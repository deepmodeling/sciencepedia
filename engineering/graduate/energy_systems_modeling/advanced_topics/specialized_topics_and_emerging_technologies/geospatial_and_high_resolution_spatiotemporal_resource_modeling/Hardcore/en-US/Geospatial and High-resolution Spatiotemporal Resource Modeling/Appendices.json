{
    "hands_on_practices": [
        {
            "introduction": "Accurate wind resource assessment depends critically on knowing the wind speed at the turbine's hub height, which is often not directly measured. This practice will guide you through a physically-grounded vertical extrapolation using Monin-Obukhov Similarity Theory, which accounts for atmospheric stability. Mastering this technique is a crucial skill for moving beyond simplistic power-law models and achieving higher fidelity in wind energy modeling .",
            "id": "4093433",
            "problem": "You are tasked with implementing a vertical wind speed extrapolation using the framework of Monin–Obukhov similarity theory (MOST) for the atmospheric surface layer, suitable for geospatial and high-resolution spatiotemporal resource modeling. Start from the MOST gradient relation that links the mean wind speed profile to surface-layer turbulence under horizontally homogeneous conditions. Specifically, take as fundamental the definition that the vertical gradient of the mean horizontal wind speed $\\bar{v}(z)$ obeys\n$$\n\\frac{d\\,\\bar{v}}{d z} = \\frac{u_*}{\\kappa\\, z}\\,\\phi_m\\!\\left(\\frac{z}{L}\\right),\n$$\nwhere $u_*$ is the friction velocity, $\\kappa$ is the von Kármán constant, $z$ is the height above the surface, $L$ is the Monin–Obukhov length, and $\\phi_m$ is the dimensionless stability function for momentum. Use the physical boundary condition that the mean wind speed at the aerodynamic roughness length $z_0$ is zero, that is, $\\bar{v}(z_0)=0$. Assume horizontally homogeneous and stationary conditions, with constant fluxes in the surface layer, and neglect displacement height. The von Kármán constant is $\\kappa = 0.4$.\n\nFor the stability function $\\phi_m(\\zeta)$, where $\\zeta = z/L$, use the widely accepted Businger–Dyer forms:\n- For stable stratification ($\\zeta > 0$), take $\\phi_m(\\zeta) = 1 + 5 \\zeta$.\n- For neutral stratification (limit $\\zeta \\to 0$), take $\\phi_m(\\zeta) = 1$.\n- For unstable stratification ($\\zeta < 0$), take $\\phi_m(\\zeta) = (1 - 16 \\zeta)^{-1/4}$.\n\nYour tasks are:\n1. Derive, by integrating the gradient relation from $z_0$ to a general height $z$, an expression for $\\bar{v}(z)$ that is valid for all three stability regimes and reduces to the classical logarithmic wind profile under neutral stratification.\n2. Show how to compute $u_*$ from a wind speed measurement $\\bar{v}(z_{\\mathrm{ref}})$ at a reference height $z_{\\mathrm{ref}}$ for given $z_0$ and $L$.\n3. Using the derived expressions, compute the hub-height wind speed $\\bar{v}(z_h)$ given inputs $(z_0, z_{\\mathrm{ref}}, z_h, \\bar{v}(z_{\\mathrm{ref}}), L)$, with $\\kappa = 0.4$.\n\nImplement a program that evaluates $\\bar{v}(z_h)$ in meters per second for the following test suite of parameter sets. Treat the neutral stratification case by taking $L$ to be a very large magnitude number and implementing the neutral limit consistently. Use the following four test cases:\n\n- Case A (neutral, typical short vegetation): $z_0 = 0.03$ m, $z_{\\mathrm{ref}} = 10$ m, $z_h = 100$ m, $\\bar{v}(z_{\\mathrm{ref}}) = 6.0$ m/s, $L = 1\\times 10^{9}$ m.\n- Case B (unstable, smooth water): $z_0 = 0.0002$ m, $z_{\\mathrm{ref}} = 10$ m, $z_h = 120$ m, $\\bar{v}(z_{\\mathrm{ref}}) = 8.0$ m/s, $L = -50.0$ m.\n- Case C (stable, forested terrain): $z_0 = 1.0$ m, $z_{\\mathrm{ref}} = 30$ m, $z_h = 80$ m, $\\bar{v}(z_{\\mathrm{ref}}) = 7.0$ m/s, $L = 200.0$ m.\n- Case D (slightly stable, urban roughness): $z_0 = 2.0$ m, $z_{\\mathrm{ref}} = 20$ m, $z_h = 150$ m, $\\bar{v}(z_{\\mathrm{ref}}) = 5.0$ m/s, $L = 100.0$ m.\n\nRequirements for implementation:\n- Use the integration of the MOST gradient relation to construct $\\bar{v}(z)$, expressing the result in terms of an appropriately defined integrated stability correction. Ensure that the neutral limit is recovered when $L \\to \\infty$.\n- Compute the friction velocity $u_*$ using the measurement at $z_{\\mathrm{ref}}$ and then compute $\\bar{v}(z_h)$ for each case.\n- Express all final answers in meters per second and round each to three decimals. The program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D]$, where each $\\text{result}_\\cdot$ is a float rounded to three decimals. There must be no other printed text.\n\nYour program must be complete and runnable as provided, require no user input, and use only the specified environment.",
            "solution": "The problem requires the implementation of a vertical wind speed extrapolation model based on Monin–Obukhov Similarity Theory (MOST). The process begins with the validation of the problem statement.\n\n### Step 1: Extract Givens\n- **Governing Differential Equation:** The vertical gradient of the mean horizontal wind speed, $\\bar{v}(z)$, is given by $\\frac{d\\,\\bar{v}}{d z} = \\frac{u_*}{\\kappa\\, z}\\,\\phi_m\\!\\left(\\frac{z}{L}\\right)$.\n- **Parameters and Variables:**\n    - $u_*$: friction velocity.\n    - $\\kappa$: von Kármán constant, given as $0.4$.\n    - $z$: height above the ground.\n    - $L$: Monin–Obukhov length.\n    - $\\phi_m(\\zeta)$: dimensionless stability function for momentum, where $\\zeta = z/L$.\n    - $z_0$: aerodynamic roughness length.\n- **Boundary Condition:** $\\bar{v}(z_0) = 0$.\n- **Businger–Dyer Forms for $\\phi_m(\\zeta)$:**\n    - Stable ($\\zeta > 0$): $\\phi_m(\\zeta) = 1 + 5 \\zeta$.\n    - Neutral ($\\zeta \\to 0$): $\\phi_m(\\zeta) = 1$.\n    - Unstable ($\\zeta < 0$): $\\phi_m(\\zeta) = (1 - 16 \\zeta)^{-1/4}$.\n- **Input Data Sets:**\n    - Case A: $(z_0, z_{\\mathrm{ref}}, z_h, \\bar{v}(z_{\\mathrm{ref}}), L) = (0.03, 10, 100, 6.0, 1\\times 10^9)$.\n    - Case B: $(z_0, z_{\\mathrm{ref}}, z_h, \\bar{v}(z_{\\mathrm{ref}}), L) = (0.0002, 10, 120, 8.0, -50.0)$.\n    - Case C: $(z_0, z_{\\mathrm{ref}}, z_h, \\bar{v}(z_{\\mathrm{ref}}), L) = (1.0, 30, 80, 7.0, 200.0)$.\n    - Case D: $(z_0, z_{\\mathrm{ref}}, z_h, \\bar{v}(z_{\\mathrm{ref}}), L) = (2.0, 20, 150, 5.0, 100.0)$.\n- **Output Requirement:** A single-line list of results for each case, `[result_A,result_B,result_C,result_D]`, with each result rounded to three decimal places.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in established atmospheric boundary layer physics (Monin–Obukhov Similarity Theory). The provided equations, constants ($\\kappa$), and stability functions ($\\phi_m$) are standard in micrometeorology. The problem is well-posed, providing a differential equation and boundary condition, leading to a unique solution. The input data for all test cases are physically realistic for the specified conditions (e.g., terrain roughness, stability). The problem statement is objective, precise, and contains no contradictions or ambiguities. It is directly relevant to wind resource modeling. Consequently, the problem is deemed **valid**.\n\n### Step 3: Derivation of the Wind Profile\nThe wind speed $\\bar{v}(z)$ is found by integrating the gradient relation from the aerodynamic roughness length $z_0$ to an arbitrary height $z$:\n$$\n\\int_{\\bar{v}(z_0)}^{\\bar{v}(z)} d\\bar{v}' = \\int_{z_0}^{z} \\frac{u_*}{\\kappa\\, z'}\\,\\phi_m\\!\\left(\\frac{z'}{L}\\right) dz'\n$$\nWith the boundary condition $\\bar{v}(z_0)=0$, this yields:\n$$\n\\bar{v}(z) = \\frac{u_*}{\\kappa} \\int_{z_0}^{z} \\frac{1}{z'}\\,\\phi_m\\!\\left(\\frac{z'}{L}\\right) dz'\n$$\nThis can be expressed using the integrated stability correction function, $\\Psi_m(\\zeta)$, defined as $\\Psi_m(\\zeta) = \\int_{0}^{\\zeta} \\frac{1-\\phi_m(\\zeta')}{\\zeta'}d\\zeta'$. The wind profile equation becomes:\n$$\n\\bar{v}(z) = \\frac{u_*}{\\kappa} \\left[ \\ln\\left(\\frac{z}{z_0}\\right) - \\left(\\Psi_m\\left(\\frac{z}{L}\\right) - \\Psi_m\\left(\\frac{z_0}{L}\\right)\\right) \\right]\n$$\nWe now derive the form of $\\Psi_m(\\zeta)$ for each stability regime.\n\n- **Neutral Stratification ($\\zeta \\to 0$):**\n  $\\phi_m(\\zeta) = 1$. The integrand for $\\Psi_m(\\zeta)$ is zero, so $\\Psi_m(\\zeta) = 0$. The profile reduces to the logarithmic wind profile:\n  $$\n  \\bar{v}(z) = \\frac{u_*}{\\kappa} \\ln\\left(\\frac{z}{z_0}\\right)\n  $$\n\n- **Stable Stratification ($\\zeta > 0$):**\n  $\\phi_m(\\zeta) = 1 + 5\\zeta$.\n  $$\n  \\Psi_m(\\zeta) = \\int_{0}^{\\zeta} \\frac{1 - (1 + 5\\zeta')}{\\zeta'} d\\zeta' = \\int_{0}^{\\zeta} -5 \\, d\\zeta' = -5\\zeta\n  $$\n  The stability correction term in the profile equation is $-\\left(\\Psi_m(z/L) - \\Psi_m(z_0/L)\\right) = -(-5z/L - (-5z_0/L)) = 5(z-z_0)/L$. However, for consistency and direct integration, it is simpler to integrate the full expression:\n  $$\n  \\int_{z_0}^{z} \\frac{1+5z'/L}{z'}dz' = \\left[\\ln(z') + \\frac{5z'}{L}\\right]_{z_0}^z = \\ln\\left(\\frac{z}{z_0}\\right) + \\frac{5(z-z_0)}{L}\n  $$\n  Thus, a more direct expression for the term in brackets in the profile equation is $\\ln(z/z_0) + 5(z-z_0)/L$. Our definition of $\\Psi_m$ leading to a correction of $-(\\Psi_m(z/L) - \\Psi_m(z_0/L))$ gives the same result.\n\n- **Unstable Stratification ($\\zeta < 0$):**\n  $\\phi_m(\\zeta)=(1-16\\zeta)^{-1/4}$. The integration of $\\frac{1-\\phi_m(\\zeta')}{\\zeta'}$ yields a standard, albeit complex, form. Let $x = (1-16\\zeta)^{1/4}$. The resulting integrated stability function is:\n  $$\n  \\Psi_m(\\zeta) = 2\\ln\\left(\\frac{1+x}{2}\\right) + \\ln\\left(\\frac{1+x^2}{2}\\right) - 2\\arctan(x) + \\frac{\\pi}{2}\n  $$\n\n### Algorithmic Design for Solution\nLet $F(z, z_0, L)$ be the integrated term in the wind profile equation, scaled by $\\kappa$:\n$$\nF(z, z_0, L) = \\ln\\left(\\frac{z}{z_0}\\right) - \\left(\\Psi_m\\left(\\frac{z}{L}\\right) - \\Psi_m\\left(\\frac{z_0}{L}\\right)\\right)\n$$\nThen the wind profile is $\\bar{v}(z) = \\frac{u_*}{\\kappa} F(z, z_0, L)$.\n\nTo solve the problem, we follow a two-step process:\n1.  **Compute Friction Velocity ($u_*$):**\n    Using the known wind speed $\\bar{v}(z_{\\mathrm{ref}})$ at a reference height $z_{\\mathrm{ref}}$, we can solve for $u_*$:\n    $$\n    u_* = \\frac{\\kappa \\, \\bar{v}(z_{\\mathrm{ref}})}{F(z_{\\mathrm{ref}}, z_0, L)}\n    $$\n\n2.  **Compute Hub-Height Wind Speed ($\\bar{v}(z_h)$):**\n    Using the calculated $u_*$, we find the wind speed at the hub height $z_h$:\n    $$\n    \\bar{v}(z_h) = \\frac{u_*}{\\kappa} F(z_h, z_0, L)\n    $$\n\nCombining these two steps, we can compute $\\bar{v}(z_h)$ directly from $\\bar{v}(z_{\\mathrm{ref}})$:\n$$\n\\bar{v}(z_h) = \\bar{v}(z_{\\mathrm{ref}}) \\frac{F(z_h, z_0, L)}{F(z_{\\mathrm{ref}}, z_0, L)}\n$$\nThis ratio method avoids the intermediate calculation of $u_*$ and is numerically stable. The implementation requires constructing a function to compute $F(z, z_0, L)$ that correctly selects the stability correction based on the sign and magnitude of $L$. The neutral case is handled by using a large-magnitude $L$, where $\\zeta \\approx 0$ and thus $\\Psi_m(\\zeta) \\approx 0$. A threshold for $|L|$ (e.g., $10^6$) establishes the practical boundary for neutral conditions.\n\nThe program will implement this logic by defining a function for $\\Psi_m(\\zeta)$ for each non-neutral regime and a main function that calculates the final ratio for each test case. The results are then formatted as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for hub-height wind speed using Monin-Obukhov Similarity Theory.\n    \"\"\"\n\n    def psi_m_unstable(zeta):\n        \"\"\"\n        Calculates the integrated stability correction function Psi_m for unstable conditions.\n        zeta = z/L, where zeta < 0.\n        \"\"\"\n        if zeta >= 0:\n            # This function is not defined for zeta >= 0. Return 0 as a safe fallback.\n            return 0.0\n        x = (1 - 16 * zeta)**0.25\n        term1 = 2 * np.log((1 + x) / 2)\n        term2 = np.log((1 + x**2) / 2)\n        term3 = -2 * np.arctan(x)\n        term4 = np.pi / 2\n        return term1 + term2 + term3 + term4\n\n    def psi_m_stable(zeta):\n        \"\"\"\n        Calculates the integrated stability correction function Psi_m for stable conditions.\n        zeta = z/L, where zeta > 0.\n        \"\"\"\n        if zeta <= 0:\n            # This function is not defined for zeta <= 0. Return 0 as a safe fallback.\n            return 0.0\n        return -5.0 * zeta\n\n    def get_profile_integral_term(z, z0, L):\n        \"\"\"\n        Computes the integrated wind profile term F(z, z0, L).\n        F(z, z0, L) = ln(z/z0) - (Psi_m(z/L) - Psi_m(z0/L))\n        \"\"\"\n        log_term = np.log(z / z0)\n\n        # A large L signifies neutral conditions. A threshold is used to handle this numerically.\n        if abs(L) > 1e6:  # Neutral condition threshold\n            psi_m_z = 0.0\n            psi_m_z0 = 0.0\n        elif L > 0:  # Stable conditions\n            zeta_z = z / L\n            zeta_z0 = z0 / L\n            psi_m_z = psi_m_stable(zeta_z)\n            psi_m_z0 = psi_m_stable(zeta_z0)\n        else:  # Unstable conditions (L < 0)\n            zeta_z = z / L\n            zeta_z0 = z0 / L\n            psi_m_z = psi_m_unstable(zeta_z)\n            psi_m_z0 = psi_m_unstable(zeta_z0)\n\n        stability_correction = psi_m_z - psi_m_z0\n        return log_term - stability_correction\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (neutral, typical short vegetation)\n        {'z0': 0.03, 'z_ref': 10, 'z_h': 100, 'v_ref': 6.0, 'L': 1e9},\n        # Case B (unstable, smooth water)\n        {'z0': 0.0002, 'z_ref': 10, 'z_h': 120, 'v_ref': 8.0, 'L': -50.0},\n        # Case C (stable, forested terrain)\n        {'z0': 1.0, 'z_ref': 30, 'z_h': 80, 'v_ref': 7.0, 'L': 200.0},\n        # Case D (slightly stable, urban roughness)\n        {'z0': 2.0, 'z_ref': 20, 'z_h': 150, 'v_ref': 5.0, 'L': 100.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        z0 = case['z0']\n        z_ref = case['z_ref']\n        z_h = case['z_h']\n        v_ref = case['v_ref']\n        L = case['L']\n\n        # Calculate the integrated terms for reference and hub heights\n        F_ref = get_profile_integral_term(z_ref, z0, L)\n        F_h = get_profile_integral_term(z_h, z0, L)\n\n        # Calculate hub-height wind speed using the ratio method\n        v_h = v_ref * (F_h / F_ref)\n        \n        # Round to three decimal places and store the result\n        results.append(f\"{v_h:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once high-resolution resource data like wind speed or solar irradiance is available, the next essential step is to translate it into electrical energy output. This practice guides you through deriving and implementing performance models for both wind turbines and photovoltaic systems from first principles, accounting for operational limits and environmental factors. You will apply these models to calculate the capacity factor, a vital, standardized metric for evaluating the productivity of generation assets in energy system analysis .",
            "id": "4093383",
            "problem": "A geospatial and high-resolution spatiotemporal resource modeling workflow often requires converting hourly resource series into capacity factor fields for wind turbines and photovoltaic systems. Starting from fundamental physical relations, derive algorithmic methods that map an hourly wind speed series $v(t)$ to turbine power output via a physically motivated power curve, and an hourly plane-of-array irradiance series $POA(t)$ (denoted as $G(t)$) and ambient temperature series $T_{\\mathrm{amb}}(t)$ to photovoltaic power output via a temperature-adjusted performance model. Use these to compute the capacity factor for each site as the ratio of generated energy to the energy that would have been produced at rated power over the same period. The capacity factor is dimensionless and must be expressed as a decimal.\n\nYour derivations must begin from a valid fundamental base. For wind, begin from the kinetic energy flux through an area and the notion that the turbine power curve enforces cut-in, rated, and cut-out behavior. For photovoltaics, begin from plane-of-array irradiance conversion to direct current power via module efficiency at Standard Test Conditions and a linear temperature coefficient, with cell temperature estimated from the Nominal Operating Cell Temperature. No shortcut formulas should be assumed; derive each mapping logically from these bases. Ensure scientific realism in all algorithmic choices.\n\nUnits must be used as follows:\n- Wind speed in $\\mathrm{m/s}$.\n- Irradiance in $\\mathrm{W/m^2}$.\n- Ambient and cell temperatures in °C.\n- Power in $\\mathrm{kW}$.\n- Capacity factor as a dimensionless decimal.\n\nDefine the capacity factor for a time series of $N$ hourly samples as $CF = \\dfrac{\\sum_{t=1}^{N} P(t)}{P_{\\mathrm{rated}} \\cdot N}$, where $P(t)$ is the hour-$t$ power and $P_{\\mathrm{rated}}$ is the rated power. This definition is universally applicable; when the provided series spans a full year, it yields the annual capacity factor.\n\nImplement the derived methods and compute capacity factors for the following test suite, each case representing a distinct site or grid cell:\n\n- Wind Case A (happy path):\n  - Rated power $P_{\\mathrm{rated}} = 3000\\,\\mathrm{kW}$.\n  - Cut-in speed $v_{\\mathrm{ci}} = 3\\,\\mathrm{m/s}$.\n  - Rated speed $v_{\\mathrm{r}} = 12\\,\\mathrm{m/s}$.\n  - Cut-out speed $v_{\\mathrm{co}} = 25\\,\\mathrm{m/s}$.\n  - Hourly wind speeds $v(t)$ for $N=10$ hours: $[0, 2.5, 3, 6, 10, 12, 15, 24, 26, 8]$ in $\\mathrm{m/s}$.\n\n- Wind Case B (edge case, always below cut-in):\n  - Rated power $P_{\\mathrm{rated}} = 3000\\,\\mathrm{kW}$.\n  - Cut-in speed $v_{\\mathrm{ci}} = 3\\,\\mathrm{m/s}$.\n  - Rated speed $v_{\\mathrm{r}} = 12\\,\\mathrm{m/s}$.\n  - Cut-out speed $v_{\\mathrm{co}} = 25\\,\\mathrm{m/s}$.\n  - Hourly wind speeds $v(t)$ for $N=10$ hours: $[0, 1, 2, 2.9, 0.5, 2.8, 2.999, 2, 1.5, 0]$ in $\\mathrm{m/s}$.\n\n- Photovoltaic Case C (day-night variation, no clipping):\n  - Rated power $P_{\\mathrm{rated}} = 500\\,\\mathrm{kW}$.\n  - Reference module efficiency at Standard Test Conditions $\\eta_{\\mathrm{ref}} = 0.18$.\n  - Power temperature coefficient $\\beta = -0.004\\,^{\\circ}\\text{C}^{-1}$.\n  - Nominal Operating Cell Temperature $NOCT = 45\\,^\\circ\\mathrm{C}$.\n  - Hourly plane-of-array irradiance $G(t)$ for $N=10$ hours: $[0, 0, 200, 400, 600, 800, 1000, 800, 400, 0]$ in $\\mathrm{W/m^2}$.\n  - Hourly ambient temperature $T_{\\mathrm{amb}}(t)$ for $N=10$ hours: $[15, 15, 16, 17, 18, 20, 22, 24, 22, 18]$ in °C.\n\n- Photovoltaic Case D (high irradiance with inverter clipping):\n  - Rated power $P_{\\mathrm{rated}} = 1000\\,\\mathrm{kW}$.\n  - Reference module efficiency at Standard Test Conditions $\\eta_{\\mathrm{ref}} = 0.18$.\n  - Power temperature coefficient $\\beta = -0.004\\,^{\\circ}\\text{C}^{-1}$.\n  - Nominal Operating Cell Temperature $NOCT = 45\\,^\\circ\\mathrm{C}$.\n  - Hourly plane-of-array irradiance $G(t)$ for $N=10$ hours: $[0, 300, 600, 900, 1100, 1200, 1100, 900, 600, 300]$ in $\\mathrm{W/m^2}$.\n  - Hourly ambient temperature $T_{\\mathrm{amb}}(t)$ for $N=10$ hours: $[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]$ in °C.\n\nYour program should produce a single line of output containing the four capacity factor values corresponding to the cases above, rounded to six decimal places, as a comma-separated list enclosed in square brackets, for example $[x_1, x_2, x_3, x_4]$.",
            "solution": "The problem requires the derivation and implementation of algorithmic methods for calculating the capacity factor of wind and photovoltaic (PV) power generation systems from hourly time series data. The derivation must originate from fundamental physical principles as specified.\n\nFirst, we address the wind turbine model. The power available in the wind derives from the kinetic energy of moving air. The kinetic energy $E_k$ of an air mass $m$ moving at speed $v$ is given by $E_k = \\frac{1}{2}mv^2$. The power is the rate of energy flow. Considering a stream of air passing through a turbine's rotor area $A$ in time $\\Delta t$, the volume of air is $V = A \\cdot v \\cdot \\Delta t$. With air density $\\rho$, the mass is $m = \\rho V = \\rho A v \\Delta t$. The kinetic energy flux, or power in the wind, is therefore $P_{\\text{wind}} = \\frac{E_k}{\\Delta t} = \\frac{1}{2}\\rho A v^3$. This establishes that the available power is proportional to the cube of the wind speed, i.e., $P_{\\text{wind}} \\propto v^3$.\n\nA real wind turbine's electrical power output, $P(t)$, is described by a power curve which is a function of the instantaneous wind speed $v(t)$. This curve is defined by four operational regions based on the cut-in speed $v_{\\mathrm{ci}}$, rated speed $v_{\\mathrm{r}}$, and cut-out speed $v_{\\mathrm{co}}$.\n1.  For $v(t) < v_{\\mathrm{ci}}$, the wind speed is insufficient to overcome the turbine's mechanical and electrical losses, so the power output is zero: $P(t) = 0$.\n2.  For $v_{\\mathrm{ci}} \\le v(t) < v_{\\mathrm{r}}$, the turbine generates power. Following the physical motivation that extracted power should relate to the available power in the wind, the output in this region is modeled as a function of $v(t)^3$. A common and physically consistent model that satisfies the boundary conditions $P(v_{\\mathrm{ci}}) = 0$ and $P(v_{\\mathrm{r}}) = P_{\\mathrm{rated}}$ is a scaled cubic function:\n    $$P(t) = P_{\\mathrm{rated}} \\cdot \\left( \\frac{v(t)^3 - v_{\\mathrm{ci}}^3}{v_{\\mathrm{r}}^3 - v_{\\mathrm{ci}}^3} \\right)$$\n    This ensures a smooth, physically-based power ramp-up.\n3.  For $v_{\\mathrm{r}} \\le v(t) < v_{\\mathrm{co}}$, the turbine's control system limits the output to its rated power $P_{\\mathrm{rated}}$ to protect the generator and power electronics. Thus, $P(t) = P_{\\mathrm{rated}}$.\n4.  For $v(t) \\ge v_{\\mathrm{co}}$, the turbine shuts down to prevent structural damage from extreme wind loads. The power output drops to zero: $P(t) = 0$.\n\nCombining these regions, the complete algorithmic mapping from $v(t)$ to $P(t)$ for a wind turbine is:\n$$\nP(t) = \n\\begin{cases} \n0 & \\text{if } v(t) < v_{\\mathrm{ci}} \\text{ or } v(t) \\ge v_{\\mathrm{co}} \\\\\nP_{\\mathrm{rated}} \\cdot \\left(\\frac{v(t)^3 - v_{\\mathrm{ci}}^3}{v_{\\mathrm{r}}^3 - v_{\\mathrm{ci}}^3}\\right) & \\text{if } v_{\\mathrm{ci}} \\le v(t) < v_{\\mathrm{r}} \\\\\nP_{\\mathrm{rated}} & \\text{if } v_{\\mathrm{r}} \\le v(t) < v_{\\mathrm{co}}\n\\end{cases}\n$$\n\nNext, we address the photovoltaic (PV) system model. The power generated by a PV system depends on the incoming solar irradiance, the system's area, and its conversion efficiency. The rated power, $P_{\\mathrm{rated}}$, is specified at Standard Test Conditions (STC), which are a reference irradiance $G_{\\mathrm{ref}} = 1000\\,\\mathrm{W/m^2}$ and a reference cell temperature $T_{\\mathrm{ref}} = 25\\,^\\circ\\mathrm{C}$. At these conditions, the power is $P_{\\mathrm{rated}} = G_{\\mathrm{ref}} \\cdot A_{\\mathrm{sys}} \\cdot \\eta_{\\mathrm{ref}}$, where $A_{\\mathrm{sys}}$ is the total system area and $\\eta_{\\mathrm{ref}}$ is the reference module efficiency. We must handle units carefully; if $P_{\\mathrm{rated}}$ is in $\\mathrm{kW}$, we convert it to $\\mathrm{W}$ by multiplying by $1000$. The effective area of the system can be derived as $A_{\\mathrm{sys}} = \\frac{1000 \\cdot P_{\\mathrm{rated}}}{G_{\\mathrm{ref}} \\cdot \\eta_{\\mathrm{ref}}}$.\nThe power generated under an arbitrary plane-of-array irradiance $G(t)$, without considering temperature effects, would be $P_{\\text{potential}}(t) = G(t) \\cdot A_{\\mathrm{sys}} \\cdot \\eta_{\\mathrm{ref}}$. Substituting the expression for $A_{\\mathrm{sys}}$ and using $G_{\\mathrm{ref}} = 1000\\,\\mathrm{W/m^2}$:\n$$P_{\\text{potential}}(t) = G(t) \\cdot \\left(\\frac{1000 \\cdot P_{\\mathrm{rated}}}{1000 \\cdot \\eta_{\\mathrm{ref}}}\\right) \\cdot \\eta_{\\mathrm{ref}} = P_{\\mathrm{rated}} \\cdot \\frac{G(t)}{1000}$$\nThis provides a direct scaling of the rated power by the GHI ratio, with $P(t)$ having the same units as $P_{\\mathrm{rated}}$ (kW).\n\nThe module's efficiency, and thus its power output, is sensitive to its operating temperature, $T_{\\mathrm{cell}}(t)$. First, we must estimate $T_{\\mathrm{cell}}(t)$. The problem specifies using the Nominal Operating Cell Temperature ($NOCT$) model. $NOCT$ is the cell temperature under conditions of $G_{\\mathrm{NOCT}} = 800\\,\\mathrm{W/m^2}$ and $T_{\\mathrm{amb,NOCT}} = 20\\,^\\circ\\mathrm{C}$. The cell temperature rises above ambient temperature in proportion to the incident irradiance. The model is:\n$$T_{\\mathrm{cell}}(t) = T_{\\mathrm{amb}}(t) + (NOCT - T_{\\mathrm{amb,NOCT}}) \\cdot \\frac{G(t)}{G_{\\mathrm{NOCT}}} = T_{\\mathrm{amb}}(t) + (NOCT - 20) \\cdot \\frac{G(t)}{800}$$\nwhere all temperatures are in $^\\circ\\mathrm{C}$.\n\nNext, we account for the temperature's effect on power output using the given linear power temperature coefficient, $\\beta$. This coefficient modifies the power output relative to the reference temperature $T_{\\mathrm{ref}} = 25\\,^\\circ\\mathrm{C}$. The total DC power generated, $P_{\\mathrm{DC}}(t)$, is then:\n$$P_{\\mathrm{DC}}(t) = P_{\\text{potential}}(t) \\cdot [1 + \\beta(T_{\\mathrm{cell}}(t) - T_{\\mathrm{ref}})] = P_{\\mathrm{rated}} \\cdot \\frac{G(t)}{1000} \\cdot [1 + \\beta(T_{\\mathrm{cell}}(t) - 25)]$$\nSince $\\beta$ is typically negative for crystalline silicon PV modules, higher cell temperatures lead to lower power output.\n\nFinally, the AC power delivered to the grid, $P(t)$, is limited by the inverter's maximum power output, which is assumed to be equal to the system's rated power $P_{\\mathrm{rated}}$. This phenomenon is known as inverter clipping. Therefore, the final power output is the lesser of the calculated DC power and the rated power. We also ensure power is non-negative.\n$$P(t) = \\max(0, \\min(P_{\\mathrm{DC}}(t), P_{\\mathrm{rated}}))$$\n\nFor both wind and PV systems, the capacity factor ($CF$) for a period of $N$ hours is defined as the ratio of the total energy actually generated to the maximum possible energy that could have been generated if the system operated at its rated power $P_{\\mathrm{rated}}$ for the entire period.\n$$CF = \\frac{\\sum_{t=1}^{N} P(t) \\cdot (1\\,\\text{hr})}{P_{\\mathrm{rated}} \\cdot N \\cdot (1\\,\\text{hr})} = \\frac{\\sum_{t=1}^{N} P(t)}{P_{\\mathrm{rated}} \\cdot N}$$\nUsing the derived functions for $P(t)$, we can compute the capacity factor for each of the provided test cases. All calculations will maintain power in units of $\\mathrm{kW}$ as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are needed for this problem.\n\ndef solve():\n    \"\"\"\n    Derives and implements models for wind and PV power generation to calculate\n    capacity factors for a given set of test cases.\n    \"\"\"\n\n    # --- Model Implementation ---\n\n    def calculate_wind_power_series(v_series, p_rated, v_ci, v_r, v_co):\n        \"\"\"\n        Calculates hourly power output for a wind turbine from a wind speed series.\n        \n        Args:\n            v_series (list or np.array): Hourly wind speeds in m/s.\n            p_rated (float): Rated power in kW.\n            v_ci (float): Cut-in speed in m/s.\n            v_r (float): Rated speed in m/s.\n            v_co (float): Cut-out speed in m/s.\n\n        Returns:\n            np.array: Hourly power output in kW.\n        \"\"\"\n        v = np.array(v_series, dtype=float)\n        power = np.zeros_like(v)\n\n        # Region 1: Normal operation between cut-in and rated speed\n        # P(v) = P_rated * (v^3 - v_ci^3) / (v_r^3 - v_ci^3)\n        op_mask = (v >= v_ci) & (v < v_r)\n        v_op = v[op_mask]\n        \n        # Avoid division by zero if v_r <= v_ci, though not expected for valid problems\n        v_r3_minus_v_ci3 = v_r**3 - v_ci**3\n        if v_r3_minus_v_ci3 > 0:\n            power[op_mask] = p_rated * (v_op**3 - v_ci**3) / v_r3_minus_v_ci3\n\n        # Region 2: Rated power output\n        rated_mask = (v >= v_r) & (v < v_co)\n        power[rated_mask] = p_rated\n\n        # Regions 3 & 4 (below cut-in and above cut-out) are already 0.\n        \n        return power\n\n    def calculate_pv_power_series(g_series, t_amb_series, p_rated, beta, noct):\n        \"\"\"\n        Calculates hourly power output for a PV system.\n        \n        Args:\n            g_series (list or np.array): Hourly plane-of-array irradiance in W/m^2.\n            t_amb_series (list or np.array): Hourly ambient temperature in °C.\n            p_rated (float): Rated power in kW.\n            beta (float): Power temperature coefficient in 1/°C.\n            noct (float): Nominal Operating Cell Temperature in °C.\n\n        Returns:\n            np.array: Hourly power output in kW.\n        \"\"\"\n        g = np.array(g_series, dtype=float)\n        t_amb = np.array(t_amb_series, dtype=float)\n        power = np.zeros_like(g)\n\n        # Constants from PV modeling standards\n        G_REF = 1000.0  # W/m^2 (STC irradiance)\n        T_REF = 25.0    # °C (STC cell temperature)\n        G_NOCT = 800.0  # W/m^2 (NOCT irradiance)\n        T_AMB_NOCT = 20.0 # °C (NOCT ambient temperature)\n\n        # Calculate only for hours with sunlight\n        sunlight_mask = g > 0\n        g_sun = g[sunlight_mask]\n        t_amb_sun = t_amb[sunlight_mask]\n\n        # 1. Calculate cell temperature using the NOCT model\n        t_cell = t_amb_sun + (noct - T_AMB_NOCT) * g_sun / G_NOCT\n\n        # 2. Calculate DC power with temperature adjustment\n        # P_potential = P_rated * G / G_ref\n        # P_dc = P_potential * (1 + beta * (T_cell - T_ref))\n        p_dc = (p_rated * g_sun / G_REF) * (1 + beta * (t_cell - T_REF))\n        \n        # 3. Apply inverter clipping and ensure non-negative power\n        p_final = np.maximum(0, np.minimum(p_dc, p_rated))\n\n        power[sunlight_mask] = p_final\n        return power\n\n    # --- Test Case Definitions ---\n    \n    test_cases = [\n        {\n            \"type\": \"wind\",\n            \"params\": {\n                \"v_series\": [0, 2.5, 3, 6, 10, 12, 15, 24, 26, 8],\n                \"p_rated\": 3000.0, \"v_ci\": 3.0, \"v_r\": 12.0, \"v_co\": 25.0\n            }\n        },\n        {\n            \"type\": \"wind\",\n            \"params\": {\n                \"v_series\": [0, 1, 2, 2.9, 0.5, 2.8, 2.999, 2, 1.5, 0],\n                \"p_rated\": 3000.0, \"v_ci\": 3.0, \"v_r\": 12.0, \"v_co\": 25.0\n            }\n        },\n        {\n            \"type\": \"pv\",\n            \"params\": {\n                \"g_series\": [0, 0, 200, 400, 600, 800, 1000, 800, 400, 0],\n                \"t_amb_series\": [15, 15, 16, 17, 18, 20, 22, 24, 22, 18],\n                \"p_rated\": 500.0, \"beta\": -0.004, \"noct\": 45.0\n            }\n        },\n        {\n            \"type\": \"pv\",\n            \"params\": {\n                \"g_series\": [0, 300, 600, 900, 1100, 1200, 1100, 900, 600, 300],\n                \"t_amb_series\": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                \"p_rated\": 1000.0, \"beta\": -0.004, \"noct\": 45.0\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        params = case[\"params\"]\n        p_rated = params[\"p_rated\"]\n        \n        if case[\"type\"] == \"wind\":\n            power_series = calculate_wind_power_series(**params)\n            N = len(params[\"v_series\"])\n        elif case[\"type\"] == \"pv\":\n            power_series = calculate_pv_power_series(**params)\n            N = len(params[\"g_series\"])\n        \n        # Calculate Capacity Factor\n        # CF = sum(P_t) / (P_rated * N)\n        total_energy_generated = np.sum(power_series)\n        max_possible_energy = p_rated * N\n        \n        if max_possible_energy == 0:\n            capacity_factor = 0.0\n        else:\n            capacity_factor = total_energy_generated / max_possible_energy\n            \n        results.append(capacity_factor)\n\n    # Format results to six decimal places for the final output\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "High-resolution resource models typically generate data at discrete points, which are then aggregated into larger grid cells for regional analysis or system planning. This exercise explores a critical and often overlooked aspect of this process: the impact of geodetic datum shifts on spatial aggregation. You will quantify how a small, meter-scale coordinate discrepancy between datums like WGS84 and NAD83 can alter aggregated resource statistics, highlighting the importance of rigorous data management in geospatial modeling .",
            "id": "4093404",
            "problem": "You are tasked with formalizing and quantifying the effect of geodetic datum shifts on aggregated energy resource mapping. Distinguish the World Geodetic System 1984 (WGS84) from the North American Datum 1983 (NAD83) in terms of their geodetic definitions and realizations, and derive how a horizontal translation of magnitude $1\\,\\mathrm{m}$ in a projected planar coordinate system can alter capacity factor aggregation when points are grouped into polygons of area $100\\,\\mathrm{km}^2$. For algorithmic tractability and scientific realism over a local region, assume a locally planar map projection consistent with the Universal Transverse Mercator (UTM) family where small horizontal shifts are preserved as planar translations in meters.\n\nFundamental bases you must use include the definition of a geodetic datum as a specification of an Earth-centered Earth-fixed coordinate reference frame and associated ellipsoid, the notion that datum differences can be represented by a seven-parameter Helmert transform, and the definition of capacity factor as a dimensionless ratio of actual energy production to maximum possible production over a period.\n\nDefine a partition of the plane into axis-aligned square polygons with area $100\\,\\mathrm{km}^2$, each having side length $L = 10{,}000\\,\\mathrm{m}$, and adopt the following membership rule to avoid ambiguity on boundaries: a point with coordinates $(x,y)$ belongs to the polygon $[x_0,x_1) \\times [y_0,y_1)$ if and only if $x_0 \\le x < x_1$ and $y_0 \\le y < y_1$. Capacity factor aggregation for a polygon is the arithmetic mean of the capacity factors of all points belonging to that polygon under the membership rule.\n\nYou must implement a program that, for each test case provided below, computes the maximum absolute change in polygon-level aggregated capacity factor caused by translating all points by the specified horizontal shift vector. Specifically, for each test case, let $\\mu_p$ denote the pre-shift mean capacity factor for polygon $p$, and let $\\mu'_p$ denote the post-shift mean after translating every point by the given vector. Compute the impact metric $I = \\max_{p} \\left| \\mu'_p - \\mu_p \\right|$ for that test case. Express all coordinates in meters, and treat all capacity factors as dimensionless decimals. The final outputs are the values of $I$ per test case, expressed as decimals rounded to six places.\n\nUse the following test suite. Each test case consists of a set of polygons, a set of resource points with associated capacity factors, and a horizontal shift vector $\\Delta \\mathbf{x} = (\\Delta x, \\Delta y)$ in meters. Polygons are axis-aligned squares of side length $10{,}000\\,\\mathrm{m}$, defined by half-open intervals $[x_0,x_1) \\times [y_0,y_1)$ as specified.\n\nTest Case $1$ (happy path, no boundary crossings):\n- Polygons: a single polygon $P_0$ with $[0,10{,}000) \\times [0,10{,}000)$.\n- Points and capacity factors: $(x,y,c)$ triplets\n  - $(5{,}000,5{,}000,0.4)$\n  - $(2{,}000,2{,}000,0.5)$\n- Shift vector: $\\Delta \\mathbf{x} = (1,0)\\,\\mathrm{m}$.\n\nTest Case $2$ (east boundary crossing between adjacent polygons):\n- Polygons: $P_0$ with $[0,10{,}000) \\times [0,10{,}000)$ and $P_1$ with $[10{,}000,20{,}000) \\times [0,10{,}000)$.\n- Points and capacity factors:\n  - $(9{,}999.6,3{,}000,0.6)$\n  - $(7{,}000,7{,}000,0.2)$\n  - $(15{,}000,5{,}000,0.8)$\n- Shift vector: $\\Delta \\mathbf{x} = (1,0)\\,\\mathrm{m}$.\n\nTest Case $3$ (north boundary crossing between adjacent polygons):\n- Polygons: $P_0$ with $[0,10{,}000) \\times [0,10{,}000)$ and $P_2$ with $[0,10{,}000) \\times [10{,}000,20{,}000)$.\n- Points and capacity factors:\n  - $(5{,}000,9{,}999.5,0.9)$\n  - $(4{,}000,2{,}000,0.1)$\n  - $(5{,}000,15{,}000,0.3)$\n- Shift vector: $\\Delta \\mathbf{x} = (0,1)\\,\\mathrm{m}$.\n\nTest Case $4$ (edge case with point exactly on a boundary and westward shift):\n- Polygons: $P_0$ with $[0,10{,}000) \\times [0,10{,}000)$ and $P_1$ with $[10{,}000,20{,}000) \\times [0,10{,}000)$.\n- Points and capacity factors:\n  - $(10{,}000.0,5{,}000,0.7)$\n  - $(8{,}000,6{,}000,0.5)$\n  - $(15{,}000,4{,}000,0.6)$\n- Shift vector: $\\Delta \\mathbf{x} = (-1,0)\\,\\mathrm{m}$.\n\nYour program should produce a single line of output containing the four impact metric values as a comma-separated list enclosed in square brackets, rounded to six decimal places, for example, $[0.000000,0.123456,0.500000,0.010000]$. No other text should be printed. The computation must be deterministic and use only the provided test suite data.",
            "solution": "The problem presented is a valid and well-posed formalization of a practical issue in geospatial data analysis, specifically within energy resource modeling. It concerns the sensitivity of aggregated spatial data to small perturbations in underlying coordinate systems, such as those arising from differences between geodetic datums like the World Geodetic System 1984 (WGS84) and the North American Datum 1983 (NAD83). While these datums are defined by complex geodetic parameters (reference ellipsoid, origin, orientation), for local-scale analysis, the difference between their realizations can often be well-approximated by a simple horizontal translation vector, as posited in the problem. The magnitude of this shift is on the order of $1\\,\\mathrm{m}$, which is physically realistic. The problem asks us to quantify the maximum impact of such a shift on the mean capacity factor aggregated over a regular grid of square polygons.\n\nThe core scientific principle being investigated is the effect of boundary conditions in discrete spatial aggregation. When continuous point data are aggregated into discrete zones (polygons), points lying near a boundary are susceptible to being reassigned to an adjacent zone if their coordinates are slightly perturbed. This reassignment alters the composition of the point sets within the affected polygons, thereby changing their aggregated statistics. The problem provides a rigorous framework to analyze this effect.\n\nOur algorithm will systematically compute the change in aggregated values by following a precise sequence of steps based on the provided definitions.\n\n**Algorithmic Formulation**\n\n1.  **System Definition**: The system consists of a set of resource data points $S = \\{(x_i, y_i, c_i)\\}_{i=1}^N$, where $(x_i, y_i)$ are planar coordinates in meters and $c_i$ is the dimensionless capacity factor. The plane is partitioned into a grid of axis-aligned square polygons, each of side length $L = 10{,}000\\,\\mathrm{m}$ and area $100\\,\\mathrm{km}^2$.\n\n2.  **Polygon Membership Rule**: A point with coordinates $(x,y)$ is assigned to the unique polygon $P_{j,k}$ defined by the half-open interval $[jL, (j+1)L) \\times [kL, (k+1)L)$, where the integer indices $(j,k)$ are determined by the floor function:\n    $$\n    j = \\lfloor x/L \\rfloor, \\quad k = \\lfloor y/L \\rfloor\n    $$\n    This rule is unambiguous and ensures every point in the plane belongs to exactly one polygon.\n\n3.  **Aggregation Function**: The aggregated capacity factor for a polygon $p$ is the arithmetic mean of the capacity factors of all points contained within it. Let $S_p = \\{(x_i, y_i, c_i) \\in S \\mid (x_i, y_i) \\in p\\}$. The pre-shift mean capacity factor, $\\mu_p$, is:\n    $$\n    \\mu_p = \\begin{cases} \\frac{1}{|S_p|} \\sum_{(x,y,c) \\in S_p} c & \\text{if } |S_p| > 0 \\\\ 0 & \\text{if } |S_p| = 0 \\end{cases}\n    $$\n\n4.  **Coordinate Transformation**: A datum shift is modeled as a uniform horizontal translation by a vector $\\Delta \\mathbf{x} = (\\Delta x, \\Delta y)$. Each point $(x_i, y_i)$ is transformed to a new coordinate $(x'_i, y'_i)$:\n    $$\n    (x'_i, y'_i) = (x_i + \\Delta x, y_i + \\Delta y)\n    $$\n    This creates a new set of shifted points $S' = \\{(x'_i, y'_i, c_i)\\}_{i=1}^N$. Note that the capacity factor $c_i$ is an intrinsic property of the resource point and remains invariant under coordinate transformation.\n\n5.  **Post-Shift Aggregation**: The aggregation procedure is repeated for the shifted points. Let $S'_p = \\{(x'_i, y'_i, c_i) \\in S' \\mid (x'_i, y'_i) \\in p\\}$. The post-shift mean capacity factor, $\\mu'_p$, is:\n    $$\n    \\mu'_p = \\begin{cases} \\frac{1}{|S'_p|} \\sum_{(x',y',c) \\in S'_p} c & \\text{if } |S'_p| > 0 \\\\ 0 & \\text{if } |S'_p| = 0 \\end{cases}\n    $$\n\n6.  **Impact Metric**: The impact of the shift is quantified by the maximum absolute change in the mean capacity factor across all affected polygons. Let $\\mathcal{P}_{affected}$ be the set of all polygons $p$ for which either $S_p$ or $S'_p$ is non-empty. The impact metric $I$ is:\n    $$\n    I = \\max_{p \\in \\mathcal{P}_{affected}} |\\mu'_p - \\mu_p|\n    $$\n\n**Implementation Strategy**\n\nThe algorithm is implemented by processing each test case as follows:\n- Define the side length $L=10000.0$.\n- For each test case, we first compute the pre-shift aggregations. We use a dictionary to map polygon indices $(j,k)$ to a list of capacity factors.\n- We iterate through the given points, determine the polygon index for each point using the floor-division rule, and populate the dictionary.\n- From this dictionary, we compute a second dictionary mapping polygon indices to their pre-shift mean capacity factor, $\\mu_p$.\n- Next, we apply the shift vector $(\\Delta x, \\Delta y)$ to all point coordinates.\n- We repeat the aggregation process with the shifted coordinates to compute the post-shift mean capacity factors, $\\mu'_p$.\n- We then identify the set of all unique polygon indices that appeared in either the pre-shift or post-shift calculations.\n- For each of these polygons, we calculate the absolute difference $|\\mu'_p - \\mu_p|$, retrieving values from the mean dictionaries (using a default of $0$ if a polygon is empty in one of the states).\n- The maximum of these differences is the impact metric $I$ for the test case.\n\nLet us trace Test Case 2 as an example:\n- **Polygons**: $P_{0,0} = [0, 10000) \\times [0, 10000)$ and $P_{1,0} = [10000, 20000) \\times [0, 10000)$.\n- **Points**: $(9999.6, 3000, 0.6)$, $(7000, 7000, 0.2)$, $(15000, 5000, 0.8)$.\n- **Shift**: $\\Delta \\mathbf{x} = (1, 0)$.\n\n**Pre-shift analysis**:\n- Point $(9999.6, 3000)$: $\\lfloor 9999.6/10000 \\rfloor = 0$, $\\lfloor 3000/10000 \\rfloor = 0$. Belongs to $P_{0,0}$.\n- Point $(7000, 7000)$: $\\lfloor 7000/10000 \\rfloor = 0$, $\\lfloor 7000/10000 \\rfloor = 0$. Belongs to $P_{0,0}$.\n- Point $(15000, 5000)$: $\\lfloor 15000/10000 \\rfloor = 1$, $\\lfloor 5000/10000 \\rfloor = 0$. Belongs to $P_{1,0}$.\n- Pre-shift means:\n  - $\\mu_{P_{0,0}} = (0.6 + 0.2) / 2 = 0.4$.\n  - $\\mu_{P_{1,0}} = 0.8 / 1 = 0.8$.\n\n**Post-shift analysis**:\n- Shifted points: $(10000.6, 3000)$, $(7001, 7000)$, $(15001, 5000)$.\n- Point $(10000.6, 3000)$: $\\lfloor 10000.6/10000 \\rfloor = 1$. Belongs to $P_{1,0}$. (This point crossed the boundary).\n- Point $(7001, 7000)$: $\\lfloor 7001/10000 \\rfloor = 0$. Belongs to $P_{0,0}$.\n- Point $(15001, 5000)$: $\\lfloor 15001/10000 \\rfloor = 1$. Belongs to $P_{1,0}$.\n- Post-shift means:\n  - $\\mu'_{P_{0,0}} = 0.2 / 1 = 0.2$.\n  - $\\mu'_{P_{1,0}} = (0.6 + 0.8) / 2 = 0.7$.\n\n**Impact calculation**:\n- Change for $P_{0,0}$: $|\\mu'_{P_{0,0}} - \\mu_{P_{0,0}}| = |0.2 - 0.4| = 0.2$.\n- Change for $P_{1,0}$: $|\\mu'_{P_{1,0}} - \\mu_{P_{1,0}}| = |0.7 - 0.8| = 0.1$.\n- $I = \\max(0.2, 0.1) = 0.2$.\n\nThis procedure is applied to all test cases to derive the final results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        {\n            \"points\": [(5000.0, 5000.0, 0.4), (2000.0, 2000.0, 0.5)],\n            \"shift\": (1.0, 0.0)\n        },\n        {\n            \"points\": [(9999.6, 3000.0, 0.6), (7000.0, 7000.0, 0.2), (15000.0, 5000.0, 0.8)],\n            \"shift\": (1.0, 0.0)\n        },\n        {\n            \"points\": [(5000.0, 9999.5, 0.9), (4000.0, 2000.0, 0.1), (5000.0, 15000.0, 0.3)],\n            \"shift\": (0.0, 1.0)\n        },\n        {\n            \"points\": [(10000.0, 5000.0, 0.7), (8000.0, 6000.0, 0.5), (15000.0, 4000.0, 0.6)],\n            \"shift\": (-1.0, 0.0)\n        }\n    ]\n\n    L = 10000.0  # Side length of the square polygons in meters.\n\n    def get_polygon_aggregates(points, L_val):\n        \"\"\"\n        Aggregates capacity factors by polygon.\n\n        Args:\n            points (list): A list of (x, y, capacity_factor) tuples.\n            L_val (float): The side length of the polygon grid.\n\n        Returns:\n            dict: A dictionary mapping polygon indices (ix, iy) to a list of capacity factors.\n        \"\"\"\n        aggregates = {}\n        for x, y, c in points:\n            # Determine the polygon index using the floor function.\n            # This corresponds to the rule x_0 <= x < x_1.\n            ix = int(np.floor(x / L_val))\n            iy = int(np.floor(y / L_val))\n            key = (ix, iy)\n            if key not in aggregates:\n                aggregates[key] = []\n            aggregates[key].append(c)\n        return aggregates\n\n    def calculate_means(aggregates):\n        \"\"\"\n        Calculates the mean capacity factor for each polygon.\n\n        Args:\n            aggregates (dict): A dictionary mapping polygon indices to lists of factors.\n\n        Returns:\n            dict: A dictionary mapping polygon indices to mean capacity factors.\n        \"\"\"\n        means = {}\n        for key, values in aggregates.items():\n            if values:\n                means[key] = sum(values) / len(values)\n            else:\n                means[key] = 0.0\n        return means\n\n    def compute_impact_for_case(points, shift, L_val):\n        \"\"\"\n        Computes the impact metric I for a single test case.\n\n        Args:\n            points (list): A list of (x, y, capacity_factor) tuples.\n            shift (tuple): A (dx, dy) shift vector.\n            L_val (float): The side length of the polygon grid.\n\n        Returns:\n            float: The computed impact metric I.\n        \"\"\"\n        # 1. Pre-shift calculations\n        pre_shift_aggs = get_polygon_aggregates(points, L_val)\n        pre_shift_means = calculate_means(pre_shift_aggs)\n\n        # 2. Post-shift calculations\n        dx, dy = shift\n        shifted_points = [(x + dx, y + dy, c) for x, y, c in points]\n        post_shift_aggs = get_polygon_aggregates(shifted_points, L_val)\n        post_shift_means = calculate_means(post_shift_aggs)\n\n        # 3. Calculate impact metric I\n        # Get the union of all polygon keys that have points in either state.\n        all_polygon_keys = set(pre_shift_means.keys()) | set(post_shift_means.keys())\n        \n        max_abs_change = 0.0\n        for key in all_polygon_keys:\n            # Use .get(key, 0.0) to handle polygons that become empty or are newly populated.\n            mu_p = pre_shift_means.get(key, 0.0)\n            mu_p_prime = post_shift_means.get(key, 0.0)\n            abs_change = abs(mu_p_prime - mu_p)\n            if abs_change > max_abs_change:\n                max_abs_change = abs_change\n        \n        return max_abs_change\n\n    results = []\n    for case in test_cases:\n        impact_metric = compute_impact_for_case(case[\"points\"], case[\"shift\"], L)\n        results.append(impact_metric)\n\n    # Format the final output as a comma-separated list of strings,\n    # with each value rounded to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}