{
    "hands_on_practices": [
        {
            "introduction": "一阶 RC 热力学模型是温控负荷分析的基石。本练习将理论与实践相结合，指导您从建筑的材料和几何形状等物理特性中推导出其总热阻 $R$ 和热容 $C$。掌握这项技能使您能够为真实世界的建筑构建参数化模型，这是能源系统分析中的一项关键能力。",
            "id": "4130995",
            "problem": "单区建筑可以建模为温控负荷 (TCL)，其中室内空气和内部质量被集中为单一热容，而通向室外环境的围护结构路径提供热阻。从傅里叶热传导定律、牛顿对流换热定律和热容量的定义出发，推导如何从围护结构的材料和几何形状推断出住宅的总热阻和总热容。然后，为以下科学上真实的小型住宅计算其热时间常数的数量级估计值，将室内处理为充分混合，并在固定恒温器设定点附近进行线性化，同时忽略空气渗透和内部得热。\n\n几何参数和围护结构：\n- 矩形平面，楼面面积 $60$ m$^2$，尺寸为 $10$ m × $6$ m，天花板高度为 $2.5$ m。屋顶面积等于楼面面积，为 $60$ m$^2$。总墙体面积为周长乘以高度。总窗户面积为 $8$ m$^2$；剩余墙体面积为不透明部分。\n- 不透明墙体组件，从室内到室外：室内石膏板，厚度 $0.0125$ m；隔热立柱空腔，厚度 $0.09$ m；定向刨花板 (OSB) 护板，厚度 $0.012$ m；木质壁板，厚度 $0.010$ m。对所有不透明组件，使用室内和室外表面薄膜对流系数 $h_{\\text{in}}=8$ W m$^{-2}$ K$^{-1}$ 和 $h_{\\text{out}}=25$ W m$^{-2}$ K$^{-1}$。\n- 屋顶组件，从室内到室外：室内石膏板，厚度 $0.0125$ m；阁楼隔热层，厚度 $0.20$ m；OSB 护板，厚度 $0.012$ m。使用与墙体相同的 $h_{\\text{in}}$ 和 $h_{\\text{out}}$。\n- 窗户：使用总传热系数 $U_{\\text{win}}=1.8$ W m$^{-2}$ K$^{-1}$，假定其已包含表面薄膜。\n\n材料属性（使用恒定值）：\n- 石膏板导热系数 $k_{\\text{gyp}}=0.17$ W m$^{-1}$ K$^{-1}$，密度 $800$ kg m$^{-3}$，比热 $c_{p,\\text{gyp}}=1090$ J kg$^{-1}$ K$^{-1}$。\n- 隔热材料导热系数 $k_{\\text{ins}}=0.035$ W m$^{-1}$ K$^{-1}$。\n- OSB 导热系数 $k_{\\text{osb}}=0.12$ W m$^{-1}$ K$^{-1}$。\n- 木质壁板导热系数 $k_{\\text{wood}}=0.14$ W m$^{-1}$ K$^{-1}$。\n- 室内空气密度 $1.2$ kg m$^{-3}$，比热 $c_{p,\\text{air}}=1005$ J kg$^{-1}$ K$^{-1}$。\n- 混凝土地面楼板（与室内热耦合良好），厚度 $0.10$ m，密度 $2400$ kg m$^{-3}$，比热 $c_{p,\\text{conc}}=880$ J kg$^{-1}$ K$^{-1}$，面积等于楼面面积。\n- 由集中质量 $500$ kg 代表的家具，比热 $c_{p,\\text{furn}}=1500$ J kg$^{-1}$ K$^{-1}$。\n\n假设所有不透明组件的各层在厚度方向上是串联的，并且屋顶、不透明墙体和窗户与室外并联换热。将室内热容视作室内空气、不透明墙体和天花板上的室内石膏板、混凝土地板以及家具的热容之和。计算热时间常数 $\\tau$，其定义为总热阻和总热容的乘积。将最终的 $\\tau$ 以小时为单位表示，并将答案四舍五入到三位有效数字。",
            "solution": "本问题需进行验证。\n\n### 步骤 1：提取已知条件\n- **模型：** 单区建筑，作为温控负荷 (TCL)，具有集中的室内空气和内部质量（单一热容）以及围护结构热阻。\n- **任务：** 1) 从基本原理推导总热阻和总热容。2) 为特定住宅计算热时间常数 $\\tau = R C$。\n- **假设：** 室内充分混合，系统线性化，忽略空气渗透和内部得热。所有不透明组件的各层串联，围护结构各部分（屋顶、墙体、窗户）并联。\n- **几何参数：**\n    - 楼面面积：$A_{\\text{floor}} = 60$ m$^2$。\n    - 楼面尺寸：$10$ m × $6$ m。\n    - 天花板高度：$H = 2.5$ m。\n    - 屋顶面积：$A_{\\text{roof}} = A_{\\text{floor}} = 60$ m$^2$。\n    - 总墙体面积：周长乘以高度。\n    - 总窗户面积：$A_{\\text{win}} = 8$ m$^2$。\n- **不透明墙体组件：**\n    - 各层（从内到外）：石膏板 ($L_{\\text{gyp}} = 0.0125$ m)，隔热立柱空腔 ($L_{\\text{ins}} = 0.09$ m)，OSB 护板 ($L_{\\text{osb}} = 0.012$ m)，木质壁板 ($L_{\\text{wood}} = 0.010$ m)。\n    - 对流系数：$h_{\\text{in}} = 8$ W m$^{-2}$ K$^{-1}$，$h_{\\text{out}} = 25$ W m$^{-2}$ K$^{-1}$。\n- **屋顶组件：**\n    - 各层（从内到外）：石膏板 ($L_{\\text{gyp}} = 0.0125$ m)，阁楼隔热层 ($L_{\\text{attic_ins}} = 0.20$ m)，OSB 护板 ($L_{\\text{osb}} = 0.012$ m)。\n    - 对流系数：与墙体相同，$h_{\\text{in}} = 8$ W m$^{-2}$ K$^{-1}$，$h_{\\text{out}} = 25$ W m$^{-2}$ K$^{-1}$。\n- **窗户：**\n    - 总传热系数：$U_{\\text{win}} = 1.8$ W m$^{-2}$ K$^{-1}$（包含表面薄膜）。\n- **材料属性：**\n    - 石膏板：$k_{\\text{gyp}} = 0.17$ W m$^{-1}$ K$^{-1}$，$\\rho_{\\text{gyp}} = 800$ kg m$^{-3}$，$c_{p,\\text{gyp}} = 1090$ J kg$^{-1}$ K$^{-1}$。\n    - 隔热材料：$k_{\\text{ins}} = 0.035$ W m$^{-1}$ K$^{-1}$。\n    - OSB：$k_{\\text{osb}} = 0.12$ W m$^{-1}$ K$^{-1}$。\n    - 木质壁板：$k_{\\text{wood}} = 0.14$ W m$^{-1}$ K$^{-1}$。\n    - 室内空气：$\\rho_{\\text{air}} = 1.2$ kg m$^{-3}$，$c_{p,\\text{air}} = 1005$ J kg$^{-1}$ K$^{-1}$。\n    - 混凝土地板：$L_{\\text{conc}} = 0.10$ m，$\\rho_{\\text{conc}} = 2400$ kg m$^{-3}$，$c_{p,\\text{conc}} = 880$ J kg$^{-1}$ K$^{-1}$。面积为 $A_{\\text{floor}}$。\n    - 家具：$m_{\\text{furn}} = 500$ kg，$c_{p,\\text{furn}} = 1500$ J kg$^{-1}$ K$^{-1}$。\n- **热容定义：** 包括室内空气、室内石膏板（墙体和天花板）、混凝土地板和家具。\n- **输出：** 热时间常数 $\\tau$，以小时为单位，四舍五入到三位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n这个问题是科学合理的，它基于已建立的热传递原理（傅里叶热传导定律、牛顿对流换热定律）和热力学原理（热容量）。所描述的模型（一阶集总热容模型）是建筑能耗分析中一个标准且广泛使用的简化方法。提供的几何尺寸和材料属性是真实且一致的。问题是适定的，提供了计算唯一解所需的所有信息。语言客观而精确。不存在科学上不合理、不完整、矛盾或模棱两可等缺陷。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n该问题需要两部分的解答：首先是理论推导，然后是数值计算。\n\n**第 1 部分：理论推导**\n\n建筑物的总热阻 $R_{\\text{eq}}$ 和总热容 $C_{\\text{eq}}$ 是从基本原理推导出来的。\n\n**热阻, $R$**\n热阻是物质对热流的阻碍作用。对于由温差 $\\Delta T$ 驱动的给定传热速率 $\\dot{Q}$，热阻定义为 $R = \\frac{\\Delta T}{\\dot{Q}}$。\n\n1.  **传导：** 对于通过平面材料的一维稳态热流，傅里叶热传导定律为 $\\dot{Q} = -kA \\frac{dT}{dx}$，其中 $\\dot{Q}$ 是传热速率， $k$ 是导热系数， $A$ 是垂直于热流方向的面积， $\\frac{dT}{dx}$ 是温度梯度。对于厚度为 $L$、两侧温差为 $\\Delta T$ 的材料层，该式积分可得 $\\dot{Q} = kA \\frac{\\Delta T}{L}$。因此，传导热阻为 $R_{\\text{cond}} = \\frac{\\Delta T}{\\dot{Q}} = \\frac{L}{kA}$。\n\n2.  **对流：** 从面积为 $A$ 的表面到流体的牛顿对流换热定律为 $\\dot{Q} = hA \\Delta T$，其中 $h$ 是对流换热系数， $\\Delta T$ 是表面与流体之间的温差。对流热阻为 $R_{\\text{conv}} = \\frac{\\Delta T}{\\dot{Q}} = \\frac{1}{hA}$。\n\n3.  **组件的总热阻：** 对于像墙体这样的建筑围护结构组件，它由多个串联的层组成，其总热阻是各个层热阻的总和：$R_{\\text{assembly}} = \\sum_{i} R_i$。通常使用单位面积热阻 $R' = R \\cdot A$。因此，对于多层墙体，$R'_{\\text{assembly}} = \\frac{1}{h_{\\text{in}}} + \\sum_{j} \\frac{L_j}{k_j} + \\frac{1}{h_{\\text{out}}}$。总传热系数，即 U 值，是单位面积总热阻的倒数：$U = \\frac{1}{R'_{\\text{assembly}}}$。通过该组件的传热速率为 $\\dot{Q} = UA \\Delta T$。\n\n4.  **建筑的等效热阻：** 建筑围护结构由几个并联向室外环境传热的组件（墙体、屋顶、窗户）组成。总传热速率是流经每个组件的速率之和：$\\dot{Q}_{\\text{tot}} = \\sum_{j} \\dot{Q}_j = \\sum_{j} (UA)_j \\Delta T = (\\sum_{j} (UA)_j) \\Delta T$。项 $(UA)_{\\text{tot}} = \\sum_j (UA)_j$ 表示每单位温差的总热损失率。整个建筑围护结构的等效热阻是该值的倒数：$R_{\\text{eq}} = \\frac{1}{(UA)_{\\text{tot}}} = \\frac{1}{\\sum_{j} (UA)_j}$。\n\n**热容, $C$**\n热容是物体储存热能的能力。它被定义为使物体的温度升高一度所需的热能。温度变化 $dT$ 所需的热能 $dQ$ 为 $dQ = C dT$。对于质量为 $m$、比热容为 $c_p$ 的物质，有限温差 $\\Delta T$ 所需的热量为 $Q = mc_p \\Delta T$。因此，热容为 $C = mc_p$。对于体积为 $V$、密度为 $\\rho$ 的物体，其质量为 $m=\\rho V$，所以热容为 $C = \\rho V c_p$。\n\n对于集总热容建筑模型，总热容 $C_{\\text{eq}}$ 是假定处于均匀室内空气温度下的所有组件的热容之和。这包括室内空气本身以及与空气热耦合良好的朝向室内的材料质量。\n$C_{\\text{eq}} = \\sum_{i} C_i = \\sum_{i} m_i c_{p,i}$。\n\n**第 2 部分：数值计算**\n\n**步骤 A：计算总热阻 ($R_{\\text{eq}}$)**\n\n1.  **计算组件面积：**\n    - 楼面/屋顶面积：$A_{\\text{floor}} = A_{\\text{roof}} = 60$ m$^2$。\n    - 建筑周长：$P = 2(10\\,\\text{m} + 6\\,\\text{m}) = 32$ m。\n    - 总墙体面积：$A_{\\text{wall,tot}} = P \\times H = 32\\,\\text{m} \\times 2.5\\,\\text{m} = 80$ m$^2$。\n    - 窗户面积：$A_{\\text{win}} = 8$ m$^2$。\n    - 不透明墙体面积：$A_{\\text{wall,op}} = A_{\\text{wall,tot}} - A_{\\text{win}} = 80\\,\\text{m}^2 - 8\\,\\text{m}^2 = 72$ m$^2$。\n\n2.  **计算不透明墙体的 U 值 ($U_{\\text{wall}}$)：**\n    单位面积的总热阻 $R'_{\\text{wall,op}}$ 是串联热阻之和：\n    $R'_{\\text{wall,op}} = \\frac{1}{h_{\\text{in}}} + \\frac{L_{\\text{gyp}}}{k_{\\text{gyp}}} + \\frac{L_{\\text{ins}}}{k_{\\text{ins}}} + \\frac{L_{\\text{osb}}}{k_{\\text{osb}}} + \\frac{L_{\\text{wood}}}{k_{\\text{wood}}} + \\frac{1}{h_{\\text{out}}}$\n    $R'_{\\text{wall,op}} = \\frac{1}{8} + \\frac{0.0125}{0.17} + \\frac{0.09}{0.035} + \\frac{0.012}{0.12} + \\frac{0.010}{0.14} + \\frac{1}{25}$ m$^2$ K W$^{-1}$\n    $R'_{\\text{wall,op}} = (0.125 + 0.073529... + 2.571428... + 0.1 + 0.071428... + 0.04)$ m$^2$ K W$^{-1} = 2.98138...$ m$^2$ K W$^{-1}$。\n    $U_{\\text{wall}} = \\frac{1}{R'_{\\text{wall,op}}} = \\frac{1}{2.98138...}$ W m$^{-2}$ K$^{-1} = 0.33541...$ W m$^{-2}$ K$^{-1}$。\n\n3.  **计算屋顶的 U 值 ($U_{\\text{roof}}$)：**\n    $R'_{\\text{roof}} = \\frac{1}{h_{\\text{in}}} + \\frac{L_{\\text{gyp}}}{k_{\\text{gyp}}} + \\frac{L_{\\text{attic_ins}}}{k_{\\text{ins}}} + \\frac{L_{\\text{osb}}}{k_{\\text{osb}}} + \\frac{1}{h_{\\text{out}}}$\n    $R'_{\\text{roof}} = \\frac{1}{8} + \\frac{0.0125}{0.17} + \\frac{0.20}{0.035} + \\frac{0.012}{0.12} + \\frac{1}{25}$ m$^2$ K W$^{-1}$\n    $R'_{\\text{roof}} = (0.125 + 0.073529... + 5.714285... + 0.1 + 0.04)$ m$^2$ K W$^{-1} = 6.05281...$ m$^2$ K W$^{-1}$。\n    $U_{\\text{roof}} = \\frac{1}{R'_{\\text{roof}}} = \\frac{1}{6.05281...}$ W m$^{-2}$ K$^{-1} = 0.16521...$ W m$^{-2}$ K$^{-1}$。\n\n4.  **计算总 UA 乘积 ($(UA)_{\\text{tot}}$)：**\n    $(UA)_{\\text{tot}} = U_{\\text{wall}}A_{\\text{wall,op}} + U_{\\text{roof}}A_{\\text{roof}} + U_{\\text{win}}A_{\\text{win}}$\n    $(UA)_{\\text{tot}} = (0.33541... \\times 72) + (0.16521... \\times 60) + (1.8 \\times 8)$ W K$^{-1}$\n    $(UA)_{\\text{tot}} = (24.1498... + 9.9126... + 14.4)$ W K$^{-1} = 48.4625...$ W K$^{-1}$。\n\n5.  **计算等效热阻 ($R_{\\text{eq}}$)：**\n    $R_{\\text{eq}} = \\frac{1}{(UA)_{\\text{tot}}} = \\frac{1}{48.4625...}$ K W$^{-1} = 0.020634...$ K W$^{-1}$。\n\n**步骤 B：计算总热容 ($C_{\\text{eq}}$)**\n\n$C_{\\text{eq}} = C_{\\text{air}} + C_{\\text{gyp}} + C_{\\text{conc}} + C_{\\text{furn}}$\n\n1.  **空气热容 ($C_{\\text{air}}$)：**\n    $V_{\\text{air}} = A_{\\text{floor}} \\times H = 60\\,\\text{m}^2 \\times 2.5\\,\\text{m} = 150$ m$^3$。\n    $C_{\\text{air}} = \\rho_{\\text{air}} V_{\\text{air}} c_{p,\\text{air}} = 1.2 \\times 150 \\times 1005 = 180900$ J K$^{-1}$。\n\n2.  **石膏板热容 ($C_{\\text{gyp}}$)：**\n    石膏板位于不透明墙体和天花板的内侧。\n    $A_{\\text{gyp}} = A_{\\text{wall,op}} + A_{\\text{roof}} = 72\\,\\text{m}^2 + 60\\,\\text{m}^2 = 132$ m$^2$。\n    $V_{\\text{gyp}} = A_{\\text{gyp}} \\times L_{\\text{gyp}} = 132 \\times 0.0125 = 1.65$ m$^3$。\n    $C_{\\text{gyp}} = \\rho_{\\text{gyp}} V_{\\text{gyp}} c_{p,\\text{gyp}} = 800 \\times 1.65 \\times 1090 = 1438800$ J K$^{-1}$。\n\n3.  **混凝土地板热容 ($C_{\\text{conc}}$)：**\n    $V_{\\text{conc}} = A_{\\text{floor}} \\times L_{\\text{conc}} = 60 \\times 0.10 = 6$ m$^3$。\n    $C_{\\text{conc}} = \\rho_{\\text{conc}} V_{\\text{conc}} c_{p,\\text{conc}} = 2400 \\times 6 \\times 880 = 12672000$ J K$^{-1}$。\n\n4.  **家具热容 ($C_{\\text{furn}}$)：**\n    $C_{\\text{furn}} = m_{\\text{furn}} c_{p,\\text{furn}} = 500 \\times 1500 = 750000$ J K$^{-1}$。\n\n5.  **总等效热容 ($C_{\\text{eq}}$)：**\n    $C_{\\text{eq}} = 180900 + 1438800 + 12672000 + 750000 = 15041700$ J K$^{-1}$。\n\n**步骤 C：计算热时间常数 ($\\tau$)**\n\n热时间常数 $\\tau$ 是等效热阻和等效热容的乘积。\n$\\tau = R_{\\text{eq}} C_{\\text{eq}} = 0.020634... \\text{ K W}^{-1} \\times 15041700 \\text{ J K}^{-1}$\n单位是 $(\\text{K}/\\text{W}) \\times (\\text{J}/\\text{K}) = \\text{J}/\\text{W} = \\text{J}/(\\text{J}/\\text{s}) = \\text{s}$。\n$\\tau = 310379...$ s。\n\n最后，将时间常数转换为小时，并四舍五入到三位有效数字。\n$\\tau_{\\text{hours}} = \\frac{\\tau}{3600\\,\\text{s/hr}} = \\frac{310379...}{3600} = 86.216...$ hr。\n四舍五入到三位有效数字得到 $86.2$ hr。",
            "answer": "$$\n\\boxed{86.2}\n$$"
        },
        {
            "introduction": "在温控负荷模型参数化后，我们需要模拟其动态行为以了解其能耗模式。本练习要求您实现一个先进的事件驱动模拟器，该模拟器能精确解析计算恒温器切换的精确时刻。这种方法比固定时间步长法更准确、计算效率更高，代表了动态系统仿真的专业标准。",
            "id": "4131004",
            "problem": "您的任务是在能源系统建模领域，为一个温控负荷（TCL）实现一个事件驱动模拟器。该TCL是一个单区制冷设备，在分段恒定的环境条件下，基于滞回控制来调节室内温度。目标是通过解析求解温度轨迹的阈值穿越问题，来计算恒温器改变状态的精确切换时间。\n\n从以下建模基础开始：\n- 室内温度动态遵循一个源于能量平衡和牛顿冷却定律的一阶集总热容模型。其常微分方程（ODE）为\n$$\n\\frac{dT(t)}{dt} \\;=\\; -k \\,\\big(T(t) - T_a(t)\\big) \\;-\\; u(t) \\, q,\n$$\n其中 $T(t)$ 是室内温度，单位为摄氏度；$T_a(t)$ 是环境温度，单位为摄氏度；$k > 0$ 是热损失率，单位为 1/秒；$u(t) \\in \\{0,1\\}$ 是执行器模式，其中 $u(t)=1$ 表示制冷设备开启（ON），$u(t)=0$ 表示其关闭（OFF）；$q > 0$ 是有效制冷速率，单位为摄氏度/秒。环境温度 $T_a(t)$ 在指定的时间段内是分段恒定的。参数 $k$ 和 $q$ 在整个模拟过程中保持不变。单位：温度为摄氏度，时间为秒。\n\n- 恒温器采用围绕设定点的带有死区的滞回控制，其下限阈值为 $T_{\\text{low}} = T_{\\text{set}} - \\Delta$，上限阈值为 $T_{\\text{high}} = T_{\\text{set}} + \\Delta$，其中 $\\Delta > 0$ 是死区宽度的一半。制冷设备的切换逻辑是：当 $u(t)=0$（设备关闭）时，在温度 $T(t) \\ge T_{\\text{high}}$ 的第一个时间点 $t$ 开启；当 $u(t)=1$（设备开启）时，在温度 $T(t) \\le T_{\\text{low}}$ 的第一个时间点 $t$ 关闭。在阈值处的临界情况通过在当前时间立即切换来解决，即，如果在任何决策时刻 $T(t)$ 等于活动阈值，则相应的切换在该时刻发生。\n\n您的任务：\n- 实现一个事件驱动的模拟算法，该算法通过解析求解每个分段内的阈值穿越时间，来精确积分 $T(t)$ 并计算给定环境分段计划内的切换事件时间。环境温度 $T_a(t)$ 在分段 $\\{(d_i, T_{a,i})\\}$ 上是分段恒定的，其中 $d_i$ 是分段 $i$ 的持续时间（秒），$T_{a,i}$ 是该分段的环境温度（摄氏度）。设备模式 $u(t)$ 在切换事件之间是分段恒定的。在任何具有恒定 $T_a$ 和恒定 $u$ 的分段内，$T(t)$ 根据给定的ODE演化。\n\n- 您的模拟器必须：\n  1. 接受模型参数 $(\\tau, q, T_{\\text{set}}, \\Delta, T_0, u_0, \\{(d_i, T_{a,i})\\})$, 其中 $\\tau$ 是热时间常数（秒），$k = 1/\\tau$，$q$ 是制冷速率（摄氏度/秒），$T_{\\text{set}}$ 是设定点（摄氏度），$\\Delta$ 是死区半宽（摄氏度），$T_0$ 是时间 $t=0$ 时的初始室内温度（摄氏度），$u_0 \\in \\{0,1\\}$ 是初始模式（0为OFF，1为ON），环境计划是成对的 $(d_i, T_{a,i})$ 列表。\n  2. 在每个环境分段内精确计算室内温度轨迹，并确定恒温器状态切换的精确时间。事件之间的传播通过使用ODE解析解来完成；不允许使用数值步进。\n  3. 执行上述的滞回切换逻辑和阈值处的临界情况处理规则。\n  4. 返回一个从 $t=0$ 到环境计划结束的事件时间列表（秒）。\n\n解析积分规范：\n- 在任何 $T_a(t) = \\text{constant}$ 和 $u(t) = \\text{constant}$ 的区间内，$T(t)$ 必须被精确积分。事件时间通过求解 $T(t) = T_{\\text{thr}}$ 来找到 $t$，其中 $T_{\\text{thr}}$ 是活动阈值（当 $u=0$ 时为 $T_{\\text{high}}$，当 $u=1$ 时为 $T_{\\text{low}}$）。只有当轨迹单调趋向于 $T_{\\infty}$ 并且阈值位于当前温度和该分段的 $T_{\\infty}$ 之间时，才计算穿越；否则，在该分段内不会发生穿越。\n\n单位：\n- 所有事件时间均以秒为单位，作为浮点值报告。\n\n测试套件：\n实现您的程序以运行以下五个测试用例，每个用例由 $(\\tau, q, T_{\\text{set}}, \\Delta, T_0, u_0, \\{(d_i, T_{a,i})\\})$ 定义：\n- 用例 1：$\\tau = 1200$, $q = 0.01$, $T_{\\text{set}} = 22$, $\\Delta = 1$, $T_0 = 22$, $u_0 = 0$, 环境分段 $\\{(1800, 30), (1800, 26), (1800, 28)\\}$。\n- 用例 2：$\\tau = 900$, $q = \\frac{8}{900}$, $T_{\\text{set}} = 24$, $\\Delta = 0.5$, $T_0 = 24.5$, $u_0 = 0$, 环境分段 $\\{(1200, 27)\\}$。\n- 用例 3：$\\tau = 1500$, $q = \\frac{10}{1500}$, $T_{\\text{set}} = 21$, $\\Delta = 0.7$, $T_0 = 21$, $u_0 = 0$, 环境分段 $\\{(3600, 18)\\}$。\n- 用例 4：$\\tau = 300$, $q = \\frac{12}{300}$, $T_{\\text{set}} = 25$, $\\Delta = 1$, $T_0 = 26$, $u_0 = 0$, 环境分段 $\\{(200, 32), (200, 34), (200, 30), (400, 29)\\}$。\n- 用例 5：$\\tau = 600$, $q = \\frac{15}{600}$, $T_{\\text{set}} = 22$, $\\Delta = 0.1$, $T_0 = 22$, $u_0 = 0$, 环境分段 $\\{(300, 27), (300, 27)\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个条目必须是对应一个测试用例的事件时间列表（秒），并按顺序排列。例如，输出必须如下所示：\n$$\n[ [t_{1,1}, t_{1,2}, \\dots], [t_{2,1}, \\dots], [\\dots], [\\dots], [\\dots] ].\n$$\n如果某个用例没有事件，则为该用例输出一个空列表，即 $[]$。",
            "solution": "该问题要求实现一个在滞回控制下运行的温控负荷（TCL）的事件驱动模拟器。模拟必须是精确的，在事件之间使用温度动态的解析解。\n\n模拟的核心是基于控制室内温度 $T(t)$ 的一阶常微分方程（ODE）：\n$$\n\\frac{dT(t)}{dt} = -k \\left(T(t) - T_a(t)\\right) - u(t) q\n$$\n这里，$k$ 是热损失率（$k=1/\\tau$，其中 $\\tau$ 是热时间常数），$T_a(t)$ 是环境温度，$u(t)$ 是执行器状态（1为开启，0为关闭），$q$ 是制冷速率。\n\n模拟通过识别并推进到时间上的下一个事件来进行。事件可以是恒温器状态切换（状态依赖事件），也可以是环境温度的变化（时间依赖事件）。\n\n首先，我们解析地求解ODE。在执行器状态 $u(t)$ 和环境温度 $T_a(t)$ 保持恒定的任何时间区间内，我们将它们分别表示为 $u_c$ 和 $T_{a,c}$。该ODE可以重写为一个标准的一阶线性ODE：\n$$\n\\frac{dT}{dt} + k T(t) = k T_{a,c} - u_c q\n$$\n方程右侧是常数。此ODE的解由齐次部分和特解组成。特解是稳态或渐近温度 $T_{\\infty}$，通过设置 $\\frac{dT}{dt}=0$ 求得：\n$$\n0 = -k (T_{\\infty} - T_{a,c}) - u_c q \\implies T_{\\infty} = T_{a,c} - \\frac{u_c q}{k} = T_{a,c} - u_c q \\tau\n$$\n从时间 $t_s$ 的初始温度 $T_s$ 开始，温度 $T(t)$ 的通解由下式给出：\n$$\nT(t) = T_{\\infty} + (T_s - T_{\\infty}) e^{-k(t - t_s)}\n$$\n这个解析解使我们能够计算恒定参数区间内任何未来时间 $t$ 的温度，而无需借助数值积分。\n\n下一步是确定恒温器切换的时间。当温度 $T(t)$ 达到滞回阈值之一时，发生切换：$T_{\\text{high}} = T_{\\text{set}} + \\Delta$ 或 $T_{\\text{low}} = T_{\\text{set}} - \\Delta$。活动阈值 $T_{\\text{thr}}$ 取决于当前的执行器模式 $u_c$：\n- 如果设备关闭（$u_c=0$），它将在达到 $T_{\\text{high}}$ 时开启。因此，$T_{\\text{thr}} = T_{\\text{high}}$。\n- 如果设备开启（$u_c=1$），它将在达到 $T_{\\text{low}}$ 时关闭。因此，$T_{\\text{thr}} = T_{\\text{low}}$。\n\n为了找到切换所需时间 $\\Delta t_{cross} = t_{cross} - t_s$，我们求解方程 $T(t_{cross}) = T_{\\text{thr}}$ 以得到 $\\Delta t_{cross}$：\n$$\nT_{\\text{thr}} = T_{\\infty} + (T_s - T_{\\infty}) e^{-k \\Delta t_{cross}}\n$$\n整理并求解 $\\Delta t_{cross}$ 得：\n$$\n\\frac{T_{\\text{thr}} - T_{\\infty}}{T_s - T_{\\infty}} = e^{-k \\Delta t_{cross}}\n$$\n$$\n\\ln\\left(\\frac{T_{\\text{thr}} - T_{\\infty}}{T_s - T_{\\infty}}\\right) = -k \\Delta t_{cross}\n$$\n$$\n\\Delta t_{cross} = -\\frac{1}{k} \\ln\\left(\\frac{T_{\\text{thr}} - T_{\\infty}}{T_s - T_{\\infty}}\\right) = \\tau \\ln\\left(\\frac{T_s - T_{\\infty}}{T_{\\text{thr}} - T_{\\infty}}\\right)\n$$\n仅当自然对数的参数大于1时，才存在一个有物理意义的（正的、有限的）切换时间 $\\Delta t_{cross}$。这对应于阈值 $T_{\\text{thr}}$ 位于当前温度 $T_s$ 和渐近温度 $T_{\\infty}$ 之间的条件。具体来说：\n- 对于开启事件（$u_c=0$）：如果 $T_s < T_{\\text{high}}$ 且系统正朝着高于该阈值的渐近温度加热，即 $T_{\\infty} > T_{\\text{high}}$，则会发生穿越。\n- 对于关闭事件（$u_c=1$）：如果 $T_s > T_{\\text{low}}$ 且系统正朝着低于该阈值的渐近温度冷却，即 $T_{\\infty} < T_{\\text{low}}$，则会发生穿越。\n如果不满足这些条件，在当前恒定参数的区间内将不会发生切换事件。临界情况处理规则规定，如果在决策时刻 $T_s = T_{\\text{thr}}$，则切换是立即的，因此 $\\Delta t_{cross}=0$。\n\n事件驱动的模拟算法结构如下：\n1. 初始化模拟状态：当前时间 $t_{curr}=0$，温度 $T_{curr}=T_0$，执行器模式 $u_{curr}=u_0$。创建一个列表来存储事件时间。\n2. 检查在 $t=0$ 时是否基于初始条件 $T_0$、$u_0$ 和相应阈值发生立即切换。如果发生切换，记录事件时间 $t=0$ 并更新 $u_{curr}$。\n3. 进入一个循环，持续到 $t_{curr}$ 达到总模拟时长。\n4. 在循环内，对于当前状态 $(t_{curr}, T_{curr}, u_{curr})$：\n   a. 确定当前的环境温度 $T_{a,c}$ 和下一个计划的环境温度变化时间 $t_{amb}$。\n   b. 根据 $T_{a,c}$ 和 $u_{curr}$ 计算渐近温度 $T_{\\infty}$。\n   c. 确定活动阈值 $T_{\\text{thr}}$ 并检查是否可能发生切换。\n   d. 如果可能发生切换，计算 $\\Delta t_{cross}$。潜在的切换时间为 $t_{switch} = t_{curr} + \\Delta t_{cross}$。否则，将 $t_{switch}$ 设为无穷大。\n   e. 下一个事件时间为 $t_{next} = \\min(t_{switch}, t_{amb})$。\n   f. 如果 $t_{next}$ 超过模拟范围，则将时间推进到模拟结束并终止。\n   g. 将模拟推进到 $t_{next}$。使用解析解计算此时的温度 $T_{next}$。更新 $t_{curr} = t_{next}$ 和 $T_{curr} = T_{next}$。\n   h. 如果事件是切换事件（$t_{next} = t_{switch}$），则在事件列表中记录 $t_{next}$，翻转执行器模式 $u_{curr}$，并将 $T_{curr}$ 精确地设置为 $T_{\\text{thr}}$。\n5. 循环终止后，返回记录的事件时间列表。\n\n此过程确保了温度轨迹在事件之间是精确演化的，并且切换时间是以解析精度计算的，从而满足了问题的要求。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: tau, q, T_set, Delta, T0, u0, ambient_segments\n        (1200.0, 0.01, 22.0, 1.0, 22.0, 0, [(1800.0, 30.0), (1800.0, 26.0), (1800.0, 28.0)]),\n        # Case 2\n        (900.0, 8.0/900.0, 24.0, 0.5, 24.5, 0, [(1200.0, 27.0)]),\n        # Case 3\n        (1500.0, 10.0/1500.0, 21.0, 0.7, 21.0, 0, [(3600.0, 18.0)]),\n        # Case 4\n        (300.0, 12.0/300.0, 25.0, 1.0, 26.0, 0, [(200.0, 32.0), (200.0, 34.0), (200.0, 30.0), (400.0, 29.0)]),\n        # Case 5\n        (600.0, 15.0/600.0, 22.0, 0.1, 22.0, 0, [(300.0, 27.0), (300.0, 27.0)])\n    ]\n    \n    all_results = []\n    for case in test_cases:\n        result = simulate_tcl(*case)\n        all_results.append(result)\n\n    # Format the final output string as specified\n    output_str = \"[\" + \",\".join([str(res) for res in all_results]) + \"]\"\n    print(output_str)\n\ndef simulate_tcl(tau, q, t_set, delta, t0, u0, ambient_segments):\n    \"\"\"\n    Simulates a single Thermostatically Controlled Load (TCL) case.\n\n    Args:\n        tau (float): Thermal time constant in seconds.\n        q (float): Cooling rate in degrees Celsius per second.\n        t_set (float): Temperature setpoint in degrees Celsius.\n        delta (float): Deadband half-width in degrees Celsius.\n        t0 (float): Initial indoor temperature in degrees Celsius.\n        u0 (int): Initial actuator mode (0 for OFF, 1 for ON).\n        ambient_segments (list): A list of tuples (duration, ambient_temp).\n\n    Returns:\n        list: A list of floating-point event times in seconds.\n    \"\"\"\n    k = 1.0 / tau\n    t_low = t_set - delta\n    t_high = t_set + delta\n\n    current_time = 0.0\n    current_temp = t0\n    current_mode = u0\n    \n    event_times = []\n\n    # Build ambient event schedule\n    ambient_events = []\n    _time = 0.0\n    total_duration = 0.0\n    for duration, temp in ambient_segments:\n        _time += duration\n        ambient_events.append((_time, temp))\n        total_duration = _time\n    \n    ambient_idx = 0\n\n    # Initial state check for immediate switch at t=0\n    # This loop handles the rare case of multiple immediate switches if T_low == T_high\n    while True:\n      initial_mode = current_mode\n      if current_mode == 0 and current_temp >= t_high:\n          event_times.append(current_time)\n          current_mode = 1\n          current_temp = t_high # Snap to threshold\n      elif current_mode == 1 and current_temp = t_low:\n          event_times.append(current_time)\n          current_mode = 0\n          current_temp = t_low # Snap to threshold\n          \n      if current_mode == initial_mode:\n        break\n\n\n    while current_time  total_duration:\n        # Determine current ambient conditions\n        while ambient_idx  len(ambient_events) and current_time >= ambient_events[ambient_idx][0]:\n            ambient_idx += 1\n\n        t_a = ambient_segments[ambient_idx][1]\n        next_ambient_time = ambient_events[ambient_idx][0]\n        \n        # Calculate asymptotic temperature\n        t_inf = t_a - current_mode * q * tau\n        \n        # Determine active threshold and calculate time to next switch\n        next_switch_time = float('inf')\n        \n        t_s = current_temp\n        \n        if current_mode == 0:  # OFF, heating up\n            t_thr = t_high\n            # Condition for crossing: T_s  T_thr and T_inf > T_thr\n            if t_s  t_thr and t_inf > t_thr:\n                # Handle division by zero if t_thr is close to t_inf\n                if not np.isclose(t_thr, t_inf):\n                    arg = (t_s - t_inf) / (t_thr - t_inf)\n                    if arg > 0: # It must be > 1, but >0 is a sanity check\n                        dt_cross = tau * np.log(arg)\n                        if dt_cross >= 0:\n                            next_switch_time = current_time + dt_cross\n        else:  # ON, cooling down\n            t_thr = t_low\n            # Condition for crossing: T_s > T_thr and T_inf  T_thr\n            if t_s > t_thr and t_inf  t_thr:\n                if not np.isclose(t_thr, t_inf):\n                    arg = (t_s - t_inf) / (t_thr - t_inf)\n                    if arg > 0:\n                        dt_cross = tau * np.log(arg)\n                        if dt_cross >= 0:\n                            next_switch_time = current_time + dt_cross\n                            \n        # Determine the next event\n        next_event_time = min(next_switch_time, next_ambient_time, total_duration)\n\n        if next_event_time = current_time and not np.isclose(next_event_time, current_time):\n            # This indicates no forward progress is possible, break to avoid infinite loop\n            break\n        \n        is_switch_event = np.isclose(next_event_time, next_switch_time)\n        \n        if np.isclose(current_time, total_duration):\n            break\n\n        # Propagate state to the next event time\n        dt = next_event_time - current_time\n        current_temp = t_inf + (t_s - t_inf) * np.exp(-k * dt)\n        current_time = next_event_time\n        \n        # Handle the event\n        if is_switch_event and current_time  total_duration:\n            event_times.append(current_time)\n            current_mode = 1 - current_mode\n            current_temp = t_thr # Snap temperature to threshold after switch\n\n    return event_times\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "当温控负荷（TCLs）被聚合并用于提供电网服务时，其真正的潜力才得以实现。这个高级实践引入了平均场建模来表示大型 TCL 群体的集体行为，并要求您设计一个反馈控制器以跟踪功率调节信号。成功完成此练习将展示如何利用分布式能源来维持电网稳定。",
            "id": "4131081",
            "problem": "考虑一个由相同的电制冷恒温控制负载（TCL）组成的大型群体。每个TCL被建模为一个集总热阻-热容元件，其室内空气温度根据能量守恒定律演变：来自环境的热传导加上压缩机开启时的排热量。设单个设备的热阻为 $R$（单位为 $\\mathrm{K/W}$），热容为 $C_{th}$（单位为 $\\mathrm{J/K}$），基准恒温器设定点为 $T_{s,0}$（单位为 $\\mathrm{K}$），死区宽度为 $\\Delta$（单位为 $\\mathrm{K}$），环境温度为 $T_a$（单位为 $\\mathrm{K}$）。每个设备在开启时消耗额定电功率 $P_{dev}$（单位为 $\\mathrm{W}$），并实现 $\\eta P_{dev}$（单位为 $\\mathrm{W}$）的排热功率，其中 $\\eta$ 是将电功率映射到排热功率的系数（无量纲）。群体大小为 $N$（整数）。聚合功率为 $P_{agg}(t)$（单位为 $\\mathrm{W}$）。必须通过操控公共设定点偏移量 $\\delta T_s(t)$（单位为 $\\mathrm{K}$）来跟踪一个调节信号 $r(t)$（单位为 $\\mathrm{W}$）。\n\n从第一性原理出发，使用单个设备的能量守恒定律和适用于大型、非同步群体在 $T_{s,0}$ 附近有小扰动 $\\delta T_s(t)$ 的平均场建模假设。假设线性化在 $\\lvert \\delta T_s(t) \\rvert \\ll \\Delta$ 时有效。按以下步骤进行：\n\n1) 在小信号条件下，推导一个线性的、时不变的标量平均场对象，该对象将设定点偏移量 $\\delta T_s(t)$ 映射到聚合功率偏差 $\\delta P_{agg}(t) = P_{agg}(t) - P_{agg}(0)$。您的推导必须从单个设备的能量平衡出发，并用 $N$、$R$、$C_{th}$ 和 $\\eta$ 表示该对象的静态增益和主导弛豫时间，同时做出与大型、非同步群体一致的科学上合理的近似。明确说明哪些近似将弛豫时间与 $R$ 和 $C_{th}$ 关联起来。\n\n2) 设控制器为比例-积分（PI）控制器，具有指定的控制方向 $\\sigma \\in \\{+1,-1\\}$，使得设定点偏移量由 $\\delta T_s(t) = \\sigma \\left[ K_p e(t) + K_i \\int_0^t e(\\tau)\\,d\\tau \\right]$ 给出，其中 $e(t) = r(t) - P_{agg}(t)$，控制器增益为 $K_p$（单位为 $\\mathrm{K/W}$）和 $K_i$（单位为 $\\mathrm{K/(W\\cdot s)}$）。用对象参数和控制器参数表示线性化系统的闭环特征方程。使用制冷负载具有 $\\sigma = -1$ 的约定。\n\n3) 实现一个程序，对于下面指定的测试套件，为每个测试案例计算以下四个量：\n   a) 闭环稳定性，以布尔值表示，如果所有闭环极点的实部都严格为负，则输出 $1$，否则输出 $0$。\n   b) 在有限时间域 $[0,T_h]$ 上的误差平方积分（ISE）$\\int_0^{T_h} e(t)^2\\,dt$，以 $\\mathrm{W^2 \\cdot s}$ 为单位，表示为一个浮点数。调节信号是一个幅度为 $A$（单位为 $\\mathrm{W}$）的阶跃输入，即当 $t  0$ 时 $r(t) = 0$，当 $t \\ge 0$ 时 $r(t) = A$。\n   c) 最终跟踪误差 $e(T_h)$（单位为 $\\mathrm{W}$），表示为一个浮点数。\n   d) 最大绝对设定点偏移量 $\\max_{t \\in [0,T_h]} \\lvert \\delta T_s(t) \\rvert$（单位为 $\\mathrm{K}$），表示为一个浮点数。\n   数值积分使用 1 秒的时间步长，并假设初始条件为 $P_{agg}(0) = 0$ 和 $\\int_0^0 e(\\tau)\\,d\\tau = 0$。\n\n4) 所有结果均使用上述指定单位表示。由于不涉及角度，因此不需要角度单位。不涉及百分比。最终输出格式必须是单行，包含所有测试案例的结果，形式为方括号括起来的逗号分隔列表，其中每个测试案例本身也表示为方括号括起来的四元素逗号分隔列表。例如，输出格式应类似于 $[[b_1,ise_1,e_T^{(1)},u_{max}^{(1)}],[b_2,ise_2,e_T^{(2)},u_{max}^{(2)}],\\ldots]$，不带任何附加文本。\n\n使用以下测试套件，其选择旨在探测典型、快速和高增益场景，同时保持科学上的合理性。对于以下所有案例，取弛豫时间等于热时间常数 $R C_{th}$：\n\n- 案例1（典型制冷群体）：\n  $N = 10000$，$P_{dev} = 1000\\,\\mathrm{W}$，$R = 0.005\\,\\mathrm{K/W}$，$C_{th} = 1.2 \\times 10^6\\,\\mathrm{J/K}$，$\\eta = 3$，$\\Delta = 0.5\\,\\mathrm{K}$，$\\sigma = -1$，$K_p = 1\\times 10^{-5}\\,\\mathrm{K/W}$，$K_i = 1\\times 10^{-7}\\,\\mathrm{K/(W\\cdot s)}$，$A = 100000\\,\\mathrm{W}$，$T_h = 7200\\,\\mathrm{s}$。\n\n- 案例2（较小群体，更快的热动态）：\n  $N = 2000$，$P_{dev} = 1500\\,\\mathrm{W}$，$R = 0.01\\,\\mathrm{K/W}$，$C_{th} = 2 \\times 10^5\\,\\mathrm{J/K}$，$\\eta = 2.5$，$\\Delta = 0.5\\,\\mathrm{K}$，$\\sigma = -1$，$K_p = 5\\times 10^{-6}\\,\\mathrm{K/W}$，$K_i = 2\\times 10^{-7}\\,\\mathrm{K/(W\\cdot s)}$，$A = 50000\\,\\mathrm{W}$，$T_h = 7200\\,\\mathrm{s}$。\n\n- 案例3（中等群体，更高增益）：\n  $N = 5000$，$P_{dev} = 800\\,\\mathrm{W}$，$R = 0.007\\,\\mathrm{K/W}$，$C_{th} = 8 \\times 10^5\\,\\mathrm{J/K}$，$\\eta = 3.5$，$\\Delta = 0.5\\,\\mathrm{K}$，$\\sigma = -1$，$K_p = 5\\times 10^{-5}\\,\\mathrm{K/W}$，$K_i = 8\\times 10^{-7}\\,\\mathrm{K/(W\\cdot s)}$，$A = 200000\\,\\mathrm{W}$，$T_h = 7200\\,\\mathrm{s}$。\n\n您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，不带任何附加文本，与上述第 4 项中描述的格式完全一致。",
            "solution": "该问题要求推导一个恒温控制负载（TCL）群体的线性化平均场模型，分析其使用比例-积分（PI）控制器的闭环控制，并通过数值实现来评估系统在特定测试场景下的性能。\n\n### 第1部分：平均场对象模型推导\n\n我们从单个TCL的能量平衡开始，它被建模为一个集总热阻-热容元件。设备 $i$ 的室内温度 $T_i(t)$ 根据以下公式演变：\n$$ C_{th} \\frac{dT_i}{dt} = \\frac{T_a - T_i(t)}{R} - s_i(t) \\eta P_{dev} $$\n其中 $C_{th}$ 是热容，$R$ 是热阻，$T_a$ 是环境温度，$\\eta$ 是性能系数，$P_{dev}$ 是设备的电功率消耗，$s_i(t) \\in \\{0, 1\\}$ 是压缩机状态（开/关）。\n\n对于一个由 $N$ 个相同设备组成的大型、非同步群体，我们可以使用平均场方法。我们感兴趣的是聚合功率的偏差 $\\delta P_{agg}(t)$ 对一个小的、公共的设定点偏移 $\\delta T_s(t)$ 的响应。这类系统可以有效地建模为一阶线性时不变（LTI）对象：\n$$ G_p(s) = \\frac{\\delta P_{agg}(s)}{\\delta T_s(s)} = \\frac{G}{1 + \\tau s} $$\n其中 $G$ 是静态增益，$\\tau$ 是主导弛豫时间。\n\n**静态增益 $G$：**\n静态增益表示由于设定点的持续变化而引起的聚合功率的稳态变化。在平均场平衡中，群体的平均室内温度 $\\bar{T}$ 跟踪设定点 $T_s$。稳态占空比 $d_0$（开启设备的比例）必须平衡来自环境的平均热增益：\n$$ \\frac{T_a - \\bar{T}}{R} - d_0 \\eta P_{dev} = 0 $$\n假设 $\\bar{T} \\approx T_s = T_{s,0} + \\delta T_s$，则占空比为 $d = \\frac{T_a - T_s}{R \\eta P_{dev}}$。\n聚合功率为 $P_{agg} = N \\cdot d \\cdot P_{dev} = N P_{dev} \\frac{T_a - T_s}{R \\eta P_{dev}} = \\frac{N (T_a - T_s)}{R \\eta}$。\n对于围绕 $T_{s,0}$ 的小扰动 $\\delta T_s$，聚合功率的变化为：\n$$ \\delta P_{agg} = P_{agg}(T_{s,0} + \\delta T_s) - P_{agg}(T_{s,0}) = \\frac{N (T_a - (T_{s,0} + \\delta T_s))}{R \\eta} - \\frac{N (T_a - T_{s,0})}{R \\eta} = -\\frac{N}{R \\eta} \\delta T_s $$\n因此，静态增益为：\n$$ G = \\frac{\\delta P_{agg}}{\\delta T_s} = -\\frac{N}{R \\eta} $$\n对于制冷负载，设定点的增加（希望温度更暖）正确地导致了制冷功率的减少。\n\n**弛豫时间 $\\tau$：**\n问题指定将弛豫时间 $\\tau$ 取为与单个设备的热时间常数 $\\tau_{th} = R C_{th}$ 相等。\n这是一个关键的近似。对于同质群体，响应可能是复杂和振荡的。然而，对于一个足够“非同步”的大型群体（即，设备的状态在其运行周期内是分散的），其聚合行为趋于平滑。这种行为类似于参数呈分布式的异质群体的行为。在这种情况下，聚合响应的主导时间常数可以很好地由单个设备的平均热时间常数来近似。\n因此，我们的近似是 $\\tau = R C_{th}$，基于这样的假设：大型、非同步群体的聚合动态由单个单元的固有热惯性决定。\n\n### 第2部分：闭环系统分析\n\n控制器是一个具有控制方向 $\\sigma$ 的PI控制器。设定点偏移为：\n$$ \\delta T_s(t) = \\sigma \\left[ K_p e(t) + K_i \\int_0^t e(\\tau)\\,d\\tau \\right] $$\n其中误差信号为 $e(t) = r(t) - P_{agg}(t)$。问题声明 $P_{agg}(0)=0$，所以 $P_{agg}(t) = \\delta P_{agg}(t)$。\n在拉普拉斯域中，控制器是 $C(s) = K_p + \\frac{K_i}{s}$，控制信号是 $\\delta T_s(s) = \\sigma C(s) E(s)$。\n\n闭环系统由对象和控制器的负反馈互连构成。误差为 $E(s) = R(s) - P_{agg}(s)$。\n功率响应为 $P_{agg}(s) = G_p(s) \\delta T_s(s) = G_p(s) \\sigma C(s) E(s) = G_p(s) \\sigma C(s) [R(s) - P_{agg}(s)]$。\n求解 $P_{agg}(s)$：\n$$ P_{agg}(s) [1 + \\sigma G_p(s) C(s)] = \\sigma G_p(s) C(s) R(s) $$\n闭环传递函数为 $T(s) = \\frac{P_{agg}(s)}{R(s)} = \\frac{\\sigma G_p(s) C(s)}{1 + \\sigma G_p(s) C(s)}$。\n\n特征方程由闭环传递函数的分母置零给出：\n$$ 1 + \\sigma G_p(s) C(s) = 0 $$\n代入 $G_p(s) = \\frac{G}{1 + \\tau s}$ 和 $C(s) = \\frac{K_p s + K_i}{s}$：\n$$ 1 + \\sigma \\left( \\frac{G}{1 + \\tau s} \\right) \\left( \\frac{K_p s + K_i}{s} \\right) = 0 $$\n为了消去分母，我们乘以 $s(1 + \\tau s)$：\n$$ s(1 + \\tau s) + \\sigma G (K_p s + K_i) = 0 $$\n展开并按 $s$ 的幂次合并各项，得到二阶特征方程：\n$$ \\tau s^2 + (1 + \\sigma G K_p) s + \\sigma G K_i = 0 $$\n\n### 第3部分：计算方法\n\n**a) 稳定性分析**\nLTI系统的稳定性由闭环传递函数的极点位置决定，这些极点是特征方程 $as^2+bs+c=0$ 的根，其中：\n- $a = \\tau = R C_{th}$\n- $b = 1 + \\sigma G K_p$\n- $c = \\sigma G K_i$\n对于制冷负载，$\\sigma = -1$。增益 $G = -N/(R\\eta)$ 为负。\n所有物理参数（$N, R, C_{th}, \\eta$）和控制器增益（$K_p, K_i$）都为正。\n因此，系数为：\n- $a = R C_{th} > 0$\n- $b = 1 + (-1)(-\\frac{N}{R\\eta}) K_p = 1 + \\frac{N K_p}{R \\eta} > 0$\n- $c = (-1)(-\\frac{N}{R\\eta}) K_i = \\frac{N K_i}{R \\eta} > 0$\n根据二阶系统的劳斯-赫尔维茨稳定性判据，如果所有系数（$a, b, c$）符号相同（此处为正），则所有根都具有严格为负的实部。因此，对于所有测试案例，闭环系统都是稳定的。稳定性输出将为 $1$。\n\n**b, c, d) 用于性能指标的动态仿真**\n为了计算误差平方积分（ISE）、最终误差和最大控制力，我们仿真系统对 $t \\ge 0$ 时的阶跃参考 $r(t) = A$ 的响应。我们将系统动态以状态空间形式表示。设状态向量为 $\\mathbf{x}(t) = [x_1(t), x_2(t)]^T$，其中 $x_1(t) = P_{agg}(t)$，$x_2(t) = \\int_0^t e(\\tau)d\\tau$。\n\n状态方程推导如下：\n$\\dot{x}_2(t) = e(t) = r(t) - x_1(t)$。\n对象方程 $\\tau \\dot{x}_1(t) + x_1(t) = G \\delta T_s(t)$ 和控制器方程 $\\delta T_s(t) = \\sigma(K_p e(t) + K_i x_2(t))$ 结合得到：\n$\\tau \\dot{x}_1(t) = -x_1(t) + G \\sigma [K_p(r(t) - x_1(t)) + K_i x_2(t)]$\n这给出了 $x_1(t)$ 的微分方程：\n$\\dot{x}_1(t) = -\\frac{1+G\\sigma K_p}{\\tau} x_1(t) + \\frac{G\\sigma K_i}{\\tau} x_2(t) + \\frac{G\\sigma K_p}{\\tau} r(t)$\n\n我们使用前向欧拉法，以 $\\Delta t=1$ 秒的时间步长，对这个由两个一阶常微分方程组成的系统进行数值求解，如题目所规定。初始条件为 $x_1(0) = P_{agg}(0) = 0$ 和 $x_2(0) = 0$。\n\n仿真按 $k=0, 1, \\dots, T_h-1$ 迭代进行：\n1.  计算误差：$e[k] = A - x_1[k]$。\n2.  计算控制信号：$\\delta T_s[k] = \\sigma (K_p e[k] + K_i x_2[k])$。\n3.  更新下一个时间步 $k+1$ 的状态：\n    $x_1[k+1] = x_1[k] + \\Delta t \\cdot \\left( \\frac{G \\delta T_s[k] - x_1[k]}{\\tau} \\right)$\n    $x_2[k+1] = x_2[k] + \\Delta t \\cdot e[k]$\n4.  在仿真过程中，我们累积 ISE，$\\sum_{k=0}^{T_h-1} (e[k])^2 \\Delta t$，并跟踪 $|\\delta T_s[k]|$ 的最大值。\n\n在时间域 $[0, T_h]$ 上的仿真结束后，最终误差为 $e(T_h) = A - x_1[T_h]$。最终结果按要求的格式组合。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the TCL control problem for the specified test cases.\n\n    The solution involves:\n    1. Calculating the parameters of a first-order LTI plant model for a TCL population.\n    2. Simulating the closed-loop response of this plant with a PI controller.\n    3. Computing stability, Integrated Squared Error (ISE), final error, and maximum control signal magnitude.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 10000, \"P_dev\": 1000, \"R\": 0.005, \"C_th\": 1.2e6, \"eta\": 3, \"Delta\": 0.5,\n            \"sigma\": -1, \"Kp\": 1e-5, \"Ki\": 1e-7, \"A\": 100000, \"T_h\": 7200\n        },\n        {\n            \"N\": 2000, \"P_dev\": 1500, \"R\": 0.01, \"C_th\": 2e5, \"eta\": 2.5, \"Delta\": 0.5,\n            \"sigma\": -1, \"Kp\": 5e-6, \"Ki\": 2e-7, \"A\": 50000, \"T_h\": 7200\n        },\n        {\n            \"N\": 5000, \"P_dev\": 800, \"R\": 0.007, \"C_th\": 8e5, \"eta\": 3.5, \"Delta\": 0.5,\n            \"sigma\": -1, \"Kp\": 5e-5, \"Ki\": 8e-7, \"A\": 200000, \"T_h\": 7200\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        # Extract parameters\n        N = case[\"N\"]\n        R = case[\"R\"]\n        C_th = case[\"C_th\"]\n        eta = case[\"eta\"]\n        sigma = case[\"sigma\"]\n        Kp = case[\"Kp\"]\n        Ki = case[\"Ki\"]\n        A = case[\"A\"]\n        T_h = case[\"T_h\"]\n\n        # 1. Calculate Plant Parameters\n        # Static Gain G (W/K)\n        G = -N / (R * eta)\n        # Relaxation Time tau (s)\n        tau = R * C_th\n        \n        # 2. Stability Analysis\n        # Characteristic equation: a*s^2 + b*s + c = 0\n        a = tau\n        b = 1 + sigma * G * Kp\n        c = sigma * G * Ki\n        \n        # System is stable if a, b, c have the same sign.\n        # Since tau > 0, we check if b > 0 and c > 0.\n        is_stable = 1 if b > 0 and c > 0 else 0\n\n        # 3. Numerical Simulation\n        dt = 1.0  # Time step in seconds\n        num_steps = int(T_h / dt)\n        \n        # State variables: x1 = P_agg, x2 = integral of error\n        x1 = 0.0\n        x2 = 0.0\n        \n        # Performance metrics\n        ise = 0.0\n        max_abs_dTs = 0.0\n        \n        for k in range(num_steps):\n            # Calculate error\n            e = A - x1\n            \n            # Calculate control signal (setpoint offset)\n            dTs = sigma * (Kp * e + Ki * x2)\n            \n            # Update performance metrics\n            ise += e**2 * dt\n            if abs(dTs) > max_abs_dTs:\n                max_abs_dTs = abs(dTs)\n\n            # Update states using Forward Euler method\n            x1_dot = (G * dTs - x1) / tau\n            x2_dot = e\n            \n            x1 += x1_dot * dt\n            x2 += x2_dot * dt\n            \n        # Final error at t = T_h\n        final_error = A - x1\n\n        # Collect results for the current case\n        case_results = [is_stable, ise, final_error, max_abs_dTs]\n        all_results.append(case_results)\n\n    # 4. Format Output\n    # Create the final string in the format [[r1_1,r1_2,...],[r2_1,r2_2,...],...]\n    output_str = \"[\" + \",\".join(\n        \"[\" + \",\".join(map(str, res)) + \"]\" for res in all_results\n    ) + \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}