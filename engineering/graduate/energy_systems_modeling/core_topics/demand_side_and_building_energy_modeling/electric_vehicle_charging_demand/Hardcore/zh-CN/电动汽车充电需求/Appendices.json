{
    "hands_on_practices": [
        {
            "introduction": "要理解电动汽车的充电需求，我们必须首先对其能量消耗进行建模。本练习将带您从基本物理学原理出发，通过应用牛顿定律和标准的阻力模型，计算车辆在特定驾驶循环中的能耗。这项实践将为您建立一个核心能力，即根据车辆的物理参数和驾驶行为来量化其充电需求。",
            "id": "4087464",
            "problem": "一辆电动汽车按照一个特定的驾驶循环运行，该循环由一个随时间变化的速度曲线来表征。目标是计算完成该循环后，将电池恢复到其初始充电状态所需的充电需求。计算必须基于力学基本原理和成熟的车辆建模实践。\n\n从第一性原理出发，使用以下建模基础：\n- Newton第二定律：纵向合力等于质量乘以纵向加速度。用 $m$ 表示质量（单位 $\\mathrm{kg}$），$v(t)$ 表示速度（单位 $\\mathrm{m/s}$），$a(t)$ 表示加速度（单位 $\\mathrm{m/s^2}$）。\n- 滚动阻力模型：滚动阻力与法向力成正比，比例系数为 $c_r$（无量纲），因此滚动阻力的大小为 $c_r \\, m \\, g$，其中 $g$ 是重力加速度（单位 $\\mathrm{m/s^2}$）。\n- 空气动力学阻力模型：空气动力学阻力的大小与速度的平方和动压成正比。使用空气密度 $\\rho$（单位 $\\mathrm{kg/m^3}$）、迎风面积 $A$（单位 $\\mathrm{m^2}$）和风阻系数 $C_d$（无量纲），则阻力大小取决于 $\\tfrac{1}{2}\\,\\rho\\,A\\,C_d\\,v(t)^2$。\n- 车轮处的机械功率等于纵向牵引力乘以速度。采用符号约定，正的机械功率表示能量从电池流向车轮，而负的机械功率表示通过（如果存在的）再生制动，能量从车轮返回到电池。\n\n电能转换假设：\n- 传动系统效率 $\\eta_d$（无量纲）将车轮处的机械功率映射为当机械功率为正时从电池提取的电功率。\n- 再生制动效率 $\\eta_{\\text{reg}}$（无量纲）将车轮处的负机械功率映射为当机械功率为负时回收到电池的电功率。假设对负机械功率进行完全的再生捕获，仅受效率 $\\eta_{\\text{reg}}$ 的限制。\n- 充电效率 $\\eta_{\\text{ch}}$（无量纲）将充电过程中的电网能量映射为电池能量。\n\n通过对机械功率进行时间积分，并使用上述效率将其转换为电能，来计算整个循环中的电池净能量变化。如果电池净能量变化为负（即由于再生制动而产生净能量增益），则将恢复到初始充电状态所需的电网能量设置为零。否则，将电网能量计算为电池能量变化除以充电效率。所有能量结果以千瓦时（$\\mathrm{kWh}$）表示，并四舍五入到六位小数。\n\n时间离散化要求：\n- 对于每个测试用例，在指定的时间范围 $[0, T]$ 上，以时间步长 $\\Delta t = 1$ s 构建一个均匀网格上的 $v(t)$。\n- 通过与均匀网格一致的有限差分法计算 $a(t)$。\n- 使用数值上一致的方法（例如，梯形法则或黎曼和）进行时间积分。\n\n提供一个程序，该程序针对以下测试套件，计算循环结束后将电池充电至初始充电状态所需的电网能量。对每个测试用例使用指定的物理参数。所有速度单位为 $\\mathrm{m/s}$，时间单位为 $\\mathrm{s}$，能量单位为 $\\mathrm{kWh}$。所有情况下的重力加速度均为 $g=9.81$ $\\mathrm{m/s^2}$。\n\n测试套件：\n- 案例 1（基准城市工况）：\n  - 参数：$m=1600$ kg, $c_r=0.012$, $\\rho=1.225$ kg/m^3, $A=2.2$ m^2, $C_d=0.29$, $\\eta_d=0.92$, $\\eta_{\\text{reg}}=0.65$, $\\eta_{\\text{ch}}=0.90$。\n  - 时间范围：$T=600$ s，$\\Delta t=1$ s。\n  - 速度曲线 $v(t)$：\n    - 对于 $t \\in [0, 30]$：从 $0$ 线性加速到 $15$ $\\mathrm{m/s}$。\n    - 对于 $t \\in [30, 150]$：以 $15$ $\\mathrm{m/s}$ 匀速行驶。\n    - 对于 $t \\in [150, 170]$：从 $15$ 线性减速到 $0$ $\\mathrm{m/s}$。\n    - 对于 $t \\in [170, 230]$：以 $0$ $\\mathrm{m/s}$ 停驻。\n    - 对于 $t \\in [230, 260]$：从 $0$ 线性加速到 $12$ $\\mathrm{m/s}$。\n    - 对于 $t \\in [260, 380]$：以 $12$ $\\mathrm{m/s}$ 匀速行驶。\n    - 对于 $t \\in [380, 420]$：从 $12$ 线性减速到 $0$ $\\mathrm{m/s}$。\n    - 对于 $t \\in [420, 600]$：以 $0$ $\\mathrm{m/s}$ 停驻。\n- 案例 2（静止边界情况）：\n  - 参数：与案例 1 相同。\n  - 时间范围：$T=300$ s，$\\Delta t=1$ s。\n  - 速度曲线 $v(t)$：对于所有 $t \\in [0, 300]$ 恒为 $0$。\n- 案例 3（高速加速与再生制动）：\n  - 参数：$m=1600$ kg, $c_r=0.012$, $\\rho=1.225$ kg/m^3, $A=2.2$ m^2, $C_d=0.29$, $\\eta_d=0.92$, $\\eta_{\\text{reg}}=0.75$, $\\eta_{\\text{ch}}=0.90$。\n  - 时间范围：$T=120$ s，$\\Delta t=1$ s。\n  - 速度曲线 $v(t)$：\n    - 对于 $t \\in [0, 30]$：从 $0$ 线性加速到 $30$ $\\mathrm{m/s}$。\n    - 对于 $t \\in [30, 60]$：以 $30$ $\\mathrm{m/s}$ 匀速行驶。\n    - 对于 $t \\in [60, 80]$：从 $30$ 线性减速到 $0$ $\\mathrm{m/s}$。\n    - 对于 $t \\in [80, 120]$：以 $0$ $\\mathrm{m/s}$ 停驻。\n- 案例 4（空气动力学区域，持续巡航）：\n  - 参数：$m=1600$ kg, $c_r=0.012$, $\\rho=1.225$ kg/m^3, $A=2.6$ m^2, $C_d=0.32$, $\\eta_d=0.92$, $\\eta_{\\text{reg}}=0.65$, $\\eta_{\\text{ch}}=0.90$。\n  - 时间范围：$T=600$ s，$\\Delta t=1$ s。\n  - 速度曲线 $v(t)$：对于所有 $t \\in [0, 600]$，以 $33.33$ $\\mathrm{m/s}$ 恒速巡航。\n\n所需输出：\n- 对于每个案例，计算循环后将电池充电至其初始充电状态所需的电网能量，单位为 $\\mathrm{kWh}$，四舍五入至六位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $\\left[\\text{result1},\\text{result2},\\text{result3},\\text{result4}\\right]$），每个结果都四舍五入到六位小数并以 $\\mathrm{kWh}$ 为单位表示。",
            "solution": "该问题提法清晰，具有科学依据，并包含了进行求解所需的所有信息。\n\n### 1. 控制原理与力-功率公式\n\n分析从经典力学的第一性原理开始。电动汽车的运动遵循应用于纵向的Newton第二定律。车辆上的合力是来自传动系统的牵引力与各种阻力之和。对于质量为 $m$ 的车辆在水平路面上以纵向加速度 $a(t)$ 移动，其车轮所需的牵引力 $F_{\\text{tractive}}(t)$ 由下式给出：\n\n$$\nF_{\\text{tractive}}(t) = m \\, a(t) + F_{\\text{res}}(t)\n$$\n\n其中 $F_{\\text{res}}(t)$ 是总阻力。问题指定了两种主要阻力来源：滚动阻力和空气动力学阻力。\n\n滚动阻力 $F_{rr}$ 被建模为与车辆上的法向力成正比。对于水平路面，其表达式为：\n$$\nF_{rr} = c_r \\, m \\, g\n$$\n其中 $c_r$ 是无量纲的滚动阻力系数，$g$ 是重力加速度。此力被假定在车辆运动时为恒定值，并作用于与速度相反的方向。\n\n空气动力学阻力 $F_{ad}(t)$ 与空气的动压和车辆的迎风面积成正比。其大小由下式给出：\n$$\nF_{ad}(t) = \\frac{1}{2} \\, \\rho \\, A \\, C_d \\, v(t)^2\n$$\n其中 $\\rho$ 是空气密度，$A$ 是迎风面积，$C_d$ 是无量纲的风阻系数，$v(t)$ 是车辆的速度。此力也作用于与速度相反的方向。\n\n综合这些分量，遵循指定速度曲线所需的总牵引力为：\n$$\nF_{\\text{tractive}}(t) = m \\, a(t) + c_r \\, m \\, g + \\frac{1}{2} \\, \\rho \\, A \\, C_d \\, v(t)^2\n$$\n符号约定为：驱动时 $F_{\\text{tractive}}(t)$ 为正，制动时为负。\n\n车轮处的机械功率 $P_{\\text{mech}}(t)$ 是牵引力与车辆速度的乘积：\n$$\nP_{\\text{mech}}(t) = F_{\\text{tractive}}(t) \\cdot v(t)\n$$\n正的 $P_{\\text{mech}}(t)$ 表示消耗功率以驱动车辆（驱动工况），而负的 $P_{\\text{mech}}(t)$ 表示能量正从车辆的动能传递到车轮（制动工况），这部分能量可以被部分回收。\n\n### 2. 电功率与能量消耗\n\n车轮处的机械功率通过电动传动系统由车辆电池提供或回收到电池。机械功率和电功率之间的转换受效率影响。\n\n从电池提取或供给到电池的电功率 $P_{\\text{elec}}(t)$ 按如下方式确定：\n- 当驱动时 ($P_{\\text{mech}}(t) > 0$)，功率从电池中提取，转换由传动系统效率 $\\eta_d$ 决定：\n  $$\n  P_{\\text{elec}}(t) = \\frac{P_{\\text{mech}}(t)}{\\eta_d}\n  $$\n- 当制动时 ($P_{\\text{mech}}(t) < 0$)，功率通过再生制动返回到电池，转换由再生效率 $\\eta_{\\text{reg}}$ 决定：\n  $$\n  P_{\\text{elec}}(t) = P_{\\text{mech}}(t) \\cdot \\eta_{\\text{reg}}\n  $$\n- 当 $P_{\\text{mech}}(t) = 0$ 时，没有功率交换，因此 $P_{\\text{elec}}(t) = 0$。\n\n在持续时间为 $T$ 的驾驶循环中，电池储存能量的净变化是电功率的时间积分：\n$$\n\\Delta E_{\\text{batt}} = \\int_{0}^{T} P_{\\text{elec}}(t) \\, dt\n$$\n正的 $\\Delta E_{\\text{batt}}$ 表示电池的净放电。\n\n### 3. 数值离散化与算法\n\n为计算解，我们在均匀的时间网格上对问题进行离散化。时间范围 $[0, T]$ 被划分为 $N$ 个持续时间为 $\\Delta t = 1 \\, \\mathrm{s}$ 的区间，得到时间点 $t_i = i \\cdot \\Delta t$，其中 $i = 0, 1, \\dots, N$。\n\n算法流程如下：\n1.  **构建时间和速度矢量**：创建一个时间矢量 $\\mathbf{t} = [t_0, t_1, \\dots, t_N]$。通过在每个时间点 $t_i$ 对给定的分段速度曲线进行采样，构建相应的速度矢量 $\\mathbf{v} = [v_0, v_1, \\dots, v_N]$。\n2.  **计算加速度矢量**：加速度矢量 $\\mathbf{a} = [a_0, a_1, \\dots, a_N]$ 是使用速度矢量 $\\mathbf{v}$ 上的有限差分近似计算的。一种标准方法，如 `numpy.gradient`，对内部点使用中心差分，对边界点使用二阶精确的单边差分，是合适且一致的。给定 $\\Delta t=1 \\, \\mathrm{s}$，这可以直接应用于速度矢量。\n3.  **计算瞬时力和功率**：对于每个时间索引 $i$：\n    a. 牵引力：$F_{\\text{tractive}, i} = m \\, a_i + c_r \\, m \\, g + \\frac{1}{2} \\, \\rho \\, A \\, C_d \\, v_i^2$。\n    b. 机械功率：$P_{\\text{mech}, i} = F_{\\text{tractive}, i} \\cdot v_i$。\n    c. 电功率：$P_{\\text{elec}, i}$ 根据 $P_{\\text{mech}, i}$ 的符号以及相应的效率 $\\eta_d$ 或 $\\eta_{\\text{reg}}$ 计算。\n4.  **积分电功率**：电池净能量变化 $\\Delta E_{\\text{batt}}$ 是通过对电功率矢量 $\\mathbf{P}_{\\text{elec}}$ 进行时间上的数值积分来计算的。梯形法是一种合适且数值上一致的方法：\n    $$\n    \\Delta E_{\\text{batt}} \\approx \\sum_{i=1}^{N} \\frac{P_{\\text{elec}, i} + P_{\\text{elec}, i-1}}{2} \\Delta t\n    $$\n    这将应用于计算出的功率值，得到以焦耳为单位的结果。\n\n### 4. 电网能量计算\n\n最终目标是求出从电网获取的、用于将电池恢复到其初始状态所需的能量 $E_{\\text{grid}}$。\n1.  **单位转换**：使用转换因子 $1 \\, \\mathrm{kWh} = 3.6 \\times 10^6 \\, \\mathrm{J}$，将以焦耳为单位计算出的 $\\Delta E_{\\text{batt}}$ 转换为千瓦时（kWh）。\n    $$\n    \\Delta E_{\\text{batt}} [\\mathrm{kWh}] = \\frac{\\Delta E_{\\text{batt}} [\\mathrm{J}]}{3.6 \\times 10^6}\n    $$\n2.  **充电逻辑**：\n    - 如果 $\\Delta E_{\\text{batt}} \\le 0$，车辆在循环中经历了净能量增益（由于显著的再生制动）。不需要充电。因此，$E_{\\text{grid}} = 0$。\n    - 如果 $\\Delta E_{\\text{batt}} > 0$，电池已被放电。从电网所需的能量必须考虑充电效率 $\\eta_{\\text{ch}}$。\n      $$\n      E_{\\text{grid}} = \\frac{\\Delta E_{\\text{batt}} [\\mathrm{kWh}]}{\\eta_{\\text{ch}}}\n      $$\n3.  **最终结果**：按要求将计算出的 $E_{\\text{grid}}$ 值四舍五入到六位小数。对提供的每个测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_grid_energy(params, cycle_def):\n    \"\"\"\n    Computes the grid energy required to recharge an EV battery after a driving cycle.\n    \n    Args:\n        params (dict): Dictionary of vehicle and efficiency parameters.\n        cycle_def (dict): Dictionary defining the driving cycle horizon and speed profile.\n\n    Returns:\n        float: Grid energy in kWh, rounded to 6 decimal places.\n    \"\"\"\n    # Unpack parameters\n    m = params['m']\n    c_r = params['c_r']\n    rho = params['rho']\n    A = params['A']\n    C_d = params['C_d']\n    eta_d = params['eta_d']\n    eta_reg = params['eta_reg']\n    eta_ch = params['eta_ch']\n    g = 9.81\n\n    # Unpack cycle definition\n    T = cycle_def['T']\n    dt = cycle_def['dt']\n    speed_profile = cycle_def['speed_profile']\n\n    # 1. Construct Time and Velocity Vectors\n    time = np.arange(0, T + dt, dt)\n    v = np.zeros_like(time, dtype=float)\n\n    for segment in speed_profile:\n        t_start, t_end = segment[0], segment[1]\n        v_start, v_end = segment[2], segment[3]\n        \n        # Find indices corresponding to the time segment\n        start_idx = int(t_start / dt)\n        end_idx = int(t_end / dt)\n        num_points = end_idx - start_idx + 1\n\n        if v_start == v_end: # Constant speed (cruise or dwell)\n            v[start_idx : end_idx + 1] = v_start\n        else: # Linear acceleration/deceleration\n            v[start_idx : end_idx + 1] = np.linspace(v_start, v_end, num_points)\n\n    # 2. Compute Acceleration Vector\n    a = np.gradient(v, dt)\n\n    # 3. Calculate Instantaneous Forces and Powers\n    F_rr = c_r * m * g\n    F_ad = 0.5 * rho * A * C_d * v**2\n    F_tractive = m * a + F_rr + F_ad\n\n    P_mech = F_tractive * v\n    \n    # Use np.where for conditional power calculation\n    P_elec = np.where(P_mech > 0, P_mech / eta_d, P_mech * eta_reg)\n\n    # 4. Integrate Electrical Power (Trapezoidal Rule)\n    delta_E_batt_J = np.trapz(P_elec, time)\n\n    # 5. Grid Energy Calculation\n    # Convert Joules to kWh\n    delta_E_batt_kWh = delta_E_batt_J / 3.6e6\n\n    if delta_E_batt_kWh <= 0:\n        E_grid = 0.0\n    else:\n        E_grid = delta_E_batt_kWh / eta_ch\n\n    return round(E_grid, 6)\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the results for the problem.\n    \"\"\"\n    g = 9.81  # m/s^2\n\n    test_cases = [\n        {\n            \"params\": {\n                'm': 1600, 'c_r': 0.012, 'rho': 1.225, 'A': 2.2, 'C_d': 0.29,\n                'eta_d': 0.92, 'eta_reg': 0.65, 'eta_ch': 0.90\n            },\n            \"cycle_def\": {\n                'T': 600, 'dt': 1,\n                'speed_profile': [\n                    (0, 30, 0, 15), (30, 150, 15, 15), (150, 170, 15, 0),\n                    (170, 230, 0, 0), (230, 260, 0, 12), (260, 380, 12, 12),\n                    (380, 420, 12, 0), (420, 600, 0, 0)\n                ]\n            }\n        },\n        {\n            \"params\": {\n                'm': 1600, 'c_r': 0.012, 'rho': 1.225, 'A': 2.2, 'C_d': 0.29,\n                'eta_d': 0.92, 'eta_reg': 0.65, 'eta_ch': 0.90\n            },\n            \"cycle_def\": {\n                'T': 300, 'dt': 1,\n                'speed_profile': [(0, 300, 0, 0)]\n            }\n        },\n        {\n            \"params\": {\n                'm': 1600, 'c_r': 0.012, 'rho': 1.225, 'A': 2.2, 'C_d': 0.29,\n                'eta_d': 0.92, 'eta_reg': 0.75, 'eta_ch': 0.90\n            },\n            \"cycle_def\": {\n                'T': 120, 'dt': 1,\n                'speed_profile': [\n                    (0, 30, 0, 30), (30, 60, 30, 30), (60, 80, 30, 0),\n                    (80, 120, 0, 0)\n                ]\n            }\n        },\n        {\n            \"params\": {\n                'm': 1600, 'c_r': 0.012, 'rho': 1.225, 'A': 2.6, 'C_d': 0.32,\n                'eta_d': 0.92, 'eta_reg': 0.65, 'eta_ch': 0.90\n            },\n            \"cycle_def\": {\n                'T': 600, 'dt': 1,\n                'speed_profile': [(0, 600, 33.33, 33.33)]\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_grid_energy(case[\"params\"], case[\"cycle_def\"])\n        results.append(f\"{result:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在确定了车辆的能耗之后，下一步是模拟充电过程中能量是如何补充的。本练习将深入探讨直流快充中普遍采用的恒流-恒压（CC-CV）充电协议。基于一个标准的电池等效电路模型，您将推导出充电电流和功率随电池荷电状态（$s$）变化的解析表达式，从而理解高荷电状态时充电功率逐渐减小的“锥化”现象背后的物理原理。",
            "id": "4087498",
            "problem": "考虑一个电动汽车（EV）电池包，其在一个两阶段控制策略下进行直流（DC）快速充电：一个恒流（CC）阶段，随后是一个恒压（CV）阶段。令荷电状态（SOC）由无量纲变量 $s \\in [0,1]$ 表示。用一个准静态等效电路对该电池包进行建模，该电路包含一个依赖于SOC的开路电压（OCV）$v_{\\mathrm{oc}}(s)$ 和一个依赖于SOC的等效内阻 $r(s)$，后者聚合了各单体电池内阻和连接件的贡献。假设在充电电流 $i(s)$ 下，电池包端电压 $v(s)$ 满足本构关系\n$$\nv(s) = v_{\\mathrm{oc}}(s) + i(s)\\, r(s),\n$$\n其中 $v_{\\mathrm{oc}}(s)$ 和 $r(s)$ 是关于 $s$ 的平滑函数，并且对于所有 $s \\in [0,1]$ 都有 $r(s) > 0$。恒流阶段施加一个恒定电流 $I_{\\mathrm{cc}} > 0$，直到端电压达到预设的恒压钳位电压 $V_{\\mathrm{cv}} > 0$。此时，充电过程转换到恒压阶段，在该阶段中 $v(s)$ 保持在 $V_{\\mathrm{cv}}$，并且随着 $s$ 的增加，电流逐渐减小。\n\n为使电流衰减过程在解析上易于处理且在物理上保持合理，假设参数形式为\n$$\nv_{\\mathrm{oc}}(s) = v_{\\min} + k\\, s, \\quad k > 0, \\quad v_{\\min} > 0,\n$$\n$$\nr(s) = r_0 \\left(1 - \\gamma s\\right), \\quad r_0 > 0, \\quad 0 < \\gamma < 1,\n$$\n这描述了开路电压随SOC增加而增加，以及等效内阻随SOC增加而适度减小的情况。令恒流到恒压的转换发生在SOC为 $s^{\\dagger} \\in (0,1)$ 时，此时恒流阶段的端电压等于恒压钳位电压。并假设参数满足 $k - I_{\\mathrm{cc}} r_0 \\gamma > 0$ 和 $v_{\\min} + I_{\\mathrm{cc}} r_0 \\le V_{\\mathrm{cv}} \\le v_{\\min} + k + I_{\\mathrm{cc}} r_0 (1 - \\gamma)$，以确保在SOC范围内存在一个唯一的、物理上有意义的转换。\n\n从等效电路关系 $v(s) = v_{\\mathrm{oc}}(s) + i(s)\\, r(s)$、恒流/恒压控制定义以及瞬时充电功率的定义 $P(s) = v(s)\\, i(s)$ 出发，推导在 $s \\in [0,1]$ 范围内，依赖于SOC的充电电流 $I(s)$ 和功率 $P(s)$ 的衰减函数。这些函数应以分段形式表示，覆盖恒流和恒压两个阶段，并由 $v_{\\min}$、$k$、$r_0$、$\\gamma$、$I_{\\mathrm{cc}}$ 和 $V_{\\mathrm{cv}}$ 显式参数化。同时，通过施加恒流到恒压的转换条件，推导 $s^{\\dagger}$ 关于这些参数的显式表达式。请将您的最终答案表示为 $I(s)$、$P(s)$ 和 $s^{\\dagger}$ 的闭式解析表达式。无需进行数值评估。最终答案中不应包含单位。如果您使用不等式来陈述条件，请不要将其包含在最终答案中。",
            "solution": "### 问题验证\n\n#### 步骤1：提取已知条件\n问题提供了以下数据、定义和条件：\n-   **荷电状态（SOC）：** 无量纲变量 $s \\in [0,1]$。\n-   **等效电路模型：** 端电压 $v(s)$ 通过本构关系 $v(s) = v_{\\mathrm{oc}}(s) + i(s)\\, r(s)$ 与开路电压 $v_{\\mathrm{oc}}(s)$ 和内阻 $r(s)$ 相关联，其中 $i(s)$ 是充电电流。\n-   **OCV的参数形式：** $v_{\\mathrm{oc}}(s) = v_{\\min} + k\\, s$，其中常数 $k > 0$ 且 $v_{\\min} > 0$。\n-   **内阻的参数形式：** $r(s) = r_0 \\left(1 - \\gamma s\\right)$，其中常数 $r_0 > 0$ 且 $0 < \\gamma < 1$。\n-   **恒流-恒压充电策略：**\n    -   **恒流（CC）阶段：** 施加恒定电流 $I_{\\mathrm{cc}} > 0$。\n    -   **恒压（CV）阶段：** 端电压保持在恒定的钳位电压 $V_{\\mathrm{cv}} > 0$。\n-   **转换条件：** 从恒流阶段到恒压阶段的切换发生在SOC为 $s^{\\dagger} \\in (0,1)$ 时，此时恒流阶段的端电压达到 $V_{\\mathrm{cv}}$。\n-   **参数约束：** 问题明确指出参数满足 $k - I_{\\mathrm{cc}} r_0 \\gamma > 0$ 和 $v_{\\min} + I_{\\mathrm{cc}} r_0 \\le V_{\\mathrm{cv}} \\le v_{\\min} + k + I_{\\mathrm{cc}} r_0 (1 - \\gamma)$，以确保存在一个唯一的、物理上有意义的转换。\n-   **功率定义：** 瞬时充电功率为 $P(s) = v(s)\\, i(s)$。\n\n#### 步骤2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估：\n-   **科学依据：** 该问题基于标准的电池一阶Thévenin等效电路模型和工业标准的恒流-恒压（CC-CV）充电协议。对OCV和内阻的线性参数化是在特定工作范围内进行解析建模的常见且有效的简化方法。该模型在科学上是合理的，并与能源系统领域相关。\n-   **适定性：** 问题陈述在数学上是精确的。它提供了推导所需量（$s^{\\dagger}$、$I(s)$、$P(s)$）的所有必要方程和参数形式。对参数的显式约束旨在保证恒流到恒压的转换发生在有效范围 $(0,1)$ 内的一个唯一SOC值 $s^{\\dagger}$ 处，从而确保问题是适定的且有唯一解。\n-   **客观性：** 问题采用客观、定量的语言表述，没有任何主观或模糊的术语。\n\n该问题不存在任何列出的缺陷（例如，科学上不合理、不完整、矛盾、不可行或含糊不清）。\n\n#### 步骤3：结论与行动\n该问题是**有效的**。将提供一个完整的、有理有据的解答。\n\n### 解答推导\n\n推导过程首先分别分析充电过程的两个阶段，然后合并结果。关键在于推导恒流阶段的端电压 $v(s)$，找出转换SOC $s^{\\dagger}$（在该点 $v(s^{\\dagger}) = V_{\\mathrm{cv}}$），然后确定恒压阶段的衰减电流和功率。\n\n**1. 恒流（CC）阶段：$s \\in [0, s^{\\dagger}]$**\n\n在此阶段，根据定义，充电电流是恒定的：\n$$I(s) = I_{\\mathrm{cc}}$$\n通过将给定的 $v_{\\mathrm{oc}}(s)$、$r(s)$ 和 $I(s)$ 的参数形式代入本构关系，可以求得端电压 $v(s)$：\n$$v(s) = v_{\\mathrm{oc}}(s) + I(s) r(s)$$\n$$v(s) = (v_{\\min} + k s) + I_{\\mathrm{cc}} \\left( r_0 (1 - \\gamma s) \\right)$$\n$$v(s) = v_{\\min} + I_{\\mathrm{cc}} r_0 + (k - I_{\\mathrm{cc}} r_0 \\gamma) s$$\n恒流阶段的瞬时功率 $P(s)$ 是端电压和恒定电流的乘积：\n$$P(s) = v(s) I(s) = \\left( v_{\\min} + I_{\\mathrm{cc}} r_0 + (k - I_{\\mathrm{cc}} r_0 \\gamma) s \\right) I_{\\mathrm{cc}}$$\n简化后得到：\n$$P(s) = I_{\\mathrm{cc}} (v_{\\min} + I_{\\mathrm{cc}} r_0) + I_{\\mathrm{cc}}(k - I_{\\mathrm{cc}} r_0 \\gamma) s$$\n\n**2. 恒流到恒压的转换SOC：$s^{\\dagger}$**\n\n从恒流阶段到恒压阶段的转换发生在SOC为 $s^{\\dagger}$ 时，此时恒流阶段的端电压 $v(s)$ 首次达到钳位电压 $V_{\\mathrm{cv}}$。我们设 $v(s^{\\dagger}) = V_{\\mathrm{cv}}$：\n$$V_{\\mathrm{cv}} = v_{\\min} + I_{\\mathrm{cc}} r_0 + (k - I_{\\mathrm{cc}} r_0 \\gamma) s^{\\dagger}$$\n求解 $s^{\\dagger}$ 可得：\n$$(k - I_{\\mathrm{cc}} r_0 \\gamma) s^{\\dagger} = V_{\\mathrm{cv}} - v_{\\min} - I_{\\mathrm{cc}} r_0$$\n$$s^{\\dagger} = \\frac{V_{\\mathrm{cv}} - v_{\\min} - I_{\\mathrm{cc}} r_0}{k - I_{\\mathrm{cc}} r_0 \\gamma}$$\n问题陈述的约束条件 $k - I_{\\mathrm{cc}} r_0 \\gamma > 0$ 确保分母为正且非零。约束条件 $v_{\\min} + I_{\\mathrm{cc}} r_0 \\le V_{\\mathrm{cv}}$ 确保分子为正，因此 $s^{\\dagger} > 0$。约束条件 $V_{\\mathrm{cv}} \\le v_{\\min} + k + I_{\\mathrm{cc}} r_0 (1 - \\gamma)$ 意味着 $V_{\\mathrm{cv}} - v_{\\min} - I_{\\mathrm{cc}} r_0 \\le k - I_{\\mathrm{cc}} r_0 \\gamma$，这确保了 $s^{\\dagger} \\le 1$。因此，推导出的 $s^{\\dagger}$ 保证在物理上有意义的范围 $(0,1]$ 内。\n\n**3. 恒压（CV）阶段：$s \\in (s^{\\dagger}, 1]$**\n\n在此阶段，根据定义，端电压保持恒定：\n$$v(s) = V_{\\mathrm{cv}}$$\n充电电流 $I(s)$ 不再是恒定的，而是逐渐减小。我们通过重排本构关系来找到其表达式：\n$$V_{\\mathrm{cv}} = v_{\\mathrm{oc}}(s) + I(s) r(s) \\implies I(s) = \\frac{V_{\\mathrm{cv}} - v_{\\mathrm{oc}}(s)}{r(s)}$$\n代入 $v_{\\mathrm{oc}}(s)$ 和 $r(s)$ 的参数形式：\n$$I(s) = \\frac{V_{\\mathrm{cv}} - (v_{\\min} + k s)}{r_0 (1 - \\gamma s)} = \\frac{V_{\\mathrm{cv}} - v_{\\min} - k s}{r_0 (1 - \\gamma s)}$$\n恒压阶段的瞬时功率 $P(s)$ 是恒定端电压和衰减电流的乘积：\n$$P(s) = v(s) I(s) = V_{\\mathrm{cv}} \\left( \\frac{V_{\\mathrm{cv}} - v_{\\min} - k s}{r_0 (1 - \\gamma s)} \\right)$$\n\n**4. 最终分段表达式**\n\n结合恒流和恒压阶段的结果，我们得到了在整个SOC范围 $s \\in [0,1]$ 内充电电流 $I(s)$ 和功率 $P(s)$ 的完整分段表达式。\n\n**电流 $I(s)$：**\n$$ I(s) = \\begin{cases} I_{\\mathrm{cc}} & \\text{for } 0 \\le s \\le s^{\\dagger} \\\\ \\frac{V_{\\mathrm{cv}} - v_{\\min} - k s}{r_0 (1 - \\gamma s)} & \\text{for } s^{\\dagger} < s \\le 1 \\end{cases} $$\n\n**功率 $P(s)$：**\n$$ P(s) = \\begin{cases} I_{\\mathrm{cc}} \\left( v_{\\min} + I_{\\mathrm{cc}} r_0 + (k - I_{\\mathrm{cc}} r_0 \\gamma) s \\right) & \\text{for } 0 \\le s \\le s^{\\dagger} \\\\ V_{\\mathrm{cv}} \\left( \\frac{V_{\\mathrm{cv}} - v_{\\min} - k s}{r_0 (1 - \\gamma s)} \\right) & \\text{for } s^{\\dagger} < s \\le 1 \\end{cases} $$\n\n这些表达式，连同推导出的 $s^{\\dagger}$ 公式，构成了该问题的完整解答。",
            "answer": "$$\n\\boxed{\n\\begin{aligned}\n&s^{\\dagger} = \\frac{V_{\\mathrm{cv}} - v_{\\min} - I_{\\mathrm{cc}} r_0}{k - I_{\\mathrm{cc}} r_0 \\gamma} \\\\\n\\\\\n&I(s) =\n\\begin{cases}\nI_{\\mathrm{cc}} & \\text{for } 0 \\le s \\le s^{\\dagger} \\\\\n\\frac{V_{\\mathrm{cv}} - v_{\\min} - k s}{r_0 (1 - \\gamma s)} & \\text{for } s^{\\dagger} < s \\le 1\n\\end{cases} \\\\\n\\\\\n&P(s) =\n\\begin{cases}\nI_{\\mathrm{cc}} ( v_{\\min} + I_{\\mathrm{cc}} r_0 + (k - I_{\\mathrm{cc}} r_0 \\gamma) s ) & \\text{for } 0 \\le s \\le s^{\\dagger} \\\\\nV_{\\mathrm{cv}} \\frac{V_{\\mathrm{cv}} - v_{\\min} - k s}{r_0 (1 - \\gamma s)} & \\text{for } s^{\\dagger} < s \\le 1\n\\end{cases}\n\\end{aligned}\n}\n$$"
        },
        {
            "introduction": "现实世界中的充电不仅涉及物理过程，还涉及规划与约束。最后的这项练习将我们的视角提升到充电管理层面，运用优化方法来判断一个充电目标是否可以实现。您将把充电调度问题构建为一个线性规划模型，其中包含了充电桩可用性、功率限制和最小出行电量需求等约束条件，这对于智能充电和车网互动等高级应用至关重要。",
            "id": "4087499",
            "problem": "考虑一个在离散化时间范围内的单个电动汽车充电问题。设时间范围划分为 $D$ 个时隙，索引为 $t \\in \\{0,1,\\dots,D-1\\}$，每个时隙时长为 $\\Delta t$ 小时。设电动汽车电池的能量容量为 $E_{\\mathrm{cap}}$ 千瓦时 (kWh)，初始充电状态为 $\\mathrm{SOC}_0 \\in [0,1]$，充电效率为 $\\eta \\in (0,1]$，该效率将插头处输送的电能线性映射到电池中存储的能量。决策变量是充电功率 $\\{p_t\\}_{t=0}^{D-1}$，单位为千瓦 (kW)，并受制于反映物理和运营限制的线性约束。\n\n基本原理和模型：\n- 根据能量守恒定律，电池中存储的能量随输送功率的增加而增加，其关系式为 $\\Delta E_t = \\eta\\, p_t\\, \\Delta t$，其中 $\\Delta E_t$ 是时隙 $t$ 期间电池能量的增量，而 $p_t$ 是时隙 $t$ 期间的插头功率。\n- 充电状态的演变过程为 $\\mathrm{SOC}_{t+1} = \\mathrm{SOC}_t + \\dfrac{\\Delta E_t}{E_{\\mathrm{cap}}} = \\mathrm{SOC}_t + \\dfrac{\\eta\\, p_t\\, \\Delta t}{E_{\\mathrm{cap}}}$。\n- 定义 $\\alpha = \\dfrac{\\eta\\, \\Delta t}{E_{\\mathrm{cap}}}$。则 $\\mathrm{SOC}_D = \\mathrm{SOC}_0 + \\alpha \\sum_{t=0}^{D-1} p_t$。\n\n约束条件：\n- 功率非负性：对于所有 $t$，$p_t \\ge 0$。\n- 可用性窗口和功率限制：设 $a_t \\in \\{0,1\\}$ 表示可用性（如果 $a_t=1$，表示车辆在时隙 $t$ 期间已连接；否则 $a_t=0$），设 $P^{\\max}_t$ 为时隙 $t$ 期间充电桩的最大功率（单位：千瓦），设 $P^{\\mathrm{grid}}_t$ 为时隙 $t$ 期间外生的电网或馈线功率上限。则对于所有 $t$，$p_t \\le a_t \\cdot \\min\\{P^{\\max}_t, P^{\\mathrm{grid}}_t\\}$。\n- 最低出行充电状态：在任何时隙边界 $t$，强制要求 $\\mathrm{SOC}_t \\ge \\mathrm{SOC}_{\\min}$，其中 $\\mathrm{SOC}_{\\min} \\in [0,1]$ 是一项出行要求。\n- 截止时间前的目标：强制要求 $\\mathrm{SOC}_D \\ge \\mathrm{SOC}_{\\mathrm{target}}$，其中 $\\mathrm{SOC}_{\\mathrm{target}} \\in [0,1]$ 是到时隙 $D$ 时所要求的充电状态。\n\n公式化：\n- 可行性问题是一个线性规划，其决策变量为 $p_t$，并带有线性不等式约束。利用 $\\alpha$ 的定义，截止时间前的目标约束可以写成 $\\alpha \\sum_{t=0}^{D-1} p_t \\ge \\mathrm{SOC}_{\\mathrm{target}} - \\mathrm{SOC}_0$，这是一个线性约束。中间时刻的最低出行约束可以写成 $\\alpha \\sum_{k=0}^{t-1} p_k \\ge \\mathrm{SOC}_{\\min} - \\mathrm{SOC}_0$（对于 $t=1,\\dots,D$），这些也是线性的。目标函数可以为零函数，因为只要求可行性。\n\n你的任务：\n- 编写一个程序，为每个测试用例构建所述的线性规划，求解它，并返回一个布尔值，指示约束是否可行（即，是否存在满足所有约束的某个充电计划 $\\{p_t\\}$）。如果 $D=0$，则将约束解释为要求 $\\mathrm{SOC}_0 \\ge \\mathrm{SOC}_{\\mathrm{target}}$ 和 $\\mathrm{SOC}_0 \\ge \\mathrm{SOC}_{\\min}$。\n- 单位：功率必须以千瓦 (kW) 处理，能量以千瓦时 (kWh) 处理，时间以小时处理，充电状态以 $[0,1]$ 范围内的小数表示（例如，$0.8$）。每个测试用例的最终布尔结果应在不进行四舍五入或截断的情况下计算，并打印为 $True$ 或 $False$。\n\n测试套件：\n为以下四个测试用例提供结果，每个用例指定为 $(E_{\\mathrm{cap}}, \\Delta t, D, \\eta, \\mathrm{SOC}_0, \\mathrm{SOC}_{\\min}, \\mathrm{SOC}_{\\mathrm{target}}, \\{P^{\\max}_t\\}_{t=0}^{D-1}, \\{P^{\\mathrm{grid}}_t\\}_{t=0}^{D-1}, \\{a_t\\}_{t=0}^{D-1})$：\n1. 连续可用且采用典型交流2级充电的理想路径可行性：\n   - $E_{\\mathrm{cap}} = 60$ kWh, $\\Delta t = 0.25$ h, $D = 16$, $\\eta = 0.92$, $\\mathrm{SOC}_0 = 0.5$, $\\mathrm{SOC}_{\\min} = 0.2$, $\\mathrm{SOC}_{\\mathrm{target}} = 0.8$, 对所有 $t$, $P^{\\max}_t = 7$ kW, 对所有 $t$, $P^{\\mathrm{grid}}_t = 10$ kW, 对所有 $t$, $a_t = 1$。\n2. 因可用性不足和功率过低而不可行：\n   - $E_{\\mathrm{cap}} = 60$ kWh, $\\Delta t = 1.0$ h, $D = 1$, $\\eta = 0.92$, $\\mathrm{SOC}_0 = 0.7$, $\\mathrm{SOC}_{\\min} = 0.2$, $\\mathrm{SOC}_{\\mathrm{target}} = 0.9$, $P^{\\max}_0 = 3.6$ kW, $P^{\\mathrm{grid}}_0 = 3.6$ kW, $a_0 = 1$。\n3. 立即截止的边界情况：\n   - $E_{\\mathrm{cap}} = 50$ kWh, $\\Delta t = 0.25$ h, $D = 0$, $\\eta = 0.90$, $\\mathrm{SOC}_0 = 0.7$, $\\mathrm{SOC}_{\\min} = 0.6$, $\\mathrm{SOC}_{\\mathrm{target}} = 0.7$。由于没有时隙，$P^{\\max}_t$、$P^{\\mathrm{grid}}_t$ 和 $a_t$ 为空序列。\n4. 间歇性可用和功率限制变化下的精确可行性边界：\n   - $E_{\\mathrm{cap}} = 50$ kWh, $\\Delta t = 0.25$ h, $D = 5$, $\\eta = 0.80$, $\\mathrm{SOC}_0 = 0.6$, $\\mathrm{SOC}_{\\min} = 0.2$, $\\mathrm{SOC}_{\\mathrm{target}} = 0.8$, $P^{\\max}_t = [20, 20, 15, 20, 15]$ kW, $P^{\\mathrm{grid}}_t = [25, 25, 25, 25, 25]$ kW, $a_t = [1, 0, 1, 0, 1]$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含测试套件的布尔结果，格式为方括号内以逗号分隔的列表，例如，$[True,False,True,True]$。",
            "solution": "我们从能量守恒定律开始，该定律指出，一个系统中储存能量的变化率等于净输入功率。对于一个充电效率为 $\\eta \\in (0,1]$ 的电动汽车电池，当充电桩在时长为 $\\Delta t$ 小时的时隙内输送 $p_t$ 千瓦的电功率时，电池中存储的能量增加 $\\Delta E_t = \\eta\\, p_t\\, \\Delta t$ 千瓦时。充电状态，表示为 $\\mathrm{SOC}_t \\in [0,1]$，是电池能量容量 $E_{\\mathrm{cap}}$ 已填充的比例，因此时隙 $t$ 中充电状态的增量变化是\n$$\n\\Delta \\mathrm{SOC}_t = \\frac{\\Delta E_t}{E_{\\mathrm{cap}}} = \\frac{\\eta\\, p_t\\, \\Delta t}{E_{\\mathrm{cap}}}.\n$$\n因此，离散时间的充电状态动态方程为\n$$\n\\mathrm{SOC}_{t+1} = \\mathrm{SOC}_t + \\frac{\\eta\\, p_t\\, \\Delta t}{E_{\\mathrm{cap}}}.\n$$\n定义常数\n$$\n\\alpha = \\frac{\\eta\\, \\Delta t}{E_{\\mathrm{cap}}}.\n$$\n通过重复代入，截止时隙 $D$ 的充电状态为\n$$\n\\mathrm{SOC}_D = \\mathrm{SOC}_0 + \\alpha \\sum_{t=0}^{D-1} p_t.\n$$\n\n我们现在收集物理和操作限制所要求的约束条件，并以线性形式表示它们：\n- 功率非负性：对于所有 $t$，$p_t \\ge 0$。\n- 可用性和功率限制：设 $a_t \\in \\{0,1\\}$ 表示车辆在时隙 $t$ 是否已连接，设 $P^{\\max}_t$ 为充电桩额定功率（单位：千瓦），设 $P^{\\mathrm{grid}}_t$ 为电网功率上限（单位：千瓦）。时隙 $t$ 的可行上限是\n$$\n\\overline{P}_t = a_t \\cdot \\min\\{P^{\\max}_t, P^{\\mathrm{grid}}_t\\},\n$$\n因此，对于所有 $t$，我们有 $p_t \\le \\overline{P}_t$。\n- 最低出行充电状态：强制要求对于每个中间时隙边界，\n$$\n\\mathrm{SOC}_t \\ge \\mathrm{SOC}_{\\min} \\quad \\text{for all } t \\in \\{0,1,\\dots,D\\}.\n$$\n由于模型中没有放电，只要 $\\mathrm{SOC}_0 \\ge \\mathrm{SOC}_{\\min}$，这些约束就是非绑定的，但为了完整性，可以将它们包含在线性规划中。\n- 截止时间前目标要求：\n$$\n\\mathrm{SOC}_D \\ge \\mathrm{SOC}_{\\mathrm{target}}.\n$$\n\n所有约束对于决策变量 $\\{p_t\\}$ 都是线性的。特别地，目标约束可以写成\n$$\n\\alpha \\sum_{t=0}^{D-1} p_t \\ge \\mathrm{SOC}_{\\mathrm{target}} - \\mathrm{SOC}_0,\n$$\n并且每个最低出行约束可以写成\n$$\n\\alpha \\sum_{k=0}^{t-1} p_k \\ge \\mathrm{SOC}_{\\min} - \\mathrm{SOC}_0 \\quad \\text{for } t=1,\\dots,D.\n$$\n为了使用带有上界的不等式形式的标准线性规划求解器，我们将其表示为\n$$\n-\\alpha \\sum_{t=0}^{D-1} p_t \\le -(\\mathrm{SOC}_{\\mathrm{target}} - \\mathrm{SOC}_0),\n$$\n以及\n$$\n-\\alpha \\sum_{k=0}^{t-1} p_k \\le -(\\mathrm{SOC}_{\\min} - \\mathrm{SOC}_0), \\quad t=1,\\dots,D.\n$$\n\n我们将可行性线性规划公式化为：\n- 决策变量：$p_t$，$t=0,\\dots,D-1$。\n- 目标：最小化 $0$（零函数），即任何可行点都是可接受的。\n- 不等式约束：如上所述的转换后的目标约束和最低出行约束。\n- 边界：对每个 $t$，有 $0 \\le p_t \\le \\overline{P}_t$。\n\n算法设计：\n1. 对于每个测试用例，计算 $\\alpha = \\dfrac{\\eta\\, \\Delta t}{E_{\\mathrm{cap}}}$。\n2. 如果 $D=0$，则没有决策变量。可行性简化为检查 $\\mathrm{SOC}_0 \\ge \\mathrm{SOC}_{\\mathrm{target}}$ 和 $\\mathrm{SOC}_0 \\ge \\mathrm{SOC}_{\\min}$。如果两者都成立，则返回 $True$，否则返回 $False$。\n3. 否则，构建上界 $\\overline{P}_t = a_t \\cdot \\min\\{P^{\\max}_t, P^{\\mathrm{grid}}_t\\}$（对于 $t=0,\\dots,D-1$），并设置变量边界为 $0 \\le p_t \\le \\overline{P}_t$。\n4. 构建不等式矩阵-向量对 $(A_{\\mathrm{ub}}, b_{\\mathrm{ub}})$：\n   - 目标约束行具有条目 $A_{\\mathrm{ub}}^{(0,t)} = -\\alpha$（对于 $t=0,\\dots,D-1$）和 $b_{\\mathrm{ub}}^{(0)} = -(\\mathrm{SOC}_{\\mathrm{target}} - \\mathrm{SOC}_0)$。\n   - 对于每个 $t=1,\\dots,D$，一个最低出行约束行具有条目 $A_{\\mathrm{ub}}^{(t,u)} = -\\alpha$（对于 $u=0,\\dots,t-1$）和 $A_{\\mathrm{ub}}^{(t,u)} = 0$（对于 $u=t,\\dots,D-1$），以及 $b_{\\mathrm{ub}}^{(t)} = -(\\mathrm{SOC}_{\\min} - \\mathrm{SOC}_0)$。\n5. 将目标向量 $c$ 设置为长度为 $D$ 的零向量，并求解线性规划。如果求解器报告有可行解，则返回 $True$；否则，返回 $False$。\n\n测试套件解释：\n- 在第一种情况下，累积的可用能量和效率足以达到目标，因此预期是可行的。\n- 在第二种情况下，单个低功率时隙不足以产生所需的充电状态增量，因此预期是不可行的。\n- 在第三种情况下，由于截止时间立即到来且没有充电机会，可行性完全取决于初始充电状态是否同时满足目标和最低要求。\n- 在第四种情况下，上界和可用性的构造使得在给定效率下，累积可能充电量恰好满足所需的充电状态增量，从而在边界上达到精确可行。\n\n该程序实现了此公式，并以指定的单行格式打印四个测试用例的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef check_feasibility(E_cap, dt, D, eta, soc0, soc_min, soc_target,\n                      pmax, pgrid, availability):\n    \"\"\"\n    Check feasibility of reaching soc_target by deadline with linear constraints.\n    Parameters:\n        E_cap (float): Battery capacity in kWh.\n        dt (float): Slot duration in hours.\n        D (int): Number of slots to the deadline.\n        eta (float): Charging efficiency (0..1].\n        soc0 (float): Initial state of charge (0..1).\n        soc_min (float): Minimum mobility SOC (0..1).\n        soc_target (float): Target SOC by deadline (0..1).\n        pmax (array-like of length D): Per-slot charger maximum power in kW.\n        pgrid (array-like of length D): Per-slot grid upper bound in kW.\n        availability (array-like of length D): Per-slot availability (0 or 1).\n    Returns:\n        bool: True if feasible, False otherwise.\n    \"\"\"\n    # Handle the zero-slot boundary case directly.\n    if D == 0:\n        return (soc0 >= soc_target) and (soc0 >= soc_min)\n\n    alpha = eta * dt / E_cap\n\n    # Compute per-slot upper bounds considering availability and both limits.\n    pmax = np.array(pmax, dtype=float)\n    pgrid = np.array(pgrid, dtype=float)\n    availability = np.array(availability, dtype=float)\n\n    if pmax.shape[0] != D or pgrid.shape[0] != D or availability.shape[0] != D:\n        # Dimension mismatch: treat as infeasible for safety.\n        return False\n\n    ub = availability * np.minimum(pmax, pgrid)\n    bounds = [(0.0, float(ub_t)) for ub_t in ub]\n\n    # Build A_ub and b_ub for target and minimum SOC constraints.\n    # Target constraint: -alpha * sum(p_t) = -(soc_target - soc0)\n    A_rows = []\n    b_vals = []\n\n    A_target = -alpha * np.ones(D)\n    b_target = -(soc_target - soc0)\n    A_rows.append(A_target)\n    b_vals.append(b_target)\n\n    # Minimum SOC constraints for each intermediate time t = 1..D:\n    # -alpha * sum_{k=0..t-1}(p_k) = -(soc_min - soc0)\n    for t in range(1, D + 1):\n        row = np.zeros(D)\n        row[:t] = -alpha\n        A_rows.append(row)\n        b_vals.append(-(soc_min - soc0))\n\n    A_ub = np.vstack(A_rows)\n    b_ub = np.array(b_vals)\n\n    # Objective is zero vector (feasibility problem).\n    c = np.zeros(D)\n\n    # Solve the LP using HiGHS.\n    res = linprog(c=c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    # Feasible if solver succeeded.\n    return bool(res.success)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Happy path feasibility with continuous availability.\n        {\n            \"E_cap\": 60.0, \"dt\": 0.25, \"D\": 16, \"eta\": 0.92,\n            \"soc0\": 0.5, \"soc_min\": 0.2, \"soc_target\": 0.8,\n            \"pmax\": [7.0]*16, \"pgrid\": [10.0]*16, \"availability\": [1]*16\n        },\n        # 2. Infeasible due to insufficient availability and low power.\n        {\n            \"E_cap\": 60.0, \"dt\": 1.0, \"D\": 1, \"eta\": 0.92,\n            \"soc0\": 0.7, \"soc_min\": 0.2, \"soc_target\": 0.9,\n            \"pmax\": [3.6], \"pgrid\": [3.6], \"availability\": [1]\n        },\n        # 3. Boundary case with immediate deadline (D=0).\n        {\n            \"E_cap\": 50.0, \"dt\": 0.25, \"D\": 0, \"eta\": 0.90,\n            \"soc0\": 0.7, \"soc_min\": 0.6, \"soc_target\": 0.7,\n            \"pmax\": [], \"pgrid\": [], \"availability\": []\n        },\n        # 4. Exact-feasibility boundary with intermittent availability and varying power limits.\n        {\n            \"E_cap\": 50.0, \"dt\": 0.25, \"D\": 5, \"eta\": 0.80,\n            \"soc0\": 0.6, \"soc_min\": 0.2, \"soc_target\": 0.8,\n            \"pmax\": [20.0, 20.0, 15.0, 20.0, 15.0],\n            \"pgrid\": [25.0, 25.0, 25.0, 25.0, 25.0],\n            \"availability\": [1, 0, 1, 0, 1]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = check_feasibility(\n            case[\"E_cap\"], case[\"dt\"], case[\"D\"], case[\"eta\"],\n            case[\"soc0\"], case[\"soc_min\"], case[\"soc_target\"],\n            case[\"pmax\"], case[\"pgrid\"], case[\"availability\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}