{
    "hands_on_practices": [
        {
            "introduction": "Understanding electric vehicle charging demand begins with a solid foundation in vehicle dynamics and energy consumption. This practice grounds your understanding in first principles, tasking you with modeling the tractive energy required for an EV to complete a specific driving cycle. By applying Newton's second law and standard models for rolling resistance and aerodynamic drag, you will develop a powerful tool for predicting energy use, a critical first step in sizing batteries and planning charging infrastructure .",
            "id": "4087464",
            "problem": "An electric vehicle operates over a specified driving cycle characterized by a speed profile as a function of time. The objective is to compute the electric vehicle charging demand required to restore the battery to its initial state-of-charge after completing the cycle. The computation must be grounded in fundamentals of mechanics and established vehicle modeling practice.\n\nStarting from first principles, use the following modeling bases:\n- Newton’s second law: the net longitudinal force equals mass times longitudinal acceleration. Denote mass by $m$ in $\\mathrm{kg}$, speed by $v(t)$ in $\\mathrm{m/s}$, and acceleration by $a(t)$ in $\\mathrm{m/s^2}$.\n- Rolling resistance model: the rolling resistance force is proportional to the normal force with coefficient $c_r$ (dimensionless), such that the rolling resistance force magnitude is $c_r \\, m \\, g$, where $g$ is the gravitational acceleration in $\\mathrm{m/s^2}$.\n- Aerodynamic drag model: the aerodynamic drag force magnitude is proportional to the squared speed and the dynamic pressure. Using air density $\\rho$ in $\\mathrm{kg/m^3}$, frontal area $A$ in $\\mathrm{m^2}$, and drag coefficient $C_d$ (dimensionless), the drag force magnitude depends on $\\tfrac{1}{2}\\,\\rho\\,A\\,C_d\\,v(t)^2$.\n- Mechanical power at the wheels equals the longitudinal tractive force times speed. Adopt the sign convention that positive mechanical power represents energy drawn from the battery to the wheels, while negative mechanical power represents energy returned from the wheels to the battery through regenerative braking if present.\n\nElectrical energy conversion assumptions:\n- Drivetrain efficiency $\\eta_d$ (dimensionless) maps mechanical power at the wheels to electrical power drawn from the battery when mechanical power is positive.\n- Regenerative braking efficiency $\\eta_{\\text{reg}}$ (dimensionless) maps negative mechanical power at the wheels to electrical power recovered into the battery when mechanical power is negative. Assume full regenerative capture of negative mechanical power limited only by the efficiency $\\eta_{\\text{reg}}$.\n- Charging efficiency $\\eta_{\\text{ch}}$ (dimensionless) maps grid energy to battery energy during charging.\n\nCompute the net battery energy change over the cycle by integrating mechanical power over time and converting to electrical energy using the efficiencies above. If the net battery energy change is negative (i.e., net energy gain due to regeneration), set the required grid energy to recharge to the initial state-of-charge to zero. Otherwise, compute the grid energy as the battery energy change divided by the charging efficiency. Express all energy results in kilowatt-hour ($\\mathrm{kWh}$), rounded to six decimal places.\n\nTime discretization requirements:\n- For each test case, construct $v(t)$ on a uniform grid with time step $\\Delta t = 1$ s across the specified horizon $[0, T]$.\n- Compute $a(t)$ via finite differences consistent with the uniform grid.\n- Integrate over time using a numerically consistent method (for example, the trapezoidal rule or a Riemann sum).\n\nProvide a program that, for the following test suite, computes the required grid energy to recharge the battery to its initial state-of-charge after the cycle. Use the specified physical parameters for each test case. All speeds are in $\\mathrm{m/s}$, times in $\\mathrm{s}$, and energies in $\\mathrm{kWh}$. The gravitational acceleration is $g=9.81 \\mathrm{m/s^2}$ in all cases.\n\nTest Suite:\n- Case 1 (baseline urban profile):\n  - Parameters: $m=1600$ kg, $c_r=0.012$, $\\rho=1.225$ kg/m$^3$, $A=2.2$ m$^2$, $C_d=0.29$, $\\eta_d=0.92$, $\\eta_{\\text{reg}}=0.65$, $\\eta_{\\text{ch}}=0.90$.\n  - Horizon: $T=600$ s, $\\Delta t=1$ s.\n  - Speed profile $v(t)$:\n    - For $t \\in [0, 30]$: linearly accelerate from 0 to 15 $\\mathrm{m/s}$.\n    - For $t \\in [30, 150]$: cruise at 15 $\\mathrm{m/s}$.\n    - For $t \\in [150, 170]$: linearly decelerate from 15 to 0 $\\mathrm{m/s}$.\n    - For $t \\in [170, 230]$: dwell at 0 $\\mathrm{m/s}$.\n    - For $t \\in [230, 260]$: linearly accelerate from 0 to 12 $\\mathrm{m/s}$.\n    - For $t \\in [260, 380]$: cruise at 12 $\\mathrm{m/s}$.\n    - For $t \\in [380, 420]$: linearly decelerate from 12 to 0 $\\mathrm{m/s}$.\n    - For $t \\in [420, 600]$: dwell at 0 $\\mathrm{m/s}$.\n- Case 2 (stationary edge case):\n  - Parameters: same as Case 1.\n  - Horizon: $T=300$ s, $\\Delta t=1$ s.\n  - Speed profile $v(t)$: identically 0 for all $t \\in [0, 300]$.\n- Case 3 (high-speed acceleration and regenerative braking):\n  - Parameters: $m=1600$ kg, $c_r=0.012$, $\\rho=1.225$ kg/m$^3$, $A=2.2$ m$^2$, $C_d=0.29$, $\\eta_d=0.92$, $\\eta_{\\text{reg}}=0.75$, $\\eta_{\\text{ch}}=0.90$.\n  - Horizon: $T=120$ s, $\\Delta t=1$ s.\n  - Speed profile $v(t)$:\n    - For $t \\in [0, 30]$: linearly accelerate from 0 to 30 $\\mathrm{m/s}$.\n    - For $t \\in [30, 60]$: cruise at 30 $\\mathrm{m/s}$.\n    - For $t \\in [60, 80]$: linearly decelerate from 30 to 0 $\\mathrm{m/s}$.\n    - For $t \\in [80, 120]$: dwell at 0 $\\mathrm{m/s}$.\n- Case 4 (aerodynamic regime, sustained cruising):\n  - Parameters: $m=1600$ kg, $c_r=0.012$, $\\rho=1.225$ kg/m$^3$, $A=2.6$ m$^2$, $C_d=0.32$, $\\eta_d=0.92$, $\\eta_{\\text{reg}}=0.65$, $\\eta_{\\text{ch}}=0.90$.\n  - Horizon: $T=600$ s, $\\Delta t=1$ s.\n  - Speed profile $v(t)$: constant cruising at 33.33 $\\mathrm{m/s}$ for all $t \\in [0, 600]$.\n\nRequired output:\n- For each case, compute the grid energy required to recharge the battery to its initial state-of-charge after the cycle, in $\\mathrm{kWh}$, rounded to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3,result4]$), with each result rounded to six decimal places and expressed in $\\mathrm{kWh}$.",
            "solution": "The problem is well-posed, scientifically grounded, and contains all necessary information to proceed with a solution.\n\n### 1. Governing Principles and Force-Power Formulation\n\nThe analysis begins from first principles of classical mechanics. The motion of the electric vehicle is governed by Newton's second law applied in the longitudinal direction. The net force on the vehicle is the sum of the tractive force from the powertrain and various resistive forces. For a vehicle of mass $m$ moving on a level surface with longitudinal acceleration $a(t)$, the required tractive force at the wheels, $F_{\\text{tractive}}(t)$, is given by:\n\n$$\nF_{\\text{tractive}}(t) = m \\, a(t) + F_{\\text{res}}(t)\n$$\n\nwhere $F_{\\text{res}}(t)$ is the total resistive force. The problem specifies two primary sources of resistance: rolling resistance and aerodynamic drag.\n\nThe rolling resistance force, $F_{rr}$, is modeled as proportional to the normal force on the vehicle. For a level surface, this is:\n$$\nF_{rr} = c_r \\, m \\, g\n$$\nwhere $c_r$ is the dimensionless coefficient of rolling resistance and $g$ is the acceleration due to gravity. This force is assumed to be constant whenever the vehicle is in motion and acts to oppose the direction of velocity.\n\nThe aerodynamic drag force, $F_{ad}(t)$, is proportional to the dynamic pressure of the air and the vehicle's frontal area. Its magnitude is given by:\n$$\nF_{ad}(t) = \\frac{1}{2} \\, \\rho \\, A \\, C_d \\, v(t)^2\n$$\nwhere $\\rho$ is the air density, $A$ is the frontal area, $C_d$ is the dimensionless drag coefficient, and $v(t)$ is the vehicle's speed. This force also opposes the direction of velocity.\n\nCombining these components, the total tractive force required to follow the specified speed profile is:\n$$\nF_{\\text{tractive}}(t) = m \\, a(t) + c_r \\, m \\, g + \\frac{1}{2} \\, \\rho \\, A \\, C_d \\, v(t)^2\n$$\nThe sign convention is such that $F_{\\text{tractive}}(t)$ is positive for motoring and negative for braking.\n\nThe mechanical power at the wheels, $P_{\\text{mech}}(t)$, is the product of the tractive force and the vehicle's speed:\n$$\nP_{\\text{mech}}(t) = F_{\\text{tractive}}(t) \\cdot v(t)\n$$\nA positive $P_{\\text{mech}}(t)$ indicates power is expended to propel the vehicle (motoring), while a negative $P_{\\text{mech}}(t)$ signifies that power is being delivered to the wheels from the vehicle's kinetic energy (braking), which can be partially recovered.\n\n### 2. Electrical Power and Energy Consumption\n\nThe mechanical power at the wheels is supplied by or delivered to the vehicle's battery through the electric drivetrain. The conversion between mechanical and electrical power is subject to efficiencies.\n\nThe electrical power drawn from or supplied to the battery, $P_{\\text{elec}}(t)$, is determined as follows:\n- When motoring ($P_{\\text{mech}}(t) > 0$), power is drawn from the battery, and the conversion is governed by the drivetrain efficiency $\\eta_d$:\n  $$\n  P_{\\text{elec}}(t) = \\frac{P_{\\text{mech}}(t)}{\\eta_d}\n  $$\n- When braking ($P_{\\text{mech}}(t)  0$), power is returned to the battery via regenerative braking, governed by the regenerative efficiency $\\eta_{\\text{reg}}$:\n  $$\n  P_{\\text{elec}}(t) = P_{\\text{mech}}(t) \\cdot \\eta_{\\text{reg}}\n  $$\n- When $P_{\\text{mech}}(t) = 0$, no power is exchanged, so $P_{\\text{elec}}(t) = 0$.\n\nThe net change in the battery's stored energy over the driving cycle of duration $T$ is the time integral of the electrical power:\n$$\n\\Delta E_{\\text{batt}} = \\int_{0}^{T} P_{\\text{elec}}(t) \\, dt\n$$\nA positive $\\Delta E_{\\text{batt}}$ represents a net discharge of the battery.\n\n### 3. Numerical Discretization and Algorithm\n\nTo compute the solution, we discretize the problem over a uniform time grid. The time horizon $[0, T]$ is divided into $N$ intervals of duration $\\Delta t = 1 \\, \\mathrm{s}$, yielding time points $t_i = i \\cdot \\Delta t$ for $i = 0, 1, \\dots, N$.\n\nThe algorithm proceeds as follows:\n1.  **Construct Time and Velocity Vectors**: A time vector $\\mathbf{t} = [t_0, t_1, \\dots, t_N]$ is created. The corresponding velocity vector $\\mathbf{v} = [v_0, v_1, \\dots, v_N]$ is constructed by sampling the given piecewise speed profile at each time point $t_i$.\n2.  **Compute Acceleration Vector**: The acceleration vector $\\mathbf{a} = [a_0, a_1, \\dots, a_N]$ is computed using a finite difference approximation on the velocity vector $\\mathbf{v}$. A standard approach, such as `numpy.gradient`, which uses central differences for interior points and second-order accurate one-sided differences at the boundaries, is suitable and consistent. Given $\\Delta t=1 \\, \\mathrm{s}$, this is applied directly to the velocity vector.\n3.  **Calculate Instantaneous Forces and Powers**: For each time index $i$:\n    a. Tractive Force: $F_{\\text{tractive}, i} = m \\, a_i + c_r \\, m \\, g + \\frac{1}{2} \\, \\rho \\, A \\, C_d \\, v_i^2$.\n    b. Mechanical Power: $P_{\\text{mech}, i} = F_{\\text{tractive}, i} \\cdot v_i$.\n    c. Electrical Power: $P_{\\text{elec}, i}$ is calculated based on the sign of $P_{\\text{mech}, i}$ and the corresponding efficiencies $\\eta_d$ or $\\eta_{\\text{reg}}$.\n4.  **Integrate Electrical Power**: The net battery energy change, $\\Delta E_{\\text{batt}}$, is calculated by numerically integrating the electrical power vector $\\mathbf{P}_{\\text{elec}}$ with respect to time. The trapezoidal rule is a suitable and numerically consistent method:\n    $$\n    \\Delta E_{\\text{batt}} \\approx \\sum_{i=1}^{N} \\frac{P_{\\text{elec}, i} + P_{\\text{elec}, i-1}}{2} \\Delta t\n    $$\n    This is performed on the computed power values, yielding a result in Joules.\n\n### 4. Grid Energy Calculation\n\nThe final objective is to find the energy required from the grid, $E_{\\text{grid}}$, to restore the battery to its initial state.\n1.  **Unit Conversion**: The calculated $\\Delta E_{\\text{batt}}$ in Joules is converted to kilowatt-hours (kWh) using the conversion factor $1 \\, \\mathrm{kWh} = 3.6 \\times 10^6 \\, \\mathrm{J}$.\n    $$\n    \\Delta E_{\\text{batt}} [\\mathrm{kWh}] = \\frac{\\Delta E_{\\text{batt}} [\\mathrm{J}]}{3.6 \\times 10^6}\n    $$\n2.  **Charging Logic**:\n    - If $\\Delta E_{\\text{batt}} \\le 0$, the vehicle has experienced a net energy gain over the cycle (due to significant regenerative braking). No charging is required. Thus, $E_{\\text{grid}} = 0$.\n    - If $\\Delta E_{\\text{batt}} > 0$, the battery has been discharged. The energy required from the grid must account for the charging efficiency $\\eta_{\\text{ch}}$.\n      $$\n      E_{\\text{grid}} = \\frac{\\Delta E_{\\text{batt}} [\\mathrm{kWh}]}{\\eta_{\\text{ch}}}\n      $$\n3.  **Final Result**: The computed value of $E_{\\text{grid}}$ is rounded to six decimal places as required. This process is repeated for each test case provided.",
            "answer": "```python\nimport numpy as np\n\ndef calculate_grid_energy(params, cycle_def):\n    \"\"\"\n    Computes the grid energy required to recharge an EV battery after a driving cycle.\n    \n    Args:\n        params (dict): Dictionary of vehicle and efficiency parameters.\n        cycle_def (dict): Dictionary defining the driving cycle horizon and speed profile.\n\n    Returns:\n        float: Grid energy in kWh, rounded to 6 decimal places.\n    \"\"\"\n    # Unpack parameters\n    m = params['m']\n    c_r = params['c_r']\n    rho = params['rho']\n    A = params['A']\n    C_d = params['C_d']\n    eta_d = params['eta_d']\n    eta_reg = params['eta_reg']\n    eta_ch = params['eta_ch']\n    g = 9.81\n\n    # Unpack cycle definition\n    T = cycle_def['T']\n    dt = cycle_def['dt']\n    speed_profile = cycle_def['speed_profile']\n\n    # 1. Construct Time and Velocity Vectors\n    time = np.arange(0, T + dt, dt)\n    v = np.zeros_like(time, dtype=float)\n\n    for segment in speed_profile:\n        t_start, t_end = segment[0], segment[1]\n        v_start, v_end = segment[2], segment[3]\n        \n        # Find indices corresponding to the time segment\n        start_idx = int(t_start / dt)\n        end_idx = int(t_end / dt)\n        num_points = end_idx - start_idx + 1\n\n        if v_start == v_end: # Constant speed (cruise or dwell)\n            v[start_idx : end_idx + 1] = v_start\n        else: # Linear acceleration/deceleration\n            v[start_idx : end_idx + 1] = np.linspace(v_start, v_end, num_points)\n\n    # 2. Compute Acceleration Vector\n    a = np.gradient(v, dt)\n\n    # 3. Calculate Instantaneous Forces and Powers\n    F_rr = c_r * m * g\n    F_ad = 0.5 * rho * A * C_d * v**2\n    F_tractive = m * a + F_rr + F_ad\n\n    P_mech = F_tractive * v\n    \n    # Use np.where for conditional power calculation\n    P_elec = np.where(P_mech > 0, P_mech / eta_d, P_mech * eta_reg)\n\n    # 4. Integrate Electrical Power (Trapezoidal Rule)\n    delta_E_batt_J = np.trapz(P_elec, time)\n\n    # 5. Grid Energy Calculation\n    # Convert Joules to kWh\n    delta_E_batt_kWh = delta_E_batt_J / 3.6e6\n\n    if delta_E_batt_kWh = 0:\n        E_grid = 0.0\n    else:\n        E_grid = delta_E_batt_kWh / eta_ch\n\n    return round(E_grid, 6)\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the results for the problem.\n    \"\"\"\n    g = 9.81  # m/s^2\n\n    test_cases = [\n        {\n            \"params\": {\n                'm': 1600, 'c_r': 0.012, 'rho': 1.225, 'A': 2.2, 'C_d': 0.29,\n                'eta_d': 0.92, 'eta_reg': 0.65, 'eta_ch': 0.90\n            },\n            \"cycle_def\": {\n                'T': 600, 'dt': 1,\n                'speed_profile': [\n                    (0, 30, 0, 15), (30, 150, 15, 15), (150, 170, 15, 0),\n                    (170, 230, 0, 0), (230, 260, 0, 12), (260, 380, 12, 12),\n                    (380, 420, 12, 0), (420, 600, 0, 0)\n                ]\n            }\n        },\n        {\n            \"params\": {\n                'm': 1600, 'c_r': 0.012, 'rho': 1.225, 'A': 2.2, 'C_d': 0.29,\n                'eta_d': 0.92, 'eta_reg': 0.65, 'eta_ch': 0.90\n            },\n            \"cycle_def\": {\n                'T': 300, 'dt': 1,\n                'speed_profile': [(0, 300, 0, 0)]\n            }\n        },\n        {\n            \"params\": {\n                'm': 1600, 'c_r': 0.012, 'rho': 1.225, 'A': 2.2, 'C_d': 0.29,\n                'eta_d': 0.92, 'eta_reg': 0.75, 'eta_ch': 0.90\n            },\n            \"cycle_def\": {\n                'T': 120, 'dt': 1,\n                'speed_profile': [\n                    (0, 30, 0, 30), (30, 60, 30, 30), (60, 80, 30, 0),\n                    (80, 120, 0, 0)\n                ]\n            }\n        },\n        {\n            \"params\": {\n                'm': 1600, 'c_r': 0.012, 'rho': 1.225, 'A': 2.6, 'C_d': 0.32,\n                'eta_d': 0.92, 'eta_reg': 0.65, 'eta_ch': 0.90\n            },\n            \"cycle_def\": {\n                'T': 600, 'dt': 1,\n                'speed_profile': [(0, 600, 33.33, 33.33)]\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_grid_energy(case[\"params\"], case[\"cycle_def\"])\n        results.append(f\"{result:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Replenishing an EV's battery is not a simple constant-power process, especially during DC fast charging. This exercise delves into the standard Constant Current-Constant Voltage (CC-CV) charging protocol, guiding you to derive the characteristic tapering of current and power as the battery's state of charge increases. By working through the analytics of a battery's equivalent circuit model, you will gain crucial insights into the physical limitations and dynamics that govern the charging process .",
            "id": "4087498",
            "problem": "Consider an Electric Vehicle (EV) battery pack undergoing Direct Current (DC) fast charging under a two-stage control policy: a Constant Current (CC) stage followed by a Constant Voltage (CV) stage. Let the State of Charge (SOC) be denoted by the dimensionless variable $s \\in [0,1]$. Model the pack by a quasi-static equivalent circuit with an SOC-dependent open-circuit voltage (OCV) $v_{\\mathrm{oc}}(s)$ and an SOC-dependent effective internal resistance $r(s)$ that aggregates the contribution of individual cell internal resistances and interconnects. Assume the terminal pack voltage $v(s)$ under charge current $i(s)$ satisfies the constitutive relation\n$$\nv(s) = v_{\\mathrm{oc}}(s) + i(s)\\, r(s),\n$$\nwhere $v_{\\mathrm{oc}}(s)$ and $r(s)$ are smooth functions of $s$ and $r(s)  0$ for all $s \\in [0,1]$. The CC stage applies a constant current $I_{\\mathrm{cc}}  0$ until the terminal voltage reaches a prescribed CV clamp $V_{\\mathrm{cv}}  0$, at which point the charging transitions to the CV stage where $v(s)$ is held at $V_{\\mathrm{cv}}$ and the current tapers as $s$ increases.\n\nTo make the tapering analytically tractable while remaining physically plausible, posit the parametric forms\n$$\nv_{\\mathrm{oc}}(s) = v_{\\min} + k\\, s, \\quad k  0, \\quad v_{\\min}  0,\n$$\n$$\nr(s) = r_0 \\left(1 - \\gamma s\\right), \\quad r_0  0, \\quad 0  \\gamma  1,\n$$\nwhich capture an OCV that increases with SOC and an effective resistance that decreases moderately with SOC. Let the $CC \\to CV$ transition occur at the SOC $s^{\\dagger} \\in (0,1)$ where the CC-stage terminal voltage equals the CV clamp, and assume parameters satisfy $k - I_{\\mathrm{cc}} r_0 \\gamma > 0$ and $v_{\\min} + I_{\\mathrm{cc}} r_0  V_{\\mathrm{cv}}  v_{\\min} + k + I_{\\mathrm{cc}} r_0 (1 - \\gamma)$ to ensure a unique, physically meaningful transition within the SOC range.\n\nStarting from the equivalent-circuit relation $v(s) = v_{\\mathrm{oc}}(s) + i(s)\\, r(s)$, the CC/CV control definitions, and the definition of instantaneous charging power $P(s) = v(s)\\, i(s)$, derive the SOC-dependent tapering functions for the charging current $I(s)$ and power $P(s)$ over $s \\in [0,1]$, expressed piecewise across the CC and CV stages and explicitly parameterized by $v_{\\min}$, $k$, $r_0$, $\\gamma$, $I_{\\mathrm{cc}}$, and $V_{\\mathrm{cv}}$. Also derive the explicit expression for $s^{\\dagger}$ in terms of these parameters by enforcing the $CC \\to CV$ transition condition. Express your final answer as closed-form analytic expressions for $I(s)$, $P(s)$, and $s^{\\dagger}$. No numerical evaluation is required. Do not include units in your final answer. If you use inequalities to state conditions, do not include them in the final answer.",
            "solution": "### Problem Validation\n\n#### Step 1: Extract Givens\nThe problem provides the following data, definitions, and conditions:\n-   **State of Charge (SOC):** A dimensionless variable $s \\in [0,1]$.\n-   **Equivalent Circuit Model:** The terminal voltage $v(s)$ is related to the open-circuit voltage $v_{\\mathrm{oc}}(s)$ and internal resistance $r(s)$ by the constitutive relation $v(s) = v_{\\mathrm{oc}}(s) + i(s)\\, r(s)$, where $i(s)$ is the charging current.\n-   **Parametric Form for OCV:** $v_{\\mathrm{oc}}(s) = v_{\\min} + k\\, s$, with constants $k  0$ and $v_{\\min}  0$.\n-   **Parametric Form for Resistance:** $r(s) = r_0 \\left(1 - \\gamma s\\right)$, with constants $r_0  0$ and $0  \\gamma  1$.\n-   **CC-CV Charging Policy:**\n    -   **Constant Current (CC) Stage:** A constant current $I_{\\mathrm{cc}}  0$ is applied.\n    -   **Constant Voltage (CV) Stage:** The terminal voltage is held at a constant clamp voltage $V_{\\mathrm{cv}}  0$.\n-   **Transition Condition:** The switch from CC to CV stage occurs at an SOC denoted by $s^{\\dagger} \\in (0,1)$, where the terminal voltage during the CC stage reaches $V_{\\mathrm{cv}}$.\n-   **Parameter Constraints:** The problem specifies that the parameters satisfy $k - I_{\\mathrm{cc}} r_0 \\gamma  0$ and $v_{\\min} + I_{\\mathrm{cc}} r_0  V_{\\mathrm{cv}}  v_{\\min} + k + I_{\\mathrm{cc}} r_0 (1 - \\gamma)$ to ensure a unique, physically meaningful transition.\n-   **Power Definition:** The instantaneous charging power is $P(s) = v(s)\\, i(s)$.\n\n#### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria:\n-   **Scientifically Grounded:** The problem is based on a standard first-order Thévenin equivalent circuit model for a battery and the industry-standard Constant Current-Constant Voltage (CC-CV) charging protocol. The linear parameterizations for OCV and internal resistance are common and valid simplifications for analytical modeling within a specific operational range. The model is scientifically sound and relevant to the field of energy systems.\n-   **Well-Posed:** The problem statement is mathematically precise. It provides all necessary equations and parametric forms to derive the requested quantities ($s^{\\dagger}$, $I(s)$, $P(s)$). The explicit constraints on the parameters are designed to guarantee that the CC-to-CV transition occurs at a unique SOC, $s^{\\dagger}$, within the valid range $(0,1)$, thus ensuring a well-posed problem with a unique solution.\n-   **Objective:** The problem is formulated in objective, quantitative language, free of any subjective or ambiguous terminology.\n\nThe problem does not exhibit any of the listed flaws (e.g., scientific unsoundness, incompleteness, contradiction, infeasibility, or ambiguity).\n\n#### Step 3: Verdict and Action\nThe problem is **valid**. A complete, reasoned solution will be provided.\n\n### Solution Derivation\n\nThe derivation proceeds by analyzing the two stages of the charging process separately and then combining the results. The key is to derive the terminal voltage $v(s)$ during the CC stage, find the transition SOC $s^{\\dagger}$ where $v(s^{\\dagger}) = V_{\\mathrm{cv}}$, and then determine the tapering current and power for the CV stage.\n\n**1. Constant Current (CC) Stage: $s \\in [0, s^{\\dagger}]$**\n\nIn this stage, the charging current is constant by definition:\n$$I(s) = I_{\\mathrm{cc}}$$\nThe terminal voltage $v(s)$ is found by substituting the given parametric forms for $v_{\\mathrm{oc}}(s)$, $r(s)$, and $I(s)$ into the constitutive relation:\n$$v(s) = v_{\\mathrm{oc}}(s) + I(s) r(s)$$\n$$v(s) = (v_{\\min} + k s) + I_{\\mathrm{cc}} \\left( r_0 (1 - \\gamma s) \\right)$$\n$$v(s) = v_{\\min} + I_{\\mathrm{cc}} r_0 + (k - I_{\\mathrm{cc}} r_0 \\gamma) s$$\nThe instantaneous power $P(s)$ during the CC stage is the product of the terminal voltage and the constant current:\n$$P(s) = v(s) I(s) = \\left( v_{\\min} + I_{\\mathrm{cc}} r_0 + (k - I_{\\mathrm{cc}} r_0 \\gamma) s \\right) I_{\\mathrm{cc}}$$\nThis simplifies to:\n$$P(s) = I_{\\mathrm{cc}} (v_{\\min} + I_{\\mathrm{cc}} r_0) + I_{\\mathrm{cc}}(k - I_{\\mathrm{cc}} r_0 \\gamma) s$$\n\n**2. CC-to-CV Transition SOC: $s^{\\dagger}$**\n\nThe transition from the CC stage to the CV stage occurs at the SOC $s^{\\dagger}$ where the terminal voltage $v(s)$ from the CC stage first reaches the clamp voltage $V_{\\mathrm{cv}}$. We set $v(s^{\\dagger}) = V_{\\mathrm{cv}}$:\n$$V_{\\mathrm{cv}} = v_{\\min} + I_{\\mathrm{cc}} r_0 + (k - I_{\\mathrm{cc}} r_0 \\gamma) s^{\\dagger}$$\nSolving for $s^{\\dagger}$ yields:\n$$(k - I_{\\mathrm{cc}} r_0 \\gamma) s^{\\dagger} = V_{\\mathrm{cv}} - v_{\\min} - I_{\\mathrm{cc}} r_0$$\n$$s^{\\dagger} = \\frac{V_{\\mathrm{cv}} - v_{\\min} - I_{\\mathrm{cc}} r_0}{k - I_{\\mathrm{cc}} r_0 \\gamma}$$\nThe problem-stated constraint $k - I_{\\mathrm{cc}} r_0 \\gamma > 0$ ensures the denominator is positive and non-zero. The constraint $v_{\\min} + I_{\\mathrm{cc}} r_0  V_{\\mathrm{cv}}$ ensures the numerator is positive, so $s^{\\dagger} > 0$. The constraint $V_{\\mathrm{cv}}  v_{\\min} + k + I_{\\mathrm{cc}} r_0 (1 - \\gamma)$ implies $V_{\\mathrm{cv}} - v_{\\min} - I_{\\mathrm{cc}} r_0  k - I_{\\mathrm{cc}} r_0 \\gamma$, which ensures $s^{\\dagger}  1$. Thus, the derived $s^{\\dagger}$ is guaranteed to be in the physically meaningful range $(0,1)$.\n\n**3. Constant Voltage (CV) Stage: $s \\in (s^{\\dagger}, 1]$**\n\nIn this stage, the terminal voltage is held constant by definition:\n$$v(s) = V_{\\mathrm{cv}}$$\nThe charging current $I(s)$ is no longer constant but tapers off. We find its expression by rearranging the constitutive relation:\n$$V_{\\mathrm{cv}} = v_{\\mathrm{oc}}(s) + I(s) r(s) \\implies I(s) = \\frac{V_{\\mathrm{cv}} - v_{\\mathrm{oc}}(s)}{r(s)}$$\nSubstituting the parametric forms for $v_{\\mathrm{oc}}(s)$ and $r(s)$:\n$$I(s) = \\frac{V_{\\mathrm{cv}} - (v_{\\min} + k s)}{r_0 (1 - \\gamma s)} = \\frac{V_{\\mathrm{cv}} - v_{\\min} - k s}{r_0 (1 - \\gamma s)}$$\nThe instantaneous power $P(s)$ during the CV stage is the product of the constant terminal voltage and the tapering current:\n$$P(s) = v(s) I(s) = V_{\\mathrm{cv}} \\left( \\frac{V_{\\mathrm{cv}} - v_{\\min} - k s}{r_0 (1 - \\gamma s)} \\right)$$\n\n**4. Final Piecewise Expressions**\n\nCombining the results from the CC and CV stages, we obtain the complete piecewise expressions for the charging current $I(s)$ and power $P(s)$ over the entire SOC range $s \\in [0,1]$.\n\n**Current $I(s)$:**\n$$ I(s) = \\begin{cases} I_{\\mathrm{cc}}  \\text{for } 0 \\le s \\le s^{\\dagger} \\\\ \\frac{V_{\\mathrm{cv}} - v_{\\min} - k s}{r_0 (1 - \\gamma s)}  \\text{for } s^{\\dagger}  s \\le 1 \\end{cases} $$\n\n**Power $P(s)$:**\n$$ P(s) = \\begin{cases} I_{\\mathrm{cc}} \\left( v_{\\min} + I_{\\mathrm{cc}} r_0 + (k - I_{\\mathrm{cc}} r_0 \\gamma) s \\right)  \\text{for } 0 \\le s \\le s^{\\dagger} \\\\ V_{\\mathrm{cv}} \\left( \\frac{V_{\\mathrm{cv}} - v_{\\min} - k s}{r_0 (1 - \\gamma s)} \\right)  \\text{for } s^{\\dagger}  s \\le 1 \\end{cases} $$\n\nThese expressions, along with the derived formula for $s^{\\dagger}$, constitute the complete solution to the problem.",
            "answer": "$$\n\\boxed{\n\\pmatrix{\ns^{\\dagger} = \\frac{V_{\\mathrm{cv}} - v_{\\min} - I_{\\mathrm{cc}} r_0}{k - I_{\\mathrm{cc}} r_0 \\gamma}\n\nI(s) =\n\\begin{cases}\nI_{\\mathrm{cc}}  0 \\le s \\le s^{\\dagger} \\\\\n\\frac{V_{\\mathrm{cv}} - v_{\\min} - k s}{r_0 (1 - \\gamma s)}  s^{\\dagger}  s \\le 1\n\\end{cases}\n\nP(s) =\n\\begin{cases}\nI_{\\mathrm{cc}} ( v_{\\min} + I_{\\mathrm{cc}} r_0 + (k - I_{\\mathrm{cc}} r_0 \\gamma) s )  0 \\le s \\le s^{\\dagger} \\\\\nV_{\\mathrm{cv}} \\frac{V_{\\mathrm{cv}} - v_{\\min} - k s}{r_0 (1 - \\gamma s)}  s^{\\dagger}  s \\le 1\n\\end{cases}\n}\n}\n$$"
        },
        {
            "introduction": "With a physical understanding of energy consumption and charging dynamics, the next step is to manage the charging process over time. This practice introduces you to optimization by framing charging as a feasibility problem that can be solved using Linear Programming (LP). You will learn to translate physical constraints—such as charger power limits, grid capacity, and driver-defined targets—into a mathematical model, a fundamental skill for developing smart charging algorithms and assessing their viability .",
            "id": "4087499",
            "problem": "Consider a single electric vehicle charging problem over a discretized time horizon. Let the time horizon be partitioned into $D$ slots indexed by $t \\in \\{0,1,\\dots,D-1\\}$, each of duration $\\Delta t$ in hours. Let the electric vehicle battery have energy capacity $E_{\\mathrm{cap}}$ in kilowatt-hours (kWh), initial state of charge $\\mathrm{SOC}_0 \\in [0,1]$, and a charging efficiency $\\eta \\in (0,1]$ that linearly maps electrical energy delivered at the plug to energy stored in the battery. The decision variables are the charging powers $\\{p_t\\}_{t=0}^{D-1}$ in kilowatts (kW), subject to linear constraints capturing physical and operational limits.\n\nFundamental base and model:\n- By conservation of energy, the energy stored in the battery increases with delivered power according to\n$$\\Delta E_t = \\eta\\, p_t\\, \\Delta t,$$\nwhere $\\Delta E_t$ is the battery energy increment during slot $t$ and $p_t$ is the plug power during slot $t$.\n- The state of charge evolves as\n$$\\mathrm{SOC}_{t+1} = \\mathrm{SOC}_t + \\dfrac{\\Delta E_t}{E_{\\mathrm{cap}}} = \\mathrm{SOC}_t + \\dfrac{\\eta\\, p_t\\, \\Delta t}{E_{\\mathrm{cap}}}.$$\n- Define $\\alpha = \\dfrac{\\eta\\, \\Delta t}{E_{\\mathrm{cap}}}$. Then\n$$\\mathrm{SOC}_D = \\mathrm{SOC}_0 + \\alpha \\sum_{t=0}^{D-1} p_t.$$\n\nConstraints:\n- Power nonnegativity: $p_t \\ge 0$ for all $t$.\n- Availability window and power limits: let $a_t \\in \\{0,1\\}$ denote availability (vehicle is connected during slot $t$ if $a_t=1$, otherwise $a_t=0$), let $P^{\\max}_t$ be the charger maximum in kilowatts during slot $t$, and let $P^{\\mathrm{grid}}_t$ be an exogenous grid or feeder upper bound during slot $t$. Then $p_t \\le a_t \\cdot \\min\\{P^{\\max}_t, P^{\\mathrm{grid}}_t\\}$ for all $t$.\n- Minimum mobility state of charge: at any slot boundary $t$, impose $\\mathrm{SOC}_t \\ge \\mathrm{SOC}_{\\min}$, where $\\mathrm{SOC}_{\\min} \\in [0,1]$ is a mobility requirement.\n- Target by deadline: impose $\\mathrm{SOC}_D \\ge \\mathrm{SOC}_{\\mathrm{target}}$, where $\\mathrm{SOC}_{\\mathrm{target}} \\in [0,1]$ is the required state of charge by slot $D$.\n\nFormulation:\n- The feasibility problem is a linear program with decision variables $p_t$ and linear inequality constraints. With the definition of $\\alpha$, the target-by-deadline constraint can be written as $\\alpha \\sum_{t=0}^{D-1} p_t \\ge \\mathrm{SOC}_{\\mathrm{target}} - \\mathrm{SOC}_0$, which is linear. Minimum mobility constraints for intermediate times can be written as $\\alpha \\sum_{k=0}^{t-1} p_k \\ge \\mathrm{SOC}_{\\min} - \\mathrm{SOC}_0$ for $t=1,\\dots,D$, which are also linear. The objective may be the zero function, as only feasibility is required.\n\nYour task:\n- Write a program that, for each test case, constructs the described linear program, solves it, and returns a boolean indicating whether the constraints are feasible (i.e., whether some charging schedule $\\{p_t\\}$ exists that satisfies all constraints). If $D=0$, interpret the constraints as requiring $\\mathrm{SOC}_0 \\ge \\mathrm{SOC}_{\\mathrm{target}}$ and $\\mathrm{SOC}_0 \\ge \\mathrm{SOC}_{\\min}$.\n- Units: power must be handled in kilowatts (kW), energy in kilowatt-hours (kWh), time in hours, and state of charge as a decimal fraction in $[0,1]$ (e.g., $0.8$). The final boolean result for each test case should be computed without rounding or truncation and printed as either $True$ or $False$.\n\nTest suite:\nProvide results for the following four test cases, each specified as $(E_{\\mathrm{cap}}, \\Delta t, D, \\eta, \\mathrm{SOC}_0, \\mathrm{SOC}_{\\min}, \\mathrm{SOC}_{\\mathrm{target}}, \\{P^{\\max}_t\\}_{t=0}^{D-1}, \\{P^{\\mathrm{grid}}_t\\}_{t=0}^{D-1}, \\{a_t\\}_{t=0}^{D-1})$:\n1. Happy path feasibility with continuous availability and typical alternating current Level $2$ charging:\n   - $E_{\\mathrm{cap}} = 60$ kWh, $\\Delta t = 0.25$ h, $D = 16$, $\\eta = 0.92$, $\\mathrm{SOC}_0 = 0.5$, $\\mathrm{SOC}_{\\min} = 0.2$, $\\mathrm{SOC}_{\\mathrm{target}} = 0.8$, $P^{\\max}_t = 7$ kW for all $t$, $P^{\\mathrm{grid}}_t = 10$ kW for all $t$, $a_t = 1$ for all $t$.\n2. Infeasible due to insufficient availability and low power:\n   - $E_{\\mathrm{cap}} = 60$ kWh, $\\Delta t = 1.0$ h, $D = 1$, $\\eta = 0.92$, $\\mathrm{SOC}_0 = 0.7$, $\\mathrm{SOC}_{\\min} = 0.2$, $\\mathrm{SOC}_{\\mathrm{target}} = 0.9$, $P^{\\max}_0 = 3.6$ kW, $P^{\\mathrm{grid}}_0 = 3.6$ kW, $a_0 = 1$.\n3. Boundary case with immediate deadline:\n   - $E_{\\mathrm{cap}} = 50$ kWh, $\\Delta t = 0.25$ h, $D = 0$, $\\eta = 0.90$, $\\mathrm{SOC}_0 = 0.7$, $\\mathrm{SOC}_{\\min} = 0.6$, $\\mathrm{SOC}_{\\mathrm{target}} = 0.7$. Empty sequences for $P^{\\max}_t$, $P^{\\mathrm{grid}}_t$, and $a_t$ because there are no slots.\n4. Exact-feasibility boundary with intermittent availability and varying power limits:\n   - $E_{\\mathrm{cap}} = 50$ kWh, $\\Delta t = 0.25$ h, $D = 5$, $\\eta = 0.80$, $\\mathrm{SOC}_0 = 0.6$, $\\mathrm{SOC}_{\\min} = 0.2$, $\\mathrm{SOC}_{\\mathrm{target}} = 0.8$, $P^{\\max}_t = [20, 20, 15, 20, 15]$ kW, $P^{\\mathrm{grid}}_t = [25, 25, 25, 25, 25]$ kW, $a_t = [1, 0, 1, 0, 1]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the boolean results for the test suite as a comma-separated list enclosed in square brackets, for example, $[True,False,True,True]$.",
            "solution": "We begin from conservation of energy, which states that the rate of change of energy stored in a system is equal to the net power input. For an electric vehicle battery with charging efficiency $\\eta \\in (0,1]$, when a charger delivers electrical power $p_t$ in kilowatts over a slot of duration $\\Delta t$ hours, the energy stored in the battery increases by $\\Delta E_t = \\eta\\, p_t\\, \\Delta t$ kilowatt-hours. The state of charge, denoted by $\\mathrm{SOC}_t \\in [0,1]$, is the fraction of the battery's energy capacity $E_{\\mathrm{cap}}$ that is filled, so the incremental change in state of charge in slot $t$ is\n$$\n\\Delta \\mathrm{SOC}_t = \\frac{\\Delta E_t}{E_{\\mathrm{cap}}} = \\frac{\\eta\\, p_t\\, \\Delta t}{E_{\\mathrm{cap}}}.\n$$\nTherefore, the discrete-time state of charge dynamics are\n$$\n\\mathrm{SOC}_{t+1} = \\mathrm{SOC}_t + \\frac{\\eta\\, p_t\\, \\Delta t}{E_{\\mathrm{cap}}}.\n$$\nDefine the constant\n$$\n\\alpha = \\frac{\\eta\\, \\Delta t}{E_{\\mathrm{cap}}}.\n$$\nBy repeated substitution, the state of charge at the deadline slot $D$ is\n$$\n\\mathrm{SOC}_D = \\mathrm{SOC}_0 + \\alpha \\sum_{t=0}^{D-1} p_t.\n$$\n\nWe now collect the constraints required by physical and operational limits and express them in linear form:\n- Nonnegativity of power: $p_t \\ge 0$ for all $t$.\n- Availability and power limits: let $a_t \\in \\{0,1\\}$ indicate whether the vehicle is connected during slot $t$, let $P^{\\max}_t$ be the charger rating in kilowatts, and let $P^{\\mathrm{grid}}_t$ be a grid upper bound in kilowatts. The feasible upper bound for slot $t$ is\n$$\n\\overline{P}_t = a_t \\cdot \\min\\{P^{\\max}_t, P^{\\mathrm{grid}}_t\\},\n$$\nso we have $p_t \\le \\overline{P}_t$ for all $t$.\n- Minimum mobility state of charge: impose that for each intermediate slot boundary,\n$$\n\\mathrm{SOC}_t \\ge \\mathrm{SOC}_{\\min} \\quad \\text{for all } t \\in \\{0,1,\\dots,D\\}.\n$$\nSince there is no discharge modeled, these constraints are nonbinding whenever $\\mathrm{SOC}_0 \\ge \\mathrm{SOC}_{\\min}$, but they can be included in the linear program for completeness.\n- Target-by-deadline requirement:\n$$\n\\mathrm{SOC}_D \\ge \\mathrm{SOC}_{\\mathrm{target}}.\n$$\n\nAll constraints are linear in the decision variables $\\{p_t\\}$. In particular, the target constraint can be written as\n$$\n\\alpha \\sum_{t=0}^{D-1} p_t \\ge \\mathrm{SOC}_{\\mathrm{target}} - \\mathrm{SOC}_0,\n$$\nand each minimum mobility constraint can be written as\n$$\n\\alpha \\sum_{k=0}^{t-1} p_k \\ge \\mathrm{SOC}_{\\min} - \\mathrm{SOC}_0 \\quad \\text{for } t=1,\\dots,D.\n$$\nTo use a standard linear programming solver in inequality form with upper bounds, we express these as\n$$\n-\\alpha \\sum_{t=0}^{D-1} p_t \\le -(\\mathrm{SOC}_{\\mathrm{target}} - \\mathrm{SOC}_0),\n$$\nand\n$$\n-\\alpha \\sum_{k=0}^{t-1} p_k \\le -(\\mathrm{SOC}_{\\min} - \\mathrm{SOC}_0), \\quad t=1,\\dots,D.\n$$\n\nWe formulate the feasibility linear program as:\n- Decision variables: $p_t$, $t=0,\\dots,D-1$.\n- Objective: minimize $0$ (the zero function), i.e., any feasible point is acceptable.\n- Inequality constraints: the transformed target and minimum mobility constraints as above.\n- Bounds: $0 \\le p_t \\le \\overline{P}_t$ for each $t$.\n\nAlgorithmic design:\n1. For each test case, compute $\\alpha = \\dfrac{\\eta\\, \\Delta t}{E_{\\mathrm{cap}}}$.\n2. If $D=0$, there are no decision variables. Feasibility reduces to checking $\\mathrm{SOC}_0 \\ge \\mathrm{SOC}_{\\mathrm{target}}$ and $\\mathrm{SOC}_0 \\ge \\mathrm{SOC}_{\\min}$. Return $True$ if both hold, otherwise $False$.\n3. Otherwise, construct the upper bounds $\\overline{P}_t = a_t \\cdot \\min\\{P^{\\max}_t, P^{\\mathrm{grid}}_t\\}$ for $t=0,\\dots,D-1$, and set variable bounds as $0 \\le p_t \\le \\overline{P}_t$.\n4. Build the inequality matrix-vector pair $(A_{\\mathrm{ub}}, b_{\\mathrm{ub}})$:\n   - The target constraint row has entries $A_{\\mathrm{ub}}^{(0,t)} = -\\alpha$ for $t=0,\\dots,D-1$ and $b_{\\mathrm{ub}}^{(0)} = -(\\mathrm{SOC}_{\\mathrm{target}} - \\mathrm{SOC}_0)$.\n   - For each $t=1,\\dots,D$, a minimum mobility row has entries $A_{\\mathrm{ub}}^{(t,u)} = -\\alpha$ for $u=0,\\dots,t-1$ and $A_{\\mathrm{ub}}^{(t,u)} = 0$ for $u=t,\\dots,D-1$, with $b_{\\mathrm{ub}}^{(t)} = -(\\mathrm{SOC}_{\\min} - \\mathrm{SOC}_0)$.\n5. Set the objective vector $c$ to the zero vector of length $D$ and solve the linear program. If the solver reports a feasible solution, return $True$; otherwise, return $False$.\n\nInterpretation for the test suite:\n- In the first case, the cumulative available energy and efficiency suffice to reach the target, so feasibility is expected.\n- In the second case, the single slot with low power is inadequate to produce the required state of charge increase, so infeasibility is expected.\n- In the third case, with immediate deadline and no charging opportunity, feasibility depends solely on the initial state of charge meeting both the target and minimum requirements.\n- In the fourth case, the upper bounds and availability are constructed so that the cumulative possible charging exactly meets the required state of charge increase at the efficiency given, resulting in exact-feasibility at the boundary.\n\nThe program implements this formulation and prints the boolean results for the four test cases in the specified single-line format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef check_feasibility(E_cap, dt, D, eta, soc0, soc_min, soc_target,\n                      pmax, pgrid, availability):\n    \"\"\"\n    Check feasibility of reaching soc_target by deadline with linear constraints.\n    Parameters:\n        E_cap (float): Battery capacity in kWh.\n        dt (float): Slot duration in hours.\n        D (int): Number of slots to the deadline.\n        eta (float): Charging efficiency (0..1].\n        soc0 (float): Initial state of charge (0..1).\n        soc_min (float): Minimum mobility SOC (0..1).\n        soc_target (float): Target SOC by deadline (0..1).\n        pmax (array-like of length D): Per-slot charger maximum power in kW.\n        pgrid (array-like of length D): Per-slot grid upper bound in kW.\n        availability (array-like of length D): Per-slot availability (0 or 1).\n    Returns:\n        bool: True if feasible, False otherwise.\n    \"\"\"\n    # Handle the zero-slot boundary case directly.\n    if D == 0:\n        return (soc0 >= soc_target) and (soc0 >= soc_min)\n\n    alpha = eta * dt / E_cap\n\n    # Compute per-slot upper bounds considering availability and both limits.\n    pmax = np.array(pmax, dtype=float)\n    pgrid = np.array(pgrid, dtype=float)\n    availability = np.array(availability, dtype=float)\n\n    if pmax.shape[0] != D or pgrid.shape[0] != D or availability.shape[0] != D:\n        # Dimension mismatch: treat as infeasible for safety.\n        return False\n\n    ub = availability * np.minimum(pmax, pgrid)\n    bounds = [(0.0, float(ub_t)) for ub_t in ub]\n\n    # Build A_ub and b_ub for target and minimum SOC constraints.\n    # Target constraint: -alpha * sum(p_t) = -(soc_target - soc0)\n    A_rows = []\n    b_vals = []\n\n    A_target = -alpha * np.ones(D)\n    b_target = -(soc_target - soc0)\n    A_rows.append(A_target)\n    b_vals.append(b_target)\n\n    # Minimum SOC constraints for each intermediate time t = 1..D:\n    # -alpha * sum_{k=0..t-1}(p_k) = -(soc_min - soc0)\n    for t in range(1, D + 1):\n        row = np.zeros(D)\n        row[:t] = -alpha\n        A_rows.append(row)\n        b_vals.append(-(soc_min - soc0))\n\n    A_ub = np.vstack(A_rows)\n    b_ub = np.array(b_vals)\n\n    # Objective is zero vector (feasibility problem).\n    c = np.zeros(D)\n\n    # Solve the LP using HiGHS.\n    res = linprog(c=c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    # Feasible if solver succeeded.\n    return bool(res.success)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Happy path feasibility with continuous availability.\n        {\n            \"E_cap\": 60.0, \"dt\": 0.25, \"D\": 16, \"eta\": 0.92,\n            \"soc0\": 0.5, \"soc_min\": 0.2, \"soc_target\": 0.8,\n            \"pmax\": [7.0]*16, \"pgrid\": [10.0]*16, \"availability\": [1]*16\n        },\n        # 2. Infeasible due to insufficient availability and low power.\n        {\n            \"E_cap\": 60.0, \"dt\": 1.0, \"D\": 1, \"eta\": 0.92,\n            \"soc0\": 0.7, \"soc_min\": 0.2, \"soc_target\": 0.9,\n            \"pmax\": [3.6], \"pgrid\": [3.6], \"availability\": [1]\n        },\n        # 3. Boundary case with immediate deadline (D=0).\n        {\n            \"E_cap\": 50.0, \"dt\": 0.25, \"D\": 0, \"eta\": 0.90,\n            \"soc0\": 0.7, \"soc_min\": 0.6, \"soc_target\": 0.7,\n            \"pmax\": [], \"pgrid\": [], \"availability\": []\n        },\n        # 4. Exact-feasibility boundary with intermittent availability and varying power limits.\n        {\n            \"E_cap\": 50.0, \"dt\": 0.25, \"D\": 5, \"eta\": 0.80,\n            \"soc0\": 0.6, \"soc_min\": 0.2, \"soc_target\": 0.8,\n            \"pmax\": [20.0, 20.0, 15.0, 20.0, 15.0],\n            \"pgrid\": [25.0, 25.0, 25.0, 25.0, 25.0],\n            \"availability\": [1, 0, 1, 0, 1]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = check_feasibility(\n            case[\"E_cap\"], case[\"dt\"], case[\"D\"], case[\"eta\"],\n            case[\"soc0\"], case[\"soc_min\"], case[\"soc_target\"],\n            case[\"pmax\"], case[\"pgrid\"], case[\"availability\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}