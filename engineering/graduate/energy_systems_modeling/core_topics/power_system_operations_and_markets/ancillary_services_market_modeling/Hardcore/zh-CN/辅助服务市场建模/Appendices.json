{
    "hands_on_practices": [
        {
            "introduction": "电力系统为何需要像惯量这样的辅助服务？其根源在于物理定律。本练习将引导您通过经典的摇摆方程，将发电扰动后系统频率的初始变化率（RoCoF）与系统总惯量联系起来。通过这个实践 ，您将亲手推导出一个关键约束，它阐明了为维持电网稳定而必须采购的最小惯量，从而深刻理解物理原理如何催生出市场需求。",
            "id": "4069530",
            "problem": "一家输电系统运营商计划设计一种用于转动惯量的辅助服务产品，以在发生可信事故后强制执行频率变化率 (RoCoF) 限制。考虑一个由单一惯性中心电机代表的系统。该惯性中心频率的聚合摇摆动态由经典摇摆方程描述，惯性常数按标准方式定义：在额定速率下，旋转质量中存储的动能为 $E_{k} = H_{\\mathrm{sys}} S_{\\mathrm{base}}$，其中 $H_{\\mathrm{sys}}$ 是系统功率基准 $S_{\\mathrm{base}}$（单位为兆伏安）下的聚合惯性常数（单位为秒），$E_{k}$ 的单位为兆焦耳。假设在扰动发生的初始瞬间，负荷阻尼和一次控制可以忽略不计，因此初始频率变化率仅由功率不平衡和惯性决定。\n\n额定频率为 $f_{0} = 50$ Hz。系统功率基准为 $S_{\\mathrm{base}} = 31$ GW，可信事故为大小为 $\\Delta P = 1.30$ GW 的突发性发电损失。RoCoF 限制为 $|\\mathrm{d}f/\\mathrm{d}t| \\le \\alpha$，其中 $\\alpha = 0.40$ Hz/s。将该损失视为作用于惯性中心的阶跃不平衡，并使用摇摆方程推导将 RoCoF 限制 $\\alpha$ 与最小聚合惯性常数 $H_{\\mathrm{sys}}$ 联系起来的条件。然后，使用给定数据计算必须采购的最小 $H_{\\mathrm{sys}}$。最终答案以秒为单位表示，并四舍五入到四位有效数字。",
            "solution": "用户要求我验证并解决一个来自能源系统建模领域的问题，该问题具体涉及转动惯量的辅助服务市场。\n\n### 步骤 1：提取已知条件\n- **系统模型**：单一惯性中心电机。\n- **系统动态**：经典摇摆方程。\n- **惯性常数定义**：$E_{k} = H_{\\mathrm{sys}} S_{\\mathrm{base}}$，其中 $E_{k}$ 是动能（单位：兆焦耳 $MJ$），$H_{\\mathrm{sys}}$ 是聚合惯性常数（单位：秒 $s$），$S_{\\mathrm{base}}$ 是系统功率基准（单位：兆伏安 $MVA$）。\n- **假设**：在扰动发生的初始瞬间，负荷阻尼和一次控制可以忽略不计。\n- **额定频率**：$f_{0} = 50$ Hz。\n- **系统功率基准**：$S_{\\mathrm{base}} = 31$ GW。\n- **可信事故**：突发性发电损失 $\\Delta P = 1.30$ GW。\n- **RoCoF 限制**：$|\\mathrm{d}f/\\mathrm{d}t| \\le \\alpha$，其中 $\\alpha = 0.40$ Hz/s。\n- **任务**：推导将 RoCoF 限制与最小聚合惯性常数 $H_{\\mathrm{sys}}$ 联系起来的条件，然后计算这个最小 $H_{\\mathrm{sys}}$。\n- **输出格式**：将最终答案四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题基于惯性中心的经典摇摆方程，这是分析电力系统在扰动后初始频率动态的基本和标准模型。惯性常数 $H_{\\mathrm{sys}}$ 和频率变化率 (RoCoF) 限制的概念是现代电力系统稳定性和运行的核心原则。采购惯性以管理 RoCoF 的情景在当代能源系统中是一个现实且关键的问题，尤其是在非同步可再生能源渗透率不断增加的情况下。该问题具有科学合理性。\n\n2.  **适定性**：该问题提供了建立数学关系和求解未知变量 ($H_{\\mathrm{sys}}$) 所需的所有数据。目标明确，并且可以预期存在一个满足给定约束的唯一最小 $H_{\\mathrm{sys}}$ 值。\n\n3.  **客观性**：问题陈述使用了精确、量化且无偏见的语言。\n\n4.  **一致性检查**：问题在 $H_{\\mathrm{sys}}$ 的正式定义中以 MVA 为单位定义 $S_{\\mathrm{base}}$，但其值以 GW 给出。在电力系统分析中，功率基准通常以 MW 或 GW 表示，这隐含地假设功率因数为 1，使得有功功率 (MW) 和视在功率 (MVA) 的数值相等。鉴于扰动 $\\Delta P$ 也以 GW（有功功率）为单位，将 $S_{\\mathrm{base}}$ 视为 $31$ GW（或 $31000$ MW）的基准是合理的。这是一种常见的约定，并不构成矛盾。该问题内部一致且完整。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。它具有科学依据，适定、客观且内部一致。我现在将开始求解。\n\n对于同步电机或由惯性中心代表的聚合系统，摇摆方程将转子速率的变化与机械输入功率和电气输出功率之间的不平衡联系起来。在标幺值 (p.u.) 系统中，该方程为：\n$$ 2 H_{\\mathrm{sys}} \\frac{\\mathrm{d}\\omega_{\\mathrm{p.u.}}}{\\mathrm{d}t} = P_{m, \\mathrm{p.u.}} - P_{e, \\mathrm{p.u.}} = \\Delta P_{\\text{p.u.}} $$\n此处，$H_{\\mathrm{sys}}$ 是聚合的系统惯性常数（单位为秒），$\\omega_{\\mathrm{p.u.}}$ 是系统频率的标幺值，$t$ 是时间（单位为秒），$\\Delta P_{\\text{p.u.}}$ 是基于系统功率基准 $S_{\\mathrm{base}}$ 的净功率不平衡标幺值。\n\n以赫兹为单位的系统频率 $f$ 通过额定频率 $f_{0}$ 与标幺值频率 $\\omega_{\\mathrm{p.u.}}$ 相关：\n$$ f = f_{0} \\omega_{\\mathrm{p.u.}} $$\n对该表达式关于时间求导，得到频率变化率 (RoCoF)（单位：Hz/s）与标幺值频率变化率之间的关系：\n$$ \\frac{\\mathrm{d}f}{\\mathrm{d}t} = f_{0} \\frac{\\mathrm{d}\\omega_{\\mathrm{p.u.}}}{\\mathrm{d}t} $$\n我们可以重新整理这个式子来表示标幺值频率的导数：\n$$ \\frac{\\mathrm{d}\\omega_{\\mathrm{p.u.}}}{\\mathrm{d}t} = \\frac{1}{f_{0}} \\frac{\\mathrm{d}f}{\\mathrm{d}t} $$\n将此代入标幺值摇摆方程可得：\n$$ 2 H_{\\mathrm{sys}} \\left( \\frac{1}{f_{0}} \\frac{\\mathrm{d}f}{\\mathrm{d}t} \\right) = \\Delta P_{\\text{p.u.}} $$\n问题将可信事故描述为大小为 $\\Delta P$ 的突发性发电损失。此事件会立即产生功率不平衡，即电气负荷超过机械发电量。功率不平衡为 $\\Delta P_{\\text{imbalance}} = P_m - P_e = -\\Delta P$。\n以标幺值计算，此不平衡是相对于系统基准功率 $S_{\\mathrm{base}}$ 的：\n$$ \\Delta P_{\\text{p.u.}} = \\frac{-\\Delta P}{S_{\\mathrm{base}}} $$\n问题指出，在初始瞬间，负荷阻尼和一次频率控制可以忽略不计。因此，初始 RoCoF 完全由该功率不平衡和系统的储能动能（惯性）决定。将 $\\Delta P_{\\text{p.u.}}$ 的表达式代入我们修正后的摇摆方程，得到：\n$$ 2 H_{\\mathrm{sys}} \\left( \\frac{1}{f_{0}} \\frac{\\mathrm{d}f}{\\mathrm{d}t} \\right) = -\\frac{\\Delta P}{S_{\\mathrm{base}}} $$\n求解 RoCoF ($\\mathrm{d}f/\\mathrm{d}t$)：\n$$ \\frac{\\mathrm{d}f}{\\mathrm{d}t} = -\\frac{f_{0}}{2 H_{\\mathrm{sys}}} \\frac{\\Delta P}{S_{\\mathrm{base}}} $$\n负号正确地表明发电损失会导致频率下降。\n\n系统的运行必须确保 RoCoF 的绝对值不超过指定的限制 $\\alpha$。这施加了以下约束：\n$$ \\left| \\frac{\\mathrm{d}f}{\\mathrm{d}t} \\right| \\le \\alpha $$\n代入我们的 RoCoF 表达式：\n$$ \\left| -\\frac{f_{0}}{2 H_{\\mathrm{sys}}} \\frac{\\Delta P}{S_{\\mathrm{base}}} \\right| \\le \\alpha $$\n$$ \\frac{f_{0}}{2 H_{\\mathrm{sys}}} \\frac{\\Delta P}{S_{\\mathrm{base}}} \\le \\alpha $$\n这个不等式就是将 RoCoF 限制与系统惯性联系起来的条件。为了满足此条件，$H_{\\mathrm{sys}}$ 必须大于或等于某个最小值。所需的最小惯性 $H_{\\mathrm{sys, min}}$ 在等式成立时求得：\n$$ \\frac{f_{0}}{2 H_{\\mathrm{sys, min}}} \\frac{\\Delta P}{S_{\\mathrm{base}}} = \\alpha $$\n求解 $H_{\\mathrm{sys, min}}$ 得到最终推导出的公式：\n$$ H_{\\mathrm{sys, min}} = \\frac{f_{0}}{2 \\alpha} \\frac{\\Delta P}{S_{\\mathrm{base}}} $$\n我们已知以下数值：\n- $f_{0} = 50$ Hz\n- $\\alpha = 0.40$ Hz/s\n- $\\Delta P = 1.30$ GW\n- $S_{\\mathrm{base}} = 31$ GW\n\n功率不平衡的标幺值是一个无量纲量：\n$$ \\frac{\\Delta P}{S_{\\mathrm{base}}} = \\frac{1.30 \\text{ GW}}{31 \\text{ GW}} = \\frac{1.30}{31} $$\n现在，我们将数值代入 $H_{\\mathrm{sys, min}}$ 的方程中：\n$$ H_{\\mathrm{sys, min}} = \\frac{50}{2 \\times 0.40} \\left( \\frac{1.30}{31} \\right) $$\n$$ H_{\\mathrm{sys, min}} = \\frac{50}{0.80} \\left( \\frac{1.30}{31} \\right) $$\n$$ H_{\\mathrm{sys, min}} = 62.5 \\left( \\frac{1.30}{31} \\right) $$\n$$ H_{\\mathrm{sys, min}} = \\frac{81.25}{31} $$\n$$ H_{\\mathrm{sys, min}} \\approx 2.62096774... \\text{ s} $$\n问题要求答案四舍五入到四位有效数字。\n$$ H_{\\mathrm{sys, min}} \\approx 2.621 \\text{ s} $$",
            "answer": "$$\\boxed{2.621}$$"
        },
        {
            "introduction": "确保电网在发生意外事件（如发电机组故障）后的安全稳定，不仅需要储备足够的备用容量，更关键的是要确保这些备用容量能够被有效输送到需要的地方。本练习  使用了电力系统分析中广泛应用的直流潮流模型，构建了一个典型的场景。您将通过计算发现，若不考虑输电网络的位置约束，即使系统整体备用充足，紧急调度也可能导致新的线路过载，从而直观地理解为何必须引入带有地域属性的辅助服务产品。",
            "id": "4069445",
            "problem": "考虑一个在直流潮流近似（DC）下建模的三母线输电网络。假设电压幅值固定且相等，相角差很小，并且忽略无功功率。设母线$1$为电压相角的参考点。网络拓扑是以母线$1$为中心的星形结构：有一条线路连接母线$1$和母线$2$，另一条独立的线路连接母线$1$和母线$3$。母线$2$和母线$3$之间没有直接连接的线路。母线$1$和母线$2$之间的线路串联电抗为$x_{21} = 0.1$（基于一致基准的标幺值），热流限制为$F_{21}^{\\max} = 100$ MW。母线$1$和母线$3$之间的线路串联电抗为$x_{31} = 0.1$，热流限制为$F_{31}^{\\max} = 70$ MW。在直流近似下，线路潮流满足$f_{ij} = \\frac{1}{x_{ij}}\\left(\\theta_i - \\theta_j\\right)$，节点功率平衡满足$p_i = \\sum_{j \\in \\mathcal{N}(i)} \\frac{1}{x_{ij}}\\left(\\theta_i - \\theta_j\\right)$，其中$p_i$是母线$i$的净有功功率注入，$\\theta_i$是母线$i$的电压相角，$\\mathcal{N}(i)$表示连接到母线$i$的母线集合。\n\n故障前，系统在母线$1$有一个$100$ MW的单一负荷（因此$p_1 = -100$ MW），在母线$2$有一个产生$100$ MW的单一发电机（因此$p_2 = +100$ MW），母线$3$的发电机在线但调度出力为$0$ MW（因此$p_3 = 0$ MW）。系统运营商设定了一个全系统范围的旋转备用要求，其大小等于最大的单一发电机故障。最大的故障是母线$2$的发电机失功，即$C^{\\max} = 100$ MW。系统运营商在母线$3$获取了全部$100$ MW的旋转备用，没有任何位置可送性约束。\n\n现在考虑母线$2$发电机完全停运的$N-1$故障。在停运后，运营商立即部署母线$3$的$100$ MW旋转备用以重新平衡系统。使用直流潮流关系和给定的网络，计算母线$1$和母线$3$之间线路的故障后过载量，定义为故障后潮流$f_{31}$超过热限制$F_{31}^{\\max}$的量。以MW为单位表示您的最终结果。无需四舍五入；如果适用，请提供精确的整数值。",
            "solution": "该问题陈述具有科学依据、提法明确且客观。它描述了电力系统安全分析中使用直流（DC）潮流近似的一个标准场景，这是该领域一个基础且广泛使用的模型。所有参数和条件都已给出，从而可以得到唯一且有意义的解。因此，我们可以进行计算。\n\n目标是计算连接母线$1$和母线$3$的输电线路上故障后的过载量。过载量定义为故障后潮流的大小（我们将其表示为$|f_{31}'|$）与线路热限制$F_{31}^{\\max}$之间的差值。\n\n首先，我们必须确定系统功率注入的故障后状态。故障是母线$2$的发电机停运，该发电机原先产生$100$ MW。在母线$3$获取的$100$ MW旋转备用被部署以补偿这一损失并重新平衡系统。母线$1$的负荷保持不变。\n\n故障后的功率注入（用上撇符号（$'$）表示）为：\n-   母线$1$的负荷：$p_1' = -100$ MW。\n-   母线$2$的发电：$p_2' = 0$ MW（由于停运）。\n-   母线$3$的发电：$p_3' = 100$ MW（由于备用部署）。\n\n总净注入功率为$p_1' + p_2' + p_3' = -100 + 0 + 100 = 0$ MW，这证实在无损直流模型中功率是平衡的。\n\n接下来，我们应用直流潮流方程来确定故障后的电压相角$\\theta_i'$。母线$1$被定义为参考母线，因此其电压相角在故障前和故障后均为零：$\\theta_1' = 0$ 弧度。\n\n任意母线$i$的节点功率平衡方程由$p_i = \\sum_{j \\in \\mathcal{N}(i)} \\frac{1}{x_{ij}}(\\theta_i - \\theta_j)$给出。网络由一条从母线$1$到母线$2$的线路和一条从母线$1$到母线$3$的线路组成。\n\n对于母线$2$，故障后的功率平衡为：\n$$p_2' = \\frac{1}{x_{21}}(\\theta_2' - \\theta_1')$$\n代入已知值：\n$$0 = \\frac{1}{0.1}(\\theta_2' - 0)$$\n$$0 = 10 \\theta_2'$$\n这意味着母线$2$的故障后相角为$\\theta_2' = 0$ 弧度。\n\n对于母线$3$，故障后的功率平衡为：\n$$p_3' = \\frac{1}{x_{31}}(\\theta_3' - \\theta_1')$$\n代入已知值：\n$$100 = \\frac{1}{0.1}(\\theta_3' - 0)$$\n$$100 = 10 \\theta_3'$$\n解出$\\theta_3'$得到$\\theta_3' = 10$。\n\n作为验证，我们可以检查参考母线（母线$1$）的功率平衡：\n$$p_1' = \\frac{1}{x_{21}}(\\theta_1' - \\theta_2') + \\frac{1}{x_{31}}(\\theta_1' - \\theta_3')$$\n$$-100 = \\frac{1}{0.1}(0 - 0) + \\frac{1}{0.1}(0 - 10)$$\n$$-100 = 0 + 10(-10)$$\n$$-100 = -100$$\n计算出的相角与所有母线的功率注入一致。\n\n现在我们可以计算母线$1$和母线$3$之间线路的故障后潮流。从母线$3$到母线$1$的潮流$f_{31}'$由公式$f_{ij} = \\frac{1}{x_{ij}}(\\theta_i - \\theta_j)$给出：\n$$f_{31}' = \\frac{1}{x_{31}}(\\theta_3' - \\theta_1')$$\n$$f_{31}' = \\frac{1}{0.1}(10 - 0) = 10 \\times 10 = 100$$\n问题将线路电抗定义为标幺值，功率注入定义为MW，并直接给出了潮流方程。一致性意味着计算出的潮流$f_{31}'$的单位是MW。因此，3-1线路上的故障后潮流为$100$ MW。潮流的大小为$|f_{31}'| = 100$ MW。\n\n最后，我们计算过载量。线路的热限制为$F_{31}^{\\max} = 70$ MW。过载量是潮流超过此限制的量。\n$$\\text{过载量} = |f_{31}'| - F_{31}^{\\max}$$\n$$\\text{过载量} = 100 \\text{ MW} - 70 \\text{ MW} = 30 \\text{ MW}$$\n\n母线$1$和母线$3$之间线路的故障后过载量的大小为$30$ MW。",
            "answer": "$$\\boxed{30}$$"
        },
        {
            "introduction": "现代电力市场运行的核心是优化资源的分配，这在辅助服务采购中尤为复杂，因为市场通常需要多种性能和成本各异的备用品种（如旋转备用、非旋转备用等）。一个高效的市场机制允许高等级服务替代低等级服务需求，以降低总成本，但这必须在严谨的约束下进行，以防止“一物多卖”等问题。这项实践  将带您深入市场建模的核心，通过构建一个线性规划模型，来模拟这种分层、可替代的备用服务联合优化过程，这正是许多真实电力市场结算引擎的逻辑基础。",
            "id": "4069460",
            "problem": "考虑一个独立系统运营商 (ISO)，它按层级采购多种类别的运行备用：旋转备用、非旋转备用和三次备用。ISO 允许沿此层级向下替代：旋转备用可以满足非旋转备用和三次备用的需求；非旋转备用可以满足三次备用的需求。然而，为保持物理完整性，任何单位的容量在不同类别中都不能被重复计算。目标是以一种既能强制执行市场出清又能防止重复计算的方式，来编码这种级联的向下替代约束。\n\n从以下基本原则出发：\n- 容量守恒：任何物理容量在互斥的用途中只能被分配一次，这意味着分配量是可加的，并且其上限受可用容量的限制。如果多个用途从同一个物理池中获取容量，那么它们分配数量的总和不能超过该池可提供的总量。\n- 带替代的市场出清：对于每个需求类别，来自合格类别的分配贡献之和加上任何未满足的松弛量，必须至少等于该需求。向下替代是允许的，即允许来自较高级别的供应出现在较低级别市场出清的左侧，但反之则不行。\n- 非负性与单位一致性：分配量和未满足的松弛量均为非负。所有备用量均以兆瓦 (MW) 为单位计量，需求和可用容量也必须以相同单位建模。\n\n您必须设计一个实现这些原则的线性规划 (LP) 模型。该 LP 模型必须包含决策变量，用以表示从每个类别中分配多少容量来满足各项需求，同时还需包含非负的松弛变量来捕捉任何未满足的需求，以确保 LP 模型始终可行。请从基本原理出发，论证哪些容量流是物理上允许的，以及如何为每个物理容量池编码“无重复计算”的条件。\n\n您的程序必须为每个测试用例构建并求解该 LP 模型，以计算最小总未满足需求，结果以兆瓦为单位的浮点数表示。目标是在满足物理容量守恒和带替代的市场出清约束的条件下，最小化各类别未满足备用之和。对于每个测试用例，输出最小总未满足需求（单位为 $\\mathrm{MW}$），四舍五入到三位小数。\n\n定义决策变量，均以 $\\mathrm{MW}$ 为单位：\n- $x_{S \\rightarrow S}$: 分配用于满足旋转备用需求的旋转备用容量，\n- $x_{S \\rightarrow NS}$: 分配用于满足非旋转备用需求的旋转备用容量，\n- $x_{S \\rightarrow T}$: 分配用于满足三次备用需求的旋转备用容量，\n- $x_{NS \\rightarrow NS}$: 分配用于满足非旋转备用需求的非旋转备用容量，\n- $x_{NS \\rightarrow T}$: 分配用于满足三次备用需求的非旋转备用容量，\n- $x_{T \\rightarrow T}$: 分配用于满足三次备用需求的三次备用容量，\n- $u_{S}$: 未满足的旋转备用需求，\n- $u_{NS}$: 未满足的非旋转备用需求，\n- $u_{T}$: 未满足的三次备用需求。\n\n所有变量必须约束为非负。级联和无重复计算约束必须强制规定：旋转备用容量可以为任何需求类别做出贡献，非旋转备用容量可以为非旋转和三次备用需求做出贡献，而三次备用容量只能为三次备用需求做出贡献。“无重复计算”条件必须通过对源自同一类别的容量流进行容量守恒建模来体现。\n\n测试套件：\n提供以下四个测试用例，每个用例均由可用容量和需求指定，单位均为 $\\mathrm{MW}$：\n1. 理想情况，需要替代：\n   - 可用容量: $S_{\\mathrm{avail}} = 100$, $NS_{\\mathrm{avail}} = 30$, $T_{\\mathrm{avail}} = 10$。\n   - 需求: $R_{S} = 80$, $R_{NS} = 40$, $R_{T} = 20$。\n2. 边界情况，精确匹配：\n   - 可用容量: $S_{\\mathrm{avail}} = 50$, $NS_{\\mathrm{avail}} = 20$, $T_{\\mathrm{avail}} = 30$。\n   - 需求: $R_{S} = 50$, $R_{NS} = 20$, $R_{T} = 30$。\n3. 不可行情况，即使有替代，总容量也不足：\n   - 可用容量: $S_{\\mathrm{avail}} = 60$, $NS_{\\mathrm{avail}} = 10$, $T_{\\mathrm{avail}} = 5$。\n   - 需求: $R_{S} = 50$, $R_{NS} = 30$, $R_{T} = 20$。\n4. 强调防止重复计算的边缘情况（单个池必须在所有需求间分配）：\n   - 可用容量: $S_{\\mathrm{avail}} = 30$, $NS_{\\mathrm{avail}} = 0$, $T_{\\mathrm{avail}} = 0$。\n   - 需求: $R_{S} = 10$, $R_{NS} = 10$, $R_{T} = 10$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，$[\\text{result1},\\text{result2},\\text{result3}]$）。每个结果必须是对应测试用例的最小总未满足需求，单位为 $\\mathrm{MW}$，四舍五入到三位小数，列表中无空格。例如，一个有效的输出可以是 $[0.000,0.000,25.000,0.000]$。",
            "solution": "问题陈述是能源系统建模领域中一个有效且定义明确的练习，特别是在辅助服务采购领域。它要求构建一个线性规划 (LP) 模型，以协同优化分层运行备用的分配，同时遵循可替代性和容量守恒约束。该问题在科学上是合理的，逻辑上是一致的，并提供了构建和求解模型所需的所有信息。\n\n问题的核心是将物理规则和市场规则转化为一组数学约束。给定三类备用容量：旋转备用 ($S$)、非旋转备用 ($NS$) 和三次备用 ($T$)，其可用量分别为 $S_{\\mathrm{avail}}$、$NS_{\\mathrm{avail}}$ 和 $T_{\\mathrm{avail}}$。同时，也给定了每个类别的需求：$R_S$、$R_{NS}$ 和 $R_T$。\n\n目标是最小化总未满足需求。我们定义非负松弛变量 $u_S$、$u_{NS}$ 和 $u_T$ 来表示满足各项需求的缺口。因此，目标函数为：\n$$\n\\text{Minimize} \\quad Z = u_S + u_{NS} + u_T\n$$\n\n决策变量，如问题中所定义，表示从一个来源类别到一个目标需求的容量流。例如，$x_{S \\rightarrow NS}$ 是用于满足非旋转备用需求的旋转备用容量。所有决策变量必须为非负。\n\n我们基于两个基本原则来构建约束：\n\n1.  **容量守恒（无重复计算）：** 此原则确保从特定备用池中分配的总容量不超过该池的物理可用量。一兆瓦的容量不能被出售两次。这导致每个容量来源对应一个约束。\n\n    *   对于旋转备用池，所有源自于它的分配之和不能超过其可用容量：\n        $$x_{S \\rightarrow S} + x_{S \\rightarrow NS} + x_{S \\rightarrow T} \\le S_{\\mathrm{avail}}$$\n\n    *   对于非旋转备用池，它可以满足非旋转和三次备用的需求：\n        $$x_{NS \\rightarrow NS} + x_{NS \\rightarrow T} \\le NS_{\\mathrm{avail}}$$\n\n    *   对于三次备用池，它只能满足自己的需求：\n        $$x_{T \\rightarrow T} \\le T_{\\mathrm{avail}}$$\n\n2.  **带替代的市场出清：** 此原则确保对于每个需求，所有来自合格来源类别的贡献之和，加上任何未满足的松弛量，必须至少等于所需数量。\n\n    *   对于旋转备用需求，只有旋转容量是合格的：\n        $$x_{S \\rightarrow S} + u_S \\ge R_S$$\n\n    *   对于非旋转备用需求，由于向下替代，旋转和非旋转容量都是合格的：\n        $$x_{S \\rightarrow NS} + x_{NS \\rightarrow NS} + u_{NS} \\ge R_{NS}$$\n\n    *   对于三次备用需求，由于级联替代，所有三种容量类型都是合格的：\n        $$x_{S \\rightarrow T} + x_{NS \\rightarrow T} + x_{T \\rightarrow T} + u_T \\ge R_T$$\n\n结合这些元素，我们得到了一个完整的 LP 公式。为了使用像 `scipy.optimize.linprog` 这样的标准求解器来求解，我们必须将其表示为标准形式：最小化 $\\mathbf{c}^T \\mathbf{x}$，约束条件为 $\\mathbf{A_{ub}} \\mathbf{x} \\le \\mathbf{b_{ub}}$ 和 $\\mathbf{x} \\ge 0$。\n\n决策变量向量 $\\mathbf{x}$ 是一个 $9 \\times 1$ 的列向量：\n$$\n\\mathbf{x} = [x_{S \\rightarrow S}, x_{S \\rightarrow NS}, x_{S \\rightarrow T}, x_{NS \\rightarrow NS}, x_{NS \\rightarrow T}, x_{T \\rightarrow T}, u_S, u_{NS}, u_T]^T\n$$\n目标系数向量 $\\mathbf{c}$ 是：\n$$\n\\mathbf{c} = [0, 0, 0, 0, 0, 0, 1, 1, 1]^T\n$$\n约束必须写成“小于等于”的不等式。容量守恒约束已经是这种形式。形式为 $A \\ge B$ 的市场出清约束必须重写为 $-A \\le -B$。\n\n这产生了一个 $6 \\times 9$ 的矩阵 $\\mathbf{A_{ub}}$ 和一个 $6 \\times 1$ 的向量 $\\mathbf{b_{ub}}$：\n$$\n\\mathbf{A_{ub}} = \\begin{pmatrix}\n1  & 1  & 1  & 0  & 0  & 0  & 0  & 0  & 0 \\\\\n0  & 0  & 0  & 1  & 1  & 0  & 0  & 0  & 0 \\\\\n0  & 0  & 0  & 0  & 0  & 1  & 0  & 0  & 0 \\\\\n-1 & 0  & 0  & 0  & 0  & 0  & -1 & 0  & 0 \\\\\n0  & -1 & 0  & -1 & 0  & 0  & 0  & -1 & 0 \\\\\n0  & 0  & -1 & 0  & -1 & -1 & 0  & 0  & -1\n\\end{pmatrix}\n$$\n$$\n\\mathbf{b_{ub}} = [S_{\\mathrm{avail}}, NS_{\\mathrm{avail}}, T_{\\mathrm{avail}}, -R_S, -R_{NS}, -R_T]^T\n$$\n所有变量都约束为非负，因此对于 $\\mathbf{x}$ 的每个分量 $x_i$，其边界为 $[0, \\infty)$。程序将为每个测试用例构建这些矩阵，求解 LP，并报告最优目标值，即最小总未满足需求。```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Constructs and solves a linear programming model for ancillary service\n    procurement with downward substitution for a series of test cases.\n    \"\"\"\n    # Test cases are provided as tuples of:\n    # (S_avail, NS_avail, T_avail, R_S, R_NS, R_T)\n    # All quantities are in MW.\n    test_cases = [\n        # 1. Happy path with substitution needed\n        (100.0, 30.0, 10.0, 80.0, 40.0, 20.0),\n        # 2. Boundary case with exact matching\n        (50.0, 20.0, 30.0, 50.0, 20.0, 30.0),\n        # 3. Infeasible case (insufficient total capacity)\n        (60.0, 10.0, 5.0, 50.0, 30.0, 20.0),\n        # 4. Edge case stressing double-counting prevention\n        (30.0, 0.0, 0.0, 10.0, 10.0, 10.0),\n    ]\n\n    results = []\n\n    # The decision variables are ordered as follows:\n    # x_S->S, x_S->NS, x_S->T, x_NS->NS, x_NS->T, x_T->T, u_S, u_NS, u_T\n    # 0       1        2        3         4        5       6    7     8\n\n    # Objective function: Minimize u_S + u_NS + u_T\n    c = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1])\n\n    # Constraint matrix A_ub for inequalities of the form A_ub @ x = b_ub\n    # It has 6 constraints (3 capacity, 3 requirement) and 9 variables.\n    A_ub = np.array([\n        # Capacity conservation constraints:\n        # 1. x_S->S + x_S->NS + x_S->T = S_avail\n        [1, 1, 1, 0, 0, 0, 0, 0, 0],\n        # 2. x_NS->NS + x_NS->T = NS_avail\n        [0, 0, 0, 1, 1, 0, 0, 0, 0],\n        # 3. x_T->T = T_avail\n        [0, 0, 0, 0, 0, 1, 0, 0, 0],\n\n        # Market clearing constraints (multiplied by -1 to fit = form):\n        # 4. x_S->S + u_S >= R_S  => -x_S->S - u_S = -R_S\n        [-1, 0, 0, 0, 0, 0, -1, 0, 0],\n        # 5. x_S->NS + x_NS->NS + u_NS >= R_NS => -x_S->NS - x_NS->NS - u_NS = -R_NS\n        [0, -1, 0, -1, 0, 0, 0, -1, 0],\n        # 6. x_S->T + x_NS->T + x_T->T + u_T >= R_T => -x_S->T - x_NS->T - x_T->T - u_T = -R_T\n        [0, 0, -1, 0, -1, -1, 0, 0, -1],\n    ])\n\n    # All decision variables must be non-negative.\n    bounds = [(0, None) for _ in range(9)]\n\n    for case in test_cases:\n        s_avail, ns_avail, t_avail, r_s, r_ns, r_t = case\n        \n        # Right-hand side vector for the inequality constraints\n        b_ub = np.array([\n            s_avail,\n            ns_avail,\n            t_avail,\n            -r_s,\n            -r_ns,\n            -r_t\n        ])\n        \n        # Solve the linear program\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        # The optimal value of the objective function is the minimal total unmet requirement.\n        # Slack variables ensure feasibility, so the solver should always succeed.\n        if res.success:\n            total_unmet_requirement = res.fun\n        else:\n            # This path is not expected for this problem formulation\n            total_unmet_requirement = np.nan \n\n        results.append(f\"{total_unmet_requirement:.3f}\")\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Constructs and solves a linear programming model for ancillary service\n    procurement with downward substitution for a series of test cases.\n    \"\"\"\n    # Test cases are provided as tuples of:\n    # (S_avail, NS_avail, T_avail, R_S, R_NS, R_T)\n    # All quantities are in MW.\n    test_cases = [\n        # 1. Happy path with substitution needed\n        (100.0, 30.0, 10.0, 80.0, 40.0, 20.0),\n        # 2. Boundary case with exact matching\n        (50.0, 20.0, 30.0, 50.0, 20.0, 30.0),\n        # 3. Infeasible case (insufficient total capacity)\n        (60.0, 10.0, 5.0, 50.0, 30.0, 20.0),\n        # 4. Edge case stressing double-counting prevention\n        (30.0, 0.0, 0.0, 10.0, 10.0, 10.0),\n    ]\n\n    results = []\n\n    # The decision variables are ordered as follows:\n    # x_S-S, x_S-NS, x_S-T, x_NS-NS, x_NS-T, x_T-T, u_S, u_NS, u_T\n    # 0       1        2        3         4        5       6    7     8\n\n    # Objective function: Minimize u_S + u_NS + u_T\n    c = np.array([0, 0, 0, 0, 0, 0, 1, 1, 1])\n\n    # Constraint matrix A_ub for inequalities of the form A_ub @ x = b_ub\n    # It has 6 constraints (3 capacity, 3 requirement) and 9 variables.\n    A_ub = np.array([\n        # Capacity conservation constraints:\n        # 1. x_S-S + x_S-NS + x_S-T = S_avail\n        [1, 1, 1, 0, 0, 0, 0, 0, 0],\n        # 2. x_NS-NS + x_NS-T = NS_avail\n        [0, 0, 0, 1, 1, 0, 0, 0, 0],\n        # 3. x_T-T = T_avail\n        [0, 0, 0, 0, 0, 1, 0, 0, 0],\n\n        # Market clearing constraints (multiplied by -1 to fit = form):\n        # 4. x_S-S + u_S >= R_S  => -x_S-S - u_S = -R_S\n        [-1, 0, 0, 0, 0, 0, -1, 0, 0],\n        # 5. x_S-NS + x_NS-NS + u_NS >= R_NS => -x_S-NS - x_NS-NS - u_NS = -R_NS\n        [0, -1, 0, -1, 0, 0, 0, -1, 0],\n        # 6. x_S-T + x_NS-T + x_T-T + u_T >= R_T => -x_S-T - x_NS-T - x_T-T - u_T = -R_T\n        [0, 0, -1, 0, -1, -1, 0, 0, -1],\n    ])\n\n    # All decision variables must be non-negative.\n    bounds = [(0, None) for _ in range(9)]\n\n    for case in test_cases:\n        s_avail, ns_avail, t_avail, r_s, r_ns, r_t = case\n        \n        # Right-hand side vector for the inequality constraints\n        b_ub = np.array([\n            s_avail,\n            ns_avail,\n            t_avail,\n            -r_s,\n            -r_ns,\n            -r_t\n        ])\n        \n        # Solve the linear program\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        # The optimal value of the objective function is the minimal total unmet requirement.\n        # Slack variables ensure feasibility, so the solver should always succeed.\n        if res.success:\n            total_unmet_requirement = res.fun\n        else:\n            # This path is not expected for this problem formulation\n            total_unmet_requirement = np.nan \n\n        results.append(f\"{total_unmet_requirement:.3f}\")\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}