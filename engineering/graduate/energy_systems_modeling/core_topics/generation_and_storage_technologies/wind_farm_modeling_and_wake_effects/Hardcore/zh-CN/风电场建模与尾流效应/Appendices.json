{
    "hands_on_practices": [
        {
            "introduction": "要精确地为风电场建模，我们必须首先理解单个风力涡轮机如何与风相互作用。这个基础练习将引导您将守恒定律应用于致动盘模型。通过掌握这项练习 ，您将推导出能量提取、推力和最终形成尾流的速度亏损之间的关键关系。",
            "id": "4136830",
            "problem": "一个大型、中性层结的陆上风电场中的单台水平轴风力涡轮机被建模为一个浸没在稳定、不可压缩、轴对称流管中的可渗透、均匀负载的致动盘。远上游的自由来流速度为 $U_{\\infty}$，空气密度为 $\\rho$，转子面积为 $A$。通过盘面速度 $U_{\\text{disk}} = U_{\\infty}(1 - a)$ 定义轴向诱导因子 $a$。假设流管周围存在一个稳定的控制体，剪切和旋流可忽略不计，远上游和远下游的静压相等，并且伯努利方程适用于盘外的流线，盘面两侧存在压力跃升。\n\n从应用于控制体的质量守恒和线性动量守恒出发，结合上述假设，推导涡轮机下游的远尾流中心线速度 $U_{d}$（用 $U_{\\infty}$ 和 $a$ 表示），并推导提取的机械功率 $P$（用 $\\rho$、$A$、$U_{\\infty}$ 和 $a$ 表示）。引入功率系数 (C_p) 为 $C_{p} \\equiv \\dfrac{P}{\\tfrac{1}{2}\\rho A U_{\\infty}^{3}}$，并仅用 $a$ 来表示它。\n\n然后，对于一台以 $\\rho = 1.225\\,\\text{kg m}^{-3}$、$A = 1.0000 \\times 10^{4}\\,\\text{m}^{2}$、$U_{\\infty} = 10.0\\,\\text{m s}^{-1}$ 和 $a = \\dfrac{1}{3}$ 为特征的涡轮机，计算 $U_{d}$ 和 $P$ 的数值。将 $U_{d}$ 以米/秒表示，$P$ 以兆瓦表示。将两个量都四舍五入到4位有效数字。你的最终答案必须是一个包含 $U_{d}$ 和 $P$（使用指定单位）的单行双元素矩阵。",
            "solution": "该问题是有效的，因为它是朗肯-弗劳德致动盘模型的标准应用，该模型是风能工程中一个基础且有科学依据的概念。该问题提法明确、客观、自洽，并使用了符合实际的物理参数。\n\n我们首先将质量守恒和线性动量守恒原理应用于一个由穿过涡轮机盘面的流管所定义的控制体。设流管在远上游的横截面积为 $A_{\\infty}$，在盘面处为 $A$，在远下游为 $A_d$。相应的轴向速度为 $U_{\\infty}$、$U_{\\text{disk}}$ 和 $U_d$。静压分别为 $p_{\\infty}$、$p_{\\text{up}}$（盘面正上游）、$p_{\\text{down}}$（盘面正下游）和远下游的 $p_d$。\n\n首先，根据密度为 $\\rho$ 的不可压缩流体的质量守恒原理，通过流管的质量流量 $\\dot{m}$ 是恒定的。通过涡轮机盘面的质量流量为：\n$$\n\\dot{m} = \\rho A U_{\\text{disk}}\n$$\n使用给定的轴向诱导因子 $a$ 的定义，我们有 $U_{\\text{disk}} = U_{\\infty}(1-a)$。将此代入质量流量表达式中，得到：\n$$\n\\dot{m} = \\rho A U_{\\infty}(1-a)\n$$\n\n接下来，我们应用线性动量守恒。控制体内流体所受的净力等于流体通过它时动量的变化率。涡轮机施加于流体的力方向朝向上游，我们记为 $-T$，其中 $T$ 是作用在涡轮机上的推力。根据动量定理，流管中流体上的总力为：\n$$\n\\sum F_{x} = \\dot{m} (U_{d} - U_{\\infty})\n$$\n作用在流体上的力由控制体表面的压力和来自盘面的力 $-T$ 组成。假设远上游和远下游的压力均等于自由来流静压，即 $p_{\\infty} = p_d$（根据题设），则作用在流体上的净力就是 $-T$。因此，\n$$\n-T = \\dot{m} (U_{d} - U_{\\infty})\n$$\n所以作用在涡轮机上的推力为：\n$$\nT = \\dot{m} (U_{\\infty} - U_{d})\n$$\n代入 $\\dot{m}$ 的表达式：\n$$\nT = \\rho A U_{\\text{disk}} (U_{\\infty} - U_{d})\n$$\n\n现在，我们应用伯努利方程。假设它在盘面上游和下游的流线上有效，但在盘面本身（能量被提取的地方）无效。\n从远上游到盘面前应用伯努利方程：\n$$\np_{\\infty} + \\frac{1}{2}\\rho U_{\\infty}^2 = p_{\\text{up}} + \\frac{1}{2}\\rho U_{\\text{disk}}^2\n$$\n从盘面后到远下游应用伯努利方程，并使用给定条件 $p_d = p_{\\infty}$：\n$$\np_{\\text{down}} + \\frac{1}{2}\\rho U_{\\text{disk}}^2 = p_{d} + \\frac{1}{2}\\rho U_{d}^2 = p_{\\infty} + \\frac{1}{2}\\rho U_{d}^2\n$$\n通过重新整理这两个方程，我们可以得到 $p_{\\text{up}}$ 和 $p_{\\text{down}}$ 的表达式：\n$$\np_{\\text{up}} = p_{\\infty} + \\frac{1}{2}\\rho (U_{\\infty}^2 - U_{\\text{disk}}^2)\n$$\n$$\np_{\\text{down}} = p_{\\infty} + \\frac{1}{2}\\rho (U_{d}^2 - U_{\\text{disk}}^2)\n$$\n推力 $T$ 也是盘面两侧压力差在盘面积 $A$ 上积分的结果：\n$$\nT = (p_{\\text{up}} - p_{\\text{down}}) A\n$$\n代入 $p_{\\text{up}}$ 和 $p_{\\text{down}}$ 的表达式：\n$$\nT = \\left[ \\left(p_{\\infty} + \\frac{1}{2}\\rho (U_{\\infty}^2 - U_{\\text{disk}}^2)\\right) - \\left(p_{\\infty} + \\frac{1}{2}\\rho (U_{d}^2 - U_{\\text{disk}}^2)\\right) \\right] A\n$$\n$$\nT = \\frac{1}{2}\\rho A (U_{\\infty}^2 - U_{d}^2)\n$$\n我们现在有两个关于推力 $T$ 的表达式。令它们相等：\n$$\n\\rho A U_{\\text{disk}} (U_{\\infty} - U_{d}) = \\frac{1}{2}\\rho A (U_{\\infty}^2 - U_{d}^2)\n$$\n我们可以消去两边的 $\\rho A$ 并对平方差进行因式分解：\n$$\nU_{\\text{disk}} (U_{\\infty} - U_{d}) = \\frac{1}{2} (U_{\\infty} - U_{d}) (U_{\\infty} + U_{d})\n$$\n对于非平凡情况，即 $U_{\\infty} \\neq U_d$，我们可以消去 $(U_{\\infty} - U_{d})$ 项，从而得到致动盘理论的一个核心结果：\n$$\nU_{\\text{disk}} = \\frac{1}{2} (U_{\\infty} + U_{d})\n$$\n这表明通过盘面的速度是远上游和远下游速度的平均值。\n\n为了用 $U_{\\infty}$ 和 $a$ 来推导 $U_d$，我们代入定义 $U_{\\text{disk}} = U_{\\infty}(1-a)$：\n$$\nU_{\\infty}(1-a) = \\frac{1}{2} (U_{\\infty} + U_{d})\n$$\n$$\n2U_{\\infty}(1-a) = U_{\\infty} + U_{d}\n$$\n$$\nU_{d} = 2U_{\\infty} - 2aU_{\\infty} - U_{\\infty}\n$$\n$$\nU_{d} = U_{\\infty}(1-2a)\n$$\n这是远尾流速度所要求的表达式。为了使该模型在物理上有意义（即 $U_d  0$），$a$ 必须小于 $1/2$。\n\n接下来，我们推导提取的机械功率 $P$。功率是涡轮机做功的速率，等于推力乘以流体在盘面处的速度：\n$$\nP = T U_{\\text{disk}}\n$$\n使用推力的动量表达式 $T = \\dot{m}(U_{\\infty} - U_{d})$ 和关系式 $\\dot{m} = \\rho A U_{\\text{disk}}$：\n$$\nP = (\\rho A U_{\\text{disk}} (U_{\\infty} - U_{d})) U_{\\text{disk}} = \\rho A U_{\\text{disk}}^2 (U_{\\infty} - U_{d})\n$$\n现在我们用 $U_{\\infty}$ 和 $a$ 表示 $U_{\\text{disk}}$ 和 $U_d$ 并代入：\n$$\nU_{\\text{disk}} = U_{\\infty}(1-a)\n$$\n$$\nU_d = U_{\\infty}(1-2a)\n$$\n$$\nP = \\rho A (U_{\\infty}(1-a))^2 (U_{\\infty} - U_{\\infty}(1-2a))\n$$\n$$\nP = \\rho A U_{\\infty}^2 (1-a)^2 (U_{\\infty} - U_{\\infty} + 2aU_{\\infty})\n$$\n$$\nP = \\rho A U_{\\infty}^2 (1-a)^2 (2aU_{\\infty})\n$$\n$$\nP = 2\\rho A U_{\\infty}^3 a(1-a)^2\n$$\n这是所要求的提取功率的表达式。\n\n功率系数 $C_p$ 定义为 $C_{p} \\equiv \\dfrac{P}{\\tfrac{1}{2}\\rho A U_{\\infty}^{3}}$。代入我们的 $P$ 的表达式：\n$$\nC_p = \\frac{2\\rho A U_{\\infty}^3 a(1-a)^2}{\\frac{1}{2}\\rho A U_{\\infty}^3}\n$$\n消去公因式，我们得到仅用 $a$ 表示的功率系数：\n$$\nC_p = 4a(1-a)^2\n$$\n\n最后，我们使用给定的数据计算 $U_d$ 和 $P$ 的数值：$\\rho = 1.225\\,\\text{kg m}^{-3}$，$A = 1.0000 \\times 10^{4}\\,\\text{m}^{2}$，$U_{\\infty} = 10.0\\,\\text{m s}^{-1}$，以及 $a = \\dfrac{1}{3}$。\n\n远尾流速度 $U_d$ 为：\n$$\nU_d = U_{\\infty}(1-2a) = 10.0 \\left(1 - 2 \\cdot \\frac{1}{3}\\right) = 10.0 \\left(1 - \\frac{2}{3}\\right) = 10.0 \\left(\\frac{1}{3}\\right) = \\frac{10.0}{3}\\,\\text{m s}^{-1}\n$$\n$$\nU_d \\approx 3.3333...\\,\\text{m s}^{-1}\n$$\n四舍五入到4位有效数字，$U_d = 3.333\\,\\text{m s}^{-1}$。\n\n提取的功率 $P$ 为：\n$$\nP = 2\\rho A U_{\\infty}^3 a(1-a)^2 = 2(1.225)(1.0000 \\times 10^4)(10.0)^3 \\left(\\frac{1}{3}\\right) \\left(1-\\frac{1}{3}\\right)^2\n$$\n$$\nP = 2(1.225)(10^4)(10^3) \\left(\\frac{1}{3}\\right) \\left(\\frac{2}{3}\\right)^2 = 2.45 \\times 10^7 \\times \\frac{1}{3} \\times \\frac{4}{9}\n$$\n$$\nP = 2.45 \\times 10^7 \\times \\frac{4}{27} = \\frac{9.8}{27} \\times 10^7\\,\\text{W}\n$$\n$$\nP \\approx 0.36296296... \\times 10^7\\,\\text{W} = 3.6296296... \\times 10^6\\,\\text{W}\n$$\n因为 $1\\,\\text{MW} = 10^6\\,\\text{W}$，所以功率（以兆瓦计）为 $P \\approx 3.6296296...\\,\\text{MW}$。\n四舍五入到4位有效数字，$P = 3.630\\,\\text{MW}$。\n\n数值结果为 $U_d = 3.333\\,\\text{m s}^{-1}$ 和 $P = 3.630\\,\\text{MW}$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 3.333  3.630 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "尾流并非静止不变；它在向下游移动时会不断演化，与周围空气混合膨胀，导致其速度亏损减小。这项动手编程练习  要求您实现经典的Park（Jensen）模型，这是实用风资源评估的基石。您将把物理原理转化为代码，以模拟尾流的扩张，并计算其对下游涡轮机的精确几何影响。",
            "id": "4136770",
            "problem": "你需要构建一个完整且可运行的程序，使用 Park 模型（也称为 Jensen 模型），在均匀速度亏损（顶帽）假设下，模拟两台串联的水平轴风力涡轮机的尾流重叠。目标是确定下游转子区域受上游尾流影响的部分，并计算下游涡轮机平面上按面积加权的转子平均风速。你必须基于质量和动量守恒以及初等欧几里得几何的第一性原理来构建算法，不得依赖本说明中给出的任何捷径公式。该模型必须为一组具有数值指定参数的测试用例实现，并以精确要求的格式生成单行输出。\n\n基本原理和假设：\n- 使用适用于致动盘理论的质量和动量守恒，将推力与上游转子后的速度亏损联系起来，并使用基于湍流夹带的已建立的 Park 模型下游尾流扩展标度。Park 模型假设在扩展的圆形尾流横截面内速度亏损均匀，且无偏航失准。\n- 上游尾流沿下游线性扩展；尾流横截面区域为圆形，其中心线与上游涡轮机轴线对齐。下游涡轮机的中心可能相对于尾流中心线有横向偏移。\n- 下游转子是圆形的。受影响区域是下游位置的尾流圆与下游转子圆之间的相交面积。\n- 下游涡轮机平面上的转子平均风速是通过对环境未扰动风速和均匀尾流亏损进行面积加权混合得到的，其中的亏损由 Park 模型在所考虑的下游位置预测。\n\n每个测试用例的所需输出：\n- 上游尾流对下游转子的影响面积，以平方米 (m²) 表示的浮点数。\n- 下游涡轮机平面上的转子平均风速，以米每秒 (m/s) 表示的浮点数。\n- 两个输出都必须四舍五入到六位小数。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身就是一个形式为 $[A_{\\text{impacted}}, U_{\\text{avg}}]$ 的双元素列表（例如，`[[1.234000,7.890000],[...],...]`）。\n\n定义：\n- 令 $D_u$ 为上游转子直径，单位为米。\n- 令 $D_d$ 为下游转子直径，单位为米。\n- 令 $R_u = D_u/2$ 为上游转子半径，单位为米。\n- 令 $R_d = D_d/2$ 为下游转子半径，单位为米。\n- 令 $U_\\infty$ 为环境入流风速，单位为米每秒。\n- 令 $C_T$ 为上游涡轮机推力系数（无量纲）。\n- 令 $k_w$ 为尾流扩展系数（无量纲），控制线性尾流半径增长。\n- 令 $x$ 为涡轮机中心之间的顺流间距，单位为米。\n- 令 $y$ 为涡轮机中心之间的横向偏移，在下游平面上垂直于风向测量，单位为米。\n- 令 $r_w(x)$ 为根据 Park 模型在下游距离 $x$ 处的尾流半径，单位为米。\n- 令 $\\Delta$ 为根据 Park 模型在距离 $x$ 处的尾流内顺流速度亏损比。\n- 令 $A_{\\cap}$ 为半径为 $r_w(x)$ 的尾流圆与半径为 $R_d$、中心距为 $d=y$ 的下游转子圆之间的几何相交面积。\n- 令 $A_d = \\pi R_d^2$ 为下游转子面积，单位为平方米。\n- 令 $A_{\\text{impacted}} = A_{\\cap}$ 为下游转子面积的受影响部分。\n- 令 $U_{\\text{avg}}$ 为下游转子圆盘上的面积加权平均风速。\n\n你必须实现的算法任务：\n1. 使用上游转子半径 $R_u$、尾流扩展系数 $k_w$ 和下游距离 $x$，通过 Park 模型计算尾流半径 $r_w(x)$。\n2. 基于环境风速 $U_\\infty$、推力系数 $C_T$、尾流扩展系数 $k_w$、上游转子直径 $D_u$ 和下游距离 $x$，根据 Park 模型在质量和动量守恒下的含义，计算距离 $x$ 处尾流内的均匀速度亏损比 $\\Delta$。\n3. 计算两个半径分别为 $r_w(x)$ 和 $R_d$、中心距为 $d=y$ 的圆的几何相交面积 $A_{\\cap}$。使用精确的欧几里得几何处理所有几何构型，包括无重叠（$A_{\\cap} = 0$）、小圆被完全覆盖、部分重叠、外切和内切。\n4. 计算 $A_{\\text{impacted}} = A_{\\cap}$（单位为平方米）和 $U_{\\text{avg}}$（通过对下游转子盘上的环境速度和尾流速度进行面积加权混合）。\n5. 将每个 $A_{\\text{impacted}}$ 和 $U_{\\text{avg}}$ 四舍五入到六位小数。\n\n测试套件：\n为以下四个测试用例实现你的解决方案，这些用例共同探讨了典型配置、完全覆盖、无重叠和精确外切的情况：\n- 情况 1：$D_u = 100\\,\\mathrm{m}$, $D_d = 100\\,\\mathrm{m}$, $x = 500\\,\\mathrm{m}$, $y = 20\\,\\mathrm{m}$, $k_w = 0.05$, $U_\\infty = 8\\,\\mathrm{m/s}$, $C_T = 0.8$。\n- 情况 2：$D_u = 100\\,\\mathrm{m}$, $D_d = 80\\,\\mathrm{m}$, $x = 600\\,\\mathrm{m}$, $y = 0\\,\\mathrm{m}$, $k_w = 0.1$, $U_\\infty = 10\\,\\mathrm{m/s}$, $C_T = 0.75$。\n- 情况 3：$D_u = 100\\,\\mathrm{m}$, $D_d = 100\\,\\mathrm{m}$, $x = 400\\,\\mathrm{m}$, $y = 200\\,\\mathrm{m}$, $k_w = 0.04$, $U_\\infty = 9\\,\\mathrm{m/s}$, $C_T = 0.9$。\n- 情况 4：$D_u = 120\\,\\mathrm{m}$, $D_d = 90\\,\\mathrm{m}$, $x = 300\\,\\mathrm{m}$, $y = 123\\,\\mathrm{m}$, $k_w = 0.06$, $U_\\infty = 7\\,\\mathrm{m/s}$, $C_T = 0.7$。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个由四个双元素列表组成的列表，按测试用例的顺序排列，每个双元素列表为 $[A_{\\text{impacted}}, U_{\\text{avg}}]$，两个浮点数均四舍五入到六位小数。\n- 确切格式必须是：`[[A_1,U_1],[A_2,U_2],[A_3,U_3],[A_4,U_4]]`，使用十进制表示法，不带单位，也无附加文本。例如，一个有效的输出行看起来像 `[[1234.567890,7.654321],[...],[...],[...]]`。",
            "solution": "该问题被评估为有效。它在科学上基于已建立的用于风力涡轮机尾流的 Park (Jensen) 模型，这是一个基于守恒定律的标准简化。该问题是适定的，为获得唯一解提供了所有必要的数据和定义。语言客观，任务规定明确无歧义。\n\n解决方案是通过实现问题陈述中指定的四个算法任务来开发的，每一步都基于所要求的第一性原理。\n\n**1. 尾流半径，$r_w(x)$**\n\nPark 模型假设涡轮机尾流随下游距离 $x$ 线性扩展。尾流被建模为一个圆形横截面，其半径 $r_w(x)$ 从初始值（上游转子半径 $R_u$）开始，根据尾流扩展系数 $k_w$ 增长。\n\n在距离 $x$ 处的尾流半径公式为：\n$$r_w(x) = R_u + k_w x$$\n其中 $R_u = D_u/2$ 是上游转子半径。这种线性扩展是用于模拟环境空气湍流夹带入尾流的经验模型。\n\n**2. 速度亏损，$\\Delta(x)$**\n\n尾流内的速度亏损源于动量守恒，它将涡轮机施加的推力与下游流中的动量亏损联系起来。\n\n根据致动盘理论，推力 $T$ 由下式给出 $T = \\frac{1}{2}\\rho A_u C_T U_\\infty^2$，其中 $\\rho$ 是空气密度，$A_u = \\pi R_u^2$ 是转子面积，$C_T$ 是推力系数，$U_\\infty$ 是环境风速。\n\n推力也是赋予空气的动量变化率。在一维动量理论中，远尾流速度 $U_{w, \\text{far}}$ 通过 $U_{w, \\text{far}} = U_\\infty(1-2a)$ 与轴向诱导因子 $a$ 相关。推力系数为 $C_T = 4a(1-a)$。假设涡轮机在风车状态（$a  1/2$）下运行，我们可以解出 $2a$：\n$$1-C_T = (1-2a)^2 \\implies \\sqrt{1-C_T} = 1-2a \\implies 2a = 1 - \\sqrt{1-C_T}$$\n远尾流中相对于环境速度的速度亏损为 $\\Delta U_{\\text{far}} = U_\\infty - U_{w, \\text{far}} = 2aU_\\infty$。因此，初始亏损比为 $2a$。\n\nPark 模型假设当尾流扩展时，该动量亏损是守恒的。在下游距离 $x$ 处的动量通量亏损被假设为与尾流面积 $A_w(x) = \\pi r_w(x)^2$ 和局部速度亏损 $U_\\infty - U_w(x)$ 成正比。通过守恒动量亏损：\n$$(U_\\infty - U_w(x)) A_w(x) \\propto (U_\\infty - U_{w, \\text{far}}) A_u$$\n这导致在距离 $x$ 处速度亏损 $\\Delta U(x) = U_\\infty - U_w(x)$ 随初始亏损和面积比进行缩放：\n$$\\Delta U(x) = (2a U_\\infty) \\frac{A_u}{A_w(x)}$$\n除以 $U_\\infty$ 得到无量纲亏损比 $\\Delta(x)$：\n$$\\Delta(x) = \\frac{U_\\infty - U_w(x)}{U_\\infty} = (2a) \\frac{\\pi R_u^2}{\\pi r_w(x)^2} = (1 - \\sqrt{1-C_T}) \\left(\\frac{R_u}{r_w(x)}\\right)^2$$\n代入 $r_w(x) = R_u + k_w x$：\n$$\\Delta(x) = \\frac{1 - \\sqrt{1-C_T}}{(1 + k_w x / R_u)^2}$$\n那么在距离 $x$ 处的尾流内部速度为 $U_w(x) = U_\\infty(1 - \\Delta(x))$。\n\n**3. 相交面积，$A_{\\cap}$**\n\n下游转子的受影响面积是两个圆的几何相交区域：半径为 $r_1 = r_w(x)$ 的尾流圆和半径为 $r_2 = R_d = D_d/2$ 的下游转子圆。它们中心之间的距离是 $d=y$。\n\n计算过程通过考虑三种不同的几何情况进行：\na. **无重叠**：如果圆心距大于或等于半径之和，则两圆不相交或外切。\n$$d \\ge r_1 + r_2 \\implies A_{\\cap} = 0$$\nb. **完全包含**：如果圆心距小于或等于半径之差的绝对值，则较小的圆完全包含在较大的圆内（或它们内切）。\n$$d \\le |r_1 - r_2| \\implies A_{\\cap} = \\pi (\\min(r_1, r_2))^2$$\nc. **部分重叠**：如果 $|r_1 - r_2|  d  r_1 + r_2$，则两圆部分相交。相交面积是两圆公共弦所形成的两个弓形面积之和。\n\n一个弓形的面积等于其对应的扇形面积减去由半径和弦组成的三角形的面积。对于一个半径为 $r$ 的圆和一个由中心角 $\\theta$（弧度）定义的弓形，其面积为 $A_{\\text{seg}} = \\frac{1}{2}r^2(\\theta - \\sin\\theta)$。\n\n每个圆中弓形的中心角 $\\theta_1$ 和 $\\theta_2$ 可以使用余弦定理求得。考虑由两个圆心和一个交点形成的三角形。其边长为 $r_1$、$r_2$ 和 $d$。在圆心处的半角为：\n$$\\alpha_1 = \\text{arccos}\\left(\\frac{d^2 + r_1^2 - r_2^2}{2 d r_1}\\right)$$\n$$\\alpha_2 = \\text{arccos}\\left(\\frac{d^2 + r_2^2 - r_1^2}{2 d r_2}\\right)$$\n完整的中心角为 $\\theta_1 = 2\\alpha_1$ 和 $\\theta_2 = 2\\alpha_2$。总相交面积是两个弓形面积之和：\n$$A_{\\cap} = A_{\\text{seg},1} + A_{\\text{seg},2} = \\frac{1}{2}r_1^2(\\theta_1 - \\sin\\theta_1) + \\frac{1}{2}r_2^2(\\theta_2 - \\sin\\theta_2)$$\n该公式稳健地计算了部分重叠情况下的相交面积。最终的影响面积为 $A_{\\text{impacted}} = A_{\\cap}$。\n\n**4. 平均风速，$U_{\\text{avg}}$**\n\n下游涡轮机处的转子平均风速 $U_{\\text{avg}}$ 是其转子盘面积 $A_d = \\pi R_d^2$ 上风速的面积加权平均值。盘面在尾流内的部分 $A_{\\cap}$ 经历尾流速度 $U_w(x)$，而尾流外的部分 $A_d - A_{\\cap}$ 经历环境速度 $U_\\infty$。\n\n加权平均值为：\n$$U_{\\text{avg}} = \\frac{U_w(x) \\cdot A_{\\cap} + U_\\infty \\cdot (A_d - A_{\\cap})}{A_d}$$\n代入 $U_w(x) = U_\\infty(1 - \\Delta(x))$：\n$$U_{\\text{avg}} = \\frac{U_\\infty(1 - \\Delta(x)) A_{\\cap} + U_\\infty A_d - U_\\infty A_{\\cap}}{A_d}$$\n$$U_{\\text{avg}} = \\frac{U_\\infty A_d - U_\\infty \\Delta(x) A_{\\cap}}{A_d}$$\n简化后得到最终表达式：\n$$U_{\\text{avg}} = U_\\infty \\left(1 - \\Delta(x) \\frac{A_{\\cap}}{A_d}\\right)$$\n该公式用于计算面积加权平均风速。在下游转子面积 $A_d$ 为零的情况下，面积平均速度没有明确定义。然而，由于所有测试用例都具有物理转子（$D_d > 0$），这种退化情况不会出现。\n\n根据这些原理构建的算法现在将用于解决给定的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Models the wake overlap for two wind turbines using the Park (Jensen) model.\n    Calculates the impacted downstream rotor area and the area-weighted average wind speed.\n    \"\"\"\n\n    def calculate_wake_effects(Du, Dd, x, y, kw, U_inf, CT):\n        \"\"\"\n        Computes wake effects for a single turbine pair configuration.\n\n        Args:\n            Du (float): Upstream rotor diameter (m).\n            Dd (float): Downstream rotor diameter (m).\n            x (float): Streamwise spacing between turbines (m).\n            y (float): Lateral offset between turbine centers (m).\n            kw (float): Wake expansion coefficient.\n            U_inf (float): Ambient inflow wind speed (m/s).\n            CT (float): Upstream turbine thrust coefficient.\n\n        Returns:\n            list: A list containing [A_impacted, U_avg], rounded to 6 decimal places.\n        \"\"\"\n\n        # Step 1: Compute radii and wake radius\n        Ru = Du / 2.0\n        Rd = Dd / 2.0\n        \n        # The wake does not exist at or before the turbine\n        if x = 0:\n            A_impacted = 0.0\n            U_avg = U_inf\n            return [round(A_impacted, 6), round(U_avg, 6)]\n\n        r_w = kw * x + Ru\n\n        # Step 2: Compute velocity deficit ratio\n        # The term (1 + kw * x / Ru) is equivalent to r_w / Ru.\n        # Check for Ru > 0 to avoid division by zero.\n        if Ru > 0:\n            deficit_ratio_factor = (r_w / Ru)**2\n            deficit_ratio = (1 - np.sqrt(1 - CT)) / deficit_ratio_factor\n        else: # If upstream turbine has no size, it creates no wake.\n            deficit_ratio = 0.0\n\n        # Step 3: Compute geometric intersection area (A_impacted)\n        A_impacted = calculate_intersection_area(r_w, Rd, y)\n\n        # Step 4: Compute area-weighted average wind speed\n        A_d = np.pi * Rd**2\n        \n        if A_d > 0:\n            U_avg = U_inf * (1 - deficit_ratio * (A_impacted / A_d))\n        else:\n            # For a zero-area downstream rotor, the concept of area-average is\n            # ill-defined. We can find the point velocity at its center.\n            if abs(y)  r_w: # Point is inside the wake\n                U_avg = U_inf * (1 - deficit_ratio)\n            else: # Point is outside the wake\n                U_avg = U_inf\n\n        return [round(A_impacted, 6), round(U_avg, 6)]\n\n    def calculate_intersection_area(r1, r2, d):\n        \"\"\"\n        Calculates the intersection area of two circles.\n\n        Args:\n            r1 (float): Radius of the first circle.\n            r2 (float): Radius of the second circle.\n            d (float): Distance between the centers of the circles.\n\n        Returns:\n            float: The intersection area.\n        \"\"\"\n        d = abs(float(d))\n        r1, r2 = float(r1), float(r2)\n\n        if r1 = 0 or r2 = 0:\n            return 0.0\n\n        # Case 1: No overlap or external tangency\n        if d >= r1 + r2:\n            return 0.0\n\n        # Case 2: Full containment or internal tangency\n        if d = abs(r1 - r2):\n            return np.pi * min(r1, r2)**2\n\n        # Case 3: Partial overlap\n        r1_sq, r2_sq, d_sq = r1**2, r2**2, d**2\n\n        # Arguments for arccos based on law of cosines\n        # Clip to handle potential floating point inaccuracies near +/-1\n        cos_alpha1_arg = np.clip((d_sq + r1_sq - r2_sq) / (2 * d * r1), -1.0, 1.0)\n        cos_alpha2_arg = np.clip((d_sq + r2_sq - r1_sq) / (2 * d * r2), -1.0, 1.0)\n        \n        # Central angles for the segments\n        theta1 = 2 * np.arccos(cos_alpha1_arg)\n        theta2 = 2 * np.arccos(cos_alpha2_arg)\n\n        # Area of circular segments\n        area_seg1 = 0.5 * r1_sq * (theta1 - np.sin(theta1))\n        area_seg2 = 0.5 * r2_sq * (theta2 - np.sin(theta2))\n        \n        return area_seg1 + area_seg2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Typical configuration with partial overlap (actually full coverage)\n        (100.0, 100.0, 500.0, 20.0, 0.05, 8.0, 0.8),\n        # Case 2: Full coverage (concentric)\n        (100.0, 80.0, 600.0, 0.0, 0.1, 10.0, 0.75),\n        # Case 3: No overlap\n        (100.0, 100.0, 400.0, 200.0, 0.04, 9.0, 0.9),\n        # Case 4: Exact external tangency\n        (120.0, 90.0, 300.0, 123.0, 0.06, 7.0, 0.7),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_wake_effects(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Convert each inner list to its string representation and join with commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了被动建模，风能领域一个激动人心的前沿是主动控制尾流以提高整个风电场的效率。本练习  深入探讨了“尾流转向”的概念，即有意地让上游涡轮机与风向偏航以使其尾流偏转。通过解决这个问题，您将看到如何利用尾流行为的物理模型来设计和量化现代风电场的先进控制策略。",
            "id": "4136836",
            "problem": "给定一个场景，其中有两台对齐的水平轴风力发电机处于均匀入流中。上游风力发电机被刻意偏航一个角度，以横向偏转其尾流，从而在指定的下游距离处，尾流中心线至少达到一个要求的横向偏移量。您的任务是根据基本原理推导出一个显式算法，用于计算实现所需下游尾流偏移的最小偏航角，然后使用标准的余弦模型量化由偏航引起的功率损失。您必须将该算法实现为一个完整的程序，评估几组参数集并生成单行结果列表。\n\n从以下基本原理和建模假设出发，每个都应作为您推导的起点：\n\n- 围绕尾流的稳态控制体中流向和横向动量的守恒，其中尾流中的横向动量源于风轮偏航产生的横向力。假设推力大小与流向推力系数和自由来流速度相关。\n- 上游风力发电机的风轮半径为 $R$，风轮扫掠面积为 $A = \\pi R^2$，相对于来流风向偏航角度为 $\\gamma$，在自由来流速度 $U_{\\infty}$ 下以推力系数 $C_T$ 运行。取推力大小为 $T = \\tfrac{1}{2} \\rho A U_{\\infty}^2 C_T$，其横向分量为 $F_y = T \\sin{\\gamma}$，其中 $\\rho$ 是空气密度（您可以假设 $\\rho$ 在推导中被抵消，因此不需要数值）。\n- 将尾流横截面建模为半径为 $r(x)$ 的顶帽（top-hat）模型，该半径沿下游线性扩张：$r(x) = R + k x$，其中 $k$ 是一个恒定的尾流扩张系数，$x$ 是距风力发电机的下游距离。\n- 将尾流中心线的对流输运速度建模为 $U_{\\infty}$，尾流横截面中的质量流量建模为 $\\dot{m}(x) = \\rho U_{\\infty} \\pi r(x)^2$。将在下游距离 $x$ 处的尾流横截面的平均横向速度建模为 $v_y(x) = F_y / \\dot{m}(x)$。\n- 在几何上，尾流中心线偏转满足 $\\mathrm{d}y_w/\\mathrm{d}x = v_y(x)/U_{\\infty}$，且 $y_w(0) = 0$。\n\n仅使用这些基本关系以及标准微积分和三角学，推导出尾流中心线横向位置 $y_w(x)$ 作为 $x$、$R$、$k$、$C_T$ 和 $\\gamma$ 的函数的显式表达式。然后，给定在下游位置 $x = x_d$ 的特定目标横向偏移 $y_{\\mathrm{target}}$，定义最小偏航角 $\\gamma^\\star$，使其在最大允许偏航角限制 $0 \\le \\gamma \\le \\gamma_{\\max}$ 的约束下实现 $y_w(x_d) \\ge y_{\\mathrm{target}}$。如果 $y_{\\mathrm{target}}$ 在限制内无法达到，则设置 $\\gamma^\\star = \\gamma_{\\max}$。将上游风力发电机由偏航引起的相对功率表示为 $P_{\\mathrm{rel}} = \\cos^p(\\gamma^\\star)$，其中 $p$ 是给定的正指数。\n\n您的程序必须实现上述推导，为每个参数集计算由最小偏航角（以度为单位）和相应相对功率组成的数对。在内部进行三角函数计算时使用弧度，但报告的偏航角必须以度为单位。所有距离必须以米为单位。每个测试用例的最终输出必须是一个双元素列表 $[\\gamma^\\star_{\\mathrm{deg}}, P_{\\mathrm{rel}}]$，其中 $\\gamma^\\star_{\\mathrm{deg}}$ 以度为单位，$P_{\\mathrm{rel}}$ 是无量纲的。报告的两个数字都必须四舍五入到四位小数。\n\n测试套件。使用以下四个参数集，每个参数集指定为一个元组 $(D, C_T, k, x_d, y_{\\mathrm{target}}, p, \\gamma_{\\max,\\mathrm{deg}})$，其中 $D$ 是直径（米），$R = D/2$，$C_T$ 无量纲，$k$ 无量纲，$x_d$ 以米为单位，$y_{\\mathrm{target}}$ 以米为单位，$p$ 无量纲，$\\gamma_{\\max,\\mathrm{deg}}$ 以度为单位：\n\n- 情况 A: $(120, 0.8, 0.05, 600, 20, 2.0, 30)$。\n- 情况 B: $(150, 0.9, 0.04, 750, 150, 1.88, 30)$。\n- 情况 C: $(100, 0.75, 0.06, 400, 0, 2.1, 30)$。\n- 情况 D: $(120, 0.8, 0.1, 50, 10, 2.0, 25)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，本身是一个形如 $[\\gamma^\\star_{\\mathrm{deg}}, P_{\\mathrm{rel}}]$ 的双元素列表。例如，该字符串应类似于 $[[a_1,b_1],[a_2,b_2],[a_3,b_3],[a_4,b_4]]$，不含多余的空格或文本。所有角度必须以度表示，四舍五入到四位小数，所有相对功率也必须四舍五入到四位小数。",
            "solution": "该问题陈述已经过验证，并被确定为风能系统建模领域中一个有效、良定且具有科学依据的问题。所有必要的数据、模型和约束都已提供，以推导出唯一且有意义的解。\n\n求解过程分两个阶段进行。首先，根据所提供的基本原理，推导出尾流中心线偏转 $y_w(x)$ 的显式解析表达式。其次，利用此表达式制定一个算法，用于计算所需的最小偏航角 $\\gamma^\\star$ 及相关的相对功率 $P_{\\mathrm{rel}}$。\n\n**1. 尾流中心线偏转的推导**\n\n尾流中心线横向位置 $y_w$ 的演变由以下微分方程控制：\n$$\n\\frac{\\mathrm{d}y_w}{\\mathrm{d}x} = \\frac{v_y(x)}{U_{\\infty}}\n$$\n初始条件为 $y_w(0) = 0$。此处，$v_y(x)$ 是尾流在下游距离 $x$ 处的平均横向速度，$U_{\\infty}$ 是自由来流风速。\n\n横向速度 $v_y(x)$ 由动量平衡确定，即偏航的风力发电机施加的横向力 $F_y$ 与通过该位置尾流横截面的质量流率 $\\dot{m}(x)$ 之比：\n$$\nv_y(x) = \\frac{F_y}{\\dot{m}(x)}\n$$\n问题中指定了 $F_y$ 和 $\\dot{m}(x)$ 的模型。横向力是总推力 $T$ 垂直于来流风向的分量：\n$$\nF_y = T \\sin{\\gamma} = \\left( \\frac{1}{2} \\rho A U_{\\infty}^2 C_T \\right) \\sin{\\gamma}\n$$\n其中 $\\rho$ 是空气密度，$A = \\pi R^2$ 是风轮面积，$R$ 是风轮半径，$C_T$ 是推力系数，$\\gamma$ 是偏航角。\n\n质量流率的建模假设为，在扩张半径为 $r(x)$ 的尾流上，存在一个速度为 $U_{\\infty}$ 的顶帽（top-hat）速度剖面：\n$$\n\\dot{m}(x) = \\rho U_{\\infty} \\pi r(x)^2\n$$\n尾流半径随距离 $x$ 线性扩张，遵循 $r(x) = R + kx$，其中 $k$ 是尾流扩张系数。\n\n将这些表达式代入 $v_y(x)$ 的方程中：\n$$\nv_y(x) = \\frac{\\frac{1}{2} \\rho (\\pi R^2) U_{\\infty}^2 C_T \\sin{\\gamma}}{\\rho U_{\\infty} \\pi (R+kx)^2} = \\frac{R^2 U_{\\infty} C_T \\sin{\\gamma}}{2(R+kx)^2}\n$$\n现在，我们将此结果代回 $y_w$ 的控制微分方程中：\n$$\n\\frac{\\mathrm{d}y_w}{\\mathrm{d}x} = \\frac{1}{U_{\\infty}} \\left( \\frac{R^2 U_{\\infty} C_T \\sin{\\gamma}}{2(R+kx)^2} \\right) = \\frac{R^2 C_T \\sin{\\gamma}}{2(R+kx)^2}\n$$\n如问题所述，空气密度 $\\rho$ 和自由来流速度 $U_{\\infty}$ 均从最终的微分方程中消去。\n\n为了求得尾流中心线位置 $y_w(x)$，我们利用初始条件 $y_w(0) = 0$，将此方程从风力发电机位置（$x=0$）积分到下游距离 $x$：\n$$\ny_w(x) = \\int_{0}^{x} \\frac{R^2 C_T \\sin{\\gamma}}{2(R+k\\xi)^2} \\mathrm{d}\\xi\n$$\n相对于积分变量 $\\xi$ 为常数的项可以移到积分号外：\n$$\ny_w(x) = \\frac{R^2 C_T \\sin{\\gamma}}{2} \\int_{0}^{x} (R+k\\xi)^{-2} \\mathrm{d}\\xi\n$$\n该积分的计算结果为：\n$$\n\\int_{0}^{x} (R+k\\xi)^{-2} \\mathrm{d}\\xi = \\left[ -\\frac{1}{k} (R+k\\xi)^{-1} \\right]_0^x = -\\frac{1}{k} \\left( \\frac{1}{R+kx} - \\frac{1}{R} \\right)\n$$\n合并括号内的项：\n$$\n-\\frac{1}{k} \\left( \\frac{R - (R+kx)}{R(R+kx)} \\right) = -\\frac{1}{k} \\left( \\frac{-kx}{R(R+kx)} \\right) = \\frac{x}{R(R+kx)}\n$$\n将此结果代回 $y_w(x)$ 的表达式中：\n$$\ny_w(x) = \\frac{R^2 C_T \\sin{\\gamma}}{2} \\left( \\frac{x}{R(R+kx)} \\right)\n$$\n简化后得到尾流中心线偏转的最终解析表达式：\n$$\ny_w(x) = \\frac{R C_T x \\sin{\\gamma}}{2(R+kx)}\n$$\n\n**2. 最小偏航角和相对功率的算法**\n\n目标是找到最小偏航角 $\\gamma^\\star$，使得在特定下游距离 $x_d$ 处，尾流偏转至少达到目标值 $y_{\\mathrm{target}}$，即 $y_w(x_d) \\ge y_{\\mathrm{target}}$。偏航角受约束于 $0 \\le \\gamma \\le \\gamma_{\\max}$。\n\n我们从不等式开始：\n$$\n\\frac{R C_T x_d \\sin{\\gamma}}{2(R+kx_d)} \\ge y_{\\mathrm{target}}\n$$\n对于非负的 $\\gamma$，函数 $\\sin(\\gamma)$ 在我们关注的范围内（最大到 $\\gamma_{\\max} \\le 90^\\circ$）是非递减的。为求得最小的 $\\gamma$，我们求解等式：\n$$\n\\sin{\\gamma} = \\frac{2 y_{\\mathrm{target}} (R+kx_d)}{R C_T x_d}\n$$\n我们将等式右侧定义为所需的正弦值 $S$：\n$$\nS = \\frac{2 y_{\\mathrm{target}} (R+kx_d)}{R C_T x_d}\n$$\n所需的偏航角（以弧度为单位）$\\gamma_{\\mathrm{req}}$ 将是 $\\arcsin(S)$。现在我们必须考虑所有约束。\n\n确定最优偏航角 $\\gamma^\\star$ 的算法如下：\n1.  如果 $y_{\\mathrm{target}} \\le 0$，则零偏转即可满足条件 $y_w(x_d) \\ge y_{\\mathrm{target}}$。由于我们寻求最小的非负偏航角，因此 $\\gamma^\\star = 0$。\n2.  如果 $y_{\\mathrm{target}} > 0$，我们计算 $S$ 的值。\n    a. 如果 $S > \\sin(\\gamma_{\\max})$，所需的偏航角超过了最大允许偏航角 $\\gamma_{\\max}$（此情况也包括了 $S>1$ 的物理不可能性）。根据问题要求，如果目标在限制内无法达到，我们必须将偏航角设置为其最大值。因此，$\\gamma^\\star = \\gamma_{\\max}$。\n    b. 如果 $0  S \\le \\sin(\\gamma_{\\max})$，目标在偏航限制内是可达到的。所需的最小偏航角为 $\\gamma^\\star = \\arcsin(S)$。\n\n这个逻辑可以通过计算所需角度 $\\gamma_{\\mathrm{req}} = \\arcsin(S)$，然后将其裁剪到有效范围 $[0, \\gamma_{\\max}]$ 来紧凑地实现。必须注意 $S > 1$ 的情况，此时 $\\arcsin$ 未定义。一个鲁棒的实现会在应用 $\\arcsin$ 之前将参数 $S$ 裁剪到定义域 $[-1, 1]$ 内。\n\n最终的计算步骤如下：\n1.  给定输入参数 $(D, C_T, k, x_d, y_{\\mathrm{target}}, p, \\gamma_{\\max,\\mathrm{deg}})$，计算 $R = D/2$ 并将 $\\gamma_{\\max,\\mathrm{deg}}$ 转换为弧度 $\\gamma_{\\max,\\mathrm{rad}}$。\n2.  如果 $y_{\\mathrm{target}} \\le 0$，设置 $\\gamma^\\star_{\\mathrm{rad}} = 0$。\n3.  如果 $y_{\\mathrm{target}} > 0$，计算 $S = \\frac{2 y_{\\mathrm{target}} (R+kx_d)}{R C_T x_d}$。\n    - 如果 $S > \\sin(\\gamma_{\\max,\\mathrm{rad}})$，设置 $\\gamma^\\star_{\\mathrm{rad}} = \\gamma_{\\max,\\mathrm{rad}}$。\n    - 否则，设置 $\\gamma^\\star_{\\mathrm{rad}} = \\arcsin(S)$。\n4.  将最终的偏航角转换为度：$\\gamma^\\star_{\\mathrm{deg}} = \\gamma^\\star_{\\mathrm{rad}} \\cdot 180/\\pi$。\n5.  使用求得的偏航角（以弧度为单位）计算相对功率：$P_{\\mathrm{rel}} = \\cos^p(\\gamma^\\star_{\\mathrm{rad}})$。\n6.  返回四舍五入到四位小数的数对 $[\\gamma^\\star_{\\mathrm{deg}}, P_{\\mathrm{rel}}]$。\n\n此程序正确处理了所有指定的情况和约束。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the minimum yaw angle and corresponding relative power\n    for a series of wind turbine wake steering scenarios.\n    \"\"\"\n\n    # Test cases: (D, C_T, k, x_d, y_target, p, gamma_max_deg)\n    test_cases = [\n        (120, 0.8, 0.05, 600, 20, 2.0, 30),   # Case A\n        (150, 0.9, 0.04, 750, 150, 1.88, 30), # Case B\n        (100, 0.75, 0.06, 400, 0, 2.1, 30),   # Case C\n        (120, 0.8, 0.1, 50, 10, 2.0, 25),      # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        D, C_T, k, x_d, y_target, p, gamma_max_deg = case\n\n        R = D / 2.0\n        gamma_max_rad = np.deg2rad(gamma_max_deg)\n        \n        gamma_star_rad = 0.0\n\n        if y_target > 0:\n            # Denominator of the sine argument S\n            denominator = R * C_T * x_d\n            \n            # This check avoids division by zero, although not expected with problem data\n            if denominator > 1e-9:\n                # Calculate S, the required sine value\n                numerator = 2.0 * y_target * (R + k * x_d)\n                sin_arg = numerator / denominator\n                \n                # Check if the required angle is within the maximum yaw constraint\n                # Also handles the sin_arg > 1 case implicitly\n                if sin_arg > np.sin(gamma_max_rad):\n                    # Target is unreachable within the bound, or physically impossible.\n                    # As per problem, set yaw to max.\n                    gamma_star_rad = gamma_max_rad\n                else:\n                    # Target is reachable. Calculate the minimum required angle.\n                    gamma_star_rad = np.arcsin(sin_arg)\n            else:\n                # Physically unable to generate lateral force (e.g., CT=0). \n                # If y_target > 0, we must use the max yaw.\n                gamma_star_rad = gamma_max_rad\n        else:\n            # If y_target = 0, no yaw is needed to meet the condition.\n            gamma_star_rad = 0.0\n\n        # Convert final yaw angle to degrees\n        gamma_star_deg = np.rad2deg(gamma_star_rad)\n\n        # Calculate relative power using yaw angle in radians\n        P_rel = np.power(np.cos(gamma_star_rad), p)\n\n        # Format results as [angle_deg, power_rel] with 4 decimal places\n        # Using f-string formatting for precise output.\n        formatted_gamma = f\"{gamma_star_deg:.4f}\"\n        formatted_P_rel = f\"{P_rel:.4f}\"\n        \n        # Append as a raw string to control the final output format precisely\n        results.append(f\"[{formatted_gamma},{formatted_P_rel}]\")\n\n    # Final print statement in the exact required format: [[a1,b1],[a2,b2],...]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}