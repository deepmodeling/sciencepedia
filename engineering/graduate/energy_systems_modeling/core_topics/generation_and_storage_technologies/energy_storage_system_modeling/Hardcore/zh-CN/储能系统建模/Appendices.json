{
    "hands_on_practices": [
        {
            "introduction": "抽水蓄能是电网规模储能的基石技术之一。要准确评估其在能源系统中的作用和经济性，关键在于深刻理解其能量转换过程中的效率。本练习将引导您从流体力学和机械能守恒的第一性原理出发，建立一个完整的抽水蓄能系统效率模型。通过这项实践，您不仅将计算一个具体场景下的往返效率，更将掌握如何量化分析大型机电储能系统中的能量损失，这是一项在各类能源系统建模中都至关重要的核心能力 。",
            "id": "4090291",
            "problem": "一个抽水蓄能设施通过一根横截面为常数圆形的笔直钢制压力管道连接一个上水库和一个下水库。水库具有较大的自由表面，因此水库处的速度水头可以忽略不计。两个水库自由表面之间的总静高差为 $H = 120 \\ \\mathrm{m}$。压力钢管的长度为 $L = 800 \\ \\mathrm{m}$，内径为 $D = 4 \\ \\mathrm{m}$。发电期间，体积流量为 $Q_{\\mathrm{gen}} = 50 \\ \\mathrm{m^3/s}$，持续时间为 $T_{\\mathrm{gen}} = 6 \\ \\mathrm{h}$；抽水期间，流量为 $Q_{\\mathrm{pump}} = 45 \\ \\mathrm{m^3/s}$，抽水过程持续到上水库恢复到其初始高程。流体为水，模型为不可压缩流体，密度 $\\rho = 1000 \\ \\mathrm{kg/m^3}$。取重力加速度 $g = 9.81 \\ \\mathrm{m/s^2}$。假设水力损失参数与方向有关：发电期间，达西-魏斯巴赫摩擦系数为 $f_{\\mathrm{gen}} = 0.018$，局部损失系数之和为 $K_{\\mathrm{gen}} = 2.0$；抽水期间，$f_{\\mathrm{pump}} = 0.020$，$K_{\\mathrm{pump}} = 2.5$。涡轮机的水力效率为 $\\eta_{\\mathrm{turb,h}} = 0.92$，发电机的机电效率为 $\\eta_{\\mathrm{e,gen}} = 0.98$。水泵的水力效率为 $\\eta_{\\mathrm{pump,h}} = 0.88$，电动机的机电效率为 $\\eta_{\\mathrm{motor}} = 0.96$。忽略大气压力差、空化极限、浪涌现象以及除静水头 $H$ 中隐含的高程变化外的任何压力钢管高程变化。\n\n从不可压缩流动的机械能平衡第一性原理和重力势能的定义出发，推导将一定体积的流体提升静水头高度所储存的重力势能表达式，然后为该抽水蓄能系统建立包含水力损失和转换效率的往返能量平衡。使用给定数据，计算往返效率（RTE），其定义为当抽水体积恰好使上水库恢复到其初始高程时，发电产生的电能与抽水消耗的电能之比。\n\n将最终的RTE表示为无量纲的小数，并将答案四舍五入到四位有效数字。",
            "solution": "该问题要求推导抽水蓄能系统的往返效率（RTE）并根据所提供的数据进行计算。解决方案分三个阶段进行：势能公式的初步推导，系统能量平衡的建立，以及RTE的数值计算。\n\n首先，我们推导提升一定体积流体所储存的重力势能 $E_p$ 的表达式。将质量为 $m$ 的物体在重力（加速度为 $g$）作用下沿竖直高度 $H$ 提升所做的功 $W$ 储存为势能。\n$$ W = \\text{力} \\times \\text{距离} = (mg)H $$\n因此，势能为 $E_p = mgH$。对于密度为 $\\rho$、体积为 $V$ 的流体，其质量为 $m = \\rho V$。将此代入能量表达式可得：\n$$ E_p = \\rho g V H $$\n\n接下来，我们建立往返能量平衡。RTE 定义为发电期间产生的电能 $E_{\\mathrm{elec,gen}}$ 与为使系统恢复初始状态而抽水消耗的电能 $E_{\\mathrm{elec,pump}}$ 之比。\n$$ \\mathrm{RTE} = \\frac{E_{\\mathrm{elec,gen}}}{E_{\\mathrm{elec,pump}}} $$\n\n**发电模式分析**\n我们对上水库表面（点1）和下水库表面（点2）之间的不可压缩流体应用机械能平衡（推广的伯努利方程）：\n$$ \\frac{P_1}{\\rho g} + \\frac{v_1^2}{2g} + z_1 = \\frac{P_2}{\\rho g} + \\frac{v_2^2}{2g} + z_2 + H_{\\mathrm{turb}} + h_{L,\\mathrm{gen}} $$\n此处，$P$ 是压力，$v$ 是速度，$z$ 是高程，$H_{\\mathrm{turb}}$ 是涡轮机提取的水头，$h_{L,\\mathrm{gen}}$ 是总水力水头损失。鉴于水库很大（$v_1 \\approx 0, v_2 \\approx 0$）且对大气开放（$P_1 = P_2$），并且静水头为 $H = z_1 - z_2$，方程简化为 $H = H_{\\mathrm{turb}} + h_{L,\\mathrm{gen}}$。\n输送给涡轮机的净水头为 $H_{\\mathrm{net,gen}} = H_{\\mathrm{turb}} = H - h_{L,\\mathrm{gen}}$。从水流中提取的水力功率为：\n$$ P_{\\mathrm{hyd,gen}} = \\rho g Q_{\\mathrm{gen}} H_{\\mathrm{net,gen}} = \\rho g Q_{\\mathrm{gen}} (H - h_{L,\\mathrm{gen}}) $$\n该水力功率以 $\\eta_{\\mathrm{turb,h}} \\eta_{\\mathrm{e,gen}}$ 的组合效率转换为电功率：\n$$ P_{\\mathrm{elec,gen}} = \\eta_{\\mathrm{turb,h}} \\eta_{\\mathrm{e,gen}} P_{\\mathrm{hyd,gen}} $$\n在持续时间 $T_{\\mathrm{gen}}$ 内产生的总能量为 $E_{\\mathrm{elec,gen}} = P_{\\mathrm{elec,gen}} T_{\\mathrm{gen}}$。\n\n**抽水模式分析**\n抽水期间，下水库（点2）和上水库（点1）之间的能量平衡包括由水泵增加的水头 $H_{\\mathrm{pump}}$：\n$$ \\frac{P_2}{\\rho g} + \\frac{v_2^2}{2g} + z_2 + H_{\\mathrm{pump}} = \\frac{P_1}{\\rho g} + \\frac{v_1^2}{2g} + z_1 + h_{L,\\mathrm{pump}} $$\n在相同假设下，可得 $H_{\\mathrm{pump}} = (z_1 - z_2) + h_{L,\\mathrm{pump}} = H + h_{L,\\mathrm{pump}}$。这是水泵必须克服的总动水头。输送给水的水力功率为：\n$$ P_{\\mathrm{hyd,pump}} = \\rho g Q_{\\mathrm{pump}} H_{\\mathrm{pump}} = \\rho g Q_{\\mathrm{pump}} (H + h_{L,\\mathrm{pump}}) $$\n电机-水泵机组消耗的电功率，其组合效率为 $\\eta_{\\mathrm{pump,h}} \\eta_{\\mathrm{motor}}$，为：\n$$ P_{\\mathrm{elec,pump}} = \\frac{P_{\\mathrm{hyd,pump}}}{\\eta_{\\mathrm{pump,h}} \\eta_{\\mathrm{motor}}} $$\n为了回抽在发电期间排出的水量 $V = Q_{\\mathrm{gen}} T_{\\mathrm{gen}}$，抽水持续时间必须为 $T_{\\mathrm{pump}} = V / Q_{\\mathrm{pump}} = (Q_{\\mathrm{gen}} T_{\\mathrm{gen}}) / Q_{\\mathrm{pump}}$。消耗的总能量为 $E_{\\mathrm{elec,pump}} = P_{\\mathrm{elec,pump}} T_{\\mathrm{pump}}$。\n\n**RTE 计算**\n将能量表达式代入RTE定义中：\n$$ \\mathrm{RTE} = \\frac{ (\\eta_{\\mathrm{turb,h}} \\eta_{\\mathrm{e,gen}}) (\\rho g Q_{\\mathrm{gen}} (H - h_{L,\\mathrm{gen}})) T_{\\mathrm{gen}} }{ \\frac{\\rho g Q_{\\mathrm{pump}} (H + h_{L,\\mathrm{pump}})}{\\eta_{\\mathrm{pump,h}} \\eta_{\\mathrm{motor}}} \\left( \\frac{Q_{\\mathrm{gen}} T_{\\mathrm{gen}}}{Q_{\\mathrm{pump}}} \\right) } $$\n通过消去公因子（$\\rho, g, Q_{\\mathrm{gen}}, Q_{\\mathrm{pump}}, T_{\\mathrm{gen}}$）来简化，得到RTE的最终表达式：\n$$ \\mathrm{RTE} = (\\eta_{\\mathrm{turb,h}} \\eta_{\\mathrm{e,gen}} \\eta_{\\mathrm{pump,h}} \\eta_{\\mathrm{motor}}) \\left( \\frac{H - h_{L,\\mathrm{gen}}}{H + h_{L,\\mathrm{pump}}} \\right) $$\n水力水头损失 $h_{L}$ 使用达西-魏斯巴赫方程计算摩擦损失，并使用局部损失公式计算：\n$$ h_{L} = \\left( f \\frac{L}{D} + K \\right) \\frac{v^2}{2g} $$\n其中 $v=Q/A$ 且 $A = \\pi D^2 / 4$。\n\n**数值计算**\n给定值为：\n$H = 120 \\ \\mathrm{m}$, $L = 800 \\ \\mathrm{m}$, $D = 4 \\ \\mathrm{m}$, $g = 9.81 \\ \\mathrm{m/s^2}$。\n$Q_{\\mathrm{gen}} = 50 \\ \\mathrm{m^3/s}$, $f_{\\mathrm{gen}} = 0.018$, $K_{\\mathrm{gen}} = 2.0$。\n$Q_{\\mathrm{pump}} = 45 \\ \\mathrm{m^3/s}$, $f_{\\mathrm{pump}} = 0.020$, $K_{\\mathrm{pump}} = 2.5$。\n$\\eta_{\\mathrm{turb,h}} = 0.92$, $\\eta_{\\mathrm{e,gen}} = 0.98$, $\\eta_{\\mathrm{pump,h}} = 0.88$, $\\eta_{\\mathrm{motor}} = 0.96$。\n\n1.  压力钢管面积：$A = \\frac{\\pi (4 \\ \\mathrm{m})^2}{4} = 4\\pi \\ \\mathrm{m}^2$。\n\n2.  流速：\n    $v_{\\mathrm{gen}} = \\frac{50 \\ \\mathrm{m^3/s}}{4\\pi \\ \\mathrm{m}^2} = \\frac{12.5}{\\pi} \\ \\mathrm{m/s}$。\n    $v_{\\mathrm{pump}} = \\frac{45 \\ \\mathrm{m^3/s}}{4\\pi \\ \\mathrm{m}^2} = \\frac{11.25}{\\pi} \\ \\mathrm{m/s}$。\n\n3.  速度水头：\n    $\\frac{v_{\\mathrm{gen}}^2}{2g} = \\frac{(12.5/\\pi \\ \\mathrm{m/s})^2}{2(9.81 \\ \\mathrm{m/s^2})} \\approx 0.80690 \\ \\mathrm{m}$。\n    $\\frac{v_{\\mathrm{pump}}^2}{2g} = \\frac{(11.25/\\pi \\ \\mathrm{m/s})^2}{2(9.81 \\ \\mathrm{m/s^2})} \\approx 0.65359 \\ \\mathrm{m}$。\n\n4.  水头损失：\n    长径比 $L/D = 800/4 = 200$。\n    $h_{L,\\mathrm{gen}} = (0.018 \\times 200 + 2.0) \\times (0.80690 \\ \\mathrm{m}) = (3.6 + 2.0) \\times 0.80690 \\ \\mathrm{m} = 5.6 \\times 0.80690 \\ \\mathrm{m} \\approx 4.51864 \\ \\mathrm{m}$。\n    $h_{L,\\mathrm{pump}} = (0.020 \\times 200 + 2.5) \\times (0.65359 \\ \\mathrm{m}) = (4.0 + 2.5) \\times 0.65359 \\ \\mathrm{m} = 6.5 \\times 0.65359 \\ \\mathrm{m} \\approx 4.24834 \\ \\mathrm{m}$。\n\n5.  往返效率：\n    设备效率的乘积为：\n    $\\eta_{\\mathrm{em}} = 0.92 \\times 0.98 \\times 0.88 \\times 0.96 = 0.76169216$。\n    水力循环效率为：\n    $\\eta_{\\mathrm{hyd}} = \\frac{H - h_{L,\\mathrm{gen}}}{H + h_{L,\\mathrm{pump}}} = \\frac{120 \\ \\mathrm{m} - 4.51864 \\ \\mathrm{m}}{120 \\ \\mathrm{m} + 4.24834 \\ \\mathrm{m}} = \\frac{115.48136}{124.24834} \\approx 0.929439$。\n    总往返效率为：\n    $\\mathrm{RTE} = \\eta_{\\mathrm{em}} \\times \\eta_{\\mathrm{hyd}} = 0.76169216 \\times 0.929439 \\approx 0.707915$。\n\n将结果四舍五入到四位有效数字，得到 $0.7079$。",
            "answer": "$$\\boxed{0.7079}$$"
        },
        {
            "introduction": "储能装置的标称容量并不能完全代表其在实际应用中的可用能量。本练习将带您深入到一个电化学双电层电容器（EDLC）的内部，探讨真实世界的运行约束如何影响其性能。您将学习如何基于基本物理定律 $W = \\frac{1}{2}CV^2$ 出发，并结合考虑温度对电容和工作电压的实际影响，来精确计算装置的有效可用能量。这项实践对于任何需要设计或管理电池及超级电容器系统的工程师来说，都是一项必不可少的技能，它教会我们如何弥合理论模型与实际运行性能之间的差距 。",
            "id": "4090324",
            "problem": "一个配电网级的快速频率响应装置使用一个电化学双电层电容器（EDLC）组作为其储能元件。该EDLC组由$N_p$个并联的电容器串组成，每个串由$N_s$个电容器单元串联而成。每个单元被建模为一个线性电容器，其电容值在工作窗口内取决于温度但与电压无关。在恒定温度$T$下，将一个电容器从零电压充电到电压$V$所需的功由增量功$dW = v\\,dq$定义，其中$q$是电荷，$v$是瞬时电压。对于一个恒定温度$T$下的线性电容器，电荷与电压之间的本构关系为$q = C(T)\\,v$，其中$C(T)$是温度$T$下的电容值。\n\nEDLC单元在$25^\\circ\\mathrm{C}$时的标称电容为$C_{\\mathrm{cell},25}$，温度系数为$\\alpha$，使得$C_{\\mathrm{cell}}(T) = C_{\\mathrm{cell},25}\\,[1 + \\alpha\\,(T - 25^\\circ\\mathrm{C})]$。在温度$T$下，当温度超过阈值温度$T_0$时，最大允许单元电压会根据公式$V_{\\mathrm{cell,max}}(T) = V_{\\mathrm{cell,nom}} - \\gamma\\,\\max(0,\\,T - T_0)$进行工作降额，其中$V_{\\mathrm{cell,nom}}$是在$T_0$或低于$T_0$时的标称最大单元电压。与EDLC组连接的电力电子变流器设定了一个直流母线电压窗口$[V_{\\min},\\,V_{\\max,\\mathrm{conv}}]$；EDLC组充电至变流器电压上限和温度降额后的电容器组最大电压两者中的较小值，放电仅至变流器电压下限。\n\n参数和应用概况：\n- $N_s = 18$， $N_p = 2$。\n- $C_{\\mathrm{cell},25} = 3000$ F, $V_{\\mathrm{cell,nom}} = 2.7$ V, $T_0 = 35^\\circ\\mathrm{C}$, $\\alpha = 1.0 \\times 10^{-3}\\ \\mathrm{K}^{-1}$, $\\gamma = 1.0 \\times 10^{-2}$ V/K。\n- 环境温度 $T = 50^\\circ\\mathrm{C}$。\n- 变流器电压窗口：$V_{\\min} = 30$ V, $V_{\\max,\\mathrm{conv}} = 48$ V。\n- 在放电事件中忽略电阻损耗和漏电，并假设在恒定温度$T$下，$C(T)$在整个电压窗口内是恒定的。\n\n任务：\n从定义$dW = v\\,dq$和$q = C(T)\\,v$出发，推导在恒定温度$T$和电压$V$下，EDLC组中存储的能量的表达式。然后计算在$T = 50^\\circ\\mathrm{C}$时，从初始电容器组电压$V_i$（变流器电压上限和温度降额后的电容器组最大电压中的较小值）放电至最终电容器组电压$V_f = V_{\\min}$时可以提取的可用能量。将最终数值答案四舍五入至四位有效数字，并以千焦（kJ）为单位表示能量。最终答案必须是单个实数。",
            "solution": "该问题被评估为有效，因为它具有科学依据、内容自洽且问题适定。所提供的参数对于模拟电化学双电层电容器（EDLC）系统是一致且符合实际的。任务定义清晰，可以使用电路理论和储能的标准原理解答。\n\n第一个任务是推导EDLC组中存储的能量的表达式。我们从给定的基本定义开始：在电压为$v$时，向电容器增加增量电荷$dq$所需的增量功$dW$为$dW = v\\,dq$。对于恒定温度$T$下的线性电容器，电荷$q$和电压$v$之间的关系是$q = C(T)\\,v$，其中$C(T)$是电容值。在恒定温度下，$C(T)$是常数，因此我们可以简单地将其表示为$C$。对电荷-电压关系进行微分得到$dq = C\\,dv$。\n\n将电容器从电压$0$充电到最终电压$V$时存储的总能量$W$是增量功的积分：\n$$W = \\int_{v=0}^{v=V} dW = \\int_{v=0}^{v=V} v\\,dq$$\n代入$dq = C\\,dv$：\n$$W = \\int_{0}^{V} v\\,(C\\,dv) = C \\int_{0}^{V} v\\,dv = C \\left[ \\frac{1}{2}v^2 \\right]_{0}^{V} = \\frac{1}{2}CV^2$$\n这是储存在线性电容器中能量的通用表达式。EDLC组是线性电容器的组合，其行为也像一个具有等效电容器组电容$C_{\\mathrm{bank}}$的单一线性电容器。因此，在电压$V_{\\mathrm{bank}}$下，电容器组中存储的能量为：\n$$W_{\\mathrm{bank}}(V_{\\mathrm{bank}}) = \\frac{1}{2} C_{\\mathrm{bank}}(T) V_{\\mathrm{bank}}^2$$\n\n接下来，我们根据其组成单元确定整个EDLC组的特性。该电容器组由$N_p$个并联的串组成，每个串有$N_s$个单元串联。\n对于$N_s$个串联的单元，总串电容为$C_{\\mathrm{string}} = \\frac{C_{\\mathrm{cell}}}{N_s}$，总串电压是单元电压之和，$V_{\\mathrm{string}} = N_s V_{\\mathrm{cell}}$。\n对于$N_p$个并联的串，总电容器组电容为$C_{\\mathrm{bank}} = N_p C_{\\mathrm{string}} = \\frac{N_p}{N_s} C_{\\mathrm{cell}}$，电容器组电压与串电压相同，$V_{\\mathrm{bank}} = V_{\\mathrm{string}}$。\n因此，用单元参数表示的电容器组参数为：\n$$C_{\\mathrm{bank}}(T) = \\frac{N_p}{N_s} C_{\\mathrm{cell}}(T)$$\n$$V_{\\mathrm{bank,max}}(T) = N_s V_{\\mathrm{cell,max}}(T)$$\n\n给定的工作温度为$T = 50^\\circ\\mathrm{C}$。我们首先计算在此温度下单个单元的参数。温度依赖关系给出的系数单位为$\\mathrm{K}^{-1}$和$\\mathrm{V/K}$，而温度单位为${}^\\circ\\mathrm{C}$。这是标准做法，因为温差在开尔文和摄氏度下数值相同（即$\\Delta T_{\\mathrm{K}} = \\Delta T_{^\\circ\\mathrm{C}}$）。\n\n在$T = 50^\\circ\\mathrm{C}$时，单元电容为：\n$$C_{\\mathrm{cell}}(T) = C_{\\mathrm{cell},25}\\,[1 + \\alpha\\,(T - 25^\\circ\\mathrm{C})]$$\n$$C_{\\mathrm{cell}}(50^\\circ\\mathrm{C}) = 3000\\,\\text{F} \\times [1 + (1.0 \\times 10^{-3}\\,\\mathrm{K}^{-1}) \\times (50 - 25)\\,\\mathrm{K}] = 3000 \\times [1 + 0.025] = 3075\\,\\text{F}$$\n\n在$T = 50^\\circ\\mathrm{C}$时，由于$T  T_0$，最大允许单元电压会降额。\n$$V_{\\mathrm{cell,max}}(T) = V_{\\mathrm{cell,nom}} - \\gamma\\,\\max(0,\\,T - T_0)$$\n$$V_{\\mathrm{cell,max}}(50^\\circ\\mathrm{C}) = 2.7\\,\\text{V} - (1.0 \\times 10^{-2}\\,\\mathrm{V/K}) \\times \\max(0, 50 - 35)\\,\\mathrm{K} = 2.7 - (1.0 \\times 10^{-2}) \\times 15 = 2.7 - 0.15 = 2.55\\,\\text{V}$$\n\n现在，我们可以使用$N_s = 18$和$N_p = 2$计算电容器组级别的参数。\n在$T = 50^\\circ\\mathrm{C}$时，电容器组电容为：\n$$C_{\\mathrm{bank}}(50^\\circ\\mathrm{C}) = \\frac{N_p}{N_s} C_{\\mathrm{cell}}(50^\\circ\\mathrm{C}) = \\frac{2}{18} \\times 3075\\,\\text{F} = \\frac{3075}{9}\\,\\text{F} \\approx 341.67\\,\\text{F}$$\n在$T = 50^\\circ\\mathrm{C}$时，最大允许电容器组电压为：\n$$V_{\\mathrm{bank,max}}(50^\\circ\\mathrm{C}) = N_s V_{\\mathrm{cell,max}}(50^\\circ\\mathrm{C}) = 18 \\times 2.55\\,\\text{V} = 45.9\\,\\text{V}$$\n\n可用能量是通过在特定电压范围内对电容器组放电来提取的。初始电压$V_i$是完全充电状态下的电压，取温度降额后的电容器组最大电压和变流器电压上限$V_{\\max,\\mathrm{conv}} = 48\\,\\text{V}$中的较小值。\n$$V_i = \\min(V_{\\mathrm{bank,max}}(50^\\circ\\mathrm{C}), V_{\\max,\\mathrm{conv}}) = \\min(45.9\\,\\text{V}, 48\\,\\text{V}) = 45.9\\,\\text{V}$$\n最终电压$V_f$是变流器的电压下限，$V_{\\min} = 30\\,\\text{V}$。\n$$V_f = V_{\\min} = 30\\,\\text{V}$$\n\n可用能量$\\Delta W$是在$V_i$时存储的能量与在$V_f$时存储的能量之差。\n$$\\Delta W = W_{\\mathrm{bank}}(V_i) - W_{\\mathrm{bank}}(V_f) = \\frac{1}{2}C_{\\mathrm{bank}}(50^\\circ\\mathrm{C})V_i^2 - \\frac{1}{2}C_{\\mathrm{bank}}(50^\\circ\\mathrm{C})V_f^2$$\n$$\\Delta W = \\frac{1}{2}C_{\\mathrm{bank}}(50^\\circ\\mathrm{C})(V_i^2 - V_f^2)$$\n代入计算出的值：\n$$\\Delta W = \\frac{1}{2} \\left(\\frac{3075}{9}\\,\\text{F}\\right) \\left( (45.9\\,\\text{V})^2 - (30\\,\\text{V})^2 \\right)$$\n$$\\Delta W = \\frac{3075}{18} (2106.81 - 900)\\,\\text{J}$$\n$$\\Delta W = \\frac{3075}{18} (1206.81)\\,\\text{J} \\approx 206200.708\\,\\text{J}$$\n\n问题要求答案以千焦（kJ）为单位，并四舍五入到四位有效数字。\n$$\\Delta W \\approx 206.200708\\,\\text{kJ}$$\n四舍五入到四位有效数字，我们得到：\n$$\\Delta W = 206.2\\,\\text{kJ}$$",
            "answer": "$$\\boxed{206.2}$$"
        },
        {
            "introduction": "预测储能资产的使用寿命是评估其全生命周期价值和制定优化运行策略的核心。本练习将通过一个动手编程任务，向您介绍一种结合了电气工程和材料疲劳分析的先进方法。您将学习使用“雨流计数法”这种标准算法来解析复杂的电池充放电曲线，并将其转化为一组对电池寿命有影响的应力循环，最终应用一个经过校准的疲劳模型来预测电池的累积损伤和预期寿命。这项实践为您提供了一个强大的计算框架，用以量化不同使用模式对电池退化的影响，从而为储能系统的设计和运营提供关键数据支持 。",
            "id": "4090343",
            "problem": "给定代表电池荷电状态 (SoC) 循环剖面的离散时间序列，以及允许将 SoC 变化映射到电极应力的具有物理意义的参数。您的任务是计算每个剖面的累积外部能量吞吐量，并通过对诱导应力信号应用雨流计数法和 Wöhler 型疲劳模型来估计循环寿命。解决方案必须实现为一个完整的、可运行的程序。\n\n假设以下基于物理的基本定义和定律：\n\n- 能量守恒：在一个时间步长内，电池中存储能量的变化与荷电状态的变化成正比。如果额定能量容量为 $C_{\\mathrm{Wh}}$ 瓦时 (Wh)，SoC 变化量为 $\\Delta s$，则内部能量变化为 $C_{\\mathrm{Wh}} \\,\\Delta s$ Wh。\n\n- 外部能量吞吐量考虑了充电和放电的转换效率。对于 SoC 变化为 $\\Delta s_k$ 的时间步长 $k$，充电（$\\Delta s_k \\gt 0$）需要外部能量 $C_{\\mathrm{Wh}} \\,\\Delta s_k / \\eta_c$，而放电（$\\Delta s_k \\lt 0$）产生外部能量 $C_{\\mathrm{Wh}} \\,|\\Delta s_k| \\,\\eta_d$。此处的 $\\eta_c$ 和 $\\eta_d$ 分别是充电和放电效率，均为 $(0,1]$ 内的无量纲数。\n\n- 应力-循环次数 (S-N) Wöhler 型疲劳模型：如果第 $i$ 个循环的应力幅值为 $\\Delta \\sigma_i$，则在该幅值下达到失效的循环次数为 $N_i = N_{\\mathrm{ref}}\\left(\\dfrac{\\Delta \\sigma_{\\mathrm{ref}}}{\\Delta \\sigma_i}\\right)^m$，其中 $N_{\\mathrm{ref}}$ 是在参考应力幅值 $\\Delta \\sigma_{\\mathrm{ref}}$ 下达到失效的循环次数，$m$ 是 Basquin 指数。每个循环的损伤为 $d_i = \\dfrac{1}{N_i} = \\dfrac{1}{N_{\\mathrm{ref}}}\\left(\\dfrac{\\Delta \\sigma_i}{\\Delta \\sigma_{\\mathrm{ref}}}\\right)^m$。\n\n- Miner 线性损伤累积法则：一个剖面上的总损伤为 $D_{\\mathrm{profile}} = \\sum_i \\alpha_i \\, d_i$，其中 $\\alpha_i$ 是循环计数权重（对于一个完整循环，$\\alpha_i = 1$，对于半个循环，$\\alpha_i = \\tfrac{1}{2}$）。给定剖面重复使用至失效的预测次数（即此重复使用下的循环寿命）为 $R^\\star = \\dfrac{1}{D_{\\mathrm{profile}}}$。\n\n- SoC 到应力的映射：使用线性映射将 SoC 映射到电极应力信号 $\\sigma(t)$，即 $\\sigma(t) = k_\\sigma \\, s(t)$，其中 $k_\\sigma$ 的单位是 $\\mathrm{MPa}$ 每单位 SoC，$s(t)$ 是无量纲的。这确保了计数循环的应力幅值为 $\\Delta \\sigma = k_\\sigma \\, \\Delta s$。\n\n雨流计数必须在从 SoC 样本 $\\{s_k\\}$ 获得的离散应力信号 $\\{\\sigma_k\\}$ 上执行。使用一个算法，该算法：\n- 从 $\\{\\sigma_k\\}$ 中提取转折点（局部极值），形成一个反转序列。\n- 迭代应用雨流计数规则，以识别完整循环和半循环及其幅值 $\\Delta \\sigma_i$。\n- 生成一组带有幅值和权重 $\\alpha_i \\in \\{1,\\tfrac{1}{2}\\}$ 的循环。\n\n对于每个测试用例，计算：\n- 所提供剖面上的累积外部能量吞吐量，单位为 $\\mathrm{Wh}$（外部充电和放电能量大小的总和）。\n- 剖面上的总损伤 $D_{\\mathrm{profile}}$。\n- 预测的重复至失效次数 $R^\\star = \\dfrac{1}{D_{\\mathrm{profile}}}$，无量纲。如果 $D_{\\mathrm{profile}} = 0$，则定义 $R^\\star = +\\infty$。\n- 失效能量吞吐量 $E_{\\mathrm{TTF}} = R^\\star \\times E_{\\mathrm{throughput}}$，以 $\\mathrm{Wh}$ 表示。如果 $R^\\star = +\\infty$，则定义 $E_{\\mathrm{TTF}} = +\\infty$。\n\n所有能量值以 $\\mathrm{Wh}$ 表示，无量纲量不带单位。不涉及角度，也不需要角度单位。\n\n使用以下参数集测试套件。每个测试用例由一个元组 $(\\{s_k\\}, \\Delta t, C_{\\mathrm{Wh}}, \\eta_c, \\eta_d, k_\\sigma, \\Delta \\sigma_{\\mathrm{ref}}, N_{\\mathrm{ref}}, m)$ 定义：\n- 测试用例 1（典型情况，混合幅值）：\n  - $\\{s_k\\} = [\\,0.50,\\,0.65,\\,0.40,\\,0.75,\\,0.35,\\,0.80,\\,0.45,\\,0.60\\,]$\n  - $\\Delta t = 600\\,\\mathrm{s}$\n  - $C_{\\mathrm{Wh}} = 10000$\n  - $\\eta_c = 0.96$\n  - $\\eta_d = 0.96$\n  - $k_\\sigma = 80\\,\\mathrm{MPa}$\n  - $\\Delta \\sigma_{\\mathrm{ref}} = 32\\,\\mathrm{MPa}$\n  - $N_{\\mathrm{ref}} = 12000$\n  - $m = 3.2$\n- 测试用例 2（边界情况，单调增加仅导致半循环）：\n  - $\\{s_k\\} = [\\,0.50,\\,0.55,\\,0.60,\\,0.65,\\,0.70\\,]$\n  - $\\Delta t = 900\\,\\mathrm{s}$\n  - $C_{\\mathrm{Wh}} = 10000$\n  - $\\eta_c = 0.96$\n  - $\\eta_d = 0.96$\n  - $k_\\sigma = 80\\,\\mathrm{MPa}$\n  - $\\Delta \\sigma_{\\mathrm{ref}} = 32\\,\\mathrm{MPa}$\n  - $N_{\\mathrm{ref}} = 12000$\n  - $m = 3.2$\n- 测试用例 3（边缘情况，混合半循环和完整循环）：\n  - $\\{s_k\\} = [\\,0.20,\\,0.60,\\,0.30,\\,0.55,\\,0.25\\,]$\n  - $\\Delta t = 300\\,\\mathrm{s}$\n  - $C_{\\mathrm{Wh}} = 10000$\n  - $\\eta_c = 0.96$\n  - $\\eta_d = 0.96$\n  - $k_\\sigma = 80\\,\\mathrm{MPa}$\n  - $\\Delta \\sigma_{\\mathrm{ref}} = 32\\,\\mathrm{MPa}$\n  - $N_{\\mathrm{ref}} = 12000$\n  - $m = 3.2$\n- 测试用例 4（高应力波动）：\n  - $\\{s_k\\} = [\\,0.10,\\,0.90,\\,0.20,\\,0.85,\\,0.30,\\,0.80\\,]$\n  - $\\Delta t = 1200\\,\\mathrm{s}$\n  - $C_{\\mathrm{Wh}} = 10000$\n  - $\\eta_c = 0.96$\n  - $\\eta_d = 0.96$\n  - $k_\\sigma = 80\\,\\mathrm{MPa}$\n  - $\\Delta \\sigma_{\\mathrm{ref}} = 32\\,\\mathrm{MPa}$\n  - $N_{\\mathrm{ref}} = 12000$\n  - $m = 3.2$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身就是一个形式为 $[E_{\\mathrm{throughput}}, D_{\\mathrm{profile}}, R^\\star, E_{\\mathrm{TTF}}]$ 的列表。例如，最终输出应类似于 $[[x_1,y_1,z_1,w_1],[x_2,y_2,z_2,w_2],[x_3,y_3,z_3,w_3],[x_4,y_4,z_4,w_4]]$，其中数值替换了占位符。",
            "solution": "该任务要求将基础电化学能量衡算与机械疲劳分析相结合。推导从第一性原理出发。\n\n从电池的能量守恒原理开始。设额定能量容量为 $C_{\\mathrm{Wh}}$ 瓦时。荷电状态序列为 $\\{s_k\\}$，无量纲且界于 $[0,1]$。在离散步骤 $k$ 上的内部能量变化为 $\\Delta E_{\\mathrm{int},k} = C_{\\mathrm{Wh}} \\,\\Delta s_k$，其中 $\\Delta s_k = s_{k+1} - s_k$。外部能量衡算包含了效率。对于充电步骤（$\\Delta s_k \\gt 0$），所需的外部能量输入为 $E_{\\mathrm{ext},k}^{\\mathrm{in}} = \\dfrac{C_{\\mathrm{Wh}} \\,\\Delta s_k}{\\eta_c}$。对于放电步骤（$\\Delta s_k \\lt 0$），外部能量输出为 $E_{\\mathrm{ext},k}^{\\mathrm{out}} = C_{\\mathrm{Wh}} \\,|\\Delta s_k| \\,\\eta_d$。累积外部能量吞吐量定义为外部能量流大小的总和，即\n$$\nE_{\\mathrm{throughput}} = \\sum_{k=0}^{K-2}\n\\begin{cases}\n\\dfrac{C_{\\mathrm{Wh}} \\,\\Delta s_k}{\\eta_c},   \\Delta s_k \\gt 0,\\\\\nC_{\\mathrm{Wh}} \\,(-\\Delta s_k)\\,\\eta_d,   \\Delta s_k \\lt 0,\\\\\n0,   \\Delta s_k = 0.\n\\end{cases}\n$$\n该量以 $\\mathrm{Wh}$ 表示。\n\n接下来，使用线性模型 $\\sigma_k = k_\\sigma \\, s_k$ 将 SoC 信号映射到电极应力，其中 $k_\\sigma$ 的单位是 $\\mathrm{MPa}$ 每单位 SoC。该映射反映了锂化状态和机械应力之间的比例关系，这与活性材料中的小应变近似一致。然后使用雨流计数法分析应力序列 $\\{\\sigma_k\\}$ 以提取循环幅值。雨流算法对转折点（反转）序列进行操作，并应用基于堆栈的相邻范围比较来识别闭合循环。对于三个连续的反转点 $\\sigma_{a}, \\sigma_{b}, \\sigma_{c}$，定义范围 $R_1 = |\\sigma_b - \\sigma_a|$ 和 $R_2 = |\\sigma_c - \\sigma_b|$。如果 $R_1 \\le R_2$，则计数一个幅值为 $\\Delta \\sigma = R_1$ 的循环；然后算法移除中间点并继续。遍历结束后，堆栈上残留的相邻对代表半循环。每个计数的元素都关联一个权重，完整循环为 $\\alpha_i = 1$，半循环为 $\\alpha_i = \\tfrac{1}{2}$。\n\n利用循环幅值集 $\\{\\Delta \\sigma_i\\}$ 和权重集 $\\{\\alpha_i\\}$，应用 Wöhler 型疲劳模型。在幅值 $\\Delta \\sigma_i$ 下的失效循环次数为\n$$\nN_i = N_{\\mathrm{ref}}\\left(\\dfrac{\\Delta \\sigma_{\\mathrm{ref}}}{\\Delta \\sigma_i}\\right)^m,\n$$\n其中 $N_{\\mathrm{ref}}$ 是在参考应力幅值 $\\Delta \\sigma_{\\mathrm{ref}}$ 下的失效循环次数，$m$ 是 Basquin 指数。第 $i$ 个循环的损伤为\n$$\nd_i = \\dfrac{1}{N_i} = \\dfrac{1}{N_{\\mathrm{ref}}}\\left(\\dfrac{\\Delta \\sigma_i}{\\Delta \\sigma_{\\mathrm{ref}}}\\right)^m.\n$$\n根据 Miner 法则，剖面上的总损伤为\n$$\nD_{\\mathrm{profile}} = \\sum_i \\alpha_i \\, d_i = \\sum_i \\alpha_i \\, \\dfrac{1}{N_{\\mathrm{ref}}}\\left(\\dfrac{\\Delta \\sigma_i}{\\Delta \\sigma_{\\mathrm{ref}}}\\right)^m.\n$$\n如果没有检测到循环或所有幅值均为零，则 $D_{\\mathrm{profile}} = 0$。预测的重复至失效次数为\n$$\nR^\\star = \\begin{cases}\n\\dfrac{1}{D_{\\mathrm{profile}}},  D_{\\mathrm{profile}} \\gt 0,\\\\\n+\\infty,  D_{\\mathrm{profile}} = 0.\n\\end{cases}\n$$\n失效能量吞吐量是剖面的累积吞吐量乘以重复次数：\n$$\nE_{\\mathrm{TTF}} = R^\\star \\times E_{\\mathrm{throughput}}.\n$$\n如果 $R^\\star = +\\infty$，则 $E_{\\mathrm{TTF}} = +\\infty$。\n\n算法设计：\n\n- 使用上述分段求和，直接从 $\\{s_k\\}$, $C_{\\mathrm{Wh}}$, $\\eta_c$, 和 $\\eta_d$ 计算 $E_{\\mathrm{throughput}}$。\n\n- 生成应力序列 $\\sigma_k = k_\\sigma \\, s_k$。\n\n- 提取反转点：包括第一个和最后一个点，以及任何满足 $(\\sigma_i - \\sigma_{i-1})(\\sigma_{i+1} - \\sigma_i) \\le 0$ 的中间点 $\\sigma_i$，当相邻值不同时，不等式为严格的。移除连续的重复值以避免零长度范围。\n\n- 应用基于堆栈的雨流算法：\n  - 初始化一个空堆栈。\n  - 对于每个反转值，将其推入堆栈，当堆栈中至少有三个点时，比较最后两个范围。如果前一个范围小于或等于后一个范围，则计数一个幅值等于前一个范围的完整循环，并从堆栈中移除前两个点；否则停止内循环。\n  - 处理完所有反转点后，为堆栈上每个剩余的相邻对计数半循环，其幅值等于该对的范围。\n\n- 对每个循环幅值，通过 Wöhler 模型计算 $D_{\\mathrm{profile}}$，并应用 $\\alpha_i$ 权重。\n\n- 计算 $R^\\star$ 和 $E_{\\mathrm{TTF}}$。\n\n此方法在吞吐量计算中遵循能量守恒，并使用经过充分测试的疲劳模型（应力-循环次数 Wöhler 关系）与雨流计数法相结合，雨流计数法是将变幅载荷历史转化为一组损伤循环的标准方法。程序将此过程应用于四个测试用例，并输出所要求的列表的列表，其中能量值以 $\\mathrm{Wh}$ 为单位，损伤和重复次数为无量纲量。",
            "answer": "```python\nimport numpy as np\n\ndef extract_reversals(series: np.ndarray) - np.ndarray:\n    \"\"\"\n    Extract turning points (reversals) from a numeric sequence.\n    Includes first and last points. Removes consecutive duplicates.\n    \"\"\"\n    if len(series) == 0:\n        return np.array([])\n    # Remove consecutive duplicates\n    s = [series[0]]\n    for x in series[1:]:\n        if x != s[-1]:\n            s.append(x)\n    s = np.array(s, dtype=float)\n    if len(s) == 1:\n        return s.copy()\n\n    rev = [s[0]]\n    for i in range(1, len(s) - 1):\n        prev = s[i - 1]\n        curr = s[i]\n        nxt = s[i + 1]\n        # reversal if direction changes or plateau transitions\n        if (curr - prev) * (nxt - curr) = 0:\n            if not (curr == prev and curr == nxt):\n                rev.append(curr)\n    rev.append(s[-1])\n    # Remove consecutive duplicates in reversals\n    clean = [rev[0]]\n    for x in rev[1:]:\n        if x != clean[-1]:\n            clean.append(x)\n    return np.array(clean, dtype=float)\n\ndef rainflow_ranges(series: np.ndarray):\n    \"\"\"\n    Perform rainflow counting on a sequence of stress values.\n    Returns a list of tuples (amplitude, weight) where weight is 1.0 for full cycle\n    and 0.5 for half cycle.\n    \"\"\"\n    rev = extract_reversals(series)\n    cycles = []\n    stack = []\n    for x in rev:\n        stack.append(x)\n        # While at least 3 reversals, compare ranges\n        while len(stack) >= 3:\n            s0 = stack[-3]\n            s1 = stack[-2]\n            s2 = stack[-1]\n            r1 = abs(s1 - s0)\n            r2 = abs(s2 - s1)\n            if r1 = r2:\n                # Count a full cycle of amplitude r1\n                if r1 > 0.0:\n                    cycles.append((r1, 1.0))\n                # Remove middle two: first remove s1 (index -2), then s0 (now at index -2)\n                stack.pop(-2)\n                stack.pop(-2)\n            else:\n                break\n    # Remaining adjacent pairs are half cycles\n    for i in range(len(stack) - 1):\n        r = abs(stack[i + 1] - stack[i])\n        if r > 0.0:\n            cycles.append((r, 0.5))\n    return cycles\n\ndef compute_throughput_wh(soc: np.ndarray, C_wh: float, eta_c: float, eta_d: float) - float:\n    \"\"\"\n    Compute cumulative external energy throughput in Wh from an SoC sequence.\n    Charging steps: external energy in = C_wh * delta_soc / eta_c\n    Discharging steps: external energy out = C_wh * (-delta_soc) * eta_d\n    \"\"\"\n    throughput = 0.0\n    for i in range(len(soc) - 1):\n        ds = soc[i + 1] - soc[i]\n        if ds > 0:\n            throughput += C_wh * ds / eta_c\n        elif ds  0:\n            throughput += C_wh * (-ds) * eta_d\n        # ds == 0 contributes nothing\n    return throughput\n\ndef fatigue_damage_profile(soc: np.ndarray, k_sigma: float, sigma_ref: float,\n                           N_ref: float, m: float) - float:\n    \"\"\"\n    Map SoC to stress, apply rainflow counting, and compute total damage per profile.\n    Damage per cycle: d_i = (1/N_ref) * (Delta_sigma_i / sigma_ref)^m\n    \"\"\"\n    sigma = k_sigma * soc\n    cycles = rainflow_ranges(sigma)\n    D = 0.0\n    for amp, weight in cycles:\n        if amp = 0.0:\n            continue\n        # Damage contribution\n        D += weight * (amp / sigma_ref) ** m / N_ref\n    return D\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (soc_list, dt_seconds, C_wh, eta_c, eta_d, k_sigma, sigma_ref, N_ref, m)\n    test_cases = [\n        ([0.50, 0.65, 0.40, 0.75, 0.35, 0.80, 0.45, 0.60], 600, 10000.0, 0.96, 0.96, 80.0, 32.0, 12000.0, 3.2),\n        ([0.50, 0.55, 0.60, 0.65, 0.70], 900, 10000.0, 0.96, 0.96, 80.0, 32.0, 12000.0, 3.2),\n        ([0.20, 0.60, 0.30, 0.55, 0.25], 300, 10000.0, 0.96, 0.96, 80.0, 32.0, 12000.0, 3.2),\n        ([0.10, 0.90, 0.20, 0.85, 0.30, 0.80], 1200, 10000.0, 0.96, 0.96, 80.0, 32.0, 12000.0, 3.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        soc_list, dt, C_wh, eta_c, eta_d, k_sigma, sigma_ref, N_ref, m = case\n        soc = np.array(soc_list, dtype=float)\n\n        # Energy throughput in Wh\n        E_throughput = compute_throughput_wh(soc, C_wh, eta_c, eta_d)\n\n        # Damage per profile\n        D_profile = fatigue_damage_profile(soc, k_sigma, sigma_ref, N_ref, m)\n\n        # Repeats to failure\n        if D_profile > 0.0:\n            R_star = 1.0 / D_profile\n            E_ttf = R_star * E_throughput\n        else:\n            R_star = float('inf')\n            E_ttf = float('inf')\n\n        results.append([E_throughput, D_profile, R_star, E_ttf])\n\n    # Final print statement in the exact required format.\n    # Produce a single line with the list-of-lists.\n    print(f\"[{','.join([str(r) for r in results])}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}