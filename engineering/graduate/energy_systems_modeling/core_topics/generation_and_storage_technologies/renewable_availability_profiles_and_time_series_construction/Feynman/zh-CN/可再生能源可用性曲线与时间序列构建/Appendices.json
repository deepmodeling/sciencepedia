{
    "hands_on_practices": [
        {
            "introduction": "在处理任何能源时间序列数据之前，最关键的第一步是准确理解数据本身的含义。一个数值究竟代表了瞬时读数还是一个时间段内的平均值，其时间戳是指区间的开始、中间还是结束？这些看似微小的细节将直接影响到能量和容量因子等关键指标的计算准确性。本练习  将通过分析不同的时间戳约定，帮助您建立严谨的数据处理思维，避免因数据误读而导致的模型偏差。",
            "id": "4115881",
            "problem": "一位能源系统建模师需要根据长度为 $T$、划分为 $N$ 个宽度为 $\\Delta t = T/N$ 的相等区间的每小时可用率时间序列，计算风力或光伏 (PV) 发电厂的年容量因子。设 $a(t) \\in [0,1]$ 表示潜在的连续可用率分数，$P_{\\mathrm{rated}}$ 表示额定功率，因此物理功率为 $P(t) = P_{\\mathrm{rated}} a(t)$。三家数据提供商为相同的潜在过程和完全覆盖该时间范围的同一组不相交、连续的区间提供具有不同时间戳约定的时间序列：\n- Provider A：值以区间结束时间 $t_k$ 标记；每个报告的值等于 $(t_{k-1}, t_k]$ 上的区间平均可用率。\n- Provider B：值以区间开始时间 $t_{k-1}$ 标记；每个报告的值等于 $[t_{k-1}, t_k)$ 上的区间平均可用率。\n- Provider C：值以中心时间 $(t_{k-1} + t_k)/2$ 标记；每个报告的值等于 $[t_{k-1}, t_k)$ 中点的瞬时可用率。\n\n建模师通过对报告的序列进行离散求和，并除以 $P_{\\mathrm{rated}}$ 和 $T$ 来形成容量因子的估计值。假设 $a(t)$ 在 $[0,T]$ 上是连续的，且具有有界导数。\n\n哪个陈述最能描述时间戳约定对计算出的容量因子的影响，并规定了一种能避免偏差的一致性约定？\n\nA. 如果报告的值是区间平均值，它们以半开区间的形式拼接覆盖了 $[0,T]$，并且没有丢弃或重复边界区间，那么容量因子的估计值与时间戳表示的是开始、结束还是中心无关。偏差主要产生于将区间平均值误解为点样本或对时间范围边界处理不当。一种一致且无偏的约定是，存储半开区间 $[t_k, t_{k+1})$ 的区间平均可用率，用明确的区间语义在 $t_k$ 或 $t_{k+1}$ 处标记时间戳，并通过区间能量之和除以 $P_{\\mathrm{rated}} T$ 来计算容量因子。如果只有点样本可用，则在具有对齐边界的 $[0,T]$ 上使用中点或梯形求积法。\n\nB. 区间开始时间戳会系统性地夸大风能和光伏的容量因子，因为可用率通常在每小时内增加；区间结束时间戳消除了这种效应。因此，一种一致且无偏的约定是使用区间结束时间戳，并将值解释为瞬时值。\n\nC. 当容量因子通过点样本上的矩形法则计算时，中心时间戳能保证对于任何平滑的可用率曲线都具有零偏差；开始和结束时间戳会产生大小相等、符号相反的一阶偏差，该偏差与局部时间导数成正比。因此，应始终在区间中心标记时间戳以消除偏差。\n\nD. 为避免重复计算，对于区间结束时间戳，应丢弃第一个报告的值，并对其余 $N-1$ 个值求和；这可以消除边界效应并确保容量因子无偏。\n\nE. 在任何解释下，时间戳的选择都无关紧要，因为对一组固定的 $N$ 个值的求和对于重新标记是不变的；因此，容量因子不能依赖于开始、结束还是中心的约定，并且不需要对边界进行特殊处理。",
            "solution": "该问题要求分析不同的时间序列时间戳和数据表示约定如何影响年容量因子的计算。\n\n真实容量因子 $CF$ 定义为在周期 $T$ 内产生的总实际能量除以该周期内可能产生的最大能量。在数学上，它是可用率分数 $a(t)$ 的时间平均值：\n$$CF = \\frac{\\int_0^T P(t) \\, dt}{P_{\\mathrm{rated}} T} = \\frac{\\int_0^T P_{\\mathrm{rated}} a(t) \\, dt}{P_{\\mathrm{rated}} T} = \\frac{1}{T} \\int_0^T a(t) \\, dt$$\n\n时间范围 $[0, T]$ 被划分为 $N$ 个相等的区间，每个区间的宽度为 $\\Delta t = T/N$。第 $k$ 个区间可以表示为 $[t_{k-1}, t_k)$ 或 $(t_{k-1}, t_k]$，其中 $t_k = k \\Delta t$，$k=0, 1, \\dots, N$。该积分可以表示为在这些区间上的和：\n$$CF = \\frac{1}{T} \\sum_{k=1}^N \\int_{t_{k-1}}^{t_k} a(t) \\, dt$$\n\n建模师对容量因子的估计值 $\\widehat{CF}$，是通过对所提供的时间序列值（我们称之为 $\\{v_k\\}_{k=1}^N$）进行离散求和而形成的：\n$$\\widehat{CF} = \\frac{\\sum_{k=1}^N (v_k P_{\\mathrm{rated}}) \\Delta t}{P_{\\mathrm{rated}} T} = \\frac{\\Delta t}{T} \\sum_{k=1}^N v_k = \\frac{1}{N} \\sum_{k=1}^N v_k$$\n\n我们现在将为每个数据提供商分析估计值 $\\widehat{CF}$。\n\n**对 Provider A（区间结束平均值）和 Provider B（区间开始平均值）的分析：**\n\n两家提供商都提供区间平均值。\n对于 Provider A，值 $A_k$ 的时间戳在 $t_k$，代表在 $(t_{k-1}, t_k]$ 上的平均值。\n对于 Provider B，值 $B_k$ 的时间戳在 $t_{k-1}$，代表在 $[t_{k-1}, t_k)$ 上的平均值。\n\n在这两种情况下，第 $k$ 个区间的报告值是该区间的真实平均可用率：\n$$v_k = \\frac{1}{\\Delta t} \\int_{t_{k-1}}^{t_k} a(\\tau) \\, d\\tau$$\n对于 Provider A 和 Provider B，报告的值集 $\\{v_k\\}_{k=1}^N$ 是相同的；只有附加到这些值上的时间标签不同。\n\n估计的容量因子计算如下：\n$$\\widehat{CF} = \\frac{1}{N} \\sum_{k=1}^N v_k = \\frac{1}{N} \\sum_{k=1}^N \\left( \\frac{1}{\\Delta t} \\int_{t_{k-1}}^{t_k} a(\\tau) \\, d\\tau \\right)$$\n代入 $N = T / \\Delta t$：\n$$\\widehat{CF} = \\frac{\\Delta t}{T} \\frac{1}{\\Delta t} \\sum_{k=1}^N \\int_{t_{k-1}}^{t_k} a(\\tau) \\, d\\tau = \\frac{1}{T} \\sum_{k=1}^N \\int_{t_{k-1}}^{t_k} a(\\tau) \\, d\\tau$$\n根据积分的可加性，在拼接覆盖 $[0, T]$ 的不相交区间 $[t_{k-1}, t_k]$ 上的积分之和等于在整个时间范围上的积分：\n$$\\widehat{CF} = \\frac{1}{T} \\int_0^T a(\\tau) \\, d\\tau = CF$$\n\n结论：如果数据包含一套完整的、不重叠的、完美拼接覆盖时间范围的区间平均值，那么离散求和可以正确且精确地重构出真实的容量因子。时间戳的选择（区间开始 vs. 区间结束）仅仅是一个标记约定，对计算值没有影响。偏差为零。\n\n**对 Provider C（中心瞬时值）的分析：**\n\nProvider C 提供的值 $C_k$ 是每个区间中点 $t_{k,cen} = (t_{k-1} + t_k) / 2$ 的瞬时样本。\n$$C_k = a(t_{k,cen})$$\n估计的容量因子为：\n$$\\widehat{CF}_C = \\frac{1}{N} \\sum_{k=1}^N C_k = \\frac{1}{N} \\sum_{k=1}^N a(t_{k,cen})$$\n为了将其与真实的 $CF$ 进行比较，我们重写该表达式：\n$$\\widehat{CF}_C = \\frac{\\Delta t}{T} \\sum_{k=1}^N a(t_{k,cen})$$\n这个计算等同于使用中点法则进行数值求积来近似真实积分 $\\int_0^T a(t) \\, dt$：\n$$\\int_0^T a(t) \\, dt \\approx \\sum_{k=1}^N a(t_{k,cen}) \\Delta t$$\n复合中点法则的误差在数值分析中是已知的。对于一个具有连续二阶导数的函数 $a(t)$，误差为：\n$$\\int_0^T a(t) \\, dt - \\sum_{k=1}^N a(t_{k,cen}) \\Delta t = \\frac{T (\\Delta t)^2}{24} a''(\\xi)$$\n其中某个 $\\xi \\in (0, T)$。\n\n结论：来自 Provider C 数据的估计是一个近似值，而非精确计算。它是有偏差的，除非对所有 $t$ 都有 $a''(t) = 0$（即 $a(t)$ 是一个线性函数），否则偏差（误差）不为零。\n\n**选项评估：**\n\n**A. 如果报告的值是区间平均值，它们以半开区间的形式拼接覆盖了 $[0,T]$，并且没有丢弃或重复边界区间，那么容量因子的估计值与时间戳表示的是开始、结束还是中心无关。偏差主要产生于将区间平均值误解为点样本或对时间范围边界处理不当。一种一致且无偏的约定是，存储半开区间 $[t_k, t_{k+1})$ 的区间平均可用率，用明确的区间语义在 $t_k$ 或 $t_{k+1}$ 处标记时间戳，并通过区间能量之和除以 $P_{\\mathrm{rated}} T$ 来计算容量因子。如果只有点样本可用，则在具有对齐边界的 $[0,T]$ 上使用中点或梯形求积法。**\n- 这个陈述与我们的分析完全一致。它正确地指出，对于区间平均数据（Provider A 和 B），时间戳是一个标记问题，如果执行正确，计算是精确的（无偏的）。它精确指出了误差的真正来源：误解数据类型（例如，将平均值视为点样本）或处理不当的求和域（边界效应）。为区间平均值规定的约定是数学上精确的方法。它还正确地建议对点样本使用数值求积法。\n- **结论：正确。**\n\n**B. 区间开始时间戳会系统性地夸大风能和光伏的容量因子，因为可用率通常在每小时内增加；区间结束时间戳消除了这种效应。因此，一种一致且无偏的约定是使用区间结束时间戳，并将值解释为瞬时值。**\n- 这个选项在多个方面都有缺陷。首先，“可用率通常在每小时内增加”的前提是一个薄弱且未经证实的概括。其次，它错误地分析了偏差。如果我们对一个递增函数使用区间开始处的点样本，左黎曼和会*低估*（而不是夸大）积分。第三，它混淆了区间平均数据（来自 Provider B）和点样本数据。如前所示，对于区间平均值，没有偏差。最后，它建议误解数据（“将值解释为瞬时值”），这是错误的直接原因。\n- **结论：不正确。**\n\n**C. 当容量因子通过点样本上的矩形法则计算时，中心时间戳能保证对于任何平滑的可用率曲线都具有零偏差；开始和结束时间戳会产生大小相等、符号相反的一阶偏差，该偏差与局部时间导数成正比。因此，应始终在区间中心标记时间戳以消除偏差。**\n- “中心时间戳（中点法则）‘保证对于任何平滑’曲线都具有零偏差”的核心论点是错误的。如分析所示，误差与二阶导数 $a''(t)$ 成正比，并且对于任何非线性函数都不为零。虽然中点法则通常比左手或右手法则更准确，但它通常不是精确的。\n- **结论：不正确。**\n\n**D. 为避免重复计算，对于区间结束时间戳，应丢弃第一个报告的值，并对其余 $N-1$ 个值求和；这可以消除边界效应并确保容量因子无偏。**\n- “重复计算”的前提是错误的。Provider A 的关于区间 $(t_0, t_1], (t_1, t_2], \\dots, (t_{N-1}, t_N]$ 的数据是完全不相交的，并且覆盖了整个时间范围。丢弃第一个值意味着忽略了在第一个区间 $(0, t_1]$ 中产生的能量，这会引入显著的偏差。这个建议明显是错误的。\n- **结论：不正确。**\n\n**E. 在任何解释下，时间戳的选择都无关紧要，因为对一组固定的 $N$ 个值的求和对于重新标记是不变的；因此，容量因子不能依赖于开始、结束还是中心的约定，并且不需要对边界进行特殊处理。**\n- “在任何解释下”这个短语是一个致命的缺陷。对一个值的解释——是作为区间平均值还是点样本——是至关重要的。来自 Provider C 的值集（点样本）与来自 A 和 B 的值集（区间平均值）根本不同。“不需要对边界进行特殊处理”的说法也是错误和危险的，因为差一错误是常见且显著的偏差来源。这个陈述宣扬了一种危险的简单化观点。\n- **结论：不正确。**\n\n基于严谨的分析，只有选项 A 提供了对该问题的科学合理且完整的描述。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "掌握了数据表示的基础后，我们将从第一性原理出发，亲手构建一个可再生能源的可利用率时间序列。潮汐能是一种高度可预测的资源，其周期性源于天体运动的确定性规律。本练习  将指导您使用谐波分析方法，将主要潮汐分量（如M2、S2）合成为潮流速度时间序列，并进一步计算其动能功率流，从而将物理模型转化为可用于能源系统分析的精确数据。",
            "id": "4115872",
            "problem": "你的任务是使用谐波分析构建一个潮流可用性时间序列，并计算相应的动能功率通量时间序列。该构建必须依赖于潮汐分潮的标准表示法和运动流体的动能功率通量。从第一性原理出发，使用以下科学上已确立的出发点：\n- 任何稳态潮流信号都可以近似为一组有限谐波的总和。对于由 $j$ 索引的分潮，每个谐波分量的特征在于振幅 $A_j$（单位为 $\\mathrm{m/s}$）、相位 $\\phi_j$（单位为弧度）和角频率 $\\omega_j$（单位为弧度/小时）。沿固定轴的速度建模为\n$$\nv(t) \\;=\\; \\sum_{j} A_j \\cos\\!\\big(\\omega_j t + \\phi_j\\big),\n$$\n其中 $t$ 是以小时为单位的时间。\n- 密度为 $\\rho$、速度为 $|v|$ 的流体流的单位面积动能功率通量为\n$$\nP(t) \\;=\\; \\tfrac{1}{2}\\,\\rho\\,|v(t)|^3,\n$$\n其中 $\\rho$ 的单位为 $\\mathrm{kg/m^3}$，$P(t)$ 的单位为 $\\mathrm{W/m^2}$。使用 $\\rho = 1025$ $\\mathrm{kg/m^3}$（海水，国际单位制 (SI)）。\n\n要使用的谐波分潮是主要太阴半日分潮 ($\\mathrm{M2}$)、主要太阳半日分潮 ($\\mathrm{S2}$)、日月赤纬日分潮 ($\\mathrm{K1}$) 和主要太阴日分潮 ($\\mathrm{O1}$) 等分量。它们的以小时为单位的天文周期是：\n- $\\mathrm{M2}$：$T_{\\mathrm{M2}} = 12.4206012$，\n- $\\mathrm{S2}$：$T_{\\mathrm{S2}} = 12.0$，\n- $\\mathrm{K1}$：$T_{\\mathrm{K1}} = 23.93447213$，\n- $\\mathrm{O1}$：$T_{\\mathrm{O1}} = 25.81934166$。\n\n对每个分潮，角频率计算如下\n$$\n\\omega_j \\;=\\; \\frac{2\\pi}{T_j}\n\\quad\\text{(弧度/小时)}。\n$$\n\n将时间均匀离散化为\n$$\nt_k \\;=\\; k\\,\\Delta t,\\quad k \\in \\{0,1,2,\\dots,N-1\\},\n$$\n其中 $\\Delta t$ 是以小时为单位的时间步长，$N \\;=\\; \\left\\lfloor \\dfrac{T}{\\Delta t} \\right\\rfloor$ 是以小时为单位的时间范围 $T$ 内的样本数。使用离散时间算术平均值作为时间平均功率通量的估计量：\n$$\n\\overline{P} \\;=\\; \\frac{1}{N} \\sum_{k=0}^{N-1} P(t_k).\n$$\n\n角度单位：所有相位和角频率均以弧度为单位，$t$ 以小时为单位。速度必须以 $\\mathrm{m/s}$ 为单位，功率通量必须以 $\\mathrm{W/m^2}$ 表示。你的程序必须为下面的每个测试用例计算 $\\overline{P}$，并将每个结果以 $\\mathrm{W/m^2}$ 表示，四舍五入到恰好6位小数。\n\n使用以下四个案例组成的测试套件实现上述内容，每个案例由时间范围 $T$、时间步长 $\\Delta t$、振幅向量 $[A_{\\mathrm{M2}}, A_{\\mathrm{S2}}, A_{\\mathrm{K1}}, A_{\\mathrm{O1}}]$（单位 $\\mathrm{m/s}$）和相位向量 $[\\phi_{\\mathrm{M2}}, \\phi_{\\mathrm{S2}}, \\phi_{\\mathrm{K1}}, \\phi_{\\mathrm{O1}}]$（单位弧度）指定：\n- 案例 A（两个大小潮周期上的一般多谐波）：\n  - $T = 336.0$，$\\Delta t = 0.25$，\n  - $[A_{\\mathrm{M2}}, A_{\\mathrm{S2}}, A_{\\mathrm{K1}}, A_{\\mathrm{O1}}] = [1.0, 0.35, 0.25, 0.15]$,\n  - $[\\phi_{\\mathrm{M2}}, \\phi_{\\mathrm{S2}}, \\phi_{\\mathrm{K1}}, \\phi_{\\mathrm{O1}}] = [0.4, -1.1, 1.6, -0.3]$。\n- 案例 B（周期的整数倍的单分潮边界）：\n  - $T = 10 \\times 12.4206012$，$\\Delta t = 0.05$，\n  - $[A_{\\mathrm{M2}}, A_{\\mathrm{S2}}, A_{\\mathrm{K1}}, A_{\\mathrm{O1}}] = [1.5, 0.0, 0.0, 0.0]$,\n  - $[\\phi_{\\mathrm{M2}}, \\phi_{\\mathrm{S2}}, \\phi_{\\mathrm{K1}}, \\phi_{\\mathrm{O1}}] = [0.0, 0.0, 0.0, 0.0]$。\n- 案例 C（以日潮为主且带相位偏移）：\n  - $T = 168.0$，$\\Delta t = 0.2$，\n  - $[A_{\\mathrm{M2}}, A_{\\mathrm{S2}}, A_{\\mathrm{K1}}, A_{\\mathrm{O1}}] = [0.6, 0.3, 1.2, 0.8]$,\n  - $[\\phi_{\\mathrm{M2}}, \\phi_{\\mathrm{S2}}, \\phi_{\\mathrm{K1}}, \\phi_{\\mathrm{O1}}] = [\\pi/3, -\\pi/4, \\pi/2, -\\pi/6]$。\n- 案例 D（用于探测数值稳定性的近零振幅）：\n  - $T = 48.0$，$\\Delta t = 0.5$，\n  - $[A_{\\mathrm{M2}}, A_{\\mathrm{S2}}, A_{\\mathrm{K1}}, A_{\\mathrm{O1}}] = [0.01, 0.01, 0.01, 0.01]$,\n  - $[\\phi_{\\mathrm{M2}}, \\phi_{\\mathrm{S2}}, \\phi_{\\mathrm{K1}}, \\phi_{\\mathrm{O1}}] = [0.0, 0.0, 0.0, 0.0]$。\n\n你的程序应：\n- 使用指定的 $\\mathrm{M2}$、$\\mathrm{S2}$、$\\mathrm{K1}$、$\\mathrm{O1}$ 周期来构建 $\\omega_j$，\n- 为每个案例在均匀网格上构建 $v(t_k)$，\n- 使用 $\\rho = 1025$ $\\mathrm{kg/m^3}$ 计算 $P(t_k) = \\tfrac{1}{2}\\rho |v(t_k)|^3$，\n- 为每个案例计算 $\\overline{P}$ 并四舍五入到恰好6位小数。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $\\big[\\overline{P}_{\\mathrm{A}}, \\overline{P}_{\\mathrm{B}}, \\overline{P}_{\\mathrm{C}}, \\overline{P}_{\\mathrm{D}}\\big]$。例如，格式必须与 $\\big[1.234000,5.678900,2.500000,0.000001\\big]$ 完全一样，其中每个条目的单位都是 $\\mathrm{W/m^2}$。",
            "solution": "该问题是有效的，因为它有科学依据、适定、客观，并为直接的计算任务提供了一套完整、一致的规范。解决方案需要构建潮流速度时间序列，并随后计算平均动能功率通量。该过程遵循谐波分析和流体动力学的既定原理。\n\n基本原理是，一个稳态潮流信号可以表示为有限数量谐波分潮的叠加。沿固定轴在时间 $t$（小时）的速度 $v(t)$ 由以下总和给出：\n$$\nv(t) = \\sum_{j} A_j \\cos(\\omega_j t + \\phi_j)\n$$\n在此，$j$ 索引潮汐分潮（$\\mathrm{M2}$、$\\mathrm{S2}$、$\\mathrm{K1}$、$\\mathrm{O1}$）。对于每个分潮 $j$，$A_j$ 是速度振幅（单位 $\\mathrm{m/s}$），$\\phi_j$ 是相位偏移（单位弧度），$\\omega_j$ 是角频率（单位弧度/小时）。\n\n角频率 $\\omega_j$ 是根据每个分潮的天文周期 $T_j$ 使用以下关系导出的：\n$$\n\\omega_j = \\frac{2\\pi}{T_j}\n$$\n四个指定分潮的周期作为常数给出：\n- $T_{\\mathrm{M2}} = 12.4206012$ 小时\n- $T_{\\mathrm{S2}} = 12.0$ 小时\n- $T_{\\mathrm{K1}} = 23.93447213$ 小时\n- $T_{\\mathrm{O1}} = 25.81934166$ 小时\n\n动能功率通量 $P(t)$ 代表垂直于流向的单位面积上单位时间内流过的动能，其公式对于密度为 $\\rho$、速度为 $|v(t)|$ 的流体给出如下：\n$$\nP(t) = \\tfrac{1}{2}\\,\\rho\\,|v(t)|^3\n$$\n问题指定海水密度为 $\\rho = 1025$ $\\mathrm{kg/m^3}$。当速度单位为 $\\mathrm{m/s}$ 时，得到的功率通量 $P(t)$ 的单位是瓦特/平方米（$\\mathrm{W/m^2}$）。\n\n目标是计算在给定时间范围 $T$ 内的时间平均功率通量 $\\overline{P}$。由于 $|\\sum_j \\dots|^3$ 的平均值的解析解难以处理，因此采用基于离散时间平均的数值方法。时间被离散化为一个均匀网格：\n$$\nt_k = k\\,\\Delta t, \\quad \\text{for } k \\in \\{0, 1, 2, \\dots, N-1\\}\n$$\n其中 $\\Delta t$ 是以小时为单位的时间步长，$N$ 是样本总数，定义为：\n$$\nN = \\left\\lfloor \\frac{T}{\\Delta t} \\right\\rfloor\n$$\n然后使用 $N$ 个样本的离散时间算术平均值来估算平均功率通量 $\\overline{P}$：\n$$\n\\overline{P} = \\frac{1}{N} \\sum_{k=0}^{N-1} P(t_k) = \\frac{1}{N} \\sum_{k=0}^{N-1} \\left( \\tfrac{1}{2}\\,\\rho\\,|v(t_k)|^3 \\right)\n$$\n\n每个测试用例的计算算法如下：\n1.  **初始化**：从各自的周期 $T_j$ 预先计算 $\\mathrm{M2}$、$\\mathrm{S2}$、$\\mathrm{K1}$ 和 $\\mathrm{O1}$ 分潮的角频率 $\\omega_j$。\n2.  **时间离散化**：对于给定的时间范围 $T$ 和时间步长 $\\Delta t$ 的测试用例，计算样本数 $N$。生成一个长度为 $N$ 的时间向量 $t$，代表离散的时间点 $t_k$。\n3.  **速度时间序列构建**：初始化一个长度为 $N$ 的空速度向量 $v$。对于四个分潮中的每一个，计算其对速度的贡献 $A_j \\cos(\\omega_j t_k + \\phi_j)$（针对所有时间步长 $t_k$），并将其加到总速度向量 $v$ 中。\n4.  **功率通量计算**：通过取速度向量的绝对值 $|v(t_k)|$ 来找到瞬时速率。然后使用功率通量公式 $P(t_k) = \\frac{1}{2} \\rho |v(t_k)|^3$ 按元素计算功率通量时间序列 $P(t_k)$。\n5.  **求平均值**：通过计算功率通量时间序列向量 $P(t_k)$ 的算术平均值来计算平均功率通量 $\\overline{P}$。\n6.  **输出格式化**：对所有四个测试用例重复此过程。最终结果四舍五入到恰好6位小数，并格式化为指定的输出字符串。\n\n这个过程用高精度浮点运算实现，为每组输入参数产生一个确定性且可验证的结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the average tidal current power flux for specified harmonic constituents.\n    \"\"\"\n    # Define physical and numerical constants\n    RHO = 1025.0  # Density of seawater in kg/m^3\n\n    # Astronomical periods of the four principal tidal constituents in hours\n    # Order: M2, S2, K1, O1\n    PERIODS = np.array([\n        12.4206012,      # M2: Principal lunar semidiurnal\n        12.0,            # S2: Principal solar semidiurnal\n        23.93447213,     # K1: Luni-solar diurnal\n        25.81934166      # O1: Principal lunar diurnal\n    ], dtype=np.float64)\n    \n    # Calculate angular frequencies in radians per hour\n    OMEGAS = 2 * np.pi / PERIODS\n    \n    # Define the test suite as a list of tuples.\n    # Each tuple contains: (T, dt, Amplitudes, Phases)\n    test_cases = [\n        # Case A: General multiharmonic over two spring-neap cycles\n        (336.0, 0.25, [1.0, 0.35, 0.25, 0.15], [0.4, -1.1, 1.6, -0.3]),\n        \n        # Case B: Single-constituent boundary with integer multiples of the period\n        (10 * 12.4206012, 0.05, [1.5, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]),\n        \n        # Case C: Diurnal-dominated with phase offsets\n        (168.0, 0.2, [0.6, 0.3, 1.2, 0.8], [np.pi/3, -np.pi/4, np.pi/2, -np.pi/6]),\n        \n        # Case D: Near-zero amplitudes to probe numerical stability\n        (48.0, 0.5, [0.01, 0.01, 0.01, 0.01], [0.0, 0.0, 0.0, 0.0])\n    ]\n\n    results = []\n    \n    for T_horizon, dt, amps_list, phases_list in test_cases:\n        amps = np.array(amps_list, dtype=np.float64)\n        phases = np.array(phases_list, dtype=np.float64)\n        \n        # 1. Discretize time\n        # N is the number of samples for the given horizon T and time step dt.\n        N = int(np.floor(T_horizon / dt))\n        # t is the time vector from t=0 to t=(N-1)*dt.\n        t = np.arange(N, dtype=np.float64) * dt\n        \n        # 2. Calculate velocity time series v(t)\n        # Initialize velocity vector with zeros. Use float64 for precision.\n        v = np.zeros(N, dtype=np.float64)\n        \n        # Sum the contributions of each harmonic constituent\n        for j in range(len(OMEGAS)):\n            # Add component v_j(t) = A_j * cos(omega_j * t + phi_j)\n            v += amps[j] * np.cos(OMEGAS[j] * t + phases[j])\n            \n        # 3. Calculate power flux time series P(t)\n        # P(t) = 1/2 * rho * |v(t)|^3\n        # np.abs() calculates the speed |v(t)| from the 1D velocity v(t).\n        P = 0.5 * RHO * np.power(np.abs(v), 3)\n        \n        # 4. Compute average power flux\n        # Use the discrete arithmetic mean as the estimator for the time-average.\n        P_avg = np.mean(P)\n        results.append(P_avg)\n\n    # Format the final results to exactly 6 decimal places and print\n    # in the required format: [result_A,result_B,result_C,result_D]\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在能源系统建模中，我们经常需要在不同时间分辨率的数据之间进行转换，以匹配模型的尺度要求，例如，将高频的15分钟数据聚合为小时数据。在这一过程中，必须保证像能量这样的基本物理量在转换前后是守恒的。本练习  将让您设计并实现一个能量守恒的重采样方案，以确保数据在时间尺度变换时不会引入人为的能量增益或损失，这是保证模型物理一致性的核心要求。",
            "id": "4115891",
            "problem": "您的任务是在能源系统建模的背景下，设计并实现一个在季度小时（15分钟）可用性剖面和小时可用性剖面之间进行能量守恒的重采样和插值方案。考虑一个功率时间序列，表示为函数 $P(t)$，单位为千瓦 (kW)，其中 $t$ 是以小时为单位的时间。在区间 $[a,b]$ 上的能量定义为 $E_{[a,b]} = \\int_a^b P(t)\\, dt$，单位为千瓦时 (kWh)。在离散时间下，对于均匀的采样间隔 $\\Delta t$，一个常见的建模假设是 $P(t)$ 在每个采样间隔上是分段常数。在此假设下，一组间隔上的能量由黎曼和 $E = \\sum_i P_i \\Delta t$ 给出，其中 $P_i$ 是间隔 $i$ 上的恒定功率。\n\n您的程序必须构建一个方案，在进行以下转换时能够保持能量（即功率的时间积分）守恒：\n- 从季度小时（$\\Delta t = 0.25$ 小时）转换为小时（$\\Delta t = 1$ 小时），以及\n- 从小时转换为季度小时。\n\n您必须遵守以下科学约束：\n- 从季度小时降采样到小时必须产生一个小时时间序列 $\\{\\hat{P}_h\\}$，其中每个 $\\hat{P}_h$ 是小时平均功率，使得该小时的能量等于该小时内各季度小时能量的总和。\n- 从小时升采样到季度小时必须产生一个季度小时时间序列 $\\{p_{h,j}\\}$（每小时 $j=1,\\dots,4$），该序列在每个小时内都保持小时能量守恒。\n\n定义和要求：\n- 令 $P_k$ 表示季度小时功率样本（单位为 kW），其中 $k$ 为一天中季度小时的索引（共 $96$ 个样本）。\n- 令 $\\hat{P}_h$ 表示小时功率样本（单位为 kW），其中 $h$ 为一天中小时的索引（共 $24$ 个样本）。\n- 季度小时能量为 $E_{\\text{15min}} = \\sum_{k=0}^{95} P_k \\cdot 0.25$，单位为 kWh。\n- 小时能量为 $E_{\\text{hour}} = \\sum_{h=0}^{23} \\hat{P}_h \\cdot 1$，单位为 kWh。\n- 任何三角函数中使用的角度必须以弧度为单位。\n\n您的程序必须实现：\n1. 一个函数，输入季度小时序列 $\\{P_k\\}$，返回小时序列 $\\{\\hat{P}_h\\}$，使得从 $15$ 分钟聚合到 $1$ 小时时能量守恒。\n2. 一个函数，输入小时序列 $\\{\\hat{P}_h\\}$，返回季度小时序列 $\\{p_{h,j}\\}$，使得从 $1$ 小时分解到 $15$ 分钟时能量守恒。\n\n测试套件：\n实现以下测试用例以验证能量守恒。对于每个用例，计算原始序列与经过应保持能量守恒的往返转换后得到的序列之间的总能量绝对差值（单位为 kWh）。每个测试用例应产生一个浮点数（单位为 kWh）。您的最终输出必须是单行文本，包含所有结果，以逗号分隔并用方括号括起来。\n\n季度小时到小时再到季度小时 (15→60→15)：\n- 测试 $1$（类太阳能季度小时剖面）：令 $P_{\\max} = 100$ (kW)。对于 $t_k = k \\cdot 0.25$，$k \\in \\{0,1,\\dots,95\\}$，定义 $P_k = \\max\\{0, P_{\\max} \\cdot \\sin\\left(\\pi \\cdot \\frac{t_k - 6}{12}\\right)\\}$，适用于 $t_k \\in [0,24)$，角度以弧度为单位。\n- 测试 $2$（单小时线性斜坡季度小时剖面）：在第 $8$ 小时到第 $9$ 小时期间定义一个从 $0$ (kW) 到 $80$ (kW) 的线性斜坡。通过使用 $[8,9)$ 小时内每个季度小时子区间的中点，将 $P_k$ 表示为每个子区间的平均功率，从而仅在 $[8,9)$ 时间段内产生 $10$、$30$、$50$ 和 $70$ (kW) 的季度小时值；在其他时间 $P_k = 0$ (kW)。\n- 测试 $3$（恒定季度小时剖面）：对于所有 $k$，$P_k = 50$ (kW)。\n- 测试 $4$（确定性伪随机季度小时剖面）：使用固定种子生成 $96$ 个在 $[0,100]$ (kW) 范围内均匀分布的确定性样本。\n\n小时到季度小时再到小时 (60→15→60)：\n- 测试 $5$（三角小时剖面）：对于 $h \\in \\{0,1,\\dots,23\\}$，定义 $\\hat{P}_h = \\max\\{0, 100 \\cdot (1 - |h - 12|/6)\\}$ (kW)。\n- 测试 $6$（尖峰小时剖面）：对于 $h \\in \\{0,1,\\dots,23\\}$，如果 $h$ 是偶数，则定义 $\\hat{P}_h = 100$ (kW)，如果 $h$ 是奇数，则 $\\hat{P}_h = 0$ (kW)。\n\n单位要求：\n- 所有功率值必须解释为千瓦 (kW)。\n- 所有能量值必须以千瓦时 (kWh) 计算和报告。\n- 所有三角函数的角度必须以弧度为单位。\n- 程序必须计算往返转换的总能量绝对差值，并以 kWh 为单位报告。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按顺序排列的 $6$ 个测试的结果，结果为逗号分隔的列表，并用方括号括起来。例如，格式必须为 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_i$ 是一个浮点数（单位为 kWh）。",
            "solution": "问题要求设计并实现一个用于功率时间序列在季度小时和小时分辨率之间转换的能量守恒重采样方案。核心原理是能量守恒，其定义为功率的时间积分，$E = \\int P(t) dt$。对于在持续时间为 $\\Delta t$ 的采样间隔上假设功率为分段常数的离散时间序列，该积分变为一个和：$E = \\sum_i P_i \\Delta t$。\n\n首先，我们为两个所需的转换函数建立数学形式。\n\n**1. 降采样：季度小时到小时 (15分钟 → 60分钟)**\n\n令 $\\{P_k\\}_{k=0}^{95}$ 为时间步长为 $\\Delta t_{15} = 0.25$ 小时的季度小时功率序列。令 $\\{\\hat{P}_h\\}_{h=0}^{23}$ 为相应的时间步长为 $\\Delta t_{60} = 1.0$ 小时的小时功率序列。\n\n能量守恒约束要求，无论使用何种分辨率，在任何给定小时内计算的能量都是相同的。对于任意小时 $h$（其中 $h \\in \\{0, 1, \\dots, 23\\}$），根据小时序列计算的能量为：\n$$E_{h, \\text{hourly}} = \\hat{P}_h \\cdot \\Delta t_{60} = \\hat{P}_h \\cdot 1$$\n\n同一个小时 $h$ 对应四个季度小时区间，其索引为 $k = 4h, 4h+1, 4h+2,$ 和 $4h+3$。根据季度小时序列计算的该小时内的总能量是这四个区间能量的总和：\n$$E_{h, \\text{15min}} = \\sum_{j=0}^{3} P_{4h+j} \\cdot \\Delta t_{15} = \\left( P_{4h} + P_{4h+1} + P_{4h+2} + P_{4h+3} \\right) \\cdot 0.25$$\n\n将两个能量表达式相等（$E_{h, \\text{hourly}} = E_{h, \\text{15min}}$），得到确定小时功率值 $\\hat{P}_h$ 的规则：\n$$\\hat{P}_h \\cdot 1 = \\left( P_{4h} + P_{4h+1} + P_{4h+2} + P_{4h+3} \\right) \\cdot 0.25$$\n$$\\hat{P}_h = \\frac{P_{4h} + P_{4h+1} + P_{4h+2} + P_{4h+3}}{4}$$\n\n这表明，保持能量守恒的降采样操作等同于取每小时内四个季度小时功率值的算术平均值。\n\n**2. 升采样：小时到季度小时 (60分钟 → 15分钟)**\n\n令 $\\{\\hat{P}_h\\}_{h=0}^{23}$ 为小时功率序列。我们需要确定一个季度小时序列 $\\{P_k\\}_{k=0}^{95}$，它在每个小时内都保持能量守恒。小时 $h$ 的能量守恒方程与之前相同：\n$$\\hat{P}_h = \\frac{1}{4} \\sum_{j=0}^{3} P_{4h+j}$$\n\n对于每个小时 $h$，这是一个有四个未知数 $\\{P_{4h}, P_{4h+1}, P_{4h+2}, P_{4h+3}\\}$ 的单线性方程。这是一个欠定系统，有无限多解。为了选择一个唯一解，需要一个额外的假设。问题从一开始就指出，功率 $P(t)$ 在每个采样间隔上被建模为分段常数。对于升采样，最简单且最一致的选择是扩展这个假设，假定小时功率值 $\\hat{P}_h$ 代表了整个小时内的恒定功率水平。这导致了以下规则：\n$$P_k = \\hat{P}_{\\lfloor k/4 \\rfloor}$$\n\n换句话说，给定小时内的所有四个季度小时功率值都设置为该小时的功率值：\n$$P_{4h} = P_{4h+1} = P_{4h+2} = P_{4h+3} = \\hat{P}_h$$\n这个选择满足能量守恒约束，因为 $\\frac{1}{4}(\\hat{P}_h + \\hat{P}_h + \\hat{P}_h + \\hat{P}_h) = \\hat{P}_h$。该方法，也称为零阶保持或最近邻插值，是所选的升采样方案。\n\n**3. 往返能量守恒分析**\n\n问题要求计算往返转换后的总能量绝对差值。\n\n**情况 A：15分钟 → 60分钟 → 15分钟**\n- 初始的季度小时序列 $\\{P_k\\}$ 被降采样为小时序列 $\\{\\hat{P}_h\\}$，其中 $\\hat{P}_h = \\frac{1}{4}\\sum_{j=0}^{3} P_{4h+j}$。\n- 这个小时序列随后被升采样为一个新的季度小时序列 $\\{P'_k\\}$，其中 $P'_k = \\hat{P}_{\\lfloor k/4 \\rfloor}$。\n- 原始序列的总能量是 $E_{\\text{orig}} = \\Delta t_{15} \\sum_{k=0}^{95} P_k = 0.25 \\sum_{k=0}^{95} P_k$。\n- 重建序列的总能量是 $E_{\\text{recon}} = \\Delta t_{15} \\sum_{k=0}^{95} P'_k$。\n代入定义：\n$$E_{\\text{recon}} = 0.25 \\sum_{h=0}^{23} \\sum_{j=0}^{3} P'_{4h+j} = 0.25 \\sum_{h=0}^{23} \\sum_{j=0}^{3} \\hat{P}_h = 0.25 \\sum_{h=0}^{23} 4\\hat{P}_h = \\sum_{h=0}^{23} \\hat{P}_h$$\n现在，代入 $\\hat{P}_h$ 的公式：\n$$E_{\\text{recon}} = \\sum_{h=0}^{23} \\left( \\frac{1}{4}\\sum_{j=0}^{3} P_{4h+j} \\right) = 0.25 \\sum_{h=0}^{23} \\sum_{j=0}^{3} P_{4h+j} = 0.25 \\sum_{k=0}^{95} P_k = E_{\\text{orig}}$$\n因此，对于这次往返转换，总能量在分析上是守恒的，绝对差值 $|E_{\\text{orig}} - E_{\\text{recon}}|$ 为 $0$。\n\n**情况 B：60分钟 → 15分钟 → 60分钟**\n- 初始的小时序列 $\\{\\hat{P}_h\\}$ 被升采样为季度小时序列 $\\{P_k\\}$，其中 $P_k = \\hat{P}_{\\lfloor k/4 \\rfloor}$。\n- 这个季度小时序列随后被降采样为一个新的小时序列 $\\{\\hat{P}'_h\\}$。\n$$\\hat{P}'_h = \\frac{1}{4}\\sum_{j=0}^{3} P_{4h+j} = \\frac{1}{4}\\left(\\hat{P}_h + \\hat{P}_h + \\hat{P}_h + \\hat{P}_h\\right) = \\hat{P}_h$$\n重建的小时序列 $\\{\\hat{P}'_h\\}$ 与原始序列 $\\{\\hat{P}_h\\}$ 完全相同。因此，它们的总能量 $E_{\\text{recon}} = \\sum \\hat{P}'_h \\cdot 1$ 和 $E_{\\text{orig}} = \\sum \\hat{P}_h \\cdot 1$ 也完全相同。绝对差值 $|E_{\\text{orig}} - E_{\\text{recon}}|$ 也为 $0$。\n\n实现将为各种测试剖面计算这些差异。任何非零结果都将归因于浮点运算误差。",
            "answer": "```python\nimport numpy as np\n\ndef downsample_15_to_60(p_15min: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Downsamples a quarter-hour power series to an hourly series by averaging.\n    This preserves energy as per the derivation.\n    \"\"\"\n    if p_15min.shape != (96,):\n        raise ValueError(\"Input must be a numpy array of shape (96,).\")\n    # Reshape the 96-sample series into 24 hours of 4 quarter-hour samples\n    # and compute the mean for each hour.\n    return p_15min.reshape(24, 4).mean(axis=1)\n\ndef upsample_60_to_15(p_60min: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Upsamples an hourly power series to a quarter-hour series by repetition.\n    This preserves energy under the piecewise-constant power assumption.\n    \"\"\"\n    if p_60min.shape != (24,):\n        raise ValueError(\"Input must be a numpy array of shape (24,).\")\n    # Repeat each hourly value 4 times to create the quarter-hour series.\n    return p_60min.repeat(4)\n\ndef calculate_energy(power_series: np.ndarray, dt: float) -> float:\n    \"\"\"\n    Calculates the total energy for a time series with a given time step.\n    \"\"\"\n    return np.sum(power_series) * dt\n\ndef solve():\n    \"\"\"\n    Runs the test suite and computes the energy differences for round-trip conversions.\n    \"\"\"\n    results = []\n    \n    # --- Test Cases 1-4: 15-min -> 60-min -> 15-min ---\n\n    # Test 1: Solar-like quarter-hour profile\n    k = np.arange(96)\n    t_k = k * 0.25\n    p15_orig_1 = np.maximum(0, 100.0 * np.sin(np.pi * (t_k - 6.0) / 12.0))\n    \n    # Test 2: Single-hour linear ramp quarter-hour profile\n    p15_orig_2 = np.zeros(96)\n    p15_orig_2[32:36] = [10.0, 30.0, 50.0, 70.0]\n\n    # Test 3: Constant quarter-hour profile\n    p15_orig_3 = np.full(96, 50.0)\n\n    # Test 4: Deterministic pseudo-random quarter-hour profile\n    np.random.seed(42)\n    p15_orig_4 = np.random.uniform(0.0, 100.0, 96)\n\n    test_cases_15min = [p15_orig_1, p15_orig_2, p15_orig_3, p15_orig_4]\n\n    for p15_orig in test_cases_15min:\n        E_orig = calculate_energy(p15_orig, 0.25)\n        p60_resampled = downsample_15_to_60(p15_orig)\n        p15_recon = upsample_60_to_15(p60_resampled)\n        E_recon = calculate_energy(p15_recon, 0.25)\n        diff = np.abs(E_orig - E_recon)\n        results.append(diff)\n        \n    # --- Test Cases 5-6: 60-min -> 15-min -> 60-min ---\n\n    # Test 5: Triangular hourly profile\n    h = np.arange(24)\n    p60_orig_5 = np.maximum(0, 100.0 * (1.0 - np.abs(h - 12.0) / 6.0))\n\n    # Test 6: Spiky hourly profile\n    p60_orig_6 = 100.0 * (h % 2 == 0)\n\n    test_cases_60min = [p60_orig_5, p60_orig_6]\n\n    for p60_orig in test_cases_60min:\n        E_orig = calculate_energy(p60_orig, 1.0)\n        p15_resampled = upsample_60_to_15(p60_orig)\n        p60_recon = downsample_15_to_60(p15_resampled)\n        E_recon = calculate_energy(p60_recon, 1.0)\n        diff = np.abs(E_orig - E_recon)\n        results.append(diff)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}