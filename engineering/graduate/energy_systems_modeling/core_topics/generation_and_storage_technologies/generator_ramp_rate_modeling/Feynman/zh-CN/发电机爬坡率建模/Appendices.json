{
    "hands_on_practices": [
        {
            "introduction": "对发电机斜率的理解始于单个机组的基本控制问题。本练习要求您推导出发电机在满足其自身物理斜率限制和外部电网约束的条件下，实现功率最优时间转换的轨迹 。解决此问题将帮助您建立关于约束如何塑造发电机可行运行区间以及如何最大化其响应速度的深刻直觉。",
            "id": "4093099",
            "problem": "单个发电机组具有连续时间有功功率输出轨迹$P(t)$（单位为$\\mathrm{MW}$），并受到对称爬坡率限制，表示为$|\\dot{P}(t)| \\le r$，其中$r$是一个正常数（单位为$\\mathrm{MW}/\\mathrm{min}$）。该发电机必须在最短的允许时间$T$内，从初始运行点$P(0)=P_0$移动到目标$P(T)=P_f$，同时遵守由状态约束$P(t) \\le \\bar{P}(t)$给出的时变注入输电上限。该上限为\n$$\n\\bar{P}(t)=\n\\begin{cases}\nP_b,  0 \\le t \\le \\tau,\\\\\nP_{\\max},  t > \\tau,\n\\end{cases}\n$$\n其中$P_{\\max} \\ge P_f$，因此在时间$\\tau$之后，该上限不具约束力。假设该发电机除了非负性之外没有最小功率限制，并且$P_f > P_0$。仅使用爬坡率的定义和一阶系统时间最优控制的第一性原理。\n\n给定数值参数$P_0=160\\ \\mathrm{MW}$，$P_f=300\\ \\mathrm{MW}$，$r=12\\ \\mathrm{MW}/\\mathrm{min}$，$P_b=200\\ \\mathrm{MW}$，$\\tau=6\\ \\mathrm{min}$，以及$P_{\\max}=400\\ \\mathrm{MW}$：\n\n- 构建一个显式的连续时间分段线性轨迹$P(t)$，该轨迹对所有$t \\ge 0$满足$|\\dot{P}(t)| \\le r$和$P(t) \\le \\bar{P}(t)$，并在最短的允许时间内达到$P(T)=P_f$。\n- 从第一性原理证明，为何在这些约束下的所有可行轨迹中，你的轨迹是时间最优的。\n\n从$P_0$到达$P_f$所需的最小时间$T^{\\star}$（以$\\mathrm{min}$表示）是多少？你的最终答案必须是单个数字。不要四舍五入；提供精确值。",
            "solution": "该问题是一个带状态约束的一阶系统时间最优控制问题。系统方程为$\\dot{P}(t) = u(t)$，其中$P(t)$是发电机的功率输出，而$u(t)$是控制变量，代表爬坡率。\n\n**问题验证**\n\n首先，对问题陈述进行验证。\n已知条件如下：\n- 状态变量：有功功率$P(t)$，单位为$\\mathrm{MW}$。\n- 系统动力学：$\\dot{P}(t) = u(t)$。\n- 控制约束：$|u(t)| = |\\dot{P}(t)| \\le r$，其中$r = 12 \\ \\mathrm{MW}/\\mathrm{min}$。\n- 状态约束：$P(t) \\le \\bar{P}(t)$，其中$\\bar{P}(t)$是一个分段常数函数。\n- 初始条件：$P(0) = P_0 = 160 \\ \\mathrm{MW}$。\n- 终端条件：$P(T) = P_f = 300 \\ \\mathrm{MW}$。\n- 目标：最小化最终时间$T$。\n- 状态约束函数为$\\bar{P}(t) = \\begin{cases} P_b,  0 \\le t \\le \\tau \\\\ P_{\\max},  t > \\tau \\end{cases}$，其中$P_b = 200 \\ \\mathrm{MW}$，$\\tau = 6 \\ \\mathrm{min}$，以及$P_{\\max} = 400 \\ \\mathrm{MW}$。\n- 其他条件：$P_f > P_0$且$P_{\\max} \\ge P_f$。\n\n该问题在电力系统工程中有科学依据，代表一个简化但标准的发电机调度问题。它是适定的，具有明确的目标，以及一套完整且一致的约束和数值数据。语言客观而精确。因此，该问题被认为是有效且可解的。\n\n**从第一性原理证明最优轨迹**\n\n目标是在最短时间内将状态变量$P(t)$从$P_0$增加到$P_f$。对于系统$\\dot{P}(t) = u(t)$且$|u(t)| \\le r$，时间最优控制原理规定状态变量必须尽可能快地变化。由于$P_f > P_0$，这意味着只要可行，控制应处于其正向最大值，即$u(t) = \\dot{P}(t) = r$。\n\n状态约束$P(t) \\le \\bar{P}(t)$可能会阻止系统始终保持$\\dot{P}(t) = r$。因此，最优策略是遵循一种“贪心”方法：在任何时间$t$，发电机的功率输出$P(t)$应该是从$P_0$出发，在不违反任何过去或现在约束的情况下可以达到的最大可能值。这意味着轨迹将始终位于$(t, P)$平面中可行区域的上边界。这个边界由最大爬坡曲线$P_0 + rt$和状态约束上限$\\bar{P}(t)$形成。\n\n**最优轨迹的构建**\n\n我们遵循上述原则，分段构建最优轨迹$P^*(t)$。\n\n**阶段1：初始爬坡**\n发电机从$P(0) = P_0 = 160 \\ \\mathrm{MW}$开始，并以其最大速率$r = 12 \\ \\mathrm{MW}/\\mathrm{min}$爬坡。轨迹为：\n$$ P(t) = P_0 + rt = 160 + 12t $$\n这个过程一直持续到满足一个约束为止。第一个相关的约束是输电上限$P(t) \\le P_b = 200 \\ \\mathrm{MW}$，它在$t \\in [0, \\tau]$期间有效。我们找到轨迹与此上限相交的时间$t_1$：\n$$ 160 + 12t_1 = 200 \\implies 12t_1 = 40 \\implies t_1 = \\frac{40}{12} = \\frac{10}{3} \\ \\mathrm{min} $$\n由于$t_1 \\approx 3.33 \\ \\mathrm{min}$小于$\\tau = 6 \\ \\mathrm{min}$，发电机触及了此上限。\n对于$t \\in [0, \\frac{10}{3}]$，最优轨迹是$P^*(t) = 160 + 12t$。在$t_1 = \\frac{10}{3} \\ \\mathrm{min}$时，功率为$P^*(t_1) = 200 \\ \\mathrm{MW}$。\n\n**阶段2：保持在输电上限**\n对于$t > t_1$，继续爬坡将违反$P(t) \\le P_b$。为了保持在最优路径上（即在尽可能高的功率下），发电机必须将其输出维持在上限水平。这需要爬坡率为$\\dot{P}(t) = 0$，这是有效的，因为$|0| \\le r$。此阶段一直持续到$t = \\tau = 6 \\ \\mathrm{min}$时上限被提高为止。\n对于$t \\in (\\frac{10}{3}, 6]$，最优轨迹是$P^*(t) = P_b = 200 \\ \\mathrm{MW}$。\n\n**阶段3：向目标最终爬坡**\n在$t = \\tau = 6 \\ \\mathrm{min}$时，发电机的功率是$P^*(\\tau) = 200 \\ \\mathrm{MW}$。上限提高到$P_{\\max} = 400 \\ \\mathrm{MW}$。由于目标是$P_f = 300 \\ \\mathrm{MW}$且$P_f  P_{\\max}$，现在到达目标的路径不再受上限约束。为了在最短时间内达到$P_f$，发电机必须以最大速率$r$重新开始爬坡。对于$t > 6 \\ \\mathrm{min}$的轨迹是：\n$$ P(t) = P^*(\\tau) + r(t - \\tau) = 200 + 12(t - 6) $$\n我们通过设置$P(T^{\\star}) = P_f$来找到最终时间$T^{\\star}$：\n$$ 200 + 12(T^{\\star} - 6) = 300 $$\n$$ 12(T^{\\star} - 6) = 100 $$\n$$ T^{\\star} - 6 = \\frac{100}{12} = \\frac{25}{3} $$\n$$ T^{\\star} = 6 + \\frac{25}{3} = \\frac{18}{3} + \\frac{25}{3} = \\frac{43}{3} \\ \\mathrm{min} $$\n\n完整的、分段线性的、连续时间的轨迹是：\n$$\nP^*(t) =\n\\begin{cases}\n160 + 12t,   0 \\le t \\le \\frac{10}{3} \\\\\n200,   \\frac{10}{3}  t \\le 6 \\\\\n200 + 12(t-6),   6  t \\le \\frac{43}{3}\n\\end{cases}\n$$\n该轨迹是可行的，对所有$t \\in [0, T^{\\star}]$满足$|\\dot{P}^*(t)| \\le r$和$P^*(t) \\le \\bar{P}(t)$，并在时间$T^{\\star} = \\frac{43}{3} \\ \\mathrm{min}$到达$P_f$。\n\n**最优性证明**\n设$\\tilde{P}(t)$是任何其他从$P(0)=P_0$开始并在时间$\\tilde{T}$到达$P_f$的可行轨迹。根据定义，它必须对所有$t$满足$\\dot{\\tilde{P}}(t) \\le r$和$\\tilde{P}(t) \\le \\bar{P}(t)$。\n对于任何$t \\ge 0$，$\\tilde{P}(t) = P_0 + \\int_0^t \\dot{\\tilde{P}}(s) ds \\le P_0 + \\int_0^t r ds = P_0 + rt$。\n在阶段1中，$P^*(t) = P_0 + rt$，所以$\\tilde{P}(t) \\le P^*(t)$。\n在阶段2中，$\\tilde{P}(t) \\le \\bar{P}(t) = P_b$。由于在此区间内$P^*(t) = P_b$，我们再次得到$\\tilde{P}(t) \\le P^*(t)$。\n在阶段3中，我们有$\\tilde{P}(\\tau) \\le P^*(\\tau) = P_b$。对于$t > \\tau$，$\\tilde{P}(t) = \\tilde{P}(\\tau) + \\int_\\tau^t \\dot{\\tilde{P}}(s) ds \\le P^*(\\tau) + \\int_\\tau^t r ds = P^*(t)$。\n因此，对于所有$t \\ge 0$，有$\\tilde{P}(t) \\le P^*(t)$。\n现在，为得出矛盾，假设$\\tilde{T}  T^{\\star}$。那么$\\tilde{P}(\\tilde{T}) = P_f$。我们也有$\\tilde{P}(\\tilde{T}) \\le P^*(\\tilde{T})$。这意味着$P_f \\le P^*(\\tilde{T})$。\n然而，由于$\\tilde{T}  T^{\\star}$且$P^*(t)$在区间$(6, T^{\\star}]$上是严格递增的，我们必有$P^*(\\tilde{T})  P^*(T^{\\star}) = P_f$。\n这导致了$P_f  P_f$的矛盾。因此，假设$\\tilde{T}  T^{\\star}$是错误的。必然有$\\tilde{T} \\ge T^{\\star}$，这证明了$T^{\\star}$是最小时间。\n\n所需的最小时间为$T^{\\star}$。\n$$ T^{\\star} = \\frac{43}{3} \\ \\mathrm{min} $$",
            "answer": "$$\\boxed{\\frac{43}{3}}$$"
        },
        {
            "introduction": "在掌握了单个发电机斜率能力的概念后，本练习将重点转向系统层面的经济调度问题。当存在多个成本和能力各异的发电机时，系统运营商应如何以最低成本来满足整个系统的爬坡需求 ？本练习将引导您应用经济调度的核心原理，展示如何通过等边际成本这一关键概念，在发电机组间实现高效的最优资源分配。",
            "id": "4093106",
            "problem": "考虑一个专注于发电机上调爬坡率备用分配的能源系统建模任务。现有$n$台火力发电机组，索引为$i \\in \\{1, \\dots, n\\}$。每台机组的上调爬坡率能力为$RU_i$，单位为$\\mathrm{MW/min}$。一个独立系统运营商必须为单个调度区间内的每台机组分配上调爬坡备用$x_i$（单位为$\\mathrm{MW/min}$），以满足系统级的上调爬坡备用需求$R$（单位为$\\mathrm{MW/min}$）。分配必须对所有机组满足$0 \\leq x_i \\leq RU_i$且$\\sum_{i=1}^{n} x_i = R$。\n\n每台机组的上调爬坡备用会产生严格凸的成本，由$C_i(x_i) = \\frac{1}{2} q_i x_i^2 + c_i x_i$给出，其中$q_i > 0$的单位是美元/($\\mathrm{MW/min})^2$，$c_i \\geq 0$的单位是美元/$\\mathrm{MW/min}$。目标是确定分配向量$\\mathbf{x} = (x_1, \\dots, x_n)$，以在满足上述约束条件的情况下，最小化总备用成本$\\sum_{i=1}^{n} C_i(x_i)$。\n\n您必须从约束优化和微积分的基本定律与核心定义（例如，边际成本作为成本函数的导数的概念，以及线性不等式约束中的可行性）出发，推导出算法方法，然后实现一个完整的、可运行的程序，为所提供的每个测试用例计算最优分配$\\mathbf{x}$。您还必须在您的解法中运用边际分析，为最终的调度结果提供有原则的论证。不得在没有推导的情况下使用任何快捷公式；您必须从第一性原理出发推导您的方法。\n\n假设：\n- 对所有$i$，$q_i > 0$。\n- 需求$R$满足$0 \\leq R \\leq \\sum_{i=1}^{n} RU_i$（即可行性）。\n- 所有输入都是确定性的，代表单个调度区间，且每个$x_i$在其界限内是连续的。\n\n您的程序必须实现一个鲁棒的数值过程来获得$\\mathbf{x}$，使等式约束$\\sum_{i=1}^{n} x_i = R$在$10^{-9}$的数值公差内得以满足。\n\n物理单位：\n- 以$\\mathrm{MW/min}$为单位表示每个分配$x_i$。\n- 在最终输出中，将每个$x_i$打印为小数点后恰好有$6$位数字的十进制浮点数。\n\n测试套件：\n为以下四种情况计算最优分配。每种情况由元组$(\\{RU_i\\}_{i=1}^{n}, \\{q_i\\}_{i=1}^{n}, \\{c_i\\}_{i=1}^{n}, R)$指定。\n\n- 情况 1：$n = 3$, $RU = [\\,30,\\,20,\\,10\\,]$ $\\mathrm{MW/min}$, $q = [\\,0.8,\\,0.4,\\,1.2\\,]$ 美元/($\\mathrm{MW/min})^2$, $c = [\\,4.0,\\,3.0,\\,5.5\\,]$ 美元/$\\mathrm{MW/min}$, $R = 35$ $\\mathrm{MW/min}$。\n- 情况 2：$n = 2$, $RU = [\\,15,\\,15\\,]$ $\\mathrm{MW/min}$, $q = [\\,0.5,\\,0.5\\,]$ 美元/($\\mathrm{MW/min})^2$, $c = [\\,2.0,\\,2.0\\,]$ 美元/$\\mathrm{MW/min}$, $R = 0$ $\\mathrm{MW/min}$。\n- 情况 3：$n = 4$, $RU = [\\,5,\\,10,\\,15,\\,20\\,]$ $\\mathrm{MW/min}$, $q = [\\,1.0,\\,0.2,\\,0.6,\\,0.4\\,]$ 美元/($\\mathrm{MW/min})^2$, $c = [\\,3.5,\\,2.0,\\,2.5,\\,3.0\\,]$ 美元/$\\mathrm{MW/min}$, $R = 50$ $\\mathrm{MW/min}$。\n- 情况 4：$n = 4$, $RU = [\\,50,\\,5,\\,0,\\,40\\,]$ $\\mathrm{MW/min}$, $q = [\\,0.1,\\,1.5,\\,0.8,\\,0.3\\,]$ 美元/($\\mathrm{MW/min})^2$, $c = [\\,1.0,\\,10.0,\\,2.0,\\,1.5\\,]$ 美元/$\\mathrm{MW/min}$, $R = 60$ $\\mathrm{MW/min}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来，其中每个元素是代表一个案例的最优分配$\\mathbf{x}$的内部列表，单位为$\\mathrm{MW/min}$，每个值都打印为小数点后恰好有$6$位数字。例如，输出应具有$[\\,[x_{1,1},x_{1,2},\\dots],\\,[x_{2,1},x_{2,2},\\dots],\\,\\dots\\,]$的形式，行内任何地方都没有空格。",
            "solution": "用户提供的问题是能源系统建模领域中一个适定（well-posed）且具有科学依据的问题，具体涉及爬坡率备用的经济调度。这是一个经典的凸优化问题，可以使用约束优化的原理来解决。\n\n### 第1步：提取已知信息\n- **索引**：$n$台发电机组，索引为$i \\in \\{1, \\dots, n\\}$。\n- **每台机组$i$的参数**：\n    - 上调爬坡率能力：$RU_i$ [$\\mathrm{MW/min}$]\n    - 成本函数系数：$q_i > 0$ [美元/($\\mathrm{MW/min})^2$]和$c_i \\geq 0$ [美元/$\\mathrm{MW/min}$]。\n- **系统级需求**：\n    - 总上调爬坡备用需求：$R$ [$\\mathrm{MW/min}$]。\n- **决策变量**：\n    - 机组$i$的上调爬坡备用分配：$x_i$ [$\\mathrm{MW/min}$]。分配向量为$\\mathbf{x} = (x_1, \\dots, x_n)$。\n- **目标函数**：\n    - 最小化总成本：$\\sum_{i=1}^{n} C_i(x_i)$，其中$C_i(x_i) = \\frac{1}{2} q_i x_i^2 + c_i x_i$。\n- **约束条件**：\n    - 系统需求：$\\sum_{i=1}^{n} x_i = R$。\n    - 单机能力：对所有$i \\in \\{1, \\dots, n\\}$，$0 \\leq x_i \\leq RU_i$。\n- **假设**：\n    - 对所有$i$，$q_i > 0$。\n    - $0 \\leq R \\leq \\sum_{i=1}^{n} RU_i$。\n    - 所有输入都是确定性的。\n    - $x_i$是连续变量。\n- **数值精度**：\n    - 等式约束$\\sum_{i=1}^{n} x_i = R$必须在$10^{-9}$的公差内满足。\n\n### 第2步：使用提取的已知信息进行验证\n1.  **科学依据**：该问题是电力系统工程中使用的标准经济调度模型。二次成本函数代表提供服务的边际成本递增，这是对火力发电机的常见假设。约束条件代表了物理限制和全系统要求。所有概念都牢固地建立在公认的工程和优化理论之上。\n2.  **适定性**：该问题是适定的。目标函数是严格凸函数之和（因为每个$q_i > 0$），使得总成本函数是严格凸的。由线性的等式和不等式约束定义的可行域是一个凸集。在凸集上最小化一个严格凸函数保证了唯一最优解的存在。假设$0 \\leq R \\leq \\sum_{i=1}^{n} RU_i$确保了可行集非空，因此保证解的存在性。\n3.  **客观性**：问题陈述使用了精确的数学语言，没有歧义或主观论断。\n\n问题表述是完整的、一致的且科学合理的。这是一个有效的优化问题。\n\n### 行动\n问题有效。将提供完整的解决方案。\n\n### 解法推导\n问题是找到分配向量$\\mathbf{x} = (x_1, \\dots, x_n)$，它能解决以下约束优化问题：\n$$\n\\begin{aligned}\n \\underset{\\mathbf{x}}{\\text{minimize}}\n  \\sum_{i=1}^{n} \\left(\\frac{1}{2} q_i x_i^2 + c_i x_i\\right) \\\\\n \\text{subject to}\n  \\sum_{i=1}^{n} x_i = R \\\\\n   0 \\leq x_i \\leq RU_i, \\quad \\forall i \\in \\{1, \\dots, n\\}\n\\end{aligned}\n$$\n\n这是一个凸优化问题。我们可以使用拉格朗日乘子法，特别是通过构建 Karush-Kuhn-Tucker (KKT) 条件来推导最优性条件。约束可以写成$R - \\sum_{i=1}^{n} x_i = 0$，$-x_i \\leq 0$和$x_i - RU_i \\leq 0$。\n\n此问题的拉格朗日函数$L$是：\n$$\nL(\\mathbf{x}, \\lambda, \\boldsymbol{\\mu}, \\boldsymbol{\\nu}) = \\sum_{i=1}^{n} \\left(\\frac{1}{2} q_i x_i^2 + c_i x_i\\right) + \\lambda \\left(R - \\sum_{i=1}^{n} x_i\\right) + \\sum_{i=1}^{n} \\mu_i (-x_i) + \\sum_{i=1}^{n} \\nu_i (x_i - RU_i)\n$$\n其中$\\lambda$是等式约束的拉格朗日乘子，$\\mu_i \\geq 0$和$\\nu_i \\geq 0$分别是$x_i$的下界和上界不等式约束的乘子。\n\n最优解$(\\mathbf{x}^*, \\lambda^*, \\boldsymbol{\\mu}^*, \\boldsymbol{\\nu}^*)$的KKT条件是：\n\n1.  **驻点条件**：拉格朗日函数相对于每个$x_i$的梯度必须为零。\n    $$\n    \\frac{\\partial L}{\\partial x_i} = q_i x_i + c_i - \\lambda - \\mu_i + \\nu_i = 0 \\quad \\forall i\n    $$\n    这可以重新排列为$q_i x_i + c_i = \\lambda + \\mu_i - \\nu_i$。项$q_i x_i + c_i$是成本函数$C'_i(x_i)$的导数，称为机组$i$的**边际成本**。\n\n2.  **原始可行性**：必须满足原始约束。\n    $$\n    \\sum_{i=1}^{n} x_i = R\n    $$\n    $$\n    0 \\leq x_i \\leq RU_i \\quad \\forall i\n    $$\n\n3.  **对偶可行性**：不等式约束的拉格朗日乘子必须为非负。\n    $$\n    \\mu_i \\geq 0, \\quad \\nu_i \\geq 0 \\quad \\forall i\n    $$\n\n4.  **互补松弛性**：不等式乘子与其对应约束的乘积必须为零。\n    $$\n    \\mu_i x_i = 0 \\quad \\forall i\n    $$\n    $$\n    \\nu_i (x_i - RU_i) = 0 \\quad \\forall i\n    $$\n\n从这些条件中，我们推导出给定系统边际价格$\\lambda$下的最优分配$x_i$。我们分析每台机组$i$的三种情况：\n\n-   **情况A：机组在其限制范围内调度（$0  x_i  RU_i$）**\n    因为$x_i > 0$和$x_i  RU_i$，互补松弛性条件意味着$\\mu_i = 0$和$\\nu_i = 0$。驻点条件简化为：\n    $$\n    q_i x_i + c_i = \\lambda \\quad \\implies \\quad x_i = \\frac{\\lambda - c_i}{q_i}\n    $$\n    这表明所有在其界限内运行的机组必须具有相同的边际成本，等于$\\lambda$。\n\n-   **情况B：机组处于其下限（$x_i = 0$）**\n    由于$x_i  RU_i$（假设$RU_i > 0$），互补松弛性意味着$\\nu_i = 0$。驻点条件是$c_i - \\lambda - \\mu_i = 0$。因为$\\mu_i \\geq 0$，这意味着$c_i - \\lambda \\geq 0$，或$\\lambda \\leq c_i$。该机组的基础边际成本相对于系统价格$\\lambda$太高，因此不被调度。\n\n-   **情况C：机组处于其上限（$x_i = RU_i$）**\n    由于$x_i > 0$（假设$RU_i > 0$），互补松弛性意味着$\\mu_i = 0$。驻点条件是$q_i RU_i + c_i - \\lambda + \\nu_i = 0$。因为$\\nu_i \\geq 0$，这意味着$q_i RU_i + c_i - \\lambda \\leq 0$，或$\\lambda \\geq q_i RU_i + c_i$。该机组非常经济，即使在其最大出力下，其边际成本也小于或等于系统价格$\\lambda$。\n\n综合这三种情况，我们可以将机组$i$的最优分配表示为单一参数$\\lambda$的函数：\n$$\nx_i(\\lambda) = \\begin{cases}\nRU_i   \\text{if } \\lambda  q_i RU_i + c_i \\\\\n\\frac{\\lambda - c_i}{q_i}   \\text{if } c_i \\leq \\lambda \\leq q_i RU_i + c_i \\\\\n0   \\text{if } \\lambda  c_i\n\\end{cases}\n$$\n这可以更紧凑地写成：\n$$\nx_i(\\lambda) = \\max\\left(0, \\min\\left(RU_i, \\frac{\\lambda - c_i}{q_i}\\right)\\right)\n$$\n这个函数$x_i(\\lambda)$是关于$\\lambda$的连续且单调不减函数。\n\n### 算法方法\n问题的核心是找到唯一的系统边际成本值$\\lambda^*$，使得总分配满足系统需求：\n$$\n\\sum_{i=1}^{n} x_i(\\lambda^*) = R\n$$\n让我们定义一个函数$f(\\lambda) = \\sum_{i=1}^{n} x_i(\\lambda) - R$。我们正在寻找$f(\\lambda) = 0$的根。由于每个$x_i(\\lambda)$都是$\\lambda$的单调不减函数，它们的和$\\sum_{i=1}^{n} x_i(\\lambda)$也是单调的。这个属性使得求根问题非常适合使用二分搜索算法。\n\n二分搜索算法过程如下：\n\n1.  **为$\\lambda$建立一个搜索区间$[\\lambda_{\\text{low}}, \\lambda_{\\text{high}}]$**：\n    -   下界可以设为$\\lambda_{\\text{low}} = 0$，因为$c_i \\geq 0$。如果$\\lambda  0$，所有$x_i$都将为$0$。\n    -   上界$\\lambda_{\\text{high}}$必须足够大，使得$\\sum_{i=1}^{n} x_i(\\lambda_{\\text{high}}) \\geq R$。可以选择一个安全的、足够大的值，例如，通过找到所有机组中可能的最大边际成本：$\\lambda_{\\text{high}} = \\max_i(c_i + q_i RU_i)$。\n\n2.  **迭代求根**：\n    -   重复固定次数的迭代（例如，100次）以达到高精度，或者直到搜索区间足够小。\n    -   在每次迭代中，计算中点$\\lambda_{\\text{mid}} = (\\lambda_{\\text{low}} + \\lambda_{\\text{high}}) / 2$。\n    -   计算此试验值的总分配：$X_{\\text{total}} = \\sum_{i=1}^{n} \\max\\left(0, \\min\\left(RU_i, \\frac{\\lambda_{\\text{mid}} - c_i}{q_i}\\right)\\right)$。\n    -   更新区间：\n        -   如果$X_{\\text{total}}  R$，则试验值$\\lambda_{\\text{mid}}$太低，无法满足需求。我们需要增加边际成本以获取更多备用。因此，我们设置$\\lambda_{\\text{low}} = \\lambda_{\\text{mid}}$。\n        -   如果$X_{\\text{total}} \\geq R$，则试验值$\\lambda_{\\text{mid}}$足够高或过高。我们可能可以用更低的成本来满足需求。因此，我们设置$\\lambda_{\\text{high}} = \\lambda_{\\text{mid}}$。\n\n3.  **最终计算**：\n    -   迭代完成后，最优边际成本$\\lambda^*$取为最终区间的中点，$\\lambda^* = (\\lambda_{\\text{low}} + \\lambda_{\\text{high}}) / 2$。\n    -   使用这个$\\lambda^*$计算最终的最优分配向量$\\mathbf{x}^* = (x_1^*, \\dots, x_n^*)$：\n        $$\n        x_i^* = \\max\\left(0, \\min\\left(RU_i, \\frac{\\lambda^* - c_i}{q_i}\\right)\\right) \\quad \\forall i\n        $$\n该算法是鲁棒、高效的，并且由于$f(\\lambda)$的单调性，保证能收敛到唯一的最优解。在标准的双精度浮点数上进行足够次数的迭代（例如100次）将确保最终约束$|\\sum x_i - R|$远在要求的$10^{-9}$公差之内。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ramp-rate reserve allocation problem for a series of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: n = 3, RU = [30, 20, 10], q = [0.8, 0.4, 1.2], c = [4.0, 3.0, 5.5], R = 35\n        (np.array([30.0, 20.0, 10.0]), np.array([0.8, 0.4, 1.2]), np.array([4.0, 3.0, 5.5]), 35.0),\n        # Case 2: n = 2, RU = [15, 15], q = [0.5, 0.5], c = [2.0, 2.0], R = 0\n        (np.array([15.0, 15.0]), np.array([0.5, 0.5]), np.array([2.0, 2.0]), 0.0),\n        # Case 3: n = 4, RU = [5, 10, 15, 20], q = [1.0, 0.2, 0.6, 0.4], c = [3.5, 2.0, 2.5, 3.0], R = 50\n        (np.array([5.0, 10.0, 15.0, 20.0]), np.array([1.0, 0.2, 0.6, 0.4]), np.array([3.5, 2.0, 2.5, 3.0]), 50.0),\n        # Case 4: n = 4, RU = [50, 5, 0, 40], q = [0.1, 1.5, 0.8, 0.3], c = [1.0, 10.0, 2.0, 1.5], R = 60\n        (np.array([50.0, 5.0, 0.0, 40.0]), np.array([0.1, 1.5, 0.8, 0.3]), np.array([1.0, 10.0, 2.0, 1.5]), 60.0),\n    ]\n\n    all_results = []\n\n    for RU, q, c, R in test_cases:\n        # Handle the trivial case where R=0\n        if R == 0:\n            allocations = np.zeros_like(RU)\n            all_results.append(allocations)\n            continue\n        \n        # Handle the trivial case where R is the sum of all capacities\n        if abs(R - np.sum(RU))  1e-9:\n            allocations = RU\n            all_results.append(allocations)\n            continue\n            \n        # 1. Establish a search interval for lambda\n        lambda_low = 0.0\n        # A safe upper bound for lambda is the max possible marginal cost\n        # Add a small epsilon to handle cases where RU might be zero\n        lambda_high = np.max(c + q * (RU + 1e-9)) * 1.5 # Multiplied by 1.5 for an extra margin\n        \n        # For a more robust upper bound, ensure it's sufficiently large\n        lambda_high = max(lambda_high, 1000.0)\n\n        # 2. Iterate using bisection search to find the optimal lambda\n        # 100 iterations are more than sufficient for double precision convergence\n        for _ in range(100):\n            lambda_mid = (lambda_low + lambda_high) / 2.0\n            \n            # Calculate total allocation for the current lambda_mid\n            # x_i = (lambda - c_i) / q_i, clipped by [0, RU_i]\n            # np.divide is used for safe division, although q_i > 0 is assumed\n            x = (lambda_mid - c) / q\n            allocations = np.maximum(0.0, np.minimum(RU, x))\n            \n            total_allocation = np.sum(allocations)\n            \n            # Update the search interval\n            if total_allocation  R:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        # 3. Final calculation using the determined optimal lambda\n        lambda_opt = (lambda_low + lambda_high) / 2.0\n        \n        final_x = (lambda_opt - c) / q\n        final_allocations = np.maximum(0.0, np.minimum(RU, final_x))\n        \n        # An optional step to correct for floating point inaccuracies to perfectly match R.\n        # However, 100 iterations of bisection typically make the error negligible (well within 1e-9).\n        residual = R - np.sum(final_allocations)\n        # Identify generators not at their bounds\n        active_mask = (final_allocations > 1e-9)  (final_allocations  RU - 1e-9)\n        \n        if np.any(active_mask):\n            # Calculate sum of 1/q_i for active generators\n            inv_q_sum_active = np.sum(1.0 / q[active_mask])\n            if inv_q_sum_active > 0:\n                # Distribute residual proportionally\n                final_allocations[active_mask] += residual * (1.0 / q[active_mask]) / inv_q_sum_active\n        \n        # Ensure positivity and bounds again after correction\n        final_allocations = np.maximum(0.0, np.minimum(RU, final_allocations))\n\n        all_results.append(final_allocations)\n\n    # Format output string\n    output_parts = []\n    for result_vector in all_results:\n        formatted_vector = ','.join([f\"{val:.6f}\" for val in result_vector])\n        output_parts.append(f\"[{formatted_vector}]\")\n    \n    final_output = f\"[{','.join(output_parts)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "前述练习中的模型依赖于精确的参数，例如向上爬坡率极限$RU$。最后的这个练习将模型与现实联系起来，要求您直接从原始运行数据中估算这些参数 。通过开发并应用一个稳健的统计算法，您将学会如何处理时间序列数据以揭示发电机的真实物理性能，这是能源系统分析中的一项基本技能。",
            "id": "4093077",
            "problem": "提供给您的是某火力发电机有功功率输出及其测量时间戳的监视控制与数据采集 (SCADA) 时间序列数据。目标是估算能反映真实运行行为的经验性爬坡率边界。具体而言，将离散时间的爬坡率定义为功率时间导数的有限差分近似。设测量功率为$P(t)$（单位：兆瓦），采样时间戳为$\\{t_0, t_1, \\dots, t_N\\}$，相应的功率样本为$\\{P_0, P_1, \\dots, P_N\\}$，其中$P_i = P(t_i)$。在区间$[t_{i-1}, t_i]$上的有限差分爬坡率定义为\n$$\nr_i = \\frac{P_i - P_{i-1}}{t_i - t_{i-1}},\n$$\n单位为兆瓦/分钟 (MW/min)。\n\n您必须通过以下方法从历史数据中估算经验性爬坡上限$RU$和滑坡下限$RD$（单位：MW/min）：\n- 在计算有限差分之前，过滤功率序列$P_i$中的测量噪声。\n- 排除与启动或停机相关的区间，以及被明确标记为无效的区间。\n\n您的算法必须从第一性原理出发进行设计，仅使用公认的定义和稳健的统计程序。该程序必须遵守以下规范：\n1. 噪声抑制应采用稳健的局部方法，该方法不假定噪声的参数形式。您必须实现一个基于中位数和中位数绝对偏差 (MAD) 的滑动窗口异常值替换方法，窗口半尺寸为$w \\in \\mathbb{Z}_{\\ge 1}$，阈值乘数为$k \\in \\mathbb{R}_{>0}$。对于以索引$i$为中心的窗口，计算局部中位数$m_i$和局部 MAD $d_i = \\mathrm{median}\\{|x - m_i|\\}$；定义尺度$s_i = c \\cdot d_i$，其中$c = 1.4826$。如果$|P_i - m_i| > k s_i$，则将$P_i$替换为$m_i$；否则保持$P_i$不变。边缘情况必须通过将窗口缩小到可用样本范围来处理。\n2. 通过排除任何满足以下任一条件的区间$[t_{i-1}, t_i]$来构建有效区间：\n   - $P_{i-1}$或$P_i$低于最小发电阈值$P_{\\min}$（启停机排除）。\n   - 索引$i-1$或$i$处的测量值通过二进制掩码被明确标记为离线/无效。\n   - 时间增量$t_i - t_{i-1} \\le 0$（非正向时间）。\n3. 为所有有效区间计算$r_i$，并使用顺序统计量，在指定的尾部比例$\\alpha \\in (0, 0.5)$处丢弃分布的尾部，以估算经验边界。令水平为$\\alpha$的下尾分位数作为经验下界，水平为$1 - \\alpha$的上尾分位数作为经验上界。将$RD$定义为经验下界（应为非正值），$RU$定义为经验上界（应为非负值）。通过返回$RD = \\min\\{0, RD\\}$和$RU = \\max\\{0, RU\\}$，将结果裁剪至具有物理意义的符号范围。\n4. 如果排除后没有剩余的有效区间，则返回$RU = 0.0$和$RD = 0.0$。\n5. 将$RU$和$RD$以兆瓦/分钟 (MW/min) 为单位表示，并将每个值四舍五入到3位小数。\n\n程序必须实现上述算法，并为以下测试套件生成结果。每个测试用例包括：\n- 时间戳（分钟）$\\{t_i\\}$。\n- 功率样本（兆瓦）$\\{P_i\\}$。\n- 二进制离线掩码$\\{b_i\\}$，其中$b_i = 1$表示无效/离线测量，$b_i = 0$表示有效测量。\n- 最小发电阈值$P_{\\min}$（兆瓦）。\n- 噪声滤波器参数：窗口半尺寸$w$和阈值乘数$k$。\n- 用于经验边界的尾部比例$\\alpha$。\n\n测试套件：\n- 用例 A（一般情况，均匀采样，带有异常值的混合爬坡）：\n  - $t = [\\,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20\\,]$。\n  - $P = [\\,50.0,51.2,52.4,53.6,54.8,56.0,56.0,59.0,56.0,56.0,56.0,55.2,50.4,53.6,52.8,52.0,52.0,52.5,53.0,53.5,54.0\\,]$其中$t=7$和$t=12$处的值是故意设置的异常值。\n  - $b = [\\,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\\,]$。\n  - $P_{\\min} = 10.0$，$w = 2$，$k = 3.0$，$\\alpha = 0.02$。\n- 用例 B（边界情况，功率接近恒定，有小幅偏差）：\n  - $t = [\\,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15\\,]$。\n  - $P = [\\,75.00,75.10,74.80,75.15,74.95,75.00,75.05,74.90,75.00,75.08,74.93,75.00,75.03,74.96,75.02,75.00\\,]$。\n  - $b = [\\,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\\,]$。\n  - $P_{\\min} = 10.0$，$w = 2$，$k = 3.0$，$\\alpha = 0.02$。\n- 用例 C（非均匀采样，一个索引被标记为无效）：\n  - $t = [\\,0.0,1.5,3.1,4.0,6.5,7.0,9.0,12.0\\,]$。\n  - $P = [\\,60.0,63.0,66.0,67.8,72.8,72.0,69.0,66.0\\,]$。\n  - $b = [\\,0,0,0,0,1,0,0,0\\,]$其中索引$4$处的测量值无效。\n  - $P_{\\min} = 10.0$，$w = 1$，$k = 3.0$，$\\alpha = 0.02$。\n- 用例 D（存在启动和停机过程；通过$P_{\\min}$排除）：\n  - $t = [\\,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18\\,]$。\n  - $P = [\\,0.0,0.0,0.0,50.0,100.0,100.0,102.0,104.0,106.0,108.0,110.0,111.0,109.5,108.0,106.5,20.0,0.0,0.0,0.0\\,]$其中接近零的快速变化代表了必须通过$P_{\\min}$排除的启动/停机区间。\n  - $b = [\\,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\\,]$。\n  - $P_{\\min} = 10.0$，$w = 2$，$k = 3.0$，$\\alpha = 0.02$。\n\n您的程序必须实现该算法，并生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例对应一个双元素列表$[RU,RD]$，每个值均四舍五入到3位小数，单位为 MW/min。最终输出格式必须严格为\n$$\n[\\,[RU_A,RD_A],[RU_B,RD_B],[RU_C,RD_C],[RU_D,RD_D]\\,]\n$$\n其中$RU_A$和$RD_A$对应于用例 A，依此类推。不得打印任何额外文本。",
            "solution": "该问题定义明确，具有科学依据，并为进行求解提供了所有必要信息。任务是实现一个稳健的多阶段算法，用于从时间序列数据中估算发电机的经验性爬坡上限 ($RU$) 和滑坡下限 ($RD$)。该算法基于已建立的统计信号处理技术和能源系统分析中常用的启发式方法。\n\n求解过程通过逐步实现指定的算法来进行。\n\n**1. 通过中位数绝对偏差 (MAD) 滤波进行噪声抑制**\n\n第一步是预处理原始功率输出序列$\\{P_i\\}$，以减轻测量噪声和伪异常值的影响。一个简单的爬坡率有限差分计算公式$r_i = \\frac{P_i - P_{i-1}}{t_i - t_{i-1}}$对噪声高度敏感，因为它会放大高频分量。问题指定了一个稳健的非参数滤波器：一种基于局部中位数和中位数绝对偏差 (MAD) 的滑动窗口异常值替换方案。\n\n对于长度为$N+1$的序列中的每个数据点$P_i$，我们定义一个以索引$i$为中心的样本窗口。该窗口包含样本$P_j$，其中$j \\in [\\max(0, i-w), \\min(N, i+w)]$，$w$是窗口的半尺寸。在此窗口内，我们计算：\n- 局部中位数, $m_i = \\mathrm{median}\\{P_j\\}$。\n- 局部中位数绝对偏差, $d_i = \\mathrm{median}\\{|P_j - m_i|\\}$。\n\nMAD 是统计离散度的稳健度量。为了将其用作标准差$\\sigma$的一致估计量，需要乘以一个常数因子$c \\approx 1.4826$进行缩放。这个常数源自高斯分布，其中$c = 1/\\Phi^{-1}(0.75)$，$\\Phi^{-1}$是标准正态分布的分位数函数。缩放后的 MAD，$s_i = c \\cdot d_i$，可作为“干净”数据标准差的稳健局部估计。\n\n如果一个点与局部中位数的偏差超过此稳健尺度估计的某个倍数$k$，则检测为异常值。根据以下规则构建一个新的、经过滤波的功率序列$P'_i$：\n$$\nP'_i = \\begin{cases}\nm_i   \\text{if } |P_i - m_i|  k \\cdot s_i \\\\\nP_i   \\text{otherwise}\n\\end{cases}\n$$\n如果窗口中的所有值都相同，则$d_i=0$且$s_i=0$。在这种情况下，任何不等于中位数$m_i$的点$P_i$都将满足$|P_i-m_i| > 0$，并被归类为异常值，然后被$m_i$替换。这是正确且期望的行为。这个滤波后的序列$\\{P'_i\\}$将用于所有后续步骤。\n\n**2. 有效爬坡区间的识别**\n\n并非所有时间区间都代表发电机的正常爬坡行为。该算法强制要求排除对应于启动、停机、数据质量标记事件或时间后退的区间$[t_{i-1}, t_i]$。一个区间只有在满足以下所有条件时，才被视为用于爬坡率计算的“有效”区间：\n- **最小发电量：** 两个端点都必须高于最小发电阈值$P_{\\min}$。这排除了发电机从零启动或停机的区间。检查是在滤波后的功率值上进行的：$P'_{i-1} \\ge P_{\\min}$且$P'_{i} \\ge P_{\\min}$。\n- **数据质量：** 区间端点的测量值均不能被标记为无效。使用二进制掩码$\\{b_i\\}$，这意味着$b_{i-1} = 0$且$b_i = 0$。\n- **时间单调性：** 时间戳必须严格递增，即$t_i - t_{i-1} > 0$。\n\n**3. 爬坡率计算与边界估算**\n\n对于每个被识别为有效的区间$[t_{i-1}, t_i]$，使用滤波后的功率数据计算一个爬坡率样本：\n$$\nr_i = \\frac{P'_i - P'_{i-1}}{t_i - t_{i-1}}\n$$\n这些计算出的速率，单位为 MW/min，构成一个经验爬坡率集合$\\mathcal{R}$。正值对应于爬坡，负值对应于滑坡。\n\n如果在滤波阶段后不存在有效区间，则集合$\\mathcal{R}$为空。在这种情况下，爬坡率边界被简单地定义为$RU=0.0$和$RD=0.0$。\n\n如果$\\mathcal{R}$不为空，则从$\\mathcal{R}$的经验分布中估算爬坡上限和滑坡下限。为了获得一个对任何剩余的极端值不敏感的稳健估计，我们使用分位数。问题指定使用$\\alpha$和$1-\\alpha$分位数，其中$\\alpha$是一个很小的分数（例如 0.02），代表要丢弃的分布尾部。\n\n原始的滑坡下限和爬坡上限计算如下：\n- $RD_{\\text{raw}} = \\text{Quantile}(\\mathcal{R}, \\alpha)$\n- $RU_{\\text{raw}} = \\text{Quantile}(\\mathcal{R}, 1-\\alpha)$\n\n$\\text{Quantile}(\\mathcal{R}, q)$函数找到一个值，$\\mathcal{R}$中有比例为$q$的数据小于该值。这通常通过排序和线性插值来实现。\n\n最后，为了确保边界的物理意义得到尊重（爬坡不能为负，滑坡不能为正），应用了最后的裁剪步骤：\n- 滑坡下限：$RD = \\min(0, RD_{\\text{raw}})$\n- 爬坡上限：$RU = \\max(0, RU_{\\text{raw}})$\n\n然后，根据要求将$RU$和$RD$的最终值四舍五入到3位小数。这整个程序提供了一种可重复且有根据的方法，用于从原始运行数据中提取关键运行参数。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_ramp_bounds(t, P, b, p_min, w, k, alpha):\n    \"\"\"\n    Calculates empirical ramp-rate bounds (RU, RD) from time-series data.\n    \n    This function implements the complete algorithm as specified:\n    1. Applies a sliding-window Median-Absolute-Deviation (MAD) filter for noise.\n    2. Identifies valid intervals, excluding startup/shutdown and flagged data.\n    3. Computes finite-difference ramp rates on valid intervals.\n    4. Estimates bounds using quantiles of the ramp-rate distribution.\n    5. Clips and rounds a final result.\n    \"\"\"\n    if len(P)  2:\n        return 0.0, 0.0\n\n    # Ensure inputs are numpy arrays for vectorized operations\n    P = np.array(P, dtype=float)\n    t = np.array(t, dtype=float)\n    b = np.array(b, dtype=int)\n    \n    # 1. Noise Suppression (MAD Filter)\n    P_filtered = np.copy(P)\n    c = 1.4826  # Constant: 1 / N(0.75) for standard deviation estimation\n\n    for i in range(len(P)):\n        # Define window, handling edges by shrinking\n        start = max(0, i - w)\n        end = min(len(P), i + w + 1)\n        window_data = P[start:end]\n\n        # Calculate local median and MAD\n        m_i = np.median(window_data)\n        d_i = np.median(np.abs(window_data - m_i))\n        \n        # Calculate scaled MAD (robust standard deviation)\n        s_i = c * d_i\n\n        # Replace outlier if deviation from median is too large\n        # Handles s_i = 0 case, where any deviation is an outlier\n        if s_i > 0:\n            if np.abs(P[i] - m_i) > k * s_i:\n                P_filtered[i] = m_i\n        elif np.abs(P[i] - m_i) > 0:\n            P_filtered[i] = m_i\n\n    # 2.  3. Identify Valid Intervals and Compute Ramp Rates\n    valid_ramps = []\n    for i in range(1, len(t)):\n        # Check validity conditions\n        dt = t[i] - t[i-1]\n        is_time_forward = dt > 0\n        is_quality_ok = b[i-1] == 0 and b[i] == 0\n        is_above_min_gen = P_filtered[i-1] >= p_min and P_filtered[i] >= p_min\n        \n        if is_time_forward and is_quality_ok and is_above_min_gen:\n            ramp_rate = (P_filtered[i] - P_filtered[i-1]) / dt\n            valid_ramps.append(ramp_rate)\n\n    # 4. Handle Case of No Valid Intervals\n    if not valid_ramps:\n        return 0.0, 0.0\n        \n    # 5. Estimate Bounds from Quantiles\n    valid_ramps = np.array(valid_ramps)\n    rd_raw = np.quantile(valid_ramps, alpha)\n    ru_raw = np.quantile(valid_ramps, 1 - alpha)\n    \n    # Clip to physically meaningful signs\n    rd_final = min(0.0, rd_raw)\n    ru_final = max(0.0, ru_raw)\n    \n    # 6. Round to 3 decimal places\n    return round(ru_final, 3), round(rd_final, 3)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case A: general, uniform sampling, mixed ramps with outliers\n        {\n            't': np.arange(21, dtype=float),\n            'P': np.array([50.0, 51.2, 52.4, 53.6, 54.8, 56.0, 56.0, 59.0, 56.0, 56.0, 56.0, \n                           55.2, 50.4, 53.6, 52.8, 52.0, 52.0, 52.5, 53.0, 53.5, 54.0]),\n            'b': np.zeros(21, dtype=int),\n            'p_min': 10.0, 'w': 2, 'k': 3.0, 'alpha': 0.02\n        },\n        # Case B: boundary, near-constant power with small deviations\n        {\n            't': np.arange(16, dtype=float),\n            'P': np.array([75.00, 75.10, 74.80, 75.15, 74.95, 75.00, 75.05, 74.90, 75.00, \n                           75.08, 74.93, 75.00, 75.03, 74.96, 75.02, 75.00]),\n            'b': np.zeros(16, dtype=int),\n            'p_min': 10.0, 'w': 2, 'k': 3.0, 'alpha': 0.02\n        },\n        # Case C: irregular sampling, flagged invalid at one index\n        {\n            't': np.array([0.0, 1.5, 3.1, 4.0, 6.5, 7.0, 9.0, 12.0]),\n            'P': np.array([60.0, 63.0, 66.0, 67.8, 72.8, 72.0, 69.0, 66.0]),\n            'b': np.array([0, 0, 0, 0, 1, 0, 0, 0]),\n            'p_min': 10.0, 'w': 1, 'k': 3.0, 'alpha': 0.02\n        },\n        # Case D: startup and shutdown present; exclude via P_min\n        {\n            't': np.arange(19, dtype=float),\n            'P': np.array([0.0, 0.0, 0.0, 50.0, 100.0, 100.0, 102.0, 104.0, 106.0, 108.0, \n                           110.0, 111.0, 109.5, 108.0, 106.5, 20.0, 0.0, 0.0, 0.0]),\n            'b': np.zeros(19, dtype=int),\n            'p_min': 10.0, 'w': 2, 'k': 3.0, 'alpha': 0.02\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        ru, rd = calculate_ramp_bounds(\n            t=case['t'], P=case['P'], b=case['b'], p_min=case['p_min'],\n            w=case['w'], k=case['k'], alpha=case['alpha']\n        )\n        results.append(f\"[{ru},{rd}]\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}