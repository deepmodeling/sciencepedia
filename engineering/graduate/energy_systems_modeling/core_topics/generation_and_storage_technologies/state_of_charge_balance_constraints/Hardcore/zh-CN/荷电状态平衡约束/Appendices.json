{
    "hands_on_practices": [
        {
            "introduction": "这个练习旨在从头开始构建核心模型。它将引导您从能量守恒基本原理出发，推导出包含效率和自放电等关键因素的离散时间荷电状态（$SOC$）平衡方程。通过模拟电池在多个时间步内的 $SOC$ 变化，本实践旨在加深您对充、放电及损耗如何动态影响储能的理解，为所有后续分析奠定坚实基础。",
            "id": "4125178",
            "problem": "单个电池储能系统具有一个充电状态（SoC），用 $s_t \\in [0,1]$ 表示，定义为存储能量除以额定能量容量的归一化值。考虑一个时间索引为 $t \\in \\{0,1,\\dots,T\\}$ 且时间步长均匀为 $\\Delta t$ 的离散时间模型。该电池通过输入功率 $p^c_t \\ge 0$ 充电，并通过输出功率 $p^d_t \\ge 0$ 放电。充电和放电会产生转换损耗，分别由恒定的充电效率 $\\eta_c \\in (0,1]$ 和放电效率 $\\eta_d \\in (0,1]$ 表示。在时间步之间，每个时间步存储的能量会因自放电（泄漏）而减少一个比例 $\\sigma \\in [0,1)$。假设没有其他损耗或增益。\n\n从能量守恒的第一性原理和充电状态（SoC）的定义出发，推导适当的离散时间SoC平衡方程，并用它来计算以下参数和输入序列的终端SoC $s_T$：\n- 能量容量 $E = 100\\,\\text{kWh}$。\n- 时间步长 $\\Delta t = 1\\,\\text{h}$。\n- 充电效率 $\\eta_c = 0.96$。\n- 放电效率 $\\eta_d = 0.92$。\n- 每步自放电率 $\\sigma = 0.002$。\n- 初始SoC $s_0 = 0.50$。\n- 时间范围长度 $T = 6$。\n- 时间 $t=1,\\dots,6$ 的功率序列（单位为 $\\text{kW}$）：\n  - $t=1$: $p^c_1 = 10$, $p^d_1 = 0$。\n  - $t=2$: $p^c_2 = 20$, $p^d_2 = 0$。\n  - $t=3$: $p^c_3 = 0$, $p^d_3 = 15$。\n  - $t=4$: $p^c_4 = 0$, $p^d_4 = 10$。\n  - $t=5$: $p^c_5 = 5$, $p^d_5 = 0$。\n  - $t=6$: $p^c_6 = 0$, $p^d_6 = 0$。\n\n在您的推导中，从设备边界的能量守恒和SoC作为归一化存储能量的定义开始。然后，通过检查计算出的轨迹在所有 $t \\in \\{1,\\dots,T\\}$ 上是否满足 $0 \\le s_t \\le 1$ 来验证可行性。最后，将终端SoC $s_T$ 报告为一个无量纲的分数。将您的答案四舍五入到六位有效数字，并表示为一个不带单位的纯数字。",
            "solution": "首先将根据科学性、适定性、客观性和完整性的标准对问题进行验证。\n\n### 问题验证\n\n**第一步：提取已知条件**\n-   **系统定义**：单个电池储能系统。\n-   **状态变量**：充电状态（SoC），$s_t \\in [0,1]$，定义为存储能量除以额定能量容量的归一化值。\n-   **时间模型**：离散时间，索引为 $t \\in \\{0,1,\\dots,T\\}$，时间步长均匀为 $\\Delta t$。\n-   **输入/输出**：充电功率 $p^c_t \\ge 0$，放电功率 $p^d_t \\ge 0$。\n-   **损耗**：恒定充电效率 $\\eta_c \\in (0,1]$，恒定放电效率 $\\eta_d \\in (0,1]$，以及每时间步的自放电比例 $\\sigma \\in [0,1)$。\n-   **初始状态**：初始SoC $s_0$。\n-   **参数**：\n    -   能量容量 $E = 100\\,\\text{kWh}$。\n    -   时间步长 $\\Delta t = 1\\,\\text{h}$。\n    -   充电效率 $\\eta_c = 0.96$。\n    -   放电效率 $\\eta_d = 0.92$。\n    -   每步自放电率 $\\sigma = 0.002$。\n    -   初始SoC $s_0 = 0.50$。\n    -   时间范围长度 $T = 6$。\n-   **输入序列**：\n    -   $t=1$: $p^c_1 = 10\\,\\text{kW}$, $p^d_1 = 0\\,\\text{kW}$。\n    -   $t=2$: $p^c_2 = 20\\,\\text{kW}$, $p^d_2 = 0\\,\\text{kW}$。\n    -   $t=3$: $p^c_3 = 0\\,\\text{kW}$, $p^d_3 = 15\\,\\text{kW}$。\n    -   $t=4$: $p^c_4 = 0\\,\\text{kW}$, $p^d_4 = 10\\,\\text{kW}$。\n    -   $t=5$: $p^c_5 = 5\\,\\text{kW}$, $p^d_5 = 0\\,\\text{kW}$。\n    -   $t=6$: $p^c_6 = 0\\,\\text{kW}$, $p^d_6 = 0\\,\\text{kW}$。\n-   **任务**：从第一性原理推导离散时间SoC平衡方程，计算终端SoC $s_T$，验证可行性（$0 \\le s_t \\le 1$），并提供四舍五入到六位有效数字的 $s_T$。\n\n**第二步：使用提取的已知条件进行验证**\n-   **科学性**：该问题描述了一个标准的电池能量平衡模型，包含了充电/放电效率和自放电等基本概念。这些概念在电气工程和能源系统建模中是公认的。该模型基于能量守恒原理。\n-   **适定性**：该问题提供了所有必要的参数（$E, \\Delta t, \\eta_c, \\eta_d, \\sigma$）、一个明确定义的初始条件（$s_0$）以及整个时间范围内的完整输入序列（$p^c_t, p^d_t$）。这使得能够计算出状态轨迹 $s_t$ 和终端状态 $s_T$ 的唯一解。\n-   **客观性**：该问题使用精确、无歧义的技术术语进行表述。量被定义，任务是具体的和定量的。没有主观或基于意见的内容。\n-   **完整性**：该问题是自包含的，并提供了解决它所需的所有数据。单位是一致的（功率单位为 $\\text{kW}$，时间单位为 $\\text{h}$，容量单位为 $\\text{kWh}$）。\n\n**第三步：结论与行动**\n该问题是有效的，因为它是科学合理的、适定的、客观的和完整的。我们可以继续进行求解。\n\n### SoC平衡方程的推导\n\n设 $S_t$ 为在时间步 $t$ 结束时电池中存储的绝对能量，单位为 $\\text{kWh}$。充电状态（SoC）$s_t$ 定义为存储能量除以额定能量容量 $E$ 的归一化值：\n$$s_t = \\frac{S_t}{E}$$\n我们基于能量守恒原理，推导 $S_t$ 从时间步 $t-1$ 到 $t$ 的演变过程。\n\n在时间步 $t-1$ 结束时的状态是 $S_{t-1}$。问题指出，在“时间步之间”会损失一个自放电比例 $\\sigma$。这意味着在时间步 $t$ 的操作阶段开始时的能量是上一步的能量经过自放电衰减后的能量。\n自放电后的能量：$S_{t-1} (1-\\sigma)$。\n\n在持续时间为 $\\Delta t$ 的时间步 $t$ 期间，电池被充电和/或放电。\n1.  **充电**：施加输入功率 $p^c_t$。在 $\\Delta t$ 时间内输送到电池的能量是 $p^c_t \\Delta t$。由于转换损耗，只有这部分能量的一个比例 $\\eta_c$ 被成功存储。增加到存储中的能量是 $\\eta_c p^c_t \\Delta t$。\n2.  **放电**：电池提供输出功率 $p^d_t$。输送到负载的能量是 $p^d_t \\Delta t$。由于转换损耗，必须从存储中消耗更大量的能量。这个量是 $\\frac{1}{\\eta_d} p^d_t \\Delta t$。\n\n结合这些效应，在时间步 $t$ 结束时的总存储能量 $S_t$ 是自放电后的能量加上充放电带来的净能量变化：\n$$S_t = S_{t-1}(1-\\sigma) + \\eta_c p^c_t \\Delta t - \\frac{1}{\\eta_d} p^d_t \\Delta t$$\n为了得到SoC平衡方程，我们将整个方程除以能量容量 $E$：\n$$\\frac{S_t}{E} = \\frac{S_{t-1}}{E}(1-\\sigma) + \\frac{\\eta_c \\Delta t}{E} p^c_t - \\frac{\\Delta t}{\\eta_d E} p^d_t$$\n代入SoC的定义，我们得到离散时间SoC平衡方程：\n$$s_t = s_{t-1}(1-\\sigma) + \\frac{\\eta_c \\Delta t}{E} p^c_t - \\frac{\\Delta t}{\\eta_d E} p^d_t$$\n\n### 终端SoC的计算\n\n现在我们将给定的数值代入推导出的方程中。\n-   $1-\\sigma = 1 - 0.002 = 0.998$。\n-   充电系数是 $\\frac{\\eta_c \\Delta t}{E} = \\frac{0.96 \\times 1\\,\\text{h}}{100\\,\\text{kWh}} = 0.0096\\,\\text{kW}^{-1}$。\n-   放电系数是 $\\frac{\\Delta t}{\\eta_d E} = \\frac{1\\,\\text{h}}{0.92 \\times 100\\,\\text{kWh}} = \\frac{1}{92}\\,\\text{kW}^{-1}$。\n\n这个特定问题的递推关系是：\n$$s_t = 0.998 s_{t-1} + 0.0096 p^c_t - \\frac{1}{92} p^d_t$$\n我们从 $s_0 = 0.50$ 开始，迭代计算 $t=1, \\dots, 6$ 的 $s_t$。\n\n**步骤 $t=1$**: $p^c_1 = 10$, $p^d_1 = 0$。\n$$s_1 = 0.998 \\times s_0 + 0.0096 \\times 10 - \\frac{1}{92} \\times 0$$\n$$s_1 = 0.998 \\times 0.5 + 0.096 = 0.499 + 0.096 = 0.595$$\n可行性检查：$0 \\le 0.595 \\le 1$。状态有效。\n\n**步骤 $t=2$**: $p^c_2 = 20$, $p^d_2 = 0$。\n$$s_2 = 0.998 \\times s_1 + 0.0096 \\times 20 - \\frac{1}{92} \\times 0$$\n$$s_2 = 0.998 \\times 0.595 + 0.192 = 0.59381 + 0.192 = 0.78581$$\n可行性检查：$0 \\le 0.78581 \\le 1$。状态有效。\n\n**步骤 $t=3$**: $p^c_3 = 0$, $p^d_3 = 15$。\n$$s_3 = 0.998 \\times s_2 + 0.0096 \\times 0 - \\frac{1}{92} \\times 15$$\n$$s_3 = 0.998 \\times 0.78581 - \\frac{15}{92} \\approx 0.78423838 - 0.16304348 \\approx 0.62119490$$\n可行性检查：$0 \\le 0.62119490 \\le 1$。状态有效。\n\n**步骤 $t=4$**: $p^c_4 = 0$, $p^d_4 = 10$。\n$$s_4 = 0.998 \\times s_3 - \\frac{1}{92} \\times 10$$\n$$s_4 \\approx 0.998 \\times 0.62119490 - \\frac{10}{92} \\approx 0.61995251 - 0.10869565 \\approx 0.51125686$$\n可行性检查：$0 \\le 0.51125686 \\le 1$。状态有效。\n\n**步骤 $t=5$**: $p^c_5 = 5$, $p^d_5 = 0$。\n$$s_5 = 0.998 \\times s_4 + 0.0096 \\times 5$$\n$$s_5 \\approx 0.998 \\times 0.51125686 + 0.048 \\approx 0.51023435 + 0.048 = 0.55823435$$\n可行性检查：$0 \\le 0.55823435 \\le 1$。状态有效。\n\n**步骤 $t=6$**: $p^c_6 = 0$, $p^d_6 = 0$。\n这是最后一步，得出终端SoC $s_T = s_6$。\n$$s_6 = 0.998 \\times s_5 + 0.0096 \\times 0 - \\frac{1}{92} \\times 0$$\n$$s_6 = 0.998 \\times s_5 \\approx 0.998 \\times 0.55823435 \\approx 0.55711788$$\n可行性检查：$0 \\le 0.55711788 \\le 1$。终端状态有效。\n\n终端SoC $s_6$ 的未四舍五入值约为 $0.55711787735...$。四舍五入到六位有效数字，我们得到 $0.557118$。",
            "answer": "$$\\boxed{0.557118}$$"
        },
        {
            "introduction": "本练习超越了简单的模拟，挑战您以逆向思维方式应用 $SOC$ 平衡方程。您的目标不再是预测未来状态，而是确定在不超过系统物理极限（即 $s_t \\le 1$）的前提下的最大允许充电功率。这类计算对于设计控制策略和在优化模型中制定约束至关重要，标志着从描述性建模向规范性建模的转变。",
            "id": "4125166",
            "problem": "一个电能存储系统的归一化荷电状态 (SoC) $s_t \\in [0,1]$，其存储的能量 $E_t$ 与 SoC 的关系为 $s_t = E_t / E_{\\max}$，其中 $E_{\\max}$ 是可用能量容量。在一个长度为 $\\Delta t$ 的调度区间内，存储的能量因三个基于物理的过程而变化：(i) 以恒定功率 $p^c_t \\ge 0$ 充电，单向充电效率为 $\\eta_c \\in (0,1]$；(ii) 以恒定功率 $p^d_t \\ge 0$ 放电，单向放电效率为 $\\eta_d \\in (0,1]$；(iii) 自放电，其模型为存储能量以速率 $\\lambda \\ge 0$ 的指数衰减，在该区间内的能量保持因子为 $\\phi = \\exp(-\\lambda \\Delta t)$。此外，还有一个恒定的辅助负载 $P_{\\mathrm{aux}} \\ge 0$ (单位为 $\\mathrm{MW}$)，它在该区间内从储能系统中消耗能量。假设所有功率在该区间内恒定，并且区间内不会发生饱和。从能量守恒和荷电状态的定义出发，确定最大允许充电功率 $p^c_t$，以确保在区间结束时满足上界 $s_t \\le 1$。\n\n使用以下参数值：可用能量容量为 $E_{\\max} = 180\\,\\mathrm{MWh}$，上一时刻的归一化 SoC 为 $s_{t-1} = 0.85$，区间长度为 $\\Delta t = 0.5\\,\\mathrm{h}$，自放电率为 $\\lambda = 0.01\\,\\mathrm{h}^{-1}$，充电效率为 $\\eta_c = 0.94$，放电效率为 $\\eta_d = 0.92$，辅助负载为 $P_{\\mathrm{aux}} = 0.6\\,\\mathrm{MW}$，计划放电功率为 $p^d_t = 10\\,\\mathrm{MW}$。将您的答案四舍五入到四位有效数字。最终的充电功率以 $\\mathrm{MW}$ 为单位表示。",
            "solution": "用户希望我解决“提示”中描述的问题。我将首先验证问题陈述。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n-   **状态变量：** 归一化荷电状态 $s_t \\in [0,1]$。\n-   **定义：** $s_t = E_t / E_{\\max}$，其中 $E_t$ 是存储的能量，$E_{\\max}$ 是可用能量容量。\n-   **区间长度：** $\\Delta t$。\n-   **过程：**\n    -   充电：恒定功率 $p^c_t \\ge 0$，效率 $\\eta_c \\in (0,1]$。\n    -   放电：恒定功率 $p^d_t \\ge 0$，效率 $\\eta_d \\in (0,1]$。\n    -   自放电：速率 $\\lambda \\ge 0$，能量保持因子 $\\phi = \\exp(-\\lambda \\Delta t)$。\n    -   辅助负载：恒定功率 $P_{\\mathrm{aux}} \\ge 0$。\n-   **目标：** 确定最大允许充电功率 $p^c_t$，使得区间结束时 $s_t \\le 1$。\n-   **假设：** 功率在区间内恒定；区间内不发生饱和。\n-   **参数值：**\n    -   $E_{\\max} = 180\\,\\mathrm{MWh}$\n    -   $s_{t-1} = 0.85$\n    -   $\\Delta t = 0.5\\,\\mathrm{h}$\n    -   $\\lambda = 0.01\\,\\mathrm{h}^{-1}$\n    -   $\\eta_c = 0.94$\n    -   $\\eta_d = 0.92$\n    -   $P_{\\mathrm{aux}} = 0.6\\,\\mathrm{MW}$\n    -   $p^d_t = 10\\,\\mathrm{MW}$\n\n**步骤 2：使用提取的给定信息进行验证**\n\n-   **科学依据：** 该问题具有科学依据。它提出了一个储能系统的标准能量平衡模型，包含了充电/放电效率、自放电和辅助负载等公认的概念。该模型基于能量守恒的基本原理。\n-   **良定性：** 该问题是良定的。它要求根据一个明确的约束（$s_t \\le 1$）求解单个未知变量 $p^c_t$，并提供了所有必要的参数。存在唯一解。\n-   **客观性：** 该问题以客观、定量的术语陈述，没有歧义或主观声明。\n-   **一致性和完整性：** 问题设定是自洽的，没有矛盾。提供了所有必需的数据。单位是一致的（MWh、MW、h）。\n-   **真实性：** 参数对于一个电网规模的电池储能系统来说是物理上合理的。在 $0.5\\,\\mathrm{h}$ 的区间内假设功率恒定是能源系统建模中一个常见且可接受的简化。\n\n**步骤 3：结论和行动**\n\n该问题是**有效的**。将提供解答。\n\n### 解题过程\n\n本问题要求计算在一个时间区间 $\\Delta t$ 内，储能系统的最大充电功率 $p^c_t$，以确保最终的荷电状态 $s_t$ 不超过其上限 $1$。该解法源于能量守恒原理。\n\n区间结束时系统存储的能量 $E_t$ 由区间开始时的能量 $E_{t-1}$ 和区间内的净能量变化决定。影响存储能量的过程包括自放电、从电网充电、向电网放电以及内部辅助负载。\n\n能量平衡方程可以通过依次考虑这些过程来建立。首先，区间开始时的能量为 $E_{t-1}$。在区间 $\\Delta t$ 内，这部分能量因自放电而衰减。自放电被建模为速率为 $\\lambda$ 的指数衰减，从而得到一个能量保持因子 $\\phi = \\exp(-\\lambda \\Delta t)$。自放电后剩余的能量为 $E_{t-1} \\phi$。\n\n在该区间内，与功率相关的活动会产生净能量交换。\n$1$. 以功率 $p^c_t$ 和效率 $\\eta_c$ 充电所增加的能量为 $p^c_t \\eta_c \\Delta t$。\n$2$. 为了以效率 $\\eta_d$ 向电网输送放电功率 $p^d_t$，从储能中提取的能量为 $\\frac{p^d_t}{\\eta_d} \\Delta t$。\n$3$. 恒定辅助负载 $P_{\\mathrm{aux}}$ 消耗的能量为 $P_{\\mathrm{aux}} \\Delta t$。\n\n结合这些项，区间结束时的能量 $E_t$ 由以下平衡方程给出：\n$$E_t = E_{t-1} \\phi + p^c_t \\eta_c \\Delta t - \\frac{p^d_t}{\\eta_d} \\Delta t - P_{\\mathrm{aux}} \\Delta t$$\n\n归一化荷电状态 (SoC) 定义为 $s_t = E_t / E_{\\max}$。通过将整个能量平衡方程除以最大可用能量容量 $E_{\\max}$，我们得到 SoC 平衡方程：\n$$\\frac{E_t}{E_{\\max}} = \\frac{E_{t-1}}{E_{\\max}} \\phi + \\frac{\\Delta t}{E_{\\max}} \\left( p^c_t \\eta_c - \\frac{p^d_t}{\\eta_d} - P_{\\mathrm{aux}} \\right)$$\n$$s_t = s_{t-1} \\phi + \\frac{\\Delta t}{E_{\\max}} \\left( p^c_t \\eta_c - \\frac{p^d_t}{\\eta_d} - P_{\\mathrm{aux}} \\right)$$\n\n为了求得最大允许充电功率 $p^c_t$，我们施加边界条件，即最终 SoC 达到其最大值 $s_t = 1$。\n$$1 = s_{t-1} \\phi + \\frac{\\Delta t}{E_{\\max}} \\left( p^c_t \\eta_c - \\frac{p^d_t}{\\eta_d} - P_{\\mathrm{aux}} \\right)$$\n\n现在我们求解该方程以得到 $p^c_t$：\n$$1 - s_{t-1} \\phi = \\frac{\\Delta t}{E_{\\max}} \\left( p^c_t \\eta_c - \\frac{p^d_t}{\\eta_d} - P_{\\mathrm{aux}} \\right)$$\n$$\\frac{E_{\\max}}{\\Delta t} (1 - s_{t-1} \\phi) = p^c_t \\eta_c - \\frac{p^d_t}{\\eta_d} - P_{\\mathrm{aux}}$$\n$$p^c_t \\eta_c = \\frac{E_{\\max}}{\\Delta t} (1 - s_{t-1} \\phi) + \\frac{p^d_t}{\\eta_d} + P_{\\mathrm{aux}}$$\n$$p^c_t = \\frac{1}{\\eta_c} \\left[ \\frac{E_{\\max}}{\\Delta t} (1 - s_{t-1} \\phi) + \\frac{p^d_t}{\\eta_d} + P_{\\mathrm{aux}} \\right]$$\n\n现在我们代入给定的数值：$E_{\\max} = 180\\,\\mathrm{MWh}$，$s_{t-1} = 0.85$，$\\Delta t = 0.5\\,\\mathrm{h}$，$\\lambda = 0.01\\,\\mathrm{h}^{-1}$，$\\eta_c = 0.94$，$\\eta_d = 0.92$，$P_{\\mathrm{aux}} = 0.6\\,\\mathrm{MW}$，以及 $p^d_t = 10\\,\\mathrm{MW}$。\n\n首先，计算能量保持因子 $\\phi$：\n$$\\phi = \\exp(-\\lambda \\Delta t) = \\exp(-0.01 \\times 0.5) = \\exp(-0.005)$$\n\n现在将所有值代入 $p^c_t$ 的表达式中：\n$$p^c_t = \\frac{1}{0.94} \\left[ \\frac{180}{0.5} (1 - 0.85 \\exp(-0.005)) + \\frac{10}{0.92} + 0.6 \\right]$$\n让我们计算括号内的各项：\n$$ \\frac{180\\,\\mathrm{MWh}}{0.5\\,\\mathrm{h}} = 360\\,\\mathrm{MW} $$\n$$ \\frac{10\\,\\mathrm{MW}}{0.92} \\approx 10.869565\\,\\mathrm{MW} $$\n$$ \\exp(-0.005) \\approx 0.9950125 $$\n括号中的第一项是：\n$$ 360 \\times (1 - 0.85 \\times 0.9950125) = 360 \\times (1 - 0.8457606) = 360 \\times 0.1542394 \\approx 55.52618\\,\\mathrm{MW} $$\n对括号内的各项求和：\n$$ 55.52618\\,\\mathrm{MW} + 10.869565\\,\\mathrm{MW} + 0.6\\,\\mathrm{MW} \\approx 66.99575\\,\\mathrm{MW} $$\n最后，我们计算 $p^c_t$：\n$$ p^c_t = \\frac{1}{0.94} \\times 66.99575\\,\\mathrm{MW} \\approx 71.27207\\,\\mathrm{MW} $$\n将结果四舍五入到四位有效数字，我们得到 $71.27\\,\\mathrm{MW}$。",
            "answer": "$$\n\\boxed{71.27}\n$$"
        },
        {
            "introduction": "现实世界中电池的效率并非恒定不变，它会随功率水平和当前荷电状态（$SOC$）等因素而变化。这项进阶实践引入了一个更贴近实际的非线性效率模型，并要求您通过编程实现。通过将这个复杂模型的轨迹与简化的恒定效率基准进行比较，您将能洞察建模假设所带来的影响，并理解模型保真度在系统仿真中的重要性。",
            "id": "4125114",
            "problem": "考虑一个单一的储能设备，其充电状态 (SOC) 通过能量守恒和充放电效率的定义从第一性原理建模。令 $s_t \\in [0,1]$ 表示离散时间步长 $t$ 时的充电状态，令 $C$ 表示可用能量容量，单位为千瓦时 (kWh)，令 $\\Delta t$ 表示时间步长，单位为小时，令 $p_t$ 表示在步长 $t$ 时的净终端功率，单位为千瓦 (kW)（约定 $p_t \\ge 0$ 表示从电网向储能设备充电，$p_t  0$ 表示从储能设备向电网放电）。令每步的自放电分数参数表示为 $\\rho \\in [0,1]$。\n\n充电和放电过程中的效率是功率和充电状态的非线性函数。具体来说，通过以下公式定义充电效率 $\\eta_c(p,s)$ 和放电效率 $\\eta_d(p,s)$：\n$$\n\\eta_c(p,s) = \\operatorname{clip}\\Big(\\eta_{c0} - \\alpha_c \\tanh\\big(|p| / P_{\\mathrm{ref}}\\big) - \\beta_c \\big(s - s^*\\big)^2 \\; ; \\; \\eta_{\\min}, \\eta_{\\max}\\Big),\n$$\n$$\n\\eta_d(p,s) = \\operatorname{clip}\\Big(\\eta_{d0} - \\alpha_d \\tanh\\big(|p| / P_{\\mathrm{ref}}\\big) - \\beta_d \\big(s - s^*\\big)^2 \\; ; \\; \\eta_{\\min}, \\eta_{\\max}\\Big),\n$$\n其中 $\\operatorname{clip}(x;a,b) = \\min\\{\\max\\{x,a\\},b\\}$，$\\eta_{c0}$ 和 $\\eta_{d0}$ 是基准效率，$\\alpha_c, \\alpha_d, \\beta_c, \\beta_d$ 是非线性系数，$P_{\\mathrm{ref}}$ 是参考功率标度，$s^*$ 是一个优选的充电状态（无量纲），$\\eta_{\\min}$ 和 $\\eta_{\\max}$ 将效率限制在物理上有意义的范围内。恒定效率基准在所有步长中都使用 $\\hat{\\eta}_c = \\eta_{c0}$ 和 $\\hat{\\eta}_d = \\eta_{d0}$，而不考虑 $p$ 和 $s$ 的值。\n\n从能量守恒出发，严格定义在一个时间步长内将 $s_{t}$ 更新为 $s_{t+1}$ 的充电状态平衡约束，明确考虑 (i) $p_t$ 的符号，(ii) 上述的非线性效率，以及 (iii) 自放电。实现此更新规则两次：一次使用非线性效率 $\\eta_c(\\cdot,\\cdot)$ 和 $\\eta_d(\\cdot,\\cdot)$，另一次使用恒定效率基准 $\\hat{\\eta}_c$ 和 $\\hat{\\eta}_d$。在每一步，通过硬饱和（即当超出范围时，钳位到最近的边界）强制执行充电状态边界 $s_{\\min} \\le s_t \\le s_{\\max}$。\n\n对于下面的每个测试用例，计算两种充电状态轨迹（非线性和基准），然后报告以下三个量：\n- 非线性效率下的最终充电状态，以小数形式表示。\n- 恒定效率基准下的最终充电状态，以小数形式表示。\n- 在所有时间步长中，两条充电状态轨迹之间的最大绝对偏差，以小数形式表示。\n\n所有功率值必须以千瓦 (kW) 为单位处理，容量以千瓦时 (kWh) 为单位，时间步长以小时为单位；充电状态和输出必须是无量纲的小数。不涉及角度。所有输出均以十进制数表示。你的程序应生成单行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表，其中每个测试用例的结果本身就是一个 $[\\text{final\\_soc\\_nonlinear}, \\text{final\\_soc\\_baseline}, \\text{max\\_trajectory\\_deviation}]$ 形式的列表。\n\n测试套件参数：\n\n测试用例 1（混合充放电，典型操作模式）：\n- $C = 100$ kWh，$\\Delta t = 0.25$ 小时，$\\rho = 0.001$，$s_{\\min} = 0.05$，$s_{\\max} = 0.95$，$s_0 = 0.50$。\n- $\\eta_{c0} = 0.95$，$\\eta_{d0} = 0.94$，$\\alpha_c = 0.08$，$\\alpha_d = 0.10$，$\\beta_c = 0.15$，$\\beta_d = 0.12$，$P_{\\mathrm{ref}} = 50$，$s^* = 0.50$，$\\eta_{\\min} = 0.80$，$\\eta_{\\max} = 0.99$。\n- 功率时间序列 (单位：kW)：$[20, 35, -15, -40, 25, 0, -30, 10, 50, -55, 0, 0, 30, -20, 5, -10]$。\n\n测试用例 2（接近容量边界的持续充电，以测试饱和效应）：\n- $C = 100$ kWh，$\\Delta t = 0.5$ 小时，$\\rho = 0.001$，$s_{\\min} = 0.05$，$s_{\\max} = 0.95$，$s_0 = 0.92$。\n- $\\eta_{c0} = 0.96$，$\\eta_{d0} = 0.95$，$\\alpha_c = 0.06$，$\\alpha_d = 0.08$，$\\beta_c = 0.10$，$\\beta_d = 0.10$，$P_{\\mathrm{ref}} = 60$，$s^* = 0.50$，$\\eta_{\\min} = 0.85$，$\\eta_{\\max} = 0.99$。\n- 功率时间序列 (单位：kW)：$[40, 40, 35, 30, 25, 20, 15, 10]$。\n\n测试用例 3（零流量的边界情况，以隔离自放电效应）：\n- $C = 80$ kWh，$\\Delta t = 1.0$ 小时，$\\rho = 0.01$，$s_{\\min} = 0.05$，$s_{\\max} = 0.95$，$s_0 = 0.33$。\n- $\\eta_{c0} = 0.95$，$\\eta_{d0} = 0.95$，$\\alpha_c = 0.05$，$\\alpha_d = 0.05$，$\\beta_c = 0.05$，$\\beta_d = 0.05$，$P_{\\mathrm{ref}} = 50$，$s^* = 0.50$，$\\eta_{\\min} = 0.80$，$\\eta_{\\max} = 0.99$。\n- 功率时间序列 (单位：kW)：$[0, 0, 0, 0]$。\n\n你的程序必须实现从能量守恒和上述效率定义中导出的充电状态平衡约束，并计算这 3 个测试用例所要求的输出。最终输出必须是形如 $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]$ 的单行文本，其中每个 $a_i$、$b_i$、$c_i$ 都是指定格式的十进制数。",
            "solution": "充电状态 (SOC) 平衡的基本基础是能量守恒与充放电效率的操作性定义相结合。令 $E_t$ 表示在时间步长 $t$ 时储存的能量，单位为千瓦时 (kWh)，令 $s_t$ 为无量纲的充电状态，定义为 $s_t = E_t / C$，其中 $C$ 是可用的能量容量，单位为千瓦时。在一个持续时间为 $\\Delta t$ 小时的离散时间间隔内，能量守恒定律表明，储存能量的变化等于净能量流入减去流出再减去因自放电而损失的能量。\n\n首先，定义终端功率 $p_t$（单位为千瓦）的符号约定。对于 $p_t \\ge 0$，设备从电网向储能设备充电；对于 $p_t  0$，设备从储能设备向电网放电。充电和放电过程存在效率损失。充电效率 $\\eta_c(p_t,s_t) \\in (0,1]$ 将终端充电功率映射为内部能量的增加，而放电效率 $\\eta_d(p_t,s_t) \\in (0,1]$ 将内部能量的减少映射为终端放电功率。\n\n根据效率的定义：\n- 对于充电 ($p_t \\ge 0$)，每单位时间增加的内部能量为 $\\eta_c(p_t,s_t) \\, p_t$。在一个时间间隔内，对储存能量的贡献是 $\\eta_c(p_t,s_t) \\, p_t \\, \\Delta t$。\n- 对于放电 ($p_t  0$)，终端功率的绝对值 $|p_t|$ 是通过消耗内部功率 $|p_t| / \\eta_d(p_t,s_t)$ 产生的。在一个时间间隔内，对储存能量的贡献是 $p_t \\, \\Delta t / \\eta_d(p_t,s_t)$（注意 $p_t  0$，所以此项为负，正确地减少了储存能量）。\n\n自放电被建模为每一步储存能量的分数损失。令 $\\rho \\in [0,1]$ 表示每步的自放电分数。则一个时间步长内的能量守恒可得\n$$\nE_{t+1} = (1 - \\rho)\\, E_t \\;+\\; \\Delta t \\left[ \\eta_c(p_t,s_t) \\, \\max\\{p_t,0\\} \\;+\\; \\frac{ \\min\\{p_t,0\\} }{ \\eta_d(-\\min\\{p_t,0\\},\\,s_t) } \\right].\n$$\n参数 $-\\min\\{p_t,0\\}$ 在放电时等于 $|p_t|$，确保了放电效率是以一个非负的功率大小来计算的。通过 $s_t = E_t / C$ 转换为充电状态可得\n$$\ns_{t+1} = (1 - \\rho)\\, s_t \\;+\\; \\frac{\\Delta t}{C} \\left[ \\eta_c(p_t,s_t) \\, \\max\\{p_t,0\\} \\;+\\; \\frac{ \\min\\{p_t,0\\} }{ \\eta_d(-\\min\\{p_t,0\\},\\,s_t) } \\right].\n$$\n在操作上，此更新后通过硬饱和强制执行边界 $s_{\\min} \\le s_t \\le s_{\\max}$：\n$$\ns_{t+1} \\leftarrow \\operatorname{clip}\\big(s_{t+1} \\, ; \\, s_{\\min}, s_{\\max}\\big).\n$$\n\n非线性效率函数指定为\n$$\n\\eta_c(p,s) = \\operatorname{clip}\\Big(\\eta_{c0} - \\alpha_c \\tanh\\big(|p| / P_{\\mathrm{ref}}\\big) - \\beta_c \\big(s - s^*\\big)^2 \\; ; \\; \\eta_{\\min}, \\eta_{\\max}\\Big),\n$$\n$$\n\\eta_d(p,s) = \\operatorname{clip}\\Big(\\eta_{d0} - \\alpha_d \\tanh\\big(|p| / P_{\\mathrm{ref}}\\big) - \\beta_d \\big(s - s^*\\big)^2 \\; ; \\; \\eta_{\\min}, \\eta_{\\max}\\Big),\n$$\n其中 $\\operatorname{clip}(x;a,b) = \\min\\{\\max\\{x,a\\},b\\}$ 且 $\\tanh(\\cdot)$ 是双曲正切函数。$\\tanh$ 项随着功率绝对值的增大而降低效率（在高功率时饱和），而二次项则在偏离优选充电状态 $s^*$ 时降低效率，这两种效应都被限制在物理上有意义的 $\\eta_{\\min}$ 和 $\\eta_{\\max}$ 范围内。\n\n对于恒定效率基准，我们设置 $\\hat{\\eta}_c = \\eta_{c0}$ 和 $\\hat{\\eta}_d = \\eta_{d0}$，并使用这些与 $(p_t,s_t)$ 无关的常数重用相同的更新规则：\n$$\ns_{t+1}^{\\mathrm{baseline}} = (1 - \\rho)\\, s_t^{\\mathrm{baseline}} \\;+\\; \\frac{\\Delta t}{C} \\left[ \\hat{\\eta}_c \\, \\max\\{p_t,0\\} \\;+\\; \\frac{ \\min\\{p_t,0\\} }{ \\hat{\\eta}_d } \\right],\n$$\n随后进行相同的饱和处理，限制在 $[s_{\\min}, s_{\\max}]$ 范围内。\n\n为每个测试用例计算所要求输出的算法步骤：\n1. 为非线性和基准轨迹初始化 $s_0$。\n2. 对于 $t = 0, 1, \\dots, T-1$：\n   - 对于非线性轨迹，通过指定的非线性公式计算 $\\eta_c(p_t, s_t)$ 和 $\\eta_d(|p_t|, s_t)$；对于基准轨迹，使用常数 $\\hat{\\eta}_c$ 和 $\\hat{\\eta}_d$。\n   - 使用上述的充电状态平衡方程，并结合 $\\max\\{p_t,0\\}$ 和 $\\min\\{p_t,0\\}$ 来更新 $s_{t+1}$。\n   - 将 $s_{t+1}$ 饱和处理至 $[s_{\\min}, s_{\\max}]$ 范围内。\n3. 记录两条轨迹 $\\{s_t^{\\mathrm{nonlinear}}\\}_{t=0}^T$ 和 $\\{s_t^{\\mathrm{baseline}}\\}_{t=0}^T$。\n4. 计算最终的充电状态 $s_T^{\\mathrm{nonlinear}}$ 和 $s_T^{\\mathrm{baseline}}$。\n5. 计算最大绝对偏差 $\\max_{t \\in \\{0,\\dots,T\\}} |s_t^{\\mathrm{nonlinear}} - s_t^{\\mathrm{baseline}}|$。\n6. 对每个测试用例，输出列表 $[s_T^{\\mathrm{nonlinear}}, s_T^{\\mathrm{baseline}}, \\max |s_t^{\\mathrm{nonlinear}} - s_t^{\\mathrm{baseline}}|]$。\n\n因为所有功率值的单位是千瓦 (kW)，容量的单位是千瓦时 (kWh)，时间步长的单位是小时，所以项 $\\frac{\\Delta t}{C} p_t$ 的单位是 $[\\text{小时}] / [\\text{kWh}] \\times [\\text{kW}] = [1]$，因此对充电状态的增量是无量纲的，符合要求。因此，输出是无量纲的小数。\n\n该实现为提供的三个测试用例精确计算这些量，并按指定格式打印单行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef clip(x, a, b):\n    return np.minimum(np.maximum(x, a), b)\n\ndef eta_c(p, s, params):\n    # Charging efficiency, p is terminal power (can be signed); use magnitude in tanh term.\n    eta = params['eta_c0'] - params['alpha_c'] * np.tanh(abs(p) / params['P_ref']) - params['beta_c'] * (s - params['s_star'])**2\n    return float(clip(eta, params['eta_min'], params['eta_max']))\n\ndef eta_d(p, s, params):\n    # Discharging efficiency, p is nonnegative magnitude; use magnitude in tanh term.\n    eta = params['eta_d0'] - params['alpha_d'] * np.tanh(abs(p) / params['P_ref']) - params['beta_d'] * (s - params['s_star'])**2\n    return float(clip(eta, params['eta_min'], params['eta_max']))\n\ndef update_soc_trajectory(power_series, s0, C, dt, rho, s_min, s_max, params, use_nonlinear=True):\n    \"\"\"\n    Compute SOC trajectory given parameters.\n    use_nonlinear: if True, use nonlinear efficiencies; otherwise constant baseline.\n    Returns list of SOC values including initial s0.\n    \"\"\"\n    T = len(power_series)\n    s = s0\n    traj = [float(s)]\n    for t in range(T):\n        p = float(power_series[t])\n        if use_nonlinear:\n            # Evaluate efficiencies at current s and appropriate power magnitude.\n            if p >= 0.0:\n                ec = eta_c(p, s, params)\n                ed = None  # Not used this step\n                delta = (dt / C) * (ec * p)  # charging contribution\n            else:\n                # For discharge, evaluate discharge efficiency with magnitude |p|.\n                ed = eta_d(-p, s, params)\n                delta = (dt / C) * (p / ed)  # discharging contribution (p is negative)\n        else:\n            # Baseline constant efficiencies\n            ec = params['eta_c0']\n            ed = params['eta_d0']\n            if p >= 0.0:\n                delta = (dt / C) * (ec * p)\n            else:\n                delta = (dt / C) * (p / ed)\n\n        s_next = (1.0 - rho) * s + delta\n        # Enforce SOC bounds via hard saturation\n        s_next = float(clip(s_next, s_min, s_max))\n        traj.append(s_next)\n        s = s_next\n    return traj\n\ndef run_test_case(case):\n    # Unpack parameters\n    C = case['C']\n    dt = case['dt']\n    rho = case['rho']\n    s_min = case['s_min']\n    s_max = case['s_max']\n    s0 = case['s0']\n    params = case['params']\n    power_series = case['power_series']\n\n    traj_nonlin = update_soc_trajectory(power_series, s0, C, dt, rho, s_min, s_max, params, use_nonlinear=True)\n    traj_const  = update_soc_trajectory(power_series, s0, C, dt, rho, s_min, s_max, params, use_nonlinear=False)\n\n    final_nonlin = traj_nonlin[-1]\n    final_const = traj_const[-1]\n    # Compute max absolute deviation over all time indices (including initial)\n    deviations = [abs(a - b) for a, b in zip(traj_nonlin, traj_const)]\n    max_dev = max(deviations)\n    return [final_nonlin, final_const, max_dev]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'C': 100.0,\n            'dt': 0.25,\n            'rho': 0.001,\n            's_min': 0.05,\n            's_max': 0.95,\n            's0': 0.50,\n            'params': {\n                'eta_c0': 0.95,\n                'eta_d0': 0.94,\n                'alpha_c': 0.08,\n                'alpha_d': 0.10,\n                'beta_c': 0.15,\n                'beta_d': 0.12,\n                'P_ref': 50.0,\n                's_star': 0.50,\n                'eta_min': 0.80,\n                'eta_max': 0.99,\n            },\n            'power_series': [20, 35, -15, -40, 25, 0, -30, 10, 50, -55, 0, 0, 30, -20, 5, -10],\n        },\n        {\n            'C': 100.0,\n            'dt': 0.5,\n            'rho': 0.001,\n            's_min': 0.05,\n            's_max': 0.95,\n            's0': 0.92,\n            'params': {\n                'eta_c0': 0.96,\n                'eta_d0': 0.95,\n                'alpha_c': 0.06,\n                'alpha_d': 0.08,\n                'beta_c': 0.10,\n                'beta_d': 0.10,\n                'P_ref': 60.0,\n                's_star': 0.50,\n                'eta_min': 0.85,\n                'eta_max': 0.99,\n            },\n            'power_series': [40, 40, 35, 30, 25, 20, 15, 10],\n        },\n        {\n            'C': 80.0,\n            'dt': 1.0,\n            'rho': 0.01,\n            's_min': 0.05,\n            's_max': 0.95,\n            's0': 0.33,\n            'params': {\n                'eta_c0': 0.95,\n                'eta_d0': 0.95,\n                'alpha_c': 0.05,\n                'alpha_d': 0.05,\n                'beta_c': 0.05,\n                'beta_d': 0.05,\n                'P_ref': 50.0,\n                's_star': 0.50,\n                'eta_min': 0.80,\n                'eta_max': 0.99,\n            },\n            'power_series': [0, 0, 0, 0],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Ensure clean single-line output with Python's list formatting.\n    # Optionally format floats to a reasonable number of decimals for readability.\n    # Here we leave default float string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}