{
    "hands_on_practices": [
        {
            "introduction": "发电机启动过程是理解其运行约束的一个绝佳起点。在能源系统模型中，一个关键的现实是，机组在启动后无法瞬时达到其最低稳定出力水平($P^{\\min}$)。本练习  旨在探索斜坡爬升率（$RU$）和最低出力（$P^{\\min}$）这两个关键参数之间的相互作用，通过计算发电机从零出力启动后，达到稳定运行所需的最短时间，从而揭示启动过程中的物理延迟特性。",
            "id": "4130416",
            "problem": "一个热力发电机组在离散时间内建模，周期长度为 $\\Delta t = 1$ 小时。设 $t \\in \\{1,2,\\dots\\}$ 为周期索引，$p_t$ 表示机组的电输出功率（单位为兆瓦），$u_t \\in \\{0,1\\}$ 表示其启停状态。该机组遵循能源系统建模中的三个标准约束：最小稳定输出约束、最大输出约束，以及由于热惯性导致发电机有限的变动率能力而产生的跨时间段爬坡限制。具体来说，对于每个周期 $t$，\n- 最小输出约束为 $p_t \\ge P^{\\min} u_t$，\n- 最大输出约束为 $p_t \\le P^{\\max} u_t$，\n- 爬坡限制（定义为每个周期的最大输出增量）为 $p_t - p_{t-1} \\le RU$。\n\n假设发电机初始处于关闭状态，即 $u_0 = 0$ 且 $p_0 = 0$。该机组从周期 $t=1$ 开始投入运行，因此对于所有 $t \\ge 1$，$u_t = 1$。参数为 $P^{\\min} = 300$ 兆瓦，$P^{\\max} = 500$ 兆瓦，爬坡限制 $RU = 80$ 兆瓦/小时。没有单独的启动爬坡参数；相同的爬坡限制也适用于启动过程。在这些条件下，如果爬坡限制较低，要在第一个运行周期内将 $p_t$ 调度到 $P^{\\min}$ 或更高可能是不可能的，因为跨时间段的变动率约束可能会阻止机组在单个周期内从零达到最小稳定输出。\n\n在给定上述约束和初始条件的情况下，确定最早的周期索引 $t^{\\star} \\ge 1$，使得存在一个满足 $p_{t^{\\star}} \\ge P^{\\min}$ 的可行 $p_{t^{\\star}}$。请以整数形式提供 $t^{\\star}$。最终答案无需四舍五入，也无需单位，因为 $t^{\\star}$ 是一个周期索引。",
            "solution": "首先根据指定标准对问题进行验证。\n\n**第 1 步：提取给定信息**\n- 时间周期长度：$\\Delta t = 1$ 小时。\n- 时间周期索引：$t \\in \\{1, 2, \\dots\\}$。\n- 时间 $t$ 的电输出功率：$p_t$（单位：兆瓦）。\n- 时间 $t$ 的启停状态：$u_t \\in \\{0, 1\\}$。\n- 最小输出约束：$p_t \\ge P^{\\min} u_t$。\n- 最大输出约束：$p_t \\le P^{\\max} u_t$。\n- 爬坡限制：$p_t - p_{t-1} \\le RU$。\n- 初始条件（在 $t=0$ 时）：$u_0 = 0$ 且 $p_0 = 0$。\n- 启停计划（对于 $t \\ge 1$）：$u_t = 1$。\n- 参数：$P^{\\min} = 300$ 兆瓦，$P^{\\max} = 500$ 兆瓦，$RU = 80$ 兆瓦/小时。\n\n**第 2 步：使用提取的信息进行验证**\n- **科学依据：** 该问题使用了热力发电机运行约束的标准简化模型，这在电力系统工程和能源系统建模中是基础。最小和最大输出以及爬坡率的概念是公认的。所提供的值在物理上是合理的。\n- **适定性：** 问题陈述清晰，提供了所有必要的参数和初始条件。它要求一个特定的、可计算的量（最早的时间周期 $t^{\\star}$），并且约束条件足以确定唯一的答案。\n- **客观性：** 问题使用精确、定量和无偏见的技术语言进行描述。它不含主观论断。\n\n**第 3 步：结论与行动**\n该问题具有科学依据、适定性、客观性且内部一致。它被判定为**有效**。将提供解答。\n\n**求解过程**\n目标是找到最早的时间周期 $t^{\\star}$（$t^{\\star} \\ge 1$），在该周期，发电机的输出 $p_{t^{\\star}}$ 能够满足最小输出约束 $p_{t^{\\star}} \\ge P^{\\min}$，同时遵守所有其他约束。\n\n对于任何时间周期 $t \\ge 1$，约束条件如下：\n1. $p_t \\ge P^{\\min} u_t \\implies p_t \\ge 300$ （因为对于 $t \\ge 1$，$u_t=1$）\n2. $p_t \\le P^{\\max} u_t \\implies p_t \\le 500$\n3. $p_t - p_{t-1} \\le RU \\implies p_t \\le p_{t-1} + 80$\n\n我们来考察第一个周期 $t=1$ 的条件。初始条件为 $p_0 = 0$。\n$t=1$ 的爬坡约束为 $p_1 - p_0 \\le RU$，可简化为 $p_1 \\le 0 + 80$，即 $p_1 \\le 80$。\n$t=1$ 的最小输出约束为 $p_1 \\ge P^{\\min}$，即 $p_1 \\ge 300$。\n为了在 $t=1$ 时可行，$p_1$ 必须同时满足 $p_1 \\ge 300$ 和 $p_1 \\le 80$。这是一个矛盾，意味着在 $t=1$ 时不存在能同时满足所有约束的可行功率输出。\n\n这证实了问题陈述中的说法，即在第一个周期内达到最小输出水平可能是不可能的。这意味着在初始启动阶段，不要求满足约束 $p_t \\ge P^{\\min}$。问题要求的是 *最早* 的时间 $t^{\\star}$，在该时间点 *开始变得可能* 满足 $p_{t^{\\star}} \\ge P^{\\min}$。这要求存在一个可行的功率轨迹 $(p_1, p_2, \\dots, p_{t^{\\star}})$，其中对于 $t  t^{\\star}$，输出可以低于 $P^{\\min}$（即 $0 \\le p_t  P^{\\min}$），而在 $t=t^{\\star}$ 时，输出最终可以达到或超过 $P^{\\min}$。\n\n为了找到最早可能的时间 $t^{\\star}$，我们必须考虑最快的启动轨迹。这可以通过在每个周期内将发电机的输出增加最大爬坡值 $RU$ 来实现。我们将这个轨迹定义为 $\\hat{p}_t$。\n初始状态为 $\\hat{p}_0 = 0$。\n对于 $t=1$，最大可能输出为 $\\hat{p}_1 = \\hat{p}_0 + RU = 0 + 80 = 80$。\n对于 $t=2$，最大可能输出为 $\\hat{p}_2 = \\hat{p}_1 + RU = 80 + 80 = 160$。\n通常，假设从 $p_0=0$ 开始无约束地爬坡，在时间 $t$ 可达到的最大功率输出由下式给出：\n$$ \\hat{p}_t = t \\cdot RU $$\n根据构造，该轨迹满足爬坡约束。我们还需要确保它满足最大输出约束 $\\hat{p}_t \\le P^{\\max}$，只要 $t \\cdot RU \\le P^{\\max}$，该约束就成立。\n\n我们正在寻找最小的整数 $t \\ge 1$（记为 $t^{\\star}$），在该时间点，这个可达到的最大功率水平至少为 $P^{\\min}$。\n条件是：\n$$ \\hat{p}_{t^{\\star}} \\ge P^{\\min} $$\n代入 $\\hat{p}_{t^{\\star}}$ 的表达式：\n$$ t^{\\star} \\cdot RU \\ge P^{\\min} $$\n我们可以解出 $t^{\\star}$：\n$$ t^{\\star} \\ge \\frac{P^{\\min}}{RU} $$\n代入给定的数值 $P^{\\min} = 300$ 和 $RU = 80$：\n$$ t^{\\star} \\ge \\frac{300}{80} = \\frac{30}{8} = \\frac{15}{4} = 3.75 $$\n由于时间索引 $t^{\\star}$ 必须是整数，满足此不等式的最小整数值为 $4$。这可以用向上取整函数正式表示：\n$$ t^{\\star} = \\left\\lceil \\frac{P^{\\min}}{RU} \\right\\rceil = \\lceil 3.75 \\rceil = 4 $$\n\n我们来验证在 $t^{\\star} = 4$ 时的可行性。\n在 $t=3$ 时，可达到的最大功率为 $\\hat{p}_3 = 3 \\cdot 80 = 240$。所以我们可以选择一个可行的 $p_3 = 240$，该值小于 $P^{\\min}$。\n在 $t=4$ 时，爬坡约束要求 $p_4 \\le p_3 + RU = 240 + 80 = 320$。\n$p_4$ 的约束条件是：\n- $p_4 \\ge P^{\\min} \\implies p_4 \\ge 300$\n- $p_4 \\le P^{\\max} \\implies p_4 \\le 500$\n- $p_4 \\le p_3 + RU \\implies p_4 \\le 320$\n综合这些条件，一个可行的功率输出 $p_4$ 必须位于区间 $[300, 320]$ 内。由于该区间非空（例如，$p_4 = 310$ 是一个有效选择），所以在 $t=4$ 时存在可行解。对于任何 $t  4$，可达到的最大功率为 $t \\cdot 80$，小于 $300$。因此，$t=4$ 是能够满足最小输出约束的最早周期。",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "在理解了机组的启动限制后，我们进一步考察一个已在运行中的机组其未来的运行灵活性。一个发电机的未来出力可能性并非一成不变，而是形成一个依赖于其当前出力水平的“可行窗口”。本练习  要求您描绘出所有可能的多周期运行轨迹，通过这种方式，您可以具体地感受到发电机调度的动态性和路径依赖性，这对于理解更复杂的动态优化问题至关重要。",
            "id": "4130369",
            "problem": "考虑一个在离散、等间隔时间段 $t \\in \\{0,1,2,3\\}$ 上建模的单一火力发电机组。该机组的物理行为受两个基本运行现实的制约：（i）最小和最大稳定运行水平，以及（ii）由传热和机械限制决定的有限的热升降速率。具体来说：\n- 最小和最大稳定运行水平分别为 $P^{\\min} = 50$ 兆瓦和 $P^{\\max} = 200$ 兆瓦，意味着当机组运行时，其实际功率输出 $p_t$ 必须保持在 $[50,200]$ 兆瓦范围内。\n- 每个时段的升负荷（$RU$）和降负荷（$RD$）能力分别为每时段 $RU = 40$ 兆瓦和每时段 $RD = 60$ 兆瓦，反映了连续时段内 $p_t$ 允许的最大增加和减少量。\n- 该机组在 $t=0$ 时处于开启状态，并产生 $p_0 = 120$ 兆瓦的功率。\n\n假设机组在 $t=1,2,3$ 期间保持开启，并将 $p_t$ 限制为 $10$ 兆瓦的倍数，这反映了适用于市场出清或监控调度的离散化调度粒度。每一步的可行轨迹约束来自于前一输出周围的物理允许升降窗口与稳定运行区间 $[50,200]$ 的交集，此约束在离散化之前应用。\n\n基于上述物理和运行基础，请完成以下任务：\n- 确定所有可行的三时段输出轨迹 $(p_1,p_2,p_3)$ 的完整集合，其中每个 $p_t$ 都是 $10$ 兆瓦的倍数，并与所述的运行限制相符。\n- 对于每个时段，从概念上确定在前一时段可行集所暗示的可行性边界上，哪些约束（升负荷、降负荷、最小输出、最大输出）是紧约束。\n\n将不同可行轨迹 $(p_1,p_2,p_3)$ 的总数作为最终答案报告。请提供精确的整数计数，不要四舍五入。因为这是轨迹的计数，所以它没有单位。",
            "solution": "该问题要求在运行约束条件下，计算一个火力发电机组的可行三时段输出轨迹 $(p_1, p_2, p_3)$ 的总数。分析将从初始条件开始，通过枚举每个时间段的可行状态来进行。\n\n已知条件如下：\n-   $t=0$ 时的初始功率输出：$p_0 = 120$ 兆瓦。\n-   最小稳定功率输出：$P^{\\min} = 50$ 兆瓦。\n-   最大稳定功率输出：$P^{\\max} = 200$ 兆瓦。\n-   升负荷限制：$RU = 40$ 兆瓦/时段。\n-   降负荷限制：$RD = 60$ 兆瓦/时段。\n-   离散化：对于 $t \\in \\{1, 2, 3\\}$，功率输出 $p_t$ 必须是 $10$ 兆瓦的倍数。\n-   机组在所有时间段内都处于开启状态。\n\n在给定前一时间段输出 $p_{t-1}$ 的情况下，任意时间 $t \\in \\{1, 2, 3\\}$ 的功率输出 $p_t$ 的约束可以形式化如下：\n1.  **稳定运行范围**：输出必须在最小和最大稳定水平之间。\n    $$p_t \\in [P^{\\min}, P^{\\max}] \\implies 50 \\le p_t \\le 200$$\n2.  **升降负荷约束**：从一个时间段到下一个时间段的输出变化是有限的。\n    $$p_t - p_{t-1} \\le RU \\implies p_t \\le p_{t-1} + 40$$\n    $$p_{t-1} - p_t \\le RD \\implies p_t \\ge p_{t-1} - 60$$\n    将这些结合起来得到升降负荷窗口：\n    $$p_{t-1} - 60 \\le p_t \\le p_{t-1} + 40$$\n\n$p_t$ 的可行连续范围是这两组约束的交集：\n$$p_t \\in [\\max(P^{\\min}, p_{t-1} - RD), \\min(P^{\\max}, p_{t-1} + RU)]$$\n代入给定值：\n$$p_t \\in [\\max(50, p_{t-1} - 60), \\min(200, p_{t-1} + 40)]$$\n此外，$p_t$ 必须是 $10$ 的倍数。\n\n可行轨迹 $(p_1, p_2, p_3)$ 的总数是所有可能路径的总和。这可以通过迭代计算得出：\n总轨迹数 $= \\sum_{p_1 \\in S_1} \\left( \\sum_{p_2 \\in S_2(p_1)} |S_3(p_2)| \\right)$\n其中 $S_t(p_{t-1})$ 是给定 $p_{t-1}$ 时 $p_t$ 的可行离散输出集合，而 $|S_3(p_2)|$ 是从状态 $p_2$ 可达的 $p_3$ 的可行状态数量。\n\n**步骤 1：从任意给定状态 $p_2$ 确定可行的最终状态 $p_3$ 的数量。**\n令 $C(p_2) \\equiv |S_3(p_2)|$ 为给定 $p_2$ 时 $p_3$ 的可行值数量。由于 $p_2$ 必须是 $10$ 的倍数，且所有约束参数（$50, 60, 200, 40$）也都是 $10$ 的倍数，因此 $p_3$ 的可行范围的界限也将是 $10$ 的倍数。可行值的数量由以下公式给出：\n$$C(p_2) = \\frac{\\min(200, p_2 + 40) - \\max(50, p_2 - 60)}{10} + 1$$\n我们可以将 $C(p_2)$ 定义为其可行范围 $[50, 200]$ 上的关于 $p_2$ 的分段函数：\n-   对于 $p_2 \\in \\{50, 60, ..., 110\\}$：$p_3$ 的范围是 $[50, p_2+40]$。因此，$C(p_2) = \\frac{(p_2+40) - 50}{10} + 1 = \\frac{p_2}{10}$。\n-   对于 $p_2 \\in \\{120, 130, ..., 160\\}$：$p_3$ 的范围是 $[p_2-60, p_2+40]$。因此，$C(p_2) = \\frac{(p_2+40) - (p_2-60)}{10} + 1 = \\frac{100}{10} + 1 = 11$。\n-   对于 $p_2 \\in \\{170, 180, ..., 200\\}$：$p_3$ 的范围是 $[p_2-60, 200]$。因此，$C(p_2) = \\frac{200 - (p_2-60)}{10} + 1 = \\frac{260-p_2}{10} + 1 = 27 - \\frac{p_2}{10}$。\n\n**步骤 2：确定第一个时段的可行状态集合 $S_1$。**\n给定 $p_0 = 120$， $p_1$ 的可行范围是：\n$$p_1 \\in [\\max(50, 120 - 60), \\min(200, 120 + 40)] = [\\max(50, 60), \\min(200, 160)] = [60, 160]$$\n离散可行状态的集合是 $S_1 = \\{60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160\\}$。\n在这一步，下界受降负荷 ($RD$) 约束限制，上界受升负荷 ($RU$) 约束限制。\n\n**步骤 3：计算每个 $p_1 \\in S_1$ 对应的子轨迹 $(p_2, p_3)$ 的数量。**\n对于每个 $p_1 \\in S_1$，我们需要计算 $N_{\\text{paths}}(p_1) = \\sum_{p_2 \\in S_2(p_1)} C(p_2)$。集合 $S_2(p_1)$ 由区间 $[\\max(50, p_1-60), \\min(200, p_1+40)]$ 内 $10$ 的倍数组成。我们为 $S_1$ 中的每个值计算这个和：\n-   $p_1=60$ 时：$p_2 \\in [50, 100]$。$N_{\\text{paths}}(60) = \\sum_{k=50,10}^{100} C(k) = 5+6+7+8+9+10 = 45$。\n-   $p_1=70$ 时：$p_2 \\in [50, 110]$。$N_{\\text{paths}}(70) = \\sum_{k=50,10}^{110} C(k) = 45+11 = 56$。\n-   $p_1=80$ 时：$p_2 \\in [50, 120]$。$N_{\\text{paths}}(80) = \\sum_{k=50,10}^{120} C(k) = 56+11 = 67$。\n-   $p_1=90$ 时：$p_2 \\in [50, 130]$。$N_{\\text{paths}}(90) = \\sum_{k=50,10}^{130} C(k) = 67+11 = 78$。\n-   $p_1=100$ 时：$p_2 \\in [50, 140]$。$N_{\\text{paths}}(100) = \\sum_{k=50,10}^{140} C(k) = 78+11 = 89$。\n-   $p_1=110$ 时：$p_2 \\in [50, 150]$。$N_{\\text{paths}}(110) = \\sum_{k=50,10}^{150} C(k) = 89+11 = 100$。\n-   $p_1=120$ 时：$p_2 \\in [60, 160]$。$N_{\\text{paths}}(120) = \\sum_{k=60,10}^{160} C(k) = (\\sum_{k=50,10}^{160} C(k)) - C(50) = (100+11) - 5 = 106$。\n-   $p_1=130$ 时：$p_2 \\in [70, 170]$。$N_{\\text{paths}}(130) = \\sum_{k=70,10}^{170} C(k) = N_{\\text{paths}}(120) - C(60) + C(170) = 106 - 6 + 10 = 110$。\n-   $p_1=140$ 时：$p_2 \\in [80, 180]$。$N_{\\text{paths}}(140) = \\sum_{k=80,10}^{180} C(k) = N_{\\text{paths}}(130) - C(70) + C(180) = 110 - 7 + 9 = 112$。\n-   $p_1=150$ 时：$p_2 \\in [90, 190]$。$N_{\\text{paths}}(150) = \\sum_{k=90,10}^{190} C(k) = N_{\\text{paths}}(140) - C(80) + C(190) = 112 - 8 + 8 = 112$。\n-   $p_1=160$ 时：$p_2 \\in [100, 200]$。$N_{\\text{paths}}(160) = \\sum_{k=100,10}^{200} C(k) = N_{\\text{paths}}(150) - C(90) + C(200) = 112 - 9 + 7 = 110$。\n\n对于时段 $t=2$ 和 $t=3$，总体的可行输出集合（所有可能输出的并集）覆盖了整个稳定运行范围。可能的最低 $p_2$ 是 $50$（从 $p_1=60$ 得来），这达到了 $P^{\\min}$ 约束。可能的最高 $p_2$ 是 $200$（从 $p_1=160$ 得来），这达到了 $P^{\\max}$ 约束。同样的逻辑适用于发现 $p_3$ 的总体范围也是 $[50, 200]$。因此，对于 $t=2$ 和 $t=3$ 的聚合状态集，边界上的紧约束是 $P^{\\min}$ 和 $P^{\\max}$。\n\n**步骤 4：将路径数量相加，求得轨迹总数。**\n不同可行轨迹 $(p_1, p_2, p_3)$ 的总数是源于每个可行 $p_1$ 的子轨迹数量的总和：\n总轨迹数 $= \\sum_{p_1 \\in S_1} N_{\\text{paths}}(p_1)$\n总数 $= 45 + 56 + 67 + 78 + 89 + 100 + 106 + 110 + 112 + 112 + 110$\n总数 $= 985$\n\n共有 $985$ 条不同的可行三时段输出轨迹。",
            "answer": "$$\\boxed{985}$$"
        },
        {
            "introduction": "前面的练习侧重于物理可行性，现在我们将这一理解延伸到经济层面。虽然最低出力限制是物理上的必要条件，但它会给电力系统带来显著的成本，尤其是在低需求时段。本编程练习  将指导您构建一个简化的机组组合模型，通过对比真实场景与一个理想化的、完全灵活的假设场景，来量化这种“不灵活性成本”，从而深刻理解物理约束如何转化为经济后果。",
            "id": "4130421",
            "problem": "构建并求解一个小型、科学上真实的发电机组组合问题，以量化在低需求期间非零最小出力对成本的影响，并将其与所有最小出力均为零的假设情况进行比较。仅依赖于基本原则：功率平衡、机组能力约束和线性生产成本。该问题纯粹是数学问题，将通过算法实现。\n\n考虑一组以 $i \\in \\{1,2,3\\}$ 为索引的火电机组和一个单一时间段 $t$（一小时）。对每个机组，定义一个二元启停状态变量 $u_i \\in \\{0,1\\}$ 和一个连续功率输出 $p_i \\ge 0$（单位为兆瓦）。设系统需求为 $D$（单位为兆瓦）。为确保在总最小出力超过需求时的可行性，引入一个非负的弃能变量 $s \\ge 0$（单位为兆瓦），代表产生后立即被削减且无价值的能量。采用以下核心约束和成本模型，这些是能源系统建模中的标准模型：\n\n- 功率平衡：\n$$\\sum_{i=1}^{3} p_i \\;=\\; D + s.$$\n- 带最小和最大出力的机组能力：\n$$u_i \\, P_i^{\\min} \\;\\le\\; p_i \\;\\le\\; u_i \\, P_i^{\\max}, \\quad \\text{for } i \\in \\{1,2,3\\}.$$\n- 无跨时段耦合：无爬坡约束，无最小启停时间，无启动/关停成本。\n- 线性生产成本：\n$$\\text{Cost} \\;=\\; \\sum_{i=1}^{3} c_i \\, p_i.$$\n\n定义两种情况：\n- 情况 A（实际）：给定非零的最小出力 $P_i^{\\min}$。\n- 情况 B（假设）：将所有最小出力设为零，即对所有 $i$ 有 $P_i^{\\min}=0$。\n\n对于两种情况，决策变量均为 $u_i$ 和 $p_i$，以及 $s \\ge 0$。目标是在满足约束条件的情况下最小化总生产成本。参数如下：\n\n- 机组 1：$P_1^{\\min} = 50$ MW, $P_1^{\\max} = 200$ MW, $c_1 = 20$ 美元/兆瓦时。\n- 机组 2：$P_2^{\\min} = 30$ MW, $P_2^{\\max} = 100$ MW, $c_2 = 25$ 美元/兆瓦时。\n- 机组 3：$P_3^{\\min} = 10$ MW, $P_3^{\\max} = 50$ MW, $c_3 = 40$ 美元/兆瓦时。\n\n假设时间段为一小时，因此兆瓦和兆瓦时的数值在该小时内是相同的。所有成本以美元表示，四舍五入到两位小数。\n\n编写一个完整且可运行的程序，针对下述每个测试用例，计算情况 A 和情况 B 下的最低总生产成本，并返回成本差异 $\\Delta = \\text{Cost}_{A} - \\text{Cost}_{B}$（以美元为单位）：\n\n- 测试用例 1：$D = 5$ MW。\n- 测试用例 2：$D = 10$ MW。\n- 测试用例 3：$D = 20$ MW。\n- 测试用例 4：$D = 130$ MW。\n- 测试用例 5：$D = 250$ MW。\n\n您的程序必须为每个测试用例以及情况 A 和情况 B 精确求解混合整数线性问题。您可以利用无跨时段耦合和线性成本的结构。弃能变量 $s$ 没有直接成本，但受 $s \\ge 0$ 约束。如果 $D = 0$，则零启停、零出力的解是可行的，成本为零。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如\n$$[x_1,x_2,x_3,x_4,x_5],$$\n其中每个 $x_k$ 是测试用例 $k$ 的 $\\Delta$ 值，以美元为单位，四舍五入到两位小数，不打印任何单位或额外文本。答案值必须是浮点数。\n\n测试套件涵盖：\n- 极低的需求，此时最小出力可能导致弃能（测试1和2）。\n- 一个低但高于最小机组出力的正需求（测试3）。\n- 正常需求，此时最小出力约束不起作用（测试4）。\n- 需要多个机组的高需求（测试5）。",
            "solution": "用户希望我解决一个简化的机组组合问题。以下是我的方法。\n\n### 步骤1：提取给定信息\n- **机组**：$i \\in \\{1,2,3\\}$\n- **时间段**：$t=1$（一小时）\n- **决策变量**：\n    - 二元启停状态：$u_i \\in \\{0,1\\}$，对每个机组 $i$。\n    - 连续功率输出：$p_i \\ge 0$（单位为 MW），对每个机组 $i$。\n    - 弃能：$s \\ge 0$（单位为 MW）。\n- **系统需求**：$D$（单位为 MW）。\n- **约束条件**：\n    1.  功率平衡：$\\sum_{i=1}^{3} p_i = D + s$。\n    2.  机组能力：$u_i P_i^{\\min} \\le p_i \\le u_i P_i^{\\max}$，对 $i \\in \\{1,2,3\\}$。\n- **目标函数**：最小化总生产成本，成本 $= \\sum_{i=1}^{3} c_i p_i$。\n- **机组参数**：\n    - 机组 1：$P_1^{\\min} = 50$ MW, $P_1^{\\max} = 200$ MW, $c_1 = 20$ 美元/MWh。\n    - 机组 2：$P_2^{\\min} = 30$ MW, $P_2^{\\max} = 100$ MW, $c_2 = 25$ 美元/MWh。\n    - 机组 3：$P_3^{\\min} = 10$ MW, $P_3^{\\max} = 50$ MW, $c_3 = 40$ 美元/MWh。\n- **情况**：\n    - **情况 A（实际）**：使用给定的 $P_i^{\\min}$ 值。\n    - **情况 B（假设）**：对所有 $i$，使用 $P_i^{\\min} = 0$。\n- **任务**：对每个测试用例，计算情况 A ($\\text{Cost}_A$) 和情况 B ($\\text{Cost}_B$) 的最低成本，并求出差异 $\\Delta = \\text{Cost}_A - \\text{Cost}_B$。\n- **测试用例（需求）**：\n    - 测试用例 1: $D = 5$ MW。\n    - 测试用例 2: $D = 10$ MW。\n    - 测试用例 3: $D = 20$ MW。\n    - 测试用例 4: $D = 130$ MW。\n    - 测试用例 5: $D = 250$ MW。\n- **输出格式**：单行字符串 `[x_1,x_2,x_3,x_4,x_5]`，其中 $x_k$ 是测试用例 $k$ 的 $\\Delta$ 值，四舍五入到两位小数。\n\n### 步骤2：使用提取的给定信息进行验证\n1.  **科学依据**：该问题是一个经典但简化的电力系统工程中的机组组合问题。该模型使用标准约束（功率平衡、发电限制）和线性成本函数，这些都是能源系统建模的基本原则。将其表述为混合整数线性规划（MILP）是标准做法。该问题在科学上是合理的。\n2.  **良态问题**：该问题是良态的。对于每种情况，一个目标函数（成本）在一个由线性约束定义的紧凑决策变量集上被最小化。解保证存在。由于机组数量少，可以通过枚举法找到精确解。\n3.  **客观性**：语言精确、量化且没有主观性。所有术语都得到了明确定义。\n4.  **完整性**：所有必要的参数（$P^{\\min}$、$P^{\\max}$、$c$、$D$）都已提供。该问题是自包含的。\n5.  **现实性**：参数对于小型火电机组是现实的。场景覆盖了从极低到高需求的范围，这对于测试最小出力约束的影响是相关的。\n\n### 步骤3：结论与行动\n问题是有效的。它是一个定义明确的数学优化问题，植根于能源系统工程的既定原则。我将着手解决。\n\n### 基于原则的设计\n该问题是一个混合整数线性规划（MILP）问题。整数变量是启停决策 $u_i \\in \\{0,1\\}$，连续变量是功率输出 $p_i$ 和弃能 $s$。目标是最小化总生产成本。由于只有3个机组，因此有 $2^3 = 8$ 种可能的启停组合（例如，机组1开启，机组2、3关闭）。该问题可以通过枚举所有8种启停状态，计算每种可行状态的最低成本，并选择总体最低成本的状态来精确求解。\n\n对于一个固定的启停状态（即一组固定的 $u_i$ 值），问题简化为线性规划。设 $U = (u_1, u_2, u_3)$ 为一个特定的启停状态。\n\n1.  **可行性与所需产量**：\n    已启机组的集合是 $I_{on} = \\{i | u_i = 1\\}$。\n    此状态下的总最小发电量为 $P_{\\min}^{\\text{total}} = \\sum_{i \\in I_{on}} P_i^{\\min}$。\n    总最大发电量为 $P_{\\max}^{\\text{total}} = \\sum_{i \\in I_{on}} P_i^{\\max}$。\n    待生产的总功率 $P_{\\text{prod}}$ 必须满足需求 $D$ 和最小发电水平。根据功率平衡方程，$P_{\\text{prod}} = \\sum p_i = D+s$。由于 $s \\ge 0$，我们必须有 $P_{\\text{prod}} \\ge D$。同样，根据机组能力约束，我们必须有 $P_{\\text{prod}} \\ge P_{\\min}^{\\text{total}}$。因此，所需的总产量为 $P_{\\text{req}} = \\max(D, P_{\\min}^{\\text{total}})$。\n    如果这个所需的产量可以被满足，即 $P_{\\text{req}} \\le P_{\\max}^{\\text{total}}$，则启停状态 $U$ 是可行的。如果一个状态不可行，则将其丢弃。弃能量随后计算为 $s = P_{\\text{req}} - D$。\n\n2.  **可行启停状态下的最优调度**：\n    一旦为某个可行的启停状态确定了 $P_{\\text{req}}$，我们必须在已启机组 $\\{i | u_i = 1\\}$ 中分配此功率以最小化成本。成本函数是线性的：$\\sum c_i p_i$。这是一个经典的经济调度问题。最优策略是按照其成本 $c_i$ 的“优先顺序”（从最便宜到最贵）加载机组。\n    调度算法如下：\n    a. 首先，每个已启机组 $i \\in I_{on}$ 必须至少产生其最小出力 $P_i^{\\min}$。这部分占了所需功率的 $P_{\\min}^{\\text{total}}$。\n    b. 剩余的功率 $\\Delta P = P_{\\text{req}} - P_{\\min}^{\\text{total}}$ 必须由已启机组提供。为了以最低成本实现这一点，我们从成本最低的机组开始，逐步增加其功率直至其 $P_i^{\\max}$，然后转向次便宜的机组，以此类推，直到总产量等于 $P_{\\text{req}}$。\n\n3.  **求解情况 A 与情况 B**：\n    - **情况 A（实际 $P_i^{\\min}$）**：应用上述完整算法，枚举所有8种启停状态，并为每种状态找到最低成本调度。\n    - **情况 B（$P_i^{\\min} = 0$）**：在这种情况下，任何启停状态的 $P_{\\min}^{\\text{total}} = 0$。所需的产量始终为 $P_{\\text{req}} = \\max(D, 0) = D$。永远不会有弃能（$s=0$）。问题简化为纯粹的经济调度：通过严格按优先顺序（$c_1  c_2  c_3$）加载机组直至其最大容量来满足需求 $D$，并根据需要启动它们。这不需要枚举所有8种状态；只需对优先顺序进行一次遍历即可找到最优成本。\n\n4.  **最终计算**：对于测试用例中的每个需求水平 $D$，我们使用相应的方法计算 $\\text{Cost}_A$ 和 $\\text{Cost}_B$，并找到差异 $\\Delta = \\text{Cost}_A - \\text{Cost}_B$。\n\n该算法将用 Python 实现。我们将定义机组参数和测试用例，然后创建一个函数来为给定的需求和机组参数求解 MILP。另一个更简单的函数将为情况 B 求解经济调度。主循环将遍历测试用例并计算所需的成本差异。",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the unit commitment problem for the given test cases and prints the results.\n    \"\"\"\n\n    # Define unit parameters for Case A\n    units_case_a = [\n        {'id': 1, 'p_min': 50.0, 'p_max': 200.0, 'cost': 20.0},\n        {'id': 2, 'p_min': 30.0, 'p_max': 100.0, 'cost': 25.0},\n        {'id': 3, 'p_min': 10.0, 'p_max': 50.0, 'cost': 40.0},\n    ]\n\n    # Define unit parameters for Case B (hypothetical, p_min = 0)\n    units_case_b = [\n        {'id': 1, 'p_min': 0.0, 'p_max': 200.0, 'cost': 20.0},\n        {'id': 2, 'p_min': 0.0, 'p_max': 100.0, 'cost': 25.0},\n        {'id': 3, 'p_min': 0.0, 'p_max': 50.0, 'cost': 40.0},\n    ]\n\n    test_demands = [5.0, 10.0, 20.0, 130.0, 250.0]\n\n    results = []\n    \n    for demand in test_demands:\n        cost_a = compute_milp_cost(demand, units_case_a)\n        cost_b = compute_economic_dispatch_cost(demand, units_case_b)\n        \n        delta = cost_a - cost_b\n        results.append(f\"{delta:.2f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef compute_milp_cost(demand, units):\n    \"\"\"\n    Solves the mixed-integer linear problem by enumerating all commitment states.\n    This is exact for a small number of units.\n    \"\"\"\n    if demand == 0.0:\n        return 0.0\n\n    num_units = len(units)\n    min_total_cost = np.inf\n\n    # Iterate through all 2^N commitment combinations\n    for commitment in itertools.product([0, 1], repeat=num_units):\n        \n        committed_units_indices = [i for i, u in enumerate(commitment) if u == 1]\n        if not committed_units_indices:\n            # If demand > 0 and no units are on, this state is infeasible.\n            continue\n            \n        p_min_total = sum(units[i]['p_min'] for i in committed_units_indices)\n        p_max_total = sum(units[i]['p_max'] for i in committed_units_indices)\n\n        # Determine required production and check feasibility\n        p_required = max(demand, p_min_total)\n        \n        if p_required > p_max_total:\n            # This commitment state cannot meet the required production.\n            continue\n\n        # Feasible state, now calculate the minimum cost for this dispatch.\n        # Start with minimum generation.\n        current_cost = 0.0\n        power_dispatch = {i: 0.0 for i in range(num_units)}\n        \n        for i in committed_units_indices:\n            power_dispatch[i] = units[i]['p_min']\n            current_cost += units[i]['p_min'] * units[i]['cost']\n            \n        # Dispatch remaining power economically (merit order)\n        power_to_add = p_required - p_min_total\n        \n        # Sort committed units by cost to dispatch economically\n        sorted_committed_units = sorted([units[i] for i in committed_units_indices], key=lambda x: x['cost'])\n        \n        for unit in sorted_committed_units:\n            if power_to_add == 0:\n                break\n                \n            unit_idx = unit['id'] - 1\n            available_capacity = unit['p_max'] - power_dispatch[unit_idx]\n            dispatch_amount = min(power_to_add, available_capacity)\n            \n            power_dispatch[unit_idx] += dispatch_amount\n            current_cost += dispatch_amount * unit['cost']\n            power_to_add -= dispatch_amount\n            \n        min_total_cost = min(min_total_cost, current_cost)\n\n    return min_total_cost\n\ndef compute_economic_dispatch_cost(demand, units):\n    \"\"\"\n    Solves a simple economic dispatch problem where P_min = 0 for all units.\n    This uses a greedy merit-order dispatch.\n    \"\"\"\n    if demand == 0.0:\n        return 0.0\n\n    # Sort units by cost (merit order)\n    sorted_units = sorted(units, key=lambda x: x['cost'])\n    \n    total_cost = 0.0\n    remaining_demand = demand\n    \n    total_max_cap = sum(u['p_max'] for u in units)\n    if demand > total_max_cap:\n        return np.inf\n\n    for unit in sorted_units:\n        if remaining_demand == 0:\n            break\n            \n        # Dispatch amount is the minimum of what's needed and what the unit can provide\n        dispatch_amount = min(remaining_demand, unit['p_max'])\n        \n        total_cost += dispatch_amount * unit['cost']\n        remaining_demand -= dispatch_amount\n        \n    return total_cost\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}