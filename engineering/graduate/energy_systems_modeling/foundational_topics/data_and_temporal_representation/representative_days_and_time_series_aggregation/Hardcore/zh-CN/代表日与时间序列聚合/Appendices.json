{
    "hands_on_practices": [
        {
            "introduction": "本练习介绍在使用时间序列聚合模型时一个基本的后处理步骤 。它演示了如何利用频率权重，将从少数代表性日得到的结果进行尺度放大，从而还原出如年度总成本和总排放量等关键的全年指标。这项技能对于正确解读那些为提高计算效率而采用聚合方法的能源系统模型的输出至关重要。",
            "id": "4117300",
            "problem": "一个电力系统模型使用时间聚类方法，将全年 $365$ 天的日时间序列聚合为 $4$ 个代表日，以降低运行与投资优化问题的维度。这 $365$ 个原始日被划分为 $4$ 个不相交的簇，每个簇由一个单独的典型日代表。该模型假设运营成本和排放在时间上具有线性可加性，并且当一个代表日代表多个原始日时，进行线性缩放。该聚合过程遵守天数守恒原则，并使用等于每个典型日所代表的原始天数的频率权重。聚合后的优化模型为每个代表日生成了以下输出：每日运营成本（单位：美元(USD)/天）和每日排放量（单位：公吨二氧化碳(CO2)/天）。此外，该优化还生成了由容量投资产生的年固定成本。\n\n代表日 A：\n- 簇大小 $n_{\\mathrm{A}} = 120$\n- 日运营成本 $C_{\\mathrm{A}} = 1.35 \\times 10^{6}$ 美元/天\n- 日排放量 $E_{\\mathrm{A}} = 780$ 公吨二氧化碳/天\n\n代表日 B：\n- 簇大小 $n_{\\mathrm{B}} = 150$\n- 日运营成本 $C_{\\mathrm{B}} = 1.10 \\times 10^{6}$ 美元/天\n- 日排放量 $E_{\\mathrm{B}} = 620$ 公吨二氧化碳/天\n\n代表日 C：\n- 簇大小 $n_{\\mathrm{C}} = 80$\n- 日运营成本 $C_{\\mathrm{C}} = 1.80 \\times 10^{6}$ 美元/天\n- 日排放量 $E_{\\mathrm{C}} = 950$ 公吨二氧化碳/天\n\n代表日 D：\n- 簇大小 $n_{\\mathrm{D}} = 15$\n- 日运营成本 $C_{\\mathrm{D}} = 2.40 \\times 10^{6}$ 美元/天\n- 日排放量 $E_{\\mathrm{D}} = 1{,}300$ 公吨二氧化碳/天\n\n容量投资的年固定成本：\n- $F = 2.50 \\times 10^{8}$ 美元/年\n\n假设排放量的估值使用 $\\lambda = 50$ 美元/公吨二氧化碳的碳价，并且所有成本和排放量都与其代表日的频率权重成线性比例缩放。计算每个代表日的频率权重，并用它们来重构年运营成本和年排放量。然后，计算重构的年度总目标值，其定义为年固定成本、年运营成本和年排放量碳估值之和。以百万美元为单位表示最终答案，并将答案四舍五入到四位有效数字。",
            "solution": "问题陈述已经过验证，是自洽的，其科学基础植根于能源系统建模原理，并且在数学上是适定的。所提供的数据是一致的，因为各簇的大小之和 $n_{\\mathrm{A}} + n_{\\mathrm{B}} + n_{\\mathrm{C}} + n_{\\mathrm{D}} = 120 + 150 + 80 + 15 = 365$，这正确地涵盖了一年中的所有天数。该问题要求根据基于代表日的优化模型的输出，重构年度总成本和总排放量。\n\n此重构的核心原则是，每日的量（成本和排放量）根据其相应的频率权重进行线性缩放。问题陈述指出，频率权重等于簇的大小，即每个代表日所代表的原始时间序列中的天数。\n\n设代表日的集合为 $\\mathcal{D} = \\{\\mathrm{A}, \\mathrm{B}, \\mathrm{C}, \\mathrm{D}\\}$。对于每个代表日 $i \\in \\mathcal{D}$，我们已知其簇大小 $n_i$、日运营成本 $C_i$ 和日排放量 $E_i$。\n\n首先，我们确定每个代表日的频率权重 $w_i$。根据问题描述，这些权重等于簇的大小：\n- A日的频率权重: $w_{\\mathrm{A}} = n_{\\mathrm{A}} = 120$ 天\n- B日的频率权重: $w_{\\mathrm{B}} = n_{\\mathrm{B}} = 150$ 天\n- C日的频率权重: $w_{\\mathrm{C}} = n_{\\mathrm{C}} = 80$ 天\n- D日的频率权重: $w_{\\mathrm{D}} = n_{\\mathrm{D}} = 15$ 天\n\n接下来，我们通过将每个代表日的日运营成本乘以其频率权重后求和，来计算重构的年运营成本 $C_{\\text{annual}}$。\n$$C_{\\text{annual}} = \\sum_{i \\in \\mathcal{D}} w_i C_i = n_{\\mathrm{A}}C_{\\mathrm{A}} + n_{\\mathrm{B}}C_{\\mathrm{B}} + n_{\\mathrm{C}}C_{\\mathrm{C}} + n_{\\mathrm{D}}C_{\\mathrm{D}}$$\n代入给定值：\n$$C_{\\text{annual}} = (120 \\ \\text{天}) \\times (1.35 \\times 10^{6} \\ \\text{美元/天}) + (150 \\ \\text{天}) \\times (1.10 \\times 10^{6} \\ \\text{美元/天}) + (80 \\ \\text{天}) \\times (1.80 \\times 10^{6} \\ \\text{美元/天}) + (15 \\ \\text{天}) \\times (2.40 \\times 10^{6} \\ \\text{美元/天})$$\n$$C_{\\text{annual}} = (1.62 \\times 10^{8} \\ \\text{美元}) + (1.65 \\times 10^{8} \\ \\text{美元}) + (1.44 \\times 10^{8} \\ \\text{美元}) + (0.36 \\times 10^{8} \\ \\text{美元})$$\n$$C_{\\text{annual}} = (1.62 + 1.65 + 1.44 + 0.36) \\times 10^{8} \\ \\text{美元} = 5.07 \\times 10^{8} \\ \\text{美元}$$\n\n类似地，我们通过将每个代表日的日排放量乘以其频率权重后求和，来计算重构的年排放量 $E_{\\text{annual}}$。\n$$E_{\\text{annual}} = \\sum_{i \\in \\mathcal{D}} w_i E_i = n_{\\mathrm{A}}E_{\\mathrm{A}} + n_{\\mathrm{B}}E_{\\mathrm{B}} + n_{\\mathrm{C}}E_{\\mathrm{C}} + n_{\\mathrm{D}}E_{\\mathrm{D}}$$\n代入给定值：\n$$E_{\\text{annual}} = (120 \\ \\text{天}) \\times (780 \\ \\text{tCO2/天}) + (150 \\ \\text{天}) \\times (620 \\ \\text{tCO2/天}) + (80 \\ \\text{天}) \\times (950 \\ \\text{tCO2/天}) + (15 \\ \\text{天}) \\times (1300 \\ \\text{tCO2/天})$$\n$$E_{\\text{annual}} = (93600 \\ \\text{tCO2}) + (93000 \\ \\text{tCO2}) + (76000 \\ \\text{tCO2}) + (19500 \\ \\text{tCO2})$$\n$$E_{\\text{annual}} = 282100 \\ \\text{公吨二氧化碳}$$\n\n年碳排放成本 $V_{\\text{carbon}}$ 是年排放量与碳价 $\\lambda = 50$ 美元/公吨二氧化碳的乘积。\n$$V_{\\text{carbon}} = E_{\\text{annual}} \\times \\lambda$$\n$$V_{\\text{carbon}} = (282100 \\ \\text{tCO2}) \\times (50 \\ \\text{USD/tCO2}) = 14,105,000 \\ \\text{USD}$$\n$$V_{\\text{carbon}} = 1.4105 \\times 10^{7} \\ \\text{USD}$$\n\n年度总目标值 $Z_{\\text{total}}$ 是年固定成本 $F$、年运营成本 $C_{\\text{annual}}$ 和年碳成本 $V_{\\text{carbon}}$ 的总和。\n$$Z_{\\text{total}} = F + C_{\\text{annual}} + V_{\\text{carbon}}$$\n给定的年固定成本为 $F = 2.50 \\times 10^{8}$ 美元。\n$$Z_{\\text{total}} = (2.50 \\times 10^{8} \\ \\text{USD}) + (5.07 \\times 10^{8} \\ \\text{USD}) + (1.4105 \\times 10^{7} \\ \\text{USD})$$\n为了将这些值相加，我们用相同的 $10$ 的幂来表示它们：\n$$Z_{\\text{total}} = (2.50 \\times 10^{8}) + (5.07 \\times 10^{8}) + (0.14105 \\times 10^{8}) \\ \\text{USD}$$\n$$Z_{\\text{total}} = (2.50 + 5.07 + 0.14105) \\times 10^{8} \\ \\text{USD} = 7.71105 \\times 10^{8} \\ \\text{USD}$$\n\n问题要求最终答案以百万美元表示。我们转换总目标值：\n$$Z_{\\text{total}} = 7.71105 \\times 10^{8} \\ \\text{USD} = 771.105 \\times 10^{6} \\ \\text{USD} = 771.105 \\ \\text{百万美元}$$\n\n最后，这个值必须四舍五入到四位有效数字。该数字是 $771.105$。前四位有效数字是 $7$、$7$、$1$ 和 $1$。第五位是 $0$，所以我们向下舍入（截断）。\n四舍五入后的结果是 $771.1$ 百万美元。",
            "answer": "$$\\boxed{771.1}$$"
        },
        {
            "introduction": "时间序列聚合会引入显著误差，特别是对于储能这样对时间动态高度敏感的系统组件 。本实践将指导你通过编程来量化因聚合而产生的储能容量配置偏差。通过对比完整时间序列模型与不同边界条件下的聚合模型，你将更深入地理解平滑效应如何导致储能需求被低估，这是一个在可再生能源高渗透率系统规划中必须仔细考量的问题。",
            "id": "4117337",
            "problem": "要求您设计一个程序，用以量化将时间序列聚合成代表日所导致的储能容量配置偏差，并与一个基于全年逐时分辨率计算的基准进行比较。该能源系统由一个储能设备、一个负荷和一个可变可再生能源 (VRE) 发电机组成。每小时的负荷是恒定的，VRE 发电量是日度和季节性正弦分量的确定性组合。正弦函数中的所有角度都必须以弧度为单位。储能设备模型具有完美的往返效率，无充放电功率限制，且无损耗。时间步长为 $1$ 小时。\n\n基本原理：储能的能量平衡源于能量守恒。设 $t$ 时刻的负荷为 $L_t$（单位：兆瓦，MW），$t$ 时刻的发电量为 $G_t$（单位：兆瓦，MW），时间步长 $\\Delta t = 1$ 小时。$t$ 时刻流入储能的净功率流为 $P_t = G_t - L_t$。储能的荷电状态 $S_t$（单位：兆瓦时，MWh）的演变关系为 $S_{t+1} = S_t + P_t \\Delta t$。储能容量 $E$ 是这样一个最小值：在给定的边界条件下，存在一个初始状态 $S_0$，使得在整个时间范围内对于所有 $t$ 都有 $S_t \\in [0,E]$。您必须在两种不同的边界处理方式下计算 $E$：全年周期性边界和聚合周期边界。\n\n您的程序必须实现以下步骤：\n\n1. 构建全年逐时时间序列，包含 $365$ 天，每天 $24$ 小时，因此 $T = 365 \\times 24$ 小时。对所有 $t$ 使用恒定负荷 $L_t = 1$ MW。发电量构建如下\n$$\nG_t = 1 + A_{\\text{season}} \\sin\\!\\left(\\frac{2\\pi t}{24 \\cdot 365}\\right) + A_{\\text{day}} \\sin\\!\\left(\\frac{2\\pi (t \\bmod 24)}{24}\\right),\n$$\n其中 $A_{\\text{day}} \\ge 0$ 和 $A_{\\text{season}} \\ge 0$ 是振幅（单位：MW）。得到的净功率序列为 $P_t = G_t - L_t$（单位：MW）。因此，$P_t$ 的全年均值为 $0$ MW。储能容量必须以兆瓦时 (MWh) 表示。\n\n2. 全年容量：使用全年逐时序列和周期性边界条件 $S_T = S_0$（针对整个年度），计算最小储能容量 $E_{\\text{full}}$，使得状态 $S_t$ 保持在 $[0,E_{\\text{full}}]$ 区间内。这必须从能量平衡推导得出，并且不能假设任何每日循环重置。\n\n3. 聚合成代表日：按天索引将 $365$ 个日廓线划分为 $k$ 个连续的块，从而产生 $k$ 个代表日。对于块 $b \\in \\{1,\\dots,k\\}$，其权重 $w_b$ 等于其包含的天数，将代表性净廓线 $p^{(b)}_h$（对于小时 $h \\in \\{0,\\dots,23\\}$，单位：MW）定义为该块内各天逐时净功率 $P_t$ 的算术平均值。必须考虑两种不同的聚合边界处理方法：\n   - 独立日循环边界：每个代表日都被独立处理，并采用针对该日的循环边界 $S_{24} = S_0$。通过从每个代表性廓线中移除日均值来对此进行建模，即使用 $\\tilde{p}^{(b)}_h = p^{(b)}_h - \\frac{1}{24}\\sum_{h=0}^{23} p^{(b)}_h$。计算每个 $\\tilde{p}^{(b)}_h$ 所需的日储能范围，并取所有 $b$ 中的最大值作为 $E_{\\text{ind}}$（单位：MWh）。\n   - 串联原型序列边界：通过将每个代表日背靠背地重复 $w_b$ 次，构建一个年长度的聚合序列。不移除日均值。在此串联序列上使用单年周期性边界计算最小储能容量，以获得 $E_{\\text{seq}}$（单位：MWh）。\n\n4. 偏差量化：对于一个聚合容量 $E_{\\text{agg}} \\in \\{E_{\\text{ind}}, E_{\\text{seq}}\\}$，将相对偏差定义为小数\n$$\nB = \\begin{cases}\n\\frac{E_{\\text{agg}} - E_{\\text{full}}}{E_{\\text{full}}},  & \\text{if } E_{\\text{full}} > 0, \\\\\n0,  & \\text{if } E_{\\text{full}} = 0,\n\\end{cases}\n$$\n它是无量纲的。您必须报告下面每个测试用例的此偏差。\n\n物理单位：所有储能容量必须以兆瓦时 (MWh) 计算。三角函数中的角度单位为弧度。最终报告的偏差必须是小数（不带百分号）。\n\n测试套件：实现以下五个测试用例，每个用例由 $(A_{\\text{day}}, A_{\\text{season}}, k, \\text{aggregator\\_type})$ 指定，其中 $\\text{aggregator\\_type}$ 是 $\\text{\"independent\"}$ 或 $\\text{\"sequence\"}$。\n\n- 案例 1 (常规“理想路径”)：$(0.6, 0.3, 12, \\text{\"independent\"})$。\n- 案例 2 (通过串联减少平滑效应)：$(0.6, 0.3, 12, \\text{\"sequence\"})$。\n- 案例 3 (无聚合损失的边界条件)：$(0.5, 0.5, 365, \\text{\"sequence\"})$。\n- 案例 4 (零波动性边界情况)：$(0.0, 0.0, 12, \\text{\"independent\"})$。\n- 案例 5 (强季节性波动，少量代表日)：$(0.3, 0.6, 4, \\text{\"independent\"})$。\n\n最终输出格式：您的程序应生成单行输出，其中包含五个测试用例的偏差，以逗号分隔的列表形式并用方括号括起，顺序与上面列出的顺序相同（例如，$[b_1,b_2,b_3,b_4,b_5]$），其中每个 $b_i$ 是相应案例的小数偏差 $B$。",
            "solution": "我们从一个具有完美往返效率的无损储能设备的能量守恒定律出发。设 $t$ 时刻的负荷为 $L_t$（单位：兆瓦，MW），$t$ 时刻的发电量为 $G_t$（单位：兆瓦，MW）。流入储能的净功率流为 $P_t = G_t - L_t$（单位：兆瓦，MW）。在离散时间步长 $\\Delta t = 1$ 小时的情况下，荷电状态 $S_t$（单位：兆瓦时，MWh）根据以下公式更新\n$$\nS_{t+1} = S_t + P_t \\Delta t.\n$$\n储能容量 $E$ 是这样一个最小标量：存在一个初始状态 $S_0$，使得在所考虑的时间范围内对于所有 $t$ 都有 $S_t \\in [0,E]$。容量 $E$ 取决于整个时间范围内的边界条件。\n\n对于具有单一周期性边界 $S_T = S_0$ 的全年情况，我们通过定义累积能量偏差序列来确定一个标准变换\n$$\nC_t = \\sum_{\\tau=0}^{t-1} P_{\\tau} \\Delta t, \\quad \\text{with } C_0 = 0.\n$$\n根据更新方程，我们有\n$$\nS_t = S_0 + C_t.\n$$\n为满足对所有 $t$ 都有 $S_t \\in [0,E]$，我们可以选择 $S_0$ 来平移 $C_t$ 的范围。最小的 $E$ 等于包围 $\\{S_0 + C_t\\}_{t=0}^{T}$ 的最小区间长度，该长度通过对 $S_0$ 取最小值得到。通过选择 $S_0 = -\\min_t C_t$ 可以实现这一点，从而得到\n$$\nE_{\\text{full}} = \\max_t C_t - \\min_t C_t.\n$$\n此推导关键地依赖于周期性边界以及 $P_t$ 在整个时间范围内的均值为零这一事实，这确保了 $C_t$ 在全年内没有净漂移。在我们的构建中，我们设置 $L_t = 1$ MW 并且\n$$\nG_t = 1 + A_{\\text{season}} \\sin\\!\\left(\\frac{2\\pi t}{24 \\cdot 365}\\right) + A_{\\text{day}} \\sin\\!\\left(\\frac{2\\pi (t \\bmod 24)}{24}\\right),\n$$\n得到 $P_t = G_t - L_t = A_{\\text{season}} \\sin\\!\\left(\\frac{2\\pi t}{24 \\cdot 365}\\right) + A_{\\text{day}} \\sin\\!\\left(\\frac{2\\pi (t \\bmod 24)}{24}\\right)$，其年均值为零，因为两个正弦波在其周期内的均值都为零。所有角度都以弧度为单位。\n\n当聚合成代表日时，从全年序列到 $k$ 个原型的映射会引入平滑效应。我们将 $365$ 个日廓线按天索引划分为 $k$ 个连续的块。对于块 $b$，我们将代表性净廓线 $p^{(b)}_h$ (对于 $h \\in \\{0,\\dots,23\\}$) 定义为该块中日净廓线的算术平均值。块权重 $w_b$ 是该块中的天数。考虑两种边界处理方法：\n\n1. 独立日循环边界。在许多聚合模型中，每个代表日都被独立处理，并采用日内循环边界，即对该日有 $S_{24} = S_0$。这个假设隐含地移除了日内的低频能量不平衡。在数学上，我们通过使用每个代表性廓线的零均值版本来强制实现日内中性\n$$\n\\tilde{p}^{(b)}_h = p^{(b)}_h - \\bar{p}^{(b)}, \\quad \\text{where } \\bar{p}^{(b)} = \\frac{1}{24} \\sum_{h=0}^{23} p^{(b)}_h.\n$$\n对于给定的 $\\tilde{p}^{(b)}_h$，定义其日内累积能量偏差\n$$\n\\tilde{C}^{(b)}_h = \\sum_{\\eta=0}^{h-1} \\tilde{p}^{(b)}_{\\eta} \\Delta t, \\quad \\tilde{C}^{(b)}_0 = 0.\n$$\n该代表日的最小日储能容量等于\n$$\nE^{(b)}_{\\text{day}} = \\max_h \\tilde{C}^{(b)}_h - \\min_h \\tilde{C}^{(b)}_h.\n$$\n在独立日的假设下，年级容量是所有代表日中的最大值，\n$$\nE_{\\text{ind}} = \\max_{b} E^{(b)}_{\\text{day}}.\n$$\n此过程通过平均消除了日间漂移并平滑了波动性，通常会低估季节性储能需求。\n\n2. 串联原型序列边界。为了在保留聚合平滑效应的同时部分恢复时间连续性，我们通过将每个代表日背靠背重复 $w_b$ 次来构建一个年长度的序列，而不改变其均值：\n$$\n\\text{Sequence} = \\big[p^{(1)}_0, \\dots, p^{(1)}_{23}, \\dots, \\text{repeated } w_1 \\text{ times}, \\dots, p^{(k)}_0, \\dots, p^{(k)}_{23}, \\dots, \\text{repeated } w_k \\text{ times}\\big].\n$$\n在这个串联序列上，使用单年周期性边界，最小容量同样是累积范围：\n$$\nE_{\\text{seq}} = \\max_t C^{\\text{seq}}_t - \\min_t C^{\\text{seq}}_t,\n$$\n其中 $C^{\\text{seq}}_t$ 是串联净序列的累积和。因为 $p^{(b)}_h$ 是连续几天的平均值，所以此方法保留了一些低频漂移，但仍然平滑了日内和块内的动态，从而相对于全年 $E_{\\text{full}}$ 减少了但未消除偏差。\n\n相对偏差的度量方式为\n$$\nB = \\begin{cases}\n\\frac{E_{\\text{agg}} - E_{\\text{full}}}{E_{\\text{full}}},  & \\text{if } E_{\\text{full}} > 0, \\\\\n0,  & \\text{if } E_{\\text{full}} = 0.\n\\end{cases}\n$$\n这是一个无量纲小数。负的 $B$ 表示聚合方法低估了容量。对于 $E_{\\text{full}}=0$ 的情况，约定 $B=0$ 以确保在零波动性边界情况下有良定义的输出，此时两种方法都得出 $0$ MWh 的容量。\n\n算法设计：\n- 使用指定的 $A_{\\text{day}}$ 和 $A_{\\text{season}}$ 生成 $T = 365 \\cdot 24$ 的全年净序列 $P_t$。\n- 通过 $P_t$ 累积和的范围计算 $E_{\\text{full}}$。\n- 将 $365$ 天划分为 $k$ 个大小近似相等的连续块；权重 $w_b$ 等于块的大小。\n- 对于每个块，计算 $p^{(b)}_h$ 作为其组成日的平均净廓线。\n- 对于独立日方法，减去日均值，并计算 $E_{\\text{ind}}$ 作为所有块中最大的日累积范围。\n- 对于序列方法，通过将 $p^{(b)}_h$ 重复 $w_b$ 次来构建串联序列，并通过累积范围计算 $E_{\\text{seq}}$。\n- 为每个测试用例计算所要求方法的偏差 $B$。\n- 以指定的单行格式报告五个测试用例的偏差。\n\n通过遵循与能量守恒一致的能量平衡，使用能保持发电量非负的物理上合理的振幅，并显式地建模聚合周期如何改变边界条件和移除低频分量，保证了科学真实性。移除低频分量是可变可再生能源 (VRE) 能源系统建模中储能配置偏差的一个众所周知的来源。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_full_year_net(A_day, A_season):\n    \"\"\"\n    Generate full-year hourly net power sequence P_t = G_t - L_t.\n    Load L_t = 1 MW constant. Generation:\n    G_t = 1 + A_season * sin(2π t / (24*365)) + A_day * sin(2π (t mod 24) / 24).\n    Angles are radians. Returns array of length T=365*24 in MW.\n    \"\"\"\n    days = 365\n    hours_per_day = 24\n    T = days * hours_per_day\n    t = np.arange(T)\n    # Seasonal component varies over the full year period\n    seasonal = A_season * np.sin(2.0 * np.pi * t / (hours_per_day * days))\n    # Daily component varies within each day\n    hour_in_day = t % hours_per_day\n    daily = A_day * np.sin(2.0 * np.pi * hour_in_day / hours_per_day)\n    # Load is 1 MW constant, generation mean is 1 MW plus sinusoids (zero mean)\n    G = 1.0 + seasonal + daily  # MW\n    L = 1.0  # MW\n    P = G - L  # MW\n    return P\n\ndef minimal_capacity_cumulative_range(net_power):\n    \"\"\"\n    Compute minimal storage energy capacity E (MWh) given net power sequence (MW),\n    1-hour timestep, periodic boundary. E = max(cumsum) - min(cumsum).\n    \"\"\"\n    # Cumulative energy deviation in MWh (since Δt=1 h)\n    c = np.cumsum(net_power)\n    # Include initial zero to consider the full range from start\n    c = np.concatenate(([0.0], c))\n    E = float(np.max(c) - np.min(c))\n    return E\n\ndef partition_days(n_days, k):\n    \"\"\"\n    Partition n_days into k contiguous blocks with nearly equal sizes.\n    Returns a list of block sizes that sum to n_days.\n    \"\"\"\n    base = n_days // k\n    remainder = n_days % k\n    # Distribute the remainder across the first 'remainder' blocks\n    block_sizes = [base + 1 if i  remainder else base for i in range(k)]\n    return block_sizes\n\ndef build_representative_days(net_power, k):\n    \"\"\"\n    Build k representative daily net profiles by averaging contiguous blocks of days.\n    Returns:\n      prototypes: list of arrays length 24 (MW)\n      weights: list of integers (number of days in each block)\n    \"\"\"\n    hours_per_day = 24\n    n_days = net_power.size // hours_per_day\n    # Reshape to [n_days, 24]\n    daily_matrix = net_power.reshape(n_days, hours_per_day)\n    block_sizes = partition_days(n_days, k)\n    prototypes = []\n    weights = []\n    start = 0\n    for bsize in block_sizes:\n        end = start + bsize\n        block = daily_matrix[start:end, :]  # shape [bsize, 24]\n        proto = block.mean(axis=0)  # MW\n        prototypes.append(proto)\n        weights.append(bsize)\n        start = end\n    return prototypes, weights\n\ndef capacity_independent_day(prototypes):\n    \"\"\"\n    Compute E_ind (MWh) under independent cyclic day boundary:\n    For each prototype, subtract its mean to enforce zero-sum, compute cumulative range,\n    then take the maximum across prototypes.\n    \"\"\"\n    hours_per_day = 24\n    E_days = []\n    for p in prototypes:\n        p = np.asarray(p)\n        p_zero_mean = p - np.mean(p)\n        c = np.cumsum(p_zero_mean)\n        c = np.concatenate(([0.0], c))\n        E_day = float(np.max(c) - np.min(c))\n        E_days.append(E_day)\n    return float(np.max(E_days)) if E_days else 0.0\n\ndef capacity_concatenated_sequence(prototypes, weights):\n    \"\"\"\n    Compute E_seq (MWh) by concatenating prototypes repeated by weights and\n    computing the cumulative range over the full concatenated sequence.\n    \"\"\"\n    seq = []\n    for proto, w in zip(prototypes, weights):\n        # Repeat the 24-hour profile w times\n        repeated = np.tile(np.asarray(proto), int(w))\n        seq.append(repeated)\n    if not seq:\n        return 0.0\n    concatenated = np.concatenate(seq)\n    return minimal_capacity_cumulative_range(concatenated)\n\ndef compute_bias(E_agg, E_full):\n    \"\"\"\n    Compute relative bias B = (E_agg - E_full) / E_full if E_full > 0 else 0.\n    \"\"\"\n    if E_full > 0.0:\n        return (E_agg - E_full) / E_full\n    else:\n        return 0.0\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (A_day, A_season, k, aggregator_type)\n    test_cases = [\n        (0.6, 0.3, 12, \"independent\"),\n        (0.6, 0.3, 12, \"sequence\"),\n        (0.5, 0.5, 365, \"sequence\"),\n        (0.0, 0.0, 12, \"independent\"),\n        (0.3, 0.6, 4, \"independent\"),\n    ]\n\n    results = []\n    for A_day, A_season, k, agg_type in test_cases:\n        net = generate_full_year_net(A_day, A_season)  # MW\n        # Full-year minimal capacity in MWh\n        E_full = minimal_capacity_cumulative_range(net)\n\n        # Build representative days\n        prototypes, weights = build_representative_days(net, k)\n\n        if agg_type == \"independent\":\n            E_agg = capacity_independent_day(prototypes)\n        elif agg_type == \"sequence\":\n            E_agg = capacity_concatenated_sequence(prototypes, weights)\n        else:\n            # Should not happen for given test cases; default to 0\n            E_agg = 0.0\n\n        bias = compute_bias(E_agg, E_full)\n        # Use a reasonable numeric precision formatting via str() for final print\n        results.append(bias)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在时间序列聚合中，一个关键的建模选择是如何处理极端事件或离群值 。本练习通过求解一个容量扩张问题来探讨这一选择所带来的深远影响。你将比较两种情景：一种是将极端负荷日平均化处理，另一种是将其作为独立的代表日明确保留。通过这种对比，你将直接观察到对离群值的不同处理方式如何改变对可靠容量的优化投资决策，以及对期望缺负荷小时数（LOLE）和期望缺供电量（EUE）等关键可靠性指标的评估。",
            "id": "4117398",
            "problem": "考虑一个用于能源系统建模的、在时间序列聚合下的单节点容量扩张和可靠性评估问题。规划者选择一个非负的固定容量 $K$（单位为兆瓦）来满足一个外生的逐时需求曲线。未满足的需求会根据“缺负荷价值”(VOLL) 产生罚款，而已安装的容量则会产生固定的年化投资成本。全年的需求通过具有相应整数日权重的代表日来近似。比较两种聚合情景，以展示将一个离群日明确地作为固定代表日所带来的影响。\n\n基本基础：\n- 将任何小时的小时缺电量定义为 $\\max(L - K, 0)$，其中 $L$ 是实际需求（单位为兆瓦），$K$ 是已安装的固定容量（单位为兆瓦）。\n- 设 $C_{\\text{inv}}$ 为每兆瓦每年的投资成本（单位为货币），$v$ 为每兆瓦时的缺负荷价值 (VOLL)（单位为货币）。\n- 给定由 $d$ 索引的、具有整数权重 $w_d$（天）的代表日曲线，以及从 $1$ 到 $24$ 索引的小时 $h$，对于给定的 $K$，年度目标函数为\n$$J(K) = C_{\\text{inv}} \\cdot K + v \\cdot \\sum_{d} w_d \\sum_{h=1}^{24} \\max\\left(L_{d,h} - K, 0\\right).$$\n- 可靠性指标在加权时间范围内定义：\n  - 缺负荷期望 (LOLE)，单位为小时/年，等于 $\\sum_d w_d \\sum_{h=1}^{24} \\mathbf{1}\\{L_{d,h} > K\\}$。\n  - 期望未服务电量 (EUE)，单位为兆瓦时/年，等于 $\\sum_d w_d \\sum_{h=1}^{24} \\max(L_{d,h} - K, 0)$。\n\n时间序列和聚合定义：\n- 构建一个每日24小时的合成日需求曲线集。其中有10个“正常”日，由 $d \\in \\{1,\\dots,10\\}$ 索引，以及1个“离群”日。对于小时 $h \\in \\{1,\\dots,24\\}$，将正常日的需求定义为\n$$L^{\\text{norm}}_{d,h} = 50 + 10 \\cdot \\sin\\!\\left(2\\pi \\cdot \\frac{h - 8}{24}\\right) + 2 \\cdot \\sin\\!\\left(2\\pi \\cdot \\frac{d}{10}\\right).$$\n- 通过采用与 $d=1$ 相同的基本昼夜变化形状，并在傍晚/夜间时段增加一个30兆瓦的局部峰值，来定义离群日曲线 $L^{\\text{out}}_{h}$：\n$$L^{\\text{out}}_{h} = \\left(50 + 10 \\cdot \\sin\\!\\left(2\\pi \\cdot \\frac{h - 8}{24}\\right) + 2 \\cdot \\sin\\!\\left(2\\pi \\cdot \\frac{1}{10}\\right)\\right) + \\Delta_h,$$\n其中，如果 $h \\in \\{17, 18, 19, 20\\}$，则 $\\Delta_h = 30$，否则 $\\Delta_h = 0$。\n- 聚合情景 A（不包括离群日）：使用单个代表日，其等于10个正常日的算术平均值，权重为10。形式上，$L^{A}_{h} = \\frac{1}{10} \\sum_{d=1}^{10} L^{\\text{norm}}_{d,h}$，权重 $w^{A} = 10$。\n- 聚合情景 B（将离群日作为固定代表日包括在内）：使用两个代表日，即权重为10的平均正常日 $L^{A}_{h}$，和权重为1的离群日 $L^{\\text{out}}_{h}$。\n\n两种情景下的决策问题：\n- 对于给定的 $C_{\\text{inv}}$（货币/兆瓦·年）和 $v$（货币/兆瓦时），选择 $K \\ge 0$ 以最小化使用该情景的代表集和权重所定义的 $J(K)$。在最优解 $K^\\star$ 处，计算 LOLE（小时/年）和 EUE（兆瓦时/年）。\n\n算法要求：\n- 通过在由 $K=0$ 和情景代表曲线中所有唯一的逐时需求值组成的有限候选集上评估目标函数 $J(K)$ 来求解 $K^\\star$。选择使 $J(K)$ 最小化的 $K$。如果存在多个最小值点，则选择其中最小的 $K$。\n\n单位和报告：\n- 报告容量 $K^\\star$（单位兆瓦），LOLE（单位小时/年）和 EUE（单位兆瓦时/年）。所有报告的数字必须四舍五入到三位小数。\n\n测试套件：\n- 使用以下三个测试用例，每个用例由 $(C_{\\text{inv}}, v)$ 指定：\n  - 测试 1：$(50{,}000, 10{,}000)$。\n  - 测试 2：$(3{,}000{,}000, 10{,}000)$。\n  - 测试 3：$(1{,}000, 10{,}000)$。\n这些用例涵盖了一个典型的权衡情况、一个零容量可能是最优的高投资成本极端情况，以及一个接近“覆盖峰值”的情况。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含一个包含18个数字的扁平列表，按以下顺序排列，所有数字都四舍五入到三位小数：对于每个按升序排列的测试 $t \\in \\{1,2,3\\}$，列出 $[K^{A,\\star}_t,\\ \\text{LOLE}^{A}_t,\\ \\text{EUE}^{A}_t,\\ K^{B,\\star}_t,\\ \\text{LOLE}^{B}_t,\\ \\text{EUE}^{B}_t]$，然后将这些每个测试的列表连接成一个长度为18的扁平列表。输出必须严格按照单个带方括号、逗号分隔的 Python 风格列表（例如 $[x_1,x_2,\\dots,x_{18}]$）打印。",
            "solution": "我们使用目标函数的定义和分段线性的缺负荷罚函数，从第一性原理推导出解决方案。\n\n1. 构建时间序列。\n   - 对于每个正常日 $d \\in \\{1,\\dots,10\\}$ 和小时 $h \\in \\{1,\\dots,24\\}$，定义负荷\n   $$L^{\\text{norm}}_{d,h} = 50 + 10 \\cdot \\sin\\!\\left(2\\pi \\cdot \\frac{h - 8}{24}\\right) + 2 \\cdot \\sin\\!\\left(2\\pi \\cdot \\frac{d}{10}\\right).$$\n   这产生了一个在傍晚时分达到峰值的昼夜模式，由于项 $2 \\cdot \\sin\\!\\left(2\\pi \\cdot d/10\\right)$ 的存在，日间存在轻微的变化。\n   - 通过在 $d=1$ 的基本曲线上增加一个日末峰值来定义离群日：\n   $$L^{\\text{out}}_{h} = \\left(50 + 10 \\cdot \\sin\\!\\left(2\\pi \\cdot \\frac{h - 8}{24}\\right) + 2 \\cdot \\sin\\!\\left(2\\pi \\cdot \\frac{1}{10}\\right)\\right) + \\Delta_h,$$\n   其中，对于 $h \\in \\{17,18,19,20\\}$，$\\Delta_h = 30$，否则 $\\Delta_h = 0$。这样可以在一个短时间窗口内构建一个合理的极端峰值。\n\n2. 构建代表性情景。\n   - 情景 A：代表日是10个正常日每小时的算术平均值，\n   $$L^{A}_{h} = \\frac{1}{10} \\sum_{d=1}^{10} L^{\\text{norm}}_{d,h},$$\n   权重 $w^{A} = 10$ 天。总加权小时数为 $24 \\cdot 10$。\n   - 情景 B：使用两个代表日，即权重为10的平均正常日 $L^{A}_{h}$ 和权重为1的离群日 $L^{\\text{out}}_{h}$。总加权小时数为 $24 \\cdot 11$。\n\n3. 为给定的非负容量 $K$ 定义目标函数和指标。\n   - 年化成本为\n   $$J(K) = C_{\\text{inv}} \\cdot K + v \\cdot \\sum_{d} w_d \\sum_{h=1}^{24} \\max(L_{d,h} - K, 0).$$\n   - 可靠性指标为\n   $$\\text{LOLE}(K) = \\sum_{d} w_d \\sum_{h=1}^{24} \\mathbf{1}\\{L_{d,h} > K\\}, \\quad \\text{EUE}(K) = \\sum_{d} w_d \\sum_{h=1}^{24} \\max(L_{d,h} - K, 0).$$\n\n4. 凸性和最优解的特征。\n   - 对于每个小时，$f_h(K) = \\max(L_h - K, 0)$ 是关于 $K$ 的凸函数和分段线性函数，当 $K  L_h$ 时次梯度为 $-1$，当 $K = L_h$ 时次梯度为 $[-1,0]$ 中的任意值，当 $K > L_h$ 时次梯度为 $0$。\n   - 因为 $J(K)$ 是线性项 $C_{\\text{inv}} \\cdot K$ 与凸函数 $f_h(K)$ 的非负加权和之和，所以 $J(K)$ 是凸函数和分段线性函数。因此，最优解 $K^\\star$ 存在于 $J(K)$ 的某个断点处，这些断点发生在 $K$ 等于 $0$ 或聚合代表集中的某个逐时负荷值。\n   - $J$ 在 $K$ 处的次梯度为\n   $$\\partial J(K) \\ni C_{\\text{inv}} - v \\cdot \\sum_{d} w_d \\sum_{h=1}^{24} g_{d,h}(K),$$\n   其中，如果 $K  L_{d,h}$，则 $g_{d,h}(K) = 1$；如果 $K = L_{d,h}$，则 $g_{d,h}(K) \\in [0,1]$；如果 $K > L_{d,h}$，则 $g_{d,h}(K) = 0$。在任何可微点（即非断点处），$g_{d,h}(K) = \\mathbf{1}\\{L_{d,h} > K\\}$，所以导数为\n   $$J'(K) = C_{\\text{inv}} - v \\cdot \\sum_{d} w_d \\sum_{h=1}^{24} \\mathbf{1}\\{L_{d,h} > K\\}.$$\n   对于内部极小值点，一阶最优性条件为 $J'(K^\\star) = 0$，其解释为边际投资成本与期望缺电成本的边际减少量相平衡，后者与高于 $K^\\star$ 的加权小时数成正比。\n   - 在离散、分段线性的设定中，可以通过在有限集合 $\\{0\\} \\cup \\{L_{d,h}\\ \\text{对于所有代表小时}\\}$ 上评估 $J(K)$，并选择使 $J(K)$ 最小的最小的 $K$ 来找到精确的最小值点。这满足了凸最优性条件，并避免了在平坦区域的歧义。\n\n5. 用于计算任何给定 $(C_{\\text{inv}}, v)$ 和任一聚合情景下所需输出的算法。\n   - 步骤 1：为情景构建代表性数组 $\\{L_{d,h}\\}$ 和权重 $\\{w_d\\}$。\n   - 步骤 2：构建非负断点的候选集 $\\mathcal{K} = \\{0\\} \\cup \\{L_{d,h}\\}$。\n   - 步骤 3：对于每个 $K \\in \\mathcal{K}$，计算如上定义的 $J(K)$、$\\text{LOLE}(K)$ 和 $\\text{EUE}(K)$。选择使 $J(K)$ 最小化的 $K^\\star$；如果存在多个最小值点，则选择最小的那个 $K$。\n   - 步骤 4：报告 $K^\\star$（兆瓦）、$\\text{LOLE}(K^\\star)$（小时/年）和 $\\text{EUE}(K^\\star)$（兆瓦时/年），每个值都四舍五入到三位小数。\n\n6. 解释测试套件以及包含离群日的影响。\n   - 测试 1 中 $(C_{\\text{inv}}, v) = (50{,}000, 10{,}000)$ 产生了一个“允许的”超限小时数，其规模与几个小时相当，因此情景 B 中离群日的4小时尖峰的存在，使得最优的 $K^\\star$ 相对于情景 A 向上移动，以更高的容量成本为代价，减少了情景 B 中的 $\\text{LOLE}$ 和 $\\text{EUE}$。\n   - 测试 2 中 $(C_{\\text{inv}}, v) = (3{,}000{,}000, 10{,}000)$ 意味着边际投资成本在整个加权时间范围内都主导着缺电成本（因为 $C_{\\text{inv}}/v$ 超过了总加权小时数），所以在两种情景下最优解都是 $K^\\star = 0$；由于总加权小时数和峰值大小不同，两种情景的可靠性指标会有所不同，这说明了即使投资为零，可靠性核算仍然重要。\n   - 测试 3 中 $(C_{\\text{inv}}, v) = (1{,}000, 10{,}000)$ 使得缺电相对于容量来说非常昂贵，从而驱动 $K^\\star$ 基本上覆盖情景中的最大小时负荷。将离群日作为固定代表日包括进来，增加了情景的最大负荷，从而增加了情景 B 中的 $K^\\star$，与情景 A 相比，进一步减少了 $\\text{LOLE}$ 和 $\\text{EUE}$。\n\n程序精确地实现了这些步骤，计算了在指定的测试用例中两种聚合情景下的最优容量和可靠性指标，并按照要求的顺序和单位打印了一个包含18个四舍五入数字的扁平列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_normal_days():\n    \"\"\"\n    Build 10 normal days, each with 24 hours.\n    L_norm[d, h]: d=0..9 corresponds to days 1..10, h=0..23 corresponds to hours 1..24.\n    \"\"\"\n    hours = np.arange(1, 25)  # 1..24\n    # Base diurnal shape\n    diurnal = 50.0 + 10.0 * np.sin(2.0 * np.pi * (hours - 8.0) / 24.0)\n    normals = []\n    for d in range(1, 11):  # days 1..10\n        day_variation = 2.0 * np.sin(2.0 * np.pi * d / 10.0)\n        L_d = diurnal + day_variation\n        normals.append(L_d)\n    return np.array(normals)  # shape (10, 24)\n\ndef build_outlier_day():\n    \"\"\"\n    Build the outlier day using the base diurnal shape for d=1 and add +30 MW at hours {17, 18, 19, 20}.\n    \"\"\"\n    hours = np.arange(1, 25)  # 1..24\n    diurnal = 50.0 + 10.0 * np.sin(2.0 * np.pi * (hours - 8.0) / 24.0)\n    base = diurnal + 2.0 * np.sin(2.0 * np.pi * 1.0 / 10.0)  # d=1 baseline\n    delta = np.zeros_like(base)\n    # Add 30 MW to hours 17,18,19,20\n    for h in [17, 18, 19, 20]:\n        delta[h - 1] = 30.0\n    return base + delta  # shape (24,)\n\ndef representative_scenario_A(normals):\n    \"\"\"\n    Scenario A: single representative day = mean of normals, weight = 10.\n    Returns list of (profile, weight).\n    \"\"\"\n    mean_day = normals.mean(axis=0)\n    return [(mean_day, 10)]\n\ndef representative_scenario_B(normals, outlier):\n    \"\"\"\n    Scenario B: two representatives: mean normal day (weight 10), outlier day (weight 1).\n    Returns list of (profile, weight).\n    \"\"\"\n    mean_day = normals.mean(axis=0)\n    return [(mean_day, 10), (outlier, 1)]\n\ndef evaluate_objective_and_metrics(K, reps, C_inv, v):\n    \"\"\"\n    Compute J(K), LOLE(K), EUE(K) for given K and representative days.\n    reps: list of (profile array length 24, weight integer)\n    \"\"\"\n    total_eue = 0.0\n    total_lole = 0.0\n    for prof, w in reps:\n        shortage = np.maximum(prof - K, 0.0)\n        total_eue += w * shortage.sum()\n        total_lole += w * np.count_nonzero(prof > K)\n    J = C_inv * K + v * total_eue\n    return J, total_lole, total_eue\n\ndef solve_one_scenario(reps, C_inv, v):\n    \"\"\"\n    Enumerate candidate K values: {0} union all unique hourly loads in reps.\n    Return optimal (K*, LOLE*, EUE*) with the smallest K* among minimizers.\n    \"\"\"\n    # Collect candidate K values\n    candidates = [0.0]\n    for prof, _ in reps:\n        candidates.extend(prof.tolist())\n    # Unique and sorted\n    K_candidates = np.unique(np.array(candidates))\n    best_J = None\n    best_K = None\n    best_lole = None\n    best_eue = None\n    for K in K_candidates:\n        J, lole, eue = evaluate_objective_and_metrics(K, reps, C_inv, v)\n        if (best_J is None) or (J  best_J - 1e-12) or (abs(J - best_J) = 1e-12 and K  best_K):\n            best_J = J\n            best_K = K\n            best_lole = lole\n            best_eue = eue\n    return best_K, best_lole, best_eue\n\ndef round3(x):\n    return float(f\"{x:.3f}\")\n\ndef solve():\n    # Build data\n    normals = build_normal_days()\n    outlier = build_outlier_day()\n    reps_A = representative_scenario_A(normals)\n    reps_B = representative_scenario_B(normals, outlier)\n\n    # Define the test cases (C_inv, v)\n    test_cases = [\n        (50000.0, 10000.0),   # Test 1\n        (3000000.0, 10000.0), # Test 2\n        (1000.0, 10000.0),    # Test 3\n    ]\n\n    results = []\n    for C_inv, v in test_cases:\n        # Scenario A\n        K_A, LOLE_A, EUE_A = solve_one_scenario(reps_A, C_inv, v)\n        # Scenario B\n        K_B, LOLE_B, EUE_B = solve_one_scenario(reps_B, C_inv, v)\n        # Append rounded results in required order\n        results.extend([\n            round3(K_A), round3(LOLE_A), round3(EUE_A),\n            round3(K_B), round3(LOLE_B), round3(EUE_B),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}