{
    "hands_on_practices": [
        {
            "introduction": "A common simplification in long-term energy planning is to use a Load Duration Curve (LDC), which sorts load data by magnitude and discards the temporal sequence. While computationally convenient, this approach can lead to significant errors for systems with assets constrained by inter-temporal dynamics. This first practice provides a direct, quantitative illustration of this issue by tasking you with calculating the production cost error that arises when an LDC model is used instead of a chronological dispatch for a generator with physical ramp-rate limits.",
            "id": "4129555",
            "problem": "Consider a single thermal generation unit with continuous power output that is constrained by a symmetric ramp-rate limit between consecutive time steps. The system load is deterministic and given by a sinusoid over a fixed horizon. You will compare chronological dispatch, which respects adjacency in time, to a Load Duration Curve (LDC) dispatch, which ignores chronology by sorting the load levels, and compute the production cost error incurred when replacing chronological dispatch by LDC dispatch.\n\nFundamental base and definitions:\n- Let the time horizon be of duration $T$ hours, discretized into $N$ equal steps with time step $\\Delta t = T/N$ hours.\n- The load at discrete time index $t \\in \\{0,1,\\dots,N-1\\}$ is $L_t$ in megawatts (MW), following the sinusoid $L_t = L_0 + A \\sin\\left( 2\\pi \\frac{t}{N} \\right)$, where $L_0$ is the mean load in MW and $A$ is the amplitude in MW.\n- The generator produces $p_t$ in megawatts (MW) at time step $t$, with ramp-rate constraint\n$$\n|p_t - p_{t-1}| \\le r \\quad \\text{for } t \\ge 1,\n$$\nwhere $r = R \\Delta t$ is the per-step ramp limit in MW, and $R$ is the continuous ramp rate in MW/hour. The initial condition is $p_0 = L_0 + A \\sin\\left( 0 \\right) = L_0$.\n- Energy over a step is power times duration. The produced energy at time $t$ is $p_t \\Delta t$ in megawatt-hours (MWh). The unmet energy (shortage) at time $t$ is $s_t = \\max(0, L_t - p_t)$ in MW, contributing $s_t \\Delta t$ in MWh.\n- The production cost is linear in energy, with variable cost $c$ in dollars per megawatt-hour ($\\$/\\text{MWh}$). Unserved energy incurs a penalty $v$ in dollars per megawatt-hour ($\\$/\\text{MWh}$). Assume any overgeneration (where $p_t > L_t$) is curtailed at zero resale value but still incurs the production cost $c$.\n- Chronological dispatch cost is\n$$\nC_{\\text{chron}} = c \\sum_{t=0}^{N-1} p_t \\Delta t + v \\sum_{t=0}^{N-1} s_t \\Delta t.\n$$\n- LDC dispatch ignores the ramp constraint by assuming the generator can meet the load in each duration segment when sorted by magnitude. With a single unit and linear production cost, this yields\n$$\nC_{\\text{LDC}} = c \\sum_{t=0}^{N-1} L_t \\Delta t,\n$$\nbecause all load is assumed fully served with no shortage and no chronology constraints.\n- Define the production cost error as\n$$\nE = C_{\\text{chron}} - C_{\\text{LDC}},\n$$\nin dollars, rounded to two decimal places.\n\nRole of sequence in ramp feasibility:\n- The ramp-rate constraint couples adjacent times, so feasibility depends on the sequence $\\{L_t\\}$ and the per-step differences $\\Delta L_t = L_t - L_{t-1}$. Sorting the load as in the LDC erases adjacency and thus cannot enforce $|p_t - p_{t-1}| \\le r$. For a sinusoid $L(t) = L_0 + A \\sin\\left( \\frac{2\\pi}{T} t \\right)$, the maximum continuous slope magnitude is $\\left| \\frac{dL}{dt} \\right|_{\\max} = \\frac{2\\pi A}{T}$ in MW/hour. In discrete time, a necessary condition for exact tracking is $R \\ge \\max_t \\left| \\frac{L_t - L_{t-1}}{\\Delta t} \\right|$, which is violated whenever the time-adjacent differences exceed $R$, creating shortages on up-ramps and potential overgeneration on down-ramps.\n\nYour task:\n- Implement a program that computes the chronological dispatch respecting the ramp-rate constraint to minimize $C_{\\text{chron}}$ under linear production cost $c$ and shortage penalty $v$.\n- Compute the LDC dispatch cost $C_{\\text{LDC}}$ for the same load and generator parameters as defined above.\n- Report the production cost error $E$ for each provided test case.\n\nNumerical units and output requirements:\n- All given and computed physical quantities must be treated with their units: power in megawatts (MW), time in hours (h), energy in megawatt-hours (MWh), costs in dollars ($).\n- Express the final production cost error $E$ for each test case in dollars, as a float rounded to two decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[e1,e2,e3]\").\n\nTest suite:\nUse the following four parameter sets to test different facets of the solution. Each test case is a tuple $(L_0, A, T, N, c, v, R)$, with units $(\\text{MW}, \\text{MW}, \\text{h}, -, \\$/\\text{MWh}, \\$/\\text{MWh}, \\text{MW}/\\text{h})$.\n\n1. General case (happy path, sufficiently high ramp rate for perfect tracking): $(100, 30, 24, 96, 50, 5000, 12)$.\n2. Moderate ramp insufficiency (chronology causes up-ramp shortages): $(100, 30, 24, 96, 50, 5000, 6)$.\n3. Severe ramp insufficiency (large errors due to both up-ramp shortages and down-ramp overgeneration): $(100, 30, 24, 96, 50, 5000, 0.5)$.\n4. Boundary condition (ramp equals the sinusoid’s maximum continuous slope): $(100, 30, 24, 96, 50, 5000, \\frac{2\\pi A}{T})$. For implementation, set $R$ numerically to $R = \\frac{2\\pi A}{T}$.\n\nYour program must implement the chronological ramp-constrained dispatch, compute $C_{\\text{chron}}$ and $C_{\\text{LDC}}$, and output the four $E$ values in dollars as a single list on one line, rounded to two decimal places.",
            "solution": "The problem requires the computation of the production cost error, $E$, which arises from substituting a simplified Load Duration Curve (LDC) dispatch model for a more realistic chronological dispatch model that accounts for generator ramp-rate constraints. The error is defined as $E = C_{\\text{chron}} - C_{\\text{LDC}}$. We will first formalize the calculation of each cost component and then derive the algorithm for the chronological dispatch.\n\nThe time horizon of duration $T$ is discretized into $N$ steps of length $\\Delta t = T/N$. The system load at time index $t \\in \\{0, 1, \\dots, N-1\\}$ is given by the sinusoidal function $L_t = L_0 + A \\sin\\left( 2\\pi \\frac{t}{N} \\right)$.\n\nFirst, we address the LDC dispatch cost, $C_{\\text{LDC}}$. This model assumes the generator can meet any load level at any time, ignoring the temporal sequence and thus the ramp-rate constraints. With a linear production cost, $c$, and the assumption that all load is served, the total production is simply the total energy demanded by the load.\n$$\nC_{\\text{LDC}} = c \\sum_{t=0}^{N-1} (L_t \\cdot \\Delta t) = c \\Delta t \\sum_{t=0}^{N-1} L_t\n$$\nThis calculation is a direct summation of the given load profile, multiplied by the cost and time-step duration.\n\nNext, we address the chronological dispatch cost, $C_{\\text{chron}}$. This cost is subject to the ramp-rate constraint $|p_t - p_{t-1}| \\le r$ for $t \\ge 1$, where $p_t$ is the power production at time $t$ and $r = R \\Delta t$ is the maximum allowed change in production per time step. The initial condition is given as $p_0 = L_0$, which is equal to the load at $t=0$, $L_0 = L_0 + A \\sin(0)$.\n\nThe total chronological cost is given by:\n$$\nC_{\\text{chron}} = \\sum_{t=0}^{N-1} \\left( c \\cdot p_t \\cdot \\Delta t + v \\cdot s_t \\cdot \\Delta t \\right) = \\Delta t \\sum_{t=0}^{N-1} \\left( c \\cdot p_t + v \\cdot \\max(0, L_t - p_t) \\right)\n$$\nwhere $v$ is the high penalty for unserved energy ($s_t \\Delta t$). The objective is to determine the production sequence $\\{p_t\\}_{t=0}^{N-1}$ that minimizes this total cost.\n\nThe problem has a sequential structure. The optimal decision for $p_t$ depends only on the state from the previous step, $p_{t-1}$. This allows us to solve the problem by making a locally optimal decision at each time step from $t=1$ to $t=N-1$. For each step $t$, we must find the value of $p_t$ that minimizes the single-step cost, $\\text{cost}_t(p_t) = c \\cdot p_t + v \\cdot \\max(0, L_t - p_t)$, subject to the constraint $p_{t-1} - r \\le p_t \\le p_{t-1} + r$.\n\nLet us analyze the single-step cost function. It is a piecewise linear, convex function of $p_t$.\n- For $p_t \\ge L_t$, the cost is $c \\cdot p_t$. The slope is $c > 0$.\n- For $p_t < L_t$, the cost is $c \\cdot p_t + v(L_t - p_t) = (c-v)p_t + v L_t$. Since the shortage penalty $v$ is significantly larger than the production cost $c$ (e.g., $v=5000$, $c=50$), the slope $c-v$ is negative.\n\nThe unconstrained minimum of $\\text{cost}_t(p_t)$ occurs at $p_t = L_t$, where the function has a \"V\" shape. To minimize the constrained cost, we must choose the point in the feasible interval $[p_{t-1}-r, p_{t-1}+r]$ that is closest to the unconstrained minimum, $L_t$. This is a projection of $L_t$ onto the feasible interval. The optimal production level, $p_t^*$, is therefore given by:\n- If $L_t$ is within the interval, $p_{t-1}-r \\le L_t \\le p_{t-1}+r$, then $p_t^* = L_t$.\n- If $L_t > p_{t-1}+r$, the generator cannot ramp up fast enough to meet the load. The closest feasible point is the upper bound, so $p_t^* = p_{t-1}+r$. This results in a shortage $s_t = L_t - p_t^* > 0$.\n- If $L_t < p_{t-1}-r$, the generator cannot ramp down fast enough. The closest feasible point is the lower bound, so $p_t^* = p_{t-1}-r$. This results in overgeneration relative to the load ($p_t^* > L_t$) but no shortage ($s_t = 0$).\n\nThis logic is compactly expressed as:\n$$\np_t^* = \\max(p_{t-1} - r, \\min(L_t, p_{t-1} + r))\n$$\nThis is equivalent to clamping or clipping the target value $L_t$ to the feasible range defined by the ramp-rate limit.\n\nThe algorithm to compute $C_{\\text{chron}}$ proceeds as follows:\n1.  Initialize parameters $L_0, A, T, N, c, v, R$ and calculate derived constants $\\Delta t = T/N$ and $r = R \\Delta t$.\n2.  Generate the load vector $\\{L_t\\}_{t=0}^{N-1}$.\n3.  Initialize the production vector $\\{p_t\\}_{t=0}^{N-1}$ by setting the initial condition $p_0 = L_0$.\n4.  Initialize $C_{\\text{chron}} = (c \\cdot p_0) \\cdot \\Delta t$, as $s_0 = \\max(0, L_0 - p_0) = 0$.\n5.  Iterate from $t=1$ to $N-1$:\n    a. Determine the optimal production $p_t$ using the rule $p_t = \\max(p_{t-1} - r, \\min(L_t, p_{t-1} + r))$.\n    b. Calculate the shortage $s_t = \\max(0, L_t - p_t)$.\n    c. Add the cost for the current step, $(c \\cdot p_t + v \\cdot s_t) \\cdot \\Delta t$, to $C_{\\text{chron}}$.\n\nFinally, the production cost error is computed as $E = C_{\\text{chron}} - C_{\\text{LDC}}$ and rounded to two decimal places.\n\nFor test cases where the ramp rate $R$ is sufficiently high, the per-step ramp limit $r$ may exceed the maximum change in load between any two consecutive steps, i.e., $r \\ge \\max_t |L_t - L_{t-1}|$. In such cases, if $p_{t-1}=L_{t-1}$, then $|L_t - p_{t-1}| = |L_t-L_{t-1}| \\le r$, which implies that the target load $L_t$ is always within the feasible production interval $[p_{t-1}-r, p_{t-1}+r]$. By induction from the initial state $p_0=L_0$, the optimal dispatch is always $p_t = L_t$. Consequently, $C_{\\text{chron}} = \\sum c \\cdot L_t \\Delta t = C_{\\text{LDC}}$, yielding a production cost error $E=0$. This applies to test cases 1 and 4, where the provided ramp rate $R$ is greater than the maximum rate of change of the discrete load signal. For cases 2 and 3, $R$ is insufficient, leading to deviations between $p_t$ and $L_t$, and thus a positive error $E$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the production cost error problem for a set of test cases.\n    \"\"\"\n\n    def compute_production_cost_error(L0, A, T, N, c, v, R):\n        \"\"\"\n        Computes the production cost error between chronological and LDC dispatch.\n\n        Args:\n            L0 (float): Mean load in MW.\n            A (float): Amplitude of sinusoidal load in MW.\n            T (float): Time horizon in hours.\n            N (int): Number of time steps.\n            c (float): Variable production cost in $/MWh.\n            v (float): Unserved energy penalty in $/MWh.\n            R (float): Continuous ramp rate in MW/hour.\n\n        Returns:\n            float: The production cost error E, rounded to two decimal places.\n        \"\"\"\n        \n        # 1. Parameter and Load Profile Setup\n        delta_t = T / N\n        r = R * delta_t  # Per-step ramp limit in MW\n        \n        t_steps = np.arange(N)\n        load = L0 + A * np.sin(2 * np.pi * t_steps / N)\n        \n        # 2. LDC Dispatch Cost Calculation\n        # Assumes all load is met, no constraints.\n        c_ldc = c * np.sum(load) * delta_t\n        \n        # 3. Chronological Dispatch and Cost Calculation\n        p = np.zeros(N)  # Production schedule in MW\n        \n        # Initial condition at t=0\n        # Problem statement: p_0 = L_0. Load at t=0 is L0 + A*sin(0) = L0.\n        p[0] = L0\n        \n        # Shortage at t=0 is max(0, load[0] - p[0]), which is 0.\n        c_chron = c * p[0] * delta_t\n        \n        # Iterate through the time horizon to determine the optimal dispatch\n        for t in range(1, N):\n            p_prev = p[t-1]\n            \n            # The optimal dispatch p[t] is the projection of the load[t] onto\n            # the feasible interval [p_prev - r, p_prev + r].\n            p[t] = np.clip(load[t], p_prev - r, p_prev + r)\n            \n            # Calculate shortage (unmet load) at the current step\n            s_t = max(0, load[t] - p[t])\n            \n            # Accumulate cost for the current step\n            cost_t = (c * p[t] + v * s_t) * delta_t\n            c_chron += cost_t\n            \n        # 4. Compute the final error\n        error = c_chron - c_ldc\n        \n        return round(error, 2)\n\n    # Test suite from the problem statement\n    # Each case is a tuple (L0, A, T, N, c, v, R)\n    test_cases = [\n        (100, 30, 24, 96, 50, 5000, 12),\n        (100, 30, 24, 96, 50, 5000, 6),\n        (100, 30, 24, 96, 50, 5000, 0.5),\n        # For the 4th case, R is defined by a formula\n        (100, 30, 24, 96, 50, 5000, (2 * np.pi * 30) / 24),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = compute_production_cost_error(*params)\n        results.append(result)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having established the necessity of chronological modeling for ramp-constrained generators, we now apply this principle to energy storage—a critical component for managing modern power grids. This exercise focuses on a fundamental design problem: determining the minimum energy capacity a storage system needs to successfully \"shave\" peak loads down to a specified cap. Solving this requires you to model the state of charge chronologically, as the ability to discharge during a peak depends directly on the history of available charging opportunities.",
            "id": "4129549",
            "problem": "You are given a discrete chronological net load series over a horizon of $24$ hours, a target peak cap, and storage charge and discharge efficiencies. The objective is to compute the minimum energy capacity, expressed in megawatt-hour (MWh), of an idealized storage system that caps the net load at or below the specified target across the entire day, under the following physically realistic constraints.\n\nFundamental base and core definitions: consider a discrete-time representation with hour index $t \\in \\{0,1,\\dots,T-1\\}$ where $T=24$, and time step $\\Delta t = 1$ hour. Let $L_t$ denote the chronological net load (megawatt), which is the residual demand after non-dispatchable supply. Let $P^{\\mathrm{cap}}$ denote the target cap (megawatt), so the requirement is to ensure the net load does not exceed $P^{\\mathrm{cap}}$ at any hour. The storage has State of Charge (SoC) denoted $s_t$ (megawatt-hour) at the start of hour $t$, a charge efficiency $\\eta_c \\in (0,1]$, and a discharge efficiency $\\eta_d \\in (0,1]$. Let $u_t^{c}$ denote the charging power (megawatt) during hour $t$, and let the required discharging power $u_t^{d}$ be the non-negative power necessary to reduce the net load down to the cap, which is determined by chronology and the cap: $$u_t^{d} = \\max\\{0, L_t - P^{\\mathrm{cap}}\\}.$$ Similarly, the maximum feasible charging power to avoid exceeding the cap while charging is $$U_t^{c} = \\max\\{0, P^{\\mathrm{cap}} - L_t\\}.$$ The hourly SoC dynamics, derived from conservation of energy and the definition of efficiencies, are $$s_{t+1} = s_t + \\eta_c \\, u_t^c \\, \\Delta t - \\frac{u_t^{d}}{\\eta_d} \\, \\Delta t,$$ where $\\Delta t = 1$ hour. The storage energy capacity $E$ (megawatt-hour) must satisfy the bound constraints $$0 \\le s_t \\le E \\quad \\text{for all } t,$$ and cyclic daily operation requires $$s_T = s_0.$$\n\nThe minimum feasible capacity problem is: find the smallest $E$ such that there exists a charging schedule $\\{u_t^c\\}_{t=0}^{T-1}$ with $0 \\le u_t^c \\le U_t^c$ for all $t$, satisfying the SoC dynamics, the cyclic boundary condition, and the SoC bounds, given mandatory discharges $\\{u_t^d\\}$ that enforce the cap. If no such schedule exists (i.e., chronology and efficiencies imply an energy imbalance that cannot be recovered by feasible charging), report infeasibility.\n\nTasks:\n1. Implement a program that, for each given test case, formulates and solves the minimum capacity problem in purely mathematical terms, using the discrete dynamics above, and returns the minimum $E$ in megawatt-hour (MWh), rounded to three decimal places. If the problem is infeasible for a test case, return the sentinel value $-1.000$.\n2. You must explicitly enforce the cyclic boundary condition $s_T = s_0$, the SoC bounds $0 \\le s_t \\le E$, and the charging bounds $0 \\le u_t^c \\le U_t^c$, and you must treat discharging $u_t^d$ as fixed by chronology. Use $\\Delta t = 1$ hour, so energy in megawatt-hour equals power in megawatt times one.\n3. You must express the final capacity answer in megawatt-hour (MWh), rounded to three decimals.\n\nTest suite:\nProvide results for the following four test cases, each specified by $(\\{L_t\\}_{t=0}^{23}, P^{\\mathrm{cap}}, \\eta_c, \\eta_d)$.\n\n- Case $1$ (general happy path): \n  - $P^{\\mathrm{cap}} = 50$,\n  - $\\eta_c = 0.92$, $\\eta_d = 0.90$,\n  - $\\{L_t\\}_{t=0}^{23} = [48, 52, 55, 60, 62, 58, 54, 49, 45, 43, 46, 50, 53, 57, 65, 63, 59, 56, 52, 48, 44, 42, 47, 51]$.\n\n- Case $2$ (boundary energy-balance feasibility with symmetry):\n  - $P^{\\mathrm{cap}} = 50$,\n  - $\\eta_c = 0.90$, $\\eta_d = 0.90$,\n  - Construct valleys and peaks such that $\\sum_t \\eta_c U_t^c = \\sum_t \\frac{u_t^d}{\\eta_d}$: set $b=9$ and $a = \\frac{b}{\\eta_c \\eta_d} = \\frac{9}{0.9 \\cdot 0.9} = 11.111\\ldots$, so\n  - $\\{L_t\\}_{t=0}^{23} = [38.8888888889 \\text{ (repeated } 12 \\text{ times)}, 59 \\text{ (repeated } 12 \\text{ times)}]$.\n\n- Case $3$ (significant edge case: infeasible due to insufficient valley energy under efficiencies):\n  - $P^{\\mathrm{cap}} = 50$,\n  - $\\eta_c = 0.90$, $\\eta_d = 0.90$,\n  - $\\{L_t\\}_{t=0}^{23} = [42 \\text{ (repeated } 12 \\text{ times)}, 60 \\text{ (repeated } 12 \\text{ times)}]$.\n\n- Case $4$ (edge case: no peaks above the cap, zero capacity):\n  - $P^{\\mathrm{cap}} = 50$,\n  - $\\eta_c = 0.95$, $\\eta_d = 0.95$,\n  - $\\{L_t\\}_{t=0}^{23} = [45, 46, 47, 48, 49, 50, 49, 48, 47, 46, 45, 44, 45, 46, 47, 48, 49, 50, 49, 48, 47, 46, 45, 44]$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is the computed minimum capacity for the corresponding test case in megawatt-hour (MWh), rounded to three decimals, or $-1.000$ if infeasible. For example, the output must have the form $$[x_1,x_2,x_3,x_4],$$ where each $x_i$ is a float as specified.",
            "solution": "The problem asks for the minimum energy capacity $E$ of a storage system required to cap a chronological net load profile $L_t$ at a given peak level $P^{\\mathrm{cap}}$. The solution must adhere to the system's dynamics, physical constraints, and a cyclic operational requirement.\n\n### Step 1: Problem Validation\n\n**1.1. Extract Givens**\n\n-   **Time Horizon**: $t \\in \\{0, 1, \\dots, T-1\\}$ with $T=24$.\n-   **Time Step**: $\\Delta t = 1$ hour.\n-   **Chronological Net Load**: $L_t$ (MW).\n-   **Target Peak Cap**: $P^{\\mathrm{cap}}$ (MW).\n-   **Storage State of Charge (SoC)**: $s_t$ (MWh) at the start of hour $t$.\n-   **Efficiencies**: Charge efficiency $\\eta_c \\in (0, 1]$, Discharge efficiency $\\eta_d \\in (0, 1]$.\n-   **Charging Power**: $u_t^c$ (MW).\n-   **Discharging Power**: $u_t^{d} = \\max\\{0, L_t - P^{\\mathrm{cap}}\\}$ (MW). This is a mandatory, non-negative power injection required to meet the cap.\n-   **Maximum Feasible Charging Power**: $U_t^{c} = \\max\\{0, P^{\\mathrm{cap}} - L_t\\}$ (MW).\n-   **SoC Dynamics**: $s_{t+1} = s_t + \\eta_c \\, u_t^c \\, \\Delta t - \\frac{u_t^{d}}{\\eta_d} \\, \\Delta t$.\n-   **Storage Constraints**:\n    -   SoC bounds: $0 \\le s_t \\le E$ for all $t$.\n    -   Charging bounds: $0 \\le u_t^c \\le U_t^c$ for all $t$.\n    -   Cyclic condition: $s_T = s_0$.\n-   **Objective**: Find the minimum feasible energy capacity $E$ (MWh).\n-   **Infeasibility**: If no solution exists, report infeasibility.\n\n**1.2. Validate Using Extracted Givens**\n\n-   **Scientifically Grounded**: The problem is based on the well-established principles of energy conservation applied to an energy storage system. The model uses standard definitions for efficiencies, state of charge, and power flows. It is a simplified but physically realistic representation used in energy systems modeling.\n-   **Well-Posed**: The problem is structured as a constrained optimization problem: minimizing a variable $E$ subject to a set of linear constraints on the system's state and control variables. This structure is well-posed and admits a unique minimum value for $E$ if a feasible solution exists.\n-   **Objective**: The problem is stated using precise mathematical definitions and objective language. There are no subjective or ambiguous terms.\n-   **Completeness**: All necessary data and equations ($L_t$, $P^{\\mathrm{cap}}$, efficiencies, dynamics, constraints) are provided to formulate a solvable model.\n-   **Consistency**: The givens are internally consistent. The physics of charging and discharging are correctly represented in the SoC dynamics equation. For instance, to discharge $u_t^d$ to the grid, energy of $u_t^d / \\eta_d$ must be drawn from the storage, correctly accounting for losses.\n\n**1.3. Verdict and Action**\n\nThe problem is **valid**. It is a scientifically sound, well-posed, and objective problem in the domain of energy systems engineering. I will proceed with formulating and solving it.\n\n### Step 2: Mathematical Formulation and Solution\n\nThe core task is to find the minimum energy capacity $E$ that allows for a feasible operating schedule. This can be formulated as a constrained optimization problem.\n\n**A. Feasibility Condition**\n\nFirst, we establish a necessary condition for any feasible solution to exist. The SoC dynamics are given by (with $\\Delta t=1$):\n$$s_{t+1} = s_t + \\eta_c u_t^c - \\frac{u_t^{d}}{\\eta_d}$$\nSumming this equation from $t=0$ to $t=T-1$:\n$$\\sum_{t=0}^{T-1} (s_{t+1} - s_t) = \\sum_{t=0}^{T-1} \\left( \\eta_c u_t^c - \\frac{u_t^{d}}{\\eta_d} \\right)$$\nThe left-hand side is a telescoping sum equal to $s_T - s_0$. The cyclic boundary condition $s_T = s_0$ implies that this sum is zero. Therefore, the total energy balance over the cycle is:\n$$\\sum_{t=0}^{T-1} \\eta_c u_t^c = \\sum_{t=0}^{T-1} \\frac{u_t^{d}}{\\eta_d}$$\nThis equation signifies that the total energy charged into the storage (accounting for charging efficiency) must equal the total energy drawn from the storage to meet discharge requirements (accounting for discharge efficiency).\n\nThe charging power is constrained by $0 \\le u_t^c \\le U_t^c$. Summing over the cycle gives an upper bound on the total possible energy that can be charged:\n$$\\sum_{t=0}^{T-1} \\eta_c u_t^c \\le \\sum_{t=0}^{T-1} \\eta_c U_t^c$$\nCombining these two results yields a fundamental feasibility condition:\n$$\\sum_{t=0}^{T-1} \\frac{u_t^{d}}{\\eta_d} \\le \\sum_{t=0}^{T-1} \\eta_c U_t^c$$\nThe total energy required for discharge (from the storage's perspective) must be less than or equal to the total maximum energy available for charging (into the storage). If this condition is violated, the storage system has an irrecoverable energy deficit over the cycle, and no feasible charging schedule exists. The problem is then infeasible.\n\n**B. Linear Programming Formulation**\n\nIf the feasibility condition holds, we can find the minimum capacity $E$ by solving a linear program (LP). The problem is to minimize $E$ subject to a set of linear constraints.\n\nThe optimization variables are:\n-   The energy capacity $E$.\n-   The state of charge at the beginning of each hour: $\\{s_0, s_1, \\dots, s_{T-1}\\}$.\n-   The charging power for each hour: $\\{u_0^c, u_1^c, \\dots, u_{T-1}^c\\}$.\n\nThe LP is formulated as follows:\n\n**Minimize:**\n$$E$$\n**Subject to:**\n\n1.  **SoC Dynamics (Equality Constraints):** These $T$ constraints link the state variables across time steps. For $t \\in \\{0, \\dots, T-2\\}$:\n    $$s_{t+1} - s_t - \\eta_c u_t^c = -\\frac{u_t^d}{\\eta_d}$$\n    And for the final step, incorporating the cyclic condition $s_T=s_0$:\n    $$s_0 - s_{T-1} - \\eta_c u_{T-1}^c = -\\frac{u_{T-1}^d}{\\eta_d}$$\n\n2.  **SoC Capacity Limits (Inequality Constraints):** The SoC must not exceed the capacity $E$. For $t \\in \\{0, \\dots, T-1\\}$:\n    $$s_t - E \\le 0$$\n\n3.  **Variable Bounds:**\n    -   Non-negative capacity: $E \\ge 0$.\n    -   Non-negative SoC: $s_t \\ge 0$ for $t \\in \\{0, \\dots, T-1\\}$.\n    -   Charging power limits: $0 \\le u_t^c \\le U_t^c$ for $t \\in \\{0, \\dots, T-1\\}$.\n\nThis formulation constitutes a standard LP problem that can be solved using numerical algorithms, such as the simplex method or interior-point methods, which are implemented in libraries like `scipy.optimize`.\n\n**C. Algorithm Outline**\n\nFor each test case:\n1.  Pre-calculate the fixed hourly parameters based on the input load profile $\\{L_t\\}$ and peak cap $P^{\\mathrm{cap}}$:\n    -   Mandatory discharge power: $u_t^d = \\max(0, L_t - P^{\\mathrm{cap}})$.\n    -   Maximum charge power: $U_t^c = \\max(0, P^{\\mathrm{cap}} - L_t)$.\n2.  Verify the energy balance feasibility condition: If $\\sum_{t=0}^{T-1} \\frac{u_t^d}{\\eta_d} > \\sum_{t=0}^{T-1} \\eta_c U_t^c$, the problem is infeasible. Report $-1.000$.\n3.  If feasible, construct the components of the LP: the objective function vector, the matrices for equality and inequality constraints, and the bounds for each variable.\n4.  Solve the LP using a standard solver. The solution will provide the optimal values for all variables, including the minimum capacity $E$.\n5.  Return the obtained minimum capacity $E$, rounded to three decimal places.\n\nThis procedure correctly models the physical system and guarantees finding the minimum possible storage capacity under the given constraints.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General happy path\n        {\n            \"L_t\": np.array([48, 52, 55, 60, 62, 58, 54, 49, 45, 43, 46, 50, 53, 57, 65, 63, 59, 56, 52, 48, 44, 42, 47, 51]),\n            \"P_cap\": 50.0,\n            \"eta_c\": 0.92,\n            \"eta_d\": 0.90,\n        },\n        # Case 2: Boundary energy-balance feasibility\n        {\n            \"L_t\": np.concatenate([np.full(12, 38.8888888889), np.full(12, 59.0)]),\n            \"P_cap\": 50.0,\n            \"eta_c\": 0.90,\n            \"eta_d\": 0.90,\n        },\n        # Case 3: Infeasible due to insufficient valley energy\n        {\n            \"L_t\": np.concatenate([np.full(12, 42.0), np.full(12, 60.0)]),\n            \"P_cap\": 50.0,\n            \"eta_c\": 0.90,\n            \"eta_d\": 0.90,\n        },\n        # Case 4: No peaks above the cap, zero capacity\n        {\n            \"L_t\": np.array([45, 46, 47, 48, 49, 50, 49, 48, 47, 46, 45, 44, 45, 46, 47, 48, 49, 50, 49, 48, 47, 46, 45, 44]),\n            \"P_cap\": 50.0,\n            \"eta_c\": 0.95,\n            \"eta_d\": 0.95,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_min_capacity(case[\"L_t\"], case[\"P_cap\"], case[\"eta_c\"], case[\"eta_d\"])\n        results.append(f\"{result:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_min_capacity(L_t, P_cap, eta_c, eta_d):\n    \"\"\"\n    Calculates the minimum storage capacity for a given load profile and parameters.\n\n    Args:\n        L_t (np.array): Chronological net load series (MW).\n        P_cap (float): Target peak cap (MW).\n        eta_c (float): Storage charge efficiency.\n        eta_d (float): Storage discharge efficiency.\n\n    Returns:\n        float: The minimum required storage capacity (MWh), or -1.0 if infeasible.\n    \"\"\"\n    T = 24\n    \n    # Calculate hourly required discharge and max possible charge power\n    u_d = np.maximum(0, L_t - P_cap)\n    U_c = np.maximum(0, P_cap - L_t)\n    \n    # Calculate energy drawn from storage for discharge\n    d_t = u_d / eta_d\n    \n    # Check overall energy balance feasibility\n    total_discharge_needed = np.sum(d_t)\n    total_charge_available = np.sum(eta_c * U_c)\n    \n    # Use a small tolerance for floating point comparison, though not strictly needed for given cases\n    if total_discharge_needed > total_charge_available + 1e-9:\n        return -1.0\n\n    # If no discharge is ever needed, capacity is zero\n    if total_discharge_needed  1e-9:\n        return 0.0\n\n    # Formulate and solve the Linear Program\n    # Variable vector x: [E, s_0, ..., s_23, u_c_0, ..., u_c_23]\n    # Total variables: 1 (E) + T (s_t) + T (u_c_t) = 1 + 24 + 24 = 49\n    num_vars = 1 + 2 * T\n\n    # Objective function: minimize E\n    c = np.zeros(num_vars)\n    c[0] = 1.0\n\n    # Equality constraints (A_eq * x = b_eq): SoC dynamics\n    A_eq = np.zeros((T, num_vars))\n    b_eq = -d_t\n    \n    for t in range(T - 1):\n        # s_{t+1} - s_t - eta_c * u_c_t = -d_t\n        A_eq[t, 1 + (t + 1)] = 1.0  # s_{t+1}\n        A_eq[t, 1 + t] = -1.0       # -s_t\n        A_eq[t, 1 + T + t] = -eta_c # -eta_c * u_c_t\n    \n    # Cyclic constraint: s_0 - s_{T-1} - eta_c * u_c_{T-1} = -d_{T-1}\n    A_eq[T - 1, 1] = 1.0            # s_0\n    A_eq[T - 1, 1 + (T - 1)] = -1.0 # -s_{T-1}\n    A_eq[T - 1, 1 + T + (T-1)] = -eta_c # -eta_c * u_c_{T-1}\n\n    # Inequality constraints (A_ub * x = b_ub): SoC = E\n    # s_t - E = 0\n    A_ub = np.zeros((T, num_vars))\n    b_ub = np.zeros(T)\n    \n    for t in range(T):\n        A_ub[t, 1 + t] = 1.0 # s_t\n        A_ub[t, 0] = -1.0    # -E\n\n    # Bounds for variables\n    bounds = []\n    # E >= 0\n    bounds.append((0, None))\n    # s_t >= 0\n    for _ in range(T):\n        bounds.append((0, None))\n    # 0 = u_c_t = U_c_t\n    for t in range(T):\n        bounds.append((0, U_c[t]))\n\n    # Solve the LP\n    res = linprog(c, A_eq=A_eq, b_eq=b_eq, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    if res.success:\n        min_E = res.x[0]\n        return min_E\n    else:\n        # Should not be reached if initial feasibility check is correct, but as a fallback\n        return -1.0\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "While the previous exercise focused on using storage to meet physical constraints, the same chronological modeling framework is essential for economic optimization. In this final practice, you will shift your perspective from a system operator to a prosumer aiming to minimize their electricity bill. Your task is to develop an optimal charge-discharge schedule for a residential battery based on a fluctuating real-time price signal, a classic example of economic arbitrage made possible by tracking state and opportunities over time.",
            "id": "4129559",
            "problem": "A discrete-time household energy system is modeled over a finite horizon with chronology preserved by state evolution constraints. The household has an exogenous electric load and can buy from or sell to the grid at a real-time price. A battery with charge and discharge inefficiencies can be operated to minimize total bill cost subject to physical limits and state-of-charge constraints. The goal is to compute the bill savings and the modified net grid exchange profile when optimally operating the battery.\n\nFundamental base. Energy conservation in discrete time and physically consistent bounds apply. For time steps indexed by $t \\in \\{0,1,\\dots,T-1\\}$ with uniform duration $\\Delta t$, let $L_t$ denote the household load (in $\\mathrm{kW}$), let $p_t$ denote the real-time price (in dollars per kilowatt-hour, denoted $\\$$ per $\\mathrm{kWh}$), and let the battery be characterized by charge efficiency $\\eta_c \\in (0,1]$, discharge efficiency $\\eta_d \\in (0,1]$, energy capacity $E_{\\max}$ (in $\\mathrm{kWh}$), maximum charge power $P_c^{\\max}$ (in $\\mathrm{kW}$), maximum discharge power $P_d^{\\max}$ (in $\\mathrm{kW}$), and initial state-of-charge $s_0$ (in $\\mathrm{kWh}$). The household may import power $g_t \\ge 0$ (in $\\mathrm{kW}$) and export power $x_t \\ge 0$ (in $\\mathrm{kW}$). Define the battery charge power $c_t \\ge 0$ (in $\\mathrm{kW}$) and discharge power $d_t \\ge 0$ (in $\\mathrm{kW}$). The battery state-of-charge at the end of period $t$ is $s_{t+1}$ (in $\\mathrm{kWh}$). Chronology is enforced via an inter-temporal state evolution.\n\nCore definitions and constraints. The nodal (power) balance in each time step requires\n$$\ng_t + d_t = L_t + c_t + x_t,\n$$\nensuring that import plus battery discharge meets the sum of load plus battery charge plus export. The battery state of charge evolves following conservation of energy and efficiency losses:\n$$\ns_{t+1} = s_t + \\eta_c \\, c_t \\, \\Delta t - \\frac{1}{\\eta_d} \\, d_t \\, \\Delta t,\n$$\nfor all $t \\in \\{0,1,\\dots,T-1\\}$. Physical bounds are\n$$\n0 \\le s_t \\le E_{\\max}, \\quad 0 \\le c_t \\le P_c^{\\max}, \\quad 0 \\le d_t \\le P_d^{\\max}, \\quad g_t \\ge 0, \\quad x_t \\ge 0.\n$$\nImpose a cycle-closure constraint to avoid end effects:\n$$\ns_T = s_0.\n$$\n\nObjective. The baseline bill cost without a battery is\n$$\nC_{\\mathrm{base}} = \\sum_{t=0}^{T-1} p_t \\, L_t \\, \\Delta t.\n$$\nThe optimized bill cost with battery control and net metering at real-time prices is\n$$\nC_{\\mathrm{opt}} = \\sum_{t=0}^{T-1} p_t \\, (g_t - x_t) \\, \\Delta t,\n$$\nbecause imports incur cost and exports yield revenue. The bill savings are\n$$\n\\mathrm{Savings} = C_{\\mathrm{base}} - C_{\\mathrm{opt}}.\n$$\nThe modified net grid exchange profile (in $\\mathrm{kW}$) is the list $\\{g_t - x_t\\}_{t=0}^{T-1}$.\n\nTask. Implement a program that, given $(L_t)$, $(p_t)$, $\\Delta t$, $\\eta_c$, $\\eta_d$, $E_{\\max}$, $P_c^{\\max}$, $P_d^{\\max}$, and $s_0$, constructs and solves the linear program defined by the objective and constraints above to find the optimal $(g_t, x_t, c_t, d_t, s_t)$ and computes the bill savings and the modified net grid exchange profile. Use dollars ($\\$$) for all monetary outputs (as unitless numeric floats), $\\mathrm{kW}$ for power values, $\\mathrm{kWh}$ for energy and state-of-charge values, and hours for time. Express all monetary answers as floats in dollars, and all profiles as lists of floats in $\\mathrm{kW}$. Angles are not used.\n\nTest suite. Your program must solve the following test cases:\n\n- Case A (happy path, variable prices and moderate battery):\n  - Time steps: $T = 6$, $\\Delta t = 1$ hour.\n  - Prices (in $\\$/\\mathrm{kWh}$): $[0.2, 0.15, 0.1, 0.3, 0.25, 0.18]$.\n  - Load (in $\\mathrm{kW}$): $[1.2, 1.0, 0.8, 1.5, 1.3, 1.0]$.\n  - Battery parameters: $\\eta_c = 0.95$, $\\eta_d = 0.9$, $E_{\\max} = 2.0$ $\\mathrm{kWh}$, $P_c^{\\max} = 1.0$ $\\mathrm{kW}$, $P_d^{\\max} = 1.0$ $\\mathrm{kW}$, $s_0 = 1.0$ $\\mathrm{kWh}$.\n\n- Case B (boundary, zero capacity battery, no savings expected):\n  - Time steps: $T = 4$, $\\Delta t = 1$ hour.\n  - Prices (in $\\$/\\mathrm{kWh}$): $[0.1, 0.2, 0.3, 0.4]$.\n  - Load (in $\\mathrm{kW}$): $[1.0, 1.0, 1.0, 1.0]$.\n  - Battery parameters: $\\eta_c = 0.95$, $\\eta_d = 0.9$, $E_{\\max} = 0.0$ $\\mathrm{kWh}$, $P_c^{\\max} = 1.0$ $\\mathrm{kW}$, $P_d^{\\max} = 1.0$ $\\mathrm{kW}$, $s_0 = 0.0$ $\\mathrm{kWh}$.\n\n- Case C (edge, perfect efficiency with small capacity and large power limits, arbitrage across low/high prices):\n  - Time steps: $T = 5$, $\\Delta t = 1$ hour.\n  - Prices (in $\\$/\\mathrm{kWh}$): $[0.3, 0.05, 0.05, 0.5, 0.5]$.\n  - Load (in $\\mathrm{kW}$): $[0.5, 0.5, 0.5, 0.5, 0.5]$.\n  - Battery parameters: $\\eta_c = 1.0$, $\\eta_d = 1.0$, $E_{\\max} = 1.0$ $\\mathrm{kWh}$, $P_c^{\\max} = 2.0$ $\\mathrm{kW}$, $P_d^{\\max} = 2.0$ $\\mathrm{kW}$, $s_0 = 0.0$ $\\mathrm{kWh}$.\n\n- Case D (edge, initially full battery, very high last-hour price, cycle closure enforced):\n  - Time steps: $T = 6$, $\\Delta t = 1$ hour.\n  - Prices (in $\\$/\\mathrm{kWh}$): $[0.12, 0.12, 0.12, 0.12, 0.12, 0.6]$.\n  - Load (in $\\mathrm{kW}$): $[0.8, 0.8, 0.8, 0.8, 0.8, 0.8]$.\n  - Battery parameters: $\\eta_c = 0.9$, $\\eta_d = 0.9$, $E_{\\max} = 3.0$ $\\mathrm{kWh}$, $P_c^{\\max} = 0.5$ $\\mathrm{kW}$, $P_d^{\\max} = 1.0$ $\\mathrm{kW}$, $s_0 = 3.0$ $\\mathrm{kWh}$.\n\nAnswer specification. For each test case, your program must produce a pair consisting of the bill savings (as a float in dollars) and the modified net grid exchange profile (as a list of floats in $\\mathrm{kW}$). Aggregate the results for all test cases into a single line of output containing a list of these pairs, in the exact format:\n\"[ [savings_case_A, [net_profile_case_A]], [savings_case_B, [net_profile_case_B]], [savings_case_C, [net_profile_case_C]], [savings_case_D, [net_profile_case_D]] ]\"\nFor example, the enclosing brackets and comma-separated values must match this structure. The program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets as demonstrated.",
            "solution": "The user wants to solve a household energy cost minimization problem by optimally scheduling a battery energy storage system. The problem is formulated as a linear program (LP).\n\n### Step 1: Extract Givens\n\n- **Indices**: Time steps $t \\in \\{0, 1, \\dots, T-1\\}$.\n- **Parameters**:\n    - Time step duration: $\\Delta t$ ($\\mathrm{h}$)\n    - Household load profile: $L_t$ ($\\mathrm{kW}$)\n    - Real-time price profile: $p_t$ ($\\$/\\mathrm{kWh}$)\n    - Battery charge efficiency: $\\eta_c \\in (0, 1]$\n    - Battery discharge efficiency: $\\eta_d \\in (0, 1]$\n    - Battery energy capacity: $E_{\\max}$ ($\\mathrm{kWh}$)\n    - Maximum charge power: $P_c^{\\max}$ ($\\mathrm{kW}$)\n    - Maximum discharge power: $P_d^{\\max}$ ($\\mathrm{kW}$)\n    - Initial state-of-charge: $s_0$ ($\\mathrm{kWh}$)\n- **Decision Variables**:\n    - Grid import power: $g_t \\ge 0$ ($\\mathrm{kW}$)\n    - Grid export power: $x_t \\ge 0$ ($\\mathrm{kW}$)\n    - Battery charge power: $c_t \\ge 0$ ($\\mathrm{kW}$)\n    - Battery discharge power: $d_t \\ge 0$ ($\\mathrm{kW}$)\n    - Battery state-of-charge: $s_t$ ($\\mathrm{kWh}$)\n- **Constraints**:\n    1.  **Power Balance**: $g_t + d_t = L_t + c_t + x_t$ for $t \\in \\{0, \\dots, T-1\\}$.\n    2.  **State Evolution**: $s_{t+1} = s_t + \\eta_c \\, c_t \\, \\Delta t - \\frac{1}{\\eta_d} \\, d_t \\, \\Delta t$ for $t \\in \\{0, \\dots, T-1\\}$.\n    3.  **Physical Bounds**:\n        - $0 \\le s_t \\le E_{\\max}$ for $t \\in \\{0, \\dots, T\\}$.\n        - $0 \\le c_t \\le P_c^{\\max}$ for $t \\in \\{0, \\dots, T-1\\}$.\n        - $0 \\le d_t \\le P_d^{\\max}$ for $t \\in \\{0, \\dots, T-1\\}$.\n    4.  **Cycle Closure**: $s_T = s_0$.\n- **Objective Function**: Minimize the total bill cost $C_{\\mathrm{opt}} = \\sum_{t=0}^{T-1} p_t \\, (g_t - x_t) \\, \\Delta t$.\n- **Outputs**:\n    1.  Bill Savings: $\\mathrm{Savings} = C_{\\mathrm{base}} - C_{\\mathrm{opt}}$, where $C_{\\mathrm{base}} = \\sum_{t=0}^{T-1} p_t \\, L_t \\, \\Delta t$.\n    2.  Modified Net Grid Exchange Profile: $\\{g_t - x_t\\}_{t=0}^{T-1}$.\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientifically Grounded (Critical)**: The problem is a standard representation of a battery energy storage dispatch problem. The power balance equation represents nodal analysis at the household's electrical connection point. The state-of-charge evolution equation correctly models energy conservation, accounting for coulombic efficiencies during charging and discharging. The model is a well-established and scientifically sound simplification used in energy systems modeling.\n-   **Well-Posed**: The problem is formulated as a linear program. The objective function is linear in the decision variables $g_t$ and $x_t$. All constraints are linear inequalities or equalities. The feasible region is a convex polyhedron. A feasible solution always exists (e.g., the baseline case where $c_t = 0$ and $d_t = 0$ for all $t$). Therefore, an optimal solution is guaranteed to exist. The problem is well-posed.\n-   **Objective (Critical)**: The problem is stated using precise and unambiguous technical language from optimization and energy systems engineering. It is free from subjective claims.\n-   **No Other Flaws**: The problem is self-contained, with all necessary data and constraints provided. It is not contradictory; the constraints define a non-empty feasible set. The parameters in the test cases are physically realistic. The problem is a non-trivial application of linear programming, requiring substantive setup and computation.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. A solution will be provided by formulating and solving the described linear program.\n\n### Solution Strategy: Linear Program Formulation\n\nThe problem can be solved by formulating it as a standard LP of the form $\\min_{\\mathbf{v}} \\mathbf{c}^T \\mathbf{v}$ subject to $\\mathbf{A}_{eq} \\mathbf{v} = \\mathbf{b}_{eq}$ and bounds on $\\mathbf{v}$.\n\n1.  **Objective Function Reformulation**:\n    From the power balance constraint, the net grid exchange is $g_t - x_t = L_t + c_t - d_t$. Substituting this into the objective function:\n    $$C_{\\mathrm{opt}} = \\sum_{t=0}^{T-1} p_t (L_t + c_t - d_t) \\Delta t = \\sum_{t=0}^{T-1} p_t L_t \\Delta t + \\sum_{t=0}^{T-1} p_t (c_t - d_t) \\Delta t$$\n    Since $C_{\\mathrm{base}} = \\sum p_t L_t \\Delta t$ is a constant, minimizing $C_{\\mathrm{opt}}$ is equivalent to minimizing the operational cost:\n    $$\\min_{c_t, d_t} \\sum_{t=0}^{T-1} (p_t \\Delta t) c_t - (p_t \\Delta t) d_t$$\n    The variables $g_t$ and $x_t$ are not needed as primary decision variables in the LP, as their values can be determined post-optimization from $L_t, c_t, d_t$. The non-negativity constraints on $g_t$ and $x_t$ are implicitly satisfied.\n\n2.  **Decision Variable Vector**:\n    We define the decision variable vector $\\mathbf{v}$ by concatenating the time series of battery charge powers, discharge powers, and state-of-charge values.\n    $$\\mathbf{v} = [c_0, ..., c_{T-1}, d_0, ..., d_{T-1}, s_1, ..., s_T]^T$$\n    This is a vector of length $3T$. Note that $s_0$ is a given parameter, not a variable.\n\n3.  **Cost Vector ($\\mathbf{c}$)**:\n    Based on the reformulated objective, the cost vector $\\mathbf{c}$ of length $3T$ is:\n    - For variables $c_t$ (indices $0$ to $T-1$): coefficients are $p_t \\Delta t$.\n    - For variables $d_t$ (indices $T$ to $2T-1$): coefficients are $-p_t \\Delta t$.\n    - For variables $s_t$ (indices $2T$ to $3T-1$): coefficients are $0$.\n\n4.  **Equality Constraints ($\\mathbf{A}_{eq}, \\mathbf{b}_{eq}$)**:\n    There are $T+1$ equality constraints.\n    - **State Evolution ($T$ constraints)**: For each $t \\in \\{0, \\dots, T-1\\}$, the equation $s_{t+1} = s_t + \\eta_c c_t \\Delta t - \\frac{1}{\\eta_d} d_t \\Delta t$ is rearranged to $s_{t+1} - s_t - \\eta_c c_t \\Delta t + \\frac{1}{\\eta_d} d_t \\Delta t = 0$. For $t=0$, $s_0$ is a known constant and is moved to the right-hand side.\n    - **Cycle Closure (1 constraint)**: $s_T = s_0$.\n    These equations are encoded into an $(T+1) \\times 3T$ matrix $\\mathbf{A}_{eq}$ and a vector $\\mathbf{b}_{eq}$ of length $T+1$.\n\n5.  **Bounds**:\n    The variables are subject to lower and upper bounds:\n    - $0 \\le c_t \\le P_c^{\\max}$\n    - $0 \\le d_t \\le P_d^{\\max}$\n    - $0 \\le s_t \\le E_{\\max}$ (for $t \\in \\{1, \\dots, T\\}$)\n\n6.  **Solving and Post-processing**:\n    The `scipy.optimize.linprog` function is used to solve this LP.\n    - After finding the optimal values `result.x`, we extract the optimal charge and discharge profiles, $c_t^*$ and $d_t^*$.\n    - The savings are calculated as the negative of the optimal objective function value, `result.fun`.\n    - The modified net grid exchange profile is calculated as $\\{ L_t + c_t^* - d_t^* \\}_{t=0}^{T-1}$.\n\nThis systematic approach will be implemented for each test case.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of battery dispatch optimization problems and formats the output.\n    \"\"\"\n    test_cases = [\n        {\n            # Case A: happy path, variable prices and moderate battery\n            'T': 6, 'delta_t': 1.0,\n            'p': np.array([0.2, 0.15, 0.1, 0.3, 0.25, 0.18]),\n            'L': np.array([1.2, 1.0, 0.8, 1.5, 1.3, 1.0]),\n            'eta_c': 0.95, 'eta_d': 0.9, 'E_max': 2.0,\n            'P_c_max': 1.0, 'P_d_max': 1.0, 's0': 1.0,\n        },\n        {\n            # Case B: boundary, zero capacity battery, no savings expected\n            'T': 4, 'delta_t': 1.0,\n            'p': np.array([0.1, 0.2, 0.3, 0.4]),\n            'L': np.array([1.0, 1.0, 1.0, 1.0]),\n            'eta_c': 0.95, 'eta_d': 0.9, 'E_max': 0.0,\n            'P_c_max': 1.0, 'P_d_max': 1.0, 's0': 0.0,\n        },\n        {\n            # Case C: edge, perfect efficiency with small capacity and large power limits\n            'T': 5, 'delta_t': 1.0,\n            'p': np.array([0.3, 0.05, 0.05, 0.5, 0.5]),\n            'L': np.array([0.5, 0.5, 0.5, 0.5, 0.5]),\n            'eta_c': 1.0, 'eta_d': 1.0, 'E_max': 1.0,\n            'P_c_max': 2.0, 'P_d_max': 2.0, 's0': 0.0,\n        },\n        {\n            # Case D: edge, initially full battery, very high last-hour price\n            'T': 6, 'delta_t': 1.0,\n            'p': np.array([0.12, 0.12, 0.12, 0.12, 0.12, 0.6]),\n            'L': np.array([0.8, 0.8, 0.8, 0.8, 0.8, 0.8]),\n            'eta_c': 0.9, 'eta_d': 0.9, 'E_max': 3.0,\n            'P_c_max': 0.5, 'P_d_max': 1.0, 's0': 3.0,\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        T, delta_t = case['T'], case['delta_t']\n        p, L = case['p'], case['L']\n        eta_c, eta_d = case['eta_c'], case['eta_d']\n        E_max, P_c_max, P_d_max, s0 = case['E_max'], case['P_c_max'], case['P_d_max'], case['s0']\n\n        # Decision variables: v = [c_0,...,c_{T-1}, d_0,...,d_{T-1}, s_1,...,s_T]\n        # Total number of variables is 3*T\n        num_vars = 3 * T\n\n        # Cost vector c\n        cost_c = p * delta_t\n        cost_d = -p * delta_t\n        cost_s = np.zeros(T)\n        c_vec = np.concatenate([cost_c, cost_d, cost_s])\n\n        # Equality constraints: A_eq @ v = b_eq\n        # State evolution (T constraints) + cycle closure (1 constraint)\n        A_eq = np.zeros((T + 1, num_vars))\n        b_eq = np.zeros(T + 1)\n\n        # State evolution constraints: s_{t+1} - s_t - eta_c*c_t*dt + (1/eta_d)*d_t*dt = 0\n        for t in range(T):\n            # coeff for c_t\n            A_eq[t, t] = -eta_c * delta_t\n            # coeff for d_t\n            A_eq[t, T + t] = delta_t / eta_d\n            # coeff for s_{t+1}\n            A_eq[t, 2 * T + t] = 1\n            if t > 0:\n                # coeff for s_t\n                A_eq[t, 2 * T + t - 1] = -1\n            \n            if t == 0:\n                b_eq[t] = s0\n\n        # Cycle closure constraint: s_T = s_0\n        A_eq[T, 3 * T - 1] = 1\n        b_eq[T] = s0\n\n        # Bounds on variables\n        bounds = []\n        # Bounds for c_t\n        bounds.extend([(0, P_c_max)] * T)\n        # Bounds for d_t\n        bounds.extend([(0, P_d_max)] * T)\n        # Bounds for s_t\n        bounds.extend([(0, E_max)] * T)\n        \n        # Solve the linear program\n        res = linprog(c=c_vec, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if not res.success:\n            raise RuntimeError(f\"LP solver failed for case with T={T}.\")\n        \n        # Extract results\n        c_opt = res.x[0:T]\n        d_opt = res.x[T:2*T]\n        \n        # Calculate savings and net profile\n        savings = -res.fun\n        net_profile = L + c_opt - d_opt\n\n        # To handle potential floating point dust near zero\n        savings = np.round(savings, 8)\n        net_profile = np.round(net_profile, 8).tolist()\n\n        all_results.append((savings, net_profile))\n\n    # Format the final output string exactly as specified in the problem\n    output_parts = []\n    for sav, prof in all_results:\n        # Manually format profile list to get spaces after commas\n        prof_str = '[' + ', '.join(map(str, prof)) + ']'\n        # Format the pair\n        output_parts.append(f\"[{sav}, {prof_str}]\")\n\n    final_output = '[' + ', '.join(output_parts) + ']'\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}