{
    "hands_on_practices": [
        {
            "introduction": "技术成本的动态变化是能源系统建模的核心。本练习将带你实践一种关键的自下而上建模技术——经验曲线，它通过幂律关系来量化技术成本如何随累积产量的增加而下降。通过对历史数据进行对数线性回归，你不仅将校准出学习率等关键参数，还将学会如何为来自不同建模范式（如自上而下的宏观经济预测、优化模型和模拟路径）的情景预测未来成本并量化其不确定性。",
            "id": "4105975",
            "problem": "考虑一种能源技术，其单位成本通过基于经验规律的幂律经验曲线依赖于累积部署量。假设以下基础模型：对于以吉瓦（GW）为单位的累积部署量 $Q$ 和以美元/千瓦（$/kW$）为单位的单位成本 $C(Q)$，成本遵循 $C(Q) = C_0 Q^{-\\beta}$，其中 $C_0 > 0$ 为常数，$\\beta > 0$ 为学习指数。假设对数采用自然底数，并且对数残差是独立同分布的高斯随机变量，则该模型可以表示为 $\\ln C = \\alpha - \\beta \\ln Q + \\varepsilon$，其中 $\\alpha = \\ln C_0$ 且 $\\varepsilon \\sim \\mathcal{N}(0,\\sigma^2)$。\n\n您将获得以有序对 ($Q_t$, $C_t$) 形式提供的历史上观测到的自下而上数据，其中 $Q_t$ 以吉瓦（GW）为单位，$C_t$ 以美元/千瓦（$/kW$）为单位：\n$(5,2200)$、$(10,2000)$、$(20,1800)$、$(35,1600)$、$(55,1400)$、$(80,1250)$、$(105,1150)$、$(130,1075)$。\n\n您的任务是：\n- 在所述高斯误差假设下，通过对数线性回归校准学习指数 $\\beta$ 和截距 $\\alpha$。\n- 使用校准后的模型和基于统计学原理的不确定性量化方法，为源自不同建模范式的三种累积部署情景生成未来成本的预测分布：\n    1. 自上而下的宏观经济预测，$Q_{\\mathrm{TD}} = 200$ GW。\n    2. 自下而上的优化计划输出，$Q_{\\mathrm{OPT}} = 130$ GW。\n    3. 基于模拟的采纳轨迹，$Q_{\\mathrm{SIM}} = 600$ GW。\n- 对于每个情景 $Q_\\star \\in \\{Q_{\\mathrm{TD}}, Q_{\\mathrm{OPT}}, Q_{\\mathrm{SIM}}\\}$，在原始成本尺度上以美元/千瓦（$/kW$）为单位，输出预测的中位数单位成本和一个双侧 $(1-\\alpha)$ 预测区间，其中 $\\alpha = 0.05$。假设预测区间是在对数空间中为新观测值（不仅仅是平均响应）计算的，然后映射回原始成本空间。\n\n将三个情景的结果表示为包含三个浮点数的列表 $[m_\\star, \\ell_\\star, u_\\star]$，其中 $m_\\star$ 是预测的中位数成本，$\\ell_\\star$ 是双侧 $(1-\\alpha)$ 预测区间的下限， $u_\\star$ 是上限，所有单位均为美元/千瓦（$/kW$）。最终程序输出应为单行，包含这三个列表的逗号分隔列表，并用方括号括起来，无空格，格式完全如下：\n`[[m_{\\mathrm{TD}},\\ell_{\\mathrm{TD}},u_{\\mathrm{TD}}],[m_{\\mathrm{OPT}},\\ell_{\\mathrm{OPT}},u_{\\mathrm{OPT}}],[m_{\\mathrm{SIM}},\\ell_{\\mathrm{SIM}},u_{\\mathrm{SIM}}]]`.\n\n测试套件和覆盖要求：\n- 使用指定的历史数据集和三个情景的累积部署量 $Q_{\\mathrm{TD}} = 200$ GW、$Q_{\\mathrm{OPT}} = 130$ GW 和 $Q_{\\mathrm{SIM}} = 600$ GW。\n- 这些情景共同测试了一个一般情况（$Q_{\\mathrm{TD}}$）、一个在最新观测部署量上的边界情况（$Q_{\\mathrm{OPT}}$）以及一个远距离外推的边缘情况（$Q_{\\mathrm{SIM}}$）。\n- 您的程序必须按照规定，生成包含三个浮点数列表（每个列表对应一个情景）的单行输出，单位为美元/千瓦（$/kW$）。",
            "solution": "该问题是有效的，因为它在科学上基于成熟的技术经验曲线理论，在数学上是适定的且有足够的数据，并且其表述是客观的。它需要对数线性回归和统计预测进行标准而严谨的应用。我现在将开始解答。\n\n该问题要求我们对某能源技术的累积部署量 $Q$ 与单位成本 $C$ 之间的关系进行建模。提出的模型是一个幂律：\n$$C(Q) = C_0 Q^{-\\beta}$$\n其中 $C_0$ 是初始成本，$\\beta$ 是学习指数。\n\n为了从提供的数据中估计参数 $C_0$ 和 $\\beta$，我们通过对两边取自然对数来线性化模型：\n$$\\ln(C) = \\ln(C_0 Q^{-\\beta}) = \\ln(C_0) + \\ln(Q^{-\\beta}) = \\ln(C_0) - \\beta \\ln(Q)$$\n问题陈述以 $\\ln C = \\alpha - \\beta \\ln Q + \\varepsilon$ 的形式给出，其中 $\\alpha = \\ln C_0$，$\\varepsilon$ 是一个均值为 $0$、方差为 $\\sigma^2$ 的正态分布误差项，即 $\\varepsilon \\sim \\mathcal{N}(0, \\sigma^2)$。\n\n通过设置以下变量，该方程可变为简单线性回归模型的形式 $y = \\beta_0 + \\beta_1 x + \\varepsilon$：\n$y = \\ln C$\n$x = \\ln Q$\n$\\beta_0 = \\alpha$\n$\\beta_1 = -\\beta$\n\n我们的第一步是将给定的历史数据 $(Q_t, C_t)$ 转换为对数坐标 $(x_t, y_t) = (\\ln Q_t, \\ln C_t)$，然后执行普通最小二乘法（OLS）回归，以找到最佳拟合估计值 $\\hat{\\beta}_0$ 和 $\\hat{\\beta}_1$。由此，我们可以找到原始模型参数的估计值：$\\hat{\\alpha} = \\hat{\\beta}_0$ 和 $\\hat{\\beta} = -\\hat{\\beta}_1$。\n\n提供的历史数据包含 $n=8$ 对：\n$Q = [5, 10, 20, 35, 55, 80, 105, 130]$ GW\n$C = [2200, 2000, 1800, 1600, 1400, 1250, 1150, 1075]$ $/kW\n\n第二步是使用校准后的模型对三个未来的部署情景进行预测：$Q_\\star \\in \\{200, 130, 600\\}$ GW。对于每个 $Q_\\star$，我们必须计算：\n1.  预测的中位数成本 $m_\\star$。\n2.  一个双侧 $95\\%$ 预测区间 $[\\ell_\\star, u_\\star]$。\n\n预测首先在对数空间中进行。对于一个新的部署量 $Q_\\star$，我们计算其对数 $x_\\star = \\ln Q_\\star$。对数成本的预测值为：\n$$\\hat{y}_\\star = \\hat{\\beta}_0 + \\hat{\\beta}_1 x_\\star$$\n由于误差 $\\varepsilon$ 是正态分布的，对数成本 $y = \\ln C$ 也服从正态分布。这意味着成本 $C = \\exp(y)$ 服从对数正态分布。此对数正态分布的中位数是 $\\exp(\\mathbb{E}[y])$。我们在 $x_\\star$ 处对 $\\mathbb{E}[y]$ 的最佳估计是 $\\hat{y}_\\star$。因此，预测的中位数成本是：\n$$m_\\star = \\exp(\\hat{y}_\\star)$$\n\n为了计算预测区间，我们必须考虑模型参数的不确定性和新观测值的内在变异性。在点 $x_\\star$ 处，一个新观测值 $y_{new}$ 的 $(1-\\alpha_{CI})$ 预测区间由下式给出：\n$$\\hat{y}_\\star \\pm t_{n-2, \\alpha_{CI}/2} \\cdot s_e \\sqrt{1 + \\frac{1}{n} + \\frac{(x_\\star - \\bar{x})^2}{\\sum_{i=1}^n (x_i - \\bar{x})^2}}$$\n其中：\n-   $n=8$ 是数据点的数量。\n-   $t_{n-2, \\alpha_{CI}/2}$ 是自由度为 $n-2=6$ 的t分布的临界值。对于 $95\\%$ 的区间，$\\alpha_{CI}=0.05$，所以我们需要 $1 - 0.05/2 = 0.975$ 百分位数处的值。\n-   $s_e$ 是回归的标准误（也称为残差标准误），计算公式为 $s_e = \\sqrt{\\frac{\\sum(y_i - \\hat{y}_i)^2}{n-2}}$。\n-   $\\bar{x}$ 是观测到的对数部署量 $x_i$ 的均值。\n-   $\\sum(x_i - \\bar{x})^2$ 是观测到的 $x_i$ 的离差平方和。\n\n令误差范围（上述公式中的第二项）表示为 $ME$。在对数空间中的预测区间是 $[\\hat{y}_\\star - ME, \\hat{y}_\\star + ME]$。\n为了获得原始成本尺度上的区间，我们对边界进行指数运算：\n$$\\ell_\\star = \\exp(\\hat{y}_\\star - ME)$$\n$$u_\\star = \\exp(\\hat{y}_\\star + ME)$$\n\n将对 $Q_{\\mathrm{TD}} = 200$、$Q_{\\mathrm{OPT}} = 130$ 和 $Q_{\\mathrm{SIM}} = 600$ 这三个情景中的每一个进行这些计算，并按要求格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress, t\n\ndef solve():\n    \"\"\"\n    Calibrates a power-law experience curve model using log-linear regression\n    and computes prediction intervals for future costs based on three deployment scenarios.\n    \"\"\"\n    # Step 1: Define historical data and scenario parameters\n    # Historical data: (Cumulative Deployment in GW, Unit Cost in $/kW)\n    data = np.array([\n        (5, 2200),\n        (10, 2000),\n        (20, 1800),\n        (35, 1600),\n        (55, 1400),\n        (80, 1250),\n        (105, 1150),\n        (130, 1075)\n    ])\n    \n    # Scenarios for prediction (Cumulative Deployment in GW)\n    q_scenarios = [200.0, 130.0, 600.0]  # TD, OPT, SIM\n\n    # Model: C = C_0 * Q^-beta\n    # Log-linear form: ln(C) = ln(C_0) - beta * ln(Q) => y = beta_0 + beta_1 * x\n    # where y = ln(C), x = ln(Q), beta_0 = ln(C_0), beta_1 = -beta\n\n    q_obs = data[:, 0]\n    c_obs = data[:, 1]\n    \n    # Transform data to log-space\n    x_obs = np.log(q_obs) # ln(Q)\n    y_obs = np.log(c_obs) # ln(C)\n    \n    # Step 2: Perform log-linear regression\n    # The `linregress` function from scipy provides all necessary OLS results.\n    # slope = beta_1, intercept = beta_0\n    slope, intercept, _, _, std_err_slope = linregress(x_obs, y_obs)\n    \n    # Step 3: Calculate parameters for prediction interval\n    n = len(x_obs)\n    df = n - 2  # Degrees of freedom for t-distribution\n    alpha_ci = 0.05 # Significance level for a 95% prediction interval\n    \n    # Critical t-value for a two-sided interval\n    t_crit = t.ppf(1 - alpha_ci / 2, df)\n    \n    # Mean and sum of squared deviations of the predictor variable\n    x_mean = np.mean(x_obs)\n    s_xx = np.sum((x_obs - x_mean)**2)\n    \n    # Standard error of the regression estimate (s_e)\n    # This can be derived from the standard error of the slope:\n    # std_err_slope = s_e / sqrt(S_xx) => s_e = std_err_slope * sqrt(S_xx)\n    s_e = std_err_slope * np.sqrt(s_xx)\n    \n    # Step 4: Calculate predictions and intervals for each scenario\n    results = []\n    for q_star in q_scenarios:\n        # Transform scenario deployment to log-space\n        x_star = np.log(q_star)\n        \n        # Predict the log-cost\n        y_hat_star = intercept + slope * x_star\n        \n        # Calculate the median cost by transforming back to original scale\n        # For a log-normal distribution, median = exp(mean of log-distribution)\n        median_cost = np.exp(y_hat_star)\n        \n        # Calculate the margin of error for the prediction interval in log-space\n        # The term under the square root accounts for uncertainty in the mean response\n        # plus the variability of a single future observation.\n        pred_err_term = np.sqrt(1 + (1 / n) + ((x_star - x_mean)**2 / s_xx))\n        margin_of_error_log = t_crit * s_e * pred_err_term\n        \n        # Determine the prediction interval bounds in log-space\n        log_lower_bound = y_hat_star - margin_of_error_log\n        log_upper_bound = y_hat_star + margin_of_error_log\n        \n        # Transform bounds back to the original cost scale\n        lower_bound = np.exp(log_lower_bound)\n        upper_bound = np.exp(log_upper_bound)\n        \n        results.append([median_cost, lower_bound, upper_bound])\n\n    # Step 5: Format the final output string\n    # E.g., [[m1,l1,u1],[m2,l2,u2],[m3,l3,u3]]\n    result_str_parts = []\n    for res in results:\n        # Format each scenario's result list\n        part = f\"[{res[0]},{res[1]},{res[2]}]\"\n        result_str_parts.append(part)\n        \n    final_output = f\"[{','.join(result_str_parts)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "自上而下的可计算一般均衡（Computable General Equilibrium, CGE）模型依赖于一个全面且一致的宏观经济数据库，即社会核算矩阵（Social Accounting Matrix, SAM）。本练习将让你亲手构建一个SAM的关键部分，通过处理来自投入产出表和国民账户的原始数据来平衡政府账户。这个过程将加深你对经济体中各部门间流量、税收和转移支付如何相互关联的理解，并揭示CGE模型赖以建立的严格会计恒等式。",
            "id": "4106006",
            "problem": "一个面向能源的社会核算矩阵（SAM）是一个方形矩阵，记录了所有账户之间的交易，使得每个账户的总流入等于总流出。在自上而下的可计算一般均衡（CGE）模型中，SAM为包含能源部门的政策情景模拟和优化提供了所需的一致均衡的宏观经济数据图景。其核心会计恒等式是：每个账户的收入总和等于支出总和，任何差额都作为储蓄或赤字记录，流入或流出资本账户。\n\n考虑一个经济体，它有五个生产活动：电力 (E)、制造业 (M)、服务业 (S)、运输业 (T) 和农业 (A)；以及四个制度账户：家庭 (H)、政府 (G)、世界其他地区 (R) 和资本 (K)。所有流量均以十亿本国货币单位报告。根据投入产出（IO）表和国民账户，给定以下数据：\n\n- 产业间交易 $T_{ij}$，其中 $i$ 是销售活动，$j$ 是购买活动：\n  - 来自 $E$：$T_{EE}=5$, $T_{EM}=10$, $T_{ES}=2$, $T_{ET}=4$, $T_{EA}=1$。\n  - 来自 $M$：$T_{ME}=3$, $T_{MM}=8$, $T_{MS}=5$, $T_{MT}=6$, $T_{MA}=4$。\n  - 来自 $S$：$T_{SE}=2$, $T_{SM}=7$, $T_{SS}=9$, $T_{ST}=5$, $T_{SA}=3$。\n  - 来自 $T$：$T_{TE}=1$, $T_{TM}=4$, $T_{TS}=3$, $T_{TT}=6$, $T_{TA}=2$。\n  - 来自 $A$：$T_{AE}=0.5$, $T_{AM}=3$, $T_{AS}=2$, $T_{AT}=1$, $T_{AA}=7$。\n- 按活动划分的家庭最终消费 $c_i$：$c_E=12$, $c_M=25$, $c_S=40$, $c_T=18$, $c_A=15$。\n- 按活动划分的政府最终消费 $g_i$（以基本价格计量，即不含产品税）：$g_E=5$, $g_M=7$, $g_S=12$, $g_T=10$, $g_A=6$。\n- 按活动划分的出口 $x_i$：$x_E=8$, $x_M=20$, $x_S=10$, $x_T=6$, $x_A=12$。\n- 按商品划分的进口 $m_i$：$m_E=5$, $m_M=18$, $m_S=12$, $m_T=9$, $m_A=7$。\n- 对总产出的从价产品税率 $\\tau^p_i$：$\\tau^p_E=0.05$, $\\tau^p_M=0.10$, $\\tau^p_S=0.08$, $\\tau^p_T=0.06$, $\\tau^p_A=0.04$。\n- 对家庭消费的从价消费税率 $\\tau^c_i$：$\\tau^c_E=0.02$, $\\tau^c_M=0.04$, $\\tau^c_S=0.03$, $\\tau^c_T=0.05$, $\\tau^c_A=0.01$。\n- 对进口的从价关税税率 $\\tau^m_i$：$\\tau^m_E=0.03$, $\\tau^m_M=0.05$, $\\tau^m_S=0.02$, $\\tau^m_T=0.04$, $\\tau^m_A=0.03$。\n- 各活动向家庭支付的工资 $w_i$：$w_E=18$, $w_M=35$, $w_S=38$, $w_T=21$, $w_A=18$。\n- 对工资收入的家庭所得税率 $\\tau^y=0.15$。\n- 政府对家庭的转移支付 $tr^{G\\to H}=8$。\n- 政府利息支付 $r^G=2$。\n\n请遵循以下步骤，通过将IO数据映射到SAM组件，从基本原理构建与SAM一致的政府账户：\n\n1. 使用活动 $i$ 的总销售额等于产业间销售额、家庭消费、政府消费和出口之和这一恒等式，从IO流量和最终需求中推断出每个活动的总产出 $Y_i$。\n2. 使用SAM恒等式（税收流被记录为从相应税基到政府账户的支付），计算政府从总产出产品税、家庭消费消费税、进口关税以及工资家庭所得税中获得的总税收收入。\n3. 使用SAM恒等式（政府支出被记录为从政府账户到其他账户的支付），计算政府总支出，即政府最终消费（以基本价格计）、对家庭的转移支付和利息支付的总和。\n4. 对政府账户强制执行复式记账恒等式，其中差额项，即政府储蓄 $S_G$（如果为正，则为从 $G$ 到 $K$ 的支付；如果为负，则为从 $K$ 到 $G$ 的流入），用于平衡账户，使得总流入等于总流出。\n\n根据以上数据和恒等式，计算 $S_G$ 的唯一标量值。最终答案以十亿本国货币单位表示。无需四舍五入；报告精确值。",
            "solution": "该问题是有效的，因为它科学地基于社会核算矩阵（SAM）的原理，问题设定良好，拥有清晰完整的数据和恒等式，并以客观、正式的语言表述。任务是通过所提供的投入产出和国民账户数据构建政府账户，从而计算政府储蓄 $S_G$。这涉及问题陈述中概述的四个步骤。\n\n政府账户与SAM中的所有账户一样，必须平衡。这意味着总流入（收入）必须等于总流出（支付）。政府账户的平衡项是政府储蓄 $S_G$。基本恒等式为：\n$$\n\\text{政府总收入} = \\text{政府总支出} + S_G\n$$\n因此，政府储蓄是差额：\n$$\nS_G = \\text{政府总收入} - \\text{政府总支出}\n$$\n$S_G$ 的正值代表政府盈余（从政府账户 $G$ 到资本账户 $K$ 的支付），而负值代表赤字（从 $K$ 到 $G$ 的流入）。\n\n我们将根据提供的数据，通过计算政府总收入和总支出来进行。\n\n**步骤1：计算每个活动的总产出（$Y_i$）**\n\n一个活动 $i$ 的总产出，记为 $Y_i$，是其总销售额。这是它对其他产业的销售额（中间消耗）、对家庭的销售额（最终消费）、对政府的销售额（最终消费）以及对世界其他地区的销售额（出口）的总和。公式为：\n$$\nY_i = \\sum_{j \\in \\{E,M,S,T,A\\}} T_{ij} + c_i + g_i + x_i\n$$\n其中 $T_{ij}$ 表示从活动 $i$ 到活动 $j$ 的销售， $c_i$ 是家庭对产品 $i$ 的消费， $g_i$ 是政府对产品 $i$ 的消费， $x_i$ 是产品 $i$ 的出口。\n\n对于电力（E）：\n$Y_E = T_{EE} + T_{EM} + T_{ES} + T_{ET} + T_{EA} + c_E + g_E + x_E = 5 + 10 + 2 + 4 + 1 + 12 + 5 + 8 = 47$\n\n对于制造业（M）：\n$Y_M = T_{ME} + T_{MM} + T_{MS} + T_{MT} + T_{MA} + c_M + g_M + x_M = 3 + 8 + 5 + 6 + 4 + 25 + 7 + 20 = 78$\n\n对于服务业（S）：\n$Y_S = T_{SE} + T_{SM} + T_{SS} + T_{ST} + T_{SA} + c_S + g_S + x_S = 2 + 7 + 9 + 5 + 3 + 40 + 12 + 10 = 88$\n\n对于运输业（T）：\n$Y_T = T_{TE} + T_{TM} + T_{TS} + T_{TT} + T_{TA} + c_T + g_T + x_T = 1 + 4 + 3 + 6 + 2 + 18 + 10 + 6 = 50$\n\n对于农业（A）：\n$Y_A = T_{AE} + T_{AM} + T_{AS} + T_{AT} + T_{AA} + c_A + g_A + x_A = 0.5 + 3 + 2 + 1 + 7 + 15 + 6 + 12 = 46.5$\n\n总产出为：$Y_E=47$，$Y_M=78$，$Y_S=88$，$Y_T=50$，$Y_A=46.5$。\n\n**步骤2：计算政府总收入（$R_G$）**\n\n政府收入由四类税收构成：\n1.  **产品税收入（$R_p$）**：这是对每个活动的总产出征收的税收总和。\n    $$R_p = \\sum_{i} \\tau^{p}_{i} Y_i$$\n    $R_p = (0.05)(47) + (0.10)(78) + (0.08)(88) + (0.06)(50) + (0.04)(46.5)$\n    $R_p = 2.35 + 7.8 + 7.04 + 3.0 + 1.86 = 22.05$\n\n2.  **消费税收入（$R_c$）**：这是对家庭消费征收的税收总和。\n    $$R_c = \\sum_{i} \\tau^{c}_{i} c_i$$\n    $R_c = (0.02)(12) + (0.04)(25) + (0.03)(40) + (0.05)(18) + (0.01)(15)$\n    $R_c = 0.24 + 1.0 + 1.2 + 0.9 + 0.15 = 3.49$\n\n3.  **关税收入（$R_m$）**：这是对进口征收的税收总和。\n    $$R_m = \\sum_{i} \\tau^{m}_{i} m_i$$\n    $R_m = (0.03)(5) + (0.05)(18) + (0.02)(12) + (0.04)(9) + (0.03)(7)$\n    $R_m = 0.15 + 0.9 + 0.24 + 0.36 + 0.21 = 1.86$\n\n4.  **家庭所得税收入（$R_y$）**：这是对各活动向家庭支付的总工资收入征收的税。\n    首先，我们计算总工资收入 $W$：\n    $W = \\sum_{i} w_i = 18 + 35 + 38 + 21 + 18 = 130$\n    然后，我们应用所得税率 $\\tau^y$：\n    $R_y = \\tau^y \\times W = 0.15 \\times 130 = 19.5$\n\n政府总收入 $R_G$ 是这些组成部分的总和：\n$$R_G = R_p + R_c + R_m + R_y$$\n$$R_G = 22.05 + 3.49 + 1.86 + 19.5 = 46.9$$\n\n**步骤3：计算政府总支出（$E_G$）**\n\n政府支出包括政府最终消费、对家庭的转移支付和利息支付。\n1.  **政府最终消费（$G_c$）**：这是政府从所有活动购买的总和。\n    $$G_c = \\sum_i g_i$$\n    $G_c = 5 + 7 + 12 + 10 + 6 = 40$\n\n2.  **对家庭的转移支付（$Tr_{GH}$）**：\n    $Tr_{GH} = tr^{G\\to H} = 8$\n\n3.  **利息支付（$Int_G$）**：\n    $Int_G = r^G = 2$\n\n政府总支出 $E_G$ 是这些支出的总和：\n$$E_G = G_c + Tr_{GH} + Int_G$$\n$$E_G = 40 + 8 + 2 = 50$$\n\n**步骤4：计算政府储蓄（$S_G$）**\n\n最后，我们通过从总收入中减去总支出，来计算政府储蓄：\n$$S_G = R_G - E_G$$\n$$S_G = 46.9 - 50 = -3.1$$\n\n最终得到的政府储蓄值 $S_G$ 是 -3.1 十亿本国货币单位。负号表示政府赤字，在SAM中记录为从资本账户到政府账户的一笔支付。",
            "answer": "$$\\boxed{-3.1}$$"
        },
        {
            "introduction": "一个社会核算矩阵（SAM）仅仅是经济体在某一年的静态快照。为了将其转化为一个动态的分析工具，我们必须校准一个可计算一般均衡（CGE）模型，使其能够重现这个基准年的经济平衡。在本练习中，你将通过求解零利润和市场出清条件组成的方程组，为模型计算出一组一致的基准年价格和工资，并探索“计价物”（numeraire）在确定绝对价格水平中的关键作用。",
            "id": "4105969",
            "problem": "您的任务是使用固定系数（里昂惕夫）技术、完全竞争和规模报酬不变的假设，将一个简单的、静态的、自上而下的可计算一般均衡 (CGE) 模型校准到社会核算矩阵 (SAM)。该经济体有 $n=2$ 个部门，生产 $2$ 种商品，并使用单一原始要素（劳动）。您必须推导并实施一个校准程序，计算满足零利润和市场出清的基准年价格和活动水平，并且必须引入一个明确的标准化（计价物）来固定绝对价格水平。\n\n基本原理：\n- 在规模报酬不变和固定投入系数的条件下，竞争性零利润意味着单位价格向量 $p \\in \\mathbb{R}^2$ 满足线性价格体系\n$$\n\\left(I - A^\\top\\right) p = a_L \\, w,\n$$\n其中 $I$ 是单位矩阵，$A \\in \\mathbb{R}^{2 \\times 2}$ 是中间投入技术系数矩阵，其元素 $a_{ji}$ 等于部门 $i$ 每单位产出所使用的商品 $j$ 的数量，$a_L \\in \\mathbb{R}^2$ 是各部门每单位产出的原始要素（劳动）需求向量，$w \\in \\mathbb{R}$ 是工资（原始要素的价格）。\n- 固定系数下的市场出清意味着基准年活动（产出）向量 $x \\in \\mathbb{R}^2$ 满足\n$$\n\\left(I - A \\right) x = y,\n$$\n其中 $y \\in \\mathbb{R}^2$ 是基准年最终需求向量。\n- 社会核算矩阵 (SAM) 提供了中间使用矩阵 $Z \\in \\mathbb{R}^{2 \\times 2}$、最终需求向量 $y \\in \\mathbb{R}^2$ 以及各部门的增加值支付 $v \\in \\mathbb{R}^2$，它们满足核算恒等式 $x = Z \\mathbf{1} + y$，其中 $\\mathbf{1}$ 是元素全为1的向量。根据 SAM，技术系数和原始要素系数构建如下\n$$\nA = Z \\, \\mathrm{diag}(x)^{-1}, \\quad a_L = v \\oslash x,\n$$\n其中 $\\mathrm{diag}(x)$ 是以 $x$ 为对角线元素的对角矩阵，$\\oslash$ 表示逐元素除法。\n\n标准化（计价物）：\n- 因为均衡条件只决定相对价格，所以需要进行标准化。您将实现以下两种标准化方法：\n  1. 工资计价物：固定 $w = 1$，并从 $\\left(I - A^\\top\\right) p = a_L$ 中求解 $p$。\n  2. 价格指数计价物：使用给定的正权重向量 $s \\in \\mathbb{R}^2$ 施加 $s^\\top p = 1$ 的约束，并联合求解\n  $$\n  \\begin{bmatrix}\n  I - A^\\top & -a_L \\\\\n  s^\\top & 0\n  \\end{bmatrix}\n  \\begin{bmatrix}\n  p \\\\ w\n  \\end{bmatrix}\n  =\n  \\begin{bmatrix}\n  0 \\\\ 1\n  \\end{bmatrix}.\n  $$\n\n您的程序必须：\n- 对于下面的每个测试用例，通过选择 $A$、$x$ 和 $a_L$，从给定的基元构建一个一致的 SAM，然后形成\n  $$\n  Z = A \\, \\mathrm{diag}(x), \\quad y = x - A x, \\quad v = a_L \\odot x,\n  $$\n  其中 $\\odot$ 表示逐元素乘法。然后计算：\n  - 满足零利润和指定标准化的价格向量 $p$ 和工资 $w$。\n  - 求解 $\\left(I - A \\right) x_{\\mathrm{cal}} = y$ 得到的活动向量 $x_{\\mathrm{cal}}$。\n- 对每个测试用例，返回列表 $[p_1, p_2, w, x_{\\mathrm{cal},1}, x_{\\mathrm{cal},2}]$，所有数值为浮点数。\n\n测试套件：\n- 用例 $1$（工资计价物）：\n  - $A = \\begin{bmatrix} 0.2 & 0.1 \\\\ 0.05 & 0.15 \\end{bmatrix}$, $x = \\begin{bmatrix} 100 \\\\ 80 \\end{bmatrix}$, $a_L = \\begin{bmatrix} 0.7 \\\\ 0.6 \\end{bmatrix}$；标准化：$w=1$。\n- 用例 $2$（价格指数计价物）：\n  - $A = \\begin{bmatrix} 0.1 & 0.2 \\\\ 0.2 & 0.1 \\end{bmatrix}$, $x = \\begin{bmatrix} 50 \\\\ 120 \\end{bmatrix}$, $a_L = \\begin{bmatrix} 0.6 \\\\ 0.7 \\end{bmatrix}$；标准化：$s = \\begin{bmatrix} 0.5 \\\\ 0.5 \\end{bmatrix}$ 且 $s^\\top p = 1$。\n- 用例 $3$（边界稳定，工资计价物）：\n  - $A = \\begin{bmatrix} 0.49 & 0.0 \\\\ 0.0 & 0.49 \\end{bmatrix}$, $x = \\begin{bmatrix} 40 \\\\ 60 \\end{bmatrix}$, $a_L = \\begin{bmatrix} 0.01 \\\\ 0.01 \\end{bmatrix}$；标准化：$w=1$。\n\n覆盖性设计：\n- 用例 $1$ 是一个通用的“理想路径”。\n- 用例 $2$ 测试在价格指数计价物下对 $p$ 和 $w$ 的联合求解。\n- 用例 $3$ 测试具有较大中间系数但谱半径严格小于 $1$ 时的稳定性。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由各用例列表组成的逗号分隔列表，并用方括号括起来，不含空格。例如，所需格式为\n  $$\n  \\text{\"[[p_{1,1},p_{1,2},w_1,x_{1,1},x_{1,2}],[p_{2,1},p_{2,2},w_2,x_{2,1},x_{2,2}],[p_{3,1},p_{3,2},w_3,x_{3,1},x_{3,2}]]\"}.\n  $$\n所有量均为无单位指数或与 SAM 计价物一致的货币量；请将它们报告为浮点数，除了编程语言的默认打印表示外，无需进行额外的舍入指令。",
            "solution": "该问题要求校准一个具有固定系数里昂惕夫技术的简单的静态双部门可计算一般均衡 (CGE) 模型。这涉及计算与社会核算矩阵 (SAM) 一致的基准年均衡价格、工资和活动水平。该过程必须针对三个独立的测试用例实施，每个用例都具有不同的参数和标准化规则。\n\n该问题在科学上和数学上都是适定的。它描述了一个标准的里昂惕夫投入产出框架，这是定量经济分析的基石。所提供的方程是规模报酬不变下竞争均衡的基本表示。对于所有测试用例，解的存在性和唯一性条件——即里昂惕夫矩阵 $(I-A)$ 和价格体系矩阵的可逆性——都得到满足，因为技术系数矩阵 $A$ 是生产性的（其谱半径小于 $1$）。这项任务是计算经济学中一个标准的、可验证的练习。\n\n**理论框架**\n\n该模型由两组核心线性方程定义，一组用于数量（市场出清），另一组用于价格（零利润条件）。\n\n1.  **数量体系（物质平衡）：** 经济的总产出，由活动向量 $x \\in \\mathbb{R}^2$ 表示，必须同时满足中间需求和最终需求。在由矩阵 $A$ 定义的固定系数技术下，其中元素 $a_{ji}$ 是生产一单位商品 $i$ 所需的商品 $j$ 的数量，中间需求为 $Ax$。市场出清条件为：\n    $$\n    x = Ax + y\n    $$\n    其中 $y \\in \\mathbb{R}^2$ 是最终需求向量。这可以重排为标准的里昂惕夫体系：\n    $$\n    (I - A) x = y\n    $$\n    对于一个经济上可行的系统，矩阵 $(I-A)$ 必须是可逆的，并且其逆矩阵 $(I-A)^{-1}$（里昂惕夫逆矩阵）必须具有非负项。如果 $A$ 的谱半径小于 $1$，这一点可以得到保证。\n\n2.  **价格体系（零利润条件）：** 在完全竞争均衡和规模报酬不变的情况下，利润被驱动为零。这意味着一单位商品的价格必须等于其单位生产成本。成本是中间投入成本和原始要素（劳动）成本的总和。这种关系表示为：\n    $$\n    p = A^\\top p + a_L w\n    $$\n    其中 $p \\in \\mathbb{R}^2$ 是商品价格向量，$A^\\top$ 是技术系数矩阵的转置，$a_L \\in \\mathbb{R}^2$ 是每单位产出所需的劳动向量，$w \\in \\mathbb{R}$ 是工资率。这可以重排为：\n    $$\n    (I - A^\\top) p = a_L w\n    $$\n    该体系只在相差一个乘法常数的意义上确定价格；也就是说，它确定的是相对价格。为了找到绝对价格水平的唯一解，必须施加一个标准化规则（计价物）。\n\n**校准与求解过程**\n\n任务是执行一个校准练习。我们从已知的基准年模型参数——技术系数矩阵 $A$、基准年产出向量 $x$ 和劳动系数向量 $a_L$——开始，并用它们来推导一个一致的数据集并求解均衡值。\n\n首先，我们建立一致的基准年数据集（SAM）。给定基元 $A$、$x$ 和 $a_L$，根据定义，能使市场出清的相应最终需求向量 $y$ 计算如下：\n$$\ny = (I - A) x\n$$\n然后，问题要求使用这个推导出的最终需求来求解一个“校准后”的活动向量 $x_{\\mathrm{cal}}$：\n$$\n(I - A) x_{\\mathrm{cal}} = y\n$$\n代入 $y$ 的表达式得到 $(I - A) x_{\\mathrm{cal}} = (I - A) x$。由于对于一个可行的经济体，$(I - A)$ 是可逆的，这意味着 $x_{\\mathrm{cal}} = x$。这是校准过程中固有的一致性检验：模型在使用校准参数求解时，必须能够复制其校准所依据的基准年数据。因此，对于所有测试用例，计算出的活动向量 $x_{\\mathrm{cal}}$ 将与提供的基准年活动向量 $x$ 相同。\n\n主要的计算任务是根据每个用例指定的标准化规则，求解价格向量 $p$ 和工资 $w$。\n\n**用例 1：工资计价物**\n基元为：\n$A = \\begin{bmatrix} 0.2 & 0.1 \\\\ 0.05 & 0.15 \\end{bmatrix}$, $x = \\begin{bmatrix} 100 \\\\ 80 \\end{bmatrix}$, $a_L = \\begin{bmatrix} 0.7 \\\\ 0.6 \\end{bmatrix}$。\n标准化是工资计价物，它固定 $w=1$。\n\n价格体系变为：\n$$\n(I - A^\\top) p = a_L\n$$\n价格向量 $p$ 的解通过求解这个线性系统得到：\n$$\np = (I - A^\\top)^{-1} a_L\n$$\n数值上，我们求解：\n$$\n\\left( \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} - \\begin{bmatrix} 0.2 & 0.05 \\\\ 0.1 & 0.15 \\end{bmatrix} \\right) \\begin{bmatrix} p_1 \\\\ p_2 \\end{bmatrix} = \\begin{bmatrix} 0.7 \\\\ 0.6 \\end{bmatrix}\n$$\n$$\n\\begin{bmatrix} 0.8 & -0.05 \\\\ -0.1 & 0.85 \\end{bmatrix} \\begin{bmatrix} p_1 \\\\ p_2 \\end{bmatrix} = \\begin{bmatrix} 0.7 \\\\ 0.6 \\end{bmatrix}\n$$\n活动向量为 $x_{\\mathrm{cal}} = x = [100, 80]^\\top$。完整的结果向量是 $[p_1, p_2, 1.0, 100.0, 80.0]$。\n\n**用例 2：价格指数计价物**\n基元为：\n$A = \\begin{bmatrix} 0.1 & 0.2 \\\\ 0.2 & 0.1 \\end{bmatrix}$, $x = \\begin{bmatrix} 50 \\\\ 120 \\end{bmatrix}$, $a_L = \\begin{bmatrix} 0.6 \\\\ 0.7 \\end{bmatrix}$。\n标准化是价格指数计价物，权重为 $s = [0.5, 0.5]^\\top$，施加约束 $s^\\top p = 1$。\n\n我们必须使用结合了零利润条件和标准化规则的增广系统来联合求解 $p$ 和 $w$：\n$$\n\\begin{bmatrix}\nI - A^\\top & -a_L \\\\\ns^\\top & 0\n\\end{bmatrix}\n\\begin{bmatrix}\np \\\\ w\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\ 1\n\\end{bmatrix}\n$$\n代入给定值，我们构成一个 $3 \\times 3$ 的线性系统：\n$$\n\\left( \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} - \\begin{bmatrix} 0.1 & 0.2 \\\\ 0.2 & 0.1 \\end{bmatrix} \\right) \\begin{bmatrix} p_1 \\\\ p_2 \\end{bmatrix} - \\begin{bmatrix} 0.6 \\\\ 0.7 \\end{bmatrix} w = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}\n$$\n$$\n\\begin{bmatrix} 0.5 & 0.5 \\end{bmatrix} \\begin{bmatrix} p_1 \\\\ p_2 \\end{bmatrix} = 1\n$$\n这组合成矩阵方程：\n$$\n\\begin{bmatrix}\n0.9 & -0.2 & -0.6 \\\\\n-0.2 & 0.9 & -0.7 \\\\\n0.5 & 0.5 & 0.0\n\\end{bmatrix}\n\\begin{bmatrix}\np_1 \\\\\np_2 \\\\\nw\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\\n0 \\\\\n1\n\\end{bmatrix}\n$$\n求解这个系统可以得到 $p_1$、$p_2$ 和 $w$ 的唯一值。\n活动向量为 $x_{\\mathrm{cal}} = x = [50, 120]^\\top$。完整的结果向量是 $[p_1, p_2, w, 50.0, 120.0]$。\n\n**用例 3：边界稳定，工资计价物**\n基元为：\n$A = \\begin{bmatrix} 0.49 & 0.0 \\\\ 0.0 & 0.49 \\end{bmatrix}$, $x = \\begin{bmatrix} 40 \\\\ 60 \\end{bmatrix}$, $a_L = \\begin{bmatrix} 0.01 \\\\ 0.01 \\end{bmatrix}$。\n标准化是工资计价物，它固定 $w=1$。\n\n该过程与用例 1 相同。我们求解 $p = (I - A^\\top)^{-1} a_L$。由于 $A$ 是对角矩阵，所以 $A^\\top = A$。\n$$\n\\left( \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix} - \\begin{bmatrix} 0.49 & 0.0 \\\\ 0.0 & 0.49 \\end{bmatrix} \\right) \\begin{bmatrix} p_1 \\\\ p_2 \\end{bmatrix} = \\begin{bmatrix} 0.01 \\\\ 0.01 \\end{bmatrix}\n$$\n$$\n\\begin{bmatrix} 0.51 & 0.0 \\\\ 0.0 & 0.51 \\end{bmatrix} \\begin{bmatrix} p_1 \\\\ p_2 \\end{bmatrix} = \\begin{bmatrix} 0.01 \\\\ 0.01 \\end{bmatrix}\n$$\n这个对角系统可以轻易求解：$p_1 = p_2 = 0.01 / 0.51$。\n活动向量为 $x_{\\mathrm{cal}} = x = [40, 60]^\\top$。完整的结果向量是 $[p_1, p_2, 1.0, 40.0, 60.0]$。稳定性得到保证，因为 $A$ 的特征值为 $0.49$，严格小于 $1$，所以里昂惕夫逆矩阵存在。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for equilibrium prices, wages, and activity levels for a simple\n    CGE model based on provided test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"id\": 1,\n            \"A\": np.array([[0.2, 0.1], [0.05, 0.15]]),\n            \"x\": np.array([100.0, 80.0]),\n            \"a_L\": np.array([0.7, 0.6]),\n            \"norm_type\": \"wage_numeraire\",\n            \"norm_params\": {\"w\": 1.0}\n        },\n        {\n            \"id\": 2,\n            \"A\": np.array([[0.1, 0.2], [0.2, 0.1]]),\n            \"x\": np.array([50.0, 120.0]),\n            \"a_L\": np.array([0.6, 0.7]),\n            \"norm_type\": \"price_index_numeraire\",\n            \"norm_params\": {\"s\": np.array([0.5, 0.5])}\n        },\n        {\n            \"id\": 3,\n            \"A\": np.array([[0.49, 0.0], [0.0, 0.49]]),\n            \"x\": np.array([40.0, 60.0]),\n            \"a_L\": np.array([0.01, 0.01]),\n            \"norm_type\": \"wage_numeraire\",\n            \"norm_params\": {\"w\": 1.0}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case[\"A\"]\n        x = case[\"x\"]\n        a_L = case[\"a_L\"]\n        norm_type = case[\"norm_type\"]\n        norm_params = case[\"norm_params\"]\n        \n        n = A.shape[0]\n        I = np.identity(n)\n\n        # By construction of the calibration problem, x_cal = x.\n        # The problem asks to solve (I - A)x_cal = y where y = (I - A)x.\n        # This simplifies to (I - A)x_cal = (I - A)x.\n        # Since (I - A) is invertible for a viable economy, x_cal = x.\n        x_cal = x\n\n        p = None\n        w = None\n\n        if norm_type == \"wage_numeraire\":\n            # Fix w = 1 and solve (I - A^T)p = a_L * w\n            w = norm_params[\"w\"]\n            M = I - A.T\n            b = a_L * w\n            p = np.linalg.solve(M, b)\n        \n        elif norm_type == \"price_index_numeraire\":\n            # Solve the augmented system for [p, w]\n            # [ I - A^T   -a_L ] [ p ] = [ 0 ]\n            # [ s^T         0  ] [ w ]   [ 1 ]\n            s = norm_params[\"s\"]\n            \n            M_aug = np.zeros((n + 1, n + 1))\n            M_aug[:n, :n] = I - A.T\n            M_aug[:n, n] = -a_L\n            M_aug[n, :n] = s\n            # M_aug[n, n] is already 0.0\n            \n            b_aug = np.zeros(n + 1)\n            b_aug[n] = 1.0\n            \n            solution = np.linalg.solve(M_aug, b_aug)\n            p = solution[:n]\n            w = solution[n]\n\n        # Assemble the final result vector for the case\n        case_result = [p[0], p[1], w, x_cal[0], x_cal[1]]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists will have spaces.\n    # The required format has no spaces, e.g., [[1,2],[3,4]].\n    # We remove all spaces from the default string representation.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}