{
    "hands_on_practices": [
        {
            "introduction": "The first step in building a credible model is ensuring the code correctly implements the intended mathematical equations. This practice introduces the Method of Manufactured Solutions (MMS), a powerful and formal technique for code verification. You will learn the core procedure of MMS by deriving an artificial source term for a partial differential equation (PDE) that forces a chosen 'manufactured' function to be an exact solution, allowing for a precise and quantitative check of your solver's implementation. ",
            "id": "4105668",
            "problem": "A one-dimensional steady pipeline of constant cross-sectional area transports a dilute fuel species with mass fraction $c(x,t)$ along coordinate $x$ and time $t$. Starting from the conservation of species mass in a differential control volume, the constitutive flux for advection and diffusion is $J(x,t) = u\\,c(x,t) - D\\,\\frac{\\partial c}{\\partial x}(x,t)$, where $u$ is the constant mean axial velocity and $D$ is the constant effective axial diffusion coefficient. A linear first-order loss term models consumption or leakage as $-\\,\\kappa\\,c(x,t)$, where $\\kappa > 0$ is the rate constant. To perform code verification using the Method of Manufactured Solutions (MMS), an artificial source term $S(x,t)$ is added so that a chosen exact solution is satisfied by the governing Partial Differential Equation (PDE).\n\nUsing the above conservation and constitutive statements as the fundamental base, consider the linear advection–diffusion–reaction PDE with source,\n$$\\frac{\\partial c}{\\partial t} + u\\,\\frac{\\partial c}{\\partial x} = D\\,\\frac{\\partial^{2} c}{\\partial x^{2}} - \\kappa\\,c + S(x,t),$$\nwith positive constants $u$, $D$, and $\\kappa$. For MMS, choose the manufactured solution\n$$c(x,t) = \\exp(\\alpha t)\\,\\big(\\sin(\\beta x) + x^{2}\\big) + \\exp(\\sigma t)\\,\\cos(\\beta x),$$\nwhere $\\alpha$, $\\sigma$, and $\\beta$ are nonzero constants.\n\nDerive the explicit closed-form expression for the source term $S(x,t)$ that makes the above $c(x,t)$ an exact solution of the PDE. Express your final answer as a single analytic expression in terms of $x$, $t$, $u$, $D$, $\\kappa$, $\\alpha$, $\\sigma$, and $\\beta$. Do not include units. No numerical evaluation or rounding is required.",
            "solution": "The problem requires the derivation of an artificial source term $S(x,t)$ for a given Partial Differential Equation (PDE) such that a chosen manufactured solution $c(x,t)$ is an exact solution. This is a standard procedure in the Method of Manufactured Solutions (MMS) used for code verification.\n\nThe governing linear advection–diffusion–reaction PDE is given as:\n$$\n\\frac{\\partial c}{\\partial t} + u\\,\\frac{\\partial c}{\\partial x} = D\\,\\frac{\\partial^{2} c}{\\partial x^{2}} - \\kappa\\,c + S(x,t)\n$$\nTo find the source term $S(x,t)$, we rearrange the PDE to isolate $S(x,t)$:\n$$\nS(x,t) = \\frac{\\partial c}{\\partial t} + u\\,\\frac{\\partial c}{\\partial x} - D\\,\\frac{\\partial^{2} c}{\\partial x^{2}} + \\kappa\\,c\n$$\nThe manufactured solution is provided as:\n$$\nc(x,t) = \\exp(\\alpha t)\\,\\big(\\sin(\\beta x) + x^{2}\\big) + \\exp(\\sigma t)\\,\\cos(\\beta x)\n$$\nwhere $u$, $D$, $\\kappa$ are positive constants, and $\\alpha$, $\\sigma$, $\\beta$ are nonzero constants.\n\nThe derivation proceeds by computing the necessary partial derivatives of $c(x,t)$ and substituting them into the expression for $S(x,t)$.\n\nFirst, we calculate the partial derivative of $c(x,t)$ with respect to time $t$:\n$$\n\\frac{\\partial c}{\\partial t} = \\frac{\\partial}{\\partial t} \\left[ \\exp(\\alpha t)\\,\\big(\\sin(\\beta x) + x^{2}\\big) + \\exp(\\sigma t)\\,\\cos(\\beta x) \\right]\n$$\n$$\n\\frac{\\partial c}{\\partial t} = \\alpha \\exp(\\alpha t)\\,\\big(\\sin(\\beta x) + x^{2}\\big) + \\sigma \\exp(\\sigma t)\\,\\cos(\\beta x)\n$$\n\nNext, we calculate the first partial derivative of $c(x,t)$ with respect to the spatial coordinate $x$:\n$$\n\\frac{\\partial c}{\\partial x} = \\frac{\\partial}{\\partial x} \\left[ \\exp(\\alpha t)\\,\\big(\\sin(\\beta x) + x^{2}\\big) + \\exp(\\sigma t)\\,\\cos(\\beta x) \\right]\n$$\n$$\n\\frac{\\partial c}{\\partial x} = \\exp(\\alpha t)\\,\\big(\\beta \\cos(\\beta x) + 2x\\big) - \\beta \\exp(\\sigma t)\\,\\sin(\\beta x)\n$$\n\nThen, we calculate the second partial derivative with respect to $x$:\n$$\n\\frac{\\partial^{2} c}{\\partial x^{2}} = \\frac{\\partial}{\\partial x} \\left[ \\exp(\\alpha t)\\,\\big(\\beta \\cos(\\beta x) + 2x\\big) - \\beta \\exp(\\sigma t)\\,\\sin(\\beta x) \\right]\n$$\n$$\n\\frac{\\partial^{2} c}{\\partial x^{2}} = \\exp(\\alpha t)\\,\\big(-\\beta^{2} \\sin(\\beta x) + 2\\big) - \\beta^{2} \\exp(\\sigma t)\\,\\cos(\\beta x)\n$$\n\nNow we substitute $c(x,t)$ and its derivatives into the expression for $S(x,t)$:\n$$\nS(x,t) = \\left[ \\alpha \\exp(\\alpha t)\\big(\\sin(\\beta x) + x^{2}\\big) + \\sigma \\exp(\\sigma t)\\cos(\\beta x) \\right] + u \\left[ \\exp(\\alpha t)\\big(\\beta \\cos(\\beta x) + 2x\\big) - \\beta \\exp(\\sigma t)\\sin(\\beta x) \\right] - D \\left[ \\exp(\\alpha t)\\big(-\\beta^{2} \\sin(\\beta x) + 2\\big) - \\beta^{2} \\exp(\\sigma t)\\cos(\\beta x) \\right] + \\kappa \\left[ \\exp(\\alpha t)\\big(\\sin(\\beta x) + x^{2}\\big) + \\exp(\\sigma t)\\cos(\\beta x) \\right]\n$$\nTo obtain the final closed-form expression, we expand and collect terms based on their functional dependence on $x$ and $t$.\n\nExpanding all terms:\n$$\nS(x,t) = \\alpha \\exp(\\alpha t)\\sin(\\beta x) + \\alpha \\exp(\\alpha t)x^{2} + \\sigma \\exp(\\sigma t)\\cos(\\beta x) + u\\beta \\exp(\\alpha t)\\cos(\\beta x) + 2ux \\exp(\\alpha t) - u\\beta \\exp(\\sigma t)\\sin(\\beta x) + D\\beta^{2} \\exp(\\alpha t)\\sin(\\beta x) - 2D \\exp(\\alpha t) + D\\beta^{2} \\exp(\\sigma t)\\cos(\\beta x) + \\kappa \\exp(\\alpha t)\\sin(\\beta x) + \\kappa \\exp(\\alpha t)x^{2} + \\kappa \\exp(\\sigma t)\\cos(\\beta x)\n$$\nNow, we group the coefficients of the distinct functional forms: $\\sin(\\beta x)$, $\\cos(\\beta x)$, and the polynomial in $x$.\n\nFor the terms proportional to $\\sin(\\beta x)$:\n$$\n\\big(\\alpha \\exp(\\alpha t) - u\\beta \\exp(\\sigma t) + D\\beta^{2} \\exp(\\alpha t) + \\kappa \\exp(\\alpha t)\\big) \\sin(\\beta x) = \\left[ (\\alpha + \\kappa + D\\beta^{2})\\exp(\\alpha t) - u\\beta\\exp(\\sigma t) \\right] \\sin(\\beta x)\n$$\nFor the terms proportional to $\\cos(\\beta x)$:\n$$\n\\big(\\sigma \\exp(\\sigma t) + u\\beta \\exp(\\alpha t) + D\\beta^{2} \\exp(\\sigma t) + \\kappa \\exp(\\sigma t)\\big) \\cos(\\beta x) = \\left[ u\\beta\\exp(\\alpha t) + (\\sigma + \\kappa + D\\beta^{2})\\exp(\\sigma t) \\right] \\cos(\\beta x)\n$$\nFor the terms that are polynomial in $x$:\n$$\n\\alpha \\exp(\\alpha t)x^{2} + 2ux \\exp(\\alpha t) - 2D\\exp(\\alpha t) + \\kappa \\exp(\\alpha t)x^{2} = \\left[ (\\alpha+\\kappa)x^{2} + 2ux - 2D \\right] \\exp(\\alpha t)\n$$\nCombining these groups yields the final expression for the source term $S(x,t)$:\n$$\nS(x,t) = \\left[ (\\alpha + \\kappa + D\\beta^{2})\\exp(\\alpha t) - u\\beta\\exp(\\sigma t) \\right] \\sin(\\beta x) + \\left[ u\\beta\\exp(\\alpha t) + (\\sigma + \\kappa + D\\beta^{2})\\exp(\\sigma t) \\right] \\cos(\\beta x) + \\left[ (\\alpha+\\kappa)x^{2} + 2ux - 2D \\right] \\exp(\\alpha t)\n$$\nThis is the required explicit closed-form expression for the source term.",
            "answer": "$$\n\\boxed{\\left[ (\\alpha + \\kappa + D\\beta^{2})\\exp(\\alpha t) - u\\beta\\exp(\\sigma t) \\right] \\sin(\\beta x) + \\left[ u\\beta\\exp(\\alpha t) + (\\sigma + \\kappa + D\\beta^{2})\\exp(\\sigma t) \\right] \\cos(\\beta x) + \\left[ (\\alpha+\\kappa)x^{2} + 2ux - 2D \\right] \\exp(\\alpha t)}\n$$"
        },
        {
            "introduction": "Once a model's code is confirmed to be bug-free, a critical part of verification is to assess its numerical accuracy, as simulations introduce discretization errors. This exercise demonstrates Richardson extrapolation, a classic technique to analyze this error. Using simulation outputs from multiple grid resolutions, you will learn how to empirically estimate a method's order of accuracy, denoted by $p$, and produce a more accurate estimate of the true solution, $E^{\\ast}$, thereby verifying that your numerical method behaves as expected. ",
            "id": "4105690",
            "problem": "Consider a single thermal generating unit subject to a constant ascending ramp limit, modeled in continuous time by the ordinary differential equation (ODE) $dP/dt = r$ with the unit initially at power $P(0) = P_{0}$, and ramping to a higher power over a finite event duration $T$. The cumulative electrical energy produced over the event is $E = \\int_{0}^{T} P(t)\\, dt$, which defines the quantity of interest for verification. A time-marching simulation is implemented using a piecewise-constant (left-rectangle) accumulation of $P(t)$ over uniform time steps, and the same numerical method is applied with three different time resolutions: $\\Delta t$, $\\Delta t/2$, and $\\Delta t/4$.\n\nIn a verification exercise, assume the method is consistent and that its leading discretization error in the quantity of interest follows the widely used model $E(\\Delta t) = E^{\\ast} + C\\, (\\Delta t)^{p}$, where $E^{\\ast}$ is the exact (time-step independent) value, $C$ is an unknown constant, and $p > 0$ is the empirical order of accuracy. The simulation, for a $T = 15$ minute ramp event starting from $P_{0} = 500$ MW with a constant ramp rate $r = 20$ MW/min, yields the following cumulative energies for the three time steps:\n- For $\\Delta t = 5$ minutes, $E(\\Delta t) = 150.000$ MWh.\n- For $\\Delta t/2 = 2.5$ minutes, $E(\\Delta t/2) = 156.250$ MWh.\n- For $\\Delta t/4 = 1.25$ minutes, $E(\\Delta t/4) = 159.375$ MWh.\n\nUsing only the base error model $E(\\Delta t) = E^{\\ast} + C\\, (\\Delta t)^{p}$ and first principles of grid refinement in numerical simulation, derive expressions to:\n1. Estimate the empirical order of accuracy $p$ from the three computed values.\n2. Perform Richardson extrapolation to estimate $E^{\\ast}$ from the two finest-grid results.\n\nCompute the numerical values of both $p$ and the extrapolated $E^{\\ast}$ using the provided data. Round both values to four significant figures. Express the energy in MWh. Report your final answer as two values in a single row matrix, with the first entry being the extrapolated $E^{\\ast}$ and the second entry being $p$.",
            "solution": "The quantity of interest is the cumulative energy $E = \\int_{0}^{T} P(t)\\, dt$. The numerical method is consistent and its leading error is modeled by\n$$\nE(\\Delta t) = E^{\\ast} + C\\, (\\Delta t)^{p},\n$$\nwhere $E^{\\ast}$ is the exact value, $C$ is a constant, and $p$ is the empirical order of accuracy.\n\nLet $h = \\Delta t$. The three computed energies are $E(h)$, $E(h/2)$, and $E(h/4)$. Under the error model,\n\\begin{align*}\nE(h) &= E^{\\ast} + C h^{p}, \\\\\nE\\!\\left(\\frac{h}{2}\\right) &= E^{\\ast} + C \\left(\\frac{h}{2}\\right)^{p} = E^{\\ast} + C h^{p} 2^{-p}, \\\\\nE\\!\\left(\\frac{h}{4}\\right) &= E^{\\ast} + C \\left(\\frac{h}{4}\\right)^{p} = E^{\\ast} + C h^{p} 4^{-p} = E^{\\ast} + C h^{p} 2^{-2p}.\n\\end{align*}\n\nDefine the successive differences,\n\\begin{align*}\nD_{1} &= E\\!\\left(\\frac{h}{2}\\right) - E(h) = C h^{p} \\left(2^{-p} - 1\\right), \\\\\nD_{2} &= E\\!\\left(\\frac{h}{4}\\right) - E\\!\\left(\\frac{h}{2}\\right) = C h^{p} \\left(2^{-2p} - 2^{-p}\\right) = C h^{p} 2^{-p} \\left(2^{-p} - 1\\right).\n\\end{align*}\nTaking the ratio,\n$$\nR \\equiv \\frac{D_{2}}{D_{1}} = \\frac{C h^{p} 2^{-p} \\left(2^{-p} - 1\\right)}{C h^{p} \\left(2^{-p} - 1\\right)} = 2^{-p}.\n$$\nTherefore,\n$$\np = -\\log_{2}(R) = \\log_{2}\\!\\left(\\frac{D_{1}}{D_{2}}\\right).\n$$\n\nWith $E(h) = 150.000$, $E(h/2) = 156.250$, and $E(h/4) = 159.375$ (all in MWh), compute\n\\begin{align*}\nD_{1} &= E(h/2) - E(h) = 156.250 - 150.000 = 6.250, \\\\\nD_{2} &= E(h/4) - E(h/2) = 159.375 - 156.250 = 3.125.\n\\end{align*}\nThus,\n$$\nR = \\frac{D_{2}}{D_{1}} = \\frac{3.125}{6.250} = 0.5,\n$$\nand\n$$\np = -\\log_{2}(0.5) = 1.\n$$\n\nTo obtain a Richardson extrapolation estimate of $E^{\\ast}$, eliminate the leading error term using the two finest resolutions. From the model,\n\\begin{align*}\nE\\!\\left(\\frac{h}{2}\\right) &= E^{\\ast} + C h^{p} 2^{-p}, \\\\\nE\\!\\left(\\frac{h}{4}\\right) &= E^{\\ast} + C h^{p} 2^{-2p}.\n\\end{align*}\nSubtract and solve for $C h^{p} 2^{-p}$,\n\\begin{align*}\nE\\!\\left(\\frac{h}{4}\\right) - E\\!\\left(\\frac{h}{2}\\right) &= C h^{p} \\left(2^{-2p} - 2^{-p}\\right) = - C h^{p} 2^{-p} \\left(1 - 2^{-p}\\right), \\\\\nC h^{p} 2^{-p} &= \\frac{E\\!\\left(\\frac{h}{2}\\right) - E\\!\\left(\\frac{h}{4}\\right)}{1 - 2^{-p}}.\n\\end{align*}\nInsert this into $E\\!\\left(\\frac{h}{4}\\right)$,\n\\begin{align*}\nE^{\\ast} &= E\\!\\left(\\frac{h}{4}\\right) - C h^{p} 2^{-2p} \\\\\n&= E\\!\\left(\\frac{h}{4}\\right) - 2^{-p} \\left[ C h^{p} 2^{-p} \\right] \\\\\n&= E\\!\\left(\\frac{h}{4}\\right) - 2^{-p} \\frac{E\\!\\left(\\frac{h}{2}\\right) - E\\!\\left(\\frac{h}{4}\\right)}{1 - 2^{-p}} \\\\\n&= E\\!\\left(\\frac{h}{4}\\right) + \\frac{E\\!\\left(\\frac{h}{4}\\right) - E\\!\\left(\\frac{h}{2}\\right)}{2^{p} - 1}.\n\\end{align*}\nEvaluate with $p = 1$,\n\\begin{align*}\nE^{\\ast} &= 159.375 + \\frac{159.375 - 156.250}{2^{1} - 1} = 159.375 + \\frac{3.125}{1} = 162.500.\n\\end{align*}\n\nFinally, round to four significant figures: $E^{\\ast} = 162.5$ MWh and $p = 1.000$.",
            "answer": "$$\\boxed{\\begin{pmatrix}162.5 & 1.000\\end{pmatrix}}$$"
        },
        {
            "introduction": "After verifying a model's internal correctness, we can apply it to explore real-world complexities like uncertainty. In energy systems, inputs like electricity demand are never known with certainty. This practice applies Monte Carlo simulation to propagate these uncertainties through a dispatch model, allowing you to estimate the distribution of the resulting dispatch cost and construct statistically rigorous confidence intervals for its key moments. ",
            "id": "4105647",
            "problem": "You are tasked with designing and implementing a complete, runnable program that applies Monte Carlo sampling to propagate uncertainty in single-period electric power system demand and renewable availability into a distribution of dispatch cost, and then computes validated estimators of the mean and variance with confidence intervals. The program must be self-contained and produce deterministic results for a predefined test suite.\n\nUse the following scientifically grounded, context-appropriate base:\n\n- Definitions of expectation and variance: For a random cost variable $C$, the expectation is $E[C]$ and the variance is $\\mathrm{Var}(C) = E[(C - E[C])^2]$.\n- The Law of Large Numbers: The sample mean converges to the expectation as the sample size grows.\n- The Central Limit Theorem: Under mild conditions, the sample mean is approximately normally distributed for large sample sizes.\n- Monte Carlo sampling: Independent and identically distributed draws from the specified input distributions used to approximate $E[C]$ and $\\mathrm{Var}(C)$.\n- Nonparametric bootstrap: Resampling with replacement from the empirical distribution to approximate sampling distributions of statistics without relying on parametric assumptions.\n\nModel fundamentals and definitions:\n\n- Consider a single dispatch period of duration $1$ hour. Let $D$ denote random demand in megawatts $(\\mathrm{MW})$ and $R$ denote random renewable availability in megawatts $(\\mathrm{MW})$.\n- Net load is $L = D - R$.\n- A single thermal generator supplies power $g$ subject to capacity constraint $0 \\le g \\le G_{\\max}$, where $G_{\\max}$ is the generator capacity in megawatts $(\\mathrm{MW})$. The supplied thermal power equals $g = \\min(\\max(L, 0), G_{\\max})$.\n- Unserved energy is $U = \\max(L - G_{\\max}, 0)$ and curtailed renewable energy is $C_c = \\max(R - D, 0)$, both in megawatts $(\\mathrm{MW})$ for the one-hour period.\n- The thermal generation cost is $C_{\\text{th}}(g) = a g^2 + b g$, with $a$ in dollars per square megawatt $(\\$/\\mathrm{MW}^2)$ and $b$ in dollars per megawatt $(\\$/\\mathrm{MW})$.\n- The total dispatch cost is $C = C_{\\text{th}}(g) + \\lambda_s U + \\lambda_c C_c$, where $\\lambda_s$ is the Value of Lost Load (VOLL) in dollars per megawatt $(\\$/\\mathrm{MW})$ and $\\lambda_c$ is the curtailment penalty in dollars per megawatt $(\\$/\\mathrm{MW})$.\n- Demand $D$ is modeled as a truncated normal random variable $D \\sim \\mathcal{N}(\\mu_D, \\sigma_D^2)$ truncated at $D \\ge 0$. Renewable availability is modeled as $R = R_{\\max} X$ where $X \\sim \\mathrm{Beta}(\\alpha, \\beta)$ and $0 \\le R \\le R_{\\max}$.\n\nTasks to implement:\n\n1. For each test case, perform Monte Carlo sampling of size $N$: draw $N$ independent samples $\\{(D_i, R_i)\\}_{i=1}^N$ following the above distributions, compute $g_i$, $U_i$, $C_{c,i}$, and $C_i$ for each sample $i$, then compute:\n   - The sample mean $\\hat{\\mu} = \\frac{1}{N} \\sum_{i=1}^N C_i$.\n   - The unbiased sample variance $\\hat{\\sigma}^2 = \\frac{1}{N-1} \\sum_{i=1}^N (C_i - \\hat{\\mu})^2$.\n2. Construct a confidence interval for the mean using the Student's $t$ distribution: use $\\hat{\\mu} \\pm t_{1 - \\alpha/2, \\, N-1} \\cdot \\hat{s} / \\sqrt{N}$, where $\\hat{s}$ is the sample standard deviation and $t_{1 - \\alpha/2, \\, N-1}$ is the $(1 - \\alpha/2)$ quantile of the Student's $t$ distribution with $N-1$ degrees of freedom.\n3. Construct a confidence interval for the variance using a nonparametric bootstrap with $B$ resamples: for each bootstrap replicate $b \\in \\{1,\\dots,B\\}$, resample $N$ indices with replacement from $\\{1,\\dots,N\\}$, compute the unbiased sample variance on the resampled data, and use the empirical $(\\alpha/2)$ and $(1 - \\alpha/2)$ quantiles of these $B$ bootstrap variances as the lower and upper endpoints of the confidence interval for $\\hat{\\sigma}^2$.\n\nValidation and verification considerations:\n\n- Verification: Ensure constraints $0 \\le g \\le G_{\\max}$, $U \\ge 0$, and $C_c \\ge 0$ hold for all samples by using the definitions $g = \\min(\\max(L, 0), G_{\\max})$, $U = \\max(L - G_{\\max}, 0)$, and $C_c = \\max(R - D, 0)$.\n- Validation: Use the Law of Large Numbers and the Central Limit Theorem to justify the mean estimator and its confidence interval, and use the nonparametric bootstrap to avoid misspecification risk in variance inference. Fix random number generator seeds per test case to ensure reproducibility.\n\nPhysical units and numerical output requirements:\n\n- All costs must be expressed in dollars per hour $(\\$/\\mathrm{h})$ and rounded to two decimal places.\n- Angles are not used; no angle unit specification is required.\n- The final program must produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets. Each inner list must contain exactly six floats in the following order for the corresponding test case: $[\\hat{\\mu}, \\hat{\\sigma}^2, \\text{CI}_{\\mu,\\text{lower}}, \\text{CI}_{\\mu,\\text{upper}}, \\text{CI}_{\\sigma^2,\\text{lower}}, \\text{CI}_{\\sigma^2,\\text{upper}}]$. Each float must be rounded to two decimal places.\n\nTest suite:\n\nUse the following three scientifically realistic and diverse test cases to exercise the logic, constraints, and confidence interval constructions. For each case, report values in $(\\$/\\mathrm{h})$ rounded to two decimals.\n\n- Case A (general case): $G_{\\max} = 900$, $a = 0.01$, $b = 20$, $\\lambda_s = 10000$, $\\lambda_c = 5$, $\\mu_D = 1000$, $\\sigma_D = 100$, $R_{\\max} = 800$, $\\alpha = 3$, $\\beta = 2$, $N = 20000$, $B = 300$, $\\alpha_{\\text{CI}} = 0.05$, $\\text{seed} = 42$.\n- Case B (boundary shortage-sensitive): $G_{\\max} = 900$, $a = 0.01$, $b = 20$, $\\lambda_s = 20000$, $\\lambda_c = 0$, $\\mu_D = 900$, $\\sigma_D = 50$, $R_{\\max} = 600$, $\\alpha = 2$, $\\beta = 6$, $N = 15000$, $B = 250$, $\\alpha_{\\text{CI}} = 0.10$, $\\text{seed} = 123$.\n- Case C (high renewable with curtailment penalties): $G_{\\max} = 700$, $a = 0.01$, $b = 20$, $\\lambda_s = 15000$, $\\lambda_c = 50$, $\\mu_D = 700$, $\\sigma_D = 150$, $R_{\\max} = 1000$, $\\alpha = 5$, $\\beta = 2$, $N = 12000$, $B = 250$, $\\alpha_{\\text{CI}} = 0.05$, $\\text{seed} = 7$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes one inner list of six floats as specified above (for example, $[[x_1,x_2,x_3,x_4,x_5,x_6],[y_1,\\dots,y_6],[z_1,\\dots,z_6]]$), with all values in $(\\$/\\mathrm{h})$ rounded to two decimals. The program must be deterministic and must not require any user input.",
            "solution": "We begin from core definitions of random variables and estimators. Let $C$ denote the random dispatch cost for a single hour under uncertain demand $D$ and renewable availability $R$. The model components are defined as follows: net load $L = D - R$, thermal dispatch $g = \\min(\\max(L, 0), G_{\\max})$, unserved energy $U = \\max(L - G_{\\max}, 0)$, and curtailed energy $C_c = \\max(R - D, 0)$. The total cost is $C = C_{\\text{th}}(g) + \\lambda_s U + \\lambda_c C_c$, where $C_{\\text{th}}(g) = a g^2 + b g$ with $a$ and $b$ representing quadratic and linear cost coefficients. These definitions enforce $0 \\le g \\le G_{\\max}$, $U \\ge 0$, and $C_c \\ge 0$ by construction, which is the verification of constraints critical in energy systems modeling.\n\nWe seek $E[C]$ and $\\mathrm{Var}(C)$, which are defined respectively as $E[C]$ and $E[(C - E[C])^2]$. Closed-form evaluation is intractable due to truncation and the piecewise nature of constraints; therefore, we use Monte Carlo sampling: draw $N$ independent samples of $(D, R)$ from the specified distributions and compute $C_i$ for $i \\in \\{1, \\dots, N\\}$. The sample mean $\\hat{\\mu} = \\frac{1}{N} \\sum_{i=1}^N C_i$ is a consistent estimator of $E[C]$ by the Law of Large Numbers. The unbiased sample variance $\\hat{\\sigma}^2 = \\frac{1}{N-1} \\sum_{i=1}^N (C_i - \\hat{\\mu})^2$ is a consistent estimator of $\\mathrm{Var}(C)$.\n\nFor confidence intervals, we use two principles tailored to our objectives and model validation:\n\n- By the Central Limit Theorem, for sufficiently large $N$, the sample mean $\\hat{\\mu}$ is approximately normally distributed with mean $E[C]$ and standard deviation $\\sigma/\\sqrt{N}$, where $\\sigma$ is the true standard deviation. Because $\\sigma$ is unknown, we use the Student's $t$ distribution with $N - 1$ degrees of freedom and the sample standard deviation $\\hat{s}$ to construct the confidence interval for the mean: $\\hat{\\mu} \\pm t_{1 - \\alpha/2, \\, N-1} \\cdot \\hat{s} / \\sqrt{N}$. This interval accounts for the sampling uncertainty and is robust for large $N$.\n\n- For the variance, a parametric interval would depend on distributional assumptions often violated in energy systems with piecewise costs and truncations. To avoid model misspecification and adhere to validation best practices, we instead use the nonparametric bootstrap: generate $B$ bootstrap samples by resampling with replacement from $\\{C_i\\}_{i=1}^N$, compute the unbiased sample variance for each resample, and take the $(\\alpha/2)$ and $(1 - \\alpha/2)$ empirical quantiles of the $B$ bootstrap variances as the confidence interval endpoints. This procedure leverages the empirical distribution of the data to approximate the sampling distribution of the variance estimator without imposing parametric forms.\n\nAlgorithmic steps:\n\n1. For each test case, initialize a fixed random seed to ensure reproducibility.\n2. Sample demand $D$ from a truncated normal distribution $D \\sim \\mathcal{N}(\\mu_D, \\sigma_D^2)$ truncated at $D \\ge 0$. Sampling is performed via a truncated normal generator that enforces $D \\ge 0$.\n3. Sample renewable availability $R = R_{\\max} X$ with $X \\sim \\mathrm{Beta}(\\alpha, \\beta)$. This constrains $R$ to $[0, R_{\\max}]$.\n4. Compute $L = D - R$, $g = \\min(\\max(L, 0), G_{\\max})$, $U = \\max(L - G_{\\max}, 0)$, and $C_c = \\max(R - D, 0)$ for all samples, then compute $C = a g^2 + b g + \\lambda_s U + \\lambda_c C_c$.\n5. Compute $\\hat{\\mu}$ and $\\hat{\\sigma}^2$ from the sample $\\{C_i\\}$.\n6. Compute the mean confidence interval using the Student's $t$ critical value at confidence level $1 - \\alpha$ with degrees of freedom $N - 1$: $\\hat{\\mu} \\pm t_{1 - \\alpha/2, \\, N-1} \\cdot \\hat{s} / \\sqrt{N}$.\n7. For the variance confidence interval, perform $B$ bootstrap resamples: for each resample, draw $N$ indices with replacement from $\\{1,\\dots,N\\}$, compute the unbiased sample variance on the resampled $C$ values, and then compute the $(\\alpha/2)$ and $(1 - \\alpha/2)$ quantiles across the $B$ bootstrap variances.\n8. Round all outputs to two decimal places and present them in the required single-line format: a list of three inner lists, each containing six floats $[\\hat{\\mu}, \\hat{\\sigma}^2, \\text{CI}_{\\mu,\\text{lower}}, \\text{CI}_{\\mu,\\text{upper}}, \\text{CI}_{\\sigma^2,\\text{lower}}, \\text{CI}_{\\sigma^2,\\text{upper}}]$, with units $(\\$/\\mathrm{h})$.\n\nScientific realism is maintained through physically plausible parameter choices, explicit enforcement of operational constraints, and robust statistical inference. Verification is achieved by ensuring $g$, $U$, and $C_c$ satisfy their nonnegativity and capacity constraints across all samples. Validation is supported by appropriate use of the Law of Large Numbers and Central Limit Theorem for the mean, and bootstrap methods for the variance, thereby aligning with model validation and verification concepts in energy systems modeling. The test suite includes a general case, a shortage-sensitive boundary case, and a high-renewable case with curtailment penalties to test different operating regimes and uncertainty propagation behaviors.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import truncnorm, beta as scipy_beta, t as student_t\n\ndef monte_carlo_dispatch_cost(\n    G_max, a, b, lambda_s, lambda_c,\n    mu_D, sigma_D, R_max, alpha_beta, beta_beta,\n    N, B, alpha_CI, seed\n):\n    \"\"\"\n    Perform Monte Carlo sampling for dispatch cost under uncertainty and compute\n    mean, variance, and confidence intervals.\n\n    Parameters:\n        G_max (float): Generator capacity (MW).\n        a (float): Quadratic cost coefficient ($/MW^2).\n        b (float): Linear cost coefficient ($/MW).\n        lambda_s (float): Shortage penalty (Value of Lost Load) ($/MW).\n        lambda_c (float): Curtailment penalty ($/MW).\n        mu_D (float): Mean of demand (MW).\n        sigma_D (float): Standard deviation of demand (MW).\n        R_max (float): Maximum renewable availability (MW).\n        alpha_beta (float): Alpha parameter of Beta distribution for renewable CF.\n        beta_beta (float): Beta parameter of Beta distribution for renewable CF.\n        N (int): Monte Carlo sample size.\n        B (int): Number of bootstrap resamples for variance CI.\n        alpha_CI (float): Significance level for confidence intervals.\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        list: [mean, variance, mean_CI_lower, mean_CI_upper, var_CI_lower, var_CI_upper],\n              all rounded to two decimals.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # Sample demand: truncated normal at D >= 0\n    a_trunc = (0 - mu_D) / sigma_D\n    b_trunc = np.inf\n    D = truncnorm.rvs(a=a_trunc, b=b_trunc, loc=mu_D, scale=sigma_D, size=N, random_state=rng)\n\n    # Sample renewable: R = R_max * X, X ~ Beta(alpha_beta, beta_beta)\n    X = scipy_beta.rvs(alpha_beta, beta_beta, size=N, random_state=rng)\n    R = R_max * X\n\n    # Net load and constrained quantities\n    L = D - R\n    pos_net_load = np.maximum(L, 0.0)\n    g = np.minimum(pos_net_load, G_max)\n    U = np.maximum(pos_net_load - G_max, 0.0)\n    C_c = np.maximum(R - D, 0.0)\n\n    # Cost computation\n    C_th = a * g**2 + b * g\n    C = C_th + lambda_s * U + lambda_c * C_c\n\n    # Estimators\n    mean_est = float(np.mean(C))\n    # Unbiased sample variance (ddof=1)\n    var_est = float(np.var(C, ddof=1))\n    std_est = float(np.sqrt(var_est))\n\n    # Mean CI via Student's t\n    df = N - 1\n    tcrit = float(student_t.ppf(1.0 - alpha_CI / 2.0, df))\n    half_width_mean = tcrit * std_est / np.sqrt(N)\n    mean_CI_lower = mean_est - half_width_mean\n    mean_CI_upper = mean_est + half_width_mean\n\n    # Variance CI via nonparametric bootstrap\n    # Resample indices and compute unbiased variance for each bootstrap replicate\n    boot_vars = np.empty(B, dtype=float)\n    for b_idx in range(B):\n        idx = rng.integers(low=0, high=N, size=N, endpoint=False)\n        C_b = C[idx]\n        boot_vars[b_idx] = float(np.var(C_b, ddof=1))\n\n    lower_q = 100.0 * (alpha_CI / 2.0)\n    upper_q = 100.0 * (1.0 - alpha_CI / 2.0)\n    var_CI_lower = float(np.percentile(boot_vars, lower_q, interpolation='linear'))\n    var_CI_upper = float(np.percentile(boot_vars, upper_q, interpolation='linear'))\n\n    # Round to two decimals\n    def r2(x): return float(np.round(x, 2))\n    return [r2(mean_est), r2(var_est), r2(mean_CI_lower), r2(mean_CI_upper), r2(var_CI_lower), r2(var_CI_upper)]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (general case)\n        {\n            \"G_max\": 900.0, \"a\": 0.01, \"b\": 20.0,\n            \"lambda_s\": 10000.0, \"lambda_c\": 5.0,\n            \"mu_D\": 1000.0, \"sigma_D\": 100.0,\n            \"R_max\": 800.0, \"alpha_beta\": 3.0, \"beta_beta\": 2.0,\n            \"N\": 20000, \"B\": 300, \"alpha_CI\": 0.05, \"seed\": 42\n        },\n        # Case B (boundary shortage-sensitive)\n        {\n            \"G_max\": 900.0, \"a\": 0.01, \"b\": 20.0,\n            \"lambda_s\": 20000.0, \"lambda_c\": 0.0,\n            \"mu_D\": 900.0, \"sigma_D\": 50.0,\n            \"R_max\": 600.0, \"alpha_beta\": 2.0, \"beta_beta\": 6.0,\n            \"N\": 15000, \"B\": 250, \"alpha_CI\": 0.10, \"seed\": 123\n        },\n        # Case C (high renewable with curtailment penalties)\n        {\n            \"G_max\": 700.0, \"a\": 0.01, \"b\": 20.0,\n            \"lambda_s\": 15000.0, \"lambda_c\": 50.0,\n            \"mu_D\": 700.0, \"sigma_D\": 150.0,\n            \"R_max\": 1000.0, \"alpha_beta\": 5.0, \"beta_beta\": 2.0,\n            \"N\": 12000, \"B\": 250, \"alpha_CI\": 0.05, \"seed\": 7\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        res = monte_carlo_dispatch_cost(**case)\n        results.append(res)\n\n    # Format as required: single line, comma-separated list of lists, rounded to two decimals.\n    # Build string representation with two-decimal formatting.\n    inner_strs = []\n    for res in results:\n        inner = \"[\" + \",\".join(f\"{x:.2f}\" for x in res) + \"]\"\n        inner_strs.append(inner)\n    print(f\"[{','.join(inner_strs)}]\")\n\nsolve()\n```"
        }
    ]
}