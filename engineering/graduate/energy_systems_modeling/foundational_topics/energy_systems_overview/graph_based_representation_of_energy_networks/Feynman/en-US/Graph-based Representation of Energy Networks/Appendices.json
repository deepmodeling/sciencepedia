{
    "hands_on_practices": [
        {
            "introduction": "The nodal admittance matrix, or $Y_{\\text{bus}}$, is a cornerstone of AC power system analysis. While simple transmission lines have straightforward representations, real-world components like tap-changing transformers require a more careful derivation from first principles to be correctly incorporated into the graph model. This practice  challenges you to derive the admittance model for an off-nominal transformer and implement it to solve for network voltages, reinforcing the deep connection between fundamental circuit laws and the matrix representation of the network.",
            "id": "4094408",
            "problem": "Consider a connected Alternating Current (AC) energy network represented as a directed graph with buses as nodes and components (lines and transformers) as edges. The network is modeled in per-unit (p.u.) and obeys Kirchhoff's Current Law (KCL) and Ohm's law. Each branch is represented by a series impedance and, where applicable, a shunt admittance. A tap-changing ideal transformer is represented by a complex off-nominal tap ratio that modifies the relation between bus voltages and branch currents. The nodal admittance matrix is constructed from these branch models. The nodal equations are linear in current injection variables.\n\nStarting from the fundamental base of Kirchhoff's Current Law (KCL), Ohm's law, and the per-unit representation of network components, you must derive the nodal admittance matrix contributions for:\n- a standard transmission line modeled by the symmetric $\\pi$-model with series impedance, and\n- an ideal transformer with complex off-nominal tap located on the \"from\" side of the branch, including the effect of taps on the admittance seen at the buses.\n\nThen, implement the derived expressions to assemble the nodal admittance matrix and solve for the unknown bus voltages given specified current injections and known slack bus voltage, strictly relying on KCL and Ohm's law. Your program must be complete and runnable, perform all calculations in per-unit (dimensionless), and use radians for angles.\n\nNetwork specification:\n- Buses: $\\{1,2,3\\}$.\n- Slack bus voltage: $V_1 = 1 \\angle 0$ p.u.\n- Current injections: $I_2 = -0.50 - j\\,0.20$ p.u., $I_3 = -0.30 - j\\,0.10$ p.u. These are independent current sources/sinks defined in per-unit, and do not depend on bus voltage magnitudes.\n- Branch $1 \\leftrightarrow 2$ is an ideal transformer with series impedance $z_{12} = 0.01 + j\\,0.05$ p.u. and complex off-nominal tap ratio $t = a\\,e^{j\\theta}$ located on the bus $1$ side. There is no shunt admittance on this branch other than what arises from the series branch modeling; magnetizing admittance is neglected.\n- Branch $2 \\leftrightarrow 3$ is a transmission line modeled as a symmetric $\\pi$-model with series impedance $z_{23} = 0.015 + j\\,0.06$ p.u. and total shunt admittance $y_{sh,23} = j\\,0.002$ p.u., split equally as $y_{sh,23}/2$ at each end.\n\nTasks:\n1. Using Kirchhoff's Current Law (KCL) and Ohm's law, derive the nodal admittance matrix contributions for a general branch between buses $k$ and $m$ for:\n   - a line with series impedance and symmetric shunt admittance (no tap), and\n   - an ideal transformer with off-nominal complex tap $t = a\\,e^{j\\theta}$ on the bus $k$ side, including the effect of the tap on the admittance seen at the buses. You must not assume or use any pre-compiled transformer formulas; derive the transformer effect from the voltage-current relations of an ideal transformer and the series admittance, then translate these relations to nodal admittance contributions consistent with KCL.\n2. Assemble the full nodal admittance matrix $Y$ for the network using your derived expressions. Use complex numbers and per-unit quantities consistently.\n3. Solve for the unknown bus voltages $V_2$ and $V_3$ from the linear nodal equation $I = YV$ by partitioning the system with the known slack bus voltage $V_1$. Express the solution procedure clearly and implement it in code.\n4. For each test case, compute the magnitude $\\lvert V_3 \\rvert$ in per-unit.\n\nTest suite (angles in radians):\n- Case $A$: $a = 1.00$, $\\theta = 0$.\n- Case $B$: $a = 0.95$, $\\theta = 0$.\n- Case $C$: $a = 1.00$, $\\theta = \\pi/12$.\n- Case $D$: $a = 1.10$, $\\theta = -\\pi/6$.\n\nAnswer specification:\n- Use radians for angles.\n- Express all outputs in per-unit (dimensionless).\n- For each test case, return the float value of $\\lvert V_3 \\rvert$ rounded to six decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, `[result1,result2,result3,result4]`), in the order of cases $A$, $B$, $C$, $D$.",
            "solution": "The problem requires the derivation of nodal admittance matrix elements for two types of AC network components, the assembly of the network's nodal admittance matrix $Y$, and the solution of the resulting linear system $I = YV$ for unknown bus voltages. The entire procedure must be grounded in Kirchhoff's Current Law (KCL) and Ohm's law.\n\nFirst, the validity of the problem is established.\n-   **Givens Extracted**:\n    -   Network: $3$ buses, connected, AC.\n    -   Slack Bus: Bus $1$, with voltage $V_1 = 1 \\angle 0$ p.u. ($1+j0$).\n    -   Current Injections: $I_2 = -0.50 - j\\,0.20$ p.u., $I_3 = -0.30 - j\\,0.10$ p.u.\n    -   Branch $1 \\leftrightarrow 2$: Ideal transformer with series impedance $z_{12} = 0.01 + j\\,0.05$ p.u., complex off-nominal tap ratio $t = a\\,e^{j\\theta}$ on the bus $1$ side. No magnetizing admittance.\n    -   Branch $2 \\leftrightarrow 3$: Symmetric $\\pi$-model transmission line with series impedance $z_{23} = 0.015 + j\\,0.06$ p.u. and total shunt admittance $y_{sh,23} = j\\,0.002$ p.u.\n-   **Validation Verdict**: The problem is valid. It is scientifically grounded in fundamental circuit theory and standard power system modeling techniques. It is well-posed, providing a complete and consistent set of data and constraints that allow for a unique solution. The language is objective and unambiguous.\n\nThe solution proceeds in three stages: derivation of component models, assembly of the system matrix, and solution of the linear system.\n\n**1. Nodal Admittance Matrix Contributions from First Principles**\n\nThe nodal admittance formulation is derived from KCL, which states that the sum of currents entering any node (bus) from external sources must equal the sum of currents leaving the node and flowing into the network branches. For any bus $k$, this is expressed as:\n$$I_k = \\sum_{m \\in N_k} I_{k \\to m}$$\nwhere $I_k$ is the current injected into bus $k$, $N_k$ is the set of buses connected to bus $k$, and $I_{k \\to m}$ is the current flowing from bus $k$ towards bus $m$ through the branch connecting them. The goal is to express each branch current $I_{k \\to m}$ as a linear function of the bus voltages, which gives rise to the matrix equation $I = YV$.\n\n**1.1. Symmetric $\\pi$-Model Transmission Line**\n\nConsider a branch between bus $k$ and bus $m$ represented by a symmetric $\\pi$-model. This model consists of a series admittance $y_{km} = 1/z_{km}$ between the buses and a shunt admittance of $y_{sh,km}/2$ connected from each bus to the reference ground. Let $V_k$ and $V_m$ be the complex voltages at bus $k$ and bus $m$, respectively.\n\nThe current leaving bus $k$ and flowing into this branch, $I_{k \\to m}$, has two components:\n1.  The current through the series element, given by Ohm's law: $(V_k - V_m)y_{km}$.\n2.  The current through the shunt element at bus $k$: $V_k (y_{sh,km}/2)$.\n\nSumming these components gives the total current leaving bus $k$ for this branch:\n$$I_{k \\to m} = (V_k - V_m)y_{km} + V_k \\frac{y_{sh,km}}{2} = \\left(y_{km} + \\frac{y_{sh,km}}{2}\\right)V_k - y_{km}V_m$$\nBy symmetry, the current leaving bus $m$ for this branch is:\n$$I_{m \\to k} = (V_m - V_k)y_{km} + V_m \\frac{y_{sh,km}}{2} = \\left(y_{km} + \\frac{y_{sh,km}}{2}\\right)V_m - y_{km}V_k$$\n\nThese expressions relate the injected currents at buses $k$ and $m$ (here, $I_k = I_{k \\to m}$ and $I_m = I_{m \\to k}$, assuming this is the only branch) to the bus voltages. They provide the following contributions to the nodal admittance matrix $Y$:\n-   Diagonal (self-admittance) terms: $Y_{kk}$ and $Y_{mm}$ are increased by $(y_{km} + y_{sh,km}/2)$.\n-   Off-diagonal (mutual admittance) terms: $Y_{km}$ and $Y_{mk}$ are decreased by $y_{km}$.\n$$ \\Delta Y = \\begin{pmatrix} y_{km} + y_{sh,km}/2 & -y_{km} \\\\ -y_{km} & y_{km} + y_{sh,km}/2 \\end{pmatrix} $$\n\n**1.2. Ideal Transformer with Off-Nominal Tap**\n\nConsider a branch between bus $k$ (the \"from\" side) and bus $m$ (the \"to\" side), containing a series impedance $z_{km}$ (admittance $y_{km} = 1/z_{km}$) and an ideal transformer. The transformer has a complex off-nominal tap ratio $t = a e^{j\\theta}$ and is located on the bus $k$ side. Magnetizing admittance is neglected.\n\nAn ideal transformer alters voltage and current. Let the voltage at bus $k$ be $V_k$. The tap changer creates an intermediate voltage $V_k'$ on the other side of the transformer such that $V_k' = V_k / t$. The series impedance $z_{km}$ is placed between this intermediate point $k'$ and bus $m$.\n\nThe current $I'_{k \\to m}$ flowing through the series impedance from $k'$ to $m$ is given by Ohm's law:\n$$I'_{k \\to m} = (V_k' - V_m) y_{km} = \\left(\\frac{V_k}{t} - V_m\\right) y_{km}$$\nFor an ideal power-invariant transformer, the relationship between the current entering the primary, $I_{k \\to m}$, and the current leaving the secondary, $I'_{k \\to m}$, is $I_{k \\to m} = I'_{k \\to m} / t^*$, where $t^*$ is the complex conjugate of $t$. This relationship ensures that complex power is conserved ($S = V_k I_{k \\to m}^* = V_k' (I'_{k \\to m})^*$).\n\nSubstituting the expression for $I'_{k \\to m}$ gives the current leaving bus $k$:\n$$I_{k \\to m} = \\frac{1}{t^*} \\left(\\frac{V_k}{t} - V_m\\right) y_{km} = \\frac{y_{km}}{t t^*} V_k - \\frac{y_{km}}{t^*} V_m = \\frac{y_{km}}{|t|^2} V_k - \\frac{y_{km}}{t^*} V_m$$\nThe current leaving bus $m$, $I_{m \\to k}$, flows directly from bus $m$ towards the intermediate point $k'$:\n$$I_{m \\to k} = (V_m - V_k') y_{km} = \\left(V_m - \\frac{V_k}{t}\\right) y_{km} = - \\frac{y_{km}}{t} V_k + y_{km} V_m$$\n\nThese relations provide the following non-symmetric contributions to the nodal admittance matrix $Y$:\n-   $Y_{kk}$ is increased by $y_{km}/|t|^2$.\n-   $Y_{mm}$ is increased by $y_{km}$.\n-   $Y_{km}$ is decreased by $y_{km}/t^*$.\n-   $Y_{mk}$ is decreased by $y_{km}/t$.\n$$ \\Delta Y = \\begin{pmatrix} y_{km}/|t|^2 & -y_{km}/t^* \\\\ -y_{km}/t & y_{km} \\end{pmatrix} $$\n\n**2. Assembly of the Network Admittance Matrix**\n\nThe full $3 \\times 3$ nodal admittance matrix $Y$ is assembled by initializing a zero matrix and summing the contributions from each branch.\n\n-   **Branch $1 \\leftrightarrow 2$ (Transformer):** $k=1$, $m=2$, $z_{12} = 0.01 + j\\,0.05$, $y_{12} = 1/z_{12}$, tap $t$ on bus $1$ side.\n    -   $Y_{11} \\leftarrow Y_{11} + y_{12}/|t|^2$\n    -   $Y_{22} \\leftarrow Y_{22} + y_{12}$\n    -   $Y_{12} \\leftarrow Y_{12} - y_{12}/t^*$\n    -   $Y_{21} \\leftarrow Y_{21} - y_{12}/t$\n\n-   **Branch $2 \\leftrightarrow 3$ ($\\pi$-model Line):** $k=2$, $m=3$, $z_{23} = 0.015 + j\\,0.06$, $y_{23} = 1/z_{23}$, $y_{sh,23} = j\\,0.002$.\n    -   $Y_{22} \\leftarrow Y_{22} + y_{23} + y_{sh,23}/2$\n    -   $Y_{33} \\leftarrow Y_{33} + y_{23} + y_{sh,23}/2$\n    -   $Y_{23} \\leftarrow Y_{23} - y_{23}$\n    -   $Y_{32} \\leftarrow Y_{32} - y_{23}$\n\nCombining these, the final elements of the $Y$ matrix are:\n$Y_{11} = y_{12}/|t|^2$\n$Y_{12} = -y_{12}/t^*$\n$Y_{13} = 0$\n$Y_{21} = -y_{12}/t$\n$Y_{22} = y_{12} + y_{23} + y_{sh,23}/2$\n$Y_{23} = -y_{23}$\n$Y_{31} = 0$\n$Y_{32} = -y_{23}$\n$Y_{33} = y_{23} + y_{sh,23}/2$\n\n**3. Solving the Nodal Equations**\n\nThe nodal equation is $I = YV$. We partition this system based on known and unknown voltages. Bus $1$ is the slack bus with known voltage $V_1$. Buses $2$ and $3$ are load buses where current injections are known but voltages $V_2$ and $V_3$ are unknown. Let $U = \\{2, 3\\}$ be the set of buses with unknown voltages and $S = \\{1\\}$ be the set of buses with known voltages.\n\nThe partitioned system is:\n$$ \\begin{pmatrix} I_U \\\\ I_S \\end{pmatrix} = \\begin{pmatrix} Y_{UU} & Y_{US} \\\\ Y_{SU} & Y_{SS} \\end{pmatrix} \\begin{pmatrix} V_U \\\\ V_S \\end{pmatrix} $$\nwhere $V_U = \\begin{pmatrix} V_2 \\\\ V_3 \\end{pmatrix}$ and $V_S = \\begin{pmatrix} V_1 \\end{pmatrix}$. The upper part of the matrix equation pertains to the unknown voltages:\n$$ I_U = Y_{UU} V_U + Y_{US} V_S $$\nWe rearrange this to solve for $V_U$:\n$$ Y_{UU} V_U = I_U - Y_{US} V_S $$\nThis is a $2 \\times 2$ linear system of complex equations. The components are:\n-   $I_U = \\begin{pmatrix} I_2 \\\\ I_3 \\end{pmatrix} = \\begin{pmatrix} -0.50 - j\\,0.20 \\\\ -0.30 - j\\,0.10 \\end{pmatrix}$\n-   $V_S = \\begin{pmatrix} V_1 \\end{pmatrix} = \\begin{pmatrix} 1.0 + j\\,0.0 \\end{pmatrix}$\n-   $Y_{UU} = \\begin{pmatrix} Y_{22} & Y_{23} \\\\ Y_{32} & Y_{33} \\end{pmatrix}$\n-   $Y_{US} = \\begin{pmatrix} Y_{21} \\\\ Y_{31} \\end{pmatrix}$\n\nFor each test case, the value of $t = a\\,e^{j\\theta}$ is calculated, the matrix $Y$ is assembled, the system $Y_{UU} V_U = I_U - Y_{US} V_S$ is solved for $V_U$, and the magnitude of the resulting voltage $V_3$ is computed.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the unknown bus voltages in a 3-bus power system\n    for different transformer tap settings.\n    \"\"\"\n\n    # Define the problem parameters as complex numbers\n    V1 = 1.0 + 0.0j\n    I2 = -0.50 - 0.20j\n    I3 = -0.30 - 0.10j\n    \n    z12 = 0.01 + 0.05j\n    z23 = 0.015 + 0.06j\n    ysh23 = 0.002j\n\n    # Pre-calculate branch admittances\n    y12 = 1.0 / z12\n    y23 = 1.0 / z23\n\n    # Define the test cases from the problem statement\n    # Each case is a tuple (a, theta) for the tap ratio t = a * exp(j*theta)\n    test_cases = [\n        (1.00, 0.0),                  # Case A\n        (0.95, 0.0),                  # Case B\n        (1.00, np.pi / 12),           # Case C\n        (1.10, -np.pi / 6),           # Case D\n    ]\n\n    results = []\n    for a, theta in test_cases:\n        # 1. Calculate the complex tap ratio for the current case\n        t = a * np.exp(1j * theta)\n        \n        # 2. Assemble the 3x3 nodal admittance matrix Y\n        Y = np.zeros((3, 3), dtype=np.complex128)\n\n        # Add contributions from Branch 1-2 (Transformer)\n        # k=1 (tap side), m=2\n        Y[0, 0] += y12 / (np.abs(t)**2)\n        Y[1, 1] += y12\n        Y[0, 1] += -y12 / np.conjugate(t)\n        Y[1, 0] += -y12 / t\n\n        # Add contributions from Branch 2-3 (pi-model line)\n        # k=2, m=3\n        Y[1, 1] += y23 + ysh23 / 2.0\n        Y[2, 2] += y23 + ysh23 / 2.0\n        Y[1, 2] += -y23\n        Y[2, 1] += -y23 # same as Y[1,2] since it's a symmetric line\n\n        # 3. Partition the system to solve for unknown voltages V2 and V3\n        # The system is Y_UU * V_U = I_U - Y_US * V_S\n        # Bus 1 is the slack bus (S), buses 2 and 3 have unknown voltages (U)\n        \n        # Y_UU is the submatrix for unknown voltage buses (2, 3)\n        Y_UU = Y[1:3, 1:3]\n        \n        # Y_US is the submatrix coupling unknown and slack buses\n        Y_US = Y[1:3, 0].reshape(2, 1)\n\n        # I_U is the vector of known current injections at buses 2 and 3\n        I_U = np.array([I2, I3])\n        \n        # V_S is the known slack bus voltage V1\n        V_S = np.array([V1]) # As a 1x1 vector\n\n        # Calculate the right-hand side of the linear equation\n        RHS = I_U - (Y_US @ V_S).flatten()\n        \n        # 4. Solve the linear system for the unknown voltages V_U = [V2, V3]\n        V_U = np.linalg.solve(Y_UU, RHS)\n        \n        # Extract V3 from the solution vector\n        V3 = V_U[1]\n        \n        # 5. Compute the magnitude of V3 and round to six decimal places\n        magnitude_V3 = np.abs(V3)\n        results.append(round(magnitude_V3, 6))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "For large-scale planning and economic analysis, a full AC power flow can be computationally intensive, so linearized models are essential. The DC power flow approximation provides a powerful tool by framing the analysis as a linear problem on the network graph. This exercise  guides you through implementing the DC power flow using a pure graph-theoretic framework, where the weighted Laplacian matrix relates power injections to phase angles, enabling rapid and insightful system-wide studies.",
            "id": "4094429",
            "problem": "Consider an energy transmission network represented as a connected, directed graph $G = (\\mathcal{V}, \\mathcal{E})$ where $\\mathcal{V}$ is the set of buses (nodes) and $\\mathcal{E}$ is the set of transmission lines (edges). Each edge $(i,j) \\in \\mathcal{E}$ is oriented from bus $i$ to bus $j$, has a known series reactance $x_{ij} > 0$ (in per unit on a common base), and is modeled as a lossless inductive element. The network operates in sinusoidal steady-state under the following assumptions of the Direct Current (DC) approximation of Alternating Current (AC) power flow:\n- Bus voltage magnitudes are approximately uniform and fixed at $\\lvert V_i \\rvert \\approx 1$ per unit for all $i \\in \\mathcal{V}$.\n- Angle differences between buses satisfy $\\lvert\\theta_i - \\theta_j\\rvert \\ll 1$ radians, so $\\sin(\\theta_i - \\theta_j) \\approx \\theta_i - \\theta_j$.\n- Line resistances and shunt elements are negligible compared to reactances.\n- Real power injection at a bus equals the algebraic sum of the oriented real power flows on incident lines, consistent with Kirchhoff’s Current Law (KCL) and Kirchhoff’s Voltage Law (KVL).\n\nUnder these assumptions, use the graph-based formulation in which the incidence matrix encodes edge orientations and the weighted Laplacian encodes line reactances to derive and implement the linear DC power flow. Impose a slack bus with specified index whose phase angle is fixed to $0$ radians. Express all bus phase angles in radians. Express all line flows in megawatts (MW). Use a common base power $S_{\\text{base}}$ in MW to convert between per unit and physical units, namely $P_{\\text{MW}} = P_{\\text{p.u.}} \\cdot S_{\\text{base}}$ and $F_{\\text{MW}} = F_{\\text{p.u.}} \\cdot S_{\\text{base}}$.\n\nWrite a complete, runnable program that:\n- Constructs the incidence matrix from the oriented edges and forms the appropriate weighted Laplacian using line reactances.\n- Solves the linear system for bus phase angles $\\theta_i$ with the slack bus angle fixed at $0$ radians.\n- Computes the oriented line flows $F_{ij}$ in MW for each edge $(i,j) \\in \\mathcal{E}$ using the DC approximation, with positive flow defined in the edge’s orientation.\n- Checks thermal limit compliance for each edge: a limit is considered violated if $\\lvert F_{ij} \\rvert$ is strictly greater than the specified limit $L_{ij}$ in MW. Equality $\\lvert F_{ij} \\rvert = L_{ij}$ is not a violation.\n- Produces a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must be a list of three elements: the list of bus angles in radians ordered by ascending bus index, the list of line flows in MW ordered by the given edge list, and a boolean flag indicating whether any line limit is violated.\n\nAngle unit: radians. Power unit: MW. The program must produce outputs in these units.\n\nUse the following test suite, which covers a general case, a boundary condition, and an edge case:\n\n- Test Case $1$ (three-bus chain, happy path):\n  - Buses: $\\{1,2,3\\}$.\n  - Edges and reactances (per unit): $(1,2)$ with $x_{12} = 0.2$, $(2,3)$ with $x_{23} = 0.25$.\n  - Oriented edges in order: $(1,2)$, $(2,3)$.\n  - Net injections in MW: $[50, -30, -20]$.\n  - Slack bus index: $1$.\n  - Base power: $S_{\\text{base}} = 100$ MW.\n  - Line limits in MW: $[100, 100]$.\n\n- Test Case $2$ (four-bus ring, includes boundary equality on limits and a violation):\n  - Buses: $\\{1,2,3,4\\}$.\n  - Edges and reactances (per unit): $(1,2)$ with $x_{12} = 0.1$, $(2,3)$ with $x_{23} = 0.2$, $(3,4)$ with $x_{34} = 0.3$, $(4,1)$ with $x_{41} = 0.4$.\n  - Oriented edges in order: $(1,2)$, $(2,3)$, $(3,4)$, $(4,1)$.\n  - Net injections in MW: $[0, 60, -30, -30]$.\n  - Slack bus index: $1$.\n  - Base power: $S_{\\text{base}} = 100$ MW.\n  - Line limits in MW: $[21, 30, 9, 21]$.\n\n- Test Case $3$ (two-bus single line, edge case with zero injections):\n  - Buses: $\\{1,2\\}$.\n  - Edge and reactance (per unit): $(1,2)$ with $x_{12} = 0.5$.\n  - Oriented edge in order: $(1,2)$.\n  - Net injections in MW: $[0, 0]$.\n  - Slack bus index: $1$.\n  - Base power: $S_{\\text{base}} = 100$ MW.\n  - Line limit in MW: $[10]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3]$), where each $resultk$ is of the form $[\\text{angles}, \\text{flows}, \\text{violation}]$ as specified.",
            "solution": "The problem statement is evaluated for validity prior to attempting a solution.\n\n### Step 1: Extract Givens\n- **Network Model**: A connected, directed graph $G = (\\mathcal{V}, \\mathcal{E})$ representing an energy transmission network.\n- **Nodes**: $\\mathcal{V}$ is the set of buses.\n- **Edges**: $\\mathcal{E}$ is the set of oriented transmission lines from bus $i$ to bus $j$.\n- **Edge Properties**: Each edge $(i,j)$ has a series reactance $x_{ij} > 0$ (per unit) and is modeled as a lossless inductor.\n- **Operating Assumptions (DC Power Flow)**:\n    - Bus voltage magnitudes $\\lvert V_i \\rvert \\approx 1$ p.u. for all $i \\in \\mathcal{V}$.\n    - Small angle differences $\\lvert\\theta_i - \\theta_j\\rvert \\ll 1$ radians, allowing the approximation $\\sin(\\theta_i - \\theta_j) \\approx \\theta_i - \\theta_j$.\n    - Line resistances and shunt elements are negligible.\n- **Conservation Law**: Real power injection at a bus equals the algebraic sum of oriented real power flows on incident lines.\n- **Required Formulation**: A graph-based formulation using an incidence matrix and a weighted Laplacian.\n- **Boundary Condition**: A slack bus with a specified index has its phase angle fixed at $\\theta_{\\text{slack}} = 0$ radians.\n- **Unit Conversion**: Base power $S_{\\text{base}}$ in MW is used to convert between per unit (p.u.) and physical units: $P_{\\text{MW}} = P_{\\text{p.u.}} \\cdot S_{\\text{base}}$ and $F_{\\text{MW}} = F_{\\text{p.u.}} \\cdot S_{\\text{base}}$.\n- **Output Requirements**:\n    1.  A list of bus phase angles $\\theta_i$ in radians, ordered by bus index.\n    2.  A list of oriented line flows $F_{ij}$ in MW, ordered by the input edge list.\n    3.  A boolean flag indicating if any line limit is violated, where a violation is defined as $\\lvert F_{ij} \\rvert > L_{ij}$.\n- **Test Cases**: Three specific test cases are provided with all necessary parameters (network topology, reactances, power injections, slack bus, base power, line limits).\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on the Direct Current (DC) power flow approximation, a standard and fundamental analysis tool in power systems engineering. The assumptions and the graph-based formulation are textbook material. This is scientifically sound.\n- **Well-Posed**: The problem is well-posed. For a connected network, specifying a slack bus (a reference angle) makes the system of linear equations for the remaining bus angles non-singular, guaranteeing a unique solution. All necessary data is provided for each test case.\n- **Objective**: The problem is stated using precise, objective, and quantitative language. The goals are clear and unambiguous.\n- **Completeness and Consistency**: The setup is complete. For each test case, the number of buses, the oriented edges, their reactances, the net power injections at all buses, the slack bus, the base power, and the line thermal limits are all specified. There are no contradictions.\n- **Feasibility**: The numerical values given for reactances, power injections, and limits are within realistic ranges for power system studies.\n\n### Step 3: Verdict and Action\nThe problem is **valid** as it is scientifically sound, well-posed, and complete. A solution will be developed based on the specified graph-theoretic principles.\n\n### Solution Derivation\nThe DC power flow model provides a linearized relationship between real power injections, bus phase angles, and line flows. The derivation proceeds as follows:\n\n1.  **Line Power Flow**: Under the DC approximation assumptions, the real power flow $F_{ij}$ from bus $i$ to bus $j$ along a line with reactance $x_{ij}$ is given by:\n    $$F_{ij}^{\\text{p.u.}} = \\frac{\\lvert V_i \\rvert \\lvert V_j \\rvert}{x_{ij}}\\sin(\\theta_i - \\theta_j) \\approx \\frac{1 \\cdot 1}{x_{ij}}(\\theta_i - \\theta_j) = b_{ij}(\\theta_i - \\theta_j)$$\n    where $b_{ij} = 1/x_{ij}$ is the susceptance of the line in per unit (p.u.).\n\n2.  **Bus Power Balance**: The net real power injection $P_i$ at any bus $i$ is the sum of real power flows leaving the bus on all connected lines.\n    $$P_i^{\\text{p.u.}} = \\sum_{j \\text{ adjacent to } i} F_{ij}^{\\text{p.u.}} = \\sum_{j \\text{ adjacent to } i} b_{ij}(\\theta_i - \\theta_j)$$\n    This can be rewritten as a set of linear equations, one for each bus.\n\n3.  **Graph-Theoretic Matrix Formulation**: This system of equations can be elegantly expressed using graph theory. Let the graph have $N_b = |\\mathcal{V}|$ buses and $N_e = |\\mathcal{E}|$ edges.\n    - **Incidence Matrix ($\\mathbf{A}$)**: An $N_b \\times N_e$ matrix that captures the graph topology and edge orientations. For the $k$-th edge, oriented from bus $i$ to bus $j$:\n      $$A_{mk} = \\begin{cases} +1 & \\text{if } m=i \\text{ (source bus)} \\\\ -1 & \\text{if } m=j \\text{ (target bus)} \\\\ 0 & \\text{otherwise} \\end{cases}$$\n    - **Edge Susceptance Matrix ($\\mathbf{W}$)**: An $N_e \\times N_e$ diagonal matrix whose diagonal entries are the line susceptances, $W_{kk} = b_k = 1/x_k$.\n    - **Bus Admittance Matrix ($\\mathbf{B}$)**: The relationship between the vector of bus power injections $\\mathbf{P}^{\\text{p.u.}}$ and the vector of bus phase angles $\\boldsymbol{\\theta}$ is given by $\\mathbf{P}^{\\text{p.u.}} = \\mathbf{B}\\boldsymbol{\\theta}$. The bus admittance matrix $\\mathbf{B}$ for the DC model is equivalent to the weighted graph Laplacian, $\\mathbf{L}_w$:\n      $$\\mathbf{B} = \\mathbf{A} \\mathbf{W} \\mathbf{A}^T$$\n      The elements of $\\mathbf{B}$ are:\n      - $B_{ii} = \\sum_{k \\text{ incident to } i} b_k$ (sum of susceptances of lines connected to bus $i$)\n      - $B_{ij} = -b_{ij}$ for $i \\neq j$ if a line exists between buses $i$ and $j$.\n\n4.  **Solving the System**: The matrix $\\mathbf{B}$ is singular, reflecting that only angle differences are physically determined. By setting one bus as the slack bus (say, bus $s$) and fixing its angle $\\theta_s = 0$, we provide a reference. This removes one unknown ($\\theta_s$) and one equation (the power balance at bus $s$, which becomes a dependent equation). The system is reduced by removing the row and column corresponding to the slack bus from $\\mathbf{B}$, and the corresponding entry from $\\mathbf{P}^{\\text{p.u.}}$. Let the reduced quantities be denoted by the subscript 'red'.\n    $$\\mathbf{P}_{\\text{red}}^{\\text{p.u.}} = \\mathbf{B}_{\\text{red}} \\boldsymbol{\\theta}_{\\text{red}}$$\n    Since $\\mathbf{B}_{\\text{red}}$ is invertible for a connected graph, the unknown non-slack angles $\\boldsymbol{\\theta}_{\\text{red}}$ can be found by solving this linear system:\n    $$\\boldsymbol{\\theta}_{\\text{red}} = \\mathbf{B}_{\\text{red}}^{-1} \\mathbf{P}_{\\text{red}}^{\\text{p.u.}}$$\n    The full vector of angles $\\boldsymbol{\\theta}$ is then assembled from $\\boldsymbol{\\theta}_{\\text{red}}$ and $\\theta_s=0$. All angles are in radians.\n\n5.  **Calculating Line Flows**: Once all bus angles are known, the oriented power flow on each line can be calculated. The vector of angle differences across all edges, respecting their orientation, is $\\Delta\\boldsymbol{\\theta} = \\mathbf{A}^T \\boldsymbol{\\theta}$. The vector of line flows in p.u. is then:\n    $$\\mathbf{F}^{\\text{p.u.}} = \\mathbf{W} (\\mathbf{A}^T \\boldsymbol{\\theta})$$\n    To obtain the flows in megawatts (MW), each element is multiplied by the base power $S_{\\text{base}}$:\n    $$\\mathbf{F}^{\\text{MW}} = S_{\\text{base}} \\cdot \\mathbf{F}^{\\text{p.u.}}$$\n\n6.  **Thermal Limit Check**: For each line $k$, the absolute value of the flow, $\\lvert F_k^{\\text{MW}} \\rvert$, is compared to its thermal limit $L_k^{\\text{MW}}$. If $\\lvert F_k^{\\text{MW}} \\rvert > L_k^{\\text{MW}}$ for any line, a violation has occurred.\n\nThis structured, principle-based approach will be implemented to solve the given test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of DC power flow problems using a graph-based formulation.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"buses\": [1, 2, 3],\n            \"edges\": [(1, 2), (2, 3)],\n            \"reactances\": [0.2, 0.25],\n            \"injections_mw\": [50, -30, -20],\n            \"slack_bus_index\": 1,\n            \"base_power\": 100.0,\n            \"line_limits_mw\": [100, 100],\n        },\n        {\n            \"buses\": [1, 2, 3, 4],\n            \"edges\": [(1, 2), (2, 3), (3, 4), (4, 1)],\n            \"reactances\": [0.1, 0.2, 0.3, 0.4],\n            \"injections_mw\": [0, 60, -30, -30],\n            \"slack_bus_index\": 1,\n            \"base_power\": 100.0,\n            \"line_limits_mw\": [21, 30, 9, 21],\n        },\n        {\n            \"buses\": [1, 2],\n            \"edge\": [(1, 2)],\n            \"reactances\": [0.5],\n            \"injections_mw\": [0, 0],\n            \"slack_bus_index\": 1,\n            \"base_power\": 100.0,\n            \"line_limits_mw\": [10],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        num_buses = len(case[\"buses\"])\n        edges = case.get(\"edges\") or case.get(\"edge\") # Handle alternate key\n        num_edges = len(edges)\n        reactances = np.array(case[\"reactances\"], dtype=float)\n        injections_mw = np.array(case[\"injections_mw\"], dtype=float)\n        slack_bus_id = case[\"slack_bus_index\"]\n        s_base = case[\"base_power\"]\n        limits_mw = np.array(case[\"line_limits_mw\"], dtype=float)\n        \n        # 1. Convert to 0-based index for arrays\n        slack_idx_0based = slack_bus_id - 1\n\n        # 2. Build Incidence Matrix A (num_buses x num_edges)\n        A = np.zeros((num_buses, num_edges), dtype=float)\n        for k, (i, j) in enumerate(edges):\n            A[i - 1, k] = 1.0\n            A[j - 1, k] = -1.0\n        \n        # 3. Build Susceptance Diagonal Matrix W (num_edges x num_edges)\n        susceptances = 1.0 / reactances\n        W = np.diag(susceptances)\n        \n        # 4. Build Bus Admittance Matrix B (num_buses x num_buses)\n        # B is the weighted graph Laplacian: B = A * W * A^T\n        B = A @ W @ A.T\n\n        # 5. Convert power injections to per unit\n        P_pu = injections_mw / s_base\n        \n        # 6. Create the reduced system for non-slack buses\n        all_indices = np.arange(num_buses)\n        non_slack_indices = np.delete(all_indices, slack_idx_0based)\n        \n        B_red = B[np.ix_(non_slack_indices, non_slack_indices)]\n        P_pu_red = P_pu[non_slack_indices]\n        \n        # 7. Solve for non-slack bus angles\n        # B_red * theta_red = P_pu_red\n        theta_red = np.linalg.solve(B_red, P_pu_red)\n        \n        # 8. Reconstruct the full vector of bus angles (in radians)\n        theta = np.zeros(num_buses, dtype=float)\n        theta[non_slack_indices] = theta_red\n        # The slack bus angle theta[slack_idx_0based] is already 0.0\n\n        # 9. Calculate oriented line flows in MW\n        # Angle differences: delta_theta = A^T * theta\n        # Flows (p.u.): F_pu = W * delta_theta\n        # Flows (MW): F_mw = F_pu * S_base\n        flows_pu = W @ A.T @ theta\n        flows_mw = flows_pu * s_base\n\n        # 10. Check for thermal limit violations\n        # Violation if |flow| > limit. Equality is not a violation.\n        is_violated = bool(np.any(np.abs(flows_mw) > limits_mw))\n\n        # 11. Store results in the specified format\n        result = [\n            np.round(theta, 12).tolist(), \n            np.round(flows_mw, 12).tolist(), \n            is_violated\n        ]\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list is \"[item1, item2, ...]\",\n    # which matches the required nested list format for each result.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A central challenge in operating a modern power grid is maintaining full situational awareness, a property known as network observability. This practice  translates the physical problem of sensor placement into a combinatorial optimization problem on the network graph. You will develop an algorithm to determine the minimum number of Phasor Measurement Units (PMUs) required to solve the system state, exploring a practical design problem that relies on graph traversal and logical inference rules.",
            "id": "4094414",
            "problem": "Consider an undirected, simple graph $G = (V,E)$ representing a transmission-level power network, where $V$ is a finite set of buses and $E$ is a finite set of undirected branches. A Phasor Measurement Unit (PMU) is a device that, when installed at a bus $v \\in V$, measures the complex voltage phasor $V_v$ at $v$ and the complex current phasors $I_{v,u}$ on all incident branches $(v,u) \\in E$. The objective is to determine a minimum-cardinality PMU placement that guarantees full network observability, meaning the complex voltage phasor $V_v$ is determinable for every $v \\in V$, under the standard assumptions of linearized network equations and known line admittances.\n\nThe fundamental base is Kirchhoff's Current Law (KCL), which states that for any bus $v \\in V$, the algebraic sum of currents flowing into the bus equals the net injection. In particular, at a zero injection bus $z \\in Z \\subseteq V$, the sum of currents is zero:\n$$\n\\sum_{u \\in N(z)} I_{z,u} = 0,\n$$\nwhere $N(z)$ denotes the neighbor set of $z$. If the complex current phasors on all but one incident branch of a zero injection bus are known, the remaining branch current is inferable by KCL. If a branch’s complex current and one endpoint’s complex voltage are known, the other endpoint’s complex voltage is inferable using the branch admittance relation. This leads to graph-based observability rules derivable from the physics.\n\nDefine the following graph-based rules for observability closure, which are the only rules to be used by your program:\n- Direct measurement rule: If a PMU is placed at $v \\in V$, then $v$ and all $u \\in N(v)$ are observed.\n- Zero injection inference rule: If a zero injection bus $z \\in Z$ is observed, and exactly one neighbor $u \\in N(z)$ is not yet observed, then $u$ becomes observed by KCL-based inference.\n\nA bus is observed if its complex voltage phasor $V_v$ is determinable by the rules above. Full observability means all buses in $V$ are observed.\n\nYou are given multiple test cases. For each test case, you must compute the lexicographically smallest minimum-cardinality set of additional PMU placements $P_{\\mathrm{add}} \\subseteq V \\setminus P_0$ that, when combined with any pre-installed PMUs $P_0 \\subseteq V$, yields full observability under the rules stated. Lexicographic order is taken over ascending lists of bus indices. If $P_0 = \\varnothing$, then $P_{\\mathrm{add}}$ is the minimum-cardinality PMU placement set.\n\nAll buses are indexed by nonnegative integers, and all sets must be represented as ascending lists of these integers. There are no physical units to report in the answer.\n\nTest Suite:\n- Case A (path graph without zero injection inference): \n  $V = \\{0,1,2,3,4,5\\}$, \n  $E = \\{(0,1),(1,2),(2,3),(3,4),(4,5)\\}$, \n  $Z = \\varnothing$, \n  $P_0 = \\varnothing$. \n  Compute $P_{\\mathrm{add}}$.\n- Case B (path graph with zero injection inference at interior buses): \n  $V = \\{0,1,2,3,4,5\\}$, \n  $E = \\{(0,1),(1,2),(2,3),(3,4),(4,5)\\}$, \n  $Z = \\{1,2,3,4\\}$, \n  $P_0 = \\varnothing$. \n  Compute $P_{\\mathrm{add}}$.\n- Case C (star graph with a pre-installed PMU at a leaf): \n  $V = \\{0,1,2,3,4\\}$, \n  $E = \\{(0,1),(0,2),(0,3),(0,4)\\}$, \n  $Z = \\varnothing$, \n  $P_0 = \\{1\\}$. \n  Compute $P_{\\mathrm{add}}$.\n- Case D (graph with an isolated bus): \n  $V = \\{0,1,2\\}$, \n  $E = \\{(0,1)\\}$, \n  $Z = \\varnothing$, \n  $P_0 = \\varnothing$. \n  Compute $P_{\\mathrm{add}}$.\n\nAlgorithmic constraints:\n- Your program must search over candidate additional PMU placements and select a minimum-cardinality set that achieves full observability, breaking ties by lexicographic order on ascending lists of indices.\n- The observability closure must be computed strictly by iterating the two rules above until a fixed point is reached, and then checking whether all buses are observed.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is an ascending list of bus indices for $P_{\\mathrm{add}}$ in the corresponding test case. The output must contain no spaces. For example, for three results $R_1$, $R_2$, and $R_3$, the line should be of the form $[R_1,R_2,R_3]$ with $R_i$ represented as lists like $[0,2,5]$.",
            "solution": "The problem posed is to determine the lexicographically smallest, minimum-cardinality set of additional Phasor Measurement Unit (PMU) placements, denoted $P_{\\mathrm{add}}$, required to achieve full network observability. The network is represented as an undirected graph $G = (V,E)$, where $V$ is the set of buses and $E$ is the set of branches. The problem is well-defined, scientifically grounded in power systems engineering, and possesses a unique solution under the given constraints. It is a variant of the set cover or dominating set problem, augmented with specific inference rules.\n\nThe solution strategy involves a systematic search over the space of all possible additional PMU placements. Since the objective is to first minimize the cardinality of $P_{\\mathrm{add}}$ and then select the lexicographically smallest set, the search is structured accordingly. We iterate on the size of the additional placement set, $k = |P_{\\mathrm{add}}|$, starting from $k=0$ and incrementing until a solution is found. For each value of $k$, we generate all possible combinations of $k$ buses chosen from the set of available buses $V \\setminus P_0$. By generating these combinations in lexicographical order, the first combination that yields full network observability is guaranteed to be the lexicographically smallest solution of the minimum possible cardinality.\n\nFor each candidate set of total PMU placements, $P = P_0 \\cup P_{\\mathrm{add\\_candidate}}$, we must verify if it results in full observability. This is accomplished by computing the observability closure, which is the complete set of buses whose voltage phasors can be determined. The closure is computed by applying the two given rules iteratively until a fixed point is reached—that is, until no new buses can be observed.\n\nThe observability closure algorithm proceeds as follows:\n1.  **Initialization (Direct Measurement Rule)**: An initial set of observed buses, $O$, is formed. For each bus $v$ where a PMU is placed ($v \\in P$), bus $v$ itself and all buses in its neighborhood, $N(v)$, are added to the set $O$. This is expressed by the rule: if $v \\in P$, then $\\{v\\} \\cup N(v) \\subseteq O$.\n\n2.  **Iterative Inference (Zero Injection Inference Rule)**: The algorithm enters an iterative loop. In each iteration, it examines every zero injection bus $z \\in Z$. If $z$ is in the current set of observed buses $O$, the algorithm checks its neighbors. If exactly one neighbor, say $u \\in N(z)$, is not yet in $O$, then $u$ becomes observed and is added to a temporary set of newly observed buses for the current iteration. After checking all zero injection buses, this temporary set is added to $O$. The loop continues until a full pass over all $z \\in Z$ results in no new buses being observed. At this point, a fixed-point has been reached and the set $O$ is complete.\n\n3.  **Verification**: After the fixed-point iteration terminates, the cardinality of the final set of observed buses, $\\lvert O \\rvert$, is compared to the total number of buses in the network, $\\lvert V \\rvert$. If $\\lvert O \\rvert = \\lvert V \\rvert$, the network is fully observable for the given PMU placement $P$.\n\nThe overall algorithm for each test case is thus a nested process: the outer loop searches for the optimal $P_{\\mathrm{add}}$ by size and lexicographical order, and the inner loop (the observability closure algorithm) validates each candidate placement. The graph is represented using an adjacency list to facilitate efficient neighbor lookup, which is essential for applying both observability rules.",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the PMU placement problem for a suite of test cases.\n    \"\"\"\n\n    def check_observability(num_buses, adj, z_buses, pmu_set):\n        \"\"\"\n        Computes the observability closure for a given PMU placement.\n\n        Args:\n            num_buses (int): The total number of buses in the network.\n            adj (dict): An adjacency list representation of the graph.\n            z_buses (set): A set of indices of zero injection buses.\n            pmu_set (set): A set of indices of buses with PMUs.\n\n        Returns:\n            bool: True if the network is fully observable, False otherwise.\n        \"\"\"\n        observed = set()\n\n        # Rule 1: Direct measurement\n        for pmu_bus in pmu_set:\n            observed.add(pmu_bus)\n            if pmu_bus in adj:\n                for neighbor in adj[pmu_bus]:\n                    observed.add(neighbor)\n\n        # Early exit if all buses are already observed by direct measurement\n        if len(observed) == num_buses:\n            return True\n\n        # Rule 2: Zero injection inference (iterative fixed-point)\n        while True:\n            newly_observed_this_pass = set()\n            for z in z_buses:\n                if z in observed:\n                    unobserved_neighbors = []\n                    if z in adj:\n                        for neighbor in adj[z]:\n                            if neighbor not in observed:\n                                unobserved_neighbors.append(neighbor)\n                    \n                    if len(unobserved_neighbors) == 1:\n                        new_bus = unobserved_neighbors[0]\n                        # Check if it's truly new to avoid redundant adds\n                        if new_bus not in observed:\n                           newly_observed_this_pass.add(new_bus)\n\n            if not newly_observed_this_pass:\n                break  # Fixed point reached\n            \n            observed.update(newly_observed_this_pass)\n\n        return len(observed) == num_buses\n\n    def find_min_placement(num_buses, edges, z_buses, p0_buses):\n        \"\"\"\n        Finds the lexicographically smallest, minimum-cardinality additional\n        PMU placement for full observability.\n\n        Args:\n            num_buses (int): The total number of buses.\n            edges (list of tuples): The list of branches in the graph.\n            z_buses (list): A list of indices of zero injection buses.\n            p0_buses (list): A list of indices of pre-installed PMUs.\n\n        Returns:\n            list: The lexicographically smallest, minimum-cardinality P_add.\n        \"\"\"\n        V = np.arange(num_buses)\n        P0 = set(p0_buses)\n        Z = set(z_buses)\n        \n        # Using numpy to find available buses for placement\n        available_buses = np.setdiff1d(V, list(P0)).tolist()\n\n        adj = {i: [] for i in range(num_buses)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        # Iterate on the size of the additional PMU set, k\n        for k in range(len(available_buses) + 1):\n            # itertools.combinations produces tuples in lexicographical order\n            for p_add_tuple in itertools.combinations(available_buses, k):\n                p_add = set(p_add_tuple)\n                current_pmu_set = P0.union(p_add)\n                \n                if check_observability(num_buses, adj, Z, current_pmu_set):\n                    return sorted(list(p_add))\n        \n        return [] # Should not be reached for a valid problem setup\n\n    # Test Suite\n    test_cases = [\n        # Case A: path graph without zero injection inference\n        {'num_buses': 6, 'edges': [(0,1),(1,2),(2,3),(3,4),(4,5)], 'z_buses': [], 'p0_buses': []},\n        # Case B: path graph with zero injection inference at interior buses\n        {'num_buses': 6, 'edges': [(0,1),(1,2),(2,3),(3,4),(4,5)], 'z_buses': [1,2,3,4], 'p0_buses': []},\n        # Case C: star graph with a pre-installed PMU at a leaf\n        {'num_buses': 5, 'edges': [(0,1),(0,2),(0,3),(0,4)], 'z_buses': [], 'p0_buses': [1]},\n        # Case D: graph with an isolated bus\n        {'num_buses': 3, 'edges': [(0,1)], 'z_buses': [], 'p0_buses': []}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_min_placement(\n            case['num_buses'], \n            case['edges'], \n            case['z_buses'], \n            case['p0_buses']\n        )\n        results.append(result)\n\n    # Format the final output string to be exactly as specified (no spaces).\n    results_str = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}