{
    "hands_on_practices": [
        {
            "introduction": "节点导纳矩阵（$Y_{\\text{bus}}$）是大多数电力系统分析的数学基础。本练习 () 将提供构建该矩阵的实践机会，通过将基尔霍夫定律应用于网络的图结构，加深对物理组件与其线性代数模型之间联系的理解。",
            "id": "4094423",
            "problem": "考虑一个线性正弦稳态交流（AC）电能网络，该网络表示为一个无向图，其中母线为节点，支路为边。节点导纳矩阵（也称为$Y$-bus）依据基尔霍夫电流定律和线性本构关系，编码了网络的电流-电压关系。每条输电线路都通过一个$\\pi$等效模型进行建模，该模型包含串联阻抗和平均分配到其两端母线的总并联电纳。变压器被建模为与线路阻抗串联的理想、无损、非额定抽头元件。所有参数均以公共基准下的标幺值给出，$j$表示虚数单位。\n\n该网络有四个母线，标记为$1$到$4$。支路及其参数如下：\n- 母线$1$和$2$之间：串联阻抗 $z_{12} = 0.02 + j\\,0.2$，线路总并联电纳 $b_{12} = j\\,0.04$。一个变比为 $t_{12} = 1.05 \\angle 0$ 的理想非额定抽头变压器位于母线$1$侧。\n- 母线$2$和$3$之间：串联阻抗 $z_{23} = 0.01 + j\\,0.1$，线路总并联电纳 $b_{23} = j\\,0.02$。\n- 母线$3$和$4$之间：串联阻抗 $z_{34} = 0.015 + j\\,0.15$，线路总并联电纳 $b_{34} = j\\,0.03$。\n- 母线$2$和$4$之间：串联阻抗 $z_{24} = 0.03 + j\\,0.3$，线路总并联电纳 $b_{24} = j\\,0.06$。\n\n存在对地并联元件的母线如下：\n- 母线$3$：并联导纳 $y_{\\text{sh},3} = j\\,0.1$。\n- 母线$4$：并联导纳 $y_{\\text{sh},4} = -j\\,0.05$。\n\n从基尔霍夫电流定律和各支路元件的线性本构关系出发，使用基于图的节点法确定母线$3$的自导纳，即对角线元素$(Y_{\\text{bus}})_{33}$。然后，数值计算其虚部$\\Im\\{(Y_{\\text{bus}})_{33}\\}$。\n\n将最终答案四舍五入到四位有效数字。以标幺值表示最终值。最终答案必须是单个实数。",
            "solution": "题目要求确定母线$3$的自导纳，即节点导纳矩阵的对角线元素$(Y_{\\text{bus}})_{33}$，然后求其虚部。\n\n节点导纳矩阵的对角线元素$(Y_{\\text{bus}})_{kk}$由基尔霍夫电流定律在每个母线$k$上的应用所定义。元素$(Y_{\\text{bus}})_{kk}$，称为母线$k$的自导纳，是连接到母线$k$的所有导纳之和。这包括连接到母线$k$的所有输电线路的串联导纳、这些线路的$\\pi$模型中的并联导纳，以及连接到母线$k$的任何专用并联元件。\n\n对于母线$3$，连接的元件有：\n$1$. 母线$2$和母线$3$之间的输电线路。\n$2$. 母线$3$和母线$4$之间的输电线路。\n$3$. 母线$3$上的专用并联元件。\n\n输电线路使用$\\pi$等效电路建模。母线$k$和母线$m$之间的一条线路，其串联阻抗为$z_{km}$，总并联导纳为$y^{\\text{sh,total}}_{km}$，其串联导纳为$y'_{km} = 1/z_{km}$。总并联导纳$y^{\\text{sh,total}}_{km}$被平均分配，线路两端（母线$k$和母线$m$处）各连接$y^{\\text{sh,total}}_{km}/2$。\n\n问题描述中提供了带有复数值的“线路总并联电纳$b_{km}$”（例如，$b_{12} = j\\,0.04$）。在标准电路理论中，电纳是导纳的实值虚部。提供一个复数值表明，在问题上下文中，符号$b_{km}$代表线路的总并联导纳，对于无损线路模型，该值是纯虚数。因此，我们将$b_{km}$解释为总并联导纳$y^{\\text{sh,total}}_{km}$。这种解释是唯一与无源网络物理上一致的解释。\n\n母线$3$的自导纳$(Y_{\\text{bus}})_{33}$是连接到它的所有元件的导纳之和：\n$$\n(Y_{\\text{bus}})_{33} = (\\text{contribution from line } 2-3) + (\\text{contribution from line } 3-4) + (\\text{dedicated shunt at bus } 3)\n$$\n每条线路的贡献是其串联导纳和在母线3处的半值并联导纳之和。\n$$\n(Y_{\\text{bus}})_{33} = \\left(\\frac{1}{z_{23}} + \\frac{b_{23}}{2}\\right) + \\left(\\frac{1}{z_{34}} + \\frac{b_{34}}{2}\\right) + y_{\\text{sh},3}\n$$\n关于母线$1$和母线$2$之间线路上的变压器的信息与计算$(Y_{\\text{bus}})_{33}$无关，因为该支路不与母线$3$相连。\n\n连接到母线$3$的元件的给定参数如下：\n-   支路 $2-3$：串联阻抗 $z_{23} = 0.01 + j\\,0.1$ p.u.，总并联导纳 $b_{23} = j\\,0.02$ p.u.。\n-   支路 $3-4$：串联阻抗 $z_{34} = 0.015 + j\\,0.15$ p.u.，总并联导纳 $b_{34} = j\\,0.03$ p.u.。\n-   母线$3$上的并联元件：并联导纳 $y_{\\text{sh},3} = j\\,0.1$ p.u.。\n\n将这些值代入$(Y_{\\text{bus}})_{33}$的表达式中：\n$$\n(Y_{\\text{bus}})_{33} = \\left(\\frac{1}{0.01 + j\\,0.1}\\right) + \\left(\\frac{j\\,0.02}{2}\\right) + \\left(\\frac{1}{0.015 + j\\,0.15}\\right) + \\left(\\frac{j\\,0.03}{2}\\right) + j\\,0.1\n$$\n首先，我们通过取阻抗的倒数来计算串联导纳：\n对于线路 $2-3$：\n$$\ny'_{23} = \\frac{1}{z_{23}} = \\frac{1}{0.01 + j\\,0.1} = \\frac{1}{0.01 + j\\,0.1} \\times \\frac{0.01 - j\\,0.1}{0.01 - j\\,0.1} = \\frac{0.01 - j\\,0.1}{0.01^2 + 0.1^2} = \\frac{0.01 - j\\,0.1}{0.0001 + 0.01} = \\frac{0.01 - j\\,0.1}{0.0101}\n$$\n$$\ny'_{23} = \\frac{0.01}{0.0101} - j\\,\\frac{0.1}{0.0101} \\text{ p.u.}\n$$\n对于线路 $3-4$：\n$$\ny'_{34} = \\frac{1}{z_{34}} = \\frac{1}{0.015 + j\\,0.15} = \\frac{1}{0.015 + j\\,0.15} \\times \\frac{0.015 - j\\,0.15}{0.015 - j\\,0.15} = \\frac{0.015 - j\\,0.15}{0.015^2 + 0.15^2} = \\frac{0.015 - j\\,0.15}{0.000225 + 0.0225} = \\frac{0.015 - j\\,0.15}{0.022725}\n$$\n$$\ny'_{34} = \\frac{0.015}{0.022725} - j\\,\\frac{0.15}{0.022725} \\text{ p.u.}\n$$\n现在，我们对$(Y_{\\text{bus}})_{33}$的所有分量求和：\n$$\n(Y_{\\text{bus}})_{33} = \\left(\\frac{0.01}{0.0101} - j\\,\\frac{0.1}{0.0101}\\right) + \\left(\\frac{0.015}{0.022725} - j\\,\\frac{0.15}{0.022725}\\right) + j\\,0.01 + j\\,0.015 + j\\,0.1\n$$\n将实部和虚部分开：\n$(Y_{\\text{bus}})_{33}$的实部为：\n$$\n\\Re\\{(Y_{\\text{bus}})_{33}\\} = \\frac{0.01}{0.0101} + \\frac{0.015}{0.022725} \\approx 0.990099 + 0.660066 = 1.650165 \\text{ p.u.}\n$$\n$(Y_{\\text{bus}})_{33}$的虚部为：\n$$\n\\Im\\{(Y_{\\text{bus}})_{33}\\} = -\\frac{0.1}{0.0101} - \\frac{0.15}{0.022725} + 0.01 + 0.015 + 0.1\n$$\n$$\n\\Im\\{(Y_{\\text{bus}})_{33}\\} = -\\frac{0.1}{0.0101} - \\frac{0.15}{0.022725} + 0.125\n$$\n数值计算各项：\n$$\n-\\frac{0.1}{0.0101} \\approx -9.900990\n$$\n$$\n-\\frac{0.15}{0.022725} \\approx -6.600660\n$$\n对虚部各分量求和：\n$$\n\\Im\\{(Y_{\\text{bus}})_{33}\\} \\approx -9.900990 - 6.600660 + 0.125\n$$\n$$\n\\Im\\{(Y_{\\text{bus}})_{33}\\} \\approx -16.501650 + 0.125 = -16.376650 \\text{ p.u.}\n$$\n题目要求将最终答案四舍五入到四位有效数字。该值为$-16.376650$。前四位有效数字是$1$、$6$、$3$和$7$。第五位有效数字是$6$，因此我们将第四位数字向上舍入。\n$$\n\\Im\\{(Y_{\\text{bus}})_{33}\\} \\approx -16.38\n$$",
            "answer": "$$\\boxed{-16.38}$$"
        },
        {
            "introduction": "为了高效分析大型网络的运行状态，工程师们常采用直流潮流近似法。本练习 () 将指导您实现这一强大的技术，它将网络建模为加权拉普拉斯矩阵，从而建立一个关联注入功率与相角的线性系统。这是电力市场和规划研究中的一项核心任务。",
            "id": "4094429",
            "problem": "考虑一个能量传输网络，它被表示为一个连通有向图 $G = (\\mathcal{V}, \\mathcal{E})$，其中 $\\mathcal{V}$ 是母线（节点）的集合，$\\mathcal{E}$ 是输电线路（边）的集合。每条边 $(i,j) \\in \\mathcal{E}$ 从母线 $i$ 指向母线 $j$，具有已知的串联电抗 $x_{ij} > 0$（在共同基准下的标幺值），并被建模为一个无损电感元件。该网络在正弦稳态下运行，并遵循交流（AC）潮流的直流（DC）近似法的以下假设：\n- 所有母线的电压幅值近似均匀且固定为 $|V_i| \\approx 1$ 标幺值，对于所有 $i \\in \\mathcal{V}$。\n- 母线之间的相角差满足 $|\\theta_i - \\theta_j| \\ll 1$ 弧度，因此 $\\sin(\\theta_i - \\theta_j) \\approx \\theta_i - \\theta_j$。\n- 与电抗相比，线路电阻和并联元件可以忽略不计。\n- 母线上的有功功率注入等于其所连接线路上有向有功潮流的代数和，这与 Kirchhoff 电流定律（KCL）和 Kirchhoff 电压定律（KVL）一致。\n\n在这些假设下，使用基于图的公式化方法，其中关联矩阵编码边的方向，加权拉普拉斯矩阵编码线路电抗，以推导并实现线性直流潮流。指定一个索引的平衡母线，其相角固定为 $0$ 弧度。所有母线相角以弧度表示。所有线路潮流以兆瓦（MW）表示。使用以兆瓦（MW）为单位的共同基准功率 $S_{\\text{base}}$ 在标幺值和物理单位之间进行转换，即 $P_{\\text{MW}} = P_{\\text{p.u.}} \\cdot S_{\\text{base}}$ 和 $F_{\\text{MW}} = F_{\\text{p.u.}} \\cdot S_{\\text{base}}$。\n\n编写一个完整、可运行的程序，该程序：\n- 根据有向边构建关联矩阵，并利用线路电抗形成相应的加权拉普拉斯矩阵。\n- 求解以平衡母线相角固定为 $0$ 弧度的母线相角 $\\theta_i$ 线性系统。\n- 使用直流近似法计算每条边 $(i,j) \\in \\mathcal{E}$ 的有向线路潮流 $F_{ij}$（单位为MW），其中正向潮流定义为与边的方向一致。\n- 检查每条边的热极限符合性：如果 $|F_{ij}|$ 严格大于指定的极限 $L_{ij}$（单位为MW），则认为超出极限。等于极限 $|F_{ij}| = L_{ij}$ 不算作超出极限。\n- 生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是一个包含三个元素的列表：按母线索引升序排列的母线相角列表（单位为弧度），按给定边列表顺序排列的线路潮流列表（单位为MW），以及一个指示是否有任何线路超出极限的布尔标志。\n\n相角单位：弧度。功率单位：MW。程序必须以这些单位生成输出。\n\n使用以下测试套件，它涵盖了一般情况、边界条件和边缘情况：\n\n- 测试用例 1（三母线链式网络，正常路径）：\n  - 母线：$\\{1,2,3\\}$。\n  - 边和电抗（标幺值）：$(1,2)$ 的 $x_{12} = 0.2$，$(2,3)$ 的 $x_{23} = 0.25$。\n  - 有向边顺序：$(1,2)$，$(2,3)$。\n  - 净注入功率（MW）：$[50, -30, -20]$。\n  - 平衡母线索引：$1$。\n  - 基准功率：$S_{\\text{base}} = 100$ MW。\n  - 线路极限（MW）：$[100, 100]$。\n\n- 测试用例 2（四母线环形网络，包括极限边界相等和超出极限的情况）：\n  - 母线：$\\{1,2,3,4\\}$。\n  - 边和电抗（标幺值）：$(1,2)$ 的 $x_{12} = 0.1$，$(2,3)$ 的 $x_{23} = 0.2$，$(3,4)$ 的 $x_{34} = 0.3$，$(4,1)$ 的 $x_{41} = 0.4$。\n  - 有向边顺序：$(1,2)$，$(2,3)$，$(3,4)$，$(4,1)$。\n  - 净注入功率（MW）：$[0, 60, -30, -30]$。\n  - 平衡母线索引：$1$。\n  - 基准功率：$S_{\\text{base}} = 100$ MW。\n  - 线路极限（MW）：$[21, 30, 9, 21]$。\n\n- 测试用例 3（双母线单条线路，零注入功率的边缘情况）：\n  - 母线：$\\{1,2\\}$。\n  - 边和电抗（标幺值）：$(1,2)$ 的 $x_{12} = 0.5$。\n  - 有向边顺序：$(1,2)$。\n  - 净注入功率（MW）：$[0, 0]$。\n  - 平衡母线索引：$1$。\n  - 基准功率：$S_{\\text{base}} = 100$ MW。\n  - 线路极限（MW）：$[10]$。\n\n你的程序应生成一行输出，其格式为包含在一个方括号内的逗号分隔列表（例如，$[result1,result2,result3]$），其中每个 $resultk$ 的形式为指定的 $[\\text{angles}, \\text{flows}, \\text{violation}]$。",
            "solution": "在尝试解决方案之前，对问题陈述的有效性进行评估。\n\n### 第 1 步：提取已知条件\n- **网络模型**：一个表示能量传输网络的连通有向图 $G = (\\mathcal{V}, \\mathcal{E})$。\n- **节点**：$\\mathcal{V}$ 是母线集合。\n- **边**：$\\mathcal{E}$ 是从母线 $i$ 到母线 $j$ 的有向输电线路集合。\n- **边属性**：每条边 $(i,j)$ 都有一个串联电抗 $x_{ij} > 0$（标幺值），并被建模为一个无损电感元件。\n- **运行假设（直流潮流）**：\n    - 所有母线电压幅值 $|V_i| \\approx 1$ 标幺值，对于所有 $i \\in \\mathcal{V}$。\n    - 小相角差 $|\\theta_i - \\theta_j| \\ll 1$ 弧度，允许近似 $\\sin(\\theta_i - \\theta_j) \\approx \\theta_i - \\theta_j$。\n    - 线路电阻和并联元件可忽略不计。\n- **守恒定律**：母线上的有功功率注入等于其所连接线路上有向有功潮流的代数和。\n- **要求的公式化方法**：使用关联矩阵和加权拉普拉斯矩阵的基于图的公式化方法。\n- **边界条件**：一个指定索引的平衡母线，其相角固定为 $\\theta_{\\text{slack}} = 0$ 弧度。\n- **单位转换**：使用以兆瓦（MW）为单位的基准功率 $S_{\\text{base}}$ 在标幺值（p.u.）和物理单位之间转换：$P_{\\text{MW}} = P_{\\text{p.u.}} \\cdot S_{\\text{base}}$ 和 $F_{\\text{MW}} = F_{\\text{p.u.}} \\cdot S_{\\text{base}}$。\n- **输出要求**：\n    1.  一个按母线索引排序的母线相角 $\\theta_i$ 列表（单位为弧度）。\n    2.  一个按输入边列表顺序排列的有向线路潮流 $F_{ij}$ 列表（单位为MW）。\n    3.  一个布尔标志，指示是否有任何线路超出极限，其中超出极限定义为 $|F_{ij}| > L_{ij}$。\n- **测试用例**：提供了三个具体的测试用例，包含所有必要的参数（网络拓扑、电抗、注入功率、平衡母线、基准功率、线路极限）。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题基于直流（DC）潮流近似法，这是电力系统工程中一个标准和基础的分析工具。其假设和基于图的公式化方法是教科书级别的内容。这是科学上合理的。\n- **适定性**：问题是适定的。对于一个连通网络，指定一个平衡母线（一个参考相角）会使得求解其余母线相角的线性方程组非奇异，从而保证唯一解。每个测试用例都提供了所有必要的数据。\n- **客观性**：问题陈述使用了精确、客观和定量的语言。目标清晰明确。\n- **完整性和一致性**：设置是完整的。对于每个测试用例，母线数量、有向边、它们的电抗、所有母线的净注入功率、平衡母线、基准功率和线路热极限都已指定。没有矛盾之处。\n- **可行性**：给出的电抗、注入功率和极限的数值在电力系统研究的实际范围内。\n\n### 第 3 步：结论与行动\n问题是**有效的**，因为它具有科学依据、适定且完整。将基于指定的图论原理开发解决方案。\n\n### 求解推导\n直流潮流模型提供了有功功率注入、母线相角和线路潮流之间的线性关系。推导过程如下：\n\n1.  **线路潮流**：在直流近似假设下，从母线 $i$ 到母线 $j$，沿电抗为 $x_{ij}$ 的线路的有功潮流 $F_{ij}$ 由以下公式给出：\n    $$F_{ij}^{\\text{p.u.}} = \\frac{|V_i||V_j|}{x_{ij}}\\sin(\\theta_i - \\theta_j) \\approx \\frac{1 \\cdot 1}{x_{ij}}(\\theta_i - \\theta_j) = b_{ij}(\\theta_i - \\theta_j)$$\n    其中 $b_{ij} = 1/x_{ij}$ 是线路的电纳，单位为标幺值（p.u.）。\n\n2.  **母线功率平衡**：任何母线 $i$ 的净有功功率注入 $P_i$ 是从该母线流向所有连接线路的有功潮流之和。\n    $$P_i^{\\text{p.u.}} = \\sum_{j \\text{ adjacent to } i} F_{ij}^{\\text{p.u.}} = \\sum_{j \\text{ adjacent to } i} b_{ij}(\\theta_i - \\theta_j)$$\n    这可以重写为一组线性方程，每个母线一个。\n\n3.  **图论矩阵公式化**：这个方程组可以用图论优雅地表达。设图有 $N_b = |\\mathcal{V}|$ 个母线和 $N_e = |\\mathcal{E}|$ 条边。\n    - **关联矩阵（$\\mathbf{A}$）**：一个 $N_b \\times N_e$ 的矩阵，它捕捉了图的拓扑结构和边的方向。对于第 $k$ 条边，从母线 $i$ 指向母线 $j$：\n      $$A_{mk} = \\begin{cases} +1  \\text{if } m=i \\text{ (源母线)} \\\\ -1  \\text{if } m=j \\text{ (目标母线)} \\\\ 0  \\text{otherwise} \\end{cases}$$\n    - **边电纳矩阵（$\\mathbf{W}$）**：一个 $N_e \\times N_e$ 的对角矩阵，其对角线元素是线路电纳，$W_{kk} = b_k = 1/x_k$。\n    - **母线导纳矩阵（$\\mathbf{B}$）**：母线注入功率向量 $\\mathbf{P}^{\\text{p.u.}}$ 和母线相角向量 $\\boldsymbol{\\theta}$ 之间的关系由 $\\mathbf{P}^{\\text{p.u.}} = \\mathbf{B}\\boldsymbol{\\theta}$ 给出。直流模型的母线导纳矩阵 $\\mathbf{B}$ 等价于加权图拉普拉斯矩阵 $\\mathbf{L}_w$：\n      $$\\mathbf{B} = \\mathbf{A} \\mathbf{W} \\mathbf{A}^T$$\n      $\\mathbf{B}$ 的元素为：\n      - $B_{ii} = \\sum_{k \\text{ incident to } i} b_k$（连接到母线 $i$ 的线路电纳之和）\n      - $B_{ij} = -b_{ij}$ 对于 $i \\neq j$，如果母线 $i$ 和 $j$ 之间存在线路。\n\n4.  **求解系统**：矩阵 $\\mathbf{B}$ 是奇异的，这反映了只有相角差是物理上确定的。通过将一个母线设为平衡母线（例如，母线 $s$）并将其相角固定为 $\\theta_s = 0$，我们提供了一个参考。这移除了一个未知数（$\\theta_s$）和一个方程（平衡母线处的功率平衡方程，它成为一个相关方程）。通过从 $\\mathbf{B}$ 中移除与平衡母线对应的行和列，并从 $\\mathbf{P}^{\\text{p.u.}}$ 中移除相应的条目，来对系统进行降阶。让降阶后的量用下标 'red' 表示。\n    $$\\mathbf{P}_{\\text{red}}^{\\text{p.u.}} = \\mathbf{B}_{\\text{red}} \\boldsymbol{\\theta}_{\\text{red}}$$\n    由于对于连通图 $\\mathbf{B}_{\\text{red}}$ 是可逆的，未知的非平衡母线相角 $\\boldsymbol{\\theta}_{\\text{red}}$ 可以通过求解这个线性系统找到：\n    $$\\boldsymbol{\\theta}_{\\text{red}} = \\mathbf{B}_{\\text{red}}^{-1} \\mathbf{P}_{\\text{red}}^{\\text{p.u.}}$$\n    然后，完整的相角向量 $\\boldsymbol{\\theta}$ 由 $\\boldsymbol{\\theta}_{\\text{red}}$ 和 $\\theta_s=0$ 组合而成。所有相角单位为弧度。\n\n5.  **计算线路潮流**：一旦所有母线相角已知，就可以计算每条线路上的有向潮流。尊重其方向的所有边上的相角差向量为 $\\Delta\\boldsymbol{\\theta} = \\mathbf{A}^T \\boldsymbol{\\theta}$。那么，线路潮流的标幺值向量为：\n    $$\\mathbf{F}^{\\text{p.u.}} = \\mathbf{W} (\\mathbf{A}^T \\boldsymbol{\\theta})$$\n    为了获得以兆瓦（MW）为单位的潮流，每个元素都乘以基准功率 $S_{\\text{base}}$：\n    $$\\mathbf{F}^{\\text{MW}} = S_{\\text{base}} \\cdot \\mathbf{F}^{\\text{p.u.}}$$\n\n6.  **热极限检查**：对于每条线路 $k$，将其潮流的绝对值 $|F_k^{\\text{MW}}|$ 与其热极限 $L_k^{\\text{MW}}|$ 进行比较。如果对于任何线路有 $|F_k^{\\text{MW}}| > L_k^{\\text{MW}}|$，则发生了超出极限的情况。\n\n这种结构化、基于原理的方法将被实施以解决给定的测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of DC power flow problems using a graph-based formulation.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"buses\": [1, 2, 3],\n            \"edges\": [(1, 2), (2, 3)],\n            \"reactances\": [0.2, 0.25],\n            \"injections_mw\": [50, -30, -20],\n            \"slack_bus_index\": 1,\n            \"base_power\": 100.0,\n            \"line_limits_mw\": [100, 100],\n        },\n        {\n            \"buses\": [1, 2, 3, 4],\n            \"edges\": [(1, 2), (2, 3), (3, 4), (4, 1)],\n            \"reactances\": [0.1, 0.2, 0.3, 0.4],\n            \"injections_mw\": [0, 60, -30, -30],\n            \"slack_bus_index\": 1,\n            \"base_power\": 100.0,\n            \"line_limits_mw\": [21, 30, 9, 21],\n        },\n        {\n            \"buses\": [1, 2],\n            \"edge\": [(1, 2)],\n            \"reactances\": [0.5],\n            \"injections_mw\": [0, 0],\n            \"slack_bus_index\": 1,\n            \"base_power\": 100.0,\n            \"line_limits_mw\": [10],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        num_buses = len(case[\"buses\"])\n        edges = case.get(\"edges\") or case.get(\"edge\") # Handle alternate key\n        num_edges = len(edges)\n        reactances = np.array(case[\"reactances\"], dtype=float)\n        injections_mw = np.array(case[\"injections_mw\"], dtype=float)\n        slack_bus_id = case[\"slack_bus_index\"]\n        s_base = case[\"base_power\"]\n        limits_mw = np.array(case[\"line_limits_mw\"], dtype=float)\n        \n        # 1. Convert to 0-based index for arrays\n        slack_idx_0based = slack_bus_id - 1\n\n        # 2. Build Incidence Matrix A (num_buses x num_edges)\n        A = np.zeros((num_buses, num_edges), dtype=float)\n        for k, (i, j) in enumerate(edges):\n            A[i - 1, k] = 1.0\n            A[j - 1, k] = -1.0\n        \n        # 3. Build Susceptance Diagonal Matrix W (num_edges x num_edges)\n        susceptances = 1.0 / reactances\n        W = np.diag(susceptances)\n        \n        # 4. Build Bus Admittance Matrix B (num_buses x num_buses)\n        # B is the weighted graph Laplacian: B = A * W * A^T\n        B = A @ W @ A.T\n\n        # 5. Convert power injections to per unit\n        P_pu = injections_mw / s_base\n        \n        # 6. Create the reduced system for non-slack buses\n        all_indices = np.arange(num_buses)\n        non_slack_indices = np.delete(all_indices, slack_idx_0based)\n        \n        B_red = B[np.ix_(non_slack_indices, non_slack_indices)]\n        P_pu_red = P_pu[non_slack_indices]\n        \n        # 7. Solve for non-slack bus angles\n        # B_red * theta_red = P_pu_red\n        theta_red = np.linalg.solve(B_red, P_pu_red)\n        \n        # 8. Reconstruct the full vector of bus angles (in radians)\n        theta = np.zeros(num_buses, dtype=float)\n        theta[non_slack_indices] = theta_red\n        # The slack bus angle theta[slack_idx_0based] is already 0.0\n\n        # 9. Calculate oriented line flows in MW\n        # Angle differences: delta_theta = A^T * theta\n        # Flows (p.u.): F_pu = W * delta_theta\n        # Flows (MW): F_mw = F_pu * S_base\n        flows_pu = W @ A.T @ theta\n        flows_mw = flows_pu * s_base\n\n        # 10. Check for thermal limit violations\n        # Violation if |flow| > limit. Equality is not a violation.\n        is_violated = bool(np.any(np.abs(flows_mw) > limits_mw))\n\n        # 11. Store results in the specified format\n        result = [\n            np.round(theta, 12).tolist(), \n            np.round(flows_mw, 12).tolist(), \n            is_violated\n        ]\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list is \"[item1, item2, ...]\",\n    # which matches the required nested list format for each result.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现代电网依赖于实时监控，这要求网络具有完全的可观测性。这个高级问题 () 将可观测性问题构建为一个图论挑战，目标是找到一个最小的传感器（PMU）集合来观测整个网络。该练习展示了如何应用抽象的图论概念来解决智能电网基础设施中的关键设计问题。",
            "id": "4094414",
            "problem": "考虑一个表示输电级电力网络的无向简单图 $G = (V,E)$，其中 $V$ 是母线的有限集合，$E$ 是无向支路的有限集合。相量测量单元 (PMU) 是一种设备，当安装在母线 $v \\in V$ 上时，它可以测量该母线 $v$ 上的复电压相量 $V_v$ 以及所有关联支路 $(v,u) \\in E$ 上的复电流相量 $I_{v,u}$。目标是在线性化网络方程和已知线路导纳的标准假设下，确定一个最小基数的 PMU 布局，以保证全网可观性，即对于每一个 $v \\in V$，其复电压相量 $V_v$ 都是可确定的。\n\n其基本依据是基尔霍夫电流定律 (KCL)，该定律指出，对于任何母线 $v \\in V$，流入该母线的电流代数和等于其净注入。特别地，在一个零注入母线 $z \\in Z \\subseteq V$ 上，电流之和为零：\n$$\n\\sum_{u \\in N(z)} I_{z,u} = 0,\n$$\n其中 $N(z)$ 表示 $z$ 的邻居集合。如果一个零注入母线的所有关联支路中，除了一个支路外，其他所有支路上的复电流相量都是已知的，则剩余支路的电流可以通过 KCL 推断出来。如果一条支路的复电流及其一端母线的复电压是已知的，则可以使用支路导纳关系推断出另一端母线的复电压。这导出了可从物理学推导出的基于图的可观性规则。\n\n定义以下用于可观性闭包的基于图的规则，这些是你的程序唯一需要使用的规则：\n- 直接测量规则：如果在 $v \\in V$ 处放置一个 PMU，则 $v$ 及所有 $u \\in N(v)$ 都是可观的。\n- 零注入推断规则：如果一个零注入母线 $z \\in Z$ 是可观的，并且其邻居中恰好有一个 $u \\in N(z)$ 尚未可观，则 $u$ 通过基于 KCL 的推断变为可观的。\n\n如果一个母线的复电压相量 $V_v$ 可以通过上述规则确定，则该母线是可观的。全网可观性意味着 $V$ 中的所有母线都是可观的。\n\n给定多个测试用例。对于每个测试用例，你必须计算额外 PMU 布局的字典序最小的最小基数集合 $P_{\\mathrm{add}} \\subseteq V \\setminus P_0$，该集合与任何预装 PMU $P_0 \\subseteq V$ 结合后，能在所述规则下实现全网可观性。字典序是基于母线索引的升序列表来确定的。如果 $P_0 = \\varnothing$，则 $P_{\\mathrm{add}}$ 就是最小基数的 PMU 布局集合。\n\n所有母线都由非负整数索引，所有集合都必须表示为这些整数的升序列表。答案中无需报告任何物理单位。\n\n测试套件：\n- 情况 A (无零注入推断的路径图): \n  $V = \\{0,1,2,3,4,5\\}$, \n  $E = \\{(0,1),(1,2),(2,3),(3,4),(4,5)\\}$, \n  $Z = \\varnothing$, \n  $P_0 = \\varnothing$. \n  计算 $P_{\\mathrm{add}}$。\n- 情况 B (内部母线有零注入推断的路径图): \n  $V = \\{0,1,2,3,4,5\\}$, \n  $E = \\{(0,1),(1,2),(2,3),(3,4),(4,5)\\}$, \n  $Z = \\{1,2,3,4\\}$, \n  $P_0 = \\varnothing$. \n  计算 $P_{\\mathrm{add}}$。\n- 情况 C (叶节点有预装 PMU 的星形图): \n  $V = \\{0,1,2,3,4\\}$, \n  $E = \\{(0,1),(0,2),(0,3),(0,4)\\}$, \n  $Z = \\varnothing$, \n  $P_0 = \\{1\\}$. \n  计算 $P_{\\mathrm{add}}$。\n- 情况 D (有孤立母线的图): \n  $V = \\{0,1,2\\}$, \n  $E = \\{(0,1)\\}$, \n  $Z = \\varnothing$, \n  $P_0 = \\varnothing$. \n  计算 $P_{\\mathrm{add}}$。\n\n算法约束：\n- 你的程序必须搜索候选的额外 PMU 布局，并选择一个实现全网可观性的最小基数集合，通过母线索引升序列表的字典序来决胜平局。\n- 可观性闭包必须严格通过迭代上述两条规则直到达到不动点来计算，然后检查是否所有母线都变为可观的。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含结果，结果是一个用方括号括起来的逗号分隔列表，每个元素是相应测试用例中 $P_{\\mathrm{add}}$ 的母线索引升序列表。输出不得包含任何空格。例如，对于三个结果 $R_1$、$R_2$ 和 $R_3$，该行应为 $[R_1,R_2,R_3]$ 的形式，其中 $R_i$ 表示为像 $[0,2,5]$ 这样的列表。",
            "solution": "所提出的问题是确定为实现全网可观性所需的、字典序最小的最小基数额外相量测量单元 (PMU) 布局集合，记为 $P_{\\mathrm{add}}$。该网络表示为一个无向图 $G = (V,E)$，其中 $V$ 是母线集合，$E$ 是支路集合。该问题是良定义的，在电力系统工程中有科学依据，并且在给定约束下具有唯一解。它是集合覆盖或支配集问题的一个变体，并增加了特定的推斷规则。\n\n解决策略涉及对所有可能的额外 PMU 布局空间进行系统性搜索。由于目标是首先最小化 $P_{\\mathrm{add}}$ 的基数，然后选择字典序最小的集合，因此搜索也相应地进行了结构化。我们对额外布局集的大小 $k = |P_{\\mathrm{add}}|$ 进行迭代，从 $k=0$ 开始，并递增直到找到解。对于每个 $k$ 值，我们从可用母线集合 $V \\setminus P_0$ 中生成所有 $k$ 个母线的可能组合。通过按字典序生成这些组合，第一个实现全网可观性的组合保证是具有最小可能基数的字典序最小解。\n\n对于每个候选的总 PMU 布局集合 $P = P_0 \\cup P_{\\mathrm{add\\_candidate}}$，我们必须验证它是否能实现全网可观性。这是通过计算可观性闭包来完成的，可观性闭包是其电压相量可以被确定的所有母线的完整集合。该闭包是通过迭代应用给定的两个规则直到达到不动点（即直到没有新的母线可以变为可观）来计算的。\n\n可观性闭包算法按以下步骤进行：\n1.  初始化 (直接测量规则)：形成一个初始可观母线集合 $O$。对于每个放置了 PMU 的母线 $v$ ($v \\in P$)，母线 $v$ 本身及其邻域 $N(v)$ 中的所有母线都被添加到集合 $O$ 中。这由规则表达为：如果 $v \\in P$，则 $\\{v\\} \\cup N(v) \\subseteq O$。\n\n2.  迭代推断 (零注入推断规则)：算法进入一个迭代循环。在每次迭代中，它检查每个零注入母线 $z \\in Z$。如果 $z$ 在当前的可观母线集合 $O$ 中，算法会检查其邻居。如果恰好有一个邻居，比如 $u \\in N(z)$，尚不在 $O$ 中，则 $u$ 变为可观，并被添加到一个用于当前迭代的新可观母线临时集合中。在检查完所有零注入母线后，这个临时集合被添加到 $O$ 中。循环继续，直到对所有 $z \\in Z$ 的一次完整遍历没有导致任何新的母线变为可观。此时，已达到不動点，集合 $O$ 是完整的。\n\n3.  验证：在不动点迭代终止后，将最终可观母线集合的基数 $|O|$ 与网络中的母线总数 $|V|$ 进行比较。如果 $|O| = |V|$，则对于给定的 PMU 布局 $P$，网络是完全可观的。\n\n因此，每个测试用例的整体算法是一个嵌套过程：外层循环按大小和字典序搜索最优的 $P_{\\mathrm{add}}$，而内层循环（可观性闭包算法）则验证每个候选布局。该图使用邻接表表示，以便于高效地查找邻居，这对于应用两种可观性规则至关重要。",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the PMU placement problem for a suite of test cases.\n    \"\"\"\n\n    def check_observability(num_buses, adj, z_buses, pmu_set):\n        \"\"\"\n        Computes the observability closure for a given PMU placement.\n\n        Args:\n            num_buses (int): The total number of buses in the network.\n            adj (dict): An adjacency list representation of the graph.\n            z_buses (set): A set of indices of zero injection buses.\n            pmu_set (set): A set of indices of buses with PMUs.\n\n        Returns:\n            bool: True if the network is fully observable, False otherwise.\n        \"\"\"\n        observed = set()\n\n        # Rule 1: Direct measurement\n        for pmu_bus in pmu_set:\n            observed.add(pmu_bus)\n            if pmu_bus in adj:\n                for neighbor in adj[pmu_bus]:\n                    observed.add(neighbor)\n\n        # Early exit if all buses are already observed by direct measurement\n        if len(observed) == num_buses:\n            return True\n\n        # Rule 2: Zero injection inference (iterative fixed-point)\n        while True:\n            newly_observed_this_pass = set()\n            for z in z_buses:\n                if z in observed:\n                    unobserved_neighbors = []\n                    if z in adj:\n                        for neighbor in adj[z]:\n                            if neighbor not in observed:\n                                unobserved_neighbors.append(neighbor)\n                    \n                    if len(unobserved_neighbors) == 1:\n                        new_bus = unobserved_neighbors[0]\n                        # Check if it's truly new to avoid redundant adds\n                        if new_bus not in observed:\n                           newly_observed_this_pass.add(new_bus)\n\n            if not newly_observed_this_pass:\n                break  # Fixed point reached\n            \n            observed.update(newly_observed_this_pass)\n\n        return len(observed) == num_buses\n\n    def find_min_placement(num_buses, edges, z_buses, p0_buses):\n        \"\"\"\n        Finds the lexicographically smallest, minimum-cardinality additional\n        PMU placement for full observability.\n\n        Args:\n            num_buses (int): The total number of buses.\n            edges (list of tuples): The list of branches in the graph.\n            z_buses (list): A list of indices of zero injection buses.\n            p0_buses (list): A list of indices of pre-installed PMUs.\n\n        Returns:\n            list: The lexicographically smallest, minimum-cardinality P_add.\n        \"\"\"\n        V = np.arange(num_buses)\n        P0 = set(p0_buses)\n        Z = set(z_buses)\n        \n        # Using numpy to find available buses for placement\n        available_buses = np.setdiff1d(V, list(P0)).tolist()\n\n        adj = {i: [] for i in range(num_buses)}\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        # Iterate on the size of the additional PMU set, k\n        for k in range(len(available_buses) + 1):\n            # itertools.combinations produces tuples in lexicographical order\n            for p_add_tuple in itertools.combinations(available_buses, k):\n                p_add = set(p_add_tuple)\n                current_pmu_set = P0.union(p_add)\n                \n                if check_observability(num_buses, adj, Z, current_pmu_set):\n                    return sorted(list(p_add))\n        \n        return [] # Should not be reached for a valid problem setup\n\n    # Test Suite\n    test_cases = [\n        # Case A: path graph without zero injection inference\n        {'num_buses': 6, 'edges': [(0,1),(1,2),(2,3),(3,4),(4,5)], 'z_buses': [], 'p0_buses': []},\n        # Case B: path graph with zero injection inference at interior buses\n        {'num_buses': 6, 'edges': [(0,1),(1,2),(2,3),(3,4),(4,5)], 'z_buses': [1,2,3,4], 'p0_buses': []},\n        # Case C: star graph with a pre-installed PMU at a leaf\n        {'num_buses': 5, 'edges': [(0,1),(0,2),(0,3),(0,4)], 'z_buses': [], 'p0_buses': [1]},\n        # Case D: graph with an isolated bus\n        {'num_buses': 3, 'edges': [(0,1)], 'z_buses': [], 'p0_buses': []}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_min_placement(\n            case['num_buses'], \n            case['edges'], \n            case['z_buses'], \n            case['p0_buses']\n        )\n        results.append(result)\n\n    # Format the final output string to be exactly as specified (no spaces).\n    results_str = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}