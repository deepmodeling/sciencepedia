{
    "hands_on_practices": [
        {
            "introduction": "To truly grasp vorticity, we must start with its mathematical roots in the velocity gradient tensor. This exercise provides a foundational proof that vorticity is intrinsically linked to fluid rotation, not deformation . By analytically dissecting a velocity field into its symmetric (strain-rate) and anti-symmetric (spin) components, you will demonstrate from first principles why only the latter gives rise to a non-zero vorticity.",
            "id": "4005202",
            "problem": "Consider a three-dimensional, steady velocity field in free space, representative of a local model often used in Computational Fluid Dynamics (CFD), defined by the superposition of a rigid-body rotation and a uniform pure shear, \n$$\\boldsymbol{u}(\\boldsymbol{x}) = \\boldsymbol{\\Omega} \\times \\boldsymbol{x} + \\boldsymbol{S}\\,\\boldsymbol{x},$$ \nwhere $\\boldsymbol{x} = (x,y,z)$, $\\boldsymbol{\\Omega}$ is a constant angular-velocity vector, and $\\boldsymbol{S}$ is a constant, symmetric second-order tensor with zero trace (a uniform pure shear, i.e., a deviatoric rate-of-strain). Using only the fundamental definition of vorticity as the curl of velocity, $$\\boldsymbol{\\omega} = \\nabla \\times \\boldsymbol{u},$$ derive the vorticity field $\\boldsymbol{\\omega}(\\boldsymbol{x})$ and demonstrate, from first principles, which portion of the velocity gradient contributes to $\\boldsymbol{\\omega}$ and which portion does not. Your derivation must explicitly show the role of the symmetry of the velocity-gradient components. Express your final result for $\\boldsymbol{\\omega}(\\boldsymbol{x})$ in closed form. The final answer should be a single analytic expression (no numerical rounding is required).",
            "solution": "The problem statement is evaluated as scientifically grounded, well-posed, and objective. It provides a complete and consistent setup for a standard problem in fluid kinematics. The problem is valid.\n\nThe vorticity field $\\boldsymbol{\\omega}(\\boldsymbol{x})$ is defined as the curl of the velocity field $\\boldsymbol{u}(\\boldsymbol{x})$:\n$$\n\\boldsymbol{\\omega} = \\nabla \\times \\boldsymbol{u}\n$$\nThe given velocity field is a superposition of a rigid-body rotation and a uniform pure shear:\n$$\n\\boldsymbol{u}(\\boldsymbol{x}) = \\boldsymbol{\\Omega} \\times \\boldsymbol{x} + \\boldsymbol{S}\\,\\boldsymbol{x}\n$$\nwhere $\\boldsymbol{\\Omega}$ is a constant angular-velocity vector and $\\boldsymbol{S}$ is a constant, symmetric, second-order tensor with zero trace.\n\nBy the linearity of the curl operator, we can analyze the two terms of the velocity field separately:\n$$\n\\boldsymbol{\\omega} = \\nabla \\times (\\boldsymbol{\\Omega} \\times \\boldsymbol{x}) + \\nabla \\times (\\boldsymbol{S}\\,\\boldsymbol{x})\n$$\nWe will now evaluate each term from first principles.\n\nFirst, consider the rigid-body rotation term, $\\boldsymbol{u}_{rot} = \\boldsymbol{\\Omega} \\times \\boldsymbol{x}$. We can compute its curl using the vector calculus identity for the curl of a cross product, $\\nabla \\times (\\boldsymbol{A} \\times \\boldsymbol{B}) = \\boldsymbol{A}(\\nabla \\cdot \\boldsymbol{B}) - \\boldsymbol{B}(\\nabla \\cdot \\boldsymbol{A}) + (\\boldsymbol{B} \\cdot \\nabla)\\boldsymbol{A} - (\\boldsymbol{A} \\cdot \\nabla)\\boldsymbol{B}$. Let $\\boldsymbol{A} = \\boldsymbol{\\Omega}$ and $\\boldsymbol{B} = \\boldsymbol{x}$.\n\nGiven that $\\boldsymbol{\\Omega}$ is a constant vector, its spatial derivatives are zero:\n$$\n\\nabla \\cdot \\boldsymbol{\\Omega} = 0\n$$\n$$\n(\\boldsymbol{x} \\cdot \\nabla)\\boldsymbol{\\Omega} = \\boldsymbol{0}\n$$\nThe derivatives of the position vector $\\boldsymbol{x}$ are:\nThe divergence of $\\boldsymbol{x}$:\n$$\n\\nabla \\cdot \\boldsymbol{x} = \\frac{\\partial x}{\\partial x} + \\frac{\\partial y}{\\partial y} + \\frac{\\partial z}{\\partial z} = 1 + 1 + 1 = 3\n$$\nThe directional derivative of $\\boldsymbol{x}$ along $\\boldsymbol{\\Omega}$:\n$$\n(\\boldsymbol{\\Omega} \\cdot \\nabla)\\boldsymbol{x} = \\left(\\Omega_x \\frac{\\partial}{\\partial x} + \\Omega_y \\frac{\\partial}{\\partial y} + \\Omega_z \\frac{\\partial}{\\partial z}\\right)(x\\hat{\\boldsymbol{e}}_x + y\\hat{\\boldsymbol{e}}_y + z\\hat{\\boldsymbol{e}}_z) = \\Omega_x \\hat{\\boldsymbol{e}}_x + \\Omega_y \\hat{\\boldsymbol{e}}_y + \\Omega_z \\hat{\\boldsymbol{e}}_z = \\boldsymbol{\\Omega}\n$$\nSubstituting these results into the vector identity:\n$$\n\\nabla \\times (\\boldsymbol{\\Omega} \\times \\boldsymbol{x}) = \\boldsymbol{\\Omega}(3) - \\boldsymbol{x}(0) + \\boldsymbol{0} - \\boldsymbol{\\Omega} = 3\\boldsymbol{\\Omega} - \\boldsymbol{\\Omega} = 2\\boldsymbol{\\Omega}\n$$\n\nSecond, consider the pure shear term, $\\boldsymbol{u}_{shear} = \\boldsymbol{S}\\,\\boldsymbol{x}$. We will compute its curl, $\\nabla \\times (\\boldsymbol{S}\\,\\boldsymbol{x})$, using indicial notation. Let $\\boldsymbol{v} = \\boldsymbol{S}\\,\\boldsymbol{x}$. The $k$-th component of $\\boldsymbol{v}$ is given by $v_k = S_{km} x_m$, where Einstein summation over the index $m$ is implied. The $i$-th component of the curl of $\\boldsymbol{v}$ is:\n$$\n(\\nabla \\times \\boldsymbol{v})_i = \\epsilon_{ijk} \\frac{\\partial v_k}{\\partial x_j}\n$$\nwhere $\\epsilon_{ijk}$ is the Levi-Civita symbol. The partial derivative term is the velocity gradient for the shear flow:\n$$\n\\frac{\\partial v_k}{\\partial x_j} = \\frac{\\partial}{\\partial x_j}(S_{km} x_m) = S_{km} \\frac{\\partial x_m}{\\partial x_j} = S_{km} \\delta_{jm} = S_{kj}\n$$\nHere, $\\delta_{jm}$ is the Kronecker delta. Substituting this back into the expression for the curl component:\n$$\n(\\nabla \\times \\boldsymbol{v})_i = \\epsilon_{ijk} S_{kj}\n$$\nThe problem states that the tensor $\\boldsymbol{S}$ is symmetric, meaning $S_{kj} = S_{jk}$. The Levi-Civita symbol $\\epsilon_{ijk}$ is anti-symmetric with respect to an interchange of any two of its indices, specifically $\\epsilon_{ijk} = -\\epsilon_{ikj}$. A contracted product of a symmetric tensor and an anti-symmetric tensor over their corresponding indices is identically zero. To demonstrate this explicitly, we can rename the dummy summation indices $j$ and $k$:\n$$\n(\\nabla \\times \\boldsymbol{v})_i = \\epsilon_{ijk} S_{kj} = \\epsilon_{ikj} S_{jk}\n$$\nUsing the anti-symmetric property of $\\epsilon_{ikj} = -\\epsilon_{ijk}$ and the symmetric property of $S_{jk} = S_{kj}$:\n$$\n(\\nabla \\times \\boldsymbol{v})_i = (-\\epsilon_{ijk}) (S_{kj}) = -(\\epsilon_{ijk} S_{kj}) = -(\\nabla \\times \\boldsymbol{v})_i\n$$\nThe only way a quantity can be equal to its own negative, $C_i = -C_i$, is if the quantity is zero, $C_i = 0$. This holds for all components $i=1, 2, 3$. Therefore, the curl of the pure shear velocity component is the zero vector:\n$$\n\\nabla \\times (\\boldsymbol{S}\\,\\boldsymbol{x}) = \\boldsymbol{0}\n$$\n\nThe analysis above demonstrates which portion of the velocity gradient contributes to vorticity. The velocity gradient tensor, with components $L_{ij} = \\partial u_i / \\partial x_j$, can always be decomposed into a symmetric part, the rate-of-strain tensor $\\boldsymbol{E}$, and an anti-symmetric part, the spin (or vorticity) tensor $\\boldsymbol{W}$:\n$$\nL_{ij} = E_{ij} + W_{ij} = \\frac{1}{2}\\left(\\frac{\\partial u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i}\\right) + \\frac{1}{2}\\left(\\frac{\\partial u_i}{\\partial x_j} - \\frac{\\partial u_j}{\\partial x_i}\\right)\n$$\nThe vorticity vector $\\boldsymbol{\\omega}$ is related to the anti-symmetric part of the velocity gradient. Its components are $\\omega_k = \\epsilon_{kji} L_{ij}$. When we substitute the decomposition, the term involving the symmetric tensor $\\boldsymbol{E}$ vanishes due to the contraction with the anti-symmetric tensor $\\epsilon_{kji}$, i.e., $\\epsilon_{kji} E_{ij} = 0$. Thus, only the anti-symmetric part $\\boldsymbol{W}$ contributes to vorticity.\n\nFor the given velocity field $\\boldsymbol{u} = \\boldsymbol{\\Omega} \\times \\boldsymbol{x} + \\boldsymbol{S}\\,\\boldsymbol{x}$, the gradient of the first term, $\\boldsymbol{\\Omega} \\times \\boldsymbol{x}$, is a purely anti-symmetric tensor, which constitutes the spin tensor $\\boldsymbol{W}$ for this flow. The gradient of the second term, $\\boldsymbol{S}\\,\\boldsymbol{x}$, is the symmetric tensor $\\boldsymbol{S}$, which constitutes the rate-of-strain tensor $\\boldsymbol{E}$. Our derivation confirmed this principle: the curl of the part associated with the anti-symmetric gradient ($\\boldsymbol{\\Omega} \\times \\boldsymbol{x}$) is non-zero, while the curl of the part associated with the symmetric gradient ($\\boldsymbol{S}\\,\\boldsymbol{x}$) is zero.\n\nCombining the results for the two terms, the total vorticity field is:\n$$\n\\boldsymbol{\\omega}(\\boldsymbol{x}) = \\nabla \\times (\\boldsymbol{\\Omega} \\times \\boldsymbol{x}) + \\nabla \\times (\\boldsymbol{S}\\,\\boldsymbol{x}) = 2\\boldsymbol{\\Omega} + \\boldsymbol{0} = 2\\boldsymbol{\\Omega}\n$$\nThe vorticity field is constant and is equal to twice the angular-velocity vector defining the rigid-body rotation.",
            "answer": "$$\\boxed{2\\boldsymbol{\\Omega}}$$"
        },
        {
            "introduction": "Bridging the gap between continuous theory and discrete computation is a cornerstone of CFD. This practice challenges you to numerically verify Stokes' theorem, which relates circulation $\\Gamma$ to the flux of vorticity $\\boldsymbol{\\omega}$ . You will implement and compare two distinct numerical approximations—a line integral for circulation and a surface integral for vorticity—gaining invaluable insight into how fundamental integral theorems are realized in finite volume and finite difference methods.",
            "id": "4005206",
            "problem": "You are given a uniform Cartesian grid representing a two-dimensional velocity field for Computational Fluid Dynamics in aerospace applications. The velocity field is sampled at cell centers. Your task is to construct a numerical procedure to evaluate circulation around a discrete closed loop and compare the result to a surface integral of vorticity using a discrete form of Stokes theorem. The problem must be implemented as a complete, runnable program that outputs the required comparison for the test suite described below.\n\nDefinitions and context to use:\n- The velocity field is $\\mathbf{v}(x,y) = (v_x(x,y), v_y(x,y))$ with $v_x$ and $v_y$ specified at cell centers.\n- The circulation around a closed curve $\\mathcal{C}$ is defined as $\\Gamma = \\oint_{\\mathcal{C}} \\mathbf{v} \\cdot d\\mathbf{l}$, with units of square meters per second (m$^2$/s).\n- In two dimensions, the out-of-plane vorticity is defined as $\\omega_z = \\frac{\\partial v_y}{\\partial x} - \\frac{\\partial v_x}{\\partial y}$, with units of inverse seconds (1/s).\n- Stokes theorem states, for a smooth field, that $\\Gamma = \\iint_{\\mathcal{S}} \\omega_z \\, dS$, where $\\mathcal{S}$ is any surface bounded by $\\mathcal{C}$.\n\nGrid model and loop specification:\n- Use a uniform grid with $N_x$ cells in the $x$-direction and $N_y$ cells in the $y$-direction.\n- Cell centers are at coordinates $x_i = (i + \\tfrac{1}{2}) \\, \\Delta x$ for $i = 0,1,\\ldots,N_x-1$ and $y_j = (j + \\tfrac{1}{2}) \\, \\Delta y$ for $j = 0,1,\\ldots,N_y-1$, where $\\Delta x$ and $\\Delta y$ are the uniform cell widths in meters.\n- A rectangular loop is defined by the index ranges $i \\in [i_0,i_1]$ and $j \\in [j_0,j_1]$ for the interior cells enclosed by the loop. The loop path $\\mathcal{C}$ runs along the faces surrounding this block of cells, oriented counterclockwise.\n\nNumerical requirements:\n1. Construct a discrete line integral approximation for $\\Gamma$ along the rectangle boundary using only cell-centered velocities. For a horizontal edge segment, approximate the tangential velocity component $v_x$ at the edge midpoint by the arithmetic mean of the two adjacent cell-centered values, and multiply by the segment length $\\Delta x$. For a vertical edge segment, approximate the tangential velocity component $v_y$ at the edge midpoint by the arithmetic mean of the two adjacent cell-centered values, and multiply by the segment length $\\Delta y$. Respect the counterclockwise orientation when accumulating contributions, with the bottom and right edges added and the top and left edges subtracted.\n2. Construct a discrete surface integral approximation for $\\Gamma$ by first computing $\\omega_z$ at each interior cell center using second-order central differences from neighboring cell-centered velocities, namely approximate $\\frac{\\partial v_y}{\\partial x}$ by a centered difference in $x$ and $\\frac{\\partial v_x}{\\partial y}$ by a centered difference in $y$, and then sum $\\omega_z \\, \\Delta x \\, \\Delta y$ over all cells inside the loop.\n3. For each case in the test suite, compute the absolute difference $|\\Gamma_{\\text{line}} - \\Gamma_{\\text{surface}}|$. Express results in square meters per second (m$^2$/s) as decimal numbers.\n\nFlow fields:\n- For each test case, the continuous velocity field is specified analytically and must be sampled at cell centers:\n  - Solid-body rotation: $v_x(x,y) = -\\Omega \\, y$, $v_y(x,y) = \\Omega \\, x$, where $\\Omega$ is the angular speed in radians per second. The vorticity is spatially uniform with $\\omega_z = 2 \\Omega$.\n  - Uniform shear: $v_x(x,y) = S \\, y$, $v_y(x,y) = 0$, where $S$ is the shear rate in inverse seconds. The vorticity is spatially uniform with $\\omega_z = -S$.\n  - Uniform flow: $v_x(x,y) = U$, $v_y(x,y) = 0$, where $U$ is the free-stream speed in meters per second. The vorticity is $\\omega_z = 0$.\n\nTest suite:\nImplement the following test cases. All indices are zero-based. Ensure that loops are strictly interior so that all required neighbor cell values exist for centered differences and edge-averaging.\n\n- Case 1 (happy path, solid-body rotation): $N_x = 21$, $N_y = 17$, $\\Delta x = 0.1$ m, $\\Delta y = 0.1$ m, $\\Omega = 2.0$ s$^{-1}$, loop indices $i_0 = 5$, $i_1 = 8$, $j_0 = 6$, $j_1 = 8$.\n- Case 2 (moderate rectangle, uniform shear): $N_x = 16$, $N_y = 16$, $\\Delta x = 0.2$ m, $\\Delta y = 0.2$ m, $S = 3.0$ s$^{-1}$, loop indices $i_0 = 5$, $i_1 = 6$, $j_0 = 5$, $j_1 = 6$.\n- Case 3 (larger aspect ratio loop, uniform flow): $N_x = 20$, $N_y = 20$, $\\Delta x = 0.5$ m, $\\Delta y = 0.5$ m, $U = 15.0$ m/s, loop indices $i_0 = 8$, $i_1 = 10$, $j_0 = 7$, $j_1 = 11$.\n- Case 4 (edge case, smallest loop, solid-body rotation): $N_x = 15$, $N_y = 15$, $\\Delta x = 0.05$ m, $\\Delta y = 0.05$ m, $\\Omega = 1.5$ s$^{-1}$, loop indices $i_0 = 7$, $i_1 = 7$, $j_0 = 7$, $j_1 = 7$.\n\nFinal output format:\nYour program should produce a single line of output containing the absolute differences for the four test cases, in m$^2$/s, as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4]$, where each $r_k$ is a decimal number. No additional text should be printed.",
            "solution": "The task is to numerically verify a discrete version of Stokes' theorem for several two-dimensional velocity fields. Stokes' theorem relates the circulation $\\Gamma$ of a vector field $\\mathbf{v}$ around a closed curve $\\mathcal{C}$ to the surface integral of the curl of the field over the surface $\\mathcal{S}$ bounded by $\\mathcal{C}$. In two dimensions, this is expressed as:\n$$\n\\Gamma = \\oint_{\\mathcal{C}} \\mathbf{v} \\cdot d\\mathbf{l} = \\iint_{\\mathcal{S}} (\\nabla \\times \\mathbf{v}) \\cdot d\\mathbf{S} = \\iint_{\\mathcal{S}} \\omega_z \\, dS\n$$\nwhere $\\omega_z = \\frac{\\partial v_y}{\\partial x} - \\frac{\\partial v_x}{\\partial y}$ is the out-of-plane component of the vorticity. We will compute discrete approximations for the line integral, $\\Gamma_{\\text{line}}$, and the surface integral, $\\Gamma_{\\text{surface}}$, and then evaluate their absolute difference.\n\nFirst, we establish the computational grid. The domain is discretized into a uniform Cartesian grid of $N_x \\times N_y$ cells, with respective cell widths $\\Delta x$ and $\\Delta y$. The velocity components, $v_x(x,y)$ and $v_y(x,y)$, are sampled at the center of each cell $(i, j)$, where $i \\in \\{0, 1, \\dots, N_x-1\\}$ and $j \\in \\{0, 1, \\dots, N_y-1\\}$. The coordinates of a cell center are given by $x_i = (i + \\frac{1}{2})\\Delta x$ and $y_j = (j + \\frac{1}{2})\\Delta y$. The provided analytical velocity fields are used to populate two $N_y \\times N_x$ arrays representing the discrete fields $v_{x,i,j}$ and $v_{y,i,j}$.\n\nNext, we formulate the discrete line integral, $\\Gamma_{\\text{line}}$. The integration path $\\mathcal{C}$ is a counterclockwise rectangular loop that encloses the block of interior cells defined by index ranges $i \\in [i_0, i_1]$ and $j \\in [j_0, j_1]$. The path follows the faces of these cells. The integral is approximated by summing the contributions from the four segments of the loop:\n$$\n\\Gamma_{\\text{line}} \\approx \\sum_{\\text{bottom}} (\\mathbf{v} \\cdot d\\mathbf{l}) + \\sum_{\\text{right}} (\\mathbf{v} \\cdot d\\mathbf{l}) + \\sum_{\\text{top}} (\\mathbf{v} \\cdot d\\mathbf{l}) + \\sum_{\\text{left}} (\\mathbf{v} \\cdot d\\mathbf{l})\n$$\nFor each segment, the tangential velocity is approximated at the midpoint of each cell face by the arithmetic mean of the velocities in the two adjacent cell centers. The path increments are $\\Delta x \\mathbf{i}$ (bottom), $\\Delta y \\mathbf{j}$ (right), $-\\Delta x \\mathbf{i}$ (top), and $-\\Delta y \\mathbf{j}$ (left). This leads to the following sum:\n$$\n\\Gamma_{\\text{line}} = \\Delta x \\sum_{i=i_0}^{i_1} \\left(\\frac{v_{x,i,j_0-1} + v_{x,i,j_0}}{2}\\right) + \\Delta y \\sum_{j=j_0}^{j_1} \\left(\\frac{v_{y,i_1,j} + v_{y,i_1+1,j}}{2}\\right) - \\Delta x \\sum_{i=i_0}^{i_1} \\left(\\frac{v_{x,i,j_1} + v_{x,i,j_1+1}}{2}\\right) - \\Delta y \\sum_{j=j_0}^{j_1} \\left(\\frac{v_{y,i_0-1,j} + v_{y,i_0,j}}{2}\\right)\n$$\nThe condition that the loop is \"strictly interior\" ensures that all cell indices used in this formula (e.g., $j_0-1$, $j_1+1$, $i_0-1$, $i_1+1$) are within the grid bounds.\n\nThen, we formulate the discrete surface integral, $\\Gamma_{\\text{surface}}$. The surface $\\mathcal{S}$ is the area covered by the interior cells of the loop. The integral is approximated by summing the vorticity contribution from each cell, multiplied by the cell area $\\Delta x \\Delta y$:\n$$\n\\Gamma_{\\text{surface}} = \\sum_{j=j_0}^{j_1} \\sum_{i=i_0}^{i_1} \\omega_{z,i,j} \\Delta x \\Delta y\n$$\nThe vorticity $\\omega_{z,i,j}$ at the center of cell $(i,j)$ is computed using second-order accurate central difference approximations for the partial derivatives:\n$$\n\\omega_{z,i,j} \\approx \\left(\\frac{\\partial v_y}{\\partial x}\\right)\\bigg|_{i,j} - \\left(\\frac{\\partial v_x}{\\partial y}\\right)\\bigg|_{i,j} \\approx \\frac{v_{y,i+1,j} - v_{y,i-1,j}}{2 \\Delta x} - \\frac{v_{x,i,j+1} - v_{x,i,j-1}}{2 \\Delta y}\n$$\nThis calculation also relies on the loop being strictly interior to ensure that neighbor cells at $i\\pm1$ and $j\\pm1$ are available.\n\nAn important theoretical point is that for this specific choice of centered differencing for vorticity and edge-midpoint averaging for circulation, the discrete form of Stokes' theorem holds exactly. The summation of the discrete vorticity over the interior area can be shown to telescope, resulting in a sum over the boundary that is identical to the expression for the discrete line integral. Therefore, we expect the calculated difference $|\\Gamma_{\\textline} - \\Gamma_{\\text{surface}}|$ to be zero, or a very small number attributable to floating-point precision errors.\n\nThe implementation will proceed by defining a function that takes a test case's parameters, generates the grid and velocity fields, computes $\\Gamma_{\\text{line}}$ and $\\Gamma_{\\text{surface}}$ according to the formulae above, and returns their absolute difference. This process is repeated for each case in the test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries outside the Python standard library are permitted.\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: Solid-body rotation\n        {'flow_type': 'solid_body', 'Nx': 21, 'Ny': 17, 'dx': 0.1, 'dy': 0.1, 'params': {'Omega': 2.0}, 'i0': 5, 'i1': 8, 'j0': 6, 'j1': 8},\n        # Case 2: Uniform shear\n        {'flow_type': 'shear', 'Nx': 16, 'Ny': 16, 'dx': 0.2, 'dy': 0.2, 'params': {'S': 3.0}, 'i0': 5, 'i1': 6, 'j0': 5, 'j1': 6},\n        # Case 3: Uniform flow\n        {'flow_type': 'uniform', 'Nx': 20, 'Ny': 20, 'dx': 0.5, 'dy': 0.5, 'params': {'U': 15.0}, 'i0': 8, 'i1': 10, 'j0': 7, 'j1': 11},\n        # Case 4: Smallest loop, solid-body rotation\n        {'flow_type': 'solid_body', 'Nx': 15, 'Ny': 15, 'dx': 0.05, 'dy': 0.05, 'params': {'Omega': 1.5}, 'i0': 7, 'i1': 7, 'j0': 7, 'j1': 7},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_difference(case)\n        results.append(f\"{result:.15e}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_difference(case_params):\n    \"\"\"\n    Calculates the absolute difference between line and surface integral approximations\n    of circulation for a single test case.\n    \"\"\"\n    # Unpack parameters\n    Nx, Ny = case_params['Nx'], case_params['Ny']\n    dx, dy = case_params['dx'], case_params['dy']\n    i0, i1 = case_params['i0'], case_params['i1']\n    j0, j1 = case_params['j0'], case_params['j1']\n    flow_type = case_params['flow_type']\n    params = case_params['params']\n    \n    # Generate grid coordinates for cell centers\n    x_coords = (np.arange(Nx) + 0.5) * dx\n    y_coords = (np.arange(Ny) + 0.5) * dy\n    X, Y = np.meshgrid(x_coords, y_coords, indexing='ij') # Y is (Ny, Nx), X is (Ny, Nx)\n    \n    # Generate velocity fields based on flow type\n    # Numpy arrays are indexed (row, col) which corresponds to (j, i)\n    vx = np.zeros((Ny, Nx))\n    vy = np.zeros((Ny, Nx))\n    \n    if flow_type == 'solid_body':\n        Omega = params['Omega']\n        vx = -Omega * Y\n        vy = Omega * X\n    elif flow_type == 'shear':\n        S = params['S']\n        vx = S * Y\n        vy = np.zeros_like(X)\n    elif flow_type == 'uniform':\n        U = params['U']\n        vx = np.full_like(X, U)\n        vy = np.zeros_like(X)\n\n    # 1. Calculate the discrete line integral Gamma_line\n    gamma_line = 0.0\n    \n    # Bottom edge (path in +x direction)\n    for i in range(i0, i1 + 1):\n        vel_x_avg = 0.5 * (vx[j0 - 1, i] + vx[j0, i])\n        gamma_line += vel_x_avg * dx\n        \n    # Right edge (path in +y direction)\n    for j in range(j0, j1 + 1):\n        vel_y_avg = 0.5 * (vy[j, i1] + vy[j, i1 + 1])\n        gamma_line += vel_y_avg * dy\n        \n    # Top edge (path in -x direction)\n    for i in range(i0, i1 + 1):\n        vel_x_avg = 0.5 * (vx[j1, i] + vx[j1 + 1, i])\n        gamma_line -= vel_x_avg * dx\n        \n    # Left edge (path in -y direction)\n    for j in range(j0, j1 + 1):\n        vel_y_avg = 0.5 * (vy[j, i0 - 1] + vy[j, i0])\n        gamma_line -= vel_y_avg * dy\n\n    # 2. Calculate the discrete surface integral Gamma_surface\n    gamma_surface = 0.0\n    cell_area = dx * dy\n    \n    for j in range(j0, j1 + 1):\n        for i in range(i0, i1 + 1):\n            # Second-order central differences for vorticity\n            dvy_dx = (vy[j, i + 1] - vy[j, i - 1]) / (2.0 * dx)\n            dvx_dy = (vx[j + 1, i] - vx[j - 1, i]) / (2.0 * dy)\n            omega_z = dvy_dx - dvx_dy\n            gamma_surface += omega_z * cell_area\n\n    # 3. Compute absolute difference\n    return abs(gamma_line - gamma_surface)\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate goal of CFD is to serve as a tool for scientific inquiry and engineering design. This final practice elevates your skills to this level by guiding you through a complete \"virtual experiment\" . You will model the viscous evolution of vortex tubes, use post-processing techniques to extract geometric features from the flow field, and analyze the data to uncover a physical scaling law relating vortex size to the Reynolds number, mimicking the workflow of a modern fluid dynamics researcher.",
            "id": "4005195",
            "problem": "You are tasked with designing and implementing a program to quantify how the Reynolds number affects the geometric properties of vortex tubes by extracting vorticity isosurfaces from simulated flows and fitting scaling laws. The program must be based on first principles of fluid mechanics and numerical approximation, without using any precomputed datasets. The target scenario models a two-dimensional cross-section of a set of parallel vortex tubes with axes aligned with the out-of-plane direction. The flows are incompressible and viscous, and the vortex cores evolve under viscous diffusion. The analysis must be performed for a set of simulations at different Reynolds numbers.\n\nStart from the following foundational base:\n- The definition of vorticity: for a velocity field $\\mathbf{u}(x,y) = (u(x,y), v(x,y))$, the out-of-plane vorticity component is $\\omega_z(x,y) = \\frac{\\partial v}{\\partial x} - \\frac{\\partial u}{\\partial y}$.\n- The definition of circulation: for a closed curve $\\mathcal{C}$, the circulation is $\\Gamma = \\oint_{\\mathcal{C}} \\mathbf{u} \\cdot d\\mathbf{l}$, and by Stokes' theorem, $\\Gamma = \\iint_{\\mathcal{S}} \\omega_z \\, dS$, where $\\mathcal{S}$ is any surface bounded by $\\mathcal{C}$.\n- The Reynolds number: $\\mathrm{Re} = \\frac{\\rho U L}{\\mu}$, where $\\rho$ is the fluid density, $U$ is a characteristic speed, $L$ is a characteristic length, and $\\mu$ is the dynamic viscosity; the kinematic viscosity is $\\nu = \\mu / \\rho$.\n\nYou must build a computational model with the following specifications:\n1. Domain and discretization: Use a square domain of side length $L = 1$ (dimensionless units), discretized uniformly with $N_x = N_y = 256$ grid points. Let $\\Delta x = \\Delta y = 1/(N-1)$, with $N = 256$.\n2. Vortex configuration: Place four identical, co-rotating vortex tubes with centers at $(x,y) \\in \\{(0.3,0.3), (0.3,0.7), (0.7,0.3), (0.7,0.7)\\}$, and circulation $\\Gamma = 1$ (dimensionless). The vortex velocity field in the cross-section must be physically consistent with viscous diffusion of vorticity. You must construct the two-dimensional velocity field $\\mathbf{u}(x,y)$ as the superposition of the azimuthal flows induced by each tube’s circulation. The azimuthal velocity magnitude for each tube must be derived from a viscous vortex model grounded in the governing equations, and the total velocity at each grid point must be the vector sum from all tubes.\n3. Vorticity computation: Compute $\\omega_z(x,y)$ using consistent, second-order accurate finite differences via numerical gradients on the grid.\n4. Isosurface extraction: For each Reynolds number in the test suite (see below), compute the vorticity magnitude isosurface threshold $\\tau$ defined as a fixed fraction of the maximum vorticity magnitude, $\\tau = f \\cdot \\max_{x,y} |\\omega_z(x,y)|$, with $f = e^{-1}$. Extract the binary mask corresponding to $|\\omega_z(x,y)| \\ge \\tau$ in the midplane and identify the connected components that represent the cross-sections of the vortex tubes.\n5. Geometric measurements:\n   - Tube radius: For each connected component, compute its area $A$ in physical units ($A$ in units of $L^2$), and define the equivalent radius $r = \\sqrt{A/\\pi}$ in units of $L$. Use the mean of these radii across all components as the tube radius for that simulation.\n   - Tube spacing: Compute the centroids $(\\bar{x}, \\bar{y})$ of each component, then calculate the Euclidean distance from each centroid to its nearest neighbor. Use the mean nearest-neighbor distance as the tube spacing for that simulation. All distances must be expressed in units of $L$.\n6. Scaling-law fitting: Across the simulations, fit power-law scalings of the form $r(\\mathrm{Re}) = k_r \\, \\mathrm{Re}^{-\\alpha}$ and $s(\\mathrm{Re}) = k_s \\, \\mathrm{Re}^{-\\beta}$. Use linear regression on $\\log r$ versus $\\log \\mathrm{Re}$ and on $\\log s$ versus $\\log \\mathrm{Re}$ to estimate the exponents $\\alpha$ and $\\beta$ and the prefactors $k_r$ and $k_s$. Report only $\\alpha$ and $\\beta$.\n\nTest suite:\n- Use the following Reynolds numbers: $\\mathrm{Re} \\in \\{200, 500, 1000, 2000, 5000\\}$.\n- The characteristic speed $U = 1$ (dimensionless), characteristic length $L = 1$ (dimensionless), circulation $\\Gamma = 1$ (dimensionless), and time scale $t = L/U = 1$ (dimensionless).\n- The vorticity isosurface fraction $f = e^{-1}$ (dimensionless).\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order and rounding:\n  1. The fitted exponent $\\alpha$ (rounded to six decimal places),\n  2. The fitted exponent $\\beta$ (rounded to six decimal places),\n  3. The mean tube radii for each Reynolds number in the test suite, in the same order as the test suite, each rounded to six decimal places,\n  4. The mean nearest-neighbor spacings for each Reynolds number in the test suite, in the same order as the test suite, each rounded to six decimal places.\n- All reported quantities are dimensionless floats. For example, a valid output format is: \"[0.500000,0.000000,0.123456,0.101112,0.098765,0.088888,0.077777,0.400000,0.400000,0.400000,0.400000,0.400000]\".",
            "solution": "The problem statement has been critically reviewed and is determined to be valid. It is a well-posed, scientifically grounded problem in computational fluid dynamics that is self-contained and free of contradictions. The task is to numerically simulate the cross-section of a system of co-rotating viscous vortices at a specific time instance for several Reynolds numbers, measure the geometric properties of the vortex cores, and derive scaling laws.\n\nThe solution will be constructed based on the following first principles and numerical methods.\n\nFirst, we must establish a valid physical model for the velocity field of a viscous vortex. The problem specifies that the model must be \"physically consistent with viscous diffusion of vorticity\". For an isolated line vortex of circulation $\\Gamma$ placed at the origin in an otherwise quiescent fluid, the vorticity $\\omega_z$ evolves according to the two-dimensional vorticity transport equation, which in the absence of background advection simplifies to a diffusion equation:\n$$\n\\frac{\\partial \\omega_z}{\\partial t} = \\nu \\left( \\frac{\\partial^2 \\omega_z}{\\partial x^2} + \\frac{\\partial^2 \\omega_z}{\\partial y^2} \\right) = \\nu \\nabla^2 \\omega_z\n$$\nwhere $\\nu$ is the kinematic viscosity. The solution to this equation, starting from a delta-function vorticity distribution at time $t=0$, is the Lamb-Oseen vortex. Its vorticity profile at a time $t$ is a Gaussian:\n$$\n\\omega_z(r, t) = \\frac{\\Gamma}{4 \\pi \\nu t} \\exp\\left(-\\frac{r^2}{4 \\nu t}\\right)\n$$\nwhere $r$ is the radial distance from the vortex center. The corresponding azimuthal velocity $u_\\theta(r, t)$ is found by integrating the vorticity over a circular disk of radius $r$ to find the circulation $\\Gamma(r)$ and using the relation $\\Gamma(r) = 2\\pi r u_\\theta$:\n$$\nu_\\theta(r, t) = \\frac{\\Gamma}{2 \\pi r} \\left(1 - \\exp\\left(-\\frac{r^2}{4 \\nu t}\\right)\\right)\n$$\nThe problem specifies characteristic scales $U=1$ and $L=1$, and a time of analysis $t=1$. The Reynolds number is given as $\\mathrm{Re} = \\frac{UL}{\\nu} = \\frac{1}{\\nu}$, which implies $\\nu = 1/\\mathrm{Re}$. The circulation is $\\Gamma=1$. Substituting these values into the model equations gives the expressions we will implement for a single vortex:\n$$\nu_\\theta(r) = \\frac{1}{2 \\pi r} \\left(1 - \\exp\\left(-\\frac{r^2 \\mathrm{Re}}{4}\\right)\\right)\n$$\nand\n$$\n\\omega_z(r) = \\frac{\\mathrm{Re}}{4 \\pi} \\exp\\left(-\\frac{r^2 \\mathrm{Re}}{4}\\right)\n$$\nThe total velocity field $\\mathbf{u}(x,y) = (u(x,y), v(x,y))$ is the linear superposition of the fields from the four specified vortex centers.\n\nThe computational procedure is as follows, implemented for each Reynolds number $\\mathrm{Re}$ in the test suite:\n\n1.  **Grid and Field Generation**: A uniform Cartesian grid of size $N \\times N$ with $N=256$ is defined over the square domain $[0,1] \\times [0,1]$. The grid spacing is $\\Delta x = \\Delta y = 1/(N-1)$. The velocity vector field $(u, v)$ is computed at each grid point by summing the contributions from each of the four vortices. For each vortex centered at $(x_c, y_c)$, the velocity components $(u_i, v_i)$ at a point $(x,y)$ are calculated from its induced azimuthal velocity $u_\\theta(r)$, where $r = \\sqrt{(x-x_c)^2 + (y-y_c)^2}$. The Cartesian components are $u_i = -u_\\theta \\frac{y-y_c}{r}$ and $v_i = u_\\theta \\frac{x-x_c}{r}$. Care is taken to handle the case $r=0$, where the velocity is $0$.\n\n2.  **Vorticity Calculation**: The out-of-plane vorticity field $\\omega_z = \\frac{\\partial v}{\\partial x} - \\frac{\\partial u}{\\partial y}$ is computed from the gridded velocity field using a second-order accurate central finite difference scheme, as provided by `numpy.gradient`.\n\n3.  **Isosurface Extraction**: The maximum absolute vorticity $\\max|\\omega_z|$ is found. Since all vortices are co-rotating, $\\omega_z$ has a consistent sign, so we use $\\max(\\omega_z)$. The isosurface threshold is calculated as $\\tau = f \\cdot \\max(\\omega_z)$ with $f = e^{-1}$. A binary mask is created for the grid points where $\\omega_z \\ge \\tau$.\n\n4.  **Geometric Analysis**: The `scipy.ndimage` library is used to identify the four distinct connected components (the vortex cores) in the binary mask. For each component:\n    *   The area $A$ is calculated by counting the number of pixels in the component and multiplying by the area of a single pixel, $(\\Delta x)^2$. The equivalent radius is then $r = \\sqrt{A/\\pi}$.\n    *   The centroid $(\\bar{x}, \\bar{y})$ is computed using `scipy.ndimage.center_of_mass` and converted from pixel indices to physical coordinates.\n    The mean radius and mean nearest-neighbor spacing between centroids are calculated for the given $\\mathrm{Re}$.\n\n5.  **Scaling-Law Fitting**: After processing all Reynolds numbers, two power laws, $r(\\mathrm{Re}) = k_r \\mathrm{Re}^{-\\alpha}$ and $s(\\mathrm{Re}) = k_s \\mathrm{Re}^{-\\beta}$, are fitted to the collected data. This is achieved by performing linear regression on the logarithm of the data:\n    $$\n    \\log(r) = \\log(k_r) - \\alpha \\log(\\mathrm{Re})\n    $$\n    $$\n    \\log(s) = \\log(k_s) - \\beta \\log(\\mathrm{Re})\n    $$\n    The slopes of the regression lines yield $-\\alpha$ and $-\\beta$. Analytically, based on the isosurface definition $\\omega_z(r) = e^{-1} \\omega_z(0)$, we derive $\\exp(-\\frac{r^2 \\mathrm{Re}}{4}) = e^{-1}$, which gives $r^2 \\mathrm{Re}/4 = 1$, or $r = 2 \\mathrm{Re}^{-0.5}$. Thus, we expect $\\alpha \\approx 0.5$. Since the vortex centers are fixed, we expect the spacing $s$ to be independent of $\\mathrm{Re}$, implying $\\beta \\approx 0$. The numerical results will be compared against these theoretical predictions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import ndimage\nfrom scipy.spatial.distance import pdist, squareform\n\ndef solve():\n    \"\"\"\n    Computes vortex tube geometric properties for various Reynolds numbers\n    and fits scaling laws.\n    \"\"\"\n    # Problem parameters\n    N = 256\n    L = 1.0\n    GAMMA = 1.0\n    F_ISOSURFACE = np.exp(-1.0)\n    VORTEX_CENTERS = [(0.3, 0.3), (0.3, 0.7), (0.7, 0.3), (0.7, 0.7)]\n    RE_VALUES = np.array([200, 500, 1000, 2000, 5000])\n\n    mean_radii = []\n    mean_spacings = []\n\n    # Grid setup\n    x = np.linspace(0, L, N)\n    y = np.linspace(0, L, N)\n    dx = x[1] - x[0]\n    xx, yy = np.meshgrid(x, y)\n\n    for re in RE_VALUES:\n        # Initialize velocity field\n        u_total = np.zeros((N, N))\n        v_total = np.zeros((N, N))\n\n        # Superimpose velocity fields from each vortex\n        for xc, yc in VORTEX_CENTERS:\n            # Calculate radial distance from vortex center for each grid point\n            rx = xx - xc\n            ry = yy - yc\n            r = np.sqrt(rx**2 + ry**2)\n\n            # Lamb-Oseen azimuthal velocity\n            # u_theta = (Gamma / (2*pi*r)) * (1 - exp(-r^2 * Re / 4t)), t=1\n            # Handle singularity at r=0 where u_theta is 0\n            u_theta = np.zeros_like(r)\n            r_nonzero = r > 0\n            \n            # The argument to exp() can be very large causing overflow\n            # in 1-exp(...) for large Re and r. However, for large arguments,\n            # exp(-arg) -> 0, so 1-exp(-arg) -> 1.\n            # Here, -r^2*re/4 can be large and negative. exp will underflow to 0.\n            # This is numerically stable.\n            u_theta[r_nonzero] = (GAMMA / (2 * np.pi * r[r_nonzero])) * \\\n                                 (1 - np.exp(-(r[r_nonzero]**2 * re) / 4.0))\n\n            # Convert to Cartesian velocity components and add to total field\n            # u_i = -u_theta * (y-yc)/r, v_i = u_theta * (x-xc)/r\n            u_i = np.zeros_like(r)\n            v_i = np.zeros_like(r)\n            u_i[r_nonzero] = -u_theta[r_nonzero] * ry[r_nonzero] / r[r_nonzero]\n            v_i[r_nonzero] = u_theta[r_nonzero] * rx[r_nonzero] / r[r_nonzero]\n            \n            u_total += u_i\n            v_total += v_i\n\n        # Compute vorticity using second-order finite differences\n        grad_v = np.gradient(v_total, dx, axis=1) # dv/dx\n        grad_u = np.gradient(u_total, dx, axis=0) # du/dy\n        omega_z = grad_v - grad_u\n\n        # Isosurface extraction\n        omega_max = np.max(omega_z) # All vortices are co-rotating\n        threshold = F_ISOSURFACE * omega_max\n        mask = omega_z >= threshold\n\n        # Connected components analysis\n        labels, num_labels = ndimage.label(mask)\n        \n        if num_labels != len(VORTEX_CENTERS):\n            # This would indicate an issue, e.g., vortex cores merging\n            # For this problem setup, this shouldn't happen.\n            # Handle gracefully if it does.\n            raise ValueError(f\"Expected {len(VORTEX_CENTERS)} vortices, but found {num_labels} for Re={re}\")\n\n        component_radii = []\n        # `center_of_mass` calculates centroids for specified labels\n        # index needs to be a list of labels to query\n        label_indices = np.arange(1, num_labels + 1)\n        # The input array is `mask` to get geometric centroids\n        centroids_pixels = ndimage.center_of_mass(mask, labels, label_indices)\n        centroids_phys = np.array([(c[1]*dx, c[0]*dx) for c in centroids_pixels])\n\n        for i in label_indices:\n            # Area = number of pixels * area of one pixel\n            area = np.sum(labels == i) * (dx**2)\n            radius = np.sqrt(area / np.pi)\n            component_radii.append(radius)\n        \n        mean_radii.append(np.mean(component_radii))\n\n        # Compute mean nearest-neighbor spacing\n        if num_labels > 1:\n            dist_matrix = squareform(pdist(centroids_phys))\n            np.fill_diagonal(dist_matrix, np.inf)\n            min_dists = np.min(dist_matrix, axis=1)\n            mean_spacings.append(np.mean(min_dists))\n        else:\n            mean_spacings.append(0.0) # Or NaN, but 0 makes sense\n\n    # Fit scaling laws: log(y) = log(k) - exponent * log(x)\n    # The slope of the line is -exponent.\n    log_re = np.log(RE_VALUES)\n    log_radii = np.log(mean_radii)\n    log_spacings = np.log(mean_spacings)\n\n    # Fit for alpha (radius scaling)\n    # polyfit returns [slope, intercept]\n    p_alpha = np.polyfit(log_re, log_radii, 1)\n    alpha = -p_alpha[0]\n\n    # Fit for beta (spacing scaling)\n    p_beta = np.polyfit(log_re, log_spacings, 1)\n    beta = -p_beta[0]\n\n    # Format output\n    results = []\n    results.append(f\"{alpha:.6f}\")\n    results.append(f\"{beta:.6f}\")\n    for r in mean_radii:\n        results.append(f\"{r:.6f}\")\n    for s in mean_spacings:\n        results.append(f\"{s:.6f}\")\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}