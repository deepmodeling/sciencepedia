{
    "hands_on_practices": [
        {
            "introduction": "The Lax Equivalence Theorem forms the bedrock of numerical analysis for partial differential equations, linking consistency and stability to convergence. We begin our hands-on exploration with a classic cautionary tale that illustrates the necessity of all parts of the theorem. This exercise challenges you to analyze the Forward-Time, Centered-Space (FTCS) scheme, a seemingly straightforward discretization of the advection equation. Through rigorous Taylor series and von Neumann analysis, you will prove that while the scheme is consistent, it is unconditionally unstable, providing a clear theoretical explanation for why consistency alone is insufficient for convergence.",
            "id": "3972027",
            "problem": "Consider the linear advection of a small-amplitude entropy perturbation in a one-dimensional compressible duct, modeled by the constant-coefficient scalar transport equation appropriate for Computational Fluid Dynamics (CFD),\n$$\nu_{t} + a\\,u_{x} = 0,\n$$\nwhere $a0$ is a constant advection speed, $u(t,x)$ is smooth, and the domain is periodic with spatial period $L$. Let the spatial grid be uniform with spacing $\\Delta x$, nodes $x_{j} = j\\,\\Delta x$, and time levels $t^{n} = n\\,\\Delta t$ with $\\Delta t0$. Consider the explicit forward Euler time integration combined with a centered finite difference approximation in space:\n$$\n\\frac{u^{n+1}_{j} - u^{n}_{j}}{\\Delta t} + a\\,\\frac{u^{n}_{j+1} - u^{n}_{j-1}}{2\\,\\Delta x} = 0,\n$$\nwhich is the forward-time, centered-space (FTCS) scheme. Define the Courant-Friedrichs-Lewy (CFL) number $\\nu = a\\,\\Delta t / \\Delta x$, and impose periodic boundary conditions so that discrete Fourier (von Neumann) analysis applies.\n\nStarting only from the governing transport equation and definitions of local truncation error, stability, and convergence for linear initial-value problems, perform the following:\n\n$1.$ Using Taylor expansions of the exact solution $u(t,x)$ in time and space, compute the leading-order expression for the local truncation error of the FTCS scheme and show that it vanishes as $\\Delta t \\to 0$ and $\\Delta x \\to 0$ for smooth $u(t,x)$, thereby establishing consistency.\n\n$2.$ For a discrete Fourier mode with wavenumber $k \\in \\mathbb{Z}$, angle $\\theta = k\\,\\Delta x$, and ansatz $u^{n}_{j} = \\hat{u}^{n}\\,\\exp\\!\\big(i\\,j\\,\\theta\\big)$, derive the von Neumann amplification factor $G(\\theta)$, defined by $\\hat{u}^{n+1} = G(\\theta)\\,\\hat{u}^{n}$.\n\n$3.$ Determine the supremum of the per-step amplification magnitude over all admissible Fourier angles,\n$$\n\\sup_{\\theta \\in [-\\pi,\\pi]} |G(\\theta)|,\n$$\nexpressed in closed form as a function of the CFL number $\\nu$.\n\n$4.$ Using the result of item $3$, analyze the mechanism by which numerical errors grow in time for fixed $\\nu0$ as the mesh is refined, and explain why the FTCS scheme fails to converge to the true solution even though the truncation error vanishes, in light of the Lax equivalence theorem.\n\nProvide your final answer as the single analytical expression for $\\sup_{\\theta \\in [-\\pi,\\pi]} |G(\\theta)|$ in terms of $\\nu$, with no rounding and no units.",
            "solution": "The problem presents a valid, well-posed exercise in the numerical analysis of partial differential equations, specifically concerning the Lax equivalence theorem as applied to the forward-time, centered-space (FTCS) scheme for the linear advection equation. We shall proceed by systematically addressing the four required components.\n\n$1.$ Derivation of the local truncation error and establishment of consistency.\n\nThe local truncation error, $\\tau$, is the residual obtained when the exact solution $u(t,x)$ of the governing partial differential equation (PDE) is substituted into the finite difference equation (FDE). The FDE is given by:\n$$\n\\frac{u^{n+1}_{j} - u^{n}_{j}}{\\Delta t} + a\\,\\frac{u^{n}_{j+1} - u^{n}_{j-1}}{2\\,\\Delta x} = 0\n$$\nLet $L_{\\Delta} u$ be the finite difference operator. The truncation error at a point $(t,x)$ is defined as $\\tau(t,x) = L_{\\Delta} u(t,x)$.\n$$\n\\tau(t,x) = \\frac{u(t+\\Delta t, x) - u(t, x)}{\\Delta t} + a\\,\\frac{u(t, x+\\Delta x) - u(t, x-\\Delta x)}{2\\,\\Delta x}\n$$\nWe use Taylor series to expand the terms $u(t+\\Delta t, x)$, $u(t, x+\\Delta x)$, and $u(t, x-\\Delta x)$ around the point $(t,x)$. Since $u(t,x)$ is assumed to be smooth, all necessary derivatives exist. Notationally, $u_t = \\frac{\\partial u}{\\partial t}$, $u_x = \\frac{\\partial u}{\\partial x}$, $u_{tt} = \\frac{\\partial^2 u}{\\partial t^2}$, $u_{xx} = \\frac{\\partial^2 u}{\\partial x^2}$, and so on.\n\nThe expansion in time is:\n$$\nu(t+\\Delta t, x) = u(t,x) + \\Delta t\\, u_t(t,x) + \\frac{(\\Delta t)^2}{2}\\,u_{tt}(t,x) + O((\\Delta t)^3)\n$$\nThe expansions in space are:\n$$\nu(t, x+\\Delta x) = u(t,x) + \\Delta x\\, u_x(t,x) + \\frac{(\\Delta x)^2}{2}\\,u_{xx}(t,x) + \\frac{(\\Delta x)^3}{6}\\,u_{xxx}(t,x) + O((\\Delta x)^4)\n$$\n$$\nu(t, x-\\Delta x) = u(t,x) - \\Delta x\\, u_x(t,x) + \\frac{(\\Delta x)^2}{2}\\,u_{xx}(t,x) - \\frac{(\\Delta x)^3}{6}\\,u_{xxx}(t,x) + O((\\Delta x)^4)\n$$\nSubstituting these expansions into the expression for $\\tau(t,x)$:\n$$\n\\tau(t,x) = \\frac{1}{\\Delta t} \\left( \\Delta t\\, u_t + \\frac{(\\Delta t)^2}{2}\\,u_{tt} + \\dots \\right) + \\frac{a}{2\\,\\Delta x} \\left( 2\\,\\Delta x\\, u_x + \\frac{2\\,(\\Delta x)^3}{6}\\,u_{xxx} + \\dots \\right)\n$$\nSimplifying the expression yields:\n$$\n\\tau(t,x) = \\left( u_t + \\frac{\\Delta t}{2}\\,u_{tt} + \\dots \\right) + a \\left( u_x + \\frac{(\\Delta x)^2}{6}\\,u_{xxx} + \\dots \\right)\n$$\nRearranging the terms:\n$$\n\\tau(t,x) = (u_t + a\\,u_x) + \\frac{\\Delta t}{2}\\,u_{tt} + a\\,\\frac{(\\Delta x)^2}{6}\\,u_{xxx} + \\text{H.O.T.}\n$$\nSince $u(t,x)$ is the exact solution to the governing PDE, we have $u_t + a\\,u_x = 0$. Thus, the first term vanishes. To express the truncation error in terms of spatial derivatives only, we differentiate the PDE:\n$u_t = -a\\,u_x$\n$u_{tt} = \\frac{\\partial}{\\partial t} (-a\\,u_x) = -a\\,\\frac{\\partial}{\\partial x}(u_t) = -a\\,\\frac{\\partial}{\\partial x}(-a\\,u_x) = a^2\\,u_{xx}$\nSubstituting this into the expression for $\\tau(t,x)$, the leading-order terms of the local truncation error are:\n$$\n\\tau(t,x) = \\frac{a^2\\,\\Delta t}{2}\\,u_{xx} + a\\,\\frac{(\\Delta x)^2}{6}\\,u_{xxx} + O((\\Delta t)^2) + O((\\Delta x)^4)\n$$\nThe scheme is first-order accurate in time and second-order accurate in space. For a smooth solution $u(t,x)$, the derivatives $u_{xx}$ and $u_{xxx}$ are bounded. As $\\Delta t \\to 0$ and $\\Delta x \\to 0$, the truncation error $\\tau \\to 0$. This demonstrates that the FTCS scheme is consistent with the linear advection equation.\n\n$2.$ Derivation of the von Neumann amplification factor $G(\\theta)$.\n\nWe perform a von Neumann stability analysis by substituting the Fourier mode ansatz $u^{n}_{j} = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)$ into the FTCS scheme. The scheme is first rearranged as:\n$$\nu^{n+1}_{j} = u^{n}_{j} - \\frac{a\\,\\Delta t}{2\\,\\Delta x} (u^{n}_{j+1} - u^{n}_{j-1})\n$$\nUsing the definition of the CFL number $\\nu = a\\,\\Delta t / \\Delta x$, this becomes:\n$$\nu^{n+1}_{j} = u^{n}_{j} - \\frac{\\nu}{2} (u^{n}_{j+1} - u^{n}_{j-1})\n$$\nSubstituting the ansatz:\n$$\n\\hat{u}^{n+1}\\,\\exp(i\\,j\\,\\theta) = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta) - \\frac{\\nu}{2} \\left( \\hat{u}^{n}\\,\\exp(i\\,(j+1)\\,\\theta) - \\hat{u}^{n}\\,\\exp(i\\,(j-1)\\,\\theta) \\right)\n$$\nDividing the entire equation by the common factor $\\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)$:\n$$\n\\frac{\\hat{u}^{n+1}}{\\hat{u}^{n}} = 1 - \\frac{\\nu}{2} \\left( \\exp(i\\,\\theta) - \\exp(-i\\,\\theta) \\right)\n$$\nThe amplification factor $G(\\theta)$ is defined as the ratio $\\hat{u}^{n+1}/\\hat{u}^{n}$. Using Euler's identity $\\sin(\\theta) = \\frac{\\exp(i\\,\\theta) - \\exp(-i\\,\\theta)}{2i}$, we can simplify the term in parentheses:\n$$\n\\exp(i\\,\\theta) - \\exp(-i\\,\\theta) = 2i\\,\\sin(\\theta)\n$$\nSubstituting this back, we obtain the amplification factor:\n$$\nG(\\theta) = 1 - \\frac{\\nu}{2} (2i\\,\\sin(\\theta)) = 1 - i\\,\\nu\\,\\sin(\\theta)\n$$\n\n$3.$ Determination of the supremum of the amplification magnitude.\n\nThe stability of the scheme depends on the magnitude of the amplification factor, $|G(\\theta)|$. For the complex number $G(\\theta) = 1 - i\\,\\nu\\,\\sin(\\theta)$, the magnitude is calculated as:\n$$\n|G(\\theta)| = \\sqrt{(\\text{Re}[G(\\theta)])^2 + (\\text{Im}[G(\\theta)])^2} = \\sqrt{1^2 + (-\\nu\\,\\sin(\\theta))^2} = \\sqrt{1 + \\nu^2\\,\\sin^2(\\theta)}\n$$\nWe need to find the supremum of this quantity over all admissible Fourier angles $\\theta \\in [-\\pi, \\pi]$. The value of $|G(\\theta)|$ is maximized when the term $\\sin^2(\\theta)$ is maximized. The maximum value of $\\sin^2(\\theta)$ is $1$, which occurs when $\\theta = \\pm \\pi/2$.\nTherefore, the supremum of the amplification magnitude is:\n$$\n\\sup_{\\theta \\in [-\\pi,\\pi]} |G(\\theta)| = \\sqrt{1 + \\nu^2 \\cdot \\max_{\\theta \\in [-\\pi,\\pi]}(\\sin^2(\\theta))} = \\sqrt{1 + \\nu^2 \\cdot 1} = \\sqrt{1 + \\nu^2}\n$$\n\n$4.$ Analysis of convergence in light of the Lax equivalence theorem.\n\nThe Lax equivalence theorem states that for a consistent linear numerical scheme applied to a well-posed linear initial-value problem, the scheme is convergent if and only if it is stable.\n\nIn part $1$, we established that the FTCS scheme is consistent with the linear advection equation, as its local truncation error vanishes as the grid is refined.\n\nIn part $3$, we determined the stability properties. The von Neumann stability criterion requires that $|G(\\theta)| \\le 1$ for all $\\theta$. Our result shows that the maximum amplification magnitude is $\\sup|G(\\theta)| = \\sqrt{1 + \\nu^2}$.\nThe problem specifies that $a  0$, $\\Delta t  0$, and $\\Delta x  0$. This implies that the CFL number $\\nu = a\\,\\Delta t / \\Delta x$ is strictly positive, i.e., $\\nu  0$.\nFor any $\\nu  0$, we have $\\nu^2  0$, which leads to $1 + \\nu^2  1$. Consequently, $\\sqrt{1 + \\nu^2}  1$.\nThis means that for any choice of $\\Delta t  0$ and $\\Delta x  0$, there always exists a Fourier mode (specifically, the mode with $\\theta = \\pm \\pi/2$, which represents the highest-frequency wave resolvable on the grid) whose amplitude is amplified at every time step. Thus, the condition $|G(\\theta)| \\le 1$ is violated, and the FTCS scheme is unconditionally unstable.\n\nThe mechanism for error growth is as follows: Any numerical error introduced at a given time step (e.g., from floating-point arithmetic or the truncation error itself) can be decomposed into a spectrum of Fourier modes. The high-frequency components of this error will be amplified by a factor greater than $1$ at each step. After $N$ time steps, the amplitude of such an error mode is multiplied by a factor of $|G(\\theta)|^N$. As the mesh is refined to achieve higher accuracy, one typically decreases $\\Delta t$. For a fixed simulation time $T$, the number of steps $N = T/\\Delta t$ increases. The error amplification over the full simulation, $|G(\\theta)|^{T/\\Delta t}$, grows exponentially without bound as $\\Delta t \\to 0$.\n\nIn conclusion, although the FTCS scheme is consistent (it correctly approximates the PDE at a single step), it is unconditionally unstable (errors grow uncontrollably over multiple steps). By the Lax equivalence theorem, a scheme that is consistent but not stable cannot be convergent. Therefore, the numerical solution produced by the FTCS scheme will diverge from the true solution as the simulation progresses, regardless of how fine the mesh is. This explains its failure to converge.",
            "answer": "$$\n\\boxed{\\sqrt{1+\\nu^{2}}}\n$$"
        },
        {
            "introduction": "Having theoretically established the unconditional instability of the FTCS scheme , the next step is to witness this mathematical prediction come to life. This coding practice guides you to implement the scheme and run a numerical experiment, providing a tangible demonstration of non-convergence. By observing how the numerical error behaves upon grid refinement, you will see firsthand how the amplification of high-frequency modes, predicted by the analysis where $|G(\\theta)| \\gt 1$, leads to a catastrophic failure of the simulation, reinforcing the critical role of stability.",
            "id": "3972054",
            "problem": "Consider the linear advection initial boundary value problem (IBVP) from Computational Fluid Dynamics (CFD): find a sufficiently smooth scalar field $u(x,t)$ such that\n$$\nu_t + a\\,u_x = 0 \\quad \\text{for } x \\in [0,1], \\ t \\ge 0,\n$$\nwith periodic boundary conditions $u(0,t) = u(1,t)$ and the initial condition\n$$\nu(x,0) = \\sin(2\\pi x) + \\tfrac{1}{2}\\cos(6\\pi x).\n$$\nHere $a  0$ is a constant advection speed. The exact solution is given by the translation\n$$\nu(x,t) = u_0(x - a t \\bmod 1).\n$$\nThe problem is to construct a minimal counterexample test that highlights the necessity of stability in the Lax equivalence theorem by implementing a time-marching finite difference method that is consistent but unstable, and then demonstrate numerically that it does not converge as the grid is refined.\n\nUse the forward-time centered-space (FTCS) scheme on a uniform grid with $N$ points, grid spacing $\\Delta x = 1/N$, and a time step chosen using the Courant–Friedrichs–Lewy (CFL) number $\\text{CFL} \\in (0,1)$ as\n$$\n\\Delta t \\approx \\frac{\\text{CFL}\\,\\Delta x}{a},\n$$\nadjusted so that the final time $T$ is reached exactly after an integer number of time steps. Denote $\\sigma = a \\,\\Delta t / \\Delta x$. The FTCS update is\n$$\nu_j^{n+1} = u_j^n - \\frac{\\sigma}{2} \\left( u_{j+1}^n - u_{j-1}^n \\right),\n$$\nwith periodic indexing. The numerical solution at time $T$ is compared to the exact solution $u(x,T)$ sampled on the grid, and the error is measured in the discrete $L^2$ norm\n$$\n\\| e \\|_2 = \\left( \\Delta x \\sum_{j=0}^{N-1} \\left( u_j^{\\text{num}}(T) - u_j^{\\text{exact}}(T) \\right)^2 \\right)^{1/2}.\n$$\nNo physical units are required because the problem is non-dimensional; angles are implicitly in radians.\n\nYour task is to implement the FTCS scheme described above and, for each test scenario below, compute the discrete $L^2$ errors for the three grid resolutions $N \\in \\{50, 100, 200\\}$. For each scenario, also determine a boolean flag that is true if and only if the error strictly decreases as $N$ increases (i.e., $E_{100}  E_{50}$ and $E_{200}  E_{100}$), and false otherwise. This flag is the numerical indicator of convergence under refinement for that scenario.\n\nTest suite:\n- Scenario $1$ (happy path): $a = 1.0$, $T = 0.2$, $\\text{CFL} = 0.8$.\n- Scenario $2$ (boundary case in short time): $a = 1.0$, $T = 0.01$, $\\text{CFL} = 0.8$.\n- Scenario $3$ (edge case with very small CFL): $a = 1.0$, $T = 0.2$, $\\text{CFL} = 0.1$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one entry per scenario. Each scenario’s entry must itself be a bracketed, comma-separated list containing four items in order: the three discrete $L^2$ errors for $N = 50, 100, 200$, followed by the convergence flag. For example, the output format must be\n$ [ [E_{50}^{(1)}, E_{100}^{(1)}, E_{200}^{(1)}, \\text{flag}^{(1)}], [E_{50}^{(2)}, E_{100}^{(2)}, E_{200}^{(2)}, \\text{flag}^{(2)}], [E_{50}^{(3)}, E_{100}^{(3)}, E_{200}^{(3)}, \\text{flag}^{(3)}] ]. $\nAll numerical outputs must be real numbers (floats) or booleans, and the final output must be a single line exactly as specified.",
            "solution": "The user-provided problem is a valid exercise in computational science. It asks for a numerical demonstration of the consequences of violating the stability condition in the Lax Equivalence Theorem for finite difference schemes. The problem is scientifically grounded, well-posed, and all parameters and methods are defined unambiguously.\n\nThe core of the problem is the linear advection equation:\n$$ u_t + a u_x = 0 $$\nfor a scalar field $u(x,t)$ on the spatial domain $x \\in [0,1]$ with periodic boundary conditions. The initial condition is given by $u(x,0) = u_0(x) = \\sin(2\\pi x) + \\frac{1}{2}\\cos(6\\pi x)$. The exact solution is a simple translation of the initial profile: $u(x,t) = u_0(x - a t \\pmod 1)$.\n\nThe problem specifies the use of the Forward-Time Centered-Space (FTCS) finite difference scheme. For a uniform grid with spacing $\\Delta x$ and a time step $\\Delta t$, the scheme approximates the PDE as:\n$$ \\frac{u_j^{n+1} - u_j^n}{\\Delta t} + a \\frac{u_{j+1}^n - u_{j-1}^n}{2 \\Delta x} = 0 $$\nwhere $u_j^n \\approx u(j\\Delta x, n\\Delta t)$. This can be rearranged into an explicit update rule:\n$$ u_j^{n+1} = u_j^n - \\frac{\\sigma}{2} (u_{j+1}^n - u_{j-1}^n) $$\nHere, $\\sigma$ is the Courant number, defined as $\\sigma = a \\Delta t / \\Delta x$.\n\nThe Lax Equivalence Theorem states that for a linear, well-posed initial value problem, a consistent finite difference scheme converges if and only if it is stable.\n*   **Consistency**: The FTCS scheme is consistent with the advection equation. A Taylor series expansion reveals that its local truncation error is of order $O(\\Delta t, \\Delta x^2)$.\n*   **Stability**: The stability can be analyzed using the von Neumann method. We seek a solution of the form $u_j^n = G^n e^{i k x_j}$, where $k$ is the wavenumber and $G$ is the amplification factor. Substituting this into the FTCS scheme yields:\n$$ G = 1 - \\frac{\\sigma}{2} (e^{i k \\Delta x} - e^{-i k \\Delta x}) = 1 - i \\sigma \\sin(k \\Delta x) $$\nFor stability, the magnitude of the amplification factor $|G|$ must not exceed $1$ for all possible wavenumbers. The magnitude squared is:\n$$ |G|^2 = 1^2 + (-\\sigma \\sin(k \\Delta x))^2 = 1 + \\sigma^2 \\sin^2(k \\Delta x) $$\nFor any non-zero $\\sigma$ and any $k\\Delta x$ that is not an integer multiple of $\\pi$, $|G|^2  1$. This means that error components (especially high-frequency ones) will be amplified at each time step, leading to exponential growth. The scheme is therefore unconditionally unstable for the pure advection problem.\n\nAccording to the Lax Equivalence Theorem, since the FTCS scheme is consistent but unstable, it will not converge as the grid is refined. The numerical experiment is designed to demonstrate this lack of convergence.\n\nThe implementation plan is as follows:\n1.  For each test scenario $(a, T, \\text{CFL})$, we iterate through the grid resolutions $N \\in \\{50, 100, 200\\}$.\n2.  For each $N$, we establish the grid with $\\Delta x = 1/N$ and points $x_j = j \\Delta x$.\n3.  The number of time steps, $N_t$, is determined to match the final time $T$ exactly. We estimate $N_t \\approx aTN/\\text{CFL}$ and then take the ceiling: $N_t = \\lceil aTN/\\text{CFL} \\rceil$. The time step is then $\\Delta t = T/N_t$.\n4.  The initial state $u^0$ is set by sampling $u_0(x)$ on the grid.\n5.  The state is advanced $N_t$ times using the FTCS update rule. The periodic boundary conditions are handled by cyclic array indexing.\n6.  The final numerical solution $u^{\\text{num}}(T)$ is compared to the exact solution $u^{\\text{exact}}(T)$ sampled on the same grid. The error is quantified using the discrete $L^2$ norm:\n    $$ \\| e \\|_2 = \\left( \\Delta x \\sum_{j=0}^{N-1} \\left( u_j^{\\text{num}}(T) - u_j^{\\text{exact}}(T) \\right)^2 \\right)^{1/2} $$\n7.  After calculating the errors for all three values of $N$, a convergence flag is set. It is `True` if the error strictly decreases with each refinement ($E_{100}  E_{50}$ and $E_{200}  E_{100}$) and `False` otherwise. Due to the instability, we generally expect this flag to be `False`, except possibly in cases with a very short simulation time $T$ where the exponential error growth has not yet overwhelmed the reduction in truncation error.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef run_scenario(a, T, CFL, N_vals):\n    \"\"\"\n    Runs the FTCS simulation for a given scenario and a list of grid resolutions.\n\n    Args:\n        a (float): Advection speed.\n        T (float): Final time.\n        CFL (float): CFL number to determine time step.\n        N_vals (list of int): List of grid resolutions (number of points).\n\n    Returns:\n        list: A list containing the L2 errors for each resolution and the convergence flag.\n    \"\"\"\n    errors = []\n    \n    # Initial condition function\n    def u_initial(x):\n        return np.sin(2 * np.pi * x) + 0.5 * np.cos(6 * np.pi * x)\n\n    # Exact solution function\n    def u_exact(x, t):\n        # The modulo operator correctly handles the periodicity for x-at\n        return u_initial((x - a * t) % 1.0)\n\n    for N in N_vals:\n        # Spatial grid setup\n        dx = 1.0 / N\n        x = np.linspace(0, 1, N, endpoint=False)\n\n        # Time step setup\n        # Adjust dt so that T is reached in an integer number of steps\n        Nt_approx = a * T * N / CFL\n        Nt = int(math.ceil(Nt_approx))\n        # Handle case where Nt is 0 for very small T\n        if Nt == 0:\n            Nt = 1 \n        dt = T / Nt\n        \n        # Courant number\n        sigma = a * dt / dx\n\n        # Set initial condition\n        u = u_initial(x)\n\n        # Time-marching loop\n        for n in range(Nt):\n            u_prev = u.copy()\n            # Implement periodic boundaries using numpy.roll\n            u_plus_1 = np.roll(u_prev, -1)\n            u_minus_1 = np.roll(u_prev, 1)\n            \n            # FTCS update\n            u = u_prev - (sigma / 2.0) * (u_plus_1 - u_minus_1)\n\n        # Calculate exact solution at time T\n        u_ex = u_exact(x, T)\n\n        # Calculate discrete L2 error\n        error_vec = u - u_ex\n        l2_error = np.sqrt(dx * np.sum(error_vec**2))\n        errors.append(l2_error)\n\n    # Check for convergence: error must strictly decrease with refinement\n    is_convergent = (errors[1]  errors[0]) and (errors[2]  errors[1])\n\n    return [errors[0], errors[1], errors[2], is_convergent]\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the specified test suite.\n    \"\"\"\n    test_cases = [\n        {'a': 1.0, 'T': 0.2, 'CFL': 0.8},  # Scenario 1\n        {'a': 1.0, 'T': 0.01, 'CFL': 0.8}, # Scenario 2\n        {'a': 1.0, 'T': 0.2, 'CFL': 0.1},  # Scenario 3\n    ]\n    \n    N_values = [50, 100, 200]\n    \n    results = []\n    for case in test_cases:\n        scenario_result = run_scenario(case['a'], case['T'], case['CFL'], N_values)\n        results.append(scenario_result)\n\n    # Format the output string as per the requirements\n    # e.g., [[err1,err2,err3,flag], [err1,err2,err3,flag]]\n    result_strings = []\n    for res in results:\n        # str(bool) gives 'True' or 'False' as required\n        inner_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\"\n        result_strings.append(inner_str)\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "To complete our practical investigation of the Lax Equivalence Theorem, we now pivot from a case of failure to examples of success. This exercise focuses on implementing schemes that are known to be stable, such as the first-order upwind and second-order Lax-Wendroff methods. By performing a systematic grid convergence study, you will empirically verify the \"if\" part of the theorem: for a scheme that is both consistent and stable, the numerical solution converges to the exact solution as the grid is refined. This practice demonstrates the standard process of code verification and confirms that the numerical error decreases at the rate predicted by theory.",
            "id": "3972105",
            "problem": "Consider the one-dimensional linear advection initial value problem, a canonical model in Computational Fluid Dynamics (CFD) for passive transport, given by the partial differential equation $u_t + a u_x = 0$ on the periodic domain $x \\in [0,1]$, with smooth periodic initial data $u(x,0) = u_0(x)$ and advection speed $a  0$. Under the Lax equivalence theorem for linear initial value problems, stability together with consistency implies convergence. In this problem, you will empirically verify convergence orders through a grid halving study for stable, consistent finite difference schemes and a prescribed Courant-Friedrichs-Lewy (CFL) number.\n\nYou must implement two linear, explicit finite difference schemes on a uniform grid of $N$ cells with spacing $\\Delta x = 1/N$ and periodic boundary conditions:\n- First-order upwind (for $a  0$): $u_i^{n+1} = u_i^n - \\nu \\left( u_i^n - u_{i-1}^n \\right)$,\n- Second-order Lax–Wendroff: $u_i^{n+1} = u_i^n - \\nu \\dfrac{u_{i+1}^n - u_{i-1}^n}{2} + \\dfrac{\\nu^2}{2} \\left( u_{i+1}^n - 2 u_i^n + u_{i-1}^n \\right)$,\n\nwhere $\\nu = \\dfrac{a \\Delta t}{\\Delta x}$ is the prescribed Courant-Friedrichs-Lewy (CFL) number, $\\Delta t$ is the time step, and indices are periodic with $u_{-1}^n \\equiv u_{N-1}^n$ and $u_N^n \\equiv u_0^n$. For each grid, advance the numerical solution to final time $T$ using $N_t$ time steps with $\\Delta t$ chosen to satisfy the desired $\\nu$ and $N_t$ chosen as the nearest integer to $T/\\Delta t$. At the attained final time $t_f = N_t \\Delta t$, compute the exact solution $u_{\\text{exact}}(x,t_f) = u_0\\big((x - a t_f) \\bmod 1\\big)$, and then evaluate the discrete error in a chosen norm.\n\nYour program must:\n- Implement both schemes above and enforce periodic boundary conditions.\n- For each test case, perform a grid halving (doubling $N$) study across a sequence of $N$ values, compute the error at $t_f$ in a specified norm, and estimate the observed order of convergence $p$ by fitting $\\log(E) = \\alpha + p \\log(\\Delta x)$, where $E$ is the error magnitude in the chosen norm.\n- Use the following norms:\n  - Discrete $L^2$ norm: $||e||_{L^2} = \\sqrt{\\sum_i e_i^2 \\Delta x}$,\n  - Discrete $L^\\infty$ norm: $||e||_{L^\\infty} = \\max_i |e_i|$.\n- Confirm whether the observed order is within a specified tolerance of the predicted order for the scheme and norm.\n\nUse dimensionless units throughout. Angles, if any, must be expressed in radians. All outputs must be dimensionless floats or booleans.\n\nTest suite and parameters:\n- Case $1$ (happy path): scheme is Lax–Wendroff, $a = 1$, $\\nu = 0.5$, norm $L^2$, $T = 1$, $u_0(x) = \\sin(2\\pi x)$, $N \\in \\{50, 100, 200, 400\\}$, predicted order $p_{\\text{pred}} = 2$ with tolerance $\\tau = 0.15$.\n- Case $2$ (near CFL boundary for first order): scheme is upwind, $a = 1$, $\\nu = 0.95$, norm $L^2$, $T = 1$, $u_0(x) = \\sin(2\\pi x) + 0.5 \\sin(4\\pi x)$, $N \\in \\{50, 100, 200, 400\\}$, predicted order $p_{\\text{pred}} = 1$ with tolerance $\\tau = 0.20$.\n- Case $3$ (near CFL boundary in $L^\\infty$): scheme is Lax–Wendroff, $a = 1$, $\\nu = 0.9$, norm $L^\\infty$, $T = 1$, $u_0(x) = \\cos(2\\pi x) - 0.25 \\sin(6\\pi x)$, $N \\in \\{64, 128, 256, 512\\}$, predicted order $p_{\\text{pred}} = 2$ with tolerance $\\tau = 0.20$.\n\nFinal output specification:\n- For each of the three cases, compute the estimated order $p$ as a float and a boolean indicating whether $|p - p_{\\text{pred}}| \\le \\tau$.\n- Your program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, ordered as $[p_1, b_1, p_2, b_2, p_3, b_3]$, where $p_k$ are floats and $b_k$ are booleans.\n\nNo external input is permitted; all parameters are fixed as above within the program.",
            "solution": "The problem statement poses a valid and well-defined exercise in numerical analysis, specifically within the field of computational fluid dynamics (CFD). It asks for an empirical verification of the convergence orders of two standard finite difference schemes for the one-dimensional linear advection equation. All provided parameters, equations, and conditions are scientifically sound, internally consistent, and sufficient for deriving a unique solution. The problem is a classic academic task designed to illustrate the practical implications of the Lax equivalence theorem, which states that for a consistent linear scheme, stability is the necessary and sufficient condition for convergence. The problem is therefore deemed valid.\n\nHere, we present a systematic solution to the problem.\n\n### 1. Governing Equation and Numerical Discretization\n\nThe physical process is modeled by the linear advection equation:\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\non a periodic domain $x \\in [0, 1]$, with a constant advection speed $a  0$ and a given smooth initial condition $u(x,0) = u_0(x)$. The exact solution is a simple translation of the initial profile: $u_{\\text{exact}}(x,t) = u_0(x-at)$. On a periodic domain of length $1$, this becomes $u_{\\text{exact}}(x,t) = u_0((x-at) \\pmod 1)$.\n\nWe discretize the spatial domain into $N$ uniform cells, with grid points $x_i = i \\Delta x$ for $i = 0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = 1/N$. The time domain is discretized with a constant time step $\\Delta t$. We denote the numerical approximation of $u(x_i, t_n)$ as $u_i^n$, where $t_n = n \\Delta t$.\n\nThe Courant-Friedrichs-Lewy (CFL) number, $\\nu$, is a dimensionless parameter that relates the grid and time step sizes to the advection speed:\n$$\n\\nu = \\frac{a \\Delta t}{\\Delta x}\n$$\nFor a fixed $\\nu$, the time step $\\Delta t$ is determined by the spatial grid: $\\Delta t = \\nu \\Delta x / a$. The simulation runs up to a target final time $T$. The number of time steps, $N_t$, is chosen as the nearest integer to $T/\\Delta t$, i.e., $N_t = \\text{round}(T/\\Delta t)$. The actual final time of the simulation is then $t_f = N_t \\Delta t$.\n\n### 2. Finite Difference Schemes\n\nThe problem specifies two explicit finite difference schemes.\n\n**First-Order Upwind Scheme (for $a0$):**\nThis scheme uses a one-sided difference for the spatial derivative, biased against the direction of wave propagation (`upwind`). Its update rule is:\n$$\nu_i^{n+1} = u_i^n - \\nu (u_i^n - u_{i-1}^n)\n$$\nThis scheme is first-order accurate in both space and time, denoted as $\\mathcal{O}(\\Delta x, \\Delta t)$, and is stable for $0 \\le \\nu \\le 1$.\n\n**Second-Order Lax-Wendroff Scheme:**\nThis scheme is derived from a Taylor series expansion in time and is designed to be second-order accurate. Its update rule is:\n$$\nu_i^{n+1} = u_i^n - \\frac{\\nu}{2} (u_{i+1}^n - u_{i-1}^n) + \\frac{\\nu^2}{2} (u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\nThis scheme is second-order accurate, $\\mathcal{O}(\\Delta x^2, \\Delta t^2)$, and is stable for $|\\nu| \\le 1$.\n\nPeriodic boundary conditions are enforced by identifying grid points $i$ modulo $N$. Specifically, $u_{-1}^n \\equiv u_{N-1}^n$ and $u_N^n \\equiv u_0^n$.\n\n### 3. Error Measurement and Convergence Order\n\nTo assess the accuracy of a scheme, we compare the numerical solution at the final time, $u_i^{N_t}$, with the exact solution, $u_{\\text{exact}}(x_i, t_f)$. The error at each grid point is $e_i = u_i^{N_t} - u_{\\text{exact}}(x_i, t_f)$. We quantify the total error using a chosen norm.\n\n**Discrete $L^2$ Norm:**\n$$\n||e||_{L^2} = \\sqrt{\\sum_{i=0}^{N-1} e_i^2 \\Delta x}\n$$\n\n**Discrete $L^\\infty$ Norm (Maximum Norm):**\n$$\n||e||_{L^\\infty} = \\max_{0 \\le i  N} |e_i|\n$$\n\nThe theoretical order of convergence, $p$, relates the error $E$ to the grid spacing $\\Delta x$ by the asymptotic relationship $E \\approx C (\\Delta x)^p$ for some constant $C$, as $\\Delta x \\to 0$. To estimate $p$ empirically, we perform a grid halving study. We compute the error $E_k$ for a sequence of decreasing grid spacings $\\Delta x_k$ (corresponding to an increasing sequence of $N_k$). Taking the logarithm of the error relationship yields a linear equation:\n$$\n\\log(E) \\approx \\log(C) + p \\log(\\Delta x)\n$$\nThe observed order of convergence, $p$, is the slope of the best-fit line to the data points $(\\log(\\Delta x_k), \\log(E_k))$. This slope can be determined using linear regression.\n\n### 4. Computational Procedure\n\nFor each test case specified in the problem, the following procedure is executed:\n1. An array of grid point counts, $N_{list}$, is defined.\n2. For each $N$ in $N_{list}$:\n    a. The grid spacing $\\Delta x = 1/N$ and the spatial grid $x_i$ are created.\n    b. The time step $\\Delta t = \\nu \\Delta x / a$ is calculated.\n    c. The number of time steps $N_t = \\text{round}(T / \\Delta t)$ and the final time $t_f = N_t \\Delta t$ are determined.\n    d. The initial state vector, $u^0$, is computed by evaluating $u_0(x_i)$.\n    e. The simulation is advanced for $N_t$ time steps using the specified scheme (upwind or Lax-Wendroff), applying periodic boundary conditions at each step.\n    f. The exact solution vector at $t_f$ is computed.\n    g. The error vector is calculated, and its magnitude is measured using the specified norm ($L^2$ or $L^\\infty$). This error value $E$ is stored along with the corresponding $\\Delta x$.\n3. After completing the loop over all $N$, a set of $(\\Delta x_k, E_k)$ pairs is obtained.\n4. The natural logarithms of these values, $(\\log(\\Delta x_k), \\log(E_k))$, are computed.\n5. A linear regression is performed on the log-transformed data to find the slope, which is our estimated order of convergence, $p$.\n6. Finally, the condition $|p - p_{\\text{pred}}| \\le \\tau$ is evaluated to produce a boolean result, confirming if the observed order matches the theoretical prediction within the given tolerance $\\tau$.\n\nThis rigorous process is applied to all three test cases to generate the required final output.",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    \n    # --- Scheme Implementations ---\n    def upwind_step(u, nu):\n        \"\"\"\n        Computes one time step of the first-order upwind scheme.\n        Assumes a  0.\n        u_{i-1} is implemented with np.roll(u, 1).\n        \"\"\"\n        return u - nu * (u - np.roll(u, 1))\n\n    def lax_wendroff_step(u, nu):\n        \"\"\"\n        Computes one time step of the second-order Lax-Wendroff scheme.\n        u_{i-1} is np.roll(u, 1), u_{i+1} is np.roll(u, -1).\n        \"\"\"\n        u_p1 = np.roll(u, -1)\n        u_m1 = np.roll(u, 1)\n        central_diff = (u_p1 - u_m1) / 2.0\n        diffusion_term = u_p1 - 2.0 * u + u_m1\n        return u - nu * central_diff + (nu**2 / 2.0) * diffusion_term\n    \n    # --- Norm Implementations ---\n    def l2_norm(error_vec, dx):\n        \"\"\"Computes the discrete L2 norm.\"\"\"\n        return np.sqrt(np.sum(error_vec**2) * dx)\n\n    def linf_norm(error_vec, dx):\n        \"\"\"Computes the discrete L-infinity norm.\"\"\"\n        return np.max(np.abs(error_vec))\n\n    # --- Convergence Study Runner ---\n    def run_convergence_study(params):\n        \"\"\"\n        Performs a grid-halving study for a given set of parameters.\n        \"\"\"\n        scheme_name = params['scheme']\n        a = params['a']\n        nu = params['nu']\n        T = params['T']\n        u0_func = params['u0']\n        N_list = params['N_list']\n        norm_name = params['norm']\n        p_pred = params['p_pred']\n        tolerance = params['tau']\n\n        if scheme_name == 'upwind':\n            scheme_func = upwind_step\n        else: # 'lax-wendroff'\n            scheme_func = lax_wendroff_step\n\n        if norm_name == 'L2':\n            norm_func = l2_norm\n        else: # 'Linf'\n            norm_func = linf_norm\n\n        errors = []\n        dx_values = []\n        \n        for N in N_list:\n            # 1. Setup grid and time step\n            dx = 1.0 / N\n            x = np.linspace(0, 1.0, N, endpoint=False)\n            dt = nu * dx / a\n            \n            # Use np.round for nearest integer as specified\n            Nt = int(np.round(T / dt))\n            tf = Nt * dt\n            \n            # 2. Initial condition\n            u = u0_func(x)\n            \n            # 3. Time evolution\n            for _ in range(Nt):\n                u = scheme_func(u, nu)\n            \n            # 4. Compute error\n            # Exact solution at final time tf\n            u_exact = u0_func((x - a * tf) % 1.0)\n            error_vec = u - u_exact\n            \n            # 5. Compute norm\n            error_norm = norm_func(error_vec, dx)\n            \n            errors.append(error_norm)\n            dx_values.append(dx)\n\n        # 6. Estimate convergence order p via linear regression on log-log data\n        log_dx = np.log(dx_values)\n        log_E = np.log(errors)\n        \n        # Use scipy.stats.linregress to get the slope\n        regression_result = linregress(log_dx, log_E)\n        p_observed = regression_result.slope\n        \n        # 7. Check if observed order is within tolerance\n        is_converged_as_predicted = np.abs(p_observed - p_pred) = tolerance\n\n        return p_observed, is_converged_as_predicted\n\n    # --- Test Case Definitions ---\n    test_cases = [\n        {\n            'name': 'Case 1',\n            'scheme': 'lax-wendroff', 'a': 1.0, 'nu': 0.5, 'norm': 'L2', 'T': 1.0,\n            'u0': lambda x: np.sin(2 * np.pi * x),\n            'N_list': [50, 100, 200, 400],\n            'p_pred': 2.0, 'tau': 0.15\n        },\n        {\n            'name': 'Case 2',\n            'scheme': 'upwind', 'a': 1.0, 'nu': 0.95, 'norm': 'L2', 'T': 1.0,\n            'u0': lambda x: np.sin(2 * np.pi * x) + 0.5 * np.sin(4 * np.pi * x),\n            'N_list': [50, 100, 200, 400],\n            'p_pred': 1.0, 'tau': 0.20\n        },\n        {\n            'name': 'Case 3',\n            'scheme': 'lax-wendroff', 'a': 1.0, 'nu': 0.9, 'norm': 'Linf', 'T': 1.0,\n            'u0': lambda x: np.cos(2 * np.pi * x) - 0.25 * np.sin(6 * np.pi * x),\n            'N_list': [64, 128, 256, 512],\n            'p_pred': 2.0, 'tau': 0.20\n        }\n    ]\n\n    # --- Run all cases and collect results ---\n    final_results = []\n    for case in test_cases:\n        p, b = run_convergence_study(case)\n        final_results.extend([p, b])\n\n    # --- Format and print the final output ---\n    # Convert booleans to lowercase 'true'/'false' for standard output, though\n    # default str() would be 'True'/'False'. Both are clear. We use str() as is.\n    result_str = ','.join(map(str, final_results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}