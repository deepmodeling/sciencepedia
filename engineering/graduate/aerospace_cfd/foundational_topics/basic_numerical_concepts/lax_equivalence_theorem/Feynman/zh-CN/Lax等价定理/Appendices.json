{
    "hands_on_practices": [
        {
            "introduction": "本练习将指导你完成冯·诺依曼稳定性分析，这是计算流体力学中的一项基石技术。通过推导一阶迎风格式的放大因子，你将确定其稳定性的精确数学条件——即库朗-弗里德里希斯-路维（CFL）条件。此练习旨在让你深入理解稳定性分析如何直接影响时间步长等实际仿真参数的选择。",
            "id": "3972090",
            "problem": "考虑一维线性平流方程，这是航空航天流动输运建模中计算流体力学（CFD）的一个标准构建模块，\n$$\nu_{t} + a\\,u_{x} = 0,\n$$\n其中 $a>0$ 是一个恒定的对流速度。你在一个均匀网格 $x_{j} = j\\,\\Delta x$ 和时间层 $t^{n} = n\\,\\Delta t$ 上对该方程进行离散化，时间上使用前向欧拉离散，空间上使用适用于 $a>0$ 的一阶迎风离散。假设边界条件是周期性的，因此傅里叶表示是可行的。\n\n从控制方程和所述离散化方案出发，通过代入单个傅里叶模态 $u_{j}^{n} = \\hat{u}^{n}\\exp(i\\,j\\,\\theta)$（其中 $\\theta \\in [-\\pi,\\pi]$）来进行冯·诺伊曼傅里叶分析。推导离散放大因子 $G(\\theta)$，然后通过施加条件 $|G(\\theta)| \\le 1$ 对所有 $\\theta \\in [-\\pi,\\pi]$ 来确定稳定区域。援引Lax等价定理（LET）来解释在给定格式与平流方程一致的情况下，你的稳定性结论与收敛性之间的关系。\n\n作为你的最终答案，报告以 $a$ 和 $\\Delta x$ 表示的最大允许时间步长 $\\Delta t_{\\max}$ 的闭式解析表达式。以秒为单位表示最终答案。无需数值取整；给出精确表达式。",
            "solution": "问题要求对应用于一维线性平流方程的特定有限差分格式进行数值稳定性分析。我们将通过冯·诺伊曼分析来确定稳定性约束，然后使用Lax等价定理将其与数值解的收敛性联系起来。\n\n控制偏微分方程（PDE）是线性平流方程：\n$$\nu_{t} + a\\,u_{x} = 0\n$$\n其中 $u(x,t)$ 是被输运的量，而 $a>0$ 是恒定的波速。\n\n问题指定了离散化方法：\n1.  **时间导数 ($u_t$)**：前向欧拉格式。在均匀时间网格 $t^n = n \\Delta t$ 上，其近似为：\n    $$\n    u_t \\approx \\frac{u_j^{n+1} - u_j^n}{\\Delta t}\n    $$\n    其中上标 $n$ 表示时间层，下标 $j$ 表示空间网格点。\n\n2.  **空间导数 ($u_x$)**：一阶迎风格式。对于 $a>0$，波从左向右传播，因此我们使用来自“迎风”方向（即较小的 $x$）的信息。在均匀空间网格 $x_j = j \\Delta x$ 上，其近似为：\n    $$\n    u_x \\approx \\frac{u_j^n - u_{j-1}^n}{\\Delta x}\n    $$\n\n将这些近似代入偏微分方程，得到完全离散的方程：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} + a \\left( \\frac{u_j^n - u_{j-1}^n}{\\Delta x} \\right) = 0\n$$\n我们重新整理此方程以求解下一个时间步的解 $u_j^{n+1}$：\n$$\nu_j^{n+1} = u_j^n - \\frac{a \\Delta t}{\\Delta x} (u_j^n - u_{j-1}^n)\n$$\n让我们定义库朗数 $C$，它是一个无量纲量，表示在单个时间步内，物理波传播的距离与单个网格间距之比：\n$$\nC = \\frac{a \\Delta t}{\\Delta x}\n$$\n离散方程可以更紧凑地写为：\n$$\nu_j^{n+1} = u_j^n - C(u_j^n - u_{j-1}^n) = (1-C)u_j^n + C u_{j-1}^n\n$$\n这就是我们必须进行稳定性分析的有限差分格式。\n\n接下来，我们进行冯·诺伊曼稳定性分析。我们假设解具有单个傅里叶模态的形式：\n$$\nu_j^n = \\hat{u}^n \\exp(i j \\theta)\n$$\n其中 $\\hat{u}^n$ 是在时间层 $n$ 的模态振幅，$i = \\sqrt{-1}$ 是虚数单位，$\\theta = k \\Delta x$ 是无量纲波数，其中 $k$ 是波数。对于周期性域，$\\theta$ 的范围是 $[-\\pi, \\pi]$。\n将此形式代入我们的离散方程中：\n$$\n\\hat{u}^{n+1} \\exp(i j \\theta) = (1-C) \\hat{u}^n \\exp(i j \\theta) + C \\hat{u}^n \\exp(i (j-1) \\theta)\n$$\n我们可以提出因子 $\\exp(i j \\theta)$：\n$$\n\\hat{u}^{n+1} \\exp(i j \\theta) = \\left[ (1-C) + C \\exp(-i \\theta) \\right] \\hat{u}^n \\exp(i j \\theta)\n$$\n除以 $\\hat{u}^n \\exp(i j \\theta)$（假设非平凡解），我们得到放大因子 $G(\\theta)$ 的表达式，该因子是傅里叶模态的振幅在单个时间步内相乘的系数：\n$$\nG(\\theta) = \\frac{\\hat{u}^{n+1}}{\\hat{u}^n} = 1 - C + C \\exp(-i \\theta)\n$$\n使用欧拉公式 $\\exp(-i \\theta) = \\cos(\\theta) - i \\sin(\\theta)$，我们可以用其实部和虚部来表示 $G(\\theta)$：\n$$\nG(\\theta) = (1 - C + C \\cos(\\theta)) - i (C \\sin(\\theta))\n$$\n为使数值格式稳定，任何傅里叶模态的振幅都不能随时间增长。这要求放大因子的模对于所有可能的 $\\theta$ 值都小于或等于1：\n$$\n|G(\\theta)| \\le 1 \\quad \\forall \\theta \\in [-\\pi, \\pi]\n$$\n我们可以通过检查模的平方 $|G(\\theta)|^2$ 来分析这个条件：\n$$\n|G(\\theta)|^2 = (\\operatorname{Re}(G))^2 + (\\operatorname{Im}(G))^2\n$$\n$$\n|G(\\theta)|^2 = (1 - C + C \\cos(\\theta))^2 + (-C \\sin(\\theta))^2\n$$\n$$\n|G(\\theta)|^2 = (1 - C(1 - \\cos(\\theta)))^2 + C^2 \\sin^2(\\theta)\n$$\n$$\n|G(\\theta)|^2 = 1 - 2C(1 - \\cos(\\theta)) + C^2(1 - \\cos(\\theta))^2 + C^2 \\sin^2(\\theta)\n$$\n$$\n|G(\\theta)|^2 = 1 - 2C(1 - \\cos(\\theta)) + C^2(1 - 2\\cos(\\theta) + \\cos^2(\\theta)) + C^2 \\sin^2(\\theta)\n$$\n使用恒等式 $\\cos^2(\\theta) + \\sin^2(\\theta) = 1$：\n$$\n|G(\\theta)|^2 = 1 - 2C(1 - \\cos(\\theta)) + C^2(1 - 2\\cos(\\theta) + 1)\n$$\n$$\n|G(\\theta)|^2 = 1 - 2C(1 - \\cos(\\theta)) + 2C^2(1 - \\cos(\\theta))\n$$\n$$\n|G(\\theta)|^2 = 1 + (2C^2 - 2C)(1 - \\cos(\\theta))\n$$\n稳定性条件 $|G(\\theta)|^2 \\le 1$ 变为：\n$$\n1 + (2C^2 - 2C)(1 - \\cos(\\theta)) \\le 1\n$$\n$$\n(2C^2 - 2C)(1 - \\cos(\\theta)) \\le 0\n$$\n$$\n2C(C - 1)(1 - \\cos(\\theta)) \\le 0\n$$\n我们分析这个不等式中的各项。根据定义，$a>0$, $\\Delta t>0$, 且 $\\Delta x>0$，所以库朗数 $C \\ge 0$。项 $(1 - \\cos(\\theta))$ 总是非负的，因为 $\\cos(\\theta) \\le 1$。因此，为了使不等式对所有 $\\theta$ 都成立，项 $2C(C-1)$ 必须是非正的。由于 $C \\ge 0$，这要求：\n$$\nC - 1 \\le 0 \\implies C \\le 1\n$$\n结合这些条件，该格式的稳定区域是 $0 \\le C \\le 1$。\n\nLax等价定理（LET）指出，对于一个线性初值问题，一个一致的有限差分格式是收敛的，当且仅当它是稳定的。问题说明该格式是一致的。对截断误差的简要检查证实，该格式在时间和空间上都是一阶精确的，$O(\\Delta t, \\Delta x)$，因此是一致的（当 $\\Delta t, \\Delta x \\to 0$ 时，截断误差趋于零）。\n\n因此，根据Lax等价定理，我们的数值解将收敛到偏微分方程的真解，当且仅当满足稳定性准则。稳定性准则是：\n$$\n0 \\le \\frac{a \\Delta t}{\\Delta x} \\le 1\n$$\n我们被要求求出最大允许时间步长 $\\Delta t_{\\max}$，它对应于此稳定范围的上界：\n$$\n\\frac{a \\Delta t_{\\max}}{\\Delta x} = 1\n$$\n解出 $\\Delta t_{\\max}$ 得到：\n$$\n\\Delta t_{\\max} = \\frac{\\Delta x}{a}\n$$\n这是该显式格式的Courant-Friedrichs-Lewy（CFL）条件。它的物理解释是，在单个时间步内，数值依赖域必须包含物理依赖域。在一个时间步 $\\Delta t$ 内，波传播的距离为 $a \\Delta t$。为了使格式能正确捕捉波的传播，这个距离不能大于空间网格间距 $\\Delta x$。该表达式具有时间的单位（例如，如果 $\\Delta x$ 以米为单位，而 $a$ 以米/秒为单位，则单位为秒），符合要求。",
            "answer": "$$\n\\boxed{\\frac{\\Delta x}{a}}\n$$"
        },
        {
            "introduction": "Lax等价定理指出，对于一个适定问题，一个相容的差分格式收敛的充要条件是其稳定性。本练习通过一个著名的反例——前向时间中心空间（FTCS）格式——来凸显“稳定性”这一条件的必要性。你将通过编程实现这个虽然相容但无条件不稳定的格式，并亲眼观察到网格加密时，数值解非但没有收敛到真解，反而发散了。",
            "id": "3972054",
            "problem": "考虑来自计算流体动力学 (CFD) 的线性平流初边值问题 (IBVP)：寻找一个足够光滑的标量场 $u(x,t)$，使得\n$$\nu_t + a\\,u_x = 0 \\quad \\text{for } x \\in [0,1], \\ t \\ge 0,\n$$\n其边界条件为周期性边界条件 $u(0,t) = u(1,t)$，初始条件为\n$$\nu(x,0) = \\sin(2\\pi x) + \\tfrac{1}{2}\\cos(6\\pi x).\n$$\n此处 $a > 0$ 是一个恒定的平流速度。其精确解由平移给出：\n$$\nu(x,t) = u_0(x - a t \\bmod 1).\n$$\n本问题旨在构建一个最小反例测试，通过实现一个一致但不稳定的时间推进有限差分法，来凸显 Lax 等价定理中稳定性的必要性，并数值上证明该方法在网格加密时并不收敛。\n\n在具有 $N$ 个点、网格间距为 $\\Delta x = 1/N$ 的均匀网格上使用前向时间中心空间 (FTCS) 格式，并使用 Courant–Friedrichs–Lewy (CFL) 数 $\\text{CFL} \\in (0,1)$ 来选择时间步长，如下所示：\n$$\n\\Delta t \\approx \\frac{\\text{CFL}\\,\\Delta x}{a},\n$$\n并进行调整，以确保在整数个时间步后恰好达到最终时间 $T$。记 $\\sigma = a \\,\\Delta t / \\Delta x$。FTCS 的更新方式为：\n$$\nu_j^{n+1} = u_j^n - \\frac{\\sigma}{2} \\left( u_{j+1}^n - u_{j-1}^n \\right),\n$$\n其中索引是周期性的。将时间 $T$ 的数值解与在网格上采样的精确解 $u(x,T)$ 进行比较，误差通过离散 $L^2$ 范数度量：\n$$\n\\| e \\|_2 = \\left( \\Delta x \\sum_{j=0}^{N-1} \\left( u_j^{\\text{num}}(T) - u_j^{\\text{exact}}(T) \\right)^2 \\right)^{1/2}.\n$$\n由于该问题是无量纲的，因此不需要物理单位；角度隐式地以弧度为单位。\n\n您的任务是实现上述 FTCS 格式，并对以下每个测试场景，计算三种网格分辨率 $N \\in \\{50, 100, 200\\}$ 下的离散 $L^2$ 误差。对于每个场景，还需确定一个布尔标志：当且仅当误差随着 $N$ 的增加而严格减小（即 $E_{100}  E_{50}$ 且 $E_{200}  E_{100}$）时，该标志为真，否则为假。此标志是该场景在网格加密情况下的收敛性数值指标。\n\n测试套件：\n- 场景 1 (理想情况)：$a = 1.0$, $T = 0.2$, $\\text{CFL} = 0.8$。\n- 场景 2 (短时间内的边界情况)：$a = 1.0$, $T = 0.01$, $\\text{CFL} = 0.8$。\n- 场景 3 (CFL 非常小的边缘情况)：$a = 1.0$, $T = 0.2$, $\\text{CFL} = 0.1$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个场景对应一个条目。每个场景的条目本身必须是一个由方括号括起来的逗号分隔列表，按顺序包含四个项目：三个分别对应 $N = 50, 100, 200$ 的离散 $L^2$ 误差，以及随后的收敛标志。例如，输出格式必须为：\n$$\n[ [E_{50}^{(1)}, E_{100}^{(1)}, E_{200}^{(1)}, \\text{flag}^{(1)}], [E_{50}^{(2)}, E_{100}^{(2)}, E_{200}^{(2)}, \\text{flag}^{(2)}], [E_{50}^{(3)}, E_{100}^{(3)}, E_{200}^{(3)}, \\text{flag}^{(3)}] ].\n$$\n所有数值输出必须是实数（浮点数）或布尔值，且最终输出必须是与规定完全一致的单行。",
            "solution": "用户提供的问题是计算科学领域的一个有效练习。它要求对违反有限差分格式中 Lax 等价定理的稳定性条件所产生的后果进行数值演示。该问题具有科学依据，是适定的，并且所有参数和方法都得到了明确的定义。\n\n该问题的核心是线性平流方程：\n$$ u_t + a u_x = 0 $$\n适用于空间域 $x \\in [0,1]$ 上具有周期性边界条件的标量场 $u(x,t)$。初始条件由 $u(x,0) = u_0(x) = \\sin(2\\pi x) + \\frac{1}{2}\\cos(6\\pi x)$ 给出。精确解是初始剖面的一个简单平移：$u(x,t) = u_0(x - a t \\pmod 1)$。\n\n问题指定使用前向时间中心空间 (FTCS) 有限差分格式。对于间距为 $\\Delta x$ 的均匀网格和时间步长 $\\Delta t$，该格式将偏微分方程 (PDE) 近似为：\n$$ \\frac{u_j^{n+1} - u_j^n}{\\Delta t} + a \\frac{u_{j+1}^n - u_{j-1}^n}{2 \\Delta x} = 0 $$\n其中 $u_j^n \\approx u(j\\Delta x, n\\Delta t)$。这可以重排为一个显式更新规则：\n$$ u_j^{n+1} = u_j^n - \\frac{\\sigma}{2} (u_{j+1}^n - u_{j-1}^n) $$\n此处，$\\sigma$ 是 Courant 数，定义为 $\\sigma = a \\Delta t / \\Delta x$。\n\nLax 等价定理指出，对于一个线性的、适定的初值问题，一个一致的有限差分格式是收敛的，当且仅当它是稳定的。\n*   **一致性**：FTCS 格式与平流方程是一致的。泰勒级数展开表明其局部截断误差为 $O(\\Delta t, \\Delta x^2)$ 阶。\n*   **稳定性**：其稳定性可以使用冯·诺依曼方法进行分析。我们寻找形如 $u_j^n = G^n e^{i k x_j}$ 的解，其中 $k$ 是波数，$G$ 是放大因子。将此代入 FTCS 格式可得：\n$$ G = 1 - \\frac{\\sigma}{2} (e^{i k \\Delta x} - e^{-i k \\Delta x}) = 1 - i \\sigma \\sin(k \\Delta x) $$\n为了保证稳定性，放大因子 $G$ 的模 $|G|$ 对于所有可能的波数都不能超过 1。其模的平方为：\n$$ |G|^2 = 1^2 + (-\\sigma \\sin(k \\Delta x))^2 = 1 + \\sigma^2 \\sin^2(k \\Delta x) $$\n对于任何非零的 $\\sigma$ 和任何不是 $\\pi$ 整数倍的 $k\\Delta x$，都有 $|G|^2  1$。这意味着误差分量（特别是高频分量）将在每个时间步被放大，导致指数级增长。因此，该格式对于纯平流问题是无条件不稳定的。\n\n根据 Lax 等价定理，由于 FTCS 格式是一致但不稳定的，它在网格加密时不会收敛。本数值实验旨在证明这种不收敛性。\n\n实施计划如下：\n1.  对于每个测试场景 $(a, T, \\text{CFL})$，我们遍历网格分辨率 $N \\in \\{50, 100, 200\\}$。\n2.  对于每个 $N$，我们建立网格，其网格间距为 $\\Delta x = 1/N$，网格点为 $x_j = j \\Delta x$。\n3.  确定时间步数 $N_t$，以精确匹配最终时间 $T$。我们估计 $N_t \\approx aTN/\\text{CFL}$，然后取其上整：$N_t = \\lceil aTN/\\text{CFL} \\rceil$。则时间步长为 $\\Delta t = T/N_t$。\n4.  通过在网格上采样 $u_0(x)$ 来设置初始状态 $u^0$。\n5.  使用 FTCS 更新规则将状态推进 $N_t$ 次。周期性边界条件通过循环数组索引来处理。\n6.  将最终数值解 $u^{\\text{num}}(T)$ 与在同一网格上采样的精确解 $u^{\\text{exact}}(T)$ 进行比较。误差使用离散 $L^2$ 范数量化：\n    $$ \\| e \\|_2 = \\left( \\Delta x \\sum_{j=0}^{N-1} \\left( u_j^{\\text{num}}(T) - u_j^{\\text{exact}}(T) \\right)^2 \\right)^{1/2} $$\n7.  在计算出所有三个 $N$ 值的误差后，设置一个收敛标志。如果误差随着每次加密而严格减小（$E_{100}  E_{50}$ 且 $E_{200}  E_{100}$），则该标志为 `True`，否则为 `False`。由于不稳定性，我们通常预期此标志为 `False`，除非在模拟时间 $T$ 非常短的情况下，指数级的误差增长尚未超过截断误差的减少。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef run_scenario(a, T, CFL, N_vals):\n    \"\"\"\n    Runs the FTCS simulation for a given scenario and a list of grid resolutions.\n\n    Args:\n        a (float): Advection speed.\n        T (float): Final time.\n        CFL (float): CFL number to determine time step.\n        N_vals (list of int): List of grid resolutions (number of points).\n\n    Returns:\n        list: A list containing the L2 errors for each resolution and the convergence flag.\n    \"\"\"\n    errors = []\n    \n    # Initial condition function\n    def u_initial(x):\n        return np.sin(2 * np.pi * x) + 0.5 * np.cos(6 * np.pi * x)\n\n    # Exact solution function\n    def u_exact(x, t):\n        # The modulo operator correctly handles the periodicity for x-at\n        return u_initial((x - a * t) % 1.0)\n\n    for N in N_vals:\n        # Spatial grid setup\n        dx = 1.0 / N\n        x = np.linspace(0, 1, N, endpoint=False)\n\n        # Time step setup\n        # Adjust dt so that T is reached in an integer number of steps\n        Nt_approx = a * T * N / CFL\n        Nt = int(math.ceil(Nt_approx))\n        # Handle case where Nt is 0 for very small T\n        if Nt == 0:\n            Nt = 1 \n        dt = T / Nt\n        \n        # Courant number\n        sigma = a * dt / dx\n\n        # Set initial condition\n        u = u_initial(x)\n\n        # Time-marching loop\n        for n in range(Nt):\n            u_prev = u.copy()\n            # Implement periodic boundaries using numpy.roll\n            u_plus_1 = np.roll(u_prev, -1)\n            u_minus_1 = np.roll(u_prev, 1)\n            \n            # FTCS update\n            u = u_prev - (sigma / 2.0) * (u_plus_1 - u_minus_1)\n\n        # Calculate exact solution at time T\n        u_ex = u_exact(x, T)\n\n        # Calculate discrete L2 error\n        error_vec = u - u_ex\n        l2_error = np.sqrt(dx * np.sum(error_vec**2))\n        errors.append(l2_error)\n\n    # Check for convergence: error must strictly decrease with refinement\n    is_convergent = (errors[1]  errors[0]) and (errors[2]  errors[1])\n\n    return [errors[0], errors[1], errors[2], is_convergent]\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the specified test suite.\n    \"\"\"\n    test_cases = [\n        {'a': 1.0, 'T': 0.2, 'CFL': 0.8},  # Scenario 1\n        {'a': 1.0, 'T': 0.01, 'CFL': 0.8}, # Scenario 2\n        {'a': 1.0, 'T': 0.2, 'CFL': 0.1},  # Scenario 3\n    ]\n    \n    N_values = [50, 100, 200]\n    \n    results = []\n    for case in test_cases:\n        scenario_result = run_scenario(case['a'], case['CFL'], case['T'], N_values)\n        results.append(scenario_result)\n\n    # Format the output string as per the requirements\n    # e.g., [[err1,err2,err3,flag], [err1,err2,err3,flag]]\n    result_strings = []\n    for res in results:\n        # str(bool) gives 'True' or 'False' as required\n        inner_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\"\n        result_strings.append(inner_str)\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在见证了一个不稳定格式的失败之后，本练习将展示稳定格式如何成功兑现 Lax 等价定理的承诺。你将实现两种广泛应用的稳定格式——一阶迎风格式和二阶 Lax-Wendroff 格式，并进行网格收敛性研究。通过计算和验证它们各自的收敛阶，你将获得关于数值精度和误差如何随网格尺度变化的直观和定量的认识。",
            "id": "3972105",
            "problem": "考虑一维线性平流初值问题，这是计算流体动力学（CFD）中用于被动输运的一个典范模型，由偏微分方程 $u_t + a u_x = 0$ 在周期性域 $x \\in [0,1]$ 上给出，具有光滑的周期性初始数据 $u(x,0) = u_0(x)$ 和平流速度 $a  0$。根据线性初值问题的 Lax 等价定理，稳定性与相容性共同蕴含收敛性。在本问题中，您将通过网格减半研究，对稳定的、相容的有限差分格式，在指定的 Courant-Friedrichs-Lewy (CFL) 数下，经验性地验证其收敛阶。\n\n您必须在包含 $N$ 个单元的均匀网格上实现两种线性显式有限差分格式，网格间距为 $\\Delta x = 1/N$，并采用周期性边界条件：\n- 一阶迎风格式（适用于 $a  0$）：$u_i^{n+1} = u_i^n - \\nu \\left( u_i^n - u_{i-1}^n \\right)$，\n- 二阶 Lax–Wendroff 格式：$u_i^{n+1} = u_i^n - \\nu \\dfrac{u_{i+1}^n - u_{i-1}^n}{2} + \\dfrac{\\nu^2}{2} \\left( u_{i+1}^n - 2 u_i^n + u_{i-1}^n \\right)$，\n\n其中 $\\nu = \\dfrac{a \\Delta t}{\\Delta x}$ 是指定的 Courant-Friedrichs-Lewy (CFL) 数，$\\Delta t$ 是时间步长，且下标是周期性的，满足 $u_{-1}^n \\equiv u_{N-1}^n$ 和 $u_N^n \\equiv u_0^n$。对于每个网格，使用 $N_t$ 个时间步将数值解推进到最终时刻 $T$，其中 $\\Delta t$ 的选择要满足所需的 $\\nu$ 值，而 $N_t$ 则取为与 $T/\\Delta t$ 最接近的整数。在达到的最终时刻 $t_f = N_t \\Delta t$，计算精确解 $u_{\\text{exact}}(x,t_f) = u_0\\big((x - a t_f) \\bmod 1\\big)$，然后用选定的范数评估离散误差。\n\n您的程序必须：\n- 实现上述两种格式并施加周期性边界条件。\n- 对每个测试用例，在一系列 $N$ 值上进行网格减半（即 $N$ 值加倍）研究，计算在 $t_f$ 时刻指定范数下的误差，并通过拟合 $\\log(E) = \\alpha + p \\log(\\Delta x)$ 来估计观测到的收敛阶 $p$，其中 $E$ 是选定范数下的误差大小。\n- 使用以下范数：\n  - 离散 $L^2$ 范数：$||e||_{L^2} = \\sqrt{\\sum_i e_i^2 \\Delta x}$，\n  - 离散 $L^\\infty$ 范数：$||e||_{L^\\infty} = \\max_i |e_i|$。\n- 确认观测到的阶数是否在格式和范数所对应的预测阶数的指定容差范围内。\n\n全程使用无量纲单位。若有角度，必须以弧度表示。所有输出必须是无量纲的浮点数或布尔值。\n\n测试套件和参数：\n- 用例 1（理想情况）：格式为 Lax–Wendroff， $a = 1$，$\\nu = 0.5$，范数为 $L^2$，$T = 1$，$u_0(x) = \\sin(2\\pi x)$，$N \\in \\{50, 100, 200, 400\\}$，预测阶 $p_{\\text{pred}} = 2$，容差 $\\tau = 0.15$。\n- 用例 2（接近一阶格式的 CFL 边界）：格式为迎风格式，$a = 1$，$\\nu = 0.95$，范数为 $L^2$，$T = 1$，$u_0(x) = \\sin(2\\pi x) + 0.5 \\sin(4\\pi x)$，$N \\in \\{50, 100, 200, 400\\}$，预测阶 $p_{\\text{pred}} = 1$，容差 $\\tau = 0.20$。\n- 用例 3（在 $L^\\infty$ 范数下接近 CFL 边界）：格式为 Lax–Wendroff，$a = 1$，$\\nu = 0.9$，范数为 $L^\\infty$，$T = 1$，$u_0(x) = \\cos(2\\pi x) - 0.25 \\sin(6\\pi x)$，$N \\in \\{64, 128, 256, 512\\}$，预测阶 $p_{\\text{pred}} = 2$，容差 $\\tau = 0.20$。\n\n最终输出规范：\n- 对于三个用例中的每一个，计算估计阶 $p$（浮点数）和一个布尔值，该布尔值指示是否满足 $|p - p_{\\text{pred}}| \\le \\tau$。\n- 您的程序应生成单行输出，其中包含六个结果，形式为方括号括起来的逗号分隔列表，顺序为 $[p_1, b_1, p_2, b_2, p_3, b_3]$，其中 $p_k$ 是浮点数，$b_k$ 是布尔值。\n\n不允许任何外部输入；所有参数均如上所述在程序内部固定。",
            "solution": "该问题陈述提出了一个在数值分析领域，特别是在计算流体动力学（CFD）领域内，有效且定义明确的练习。它要求对一维线性平流方程的两种标准有限差分格式的收敛阶进行经验性验证。所有提供的参数、方程和条件在科学上都是合理的、内部一致的，并且足以推导出唯一的解。该问题是一个经典的学术任务，旨在阐明 Lax 等价定理的实际意义，该定理指出：对于一个相容的线性格式，稳定性是其收敛的充分必要条件。因此，该问题被认为是有效的。\n\n在此，我们提出对该问题的系统性解决方案。\n\n### 1. 控制方程与数值离散化\n\n该物理过程由线性平流方程建模：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\n在周期性域 $x \\in [0, 1]$ 上，具有恒定的平流速度 $a  0$ 和给定的光滑初始条件 $u(x,0) = u_0(x)$。精确解是初始剖面的简单平移：$u_{\\text{exact}}(x,t) = u_0(x-at)$。在长度为 1 的周期性域上，这变为 $u_{\\text{exact}}(x,t) = u_0((x-at) \\pmod 1)$。\n\n我们将空间域离散化为 $N$ 个均匀单元，网格点为 $x_i = i \\Delta x$，$i = 0, 1, \\dots, N-1$，其中网格间距为 $\\Delta x = 1/N$。时间域以恒定的时间步长 $\\Delta t$ 进行离散化。我们将 $u(x_i, t_n)$ 的数值近似表示为 $u_i^n$，其中 $t_n = n \\Delta t$。\n\nCourant-Friedrichs-Lewy (CFL) 数 $\\nu$ 是一个无量纲参数，它将网格和时间步长的大小与平流速度关联起来：\n$$\n\\nu = \\frac{a \\Delta t}{\\Delta x}\n$$\n对于一个固定的 $\\nu$，时间步长 $\\Delta t$ 由空间网格决定：$\\Delta t = \\nu \\Delta x / a$。模拟运行至目标最终时刻 $T$。时间步数 $N_t$ 取为与 $T/\\Delta t$ 最接近的整数，即 $N_t = \\text{round}(T/\\Delta t)$。模拟的实际最终时刻则为 $t_f = N_t \\Delta t$。\n\n### 2. 有限差分格式\n\n该问题指定了两种显式有限差分格式。\n\n**一阶迎风格式（适用于 $a0$）：**\n此格式对空间导数使用单边差分，其方向逆着波的传播方向（即“迎风”）。其更新规则是：\n$$\nu_i^{n+1} = u_i^n - \\nu (u_i^n - u_{i-1}^n)\n$$\n该格式在空间和时间上均为一阶精度，记作 $\\mathcal{O}(\\Delta x, \\Delta t)$，并且在 $0 \\le \\nu \\le 1$ 时是稳定的。\n\n**二阶 Lax-Wendroff 格式：**\n该格式由时间上的泰勒级数展开推导而来，旨在达到二阶精度。其更新规则是：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\nu}{2} (u_{i+1}^n - u_{i-1}^n) + \\frac{\\nu^2}{2} (u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\n该格式为二阶精度，$\\mathcal{O}(\\Delta x^2, \\Delta t^2)$，并且在 $|\\nu| \\le 1$ 时是稳定的。\n\n通过对网格点下标 $i$ 对 $N$ 取模来施加周期性边界条件。具体来说，$u_{-1}^n \\equiv u_{N-1}^n$ 且 $u_N^n \\equiv u_0^n$。\n\n### 3. 误差测量与收敛阶\n\n为评估格式的精度，我们将最终时刻的数值解 $u_i^{N_t}$ 与精确解 $u_{\\text{exact}}(x_i, t_f)$进行比较。每个网格点上的误差为 $e_i = u_i^{N_t} - u_{\\text{exact}}(x_i, t_f)$。我们使用选定的范数量化总误差。\n\n**离散 $L^2$ 范数：**\n$$\n||e||_{L^2} = \\sqrt{\\sum_{i=0}^{N-1} e_i^2 \\Delta x}\n$$\n\n**离散 $L^\\infty$ 范数（最大范数）：**\n$$\n||e||_{L^\\infty} = \\max_{0 \\le i  N} |e_i|\n$$\n\n理论收敛阶 $p$ 通过渐近关系 $E \\approx C (\\Delta x)^p$ 将误差 $E$ 与网格间距 $\\Delta x$ 联系起来，其中 $C$ 为某个常数，且该关系在 $\\Delta x \\to 0$ 时成立。为经验性地估计 $p$，我们进行网格减半研究。我们为一系列递减的网格间距 $\\Delta x_k$（对应于一系列递增的 $N_k$）计算误差 $E_k$。对误差关系式两边取对数，可得到一个线性方程：\n$$\n\\log(E) \\approx \\log(C) + p \\log(\\Delta x)\n$$\n观测到的收敛阶 $p$ 是数据点 $(\\log(\\Delta x_k), \\log(E_k))$ 的最佳拟合线的斜率。该斜率可以通过线性回归确定。\n\n### 4. 计算流程\n\n对于问题中指定的每个测试用例，执行以下流程：\n1. 定义一个包含网格点数量的数组 $N_{list}$。\n2. 对于 $N_{list}$ 中的每个 $N$：\n    a. 创建网格间距 $\\Delta x = 1/N$ 和空间网格 $x_i$。\n    b. 计算时间步长 $\\Delta t = \\nu \\Delta x / a$。\n    c. 确定时间步数 $N_t = \\text{round}(T / \\Delta t)$ 和最终时刻 $t_f = N_t \\Delta t$。\n    d. 通过计算 $u_0(x_i)$ 来得到初始状态向量 $u^0$。\n    e. 使用指定的格式（迎风或 Lax-Wendroff）将模拟推进 $N_t$ 个时间步，并在每一步施加周期性边界条件。\n    f. 计算在 $t_f$ 时刻的精确解向量。\n    g. 计算误差向量，并使用指定的范数（$L^2$ 或 $L^\\infty$）测量其大小。将此误差值 $E$ 与相应的 $\\Delta x$ 一同存储。\n3. 在完成对所有 $N$ 的循环后，获得一组 $(\\Delta x_k, E_k)$ 对。\n4. 计算这些值的自然对数，即 $(\\log(\\Delta x_k), \\log(E_k))$。\n5. 对经过对数变换的数据进行线性回归，以找到斜率，即我们估计的收敛阶 $p$。\n6. 最后，评估条件 $|p - p_{\\text{pred}}| \\le \\tau$ 以生成一个布尔结果，确认观测阶是否在给定的容差 $\\tau$ 内与理论预测相符。\n\n将此严谨的流程应用于所有三个测试用例，以生成所需的最终输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    \n    # --- Scheme Implementations ---\n    def upwind_step(u, nu):\n        \"\"\"\n        Computes one time step of the first-order upwind scheme.\n        Assumes a  0.\n        u_{i-1} is implemented with np.roll(u, 1).\n        \"\"\"\n        return u - nu * (u - np.roll(u, 1))\n\n    def lax_wendroff_step(u, nu):\n        \"\"\"\n        Computes one time step of the second-order Lax-Wendroff scheme.\n        u_{i-1} is np.roll(u, 1), u_{i+1} is np.roll(u, -1).\n        \"\"\"\n        u_p1 = np.roll(u, -1)\n        u_m1 = np.roll(u, 1)\n        central_diff = (u_p1 - u_m1) / 2.0\n        diffusion_term = u_p1 - 2.0 * u + u_m1\n        return u - nu * central_diff + (nu**2 / 2.0) * diffusion_term\n    \n    # --- Norm Implementations ---\n    def l2_norm(error_vec, dx):\n        \"\"\"Computes the discrete L2 norm.\"\"\"\n        return np.sqrt(np.sum(error_vec**2) * dx)\n\n    def linf_norm(error_vec, dx):\n        \"\"\"Computes the discrete L-infinity norm.\"\"\"\n        return np.max(np.abs(error_vec))\n\n    # --- Convergence Study Runner ---\n    def run_convergence_study(params):\n        \"\"\"\n        Performs a grid-halving study for a given set of parameters.\n        \"\"\"\n        scheme_name = params['scheme']\n        a = params['a']\n        nu = params['nu']\n        T = params['T']\n        u0_func = params['u0']\n        N_list = params['N_list']\n        norm_name = params['norm']\n        p_pred = params['p_pred']\n        tolerance = params['tau']\n\n        if scheme_name == 'upwind':\n            scheme_func = upwind_step\n        else: # 'lax-wendroff'\n            scheme_func = lax_wendroff_step\n\n        if norm_name == 'L2':\n            norm_func = l2_norm\n        else: # 'Linf'\n            norm_func = linf_norm\n\n        errors = []\n        dx_values = []\n        \n        for N in N_list:\n            # 1. Setup grid and time step\n            dx = 1.0 / N\n            x = np.linspace(0, 1.0, N, endpoint=False)\n            dt = nu * dx / a\n            \n            # Use np.round for nearest integer as specified\n            Nt = int(np.round(T / dt))\n            tf = Nt * dt\n            \n            # 2. Initial condition\n            u = u0_func(x)\n            \n            # 3. Time evolution\n            for _ in range(Nt):\n                u = scheme_func(u, nu)\n            \n            # 4. Compute error\n            # Exact solution at final time tf\n            u_exact = u0_func((x - a * tf) % 1.0)\n            error_vec = u - u_exact\n            \n            # 5. Compute norm\n            error_norm = norm_func(error_vec, dx)\n            \n            errors.append(error_norm)\n            dx_values.append(dx)\n\n        # 6. Estimate convergence order p via linear regression on log-log data\n        log_dx = np.log(dx_values)\n        log_E = np.log(errors)\n        \n        # Use scipy.stats.linregress to get the slope\n        regression_result = linregress(log_dx, log_E)\n        p_observed = regression_result.slope\n        \n        # 7. Check if observed order is within tolerance\n        is_converged_as_predicted = np.abs(p_observed - p_pred) = tolerance\n\n        return p_observed, is_converged_as_predicted\n\n    # --- Test Case Definitions ---\n    test_cases = [\n        {\n            'name': 'Case 1',\n            'scheme': 'lax-wendroff', 'a': 1.0, 'nu': 0.5, 'norm': 'L2', 'T': 1.0,\n            'u0': lambda x: np.sin(2 * np.pi * x),\n            'N_list': [50, 100, 200, 400],\n            'p_pred': 2.0, 'tau': 0.15\n        },\n        {\n            'name': 'Case 2',\n            'scheme': 'upwind', 'a': 1.0, 'nu': 0.95, 'norm': 'L2', 'T': 1.0,\n            'u0': lambda x: np.sin(2 * np.pi * x) + 0.5 * np.sin(4 * np.pi * x),\n            'N_list': [50, 100, 200, 400],\n            'p_pred': 1.0, 'tau': 0.20\n        },\n        {\n            'name': 'Case 3',\n            'scheme': 'lax-wendroff', 'a': 1.0, 'nu': 0.9, 'norm': 'Linf', 'T': 1.0,\n            'u0': lambda x: np.cos(2 * np.pi * x) - 0.25 * np.sin(6 * np.pi * x),\n            'N_list': [64, 128, 256, 512],\n            'p_pred': 2.0, 'tau': 0.20\n        }\n    ]\n\n    # --- Run all cases and collect results ---\n    final_results = []\n    for case in test_cases:\n        p, b = run_convergence_study(case)\n        final_results.extend([p, b])\n\n    # --- Format and print the final output ---\n    # Convert booleans to lowercase 'true'/'false' for standard output, though\n    # default str() would be 'True'/'False'. Both are clear. We use str() as is.\n    result_str = ','.join(map(str, final_results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}