{
    "hands_on_practices": [
        {
            "introduction": "A fundamental skill in the analysis of numerical methods is the ability to derive a scheme and quantify its local accuracy. This exercise provides practice in this core competency by tasking you with constructing a high-order approximation for the Laplacian operator, a key component in models for viscous diffusion. By systematically using Taylor series expansions, you will not only determine the necessary stencil coefficients but also derive the scheme's leading truncation error, giving you a direct measure of its order of accuracy .",
            "id": "3982491",
            "problem": "Aerospace Computational Fluid Dynamics (CFD) simulations often require high-fidelity discretizations of viscous diffusion operators to control numerical dissipation and resolve thin boundary layers. Consider a one-dimensional, sufficiently smooth function $u(x)$ describing the streamwise component of velocity along a line in a laminar boundary-layer calculation, defined on a uniform grid with spacing $h$ and nodes $x_i = x_0 + i h$. You are tasked with constructing a fourth-order accurate finite-difference approximation to the one-dimensional Laplacian (second derivative) operator using a symmetric $5$-point stencil centered at $x_i$. \n\nStarting from the Taylor series expansion of $u(x)$ about $x_i$ for the points $x_{i \\pm h}$ and $x_{i \\pm 2 h}$, and enforcing consistency with the continuous second derivative operator at leading order, derive the unique symmetric $5$-point stencil that yields a fourth-order accurate approximation to $u''(x_i)$. Then, using the same Taylor expansion framework, derive the truncation error and explicitly determine the coefficient multiplying the term $h^4 u^{(6)}(x_i)$ in the truncation error series of your discrete Laplacian.\n\nYour final reported quantity must be the single real-valued coefficient that multiplies $h^4 u^{(6)}(x_i)$ in the truncation error. Express the coefficient as an exact rational number. No rounding is required. Do not include units.",
            "solution": "The problem requires the derivation of a fourth-order accurate, symmetric, $5$-point finite-difference approximation for the second derivative $u''(x_i)$, and the subsequent determination of the coefficient of the leading term in its truncation error.\n\nLet the uniform grid spacing be $h$. The approximation for the second derivative at the node $x_i$, which we denote as $L_h u_i$, is a linear combination of function values at five symmetric points: $x_{i-2}$, $x_{i-1}$, $x_i$, $x_{i+1}$, and $x_{i+2}$. We can write this approximation as:\n$$\nL_h u_i = \\frac{1}{h^2} \\left[ c_{-2} u(x_{i-2}) + c_{-1} u(x_{i-1}) + c_0 u(x_i) + c_1 u(x_{i+1}) + c_2 u(x_{i+2}) \\right]\n$$\nFor a symmetric stencil, the coefficients must satisfy $c_{-k} = c_k$. Thus, we have $c_{-1} = c_1$ and $c_{-2} = c_2$.\n\nTo determine the coefficients $c_0$, $c_1$, and $c_2$, we use Taylor series expansions of $u(x)$ around the point $x_i$. For a sufficiently smooth function $u(x)$, we have:\n$$\nu(x_{i+k}) = u(x_i + kh) = \\sum_{n=0}^{\\infty} \\frac{(kh)^n}{n!} u^{(n)}(x_i)\n$$\nwhere $u^{(n)}(x_i)$ is the $n$-th derivative of $u$ at $x_i$.\n\nSubstituting these expansions into the formula for $L_h u_i$:\n$$\nL_h u_i = \\frac{1}{h^2} \\sum_{k=-2}^{2} c_k \\left( \\sum_{n=0}^{\\infty} \\frac{(kh)^n}{n!} u^{(n)}(x_i) \\right)\n$$\nBy interchanging the order of summation, we get:\n$$\nL_h u_i = \\sum_{n=0}^{\\infty} \\left[ \\frac{h^{n-2}}{n!} \\sum_{k=-2}^{2} c_k k^n \\right] u^{(n)}(x_i)\n$$\nWe want our approximation $L_h u_i$ to be equal to $u''(x_i)$ with an error of order $O(h^4)$. This means we need to match the terms in the expansion to the expression $u''(x_i) + O(h^4)$.\n\nFor $n=0$: The coefficient of $u(x_i)$ must be zero.\n$$\n\\frac{h^{-2}}{0!} \\sum_{k=-2}^{2} c_k k^0 = \\frac{1}{h^2}(c_{-2} + c_{-1} + c_0 + c_1 + c_2) = 0 \\implies c_0 + 2c_1 + 2c_2 = 0\n$$\n\nFor $n=1$: The coefficient of $u'(x_i)$ must be zero.\n$$\n\\frac{h^{-1}}{1!} \\sum_{k=-2}^{2} c_k k^1 = \\frac{1}{h}(c_1 - c_1 + 2c_2 - 2c_2) = 0\n$$\nThis is automatically satisfied due to the symmetry $c_{-k}=c_k$.\n\nFor $n=2$: The coefficient of $u''(x_i)$ must be $1$.\n$$\n\\frac{h^{0}}{2!} \\sum_{k=-2}^{2} c_k k^2 = \\frac{1}{2} (c_1(1)^2 + c_1(-1)^2 + c_2(2)^2 + c_2(-2)^2) = 1 \\implies \\frac{1}{2}(2c_1 + 8c_2) = 1 \\implies c_1 + 4c_2 = 1\n$$\n\nFor $n=3$: The coefficient of $u'''(x_i)$ is automatically zero due to symmetry.\n$$\n\\frac{h^{1}}{3!} \\sum_{k=-2}^{2} c_k k^3 = \\frac{h}{6} (c_1(1)^3 + c_1(-1)^3 + c_2(2)^3 + c_2(-2)^3) = 0\n$$\n\nFor $n=4$: To achieve fourth-order accuracy, the coefficient of the $h^2 u^{(4)}(x_i)$ term must be zero.\n$$\n\\frac{h^{2}}{4!} \\sum_{k=-2}^{2} c_k k^4 = \\frac{h^2}{24} (c_1(1)^4 + c_1(-1)^4 + c_2(2)^4 + c_2(-2)^4) = 0 \\implies \\frac{h^2}{24}(2c_1 + 32c_2) = 0 \\implies c_1 + 16c_2 = 0\n$$\n\nWe now have a system of linear equations for $c_1$ and $c_2$:\n1) $c_1 + 4c_2 = 1$\n2) $c_1 + 16c_2 = 0$\n\nSubtracting equation (1) from (2):\n$$\n(c_1 + 16c_2) - (c_1 + 4c_2) = 0 - 1 \\implies 12c_2 = -1 \\implies c_2 = -\\frac{1}{12}\n$$\nSubstituting $c_2$ back into equation (2):\n$$\nc_1 + 16\\left(-\\frac{1}{12}\\right) = 0 \\implies c_1 - \\frac{16}{12} = 0 \\implies c_1 = \\frac{16}{12} = \\frac{4}{3}\n$$\nFinally, we find $c_0$ from the first condition:\n$$\nc_0 = -2c_1 - 2c_2 = -2\\left(\\frac{4}{3}\\right) - 2\\left(-\\frac{1}{12}\\right) = -\\frac{8}{3} + \\frac{2}{12} = -\\frac{16}{6} + \\frac{1}{6} = -\\frac{15}{6} = -\\frac{5}{2}\n$$\nThe finite-difference approximation is:\n$$\nL_h u_i = \\frac{1}{12h^2} \\left[ -u_{i-2} + 16u_{i-1} - 30u_i + 16u_{i+1} - u_{i+2} \\right]\n$$\n\nThe truncation error, $\\tau$, is defined as $\\tau = L_h u_i - u''(x_i)$. The leading term of the truncation error corresponds to the first non-zero term in the expansion after the $u''(x_i)$ term. The terms for $n=3$, $n=4$, and $n=5$ (by symmetry) are zero. The leading error term is from $n=6$.\n$$\n\\tau = \\left[ \\frac{h^{6-2}}{6!} \\sum_{k=-2}^{2} c_k k^6 \\right] u^{(6)}(x_i) + O(h^6)\n$$\nThe coefficient multiplying $h^4 u^{(6)}(x_i)$ is therefore:\n$$\nK = \\frac{1}{6!} \\sum_{k=-2}^{2} c_k k^6 = \\frac{1}{720} \\left[ c_{-2}(-2)^6 + c_{-1}(-1)^6 + c_1(1)^6 + c_2(2)^6 \\right]\n$$\nUsing $c_{-k}=c_k$:\n$$\nK = \\frac{1}{720} \\left[ 2c_1 (1)^6 + 2c_2 (2)^6 \\right] = \\frac{2c_1 + 128c_2}{720} = \\frac{c_1 + 64c_2}{360}\n$$\nSubstituting the derived values for $c_1$ and $c_2$:\n$$\nc_1 = \\frac{4}{3} \\quad \\text{and} \\quad c_2 = -\\frac{1}{12}\n$$\n$$\nK = \\frac{\\frac{4}{3} + 64\\left(-\\frac{1}{12}\\right)}{360} = \\frac{\\frac{4}{3} - \\frac{64}{12}}{360} = \\frac{\\frac{4}{3} - \\frac{16}{3}}{360}\n$$\n$$\nK = \\frac{-\\frac{12}{3}}{360} = \\frac{-4}{360} = -\\frac{1}{90}\n$$\nThus, the coefficient multiplying the term $h^4 u^{(6)}(x_i)$ in the truncation error series is $-\\frac{1}{90}$.",
            "answer": "$$ \\boxed{-\\frac{1}{90}} $$"
        },
        {
            "introduction": "For phenomena dominated by wave transport, such as advection in fluid flow, the simple order of accuracy does not tell the whole story. This practice introduces the powerful technique of Fourier analysis, which decomposes numerical errors into physically meaningful components: numerical dissipation (amplitude error) and numerical dispersion (phase error). By analyzing a third-order upwind scheme using the concept of a modified wavenumber, you will gain a deeper, more practical understanding of how numerical schemes can alter the physical behavior of the solutions they are meant to approximate .",
            "id": "3982496",
            "problem": "Consider one-dimensional linear advection of a passive scalar in a uniform flow, governed by the partial differential equation $u_{t} + a\\,u_{x} = 0$, with constant advection speed $a  0$. In a semi-discrete Method of Lines (MOL) formulation of Computational Fluid Dynamics (CFD), approximate the spatial derivative using the third-order upwind-biased backward difference operator (appropriate for $a0$) on a uniform grid of spacing $h$:\n$$\n\\left(D u\\right)_{i} \\equiv \\frac{1}{h}\\left(\\frac{11}{6}\\,u_{i} - 3\\,u_{i-1} + \\frac{3}{2}\\,u_{i-2} - \\frac{1}{3}\\,u_{i-3}\\right).\n$$\nPerform a Fourier (von Neumann) analysis by inserting the mode $u_{j} = \\exp\\!\\left(i k x_{j}\\right)$, where $x_{j} = j h$ and $k$ is the physical wavenumber, so that the discrete derivative is represented by $D u_{j} = \\left(i\\,\\tilde{k}\\right) u_{j}$, which defines the modified wavenumber $\\tilde{k} = \\tilde{k}(k,h)$. Using small-parameter expansion in $\\theta \\equiv k h$, determine from $\\tilde{k}$ the leading-order numerical dissipation and dispersion. For this problem, define:\n- The numerical dissipation coefficient $C_{d}$ as the leading constant (independent of $h$) in the small-$\\theta$ expansion of the imaginary part of the modified wavenumber,\n$$\n\\mathrm{Im}\\!\\left(\\tilde{k}\\right) = C_{d}\\,k^{4} h^{3} + \\mathcal{O}\\!\\left(k^{6} h^{5}\\right).\n$$\n- The numerical dispersion coefficient $C_{p}$ as the leading constant in the small-$\\theta$ expansion of the deviation of the real part of the modified wavenumber from the true wavenumber,\n$$\n\\mathrm{Re}\\!\\left(\\tilde{k}\\right) - k = C_{p}\\,k^{5} h^{4} + \\mathcal{O}\\!\\left(k^{7} h^{6}\\right).\n$$\nDerive these coefficients starting from the above discrete operator and the definition of $\\tilde{k}$, without invoking any pre-tabulated discrete symbols. Express your final answer as a row matrix $\\begin{pmatrix}C_{d}  C_{p}\\end{pmatrix}$ of exact fractions. No rounding is required. In your derivation, also state how each effect scales with $h$.",
            "solution": "The problem requires the determination of the leading-order numerical dissipation and dispersion coefficients, denoted $C_d$ and $C_p$ respectively, for a given third-order finite difference approximation to the first spatial derivative. The analysis is performed using the concept of the modified wavenumber, $\\tilde{k}$.\n\nThe governing partial differential equation is the one-dimensional linear advection equation, $u_{t} + a\\,u_{x} = 0$, where $a  0$ is a constant advection speed. The spatial derivative $u_x$ at a grid point $x_i$ is approximated by the discrete operator $(D u)_i$:\n$$\n\\left(D u\\right)_{i} \\equiv \\frac{1}{h}\\left(\\frac{11}{6}\\,u_{i} - 3\\,u_{i-1} + \\frac{3}{2}\\,u_{i-2} - \\frac{1}{3}\\,u_{i-3}\\right)\n$$\nwhere $h$ is the uniform grid spacing.\n\nTo perform a Fourier analysis, we consider the action of this operator on a single Fourier mode, $u_j = \\exp(i k x_j)$, where $x_j=jh$ and $k$ is the physical wavenumber. The modified wavenumber $\\tilde{k}$ is defined by the relation:\n$$\nD u_{j} = \\left(i\\,\\tilde{k}\\right) u_{j}\n$$\nThe exact differential operator $\\frac{\\partial}{\\partial x}$ acting on this mode yields $\\frac{\\partial}{\\partial x} \\exp(ikx) = (ik)\\exp(ikx)$. Thus, $\\tilde{k}$ serves as the representation of the wavenumber $k$ in the discrete system. Any deviation of $\\tilde{k}$ from $k$ signifies numerical error.\n\nWe begin by substituting the Fourier mode into the discrete operator. Note that for any integer $m$, $u_{j-m} = \\exp(ik(j-m)h) = \\exp(ikjh) \\exp(-ikmh) = u_j \\exp(-imkh)$. Let $\\theta \\equiv kh$ be the dimensionless wavenumber. Then $u_{j-m} = u_j \\exp(-im\\theta)$.\nApplying the operator $D$ to $u_j$:\n$$\n\\begin{aligned}\nD u_{j} = \\frac{1}{h}\\left(\\frac{11}{6}\\,u_{j} - 3\\,u_{j-1} + \\frac{3}{2}\\,u_{j-2} - \\frac{1}{3}\\,u_{j-3}\\right) \\\\\n= \\frac{1}{h}\\left(\\frac{11}{6}\\,u_{j} - 3\\,u_{j}\\exp(-i\\theta) + \\frac{3}{2}\\,u_{j}\\exp(-i2\\theta) - \\frac{1}{3}\\,u_{j}\\exp(-i3\\theta)\\right) \\\\\n= \\frac{u_{j}}{h}\\left(\\frac{11}{6} - 3\\exp(-i\\theta) + \\frac{3}{2}\\exp(-i2\\theta) - \\frac{1}{3}\\exp(-i3\\theta)\\right)\n\\end{aligned}\n$$\nBy the definition of the modified wavenumber, we equate this to $(i\\,\\tilde{k}) u_{j}$:\n$$\n(i\\,\\tilde{k}) u_{j} = \\frac{u_{j}}{h}\\left(\\frac{11}{6} - 3\\exp(-i\\theta) + \\frac{3}{2}\\exp(-i2\\theta) - \\frac{1}{3}\\exp(-i3\\theta)\\right)\n$$\nSolving for $\\tilde{k}$ yields:\n$$\n\\tilde{k} = \\frac{1}{ih}\\left(\\frac{11}{6} - 3\\exp(-i\\theta) + \\frac{3}{2}\\exp(-i2\\theta) - \\frac{1}{3}\\exp(-i3\\theta)\\right)\n$$\nThis is the exact expression for the modified wavenumber. To analyze the numerical error for long wavelengths (small $k$) at a fixed grid spacing $h$, we perform a Taylor series expansion of this expression for small $\\theta \\ll 1$. We use the expansion for the exponential function, $\\exp(z) = \\sum_{n=0}^{\\infty} \\frac{z^n}{n!}$. We need terms up to $\\theta^5$ to capture the leading-order dispersion.\n$$\n\\exp(-im\\theta) = 1 - (im\\theta) - \\frac{(m\\theta)^2}{2} + i\\frac{(m\\theta)^3}{6} + \\frac{(m\\theta)^4}{24} - i\\frac{(m\\theta)^5}{120} + \\mathcal{O}(\\theta^6)\n$$\nLet the term in the parentheses be $Z(\\theta) = \\frac{11}{6} - 3\\exp(-i\\theta) + \\frac{3}{2}\\exp(-i2\\theta) - \\frac{1}{3}\\exp(-i3\\theta)$. After expanding the exponentials and collecting terms by powers of $\\theta$, it can be shown that the scheme is third-order accurate, meaning the terms for $\\theta^0, \\theta^1, \\theta^2, \\theta^3$ match the expansion of $i\\theta$. The resulting series for $Z(\\theta)$ is:\n$$\nZ(\\theta) = i\\theta - \\frac{1}{4}\\theta^4 + i\\frac{3}{10}\\theta^5 + \\mathcal{O}(\\theta^6)\n$$\nNow we substitute this back into the expression for $\\tilde{k}$:\n$$\n\\tilde{k} = \\frac{Z(\\theta)}{ih} = \\frac{1}{ih}\\left(i\\theta - \\frac{1}{4}\\theta^4 + i\\frac{3}{10}\\theta^5 + \\mathcal{O}(\\theta^7)\\right)\n$$\nNote that the next non-zero term in the expansion for $Z(\\theta)$ is of order $\\theta^7$, which takes care of the order notation stated in the problem for dispersion.\n$$\n\\tilde{k} = \\frac{\\theta}{h} + \\frac{i}{h}\\frac{\\theta^4}{4} + \\frac{1}{h}\\frac{3\\theta^5}{10} + \\mathcal{O}(\\frac{\\theta^7}{h})\n$$\nSubstituting $\\theta=kh$:\n$$\n\\tilde{k} = \\frac{kh}{h} + i\\frac{(kh)^4}{4h} + \\frac{3(kh)^5}{10h} + \\mathcal{O}(k^7h^6) = k + i\\frac{1}{4}k^4h^3 + \\frac{3}{10}k^5h^4 + \\mathcal{O}(k^7h^6)\n$$\nWe now separate the real and imaginary parts of $\\tilde{k}$.\nThe imaginary part of $\\tilde{k}$ represents numerical dissipation (if positive) or amplification (if negative).\n$$\n\\mathrm{Im}(\\tilde{k}) = \\frac{1}{4}k^4h^3 + \\mathcal{O}(k^6h^5)\n$$\nThis corresponds to numerical dissipation since the coefficient is positive. Comparing with the given form $\\mathrm{Im}(\\tilde{k}) = C_{d}\\,k^{4} h^{3} + \\mathcal{O}(k^{6} h^{5})$, we identify the numerical dissipation coefficient as:\n$$\nC_d = \\frac{1}{4}\n$$\nThe leading-order dissipation error scales with the grid spacing as $h^3$.\n\nThe real part of $\\tilde{k}$ relates to the wave propagation speed. The deviation from the true wavenumber $k$, $\\mathrm{Re}(\\tilde{k}) - k$, represents numerical dispersion.\n$$\n\\mathrm{Re}(\\tilde{k}) = k + \\frac{3}{10}k^5h^4 + \\mathcal{O}(k^7h^6)\n$$\nThus, the dispersion error is:\n$$\n\\mathrm{Re}(\\tilde{k}) - k = \\frac{3}{10}k^5h^4 + \\mathcal{O}(k^7h^6)\n$$\nComparing with the given form $\\mathrm{Re}(\\tilde{k}) - k = C_{p}\\,k^{5} h^{4} + \\mathcal{O}(k^{7} h^{6})$, we identify the numerical dispersion coefficient as:\n$$\nC_p = \\frac{3}{10}\n$$\nThe leading-order dispersion error scales with the grid spacing as $h^4$. The positive sign indicates that the numerical phase speed is greater than the true phase speed for long wavelengths.\n\nThe requested coefficients are $C_d = \\frac{1}{4}$ and $C_p = \\frac{3}{10}$.\nFinal answer is to be expressed as a row matrix.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{4}  \\frac{3}{10} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "The final and most crucial test of any numerical theory is its performance in practice. This hands-on coding exercise bridges the gap between theoretical analysis and computational results by using the Method of Manufactured Solutions (MMS), a cornerstone of code verification. You will implement a simulation on a curved surface and directly observe how a seemingly benign simplification—using a low-order approximation for geometric metric terms—can degrade the overall accuracy of an otherwise high-order scheme, a critical lesson for developing robust CFD codes for complex geometries .",
            "id": "3982485",
            "problem": "Consider a scalar field on a cylindrical surface within the context of Computational Fluid Dynamics (CFD). Let the physical surface be parameterized by the angular coordinate $\\theta$ and the axial coordinate $z$. The cylinder has a nominal radius $R_0$ that is perturbed by a smooth sinusoidal variation. The physical mapping $\\mathbf{x}(\\theta,z)$ is given by\n$$\nx(\\theta) = r(\\theta)\\cos\\theta,\\quad y(\\theta) = r(\\theta)\\sin\\theta,\\quad z = z,\n$$\nwhere\n$$\nr(\\theta) = R_0 + \\varepsilon \\sin\\theta,\n$$\nwith $\\theta$ measured in radians. The induced metric on the surface has components\n$$\ng_{\\theta\\theta} = r(\\theta)^2 + \\left(\\frac{dr}{d\\theta}\\right)^2,\\quad g_{zz} = 1,\\quad g_{\\theta z} = 0,\n$$\nand the determinant $g$ satisfies $\\sqrt{g} = \\sqrt{g_{\\theta\\theta}}$. The surface Laplace–Beltrami operator (the intrinsic surface Laplacian) acting on a scalar field $u(\\theta,z)$ is\n$$\n\\Delta_s u = \\frac{1}{\\sqrt{g}} \\frac{\\partial}{\\partial \\theta}\\left(\\sqrt{g}\\, g^{\\theta\\theta}\\, \\frac{\\partial u}{\\partial \\theta}\\right) + \\frac{1}{\\sqrt{g}} \\frac{\\partial}{\\partial z}\\left(\\sqrt{g}\\, g^{zz}\\, \\frac{\\partial u}{\\partial z}\\right),\n$$\nwhere $g^{\\theta\\theta} = \\left(g_{\\theta\\theta}\\right)^{-1}$ and $g^{zz} = 1$. Since $\\sqrt{g}$ does not depend on $z$, this reduces to\n$$\n\\Delta_s u = \\frac{1}{\\sqrt{g}} \\frac{\\partial}{\\partial \\theta}\\left(\\sqrt{g}\\, g^{\\theta\\theta}\\, \\frac{\\partial u}{\\partial \\theta}\\right) + \\frac{\\partial^2 u}{\\partial z^2}.\n$$\nDefine the manufactured (analytic) solution\n$$\nu(\\theta,z) = \\sin(3\\theta)\\,\\cos\\left(\\frac{2\\pi}{L} z\\right),\n$$\nwhere $L$ is the axial period. Using the above definitions, and writing $G(\\theta) = r(\\theta)^2 + \\left(\\frac{dr}{d\\theta}\\right)^2$ and $B(\\theta) = \\frac{1}{\\sqrt{G(\\theta)}}$, we can rewrite the operator equivalently as\n$$\n\\Delta_s u = B(\\theta)\\left( \\frac{d B}{d\\theta} \\frac{\\partial u}{\\partial \\theta} + B(\\theta) \\frac{\\partial^2 u}{\\partial \\theta^2} \\right) + \\frac{\\partial^2 u}{\\partial z^2}.\n$$\nFor the chosen $r(\\theta)$, the exact derivatives are $r'(\\theta) = \\varepsilon \\cos\\theta$ and\n$$\nG(\\theta) = R_0^2 + \\varepsilon^2 + 2 R_0 \\varepsilon \\sin\\theta,\\quad B(\\theta) = \\left(R_0^2 + \\varepsilon^2 + 2 R_0 \\varepsilon \\sin\\theta\\right)^{-1/2},\n$$\n$$\n\\frac{dB}{d\\theta} = - \\frac{R_0 \\varepsilon \\cos\\theta}{\\left(R_0^2 + \\varepsilon^2 + 2 R_0 \\varepsilon \\sin\\theta\\right)^{3/2}}.\n$$\n\nYour task is to implement two discrete approximations of $\\Delta_s u$ on a uniform, periodic grid in both $\\theta$ and $z$:\n\n1. An \"exact-metric\" discretization that uses the analytic expressions for $B(\\theta)$ and $\\frac{dB}{d\\theta}$ and second-order centered finite differences for $\\frac{\\partial u}{\\partial \\theta}$, $\\frac{\\partial^2 u}{\\partial \\theta^2}$, and $\\frac{\\partial^2 u}{\\partial z^2}$.\n\n2. A \"naive-metric\" discretization that computes the geometric metrics purely from the discretized geometry using first-order forward differences, specifically\n   - approximate $r'(\\theta)$ by a forward difference $r'(\\theta_i) \\approx \\frac{r(\\theta_{i+1}) - r(\\theta_i)}{\\Delta\\theta}$,\n   - form $G(\\theta_i) = r(\\theta_i)^2 + \\left(r'(\\theta_i)\\right)^2$ and $B(\\theta_i) = \\frac{1}{\\sqrt{G(\\theta_i)}}$,\n   - approximate $\\frac{dB}{d\\theta}$ by a forward difference $\\frac{dB}{d\\theta}(\\theta_i) \\approx \\frac{B(\\theta_{i+1}) - B(\\theta_i)}{\\Delta\\theta}$,\n   while still using second-order centered finite differences for the derivatives of $u$.\n\nFor each discretization, evaluate the discrete operator $\\Delta_{s,h} u$ on the grid and compute the pointwise exact value of $\\Delta_s u(\\theta_i,z_j)$ using the analytic expressions and derivatives of $u$. Then compute the discrete root-mean-square (RMS) error\n$$\nE_h = \\left( \\frac{1}{N_\\theta N_z} \\sum_{i=0}^{N_\\theta - 1} \\sum_{j=0}^{N_z - 1} \\left[ \\Delta_{s,h} u(\\theta_i,z_j) - \\Delta_s u(\\theta_i,z_j) \\right]^2 \\right)^{1/2}.\n$$\n\nTo measure the observed convergence rate, use three successively refined grids and perform a linear regression of $\\log E_h$ versus $\\log h$, where $h = \\Delta\\theta = \\frac{2\\pi}{N_\\theta}$ is the angular grid spacing. The slope of this fit is the observed order $p$.\n\nImplement a program that carries out this procedure for the following four test cases (all angles in radians, all lengths in the same arbitrary unit):\n\n- Case A (happy path): $R_0 = 1.0$, $\\varepsilon = 0.1$, $L = 1.0$, with grids $(N_\\theta,N_z) = (32,32)$, $(64,64)$, $(128,128)$.\n- Case B (strong perturbation): $R_0 = 1.0$, $\\varepsilon = 0.5$, $L = 1.0$, with grids $(N_\\theta,N_z) = (32,32)$, $(64,64)$, $(128,128)$.\n- Case C (boundary condition of no perturbation): $R_0 = 1.0$, $\\varepsilon = 0.0$, $L = 1.0$, with grids $(N_\\theta,N_z) = (32,32)$, $(64,64)$, $(128,128)$.\n- Case D (different axial period): $R_0 = 2.0$, $\\varepsilon = 0.2$, $L = 3.0$, with grids $(N_\\theta,N_z) = (32,32)$, $(64,64)$, $(128,128)$.\n\nYour program should produce a single line of output containing the observed convergence rates as a comma-separated list enclosed in square brackets, ordered as\n$$\n[\\;p_{\\text{naive},A},\\;p_{\\text{exact},A},\\;p_{\\text{naive},B},\\;p_{\\text{exact},B},\\;p_{\\text{naive},C},\\;p_{\\text{exact},C},\\;p_{\\text{naive},D},\\;p_{\\text{exact},D}\\;].\n$$\nEach $p$ must be a floating-point number. No other output should be produced.",
            "solution": "The user wants to analyze the order of accuracy for two different numerical discretizations of the Laplace-Beltrami operator on a perturbed cylindrical surface.\n\n### Step 1: Problem Validation\n\nThe problem is subjected to a rigorous validation process.\n\n- **Extraction of Givens**: All provided information, including the parameterization of the cylindrical surface $r(\\theta) = R_0 + \\varepsilon \\sin\\theta$, the components of the metric tensor ($g_{\\theta\\theta}$, $g_{zz}$), the simplified form of the Laplace-Beltrami operator $\\Delta_s u = B(\\theta)( \\frac{d B}{d\\theta} \\frac{\\partial u}{\\partial \\theta} + B(\\theta) \\frac{\\partial^2 u}{\\partial \\theta^2} ) + \\frac{\\partial^2 u}{\\partial z^2}$, the manufactured solution $u(\\theta,z) = \\sin(3\\theta)\\cos(\\frac{2\\pi}{L} z)$, the definitions of the two discretization schemes (\"exact-metric\" and \"naive-metric\"), the error metric (RMS error), the methodology for determining the convergence rate (log-log linear regression), and the specific test cases (parameters and grid sizes) are duly noted. All analytic expressions provided for $G(\\theta)$, $B(\\theta)$, and $\\frac{dB}{d\\theta}$ have been verified and are correct.\n\n- **Validation Checks**:\n    1.  **Scientific Grounding**: The problem is fundamentally sound, rooted in established principles of differential geometry (metric tensors, Laplace-Beltrami operator) and numerical analysis (method of manufactured solutions, finite difference methods, convergence studies). This is a standard verification and validation (VV) exercise in computational physics and engineering.\n    2.  **Well-Posedness**: The task is well-posed. It requires the computation of a specific, well-defined numerical quantity (the observed order of accuracy) for a given set of inputs and a clear methodology. A unique and stable solution for the convergence rates exists.\n    3.  **Objectivity**: The problem is specified using precise, unambiguous mathematical terminology. There is no subjective content.\n    4.  **Completeness and Consistency**: All necessary formulas, parameters, and boundary conditions (periodicity) are provided. The problem is self-contained. A check of the denominator in the metric term $B(\\theta)$, which is $G(\\theta) = (R_0 - \\varepsilon)^2 + 2R_0\\varepsilon(1+\\sin\\theta)$, confirms that it is strictly positive for all test cases where $\\varepsilon0$, as $R_0  \\varepsilon$ is always satisfied. For $\\varepsilon=0$, it is also positive. Thus, no division by zero will occur.\n    5.  **Feasibility**: The required computations are numerically feasible and well within the capabilities of standard scientific computing libraries. The parameters are physically plausible.\n\n- **Verdict**: The problem is assessed as **valid**. It is a well-formulated, scientifically sound problem in numerical analysis applied to a CFD-relevant context.\n\n### Step 2: Solution Derivation and Algorithm Design\n\nThe core of the problem is to compute the observed order of convergence, $p$, for two schemes by calculating the RMS error $E_h$ on a sequence of three grids and finding the slope of $\\log E_h$ versus $\\log h$, where $h = \\Delta\\theta$.\n\n**A. Analytic Reference Solution**\nThe exact Laplace-Beltrami operator applied to the manufactured solution $u(\\theta,z)$ is required as a baseline for error calculation. Given $u(\\theta,z) = \\sin(3\\theta)\\cos(kz)$ where $k = 2\\pi/L$, its partial derivatives are:\n$$\n\\frac{\\partial u}{\\partial \\theta} = 3\\cos(3\\theta)\\cos(kz), \\quad \\frac{\\partial^2 u}{\\partial \\theta^2} = -9\\sin(3\\theta)\\cos(kz), \\quad \\frac{\\partial^2 u}{\\partial z^2} = -k^2\\sin(3\\theta)\\cos(kz).\n$$\nSubstituting these into the provided form of the operator $\\Delta_s u = B(\\theta)\\left( \\frac{dB}{d\\theta} \\frac{\\partial u}{\\partial \\theta} + B(\\theta) \\frac{\\partial^2 u}{\\partial \\theta^2} \\right) + \\frac{\\partial^2 u}{\\partial z^2}$ gives the exact value at any point $(\\theta, z)$:\n$$\n\\Delta_s u(\\theta,z) = \\left[ B(\\theta)\\left( \\frac{dB}{d\\theta} (3\\cos(3\\theta)) - 9B(\\theta)\\sin(3\\theta) \\right) - k^2\\sin(3\\theta) \\right] \\cos(kz).\n$$\nThe terms $B(\\theta)$ and $\\frac{dB}{d\\theta}$ are computed using their analytic formulas from the problem statement. This expression will be evaluated on the grid to serve as the exact solution for the error calculation.\n\n**B. Numerical Discretization**\nA uniform periodic grid is defined by $\\theta_i = i \\Delta\\theta$ and $z_j = j \\Delta z$, with $\\Delta\\theta = 2\\pi/N_\\theta$ and $\\Delta z = L/N_z$. On this grid, any function $f(\\theta_i, z_j)$ is represented as a 2D array $f_{i,j}$.\n\nThe required second-order centered finite difference approximations for the derivatives of $u$, incorporating periodicity, are:\n$$\n\\left(\\frac{\\partial u}{\\partial \\theta}\\right)_{i,j} \\approx \\frac{u_{i+1,j} - u_{i-1,j}}{2\\Delta\\theta}\n$$\n$$\n\\left(\\frac{\\partial^2 u}{\\partial \\theta^2}\\right)_{i,j} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{(\\Delta\\theta)^2}\n$$\n$$\n\\left(\\frac{\\partial^2 u}{\\partial z^2}\\right)_{i,j} \\approx \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{(\\Delta z)^2}\n$$\nThese will be implemented efficiently using `numpy.roll` for handling the periodic boundary conditions.\n\n**C. Scheme Implementations**\n\n1.  **Exact-Metric Scheme**: This scheme combines the numerically computed derivatives of $u$ with the analytically computed metric coefficients.\n    -   The metric terms $B(\\theta_i)$ and $\\frac{dB}{d\\theta}(\\theta_i)$ are calculated for each $\\theta_i$ on the grid using the exact formulas.\n    -   The discrete operator is assembled as:\n        $\\Delta_{s,h} u = B_{\\text{exact}} \\left( \\frac{dB}{d\\theta}_{\\text{exact}} \\left(\\frac{\\partial u}{\\partial \\theta}\\right)_h + B_{\\text{exact}} \\left(\\frac{\\partial^2 u}{\\partial \\theta^2}\\right)_h \\right) + \\left(\\frac{\\partial^2 u}{\\partial z^2}\\right)_h$.\n    -   The truncation error is dominated by the $O(h^2)$ errors from the finite differences of $u$. Thus, we expect a convergence rate $p \\approx 2$.\n\n2.  **Naive-Metric Scheme**: This scheme uses low-order numerical approximations for the metric terms.\n    -   At each point $\\theta_i$, $r'_i$ is approximated by a first-order forward difference: $r'_i \\approx (r_{i+1} - r_i)/\\Delta\\theta$.\n    -   This is used to compute a \"naive\" $G_i = r_i^2 + (r'_i)^2$ and $B_i = 1/\\sqrt{G_i}$.\n    -   Then, $\\frac{dB}{d\\theta}$ is also approximated by a first-order forward difference: $(\\frac{dB}{d\\theta})_i \\approx (B_{i+1} - B_i)/\\Delta\\theta$.\n    -   The discrete operator is assembled similarly, but with these naive metric terms $B_{\\text{naive}}$ and $(\\frac{dB}{d\\theta})_{\\text{naive}}$.\n    -   The overall accuracy will be limited by the first-order, $O(h)$, errors introduced in the metric calculations. Thus, we expect a convergence rate $p \\approx 1$.\n    -   An exception is Case C ($\\varepsilon=0$), where the geometry is a perfect cylinder. For a constant radius $r(\\theta)=R_0$, the first-order forward differences for $r'$ and $dB/d\\theta$ both evaluate to exactly zero, which is the correct analytic value. In this special case, the naive-metric scheme becomes identical to the exact-metric scheme, and both are expected to converge at second order ($p \\approx 2$).\n\n**D. Convergence Rate Calculation**\nFor each test case and each scheme, the procedure is:\n1.  Compute the RMS error $E_h = \\sqrt{\\frac{1}{N_\\theta N_z}\\sum_{i,j} (\\Delta_{s,h}u_{i,j} - \\Delta_s u(\\theta_i,z_j))^2}$ for the three grid resolutions, giving $(E_{h_1}, E_{h_2}, E_{h_3})$.\n2.  The corresponding grid spacings are $h_k = 2\\pi/N_{\\theta,k}$.\n3.  Perform a linear regression on the points $(\\log(h_k), \\log(E_{h_k}))$. The slope of this line is the observed order of accuracy, $p$. The `scipy.stats.linregress` function is used for this step.\n\nThe final program will systematically execute this entire procedure for all four test cases and output the eight resulting convergence rates in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Computes the observed convergence rates for two discretizations\n    of the Laplace-Beltrami operator on a perturbed cylinder.\n    \"\"\"\n    test_cases = [\n        # (R0, epsilon, L)\n        (1.0, 0.1, 1.0),  # Case A\n        (1.0, 0.5, 1.0),  # Case B\n        (1.0, 0.0, 1.0),  # Case C\n        (2.0, 0.2, 3.0),  # Case D\n    ]\n    grid_resolutions = [(32, 32), (64, 64), (128, 128)]\n    \n    all_convergence_rates = []\n\n    for R0, eps, L in test_cases:\n        errors_naive = []\n        errors_exact = []\n        h_values = []\n\n        for N_theta, N_z in grid_resolutions:\n            # 1. Grid setup\n            d_theta = 2.0 * np.pi / N_theta\n            d_z = L / N_z\n            h_values.append(d_theta)\n\n            theta_1d = np.linspace(0.0, 2.0 * np.pi, N_theta, endpoint=False)\n            z_1d = np.linspace(0.0, L, N_z, endpoint=False)\n            THETA, Z = np.meshgrid(theta_1d, z_1d, indexing='ij')\n\n            k = 2.0 * np.pi / L\n\n            # 2. Manufactured solution and its analytical derivatives\n            u = np.sin(3.0 * THETA) * np.cos(k * Z)\n            u_theta = 3.0 * np.cos(3.0 * THETA) * np.cos(k * Z)\n            u_thetatheta = -9.0 * np.sin(3.0 * THETA) * np.cos(k * Z)\n            u_zz = -(k**2) * u\n\n            # 3. Analytical Laplace-Beltrami operator evaluation\n            G_analytic = R0**2 + eps**2 + 2.0 * R0 * eps * np.sin(THETA)\n            B_analytic = G_analytic**(-0.5)\n            dBdtheta_analytic = -R0 * eps * np.cos(THETA) * G_analytic**(-1.5)\n            \n            lap_u_analytic = B_analytic * (dBdtheta_analytic * u_theta + B_analytic * u_thetatheta) + u_zz\n\n            # 4. Numerical derivatives of u (2nd-order centered differences)\n            u_ip1 = np.roll(u, -1, axis=0) # i+1\n            u_im1 = np.roll(u, 1, axis=0)  # i-1\n            u_jp1 = np.roll(u, -1, axis=1) # j+1\n            u_jm1 = np.roll(u, 1, axis=1)  # j-1\n            \n            du_dtheta_h = (u_ip1 - u_im1) / (2.0 * d_theta)\n            d2u_dtheta2_h = (u_ip1 - 2.0 * u + u_im1) / (d_theta**2)\n            d2u_dz2_h = (u_jp1 - 2.0 * u + u_jm1) / (d_z**2)\n            \n            # --- Scheme 1: \"Exact-Metric\" Discretization ---\n            G_exact_1d = R0**2 + eps**2 + 2.0 * R0 * eps * np.sin(theta_1d)\n            B_exact_1d = G_exact_1d**(-0.5)\n            dBdtheta_exact_1d = -R0 * eps * np.cos(theta_1d) * G_exact_1d**(-1.5)\n            \n            # Broadcast metric terms to 2D grid shape\n            B_exact = B_exact_1d[:, np.newaxis]\n            dBdtheta_exact = dBdtheta_exact_1d[:, np.newaxis]\n            \n            lap_u_h_exact = B_exact * (dBdtheta_exact * du_dtheta_h + B_exact * d2u_dtheta2_h) + d2u_dz2_h\n            \n            error_exact = np.sqrt(np.mean((lap_u_h_exact - lap_u_analytic)**2))\n            errors_exact.append(error_exact)\n\n            # --- Scheme 2: \"Naive-Metric\" Discretization ---\n            r_vals = R0 + eps * np.sin(theta_1d)\n            # 1st-order forward difference for r'\n            rp_naive = (np.roll(r_vals, -1) - r_vals) / d_theta\n            \n            G_naive_1d = r_vals**2 + rp_naive**2\n            B_naive_1d = G_naive_1d**(-0.5)\n            # 1st-order forward difference for B'\n            dBdtheta_naive_1d = (np.roll(B_naive_1d, -1) - B_naive_1d) / d_theta\n            \n            # Broadcast metric terms to 2D grid shape\n            B_naive = B_naive_1d[:, np.newaxis]\n            dBdtheta_naive = dBdtheta_naive_1d[:, np.newaxis]\n\n            lap_u_h_naive = B_naive * (dBdtheta_naive * du_dtheta_h + B_naive * d2u_dtheta2_h) + d2u_dz2_h\n\n            error_naive = np.sqrt(np.mean((lap_u_h_naive - lap_u_analytic)**2))\n            errors_naive.append(error_naive)\n\n        # 5. Convergence analysis via log-log linear regression\n        log_h = np.log(h_values)\n        \n        # Naive scheme rate\n        log_err_naive = np.log(errors_naive)\n        p_naive = stats.linregress(log_h, log_err_naive).slope\n        \n        # Exact scheme rate\n        log_err_exact = np.log(errors_exact)\n        p_exact = stats.linregress(log_h, log_err_exact).slope\n        \n        all_convergence_rates.extend([p_naive, p_exact])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_convergence_rates))}]\")\n\nsolve()\n```"
        }
    ]
}