{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的数值求解器之前，掌握经典的解析技术至关重要。第一个练习将回顾基本的分离变量法，在一个简单的矩形域上求解拉普拉斯方程的精确解 。通过构建特征函数并使用傅里叶级数施加边界条件，你将巩固对椭圆问题结构的理解，并获得一个可用于验证数值方法的解析基准。",
            "id": "3971038",
            "problem": "考虑一个典型的椭圆边值问题，该问题在计算流体动力学（CFD）中分析用于不可压缩流求解器中压力或势修正的椭圆算子时，或在简化薄板中的稳态热传导时出现。设一个矩形域由 $0 < x < L$ 和 $0 < y < H$ 定义。标量场 $\\phi(x,y)$ 由拉普拉斯方程控制\n$$\n\\nabla^{2} \\phi \\equiv \\frac{\\partial^{2} \\phi}{\\partial x^{2}} + \\frac{\\partial^{2} \\phi}{\\partial y^{2}} = 0,\n$$\n三边为齐次狄利克雷边界条件，\n$$\n\\phi(0,y) = 0,\\quad \\phi(L,y) = 0,\\quad \\phi(x,0) = 0,\n$$\n第四边为给定的非齐次狄利克雷边界条件，\n$$\n\\phi(x,H) = \\Phi_{0}\\,\\frac{x}{L},\n$$\n其中 $\\Phi_{0}$ 是一个恒定振幅。假设 $\\phi$ 是以 $\\mathrm{m^{2}/s}$ 为单位测量的速度势，长度 $L$ 和 $H$ 以 $\\mathrm{m}$ 为单位测量。你需要提供 $\\phi(x,y)$ 的符号表达式；最终的方框表达式中不应包含单位。\n\n从基本原理出发，使用分离变量法构造满足齐次狄利克雷条件的适当本征函数，通过将 $\\phi(x,H)$ 在相应的正交基中展开来施加剩余的边界条件，并从给定的边界数据中推导本征函数展开系数。给出在 $0 < x < L$，$0 < y < H$ 内有效的 $\\phi(x,y)$ 的最终闭合形式本征函数展开式。",
            "solution": "所述问题是一个适定的、典型的椭圆边值问题。它在科学上是合理的，内容是自洽的，并且没有矛盾。控制方程是拉普拉斯方程，这是数学物理中的一个基本偏微分方程，并且边界条件明确指定，使得该问题可以用标准方法求解。我们可以开始求解。\n\n问题是在一个矩形域上求解标量场 $\\phi(x,y)$ 的二维拉普拉斯方程，\n$$\n\\frac{\\partial^{2} \\phi}{\\partial x^{2}} + \\frac{\\partial^{2} \\phi}{\\partial y^{2}} = 0, \\quad \\text{for } 0 < x < L, \\ 0 < y < H\n$$\n其边界条件如下：\n$$\n\\phi(0,y) = 0 \\\\\n\\phi(L,y) = 0 \\\\\n\\phi(x,0) = 0 \\\\\n\\phi(x,H) = \\Phi_{0}\\,\\frac{x}{L}\n$$\n\n我们将使用分离变量法。我们假设解的形式为 $\\phi(x,y) = X(x)Y(y)$。将其代入拉普拉斯方程得到：\n$$\nX''(x)Y(y) + X(x)Y''(y) = 0\n$$\n其中撇号表示对函数自变量的微分。对于非零解，我们可以除以 $X(x)Y(y)$ 来分离变量：\n$$\n\\frac{X''(x)}{X(x)} = -\\frac{Y''(y)}{Y(y)}\n$$\n由于左边仅是 $x$ 的函数，右边仅是 $y$ 的函数，因此两边都必须等于一个常数。我们称这个分离常数为 $-\\lambda$。\n这得到两个常微分方程 (ODEs)：\n$$\nX''(x) + \\lambda X(x) = 0 \\\\\nY''(y) - \\lambda Y(y) = 0\n$$\n\n我们应用齐次边界条件。四个条件中有三个是齐次的。\n由 $\\phi(0,y) = X(0)Y(y) = 0$，对于非零解，我们要求 $X(0) = 0$。\n由 $\\phi(L,y) = X(L)Y(y) = 0$，我们要求 $X(L) = 0$。\n由 $\\phi(x,0) = X(x)Y(0) = 0$，我们要求 $Y(0) = 0$。\n\n首先，我们求解带有齐次边界条件的 $X(x)$ 的 Sturm-Liouville 问题：\n$$\nX''(x) + \\lambda X(x) = 0, \\quad X(0)=0, \\quad X(L)=0\n$$\n我们分析本征值 $\\lambda$ 的可能取值。\n情况1：$\\lambda < 0$。令 $\\lambda = -k^2$，其中 $k > 0$。常微分方程变为 $X'' - k^2 X = 0$，其通解为 $X(x) = A\\cosh(kx) + B\\sinh(kx)$。应用边界条件：$X(0) = A = 0$。然后 $X(L) = B\\sinh(kL) = 0$。由于 $L>0$ 和 $k>0$，$\\sinh(kL) \\neq 0$，所以 $B$ 必须为 $0$。这导致了零解 $X(x)=0$，因此没有负的本征值。\n情况2：$\\lambda = 0$。常微分方程变为 $X'' = 0$，其通解为 $X(x) = Ax + B$。应用边界条件：$X(0) = B = 0$。然后 $X(L) = AL = 0$。由于 $L \\neq 0$，$A$ 必须为 $0$。这也导致了零解，因此 $\\lambda=0$ 不是一个本征值。\n情况3：$\\lambda > 0$。令 $\\lambda = k^2$，其中 $k > 0$。常微分方程为 $X'' + k^2 X = 0$，其通解为 $X(x) = A\\cos(kx) + B\\sin(kx)$。应用边界条件：$X(0) = A = 0$。然后 $X(L) = B\\sin(kL) = 0$。对于非零解，我们必须有 $B \\neq 0$，这要求 $\\sin(kL)=0$。当 $kL = n\\pi$（对于任何整数 $n$）时，此条件得到满足。由于 $k > 0$，我们取 $n = 1, 2, 3, \\ldots$。\n因此，本征值为 $\\lambda_n = k_n^2 = \\left(\\frac{n\\pi}{L}\\right)^2$，其中 $n=1, 2, 3, \\ldots$。\n相应的本征函数，在相差一个乘法常数的情况下，为 $X_n(x) = \\sin\\left(\\frac{n\\pi x}{L}\\right)$。\n\n现在我们使用这些本征值来求解 $Y(y)$ 的常微分方程：\n$$\nY''(y) - \\lambda_n Y(y) = 0 \\implies Y'' - \\left(\\frac{n\\pi}{L}\\right)^2 Y = 0\n$$\n$Y_n(y)$ 的通解为 $Y_n(y) = C_n \\cosh\\left(\\frac{n\\pi y}{L}\\right) + D_n \\sinh\\left(\\frac{n\\pi y}{L}\\right)$。\n应用齐次边界条件 $Y(0)=0$：\n$$\nY_n(0) = C_n \\cosh(0) + D_n \\sinh(0) = C_n \\cdot 1 + D_n \\cdot 0 = C_n = 0\n$$\n因此，$Y_n(y)$ 的解的形式为 $Y_n(y) = D_n \\sinh\\left(\\frac{n\\pi y}{L}\\right)$。\n\n根据叠加原理，$\\phi(x,y)$ 的通解是乘积解 $\\phi_n(x,y) = X_n(x)Y_n(y)$ 的无穷级数：\n$$\n\\phi(x,y) = \\sum_{n=1}^{\\infty} D_n \\sin\\left(\\frac{n\\pi x}{L}\\right) \\sinh\\left(\\frac{n\\pi y}{L}\\right)\n$$\n其中系数 $D_n$ 将由余下的非齐次边界条件确定。\n\n我们在 $y=H$ 处应用该条件：$\\phi(x,H) = \\Phi_{0}\\frac{x}{L}$。\n$$\n\\Phi_{0}\\frac{x}{L} = \\sum_{n=1}^{\\infty} D_n \\sin\\left(\\frac{n\\pi x}{L}\\right) \\sinh\\left(\\frac{n\\pi H}{L}\\right) = \\sum_{n=1}^{\\infty} b_n \\sin\\left(\\frac{n\\pi x}{L}\\right)\n$$\n这是函数 $f(x) = \\Phi_{0}\\frac{x}{L}$ 在区间 $[0, L]$ 上的傅里叶正弦级数。系数 $b_n = D_n \\sinh\\left(\\frac{n\\pi H}{L}\\right)$ 由标准公式给出：\n$$\nb_n = \\frac{2}{L} \\int_0^L f(x) \\sin\\left(\\frac{n\\pi x}{L}\\right) dx = \\frac{2}{L} \\int_0^L \\left(\\Phi_{0}\\frac{x}{L}\\right) \\sin\\left(\\frac{n\\pi x}{L}\\right) dx\n$$\n$$\nb_n = \\frac{2\\Phi_0}{L^2} \\int_0^L x \\sin\\left(\\frac{n\\pi x}{L}\\right) dx\n$$\n我们使用分部积分法 $\\int u \\, dv = uv - \\int v \\, du$ 计算该积分，令 $u=x$ 和 $dv = \\sin\\left(\\frac{n\\pi x}{L}\\right)dx$。这得到 $du=dx$ 和 $v = -\\frac{L}{n\\pi}\\cos\\left(\\frac{n\\pi x}{L}\\right)$。\n$$\n\\int_0^L x \\sin\\left(\\frac{n\\pi x}{L}\\right) dx = \\left[ -x \\frac{L}{n\\pi} \\cos\\left(\\frac{n\\pi x}{L}\\right) \\right]_0^L - \\int_0^L \\left(-\\frac{L}{n\\pi} \\cos\\left(\\frac{n\\pi x}{L}\\right)\\right) dx\n$$\n$$\n= \\left( -L \\frac{L}{n\\pi} \\cos(n\\pi) - 0 \\right) + \\frac{L}{n\\pi} \\int_0^L \\cos\\left(\\frac{n\\pi x}{L}\\right) dx\n$$\n$$\n= -\\frac{L^2}{n\\pi} (-1)^n + \\frac{L}{n\\pi} \\left[ \\frac{L}{n\\pi} \\sin\\left(\\frac{n\\pi x}{L}\\right) \\right]_0^L\n$$\n$$\n= \\frac{L^2}{n\\pi} (-1)^{n+1} + \\frac{L^2}{(n\\pi)^2} (\\sin(n\\pi) - \\sin(0)) = \\frac{L^2}{n\\pi} (-1)^{n+1}\n$$\n将此结果代回 $b_n$ 的表达式中：\n$$\nb_n = \\frac{2\\Phi_0}{L^2} \\left(\\frac{L^2}{n\\pi} (-1)^{n+1}\\right) = \\frac{2\\Phi_0}{n\\pi} (-1)^{n+1}\n$$\n现在我们求解系数 $D_n$：\n$$\nD_n = \\frac{b_n}{\\sinh\\left(\\frac{n\\pi H}{L}\\right)} = \\frac{2\\Phi_0 (-1)^{n+1}}{n\\pi\\sinh\\left(\\frac{n\\pi H}{L}\\right)}\n$$\n最后，将这些系数代回 $\\phi(x,y)$ 的通解中，我们得到完整的本征函数展开式：\n$$\n\\phi(x,y) = \\sum_{n=1}^{\\infty} \\frac{2\\Phi_0 (-1)^{n+1}}{n\\pi\\sinh\\left(\\frac{n\\pi H}{L}\\right)} \\sin\\left(\\frac{n\\pi x}{L}\\right) \\sinh\\left(\\frac{n\\pi y}{L}\\right)\n$$\n这可以更简洁地写成：\n$$\n\\phi(x,y) = \\frac{2\\Phi_0}{\\pi} \\sum_{n=1}^{\\infty} \\frac{(-1)^{n+1}}{n} \\frac{\\sinh\\left(\\frac{n\\pi y}{L}\\right)}{\\sinh\\left(\\frac{n\\pi H}{L}\\right)} \\sin\\left(\\frac{n\\pi x}{L}\\right)\n$$\n此表达式是在指定域和边界条件下标量场 $\\phi(x,y)$ 的最终解。",
            "answer": "$$\\boxed{\\frac{2\\Phi_0}{\\pi} \\sum_{n=1}^{\\infty} \\frac{(-1)^{n+1}}{n} \\frac{\\sinh\\left(\\frac{n\\pi y}{L}\\right)}{\\sinh\\left(\\frac{n\\pi H}{L}\\right)} \\sin\\left(\\frac{n\\pi x}{L}\\right)}$$"
        },
        {
            "introduction": "在建立了分析基础和验证技术之后，我们现在转向实现一个高性能的数值求解器。本练习将指导你使用快速傅里叶变换（FFT）构建一个用于求解周期性泊松方程的谱方法求解器 。你将应用物理空间中的微分在傅里叶空间中变为简单乘法的原理，并解决关键的实践细节，例如处理零波数模式和消除非线性项中的混叠误差。",
            "id": "3970993",
            "problem": "您需要构建一个完整、可运行的程序，用于在均匀网格上使用快速傅里叶变换 (FFT) 求解二维周期性泊松问题。其科学基础源于计算流体力学中的泊松模型问题，其纯数学形式表述为：在双周期域上寻找一个标量场 $u(x,y)$，使得\n$$\n\\nabla^2 u(x,y) = f(x,y),\n$$\n其在长度为 $L_x$ 和 $L_y$ 的矩形域上满足周期性边界条件，并使用 $N_x \\times N_y$ 个点的均匀网格。该方法必须基于周期函数的谱表示和复指数的正交性，利用快速傅里叶变换 (FFT) 在傅里叶空间中对拉普拉斯算子求逆。在此，缩写词快速傅里叶变换 (FFT) 必须被理解为高效计算离散傅里叶变换的规范数值方法，而计算流体力学 (CFD) 指的是对流体流动方程进行数值求解的学科。\n\n您的程序必须实现以下功能：\n- 在 $x$ 和 $y$ 方向上，在以弧度为单位的周期域上构建均匀网格。所有三角函数都必须将其参数解释为弧度。\n- 使用谱微分法求解周期性泊松方程，其中拉普拉斯算子在傅里叶空间中作为对角算子。计算必须处理零傅里叶模式，并带有明确的约束条件：对于波数 $k_x = 0$ 和 $k_y = 0$ 的傅里叶模式，解必须为 $u$ 施加一个指定的平均值，或者通过移除右端项 $f$ 的平均值来强制满足相容性。如果右端项具有非零平均值且不希望强制执行相容性，程序必须返回一个不可行性指示符。\n- 在构造涉及场乘积的非线性源项时，使用基于填充的 $3/2$ 法则（或等效地， $2/3$ 截断法则）实现去混叠。这必须通过在傅里叶空间中补零，变换到更高分辨率的物理网格，在该网格上计算乘积，再变换回来，并截断到原始网格，以消除未解析模式在已解析模式上的混叠。\n\n算法必须基于经过充分检验的数学事实，按如下方式工作：\n- 在 $[0,L_x] \\times [0,L_y]$ 上的周期函数允许傅里叶级数展开，其波数 $k_x$ 和 $k_y$ 分别是 $2\\pi/L_x$ 和 $2\\pi/L_y$ 的整数倍。离散傅里叶变换在均匀网格上逼近这些展开，而谱微分将导数映射为在傅里叶空间中乘以 $i k_x$ 和 $i k_y$ 的代数运算。拉普拉斯算子映射为乘以 $-(k_x^2 + k_y^2)$。\n- 零傅里叶模式 $(k_x,k_y)=(0,0)$ 对应于空间平均值。为了存在有界周期解，相容性条件要求 $f$ 的空间平均值为零。如果不为零，要么通过在求解前减去 $f$ 的平均值并设定解的平均值为指定值来强制满足相容性，要么在请求的约束下指示问题不可行。\n- 当表示场的逐点乘积的离散卷积中，由于分辨率不足，高频内容会折叠到较低频率，从而产生混叠。基于填充的 $3/2$ 去混叠法则是防止这种情况的一种经过充分检验的方法，它通过在每个维度上尺寸为 $3N/2$ 的网格上临时解析非线性乘积，然后截断回原始网格。\n\n您的程序必须：\n- 构建一个求解器，它接受基础网格上的 $f(x,y)$ 并通过谱反演返回 $u(x,y)$，并提供可配置的零模式约束选项：强制右端项为零均值并为 $u$ 指定平均值，或者在 $f$ 的平均值非零时发出不可行信号。\n- 如上所述，使用基于填充的 $3/2$ 法则，实现构造某些源项所需的乘积的去混叠计算。\n- 计算并报告以下测试套件所要求的误差度量。\n\n角度单位要求：所有角度量和三角函数的参数都必须以弧度为单位进行解释。\n\n测试套件由以下案例组成，每个案例由 $(N_x,N_y,L_x,L_y)$、 $f(x,y)$ 的构造以及零模式处理策略指定。所有的 $N_x$ 和 $N_y$ 都是偶数，所有长度都以弧度为单位。对于每个案例，请按规定计算所需的标量输出。使用间距为 $L_x/N_x$ 和 $L_y/N_y$ 的均匀网格点，并遵循您编程环境的离散傅里叶变换约定。\n\n- 案例 $1$ (理想情况，解析比较)：\n  - 参数：$(N_x,N_y)=(64,64)$，$(L_x,L_y)=(2\\pi,2\\pi)$。\n  - 在网格上定义 $f(x,y) = \\sin(x) + \\sin(y)$。\n  - 使用零模式约束求解 $u$，该约束通过减去 $f$ 的平均值（该值已为零）来强制满足相容性，并将 $u$ 的平均值设为 $0$。\n  - 计算解析参考解 $u_{\\text{ref}}(x,y) = -\\sin(x) - \\sin(y)$。\n  - 输出最大绝对误差 $\\max_{x,y} |u(x,y) - u_{\\text{ref}}(x,y)|$，格式为浮点数。\n\n- 案例 $2$ (非零平均值右端项，强制相容)：\n  - 参数：$(N_x,N_y)=(64,64)$，$(L_x,L_y)=(2\\pi,2\\pi)$。\n  - 在网格上定义 $f(x,y) = 1$。\n  - 使用零模式约束求解，该约束通过减去 $\\langle f \\rangle$ 来强制满足相容性，并将 $u$ 的平均值设为 $0$。\n  - 输出最大绝对值 $\\max_{x,y} |u(x,y)|$，格式为浮点数。\n\n- 案例 $3$ (非线性源项，去混叠方法与朴素方法的比较)：\n  - 参数：$(N_x,N_y)=(64,64)$，$(L_x,L_y)=(2\\pi,2\\pi)$。\n  - 定义 $s(x,y) = \\sin(25 x) + \\sin(25 y)$。\n  - 使用两种方法构造矢量场 $\\boldsymbol{q}(x,y) = (s^2(x,y), s^2(x,y))$：\n    - 去混叠方法：如上所述，使用基于填充的 $3/2$ 法则计算 $s^2$。\n    - 朴素方法：在基础网格上计算 $s^2$，不进行任何去混叠处理。\n  - 对每种方法，在基础网格上使用谱微分计算 $f(x,y) = \\nabla \\cdot \\boldsymbol{q}(x,y)$，并在强制相容且 $u$ 的平均值设为 $0$ 的条件下求解 $u$。\n  - 输出两个解之间的均方根差，即 $\\sqrt{\\langle (u_{\\text{dealiased}} - u_{\\text{naive}})^2 \\rangle}$，格式为浮点数。\n\n- 案例 $4$ (为解指定平均值)：\n  - 参数：$(N_x,N_y)=(64,64)$，$(L_x,L_y)=(2\\pi,2\\pi)$。\n  - 定义 $f(x,y) = \\sin(x)$。\n  - 在强制相容且解的平均值指定为 $m = 0.3$ 的条件下求解。\n  - 输出绝对偏差 $|\\langle u \\rangle - m|$，格式为浮点数。\n\n- 案例 $5$ (不可行性信号)：\n  - 参数：$(N_x,N_y)=(64,64)$，$(L_x,L_y)=(2\\pi,2\\pi)$。\n  - 定义 $f(x,y) = 1$。\n  - 尝试使用一种不强制相容的零模式策略求解，该策略在 $\\langle f \\rangle \\neq 0$ 时会发出不可行信号。\n  - 如果正确地发出了不可行信号，则输出整数 $1$，否则输出 $0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个案例的结果，以逗号分隔的列表形式封装在方括号中，按案例 $1$ 到案例 $5$ 的顺序排列，例如 $[r_1,r_2,r_3,r_4,r_5]$。",
            "solution": "该问题旨在为二维周期性泊松方程 $\\nabla^2 u(x,y) = f(x,y)$ 构建一个数值求解器，该方程定义在矩形域 $[0, L_x] \\times [0, L_y]$ 上。该方法必须基于使用快速傅里叶变换 (FFT) 的谱技术，包含用于非线性项的去混叠方案，并正确处理与零傅里叶模式相关的奇异性。\n\n该解建立在傅里叶级数的性质之上。一个在域上足够光滑的周期函数 $u(x,y)$ 可以用傅里叶级数表示。在一个由 $N_x \\times N_y$ 个点组成的离散均匀网格上，其中 $x_j = j L_x / N_x$ (对于 $j \\in \\{0, \\dots, N_x-1\\}$) 且 $y_l = l L_y / N_y$ (对于 $l \\in \\{0, \\dots, N_y-1\\}$)，该级数由离散傅里叶变换 (DFT) 近似。正向和反向 DFT 定义如下：\n$$\n\\hat{u}_{m,n} = \\sum_{j=0}^{N_x-1} \\sum_{l=0}^{N_y-1} u(x_j, y_l) e^{-i (k_m x_j + k_n y_l)}\n$$\n$$\nu(x_j, y_l) = \\frac{1}{N_x N_y} \\sum_{m=-N_x/2}^{N_x/2-1} \\sum_{n=-N_y/2}^{N_y/2-1} \\hat{u}_{m,n} e^{i (k_m x_j + k_n y_l)}\n$$\n这里，$k_m = 2\\pi m/L_x$ 和 $k_n = 2\\pi n/L_y$ 是波数。Python 的 `numpy.fft` 库提供了这些变换的高效实现，即 `fft2` 和 `ifft2`，它们内部处理归一化常数，使得 `ifft2(fft2(u)) == u`。\n\n傅里叶变换的一个关键性质是，物理空间中的微分对应于傅里叶空间中的代数乘法。具体来说，偏导数 $\\partial/\\partial x$ 变换为乘以 $i k_x$，而 $\\partial/\\partial y$ 变换为乘以 $i k_y$。因此，拉普拉斯算子 $\\nabla^2 = \\partial^2/\\partial x^2 + \\partial^2/\\partial y^2$ 变换为乘以 $(i k_x)^2 + (i k_y)^2 = -(k_x^2 + k_y^2)$。\n\n对泊松方程 $\\nabla^2 u = f$ 应用傅里叶变换，得到解的傅里叶系数 $\\hat{u}$ 的代数方程：\n$$\n-(k_x^2 + k_y^2) \\hat{u}(k_x, k_y) = \\hat{f}(k_x, k_y)\n$$\n傅里叶系数的解随即通过除法得到：\n$$\n\\hat{u}(k_x, k_y) = \\frac{\\hat{f}(k_x, k_y)}{-(k_x^2 + k_y^2)}\n$$\n这构成了谱泊松求解器的核心。算法如下：1) 将源项 $f(x,y)$ 变换到傅里叶空间以获得 $\\hat{f}(k_x, k_y)$；2) 将每个系数除以对应的 $-(k_x^2 + k_y^2)$ 值；3) 将得到的系数 $\\hat{u}(k_x, k_y)$ 变换回物理空间以获得解 $u(x,y)$。\n\n对于零频率模式 $(k_x, k_y) = (0, 0)$，会出现一个关键问题。对于此模式，分母 $-(k_x^2 + k_y^2)$ 为零，导致奇异性。这是封闭周期域上泊松问题相容性条件的数值体现。将方程在整个域上积分得到 $\\iint \\nabla^2 u \\,dx\\,dy = \\iint f \\,dx\\,dy$。根据带有周期性边界的散度定理，左侧为零。因此，只有当 $\\iint f \\,dx\\,dy = 0$ 时，解才存在。用离散术语来说，$f$ 的平均值必须为零，这等价于其零频率傅里叶系数 $\\hat{f}(0,0)$ 为零。\n如果 $\\hat{f}(0,0) = 0$，则零模式的方程变为 $0 \\cdot \\hat{u}(0,0) = 0$，这意味着 $\\hat{u}(0,0)$ 是不确定的。由于解的平均值由 $\\langle u \\rangle = \\hat{u}(0,0) / (N_x N_y)$ 给出，这种不确定性对应于解仅在相差一个加法常数的意义下是确定的。通过指定 $u$ 的平均值可以获得唯一解。所实现的求解器根据指定的策略处理此问题：\n$1$. 强制相容性：如果 $\\hat{f}(0,0) \\neq 0$，则将其值设为 $0$（等同于从 $f$ 中减去其平均值）。然后，将 $\\hat{u}(0,0)$ 设为对应于 $u$ 的指定平均值（例如 $0$）的值。为避免代码中出现除以零的情况，傅里叶空间拉普拉斯算子的 $(0,0)$ 项通常设为一个非零值（例如 $1$），因为其对应的分子 $\\hat{f}(0,0)$ 是分开处理的。\n$2$. 发出不可行信号：如果 $\\hat{f}(0,0)$ 在一个小容差范围内非零，则问题是病态的，求解器会发出在给定约束下不存在解的信号。\n\n对于非线性源项，例如涉及场乘积的项，DFT 可能会引入混叠误差。如果一个场 $s$ 包含最高波数为 $K$ 的频率，其乘积 $s^2$ 将包含最高为 $2K$ 的频率。如果 $2K$ 超过了网格的奈奎斯特频率（约为 $N/2$），这些较高的频率将被错误地表示为较低的频率，从而污染解。$3/2$ 填充法则是用于二次非线性项去混叠的标准方法。一个场被变换到傅里叶空间，其傅里叶表示通过补零扩展到每个维度上大 $3/2$ 倍的网格上。然后将其变换回这个更大的物理网格。在这个高分辨率网格上，逐点计算乘积。由于网格更大，它可以正确地表示乘积的更高频率。结果被变换回填充后的傅里叶空间，然后截断出原始的、较小的低频模式集，并用于求解。这个过程确保了计算出的非线性项没有混叠污染。\n\n该程序在一组函数中实现了这些原理。一个核心的 `poisson_solver` 函数对拉普拉斯算子求逆，并带有可配置的零模式处理。还构建了用于执行谱微分和去混叠乘积的辅助函数。然后使用这些函数来解决提供的具体测试案例。\n- 对于案例 $1$，求解器与一个解析解进行对比测试。\n- 对于案例 $2$，它演示了如何为具有非零平均值的右端项强制执行相容性。\n- 对于案例 $3$，通过将使用去混叠非线性源项的解与使用朴素计算（有混叠）的源项的解进行比较，来量化去混叠的效果。\n- 对于案例 $4$，验证了为解指定非零平均值的能力。\n- 对于案例 $5$，测试了求解器检测并发出不可行问题信号的能力。\n所有涉及角度和三角函数的计算均按规定使用弧度进行。",
            "answer": "```python\nimport numpy as np\n\ndef poisson_solver(f_phys, Lx, Ly, policy, mean_u=0.0):\n    \"\"\"\n    Solves the 2D periodic Poisson equation using FFT.\n\n    Args:\n        f_phys (np.ndarray): The source term f(x,y) in physical space.\n        Lx (float): Domain length in x.\n        Ly (float): Domain length in y.\n        policy (str): Zero-mode handling policy ('enforce_compatibility' or 'signal_infeasibility').\n        mean_u (float): Prescribed mean for the solution u.\n\n    Returns:\n        np.ndarray or str: The solution u(x,y) in physical space, or \"infeasible\".\n    \"\"\"\n    Nx, Ny = f_phys.shape\n    f_hat = np.fft.fft2(f_phys)\n\n    # Handle zero-mode based on policy\n    if policy == 'signal_infeasibility':\n        if np.abs(f_hat[0, 0]) > 1e-9:\n            return \"infeasible\"\n    \n    # For 'enforce_compatibility', we set the mean of f to zero.\n    # This also applies to 'signal_infeasibility' if f_hat[0,0] is zero.\n    f_hat[0, 0] = 0.0\n\n    # Wavenumbers\n    kx_1d = 2 * np.pi * np.fft.fftfreq(Nx, d=Lx / Nx)\n    ky_1d = 2 * np.pi * np.fft.fftfreq(Ny, d=Ly / Ny)\n    kx, ky = np.meshgrid(kx_1d, ky_1d, indexing='ij')\n\n    # Laplacian operator in Fourier space\n    lap_fourier = -(kx**2 + ky**2)\n    \n    # Avoid division by zero at k=0. The value is a placeholder as u_hat[0,0] is set separately.\n    lap_fourier[0, 0] = 1.0\n\n    # Solve for u_hat\n    u_hat = f_hat / lap_fourier\n\n    # Set the mean of the solution u\n    u_hat[0, 0] = mean_u * Nx * Ny\n\n    # Transform back to physical space\n    u_phys = np.fft.ifft2(u_hat)\n\n    return np.real(u_phys)\n\ndef dealiased_product(a_phys, b_phys):\n    \"\"\"\n    Computes the dealiased product of two fields using the 3/2 padding rule.\n\n    Args:\n        a_phys (np.ndarray): First field in physical space.\n        b_phys (np.ndarray): Second field in physical space.\n\n    Returns:\n        np.ndarray: The dealiased product in physical space.\n    \"\"\"\n    Nx, Ny = a_phys.shape\n    Mx, My = int(Nx * 3 / 2), int(Ny * 3 / 2)\n\n    a_hat = np.fft.fft2(a_phys)\n    b_hat = np.fft.fft2(b_phys)\n\n    a_hat_padded = np.zeros((Mx, My), dtype=np.complex128)\n    b_hat_padded = np.zeros((Mx, My), dtype=np.complex128)\n    \n    hx, hy = Nx // 2, Ny // 2\n\n    # Copy low-frequency coefficients to padded array\n    a_hat_padded[:hx, :hy] = a_hat[:hx, :hy]\n    a_hat_padded[:hx, My-hy:] = a_hat[:hx, hy:]\n    a_hat_padded[Mx-hx:, :hy] = a_hat[hx:, :hy]\n    a_hat_padded[Mx-hx:, My-hy:] = a_hat[hx:, hy:]\n\n    b_hat_padded[:hx, :hy] = b_hat[:hx, :hy]\n    b_hat_padded[:hx, My-hy:] = b_hat[:hx, hy:]\n    b_hat_padded[Mx-hx:, :hy] = b_hat[hx:, :hy]\n    b_hat_padded[Mx-hx:, My-hy:] = b_hat[hx:, hy:]\n    \n    # Transform to padded physical grid\n    a_padded = np.fft.ifft2(a_hat_padded)\n    b_padded = np.fft.ifft2(b_hat_padded)\n\n    # Compute product on padded grid\n    product_padded = a_padded * b_padded\n\n    # Transform product back to padded Fourier space\n    product_hat_padded = np.fft.fft2(product_padded)\n\n    # Truncate back to original Fourier grid size\n    product_hat = np.zeros((Nx, Ny), dtype=np.complex128)\n\n    product_hat[:hx, :hy] = product_hat_padded[:hx, :hy]\n    product_hat[:hx, Ny-hy:] = product_hat_padded[:hx, My-hy:]\n    product_hat[Nx-hx:, :hy] = product_hat_padded[Mx-hx:, :hy]\n    product_hat[Nx-hx:, Ny-hy:] = product_hat_padded[Mx-hx:, My-hy:]\n\n    # Transform truncated product to original physical grid\n    product_phys = np.fft.ifft2(product_hat)\n    \n    return np.real(product_phys)\n\ndef spectral_div(qx_phys, qy_phys, Lx, Ly):\n    \"\"\"\n    Computes the divergence of a vector field using spectral differentiation.\n    \n    Args:\n        qx_phys (np.ndarray): x-component of the vector field.\n        qy_phys (np.ndarray): y-component of the vector field.\n        Lx (float): Domain length in x.\n        Ly (float): Domain length in y.\n\n    Returns:\n        np.ndarray: The divergence in physical space.\n    \"\"\"\n    Nx, Ny = qx_phys.shape\n    \n    qx_hat = np.fft.fft2(qx_phys)\n    qy_hat = np.fft.fft2(qy_phys)\n\n    kx_1d = 2 * np.pi * np.fft.fftfreq(Nx, d=Lx / Nx)\n    ky_1d = 2 * np.pi * np.fft.fftfreq(Ny, d=Ly / Ny)\n    kx, ky = np.meshgrid(kx_1d, ky_1d, indexing='ij')\n\n    div_q_hat = 1j * kx * qx_hat + 1j * ky * qy_hat\n    \n    div_q_phys = np.fft.ifft2(div_q_hat)\n    \n    return np.real(div_q_phys)\n\ndef solve():\n    results = []\n    \n    # --- Case 1: Happy path, analytic comparison ---\n    Nx, Ny = 64, 64\n    Lx, Ly = 2 * np.pi, 2 * np.pi\n    x = np.linspace(0, Lx, Nx, endpoint=False)\n    y = np.linspace(0, Ly, Ny, endpoint=False)\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    f_case1 = np.sin(xx) + np.sin(yy)\n    u_case1 = poisson_solver(f_case1, Lx, Ly, 'enforce_compatibility', mean_u=0.0)\n    u_ref_case1 = -np.sin(xx) - np.sin(yy)\n    error_case1 = np.max(np.abs(u_case1 - u_ref_case1))\n    results.append(error_case1)\n\n    # --- Case 2: Nonzero mean RHS, compatibility enforced ---\n    f_case2 = np.ones((Nx, Ny))\n    u_case2 = poisson_solver(f_case2, Lx, Ly, 'enforce_compatibility', mean_u=0.0)\n    max_abs_u_case2 = np.max(np.abs(u_case2))\n    results.append(max_abs_u_case2)\n\n    # --- Case 3: Nonlinear source term and dealiasing ---\n    s_case3 = np.sin(25 * xx) + np.sin(25 * yy)\n    \n    # Dealiased method\n    s2_dealiased = dealiased_product(s_case3, s_case3)\n    q_d = s2_dealiased\n    f_dealiased = spectral_div(q_d, q_d, Lx, Ly)\n    u_dealiased = poisson_solver(f_dealiased, Lx, Ly, 'enforce_compatibility', mean_u=0.0)\n    \n    # Naive method\n    s2_naive = s_case3**2\n    q_n = s2_naive\n    f_naive = spectral_div(q_n, q_n, Lx, Ly)\n    u_naive = poisson_solver(f_naive, Lx, Ly, 'enforce_compatibility', mean_u=0.0)\n\n    rms_diff = np.sqrt(np.mean((u_dealiased - u_naive)**2))\n    results.append(rms_diff)\n\n    # --- Case 4: Prescribed mean for the solution ---\n    m = 0.3\n    f_case4 = np.sin(xx)\n    u_case4 = poisson_solver(f_case4, Lx, Ly, 'enforce_compatibility', mean_u=m)\n    deviation_case4 = np.abs(np.mean(u_case4) - m)\n    results.append(deviation_case4)\n\n    # --- Case 5: Infeasibility signaling ---\n    f_case5 = np.ones((Nx, Ny))\n    result_case5 = poisson_solver(f_case5, Lx, Ly, 'signal_infeasibility')\n    infeasibility_signaled = 1 if result_case5 == \"infeasible\" else 0\n    results.append(infeasibility_signaled)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}