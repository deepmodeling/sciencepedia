{
    "hands_on_practices": [
        {
            "introduction": "The foundation of computational fluid dynamics lies in approximating the continuous partial derivatives of the Euler and Navier-Stokes equations with discrete algebraic operations. This first exercise provides essential practice in analyzing the local truncation error, which quantifies the discrepancy between the continuous derivative and its finite-difference approximation. Mastering the use of Taylor series expansions to determine a scheme's order of accuracy is a fundamental skill for any CFD practitioner, as it directly informs the choice of numerical methods and the expected behavior of the simulation error under grid refinement .",
            "id": "3979200",
            "problem": "Consider a one-dimensional, sufficiently smooth compressible flow along the coordinate $x$, with density $\\rho(x)$ and velocity $u(x)$. The mass flux is $f(x) = \\rho(x) u(x)$, and the continuity equation involves the spatial derivative $\\partial_x(\\rho u) = \\partial_x f$. On a uniform grid with points $x_i = i \\Delta x$ and spacing $\\Delta x > 0$, two widely used finite-difference approximations for $\\partial_x f$ at $x_i$ are:\n- The central-difference approximation defined by\n$$\\mathcal{D}_{c}[f]_i = \\frac{f_{i+1} - f_{i-1}}{2 \\Delta x},$$\n- The upwind approximation (assume $u(x_i) > 0$ so that the upwind direction is from $x_{i-1}$ to $x_i$) defined by\n$$\\mathcal{D}_{u}[f]_i = \\frac{f_i - f_{i-1}}{\\Delta x}.$$\n\nStarting from fundamental definitions of derivatives and smooth functions, provide a precise definition of the local truncation error for a finite-difference approximation to $\\partial_x f$. Then, for each of the two approximations above, derive the truncation error at $x_i$ in terms of derivatives of $f(x) = \\rho(x) u(x)$ evaluated at $x_i$, and determine the order of accuracy $p$ such that $|\\tau_i(\\Delta x)| = \\mathcal{O}(\\Delta x^p)$ as $\\Delta x \\to 0$. Express your final answer as a row matrix $\\begin{pmatrix}p_{\\mathrm{central}} & p_{\\mathrm{upwind}}\\end{pmatrix}$ using the LaTeX $\\mathrm{pmatrix}$ environment.",
            "solution": "The problem as stated is valid. It is scientifically grounded in the principles of numerical analysis and fluid dynamics, specifically concerning the analysis of finite-difference schemes for conservation laws. The problem is well-posed, objective, and self-contained, providing all necessary definitions and constraints to arrive at a unique, verifiable solution. The assumption of a \"sufficiently smooth\" flow is a standard and necessary condition that allows for the use of Taylor series expansions, which are fundamental to the analysis of truncation error.\n\nFirst, we must provide a precise definition of the local truncation error. Let $\\mathcal{L}$ be a differential operator, and let $\\mathcal{D}_{\\Delta x}$ be a finite-difference operator that approximates $\\mathcal{L}$ on a grid with spacing $\\Delta x$. Let $f(x)$ be a sufficiently smooth function. The local truncation error, denoted by $\\tau(x)$, is the residual obtained when the exact smooth function $f(x)$ is substituted into the finite-difference approximation. It measures how well the discrete operator $\\mathcal{D}_{\\Delta x}$ approximates the continuous operator $\\mathcal{L}$ at a specific point $x$. For a spatial derivative $\\mathcal{L} = \\partial_x$, the truncation error at a grid point $x_i$ is defined as:\n$$\n\\tau_i(\\Delta x) = \\mathcal{D}_{\\Delta x}[f]_i - (\\partial_x f)|_{x=x_i}\n$$\nwhere $(\\partial_x f)|_{x=x_i}$ is the exact value of the first derivative of $f(x)$ evaluated at $x_i$, which we will denote as $f'(x_i)$. The order of accuracy of the approximation is the integer $p$ such that the magnitude of the truncation error behaves as $|\\tau_i(\\Delta x)| = \\mathcal{O}((\\Delta x)^p)$ in the limit $\\Delta x \\to 0$.\n\nTo determine the truncation error for each given scheme, we employ Taylor series expansions of the function $f(x)$ around the point $x_i$. We denote $f(x_i)$ as $f_i$, $f(x_i+\\Delta x)$ as $f_{i+1}$, and $f(x_i-\\Delta x)$ as $f_{i-1}$. The assumption that the flow is \"sufficiently smooth\" guarantees that $f(x)$ has continuous derivatives of the required order.\n\nThe Taylor series expansions for $f_{i+1}$ and $f_{i-1}$ around $x_i$ are:\n$$\nf_{i+1} = f(x_i + \\Delta x) = f_i + (\\Delta x) f'(x_i) + \\frac{(\\Delta x)^2}{2!} f''(x_i) + \\frac{(\\Delta x)^3}{3!} f'''(x_i) + \\mathcal{O}((\\Delta x)^4)\n$$\n$$\nf_{i-1} = f(x_i - \\Delta x) = f_i - (\\Delta x) f'(x_i) + \\frac{(\\Delta x)^2}{2!} f''(x_i) - \\frac{(\\Delta x)^3}{3!} f'''(x_i) + \\mathcal{O}((\\Delta x)^4)\n$$\nwhere $f'(x_i)$, $f''(x_i)$, and $f'''(x_i)$ are the first, second, and third derivatives of $f(x)$ evaluated at $x_i$.\n\nLet us analyze the central-difference approximation, $\\mathcal{D}_{c}[f]_i$.\n$$\n\\mathcal{D}_{c}[f]_i = \\frac{f_{i+1} - f_{i-1}}{2 \\Delta x}\n$$\nSubstituting the Taylor series expansions into this expression:\n$$\n\\mathcal{D}_{c}[f]_i = \\frac{1}{2 \\Delta x} \\left[ \\left( f_i + \\Delta x f'(x_i) + \\frac{(\\Delta x)^2}{2} f''(x_i) + \\frac{(\\Delta x)^3}{6} f'''(x_i) + \\dots \\right) - \\left( f_i - \\Delta x f'(x_i) + \\frac{(\\Delta x)^2}{2} f''(x_i) - \\frac{(\\Delta x)^3}{6} f'''(x_i) + \\dots \\right) \\right]\n$$\nSimplifying the terms in the numerator:\n$$\nf_{i+1} - f_{i-1} = (f_i - f_i) + (\\Delta x f'(x_i) - (-\\Delta x f'(x_i))) + \\left(\\frac{(\\Delta x)^2}{2} f''(x_i) - \\frac{(\\Delta x)^2}{2} f''(x_i)\\right) + \\left(\\frac{(\\Delta x)^3}{6} f'''(x_i) - \\left(-\\frac{(\\Delta x)^3}{6} f'''(x_i)\\right)\\right) + \\dots\n$$\n$$\nf_{i+1} - f_{i-1} = 2 \\Delta x f'(x_i) + \\frac{2 (\\Delta x)^3}{6} f'''(x_i) + \\mathcal{O}((\\Delta x)^5) = 2 \\Delta x f'(x_i) + \\frac{(\\Delta x)^3}{3} f'''(x_i) + \\mathcal{O}((\\Delta x)^5)\n$$\nNow, substitute this back into the formula for $\\mathcal{D}_{c}[f]_i$:\n$$\n\\mathcal{D}_{c}[f]_i = \\frac{1}{2 \\Delta x} \\left[ 2 \\Delta x f'(x_i) + \\frac{(\\Delta x)^3}{3} f'''(x_i) + \\mathcal{O}((\\Delta x)^5) \\right] = f'(x_i) + \\frac{(\\Delta x)^2}{6} f'''(x_i) + \\mathcal{O}((\\Delta x)^4)\n$$\nThe truncation error for the central-difference scheme, $\\tau_{c,i}$, is:\n$$\n\\tau_{c,i}(\\Delta x) = \\mathcal{D}_{c}[f]_i - f'(x_i) = \\frac{(\\Delta x)^2}{6} f'''(x_i) + \\mathcal{O}((\\Delta x)^4)\n$$\nThe leading error term is proportional to $(\\Delta x)^2$. Therefore, the order of accuracy for the central-difference scheme is $p_{\\mathrm{central}} = 2$.\n\nNext, we analyze the upwind approximation, $\\mathcal{D}_{u}[f]_i$.\n$$\n\\mathcal{D}_{u}[f]_i = \\frac{f_i - f_{i-1}}{\\Delta x}\n$$\nSubstituting the Taylor series expansion for $f_{i-1}$:\n$$\n\\mathcal{D}_{u}[f]_i = \\frac{1}{\\Delta x} \\left[ f_i - \\left( f_i - \\Delta x f'(x_i) + \\frac{(\\Delta x)^2}{2} f''(x_i) - \\frac{(\\Delta x)^3}{6} f'''(x_i) + \\dots \\right) \\right]\n$$\nSimplifying the terms in the numerator:\n$$\nf_i - f_{i-1} = f_i - f_i + \\Delta x f'(x_i) - \\frac{(\\Delta x)^2}{2} f''(x_i) + \\frac{(\\Delta x)^3}{6} f'''(x_i) - \\dots\n$$\n$$\nf_i - f_{i-1} = \\Delta x f'(x_i) - \\frac{(\\Delta x)^2}{2} f''(x_i) + \\mathcal{O}((\\Delta x)^3)\n$$\nNow, substitute this back into the formula for $\\mathcal{D}_{u}[f]_i$:\n$$\n\\mathcal{D}_{u}[f]_i = \\frac{1}{\\Delta x} \\left[ \\Delta x f'(x_i) - \\frac{(\\Delta x)^2}{2} f''(x_i) + \\mathcal{O}((\\Delta x)^3) \\right] = f'(x_i) - \\frac{\\Delta x}{2} f''(x_i) + \\mathcal{O}((\\Delta x)^2)\n$$\nThe truncation error for the upwind scheme, $\\tau_{u,i}$, is:\n$$\n\\tau_{u,i}(\\Delta x) = \\mathcal{D}_{u}[f]_i - f'(x_i) = - \\frac{\\Delta x}{2} f''(x_i) + \\mathcal{O}((\\Delta x)^2)\n$$\nThe leading error term is proportional to $\\Delta x$. Therefore, the order of accuracy for the upwind scheme is $p_{\\mathrm{upwind}} = 1$.\n\nIn conclusion, the central-difference scheme is second-order accurate, while the upwind scheme is first-order accurate. The required answer is the row matrix of these orders of accuracy.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2 & 1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While theoretical analysis reveals a scheme's formal order of accuracy, practical verification requires confirming this behavior using actual simulation output. This exercise guides you through a cornerstone of CFD validation: the grid convergence study. By analyzing results from a sequence of systematically refined grids, you can compute the observed order of accuracy and use Richardson extrapolation to estimate the grid-independent solution, providing a powerful tool for quantifying and reducing discretization error in your simulations .",
            "id": "3979183",
            "problem": "Consider a steady, inviscid or viscous flow governed by the Euler equations or the Navier–Stokes equations. In Computational Fluid Dynamics (CFD), a finite volume (or finite difference) discretization of a smooth functional of the solution, such as an integrated quantity $Q$ (for example, lift coefficient, drag coefficient, or mass flow), yields a sequence of grid-dependent approximations $Q(h)$ when the grid spacing $h$ is refined. Under grid refinement and when the solution is sufficiently smooth and the scheme consistent, the leading-order discretization error admits an asymptotic expansion of the form\n$$\nQ(h) \\;=\\; Q^\\star \\;+\\; K\\,h^{p} \\;+\\; \\mathcal{O}(h^{p+1}),\n$$\nwhere $Q^\\star$ is the asymptotic (grid-independent) solution, $K$ is a constant independent of $h$, and $p$ is the formal order of accuracy for the dominant error term. For grids with characteristic spacings $h_1<h_2<h_3$, and computed approximations $Q_1=Q(h_1)$, $Q_2=Q(h_2)$, $Q_3=Q(h_3)$, the observed order of accuracy $p$ can be inferred from the three-grid sequence, and Richardson extrapolation can be applied to estimate $Q^\\star$ and the discretization error on the finest grid.\n\nStarting from the asymptotic error model for $Q(h)$ and the definition of the grid refinement ratios $r_{21}=h_2/h_1>1$ and $r_{32}=h_3/h_2>1$, derive a principled computational procedure that:\n- infers the observed order of accuracy $p$ from the triplet $(Q_1,Q_2,Q_3)$ and $(h_1,h_2,h_3)$ without assuming equal refinement ratios, and\n- estimates the asymptotic solution $Q^\\star$ and the discretization error on the finest grid, using only $(Q_1,Q_2)$, $(h_1,h_2)$, and the inferred $p$ in a two-grid Richardson extrapolation.\n\nYour derivation should start from the conservation-law base of the Euler or Navier–Stokes equations, the consistency of the discrete operator, and the Taylor-series characterization of the truncation error, and must reason out the relationships needed to build a numerically robust algorithm. You must avoid providing shortcut final formulas in the problem statement; rather, clearly state the assumptions and the logical steps needed to obtain the computational method.\n\nImplement the derived method in a program that takes no input and applies it to the following test suite of grid refinement data, each representing a distinct scenario commonly encountered in aerospace CFD grid-convergence studies. All quantities $Q$ are dimensionless, and the grids are characterized by scalar spacings $h$ that can be interpreted as representative cell sizes. The test suite values are:\n\n- Case A (constant refinement ratio, monotone sequence, moderate order): $h_1=0.01$, $h_2=0.02$, $h_3=0.04$; $Q_1=0.53388$, $Q_2=0.53352$, $Q_3=0.53208$.\n- Case B (unequal refinement ratios, monotone sequence, non-integer order): $h_1=0.015$, $h_2=0.03$, $h_3=0.07$; $Q_1=1.20063448$, $Q_2=1.20205920$, $Q_3=1.20870400$.\n- Case C (constant refinement ratio, high order with very small errors): $h_1=0.02$, $h_2=0.04$, $h_3=0.08$; $Q_1=0.0000008$, $Q_2=0.0000128$, $Q_3=0.0002048$.\n- Case D (unequal refinement ratios, small refinement steps, non-integer order): $h_1=0.008$, $h_2=0.01$, $h_3=0.012$; $Q_1=0.749990284$, $Q_2=0.749984076$, $Q_3=0.74997619$.\n\nFor each case:\n1. Compute the observed order of accuracy $p$ from $(Q_1,Q_2,Q_3)$ and $(h_1,h_2,h_3)$.\n2. Using $(Q_1,Q_2)$, $(h_1,h_2)$, and the computed $p$, compute the Richardson-extrapolated estimate of the asymptotic solution $Q^\\star$.\n3. Compute the discretization error magnitude on the finest grid, $E_1=\\lvert Q^\\star - Q_1\\rvert$.\n\nYour program should produce a single line of output containing the results for all cases as a comma-separated list of lists, where each inner list contains $[p,Q^\\star,E_1]$ for one case. All three numbers for each case must be rounded to eight decimal places. For example, the output format must be:\n\"[[p_A,Qstar_A,E1_A],[p_B,Qstar_B,E1_B],[p_C,Qstar_C,E1_C],[p_D,Qstar_D,E1_D]]\".",
            "solution": "The problem posed is a standard exercise in the verification and validation of numerical simulations, specifically concerning the estimation of discretization error and the observed order of accuracy from a grid refinement study. It is scientifically sound, well-posed, and contains all necessary information for a unique solution. We proceed with the derivation.\n\nThe foundation of this analysis rests on the behavior of the discretization error for a consistent numerical scheme applied to a sufficiently smooth problem. For governing partial differential equations like the Euler or Navier-Stokes equations, a finite volume or finite difference scheme approximates the continuous differential operator $L(u)=f$ with a discrete operator $L_h(U_h)=f_h$, where $U_h$ is the discrete solution on a grid with characteristic spacing $h$. The truncation error, $\\tau_h = L_h(u_{ex}) - f_h$, where $u_{ex}$ is the exact solution to the continuous problem projected onto the grid, can be expanded via a Taylor series for a consistent scheme. For a scheme of order $p$, $\\tau_h = C h^p + \\mathcal{O}(h^{p+1})$. It can be shown that, under suitable conditions of stability and smoothness, the error in the discrete solution itself, $e_h = U_h - u_{ex}$, and consequently the error in a smooth functional of the solution $Q(h)$, follows a similar asymptotic expansion.\n\nWe are given this leading-order asymptotic error model for a computed functional $Q(h)$:\n$$\nQ(h) \\;=\\; Q^\\star \\;+\\; K h^{p} \\;+\\; \\mathcal{O}(h^{p+1})\n$$\nwhere $Q^\\star$ is the exact, grid-independent value of the functional, $K$ is a constant, $p$ is the formal order of accuracy, and $h$ is the grid spacing. For our analysis, we will assume the higher-order terms are negligible, which is a valid approximation for sufficiently small $h$. This reduces the model to:\n$$\nQ(h) \\approx Q^\\star + K h^p\n$$\nGiven a sequence of three grids with characteristic spacings $h_1 < h_2 < h_3$ and their corresponding computed solutions $Q_1 = Q(h_1)$, $Q_2 = Q(h_2)$, and $Q_3 = Q(h_3)$, we can write a system of three equations with three unknowns ($Q^\\star$, $K$, $p$):\n\\begin{align*}\nQ_1 &\\approx Q^\\star + K h_1^p \\quad &(1) \\\\\nQ_2 &\\approx Q^\\star + K h_2^p \\quad &(2) \\\\\nQ_3 &\\approx Q^\\star + K h_3^p \\quad &(3)\n\\end{align*}\n\n**Step 1: Derivation of the Observed Order of Accuracy, $p$**\n\nTo determine the observed order of accuracy $p$, we must eliminate the unknowns $Q^\\star$ and $K$. We first eliminate $Q^\\star$ by taking differences between successive equations:\n$$\nQ_2 - Q_1 \\approx (Q^\\star + K h_2^p) - (Q^\\star + K h_1^p) = K (h_2^p - h_1^p) \\quad (4)\n$$\n$$\nQ_3 - Q_2 \\approx (Q^\\star + K h_3^p) - (Q^\\star + K h_2^p) = K (h_3^p - h_2^p) \\quad (5)\n$$\nThese equations represent the change in the solution as a function of the change in the grid spacing. We can now eliminate the constant $K$ by taking the ratio of equation $(5)$ to equation $(4)$, provided that $Q_2 - Q_1 \\neq 0$:\n$$\n\\frac{Q_3 - Q_2}{Q_2 - Q_1} \\approx \\frac{K (h_3^p - h_2^p)}{K (h_2^p - h_1^p)} = \\frac{h_3^p - h_2^p}{h_2^p - h_1^p}\n$$\nThis equation relates the observed order $p$ to the solution values and grid spacings. It holds for any grid refinement ratios. Let $\\mathcal{R}_Q = \\frac{Q_3 - Q_2}{Q_2 - Q_1}$. We must then solve the following nonlinear equation for $p$:\n$$\n\\mathcal{R}_Q = \\frac{h_3^p - h_2^p}{h_2^p - h_1^p}\n$$\nRearranging gives the function whose root we seek:\n$$\nf(p) = \\frac{h_3^p - h_2^p}{h_2^p - h_1^p} - \\mathcal{R}_Q = 0\n$$\nThis is a transcendental equation that generally cannot be solved for $p$ in closed form. A principled computational procedure, as requested, involves using a numerical root-finding algorithm, such as the bisection method or a more sophisticated one like Brent's method, to find the value of $p$ that satisfies this equation.\n\nIn the special case where the grid refinement ratio is constant, i.e., $r = h_2/h_1 = h_3/h_2$, we have $h_2 = r h_1$ and $h_3 = r^2 h_1$. The equation simplifies significantly:\n$$\n\\frac{Q_3 - Q_2}{Q_2 - Q_1} = \\frac{(r^2 h_1)^p - (r h_1)^p}{(r h_1)^p - h_1^p} = \\frac{h_1^p (r^{2p} - r^p)}{h_1^p (r^p - 1)} = \\frac{r^p(r^p - 1)}{r^p - 1} = r^p\n$$\nIn this case, $p$ can be found analytically: $p = \\frac{\\ln\\left(\\frac{Q_3 - Q_2}{Q_2 - Q_1}\\right)}{\\ln(r)}$. However, the problem requires a general procedure, so we will implement the numerical root-finding approach.\n\n**Step 2: Derivation of the Asymptotic Solution, $Q^\\star$**\n\nThe problem specifies using a two-grid Richardson extrapolation based on the finest two grids ($(h_1, Q_1)$, $(h_2, Q_2)$) and the inferred order of accuracy $p$. We use equations $(1)$ and $(2)$:\n\\begin{align*}\nQ_1 &\\approx Q^\\star + K h_1^p \\\\\nQ_2 &\\approx Q^\\star + K h_2^p\n\\end{align*}\nOur goal is to eliminate $K$ and solve for $Q^\\star$. From the first equation, we express $K$ as $K \\approx (Q_1 - Q^\\star)/h_1^p$. Substituting this into the second equation yields:\n$$\nQ_2 \\approx Q^\\star + \\frac{Q_1 - Q^\\star}{h_1^p} h_2^p = Q^\\star + (Q_1 - Q^\\star) \\left(\\frac{h_2}{h_1}\\right)^p\n$$\nLet the grid refinement ratio be $r_{21} = h_2/h_1$. The equation becomes:\n$$\nQ_2 \\approx Q^\\star + (Q_1 - Q^\\star) r_{21}^p\n$$\nWe now solve for $Q^\\star$:\n\\begin{align*}\nQ_2 &\\approx Q^\\star + Q_1 r_{21}^p - Q^\\star r_{21}^p \\\\\nQ_2 - Q_1 r_{21}^p &\\approx Q^\\star (1 - r_{21}^p) \\\\\nQ^\\star &\\approx \\frac{Q_2 - Q_1 r_{21}^p}{1 - r_{21}^p} = \\frac{Q_1 r_{21}^p - Q_2}{r_{21}^p - 1}\n\\end{align*}\nThis is the Richardson extrapolation formula for $Q^\\star$. A computationally intuitive form is to express $Q^\\star$ as an additive correction to the fine-grid solution $Q_1$:\n$$\nQ^\\star \\approx Q_1 + \\frac{Q_1 - Q_2}{r_{21}^p - 1}\n$$\n\n**Step 3: Estimation of Discretization Error on the Finest Grid, $E_1$**\n\nThe discretization error on the finest grid can be estimated as the difference between the extrapolated, grid-independent solution $Q^\\star$ and the fine-grid solution $Q_1$. The magnitude is defined as:\n$$\nE_1 = |Q^\\star - Q_1|\n$$\nUsing the expression for $Q^\\star - Q_1$ from the previous step, we obtain a direct formula for the error estimate:\n$$\nE_1 = \\left| \\frac{Q_1 - Q_2}{r_{21}^p - 1} \\right|\n$$\nThis completes the derivation of the required computational procedure.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Main function to process the test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: ((h1, h2, h3), (Q1, Q2, Q3))\n    test_cases = [\n        # Case A\n        ((0.01, 0.02, 0.04), (0.53388, 0.53352, 0.53208)),\n        # Case B\n        ((0.015, 0.03, 0.07), (1.20063448, 1.20205920, 1.20870400)),\n        # Case C\n        ((0.02, 0.04, 0.08), (0.0000008, 0.0000128, 0.0002048)),\n        # Case D\n        ((0.008, 0.01, 0.012), (0.749990284, 0.749984076, 0.74997619)),\n    ]\n\n    all_results = []\n    \n    for h_vals, Q_vals in test_cases:\n        h1, h2, h3 = h_vals\n        Q1, Q2, Q3 = Q_vals\n        \n        # --- Step 1: Compute the observed order of accuracy 'p' ---\n        \n        # Ratio of solution differences\n        # Handle potential division by zero, although not present in test data.\n        # This can happen if the solution is oscillatory or appears converged.\n        q_diff_21 = Q2 - Q1\n        if abs(q_diff_21) < 1.0e-15:\n            # If the difference is zero, 'p' is undefined. This indicates an issue\n            # with the data (e.g., convergence has been reached within machine precision).\n            # For this problem, we can assume this won't happen based on the data.\n            p = np.nan\n        else:\n            q_ratio = (Q3 - Q2) / q_diff_21\n\n            # Define the function f(p) = 0 for the root-finding algorithm\n            # f(p) = (h3^p - h2^p) / (h2^p - h1^p) - q_ratio\n            def p_equation(p_val):\n                # Numerically stable evaluation for small p by factoring out h2^p and h1^p\n                term1_num = (h3 / h2)**p_val - 1.0\n                term1_den = 1.0 - (h1 / h2)**p_val\n                # Check for p_val=0, which would lead to 0/0\n                if abs(p_val) < 1e-9:\n                    # Use L'Hopital's rule for p -> 0 limit\n                    # d/dp((a^p - 1)/(1 - b^p)) = (a^p log(a)) / (-b^p log(b)) -> log(a)/-log(b)\n                    h_ratio_term = np.log(h3 / h2) / -np.log(h1 / h2)\n                else:\n                    h_ratio_term = term1_num / term1_den\n                \n                return h_ratio_term - q_ratio\n\n            # Use SciPy's root-finding scalar function.\n            # A bracket of [0, 8] is a reasonable search range for order of accuracy.\n            try:\n                # Brent's method is typically used here, it's robust.\n                sol = root_scalar(p_equation, bracket=[0, 8], method='brentq')\n                p = sol.root\n            except ValueError:\n                # This may happen if the function does not cross zero in the bracket,\n                # e.g., for non-monotonic convergence.\n                p = np.nan\n\n        # --- Step 2: Compute the asymptotic solution Q_star ---\n\n        # Grid refinement ratio for the two finest grids\n        r21 = h2 / h1\n        \n        # Richardson extrapolation formula: Q_star = Q1 + (Q1 - Q2) / (r21^p - 1)\n        # Check for p=0 and r21=1, which is not the case here.\n        denominator = r21**p - 1.0\n        if abs(denominator) < 1.0e-15:\n            Q_star = np.nan # Undefined extrapolation\n        else:\n            Q_star = Q1 + (Q1 - Q2) / denominator\n        \n        # --- Step 3: Compute the discretization error E1 ---\n        E1 = abs(Q_star - Q1)\n\n        # Store results rounded to 8 decimal places\n        case_result = [round(val, 8) for val in [p, Q_star, E1]]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists.\n    result_str = \",\".join([str(res) for res in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "For the complex, nonlinear Navier-Stokes equations, exact analytical solutions for non-trivial flows are virtually nonexistent, making rigorous code verification a challenge. This practice introduces a sophisticated and powerful technique known as the Method of Manufactured Solutions (MMS). By designing an analytical solution and substituting it into the governing equations, you will derive the specific source terms required to make it an exact solution, thereby creating a benchmark against which every part of a CFD code can be precisely tested .",
            "id": "3979186",
            "problem": "You are tasked with developing a two-dimensional Manufactured Solution for the compressible Navier–Stokes equations suitable for validation of computational fluid dynamics solvers in aerospace applications. Begin from the fundamental conservation laws of mass, momentum, and energy for a Newtonian compressible fluid with Fourier heat conduction and an ideal-gas thermodynamic closure. You must specify analytic fields for density, velocity, and temperature, and then derive the body-force source terms that make these fields exact solutions of the governing equations. Your program should compute these forcing terms at specified space-time points and fluid-property parameter sets.\n\nAssume a two-dimensional Cartesian domain with spatial coordinates $(x,y)$ in meters and time $t$ in seconds. The analytic Manufactured Solution fields are:\n$$\n\\rho(x,y,t) = \\rho_0\\left[1 + A \\cdot 0.1 \\cdot \\sin(\\pi x)\\cos(\\pi y)\\cdot e^{-\\alpha t}\\right],\n$$\n$$\nu(x,y,t) = U_0 + A \\cdot 0.2 \\cdot \\cos(\\pi x)\\sin(\\pi y)\\cdot e^{-\\alpha t},\n$$\n$$\nv(x,y,t) = V_0 + A \\cdot 0.15 \\cdot \\sin(2\\pi x)\\sin(\\pi y)\\cdot e^{-\\alpha t},\n$$\n$$\nT(x,y,t) = T_0\\left[1 + A \\cdot 0.03 \\cdot \\cos(\\pi x)\\cos(2\\pi y)\\cdot e^{-\\alpha t}\\right].\n$$\nThe fluid obeys the ideal-gas law and caloric relations:\n$$\np = \\rho R T,\\quad c_v = \\frac{R}{\\gamma - 1},\\quad c_p = \\gamma c_v,\n$$\nand Fourier heat conduction with constant thermal conductivity $k$ related to dynamic viscosity $\\mu$ via the Prandtl number $\\mathrm{Pr}$:\n$$\nk = \\frac{\\mu c_p}{\\mathrm{Pr}}.\n$$\nThe Newtonian viscous stress tensor with Stokes hypothesis is:\n$$\n\\boldsymbol{\\tau} = \\mu\\left[\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{\\mathsf{T}} - \\frac{2}{3}(\\nabla\\cdot \\mathbf{u})\\mathbf{I}\\right].\n$$\nDefine total energy per unit mass as:\n$$\nE = e + \\frac{1}{2}(u^2 + v^2),\\quad e = c_v T.\n$$\nThe governing equations in conservative form are:\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla\\cdot(\\rho \\mathbf{u}) = f_\\rho,\n$$\n$$\n\\frac{\\partial (\\rho \\mathbf{u})}{\\partial t} + \\nabla\\cdot\\left(\\rho \\mathbf{u} \\otimes \\mathbf{u} + p\\mathbf{I}\\right) = \\nabla\\cdot \\boldsymbol{\\tau} + \\mathbf{f}_{\\mathbf{m}},\n$$\n$$\n\\frac{\\partial (\\rho E)}{\\partial t} + \\nabla\\cdot\\left[(\\rho E + p)\\mathbf{u}\\right] = \\nabla\\cdot(\\boldsymbol{\\tau}\\cdot \\mathbf{u}) - \\nabla\\cdot \\mathbf{q} + f_E,\n$$\nwith heat flux $\\mathbf{q} = -k\\nabla T$, $f_\\rho$ the mass source term, $\\mathbf{f}_{\\mathbf{m}}$ the momentum source term (units of Newton per cubic meter), and $f_E$ the energy source term (units of Watt per cubic meter). Your task is to compute $f_\\rho$, the components of $\\mathbf{f}_{\\mathbf{m}}$, and $f_E$ that make the specified fields exact solutions of the above equations.\n\nImplementation requirements:\n- You must compute the required spatial and temporal derivatives analytically from the specified fields, apply the conservation laws and constitutive relations exactly as written, and assemble the forcing terms so that each equation is satisfied pointwise.\n- All quantities must be computed in International System of Units (SI): density in kilogram per cubic meter, velocity in meter per second, temperature in kelvin, pressure in pascal, viscosity in pascal·second, thermal conductivity in watt per meter-kelvin, and time in second.\n- Express the final outputs as floating-point numbers. The mass source term $f_\\rho$ must be in $\\mathrm{kg/(m^3\\cdot s)}$, each momentum source term component must be in $\\mathrm{N/m^3}$, and the energy source term $f_E$ must be in $\\mathrm{W/m^3}$.\n\nTest suite:\nUse the following set of parameter values and evaluation points. For each case, compute and return the tuple $\\left[f_\\rho, f_{m,x}, f_{m,y}, f_E\\right]$.\n- Case $1$ (general interior, viscous): $\\gamma=1.4$, $R=287$, $\\rho_0=1.2$, $U_0=50$, $V_0=-20$, $T_0=300$, $\\mu=1.8\\times 10^{-5}$, $\\mathrm{Pr}=0.72$, $\\alpha=0.5$, $A=1$, evaluated at $(x,y,t)=(0.3,0.7,1.2)$.\n- Case $2$ (boundary point, initial time, viscous): same parameters as Case $1$, evaluated at $(x,y,t)=(0,0,0)$.\n- Case $3$ (Euler limit, inviscid and adiabatic): same thermodynamic parameters as Case $1$ but with $\\mu=0$ and $k=0$, i.e. set $\\mu=0$ and treat $\\mathrm{Pr}$ as irrelevant, evaluated at $(x,y,t)=(1,1,2)$.\n- Case $4$ (constant fields, zero amplitude): same viscous parameters as Case $1$ but with $A=0$, evaluated at $(x,y,t)=(0.4,0.6,3)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a comma-separated list. For example:\n$$\n\\text{[}[f_{\\rho,1},f_{m,x,1},f_{m,y,1},f_{E,1}], [f_{\\rho,2},f_{m,x,2},f_{m,y,2},f_{E,2}], [f_{\\rho,3},f_{m,x,3},f_{m,y,3},f_{E,3}], [f_{\\rho,4},f_{m,x,4},f_{m,y,4},f_{E,4}]\\text{]}\n$$\nEnsure your program prints exactly one line in this format, with numeric values for each entry.",
            "solution": "The user has provided a valid problem statement. The task is to derive and compute the source terms for the 2D compressible Navier–Stokes equations that would make a given set of analytic functions for density, velocity, and temperature an exact solution. This procedure is known as the Method of Manufactured Solutions (MMS), a cornerstone technique for the verification of numerical solvers.\n\nThe governing equations in conservative form with source terms $f_\\rho$, $\\mathbf{f}_{\\mathbf{m}}$, and $f_E$ are provided as:\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla\\cdot(\\rho \\mathbf{u}) = f_\\rho\n$$\n$$\n\\frac{\\partial (\\rho \\mathbf{u})}{\\partial t} + \\nabla\\cdot\\left(\\rho \\mathbf{u} \\otimes \\mathbf{u} + p\\mathbf{I}\\right) = \\nabla\\cdot \\boldsymbol{\\tau} + \\mathbf{f}_{\\mathbf{m}}\n$$\n$$\n\\frac{\\partial (\\rho E)}{\\partial t} + \\nabla\\cdot\\left[(\\rho E + p)\\mathbf{u}\\right] = \\nabla\\cdot(\\boldsymbol{\\tau}\\cdot \\mathbf{u}) - \\nabla\\cdot \\mathbf{q} + f_E\n$$\nTo find the source terms, we rearrange these equations:\n$$\nf_\\rho = \\frac{\\partial \\rho}{\\partial t} + \\nabla\\cdot(\\rho \\mathbf{u})\n$$\n$$\n\\mathbf{f}_{\\mathbf{m}} = \\frac{\\partial (\\rho \\mathbf{u})}{\\partial t} + \\nabla\\cdot\\left(\\rho \\mathbf{u} \\otimes \\mathbf{u} + p\\mathbf{I}\\right) - \\nabla\\cdot \\boldsymbol{\\tau}\n$$\n$$\nf_E = \\frac{\\partial (\\rho E)}{\\partial t} + \\nabla\\cdot\\left[(\\rho E + p)\\mathbf{u}\\right] - \\nabla\\cdot(\\boldsymbol{\\tau}\\cdot \\mathbf{u}) + \\nabla\\cdot \\mathbf{q}\n$$\nThe solution requires computing every term on the right-hand side of these equations analytically by differentiating the manufactured solution fields and substituting them into the expressions for the fluxes and other derived quantities.\n\nThe manufactured fields are given as:\n$$\n\\rho(x,y,t) = \\rho_0\\left[1 + 0.1 A \\sin(\\pi x)\\cos(\\pi y) e^{-\\alpha t}\\right]\n$$\n$$\nu(x,y,t) = U_0 + 0.2 A \\cos(\\pi x)\\sin(\\pi y) e^{-\\alpha t}\n$$\n$$\nv(x,y,t) = V_0 + 0.15 A \\sin(2\\pi x)\\sin(\\pi y) e^{-\\alpha t}\n$$\n$$\nT(x,y,t) = T_0\\left[1 + 0.03 A \\cos(\\pi x)\\cos(2\\pi y) e^{-\\alpha t}\\right]\n$$\nFrom these, we derive all necessary first and second partial derivatives with respect to space ($x, y$) and time ($t$). For example, the partial derivative of density with respect to time is:\n$$\n\\frac{\\partial \\rho}{\\partial t} = \\rho_0 \\left[ 0.1 A \\sin(\\pi x)\\cos(\\pi y) \\cdot (-\\alpha e^{-\\alpha t}) \\right] = -0.1 \\alpha A \\rho_0 \\sin(\\pi x)\\cos(\\pi y) e^{-\\alpha t}\n$$\nAnd the partial derivative of density with respect to $x$:\n$$\n\\frac{\\partial \\rho}{\\partial x} = \\rho_0 \\left[ 0.1 A \\cdot \\pi\\cos(\\pi x)\\cos(\\pi y) e^{-\\alpha t} \\right] = 0.1 \\pi A \\rho_0 \\cos(\\pi x)\\cos(\\pi y) e^{-\\alpha t}\n$$\nSimilar expressions are derived for all other first and second derivatives of $\\rho$, $u$, $v$, and $T$.\n\nThe calculation of the source terms proceeds as follows:\n\n**1. Mass Source Term ($f_\\rho$)**\nThe mass source term is the residual of the continuity equation:\n$$\nf_\\rho = \\underbrace{\\frac{\\partial \\rho}{\\partial t}}_{\\text{Time derivative}} + \\underbrace{\\frac{\\partial(\\rho u)}{\\partial x} + \\frac{\\partial(\\rho v)}{\\partial y}}_{\\text{Divergence of mass flux}}\n$$\nExpanding the divergence term using the product rule, $f_\\rho = \\frac{\\partial \\rho}{\\partial t} + u\\frac{\\partial \\rho}{\\partial x} + \\rho\\frac{\\partial u}{\\partial x} + v\\frac{\\partial \\rho}{\\partial y} + \\rho\\frac{\\partial v}{\\partial y}$. Each term is computed using the analytical derivatives.\n\n**2. Momentum Source Term ($\\mathbf{f}_{\\mathbf{m}} = [f_{m,x}, f_{m,y}]^\\top$)**\nThe momentum source term is the residual of the momentum equation. For the $x$-component:\n$$\nf_{m,x} = \\frac{\\partial (\\rho u)}{\\partial t} + \\frac{\\partial (\\rho u^2 + p)}{\\partial x} + \\frac{\\partial (\\rho u v)}{\\partial y} - (\\nabla\\cdot \\boldsymbol{\\tau})_x\n$$\nThis involves several components:\n-   **Time derivative**: $\\frac{\\partial (\\rho u)}{\\partial t} = u \\frac{\\partial \\rho}{\\partial t} + \\rho \\frac{\\partial u}{\\partial t}$.\n-   **Convective and pressure terms**: $\\frac{\\partial (\\rho u^2)}{\\partial x} + \\frac{\\partial p}{\\partial x}$ and $\\frac{\\partial (\\rho u v)}{\\partial y}$. The pressure $p = \\rho R T$ and its derivatives are computed first, e.g., $\\frac{\\partial p}{\\partial x} = R(T\\frac{\\partial \\rho}{\\partial x} + \\rho\\frac{\\partial T}{\\partial x})$.\n-   **Viscous term**: The divergence of the viscous stress tensor, $(\\nabla\\cdot \\boldsymbol{\\tau})_x$. For a Newtonian fluid with constant viscosity $\\mu$, this is:\n    $$\n    (\\nabla\\cdot \\boldsymbol{\\tau})_x = \\mu \\left( \\frac{4}{3}\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} + \\frac{1}{3}\\frac{\\partial^2 v}{\\partial x \\partial y} \\right)\n    $$\n    This requires the second spatial derivatives of the velocity components.\nThe $y$-component, $f_{m,y}$, is derived analogously.\n\n**3. Energy Source Term ($f_E$)**\nThe energy source term is the residual of the total energy equation:\n$$\nf_E = \\frac{\\partial (\\rho E)}{\\partial t} + \\nabla\\cdot\\left[(\\rho E + p)\\mathbf{u}\\right] - \\nabla\\cdot(\\boldsymbol{\\tau}\\cdot \\mathbf{u}) + \\nabla\\cdot \\mathbf{q}\n$$\nThe calculation involves:\n-   **Total energy**: $E = c_v T + \\frac{1}{2}(u^2+v^2)$, with $c_v = R/(\\gamma - 1)$.\n-   **Time derivative**: $\\frac{\\partial (\\rho E)}{\\partial t}$, expanded using the product rule.\n-   **Convective term**: $\\nabla\\cdot\\left[(\\rho E + p)\\mathbf{u}\\right]$, the divergence of the total enthalpy flux.\n-   **Viscous work term**: $\\nabla\\cdot(\\boldsymbol{\\tau}\\cdot \\mathbf{u})$. This can be expanded into two parts: work done by surface traction, $(\\nabla\\cdot\\boldsymbol{\\tau})\\cdot\\mathbf{u}$, and irreversible viscous dissipation, $\\boldsymbol{\\tau}:\\nabla\\mathbf{u}$.\n-   **Heat flux term**: $\\nabla\\cdot\\mathbf{q}$. For Fourier's law with constant conductivity $k$, $\\mathbf{q} = -k\\nabla T$, this becomes $\\nabla\\cdot\\mathbf{q} = -k \\nabla^2 T = -k(\\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2})$. The thermal conductivity is given by $k = \\mu c_p / \\mathrm{Pr}$, where $c_p = \\gamma c_v$.\n\nFor each test case, the specified parameters ($\\gamma, R, \\rho_0$, etc.) and evaluation point $(x,y,t)$ are used to compute the numerical values of all derivatives and intermediate quantities, which are then assembled to yield the final source term vector $[f_\\rho, f_{m,x}, f_{m,y}, f_E]$. Special cases, such as the inviscid limit ($\\mu=0$, which implies $k=0$) and the constant field case ($A=0$), are handled by the same formulation, which naturally simplifies as terms become zero.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_sources(gamma, R, rho_0, U_0, V_0, T_0, mu, Pr, alpha, A, x, y, t):\n    \"\"\"\n    Computes the source terms for the compressible Navier-Stokes equations\n    for a given manufactured solution.\n    \"\"\"\n    # 0. Constants and trigonometric/exponential factors\n    pi = np.pi\n    c_v = R / (gamma - 1.0)\n    c_p = gamma * c_v\n    \n    if mu == 0:\n        k = 0.0\n    else:\n        k = mu * c_p / Pr\n        \n    exp_at = np.exp(-alpha * t)\n\n    s_px = np.sin(pi * x)\n    c_px = np.cos(pi * x)\n    s_py = np.sin(pi * y)\n    c_py = np.cos(pi * y)\n    s_2px = np.sin(2 * pi * x)\n    c_2px = np.cos(2 * pi * x)\n    s_2py = np.sin(2 * pi * y)\n    c_2py = np.cos(2 * pi * y)\n\n    # 1. Primitive variables and their derivatives\n    # rho\n    rho = rho_0 * (1 + 0.1 * A * s_px * c_py * exp_at)\n    d_rho_dt = rho_0 * 0.1 * A * s_px * c_py * (-alpha * exp_at)\n    d_rho_dx = rho_0 * 0.1 * A * (pi * c_px) * c_py * exp_at\n    d_rho_dy = rho_0 * 0.1 * A * s_px * (-pi * s_py) * exp_at\n\n    # u\n    u = U_0 + 0.2 * A * c_px * s_py * exp_at\n    d_u_dt = 0.2 * A * c_px * s_py * (-alpha * exp_at)\n    d_u_dx = 0.2 * A * (-pi * s_px) * s_py * exp_at\n    d_u_dy = 0.2 * A * c_px * (pi * c_py) * exp_at\n    d2_u_dx2 = 0.2 * A * (-pi**2 * c_px) * s_py * exp_at\n    d2_u_dy2 = 0.2 * A * c_px * (-pi**2 * s_py) * exp_at\n    d2_u_dxdy = 0.2 * A * (-pi * s_px) * (pi * c_py) * exp_at\n\n    # v\n    v = V_0 + 0.15 * A * s_2px * s_py * exp_at\n    d_v_dt = 0.15 * A * s_2px * s_py * (-alpha * exp_at)\n    d_v_dx = 0.15 * A * (2 * pi * c_2px) * s_py * exp_at\n    d_v_dy = 0.15 * A * s_2px * (pi * c_py) * exp_at\n    d2_v_dx2 = 0.15 * A * (-4 * pi**2 * s_2px) * s_py * exp_at\n    d2_v_dy2 = 0.15 * A * s_2px * (-pi**2 * s_py) * exp_at\n    d2_v_dxdy = 0.15 * A * (2 * pi * c_2px) * (pi * c_py) * exp_at\n\n    # T\n    T = T_0 * (1 + 0.03 * A * c_px * c_2py * exp_at)\n    d_T_dt = T_0 * 0.03 * A * c_px * c_2py * (-alpha * exp_at)\n    d_T_dx = T_0 * 0.03 * A * (-pi * s_px) * c_2py * exp_at\n    d_T_dy = T_0 * 0.03 * A * c_px * (-2 * pi * s_2py) * exp_at\n    d2_T_dx2 = T_0 * 0.03 * A * (-pi**2 * c_px) * c_2py * exp_at\n    d2_T_dy2 = T_0 * 0.03 * A * c_px * (-4 * pi**2 * c_2py) * exp_at\n\n    # 2. Intermediate quantities\n    p = rho * R * T\n    d_p_dx = R * (d_rho_dx * T + rho * d_T_dx)\n    d_p_dy = R * (d_rho_dy * T + rho * d_T_dy)\n    \n    E = c_v * T + 0.5 * (u**2 + v**2)\n\n    div_u = d_u_dx + d_v_dy\n    tau_xx = mu * (2 * d_u_dx - 2/3 * div_u)\n    tau_yy = mu * (2 * d_v_dy - 2/3 * div_u)\n    tau_xy = mu * (d_u_dy + d_v_dx)\n    \n    # 3. Compute source terms\n    # 3.1 Mass source f_rho\n    f_rho = d_rho_dt + (d_rho_dx * u + rho * d_u_dx) + (d_rho_dy * v + rho * d_v_dy)\n\n    # 3.2 Momentum source f_m\n    div_tau_x = mu * ((4/3) * d2_u_dx2 + d2_u_dy2 + (1/3) * d2_v_dxdy)\n    div_tau_y = mu * ((4/3) * d2_v_dy2 + d2_v_dx2 + (1/3) * d2_u_dxdy)\n\n    f_mx_t = d_rho_dt * u + rho * d_u_dt\n    f_mx_conv = (u * u * d_rho_dx + 2 * rho * u * d_u_dx) + (u * v * d_rho_dy + rho * v * d_u_dy + rho * u * d_v_dy)\n    f_mx = f_mx_t + f_mx_conv + d_p_dx - div_tau_x\n    \n    f_my_t = d_rho_dt * v + rho * d_v_dt\n    f_my_conv = (u * v * d_rho_dx + rho * v * d_u_dx + rho * u * d_v_dx) + (v * v * d_rho_dy + 2 * rho * v * d_v_dy)\n    f_my = f_my_t + f_my_conv + d_p_dy - div_tau_y\n\n    # 3.3 Energy source f_E\n    # Time derivative term d(rho*E)/dt\n    dE_dt = c_v * d_T_dt + u * d_u_dt + v * d_v_dt\n    d_rhoE_dt = E * d_rho_dt + rho * dE_dt\n\n    # Convective term div((rho*E+p)*u)\n    dE_dx = c_v * d_T_dx + u * d_u_dx + v * d_v_dx\n    d_rhoE_dx = E * d_rho_dx + rho * dE_dx\n    conv_E_x = (rho * E + p) * d_u_dx + u * (d_rhoE_dx + d_p_dx)\n\n    dE_dy = c_v * d_T_dy + u * d_u_dy + v * d_v_dy\n    d_rhoE_dy = E * d_rho_dy + rho * dE_dy\n    conv_E_y = (rho * E + p) * d_v_dy + v * (d_rhoE_dy + d_p_dy)\n    div_conv_E = conv_E_x + conv_E_y\n\n    # Viscous work term div(tau . u)\n    viscous_dissipation = tau_xx * d_u_dx + tau_yy * d_v_dy + tau_xy * (d_u_dy + d_v_dx)\n    div_tau_dot_u = u * div_tau_x + v * div_tau_y + viscous_dissipation\n\n    # Heat flux term div(q)\n    laplacian_T = d2_T_dx2 + d2_T_dy2\n    div_q = -k * laplacian_T\n\n    f_E = d_rhoE_dt + div_conv_E - div_tau_dot_u + div_q\n\n    return [f_rho, f_mx, f_my, f_E]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: general interior, viscous\n        {'gamma': 1.4, 'R': 287, 'rho_0': 1.2, 'U_0': 50, 'V_0': -20, 'T_0': 300, \n         'mu': 1.8e-5, 'Pr': 0.72, 'alpha': 0.5, 'A': 1, \n         'x': 0.3, 'y': 0.7, 't': 1.2},\n        # Case 2: boundary point, initial time, viscous\n        {'gamma': 1.4, 'R': 287, 'rho_0': 1.2, 'U_0': 50, 'V_0': -20, 'T_0': 300, \n         'mu': 1.8e-5, 'Pr': 0.72, 'alpha': 0.5, 'A': 1, \n         'x': 0, 'y': 0, 't': 0},\n        # Case 3: Euler limit, inviscid and adiabatic\n        {'gamma': 1.4, 'R': 287, 'rho_0': 1.2, 'U_0': 50, 'V_0': -20, 'T_0': 300, \n         'mu': 0.0, 'Pr': 0.72, 'alpha': 0.5, 'A': 1, \n         'x': 1, 'y': 1, 't': 2.0},\n        # Case 4: constant fields, zero amplitude\n        {'gamma': 1.4, 'R': 287, 'rho_0': 1.2, 'U_0': 50, 'V_0': -20, 'T_0': 300, \n         'mu': 1.8e-5, 'Pr': 0.72, 'alpha': 0.5, 'A': 0, \n         'x': 0.4, 'y': 0.6, 't': 3.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        f_rho, f_mx, f_my, f_E = compute_sources(**case)\n        # Format each result set as a string \"[v1,v2,v3,v4]\"\n        result_str = f\"[{f_rho},{f_mx},{f_my},{f_E}]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}