{
    "hands_on_practices": [
        {
            "introduction": "在深入探讨两种布局的复杂差异之前，建立一个共同的理论基础至关重要。本练习旨在引导您理解，在何种理想条件下，单元中心和顶点中心方法会得出完全相同的离散格式。通过在标准正交网格上为基本的扩散算子推导这种等价性 ()，您将揭示有限体积法和有限差分法视角之间深层的数学联系，为后续更复杂的分析奠定坚实基础。",
            "id": "3947053",
            "problem": "考虑一个在航空航天计算流体动力学（CFD）中常用的二维标量扩散模型：作用于光滑标量场 $u(x,y)$ 上的常系数椭圆算子，\n$$\\mathcal{L}u = \\nabla \\cdot \\left(\\kappa \\nabla u\\right),$$\n其中 $\\kappa$ 是一个正常数，$(x,y)$ 位于一个矩形计算域内。设该域由间距相等的正交均匀笛卡尔网格离散化，$\\Delta x = \\Delta y = h$，并考虑两种离散格式：\n\n- 一种单元中心格式，在矩形控制体上使用算子的积分（有限体积）形式，其面法向通量通过对最高为1次的多项式精确的线性重构进行近似，并使用每个面上的中点求积进行计算。\n- 一种节点中心格式，在网格节点处使用算子的逐点有限差分近似，采用中心差分，并由与坐标方向对齐的均匀模板构造而成。\n\n从散度定理和关于一般网格位置的泰勒展开出发，且不引入任何额外的修正项，推导使这两种格式产生的离散算子在该网格上变得相同的网格几何条件和重构规则。然后，在这些条件下，将离散拉普拉斯算子在网格位置 $(x,y)$ 处的主截断误差定义为局部展开式中的系数 $C$：\n$$\\mathcal{L}_h u(x,y) - \\mathcal{L}u(x,y) = C\\,h^{2}\\left(u_{xxxx}(x,y) + u_{yyyy}(x,y)\\right) + \\mathcal{O}\\!\\left(h^{4}\\right),$$\n其中 $\\mathcal{L}_h$ 表示离散算子，$u_{xxxx}$ 和 $u_{yyyy}$ 是 $u$ 的四阶偏导数。计算两种格式的主截断误差常数之差，\n$$C_{\\mathrm{cc}} - C_{\\mathrm{vc}},$$\n其中 $C_{\\mathrm{cc}}$ 对应于单元中心算子，$C_{\\mathrm{vc}}$ 对应于节点中心算子，并将最终答案以单个实数形式给出。无需四舍五入。",
            "solution": "该问题要求对均匀笛卡尔网格上扩散算子 $\\mathcal{L}u = \\nabla \\cdot (\\kappa \\nabla u)$ 的两种常见离散格式进行比较分析。\n\n设网格节点由 $(i,j)$ 索引，对应物理坐标 $(x_i, y_j) = (i h, j h)$。设 $u_{i,j}$ 表示标量场 $u$ 在此位置的值，即 $u_{i,j} = u(x_i, y_j)$。\n\n**1. 节点中心（VC）离散算子的推导**\n\n在节点中心格式中，离散值 $u_{i,j}$ 与网格节点相关联。算子 $\\mathcal{L}_h^{\\mathrm{vc}}$ 是在节点 $(i,j)$ 处对 $\\mathcal{L}u = \\kappa (\\partial^2u/\\partial x^2 + \\partial^2u/\\partial y^2)$ 的逐点近似。使用标准的二阶中心差分公式来计算二阶偏导数：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(i,j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(i,j)} \\approx \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2}\n$$\n将这些代入 $\\mathcal{L}u$ 的表达式，得到离散的节点中心算子：\n$$\n\\mathcal{L}_h^{\\mathrm{vc}} u_{i,j} = \\kappa \\left( \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} \\right)\n$$\n$$\n\\mathcal{L}_h^{\\mathrm{vc}} u_{i,j} = \\frac{\\kappa}{h^2} \\left( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} \\right)\n$$\n这就是著名的拉普拉斯算子五点模板。\n\n**2. 单元中心（CC）离散算子的推导**\n\n在单元中心（有限体积）格式中，值 $u_{i,j}$ 与控制体 $V_{i,j}$ 的中心相关联。对于此网格，控制体是一个边长为 $h$、中心在 $(x_i, y_j)$ 的正方形，定义为 $V_{i,j} = [x_i - h/2, x_i + h/2] \\times [y_j - h/2, y_j + h/2]$。控制体的面积为 $A = h^2$。\n\n有限体积法近似了 $\\mathcal{L}u$ 在单元上的平均值：\n$$\n\\frac{1}{A} \\int_{V_{i,j}} \\mathcal{L}u \\, dA = \\frac{1}{h^2} \\int_{V_{i,j}} \\nabla \\cdot (\\kappa \\nabla u) \\, dA\n$$\n应用散度定理，将体积分转换为控制体各面 $\\partial V_{i,j}$ 上的边值积分：\n$$\n\\frac{1}{h^2} \\oint_{\\partial V_{i,j}} (\\kappa \\nabla u) \\cdot \\mathbf{n} \\, ds\n$$\n其中 $\\mathbf{n}$ 是向外的单位法向量。该积分是流经四个面（东($e$)、西($w$)、北($n$)和南($s$)）的通量之和。\n$$\n\\mathcal{L}_h^{\\mathrm{cc}} u_{i,j} = \\frac{1}{h^2} \\left( F_e - F_w + F_n - F_s \\right)\n$$\n通量由 $F = \\int_{\\text{face}} \\kappa \\nabla u \\cdot \\mathbf{n} \\, ds$ 给出。问题指定使用中点求积，因此通过一个面的通量是该面的长度乘以在面中点处计算的被积函数的值。\n\n- **东面 ($e$)：** 中心在 $(x_{i+1/2}, y_j)$，法向量 $\\mathbf{n}=(1,0)$，长度 $h$。通量 $F_e \\approx h \\left(\\kappa \\frac{\\partial u}{\\partial x}\\right)\\big|_{i+1/2,j}$。\n- **西面 ($w$)：** 中心在 $(x_{i-1/2}, y_j)$，法向量 $\\mathbf{n}=(-1,0)$，长度 $h$。向外通量为 $h \\left(\\kappa \\frac{\\partial u}{\\partial x}\\right)\\big|_{i-1/2,j}$。\n- **北面 ($n$)：** 中心在 $(x_i, y_{j+1/2})$，法向量 $\\mathbf{n}=(0,1)$，长度 $h$。通量 $F_n \\approx h \\left(\\kappa \\frac{\\partial u}{\\partial y}\\right)\\big|_{i,j+1/2}$。\n- **南面 ($s$)：** 中心在 $(x_i, y_{j-1/2})$，法向量 $\\mathbf{n}=(0,-1)$，长度 $h$。向外通量为 $h \\left(\\kappa \\frac{\\partial u}{\\partial y}\\right)\\big|_{i,j-1/2}$。\n\n问题陈述梯度由对1次多项式精确的线性重构近似。对于均匀网格，这对应于在面中心使用中心差分，该差分使用相邻的单元中心值：\n$$\n\\frac{\\partial u}{\\partial x}\\bigg|_{i+1/2,j} \\approx \\frac{u_{i+1,j} - u_{i,j}}{h} \\quad , \\quad \\frac{\\partial u}{\\partial x}\\bigg|_{i-1/2,j} \\approx \\frac{u_{i,j} - u_{i-1,j}}{h}\n$$\n$$\n\\frac{\\partial u}{\\partial y}\\bigg|_{i,j+1/2} \\approx \\frac{u_{i,j+1} - u_{i,j}}{h} \\quad , \\quad \\frac{\\partial u}{\\partial y}\\bigg|_{i,j-1/2} \\approx \\frac{u_{i,j} - u_{i,j-1}}{h}\n$$\n将这些代入通量表达式中：\n$$\nF_e \\approx \\kappa h \\frac{u_{i+1,j} - u_{i,j}}{h} = \\kappa(u_{i+1,j} - u_{i,j})\n$$\n$$\nF_w \\approx \\kappa h \\frac{u_{i,j} - u_{i-1,j}}{h} = \\kappa(u_{i,j} - u_{i-1,j})\n$$\n$$\nF_n \\approx \\kappa h \\frac{u_{i,j+1} - u_{i,j}}{h} = \\kappa(u_{i,j+1} - u_{i,j})\n$$\n$$\nF_s \\approx \\kappa h \\frac{u_{i,j} - u_{i,j-1}}{h} = \\kappa(u_{i,j} - u_{i,j-1})\n$$\n那么总和为：\n$$\n\\mathcal{L}_h^{\\mathrm{cc}} u_{i,j} = \\frac{1}{h^2} \\left[ \\kappa(u_{i+1,j} - u_{i,j}) - \\kappa(u_{i,j} - u_{i-1,j}) + \\kappa(u_{i,j+1} - u_{i,j}) - \\kappa(u_{i,j} - u_{i,j-1}) \\right]\n$$\n简化此表达式可得：\n$$\n\\mathcal{L}_h^{\\mathrm{cc}} u_{i,j} = \\frac{\\kappa}{h^2} \\left( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} \\right)\n$$\n\n**3. 算子相同的条件**\n\n比较第1部分和第2部分的结果，我们发现 $\\mathcal{L}_h^{\\mathrm{vc}} u_{i,j} = \\mathcal{L}_h^{\\mathrm{cc}} u_{i,j}$。这两个离散算子是相同的。此同一性的条件恰好是问题陈述中指定的条件：\n- 网格必须是均匀、正交的笛卡尔网格。\n- 有限差分格式必须使用标准的二阶中心差分。\n- 有限体积格式必须使用中点求积计算通量，并使用基于两个相邻单元中心值的中心差分来近似面法向梯度。\n\n**4. 截断误差分析**\n\n由于 $\\mathcal{L}_h^{\\mathrm{cc}} = \\mathcal{L}_h^{\\mathrm{vc}}$，我们可以将公共的离散算子表示为 $\\mathcal{L}_h$。问题要求的是局部截断误差，定义为 $\\tau = \\mathcal{L}_h u(x,y) - \\mathcal{L}u(x,y)$。我们使用 $u$ 在点 $(x_i, y_j)$ 附近的泰勒级数展开。令 $u_{xxxx} = \\partial^4 u / \\partial x^4$ 且 $u_{yyyy} = \\partial^4 u / \\partial y^4$。\n\n$u(x_i \\pm h, y_j) = u_{i,j} \\pm h \\frac{\\partial u}{\\partial x} + \\frac{h^2}{2} \\frac{\\partial^2 u}{\\partial x^2} \\pm \\frac{h^3}{6} \\frac{\\partial^3 u}{\\partial x^3} + \\frac{h^4}{24} \\frac{\\partial^4 u}{\\partial x^4} + \\mathcal{O}(h^5)$\n$u(x_i, y_j \\pm h) = u_{i,j} \\pm h \\frac{\\partial u}{\\partial y} + \\frac{h^2}{2} \\frac{\\partial^2 u}{\\partial y^2} \\pm \\frac{h^3}{6} \\frac{\\partial^3 u}{\\partial y^3} + \\frac{h^4}{24} \\frac{\\partial^4 u}{\\partial y^4} + \\mathcal{O}(h^5)$\n\n对模板的各项求和：\n$u_{i+1,j} + u_{i-1,j} = 2u_{i,j} + h^2 \\frac{\\partial^2 u}{\\partial x^2} + \\frac{h^4}{12} \\frac{\\partial^4 u}{\\partial x^4} + \\mathcal{O}(h^6)$\n$u_{i,j+1} + u_{i,j-1} = 2u_{i,j} + h^2 \\frac{\\partial^2 u}{\\partial y^2} + \\frac{h^4}{12} \\frac{\\partial^4 u}{\\partial y^4} + \\mathcal{O}(h^6)$\n\n现在将这些代入 $\\mathcal{L}_h u_{i,j}$ 的表达式中：\n$$\n\\mathcal{L}_h u_{i,j} = \\frac{\\kappa}{h^2} \\left[ \\left(2u_{i,j} + h^2 u_{xx} + \\frac{h^4}{12} u_{xxxx}\\right) + \\left(2u_{i,j} + h^2 u_{yy} + \\frac{h^4}{12} u_{yyyy}\\right) - 4u_{i,j} + \\mathcal{O}(h^6) \\right]\n$$\n$$\n\\mathcal{L}_h u_{i,j} = \\frac{\\kappa}{h^2} \\left[ h^2 (u_{xx} + u_{yy}) + \\frac{h^4}{12} (u_{xxxx} + u_{yyyy}) + \\mathcal{O}(h^6) \\right]\n$$\n$$\n\\mathcal{L}_h u_{i,j} = \\kappa (u_{xx} + u_{yy}) + \\frac{\\kappa h^2}{12} (u_{xxxx} + u_{yyyy}) + \\mathcal{O}(h^4)\n$$\n连续算子是 $\\mathcal{L}u = \\kappa(u_{xx} + u_{yy})$。因此，局部截断误差为：\n$$\n\\tau = \\mathcal{L}_h u_{i,j} - \\mathcal{L}u_{i,j} = \\frac{\\kappa h^2}{12} (u_{xxxx} + u_{yyyy}) + \\mathcal{O}(h^4)\n$$\n问题给出的主截断误差形式为 $C h^2 (u_{xxxx} + u_{yyyy})$。通过比较这两个表达式，我们可以确定常数 $C$：\n$$\nC = \\frac{\\kappa}{12}\n$$\n\n**5. 最终计算**\n\n此截断误差的推导基于离散算子 $\\mathcal{L}_h$ 的代数形式。由于我们已经证明 $\\mathcal{L}_h^{\\mathrm{cc}} = \\mathcal{L}_h^{\\mathrm{vc}} = \\mathcal{L}_h$，因此两种格式的主截断误差常数必须相同。\n$$\nC_{\\mathrm{cc}} = \\frac{\\kappa}{12}\n$$\n$$\nC_{\\mathrm{vc}} = \\frac{\\kappa}{12}\n$$\n所求的差值为：\n$$\nC_{\\mathrm{cc}} - C_{\\mathrm{vc}} = \\frac{\\kappa}{12} - \\frac{\\kappa}{12} = 0\n$$",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "当从理想的正交网格过渡到航空航天应用中常见的倾斜或非结构网格时，一个至关重要的数值原则——几何守恒律 (Geometric Conservation Law, GCL) ——便凸显出来。本练习将带您从理论推导转向计算实践，要求您设计一个数值实验来验证欧拉方程的自由流保持特性 ()。通过对比“一致”与“不一致”的通量计算方法在倾斜网格上的表现，本练习将生动地揭示为何精确满足GCL对于一个可靠的CFD格式是不可或缺的。",
            "id": "3947046",
            "problem": "考虑守恒形式的二维可压缩欧拉方程，其写为在控制体上守恒变量与对流通量的积分平衡。从积分守恒律和 Gauss 散度定理出发，其连续形式的表述为：对于任何带有边界的控制体，通过边界的守恒量净通量等于控制体内部守恒量的时间变化率。在有限体积离散化中，一个控制体的离散残差是其所有面上的投影通量之和。自由流保持要求均匀状态在任何网格上都产生零离散残差。离散几何守恒律指出，一个封闭控制体的所有面面积向量之和必须为零，并且在重构和通量投影中使用的几何度量必须一致。\n\n您必须设计并实现一个计算测试，以在扭曲网格上验证单元中心和节点中心两种配置的自由流保持特性，并指明在这两种配置下，重构和通量投影之间必须保持一致的离散操作。\n\n使用的基本原理：\n- 守恒律的积分形式和 Gauss 散度定理：一个常数状态在任何封闭控制体上应产生零净通量，即，如果几何离散化是一致的，离散残差必须恒为零。\n- 离散几何守恒律：任何封闭控制体的面面积向量的向量和必须为零。\n- 有限体积离散残差由面法向投影通量之和构成。\n\n采用的定义：\n- 单元中心配置将状态存储在单元中心，并使用从顶点坐标导出的面面积向量计算面通量之和作为离散残差。\n- 节点中心配置将状态存储在网格顶点，并使用围绕顶点的对偶控制体。该对偶控制体是由连接到该顶点的边的中点构成的多边形（一种常见的中线对偶）。离散残差是通过对偶多边形边的通量之和。\n\n通量模型：\n- 使用无粘二维欧拉通量。对于一个均匀自由流，其密度为 $\\,\\rho\\,$，速度为 $\\,u\\,$ 和 $\\,v\\,$，压力为 $\\,p\\,$，比热比为 $\\,\\gamma\\,$，定义比内能 $\\,e = \\dfrac{p}{(\\gamma - 1)\\rho}\\,$，总比能 $\\,E = e + \\dfrac{1}{2}(u^2 + v^2)\\,$，$x$ 方向通量向量 $\\,\\mathbf{F}\\,$ 和 $y$ 方向通量向量 $\\,\\mathbf{G}\\,$ 如下\n$$\n\\mathbf{F} = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\n\\rho u v \\\\\n(\\rho E + p) u\n\\end{bmatrix}, \\quad\n\\mathbf{G} = \\begin{bmatrix}\n\\rho v \\\\\n\\rho u v \\\\\n\\rho v^2 + p \\\\\n(\\rho E + p) v\n\\end{bmatrix}.\n$$\n对于一个面积向量为 $\\,\\mathbf{s}_f = (s_{x,f}, s_{y,f})\\,$ 的面，离散通量贡献为 $\\,\\mathbf{F}\\, s_{x,f} + \\mathbf{G}\\, s_{y,f}\\,$。对于一个单位法向量为 $\\,\\hat{\\mathbf{n}}_f = (n_{x,f}, n_{y,f})\\,$ 的面，不带长度缩放的投影通量为 $\\,\\mathbf{F}\\, n_{x,f} + \\mathbf{G}\\, n_{y,f}\\,$。\n\n网格生成：\n- 构建一个 $\\,3 \\times 3\\,$ 顶点和 $\\,2 \\times 2\\,$ 四边形单元的结构化网格。顶点坐标由 $\\,x(i,j) = i + s\\, j\\,$ 和 $\\,y(i,j) = j\\,$ 给出，其中整数索引 $\\,i \\in \\{0,1,2\\}\\,$ 和 $\\,j \\in \\{0,1,2\\}\\,$，$\\,s\\,$ 是扭曲因子。$\\,s = 0\\,$ 产生正交网格；$\\,s > 0\\,$ 产生扭曲网格。\n- 每个单元由四个顶点按逆时针顺序定义：$\\,[(i,j), (i+1,j), (i+1,j+1), (i,j+1)]\\,$，其中 $\\,i \\in \\{0,1\\}\\,$ 且 $\\,j \\in \\{0,1\\}\\,$。面面积向量由连续顶点对 $\\,\\mathbf{e}_k = (x_{k+1}-x_k,\\; y_{k+1}-y_k)\\,$ 计算为 $\\,\\mathbf{s}_k = (e_{y,k},\\, -e_{x,k})\\,$，对于逆时针单元顶点顺序，该向量朝外。对于节点中心测试，使用内部顶点 $\\, (1,1)\\,$，并通过连接其四个入射边（分别连接到其正交邻居：左侧 $\\, (0,1)\\,$、右侧 $\\, (2,1)\\,$、底部 $\\, (1,0)\\,$ 和顶部 $\\, (1,2)\\,$）的中点来定义其对偶控制体多边形。围绕顶点按逆时针角度排列这些中点以形成多边形，并使用相同的面面积向量构造方法。\n\n要编码的离散操作和一致性要求：\n- 面面积向量和单位法向量必须从相同的顶点几何结构中以一致的方式导出。\n- 用于计算面积向量的面方向和顺序在重构和通量投影中必须相同，以便对于均匀状态，跨面的抵消是精确的。\n- 对于主控制体和对偶控制体，都必须遵守控制体封闭性（面积向量之和 $\\,\\sum_f \\mathbf{s}_f = \\mathbf{0}\\,$）。\n- 对于节点中心的对偶控制体，边中点位置和多边形顶点顺序在重构和通量投影中必须保持一致。\n\n您的程序必须：\n1. 实现均匀自由流，参数为 $\\,\\rho = 1.225\\,$、$\\,u = 200\\,$、$\\,v = 50\\,$、$\\,p = 101325\\,$ 和 $\\,\\gamma = 1.4\\,$。输出中不需要物理单位，因为最终度量是无量纲的。\n2. 为指定的扭曲因子 $\\,s\\,$ 构建网格，为单元中心和节点中心配置构建控制体，并通过对面贡献求和来计算每个控制体的离散残差向量。\n3. 对每个测试，计算一个无量纲残差比，定义为 $\\,r = \\dfrac{\\|\\mathbf{R}\\|_2}{\\sum_{\\text{faces}} \\|\\mathbf{F}\\, \\alpha_{x,f} + \\mathbf{G}\\, \\alpha_{y,f}\\|_2}\\,$，其中 $\\,\\mathbf{R}\\,$ 是被评估控制体的总残差向量，$\\,\\alpha_{x,f}, \\alpha_{y,f}\\,$ 在一致情况下为 $\\,s_{x,f}, s_{y,f}\\,$，在不一致情况下为 $\\,n_{x,f}, n_{y,f}\\,$，$\\,\\|\\cdot\\|_2\\,$ 表示欧几里得范数。该比率是无量纲的，当自由流被保持时，应接近 $\\,0\\,$。\n4. 评估以下测试套件参数集：\n   - 测试 $\\,1\\,$：单元中心，扭曲度 $\\,s = 0.3\\,$，通量投影中使用一致的面面积向量。\n   - 测试 $\\,2\\,$：单元中心，扭曲度 $\\,s = 0.3\\,$，使用不带长度缩放的单位法向量进行不一致的通量投影。\n   - 测试 $\\,3\\,$：节点中心（内部顶点对偶），扭曲度 $\\,s = 0.3\\,$，通量投影中使用一致的面积向量。\n   - 测试 $\\,4\\,$：节点中心（内部顶点对偶），扭曲度 $\\,s = 0.3\\,$，使用不带长度缩放的单位法向量进行不一致的通量投影。\n   - 测试 $\\,5\\,$：单元中心，正交网格 $\\,s = 0.0\\,$，使用不带长度缩放的单位法向量进行不一致的通量投影（对称性可能意外抵消的边界情况）。\n   - 测试 $\\,6\\,$：节点中心（内部顶点对偶），正交网格 $\\,s = 0.0\\,$，使用不带长度缩放的单位法向量进行不一致的通量投影。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含六个测试的残差比，以逗号分隔的列表形式包含在方括号中，例如 $\\, [r_1,r_2,r_3,r_4,r_5,r_6]\\,$。不得打印任何额外文本。",
            "solution": "该问题要求设计并实现一个计算验证测试，用于检验有限体积法在扭曲网格上对单元中心和节点中心两种格式的自由流保持性质。此性质对任何求解守恒律的数值方法的准确性都至关重要，因为它确保了一个平凡的均匀流场不会伪地产生守恒量的数值源或汇。\n\n该分析的基础是守恒律在具有边界 $\\partial V$ 的控制体 $V$ 上的积分形式：\n$$\n\\frac{d}{dt}\\int_V \\mathbf{U} dV + \\oint_{\\partial V} \\mathbf{F}_n dS = \\mathbf{0}\n$$\n这里，$\\mathbf{U}$ 是守恒变量的向量，$\\mathbf{F}_n$ 是 $\\mathbf{U}$ 垂直于边界的通量。对于二维欧拉方程，穿过单位法向量为 $\\hat{\\mathbf{n}} = (n_x, n_y)$ 的边界元的通量向量由 $\\mathbf{F} n_x + \\mathbf{G} n_y$ 给出，其中 $\\mathbf{F}$ 和 $\\mathbf{G}$ 分别是笛卡尔 $x$ 和 $y$ 方向的通量向量。\n\n对于稳态均匀自由流，状态向量 $\\mathbf{U}$ 在整个区域内是常数。因此，其时间导数为零，通量向量 $\\mathbf{F}(\\mathbf{U})$ 和 $\\mathbf{G}(\\mathbf{U})$ 也是常数。守恒律简化为要求从任何封闭控制体流出的净通量必须为零：\n$$\n\\oint_{\\partial V} (\\mathbf{F} n_x + \\mathbf{G} n_y) dS = \\mathbf{0}\n$$\n有限体积法通过对构成离散控制体边界的各个面 $f$ 上的通量求和来离散化此积分：\n$$\n\\mathbf{R} = \\sum_{f \\in \\partial V} (\\mathbf{F} n_{x,f} + \\mathbf{G} n_{y,f}) L_f\n$$\n其中 $\\mathbf{R}$ 是离散残差，$L_f$ 是面 $f$ 的长度，$(n_{x,f}, n_{y,f})$ 是其向外的单位法向量。\n\n一个关键概念是面面积向量 $\\mathbf{s}_f$，定义为 $\\mathbf{s}_f = (s_{x,f}, s_{y,f}) = (n_{x,f} L_f, n_{y,f} L_f)$。使用此定义，均匀状态的离散残差可以写为：\n$$\n\\mathbf{R} = \\sum_{f} (\\mathbf{F} s_{x,f} + \\mathbf{G} s_{y,f})\n$$\n由于自由流是均匀的，通量向量 $\\mathbf{F}$ 和 $\\mathbf{G}$ 是常数，可以从求和中提取出来：\n$$\n\\mathbf{R} = \\mathbf{F} \\left(\\sum_f s_{x,f}\\right) + \\mathbf{G} \\left(\\sum_f s_{y,f}\\right)\n$$\n对于任何封闭的多面体（在本例中为二维多边形），其向外面面积向量之和恒为零。这就是**离散几何守恒律 (GCL)**：\n$$\n\\sum_f \\mathbf{s}_f = \\sum_f \\begin{pmatrix} s_{x,f} \\\\ s_{y,f} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n如果离散几何满足 GCL，则直接推导出均匀自由流的离散残差 $\\mathbf{R}$ 恒为零。这就是自由流保持的本质。\n\n该问题要求测试两种通量计算情景：\n$1$. **一致格式**：通量投影使用面积向量 $\\mathbf{s}_f$。每个面的贡献是 $\\mathbf{F} s_{x,f} + \\mathbf{G} s_{y,f}$。如上所示，此格式遵循 GCL，将产生零残差（在机器精度范围内）。\n$2$. **不一致格式**：通量投影使用单位法向量 $\\hat{\\mathbf{n}}_f = (n_{x,f}, n_{y,f})$，而没有面长度缩放。面的贡献是 $\\mathbf{F} n_{x,f} + \\mathbf{G} n_{y,f}$。总残差变为：\n$$\n\\mathbf{R} = \\mathbf{F} \\left(\\sum_f n_{x,f}\\right) + \\mathbf{G} \\left(\\sum_f n_{y,f}\\right)\n$$\n该残差不保证为零。只有当面单位法向量的向量和 $\\sum_f \\hat{\\mathbf{n}}_f$ 为零时，它才为零。此条件仅对具有特殊对称性的控制体（例如正交网格上的矩形）成立，但对于一般的扭曲或不规则单元则不成立。几何封闭性要求（涉及面面积/长度）与通量计算（丢弃长度）之间的这种不一致性导致了自由流保持性质的丧失。\n\n因此，必须保持一致的离散操作是那些定义控制体几何形状和计算其边界通量的操作。具体来说：\n- 在**单元中心**配置中，控制体是主网格单元，一个由一组顶点定义的多边形。面面积向量 $\\mathbf{s}_f$ 从这些顶点坐标导出。为保持一致性，通量计算必须使用这些完全相同的面积向量 $\\mathbf{s}_f$。\n- 在**节点中心**配置中，控制体是一个对偶多边形，这里是通过连接到中心顶点的边的中点形成的。面面积向量 $\\mathbf{s}_f$ 从这些中点的坐标导出。一致性要求通量计算使用这些对偶面面积向量。\n\n实现将构建指定的网格和控制体。对于每个测试用例，它将以逆时针顺序定义控制多边形的顶点。然后，它遍历多边形的边，计算每个面的面积向量 $\\mathbf{s}_f$ 和单位法向量 $\\hat{\\mathbf{n}}_f$。根据测试的一致性要求，它使用 $\\mathbf{s}_f$ 或 $\\hat{\\mathbf{n}}_f$ 计算面通量贡献。将这些贡献相加以求得总残差向量 $\\mathbf{R}$。最后，计算无量纲比率 $r = \\dfrac{\\|\\mathbf{R}\\|_2}{\\sum_{\\text{faces}} \\|\\text{flux contribution}\\|_2}$，以量化违反的程度。\n\n根据理论：\n- 测试 $1$ 和 $3$ 是一致的，无论扭曲度如何，都应产生接近机器精度零的比率 $r$。\n- 测试 $2$ 和 $4$ 在扭曲网格（$s=0.3$）上使用不一致的格式。对称性被破坏，因此 $\\sum_f \\hat{\\mathbf{n}}_f \\neq \\mathbf{0}$，导致非零残差和比率 $r > 0$。\n- 测试 $5$ 和 $6$ 在正交网格（$s=0.0$）上使用不一致的格式。控制体（主控制体和对偶控制体）都是对称的矩形/正方形。由于这种对称性，通过对立面法向量的抵消，$\\sum_f \\hat{\\mathbf{n}}_f = \\mathbf{0}$。因此，即使是不一致的格式也有望产生零残差，从而掩盖了潜在的格式错误。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the free-stream preservation tests.\n    \"\"\"\n\n    # 1. Define the uniform free-stream state\n    rho = 1.225  # density\n    u = 200.0    # x-velocity\n    v = 50.0     # y-velocity\n    p = 101325.0 # pressure\n    gamma = 1.4  # ratio of specific heats\n\n    # Calculate derived quantities\n    e = p / ((gamma - 1) * rho)\n    E_total = e + 0.5 * (u**2 + v**2)\n\n    # 2. Define the constant Euler flux vectors F and G\n    F_flux = np.array([\n        rho * u,\n        rho * u**2 + p,\n        rho * u * v,\n        (rho * E_total + p) * u\n    ])\n\n    G_flux = np.array([\n        rho * v,\n        rho * u * v,\n        rho * v**2 + p,\n        (rho * E_total + p) * v\n    ])\n\n    # 3. Define the test suite as specified in the problem\n    test_cases = [\n        # Test 1: cell-centered, skewed, consistent\n        {'type': 'cell', 's': 0.3, 'consistent': True},\n        # Test 2: cell-centered, skewed, inconsistent\n        {'type': 'cell', 's': 0.3, 'consistent': False},\n        # Test 3: vertex-centered, skewed, consistent\n        {'type': 'vertex', 's': 0.3, 'consistent': True},\n        # Test 4: vertex-centered, skewed, inconsistent\n        {'type': 'vertex', 's': 0.3, 'consistent': False},\n        # Test 5: cell-centered, orthogonal, inconsistent\n        {'type': 'cell', 's': 0.0, 'consistent': False},\n        # Test 6: vertex-centered, orthogonal, inconsistent\n        {'type': 'vertex', 's': 0.0, 'consistent': False},\n    ]\n\n    results = []\n    # 4. Execute each test case\n    for params in test_cases:\n        ratio = run_test(params, F_flux, G_flux)\n        results.append(ratio)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_vertices(s):\n    \"\"\"\n    Generates the 3x3 grid of vertex coordinates for a given skew factor s.\n    \"\"\"\n    vertices = np.zeros((3, 3, 2))\n    for j in range(3):\n        for i in range(3):\n            vertices[i, j, 0] = float(i) + s * float(j)\n            vertices[i, j, 1] = float(j)\n    return vertices\n\ndef compute_residual_for_polygon(polygon_vertices, use_consistent_flux, F, G):\n    \"\"\"\n    Computes the discrete residual and the dimensionless ratio for a given\n    closed polygon control volume.\n    \"\"\"\n    total_residual = np.zeros(4)\n    denominator_sum = 0.0\n    num_verts = len(polygon_vertices)\n\n    # Iterate over the faces of the polygon (defined by successive vertices)\n    for i in range(num_verts):\n        p1 = polygon_vertices[i]\n        p2 = polygon_vertices[(i + 1) % num_verts]  # Assumes CCW ordering\n\n        # Compute face geometry from its vertices\n        edge_vec = p2 - p1\n        # Area vector is normal to the edge, pointing outwards for CCW traversal\n        area_vec = np.array([edge_vec[1], -edge_vec[0]])\n        \n        length = np.linalg.norm(area_vec)\n        if length  1e-15:\n            # Should not happen with this problem's geometry\n            unit_normal = np.zeros(2)\n        else:\n            unit_normal = area_vec / length\n\n        # Select the projection vector based on consistency\n        if use_consistent_flux:\n            alpha = area_vec\n        else:\n            alpha = unit_normal\n\n        # Calculate the flux contribution for this face\n        flux_contribution = F * alpha[0] + G * alpha[1]\n        \n        # Accumulate the total residual and the denominator term\n        total_residual += flux_contribution\n        denominator_sum += np.linalg.norm(flux_contribution)\n\n    # Calculate the final dimensionless residual ratio\n    numerator = np.linalg.norm(total_residual)\n    if denominator_sum  1e-15:\n        return 0.0\n    \n    return numerator / denominator_sum\n\ndef run_test(params, F, G):\n    \"\"\"\n    Sets up and runs a single test case.\n    \"\"\"\n    s = params['s']\n    test_type = params['type']\n    is_consistent = params['consistent']\n\n    # Generate the primary 3x3 vertex grid\n    vertices = generate_vertices(s)\n    cv_polygon_verts = []\n\n    if test_type == 'cell':\n        # Select the first cell [0,0] for the test. Its vertices are\n        # (0,0), (1,0), (1,1), (0,1) in the (i,j) index space.\n        cv_polygon_verts = [\n            vertices[0, 0],\n            vertices[1, 0],\n            vertices[1, 1],\n            vertices[0, 1]\n        ]\n    elif test_type == 'vertex':\n        # Construct the dual control volume around the central vertex (1,1).\n        # The dual polygon connects the midpoints of the four incident edges.\n        v_c = vertices[1, 1]  # Central vertex\n        v_r = vertices[2, 1]  # Right neighbor\n        v_t = vertices[1, 2]  # Top neighbor\n        v_l = vertices[0, 1]  # Left neighbor\n        v_b = vertices[1, 0]  # Bottom neighbor\n        \n        # Midpoints forming the dual cell, ordered CCW around v_c to form the polygon\n        m_b = 0.5 * (v_c + v_b)\n        m_r = 0.5 * (v_c + v_r)\n        m_t = 0.5 * (v_c + v_t)\n        m_l = 0.5 * (v_c + v_l)\n        \n        cv_polygon_verts = [m_r, m_t, m_l, m_b]\n    \n    # Compute and return the residual ratio for the constructed control volume\n    return compute_residual_for_polygon(np.array(cv_polygon_verts), is_consistent, F, G)\n\n# Execute the main function\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "数值格式的真正考验往往在于其处理激波等不连续性的能力。最后的这项实践将探索在面对激波时，两种布局在行为上的细微但重要的差异 ()。通过为伯格斯方程 (Burgers' equation) 实现两种格式并量化比较其在激波附近的数值过冲，您将获得关于数据点和通量点交错布局如何影响解的质量和稳定性的实践洞察——即便在所有其他数值组件（如限制器和通量函数）完全相同的情况下。",
            "id": "3947027",
            "problem": "您需要实现并比较两种有限体积重构方法，用于求解一维非线性守恒律，以便在使用相同斜率限制器时，评估和量化激波附近的过冲，然后将任何差异与计算流体动力学（CFD）中与单元中心和顶点中心排列相关的重构位置联系起来。考虑无粘性伯格斯方程，这是一个典型的非线性标量守恒律，由下式给出\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0, \\quad f(u) = \\frac{u^2}{2},\n$$\n在域 $[x_{\\min}, x_{\\max}] = [-1, 1]$ 上。使用黎曼型初始条件\n$$\nu(x,0) = \\begin{cases}\nu_L,  x  x_0,\\\\\nu_R,  x \\ge x_0,\n\\end{cases}\n$$\n其中 $u_L > u_R$ 以形成激波。激波速度由 Rankine-Hugoniot 关系式给出 $s = \\dfrac{f(u_L) - f(u_R)}{u_L - u_R} = \\dfrac{u_L + u_R}{2}$。\n\n在两种排列中，使用 Van Albada 限制器实现相同的二阶空间重构：\n- 单元中心排列：未知量 $u_i$ 位于单元中心 $x_i = x_{\\min} + (i+1/2)\\Delta x$（对于 $i = 0, 1, \\dots, N_{\\mathrm{cc}}-1$），面位于 $x_{i+1/2} = x_{\\min} + (i+1)\\Delta x$。\n- 顶点中心排列：未知量 $u_j$ 位于网格顶点 $x_j = x_{\\min} + j\\,\\Delta x$（对于 $j = 0, 1, \\dots, N_{\\mathrm{vc}}-1$），中点（控制体积的面）位于 $x_{j+1/2} = x_{\\min} + (j+1/2)\\Delta x$。\n\n在两种排列中，使用相同的数值通量（局部 Lax-Friedrichs/Rusanov 通量），\n$$\nF(u_L,u_R) = \\frac{1}{2}\\left(f(u_L) + f(u_R)\\right) - \\frac{1}{2}\\alpha (u_R - u_L), \\quad \\alpha = \\max\\left(|u_L|, |u_R|\\right),\n$$\n和相同的斜率限制。对于未知量数组 $u_k$，定义单边差分 $\\Delta^-_k = u_k - u_{k-1}$ 和 $\\Delta^+_k = u_{k+1} - u_k$，一个比率 $r_k = \\dfrac{\\Delta^-_k}{\\Delta^+_k + \\varepsilon}$（其中 $\\varepsilon  0$ 是一个小量），以及 Van Albada 限制器函数\n$$\n\\phi(r) = \\frac{r^2 + r}{r^2 + 1}.\n$$\n使用限制后的斜率 $s_k = \\phi(r_k)\\,\\Delta^+_k$ 通过 MUSCL 型线性重构来重构面上的左右状态，\n$$\nu_{k+1/2}^{L} = u_k + \\frac{1}{2} s_k, \\qquad\nu_{k+1/2}^{R} = u_{k+1} - \\frac{1}{2} s_{k+1}.\n$$\n使用二阶强保稳龙格-库塔方法（SSP-RK2）将时间推进到目标时间 $t_{\\mathrm{final}}$，时间步长满足 Courant-Friedrichs-Lewy (CFL) 条件\n$$\n\\Delta t = \\mathrm{CFL}\\,\\frac{\\Delta x}{\\max_k |u_k| + \\delta},\n$$\n其中 $\\delta$ 是一个小的正常数，以避免除以零。施加与初始黎曼数据一致的恒定 Dirichlet 边界状态，即 $u(x_{\\min},t)=u_L$ 和 $u(x_{\\max},t)=u_R$，并使用鬼点（或鬼点顶点）在边界处应用重构。\n\n相对于由初始极值给出的物理相关界限来定义过冲和下冲指标，\n$$\nu_{\\max}^{0} = \\max(u_L,u_R), \\qquad u_{\\min}^{0} = \\min(u_L,u_R),\n$$\n并在时间 $t_{\\mathrm{final}}$ 计算\n$$\n\\text{overshoot}^+ = \\max\\left(0, \\max_x u(x,t_{\\mathrm{final}}) - u_{\\max}^{0}\\right),\n$$\n$$\n\\text{overshoot}^- = \\max\\left(0, u_{\\min}^{0} - \\min_x u(x,t_{\\mathrm{final}})\\right).\n$$\n在保持限制器和通量相同的情况下，为单元中心和顶点中心两种排列计算这些指标。这些指标的任何差异都应归因于两种排列之间重构位置的差异。\n\n使用以下测试套件。所有值都是无量纲和无单位的。不涉及角度。对于每种情况，在两种排列中采用相同的 $\\mathrm{CFL}$，并在限制器中使用小参数 $\\varepsilon = 10^{-12}$。对于顶点中心情况，选择 $N_{\\mathrm{vc}} = N_{\\mathrm{cc}} + 1$ 以使两种排列之间的 $\\Delta x$ 匹配，即 $\\Delta x = \\dfrac{x_{\\max}-x_{\\min}}{N_{\\mathrm{cc}}} = \\dfrac{x_{\\max}-x_{\\min}}{N_{\\mathrm{vc}} - 1}$。\n\n- 情况1（激波与单元中心排列的单元面和顶点中心排列的顶点对齐）：\n  - $N_{\\mathrm{cc}} = 200$， $N_{\\mathrm{vc}} = 201$， $u_L = 1.0$， $u_R = 0.2$， $x_0 = 0.0$， $t_{\\mathrm{final}} = 0.2$， $\\mathrm{CFL} = 0.45$。\n- 情况2（更强的激波，与情况1对齐方式相同）：\n  - $N_{\\mathrm{cc}} = 200$， $N_{\\mathrm{vc}} = 201$， $u_L = 2.0$， $u_R = 0.1$， $x_0 = 0.0$， $t_{\\mathrm{final}} = 0.15$， $\\mathrm{CFL} = 0.45$。\n- 情况3（更粗的网格，激波与两个顶点节点之间的中点对齐，即与顶点中心的面重合；单元中心网格使用相同的 $x_0$，通常不与单元面重合）：\n  - $N_{\\mathrm{cc}} = 50$, $N_{\\mathrm{vc}} = 51$, $u_L = 1.5$, $u_R = 0.5$, $x_0 = x_{\\min} + \\frac{1}{2}\\,\\Delta x$ (其中 $\\Delta x$ 由顶点中心网格定义), $t_{\\mathrm{final}} = 0.2$, $\\mathrm{CFL} = 0.45$。\n- 情况4（非常强的激波，不连续点位置未对齐）：\n  - $N_{\\mathrm{cc}} = 100$, $N_{\\mathrm{vc}} = 101$, $u_L = 3.0$, $u_R = 0.0$, $x_0 = 0.123456$, $t_{\\mathrm{final}} = 0.1$, $\\mathrm{CFL} = 0.45$。\n\n您的程序必须：\n- 用相同的数值通量和相同的 Van Albada 限制器实现两种排列，并为每种排列在相同的物理面位置重构左右状态。\n- 对于每个测试用例，使用 SSP-RK2 将解推进到指定的 $t_{\\mathrm{final}}$。\n- 在每个测试中为两种排列计算 $\\text{overshoot}^+$ 和 $\\text{overshoot}^-$。\n- 将过冲幅度表示为纯数字（无单位），以四舍五入到六位小数的十进制浮点数打印。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个情况，按顺序输出四个值 $[\\text{overshoot}^+_{\\mathrm{cc}}, \\text{overshoot}^+_{\\mathrm{vc}}, \\text{overshoot}^-_{\\mathrm{cc}}, \\text{overshoot}^-_{\\mathrm{vc}}]$，并将这四个情况的结果连接起来，形成一个扁平列表。例如，两个情况的输出形式将是 $[\\alpha_1,\\beta_1,\\gamma_1,\\delta_1,\\alpha_2,\\beta_2,\\gamma_2,\\delta_2]$，其中每个符号都是一个四舍五入到六位小数的十进制浮点数。",
            "solution": "该问题要求为一维无粘性伯格斯方程实现并比较单元中心和顶点中心的有限体积格式。该分析侧重于量化激波不连续点附近的数值过冲和下冲，这为理解计算流体动力学（CFD）中这两种常用离散化策略的行为提供了见解。问题是自洽的，所有必要的方程、数值方法和参数都已指定。\n\n控制方程是无粘性伯格斯方程，一个非线性标量守恒律：\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0, \\quad \\text{where } f(u) = \\frac{u^2}{2}\n$$\n该方程在域 $x \\in [x_{\\min}, x_{\\max}]$ 上求解，初始条件为黎曼问题，会产生一个向右传播的激波。采用有限体积法，该方法涉及将域离散为控制体积，并在每个体积上对偏微分方程进行积分。这会产生一个关于解的体积平均值或节点值的常微分方程（ODE）组，可以写成半离散形式：\n$$\n\\frac{d\\mathbf{U}}{dt} = \\mathbf{L}(\\mathbf{U})\n$$\n其中 $\\mathbf{U}$ 是离散未知量向量，$\\mathbf{L}$ 是空间离散算子，表示数值通量的负散度。\n\n问题的核心在于比较离散未知量 $\\mathbf{U}$ 的两种不同空间排列方式：\n\n**1. 单元中心（CC）排列**\n在单元中心格式中，区域被划分为 $N_{\\mathrm{cc}}$ 个单元，$C_i = [x_{i-1/2}, x_{i+1/2}]$，对于 $i=0, \\dots, N_{\\mathrm{cc}}-1$。单元面位于 $x_{i+1/2} = x_{\\min} + (i+1)\\Delta x$，单元宽度为 $\\Delta x = (x_{\\max}-x_{\\min})/N_{\\mathrm{cc}}$。离散未知量 $u_i$ 代表单元 $C_i$ 上的解的平均值，并名义上位于单元中心 $x_i = x_{\\min} + (i+1/2)\\Delta x$。单元 $i$ 的半离散方程为：\n$$\n\\frac{du_i}{dt} = -\\frac{1}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\n其中 $F_{i+1/2}$ 是单元 $i$ 和单元 $i+1$ 之间界面上的数值通量。\n\n**2. 顶点中心（VC）排列**\n在顶点中心格式中，区域被 $N_{\\mathrm{vc}}$ 个顶点或节点划分为 $N_{\\mathrm{vc}}-1$ 个段，这些顶点位于 $x_j = x_{\\min} + j\\Delta x$，对于 $j=0, \\dots, N_{\\mathrm{vc}}-1$。间距为 $\\Delta x = (x_{\\max}-x_{\\min})/(N_{\\mathrm{vc}}-1)$。未知量 $u_j$ 是顶点 $x_j$ 处的解的值。围绕每个内部顶点构建控制体积，$V_j = [x_{j-1/2}, x_{j+1/2}]$，其中 $x_{j+1/2} = (x_j + x_{j+1})/2$ 是顶点之间的中点。内部顶点 $j$ 的半离散方程为：\n$$\n\\frac{du_j}{dt} = -\\frac{1}{\\Delta x} \\left( F_{j+1/2} - F_{j-1/2} \\right)\n$$\n其中 $F_{j+1/2}$ 是控制体积 $V_j$ 面上的数值通量。边界节点 $u_0$ 和 $u_{N_{\\mathrm{vc}}-1}$ 由 Dirichlet 边界条件固定。\n\n一个关键区别在于通量计算的位置。在 CC 网格中，通量在单元面上计算，这些面与相应 VC 网格的顶点位置重合。在 VC 网格中，通量在控制体积面上计算，这些面与相应 CC 网格的单元中心位置重合。这种“交错”关系是这两种格式数值特性不同的根本原因。\n\n为确保公平比较，问题为两种格式指定了相同的数值组件：\n- **数值通量：** 使用局部 Lax-Friedrichs（或 Rusanov）通量，由 $F(u_L, u_R) = \\frac{1}{2}(f(u_L) + f(u_R)) - \\frac{1}{2}\\alpha(u_R - u_L)$ 给出，其中波速估计为 $\\alpha = \\max(|u_L|, |u_R|)$。\n- **空间重构：** 使用二阶 MUSCL 型线性重构，从单元/顶点局部数据中获取每个界面处的左（$u^L$）和右（$u^R$）状态。对于单元/顶点 $k$ 和 $k+1$ 之间的界面 $k+1/2$，状态为：\n$$\nu_{k+1/2}^{L} = u_k + \\frac{1}{2} s_k, \\qquad u_{k+1/2}^{R} = u_{k+1} - \\frac{1}{2} s_{k+1}\n$$\n其中 $s_k$ 是单元/顶点 $k$ 中限制后的斜率。\n- **斜率限制器：** 使用 Van Albada 限制器来限制斜率，以防止在激波附近产生伪振荡并确保稳定性。单元/顶点 $k$ 中的斜率为 $s_k = \\phi(r_k) \\Delta^+_k$，其中 $\\Delta^+_k = u_{k+1}-u_k$ 是前向差分，$r_k = (u_k - u_{k-1}) / (\\Delta^+_k + \\varepsilon)$ 是连续梯度的比率，$\\phi(r) = (r^2+r)/(r^2+1)$ 是 Van Albada 限制器函数。\n- **边界条件：** 对于 CC 格式，使用一层鬼点单元实现 Dirichlet 边界条件，其值设为 $u_{-1} = u_L$ 和 $u_{N_{cc}} = u_R$。对于 VC 格式，边界顶点值 $u_0 = u_L$ 和 $u_{N_{vc}-1} = u_R$ 被固定，并且这些边界顶点的斜率设为零（$s_0=0$, $s_{N_{vc}-1}=0$），以提供稳定的一阶边界闭合。\n- **时间积分：** 使用二阶强保稳龙格-库塔（SSP-RK2）方法对得到的常微分方程组进行时间推进。时间步长 $\\Delta t$ 由 CFL 条件决定：$\\Delta t = \\mathrm{CFL} \\frac{\\Delta x}{\\max_k |u_k| + \\delta}$。\n\n实现过程是通过创建独立的函数来为每种排列计算空间算子 $\\mathbf{L}$。主循环遍历指定的测试用例，为 CC 和 VC 两种格式运行模拟直到 $t_{\\mathrm{final}}$，然后根据最终的解剖面计算过冲和下冲指标。过冲指标量化了数值解违反极值原理的程度，该原理指出对于标量守恒律，不应产生新的极值。在其他数值设置相同的情况下，CC 和 VC 格式之间这些指标的任何差异都可归因于网格排列的差异。\n\n预计分析将显示，即使使用相同的限制器，未知量和通量计算位置的不同也会导致限制器在重构解上的作用方式发生变化，进而影响激波附近伪振荡的幅度。这类研究对于开发高保真度 CFD 代码至关重要，在这些代码中，控制非物理假象对于准确预测是至关重要的。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        {'N_cc': 200, 'N_vc': 201, 'u_L': 1.0, 'u_R': 0.2, 'x_0': 0.0, 't_final': 0.2, 'CFL': 0.45},\n        {'N_cc': 200, 'N_vc': 201, 'u_L': 2.0, 'u_R': 0.1, 'x_0': 0.0, 't_final': 0.15, 'CFL': 0.45},\n        {'N_cc': 50, 'N_vc': 51, 'u_L': 1.5, 'u_R': 0.5, 'x_0': None, 't_final': 0.2, 'CFL': 0.45}, # x0 to be calculated\n        {'N_cc': 100, 'N_vc': 101, 'u_L': 3.0, 'u_R': 0.0, 'x_0': 0.123456, 't_final': 0.1, 'CFL': 0.45},\n    ]\n\n    # Special handling for Case 3's x0\n    x_min, x_max = -1.0, 1.0\n    dx_vc_case3 = (x_max - x_min) / (test_cases[2]['N_vc'] - 1)\n    test_cases[2]['x_0'] = x_min + 0.5 * dx_vc_case3\n\n    results = []\n    for params in test_cases:\n        # Cell-Centered Run\n        overshoot_p_cc, overshoot_m_cc = run_simulation(\n            scheme='cc',\n            N=params['N_cc'],\n            u_L=params['u_L'],\n            u_R=params['u_R'],\n            x_0=params['x_0'],\n            t_final=params['t_final'],\n            CFL=params['CFL']\n        )\n        \n        # Vertex-Centered Run\n        overshoot_p_vc, overshoot_m_vc = run_simulation(\n            scheme='vc',\n            N=params['N_vc'],\n            u_L=params['u_L'],\n            u_R=params['u_R'],\n            x_0=params['x_0'],\n            t_final=params['t_final'],\n            CFL=params['CFL']\n        )\n        \n        results.extend([overshoot_p_cc, overshoot_p_vc, overshoot_m_cc, overshoot_m_vc])\n\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\ndef run_simulation(scheme, N, u_L, u_R, x_0, t_final, CFL):\n    \"\"\"\n    Runs a single simulation for a given arrangement and parameters.\n    \"\"\"\n    x_min, x_max = -1.0, 1.0\n    eps = 1e-12\n    delta = 1e-9\n\n    # Setup grid\n    if scheme == 'cc':\n        dx = (x_max - x_min) / N\n        x = x_min + (np.arange(N) + 0.5) * dx\n    elif scheme == 'vc':\n        dx = (x_max - x_min) / (N - 1)\n        x = x_min + np.arange(N) * dx\n    else:\n        raise ValueError(\"Unknown scheme type\")\n\n    # Initial condition\n    u = np.where(x  x_0, u_L, u_R)\n\n    # Time integration\n    t = 0.0\n    while t  t_final:\n        max_wave_speed = np.max(np.abs(u))\n        dt = CFL * dx / (max_wave_speed + delta)\n        if t + dt > t_final:\n            dt = t_final - t\n        \n        # SSP-RK2\n        if scheme == 'cc':\n            Lu_n = compute_rhs_cc(u, dx, u_L, u_R, eps)\n            u1 = u + dt * Lu_n\n            Lu_1 = compute_rhs_cc(u1, dx, u_L, u_R, eps)\n            u = 0.5 * u + 0.5 * (u1 + dt * Lu_1)\n        elif scheme == 'vc':\n            Lu_n = compute_rhs_vc(u, dx, u_L, u_R, eps)\n            u1_interior = u[1:-1] + dt * Lu_n\n            u1 = np.copy(u)\n            u1[1:-1] = u1_interior\n            Lu_1 = compute_rhs_vc(u1, dx, u_L, u_R, eps)\n            u_interior = 0.5 * u[1:-1] + 0.5 * (u1_interior + dt * Lu_1)\n            u[1:-1] = u_interior\n            \n        t += dt\n\n    # Compute metrics\n    u_max_0 = max(u_L, u_R)\n    u_min_0 = min(u_L, u_R)\n    \n    overshoot_p = max(0.0, np.max(u) - u_max_0)\n    overshoot_m = max(0.0, u_min_0 - np.min(u))\n    \n    return overshoot_p, overshoot_m\n\ndef physical_flux(u):\n    return 0.5 * u**2\n\ndef rusanov_flux(ul, ur):\n    alpha = np.maximum(np.abs(ul), np.abs(ur))\n    return 0.5 * (physical_flux(ul) + physical_flux(ur)) - 0.5 * alpha * (ur - ul)\n\ndef van_albada_limiter(r):\n    return (r**2 + r) / (r**2 + 1.0)\n\ndef compute_rhs_cc(u, dx, u_L, u_R, eps):\n    \"\"\"Computes the spatial operator L(u) for the cell-centered scheme.\"\"\"\n    N_cc = len(u)\n    # Apply BC using ghost cells\n    u_padded = np.concatenate(([u_L], u, [u_R]))\n\n    # Compute slopes in all real cells\n    delta_plus = u_padded[1:-1] - u_padded[:-2] # u_i - u_{i-1}\n    delta_minus = u_padded[2:] - u_padded[1:-1] # u_{i+1} - u_i\n    \n    # Corrected slope formulation\n    # slope s_i is computed using u_{i-1}, u_i, u_{i+1}\n    u_m1 = u_padded[:-2]\n    u_p0 = u_padded[1:-1]\n    u_p1 = u_padded[2:]\n    \n    del_m = u_p0 - u_m1\n    del_p = u_p1 - u_p0\n\n    with np.errstate(divide='ignore', invalid='ignore'):\n        r = del_m / (del_p + eps)\n    phi_r = van_albada_limiter(r)\n    s = phi_r * del_p\n    s[np.isnan(s)] = 0.0\n\n    # Reconstruct states at faces\n    # For face i+1/2 between cell i and i+1\n    # uL comes from cell i, uR from cell i+1\n    uL_at_faces = np.zeros(N_cc + 1)\n    uR_at_faces = np.zeros(N_cc + 1)\n\n    uL_at_faces[1:] = u + 0.5 * s\n    uR_at_faces[:-1] = u - 0.5 * s\n    \n    # Boundary faces\n    uL_at_faces[0] = u_L\n    uR_at_faces[-1] = u_R\n\n    # Compute fluxes\n    fluxes = rusanov_flux(uL_at_faces, uR_at_faces)\n    \n    # Compute RHS\n    rhs = -(fluxes[1:] - fluxes[:-1]) / dx\n    return rhs\n\ndef compute_rhs_vc(u, dx, u_L, u_R, eps):\n    \"\"\"Computes the spatial operator L(u) for the vertex-centered scheme.\"\"\"\n    N_vc = len(u)\n    s = np.zeros(N_vc)\n    \n    # Compute slopes for interior vertices (j=1..N-2)\n    u_m1 = u[0:-2]\n    u_p0 = u[1:-1]\n    u_p1 = u[2:]\n    \n    del_m = u_p0 - u_m1\n    del_p = u_p1 - u_p0\n    \n    with np.errstate(divide='ignore', invalid='ignore'):\n        r = del_m / (del_p + eps)\n    phi_r = van_albada_limiter(r)\n    s[1:-1] = phi_r * del_p\n    s[np.isnan(s)] = 0.0\n\n    # Reconstruct states at interior faces (j+1/2, for j=0..N-2)\n    num_faces = N_vc - 1\n    uL_at_faces = np.zeros(num_faces)\n    uR_at_faces = np.zeros(num_faces)\n\n    uL_at_faces = u[:-1] + 0.5 * s[:-1]\n    uR_at_faces = u[1:] - 0.5 * s[1:]\n    \n    # Compute fluxes\n    fluxes = rusanov_flux(uL_at_faces, uR_at_faces)\n\n    # Compute RHS for interior vertices\n    rhs = -(fluxes[1:] - fluxes[:-1]) / dx\n    return rhs\n\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}