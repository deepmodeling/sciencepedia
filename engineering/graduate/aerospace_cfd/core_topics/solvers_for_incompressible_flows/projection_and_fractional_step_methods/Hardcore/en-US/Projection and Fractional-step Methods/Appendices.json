{
    "hands_on_practices": [
        {
            "introduction": "The heart of a projection method is the mathematical operator that enforces the incompressibility constraint. This exercise  takes you into Fourier space—the natural setting for spectral methods on periodic domains—to derive this projection operator from first principles. By completing this derivation, you will solidify your understanding of how an arbitrary vector field is decomposed into a divergence-free part and a gradient part, a cornerstone of incompressible flow simulation.",
            "id": "3987130",
            "problem": "Consider the incompressible Navier–Stokes equations for a viscous fluid on a three-dimensional periodic cube of side length $2\\pi$ with periodic boundary conditions. In a classical projection (fractional-step) method, one constructs a divergence-free velocity $\\boldsymbol{w}(\\boldsymbol{x})$ from a given intermediate velocity $\\boldsymbol{v}(\\boldsymbol{x})$ by subtracting a gradient:\n$$\n\\boldsymbol{w}(\\boldsymbol{x}) \\;=\\; \\boldsymbol{v}(\\boldsymbol{x}) \\;-\\; \\nabla \\phi(\\boldsymbol{x}),\n$$\nwith the scalar potential $\\phi(\\boldsymbol{x})$ chosen such that $\\nabla \\cdot \\boldsymbol{w}(\\boldsymbol{x})=0$. Let $\\widehat{\\boldsymbol{v}}(\\boldsymbol{k})$ denote the Fourier coefficient of $\\boldsymbol{v}(\\boldsymbol{x})$ at the integer wavevector $\\boldsymbol{k} \\in \\mathbb{Z}^{3}$, and similarly for $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k})$ and $\\widehat{\\phi}(\\boldsymbol{k})$. Use only the following foundations:\n- Incompressibility requires $\\nabla \\cdot \\boldsymbol{w}(\\boldsymbol{x})=0$.\n- The decomposition $\\boldsymbol{w}=\\boldsymbol{v}-\\nabla\\phi$ is the defining step of the projection method.\n- On a periodic domain, the Fourier symbol of the gradient is $i\\boldsymbol{k}$, and the Fourier symbol of the Laplacian is $-|\\boldsymbol{k}|^{2}$.\n\nTask:\n1. Derive the Fourier-space representation of the projection operator $\\mathcal{P}$ that maps any vector Fourier mode $\\widehat{\\boldsymbol{v}}(\\boldsymbol{k})$ to its divergence-free counterpart $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k})$.\n2. For the specific mode $\\boldsymbol{k}=(1,2,2)$ and the given intermediate Fourier coefficient $\\widehat{\\boldsymbol{v}}(\\boldsymbol{k})=(3, -1, 4)$, compute the projected mode $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k})$.\n\nExpress your final answer as a single row vector containing the three components of $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k})$. No rounding is required.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of computational fluid dynamics, specifically the projection method for incompressible flows. It is well-posed, objective, and contains all necessary information to derive the projection operator and compute the required quantity.\n\nThe solution proceeds in two parts as requested by the task. First, we derive the general Fourier-space representation of the projection operator. Second, we apply this operator to the specific intermediate velocity mode provided.\n\n**Part 1: Derivation of the Fourier-Space Projection Operator**\n\nThe projection method decomposes an arbitrary vector field $\\boldsymbol{v}(\\boldsymbol{x})$ into a divergence-free part $\\boldsymbol{w}(\\boldsymbol{x})$ and a gradient part $\\nabla\\phi(\\boldsymbol{x})$. The governing equation for this decomposition is given as:\n$$\n\\boldsymbol{w}(\\boldsymbol{x}) = \\boldsymbol{v}(\\boldsymbol{x}) - \\nabla \\phi(\\boldsymbol{x})\n$$\nThe resulting field $\\boldsymbol{w}(\\boldsymbol{x})$ is required to be divergence-free, which imposes the constraint:\n$$\n\\nabla \\cdot \\boldsymbol{w}(\\boldsymbol{x}) = 0\n$$\nTo find an equation for the scalar potential $\\phi(\\boldsymbol{x})$, we take the divergence of the first equation:\n$$\n\\nabla \\cdot \\boldsymbol{w}(\\boldsymbol{x}) = \\nabla \\cdot \\boldsymbol{v}(\\boldsymbol{x}) - \\nabla \\cdot (\\nabla \\phi(\\boldsymbol{x}))\n$$\nUsing the vector calculus identity $\\nabla \\cdot (\\nabla \\phi) = \\nabla^2 \\phi$, where $\\nabla^2$ is the Laplacian operator, we have:\n$$\n\\nabla \\cdot \\boldsymbol{w}(\\boldsymbol{x}) = \\nabla \\cdot \\boldsymbol{v}(\\boldsymbol{x}) - \\nabla^2 \\phi(\\boldsymbol{x})\n$$\nApplying the incompressibility constraint $\\nabla \\cdot \\boldsymbol{w}(\\boldsymbol{x}) = 0$, we arrive at the Poisson equation for $\\phi(\\boldsymbol{x})$:\n$$\n\\nabla^2 \\phi(\\boldsymbol{x}) = \\nabla \\cdot \\boldsymbol{v}(\\boldsymbol{x})\n$$\nWe now transform these equations into Fourier space. Let $\\widehat{f}(\\boldsymbol{k}) = \\mathcal{F}(f(\\boldsymbol{x}))$ denote the Fourier coefficient of a function $f(\\boldsymbol{x})$ at wavevector $\\boldsymbol{k} \\in \\mathbb{Z}^3$. Using the provided Fourier symbols for the gradient ($\\nabla \\to i\\boldsymbol{k}$), divergence ($\\nabla \\cdot \\to i\\boldsymbol{k}\\cdot$), and Laplacian ($\\nabla^2 \\to -|\\boldsymbol{k}|^2$), the equations become:\n$$\n\\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = \\widehat{\\boldsymbol{v}}(\\boldsymbol{k}) - i\\boldsymbol{k}\\widehat{\\phi}(\\boldsymbol{k})\n$$\nand the Poisson equation for the potential becomes:\n$$\n-|\\boldsymbol{k}|^2 \\widehat{\\phi}(\\boldsymbol{k}) = i\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{v}}(\\boldsymbol{k})\n$$\nFor any non-zero wavevector, $\\boldsymbol{k} \\neq \\boldsymbol{0}$, we can solve for $\\widehat{\\phi}(\\boldsymbol{k})$:\n$$\n\\widehat{\\phi}(\\boldsymbol{k}) = -\\frac{i\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{v}}(\\boldsymbol{k})}{|\\boldsymbol{k}|^2}\n$$\nThe case $\\boldsymbol{k}=\\boldsymbol{0}$ corresponds to the mean flow, which is trivially divergence-free, so no projection is needed. For $\\boldsymbol{k} \\neq \\boldsymbol{0}$, we substitute the expression for $\\widehat{\\phi}(\\boldsymbol{k})$ back into the equation for $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k})$:\n$$\n\\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = \\widehat{\\boldsymbol{v}}(\\boldsymbol{k}) - i\\boldsymbol{k} \\left( -\\frac{i\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{v}}(\\boldsymbol{k})}{|\\boldsymbol{k}|^2} \\right)\n$$\nSimplifying the expression, noting that $i \\times (-i) = -i^2 = -(-1) = 1$:\n$$\n\\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = \\widehat{\\boldsymbol{v}}(\\boldsymbol{k}) - \\frac{\\boldsymbol{k}(\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{v}}(\\boldsymbol{k}))}{|\\boldsymbol{k}|^2}\n$$\nThis equation defines the action of the projection operator $\\mathcal{P}$ in Fourier space, such that $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = \\mathcal{P}(\\boldsymbol{k})\\widehat{\\boldsymbol{v}}(\\boldsymbol{k})$. This operator can be written in matrix form using the identity matrix $\\boldsymbol{I}$ and the outer product (or tensor product) $\\boldsymbol{k} \\otimes \\boldsymbol{k}$:\n$$\n\\mathcal{P}(\\boldsymbol{k}) = \\boldsymbol{I} - \\frac{\\boldsymbol{k} \\otimes \\boldsymbol{k}}{|\\boldsymbol{k}|^2}\n$$\nThis operator projects any vector $\\widehat{\\boldsymbol{v}}(\\boldsymbol{k})$ onto the plane orthogonal to the wavevector $\\boldsymbol{k}$, thus removing its longitudinal component and ensuring that the result $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k})$ is divergence-free ($i\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{w}}(\\boldsymbol{k})=0$).\n\n**Part 2: Calculation for the Specific Mode**\n\nWe are given the specific wavevector $\\boldsymbol{k}$ and intermediate velocity Fourier coefficient $\\widehat{\\boldsymbol{v}}(\\boldsymbol{k})$:\n$$\n\\boldsymbol{k} = (1, 2, 2)\n$$\n$$\n\\widehat{\\boldsymbol{v}}(\\boldsymbol{k}) = (3, -1, 4)\n$$\nFirst, we compute the squared magnitude of the wavevector, $|\\boldsymbol{k}|^2$:\n$$\n|\\boldsymbol{k}|^2 = k_1^2 + k_2^2 + k_3^2 = 1^2 + 2^2 + 2^2 = 1 + 4 + 4 = 9\n$$\nNext, we compute the dot product $\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{v}}(\\boldsymbol{k})$:\n$$\n\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{v}}(\\boldsymbol{k}) = k_1 \\widehat{v}_1 + k_2 \\widehat{v}_2 + k_3 \\widehat{v}_3 = (1)(3) + (2)(-1) + (2)(4) = 3 - 2 + 8 = 9\n$$\nNow we use the derived formula for the projected mode $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k})$:\n$$\n\\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = \\widehat{\\boldsymbol{v}}(\\boldsymbol{k}) - \\frac{\\boldsymbol{k} (\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{v}}(\\boldsymbol{k}))}{|\\boldsymbol{k}|^2}\n$$\nSubstituting the calculated values:\n$$\n\\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = (3, -1, 4) - \\frac{(1, 2, 2) (9)}{9}\n$$\n$$\n\\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = (3, -1, 4) - (1, 2, 2)\n$$\nPerforming the vector subtraction component-wise:\n$$\n\\widehat{w}_1(\\boldsymbol{k}) = 3 - 1 = 2\n$$\n$$\n\\widehat{w}_2(\\boldsymbol{k}) = -1 - 2 = -3\n$$\n$$\n\\widehat{w}_3(\\boldsymbol{k}) = 4 - 2 = 2\n$$\nThus, the projected Fourier mode is $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = (2, -3, 2)$. As a verification step, we can check that this resulting vector is indeed orthogonal to $\\boldsymbol{k}$:\n$$\n\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = (1)(2) + (2)(-3) + (2)(2) = 2 - 6 + 4 = 0\n$$\nSince the dot product is zero, the resulting mode is solenoidal (divergence-free in Fourier space), as required.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2 & -3 & 2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Theory comes to life through implementation, and this hands-on coding practice  challenges you to translate the concept of spectral projection into a robust numerical algorithm. You will write code to enforce the incompressibility constraint on a 2D periodic grid, using the Fast Fourier Transform (FFT) to solve the necessary Poisson equation. This exercise demonstrates how to guarantee that the resulting velocity field is discretely divergence-free to machine precision, a critical requirement for stable and accurate simulations.",
            "id": "4082126",
            "problem": "You are asked to design and implement a mass-conservative projection step in a fractional-step method for incompressible complex fluids that enforces the discrete conservation of mass at the new time level. Starting from the conservation of mass and the definition of incompressibility, construct a projection that maps an intermediate velocity field to a divergence-free field on a two-dimensional periodic domain. The domain is the unit torus with periodic boundary conditions, namely $[0,1]^2$, discretized on a uniform grid with $N_x$ points in the $x$-direction and $N_y$ points in the $y$-direction. The intermediate velocity field at time level $n$ after the explicit non-pressure update is denoted by $\\mathbf{u}^\\star(x,y) = (u^\\star(x,y), v^\\star(x,y))$, and the objective is to produce $\\mathbf{u}^{n+1}(x,y)$ satisfying $\\nabla \\cdot \\mathbf{u}^{n+1}(x,y) = 0$ at the discrete level to machine precision.\n\nYour construction must be based on a consistent pair of discrete gradient and divergence operators that are adjoint on the periodic grid so that the projection step enforces the discrete continuity equation exactly up to floating-point rounding. This step must conceptually solve a discrete Poisson equation for a scalar potential that corrects the intermediate velocity and guarantees a divergence-free result. The core scientific base must begin from the law of conservation of mass and the definition of incompressibility. No shortcut formulas are permitted in the problem statement; derive what is needed in your solution.\n\nImplement your projection in a way that is reproducible and numerically robust on the periodic unit square. All computations are to be non-dimensional. Angles, if any, are interpreted implicitly in radians because the functions employed are trigonometric in the standard mathematical sense; however, you do not need to report any angles in the output.\n\nYour program must:\n- Construct the test velocity fields $\\mathbf{u}^\\star(x,y)$ on given grids.\n- Apply your mass-conservative projection to obtain $\\mathbf{u}^{n+1}(x,y)$.\n- Compute the discrete divergence of $\\mathbf{u}^{n+1}(x,y)$ using the same discrete operators that underlie your projection mechanism.\n- Report, for each test case, the maximum absolute value of the discrete divergence over the grid as a floating-point number.\n\nTest suite:\n- Case $1$: $N_x = 32$, $N_y = 32$. Define $x_i = i/N_x$, $y_j = j/N_y$ for integers $i \\in \\{0,\\dots,N_x-1\\}$ and $j \\in \\{0,\\dots,N_y-1\\}$. Let the scalar field $\\psi(x,y) = \\sin(2\\pi x)\\cos(2\\pi y)$ and $\\phi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$. Define a potential-flow gradient component $\\mathbf{u}_{\\mathrm{grad}} = \\nabla \\psi$ and a divergence-free rotational component $\\mathbf{u}_{\\mathrm{vort}} = (-\\partial_y \\phi, \\partial_x \\phi)$. Set $\\mathbf{u}^\\star = \\mathbf{u}_{\\mathrm{grad}} + \\mathbf{u}_{\\mathrm{vort}} + 0.1\\,\\boldsymbol{\\eta}$, where $\\boldsymbol{\\eta}$ is a deterministic pseudorandom field drawn from a standard normal distribution with seed set to $0$ and shaped to $(N_x,N_y)$ for each component.\n- Case $2$: $N_x = 33$, $N_y = 17$. Let $\\mathbf{u}^\\star = \\boldsymbol{\\eta} + \\mathbf{c}$, where $\\boldsymbol{\\eta}$ is as above but with seed set to $0$, and $\\mathbf{c} = (1.5, -0.75)$ is a constant uniform velocity vector.\n- Case $3$: $N_x = 64$, $N_y = 64$. Let $\\psi(x,y) = \\cos(4\\pi x)\\sin(2\\pi y)$ and set $\\mathbf{u}^\\star = \\nabla \\psi$ (a pure gradient field).\n- Case $4$: $N_x = 8$, $N_y = 8$. Let $\\phi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$ and set $\\mathbf{u}^\\star = 3\\,(-\\partial_y \\phi, \\partial_x \\phi)$ (a scaled divergence-free field).\n- Case $5$: $N_x = 16$, $N_y = 24$. Let $\\mathbf{u}^\\star = \\boldsymbol{\\eta}$ with seed set to $42$ and components drawn from a standard normal distribution.\n\nDefinitions and requirements:\n- Use the discrete Fourier transform consistent with periodic boundary conditions to realize the discrete gradient, divergence, and the solution of the Poisson equation. Use Fast Fourier Transform (FFT) as the numerical mechanism for transforms.\n- The discrete divergence must be computed spectrally using the same wavenumbers employed in the projection construction, ensuring adjointness and exact cancellation up to floating point.\n- For each case, compute the maximum absolute discrete divergence of $\\mathbf{u}^{n+1}$ and return it as a floating-point value.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4,\\mathrm{result}_5]$). Each result must be a floating-point number.",
            "solution": "The problem requires the design and implementation of a mass-conservative projection step for an incompressible fluid on a two-dimensional periodic domain. The solution must be derived from first principles, specifically the conservation of mass, and implemented using spectral methods based on the Fast Fourier Transform (FFT).\n\nThe fundamental principle governing fluid motion is the conservation of mass, expressed by the continuity equation:\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{u}) = 0\n$$\nwhere $\\rho$ is the fluid density and $\\mathbf{u}$ is the velocity field. For a complex fluid treated as incompressible, the density $\\rho$ is assumed to be constant in both space and time. Consequently, its partial derivatives are zero, $\\frac{\\partial \\rho}{\\partial t} = 0$ and $\\nabla \\rho = \\mathbf{0}$. The continuity equation simplifies to:\n$$\n\\rho (\\nabla \\cdot \\mathbf{u}) = 0\n$$\nSince $\\rho > 0$, this yields the incompressibility constraint, which is a kinematic condition on the velocity field:\n$$\n\\nabla \\cdot \\mathbf{u} = 0\n$$\nThis equation states that the velocity field of an incompressible flow must be divergence-free.\n\nFractional-step methods, or projection methods, are commonly used to solve the time-dependent Navier-Stokes equations for incompressible flows. They decouple the computation of velocity and pressure. In a typical two-step scheme, an intermediate velocity field, denoted $\\mathbf{u}^\\star$, is first computed at time level $n+1$ by advancing the momentum equation without the pressure gradient term. This field $\\mathbf{u}^\\star$ will not, in general, satisfy the incompressibility constraint.\n\nThe second step, the projection step, corrects $\\mathbf{u}^\\star$ to produce a velocity field $\\mathbf{u}^{n+1}$ that is discretely divergence-free. This is achieved by incorporating the effect of the pressure gradient. The correction is given by:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^\\star}{\\Delta t} = -\\nabla p^{n+1}\n$$\nwhere $p^{n+1}$ is related to the pressure and $\\Delta t$ is the time step. For our non-dimensional problem, we can absorb $\\Delta t$ into a scalar potential, $\\Phi$, such that the update is:\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^\\star - \\nabla \\Phi\n$$\nThis is a statement of the Helmholtz-Hodge decomposition, which states that any vector field $\\mathbf{u}^\\star$ can be uniquely decomposed into a divergence-free component ($\\mathbf{u}^{n+1}$) and a curl-free (gradient) component ($\\nabla \\Phi$).\n\nTo find the potential $\\Phi$, we enforce the incompressibility constraint on the final velocity field, $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$. Applying the divergence operator to the correction equation, we get:\n$$\n\\nabla \\cdot \\mathbf{u}^{n+1} = \\nabla \\cdot \\mathbf{u}^\\star - \\nabla \\cdot (\\nabla \\Phi)\n$$\nSetting $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$ leads to a Poisson equation for the scalar potential $\\Phi$:\n$$\n\\nabla^2 \\Phi = \\nabla \\cdot \\mathbf{u}^\\star\n$$\nSolving this equation for $\\Phi$ allows us to compute the gradient $\\nabla \\Phi$ and subsequently the final divergence-free velocity field $\\mathbf{u}^{n+1}$.\n\nFor the specified periodic domain $[0,1]^2$, spectral methods using the Discrete Fourier Transform (DFT) are exceptionally well-suited due to their high accuracy and the efficiency of the FFT algorithm. In Fourier space, differential operators become algebraic multiplication operators. A function $f(x,y)$ on the grid is transformed to its Fourier coefficients $\\hat{f}(k_x, k_y)$, where $k_x$ and $k_y$ are the wavenumbers. The derivative operators transform as:\n$$\n\\mathcal{F}\\left(\\frac{\\partial f}{\\partial x}\\right) = i k_x \\hat{f} \\quad \\text{and} \\quad \\mathcal{F}\\left(\\frac{\\partial f}{\\partial y}\\right) = i k_y \\hat{f}\n$$\nwhere $\\mathcal{F}$ denotes the Fourier transform.\n\nThe discrete wavenumbers for a domain of size $L_x=1$, $L_y=1$ with $N_x$ and $N_y$ points are given by $k_x = 2\\pi m$ and $k_y = 2\\pi n$ for integer modes $m$ and $n$. These are calculated using `scipy.fft.fftfreq`. Specifically, $k_x = 2\\pi \\times \\text{fftfreq}(N_x, 1/N_x)$ and $k_y = 2\\pi \\times \\text{fftfreq}(N_y, 1/N_y)$.\n\nApplying the Fourier transform to the Poisson equation $\\nabla^2 \\Phi = \\nabla \\cdot \\mathbf{u}^\\star$:\n$$\n\\mathcal{F}(\\nabla^2 \\Phi) = \\mathcal{F}(\\nabla \\cdot \\mathbf{u}^\\star)\n$$\nThe left-hand side becomes:\n$$\n\\mathcal{F}(\\nabla^2 \\Phi) = \\mathcal{F}\\left(\\frac{\\partial^2 \\Phi}{\\partial x^2} + \\frac{\\partial^2 \\Phi}{\\partial y^2}\\right) = ((ik_x)^2 + (ik_y)^2)\\hat{\\Phi} = -(k_x^2 + k_y^2)\\hat{\\Phi}\n$$\nThe right-hand side, the divergence of $\\mathbf{u}^\\star = (u^\\star, v^\\star)$, becomes:\n$$\n\\mathcal{F}(\\nabla \\cdot \\mathbf{u}^\\star) = \\mathcal{F}\\left(\\frac{\\partial u^\\star}{\\partial x} + \\frac{\\partial v^\\star}{\\partial y}\\right) = i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star\n$$\nCombining these yields the algebraic equation for $\\hat{\\Phi}$ in Fourier space:\n$$\n-(k_x^2 + k_y^2)\\hat{\\Phi} = i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star\n$$\nWe can solve for $\\hat{\\Phi}$:\n$$\n\\hat{\\Phi}(k_x, k_y) = - \\frac{i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star}{k_x^2 + k_y^2}\n$$\nA special case arises for the zero-wavenumber mode $(k_x, k_y) = (0,0)$, where the denominator $k_x^2+k_y^2$ is zero. This mode corresponds to the mean value of the fields. For this mode, the numerator is also zero, $i(0)\\hat{u}^\\star_{0,0} + i(0)\\hat{v}^\\star_{0,0} = 0$. This $0/0$ indeterminacy reflects that the potential $\\Phi$ is determined only up to an arbitrary constant. We can resolve this by setting $\\hat{\\Phi}(0,0) = 0$, which corresponds to choosing the unique potential with a zero spatial mean.\n\nOnce $\\hat{\\Phi}$ is known, we find the Fourier transform of the projected velocity $\\mathbf{u}^{n+1} = \\mathbf{u}^\\star - \\nabla \\Phi$:\n$$\n\\hat{u}^{n+1} = \\hat{u}^\\star - i k_x \\hat{\\Phi}\n$$\n$$\n\\hat{v}^{n+1} = \\hat{v}^\\star - i k_y \\hat{\\Phi}\n$$\nFinally, the real-space velocity field $\\mathbf{u}^{n+1}$ is recovered by applying the inverse Fourier transform $\\mathcal{F}^{-1}$.\n\nTo verify the result, we compute the discrete divergence of $\\mathbf{u}^{n+1}$ using the same spectral operator. In Fourier space, this is:\n$$\n\\widehat{\\nabla \\cdot \\mathbf{u}^{n+1}} = i k_x \\hat{u}^{n+1} + i k_y \\hat{v}^{n+1}\n$$\nSubstituting the expressions for $\\hat{u}^{n+1}$ and $\\hat{v}^{n+1}$:\n$$\n\\widehat{\\nabla \\cdot \\mathbf{u}^{n+1}} = i k_x (\\hat{u}^\\star - i k_x \\hat{\\Phi}) + i k_y (\\hat{v}^\\star - i k_y \\hat{\\Phi})\n= (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star) - ( (ik_x)^2 + (ik_y)^2 ) \\hat{\\Phi}\n= (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star) + (k_x^2 + k_y^2) \\hat{\\Phi}\n$$\nSubstituting the solution for $\\hat{\\Phi}$:\n$$\n= (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star) + (k_x^2 + k_y^2) \\left( - \\frac{i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star}{k_x^2 + k_y^2} \\right) = 0\n$$\nThis holds for all $(k_x, k_y) \\neq (0,0)$. For $(k_x, k_y)=(0,0)$, all terms are zero. Thus, the divergence of the projected field is analytically zero in Fourier space. Its inverse transform will be zero up to floating-point rounding errors. The maximum absolute value of this field is the required output.",
            "answer": "```python\nimport numpy as np\nimport scipy.fft\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        {'Nx': 32, 'Ny': 32, 'case_type': 'grad_vort_noise', 'seed': 0},\n        {'Nx': 33, 'Ny': 17, 'case_type': 'noise_const', 'seed': 0},\n        {'Nx': 64, 'Ny': 64, 'case_type': 'pure_grad', 'seed': None},\n        {'Nx': 8, 'Ny': 8, 'case_type': 'pure_vort', 'seed': None},\n        {'Nx': 16, 'Ny': 24, 'case_type': 'pure_noise', 'seed': 42},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_single_case(params)\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.16e}' for r in results)}]\")\n\ndef _solve_single_case(params):\n    \"\"\"\n    Solves a single test case for the projection problem.\n    \"\"\"\n    Nx = params['Nx']\n    Ny = params['Ny']\n    case_type = params['case_type']\n    seed = params['seed']\n    \n    # 1. Construct the grid\n    x = np.arange(Nx) / Nx\n    y = np.arange(Ny) / Ny\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Construct the intermediate velocity field u_star\n    pi = np.pi\n    u_star, v_star = None, None\n    rng = np.random.default_rng(seed) if seed is not None else None\n\n    if case_type == 'grad_vort_noise':\n        # Case 1: Grad + Vort + Noise\n        psi = np.sin(2 * pi * xx) * np.cos(2 * pi * yy)\n        dpsi_dx = 2 * pi * np.cos(2 * pi * xx) * np.cos(2 * pi * yy)\n        dpsi_dy = -2 * pi * np.sin(2 * pi * xx) * np.sin(2 * pi * yy)\n\n        phi_vort = np.sin(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dx = 2 * pi * np.cos(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dy = 2 * pi * np.sin(2 * pi * xx) * np.cos(2 * pi * yy)\n        \n        eta_x = rng.standard_normal(size=(Nx, Ny))\n        eta_y = rng.standard_normal(size=(Nx, Ny))\n\n        u_star = dpsi_dx - dphi_dy + 0.1 * eta_x\n        v_star = dpsi_dy + dphi_dx + 0.1 * eta_y\n\n    elif case_type == 'noise_const':\n        # Case 2: Noise + Constant\n        c = (1.5, -0.75)\n        eta_x = rng.standard_normal(size=(Nx, Ny))\n        eta_y = rng.standard_normal(size=(Nx, Ny))\n        u_star = eta_x + c[0]\n        v_star = eta_y + c[1]\n\n    elif case_type == 'pure_grad':\n        # Case 3: Pure gradient field\n        psi = np.cos(4 * pi * xx) * np.sin(2 * pi * yy)\n        u_star = -4 * pi * np.sin(4 * pi * xx) * np.sin(2 * pi * yy)\n        v_star = 2 * pi * np.cos(4 * pi * xx) * np.cos(2 * pi * yy)\n\n    elif case_type == 'pure_vort':\n        # Case 4: Purely rotational (divergence-free) field\n        phi_vort = np.sin(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dx = 2 * pi * np.cos(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dy = 2 * pi * np.sin(2 * pi * xx) * np.cos(2 * pi * yy)\n        u_star = 3.0 * (-dphi_dy)\n        v_star = 3.0 * (dphi_dx)\n\n    elif case_type == 'pure_noise':\n        # Case 5: Pure noise\n        u_star = rng.standard_normal(size=(Nx, Ny))\n        v_star = rng.standard_normal(size=(Nx, Ny))\n    \n    # 3. Perform the projection\n    u_proj, v_proj = _project_velocity(u_star, v_star, Nx, Ny)\n\n    # 4. Compute the divergence of the projected field\n    divergence_field = _calculate_divergence(u_proj, v_proj, Nx, Ny)\n\n    # 5. Return the maximum absolute divergence\n    return np.max(np.abs(divergence_field))\n\ndef _project_velocity(u, v, Nx, Ny):\n    \"\"\"\n    Projects a velocity field (u, v) onto its divergence-free part.\n    \"\"\"\n    # Create wavenumber grids\n    kx_1d = 2 * np.pi * scipy.fft.fftfreq(Nx, d=1.0/Nx)\n    ky_1d = 2 * np.pi * scipy.fft.fftfreq(Ny, d=1.0/Ny)\n    kx, ky = np.meshgrid(kx_1d, ky_1d, indexing='ij')\n\n    # FFT of the velocity field\n    u_hat = scipy.fft.fft2(u)\n    v_hat = scipy.fft.fft2(v)\n\n    # Compute FFT of divergence of (u, v)\n    div_u_hat = 1j * kx * u_hat + 1j * ky * v_hat\n\n    # Solve Poisson equation for the potential phi in Fourier space\n    k_squared = kx**2 + ky**2\n    # Handle the k=0 mode to avoid division by zero\n    k_squared[0, 0] = 1.0  # Denominator is non-zero\n    \n    phi_hat = -div_u_hat / k_squared\n    # The numerator at k=0 is already zero, so this enforces phi_hat(0,0)=0\n\n    # Correct the velocity field in Fourier space\n    u_proj_hat = u_hat - 1j * kx * phi_hat\n    v_proj_hat = v_hat - 1j * ky * phi_hat\n\n    # Inverse FFT to get the projected velocity field in real space\n    u_proj = scipy.fft.ifft2(u_proj_hat).real\n    v_proj = scipy.fft.ifft2(v_proj_hat).real\n    \n    return u_proj, v_proj\n\ndef _calculate_divergence(u, v, Nx, Ny):\n    \"\"\"\n    Computes the divergence of a velocity field (u, v) using spectral methods.\n    \"\"\"\n    # Create wavenumber grids\n    kx_1d = 2 * np.pi * scipy.fft.fftfreq(Nx, d=1.0/Nx)\n    ky_1d = 2 * np.pi * scipy.fft.fftfreq(Ny, d=1.0/Ny)\n    kx, ky = np.meshgrid(kx_1d, ky_1d, indexing='ij')\n\n    # FFT of the velocity field\n    u_hat = scipy.fft.fft2(u)\n    v_hat = scipy.fft.fft2(v)\n\n    # Compute divergence in Fourier space\n    div_u_hat = 1j * kx * u_hat + 1j * ky * v_hat\n\n    # Inverse FFT to get divergence in real space\n    divergence = scipy.fft.ifft2(div_u_hat).real\n    \n    return divergence\n\nsolve()\n```"
        },
        {
            "introduction": "Fractional-step methods gain efficiency by \"splitting\" the governing equations into simpler sub-problems, but this convenience introduces a specific \"splitting error.\" This advanced practice  delves into the formal analysis of this error using the Baker–Campbell–Hausdorff (BCH) expansion. By deriving the leading-order error term—a commutator of the advection and diffusion operators—you will uncover the source of the method's intrinsic inaccuracy and build a foundation for understanding and developing higher-order accurate schemes.",
            "id": "3987160",
            "problem": "Consider the incompressible momentum equation used in projection and fractional-step methods for Computational Fluid Dynamics (CFD), with an explicit advection substep and an implicit diffusion substep. Let $\\boldsymbol{w}(\\boldsymbol{x})$ be a smooth, divergence-free advecting velocity field and let $\\nu(\\boldsymbol{x})$ be a smooth, spatially varying kinematic viscosity. Define the linear advection and diffusion operators acting componentwise on a vector field $\\boldsymbol{u}(\\boldsymbol{x},t)$ by\n$$\nA \\boldsymbol{u} \\equiv - (\\boldsymbol{w} \\cdot \\nabla)\\,\\boldsymbol{u}, \n\\qquad \nB \\boldsymbol{u} \\equiv \\nabla \\cdot \\left( \\nu \\nabla \\boldsymbol{u} \\right),\n$$\nwhere $B$ acts componentwise, that is, $(B \\boldsymbol{u})_{k} = \\partial_{i}(\\nu \\partial_{i} u_{k})$ with the Einstein summation convention over repeated spatial indices $i$ and $j$ from $1$ to $d$, with $d \\in \\{2,3\\}$. Consider a Lie splitting over a single time step of size $\\Delta t > 0$ defined by first applying diffusion and then advection, so that the one-step propagator is $\\exp(\\Delta t A)\\exp(\\Delta t B)$ as an approximation to the exact $\\exp(\\Delta t (A+B))$ evolution generated by the combined operator.\n\nUsing the Baker–Campbell–Hausdorff (BCH) expansion, derive the leading-order local splitting error operator and express it explicitly as a commutator acting on $\\boldsymbol{u}(\\boldsymbol{x},t^{n})$, in index notation, in terms of $\\boldsymbol{w}(\\boldsymbol{x})$, $\\nu(\\boldsymbol{x})$, and spatial derivatives of $\\boldsymbol{u}$ up to third order. Your final answer must be a single closed-form analytic expression for the $k$th component of the leading commutator error term at time level $t^{n}$, corresponding to the Lie composition $\\exp(\\Delta t A)\\exp(\\Delta t B)$, written using Einstein summation over spatial indices. Do not simplify by assuming constant $\\nu$ or constant $\\boldsymbol{w}$. No numerical evaluation is required. Express the final answer without units.",
            "solution": "The user has requested the derivation of the leading-order local splitting error for a Lie splitting scheme applied to the advection-diffusion equation.\n\n### Step 1: Problem Validation\n\n**1.1. Extracted Givens:**\n- **Advecting velocity:** A smooth, divergence-free vector field $\\boldsymbol{w}(\\boldsymbol{x})$, implying $\\partial_j w_j = 0$ using Einstein summation.\n- **Kinematic viscosity:** A smooth, spatially varying scalar field $\\nu(\\boldsymbol{x})$.\n- **Advection operator:** $A \\boldsymbol{u} \\equiv - (\\boldsymbol{w} \\cdot \\nabla)\\,\\boldsymbol{u}$. In index notation, for the $k$-th component, $(A \\boldsymbol{u})_{k} = -w_j \\partial_j u_k$.\n- **Diffusion operator:** $B \\boldsymbol{u} \\equiv \\nabla \\cdot \\left( \\nu \\nabla \\boldsymbol{u} \\right)$. In index notation, acting componentwise, $(B \\boldsymbol{u})_{k} = \\partial_{i}(\\nu\\,\\partial_{i} u_{k})$.\n- **Splitting scheme:** A Lie splitting over a time step $\\Delta t > 0$, where diffusion is applied first, followed by advection. The one-step propagator is $\\exp(\\Delta t A)\\exp(\\Delta t B)$.\n- **Exact evolution operator:** $\\exp(\\Delta t (A+B))$.\n- **Objective:** Derive the leading-order local splitting error operator, expressed as a commutator acting on the vector field $\\boldsymbol{u}(\\boldsymbol{x},t^{n})$, and provide the explicit expression for its $k$-th component.\n\n**1.2. Validation:**\n- **Scientific Grounding:** The problem is firmly grounded in the field of computational fluid dynamics and numerical analysis. The advection-diffusion equation, operator splitting methods (specifically Lie splitting), and the use of the Baker–Campbell–Hausdorff formula to analyze the error are all standard and well-established concepts.\n- **Well-Posedness:** The problem is well-posed. It asks for the derivation of a specific mathematical expression based on clearly defined operators and a standard analysis technique. A unique analytical solution can be obtained.\n- **Objectivity:** The problem is stated using precise, objective mathematical language.\n- **Flaw Analysis:** The problem statement is scientifically sound, formalizable, internally consistent, and contains all necessary information. It does not violate any of the invalidity criteria.\n\n**1.3. Verdict:**\nThe problem is valid.\n\n### Step 2: Solution Derivation\n\nThe local behavior of the splitting method can be analyzed using the Baker–Campbell–Hausdorff (BCH) formula. For two non-commuting operators $X$ and $Y$, the formula states:\n$$\n\\exp(X) \\exp(Y) = \\exp\\left(X + Y + \\frac{1}{2}[X, Y] + \\frac{1}{12}[X, [X, Y]] - \\frac{1}{12}[Y, [X, Y]] + \\dots\\right)\n$$\nIn our case, we set $X = \\Delta t A$ and $Y = \\Delta t B$. Substituting these into the BCH formula gives:\n$$\n\\exp(\\Delta t A) \\exp(\\Delta t B) = \\exp\\left(\\Delta t A + \\Delta t B + \\frac{(\\Delta t)^2}{2}[A, B] + O((\\Delta t)^3)\\right)\n$$\nThe exact solution operator over one time step is $\\exp(\\Delta t (A+B))$. The difference between the approximate (split) operator and the exact operator is the source of the splitting error. Let $\\mathcal{E}$ be the error operator.\n$$\n\\mathcal{E} = \\exp(\\Delta t A) \\exp(\\Delta t B) - \\exp(\\Delta t (A+B))\n$$\nBy expanding the exponentials, the leading-order term of this error operator is found to be:\n$$\n\\mathcal{E} = \\frac{(\\Delta t)^2}{2}[A, B] + O((\\Delta t)^3)\n$$\nThe leading-order local splitting error term, when applied to the solution $\\boldsymbol{u}$ at time $t^n$, is therefore $\\frac{(\\Delta t)^2}{2}[A, B]\\boldsymbol{u}(\\boldsymbol{x},t^n)$. Our task is to find the explicit expression for the $k$-th component of this term, which requires computing the commutator $[A, B]\\boldsymbol{u} = (AB - BA)\\boldsymbol{u}$.\n\nLet $\\boldsymbol{u}$ be a sufficiently smooth vector field. We will compute the $k$-th component of $(AB)\\boldsymbol{u}$ and $(BA)\\boldsymbol{u}$ separately. The Einstein summation convention is used for repeated spatial indices.\n\n**Term 1: $(B(A\\boldsymbol{u}))_k$**\nFirst, we apply the advection operator $A$:\n$$\n(A\\boldsymbol{u})_k = -w_j \\partial_j u_k\n$$\nNext, we apply the diffusion operator $B$ to the vector field $A\\boldsymbol{u}$:\n$$\n(B(A\\boldsymbol{u}))_k = \\partial_i\\left(\\nu \\partial_i (A\\boldsymbol{u})_k\\right) = \\partial_i\\left(\\nu \\partial_i (-w_j \\partial_j u_k)\\right) = -\\partial_i\\left(\\nu \\partial_i (w_j \\partial_j u_k)\\right)\n$$\nExpanding using the product rule for derivatives:\n$$\n(B(A\\boldsymbol{u}))_k = -\\partial_i\\left(\\nu \\left[ (\\partial_i w_j)(\\partial_j u_k) + w_j(\\partial_i \\partial_j u_k) \\right]\\right)\n$$\n$$\n= -\\left[ (\\partial_i\\nu)\\left((\\partial_i w_j)(\\partial_j u_k) + w_j(\\partial_i \\partial_j u_k)\\right) + \\nu \\partial_i\\left((\\partial_i w_j)(\\partial_j u_k) + w_j(\\partial_i \\partial_j u_k)\\right) \\right]\n$$\n$$\n= -(\\partial_i\\nu)(\\partial_i w_j)(\\partial_j u_k) - w_j(\\partial_i\\nu)(\\partial_i \\partial_j u_k) - \\nu(\\partial_i\\partial_i w_j)(\\partial_j u_k) - 2\\nu(\\partial_i w_j)(\\partial_i\\partial_j u_k) - \\nu w_j(\\partial_i\\partial_i\\partial_j u_k)\n$$\n\n**Term 2: $(A(B\\boldsymbol{u}))_k$**\nFirst, we apply the diffusion operator $B$:\n$$\n(B\\boldsymbol{u})_k = \\partial_i(\\nu \\partial_i u_k)\n$$\nNext, we apply the advection operator $A$ to the vector field $B\\boldsymbol{u}$:\n$$\n(A(B\\boldsymbol{u}))_k = -w_j \\partial_j (B\\boldsymbol{u})_k = -w_j \\partial_j(\\partial_i(\\nu \\partial_i u_k))\n$$\nExpanding using the product rule:\n$$\n(A(B\\boldsymbol{u}))_k = -w_j \\partial_j\\left( (\\partial_i\\nu)(\\partial_i u_k) + \\nu(\\partial_i\\partial_i u_k) \\right)\n$$\n$$\n= -w_j \\left[ (\\partial_j\\partial_i\\nu)(\\partial_i u_k) + (\\partial_i\\nu)(\\partial_j\\partial_i u_k) + (\\partial_j\\nu)(\\partial_i\\partial_i u_k) + \\nu(\\partial_j\\partial_i\\partial_i u_k) \\right]\n$$\n$$\n= -w_j(\\partial_j\\partial_i\\nu)(\\partial_i u_k) - w_j(\\partial_i\\nu)(\\partial_j\\partial_i u_k) - w_j(\\partial_j\\nu)(\\partial_i\\partial_i u_k) - w_j\\nu(\\partial_j\\partial_i\\partial_i u_k)\n$$\n\n**Commutator: $([A, B]\\boldsymbol{u})_k = (A(B\\boldsymbol{u}))_k - (B(A\\boldsymbol{u}))_k$**\nNow we subtract the expression for $(B(A\\boldsymbol{u}))_k$ from $(A(B\\boldsymbol{u}))_k$. We group terms by the order of derivatives acting on $u_k$.\n\n- **Third-order derivative terms:**\n$$\n-w_j\\nu(\\partial_j\\partial_i\\partial_i u_k) - (-\\nu w_j(\\partial_i\\partial_i\\partial_j u_k)) = -\\nu w_j(\\partial_j\\partial_i\\partial_i u_k) + \\nu w_j(\\partial_i\\partial_i\\partial_j u_k) = 0\n$$\nThese terms cancel due to the commutativity of partial derivatives for smooth functions. This is expected, as the commutator of first- and second-order differential operators should be a second-order operator.\n\n- **Second-order derivative terms:**\n$$\n[-w_j(\\partial_i\\nu)(\\partial_j\\partial_i u_k) - w_j(\\partial_j\\nu)(\\partial_i\\partial_i u_k)] - [-w_j(\\partial_i\\nu)(\\partial_i \\partial_j u_k) - 2\\nu(\\partial_i w_j)(\\partial_i\\partial_j u_k)]\n$$\nThe terms $-w_j(\\partial_i\\nu)(\\partial_j\\partial_i u_k)$ and $-(-w_j(\\partial_i\\nu)(\\partial_i \\partial_j u_k))$ cancel each other. The remaining terms are:\n$$\n-w_j(\\partial_j\\nu)(\\partial_i\\partial_i u_k) + 2\\nu(\\partial_i w_j)(\\partial_i\\partial_j u_k)\n$$\n\n- **First-order derivative terms:**\n$$\n[-w_j(\\partial_j\\partial_i\\nu)(\\partial_i u_k)] - [-(\\partial_i\\nu)(\\partial_i w_j)(\\partial_j u_k) - \\nu(\\partial_i\\partial_i w_j)(\\partial_j u_k)]\n$$\n$$\n= -w_j(\\partial_j\\partial_i\\nu)(\\partial_i u_k) + (\\partial_i\\nu)(\\partial_i w_j)(\\partial_j u_k) + \\nu(\\partial_i\\partial_i w_j)(\\partial_j u_k)\n$$\n\nCombining all remaining terms, the expression for the $k$-th component of the commutator is:\n$$\n([A, B]\\boldsymbol{u})_k = 2\\nu(\\partial_i w_j)\\partial_i\\partial_j u_k - w_j(\\partial_j\\nu)\\partial_l\\partial_l u_k + (\\partial_m(\\nu\\partial_m w_j))\\partial_j u_k - w_j(\\partial_j\\partial_p\\nu)\\partial_p u_k\n$$\nwhere $i, j, l, m, p$ are summation indices ranging from $1$ to $d$. We used $\\partial_i\\partial_i u_k = \\partial_l\\partial_l u_k$ to avoid index collision and recognized that $(\\partial_i\\nu)(\\partial_i w_j) + \\nu(\\partial_i\\partial_i w_j) = \\partial_i(\\nu \\partial_i w_j)$, which we wrote with a new dummy index $m$ as $\\partial_m(\\nu\\partial_m w_j)$. The divergence-free condition $\\partial_j w_j=0$ does not lead to further straightforward simplifications of this expression.\n\nFinally, the leading-order local splitting error term is obtained by multiplying by $\\frac{(\\Delta t)^2}{2}$.\n\nThe $k$-th component of the leading commutator error term at time level $t^n$ is:\n$$\n\\frac{(\\Delta t)^2}{2} \\left( 2\\nu(\\partial_i w_j)\\partial_i\\partial_j u_k - w_j(\\partial_j \\nu)\\partial_l\\partial_l u_k + (\\partial_m(\\nu\\partial_m w_j))\\partial_j u_k - w_j(\\partial_j\\partial_p\\nu)\\partial_p u_k \\right)\n$$\nAll fields and their derivatives are evaluated at $(\\boldsymbol{x}, t^n)$.",
            "answer": "$$\n\\boxed{\\frac{(\\Delta t)^2}{2} \\left( 2\\nu(\\partial_i w_j)\\partial_i\\partial_j u_k - w_j(\\partial_j \\nu)\\partial_l\\partial_l u_k + (\\partial_m(\\nu\\partial_m w_j))\\partial_j u_k - w_j(\\partial_j\\partial_p\\nu)\\partial_p u_k \\right)}\n$$"
        }
    ]
}