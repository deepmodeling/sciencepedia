{
    "hands_on_practices": [
        {
            "introduction": "第一个实践为谱投影方法奠定理论基础。通过在傅里叶空间中进行操作，控制投影的复杂偏微分方程得以简化为代数关系。本练习将指导您推导出投影算子的显式形式，该算子能够滤除速度场中的有散分量，为构建不可压缩流求解器提供最核心的构件。",
            "id": "3987130",
            "problem": "考虑在边长为 $2\\pi$ 的三维周期性立方体上，对于具有周期性边界条件的粘性流体，其不可压缩的纳维-斯托克斯方程。在经典的投影（分数步长）法中，通过减去一个梯度，从给定的中间速度 $\\boldsymbol{v}(\\boldsymbol{x})$ 构建一个无散速度 $\\boldsymbol{w}(\\boldsymbol{x})$：\n$$\n\\boldsymbol{w}(\\boldsymbol{x}) \\;=\\; \\boldsymbol{v}(\\boldsymbol{x}) \\;-\\; \\nabla \\phi(\\boldsymbol{x}),\n$$\n其中标量势 $\\phi(\\boldsymbol{x})$ 的选择应满足 $\\nabla \\cdot \\boldsymbol{w}(\\boldsymbol{x})=0$。令 $\\widehat{\\boldsymbol{v}}(\\boldsymbol{k})$ 表示 $\\boldsymbol{v}(\\boldsymbol{x})$ 在整数波矢 $\\boldsymbol{k}\\in\\mathbb{Z}^{3}$ 处的傅里叶系数，$\\widehat{\\boldsymbol{w}}(\\boldsymbol{k})$ 和 $\\widehat{\\phi}(\\boldsymbol{k})$ 也类似。仅使用以下基础：\n- 不可压缩性要求 $\\nabla \\cdot \\boldsymbol{w}(\\boldsymbol{x})=0$。\n- 分解 $\\boldsymbol{w}=\\boldsymbol{v}-\\nabla\\phi$ 是投影法的定义步骤。\n- 在周期性域上，梯度的傅里叶符号是 $i\\boldsymbol{k}$，拉普拉斯算子的傅里叶符号是 $-|\\boldsymbol{k}|^{2}$。\n\n任务：\n1. 推导投影算子 $\\mathcal{P}$ 的傅里叶空间表示，该算子将任意矢量傅里叶模态 $\\widehat{\\boldsymbol{v}}(\\boldsymbol{k})$ 映射到其无散对应部分 $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k})$。\n2. 对于特定模态 $\\boldsymbol{k}=(1,2,2)$ 和给定的中间傅里叶系数 $\\widehat{\\boldsymbol{v}}(\\boldsymbol{k})=(3,\\,-1,\\,4)$，计算投影后的模态 $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k})$。\n\n将最终答案表示为包含 $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k})$ 三个分量的单个行向量。不需要四舍五入。",
            "solution": "该问题是有效的，因为它科学地基于计算流体动力学的原理，特别是针对不可压缩流的投影法。该问题是适定的、客观的，并包含了推导投影算子和计算所需量的所有必要信息。\n\n解答过程按任务要求分为两部分。首先，我们推导投影算子的一般傅里叶空间表示。其次，我们将此算子应用于所提供的特定中间速度模态。\n\n**第一部分：傅里叶空间投影算子的推导**\n\n投影法将任意矢量场 $\\boldsymbol{v}(\\boldsymbol{x})$ 分解为一个无散部分 $\\boldsymbol{w}(\\boldsymbol{x})$ 和一个梯度部分 $\\nabla\\phi(\\boldsymbol{x})$。该分解的控制方程如下：\n$$\n\\boldsymbol{w}(\\boldsymbol{x}) = \\boldsymbol{v}(\\boldsymbol{x}) - \\nabla \\phi(\\boldsymbol{x})\n$$\n得到的场 $\\boldsymbol{w}(\\boldsymbol{x})$ 要求是无散的，这施加了以下约束：\n$$\n\\nabla \\cdot \\boldsymbol{w}(\\boldsymbol{x}) = 0\n$$\n为了找到标量势 $\\phi(\\boldsymbol{x})$ 的方程，我们对第一个方程取散度：\n$$\n\\nabla \\cdot \\boldsymbol{w}(\\boldsymbol{x}) = \\nabla \\cdot \\boldsymbol{v}(\\boldsymbol{x}) - \\nabla \\cdot (\\nabla \\phi(\\boldsymbol{x}))\n$$\n使用矢量微积分恒等式 $\\nabla \\cdot (\\nabla \\phi) = \\nabla^2 \\phi$，其中 $\\nabla^2$ 是拉普拉斯算子，我们得到：\n$$\n\\nabla \\cdot \\boldsymbol{w}(\\boldsymbol{x}) = \\nabla \\cdot \\boldsymbol{v}(\\boldsymbol{x}) - \\nabla^2 \\phi(\\boldsymbol{x})\n$$\n应用不可压缩性约束 $\\nabla \\cdot \\boldsymbol{w}(\\boldsymbol{x}) = 0$，我们得到关于 $\\phi(\\boldsymbol{x})$ 的泊松方程：\n$$\n\\nabla^2 \\phi(\\boldsymbol{x}) = \\nabla \\cdot \\boldsymbol{v}(\\boldsymbol{x})\n$$\n现在我们将这些方程变换到傅里叶空间。令 $\\widehat{f}(\\boldsymbol{k}) = \\mathcal{F}(f(\\boldsymbol{x}))$ 表示函数 $f(\\boldsymbol{x})$ 在波矢 $\\boldsymbol{k} \\in \\mathbb{Z}^3$ 处的傅里叶系数。使用所提供的梯度（$\\nabla \\to i\\boldsymbol{k}$）、散度（$\\nabla \\cdot \\to i\\boldsymbol{k}\\cdot$）和拉普拉斯算子（$\\nabla^2 \\to -|\\boldsymbol{k}|^2$）的傅里叶符号，方程变为：\n$$\n\\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = \\widehat{\\boldsymbol{v}}(\\boldsymbol{k}) - i\\boldsymbol{k}\\widehat{\\phi}(\\boldsymbol{k})\n$$\n势的泊松方程变为：\n$$\n-|\\boldsymbol{k}|^2 \\widehat{\\phi}(\\boldsymbol{k}) = i\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{v}}(\\boldsymbol{k})\n$$\n对于任意非零波矢 $\\boldsymbol{k} \\neq \\boldsymbol{0}$，我们可以解出 $\\widehat{\\phi}(\\boldsymbol{k})$：\n$$\n\\widehat{\\phi}(\\boldsymbol{k}) = -\\frac{i\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{v}}(\\boldsymbol{k})}{|\\boldsymbol{k}|^2}\n$$\n$\\boldsymbol{k}=\\boldsymbol{0}$ 的情况对应于平均流，它自然是无散的，因此不需要投影。对于 $\\boldsymbol{k} \\neq \\boldsymbol{0}$，我们将 $\\widehat{\\phi}(\\boldsymbol{k})$ 的表达式代回到 $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k})$ 的方程中：\n$$\n\\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = \\widehat{\\boldsymbol{v}}(\\boldsymbol{k}) - i\\boldsymbol{k} \\left( -\\frac{i\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{v}}(\\boldsymbol{k})}{|\\boldsymbol{k}|^2} \\right)\n$$\n化简表达式，注意到 $i \\times (-i) = -i^2 = -(-1) = 1$：\n$$\n\\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = \\widehat{\\boldsymbol{v}}(\\boldsymbol{k}) - \\frac{\\boldsymbol{k}(\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{v}}(\\boldsymbol{k}))}{|\\boldsymbol{k}|^2}\n$$\n这个方程定义了投影算子 $\\mathcal{P}$ 在傅里叶空间中的作用，使得 $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = \\mathcal{P}(\\boldsymbol{k})\\widehat{\\boldsymbol{v}}(\\boldsymbol{k})$。该算子可以使用单位矩阵 $\\boldsymbol{I}$ 和外积（或张量积）$\\boldsymbol{k} \\otimes \\boldsymbol{k}$ 以矩阵形式写出：\n$$\n\\mathcal{P}(\\boldsymbol{k}) = \\boldsymbol{I} - \\frac{\\boldsymbol{k} \\otimes \\boldsymbol{k}}{|\\boldsymbol{k}|^2}\n$$\n该算子将任意向量 $\\widehat{\\boldsymbol{v}}(\\boldsymbol{k})$ 投影到与波矢 $\\boldsymbol{k}$ 正交的平面上，从而移除了其纵向分量，并确保结果 $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k})$ 是无散的（$i\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{w}}(\\boldsymbol{k})=0$）。\n\n**第二部分：特定模态的计算**\n\n我们已知特定的波矢 $\\boldsymbol{k}$ 和中间速度傅里叶系数 $\\widehat{\\boldsymbol{v}}(\\boldsymbol{k})$：\n$$\n\\boldsymbol{k} = (1, 2, 2)\n$$\n$$\n\\widehat{\\boldsymbol{v}}(\\boldsymbol{k}) = (3, -1, 4)\n$$\n首先，我们计算波矢的模的平方 $|\\boldsymbol{k}|^2$：\n$$\n|\\boldsymbol{k}|^2 = k_1^2 + k_2^2 + k_3^2 = 1^2 + 2^2 + 2^2 = 1 + 4 + 4 = 9\n$$\n接下来，我们计算点积 $\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{v}}(\\boldsymbol{k})$：\n$$\n\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{v}}(\\boldsymbol{k}) = k_1 \\widehat{v}_1 + k_2 \\widehat{v}_2 + k_3 \\widehat{v}_3 = (1)(3) + (2)(-1) + (2)(4) = 3 - 2 + 8 = 9\n$$\n现在我们使用推导出的投影模态 $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k})$ 的公式：\n$$\n\\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = \\widehat{\\boldsymbol{v}}(\\boldsymbol{k}) - \\frac{\\boldsymbol{k} (\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{v}}(\\boldsymbol{k}))}{|\\boldsymbol{k}|^2}\n$$\n代入计算出的值：\n$$\n\\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = (3, -1, 4) - \\frac{(1, 2, 2) (9)}{9}\n$$\n$$\n\\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = (3, -1, 4) - (1, 2, 2)\n$$\n按分量进行向量减法：\n$$\n\\widehat{w}_1(\\boldsymbol{k}) = 3 - 1 = 2\n$$\n$$\n\\widehat{w}_2(\\boldsymbol{k}) = -1 - 2 = -3\n$$\n$$\n\\widehat{w}_3(\\boldsymbol{k}) = 4 - 2 = 2\n$$\n因此，投影后的傅里叶模态为 $\\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = (2, -3, 2)$。作为一个验证步骤，我们可以检查这个结果向量是否确实与 $\\boldsymbol{k}$ 正交：\n$$\n\\boldsymbol{k} \\cdot \\widehat{\\boldsymbol{w}}(\\boldsymbol{k}) = (1)(2) + (2)(-3) + (2)(2) = 2 - 6 + 4 = 0\n$$\n由于点积为零，所得模态是螺线管性的（在傅里叶空间中无散），符合要求。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2  -3  2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "从理论走向实践，本练习专注于使用快速傅里叶变换（FFT）来实现一个质量守恒的投影步。您将编写代码，对任意的中间速度场应用傅里叶空间投影算子，以强制执行离散的不可压缩约束。这项动手任务旨在演示如何在周期性网格上将质量守恒精确到机器精度，这是稳健CFD程序的一个关键特征。",
            "id": "4082126",
            "problem": "要求您在用于不可压缩复杂流体的分步法中设计并实现一个质量守恒的投影步，该投影步在新时间层上强制执行离散质量守恒。从质量守恒和不可压缩性定义出发，构建一个投影，将二维周期性域上的中间速度场映射到一个无散场。该域为具有周期性边界条件的单位环面，即 $[0,1]^2$，在一个均匀网格上进行离散化，该网格在 $x$ 方向有 $N_x$ 个点，在 $y$ 方向有 $N_y$ 个点。在显式非压力更新后，$n$ 时间层的中间速度场表示为 $\\mathbf{u}^\\star(x,y) = (u^\\star(x,y), v^\\star(x,y))$，目标是生成 $\\mathbf{u}^{n+1}(x,y)$，使其在离散层面上满足 $\\nabla \\cdot \\mathbf{u}^{n+1}(x,y) = 0$ 至机器精度。\n\n您的构建必须基于一对一致的离散梯度和散度算子，这些算子在周期性网格上是伴随的，以便投影步能够精确地（至浮点舍入误差）强制执行离散连续性方程。此步骤必须在概念上求解一个标量势的离散泊松方程，该标量势用于校正中间速度并保证得到一个无散的结果。其核心科学基础必须始于质量守恒定律和不可压缩性定义。问题陈述中不允许使用任何捷径公式；请在您的解法中推导出所需内容。\n\n以一种在周期性单位正方形上可复现且数值稳健的方式实现您的投影。所有计算都应是无量纲的。如果存在角度，则因所用函数是标准数学意义上的三角函数，故隐式地以弧度解释；但是，您无需在输出中报告任何角度。\n\n您的程序必须：\n- 在给定的网格上构建测试速度场 $\\mathbf{u}^\\star(x,y)$。\n- 应用您的质量守恒投影以获得 $\\mathbf{u}^{n+1}(x,y)$。\n- 使用构成您投影机制基础的相同离散算子计算 $\\mathbf{u}^{n+1}(x,y)$ 的离散散度。\n- 对每个测试案例，报告整个网格上离散散度的最大绝对值，作为一个浮点数。\n\n测试套件：\n- 案例 $1$：$N_x = 32$，$N_y = 32$。对于整数 $i \\in \\{0,\\dots,N_x-1\\}$ 和 $j \\in \\{0,\\dots,N_y-1\\}$，定义 $x_i = i/N_x$，$y_j = j/N_y$。设标量场 $\\psi(x,y) = \\sin(2\\pi x)\\cos(2\\pi y)$ 和 $\\phi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$。定义一个势流梯度分量 $\\mathbf{u}_{\\mathrm{grad}} = \\nabla \\psi$ 和一个无散旋转分量 $\\mathbf{u}_{\\mathrm{vort}} = (-\\partial_y \\phi, \\partial_x \\phi)$。设置 $\\mathbf{u}^\\star = \\mathbf{u}_{\\mathrm{grad}} + \\mathbf{u}_{\\mathrm{vort}} + 0.1\\,\\boldsymbol{\\eta}$，其中 $\\boldsymbol{\\eta}$ 是一个确定性伪随机场，从标准正态分布中抽取，种子设置为 $0$，并且每个分量的形状均为 $(N_x,N_y)$。\n- 案例 $2$：$N_x = 33$，$N_y = 17$。设 $\\mathbf{u}^\\star = \\boldsymbol{\\eta} + \\mathbf{c}$，其中 $\\boldsymbol{\\eta}$ 与上述相同但种子设置为 $0$，$\\mathbf{c} = (1.5, -0.75)$ 是一个恒定均匀速度矢量。\n- 案例 $3$：$N_x = 64$，$N_y = 64$。设 $\\psi(x,y) = \\cos(4\\pi x)\\sin(2\\pi y)$ 并设置 $\\mathbf{u}^\\star = \\nabla \\psi$（一个纯梯度场）。\n- 案例 $4$：$N_x = 8$，$N_y = 8$。设 $\\phi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$ 并设置 $\\mathbf{u}^\\star = 3\\,(-\\partial_y \\phi, \\partial_x \\phi)$（一个按比例缩放的无散场）。\n- 案例 $5$：$N_x = 16$，$N_y = 24$。设 $\\mathbf{u}^\\star = \\boldsymbol{\\eta}$，种子设置为 $42$，其分量从标准正态分布中抽取。\n\n定义和要求：\n- 使用与周期性边界条件一致的离散傅里叶变换来实现离散梯度、散度和泊松方程的求解。使用快速傅里叶变换（FFT）作为变换的数值机制。\n- 离散散度必须使用与投影构建中所用波数相同的谱方法计算，以确保伴随性和精确抵消（至浮点误差）。\n- 对每个案例，计算 $\\mathbf{u}^{n+1}$ 的最大绝对离散散度，并将其作为浮点值返回。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，$[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4,\\mathrm{result}_5]$）。每个结果必须是一个浮点数。",
            "solution": "该问题要求在一个二维周期性域上为不可压缩流体设计并实现一个质量守恒的投影步。该解法必须从第一性原理推导得出，特别是质量守恒定律，并使用基于快速傅里叶变换（FFT）的谱方法实现。\n\n控制流体运动的基本原理是质量守恒，由连续性方程表示：\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\mathbf{u}) = 0\n$$\n其中 $\\rho$ 是流体密度，$\\mathbf{u}$ 是速度场。对于被视为不可压缩的复杂流体，密度 $\\rho$ 假定在空间和时间上都是恒定的。因此，其偏导数为零，即 $\\frac{\\partial \\rho}{\\partial t} = 0$ 和 $\\nabla \\rho = \\mathbf{0}$。连续性方程简化为：\n$$\n\\rho (\\nabla \\cdot \\mathbf{u}) = 0\n$$\n由于 $\\rho > 0$，这便得到了不可压缩性约束，这是对速度场的一个运动学条件：\n$$\n\\nabla \\cdot \\mathbf{u} = 0\n$$\n该方程表明，不可压缩流的速度场必须是无散的。\n\n分步法，或称投影法，常用于求解不可压缩流的随时间变化的纳维-斯托克斯方程。它们将速度和压力的计算解耦。在一个典型的两步格式中，首先通过在没有压力梯度项的情况下推进动量方程，来计算时间层 $n+1$ 的一个中间速度场，表示为 $\\mathbf{u}^\\star$。这个场 $\\mathbf{u}^\\star$ 通常不满足不可压缩性约束。\n\n第二步，即投影步，校正 $\\mathbf{u}^\\star$ 以产生一个离散无散的速度场 $\\mathbf{u}^{n+1}$。这是通过引入压力梯度的效应来实现的。校正由下式给出：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^\\star}{\\Delta t} = -\\nabla p^{n+1}\n$$\n其中 $p^{n+1}$ 与压力相关，$\\Delta t$ 是时间步长。对于我们的无量纲问题，我们可以将 $\\Delta t$ 吸收到一个标量势 $\\Phi$ 中，使得更新为：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^\\star - \\nabla \\Phi\n$$\n这是亥姆霍兹-霍奇分解的一个陈述，该分解指出任何向量场 $\\mathbf{u}^\\star$ 都可以唯一地分解为一个无散分量（$\\mathbf{u}^{n+1}$）和一个无旋（梯度）分量（$\\nabla \\Phi$）。\n\n为了找到势 $\\Phi$，我们对最终速度场施加不可压缩性约束，$\\nabla \\cdot \\mathbf{u}^{n+1} = 0$。对校正方程应用散度算子，我们得到：\n$$\n\\nabla \\cdot \\mathbf{u}^{n+1} = \\nabla \\cdot \\mathbf{u}^\\star - \\nabla \\cdot (\\nabla \\Phi)\n$$\n设置 $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$ 会得到一个关于标量势 $\\Phi$ 的泊松方程：\n$$\n\\nabla^2 \\Phi = \\nabla \\cdot \\mathbf{u}^\\star\n$$\n求解这个关于 $\\Phi$ 的方程，我们就可以计算梯度 $\\nabla \\Phi$，并随后得到最终的无散速度场 $\\mathbf{u}^{n+1}$。\n\n对于指定的周期性域 $[0,1]^2$，使用离散傅里叶变换（DFT）的谱方法因其高精度和 FFT 算法的效率而特别适用。在傅里叶空间中，微分算子变为代数乘法算子。网格上的函数 $f(x,y)$ 被变换为其傅里叶系数 $\\hat{f}(k_x, k_y)$，其中 $k_x$ 和 $k_y$ 是波数。微分算子的变换如下：\n$$\n\\mathcal{F}\\left(\\frac{\\partial f}{\\partial x}\\right) = i k_x \\hat{f} \\quad \\text{和} \\quad \\mathcal{F}\\left(\\frac{\\partial f}{\\partial y}\\right) = i k_y \\hat{f}\n$$\n其中 $\\mathcal{F}$ 表示傅里叶变换。\n\n对于尺寸为 $L_x=1$，$L_y=1$ 且有 $N_x$ 和 $N_y$ 个点的域，离散波数由 $k_x = 2\\pi m$ 和 $k_y = 2\\pi n$ 给出，其中 $m$ 和 $n$ 是整数模。这些波数使用 `scipy.fft.fftfreq` 计算。具体来说，$k_x = 2\\pi \\times \\text{fftfreq}(N_x, 1/N_x)$ 和 $k_y = 2\\pi \\times \\text{fftfreq}(N_y, 1/N_y)$。\n\n对泊松方程 $\\nabla^2 \\Phi = \\nabla \\cdot \\mathbf{u}^\\star$ 应用傅里叶变换：\n$$\n\\mathcal{F}(\\nabla^2 \\Phi) = \\mathcal{F}(\\nabla \\cdot \\mathbf{u}^\\star)\n$$\n左侧变为：\n$$\n\\mathcal{F}(\\nabla^2 \\Phi) = \\mathcal{F}\\left(\\frac{\\partial^2 \\Phi}{\\partial x^2} + \\frac{\\partial^2 \\Phi}{\\partial y^2}\\right) = ((ik_x)^2 + (ik_y)^2)\\hat{\\Phi} = -(k_x^2 + k_y^2)\\hat{\\Phi}\n$$\n右侧，即 $\\mathbf{u}^\\star = (u^\\star, v^\\star)$ 的散度，变为：\n$$\n\\mathcal{F}(\\nabla \\cdot \\mathbf{u}^\\star) = \\mathcal{F}\\left(\\frac{\\partial u^\\star}{\\partial x} + \\frac{\\partial v^\\star}{\\partial y}\\right) = i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star\n$$\n将这些结合起来，得到傅里叶空间中关于 $\\hat{\\Phi}$ 的代数方程：\n$$\n-(k_x^2 + k_y^2)\\hat{\\Phi} = i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star\n$$\n我们可以解出 $\\hat{\\Phi}$：\n$$\n\\hat{\\Phi}(k_x, k_y) = - \\frac{i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star}{k_x^2 + k_y^2}\n$$\n在零波数模式 $(k_x, k_y) = (0,0)$ 处会出现一个特殊情况，此时分母 $k_x^2+k_y^2$ 为零。该模式对应于场的平均值。对于此模式，分子也为零，$i(0)\\hat{u}^\\star_{0,0} + i(0)\\hat{v}^\\star_{0,0} = 0$。这种 $0/0$ 的不确定性反映了势 $\\Phi$ 的确定只差一个任意常数。我们可以通过设置 $\\hat{\\Phi}(0,0) = 0$ 来解决这个问题，这对应于选择空间平均值为零的唯一势。\n\n一旦知道了 $\\hat{\\Phi}$，我们就可以找到投影后速度 $\\mathbf{u}^{n+1} = \\mathbf{u}^\\star - \\nabla \\Phi$ 的傅里叶变换：\n$$\n\\hat{u}^{n+1} = \\hat{u}^\\star - i k_x \\hat{\\Phi}\n$$\n$$\n\\hat{v}^{n+1} = \\hat{v}^\\star - i k_y \\hat{\\Phi}\n$$\n最后，通过应用傅里叶逆变换 $\\mathcal{F}^{-1}$ 恢复实空间速度场 $\\mathbf{u}^{n+1}$。\n\n为了验证结果，我们使用相同的谱算子计算 $\\mathbf{u}^{n+1}$ 的离散散度。在傅里叶空间中，这表示为：\n$$\n\\widehat{\\nabla \\cdot \\mathbf{u}^{n+1}} = i k_x \\hat{u}^{n+1} + i k_y \\hat{v}^{n+1}\n$$\n代入 $\\hat{u}^{n+1}$ 和 $\\hat{v}^{n+1}$ 的表达式：\n$$\n\\widehat{\\nabla \\cdot \\mathbf{u}^{n+1}} = i k_x (\\hat{u}^\\star - i k_x \\hat{\\Phi}) + i k_y (\\hat{v}^\\star - i k_y \\hat{\\Phi})\n= (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star) - ( (ik_x)^2 + (ik_y)^2 ) \\hat{\\Phi}\n= (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star) + (k_x^2 + k_y^2) \\hat{\\Phi}\n$$\n代入 $\\hat{\\Phi}$ 的解：\n$$\n= (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star) + (k_x^2 + k_y^2) \\left( - \\frac{i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star}{k_x^2 + k_y^2} \\right) = 0\n$$\n这对所有 $(k_x, k_y) \\neq (0,0)$ 成立。对于 $(k_x, k_y)=(0,0)$，所有项都为零。因此，投影场的散度在傅里叶空间中解析上为零。其逆变换将为零，误差仅限于浮点舍入误差。该场的最大绝对值是所需的输出。",
            "answer": "```python\nimport numpy as np\nimport scipy.fft\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        {'Nx': 32, 'Ny': 32, 'case_type': 'grad_vort_noise', 'seed': 0},\n        {'Nx': 33, 'Ny': 17, 'case_type': 'noise_const', 'seed': 0},\n        {'Nx': 64, 'Ny': 64, 'case_type': 'pure_grad', 'seed': None},\n        {'Nx': 8, 'Ny': 8, 'case_type': 'pure_vort', 'seed': None},\n        {'Nx': 16, 'Ny': 24, 'case_type': 'pure_noise', 'seed': 42},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_single_case(params)\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.16e}' for r in results)}]\")\n\ndef _solve_single_case(params):\n    \"\"\"\n    Solves a single test case for the projection problem.\n    \"\"\"\n    Nx = params['Nx']\n    Ny = params['Ny']\n    case_type = params['case_type']\n    seed = params['seed']\n    \n    # 1. Construct the grid\n    x = np.arange(Nx) / Nx\n    y = np.arange(Ny) / Ny\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Construct the intermediate velocity field u_star\n    pi = np.pi\n    u_star, v_star = None, None\n    rng = np.random.default_rng(seed) if seed is not None else None\n\n    if case_type == 'grad_vort_noise':\n        # Case 1: Grad + Vort + Noise\n        psi = np.sin(2 * pi * xx) * np.cos(2 * pi * yy)\n        dpsi_dx = 2 * pi * np.cos(2 * pi * xx) * np.cos(2 * pi * yy)\n        dpsi_dy = -2 * pi * np.sin(2 * pi * xx) * np.sin(2 * pi * yy)\n\n        phi_vort = np.sin(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dx = 2 * pi * np.cos(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dy = 2 * pi * np.sin(2 * pi * xx) * np.cos(2 * pi * yy)\n        \n        eta_x = rng.standard_normal(size=(Nx, Ny))\n        eta_y = rng.standard_normal(size=(Nx, Ny))\n\n        u_star = dpsi_dx - dphi_dy + 0.1 * eta_x\n        v_star = dpsi_dy + dphi_dx + 0.1 * eta_y\n\n    elif case_type == 'noise_const':\n        # Case 2: Noise + Constant\n        c = (1.5, -0.75)\n        eta_x = rng.standard_normal(size=(Nx, Ny))\n        eta_y = rng.standard_normal(size=(Nx, Ny))\n        u_star = eta_x + c[0]\n        v_star = eta_y + c[1]\n\n    elif case_type == 'pure_grad':\n        # Case 3: Pure gradient field\n        psi = np.cos(4 * pi * xx) * np.sin(2 * pi * yy)\n        u_star = -4 * pi * np.sin(4 * pi * xx) * np.sin(2 * pi * yy)\n        v_star = 2 * pi * np.cos(4 * pi * xx) * np.cos(2 * pi * yy)\n\n    elif case_type == 'pure_vort':\n        # Case 4: Purely rotational (divergence-free) field\n        phi_vort = np.sin(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dx = 2 * pi * np.cos(2 * pi * xx) * np.sin(2 * pi * yy)\n        dphi_dy = 2 * pi * np.sin(2 * pi * xx) * np.cos(2 * pi * yy)\n        u_star = 3.0 * (-dphi_dy)\n        v_star = 3.0 * (dphi_dx)\n\n    elif case_type == 'pure_noise':\n        # Case 5: Pure noise\n        u_star = rng.standard_normal(size=(Nx, Ny))\n        v_star = rng.standard_normal(size=(Nx, Ny))\n    \n    # 3. Perform the projection\n    u_proj, v_proj = _project_velocity(u_star, v_star, Nx, Ny)\n\n    # 4. Compute the divergence of the projected field\n    divergence_field = _calculate_divergence(u_proj, v_proj, Nx, Ny)\n\n    # 5. Return the maximum absolute divergence\n    return np.max(np.abs(divergence_field))\n\ndef _project_velocity(u, v, Nx, Ny):\n    \"\"\"\n    Projects a velocity field (u, v) onto its divergence-free part.\n    \"\"\"\n    # Create wavenumber grids\n    kx_1d = 2 * np.pi * scipy.fft.fftfreq(Nx, d=1.0/Nx)\n    ky_1d = 2 * np.pi * scipy.fft.fftfreq(Ny, d=1.0/Ny)\n    kx, ky = np.meshgrid(kx_1d, ky_1d, indexing='ij')\n\n    # FFT of the velocity field\n    u_hat = scipy.fft.fft2(u)\n    v_hat = scipy.fft.fft2(v)\n\n    # Compute FFT of divergence of (u, v)\n    div_u_hat = 1j * kx * u_hat + 1j * ky * v_hat\n\n    # Solve Poisson equation for the potential phi in Fourier space\n    k_squared = kx**2 + ky**2\n    # Handle the k=0 mode to avoid division by zero\n    k_squared[0, 0] = 1.0  # Denominator is non-zero\n    \n    phi_hat = -div_u_hat / k_squared\n    # The numerator at k=0 is already zero, so this enforces phi_hat(0,0)=0\n\n    # Correct the velocity field in Fourier space\n    u_proj_hat = u_hat - 1j * kx * phi_hat\n    v_proj_hat = v_hat - 1j * ky * phi_hat\n\n    # Inverse FFT to get the projected velocity field in real space\n    u_proj = scipy.fft.ifft2(u_proj_hat).real\n    v_proj = scipy.fft.ifft2(v_proj_hat).real\n    \n    return u_proj, v_proj\n\ndef _calculate_divergence(u, v, Nx, Ny):\n    \"\"\"\n    Computes the divergence of a velocity field (u, v) using spectral methods.\n    \"\"\"\n    # Create wavenumber grids\n    kx_1d = 2 * np.pi * scipy.fft.fftfreq(Nx, d=1.0/Nx)\n    ky_1d = 2 * np.pi * scipy.fft.fftfreq(Ny, d=1.0/Ny)\n    kx, ky = np.meshgrid(kx_1d, ky_1d, indexing='ij')\n\n    # FFT of the velocity field\n    u_hat = scipy.fft.fft2(u)\n    v_hat = scipy.fft.fft2(v)\n\n    # Compute divergence in Fourier space\n    div_u_hat = 1j * kx * u_hat + 1j * ky * v_hat\n\n    # Inverse FFT to get divergence in real space\n    divergence = scipy.fft.ifft2(div_u_hat).real\n    \n    return divergence\n\nsolve()\n```"
        },
        {
            "introduction": "分数步法通过算子分裂来提高计算效率，但此过程会引入“分裂误差”。这项高阶练习使用Baker-Campbell-Hausdorff (BCH) 公式来深入探究此误差的来源。分裂误差的主导项表现为对流和扩散算子的对易子，推导出该误差项对于理解格式的理论精度及其在不同流动状态下的行为至关重要。",
            "id": "3987160",
            "problem": "考虑用于计算流体动力学 (CFD) 中投影法和分数步长法的不可压缩动量方程，其中包含一个显式平流子步和一个隐式扩散子步。令 $\\boldsymbol{w}(\\boldsymbol{x})$ 为一个光滑、无散的平流速度场，令 $\\nu(\\boldsymbol{x})$ 为一个光滑、空间变化的运动粘度。定义作用于矢量场 $\\boldsymbol{u}(\\boldsymbol{x},t)$ 的线性平流和扩散算子如下：\n$$\nA \\boldsymbol{u} \\equiv - (\\boldsymbol{w} \\cdot \\nabla)\\,\\boldsymbol{u}, \n\\qquad \nB \\boldsymbol{u} \\equiv \\nabla \\cdot \\left( \\nu \\nabla \\boldsymbol{u} \\right),\n$$\n其中 $B$ 逐分量作用，即 $(B \\boldsymbol{u})_{k} = \\partial_{i}\\!\\left(\\nu\\,\\partial_{i} u_{k}\\right)$，这里对重复的空间指标 $i$ 和 $j$（从 $1$ 到 $d$，$d \\in \\{2,3\\}$）使用爱因斯坦求和约定。考虑在大小为 $\\Delta t > 0$ 的单个时间步长上的李分裂 (Lie splitting)，其定义为先应用扩散，然后应用平流，因此单步传播子为 $\\exp(\\Delta t A)\\exp(\\Delta t B)$，作为对由组合算子生成的精确演化 $\\exp(\\Delta t (A+B))$ 的近似。\n\n使用 Baker–Campbell–Hausdorff (BCH) 展开，推导领头阶局部劈裂误差算子，并将其显式地表示为一个作用于 $\\boldsymbol{u}(\\boldsymbol{x},t^{n})$ 的对易子，使用指标记法，并用 $\\boldsymbol{w}(\\boldsymbol{x})$、$\\nu(\\boldsymbol{x})$ 以及 $\\boldsymbol{u}$ 的最高三阶空间导数来表示。你的最终答案必须是对应于李组合 $\\exp(\\Delta t A)\\exp(\\Delta t B)$ 的、在时间层 $t^{n}$ 的领头对易子误差项第 $k$ 个分量的单一闭式解析表达式，并使用对空间指标的爱因斯坦求和约定写出。不要假设 $\\nu$ 或 $\\boldsymbol{w}$ 为常数来进行简化。不需要进行数值计算。最终答案表示时无需单位。",
            "solution": "用户要求推导应用于平流-扩散方程的李分裂格式的领头阶局部劈裂误差。\n\n### 第一步：问题验证\n\n**1.1. 提取的已知条件：**\n- **平流速度：** 一个光滑、无散的矢量场 $\\boldsymbol{w}(\\boldsymbol{x})$，使用爱因斯坦求和约定意味着 $\\partial_j w_j = 0$。\n- **运动粘度：** 一个光滑、空间变化的标量场 $\\nu(\\boldsymbol{x})$。\n- **平流算子：** $A \\boldsymbol{u} \\equiv - (\\boldsymbol{w} \\cdot \\nabla)\\,\\boldsymbol{u}$。用指标记法，对第 $k$ 个分量有 $(A \\boldsymbol{u})_{k} = -w_j \\partial_j u_k$。\n- **扩散算子：** $B \\boldsymbol{u} \\equiv \\nabla \\cdot \\left( \\nu \\nabla \\boldsymbol{u} \\right)$。用指标记法，逐分量作用，$(B \\boldsymbol{u})_{k} = \\partial_{i}\\!\\left(\\nu\\,\\partial_{i} u_{k}\\right)$。\n- **分裂格式：** 在时间步长 $\\Delta t > 0$ 上的李分裂，先应用扩散，然后应用平流。单步传播子为 $\\exp(\\Delta t A)\\exp(\\Delta t B)$。\n- **精确演化算子：** $\\exp(\\Delta t (A+B))$。\n- **目标：** 推导领头阶局部劈裂误差算子，表示为作用于矢量场 $\\boldsymbol{u}(\\boldsymbol{x},t^{n})$ 的对易子，并给出其第 $k$ 个分量的显式表达式。\n\n**1.2. 验证：**\n- **科学基础：** 该问题牢固地植根于计算流体动力学和数值分析领域。平流-扩散方程、算子分裂法（特别是李分裂）以及使用 Baker–Campbell–Hausdorff 公式分析误差都是标准且成熟的概念。\n- **适定性：** 该问题是适定的。它要求基于明确定义的算子和标准的分析技术推导一个特定的数学表达式。可以获得唯一的解析解。\n- **客观性：** 该问题使用精确、客观的数学语言陈述。\n- **缺陷分析：** 问题陈述在科学上是合理的，可形式化的，内部一致的，并包含所有必要的信息。它没有违反任何无效标准。\n\n**1.3. 结论：**\n该问题有效。\n\n### 第二步：求解推导\n\n分裂方法的局部行为可以使用 Baker–Campbell–Hausdorff (BCH) 公式进行分析。对于两个不对易的算子 $X$ 和 $Y$，该公式表述为：\n$$\n\\exp(X) \\exp(Y) = \\exp\\left(X + Y + \\frac{1}{2}[X, Y] + \\frac{1}{12}[X, [X, Y]] - \\frac{1}{12}[Y, [X, Y]] + \\dots\\right)\n$$\n在我们的情况下，我们设 $X = \\Delta t A$ 和 $Y = \\Delta t B$。将它们代入 BCH 公式得到：\n$$\n\\exp(\\Delta t A) \\exp(\\Delta t B) = \\exp\\left(\\Delta t A + \\Delta t B + \\frac{(\\Delta t)^2}{2}[A, B] + O((\\Delta t)^3)\\right)\n$$\n一个时间步长上的精确解算子是 $\\exp(\\Delta t (A+B))$。近似（分裂）算子与精确算子之间的差是分裂误差的来源。设 $\\mathcal{E}$ 为误差算子。\n$$\n\\mathcal{E} = \\exp(\\Delta t A) \\exp(\\Delta t B) - \\exp(\\Delta t (A+B))\n$$\n通过展开指数，该误差算子的领头阶项被发现是：\n$$\n\\mathcal{E} = \\frac{(\\Delta t)^2}{2}[A, B] + O((\\Delta t)^3)\n$$\n因此，当应用于时间 $t^n$ 的解 $\\boldsymbol{u}$ 时，领头阶局部劈裂误差项为 $\\frac{(\\Delta t)^2}{2}[A, B]\\boldsymbol{u}(\\boldsymbol{x},t^n)$。我们的任务是找到该项第 $k$ 个分量的显式表达式，这需要计算对易子 $[A, B]\\boldsymbol{u} = (AB - BA)\\boldsymbol{u}$。\n\n设 $\\boldsymbol{u}$ 为一个足够光滑的矢量场。我们将分别计算 $(AB)\\boldsymbol{u}$ 和 $(BA)\\boldsymbol{u}$ 的第 $k$ 个分量。对重复的空间指标使用爱因斯坦求和约定。\n\n**第一项：$(B(A\\boldsymbol{u}))_k$**\n首先，我们应用平流算子 $A$：\n$$\n(A\\boldsymbol{u})_k = -w_j \\partial_j u_k\n$$\n接下来，我们将扩散算子 $B$ 应用于矢量场 $A\\boldsymbol{u}$：\n$$\n(B(A\\boldsymbol{u}))_k = \\partial_i\\left(\\nu \\partial_i (A\\boldsymbol{u})_k\\right) = \\partial_i\\left(\\nu \\partial_i (-w_j \\partial_j u_k)\\right) = -\\partial_i\\left(\\nu \\partial_i (w_j \\partial_j u_k)\\right)\n$$\n使用导数的乘法法则展开：\n$$\n(B(A\\boldsymbol{u}))_k = -\\partial_i\\left(\\nu \\left[ (\\partial_i w_j)(\\partial_j u_k) + w_j(\\partial_i \\partial_j u_k) \\right]\\right)\n$$\n$$\n= -\\left[ (\\partial_i\\nu)\\left((\\partial_i w_j)(\\partial_j u_k) + w_j(\\partial_i \\partial_j u_k)\\right) + \\nu \\partial_i\\left((\\partial_i w_j)(\\partial_j u_k) + w_j(\\partial_i \\partial_j u_k)\\right) \\right]\n$$\n$$\n= -(\\partial_i\\nu)(\\partial_i w_j)(\\partial_j u_k) - w_j(\\partial_i\\nu)(\\partial_i \\partial_j u_k) - \\nu(\\partial_i\\partial_i w_j)(\\partial_j u_k) - 2\\nu(\\partial_i w_j)(\\partial_i\\partial_j u_k) - \\nu w_j(\\partial_i\\partial_i\\partial_j u_k)\n$$\n\n**第二项：$(A(B\\boldsymbol{u}))_k$**\n首先，我们应用扩散算子 $B$：\n$$\n(B\\boldsymbol{u})_k = \\partial_i(\\nu \\partial_i u_k)\n$$\n接下来，我们将平流算子 $A$ 应用于矢量场 $B\\boldsymbol{u}$：\n$$\n(A(B\\boldsymbol{u}))_k = -w_j \\partial_j (B\\boldsymbol{u})_k = -w_j \\partial_j(\\partial_i(\\nu \\partial_i u_k))\n$$\n使用乘法法则展开：\n$$\n(A(B\\boldsymbol{u}))_k = -w_j \\partial_j\\left( (\\partial_i\\nu)(\\partial_i u_k) + \\nu(\\partial_i\\partial_i u_k) \\right)\n$$\n$$\n= -w_j \\left[ (\\partial_j\\partial_i\\nu)(\\partial_i u_k) + (\\partial_i\\nu)(\\partial_j\\partial_i u_k) + (\\partial_j\\nu)(\\partial_i\\partial_i u_k) + \\nu(\\partial_j\\partial_i\\partial_i u_k) \\right]\n$$\n$$\n= -w_j(\\partial_j\\partial_i\\nu)(\\partial_i u_k) - w_j(\\partial_i\\nu)(\\partial_j\\partial_i u_k) - w_j(\\partial_j\\nu)(\\partial_i\\partial_i u_k) - w_j\\nu(\\partial_j\\partial_i\\partial_i u_k)\n$$\n\n**对易子：$([A, B]\\boldsymbol{u})_k = (A(B\\boldsymbol{u}))_k - (B(A\\boldsymbol{u}))_k$**\n现在我们从 $(A(B\\boldsymbol{u}))_k$ 中减去 $(B(A\\boldsymbol{u}))_k$ 的表达式。我们按作用于 $u_k$ 的导数阶数对各项进行分组。\n\n- **三阶导数项：**\n$$\n-w_j\\nu(\\partial_j\\partial_i\\partial_i u_k) - (-\\nu w_j(\\partial_i\\partial_i\\partial_j u_k)) = -\\nu w_j(\\partial_j\\partial_i\\partial_i u_k) + \\nu w_j(\\partial_i\\partial_i\\partial_j u_k) = 0\n$$\n由于光滑函数的偏导数的可交换性，这些项相互抵消。这是预料之中的，因为一阶和二阶微分算子的对易子应该是一个二阶算子。\n\n- **二阶导数项：**\n$$\n[-w_j(\\partial_i\\nu)(\\partial_j\\partial_i u_k) - w_j(\\partial_j\\nu)(\\partial_i\\partial_i u_k)] - [-w_j(\\partial_i\\nu)(\\partial_i \\partial_j u_k) - 2\\nu(\\partial_i w_j)(\\partial_i\\partial_j u_k)]\n$$\n项 $-w_j(\\partial_i\\nu)(\\partial_j\\partial_i u_k)$ 和 $-(-w_j(\\partial_i\\nu)(\\partial_i \\partial_j u_k))$ 相互抵消。剩下的项是：\n$$\n-w_j(\\partial_j\\nu)(\\partial_i\\partial_i u_k) + 2\\nu(\\partial_i w_j)(\\partial_i\\partial_j u_k)\n$$\n\n- **一阶导数项：**\n$$\n[-w_j(\\partial_j\\partial_i\\nu)(\\partial_i u_k)] - [-(\\partial_i\\nu)(\\partial_i w_j)(\\partial_j u_k) - \\nu(\\partial_i\\partial_i w_j)(\\partial_j u_k)]\n$$\n$$\n= -w_j(\\partial_j\\partial_i\\nu)(\\partial_i u_k) + (\\partial_i\\nu)(\\partial_i w_j)(\\partial_j u_k) + \\nu(\\partial_i\\partial_i w_j)(\\partial_j u_k)\n$$\n\n合并所有剩余项，对易子第 $k$ 个分量的表达式为：\n$$\n([A, B]\\boldsymbol{u})_k = 2\\nu(\\partial_i w_j)\\partial_i\\partial_j u_k - w_j(\\partial_j \\nu)\\partial_l\\partial_l u_k + (\\partial_m(\\nu\\partial_m w_j))\\partial_j u_k - w_j(\\partial_j\\partial_p\\nu)\\partial_p u_k\n$$\n其中 $i, j, l, m, p$ 是从 $1$ 到 $d$ 的求和指标。无散条件 $\\partial_j w_j=0$ 不会对此表达式带来进一步的直接简化。\n\n最后，将表达式乘以 $\\frac{(\\Delta t)^2}{2}$ 即可得到领头阶局部劈裂误差项。\n\n在时间层 $t^n$ 的领头对易子误差项的第 $k$ 个分量是：\n$$\n\\frac{(\\Delta t)^2}{2} \\left( 2\\nu(\\partial_i w_j)\\partial_i\\partial_j u_k - w_j(\\partial_j \\nu)\\partial_l\\partial_l u_k + (\\partial_m(\\nu\\partial_m w_j))\\partial_j u_k - w_j(\\partial_j\\partial_p\\nu)\\partial_p u_k \\right)\n$$\n所有场及其导数均在 $(\\boldsymbol{x}, t^n)$ 处求值。",
            "answer": "$$\n\\boxed{\\frac{(\\Delta t)^2}{2} \\left( 2\\nu(\\partial_i w_j)\\partial_i\\partial_j u_k - w_j(\\partial_j \\nu)\\partial_l\\partial_l u_k + (\\partial_m(\\nu\\partial_m w_j))\\partial_j u_k - w_j(\\partial_j\\partial_p\\nu)\\partial_p u_k \\right)}\n$$"
        }
    ]
}