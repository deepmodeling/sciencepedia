{
    "hands_on_practices": [
        {
            "introduction": "Building a reliable CFD solver begins with correctly implementing its fundamental building blocks: the discrete forms of differential operators. This practice utilizes the Method of Manufactured Solutions (MMS), a cornerstone of code verification, to confirm the correct implementation of the divergence, gradient, and Laplacian on a MAC grid. By comparing your numerical results against a known analytical solution and empirically measuring the convergence rate, you will gain confidence in your coding and a deep understanding of how discretization accuracy is quantified .",
            "id": "3996770",
            "problem": "Consider a two-dimensional, periodic, unit square domain with coordinates $(x,y) \\in [0,1] \\times [0,1]$ and a family of Marker-And-Cell (MAC) grids (Marker-And-Cell (MAC) is a staggered grid formulation where scalar quantities are stored at cell centers and velocity components are stored at face centers). Let $N_x = N_y = N$ denote the number of rectangular control volumes (cells) in each direction, so that $\\Delta x = 1/N$ and $\\Delta y = 1/N$. On the MAC grid:\n- The cell-centered locations are at $(x_c,y_c) = \\left((i+\\tfrac{1}{2})\\Delta x, (j+\\tfrac{1}{2})\\Delta y\\right)$ for integers $i=0,\\dots,N-1$ and $j=0,\\dots,N-1$.\n- The $x$-velocity locations (vertical faces) are at $(x_u,y_u) = \\left(i\\Delta x, (j+\\tfrac{1}{2})\\Delta y\\right)$.\n- The $y$-velocity locations (horizontal faces) are at $(x_v,y_v) = \\left((i+\\tfrac{1}{2})\\Delta x, j\\Delta y\\right)$.\n\nStart from the fundamental definitions and laws:\n- The divergence of a vector field $\\mathbf{u}(x,y) = (u(x,y),v(x,y))$ is defined as $\\nabla \\cdot \\mathbf{u} = \\dfrac{\\partial u}{\\partial x} + \\dfrac{\\partial v}{\\partial y}$.\n- The gradient of a scalar field $p(x,y)$ is $\\nabla p = \\left(\\dfrac{\\partial p}{\\partial x},\\dfrac{\\partial p}{\\partial y}\\right)$.\n- The Laplacian of a scalar field $p(x,y)$ is $\\nabla^2 p = \\dfrac{\\partial^2 p}{\\partial x^2} + \\dfrac{\\partial^2 p}{\\partial y^2}$.\n- Periodic boundary conditions imply that values and their derivatives repeat with period $1$ in both $x$ and $y$.\n\nUsing these foundations together with Taylor expansions and the Divergence Theorem (applied to each control volume), derive and implement second-order accurate MAC discretizations:\n- A discrete divergence at cell centers in terms of face-centered velocities,\n- A discrete pressure gradient at face centers in terms of cell-centered pressure,\n- A discrete Laplacian at cell centers in terms of cell-centered pressure.\n\nManufacture smooth, periodic test fields with known closed-form derivatives to evaluate the discretization error. Use the following three manufactured solutions, each specified by a scalar field $p(x,y)$ and a velocity field $\\mathbf{u}(x,y)$; all fields are dimensionless:\n1. Case A:\n   - $p(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$,\n   - $u(x,y) = \\sin(2\\pi x)\\cos(2\\pi y)$,\n   - $v(x,y) = -\\cos(2\\pi x)\\sin(2\\pi y)$.\n2. Case B:\n   - $p(x,y) = \\cos(2\\pi x) + \\cos(2\\pi y)$,\n   - $u(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$,\n   - $v(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$.\n3. Case C:\n   - $p(x,y) = \\cos(3\\pi x) + \\sin(5\\pi y)$,\n   - $u(x,y) = \\cos(3\\pi x)\\sin(5\\pi y)$,\n   - $v(x,y) = \\sin(3\\pi x)\\cos(5\\pi y)$.\n\nFor each case, compute:\n- The discrete divergence at cell centers, and its pointwise error with respect to the exact divergence evaluated at cell centers,\n- The discrete pressure gradient at face centers, and its pointwise error with respect to the exact gradient evaluated at those face centers,\n- The discrete Laplacian at cell centers, and its pointwise error with respect to the exact Laplacian at cell centers.\n\nDefine the discrete $L_2$ norm of the error for a scalar field $e_{s}(i,j)$ at cell centers as\n$$\n\\|e_s\\|_2 = \\sqrt{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} e_s(i,j)^2 \\, \\Delta x \\Delta y}.\n$$\nFor the gradient error, defined at face centers in a staggered fashion, combine the components as\n$$\n\\|e_{\\nabla}\\|_2 = \\sqrt{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1}\\left[e_{x}(i,j)^2 + e_{y}(i,j)^2\\right]\\, \\Delta x \\Delta y},\n$$\nwhere $e_x(i,j)$ is the error in $\\dfrac{\\partial p}{\\partial x}$ at $x$-velocity locations and $e_y(i,j)$ is the error in $\\dfrac{\\partial p}{\\partial y}$ at $y$-velocity locations.\n\nEmpirically verify second-order convergence by computing the observed order $q$ from the sequence of $L_2$ errors on grids with $N \\in \\{8,16,32,64\\}$ using a linear fit of $\\log(E)$ versus $\\log(h)$, where $h=\\max(\\Delta x,\\Delta y)=1/N$:\n$$\nq \\approx \\text{slope of the line fitting } \\left(\\log h, \\log E(h)\\right).\n$$\n\nTest Suite:\n- Use the three manufactured cases A, B, and C specified above.\n- For each case, compute the $L_2$ error norms for $N=8,16,32,64$ and the corresponding observed order $q$ for each operator (divergence, gradient, Laplacian).\n- Include the case where the exact divergence is identically zero (Case A) to probe numerical cancellation and confirm second-order behavior without bias from the analytic field’s magnitude.\n\nFinal Output:\n- Your program should produce a single line of output containing the observed convergence orders as a comma-separated list enclosed in square brackets.\n- The list must contain nine floating-point values in the following order:\n  $[q_{\\text{div}}^{A}, q_{\\nabla}^{A}, q_{\\nabla^2}^{A}, q_{\\text{div}}^{B}, q_{\\nabla}^{B}, q_{\\nabla^2}^{B}, q_{\\text{div}}^{C}, q_{\\nabla}^{C}, q_{\\nabla^2}^{C}]$,\n  where the superscripts denote the case and $\\nabla^2$ denotes the Laplacian.\n- No physical units are involved; all quantities are dimensionless. Angles are in radians. Express the nine outputs as floating-point numbers rounded to three decimal places.",
            "solution": "The user-provided problem statement has been validated and is deemed **valid**. It is scientifically grounded, well-posed, objective, and contains all necessary information to proceed with a solution.\n\nThe problem requires the derivation and verification of second-order accurate finite difference discretizations for the divergence, gradient, and Laplacian operators on a two-dimensional, periodic, staggered Marker-And-Cell (MAC) grid.\n\nThe domain is a unit square, $[0,1] \\times [0,1]$, discretized into $N \\times N$ control volumes, each of size $\\Delta x \\times \\Delta y$, where $\\Delta x = \\Delta y = 1/N$. Let $h = 1/N$. The grid locations are defined as follows for indices $i,j \\in \\{0, \\dots, N-1\\}$:\n- Cell centers ($p$, scalars): $(x_{c,i}, y_{c,j}) = ((i+\\frac{1}{2})h, (j+\\frac{1}{2})h)$, where a scalar field $p$ is denoted $p_{i,j}$.\n- $u$-velocity faces ($u$ component): $(x_{u,i}, y_{u,j}) = (ih, (j+\\frac{1}{2})h)$, where the $x$-velocity is denoted $u_{i,j}$. This is the left face of cell $(i,j)$.\n- $v$-velocity faces ($v$ component): $(x_{v,i}, y_{v,j}) = ((i+\\frac{1}{2})h, jh)$, where the $y$-velocity is denoted $v_{i,j}$. This is the bottom face of cell $(i,j)$.\n\nDue to periodicity, indices are handled modulo $N$. For example, $p_{N,j} = p_{0,j}$ and $p_{-1,j} = p_{N-1,j}$.\n\n### **1. Derivation of the Discrete Divergence Operator**\n\nThe divergence of a vector field $\\mathbf{u}=(u,v)$ at the center of cell $(i,j)$ is $\\nabla \\cdot \\mathbf{u} = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}$. We derive a discrete approximation using the Divergence Theorem over the control volume $V_{i,j} = [ih, (i+1)h] \\times [jh, (j+1)h]$.\n\n$$ \\int_{V_{i,j}} (\\nabla \\cdot \\mathbf{u}) \\, dV = \\oint_{\\partial V_{i,j}} \\mathbf{u} \\cdot \\mathbf{n} \\, dS $$\n\nApproximating the left-hand side integral with the value at the cell center times the area, we get $(\\nabla \\cdot \\mathbf{u})_{i,j} h^2$. The right-hand side is the net flux out of the cell, which in 2D is:\n\n$$ \\int_{jh}^{(j+1)h} [u((i+1)h, y) - u(ih, y)] dy + \\int_{ih}^{(i+1)h} [v(x, (j+1)h) - v(x, jh)] dx $$\n\nWe approximate the face integrals using the midpoint rule, which corresponds to the velocity values at the face centers:\n- Flux through right face ($x=(i+1)h$): $u_{i+1,j}h$\n- Flux through left face ($x=ih$): $u_{i,j}h$\n- Flux through top face ($y=(j+1)h$): $v_{i,j+1}h$\n- Flux through bottom face ($y=jh$): $v_{i,j}h$\n\nCombining these gives:\n$$ (\\nabla \\cdot \\mathbf{u})_{i,j} h^2 \\approx (u_{i+1,j} - u_{i,j})h + (v_{i,j+1} - v_{i,j})h $$\nDividing by $h^2$, we obtain the discrete divergence at the cell center $(i,j)$:\n$$ (\\nabla \\cdot \\mathbf{u})_{i,j} \\approx \\frac{u_{i+1,j} - u_{i,j}}{h} + \\frac{v_{i,j+1} - v_{i,j}}{h} $$\nThis is a central difference scheme on the staggered grid. A Taylor series expansion of $u$ and $v$ about the cell center $(x_{c,i}, y_{c,j})$ confirms that this approximation is second-order accurate, i.e., the truncation error is $O(h^2)$.\n\n### **2. Derivation of the Discrete Gradient Operator**\n\nThe gradient of a scalar field $p$, $\\nabla p = (\\frac{\\partial p}{\\partial x}, \\frac{\\partial p}{\\partial y})$, is required at the velocity locations.\n- The $x$-component, $\\frac{\\partial p}{\\partial x}$, is evaluated at the $u$-velocity location $(ih, (j+\\frac{1}{2})h)$. This point lies exactly between the cell centers $(i-1,j)$ and $(i,j)$. A second-order central difference is therefore:\n$$ \\left(\\frac{\\partial p}{\\partial x}\\right)_{i,j} \\approx \\frac{p_{i,j} - p_{i-1,j}}{h} $$\n- The $y$-component, $\\frac{\\partial p}{\\partial y}$, is evaluated at the $v$-velocity location $((i+\\frac{1}{2})h, jh)$. This point lies exactly between the cell centers $(i,j-1)$ and $(i,j)$. The corresponding central difference is:\n$$ \\left(\\frac{\\partial p}{\\partial y}\\right)_{i,j} \\approx \\frac{p_{i,j} - p_{i,j-1}}{h} $$\nTaylor series expansions of $p$ about the respective face centers confirm that both approximations are second-order accurate, with truncation error $O(h^2)$.\n\n### **3. Derivation of the Discrete Laplacian Operator**\n\nThe Laplacian of a scalar field $p$ is defined as $\\nabla^2 p = \\nabla \\cdot (\\nabla p)$. We can derive a discrete Laplacian by composing the discrete divergence and gradient operators derived above. The Laplacian is evaluated at cell centers.\n$$ (\\nabla^2 p)_{i,j} = \\left( \\nabla \\cdot (\\nabla p) \\right)_{i,j} \\approx \\frac{(\\frac{\\partial p}{\\partial x})_{i+1,j} - (\\frac{\\partial p}{\\partial x})_{i,j}}{h} + \\frac{(\\frac{\\partial p}{\\partial y})_{i,j+1} - (\\frac{\\partial p}{\\partial y})_{i,j}}{h} $$\nHere, $(\\frac{\\partial p}{\\partial x})_{i,j}$ refers to the discrete gradient component at the $u$-location $(ih, (j+\\frac{1}{2})h)$, and $(\\frac{\\partial p}{\\partial y})_{i,j}$ to the discrete gradient component at the $v$-location $((i+\\frac{1}{2})h, jh)$.\n\nSubstituting the expressions for the discrete gradient components:\n- $(\\frac{\\partial p}{\\partial x})_{i+1,j} \\approx \\frac{p_{i+1,j} - p_{i,j}}{h}$\n- $(\\frac{\\partial p}{\\partial x})_{i,j} \\approx \\frac{p_{i,j} - p_{i-1,j}}{h}$\n- $(\\frac{\\partial p}{\\partial y})_{i,j+1} \\approx \\frac{p_{i,j+1} - p_{i,j}}{h}$\n- $(\\frac{\\partial p}{\\partial y})_{i,j} \\approx \\frac{p_{i,j} - p_{i,j-1}}{h}$\n\nPlugging these into the composed operator gives:\n$$ (\\nabla^2 p)_{i,j} \\approx \\frac{1}{h}\\left( \\frac{p_{i+1,j} - p_{i,j}}{h} - \\frac{p_{i,j} - p_{i-1,j}}{h} \\right) + \\frac{1}{h}\\left( \\frac{p_{i,j+1} - p_{i,j}}{h} - \\frac{p_{i,j} - p_{i,j-1}}{h} \\right) $$\n$$ (\\nabla^2 p)_{i,j} \\approx \\frac{p_{i+1,j} + p_{i-1,j} - 2p_{i,j}}{h^2} + \\frac{p_{i,j+1} + p_{i,j-1} - 2p_{i,j}}{h^2} $$\nThis is the standard 5-point stencil for the Laplacian on a Cartesian grid. Taylor series analysis shows it is second-order accurate, with truncation error $O(h^2)$.\n\n### **Verification Procedure**\n\nTo verify the second-order accuracy, we use the method of manufactured solutions. For each of the three provided cases and for each operator, we:\n1. Discretize the domain with $N \\in \\{8, 16, 32, 64\\}$.\n2. Evaluate the exact analytical fields ($p, u, v$) at the appropriate MAC grid locations.\n3. Compute the discrete operators ($(\\nabla \\cdot \\mathbf{u})_h$, $(\\nabla p)_h$, $(\\nabla^2 p)_h$) using the derived formulas.\n4. Evaluate the exact analytical derivatives ($\\nabla \\cdot \\mathbf{u}$, $\\nabla p$, $\\nabla^2 p$) at the same MAC grid locations.\n5. Calculate the pointwise error fields (e.g., $e_{div} = (\\nabla \\cdot \\mathbf{u})_h - \\nabla \\cdot \\mathbf{u}$).\n6. Compute the discrete $L_2$ error norm, $E(h)$, for each operator as defined in the problem.\n7. The expected relationship for a second-order scheme is $E(h) = C h^q$, where the order of convergence $q \\approx 2$. Taking the logarithm gives $\\log(E) = \\log(C) + q \\log(h)$.\n8. We perform a linear regression on the points $(\\log(h), \\log(E))$ for $h=1/N$. The slope of the resulting line provides the observed order of convergence, $q$.\nThis procedure is implemented for all three cases and all three operators to determine the nine requested convergence orders.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Derives and verifies second-order accurate MAC grid discretizations for\n    divergence, gradient, and Laplacian operators using manufactured solutions.\n    \"\"\"\n\n    # Define the three manufactured solution cases\n    twopi = 2 * np.pi\n    \n    # Case A:\n    case_A = {\n        'p': lambda x, y: np.sin(twopi * x) * np.sin(twopi * y),\n        'u': lambda x, y: np.sin(twopi * x) * np.cos(twopi * y),\n        'v': lambda x, y: -np.cos(twopi * x) * np.sin(twopi * y),\n        'div_u': lambda x, y: 0.0 * x * y, # Exact divergence is zero\n        'grad_px': lambda x, y: twopi * np.cos(twopi * x) * np.sin(twopi * y),\n        'grad_py': lambda x, y: twopi * np.sin(twopi * x) * np.cos(twopi * y),\n        'lap_p': lambda x, y: -2 * (twopi**2) * np.sin(twopi * x) * np.sin(twopi * y)\n    }\n\n    # Case B:\n    case_B = {\n        'p': lambda x, y: np.cos(twopi * x) + np.cos(twopi * y),\n        'u': lambda x, y: np.sin(twopi * x) * np.sin(twopi * y),\n        'v': lambda x, y: np.sin(twopi * x) * np.sin(twopi * y),\n        'div_u': lambda x, y: twopi * (np.cos(twopi * x) * np.sin(twopi * y) + np.sin(twopi * x) * np.cos(twopi * y)),\n        'grad_px': lambda x, y: -twopi * np.sin(twopi * x),\n        'grad_py': lambda x, y: -twopi * np.sin(twopi * y),\n        'lap_p': lambda x, y: - (twopi**2) * (np.cos(twopi * x) + np.cos(twopi * y))\n    }\n\n    # Case C:\n    case_C = {\n        'p': lambda x, y: np.cos(3 * np.pi * x) + np.sin(5 * np.pi * y),\n        'u': lambda x, y: np.cos(3 * np.pi * x) * np.sin(5 * np.pi * y),\n        'v': lambda x, y: np.sin(3 * np.pi * x) * np.cos(5 * np.pi * y),\n        'div_u': lambda x, y: -3 * np.pi * np.sin(3 * np.pi * x) * np.sin(5 * np.pi * y) - 5 * np.pi * np.sin(3 * np.pi * x) * np.sin(5 * np.pi * y),\n        'grad_px': lambda x, y: -3 * np.pi * np.sin(3 * np.pi * x),\n        'grad_py': lambda x, y: 5 * np.pi * np.cos(5 * np.pi * y),\n        'lap_p': lambda x, y: -(3 * np.pi)**2 * np.cos(3 * np.pi * x) - (5 * np.pi)**2 * np.sin(5 * np.pi * y)\n    }\n\n    test_cases = [case_A, case_B, case_C]\n    resolutions = [8, 16, 32, 64]\n    \n    all_orders = []\n\n    for case in test_cases:\n        errors_div, errors_grad, errors_lap = [], [], []\n        h_values = []\n\n        for N in resolutions:\n            h = 1.0 / N\n            h_values.append(h)\n\n            # Generate MAC grid coordinates\n            # Cell centers (p)\n            xc = (np.arange(N) + 0.5) * h\n            yc = (np.arange(N) + 0.5) * h\n            XC_cc, YC_cc = np.meshgrid(xc, yc)\n\n            # u-velocity faces (vertical faces)\n            xu = np.arange(N) * h\n            yu = (np.arange(N) + 0.5) * h\n            XU_fc, YU_fc = np.meshgrid(xu, yu)\n\n            # v-velocity faces (horizontal faces)\n            xv = (np.arange(N) + 0.5) * h\n            yv = np.arange(N) * h\n            XV_fc, YV_fc = np.meshgrid(xv, yv)\n\n            # --- Evaluate exact fields on MAC grid locations ---\n            p_cc = case['p'](XC_cc, YC_cc)\n            u_fc = case['u'](XU_fc, YU_fc)\n            v_fc = case['v'](XV_fc, YV_fc)\n\n            # --- Compute discrete operators ---\n            # Divergence at cell centers\n            div_u_h = (np.roll(u_fc, -1, axis=1) - u_fc) / h + \\\n                      (np.roll(v_fc, -1, axis=0) - v_fc) / h\n            \n            # Gradient at face centers\n            grad_px_h = (p_cc - np.roll(p_cc, 1, axis=1)) / h\n            grad_py_h = (p_cc - np.roll(p_cc, 1, axis=0)) / h\n            \n            # Laplacian at cell centers\n            lap_p_h = (np.roll(p_cc, 1, axis=1) + np.roll(p_cc, -1, axis=1) - 2 * p_cc) / h**2 + \\\n                      (np.roll(p_cc, 1, axis=0) + np.roll(p_cc, -1, axis=0) - 2 * p_cc) / h**2\n\n            # --- Evaluate exact derivatives on MAC grid locations ---\n            div_u_exact = case['div_u'](XC_cc, YC_cc)\n            grad_px_exact = case['grad_px'](XU_fc, YU_fc)\n            grad_py_exact = case['grad_py'](XV_fc, YV_fc)\n            lap_p_exact = case['lap_p'](XC_cc, YC_cc)\n\n            # --- Compute L2 error norms ---\n            # Divergence error\n            err_div = div_u_h - div_u_exact\n            l2_err_div = np.sqrt(np.sum(err_div**2) * h**2)\n            errors_div.append(l2_err_div)\n\n            # Gradient error\n            err_grad_x = grad_px_h - grad_px_exact\n            err_grad_y = grad_py_h - grad_py_exact\n            l2_err_grad = np.sqrt(np.sum(err_grad_x**2 + err_grad_y**2) * h**2)\n            errors_grad.append(l2_err_grad)\n\n            # Laplacian error\n            err_lap = lap_p_h - lap_p_exact\n            l2_err_lap = np.sqrt(np.sum(err_lap**2) * h**2)\n            errors_lap.append(l2_err_lap)\n\n        # --- Compute convergence orders using log-log linear fit ---\n        log_h = np.log(h_values)\n        \n        # Order for divergence\n        log_err_div = np.log(errors_div)\n        q_div = linregress(log_h, log_err_div).slope\n        all_orders.append(q_div)\n\n        # Order for gradient\n        log_err_grad = np.log(errors_grad)\n        q_grad = linregress(log_h, log_err_grad).slope\n        all_orders.append(q_grad)\n\n        # Order for Laplacian\n        log_err_lap = np.log(errors_lap)\n        q_lap = linregress(log_h, log_err_lap).slope\n        all_orders.append(q_lap)\n\n    # Format the final output\n    formatted_orders = [f\"{order:.3f}\" for order in all_orders]\n    print(f\"[{','.join(formatted_orders)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While periodic domains are useful for theoretical analysis, real-world flows are bounded by physical walls where conditions like no-slip must be enforced. This exercise demonstrates how to implement this critical boundary condition in a channel flow using the ghost-cell method on a staggered grid. You will derive the appropriate values for these ghost cells to ensure that the second-order accuracy of your discretization is maintained right up to the wall, a crucial technique for the accurate simulation of wall-bounded flows .",
            "id": "3996801",
            "problem": "Consider an incompressible, steady, two-dimensional channel flow of height $H$ and length $L$, described by the incompressible Navier–Stokes equations. The channel walls are located at $y=0$ (bottom) and $y=H$ (top), and enforce the classical no-slip boundary condition, namely that both the tangential and normal velocity components vanish at the walls. The domain is discretized using a uniform Marker-And-Cell (MAC) arrangement for Computational Fluid Dynamics (CFD) with $N_{x}$ cells in the streamwise direction and $N_{y}$ cells in the wall-normal direction. Let the uniform spacings be $\\Delta x = L/N_{x}$ and $\\Delta y = H/N_{y}$. Pressure $p$ is stored at cell centers $(i,j)$ located at $(x_{i},y_{j})=\\left((i-\\tfrac{1}{2})\\Delta x,(j-\\tfrac{1}{2})\\Delta y\\right)$ for $i=1,\\dots,N_{x}$ and $j=1,\\dots,N_{y}$. The streamwise velocity $u$ is stored at vertical faces at $(i+\\tfrac{1}{2},j)$ with coordinates $\\left(x_{i+\\tfrac{1}{2}},y_{j}\\right)=\\left(i\\Delta x,(j-\\tfrac{1}{2})\\Delta y\\right)$ for $i=0,\\dots,N_{x}$ and $j=1,\\dots,N_{y}$. The wall-normal velocity $v$ is stored at horizontal faces at $(i,j+\\tfrac{1}{2})$ with coordinates $\\left(x_{i},y_{j+\\tfrac{1}{2}}\\right)=\\left((i-\\tfrac{1}{2})\\Delta x,j\\Delta y\\right)$ for $i=1,\\dots,N_{x}$ and $j=0,\\dots,N_{y}$. To form second-order central-difference viscous terms near the walls in the discrete Laplacian, define ghost $u$-face indices $j=0$ below the bottom wall at $y=-\\tfrac{1}{2}\\Delta y$ and $j=N_{y}+1$ above the top wall at $y=H+\\tfrac{1}{2}\\Delta y$; for $v$, the boundary faces at $j=0$ and $j=N_{y}$ lie exactly on the walls at $y=0$ and $y=H$.\n\nStarting from the no-slip and no-penetration conditions derived from fundamental continuum mechanics ($u=0$ and $v=0$ at solid boundaries) and the MAC placement described above, do the following:\n\n- Derive the ghost-face values $u_{i+\\tfrac{1}{2},0}$ and $u_{i+\\tfrac{1}{2},N_{y}+1}$ that must be imposed adjacent to the bottom and top walls to ensure that the discrete wall-normal second derivative of $u$ at the first interior $u$-faces (at $y=\\tfrac{1}{2}\\Delta y$ near the bottom and $y=H-\\tfrac{1}{2}\\Delta y$ near the top) remains second-order accurate.\n\n- State the wall-face values $v_{i,0}$ and $v_{i,N_{y}}$ that enforce no penetration at the walls.\n\n- Let $u(y)$ be a smooth wall-parallel velocity profile satisfying $u(0)=0$ near the bottom wall. Using Taylor expansions and without introducing any shortcut formulas, analyze the discrete wall-normal Laplacian stencil for $u$ at the first interior $u$-face adjacent to the bottom wall, \n$$\n\\left.\\frac{\\partial^{2}u}{\\partial y^{2}}\\right|_{y=\\tfrac{1}{2}\\Delta y}\n\\approx \\frac{u_{i+\\tfrac{1}{2},2}-2u_{i+\\tfrac{1}{2},1}+u_{i+\\tfrac{1}{2},0}}{\\Delta y^{2}},\n$$\nand provide the explicit leading-order truncation error term as a closed-form expression in terms of $\\Delta y$ and derivatives of $u$ evaluated at $y=\\tfrac{1}{2}\\Delta y$.\n\nExpress your final answer as a single row matrix containing, in order, the four face values $u_{i+\\tfrac{1}{2},0}$, $u_{i+\\tfrac{1}{2},N_{y}+1}$, $v_{i,0}$, $v_{i,N_{y}}$, and the leading-order truncation error term for the discrete wall-normal Laplacian of $u$ at $y=\\tfrac{1}{2}\\Delta y$. No numerical evaluation is required. If any approximation is used, provide it as an exact symbolic expression. No units are required. If you choose to compute any intermediate numerical values, round the final answer to four significant figures; otherwise provide exact expressions.",
            "solution": "The user has provided a problem in the area of Computational Fluid Dynamics (CFD), specifically concerning the staggered grid (MAC) formulation. The task is to validate the problem and, if valid, provide a complete solution.\n\n### Step 1: Extract Givens\n- **Flow**: Incompressible, steady, two-dimensional channel flow.\n- **Geometry**: Channel of height $H$ and length $L$. Walls at $y=0$ and $y=H$.\n- **Boundary Conditions (BC)**: No-slip at walls, implying $u=0$ and $v=0$ at $y=0$ and $y=H$.\n- **Discretization**: Uniform Marker-And-Cell (MAC) grid.\n- **Grid Dimensions**: $N_{x}$ cells in the streamwise direction, $N_{y}$ cells in the wall-normal direction.\n- **Grid Spacing**: $\\Delta x = L/N_{x}$ and $\\Delta y = H/N_{y}$.\n- **Pressure Nodes ($p$)**: Located at cell centers $(i,j)$ with coordinates $(x_{i},y_{j})=\\left((i-\\tfrac{1}{2})\\Delta x,(j-\\tfrac{1}{2})\\Delta y\\right)$.\n- **Streamwise Velocity Nodes ($u$)**: Located at vertical faces $(i+\\tfrac{1}{2},j)$ with coordinates $\\left(x_{i+\\tfrac{1}{2}},y_{j}\\right)=\\left(i\\Delta x,(j-\\tfrac{1}{2})\\Delta y\\right)$.\n- **Wall-Normal Velocity Nodes ($v$)**: Located at horizontal faces $(i,j+\\tfrac{1}{2})$ with coordinates $\\left(x_{i},y_{j+\\tfrac{1}{2}}\\right)=\\left((i-\\tfrac{1}{2})\\Delta x,j\\Delta y\\right)$.\n- **Ghost Nodes for $u$**: Indices $j=0$ (at $y=-\\tfrac{1}{2}\\Delta y$) and $j=N_{y}+1$ (at $y=H+\\tfrac{1}{2}\\Delta y$).\n- **Boundary Nodes for $v$**: Indices $j=0$ (at $y=0$) and $j=N_{y}$ (at $y=H=N_y\\Delta y$).\n- **Task 1**: Derive the ghost-face values $u_{i+\\tfrac{1}{2},0}$ and $u_{i+\\tfrac{1}{2},N_{y}+1}$.\n- **Task 2**: State the wall-face values $v_{i,0}$ and $v_{i,N_{y}}$.\n- **Task 3**: Analyze the truncation error of the discrete Laplacian $\\left.\\frac{\\partial^{2}u}{\\partial y^{2}}\\right|_{y=\\tfrac{1}{2}\\Delta y} \\approx \\frac{u_{i+\\tfrac{1}{2},2}-2u_{i+\\tfrac{1}{2},1}+u_{i+\\tfrac{1}{2},0}}{\\Delta y^{2}}$ for a smooth profile $u(y)$ with $u(0)=0$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, describing a standard MAC grid for the incompressible Navier-Stokes equations, which is a fundamental topic in CFD. The use of ghost cells to enforce boundary conditions is a standard and valid numerical technique. The problem is well-posed; it asks for specific derivations and an error analysis based on the provided setup. The language is objective and precise. All necessary information regarding the grid, variable placement, and boundary conditions is provided and is self-consistent. The problem is a standard exercise in a graduate-level CFD course and is entirely valid.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\n### Solution Derivation\n\nThe problem requires the derivation of three distinct items: the ghost-cell values for the streamwise velocity $u$, the boundary values for the wall-normal velocity $v$, and the leading-order truncation error for the discrete Laplacian of $u$ near a wall.\n\n**1. Ghost-Face Values for Streamwise Velocity ($u$)**\n\nThe no-slip boundary condition requires the tangential velocity component, $u$, to be zero at the walls, i.e., $u(y=0)=0$ and $u(y=H)=0$. The problem asks for the derivation of ghost-face values that ensure the resulting scheme is second-order accurate. A second-order accurate enforcement of a Dirichlet boundary condition on a staggered grid is achieved by linear interpolation.\n\n- **Bottom Wall ($y=0$)**:\nThe wall at $y=0$ is located exactly halfway between the first interior $u$-velocity node, $u_{i+\\frac{1}{2},1}$, at location $y_1 = (1-\\frac{1}{2})\\Delta y = \\frac{1}{2}\\Delta y$, and the ghost-face node, $u_{i+\\frac{1}{2},0}$, at location $y_0 = (0-\\frac{1}{2})\\Delta y = -\\frac{1}{2}\\Delta y$.\nA second-order accurate approximation for the velocity at the wall is obtained by averaging the values at these two bracketing points:\n$$u(y=0) \\approx \\frac{u_{i+\\frac{1}{2},1} + u_{i+\\frac{1}{2},0}}{2}$$\nTo enforce the no-slip condition $u(y=0)=0$, we set this approximation to zero:\n$$\\frac{u_{i+\\frac{1}{2},1} + u_{i+\\frac{1}{2},0}}{2} = 0$$\nSolving for the ghost-face value $u_{i+\\frac{1}{2},0}$ yields:\n$$u_{i+\\frac{1}{2},0} = -u_{i+\\frac{1}{2},1}$$\nThis represents an anti-symmetric reflection of the velocity across the wall.\n\n- **Top Wall ($y=H$)**:\nSimilarly, the top wall at $y=H = N_y \\Delta y$ is located halfway between the last interior $u$-velocity node, $u_{i+\\frac{1}{2},N_y}$, at $y_{N_y} = (N_y-\\frac{1}{2})\\Delta y$, and the top ghost-face node, $u_{i+\\frac{1}{2},N_y+1}$, at $y_{N_y+1} = (N_y+1-\\frac{1}{2})\\Delta y = (N_y+\\frac{1}{2})\\Delta y$.\nThe interpolated velocity at the wall is:\n$$u(y=H) \\approx \\frac{u_{i+\\frac{1}{2},N_y} + u_{i+\\frac{1}{2},N_y+1}}{2}$$\nEnforcing the no-slip condition $u(y=H)=0$:\n$$\\frac{u_{i+\\frac{1}{2},N_y} + u_{i+\\frac{1}{2},N_y+1}}{2} = 0$$\nSolving for the ghost-face value $u_{i+\\frac{1}{2},N_y+1}$ gives:\n$$u_{i+\\frac{1}{2},N_y+1} = -u_{i+\\frac{1}{2},N_y}$$\n\n**2. Wall-Face Values for Wall-Normal Velocity ($v$)**\n\nThe no-slip condition also implies no penetration, meaning the wall-normal velocity component, $v$, must be zero at the walls: $v(y=0)=0$ and $v(y=H)=0$.\nA careful reading of the problem description, \"The wall-normal velocity $v$ is stored at horizontal faces at $(i,j+\\tfrac{1}{2})$ with coordinates $\\left(x_{i},y_{j+\\tfrac{1}{2}}\\right)=\\left((i-\\tfrac{1}{2})\\Delta x,j\\Delta y\\right)$\", clarifies that the $v$-velocity faces are located at $y=j\\Delta y$.\n- For $j=0$, the location is $y = 0 \\cdot \\Delta y = 0$, which is the bottom wall.\n- For $j=N_y$, the location is $y = N_y \\Delta y = H$, which is the top wall.\nTherefore, the discrete velocities $v_{i,0}$ and $v_{i,N_y}$ represent the wall-normal velocity exactly at the wall locations. To enforce the no-penetration condition, we must set these values to zero for all $i$:\n$$v_{i,0} = 0$$\n$$v_{i,N_y} = 0$$\n\n**3. Truncation Error Analysis of the Discrete Laplacian**\n\nThe final task is to find the leading-order truncation error for the given central-difference approximation of the second derivative of $u$ with respect to $y$, evaluated at the first interior $u$-face, $y_1=\\frac{1}{2}\\Delta y$.\nThe approximation is given by:\n$$\\left.\\frac{\\partial^{2}u}{\\partial y^{2}}\\right|_{y_1} \\approx \\frac{u_{i+\\frac{1}{2},2}-2u_{i+\\frac{1}{2},1}+u_{i+\\frac{1}{2},0}}{\\Delta y^{2}}$$\nThe truncation error $\\tau$ is defined as the difference between the discrete approximation and the exact derivative:\n$$\\tau = \\left( \\frac{u_{i+\\frac{1}{2},2}-2u_{i+\\frac{1}{2},1}+u_{i+\\frac{1}{2},0}}{\\Delta y^{2}} \\right) - \\left.\\frac{\\partial^{2}u}{\\partial y^{2}}\\right|_{y_1}$$\nTo perform the analysis, we use Taylor series expansions for the discrete velocity values around the point of interest, $y_1 = \\frac{1}{2}\\Delta y$. Let $u(y)$ be the smooth, continuous velocity profile. The discrete points correspond to $u_{i+\\frac{1}{2},1} = u(y_1)$, $u_{i+\\frac{1}{2},2} = u(y_1+\\Delta y)$, and for this analysis, we consider the ideal case where $u_{i+\\frac{1}{2},0}$ corresponds to $u(y_1-\\Delta y)$. This reveals the inherent accuracy of the finite difference operator itself.\nThe Taylor series expansions for $u(y_1+\\Delta y)$ and $u(y_1-\\Delta y)$ around $y_1$ are:\n$$u(y_1+\\Delta y) = u(y_1) + \\left.\\frac{\\partial u}{\\partial y}\\right|_{y_1}\\Delta y + \\left.\\frac{\\partial^{2} u}{\\partial y^{2}}\\right|_{y_1}\\frac{\\Delta y^{2}}{2!} + \\left.\\frac{\\partial^{3} u}{\\partial y^{3}}\\right|_{y_1}\\frac{\\Delta y^{3}}{3!} + \\left.\\frac{\\partial^{4} u}{\\partial y^{4}}\\right|_{y_1}\\frac{\\Delta y^{4}}{4!} + \\mathcal{O}(\\Delta y^{5})$$\n$$u(y_1-\\Delta y) = u(y_1) - \\left.\\frac{\\partial u}{\\partial y}\\right|_{y_1}\\Delta y + \\left.\\frac{\\partial^{2} u}{\\partial y^{2}}\\right|_{y_1}\\frac{\\Delta y^{2}}{2!} - \\left.\\frac{\\partial^{3} u}{\\partial y^{3}}\\right|_{y_1}\\frac{\\Delta y^{3}}{3!} + \\left.\\frac{\\partial^{4} u}{\\partial y^{4}}\\right|_{y_1}\\frac{\\Delta y^{4}}{4!} - \\mathcal{O}(\\Delta y^{5})$$\nSubstituting these into the numerator of the discrete Laplacian:\n$$u(y_1+\\Delta y) - 2u(y_1) + u(y_1-\\Delta y) = \\left(2u(y_1) + 2\\left.\\frac{\\partial^{2} u}{\\partial y^{2}}\\right|_{y_1}\\frac{\\Delta y^{2}}{2} + 2\\left.\\frac{\\partial^{4} u}{\\partial y^{4}}\\right|_{y_1}\\frac{\\Delta y^{4}}{24} + \\dots\\right) - 2u(y_1)$$\n$$= \\left.\\frac{\\partial^{2} u}{\\partial y^{2}}\\right|_{y_1} \\Delta y^{2} + \\left.\\frac{\\partial^{4} u}{\\partial y^{4}}\\right|_{y_1} \\frac{\\Delta y^{4}}{12} + \\mathcal{O}(\\Delta y^{6})$$\nNow, we divide by $\\Delta y^{2}$ to get the full expression for the discrete operator:\n$$\\frac{u(y_1+\\Delta y)-2u(y_1)+u(y_1-\\Delta y)}{\\Delta y^{2}} = \\left.\\frac{\\partial^{2} u}{\\partial y^{2}}\\right|_{y_1} + \\left.\\frac{\\partial^{4} u}{\\partial y^{4}}\\right|_{y_1} \\frac{\\Delta y^{2}}{12} + \\mathcal{O}(\\Delta y^{4})$$\nThe truncation error is the difference between this expression and the exact derivative:\n$$\\tau = \\left(\\left.\\frac{\\partial^{2} u}{\\partial y^{2}}\\right|_{y_1} + \\left.\\frac{\\partial^{4} u}{\\partial y^{4}}\\right|_{y_1} \\frac{\\Delta y^{2}}{12} + \\mathcal{O}(\\Delta y^{4})\\right) - \\left.\\frac{\\partial^{2} u}{\\partial y^{2}}\\right|_{y_1}$$\n$$\\tau = \\left.\\frac{\\partial^{4} u}{\\partial y^{4}}\\right|_{y_1} \\frac{\\Delta y^{2}}{12} + \\mathcal{O}(\\Delta y^{4})$$\nThe leading-order truncation error term is the first term in this series. As requested, it is expressed in terms of $\\Delta y$ and a derivative of $u$ evaluated at $y=\\frac{1}{2}\\Delta y$:\n$$\\text{Leading-order TE} = \\frac{\\Delta y^{2}}{12} \\left.\\frac{\\partial^{4} u}{\\partial y^{4}}\\right|_{y=\\frac{1}{2}\\Delta y}$$\n\nThe final answer requires a matrix of the four face values and the truncation error term.\n1. $u_{i+\\frac{1}{2},0} = -u_{i+\\frac{1}{2},1}$\n2. $u_{i+\\frac{1}{2},N_{y}+1} = -u_{i+\\frac{1}{2},N_{y}}$\n3. $v_{i,0} = 0$\n4. $v_{i,N_{y}} = 0$\n5. Leading-order TE = $\\frac{\\Delta y^{2}}{12} \\left.\\frac{\\partial^{4} u}{\\partial y^{4}}\\right|_{y=\\frac{1}{2}\\Delta y}$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-u_{i+\\frac{1}{2},1} & -u_{i+\\frac{1}{2},N_{y}} & 0 & 0 & \\frac{\\Delta y^2}{12} \\left.\\frac{\\partial^4 u}{\\partial y^4}\\right|_{y=\\frac{1}{2}\\Delta y}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "The nonlinear advection term, $(\\mathbf{u} \\cdot \\nabla)\\mathbf{u}$, is often the most challenging part of the Navier-Stokes equations to discretize accurately and stably. This advanced practice guides you through the discretization of the advection term, highlighting a key feature of the staggered grid: the need for careful interpolation of velocity components between different face locations. By implementing a higher-order, mixed-discretization scheme and evaluating its error, you will tackle one of the central challenges in developing an incompressible flow solver .",
            "id": "3996786",
            "problem": "Consider an incompressible, inviscid convective term discretized on a Marker-And-Cell (MAC) grid for computational fluid dynamics in aerospace engineering. The MAC grid stores velocity components staggered on cell faces in a three-dimensional, periodic domain of extent $L_x=L_y=L_z=2\\pi$. There are $N_x$, $N_y$, and $N_z$ control volumes along the $x$, $y$, and $z$ directions, respectively, with uniform spacings $\\Delta x=L_x/N_x$, $\\Delta y=L_y/N_y$, and $\\Delta z=L_z/N_z$. The face locations are defined as follows: $u$-faces are located at $(x=i\\Delta x,\\ y=(j+\\tfrac{1}{2})\\Delta y,\\ z=(k+\\tfrac{1}{2})\\Delta z)$ for integer indices $i\\in[0,N_x-1]$, $j\\in[0,N_y-1]$, $k\\in[0,N_z-1]$; $v$-faces are located at $(x=(i+\\tfrac{1}{2})\\Delta x,\\ y=j\\Delta y,\\ z=(k+\\tfrac{1}{2})\\Delta z)$; and $w$-faces are located at $(x=(i+\\tfrac{1}{2})\\Delta x,\\ y=(j+\\tfrac{1}{2})\\Delta y,\\ z=k\\Delta z)$. All directions are periodic.\n\nStarting from the convective derivative of the incompressible Navier–Stokes equations, the $x$-component advective term is defined as $(\\mathbf{u}\\cdot\\nabla)u_x=u_x\\,\\partial u_x/\\partial x+u_y\\,\\partial u_x/\\partial y+u_z\\,\\partial u_x/\\partial z$, evaluated at $u$-faces. You are given the analytic velocity field $\\mathbf{u}(x,y,z)=(\\sin x,\\sin y,\\sin z)$. Sample the components onto their respective faces according to their definitions above. On this staggered arrangement, compute the discrete approximation of $(\\mathbf{u}\\cdot\\nabla)u_x$ at all $u$-faces using:\n- second-order upwind differencing in the streamwise direction for $\\partial u_x/\\partial x$ at each $u$-face, with the local upwind direction chosen by the sign of the face value $u_x$ at that $u$-face, that is,\n$$\n\\left.\\frac{\\partial u_x}{\\partial x}\\right|_{i,j,k} \\approx\n\\begin{cases}\n\\frac{3u_{i,j,k}-4u_{i-1,j,k}+u_{i-2,j,k}}{2\\Delta x},  \\text{if } u_{i,j,k} \\ge 0 \\\\[1.0em]\n\\frac{-3u_{i,j,k}+4u_{i+1,j,k}-u_{i+2,j,k}}{2\\Delta x},  \\text{if } u_{i,j,k}  0\n\\end{cases}\n$$\nwith periodic indexing in $i$;\n- second-order central differencing for the cross-stream derivatives $\\partial u_x/\\partial y$ and $\\partial u_x/\\partial z$ at $u$-faces,\n$$\n\\left.\\frac{\\partial u_x}{\\partial y}\\right|_{i,j,k} \\approx \\frac{u_{i,j+1,k}-u_{i,j-1,k}}{2\\Delta y},\\qquad\n\\left.\\frac{\\partial u_x}{\\partial z}\\right|_{i,j,k} \\approx \\frac{u_{i,j,k+1}-u_{i,j,k-1}}{2\\Delta z},\n$$\nwith periodic indexing in $j$ and $k$.\n\nTo evaluate the cross-stream contributions $u_y\\,\\partial u_x/\\partial y$ and $u_z\\,\\partial u_x/\\partial z$ at $u$-faces, interpolate $u_y$ (stored at $v$-faces) and $u_z$ (stored at $w$-faces) to the $u$-face location by simple arithmetic averaging of the four nearest face-centered values in the corresponding orthogonal planes:\n- for $u_y$ at the $u$-face $(i,j,k)$, average $v$-faces at $(i-\\tfrac{1}{2},j,k)$, $(i+\\tfrac{1}{2},j,k)$, $(i-\\tfrac{1}{2},j+1,k)$, $(i+\\tfrac{1}{2},j+1,k)$;\n- for $u_z$ at the $u$-face $(i,j,k)$, average $w$-faces at $(i-\\tfrac{1}{2},j,k)$, $(i+\\tfrac{1}{2},j,k)$, $(i-\\tfrac{1}{2},j,k+1)$, $(i+\\tfrac{1}{2},j,k+1)$.\n\nThe exact analytic convective derivative at $u$-faces is obtained by evaluating the continuous expression $(\\mathbf{u}\\cdot\\nabla)u_x$ at the $u$-face coordinates. For the given field, this reduces to $u_x\\,\\partial u_x/\\partial x=\\sin x\\cdot\\cos x$ at the $u$-face $x$-locations, since $\\partial u_x/\\partial y=0$ and $\\partial u_x/\\partial z=0$ in the continuum.\n\nDefine the dispersion error as the relative discrete $L^2$ norm of the difference between the computed discrete convective derivative and the exact analytic value over all $u$-faces,\n$$\nE_2=\\frac{\\left(\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\sum_{k=0}^{N_z-1}\\left[\\left((\\mathbf{u}\\cdot\\nabla)u_x\\right)_{\\text{num}}-\\left((\\mathbf{u}\\cdot\\nabla)u_x\\right)_{\\text{exact}}\\right]^2\\right)^{1/2}}{\\left(\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\sum_{k=0}^{N_z-1}\\left[\\left((\\mathbf{u}\\cdot\\nabla)u_x\\right)_{\\text{exact}}\\right]^2\\right)^{1/2}}.\n$$\n\nYour program must implement this computation for the following test suite of grid resolutions:\n- Case $1$: $(N_x,N_y,N_z)=(16,16,16)$;\n- Case $2$: $(N_x,N_y,N_z)=(32,32,32)$;\n- Case $3$: $(N_x,N_y,N_z)=(64,64,64)$.\n\nAll indexing in $i$, $j$, and $k$ must be handled with periodic wrap-around. Your program should produce a single line of output containing the dispersion errors for the three cases as a comma-separated list enclosed in square brackets, for example, $[e_1,e_2,e_3]$, where each $e_m$ is a floating-point number representing $E_2$ for Case $m$.",
            "solution": "The problem requires the computation of the dispersion error for a specific finite difference discretization of the convective term of the incompressible Navier-Stokes equations. The analysis is performed on a three-dimensional, periodic Marker-And-Cell (MAC) grid for a given analytic velocity field.\n\nThe primary objective is to evaluate the accuracy of the numerical scheme by comparing the computed result to the exact analytical value. The methodology involves three main stages: sampling the continuous velocity field onto the staggered grid, applying the specified finite difference and interpolation schemes to compute the discrete convective term, and finally, calculating the relative $L^2$ norm of the error.\n\nFirst, we define the computational domain and grid structure. The domain is a cube of side length $L_x = L_y = L_z = 2\\pi$. This domain is discretized into $N_x \\times N_y \\times N_z$ control volumes, resulting in uniform grid spacings of $\\Delta x = 2\\pi/N_x$, $\\Delta y = 2\\pi/N_y$, and $\\Delta z = 2\\pi/N_z$. The velocity components are staggered:\n-   $x$-velocity components $u_{i,j,k}$ are located at coordinates $(x_i, y_{j+1/2}, z_{k+1/2})$, where $x_i = i\\Delta x$, $y_{j+1/2} = (j+\\frac{1}{2})\\Delta y$, and $z_{k+1/2} = (k+\\frac{1}{2})\\Delta z$.\n-   $y$-velocity components $v_{i,j,k}$ are at $(x_{i+1/2}, y_j, z_{k+1/2})$, where $x_{i+1/2} = (i+\\frac{1}{2})\\Delta x$, $y_j = j\\Delta y$, and $z_{k+1/2} = (k+\\frac{1}{2})\\Delta z$.\n-   $z$-velocity components $w_{i,j,k}$ are at $(x_{i+1/2}, y_{j+1/2}, z_k)$, where $x_{i+1/2} = (i+\\frac{1}{2})\\Delta x$, $y_{j+1/2} = (j+\\frac{1}{2})\\Delta y$, and $z_k = k\\Delta z$.\nThe indices range from $i=0, \\dots, N_x-1$, $j=0, \\dots, N_y-1$, and $k=0, \\dots, N_z-1$. All indices are handled with periodic wrap-around.\n\nThe given analytic velocity field is $\\mathbf{u}(x,y,z) = (u_x, u_y, u_z) = (\\sin x, \\sin y, \\sin z)$. We sample this field at the face-centered locations defined above:\n-   $u_{i,j,k} = \\sin(x_i) = \\sin(i\\Delta x)$\n-   $v_{i,j,k} = \\sin(y_j) = \\sin(j\\Delta y)$\n-   $w_{i,j,k} = \\sin(z_k) = \\sin(k\\Delta z)$\n\nThe target of our discretization is the $x$-component of the convective derivative, $(\\mathbf{u}\\cdot\\nabla)u_x$, which is evaluated at the $u$-face locations $(i,j,k)$. The expression expands to:\n$$\n(\\mathbf{u}\\cdot\\nabla)u_x = u_x\\frac{\\partial u_x}{\\partial x} + u_y\\frac{\\partial u_x}{\\partial y} + u_z\\frac{\\partial u_x}{\\partial z}\n$$\nThe analytical value of this expression is found by substituting the continuous velocity field. Since $u_x = \\sin x$ depends only on $x$, the cross-derivatives $\\partial u_x/\\partial y$ and $\\partial u_x/\\partial z$ are zero. The exact convective term is therefore:\n$$\n\\left((\\mathbf{u}\\cdot\\nabla)u_x\\right)_{\\text{exact}} = (\\sin x)\\frac{\\partial}{\\partial x}(\\sin x) = \\sin x \\cos x\n$$\nThis is evaluated at the $u$-face locations, specifically at the coordinates $x_i=i\\Delta x$.\n\nNext, we construct the discrete approximation, $((\\mathbf{u}\\cdot\\nabla)u_x)_{\\text{num}}$, term by term.\n\n1.  **Streamwise contribution $u_x \\frac{\\partial u_x}{\\partial x}$**: The derivative $\\frac{\\partial u_x}{\\partial x}$ is approximated using a second-order upwind scheme. The direction of upwinding depends on the sign of the local velocity $u_{i,j,k}$.\n    -   If $u_{i,j,k} \\ge 0$, a backward difference is used: $\\left.\\frac{\\partial u_x}{\\partial x}\\right|_{i,j,k} \\approx \\frac{3u_{i,j,k}-4u_{i-1,j,k}+u_{i-2,j,k}}{2\\Delta x}$.\n    -   If $u_{i,j,k}  0$, a forward difference is used: $\\left.\\frac{\\partial u_x}{\\partial x}\\right|_{i,j,k} \\approx \\frac{-3u_{i,j,k}+4u_{i+1,j,k}-u_{i+2,j,k}}{2\\Delta x}$.\n    The case $u_{i,j,k}=0$ is handled by the first condition, a common convention. Periodicity is enforced on the index $i$. This derivative is then multiplied by $u_{i,j,k}$.\n\n2.  **First cross-stream contribution $u_y \\frac{\\partial u_x}{\\partial y}$**: This term involves two parts: a derivative and an interpolation.\n    -   The derivative $\\frac{\\partial u_x}{\\partial y}$ is approximated at the $u$-face $(i,j,k)$ using a second-order central difference scheme: $\\left.\\frac{\\partial u_x}{\\partial y}\\right|_{i,j,k} \\approx \\frac{u_{i,j+1,k}-u_{i,j-1,k}}{2\\Delta y}$, with periodic indexing in $j$.\n    -   The velocity component $u_y$ is not natively available at the $u$-face. It is interpolated from the four nearest $v$-faces. The interpolated value, $\\tilde{u}_y|_{i,j,k}$, is the arithmetic mean:\n    $$\n    \\tilde{u}_y|_{i,j,k} = \\frac{1}{4}(v_{i-1,j,k} + v_{i,j,k} + v_{i-1,j+1,k} + v_{i,j+1,k})\n    $$\n    Here, periodicity applies to both $i$ and $j$ indices.\n\n3.  **Second cross-stream contribution $u_z \\frac{\\partial u_x}{\\partial z}$**: This term is handled analogously.\n    -   The derivative $\\frac{\\partial u_x}{\\partial z}$ is approximated by a second-order central difference: $\\left.\\frac{\\partial u_x}{\\partial z}\\right|_{i,j,k} \\approx \\frac{u_{i,j,k+1}-u_{i,j,k-1}}{2\\Delta z}$, with periodic indexing in $k$.\n    -   The velocity component $u_z$ is interpolated from the four nearest $w$-faces. The interpolated value, $\\tilde{u}_z|_{i,j,k}$, is the arithmetic mean:\n    $$\n    \\tilde{u}_z|_{i,j,k} = \\frac{1}{4}(w_{i-1,j,k} + w_{i,j,k} + w_{i-1,j,k+1} + w_{i,j,k+1})\n    $$\n    Periodicity applies to indices $i$ and $k$.\n\nThe full numerical approximation of the convective term is the sum of these three contributions evaluated at each $u$-face $(i,j,k)$:\n$$\n((\\mathbf{u}\\cdot\\nabla)u_x)_{\\text{num}} = u_{i,j,k}\\left(\\frac{\\partial u_x}{\\partial x}\\right)_{\\text{upwind}} + \\tilde{u}_y|_{i,j,k}\\left(\\frac{\\partial u_x}{\\partial y}\\right)_{\\text{central}} + \\tilde{u}_z|_{i,j,k}\\left(\\frac{\\partial u_x}{\\partial z}\\right)_{\\text{central}}\n$$\n\nFinally, we quantify the dispersion error using the discrete relative $L^2$ norm, $E_2$:\n$$\nE_2=\\frac{\\Norm{\\left((\\mathbf{u}\\cdot\\nabla)u_x\\right)_{\\text{num}}-\\left((\\mathbf{u}\\cdot\\nabla)u_x\\right)_{\\text{exact}}}_2}{\\Norm{\\left((\\mathbf{u}\\cdot\\nabla)u_x\\right)_{\\text{exact}}}_2}\n$$\nwhere the discrete $L^2$ norm of a 3D field $F_{i,j,k}$ is defined as $\\Norm{F}_2 = \\left(\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\sum_{k=0}^{N_z-1} F_{i,j,k}^2\\right)^{1/2}$.\n\nThis entire procedure is implemented for each grid resolution specified in the test suite to obtain the corresponding error values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the dispersion error for a MAC grid discretization of the\n    convective term for three different grid resolutions.\n    \"\"\"\n    test_cases = [\n        (16, 16, 16),\n        (32, 32, 32),\n        (64, 64, 64),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        Nx, Ny, Nz = case\n        Lx, Ly, Lz = 2 * np.pi, 2 * np.pi, 2 * np.pi\n        dx, dy, dz = Lx / Nx, Ly / Ny, Lz / Nz\n\n        # 1. Sample the velocity field onto the staggered grid\n        # u is at (i*dx, (j+0.5)*dy, (k+0.5)*dz) - u = sin(i*dx)\n        x_u_coords = np.arange(Nx) * dx\n        u_1d = np.sin(x_u_coords)\n        u_grid = np.broadcast_to(u_1d[:, None, None], (Nx, Ny, Nz))\n\n        # v is at ((i+0.5)*dx, j*dy, (k+0.5)*dz) - v = sin(j*dy)\n        y_v_coords = np.arange(Ny) * dy\n        v_1d = np.sin(y_v_coords)\n        v_grid = np.broadcast_to(v_1d[None, :, None], (Nx, Ny, Nz))\n\n        # w is at ((i+0.5)*dx, (j+0.5)*dy, k*dz) - w = sin(k*dz)\n        z_w_coords = np.arange(Nz) * dz\n        w_1d = np.sin(z_w_coords)\n        w_grid = np.broadcast_to(w_1d[None, None, :], (Nx, Ny, Nz))\n\n        # 2. Compute the numerical convective derivative\n        \n        # Term 1: u * du/dx (second-order upwind)\n        u_ip1 = np.roll(u_grid, -1, axis=0)\n        u_ip2 = np.roll(u_grid, -2, axis=0)\n        u_im1 = np.roll(u_grid, 1, axis=0)\n        u_im2 = np.roll(u_grid, 2, axis=0)\n        \n        dudx_backward = (3 * u_grid - 4 * u_im1 + u_im2) / (2 * dx) # for u = 0\n        dudx_forward = (-3 * u_grid + 4 * u_ip1 - u_ip2) / (2 * dx) # for u  0\n        \n        dudx = np.where(u_grid = 0, dudx_backward, dudx_forward)\n        term1 = u_grid * dudx\n\n        # Term 2: u_y_interp * du/dy (central difference)\n        # Interpolate v to u-face locations\n        # avg of v(i-1,j), v(i,j), v(i-1,j+1), v(i,j+1)\n        v_im1 = np.roll(v_grid, 1, axis=0)\n        v_jp1 = np.roll(v_grid, -1, axis=1)\n        v_im1_jp1 = np.roll(v_im1, -1, axis=1)\n        vy_interp = 0.25 * (v_im1 + v_grid + v_im1_jp1 + v_jp1)\n        \n        # d(u_x)/dy at u-faces\n        u_jp1 = np.roll(u_grid, -1, axis=1)\n        u_jm1 = np.roll(u_grid, 1, axis=1)\n        dudy = (u_jp1 - u_jm1) / (2 * dy)\n        term2 = vy_interp * dudy\n        \n        # Term 3: u_z_interp * du/dz (central difference)\n        # Interpolate w to u-face locations\n        # avg of w(i-1,j,k), w(i,j,k), w(i-1,j,k+1), w(i,j,k+1)\n        w_im1 = np.roll(w_grid, 1, axis=0)\n        w_kp1 = np.roll(w_grid, -1, axis=2)\n        w_im1_kp1 = np.roll(w_im1, -1, axis=2)\n        wz_interp = 0.25 * (w_im1 + w_grid + w_im1_kp1 + w_kp1)\n        \n        # d(u_x)/dz at u-faces\n        u_kp1 = np.roll(u_grid, -1, axis=2)\n        u_km1 = np.roll(u_grid, 1, axis=2)\n        dudz = (u_kp1 - u_km1) / (2 * dz)\n        term3 = wz_interp * dudz\n\n        adv_num = term1 + term2 + term3\n\n        # 3. Compute the exact convective derivative\n        adv_exact_1d = np.sin(x_u_coords) * np.cos(x_u_coords)\n        adv_exact = np.broadcast_to(adv_exact_1d[:, None, None], (Nx, Ny, Nz))\n\n        # 4. Calculate the dispersion error E2\n        norm_error = np.linalg.norm(adv_num - adv_exact)\n        norm_exact = np.linalg.norm(adv_exact)\n        \n        # Handle case where norm_exact is zero to avoid division by zero\n        if norm_exact == 0:\n            # This should not happen for the given problem parameters\n            error = 0.0 if norm_error == 0 else np.inf\n        else:\n            error = norm_error / norm_exact\n            \n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}