{
    "hands_on_practices": [
        {
            "introduction": "The heart of the dual time-stepping method is the physical-time residual that the inner iterations are designed to drive to zero. This first exercise tasks you with deriving this residual for the widely-used second-order backward differentiation formula (BDF2), starting from the fundamental semi-discrete conservation laws . Mastering this derivation is a crucial step that establishes the mathematical foundation for any high-order accurate, implicit unsteady simulation.",
            "id": "3956096",
            "problem": "Consider a semi-discrete finite volume formulation of the compressible Navier–Stokes equations used in Computational Fluid Dynamics (CFD), yielding the ordinary differential equation $$\\mathbf{M}\\,\\frac{d\\mathbf{U}}{dt}+\\mathbf{R}(\\mathbf{U})=\\mathbf{0},$$ where $\\mathbf{U}(t)\\in\\mathbb{R}^{N}$ is the vector of conservative cell-averaged unknowns, $\\mathbf{M}\\in\\mathbb{R}^{N\\times N}$ is a (possibly block-diagonal) mass matrix arising from cell volumes and quadrature, and $\\mathbf{R}(\\mathbf{U})$ is the spatial residual that includes flux divergences and source terms. To advance the solution from physical time $t^{n}$ to $t^{n+1}=t^{n}+\\Delta t$, you adopt dual time-stepping: introduce a pseudo-time $\\tau$ and iteratively drive to zero a dual-time residual $\\mathcal{G}(\\mathbf{U})$ corresponding to the physical-time discretization at $t^{n+1}$. Use the second-order backward differentiation formula (BDF, order $2$), assume a uniform physical time step $\\Delta t$, and treat $\\mathbf{U}^{n}$ and $\\mathbf{U}^{n-1}$ as known past states.\n\nStarting only from the semi-discrete unsteady balance $\\mathbf{M}\\,d\\mathbf{U}/dt+\\mathbf{R}(\\mathbf{U})=\\mathbf{0}$ and the definition of the second-order backward differentiation formula via polynomial interpolation or Taylor series consistency, derive the closed-form expression for the dual-time residual $\\mathcal{G}(\\mathbf{U})$ to be driven to zero by pseudo-time iterations when forming the update to $\\mathbf{U}^{n+1}$. Then, discuss the storage implications of using the second-order backward differentiation formula in dual time-stepping, in terms of the minimum number of solution state vectors that must be retained across physical time steps and any additional structures that are typically required for implicit pseudo-time integration.\n\nExpress your final answer for $\\mathcal{G}(\\mathbf{U})$ as a single analytic expression in terms of $\\mathbf{M}$, $\\Delta t$, $\\mathbf{U}$, $\\mathbf{U}^{n}$, $\\mathbf{U}^{n-1}$, and $\\mathbf{R}(\\cdot)$. No numerical evaluation is required.",
            "solution": "The fundamental starting point is the semi-discrete conservation law\n$$\n\\mathbf{M}\\,\\frac{d\\mathbf{U}}{dt}+\\mathbf{R}(\\mathbf{U})=\\mathbf{0},\n$$\nwhere $\\mathbf{M}$ collects control-volume measures and $\\mathbf{R}(\\mathbf{U})$ represents spatial discretization of fluxes and sources. In dual time-stepping, one defines a pseudo-time $\\tau$ and solves, at each physical time step, a pseudo-transient problem of the form\n$$\n\\mathbf{M}\\,\\frac{\\partial \\mathbf{U}}{\\partial \\tau} + \\mathcal{G}(\\mathbf{U})=\\mathbf{0},\n$$\ndriving $\\mathcal{G}(\\mathbf{U})\\to\\mathbf{0}$ so that the physical-time discretized balance at $t^{n+1}$ is satisfied. Thus, $\\mathcal{G}(\\mathbf{U})$ is the residual associated with the chosen physical-time discretization applied at $t^{n+1}$, with $\\mathbf{U}$ in pseudo-time iterations representing the current iterate for $\\mathbf{U}^{n+1}$.\n\nTo construct $\\mathcal{G}(\\mathbf{U})$ for the second-order backward differentiation formula (BDF of order $2$), we approximate the physical-time derivative at $t^{n+1}$ using past values $\\mathbf{U}^{n}$ and $\\mathbf{U}^{n-1}$ and the current (unknown) $\\mathbf{U}^{n+1}$. Let the physical time grid be uniform with step $\\Delta t$, so $t^{n+1}=t^{n}+\\Delta t$ and $t^{n-1}=t^{n}-\\Delta t$. Define $j\\in\\{0,1,2\\}$ such that the points are $t^{n+1-j}$. We seek coefficients $a_{j}$ satisfying\n$$\n\\frac{d\\mathbf{U}}{dt}\\bigg|_{t^{n+1}} \\approx \\frac{1}{\\Delta t}\\sum_{j=0}^{2} a_{j}\\,\\mathbf{U}^{n+1-j},\n$$\nwith consistency conditions derived from a Taylor expansion about $t^{n+1}$. Expand\n$$\n\\mathbf{U}^{n+1-j} = \\mathbf{U}^{n+1} + (-j)\\Delta t\\,\\mathbf{U}'(t^{n+1}) + \\frac{(-j)^{2}\\Delta t^{2}}{2}\\,\\mathbf{U}''(t^{n+1}) + \\frac{(-j)^{3}\\Delta t^{3}}{6}\\,\\mathbf{U}'''(t^{n+1}) + \\cdots.\n$$\nWe require that\n$$\n\\sum_{j=0}^{2} a_{j}\\,\\mathbf{U}^{n+1-j} = \\Delta t\\,\\mathbf{U}'(t^{n+1}) + \\mathcal{O}(\\Delta t^{3}),\n$$\nwhich imposes the order conditions\n$$\n\\sum_{j=0}^{2} a_{j} = 0,\\qquad \\sum_{j=0}^{2} a_{j}(-j) = 1,\\qquad \\sum_{j=0}^{2} a_{j}\\frac{(-j)^{2}}{2} = 0.\n$$\nWriting these explicitly for $j\\in\\{0,1,2\\}$,\n$$\na_{0}+a_{1}+a_{2}=0,\\qquad -a_{1}-2a_{2}=1,\\qquad \\frac{a_{1}+4a_{2}}{2}=0.\n$$\nSolving,\n$$\na_{1}=-4a_{2},\\quad 4a_{2}-2a_{2}=1\\Rightarrow 2a_{2}=1\\Rightarrow a_{2}=\\frac{1}{2},\\quad a_{1}=-2,\\quad a_{0}= -a_{1}-a_{2}=\\frac{3}{2}.\n$$\nTherefore,\n$$\n\\frac{d\\mathbf{U}}{dt}\\bigg|_{t^{n+1}} \\approx \\frac{1}{\\Delta t}\\left(\\frac{3}{2}\\mathbf{U}^{n+1}-2\\mathbf{U}^{n}+\\frac{1}{2}\\mathbf{U}^{n-1}\\right).\n$$\nEnforcing the semi-discrete balance at $t^{n+1}$ with this approximation gives\n$$\n\\mathbf{M}\\,\\frac{1}{\\Delta t}\\left(\\frac{3}{2}\\mathbf{U}^{n+1}-2\\mathbf{U}^{n}+\\frac{1}{2}\\mathbf{U}^{n-1}\\right)+\\mathbf{R}(\\mathbf{U}^{n+1})=\\mathbf{0}.\n$$\nIn dual time-stepping, the pseudo-time iterations use $\\mathbf{U}$ to denote the current approximation to $\\mathbf{U}^{n+1}$ inside the nonlinear residual. Consequently, the dual-time residual to be driven to zero is\n$$\n\\mathcal{G}(\\mathbf{U}) = \\mathbf{R}(\\mathbf{U}) + \\frac{\\mathbf{M}}{\\Delta t}\\left(\\frac{3}{2}\\mathbf{U}-2\\mathbf{U}^{n}+\\frac{1}{2}\\mathbf{U}^{n-1}\\right).\n$$\n\nStorage implications: Using the second-order backward differentiation formula requires access to two historical solution states, namely $\\mathbf{U}^{n}$ and $\\mathbf{U}^{n-1}$, in addition to the current iterate $\\mathbf{U}$ for $\\mathbf{U}^{n+1}$. Thus, compared to first-order backward Euler (which retains only $\\mathbf{U}^{n}$), BDF of order $2$ increases the minimum retained state history to two prior vectors. In implicit dual-time integration, one typically also stores a Jacobian or an approximation thereof (for example, $\\partial \\mathcal{G}/\\partial \\mathbf{U}$) to accelerate convergence via Newton or quasi-Newton methods, and, depending on implementation, the mass matrix $\\mathbf{M}$ if it is not trivially diagonal or easily applied. For large-scale aerospace CFD, this implies an additional vector of storage for $\\mathbf{U}^{n-1}$ and potentially extra operator storage for linear solves in the pseudo-time iterations, while the residual structure itself introduces no further state history beyond $\\mathbf{U}^{n}$ and $\\mathbf{U}^{n-1}$.",
            "answer": "$$\\boxed{\\mathcal{G}(\\mathbf{U})=\\mathbf{R}(\\mathbf{U})+\\frac{\\mathbf{M}}{\\Delta t}\\left(\\frac{3}{2}\\mathbf{U}-2\\mathbf{U}^{n}+\\frac{1}{2}\\mathbf{U}^{n-1}\\right)}$$"
        },
        {
            "introduction": "With the residual correctly formulated, the next challenge is solving the resulting non-linear system efficiently. This hands-on coding exercise uses a classic 1D convection-diffusion model to explore the practical behavior of the inner pseudo-time iterations . By implementing a simple iterative solver, you will investigate how the physical time step $\\Delta t$ introduces stiffness and directly impacts the convergence rate, connecting abstract spectral theory to concrete iteration counts.",
            "id": "3956124",
            "problem": "You are to construct and analyze a stiff linear convection–diffusion model in one spatial dimension to study Dual Time Stepping (DTS) in Computational Fluid Dynamics (CFD). Begin from the partial differential equation\n$$\n\\frac{\\partial u}{\\partial t} = -a\\,\\frac{\\partial u}{\\partial x} + \\nu\\,\\frac{\\partial^2 u}{\\partial x^2},\n$$\nwhere $u(x,t)$ is the transported-diffused scalar, $a$ is the convection speed, and $\\nu$ is the kinematic viscosity. Use a periodic domain of length $L_x$ with $x \\in [0,L_x]$ and periodic boundary conditions. Discretize the spatial derivatives on a uniform grid with $N$ points and spacing $\\Delta x = L_x/N$, using first-order upwind for the convection term and second-order central differences for the diffusion term. Let the discrete spatial operator be the $N \\times N$ matrix $\\mathbf{L}$ such that the semi-discrete system is\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{L}\\,\\mathbf{u},\n$$\nwith\n$$\n\\mathbf{L}\\,\\mathbf{u} \\approx -a\\,\\frac{\\mathbf{u}_i - \\mathbf{u}_{i-1}}{\\Delta x} + \\nu\\,\\frac{\\mathbf{u}_{i+1} - 2\\,\\mathbf{u}_i + \\mathbf{u}_{i-1}}{\\Delta x^2},\n$$\nwhere indices are modulo $N$ to enforce periodicity. Advance the solution in physical time using an implicit backward Euler step from $t^n$ to $t^{n+1}$:\n$$\n\\mathbf{u}^{n+1} - \\mathbf{u}^{n} = \\Delta t\\,\\mathbf{L}\\,\\mathbf{u}^{n+1}.\n$$\nThis can be written as the nonlinear residual equation\n$$\n\\mathbf{F}(\\mathbf{u}^{n+1}) = \\mathbf{u}^{n+1} - \\mathbf{u}^n - \\Delta t\\,\\mathbf{L}\\,\\mathbf{u}^{n+1} = \\mathbf{0},\n$$\nwhose Jacobian is the linear matrix\n$$\n\\mathbf{J} = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{u}} = \\mathbf{I} - \\Delta t\\,\\mathbf{L}.\n$$\nIn Dual Time Stepping, solve $\\mathbf{F}(\\mathbf{u}^{n+1}) = \\mathbf{0}$ by introducing a pseudo-time $\\tau$ and marching the auxiliary system\n$$\n\\frac{d\\mathbf{u}}{d\\tau} + \\mathbf{F}(\\mathbf{u}) = \\mathbf{0}.\n$$\nImplement forward Euler in pseudo-time, which for the linear residual yields a Richardson-like iteration:\n$$\n\\mathbf{u}^{k+1} = \\mathbf{u}^{k} - \\omega\\,\\mathbf{F}(\\mathbf{u}^k), \\quad \\omega > 0,\n$$\nstarting from the initial guess $\\mathbf{u}^0 = \\mathbf{u}^n$. Choose the pseudo-time step parameter $\\omega$ based on the spectral radius estimate of $\\mathbf{J}$ so as to promote convergence. Measure the number of pseudo-time iterations $k$ needed so that the residual norm satisfies\n$$\n\\|\\mathbf{F}(\\mathbf{u}^{k})\\|_2 \\le \\varepsilon\\,\\|\\mathbf{F}(\\mathbf{u}^{0})\\|_2,\n$$\nfor a prescribed tolerance $0 < \\varepsilon \\ll 1$.\n\nFrom first principles, justify how the stiffness of the discrete operator emerges as the grid is refined and how increasing the physical time step $\\Delta t$ challenges inner convergence in the pseudo-time iterations. Use the spectral properties of $\\mathbf{J}$ to estimate the contraction factor of the iteration and thus predict iteration counts. Compare these predictions to measured counts.\n\nScientific and numerical setup:\n- Use $L_x = 1$ (in meters), $N = 64$, $a = 20$ (in meters per second), and $\\nu = 10^{-2}$ (in square meters per second).\n- Use the initial physical state $\\mathbf{u}^{n}_i = \\sin\\!\\left(2\\pi x_i\\right)$, where $x_i = i\\,\\Delta x$.\n- Employ a tolerance $\\varepsilon = 10^{-6}$ for the residual norm relative reduction.\n- All physical quantities must be treated in the specified units: $L_x$ in meters, $a$ in meters per second, $\\nu$ in square meters per second, and $\\Delta t$ in seconds. Angles, if any, must be in radians.\n\nTest suite:\n- Consider four physical time steps $\\Delta t$ in seconds that probe increasing stiffness and inner iteration difficulty: $\\Delta t \\in \\{5\\times 10^{-4},\\,2\\times 10^{-3},\\,10^{-2},\\,2\\times 10^{-2}\\}$.\n- For each $\\Delta t$, compute:\n  1. The measured pseudo-time iteration count required to reach the tolerance.\n  2. An estimate of the iteration count derived from spectral radius considerations of $\\mathbf{J}$ and the chosen $\\omega$, assuming a geometric error reduction model consistent with the spectral properties.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets. Each element should be a two-element list of integers in the form $[\\text{measured},\\text{estimated}]$, for example, $[[k_1,\\hat{k}_1],[k_2,\\hat{k}_2],[k_3,\\hat{k}_3],[k_4,\\hat{k}_4]]$.",
            "solution": "The user has requested a solution to a problem involving dual time-stepping for a 1D convection-diffusion equation. The first step is to validate the problem statement.\n\n### Step 1: Extract Givens\n- **Governing Equation:** The partial differential equation is given as $\\frac{\\partial u}{\\partial t} = -a\\,\\frac{\\partial u}{\\partial x} + \\nu\\,\\frac{\\partial^2 u}{\\partial x^2}$.\n- **Domain:** A one-dimensional periodic domain of length $L_x$ with $x \\in [0,L_x]$.\n- **Discretization Scheme:** A uniform grid with $N$ points and spacing $\\Delta x = L_x/N$. The convection term is discretized using first-order upwind, and the diffusion term with second-order central differences. The semi-discrete form is $\\frac{d\\mathbf{u}}{dt} = \\mathbf{L}\\,\\mathbf{u}$.\n- **Temporal Integration:** An implicit backward Euler scheme is used for physical time, leading to the equation $\\mathbf{u}^{n+1} - \\mathbf{u}^{n} = \\Delta t\\,\\mathbf{L}\\,\\mathbf{u}^{n+1}$.\n- **Residual and Jacobian:** The nonlinear residual is $\\mathbf{F}(\\mathbf{u}^{n+1}) = (\\mathbf{I} - \\Delta t\\,\\mathbf{L})\\mathbf{u}^{n+1} - \\mathbf{u}^n = \\mathbf{0}$, and its Jacobian is $\\mathbf{J} = \\mathbf{I} - \\Delta t\\,\\mathbf{L}$.\n- **Dual Time Stepping (DTS):** The system is solved by marching an auxiliary pseudo-time system $\\frac{d\\mathbf{u}}{d\\tau} + \\mathbf{F}(\\mathbf{u}) = \\mathbf{0}$ using forward Euler in pseudo-time. This results in the Richardson-like iteration $\\mathbf{u}^{k+1} = \\mathbf{u}^{k} - \\omega\\,\\mathbf{F}(\\mathbf{u}^k)$ with initial guess $\\mathbf{u}^0 = \\mathbf{u}^n$.\n- **Convergence Criterion:** The inner iterations stop when the residual norm is reduced by a factor of $\\varepsilon$, i.e., $\\|\\mathbf{F}(\\mathbf{u}^{k})\\|_2 \\le \\varepsilon\\,\\|\\mathbf{F}(\\mathbf{u}^{0})\\|_2$.\n- **Numerical Parameters:**\n    - $L_x = 1$ m\n    - $N = 64$\n    - $a = 20$ m/s\n    - $\\nu = 10^{-2}$ m²/s\n    - $\\varepsilon = 10^{-6}$\n- **Initial Condition:** The physical state at time $t^n$ is $\\mathbf{u}^{n}_i = \\sin(2\\pi x_i)$, with $x_i = i\\,\\Delta x$.\n- **Test Cases:** The physical time step $\\Delta t$ takes values from the set $\\{5\\times 10^{-4},\\,2\\times 10^{-3},\\,10^{-2},\\,2\\times 10^{-2}\\}$ s.\n- **Required Output:** For each $\\Delta t$, compute the measured iteration count and an estimated iteration count based on spectral analysis.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding:** The problem is based on the linear convection-diffusion equation, a cornerstone of fluid dynamics and transport phenomena. The numerical methods described—upwind and central differencing, backward Euler, and dual time-stepping (which is a form of preconditioned Richardson iteration)—are standard and widely used in computational science and engineering. The setup is scientifically rigorous.\n- **Well-Posedness & Completeness:** The problem is well-posed. The PDE with periodic boundary conditions is a standard problem. The discretization leads to a well-defined linear algebra problem. All necessary parameters, initial conditions, and convergence criteria are explicitly provided. The instruction to choose the pseudo-time-step parameter $\\omega$ based on the spectral radius of $\\mathbf{J}$ is a standard practice, and a reasonable interpretation (such as $\\omega = 1/\\rho(\\mathbf{J})$) can be reliably implemented. The problem is self-contained.\n- **Objectivity and Consistency:** The problem is stated in precise, objective, and mathematical language. There are no subjective claims or factual inaccuracies. The units are specified and consistent.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-defined, scientifically sound problem in numerical analysis and computational fluid dynamics. Proceeding with the solution.\n\n---\n### Principle-Based Design of the Solution\n\nThe core of the problem is to understand and quantify the performance of a Richardson-like iterative solver for the linear system arising from an implicit time-stepping scheme. The problem's difficulty is controlled by the physical time step $\\Delta t$.\n\n**1. Spectral Analysis of the Operators**\nThe semi-discrete system is $\\frac{d\\mathbf{u}}{dt} = \\mathbf{L}\\,\\mathbf{u}$. Due to the periodic boundary conditions and uniform grid, the spatial operator $\\mathbf{L}$ is a circulant matrix. Its eigenvectors are the discrete Fourier modes, $\\mathbf{v}_p$, with components $(\\mathbf{v}_p)_j = \\exp(i k_p x_j)$, where $k_p = 2\\pi p/L_x$ is the wavenumber and $p \\in \\{0, 1, \\dots, N-1\\}$. The corresponding eigenvalues, $\\lambda_L(p)$, are found by applying the discrete operator stencil to the eigenvector:\n$$ \\lambda_L(p) = -a \\frac{1-e^{-i\\theta_p}}{\\Delta x} + \\nu \\frac{e^{i\\theta_p} - 2 + e^{-i\\theta_p}}{\\Delta x^2} $$\nwhere $\\theta_p = k_p \\Delta x = 2\\pi p/N$. Simplifying this expression yields:\n$$ \\lambda_L(p) = -\\left(\\frac{a}{\\Delta x} + \\frac{2\\nu}{\\Delta x^2}\\right)(1-\\cos\\theta_p) - i \\left(\\frac{a}{\\Delta x}\\right)\\sin\\theta_p $$\nAll eigenvalues $\\lambda_L(p)$ have non-positive real parts, which is necessary for the stability of the physical system.\n\n**Stiffness emerged from grid refinement:** The terms $a/\\Delta x$ and $\\nu/\\Delta x^2$ in the eigenvalue expression control the \"spread\" of the spectrum. As the grid is refined, $\\Delta x \\to 0$, the $\\nu/\\Delta x^2$ term dominates and grows quadratically. This causes the magnitude of the eigenvalues, $|\\lambda_L(p)|$, to span a vastly larger range, from $|\\lambda_L(0)|=0$ to a very large maximum. This large ratio of extreme eigenvalues, $\\max|\\lambda_L|/\\min|\\lambda_L|$, is the definition of stiffness.\n\n**2. The Inner Iteration and Its Convergence**\nThe backward Euler step results in the linear system $(\\mathbf{I} - \\Delta t \\mathbf{L})\\mathbf{u}^{n+1} = \\mathbf{u}^n$, or $\\mathbf{J}\\mathbf{u}^{n+1} = \\mathbf{u}^n$. The dual-time stepping scheme is a Richardson iteration for solving this system:\n$$ \\mathbf{u}^{k+1} = \\mathbf{u}^{k} - \\omega (\\mathbf{J}\\mathbf{u}^k - \\mathbf{u}^n) $$\nThe error, $\\mathbf{e}^k = \\mathbf{u}^k - \\mathbf{u}^{n+1}$, evolves according to $\\mathbf{e}^{k+1} = (\\mathbf{I} - \\omega\\mathbf{J})\\mathbf{e}^k$. The convergence of this iteration is governed by the spectral radius of the iteration matrix $\\mathbf{G} = \\mathbf{I} - \\omega\\mathbf{J}$. Let this be $\\rho_G = \\rho(\\mathbf{G})$. The eigenvalues of $\\mathbf{J}$ are $\\lambda_J(p) = 1 - \\Delta t \\lambda_L(p)$, and a key observation is that $\\text{Re}(\\lambda_J(p)) \\ge 1$ for all $p$. The eigenvalues of $\\mathbf{G}$ are $\\lambda_G(p) = 1 - \\omega\\lambda_J(p)$. Convergence is guaranteed if we can choose $\\omega$ such that $\\rho_G = \\max_p|\\lambda_G(p)| < 1$.\n\n**3. Estimating a priori the Iteration Count**\nTo estimate the number of iterations, we first choose $\\omega$ and then compute the theoretical convergence rate, $\\rho_G$. The problem suggests basing $\\omega$ on the spectral radius of $\\mathbf{J}$, $\\rho_J = \\rho(\\mathbf{J}) = \\max_p|\\lambda_J(p)|$. A simple and common choice is $\\omega = 1/\\rho_J$. With this, the iteration matrix's eigenvalues are $\\lambda_G(p) = 1 - \\lambda_J(p)/\\rho_J$. The theoretical contraction factor is then $\\rho_G = \\max_p |1 - \\lambda_J(p)/\\rho_J|$.\n\nThe number of iterations $k$ required to reduce the residual norm by a factor of $\\varepsilon$ is modeled by $(\\rho_G)^k \\le \\varepsilon$. Solving for $k$ gives the estimate:\n$$ k_{\\text{est}} = \\left\\lceil \\frac{\\ln(\\varepsilon)}{\\ln(\\rho_G)} \\right\\rceil $$\n\n**The challenge of large $\\Delta t$:** As $\\Delta t$ increases, the eigenvalues $\\lambda_J(p) = 1 - \\Delta t\\lambda_L(p)$ spread out further in the complex plane. The minimum-modulus eigenvalue remains $\\lambda_J(0)=1$, while the maximum-modulus eigenvalue $\\rho_J$ grows, roughly proportionally to $\\Delta t$. The eigenvalue of the iteration matrix $\\mathbf{G}$ corresponding to the zero-frequency mode is $\\lambda_G(0) = 1 - \\omega\\lambda_J(0) = 1 - 1/\\rho_J$. As $\\Delta t$ increases, $\\rho_J$ becomes large, and $\\lambda_G(0)$ approaches $1$. A contraction factor close to $1$ signifies extremely slow convergence. This slow-down of the low-frequency error components is what makes the inner iterations more challenging for larger physical time steps.\n\n**4. Numerical Implementation**\nThe solution is implemented by first performing the spectral analysis for each given $\\Delta t$ to find $k_{\\text{est}}$. Then, a numerical simulation of the pseudo-time iteration is run to find the measured count, $k_{\\text{meas}}$. The spatial operator $\\mathbf{L}$ is applied using vector operations and `numpy.roll` to efficiently handle the periodic boundary conditions. The $\\ell_2$-norm is used for all residual calculations.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes a stiff linear convection–diffusion model\n    to study Dual Time Stepping (DTS) in aerospace CFD.\n    \"\"\"\n    # Scientific and numerical setup from the problem statement.\n    Lx = 1.0        # meters\n    N = 64          # number of grid points\n    a = 20.0        # m/s\n    nu = 1.0e-2     # m^2/s\n    epsilon = 1.0e-6  # residual reduction tolerance\n\n    # Discretization\n    dx = Lx / N\n    # Grid points x_i = i*dx for i=0..N-1\n    x = np.linspace(0, Lx, N, endpoint=False)\n\n    # Initial physical state u^n\n    u_n = np.sin(2.0 * np.pi * x)\n\n    # Test cases for physical time step\n    delta_t_cases = [5.0e-4, 2.0e-3, 1.0e-2, 2.0e-2]\n\n    # List to store results [measured_k, estimated_k] for each case\n    results = []\n\n    def apply_L(u, dx_val, a_val, nu_val):\n        \"\"\"Applies the discrete spatial operator L to a vector u.\"\"\"\n        # Enforce periodicity using np.roll\n        u_im1 = np.roll(u, 1)  # u_i-1\n        u_ip1 = np.roll(u, -1) # u_i+1\n\n        # First-order upwind for convection (a > 0)\n        conv_term = -a_val * (u - u_im1) / dx_val\n        # Second-order central for diffusion\n        diff_term = nu_val * (u_ip1 - 2.0 * u + u_im1) / dx_val**2\n\n        return conv_term + diff_term\n\n    # Loop over each test case for delta_t\n    for dt in delta_t_cases:\n        # --- Part 1: Theoretical Estimation of Iteration Count ---\n\n        # Wavenumber index for Fourier analysis\n        p = np.arange(N)\n        theta_p = 2.0 * np.pi * p / N\n\n        # Eigenvalues of the spatial operator L\n        term1 = (a / dx + 2.0 * nu / dx**2) * (1.0 - np.cos(theta_p))\n        term2 = (a / dx) * np.sin(theta_p)\n        lambda_L = -term1 - 1j * term2\n        \n        # Eigenvalues of the Jacobian J = I - dt*L\n        lambda_J = 1.0 - dt * lambda_L\n\n        # Spectral radius of J\n        rho_J = np.max(np.abs(lambda_J))\n\n        # Pseudo-time step parameter omega, based on rho(J)\n        omega = 1.0 / rho_J\n\n        # Eigenvalues of the iteration matrix G = I - omega*J\n        lambda_G = 1.0 - omega * lambda_J\n\n        # Contraction factor (spectral radius of G)\n        rho_G = np.max(np.abs(lambda_G))\n\n        # Estimate the number of iterations\n        # k >= log(epsilon) / log(rho_G)\n        k_est = int(np.ceil(np.log(epsilon) / np.log(rho_G)))\n\n        # --- Part 2: Measured Iteration Count from Simulation ---\n\n        k_meas = 0\n        u_k = np.copy(u_n) # Initial guess u^0 = u^n\n\n        def calculate_F(u, dt_val, u_n_val):\n            \"\"\"Residual function F(u) = (I - dt*L)u - u_n\"\"\"\n            return u - dt_val * apply_L(u, dx, a, nu) - u_n_val\n\n        # Initial residual F_0 = F(u^0)\n        F_0 = calculate_F(u_k, dt, u_n)\n        norm_F0 = np.linalg.norm(F_0)\n        \n        # Check for trivial case where initial residual is already zero\n        if norm_F0 == 0:\n            results.append([0, k_est])\n            continue\n\n        target_norm = epsilon * norm_F0\n        \n        F_k = F_0\n        # safety break to prevent pathologically long or infinite loops\n        max_iterations = 3 * k_est if k_est > 0 else 500000 \n        \n        # Pseudo-time iteration loop\n        while np.linalg.norm(F_k) > target_norm:\n            # Richardson-like iteration: u_{k+1} = u_k - omega * F(u_k)\n            u_k -= omega * F_k\n            # Update residual\n            F_k = calculate_F(u_k, dt, u_n)\n            k_meas += 1\n            \n            # Safety break\n            if k_meas > max_iterations:\n                # This indicates divergence or extremely slow convergence\n                # not captured by the simple estimate.\n                k_meas = -1 # Use a sentinel value for failure\n                break\n\n        results.append([k_meas, k_est])\n\n    # Format the final output according to the problem specification\n    formatted_results = [f\"[{m},{e}]\" for m, e in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In practical CFD simulations, the inner iterations are not run to machine precision but are terminated based on a tolerance, a process known as underconvergence. This final practice delves into the physical ramifications of this numerical shortcut using a model of decaying isotropic turbulence . By analyzing how underconvergence introduces errors into the energy spectrum, you will learn to devise intelligent convergence criteria that link numerical tolerance directly to the physical fidelity of the simulation.",
            "id": "3956111",
            "problem": "Consider decaying isotropic turbulence in a dimensionless setting. Let the energy spectrum be denoted by $E(k,t)$, where $k$ is the dimensionless wavenumber and $t$ is dimensionless time. Starting from the spectral energy balance derived from the incompressible Navier–Stokes equations, the viscous contribution to the evolution of the energy spectrum is given by the well-tested relation $\\,\\partial_t E(k,t) = - 2 \\mu k^2 E(k,t)\\,$, where $\\mu$ is the dimensionless kinematic viscosity. Neglect nonlinear spectral transfer over a single physical time step for the purposes of this analysis, so that the evolution over one time step is dominated by the viscous term. Discretize time with a backward Euler step from time level $n$ to $n+1$ using a physical time step $\\Delta t > 0$, which yields a semi-discrete equation of the form\n$$\nA_k E_k^{n+1} = E_k^n,\\quad \\text{with}\\quad A_k = 1 + 2 \\mu k^2 \\Delta t,\n$$\nwhere $E_k^n \\equiv E(k,t^n)$ and $E_k^{n+1} \\equiv E(k,t^{n+1})$.\n\nIn dual time-stepping for unsteady problems in Computational Fluid Dynamics (CFD), inner iterations in pseudo-time are used to approximately satisfy the backward Euler balance by driving the residual toward zero. Define the residual for wavenumber $k$ as\n$$\nR_k(E) = A_k E - E_k^n.\n$$\nUnderconvergence occurs if the inner iterations are terminated early, such that the final residual norm per mode satisfies $|R_k(E_k^{n+1,\\text{approx}})| \\le \\varepsilon_k$ for some prescribed residual tolerance $\\varepsilon_k$. This underconvergence induces an error in the spectrum at time level $n+1$.\n\nYour tasks are:\n- Derive, from first principles using the above semi-discrete linear model, an expression for the spectral error $\\,\\Delta E_k = E_k^{n+1,\\text{approx}} - E_k^{n+1}\\,$ as a function of $\\,A_k\\,$ and the residual $\\,R_k\\,$ evaluated at the underconverged solution.\n- Using that expression, derive the relative spectral error $\\,\\rho_k = \\left|\\Delta E_k\\right| / \\left|E_k^{n+1}\\right|\\,$ and explain how different residual tolerance policies affect $\\,\\rho_k\\,$ across wavenumbers.\n- Propose a residual tolerance policy that guarantees a user-specified spectral accuracy target $\\,\\delta_{\\text{spec}} > 0\\,$ in the sense that $\\,\\max_{k \\in \\mathcal{B}} \\rho_k \\le \\delta_{\\text{spec}}\\,$ over a specified wavenumber band $\\,\\mathcal{B}\\,$.\n\nNumerical evaluation requirements:\n- Use a dimensionless von Kármán-like initial spectrum shape\n$$\n\\tilde{E}(k; k_p) = k^4 \\exp\\!\\left(-2\\left(\\frac{k}{k_p}\\right)^2\\right),\n$$\nand define $\\,E_k^n = C \\,\\tilde{E}(k; k_p)\\,$ with $\\,C > 0\\,$ chosen so that the discrete energy satisfies $\\sum_{k=1}^{K_{\\max}} E_k^n \\,\\Delta k = 1$, with $\\,\\Delta k = 1\\,$ and integer wavenumbers $\\,k = 1,2,\\dots,K_{\\max}\\,$.\n- Compute the exact backward Euler update $\\,E_k^{n+1} = E_k^n / A_k\\,$ and an underconverged approximate update $\\,E_k^{n+1,\\text{approx}}$ constructed by saturating the residual to the tolerance, i.e., set $\\,|R_k(E_k^{n+1,\\text{approx}})| = \\varepsilon_k\\,$ and use the error relation you derived to define $\\,E_k^{n+1,\\text{approx}}\\,$.\n- Consider two tolerance policies:\n    1. Absolute residual tolerance: $\\,\\varepsilon_k = \\varepsilon_{\\text{abs}}\\,$ for all $\\,k\\,$.\n    2. Relative residual tolerance: $\\,\\varepsilon_k = \\varepsilon_{\\text{rel}}\\,E_k^n\\,$ for all $\\,k\\,$.\n- For each policy, compute the relative error per mode $\\,\\rho_k\\,$, then compute over the band $\\,\\mathcal{B} = \\{k \\in \\mathbb{Z} : k_{\\min} \\le k \\le k_{\\max}\\}\\,$:\n    - The bandwise root-mean-square relative error\n    $$\n    \\rho_{\\text{L2}} = \\sqrt{\\frac{1}{|\\mathcal{B}|}\\sum_{k \\in \\mathcal{B}} \\rho_k^2},\n    $$\n    - The bandwise maximum relative error\n    $$\n    \\rho_{\\infty} = \\max_{k \\in \\mathcal{B}} \\rho_k.\n    $$\n- Given a target $\\,\\delta_{\\text{spec}}\\,$, compute the smallest absolute tolerance $\\,\\varepsilon_{\\text{abs}}^{\\star}\\,$ that guarantees $\\,\\rho_{\\infty} \\le \\delta_{\\text{spec}}\\,$ over $\\,\\mathcal{B}\\,$. Also state the corresponding recommendation for the relative tolerance $\\,\\varepsilon_{\\text{rel}}\\,$ to guarantee the same target.\n- For each case, report whether the provided $\\,\\varepsilon_{\\text{abs}}\\,$ and $\\,\\varepsilon_{\\text{rel}}\\,$ meet the target, i.e., whether $\\,\\rho_{\\infty} \\le \\delta_{\\text{spec}}\\,$ in $\\,\\mathcal{B}\\,$ for each policy.\n\nTest suite:\nUse the following three parameter sets, all dimensionless, with $\\,\\Delta k = 1\\,$ and integer wavenumbers $\\,k = 1,2,\\dots,K_{\\max}\\,$.\n\n- Case $1$ (happy path):\n    - $K_{\\max} = 64$\n    - $k_p = 8$\n    - $\\mu = 10^{-3}$\n    - $\\Delta t = 5\\times 10^{-2}$\n    - $\\varepsilon_{\\text{abs}} = 10^{-6}$\n    - $\\varepsilon_{\\text{rel}} = 10^{-3}$\n    - Band $\\,\\mathcal{B}\\,$: $k_{\\min} = 4$, $k_{\\max} = 16$\n    - $\\delta_{\\text{spec}} = 10^{-3}$\n- Case $2$ (loose absolute tolerance, high-$k$ band):\n    - $K_{\\max} = 64$\n    - $k_p = 12$\n    - $\\mu = 10^{-3}$\n    - $\\Delta t = 5\\times 10^{-2}$\n    - $\\varepsilon_{\\text{abs}} = 10^{-3}$\n    - $\\varepsilon_{\\text{rel}} = 10^{-2}$\n    - Band $\\,\\mathcal{B}\\,$: $k_{\\min} = 16$, $k_{\\max} = 48$\n    - $\\delta_{\\text{spec}} = 5\\times 10^{-3}$\n- Case $3$ (larger viscosity and time step):\n    - $K_{\\max} = 64$\n    - $k_p = 6$\n    - $\\mu = 5\\times 10^{-3}$\n    - $\\Delta t = 2\\times 10^{-1}$\n    - $\\varepsilon_{\\text{abs}} = 10^{-5}$\n    - $\\varepsilon_{\\text{rel}} = 10^{-4}$\n    - Band $\\,\\mathcal{B}\\,$: $k_{\\min} = 2$, $k_{\\max} = 32$\n    - $\\delta_{\\text{spec}} = 10^{-4}$\n\nFinal output format specification:\n- Your program should produce a single line of output containing the results for the three cases as a comma-separated Python-style list of lists, where each inner list contains, in order:\n    - $\\,\\rho_{\\text{L2}}$ for the absolute tolerance policy,\n    - $\\,\\rho_{\\infty}$ for the absolute tolerance policy,\n    - $\\,\\rho_{\\text{L2}}$ for the relative tolerance policy,\n    - $\\,\\rho_{\\infty}$ for the relative tolerance policy,\n    - $\\,\\varepsilon_{\\text{abs}}^{\\star}$ as the recommended absolute tolerance to guarantee $\\,\\rho_{\\infty} \\le \\delta_{\\text{spec}}\\,$ over the specified band,\n    - a boolean indicating whether the provided $\\,\\varepsilon_{\\text{abs}}$ meets the target,\n    - a boolean indicating whether the provided $\\,\\varepsilon_{\\text{rel}}$ meets the target.\nFor example, the output should look like a single Python list string: $[ [x_1,x_2,x_3,x_4,x_5,b_1,b_2], [\\dots], [\\dots] ]$ where each $x_i$ is a float and each $b_i$ is a boolean.",
            "solution": "The problem requires a derivation of the spectral error resulting from underconvergence in a dual time-stepping scheme, an analysis of different residual tolerance policies, and a numerical evaluation of these concepts.\n\n### Part 1: Derivation of the Spectral Error\n\nLet $E_k^{n+1}$ be the exact solution to the backward Euler semi-discrete equation at time level $n+1$ for wavenumber $k$. It satisfies the linear system:\n$$\nA_k E_k^{n+1} = E_k^n\n$$\nwhere $A_k = 1 + 2 \\mu k^2 \\Delta t$. The residual for the exact solution is, by definition, zero:\n$$\nR_k(E_k^{n+1}) = A_k E_k^{n+1} - E_k^n = 0\n$$\nAn underconverged approximate solution, denoted $E_k^{n+1,\\text{approx}}$, is obtained when the inner iterations of the dual time-stepping loop are terminated prematurely. This solution does not perfectly satisfy the linear system, resulting in a non-zero residual, which we will denote $R_k^{\\text{approx}}$:\n$$\nR_k^{\\text{approx}} \\equiv R_k(E_k^{n+1,\\text{approx}}) = A_k E_k^{n+1,\\text{approx}} - E_k^n\n$$\nThe problem states that the inner iterations stop when $|R_k^{\\text{approx}}| \\le \\varepsilon_k$ for a prescribed tolerance $\\varepsilon_k$.\n\nTo find the spectral error, $\\Delta E_k = E_k^{n+1,\\text{approx}} - E_k^{n+1}$, we first express both the exact and approximate solutions in terms of $E_k^n$ and the system operator $A_k$. Since $A_k = 1 + 2 \\mu k^2 \\Delta t > 0$ for $\\mu, \\Delta t > 0$, its inverse exists.\n\nFrom the definition of the exact solution:\n$$\nE_k^{n+1} = \\frac{E_k^n}{A_k}\n$$\nFrom the definition of the approximate solution's residual:\n$$\nA_k E_k^{n+1,\\text{approx}} = E_k^n + R_k^{\\text{approx}} \\implies E_k^{n+1,\\text{approx}} = \\frac{E_k^n + R_k^{\\text{approx}}}{A_k}\n$$\nThe spectral error $\\Delta E_k$ is the difference between these two expressions:\n$$\n\\Delta E_k = E_k^{n+1,\\text{approx}} - E_k^{n+1} = \\left(\\frac{E_k^n + R_k^{\\text{approx}}}{A_k}\\right) - \\left(\\frac{E_k^n}{A_k}\\right)\n$$\nThis simplifies to the fundamental relationship between spectral error and the residual of the approximate solution:\n$$\n\\Delta E_k = \\frac{R_k^{\\text{approx}}}{A_k}\n$$\n\n### Part 2: Relative Spectral Error and Analysis of Tolerance Policies\n\nThe relative spectral error, $\\rho_k$, is defined as $\\rho_k = |\\Delta E_k| / |E_k^{n+1}|$. The energy spectrum $E(k,t)$ is a non-negative quantity, so $E_k^n \\ge 0$ and $E_k^{n+1} \\ge 0$. Thus, we can drop the absolute value signs for the energy terms.\nSubstituting the expressions for $\\Delta E_k$ and $E_k^{n+1}$:\n$$\n\\rho_k = \\frac{|\\Delta E_k|}{E_k^{n+1}} = \\frac{|R_k^{\\text{approx}} / A_k|}{E_k^n / A_k}\n$$\nSince $A_k > 0$, we have $|A_k| = A_k$. The expression simplifies to:\n$$\n\\rho_k = \\frac{|R_k^{\\text{approx}}|}{E_k^n}\n$$\nFor the purpose of analysis and numerical evaluation, we consider the worst-case scenario where the residual is saturated at the tolerance limit, i.e., $|R_k^{\\text{approx}}| = \\varepsilon_k$. This yields:\n$$\n\\rho_k = \\frac{\\varepsilon_k}{E_k^n}\n$$\nThis equation reveals how the choice of tolerance $\\varepsilon_k$ directly impacts the relative accuracy of the solution. We now analyze the two proposed policies:\n\n1.  **Absolute Residual Tolerance:** $\\varepsilon_k = \\varepsilon_{\\text{abs}}$ for all $k$.\n    In this case, the relative spectral error is $\\rho_k = \\varepsilon_{\\text{abs}} / E_k^n$. The error is inversely proportional to the energy $E_k^n$ at the previous time step. Since the energy spectrum typically has low values at high wavenumbers (the dissipation range), this policy will result in a very large relative error in those regions. While it may provide good accuracy near the peak of the spectrum, it fails to control the error uniformly.\n\n2.  **Relative Residual Tolerance:** $\\varepsilon_k = \\varepsilon_{\\text{rel}} E_k^n$ for all $k$.\n    In this case, the relative spectral error is $\\rho_k = (\\varepsilon_{\\text{rel}} E_k^n) / E_k^n = \\varepsilon_{\\text{rel}}$. This policy yields a constant relative spectral error across all wavenumbers, equal to the parameter $\\varepsilon_{\\text{rel}}$. This is a far more effective strategy for ensuring uniform spectral accuracy.\n\n### Part 3: Tolerance Policy for a Specified Accuracy Target\n\nThe objective is to devise a tolerance policy $\\varepsilon_k$ that guarantees a user-specified spectral accuracy target $\\delta_{\\text{spec}}$, such that $\\max_{k \\in \\mathcal{B}} \\rho_k \\le \\delta_{\\text{spec}}$ over a given wavenumber band $\\mathcal{B}$.\n\nUsing our derived relation $\\rho_k = \\varepsilon_k / E_k^n$, the condition becomes:\n$$\n\\frac{\\varepsilon_k}{E_k^n} \\le \\delta_{\\text{spec}} \\quad \\text{for all } k \\in \\mathcal{B}\n$$\nThis implies that the tolerance must satisfy $\\varepsilon_k \\le \\delta_{\\text{spec}} E_k^n$.\n\nThe most direct and efficient policy to meet this requirement is to set the tolerance based on the target itself. The proposed policy is:\n$$\n\\varepsilon_k = \\delta_{\\text{spec}} E_k^n\n$$\nThis is a relative residual tolerance policy where the proportionality constant is the desired accuracy target, i.e., `recommendation: set` $\\varepsilon_{\\text{rel}} = \\delta_{\\text{spec}}$. This choice ensures that $\\rho_k = \\delta_{\\text{spec}}$ for all $k$, satisfying the maximum error condition exactly.\n\nIf one is constrained to use an absolute tolerance, $\\varepsilon_k = \\varepsilon_{\\text{abs}}^{\\star}$, we must determine the value of $\\varepsilon_{\\text{abs}}^{\\star}$ that guarantees the same accuracy target. The condition becomes:\n$$\n\\max_{k \\in \\mathcal{B}} \\left( \\frac{\\varepsilon_{\\text{abs}}^{\\star}}{E_k^n} \\right) \\le \\delta_{\\text{spec}}\n$$\nThis can be rewritten as:\n$$\n\\varepsilon_{\\text{abs}}^{\\star} \\cdot \\max_{k \\in \\mathcal{B}} \\left( \\frac{1}{E_k^n} \\right) \\le \\delta_{\\text{spec}}\n$$\nThe maximum of $1/E_k^n$ occurs where $E_k^n$ is minimum within the band $\\mathcal{B}$. Let $E_{\\min,\\mathcal{B}}^n = \\min_{k \\in \\mathcal{B}} E_k^n$. The condition is then $\\varepsilon_{\\text{abs}}^{\\star} / E_{\\min,\\mathcal{B}}^n \\le \\delta_{\\text{spec}}$. To find the largest (least restrictive) tolerance $\\varepsilon_{\\text{abs}}^{\\star}$ that satisfies this, we set the equality:\n$$\n\\varepsilon_{\\text{abs}}^{\\star} = \\delta_{\\text{spec}} \\cdot E_{\\min,\\mathcal{B}}^n\n$$\nThis is the required absolute tolerance. It must be scaled by the minimum energy level within the band of interest to control the worst-case relative error.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(params):\n    \"\"\"\n    Solves for one set of parameters as defined in the problem.\n    \"\"\"\n    K_max = params['K_max']\n    k_p = params['k_p']\n    mu = params['mu']\n    delta_t = params['delta_t']\n    eps_abs = params['eps_abs']\n    eps_rel = params['eps_rel']\n    k_min_band = params['k_min_band']\n    k_max_band = params['k_max_band']\n    delta_spec = params['delta_spec']\n    delta_k = 1.0\n\n    # 1. Setup wavenumbers\n    k_vals = np.arange(1, K_max + 1, dtype=float)\n\n    # 2. Compute initial spectrum E_k^n\n    # Unnormalized spectrum shape\n    E_tilde = k_vals**4 * np.exp(-2.0 * (k_vals / k_p)**2)\n    # Normalization constant C such that sum(C * E_tilde * delta_k) = 1\n    total_energy_unnormalized = np.sum(E_tilde * delta_k)\n    C = 1.0 / total_energy_unnormalized\n    # Normalized spectrum E_k^n\n    E_k_n = C * E_tilde\n\n    # 3. Define the analysis band B\n    band_indices = np.where((k_vals >= k_min_band) & (k_vals <= k_max_band))[0]\n    E_k_n_band = E_k_n[band_indices]\n    num_modes_in_band = len(band_indices)\n\n    # 4. Analysis for Absolute Tolerance Policy\n    # Relative error per mode: rho_k = eps_abs / E_k^n\n    rho_k_abs = eps_abs / E_k_n\n    \n    # Filter for the band B\n    rho_k_abs_band = rho_k_abs[band_indices]\n\n    # Compute metrics over the band\n    rho_L2_abs = np.sqrt(np.sum(rho_k_abs_band**2) / num_modes_in_band)\n    rho_inf_abs = np.max(rho_k_abs_band)\n    meets_target_abs = rho_inf_abs <= delta_spec\n\n    # 5. Analysis for Relative Tolerance Policy\n    # Relative error per mode: rho_k = (eps_rel * E_k^n) / E_k^n = eps_rel\n    # The relative error is constant for all modes.\n    rho_L2_rel = eps_rel\n    rho_inf_rel = eps_rel\n    meets_target_rel = rho_inf_rel <= delta_spec\n    \n    # 6. Compute Optimal Absolute Tolerance eps_abs_star\n    # eps_abs_star = delta_spec * min_{k in B} E_k^n\n    E_min_band = np.min(E_k_n_band)\n    eps_abs_star = delta_spec * E_min_band\n    \n    # 7. Package results\n    return [\n        rho_L2_abs,\n        rho_inf_abs,\n        rho_L2_rel,\n        rho_inf_rel,\n        eps_abs_star,\n        meets_target_abs,\n        meets_target_rel\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            'K_max': 64, 'k_p': 8, 'mu': 1e-3, 'delta_t': 5e-2, \n            'eps_abs': 1e-6, 'eps_rel': 1e-3, \n            'k_min_band': 4, 'k_max_band': 16, \n            'delta_spec': 1e-3\n        },\n        # Case 2 (loose absolute tolerance, high-k band)\n        {\n            'K_max': 64, 'k_p': 12, 'mu': 1e-3, 'delta_t': 5e-2, \n            'eps_abs': 1e-3, 'eps_rel': 1e-2, \n            'k_min_band': 16, 'k_max_band': 48, \n            'delta_spec': 5e-3\n        },\n        # Case 3 (larger viscosity and time step)\n        {\n            'K_max': 64, 'k_p': 6, 'mu': 5e-3, 'delta_t': 2e-1,\n            'eps_abs': 1e-5, 'eps_rel': 1e-4, \n            'k_min_band': 2, 'k_max_band': 32, \n            'delta_spec': 1e-4\n        }\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        case_results = run_case(case_params)\n        all_results.append(case_results)\n\n    # Convert the list of lists to the required string format\n    result_str = \"[\"\n    for i, case_res in enumerate(all_results):\n        inner_list_str = \"[\"\n        for j, val in enumerate(case_res):\n            if isinstance(val, bool):\n                inner_list_str += str(val).lower()\n            else:\n                inner_list_str += f\"{val:.8e}\" if j < len(case_res) - 2 else str(val)\n            if j < len(case_res) - 1:\n                inner_list_str += \",\"\n        inner_list_str += \"]\"\n        result_str += inner_list_str\n        if i < len(all_results) - 1:\n            result_str += \",\"\n    result_str += \"]\"\n    \n    # Using a more direct string representation to avoid manual formatting issues\n    output_str = repr(all_results).replace(\" \", \"\")\n    \n    print(output_str)\n\nsolve()\n```"
        }
    ]
}