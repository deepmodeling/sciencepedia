{
    "hands_on_practices": [
        {
            "introduction": "这个练习直击理解稳定域的核心。我们将从抽象的定义 $\\mathcal{S} = \\{ z \\in \\mathbb{C} : |R(z)| \\le 1 \\}$ 出发，构建一个具体、可视化的表示。通过推导经典的四阶龙格-库塔（RK4）方法的稳定性函数 $R(z)$，并编写程序绘制其边界，您将对稳定域的形状和大小有一个直观的感受。这是应用这些概念至关重要的第一步。",
            "id": "3996033",
            "problem": "考虑线性测试方程 $y'(t) = \\lambda y(t)$，其中 $\\lambda \\in \\mathbb{C}$，以及一个由其稳定性函数 $R(z)$ 表征的单步显式积分器，其中 $z = h \\lambda$，$h > 0$ 是时间步长。绝对稳定域定义为 $\\mathcal{S} = \\{ z \\in \\mathbb{C} : |R(z)| \\leq 1 \\}$。在航空航天计算流体动力学（CFD）中，时间积分方案常应用于半离散系统，这些系统的特征值通过此稳定域决定了允许的时间步长。\n\n从应用于线性测试方程的单步方法的稳定性函数定义出发，推导经典四阶龙格-库塔（RK4）方法的稳定性函数 $R(z)$。使用该函数，您必须实现一个程序来完成以下任务：\n1. 通过从原点以在 $[0, 2\\pi)$ 内均匀分布的角度 $\\theta$ 采样射线 $z = r e^{i \\theta}$，计算 RK4 方法由 $|R(z)| = 1$ 定义的边界曲线。对于每个 $\\theta$，数值确定最小的正半径 $r(\\theta)$，使得 $|R(r(\\theta) e^{i \\theta})| = 1$。角度必须以弧度处理。\n2. 确定边界曲线与负实轴的交点，表示为一个实数 $x^\\star  0$，使得 $|R(x^\\star)| = 1$ 且 $x^\\star \\in \\mathbb{R}$。\n3. 给定一个有限的特征值集合 $\\{\\lambda_j\\}_{j=1}^m \\subset \\mathbb{C}$，计算最大允许时间步长 $h_{\\max}$，使得对于所有的 $j$ 都有 $h_{\\max} \\lambda_j \\in \\mathcal{S}$，即 $\\max_j |R(h_{\\max} \\lambda_j)| \\leq 1$。\n\n本问题中的所有量均为无量纲，所有角度必须以弧度处理。\n\n您的实现必须采用稳健的数值区间套定和二分法来定位单变量标量函数的根。您必须通过使用能完全覆盖 RK4 稳定区域并可靠终止的适当搜索区间来确保科学真实性。\n\n测试套件：\n- 情况1（边界与负实轴的交点）：计算 $x^\\star$，即满足 $|R(x^\\star)| = 1$ 的最大绝对值的负实数。\n- 情况2（实特征值，缩放行为）：对于 $\\lambda_1 = -1$ 和 $\\lambda_2 = -10$，计算 $h_{\\max}$，使得对于 $j=1,2$ 都有 $h_{\\max}\\lambda_j \\in \\mathcal{S}$。\n- 情况3（复特征值，方向边界）：对于 $\\lambda_3 = -2 + 3 i$，计算 $h_{\\max}$，使得 $h_{\\max}\\lambda_3 \\in \\mathcal{S}$。\n\n答案规格与输出格式：\n- 对于每种情况，答案必须是浮点数。\n- 您的程序应生成单行输出，其中包含用逗号分隔并用方括号括起来的结果列表（例如，“[result1,result2,result3]”）。\n- 三个输出必须按 $[x^\\star, \\text{情况2的 } h_{\\max}, \\text{情况3的 } h_{\\max}]$ 的顺序排列。\n- 每个浮点数必须四舍五入到六位小数。",
            "solution": "该问题要求推导经典四阶龙格-库塔（RK4）方法的稳定性函数，并用它来确定给定特征值谱的稳定性极限。该过程包括三个主要部分：推导稳定性函数 $R(z)$，找到负实轴上的稳定边界，以及为特征值集合计算最大稳定时间步长 $h_{\\max}$。\n\n### 第1步：RK4 稳定性函数的推导\n\n数值单步方法的稳定性函数 $R(z)$ 是通过将该方法应用于线性测试方程 $y'(t) = \\lambda y(t)$ 时得到的关系 $y_{n+1} = R(z) y_n$ 定义的，其中 $z = h \\lambda$，$h$ 为时间步长。\n\n经典的四阶龙格-库塔方法由下式给出：\n$$y_{n+1} = y_n + \\frac{h}{6} (k_1 + 2k_2 + 2k_3 + k_4)$$\n其中，各阶段 $k_i$ 计算如下：\n\\begin{align*}\nk_1 = f(t_n, y_n) \\\\\nk_2 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_1) \\\\\nk_3 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_2) \\\\\nk_4 = f(t_n + h, y_n + h k_3)\n\\end{align*}\n对于线性测试方程，$f(t, y) = \\lambda y$。将此代入阶段计算中可得：\n\\begin{align*}\nk_1 = \\lambda y_n \\\\\nk_2 = \\lambda \\left(y_n + \\frac{h}{2}k_1\\right) = \\lambda \\left(y_n + \\frac{h}{2}(\\lambda y_n)\\right) = \\lambda y_n \\left(1 + \\frac{h\\lambda}{2}\\right) \\\\\nk_3 = \\lambda \\left(y_n + \\frac{h}{2}k_2\\right) = \\lambda \\left(y_n + \\frac{h}{2}\\lambda y_n \\left(1 + \\frac{h\\lambda}{2}\\right)\\right) = \\lambda y_n \\left(1 + \\frac{h\\lambda}{2} + \\frac{(h\\lambda)^2}{4}\\right) \\\\\nk_4 = \\lambda \\left(y_n + h k_3\\right) = \\lambda \\left(y_n + h \\lambda y_n \\left(1 + \\frac{h\\lambda}{2} + \\frac{(h\\lambda)^2}{4}\\right)\\right) = \\lambda y_n \\left(1 + h\\lambda + \\frac{(h\\lambda)^2}{2} + \\frac{(h\\lambda)^3}{4}\\right)\n\\end{align*}\n令 $z = h\\lambda$。各阶段可以用 $z$ 重写为：\n\\begin{align*}\nk_1 = \\lambda y_n \\\\\nk_2 = \\lambda y_n \\left(1 + \\frac{z}{2}\\right) \\\\\nk_3 = \\lambda y_n \\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right) \\\\\nk_4 = \\lambda y_n \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\\right)\n\\end{align*}\n现在，我们将这些表达式代回 $y_{n+1}$ 的更新公式中：\n$$y_{n+1} = y_n + \\frac{h}{6} \\left[\\lambda y_n + 2\\lambda y_n \\left(1 + \\frac{z}{2}\\right) + 2\\lambda y_n \\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right) + \\lambda y_n \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\\right)\\right]$$\n提出因子 $y_n$ 即可得到关系式 $y_{n+1} = R(z) y_n$：\n$$R(z) = \\frac{y_{n+1}}{y_n} = 1 + \\frac{h\\lambda}{6} \\left[1 + 2\\left(1 + \\frac{z}{2}\\right) + 2\\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right) + \\left(1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\\right)\\right]$$\n$$R(z) = 1 + \\frac{z}{6} \\left[1 + (2+z) + (2+z+\\frac{z^2}{2}) + (1+z+\\frac{z^2}{2}+\\frac{z^3}{4})\\right]$$\n对括号内的项求和：\n\\begin{align*}\n\\text{常数项}:  \\quad 1+2+2+1 = 6 \\\\\n\\text{线性项 } (z):  \\quad z+z+z = 3z \\\\\n\\text{二次项 } (z^2):  \\quad \\frac{z^2}{2} + \\frac{z^2}{2} = z^2 \\\\\n\\text{三次项 } (z^3):  \\quad \\frac{z^3}{4} \\\\\n\\text{括号内总和}:  \\quad 6 + 3z + z^2 + \\frac{z^3}{4}\n\\end{align*}\n将此和代回 $R(z)$ 的表达式中：\n$$R(z) = 1 + \\frac{z}{6} \\left(6 + 3z + z^2 + \\frac{z^3}{4}\\right) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}$$\n这可以紧凑地写为 $e^z$ 的四阶泰勒级数展开：\n$$R(z) = \\sum_{k=0}^{4} \\frac{z^k}{k!}$$\n绝对稳定域为 $\\mathcal{S} = \\{ z \\in \\mathbb{C} : |R(z)| \\leq 1 \\}$。该域的边界由曲线 $|R(z)| = 1$ 给出。\n\n### 第2步：算法方法\n\n该问题要求使用此稳定性函数解决三个相关任务。一个核心组件是数值求根算法。我们将实现二分法来寻找函数 $f(x)$ 在区间 $[a, b]$ 内的根，前提是 $f(a)$ 和 $f(b)$ 符号相反。\n\n**第1部分：负实轴上的边界交点 ($x^\\star$)**\n我们必须找到满足 $|R(x^\\star)|=1$ 的最大绝对值的负实数 $x^\\star  0$。对于 $z=x \\in \\mathbb{R}$，$R(x)$ 是实数。条件是 $|R(x)|=1$，即 $R(x) = 1$ 或 $R(x) = -1$。\n对于 RK4，稳定区间的左边界点 $x^\\star$ 恰好是 $R(x)=1$ 的非零根。\n$R(x) = 1 \\implies 1 + x + \\frac{x^2}{2} + \\frac{x^3}{6} + \\frac{x^4}{24} = 1 \\implies x(1 + \\frac{x}{2} + \\frac{x^2}{6} + \\frac{x^3}{24}) = 0$。这有一个平凡解 $x=0$。非零根 $x^\\star$ 是多项式 $P(x) = 1 + \\frac{x}{2} + \\frac{x^2}{6} + \\frac{x^3}{24}$ 的根。可以建立一个搜索区间：$P(-4) = -1$ 且 $P(-2) \\approx 0.333$。在 $(-4, -2)$ 内必定存在一个根。我们使用二分法找到这个根，即 $x^\\star$。\n\n**第2部分：最大允许时间步长 ($h_{\\max}$)**\n给定一个特征值集合 $\\{\\lambda_j\\}$，如果对所有 $j$ 都有 $h\\lambda_j \\in \\mathcal{S}$，则时间步长 $h$ 是稳定的。这等价于对所有 $j$ 都有 $|R(h\\lambda_j)| \\leq 1$。我们寻求满足此条件的最大 $h$，记为 $h_{\\max}$。\n对于每个特征值 $\\lambda_j = |\\lambda_j|e^{i\\theta_j}$，该条件可以写成 $h|\\lambda_j| \\le r(\\theta_j)$，其中 $r(\\theta_j)$ 是在角度 $\\theta_j$ 处稳定边界的半径。该半径是方程 $|R(re^{i\\theta_j})|=1$ 的最小正根。\n这对每个特征值给出了 $h$ 的一个约束：$h \\leq \\frac{r(\\theta_j)}{|\\lambda_j|}$。为了同时满足所有特征值的条件，$h$ 必须小于或等于这些单个限制中的最小值：\n$$h_{\\max} = \\min_{j} \\frac{r(\\theta_j)}{|\\lambda_j|}$$\n为了找到给定 $\\theta_j$ 的 $r(\\theta_j)$，我们求解方程 $g(r) = |R(re^{i\\theta_j})|-1 = 0$ 以得到 $r>0$。对于对应于左半平面（$\\mathrm{Re}(\\lambda_j)  0$）中特征值的任何 $\\theta_j$，$g(r)$ 在 $r>0$ 较小时为负，在 $r$ 较大时为正。这允许使用二分法来找到 $r(\\theta_j)$。\n\n**应用于测试用例：**\n\n**情况1：** $\\lambda \\in \\mathbb{R}$，$\\lambda  0$。我们寻求 $x^\\star$。\n如上所述，这需要找到 $P(x) = 1 + \\frac{x}{2} + \\frac{x^2}{6} + \\frac{x^3}{24}$ 在区间 $[-4, -2]$ 内的根。\n\n**情况2：** $\\lambda_1 = -1$，$\\lambda_2 = -10$。\n两个特征值都在负实轴上（$\\theta = \\pi$）。稳定边界的半径是 $r(\\pi) = |x^\\star|$。\n单个时间步长限制为：\n$h_1 = \\frac{r(\\pi)}{|\\lambda_1|} = \\frac{|x^\\star|}{1} = |x^\\star|$\n$h_2 = \\frac{r(\\pi)}{|\\lambda_2|} = \\frac{|x^\\star|}{10}$\n最大允许时间步长为 $h_{\\max} = \\min(h_1, h_2) = \\frac{|x^\\star|}{10}$。\n\n**情况3：** $\\lambda_3 = -2 + 3i$。\n我们首先计算 $\\lambda_3$ 的极坐标表示：\n$|\\lambda_3| = \\sqrt{(-2)^2 + 3^2} = \\sqrt{13}$\n$\\theta_3 = \\text{atan2}(3, -2)$\n接下来，我们通过使用二分法数值求解 $|R(re^{i\\theta_3})| - 1 = 0$ 来找到稳定性半径 $r(\\theta_3)$。一个合适的 $r$ 搜索区间是 $[0, 5]$，因为对于大的 $r$，$|R(z)| \\approx |z|^4/24$ 会迅速增长。\n那么最大允许时间步长为 $h_{\\max} = \\frac{r(\\theta_3)}{|\\lambda_3|}$。\n\n实现将精确地遵循此逻辑，使用二分法求解器和推导出的稳定性函数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the three test cases related to the stability of the RK4 integrator.\n    \"\"\"\n\n    # --- Numerical Utilities ---\n\n    def bisection(f, a, b, tol=1e-12, max_iter=100):\n        \"\"\"\n        Finds a root of function f in the interval [a, b] using the bisection method.\n        Assumes f(a) and f(b) have opposite signs.\n        \"\"\"\n        fa = f(a)\n        if fa == 0:\n            return a\n        fb = f(b)\n        if fb == 0:\n            return b\n        \n        if np.sign(fa) == np.sign(fb):\n            raise ValueError(\"Function has the same sign at the interval endpoints.\")\n\n        for _ in range(max_iter):\n            c = a + (b - a) / 2\n            fc = f(c)\n            if abs(b - a) / 2  tol or fc == 0:\n                return c\n            if np.sign(fc) == np.sign(fa):\n                a = c\n                fa = fc\n            else:\n                b = c\n        return (a + b) / 2\n\n    # --- RK4 Stability Function ---\n\n    def R_rk4(z: complex) -> complex:\n        \"\"\"\n        Computes the stability function for the classical RK4 method.\n        R(z) = 1 + z + z^2/2! + z^3/3! + z^4/4!\n        \"\"\"\n        z2 = z * z\n        z3 = z2 * z\n        z4 = z3 * z\n        return 1 + z + z2 / 2.0 + z3 / 6.0 + z4 / 24.0\n\n    results = []\n\n    # --- Case 1: Boundary intersection on the negative real axis ---\n    \n    # We need to find the non-zero root of R(x) = 1 for x  0.\n    # This is equivalent to finding the root of P(x) = 1 + x/2 + x^2/6 + x^3/24 = 0.\n    def p_poly(x: float) -> float:\n        return 1.0 + x/2.0 + x**2/6.0 + x**3/24.0\n\n    # The interval [-4.0, -2.0] brackets the root.\n    # p_poly(-4) = -1.0\n    # p_poly(-2) = 1/3\n    x_star = bisection(p_poly, -4.0, -2.0)\n    results.append(x_star)\n\n    # --- Case 2: Real eigenvalues, scaling behavior ---\n\n    # For eigenvalues lambda_j, h_max = min_j( r(theta_j) / |lambda_j| ).\n    # Lambda = -1 and -10 are on the negative real axis (theta = pi).\n    # The boundary radius r(pi) is |x_star|.\n    # h_max = min( |x_star|/|-1|, |x_star|/|-10| ) = |x_star|/10.\n    \n    hmax_case2 = abs(x_star) / 10.0\n    results.append(hmax_case2)\n\n    # --- Case 3: Complex eigenvalue, directional boundary ---\n\n    # For lambda = -2 + 3i, find h_max.\n    lambda3 = -2.0 + 3.0j\n    abs_lambda3 = np.abs(lambda3)\n    theta3 = np.angle(lambda3)\n\n    # We need to find the radius r(theta3) of the stability boundary.\n    # This is done by solving |R(r * exp(i*theta))| - 1 = 0 for r.\n    def boundary_radius_func(r: float) -> float:\n        z = r * np.exp(1j * theta3)\n        return np.abs(R_rk4(z)) - 1.0\n\n    # For r=0, func=-0. For large r, func>0. The search interval [0, 5] is safe.\n    # Using a small positive lower bound to avoid r=0 being found.\n    r_theta3 = bisection(boundary_radius_func, 1e-9, 5.0)\n    \n    hmax_case3 = r_theta3 / abs_lambda3\n    results.append(hmax_case3)\n\n    # --- Final Output Formatting ---\n    \n    output_str = f\"[{results[0]:.6f},{results[1]:.6f},{results[2]:.6f}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在将稳定域可视化之后，下一个合理的步骤是将其用于一个实际目的：确定偏微分方程（PDE）模拟所允许的最大时间步长。这个练习旨在连接抽象的测试方程与一个真实的计算流体动力学（CFD）问题。您将推导周期性网格上二维热方程的特征值谱，并利用它以及RK4稳定域的特性，来得到时间步长限制 $\\Delta t_{\\max}$ 的符号表达式 。这种分析对于确保显式格式在扩散主导流动中的稳定性至关重要。",
            "id": "3996110",
            "problem": "考虑在方形周期性域上的二维(2D)热方程，该问题属于计算流体动力学（CFD, Computational Fluid Dynamics）领域，并使用线方法进行离散化。设热扩散系数为 $\\kappa$（单位为 $\\mathrm{m^2/s}$）。在两个方向上间距均为 $h$ 的均匀笛卡尔网格上，使用带有周期性边界条件的标准二阶五点有限差分格式来近似拉普拉斯算子 $\\nabla^2$，从而得到一个线性自治半离散系统 $u_{t} = A u$，其中 $A = \\kappa L_{h}$，$L_{h}$ 是离散拉普拉斯矩阵。\n\n仅使用：\n- 周期性均匀网格上离散傅里叶模的定义，\n- 应用于 $y'=\\lambda y$ 的单步法的绝对稳定性要求 $\\max_{\\lambda \\in \\sigma(A)} |R(\\Delta t\\,\\lambda)| \\le 1$ 这一事实，其中 $R$ 是该方法的稳定性函数，$\\sigma(A)$ 是 $A$ 的谱，\n- 以及使用经典四阶显式龙格-库塔方法 (RK$4$) 作为时间积分器，\n\n从第一性原理出发推导：\n$1)$ 算子 $A=\\kappa L_{h}$ 的谱半径 $\\rho(A)$，以及\n$2)$ RK$4$ 的最大稳定显式时间步长 $\\Delta t_{\\max}$，使得 $\\max_{z \\in \\Delta t\\,\\sigma(A)} |R(z)| \\le 1$。\n\n将您的最终答案表示为关于 $\\Delta t_{\\max}$ 的单个符号表达式，用 $h$ 和 $\\kappa$ 表示，并使用一个四舍五入到四位有效数字的数值常数。最终时间步长以秒为单位表示。",
            "solution": "问题陈述已经过验证，被认为是可靠、适定且有科学依据的。给定数值格式的最大稳定时间步长的推导从第一性原理出发。\n\n半离散系统由 $u_t = A u$ 给出，其中 $A = \\kappa L_h$。这里，$L_h$ 是在间距为 $h$ 的均匀笛卡尔网格上，拉普拉斯算子 $\\nabla^2$ 的二阶五点有限差分格式的矩阵表示。对于在网格点 $(x_i, y_j)$ 上定义的网格函数 $u_{i,j}$，离散拉普拉斯算子的作用如下：\n$$ (L_h u)_{i,j} = \\frac{u_{i+1, j} + u_{i-1, j} + u_{i, j+1} + u_{i, j-1} - 4 u_{i, j}}{h^2} $$\n\n**$1)$ $A$ 的谱与谱半径的推导**\n\n为了找到算子 $A$ 的特征值，我们分析它对离散傅里叶模的作用，这些模是周期性域上线性常系数算子的特征函数。一个通用的二维离散傅里叶模由下式给出：\n$$ u_{i,j}^{(k_x, k_y)} = \\exp(I(k_x x_i + k_y y_j)) = \\exp(I(k_x i h + k_y j h)) $$\n其中 $I = \\sqrt{-1}$ 是虚数单位，$k_x$ 和 $k_y$ 分别是 $x$ 和 $y$ 方向的波数。\n\n将算子 $L_h$ 应用于此模态，得到：\n$$ (L_h u^{(k_x, k_y)})_{i,j} = \\frac{1}{h^2} \\left[ \\exp(I(k_x(i+1)h + k_yjh)) + \\exp(I(k_x(i-1)h + k_yjh)) + \\dots \\right] $$\n将项 $u_{i,j}^{(k_x, k_y)}$ 提取出来：\n$$ (L_h u^{(k_x, k_y)})_{i,j} = \\frac{u_{i,j}^{(k_x, k_y)}}{h^2} \\left[ \\exp(I k_x h) + \\exp(-I k_x h) + \\exp(I k_y h) + \\exp(-I k_y h) - 4 \\right] $$\n使用恒等式 $2\\cos(\\theta) = \\exp(I\\theta) + \\exp(-I\\theta)$，我们求得 $L_h$ 的特征值：\n$$ \\lambda_{L_h}(k_x, k_y) = \\frac{2}{h^2} \\left[ \\cos(k_x h) + \\cos(k_y h) - 2 \\right] $$\n使用半角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$，我们可以将其重写为：\n$$ \\lambda_{L_h}(k_x, k_y) = -\\frac{4}{h^2} \\left[ \\sin^2\\left(\\frac{k_x h}{2}\\right) + \\sin^2\\left(\\frac{k_y h}{2}\\right) \\right] $$\n算子 $A = \\kappa L_h$ 的特征值为 $\\lambda_A = \\kappa \\lambda_{L_h}$：\n$$ \\lambda_A(k_x, k_y) = -\\frac{4\\kappa}{h^2} \\left[ \\sin^2\\left(\\frac{k_x h}{2}\\right) + \\sin^2\\left(\\frac{k_y h}{2}\\right) \\right] $$\n这些特征值是实数且非正的，这是扩散算子的一个特征。\n\n谱半径 $\\rho(A)$ 是谱 $\\sigma(A)$ 中特征值绝对值的最大值。\n$$ \\rho(A) = \\max_{k_x, k_y} |\\lambda_A(k_x, k_y)| = \\max_{k_x, k_y} \\left| -\\frac{4\\kappa}{h^2} \\left[ \\sin^2\\left(\\frac{k_x h}{2}\\right) + \\sin^2\\left(\\frac{k_y h}{2}\\right) \\right] \\right| $$\n当正弦项最大化时，达到最大值。当 $\\theta = \\pm\\pi$ 时，项 $\\sin^2(\\theta/2)$ 的最大值为 $1$。对于网格，无量纲波数 $k_x h$ 和 $k_y h$ 的范围在 $[-\\pi, \\pi]$ 内。因此，最大值在最高可分辨频率处取得，即 $k_x h = \\pi$ 和 $k_y h = \\pi$。\n$$ \\rho(A) = \\frac{4\\kappa}{h^2} \\left[ \\sin^2\\left(\\frac{\\pi}{2}\\right) + \\sin^2\\left(\\frac{\\pi}{2}\\right) \\right] = \\frac{4\\kappa}{h^2} [1 + 1] = \\frac{8\\kappa}{h^2} $$\n\n**$2)$ 最大稳定时间步长 $\\Delta t_{\\max}$ 的推导**\n\n单步积分器的稳定性由其稳定性函数 $R(z)$ 决定。为使方法稳定，对于系统矩阵的所有特征值 $\\lambda$，量 $z = \\Delta t \\lambda$ 必须位于该方法的绝对稳定域内。这表示为对于所有 $\\lambda \\in \\sigma(A)$，都有 $|R(\\Delta t \\lambda)| \\le 1$。\n\n对于经典四阶显式龙格-库塔方法 (RK$4$)，其稳定性函数是指数函数的四阶泰勒多项式：\n$$ R(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!} $$\n我们的算子 $A$ 的特征值均为实数且为负。因此，我们只需要考虑 RK$4$ 在负实轴上的绝对稳定区间。该区间的形式为 $[-S, 0]$，其中 $S>0$ 是稳定区间的长度。这个边界点 $S$ 满足 $|R(-S)|=1$。对于 RK$4$ 的稳定性函数，最左侧的边界点恰好是 $R(z)=1$ 的非零实根。因此，我们求解：\n$$ 1 - S + \\frac{S^2}{2} - \\frac{S^3}{6} + \\frac{S^4}{24} = 1 $$\n这简化为\n$$ \\frac{S^4}{24} - \\frac{S^3}{6} + \\frac{S^2}{2} - S = 0 $$\n求解这个多项式的非零正实根，得出 $S \\approx 2.7852915 \\ldots$。\n\n稳定性条件要求对于所有特征值 $\\lambda_A \\in \\sigma(A)$，必须有 $\\Delta t \\lambda_A \\in [-S, 0]$。由于所有 $\\lambda_A$ 都是非正的，该条件简化为：\n$$ \\Delta t \\lambda_{\\min} \\ge -S $$\n其中 $\\lambda_{\\min}$ 是 $A$ 的最负特征值。该特征值对应于谱半径：\n$$ \\lambda_{\\min} = - \\rho(A) = -\\frac{8\\kappa}{h^2} $$\n将此代入稳定性不等式：\n$$ \\Delta t \\left(-\\frac{8\\kappa}{h^2}\\right) \\ge -S $$\n两边乘以 $-1$ 并反转不等号：\n$$ \\Delta t \\frac{8\\kappa}{h^2} \\le S $$\n当此不等式取等号时，可求得最大稳定时间步长 $\\Delta t_{\\max}$：\n$$ \\Delta t_{\\max} = \\frac{S h^2}{8\\kappa} $$\n代入 $S$ 的数值并计算常数系数：\n$$ \\Delta t_{\\max} = \\frac{2.7852915 \\ldots}{8} \\frac{h^2}{\\kappa} \\approx 0.3481614 \\frac{h^2}{\\kappa} $$\n按要求将数值常数四舍五入到四位有效数字：\n$$ \\Delta t_{\\max} = 0.3482 \\frac{h^2}{\\kappa} $$\n该表达式的单位是 $(\\mathrm{m}^2) / (\\mathrm{m}^2/\\mathrm{s}) = \\mathrm{s}$，与时间步长的单位一致。",
            "answer": "$$\\boxed{0.3482 \\frac{h^2}{\\kappa}}$$"
        },
        {
            "introduction": "现在，我们将方法推广，以构建一个通用的稳定性检查工具。真实的CFD问题通常涉及复杂的算子，例如对流-扩散算子，其特征值并不会整齐地落在实轴或虚轴上。这个实践要求您实现一个程序，在给定任意线性算子的谱和所选的积分器后，能够判断给定的时间步长 $\\Delta t$ 是否稳定 。完成此任务后，您将拥有一个实用的计算程序，能够评估各种半离散系统的稳定性。",
            "id": "3995991",
            "problem": "考虑一个在计算流体动力学（CFD）中常见的线性、常系数、周期性的一维半离散平流-扩散算子。设物理域长度为 $L$（单位为 $\\mathrm{m}$），用 $N$ 个等距点进行离散化，网格间距 $h = L/N$（单位为 $\\mathrm{m}$），平流速度为 $a$（单位为 $\\mathrm{m/s}$），运动粘度为 $\\nu$（单位为 $\\mathrm{m^2/s}$）。使用用于循环差分算子的离散傅里叶变换特征基，作用于离散状态 $u(t)$ 的半离散空间算子 $\\mathcal{L}$ 具有特征对 $\\left(\\lambda_j, \\phi_j\\right)$，索引为 $j \\in \\{0,1,\\dots,N-1\\}$，其特征值由下式给出\n$$\n\\lambda_j = -a\\,\\mathrm{i}\\,\\frac{\\sin\\left(\\theta_j\\right)}{h} + \\nu\\,\\frac{2\\cos\\left(\\theta_j\\right) - 2}{h^2}, \\quad \\theta_j = \\frac{2\\pi j}{N},\n$$\n其中 $\\mathrm{i}$ 表示虚数单位。这可由中心差分一阶导数算子和周期性网格上的二阶离散拉普拉斯算子的符号推导得出。\n\n应用于线性测试方程 $\\frac{\\mathrm{d}y}{\\mathrm{d}t} = \\lambda y$ 的显式单步时间积分器通过 $y_{n+1} = R(z)\\,y_n$ 将 $y_{n}$推进到 $y_{n+1}$，其中 $z = \\Delta t\\,\\lambda$，而 $R(z)$ 是由该方法导出的标量稳定性函数。绝对稳定域 $\\mathcal{S}$ 定义为\n$$\n\\mathcal{S} = \\left\\{z \\in \\mathbb{C} \\;:\\; \\left|R(z)\\right| \\leq 1 \\right\\}.\n$$\n在所选的显式积分器和时间步长 $\\Delta t$（单位为 $\\mathrm{s}$）下，半离散系统线性稳定的一个充要条件是所有缩放后的特征值 $z_j = \\Delta t\\,\\lambda_j$ 都位于 $\\mathcal{S}$ 内。\n\n您的任务是实现一个程序，该程序：\n- 使用上述公式计算周期性平流-扩散算子 $\\mathcal{L}$ 的谱 $\\{\\lambda_j\\}_{j=0}^{N-1}$。\n- 对于给定的经典显式积分器（前向欧拉、二阶龙格-库塔、三阶龙格-库塔和四阶龙格-库塔）中的一个，构造并评估相应的稳定性函数 $R(z)$。\n- 通过验证所有 $z_j = \\Delta t\\,\\lambda_j$ 是否满足 $\\left|R(z_j)\\right| \\leq 1$（允许在边界上相等）来测试线性稳定性。\n- 为每个测试用例报告一个布尔值，指示该配置是否稳定。\n\n所有物理参数使用上述指定单位表示，所有角度在内部使用弧度表示。最终输出应为一行，包含一个由方括号括起来的逗号分隔的布尔值列表（例如，$[\\mathrm{True},\\mathrm{False}]$）。\n\n使用以下测试套件，它涵盖了一般情况、边界条件和边缘情况。每个测试用例由元组 $(\\text{integrator}, L, N, a, \\nu, \\Delta t)$ 指定：\n- 测试 $1$（扩散，前向欧拉，预期稳定）：$(\\text{FE},\\; L = 1\\,\\mathrm{m},\\; N = 100,\\; a = 0\\,\\mathrm{m/s},\\; \\nu = 10^{-3}\\,\\mathrm{m^2/s},\\; \\Delta t = 0.02\\,\\mathrm{s})$。\n- 测试 $2$（扩散，前向欧拉，最高波数处的边界情况）：$(\\text{FE},\\; L = 1\\,\\mathrm{m},\\; N = 100,\\; a = 0\\,\\mathrm{m/s},\\; \\nu = 10^{-3}\\,\\mathrm{m^2/s},\\; \\Delta t = 0.05\\,\\mathrm{s})$。\n- 测试 $3$（平流-扩散，前向欧拉，因虚数谱而预期不稳定）：$(\\text{FE},\\; L = 1\\,\\mathrm{m},\\; N = 100,\\; a = 100\\,\\mathrm{m/s},\\; \\nu = 10^{-3}\\,\\mathrm{m^2/s},\\; \\Delta t = 10^{-4}\\,\\mathrm{s})$。\n- 测试 $4$（平流，四阶龙格-库塔，对于小的 $\\Delta t$ 预期稳定）：$(\\text{RK4},\\; L = 1\\,\\mathrm{m},\\; N = 100,\\; a = 100\\,\\mathrm{m/s},\\; \\nu = 0\\,\\mathrm{m^2/s},\\; \\Delta t = 2\\times 10^{-4}\\,\\mathrm{s})$。\n- 测试 $5$（扩散，二阶龙格-库塔，对于大的 $\\Delta t$ 预期不稳定）：$(\\text{RK2},\\; L = 1\\,\\mathrm{m},\\; N = 100,\\; a = 0\\,\\mathrm{m/s},\\; \\nu = 10^{-3}\\,\\mathrm{m^2/s},\\; \\Delta t = 0.075\\,\\mathrm{s})$。\n- 测试 $6$（平流-扩散，三阶龙格-库塔，对于足够小的 $\\Delta t$ 预期稳定）：$(\\text{RK3},\\; L = 1\\,\\mathrm{m},\\; N = 100,\\; a = 50\\,\\mathrm{m/s},\\; \\nu = 10^{-3}\\,\\mathrm{m^2/s},\\; \\Delta t = 10^{-4}\\,\\mathrm{s})$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果（例如，$[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True},\\mathrm{False},\\mathrm{True}]$）。不应打印任何其他文本。",
            "solution": "用户要求解决一个关于一维平流-扩散方程数值格式线性稳定性的问题。该问题是有效的、有科学依据的且适定的。求解方法基于线法，其中空间和时间离散化被分开分析。全离散格式的稳定性取决于半离散空间算子的谱在经时间步长 $\\Delta t$ 缩放后，是否完全位于显式时间积分器的绝对稳定域内。\n\n求解过程按以下算法步骤进行：\n\n首先，我们定义每个测试用例提供的参数：积分器类型、域长度 $L$、网格点数 $N$、平流速度 $a$、运动粘度 $\\nu$ 和时间步长 $\\Delta t$。根据这些参数，计算网格间距为 $h = L/N$。\n\n其次，我们计算半离散空间算子 $\\mathcal{L}$ 的谱。问题陈述中指出，对于用 $N$ 个点离散化的周期域，其特征值 $\\lambda_j$ 由以下公式给出，其中 $j \\in \\{0, 1, \\dots, N-1\\}$：\n$$\n\\lambda_j = -a\\,\\mathrm{i}\\,\\frac{\\sin\\left(\\theta_j\\right)}{h} + \\nu\\,\\frac{2\\cos\\left(\\theta_j\\right) - 2}{h^2}\n$$\n其中 $\\theta_j = \\frac{2\\pi j}{N}$，$\\mathrm{i}$ 是虚数单位。第一项 $-a\\,\\mathrm{i}\\,\\frac{\\sin\\left(\\theta_j\\right)}{h}$ 来自平流项 $a\\frac{\\partial u}{\\partial x}$ 的二阶中心差分近似，其特征值为纯虚数。第二项 $\\nu\\,\\frac{2\\cos\\left(\\theta_j\\right) - 2}{h^2}$ 来自扩散项 $\\nu\\frac{\\partial^2 u}{\\partial x^2}$ 的二阶中心差分近似，其特征值为实数且非正。所有特征值的集合 $\\{\\lambda_j\\}_{j=0}^{N-1}$ 在复平面的左半部分形成一个轨迹。\n\n第三，我们为指定的显式时间积分器定义稳定性函数 $R(z)$。这些函数是复变量 $z$ 的多项式，通过将积分器应用于标量测试方程 $\\frac{\\mathrm{d}y}{\\mathrm{d}t} = \\lambda y$ 而导出，得到 $y_{n+1} = R(\\Delta t \\lambda) y_n$。对于指定的 $p$ 阶经典龙格-库塔方法，稳定性函数是指数函数 $e^z$ 的 $p$ 次泰勒多项式：\n$$\nR_p(z) = \\sum_{k=0}^{p} \\frac{z^k}{k!}\n$$\n具体的函数是：\n-   前向欧拉（FE, $p=1$）：$R(z) = 1 + z$\n-   二阶龙格-库塔（RK2, $p=2$）：$R(z) = 1 + z + \\frac{1}{2}z^2$\n-   三阶龙格-库塔（RK3, $p=3$）：$R(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3$\n-   四阶龙格-库塔（RK4, $p=4$）：$R(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3 + \\frac{1}{24}z^4$\n\n第四，我们确定数值格式的稳定性。对于给定的时间步长 $\\Delta t$，每个特征值 $\\lambda_j$ 被缩放为 $z_j = \\Delta t \\lambda_j$。当且仅当所有这些缩放后的特征值 $z_j$ 都位于所选积分器的绝对稳定域 $\\mathcal{S}$ 内时，该数值方法才是稳定的。稳定域定义为 $\\mathcal{S} = \\{z \\in \\mathbb{C} : |R(z)| \\leq 1\\}$。因此，需要验证的稳定性条件是：\n$$\n\\max_{j \\in \\{0, \\dots, N-1\\}} |R(z_j)| \\leq 1\n$$\n其中允许相等。这个检查必须对所有 $N$ 个特征值执行。\n\n对于每个测试用例，程序将计算 $z_j$ 值的数组，为每个元素评估 $|R(z_j)|$，并检查所有得到的模是否小于或等于 $1$。如果此条件成立，则该配置是稳定的（True）；否则，它是不稳定的（False）。然后，所有测试用例的布尔结果被汇总到一个列表中进行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stability analysis problem for a semi-discretized 1D advection-diffusion equation.\n    \"\"\"\n    \n    # Define the stability functions for the explicit integrators.\n    def r_fe(z):\n        \"\"\"Stability function for Forward Euler.\"\"\"\n        return 1 + z\n\n    def r_rk2(z):\n        \"\"\"Stability function for 2nd-order Runge-Kutta.\"\"\"\n        return 1 + z + 0.5 * z**2\n\n    def r_rk3(z):\n        \"\"\"Stability function for 3rd-order Runge-Kutta.\"\"\"\n        return 1 + z + 0.5 * z**2 + (1/6) * z**3\n\n    def r_rk4(z):\n        \"\"\"Stability function for 4th-order Runge-Kutta.\"\"\"\n        return 1 + z + 0.5 * z**2 + (1/6) * z**3 + (1/24) * z**4\n    \n    integrator_map = {\n        'FE': r_fe,\n        'RK2': r_rk2,\n        'RK3': r_rk3,\n        'RK4': r_rk4,\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (diffusion, Forward Euler, expected stable)\n        ('FE', 1.0, 100, 0.0, 1e-3, 0.02),\n        # Test 2 (diffusion, Forward Euler, boundary case)\n        ('FE', 1.0, 100, 0.0, 1e-3, 0.05),\n        # Test 3 (advection-diffusion, Forward Euler, expected unstable)\n        ('FE', 1.0, 100, 100.0, 1e-3, 1e-4),\n        # Test 4 (advection, RK4, expected stable)\n        ('RK4', 1.0, 100, 100.0, 0.0, 2e-4),\n        # Test 5 (diffusion, RK2, expected unstable)\n        ('RK2', 1.0, 100, 0.0, 1e-3, 0.075),\n        # Test 6 (advection-diffusion, RK3, expected stable)\n        ('RK3', 1.0, 100, 50.0, 1e-3, 1e-4),\n    ]\n\n    results = []\n    for case in test_cases:\n        integrator_key, L, N, a, nu, dt = case\n        \n        # Calculate grid spacing\n        h = L / N\n        \n        # Create array of indices j\n        j = np.arange(N)\n        \n        # Calculate theta_j values\n        theta = 2 * np.pi * j / N\n        \n        # Compute the spectrum of eigenvalues (lambda_j)\n        # Using 1j for the imaginary unit.\n        lambda_j = -a * 1j * (np.sin(theta) / h) + nu * ((2 * np.cos(theta) - 2) / h**2)\n        \n        # Scale eigenvalues by the time step to get z_j\n        z_j = dt * lambda_j\n        \n        # Get the appropriate stability function\n        R = integrator_map[integrator_key]\n        \n        # Evaluate the stability function for all z_j\n        magnitudes = np.abs(R(z_j))\n        \n        # Check if all magnitudes are less than or equal to 1.0\n        # A small tolerance is used to prevent floating point inaccuracies from causing failure at the boundary.\n        is_stable = np.all(magnitudes = 1.0 + 1e-12)\n        \n        results.append(is_stable)\n\n    # Format the final output as a comma-separated list of booleans in brackets.\n    # The str(bool) conversion will produce 'True'/'False' as required.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}