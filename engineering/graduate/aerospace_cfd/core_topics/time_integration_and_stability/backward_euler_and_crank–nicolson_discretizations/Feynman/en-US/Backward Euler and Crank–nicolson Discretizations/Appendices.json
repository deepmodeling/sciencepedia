{
    "hands_on_practices": [
        {
            "introduction": "This exercise focuses on a fundamental task in numerical analysis: empirically verifying the theoretical order of accuracy of a scheme. By applying the Crank-Nicolson method to a simple ordinary differential equation that models the decay of a Fourier mode in the heat equation, you will directly measure the discretization error. This practice  is crucial for building confidence in a numerical method and understanding how its error scales with the time step size, confirming the expected $O(\\Delta t^2)$ behavior.",
            "id": "3945392",
            "problem": "Consider the one-dimensional heat equation, widely used in Computational Fluid Dynamics (CFD), given by $u_t = \\alpha u_{xx}$ on a periodic domain $x \\in [0,2\\pi]$ with thermal diffusivity $\\alpha > 0$. For the initial condition $u(x,0) = \\sin(m x)$ with integer wavenumber $m \\geq 0$ (angles measured in radians), the spatial operator applied to the sine mode is exact, and the Fourier amplitude $a(t)$ satisfies the scalar ordinary differential equation $a'(t) = -\\lambda a(t)$, where $\\lambda = \\alpha m^2$. The exact solution is $a(t) = \\exp(-\\lambda t)a(0)$.\n\nYour task is to write a complete, runnable program that:\n- Implements time integration of the scalar amplitude $a(t)$ using the Crank–Nicolson scheme over $N$ uniform time steps of size $\\Delta t$ to a final time $T$ (assume $T$ is an integer multiple of $\\Delta t$ so that $N = T/\\Delta t$ is an integer).\n- Computes the temporal discretization error magnitude at the final time $T$ as $E(\\Delta t) = |a_{\\text{CN}}(T) - a_{\\text{exact}}(T)|$, where $a_{\\text{CN}}(T)$ is the Crank–Nicolson approximation after $N$ steps applied to the scalar ordinary differential equation, starting from $a(0) = 1$, and $a_{\\text{exact}}(T) = \\exp(-\\lambda T)$.\n- Quantifies the second-order time-step scaling by reporting the ratio $E(\\Delta t)/\\Delta t^2$ for specific test cases.\n\nUse the following test suite of parameter values (each test case is specified by $(\\alpha, m, T, \\Delta t)$):\n- Case $1$ (scaling quantification, three values of $\\Delta t$): $(\\alpha, m, T, \\Delta t) = (0.5, 3, 1.0, 0.2)$, $(0.5, 3, 1.0, 0.1)$, $(0.5, 3, 1.0, 0.05)$.\n- Case $2$ (boundary condition $m=0$, implying $\\lambda=0$): $(\\alpha, m, T, \\Delta t) = (0.7, 0, 1.0, 0.25)$.\n- Case $3$ (boundary condition $T=0$): $(\\alpha, m, T, \\Delta t) = (1.0, 4, 0.0, 0.1)$.\n- Case $4$ (large time step but stable): $(\\alpha, m, T, \\Delta t) = (1.0, 1, 2.0, 1.0)$.\n\nAll quantities are nondimensional. Angles must be interpreted in radians.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order:\n$[E(0.2)/0.2^2,\\;E(0.1)/0.1^2,\\;E(0.05)/0.05^2,\\;E_{\\text{case 2}}/0.25^2,\\;E_{\\text{case 3}}/0.1^2,\\;E_{\\text{case 4}}/1.0^2]$.\n\nThe final outputs must be floating-point numbers.",
            "solution": "The problem is valid. It is a well-posed, scientifically grounded exercise in the numerical analysis of ordinary differential equations (ODEs), which arise from the study of partial differential equations (PDEs) in computational fluid dynamics. All necessary parameters and conditions are provided, and the problem is free of any contradictions or ambiguities.\n\nThe task is to analyze the temporal discretization error of the Crank-Nicolson scheme applied to a model problem. This model problem is the scalar ODE governing the amplitude of a single Fourier mode for the one-dimensional heat equation.\n\nThe heat equation is given as $u_t = \\alpha u_{xx}$. For an initial condition of a single Fourier mode on a periodic domain, $u(x,0) = \\sin(m x)$, the solution retains its spatial form, $u(x,t) = a(t)\\sin(m x)$. Substituting this into the PDE yields an ODE for the amplitude $a(t)$:\n$$\n\\frac{d}{dt}(a(t)\\sin(m x)) = \\alpha \\frac{\\partial^2}{\\partial x^2}(a(t)\\sin(m x))\n$$\n$$\na'(t)\\sin(m x) = \\alpha a(t) (-m^2 \\sin(m x))\n$$\n$$\na'(t) = -(\\alpha m^2) a(t)\n$$\nThis is the model ODE, $a'(t) = -\\lambda a(t)$, where the decay rate is $\\lambda = \\alpha m^2$.\nThe problem specifies an initial amplitude $a(0) = 1$. The exact solution to this initial value problem is:\n$$\na_{\\text{exact}}(t) = a(0) e^{-\\lambda t} = e^{-\\lambda t}\n$$\nAt the final time $T$, the exact solution is $a_{\\text{exact}}(T) = e^{-\\lambda T}$.\n\nWe are asked to approximate the solution using the Crank-Nicolson time-integration scheme. Let $a^n$ be the numerical approximation of $a(t_n)$, where $t_n = n\\Delta t$. The Crank-Nicolson scheme for the ODE $a' = f(a) = -\\lambda a$ is an implicit method that averages the derivative at times $t_n$ and $t_{n+1}$:\n$$\n\\frac{a^{n+1} - a^n}{\\Delta t} = \\frac{1}{2} \\left[ f(a^{n+1}) + f(a^n) \\right]\n$$\nSubstituting $f(a) = -\\lambda a$:\n$$\n\\frac{a^{n+1} - a^n}{\\Delta t} = \\frac{1}{2} \\left[ (-\\lambda a^{n+1}) + (-\\lambda a^n) \\right]\n$$\nTo find the update rule, we solve for $a^{n+1}$:\n$$\na^{n+1} - a^n = -\\frac{\\lambda \\Delta t}{2} (a^{n+1} + a^n)\n$$\n$$\na^{n+1} \\left(1 + \\frac{\\lambda \\Delta t}{2}\\right) = a^n \\left(1 - \\frac{\\lambda \\Delta t}{2}\\right)\n$$\n$$\na^{n+1} = \\left( \\frac{1 - \\frac{\\lambda \\Delta t}{2}}{1 + \\frac{\\lambda \\Delta t}{2}} \\right) a^n\n$$\nThis recurrence relation can be solved. Starting from $a^0 = a(0) = 1$, the solution after $N$ steps, where $N=T/\\Delta t$, is:\n$$\na_{\\text{CN}}(T) = a^N = \\left( \\frac{1 - \\frac{\\lambda \\Delta t}{2}}{1 + \\frac{\\lambda \\Delta t}{2}} \\right)^N a^0 = \\left( \\frac{1 - \\frac{\\lambda \\Delta t}{2}}{1 + \\frac{\\lambda \\Delta t}{2}} \\right)^N\n$$\nThe temporal discretization error at the final time $T$ is defined as the magnitude of the difference between the numerical and exact solutions:\n$$\nE(\\Delta t) = |a_{\\text{CN}}(T) - a_{\\text{exact}}(T)|\n$$\nThe Crank-Nicolson scheme is second-order accurate in time, meaning that for small $\\Delta t$, the error $E(\\Delta t)$ is expected to be proportional to $\\Delta t^2$, i.e., $E(\\Delta t) \\approx C \\Delta t^2$ for some constant $C$ that depends on the problem parameters but not on $\\Delta t$. To verify this, we compute the ratio $E(\\Delta t) / \\Delta t^2$. For a second-order scheme, this ratio should be approximately constant as $\\Delta t \\to 0$.\n\nThe specific test cases will be evaluated as follows:\nFor each tuple $(\\alpha, m, T, \\Delta t)$:\n1. Calculate the decay rate $\\lambda = \\alpha m^2$.\n2. Calculate the number of time steps $N = T/\\Delta t$. If $T=0$, then $N=0$. If $m=0$, then $\\lambda=0$.\n3. Compute the exact solution $a_{\\text{exact}}(T) = e^{-\\lambda T}$.\n4. Compute the numerical solution $a_{\\text{CN}}(T) = \\left( \\frac{1 - 0.5\\lambda \\Delta t}{1 + 0.5\\lambda \\Delta t} \\right)^N$. If $\\lambda=0$ or $T=0$, this simplifies correctly. For $\\lambda=0$, the fraction is $1$ and $a_{\\text{CN}}(T)=1$. For $T=0$, $N=0$ and $a_{\\text{CN}}(T)=1$ (since any non-zero base to the power of $0$ is $1$).\n5. Compute the error $E(\\Delta t) = |a_{\\text{CN}}(T) - a_{\\text{exact}}(T)|$.\n6. Compute the final required ratio $E(\\Delta t) / \\Delta t^2$. For cases where $E(\\Delta t)=0$, this ratio is $0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the second-order time-step scaling ratio for a Crank-Nicolson\n    discretization of a model ODE derived from the 1D heat equation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (alpha, m, T, dt).\n    test_cases = [\n        (0.5, 3, 1.0, 0.2),\n        (0.5, 3, 1.0, 0.1),\n        (0.5, 3, 1.0, 0.05),\n        (0.7, 0, 1.0, 0.25),\n        (1.0, 4, 0.0, 0.1),\n        (1.0, 1, 2.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, m, T, dt = case\n\n        # 1. Calculate the decay rate lambda\n        lambda_val = alpha * m**2\n\n        # 2. Calculate the number of time steps N.\n        # The problem statement guarantees T is an integer multiple of dt.\n        # To be robust with floating point, we can round, but int(T/dt) is sufficient here.\n        if T == 0.0:\n            N = 0\n        else:\n            N = int(T / dt)\n\n        # 3. Compute the exact solution at time T.\n        # The initial condition is a(0) = 1.\n        a_exact = np.exp(-lambda_val * T)\n\n        # 4. Compute the numerical solution using Crank-Nicolson.\n        # The update is a^{n+1} = g_cn * a^n, where g_cn is the amplification factor.\n        # So a_cn(T) = (g_cn)^N * a(0).\n        # Handle the case where the denominator could be zero, though not possible\n        # for lambda >= 0.\n        denominator = 1.0 + 0.5 * lambda_val * dt\n        if denominator == 0:\n            # This physical scenario is not expected but included for robustness.\n            # It would imply infinite amplification.\n            # For this problem, lambda_val >= 0 and dt > 0, so denominator > 1.\n            a_cn = float('inf')\n        else:\n            g_cn = (1.0 - 0.5 * lambda_val * dt) / denominator\n            a_cn = g_cn**N\n\n        # 5. Compute the error magnitude.\n        error = abs(a_cn - a_exact)\n\n        # 6. Compute the second-order scaling ratio.\n        # The denominator dt**2 is guaranteed to be non-zero by the problem's dt > 0.\n        ratio = error / (dt**2)\n        results.append(ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While the Crank-Nicolson scheme is celebrated for its second-order accuracy and unconditional stability for diffusion problems, its performance on convection-dominated problems requires careful scrutiny. This hands-on calculation serves as a critical cautionary tale, demonstrating how applying a centered scheme like Crank-Nicolson to a sharp gradient in an advection problem can generate non-physical oscillations, including overshoots and undershoots. Understanding this behavior  is essential for selecting appropriate discretization schemes in CFD, particularly for flows with shocks or sharp interfaces.",
            "id": "3945376",
            "problem": "Consider the linear advection conservation law $\\partial_{t} u + a \\,\\partial_{x} u = 0$ with constant convection speed $a > 0$ on a periodic domain discretized by $4$ uniformly spaced nodes indexed by $j \\in \\{0,1,2,3\\}$ with spacing $\\Delta x$. Let $u_{j}^{n}$ denote the nodal solution at time level $t^{n}$. Use the second-order centered finite difference for the spatial derivative, namely $\\partial_{x} u \\approx \\left(u_{j+1}^{n} - u_{j-1}^{n}\\right)/(2 \\Delta x)$ with periodic indexing, and apply the Crank–Nicolson time discretization to advance from $t^{0}$ to $t^{1} = t^{0} + \\Delta t$.\n\nDefine the Courant–Friedrichs–Lewy (CFL) number $C = a \\Delta t/\\Delta x$ and set $C = 4$. Let the initial data be the discrete step $u_{0}^{0} = 1$, $u_{1}^{0} = 1$, $u_{2}^{0} = 0$, $u_{3}^{0} = 0$ on the $4$-node periodic grid. Starting from the conservation law and the stated discrete spatial operator, derive the Crank–Nicolson update for one time step and compute the nodal values $u_{j}^{1}$ at $t^{1}$. Demonstrate that the scheme produces both undershoot and overshoot for this convection-dominated case.\n\nReport the largest value of $u_{j}^{1}$ over $j \\in \\{0,1,2,3\\}$ as a single simplified fraction. No units are required. No rounding is required.",
            "solution": "The analysis of the problem statement indicates that it is scientifically grounded, well-posed, objective, and complete. All necessary data and definitions for solving the problem are provided, and the setup is consistent with standard principles of numerical analysis for partial differential equations. Therefore, the problem is deemed valid.\n\nThe governing equation is the linear advection conservation law:\n$$\n\\partial_{t} u + a \\,\\partial_{x} u = 0\n$$\nwhere $a > 0$ is a constant convection speed.\n\nThe problem specifies the use of the Crank–Nicolson method for time discretization. For an ordinary differential equation of the form $\\frac{du}{dt} = F(u)$, the Crank-Nicolson scheme is:\n$$\n\\frac{u^{n+1} - u^{n}}{\\Delta t} = \\frac{1}{2} \\left( F(u^{n+1}) + F(u^{n}) \\right)\n$$\nIn our case, $F(u) = -a \\,\\partial_{x} u$. Applying this to the nodal value $u_j$, we have:\n$$\n\\frac{u_{j}^{n+1} - u_{j}^{n}}{\\Delta t} = -\\frac{a}{2} \\left( (\\partial_{x} u)_{j}^{n+1} + (\\partial_{x} u)_{j}^{n} \\right)\n$$\nThe spatial derivative $\\partial_{x} u$ is approximated using a second-order centered finite difference:\n$$\n(\\partial_{x} u)_{j} \\approx \\frac{u_{j+1} - u_{j-1}}{2 \\Delta x}\n$$\nSubstituting this spatial discretization into the Crank-Nicolson formula yields:\n$$\n\\frac{u_{j}^{n+1} - u_{j}^{n}}{\\Delta t} = -\\frac{a}{2} \\left( \\frac{u_{j+1}^{n+1} - u_{j-1}^{n+1}}{2 \\Delta x} + \\frac{u_{j+1}^{n} - u_{j-1}^{n}}{2 \\Delta x} \\right)\n$$\nMultiplying by $\\Delta t$ and rearranging terms to group the unknowns at time level $n+1$ on the left-hand side (LHS) and knowns at time level $n$ on the right-hand side (RHS):\n$$\nu_{j}^{n+1} + \\frac{a \\Delta t}{4 \\Delta x} (u_{j+1}^{n+1} - u_{j-1}^{n+1}) = u_{j}^{n} - \\frac{a \\Delta t}{4 \\Delta x} (u_{j+1}^{n} - u_{j-1}^{n})\n$$\nWe are given the Courant–Friedrichs–Lewy (CFL) number $C = \\frac{a \\Delta t}{\\Delta x}$. Substituting this definition into the equation:\n$$\nu_{j}^{n+1} + \\frac{C}{4} u_{j+1}^{n+1} - \\frac{C}{4} u_{j-1}^{n+1} = u_{j}^{n} - \\frac{C}{4} u_{j+1}^{n} + \\frac{C}{4} u_{j-1}^{n}\n$$\nThe problem specifies $C=4$. The update equation simplifies to:\n$$\nu_{j}^{n+1} + u_{j+1}^{n+1} - u_{j-1}^{n+1} = u_{j}^{n} - u_{j+1}^{n} + u_{j-1}^{n}\n$$\nWe need to solve for the nodal values $u_{j}^{1}$ at time $t^{1}$ given the initial data $u_{j}^{0}$ at $t^{0}$. The grid has $4$ nodes, indexed by $j \\in \\{0,1,2,3\\}$, with periodic boundary conditions. This means indices are taken modulo $4$, e.g., $u_{-1} = u_{3}$ and $u_{4} = u_{0}$.\n\nLet us write the system of linear equations for the unknowns $\\mathbf{u}^{1} = [u_{0}^{1}, u_{1}^{1}, u_{2}^{1}, u_{3}^{1}]^T$.\n\nFor $j=0$:\n$u_{0}^{1} + u_{1}^{1} - u_{-1}^{1} = u_{0}^{0} - u_{1}^{0} + u_{-1}^{0}$\nUsing periodicity ($u_{-1}=u_3$):\n$u_{0}^{1} + u_{1}^{1} - u_{3}^{1} = u_{0}^{0} - u_{1}^{0} + u_{3}^{0} = 1 - 1 + 0 = 0$\n\nFor $j=1$:\n$u_{1}^{1} + u_{2}^{1} - u_{0}^{1} = u_{1}^{0} - u_{2}^{0} + u_{0}^{0} = 1 - 0 + 1 = 2$\n\nFor $j=2$:\n$u_{2}^{1} + u_{3}^{1} - u_{1}^{1} = u_{2}^{0} - u_{3}^{0} + u_{1}^{0} = 0 - 0 + 1 = 1$\n\nFor $j=3$:\n$u_{3}^{1} + u_{4}^{1} - u_{2}^{1} = u_{3}^{0} - u_{4}^{0} + u_{2}^{0}$\nUsing periodicity ($u_{4}=u_0$):\n$u_{3}^{1} + u_{0}^{1} - u_{2}^{1} = u_{3}^{0} - u_{0}^{0} + u_{2}^{0} = 0 - 1 + 0 = -1$\n\nThe resulting system of $4$ linear equations is:\n1. $u_{0}^{1} + u_{1}^{1} - u_{3}^{1} = 0$\n2. $-u_{0}^{1} + u_{1}^{1} + u_{2}^{1} = 2$\n3. $-u_{1}^{1} + u_{2}^{1} + u_{3}^{1} = 1$\n4. $u_{0}^{1} - u_{2}^{1} + u_{3}^{1} = -1$\n\nWe proceed to solve this system.\nFrom equation (1), we can express $u_{3}^{1}$ in terms of $u_{0}^{1}$ and $u_{1}^{1}$:\n$u_{3}^{1} = u_{0}^{1} + u_{1}^{1}$\n\nSubstitute this into equation (3):\n$-u_{1}^{1} + u_{2}^{1} + (u_{0}^{1} + u_{1}^{1}) = 1 \\implies u_{0}^{1} + u_{2}^{1} = 1$\nThis gives us $u_{2}^{1} = 1 - u_{0}^{1}$.\n\nSubstitute the expression for $u_{3}^{1}$ into equation (4):\n$u_{0}^{1} - u_{2}^{1} + (u_{0}^{1} + u_{1}^{1}) = -1 \\implies 2u_{0}^{1} - u_{2}^{1} + u_{1}^{1} = -1$\nNow, substitute the expression for $u_{2}^{1}$ into this new equation:\n$2u_{0}^{1} - (1 - u_{0}^{1}) + u_{1}^{1} = -1 \\implies 3u_{0}^{1} - 1 + u_{1}^{1} = -1 \\implies 3u_{0}^{1} + u_{1}^{1} = 0$\nThis gives us $u_{1}^{1} = -3u_{0}^{1}$.\n\nWe have now expressed $u_{1}^{1}$, $u_{2}^{1}$, and $u_{3}^{1}$ in terms of $u_{0}^{1}$. We use the remaining equation, (2), to solve for $u_{0}^{1}$:\n$-u_{0}^{1} + u_{1}^{1} + u_{2}^{1} = 2$\nSubstitute the expressions for $u_{1}^{1}$ and $u_{2}^{1}$:\n$-u_{0}^{1} + (-3u_{0}^{1}) + (1 - u_{0}^{1}) = 2$\n$-5u_{0}^{1} + 1 = 2$\n$-5u_{0}^{1} = 1$\n$u_{0}^{1} = -\\frac{1}{5}$\n\nNow we can back-substitute to find the other nodal values:\n$u_{1}^{1} = -3u_{0}^{1} = -3(-\\frac{1}{5}) = \\frac{3}{5}$\n$u_{2}^{1} = 1 - u_{0}^{1} = 1 - (-\\frac{1}{5}) = 1 + \\frac{1}{5} = \\frac{6}{5}$\n$u_{3}^{1} = u_{0}^{1} + u_{1}^{1} = -\\frac{1}{5} + \\frac{3}{5} = \\frac{2}{5}$\n\nThe solution at time $t^{1}$ is the vector $\\mathbf{u}^{1} = [-\\frac{1}{5}, \\frac{3}{5}, \\frac{6}{5}, \\frac{2}{5}]^T$.\n\nThe initial data ranged from $u_{\\text{min}}^{0}=0$ to $u_{\\text{max}}^{0}=1$. The computed solution at $t^{1}$ contains the value $u_{0}^{1} = -1/5$, which is below the initial minimum. This is an undershoot. The solution also contains the value $u_{2}^{1} = 6/5 = 1.2$, which is above the initial maximum. This is an overshoot. The scheme thus produces non-physical oscillations, characteristic of centered schemes for convection-dominated problems, especially at high CFL numbers.\n\nThe problem asks for the largest value of $u_{j}^{1}$ over $j \\in \\{0,1,2,3\\}$.\nThe set of values is $\\{-\\frac{1}{5}, \\frac{3}{5}, \\frac{6}{5}, \\frac{2}{5}\\}$.\nComparing these fractions:\n$-\\frac{1}{5} < \\frac{2}{5} < \\frac{3}{5} < \\frac{6}{5}$\nThe largest value is $\\frac{6}{5}$.\nThis is a simplified fraction as requested.",
            "answer": "$$\\boxed{\\frac{6}{5}}$$"
        },
        {
            "introduction": "Moving from linear model problems to realistic CFD applications often means confronting nonlinearity. This practice addresses this challenge head-on by applying the Crank-Nicolson method to a nonlinear advection-diffusion-reaction equation, which results in a system of nonlinear algebraic equations at each time step. You will implement the core of an implicit solver by performing a single Newton-Raphson iteration, which involves forming the Jacobian matrix and solving a linear system to update the solution, a foundational skill for advanced computational work .",
            "id": "3945416",
            "problem": "Consider the one-dimensional, dimensionless advection–diffusion–reaction equation, a common scalar model in Aerospace Computational Fluid Dynamics (CFD), for a quantity $u(x,t)$ defined on the spatial interval $x \\in [0,1]$ and time $t \\ge 0$:\n$$\n\\frac{\\partial u}{\\partial t} + v(x,t)\\,\\frac{\\partial u}{\\partial x} \\;=\\; \\nu\\,\\frac{\\partial^2 u}{\\partial x^2} \\;+\\; \\sigma\\,u^3,\n$$\nsubject to homogeneous Dirichlet boundary conditions $u(0,t)=0$ and $u(1,t)=0$. Assume all variables are nondimensional. Here, $v(x,t)$ is the advective velocity, $\\nu>0$ is a viscosity coefficient, and $\\sigma\\ge 0$ is a nonlinear reaction coefficient.\n\nYou will apply the Crank–Nicolson (CN) time discretization with a single time step from time level $t^n$ to $t^{n+1}=t^n+\\Delta t$, and use lagged convection, meaning the advective velocity in the implicit term is evaluated using the previous time level quantity. Specifically, use $v(x,t^n)=u(x,t^n)$ as the lagged advective velocity and central differences for spatial derivatives:\n- For the first derivative at an interior grid point $x_i$, use the central difference $(u_{i+1}-u_{i-1})/(2\\Delta x)$.\n- For the second derivative at an interior grid point $x_i$, use the central difference $(u_{i+1}-2u_i+u_{i-1})/\\Delta x^2$.\n\nDiscretize space with a uniform grid of $N$ points, including boundaries, with spacing $\\Delta x = 1/(N-1)$, and enforce $u_0 = u_{N-1} = 0$. Let the interior unknowns be $u_i$ for $i=1,2,\\dots,N-2$. Denote the previous time level values by $u_i^n$ and the unknown new time values by $u_i^{n+1}$.\n\nUsing the Crank–Nicolson method and lagged convection, form the nonlinear residual at each interior grid point implied by:\n$$\n\\frac{u^{n+1}-u^n}{\\Delta t} \\;+\\; \\frac{1}{2}\\left[v^*\\,\\frac{\\partial u^{n+1}}{\\partial x} + v^n\\,\\frac{\\partial u^n}{\\partial x}\\right]\n\\;=\\;\n\\frac{1}{2}\\left[\\nu\\,\\frac{\\partial^2 u^{n+1}}{\\partial x^2} + \\nu\\,\\frac{\\partial^2 u^n}{\\partial x^2}\\right]\n\\;+\\;\n\\frac{1}{2}\\left[\\sigma\\,(u^{n+1})^3 + \\sigma\\,(u^n)^3\\right],\n$$\nwhere $v^* = v^n = u^n$ is the lagged advective velocity. The discrete residual is a vector function of the interior unknown vector $u^{n+1}$ that is zero at the solution.\n\nDefine one Newton step for solving the nonlinear system by linearizing the residual around a given initial guess $u^{(0)}$ for $u^{n+1}$. Let the Jacobian be the derivative of the residual with respect to $u^{n+1}$ evaluated at $u^{(0)}$, and compute the Newton update by solving the linear system for the increment and forming $u^{(1)} = u^{(0)}$ plus the increment. Compute the reduction in the residual two-norm after this single Newton step, defined as:\n$$\n\\rho \\;=\\; \\frac{\\left\\|R\\!\\left(u^{(1)}\\right)\\right\\|_2}{\\left\\|R\\!\\left(u^{(0)}\\right)\\right\\|_2},\n$$\nwhere $R(\\cdot)$ is the nonlinear residual vector and $\\|\\cdot\\|_2$ is the Euclidean norm.\n\nImplement the above for the following test suite, which specifies the grid size $N$, time step $\\Delta t$, viscosity $\\nu$, reaction coefficient $\\sigma$, the previous time level $u^n(x)$, and the initial guess $u^{(0)}(x)$ for $u^{n+1}$:\n\n- Test Case 1 (general, moderate nonlinearity):\n  - $N = 51$, $\\Delta t = 0.005$, $\\nu = 0.01$, $\\sigma = 1.0$.\n  - $u^n(x) = \\sin(\\pi x)$.\n  - $u^{(0)}(x) = u^n(x)$.\n\n- Test Case 2 (stronger nonlinearity and larger time step):\n  - $N = 51$, $\\Delta t = 0.05$, $\\nu = 0.005$, $\\sigma = 5.0$.\n  - $u^n(x) = 0.5\\,\\sin(2\\pi x) + 0.25\\,\\sin(\\pi x)$.\n  - $u^{(0)}(x) = 0$ for all interior points.\n\n- Test Case 3 (linear case, zero reaction):\n  - $N = 31$, $\\Delta t = 0.01$, $\\nu = 0.02$, $\\sigma = 0.0$.\n  - $u^n(x) = \\sin(\\pi x)$.\n  - $u^{(0)}(x) = 0$ for all interior points.\n\nAll quantities are to be treated as dimensionless, and no physical units are required. Your program should compute the reduction factor $\\rho$ for each test case and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\rho_1,\\rho_2,\\rho_3]$. The values must be numeric floats. Use central differences as described, and enforce $u(0,t)=u(1,t)=0$ at all times and in all approximations.",
            "solution": "### Problem Validation\n\n#### Step 1: Extract Givens\n\nThe problem provides the following information for the one-dimensional advection–diffusion–reaction equation for a quantity $u(x,t)$:\n-   **Governing Equation**: $\\frac{\\partial u}{\\partial t} + v(x,t)\\,\\frac{\\partial u}{\\partial x} \\;=\\; \\nu\\,\\frac{\\partial^2 u}{\\partial x^2} \\;+\\; \\sigma\\,u^3$\n-   **Domain**: $x \\in [0,1]$, $t \\ge 0$.\n-   **Boundary Conditions**: Homogeneous Dirichlet, $u(0,t)=0$ and $u(1,t)=0$.\n-   **Advective Velocity**: $v(x,t) = u(x,t)$.\n-   **Coefficients**: Viscosity $\\nu>0$, nonlinear reaction $\\sigma\\ge 0$.\n-   **Time Discretization**: Crank–Nicolson method from $t^n$ to $t^{n+1}=t^n+\\Delta t$, with lagged convection velocity $v^* = v^n = u^n$. The discrete equation is:\n    $$\n    \\frac{u^{n+1}-u^n}{\\Delta t} \\;+\\; \\frac{1}{2}\\left[u^n\\,\\frac{\\partial u^{n+1}}{\\partial x} + u^n\\,\\frac{\\partial u^n}{\\partial x}\\right]\n    \\;=\\;\n    \\frac{1}{2}\\left[\\nu\\,\\frac{\\partial^2 u^{n+1}}{\\partial x^2} + \\nu\\,\\frac{\\partial^2 u^n}{\\partial x^2}\\right]\n    \\;+\\;\n    \\frac{1}{2}\\left[\\sigma\\,(u^{n+1})^3 + \\sigma\\,(u^n)^3\\right]\n    $$\n-   **Spatial Discretization**: Uniform grid with $N$ points, spacing $\\Delta x = 1/(N-1)$. Interior points are $i=1, 2, \\dots, N-2$. Boundary nodes are $u_0 = u_{N-1} = 0$.\n    -   First derivative (central difference): $\\frac{\\partial u}{\\partial x} \\approx \\frac{u_{i+1}-u_{i-1}}{2\\Delta x}$\n    -   Second derivative (central difference): $\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{i+1}-2u_i+u_{i-1}}{\\Delta x^2}$\n-   **Task**:\n    1.  Form the nonlinear residual vector $R(u^{n+1})$.\n    2.  Perform one Newton step to find $u^{(1)}$ from an initial guess $u^{(0)}$. The Newton update is $u^{(1)} = u^{(0)} - J(u^{(0)})^{-1}R(u^{(0)})$.\n    3.  Compute the residual reduction factor $\\rho = \\frac{\\left\\|R(u^{(1)})\\right\\|_2}{\\left\\|R(u^{(0)})\\right\\|_2}$.\n-   **Test Cases**:\n    -   **Case 1**: $N = 51$, $\\Delta t = 0.005$, $\\nu = 0.01$, $\\sigma = 1.0$, $u^n(x) = \\sin(\\pi x)$, $u^{(0)}(x) = u^n(x)$.\n    -   **Case 2**: $N = 51$, $\\Delta t = 0.05$, $\\nu = 0.005$, $\\sigma = 5.0$, $u^n(x) = 0.5\\,\\sin(2\\pi x) + 0.25\\,\\sin(\\pi x)$, $u^{(0)}(x) = 0$.\n    -   **Case 3**: $N = 31$, $\\Delta t = 0.01$, $\\nu = 0.02$, $\\sigma = 0.0$, $u^n(x) = \\sin(\\pi x)$, $u^{(0)}(x) = 0$.\n\n#### Step 2: Validate Using Extracted Givens\n\nThe problem is subjected to a rigorous validation check.\n-   **Scientifically Grounded**: The governing equation is a variant of the viscous Burgers' equation with a reaction term, a fundamental and well-studied model in fluid dynamics and nonlinear physics. The numerical methods prescribed—Crank–Nicolson, central differencing, and Newton's method—are standard, canonical techniques for solving such partial differential equations.\n-   **Well-Posed**: The problem is well-posed. It provides a specific PDE, boundary conditions, a well-defined numerical scheme, and all necessary parameters and initial data for three distinct test cases. The objective is to compute a specific, uniquely defined numerical quantity, $\\rho$.\n-   **Objective**: The problem is stated in precise, mathematical language, free from any subjectivity or ambiguity.\n-   **Completeness and Consistency**: All information required to perform the computation is provided. The discretization scheme, though a specific semi-implicit variant of Crank-Nicolson, is explicitly defined and contains no contradictions. The variables and parameters are clearly specified for each test case.\n-   **Feasibility**: The problem is a standard numerical analysis exercise. The parameters are dimensionless and do not present any physical or computational infeasibilities.\n\n#### Step 3: Verdict and Action\n\nThe problem statement is **valid**. It is a clear, self-contained, and scientifically sound problem in numerical analysis and computational fluid dynamics. I will proceed with the solution.\n\n### Solution Derivation\n\nThe objective is to compute the reduction in the $L_2$-norm of the nonlinear residual after a single Newton iteration. This requires the formulation of the residual vector, its Jacobian, and the implementation of the Newton step.\n\nLet the vector of unknowns at the interior grid points be $\\mathbf{u}^{n+1} = [u_1^{n+1}, u_2^{n+1}, \\dots, u_{M}^{n+1}]^T$, where $M = N-2$ is the number of interior points. For simplicity, we drop the superscript $n+1$ for the unknown vector, denoting it by $\\mathbf{u}$.\n\n**1. Nonlinear Residual Formulation**\nThe discrete residual $R_i(\\mathbf{u})$ for each interior point $i=1, \\dots, M$ is obtained by moving all terms of the given Crank-Nicolson equation to one side.\n$$\nR_i(\\mathbf{u}) = \\frac{u_i - u_i^n}{\\Delta t} + \\frac{1}{2}\\left[u_i^n\\,\\frac{u_{i+1}-u_{i-1}}{2\\Delta x} + u_i^n\\,\\frac{u_{i+1}^n-u_{i-1}^n}{2\\Delta x}\\right] - \\frac{\\nu}{2}\\left[\\frac{u_{i+1}-2u_i+u_{i-1}}{\\Delta x^2} + \\frac{u_{i+1}^n-2u_i^n+u_{i-1}^n}{\\Delta x^2}\\right] - \\frac{\\sigma}{2}\\left[u_i^3 + (u_i^n)^3\\right]\n$$\nThis equation defines the $i$-th component of the residual vector $R(\\mathbf{u})$. The system of nonlinear equations to solve is $R(\\mathbf{u})=\\mathbf{0}$. The indices for $u$ and $u^n$ are handled with boundary conditions, i.e., $u_0=u_N=u_0^n=u_N^n=0$.\n\n**2. Newton's Method**\nTo solve $R(\\mathbf{u}) = \\mathbf{0}$, Newton's method is employed. Given an initial guess $\\mathbf{u}^{(0)}$, a better approximation $\\mathbf{u}^{(1)}$ is found by solving the linear system for the update $\\delta \\mathbf{u} = \\mathbf{u}^{(1)} - \\mathbf{u}^{(0)}$:\n$$\nJ(\\mathbf{u}^{(0)}) \\delta \\mathbf{u} = -R(\\mathbf{u}^{(0)})\n$$\nwhere $J(\\mathbf{u}^{(0)})$ is the Jacobian matrix of the residual vector $R$ evaluated at $\\mathbf{u}^{(0)}$. The entries of the Jacobian are $J_{ij} = \\frac{\\partial R_i}{\\partial u_j}$. After solving for $\\delta \\mathbf{u}$, the solution is updated: $\\mathbf{u}^{(1)} = \\mathbf{u}^{(0)} + \\delta \\mathbf{u}$.\n\n**3. Jacobian Matrix Derivation**\nThe residual $R_i$ depends on $u_{i-1}$, $u_i$, and $u_{i+1}$. Consequently, the Jacobian matrix $J$ is tridiagonal. The non-zero entries for row $i$ are $J_{i,i-1}$, $J_{i,i}$, and $J_{i,i+1}$. Let's compute these partial derivatives from the expression for $R_i$, evaluated at an arbitrary point $\\mathbf{u}$:\n\n-   **Sub-diagonal term ($j=i-1$)**:\n    $$\n    J_{i,i-1} = \\frac{\\partial R_i}{\\partial u_{i-1}} = \\frac{1}{2}\\left[u_i^n \\frac{-1}{2\\Delta x}\\right] - \\frac{\\nu}{2}\\left[\\frac{1}{\\Delta x^2}\\right] = -\\frac{u_i^n}{4\\Delta x} - \\frac{\\nu}{2\\Delta x^2}\n    $$\n\n-   **Main diagonal term ($j=i$)**:\n    $$\n    J_{i,i} = \\frac{\\partial R_i}{\\partial u_i} = \\frac{1}{\\Delta t} - \\frac{\\nu}{2}\\left[\\frac{-2}{\\Delta x^2}\\right] - \\frac{\\sigma}{2}[3u_i^2] = \\frac{1}{\\Delta t} + \\frac{\\nu}{\\Delta x^2} - \\frac{3\\sigma}{2}u_i^2\n    $$\n\n-   **Super-diagonal term ($j=i+1$)**:\n    $$\n    J_{i,i+1} = \\frac{\\partial R_i}{\\partial u_{i+1}} = \\frac{1}{2}\\left[u_i^n \\frac{1}{2\\Delta x}\\right] - \\frac{\\nu}{2}\\left[\\frac{1}{\\Delta x^2}\\right] = \\frac{u_i^n}{4\\Delta x} - \\frac{\\nu}{2\\Delta x^2}\n    $$\nThe Jacobian is evaluated at $\\mathbf{u}^{(0)}$ for the Newton step.\n\n**4. Algorithm Summary**\nFor each test case, the following steps are executed:\n1.  Initialize parameters $N$, $\\Delta t$, $\\nu$, $\\sigma$, and spatial grid $x_i$.\n2.  Define the vectors $\\mathbf{u}^n$ and the initial guess $\\mathbf{u}^{(0)}$ for the interior points.\n3.  Compute the initial residual vector $R^{(0)} = R(\\mathbf{u}^{(0)})$ and its Euclidean norm $\\|R^{(0)}\\|_2$.\n4.  If $\\|R^{(0)}\\|_2$ is non-zero, assemble the Jacobian matrix $J_0 = J(\\mathbf{u}^{(0)})$.\n5.  Solve the linear system $J_0 \\delta \\mathbf{u} = -R^{(0)}$ for the update vector $\\delta \\mathbf{u}$.\n6.  Compute the updated solution $\\mathbf{u}^{(1)} = \\mathbf{u}^{(0)} + \\delta \\mathbf{u}$.\n7.  Compute the new residual vector $R^{(1)} = R(\\mathbf{u}^{(1)})$ and its norm $\\|R^{(1)}\\|_2$.\n8.  Calculate the reduction factor $\\rho = \\|R^{(1)}\\|_2 / \\|R^{(0)}\\|_2$. If $\\|R^{(0)}\\|_2 = 0$, the reduction is considered perfect, so $\\rho=0$.\n\nThis procedure is implemented for each of the three test cases provided. For Test Case 3, where $\\sigma=0$, the system is linear in $\\mathbf{u}$, and a single Newton step converges to the exact solution, resulting in $R(\\mathbf{u}^{(1)}) \\approx \\mathbf{0}$ and $\\rho \\approx 0$ up to machine precision.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n\n    def calculate_residual(u_next, u_prev, N, dt, nu, sigma):\n        \"\"\"\n        Calculates the nonlinear residual vector for the discretized PDE.\n\n        Args:\n            u_next (np.ndarray): The unknown solution vector u^{n+1} at interior points.\n            u_prev (np.ndarray): The solution vector u^n at interior points from the previous time step.\n            N (int): Total number of grid points.\n            dt (float): Time step size.\n            nu (float): Viscosity coefficient.\n            sigma (float): Reaction coefficient.\n\n        Returns:\n            np.ndarray: The residual vector R.\n        \"\"\"\n        dx = 1.0 / (N - 1)\n        \n        # Pad with zeros for homogeneous Dirichlet boundary conditions\n        u_next_full = np.pad(u_next, (1, 1), 'constant')\n        u_prev_full = np.pad(u_prev, (1, 1), 'constant')\n\n        # Spatial derivatives for u^{n+1} (u_next)\n        du_dx_next = (u_next_full[2:] - u_next_full[:-2]) / (2.0 * dx)\n        d2u_dx2_next = (u_next_full[2:] - 2.0 * u_next_full[1:-1] + u_next_full[:-2]) / (dx**2)\n\n        # Spatial derivatives for u^n (u_prev)\n        du_dx_prev = (u_prev_full[2:] - u_prev_full[:-2]) / (2.0 * dx)\n        d2u_dx2_prev = (u_prev_full[2:] - 2.0 * u_prev_full[1:-1] + u_prev_full[:-2]) / (dx**2)\n        \n        # Lagged advective velocity v^n is u^n at interior points\n        v_prev = u_prev\n\n        # Assemble the residual vector R based on the Crank-Nicolson formula\n        temporal_term = (u_next - u_prev) / dt\n        advective_term = 0.5 * (v_prev * du_dx_next + v_prev * du_dx_prev)\n        diffusive_term = 0.5 * nu * (d2u_dx2_next + d2u_dx2_prev)\n        reaction_term = 0.5 * sigma * (u_next**3 + u_prev**3)\n        \n        R = temporal_term + advective_term - diffusive_term - reaction_term\n        return R\n\n    def assemble_jacobian(u_linearize, u_prev, N, dt, nu, sigma):\n        \"\"\"\n        Assembles the Jacobian matrix for the nonlinear residual.\n\n        Args:\n            u_linearize (np.ndarray): The solution vector u^{(0)} at which to linearize.\n            u_prev (np.ndarray): The solution vector u^n from the previous time step.\n            N (int): Total number of grid points.\n            dt (float): Time step size.\n            nu (float): Viscosity coefficient.\n            sigma (float): Reaction coefficient.\n\n        Returns:\n            np.ndarray: The Jacobian matrix J.\n        \"\"\"\n        dx = 1.0 / (N - 1)\n        M = N - 2  # Number of interior points\n        J = np.zeros((M, M))\n\n        # Main diagonal entries\n        diag_vals = 1.0 / dt + nu / dx**2 - 1.5 * sigma * u_linearize**2\n        np.fill_diagonal(J, diag_vals)\n        \n        if M > 1:\n            # Sub-diagonal entries\n            sub_diag_vals = -u_prev[1:] / (4.0 * dx) - nu / (2.0 * dx**2)\n            np.fill_diagonal(J[1:, :], sub_diag_vals)\n\n            # Super-diagonal entries\n            super_diag_vals = u_prev[:-1] / (4.0 * dx) - nu / (2.0 * dx**2)\n            np.fill_diagonal(J[:, 1:], super_diag_vals)\n            \n        return J\n\n    def run_newton_step(params):\n        \"\"\"\n        Performs a single Newton step and computes the residual reduction.\n        \"\"\"\n        N, dt, nu, sigma, u_n_func, u0_func = params\n        \n        # Setup grid and initial vectors\n        x = np.linspace(0.0, 1.0, N)\n        x_interior = x[1:-1]\n        \n        u_prev = u_n_func(x_interior)\n        u0_guess = u0_func(x_interior)\n\n        # Calculate initial residual R(u^(0)) and its norm\n        R0 = calculate_residual(u0_guess, u_prev, N, dt, nu, sigma)\n        norm_R0 = np.linalg.norm(R0)\n\n        # Handle case where initial guess is already the solution\n        if np.isclose(norm_R0, 0.0):\n            return 0.0\n        \n        # Assemble Jacobian J(u^(0))\n        J0 = assemble_jacobian(u0_guess, u_prev, N, dt, nu, sigma)\n        \n        # Solve for the update: J * du = -R\n        delta_u = np.linalg.solve(J0, -R0)\n        \n        # Update the solution: u^(1) = u^(0) + du\n        u1_next = u0_guess + delta_u\n        \n        # Calculate new residual R(u^(1)) and its norm\n        R1 = calculate_residual(u1_next, u_prev, N, dt, nu, sigma)\n        norm_R1 = np.linalg.norm(R1)\n        \n        # Compute the reduction factor\n        rho = norm_R1 / norm_R0\n        return rho\n\n    test_cases = [\n        # Case 1: (N, dt, nu, sigma, u^n(x), u^(0)(x))\n        (51, 0.005, 0.01, 1.0, lambda x: np.sin(np.pi * x), lambda x: np.sin(np.pi * x)),\n        # Case 2\n        (51, 0.05, 0.005, 5.0, lambda x: 0.5 * np.sin(2 * np.pi * x) + 0.25 * np.sin(np.pi * x), lambda x: np.zeros_like(x)),\n        # Case 3\n        (31, 0.01, 0.02, 0.0, lambda x: np.sin(np.pi * x), lambda x: np.zeros_like(x)),\n    ]\n\n    results = []\n    for case in test_cases:\n        rho = run_newton_step(case)\n        results.append(rho)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}