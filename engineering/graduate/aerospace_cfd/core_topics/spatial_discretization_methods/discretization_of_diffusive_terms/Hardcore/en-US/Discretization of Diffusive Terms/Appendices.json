{
    "hands_on_practices": [
        {
            "introduction": "Understanding the behavior of a numerical scheme is paramount before its application. This exercise guides you through the analysis of the Crank-Nicolson method, a cornerstone implicit scheme for parabolic equations like the heat equation . By deriving and examining the scheme's amplification factor via von Neumann analysis, you will gain deep insight into its second-order temporal accuracy and its characteristic damping properties across different wavelengths.",
            "id": "3955585",
            "problem": "Consider the one-dimensional heat equation for a passive scalar in aerospace Computational Fluid Dynamics (CFD), with constant molecular diffusivity:\nGiven a periodic domain and a uniform spatial grid with spacing $\\Delta x$, the governing equation is\n$$\\frac{\\partial \\phi}{\\partial t} = \\Gamma \\frac{\\partial^{2} \\phi}{\\partial x^{2}},$$\nwhere $\\Gamma$ is constant. Use a second-order central difference for the spatial discretization on the grid points $x_{i} = i \\,\\Delta x$ to obtain a semi-discrete system for $\\phi_{i}(t)$.\n\nStarting only from the definitions of the second-order central difference and the trapezoidal rule in time, perform the following steps:\n\n1) Derive the semi-discrete ordinary differential equation at each grid point $i$ in the form\n$$\\frac{d \\phi_{i}}{dt} = \\Gamma \\frac{\\phi_{i+1} - 2 \\phi_{i} + \\phi_{i-1}}{\\Delta x^{2}}.$$\n\n2) Apply the trapezoidal rule in time over one step from $t^{n}$ to $t^{n+1}=t^{n}+\\Delta t$ to obtain a fully discrete linear system for $\\phi^{n+1}$ in the form of a Crank–Nicolson method (Crank–Nicolson (CN) method), and rewrite it in matrix form using the discrete diffusion operator $L$.\n\n3) Using von Neumann normal mode analysis, assume a Fourier mode ansatz $\\phi_{i}^{n} = A^{n} \\exp(\\mathrm{i} i \\theta)$, where $\\theta \\in [0,\\pi]$ is the nondimensional wavenumber and $\\mathrm{i}=\\sqrt{-1}$. Define the nondimensional time step $r = \\Gamma \\Delta t / \\Delta x^{2}$. Derive the temporal amplification factor $G(\\theta,r)$ for the CN scheme.\n\n4) Show by a Taylor expansion argument on the exact modal solution that the CN method is second-order accurate in time for this diffusive problem, and identify the leading-order difference between the CN stability function and the exact modal exponential at small time step.\n\n5) Characterize the damping behavior of the CN method for diffusive modes by evaluating the limit of the amplification factor for the highest resolvable wavenumber $\\theta=\\pi$ as $r \\to \\infty$, and interpret this limit physically.\n\nProvide the closed-form expression you derive for the amplification factor $G(\\theta,r)$ as your final answer. No numerical rounding is required. The final answer must be a single analytic expression with no units.",
            "solution": "The user has provided a multi-part problem concerning the numerical analysis of the one-dimensional heat equation. I will first validate the problem statement according to the specified criteria and then proceed to a complete solution if it is deemed valid.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n*   Governing Equation: $\\frac{\\partial \\phi}{\\partial t} = \\Gamma \\frac{\\partial^{2} \\phi}{\\partial x^{2}}$\n*   Domain: Periodic.\n*   Grid: Uniform spatial grid with spacing $\\Delta x$ and points $x_{i} = i \\Delta x$.\n*   Diffusivity: $\\Gamma$ is a constant.\n*   Task 1: Derive the semi-discrete ODE $\\frac{d \\phi_{i}}{dt} = \\Gamma \\frac{\\phi_{i+1} - 2 \\phi_{i} + \\phi_{i-1}}{\\Delta x^{2}}$ using a second-order central difference.\n*   Task 2: Apply the trapezoidal rule in time to obtain the Crank-Nicolson (CN) scheme and its matrix form using a discrete diffusion operator $L$.\n*   Task 3: Assume a Fourier mode ansatz $\\phi_{i}^{n} = A^{n} \\exp(\\mathrm{i} i \\theta)$, with $\\theta \\in [0,\\pi]$ and $\\mathrm{i}=\\sqrt{-1}$. Define the nondimensional time step $r = \\Gamma \\Delta t / \\Delta x^{2}$. Derive the temporal amplification factor $G(\\theta,r)$.\n*   Task 4: Show the CN method is second-order accurate in time by a Taylor expansion argument comparing the numerical and exact modal solutions. Identify the leading-order difference.\n*   Task 5: Characterize the damping behavior for the highest resolvable wavenumber $\\theta=\\pi$ as $r \\to \\infty$.\n\n**Step 2: Validate Using Extracted Givens**\n\n*   **Scientifically Grounded:** The problem is based on the fundamental heat/diffusion equation and employs standard, well-established numerical methods (finite differences, Crank-Nicolson scheme, von Neumann stability analysis). These are core concepts in computational fluid dynamics (CFD) and numerical analysis. The problem is scientifically sound.\n*   **Well-Posed:** The problem is structured as a sequence of standard derivations. Each step is clearly defined and leads to a unique, meaningful result.\n*   **Objective:** The language is formal, precise, and free of any subjective or ambiguous terminology.\n\n**Step 3: Verdict and Action**\n\nThe problem is valid. It is a standard, well-posed problem in numerical methods for partial differential equations. I will now provide a complete, reasoned solution.\n\n### Solution\n\n**1) Derivation of the Semi-Discrete Ordinary Differential Equation**\n\nThe governing partial differential equation (PDE) is given by:\n$$\n\\frac{\\partial \\phi}{\\partial t} = \\Gamma \\frac{\\partial^{2} \\phi}{\\partial x^{2}}\n$$\nWe discretize the spatial domain using a uniform grid with spacing $\\Delta x$, such that $x_i = i \\Delta x$. Let $\\phi_i(t)$ be the approximation of $\\phi(x_i, t)$. The spatial second derivative $\\frac{\\partial^2 \\phi}{\\partial x^2}$ at grid point $x_i$ is approximated using a second-order accurate central difference formula:\n$$\n\\left. \\frac{\\partial^{2} \\phi}{\\partial x^{2}} \\right|_{x=x_i} \\approx \\frac{\\phi(x_{i+1}) - 2\\phi(x_i) + \\phi(x_{i-1})}{\\Delta x^2} = \\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{\\Delta x^2}\n$$\nSubstituting this approximation into the PDE, we replace the partial time derivative with an ordinary time derivative for the grid point value $\\phi_i(t)$, as the spatial dependence has been discretized. This process, known as the method of lines, yields a system of coupled ordinary differential equations (ODEs), one for each grid point $i$:\n$$\n\\frac{d \\phi_{i}}{dt} = \\Gamma \\frac{\\phi_{i+1} - 2 \\phi_{i} + \\phi_{i-1}}{\\Delta x^{2}}\n$$\nThis is the required semi-discrete form.\n\n**2) Derivation of the Crank-Nicolson Scheme**\n\nWe now discretize the semi-discrete ODE in time. The trapezoidal rule for an ODE of the form $\\frac{dy}{dt} = f(y)$ over a time step from $t^n$ to $t^{n+1} = t^n + \\Delta t$ is:\n$$\ny^{n+1} = y^n + \\frac{\\Delta t}{2} \\left[ f(y^n) + f(y^{n+1}) \\right]\n$$\nFor our system, $y_i$ corresponds to $\\phi_i$ and the function $f(\\phi)_i$ is the right-hand side of the semi-discrete equation:\n$$\nf(\\phi)_i = \\Gamma \\frac{\\phi_{i+1} - 2 \\phi_{i} + \\phi_{i-1}}{\\Delta x^{2}}\n$$\nApplying the trapezoidal rule gives:\n$$\n\\phi_i^{n+1} = \\phi_i^n + \\frac{\\Delta t}{2} \\left[ \\left(\\Gamma \\frac{\\phi_{i+1}^n - 2 \\phi_i^n + \\phi_{i-1}^n}{\\Delta x^2}\\right) + \\left(\\Gamma \\frac{\\phi_{i+1}^{n+1} - 2 \\phi_i^{n+1} + \\phi_{i-1}^{n+1}}{\\Delta x^2}\\right) \\right]\n$$\nWe group terms at time level $n+1$ on the left-hand side and terms at time level $n$ on the right-hand side:\n$$\n\\phi_i^{n+1} - \\frac{\\Gamma \\Delta t}{2 \\Delta x^2} (\\phi_{i+1}^{n+1} - 2 \\phi_i^{n+1} + \\phi_{i-1}^{n+1}) = \\phi_i^n + \\frac{\\Gamma \\Delta t}{2 \\Delta x^2} (\\phi_{i+1}^n - 2 \\phi_i^n + \\phi_{i-1}^n)\n$$\nThis is the fully discrete Crank-Nicolson scheme. To express it in matrix form, we define the discrete diffusion operator $L$ acting on the vector of grid values $\\vec{\\phi}$ such that $(L\\vec{\\phi})_i = \\frac{\\phi_{i+1} - 2 \\phi_{i} + \\phi_{i-1}}{\\Delta x^{2}}$. The semi-discrete system is $\\frac{d\\vec{\\phi}}{dt} = \\Gamma L \\vec{\\phi}$. The fully discrete system can then be written as:\n$$\n\\vec{\\phi}^{n+1} - \\frac{\\Gamma \\Delta t}{2} L \\vec{\\phi}^{n+1} = \\vec{\\phi}^n + \\frac{\\Gamma \\Delta t}{2} L \\vec{\\phi}^n\n$$\nFactoring out the vectors $\\vec{\\phi}^{n+1}$ and $\\vec{\\phi}^{n}$ gives the final matrix form, where $\\mathbf{I}$ is the identity matrix and $\\mathbf{L}$ is the matrix representation of the operator $L$:\n$$\n\\left(\\mathbf{I} - \\frac{\\Gamma \\Delta t}{2} \\mathbf{L}\\right) \\vec{\\phi}^{n+1} = \\left(\\mathbf{I} + \\frac{\\Gamma \\Delta t}{2} \\mathbf{L}\\right) \\vec{\\phi}^{n}\n$$\n\n**3) Derivation of the Temporal Amplification Factor**\n\nFor von Neumann stability analysis, we substitute the Fourier mode ansatz $\\phi_j^k = A^k \\exp(\\mathrm{i} j \\theta)$ into the scalar form of the Crank-Nicolson scheme. The amplification factor is defined as $G = G(\\theta,r) = A^{n+1}/A^n$, which implies $\\phi_j^{n+1} = G \\phi_j^n$.\n$$\nG \\phi_i^n - \\frac{r}{2} (G \\phi_{i+1}^n - 2 G \\phi_i^n + G \\phi_{i-1}^n) = \\phi_i^n + \\frac{r}{2} (\\phi_{i+1}^n - 2 \\phi_i^n + \\phi_{i-1}^n)\n$$\nwhere $r = \\frac{\\Gamma\\Delta t}{\\Delta x^2}$. We substitute $\\phi_j^n = A^n \\exp(\\mathrm{i}j\\theta)$ and divide the entire equation by $A^n \\exp(\\mathrm{i}i\\theta)$:\n$$\nG - \\frac{r}{2} G (\\exp(\\mathrm{i}\\theta) - 2 + \\exp(-\\mathrm{i}\\theta)) = 1 + \\frac{r}{2} (\\exp(\\mathrm{i}\\theta) - 2 + \\exp(-\\mathrm{i}\\theta))\n$$\nUsing the identity $2\\cos\\theta = \\exp(\\mathrm{i}\\theta) + \\exp(-\\mathrm{i}\\theta)$, the term in the parentheses becomes $2\\cos\\theta - 2$. Then using the half-angle identity $1-\\cos\\theta = 2\\sin^2(\\theta/2)$, this simplifies to $-4\\sin^2(\\theta/2)$.\nSubstituting this back into the equation:\n$$\nG - \\frac{r}{2} G (-4\\sin^2(\\theta/2)) = 1 + \\frac{r}{2} (-4\\sin^2(\\theta/2))\n$$\n$$\nG (1 + 2r\\sin^2(\\theta/2)) = 1 - 2r\\sin^2(\\theta/2)\n$$\nSolving for the amplification factor $G$ yields:\n$$\nG(\\theta,r) = \\frac{1 - 2r\\sin^2(\\theta/2)}{1 + 2r\\sin^2(\\theta/2)}\n$$\n\n**4) Accuracy Analysis**\n\nTo analyze the temporal accuracy, we compare the numerical amplification factor $G_{CN} = G(\\theta,r)$ with the exact amplification factor of the semi-discrete ODE system, $G_{semi-exact}$. The semi-discrete ODE has modal solutions of the form $\\phi_i(t) = \\hat{\\phi}(t) \\exp(\\mathrm{i}i\\theta)$. The associated eigenvalue $\\lambda(\\theta)$ of the operator $\\Gamma L$ is:\n$$\n\\lambda(\\theta) = \\Gamma \\frac{\\exp(\\mathrm{i}\\theta) - 2 + \\exp(-\\mathrm{i}\\theta)}{\\Delta x^2} = \\frac{\\Gamma}{\\Delta x^2}(2\\cos\\theta - 2) = -\\frac{4\\Gamma}{\\Delta x^2}\\sin^2(\\theta/2)\n$$\nThe exact solution to the semi-discrete ODE over one time step $\\Delta t$ is amplified by $G_{semi-exact} = \\exp(\\lambda(\\theta)\\Delta t) = \\exp\\left(-\\frac{4\\Gamma\\Delta t}{\\Delta x^2}\\sin^2(\\theta/2)\\right) = \\exp(-4r\\sin^2(\\theta/2))$. Let $z = -4r\\sin^2(\\theta/2)$.\nSo, $G_{semi-exact} = \\exp(z)$.\nThe numerical amplification factor can be written in terms of $z$ as $G_{CN} = \\frac{1+z/2}{1-z/2}$. This is the $(1,1)$-Padé approximant to $\\exp(z)$.\nWe perform a Taylor series expansion of both factors for small $z$ (which corresponds to small $\\Delta t$):\n$$\nG_{semi-exact} = \\exp(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24} + \\mathcal{O}(z^5)\n$$\n$$\nG_{CN} = \\frac{1+z/2}{1-z/2} = (1+z/2)\\left(1 + \\frac{z}{2} + \\frac{z^2}{4} + \\frac{z^3}{8} + \\mathcal{O}(z^4)\\right) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{4} + \\mathcal{O}(z^4)\n$$\nThe difference between the numerical and semi-exact amplification factors is:\n$$\nG_{CN} - G_{semi-exact} = \\left(\\frac{1}{4} - \\frac{1}{6}\\right)z^3 + \\mathcal{O}(z^4) = \\frac{1}{12}z^3 + \\mathcal{O}(z^4)\n$$\nThe local error incurred in one step is proportional to $z^3$. Since $z$ is proportional to $\\Delta t$, the local error is $\\mathcal{O}(\\Delta t^3)$. The local truncation error (LTE) is the error per unit time, LTE = Error/$\\Delta t \\propto \\Delta t^2$. For a stable one-step method, an LTE of $\\mathcal{O}(\\Delta t^2)$ implies a global error of $\\mathcal{O}(\\Delta t^2)$, establishing that the Crank-Nicolson method is second-order accurate in time for this problem.\nThe leading-order difference is $\\frac{1}{12}z^3 = \\frac{1}{12}(-4r\\sin^2(\\theta/2))^3 = -\\frac{64}{12}r^3\\sin^6(\\theta/2) = -\\frac{16}{3}r^3\\sin^6(\\theta/2)$.\n\n**5) Damping Behavior for High Wavenumbers**\n\nWe analyze the behavior of the amplification factor for the highest resolvable wavenumber on the grid. This mode corresponds to a wavelength of $2\\Delta x$, which has a sawtooth pattern of alternating signs. For this mode, $\\phi_{i+1} = -\\phi_i$, which implies $\\exp(\\mathrm{i}\\theta)=-1$, so the nondimensional wavenumber is $\\theta=\\pi$.\nWe evaluate the amplification factor $G(\\theta,r)$ at $\\theta=\\pi$:\n$$\nG(\\pi,r) = \\frac{1 - 2r\\sin^2(\\pi/2)}{1 + 2r\\sin^2(\\pi/2)} = \\frac{1 - 2r(1)^2}{1 + 2r(1)^2} = \\frac{1 - 2r}{1 + 2r}\n$$\nNow, we take the limit as the nondimensional time step $r \\to \\infty$. This corresponds to a large time step $\\Delta t$, large diffusivity $\\Gamma$, or small grid spacing $\\Delta x$:\n$$\n\\lim_{r\\to\\infty} G(\\pi, r) = \\lim_{r\\to\\infty} \\frac{1 - 2r}{1 + 2r} = \\lim_{r\\to\\infty} \\frac{1/r - 2}{1/r + 2} = \\frac{0 - 2}{0 + 2} = -1\n$$\n**Physical Interpretation:** The limit of the amplification factor is $-1$. An amplification factor $G$ with magnitude $|G|<1$ indicates damping, $|G|=1$ indicates neutral stability (no damping), and $|G|>1$ indicates instability. In this case, $|G(\\pi, r \\to \\infty)| = |-1| = 1$. This means that for very large time steps, the highest frequency mode is not damped at all. Instead, its amplitude is preserved, and its sign is flipped at every time step. This leads to persistent, non-physical oscillations in the numerical solution. While the Crank-Nicolson scheme is unconditionally stable for the diffusion equation (since $|G(\\theta,r)| \\le 1$ for all $\\theta, r$), its lack of appropriate damping for high-wavenumber modes at large $r$ is a significant drawback. This numerical artifact can contaminate the solution with high-frequency noise.",
            "answer": "$$\n\\boxed{\\frac{1 - 2r\\sin^2(\\frac{\\theta}{2})}{1 + 2r\\sin^2(\\frac{\\theta}{2})}}\n$$"
        },
        {
            "introduction": "A numerical simulation is only as accurate as its boundary conditions. This practice moves from the domain interior to the crucial task of implementing a specified flux, or Neumann, boundary condition within a Finite Volume Method (FVM) framework . You will use the ghost-cell extrapolation technique, a standard approach in CFD, to construct a discrete representation of the boundary flux that is consistent with the governing physical law.",
            "id": "3955645",
            "problem": "A scalar transport with isotropic diffusion coefficient $\\Gamma$ is discretized by the Finite Volume Method (FVM) in a Computational Fluid Dynamics (CFD) code on a mesh of convex control volumes. Consider a boundary control volume whose centroid $P$ lies at signed normal distance $d_{P}>0$ from a planar boundary face $\\partial \\Omega_{b}$ with outward unit normal $\\boldsymbol{n}_{b}$ and area magnitude $A_{b}$. A Neumann boundary condition is prescribed as $\\partial \\phi / \\partial n \\big|_{\\partial \\Omega_{b}} = g$, where $\\partial \\phi / \\partial n \\equiv \\boldsymbol{n}_{b} \\cdot \\nabla \\phi$ and $g$ is a given constant in a neighborhood of $\\partial \\Omega_{b}$. Assume that the boundary face is locally orthogonal to the line segment joining the interior centroid $P$ and a ghost point $G$ located outside the domain along $\\boldsymbol{n}_{b}$ at signed normal distance $d_{G}>0$ from $\\partial \\Omega_{b}$. The isotropic diffusion coefficient $\\Gamma$ is constant in this neighborhood, and linear variation of $\\phi$ along the line segment $PG$ is assumed.\n\nThe diffusive flux through the boundary face is defined by Fick’s law and the divergence theorem as $\\boldsymbol{q}_{b} \\cdot \\boldsymbol{n}_{b} = -\\Gamma \\, \\partial \\phi / \\partial n \\big|_{\\partial \\Omega_{b}}$. In the discrete FVM, the face-normal gradient at $\\partial \\Omega_{b}$ is approximated by the two-point difference along $PG$:\n$$\n\\left.\\frac{\\partial \\phi}{\\partial n}\\right|_{\\partial \\Omega_{b}} \\approx \\frac{\\phi_{G} - \\phi_{P}}{d_{P} + d_{G}}.\n$$\nYou are asked to construct a Neumann boundary implementation by extrapolating $\\phi$ to the ghost point $G$ and to verify that the resulting discrete boundary flux is exactly consistent with the prescribed Neumann data when evaluated with the same two-point discrete face gradient.\n\nStarting only from the definitions above and the assumption of linear variation of $\\phi$ along $PG$, derive the ghost value $\\phi_{G}$ in terms of $\\phi_{P}$, $d_{P}$, $d_{G}$, and $g$ such that the discrete face-normal gradient equals $g$ and the discrete diffusive flux through the boundary face equals $-\\Gamma A_{b} g$. Your final answer must be a single closed-form expression for $\\phi_{G}$. No numerical evaluation is required.",
            "solution": "The problem statement has been validated and is determined to be a well-posed, scientifically grounded problem in the field of Computational Fluid Dynamics (CFD). The objective is to derive an expression for the value of a scalar field $\\phi$ at a ghost point, $\\phi_G$, to implement a Neumann boundary condition within a Finite Volume Method (FVM) framework.\n\nThe provided Neumann boundary condition is a prescribed value for the normal derivative of the scalar field $\\phi$ at a boundary face $\\partial\\Omega_b$:\n$$\n\\left.\\frac{\\partial \\phi}{\\partial n}\\right|_{\\partial \\Omega_{b}} = g\n$$\nwhere $g$ is a constant, and $\\frac{\\partial \\phi}{\\partial n}$ is the derivative in the direction of the outward unit normal $\\boldsymbol{n}_b$ to the face.\n\nIn the FVM discretization, physical laws are translated into algebraic equations. The implementation of this boundary condition requires expressing the specified derivative $g$ in terms of the discrete nodal values of $\\phi$. The problem provides a specific discrete approximation for the face-normal gradient, based on a two-point stencil involving the interior cell-centroid value $\\phi_P$ and a ghost-point value $\\phi_G$:\n$$\n\\left.\\frac{\\partial \\phi}{\\partial n}\\right|_{\\partial \\Omega_{b}, \\text{discrete}} = \\frac{\\phi_{G} - \\phi_{P}}{d_{P} + d_{G}}\n$$\nHere, $d_P$ and $d_G$ are the respective normal distances of the interior centroid $P$ and the ghost point $G$ from the boundary face.\n\nTo enforce the Neumann boundary condition in the discrete system, we must equate the discrete approximation of the gradient to the prescribed value $g$. This is the core of the implementation.\n$$\n\\frac{\\phi_{G} - \\phi_{P}}{d_{P} + d_{G}} = g\n$$\nThis equation provides a direct relationship for the ghost-point value $\\phi_G$. The task is to solve this equation for $\\phi_G$ in terms of the known quantities $\\phi_P$, $d_P$, $d_G$, and $g$.\n\nRearranging the equation to isolate $\\phi_G$:\n$$\n\\phi_{G} - \\phi_{P} = g (d_{P} + d_{G})\n$$\n$$\n\\phi_{G} = \\phi_{P} + g (d_{P} + d_{G})\n$$\nThis expression defines the value of the scalar field at the ghost point $G$ that correctly imposes the Neumann condition using the specified two-point gradient approximation. This is the required construction for the Neumann boundary implementation.\n\nThe problem also asks to verify that this construction leads to a discrete boundary flux that is consistent with the prescribed Neumann data. The continuous diffusive flux density normal to the boundary is given by Fick's law as $\\boldsymbol{q}_{b} \\cdot \\boldsymbol{n}_{b} = -\\Gamma \\frac{\\partial \\phi}{\\partial n}|_{\\partial \\Omega_{b}}$. Given the boundary condition, this becomes $-\\Gamma g$. The total flux through the face of area $A_b$ is therefore $-\\Gamma g A_b$.\n\nThe discrete total diffusive flux through the boundary face, $F_b$, is computed by multiplying the face area $A_b$ by the discrete approximation of the flux density. The discrete flux density is $-\\Gamma$ times the discrete normal gradient:\n$$\nF_b = A_b \\left( -\\Gamma \\left.\\frac{\\partial \\phi}{\\partial n}\\right|_{\\partial \\Omega_{b}, \\text{discrete}} \\right)\n$$\nSubstituting the provided two-point approximation for the gradient:\n$$\nF_b = - A_b \\Gamma \\left( \\frac{\\phi_{G} - \\phi_{P}}{d_{P} + d_{G}} \\right)\n$$\nBy our very construction of $\\phi_G$, we have enforced that the term in the parenthesis is equal to $g$. That is, $\\frac{\\phi_{G} - \\phi_{P}}{d_{P} + d_{G}} = g$. Substituting this directly into the expression for the discrete flux $F_b$ yields:\n$$\nF_b = - A_b \\Gamma g\n$$\nThis result demonstrates that the discrete flux calculated using the derived ghost-point value $\\phi_G$ is exactly equal to the target flux $-\\Gamma A_b g$ derived from the continuous physical laws and boundary conditions. The consistency is therefore verified.\n\nFurthermore, this result is consistent with the stated assumption of linear variation of $\\phi$ along the normal line connecting $P$ and $G$. If $\\phi$ varies linearly with the normal coordinate $s$ (where $s=0$ at the face), we can write $\\phi(s) = \\phi_b + s \\left(\\frac{d\\phi}{ds}\\right)$, where $\\phi_b$ is the value at the boundary face. With $\\frac{d\\phi}{ds}|_{s=0} = g$, this becomes $\\phi(s) = \\phi_b + sg$. The interior point $P$ is at $s = -d_P$, so $\\phi_P = \\phi_b - g d_P$. The ghost point $G$ is at $s = d_G$, so $\\phi_G = \\phi_b + g d_G$. From the first relation, we find $\\phi_b = \\phi_P + g d_P$. Substituting this into the second relation gives $\\phi_G = (\\phi_P + g d_P) + g d_G = \\phi_P + g(d_P + d_G)$, which is the same expression derived above. This confirms the internal consistency of all assumptions and definitions in the problem statement.\n\nThe final answer is the derived closed-form expression for $\\phi_G$.",
            "answer": "$$\\boxed{\\phi_P + g (d_P + d_G)}$$"
        },
        {
            "introduction": "After deriving and implementing a numerical scheme, how can we be sure it is correct? This capstone practice introduces the Method of Manufactured Solutions (MMS), a powerful and rigorous technique for code verification in computational physics . You will start with a predefined analytical solution $\\phi(x,y)$ and an anisotropic conductivity tensor $\\mathbf{K}$, from which you will derive the exact diffusive flux $\\mathbf{f} = -\\mathbf{K}\\nabla\\phi$ and its divergence, $\\nabla \\cdot \\mathbf{f}$. This setup allows you to precisely test the discrete conservation law by comparing a numerical approximation of the surface flux integral with a high-accuracy evaluation of the volume integral of $\\nabla \\cdot \\mathbf{f}$.",
            "id": "3955599",
            "problem": "Consider the steady two-dimensional diffusion of a scalar field subject to anisotropic conductivity. Begin from the local conservation statement for a control volume: the net outward diffusive flux across the control-volume boundary equals the volume integral of the divergence of the diffusive flux. Let the diffusive flux be defined by $ \\mathbf{f} = - \\mathbf{K} \\nabla \\phi $, where $ \\phi(x,y) $ is a smooth manufactured solution and $ \\mathbf{K}(x,y) $ is a symmetric positive-definite conductivity tensor. By the divergence theorem, for any rectangle $ V $, the equality $ \\int_{\\partial V} \\mathbf{f} \\cdot \\mathbf{n} \\, dS = \\int_V \\nabla \\cdot \\mathbf{f} \\, dA $ holds. This statement is the only starting point you may assume. You must carefully derive all expressions you need from this fundamental base and the definition of the diffusive flux.\n\nYour task is to write a program that quantifies the discrete conservation error when the surface integral on each control volume is approximated by a second-order midpoint rule on the faces, while the right-hand side is evaluated to high accuracy via Gaussian quadrature. Specifically:\n\n- Domain and grid:\n    - Use the unit square domain $ [0,1] \\times [0,1] $.\n    - Use a uniform $ N \\times N $ grid of control volumes with spacing $ \\Delta x = 1/N $ and $ \\Delta y = 1/N $. Each control volume is the rectangle $ [i \\Delta x,(i+1)\\Delta x] \\times [j \\Delta y,(j+1)\\Delta y] $ for integers $ i,j $ with $ 0 \\le i,j \\le N-1 $.\n- Manufactured solution:\n    - Define $ \\phi(x,y) = \\sin(2\\pi x)\\cos(\\pi y) + \\tfrac{1}{2} x^2 y $.\n    - From this $ \\phi(x,y) $, derive the gradient $ \\nabla \\phi $, including $ \\partial \\phi / \\partial x $ and $ \\partial \\phi / \\partial y $, and the second derivatives $ \\partial^2 \\phi / \\partial x^2 $, $ \\partial^2 \\phi / \\partial x \\partial y $, and $ \\partial^2 \\phi / \\partial y^2 $ analytically.\n- Anisotropic tensor cases:\n    - Case A (constant diagonal): $ \\mathbf{K} = \\begin{bmatrix} 2 & 0 \\\\ 0 & 1 \\end{bmatrix} $.\n    - Case B (constant off-diagonal): $ \\mathbf{K} = \\begin{bmatrix} 3 & 1 \\\\ 1 & 2 \\end{bmatrix} $.\n    - Case C (spatially varying, symmetric positive-definite): $ \\mathbf{K}(x,y) = \\begin{bmatrix} 1 + 0.3 x & 0.2 + 0.1 y \\\\ 0.2 + 0.1 y & 2 + 0.5 x y \\end{bmatrix} $. Derive and use the required partial derivatives of $ \\mathbf{K}(x,y) $ with respect to $ x $ and $ y $.\n- Fluxes and divergence:\n    - Define $ \\mathbf{f}(x,y) = -\\mathbf{K}(x,y) \\nabla \\phi(x,y) $, and derive $ \\nabla \\cdot \\mathbf{f}(x,y) $ from the product rule, in terms of the derivatives of $ \\phi $ and $ \\mathbf{K} $. You must not use any prederived shortcut formulas for this; derive $ \\nabla \\cdot \\mathbf{f} = \\partial f_x/\\partial x + \\partial f_y/\\partial y $ from first principles and the chain rule.\n- Discrete surface integral per control volume:\n    - For each control volume, approximate the boundary integral $ \\int_{\\partial V} \\mathbf{f} \\cdot \\mathbf{n} \\, dS $ by summing the four face contributions, each approximated by the midpoint rule: evaluate $ \\mathbf{f} \\cdot \\mathbf{n} $ at the face center and multiply by the face length. Use the outward unit normal $ \\mathbf{n} $ for the control volume for each face.\n- High-accuracy volume integral:\n    - For each control volume, evaluate $ \\int_V \\nabla \\cdot \\mathbf{f} \\, dA $ using tensor-product Gaussian quadrature with $ 5 $-point Gauss–Legendre nodes and weights in each direction mapped to the control volume. The resulting quadrature is $ 25 $-point over the rectangle. This will serve as a reference that is effectively exact at the accuracy level needed to expose the face-midpoint discretization error.\n- Error per control volume:\n    - For each control volume, define the discrete conservation error as\n      $ E_{ij} = \\left(\\sum_{\\text{faces}} \\left.\\mathbf{f}\\cdot\\mathbf{n}\\right|_{\\text{face center}} \\, \\ell_{\\text{face}}\\right) - \\int_{V_{ij}} \\nabla \\cdot \\mathbf{f} \\, dA $,\n      where $ \\ell_{\\text{face}} $ is the face length.\n- Outputs:\n    - For each test case, reduce the set $ \\{E_{ij}\\} $ over all control volumes to the infinity norm $ \\|E\\|_{\\infty} = \\max_{i,j} |E_{ij}| $.\n    - No physical units are involved; all quantities are dimensionless.\n    - The final program must produce one line containing a Python list of floating-point numbers $ \\left[ r_1, r_2, \\dots \\right] $, where each $ r_k $ is the infinity norm for the corresponding test case below.\n\nTest Suite:\n- Test $ 1 $: Case A with $ N = 4 $.\n- Test $ 2 $: Case B with $ N = 4 $.\n- Test $ 3 $: Case C with $ N = 8 $.\n- Test $ 4 $: Case C with $ N = 16 $.\n- Test $ 5 $: Case C with $ N = 1 $.\n\nAll computations must be implemented in your code from the above principles. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $ [r_1,r_2,r_3,r_4,r_5] $). The entries $ r_k $ must be standard decimal string representations of Python floating-point values.",
            "solution": "The problem requires the calculation of the discrete conservation error for a two-dimensional steady-state diffusion problem on a uniform grid. The error is defined as the difference between a second-order approximation of the net diffusive flux across a control volume's boundary and a high-accuracy evaluation of the divergence of the flux integrated over the control volume. We begin by adhering to the problem's strict requirement of deriving all necessary expressions from the fundamental local conservation statement provided by the divergence theorem.\n\nThe starting point is the integral form of the conservation law for a control volume $V$:\n$$ \\int_{\\partial V} \\mathbf{f} \\cdot \\mathbf{n} \\, dS = \\int_V \\nabla \\cdot \\mathbf{f} \\, dA $$\nwhere $\\mathbf{f}$ is the diffusive flux vector, $\\mathbf{n}$ is the outward unit normal to the boundary $\\partial V$, $dS$ is the infinitesimal arc length along the boundary, and $dA$ is the infinitesimal area element within the volume.\n\nThe diffusive flux $\\mathbf{f}(x,y)$ is given by a form of Fick's or Fourier's law with an anisotropic conductivity tensor $\\mathbf{K}(x,y)$:\n$$ \\mathbf{f} = - \\mathbf{K} \\nabla \\phi $$\nHere, $\\phi(x,y)$ is the scalar field, $\\nabla \\phi$ is its gradient, and $\\mathbf{K}$ is a $2 \\times 2$ symmetric positive-definite matrix. In component form:\n$$ \\mathbf{f} = \\begin{pmatrix} f_x \\\\ f_y \\end{pmatrix} = - \\begin{pmatrix} K_{xx} & K_{xy} \\\\ K_{yx} & K_{yy} \\end{pmatrix} \\begin{pmatrix} \\partial \\phi / \\partial x \\\\ \\partial \\phi / \\partial y \\end{pmatrix} = - \\begin{pmatrix} K_{xx} \\frac{\\partial \\phi}{\\partial x} + K_{xy} \\frac{\\partial \\phi}{\\partial y} \\\\ K_{yx} \\frac{\\partial \\phi}{\\partial x} + K_{yy} \\frac{\\partial \\phi}{\\partial y} \\end{pmatrix} $$\n\nThe right-hand side of the conservation law involves the divergence of the flux, $\\nabla \\cdot \\mathbf{f}$. We derive this by applying the product rule for differentiation, as required.\n$$ \\nabla \\cdot \\mathbf{f} = \\frac{\\partial f_x}{\\partial x} + \\frac{\\partial f_y}{\\partial y} $$\nThe partial derivatives of the flux components are:\n$$ \\frac{\\partial f_x}{\\partial x} = -\\frac{\\partial}{\\partial x} \\left( K_{xx} \\frac{\\partial \\phi}{\\partial x} + K_{xy} \\frac{\\partial \\phi}{\\partial y} \\right) = -\\left( \\frac{\\partial K_{xx}}{\\partial x}\\frac{\\partial \\phi}{\\partial x} + K_{xx}\\frac{\\partial^2 \\phi}{\\partial x^2} + \\frac{\\partial K_{xy}}{\\partial x}\\frac{\\partial \\phi}{\\partial y} + K_{xy}\\frac{\\partial^2 \\phi}{\\partial x \\partial y} \\right) $$\n$$ \\frac{\\partial f_y}{\\partial y} = -\\frac{\\partial}{\\partial y} \\left( K_{yx} \\frac{\\partial \\phi}{\\partial x} + K_{yy} \\frac{\\partial \\phi}{\\partial y} \\right) = -\\left( \\frac{\\partial K_{yx}}{\\partial y}\\frac{\\partial \\phi}{\\partial x} + K_{yx}\\frac{\\partial^2 \\phi}{\\partial y \\partial x} + \\frac{\\partial K_{yy}}{\\partial y}\\frac{\\partial \\phi}{\\partial y} + K_{yy}\\frac{\\partial^2 \\phi}{\\partial y^2} \\right) $$\nSumming these two expressions yields the complete formula for the divergence of the flux, which will be used to evaluate the volume integral.\n\nThe problem specifies a manufactured solution for the scalar field $\\phi(x,y)$ on the unit square domain $[0,1] \\times [0,1]$:\n$$ \\phi(x,y) = \\sin(2\\pi x)\\cos(\\pi y) + \\tfrac{1}{2} x^2 y $$\nFrom this, we derive the necessary first and second partial derivatives:\n- $\\frac{\\partial \\phi}{\\partial x} = 2\\pi\\cos(2\\pi x)\\cos(\\pi y) + xy$\n- $\\frac{\\partial \\phi}{\\partial y} = -\\pi\\sin(2\\pi x)\\sin(\\pi y) + \\tfrac{1}{2} x^2$\n- $\\frac{\\partial^2 \\phi}{\\partial x^2} = -4\\pi^2\\sin(2\\pi x)\\cos(\\pi y) + y$\n- $\\frac{\\partial^2 \\phi}{\\partial y^2} = -\\pi^2\\sin(2\\pi x)\\cos(\\pi y)$\n- $\\frac{\\partial^2 \\phi}{\\partial x \\partial y} = -2\\pi^2\\cos(2\\pi x)\\sin(\\pi y) + x$\n\nThe domain is discretized into an $N \\times N$ grid of control volumes. Each control volume $V_{ij}$ for $i,j \\in \\{0, \\dots, N-1\\}$ is a rectangle defined by $[i\\Delta x, (i+1)\\Delta x] \\times [j\\Delta y, (j+1)\\Delta y]$, where $\\Delta x = \\Delta y = 1/N$.\n\nThe discrete conservation error for cell $V_{ij}$ is defined as $E_{ij} = (\\text{LHS}_{\\text{approx}}) - (\\text{RHS}_{\\text{exact}})$.\n\n**1. Approximation of the Left-Hand Side (Surface Integral):**\nThe surface integral $\\int_{\\partial V_{ij}} \\mathbf{f} \\cdot \\mathbf{n} \\, dS$ is the sum of integrals over the four faces of the rectangular control volume (east, west, north, south). Each face integral is approximated using the midpoint rule.\nLet the face centers be:\n- East face: $(x_e, y_e) = ((i+1)\\Delta x, (j+1/2)\\Delta y)$, normal $\\mathbf{n}_e=(1,0)$\n- West face: $(x_w, y_w) = (i\\Delta x, (j+1/2)\\Delta y)$, normal $\\mathbf{n}_w=(-1,0)$\n- North face: $(x_n, y_n) = ((i+1/2)\\Delta x, (j+1)\\Delta y)$, normal $\\mathbf{n}_n=(0,1)$\n- South face: $(x_s, y_s) = ((i+1/2)\\Delta x, j\\Delta y)$, normal $\\mathbf{n}_s=(0,-1)$\nThe face lengths are $\\ell_x = \\Delta x$ and $\\ell_y = \\Delta y$. The approximated surface integral is:\n$$ \\left(\\int_{\\partial V_{ij}} \\mathbf{f} \\cdot \\mathbf{n} \\, dS\\right)_{\\text{approx}} = (\\mathbf{f}(x_e,y_e)\\cdot\\mathbf{n}_e)\\ell_y + (\\mathbf{f}(x_w,y_w)\\cdot\\mathbf{n}_w)\\ell_y + (\\mathbf{f}(x_n,y_n)\\cdot\\mathbf{n}_n)\\ell_x + (\\mathbf{f}(x_s,y_s)\\cdot\\mathbf{n}_s)\\ell_x $$\n$$ = (f_x(x_e,y_e))\\Delta y + (-f_x(x_w,y_w))\\Delta y + (f_y(x_n,y_n))\\Delta x + (-f_y(x_s,y_s))\\Delta x $$\n$$ = (f_x(x_e, y_e) - f_x(x_w, y_w))\\Delta y + (f_y(x_n, y_n) - f_y(x_s, y_s))\\Delta x $$\n\n**2. Evaluation of the Right-Hand Side (Volume Integral):**\nThe volume integral $\\int_{V_{ij}} \\nabla \\cdot \\mathbf{f} \\, dA$ is evaluated using a high-accuracy $5 \\times 5$ tensor-product Gauss-Legendre quadrature. We map the integration domain $V_{ij} = [x_i, x_{i+1}] \\times [y_j, y_{j+1}]$ to the canonical square $[-1,1] \\times [-1,1]$ using the transformations:\n$$ x(\\xi) = \\frac{x_{i+1}-x_i}{2}\\xi + \\frac{x_{i+1}+x_i}{2} = \\frac{\\Delta x}{2}\\xi + (i+1/2)\\Delta x $$\n$$ y(\\eta) = \\frac{y_{j+1}-y_j}{2}\\eta + \\frac{y_{j+1}+y_j}{2} = \\frac{\\Delta y}{2}\\eta + (j+1/2)\\Delta y $$\nThe differential area element transforms as $dA = dx\\,dy = \\left(\\frac{\\Delta x}{2}\\right)\\left(\\frac{\\Delta y}{2}\\right) d\\xi\\,d\\eta$. The integral becomes:\n$$ \\int_{V_{ij}} \\nabla \\cdot \\mathbf{f} \\, dA = \\frac{\\Delta x \\Delta y}{4} \\int_{-1}^1 \\int_{-1}^1 (\\nabla \\cdot \\mathbf{f})(x(\\xi), y(\\eta)) \\,d\\xi d\\eta $$\nThis is approximated using the $5$-point Gauss-Legendre nodes $\\xi_p$ and weights $w_p$:\n$$ \\left(\\int_{V_{ij}} \\nabla \\cdot \\mathbf{f} \\, dA\\right)_{\\text{exact}} \\approx \\frac{\\Delta x \\Delta y}{4} \\sum_{p=1}^5 \\sum_{q=1}^5 w_p w_q (\\nabla \\cdot \\mathbf{f})(x(\\xi_p), y(\\eta_q)) $$\nThis quadrature is sufficiently accurate to serve as the \"exact\" reference for quantifying the error of the midpoint-rule surface integral.\n\nFinally, for each test case, we compute the error $E_{ij}$ for all control volumes and find the maximum absolute value, which is the infinity norm:\n$$ \\|E\\|_{\\infty} = \\max_{i,j} |E_{ij}| $$\nThis procedure is implemented for each of the three conductivity tensor cases and specified grid sizes. For Case C, where $\\mathbf{K}$ is spatially varying, the derivatives of its components must be computed and used in the expression for $\\nabla \\cdot \\mathbf{f}$.\n- For $\\mathbf{K}(x,y) = \\begin{bmatrix} 1 + 0.3 x & 0.2 + 0.1 y \\\\ 0.2 + 0.1 y & 2 + 0.5 x y \\end{bmatrix}$:\n- $\\frac{\\partial K_{xx}}{\\partial x} = 0.3$\n- $\\frac{\\partial K_{xy}}{\\partial y} = \\frac{\\partial K_{yx}}{\\partial y} = 0.1$\n- $\\frac{\\partial K_{yy}}{\\partial y} = 0.5x$\n- All other first partial derivatives of the components of $\\mathbf{K}$ are zero.\nThese are substituted into the full expression for $\\nabla \\cdot \\mathbf{f}$ for calculations involving Case C.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to compute discrete conservation error for specified test cases.\n    \"\"\"\n\n    test_cases = [\n        {'case_id': 'A', 'N': 4},\n        {'case_id': 'B', 'N': 4},\n        {'case_id': 'C', 'N': 8},\n        {'case_id': 'C', 'N': 16},\n        {'case_id': 'C', 'N': 1},\n    ]\n\n    # 5-point Gauss-Legendre quadrature nodes and weights for the interval [-1, 1]\n    # Hardcoded to avoid dependencies outside numpy.\n    gauss_nodes = np.array([\n        -0.9061798459386640,\n        -0.5384693101056831,\n        0.0,\n        0.5384693101056831,\n        0.9061798459386640\n    ])\n    gauss_weights = np.array([\n        0.2369268850561891,\n        0.4786286704993665,\n        0.5688888888888889,\n        0.4786286704993665,\n        0.2369268850561891\n    ])\n\n    # --- Analytical Functions for phi and its derivatives ---\n    def phi(x, y):\n        return np.sin(2 * np.pi * x) * np.cos(np.pi * y) + 0.5 * x**2 * y\n\n    def dphi_dx(x, y):\n        return 2 * np.pi * np.cos(2 * np.pi * x) * np.cos(np.pi * y) + x * y\n\n    def dphi_dy(x, y):\n        return -np.pi * np.sin(2 * np.pi * x) * np.sin(np.pi * y) + 0.5 * x**2\n\n    def d2phi_dx2(x, y):\n        return -4 * np.pi**2 * np.sin(2 * np.pi * x) * np.cos(np.pi * y) + y\n\n    def d2phi_dy2(x, y):\n        return -np.pi**2 * np.sin(2 * np.pi * x) * np.cos(np.pi * y)\n\n    def d2phi_dxdy(x, y):\n        return -2 * np.pi**2 * np.cos(2 * np.pi * x) * np.sin(np.pi * y) + x\n\n    # --- Functions for Conductivity Tensor K and its derivatives ---\n    def get_k_functions(case_id):\n        if case_id == 'A':\n            K = lambda x, y: np.array([[2.0, 0.0], [0.0, 1.0]])\n            dK_dx = lambda x, y: np.zeros((2, 2))\n            dK_dy = lambda x, y: np.zeros((2, 2))\n        elif case_id == 'B':\n            K = lambda x, y: np.array([[3.0, 1.0], [1.0, 2.0]])\n            dK_dx = lambda x, y: np.zeros((2, 2))\n            dK_dy = lambda x, y: np.zeros((2, 2))\n        elif case_id == 'C':\n            K = lambda x, y: np.array([[1 + 0.3 * x, 0.2 + 0.1 * y],\n                                       [0.2 + 0.1 * y, 2 + 0.5 * x * y]])\n            dK_dx = lambda x, y: np.array([[0.3, 0.0], [0.0, 0.5 * y]])\n            dK_dy = lambda x, y: np.array([[0.0, 0.1], [0.1, 0.5 * x]])\n        else:\n            raise ValueError(\"Unknown case_id\")\n        return K, dK_dx, dK_dy\n\n    # --- Flux and Divergence Functions ---\n    def flux(x, y, K_func):\n        grad_phi = np.array([dphi_dx(x, y), dphi_dy(x, y)])\n        k_val = K_func(x, y)\n        f = -np.dot(k_val, grad_phi)\n        return f[0], f[1]\n\n    def div_flux(x, y, K_func, dK_dx_func, dK_dy_func):\n        k_val = K_func(x, y)\n        dk_dx_val = dK_dx_func(x, y)\n        dk_dy_val = dK_dy_func(x, y)\n\n        dfx_dx = -(dk_dx_val[0, 0] * dphi_dx(x, y) + k_val[0, 0] * d2phi_dx2(x, y) +\n                   dk_dx_val[0, 1] * dphi_dy(x, y) + k_val[0, 1] * d2phi_dxdy(x, y))\n\n        dfy_dy = -(dk_dy_val[1, 0] * dphi_dx(x, y) + k_val[1, 0] * d2phi_dxdy(x, y) +\n                   dk_dy_val[1, 1] * dphi_dy(x, y) + k_val[1, 1] * d2phi_dy2(x, y))\n        \n        return dfx_dx + dfy_dy\n\n    results = []\n    for test in test_cases:\n        N = test['N']\n        case_id = test['case_id']\n        \n        K_func, dK_dx_func, dK_dy_func = get_k_functions(case_id)\n        \n        dx = 1.0 / N\n        dy = 1.0 / N\n        \n        max_error = 0.0\n\n        for i in range(N):\n            for j in range(N):\n                # 1. Surface Integral Approximation (Midpoint Rule)\n                # Face centers\n                x_w, y_w = i * dx, (j + 0.5) * dy\n                x_e, y_e = (i + 1) * dx, (j + 0.5) * dy\n                x_s, y_s = (i + 0.5) * dx, j * dy\n                x_n, y_n = (i + 0.5) * dx, (j + 1) * dy\n\n                # Fluxes at face centers\n                f_x_w, _ = flux(x_w, y_w, K_func)\n                f_x_e, _ = flux(x_e, y_e, K_func)\n                _, f_y_s = flux(x_s, y_s, K_func)\n                _, f_y_n = flux(x_n, y_n, K_func)\n\n                surf_integral = (f_x_e - f_x_w) * dy + (f_y_n - f_y_s) * dx\n                \n                # 2. Volume Integral (High-Accuracy Gaussian Quadrature)\n                vol_integral = 0.0\n                x_offset = (i + 0.5) * dx\n                y_offset = (j + 0.5) * dy\n                x_scale = dx / 2.0\n                y_scale = dy / 2.0\n\n                for p_idx, p_node in enumerate(gauss_nodes):\n                    for q_idx, q_node in enumerate(gauss_nodes):\n                        x_gauss = x_offset + p_node * x_scale\n                        y_gauss = y_offset + q_node * y_scale\n                        \n                        integrand = div_flux(x_gauss, y_gauss, K_func, dK_dx_func, dK_dy_func)\n                        vol_integral += gauss_weights[p_idx] * gauss_weights[q_idx] * integrand\n\n                vol_integral *= x_scale * y_scale # Multiply by Jacobian\n\n                # 3. Conservation Error\n                error_ij = surf_integral - vol_integral\n                if abs(error_ij) > max_error:\n                    max_error = abs(error_ij)\n\n        results.append(max_error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}