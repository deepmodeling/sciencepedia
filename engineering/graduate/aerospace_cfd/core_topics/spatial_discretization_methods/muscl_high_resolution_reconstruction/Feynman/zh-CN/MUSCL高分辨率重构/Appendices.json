{
    "hands_on_practices": [
        {
            "introduction": "一个高分辨率格式若要达到二阶精度，其关键要求之一是能够在光滑的线性解区域内将数值耗散降至最低。本练习通过一个理想化的思想实验，检验多种常见的TVD限制器在常数梯度剖面（即线性解）上的行为，并计算由此产生的数值耗散 。这个实践揭示了保证二阶精度的基本属性，即在理想线性数据上，重构应该是连续且无耗散的。",
            "id": "3978800",
            "problem": "考虑一维标量守恒律 $u_{t} + a\\,u_{x} = 0$，其中平流速度 $a  0$ 为常数，作用于间距为 $\\Delta x$ 的均匀单元中心网格 $\\{x_{i}\\}$ 上。在有限体积离散化中，使用保守律的单调上游中心格式（MUSCL）高分辨率重构来形成分段线性状态。设 $x_{i+\\frac{1}{2}}$ 处的左右重构界面状态为\n$$U_{i+\\frac{1}{2}}^{L} = U_{i} + \\frac{1}{2}\\,s_{i}, \\quad U_{i+\\frac{1}{2}}^{R} = U_{i+1} - \\frac{1}{2}\\,s_{i+1},$$\n其中限制斜率 $s_{i}$ 由 $s_{i} = \\phi(r_{i})\\,(U_{i+1} - U_{i})$ 给出，其中总变差递减（TVD）限制器参数为 $r_{i} = \\dfrac{U_{i} - U_{i-1}}{U_{i+1} - U_{i}}$，限制器函数 $\\phi(r)$ 选自以下经过充分检验的 TVD 限制器：\n- Minmod: $\\phi_{\\mathrm{MM}}(r) = \\max\\!\\big(0, \\min(1, r)\\big)$,\n- Van Leer: $\\phi_{\\mathrm{VL}}(r) = \\dfrac{r + |r|}{1 + |r|}$,\n- Monotonized Central (MC): $\\phi_{\\mathrm{MC}}(r) = \\max\\!\\Big(0, \\min\\!\\big(2r, \\dfrac{1 + r}{2}, 2\\big)\\Big)$,\n- Superbee: $\\phi_{\\mathrm{SB}}(r) = \\max\\!\\big(0, \\min(2r, 1), \\min(r, 2)\\big)$,\n- Van Albada: $\\phi_{\\mathrm{VA}}(r) = \\dfrac{r^{2} + r}{1 + r^{2}}$。\n\n数值通量采用局部 Lax–Friedrichs（也称为 Rusanov）通量，\n$$F_{i+\\frac{1}{2}} = \\frac{a}{2}\\,\\Big(U_{i+\\frac{1}{2}}^{L} + U_{i+\\frac{1}{2}}^{R}\\Big) - \\frac{|a|}{2}\\,\\Big(U_{i+\\frac{1}{2}}^{R} - U_{i+\\frac{1}{2}}^{L}\\Big).$$\n将界面 $x_{i+\\frac{1}{2}}$ 处的耗散贡献定义为\n$$D_{i+\\frac{1}{2}} = \\frac{|a|}{2}\\,\\big|U_{i+\\frac{1}{2}}^{R} - U_{i+\\frac{1}{2}}^{L}\\big|.$$\n\n假设一个离散剖面具有恒定的向前和向后差分，使得 $U_{i+1} - U_{i} = U_{i} - U_{i-1} \\neq 0$，因此 $r_{i} = 1$ 且 $r_{i+1} = 1$。对于上面列出的每个限制器，在 $r=1$ 的条件下比较重构的界面状态 $U_{i+\\frac{1}{2}}^{L}$ 和 $U_{i+\\frac{1}{2}}^{R}$，并计算得到的 $D_{i+\\frac{1}{2}}$。\n\n将最终答案表示为单个实数。不需要四舍五入，最终答案中也不包含任何物理单位。",
            "solution": "该问题要求计算一维标量平流方程的局部 Lax-Friedrichs 数值通量的耗散贡献 $D_{i+\\frac{1}{2}}$。该计算需要在具有恒定梯度的分段线性数据剖面的特定条件下进行，使用 MUSCL 高分辨率重构方法和几种常见的 TVD 通量限制器。\n\n问题将界面 $x_{i+\\frac{1}{2}}$ 处的左右重构状态定义为：\n$$U_{i+\\frac{1}{2}}^{L} = U_{i} + \\frac{1}{2}\\,s_{i}$$\n$$U_{i+\\frac{1}{2}}^{R} = U_{i+1} - \\frac{1}{2}\\,s_{i+1}$$\n限制斜率 $s_i$ 由 $s_{i} = \\phi(r_{i})\\,(U_{i+1} - U_{i})$ 给出，其中 $\\phi(r)$ 是一个限制器函数，$r_i$ 是连续梯度的比率：\n$$r_{i} = \\frac{U_{i} - U_{i-1}}{U_{i+1} - U_{i}}$$\n对通量的耗散贡献定义为：\n$$D_{i+\\frac{1}{2}} = \\frac{|a|}{2}\\,\\big|U_{i+\\frac{1}{2}}^{R} - U_{i+\\frac{1}{2}}^{L}\\big|$$\n其中 $a0$ 是恒定的平流速度，因此 $|a|=a$。\n\n提供的关键条件是离散剖面具有恒定的向前和向后差分，使得 $U_{i+1} - U_{i} = U_{i} - U_{i-1} \\neq 0$。这直接意味着限制器参数 $r_{i}$ 为：\n$$r_{i} = \\frac{U_{i} - U_{i-1}}{U_{i+1} - U_{i}} = 1$$\n问题还指出 $r_{i+1} = 1$。这与具有全局恒定梯度的剖面是一致的，因为 $r_{i+1} = \\frac{U_{i+1} - U_{i}}{U_{i+2} - U_{i+1}} = 1$ 意味着 $U_{i+2} - U_{i+1} = U_{i+1} - U_{i}$。\n\n我们的第一步是计算每个指定的限制器函数 $\\phi(r)$ 在 $r=1$ 时的值。这是一个格式在解的光滑区域达到二阶精度的必要条件。\n\n1.  **Minmod 限制器：**\n    $$\\phi_{\\mathrm{MM}}(r) = \\max\\!\\big(0, \\min(1, r)\\big)$$\n    当 $r=1$ 时：\n    $$\\phi_{\\mathrm{MM}}(1) = \\max\\!\\big(0, \\min(1, 1)\\big) = \\max(0, 1) = 1$$\n\n2.  **Van Leer 限制器：**\n    $$\\phi_{\\mathrm{VL}}(r) = \\frac{r + |r|}{1 + |r|}$$\n    当 $r=1$ 时：\n    $$\\phi_{\\mathrm{VL}}(1) = \\frac{1 + |1|}{1 + |1|} = \\frac{1 + 1}{1 + 1} = \\frac{2}{2} = 1$$\n\n3.  **Monotonized Central (MC) 限制器：**\n    $$\\phi_{\\mathrm{MC}}(r) = \\max\\!\\Big(0, \\min\\!\\big(2r, \\frac{1 + r}{2}, 2\\big)\\Big)$$\n    当 $r=1$ 时：\n    $$\\phi_{\\mathrm{MC}}(1) = \\max\\!\\Big(0, \\min\\!\\big(2(1), \\frac{1 + 1}{2}, 2\\big)\\Big) = \\max\\!\\big(0, \\min(2, 1, 2)\\big) = \\max(0, 1) = 1$$\n\n4.  **Superbee 限制器：**\n    $$\\phi_{\\mathrm{SB}}(r) = \\max\\!\\big(0, \\min(2r, 1), \\min(r, 2)\\big)$$\n    当 $r=1$ 时：\n    $$\\phi_{\\mathrm{SB}}(1) = \\max\\!\\big(0, \\min(2(1), 1), \\min(1, 2)\\big) = \\max\\!\\big(0, \\min(2, 1), \\min(1, 2)\\big) = \\max(0, 1, 1) = 1$$\n\n5.  **Van Albada 限制器：**\n    $$\\phi_{\\mathrm{VA}}(r) = \\frac{r^{2} + r}{1 + r^{2}}$$\n    当 $r=1$ 时：\n    $$\\phi_{\\mathrm{VA}}(1) = \\frac{1^{2} + 1}{1 + 1^{2}} = \\frac{1+1}{1+1} = \\frac{2}{2} = 1$$\n\n对于所有五个指定的限制器，我们都发现 $\\phi(1) = 1$。这意味着无论选择哪一个限制器，结果都将是相同的。\n\n现在，我们计算限制斜率 $s_{i}$ 和 $s_{i+1}$。\n对于斜率 $s_{i}$：\n$$s_{i} = \\phi(r_{i})\\,(U_{i+1} - U_{i}) = \\phi(1)\\,(U_{i+1} - U_{i}) = 1 \\cdot (U_{i+1} - U_{i}) = U_{i+1} - U_{i}$$\n对于斜率 $s_{i+1}$，我们使用条件 $r_{i+1}=1$，这意味着 $U_{i+2}-U_{i+1} = U_{i+1}-U_i$。\n$$s_{i+1} = \\phi(r_{i+1})\\,(U_{i+2} - U_{i+1}) = \\phi(1)\\,(U_{i+1} - U_{i}) = 1 \\cdot (U_{i+1} - U_{i}) = U_{i+1} - U_{i}$$\n两个斜率是相同的，并且等于非限制的中心差分梯度。\n\n接下来，我们将这些斜率代入重构界面状态 $U_{i+\\frac{1}{2}}^{L}$ 和 $U_{i+\\frac{1}{2}}^{R}$ 的表达式中。\n对于左状态：\n$$U_{i+\\frac{1}{2}}^{L} = U_{i} + \\frac{1}{2}\\,s_{i} = U_{i} + \\frac{1}{2}\\,(U_{i+1} - U_{i}) = U_{i} - \\frac{1}{2}\\,U_{i} + \\frac{1}{2}\\,U_{i+1} = \\frac{1}{2}\\,(U_{i} + U_{i+1})$$\n对于右状态：\n$$U_{i+\\frac{1}{2}}^{R} = U_{i+1} - \\frac{1}{2}\\,s_{i+1} = U_{i+1} - \\frac{1}{2}\\,(U_{i+1} - U_{i}) = U_{i+1} - \\frac{1}{2}\\,U_{i+1} + \\frac{1}{2}\\,U_{i} = \\frac{1}{2}\\,(U_{i+1} + U_{i})$$\n\n比较这两个重构状态，我们发现：\n$$U_{i+\\frac{1}{2}}^{L} = U_{i+\\frac{1}{2}}^{R} = \\frac{1}{2}\\,(U_{i} + U_{i+1})$$\n界面处的重构值是相同的。这表明解的分段线性表示在单元界面 $x_{i+\\frac{1}{2}}$ 处是连续的。这对于一个在光滑、单调数据区域的二阶精度重构格式来说是预期的行为。\n\n最后，我们使用其定义计算耗散贡献 $D_{i+\\frac{1}{2}}$：\n$$D_{i+\\frac{1}{2}} = \\frac{|a|}{2}\\,\\big|U_{i+\\frac{1}{2}}^{R} - U_{i+\\frac{1}{2}}^{L}\\big|$$\n代入推导出的状态：\n$$D_{i+\\frac{1}{2}} = \\frac{|a|}{2}\\,\\left|\\frac{1}{2}\\,(U_{i} + U_{i+1}) - \\frac{1}{2}\\,(U_{i} + U_{i+1})\\right| = \\frac{|a|}{2}\\,|0| = 0$$\n在给定条件下，对于所有指定的限制器，界面处的耗散贡献都精确为零。这是因为在恒定梯度区域，一个为二阶精度设计的 TVD 格式会回退到一个无耗散（或最小耗散）的中心格式。对于 Rusanov 通量，当界面处重构状态的跳跃为零时，耗散项消失。\n\n最终答案是 $0$。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "在理论上验证了限制器的基本属性后，我们转向一个完整的编程实践，以在数值上验证格式的收敛阶。本练习  要求您从零开始，编写一个完整的MUSCL有限体积格式，用于求解高斯脉冲的线性平流问题。最终目标是通过网格加密进行收敛性研究，从而定量地确认该格式在光滑解上确实达到了预期的二阶精度。",
            "id": "3978860",
            "problem": "考虑定义在周期性域 $x \\in [0,L]$ 上的非量纲化一维线性平流方程 $u_t + a\\,u_x = 0$。初始条件为光滑的高斯脉冲 $u(x,0) = \\exp\\!\\left(-\\dfrac{(x - x_0)^2}{2\\,\\sigma^2}\\right)$，其中 $x_0 \\in [0,L]$ 且 $\\sigma  0$。在周期性边界条件下，时间 $T$ 后的精确解为 $u(x,T) = u(x - a\\,T,0)$。对于 $a = 1$ 和 $T = L$，解完成一个完整周期并精确返回到初始条件，因此 $u(x,L) = u(x,0)$。\n\n从积分守恒形式和在具有 $N$ 个宽度为 $\\Delta x = L/N$ 的单元的均匀网格上有限体积法的定义出发，使用守恒律单调上游中心格式 (Monotonic Upstream-centered Schemes for Conservation Laws, MUSCL) 高分辨率重构，推导单元平均值 $U_i(t)$ 的二阶精度半离散更新。使用总变差递减 (Total Variation Diminishing, TVD) 限制器来确保稳定性和无振荡行为。使用二阶强稳定性保持龙格-库塔 (Strong Stability Preserving Runge–Kutta, SSP RK2) 时间积分来封闭该半离散系统。每个单元界面上的数值通量必须与 $a$ 的符号保持迎风一致性。\n\n对于网格尺寸 $\\Delta x = L/N$，在 $t=T$ 时刻，将离散 $L_1$ 误差范数 $E_{1}(N)$ 和离散 $L_2$ 误差范数 $E_{2}(N)$ 定义为\n$$\nE_{1}(N) = \\Delta x \\sum_{i=0}^{N-1} \\left| U_i(T) - U_i^{\\text{exact}}(T) \\right|,\n\\qquad\nE_{2}(N) = \\left(\\Delta x \\sum_{i=0}^{N-1} \\left( U_i(T) - U_i^{\\text{exact}}(T) \\right)^2 \\right)^{1/2},\n$$\n其中 $U_i^{\\text{exact}}(T)$ 表示与您的离散化方法一致的、在单元中心采样为单元平均值或点值的精确解。通过对一系列加密网格上的 $\\log(E_{1}(N))$ 和 $\\log(E_{2}(N))$ 相对于 $\\log(\\Delta x)$ 进行直线拟合，来估计观测到的收敛阶 $p_1$ 和 $p_2$，并将收敛阶定义为拟合的斜率。验证在光滑数据上，收敛阶近似为二阶。\n\n您的任务是编写一个完整、可运行的程序，该程序能够：\n- 为 $u_t + a\\,u_x = 0$（其中 $a = 1$，$x \\in [0,L]$，$L = 1$）在周期性边界条件下实现一个均匀有限体积离散化。\n- 使用带有 TVD 限制器的 MUSCL 高分辨率分段线性重构来获取左右界面状态。该限制器通过在三个典型选项中选择一个来进行参数化：minmod、van Leer 和单调中心 (Monotonized Central, MC)。\n- 使用二阶 SSP RK2 方法将解推进到时间 $T = L$。\n- 通过与精确解（对于 $T = L$ 的情况，精确解等于初始条件）进行比较，计算最终时刻的离散 $L_1$ 和 $L_2$ 误差范数。\n- 通过对测试套件中的网格尺寸进行对数-对数数据的线性回归，来估计观测到的收敛阶。\n\n全过程使用无量纲单位；不需要物理单位。\n\n测试套件：\n- 情况1：限制器 $=$ minmod，$\\text{CFL} = 0.5$，高斯宽度 $\\sigma = 0.05$，$x_0 = 0.25$，网格尺寸 $N \\in \\{50, 100, 200, 400\\}$。\n- 情况2：限制器 $=$ van Leer，$\\text{CFL} = 0.8$，高斯宽度 $\\sigma = 0.08$，$x_0 = 0.25$，网格尺寸 $N \\in \\{50, 100, 200, 400\\}$。\n- 情况3：限制器 $=$ MC，$\\text{CFL} = 0.4$，高斯宽度 $\\sigma = 0.03$，$x_0 = 0.25$，网格尺寸 $N \\in \\{50, 100, 200, 400\\}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例返回一个包含两个浮点数值 $[p_1, p_2]$ 的列表，表示观测到的 $L_1$ 和 $L_2$ 收敛阶。例如，输出格式必须为 $\\left[\\left[p_{1,1},p_{1,2}\\right],\\left[p_{2,1},p_{2,2}\\right],\\left[p_{3,1},p_{3,2}\\right]\\right]$。\n\n所有角度（如有）必须以弧度为单位，尽管本问题中未使用角度。不使用百分比；当需要分数时，必须表示为小数或有理比。\n\n不允许外部输入；所有参数均按上文规定固定，程序必须运行至完成，并仅按规定格式打印最终结果。",
            "solution": "用户提供了一个来自计算流体力学领域的有效且适定的问题陈述。任务是为一维线性平流方程实现一个二阶有限体积格式，验证其收敛阶，并以一个完整、可运行的程序形式提供该实现。以下是根据第一性原理推导出的一个完整、合理的解法。\n\n控制偏微分方程是线性平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\n其中 $u(x,t)$ 是守恒量，$x \\in [0,L]$ 是空间坐标，$t$ 是时间，$a$ 是恒定波速，给定为 $a=1$。区域长度为 $L=1$，采用周期性边界条件。初始条件是一个高斯脉冲：\n$$\nu(x,0) = \\exp\\left(-\\frac{(x - x_0)^2}{2\\sigma^2}\\right)\n$$\n该问题需求解至最终时间 $T=L=1$。给定 $a=1$ 和 $T=L$，精确解恰好传播一个周期，因此 $u(x,T) = u(x,0)$。\n\n**1. 有限体积离散化**\n\n我们从守恒律的积分形式出发，这是通过将偏微分方程在一个宽度为 $\\Delta x = x_{i+1/2} - x_{i-1/2}$ 的控制体积或单元 $C_i = [x_{i-1/2}, x_{i+1/2}]$ 上积分得到的：\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial u}{\\partial t} dx + \\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial (au)}{\\partial x} dx = 0\n$$\n将单元 $i$ 中 $u$ 的单元平均值定义为 $U_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$，方程变为：\n$$\n\\frac{d U_i}{dt} + \\frac{1}{\\Delta x} \\left[ (au)_{i+1/2} - (au)_{i-1/2} \\right] = 0\n$$\n在这里，$(au)_{i\\pm 1/2}$ 表示在单元界面 $x_{i\\pm 1/2}$ 处的 $u$ 的通量。在数值格式中，这些被数值通量函数 $F(u_L, u_R)$ 所取代，该函数依赖于界面左侧 ($u_L$) 和右侧 ($u_R$) 的重构状态。这就得到了半离散有限体积公式：\n$$\n\\frac{d U_i}{dt} = -\\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2})\n$$\n对于通量为 $f(u) = au$ 的线性平流方程，使用迎风数值通量。由于 $a=1  0$，信息从左向右传播。任何界面处的通量由其左侧的状态决定：\n$$\nF_{i+1/2} = F(U_{i+1/2}^L, U_{i+1/2}^R) = a U_{i+1/2}^L\n$$\n其中 $U_{i+1/2}^L$ 是在界面 $x_{i+1/2}$ 左侧重构的解的值。\n\n**2. MUSCL 高分辨率重构**\n\n为达到二阶空间精度，我们使用守恒律单调上游中心格式 (MUSCL) 方法。在每个单元 $C_i$ 内，解被近似为一个分段线性函数：\n$$\nu(x) \\approx U_i + s_i \\frac{x - x_i}{\\Delta x} \\quad \\text{for } x \\in [x_{i-1/2}, x_{i+1/2}]\n$$\n其中 $x_i$ 是单元中心，$s_i$ 是一个被限制的斜率。单元 $i$ 的右界面（即界面 $x_{i+1/2}$ 的左侧）处的值通过在 $x = x_{i+1/2} = x_i + \\Delta x/2$ 处计算该重构得到：\n$$\nU_{i+1/2}^L = U_i + \\frac{s_i}{2}\n$$\n单元 $i$ 的半离散更新需要通量 $F_{i+1/2}$ 和 $F_{i-1/2}$。通量 $F_{i-1/2}$ 由单元 $i-1$ 中的重构决定：\n$$\nF_{i-1/2} = a U_{i-1/2}^L = a \\left(U_{i-1} + \\frac{s_{i-1}}{2}\\right)\n$$\n因此，完整的半离散更新为：\n$$\n\\frac{d U_i}{dt} = -\\frac{a}{\\Delta x} \\left[ \\left(U_i + \\frac{s_i}{2}\\right) - \\left(U_{i-1} + \\frac{s_{i-1}}{2}\\right) \\right]\n$$\n\n**3. TVD 斜率限制器**\n\n为防止伪振荡并确保总变差递减 (TVD) 特性，斜率 $s_i$ 会受到限制。斜率基于相邻单元平均值之间的差值计算：后向差分 $\\Delta_i^- = U_i - U_{i-1}$ 和前向差分 $\\Delta_i^+ = U_{i+1} - U_i$。受限斜率为 $s_i = \\text{limiter}(\\Delta_i^-, \\Delta_i^+)$。问题指定了三个选项：\n\n- **Minmod 限制器：** 这是耗散性最强的限制器。\n  $$\n  s_i = \\text{minmod}(\\Delta_i^-, \\Delta_i^+) = \\begin{cases} \\text{sgn}(\\Delta_i^-) \\min(|\\Delta_i^-|, |\\Delta_i^+|)  \\text{if } \\Delta_i^- \\Delta_i^+  0 \\\\ 0  \\text{if } \\Delta_i^- \\Delta_i^+ \\le 0 \\end{cases}\n  $$\n- **Van Leer 限制器：** 一种光滑的限制器，在精度和单调性之间提供了良好的平衡。\n  $$\n  s_i = \\begin{cases} \\frac{2 \\Delta_i^- \\Delta_i^+}{\\Delta_i^- + \\Delta_i^+}  \\text{if } \\Delta_i^- \\Delta_i^+  0 \\\\ 0  \\text{if } \\Delta_i^- \\Delta_i^+ \\le 0 \\end{cases}\n  $$\n- **单调中心 (MC) 限制器：** 这种限制器耗散性较小，旨在在不引入振荡的情况下尽可能恢复中心差分斜率。\n  $$\n  s_i = \\text{minmod}\\left(2\\Delta_i^-, 2\\Delta_i^+, \\frac{\\Delta_i^- + \\Delta_i^+}{2}\\right)\n  $$\n  其中多参数 minmod 函数在所有参数符号相同时返回绝对值最小的参数，否则返回零。\n\n**4. 时间积分：SSP Runge-Kutta 2**\n\n半离散系统是一组形式为 $\\frac{dU}{dt} = L(U)$ 的常微分方程，其中 $L(U)$ 是空间算子（右侧项）。该系统使用二阶强稳定性保持龙格-库塔 (SSP-RK2) 方法进行时间积分，该方法也称为 Heun 方法。\n$$\n\\begin{aligned}\nU^{(1)} = U^n + \\Delta t \\, L(U^n) \\\\\nU^{n+1} = \\frac{1}{2} U^n + \\frac{1}{2} \\left( U^{(1)} + \\Delta t \\, L(U^{(1)}) \\right)\n\\end{aligned}\n$$\n时间步长 $\\Delta t$ 由 Courant-Friedrichs-Lewy (CFL) 稳定性条件确定：\n$$\n\\Delta t = \\text{CFL} \\frac{\\Delta x}{|a|}\n$$\n其中 $\\text{CFL}$ 数是一个用户指定的参数，对于这种显式格式，要求其小于或等于 $1$。\n\n**5. 误差分析与收敛阶估计**\n\n数值解 $U_i(T)$ 的精度通过将其与在单元中心 $x_i = (i+0.5)\\Delta x$ 处求值的精确解 $U_i^{\\text{exact}}(T) = u(x_i, T)$ 进行比较，并测量离散 $L_1$ 和 $L_2$ 误差范数来量化。\n$$\nE_{1}(N) = \\Delta x \\sum_{i=0}^{N-1} \\left| U_i(T) - U_i^{\\text{exact}}(T) \\right|, \\quad E_{2}(N) = \\left(\\Delta x \\sum_{i=0}^{N-1} \\left( U_i(T) - U_i^{\\text{exact}}(T) \\right)^2 \\right)^{1/2}\n$$\n收敛阶 $p$ 由关系式 $E \\propto (\\Delta x)^p$ 定义。取对数可得 $\\log(E) \\approx p \\log(\\Delta x) + \\text{const}$。因此，$p$ 是误差与网格尺寸的对数-对数图的斜率。问题为收敛阶提供了一个特定定义：对 $\\log(E)$ 与 $\\log(\\Delta x)$ 进行线性拟合所得的斜率。此约定将被严格遵守。对一系列网格加密 $N_k$（其中 $\\Delta x_k = L/N_k$）的数据点 $(\\log(\\Delta x_k), \\log(E_k))$ 进行线性回归。如果计算出的斜率为 $m$，则报告的收敛阶为 $p = m$。对于光滑解上的二阶格式，斜率 $m$ 预期约为 $2$，这将导致报告的收敛阶约为 $2$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    \n    test_cases = [\n        {\"limiter\": \"minmod\", \"cfl\": 0.5, \"sigma\": 0.05, \"x0\": 0.25, \"N_list\": [50, 100, 200, 400]},\n        {\"limiter\": \"van_leer\", \"cfl\": 0.8, \"sigma\": 0.08, \"x0\": 0.25, \"N_list\": [50, 100, 200, 400]},\n        {\"limiter\": \"mc\", \"cfl\": 0.4, \"sigma\": 0.03, \"x0\": 0.25, \"N_list\": [50, 100, 200, 400]},\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        rates = compute_convergence_rates(case)\n        all_results.append(rates)\n\n    # Format the final output string exactly as required.\n    result_strings = [f\"[{r[0]},{r[1]}]\" for r in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\ndef compute_convergence_rates(params):\n    \"\"\"\n    Computes convergence rates for a given set of parameters over a list of mesh sizes.\n    \"\"\"\n    L = 1.0\n    errors_l1 = []\n    errors_l2 = []\n    dx_values = []\n\n    for N in params[\"N_list\"]:\n        dx = L / N\n        U_final = run_simulation(\n            N=N,\n            limiter_type=params[\"limiter\"],\n            cfl=params[\"cfl\"],\n            sigma=params[\"sigma\"],\n            x0=params[\"x0\"]\n        )\n        \n        # Cell centers\n        x = np.linspace(0.5 * dx, L - 0.5 * dx, N)\n        \n        # Exact solution at final time T=L (is the same as initial condition)\n        U_exact = np.exp(-((x - params[\"x0\"])**2) / (2 * params[\"sigma\"]**2))\n        \n        # Compute error norms\n        error_l1 = dx * np.sum(np.abs(U_final - U_exact))\n        error_l2 = np.sqrt(dx * np.sum((U_final - U_exact)**2))\n        \n        errors_l1.append(error_l1)\n        errors_l2.append(error_l2)\n        dx_values.append(dx)\n\n    # Convert to log scale for linear regression\n    log_dx = np.log(dx_values)\n    log_e1 = np.log(errors_l1)\n    log_e2 = np.log(errors_l2)\n    \n    # Fit line and get slope. Scipy's linregress is robust.\n    # The problem defines the rate as the slope of log(E) vs log(dx).\n    slope1 = linregress(log_dx, log_e1).slope\n    slope2 = linregress(log_dx, log_e2).slope\n    \n    p1 = slope1\n    p2 = slope2\n    \n    return [p1, p2]\n\ndef run_simulation(N, limiter_type, cfl, sigma, x0):\n    \"\"\"\n    Runs a single finite volume simulation.\n    \"\"\"\n    L = 1.0\n    a = 1.0\n    T = 1.0\n    \n    dx = L / N\n    dt = cfl * dx / np.abs(a)\n    num_steps = int(np.ceil(T / dt))\n    dt = T / num_steps  # Adjust dt to hit T exactly\n\n    # Initial condition at cell centers\n    x = np.linspace(0.5 * dx, L - 0.5 * dx, N)\n    U = np.exp(-((x - x0)**2) / (2 * sigma**2))\n\n    limiters = {\n        \"minmod\": minmod_limiter,\n        \"van_leer\": van_leer_limiter,\n        \"mc\": mc_limiter\n    }\n    limiter = limiters[limiter_type]\n\n    # Time integration loop (SSP-RK2)\n    for _ in range(num_steps):\n        # Stage 1\n        rhs1 = get_rhs(U, a, dx, limiter)\n        U1 = U + dt * rhs1\n        \n        # Stage 2\n        rhs2 = get_rhs(U1, a, dx, limiter)\n        U = 0.5 * U + 0.5 * (U1 + dt * rhs2)\n        \n    return U\n\ndef get_rhs(U, a, dx, limiter):\n    \"\"\"\n    Calculates the right-hand side of the semi-discrete equation dU/dt = L(U).\n    \"\"\"\n    N = len(U)\n    \n    # Apply periodic boundary conditions using np.roll for vectorization\n    U_m = np.roll(U, 1)  # U_{i-1}\n    U_p = np.roll(U, -1) # U_{i+1}\n    \n    # Compute forward and backward differences for slope calculation\n    delta_m = U - U_m\n    delta_p = U_p - U\n    \n    # Compute limited slopes for all cells\n    s = limiter(delta_m, delta_p)\n    \n    # Slopes from the cell to the left\n    s_m = np.roll(s, 1) # s_{i-1}\n    \n    # Reconstruct values at interfaces (since a0, we need the left state)\n    # Value at right-side interface of cell i: U_{i+1/2}^L\n    U_L_iphalf = U + s / 2.0\n    \n    # Fluxes at the right interface of each cell\n    F_iphalf = a * U_L_iphalf\n    \n    # Fluxes at the left interface of each cell, which is the right flux of the cell to the left\n    F_imhalf = np.roll(F_iphalf, 1)\n\n    # RHS of the semi-discrete FVM update\n    rhs = -(F_iphalf - F_imhalf) / dx\n    return rhs\n\n# --- TVD Limiter Functions ---\ndef minmod_limiter(a, b):\n    # sgn(a) and sgn(b) are +1, -1, or 0\n    # The term (np.sign(a) + np.sign(b)) / 2 is 1 if both 0, -1 if both  0, 0 otherwise\n    return (np.sign(a) + np.sign(b)) / 2.0 * np.minimum(np.abs(a), np.abs(b))\n\ndef van_leer_limiter(a, b):\n    # This limiter is harmonic mean of the slopes\n    num = 2 * a * b\n    den = a + b\n    # Create result array, default to 0\n    result = np.zeros_like(a)\n    # Mask where denominator is non-zero and signs are the same (a*b  0)\n    # Add a small epsilon to denominator to prevent division by zero in edge cases\n    mask = (a * b > 0)\n    result[mask] = num[mask] / (den[mask] + 1e-12)\n    return result\n\ndef mc_limiter(a, b):\n    # Monotonized Central limiter\n    # s = minmod(2a, 2b, (a+b)/2)\n    # Implemented by chaining the two-argument minmod\n    c = (a + b) / 2.0\n    return minmod_limiter(minmod_limiter(2 * a, 2 * b), c)\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "在光滑流场中验证了格式的精度后，我们将其应用于航空航天领域中更具挑战性的非线性场景：激波捕捉。本练习  将引导您分析在使用MUSCL格式求解伯格斯方程时产生的数值激波速度误差。通过将误差分解为源于重构和黎曼求解器的分量，本练习揭示了激波捕捉格式中可能存在的、对预测激波位置至关重要的精确性问题。",
            "id": "3978835",
            "problem": "考虑一个标量非线性守恒律，它被用作航空航天计算流体力学中激波捕捉分析的典型模型，即无粘伯格斯方程，\n$$\nu_t + \\left(\\frac{u^2}{2}\\right)_x = 0,\n$$\n其中 $u$ 是无量纲的。设计算方法为一种有限体积格式，其采用守恒律的单调上游中心格式 (Monotone Upstream-centered Schemes for Conservation Laws, MUSCL) 高分辨率重构和 Roe 近似黎曼求解器 (Roe)。\n\n基本原理：\n- 在宽度为 $\\Delta x$ 的单元上的守恒和有限体积更新，数值界面通量为 $F_{i+1/2}$：\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+1/2} - F_{i-1/2}\\right).\n$$\n- 对于以速度 $s$ 移动的间断，Rankine–Hugoniot 条件为：\n$$\ns \\left[ u \\right] = \\left[ f(u) \\right], \\quad f(u) = \\frac{u^2}{2},\n$$\n因此，对于一个左状态为 $u_L$ 右状态为 $u_R$ 的黎曼问题，精确的激波速度为\n$$\ns_{\\text{exact}} = \\frac{f(u_R)-f(u_L)}{u_R-u_L} = \\frac{u_L + u_R}{2}.\n$$\n\n在界面 $x_{i+1/2}$ 处的 MUSCL 重构使用限制后的斜率来构建左右状态 $u_{i+1/2}^-$ 和 $u_{i+1/2}^+$。设后向和前向差分为\n$$\n\\delta^-_i = \\bar{u}_i - \\bar{u}_{i-1}, \\quad \\delta^+_i = \\bar{u}_{i+1} - \\bar{u}_i,\n$$\n并定义比率\n$$\nr_i = \\frac{\\delta^-_i}{\\delta^+_i},\n$$\n约定如果 $\\delta^+_i = 0$ 则 $r_i = 0$。一个总变差不增 (Total Variation Diminishing, TVD) 通量限制器 $\\phi(r)$ 将 $r$ 映射为一个斜率因子：\n- Minmod 限制器：\n$$\n\\phi_{\\text{minmod}}(r) = \\max\\left(0, \\min(1, r)\\right).\n$$\n- Van Leer 限制器：\n$$\n\\phi_{\\text{vanleer}}(r) = \\frac{r + |r|}{1 + |r|}.\n$$\n- 单调中心 (Monotonized Central, MC) 限制器：\n$$\n\\phi_{\\text{mc}}(r) = \\max\\left(0, \\min\\left(\\frac{1+r}{2}, 2, 2r\\right)\\right).\n$$\n- Superbee 限制器：\n$$\n\\phi_{\\text{superbee}}(r) = \\max\\left(0, \\min(2r, 1), \\min(r, 2)\\right).\n$$\n\n名义上的 MUSCL 斜率是\n$$\ns_i = \\phi(r_i)\\,\\delta^-_i, \\quad s_{i+1} = \\phi(r_{i+1})\\,\\delta^-_{i+1},\n$$\n并使用一个简单的重构偏差参数 $b \\in [-1,1]$ 来模拟激波附近重构的非对称性：\n$$\n\\tilde{s}_i = (1+b)\\,s_i, \\quad \\tilde{s}_{i+1} = (1-b)\\,s_{i+1}.\n$$\n重构的界面状态为\n$$\nu_{i+1/2}^- = \\bar{u}_i + \\frac{1}{2}\\tilde{s}_i, \\quad u_{i+1/2}^+ = \\bar{u}_{i+1} - \\frac{1}{2}\\tilde{s}_{i+1}.\n$$\n\n用于标量伯格斯通量的 Roe 近似黎曼求解器使用 Roe 平均波速\n$$\na = \\frac{u_{i+1/2}^- + u_{i+1/2}^+}{2},\n$$\n以及经耗散缩放的数值通量\n$$\n\\hat{F}_{i+1/2} = \\frac{1}{2}\\left(f(u_{i+1/2}^-) + f(u_{i+1/2}^+)\\right) - \\frac{1}{2}\\lambda\\,|a|\\left(u_{i+1/2}^+ - u_{i+1/2}^-\\right),\n$$\n其中 $\\lambda \\in [0,1]$ 缩放 Roe 耗散的大小。\n\n假设一个激波位于 $x_{i+1/2}$，其左平台状态为 $\\bar{u}_i = u_L$，右平台状态为 $\\bar{u}_{i+1} = u_R$。对左单元使用质量平衡，通过以下方式将激波速度与通量联系起来\n$$\n\\bar{u}_i^{n+1} - \\bar{u}_i^n = \\frac{s\\,\\Delta t}{\\Delta x}(u_R - u_L) = -\\frac{\\Delta t}{\\Delta x}\\left(\\hat{F}_{i+1/2} - f(u_L)\\right),\n$$\n这给出了数值激波速度的操作性定义\n$$\ns_{\\text{num}} = -\\frac{\\hat{F}_{i+1/2} - f(u_L)}{u_R - u_L}.\n$$\n\n为了分离各项贡献，定义一个仅由重构偏差产生的激波速度，通过将重构状态代入 Rankine–Hugoniot 关系得到，\n$$\ns_{\\text{rb}} = \\frac{f(u_{i+1/2}^+) - f(u_{i+1/2}^-)}{u_{i+1/2}^+ - u_{i+1/2}^-} = \\frac{u_{i+1/2}^- + u_{i+1/2}^+}{2},\n$$\n以及一个耗散大小\n$$\nD = \\frac{1}{2}\\lambda\\,|a|\\,\\left|u_{i+1/2}^+ - u_{i+1/2}^-\\right|.\n$$\n总的数值激波速度误差为\n$$\n\\varepsilon_s = s_{\\text{num}} - s_{\\text{exact}},\n$$\n它可以分解为重构偏差分量\n$$\n\\varepsilon_{\\text{bias}} = s_{\\text{rb}} - s_{\\text{exact}},\n$$\n以及通量-耗散-加-平均分量\n$$\n\\varepsilon_{\\text{flux}} = s_{\\text{num}} - s_{\\text{rb}}.\n$$\n\n任务：\n- 实现一个程序，针对提供的测试套件，为每个案例计算包含四个浮点数的列表 $[\\varepsilon_s, \\varepsilon_{\\text{bias}}, \\varepsilon_{\\text{flux}}, D]$。\n\n使用以下测试套件，其中每个案例指定了 $(\\bar{u}_{i-1}, \\bar{u}_i, \\bar{u}_{i+1}, \\bar{u}_{i+2}, \\text{limiter}, b, \\lambda)$：\n- 案例 1（强激波，基准 minmod）：$(3, 3, 0, 0, \\text{\"minmod\"}, 0, 1)$。\n- 案例 2（强激波，正偏差）：$(3, 3, 0, 0, \\text{\"minmod\"}, 0.5, 1)$。\n- 案例 3（强激波，van Leer 限制器）：$(3, 3, 0, 0, \\text{\"vanleer\"}, 0, 1)$。\n- 案例 4（强激波，减小耗散，MC 限制器）：$(3, 3, 0, 0, \\text{\"mc\"}, 0, 0.5)$。\n- 案例 5（静止激波边缘案例，superbee）：$(1, 1, -1, -1, \\text{\"superbee\"}, 0, 1)$。\n\n所有量均为无量纲。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，列表的每个元素是对应一个案例的四个浮点数列表，例如 $[[x_{11},x_{12},x_{13},x_{14}],[x_{21},x_{22},x_{23},x_{24}],\\dots]$。程序必须严格使用上述测试套件，并按指定格式打印该单行输出。",
            "solution": "该问题是有效的，因为它科学地基于守恒律数值方法的既定理论，具有完整且一致的定义和数据，是一个适定问题，并且使用客观、正式的语言表述。因此，我们可以着手求解。\n\n核心任务是计算应用于无粘伯格斯方程 $u_t + (\\frac{1}{2}u^2)_x = 0$ 的守恒律的单调上游中心格式 (MUSCL) 有限体积法的数值激波速度误差分量。物理通量函数为 $f(u) = \\frac{1}{2}u^2$。对于每个测试案例，我们必须计算总误差 $\\varepsilon_s$、重构偏差误差 $\\varepsilon_{\\text{bias}}$、通量耗散误差 $\\varepsilon_{\\text{flux}}$ 和耗散大小 $D$。\n\n每个测试案例 $(\\bar{u}_{i-1}, \\bar{u}_i, \\bar{u}_{i+1}, \\bar{u}_{i+2}, \\text{limiter}, b, \\lambda)$ 的计算过程如下：\n\n1.  **确定平台状态和精确激波速度：** 问题指定了一个位于界面 $x_{i+1/2}$ 的激波，其平台状态为 $u_L = \\bar{u}_i$ 和 $u_R = \\bar{u}_{i+1}$。根据 Rankine-Hugoniot 条件，精确的激波速度为：\n    $$\n    s_{\\text{exact}} = \\frac{u_L + u_R}{2}\n    $$\n\n2.  **MUSCL 重构：** 重构提供了界面 $x_{i+1/2}$ 左右两侧的状态 $u_{i+1/2}^-$ 和 $u_{i+1/2}^+$。这涉及几个步骤：\n    a.  **计算差分和比率：** 我们需要单元 $i$ 和 $i+1$ 的斜率。\n        -   对于单元 $i$，使用模板 $(\\bar{u}_{i-1}, \\bar{u}_i, \\bar{u}_{i+1})$：\n            $$\n            \\delta^-_i = \\bar{u}_i - \\bar{u}_{i-1}, \\quad \\delta^+_i = \\bar{u}_{i+1} - \\bar{u}_i, \\quad r_i = \\frac{\\delta^-_i}{\\delta^+_i} \\text{ (if } \\delta^+_i \\neq 0, \\text{ else } 0 \\text{)}\n            $$\n        -   对于单元 $i+1$，使用模板 $(\\bar{u}_i, \\bar{u}_{i+1}, \\bar{u}_{i+2})$：\n            $$\n            \\delta^-_{i+1} = \\bar{u}_{i+1} - \\bar{u}_i, \\quad \\delta^+_{i+1} = \\bar{u}_{i+2} - \\bar{u}_{i+1}, \\quad r_{i+1} = \\frac{\\delta^-_{i+1}}{\\delta^+_{i+1}} \\text{ (if } \\delta^+_{i+1} \\neq 0, \\text{ else } 0 \\text{)}\n            $$\n    b.  **应用通量限制器：** 将指定的通量限制器函数 $\\phi(r)$ 应用于 $r_i$ 和 $r_{i+1}$ 以获得斜率修正因子。\n    c.  **计算带偏差的斜率：** 计算名义斜率 $s_i = \\phi(r_i)\\delta^-_i$ 和 $s_{i+1} = \\phi(r_{i+1})\\delta^-_{i+1}$，然后使用参数 $b$ 对其进行偏差处理：\n        $$\n        \\tilde{s}_i = (1+b)s_i, \\quad \\tilde{s}_{i+1} = (1-b)s_{i+1}\n        $$\n    d.  **确定界面状态：** 然后找到重构的状态：\n        $$\n        u_{i+1/2}^- = \\bar{u}_i + \\frac{1}{2}\\tilde{s}_i, \\quad u_{i+1/2}^+ = \\bar{u}_{i+1} - \\frac{1}{2}\\tilde{s}_{i+1}\n        $$\n\n3.  **Roe 近似黎曼求解器：**\n    a.  **计算 Roe 平均和数值通量：** 伯格斯方程的 Roe 平均波速为 $a = \\frac{u_{i+1/2}^- + u_{i+1/2}^+}{2}$。数值通量为：\n        $$\n        \\hat{F}_{i+1/2} = \\frac{1}{2}\\left(f(u_{i+1/2}^-) + f(u_{i+1/2}^+)\\right) - \\frac{1}{2}\\lambda\\,|a|\\left(u_{i+1/2}^+ - u_{i+1/2}^-\\right)\n        $$\n    b.  **计算耗散大小：**\n        $$\n        D = \\frac{1}{2}\\lambda\\,|a|\\,\\left|u_{i+1/2}^+ - u_{i+1/2}^-\\right|\n        $$\n\n4.  **计算数值激波速度和误差：**\n    a.  **重构偏差速度：** 该速度由重构状态推导得出：\n        $$\n        s_{\\text{rb}} = \\frac{u_{i+1/2}^- + u_{i+1/2}^+}{2} = a\n        $$\n    b.  **数值激波速度：** 这是根据有限体积更新操作性地定义的：\n        $$\n        s_{\\text{num}} = -\\frac{\\hat{F}_{i+1/2} - f(u_L)}{u_R - u_L}\n        $$\n    c.  **误差分量：** 然后按如下方式计算误差：\n        $$\n        \\varepsilon_{\\text{bias}} = s_{\\text{rb}} - s_{\\text{exact}}\n        $$\n        $$\n        \\varepsilon_{\\text{flux}} = s_{\\text{num}} - s_{\\text{rb}}\n        $$\n        $$\n        \\varepsilon_s = s_{\\text{num}} - s_{\\text{exact}} = \\varepsilon_{\\text{bias}} + \\varepsilon_{\\text{flux}}\n        $$\n\n让我们详细演示**案例 1** 的计算过程：$(\\bar{u}_{i-1}, \\bar{u}_i, \\bar{u}_{i+1}, \\bar{u}_{i+2}) = (3, 3, 0, 0)$，限制器 = \"minmod\"， $b=0$， $\\lambda=1$。\n1.  **精确速度：** $u_L = \\bar{u}_i = 3$, $u_R = \\bar{u}_{i+1} = 0$。$s_{\\text{exact}} = (3 + 0) / 2 = 1.5$。\n2.  **重构：** 对于单元 $i$，$r_i=0$；对于单元 $i+1$，$r_{i+1}=0$。Minmod 限制器给出 $\\phi(0)=0$，因此斜率 $s_i$ 和 $s_{i+1}$ 均为零。重构降为一阶，得到 $u_{i+1/2}^- = 3$ 和 $u_{i+1/2}^+ = 0$。\n3.  **Roe 求解器：** $a = (3+0)/2 = 1.5$。$\\hat{F}_{i+1/2} = \\frac{1}{2}(f(3) + f(0)) - \\frac{1}{2}(1)|1.5|(0-3) = 2.25 - 0.75(-3) = 4.5$。这与迎风通量 $f(u_L)$ 一致。耗散大小 $D = \\frac{1}{2}(1)|1.5||0-3| = 2.25$。\n4.  **速度和误差：** $s_{\\text{rb}} = a = 1.5$。$s_{\\text{num}} = -(4.5 - f(3))/(0-3) = -(4.5-4.5)/(-3) = 0$。因此，$\\varepsilon_{\\text{bias}} = 1.5 - 1.5 = 0$；$\\varepsilon_{\\text{flux}} = 0 - 1.5 = -1.5$；$\\varepsilon_s = -1.5$。\n案例 1 的结果是 $[-1.5, 0.0, -1.5, 2.25]$。\n\n- **案例 2 和 3：** 对于输入模板 $(3, 3, 0, 0)$，Van Leer 和 MC 限制器与 Minmod 一样，都会因 $r_i=0$ 和 $r_{i+1}=0$ 而产生零名义斜率。案例 2 中的偏差参数 $b$ 没有效果，因为它乘以一个零斜率。因此，案例 2 和 3 的计算结果与案例 1 完全相同。\n\n- **案例 4：** 此案例使用 $\\lambda=0.5$。重构与案例 1 相同。通量发生变化：$\\hat{F}_{i+1/2} = 2.25 - \\frac{1}{2}(0.5)|1.5|(-3) = 3.375$。这得到 $s_{\\text{num}} = -(3.375 - 4.5)/(-3) = -(-1.125)/(-3) = -0.375$。所产生的误差为 $\\varepsilon_s = -1.875, \\varepsilon_{\\text{bias}} = 0, \\varepsilon_{\\text{flux}} = -1.875$，以及 $D=1.125$。\n\n- **案例 5：** 这是一个静止激波 ($s_{\\text{exact}} = (1+(-1))/2=0$)。相同的重构逻辑导致零斜率和一阶状态 $u_{i+1/2}^- = 1, u_{i+1/2}^+ = -1$。Roe 速度 $a=0$。通量中的耗散项消失。$\\hat{F}_{i+1/2} = \\frac{1}{2}(f(1)+f(-1)) = \\frac{1}{2}(0.5+0.5) = 0.5$。由于 $f(u_L)=f(1)=0.5$，所以 $s_{\\text{num}} = -(0.5-0.5)/(-2) = 0$。所有速度均为零，因此所有误差也均为零。$D$ 也为零。这表明 Roe 格式可以精确解析静止激波。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes numerical shock speed errors for a MUSCL-Roe scheme on the Burgers equation.\n    \"\"\"\n\n    # --- Limiter Functions ---\n    def phi_minmod(r):\n        if r = 0: return 0.0\n        return np.min([1.0, r])\n\n    def phi_vanleer(r):\n        abs_r = np.abs(r)\n        if 1.0 + abs_r == 0: return 0.0\n        return (r + abs_r) / (1.0 + abs_r)\n\n    def phi_mc(r):\n        if r = 0: return 0.0\n        return np.min([(1.0 + r) / 2.0, 2.0, 2.0 * r])\n\n    def phi_superbee(r):\n        if r = 0: return 0.0\n        return np.max([np.min([2.0 * r, 1.0]), np.min([r, 2.0])])\n\n    limiters = {\n        \"minmod\": phi_minmod,\n        \"vanleer\": phi_vanleer,\n        \"mc\": phi_mc,\n        \"superbee\": phi_superbee\n    }\n\n    # --- Test Suite ---\n    test_cases = [\n        # (u_{i-1}, u_i, u_{i+1}, u_{i+2}), limiter, b, lambda\n        ((3.0, 3.0, 0.0, 0.0), \"minmod\", 0.0, 1.0),  # Case 1\n        ((3.0, 3.0, 0.0, 0.0), \"minmod\", 0.5, 1.0),  # Case 2\n        ((3.0, 3.0, 0.0, 0.0), \"vanleer\", 0.0, 1.0), # Case 3\n        ((3.0, 3.0, 0.0, 0.0), \"mc\", 0.0, 0.5),      # Case 4\n        ((1.0, 1.0, -1.0, -1.0), \"superbee\", 0.0, 1.0) # Case 5\n    ]\n\n    results = []\n\n    def physical_flux(u):\n        return 0.5 * u**2\n\n    for case in test_cases:\n        u_stencil, limiter_name, b, lam = case\n        u_im1, u_i, u_ip1, u_ip2 = u_stencil\n\n        # 1. Identify Plateau States and Exact Shock Speed\n        u_L = u_i\n        u_R = u_ip1\n        s_exact = 0.5 * (u_L + u_R)\n\n        # 2. MUSCL Reconstruction\n        # a. Compute differences and ratios\n        # Cell i\n        delta_minus_i = u_i - u_im1\n        delta_plus_i = u_ip1 - u_i\n        r_i = 0.0 if delta_plus_i == 0.0 else delta_minus_i / delta_plus_i\n        \n        # Cell i+1\n        delta_minus_ip1 = u_ip1 - u_i\n        delta_plus_ip1 = u_ip2 - u_ip1\n        r_ip1 = 0.0 if delta_plus_ip1 == 0.0 else delta_minus_ip1 / delta_plus_ip1\n\n        # b. Apply Flux Limiter\n        phi_func = limiters[limiter_name]\n        phi_ri = phi_func(r_i)\n        phi_rip1 = phi_func(r_ip1)\n\n        # c. Calculate Biased Slopes\n        s_i = phi_ri * delta_minus_i\n        s_ip1 = phi_rip1 * delta_minus_ip1\n        s_tilde_i = (1.0 + b) * s_i\n        s_tilde_ip1 = (1.0 - b) * s_ip1\n\n        # d. Determine Interface States\n        u_minus = u_i + 0.5 * s_tilde_i\n        u_plus = u_ip1 - 0.5 * s_tilde_ip1\n\n        # 3. Roe's Approximate Riemann Solver\n        # a. Compute Roe Average and Numerical Flux\n        a = 0.5 * (u_minus + u_plus)\n        f_minus = physical_flux(u_minus)\n        f_plus = physical_flux(u_plus)\n        \n        F_hat = 0.5 * (f_minus + f_plus) - 0.5 * lam * np.abs(a) * (u_plus - u_minus)\n\n        # b. Compute Dissipation Magnitude\n        D = 0.5 * lam * np.abs(a) * np.abs(u_plus - u_minus)\n\n        # 4. Calculate Numerical Shock Speeds and Errors\n        # a. Reconstruction-Bias Speed\n        s_rb = a\n\n        # b. Numerical Shock Speed\n        # Avoid division by zero if u_R == u_L (though not in test cases)\n        if u_R - u_L == 0:\n            s_num = 0.0 # Or undefined, but 0 is a safe choice\n        else:\n            s_num = -(F_hat - physical_flux(u_L)) / (u_R - u_L)\n\n        # c. Error Components\n        eps_bias = s_rb - s_exact\n        eps_flux = s_num - s_rb\n        eps_s = s_num - s_exact\n        \n        results.append([eps_s, eps_bias, eps_flux, D])\n\n    # Final print statement in the exact required format.\n    # Using a nested list comprehension for concise formatting.\n    formatted_results = [f\"[{','.join(f'{val:.12g}' for val in res)}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}