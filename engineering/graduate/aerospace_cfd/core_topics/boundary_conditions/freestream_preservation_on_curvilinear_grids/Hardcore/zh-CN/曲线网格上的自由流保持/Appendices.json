{
    "hands_on_practices": [
        {
            "introduction": "自由流保持特性始于最小的尺度：单个网格单元。本练习将从解析上证明一个基本的离散几何恒等式——一个闭合单元向外的面积矢量之和必须为零。这个结论是散度定理的离散模拟，构成了守恒型有限体积法的基石。",
            "id": "3961207",
            "problem": "在航空航天计算流体动力学（CFD）的背景下，考虑一个由计算坐标 $(\\xi,\\eta) \\in [0,1] \\times [0,1]$ 参数化的四边形计算单元。物理坐标 $\\mathbf{r}(\\xi,\\eta) = (x(\\xi,\\eta), y(\\xi,\\eta))$ 由 $\\mathbb{R}^2$ 中的四个角点 $\\mathbf{P}_{00}$、$\\mathbf{P}_{10}$、$\\mathbf{P}_{01}$ 和 $\\mathbf{P}_{11}$ 的双线性映射给出：\n$$\n\\mathbf{r}(\\xi,\\eta) = (1-\\xi)(1-\\eta)\\,\\mathbf{P}_{00} \\;+\\; \\xi(1-\\eta)\\,\\mathbf{P}_{10} \\;+\\; (1-\\xi)\\eta\\,\\mathbf{P}_{01} \\;+\\; \\xi\\eta\\,\\mathbf{P}_{11}.\n$$\n将四个物理边分别视为直线 $\\eta=0$、$\\xi=1$、$\\eta=1$ 和 $\\xi=0$ 的像，每条边都沿单元边界逆时针遍历。对于每条边，将其外向面法向长度向量（在二维中即面积向量）定义为外向单位法向量乘以该边上的微分弧长的线积分。仅从基本的几何和微积分定义（坐标映射、参数曲线的切向量、平面内的单位法向量和线积分）出发，计算四条边的外向面法向长度向量关于 $\\mathbf{P}_{00}$、$\\mathbf{P}_{10}$、$\\mathbf{P}_{01}$ 和 $\\mathbf{P}_{11}$ 的闭式表达式，然后计算它们的和。在曲线网格上自由来流守恒的背景下，离散度量恒等式要求这个和对于一个闭合单元必须为零。\n\n以闭式形式将最终的和表示为单个行向量。使用单个 $\\mathrm{pmatrix}$ 行矩阵表达最终答案。不需要进行数值取整，最终答案中也无需包含物理单位。",
            "solution": "问题陈述有效。它在科学上基于向量微积分和计算流体动力学的原理，是适定的、客观的，并包含获得唯一解所需的所有信息。\n\n该问题要求计算由双线性映射定义的计算单元四条边的外向面法向长度向量之和。这个和是闭合曲面上法向量面积分的离散表示，对于守恒律的计算至关重要。\n\n设物理坐标为 $\\mathbf{r}(\\xi,\\eta) = (x(\\xi,\\eta), y(\\xi,\\eta))$，物理空间中单元的四个角点为 $\\mathbf{P}_{00}$、$\\mathbf{P}_{10}$、$\\mathbf{P}_{01}$ 和 $\\mathbf{P}_{11}$。设 $\\mathbf{P}_{ij} = (x_{ij}, y_{ij})$。双线性映射由下式给出：\n$$ \\mathbf{r}(\\xi,\\eta) = (1-\\xi)(1-\\eta)\\mathbf{P}_{00} + \\xi(1-\\eta)\\mathbf{P}_{10} + (1-\\xi)\\eta\\mathbf{P}_{01} + \\xi\\eta\\mathbf{P}_{11} $$\n\n边的外向面法向长度向量，我们记为 $\\mathbf{S}$，由线积分定义：\n$$ \\mathbf{S} = \\int_{\\text{edge}} \\mathbf{n} \\, ds $$\n其中 $\\mathbf{n}$ 是外向单位法向量，$ds$ 是微分弧长元。\n\n我们首先推导 $\\mathbf{S}$ 的一个通用表达式。设一条边由变量 $t$ 参数化，其路径由 $\\mathbf{r}(t) = (x(t), y(t))$ 描述。路径的切向量为 $\\mathbf{r}'(t) = \\frac{d\\mathbf{r}}{dt} = (\\frac{dx}{dt}, \\frac{dy}{dt})$。微分弧长为 $ds = \\|\\mathbf{r}'(t)\\| \\, dt$。\n\n对于（如题设）逆时针遍历的边界，外向单位法向量 $\\mathbf{n}$ 可以通过将单位切向量 $\\mathbf{T} = \\frac{\\mathbf{r}'(t)}{\\|\\mathbf{r}'(t)\\|}$ 顺时针旋转 $\\frac{\\pi}{2}$ 弧度（$90^\\circ$）得到。如果 $\\mathbf{T} = (T_x, T_y)$，顺时针旋转得到向量 $(T_y, -T_x)$。因此，外向单位法向量为：\n$$ \\mathbf{n} = \\frac{1}{\\|\\mathbf{r}'(t)\\|} \\left(\\frac{dy}{dt}, -\\frac{dx}{dt}\\right) $$\n将 $\\mathbf{n}$ 和 $ds$ 的表达式代入 $\\mathbf{S}$ 的积分中：\n$$ \\mathbf{S} = \\int_{t_{\\text{start}}}^{t_{\\text{end}}} \\left( \\frac{1}{\\|\\mathbf{r}'(t)\\|} \\left(\\frac{dy}{dt}, -\\frac{dx}{dt}\\right) \\right) \\big( \\|\\mathbf{r}'(t)\\| \\, dt \\big) $$\n项 $\\|\\mathbf{r}'(t)\\|$ 被消去，极大地简化了被积函数：\n$$ \\mathbf{S} = \\int_{t_{\\text{start}}}^{t_{\\text{end}}} \\left(\\frac{dy}{dt}, -\\frac{dx}{dt}\\right) dt = \\int_{\\text{start}}^{\\text{end}} (dy, -dx) $$\n设边的起点为 $\\mathbf{P}_{\\text{start}} = (x_{\\text{start}}, y_{\\text{start}})$，终点为 $\\mathbf{P}_{\\text{end}} = (x_{\\text{end}}, y_{\\text{end}})$。对向量积分的每个分量使用微积分基本定理：\n$$ \\mathbf{S} = \\left( \\int_{y_{\\text{start}}}^{y_{\\text{end}}} dy, -\\int_{x_{\\text{start}}}^{x_{\\text{end}}} dx \\right) = \\left( [y]_{y_{\\text{start}}}^{y_{\\text{end}}}, -[x]_{x_{\\text{start}}}^{x_{\\text{end}}} \\right) $$\n$$ \\mathbf{S} = (y_{\\text{end}} - y_{\\text{start}}, -(x_{\\text{end}} - x_{\\text{start}})) = (y_{\\text{end}} - y_{\\text{start}}, x_{\\text{start}} - x_{\\text{end}}) $$\n这个结果表明，面法向长度向量仅取决于边端点的坐标。由双线性映射定义的单元的边是直线，因此这个公式是精确的。我们现在将其应用于逆时针遍历的四条边。\n\n边1（底边）：$\\eta=0$，$\\xi$ 从 $0$ 到 $1$。\n路径从 $\\mathbf{r}(0,0) = \\mathbf{P}_{00}$ 到 $\\mathbf{r}(1,0) = \\mathbf{P}_{10}$。\n$$ \\mathbf{S}_1 = (y_{10} - y_{00}, x_{00} - x_{10}) $$\n\n边2（右边）：$\\xi=1$，$\\eta$ 从 $0$ 到 $1$。\n路径从 $\\mathbf{r}(1,0) = \\mathbf{P}_{10}$ 到 $\\mathbf{r}(1,1) = \\mathbf{P}_{11}$。\n$$ \\mathbf{S}_2 = (y_{11} - y_{10}, x_{10} - x_{11}) $$\n\n边3（顶边）：$\\eta=1$，$\\xi$ 从 $1$ 到 $0$。\n路径从 $\\mathbf{r}(1,1) = \\mathbf{P}_{11}$ 到 $\\mathbf{r}(0,1) = \\mathbf{P}_{01}$。\n$$ \\mathbf{S}_3 = (y_{01} - y_{11}, x_{11} - x_{01}) $$\n\n边4（左边）：$\\xi=0$，$\\eta$ 从 $1$ 到 $0$。\n路径从 $\\mathbf{r}(0,1) = \\mathbf{P}_{01}$ 到 $\\mathbf{r}(0,0) = \\mathbf{P}_{00}$。\n$$ \\mathbf{S}_4 = (y_{00} - y_{01}, x_{01} - x_{00}) $$\n\n问题要求计算这四个向量的和，$\\mathbf{S}_{\\text{total}} = \\mathbf{S}_1 + \\mathbf{S}_2 + \\mathbf{S}_3 + \\mathbf{S}_4$。我们将各分量相加。\n\n和的第一个分量（x分量）是：\n$$ S_x = (y_{10} - y_{00}) + (y_{11} - y_{10}) + (y_{01} - y_{11}) + (y_{00} - y_{01}) $$\n重新整理各项表明它们两两相消：\n$$ S_x = (-y_{00} + y_{00}) + (y_{10} - y_{10}) + (y_{01} - y_{01}) + (y_{11} - y_{11}) = 0 $$\n\n和的第二个分量（y分量）是：\n$$ S_y = (x_{00} - x_{10}) + (x_{10} - x_{11}) + (x_{11} - x_{01}) + (x_{01} - x_{00}) $$\n类似地，重新整理各项表明它们也相消：\n$$ S_y = (x_{00} - x_{00}) + (-x_{10} + x_{10}) + (-x_{01} + x_{01}) + (-x_{11} + x_{11}) = 0 $$\n\n因此，闭合单元的外向面法向长度向量之和为零向量。\n$$ \\mathbf{S}_{\\text{total}} = (0, 0) $$\n这个结果通常被称为几何守恒律（GCL），是在曲线网格上精确保持均匀流（自由来流）的数值格式所必须满足的条件。它是散度定理恒等式 $\\oint_S \\mathbf{n} \\, dS = 0$ 在闭合曲面上对常向量场（本例中与位置无关）的离散模拟。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "从几何视角转向代数基础。连续介质的度量恒等式依赖于混合偏导数的相等性（即 $f_{\\xi\\eta} = f_{\\eta\\xi}$）。本练习将探索其离散对应关系：差分算子的交换性。通过实现分部求和（Summation-By-Parts, SBP）算子，你将数值验证以不同顺序应用导数会得到相同的结果（直至机器精度），从而揭示一致格式能够保持自由流的核心代数属性。",
            "id": "3961183",
            "problem": "考虑一个二维周期性计算域，其曲线坐标 $\\xi \\in [0,1)$ 和 $\\eta \\in [0,1)$ 通过光滑函数 $x(\\xi,\\eta)$ 和 $y(\\xi,\\eta)$ 映射到笛卡尔坐标。在没有数值不一致性的情况下，离散化应在此类曲线网格上保持均匀的自由流状态。一个关键要素是离散度量恒等式，它是对于足够光滑的函数，混合偏导数相等这一性质的离散对应物。您的任务是 (1) 在均匀周期性网格上构造形式阶为 $p$ 的一维分部求和 (SBP) 有限差分算子，(2) 使用它们为给定的映射计算离散度量导数，以及 (3) 以机器精度数值验证离散混合导数恒等式。\n\n从以下基本基础出发：\n- 对于足够光滑的函数，混合偏导数相等，即对于任何二阶连续可微函数 $f(\\xi,\\eta)$，有 $\\partial_\\xi \\partial_\\eta f = \\partial_\\eta \\partial_\\xi f$。\n- 在均匀周期性网格上使用一维线性差分算子对偏导数进行张量积离散化。\n\n定义与设置：\n- 分部求和 (Summation By Parts, SBP) 指的是一类在离散情况下模拟分部积分的有限差分算子。在本问题中，考虑通过在均匀网格上具有周期性边界条件的形式阶为 $p$ 的中心有限差分格式实现的 SBP 算子，因此一维一阶导数算子 $D$ 作为一个与对称奇数模板的循环卷积来作用。\n- 域为单位正方形，具有周期性边界：$\\xi \\in [0,1)$ 和 $\\eta \\in [0,1)$。\n- 令 $N_\\xi$ 和 $N_\\eta$ 分别表示 $\\xi$ 和 $\\eta$ 方向上的网格点数，令 $h_\\xi = 1/N_\\xi$ 和 $h_\\eta = 1/N_\\eta$ 为均匀间距。\n- 映射由以弧度为单位的角度给出：\n  $$x(\\xi,\\eta) = \\xi + \\alpha \\sin(2\\pi \\xi)\\sin(2\\pi \\eta), \\quad y(\\xi,\\eta) = \\eta + \\beta \\cos(2\\pi \\xi)\\sin(2\\pi \\eta).$$\n- 离散一阶导数 $x_\\xi$、$x_\\eta$、$y_\\xi$ 和 $y_\\eta$ 是通过沿相应轴应用一维 SBP 算子（具有周期性边界条件）来计算的。\n- 需要验证的离散混合导数恒等式是交换子残差为零\n  $$r_x = D_\\xi(D_\\eta x) - D_\\eta(D_\\xi x), \\quad r_y = D_\\xi(D_\\eta y) - D_\\eta(D_\\xi y),$$\n  在网格上求值，其中 $D_\\xi$ 和 $D_\\eta$ 分别表示沿 $\\xi$ 和 $\\eta$ 方向的离散一阶导数算子。\n\n任务：\n1. 构造形式阶为 $p \\in \\{2,4,6\\}$ 的周期性、中心 SBP 一阶导数算子作为一维格式。以张量积方式应用它们，为给定的二维数组计算沿各轴的离散导数。\n2. 对下面列出的每个测试用例，在网格上评估映射 $x(\\xi,\\eta)$ 和 $y(\\xi,\\eta)$，计算上面定义的离散残差场 $r_x$ 和 $r_y$，并报告无穷范数残差：\n   $$R = \\max\\left(\\|r_x\\|_\\infty, \\|r_y\\|_\\infty\\right).$$\n3. 所有三角函数求值均使用弧度角。不涉及物理单位。\n4. 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,r_3]$），其中每个条目是相应测试用例的浮点残差 $R$。\n\n测试套件：\n- 案例 1 (常规路径，中等振幅，中等网格): $p=2$, $N_\\xi=32$, $N_\\eta=32$, $\\alpha=0.1$, $\\beta=0.2$。\n- 案例 2 (更高阶，各向异性网格): $p=4$, $N_\\xi=64$, $N_\\eta=48$, $\\alpha=0.3$, $\\beta=0.25$。\n- 案例 3 (最高阶，更大各向异性): $p=6$, $N_\\xi=50$, $N_\\eta=70$, $\\alpha=0.4$, $\\beta=0.35$。\n- 案例 4 (边缘情况，由于周期性而支持六阶格式的最小网格): $p=6$, $N_\\xi=5$, $N_\\eta=5$, $\\alpha=0.9$, $\\beta=0.9$。\n- 案例 5 (边界情况，应产生精确抵消的平凡映射): $p=4$, $N_\\xi=40$, $N_\\eta=40$, $\\alpha=0.0$, $\\beta=0.0$。\n\n答案规格：\n- 对于每个案例，计算上面定义的标量浮点数 $R$，并以 $[R_1,R_2,R_3,R_4,R_5]$ 的精确格式输出包含五个浮点数的列表。",
            "solution": "该问题要求在二维周期性网格上，对给定的坐标变换进行离散混合导数恒等式的数值验证。该恒等式是关于混合偏导数相等的克莱罗定理 (Clairaut's theorem) 的离散模拟，该定理指出，对于具有连续二阶偏导数的函数 $f(\\xi,\\eta)$，有 $\\partial_\\xi \\partial_\\eta f = \\partial_\\eta \\partial_\\xi f$。此性质的数值验证对于确保数值格式能够在曲线网格上保持均匀自由流至关重要，这一特性被称为自由流保持特性。若不满足此条件，将在离散化的控制方程中引入伪源项，从而产生人为的力并破坏解的准确性。\n\n问题的核心在于均匀、周期性、张量积网格上的离散微分算子 $D_\\xi$ 和 $D_\\eta$ 的性质。问题指定使用中心分部求和 (SBP) 算子。对于周期性域，标准的中心有限差分格式就是 SBP 算子。一个作用于定义在点 $\\xi_i = i h$ 上的网格函数 $f_i$ 的形式阶为 $p$ 的一维一阶导数算子 $D$可以写成卷积形式：\n$$ (D f)_i = \\frac{1}{h} \\sum_{j=-p/2}^{p/2} c_j f_{i+j} $$\n其中索引 $i+j$ 对周期内的网格点数 $N$ 取模。格式系数 $c_j$ 是反对称的，即 $c_{-j} = -c_j$ 且 $c_0=0$。这些系数是通过将泰勒级数展开与精确的一阶导数匹配至所需的精度阶来确定的。对于阶数 $p=2, 4, 6$ 的中心格式，当 $j>0$ 时的非零系数为：\n- 对于 $p=2$: $c_1 = 1/2$。\n- 对于 $p=4$: $c_1 = 2/3$, $c_2 = -1/12$。\n- 对于 $p=6$: $c_1 = 3/4$, $c_2 = -3/20$, $c_3 = 1/60$。\n\n在二维张量积设置中，偏导数算子 $D_\\xi$ 和 $D_\\eta$ 是通过沿各自的轴应用一维算子来构造的。$D_\\xi$ 作用于每个 $\\eta=\\text{const.}$ 的线（行），而 $D_\\eta$ 作用于每个 $\\xi=\\text{const.}$ 的线（列）。这些算子一个至关重要的性质是它们是可交换的，这源于它们在周期性网格上作为卷积的结构。设 $F$ 为定义在 $(\\xi_{j}, \\eta_{i})$ 网格上的任意二维网格函数。连续求导的应用可以写为：\n$$ (D_\\xi (D_\\eta F))_{i,j} = \\frac{1}{h_\\xi} \\sum_{k} c_k (D_\\eta F)_{i, j+k} = \\frac{1}{h_\\xi} \\sum_{k} c_k \\left( \\frac{1}{h_\\eta} \\sum_{l} c_l F_{i+l, j+k} \\right) = \\frac{1}{h_\\xi h_\\eta} \\sum_{k,l} c_k c_l F_{i+l, j+k} $$\n$$ (D_\\eta (D_\\xi F))_{i,j} = \\frac{1}{h_\\eta} \\sum_{l} c_l (D_\\xi F)_{i+l, j} = \\frac{1}{h_\\eta} \\sum_{l} c_l \\left( \\frac{1}{h_\\xi} \\sum_{k} c_k F_{i+l, j+k} \\right) = \\frac{1}{h_\\eta h_\\xi} \\sum_{l,k} c_l c_k F_{i+l, j+k} $$\n由于求和是有限的，并且求和顺序可以互换，因此很明显对于所有点 $(i,j)$ 都有 $(D_\\xi (D_\\eta F))_{i,j} = (D_\\eta (D_\\xi F))_{i,j}$。这意味着算子交换子恒等于零：$D_\\xi D_\\eta - D_\\eta D_\\xi = 0$。\n\n因此，无论网格函数、网格分辨率或算子阶数如何，残差场 $r_x = D_\\xi(D_\\eta x) - D_\\eta(D_\\xi x)$ 和 $r_y = D_\\xi(D_\\eta y) - D_\\eta(D_\\xi y)$ 都必须解析地为零。于是，该问题简化为一个数值验证练习。我们预计，由于浮点舍入误差的累积，计算出的残差不为零，但其数量级应为机器精度（对于标准双精度算術，通常为 $10^{-14}$ 到 $10^{-16}$）。\n\n每个测试用例的计算过程如下：\n1.  给定参数 $p, N_\\xi, N_\\eta, \\alpha, \\beta$，构造 $\\xi$ 和 $\\eta$ 的均匀周期性网格。网格点为 $\\xi_j = j h_\\xi$（其中 $j \\in \\{0, \\dots, N_\\xi-1\\}$）和 $\\eta_i = i h_\\eta$（其中 $i \\in \\{0, \\dots, N_\\eta-1\\}$），且 $h_\\xi=1/N_\\xi$ 和 $h_\\eta=1/N_\\eta$。\n2.  在每个网格点上评估映射函数 $x(\\xi,\\eta)$ 和 $y(\\xi,\\eta)$ 以获得离散坐标场。\n3.  为给定的阶数 $p$ 选择合适的有限差分格式系数。\n4.  实现微分算子 $D_\\xi$ 和 $D_\\eta$。这通过沿二维数据数组的适当轴应用一维格式，并利用边界上的周期性环绕来实现。`numpy.roll` 函数非常适合此任务。\n5.  通过以两种不同顺序应用导数算子并求其差值来计算残差场 $r_x$ 和 $r_y$。\n6.  计算每个残差场的无穷范数 $\\| \\cdot \\|_\\infty$（最大绝对值），并报告这两个范数的最大值，$R = \\max\\left(\\|r_x\\|_\\infty, \\|r_y\\|_\\infty\\right)$。该值表示验证离散混合导数恒等式时的数值误差。即使对于案例 4，其中六阶格式的宽度（7 个点）大于网格点数（5），通过卷积对格式进行周期性应用仍然是良定义的，且交换律性质仍然成立。对于案例 5，其中 $\\alpha=\\beta=0$，坐标函数是线性的，抵消应该是精确的，导致残差为 $0.0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_stencil_coeffs(p: int) -> list[float]:\n    \"\"\"\n    Returns the coefficients for a centered, periodic SBP first-derivative operator.\n    Coefficients c_j for j > 0 are returned. c_0=0 and c_{-j}=-c_j.\n    \"\"\"\n    if p == 2:\n        # Order 2: [ ... 0, -1/2, 0, 1/2, 0 ... ]\n        return [1/2]\n    elif p == 4:\n        # Order 4: [ ... -1/12, 2/3, 0, -2/3, 1/12, ... ]\n        return [2/3, -1/12]\n    elif p == 6:\n        # Order 6: [ ... 1/60, -3/20, 3/4, 0, -3/4, 3/20, -1/60, ... ]\n        return [3/4, -3/20, 1/60]\n    else:\n        raise ValueError(f\"Unsupported order p={p}. Must be 2, 4, or 6.\")\n\ndef apply_derivative(data: np.ndarray, axis: int, h: float, coeffs: list[float]) -> np.ndarray:\n    \"\"\"\n    Applies a 1D finite-difference operator along a specified axis of a 2D array.\n    \"\"\"\n    deriv = np.zeros_like(data, dtype=float)\n    for i, c in enumerate(coeffs):\n        k = i + 1  # Stencil half-width\n        deriv += c * (np.roll(data, -k, axis=axis) - np.roll(data, k, axis=axis))\n    return deriv / h\n\ndef compute_residual_for_grid(grid_func: np.ndarray, h_xi: float, h_eta: float, coeffs: list[float]) -> np.ndarray:\n    \"\"\"\n    Computes the commutator residual D_xi(D_eta(f)) - D_eta(D_xi(f)).\n    Assumes numpy 'xy' indexing: xi is axis 1, eta is axis 0.\n    \"\"\"\n    xi_axis = 1\n    eta_axis = 0\n\n    # Path 1: D_xi(D_eta(f))\n    df_deta = apply_derivative(grid_func, axis=eta_axis, h=h_eta, coeffs=coeffs)\n    d2f_dxideta = apply_derivative(df_deta, axis=xi_axis, h=h_xi, coeffs=coeffs)\n    \n    # Path 2: D_eta(D_xi(f))\n    df_dxi = apply_derivative(grid_func, axis=xi_axis, h=h_xi, coeffs=coeffs)\n    d2f_detadxi = apply_derivative(df_dxi, axis=eta_axis, h=h_eta, coeffs=coeffs)\n    \n    return d2f_dxideta - d2f_detadxi\n\ndef calculate_max_residual(p: int, N_xi: int, N_eta: int, alpha: float, beta: float) -> float:\n    \"\"\"\n    Calculates the maximum infinity norm of the commutator residuals for x and y.\n    \"\"\"\n    h_xi = 1.0 / N_xi\n    h_eta = 1.0 / N_eta\n\n    xi_1d = np.linspace(0, 1, N_xi, endpoint=False)\n    eta_1d = np.linspace(0, 1, N_eta, endpoint=False)\n    \n    # Use 'xy' indexing for meshgrid. This means:\n    # XI has shape (N_eta, N_xi) and varies along axis 1 (columns).\n    # ETA has shape (N_eta, N_xi) and varies along axis 0 (rows).\n    XI, ETA = np.meshgrid(xi_1d, eta_1d, indexing='xy')\n\n    # Evaluate the mapping functions on the grid\n    x_grid = XI + alpha * np.sin(2 * np.pi * XI) * np.sin(2 * np.pi * ETA)\n    y_grid = ETA + beta * np.cos(2 * np.pi * XI) * np.sin(2 * np.pi * ETA)\n\n    coeffs = get_stencil_coeffs(p)\n    \n    # Compute commutator residuals for x and y coordinates\n    r_x = compute_residual_for_grid(x_grid, h_xi, h_eta, coeffs)\n    r_y = compute_residual_for_grid(y_grid, h_xi, h_eta, coeffs)\n\n    # Calculate the final residual R as the max of the infinity norms\n    norm_rx_inf = np.max(np.abs(r_x))\n    norm_ry_inf = np.max(np.abs(r_y))\n    \n    R = max(norm_rx_inf, norm_ry_inf)\n    \n    return R\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (p, N_xi, N_eta, alpha, beta)\n        (2, 32, 32, 0.1, 0.2),\n        (4, 64, 48, 0.3, 0.25),\n        (6, 50, 70, 0.4, 0.35),\n        (6, 5, 5, 0.9, 0.9),\n        (4, 40, 40, 0.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        p, N_xi, N_eta, alpha, beta = case\n        result = calculate_max_residual(p, N_xi, N_eta, alpha, beta)\n        results.append(result)\n\n    # Format the output as a comma-separated list of floats inside brackets.\n    # Use high-precision scientific notation to show the small magnitude of the residuals.\n    print(f\"[{','.join(f'{r:.16e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这项实践将所有概念整合到一个真实的CFD场景中。你将把这些原理应用于完整的可压缩欧拉方程。通过实现一个“一致的”和一个“不一致的”离散化方案，你将直接观察并量化其结果：一致的格式完美地保持了均匀流，而不一致的格式则产生了伪误差。这个练习突显了在实际模拟中满足离散几何守恒律的至关重要性。",
            "id": "3961220",
            "problem": "您需要为计算流体动力学（CFD）中的二维曲线网格上的自由流保持问题实现一个构造解测试。目标是从第一性原理出发，验证当通过一致的差分格式保持离散度量恒等式时，可压缩欧拉方程的常数状态会产生一个等于数值舍入误差（机器零）的离散残差。反之，您将展示当散度算子与用于计算网格度量的算子不一致时，自由流保持性会丧失。\n\n推导应基于以下基本定律和核心定义：\n- 在从物理空间变量 $(x,y)$ 到计算空间变量 $(\\xi,\\eta)$ 的光滑映射下，守恒形式的二维可压缩欧拉方程变换为\n$$\n\\frac{\\partial}{\\partial t}\\left(J \\mathbf{U}\\right) + \\frac{\\partial}{\\partial \\xi} \\left(\\widehat{\\mathbf{F}}\\right) + \\frac{\\partial}{\\partial \\eta} \\left(\\widehat{\\mathbf{G}}\\right) = \\mathbf{0},\n$$\n其中 $J$ 是映射的雅可比行列式，$\\mathbf{U}$ 是守恒变量向量，$\\widehat{\\mathbf{F}}, \\widehat{\\mathbf{G}}$ 是逆变通量。\n- 逆变通量可以使用度量恒等式向量\n$$\n\\mathbf{a}^{1} = \\left(y_{\\eta},\\, -x_{\\eta}\\right), \\quad \\mathbf{a}^{2} = \\left(-y_{\\xi},\\, x_{\\xi}\\right),\n$$\n写为\n$$\n\\widehat{\\mathbf{F}} = y_{\\eta}\\,\\mathbf{F} - x_{\\eta}\\,\\mathbf{G}, \\quad \\widehat{\\mathbf{G}} = -y_{\\xi}\\,\\mathbf{F} + x_{\\xi}\\,\\mathbf{G},\n$$\n其中 $\\mathbf{F}$ 和 $\\mathbf{G}$ 是 $x$ 和 $y$ 方向的物理通量。\n- 度量恒等式意味着\n$$\n\\frac{\\partial \\mathbf{a}^{1}}{\\partial \\xi} + \\frac{\\partial \\mathbf{a}^{2}}{\\partial \\eta} = \\mathbf{0}.\n$$\n- 对于常数状态 $\\mathbf{U}=\\text{const}$，物理通量 $\\mathbf{F}, \\mathbf{G}$ 是常数，因此连续残差简化为度量加权常数的散度，如果度量恒等式成立，该散度为零。\n\n您必须使用由光滑映射定义的周期性逻辑矩形网格\n$$\nx(\\xi,\\eta) = \\xi + \\alpha \\sin\\!\\left(2\\pi \\xi\\right)\\sin\\!\\left(2\\pi \\eta\\right), \\quad\ny(\\xi,\\eta) = \\eta + \\beta \\sin\\!\\left(2\\pi \\xi\\right)\\sin\\!\\left(2\\pi \\eta\\right),\n$$\n其中 $\\xi,\\eta \\in [0,1)$，网格分辨率为整数 $N \\times N$，并具有周期性环绕。所有量均为无量纲；不需要物理单位。\n\n实现以下离散算子和状态：\n- 在计算网格度量 $x_{\\xi}, x_{\\eta}, y_{\\xi}, y_{\\eta}$ 时，使用带周期性环绕的二阶中心差分来近似 $\\partial/\\partial \\xi$ 和 $\\partial/\\partial \\eta$。\n- 根据度量项和可压缩欧拉方程的常数物理通量构建逆变通量 $\\widehat{\\mathbf{F}}, \\widehat{\\mathbf{G}}$。\n- 对于“一致”格式，使用与计算度量相同的中心差分算子来计算逆变通量的散度。\n- 对于“不一致”格式，使用单边差分（$\\xi$ 方向向前，$\\eta$ 方向向后）计算散度，而度量仍然使用中心差分计算。\n\n定义常数状态如下：取恒定密度 $\\rho = 1$，速度 $u = 0.5$, $v = -0.2$，压力 $p = 1$，比热比 $\\gamma = 1.4$。计算单位体积总能量 $\\rho E = \\dfrac{p}{\\gamma - 1} + \\dfrac{1}{2}\\rho\\left(u^{2}+v^{2}\\right)$，并由此得到守恒向量 $\\mathbf{U} = \\left[\\rho,\\, \\rho u,\\, \\rho v,\\, \\rho E\\right]^{\\top}$。物理通量为\n$$\n\\mathbf{F} = \\begin{bmatrix}\n\\rho u\\\\\n\\rho u^{2} + p\\\\\n\\rho u v\\\\\nu(\\rho E + p)\n\\end{bmatrix}, \\quad\n\\mathbf{G} = \\begin{bmatrix}\n\\rho v\\\\\n\\rho u v\\\\\n\\rho v^{2} + p\\\\\nv(\\rho E + p)\n\\end{bmatrix}.\n$$\n\n您的程序必须计算离散残差\n$$\n\\mathcal{R} = D_{\\xi}\\left(\\widehat{\\mathbf{F}}\\right) + D_{\\eta}\\left(\\widehat{\\mathbf{G}}\\right),\n$$\n该残差逐分量应用于所有网格点上的每个守恒量，其中 $D_{\\xi}, D_{\\eta}$ 表示所选的离散导数算子。对于每个测试案例，报告在所有网格点和所有守恒变量上的最大绝对值：\n$$\n\\left\\|\\mathcal{R}\\right\\|_{\\infty} = \\max_{i,j,q} \\left| \\mathcal{R}_{q}(i,j) \\right|.\n$$\n\n测试套件和必需输出：\n- 在您的程序内部实现以下四个测试案例作为固定的测试套件。每个案例由元组 $\\left(N, \\alpha, \\beta, \\text{scheme}\\right)$ 指定：\n    - 案例 1：$\\left(N=64,\\, \\alpha=0.2,\\, \\beta=0.1,\\, \\text{scheme}=\\text{consistent}\\right)$。\n    - 案例 2：$\\left(N=64,\\, \\alpha=0.2,\\, \\beta=0.1,\\, \\text{scheme}=\\text{inconsistent}\\right)$。\n    - 案例 3：$\\left(N=32,\\, \\alpha=0.0,\\, \\beta=0.0,\\, \\text{scheme}=\\text{inconsistent}\\right)$。\n    - 案例 4：$\\left(N=50,\\, \\alpha=0.12,\\, \\beta=0.22,\\, \\text{scheme}=\\text{consistent}\\right)$。\n- 对于每个案例，计算如上定义的单个浮点数 $\\left\\|\\mathcal{R}\\right\\|_{\\infty}$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$\\left[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3},\\text{result}_{4}\\right]$）。所有输出均为无量纲实数。\n\n约束和科学真实性：\n- 对所有离散导数一致使用周期性边界条件。\n- 确保在“一致”格式中，度量评估中使用的相同离散算子也用于散度计算，以测试几何守恒和度量恒等式保持。\n- 仅使用代数定义的操作；不要使用任何外部文件输入或随机性。在给定双精度算术的情况下，结果应能精确复现。",
            "solution": "该问题陈述是计算流体动力学（CFD）领域一个有效且适定的数值验证练习。它在科学上植根于连续介质力学和数值分析的原理，特别是关于在曲线坐标系上离散化可压缩欧拉方程的问题。所有必要的数据、方程和边界条件都已提供，不存在矛盾或模糊之处。\n\n被测试的核心原理是**自由流保持**，这是**几何守恒律（GCL）**的直接结果。如果一个求解欧拉方程的数值格式能够精确地（达到机器精度水平）维持一个均匀流场（恒定的密度 $\\rho$、速度分量 $u$ 和 $v$、以及压力 $p$），则称该格式保持自由流。这是任何可靠CFD求解器的基本要求，因为它确保了网格的曲率或离散化过程本身不会引入虚假的、非物理的源或汇。\n\n我们从二维可压缩欧拉方程的守恒形式开始，它从物理坐标 $(x,y)$ 变换到计算坐标 $(\\xi,\\eta)$：\n$$\n\\frac{\\partial}{\\partial t}\\left(J \\mathbf{U}\\right) + \\frac{\\partial}{\\partial \\xi} \\left(\\widehat{\\mathbf{F}}\\right) + \\frac{\\partial}{\\partial \\eta} \\left(\\widehat{\\mathbf{G}}\\right) = \\mathbf{0}\n$$\n这里，$\\mathbf{U} = \\left[\\rho, \\rho u, \\rho v, \\rho E\\right]^{\\top}$ 是守恒变量向量，$\\widehat{\\mathbf{F}}$ 和 $\\widehat{\\mathbf{G}}$ 是逆变通量向量。它们通过变换度量与物理笛卡尔通量 $\\mathbf{F}$ 和 $\\mathbf{G}$ 相关联：\n$$\n\\widehat{\\mathbf{F}} = y_{\\eta}\\,\\mathbf{F} - x_{\\eta}\\,\\mathbf{G}\n$$\n$$\n\\widehat{\\mathbf{G}} = -y_{\\xi}\\,\\mathbf{F} + x_{\\xi}\\,\\mathbf{G}\n$$\n其中 $x_{\\xi} = \\frac{\\partial x}{\\partial \\xi}$，$y_{\\eta} = \\frac{\\partial y}{\\partial \\eta}$，依此类推。\n\n对于一个稳定的、均匀的自由流，状态向量 $\\mathbf{U}$ 在整个域中是常数。因此，物理通量 $\\mathbf{F}(\\mathbf{U})$ 和 $\\mathbf{G}(\\mathbf{U})$ 也是常数向量。变换后的欧拉方程的稳态残差为：\n$$\n\\mathcal{R}_c = \\frac{\\partial}{\\partial \\xi} \\left(\\widehat{\\mathbf{F}}\\right) + \\frac{\\partial}{\\partial \\eta} \\left(\\widehat{\\mathbf{G}}\\right) = \\frac{\\partial}{\\partial \\xi} \\left(y_{\\eta}\\,\\mathbf{F} - x_{\\eta}\\,\\mathbf{G}\\right) + \\frac{\\partial}{\\partial \\eta} \\left(-y_{\\xi}\\,\\mathbf{F} + x_{\\xi}\\,\\mathbf{G}\\right)\n$$\n由于 $\\mathbf{F}$ 和 $\\mathbf{G}$ 是常数，我们可以应用乘积法则并重新排列：\n$$\n\\mathcal{R}_c = \\left( \\frac{\\partial y_{\\eta}}{\\partial \\xi} - \\frac{\\partial y_{\\xi}}{\\partial \\eta} \\right) \\mathbf{F} + \\left( \\frac{\\partial x_{\\xi}}{\\partial \\eta} - \\frac{\\partial x_{\\eta}}{\\partial \\xi} \\right) \\mathbf{G}\n$$\n对于任何光滑的坐标变换 $x(\\xi, \\eta), y(\\xi, \\eta)$，微分的顺序无关紧要（Clairaut关于混合偏导数相等的定理），这意味着：\n$$\n\\frac{\\partial^2 y}{\\partial \\xi \\partial \\eta} = \\frac{\\partial^2 y}{\\partial \\eta \\partial \\xi} \\implies \\frac{\\partial y_{\\eta}}{\\partial \\xi} = \\frac{\\partial y_{\\xi}}{\\partial \\eta}\n$$\n$$\n\\frac{\\partial^2 x}{\\partial \\eta \\partial \\xi} = \\frac{\\partial^2 x}{\\partial \\xi \\partial \\eta} \\implies \\frac{\\partial x_{\\xi}}{\\partial \\eta} = \\frac{\\partial x_{\\eta}}{\\partial \\xi}\n$$\n这些是**度量恒等式**。将它们代入残差表达式表明 $\\mathcal{R}_c = \\mathbf{0}$。这证实了均匀自由流是连续变换方程的精确解。\n\n核心挑战出现在离散域中。令 $D_{\\xi}$ 和 $D_{\\eta}$ 为近似通量散度项中偏导数的离散算子，令 $d_{\\xi}$ 和 $d_{\\eta}$ 为用于计算网格度量的离散算子。网格点 $(i,j)$ 处的离散稳态残差为：\n$$\n\\mathcal{R}_{ij} = D_{\\xi}(\\widehat{\\mathbf{F}}_{ij}) + D_{\\eta}(\\widehat{\\mathbf{G}}_{ij})\n$$\n代入用算子 $d_{\\xi}$ 和 $d_{\\eta}$ 导出的度量计算的离散通量表达式，我们有：\n$$\n\\mathcal{R}_{ij} = D_{\\xi}\\left( (d_{\\eta}y)_{ij}\\,\\mathbf{F} - (d_{\\eta}x)_{ij}\\,\\mathbf{G} \\right) + D_{\\eta}\\left( -(d_{\\xi}y)_{ij}\\,\\mathbf{F} + (d_{\\xi}x)_{ij}\\,\\mathbf{G} \\right)\n$$\n由于 $\\mathbf{F}$ 和 $\\mathbf{G}$ 仍然是常数向量，这简化为：\n$$\n\\mathcal{R}_{ij} = \\left[ D_{\\xi}((d_{\\eta}y)_{ij}) - D_{\\eta}((d_{\\xi}y)_{ij}) \\right] \\mathbf{F} + \\left[ D_{\\eta}((d_{\\xi}x)_{ij}) - D_{\\xi}((d_{\\eta}x)_{ij}) \\right] \\mathbf{G}\n$$\n为使残差 $\\mathcal{R}_{ij}$ 为零，方括号中的项必须为零。这就是**离散几何守恒律（GCL）**：\n$$\nD_{\\xi}(d_{\\eta}y) - D_{\\eta}(d_{\\xi}y) = 0 \\quad \\text{and} \\quad D_{\\eta}(d_{\\xi}x) - D_{\\xi}(d_{\\eta}x) = 0\n$$\n如果离散算子选择一致，即 $D_{\\xi} = d_{\\xi}$ 和 $D_{\\eta} = d_{\\eta}$，并且算子具有伸缩求和性质（如中心差分），则该定律得到满足。如果算子不一致（例如，度量用中心差分 $d_{\\xi, \\eta}$ 计算，而散度用单边差分 $D_{\\xi, \\eta}$ 计算），GCL 将被违反，残差 $\\mathcal{R}_{ij}$ 将不为零，其大小与GCL表达式的截断误差成正比。这表现为自由流保持误差。\n\n实现将按以下步骤进行：\n1.  对于每个测试案例，根据给定的映射函数生成 $N \\times N$ 周期性网格坐标 $(x_{ij}, y_{ij})$。计算网格间距为 $\\Delta\\xi = \\Delta\\eta = 1/N$。\n2.  定义恒定的自由流状态。给定 $\\rho = 1$，$u = 0.5$，$v = -0.2$，$p = 1$，以及 $\\gamma = 1.4$。单位体积总能量为 $\\rho E = \\frac{p}{\\gamma - 1} + \\frac{1}{2}\\rho(u^2 + v^2)$。然后计算常数物理通量向量 $\\mathbf{F}$ 和 $\\mathbf{G}$。\n3.  对所有案例，使用二阶周期性中心差分计算网格度量项数组 $(x_{\\xi})_{ij}, (x_{\\eta})_{ij}, (y_{\\xi})_{ij}, (y_{\\eta})_{ij}$。\n    $$\n    (d_{\\xi}f)_{ij} = \\frac{f_{i+1,j} - f_{i-1,j}}{2 \\Delta\\xi}, \\quad (d_{\\eta}f)_{ij} = \\frac{f_{i,j+1} - f_{i,j-1}}{2 \\Delta\\eta}\n    $$\n4.  通过将度量数组与常数 $\\mathbf{F}$ 和 $\\mathbf{G}$ 向量组合，计算逆变通量数组 $\\widehat{\\mathbf{F}}_{ij}$ 和 $\\widehat{\\mathbf{G}}_{ij}$。\n5.  根据格式类型计算离散残差 $\\mathcal{R}_{ij}$：\n    - **一致格式**：对 $D_{\\xi}$ 和 $D_{\\eta}$ 使用相同的中心差分算子。\n    - **不一致格式**：对 $D_{\\xi}$ 使用周期性向前差分，对 $D_{\\eta}$ 使用周期性向后差分。\n        $$\n        (D_{\\xi}f)_{ij} = \\frac{f_{i+1,j} - f_{ij}}{\\Delta\\xi}, \\quad (D_{\\eta}f)_{ij} = \\frac{f_{ij} - f_{i,j-1}}{\\Delta\\eta}\n        $$\n6.  计算残差的无穷范数 $\\left\\|\\mathcal{R}\\right\\|_{\\infty} = \\max_{i,j,q} \\left| \\mathcal{R}_{q}(i,j) \\right|$，即在所有网格点和所有四个守恒变量上的最大绝对值。\n\n一个特殊情况是笛卡尔网格（$\\alpha = 0, \\beta = 0$），其中 $x_{ij}=\\xi_i$ 和 $y_{ij}=\\eta_j$。在这里，度量是常数：$(x_{\\xi})_{ij}=1, (y_{\\eta})_{ij}=1, (x_{\\eta})_{ij}=0, (y_{\\xi})_{ij}=0$。这导致 $\\widehat{\\mathbf{F}}_{ij}=\\mathbf{F}$ 和 $\\widehat{\\mathbf{G}}_{ij}=\\mathbf{G}$。由于逆变通量本身是常数场，任何一致的差分格式（中心、向前或向后）都将产生零导数。因此，即使是“不一致”的格式也会在这种特定情况下保持自由流，因为GCL违反项乘以了值为零的度量导数。这在案例3中得到验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a manufactured solution test for freestream preservation\n    on two-dimensional curvilinear grids in Computational Fluid Dynamics (CFD).\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (64, 0.2, 0.1, 'consistent'),\n        (64, 0.2, 0.1, 'inconsistent'),\n        (32, 0.0, 0.0, 'inconsistent'),\n        (50, 0.12, 0.22, 'consistent'),\n    ]\n\n    # Freestream state parameters\n    rho = 1.0\n    u = 0.5\n    v = -0.2\n    p = 1.0\n    gamma = 1.4\n\n    # Compute derived quantities for the freestream state\n    rho_u = rho * u\n    rho_v = rho * v\n    rho_E = p / (gamma - 1.0) + 0.5 * rho * (u**2 + v**2)\n    u_h = rho_E + p # Specific enthalpy u(rho_E+p) uses u, not rho_u\n\n    # Construct the constant physical flux vectors F and G\n    F = np.array([\n        rho_u,\n        rho_u * u + p,\n        rho_u * v,\n        u * (rho_E + p)\n    ])\n\n    G = np.array([\n        rho_v,\n        rho_v * u,\n        rho_v * v + p,\n        v * (rho_E + p)\n    ])\n\n    results = []\n    for N, alpha, beta, scheme in test_cases:\n        # 1. Grid Generation\n        # Computational coordinates xi, eta in [0, 1)\n        xi_1d = np.linspace(0.0, 1.0, N, endpoint=False)\n        eta_1d = np.linspace(0.0, 1.0, N, endpoint=False)\n        # Meshgrid indexing 'ij' ensures that the first index corresponds to xi\n        XI, ETA = np.meshgrid(xi_1d, eta_1d, indexing='ij')\n\n        # Physical coordinates x, y\n        common_term = np.sin(2.0 * np.pi * XI) * np.sin(2.0 * np.pi * ETA)\n        X = XI + alpha * common_term\n        Y = ETA + beta * common_term\n\n        # Grid spacing\n        delta_xi = 1.0 / N\n        delta_eta = 1.0 / N\n\n        # 2. Metric Computation (Second-Order Central Differences)\n        # Use np.roll for periodic boundary conditions\n        # d/dxi ~ (f_{i+1} - f_{i-1}) / (2 * delta_xi)\n        x_xi = (np.roll(X, -1, axis=0) - np.roll(X, 1, axis=0)) / (2.0 * delta_xi)\n        y_xi = (np.roll(Y, -1, axis=0) - np.roll(Y, 1, axis=0)) / (2.0 * delta_xi)\n        \n        # d/deta ~ (f_{j+1} - f_{j-1}) / (2 * delta_eta)\n        x_eta = (np.roll(X, -1, axis=1) - np.roll(X, 1, axis=1)) / (2.0 * delta_eta)\n        y_eta = (np.roll(Y, -1, axis=1) - np.roll(Y, 1, axis=1)) / (2.0 * delta_eta)\n\n        # 3. Contravariant Flux Computation\n        # F_hat = y_eta * F - x_eta * G\n        # G_hat = -y_xi * F + x_xi * G\n        # Use broadcasting to multiply (N, N) metric arrays with (4,) flux vectors\n        # Resulting flux arrays have shape (N, N, 4)\n        F_hat = y_eta[..., np.newaxis] * F - x_eta[..., np.newaxis] * G\n        G_hat = -y_xi[..., np.newaxis] * F + x_xi[..., np.newaxis] * G\n\n        # 4. Residual Calculation\n        if scheme == 'consistent':\n            # Central differences for divergence (same as for metrics)\n            dF_hat_dxi = (np.roll(F_hat, -1, axis=0) - np.roll(F_hat, 1, axis=0)) / (2.0 * delta_xi)\n            dG_hat_deta = (np.roll(G_hat, -1, axis=1) - np.roll(G_hat, 1, axis=1)) / (2.0 * delta_eta)\n        elif scheme == 'inconsistent':\n            # Forward difference in xi, backward difference in eta\n            dF_hat_dxi = (np.roll(F_hat, -1, axis=0) - F_hat) / delta_xi\n            dG_hat_deta = (G_hat - np.roll(G_hat, 1, axis=1)) / delta_eta\n        else:\n            raise ValueError(\"Unknown scheme type\")\n            \n        Residual = dF_hat_dxi + dG_hat_deta\n\n        # 5. Norm Calculation\n        # max absolute value over all grid points and all 4 conserved variables\n        inf_norm = np.max(np.abs(Residual))\n        results.append(inf_norm)\n\n    # Final print statement in the exact required format.\n    # Convert results to string with sufficient precision\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}