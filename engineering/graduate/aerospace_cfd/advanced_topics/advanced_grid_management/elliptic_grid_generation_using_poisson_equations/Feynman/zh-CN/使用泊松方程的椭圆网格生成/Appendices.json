{
    "hands_on_practices": [
        {
            "introduction": "网格质量是计算流体动力学 (CFD) 模拟精度的关键决定因素之一，而正交性是衡量网格质量的重要指标。此练习将引导您从第一性原理出发，通过分析从计算域到物理域的坐标映射，推导出检验网格线是否正交的精确数学条件 。通过完成这个基础推导，您将深刻理解网格的几何特性（如正交性）是如何与坐标变换函数的偏导数直接关联的，并掌握一个评估和诊断网格质量的基本解析工具。",
            "id": "3313536",
            "problem": "考虑一个从坐标为 $\\xi$ 和 $\\eta$ 的计算域到坐标为 $x$ 和 $y$ 的物理域的光滑、双射的平面映射，由位置向量 $\\mathbf{r}(\\xi,\\eta) = \\big(x(\\xi,\\eta), y(\\xi,\\eta)\\big)$ 定义。在使用泊松方程的椭圆网格生成中，通过求解形式为 $x_{\\xi\\xi} + x_{\\eta\\eta} = P(\\xi,\\eta)$ 和 $y_{\\xi\\xi} + y_{\\eta\\eta} = Q(\\xi,\\eta)$ 的椭圆偏微分方程来构造此类映射，其中 $P$ 和 $Q$ 是为调节网格光滑度和间距而选择的光滑控制函数。从 $\\mathbb{R}^{2}$ 中的欧几里得内积和曲线坐标的协变基向量的定义出发，推导坐标线 $\\xi=\\text{constant}$ 和 $\\eta=\\text{constant}$ 在物理平面上正交的充要条件，该条件应完全用 $x(\\xi,\\eta)$ 和 $y(\\xi,\\eta)$ 的偏导数表示。然后，对于特定映射 $x(\\xi,\\eta) = \\xi$ 和 $y(\\xi,\\eta) = \\eta^{2}$，在一般点 $(\\xi,\\eta)$ 处计算从您推导的条件中得到的正交性诊断量，以评估正交性是否保持或丧失。最终答案必须是计算出的诊断值，形式为单个实数或单个闭式表达式，无需单位，也无需四舍五入。",
            "solution": "该问题要求推导平面映射中坐标线正交的充要条件，并随后将此条件应用于一个特定的变换。\n\n首先，我们推导正交性的一般条件。从具有曲线坐标 $(\\xi, \\eta)$ 的计算域到具有笛卡尔坐标 $(x, y)$ 的物理域的映射由位置向量 $\\mathbf{r}(\\xi, \\eta) = x(\\xi, \\eta)\\mathbf{i} + y(\\xi, \\eta)\\mathbf{j}$ 定义。用分量形式表示，我们写作 $\\mathbf{r} = \\big(x(\\xi, \\eta), y(\\xi, \\eta)\\big)$。\n\n物理平面中的坐标线是计算平面中直线 $\\xi = \\text{constant}$ 和 $\\eta = \\text{constant}$ 的像。\n对应于 $\\eta = \\text{constant}$ 的曲线的切向量通过对位置向量 $\\mathbf{r}$ 关于 $\\xi$ 求导得到。此向量是协变基向量 $\\mathbf{g}_{\\xi}$：\n$$\n\\mathbf{g}_{\\xi} = \\frac{\\partial \\mathbf{r}}{\\partial \\xi} = \\left(\\frac{\\partial x}{\\partial \\xi}, \\frac{\\partial y}{\\partial \\xi}\\right) = (x_{\\xi}, y_{\\xi})\n$$\n类似地，对应于 $\\xi = \\text{constant}$ 的曲线的切向量通过对 $\\mathbf{r}$ 关于 $\\eta$ 求导得到。此向量是协变基向量 $\\mathbf{g}_{\\eta}$：\n$$\n\\mathbf{g}_{\\eta} = \\frac{\\partial \\mathbf{r}}{\\partial \\eta} = \\left(\\frac{\\partial x}{\\partial \\eta}, \\frac{\\partial y}{\\partial \\eta}\\right) = (x_{\\eta}, y_{\\eta})\n$$\n在欧几里得平面中，两个向量正交的充要条件是它们的内积（点积）为零。因此，坐标线在某一点正交的充要条件是它们在该点的切向量正交。这表示为：\n$$\n\\mathbf{g}_{\\xi} \\cdot \\mathbf{g}_{\\eta} = 0\n$$\n将基向量的分量表达式代入，我们得到用映射函数的偏导数表示的正交性条件：\n$$\n(x_{\\xi}, y_{\\xi}) \\cdot (x_{\\eta}, y_{\\eta}) = x_{\\xi}x_{\\eta} + y_{\\xi}y_{\\eta} = 0\n$$\n表达式 $x_{\\xi}x_{\\eta} + y_{\\xi}y_{\\eta}$ 作为问题中要求的“正交性诊断量”。其值决定了正交性是否得以保持。此项对应于变换的度量张量的非对角元 $g_{12}$ 和 $g_{21}$。一个对角化的度量张量（$g_{12}=g_{21}=0$）表示一个正交坐标系。\n\n接下来，我们将此条件应用于给定的特定映射：\n$$\nx(\\xi, \\eta) = \\xi\n$$\n$$\ny(\\xi, \\eta) = \\eta^{2}\n$$\n我们必须首先计算 $x$ 和 $y$ 关于 $\\xi$ 和 $\\eta$ 的四个一阶偏导数：\n$$\nx_{\\xi} = \\frac{\\partial}{\\partial \\xi}(\\xi) = 1\n$$\n$$\nx_{\\eta} = \\frac{\\partial}{\\partial \\eta}(\\xi) = 0\n$$\n$$\ny_{\\xi} = \\frac{\\partial}{\\partial \\xi}(\\eta^{2}) = 0\n$$\n$$\ny_{\\eta} = \\frac{\\partial}{\\partial \\eta}(\\eta^{2}) = 2\\eta\n$$\n现在，我们将这些导数代入正交性诊断表达式中：\n$$\nx_{\\xi}x_{\\eta} + y_{\\xi}y_{\\eta} = (1)(0) + (0)(2\\eta)\n$$\n计算此表达式，我们发现：\n$$\n0 + 0 = 0\n$$\n正交性诊断量的值在域中所有点 $(\\xi, \\eta)$ 处恒等于 $0$。这表明对于这个特定映射，坐标线处处正交。从几何上看，常数 $\\xi$ 线映射为垂线 $x = \\text{constant}$，而常数 $\\eta$ 线映射为水平线 $y = (\\text{constant})^{2}$。由垂线和水平线组成的网格根据定义是正交网格。\n\n最终答案是计算出的正交性诊断表达式的值。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "在使用泊松方程生成网格时，一个核心挑战是如何在利用控制函数 $P$ 和 $Q$ 实现网格点精确聚类的同时，避免因过度拉伸或压缩而导致的网格“折叠”。本实践练习将带您构建一个完整的自适应算法，该算法在迭代求解泊松方程的过程中持续监控变换的雅可比行列式 $J$ 。通过在雅可比行列式低于安全阈值时自动调整控制函数的强度，您将亲手实现一个能确保生成有效、无折叠网格的鲁棒反馈控制系统，这是开发和应用高级网格生成技术的一项核心实践技能。",
            "id": "3956885",
            "problem": "您的任务是在使用泊松方程的椭圆网格生成框架内，设计并实现一种算法检查。该算法通过在迭代求解过程中自适应地重缩放泊松控制函数 $P$ 和 $Q$，来强制实现严格为正的最小雅可比值，记为 $J_{\\min} > 0$。计算设置和所有数学表达式都应以纯粹和通用的方式表达，不依赖任何外部文件或特定的物理单位。\n\n从以下基础开始：椭圆网格生成通过一对泊松方程定义了一个从矩形计算域 $(\\xi,\\eta) \\in [0,1] \\times [0,1]$ 到物理域的光滑映射 $(x(\\xi,\\eta), y(\\xi,\\eta))$\n$$\nx_{\\xi\\xi} + x_{\\eta\\eta} = P(\\xi,\\eta), \\qquad y_{\\xi\\xi} + y_{\\eta\\eta} = Q(\\xi,\\eta).\n$$\n变换的雅可比行列式定义为\n$$\nJ(\\xi,\\eta) = x_{\\xi} y_{\\eta} - x_{\\eta} y_{\\xi},\n$$\n有效网格的无折叠要求是 $J(\\xi,\\eta) > 0$ 处处成立，且 $J_{\\min} = \\min_{\\xi,\\eta} J(\\xi,\\eta)$ 严格为正。控制函数 $P(\\xi,\\eta)$ 和 $Q(\\xi,\\eta)$ 可用于根据监控函数 $M(\\xi,\\eta)$ 来聚类网格点，但过于激进的聚类可能会在没有调节的情况下导致 $J_{\\min}$ 变为负值。\n\n您的任务是：\n- 从第一性原理推导一个用于泊松系统的有限差分迭代格式，该格式建立在一个具有 $N_x \\times N_y$ 个点、间距为 $\\Delta \\xi = 1/(N_x-1)$ 和 $\\Delta \\eta = 1/(N_y-1)$ 的均匀计算格点上，并服从固定的狄利克雷边界条件。这些边界条件将计算域的边缘映射到一个物理域，其顶部边界由 $y(\\xi,1) = 1 + 0.2 \\sin(2\\pi \\xi)$ 给出，侧边界保持垂直，即 $x(0,\\eta) = 0$, $x(1,\\eta) = 1$, $y(0,\\eta) = \\eta$, $y(1,\\eta) = \\eta$，底部边界为 $y(\\xi,0) = 0$, $x(\\xi,0) = \\xi$, $x(\\xi,1) = \\xi$。\n- 定义一个光滑的监控函数 $M(\\xi,\\eta) = 1 + \\kappa \\exp\\left(-\\frac{(\\xi-\\xi_c)^2 + (\\eta-\\eta_c)^2}{\\sigma^2}\\right)$，其具有固定中心 $(\\xi_c,\\eta_c) = (0.5,0.85)$、宽度 $\\sigma > 0$ 和强度 $\\kappa > 0$。使用控制函数 $P(\\xi,\\eta) = A \\frac{\\partial M}{\\partial \\xi}$ 和 $Q(\\xi,\\eta) = B \\frac{\\partial M}{\\partial \\eta}$，您将自适应地重缩放其振幅 $A$ 和 $B$ 以强制实现 $J_{\\min} > 0$。\n- 设计并实现一种算法检查，在离散泊松求解的若干迭代块之后测量 $J_{\\min}$，如果对于一个预设阈值 $\\tau > 0$ 有 $J_{\\min} \\le \\tau$，则用一个固定因子 $\\alpha \\in (0,1)$ 对 $(A,B)$ 进行乘法性重缩放，即 $(A,B) \\leftarrow (\\alpha A, \\alpha B)$，然后使用减弱后的 $P$ 和 $Q$ 继续迭代求解。这种自适应重缩放必须是单调的，即重复的违规将继续减小 $(A,B)$，直到实现 $J_{\\min} > \\tau$ 或控制函数变得可以忽略不计（此时系统将退化为拉普拉斯方程）。\n- 对内部点 $(i,j)$（其中 $i = 1,\\ldots,N_x-2$ 且 $j=1,\\ldots,N_y-2$）使用以下有限差分离散格式：\n$$\n\\frac{x_{i+1,j} - 2 x_{i,j} + x_{i-1,j}}{\\Delta \\xi^2} + \\frac{x_{i,j+1} - 2 x_{i,j} + x_{i,j-1}}{\\Delta \\eta^2} = P_{i,j},\n$$\n$$\n\\frac{y_{i+1,j} - 2 y_{i,j} + y_{i-1,j}}{\\Delta \\xi^2} + \\frac{y_{i,j+1} - 2 y_{i,j} + y_{i,j-1}}{\\Delta \\eta^2} = Q_{i,j},\n$$\n并推导相应的关于 $x_{i,j}$ 和 $y_{i,j}$ 的逐点 Gauss–Seidel 更新公式，用邻近值和当前的 $P_{i,j}$ 和 $Q_{i,j}$ 表示。通过中心差分计算 $J_{i,j}$，\n$$\nx_{\\xi}\\big|_{i,j} \\approx \\frac{x_{i+1,j}-x_{i-1,j}}{2\\Delta \\xi}, \\quad x_{\\eta}\\big|_{i,j} \\approx \\frac{x_{i,j+1}-x_{i,j-1}}{2\\Delta \\eta},\n$$\n$$\ny_{\\xi}\\big|_{i,j} \\approx \\frac{y_{i+1,j}-y_{i-1,j}}{2\\Delta \\xi}, \\quad y_{\\eta}\\big|_{i,j} \\approx \\frac{y_{i,j+1}-y_{i,j-1}}{2\\Delta \\eta},\n$$\n然后计算 $J_{i,j} = x_{\\xi}\\big|_{i,j}\\, y_{\\eta}\\big|_{i,j} - x_{\\eta}\\big|_{i,j}\\, y_{\\xi}\\big|_{i,j}$，$J_{\\min}$ 取所有内部点的最小值。\n\n在单个程序中实现上述内容，该程序运行四个测试用例，构成一个测试套件。每个测试用例提供初始控制函数的振幅 $(N_x,N_y)$、$(A_0,B_0)$、阈值 $\\tau$、重缩放因子 $\\alpha$、监控函数宽度 $\\sigma$、监控函数强度 $\\kappa$、每个自适应周期内的 Gauss–Seidel 迭代次数 $N_{\\text{inner}}$，以及最大自适应周期数 $N_{\\text{outer}}$。程序必须：\n- 按照规定初始化网格和边界条件。\n- 在计算格点上计算导数 $\\frac{\\partial M}{\\partial \\xi}$ 和 $\\frac{\\partial M}{\\partial \\eta}$，并使用它们通过当前的 $(A,B)$ 构成 $P$ 和 $Q$。\n- 执行迭代式 Gauss–Seidel 求解，周期性地检查 $J_{\\min}$，并在 $J_{\\min} \\le \\tau$ 时应用自适应重缩放 $(A,B) \\leftarrow (\\alpha A,\\alpha B)$，最多进行 $N_{\\text{outer}}$ 个自适应周期。如果未能实现正性，则回退到 $(A,B)=(0,0)$ 并执行最后一次内部求解以趋近调和映射。\n- 每个测试用例返回两个量：最终的最小雅可比值 $J_{\\min}$ 和实际应用的重缩放次数（整数）。\n\n使用以下测试套件：\n- 案例 1：$(N_x,N_y)=(32,32)$, $(A_0,B_0)=(1.0,1.0)$, $\\tau=0.02$, $\\alpha=0.7$, $\\sigma=0.18$, $\\kappa=2.0$, $N_{\\text{inner}}=400$, $N_{\\text{outer}}=8$。\n- 案例 2：$(N_x,N_y)=(32,32)$, $(A_0,B_0)=(10.0,10.0)$, $\\tau=0.05$, $\\alpha=0.6$, $\\sigma=0.18$, $\\kappa=3.0$, $N_{\\text{inner}}=600$, $N_{\\text{outer}}=10$。\n- 案例 3：$(N_x,N_y)=(18,18)$, $(A_0,B_0)=(20.0,20.0)$, $\\tau=0.08$, $\\alpha=0.5$, $\\sigma=0.12$, $\\kappa=4.0$, $N_{\\text{inner}}=700$, $N_{\\text{outer}}=12$。\n- 案例 4：$(N_x,N_y)=(32,32)$, $(A_0,B_0)=(0.0,0.0)$, $\\tau=0.02$, $\\alpha=0.7$, $\\sigma=0.18$, $\\kappa=2.0$, $N_{\\text{inner}}=300$, $N_{\\text{outer}}=5$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的条目为每个案例的最终最小雅可比值 $J_{\\min}$（浮点数）和重缩放次数（整数）交替出现，并按给定案例的顺序排列。例如，输出格式必须为 $[J_{\\min}^{(1)},n_{\\text{rescale}}^{(1)},J_{\\min}^{(2)},n_{\\text{rescale}}^{(2)},J_{\\min}^{(3)},n_{\\text{rescale}}^{(3)},J_{\\min}^{(4)},n_{\\text{rescale}}^{(4)}]$ 的形式。",
            "solution": "该问题要求设计并实现一种用于椭圆网格生成的自适应算法。核心任务是在一个计算域上求解一个泊松方程组，将其映射到物理域，同时确保网格不发生折叠。这个无折叠约束通过在整个域上保持一个严格为正的雅可比行列式 $J(\\xi,\\eta) > 0$ 来强制执行。这是通过自适应地调整控制函数 $P(\\xi,\\eta)$ 和 $Q(\\xi,\\eta)$ 来实现的，这些函数影响网格点的分布。\n\n该方法的基础是关于物理坐标 $(x, y)$ 作为计算坐标 $(\\xi, \\eta)$ 函数的两个泊松方程组：\n$$\nx_{\\xi\\xi} + x_{\\eta\\eta} = P(\\xi,\\eta)\n$$\n$$\ny_{\\xi\\xi} + y_{\\eta\\eta} = Q(\\xi,\\eta)\n$$\n其中 $(\\xi, \\eta)$ 定义在单位正方形 $[0,1] \\times [0,1]$ 上。一个有效的网格变换要求雅可比行列式 $J = x_{\\xi} y_{\\eta} - x_{\\eta} y_{\\xi}$ 保持为正。\n\n我们将首先推导求解这些方程的数值格式，然后阐述自适应控制算法，最后详细说明实现步骤。\n\n**1. 有限差分离散化与 Gauss-Seidel 格式**\n\n计算域被离散化为一个 $N_x \\times N_y$ 个点的均匀格点，索引为 $(i,j)$，其中 $i \\in \\{0, 1, \\dots, N_x-1\\}$ 且 $j \\in \\{0, 1, \\dots, N_y-1\\}$。相应的计算坐标为 $\\xi_i = i \\cdot \\Delta\\xi$ 和 $\\eta_j = j \\cdot \\Delta\\eta$，均匀间距为 $\\Delta\\xi = 1/(N_x-1)$ 和 $\\Delta\\eta = 1/(N_y-1)$。\n\n泊松方程中的二阶偏导数在内部网格点 $(i,j)$（对于 $i \\in [1, N_x-2]$ 和 $j \\in [1, N_y-2]$）处使用二阶中心差分公式进行近似：\n$$\n\\frac{\\partial^2 x}{\\partial \\xi^2} \\bigg|_{i,j} \\approx \\frac{x_{i+1,j} - 2x_{i,j} + x_{i-1,j}}{\\Delta\\xi^2}\n$$\n$$\n\\frac{\\partial^2 x}{\\partial \\eta^2} \\bigg|_{i,j} \\approx \\frac{x_{i,j+1} - 2x_{i,j} + x_{i,j-1}}{\\Delta\\eta^2}\n$$\n将这些近似代入 $x$ 的泊松方程，得到离散方程：\n$$\n\\frac{x_{i+1,j} - 2x_{i,j} + x_{i-1,j}}{\\Delta\\xi^2} + \\frac{x_{i,j+1} - 2x_{i,j} + x_{i,j-1}}{\\Delta\\eta^2} = P_{i,j}\n$$\n为了推导 Gauss-Seidel 方法的迭代更新规则，我们求解中心点 $x_{i,j}$：\n$$\nx_{i,j} \\left( \\frac{2}{\\Delta\\xi^2} + \\frac{2}{\\Delta\\eta^2} \\right) = \\frac{x_{i+1,j} + x_{i-1,j}}{\\Delta\\xi^2} + \\frac{x_{i,j+1} + x_{i,j-1}}{\\Delta\\eta^2} - P_{i,j}\n$$\n$$\nx_{i,j} = \\frac{1}{2\\left(\\frac{1}{\\Delta\\xi^2} + \\frac{1}{\\Delta\\eta^2}\\right)} \\left( \\frac{x_{i+1,j} + x_{i-1,j}}{\\Delta\\xi^2} + \\frac{x_{i,j+1} + x_{i,j-1}}{\\Delta\\eta^2} - P_{i,j} \\right)\n$$\n为了计算效率，我们可以简化此表达式。令 $\\beta = (\\Delta\\eta / \\Delta\\xi)^2$。将分子和分母同乘以 $\\Delta\\eta^2$ 得：\n$$\nx_{i,j} = \\frac{\\Delta\\eta^2}{2(1 + \\beta)} \\left( \\frac{\\beta}{\\Delta\\eta^2}(x_{i+1,j} + x_{i-1,j}) + \\frac{1}{\\Delta\\eta^2}(x_{i,j+1} + x_{i,j-1}) - P_{i,j} \\right)\n$$\n$$\nx_{i,j} = \\frac{1}{2(1 + \\beta)} \\left( \\beta(x_{i+1,j} + x_{i-1,j}) + (x_{i,j+1} + x_{i,j-1}) - \\Delta\\eta^2 P_{i,j} \\right)\n$$\nGauss-Seidel 方法在一次顺序扫描中更新每个内部网格点的 $x_{i,j}$ 和 $y_{i,j}$，使用最近计算出的邻近点的值。一个迭代步骤的更新方程为：\n$$\nx_{i,j}^{\\text{new}} = \\frac{1}{2(1 + \\beta)} \\left( \\beta(x_{i+1,j}^{\\text{old}} + x_{i-1,j}^{\\text{new}}) + (x_{i,j+1}^{\\text{old}} + x_{i,j-1}^{\\text{new}}) - \\Delta\\eta^2 P_{i,j} \\right)\n$$\n$$\ny_{i,j}^{\\text{new}} = \\frac{1}{2(1 + \\beta)} \\left( \\beta(y_{i+1,j}^{\\text{old}} + y_{i-1,j}^{\\text{new}}) + (y_{i,j+1}^{\\text{old}} + y_{i,j-1}^{\\text{new}}) - \\Delta\\eta^2 Q_{i,j} \\right)\n$$\n这个过程重复指定的迭代次数 $N_{\\text{inner}}$，直到 $x$ 和 $y$ 的解收敛于离散泊松系统的解。\n\n**2. 网格质量控制：雅可比行列式与自适应控制函数**\n\n雅可比行列式 $J=x_\\xi y_\\eta - x_\\eta y_\\xi$ 是从计算空间到物理空间的局部映射的一个度量。负的或零的雅可比值表示网格发生了折叠，这在物理上和数值上都是不可接受的。\n\n一阶导数在内部点 $(i,j)$ 处使用中心差分进行近似：\n$$\nx_{\\xi}\\big|_{i,j} \\approx \\frac{x_{i+1,j}-x_{i-1,j}}{2\\Delta \\xi}, \\qquad x_{\\eta}\\big|_{i,j} \\approx \\frac{x_{i,j+1}-x_{i,j-1}}{2\\Delta \\eta}\n$$\n对于 $y_{\\xi}|_{i,j}$ 和 $y_{\\eta}|_{i,j}$ 也是如此。于是离散的雅可比行列式为：\n$$\nJ_{i,j} = \\left(\\frac{x_{i+1,j}-x_{i-1,j}}{2\\Delta \\xi}\\right) \\left(\\frac{y_{i,j+1}-y_{i,j-1}}{2\\Delta \\eta}\\right) - \\left(\\frac{x_{i,j+1}-x_{i,j-1}}{2\\Delta \\eta}\\right) \\left(\\frac{y_{i+1,j}-y_{i-1,j}}{2\\Delta \\xi}\\right)\n$$\n网格内部的最小雅可比值 $J_{\\min} = \\min_{i,j} J_{i,j}$，作为网格质量的主要度量。\n\n控制函数 $P$ 和 $Q$ 用于聚类网格线。它们通过一个监控函数 $M(\\xi,\\eta)$ 来定义：\n$$\nP(\\xi,\\eta) = A \\frac{\\partial M}{\\partial \\xi}, \\qquad Q(\\xi,\\eta) = B \\frac{\\partial M}{\\partial \\eta}\n$$\n指定的监控函数是一个高斯分布：\n$$\nM(\\xi,\\eta) = 1 + \\kappa \\exp\\left(-\\frac{(\\xi-\\xi_c)^2 + (\\eta-\\eta_c)^2}{\\sigma^2}\\right)\n$$\n其偏导数为：\n$$\n\\frac{\\partial M}{\\partial \\xi} = -\\frac{2\\kappa(\\xi-\\xi_c)}{\\sigma^2}\\exp\\left(-\\frac{(\\xi-\\xi_c)^2 + (\\eta-\\eta_c)^2}{\\sigma^2}\\right)\n$$\n$$\n\\frac{\\partial M}{\\partial \\eta} = -\\frac{2\\kappa(\\eta-\\eta_c)}{\\sigma^2}\\exp\\left(-\\frac{(\\xi-\\xi_c)^2 + (\\eta-\\eta_c)^2}{\\sigma^2}\\right)\n$$\n振幅 $A$ 和 $B$ 的大值可能导致激进的网格聚类，进而可能导致 $J_{\\min}$ 变为非正值。\n\n**3. 自适应重缩放算法**\n\n该算法迭代求解泊松系统，同时监控 $J_{\\min}$ 并调整控制函数振幅 $A$ 和 $B$ 以防止网格折叠。流程如下：\n\n1.  **初始化**：\n    *   离散化计算域并初始化物理网格数组 $x$ 和 $y$。\n    *   设置规定的狄利克雷边界条件。\n    *   为 $x$ 和 $y$ 的内部点提供一个初始猜测，通常通过边界进行线性插值。\n    *   计算网格上 $\\frac{\\partial M}{\\partial \\xi}$ 和 $\\frac{\\partial M}{\\partial \\eta}$ 的数组。\n    *   将控制振幅初始化为其起始值 $(A,B) = (A_0, B_0)$，并将重缩放计数器设置为 $0$。\n\n2.  **自适应外循环**：最多迭代 $N_{\\text{outer}}$ 个周期。在每个周期中：\n    *   a. **更新控制函数**：使用当前的 $A$ 和 $B$ 值重新计算源项数组 $P_{i,j}$ 和 $Q_{i,j}$。\n    *   b. **迭代求解（内循环）**：执行 $N_{\\text{inner}}$ 次 Gauss-Seidel 格式迭代，以更新内部网格点 $(x_{i,j}, y_{i,j})$。\n    *   c. **雅可比行列式检查**：计算内部网格上的雅可比矩阵 $J_{i,j}$，并找到其最小值 $J_{\\min}$。\n    *   d. **重缩放**：如果 $J_{\\min} \\le \\tau$（其中 $\\tau > 0$ 是一个安全阈值），则网格质量不足。控制函数过强。我们通过一个乘法因子 $\\alpha \\in (0,1)$ 来减弱它们：\n       $$\n       (A, B) \\leftarrow (\\alpha A, \\alpha B)\n       $$\n       重缩放次数加一。如果 $J_{\\min} > \\tau$，则在下一个周期中保留当前的 $(A,B)$。\n\n3.  **回退机制**：在 $N_{\\text{outer}}$ 个周期完成后，对最后计算的 $J_{\\min}$ 进行最终检查。如果它仍然小于或等于 $\\tau$，这表示自适应过程在给定的约束内未能达到期望的网格质量。在这种情况下，触发回退到调和网格：\n    *   设置 $(A,B) = (0,0)$，这使得 $P=0$ 和 $Q=0$。系统简化为拉普拉斯方程。\n    *   执行最后一块 $N_{\\text{inner}}$ 次 Gauss-Seidel 迭代。\n    *   重新计算最终的 $J_{\\min}$。在具有非自相交边界的域上的调和映射（拉普拉斯方程的解）保证是无折叠的，从而确保了正的雅可比值。\n\n4.  **输出**：对于每个测试用例，报告最终的 $J_{\\min}$ 和乘法重缩放的总次数。\n\n该算法提供了一种稳健的方法来生成能够适应由监控函数指定的特征的网格，同时系统地防止了强网格聚类中常见的网格折叠失败。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(Nx, Ny, A0, B0, tau, alpha, sigma, kappa, N_inner, N_outer, xi_c, eta_c):\n    \"\"\"\n    Solves the elliptic grid generation problem for a single test case.\n    \"\"\"\n    # 1. Initialization\n    dxi = 1.0 / (Nx - 1)\n    deta = 1.0 / (Ny - 1)\n    xi = np.linspace(0.0, 1.0, Nx)\n    eta = np.linspace(0.0, 1.0, Ny)\n    XI, ETA = np.meshgrid(xi, eta, indexing='ij')\n\n    x = np.zeros((Nx, Ny))\n    y = np.zeros((Nx, Ny))\n\n    # 2. Set Boundary Conditions\n    # Bottom boundary (eta=0, j=0)\n    x[:, 0] = xi\n    y[:, 0] = 0.0\n    # Top boundary (eta=1, j=Ny-1)\n    x[:, Ny-1] = xi\n    y[:, Ny-1] = 1.0 + 0.2 * np.sin(2.0 * np.pi * xi)\n    # Left boundary (xi=0, i=0)\n    x[0, :] = 0.0\n    y[0, :] = eta\n    # Right boundary (xi=1, i=Nx-1)\n    x[Nx-1, :] = 1.0\n    y[Nx-1, :] = eta\n\n    # Initial guess for interior points (linear interpolation)\n    for j in range(1, Ny - 1):\n        for i in range(1, Nx - 1):\n            x[i, j] = x[i, 0] + ETA[i, j] * (x[i, Ny-1] - x[i, 0])\n            y[i, j] = y[0, j] + XI[i, j] * (y[Nx-1, j] - y[0, j])\n\n    # 3. Pre-compute monitor function derivatives\n    M_arg = -((XI - xi_c)**2 + (ETA - eta_c)**2) / (sigma**2)\n    M_exp = np.exp(M_arg)\n    dM_dxi = -2.0 * kappa * (XI - xi_c) / (sigma**2) * M_exp\n    dM_deta = -2.0 * kappa * (ETA - eta_c) / (sigma**2) * M_exp\n\n    # 4. Adaptive Rescaling Algorithm\n    A, B = A0, B0\n    rescale_count = 0\n    beta = (deta / dxi)**2\n    C = 1.0 / (2.0 * (1.0 + beta))\n    deta2 = deta**2\n\n    final_J_min = 0.0\n\n    for _ in range(N_outer):\n        # Update control functions P and Q\n        P = A * dM_dxi\n        Q = B * dM_deta\n\n        # Inner Gauss-Seidel iterations\n        for _ in range(N_inner):\n            x_old = x.copy()\n            y_old = y.copy()\n            for i in range(1, Nx - 1):\n                for j in range(1, Ny - 1):\n                    x[i, j] = C * (beta * (x_old[i+1, j] + x[i-1, j]) +\n                                   (x_old[i, j+1] + x[i, j-1]) -\n                                   deta2 * P[i, j])\n                    y[i, j] = C * (beta * (y_old[i+1, j] + y[i-1, j]) +\n                                   (y_old[i, j+1] + y[i, j-1]) -\n                                   deta2 * Q[i, j])\n        \n        # Jacobian calculation at interior points\n        x_xi = (x[2:, 1:-1] - x[:-2, 1:-1]) / (2 * dxi)\n        x_eta = (x[1:-1, 2:] - x[1:-1, :-2]) / (2 * deta)\n        y_xi = (y[2:, 1:-1] - y[:-2, 1:-1]) / (2 * dxi)\n        y_eta = (y[1:-1, 2:] - y[1:-1, :-2]) / (2 * deta)\n        \n        J = x_xi * y_eta - x_eta * y_xi\n        J_min = np.min(J)\n        final_J_min = J_min\n\n        # Adaptive step\n        if J_min = tau:\n            A *= alpha\n            B *= alpha\n            rescale_count += 1\n            \n    # 5. Fallback Mechanism if positivity is not achieved\n    if final_J_min = tau:\n        A, B = 0.0, 0.0\n        P = A * dM_dxi # Now zero\n        Q = B * dM_deta # Now zero\n        # Final inner solve for Laplace's equation\n        for _ in range(N_inner):\n            x_old = x.copy()\n            y_old = y.copy()\n            for i in range(1, Nx - 1):\n                for j in range(1, Ny - 1):\n                    x[i, j] = C * (beta * (x_old[i+1, j] + x[i-1, j]) +\n                                   (x_old[i, j+1] + x[i, j-1]) -\n                                   deta2 * P[i, j])\n                    y[i, j] = C * (beta * (y_old[i+1, j] + y[i-1, j]) +\n                                   (y_old[i, j+1] + y[i, j-1]) -\n                                   deta2 * Q[i, j])\n        \n        # Re-compute final Jacobian\n        x_xi = (x[2:, 1:-1] - x[:-2, 1:-1]) / (2 * dxi)\n        x_eta = (x[1:-1, 2:] - x[1:-1, :-2]) / (2 * deta)\n        y_xi = (y[2:, 1:-1] - y[:-2, 1:-1]) / (2 * dxi)\n        y_eta = (y[1:-1, 2:] - y[1:-1, :-2]) / (2 * deta)\n        \n        J = x_xi * y_eta - x_eta * y_xi\n        final_J_min = np.min(J)\n        \n    return final_J_min, rescale_count\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {'Nx': 32, 'Ny': 32, 'A0': 1.0, 'B0': 1.0, 'tau': 0.02, 'alpha': 0.7,\n         'sigma': 0.18, 'kappa': 2.0, 'N_inner': 400, 'N_outer': 8},\n        # Case 2\n        {'Nx': 32, 'Ny': 32, 'A0': 10.0, 'B0': 10.0, 'tau': 0.05, 'alpha': 0.6,\n         'sigma': 0.18, 'kappa': 3.0, 'N_inner': 600, 'N_outer': 10},\n        # Case 3\n        {'Nx': 18, 'Ny': 18, 'A0': 20.0, 'B0': 20.0, 'tau': 0.08, 'alpha': 0.5,\n         'sigma': 0.12, 'kappa': 4.0, 'N_inner': 700, 'N_outer': 12},\n        # Case 4\n        {'Nx': 32, 'Ny': 32, 'A0': 0.0, 'B0': 0.0, 'tau': 0.02, 'alpha': 0.7,\n         'sigma': 0.18, 'kappa': 2.0, 'N_inner': 300, 'N_outer': 5},\n    ]\n\n    results = []\n    monitor_center = (0.5, 0.85)\n\n    for case in test_cases:\n        J_min, n_rescale = run_case(\n            Nx=case['Nx'], Ny=case['Ny'],\n            A0=case['A0'], B0=case['B0'],\n            tau=case['tau'], alpha=case['alpha'],\n            sigma=case['sigma'], kappa=case['kappa'],\n            N_inner=case['N_inner'], N_outer=case['N_outer'],\n            xi_c=monitor_center[0], eta_c=monitor_center[1]\n        )\n        results.append(f\"{J_min:.8f}\")\n        results.append(str(n_rescale))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在掌握了通过内部源项控制网格分布后，下一个关键步骤是精确控制边界处的网格行为，这对于模拟真实的物理流动至关重要。本练习将重点探讨如何使用 Neumann 边界条件来直接指定边界法向的网格线间距和角度，从而实现对近壁面或出流边界网格的精细控制 。通过求解一个混合了 Dirichlet 和 Neumann 条件的边界值问题，您将量化不同边界条件设定对网格正交性和单元尺寸的影响，深入理解在 CFD 应用中如何根据物理需求定制边界网格结构。",
            "id": "3956912",
            "problem": "本题要求您在计算流体力学（CFD）的背景下，分析由泊松方程生成的椭圆网格的近边界行为。考虑一个从计算域到物理域的光滑映射，该映射由两个标量场 $x(\\xi,\\eta)$ 和 $y(\\xi,\\eta)$ 定义，其中 $(\\xi,\\eta) \\in [0,1] \\times [0,1]$ 是无量纲计算坐标，$(x,y)$ 是以米为单位的物理坐标。物理域是一个宽度为 $L_x$、高度为 $L_y$ 的矩形。网格通过求解控制函数为零的椭圆网格生成方程的泊сон形式生成，即\n$$\nx_{\\xi\\xi} + x_{\\eta\\eta} = 0, \\quad y_{\\xi\\xi} + y_{\\eta\\eta} = 0,\n$$\n该方程受制于三条边上的狄利克雷边界条件和出口边界上的诺伊曼边界条件：\n- 底部边界 ($\\eta=0$): $x(\\xi,0) = L_x \\,\\xi$, $y(\\xi,0) = 0$。\n- 左侧边界 ($\\xi=0$): $x(0,\\eta) = 0$, $y(0,\\eta) = L_y \\,\\eta$。\n- 右侧边界 ($\\xi=1$): $x(1,\\eta) = L_x$, $y(1,\\eta) = L_y \\,\\eta$。\n- 出口边界 (顶部, $\\eta=1$): 恒定的诺伊曼数据 $x_\\eta(\\xi,1) = s_x$, $y_\\eta(\\xi,1) = s_y$，其中 $s_x$ 和 $s_y$ 是给定的常数。\n\n您的任务是：\n1. 在均匀网格上使用有限差分离散方法，对上述边值问题进行数值求解。网格在 $\\xi$ 方向上有 $N_\\xi$ 个点，在 $\\eta$ 方向上有 $N_\\eta$ 个点。使用逐次超松弛法进行迭代求解，直至满足收敛准则。\n2. 计算出口边界下方第一行内部网格点上的近边界正交性度量和间距度量：\n   - 定义度量矢量 $ \\mathbf{g}_\\xi = (x_\\xi, y_\\xi)$ 和 $ \\mathbf{g}_\\eta = (x_\\eta, y_\\eta)$，并使用中心差分近似导数。\n   - 网格点的正交性度量为\n     $$\n     \\mathcal{O} = \\frac{\\left| \\mathbf{g}_\\xi \\cdot \\mathbf{g}_\\eta \\right|}{\\lVert \\mathbf{g}_\\xi \\rVert \\,\\lVert \\mathbf{g}_\\eta \\rVert},\n     $$\n     该值位于 $[0,1]$ 区间内，对于完全正交的坐标线，该值等于 $0$。\n   - 间距度量是沿同一内部行上 $\\lVert \\mathbf{g}_\\eta \\rVert$ 的平均值（单位为米），它量化了相邻 $\\eta$ 坐标线的平均物理间距。\n3. 对于每个测试用例，输出在紧邻出口边界下方的一行（即 $\\eta = 1 - \\Delta \\eta$ 处）的所有内部点上计算的平均正交性度量 $\\overline{\\mathcal{O}}$ 和平均间距 $\\overline{s}$。间距必须以米为单位表示。\n\n在所有测试用例中，使用以下固定的物理和数值参数：\n- 物理尺寸：$L_x = 1.0$ 米, $L_y = 0.5$ 米。\n- 网格分辨率：$N_\\xi = 31$, $N_\\eta = 31$。\n- 松弛因子：$\\omega = 1.8$。\n- 收敛容差：每次迭代的最大绝对变化小于 $10^{-10}$。\n- 最大迭代次数：$8000$。\n- 出口边界的离散诺伊曼条件实施：对于内部点 $i$，施加 $x(i,N_\\eta-1) = x(i,N_\\eta-2) + s_x \\,\\Delta \\eta$ 和 $y(i,N_\\eta-1) = y(i,N_\\eta-2) + s_y \\,\\Delta \\eta$，其中 $\\Delta \\eta = 1/(N_\\eta-1)$，而角点 $(\\xi=0,\\eta=1)$ 和 $(\\xi=1,\\eta=1)$ 保留其狄利克雷值。\n\n测试套件：\n- 案例1 (基准正交性与间距): $s_x = 0.0$ 米, $s_y = L_y$ 米。\n- 案例2 (为降低正交性而有意倾斜): $s_x = 0.2\\,L_x$ 米, $s_y = L_y$ 米。\n- 案例3 (出口附近间距压缩): $s_x = 0.0$ 米, $s_y = 0.5\\,L_y$ 米。\n- 案例4 (出口附近间距扩大): $s_x = 0.0$ 米, $s_y = 1.5\\,L_y$ 米。\n\n最终输出规格：\n- 您的程序应生成一行输出，包含八个用逗号分隔的浮点数，并用方括号括起来，对应于 $[\\overline{\\mathcal{O}}_1,\\overline{s}_1,\\overline{\\mathcal{O}}_2,\\overline{s}_2,\\overline{\\mathcal{O}}_3,\\overline{s}_3,\\overline{\\mathcal{O}}_4,\\overline{s}_4]$，其中下标指的是按以上顺序列出的测试用例。间距值必须以米为单位。将每个值四舍五入到六位小数。",
            "solution": "该问题要求在一个单位正方形计算域 $(\\xi, \\eta) \\in [0,1] \\times [0,1]$ 上，对一对拉普拉斯方程 $x_{\\xi\\xi} + x_{\\eta\\eta} = 0$ 和 $y_{\\xi\\xi} + y_{\\eta\\eta} = 0$ 进行数值求解。这些方程将计算网格映射到物理网格 $(x,y)$。求解过程受混合狄利克雷和诺伊曼边界条件的约束。目标是计算不同出口条件下的网格质量度量。\n\n首先，我们使用有限差分法对控制偏微分方程（PDE）进行离散化。计算域被一个均匀网格覆盖，该网格有 $N_\\xi = 31$ 个点和 $N_\\eta = 31$ 个点。计算域中的网格间距为 $\\Delta\\xi = 1/(N_\\xi-1)$ 和 $\\Delta\\eta = 1/(N_\\eta-1)$。由于 $N_\\xi = N_\\eta$，我们有 $\\Delta\\xi = \\Delta\\eta$。设 $x_{i,j} = x(i\\Delta\\xi, j\\Delta\\eta)$ 和 $y_{i,j} = y(i\\Delta\\xi, j\\Delta\\eta)$ 为网格节点 $(i,j)$ 处的物理坐标。\n\n二阶偏导数使用二阶中心差分格式进行近似。对于一个通用函数 $f(\\xi,\\eta)$，在网格点 $(i,j)$ 的导数为：\n$$\nf_{\\xi\\xi}\\Big|_{i,j} \\approx \\frac{f_{i+1,j} - 2f_{i,j} + f_{i-1,j}}{(\\Delta\\xi)^2}\n$$\n$$\nf_{\\eta\\eta}\\Big|_{i,j} \\approx \\frac{f_{i,j+1} - 2f_{i,j} + f_{i,j-1}}{(\\Delta\\eta)^2}\n$$\n将这些近似代入 $x$ 的拉普拉斯方程（对 $y$ 也类似），我们得到：\n$$\n\\frac{x_{i+1,j} - 2x_{i,j} + x_{i-1,j}}{(\\Delta\\xi)^2} + \\frac{x_{i,j+1} - 2x_{i,j} + x_{i,j-1}}{(\\Delta\\eta)^2} = 0\n$$\n由于 $\\Delta\\xi = \\Delta\\eta$，在求解 $x_{i,j}$ 时，该方程得以简化，从而得到经典的拉普拉斯算子五点差分格式平均值：\n$$\nx_{i,j} = \\frac{1}{4} (x_{i+1,j} + x_{i-1,j} + x_{i,j+1} + x_{i,j-1})\n$$\n这个线性代数方程将每个内部网格点的值与其四个最近邻点联系起来。一个类似的方程也适用于 $y_{i,j}$。\n\n这个线性方程组使用逐次超松弛（SOR）方法进行迭代求解。设 $x_{i,j}^{(k)}$ 为第 $k$ 次迭代时的值。第 $k+1$ 次迭代的更新分两步进行。首先，使用最新更新的值计算一个临时的的高斯-赛德尔值 $\\tilde{x}_{i,j}$：\n$$\n\\tilde{x}_{i,j}^{(k+1)} = \\frac{1}{4} \\left(x_{i+1,j}^{(k)} + x_{i-1,j}^{(k+1)} + x_{i,j+1}^{(k)} + x_{i,j-1}^{(k+1)}\\right)\n$$\n这里我们假设采用标准的逐行逐列扫描方式。然后，使用松弛因子 $\\omega = 1.8$ 将该值与前一次迭代的值进行混合：\n$$\nx_{i,j}^{(k+1)} = (1-\\omega)x_{i,j}^{(k)} + \\omega \\tilde{x}_{i,j}^{(k+1)}\n$$\n对 $y_{i,j}$ 的过程是相同的。\n\n边界条件按如下方式施加：\n- 在狄利克雷边界上（底部：$\\eta=0$；左侧：$\\xi=0$；右侧：$\\xi=1$），$x_{i,j}$ 和 $y_{i,j}$ 的值在所有迭代中都根据问题描述固定：$x(\\xi,0) = L_x \\xi$, $y(\\xi,0) = 0$; $x(0,\\eta) = 0$, $y(0,\\eta) = L_y \\eta$; $x(1,\\eta) = L_x$, $y(1,\\eta) = L_y \\eta$。\n- 在诺伊曼边界上（顶部：$\\eta=1$），施加法向导数的条件。对于 $x_\\eta(\\xi,1) = s_x$，我们在边界节点 $j = N_\\eta-1$ 处使用一阶向前差分近似：\n$$\n\\frac{x_{i, N_\\eta-1} - x_{i, N_\\eta-2}}{\\Delta\\eta} = s_x\n$$\n这给出了边界值的更新规则，$x_{i, N_\\eta-1} = x_{i, N_\\eta-2} + s_x \\Delta\\eta$，该规则在每次 SOR 迭代中应用于所有内部点 $i \\in [1, N_\\xi-2]$。类似的规则也适用于 $y$。根据规定，角点保留其狄利克雷值。\n\n迭代过程持续进行，直到连续两次迭代之间任意网格坐标的最大绝对变化量小于容差 $10^{-10}$，即 $\\max(|x^{(k+1)}-x^{(k)}|, |y^{(k+1)}-y^{(k)}|)  10^{-10}$。\n\n收敛后，我们在出口边界下方的第一行内部网格点上（即 $\\eta = 1-\\Delta\\eta$ 处，网格索引为 $j = N_\\eta-2$），为所有内部点 $i \\in [1, N_\\xi-2]$ 计算网格质量度量。度量矢量 $\\mathbf{g}_\\xi = (x_\\xi, y_\\xi)$ 和 $\\mathbf{g}_\\eta = (x_\\eta, y_\\eta)$ 使用二阶中心差分计算：\n$$\nx_\\xi\\Big|_{i,j} = \\frac{x_{i+1,j} - x_{i-1,j}}{2\\Delta\\xi}, \\quad y_\\xi\\Big|_{i,j} = \\frac{y_{i+1,j} - y_{i-1,j}}{2\\Delta\\xi}\n$$\n$$\nx_\\eta\\Big|_{i,j} = \\frac{x_{i,j+1} - x_{i,j-1}}{2\\Delta\\eta}, \\quad y_\\eta\\Big|_{i,j} = \\frac{y_{i,j+1} - y_{i,j-1}}{2\\Delta\\eta}\n$$\n每个点的正交性度量 $\\mathcal{O}$ 和间距度量（$\\mathbf{g}_\\eta$ 的范数）为：\n$$\n\\mathcal{O}_{i,j} = \\frac{\\left| \\mathbf{g}_\\xi \\cdot \\mathbf{g}_\\eta \\right|}{\\lVert \\mathbf{g}_\\xi \\rVert \\,\\lVert \\mathbf{g}_\\eta \\rVert} = \\frac{|x_\\xi x_\\eta + y_\\xi y_\\eta|}{\\sqrt{x_\\xi^2+y_\\xi^2}\\sqrt{x_\\eta^2+y_\\eta^2}}, \\quad s_{i,j} = \\lVert \\mathbf{g}_\\eta \\rVert = \\sqrt{x_\\eta^2 + y_\\eta^2}\n$$\n最终报告的值 $\\overline{\\mathcal{O}}$ 和 $\\overline{s}$ 分别是 $\\mathcal{O}_{i,j}$ 和 $s_{i,j}$ 在第 $j = N_\\eta-2$ 行的内部点 $i \\in [1, N_\\xi-2]$ 上取算的算术平均值。对四个测试用例中的每一个都重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_grid_and_get_metrics(Lx, Ly, N_xi, N_eta, sx, sy, omega, tol, max_iter):\n    \"\"\"\n    Solves the elliptic grid generation problem and computes metrics.\n    \"\"\"\n    # 1. Grid Setup\n    d_xi = 1.0 / (N_xi - 1)\n    d_eta = 1.0 / (N_eta - 1)\n    \n    xi = np.linspace(0, 1, N_xi)\n    eta = np.linspace(0, 1, N_eta)\n\n    x = np.zeros((N_eta, N_xi))\n    y = np.zeros((N_eta, N_xi))\n\n    # 2. Boundary Conditions\n    # Dirichlet BCs on bottom, left, and right boundaries\n    x[0, :] = Lx * xi\n    y[0, :] = 0.0\n    \n    x[:, 0] = 0.0\n    y[:, 0] = Ly * eta\n    \n    x[:, N_xi - 1] = Lx\n    y[:, N_xi - 1] = Ly * eta\n\n    # 3. Iterative Solver (SOR)\n    # The coefficient for the simplified 5-point stencil is 0.25 since d_xi = d_eta\n    stencil_coeff = 0.25\n\n    for k in range(max_iter):\n        x_old = x.copy()\n        y_old = y.copy()\n\n        # Update interior points (j from 1 to N_eta-2, i from 1 to N_xi-2)\n        for j in range(1, N_eta - 1):\n            for i in range(1, N_xi - 1):\n                # Gauss-Seidel intermediate value calculation\n                x_gs = stencil_coeff * (x[j, i+1] + x[j, i-1] + x[j+1, i] + x[j-1, i])\n                y_gs = stencil_coeff * (y[j, i+1] + y[j, i-1] + y[j+1, i] + y[j-1, i])\n                \n                # SOR update\n                x[j, i] = (1 - omega) * x_old[j, i] + omega * x_gs\n                y[j, i] = (1 - omega) * y_old[j, i] + omega * y_gs\n        \n        # Update top Neumann boundary (interior nodes: i from 1 to N_xi-2)\n        for i in range(1, N_xi - 1):\n            x[N_eta - 1, i] = x[N_eta - 2, i] + sx * d_eta\n            y[N_eta - 1, i] = y[N_eta - 2, i] + sy * d_eta\n            \n        # Check for convergence\n        max_change = max(np.max(np.abs(x - x_old)), np.max(np.abs(y - y_old)))\n        \n        if max_change  tol:\n            break\n\n    # 4. Metric Calculation\n    # Metrics are computed on the interior row just below the outflow (j = N_eta - 2)\n    j_row = N_eta - 2\n    ortho_metrics = []\n    spacing_metrics = []\n\n    # Iterate over interior points of that row (i from 1 to N_xi-2)\n    for i in range(1, N_xi - 1):\n        # Central differences for derivatives\n        x_xi = (x[j_row, i+1] - x[j_row, i-1]) / (2 * d_xi)\n        y_xi = (y[j_row, i+1] - y[j_row, i-1]) / (2 * d_xi)\n        x_eta = (x[j_row+1, i] - x[j_row-1, i]) / (2 * d_eta)\n        y_eta = (y[j_row+1, i] - y[j_row-1, i]) / (2 * d_eta)\n\n        # Metric vector components\n        g_xi_dot_g_eta = x_xi * x_eta + y_xi * y_eta\n        norm_g_xi = np.sqrt(x_xi**2 + y_xi**2)\n        norm_g_eta = np.sqrt(x_eta**2 + y_eta**2)\n\n        # Orthogonality metric\n        if norm_g_xi > 1e-12 and norm_g_eta > 1e-12: # Avoid division by zero\n            ortho = np.abs(g_xi_dot_g_eta) / (norm_g_xi * norm_g_eta)\n        else:\n            ortho = 0.0 # Define as 0 for degenerate cases\n        ortho_metrics.append(ortho)\n        \n        # Spacing metric is the norm of g_eta\n        spacing_metrics.append(norm_g_eta)\n\n    # Compute mean values\n    mean_ortho = np.mean(ortho_metrics)\n    mean_spacing = np.mean(spacing_metrics)\n\n    return mean_ortho, mean_spacing\n\n\ndef solve():\n    # Define the fixed physical and numerical parameters from the problem statement.\n    Lx = 1.0\n    Ly = 0.5\n    N_xi = 31\n    N_eta = 31\n    omega = 1.8\n    tol = 1e-10\n    max_iter = 8000\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (s_x, s_y)\n        (0.0, Ly),                  # Case 1\n        (0.2 * Lx, Ly),             # Case 2\n        (0.0, 0.5 * Ly),            # Case 3\n        (0.0, 1.5 * Ly)             # Case 4\n    ]\n\n    results = []\n    for sx, sy in test_cases:\n        mean_ortho, mean_spacing = solve_grid_and_get_metrics(Lx, Ly, N_xi, N_eta, sx, sy, omega, tol, max_iter)\n        results.extend([mean_ortho, mean_spacing])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{v:.6f}\" for v in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}