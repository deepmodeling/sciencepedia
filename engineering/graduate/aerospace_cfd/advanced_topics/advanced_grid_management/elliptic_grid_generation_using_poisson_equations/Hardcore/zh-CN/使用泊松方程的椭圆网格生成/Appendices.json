{
    "hands_on_practices": [
        {
            "introduction": "在评估计算网格的质量时，正交性是一个至关重要的特性，因为它能简化控制方程并提高数值解的精度。本练习旨在建立几何概念与解析数学之间的桥梁。通过推导正交性的必要和充分条件，即偏导数之间的关系 $x_{\\xi}x_{\\eta} + y_{\\xi}y_{\\eta} = 0$，您将掌握一个用于诊断任意坐标变换正交性的基本工具 。",
            "id": "3313536",
            "problem": "考虑一个从坐标为 $\\xi$ 和 $\\eta$ 的计算域到坐标为 $x$ 和 $y$ 的物理域的光滑、双射的平面映射，该映射由位置向量 $\\mathbf{r}(\\xi,\\eta) = \\big(x(\\xi,\\eta), y(\\xi,\\eta)\\big)$ 定义。在使用泊松方程进行椭圆网格生成时，通过求解形如 $x_{\\xi\\xi} + x_{\\eta\\eta} = P(\\xi,\\eta)$ 和 $y_{\\xi\\xi} + y_{\\eta\\eta} = Q(\\xi,\\eta)$ 的椭圆型偏微分方程来构造此类映射，其中 $P$ 和 $Q$ 是为调节网格光滑度和间距而选择的光滑控制函数。从 $\\mathbb{R}^{2}$ 中的欧几里得内积和曲线坐标的协变基向量的定义出发，推导坐标线 $\\xi=\\text{constant}$ 和 $\\eta=\\text{constant}$ 在物理平面上正交的充分必要条件，该条件需纯粹用 $x(\\xi,\\eta)$ 和 $y(\\xi,\\eta)$ 的偏导数表示。然后，对于特定映射 $x(\\xi,\\eta) = \\xi$ 和 $y(\\xi,\\eta) = \\eta^{2}$，在一般点 $(\\xi,\\eta)$ 处计算从您推导的条件中得到的正交性诊断量，以评估其正交性是保持还是丧失。最终答案必须是计算出的诊断值，形式为单个实数或单个闭式表达式，无单位且无需四舍五入。",
            "solution": "该问题要求推导平面映射中坐标线正交的充分必要条件，并随后将此条件应用于一个特定的变换。\n\n首先，我们推导正交性的一般条件。从具有曲线坐标 $(\\xi, \\eta)$ 的计算域到具有笛卡尔坐标 $(x, y)$ 的物理域的映射由位置向量 $\\mathbf{r}(\\xi, \\eta) = x(\\xi, \\eta)\\mathbf{i} + y(\\xi, \\eta)\\mathbf{j}$ 定义。用分量形式，我们写作 $\\mathbf{r} = \\big(x(\\xi, \\eta), y(\\xi, \\eta)\\big)$。\n\n物理平面中的坐标线是计算平面中直线 $\\xi = \\text{constant}$ 和 $\\eta = \\text{constant}$ 的像。\n对应于 $\\eta = \\text{constant}$ 的曲线的切向量是通过将位置向量 $\\mathbf{r}$ 对 $\\xi$ 求导得到的。这个向量是协变基向量 $\\mathbf{g}_{\\xi}$：\n$$\n\\mathbf{g}_{\\xi} = \\frac{\\partial \\mathbf{r}}{\\partial \\xi} = \\left(\\frac{\\partial x}{\\partial \\xi}, \\frac{\\partial y}{\\partial \\xi}\\right) = (x_{\\xi}, y_{\\xi})\n$$\n类似地，对应于 $\\xi = \\text{constant}$ 的曲线的切向量是通过将 $\\mathbf{r}$ 对 $\\eta$ 求导得到的。这个向量是协变基向量 $\\mathbf{g}_{\\eta}$：\n$$\n\\mathbf{g}_{\\eta} = \\frac{\\partial \\mathbf{r}}{\\partial \\eta} = \\left(\\frac{\\partial x}{\\partial \\eta}, \\frac{\\partial y}{\\partial \\eta}\\right) = (x_{\\eta}, y_{\\eta})\n$$\n在欧几里得平面中，两个向量正交的充分必要条件是它们的内积（点积）为零。因此，坐标线在某一点正交的充分必要条件是它们在该点的切向量正交。这表示为：\n$$\n\\mathbf{g}_{\\xi} \\cdot \\mathbf{g}_{\\eta} = 0\n$$\n将基向量的分量表达式代入，我们得到用映射函数的偏导数表示的正交性条件：\n$$\n(x_{\\xi}, y_{\\xi}) \\cdot (x_{\\eta}, y_{\\eta}) = x_{\\xi}x_{\\eta} + y_{\\xi}y_{\\eta} = 0\n$$\n表达式 $x_{\\xi}x_{\\eta} + y_{\\xi}y_{\\eta}$ 即为问题中要求的“正交性诊断量”。它的值决定了正交性是否得以保持。该项对应于变换的度量张量的非对角元素 $g_{12}$ 和 $g_{21}$。一个对角度量张量（$g_{12}=g_{21}=0$）意味着一个正交坐标系。\n\n接下来，我们将此条件应用于给定的特定映射：\n$$\nx(\\xi, \\eta) = \\xi\n$$\n$$\ny(\\xi, \\eta) = \\eta^{2}\n$$\n我们必须首先计算 $x$ 和 $y$ 关于 $\\xi$ 和 $\\eta$ 的四个一阶偏导数：\n$$\nx_{\\xi} = \\frac{\\partial}{\\partial \\xi}(\\xi) = 1\n$$\n$$\nx_{\\eta} = \\frac{\\partial}{\\partial \\eta}(\\xi) = 0\n$$\n$$\ny_{\\xi} = \\frac{\\partial}{\\partial \\xi}(\\eta^{2}) = 0\n$$\n$$\ny_{\\eta} = \\frac{\\partial}{\\partial \\eta}(\\eta^{2}) = 2\\eta\n$$\n现在，我们将这些导数代入正交性诊断表达式中：\n$$\nx_{\\xi}x_{\\eta} + y_{\\xi}y_{\\eta} = (1)(0) + (0)(2\\eta)\n$$\n计算此表达式，我们得到：\n$$\n0 + 0 = 0\n$$\n对于域中所有的点 $(\\xi, \\eta)$，正交性诊断量的值恒等于 $0$。这表明对于这个特定映射，坐标线处处正交。从几何上看，$\\xi$ 为常数的线映射为垂直线 $x = \\text{constant}$，而 $\\eta$ 为常数的线映射为水平线 $y = (\\text{constant})^{2}$。由垂直线和水平线组成的网格根据定义是正交网格。\n\n最终答案是计算出的正交性诊断表达式的值。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "虽然拉普拉斯方程能够生成平滑的网格，但在实际的计算流体力学（CFD）应用中，我们常常需要通过泊松方程中的控制函数 $P$ 和 $Q$ 在关键区域（如边界层或激波附近）加密网格点。然而，过于激进的网格聚集可能导致网格折叠，即雅可比行列式 $J$ 变为非正值。本练习将指导您设计并实现一个自适应算法，该算法在迭代求解过程中监控最小雅可比行列式 $J_{\\min}$，并通过动态缩放控制函数来确保网格的有效性，即 $J > 0$ 。这项实践对于平衡网格自适应需求与保持网格质量的核心工程挑战至关重要。",
            "id": "3956885",
            "problem": "您的任务是在使用泊松方程的椭圆网格生成框架内，设计并实现一个算法检查，该检查通过在迭代求解过程中自适应地重缩放泊松控制函数 $P$ 和 $Q$ 来强制执行一个严格为正的最小雅可比值，记作 $J_{\\min} > 0$。计算设置和所有数学表达式都应以纯粹和通用的方式表达，不依赖任何外部文件或特定的物理单位。\n\n从以下基础出发：椭圆网格生成通过一对泊松方程定义了一个从矩形计算域 $(\\xi,\\eta) \\in [0,1] \\times [0,1]$ 到物理域的光滑映射 $(x(\\xi,\\eta), y(\\xi,\\eta))$\n$$\nx_{\\xi\\xi} + x_{\\eta\\eta} = P(\\xi,\\eta), \\qquad y_{\\xi\\xi} + y_{\\eta\\eta} = Q(\\xi,\\eta).\n$$\n变换的雅可比行列式定义为\n$$\nJ(\\xi,\\eta) = x_{\\xi} y_{\\eta} - x_{\\eta} y_{\\xi},\n$$\n一个有效网格的无折叠要求是 $J(\\xi,\\eta) > 0$ 处处成立，且 $J_{\\min} = \\min_{\\xi,\\eta} J(\\xi,\\eta)$ 严格为正。控制函数 $P(\\xi,\\eta)$ 和 $Q(\\xi,\\eta)$ 可用于根据监控函数 $M(\\xi,\\eta)$ 聚集网格点，但过于激进的聚集可能会在没有调节的情况下导致 $J_{\\min}$ 变为负值。\n\n您的任务是：\n- 从第一性原理出发，推导泊松系统在具有 $N_x \\times N_y$ 个点、间距为 $\\Delta \\xi = 1/(N_x-1)$ 和 $\\Delta \\eta = 1/(N_y-1)$ 的均匀计算网格上的有限差分迭代格式。该格式需满足固定的狄利克雷边界条件，这些条件将计算域的边界映射到一个物理域，其上边界由 $y(\\xi,1) = 1 + 0.2 \\sin(2\\pi \\xi)$ 给出，侧边界保持垂直，即 $x(0,\\eta) = 0$, $x(1,\\eta) = 1$, $y(0,\\eta) = \\eta$, $y(1,\\eta) = \\eta$，下边界为 $y(\\xi,0) = 0$, $x(\\xi,0) = \\xi$, $x(\\xi,1) = \\xi$。\n- 定义一个光滑监控函数 $M(\\xi,\\eta) = 1 + \\kappa \\exp\\left(-\\frac{(\\xi-\\xi_c)^2 + (\\eta-\\eta_c)^2}{\\sigma^2}\\right)$，其中心固定为 $(\\xi_c,\\eta_c) = (0.5,0.85)$，宽度为 $\\sigma > 0$，强度为 $\\kappa > 0$。使用控制函数 $P(\\xi,\\eta) = A \\frac{\\partial M}{\\partial \\xi}$ 和 $Q(\\xi,\\eta) = B \\frac{\\partial M}{\\partial \\eta}$，其中的振幅 $A$ 和 $B$ 将被自适应地重缩放以强制 $J_{\\min} > 0$。\n- 制定并实现一个算法检查，在离散泊松求解的若干迭代块之后测量 $J_{\\min}$。如果对于预设阈值 $\\tau > 0$ 有 $J_{\\min} \\le \\tau$，则用一个固定因子 $\\alpha \\in (0,1)$ 对 $(A,B)$ 进行乘法重缩放，即 $(A,B) \\leftarrow (\\alpha A, \\alpha B)$，然后使用减弱后的 $P$ 和 $Q$ 继续迭代求解。这种自适应重缩放必须是单调的，即重复的违规将继续减小 $(A,B)$，直到实现 $J_{\\min} > \\tau$ 或控制函数变得可以忽略不计（此时系统退化为拉普拉斯方程）。\n- 对内部点 $(i,j)$（其中 $i = 1,\\ldots,N_x-2$ 且 $j=1,\\ldots,N_y-2$）使用以下有限差分格式：\n$$\n\\frac{x_{i+1,j} - 2 x_{i,j} + x_{i-1,j}}{\\Delta \\xi^2} + \\frac{x_{i,j+1} - 2 x_{i,j} + x_{i,j-1}}{\\Delta \\eta^2} = P_{i,j},\n$$\n$$\n\\frac{y_{i+1,j} - 2 y_{i,j} + y_{i-1,j}}{\\Delta \\xi^2} + \\frac{y_{i,j+1} - 2 y_{i,j} + y_{i,j-1}}{\\Delta \\eta^2} = Q_{i,j},\n$$\n并推导出 $x_{i,j}$ 和 $y_{i,j}$ 关于其邻近值以及当前 $P_{i,j}$ 和 $Q_{i,j}$ 的相应逐点 Gauss–Seidel 更新。通过中心差分计算 $J_{i,j}$，\n$$\nx_{\\xi}\\big|_{i,j} \\approx \\frac{x_{i+1,j}-x_{i-1,j}}{2\\Delta \\xi}, \\quad x_{\\eta}\\big|_{i,j} \\approx \\frac{x_{i,j+1}-x_{i,j-1}}{2\\Delta \\eta},\n$$\n$$\ny_{\\xi}\\big|_{i,j} \\approx \\frac{y_{i+1,j}-y_{i-1,j}}{2\\Delta \\xi}, \\quad y_{\\eta}\\big|_{i,j} \\approx \\frac{y_{i,j+1}-y_{i,j-1}}{2\\Delta \\eta},\n$$\n然后计算 $J_{i,j} = x_{\\xi}\\big|_{i,j}\\, y_{\\eta}\\big|_{i,j} - x_{\\eta}\\big|_{i,j}\\, y_{\\xi}\\big|_{i,j}$，其中 $J_{\\min}$ 是在所有内部点上取最小值。\n\n将上述内容实现在一个单一程序中，该程序运行四个构成测试套件的测试用例。每个测试用例提供初始控制函数的振幅 $(N_x,N_y)$、$(A_0,B_0)$、阈值 $\\tau$、重缩放因子 $\\alpha$、监控函数宽度 $\\sigma$、监控函数强度 $\\kappa$、每个自适应周期内的 Gauss–Seidel 迭代次数 $N_{\\text{inner}}$ 以及最大自适应周期数 $N_{\\text{outer}}$。程序必须：\n- 按规定初始化网格和边界条件。\n- 在计算网格上计算导数 $\\frac{\\partial M}{\\partial \\xi}$ 和 $\\frac{\\partial M}{\\partial \\eta}$，并使用它们通过当前的 $(A,B)$ 构成 $P$ 和 $Q$。\n- 执行迭代式 Gauss–Seidel 求解，周期性地检查 $J_{\\min}$，并在 $J_{\\min} \\le \\tau$ 时应用自适应重缩放 $(A,B) \\leftarrow (\\alpha A,\\alpha B)$，最多进行 $N_{\\text{outer}}$ 个自适应周期。如果未能实现正定性，则回退到 $(A,B)=(0,0)$ 并执行最后一次内部求解以逼近调和映射。\n- 每个测试用例返回两个量：最终的最小雅可比值 $J_{\\min}$ 和实际应用的重缩放次数（整数）。\n\n使用以下测试套件：\n- 用例 1：$(N_x,N_y)=(32,32)$, $(A_0,B_0)=(1.0,1.0)$, $\\tau=0.02$, $\\alpha=0.7$, $\\sigma=0.18$, $\\kappa=2.0$, $N_{\\text{inner}}=400$, $N_{\\text{outer}}=8$。\n- 用例 2：$(N_x,N_y)=(32,32)$, $(A_0,B_0)=(10.0,10.0)$, $\\tau=0.05$, $\\alpha=0.6$, $\\sigma=0.18$, $\\kappa=3.0$, $N_{\\text{inner}}=600$, $N_{\\text{outer}}=10$。\n- 用例 3：$(N_x,N_y)=(18,18)$, $(A_0,B_0)=(20.0,20.0)$, $\\tau=0.08$, $\\alpha=0.5$, $\\sigma=0.12$, $\\kappa=4.0$, $N_{\\text{inner}}=700$, $N_{\\text{outer}}=12$。\n- 用例 4：$(N_x,N_y)=(32,32)$, $(A_0,B_0)=(0.0,0.0)$, $\\tau=0.02$, $\\alpha=0.7$, $\\sigma=0.18$, $\\kappa=2.0$, $N_{\\text{inner}}=300$, $N_{\\text{outer}}=5$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个用例的条目交替为最终的最小雅可比值 $J_{\\min}$（浮点数）和重缩放次数（整数），并按给定用例的顺序排列。例如，输出格式必须为 $[J_{\\min}^{(1)},n_{\\text{rescale}}^{(1)},J_{\\min}^{(2)},n_{\\text{rescale}}^{(2)},J_{\\min}^{(3)},n_{\\text{rescale}}^{(3)},J_{\\min}^{(4)},n_{\\text{rescale}}^{(4)}]$ 的形式。",
            "solution": "该问题要求设计并实现一个用于椭圆网格生成的自适应算法。核心任务是在一个计算域上求解一个泊松方程组，将其映射到一个物理域，同时确保网格不会发生折叠。这个无折叠约束是通过在整个域上维持一个严格为正的雅可比行列式 $J(\\xi,\\eta) > 0$ 来强制执行的。这是通过自适应地调整影响网格点分布的控制函数 $P(\\xi,\\eta)$ 和 $Q(\\xi,\\eta)$ 来实现的。\n\n该方法的基础是关于物理坐标 $(x, y)$ 作为计算坐标 $(\\xi, \\eta)$ 的函数的两个泊松方程组：\n$$\nx_{\\xi\\xi} + x_{\\eta\\eta} = P(\\xi,\\eta)\n$$\n$$\ny_{\\xi\\xi} + y_{\\eta\\eta} = Q(\\xi,\\eta)\n$$\n其中 $(\\xi, \\eta)$ 定义在单位正方形 $[0,1] \\times [0,1]$ 上。一个有效的网格变换要求雅可比行列式 $J = x_{\\xi} y_{\\eta} - x_{\\eta} y_{\\xi}$ 保持为正。\n\n我们将首先推导求解这些方程的数值格式，然后构建自适应控制算法，最后详细说明实现步骤。\n\n**1. 有限差分离散化与 Gauss-Seidel 格式**\n\n计算域被离散化为一个由 $N_x \\times N_y$ 个点组成的均匀网格，其索引为 $(i,j)$，其中 $i \\in \\{0, 1, \\dots, N_x-1\\}$ 且 $j \\in \\{0, 1, \\dots, N_y-1\\}$。相应的计算坐标为 $\\xi_i = i \\cdot \\Delta\\xi$ 和 $\\eta_j = j \\cdot \\Delta\\eta$，均匀间距为 $\\Delta\\xi = 1/(N_x-1)$ 和 $\\Delta\\eta = 1/(N_y-1)$。\n\n泊松方程中的二阶偏导数在内部网格点 $(i,j)$（对于 $i \\in [1, N_x-2]$ 和 $j \\in [1, N_y-2]$）处使用二阶中心差分公式进行近似：\n$$\n\\frac{\\partial^2 x}{\\partial \\xi^2} \\bigg|_{i,j} \\approx \\frac{x_{i+1,j} - 2x_{i,j} + x_{i-1,j}}{\\Delta\\xi^2}\n$$\n$$\n\\frac{\\partial^2 x}{\\partial \\eta^2} \\bigg|_{i,j} \\approx \\frac{x_{i,j+1} - 2x_{i,j} + x_{i,j-1}}{\\Delta\\eta^2}\n$$\n将这些代入 $x$ 的泊松方程，得到离散方程：\n$$\n\\frac{x_{i+1,j} - 2x_{i,j} + x_{i-1,j}}{\\Delta\\xi^2} + \\frac{x_{i,j+1} - 2x_{i,j} + x_{i,j-1}}{\\Delta\\eta^2} = P_{i,j}\n$$\n为了推导 Gauss-Seidel 方法的迭代更新规则，我们求解中心点 $x_{i,j}$：\n$$\nx_{i,j} \\left( \\frac{2}{\\Delta\\xi^2} + \\frac{2}{\\Delta\\eta^2} \\right) = \\frac{x_{i+1,j} + x_{i-1,j}}{\\Delta\\xi^2} + \\frac{x_{i,j+1} + x_{i,j-1}}{\\Delta\\eta^2} - P_{i,j}\n$$\n$$\nx_{i,j} = \\frac{1}{2\\left(\\frac{1}{\\Delta\\xi^2} + \\frac{1}{\\Delta\\eta^2}\\right)} \\left( \\frac{x_{i+1,j} + x_{i-1,j}}{\\Delta\\xi^2} + \\frac{x_{i,j+1} + x_{i,j-1}}{\\Delta\\eta^2} - P_{i,j} \\right)\n$$\n为提高计算效率，我们可以简化此表达式。令 $\\beta = (\\Delta\\eta / \\Delta\\xi)^2$。将分子和分母同乘以 $\\Delta\\eta^2$ 可得：\n$$\nx_{i,j} = \\frac{\\Delta\\eta^2}{2(1 + \\beta)} \\left( \\frac{\\beta}{\\Delta\\eta^2}(x_{i+1,j} + x_{i-1,j}) + \\frac{1}{\\Delta\\eta^2}(x_{i,j+1} + x_{i,j-1}) - P_{i,j} \\right)\n$$\n$$\nx_{i,j} = \\frac{1}{2(1 + \\beta)} \\left( \\beta(x_{i+1,j} + x_{i-1,j}) + (x_{i,j+1} + x_{i,j-1}) - \\Delta\\eta^2 P_{i,j} \\right)\n$$\nGauss-Seidel 方法通过顺序扫描更新每个内部网格点的 $x_{i,j}$ 和 $y_{i,j}$，使用邻近点的最新计算值。一个迭代步的更新方程为：\n$$\nx_{i,j}^{\\text{new}} = \\frac{1}{2(1 + \\beta)} \\left( \\beta(x_{i+1,j}^{\\text{old}} + x_{i-1,j}^{\\text{new}}) + (x_{i,j+1}^{\\text{old}} + x_{i,j-1}^{\\text{new}}) - \\Delta\\eta^2 P_{i,j} \\right)\n$$\n$$\ny_{i,j}^{\\text{new}} = \\frac{1}{2(1 + \\beta)} \\left( \\beta(y_{i+1,j}^{\\text{old}} + y_{i-1,j}^{\\text{new}}) + (y_{i,j+1}^{\\text{old}} + y_{i,j-1}^{\\text{new}}) - \\Delta\\eta^2 Q_{i,j} \\right)\n$$\n此过程重复指定的迭代次数 $N_{\\text{inner}}$，直到 $x$ 和 $y$ 的解收敛到离散泊松系统的解。\n\n**2. 网格质量控制：雅可比行列式与自适应控制函数**\n\n雅可比行列式 $J=x_\\xi y_\\eta - x_\\eta y_\\xi$ 是从计算空间到物理空间的局部映射的一个度量。负的或零的雅可比值表示网格发生折叠，这在物理上和数值上都是不可接受的。\n\n一阶导数在内部点 $(i,j)$ 处使用中心差分进行近似：\n$$\nx_{\\xi}\\big|_{i,j} \\approx \\frac{x_{i+1,j}-x_{i-1,j}}{2\\Delta \\xi}, \\qquad x_{\\eta}\\big|_{i,j} \\approx \\frac{x_{i,j+1}-x_{i,j-1}}{2\\Delta \\eta}\n$$\n对于 $y_{\\xi}|_{i,j}$ 和 $y_{\\eta}|_{i,j}$ 也是类似的。离散雅可比行列式则为：\n$$\nJ_{i,j} = \\left(\\frac{x_{i+1,j}-x_{i-1,j}}{2\\Delta \\xi}\\right) \\left(\\frac{y_{i,j+1}-y_{i,j-1}}{2\\Delta \\eta}\\right) - \\left(\\frac{x_{i,j+1}-x_{i,j-1}}{2\\Delta \\eta}\\right) \\left(\\frac{y_{i+1,j}-y_{i-1,j}}{2\\Delta \\xi}\\right)\n$$\n网格内部的最小雅可比值 $J_{\\min} = \\min_{i,j} J_{i,j}$，是网格质量的主要度量标准。\n\n控制函数 $P$ 和 $Q$ 用于聚集网格线。它们根据一个监控函数 $M(\\xi,\\eta)$ 定义：\n$$\nP(\\xi,\\eta) = A \\frac{\\partial M}{\\partial \\xi}, \\qquad Q(\\xi,\\eta) = B \\frac{\\partial M}{\\partial \\eta}\n$$\n指定的监控函数是一个高斯分布：\n$$\nM(\\xi,\\eta) = 1 + \\kappa \\exp\\left(-\\frac{(\\xi-\\xi_c)^2 + (\\eta-\\eta_c)^2}{\\sigma^2}\\right)\n$$\n其偏导数为：\n$$\n\\frac{\\partial M}{\\partial \\xi} = -\\frac{2\\kappa(\\xi-\\xi_c)}{\\sigma^2}\\exp\\left(-\\frac{(\\xi-\\xi_c)^2 + (\\eta-\\eta_c)^2}{\\sigma^2}\\right)\n$$\n$$\n\\frac{\\partial M}{\\partial \\eta} = -\\frac{2\\kappa(\\eta-\\eta_c)}{\\sigma^2}\\exp\\left(-\\frac{(\\xi-\\xi_c)^2 + (\\eta-\\eta_c)^2}{\\sigma^2}\\right)\n$$\n振幅 $A$ 和 $B$ 的值过大可能导致激进的网格聚集，这反过来又可能导致 $J_{\\min}$ 变为非正值。\n\n**3. 自适应重缩放算法**\n\n该算法迭代求解泊松系统，同时监控 $J_{\\min}$ 并调整控制函数振幅 $A$ 和 $B$ 以防止网格折叠。步骤如下：\n\n1.  **初始化**：\n    *   离散化计算域并初始化物理网格数组 $x$ 和 $y$。\n    *   设置规定的狄利克雷边界条件。\n    *   为内部点 $x$ 和 $y$ 提供一个初始猜测，通常通过从边界进行线性插值得到。\n    *   计算网格上 $\\frac{\\partial M}{\\partial \\xi}$ 和 $\\frac{\\partial M}{\\partial \\eta}$ 的数组。\n    *   将控制振幅初始化为其起始值 $(A,B) = (A_0, B_0)$，并将重缩放计数器设为 $0$。\n\n2.  **自适应外循环**：最多迭代 $N_{\\text{outer}}$ 个周期。在每个周期中：\n    *   a. **更新控制函数**：使用当前的 $A$ 和 $B$ 值重新计算源项数组 $P_{i,j}$ 和 $Q_{i,j}$。\n    *   b. **迭代求解（内循环）**：执行 $N_{\\text{inner}}$ 次 Gauss-Seidel 格式迭代，以更新内部网格点 $(x_{i,j}, y_{i,j})$。\n    *   c. **雅可比检查**：计算内部网格上的雅可比矩阵 $J_{i,j}$ 并找到其最小值 $J_{\\min}$。\n    *   d. **重缩放**：如果 $J_{\\min} \\le \\tau$（其中 $\\tau > 0$ 是一个安全阈值），则网格质量不足。控制函数过强。我们通过一个乘法因子 $\\alpha \\in (0,1)$ 来减弱它们：\n       $$\n       (A, B) \\leftarrow (\\alpha A, \\alpha B)\n       $$\n       重缩放次数增加。如果 $J_{\\min} > \\tau$，则在下一个周期中保持 $(A,B)$ 的值不变。\n\n3.  **回退机制**：在 $N_{\\text{outer}}$ 个周期完成后，对最后计算出的 $J_{\\min}$ 进行最终检查。如果它仍然小于或等于 $\\tau$，这表示自适应过程在给定约束内未能达到所需的网格质量。在这种情况下，触发回退到调和网格：\n    *   设置 $(A,B) = (0,0)$，这使得 $P=0$ 且 $Q=0$。系统退化为拉普拉斯方程。\n    *   执行最后一次包含 $N_{\\text{inner}}$ 次迭代的 Gauss-Seidel 求解。\n    *   重新计算最终的 $J_{\\min}$。在具有非自相交边界的域上的调和映射（拉普拉斯方程的解）保证是无折叠的，从而确保雅可比值为正。\n\n4.  **输出**：对于每个测试用例，报告最终的 $J_{\\min}$ 和总的乘法重缩放次数。\n\n此算法提供了一种稳健的方法，用于生成能适应监控函数所指定特征的网格，同时系统地防止了在强网格聚集时常见的网格折叠失败。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(Nx, Ny, A0, B0, tau, alpha, sigma, kappa, N_inner, N_outer, xi_c, eta_c):\n    \"\"\"\n    Solves the elliptic grid generation problem for a single test case.\n    \"\"\"\n    # 1. Initialization\n    dxi = 1.0 / (Nx - 1)\n    deta = 1.0 / (Ny - 1)\n    xi = np.linspace(0.0, 1.0, Nx)\n    eta = np.linspace(0.0, 1.0, Ny)\n    XI, ETA = np.meshgrid(xi, eta, indexing='ij')\n\n    x = np.zeros((Nx, Ny))\n    y = np.zeros((Nx, Ny))\n\n    # 2. Set Boundary Conditions\n    # Bottom boundary (eta=0, j=0)\n    x[:, 0] = xi\n    y[:, 0] = 0.0\n    # Top boundary (eta=1, j=Ny-1)\n    x[:, Ny-1] = xi\n    y[:, Ny-1] = 1.0 + 0.2 * np.sin(2.0 * np.pi * xi)\n    # Left boundary (xi=0, i=0)\n    x[0, :] = 0.0\n    y[0, :] = eta\n    # Right boundary (xi=1, i=Nx-1)\n    x[Nx-1, :] = 1.0\n    y[Nx-1, :] = eta\n\n    # Initial guess for interior points (linear interpolation)\n    for j in range(1, Ny - 1):\n        for i in range(1, Nx - 1):\n            x[i, j] = x[i, 0] + ETA[i, j] * (x[i, Ny-1] - x[i, 0])\n            y[i, j] = y[0, j] + XI[i, j] * (y[Nx-1, j] - y[0, j])\n\n    # 3. Pre-compute monitor function derivatives\n    M_arg = -((XI - xi_c)**2 + (ETA - eta_c)**2) / (sigma**2)\n    M_exp = np.exp(M_arg)\n    dM_dxi = -2.0 * kappa * (XI - xi_c) / (sigma**2) * M_exp\n    dM_deta = -2.0 * kappa * (ETA - eta_c) / (sigma**2) * M_exp\n\n    # 4. Adaptive Rescaling Algorithm\n    A, B = A0, B0\n    rescale_count = 0\n    beta = (deta / dxi)**2\n    C = 1.0 / (2.0 * (1.0 + beta))\n    deta2 = deta**2\n\n    final_J_min = 0.0\n\n    for _ in range(N_outer):\n        # Update control functions P and Q\n        P = A * dM_dxi\n        Q = B * dM_deta\n\n        # Inner Gauss-Seidel iterations\n        for _ in range(N_inner):\n            x_old = x.copy()\n            y_old = y.copy()\n            for i in range(1, Nx - 1):\n                for j in range(1, Ny - 1):\n                    x[i, j] = C * (beta * (x_old[i+1, j] + x[i-1, j]) +\n                                   (x_old[i, j+1] + x[i, j-1]) -\n                                   deta2 * P[i, j])\n                    y[i, j] = C * (beta * (y_old[i+1, j] + y[i-1, j]) +\n                                   (y_old[i, j+1] + y[i, j-1]) -\n                                   deta2 * Q[i, j])\n        \n        # Jacobian calculation at interior points\n        x_xi = (x[2:, 1:-1] - x[:-2, 1:-1]) / (2 * dxi)\n        x_eta = (x[1:-1, 2:] - x[1:-1, :-2]) / (2 * deta)\n        y_xi = (y[2:, 1:-1] - y[:-2, 1:-1]) / (2 * dxi)\n        y_eta = (y[1:-1, 2:] - y[1:-1, :-2]) / (2 * deta)\n        \n        J = x_xi * y_eta - x_eta * y_xi\n        J_min = np.min(J)\n        final_J_min = J_min\n\n        # Adaptive step\n        if J_min = tau:\n            A *= alpha\n            B *= alpha\n            rescale_count += 1\n            \n    # 5. Fallback Mechanism if positivity is not achieved\n    if final_J_min = tau:\n        A, B = 0.0, 0.0\n        P = A * dM_dxi # Now zero\n        Q = B * dM_deta # Now zero\n        # Final inner solve for Laplace's equation\n        for _ in range(N_inner):\n            x_old = x.copy()\n            y_old = y.copy()\n            for i in range(1, Nx - 1):\n                for j in range(1, Ny - 1):\n                    x[i, j] = C * (beta * (x_old[i+1, j] + x[i-1, j]) +\n                                   (x_old[i, j+1] + x[i, j-1]) -\n                                   deta2 * P[i, j])\n                    y[i, j] = C * (beta * (y_old[i+1, j] + y[i-1, j]) +\n                                   (y_old[i, j+1] + y[i, j-1]) -\n                                   deta2 * Q[i, j])\n        \n        # Re-compute final Jacobian\n        x_xi = (x[2:, 1:-1] - x[:-2, 1:-1]) / (2 * dxi)\n        x_eta = (x[1:-1, 2:] - x[1:-1, :-2]) / (2 * deta)\n        y_xi = (y[2:, 1:-1] - y[:-2, 1:-1]) / (2 * dxi)\n        y_eta = (y[1:-1, 2:] - y[1:-1, :-2]) / (2 * deta)\n        \n        J = x_xi * y_eta - x_eta * y_xi\n        final_J_min = np.min(J)\n        \n    return final_J_min, rescale_count\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {'Nx': 32, 'Ny': 32, 'A0': 1.0, 'B0': 1.0, 'tau': 0.02, 'alpha': 0.7,\n         'sigma': 0.18, 'kappa': 2.0, 'N_inner': 400, 'N_outer': 8},\n        # Case 2\n        {'Nx': 32, 'Ny': 32, 'A0': 10.0, 'B0': 10.0, 'tau': 0.05, 'alpha': 0.6,\n         'sigma': 0.18, 'kappa': 3.0, 'N_inner': 600, 'N_outer': 10},\n        # Case 3\n        {'Nx': 18, 'Ny': 18, 'A0': 20.0, 'B0': 20.0, 'tau': 0.08, 'alpha': 0.5,\n         'sigma': 0.12, 'kappa': 4.0, 'N_inner': 700, 'N_outer': 12},\n        # Case 4\n        {'Nx': 32, 'Ny': 32, 'A0': 0.0, 'B0': 0.0, 'tau': 0.02, 'alpha': 0.7,\n         'sigma': 0.18, 'kappa': 2.0, 'N_inner': 300, 'N_outer': 5},\n    ]\n\n    results = []\n    monitor_center = (0.5, 0.85)\n\n    for case in test_cases:\n        J_min, n_rescale = run_case(\n            Nx=case['Nx'], Ny=case['Ny'],\n            A0=case['A0'], B0=case['B0'],\n            tau=case['tau'], alpha=case['alpha'],\n            sigma=case['sigma'], kappa=case['kappa'],\n            N_inner=case['N_inner'], N_outer=case['N_outer'],\n            xi_c=monitor_center[0], eta_c=monitor_center[1]\n        )\n        results.append(f\"{J_min:.8f}\")\n        results.append(str(n_rescale))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "除了控制函数，边界条件也对椭圆网格的结构和质量有决定性影响，尤其是在模拟开放流场（如外部空气动力学）时。在计算流体力学中，流出边界通常采用诺伊曼（Neumann）条件来允许流动平稳地离开计算域，而网格也需要适应这种边界行为。本练习将探讨如何应用诺伊曼边界条件来控制流出边界附近的网格线间距和方向 。通过求解具有混合边界条件的拉普拉斯方程并分析所得网格的正交性和间距，您将获得针对复杂流动问题配置高质量网格的实用技能。",
            "id": "3956912",
            "problem": "在计算流体力学 (CFD) 的背景下，要求您分析由泊松方程生成的椭圆网格的近边界行为。考虑一个从计算域到物理域的光滑映射，该映射由两个标量场 $x(\\xi,\\eta)$ 和 $y(\\xi,\\eta)$ 定义，其中 $(\\xi,\\eta) \\in [0,1] \\times [0,1]$ 是无量纲的计算坐标，而 $(x,y)$ 是以米为单位的物理坐标。物理域是一个宽度为 $L_x$、高度为 $L_y$ 的矩形。该网格是通过求解控制函数为零的椭圆网格生成方程的泊松形式生成的，即\n$$\nx_{\\xi\\xi} + x_{\\eta\\eta} = 0, \\quad y_{\\xi\\xi} + y_{\\eta\\eta} = 0,\n$$\n该方程满足三条边上的狄利克雷 (Dirichlet) 边界条件和出口边界上的诺伊曼 (Neumann) 边界条件：\n- 底部边界 ($\\eta=0$)：$x(\\xi,0) = L_x \\,\\xi$, $y(\\xi,0) = 0$。\n- 左侧边界 ($\\xi=0$)：$x(0,\\eta) = 0$, $y(0,\\eta) = L_y \\,\\eta$。\n- 右侧边界 ($\\xi=1$)：$x(1,\\eta) = L_x$, $y(1,\\eta) = L_y \\,\\eta$。\n- 出口边界 (顶部, $\\eta=1$)：恒定的诺伊曼数据 $x_\\eta(\\xi,1) = s_x$，$y_\\eta(\\xi,1) = s_y$，其中 $s_x$ 和 $s_y$ 是指定的常数。\n\n您的任务是：\n1. 在 $\\xi$ 方向有 $N_\\xi$ 个点、$\\eta$ 方向有 $N_\\eta$ 个点的均匀网格上，使用有限差分离散化方法对上述边值问题进行数值求解。使用逐次超松弛 (Successive Over-Relaxation) 法进行迭代求解，直到满足收敛准则。\n2. 沿着出口边界下方的第一个内部行计算近边界正交性度量和间距度量：\n   - 定义度量矢量 $ \\mathbf{g}_\\xi = (x_\\xi, y_\\xi)$ 和 $ \\mathbf{g}_\\eta = (x_\\eta, y_\\eta)$，并用中心差分近似导数。\n   - 网格点的正交性度量为\n     $$\n     \\mathcal{O} = \\frac{\\left| \\mathbf{g}_\\xi \\cdot \\mathbf{g}_\\eta \\right|}{\\lVert \\mathbf{g}_\\xi \\rVert \\,\\lVert \\mathbf{g}_\\eta \\rVert},\n     $$\n     其值在 $[0,1]$ 范围内，对于完全正交的坐标线，该值等于 $0$。\n   - 间距度量是沿同一内部行 $\\lVert \\mathbf{g}_\\eta \\rVert$ 的平均值（以米为单位），它量化了相邻 $\\eta$ 坐标线的平均物理间距。\n3. 对于每个测试用例，输出在紧邻出口边界下方的行（即 $\\eta = 1 - \\Delta \\eta$）上所有内部点计算出的平均正交性度量 $\\overline{\\mathcal{O}}$ 和平均间距 $\\overline{s}$。间距必须以米为单位表示。\n\n在所有测试用例中使用以下固定的物理和数值参数：\n- 物理尺寸：$L_x = 1.0$ 米, $L_y = 0.5$ 米。\n- 网格分辨率：$N_\\xi = 31$, $N_\\eta = 31$。\n- 松弛参数：$\\omega = 1.8$。\n- 收敛容差：每次迭代的最大绝对变化小于 $10^{-10}$。\n- 最大迭代次数：$8000$。\n- 出口边界处的离散诺伊曼条件实施：对于内部点 $i$，施加 $x(i,N_\\eta-1) = x(i,N_\\eta-2) + s_x \\,\\Delta \\eta$ 和 $y(i,N_\\eta-1) = y(i,N_\\eta-2) + s_y \\,\\Delta \\eta$，其中 $\\Delta \\eta = 1/(N_\\eta-1)$，而角点 $(\\xi=0,\\eta=1)$ 和 $(\\xi=1,\\eta=1)$ 保留其狄利克雷值。\n\n测试套件：\n- 案例 1 (基准正交性和间距)：$s_x = 0.0$ 米, $s_y = L_y$ 米。\n- 案例 2 (为降低正交性而有意倾斜)：$s_x = 0.2\\,L_x$ 米, $s_y = L_y$ 米。\n- 案例 3 (出口附近间距压缩)：$s_x = 0.0$ 米, $s_y = 0.5\\,L_y$ 米。\n- 案例 4 (出口附近间距扩大)：$s_x = 0.0$ 米, $s_y = 1.5\\,L_y$ 米。\n\n最终输出规格：\n- 您的程序应产生单行输出，其中包含八个用方括号括起来的逗号分隔的浮点数，对应于 $[\\overline{\\mathcal{O}}_1,\\overline{s}_1,\\overline{\\mathcal{O}}_2,\\overline{s}_2,\\overline{\\mathcal{O}}_3,\\overline{s}_3,\\overline{\\mathcal{O}}_4,\\overline{s}_4]$，其中下标指代以上述顺序列出的测试用例。间距值必须以米为单位。将每个值四舍五入到六位小数。",
            "solution": "该问题要求在一个单位正方形计算域 $(\\xi, \\eta) \\in [0,1] \\times [0,1]$ 上，对一对拉普拉斯方程 $x_{\\xi\\xi} + x_{\\eta\\eta} = 0$ 和 $y_{\\xi\\xi} + y_{\\eta\\eta} = 0$ 进行数值求解。这些方程将计算网格映射到物理网格 $(x,y)$。解受混合狄利克雷 (Dirichlet) 和诺伊曼 (Neumann) 边界条件约束。目标是计算不同出口条件下的网格质量度量。\n\n首先，我们使用有限差分法对控制偏微分方程 (PDE) 进行离散化。计算域被一个包含 $N_\\xi = 31$ 和 $N_\\eta = 31$ 个点的均匀网格所覆盖。计算域中的网格间距为 $\\Delta\\xi = 1/(N_\\xi-1)$ 和 $\\Delta\\eta = 1/(N_\\eta-1)$。由于 $N_\\xi = N_\\eta$，我们有 $\\Delta\\xi = \\Delta\\eta$。设 $x_{i,j} = x(i\\Delta\\xi, j\\Delta\\eta)$ 和 $y_{i,j} = y(i\\Delta\\xi, j\\Delta\\eta)$ 为网格节点 $(i,j)$ 处的物理坐标。\n\n二阶偏导数使用二阶中心差分公式进行近似。对于一个通用函数 $f(\\xi,\\eta)$，在网格点 $(i,j)$ 处的导数为：\n$$\nf_{\\xi\\xi}\\Big|_{i,j} \\approx \\frac{f_{i+1,j} - 2f_{i,j} + f_{i-1,j}}{(\\Delta\\xi)^2}\n$$\n$$\nf_{\\eta\\eta}\\Big|_{i,j} \\approx \\frac{f_{i,j+1} - 2f_{i,j} + f_{i,j-1}}{(\\Delta\\eta)^2}\n$$\n将这些代入 $x$ 的拉普拉斯方程（对 $y$ 也类似），我们得到：\n$$\n\\frac{x_{i+1,j} - 2x_{i,j} + x_{i-1,j}}{(\\Delta\\xi)^2} + \\frac{x_{i,j+1} - 2x_{i,j} + x_{i,j-1}}{(\\Delta\\eta)^2} = 0\n$$\n由于 $\\Delta\\xi = \\Delta\\eta$，在求解 $x_{i,j}$ 时该方程得以简化，从而得到拉普拉斯算子经典的5点模板平均值：\n$$\nx_{i,j} = \\frac{1}{4} (x_{i+1,j} + x_{i-1,j} + x_{i,j+1} + x_{i,j-1})\n$$\n这个线性代数方程将每个内部网格点的值与其四个最近的邻点关联起来。一个相似的方程对 $y_{i,j}$ 也成立。\n\n该线性方程组使用逐次超松弛 (Successive Over-Relaxation, SOR) 方法进行迭代求解。设 $x_{i,j}^{(k)}$ 为第 $k$ 次迭代时的值。第 $k+1$ 次迭代的更新分两步进行。首先，使用最近更新的值计算一个临时的的高斯-赛德尔 (Gauss-Seidel) 值 $\\tilde{x}_{i,j}$：\n$$\n\\tilde{x}_{i,j}^{(k+1)} = \\frac{1}{4} \\left(x_{i+1,j}^{(k)} + x_{i-1,j}^{(k+1)} + x_{i,j+1}^{(k)} + x_{i,j-1}^{(k+1)}\\right)\n$$\n其中我们假设采用标准的逐行逐列扫描。然后，使用松弛参数 $\\omega = 1.8$ 将此值与前一次迭代的值进行混合：\n$$\nx_{i,j}^{(k+1)} = (1-\\omega)x_{i,j}^{(k)} + \\omega \\tilde{x}_{i,j}^{(k+1)}\n$$\n对 $y_{i,j}$ 的过程完全相同。\n\n边界条件按如下方式施加：\n- 在狄利克雷边界（底部：$\\eta=0$；左侧：$\\xi=0$；右侧：$\\xi=1$）上，根据问题说明，$x_{i,j}$ 和 $y_{i,j}$ 的值在所有迭代中都保持固定：$x(\\xi,0) = L_x \\xi$，$y(\\xi,0) = 0$；$x(0,\\eta) = 0$，$y(0,\\eta) = L_y \\eta$；$x(1,\\eta) = L_x$，$y(1,\\eta) = L_y \\eta$。\n- 在诺伊曼边界（顶部：$\\eta=1$）上，施加法向导数条件。对于 $x_\\eta(\\xi,1) = s_x$，我们在边界节点 $j = N_\\eta-1$ 处使用一阶前向差分近似：\n$$\n\\frac{x_{i, N_\\eta-1} - x_{i, N_\\eta-2}}{\\Delta\\eta} = s_x\n$$\n这给出了边界值的更新规则，$x_{i, N_\\eta-1} = x_{i, N_\\eta-2} + s_x \\Delta\\eta$，该规则在每次 SOR 迭代中应用于所有内部点 $i \\in [1, N_\\xi-2]$。类似的规则也适用于 $y$。如问题所述，角点保留其狄利克雷值。\n\n迭代过程持续进行，直到连续迭代之间任何网格坐标的最大绝对变化量小于容差 $10^{-10}$，即 $\\max(|x^{(k+1)}-x^{(k)}|, |y^{(k+1)}-y^{(k)}|)  10^{-10}$。\n\n收敛后，我们在出口边界下方的第一个内部行，即 $\\eta = 1-\\Delta\\eta$（网格索引 $j = N_\\eta-2$）处，为所有内部点 $i \\in [1, N_\\xi-2]$ 计算网格质量度量。度量矢量 $\\mathbf{g}_\\xi = (x_\\xi, y_\\xi)$ 和 $\\mathbf{g}_\\eta = (x_\\eta, y_\\eta)$ 使用二阶中心差分计算：\n$$\nx_\\xi\\Big|_{i,j} = \\frac{x_{i+1,j} - x_{i-1,j}}{2\\Delta\\xi}, \\quad y_\\xi\\Big|_{i,j} = \\frac{y_{i+1,j} - y_{i-1,j}}{2\\Delta\\xi}\n$$\n$$\nx_\\eta\\Big|_{i,j} = \\frac{x_{i,j+1} - x_{i,j-1}}{2\\Delta\\eta}, \\quad y_\\eta\\Big|_{i,j} = \\frac{y_{i,j+1} - y_{i,j-1}}{2\\Delta\\eta}\n$$\n每个点的正交性度量 $\\mathcal{O}$ 和间距度量（$\\mathbf{g}_\\eta$ 的范数）为：\n$$\n\\mathcal{O}_{i,j} = \\frac{\\left| \\mathbf{g}_\\xi \\cdot \\mathbf{g}_\\eta \\right|}{\\lVert \\mathbf{g}_\\xi \\rVert \\,\\lVert \\mathbf{g}_\\eta \\rVert} = \\frac{|x_\\xi x_\\eta + y_\\xi y_\\eta|}{\\sqrt{x_\\xi^2+y_\\xi^2}\\sqrt{x_\\eta^2+y_\\eta^2}}, \\quad s_{i,j} = \\lVert \\mathbf{g}_\\eta \\rVert = \\sqrt{x_\\eta^2 + y_\\eta^2}\n$$\n最终报告的值 $\\overline{\\mathcal{O}}$ 和 $\\overline{s}$ 分别是 $\\mathcal{O}_{i,j}$ 和 $s_{i,j}$ 在行 $j = N_\\eta-2$ 上的内部点 $i \\in [1, N_\\xi-2]$ 的算术平均值。对四个测试用例中的每一个重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_grid_and_get_metrics(Lx, Ly, N_xi, N_eta, sx, sy, omega, tol, max_iter):\n    \"\"\"\n    Solves the elliptic grid generation problem and computes metrics.\n    \"\"\"\n    # 1. Grid Setup\n    d_xi = 1.0 / (N_xi - 1)\n    d_eta = 1.0 / (N_eta - 1)\n    \n    xi = np.linspace(0, 1, N_xi)\n    eta = np.linspace(0, 1, N_eta)\n\n    x = np.zeros((N_eta, N_xi))\n    y = np.zeros((N_eta, N_xi))\n\n    # 2. Boundary Conditions\n    # Dirichlet BCs on bottom, left, and right boundaries\n    x[0, :] = Lx * xi\n    y[0, :] = 0.0\n    \n    x[:, 0] = 0.0\n    y[:, 0] = Ly * eta\n    \n    x[:, N_xi - 1] = Lx\n    y[:, N_xi - 1] = Ly * eta\n\n    # 3. Iterative Solver (SOR)\n    # The coefficient for the simplified 5-point stencil is 0.25 since d_xi = d_eta\n    stencil_coeff = 0.25\n\n    for k in range(max_iter):\n        x_old = x.copy()\n        y_old = y.copy()\n\n        # Update interior points (j from 1 to N_eta-2, i from 1 to N_xi-2)\n        for j in range(1, N_eta - 1):\n            for i in range(1, N_xi - 1):\n                # Gauss-Seidel intermediate value calculation\n                x_gs = stencil_coeff * (x[j, i+1] + x[j, i-1] + x[j+1, i] + x[j-1, i])\n                y_gs = stencil_coeff * (y[j, i+1] + y[j, i-1] + y[j+1, i] + y[j-1, i])\n                \n                # SOR update\n                x[j, i] = (1 - omega) * x_old[j, i] + omega * x_gs\n                y[j, i] = (1 - omega) * y_old[j, i] + omega * y_gs\n        \n        # Update top Neumann boundary (interior nodes: i from 1 to N_xi-2)\n        for i in range(1, N_xi - 1):\n            x[N_eta - 1, i] = x[N_eta - 2, i] + sx * d_eta\n            y[N_eta - 1, i] = y[N_eta - 2, i] + sy * d_eta\n            \n        # Check for convergence\n        max_change = max(np.max(np.abs(x - x_old)), np.max(np.abs(y - y_old)))\n        \n        if max_change  tol:\n            break\n\n    # 4. Metric Calculation\n    # Metrics are computed on the interior row just below the outflow (j = N_eta - 2)\n    j_row = N_eta - 2\n    ortho_metrics = []\n    spacing_metrics = []\n\n    # Iterate over interior points of that row (i from 1 to N_xi-2)\n    for i in range(1, N_xi - 1):\n        # Central differences for derivatives\n        x_xi = (x[j_row, i+1] - x[j_row, i-1]) / (2 * d_xi)\n        y_xi = (y[j_row, i+1] - y[j_row, i-1]) / (2 * d_xi)\n        x_eta = (x[j_row+1, i] - x[j_row-1, i]) / (2 * d_eta)\n        y_eta = (y[j_row+1, i] - y[j_row-1, i]) / (2 * d_eta)\n\n        # Metric vector components\n        g_xi_dot_g_eta = x_xi * x_eta + y_xi * y_eta\n        norm_g_xi = np.sqrt(x_xi**2 + y_xi**2)\n        norm_g_eta = np.sqrt(x_eta**2 + y_eta**2)\n\n        # Orthogonality metric\n        if norm_g_xi > 1e-12 and norm_g_eta > 1e-12: # Avoid division by zero\n            ortho = np.abs(g_xi_dot_g_eta) / (norm_g_xi * norm_g_eta)\n        else:\n            ortho = 0.0 # Define as 0 for degenerate cases\n        ortho_metrics.append(ortho)\n        \n        # Spacing metric is the norm of g_eta\n        spacing_metrics.append(norm_g_eta)\n\n    # Compute mean values\n    mean_ortho = np.mean(ortho_metrics)\n    mean_spacing = np.mean(spacing_metrics)\n\n    return mean_ortho, mean_spacing\n\n\ndef solve():\n    # Define the fixed physical and numerical parameters from the problem statement.\n    Lx = 1.0\n    Ly = 0.5\n    N_xi = 31\n    N_eta = 31\n    omega = 1.8\n    tol = 1e-10\n    max_iter = 8000\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (s_x, s_y)\n        (0.0, Ly),                  # Case 1\n        (0.2 * Lx, Ly),             # Case 2\n        (0.0, 0.5 * Ly),            # Case 3\n        (0.0, 1.5 * Ly)             # Case 4\n    ]\n\n    results = []\n    for sx, sy in test_cases:\n        mean_ortho, mean_spacing = solve_grid_and_get_metrics(Lx, Ly, N_xi, N_eta, sx, sy, omega, tol, max_iter)\n        results.extend([mean_ortho, mean_spacing])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{v:.6f}\" for v in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}