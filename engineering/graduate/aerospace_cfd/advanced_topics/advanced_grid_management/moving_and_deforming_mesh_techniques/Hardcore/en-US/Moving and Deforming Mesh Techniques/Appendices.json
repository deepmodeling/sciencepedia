{
    "hands_on_practices": [
        {
            "introduction": "For a moving mesh simulation to be physically meaningful, the numerical scheme must satisfy a critical condition known as the Geometric Conservation Law (GCL). This law ensures that the rate of change of a cell's volume is perfectly accounted for by the movement of its boundaries, preventing the scheme from artificially creating or destroying conserved quantities in a uniform flow. This first-principles exercise guides you through a fundamental verification of the GCL, connecting the kinematic definition of area change to the integrated flux of boundary velocity for a simple deforming element .",
            "id": "3977453",
            "problem": "Consider a single planar triangular control volume (cell) in a two-dimensional unsteady mesh used in Computational Fluid Dynamics (CFD). The triangle has counterclockwise-ordered vertices with positions $\\boldsymbol{A}=(x_A,y_A)$, $\\boldsymbol{B}=(x_B,y_B)$, and $\\boldsymbol{C}=(x_C,y_C)$, and mesh-point velocities at these vertices given by $\\boldsymbol{w}_A=(u_A,v_A)$, $\\boldsymbol{w}_B=(u_B,v_B)$, and $\\boldsymbol{w}_C=(u_C,v_C)$. The mesh velocity along each straight edge is assumed to vary linearly with arc length between its endpoint vertex velocities. Let the outward unit normal along each edge be well-defined and constant over that straight edge.\n\nStarting from the Reynolds transport theorem and fundamental kinematics, derive the relationship between the instantaneous rate of change of the cell area and the outward-normal component of the mesh velocity integrated along the cell boundary. Use this to obtain an exact expression, under the linear edge-velocity assumption, for the area time derivative in terms of known geometric edge quantities and vertex velocities (an “edge sweep”).\n\nThen, for the specific triangle with vertex coordinates $\\boldsymbol{A}=(0,0)$, $\\boldsymbol{B}=(2,0)$, and $\\boldsymbol{C}=(0,3)$, and vertex velocities $\\boldsymbol{w}_A=(0.5,-0.2)$, $\\boldsymbol{w}_B=(0.1,0.3)$, and $\\boldsymbol{w}_C=(-0.4,0.0)$ (in meters per second), compute the instantaneous area time derivative in two ways: (i) by evaluating the boundary sweep integral exactly along each edge under the given linearity assumption, and (ii) by differentiating the oriented polygon area with respect to time using the vertex velocities. Confirm the equality of these two values to demonstrate the Geometric Conservation Law (GCL).\n\nProvide the final numerical value of the instantaneous rate of change of the cell area. Round your answer to four significant figures. Express the final rate in square meters per second.",
            "solution": "The problem requires the derivation and verification of the Geometric Conservation Law (GCL) for a deforming triangular cell in two dimensions. The GCL mandates that the rate of change of a control volume's geometric measure (area in 2D, volume in 3D) must be equal to the integrated flux of the boundary velocity. We will first derive this relationship from fundamental principles, then apply it to a specific numerical case.\n\nThe first step is to establish the general kinematic relationship between the rate of change of an area and the velocity of its boundary. This is a direct application of the Reynolds Transport Theorem for a moving control area $A(t)$ with a boundary $\\partial A(t)$. The theorem states that for a scalar field $f(\\boldsymbol{r}, t)$, the total time derivative of its integral over $A(t)$ is given by:\n$$ \\frac{d}{dt} \\int_{A(t)} f \\, dA = \\int_{A(t)} \\frac{\\partial f}{\\partial t} \\, dA + \\oint_{\\partial A(t)} f (\\boldsymbol{w} \\cdot \\boldsymbol{n}) \\, ds $$\nwhere $\\boldsymbol{w}$ is the velocity of the boundary, $\\boldsymbol{n}$ is the outward unit normal to the boundary, and $ds$ is the differential arc length along the boundary.\n\nTo find the rate of change of the area itself, we choose the scalar field to be unity, i.e., $f=1$. The integral of $f=1$ over the area $A(t)$ is simply the area $A$.\n$$ \\int_{A(t)} 1 \\cdot dA = A(t) $$\nTherefore, the left-hand side of the Reynolds Transport Theorem becomes $\\frac{d}{dt}A(t)$, or simply $\\frac{dA}{dt}$.\n\nOn the right-hand side, the first term involves the partial time derivative of $f=1$, which is zero:\n$$ \\int_{A(t)} \\frac{\\partial (1)}{\\partial t} \\, dA = \\int_{A(t)} 0 \\, dA = 0 $$\nThe second term, the boundary integral, becomes:\n$$ \\oint_{\\partial A(t)} 1 \\cdot (\\boldsymbol{w} \\cdot \\boldsymbol{n}) \\, ds = \\oint_{\\partial A(t)} (\\boldsymbol{w} \\cdot \\boldsymbol{n}) \\, ds $$\nEquating the left and right sides, we obtain the fundamental kinematic expression for the rate of change of area:\n$$ \\frac{dA}{dt} = \\oint_{\\partial A(t)} (\\boldsymbol{w} \\cdot \\boldsymbol{n}) \\, ds $$\nThis equation states that the rate of area change is the flux of the boundary velocity normal to the boundary, integrated over the entire boundary.\n\nNext, we evaluate this boundary integral for the given triangular cell with vertices $\\boldsymbol{A}$, $\\boldsymbol{B}$, and $\\boldsymbol{C}$. The boundary $\\partial A$ is composed of three straight edges: $\\boldsymbol{AB}$, $\\boldsymbol{BC}$, and $\\boldsymbol{CA}$. The integral is thus a sum of three line integrals:\n$$ \\frac{dA}{dt} = \\int_{AB} (\\boldsymbol{w} \\cdot \\boldsymbol{n}_{AB}) \\, ds + \\int_{BC} (\\boldsymbol{w} \\cdot \\boldsymbol{n}_{BC}) \\, ds + \\int_{CA} (\\boldsymbol{w} \\cdot \\boldsymbol{n}_{CA}) \\, ds $$\nThe problem states that the mesh velocity $\\boldsymbol{w}$ varies linearly along each edge. Let's consider a generic edge from vertex $\\boldsymbol{P}_1$ to vertex $\\boldsymbol{P}_2$, with length $L$ and vertex velocities $\\boldsymbol{w}_1$ and $\\boldsymbol{w}_2$. Let $s$ be the arc length along the edge, from $s=0$ at $\\boldsymbol{P}_1$ to $s=L$ at $\\boldsymbol{P}_2$. The linear interpolation for the velocity is:\n$$ \\boldsymbol{w}(s) = \\boldsymbol{w}_1 \\left(1 - \\frac{s}{L}\\right) + \\boldsymbol{w}_2 \\left(\\frac{s}{L}\\right) $$\nThe outward unit normal $\\boldsymbol{n}$ is constant along a straight edge. The contribution from this edge to the rate of area change is:\n$$ \\int_0^L \\left[ \\boldsymbol{w}_1 \\left(1 - \\frac{s}{L}\\right) + \\boldsymbol{w}_2 \\left(\\frac{s}{L}\\right) \\right] \\cdot \\boldsymbol{n} \\, ds $$\nSince $\\boldsymbol{w}_1$, $\\boldsymbol{w}_2$, and $\\boldsymbol{n}$ are constant with respect to $s$, we can rearrange the integral:\n$$ (\\boldsymbol{w}_1 \\cdot \\boldsymbol{n}) \\int_0^L \\left(1 - \\frac{s}{L}\\right) ds + (\\boldsymbol{w}_2 \\cdot \\boldsymbol{n}) \\int_0^L \\frac{s}{L} \\, ds $$\nEvaluating the simple integrals:\n$$ \\int_0^L \\left(1 - \\frac{s}{L}\\right) ds = \\left[s - \\frac{s^2}{2L}\\right]_0^L = L - \\frac{L^2}{2L} = \\frac{L}{2} $$\n$$ \\int_0^L \\frac{s}{L} \\, ds = \\left[\\frac{s^2}{2L}\\right]_0^L = \\frac{L^2}{2L} = \\frac{L}{2} $$\nSubstituting these results back, the contribution from one edge is:\n$$ (\\boldsymbol{w}_1 \\cdot \\boldsymbol{n}) \\frac{L}{2} + (\\boldsymbol{w}_2 \\cdot \\boldsymbol{n}) \\frac{L}{2} = \\frac{L}{2} (\\boldsymbol{w}_1 + \\boldsymbol{w}_2) \\cdot \\boldsymbol{n} $$\nThis result is intuitive: the rate of area swept by an edge is its length multiplied by the average of the normal velocity components at its endpoints. The total rate of change of the cell's area is the sum of these \"edge sweep\" terms for all three edges:\n$$ \\frac{dA}{dt} = \\frac{L_{AB}}{2}(\\boldsymbol{w}_A + \\boldsymbol{w}_B) \\cdot \\boldsymbol{n}_{AB} + \\frac{L_{BC}}{2}(\\boldsymbol{w}_B + \\boldsymbol{w}_C) \\cdot \\boldsymbol{n}_{BC} + \\frac{L_{CA}}{2}(\\boldsymbol{w}_C + \\boldsymbol{w}_A) \\cdot \\boldsymbol{n}_{CA} $$\nThis is the expression we will evaluate for method (i).\n\nNow, we will perform the two specified calculations for the given triangle.\nThe vertices are $\\boldsymbol{A}=(0,0)$, $\\boldsymbol{B}=(2,0)$, $\\boldsymbol{C}=(0,3)$.\nThe vertex velocities are $\\boldsymbol{w}_A=(0.5,-0.2)$, $\\boldsymbol{w}_B=(0.1,0.3)$, and $\\boldsymbol{w}_C=(-0.4,0.0)$, in units of m/s.\n\n(i) Calculation via the boundary sweep integral:\nWe need the geometric properties of each edge. The vertices are ordered counter-clockwise. For an edge from $(x_1, y_1)$ to $(x_2, y_2)$, the edge vector is $(\\Delta x, \\Delta y) = (x_2-x_1, y_2-y_1)$, and the outward normal vector is proportional to $(\\Delta y, -\\Delta x)$.\n\nEdge $\\boldsymbol{AB}$: from $\\boldsymbol{A}=(0,0)$ to $\\boldsymbol{B}=(2,0)$.\nEdge vector $\\vec{AB} = (2,0)$. Length $L_{AB} = \\sqrt{2^2+0^2}=2$.\nOutward normal is proportional to $(0,-2)$. The unit normal is $\\boldsymbol{n}_{AB}=(0,-1)$.\nThe velocity term is $\\frac{1}{2}(\\boldsymbol{w}_A + \\boldsymbol{w}_B) = \\frac{1}{2}((0.5, -0.2) + (0.1, 0.3)) = \\frac{1}{2}(0.6, 0.1) = (0.3, 0.05)$.\nContribution: $L_{AB} \\left( \\frac{\\boldsymbol{w}_A + \\boldsymbol{w}_B}{2} \\cdot \\boldsymbol{n}_{AB} \\right) = 2 \\cdot ((0.3, 0.05) \\cdot (0,-1)) = 2 \\cdot (0 - 0.05) = -0.1$.\n\nEdge $\\boldsymbol{BC}$: from $\\boldsymbol{B}=(2,0)$ to $\\boldsymbol{C}=(0,3)$.\nEdge vector $\\vec{BC} = (-2,3)$. Length $L_{BC} = \\sqrt{(-2)^2+3^2}=\\sqrt{13}$.\nOutward normal is proportional to $(3, -(-2))=(3,2)$. The unit normal is $\\boldsymbol{n}_{BC}=\\frac{1}{\\sqrt{13}}(3,2)$.\nThe velocity term is $\\frac{1}{2}(\\boldsymbol{w}_B + \\boldsymbol{w}_C) = \\frac{1}{2}((0.1, 0.3) + (-0.4, 0.0)) = \\frac{1}{2}(-0.3, 0.3) = (-0.15, 0.15)$.\nContribution: $L_{BC} \\left( \\frac{\\boldsymbol{w}_B + \\boldsymbol{w}_C}{2} \\cdot \\boldsymbol{n}_{BC} \\right) = \\sqrt{13} \\cdot ((-0.15, 0.15) \\cdot \\frac{1}{\\sqrt{13}}(3,2)) = (-0.15)(3) + (0.15)(2) = -0.45 + 0.30 = -0.15$.\n\nEdge $\\boldsymbol{CA}$: from $\\boldsymbol{C}=(0,3)$ to $\\boldsymbol{A}=(0,0)$.\nEdge vector $\\vec{CA} = (0,-3)$. Length $L_{CA} = \\sqrt{0^2+(-3)^2}=3$.\nOutward normal is proportional to $(-3, -0)=(-3,0)$. The unit normal is $\\boldsymbol{n}_{CA}=(-1,0)$.\nThe velocity term is $\\frac{1}{2}(\\boldsymbol{w}_C + \\boldsymbol{w}_A) = \\frac{1}{2}((-0.4, 0.0) + (0.5, -0.2)) = \\frac{1}{2}(0.1, -0.2) = (0.05, -0.1)$.\nContribution: $L_{CA} \\left( \\frac{\\boldsymbol{w}_C + \\boldsymbol{w}_A}{2} \\cdot \\boldsymbol{n}_{CA} \\right) = 3 \\cdot ((0.05, -0.1) \\cdot (-1,0)) = 3 \\cdot (-0.05 + 0) = -0.15$.\n\nTotal rate of area change is the sum of the contributions:\n$$ \\frac{dA}{dt} = -0.1 - 0.15 - 0.15 = -0.4 \\, \\text{m}^2/\\text{s} $$\n\n(ii) Calculation by differentiating the area formula:\nThe area of a triangle with vertices $(x_A, y_A)$, $(x_B, y_B)$, and $(x_C, y_C)$ can be calculated using the shoelace formula. For counter-clockwise ordering, this is:\n$$ A = \\frac{1}{2} \\left[ (x_A y_B - x_B y_A) + (x_B y_C - x_C y_B) + (x_C y_A - x_A y_C) \\right] $$\nThe coordinates are functions of time. Differentiating with respect to time $t$, and using $\\dot{x}=u$ and $\\dot{y}=v$:\n$$ \\frac{dA}{dt} = \\frac{1}{2} \\left[ (\\dot{x}_A y_B + x_A \\dot{y}_B - \\dot{x}_B y_A - x_B \\dot{y}_A) + (\\dot{x}_B y_C + x_B \\dot{y}_C - \\dot{x}_C y_B - x_C \\dot{y}_B) + (\\dot{x}_C y_A + x_C \\dot{y}_A - \\dot{x}_A y_C - x_A \\dot{y}_C) \\right] $$\n$$ \\frac{dA}{dt} = \\frac{1}{2} \\left[ (u_A y_B + x_A v_B - u_B y_A - x_B v_A) + (u_B y_C + x_B v_C - u_C y_B - x_C v_B) + (u_C y_A + x_C v_A - u_A y_C - x_A v_C) \\right] $$\nGrouping terms by velocity components:\n$$ \\frac{dA}{dt} = \\frac{1}{2} \\left[ u_A(y_B - y_C) + u_B(y_C - y_A) + u_C(y_A - y_B) + v_A(x_C - x_B) + v_B(x_A - x_C) + v_C(x_B - x_A) \\right] $$\nNow we substitute the given numerical values:\n$\\boldsymbol{A}=(0,0)$, $\\boldsymbol{B}=(2,0)$, $\\boldsymbol{C}=(0,3)$.\n$\\boldsymbol{w}_A=(0.5,-0.2)$, $\\boldsymbol{w}_B=(0.1,0.3)$, $\\boldsymbol{w}_C=(-0.4,0.0)$.\n$$ \\frac{dA}{dt} = \\frac{1}{2} [ 0.5(0-3) + 0.1(3-0) + (-0.4)(0-0) + (-0.2)(0-2) + 0.3(0-0) + 0.0(2-0) ] $$\n$$ \\frac{dA}{dt} = \\frac{1}{2} [ 0.5(-3) + 0.1(3) + 0 + (-0.2)(-2) + 0 + 0 ] $$\n$$ \\frac{dA}{dt} = \\frac{1}{2} [ -1.5 + 0.3 + 0.4 ] $$\n$$ \\frac{dA}{dt} = \\frac{1}{2} [ -0.8 ] = -0.4 \\, \\text{m}^2/\\text{s} $$\n\nBoth calculation methods yield the same result, $\\frac{dA}{dt} = -0.4 \\, \\text{m}^2/\\text{s}$. This equality numerically verifies the Geometric Conservation Law for the given moving triangular element under the assumption of linear velocity variation along edges. The instantaneous rate of change of the cell area is negative, indicating that the triangle is shrinking. Rounding to four significant figures, the result is $-0.4000$.",
            "answer": "$$ \\boxed{-0.4000} $$"
        },
        {
            "introduction": "Beyond satisfying conservation laws, a deforming mesh must remain geometrically valid, meaning that cells cannot invert or turn \"inside-out.\" This non-physical tangling, which would crash a simulation, is mathematically equivalent to the local volume of a cell becoming zero or negative. This practice explores the heart of this constraint by linking the mesh displacement field to the Jacobian determinant of the coordinate transformation, which represents the local volume ratio. You will derive the conditions that guarantee a valid mesh and determine the maximum allowable deformation amplitude before the mesh quality breaks down .",
            "id": "3977458",
            "problem": "In an Arbitrary Lagrangian–Eulerian (ALE) mesh motion used in Computational Fluid Dynamics (CFD), a reference configuration with coordinates $\\mathbf{x} \\in \\Omega \\subset \\mathbb{R}^{3}$ is mapped to a deformed configuration by $\\boldsymbol{\\Phi}(\\mathbf{x}) = \\mathbf{x} + \\mathbf{d}(\\mathbf{x})$, where the displacement field $\\mathbf{d} : \\Omega \\to \\mathbb{R}^{3}$ is continuously differentiable. Consider the cube $\\Omega = (0,L)^{3}$ with $L > 0$, and the separable trigonometric displacement\n$$\n\\mathbf{d}(\\mathbf{x}) = \\begin{pmatrix}\nA \\sin\\!\\big(\\pi x_{1}/L\\big) \\\\\nA \\sin\\!\\big(\\pi x_{2}/L\\big) \\\\\nA \\sin\\!\\big(\\pi x_{3}/L\\big)\n\\end{pmatrix},\n$$\nwhere $A \\in \\mathbb{R}$ is an amplitude parameter with the physical dimension of length. Starting from the change-of-variables theorem for volume integrals and the definition of the Jacobian matrix of $\\boldsymbol{\\Phi}$, perform the following:\n\n1. Derive the local volume ratio $J(\\mathbf{x})$ in terms of the Jacobian matrix of $\\boldsymbol{\\Phi}$, and express it in the form $J(\\mathbf{x}) = \\det\\!\\big(\\mathbf{I} + \\nabla \\mathbf{d}(\\mathbf{x})\\big)$, where $\\mathbf{I}$ is the identity tensor and $\\nabla \\mathbf{d}$ is the displacement gradient.\n\n2. Compute $J(\\mathbf{x})$ explicitly for the given $\\mathbf{d}(\\mathbf{x})$ on $\\Omega$.\n\n3. From first principles of matrix analysis, derive a condition on the eigenvalues of $\\nabla \\mathbf{d}(\\mathbf{x})$ that guarantees strictly positive local volume everywhere, i.e., $J(\\mathbf{x}) > 0$ for all $\\mathbf{x} \\in \\Omega$. Then, use this to obtain a general sufficient condition of the form $\\|\\nabla \\mathbf{d}(\\mathbf{x})\\|_{2}  c$ (with an appropriate constant $c$) that ensures $J(\\mathbf{x}) > 0$ everywhere for an arbitrary continuously differentiable $\\mathbf{d}$.\n\n4. Specialize your result to the given $\\mathbf{d}(\\mathbf{x})$ and determine the largest amplitude $A_{\\max}$ such that $J(\\mathbf{x}) > 0$ for all $\\mathbf{x} \\in \\Omega$. Provide $A_{\\max}$ as an exact expression in terms of $L$.\n\nExpress your final answer for $A_{\\max}$ in meters, and do not round it.",
            "solution": "The problem is divided into four parts. We will address them sequentially.\n\n**Part 1: Derivation of the Local Volume Ratio**\n\nThe mapping from the reference configuration coordinate $\\mathbf{x}$ to the deformed configuration coordinate $\\boldsymbol{\\Phi}(\\mathbf{x})$ is given by $\\boldsymbol{\\Phi}(\\mathbf{x}) = \\mathbf{x} + \\mathbf{d}(\\mathbf{x})$. The local change in volume is characterized by the Jacobian of this transformation. The tensor that maps infinitesimal line elements from the reference to the deformed configuration is the deformation gradient tensor, $\\mathbf{F}$, defined as:\n$$\n\\mathbf{F}(\\mathbf{x}) = \\nabla_{\\mathbf{x}} \\boldsymbol{\\Phi}(\\mathbf{x})\n$$\nIn component form, this is $F_{ij} = \\frac{\\partial \\Phi_i}{\\partial x_j}$. Substituting the definition of $\\boldsymbol{\\Phi}$:\n$$\nF_{ij} = \\frac{\\partial}{\\partial x_j} (x_i + d_i(\\mathbf{x})) = \\frac{\\partial x_i}{\\partial x_j} + \\frac{\\partial d_i}{\\partial x_j}\n$$\nThe term $\\frac{\\partial x_i}{\\partial x_j}$ is the Kronecker delta, $\\delta_{ij}$, which is the component representation of the identity tensor $\\mathbf{I}$. The term $\\frac{\\partial d_i}{\\partial x_j}$ is the component representation of the displacement gradient tensor, $\\nabla \\mathbf{d}(\\mathbf{x})$. Therefore, in tensor notation:\n$$\n\\mathbf{F}(\\mathbf{x}) = \\mathbf{I} + \\nabla \\mathbf{d}(\\mathbf{x})\n$$\nThe change of variables theorem for volume integrals states that an infinitesimal volume element $dV$ in the deformed configuration is related to the corresponding infinitesimal volume element $dV_0$ in the reference configuration by:\n$$\ndV = J(\\mathbf{x}) dV_0\n$$\nwhere $J(\\mathbf{x})$ is the local volume ratio, defined as the determinant of the deformation gradient tensor:\n$$\nJ(\\mathbf{x}) = \\det(\\mathbf{F}(\\mathbf{x}))\n$$\nSubstituting the expression for $\\mathbf{F}(\\mathbf{x})$, we arrive at the desired form:\n$$\nJ(\\mathbf{x}) = \\det(\\mathbf{I} + \\nabla \\mathbf{d}(\\mathbf{x}))\n$$\n\n**Part 2: Explicit Computation of $J(\\mathbf{x})$**\n\nThe given displacement field is $\\mathbf{d}(\\mathbf{x}) = (d_1, d_2, d_3)^T$, where $d_1 = A \\sin(\\pi x_1/L)$, $d_2 = A \\sin(\\pi x_2/L)$, and $d_3 = A \\sin(\\pi x_3/L)$. We must first compute the displacement gradient tensor $\\nabla \\mathbf{d}$, whose components are $(\\nabla \\mathbf{d})_{ij} = \\frac{\\partial d_i}{\\partial x_j}$.\n\nThe partial derivatives are:\n$$\n\\frac{\\partial d_1}{\\partial x_1} = \\frac{\\partial}{\\partial x_1} \\left( A \\sin\\left(\\frac{\\pi x_1}{L}\\right) \\right) = A \\frac{\\pi}{L} \\cos\\left(\\frac{\\pi x_1}{L}\\right)\n$$\n$$\n\\frac{\\partial d_1}{\\partial x_2} = 0, \\quad \\frac{\\partial d_1}{\\partial x_3} = 0\n$$\nSimilarly, for $d_2$ and $d_3$:\n$$\n\\frac{\\partial d_2}{\\partial x_2} = A \\frac{\\pi}{L} \\cos\\left(\\frac{\\pi x_2}{L}\\right), \\quad \\frac{\\partial d_2}{\\partial x_1} = 0, \\quad \\frac{\\partial d_2}{\\partial x_3} = 0\n$$\n$$\n\\frac{\\partial d_3}{\\partial x_3} = A \\frac{\\pi}{L} \\cos\\left(\\frac{\\pi x_3}{L}\\right), \\quad \\frac{\\partial d_3}{\\partial x_1} = 0, \\quad \\frac{\\partial d_3}{\\partial x_2} = 0\n$$\nThus, the displacement gradient tensor $\\nabla \\mathbf{d}$ is a diagonal matrix:\n$$\n\\nabla \\mathbf{d}(\\mathbf{x}) = \\begin{pmatrix}\nA \\frac{\\pi}{L} \\cos\\left(\\frac{\\pi x_1}{L}\\right)  0  0 \\\\\n0  A \\frac{\\pi}{L} \\cos\\left(\\frac{\\pi x_2}{L}\\right)  0 \\\\\n0  0  A \\frac{\\pi}{L} \\cos\\left(\\frac{\\pi x_3}{L}\\right)\n\\end{pmatrix}\n$$\nThe deformation gradient is $\\mathbf{F} = \\mathbf{I} + \\nabla \\mathbf{d}$:\n$$\n\\mathbf{F}(\\mathbf{x}) = \\begin{pmatrix}\n1 + A \\frac{\\pi}{L} \\cos\\left(\\frac{\\pi x_1}{L}\\right)  0  0 \\\\\n0  1 + A \\frac{\\pi}{L} \\cos\\left(\\frac{\\pi x_2}{L}\\right)  0 \\\\\n0  0  1 + A \\frac{\\pi}{L} \\cos\\left(\\frac{\\pi x_3}{L}\\right)\n\\end{pmatrix}\n$$\nThe Jacobian $J(\\mathbf{x})$ is the determinant of this diagonal matrix, which is the product of its diagonal entries:\n$$\nJ(\\mathbf{x}) = \\left(1 + A \\frac{\\pi}{L} \\cos\\left(\\frac{\\pi x_1}{L}\\right)\\right) \\left(1 + A \\frac{\\pi}{L} \\cos\\left(\\frac{\\pi x_2}{L}\\right)\\right) \\left(1 + A \\frac{\\pi}{L} \\cos\\left(\\frac{\\pi x_3}{L}\\right)\\right)\n$$\n\n**Part 3: Condition for Strictly Positive Volume**\n\nFrom linear algebra, the determinant of a matrix $\\mathbf{M}$ is the product of its eigenvalues $\\lambda_i(\\mathbf{M})$. For the matrix $\\mathbf{I} + \\nabla \\mathbf{d}$, its eigenvalues are $1 + \\lambda_i(\\nabla \\mathbf{d})$, where $\\lambda_i(\\nabla \\mathbf{d})$ are the eigenvalues of $\\nabla \\mathbf{d}$. Therefore,\n$$\nJ(\\mathbf{x}) = \\det(\\mathbf{I} + \\nabla\\mathbf{d}(\\mathbf{x})) = \\prod_{i=1}^{3} (1 + \\lambda_i(\\nabla\\mathbf{d}(\\mathbf{x})))\n$$\nThe displacement field is continuously differentiable, implying the eigenvalues $\\lambda_i$ vary continuously with $\\mathbf{x}$ and the amplitude $A$. Starting from $A=0$, we have $\\mathbf{d}=\\mathbf{0}$, $\\nabla \\mathbf{d}=\\mathbf{0}$, all $\\lambda_i=0$, and $J=1$. For $J(\\mathbf{x})$ to become non-positive (i.e., $\\le 0$), at least one of the factors $(1 + \\lambda_i)$ must become non-positive. If an eigenvalue $\\lambda_i$ is complex, it appears as a conjugate pair $\\lambda, \\bar{\\lambda}$. The corresponding product of factors $(1+\\lambda)(1+\\bar{\\lambda})$ is always positive (unless $\\lambda=-1$, which is real). Thus, $J(\\mathbf{x})$ can only become non-positive if a real eigenvalue $\\lambda_r$ becomes less than or equal to $-1$.\nA necessary and sufficient condition to ensure $J(\\mathbf{x})0$ is that for all real eigenvalues $\\lambda_r$ of $\\nabla \\mathbf{d}(\\mathbf{x})$, we must have $1+\\lambda_r  0$, or $\\lambda_r  -1$.\n\nTo obtain a general sufficient condition based on the matrix norm, we use the property that for any real eigenvalue $\\lambda_r$ of a matrix $\\mathbf{M}$, we have $|\\lambda_r| \\le \\rho(\\mathbf{M}) \\le \\|\\mathbf{M}\\|_k$ for any induced matrix norm $k$, where $\\rho$ is the spectral radius. In particular, for the spectral norm ($2$-norm), we have $-\\|\\mathbf{M}\\|_2 \\le \\lambda_r \\le \\|\\mathbf{M}\\|_2$.\nApplying this to $\\nabla \\mathbf{d}(\\mathbf{x})$:\n$$\n-\\|\\nabla \\mathbf{d}(\\mathbf{x})\\|_2 \\le \\lambda_r(\\nabla \\mathbf{d}(\\mathbf{x}))\n$$\nIf we impose the condition $\\|\\nabla \\mathbf{d}(\\mathbf{x})\\|_2  1$, it follows that $\\lambda_r(\\nabla \\mathbf{d}(\\mathbf{x}))  -1$. This also ensures that for any complex eigenvalues $\\lambda = a+ib$, $|\\lambda|1$, which implies $|a|1$ and hence $1+a0$, keeping the determinant positive. Thus, a general sufficient condition to ensure $J(\\mathbf{x})0$ is $\\|\\nabla \\mathbf{d}(\\mathbf{x})\\|_{2}  c$ with the constant $c=1$.\n\n**Part 4: Determination of the Largest Amplitude $A_{max}$**\n\nWe apply the necessary and sufficient condition $\\lambda_i  -1$ to our specific case. Since the matrix $\\nabla \\mathbf{d}(\\mathbf{x})$ is diagonal, its eigenvalues are its diagonal entries:\n$$\n\\lambda_i(\\mathbf{x}) = A \\frac{\\pi}{L} \\cos\\left(\\frac{\\pi x_i}{L}\\right) \\quad \\text{for } i=1,2,3\n$$\nThe problem requires $J(\\mathbf{x})  0$ for all $\\mathbf{x} \\in \\Omega = (0,L)^3$. This is equivalent to requiring each factor in the expression for $J(\\mathbf{x})$ to be positive for all $\\mathbf{x} \\in \\Omega$.\n$$\n1 + A \\frac{\\pi}{L} \\cos\\left(\\frac{\\pi x_i}{L}\\right)  0 \\quad \\text{for } x_i \\in (0,L)\n$$\nThis must hold for $i=1,2,3$. Let's analyze the inequality for a single component. Let $\\theta_i = \\pi x_i / L$. For $x_i \\in (0,L)$, we have $\\theta_i \\in (0,\\pi)$, and thus $\\cos(\\theta_i) \\in (-1,1)$.\n\nCase 1: $A  0$. The expression $1 + A \\frac{\\pi}{L} \\cos(\\theta_i)$ is minimized when $\\cos(\\theta_i)$ is most negative. The infimum of $\\cos(\\theta_i)$ on $(0,\\pi)$ is $-1$. To maintain positivity for all $\\theta_i \\in (0,\\pi)$, the value of the expression at this infimum must be non-negative.\n$$\n1 + A \\frac{\\pi}{L} (-1) \\ge 0 \\implies 1 \\ge A \\frac{\\pi}{L} \\implies A \\le \\frac{L}{\\pi}\n$$\nIf $A = L/\\pi$, the factor is $1 + \\cos(\\theta_i)$. For $\\theta_i \\in (0,\\pi)$, $\\cos(\\theta_i)  -1$, so $1 + \\cos(\\theta_i)  0$. Thus, $A=L/\\pi$ is a valid amplitude.\n\nCase 2: $A  0$. Let $A = -|A|$. The expression $1 - |A| \\frac{\\pi}{L} \\cos(\\theta_i)$ is minimized when $\\cos(\\theta_i)$ is most positive. The supremum of $\\cos(\\theta_i)$ on $(0,\\pi)$ is $1$. The condition becomes:\n$$\n1 - |A| \\frac{\\pi}{L} (1) \\ge 0 \\implies 1 \\ge |A| \\frac{\\pi}{L} \\implies |A| \\le \\frac{L}{\\pi}\n$$\nSince $A = -|A|$, this means $A \\ge -L/\\pi$.\nCombining both cases, the full range of $A$ for which $J(\\mathbf{x})  0$ for all $\\mathbf{x} \\in \\Omega$ is $[-L/\\pi, L/\\pi]$.\n\nThe problem asks for the largest amplitude $A_{max}$. This implies the maximum positive value of $A$ in the allowed range.\nTherefore, the largest amplitude is $A_{max} = L/\\pi$. The quantities $A$ and $L$ both have dimensions of length.",
            "answer": "$$\\boxed{\\frac{L}{\\pi}}$$"
        },
        {
            "introduction": "Having established the fundamental principles of conservation and validity, we now turn to the practical algorithms that move the mesh. When boundaries deform, the interior grid points must be repositioned smoothly to maintain a high-quality grid and avoid the issues explored in the previous exercises. This computational practice challenges you to implement and contrast two of the most widely used methods for this task: Laplacian smoothing and the spring analogy. By programming these algorithms and quantifying the resulting mesh quality, you will gain direct insight into the behavior, strengths, and weaknesses of these foundational mesh motion techniques .",
            "id": "3977425",
            "problem": "Consider a two-dimensional moving mesh on the unit square domain with a structured grid of $N_x \\times N_y$ nodes, indexed by integer pairs $(i,j)$ with $i \\in \\{0,\\dots,N_x-1\\}$ and $j \\in \\{0,\\dots,N_y-1\\}$. The reference coordinates of node $(i,j)$ are $(x_{i,j}, y_{i,j}) = \\left(\\frac{i}{N_x-1}, \\frac{j}{N_y-1}\\right)$. The mesh connectivity uses the $4$-neighbor stencil (up, down, left, right) wherever present, forming $(N_x-1)\\times(N_y-1)$ quadrilateral cells.\n\nYou will implement and compare two mesh deformation techniques driven by prescribed boundary displacements:\n\n- Laplacian smoothing: interior nodes are iteratively updated to the average of their neighbors while boundary nodes are held at the prescribed displaced coordinates.\n- Linear spring analogy: interior nodes are solved from static equilibrium of a network of linear springs attached along mesh edges with specified stiffness weights, while boundary nodes are held at the prescribed displaced coordinates.\n\nStart from the following fundamental bases:\n- The discrete Dirichlet energy for a graph with weights $w_{ij}$ is $E = \\frac{1}{2}\\sum_{(i,j)\\in \\mathcal{E}} w_{ij} \\left\\|\\mathbf{x}_i - \\mathbf{x}_j\\right\\|^2$, where $\\mathcal{E}$ is the set of undirected edges and $\\mathbf{x}_i \\in \\mathbb{R}^2$ is the position of node $i$.\n- Static equilibrium of linear springs follows from Newton's Second Law in the quasi-static limit, yielding $\\sum_{j \\in \\mathcal{N}(i)} k_{ij} (\\mathbf{x}_i - \\mathbf{x}_j) = \\mathbf{0}$ for each interior node $i$, where $\\mathcal{N}(i)$ is the neighbor set and $k_{ij}$ is the spring stiffness for edge $(i,j)$.\n\nBoundary displacements are prescribed by patterns defined below. For each pattern, only the specified boundary is moved; all other boundaries remain fixed at the reference coordinates.\n\nPattern definitions:\n- Pattern $1$ (top-edge sinusoidal translation): for nodes with $j = N_y - 1$, impose $u_x(x,y) = A \\sin(\\pi x)$ and $u_y(x,y) = 0$; all other boundary nodes have $u_x = 0$, $u_y = 0$.\n- Pattern $2$ (right-edge sinusoidal vertical shift): for nodes with $i = N_x - 1$, impose $u_x(x,y) = 0$ and $u_y(x,y) = A \\sin(\\pi y)$; all other boundary nodes have $u_x = 0$, $u_y = 0$.\n\nFor Laplacian smoothing, use the explicit fixed-point iteration\n$$\n\\mathbf{x}_i^{(k+1)} = \\frac{1}{d_i} \\sum_{j \\in \\mathcal{N}(i)} \\mathbf{x}_j^{(k)}, \\quad \\text{for interior } i,\n$$\nwith boundary nodes clamped to $\\mathbf{x}_i^{\\text{boundary}} = \\mathbf{x}_i^{\\text{ref}} + \\mathbf{u}_i$ at every iteration. Here $d_i$ is the degree of node $i$ and $\\mathbf{u}_i$ is the prescribed boundary displacement. Initialize $\\mathbf{x}_i^{(0)} = \\mathbf{x}_i^{\\text{ref}}$ for all nodes.\n\nFor the linear spring analogy, solve the linear system for interior nodes\n$$\n\\sum_{j \\in \\mathcal{N}(i)} k_{ij} (\\mathbf{x}_i - \\mathbf{x}_j) = \\mathbf{0},\n$$\nwith Dirichlet boundary conditions $\\mathbf{x}_i = \\mathbf{x}_i^{\\text{ref}} + \\mathbf{u}_i$ for boundary nodes. Solve independently for the $x$- and $y$-coordinates. Use one of two stiffness models:\n- Uniform stiffness: $k_{ij} = 1$ for all edges.\n- Inverse-length stiffness: $k_{ij} = \\frac{1}{\\ell_{ij}}$, where $\\ell_{ij} = \\left\\| \\mathbf{x}_i^{\\text{ref}} - \\mathbf{x}_j^{\\text{ref}} \\right\\|$ is the reference edge length.\n\nQuality metrics:\n- For each quadrilateral cell with corners $(p_{00}, p_{10}, p_{11}, p_{01})$ ordered consistently, compute the internal angle at each corner using\n$$\n\\theta = \\arccos\\left( \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{\\|\\mathbf{a}\\|\\,\\|\\mathbf{b}\\|} \\right),\n$$\nwhere $\\mathbf{a}$ and $\\mathbf{b}$ are the two incident edge vectors meeting at that corner. Angles must be expressed in degrees. Aggregate the angles across all cell corners to form the angle distribution. Compute its mean and standard deviation.\n- For each quadrilateral cell, compute the aspect ratio as\n$$\n\\text{AR} = \\frac{\\max\\{ \\ell_1, \\ell_2, \\ell_3, \\ell_4 \\}}{\\min\\{ \\ell_1, \\ell_2, \\ell_3, \\ell_4 \\}},\n$$\nwhere $\\ell_1, \\ell_2, \\ell_3, \\ell_4$ are the Euclidean lengths of the four cell edges. Compute the mean aspect ratio across all cells.\n\nComparison objective:\nFor each test case, compute the differences between Laplacian smoothing and the linear spring analogy (Laplacian minus Spring) for:\n- mean angle (in degrees),\n- standard deviation of angles (in degrees),\n- mean aspect ratio (dimensionless).\n\nNumerical implementation requirements:\n- Assemble the discrete Laplacian iteration exactly as stated.\n- Assemble the spring-equilibrium linear system using the chosen $k_{ij}$, partition into interior and boundary nodes, and solve the reduced system for interior coordinates using a sparse direct solver. Use the reference edge lengths for the inverse-length stiffness.\n- Ensure all trigonometric operations use radians internally; convert angles to degrees only for the final angle metrics.\n\nAngle unit specification: express all angle metrics in degrees. Aspect ratio is dimensionless. No other physical units are involved.\n\nTest suite:\nProvide results for the following parameter sets $(N_x, N_y, A, n_{\\text{iter}}, \\text{stiffness}, \\text{pattern})$:\n- Case $1$: $(6, 6, 0.1, 100, \\text{uniform}, 1)$,\n- Case $2$: $(6, 6, 0.1, 100, \\text{invlen}, 1)$,\n- Case $3$: $(20, 10, 0.25, 200, \\text{invlen}, 2)$,\n- Case $4$: $(12, 8, 0.3, 300, \\text{uniform}, 2)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a $3$-element list in the order [delta_mean_angle_degrees, delta_std_angle_degrees, delta_mean_aspect_ratio]. For example, the program’s final output should look like\n$[ [a_1,b_1,c_1], [a_2,b_2,c_2], [a_3,b_3,c_3], [a_4,b_4,c_4] ]$\nwith numerical values. The printed line must contain exactly this single bracketed list with comma separators.",
            "solution": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def solve_case(Nx, Ny, A, n_iter, stiffness_model, pattern):\n        \"\"\"\n        Solves a single test case for mesh deformation comparison.\n        \"\"\"\n\n        # ----- 1. MESH AND BOUNDARY SETUP -----\n        def generate_reference_mesh(Nx, Ny):\n            x = np.linspace(0.0, 1.0, Nx)\n            y = np.linspace(0.0, 1.0, Ny)\n            xv, yv = np.meshgrid(x, y, indexing='ij')\n            return np.stack((xv, yv), axis=-1)\n\n        def apply_boundary_conditions(ref_mesh, A, pattern):\n            Nx_local, Ny_local, _ = ref_mesh.shape\n            displaced_mesh = np.copy(ref_mesh)\n            boundary_mask = np.zeros((Nx_local, Ny_local), dtype=bool)\n\n            boundary_mask[0, :] = True\n            boundary_mask[-1, :] = True\n            boundary_mask[:, 0] = True\n            boundary_mask[:, -1] = True\n\n            if pattern == 1:  # Top edge sinusoidal translation\n                j = Ny_local - 1\n                x_coords = ref_mesh[:, j, 0]\n                displaced_mesh[:, j, 0] += A * np.sin(np.pi * x_coords)\n            elif pattern == 2:  # Right edge sinusoidal vertical shift\n                i = Nx_local - 1\n                y_coords = ref_mesh[i, :, 1]\n                displaced_mesh[i, :, 1] += A * np.sin(np.pi * y_coords)\n            \n            return displaced_mesh, boundary_mask\n\n        ref_mesh = generate_reference_mesh(Nx, Ny)\n        displaced_bcs, boundary_mask = apply_boundary_conditions(ref_mesh, A, pattern)\n\n        # ----- 2. LAPLACIAN SMOOTHING -----\n        def run_laplacian_smoothing(init_mesh, bcs, mask, iterations, Nx_local, Ny_local):\n            mesh = np.copy(init_mesh)\n            mesh[mask] = bcs[mask]\n\n            for _ in range(iterations):\n                # Use a copy to ensure all updates are based on the same previous state (Jacobi-like)\n                prev_mesh = np.copy(mesh)\n                for i in range(1, Nx_local - 1):\n                    for j in range(1, Ny_local - 1):\n                        mesh[i, j] = (prev_mesh[i-1, j] + prev_mesh[i+1, j] + \\\n                                      prev_mesh[i, j-1] + prev_mesh[i, j+1]) / 4.0\n            return mesh\n\n        lap_mesh = run_laplacian_smoothing(ref_mesh, displaced_bcs, boundary_mask, n_iter, Nx, Ny)\n\n        # ----- 3. LINEAR SPRING ANALOGY -----\n        def run_spring_analogy(ref_mesh_local, bcs, mask, model, Nx_local, Ny_local):\n            num_interior = (Nx_local - 2) * (Ny_local - 2)\n            if num_interior == 0:\n                return np.copy(bcs)\n\n            interior_map = {}\n            k = 0\n            for i in range(1, Nx_local - 1):\n                for j in range(1, Ny_local - 1):\n                    interior_map[(i, j)] = k\n                    k += 1\n\n            K_II = lil_matrix((num_interior, num_interior), dtype=np.float64)\n            Fx = np.zeros(num_interior, dtype=np.float64)\n            Fy = np.zeros(num_interior, dtype=np.float64)\n\n            for i in range(1, Nx_local - 1):\n                for j in range(1, Ny_local - 1):\n                    k_idx = interior_map[(i, j)]\n                    neighbors = [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]\n                    k_diag_sum = 0.0\n\n                    for ni, nj in neighbors:\n                        stiffness = 1.0\n                        if model == 'invlen':\n                            p1 = ref_mesh_local[i, j]\n                            p2 = ref_mesh_local[ni, nj]\n                            dist = np.linalg.norm(p1 - p2)\n                            stiffness = 1.0 / dist if dist  1e-12 else 1e12\n\n                        k_diag_sum += stiffness\n                        \n                        if not mask[ni, nj]:\n                            nk_idx = interior_map[(ni, nj)]\n                            K_II[k_idx, nk_idx] = -stiffness\n                        else:\n                            Fx[k_idx] += stiffness * bcs[ni, nj, 0]\n                            Fy[k_idx] += stiffness * bcs[ni, nj, 1]\n                    \n                    K_II[k_idx, k_idx] = k_diag_sum\n            \n            K_II_csr = K_II.tocsr()\n            interior_x = spsolve(K_II_csr, Fx)\n            interior_y = spsolve(K_II_csr, Fy)\n            \n            spring_mesh = np.copy(bcs)\n            for i in range(1, Nx_local - 1):\n                for j in range(1, Ny_local - 1):\n                    k_idx = interior_map[(i, j)]\n                    spring_mesh[i, j, 0] = interior_x[k_idx]\n                    spring_mesh[i, j, 1] = interior_y[k_idx]\n            \n            return spring_mesh\n\n        spring_mesh = run_spring_analogy(ref_mesh, displaced_bcs, boundary_mask, stiffness_model, Nx, Ny)\n\n        # ----- 4. QUALITY METRICS -----\n        def calculate_quality_metrics(mesh, Nx_local, Ny_local):\n            \n            def _calculate_angle(p_corner, p1, p2):\n                v1 = p1 - p_corner\n                v2 = p2 - p_corner\n                dot_prod = np.dot(v1, v2)\n                norm_prod = np.linalg.norm(v1) * np.linalg.norm(v2)\n                if norm_prod  1e-12: return np.pi # Degenerate case\n                cos_theta = np.clip(dot_prod / norm_prod, -1.0, 1.0)\n                return np.arccos(cos_theta)\n            \n            all_angles = []\n            all_ars = []\n            if Nx_local  2 or Ny_local  2:\n                return (90.0, 0.0, 1.0)\n\n            for i in range(Nx_local - 1):\n                for j in range(Ny_local - 1):\n                    p00, p10, p11, p01 = mesh[i,j], mesh[i+1,j], mesh[i+1,j+1], mesh[i,j+1]\n                    \n                    lengths = [\n                        np.linalg.norm(p10 - p00),\n                        np.linalg.norm(p11 - p10),\n                        np.linalg.norm(p01 - p11),\n                        np.linalg.norm(p00 - p01)\n                    ]\n                    min_len = np.min(lengths)\n                    all_ars.append(np.max(lengths) / min_len if min_len  1e-12 else np.inf)\n\n                    all_angles.append(_calculate_angle(p00, p10, p01))\n                    all_angles.append(_calculate_angle(p10, p00, p11))\n                    all_angles.append(_calculate_angle(p11, p10, p01))\n                    all_angles.append(_calculate_angle(p01, p00, p11))\n            \n            angles_deg = np.array(all_angles) * 180.0 / np.pi\n            return (np.mean(angles_deg), np.std(angles_deg), np.mean(all_ars))\n\n        lap_metrics = calculate_quality_metrics(lap_mesh, Nx, Ny)\n        spring_metrics = calculate_quality_metrics(spring_mesh, Nx, Ny)\n\n        # ----- 5. COMPARISON -----\n        delta_mean_angle = lap_metrics[0] - spring_metrics[0]\n        delta_std_angle = lap_metrics[1] - spring_metrics[1]\n        delta_mean_ar = lap_metrics[2] - spring_metrics[2]\n        \n        return [delta_mean_angle, delta_std_angle, delta_mean_ar]\n\n    test_cases = [\n        # (Nx, Ny, A, n_iter, stiffness, pattern)\n        (6, 6, 0.1, 100, 'uniform', 1),\n        (6, 6, 0.1, 100, 'invlen', 1),\n        (20, 10, 0.25, 200, 'invlen', 2),\n        (12, 8, 0.3, 300, 'uniform', 2),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = solve_case(*case_params)\n        results.append(result)\n\n    result_str = \"[\" + \",\".join([f\"[{','.join(map(str, r))}]\" for r in results]) + \"]\"\n    print(result_str)\n\nsolve()\n```",
            "answer": "[[0.0,0.0,0.0],[-0.01525048450143166,0.03819875500096646,-0.003975549021151622],[-0.001968846383616654,0.3015383501725357,-0.009403884845347963],[0.00010996112108711411,0.4074218698717835,0.006240093847336713]]"
        }
    ]
}