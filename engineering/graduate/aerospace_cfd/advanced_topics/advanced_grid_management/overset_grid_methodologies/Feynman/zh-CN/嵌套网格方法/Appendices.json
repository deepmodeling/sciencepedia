{
    "hands_on_practices": [
        {
            "introduction": "重叠网格方法的整个过程依赖于将信息从一个供体单元精确地传递到一个接收点。这个练习将最常见的插值方案——三线性插值——分解为其基本原理。通过从第一性原理推导插值权重 ，您将掌握流场变量在重叠网格之间传递的核心机制。",
            "id": "3982831",
            "problem": "在计算流体动力学（CFD）的嵌合（Chimera）网格插值中，考虑一个位于施主六面体单元内部的目标点。施主单元内的插值是使用三线性张量积插值进行的。设目标点的局部等参坐标为 $(\\xi,\\eta,\\zeta)\\in[-1,1]^3$，该坐标由三线性六面体单元的标准等参映射获得。沿每个逻辑轴，根据局部坐标定义一个分数坐标 $\\phi_{\\alpha}\\in[0,1]$，其中 $\\alpha\\in\\{x,y,z\\}$。从一维线性插值的第一性原理及其到三维的张量积扩展出发，推导由 $(i,j,k)\\in\\{0,1\\}^3$ 索引的顶点的权重 $w_{ijk}$ 关于 $\\phi_{x}$、$\\phi_{y}$ 和 $\\phi_{z}$ 的通用形式。清晰地说明每个 $\\phi_{\\alpha}$ 是如何从相应的局部坐标计算得出的。\n\n然后，对于局部坐标为 $(\\xi,\\eta,\\zeta)=(0.3,-0.5,0.8)$ 的目标点，计算与顶点 $(i,j,k)=(1,0,1)$ 相关联的特定权重。将最终数值结果以无量纲数的形式给出，并四舍五入到五位有效数字。",
            "solution": "该问题被评估为有效，因为它以计算流体动力学的数值方法原理为科学基础，问题设定适定，目标明确，信息充分，并使用客观、正式的语言。我们可以着手求解。\n\n问题的核心在于六面体单元三线性插值权重的推导和应用。我们从一维线性插值的第一性原理开始。\n\n考虑一个由两个节点定义的一维线段，索引为 $i=0$ 和 $i=1$。我们可以定义一个贯穿该线段的局部分数坐标 $\\phi \\in [0,1]$，使得在节点0处 $\\phi=0$，在节点1处 $\\phi=1$。该线段上任意点的值 $f(\\phi)$ 可以通过节点值 $f_0$ 和 $f_1$ 的加权平均来插值得到：\n$$ f(\\phi) = N_0(\\phi) f_0 + N_1(\\phi) f_1 $$\n其中 $N_0(\\phi)$ 和 $N_1(\\phi)$ 是线性基函数，也称为形函数。为使插值在节点处精确，必须满足 $N_0(0)=1$、$N_0(1)=0$、$N_1(0)=0$ 和 $N_1(1)=1$。满足这些条件的唯一线性多项式是：\n$$ N_0(\\phi) = 1 - \\phi $$\n$$ N_1(\\phi) = \\phi $$\n使用索引 $i \\in \\{0, 1\\}$，这两个形函数的紧凑表达式为：\n$$ N_i(\\phi) = \\phi^i (1-\\phi)^{1-i} $$\n\n为了将此方法扩展到三维的六面体单元，我们采用张量积原理。六面体可以看作是沿三个正交逻辑轴的三个一维线段的张量积。我们定义一组分数坐标 $(\\phi_x, \\phi_y, \\phi_z)$，每个坐标都在 $[0,1]$ 范围内，对应于逻辑方向。这个逻辑立方体中的一个顶点由索引三元组 $(i,j,k)$ 标识，其中每个索引可以是 $0$ 或 $1$。\n\n对于位于 $(\\phi_x, \\phi_y, \\phi_z)$ 的目标点，分配给顶点 $(i,j,k)$ 的插值权重 $w_{ijk}$ 是每个相应坐标和索引的一维形函数的乘积：\n$$ w_{ijk}(\\phi_x, \\phi_y, \\phi_z) = N_i(\\phi_x) N_j(\\phi_y) N_k(\\phi_z) $$\n代入一维形函数的紧凑表达式，我们推导出顶点权重的通用形式：\n$$ w_{ijk}(\\phi_x, \\phi_y, \\phi_z) = \\left( \\phi_x^i (1-\\phi_x)^{1-i} \\right) \\left( \\phi_y^j (1-\\phi_y)^{1-j} \\right) \\left( \\phi_z^k (1-\\phi_z)^{1-k} \\right) $$\n这就是在顶点 $(i,j,k) \\in \\{0,1\\}^3$ 处的插值权重作为分数坐标 $(\\phi_x, \\phi_y, \\phi_z)$ 函数的通用表达式。\n\n问题给出了目标点在标准等参坐标系 $(\\xi, \\eta, \\zeta)$ 中的局部坐标，其中每个坐标的范围是从 $-1$ 到 $1$。分数坐标 $\\phi_{\\alpha} \\in [0,1]$（其中 $\\alpha \\in \\{x,y,z\\}$ 分别对应与 $\\xi, \\eta, \\zeta$ 相关的逻辑方向）通过一个简单的线性映射获得。对于一个坐标 $\\chi \\in [-1,1]$，对应的分数坐标 $\\phi \\in [0,1]$ 由下式给出：\n$$ \\phi = \\frac{\\chi - (-1)}{1 - (-1)} = \\frac{\\chi+1}{2} $$\n因此，这些关系是：\n$$ \\phi_x = \\frac{\\xi+1}{2} $$\n$$ \\phi_y = \\frac{\\eta+1}{2} $$\n$$ \\phi_z = \\frac{\\zeta+1}{2} $$\n\n现在，我们进行具体计算。目标点由 $(\\xi, \\eta, \\zeta) = (0.3, -0.5, 0.8)$ 给出。首先，我们计算相应的分数坐标：\n$$ \\phi_x = \\frac{0.3 + 1}{2} = \\frac{1.3}{2} = 0.65 $$\n$$ \\phi_y = \\frac{-0.5 + 1}{2} = \\frac{0.5}{2} = 0.25 $$\n$$ \\phi_z = \\frac{0.8 + 1}{2} = \\frac{1.8}{2} = 0.9 $$\n目标点在分数坐标系下为 $(\\phi_x, \\phi_y, \\phi_z) = (0.65, 0.25, 0.9)$。\n\n我们需要计算由 $(i,j,k)=(1,0,1)$ 索引的顶点的特定权重 $w_{101}$。使用 $w_{ijk}$ 的通用公式并代入这些索引：\n$$ w_{101}(\\phi_x, \\phi_y, \\phi_z) = \\left( \\phi_x^1 (1-\\phi_x)^{1-1} \\right) \\left( \\phi_y^0 (1-\\phi_y)^{1-0} \\right) \\left( \\phi_z^1 (1-\\phi_z)^{1-1} \\right) $$\n$$ w_{101}(\\phi_x, \\phi_y, \\phi_z) = (\\phi_x) (1-\\phi_y) (\\phi_z) $$\n代入计算出的分数坐标：\n$$ w_{101} = (0.65) \\times (1 - 0.25) \\times (0.9) $$\n$$ w_{101} = 0.65 \\times 0.75 \\times 0.9 $$\n$$ w_{101} = 0.4875 \\times 0.9 $$\n$$ w_{101} = 0.43875 $$\n这个值恰好有五位有效数字，因此不需要进一步的四舍五入。",
            "answer": "$$\\boxed{0.43875}$$"
        },
        {
            "introduction": "在进行插值之前，我们必须确定网格的哪些区域是活动的，哪些是“挖洞”或切除的。这个实践解决了一个关键的现实世界挑战：如何在弯曲表面附近稳健地执行挖洞，同时考虑CAD模型的几何公差和网格对几何形状的离散近似。通过推导一个安全余量 $\\delta$ ，您将学习如何防止可能破坏模拟的“狭缝”重叠问题。",
            "id": "3982925",
            "problem": "在用于航空航天计算流体动力学的重叠网格 (Chimera) 方法中，通过相对于光滑水密的参数化计算机辅助设计 (CAD) 曲面对背景网格单元进行分类，然后通过一个安全裕度对产生的切口进行腐蚀，以防止重叠的组件网格之间出现细长的“sliver”重叠，从而在曲面附近执行挖洞操作。考虑一个光滑曲面片，其在目标点处的局部主曲率大小为 $\\kappa$。CAD 几何结构提供带认证几何公差 $\\epsilon$ 的逐点评估，这意味着返回的曲面点在豪斯多夫意义上与真实解析曲面的偏差最多为 $\\epsilon$。邻域内的背景网格是准均匀的，标称边长为 $h$，并且曲面是局部良好解析的，即 $h \\ll 1/\\kappa$。假设局部曲面可以由其在目标点处达到最大曲率的法截面中的密切圆（半径 $R = 1/\\kappa$）来近似，并且相对于曲面的单元分类依赖于在长度为 $\\mathcal{O}(h)$ 的跨度上的平面近似。\n\n您的任务是为洞的形态学腐蚀（即，将空白区域扩大 $\\delta$）提出一个鲁棒的、曲率感知的安全裕度 $\\delta$，该裕度可以证明地消除由 CAD 公差和真实曲面与其在大小为 $h$ 的跨度上的分段平面近似之间的曲率引起的偏差所共同导致的 sliver 重叠。从几何第一性原理出发，通过界定半径为 $R$ 的圆弧与其长度最多为 $h$ 的弦之间的最大法向偏差来论证每一步。采用与 $h \\ll R$ 一致的小参数近似，并保留 $h/R$ 的最低非平凡阶。\n\n在弦跨度与主曲率方向最坏情况对齐的条件下，推导一个保证消除此类曲率和公差引起的 sliver 的最小安全裕度 $\\delta(h,\\kappa,\\epsilon)$ 的闭式解析表达式。您可以假设与上述几何效应相比，任何额外的数值分类误差都可以忽略不计。假设 $h$ 和 $\\epsilon$ 的单位是米，$\\kappa$ 的单位是米分之一，请以米为单位表示您的最终答案。您的最终答案必须是仅用 $h$、$\\kappa$ 和 $\\epsilon$ 表示的单一解析表达式 $\\delta(h,\\kappa,\\epsilon)$。",
            "solution": "所给问题具有科学依据、是适定且客观的。它描述了计算流体动力学 (CFD) 网格生成中的一个标准几何挑战，特别是针对重叠 (Chimera) 网格。CAD 公差、主曲率和分段平面近似等概念是该领域的基础。给定的条件是自洽的，足以推导出解决方案。因此，该问题是有效的。\n\n目标是为挖洞推导一个最小安全裕度 $\\delta$，以鲁棒地防止“sliver”单元的形成。这些 sliver 是由真实几何曲面与用于分类网格单元的简化表示之间的差异引起的。该问题指出了这种差异的两个主要来源：\n\n$1$. 计算机辅助设计 (CAD) 模型固有的几何公差，表示为 $\\epsilon$。\n$2$. 在背景网格单元的特征长度尺度 $h$ 上，用平面小面近似弯曲曲面所引入的误差。\n\n一个鲁棒的安全裕度必须考虑最坏情况，即这两种误差加性地组合导致错误分类。设 $\\phi_{\\text{true}}$ 为到真实解析曲面的有向距离，$\\phi_{\\text{approx}}$ 为到用于分类的分段平面近似的有向距离。如果一个单元在实际上位于物体内部（$\\phi_{\\text{true}} \\le 0$）时，却被判定为位于物体外部（$\\phi_{\\text{approx}} > 0$），则该单元被错误分类。安全裕度 $\\delta$ 是重新分类所有此类潜在问题单元所需的空白区域的最小扩大值。这对应于将所有满足 $\\phi_{\\text{approx}} \\le \\delta$ 的单元都置为空白。\n\n总差异是来自每个来源的最大可能偏差之和。设 $\\delta_{\\epsilon}$ 为 CAD 公差引起的偏差，$\\delta_{\\text{curv}}$ 为曲率引起的近似偏差。所需的总裕度为：\n$$\n\\delta = \\delta_{\\epsilon} + \\delta_{\\text{curv}}\n$$\n\n首先，我们考虑 CAD 公差的贡献。问题陈述，CAD 曲面在豪斯多夫意义上与真实解析曲面的偏差最多为 $\\epsilon$。这意味着真实曲面可以位于报告的 CAD 曲面周围宽度为 $2\\epsilon$ 的带内的任何位置。在最坏情况下，对于一个正在被分类的点，真实曲面相对于 CAD 曲面朝该点方向移动了法向距离 $\\epsilon$。因此，为考虑这种不确定性所需的裕度就是 $\\epsilon$。\n$$\n\\delta_{\\epsilon} = \\epsilon\n$$\n\n接下来，我们量化由曲率引起的偏差 $\\delta_{\\text{curv}}$。问题指示我们将局部曲面建模为其密切圆，其半径 $R$ 是局部最大主曲率大小 $\\kappa$ 的倒数。\n$$\nR = \\frac{1}{\\kappa}\n$$\n用于分类的平面近似是该圆的一条弦，其长度最多等于网格单元尺寸 $h$。圆弧与其弦之间的最大偏差出现在弦的中点，被称为弓形的矢高。这个偏差代表了 $\\delta_{\\text{curv}}$。\n\n为计算矢高，我们使用基本几何学。考虑一个半径为 $R$ 的圆。一条长度为 $h$ 的弦置于其上。由半径 $R$（斜边）、半弦长 $\\frac{h}{2}$（一条直角边）以及圆心到弦的距离 $R - \\delta_{\\text{curv}}$（另一条直角边）构成一个直角三角形。\n\n根据勾股定理：\n$$\n\\left(R - \\delta_{\\text{curv}}\\right)^{2} + \\left(\\frac{h}{2}\\right)^{2} = R^{2}\n$$\n展开方程：\n$$\nR^{2} - 2R\\delta_{\\text{curv}} + \\delta_{\\text{curv}}^{2} + \\frac{h^{2}}{4} = R^{2}\n$$\n我们可以忽略 $\\delta_{\\text{curv}}^{2}$ 项，因为考虑到 $\\delta_{\\text{curv}}$ 很小，它是一个更高阶的项。这简化为：\n$$\n-2R\\delta_{\\text{curv}} + \\frac{h^{2}}{4} \\approx 0 \\implies \\delta_{\\text{curv}} \\approx \\frac{h^{2}}{8R}\n$$\n或者，我们可以精确求解关于 $\\delta_{\\text{curv}}$ 的二次方程：\n$$\n\\delta_{\\text{curv}} = R - \\sqrt{R^{2} - \\frac{h^{2}}{4}}\n$$\n提出因子 $R$：\n$$\n\\delta_{\\text{curv}} = R \\left(1 - \\sqrt{1 - \\frac{h^{2}}{4R^{2}}}\\right)\n$$\n问题明确指出曲面是良好解析的，即 $h \\ll R$。因此，项 $\\frac{h^{2}}{4R^{2}}$ 非常小。我们可以使用 $\\sqrt{1-x}$ 在 $x=0$ 处的泰勒级数展开，即 $1 - \\frac{x}{2} - \\frac{x^2}{8} - \\dots$。保留最低非平凡阶：\n$$\n\\sqrt{1 - \\frac{h^{2}}{4R^{2}}} \\approx 1 - \\frac{1}{2}\\left(\\frac{h^{2}}{4R^{2}}\\right) = 1 - \\frac{h^{2}}{8R^{2}}\n$$\n将此近似代回 $\\delta_{\\text{curv}}$ 的表达式中：\n$$\n\\delta_{\\text{curv}} \\approx R \\left(1 - \\left(1 - \\frac{h^{2}}{8R^{2}}\\right)\\right) = R \\left(\\frac{h^{2}}{8R^{2}}\\right) = \\frac{h^{2}}{8R}\n$$\n现在，代入 $R = 1/\\kappa$：\n$$\n\\delta_{\\text{curv}} = \\frac{h^{2}\\kappa}{8}\n$$\n该表达式给出了在最大曲率方向上，真实弯曲曲面与其在长度尺度 $h$ 上的平面近似之间的最大法向偏差。\n\n最后，我们组合安全裕度的两个分量。总裕度 $\\delta$ 是最大 CAD 公差和最大曲率引起偏差之和，因为这些误差是独立的，并且在最坏情况下可以相加。\n$$\n\\delta(h, \\kappa, \\epsilon) = \\delta_{\\epsilon} + \\delta_{\\text{curv}} = \\epsilon + \\frac{h^{2}\\kappa}{8}\n$$\n这是在给定假设和近似条件下，为可证明地防止由指定几何效应引起的 sliver 重叠所需的最小、鲁棒、曲率感知的安全裕度。单位是一致的：$\\epsilon$ 的单位是米，而对于 $\\frac{h^{2}\\kappa}{8}$，单位是 $\\frac{\\text{m}^{2} \\cdot \\text{m}^{-1}}{1} = \\text{m}$。",
            "answer": "$$\n\\boxed{\\epsilon + \\frac{h^{2} \\kappa}{8}}\n$$"
        },
        {
            "introduction": "建立了插值和挖洞的机制后，一个关键的最后步骤是验证方法的准确性。这个编程练习将指导您完成一个经典的数值实验：模拟一个涡旋穿过重叠网格界面以测量产生的数值耗散。通过比较涡旋穿过界面前后的环量 $\\Gamma$ ，您将直接量化由网格界面引入的误差，这是计算流体动力学代码验证中的一项基本技能。",
            "id": "3982917",
            "problem": "构建一个完整、可运行的程序，该程序在二维空间中模拟双网格重叠（Chimera）方法，以量化当一个尖锐涡旋穿过重叠界面时涡度的数值扩散。从基本原理开始：对于具有保守彻体力的不可压缩、无粘性流，Kelvin 环量定理指出，速度围绕物质回路的环量不随时间变化。设真实流场为一个由均匀平移所平流的 Rankine 涡，并设该 Rankine 涡的特征为总环量 $\\Gamma_0$ 和核心半径 $a$，其切向速度由下式给出\n$$\nu_\\theta(r) = \n\\begin{cases}\n\\dfrac{\\Gamma_0}{2\\pi r},  r > a,\\\\\\\\\n\\dfrac{\\Gamma_0}{2\\pi a^2}\\,r,  r \\le a.\n\\end{cases}\n$$\n围绕以涡旋中心为圆心、半径为 $R$ 的圆的精确环量为\n$$\n\\Gamma_{\\text{true}}(R) =\n\\begin{cases}\n\\Gamma_0,  R > a,\\\\\\\\\n\\Gamma_0\\,\\dfrac{R^2}{a^2},  R \\le a.\n\\end{cases}\n$$\n模拟一个重叠（Chimera）配置，该配置由一个覆盖矩形域 $\\left[x_{\\min},x_{\\max}\\right]\\times\\left[y_{\\min},y_{\\max}\\right]$ 的均匀背景笛卡尔网格（网格间距为 $h_b$）和一个覆盖矩形子域（重叠区域）的更精细的物面网格（网格间距为 $h_o$）组成。复合场通过对区域内的点在物面网格上进行双线性插值，以及对区域外的点在背景网格上进行双线性插值来定义。涡旋中心初始位于 $(x_c^0,y_c^0)$，然后平流至 $(x_c^1,y_c^1)=(x_c^0,y_c^0)+\\mathbf{U}\\,\\Delta t$。因为均匀平移对闭合曲线的线积分为零，所以在评估涡旋速度场时，只需平移涡旋中心即可。\n\n您的程序必须：\n- 通过 $\\mathbf{u}=\\left(u_x,u_y\\right)$ 表示以 $(x_c,y_c)$ 为中心的 Rankine 涡速度场 $\\mathbf{u}(x,y)$，其中 $u_\\theta(r)$ 通过单位切向量 $\\hat{\\mathbf{t}}=\\left(-\\sin\\theta,\\cos\\theta\\right)$ 映射到笛卡尔分量，$\\theta$ 是关于 $(x_c,y_c)$ 的极角，$r$ 是径向距离。\n- 在时间 $t_0$ 和 $t_1$ 为背景网格和物面区域构建均匀网格，在其节点位置采样解析涡旋场。\n- 定义一个复合采样器，对于给定的 $(x,y)$，如果 $(x,y)$ 位于区域内，则通过在物面网格上进行双线性插值返回 $\\mathbf{u}(x,y)$，否则在背景网格上进行插值。\n- 使用角度 $\\theta\\in[0,2\\pi)$（以弧度为单位）中的 $M$ 个均匀求积点，近似计算围绕以涡旋中心为圆心、半径为 $R$ 的圆的环量 $\\Gamma=\\oint \\mathbf{u}\\cdot d\\mathbf{s}$。使用中点法则：设 $\\theta_i$ 均匀间隔且 $\\Delta\\theta=2\\pi/M$，用 $\\mathbf{x}_{i+1}-\\mathbf{x}_i$ 近似 $d\\mathbf{s}$，其中 $\\mathbf{x}_i=(x_c+R\\cos\\theta_i,\\;y_c+R\\sin\\theta_i)$，并在中点角度 $\\theta_{i+\\frac{1}{2}}$ 处评估 $\\mathbf{u}$。\n- 从复合采样器计算 $t_0$ 时的 $\\Gamma_{\\text{before}}$ 和 $t_1$ 时的 $\\Gamma_{\\text{after}}$，并报告无量纲相对变化 $(\\Gamma_{\\text{after}}-\\Gamma_{\\text{before}})/\\Gamma_{\\text{true}}(R)$。\n\n所有量均为无量纲；角度必须以弧度为单位。双线性插值应在轴对齐的均匀网格上执行，对网格边界上或附近的查询点的处理必须是鲁棒的，即通过钳位到有效的插值单元格。\n\n实施以下参数集测试套件以检验重叠界面的行为。对于每种情况，域为 $\\left[x_{\\min},x_{\\max}\\right]\\times\\left[y_{\\min},y_{\\max}\\right]=[-1,1]\\times[-1,1]$，重叠区域是一个以 $(x_o,y_o)$ 为中心、半宽为 $(w/2,h/2)$ 的矩形，即 $[x_o-w/2,x_o+w/2]\\times[y_o-h/2,y_o+h/2]$。变量和常量如下：\n\n- 情况 1（使用精细物面网格的理想穿越路径）：\n  - $h_b=0.04$, $h_o=0.01$,\n  - $(x_o,y_o)=(0,0)$, $w=0.5$, $h=0.8$,\n  - $(x_c^0,y_c^0)=(-0.6,0)$, $\\Delta x=0.7$, $\\Delta y=0$, 因此 $(x_c^1,y_c^1)=(0.1,0)$,\n  - $\\Gamma_0=1$, $a=0.05$, $R=0.25$, $M=1024$.\n\n- 情况 2（较粗的背景网格导致更强的扩散）：\n  - $h_b=0.08$, $h_o=0.02$,\n  - $(x_o,y_o)=(0,0)$, $w=0.5$, $h=0.6$,\n  - $(x_c^0,y_c^0)=(-0.7,0)$, $\\Delta x=0.9$, $\\Delta y=0$, 因此 $(x_c^1,y_c^1)=(0.2,0)$,\n  - $\\Gamma_0=1$, $a=0.05$, $R=0.25$, $M=1024$.\n\n- 情况 3（穿越后，圆与重叠界面相交）：\n  - $h_b=0.05$, $h_o=0.01$,\n  - $(x_o,y_o)=(0,0)$, $w=0.4$, $h=0.6$,\n  - $(x_c^0,y_c^0)=(-0.45,0)$, $\\Delta x=0.6$, $\\Delta y=0$, 因此 $(x_c^1,y_c^1)=(0.15,0)$,\n  - $\\Gamma_0=1$, $a=0.05$, $R=0.35$, $M=1536$.\n\n- 情况 4（无穿越；两次评估均在背景网格上）：\n  - $h_b=0.04$, $h_o=0.01$,\n  - $(x_o,y_o)=(0,0)$, $w=0.5$, $h=0.8$,\n  - $(x_c^0,y_c^0)=(-0.7,0)$, $\\Delta x=0.1$, $\\Delta y=0$, 因此 $(x_c^1,y_c^1)=(-0.6,0)$,\n  - $\\Gamma_0=1$, $a=0.05$, $R=0.25$, $M=1024$.\n\n您的程序应生成单行输出，按顺序包含每个测试用例的三元组 $[\\Gamma_{\\text{before}},\\Gamma_{\\text{after}},(\\Gamma_{\\text{after}}-\\Gamma_{\\text{before}})/\\Gamma_{\\text{true}}(R)]$，格式为由逗号分隔的列表组成的列表，并用方括号括起来（例如，$[[g_{1,0},g_{1,1},\\delta_1],[g_{2,0},g_{2,1},\\delta_2],\\ldots]$）。所有输出必须是无量纲浮点数。",
            "solution": "用户提供的问题是有效的。其科学基础在于流体动力学和计算流体动力学（CFD）的原理，特别是关于 Kelvin 环量定理和重叠（Chimera）网格方法的应用。该问题是适定的，提供了构建唯一、确定性解所需的所有必要参数、定义和约束。语言是客观的，其设置是一个标准的数值实验，用以量化数值误差，在本例中，即数值扩散。\n\n解决方案通过开发一个 Python 程序来模拟所述场景。问题的核心是量化一个涡旋在穿过粗糙背景网格和精细重叠网格之间的界面时，其数值计算环量的变化。在由指定的不可压缩和无粘性动力学控制的理想连续流中，Kelvin 环量定理断言，围绕物质回路的环量保持不变。因此，计算环量中的任何变化都是一种数值假象，代表了离散化方案引入的误差。重叠网格方法，其中域的不同部分由不同的网格解析，已知会在网格界面处引入此类误差，表现为伪扩散或色散。\n\n该方法通过以下步骤序列实现：\n\n1.  **解析速度场**：Rankine 涡的速度场被解析定义。该涡的特征是其总环量 $\\Gamma_0$ 和核心半径 $a$。其切向速度 $u_\\theta (r)$ 是距涡旋中心 $(x_c, y_c)$ 的径向距离 $r$ 的函数。这个连续速度场作为我们模拟的“基准真相”。点 $(x, y)$ 处的笛卡尔速度分量 $(u_x, u_y)$ 由切向速度 $u_\\theta$ 和几何关系导出：\n    $$ u_x = -u_\\theta \\frac{y - y_c}{r}, \\quad u_y = u_\\theta \\frac{x - x_c}{r} $$\n    其中 $r = \\sqrt{(x-x_c)^2 + (y-y_c)^2}$。\n\n2.  **网格离散化**：连续域使用两个均匀的笛卡尔网格进行离散化：一个间距为 $h_b$ 的背景网格和一个覆盖子域、间距为 $h_o$ 的更精细的重叠“物面”网格。在每个时间瞬间（$t_0$ 和 $t_1$），以相应涡旋位置（$(x_c^0, y_c^0)$ 或 $(x_c^1, y_c^1)$）为中心的解析速度场在两个网格的每个节点上进行采样。这会为每个网格生成存储在二维数组中的离散速度场 $(u_x, u_y)$。\n\n3.  **复合场采样器**：构建一个复合采样器函数来模拟重叠网格的逻辑。对于任何给定的查询点 $(x, y)$，此函数首先确定该点是否位于重叠网格的矩形区域内。\n    - 如果在内部，函数对精细重叠网格的离散数据执行双线性插值以找到速度 $(u_x, u_y)$。\n    - 如果在外部，函数对粗糙背景网格的数据执行双线性插值。\n    对于一个网格单元内的点 $(x, y)$，其角点为 $(x_i, y_j)$、$(x_{i+1}, y_j)$、$(x_i, y_{j+1})$ 和 $(x_{i+1}, y_{j+1})$，对应的场值为 $f_{i,j}$、$f_{i+1,j}$、$f_{i,j+1}$、$f_{i+1,j+1}$，双线性插值由下式给出：\n    $$ f(x, y) \\approx (1-s)(1-t)f_{i,j} + s(1-t)f_{i+1,j} + (1-s)tf_{i,j+1} + stf_{i+1,j+1} $$\n    其中 $s = (x - x_i)/h_x$ 和 $t = (y - y_j)/h_y$ 是单元内的归一化坐标，$h_x, h_y$ 是网格间距。为确保鲁棒性，网格域外的查询点在插值前被钳位到边界。\n\n4.  **环量计算**：环量 $\\Gamma = \\oint_C \\mathbf{u} \\cdot d\\mathbf{s}$ 在以涡旋为中心、半径为 $R$ 的圆形路径 $C$ 上进行数值近似。该圆被离散化为 $M$ 个段。线积分使用中点法则求和来近似：\n    $$ \\Gamma_{\\text{num}} \\approx \\sum_{k=0}^{M-1} \\mathbf{u}(\\mathbf{x}_{\\text{mid},k}) \\cdot (\\mathbf{x}_{k+1} - \\mathbf{x}_k) $$\n    这里，$\\mathbf{x}_k$ 是圆上角度为 $\\theta_k = 2\\pi k/M$ 的点。向量 $\\mathbf{x}_{k+1} - \\mathbf{x}_k$ 代表线段 $d\\mathbf{s}$。速度 $\\mathbf{u}$ 使用复合采样器在线段的角度中点 $\\mathbf{x}_{\\text{mid},k}$ 处进行评估。这种方法确保了速度评估点对于该线段具有代表性。\n\n5.  **数值扩散的量化**：整个过程执行两次：一次针对初始状态（`before`，在时间 $t_0$）和一次针对最终状态（`after`，在时间 $t_1$）。这会产生两个数值环量值，$\\Gamma_{\\text{before}}$ 和 $\\Gamma_{\\text{after}}$。然后计算无量纲相对变化 $(\\Gamma_{\\text{after}} - \\Gamma_{\\text{before}}) / \\Gamma_{\\text{true}}(R)$。精确环量 $\\Gamma_{\\text{true}}(R)$ 用于归一化，并根据解析公式计算。由于 Kelvin 定理预测变化为零，因此该计算值直接量化了由网格过渡引入的数值误差。\n\n最终程序为每个测试用例实现这些步骤，并以指定格式报告计算出的环量值及其相对变化。为提高计算效率，优先使用矢量化的 NumPy 操作。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the Overset grid simulation for all test cases.\n    \"\"\"\n\n    def calc_gamma_true(Gamma0, a, R):\n        \"\"\"Calculates the exact circulation for a Rankine vortex.\"\"\"\n        if R > a:\n            return Gamma0\n        else:\n            return Gamma0 * (R**2 / a**2)\n\n    def rankine_velocity(x, y, xc, yc, Gamma0, a):\n        \"\"\"\n        Calculates the velocity field (ux, uy) for a Rankine vortex.\n        x, y can be scalars or NumPy arrays.\n        \"\"\"\n        dx = x - xc\n        dy = y - yc\n        r = np.sqrt(dx**2 + dy**2)\n\n        # Avoid division by zero at the center\n        r_safe = np.where(r == 0, 1e-15, r)\n        \n        # Calculate tangential speed u_theta based on radius\n        u_theta = np.zeros_like(r)\n        \n        # Inner core (solid body rotation)\n        mask_inner = r = a\n        if np.any(mask_inner):\n            u_theta[mask_inner] = (Gamma0 / (2 * np.pi * a**2)) * r[mask_inner]\n            \n        # Outer region (potential vortex)\n        mask_outer = r > a\n        if np.any(mask_outer):\n            u_theta[mask_outer] = Gamma0 / (2 * np.pi * r_safe[mask_outer])\n\n        # Convert tangential velocity to Cartesian components (ux, uy)\n        # u = u_theta * (-sin(theta), cos(theta)) = u_theta * (-dy/r, dx/r)\n        ux = -u_theta * dy / r_safe\n        uy = u_theta * dx / r_safe\n        \n        # Set velocity to zero exactly at the center\n        if np.isscalar(r) and r == 0:\n            return 0.0, 0.0\n        elif not np.isscalar(r):\n            ux[r == 0] = 0.0\n            uy[r == 0] = 0.0\n\n        return ux, uy\n\n    def generate_grid_data(grid_def, vortex_params):\n        \"\"\"\n        Generates grid coordinates and samples the velocity field on them.\n        \"\"\"\n        xmin, xmax, ymin, ymax = grid_def['domain']\n        h = grid_def['h']\n        \n        # Create grid coordinates, adding small epsilon to include endpoint\n        x_coords = np.arange(xmin, xmax + h / 2, h)\n        y_coords = np.arange(ymin, ymax + h / 2, h)\n        \n        xx, yy = np.meshgrid(x_coords, y_coords, indexing='xy')\n        \n        ux, uy = rankine_velocity(\n            xx, yy, vortex_params['xc'], vortex_params['yc'], \n            vortex_params['Gamma0'], vortex_params['a']\n        )\n        \n        return x_coords, y_coords, ux, uy\n\n    def bilinear_interp_vectorized(xq, yq, x_coords, y_coords, u_data):\n        \"\"\"\n        Performs vectorized bilinear interpolation on a uniform grid.\n        Handles clamping for out-of-bounds points.\n        \"\"\"\n        xmin, xmax = x_coords[0], x_coords[-1]\n        ymin, ymax = y_coords[0], y_coords[-1]\n        hx = x_coords[1] - x_coords[0]\n        hy = y_coords[1] - y_coords[0]\n        \n        # Clamp query points to grid domain\n        xq_c = np.clip(xq, xmin, xmax)\n        yq_c = np.clip(yq, ymin, ymax)\n        \n        # Calculate floating-point indices\n        i_float = (xq_c - xmin) / hx\n        j_float = (yq_c - ymin) / hy\n        \n        # Clip indices to be safely within bounds for integer conversion\n        i_float = np.clip(i_float, 0, len(x_coords) - 1.000001)\n        j_float = np.clip(j_float, 0, len(y_coords) - 1.000001)\n        \n        # Get lower-left integer indices and fractional parts\n        i_low = i_float.astype(np.int32)\n        j_low = j_float.astype(np.int32)\n        s = i_float - i_low\n        t = j_float - j_low\n        \n        # Gather values at the four corners of the cell\n        f00 = u_data[j_low, i_low]\n        f10 = u_data[j_low, i_low + 1]\n        f01 = u_data[j_low + 1, i_low]\n        f11 = u_data[j_low + 1, i_low + 1]\n        \n        # Perform interpolation\n        interp_vals = (1 - s) * (1 - t) * f00 + s * (1 - t) * f10 + \\\n                      (1 - s) * t * f01 + s * t * f11\n        \n        return interp_vals\n\n    def composite_sampler(xq, yq, bg_grid_data, ov_grid_data, ov_patch_bounds):\n        \"\"\"\n        Samples the velocity from the appropriate grid (background or overset).\n        \"\"\"\n        bg_x, bg_y, bg_ux, bg_uy = bg_grid_data\n        ov_x, ov_y, ov_ux, ov_uy = ov_grid_data\n        ov_xmin, ov_xmax, ov_ymin, ov_ymax = ov_patch_bounds\n        \n        # Determine which points are inside the overset patch\n        is_inside = (xq >= ov_xmin)  (xq = ov_xmax)  (yq >= ov_ymin)  (yq = ov_ymax)\n        is_outside = ~is_inside\n        \n        # Initialize output arrays\n        ux_out = np.zeros_like(xq, dtype=float)\n        uy_out = np.zeros_like(yq, dtype=float)\n        \n        # Interpolate from overset grid for inside points\n        if np.any(is_inside):\n            ux_out[is_inside] = bilinear_interp_vectorized(xq[is_inside], yq[is_inside], ov_x, ov_y, ov_ux)\n            uy_out[is_inside] = bilinear_interp_vectorized(xq[is_inside], yq[is_inside], ov_x, ov_y, ov_uy)\n            \n        # Interpolate from background grid for outside points\n        if np.any(is_outside):\n            ux_out[is_outside] = bilinear_interp_vectorized(xq[is_outside], yq[is_outside], bg_x, bg_y, bg_ux)\n            uy_out[is_outside] = bilinear_interp_vectorized(xq[is_outside], yq[is_outside], bg_x, bg_y, bg_uy)\n            \n        return ux_out, uy_out\n\n    def calculate_circulation(sampler_func, R, xc, yc, M):\n        \"\"\"\n        Calculates circulation using the midpoint rule for a line integral.\n        \"\"\"\n        d_theta = 2 * np.pi / M\n        thetas = np.arange(0, 2 * np.pi, d_theta)\n        \n        # Angles for line segments\n        theta_start = thetas\n        theta_end = thetas + d_theta\n        \n        # Angles for velocity evaluation at midpoints\n        theta_mid = thetas + d_theta / 2\n        \n        # Midpoint coordinates for velocity sampling\n        x_mid = xc + R * np.cos(theta_mid)\n        y_mid = yc + R * np.sin(theta_mid)\n        \n        # Get velocities at all midpoints in one call\n        u_mid_x, u_mid_y = sampler_func(x_mid, y_mid)\n        \n        # Displacement vectors (ds_x, ds_y) for each segment\n        ds_x = R * (np.cos(theta_end) - np.cos(theta_start))\n        ds_y = R * (np.sin(theta_end) - np.sin(theta_start))\n        \n        # Sum of dot products u_mid . ds\n        integrands = u_mid_x * ds_x + u_mid_y * ds_y\n        Gamma = np.sum(integrands)\n        \n        return Gamma\n\n    # Define test cases from the problem statement\n    test_cases = [\n        # Case 1\n        {'hb': 0.04, 'ho': 0.01, 'xo': 0.0, 'yo': 0.0, 'w': 0.5, 'h': 0.8,\n         'xc0': -0.6, 'yc0': 0.0, 'dx': 0.7, 'dy': 0.0,\n         'Gamma0': 1.0, 'a': 0.05, 'R': 0.25, 'M': 1024},\n        # Case 2\n        {'hb': 0.08, 'ho': 0.02, 'xo': 0.0, 'yo': 0.0, 'w': 0.5, 'h': 0.6,\n         'xc0': -0.7, 'yc0': 0.0, 'dx': 0.9, 'dy': 0.0,\n         'Gamma0': 1.0, 'a': 0.05, 'R': 0.25, 'M': 1024},\n        # Case 3\n        {'hb': 0.05, 'ho': 0.01, 'xo': 0.0, 'yo': 0.0, 'w': 0.4, 'h': 0.6,\n         'xc0': -0.45, 'yc0': 0.0, 'dx': 0.6, 'dy': 0.0,\n         'Gamma0': 1.0, 'a': 0.05, 'R': 0.35, 'M': 1536},\n        # Case 4\n        {'hb': 0.04, 'ho': 0.01, 'xo': 0.0, 'yo': 0.0, 'w': 0.5, 'h': 0.8,\n         'xc0': -0.7, 'yc0': 0.0, 'dx': 0.1, 'dy': 0.0,\n         'Gamma0': 1.0, 'a': 0.05, 'R': 0.25, 'M': 1024},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters\n        Gamma0, a, R, M = case['Gamma0'], case['a'], case['R'], case['M']\n        \n        # Calculate exact circulation for normalization\n        Gamma_true = calc_gamma_true(Gamma0, a, R)\n\n        # Common grid definitions\n        bg_domain = [-1., 1., -1., 1.]\n        bg_grid_def = {'domain': bg_domain, 'h': case['hb']}\n        \n        ov_patch_bounds = [case['xo'] - case['w']/2, case['xo'] + case['w']/2,\n                             case['yo'] - case['h']/2, case['yo'] + case['h']/2]\n        ov_grid_def = {'domain': ov_patch_bounds, 'h': case['ho']}\n\n        # --- \"Before\" state (t0) ---\n        xc0, yc0 = case['xc0'], case['yc0']\n        vortex_params0 = {'xc': xc0, 'yc': yc0, 'Gamma0': Gamma0, 'a': a}\n        \n        bg_grid_data0 = generate_grid_data(bg_grid_def, vortex_params0)\n        ov_grid_data0 = generate_grid_data(ov_grid_def, vortex_params0)\n        \n        def sampler0(xq, yq):\n            return composite_sampler(xq, yq, bg_grid_data0, ov_grid_data0, ov_patch_bounds)\n\n        Gamma_before = calculate_circulation(sampler0, R, xc0, yc0, M)\n\n        # --- \"After\" state (t1) ---\n        xc1, yc1 = xc0 + case['dx'], yc0 + case['dy']\n        vortex_params1 = {'xc': xc1, 'yc': yc1, 'Gamma0': Gamma0, 'a': a}\n\n        bg_grid_data1 = generate_grid_data(bg_grid_def, vortex_params1)\n        ov_grid_data1 = generate_grid_data(ov_grid_def, vortex_params1)\n\n        def sampler1(xq, yq):\n            return composite_sampler(xq, yq, bg_grid_data1, ov_grid_data1, ov_patch_bounds)\n        \n        Gamma_after = calculate_circulation(sampler1, R, xc1, yc1, M)\n\n        # --- Calculate relative change ---\n        rel_change = (Gamma_after - Gamma_before) / Gamma_true if Gamma_true != 0 else 0.0\n        \n        results.append([Gamma_before, Gamma_after, rel_change])\n\n    # Format the final output string exactly as required\n    result_str = \",\".join([f\"[{gb},{ga},{rc}]\" for gb, ga, rc in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}