{
    "hands_on_practices": [
        {
            "introduction": "The exchange of information between overlapping grids is the cornerstone of the overset methodology, a process facilitated by interpolation. To truly grasp how overset solvers function, one must first understand the mechanics of this data transfer. This foundational exercise guides you through the derivation of trilinear interpolation weights for a standard hexahedral donor cell, demonstrating how the elegant principle of a tensor product extends simple one-dimensional linear interpolation into three dimensions. ",
            "id": "3982831",
            "problem": "In an overset (Chimera) grid interpolation for Computational Fluid Dynamics (CFD), consider a target point lying inside a donor hexahedral cell. The interpolation within the donor cell is performed using trilinear tensor-product interpolation. Let the local isoparametric coordinates of the target point be $(\\xi,\\eta,\\zeta)\\in[-1,1]^3$, obtained from the standard isoparametric mapping for a trilinear hexahedral element. Define along each logical axis a fractional coordinate $\\phi_{\\alpha}\\in[0,1]$ for $\\alpha\\in\\{x,y,z\\}$ based on the local coordinates. Starting from first principles of one-dimensional linear interpolation and its tensor-product extension to three dimensions, derive the general form of the vertex weight $w_{ijk}$ for the vertex indexed by $(i,j,k)\\in\\{0,1\\}^3$ in terms of $\\phi_{x}$, $\\phi_{y}$, and $\\phi_{z}$. Clearly state how each $\\phi_{\\alpha}$ is computed from the corresponding local coordinate.\n\nThen, for a target point whose local coordinates are $(\\xi,\\eta,\\zeta)=(0.3,-0.5,0.8)$, compute the specific weight associated with the vertex $(i,j,k)=(1,0,1)$. Provide your final numerical result as a dimensionless number rounded to five significant figures.",
            "solution": "The problem is assessed to be valid as it is scientifically grounded in the principles of numerical methods for computational fluid dynamics, is well-posed with a clear objective and sufficient information, and uses objective, formal language. We may proceed with a solution.\n\nThe core of the problem lies in the derivation and application of trilinear interpolation weights for a hexahedral element. We begin from the first principle of one-dimensional linear interpolation.\n\nConsider a one-dimensional line segment defined by two nodes, indexed $i=0$ and $i=1$. We can define a local \"fractional\" coordinate $\\phi \\in [0,1]$ that spans this segment, such that $\\phi=0$ at node $0$ and $\\phi=1$ at node $1$. A value $f(\\phi)$ at any point along this segment can be interpolated from the nodal values $f_0$ and $f_1$ using a weighted average:\n$$ f(\\phi) = N_0(\\phi) f_0 + N_1(\\phi) f_1 $$\nwhere $N_0(\\phi)$ and $N_1(\\phi)$ are the linear basis functions, also known as shape functions. For the interpolation to be exact at the nodes, we must have $N_0(0)=1$, $N_0(1)=0$, $N_1(0)=0$, and $N_1(1)=1$. The unique linear polynomials satisfying these conditions are:\n$$ N_0(\\phi) = 1 - \\phi $$\n$$ N_1(\\phi) = \\phi $$\nA compact expression for these two shape functions, using the index $i \\in \\{0, 1\\}$, is:\n$$ N_i(\\phi) = \\phi^i (1-\\phi)^{1-i} $$\n\nTo extend this to three dimensions for a hexahedral element, we employ the principle of tensor products. The hexahedron can be viewed as the tensor product of three one-dimensional line segments along three orthogonal logical axes. We define a set of fractional coordinates $(\\phi_x, \\phi_y, \\phi_z)$, each in the range $[0,1]$, corresponding to the logical directions. A vertex in this logical cube is identified by the triplet of indices $(i,j,k)$, where each index can be $0$ or $1$.\n\nThe interpolation weight $w_{ijk}$ assigned to the vertex $(i,j,k)$ for a target point at $(\\phi_x, \\phi_y, \\phi_z)$ is the product of the one-dimensional shape functions for each corresponding coordinate and index:\n$$ w_{ijk}(\\phi_x, \\phi_y, \\phi_z) = N_i(\\phi_x) N_j(\\phi_y) N_k(\\phi_z) $$\nSubstituting the compact expression for the 1D shape functions, we derive the general form of the vertex weight:\n$$ w_{ijk}(\\phi_x, \\phi_y, \\phi_z) = \\left( \\phi_x^i (1-\\phi_x)^{1-i} \\right) \\left( \\phi_y^j (1-\\phi_y)^{1-j} \\right) \\left( \\phi_z^k (1-\\phi_z)^{1-k} \\right) $$\nThis is the general expression for the interpolation weight at vertex $(i,j,k) \\in \\{0,1\\}^3$ as a function of the fractional coordinates $(\\phi_x, \\phi_y, \\phi_z)$.\n\nThe problem provides the local coordinates of the target point in the standard isoparametric coordinate system $(\\xi, \\eta, \\zeta)$, where each coordinate ranges from $-1$ to $1$. The fractional coordinates $\\phi_{\\alpha} \\in [0,1]$ (where $\\alpha \\in \\{x,y,z\\}$ corresponds to the logical directions associated with $\\xi, \\eta, \\zeta$ respectively) are obtained through a simple linear mapping. For a coordinate $\\chi \\in [-1,1]$, the corresponding fractional coordinate $\\phi \\in [0,1]$ is given by:\n$$ \\phi = \\frac{\\chi - (-1)}{1 - (-1)} = \\frac{\\chi+1}{2} $$\nTherefore, the relationships are:\n$$ \\phi_x = \\frac{\\xi+1}{2} $$\n$$ \\phi_y = \\frac{\\eta+1}{2} $$\n$$ \\phi_z = \\frac{\\zeta+1}{2} $$\n\nNow, we proceed to the specific calculation. The target point is given by $(\\xi, \\eta, \\zeta) = (0.3, -0.5, 0.8)$. First, we compute the corresponding fractional coordinates:\n$$ \\phi_x = \\frac{0.3 + 1}{2} = \\frac{1.3}{2} = 0.65 $$\n$$ \\phi_y = \\frac{-0.5 + 1}{2} = \\frac{0.5}{2} = 0.25 $$\n$$ \\phi_z = \\frac{0.8 + 1}{2} = \\frac{1.8}{2} = 0.9 $$\nThe target point in fractional coordinates is $(\\phi_x, \\phi_y, \\phi_z) = (0.65, 0.25, 0.9)$.\n\nWe need to compute the specific weight $w_{101}$ for the vertex indexed by $(i,j,k)=(1,0,1)$. Using the general formula for $w_{ijk}$ with these indices:\n$$ w_{101}(\\phi_x, \\phi_y, \\phi_z) = \\left( \\phi_x^1 (1-\\phi_x)^{1-1} \\right) \\left( \\phi_y^0 (1-\\phi_y)^{1-0} \\right) \\left( \\phi_z^1 (1-\\phi_z)^{1-1} \\right) $$\n$$ w_{101}(\\phi_x, \\phi_y, \\phi_z) = (\\phi_x) (1-\\phi_y) (\\phi_z) $$\nSubstituting the calculated fractional coordinates:\n$$ w_{101} = (0.65) \\times (1 - 0.25) \\times (0.9) $$\n$$ w_{101} = 0.65 \\times 0.75 \\times 0.9 $$\n$$ w_{101} = 0.4875 \\times 0.9 $$\n$$ w_{101} = 0.43875 $$\nThis value already has exactly five significant figures, so no further rounding is required.",
            "answer": "$$\\boxed{0.43875}$$"
        },
        {
            "introduction": "Moving from the core mechanism of interpolation, we now address a critical aspect of practical implementation: ensuring the geometric robustness of the grid assembly. The process of \"hole-cutting\"—defining the boundary where a body-fitted grid supplants a background grid—is fraught with challenges that can lead to simulation-crashing \"sliver\" cells. This practice delves into the derivation of a robust safety margin, forcing a confrontation with real-world error sources like CAD manufacturing tolerances and the geometric simplifications inherent in any discrete grid. ",
            "id": "3982925",
            "problem": "In an overset grid (Chimera) methodology for aerospace computational fluid dynamics, hole cutting near a smooth watertight parametric Computer-Aided Design (CAD) surface is performed by classifying background-grid cells relative to the surface and then eroding the resulting cut by a safety margin to prevent thin “sliver” overlaps between overlapping component grids. Consider a single smooth surface patch with local principal curvature magnitude $\\kappa$ at a point of interest. The CAD geometry provides pointwise evaluation with a certified geometric tolerance $\\epsilon$, meaning the returned surface points deviate from the true analytic surface by at most $\\epsilon$ in the Hausdorff sense. The background grid in the neighborhood is quasi-uniform with nominal edge length $h$, and the surface is locally well-resolved in the sense that $h \\ll 1/\\kappa$. Assume the local surface can be approximated by its osculating circle of radius $R = 1/\\kappa$ in the normal section that attains the maximal curvature at the point of interest, and that the classification of cells relative to the surface relies on planar approximation over spans of length $\\mathcal{O}(h)$.\n\nYour task is to propose a robust, curvature-aware safety margin $\\delta$ for morphological erosion of the hole (that is, enlarge the blanked region by $\\delta$) that provably removes sliver overlaps caused by the combined effect of CAD tolerance and curvature-induced deviation between the true surface and its piecewise-planar approximation over spans of size $h$. Start from geometric first principles and justify each step by bounding the maximum normal deviation between a circular arc of radius $R$ and its chord of length at most $h$. Adopt a small-parameter approximation consistent with $h \\ll R$, keeping the lowest nontrivial order in $h/R$.\n\nDerive a closed-form analytic expression for the minimal safety margin $\\delta(h,\\kappa,\\epsilon)$ that guarantees removal of such curvature- and tolerance-induced slivers under worst-case alignment of the chord span with the principal curvature direction. You may assume that any additional numerical classification errors are negligible compared to the geometric effects above. Express your final answer in meters, given that $h$ and $\\epsilon$ are in meters and $\\kappa$ is in inverse meters. Your final answer must be a single analytic expression for $\\delta(h,\\kappa,\\epsilon)$ in terms of $h$, $\\kappa$, and $\\epsilon$ only.",
            "solution": "The provided problem is scientifically grounded, well-posed, and objective. It describes a standard geometric challenge in computational fluid dynamics (CFD) grid generation, specifically for overset (Chimera) grids. The concepts of CAD tolerance, principal curvature, and piecewise-planar approximation are fundamental to this field. The givens are self-contained and sufficient to derive a solution. Therefore, the problem is valid.\n\nThe objective is to derive a minimal safety margin, $\\delta$, for hole cutting that robustly prevents the formation of \"sliver\" cells. These slivers arise from discrepancies between the true geometric surface and the simplified representation used for classifying grid cells. The problem identifies two primary sources of this discrepancy:\n\n1.  The inherent geometric tolerance of the Computer-Aided Design (CAD) model, denoted by $\\epsilon$.\n2.  The error introduced by approximating the curved surface with planar facets over a characteristic length scale $h$ of a background grid cell.\n\nA robust safety margin must account for the worst-case scenario where these two errors additively combine. The total required margin is the sum of the maximum possible deviations from each independent source. Let $\\delta_{\\epsilon}$ be the deviation from CAD tolerance and $\\delta_{\\text{curv}}$ be the deviation from the curvature-induced approximation. The total margin is:\n$$\n\\delta = \\delta_{\\epsilon} + \\delta_{\\text{curv}}\n$$\n\nFirst, we consider the contribution from the CAD tolerance. The problem states that the CAD surface deviates from the true analytic surface by at most $\\epsilon$. In a worst-case scenario, the true surface can be shifted by a normal distance $\\epsilon$ from the reported CAD surface. Therefore, the margin required to account for this uncertainty is simply $\\epsilon$.\n$$\n\\delta_{\\epsilon} = \\epsilon\n$$\n\nNext, we quantify the curvature-induced deviation, $\\delta_{\\text{curv}}$. The problem instructs us to model the surface locally as its osculating circle, whose radius $R$ is the reciprocal of the local maximum principal curvature magnitude, $\\kappa$.\n$$\nR = \\frac{1}{\\kappa}\n$$\nThe planar approximation is a chord of this circle with a length at most $h$. The maximum deviation between a circular arc and its chord occurs at the midpoint of the chord and is known as the sagitta. This deviation represents $\\delta_{\\text{curv}}$.\n\nTo calculate the sagitta, we use basic geometry. A right-angled triangle is formed by the radius $R$ (the hypotenuse), half the chord length $\\frac{h}{2}$ (one leg), and the distance from the circle's center to the chord, which is $R - \\delta_{\\text{curv}}$ (the other leg). By the Pythagorean theorem:\n$$\n\\left(R - \\delta_{\\text{curv}}\\right)^{2} + \\left(\\frac{h}{2}\\right)^{2} = R^{2}\n$$\nSolving for $\\delta_{\\text{curv}}$ exactly yields:\n$$\n\\delta_{\\text{curv}} = R - \\sqrt{R^{2} - \\frac{h^{2}}{4}}\n$$\nFactoring out $R$:\n$$\n\\delta_{\\text{curv}} = R \\left(1 - \\sqrt{1 - \\frac{h^{2}}{4R^{2}}}\\right)\n$$\nGiven that the surface is well-resolved ($h \\ll R$), the term $\\frac{h^{2}}{4R^{2}}$ is very small. We use the Taylor series expansion for $\\sqrt{1-x}$ around $x=0$, which is $1 - \\frac{x}{2} - \\mathcal{O}(x^2)$. Keeping the lowest nontrivial order:\n$$\n\\sqrt{1 - \\frac{h^{2}}{4R^{2}}} \\approx 1 - \\frac{1}{2}\\left(\\frac{h^{2}}{4R^{2}}\\right) = 1 - \\frac{h^{2}}{8R^{2}}\n$$\nSubstituting this approximation back into the expression for $\\delta_{\\text{curv}}$:\n$$\n\\delta_{\\text{curv}} \\approx R \\left(1 - \\left(1 - \\frac{h^{2}}{8R^{2}}\\right)\\right) = R \\left(\\frac{h^{2}}{8R^{2}}\\right) = \\frac{h^{2}}{8R}\n$$\nNow, substituting $R = 1/\\kappa$:\n$$\n\\delta_{\\text{curv}} = \\frac{h^{2}\\kappa}{8}\n$$\nThis expression gives the maximum normal deviation between the true curved surface and its planar approximation over a length scale $h$.\n\nFinally, we combine the two components. The total safety margin $\\delta$ is the sum of the maximum CAD tolerance and the maximum curvature-induced deviation.\n$$\n\\delta(h, \\kappa, \\epsilon) = \\delta_{\\epsilon} + \\delta_{\\text{curv}} = \\epsilon + \\frac{h^{2}\\kappa}{8}\n$$\nThis is the minimal, robust, curvature-aware safety margin required to provably prevent sliver overlaps arising from the specified geometric effects. The units are consistent: $\\epsilon$ is in meters, and for $\\frac{h^{2}\\kappa}{8}$, the units are $\\frac{\\text{m}^{2} \\cdot \\text{m}^{-1}}{1} = \\text{m}$.",
            "answer": "$$\n\\boxed{\\epsilon + \\frac{h^{2} \\kappa}{8}}\n$$"
        },
        {
            "introduction": "Having mastered the mechanics of interpolation and the geometry of hole-cutting, this final practice synthesizes these concepts to investigate their ultimate impact on simulation accuracy. An ideal numerical scheme should conserve physical quantities perfectly, but the interpolation inherent in overset methods can introduce errors like numerical diffusion. This exercise asks you to build a numerical experiment from the ground up, using the classic case of an advecting vortex to directly measure the loss of circulation—a tangible metric of diffusion—as it crosses a grid interface, providing invaluable insight into the conservation properties of your overset simulation. ",
            "id": "3982917",
            "problem": "Construct a complete, runnable program that simulates a two-grid Overset (Chimera) method in two spatial dimensions to quantify the numerical diffusion of vorticity when a sharp vortex translates across an overset interface. Begin from fundamental principles: for an incompressible, inviscid flow with conservative body forces, Kelvin’s circulation theorem states that the circulation of velocity around a material contour is invariant in time. Let the true flow field be a Rankine vortex advected by a uniform translation, and let the Rankine vortex be characterized by total circulation $\\Gamma_0$ and core radius $a$, with tangential velocity given by\n$$\nu_\\theta(r) = \n\\begin{cases}\n\\dfrac{\\Gamma_0}{2\\pi r}, & r > a,\\\\\\\\\n\\dfrac{\\Gamma_0}{2\\pi a^2}\\,r, & r \\le a.\n\\end{cases}\n$$\nThe exact circulation around a circle of radius $R$ centered at the vortex center is\n$$\n\\Gamma_{\\text{true}}(R) =\n\\begin{cases}\n\\Gamma_0, & R > a,\\\\\\\\\n\\Gamma_0\\,\\dfrac{R^2}{a^2}, & R \\le a.\n\\end{cases}\n$$\nModel an Overset (Chimera) configuration composed of a uniform background Cartesian grid covering the rectangular domain $\\left[x_{\\min},x_{\\max}\\right]\\times\\left[y_{\\min},y_{\\max}\\right]$ with grid spacing $h_b$, and a finer body grid covering a rectangular subdomain (the overset patch) with grid spacing $h_o$. The composite field is defined by bilinear interpolation from the body grid for points inside the patch and from the background grid for points outside. The vortex center is initially at $(x_c^0,y_c^0)$ and then advects to $(x_c^1,y_c^1)=(x_c^0,y_c^0)+\\mathbf{U}\\,\\Delta t$. Because the uniform translation contributes zero to the line integral around a closed curve, it suffices to translate the vortex center while evaluating the vortex velocity field.\n\nYour program must:\n- Represent the Rankine vortex velocity field $\\mathbf{u}(x,y)$ centered at $(x_c,y_c)$ via $\\mathbf{u}=\\left(u_x,u_y\\right)$, where $u_\\theta(r)$ is mapped to Cartesian components by the unit tangent $\\hat{\\mathbf{t}}=\\left(-\\sin\\theta,\\cos\\theta\\right)$ with $\\theta$ the polar angle about $(x_c,y_c)$ and $r$ the radial distance.\n- Build uniform grids at time $t_0$ and $t_1$ for both the background and the body patch, sampling the analytic vortex field at their node locations.\n- Define a composite sampler that, given $(x,y)$, returns $\\mathbf{u}(x,y)$ by bilinear interpolation from the body grid if $(x,y)$ lies inside the patch and from the background grid otherwise.\n- Approximate the circulation $\\Gamma=\\oint \\mathbf{u}\\cdot d\\mathbf{s}$ around a circle of radius $R$ centered at the vortex center using $M$ uniform quadrature points in angle $\\theta\\in[0,2\\pi)$ (angles in radians). Use the midpoint rule: with $\\theta_i$ uniformly spaced and $\\Delta\\theta=2\\pi/M$, approximate $d\\mathbf{s}$ by $\\mathbf{x}_{i+1}-\\mathbf{x}_i$ where $\\mathbf{x}_i=(x_c+R\\cos\\theta_i,\\;y_c+R\\sin\\theta_i)$ and evaluate $\\mathbf{u}$ at the midpoint angle $\\theta_{i+\\frac{1}{2}}$.\n- Compute $\\Gamma_{\\text{before}}$ at $t_0$ and $\\Gamma_{\\text{after}}$ at $t_1$ from the composite sampler, and report the dimensionless relative change $(\\Gamma_{\\text{after}}-\\Gamma_{\\text{before}})/\\Gamma_{\\text{true}}(R)$.\n\nAll quantities are nondimensional; angles must be in radians. The bilinear interpolation should be performed on axis-aligned uniform grids, and handling of query points on or near grid boundaries must be robust via clamping to valid interpolation cells.\n\nImplement the following test suite of parameter sets to exercise the overset interface behavior. For each case, the domain is $\\left[x_{\\min},x_{\\max}\\right]\\times\\left[y_{\\min},y_{\\max}\\right]=[-1,1]\\times[-1,1]$, and the overset patch is a rectangle centered at $(x_o,y_o)$ with half-widths $(w/2,h/2)$, that is $[x_o-w/2,x_o+w/2]\\times[y_o-h/2,y_o+h/2]$. The variables and constants are:\n\n- Case $1$ (happy path crossing with fine body grid):\n  - $h_b=0.04$, $h_o=0.01$,\n  - $(x_o,y_o)=(0,0)$, $w=0.5$, $h=0.8$,\n  - $(x_c^0,y_c^0)=(-0.6,0)$, $\\Delta x=0.7$, $\\Delta y=0$, hence $(x_c^1,y_c^1)=(0.1,0)$,\n  - $\\Gamma_0=1$, $a=0.05$, $R=0.25$, $M=1024$.\n\n- Case $2$ (coarse background grid causing stronger diffusion):\n  - $h_b=0.08$, $h_o=0.02$,\n  - $(x_o,y_o)=(0,0)$, $w=0.5$, $h=0.6$,\n  - $(x_c^0,y_c^0)=(-0.7,0)$, $\\Delta x=0.9$, $\\Delta y=0$, hence $(x_c^1,y_c^1)=(0.2,0)$,\n  - $\\Gamma_0=1$, $a=0.05$, $R=0.25$, $M=1024$.\n\n- Case $3$ (circle intersecting the overset interface after crossing):\n  - $h_b=0.05$, $h_o=0.01$,\n  - $(x_o,y_o)=(0,0)$, $w=0.4$, $h=0.6$,\n  - $(x_c^0,y_c^0)=(-0.45,0)$, $\\Delta x=0.6$, $\\Delta y=0$, hence $(x_c^1,y_c^1)=(0.15,0)$,\n  - $\\Gamma_0=1$, $a=0.05$, $R=0.35$, $M=1536$.\n\n- Case $4$ (no crossing; both evaluations on background grid):\n  - $h_b=0.04$, $h_o=0.01$,\n  - $(x_o,y_o)=(0,0)$, $w=0.5$, $h=0.8$,\n  - $(x_c^0,y_c^0)=(-0.7,0)$, $\\Delta x=0.1$, $\\Delta y=0$, hence $(x_c^1,y_c^1)=(-0.6,0)$,\n  - $\\Gamma_0=1$, $a=0.05$, $R=0.25$, $M=1024$.\n\nYour program should produce a single line of output containing, for each test case in order, the triple $[\\Gamma_{\\text{before}},\\Gamma_{\\text{after}},(\\Gamma_{\\text{after}}-\\Gamma_{\\text{before}})/\\Gamma_{\\text{true}}(R)]$ as a comma-separated list of lists enclosed in square brackets (for example, $[[g_{1,0},g_{1,1},\\delta_1],[g_{2,0},g_{2,1},\\delta_2],\\ldots]$). All outputs must be dimensionless floating-point numbers.",
            "solution": "The user-provided problem is valid. It is scientifically grounded in the principles of fluid dynamics and computational fluid dynamics (CFD), specifically concerning Kelvin's circulation theorem and the application of Overset (Chimera) grid methodologies. The problem is well-posed, with all necessary parameters, definitions, and constraints provided to construct a unique, deterministic solution. The language is objective and the setup is a standard numerical experiment to quantify numerical error, in this case, numerical diffusion.\n\nThe solution proceeds by developing a Python program that simulates the described scenario. The core of the problem is to quantify the change in the numerically-computed circulation of a vortex as it translates across the interface between a coarse background grid and a fine overset grid. In an ideal, continuous flow governed by the specified incompressible and inviscid dynamics, Kelvin's circulation theorem asserts that the circulation around a material contour remains constant. Any change in the computed circulation is therefore a numerical artifact, representing error introduced by the discretization scheme. The Overset grid method, where different parts of the domain are resolved by different grids, is known to introduce such errors at the grid interfaces, manifesting as spurious diffusion or dispersion.\n\nThe methodology is implemented through the following sequence of steps:\n\n1.  **Analytic Velocity Field**: The velocity field of a Rankine vortex is defined analytically. The vortex is characterized by its total circulation $\\Gamma_0$ and core radius $a$. Its tangential velocity $u_\\theta (r)$ is a function of the radial distance $r$ from the vortex center $(x_c, y_c)$. This continuous velocity field serves as the \"ground truth\" for our simulation. The Cartesian velocity components $(u_x, u_y)$ at a point $(x, y)$ are derived from the tangential velocity $u_\\theta$ and the geometry:\n    $$ u_x = -u_\\theta \\frac{y - y_c}{r}, \\quad u_y = u_\\theta \\frac{x - x_c}{r} $$\n    where $r = \\sqrt{(x-x_c)^2 + (y-y_c)^2}$.\n\n2.  **Grid Discretization**: The continuous domain is discretized using two uniform Cartesian grids: a background grid with spacing $h_b$ and a finer overset \"body\" grid with spacing $h_o$ covering a sub-domain. At each time instant ($t_0$ and $t_1$), the analytic velocity field, centered at the corresponding vortex position ($(x_c^0, y_c^0)$ or $(x_c^1, y_c^1)$), is sampled at every node of both grids. This produces discrete velocity fields $(u_x, u_y)$ stored in 2D arrays for each grid.\n\n3.  **Composite Field Sampler**: A composite sampler function is constructed to model the Overset grid logic. For any given query point $(x, y)$, this function first determines if the point lies inside the rectangular region of the overset grid.\n    - If it is inside, the function performs bilinear interpolation on the fine overset grid's discrete data to find the velocity $(u_x, u_y)$.\n    - If it is outside, it performs bilinear interpolation on the coarse background grid's data.\n    The bilinear interpolation for a point $(x, y)$ within a grid cell with corners $(x_i, y_j)$, $(x_{i+1}, y_j)$, $(x_i, y_{j+1})$, and $(x_{i+1}, y_{j+1})$ and corresponding field values $f_{i,j}$, $f_{i+1,j}$, $f_{i,j+1}$, $f_{i+1,j+1}$ is given by:\n    $$ f(x, y) \\approx (1-s)(1-t)f_{i,j} + s(1-t)f_{i+1,j} + (1-s)tf_{i,j+1} + stf_{i+1,j+1} $$\n    where $s = (x - x_i)/h_x$ and $t = (y - y_j)/h_y$ are the normalized coordinates within the cell, and $h_x, h_y$ are the grid spacings. To ensure robustness, query points outside a grid's domain are clamped to the boundary before interpolation.\n\n4.  **Circulation Calculation**: The circulation $\\Gamma = \\oint_C \\mathbf{u} \\cdot d\\mathbf{s}$ is numerically approximated around a circular path $C$ of radius $R$ centered on the vortex. The circle is discretized into $M$ segments. The line integral is approximated using a midpoint rule sum:\n    $$ \\Gamma_{\\text{num}} \\approx \\sum_{k=0}^{M-1} \\mathbf{u}(\\mathbf{x}_{\\text{mid},k}) \\cdot (\\mathbf{x}_{k+1} - \\mathbf{x}_k) $$\n    Here, $\\mathbf{x}_k$ are points on the circle at angles $\\theta_k = 2\\pi k/M$. The vector $\\mathbf{x}_{k+1} - \\mathbf{x}_k$ represents the segment $d\\mathbf{s}$. The velocity $\\mathbf{u}$ is evaluated at the angular midpoint of the segment, $\\mathbf{x}_{\\text{mid},k}$, using the composite sampler. This approach ensures that the velocity evaluation point is representative for the segment.\n\n5.  **Quantification of Numerical Diffusion**: The entire process is performed twice: once for the initial state (`before`, at time $t_0$) and once for the final state (`after`, at time $t_1$). This yields two numerical circulation values, $\\Gamma_{\\text{before}}$ and $\\Gamma_{\\text{after}}$. The dimensionless relative change, $(\\Gamma_{\\text{after}} - \\Gamma_{\\text{before}}) / \\Gamma_{\\text{true}}(R)$, is then computed. The exact circulation, $\\Gamma_{\\text{true}}(R)$, is used for normalization and is calculated from the analytical formula. Since Kelvin's theorem predicts zero change, this calculated value directly quantifies the numerical error introduced by the grid transition.\n\nThe final program implements these steps for each test case, reporting the computed circulation values and their relative change in the specified format. The use of vectorized NumPy operations is prioritized for computational efficiency.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the Overset grid simulation for all test cases.\n    \"\"\"\n\n    def calc_gamma_true(Gamma0, a, R):\n        \"\"\"Calculates the exact circulation for a Rankine vortex.\"\"\"\n        if R > a:\n            return Gamma0\n        else:\n            return Gamma0 * (R**2 / a**2)\n\n    def rankine_velocity(x, y, xc, yc, Gamma0, a):\n        \"\"\"\n        Calculates the velocity field (ux, uy) for a Rankine vortex.\n        x, y can be scalars or NumPy arrays.\n        \"\"\"\n        dx = x - xc\n        dy = y - yc\n        r = np.sqrt(dx**2 + dy**2)\n\n        # Avoid division by zero at the center\n        r_safe = np.where(r == 0, 1e-15, r)\n        \n        # Calculate tangential speed u_theta based on radius\n        u_theta = np.zeros_like(r)\n        \n        # Inner core (solid body rotation)\n        mask_inner = r <= a\n        if np.any(mask_inner):\n            u_theta[mask_inner] = (Gamma0 / (2 * np.pi * a**2)) * r[mask_inner]\n            \n        # Outer region (potential vortex)\n        mask_outer = r > a\n        if np.any(mask_outer):\n            u_theta[mask_outer] = Gamma0 / (2 * np.pi * r_safe[mask_outer])\n\n        # Convert tangential velocity to Cartesian components (ux, uy)\n        # u = u_theta * (-sin(theta), cos(theta)) = u_theta * (-dy/r, dx/r)\n        ux = -u_theta * dy / r_safe\n        uy = u_theta * dx / r_safe\n        \n        # Set velocity to zero exactly at the center\n        if np.isscalar(r) and r == 0:\n            return 0.0, 0.0\n        elif not np.isscalar(r):\n            ux[r == 0] = 0.0\n            uy[r == 0] = 0.0\n\n        return ux, uy\n\n    def generate_grid_data(grid_def, vortex_params):\n        \"\"\"\n        Generates grid coordinates and samples the velocity field on them.\n        \"\"\"\n        xmin, xmax, ymin, ymax = grid_def['domain']\n        h = grid_def['h']\n        \n        # Create grid coordinates, adding small epsilon to include endpoint\n        x_coords = np.arange(xmin, xmax + h / 2, h)\n        y_coords = np.arange(ymin, ymax + h / 2, h)\n        \n        xx, yy = np.meshgrid(x_coords, y_coords, indexing='xy')\n        \n        ux, uy = rankine_velocity(\n            xx, yy, vortex_params['xc'], vortex_params['yc'], \n            vortex_params['Gamma0'], vortex_params['a']\n        )\n        \n        return x_coords, y_coords, ux, uy\n\n    def bilinear_interp_vectorized(xq, yq, x_coords, y_coords, u_data):\n        \"\"\"\n        Performs vectorized bilinear interpolation on a uniform grid.\n        Handles clamping for out-of-bounds points.\n        \"\"\"\n        xmin, xmax = x_coords[0], x_coords[-1]\n        ymin, ymax = y_coords[0], y_coords[-1]\n        hx = x_coords[1] - x_coords[0]\n        hy = y_coords[1] - y_coords[0]\n        \n        # Clamp query points to grid domain\n        xq_c = np.clip(xq, xmin, xmax)\n        yq_c = np.clip(yq, ymin, ymax)\n        \n        # Calculate floating-point indices\n        i_float = (xq_c - xmin) / hx\n        j_float = (yq_c - ymin) / hy\n        \n        # Clip indices to be safely within bounds for integer conversion\n        i_float = np.clip(i_float, 0, len(x_coords) - 1.000001)\n        j_float = np.clip(j_float, 0, len(y_coords) - 1.000001)\n        \n        # Get lower-left integer indices and fractional parts\n        i_low = i_float.astype(np.int32)\n        j_low = j_float.astype(np.int32)\n        s = i_float - i_low\n        t = j_float - j_low\n        \n        # Gather values at the four corners of the cell\n        f00 = u_data[j_low, i_low]\n        f10 = u_data[j_low, i_low + 1]\n        f01 = u_data[j_low + 1, i_low]\n        f11 = u_data[j_low + 1, i_low + 1]\n        \n        # Perform interpolation\n        interp_vals = (1 - s) * (1 - t) * f00 + s * (1 - t) * f10 + \\\n                      (1 - s) * t * f01 + s * t * f11\n        \n        return interp_vals\n\n    def composite_sampler(xq, yq, bg_grid_data, ov_grid_data, ov_patch_bounds):\n        \"\"\"\n        Samples the velocity from the appropriate grid (background or overset).\n        \"\"\"\n        bg_x, bg_y, bg_ux, bg_uy = bg_grid_data\n        ov_x, ov_y, ov_ux, ov_uy = ov_grid_data\n        ov_xmin, ov_xmax, ov_ymin, ov_ymax = ov_patch_bounds\n        \n        # Determine which points are inside the overset patch\n        is_inside = (xq >= ov_xmin)  (xq = ov_xmax)  \\\n                    (yq >= ov_ymin)  (yq = ov_ymax)\n        is_outside = ~is_inside\n        \n        # Initialize output arrays\n        ux_out = np.zeros_like(xq, dtype=float)\n        uy_out = np.zeros_like(yq, dtype=float)\n        \n        # Interpolate from overset grid for inside points\n        if np.any(is_inside):\n            ux_out[is_inside] = bilinear_interp_vectorized(xq[is_inside], yq[is_inside], ov_x, ov_y, ov_ux)\n            uy_out[is_inside] = bilinear_interp_vectorized(xq[is_inside], yq[is_inside], ov_x, ov_y, ov_uy)\n            \n        # Interpolate from background grid for outside points\n        if np.any(is_outside):\n            ux_out[is_outside] = bilinear_interp_vectorized(xq[is_outside], yq[is_outside], bg_x, bg_y, bg_ux)\n            uy_out[is_outside] = bilinear_interp_vectorized(xq[is_outside], yq[is_outside], bg_x, bg_y, bg_uy)\n            \n        return ux_out, uy_out\n\n    def calculate_circulation(sampler_func, R, xc, yc, M):\n        \"\"\"\n        Calculates circulation using the midpoint rule for a line integral.\n        \"\"\"\n        d_theta = 2 * np.pi / M\n        thetas = np.arange(0, 2 * np.pi, d_theta)\n        \n        # Angles for line segments\n        theta_start = thetas\n        theta_end = thetas + d_theta\n        \n        # Angles for velocity evaluation at midpoints\n        theta_mid = thetas + d_theta / 2\n        \n        # Midpoint coordinates for velocity sampling\n        x_mid = xc + R * np.cos(theta_mid)\n        y_mid = yc + R * np.sin(theta_mid)\n        \n        # Get velocities at all midpoints in one call\n        u_mid_x, u_mid_y = sampler_func(x_mid, y_mid)\n        \n        # Displacement vectors (ds_x, ds_y) for each segment\n        ds_x = R * (np.cos(theta_end) - np.cos(theta_start))\n        ds_y = R * (np.sin(theta_end) - np.sin(theta_start))\n        \n        # Sum of dot products u_mid . ds\n        integrands = u_mid_x * ds_x + u_mid_y * ds_y\n        Gamma = np.sum(integrands)\n        \n        return Gamma\n\n    # Define test cases from the problem statement\n    test_cases = [\n        # Case 1\n        {'hb': 0.04, 'ho': 0.01, 'xo': 0.0, 'yo': 0.0, 'w': 0.5, 'h': 0.8,\n         'xc0': -0.6, 'yc0': 0.0, 'dx': 0.7, 'dy': 0.0,\n         'Gamma0': 1.0, 'a': 0.05, 'R': 0.25, 'M': 1024},\n        # Case 2\n        {'hb': 0.08, 'ho': 0.02, 'xo': 0.0, 'yo': 0.0, 'w': 0.5, 'h': 0.6,\n         'xc0': -0.7, 'yc0': 0.0, 'dx': 0.9, 'dy': 0.0,\n         'Gamma0': 1.0, 'a': 0.05, 'R': 0.25, 'M': 1024},\n        # Case 3\n        {'hb': 0.05, 'ho': 0.01, 'xo': 0.0, 'yo': 0.0, 'w': 0.4, 'h': 0.6,\n         'xc0': -0.45, 'yc0': 0.0, 'dx': 0.6, 'dy': 0.0,\n         'Gamma0': 1.0, 'a': 0.05, 'R': 0.35, 'M': 1536},\n        # Case 4\n        {'hb': 0.04, 'ho': 0.01, 'xo': 0.0, 'yo': 0.0, 'w': 0.5, 'h': 0.8,\n         'xc0': -0.7, 'yc0': 0.0, 'dx': 0.1, 'dy': 0.0,\n         'Gamma0': 1.0, 'a': 0.05, 'R': 0.25, 'M': 1024},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters\n        Gamma0, a, R, M = case['Gamma0'], case['a'], case['R'], case['M']\n        \n        # Calculate exact circulation for normalization\n        Gamma_true = calc_gamma_true(Gamma0, a, R)\n\n        # Common grid definitions\n        bg_domain = [-1., 1., -1., 1.]\n        bg_grid_def = {'domain': bg_domain, 'h': case['hb']}\n        \n        ov_patch_bounds = [case['xo'] - case['w']/2, case['xo'] + case['w']/2,\n                             case['yo'] - case['h']/2, case['yo'] + case['h']/2]\n        ov_grid_def = {'domain': ov_patch_bounds, 'h': case['ho']}\n\n        # --- \"Before\" state (t0) ---\n        xc0, yc0 = case['xc0'], case['yc0']\n        vortex_params0 = {'xc': xc0, 'yc': yc0, 'Gamma0': Gamma0, 'a': a}\n        \n        bg_grid_data0 = generate_grid_data(bg_grid_def, vortex_params0)\n        ov_grid_data0 = generate_grid_data(ov_grid_def, vortex_params0)\n        \n        def sampler0(xq, yq):\n            return composite_sampler(xq, yq, bg_grid_data0, ov_grid_data0, ov_patch_bounds)\n\n        Gamma_before = calculate_circulation(sampler0, R, xc0, yc0, M)\n\n        # --- \"After\" state (t1) ---\n        xc1, yc1 = xc0 + case['dx'], yc0 + case['dy']\n        vortex_params1 = {'xc': xc1, 'yc': yc1, 'Gamma0': Gamma0, 'a': a}\n\n        bg_grid_data1 = generate_grid_data(bg_grid_def, vortex_params1)\n        ov_grid_data1 = generate_grid_data(ov_grid_def, vortex_params1)\n\n        def sampler1(xq, yq):\n            return composite_sampler(xq, yq, bg_grid_data1, ov_grid_data1, ov_patch_bounds)\n        \n        Gamma_after = calculate_circulation(sampler1, R, xc1, yc1, M)\n\n        # --- Calculate relative change ---\n        rel_change = (Gamma_after - Gamma_before) / Gamma_true if Gamma_true != 0 else 0.0\n        \n        results.append([Gamma_before, Gamma_after, rel_change])\n\n    # Format the final output string exactly as required\n    result_str = \",\".join([f\"[{gb},{ga},{rc}]\" for gb, ga, rc in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}