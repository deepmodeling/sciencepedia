{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的多维流体代码之前，我们首先通过一个基础练习来巩固对界面物理核心原理的理解。幽灵流体方法（GFM）的根本目标是在离散格式中精确地施加界面上的物理条件。本练习  将使用一个一维线性声学模型，来探索压力和法向速度连续性这两个基本条件如何决定波在不同介质界面上的反射与透射，并验证其能量守恒关系。",
            "id": "3962467",
            "problem": "您的任务是为与航空航天应用中的计算流体力学（CFD）相关的双材料、一维线性声学模型，实现并评估幽灵流体法（GFM）所使用的界面条件。目标是验证和确认，在多相界面处强制施加压力和法向速度的连续性，能够产生物理上一致的波在具有不同声阻抗的材料间的反射和透射。您的程序必须为每个测试用例计算由所计算的反射波和透射波所隐含的分数能量不平衡，从而为界面算子提供一个验证和确认的基准。\n\n起点和物理模型：对每种均匀材料使用一维线性声学模型，其声阻抗 $Z$ 定义为 $Z=\\rho c$，其中 $\\rho$ 是密度，$c$ 是声速。一个振幅为 $P_i$ 的右行平面声压波，其关联的法向速度振幅为 $u_i=P_i/Z$。一个左行波的速度振幅为 $u=-P/Z$，这是由于传播方向的原因。在两种材料之间的静止、无粘性、完美接触的界面上，物理上正确的界面条件是压力连续性和法向速度连续性。对于刚性气体材料，使用经过充分测试的关系式 $c=\\sqrt{\\gamma\\,(p_0+p_{\\infty})/\\rho}$，其中 $\\gamma$ 是比热比，$p_0$ 是基础热力学压力，$p_{\\infty}$ 是刚性压力。\n\n任务说明：\n- 对于每个测试用例，计算左侧（$Z_L$）和右侧（$Z_R$）的声阻抗 $Z$。\n- 对于给定的入射侧（左侧或右侧），强制施加幽灵流体法界面条件：跨界面的压力连续性和法向速度连续性。根据这些条件，确定入射介质中的反射波压力振幅 $P_r$ 和另一介质中的透射波压力振幅 $P_t$。\n- 将每个波的能量通量（也称为声强）计算为 $I=P^2/Z$，为每个波使用相应的阻抗。使用 $I_i$ 表示入射波，$I_r$ 表示反射波，$I_t$ 表示透射波。\n- 对每个测试用例，以小数形式报告分数能量不平衡 $\\varepsilon=\\lvert I_i-I_r-I_t\\rvert/I_i$。\n\n单位和数值精度：\n- 使用国际单位制（SI）。密度 $\\rho$ 必须以 $\\mathrm{kg/m^3}$ 为单位，声速 $c$ 以 $\\mathrm{m/s}$ 为单位，压力 $p$ 以 $\\mathrm{Pa}$ 为单位，强度 $I$ 以 $\\mathrm{W/m^2}$ 为单位。\n- 对每个用例，将最终的分数能量不平衡 $\\varepsilon$ 表示为一个无单位的小数。\n\n算法约束：\n- 使用所述的界面条件从第一性原理推导 $P_r$ 和 $P_t$；不要使用未经推导引入的简化公式。\n- 如果测试用例指定必须通过刚性气体关系式计算声速，则使用 $c=\\sqrt{\\gamma\\,(p_0+p_{\\infty})/\\rho}$ 及所提供的参数；否则直接使用提供的声速。\n\n测试套件：\n为以下四个测试用例提供结果。每个用例都指定了是使用刚性气体声速还是给定的声速、左侧和右侧的材料属性、入射压力振幅以及波的入射侧。\n\n- 用例 A（空气到水，刚性气体）：\n  - 使用刚性气体计算声速：是。\n  - 左侧材料（空气）：$\\rho_L=1.225$ $\\mathrm{kg/m^3}$，$\\gamma_L=1.4$，$p_{\\infty,L}=0$ $\\mathrm{Pa}$，$p_{0,L}=101325$ $\\mathrm{Pa}$。\n  - 右侧材料（水）：$\\rho_R=1000.0$ $\\mathrm{kg/m^3}$，$\\gamma_R=4.4$，$p_{\\infty,R}=6.0\\times 10^{8}$ $\\mathrm{Pa}$，$p_{0,R}=101325$ $\\mathrm{Pa}$。\n  - 入射压力振幅：$P_i=1000.0$ $\\mathrm{Pa}$。\n  - 入射自：左侧。\n\n- 用例 B（阻抗相等，直接声速）：\n  - 使用刚性气体计算声速：否。\n  - 左侧：$\\rho_L=1000.0$ $\\mathrm{kg/m^3}$，$c_L=1500.0$ $\\mathrm{m/s}$。\n  - 右侧：$\\rho_R=500.0$ $\\mathrm{kg/m^3}$，$c_R=3000.0$ $\\mathrm{m/s}$。\n  - 入射压力振幅：$P_i=500.0$ $\\mathrm{Pa}$。\n  - 入射自：左侧。\n\n- 用例 C（强失配，从右侧入射，直接声速）：\n  - 使用刚性气体计算声速：否。\n  - 左侧：$\\rho_L=800.0$ $\\mathrm{kg/m^3}$，$c_L=300.0$ $\\mathrm{m/s}$。\n  - 右侧：$\\rho_R=1200.0$ $\\mathrm{kg/m^3}$，$c_R=2000.0$ $\\mathrm{m/s}$。\n  - 入射压力振幅：$P_i=750.0$ $\\mathrm{Pa}$。\n  - 入射自：右侧。\n\n- 用例 D（中度失配，直接声速）：\n  - 使用刚性气体计算声速：否。\n  - 左侧：$\\rho_L=1200.0$ $\\mathrm{kg/m^3}$，$c_L=400.0$ $\\mathrm{m/s}$。\n  - 右侧：$\\rho_R=1200.0$ $\\mathrm{kg/m^3}$，$c_R=800.0$ $\\mathrm{m/s}$。\n  - 入射压力振幅：$P_i=200.0$ $\\mathrm{Pa}$。\n  - 入射自：左侧。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用例 A、用例 B、用例 C 和用例 D 的能量不平衡结果，按此顺序排列，形式为用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4]$）。每个 $x_k$ 必须是对应情况下以小数表示的 $\\varepsilon$ 值。",
            "solution": "该问题要求实现并验证一维、双材料线性声学模型的界面条件，这是一维幽灵流体法（GFM）在航空航天计算流体力学（CFD）中的一个基础要素。核心任务是验证在材料界面处强制施加压力和法向速度的连续性，是否能导致入射、反射和透射声波的能量守恒。这通过计算几个测试用例的分数能量不平衡来实现。\n\n物理模型基于线性声学。对于密度为 $\\rho$、声速为 $c$ 的均匀介质，声阻抗定义为 $Z = \\rho c$。对于振幅为 $P$ 的右行平面压力波，相关的粒子速度振幅为 $u = P/Z$。对于左行波，由于相对于空间坐标的传播方向改变，速度为 $u = -P/Z$。\n\n假设左侧材料（L）和右侧材料（R）之间的界面位于 $x=0$。对于 $x0$ 的区域，材料属性为 $\\rho_L$ 和 $c_L$，产生的阻抗为 $Z_L = \\rho_L c_L$。对于 $x>0$ 的区域，属性为 $\\rho_R$ 和 $c_R$，阻抗为 $Z_R = \\rho_R c_R$。\n\n对于静止、无粘性、完美接触的界面，其基本界面条件是：\n1. 压力连续性：$p_{total, L}(0, t) = p_{total, R}(0, t)$。\n2. 法向速度连续性：$u_{total, L}(0, t) = u_{total, R}(0, t)$。\n\n我们将通过应用这些条件，从入射波（$P_i$）推导反射波（$P_r$）和透射波（$P_t$）的振幅。推导过程取决于入射波的方向。\n\n**情况1：从左侧入射**\n\n振幅为 $P_i$ 的入射波从左侧（$x0$）向界面传播。这会产生一个振幅为 $P_r$ 的反射波，传播回左侧介质；以及一个振幅为 $P_t$ 的透射波，传播到右侧介质中。\n\n-   在左侧介质中（$x0$）：总压力是入射波（右行）和反射波（左行）之和，$P_{total, L} = P_i + P_r$。总速度是 $u_{total, L} = u_i + u_r = P_i/Z_L - P_r/Z_L$。\n-   在右侧介质中（$x>0$）：总压力来自透射波（右行），$P_{total, R} = P_t$。总速度是 $u_{total, R} = u_t = P_t/Z_R$。\n\n在 $x=0$ 处应用界面条件：\n1. 压力连续性：$P_i + P_r = P_t$。\n2. 速度连续性：$(P_i - P_r) / Z_L = P_t / Z_R$。\n\n我们现在有两个未知数（$P_r$ 和 $P_t$）的两个线性方程组。为求解该系统，我们可以从第二个方程中表示出 $P_t$ 为 $P_t = (Z_R/Z_L)(P_i - P_r)$，并将其代入第一个方程：\n$$P_i + P_r = \\frac{Z_R}{Z_L}(P_i - P_r)$$\n$$P_i Z_L + P_r Z_L = P_i Z_R - P_r Z_R$$\n$$P_r(Z_L + Z_R) = P_i(Z_R - Z_L)$$\n由此得出反射压力振幅：\n$$P_r = \\left(\\frac{Z_R - Z_L}{Z_R + Z_L}\\right) P_i$$\n\n为了求 $P_t$，我们将这个 $P_r$ 的结果代回压力连续性方程：\n$$P_t = P_i + P_r = P_i + \\left(\\frac{Z_R - Z_L}{Z_R + Z_L}\\right) P_i = P_i \\left(1 + \\frac{Z_R - Z_L}{Z_R + Z_L}\\right) = P_i \\left(\\frac{Z_R + Z_L + Z_R - Z_L}{Z_R + Z_L}\\right)$$\n由此得出透射压力振幅：\n$$P_t = \\left(\\frac{2 Z_R}{Z_L + Z_R}\\right) P_i$$\n\n**情况2：从右侧入射**\n\n振幅为 $P_i$ 的入射波从右侧（$x>0$）向界面传播。这会产生一个反射波（$P_r$），传播回右侧介质；以及一个透射波（$P_t$），传播到左侧介质中。\n\n-   在右侧介质中（$x>0$）：总压力为 $P_{total, R} = P_i + P_r$，其中 $P_i$ 是左行的，$P_r$ 是右行的。总速度为 $u_{total, R} = u_i + u_r = -P_i/Z_R + P_r/Z_R$。\n-   在左侧介质中（$x0$）：总压力来自透射波（左行），$P_{total, L} = P_t$。总速度为 $u_{total, L} = u_t = -P_t/Z_L$。\n\n在 $x=0$ 处应用界面条件：\n1. 压力连续性：$P_t = P_i + P_r$。\n2. 速度连续性：$-P_t / Z_L = (-P_i + P_r) / Z_R$。\n\n将第一个方程代入第二个方程：\n$$-(P_i + P_r) / Z_L = (-P_i + P_r) / Z_R$$\n$$-P_i Z_R - P_r Z_R = -P_i Z_L + P_r Z_L$$\n$$P_i(Z_L - Z_R) = P_r(Z_L + Z_R)$$\n由此得出反射压力振幅：\n$$P_r = \\left(\\frac{Z_L - Z_R}{Z_L + Z_R}\\right) P_i$$\n\n为了求 $P_t$，将 $P_r$ 代回压力连续性方程：\n$$P_t = P_i + P_r = P_i + \\left(\\frac{Z_L - Z_R}{Z_L + Z_R}\\right) P_i = P_i \\left(1 + \\frac{Z_L - Z_R}{Z_L + Z_R}\\right) = P_i \\left(\\frac{Z_L + Z_R + Z_L - Z_R}{Z_L + Z_R}\\right)$$\n由此得出透射压力振幅：\n$$P_t = \\left(\\frac{2 Z_L}{Z_L + Z_R}\\right) P_i$$\n\n**能量守恒验证**\n\n问题将波的声强（能量通量）定义为 $I = P^2/Z$。对于入射波 $I_i$、反射波 $I_r$ 和透射波 $I_t$，能量守恒原理要求入射能量通量等于出射能量通量之和：$I_i = I_r + I_t$。\n\n让我们为从左侧入射的情况验证这一点。\n入射波和反射波在介质 L 中，因此它们的强度为 $I_i = P_i^2/Z_L$ 和 $I_r = P_r^2/Z_L$。透射波在介质 R 中，所以其强度为 $I_t = P_t^2/Z_R$。守恒方程是：\n$$\\frac{P_i^2}{Z_L} = \\frac{P_r^2}{Z_L} + \\frac{P_t^2}{Z_R}$$\n代入 $P_r$ 和 $P_t$ 的推导表达式：\n$$\\frac{P_i^2}{Z_L} = \\frac{1}{Z_L} \\left(\\frac{Z_R - Z_L}{Z_R + Z_L} P_i\\right)^2 + \\frac{1}{Z_R} \\left(\\frac{2 Z_R}{Z_L + Z_R} P_i\\right)^2$$\n两边同除以 $P_i^2$ 并化简：\n$$\\frac{1}{Z_L} = \\frac{(Z_R - Z_L)^2}{Z_L (Z_R + Z_L)^2} + \\frac{4 Z_R^2}{Z_R (Z_L + Z_R)^2}$$\n$$\\frac{1}{Z_L} = \\frac{Z_R^2 - 2 Z_L Z_R + Z_L^2}{Z_L (Z_R + Z_L)^2} + \\frac{4 Z_L Z_R}{Z_L (Z_R + Z_L)^2}$$\n$$\\frac{1}{Z_L} = \\frac{Z_R^2 - 2 Z_L Z_R + Z_L^2 + 4 Z_L Z_R}{Z_L (Z_R + Z_L)^2}$$\n$$\\frac{1}{Z_L} = \\frac{Z_R^2 + 2 Z_L Z_R + Z_L^2}{Z_L (Z_R + Z_L)^2} = \\frac{(Z_R + Z_L)^2}{Z_L (Z_R + Z_L)^2} = \\frac{1}{Z_L}$$\n恒等式成立。对于从右侧入射的情况，也可以构建类似的证明。这从解析上证实了能量是守恒的，分数能量不平衡 $\\varepsilon=\\lvert I_i-I_r-I_t\\rvert/I_i$ 应该恒等于零。因此，数值计算将作为一个验证测试，其中任何非零的 $\\varepsilon$ 结果都将归因于浮点精度误差。\n\n对于需要使用刚性气体声速的测试用例，使用公式 $c=\\sqrt{\\gamma(p_0+p_{\\infty})/\\rho}$，其中 $\\gamma$ 是比热比，$p_0$ 是基础压力，$p_{\\infty}$ 是刚性压力。\n\n最后一步是应用这些推导出的公式，为每个指定的测试用例计算 $\\varepsilon$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_imbalance(case_params):\n    \"\"\"\n    Calculates the fractional energy imbalance for a single test case.\n\n    Args:\n        case_params (dict): A dictionary containing all parameters for the case.\n\n    Returns:\n        float: The fractional energy imbalance epsilon.\n    \"\"\"\n    # Unpack parameters\n    use_stiffened_gas = case_params[\"use_stiffened_gas\"]\n    left_props = case_params[\"left\"]\n    right_props = case_params[\"right\"]\n    P_i = case_params[\"incident_pressure\"]\n    incident_from = case_params[\"incident_from\"]\n\n    # Calculate sound speeds\n    if use_stiffened_gas:\n        # Left material sound speed\n        rho_L = left_props[\"rho\"]\n        gamma_L = left_props[\"gamma\"]\n        p_inf_L = left_props[\"p_inf\"]\n        p0_L = left_props[\"p0\"]\n        c_L = np.sqrt(gamma_L * (p0_L + p_inf_L) / rho_L)\n\n        # Right material sound speed\n        rho_R = right_props[\"rho\"]\n        gamma_R = right_props[\"gamma\"]\n        p_inf_R = right_props[\"p_inf\"]\n        p0_R = right_props[\"p0\"]\n        c_R = np.sqrt(gamma_R * (p0_R + p_inf_R) / rho_R)\n    else:\n        rho_L = left_props[\"rho\"]\n        c_L = left_props[\"c\"]\n        rho_R = right_props[\"rho\"]\n        c_R = right_props[\"c\"]\n\n    # Calculate acoustic impedances\n    Z_L = rho_L * c_L\n    Z_R = rho_R * c_R\n\n    # Determine reflected and transmitted pressure amplitudes\n    if incident_from == 'left':\n        # Incident wave in medium L, transmitted to R\n        # Reflection coefficient for pressure\n        R_p = (Z_R - Z_L) / (Z_R + Z_L)\n        # Transmission coefficient for pressure\n        T_p = (2 * Z_R) / (Z_L + Z_R)\n        \n        P_r = R_p * P_i\n        P_t = T_p * P_i\n\n        # Calculate intensities\n        I_i = P_i**2 / Z_L\n        I_r = P_r**2 / Z_L\n        I_t = P_t**2 / Z_R\n\n    elif incident_from == 'right':\n        # Incident wave in medium R, transmitted to L\n        # Reflection coefficient for pressure\n        R_p = (Z_L - Z_R) / (Z_L + Z_R)\n        # Transmission coefficient for pressure\n        T_p = (2 * Z_L) / (Z_L + Z_R)\n\n        P_r = R_p * P_i\n        P_t = T_p * P_i\n\n        # Calculate intensities\n        I_i = P_i**2 / Z_R\n        I_r = P_r**2 / Z_R\n        I_t = P_t**2 / Z_L\n    else:\n        raise ValueError(\"Invalid incident_from value. Must be 'left' or 'right'.\")\n\n    # Calculate fractional energy imbalance\n    # This should be zero analytically. Numerically, it will be close to zero.\n    if I_i == 0:\n        return 0.0\n    \n    epsilon = np.abs(I_i - I_r - I_t) / I_i\n    \n    return epsilon\n\n\ndef solve():\n    \"\"\"\n    Solves the problem for all given test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case A (air-to-water, stiffened-gas)\n        {\n            \"use_stiffened_gas\": True,\n            \"left\": {\"rho\": 1.225, \"gamma\": 1.4, \"p_inf\": 0.0, \"p0\": 101325.0},\n            \"right\": {\"rho\": 1000.0, \"gamma\": 4.4, \"p_inf\": 6.0e8, \"p0\": 101325.0},\n            \"incident_pressure\": 1000.0,\n            \"incident_from\": \"left\",\n        },\n        # Case B (equal impedances, direct sound speeds)\n        {\n            \"use_stiffened_gas\": False,\n            \"left\": {\"rho\": 1000.0, \"c\": 1500.0},\n            \"right\": {\"rho\": 500.0, \"c\": 3000.0},\n            \"incident_pressure\": 500.0,\n            \"incident_from\": \"left\",\n        },\n        # Case C (strong mismatch, incident from right, direct sound speeds)\n        {\n            \"use_stiffened_gas\": False,\n            \"left\": {\"rho\": 800.0, \"c\": 300.0},\n            \"right\": {\"rho\": 1200.0, \"c\": 2000.0},\n            \"incident_pressure\": 750.0,\n            \"incident_from\": \"right\",\n        },\n        # Case D (moderate mismatch, direct sound speeds)\n        {\n            \"use_stiffened_gas\": False,\n            \"left\": {\"rho\": 1200.0, \"c\": 400.0},\n            \"right\": {\"rho\": 1200.0, \"c\": 800.0},\n            \"incident_pressure\": 200.0,\n            \"incident_from\": \"left\",\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_imbalance(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理解了界面所需满足的物理条件后，我们来关注一个在含有表面张力的多相流模拟中至关重要的数值挑战。幽灵流体方法的成功在很大程度上取决于其几何处理的精度，尤其是在计算界面曲率时。本练习  旨在量化由水平集函数（level-set function）表示的界面几何精度如何直接影响曲率的计算误差，进而影响由杨-拉普拉斯定律（Young-Laplace law）所决定的压力跳跃，这对于控制非物理的寄生流（spurious currents）至关重要。",
            "id": "3966953",
            "problem": "您的任务是实现一个程序，用以量化由幽灵流体法（Ghost Fluid Method, GFM）施加于静态二维液滴的、由曲率引起的压力跳跃中的数值误差，并分析此误差如何依赖于界面表示的精度。其物理基础是关于毛细作用的杨-拉普拉斯定律（Young–Laplace law）：对于一个二维静态液滴（代表一个无限长圆柱体的横截面），跨界面的压力跳跃由 $\\Delta p = \\sigma \\kappa$ 给出，其中 $\\sigma$ 是表面张力系数，$\\kappa$ 是界面曲率。对于一个半径为 $R$ 的完美圆形，其精确曲率为 $\\kappa_{\\text{exact}} = 1/R$，精确压力跳跃为 $\\Delta p_{\\text{exact}} = \\sigma / R$。在幽灵流体法（GFM）中，像 $\\llbracket p \\rrbracket = \\sigma \\kappa$ 这样的跳跃条件是通过使用根据界面表示（如水平集函数）计算出的 $\\kappa$ 值在界面处施加的。您的目标是计算因近似曲率以及随之而来的压力跳跃所产生的数值误差，并探究其对界面表示保真度的依赖性。\n\n在方形域 $[0,1] \\times [0,1]$ 上构建一个包含 $N \\times N$ 个网格点的均匀笛卡尔网格，网格间距为 $h = 1/(N-1)$，并将一个半径为 $R$ 的圆形液滴置于中心 $(x_c,y_c) = (0.5, 0.5)$。使用水平集函数 $\\phi(x,y)$ 隐式地表示界面，其零水平集对应于该界面。使用以下基准和受扰动的界面表示：\n- 基准（精确有符号距离）水平集：$\\phi_{\\text{exact}}(x,y) = \\sqrt{(x - x_c)^2 + (y - y_c)^2} - R$。\n- 各向异性缩放的水平集（零水平集不变，但离界面值被扭曲）：$\\phi(x,y) = \\phi_{\\text{exact}}(x,y)\\left(1 + \\varepsilon \\cos(m \\theta)\\right)$，其中 $\\theta = \\operatorname{atan2}(y - y_c, x - x_c)$，$\\varepsilon \\ge 0$ 且整数 $m \\ge 0$。\n- 振荡性水平集扰动（零水平集保留，但近界面值被修改）：$\\phi(x,y) = \\phi_{\\text{exact}}(x,y) + \\varepsilon h \\,\\phi_{\\text{exact}}(x,y)\\,\\sin(2\\pi x)\\sin(2\\pi y)$，其中 $\\varepsilon \\ge 0$。\n\n从 $\\phi$ 出发，通过水平集恒等式 $\\kappa = \\nabla \\cdot \\left(\\nabla \\phi / \\|\\nabla \\phi\\|\\right)$ 数值计算曲率。对内部的空间导数使用二阶中心差分，在边界处使用一致的单边差分。识别所有被界面切割的网格边（水平和垂直），即 $\\phi$ 在边的两个端点节点之间符号发生变化的边。对于每个被切割的边，沿该边进行线性插值以定位过零点，并通过对两个边端点上的节点曲率值进行线性插值来计算该过零点处的曲率。将幽灵流体法（GFM）解释为在每个界面交叉点局部施加一个压力跳跃 $\\Delta p_{\\text{GFM}} = \\sigma \\kappa$，并因此将在该交叉点的跳跃误差定义为 $|\\Delta p_{\\text{GFM}} - \\Delta p_{\\text{exact}}| = \\left|\\sigma \\kappa - \\sigma/R\\right|$。通过计算均方根误差，汇总所有被切割边上的误差\n$$\nE_{\\text{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{e=1}^{M} \\left(\\sigma \\kappa_e - \\frac{\\sigma}{R}\\right)^2},\n$$\n其中 $M$ 是被切割边的数量，$\\kappa_e$ 是在交叉点 $e$ 处的插值曲率。\n\n所有量均为无量纲；不使用物理单位。角度（如 $\\theta$）必须以弧度为单位。您的代码必须对以下测试套件执行上述计算，每个测试由一个元组 $(N, R, \\sigma, \\text{mode}, \\varepsilon, m)$ 定义，其中 $\\text{mode} \\in \\{\\text{\"exact\"}, \\text{\"anisotropic\"}, \\text{\"oscillatory\"}\\}$ 选择界面表示方式，而 $m$ 仅用于各向异性模式：\n\n- 测试1（良好解析，精确界面）：$(N, R, \\sigma, \\text{mode}, \\varepsilon, m) = (128, 0.25, 1.0, \\text{\"exact\"}, 0.0, 0)$。\n- 测试2（良好解析，各向异性扭曲）：$(N, R, \\sigma, \\text{mode}, \\varepsilon, m) = (128, 0.25, 1.0, \\text{\"anisotropic\"}, 0.2, 6)$。\n- 测试3（欠解析液滴，精确界面）：$(N, R, \\sigma, \\text{mode}, \\varepsilon, m) = (64, 0.05, 1.0, \\text{\"exact\"}, 0.0, 0)$。\n- 测试4（良好解析，振荡性扰动）：$(N, R, \\sigma, \\text{mode}, \\varepsilon, m) = (128, 0.25, 1.0, \\text{\"oscillatory\"}, 0.5, 0)$。\n\n您的程序应：\n1. 根据每个测试选定的模式和参数构造 $\\phi$。\n2. 按照所述方法从 $\\phi$ 计算数值曲率场 $\\kappa$。\n3. 检测网格边上的界面交叉点，并计算每个交叉点处的插值曲率。\n4. 使用上述公式，并以 $\\Delta p_{\\text{exact}} = \\sigma/R$ 计算 $\\Delta p$ 的 $E_{\\text{RMS}}$。\n5. 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[$e_1,e_2,e_3,e_4$]”），其中每个 $e_i$ 是测试 $i$ 的 $E_{\\text{RMS}}$ 的浮点数值。\n\n无需用户输入。程序必须是完全确定性的。最终输出为浮点数，不带任何单位或百分号，并且所有角度均以弧度为单位。",
            "solution": "该问题是有效的，因为它在科学上基于计算流体动力学和多相流的原理，特别是杨-拉普拉斯定律（Young-Laplace law）和水平集方法（level-set method）。该问题是适定的，所有必要的参数和数值程序都已明确定义，确保了唯一且确定性的解。其语言客观且无歧义。所提出的任务构成了一个标准的数值分析练习，用于评估一个数值方案的精度，并且没有验证协议中列出的任何使其无效的缺陷。\n\n解决方案通过实现指定的数值算法来推进。问题的核心是计算由水平集函数 $\\phi$ 定义的界面的曲率 $\\kappa$，然后量化数值推导的压力跳跃与其解析值之间的误差。\n\n步骤如下：\n1.  **网格和水平集函数生成**：在域 $[0, 1] \\times [0, 1]$ 上建立一个均匀的笛卡尔网格。该网格由 $N \\times N$ 个点组成，网格间距为 $h = 1/(N-1)$。网格点的坐标为 $(x_i, y_j) = (i h, j h)$，其中 $i, j \\in \\{0, 1, \\dots, N-1\\}$。圆形界面的中心位于 $(x_c, y_c) = (0.5, 0.5)$，半径为 $R$。该界面由水平集函数 $\\phi(x,y) = 0$ 的零等值线表示。\n\n    对于每个测试用例，在网格上构建相应的水平集函数 $\\phi$：\n    -   基准表示是精确的有符号距离函数：\n        $$ \\phi_{\\text{exact}}(x,y) = \\sqrt{(x - x_c)^2 + (y - y_c)^2} - R $$\n    -   各向异性缩放的水平集是：\n        $$ \\phi(x,y) = \\phi_{\\text{exact}}(x,y) \\left(1 + \\varepsilon \\cos(m \\theta)\\right) $$\n        其中 $\\theta = \\operatorname{atan2}(y - y_c, x - x_c)$。此修改保留了零水平集，但改变了函数在远离界面处的梯度场。\n    -   振荡性扰动的水平集是：\n        $$ \\phi(x,y) = \\phi_{\\text{exact}}(x,y) + \\varepsilon h \\,\\phi_{\\text{exact}}(x,y)\\,\\sin(2\\pi x)\\sin(2\\pi y) $$\n        这也保留了零水平集，但引入了高频振荡，这对数值微分的精度构成了挑战。\n\n2.  **数值曲率计算**：曲率 $\\kappa$ 是使用散度公式从水平集函数计算得出的：\n    $$ \\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{\\|\\nabla \\phi\\|} \\right) = \\nabla \\cdot \\mathbf{n} $$\n    其中 $\\mathbf{n}$ 是单位法向量场。在每个网格节点上，计算分三个阶段进行：\n    -   **$\\phi$的梯度**：梯度 $\\nabla\\phi = (\\phi_x, \\phi_y) = (\\frac{\\partial\\phi}{\\partial x}, \\frac{\\partial\\phi}{\\partial y})$ 使用有限差分计算。我们对内部节点采用二阶中心差分，对边界节点采用一阶单边差分。\n    -   **法向量场**：单位法向量场 $\\mathbf{n} = (n_x, n_y)$ 通过归一化梯度来计算：\n        $$ n_x = \\frac{\\phi_x}{\\sqrt{\\phi_x^2 + \\phi_y^2}}, \\quad n_y = \\frac{\\phi_y}{\\sqrt{\\phi_x^2 + \\phi_y^2}} $$\n        在分母中加入一个小的容差 $\\epsilon_{\\text{mach}}$ 以防止在梯度可能数值上消失的区域（例如，远离界面）出现除以零的情况。\n    -   **$\\mathbf{n}$ 的散度**：曲率 $\\kappa$ 是法向量场的散度，$\\kappa = \\frac{\\partial n_x}{\\partial x} + \\frac{\\partial n_y}{\\partial y}$。$\\mathbf{n}$ 各分量的导数使用相同的有限差分格式（内部二阶中心差分，边界一阶差分）计算。\n\n3.  **界面交叉点检测与插值**：该算法识别所有与界面相交的水平和垂直网格边。如果一个连接两个节点 $A$ 和 $B$ 的边，其水平集函数在端点处符号相反，即 $\\phi_A \\cdot \\phi_B  0$，则认为该边被“切割”。对于每个被切割的边 $e$，我们执行两次线性插值：\n    -   首先，我们找到界面交叉点距节点 $A$ 沿该边的分数距离 $\\alpha \\in (0,1)$：\n        $$ \\alpha = \\frac{|\\phi_A|}{|\\phi_A| + |\\phi_B|} $$\n    -   其次，我们插值节点曲率值 $\\kappa_A$ 和 $\\kappa_B$ 来估计交叉点处的曲率 $\\kappa_e$：\n        $$ \\kappa_e = (1-\\alpha)\\kappa_A + \\alpha\\kappa_B $$\n\n4.  **误差量化**：对每个交叉点计算压力跳跃的误差。精确的压力跳跃由二维圆的杨-拉普拉斯方程（Young-Laplace equation）给出：$\\Delta p_{\\text{exact}} = \\sigma / R$。在交叉点 $e$ 处的数值压力跳跃为 $\\Delta p_{\\text{GFM}} = \\sigma \\kappa_e$。均方根（RMS）误差是在所有 $M$ 个被切割的边上汇总得到的：\n    $$ E_{\\text{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{e=1}^{M} \\left(\\sigma \\kappa_e - \\frac{\\sigma}{R}\\right)^2} $$\n    这个度量为给定的测试用例提供了一个单一的值，用以量化由曲率引起的压力跳跃的总体精度。\n\n对指定的测试用例实施这些步骤将产生所需的 $E_{\\text{RMS}}$ 值列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_rms_error(N, R, sigma, mode, epsilon, m):\n    \"\"\"\n    Computes the RMS error in the GFM pressure jump for a static 2D droplet.\n    \"\"\"\n    # 1. Grid and Level-Set Function Generation\n    h = 1.0 / (N - 1)\n    x = np.linspace(0, 1, N)\n    y = np.linspace(0, 1, N)\n    # Use 'ij' indexing for consistency with matrix row/column conventions\n    XX, YY = np.meshgrid(x, y, indexing='ij')\n\n    x_c, y_c = 0.5, 0.5\n    phi_exact = np.sqrt((XX - x_c)**2 + (YY - y_c)**2) - R\n\n    if mode == \"exact\":\n        phi = phi_exact\n    elif mode == \"anisotropic\":\n        theta_grid = np.arctan2(YY - y_c, XX - x_c)\n        phi = phi_exact * (1.0 + epsilon * np.cos(m * theta_grid))\n    elif mode == \"oscillatory\":\n        phi = phi_exact * (1.0 + epsilon * h * np.sin(2 * np.pi * XX) * np.sin(2 * np.pi * YY))\n    else:\n        raise ValueError(\"Unknown mode.\")\n\n    # 2. Numerical Curvature Calculation\n    # np.gradient uses 2nd-order central differences in the interior and\n    # 1st-order forward/backward differences at the boundaries.\n    # It returns derivatives with respect to each axis (axis 0, axis 1, ...).\n    # With 'ij' indexing, axis 0 is y and axis 1 is x, so we reverse the order.\n    # Correction: The problem description states to use central difference, and np.gradient does this.\n    # The axes argument to np.gradient is for sample spacing, not axis order.\n    # The default return order is (dy, dx). We use ij indexing, so it's (d/di, d/dj) -> (d/dx, d/dy).\n    phi_y, phi_x = np.gradient(phi, h, h)\n\n\n    # Normalize the gradient to get the normal vector field.\n    # Add a small machine epsilon to avoid division by zero.\n    norm_grad_phi = np.sqrt(phi_x**2 + phi_y**2) + np.finfo(float).eps\n    nx = phi_x / norm_grad_phi\n    ny = phi_y / norm_grad_phi\n\n    # Compute divergence of the normal field to get curvature.\n    # Here, we need d(ny)/dy and d(nx)/dx.\n    ny_y, _ = np.gradient(ny, h, h)\n    _, nx_x = np.gradient(nx, h, h)\n    kappa = nx_x + ny_y\n    \n    # 3. Interface Crossing Detection and Interpolation\n    squared_errors = []\n    \n    # Horizontal edges (connecting (i,j) and (i,j+1))\n    for i in range(N):\n        for j in range(N - 1):\n            phi1 = phi[i, j]\n            phi2 = phi[i, j + 1]\n            if phi1 * phi2  0:\n                kappa1 = kappa[i, j]\n                kappa2 = kappa[i, j + 1]\n                alpha = abs(phi1) / (abs(phi1) + abs(phi2))\n                kappa_e = (1.0 - alpha) * kappa1 + alpha * kappa2\n                \n                # 4. Error Quantification (for this crossing)\n                error_sq = (sigma * kappa_e - sigma / R)**2\n                squared_errors.append(error_sq)\n\n    # Vertical edges (connecting (i,j) and (i+1,j))\n    for i in range(N - 1):\n        for j in range(N):\n            phi1 = phi[i, j]\n            phi2 = phi[i + 1, j]\n            if phi1 * phi2  0:\n                kappa1 = kappa[i, j]\n                kappa2 = kappa[i + 1, j]\n                alpha = abs(phi1) / (abs(phi1) + abs(phi2))\n                kappa_e = (1.0 - alpha) * kappa1 + alpha * kappa2\n                \n                # 4. Error Quantification (for this crossing)\n                error_sq = (sigma * kappa_e - sigma / R)**2\n                squared_errors.append(error_sq)\n\n    # Compute final RMS error\n    if not squared_errors:\n        return 0.0\n    \n    E_RMS = np.sqrt(np.mean(squared_errors))\n    return E_RMS\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, R, sigma, mode, epsilon, m)\n        (128, 0.25, 1.0, \"exact\", 0.0, 0),\n        (128, 0.25, 1.0, \"anisotropic\", 0.2, 6),\n        (64, 0.05, 1.0, \"exact\", 0.0, 0),\n        (128, 0.25, 1.0, \"oscillatory\", 0.5, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        rms_error = calculate_rms_error(*case)\n        results.append(rms_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# The code in the problem had a slight bug related to np.gradient indexing.\n# For indexing='ij', XX.shape is (N,N) and XX[i,j] is x[j]. YY[i,j] is y[i].\n# Thus, np.gradient(phi, h, h) returns (d/dy, d/dx).\n# The code was also iterating over edges incorrectly. This has been corrected.\ndef calculate_rms_error(N, R, sigma, mode, epsilon, m):\n    \"\"\"\n    Computes the RMS error in the GFM pressure jump for a static 2D droplet.\n    Corrected version.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    x = np.linspace(0, 1, N)\n    y = np.linspace(0, 1, N)\n    XX, YY = np.meshgrid(x, y, indexing='xy')\n\n    x_c, y_c = 0.5, 0.5\n    phi_exact = np.sqrt((XX - x_c)**2 + (YY - y_c)**2) - R\n\n    if mode == \"exact\":\n        phi = phi_exact\n    elif mode == \"anisotropic\":\n        theta_grid = np.arctan2(YY - y_c, XX - x_c)\n        phi = phi_exact * (1.0 + epsilon * np.cos(m * theta_grid))\n    elif mode == \"oscillatory\":\n        phi = phi_exact * (1.0 + epsilon * h * np.sin(2 * np.pi * XX) * np.sin(2 * np.pi * YY))\n    else:\n        raise ValueError(\"Unknown mode.\")\n    \n    # For 'xy' indexing, np.gradient returns (d/dy, d/dx)\n    phi_y, phi_x = np.gradient(phi, h, h)\n\n    norm_grad_phi = np.sqrt(phi_x**2 + phi_y**2) + np.finfo(float).eps\n    nx = phi_x / norm_grad_phi\n    ny = phi_y / norm_grad_phi\n\n    # divergence of (nx, ny) is d(nx)/dx + d(ny)/dy\n    # ny_y is d(ny)/dy, nx_x is d(nx)/dx\n    ny_y, _ = np.gradient(ny, h, h)\n    _, nx_x = np.gradient(nx, h, h)\n    kappa = nx_x + ny_y\n    \n    squared_errors = []\n    \n    # Horizontal edges: (j, i) to (j, i+1)\n    for j in range(N):\n      for i in range(N - 1):\n        phi1 = phi[j, i]\n        phi2 = phi[j, i+1]\n        if phi1 * phi2  0:\n            kappa1 = kappa[j, i]\n            kappa2 = kappa[j, i+1]\n            alpha = abs(phi1) / (abs(phi1) + abs(phi2))\n            kappa_e = (1.0 - alpha) * kappa1 + alpha * kappa2\n            error_sq = (sigma * kappa_e - sigma / R)**2\n            squared_errors.append(error_sq)\n\n    # Vertical edges: (j, i) to (j+1, i)\n    for i in range(N):\n      for j in range(N - 1):\n        phi1 = phi[j, i]\n        phi2 = phi[j+1, i]\n        if phi1 * phi2  0:\n            kappa1 = kappa[j, i]\n            kappa2 = kappa[j+1, i]\n            alpha = abs(phi1) / (abs(phi1) + abs(phi2))\n            kappa_e = (1.0 - alpha) * kappa1 + alpha * kappa2\n            error_sq = (sigma * kappa_e - sigma / R)**2\n            squared_errors.append(error_sq)\n\n    if not squared_errors:\n        return 0.0\n    \n    E_RMS = np.sqrt(np.mean(squared_errors))\n    return E_RMS\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这个实践练习将前面的概念融会贯通，构建一个完整而实用的二维幽灵流体方法应用。您将亲手实现一个GFM求解器，用于模拟一个由表面张力维持内外压力差的静态液滴。通过解决这个经典的静态液滴测试案例 ，您将掌握如何修改离散控制方程（此处为泊松方程）来精确施加由曲率决定的压力跳跃条件，从而深刻理解GFM在处理任意位置界面问题时的核心思想。",
            "id": "4022595",
            "problem": "实现一个二维幽灵流体法 (GFM) 来施加由表面张力引起的跨材料界面的压力跳跃，并使用静态液滴测试验证其准确性。考虑一个边长为 $L$ 米的正方形计算域，该域在具有均匀间距 $\\Delta x = \\Delta y = L/(N-1)$ 的 $N \\times N$ 节点的笛卡尔网格上离散化。一个半径为 $R$ 米的圆形液滴，中心位于 $\\left(x_c, y_c\\right)=\\left(L/2,L/2\\right)$。令 $\\phi(x,y)$ 为符号距离水平集函数，$\\phi(x,y) = \\sqrt{(x-x_c)^2+(y-y_c)^2} - R$，其中液滴内部 $\\phi  0$，外部 $\\phi > 0$。\n\n假设每个相都处于静态平衡，因此压力场 $p(x,y)$ 是分段调和的：在两个区域中均为 $\\nabla^2 p = 0$，界面处的跳跃由 Young–Laplace 条件 $\\Delta p = \\gamma \\kappa$ 给出，其中 $\\gamma$ 是表面张力（单位为 $\\mathrm{N/m}$），$\\kappa$ 是曲率（单位为 $\\mathrm{m^{-1}}$）。对于代表圆柱形液滴平面横截面的二维圆形界面，曲率为 $\\kappa = 1/R$。在区域边界上施加齐次 Dirichlet 边界条件 $p=0$，以代表参考环境压力。使用五点有限差分格式来表示离散拉普拉斯算子，并实现幽灵流体法以在被界面切割的网格边上强制施加跳跃条件。\n\n幽灵流体法指令：对于网格节点 $(i,j)$，将离散拉普拉斯方程写为 $4 p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = b_{i,j}$。对于 $(i,j)$ 的每个邻居 $(i',j')$，如果满足 $\\phi_{i,j}\\cdot\\phi_{i',j'}  0$（即界面穿过该边），则在右侧项中添加一个跳跃贡献：\n- 如果 $\\phi_{i,j}  0$ 且 $\\phi_{i',j'} > 0$，则 $b_{i,j} \\leftarrow b_{i,j} + \\Delta p$。\n- 如果 $\\phi_{i,j} > 0$ 且 $\\phi_{i',j'}  0$，则 $b_{i,j} \\leftarrow b_{i,j} - \\Delta p$。\n这里 $\\Delta p = \\gamma \\kappa$，其中 $\\kappa = 1/R$。在区域边界节点上强行施加 $p=0$。\n\n验证指标：对于每个测试用例，按如下方式计算远离界面的无穷范数误差。定义内部掩码 $\\mathcal{M}^{-} = \\{(i,j): \\phi_{i,j}  -\\tau\\}$ 和外部掩码 $\\mathcal{M}^{+} = \\{(i,j): \\phi_{i,j} > \\tau\\}$，缓冲区 $\\tau = 1.5 \\Delta x$。令 $p_{\\text{th}}^{-} = \\Delta p$ 且 $p_{\\text{th}}^{+} = 0$。计算 $E^{-}_{\\infty} = \\max_{(i,j)\\in \\mathcal{M}^{-}} \\left| p_{i,j} - p_{\\text{th}}^{-} \\right|$ 和 $E^{+}_{\\infty} = \\max_{(i,j)\\in \\mathcal{M}^{+}} \\left| p_{i,j} - p_{\\text{th}}^{+} \\right|$。报告 $E_{\\infty} = \\max(E^{-}_{\\infty}, E^{+}_{\\infty})$。\n\n物理单位要求：将所有误差 $E_{\\infty}$ 以帕斯卡 (Pa) 为单位，表示为浮点数。\n\n测试套件：使用以下参数集来测试该方法：\n1. $L=0.01$ m, $N=64$, $R=0.002$ m, $\\gamma=0.072$ $\\mathrm{N/m}$。\n2. $L=0.01$ m, $N=32$ (粗网格), $R=0.002$ m, $\\gamma=0.072$ $\\mathrm{N/m}$。\n3. $L=0.01$ m, $N=128$ (细网格), $R=0.002$ m, $\\gamma=0.072$ $\\mathrm{N/m}$。\n4. $L=0.01$ m, $N=128$, $R=0.0005$ m (小液滴), $\\gamma=0.072$ $\\mathrm{N/m}$。\n5. $L=0.01$ m, $N=128$, $R=0.0015$ m, $\\gamma=0.050$ $\\mathrm{N/m}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有五个测试用例的误差，格式为方括号内以逗号分隔的列表（例如，“[e1,e2,e3,e4,e5]”），其中每个 $e_k$ 是一个以帕斯卡 (Pa) 为单位的浮点数。",
            "solution": "用户提供了一个有效、适定且具有科学依据的问题陈述。该问题要求针对静态液滴测试用例，实现并验证一个二维幽灵流体法 (GFM)。问题的核心是求解一个在圆形界面处存在急剧跳跃的分段调和压力场，该跳跃由 Young-Laplace 方程决定。\n\n问题是在一个边长为 $L$ 的正方形区域内找到压力场 $p(x,y)$。该区域包含一个不同流体的圆形液滴，中心位于 $(L/2, L/2)$，半径为 $R$。两种流体之间的界面由符号距离函数的零等值线表示，$\\phi(x,y) = \\sqrt{(x-L/2)^2 + (y-L/2)^2} - R$，其中液滴内部 $\\phi  0$，外部 $\\phi > 0$。在静态平衡且忽略体积力的情况下，每种流体中的压力是恒定的，这满足调和条件 $\\nabla^2 p = 0$。在界面处，存在一个由 Young-Laplace 方程决定的压力跳跃，$\\Delta p = p_{\\text{inside}} - p_{\\text{outside}} = \\gamma \\kappa$。这里，$\\gamma$ 是表面张力，$\\kappa$ 是界面曲率。对于二维圆形横截面，曲率为 $\\kappa = 1/R$。区域边界上的压力固定为参考值 $p=0$。因此，理论解是一个分段常数压力场：当 $\\phi  0$ 时 $p(x,y) = \\Delta p$，当 $\\phi > 0$ 时 $p(x,y) = 0$。\n\n问题在一个均匀的 $N \\times N$ 笛卡尔网格上离散化，网格间距为 $\\Delta x = \\Delta y = L/(N-1)$。拉普拉斯算子使用标准的五点有限差分格式进行近似：\n$$\n\\nabla^2 p \\approx \\frac{p_{i+1,j} + p_{i-1,j} + p_{i,j+1} + p_{i,j-1} - 4 p_{i,j}}{\\Delta x^2}\n$$\n问题指定将此格式重排为针对每个网格节点 $(i,j)$ 的线性方程形式：\n$$\n4 p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = b_{i,j}\n$$\n这等价于设置 $-\\Delta x^2 (\\nabla^2_h p)_{i,j} = b_{i,j}$，其中 $\\nabla^2_h$ 是离散拉普拉斯算子。对于远离界面的节点，控制方程为 $\\nabla^2 p = 0$，因此右侧项 $b_{i,j}$ 为 $0$。压力跳跃条件是通过为邻近界面的节点定义非零的 $b_{i,j}$ 值来强制施加的，这是此特定幽灵流体法的精髓。\n\nGFM 通过在离散方程的右侧为那些模板跨越界面的节点添加源项来模拟压力不连续性。该指令指出，对于节点 $(i,j)$ 及其邻居 $(i',j')$，如果界面位于它们之间（即 $\\phi_{i,j} \\cdot \\phi_{i',j'}  0$），则向 $b_{i,j}$ 添加一个贡献。\n我们来分析这个指令。考虑一个处于液相中的节点 $(i,j)$（$\\phi_{i,j}  0$）及其处于气相中的邻居 $(i+1,j)$（$\\phi_{i+1,j} > 0$）。一个严格的 GFM 会通过从气相压力外插来定义位于 $(i+1,j)$ 处的一个鬼点压力。一个一阶 GFM 将此鬼点压力定义为 $p_{i+1,j}^{\\text{ghost}} = p_{i+1,j} + \\Delta p$，其中 $p_{i+1,j}$ 是邻近节点处的真实压力。将此代入节点 $(i,j)$ 的格式中：\n$$\n4 p_{i,j} - p_{i+1,j}^{\\text{ghost}} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = 0\n$$\n$$\n4 p_{i,j} - (p_{i+1,j} + \\Delta p) - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = 0\n$$\n将其重排以匹配问题指定的格式，得到：\n$$\n4 p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = \\Delta p\n$$\n这意味着对于节点 $(i,j)$，右侧项 $b_{i,j}$ 应收到一个 $+\\Delta p$ 的贡献。这与指令相符：如果 $\\phi_{i,j}  0$ 且 $\\phi_{i',j'} > 0$，则 $b_{i,j}$ 增加 $\\Delta p$。\n反之，对于气相节点 $(i+1,j)$，跳跃为 $p_{\\text{inside}} - p_{\\text{outside}} = \\Delta p$，这意味着 $p_{\\text{outside}} - p_{\\text{inside}} = -\\Delta p$。位于节点 $(i,j)$ 处的鬼点压力为 $p_{i,j}^{\\text{ghost}} = p_{i,j} - \\Delta p$。$(i+1,j)$ 处的格式变为：\n$$\n4 p_{i+1,j} - p_{i+2,j} - p_{i,j}^{\\text{ghost}} - p_{i+1,j+1} - p_{i+1,j-1} = 0\n$$\n$$\n4 p_{i+1,j} - p_{i+2,j} - (p_{i,j} - \\Delta p) - p_{i+1,j+1} - p_{i+1,j-1} = 0\n$$\n这为节点 $(i+1,j)$ 提供了一个 $-\\Delta p$ 的右侧项贡献，这也与指令相符。任何节点的总右侧项值 $b_{i,j}$ 是其所有跨越界面的邻居贡献的总和。\n\n所有 $N \\times N$ 节点的完整离散方程组构成一个形式为 $A \\mathbf{p} = \\mathbf{b}$ 的大型稀疏线性系统。向量 $\\mathbf{p}$ 包含未知的压力值，由二维网格展开得到。矩阵 $A$ 是系数矩阵。对于一个内部节点 $(i,j)$，$A$ 的第 $k=iN+j$ 行包含五点格式的系数：对角线上为 $4$，其四个邻居对应位置为 $-1$。对于边界节点，通过将 $A$ 的相应行设置为单位行（即，对于 $l \\ne k$，$A_{k,k}=1$，$A_{k,l}=0$）并设置 $b_k=0$ 来强行施加 Dirichlet 条件 $p=0$。向量 $\\mathbf{b}$ 包含 GFM 源项，这些源项仅在邻近界面的节点处非零。\n\n求解这个稀疏线性系统以获得数值压力场 $p_{i,j}$。为了验证准确性，将数值解与已知的理论解（$p_{\\text{th}}^{-} = \\Delta p$，$p_{\\text{th}}^{+} = 0$）进行比较。误差使用无穷范数进行量化，该范数在由缓冲区距离 $\\tau = 1.5 \\Delta x$ 定义的远离界面的区域内计算。内部误差 $E^{-}_{\\infty} = \\max |p_{i,j} - p_{\\text{th}}^{-}|$ 是针对所有满足 $\\phi_{i,j}  -\\tau$ 的节点计算的，而外部误差 $E^{+}_{\\infty} = \\max |p_{i,j} - p_{\\text{th}}^{+}|$ 是针对所有满足 $\\phi_{i,j} > \\tau$ 的节点计算的。最终报告的误差是 $E_{\\infty} = \\max(E^{-}_{\\infty}, E^{+}_{\\infty})$。\n\n该算法使用 Python 实现。网格和场数据存储在 `numpy` 数组中。大型稀疏矩阵 $A$ 使用 `scipy.sparse.lil_matrix` 构建，线性系统则使用 `scipy.sparse.linalg.spsolve` 高效求解。对所提供的五个测试用例中的每一个都执行此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (L, N, R, gamma)\n        (0.01, 64, 0.002, 0.072),\n        (0.01, 32, 0.002, 0.072),\n        (0.01, 128, 0.002, 0.072),\n        (0.01, 128, 0.0005, 0.072),\n        (0.01, 128, 0.0015, 0.050),\n    ]\n\n    results = []\n    for L, N, R, gamma in test_cases:\n        error = solve_one_case(L, N, R, gamma)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_one_case(L, N, R, gamma):\n    \"\"\"\n    Implements the Ghost Fluid Method for a single static droplet test case.\n\n    Args:\n        L (float): Domain side length in meters.\n        N (int): Number of grid nodes in each dimension.\n        R (float): Droplet radius in meters.\n        gamma (float): Surface tension in N/m.\n\n    Returns:\n        float: The infinity-norm error E_inf in Pascals.\n    \"\"\"\n    # 1. Grid and Level-Set Setup\n    dx = L / (N - 1)\n    x = np.linspace(0, L, N)\n    y = np.linspace(0, L, N)\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n    \n    xc, yc = L / 2.0, L / 2.0\n    phi = np.sqrt((xx - xc)**2 + (yy - yc)**2) - R\n    \n    # 2. System Assembly (A p = b)\n    n_nodes = N * N\n    A = lil_matrix((n_nodes, n_nodes), dtype=np.float64)\n    b = np.zeros(n_nodes, dtype=np.float64)\n    \n    # Pressure jump and theoretical pressures\n    delta_p = gamma / R\n\n    # Iterate over all grid points to build matrix A and vector b\n    for i in range(N):\n        for j in range(N):\n            k = i * N + j  # Flattened 1D index\n\n            # Strong enforcement of Dirichlet boundary conditions p=0\n            if i == 0 or i == N - 1 or j == 0 or j == N - 1:\n                A[k, k] = 1.0\n                b[k] = 0.0\n                continue\n\n            # Internal nodes: 5-point stencil for the Laplacian\n            A[k, k] = 4.0\n            A[k, k - 1] = -1.0  # Neighbor (i, j-1)\n            A[k, k + 1] = -1.0  # Neighbor (i, j+1)\n            A[k, k - N] = -1.0  # Neighbor (i-1, j)\n            A[k, k + N] = -1.0  # Neighbor (i+1, j)\n\n            # GFM: Add source terms to RHS for nodes adjacent to the interface\n            # Check neighbors\n            neighbors = [(i, j - 1), (i, j + 1), (i - 1, j), (i + 1, j)]\n            for ni, nj in neighbors:\n                if phi[i, j] * phi[ni, nj]  0:\n                    if phi[i, j]  0:  # Current node is inside\n                        b[k] += delta_p\n                    else:  # Current node is outside\n                        b[k] -= delta_p\n    \n    # 3. Solve the Linear System\n    # Convert matrix to a more efficient format for solving\n    A_csc = A.tocsc()\n    p_flat = spsolve(A_csc, b)\n    p_sol = p_flat.reshape((N, N))\n\n    # 4. Error Verification\n    tau = 1.5 * dx\n    p_th_minus = delta_p\n    p_th_plus = 0.0\n\n    mask_inside = phi  -tau\n    mask_outside = phi > tau\n\n    p_values_inside = p_sol[mask_inside]\n    p_values_outside = p_sol[mask_outside]\n\n    err_inside = 0.0\n    if p_values_inside.size > 0:\n        err_inside = np.max(np.abs(p_values_inside - p_th_minus))\n\n    err_outside = 0.0\n    if p_values_outside.size > 0:\n        err_outside = np.max(np.abs(p_values_outside - p_th_plus))\n        \n    E_inf = max(err_inside, err_outside)\n    \n    return E_inf\n\nsolve()\n```"
        }
    ]
}