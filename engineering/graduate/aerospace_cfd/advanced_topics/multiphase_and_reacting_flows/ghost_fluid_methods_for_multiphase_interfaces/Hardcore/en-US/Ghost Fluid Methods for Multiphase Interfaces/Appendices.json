{
    "hands_on_practices": [
        {
            "introduction": "Mastering the Ghost Fluid Method (GFM) begins with understanding how to impose sharp jump conditions on a discrete grid. This first practice focuses on the canonical problem of a static droplet, where surface tension creates a pressure discontinuity governed by the Young-Laplace equation, $\\Delta p = \\gamma \\kappa$. By implementing a simplified GFM to solve for the pressure field, you will gain hands-on experience with the fundamental mechanics of defining \"ghost\" values to enforce physical jumps, a cornerstone of the method's application to multiphase flows. ",
            "id": "4022595",
            "problem": "Implement a two-dimensional Ghost Fluid Method (GFM) to impose a pressure jump across a material interface due to surface tension and verify accuracy using a static droplet test. Consider a square computational domain of side length $L$ in meters, discretized on a Cartesian grid of $N \\times N$ nodes with uniform spacing $\\Delta x = \\Delta y = L/(N-1)$. A circular droplet of radius $R$ (in meters) is centered at $(x_c, y_c)=(L/2,L/2)$. Let $\\phi(x,y)$ be the signed distance level-set function, $\\phi(x,y) = \\sqrt{(x-x_c)^2+(y-y_c)^2} - R$, with $\\phi < 0$ inside the droplet and $\\phi > 0$ outside.\n\nAssume static equilibrium in each phase, so the pressure field $p(x,y)$ is piecewise harmonic: $\\nabla^2 p = 0$ in both regions, with a jump at the interface given by the Young–Laplace condition $\\Delta p = \\gamma \\kappa$, where $\\gamma$ is the surface tension (in $\\mathrm{N/m}$) and $\\kappa$ is the curvature (in $\\mathrm{m^{-1}}$). For a two-dimensional circular interface representing a planar cross-section of a cylindrical droplet, the curvature is $\\kappa = 1/R$. Impose homogeneous Dirichlet boundary conditions $p=0$ on the domain boundary to represent a reference ambient pressure. Use the five-point finite-difference stencil for the discrete Laplacian and implement the Ghost Fluid Method to enforce the jump condition across grid edges cut by the interface.\n\nGhost Fluid Method directive: For a grid node $(i,j)$, write the discrete Laplace equation as $4 p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = b_{i,j}$. For each neighbor $(i',j')$ of $(i,j)$ such that $\\phi_{i,j} \\cdot \\phi_{i',j'} < 0$ (the interface crosses the edge), add a jump contribution to the right-hand side:\n- If $\\phi_{i,j} < 0$ and $\\phi_{i',j'} > 0$, then $b_{i,j} \\leftarrow b_{i,j} + \\Delta p$.\n- If $\\phi_{i,j} > 0$ and $\\phi_{i',j'} < 0$, then $b_{i,j} \\leftarrow b_{i,j} - \\Delta p$.\nHere $\\Delta p = \\gamma \\kappa$ with $\\kappa = 1/R$. Apply $p=0$ strongly on the domain boundary nodes.\n\nVerification metric: For each test case, compute the infinity-norm error away from the interface as follows. Define inside mask $\\mathcal{M}^{-} = \\{(i,j): \\phi_{i,j} < -\\tau\\}$ and outside mask $\\mathcal{M}^{+} = \\{(i,j): \\phi_{i,j} > \\tau\\}$ with buffer $\\tau = 1.5 \\Delta x$. Let $p_{\\text{th}}^{-} = \\Delta p$ and $p_{\\text{th}}^{+} = 0$. Compute $E^{-}_{\\infty} = \\max_{(i,j)\\in \\mathcal{M}^{-}} \\left| p_{i,j} - p_{\\text{th}}^{-} \\right|$ and $E^{+}_{\\infty} = \\max_{(i,j)\\in \\mathcal{M}^{+}} \\left| p_{i,j} - p_{\\text{th}}^{+} \\right|$. Report $E_{\\infty} = \\max(E^{-}_{\\infty}, E^{+}_{\\infty})$.\n\nPhysical units requirement: Express all errors $E_{\\infty}$ in pascals (Pa) as floating-point numbers.\n\nTest suite: Use the following parameter sets to exercise the method:\n1. $L=0.01$ m, $N=64$, $R=0.002$ m, $\\gamma=0.072$ $\\mathrm{N/m}$.\n2. $L=0.01$ m, $N=32$ (coarse grid), $R=0.002$ m, $\\gamma=0.072$ $\\mathrm{N/m}$.\n3. $L=0.01$ m, $N=128$ (fine grid), $R=0.002$ m, $\\gamma=0.072$ $\\mathrm{N/m}$.\n4. $L=0.01$ m, $N=128$, $R=0.0005$ m (small droplet), $\\gamma=0.072$ $\\mathrm{N/m}$.\n5. $L=0.01$ m, $N=128$, $R=0.0015$ m, $\\gamma=0.050$ $\\mathrm{N/m}$.\n\nFinal output format: Your program should produce a single line of output containing the errors for all five test cases as a comma-separated list enclosed in square brackets (e.g., \"[e1,e2,e3,e4,e5]\"), where each $e_k$ is a float in pascals (Pa).",
            "solution": "The user has provided a valid, well-posed, and scientifically grounded problem statement. The problem requires the implementation and verification of a two-dimensional Ghost Fluid Method (GFM) for a static droplet test case. The core of the problem is to solve for a piecewise harmonic pressure field with a sharp jump at a circular interface, governed by the Young-Laplace equation.\n\nThe problem is to find the pressure field $p(x,y)$ in a square domain of side length $L$. The domain contains a circular droplet of a different fluid, centered at $(L/2, L/2)$ with radius $R$. The interface between the two fluids is represented by the zero-contour of a signed distance function, $\\phi(x,y) = \\sqrt{(x-L/2)^2 + (y-L/2)^2} - R$, where $\\phi < 0$ is inside the droplet and $\\phi > 0$ is outside. In static equilibrium and neglecting body forces, the pressure in each fluid is constant, which satisfies the condition of being harmonic, $\\nabla^2 p = 0$. At the interface, there is a pressure jump dictated by the Young-Laplace equation, $\\Delta p = p_{\\text{inside}} - p_{\\text{outside}} = \\gamma \\kappa$. Here, $\\gamma$ is the surface tension and $\\kappa$ is the interface curvature. For a two-dimensional circular-cross section, the curvature is $\\kappa = 1/R$. The pressure on the domain boundary is fixed at a reference value of $p=0$. The theoretical solution is therefore a piecewise constant pressure field: $p(x,y) = \\Delta p$ for $\\phi < 0$ and $p(x,y) = 0$ for $\\phi > 0$.\n\nThe problem is discretized on a uniform $N \\times N$ Cartesian grid with spacing $\\Delta x = \\Delta y = L/(N-1)$. The Laplace operator is approximated using the standard five-point finite-difference stencil:\n$$\n\\nabla^2 p \\approx \\frac{p_{i+1,j} + p_{i-1,j} + p_{i,j+1} + p_{i,j-1} - 4 p_{i,j}}{\\Delta x^2}\n$$\nThe problem specifies a rearrangement of this stencil into the form of a linear equation for each grid node $(i,j)$:\n$$\n4 p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = b_{i,j}\n$$\nThis is equivalent to setting $-\\Delta x^2 (\\nabla^2_h p)_{i,j} = b_{i,j}$, where $\\nabla^2_h$ is the discrete Laplacian. For nodes away from the interface, the governing equation is $\\nabla^2 p = 0$, so the right-hand side $b_{i,j}$ is $0$. The pressure jump condition is enforced by defining non-zero values for $b_{i,j}$ for nodes adjacent to the interface, which is the essence of this particular Ghost Fluid Method.\n\nThe GFM models the pressure discontinuity by adding source terms to the right-hand side of the discrete equations for nodes whose stencils cross the interface. The directive states that for a node $(i,j)$ and its neighbor $(i',j')$, if the interface lies between them (i.e., $\\phi_{i,j} \\cdot \\phi_{i',j'} < 0$), a contribution is added to $b_{i,j}$.\nLet us analyze this directive. Consider a node $(i,j)$ in the liquid phase ($\\phi_{i,j} < 0$) and its neighbor $(i+1,j)$ in the gas phase ($\\phi_{i+1,j} > 0$). A rigorous GFM would define a ghost pressure at the location of $(i+1,j)$ by extrapolating from the gas-phase pressure. A first-order GFM defines this ghost pressure as $p_{i+1,j}^{\\text{ghost}} = p_{i+1,j} + \\Delta p$, where $p_{i+1,j}$ is the real pressure at the neighboring node. Substituting this into the stencil for node $(i,j)$:\n$$\n4 p_{i,j} - p_{i+1,j}^{\\text{ghost}} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = 0\n$$\n$$\n4 p_{i,j} - (p_{i+1,j} + \\Delta p) - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = 0\n$$\nRearranging this to match the problem's specified form gives:\n$$\n4 p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1} = \\Delta p\n$$\nThis implies that for node $(i,j)$, the RHS term $b_{i,j}$ should receive a contribution of $+\\Delta p$. This matches the directive: if $\\phi_{i,j} < 0$ and $\\phi_{i',j'} > 0$, $b_{i,j}$ is increased by $\\Delta p$.\nConversely, for the gas-phase node $(i+1,j)$, the jump is $p_{\\text{inside}} - p_{\\text{outside}} = \\Delta p$, which means $p_{\\text{outside}} - p_{\\text{inside}} = -\\Delta p$. The ghost pressure at the location of node $(i,j)$ is $p_{i,j}^{\\text{ghost}} = p_{i,j} - \\Delta p$. The stencil at $(i+1,j)$ becomes:\n$$\n4 p_{i+1,j} - p_{i+2,j} - p_{i,j}^{\\text{ghost}} - p_{i+1,j+1} - p_{i+1,j-1} = 0\n$$\n$$\n4 p_{i+1,j} - p_{i+2,j} - (p_{i,j} - \\Delta p) - p_{i+1,j+1} - p_{i+1,j-1} = 0\n$$\nThis gives a RHS contribution of $-\\Delta p$ for node $(i+1,j)$, which also matches the directive. The total RHS value $b_{i,j}$ for any node is the sum of contributions from all of its neighbors that are across the interface.\n\nThe complete set of discrete equations for all $N \\times N$ nodes forms a large, sparse linear system of the form $A \\mathbf{p} = \\mathbf{b}$. The vector $\\mathbf{p}$ contains the unknown pressure values, flattened from the 2D grid. The matrix $A$ is the coefficient matrix. For an internal node $(i,j)$, row $k=iN+j$ of $A$ contains the coefficients of the 5-point stencil: $4$ on the diagonal, and $-1$ for its four neighbors. For a boundary node, the Dirichlet condition $p=0$ is enforced strongly by setting the corresponding row of $A$ to be an identity row (i.e., $A_{k,k}=1$, $A_{k,l}=0$ for $l \\ne k$) and setting $b_k=0$. The vector $\\mathbf{b}$ contains the GFM source terms, which are non-zero only for nodes adjacent to the interface.\n\nThis sparse linear system is solved to obtain the numerical pressure field $p_{i,j}$. To verify accuracy, the numerical solution is compared against the known theoretical solution ($p_{\\text{th}}^{-} = \\Delta p$, $p_{\\text{th}}^{+} = 0$). The error is quantified using the infinity norm, computed away from the interface in regions defined by a buffer distance $\\tau = 1.5 \\Delta x$. The inside error $E^{-}_{\\infty} = \\max |p_{i,j} - p_{\\text{th}}^{-}|$ is computed for all nodes where $\\phi_{i,j} < -\\tau$, and the outside error $E^{+}_{\\infty} = \\max |p_{i,j} - p_{\\text{th}}^{+}|$ is computed for all nodes where $\\phi_{i,j} > \\tau$. The final reported error is $E_{\\infty} = \\max(E^{-}_{\\infty}, E^{+}_{\\infty})$.\n\nThe algorithm is implemented in Python. Grid and field data are stored in `numpy` arrays. The large, sparse matrix $A$ is constructed using `scipy.sparse.lil_matrix` and the linear system is solved efficiently using `scipy.sparse.linalg.spsolve`. The procedure is executed for each of the five test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (L, N, R, gamma)\n        (0.01, 64, 0.002, 0.072),\n        (0.01, 32, 0.002, 0.072),\n        (0.01, 128, 0.002, 0.072),\n        (0.01, 128, 0.0005, 0.072),\n        (0.01, 128, 0.0015, 0.050),\n    ]\n\n    results = []\n    for L, N, R, gamma in test_cases:\n        error = solve_one_case(L, N, R, gamma)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_one_case(L, N, R, gamma):\n    \"\"\"\n    Implements the Ghost Fluid Method for a single static droplet test case.\n\n    Args:\n        L (float): Domain side length in meters.\n        N (int): Number of grid nodes in each dimension.\n        R (float): Droplet radius in meters.\n        gamma (float): Surface tension in N/m.\n\n    Returns:\n        float: The infinity-norm error E_inf in Pascals.\n    \"\"\"\n    # 1. Grid and Level-Set Setup\n    dx = L / (N - 1)\n    x = np.linspace(0, L, N)\n    y = np.linspace(0, L, N)\n    xx, yy = np.meshgrid(x, y)\n    \n    xc, yc = L / 2.0, L / 2.0\n    phi = np.sqrt((xx - xc)**2 + (yy - yc)**2) - R\n    \n    # 2. System Assembly (A p = b)\n    n_nodes = N * N\n    A = lil_matrix((n_nodes, n_nodes), dtype=np.float64)\n    b = np.zeros(n_nodes, dtype=np.float64)\n    \n    # Pressure jump and theoretical pressures\n    delta_p = gamma / R\n\n    # Iterate over all grid points to build matrix A and vector b\n    for i in range(N):\n        for j in range(N):\n            k = i * N + j  # Flattened 1D index\n\n            # Strong enforcement of Dirichlet boundary conditions p=0\n            if i == 0 or i == N - 1 or j == 0 or j == N - 1:\n                A[k, k] = 1.0\n                b[k] = 0.0\n                continue\n\n            # Internal nodes: 5-point stencil for the Laplacian\n            A[k, k] = 4.0\n            A[k, k + 1] = -1.0  # Neighbor (i, j+1)\n            A[k, k - 1] = -1.0  # Neighbor (i, j-1)\n            A[k, k + N] = -1.0  # Neighbor (i+1, j)\n            A[k, k - N] = -1.0  # Neighbor (i-1, j)\n\n            # GFM: Add source terms to RHS for nodes adjacent to the interface\n            # Check right neighbor (i, j+1)\n            if phi[i, j] * phi[i, j + 1] < 0:\n                if phi[i, j] < 0: b[k] += delta_p\n                else: b[k] -= delta_p\n            \n            # Check left neighbor (i, j-1)\n            if phi[i, j] * phi[i, j - 1] < 0:\n                if phi[i, j] < 0: b[k] += delta_p\n                else: b[k] -= delta_p\n            \n            # Check top neighbor (i+1, j)\n            if phi[i, j] * phi[i + 1, j] < 0:\n                if phi[i, j] < 0: b[k] += delta_p\n                else: b[k] -= delta_p\n\n            # Check bottom neighbor (i-1, j)\n            if phi[i, j] * phi[i - 1, j] < 0:\n                if phi[i, j] < 0: b[k] += delta_p\n                else: b[k] -= delta_p\n    \n    # 3. Solve the Linear System\n    # Convert matrix to a more efficient format for solving\n    A_csc = A.tocsc()\n    p_flat = spsolve(A_csc, b)\n    p_sol = p_flat.reshape((N, N))\n\n    # 4. Error Verification\n    tau = 1.5 * dx\n    p_th_minus = delta_p\n    p_th_plus = 0.0\n\n    mask_inside = phi < -tau\n    mask_outside = phi > tau\n\n    p_values_inside = p_sol[mask_inside]\n    p_values_outside = p_sol[mask_outside]\n\n    err_inside = 0.0\n    if p_values_inside.size > 0:\n        err_inside = np.max(np.abs(p_values_inside - p_th_minus))\n\n    err_outside = 0.0\n    if p_values_outside.size > 0:\n        err_outside = np.max(np.abs(p_values_outside - p_th_plus))\n        \n    E_inf = max(err_inside, err_outside)\n    \n    return E_inf\n\nsolve()\n\n```"
        },
        {
            "introduction": "In any practical GFM simulation, the pressure jump due to surface tension is not given analytically but must be computed from a discrete representation of the interface. This practice delves into this critical step, exploring how the accuracy of the computed curvature, $\\kappa$, depends on the quality of the underlying level-set function using the relation $\\kappa = \\nabla \\cdot (\\nabla \\phi / |\\nabla \\phi|)$. By analyzing the errors that arise from imperfect or perturbed level-set fields, you will develop a crucial understanding of the sources of error in multiphase simulations and the importance of maintaining a high-quality geometric representation of the interface. ",
            "id": "3966953",
            "problem": "You are tasked with implementing a program to quantify the numerical error in the curvature-induced pressure jump imposed by the Ghost Fluid Method (GFM) for a static two-dimensional droplet, and to analyze how this error depends on the accuracy of the interface representation. The physical basis is the Young–Laplace law for capillarity: for a two-dimensional static droplet (representing the cross-section of an infinite cylinder), the pressure jump across the interface is given by $\\Delta p = \\sigma \\kappa$, where $\\sigma$ is the surface tension coefficient and $\\kappa$ is the curvature of the interface. For a perfect circle of radius $R$, the exact curvature is $\\kappa_{\\text{exact}} = 1/R$, and the exact pressure jump is $\\Delta p_{\\text{exact}} = \\sigma / R$. In the Ghost Fluid Method (GFM), jump conditions like $\\llbracket p \\rrbracket = \\sigma \\kappa$ are imposed at the interface using values of $\\kappa$ computed from an interface representation such as a level set function. Your goal is to compute the numerical error that arises from approximating the curvature and, consequently, the pressure jump, and to explore its dependence on the fidelity of the interface representation.\n\nConstruct a uniform Cartesian grid on the square domain $[0,1] \\times [0,1]$ with $N \\times N$ grid points, grid spacing $h = 1/(N-1)$, and place the circular droplet centered at $(x_c,y_c) = (0.5, 0.5)$ with radius $R$. Represent the interface implicitly using a level set function $\\phi(x,y)$ whose zero level set corresponds to the interface. Use the following baseline and perturbed interface representations:\n- Baseline (exact signed-distance) level set: $\\phi_{\\text{exact}}(x,y) = \\sqrt{(x - x_c)^2 + (y - y_c)^2} - R$.\n- Anisotropically scaled level set (zero level unchanged but off-interface values distorted): $\\phi(x,y) = \\phi_{\\text{exact}}(x,y)\\left(1 + \\varepsilon \\cos(m \\theta)\\right)$, where $\\theta = \\operatorname{atan2}(y - y_c, x - x_c)$, $\\varepsilon \\ge 0$, and integer $m \\ge 0$.\n- Oscillatory level set perturbation (zero level preserved but near-interface values modified): $\\phi(x,y) = \\phi_{\\text{exact}}(x,y) + \\varepsilon h \\,\\phi_{\\text{exact}}(x,y)\\,\\sin(2\\pi x)\\sin(2\\pi y)$, where $\\varepsilon \\ge 0$.\n\nFrom $\\phi$, compute the curvature numerically via the level set identity $\\kappa = \\nabla \\cdot \\left(\\nabla \\phi / \\|\\nabla \\phi\\|\\right)$. Use second-order central differences for spatial derivatives in the interior and consistent one-sided differences at boundaries. Identify all grid edges (both horizontal and vertical) that are cut by the interface, i.e., where $\\phi$ changes sign between the two end nodes. For each cut edge, linearly interpolate along the edge to locate the zero crossing and compute the curvature at that crossing by linearly interpolating the nodal curvature values at the two edge endpoints. Interpret the Ghost Fluid Method (GFM) as imposing a pressure jump $\\Delta p_{\\text{GFM}} = \\sigma \\kappa$ locally at each interface crossing, and thus define the error in the jump at that crossing as $|\\Delta p_{\\text{GFM}} - \\Delta p_{\\text{exact}}| = \\left|\\sigma \\kappa - \\sigma/R\\right|$. Aggregate the per-crossing errors over all cut edges by computing the root-mean-square error\n$$\nE_{\\text{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{e=1}^{M} \\left(\\sigma \\kappa_e - \\frac{\\sigma}{R}\\right)^2},\n$$\nwhere $M$ is the number of cut edges and $\\kappa_e$ is the interpolated curvature at crossing $e$.\n\nAll quantities are nondimensional; no physical units are to be used. Angles, such as $\\theta$, must be in radians. Your code must perform the above computations for the following test suite, each defined by a tuple $(N, R, \\sigma, \\text{mode}, \\varepsilon, m)$ where $\\text{mode} \\in \\{\\text{\"exact\"}, \\text{\"anisotropic\"}, \\text{\"oscillatory\"}\\}$ selects the interface representation, and $m$ is used only for the anisotropic mode:\n\n- Test $1$ (well-resolved, exact interface): $(N, R, \\sigma, \\text{mode}, \\varepsilon, m) = (128, 0.25, 1.0, \\text{\"exact\"}, 0.0, 0)$.\n- Test $2$ (well-resolved, anisotropic distortion): $(N, R, \\sigma, \\text{mode}, \\varepsilon, m) = (128, 0.25, 1.0, \\text{\"anisotropic\"}, 0.2, 6)$.\n- Test $3$ (under-resolved droplet, exact interface): $(N, R, \\sigma, \\text{mode}, \\varepsilon, m) = (64, 0.05, 1.0, \\text{\"exact\"}, 0.0, 0)$.\n- Test $4$ (well-resolved, oscillatory perturbation): $(N, R, \\sigma, \\text{mode}, \\varepsilon, m) = (128, 0.25, 1.0, \\text{\"oscillatory\"}, 0.5, 0)$.\n\nYour program should:\n1. Construct $\\phi$ according to the selected mode and parameters for each test.\n2. Compute the numerical curvature field $\\kappa$ from $\\phi$ as described.\n3. Detect interface crossings on grid edges and compute the interpolated curvature at each crossing.\n4. Compute $E_{\\text{RMS}}$ for $\\Delta p$ using the formula above with $\\Delta p_{\\text{exact}} = \\sigma/R$.\n5. Produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$e_1,e_2,e_3,e_4$]\"), where each $e_i$ is the floating-point value of $E_{\\text{RMS}}$ for Test $i$.\n\nNo user input is required. The program must be completely deterministic. The final outputs are floats without any units or percentage signs, and angles are in radians throughout.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of computational fluid dynamics and multiphase flow, specifically the Young-Laplace law and the level-set method. It is well-posed, with all necessary parameters and numerical procedures clearly defined, ensuring a unique, deterministic solution. The language is objective and unambiguous. The proposed task constitutes a standard numerical analysis exercise to evaluate the accuracy of a numerical scheme, and it is free from any of the invalidating flaws outlined in the validation protocol.\n\nThe solution proceeds by implementing the specified numerical algorithm. The core of the problem is to compute the curvature $\\kappa$ of an interface defined by a level-set function $\\phi$, and then to quantify the error of a numerically-derived pressure jump against its analytical value.\n\nThe steps are as follows:\n1.  **Grid and Level-Set Function Generation**: A uniform Cartesian grid is established over the domain $[0, 1] \\times [0, 1]$. The grid consists of $N \\times N$ points, with grid spacing $h = 1/(N-1)$. The coordinates of the grid points are $(x_i, y_j) = (i h, j h)$ for $i, j \\in \\{0, 1, \\dots, N-1\\}$. The circular interface is centered at $(x_c, y_c) = (0.5, 0.5)$ with radius $R$. The interface is represented by the zero contour of a level-set function, $\\phi(x,y) = 0$.\n\n    For each test case, the appropriate level-set function $\\phi$ is constructed on the grid:\n    -   The baseline representation is the exact signed distance function:\n        $$ \\phi_{\\text{exact}}(x,y) = \\sqrt{(x - x_c)^2 + (y - y_c)^2} - R $$\n    -   The anisotropically scaled level-set is:\n        $$ \\phi(x,y) = \\phi_{\\text{exact}}(x,y) \\left(1 + \\varepsilon \\cos(m \\theta)\\right) $$\n        where $\\theta = \\operatorname{atan2}(y - y_c, x - x_c)$. This modification preserves the zero level-set but alters the function's gradient field away from the interface.\n    -   The oscillatory perturbed level-set is:\n        $$ \\phi(x,y) = \\phi_{\\text{exact}}(x,y) + \\varepsilon h \\,\\phi_{\\text{exact}}(x,y)\\,\\sin(2\\pi x)\\sin(2\\pi y) $$\n        This also preserves the zero level-set but introduces high-frequency oscillations, which challenges the accuracy of numerical differentiation.\n\n2.  **Numerical Curvature Calculation**: The curvature $\\kappa$ is computed from the level-set function using the divergence formula:\n    $$ \\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{\\|\\nabla \\phi\\|} \\right) = \\nabla \\cdot \\mathbf{n} $$\n    where $\\mathbf{n}$ is the unit normal vector field. The computation is performed in three stages at each grid node:\n    -   **Gradient of $\\phi$**: The gradient $\\nabla\\phi = (\\phi_x, \\phi_y) = (\\frac{\\partial\\phi}{\\partial x}, \\frac{\\partial\\phi}{\\partial y})$ is computed using finite differences. We employ second-order central differences for interior nodes and first-order one-sided differences for boundary nodes.\n    -   **Normal Vector Field**: The unit normal vector field $\\mathbf{n} = (n_x, n_y)$ is computed by normalizing the gradient:\n        $$ n_x = \\frac{\\phi_x}{\\sqrt{\\phi_x^2 + \\phi_y^2}}, \\quad n_y = \\frac{\\phi_y}{\\sqrt{\\phi_x^2 + \\phi_y^2}} $$\n        A small tolerance $\\epsilon_{\\text{mach}}$ is added to the denominator to prevent division by zero in regions where the gradient might vanish numerically (e.g., far from the interface).\n    -   **Divergence of $\\mathbf{n}$**: The curvature $\\kappa$ is the divergence of the normal field, $\\kappa = \\frac{\\partial n_x}{\\partial x} + \\frac{\\partial n_y}{\\partial y}$. The derivatives of the components of $\\mathbf{n}$ are computed using the same finite difference scheme (second-order central, first-order boundary).\n\n3.  **Interface Crossing Detection and Interpolation**: The algorithm identifies all horizontal and vertical grid edges that are intersected by the interface. An edge connecting two nodes, $A$ and $B$, is considered 'cut' if the level-set function has opposite signs at its endpoints, i.e., $\\phi_A \\cdot \\phi_B < 0$.\n    For each cut edge $e$, we perform two linear interpolations:\n    -   First, we find the fractional distance $\\alpha \\in (0,1)$ of the interface crossing from node $A$ along the edge:\n        $$ \\alpha = \\frac{|\\phi_A|}{|\\phi_A| + |\\phi_B|} $$\n    -   Second, we interpolate the nodal curvature values, $\\kappa_A$ and $\\kappa_B$, to estimate the curvature $\\kappa_e$ at the crossing point:\n        $$ \\kappa_e = (1-\\alpha)\\kappa_A + \\alpha\\kappa_B $$\n\n4.  **Error Quantification**: The error in the pressure jump is calculated for each crossing. The exact pressure jump is given by the Young-Laplace equation for a 2D circle: $\\Delta p_{\\text{exact}} = \\sigma / R$. The numerical pressure jump at a crossing $e$ is $\\Delta p_{\\text{GFM}} = \\sigma \\kappa_e$. The root-mean-square (RMS) error is aggregated over all $M$ cut edges:\n    $$ E_{\\text{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{e=1}^{M} \\left(\\sigma \\kappa_e - \\frac{\\sigma}{R}\\right)^2} $$\n    This metric provides a single value quantifying the overall accuracy of the curvature-induced pressure jump for a given test case.\n\nThe implementation of these steps for the specified test cases will produce the required list of $E_{\\text{RMS}}$ values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_rms_error(N, R, sigma, mode, epsilon, m):\n    \"\"\"\n    Computes the RMS error in the GFM pressure jump for a static 2D droplet.\n    \"\"\"\n    # 1. Grid and Level-Set Function Generation\n    h = 1.0 / (N - 1)\n    x = np.linspace(0, 1, N)\n    y = np.linspace(0, 1, N)\n    # Use 'ij' indexing for consistency with matrix row/column conventions\n    XX, YY = np.meshgrid(x, y, indexing='ij')\n\n    x_c, y_c = 0.5, 0.5\n    phi_exact = np.sqrt((XX - x_c)**2 + (YY - y_c)**2) - R\n\n    if mode == \"exact\":\n        phi = phi_exact\n    elif mode == \"anisotropic\":\n        theta_grid = np.arctan2(YY - y_c, XX - x_c)\n        phi = phi_exact * (1.0 + epsilon * np.cos(m * theta_grid))\n    elif mode == \"oscillatory\":\n        phi = phi_exact * (1.0 + epsilon * h * np.sin(2 * np.pi * XX) * np.sin(2 * np.pi * YY))\n    else:\n        raise ValueError(\"Unknown mode.\")\n\n    # 2. Numerical Curvature Calculation\n    # np.gradient uses 2nd-order central differences in the interior and\n    # 1st-order forward/backward differences at the boundaries.\n    # It returns derivatives with respect to each axis (axis 0, axis 1, ...).\n    # With 'ij' indexing, axis 0 is x and axis 1 is y.\n    phi_x, phi_y = np.gradient(phi, h, h)\n\n    # Normalize the gradient to get the normal vector field.\n    # Add a small machine epsilon to avoid division by zero.\n    norm_grad_phi = np.sqrt(phi_x**2 + phi_y**2) + np.finfo(float).eps\n    nx = phi_x / norm_grad_phi\n    ny = phi_y / norm_grad_phi\n\n    # Compute divergence of the normal field to get curvature.\n    nx_x, _ = np.gradient(nx, h, h)\n    _, ny_y = np.gradient(ny, h, h)\n    kappa = nx_x + ny_y\n    \n    # 3. Interface Crossing Detection and Interpolation\n    squared_errors = []\n    \n    # Horizontal edges (connecting (i,j) and (i+1,j))\n    for i in range(N - 1):\n        for j in range(N):\n            phi1 = phi[i, j]\n            phi2 = phi[i + 1, j]\n            if phi1 * phi2 < 0:\n                kappa1 = kappa[i, j]\n                kappa2 = kappa[i + 1, j]\n                alpha = abs(phi1) / (abs(phi1) + abs(phi2))\n                kappa_e = (1.0 - alpha) * kappa1 + alpha * kappa2\n                \n                # 4. Error Quantification (for this crossing)\n                error_sq = (sigma * kappa_e - sigma / R)**2\n                squared_errors.append(error_sq)\n\n    # Vertical edges (connecting (i,j) and (i,j+1))\n    for i in range(N):\n        for j in range(N - 1):\n            phi1 = phi[i, j]\n            phi2 = phi[i, j + 1]\n            if phi1 * phi2 < 0:\n                kappa1 = kappa[i, j]\n                kappa2 = kappa[i, j + 1]\n                alpha = abs(phi1) / (abs(phi1) + abs(phi2))\n                kappa_e = (1.0 - alpha) * kappa1 + alpha * kappa2\n                \n                # 4. Error Quantification (for this crossing)\n                error_sq = (sigma * kappa_e - sigma / R)**2\n                squared_errors.append(error_sq)\n\n    # Compute final RMS error\n    if not squared_errors:\n        return 0.0\n    \n    E_RMS = np.sqrt(np.mean(squared_errors))\n    return E_RMS\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, R, sigma, mode, epsilon, m)\n        (128, 0.25, 1.0, \"exact\", 0.0, 0),\n        (128, 0.25, 1.0, \"anisotropic\", 0.2, 6),\n        (64, 0.05, 1.0, \"exact\", 0.0, 0),\n        (128, 0.25, 1.0, \"oscillatory\", 0.5, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        rms_error = calculate_rms_error(*case)\n        results.append(rms_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A perfect numerical method would hold a multiphase interface in static equilibrium indefinitely, but in practice, small discretization errors can create artificial forces that drive non-physical flows known as spurious or parasitic currents. This advanced exercise challenges you to move from identifying error sources to quantifying their dynamic consequences by deriving a scaling law for the magnitude of these currents. By modeling the interplay between curvature errors, grid anisotropy, and the choice of surface tension model (GFM vs. Continuum Surface Force), you will gain deep insight into a persistent challenge in multiphase CFD and learn to predict the severity of these numerical artifacts. ",
            "id": "3516350",
            "problem": "Consider a two-dimensional, incompressible, viscous, Newtonian, immiscible, two-phase system in which a circular droplet of radius $R$ is at rest at the center of a rectangular domain. The true physical solution has zero velocity everywhere and a hydrostatic pressure jump across the interface equal to the product of surface tension and curvature. In numerical multiphase methods, however, discretization of surface tension and curvature introduces a residual imbalance that drives non-physical flows known as spurious currents (also called parasitic currents). Your task is to quantify the peak magnitude of these spurious currents and its scaling with grid resolution and anisotropy by comparing the Continuum Surface Force (CSF) model and the Ghost Fluid Method (GFM) for two curvature estimators: the height-function estimator (HF) and the level-set estimator (LS).\n\nYou must reason from first principles of low-Reynolds-number flow and surface tension representations, using only the base laws and well-tested, method-order facts listed below, to derive a closed-form prediction for the peak spurious speed. Then implement that prediction in a program that evaluates specific test cases and prints the results.\n\nFundamental base and accepted facts to use:\n- The incompressible Navier–Stokes equations for a Newtonian fluid in the steady, inertia-less (Stokes) limit reduce to $\\mu \\nabla^2 \\mathbf{u} = \\nabla p + \\mathbf{f}$ and $\\nabla \\cdot \\mathbf{u} = 0$, where $\\mu$ is dynamic viscosity, $\\mathbf{u}$ is velocity, $p$ is pressure, and $\\mathbf{f}$ is a volumetric force density.\n- The exact surface tension traction at an interface produces a pressure jump $[p] = \\sigma \\kappa$ across the interface, where $\\sigma$ is surface tension and $\\kappa$ is curvature.\n- In a CSF-like discretization, the surface tension is regularized into a volumetric force $\\mathbf{f}_{\\text{st}} \\approx \\sigma \\kappa \\nabla C$, where $C$ is an indicator field smeared over a thickness proportional to the grid spacing. A curvature error $\\delta \\kappa$ leaves a residual force density whose magnitude scales with the gradient magnitude of the indicator.\n- In a GFM-like sharp-jump discretization, the surface tension appears as a jump condition enforced at the interface; a curvature error $\\delta \\kappa$ yields a jump error $\\delta p = \\sigma \\delta \\kappa$ that drives a localized Stokes response near the interface.\n- The height-function curvature estimator (HF) is second-order accurate for smooth interfaces, while a standard level-set curvature estimator (LS) based on first-order accurate normals and central differences is effectively first-order accurate for curvature on general grids. Denote these orders by $q_{\\text{HF}} = 2$ and $q_{\\text{LS}} = 1$.\n- For an anisotropic Cartesian grid with spacings $\\Delta x$ and $\\Delta y$, an effective grid length for LS-based discretizations that blends anisotropy is $h_{\\text{eff,LS}} = \\sqrt{(\\Delta x^2 + \\Delta y^2)/2}$, while HF-type column reconstructions are limited by the coarser direction and hence $h_{\\text{eff,HF}} = \\max(\\Delta x, \\Delta y)$.\n- Curvature has units of inverse length. For a smooth circular interface, the truncation error in curvature may be modeled dimensionally as\n  $$ \\delta \\kappa_{\\text{geom}} \\sim C_k \\frac{1}{R} \\left( \\frac{h_{\\text{eff}}}{R} \\right)^q, $$\n  where $C_k$ is a dimensionless method-dependent constant and $q$ is the order of accuracy of the curvature estimator.\n- Contact angle modeling at a solid wall introduces an additional curvature defect near the three-phase contact line that scales linearly with grid size and with the cosine of the equilibrium contact angle magnitude. Model this as\n  $$ \\delta \\kappa_{\\text{CA}} \\sim C_{\\text{CA}} \\frac{1}{R} \\left( \\frac{h_{\\text{wall}}}{R} \\right) \\left| \\cos \\theta_e \\right|, $$\n  where $\\theta_e$ is the prescribed equilibrium contact angle, $h_{\\text{wall}}$ is the grid spacing normal to the wall, and $C_{\\text{CA}}$ is a dimensionless constant.\n\nObjectives:\n1. Starting from the steady Stokes momentum balance and the models above, derive a scaling expression for the peak spurious speed $U_{\\max}$ generated by a curvature error $\\delta \\kappa$ for both CSF and GFM. Your derivation must state how the characteristic length of the viscous response enters and must be dimensionally consistent. Express the result in meters per second.\n2. Incorporate grid anisotropy through the effective length $h_{\\text{eff}}$ for each curvature estimator. Use $h_{\\text{eff,HF}} = \\max(\\Delta x, \\Delta y)$ for HF and $h_{\\text{eff,LS}} = \\sqrt{(\\Delta x^2 + \\Delta y^2)/2}$ for LS.\n3. Use the following dimensionless constants for numerical evaluation: $C_{\\text{HF}} = 0.25$, $C_{\\text{LS}} = 0.05$, $C_{\\text{CSF}} = 1.0$, $C_{\\text{GFM}} = 0.25$, $C_{\\text{CA}} = 0.75$. Here $C_{\\text{HF}}$ and $C_{\\text{LS}}$ correspond to $C_k$ for HF and LS respectively, and $C_{\\text{CSF}}$, $C_{\\text{GFM}}$ are prefactors that model the relative strength of the near-interface viscous response for CSF and GFM.\n4. When a wall-contact case is specified, include the contact-angle curvature error contribution using $h_{\\text{wall}} = \\Delta x$ and the equilibrium contact angle $\\theta_e$ in degrees. Convert angles to radians when taking the cosine.\n\nParameters and units:\n- Radius $R$ in meters.\n- Surface tension $\\sigma$ in newtons per meter.\n- Viscosity $\\mu$ in pascal-seconds.\n- Grid spacings $\\Delta x$ and $\\Delta y$ in meters.\n- Equilibrium contact angle $\\theta_e$ in degrees when applicable.\n- Output velocity in meters per second.\n\nTest suite:\nUse $R = 1.0 \\times 10^{-3}$, $\\sigma = 0.072$, and $\\mu = 1.0 \\times 10^{-3}$. Evaluate the peak spurious speed for the five cases below. For each case, specify method (CSF or GFM), curvature estimator (HF or LS), $\\Delta x$, $\\Delta y$, and wall/contact angle if applicable.\n\n- Case 1 (happy path): CSF with HF on isotropic grid.\n  - $\\Delta x = \\Delta y = R/32$.\n  - No wall, no contact angle term.\n\n- Case 2 (method sensitivity): CSF with LS on isotropic grid.\n  - $\\Delta x = \\Delta y = R/32$.\n  - No wall, no contact angle term.\n\n- Case 3 (anisotropy effect): CSF with HF on anisotropic grid.\n  - $\\Delta x = R/64$, $\\Delta y = R/16$.\n  - No wall, no contact angle term.\n\n- Case 4 (model comparison under anisotropy): GFM with LS on anisotropic grid.\n  - $\\Delta x = R/64$, $\\Delta y = R/16$.\n  - No wall, no contact angle term.\n\n- Case 5 (contact angle at wall): GFM with HF on isotropic grid with a wall-contact curvature defect.\n  - $\\Delta x = \\Delta y = R/32$.\n  - Prescribed equilibrium contact angle $\\theta_e = 60$ degrees.\n\nRequired final output format:\n- Your program must compute the peak spurious speed $U_{\\max}$ for each case in meters per second and print a single line containing a comma-separated list of the five floating-point results enclosed in square brackets, for example, \"[v1,v2,v3,v4,v5]\".\n- Express each value to six significant figures.\n- The program must not read any input and must embed the test suite internally.",
            "solution": "The task is to derive a closed-form expression for the peak spurious velocity, $U_{\\max}$, in a numerical two-phase flow simulation and then use it to evaluate five specific test cases. The derivation will be based on the provided physical principles and scaling laws.\n\nWe begin with the governing equation for the fluid motion, which is the steady, inertia-less, incompressible Navier-Stokes (Stokes) equation:\n$$\n\\mu \\nabla^2 \\mathbf{u} = \\nabla p + \\mathbf{f}\n$$\nwhere $\\mu$ is the dynamic viscosity, $\\mathbf{u}$ is the velocity field, $p$ is the pressure, and $\\mathbf{f}$ is a volumetric body force. Spurious currents are non-physical flows generated by an imbalance between the discretized viscous, pressure, and surface tension terms.\n\nA dimensional analysis of the Stokes equation provides insight into the scaling of the velocity. Let $U$ be the characteristic velocity magnitude and $L$ be the characteristic length scale over which the flow varies. The viscous term scales as $\\mu |\\nabla^2 \\mathbf{u}| \\sim \\mu U/L^2$. This term must balance either a pressure gradient, $|\\nabla p| \\sim \\delta P/L$, or a body force, $|\\mathbf{f}| \\sim F$. This leads to two potential scalings for the velocity:\n1. Pressure-driven flow: $\\mu U/L^2 \\sim \\delta P/L \\implies U \\sim \\frac{\\delta P \\cdot L}{\\mu}$\n2. Force-driven flow: $\\mu U/L^2 \\sim F \\implies U \\sim \\frac{F \\cdot L^2}{\\mu}$\n\nThe spurious currents are driven by numerical errors that occur at the scale of the computational grid. Therefore, the characteristic length scale, $L$, of the resulting flow pattern is proportional to the effective grid spacing, $h_{\\text{eff}}$. We thus set $L \\sim h_{\\text{eff}}$.\n\nWe now analyze the two surface tension models provided: the Continuum Surface Force (CSF) model and the Ghost Fluid Method (GFM).\n\nFor the CSF model, surface tension is regularized as a volumetric force $\\mathbf{f}_{\\text{st}} \\approx \\sigma \\kappa \\nabla C$, where $C$ is an indicator function (e.g., volume fraction) smeared over the interface. An error in curvature, $\\delta \\kappa$, results in a residual force density, $\\delta \\mathbf{f}_{\\text{st}}$, with magnitude $F = |\\delta \\mathbf{f}_{\\text{st}}| \\sim \\sigma (\\delta \\kappa) |\\nabla C|$. The gradient of the indicator function, which transitions from $0$ to $1$ across a few grid cells, scales as $|\\nabla C| \\sim 1/h_{\\text{eff}}$. The residual force density is thus $F \\sim \\sigma (\\delta \\kappa)/h_{\\text{eff}}$. Using the force-driven velocity scaling, we find:\n$$\nU_{\\max} \\sim \\frac{F \\cdot L^2}{\\mu} \\sim \\frac{(\\sigma (\\delta \\kappa) / h_{\\text{eff}}) \\cdot h_{\\text{eff}}^2}{\\mu} = \\frac{\\sigma (\\delta \\kappa) h_{\\text{eff}}}{\\mu}\n$$\nIntroducing the given dimensionless prefactor $C_{\\text{CSF}}$ for this model, we get:\n$$\nU_{\\max, \\text{CSF}} = C_{\\text{CSF}} \\frac{\\sigma (\\delta \\kappa) h_{\\text{eff}}}{\\mu}\n$$\n\nFor the GFM, the surface tension is enforced as a sharp pressure jump across the interface. A curvature error $\\delta \\kappa$ leads to an error in this pressure jump, $\\delta P \\sim \\delta p = \\sigma \\delta \\kappa$. This pressure imbalance drives the flow. Using the pressure-driven velocity scaling with $L \\sim h_{\\text{eff}}$, we get:\n$$\nU_{\\max} \\sim \\frac{\\delta P \\cdot L}{\\mu} \\sim \\frac{(\\sigma \\delta \\kappa) \\cdot h_{\\text{eff}}}{\\mu}\n$$\nIntroducing the prefactor $C_{\\text{GFM}}$ for this model gives:\n$$\nU_{\\max, \\text{GFM}} = C_{\\text{GFM}} \\frac{\\sigma (\\delta \\kappa) h_{\\text{eff}}}{\\mu}\n$$\nBoth models yield a similar scaling structure. We can write a general expression:\n$$\nU_{\\max} = C_{\\text{method}} \\frac{\\sigma (\\delta \\kappa) h_{\\text{eff}}}{\\mu}\n$$\nwhere $C_{\\text{method}}$ is either $C_{\\text{CSF}}$ or $C_{\\text{GFM}}$.\n\nThe next step is to substitute the model for the total curvature error, $\\delta \\kappa$. The problem states that this error has contributions from geometric discretization and, if applicable, from contact angle treatment at a wall. We assume these contributions add:\n$$\n\\delta \\kappa = \\delta \\kappa_{\\text{geom}} + \\delta \\kappa_{\\text{CA}}\n$$\nThe explicit models provided are:\n$$\n\\delta \\kappa_{\\text{geom}} = C_k \\frac{1}{R} \\left( \\frac{h_{\\text{eff}}}{R} \\right)^q\n$$\n$$\n\\delta \\kappa_{\\text{CA}} = C_{\\text{CA}} \\frac{1}{R} \\left( \\frac{h_{\\text{wall}}}{R} \\right) \\left| \\cos \\theta_e \\right|\n$$\nwhere $C_k$ and $q$ depend on the chosen curvature estimator (HF or LS), $R$ is the droplet radius, $C_{\\text{CA}}$ is a constant for contact angle error, $h_{\\text{wall}}$ is the grid spacing normal to the wall, and $\\theta_e$ is the equilibrium contact angle.\n\nSubstituting the full expression for $\\delta \\kappa$ into our velocity scaling gives the final predictive formula for the peak spurious velocity:\n$$\nU_{\\max} = C_{\\text{method}} \\frac{\\sigma h_{\\text{eff}}}{\\mu} \\left[ C_k \\frac{1}{R} \\left( \\frac{h_{\\text{eff}}}{R} \\right)^q + C_{\\text{CA}} \\frac{1}{R} \\left( \\frac{h_{\\text{wall}}}{R} \\right) \\left| \\cos \\theta_e \\right| \\right]\n$$\nThis can be rearranged for clarity by factoring out $1/R$ and identifying the capillary velocity scale $V_{cap} = \\sigma/\\mu$:\n$$\nU_{\\max} = C_{\\text{method}} \\frac{\\sigma}{\\mu} \\frac{h_{\\text{eff}}}{R} \\left[ C_k \\left( \\frac{h_{\\text{eff}}}{R} \\right)^q + C_{\\text{CA}} \\left( \\frac{h_{\\text{wall}}}{R} \\right) \\left| \\cos \\theta_e \\right| \\right]\n$$\nThis formula incorporates the surface tension model ($C_{\\text{method}}$), the curvature estimator ($C_k, q, h_{\\text{eff}}$), grid anisotropy (via $h_{\\text{eff}}$), and contact angle effects. The contact angle term is set to zero for cases without a wall. This expression will be implemented to evaluate the specified test cases. The definitions for $h_{\\text{eff}}$ depend on the estimator: $h_{\\text{eff,HF}} = \\max(\\Delta x, \\Delta y)$ and $h_{\\text{eff,LS}} = \\sqrt{(\\Delta x^2 + \\Delta y^2)/2}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and evaluates the peak spurious velocity for several test cases\n    in multiphase flow simulation.\n    \"\"\"\n    # Define physical parameters and dimensionless constants from the problem.\n    R = 1.0e-3  # meters\n    sigma = 0.072  # N/m\n    mu = 1.0e-3  # Pa.s\n\n    C_CSF = 1.0\n    C_GFM = 0.25\n    C_HF = 0.25\n    C_LS = 0.05\n    C_CA = 0.75\n\n    # Orders of accuracy for curvature estimators.\n    q_HF = 2\n    q_LS = 1\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'id': 1, 'method': 'CSF', 'estimator': 'HF', 'dx_div': 32, 'dy_div': 32, 'theta_e_deg': None},\n        {'id': 2, 'method': 'CSF', 'estimator': 'LS', 'dx_div': 32, 'dy_div': 32, 'theta_e_deg': None},\n        {'id': 3, 'method': 'CSF', 'estimator': 'HF', 'dx_div': 64, 'dy_div': 16, 'theta_e_deg': None},\n        {'id': 4, 'method': 'GFM', 'estimator': 'LS', 'dx_div': 64, 'dy_div': 16, 'theta_e_deg': None},\n        {'id': 5, 'method': 'GFM', 'estimator': 'HF', 'dx_div': 32, 'dy_div': 32, 'theta_e_deg': 60},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Determine case-specific parameters\n        if case['method'] == 'CSF':\n            C_method = C_CSF\n        else: # GFM\n            C_method = C_GFM\n\n        dx = R / case['dx_div']\n        dy = R / case['dy_div']\n\n        if case['estimator'] == 'HF':\n            C_k = C_HF\n            q = q_HF\n            h_eff = np.max([dx, dy])\n        else: # LS\n            C_k = C_LS\n            q = q_LS\n            h_eff = np.sqrt((dx**2 + dy**2) / 2)\n\n        # Calculate geometric error contribution\n        # U_max_geom = C_method * C_k * (sigma / mu) * (h_eff / R)**(q + 1)\n        geom_err_factor = C_k * (h_eff / R)**q\n\n        # Calculate contact angle error contribution\n        ca_err_factor = 0.0\n        if case['theta_e_deg'] is not None:\n            theta_e = np.radians(case['theta_e_deg'])\n            h_wall = dx\n            ca_err_factor = C_CA * (h_wall / R) * np.abs(np.cos(theta_e))\n        \n        # Combine terms using the derived formula:\n        # U_max = C_method * (sigma/mu) * (h_eff/R) * [geom_err_factor + ca_err_factor]\n        total_err_term = geom_err_factor + ca_err_factor\n        U_max = C_method * (sigma / mu) * (h_eff / R) * total_err_term\n\n        results.append(U_max)\n\n    # Format output to six significant figures and join into a single string.\n    formatted_results = [f'{val:.6g}' for val in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}