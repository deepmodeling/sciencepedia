{
    "hands_on_practices": [
        {
            "introduction": "流体体积（VOF）方法的核心优势在于其固有的质量守恒性，这是通过直接计算流体在计算网格之间输运的体积通量来实现的。为了精确地模拟界面运动，现代VOF方法（如PLIC）使用几何重构来计算这些通量。这个练习  提供了一个绝佳的实践机会，让你亲手计算一个给定的线性界面在一个时间步内流出单个计算单元的精确体积，从而深入理解VOF几何平流算法的根本机制。",
            "id": "3968668",
            "problem": "考虑一个用于计算流体动力学 (CFD) 中两相界面平流的三维笛卡尔控制体，该方法采用流体体积 (VOF) 法和分段线性界面计算 (PLIC) 重建。该矩形单元占据的区域为 $x \\in [0,\\Delta x]$, $y \\in [0,\\Delta y]$, $z \\in [0,\\Delta z]$，其中 $\\Delta x = 0.02$ 米，$\\Delta y = 0.02$ 米，$\\Delta z = 0.01$ 米。在此单元内，流体 A 与流体 B 被一个平面界面隔开，其单位法向量为 $\\boldsymbol{n} = (1,1,0)/\\sqrt{2}$，重建的平面方程为 $x + y = 0.023$ 米，因此流体 A 占据的区域为 $\\{(x,y,z) \\,|\\, x + y \\le 0.023\\ \\text{m}\\}$。\n\n假设一个沿 x 方向的方向分裂平流步。在该时间步内，速度场是均匀且恒定的，为 $\\boldsymbol{u} = (u_{x},0,0)$，其中 $u_{x} = 2.0$ 米/秒。时间步长为 $\\Delta t = 0.0015$ 秒，因此邻近右侧 x 面的迎风板厚度为 $s = u_{x}\\,\\Delta t$。在此分裂步中，y 和 z 方向上没有运动，界面也没有变形。在时间间隔 $\\Delta t$ 内，通过位于 $x = \\Delta x$ 处的右侧 x 面离开单元的流体 A 的几何通量，被定义为单元中流体 A 与 x 板区域 $x \\in [\\Delta x - s, \\Delta x]$ 的交集的体积。\n\n从流体 A 的平流特征函数的守恒定律出发，并使用上述 PLIC 描述，推导出合适的几何积分，并计算在该时间步内通过右侧 x 面离开单元的流体 A 的总体积。以立方米为单位表示最终数值答案。将答案四舍五入到四位有效数字。",
            "solution": "该问题要求计算在方向分裂平流步中，流体 A 通过一个矩形控制体右侧面流出的体积。所描述的方法是流体体积 (VOF) 框架内的分段线性界面计算 (PLIC)。\n\n流体 A 的体积分数（由特征函数 $F_A$ 表示，在流体 A 中 $F_A=1$，在流体 B 中 $F_A=0$）的守恒定律由以下平流方程给出：\n$$ \\frac{\\partial F_A}{\\partial t} + \\nabla \\cdot (\\boldsymbol{u} F_A) = 0 $$\n对于 x 方向上速度为常数 $u_x$ 的单个平流步，此方程简化为：\n$$ \\frac{\\partial F_A}{\\partial t} + u_x \\frac{\\partial F_A}{\\partial x} = 0 $$\n在时间步长 $\\Delta t$ 内，通过右侧面（位于 $x=\\Delta x$）离开单元的流体 A 的体积 $\\delta V_{A,\\text{out}}$ 是穿过该面的通量的时间积分。对于一阶显式时间积分方案，此通量体积在几何上被解释为位于该面迎风侧邻近的“平流板”中的流体 A 的体积。该板的厚度为 $s = u_x \\Delta t$。\n\n问题将此通量体积明确定义为以下三个区域交集的体积：\n1.  控制体（单元）：$V_{\\text{cell}} = \\{ (x,y,z) \\,|\\, 0 \\le x \\le \\Delta x, 0 \\le y \\le \\Delta y, 0 \\le z \\le \\Delta z \\}$。\n2.  流体 A 占据的区域：$V_A = \\{ (x,y,z) \\,|\\, x + y \\le C \\}$，其中 $C=0.023$ 米。\n3.  平流板：$V_{\\text{slab}} = \\{ (x,y,z) \\,|\\, \\Delta x - s \\le x \\le \\Delta x \\}$。\n\n我们已知以下参数：\n- 单元尺寸：$\\Delta x = 0.02$ 米，$\\Delta y = 0.02$ 米，$\\Delta z = 0.01$ 米。\n- 速度：$u_x = 2.0$ 米/秒。\n- 时间步长：$\\Delta t = 0.0015$ 秒。\n\n首先，我们计算平流板的厚度 $s$：\n$$ s = u_x \\Delta t = (2.0 \\, \\text{m/s}) \\times (0.0015 \\, \\text{s}) = 0.003 \\, \\text{m} $$\n平流板占据区域 $x \\in [\\Delta x - s, \\Delta x]$。代入 $\\Delta x$ 和 $s$ 的值：\n$$ x \\in [0.02 \\, \\text{m} - 0.003 \\, \\text{m}, 0.02 \\, \\text{m}] = [0.017 \\, \\text{m}, 0.02 \\, \\text{m}] $$\n待计算的体积 $\\delta V_A$ 是区域 $R = V_{\\text{cell}} \\cap V_A \\cap V_{\\text{slab}}$ 的体积。区域 $R$ 的边界由所有约束条件的交集定义：\n1.  $0 \\le x \\le 0.02$\n2.  $0 \\le y \\le 0.02$\n3.  $0 \\le z \\le 0.01$\n4.  $x+y \\le 0.023$\n5.  $0.017 \\le x \\le 0.02$\n\n结合约束条件 1 和 5，得到 x 的确定范围：$0.017 \\le x \\le 0.02$。\ny 的约束条件变为 $0 \\le y \\le \\min(0.02, 0.023 - x)$。\n对于 $x \\in [0.017, 0.02]$ 的范围，项 $0.023 - x$ 的值从 x 的下界处的 $0.023 - 0.017 = 0.006$ 变化到 x 的上界处的 $0.023 - 0.02 = 0.003$。在此整个范围内，$0.023 - x  0.02$。因此，y 的上界就是 $y = 0.023 - x$。\n\n体积 $\\delta V_A$ 的积分限为：\n$$ \\delta V_A = \\int_{z=0}^{0.01} \\int_{x=0.017}^{0.02} \\int_{y=0}^{0.023-x} dy \\, dx \\, dz $$\n由于被积函数为 1，且 z 的积分限与 x 和 y 无关，我们可以分离该积分：\n$$ \\delta V_A = \\left( \\int_{z=0}^{0.01} dz \\right) \\left( \\int_{x=0.017}^{0.02} \\int_{y=0}^{0.023-x} dy \\, dx \\right) $$\n第一个积分就是区域的高度 $\\Delta z = 0.01$ 米。第二个积分代表 $xy$ 平面中通量体积的横截面积，我们称之为 $A_{\\text{flux}}$。\n$$ A_{\\text{flux}} = \\int_{x=0.017}^{0.02} \\left[ y \\right]_{y=0}^{0.023-x} dx = \\int_{0.017}^{0.02} (0.023 - x) \\, dx $$\n我们现在计算这个积分：\n$$ A_{\\text{flux}} = \\left[ 0.023x - \\frac{x^2}{2} \\right]_{0.017}^{0.02} $$\n$$ A_{\\text{flux}} = \\left( 0.023 \\cdot 0.02 - \\frac{(0.02)^2}{2} \\right) - \\left( 0.023 \\cdot 0.017 - \\frac{(0.017)^2}{2} \\right) $$\n$$ A_{\\text{flux}} = \\left( 0.00046 - \\frac{0.0004}{2} \\right) - \\left( 0.000391 - \\frac{0.000289}{2} \\right) $$\n$$ A_{\\text{flux}} = (0.00046 - 0.0002) - (0.000391 - 0.0001445) $$\n$$ A_{\\text{flux}} = 0.00026 - 0.0002465 $$\n$$ A_{\\text{flux}} = 0.0000135 \\, \\text{m}^2 $$\n总通量体积 $\\delta V_A$ 是该面积乘以单元深度 $\\Delta z$：\n$$ \\delta V_A = A_{\\text{flux}} \\times \\Delta z = (0.0000135 \\, \\text{m}^2) \\times (0.01 \\, \\text{m}) $$\n$$ \\delta V_A = 0.000000135 \\, \\text{m}^3 = 1.35 \\times 10^{-7} \\, \\text{m}^3 $$\n问题要求将答案四舍五入到四位有效数字。\n$$ \\delta V_A \\approx 1.350 \\times 10^{-7} \\, \\text{m}^3 $$",
            "answer": "$$\\boxed{1.350 \\times 10^{-7}}$$"
        },
        {
            "introduction": "在计算流体动力学中，任何开放系统（即有流体流入或流出）的模拟成败都取决于边界条件的正确处理。这个练习  聚焦于一个至关重要的实际问题：为耦合的水平集（Level Set）和流体体积（VOF）场实现入口和出口边界条件。通过这个编程实践，你将学习如何基于双曲守恒律的特征线分析来设定物理上一致的边界值，确保模拟的稳定性和准确性。",
            "id": "3968655",
            "problem": "考虑一个一维、不可压缩、两相平流问题，该问题建立在一个长度为 $L$ 的均匀、有限体积、单元中心网格上，该网格包含 $N$ 个内部单元和两个虚拟单元（每个边界一个）。内部单元中心的位置为 $x_i = (i + 0.5)\\Delta x$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$，且 $\\Delta x = L/N$。左虚拟单元中心位于 $x_{\\mathrm{g},L} = x_0 - \\Delta x$，右虚拟单元中心位于 $x_{\\mathrm{g},R} = x_{N-1} + \\Delta x$。流速 $u$ 在空间上是均匀的，且不随时间变化。两个界面捕捉场是：\n- 水平集场 (Level Set field) $\\phi(x,t)$，定义为到物质界面的有符号距离，对于不可压缩流，它遵循双曲平流方程 $\\partial_t \\phi + u \\,\\partial_x \\phi = 0$。在界面附近，它满足程函方程性质 (Eikonal property) $\\lvert \\partial_x \\phi \\rvert = 1$，因此局部地有 $\\phi(x) = s\\,(x - x_I)$，其中 $s \\in \\{+1,-1\\}$，$x_I$ 是界面位置；\n- A 相的流体体积 (Volume of Fluid, VOF) 体积分数 $\\alpha(x,t)$，其定义通过一个跨越有限界面厚度 $\\varepsilon  0$ 的平滑 Heaviside 映射与水平集场保持一致。\n\n边界条件必须仅在入流边界上提供，这由双曲平流方程的特征线分析和守恒性所指导。对于平流速度 $u  0$，左边界是入流，右边界是出流；对于 $u  0$，右边界是入流，左边界是出流；对于 $u = 0$，两个边界都视为出流（没有入流特征线）。水平集场的物理一致性入流边界条件可从有符号距离定义中获得：如果域外的界面位于 $x_I^{\\mathrm{in}}$，则在相应的入流虚拟单元中心 $x_{\\mathrm{g}}$ 处，当外法线符号为 $s = +1$（常规方向 $\\phi(x) = x - x_I$），虚拟值为 $\\phi_{\\mathrm{g}} = x_{\\mathrm{g}} - x_I^{\\mathrm{in}}$，这强制 $\\lvert \\partial_x \\phi \\rvert = 1$ 并将一个几何上一致的界面输运到域内。在出流边界，施加零梯度边界条件，即虚拟值等于相邻的内部值：$\\phi_{\\mathrm{g}} = \\phi_{\\mathrm{int}}$。\n\n为确保流体体积 (VOF) 和水平集 (Level Set) 表示法之间的一致性，使用由磨光的 Dirac delta 函数构建的标准平滑 Heaviside 映射来定义 A 相的 VOF 分数。令标准的平滑 Dirac delta 函数为\n$$\n\\delta_{\\varepsilon}^{\\mathrm{std}}(\\phi) =\n\\begin{cases}\n\\frac{1}{2\\varepsilon}\\left(1+\\cos\\left(\\frac{\\pi \\phi}{\\varepsilon}\\right)\\right),  |\\phi| \\le \\varepsilon \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\n其积分为标准的平滑 Heaviside 函数 $H_{\\varepsilon}^{\\mathrm{std}}(\\phi)$，满足 $\\dfrac{d}{d\\phi} H_{\\varepsilon}^{\\mathrm{std}}(\\phi) = \\delta_{\\varepsilon}^{\\mathrm{std}}(\\phi)$，$H_{\\varepsilon}^{\\mathrm{std}}(-\\infty) = 0$，$H_{\\varepsilon}^{\\mathrm{std}}(+\\infty) = 1$。A 相的 VOF 分数定义为 $\\alpha = 1 - H_{\\varepsilon}^{\\mathrm{std}}(\\phi)$，因此在 $\\phi  0$ 的区域（A 相）$\\alpha \\approx 1$，在 $\\phi > 0$ 的区域（B 相）$\\alpha \\approx 0$，并存在一个厚度为 $\\varepsilon$ 的平滑过渡区。在入流虚拟单元处，通过平滑 Heaviside 函数从 $\\phi_{\\mathrm{g}}$ 计算 $\\alpha_{\\mathrm{g}}$；在出流处，施加零梯度 $\\alpha_{\\mathrm{g}} = \\alpha_{\\mathrm{int}}$。\n\n假设内部水平集场被良好解析，并由 $\\phi_i = x_i - x_I^{\\mathrm{dom}}$ 给出，适用于所有内部索引 $i$，其中 $x_I^{\\mathrm{dom}}$ 是计算域内的界面位置。单元 $i$ 处的内部 VOF 分数是根据 $\\phi_i$ 和该案例的 $\\varepsilon$ 计算得出的。\n\n你的任务是实现一个程序，对于每个提供的测试案例，判断每个边界是入流还是出流，应用物理上正确的边界条件来计算两个边界上虚拟单元的水平集和 VOF 值，并输出该案例的四个虚拟值组成的元组：\n- 左侧水平集虚拟值 $\\phi_{\\mathrm{g},L}$，单位为米，\n- 左侧 VOF 虚拟值 $\\alpha_{\\mathrm{g},L}$（无量纲），\n- 右侧水平集虚拟值 $\\phi_{\\mathrm{g},R}$，单位为米，\n- 右侧 VOF 虚拟值 $\\alpha_{\\mathrm{g},R}$（无量纲）。\n\n所有物理量必须使用国际单位制 (SI) 进行计算。水平集结果以米为单位表示，VOF 结果以小数表示。此问题中不涉及角度量。\n\n所有案例均使用以下网格和位置：$N = 4$ 个内部单元，$\\Delta x = 0.01$ 米，$L = 0.04$ 米。因此 $x_0 = 0.005$ 米，$x_1 = 0.015$ 米，$x_2 = 0.025$ 米，$x_3 = 0.035$ 米，$x_{\\mathrm{g},L} = -0.005$ 米，以及 $x_{\\mathrm{g},R} = 0.045$ 米。对于每个案例，内部界面位置 $x_I^{\\mathrm{dom}}$ 用于定义 $\\phi_i$，而入流界面位置 $x_I^{\\mathrm{in}}$ 仅应用于入流边界以构建虚拟水平集值。\n\n要使用的平滑 Heaviside 映射是从上述 $\\delta_{\\varepsilon}^{\\mathrm{std}}$ 推导出的。你的程序必须实现推导出的 $H_{\\varepsilon}^{\\mathrm{std}}(\\phi)$ 的分段表达式，并计算 $\\alpha = 1 - H_{\\varepsilon}^{\\mathrm{std}}(\\phi)$。\n\n测试套件：\n为以下七个案例提供输出。在每个案例中，报告四元组 $[\\phi_{\\mathrm{g},L},\\alpha_{\\mathrm{g},L},\\phi_{\\mathrm{g},R},\\alpha_{\\mathrm{g},R}]$。\n- 案例 1：$u = 2.0$ 米/秒，$x_I^{\\mathrm{dom}} = 0.02$ 米，$\\varepsilon = 0.003$ 米，左侧的 $x_I^{\\mathrm{in}}$ 等于 $-0.002$ 米。\n- 案例 2：$u = -1.0$ 米/秒，$x_I^{\\mathrm{dom}} = 0.03$ 米，$\\varepsilon = 0.002$ 米，右侧的 $x_I^{\\mathrm{in}}$ 等于 $0.041$ 米。\n- 案例 3：$u = 0.0$ 米/秒，$x_I^{\\mathrm{dom}} = 0.025$ 米，$\\varepsilon = 0.005$ 米。没有入流；将两个边界都视为出流。\n- 案例 4：$u = 3.0$ 米/秒，$x_I^{\\mathrm{dom}} = 0.02$ 米，$\\varepsilon = 0.001$ 米，左侧的 $x_I^{\\mathrm{in}}$ 等于 $0.0$ 米。\n- 案例 5：$u = -4.0$ 米/秒，$x_I^{\\mathrm{dom}} = 0.015$ 米，$\\varepsilon = 0.0025$ 米，右侧的 $x_I^{\\mathrm{in}}$ 等于 $0.04$ 米。\n- 案例 6：$u = 1.0$ 米/秒，$x_I^{\\mathrm{dom}} = 0.02$ 米，$\\varepsilon = 0.01$ 米，左侧的 $x_I^{\\mathrm{in}}$ 等于 $-0.0005$ 米。\n- 案例 7：$u = -1.5$ 米/秒，$x_I^{\\mathrm{dom}} = 0.025$ 米，$\\varepsilon = 0.01$ 米，右侧的 $x_I^{\\mathrm{in}}$ 等于 $0.043$ 米。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的结果，结果是以逗号分隔的列表，每个元素对应一个案例，并且本身是一个包含四个虚拟值的列表，例如 $[[\\phi_{\\mathrm{g},L}^{(1)},\\alpha_{\\mathrm{g},L}^{(1)},\\phi_{\\mathrm{g},R}^{(1)},\\alpha_{\\mathrm{g},R}^{(1)}],\\dots]$。",
            "solution": "问题陈述已根据既定标准进行了仔细审查和验证。经判定，该问题具有科学依据、良构、客观且完整。所有提供的数据和定义都与计算流体动力学的基本原理一致，特别是关于双曲平流方程和界面捕捉方法（水平集和流体体积法）。该问题是形式化的，并且可以按所述方式求解。\n\n解决方案要求计算一维域左右边界处水平集场 $\\phi$ 和流体体积 (VOF) 场 $\\alpha$ 的虚拟单元值。该过程遵循一套清晰的、基于物理的规则。\n\n首先，我们必须推导出平滑 Heaviside 函数 $H_{\\varepsilon}^{\\mathrm{std}}(\\phi)$ 的显式公式，该函数连接了 $\\phi$ 和 $\\alpha$ 场。它被定义为所提供的平滑 Dirac delta 函数 $\\delta_{\\varepsilon}^{\\mathrm{std}}(\\phi)$ 的积分。\n平滑 Dirac delta 函数由下式给出：\n$$\n\\delta_{\\varepsilon}^{\\mathrm{std}}(\\phi) =\n\\begin{cases}\n\\frac{1}{2\\varepsilon}\\left(1+\\cos\\left(\\frac{\\pi \\phi}{\\varepsilon}\\right)\\right),  |\\phi| \\le \\varepsilon \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\n平滑 Heaviside 函数为 $H_{\\varepsilon}^{\\mathrm{std}}(\\phi) = \\int_{-\\infty}^{\\phi} \\delta_{\\varepsilon}^{\\mathrm{std}}(\\xi) d\\xi$，其条件为 $H_{\\varepsilon}^{\\mathrm{std}}(-\\infty) = 0$ 和 $H_{\\varepsilon}^{\\mathrm{std}}(+\\infty) = 1$。\n\n积分存在三个区间：\n1.  对于 $\\phi \\le -\\varepsilon$，被积函数为零，因此 $H_{\\varepsilon}^{\\mathrm{std}}(\\phi) = \\int_{-\\infty}^{\\phi} 0 \\,d\\xi = 0$。\n2.  对于 $\\phi  \\varepsilon$，函数已在其整个支集上完成积分，因此 $H_{\\varepsilon}^{\\mathrm{std}}(\\phi) = \\int_{-\\infty}^{-\\varepsilon} 0 \\,d\\xi + \\int_{-\\varepsilon}^{\\varepsilon} \\delta_{\\varepsilon}^{\\mathrm{std}}(\\xi) d\\xi + \\int_{\\varepsilon}^{\\phi} 0 \\,d\\xi = 1$。这可以通过直接积分来证实，其结果为 $H_{\\varepsilon}^{\\mathrm{std}}(\\varepsilon) = 1$。\n3.  对于 $|\\phi|  \\varepsilon$，我们从 $-\\varepsilon$ 开始积分：\n$$\n\\begin{align*}\nH_{\\varepsilon}^{\\mathrm{std}}(\\phi) = \\int_{-\\infty}^{-\\varepsilon} 0 \\,d\\xi + \\int_{-\\varepsilon}^{\\phi} \\dfrac{1}{2\\varepsilon}\\left(1+\\cos\\left(\\dfrac{\\pi \\xi}{\\varepsilon}\\right)\\right) d\\xi \\\\\n= \\dfrac{1}{2\\varepsilon} \\left[ \\xi + \\dfrac{\\varepsilon}{\\pi}\\sin\\left(\\dfrac{\\pi \\xi}{\\varepsilon}\\right) \\right]_{-\\varepsilon}^{\\phi} \\\\\n= \\dfrac{1}{2\\varepsilon} \\left( \\left(\\phi + \\dfrac{\\varepsilon}{\\pi}\\sin\\left(\\dfrac{\\pi \\phi}{\\varepsilon}\\right)\\right) - \\left(-\\varepsilon + \\dfrac{\\varepsilon}{\\pi}\\sin\\left(\\dfrac{-\\pi\\varepsilon}{\\varepsilon}\\right)\\right) \\right) \\\\\n= \\dfrac{1}{2\\varepsilon} \\left( \\phi + \\varepsilon + \\dfrac{\\varepsilon}{\\pi}\\sin\\left(\\dfrac{\\pi \\phi}{\\varepsilon}\\right) \\right) \\quad (\\text{因为 } \\sin(-\\pi) = 0) \\\\\n= \\dfrac{1}{2} + \\dfrac{\\phi}{2\\varepsilon} + \\dfrac{1}{2\\pi}\\sin\\left(\\dfrac{\\pi \\phi}{\\varepsilon}\\right)\n\\end{align*}\n$$\n将这些部分组合起来，完整的分段函数为：\n$$\nH_{\\varepsilon}^{\\mathrm{std}}(\\phi) =\n\\begin{cases}\n0,  \\phi \\le -\\varepsilon \\\\\n\\dfrac{1}{2} + \\dfrac{\\phi}{2\\varepsilon} + \\dfrac{1}{2\\pi}\\sin\\left(\\dfrac{\\pi \\phi}{\\varepsilon}\\right),  |\\phi|  \\varepsilon \\\\\n1,  \\phi \\ge \\varepsilon\n\\end{cases}\n$$\nA 相的 VOF 分数则计算为 $\\alpha(\\phi) = 1 - H_{\\varepsilon}^{\\mathrm{std}}(\\phi)$。\n\n算法的核心在于根据平流速度 $u$ 的符号应用正确的边界条件。固定的网格参数为：$N=4$ 个单元，$\\Delta x = 0.01\\,$m，$L=0.04\\,$m。单元中心为 $x_0 = 0.005\\,$m，$x_1 = 0.015\\,$m，$x_2 = 0.025\\,$m，$x_3 = 0.035\\,$m。虚拟单元中心为 $x_{\\mathrm{g},L} = -0.005\\,$m 和 $x_{\\mathrm{g},R} = 0.045\\,$m。\n\n每个测试案例的一般步骤如下：\n\n1.  **边界分类：**\n    - 如果 $u  0$：左边界 ($x=0$) 是入流，右边界 ($x=L$) 是出流。\n    - 如果 $u  0$：右边界 ($x=L$) 是入流，左边界 ($x=0$) 是出流。\n    - 如果 $u = 0$：两个边界都视为出流。\n\n2.  **计算虚拟单元值：** 这取决于边界的分类。\n\n    **对于左边界（虚拟单元位于 $x_{\\mathrm{g},L}$）：**\n    - 如果是**入流** ($u0$)：问题提供了一个入流界面位置 $x_I^{\\mathrm{in}}$。\n        - $\\phi_{\\mathrm{g},L} = x_{\\mathrm{g},L} - x_I^{\\mathrm{in}}$。\n        - $\\alpha_{\\mathrm{g},L}$ 是使用 $\\alpha(\\phi) = 1 - H_{\\varepsilon}^{\\mathrm{std}}(\\phi)$ 从 $\\phi_{\\mathrm{g},L}$ 计算得出。\n    - 如果是**出流** ($u \\le 0$)：应用零梯度条件。虚拟值等于相邻内部单元 ($i=0$) 中的值。\n        - 内部水平集由 $\\phi_i = x_i - x_I^{\\mathrm{dom}}$ 给出。\n        - $\\phi_{\\mathrm{g},L} = \\phi_0 = x_0 - x_I^{\\mathrm{dom}}$。\n        - 内部 VOF 为 $\\alpha_0 = 1 - H_{\\varepsilon}^{\\mathrm{std}}(\\phi_0)$。\n        - $\\alpha_{\\mathrm{g},L} = \\alpha_0$。\n\n    **对于右边界（虚拟单元位于 $x_{\\mathrm{g},R}$）：**\n    - 如果是**入流** ($u0$)：问题提供了一个入流界面位置 $x_I^{\\mathrm{in}}$。\n        - $\\phi_{\\mathrm{g},R} = x_{\\mathrm{g},R} - x_I^{\\mathrm{in}}$。\n        - $\\alpha_{\\mathrm{g},R}$ 是使用 $\\alpha(\\phi) = 1 - H_{\\varepsilon}^{\\mathrm{std}}(\\phi)$ 从 $\\phi_{\\mathrm{g},R}$ 计算得出。\n    - 如果是**出流** ($u \\ge 0$)：应用零梯度条件。虚拟值等于相邻内部单元 ($i=N-1=3$) 中的值。\n        - 内部水平集为 $\\phi_i = x_i - x_I^{\\mathrm{dom}}$。\n        - $\\phi_{\\mathrm{g},R} = \\phi_{3} = x_3 - x_I^{\\mathrm{dom}}$。\n        - 内部 VOF 为 $\\alpha_3 = 1 - H_{\\varepsilon}^{\\mathrm{std}}(\\phi_{3})$。\n        - $\\alpha_{\\mathrm{g},R} = \\alpha_{3}$。\n\n我们现在将此步骤应用于每个测试案例。\n\n**案例 1：** $u = 2.0  0$，$x_I^{\\mathrm{dom}} = 0.02$，$\\varepsilon = 0.003$，$x_I^{\\mathrm{in}} = -0.002$ (左)。\n- 左侧为入流，右侧为出流。\n- $\\phi_{\\mathrm{g},L} = x_{\\mathrm{g},L} - x_I^{\\mathrm{in}} = -0.005 - (-0.002) = -0.003$。由于 $\\phi_{\\mathrm{g},L} = -\\varepsilon$，所以 $H_{0.003}^{\\mathrm{std}}(-0.003) = 0$。因此，$\\alpha_{\\mathrm{g},L} = 1-0 = 1.0$。\n- $\\phi_{\\mathrm{g},R} = \\phi_3 = x_3 - x_I^{\\mathrm{dom}} = 0.035 - 0.02 = 0.015$。由于 $\\phi_{\\mathrm{g},R}  \\varepsilon$，所以 $H_{0.003}^{\\mathrm{std}}(0.015) = 1$。因此，$\\alpha_{\\mathrm{g},R} = 1-1=0.0$。\n- 结果：$[\\phi_{\\mathrm{g},L}: -0.003, \\alpha_{\\mathrm{g},L}: 1.0, \\phi_{\\mathrm{g},R}: 0.015, \\alpha_{\\mathrm{g},R}: 0.0]$\n\n**案例 2：** $u = -1.0  0$，$x_I^{\\mathrm{dom}} = 0.03$，$\\varepsilon = 0.002$，$x_I^{\\mathrm{in}} = 0.041$ (右)。\n- 左侧为出流，右侧为入流。\n- $\\phi_{\\mathrm{g},L} = \\phi_0 = x_0 - x_I^{\\mathrm{dom}} = 0.005 - 0.03 = -0.025$。由于 $\\phi_{\\mathrm{g},L}  -\\varepsilon$，所以 $H_{0.002}^{\\mathrm{std}}(-0.025) = 0$。因此，$\\alpha_{\\mathrm{g},L} = 1-0=1.0$。\n- $\\phi_{\\mathrm{g},R} = x_{\\mathrm{g},R} - x_I^{\\mathrm{in}} = 0.045 - 0.041 = 0.004$。由于 $\\phi_{\\mathrm{g},R}  \\varepsilon$，所以 $H_{0.002}^{\\mathrm{std}}(0.004) = 1$。因此，$\\alpha_{\\mathrm{g},R} = 1-1=0.0$。\n- 结果：$[\\phi_{\\mathrm{g},L}: -0.025, \\alpha_{\\mathrm{g},L}: 1.0, \\phi_{\\mathrm{g},R}: 0.004, \\alpha_{\\mathrm{g},R}: 0.0]$\n\n对所有提供的案例都将系统地应用这些控制原理和推导出的公式，以生成最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates ghost cell values for Level Set and VOF fields\n    for a 1D advection problem based on specified boundary conditions.\n    \"\"\"\n\n    # Define fixed grid parameters\n    N = 4\n    delta_x = 0.01  # meters\n    L = 0.04  # meters\n    \n    # Interior cell centers\n    x_i = np.array([(i + 0.5) * delta_x for i in range(N)])\n    x_0 = x_i[0]\n    x_N_minus_1 = x_i[-1]\n    \n    # Ghost cell centers\n    x_g_L = x_0 - delta_x\n    x_g_R = x_N_minus_1 + delta_x\n\n    # Test cases from the problem statement\n    test_cases = [\n        {'u': 2.0, 'x_I_dom': 0.02, 'eps': 0.003, 'x_I_in': -0.002},  # Case 1\n        {'u': -1.0, 'x_I_dom': 0.03, 'eps': 0.002, 'x_I_in': 0.041},  # Case 2\n        {'u': 0.0, 'x_I_dom': 0.025, 'eps': 0.005, 'x_I_in': None},   # Case 3\n        {'u': 3.0, 'x_I_dom': 0.02, 'eps': 0.001, 'x_I_in': 0.0},     # Case 4\n        {'u': -4.0, 'x_I_dom': 0.015, 'eps': 0.0025, 'x_I_in': 0.04}, # Case 5\n        {'u': 1.0, 'x_I_dom': 0.02, 'eps': 0.01, 'x_I_in': -0.0005}, # Case 6\n        {'u': -1.5, 'x_I_dom': 0.025, 'eps': 0.01, 'x_I_in': 0.043}, # Case 7\n    ]\n\n    def smoothed_heaviside(phi, epsilon):\n        \"\"\"\n        Computes the standard smoothed Heaviside function H_epsilon(phi).\n        \"\"\"\n        if phi = -epsilon:\n            return 0.0\n        elif phi >= epsilon:\n            return 1.0\n        else:\n            return 0.5 + phi / (2 * epsilon) + np.sin(np.pi * phi / epsilon) / (2 * np.pi)\n\n    def vof_fraction(phi, epsilon):\n        \"\"\"\n        Computes the VOF fraction alpha = 1 - H_epsilon(phi).\n        \"\"\"\n        return 1.0 - smoothed_heaviside(phi, epsilon)\n\n    results = []\n    for case in test_cases:\n        u = case['u']\n        x_I_dom = case['x_I_dom']\n        eps = case['eps']\n        x_I_in = case['x_I_in']\n\n        # Initialize ghost values\n        phi_gL, alpha_gL, phi_gR, alpha_gR = 0.0, 0.0, 0.0, 0.0\n\n        # --- Left Boundary ---\n        if u > 0:  # Inflow\n            phi_gL = x_g_L - x_I_in\n            alpha_gL = vof_fraction(phi_gL, eps)\n        else:  # Outflow (u = 0)\n            phi_0 = x_0 - x_I_dom\n            alpha_0 = vof_fraction(phi_0, eps)\n            phi_gL = phi_0\n            alpha_gL = alpha_0\n\n        # --- Right Boundary ---\n        if u  0:  # Inflow\n            phi_gR = x_g_R - x_I_in\n            alpha_gR = vof_fraction(phi_gR, eps)\n        else:  # Outflow (u >= 0)\n            phi_N_minus_1 = x_N_minus_1 - x_I_dom\n            alpha_N_minus_1 = vof_fraction(phi_N_minus_1, eps)\n            phi_gR = phi_N_minus_1\n            alpha_gR = alpha_N_minus_1\n            \n        results.append([phi_gL, alpha_gL, phi_gR, alpha_gR])\n\n    # Format the final output string exactly as required\n    case_strings = []\n    for case_result in results:\n        # Use str() for default representation, which is sufficient here.\n        val_strings = [str(v) for v in case_result]\n        case_strings.append(f\"[{','.join(val_strings)}]\")\n    \n    final_output_string = f\"[{','.join(case_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "编写数值模拟程序仅仅是成功的一半，验证其正确性并理解其误差特性同样关键。本练习  将指导你完成一个标准的数值方法验证过程——网格收敛性研究。通过为VOF和LS方法实现简单的一维平流方案并系统地测量其数值误差，你可以亲手验证这些方法的理论精度阶数，这是评估和信任任何数值模拟结果的基础。",
            "id": "3968670",
            "problem": "考虑在单位区间 $x \\in [0,1)$ 上的具有恒定速度 $u$ 的一维周期性平流问题。本文研究了两种界面捕捉方法：流体体积法（VOF）和水平集法（LS）。该平流过程由守恒律 $\\partial_t q + u \\,\\partial_x q = 0$ 控制，其中 $q$ 是一个标量，代表 VOF 体积分数 $C$ 或水平集有符号距离函数 $\\phi$。从第一性原理出发，守恒声明和运动学输运表明，对于恒定的 $u$ 和周期性边界，在精确演化下，任何初始场都会平移距离 $u\\,t$，并在满足 $u\\,T = 1$ 的周期 $T$ 后返回其初始状态。\n\n您必须对以下两种离散格式进行推导、实现，并执行误差分析和收敛性研究：\n\n- 流体体积法（VOF）：在一个包含 $N$ 个单元、单元宽度为 $dx = 1/N$ 的均匀网格上，单元平均体积分数 $C_i^n$ 在时间步长 $dt$ 下遵循一个有限体积迎风更新格式（对于 $u  0$），其中面通量为 $F_{i+1/2}^n = u\\,C_i^n$，因此 $C_i^{n+1} = C_i^n - \\frac{dt}{dx}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right)$。这是施主单元 Godunov 格式，该格式是总变差不增的，且具有一阶精度。\n\n- 水平集法（LS）：有符号距离场 $\\phi(x,t)$ 在单元中心 $x_i = \\left(i+\\frac{1}{2}\\right)dx$ 处进行离散，并通过半拉格朗日平流 $\\phi^{n+1}(x_i) = \\phi^n\\!\\left(x_i - u\\,dt\\right)$ 使用周期性的分段线性插值进行推进。不执行重初始化，以分离出纯粹的平流误差。\n\n使用的基本原理包括：平流的质量守恒、Courant–Friedrichs–Lewy (CFL) 稳定性条件以及数值误差范数的定义。Courant–Friedrichs–Lewy (CFL) 数为 $\\mathrm{CFL} = \\frac{u\\,dt}{dx}$，施主单元格式的数值稳定性要求 $\\mathrm{CFL} \\le 1$。选择时间跨度 $T$ 使得 $u\\,T = 1$，以完成一次完整的域遍历。对于每个网格，时间步数 $N_t$ 必须是整数；调整 $dt$ 以满足 $dt = T/N_t$。\n\n初始条件：\n- 对于 VOF，将 $C(x,0)$ 初始化为 Heaviside 阶跃场，其中当 $x \\le x_0$ 时 $C(x,0) = 1$，否则 $C(x,0) = 0$。\n- 对于 LS，将 $\\phi(x,0)$ 初始化为到 $x_0$ 处界面的周期性有符号距离，即 $\\phi(x,0) = d(x;x_0)$，其中 $d(x;x_0) = \\min\\left(x-x_0,\\,x-x_0-1,\\,x-x_0+1\\right)$，其符号继承自周期区间上最短位移的符号。\n\n在使用周期性边界条件积分到时间 $T$ 后，计算与精确解（由于经过一个完整周期的平流，精确解等于初始场）相比的以下误差：\n- VOF $L^1$ 误差：$E_{L^1}^{\\mathrm{VOF}} = dx \\sum_i \\left| C_i(T) - C_i(0) \\right|$。\n- LS $L^2$ 误差：$E_{L^2}^{\\mathrm{LS}} = \\sqrt{ dx \\sum_i \\left( \\phi_i(T) - \\phi_i(0) \\right)^2 }$。\n\n对于每个场景，使用一系列 $N$ 值进行网格加密，并通过以下公式计算实验收敛阶（EOC）：\n$$\n\\mathrm{EOC} = \\frac{ \\log\\left( \\frac{E(h_1)}{E(h_2)} \\right) }{ \\log\\left( \\frac{h_1}{h_2} \\right) }, \\quad h = dx = \\frac{1}{N},\n$$\n对加密序列中的连续对进行计算，并报告每种方法的连续对 EOC 的平均值。\n\n您必须实现一个程序，该程序能够：\n- 为每个测试场景执行上述格式。\n- 为每个网格尺寸计算 $E_{L^1}^{\\mathrm{VOF}}$ 和 $E_{L^2}^{\\mathrm{LS}}$。\n- 分别为 VOF 和 LS 计算连续网格对的平均 EOC。\n- 生成单行输出，其中包含所有场景的平均 EOC，格式为一个包含六个浮点数的 Python 风格列表，每个浮点数精确到小数点后六位，顺序如下所述。\n\n测试套件：\n- 场景 $\\mathrm{A}$ (理想情况)：$u = 1$, $x_0 = 0.33$, $\\mathrm{CFL} = 0.50$, $T = 1$, $N \\in \\{100, 200, 400, 800\\}$。\n- 场景 $\\mathrm{B}$ (对齐边界情况)：$u = 1$, $x_0 = 0.25$, $\\mathrm{CFL} = 0.50$, $T = 1$, $N \\in \\{64, 128, 256, 512\\}$，使得对于这些均匀网格，$x_0$ 与一个单元边界对齐。\n- 场景 $\\mathrm{C}$ (接近 CFL 稳定性边界)：$u = 1$, $x_0 = 0.33$, $\\mathrm{CFL} = 0.95$, $T = 1$, $N \\in \\{100, 200, 400, 800\\}$。\n\n最终输出格式规范：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序严格如下：$\\left[ \\overline{\\mathrm{EOC}}_{\\mathrm{VOF},\\mathrm{A}}, \\overline{\\mathrm{EOC}}_{\\mathrm{LS},\\mathrm{A}}, \\overline{\\mathrm{EOC}}_{\\mathrm{VOF},\\mathrm{B}}, \\overline{\\mathrm{EOC}}_{\\mathrm{LS},\\mathrm{B}}, \\overline{\\mathrm{EOC}}_{\\mathrm{VOF},\\mathrm{C}}, \\overline{\\mathrm{EOC}}_{\\mathrm{LS},\\mathrm{C}} \\right]$，其中每个条目都是一个浮点数，打印时保留小数点后六位（例如，$[0.987654,1.012345, \\dots ]$）。不涉及物理单位；所有量均为无量纲。不适用弧度或度。这些值为浮点数，必须以上述单行格式打印。",
            "solution": "该问题要求对求解一维线性平流方程 $\\partial_t q + u \\,\\partial_x q = 0$ 的两种数值方法进行推导、实现和比较误差分析，该方程定义在周期性域 $x \\in [0,1)$ 上。标量 $q(x,t)$ 以恒定速度 $u$ 平流。我们研究流体体积法（VOF）和水平集法（LS）。模拟运行时间为 $T$，使得 $uT=1$，这对应于一次完整的域遍历。对于精确平流，时间 $T$ 的解必须与初始条件相同，即 $q(x,T) = q(x,0)$。数值误差通过比较计算得到的 $T$ 时刻的解与初始条件来衡量。\n\n对问题陈述的验证证实了其科学性、适定性、客观性和完整性。所有参数、方程和条件都得到了明确的提供。所描述的方法是计算流体动力学中的标准方法。计算时间步长的过程虽然需要仔细解读，但是一致的：对于一个目标 Courant–Friedrichs–Lewy (CFL) 数，时间步数 $N_t$ 通过向上取整到最近的整数来确定，以确保模拟在恰好 $T$ 时刻结束，然后相应地调整时间步长 $dt$。该问题是有效的，并且可以按所述方式求解。\n\n求解过程首先为 VOF 和 LS 方法定义离散化和数值格式，然后详细说明收敛性研究的步骤。\n\n**离散化和时间步进**\n\n空间域 $[0,1)$ 被离散化为 $N$ 个均匀单元，每个单元的宽度为 $dx = 1/N$。单元 $i$（对于 $i=0, 1, \\dots, N-1$）占据区间 $[i \\cdot dx, (i+1) \\cdot dx]$。物理量要么是单元平均值（VOF），要么定义在单元中心 $x_i = (i+0.5)dx$（LS）。\n\n总模拟时间为 $T = 1/u$。为确保模拟在整数个时间步后恰好在时间 $T$ 结束，我们首先根据目标 CFL 数 $\\mathrm{CFL}_{\\text{target}} = u \\cdot dt_{\\text{target}}/dx$ 计算理想的步数。这给出了一个理想的步数 $N_{t,\\text{ideal}} = T/dt_{\\text{target}} = (1/u) / (\\mathrm{CFL}_{\\text{target}} \\cdot dx / u) = 1/(\\mathrm{CFL}_{\\text{target}} \\cdot dx) = N/\\mathrm{CFL}_{\\text{target}}$。由于步数 $N_t$ 必须是整数，我们设置 $N_t = \\lceil N/\\mathrm{CFL}_{\\text{target}} \\rceil$。然后在模拟中使用的实际时间步长是 $dt = T/N_t$。由此产生的有效 CFL 数为 $\\mathrm{CFL}_{\\text{eff}} = u \\cdot dt/dx = u \\cdot (T/N_t)/dx = u \\cdot ((1/u)/N_t)/(1/N) = N/N_t \\le \\mathrm{CFL}_{\\text{target}}$，满足 VOF 格式的稳定性条件。\n\n**流体体积法（VOF）**\n\nVOF 方法追踪每个计算单元中流体的体积分数。变量是单元平均体积分数 $C_i^n \\approx \\frac{1}{dx} \\int_{i \\cdot dx}^{(i+1)dx} C(x, t^n) dx$。\n\n*   **初始条件**：初始场是一个 Heaviside 阶跃函数，$C(x,0) = 1$ 对于 $x \\le x_0$ 且 $C(x,0)=0$ 对于其他情况。对于离散场，每个单元值 $C_i(0)$ 通过对单元区域进行平均来计算：\n    $$C_i(0) = \\frac{1}{dx} \\int_{i \\cdot dx}^{(i+1)dx} C(x,0) \\,dx$$\n    该积分的计算结果是单元区间 $[i \\cdot dx, (i+1) \\cdot dx]$ 与区域 $[0, x_0]$ 交集的长度除以 $dx$。设 $j = \\lfloor x_0/dx \\rfloor$。那么对于 $i  j$，单元完全充满，$C_i(0)=1$；对于 $i > j$，单元为空，$C_i(0)=0$；对于包含界面的单元 $i=j$，其值为分数 $C_j(0) = (x_0 - j \\cdot dx)/dx$。\n*   **时间步进**：采用一阶迎风格式（对于 $u > 0$）：\n    $$C_i^{n+1} = C_i^n - \\frac{u \\cdot dt}{dx}(C_i^n - C_{i-1}^n)$$\n    其中 $C_{i-1}^n$ 是上游单元的值。周期性边界条件意味着 $C_{-1}^n = C_{N-1}^n$。\n*   **误差计算**：$L^1$ 误差为 $E_{L^1}^{\\mathrm{VOF}} = dx \\sum_{i=0}^{N-1} |C_i(T) - C_i(0)|$。该格式的理论收敛阶数为 1。\n\n**水平集法（LS）**\n\nLS 方法追踪有符号距离函数 $\\phi(x,t)$。变量是单元中心的值 $\\phi_i^n = \\phi(x_i, t^n)$。\n\n*   **初始条件**：$\\phi(x,0)$ 是到 $x_0$ 的周期性有符号距离。对于离散场，$\\phi_i(0) = d(x_i; x_0)$。这可以通过计算 $x_i - x_0$ 然后将其值调整到区间 $[-0.5, 0.5]$ 来实现，例如 $\\phi_i(0) = (x_i - x_0) - \\text{round}(x_i - x_0)$。\n*   **时间步进**：采用半拉格朗日格式：\n    $$\\phi_i^{n+1} = \\phi^n(x_i - u \\cdot dt)$$\n    $\\phi^n$ 在离散点之间的值通过分段线性插值得到。由于域是周期性的，插值也必须是周期性的。\n*   **误差计算**：$L^2$ 误差为 $E_{L^2}^{\\mathrm{LS}} = \\sqrt{dx \\sum_{i=0}^{N-1} (\\phi_i(T) - \\phi_i(0))^2}$。对于平滑解，分段线性插值的半拉格朗日格式具有二阶精度。然而，周期性距离函数在 $x_0 \\pm 0.5$ 处存在一个“扭折”（导数不连续），这可能将收敛阶数降低到接近 1.5。\n\n**收敛性研究**\n\n对于每个场景（A、B、C），将为 VOF 和 LS 两种方法运行一系列网格加密研究。对于 $N$ 的每个值，都会计算出相应的误差。然后，使用提供的公式对连续的网格对（例如，(N=100, N=200)、(N=200, N=400) 等）计算实验收敛阶（EOC）。最后，报告每个场景和每种方法的平均 EOC。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_vof_ic(x0, N):\n    \"\"\"\n    Calculates the initial cell-averaged volume fraction C_i(0).\n    C(x,0) = 1 for x = x0, 0 otherwise.\n    \"\"\"\n    dx = 1.0 / N\n    C0 = np.zeros(N)\n    # Find the index of the cell containing the interface\n    interface_cell_idx = int(np.floor(x0 / dx))\n    \n    # Cells to the left of the interface are full\n    if interface_cell_idx > 0:\n        C0[:interface_cell_idx] = 1.0\n        \n    # The cell containing the interface has a fractional value\n    # if x0 is not on a cell boundary\n    if 0 = interface_cell_idx  N:\n      cell_start = interface_cell_idx * dx\n      C0[interface_cell_idx] = (x0 - cell_start) / dx\n\n    # Special case where x0 aligns with the start of the domain\n    if np.isclose(x0, 0.0):\n        return np.zeros(N)\n\n    # Special case where x0 pushes the last cell to be full\n    if np.isclose(x0, 1.0):\n        return np.ones(N)\n\n    return C0\n\ndef calculate_ls_ic(x_coords, x0):\n    \"\"\"\n    Calculates the initial signed distance function phi(x,0).\n    It is the periodic signed distance to the interface at x0.\n    \"\"\"\n    delta = x_coords - x0\n    # This correctly computes the periodic signed distance on [-0.5, 0.5)\n    phi0 = delta - np.round(delta)\n    return phi0\n\ndef run_vof_sim(N, u, x0, cfl_target):\n    \"\"\"Runs a single VOF simulation for a given grid size N.\"\"\"\n    dx = 1.0 / N\n    T = 1.0 / u\n    \n    # Calculate time step to end exactly at T\n    if cfl_target > 0:\n        Nt = int(np.ceil(N / cfl_target))\n    else: # Should not happen based on problem\n        Nt = 1\n    dt = T / Nt\n    cfl_eff = u * dt / dx\n\n    # Initial condition\n    C0 = calculate_vof_ic(x0, N)\n    C = C0.copy()\n\n    # Time marching\n    for _ in range(Nt):\n        C_prev = np.roll(C, 1)  # Periodic boundary condition\n        C = C - cfl_eff * (C - C_prev)\n        \n    # Calculate L1 error\n    error = dx * np.sum(np.abs(C - C0))\n    return error\n\ndef run_ls_sim(N, u, x0, cfl_target):\n    \"\"\"Runs a single LS simulation for a given grid size N.\"\"\"\n    dx = 1.0 / N\n    x_grid = (np.arange(N) + 0.5) * dx\n    T = 1.0 / u\n    \n    # Calculate time step to end exactly at T\n    if cfl_target > 0:\n        Nt = int(np.ceil(N / cfl_target))\n    else: # Should not happen based on problem\n        Nt = 1\n    dt = T / Nt\n    \n    # Initial condition\n    phi0 = calculate_ls_ic(x_grid, x0)\n    phi = phi0.copy()\n\n    # Time marching\n    for _ in range(Nt):\n        departure_points = x_grid - u * dt\n        # np.interp with period=1.0 handles periodic interpolation\n        phi = np.interp(departure_points, x_grid, phi, period=1.0)\n        \n    # Calculate L2 error\n    error = np.sqrt(dx * np.sum((phi - phi0)**2))\n    return error\n\ndef calculate_mean_eoc(errors, N_vals):\n    \"\"\"Calculates the mean Experimental Order of Convergence.\"\"\"\n    eocs = []\n    h_vals = 1.0 / np.array(N_vals)\n    for i in range(len(N_vals) - 1):\n        E1 = errors[i]\n        E2 = errors[i+1]\n        h1 = h_vals[i]\n        h2 = h_vals[i+1]\n        \n        if E1 > 0 and E2 > 0:\n            eoc = np.log(E1 / E2) / np.log(h1 / h2)\n            eocs.append(eoc)\n            \n    return np.mean(eocs) if eocs else 0.0\n\ndef solve():\n    \"\"\"Main solver function to run all scenarios and print results.\"\"\"\n    scenarios = [\n        # (u, x0, cfl_target, N_vals)\n        (1.0, 0.33, 0.50, [100, 200, 400, 800]), # Scenario A\n        (1.0, 0.25, 0.50, [64, 128, 256, 512]),  # Scenario B\n        (1.0, 0.33, 0.95, [100, 200, 400, 800]), # Scenario C\n    ]\n\n    all_results = []\n    \n    for u, x0, cfl_target, N_vals in scenarios:\n        vof_errors = []\n        ls_errors = []\n        \n        for N in N_vals:\n            vof_errors.append(run_vof_sim(N, u, x0, cfl_target))\n            ls_errors.append(run_ls_sim(N, u, x0, cfl_target))\n        \n        mean_eoc_vof = calculate_mean_eoc(vof_errors, N_vals)\n        mean_eoc_ls = calculate_mean_eoc(ls_errors, N_vals)\n        \n        all_results.extend([mean_eoc_vof, mean_eoc_ls])\n\n    # Format the final output string\n    output_str = f\"[{','.join([f'{r:.6f}' for r in all_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}