{
    "hands_on_practices": [
        {
            "introduction": "流体体积法（VOF）的精度和质量守恒特性，从根本上取决于如何精确计算跨单元面的流体输运体积。本练习将深入探讨分段线性界面重构（PLIC）方案的核心机制，指导您对这种几何通量进行一次切实的计算。通过解决这个问题，您将揭开对流步骤的神秘面纱，并对界面运动如何转化为守恒的体积输运获得具体的理解。",
            "id": "3968668",
            "problem": "考虑一个用于计算流体动力学 (CFD) 中两相界面平流的三维笛卡尔控制体，其采用 VOF (Volume of Fluid) 方法和 PLIC (Piecewise Linear Interface Calculation) 重构。该矩形单元占据区域 $x \\in [0,\\Delta x]$，$y \\in [0,\\Delta y]$，$z \\in [0,\\Delta z]$，其中 $\\Delta x = 0.02$ 米，$\\Delta y = 0.02$ 米，$\\Delta z = 0.01$ 米。在此单元内，流体 $A$ 与流体 $B$ 被一个平面界面分隔，该界面的单位法向量为 $\\boldsymbol{n} = (1,1,0)/\\sqrt{2}$，重构的平面方程为 $x + y = 0.023$ 米，因此流体 $A$ 占据的区域为 $\\{(x,y,z) \\,|\\, x + y \\le 0.023\\ \\text{m}\\}$。\n\n假设沿 $x$ 方向进行方向分裂的平流步。在该时间步内，速度场是均匀且恒定的，为 $\\boldsymbol{u} = (u_{x},0,0)$，其中 $u_{x} = 2.0$ 米/秒。时间步长为 $\\Delta t = 0.0015$ 秒，因此邻近右侧 $x$ 面的迎风厚板厚度为 $s = u_{x}\\,\\Delta t$。在此分裂步中，$y$ 和 $z$ 方向没有运动，界面也没有变形。在时间间隔 $\\Delta t$ 内，通过右侧 $x$ 面（位于 $x = \\Delta x$）离开单元的流体 $A$ 的几何通量，定义为单元内流体 $A$ 与 $x$ 厚板 $x \\in [\\Delta x - s, \\Delta x]$ 的交集的体积，该体积是对 $y$ 和 $z$ 积分得到的。\n\n从流体 $A$ 的平流特征函数的守恒定律出发，并使用上述 PLIC 描述，推导出相应的几何积分，并计算在该时间步内通过右侧 $x$ 面离开单元的流体 $A$ 的总体积。请用立方米表示您的最终数值答案，并四舍五入至四位有效数字。",
            "solution": "该问题要求计算在方向分裂的平流步中，流体 A 通过一个矩形控制体的右侧面流出的体积。所描述的方法是 VOF (Volume of Fluid) 框架内的 PLIC (Piecewise Linear Interface Calculation)。\n\n流体 A 的体积分数（由特征函数 $F_A$ 表示，$F_A=1$ 在流体 A 中，$F_A=0$ 在流体 B 中）的守恒定律由以下平流方程给出：\n$$ \\frac{\\partial F_A}{\\partial t} + \\nabla \\cdot (\\boldsymbol{u} F_A) = 0 $$\n对于沿 $x$ 方向、速度为恒定值 $u_x$ 的单个平流步，该方程简化为：\n$$ \\frac{\\partial F_A}{\\partial t} + u_x \\frac{\\partial F_A}{\\partial x} = 0 $$\n在一个时间步长 $\\Delta t$ 内，通过右侧面（位于 $x=\\Delta x$）离开单元的流体 A 的体积 $\\delta V_{A,\\text{out}}$，是穿过该面的通量的时间积分。对于一阶显式时间积分格式，此通量体积在几何上被解释为位于该面迎风侧邻近的一个“平流厚板”内的流体 A 的体积。该厚板的厚度为 $s = u_x \\Delta t$。\n\n问题明确地将此通量体积定义为三个区域交集的体积：\n1.  控制体（单元）：$V_{\\text{cell}} = \\{ (x,y,z) \\,|\\, 0 \\le x \\le \\Delta x, 0 \\le y \\le \\Delta y, 0 \\le z \\le \\Delta z \\}$。\n2.  流体 A 占据的区域：$V_A = \\{ (x,y,z) \\,|\\, x + y \\le C \\}$，其中 $C=0.023$ 米。\n3.  平流厚板：$V_{\\text{slab}} = \\{ (x,y,z) \\,|\\, \\Delta x - s \\le x \\le \\Delta x \\}$。\n\n给定以下参数：\n- 单元尺寸：$\\Delta x = 0.02$ 米，$\\Delta y = 0.02$ 米，$\\Delta z = 0.01$ 米。\n- 速度：$u_x = 2.0$ 米/秒。\n- 时间步长：$\\Delta t = 0.0015$ 秒。\n\n首先，我们计算平流厚板的厚度 $s$：\n$$ s = u_x \\Delta t = (2.0 \\, \\text{m/s}) \\times (0.0015 \\, \\text{s}) = 0.003 \\, \\text{m} $$\n平流厚板占据区域 $x \\in [\\Delta x - s, \\Delta x]$。代入 $\\Delta x$ 和 $s$ 的值：\n$$ x \\in [0.02 \\, \\text{m} - 0.003 \\, \\text{m}, 0.02 \\, \\text{m}] = [0.017 \\, \\text{m}, 0.02 \\, \\text{m}] $$\n待计算的体积 $\\delta V_A$ 是区域 $R = V_{\\text{cell}} \\cap V_A \\cap V_{\\text{slab}}$ 的体积。区域 $R$ 的边界由所有约束条件的交集定义：\n1.  $0 \\le x \\le 0.02$\n2.  $0 \\le y \\le 0.02$\n3.  $0 \\le z \\le 0.01$\n4.  $x+y \\le 0.023$\n5.  $0.017 \\le x \\le 0.02$\n\n结合约束条件 1 和 5，得到 $x$ 的确定范围：$0.017 \\le x \\le 0.02$。\n对 $y$ 的约束变为 $0 \\le y \\le \\min(0.02, 0.023 - x)$。\n对于 $x \\in [0.017, 0.02]$ 的范围，$0.023 - x$ 这一项的值从 $x$ 的下界 $0.017$ 时的 $0.006$ 变化到 $x$ 的上界 $0.02$ 时的 $0.003$。在此整个范围内，$0.023 - x  0.02$。因此，$y$ 的上界就是 $y = 0.023 - x$。\n\n体积 $\\delta V_A$ 的积分限为：\n$$ \\delta V_A = \\int_{z=0}^{0.01} \\int_{x=0.017}^{0.02} \\int_{y=0}^{0.023-x} dy \\, dx \\, dz $$\n由于被积函数为 1，且 $z$ 的积分限与 $x$ 和 $y$ 无关，我们可以分离该积分：\n$$ \\delta V_A = \\left( \\int_{z=0}^{0.01} dz \\right) \\left( \\int_{x=0.017}^{0.02} \\int_{y=0}^{0.023-x} dy \\, dx \\right) $$\n第一个积分就是区域的高度 $\\Delta z = 0.01$ 米。第二个积分代表了 $xy$ 平面中通量体积的横截面积，我们称之为 $A_{\\text{flux}}$。\n$$ A_{\\text{flux}} = \\int_{x=0.017}^{0.02} \\left[ y \\right]_{y=0}^{0.023-x} dx = \\int_{0.017}^{0.02} (0.023 - x) \\, dx $$\n现在我们计算这个积分：\n$$ A_{\\text{flux}} = \\left[ 0.023x - \\frac{x^2}{2} \\right]_{0.017}^{0.02} $$\n$$ A_{\\text{flux}} = \\left( 0.023 \\cdot 0.02 - \\frac{(0.02)^2}{2} \\right) - \\left( 0.023 \\cdot 0.017 - \\frac{(0.017)^2}{2} \\right) $$\n$$ A_{\\text{flux}} = \\left( 0.00046 - \\frac{0.0004}{2} \\right) - \\left( 0.000391 - \\frac{0.000289}{2} \\right) $$\n$$ A_{\\text{flux}} = (0.00046 - 0.0002) - (0.000391 - 0.0001445) $$\n$$ A_{\\text{flux}} = 0.00026 - 0.0002465 $$\n$$ A_{\\text{flux}} = 0.0000135 \\, \\text{m}^2 $$\n总通量体积 $\\delta V_A$ 是该面积乘以单元深度 $\\Delta z$：\n$$ \\delta V_A = A_{\\text{flux}} \\times \\Delta z = (0.0000135 \\, \\text{m}^2) \\times (0.01 \\, \\text{m}) $$\n$$ \\delta V_A = 0.000000135 \\, \\text{m}^3 = 1.35 \\times 10^{-7} \\, \\text{m}^3 $$\n问题要求将答案四舍五入至四位有效数字。\n$$ \\delta V_A \\approx 1.350 \\times 10^{-7} \\, \\text{m}^3 $$",
            "answer": "$$\\boxed{1.350 \\times 10^{-7}}$$"
        },
        {
            "introduction": "任何实际的模拟都要求稳健的边界条件来处理流入或流出计算域的流体。本实践聚焦于为耦合的水平集（Level Set）和VOF模拟设置流入和流出条件这一关键任务，这是计算流体力学（CFD）实践中的一个常见挑战。您将根据流向和双曲对流的物理原理，实现设置虚拟单元值的逻辑，确保界面以稳定且一致的方式进出计算域。",
            "id": "3968655",
            "problem": "考虑一个一维、不可压缩、两相平流问题，该问题定义在一个均匀的、有限体积、单元中心的网格上。该网格长度为 $L$，包含 $N$ 个内部单元和两个鬼点（每个边界处一个）。内部单元中心的坐标为 $x_i = (i + 0.5)\\Delta x$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$，$\\Delta x = L/N$。左侧鬼点的中心位于 $x_{\\mathrm{g},L} = x_0 - \\Delta x$，右侧鬼点的中心位于 $x_{\\mathrm{g},R} = x_{N-1} + \\Delta x$。流速 $u$ 在空间上均匀且不随时间变化。两个界面捕捉场为：\n- 水平集场 (Level Set field) $\\phi(x,t)$，定义为到物质界面的有符号距离，对于不可压缩流，它遵循双曲平流方程 $\\partial_t \\phi + u \\,\\partial_x \\phi = 0$，并在界面附近满足程函性质 (Eikonal property) $\\lvert \\partial_x \\phi \\rvert = 1$，因此在局部，$\\phi(x) = s\\,(x - x_I)$，其中 $s \\in \\{+1,-1\\}$，$x_I$ 是界面位置；\n- A相的流体体积(VOF)分数 $\\alpha(x,t)$，通过跨越有限界面厚度 $\\varepsilon > 0$ 的平滑亥维赛映射 (smoothed Heaviside mapping) 定义，以确保与水平集场一致。\n\n边界条件仅需在入流边界上给定，这由双曲平流方程的特征线分析和守恒性决定。对于平流速度 $u > 0$，左边界为入流，右边界为出流；对于 $u  0$，右边界为入流，左边界为出流；对于 $u = 0$，两个边界都视为出流（无入流特征线）。水平集场的物理一致性入流边界条件可从有符号距离的定义中获得：如果计算域外的界面位于 $x_I^{\\mathrm{in}}$，则在相应的入流鬼点中心 $x_{\\mathrm{g}}$ 处，其外法线符号为 $s = +1$（常规方向 $\\phi(x) = x - x_I$），鬼点值为 $\\phi_{\\mathrm{g}} = x_{\\mathrm{g}} - x_I^{\\mathrm{in}}$，这强制满足 $\\lvert \\partial_x \\phi \\rvert = 1$ 并将一个几何上一致的界面输运到计算域内。在出流边界，施加零梯度边界条件，即鬼点值等于相邻内部单元的值：$\\phi_{\\mathrm{g}} = \\phi_{\\mathrm{int}}$。\n\n为确保流体体积(VOF)和水平集(Level Set)表示之间的一致性，使用由磨光的狄拉克δ函数 (mollified Dirac delta) 构建的标准平滑亥维赛映射来定义A相的VOF分数。设标准平滑狄拉克δ函数为\n$$\n\\delta_{\\varepsilon}^{\\mathrm{std}}(\\phi) =\n\\begin{cases}\n\\dfrac{1}{2\\varepsilon}\\left(1+\\cos\\left(\\dfrac{\\pi \\phi}{\\varepsilon}\\right)\\right),  \\lvert \\phi \\rvert \\le \\varepsilon, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其积分为标准平滑亥维赛函数 (standard smoothed Heaviside) $H_{\\varepsilon}^{\\mathrm{std}}(\\phi)$，满足 $\\dfrac{d}{d\\phi} H_{\\varepsilon}^{\\mathrm{std}}(\\phi) = \\delta_{\\varepsilon}^{\\mathrm{std}}(\\phi)$，$H_{\\varepsilon}^{\\mathrm{std}}(-\\infty) = 0$，$H_{\\varepsilon}^{\\mathrm{std}}(+\\infty) = 1$。A相的VOF分数定义为 $\\alpha = 1 - H_{\\varepsilon}^{\\mathrm{std}}(\\phi)$，因此在 $\\phi  0$ 的区域（A相）$\\alpha \\approx 1$，在 $\\phi > 0$ 的区域（B相）$\\alpha \\approx 0$，并存在一个厚度为 $\\varepsilon$ 的平滑过渡区。在入流鬼点中，通过平滑亥维赛函数由 $\\phi_{\\mathrm{g}}$ 计算 $\\alpha_{\\mathrm{g}}$；在出流处，施加零梯度条件 $\\alpha_{\\mathrm{g}} = \\alpha_{\\mathrm{int}}$。\n\n假设内部水平集场是充分解析的，并由 $\\phi_i = x_i - x_I^{\\mathrm{dom}}$ 给出（适用于所有内部索引 $i$），其中 $x_I^{\\mathrm{dom}}$ 是计算域内的界面位置。单元 $i$ 的内部VOF分数根据该案例的 $\\phi_i$ 和 $\\varepsilon$ 计算。\n\n您的任务是实现一个程序，对于每个给定的测试案例，确定每个边界是入流还是出流，应用物理上正确的边界条件来计算两个边界上鬼点的水平集和VOF值，并为该案例输出包含四个鬼点值的元组：\n- 左侧水平集鬼点值 $\\phi_{\\mathrm{g},L}$，单位为米，\n- 左侧VOF鬼点值 $\\alpha_{\\mathrm{g},L}$（无量纲），\n- 右侧水平集鬼点值 $\\phi_{\\mathrm{g},R}$，单位为米，\n- 右侧VOF鬼点值 $\\alpha_{\\mathrm{g},R}$（无量纲）。\n\n所有物理量必须使用国际单位制（SI）进行计算。水平集结果以米表示，VOF结果以小数表示。此问题中不涉及角度量。\n\n所有案例均使用以下网格和位置：$N = 4$ 个内部单元，$\\Delta x = 0.01$ 米，$L = 0.04$ 米。因此，$x_0 = 0.005$ 米，$x_1 = 0.015$ 米，$x_2 = 0.025$ 米，$x_3 = 0.035$ 米，$x_{\\mathrm{g},L} = -0.005$ 米，以及 $x_{\\mathrm{g},R} = 0.045$ 米。对于每个案例，内部界面位置 $x_I^{\\mathrm{dom}}$ 用于定义 $\\phi_i$，而入流界面位置 $x_I^{\\mathrm{in}}$ 仅应用于入流边界以构建鬼点水平集值。\n\n所使用的平滑亥维赛映射是由上述 $\\delta_{\\varepsilon}^{\\mathrm{std}}$ 推导出的。您的程序必须实现推导出的 $H_{\\varepsilon}^{\\mathrm{std}}(\\phi)$ 的分段表达式，并计算 $\\alpha = 1 - H_{\\varepsilon}^{\\mathrm{std}}(\\phi)$。\n\n测试套件：\n为以下七个案例提供输出。在每个案例中，报告四元组 $[\\phi_{\\mathrm{g},L},\\alpha_{\\mathrm{g},L},\\phi_{\\mathrm{g},R},\\alpha_{\\mathrm{g},R}]$。\n- 案例1: $u = 2.0$ 米/秒，$x_I^{\\mathrm{dom}} = 0.02$ 米，$\\varepsilon = 0.003$ 米，左侧的 $x_I^{\\mathrm{in}}$ 等于 $-0.002$ 米。\n- 案例2: $u = -1.0$ 米/秒，$x_I^{\\mathrm{dom}} = 0.03$ 米，$\\varepsilon = 0.002$ 米，右侧的 $x_I^{\\mathrm{in}}$ 等于 $0.041$ 米。\n- 案例3: $u = 0.0$ 米/秒，$x_I^{\\mathrm{dom}} = 0.025$ 米，$\\varepsilon = 0.005$ 米。没有入流；两个边界都视为出流。\n- 案例4: $u = 3.0$ 米/秒，$x_I^{\\mathrm{dom}} = 0.02$ 米，$\\varepsilon = 0.001$ 米，左侧的 $x_I^{\\mathrm{in}}$ 等于 $0.0$ 米。\n- 案例5: $u = -4.0$ 米/秒，$x_I^{\\mathrm{dom}} = 0.015$ 米，$\\varepsilon = 0.0025$ 米，右侧的 $x_I^{\\mathrm{in}}$ 等于 $0.04$ 米。\n- 案例6: $u = 1.0$ 米/秒，$x_I^{\\mathrm{dom}} = 0.02$ 米，$\\varepsilon = 0.01$ 米，左侧的 $x_I^{\\mathrm{in}}$ 等于 $-0.0005$ 米。\n- 案例7: $u = -1.5$ 米/秒，$x_I^{\\mathrm{dom}} = 0.025$ 米，$\\varepsilon = 0.01$ 米，右侧的 $x_I^{\\mathrm{in}}$ 等于 $0.043$ 米。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个案例，其本身是一个包含四个鬼点值的列表，例如 $[[\\phi_{\\mathrm{g},L}^{(1)},\\alpha_{\\mathrm{g},L}^{(1)},\\phi_{\\mathrm{g},R}^{(1)},\\alpha_{\\mathrm{g},R}^{(1)}],\\dots]$。",
            "solution": "问题陈述已根据既定标准进行了仔细审查和验证。经确认，该问题具有科学依据、提法恰当、客观且完整。所有提供的数据和定义均与计算流体力学的基本原理一致，特别是关于双曲平流方程和界面捕捉方法（水平集和流体体积法）。该问题是形式化的，并且可以按所述方式求解。\n\n求解需要计算一维域左右边界处水平集场 $\\phi$ 和流体体积(VOF)场 $\\alpha$ 的鬼点值。该过程由一组清晰的、基于物理的规则所控制。\n\n首先，我们必须推导连接 $\\phi$ 和 $\\alpha$ 场的平滑亥维赛函数 $H_{\\varepsilon}^{\\mathrm{std}}(\\phi)$ 的显式公式。它被定义为所提供的平滑狄拉克δ函数 $\\delta_{\\varepsilon}^{\\mathrm{std}}(\\phi)$ 的积分。\n平滑的狄拉克δ函数由下式给出：\n$$\n\\delta_{\\varepsilon}^{\\mathrm{std}}(\\phi) =\n\\begin{cases}\n\\dfrac{1}{2\\varepsilon}\\left(1+\\cos\\left(\\dfrac{\\pi \\phi}{\\varepsilon}\\right)\\right),  \\lvert \\phi \\rvert \\le \\varepsilon, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n平滑亥维赛函数为 $H_{\\varepsilon}^{\\mathrm{std}}(\\phi) = \\int_{-\\infty}^{\\phi} \\delta_{\\varepsilon}^{\\mathrm{std}}(\\xi) d\\xi$，附带条件 $H_{\\varepsilon}^{\\mathrm{std}}(-\\infty) = 0$ 和 $H_{\\varepsilon}^{\\mathrm{std}}(+\\infty) = 1$。\n\n积分存在三种情况：\n1.  对于 $\\phi \\le -\\varepsilon$，被积函数为零，因此 $H_{\\varepsilon}^{\\mathrm{std}}(\\phi) = \\int_{-\\infty}^{\\phi} 0 \\,d\\xi = 0$。\n2.  对于 $\\phi \\ge \\varepsilon$，该函数已在其整个支撑集上完成积分，因此 $H_{\\varepsilon}^{\\mathrm{std}}(\\phi) = \\int_{-\\infty}^{-\\varepsilon} 0 \\,d\\xi + \\int_{-\\varepsilon}^{\\varepsilon} \\delta_{\\varepsilon}^{\\mathrm{std}}(\\xi) d\\xi + \\int_{\\varepsilon}^{\\phi} 0 \\,d\\xi = 1$。这可以通过直接积分得到验证，结果为 $H_{\\varepsilon}^{\\mathrm{std}}(\\varepsilon) = 1$。\n3.  对于 $\\lvert \\phi \\rvert  \\varepsilon$，我们从 $-\\varepsilon$ 开始积分：\n$$\n\\begin{align*}\nH_{\\varepsilon}^{\\mathrm{std}}(\\phi) = \\int_{-\\infty}^{-\\varepsilon} 0 \\,d\\xi + \\int_{-\\varepsilon}^{\\phi} \\dfrac{1}{2\\varepsilon}\\left(1+\\cos\\left(\\dfrac{\\pi \\xi}{\\varepsilon}\\right)\\right) d\\xi \\\\\n= \\dfrac{1}{2\\varepsilon} \\left[ \\xi + \\dfrac{\\varepsilon}{\\pi}\\sin\\left(\\dfrac{\\pi \\xi}{\\varepsilon}\\right) \\right]_{-\\varepsilon}^{\\phi} \\\\\n= \\dfrac{1}{2\\varepsilon} \\left( \\left(\\phi + \\dfrac{\\varepsilon}{\\pi}\\sin\\left(\\dfrac{\\pi \\phi}{\\varepsilon}\\right)\\right) - \\left(-\\varepsilon + \\dfrac{\\varepsilon}{\\pi}\\sin\\left(\\dfrac{-\\pi\\varepsilon}{\\varepsilon}\\right)\\right) \\right) \\\\\n= \\dfrac{1}{2\\varepsilon} \\left( \\phi + \\varepsilon + \\dfrac{\\varepsilon}{\\pi}\\sin\\left(\\dfrac{\\pi \\phi}{\\varepsilon}\\right) \\right) \\quad (\\text{因为 } \\sin(-\\pi) = 0) \\\\\n= \\dfrac{1}{2} + \\dfrac{\\phi}{2\\varepsilon} + \\dfrac{1}{2\\pi}\\sin\\left(\\dfrac{\\pi \\phi}{\\varepsilon}\\right)\n\\end{align*}\n$$\n将这些部分组合起来，完整的分段函数为：\n$$\nH_{\\varepsilon}^{\\mathrm{std}}(\\phi) =\n\\begin{cases}\n0,  \\phi \\le -\\varepsilon \\\\\n\\dfrac{1}{2} + \\dfrac{\\phi}{2\\varepsilon} + \\dfrac{1}{2\\pi}\\sin\\left(\\dfrac{\\pi \\phi}{\\varepsilon}\\right),  \\lvert \\phi \\rvert  \\varepsilon \\\\\n1,  \\phi \\ge \\varepsilon\n\\end{cases}\n$$\n然后，A相的VOF分数计算为 $\\alpha(\\phi) = 1 - H_{\\varepsilon}^{\\mathrm{std}}(\\phi)$。\n\n算法的核心是根据平流速度 $u$ 的符号应用正确的边界条件。固定的网格参数为：$N=4$ 个单元，$\\Delta x = 0.01\\,$米，$L=0.04\\,$米。单元中心坐标为 $x_0 = 0.005\\,$米，$x_1 = 0.015\\,$米，$x_2 = 0.025\\,$米，$x_3 = 0.035\\,$米。鬼点中心坐标为 $x_{\\mathrm{g},L} = -0.005\\,$米和 $x_{\\mathrm{g},R} = 0.045\\,$米。\n\n每个测试案例的一般流程如下：\n\n1.  **分类边界：**\n    - 如果 $u > 0$：左边界 ($x=0$) 为入流，右边界 ($x=L$) 为出流。\n    - 如果 $u  0$：右边界 ($x=L$) 为入流，左边界 ($x=0$) 为出流。\n    - 如果 $u = 0$：两个边界都视为出流。\n\n2.  **计算鬼点值：** 这取决于边界的分类。\n\n    **对于左边界（鬼点位于 $x_{\\mathrm{g},L}$）：**\n    - 如果是 **入流** ($u>0$)：问题提供了入流界面位置 $x_I^{\\mathrm{in}}$。\n        - $\\phi_{\\mathrm{g},L} = x_{\\mathrm{g},L} - x_I^{\\mathrm{in}}$。\n        - $\\alpha_{\\mathrm{g},L}$ 由 $\\phi_{\\mathrm{g},L}$ 通过 $\\alpha(\\phi) = 1 - H_{\\varepsilon}^{\\mathrm{std}}(\\phi)$ 计算得出。\n    - 如果是 **出流** ($u \\le 0$)：应用零梯度条件。鬼点值等于相邻内部单元（$i=0$）的值。\n        - 内部水平集由 $\\phi_i = x_i - x_I^{\\mathrm{dom}}$ 给出。\n        - $\\phi_{\\mathrm{g},L} = \\phi_0 = x_0 - x_I^{\\mathrm{dom}}$。\n        - 内部VOF为 $\\alpha_0 = 1 - H_{\\varepsilon}^{\\mathrm{std}}(\\phi_0)$。\n        - $\\alpha_{\\mathrm{g},L} = \\alpha_0$。\n\n    **对于右边界（鬼点位于 $x_{\\mathrm{g},R}$）：**\n    - 如果是 **入流** ($u0$)：问题提供了入流界面位置 $x_I^{\\mathrm{in}}$。\n        - $\\phi_{\\mathrm{g},R} = x_{\\mathrm{g},R} - x_I^{\\mathrm{in}}$。\n        - $\\alpha_{\\mathrm{g},R}$ 由 $\\phi_{\\mathrm{g},R}$ 通过 $\\alpha(\\phi) = 1 - H_{\\varepsilon}^{\\mathrm{std}}(\\phi)$ 计算得出。\n    - 如果是 **出流** ($u \\ge 0$)：应用零梯度条件。鬼点值等于相邻内部单元（$i=N-1=3$）的值。\n        - 内部水平集为 $\\phi_i = x_i - x_I^{\\mathrm{dom}}$。\n        - $\\phi_{\\mathrm{g},R} = \\phi_{3} = x_3 - x_I^{\\mathrm{dom}}$。\n        - 内部VOF为 $\\alpha_3 = 1 - H_{\\varepsilon}^{\\mathrm{std}}(\\phi_{3})$。\n        - $\\alpha_{\\mathrm{g},R} = \\alpha_{3}$。\n\n我们现在将此流程应用于每个测试案例。\n\n**案例1：** $u = 2.0 > 0$，$x_I^{\\mathrm{dom}} = 0.02$，$\\varepsilon = 0.003$，$x_I^{\\mathrm{in}} = -0.002$ (左侧)。\n- 左侧为入流，右侧为出流。\n- $\\phi_{\\mathrm{g},L} = x_{\\mathrm{g},L} - x_I^{\\mathrm{in}} = -0.005 - (-0.002) = -0.003$。由于 $\\phi_{\\mathrm{g},L} = -\\varepsilon$，$H_{0.003}^{\\mathrm{std}}(-0.003) = 0$。因此，$\\alpha_{\\mathrm{g},L} = 1-0 = 1.0$。\n- $\\phi_{\\mathrm{g},R} = \\phi_3 = x_3 - x_I^{\\mathrm{dom}} = 0.035 - 0.02 = 0.015$。由于 $\\phi_{\\mathrm{g},R} > \\varepsilon$，$H_{0.003}^{\\mathrm{std}}(0.015) = 1$。因此，$\\alpha_{\\mathrm{g},R} = 1-1=0.0$。\n- 结果： $[\\phi_{\\mathrm{g},L}: -0.003, \\alpha_{\\mathrm{g},L}: 1.0, \\phi_{\\mathrm{g},R}: 0.015, \\alpha_{\\mathrm{g},R}: 0.0]$\n\n**案例2：** $u = -1.0  0$，$x_I^{\\mathrm{dom}} = 0.03$，$\\varepsilon = 0.002$，$x_I^{\\mathrm{in}} = 0.041$ (右侧)。\n- 左侧为出流，右侧为入流。\n- $\\phi_{\\mathrm{g},L} = \\phi_0 = x_0 - x_I^{\\mathrm{dom}} = 0.005 - 0.03 = -0.025$。由于 $\\phi_{\\mathrm{g},L}  -\\varepsilon$，$H_{0.002}^{\\mathrm{std}}(-0.025) = 0$。因此，$\\alpha_{\\mathrm{g},L} = 1-0=1.0$。\n- $\\phi_{\\mathrm{g},R} = x_{\\mathrm{g},R} - x_I^{\\mathrm{in}} = 0.045 - 0.041 = 0.004$。由于 $\\phi_{\\mathrm{g},R} > \\varepsilon$，$H_{0.002}^{\\mathrm{std}}(0.004) = 1$。因此，$\\alpha_{\\mathrm{g},R} = 1-1=0.0$。\n- 结果： $[\\phi_{\\mathrm{g},L}: -0.025, \\alpha_{\\mathrm{g},L}: 1.0, \\phi_{\\mathrm{g},R}: 0.004, \\alpha_{\\mathrm{g},R}: 0.0]$\n\n对于所有给定的案例，我们将系统地应用这些控制原理和推导出的公式来生成最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates ghost cell values for Level Set and VOF fields\n    for a 1D advection problem based on specified boundary conditions.\n    \"\"\"\n\n    # Define fixed grid parameters\n    N = 4\n    delta_x = 0.01  # meters\n    L = 0.04  # meters\n    \n    # Interior cell centers\n    x_i = np.array([(i + 0.5) * delta_x for i in range(N)])\n    x_0 = x_i[0]\n    x_N_minus_1 = x_i[-1]\n    \n    # Ghost cell centers\n    x_g_L = x_0 - delta_x\n    x_g_R = x_N_minus_1 + delta_x\n\n    # Test cases from the problem statement\n    test_cases = [\n        {'u': 2.0, 'x_I_dom': 0.02, 'eps': 0.003, 'x_I_in': -0.002},  # Case 1\n        {'u': -1.0, 'x_I_dom': 0.03, 'eps': 0.002, 'x_I_in': 0.041},  # Case 2\n        {'u': 0.0, 'x_I_dom': 0.025, 'eps': 0.005, 'x_I_in': None},   # Case 3\n        {'u': 3.0, 'x_I_dom': 0.02, 'eps': 0.001, 'x_I_in': 0.0},     # Case 4\n        {'u': -4.0, 'x_I_dom': 0.015, 'eps': 0.0025, 'x_I_in': 0.04}, # Case 5\n        {'u': 1.0, 'x_I_dom': 0.02, 'eps': 0.01, 'x_I_in': -0.0005}, # Case 6\n        {'u': -1.5, 'x_I_dom': 0.025, 'eps': 0.01, 'x_I_in': 0.043}, # Case 7\n    ]\n\n    def smoothed_heaviside(phi, epsilon):\n        \"\"\"\n        Computes the standard smoothed Heaviside function H_epsilon(phi).\n        \"\"\"\n        if phi = -epsilon:\n            return 0.0\n        elif phi >= epsilon:\n            return 1.0\n        else:\n            return 0.5 + phi / (2 * epsilon) + np.sin(np.pi * phi / epsilon) / (2 * np.pi)\n\n    def vof_fraction(phi, epsilon):\n        \"\"\"\n        Computes the VOF fraction alpha = 1 - H_epsilon(phi).\n        \"\"\"\n        return 1.0 - smoothed_heaviside(phi, epsilon)\n\n    results = []\n    for case in test_cases:\n        u = case['u']\n        x_I_dom = case['x_I_dom']\n        eps = case['eps']\n        x_I_in = case['x_I_in']\n\n        # Initialize ghost values\n        phi_gL, alpha_gL, phi_gR, alpha_gR = 0.0, 0.0, 0.0, 0.0\n\n        # --- Left Boundary ---\n        if u > 0:  # Inflow\n            phi_gL = x_g_L - x_I_in\n            alpha_gL = vof_fraction(phi_gL, eps)\n        else:  # Outflow (u = 0)\n            phi_0 = x_0 - x_I_dom\n            alpha_0 = vof_fraction(phi_0, eps)\n            phi_gL = phi_0\n            alpha_gL = alpha_0\n\n        # --- Right Boundary ---\n        if u  0:  # Inflow\n            phi_gR = x_g_R - x_I_in\n            alpha_gR = vof_fraction(phi_gR, eps)\n        else:  # Outflow (u >= 0)\n            phi_N_minus_1 = x_N_minus_1 - x_I_dom\n            alpha_N_minus_1 = vof_fraction(phi_N_minus_1, eps)\n            phi_gR = phi_N_minus_1\n            alpha_gR = alpha_N_minus_1\n            \n        results.append([phi_gL, alpha_gL, phi_gR, alpha_gR])\n\n    # Format the final output string exactly as required\n    case_strings = []\n    for case_result in results:\n        # Use str() for default representation, which is sufficient here.\n        val_strings = [str(v) for v in case_result]\n        case_strings.append(f\"[{','.join(val_strings)}]\")\n    \n    final_output_string = f\"[{','.join(case_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "开发数值代码只是工作的一半；确保其正确性并量化其精度是任何计算科学家的基本职责。这个总结性练习将引导您为一个基础的VOF方案和一个水平集对流方案完成一个完整的验证过程，即收敛性研究。这项实践将使您掌握测量数值误差和通过实验验证您所实现方法的理论精度阶数这一基本技能。",
            "id": "3968670",
            "problem": "考虑在单位区间 $x \\in [0,1)$ 上具有恒定速度 $u$ 的一维周期性平流问题。本文研究了两种界面捕捉方法：流体体积法（Volume of Fluid, VOF）和水平集法（Level Set, LS）。该平流过程由守恒律 $\\partial_t q + u \\,\\partial_x q = 0$ 控制，其中 $q$ 是一个标量，代表VOF的体积分数 $C$ 或水平集的有符号距离函数 $\\phi$。从第一性原理出发，守恒定律和运动学输运表明，在恒定速度 $u$ 和周期性边界条件下，任何初始场在精确演化下都会平移距离 $u\\,t$，并在满足 $u\\,T = 1$ 的一个周期 $T$ 后返回其初始状态。\n\n您必须对以下两种离散格式进行推导、实现，并进行误差分析和收敛性研究：\n\n- 流体体积法 (VOF)：在一个包含 $N$ 个单元格、单元格宽度为 $dx = 1/N$、时间步长为 $dt$ 的均匀网格上，单元平均体积分数 $C_i^n$ 在 $u > 0$ 时遵循有限体积迎风格式更新，其中面通量为 $F_{i+1/2}^n = u\\,C_i^n$，因此 $C_i^{n+1} = C_i^n - \\frac{dt}{dx}\\left(F_{i+1/2}^n - F_{i-1/2}^n\\right)$。这是施主单元 Godunov 格式，该格式是总变差递减（TVD）且具有一阶精度。\n\n- 水平集法 (LS)：有符号距离场 $\\phi(x,t)$ 在单元中心 $x_i = \\left(i+\\frac{1}{2}\\right)dx$ 处进行离散，并通过半拉格朗日平流 $\\phi^{n+1}(x_i) = \\phi^n\\!\\left(x_i - u\\,dt\\right)$ 进行推进，其中使用周期性分段线性插值。为了分离纯粹的平流误差，不执行重新初始化。\n\n使用的基本原理包括：平流过程中的质量守恒、Courant–Friedrichs–Lewy (CFL) 稳定性条件以及数值误差范数的定义。Courant–Friedrichs–Lewy (CFL) 数为 $\\mathrm{CFL} = \\frac{u\\,dt}{dx}$，施主单元格式的数值稳定性要求 $\\mathrm{CFL} \\le 1$。选择时间跨度 $T$ 使得 $u\\,T = 1$，以完成一次域遍历。对于每个网格，时间步数 $N_t$ 必须为整数；调整 $dt$ 以满足 $dt = T/N_t$。\n\n初始条件：\n- 对于VOF，将 $C(x,0)$ 初始化为一个 Heaviside 阶跃场，其中当 $x \\le x_0$ 时，$C(x,0) = 1$，否则 $C(x,0) = 0$。\n- 对于LS，将 $\\phi(x,0)$ 初始化为到界面 $x_0$ 的周期性有符号距离，即 $\\phi(x,0) = d(x;x_0)$，其中 $d(x;x_0) = \\min\\left(x-x_0,\\,x-x_0-1,\\,x-x_0+1\\right)$，符号由周期区间上最短位移的符号决定。\n\n在周期性边界条件下积分到时间 $T$ 后，计算与精确解（由于经过一个完整周期的平流，精确解等于初始场）之间的以下误差：\n- VOF $L^1$ 误差：$E_{L^1}^{\\mathrm{VOF}} = dx \\sum_i \\left| C_i(T) - C_i(0) \\right|$。\n- LS $L^2$ 误差：$E_{L^2}^{\\mathrm{LS}} = \\sqrt{ dx \\sum_i \\left( \\phi_i(T) - \\phi_i(0) \\right)^2 }.$。\n\n对于每种情况，使用一系列 $N$ 值进行网格加密，并通过以下公式计算实验收敛阶（EOC）：\n$$\n\\mathrm{EOC} = \\frac{ \\log\\left( \\frac{E(h_1)}{E(h_2)} \\right) }{ \\log\\left( \\frac{h_1}{h_2} \\right) }, \\quad h = dx = \\frac{1}{N},\n$$\n用于加密序列中的连续对，并报告每种方法的连续对EOC的平均值。\n\n您必须实现一个程序，该程序能够：\n- 对每个测试场景执行上述格式。\n- 计算每个网格尺寸下的 $E_{L^1}^{\\mathrm{VOF}}$ 和 $E_{L^2}^{\\mathrm{LS}}$。\n- 分别为 VOF 和 LS 计算连续网格对的平均 EOC。\n- 生成单行输出，包含所有场景的平均 EOC，格式为一个 Python 风格的列表，包含六个浮点数，每个浮点数小数点后精确到六位，顺序如下所述。\n\n测试套件：\n- 场景 $\\mathrm{A}$ (理想情况): $u = 1$, $x_0 = 0.33$, $\\mathrm{CFL} = 0.50$, $T = 1$, $N \\in \\{100, 200, 400, 800\\}$。\n- 场景 $\\mathrm{B}$ (对齐边界情况): $u = 1$, $x_0 = 0.25$, $\\mathrm{CFL} = 0.50$, $T = 1$, $N \\in \\{64, 128, 256, 512\\}$，使得对于这些均匀网格，$x_0$ 与单元格边界对齐。\n- 场景 $\\mathrm{C}$ (接近CFL稳定性边界): $u = 1$, $x_0 = 0.33$, $\\mathrm{CFL} = 0.95$, $T = 1$, $N \\in \\{100, 200, 400, 800\\}$。\n\n最终输出格式规范：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序完全如下：$\\left[ \\overline{\\mathrm{EOC}}_{\\mathrm{VOF},\\mathrm{A}}, \\overline{\\mathrm{EOC}}_{\\mathrm{LS},\\mathrm{A}}, \\overline{\\mathrm{EOC}}_{\\mathrm{VOF},\\mathrm{B}}, \\overline{\\mathrm{EOC}}_{\\mathrm{LS},\\mathrm{B}}, \\overline{\\mathrm{EOC}}_{\\mathrm{VOF},\\mathrm{C}}, \\overline{\\mathrm{EOC}}_{\\mathrm{LS},\\mathrm{C}} \\right]$，其中每个条目都是一个浮点数，打印时小数点后保留六位数字（例如 $[0.987654,1.012345, \\dots ]$）。不涉及物理单位；所有量纲均为一。不适用弧度或度。这些值是浮点数，必须以上述单行格式打印。",
            "solution": "该问题要求对求解一维线性平流方程 $\\partial_t q + u \\,\\partial_x q = 0$ 的两种数值方法进行推导、实现和比较误差分析，该方程定义在周期性域 $x \\in [0,1)$ 上。标量 $q(x,t)$ 以恒定速度 $u$ 进行平流。我们研究流体体积法（VOF）和水平集法（LS）。模拟运行时间为 $T$，使得 $uT=1$，这对应于对整个计算域的一次完整遍历。对于精确平流，时间 $T$ 的解必须与初始条件相同，即 $q(x,T) = q(x,0)$。数值误差通过将时间 $T$ 的计算解与初始条件进行比较来衡量。\n\n对问题陈述的验证证实了其科学基础扎实、适定、客观且完整。所有参数、方程和条件都已明确给出。所描述的方法是计算流体动力学中的标准方法。计算时间步长的过程虽然需要仔细解读，但是一致的：对于一个目标 Courant–Friedrichs–Lewy (CFL) 数，时间步数 $N_t$ 通过向上取整来确定，以确保模拟在时间 $T$ 精确结束，然后相应地调整时间步长 $dt$。该问题是有效的，可以按所述方式解决。\n\n求解过程首先为 VOF 和 LS 方法定义离散化和数值格式，然后详细说明收敛性研究的步骤。\n\n**离散化和时间步进**\n\n空间域 $[0,1)$ 被离散化为 $N$ 个均匀单元格，每个单元格的宽度为 $dx = 1/N$。单元格 $i$（$i=0, 1, \\dots, N-1$）占据区间 $[i \\cdot dx, (i+1) \\cdot dx]$。物理量要么是单元平均值（VOF），要么定义在单元中心 $x_i = (i+0.5)dx$（LS）。\n\n总模拟时间为 $T = 1/u$。为确保模拟在时间 $T$ 以整数个时间步结束，我们首先根据目标 CFL 数 $\\mathrm{CFL}_{\\text{target}} = u \\cdot dt_{\\text{target}}/dx$ 计算理想步数。这给出了理想步数 $N_{t,\\text{ideal}} = T/dt_{\\text{target}} = (1/u) / (\\mathrm{CFL}_{\\text{target}} \\cdot dx / u) = 1/(\\mathrm{CFL}_{\\text{target}} \\cdot dx) = N/\\mathrm{CFL}_{\\text{target}}$。由于步数 $N_t$ 必须是整数，我们设置 $N_t = \\lceil N/\\mathrm{CFL}_{\\text{target}} \\rceil$。然后，模拟中使用的实际时间步长为 $dt = T/N_t$。由此产生的有效 CFL 数为 $\\mathrm{CFL}_{\\text{eff}} = u \\cdot dt/dx = u \\cdot (T/N_t)/dx = u \\cdot ((1/u)/N_t)/(1/N) = N/N_t \\le \\mathrm{CFL}_{\\text{target}}$，满足 VOF 格式的稳定性条件。\n\n**流体体积法 (VOF)**\n\nVOF 方法追踪每个计算单元中流体的体积分数。变量是单元平均体积分数 $C_i^n \\approx \\frac{1}{dx} \\int_{i \\cdot dx}^{(i+1)dx} C(x, t^n) dx$。\n\n*   **初始条件**：初始场是一个 Heaviside 阶跃函数，$C(x,0) = 1$ 当 $x \\le x_0$，$C(x,0)=0$ 否则。对于离散场，每个单元值 $C_i(0)$ 通过在单元区域上取平均值计算得出：\n    $$C_i(0) = \\frac{1}{dx} \\int_{i \\cdot dx}^{(i+1)dx} C(x,0) \\,dx$$\n    该积分计算为单元区间 $[i \\cdot dx, (i+1) \\cdot dx]$ 与区域 $[0, x_0]$ 交集的长度除以 $dx$。这导致完全位于 $x_0$ 左侧的单元格 $C_i(0)=1$，完全位于右侧的单元格 $C_i(0)=0$，而包含 $x_0$ 的单个单元格则具有一个小数部分值。\n\n*   **时间步进**：采用一阶迎风（施主单元）格式。对于 $u>0$，离散方程为：\n    $$ \\frac{C_i^{n+1} - C_i^n}{dt} + u \\frac{C_i^n - C_{i-1}^n}{dx} = 0 $$\n    $C_i^{n+1} = C_i^n - \\frac{u\\,dt}{dx} (C_i^n - C_{i-1}^n)$\n    周期性边界条件意味着 $C_{-1}^n = C_{N-1}^n$。\n\n*   **误差计算**：$L^1$ 范数误差计算为 $E_{L^1}^{\\mathrm{VOF}} = dx \\sum_{i=0}^{N-1} |C_i(T) - C_i(0)|$。\n\n**水平集法 (LS)**\n\nLS 方法追踪一个有符号距离函数 $\\phi(x,t)$。变量是在单元中心 $x_i = (i+0.5)dx$ 的点值 $\\phi_i^n = \\phi(x_i, t^n)$。\n\n*   **初始条件**：初始场是到界面 $x_0$ 的周期性有符号距离。对于 $x_i \\in [0,1)$，$\\phi(x_i, 0)$ 是 $x_i$ 到 $x_0$、 $x_0+1$ 或 $x_0-1$ 中最近的一个的距离，并带有符号。这可以通过 $\\phi_i(0) = (x_i-x_0) - \\text{round}(x_i-x_0)$ 来有效地计算（对于长度为1的域）。\n\n*   **时间步进**：采用半拉格朗日方法。解的特征线为 $X(t) = x_i - u(t-t^n)$。因此，$\\phi(x_i, t^{n+1}) = \\phi(x_i - u\\,dt, t^n)$。$\\phi_i^{n+1}$ 通过在点 $x_i - u\\,dt$ 处对时间 $t^n$ 的场 $\\phi^n$ 进行插值来找到。该问题指定使用周期性分段线性插值。\n\n*   **误差计算**：$L^2$ 范数误差计算为 $E_{L^2}^{\\mathrm{LS}} = \\sqrt{dx \\sum_{i=0}^{N-1} (\\phi_i(T) - \\phi_i(0))^2}$。\n\n**收敛性分析**\n\n对于每个场景（A、B、C），我们对 $N$ 的每个值运行 VOF 和 LS 模拟，并计算相应的误差。然后，对于加密序列中的每一对连续网格（例如，$N_1=100, N_2=200$），我们使用公式 $\\mathrm{EOC} = \\log(E_1/E_2) / \\log(h_1/h_2)$ 计算实验收敛阶，其中 $h=1/N$。最后，我们对每个场景和方法计算这些 EOC 值的平均值。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_vof_ic(x0, N):\n    \"\"\"\n    Calculates the initial cell-averaged volume fraction C_i(0).\n    C(x,0) = 1 for x = x0, 0 otherwise.\n    \"\"\"\n    dx = 1.0 / N\n    C0 = np.zeros(N)\n    # Find the index of the cell containing the interface\n    interface_cell_idx = int(np.floor(x0 / dx))\n    \n    # Cells to the left of the interface are full\n    if interface_cell_idx > 0:\n        C0[:interface_cell_idx] = 1.0\n        \n    # The cell containing the interface has a fractional value\n    if 0 = interface_cell_idx  N:\n      cell_start = interface_cell_idx * dx\n      C0[interface_cell_idx] = (x0 - cell_start) / dx\n\n    # Special case where x0 aligns with the start of the domain\n    if np.isclose(x0, 0.0):\n        return np.zeros(N)\n\n    # Special case where x0 pushes the last cell to be full\n    if np.isclose(x0, 1.0):\n        return np.ones(N)\n\n    return C0\n\ndef calculate_ls_ic(x_coords, x0):\n    \"\"\"\n    Calculates the initial signed distance function phi(x,0).\n    It is the periodic signed distance to the interface at x0.\n    \"\"\"\n    delta = x_coords - x0\n    # This correctly computes the periodic signed distance on [-0.5, 0.5) for a domain of length 1\n    phi0 = delta - np.round(delta)\n    return phi0\n\ndef run_vof_sim(N, u, x0, cfl_target):\n    \"\"\"Runs a single VOF simulation for a given grid size N.\"\"\"\n    dx = 1.0 / N\n    T = 1.0 / u\n    \n    # Calculate time step to end exactly at T\n    if cfl_target > 0:\n        Nt = int(np.ceil(N / cfl_target))\n    else: # Should not happen based on problem\n        Nt = 1\n    dt = T / Nt\n    cfl_eff = u * dt / dx\n\n    # Initial condition\n    C0 = calculate_vof_ic(x0, N)\n    C = C0.copy()\n\n    # Time marching\n    for _ in range(Nt):\n        C_prev = np.roll(C, 1)  # Periodic boundary condition for i-1\n        C = C - cfl_eff * (C - C_prev)\n        \n    # Calculate L1 error\n    error = dx * np.sum(np.abs(C - C0))\n    return error\n\ndef run_ls_sim(N, u, x0, cfl_target):\n    \"\"\"Runs a single LS simulation for a given grid size N.\"\"\"\n    dx = 1.0 / N\n    x_grid = (np.arange(N) + 0.5) * dx\n    T = 1.0 / u\n    \n    # Calculate time step to end exactly at T\n    if cfl_target > 0:\n        Nt = int(np.ceil(N / cfl_target))\n    else: # Should not happen based on problem\n        Nt = 1\n    dt = T / Nt\n    \n    # Initial condition\n    phi0 = calculate_ls_ic(x_grid, x0)\n    phi = phi0.copy()\n\n    # Time marching\n    for _ in range(Nt):\n        departure_points = x_grid - u * dt\n        # np.interp with period=1.0 handles periodic interpolation\n        # Note: x_grid must be sorted for np.interp\n        phi = np.interp(departure_points, x_grid, phi, period=1.0)\n        \n    # Calculate L2 error\n    error = np.sqrt(dx * np.sum((phi - phi0)**2))\n    return error\n\ndef calculate_mean_eoc(errors, N_vals):\n    \"\"\"Calculates the mean Experimental Order of Convergence.\"\"\"\n    eocs = []\n    h_vals = 1.0 / np.array(N_vals)\n    for i in range(len(N_vals) - 1):\n        E1 = errors[i]\n        E2 = errors[i+1]\n        h1 = h_vals[i]\n        h2 = h_vals[i+1]\n        \n        if E1 > 1e-15 and E2 > 1e-15: # Avoid log(0)\n            eoc = np.log(E1 / E2) / np.log(h1 / h2)\n            eocs.append(eoc)\n            \n    return np.mean(eocs) if eocs else 0.0\n\ndef solve():\n    \"\"\"Main solver function to run all scenarios and print results.\"\"\"\n    scenarios = [\n        # (u, x0, cfl_target, N_vals)\n        (1.0, 0.33, 0.50, [100, 200, 400, 800]), # Scenario A\n        (1.0, 0.25, 0.50, [64, 128, 256, 512]),  # Scenario B\n        (1.0, 0.33, 0.95, [100, 200, 400, 800]), # Scenario C\n    ]\n\n    all_results = []\n    \n    for u, x0, cfl_target, N_vals in scenarios:\n        vof_errors = []\n        ls_errors = []\n        \n        for N in N_vals:\n            vof_errors.append(run_vof_sim(N, u, x0, cfl_target))\n            ls_errors.append(run_ls_sim(N, u, x0, cfl_target))\n        \n        mean_eoc_vof = calculate_mean_eoc(vof_errors, N_vals)\n        mean_eoc_ls = calculate_mean_eoc(ls_errors, N_vals)\n        \n        all_results.extend([mean_eoc_vof, mean_eoc_ls])\n\n    # Format the final output string\n    output_str = f\"[{','.join([f'{r:.6f}' for r in all_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}