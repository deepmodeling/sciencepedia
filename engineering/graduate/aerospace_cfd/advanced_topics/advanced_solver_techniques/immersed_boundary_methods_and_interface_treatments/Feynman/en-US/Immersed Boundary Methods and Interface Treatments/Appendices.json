{
    "hands_on_practices": [
        {
            "introduction": "A fundamental challenge in immersed boundary methods is to satisfy the incompressible flow constraint, $\\nabla \\cdot \\mathbf{u} = 0$, at the discrete level, especially in cells cut by the boundary. While enforcing the no-slip condition on momentum is the primary goal, simple interpolation schemes for ghost cell values can inadvertently create artificial mass sources or sinks. This exercise provides a hands-on analytical experience in quantifying this common numerical error, demonstrating how a seemingly consistent boundary treatment can violate discrete mass conservation .",
            "id": "3966940",
            "problem": "Consider an incompressible flow in two dimensions with an Immersed Boundary Method (IBM) discretized on a uniform Marker-And-Cell (MAC) staggered grid of spacings $\\Delta x$ and $\\Delta y$. The fluid occupies the region $x > s$ and the solid occupies $x  s$, where the immersed boundary is the vertical line $x = s$ and the no-slip boundary condition $u = 0$ and $v = 0$ holds on $x = s$. Let the cell of interest have vertical faces at $x = 0$ and $x = \\Delta x$ and be centered at $(\\Delta x/2, 0)$, with the immersed boundary crossing the cell interior at $x = s$ such that $0  s  \\Delta x$. The discrete divergence operator at the cell center is defined by\n$$\nD_{h} \\equiv \\frac{u_{E} - u_{W}}{\\Delta x} + \\frac{v_{N} - v_{S}}{\\Delta y},\n$$\nwhere $u_{E}$ and $u_{W}$ are the $x$-velocity values at the east and west faces, respectively, and $v_{N}$ and $v_{S}$ are the $y$-velocity values at the north and south faces, respectively.\n\nAssume the continuum velocity field is generated by a streamfunction $\\psi(x,y)$ such that the incompressibility condition $\\nabla \\cdot \\boldsymbol{u} = 0$ is identically satisfied, with $u = \\partial \\psi / \\partial y$ and $v = - \\partial \\psi / \\partial x$. Let the streamfunction be\n$$\n\\psi(x,y) = \\alpha \\,(x - s)^{2} \\, y,\n$$\nwith constant $\\alpha$ and $0  s  \\Delta x$. This provides a divergence-free flow that satisfies the no-slip condition at $x = s$.\n\nFor the IBM treatment of the cut west face $x = 0$ (which lies in the solid), consider two interpolation operators used to construct the ghost value $u_{W}$ so that the interpolant evaluated at $x = s$ enforces the boundary value $u(x=s)=0$:\n- A first-order linear interpolation operator that interpolates $u$ linearly in $x$ between $x=0$ (ghost) and $x=\\Delta x$ (fluid).\n- A second-order quadratic interpolation operator that interpolates $u$ quadratically in $x$ using the three points $x = s$ (boundary, value $u=0$), $x = \\Delta x$ (fluid), and $x = 2\\Delta x$ (fluid).\n\nUsing the above definitions, compute the discrete divergence at the cell center for each interpolation operator and deduce the discrete divergence error with respect to the continuum divergence, which is zero. Report, as a single simplified expression, the discrete divergence error for the first-order linear interpolation operator at the cell center. No rounding is required. The final expression is dimensionless.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n**Step 1: Extract Givens**\n- **Geometry and Grid**: A two-dimensional domain discretized on a uniform Marker-And-Cell (MAC) grid with spacings $\\Delta x$ and $\\Delta y$.\n- **Immersed Boundary (IB)**: A vertical line at $x=s$, with $0  s  \\Delta x$. The fluid region is $x > s$ and the solid region is $x  s$.\n- **Boundary Condition**: No-slip, $u=0$ and $v=0$, at the boundary $x=s$.\n- **Cell of Interest**: Centered at $(\\frac{\\Delta x}{2}, 0)$, with vertical faces at $x=0$ and $x=\\Delta x$.\n- **Discrete Divergence Operator**: At the cell center, $D_{h} \\equiv \\frac{u_{E} - u_{W}}{\\Delta x} + \\frac{v_{N} - v_{S}}{\\Delta y}$. Here, $u_{E}$ and $u_{W}$ are the $x$-velocities at the east ($x=\\Delta x$) and west ($x=0$) faces, and $v_{N}$ and $v_{S}$ are the $y$-velocities at the north ($y=\\frac{\\Delta y}{2}$) and south ($y=-\\frac{\\Delta y}{2}$) faces of the cell control volume for divergence.\n- **Continuum Flow Field**: Defined by the streamfunction $\\psi(x,y) = \\alpha \\,(x - s)^{2} \\, y$, where $\\alpha$ is a constant. The velocity components are $u = \\frac{\\partial \\psi}{\\partial y}$ and $v = - \\frac{\\partial \\psi}{\\partial x}$. The continuum divergence $\\nabla \\cdot \\boldsymbol{u} = 0$ is satisfied.\n- **Ghost Cell Treatment**: For the west face at $x=0$, which is in the solid region, the velocity $u_W$ is a ghost value. It is determined using a first-order linear interpolation in $x$ between the ghost point at $x=0$ and the first fluid point at $x=\\Delta x$. This interpolation must enforce the boundary condition $u(s)=0$.\n- **Objective**: Compute the discrete divergence error for the first-order linear interpolation scheme. The final answer is required to be a dimensionless expression.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is well-defined and grounded in the principles of computational fluid dynamics, specifically concerning the immersed boundary method on staggered grids. The provided streamfunction $\\psi(x,y) = \\alpha (x-s)^2 y$ correctly generates a velocity field $u = \\alpha(x-s)^2$ and $v = -2\\alpha(x-s)y$. This field is divergence-free, as $\\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y} = 2\\alpha(x-s) - 2\\alpha(x-s) = 0$, and it satisfies the no-slip condition ($u=0, v=0$) at the boundary $x=s$. The interpolation scheme is clearly specified. The problem is self-contained and consistent.\n\nA potential ambiguity arises from the request for a dimensionless final expression. A dimensional analysis shows that if $x, y, s$ have units of length $[L]$, and $\\psi$ has units $[L]^2/[T]$, then $\\alpha$ has units $1/([L][T])$, and the resulting discrete divergence $\\alpha s$ has units of inverse time $[T]^{-1}$. However, this is resolved by adopting the standard convention in theoretical fluid mechanics of treating all supplied variables and constants as non-dimensional quantities. This interpretation aligns with the explicit instruction and renders the problem valid.\n\n**Step 3: Verdict and Action**\nThe problem is deemed valid. A solution will be derived.\n\n**Solution Derivation**\nThe objective is to compute the discrete divergence $D_h$ at the center of the specified control volume, which is located at $(\\frac{\\Delta x}{2}, 0)$. The discrete divergence is given by:\n$$\nD_{h} = \\frac{u_{E} - u_{W}}{\\Delta x} + \\frac{v_{N} - v_{S}}{\\Delta y}\n$$\nThe continuum velocity field is derived from the streamfunction $\\psi(x,y) = \\alpha (x-s)^2 y$:\n$$\nu(x,y) = \\frac{\\partial \\psi}{\\partial y} = \\alpha (x-s)^2\n$$\n$$\nv(x,y) = -\\frac{\\partial \\psi}{\\partial x} = -2\\alpha(x-s)y\n$$\nWe evaluate the velocity components at the faces of the divergence control volume. The MAC grid staggering places $u$-velocities at the centers of vertical faces and $v$-velocities at the centers of horizontal faces. For the cell centered at $(\\frac{\\Delta x}{2}, 0)$, the face locations are:\n- East face center (for $u_E$): $(\\Delta x, 0)$\n- West face center (for $u_W$): $(0, 0)$\n- North face center (for $v_N$): $(\\frac{\\Delta x}{2}, \\frac{\\Delta y}{2})$\n- South face center (for $v_S$): $(\\frac{\\Delta x}{2}, -\\frac{\\Delta y}{2})$\n\nThe velocities at the fluid-side faces are taken from the continuum field:\n$$\nu_E = u(\\Delta x, 0) = \\alpha(\\Delta x - s)^2\n$$\n$$\nv_N = v\\left(\\frac{\\Delta x}{2}, \\frac{\\Delta y}{2}\\right) = -2\\alpha\\left(\\frac{\\Delta x}{2} - s\\right)\\left(\\frac{\\Delta y}{2}\\right) = -\\alpha\\left(\\Delta x - 2s\\right)\\frac{\\Delta y}{2}\n$$\n$$\nv_S = v\\left(\\frac{\\Delta x}{2}, -\\frac{\\Delta y}{2}\\right) = -2\\alpha\\left(\\frac{\\Delta x}{2} - s\\right)\\left(-\\frac{\\Delta y}{2}\\right) = \\alpha\\left(\\Delta x - 2s\\right)\\frac{\\Delta y}{2}\n$$\nThe contribution from the vertical velocities to the discrete divergence is:\n$$\n\\frac{v_N - v_S}{\\Delta y} = \\frac{-\\alpha(\\Delta x - 2s)\\frac{\\Delta y}{2} - \\alpha(\\Delta x - 2s)\\frac{\\Delta y}{2}}{\\Delta y} = \\frac{-\\alpha(\\Delta x - 2s)\\Delta y}{\\Delta y} = -\\alpha(\\Delta x - 2s)\n$$\nNext, we determine the ghost velocity $u_W$ at $x=0$. The first-order scheme uses linear interpolation between the ghost point value $u_W$ at $x=0$ and the fluid point value $u_E$ at $x=\\Delta x$. Let the linear interpolant for the $x$-velocity be $u_{interp}(x)$.\n$$\nu_{interp}(x) = u_W + \\frac{u_E - u_W}{\\Delta x} x\n$$\nThis interpolation must satisfy the boundary condition $u=0$ at $x=s$. Therefore, we set $u_{interp}(s)=0$:\n$$\nu_W + \\frac{u_E - u_W}{\\Delta x} s = 0\n$$\nSolving for the ghost value $u_W$:\n$$\nu_W \\left(1 - \\frac{s}{\\Delta x}\\right) = -u_E \\frac{s}{\\Delta x}\n$$\n$$\nu_W \\left(\\frac{\\Delta x - s}{\\Delta x}\\right) = -u_E \\frac{s}{\\Delta x}\n$$\n$$\nu_W = -u_E \\frac{s}{\\Delta x - s}\n$$\nSubstitute the expression for $u_E = \\alpha(\\Delta x - s)^2$:\n$$\nu_W = -\\left(\\alpha(\\Delta x - s)^2\\right) \\frac{s}{\\Delta x - s} = -\\alpha s (\\Delta x - s)\n$$\nNow, we can compute the contribution from the horizontal velocities to the discrete divergence:\n$$\n\\frac{u_E - u_W}{\\Delta x} = \\frac{\\alpha(\\Delta x - s)^2 - (-\\alpha s (\\Delta x - s))}{\\Delta x} = \\frac{\\alpha(\\Delta x - s) [(\\Delta x - s) + s]}{\\Delta x}\n$$\n$$\n\\frac{u_E - u_W}{\\Delta x} = \\frac{\\alpha(\\Delta x - s) (\\Delta x)}{\\Delta x} = \\alpha(\\Delta x - s)\n$$\nFinally, we sum the horizontal and vertical contributions to find the total discrete divergence $D_h$:\n$$\nD_h = \\alpha(\\Delta x - s) + (-\\alpha(\\Delta x - 2s)) = \\alpha(\\Delta x - s - \\Delta x + 2s) = \\alpha s\n$$\nThe discrete divergence error is the difference between the discrete divergence and the continuum divergence. Since the flow is incompressible by construction, the continuum divergence $\\nabla \\cdot \\boldsymbol{u}$ is identically zero.\n$$\n\\text{Error} = D_h - (\\nabla \\cdot \\boldsymbol{u}) = \\alpha s - 0 = \\alpha s\n$$\nThus, the discrete divergence error for the first-order interpolation scheme is $\\alpha s$.",
            "answer": "$$\\boxed{\\alpha s}$$"
        },
        {
            "introduction": "Moving beyond kinematic accuracy, the correct representation of forces is paramount, particularly for fluid-fluid interfaces governed by surface tension. A notorious numerical artifact in many surface tension models is the appearance of \"parasitic currents,\" which are spurious velocities that arise even in a physically static scenario. This practice demonstrates that these currents stem from a discrete imbalance between the surface tension force and the pressure gradient, challenging you to prove and implement a \"balanced-force\" formulation that eliminates this issue by ensuring consistent discretization of both terms .",
            "id": "3966969",
            "problem": "Consider a two-dimensional static droplet represented with an Immersed Boundary (IB) interface treatment using the Continuous Surface Force (CSF) method within the Volume of Fluid (VOF) framework. The goal is to implement a balanced-force formulation where the discrete pressure gradient and the discrete surface tension force share the same differential operator and spatial alignment, thereby minimizing parasitic currents. Work on a uniform Cartesian grid and assume dimensionless variables (no physical units required). The derivation must start from the incompressible steady-state momentum balance and a standard approximation of surface tension as a volumetric force via a smoothed phase indicator.\n\nUse the following foundational base:\n- The incompressible momentum equation at steady state reduces to $\\nabla p = \\mathbf{f}_{\\sigma}$, where $p$ is pressure and $\\mathbf{f}_{\\sigma}$ is the surface tension force per unit volume.\n- The CSF representation approximates the singular surface tension force localized at the interface as $\\mathbf{f}_{\\sigma} \\approx \\sigma \\kappa \\nabla H_{\\epsilon}(\\phi)$, where $\\sigma$ is surface tension coefficient, $\\kappa$ is interface curvature, $H_{\\epsilon}$ is a smoothed Heaviside function of a signed-distance function $\\phi$, and $\\epsilon$ is the smoothing half-width.\n- For a circular droplet of radius $R$, the mean curvature is constant and equal to $\\kappa = \\frac{1}{R}$.\n\nYou must:\n1. Implement a discrete formulation on an $N_x \\times N_y$ periodic domain $\\Omega = [0,1] \\times [0,1]$ with uniform spacings $\\Delta x = \\frac{1}{N_x}, \\quad \\Delta y = \\frac{1}{N_y},$ and cell centers at $x_i = \\left(i+\\frac{1}{2}\\right)\\Delta x, \\quad y_j = \\left(j+\\frac{1}{2}\\right)\\Delta y.$\n2. Construct a signed distance function $\\phi(x,y) = \\sqrt{(x-c_x)^2 + (y-c_y)^2} - R$ for a droplet of radius $R$ centered at $(c_x,c_y)$, and define the smoothed Heaviside $H_{\\epsilon}(\\phi) = \\begin{cases} 0,  \\phi \\le -\\epsilon, \\\\ \\frac{1}{2}\\left[1 + \\frac{\\phi}{\\epsilon} + \\frac{1}{\\pi}\\sin\\left(\\frac{\\pi \\phi}{\\epsilon}\\right)\\right],  |\\phi|  \\epsilon, \\\\ 1,  \\phi \\ge \\epsilon. \\end{cases}$\n3. Implement the discrete gradient operator using second-order central differences with periodic boundary conditions for any scalar field $q_{i,j}$, so that $\\left(\\nabla q\\right)_{i,j} = \\left(\\frac{q_{i+1,j} - q_{i-1,j}}{2\\Delta x}, \\frac{q_{i,j+1} - q_{i,j-1}}{2\\Delta y}\\right),$ where indices wrap periodically.\n4. Define the balanced-force pressure as $p = p_0 + \\sigma \\kappa H_{\\epsilon}(\\phi)$, with $p_0 = 0$, and compute the discrete residual of the steady momentum balance $\\mathbf{R}_{\\text{bal}} = \\sigma \\kappa \\nabla H_{\\epsilon}(\\phi) - \\nabla p$ using the same central difference operator for both gradients.\n5. Define an intentionally unbalanced formulation that mismatches operators and smoothing: compute $\\mathbf{R}_{\\text{unbal}} = \\sigma \\kappa \\nabla^{\\text{fwd}} H(\\phi) - \\nabla p,$ where $H$ is the unsmoothed Heaviside $H(\\phi) = \\begin{cases} 0,  \\phi  0, \\\\ 1,  \\phi \\ge 0, \\end{cases}$ and $\\nabla^{\\text{fwd}}$ is the first-order forward difference gradient with periodic boundary conditions:\n$\\left(\\nabla^{\\text{fwd}} q\\right)_{i,j} = \\left(\\frac{q_{i+1,j} - q_{i,j}}{\\Delta x}, \\frac{q_{i,j+1} - q_{i,j}}{\\Delta y}\\right).$\n6. Quantify the magnitude of imbalance in each case by computing the scalar residual norm $\\|\\mathbf{R}\\|_2 = \\left(\\frac{1}{N_x N_y} \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left(R_x^2 + R_y^2\\right)\\right)^{1/2}.$\n7. Prove in your solution that, under the assumptions above and using identical discrete gradient operators for both terms, the discrete residual $\\mathbf{R}_{\\text{bal}}$ vanishes identically when $\\kappa$ is constant, thereby demonstrating a discrete force balance at steady state.\n\nTest Suite:\nFor each case, take $\\epsilon = \\alpha \\Delta x$ with specified $\\alpha$ and $\\sigma = 1$.\n- Case 1 (general \"happy path\"): $N_x = 64$, $N_y = 64$, $R = 0.20$, $(c_x,c_y) = (0.50,0.50)$, $\\alpha = 1.5$.\n- Case 2 (off-center near boundary): $N_x = 64$, $N_y = 64$, $R = 0.15$, $(c_x,c_y) = (0.35,0.40)$, $\\alpha = 1.5$.\n- Case 3 (near grid-resolution limit): $N_x = 64$, $N_y = 64$, $R = 2\\Delta x$, $(c_x,c_y) = (0.52,0.47)$, $\\alpha = 1.0$.\n\nFor each case, your program must compute and return two floating-point numbers: the balanced residual norm and the unbalanced residual norm, both dimensionless. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case contributes a pair represented as a two-element list, for example, $$[\\,[r_{1,\\text{bal}}, r_{1,\\text{unbal}}],\\,[r_{2,\\text{bal}}, r_{2,\\text{unbal}}],\\,[r_{3,\\text{bal}}, r_{3,\\text{unbal}}]\\,].$$",
            "solution": "The problem presented is a valid and well-posed exercise in computational fluid dynamics, specifically concerning the numerical treatment of surface tension forces for static interfaces. It is scientifically grounded in the principles of the Volume of Fluid (VOF) method coupled with a Continuous Surface Force (CSF) model. The objective is to demonstrate the importance of a 'balanced-force' discretization, where the discrete pressure gradient and surface tension force operators are formulated consistently to eliminate spurious numerical artifacts known as parasitic currents. We will first provide a formal proof of the discrete force balance and then describe the algorithmic implementation for the numerical verification.\n\nAll mathematical entities, including variables, symbols, operators, and numbers, are rendered in LaTeX as required.\n\n**Principle-Based Derivation and Algorithmic Design**\n\nThe fundamental state under consideration is a static fluid droplet at equilibrium. In the absence of fluid motion and external body forces (like gravity), the incompressible steady-state Navier-Stokes momentum equation reduces to a balance between the pressure gradient force and the surface tension force:\n$$\n\\nabla p = \\mathbf{f}_{\\sigma}\n$$\nwhere $p$ is the pressure field and $\\mathbf{f}_{\\sigma}$ is the volumetric surface tension force. The Continuous Surface Force (CSF) method models this force, which is physically confined to the interface, as a continuous field by using a smoothed phase indicator function. The specified model is:\n$$\n\\mathbf{f}_{\\sigma} = \\sigma \\kappa \\nabla H_{\\epsilon}(\\phi)\n$$\nHere, $\\sigma$ is the constant surface tension coefficient, $\\kappa$ is the interface mean curvature, $\\phi$ is a signed distance function (SDF) to the interface, and $H_{\\epsilon}$ is a regularized or smoothed Heaviside function that transitions smoothly from $0$ (inside the droplet) to $1$ (outside the droplet) across an interface of thickness $2\\epsilon$. For a circular droplet of radius $R$, the curvature $\\kappa = 1/R$ is constant everywhere on the interface.\n\n**Proof of Discrete Force Balance**\n\nThe core principle of a balanced-force formulation is to ensure that the discrete approximations of the pressure gradient and the surface tension force cancel each other exactly for a static equilibrium case. This prevents the generation of a non-zero net force that would erroneously induce fluid motion.\n\nWe are asked to prove that the discrete residual of the balanced formulation, $\\mathbf{R}_{\\text{bal}}$, is identically zero. The residual is defined as:\n$$\n\\mathbf{R}_{\\text{bal}} = \\sigma \\kappa \\nabla H_{\\epsilon}(\\phi) - \\nabla p\n$$\nThe 'balanced' aspect is introduced through a specific definition of the pressure field $p$. Consistent with the Young-Laplace equation, the pressure jump across the interface is $\\Delta p = \\sigma \\kappa$. In the CSF framework, this is achieved by defining the pressure field itself in terms of the same smoothed Heaviside function used for the surface tension force:\n$$\np = p_0 + \\sigma \\kappa H_{\\epsilon}(\\phi)\n$$\nWith the reference pressure $p_0$ set to $0$, this simplifies to $p = \\sigma \\kappa H_{\\epsilon}(\\phi)$.\n\nSubstituting this definition of $p$ into the residual equation yields:\n$$\n\\mathbf{R}_{\\text{bal}} = \\sigma \\kappa \\nabla H_{\\epsilon}(\\phi) - \\nabla \\left( \\sigma \\kappa H_{\\epsilon}(\\phi) \\right)\n$$\nIn the continuous domain, since $\\sigma$ and $\\kappa$ are constants, they can be factored out of the gradient operator. The gradient operator $\\nabla$ is a linear operator, meaning $\\nabla(c f) = c \\nabla f$ for any constant scalar $c$ and scalar field $f$. Thus,\n$$\n\\mathbf{R}_{\\text{bal}} = \\sigma \\kappa \\nabla H_{\\epsilon}(\\phi) - \\sigma \\kappa \\nabla H_{\\epsilon}(\\phi) = \\mathbf{0}\n$$\nThe crucial step is to verify this holds for the *discrete* operators as well. Let $\\mathcal{G}$ denote the specified discrete second-order central difference gradient operator. The problem states that this exact same operator is used for both terms in $\\mathbf{R}_{\\text{bal}}$. The discrete residual at a grid cell $(i,j)$ is:\n$$\n(\\mathbf{R}_{\\text{bal}})_{i,j} = \\sigma \\kappa \\mathcal{G}(H_{\\epsilon})_{i,j} - \\mathcal{G}(p)_{i,j}\n$$\nThe discrete pressure field is defined at each cell center as $p_{i,j} = \\sigma \\kappa (H_{\\epsilon})_{i,j}$, where $(H_{\\epsilon})_{i,j}$ is the value of the smoothed Heaviside function at that cell center. Substituting this into the residual:\n$$\n(\\mathbf{R}_{\\text{bal}})_{i,j} = \\sigma \\kappa \\mathcal{G}(H_{\\epsilon})_{i,j} - \\mathcal{G}(\\sigma \\kappa H_{\\epsilon})_{i,j}\n$$\nThe central difference operator $\\mathcal{G}$ is a linear operator. For instance, its x-component acting on a field $q$ is $\\mathcal{G}_x(q)_{i,j} = (q_{i+1,j} - q_{i-1,j}) / (2\\Delta x)$. Applying this to $\\sigma \\kappa H_{\\epsilon}$:\n$$\n\\mathcal{G}_x(\\sigma \\kappa H_{\\epsilon})_{i,j} = \\frac{(\\sigma \\kappa H_{\\epsilon})_{i+1,j} - (\\sigma \\kappa H_{\\epsilon})_{i-1,j}}{2\\Delta x} = \\sigma \\kappa \\left( \\frac{(H_{\\epsilon})_{i+1,j} - (H_{\\epsilon})_{i-1,j}}{2\\Delta x} \\right) = \\sigma \\kappa \\mathcal{G}_x(H_{\\epsilon})_{i,j}\n$$\nThis demonstrates that $\\mathcal{G}(\\sigma \\kappa H_{\\epsilon}) = \\sigma \\kappa \\mathcal{G}(H_{\\epsilon})$. Therefore, the discrete residual becomes:\n$$\n(\\mathbf{R}_{\\text{bal}})_{i,j} = \\sigma \\kappa \\mathcal{G}(H_{\\epsilon})_{i,j} - \\sigma \\kappa \\mathcal{G}(H_{\\epsilon})_{i,j} = \\mathbf{0}\n$$\nThis holds for every cell $(i,j)$ in the domain. Consequently, the norm of the residual, $\\|\\mathbf{R}_{\\text{bal}}\\|_2$, must be identically zero (or a value on the order of machine precision due to floating-point arithmetic). This completes the proof.\n\nIn contrast, the unbalanced formulation,\n$$\n\\mathbf{R}_{\\text{unbal}} = \\sigma \\kappa \\nabla^{\\text{fwd}} H(\\phi) - \\nabla p\n$$\nis designed to fail this balance. The imbalance arises from two distinct sources:\n1.  **Operator Mismatch**: The surface tension term is discretized with a first-order forward difference ($\\nabla^{\\text{fwd}}$), while the pressure gradient uses a second-order central difference ($\\nabla$). These operators have different stencils and truncation errors, so $\\sigma \\kappa \\nabla^{\\text{fwd}} H_{\\epsilon}(\\phi) \\neq \\nabla (\\sigma \\kappa H_{\\epsilon}(\\phi))$ even if the same function were used.\n2.  **Function Mismatch**: The surface tension term uses the raw, unsmoothed Heaviside function $H(\\phi)$, while the pressure is defined using the smoothed function $H_{\\epsilon}(\\phi)$. The gradient of $H(\\phi)$ is a discrete approximation of a Dirac delta function, which is fundamentally different from the smooth, bell-shaped derivative of $H_{\\epsilon}(\\phi)$.\n\nDue to these inconsistencies, $\\mathbf{R}_{\\text{unbal}}$ will be significantly non-zero, leading to the large residual norms expected in the numerical results.\n\n**Numerical Implementation Algorithm**\n\nThe numerical procedure to compute the residuals for each test case follows these steps:\n1.  **Grid Setup**: For a given resolution $N_x, N_y$, define the domain size $L_x = 1, L_y = 1$ and calculate the grid spacings $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$. Construct two $N_y \\times N_x$ arrays representing the cell-centered coordinates $x_{i,j} = (i+0.5)\\Delta x$ and $y_{i,j} = (j+0.5)\\Delta y$.\n2.  **Parameter Calculation**: For each test case, use the given $R, c_x, c_y, \\alpha$ to determine the curvature $\\kappa = 1/R$ and the smoothing width $\\epsilon = \\alpha \\Delta x$. The surface tension coefficient is $\\sigma = 1$.\n3.  **Field Computations**:\n    -   Compute the signed distance function field $\\phi_{i,j} = \\sqrt{(x_{i,j}-c_x)^2 + (y_{i,j}-c_y)^2} - R$.\n    -   Compute the smoothed Heaviside field $(H_{\\epsilon})_{i,j}$ using the provided piecewise formula.\n    -   Compute the unsmoothed Heaviside field $(H)_{i,j}$.\n    -   Compute the pressure field $p_{i,j} = \\sigma \\kappa (H_{\\epsilon})_{i,j}$.\n4.  **Gradient Computations**: Implement two functions for the discrete gradients, both handling periodic boundaries.\n    -   `grad_cen(q)`: This function takes a 2D field $q$ and returns two 2D fields for the x- and y-components of the central difference gradient. Periodicity is handled using array-rolling operations (e.g., `numpy.roll`).\n    -   `grad_fwd(q)`: Similarly, this function computes the forward difference gradient.\n5.  **Residual Calculation**:\n    -   **Balanced Case**:\n        -   Compute $(\\nabla H_{\\epsilon})_{i,j}$ using `grad_cen`.\n        -   Compute $(\\nabla p)_{i,j}$ using `grad_cen`.\n        -   Calculate the residual components: $R_{\\text{bal},x} = \\sigma \\kappa (\\nabla H_{\\epsilon})_x - (\\nabla p)_x$ and $R_{\\text{bal},y} = \\sigma \\kappa (\\nabla H_{\\epsilon})_y - (\\nabla p)_y$.\n    -   **Unbalanced Case**:\n        -   Compute $(\\nabla^{\\text{fwd}} H)_{i,j}$ using `grad_fwd`.\n        -   The pressure gradient $(\\nabla p)_{i,j}$ is the same as in the balanced case (central-differenced).\n        -   Calculate the residual components: $R_{\\text{unbal},x} = \\sigma \\kappa (\\nabla^{\\text{fwd}} H)_x - (\\nabla p)_x$ and $R_{\\text{unbal},y} = \\sigma \\kappa (\\nabla^{\\text{fwd}} H)_y - (\\nabla p)_y$.\n6.  **Norm Calculation**: For both $\\mathbf{R}_{\\text{bal}}$ and $\\mathbf{R}_{\\text{unbal}}$, compute the root-mean-square norm as specified: $\\|\\mathbf{R}\\|_2 = \\sqrt{\\frac{1}{N_x N_y} \\sum_{i,j} (R_x^2 + R_y^2)}$. This is efficiently computed as `np.sqrt(np.mean(R_x**2 + R_y**2))`.\n7.  **Iteration**: Repeat steps 2-6 for all test cases provided in the suite and format the resulting norms as requested.",
            "answer": "```python\nimport numpy as np\n\n# Meticulous adherence to the specified execution environment:\n# language: Python 3.12\n# libraries:\n#     - name: numpy, version: 1.23.5\n\ndef solve():\n    \"\"\"\n    Computes balanced and unbalanced force residuals for a static droplet\n    using an Immersed Boundary (CSF) method.\n    \"\"\"\n\n    def grad_cen(q, dx, dy):\n        \"\"\"Computes the 2D gradient using second-order central differences\n        with periodic boundary conditions.\"\"\"\n        grad_x = (np.roll(q, -1, axis=1) - np.roll(q, 1, axis=1)) / (2.0 * dx)\n        grad_y = (np.roll(q, -1, axis=0) - np.roll(q, 1, axis=0)) / (2.0 * dy)\n        return grad_x, grad_y\n\n    def grad_fwd(q, dx, dy):\n        \"\"\"Computes the 2D gradient using first-order forward differences\n        with periodic boundary conditions.\"\"\"\n        grad_x = (np.roll(q, -1, axis=1) - q) / dx\n        grad_y = (np.roll(q, -1, axis=0) - q) / dy\n        return grad_x, grad_y\n\n    def H_eps_func(phi, epsilon):\n        \"\"\"Computes the smoothed Heaviside function H_epsilon(phi).\"\"\"\n        H = np.zeros_like(phi)\n        \n        # Condition: phi = -epsilon\n        mask1 = phi = -epsilon\n        H[mask1] = 0.0\n        \n        # Condition: phi = epsilon\n        mask2 = phi = epsilon\n        H[mask2] = 1.0\n\n        # Condition: |phi|  epsilon\n        mask3 = np.abs(phi)  epsilon\n        phi_masked = phi[mask3]\n        \n        term1 = 1.0 + phi_masked / epsilon\n        term2 = (1.0 / np.pi) * np.sin(np.pi * phi_masked / epsilon)\n        H[mask3] = 0.5 * (term1 + term2)\n        \n        return H\n\n    def H_func(phi):\n        \"\"\"Computes the unsmoothed Heaviside function H(phi).\"\"\"\n        H = np.zeros_like(phi)\n        H[phi = 0] = 1.0\n        return H\n\n    def calculate_residual_norm(Rx, Ry):\n        \"\"\"Computes the L2 norm of the residual vector field.\"\"\"\n        return np.sqrt(np.mean(Rx**2 + Ry**2))\n\n    # Test suite as defined in the problem statement.\n    test_cases = [\n        # (Nx, Ny, R, cx, cy, alpha)\n        (64, 64, 0.20, 0.50, 0.50, 1.5),  # Case 1\n        (64, 64, 0.15, 0.35, 0.40, 1.5),  # Case 2\n        (64, 64, 2.0 * (1.0/64), 0.52, 0.47, 1.0), # Case 3 R=2*dx\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        Nx, Ny, R, cx, cy, alpha = case\n        \n        # --- 1. Grid and Parameter Setup ---\n        sigma = 1.0\n        dx = 1.0 / Nx\n        dy = 1.0 / Ny\n        \n        # Check for R=0 to avoid division by zero, although not in test cases\n        if R == 0:\n            kappa = np.inf\n        else:\n            kappa = 1.0 / R\n            \n        epsilon = alpha * dx # Assuming dx=dy for simplicity in definition\n\n        x = (np.arange(Nx) + 0.5) * dx\n        y = (np.arange(Ny) + 0.5) * dy\n        X, Y = np.meshgrid(x, y)\n\n        # --- 2. Field Computations ---\n        phi = np.sqrt((X - cx)**2 + (Y - cy)**2) - R\n        \n        H_eps_field = H_eps_func(phi, epsilon)\n        H_field = H_func(phi)\n        \n        p_field = sigma * kappa * H_eps_field\n\n        # --- 3. Balanced Case Calculation ---\n        # Surface tension term using central differences on H_eps\n        f_sigma_x_bal, f_sigma_y_bal = grad_cen(H_eps_field, dx, dy)\n        f_sigma_x_bal *= sigma * kappa\n        f_sigma_y_bal *= sigma * kappa\n        \n        # Pressure gradient term using central differences on p\n        grad_p_x_cen, grad_p_y_cen = grad_cen(p_field, dx, dy)\n\n        # Balanced residual\n        R_bal_x = f_sigma_x_bal - grad_p_x_cen\n        R_bal_y = f_sigma_y_bal - grad_p_y_cen\n        \n        norm_bal = calculate_residual_norm(R_bal_x, R_bal_y)\n\n        # --- 4. Unbalanced Case Calculation ---\n        # Surface tension term using forward differences on H\n        f_sigma_x_unbal, f_sigma_y_unbal = grad_fwd(H_field, dx, dy)\n        f_sigma_x_unbal *= sigma * kappa\n        f_sigma_y_unbal *= sigma * kappa\n\n        # Pressure gradient is the same as before (central difference on p based on H_eps)\n        # grad_p_x_cen, grad_p_y_cen are already computed\n\n        # Unbalanced residual\n        R_unbal_x = f_sigma_x_unbal - grad_p_x_cen\n        R_unbal_y = f_sigma_y_unbal - grad_p_y_cen\n        \n        norm_unbal = calculate_residual_norm(R_unbal_x, R_unbal_y)\n\n        results.append([norm_bal, norm_unbal])\n\n    # --- 5. Final Output Formatting ---\n    # The required format is [[r1_bal, r1_unbal],[r2_bal, r2_unbal],...], which\n    # is a list of lists. The str() of a list of lists gives '[...]', so we join them.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "When an immersed boundary or interface moves, it is crucial that the simulation conserves fundamental quantities like mass and volume. A naive advection of the volume fraction field often leads to numerical diffusion or dispersion, violating this principle. This practice guides you through the derivation and implementation of a conservative remapping algorithm, a geometric approach rooted in the Reynolds transport theorem that updates the volume fraction by exactly tracking the displaced boundary, thereby guaranteeing conservation .",
            "id": "3966968",
            "problem": "You are tasked with deriving and implementing a conservative re-mapping for a moving immersed boundary in a one-dimensional periodic domain, where the mask or volume fraction field is advected by a prescribed displacement while guaranteeing exact conservation through cut-cell updates. The derivation must start from the finite volume formulation of local conservation, grounded in the conservation of measure under rigid translations, and the Reynolds transport theorem, without relying on shortcut formulas.\n\nConsider a one-dimensional periodic domain of length $L$ (in meters) discretized into $N$ uniform finite volume cells of width $\\Delta x = L/N$. Let there be a single rigid body segment (the immersed boundary) occupying the interval $[x_a, x_b]$ at time $t^n$, with $0 \\le x_a  x_b \\le L$. The binary mask indicates the solid region by an indicator function; for finite volume cut-cell treatment, define the fluid volume fraction in cell $i$ at time $t$ as the cell average of the indicator of the fluid set, denoted $\\alpha_i(t) \\in [0,1]$, where $\\alpha_i(t) = 1$ for a fully fluid cell and $\\alpha_i(t) = 0$ for a fully solid cell.\n\nBetween times $t^n$ and $t^{n+1}$, the immersed boundary undergoes a rigid translation by displacement $d$ (in meters) under periodic boundary conditions. Your task is to:\n\n- Derive from first principles a conservative remapping for the cell-averaged fluid volume fraction $\\alpha_i^{n+1}$ at time $t^{n+1}$, ensuring exact conservation of fluid measure across the mesh under periodic translation. The derivation must begin from the finite volume conservation statement and the measure-preserving property of rigid translations, and must explain why the remapping preserves the total fluid length and how cut-cells are updated without loss or gain of fluid volume.\n\n- Implement a program that, given $L$, $N$, $(x_a, x_b)$, and $d$, computes the updated fluid volume fractions $\\alpha_i^{n+1}$ for all cells using a geometry-consistent, strictly conservative cut-cell update that accounts for periodic wrapping. The algorithm must work for nonzero, zero, positive, negative, and large displacements $d$, and must properly handle cases where the boundary positions align exactly with cell faces (leading to no cut-cells) or lie strictly within cells (leading to exactly two cut-cells for a single segment).\n\nFor each test case, compute and report:\n1. The absolute conservation error in meters, defined as the absolute difference between the total fluid length at $t^{n+1}$ and at $t^n$, i.e., $ \\left| \\sum_i \\alpha_i^{n+1} \\Delta x - \\sum_i \\alpha_i^{n} \\Delta x \\right|$.\n2. The number of cut-cells after the update, defined as the count of cells where $0  \\alpha_i^{n+1}  1$.\n\nPhysical unit requirement: Express the conservation error in meters. Angles are not used. Percentages are not used; report fractions as decimals.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must alternate between the conservation error (a float in meters) and the number of cut-cells (an integer) for each test case, in the order the test cases are listed below. For example: \"[err1,cc1,err2,cc2,err3,cc3,err4,cc4,err5,cc5]\".\n\nImplement and evaluate the following test suite:\n- Test case 1 (happy path, non-aligned to faces after motion): $L = 1.0$ m, $N = 16$, $x_a = 0.25$ m, $x_b = 0.50$ m, $d = +0.10$ m.\n- Test case 2 (boundary condition: zero displacement): $L = 1.0$ m, $N = 16$, $x_a = 0.25$ m, $x_b = 0.50$ m, $d = 0.0$ m.\n- Test case 3 (exact one-cell shift): $L = 1.0$ m, $N = 20$, $x_a = 0.10$ m, $x_b = 0.34$ m, $d = \\Delta x$ (use the mesh for this test to compute $\\Delta x$).\n- Test case 4 (negative displacement with wrap-around): $L = 1.0$ m, $N = 16$, $x_a = 0.85$ m, $x_b = 0.95$ m, $d = -0.20$ m.\n- Test case 5 (large displacement with multiple wraps): $L = 1.0$ m, $N = 100$, $x_a = 0.02$ m, $x_b = 0.478$ m, $d = +1.30$ m.\n\nYour implementation must be self-contained, must not read any external input, and must strictly adhere to the specified output format.",
            "solution": "The problem requires the derivation and implementation of a conservative remapping algorithm for the fluid volume fraction, $\\alpha_i$, in a one-dimensional periodic domain containing a translating rigid body. The derivation must be founded on the principles of finite volume conservation and the conservation of measure under rigid translation.\n\n### Derivation from First Principles\n\nLet the fluid domain be characterized by an indicator function, $H(x, t)$, such that $H(x, t) = 1$ if $x$ is in the fluid at time $t$, and $H(x, t) = 0$ if $x$ is in the solid. The motion of the rigid body is a uniform translation with velocity $u$. The evolution of the indicator function is governed by the linear advection equation:\n$$\n\\frac{\\partial H}{\\partial t} + u \\frac{\\partial H}{\\partial x} = 0\n$$\nThis equation states that the property $H$ is conserved along characteristic lines $x(t) = x_0 + ut$.\n\nThe fluid volume fraction, $\\alpha_i(t)$, in a computational cell $C_i = [x_{i-1/2}, x_{i+1/2}]$ of width $\\Delta x$, is the cell average of $H(x, t)$:\n$$\n\\alpha_i(t) = \\frac{1}{\\Delta x} \\int_{C_i} H(x, t) dx\n$$\n\nTo derive an update rule for $\\alpha_i$ from time $t^n$ to $t^{n+1} = t^n + \\Delta t$, we start from the integral form of the conservation law. This form is a direct consequence of the Reynolds transport theorem applied to the quantity $H$ in a fixed control volume $C_i$. Integrating the advection equation over the cell $C_i$:\n$$\n\\int_{C_i} \\left(\\frac{\\partial H}{\\partial t} + \\frac{\\partial(uH)}{\\partial x}\\right) dx = 0\n$$\nsince the velocity $u$ is constant. Applying the divergence theorem in one dimension and swapping the order of integration and time differentiation for the first term (as $C_i$ is fixed) yields:\n$$\n\\frac{d}{dt} \\int_{C_i} H(x, t) dx + [uH]_{x_{i+1/2}} - [uH]_{x_{i-1/2}} = 0\n$$\nSubstituting the definition of $\\alpha_i(t)$ gives the exact evolution for the cell-averaged quantity:\n$$\n\\frac{d}{dt} (\\alpha_i \\Delta x) + F_{i+1/2} - F_{i-1/2} = 0\n$$\nwhere $F(x, t) = uH(x, t)$ is the flux of the indicator function. Integrating this equation over the time interval $[t^n, t^{n+1}]$:\n$$\n\\int_{t^n}^{t^{n+1}} \\frac{d}{dt} (\\alpha_i \\Delta x) dt + \\int_{t^n}^{t^{n+1}} (F_{i+1/2} - F_{i-1/2}) dt = 0\n$$\n$$\n\\alpha_i(t^{n+1})\\Delta x - \\alpha_i(t^n)\\Delta x + \\int_{t^n}^{t^{n+1}} (F_{i+1/2}(t) - F_{i-1/2}(t)) dt = 0\n$$\nLetting $\\alpha_i^n = \\alpha_i(t^n)$, the updated volume fraction is given by:\n$$\n\\alpha_i^{n+1} = \\alpha_i^n - \\frac{1}{\\Delta x} \\int_{t^n}^{t^{n+1}} (F_{i+1/2}(t) - F_{i-1/2}(t)) dt\n$$\nThis is the fundamental finite volume update formula. The challenge is to evaluate the time-integrated fluxes.\n\nFor the specific case of a rigid body translation by a displacement $d$ over the time interval $\\Delta t$, where $d = u \\Delta t$, we can solve for $\\alpha_i^{n+1}$ exactly without approximating the fluxes. The exact solution to the advection equation is given by the method of characteristics:\n$$\nH(x, t^{n+1}) = H(x - u\\Delta t, t^n) = H(x - d, t^n)\n$$\nThe new volume fraction $\\alpha_i^{n+1}$ can therefore be computed directly by averaging this exact solution over the cell $C_i$:\n$$\n\\alpha_i^{n+1} = \\frac{1}{\\Delta x} \\int_{C_i} H(x, t^{n+1}) dx = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} H(x - d, t^n) dx\n$$\nThis integral represents the fluid fraction within cell $C_i$ based on the initial fluid distribution shifted by $d$. This is a purely geometric calculation: we determine the new position of the solid body, $[x_a+d, x_b+d]$, and compute its intersection with each cell $C_i$ to find the new solid fraction, from which we get the fluid fraction $\\alpha_i^{n+1}$. This method is often called a geometric remapping or re-initialization.\n\n### Conservation Property\n\nThis geometric remapping approach is inherently and exactly conservative. The total fluid length (measure) at time $t^{n+1}$ is $\\mathcal{L}^{n+1} = \\sum_{i=0}^{N-1} \\alpha_i^{n+1} \\Delta x$. Substituting the expression for $\\alpha_i^{n+1}$:\n$$\n\\mathcal{L}^{n+1} = \\sum_{i=0}^{N-1} \\left( \\int_{x_{i-1/2}}^{x_{i+1/2}} H(x - d, t^n) dx \\right) = \\int_{0}^{L} H(x-d, t^n) dx\n$$\nThe last step follows from summing the integrals over all adjacent cells covering the domain $[0, L]$. We perform a change of variables $y = x - d$, so $dy = dx$. The limits of integration change from $[0, L]$ to $[-d, L-d]$.\n$$\n\\mathcal{L}^{n+1} = \\int_{-d}^{L-d} H(y, t^n) dy\n$$\nSince the domain and the function $H(y, t^n)$ are periodic with period $L$, the integral of a periodic function over any interval of length equal to its period is constant. Thus:\n$$\n\\int_{-d}^{L-d} H(y, t^n) dy = \\int_{0}^{L} H(y, t^n) dy\n$$\nThis final integral is the total fluid length at time $t^n$:\n$$\n\\int_{0}^{L} H(y, t^n) dy = \\sum_{i=0}^{N-1} \\int_{C_i} H(y, t^n) dy = \\sum_{i=0}^{N-1} \\alpha_i^n \\Delta x = \\mathcal{L}^n\n$$\nTherefore, $\\mathcal{L}^{n+1} = \\mathcal{L}^n$. The total fluid length is exactly conserved, irrespective of the grid resolution or the displacement $d$. The update of cut-cells via geometric intersection guarantees no loss or gain of fluid volume because it is a direct calculation of the new state, which, as proven, must conserve the total measure.\n\n### Algorithmic Implementation\n\nThe algorithm proceeds as follows:\n1.  Discretize the domain $[0, L]$ into $N$ cells of width $\\Delta x = L/N$, defining cell boundaries $x_{i-1/2} = i \\cdot \\Delta x$ for $i=0, \\dots, N$.\n2.  Define a helper function `overlap([a, b], [c, d])` that computes the length of the intersection of two intervals, given by $\\max(0, \\min(b, d) - \\max(a, c))$.\n3.  For the initial state at $t^n$, calculate the solid interval $[x_a, x_b]$. For each cell $i$, compute the initial solid length $s_i^n$ as the overlap of the cell interval $[x_{i-1/2}, x_{i+1/2}]$ with $[x_a, x_b]$. The initial fluid fraction is $\\alpha_i^n = 1 - s_i^n / \\Delta x$. Calculate the total initial fluid length $\\mathcal{L}^n = \\sum_i \\alpha_i^n \\Delta x$.\n4.  Calculate the new endpoints of the solid body: $x_a' = x_a + d$ and $x_b' = x_b + d$.\n5.  Handle periodic boundary conditions. The new solid region in the domain $[0, L)$ is determined by the modulo operator. Let $x_{a, \\text{mod}}' = x_a' \\pmod L$ and $x_{b, \\text{mod}}' = x_b' \\pmod L$. Assuming the body length $x_b-x_a  L$, there are two cases:\n    a. If $x_{a, \\text{mod}}'  x_{b, \\text{mod}}'$, the new solid forms a single interval $[x_{a, \\text{mod}}', x_{b, \\text{mod}}']$.\n    b. If $x_{a, \\text{mod}}' \\ge x_{b, \\text{mod}}'$, the solid region has wrapped around the periodic boundary and occupies two intervals: $[0, x_{b, \\text{mod}}']$ and $[x_{a, \\text{mod}}', L]$.\n6.  For the final state at $t^{n+1}$, calculate the new fluid fractions $\\alpha_i^{n+1}$. For each cell $i$, compute the new solid length $s_i^{n+1}$ by summing the overlaps of the cell interval with the new solid interval(s) determined in step 5. The final fluid fraction is $\\alpha_i^{n+1} = 1 - s_i^{n+1} / \\Delta x$.\n7.  Calculate the total final fluid length $\\mathcal{L}^{n+1} = \\sum_i \\alpha_i^{n+1} \\Delta x$.\n8.  The absolute conservation error is $|\\mathcal{L}^{n+1} - \\mathcal{L}^n|$.\n9.  The number of cut-cells is the count of cells where $0  \\alpha_i^{n+1}  1$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (happy path, non-aligned)\n        {\"L\": 1.0, \"N\": 16, \"xa\": 0.25, \"xb\": 0.50, \"d\": +0.10},\n        # Test case 2 (zero displacement)\n        {\"L\": 1.0, \"N\": 16, \"xa\": 0.25, \"xb\": 0.50, \"d\": 0.0},\n        # Test case 3 (exact one-cell shift)\n        {\"L\": 1.0, \"N\": 20, \"xa\": 0.10, \"xb\": 0.34, \"d\": 1.0 / 20.0},\n        # Test case 4 (negative displacement with wrap-around)\n        {\"L\": 1.0, \"N\": 16, \"xa\": 0.85, \"xb\": 0.95, \"d\": -0.20},\n        # Test case 5 (large displacement with multiple wraps)\n        {\"L\": 1.0, \"N\": 100, \"xa\": 0.02, \"xb\": 0.478, \"d\": +1.30},\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, xa, xb, d = case[\"L\"], case[\"N\"], case[\"xa\"], case[\"xb\"], case[\"d\"]\n        error, cut_cells = compute_remapping(L, N, xa, xb, d)\n        results.extend([error, cut_cells])\n\n    # Format the output as specified in the problem\n    formatted_results = []\n    for i in range(len(results)):\n        if i % 2 == 0:  # Conservation error (float)\n            formatted_results.append(f\"{results[i]:.17g}\")\n        else:  # Number of cut cells (integer)\n            formatted_results.append(str(results[i]))\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef compute_remapping(L: float, N: int, xa: float, xb: float, d: float):\n    \"\"\"\n    Computes the updated fluid volume fractions and associated metrics.\n\n    Args:\n        L: Length of the periodic domain.\n        N: Number of finite volume cells.\n        xa: Initial start position of the solid segment.\n        xb: Initial end position of the solid segment.\n        d: Rigid displacement.\n\n    Returns:\n        A tuple containing:\n        - The absolute conservation error in fluid length.\n        - The number of cut-cells after the update.\n    \"\"\"\n    dx = L / N\n    cell_edges = np.linspace(0, L, N + 1)\n    \n    def get_overlap_length(interval1, interval2):\n        \"\"\"Calculates the length of the intersection of two intervals.\"\"\"\n        a1, b1 = interval1\n        a2, b2 = interval2\n        return max(0.0, min(b1, b2) - max(a1, a2))\n\n    def calculate_alphas(solid_intervals):\n        \"\"\"Calculates alpha values for a given set of solid intervals.\"\"\"\n        alphas = np.ones(N)\n        for i in range(N):\n            cell_interval = (cell_edges[i], cell_edges[i+1])\n            solid_length_in_cell = 0.0\n            for solid_interval in solid_intervals:\n                solid_length_in_cell += get_overlap_length(cell_interval, solid_interval)\n            \n            # Use a small tolerance to avoid floating point issues at cell boundaries\n            # In principle, `solid_length_in_cell / dx` should be = 1.0\n            solid_fraction = solid_length_in_cell / dx\n            alphas[i] = 1.0 - solid_fraction\n        return alphas\n\n    # === Initial state (t^n) ===\n    solid_intervals_n = [(xa, xb)]\n    alphas_n = calculate_alphas(solid_intervals_n)\n    total_fluid_length_n = np.sum(alphas_n) * dx\n\n    # === Final state (t^{n+1}) ===\n    xa_new = xa + d\n    xb_new = xb + d\n\n    # Handle periodicity\n    # Python's % operator behaves as a mathematical modulo for negative numbers\n    xa_new_mod = xa_new % L\n    xb_new_mod = xb_new % L\n    \n    solid_intervals_np1 = []\n    if (xb_new - xa_new) = L: # Body is as long or longer than the domain\n        solid_intervals_np1.append((0, L))\n    elif xa_new_mod  xb_new_mod:\n        # Single continuous interval\n        solid_intervals_np1.append((xa_new_mod, xb_new_mod))\n    else:\n        # Wrapped around the boundary, two intervals\n        solid_intervals_np1.append((xa_new_mod, L))\n        solid_intervals_np1.append((0.0, xb_new_mod))\n\n    alphas_np1 = calculate_alphas(solid_intervals_np1)\n    total_fluid_length_np1 = np.sum(alphas_np1) * dx\n\n    # === Calculate final metrics ===\n    conservation_error = abs(total_fluid_length_np1 - total_fluid_length_n)\n    \n    # A cell is a cut-cell if alpha is not exactly 0 or 1.\n    # Use a small tolerance for floating point comparisons.\n    epsilon = 1e-9\n    num_cut_cells = np.sum((alphas_np1  epsilon)  (alphas_np1  1.0 - epsilon))\n    \n    return conservation_error, int(num_cut_cells)\n\nsolve()\n\n```"
        }
    ]
}