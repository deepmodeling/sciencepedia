{
    "hands_on_practices": [
        {
            "introduction": "这项基础练习是后续所有实践的基石。我们将从一维欧拉方程和一个常见的数值通量（局部Lax-Friedrichs通量）出发，为一个控制体显式地构建非线性残差。接着，你将围绕均匀流进行线性化，推导出雅可比矩阵的结构，从而加深对离散守恒律与其线性化之间联系的理解，这是构建隐式方法的关键一步。",
            "id": "3973376",
            "problem": "考虑理想气体的一维空间可压缩欧拉方程，其比热比为 $\\gamma$。设守恒状态向量为 $U = (\\rho, \\rho u, \\rho E)^{\\mathsf{T}}$，其中 $\\rho$ 是密度， $u$ 是速度， $E$ 是比总能。压强由理想气体关系式 $p = (\\gamma - 1)\\left(\\rho E - \\tfrac{1}{2}\\rho u^{2}\\right)$ 给出。物理通量函数为 $F(U) = \\left(\\rho u, \\rho u^{2} + p, u(\\rho E + p)\\right)^{\\mathsf{T}}$。在一个由 $i$ 索引、间距为 $\\Delta x$ 的均匀网格上，将单元 $i$ 的半离散有限体积残差定义为 $R_{i}(U) = \\frac{1}{\\Delta x}\\left(\\hat{F}_{i+\\tfrac{1}{2}} - \\hat{F}_{i-\\tfrac{1}{2}}\\right)$，其中 $\\hat{F}_{i+\\tfrac{1}{2}}$ 是根据界面 $i+\\tfrac{1}{2}$ 处的左右状态计算得到的相容数值通量。对欧拉方程使用 Local Lax–Friedrichs (LLF) 迎风数值通量，其对于具有左状态 $U_{L}$ 和右状态 $U_{R}$ 的界面定义为\n$$\n\\hat{F}(U_{L}, U_{R}) = \\frac{1}{2}\\left(F(U_{L}) + F(U_{R})\\right) - \\frac{1}{2}\\alpha(U_{L}, U_{R})\\left(U_{R} - U_{L}\\right),\n$$\n其中 $\\alpha(U_{L}, U_{R})$ 是在 $(U_{L}, U_{R})$ 处求值的通量雅可比矩阵的谱半径的任意上界，例如 $\\alpha(U_{L}, U_{R}) = \\max\\left(|u_{L}| + a_{L}, |u_{R}| + a_{R}\\right)$，声速为 $a = \\sqrt{\\gamma p / \\rho}$。 \n\n任务：\n- 从守恒形式和 LLF 通量定义出发，在均匀网格上用 $(U_{i-1}, U_{i}, U_{i+1})$、$F(\\cdot)$ 和 $\\alpha(\\cdot,\\cdot)$ 显式地写出 $R_{i}(U)$。\n- 对 $R_{i}(U)$ 围绕一个均匀常数状态 $U^{\\ast}$（即，对所有 $j$，$U_{j} \\equiv U^{\\ast}$）进行一阶线性化，假设耗散系数冻结在其常数值 $\\alpha^{\\ast} = \\alpha(U^{\\ast}, U^{\\ast})$。将在 $U^{\\ast}$ 处的物理通量雅可比矩阵记为 $A^{\\ast} = \\partial F/\\partial U \\big|_{U^{\\ast}}$。用 $A^{\\ast}$、$\\alpha^{\\ast}$ 和 $\\Delta x$ 推导块三对角雅可比矩阵贡献 $\\partial R_{i}/\\partial U_{i-1}$、$\\partial R_{i}/\\partial U_{i}$ 和 $\\partial R_{i}/\\partial U_{i+1}$，并验证常数扰动下的离散守恒性质。\n- 对均匀常数状态 $U^{\\ast}$ 计算 $R_{i}(U^{\\ast})$，并使用 $\\mathrm{pmatrix}$ 环境将结果表示为一个单行的 3 分量行矩阵。 \n\n无需进行数值代入。本问题属于计算流体动力学（CFD）实践范畴，旨在将守恒律与非线性残差的线性化联系起来。你的最终答案必须是按要求以符号形式表示的计算出的残差向量 $R_{i}(U^{\\ast})$，无单位。",
            "solution": "该问题提出了关于一维可压缩欧拉方程的半离散有限体积残差的三个任务。我们将依次解决每个任务。\n\n**任务1：残差 $R_i(U)$ 的显式形式**\n\n在一个间距为 $\\Delta x$ 的均匀网格上，对于索引为 $i$ 的单元，其半离散残差定义为：\n$$\nR_{i}(U) = \\frac{1}{\\Delta x}\\left(\\hat{F}_{i+\\tfrac{1}{2}} - \\hat{F}_{i-\\tfrac{1}{2}}\\right)\n$$\n对于一阶空间格式，单元 $i$ 和 $i+1$ 之间界面 $i+\\frac{1}{2}$ 处的数值通量 $\\hat{F}_{i+\\frac{1}{2}}$ 是单元平均状态 $U_i$ 和 $U_{i+1}$ 的函数。类似地，单元 $i-1$ 和 $i$ 之间界面 $i-\\frac{1}{2}$ 处的通量 $\\hat{F}_{i-\\frac{1}{2}}$ 是 $U_{i-1}$ 和 $U_i$ 的函数。\n\n所给的 Local Lax–Friedrichs (LLF) 数值通量定义为：\n$$\n\\hat{F}(U_{L}, U_{R}) = \\frac{1}{2}\\left(F(U_{L}) + F(U_{R})\\right) - \\frac{1}{2}\\alpha(U_{L}, U_{R})\\left(U_{R} - U_{L}\\right)\n$$\n其中 $F(\\cdot)$ 是物理通量函数，$\\alpha(\\cdot, \\cdot)$ 是耗散系数。\n\n对于界面 $i+\\frac{1}{2}$，其左、右状态分别为 $U_L = U_i$ 和 $U_R = U_{i+1}$。相应的数值通量为：\n$$\n\\hat{F}_{i+\\tfrac{1}{2}} = \\hat{F}(U_i, U_{i+1}) = \\frac{1}{2}\\left(F(U_i) + F(U_{i+1})\\right) - \\frac{1}{2}\\alpha(U_i, U_{i+1})\\left(U_{i+1} - U_i\\right)\n$$\n对于界面 $i-\\frac{1}{2}$，其左、右状态分别为 $U_L = U_{i-1}$ 和 $U_R = U_i$。相应的数值通量为：\n$$\n\\hat{F}_{i-\\tfrac{1}{2}} = \\hat{F}(U_{i-1}, U_i) = \\frac{1}{2}\\left(F(U_{i-1}) + F(U_i)\\right) - \\frac{1}{2}\\alpha(U_{i-1}, U_i)\\left(U_i - U_{i-1}\\right)\n$$\n将这些表达式代入残差 $R_i(U)$ 的定义中，我们得到它作为三单元模板 $(U_{i-1}, U_i, U_{i+1})$ 中状态的函数的显式形式：\n$$\nR_{i}(U) = \\frac{1}{\\Delta x} \\left[ \\left(\\frac{1}{2}\\left(F(U_i) + F(U_{i+1})\\right) - \\frac{1}{2}\\alpha(U_i, U_{i+1})\\left(U_{i+1} - U_i\\right)\\right) - \\left(\\frac{1}{2}\\left(F(U_{i-1}) + F(U_i)\\right) - \\frac{1}{2}\\alpha(U_{i-1}, U_i)\\left(U_i - U_{i-1}\\right)\\right) \\right]\n$$\n该表达式可以通过合并同类项进行简化：\n$$\nR_{i}(U) = \\frac{F(U_{i+1}) - F(U_{i-1})}{2\\Delta x} - \\frac{1}{2\\Delta x} \\left[ \\alpha(U_i, U_{i+1})\\left(U_{i+1} - U_i\\right) - \\alpha(U_{i-1}, U_i)\\left(U_i - U_{i-1}\\right) \\right]\n$$\n\n**任务2：$R_i(U)$ 的线性化与守恒性验证**\n\n现在，我们围绕一个均匀常数状态 $U^*$ 对 $R_i(U)$ 进行线性化，其中对所有单元索引 $j$，$U_j \\equiv U^*$。问题指明，对于该均匀状态，耗散系数 $\\alpha$ 应“冻结”在其常数值上：$\\alpha(U_L, U_R) \\approx \\alpha(U^*, U^*) \\equiv \\alpha^*$。这意味着不考虑 $\\alpha$ 的导数。设 $A^* = \\frac{\\partial F}{\\partial U}\\big|_{U^*}$ 为状态 $U^*$ 处的物理通量雅可比矩阵。\n\n在冻结系数近似下，残差表达式简化为：\n$$\nR_{i}(U) \\approx \\frac{1}{2\\Delta x} \\left[ F(U_{i+1}) - F(U_{i-1}) - \\alpha^*\\left((U_{i+1} - U_i) - (U_i - U_{i-1})\\right) \\right]\n$$\n$$\nR_{i}(U) \\approx \\frac{1}{2\\Delta x} \\left[ F(U_{i+1}) - F(U_{i-1}) - \\alpha^*\\left(U_{i+1} - 2U_i + U_{i-1}\\right) \\right]\n$$\n我们计算 $R_i$ 关于 $U_{i-1}$、$U_i$ 和 $U_{i+1}$ 的偏导数。为了求导，我们使用恒等式 $\\frac{\\partial F(U_j)}{\\partial U_k}\\big|_{U^*} = \\delta_{jk} A^*$，其中 $\\delta_{jk}$ 是克罗内克 δ 符号。\n\n来自 $U_{i-1}$ 的雅可比贡献为：\n$$\n\\frac{\\partial R_i}{\\partial U_{i-1}}\\bigg|_{U^*} = \\frac{1}{2\\Delta x} \\left[ -\\frac{\\partial F(U_{i-1})}{\\partial U_{i-1}}\\bigg|_{U^*} - \\alpha^*(1) \\frac{\\partial U_{i-1}}{\\partial U_{i-1}}\\bigg|_{U^*} \\right] = \\frac{1}{2\\Delta x} \\left[ -A^* - \\alpha^* I \\right]\n$$\n其中 $I$ 是 $3 \\times 3$ 单位矩阵。\n\n来自 $U_{i+1}$ 的雅可比贡献为：\n$$\n\\frac{\\partial R_i}{\\partial U_{i+1}}\\bigg|_{U^*} = \\frac{1}{2\\Delta x} \\left[ \\frac{\\partial F(U_{i+1})}{\\partial U_{i+1}}\\bigg|_{U^*} - \\alpha^* (1) \\frac{\\partial U_{i+1}}{\\partial U_{i+1}}\\bigg|_{U^*} \\right] = \\frac{1}{2\\Delta x} \\left[ A^* - \\alpha^* I \\right]\n$$\n来自 $U_{i}$ 的雅可比贡献为：\n$$\n\\frac{\\partial R_i}{\\partial U_{i}}\\bigg|_{U^*} = \\frac{1}{2\\Delta x} \\left[ - \\alpha^*(-2) \\frac{\\partial U_i}{\\partial U_i}\\bigg|_{U^*} \\right] = \\frac{1}{2\\Delta x} \\left[ 2\\alpha^* I \\right] = \\frac{\\alpha^*}{\\Delta x} I\n$$\n为了验证常数扰动下的离散守恒性质，我们将单元 $i$ 在其模板上的雅可比贡献相加：\n$$\n\\sum_{j} \\frac{\\partial R_i}{\\partial U_j} = \\frac{\\partial R_i}{\\partial U_{i-1}} + \\frac{\\partial R_i}{\\partial U_i} + \\frac{\\partial R_i}{\\partial U_{i+1}}\n$$\n$$\n= \\frac{1}{2\\Delta x} \\left( -A^* - \\alpha^* I \\right) + \\frac{\\alpha^*}{\\Delta x} I + \\frac{1}{2\\Delta x} \\left( A^* - \\alpha^* I \\right)\n$$\n$$\n= \\frac{1}{2\\Delta x} \\left[ -A^* - \\alpha^* I + 2\\alpha^* I + A^* - \\alpha^* I \\right]\n$$\n$$\n= \\frac{1}{2\\Delta x} \\left[ (-A^* + A^*) + (-\\alpha^* + 2\\alpha^* - \\alpha^*)I \\right] = 0\n$$\n和为零矩阵，这证实了离散守恒性质。\n\n**任务3：$R_i(U^*)$ 的求值**\n\n最后，我们对均匀常数状态 $U^*$ 计算残差 $R_i(U)$，其中 $U_{j} = U^*$ 对 $j \\in \\{i-1, i, i+1\\}$ 成立。\n我们从定义开始：\n$$\nR_i(U^*) = \\frac{1}{\\Delta x}\\left(\\hat{F}_{i+\\tfrac{1}{2}} - \\hat{F}_{i-\\tfrac{1}{2}}\\right)\n$$\n界面 $i+\\frac{1}{2}$ 处的数值通量具有相同的左、右状态，$U_L=U_R=U^*$：\n$$\n\\hat{F}_{i+\\tfrac{1}{2}} = \\hat{F}(U^*, U^*) = \\frac{1}{2}\\left(F(U^*) + F(U^*)\\right) - \\frac{1}{2}\\alpha(U^*, U^*)\\left(U^* - U^*\\right)\n$$\n$$\n\\hat{F}_{i+\\tfrac{1}{2}} = \\frac{1}{2}\\left(2F(U^*)\\right) - 0 = F(U^*)\n$$\n这是数值通量的相容性：$\\hat{F}(U, U) = F(U)$。\n根据同样的方法，界面 $i-\\frac{1}{2}$ 处的数值通量也是 $F(U^*)$：\n$$\n\\hat{F}_{i-\\tfrac{1}{2}} = \\hat{F}(U^*, U^*) = F(U^*)\n$$\n将这些代回残差表达式：\n$$\nR_i(U^*) = \\frac{1}{\\Delta x} \\left[ F(U^*) - F(U^*) \\right] = \\frac{1}{\\Delta x} (0) = 0\n$$\n结果是维度为 3 的零向量。这是一个被称为自由流保持的基本相容性要求：均匀流必须产生零残差，表明它是离散方程的一个稳态解。该结果表示为一个 3 分量行矩阵，即 $(0, 0, 0)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  & 0 & 0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在计算实践中，雅可比矩阵的组装过程极易出错，而错误可能非常微妙。这项练习将挑战你设计稳健的诊断测试，以验证雅可比矩阵实现的正确性。通过评估基于方向有限差分的多种验证策略，你将学会甄别严谨可靠的方法与看似合理但存在缺陷的权宜之计，这是开发可信赖CFD求解器的关键技能。",
            "id": "3973424",
            "problem": "考虑一个稳态残差算子 $R(\\mathbf{U}) \\in \\mathbb{R}^{N}$，它来自于某航空航天构型的可压缩Navier-Stokes方程的有限体积离散化，其中 $\\mathbf{U} \\in \\mathbb{R}^{N}$ 汇集了所有控制体上的全部守恒变量。在一个牛顿类求解器中，组装的雅可比矩阵 $\\mathbf{J}(\\mathbf{U}) \\in \\mathbb{R}^{N \\times N}$ 旨在表示线性化结果 $\\mathbf{J}(\\mathbf{U}) = \\partial R / \\partial \\mathbf{U}$。您的任务是设计基于方向有限差分的诊断测试，通过将 $\\mathbf{J}\\mathbf{v}$ 与沿测试方向 $\\mathbf{v}$ 的 $R$ 在 $\\mathbf{U}$ 处的方向导数的独立近似值进行比较，来验证 $\\mathbf{J}$ 的正确性。\n\n请采用以下科学上现实的背景和约束，这些背景和约束与非线性代数系统的标准牛顿线性化方法一致：\n- 残差 $R$ 包括使用 Roe 近似黎曼求解器并辅以光滑熵修正计算的无粘数值通量、使用二阶中心梯度计算的粘性通量，以及一个带有连续正则化参数 $\\delta > 0$ 的斜率限制器，该限制器用于平滑极值（例如，Venkatakrishnan 型光滑限制器）。\n- 计算以双精度进行，机器精度表示为 $ \\varepsilon_{\\text{mach}} \\approx 2.22 \\times 10^{-16} $。\n- 诊断工作流程必须依赖方向差分，而不是构造稠密的有限差分雅可比矩阵，并且必须适用于航空航天计算流体动力学（CFD）典型的大型网格。\n\n在当前CFD残差背景下，下列哪项提议的测试在理论上是可靠的、适定的，并且可能检测出 $\\mathbf{J}$ 中的组装错误？选择所有适用项。\n\nA. 对于多个随机选取的方向 $\\mathbf{v}$（满足 $\\lVert \\mathbf{v} \\rVert_{2} = 1$），使用一系列与状态量大小成比例的步长 $h$（例如，$h = \\sqrt{\\varepsilon_{\\text{mach}}} \\, \\max\\{ 1, \\lVert \\mathbf{U} \\rVert_{2} \\}$ 及其附近的值），计算中心有限差分方向导数 $D_{h}(\\mathbf{v}) = \\left[ R(\\mathbf{U} + h \\mathbf{v}) - R(\\mathbf{U} - h \\mathbf{v}) \\right] / (2h)$。评估在不同 $h$ 值下的相对 $2$-范数差异 $\\eta(\\mathbf{v}, h) = \\lVert \\mathbf{J}\\mathbf{v} - D_{h}(\\mathbf{v}) \\rVert_{2} / \\left( \\lVert \\mathbf{J}\\mathbf{v} \\rVert_{2} + \\lVert D_{h}(\\mathbf{v}) \\rVert_{2} \\right)$，并验证随着 $h$ 的变化，$\\eta$ 表现出在 $O(h^{2})$ 附近的截断误差平台，随后是在 $O(\\varepsilon_{\\text{mach}}/h)$ 附近的舍入误差增长。\n\nB. 在解析性条件下，使用复步长方向导数：对于方向 $\\mathbf{v}$ 和足够小的步长 $h$，计算 $\\operatorname{Im}\\!\\left[ R(\\mathbf{U} + i h \\mathbf{v}) \\right]/h$ 并与 $\\mathbf{J}\\mathbf{v}$ 进行相对范数比较。将此测试限制在所有残差分量在 $\\mathbf{U}$ 中都是复解析的构型上（例如，光滑熵修正、具有足够大的 $\\delta$ 以避免不可微扭结的光滑斜率限制器），并预期在解析性成立时，两者的一致性可达到接近机器精度的水平。\n\nC. 使用固定步长 $h = 10^{-2}$（以状态量为单位）的前向差分计算 $F_{h}(\\mathbf{v}) = \\left[ R(\\mathbf{U} + h \\mathbf{v}) - R(\\mathbf{U}) \\right]/h$，如果对于单个随机选择的方向 $\\mathbf{v}$，满足 $\\lVert \\mathbf{J}\\mathbf{v} - F_{h}(\\mathbf{v}) \\rVert_{2} \\le 0.01$，则宣布 $\\mathbf{J}$ 正确，并论证 1% 的绝对差异对于航空航天 CFD 而言足够小。\n\nD. 通过将 $\\mathbf{J}^{\\top}\\mathbf{v}$ 与随机方向 $\\mathbf{v}$ 的中心有限差分方向导数 $D_{h}(\\mathbf{v})$ 进行比较来验证 $\\mathbf{J}$，理由是沿 $\\mathbf{v}$ 的方向导数可以同等地由 $\\mathbf{J}\\mathbf{v}$ 或 $\\mathbf{J}^{\\top}\\mathbf{v}$ 表示。\n\nE. 结合使用随机单位方向和坐标对齐方向：采样几个独立的随机单位向量 $\\mathbf{v}$，并同时使用标准基向量 $\\mathbf{e}_{k}$（$k = 1, \\dots, N$）来探测单个自由度。对每个 $\\mathbf{v}$，选择能够平衡截断误差和舍入误差的步长 $h$ 来评估一个缩放的中心有限差分 $D_{h}(\\mathbf{v})$，并且仅当 $\\max_{\\mathbf{v}} \\eta(\\mathbf{v}, h)$ 低于预设容差且表现出预期的 $h$-依赖性时，才接受该雅可比矩阵。这种方法旨在检测可能对少量随机方向不可见的索引、符号和边界条件组装错误。\n\nF. 为节省计算量，仅扰动外部边界条件参数（例如，入口马赫数和静压），并将 $R(\\mathbf{U} + h \\mathbf{v}_{\\text{bc}}) - R(\\mathbf{U})$ 与 $\\mathbf{J}\\mathbf{v}_{\\text{bc}}$ 进行比较，其中 $\\mathbf{v}_{\\text{bc}}$ 将所有内部状态分量置零。如果观察到这些边界扰动的一致性，则推断整个内部雅可比矩阵是正确的。\n\n选择代表基于方向导数数学原理和航空航天 CFD 线性化的实用数值分析的有效诊断测试的选项。可能有一个以上的正确选项。请仅使用正确选项的大写字母提供您的最终选择。",
            "solution": "问题陈述在计算流体动力学（CFD）和数值分析领域提出了一个有效且有科学依据的问题。它要求评估几种提议的诊断测试，以验证与非线性残差向量 $R(\\mathbf{U})$ 相关联的计算雅可比矩阵 $\\mathbf{J}$ 的正确性。所提供的背景——可压缩Navier-Stokes方程、有限体积法、特定的通量和限制器格式——是现实且明确的。该问题是客观、自洽且适定的。因此，我们可以着手求解。\n\n雅可比矩阵验证的基本原理是雅可比-向量积 $\\mathbf{J}\\mathbf{v}$ 与残差函数 $R$ 在状态 $\\mathbf{U}$ 处沿方向向量 $\\mathbf{v}$ 的方向导数之间的关系。如果 $R$ 在 $\\mathbf{U}$ 处可微，其关于 $\\mathbf{U}$ 的泰勒级数展开为：\n$$ R(\\mathbf{U} + \\mathbf{\\delta U}) = R(\\mathbf{U}) + \\frac{\\partial R}{\\partial \\mathbf{U}}\\bigg|_{\\mathbf{U}} \\mathbf{\\delta U} + O(\\lVert \\mathbf{\\delta U} \\rVert^2) $$\n对于标量步长 $h$ 和方向向量 $\\mathbf{v}$，设扰动为 $\\mathbf{\\delta U} = h\\mathbf{v}$，则方向导数定义为：\n$$ D_{\\mathbf{v}}R(\\mathbf{U}) = \\lim_{h \\to 0} \\frac{R(\\mathbf{U} + h\\mathbf{v}) - R(\\mathbf{U})}{h} $$\n对于一个可微函数，此极限恰好是雅可比-向量积：\n$$ D_{\\mathbf{v}}R(\\mathbf{U}) = \\mathbf{J}(\\mathbf{U})\\mathbf{v} $$\n验证测试的工作原理是通过将解析计算或组装的 $\\mathbf{J}\\mathbf{v}$ 与通过 $R$ 的有限差分获得的方向导数的数值近似进行比较。问题陈述正确地指出，由于使用了光滑熵修正和平滑化的斜率限制器，残差是可微的。\n\n我们现在将分析每个提议的测试。\n\n**选项 A 分析**\n\n此选项建议使用中心有限差分格式来近似方向导数：\n$$ D_{h}(\\mathbf{v}) = \\frac{R(\\mathbf{U} + h \\mathbf{v}) - R(\\mathbf{U} - h \\mathbf{v})}{2h} $$\n$R(\\mathbf{U} + h\\mathbf{v})$ 和 $R(\\mathbf{U} - h\\mathbf{v})$ 的三阶泰勒级数展开为：\n$$ R(\\mathbf{U} \\pm h\\mathbf{v}) = R(\\mathbf{U}) \\pm h\\mathbf{J}\\mathbf{v} + \\frac{h^2}{2}\\mathbf{H}[\\mathbf{v},\\mathbf{v}] \\pm \\frac{h^3}{6}\\mathbf{T}[\\mathbf{v},\\mathbf{v},\\mathbf{v}] + O(h^4) $$\n其中 $\\mathbf{H}$ 和 $\\mathbf{T}$ 分别是二阶和三阶导数张量。将这些代入中心差分公式可得：\n$$ D_h(\\mathbf{v}) = \\mathbf{J}\\mathbf{v} + \\frac{h^2}{6}\\mathbf{T}[\\mathbf{v},\\mathbf{v},\\mathbf{v}] + O(h^4) $$\n该近似的截断误差为 $O(h^2)$。在有限精度算法中，还存在来自两个相近数值相减的舍入误差，其量级为 $\\varepsilon_{\\text{mach}} / h$。因此，总误差约为 $\\approx C_1 h^2 + C_2 \\varepsilon_{\\text{mach}}/h$。一个关键的验证程序是计算一系列递减 $h$ 值的差异 $\\eta(\\mathbf{v}, h)$，并将其绘制在对数-对数坐标图上。一个正确实现的雅可比矩阵将产生一条曲线，该曲线最初以斜率 $2$ 下降（$O(h^2)$ 截断误差区域），然后以斜率 $-1$ 上升（$O(1/h)$ 舍入误差区域）。这种特征行为是正确性的一个稳健指标。使用多个随机方向可确保对雅可比矩阵正确性的统计采样。提议的步长 $h \\sim \\sqrt{\\varepsilon_{\\text{mach}}}$ 是一阶前向差分的最优选择，而对于二阶中心差分，最优步长更接近 $\\varepsilon_{\\text{mach}}^{1/3}$。然而，这只是一个次要问题，因为该提议正确地主张在 *一系列* 步长上评估差异，这才是该程序的关键部分。\n\n结论：**正确**。这是一种标准、稳健且理论上可靠的验证方法。\n\n**选项 B 分析**\n\n此选项建议使用复步长导数近似：\n$$ \\frac{\\operatorname{Im}\\!\\left[ R(\\mathbf{U} + i h \\mathbf{v}) \\right]}{h} $$\n如果函数 $R$ 可以延拓为一个复解析函数 $R(z)$，其在实点 $\\mathbf{U}$ 处对复扰动 $ih\\mathbf{v}$ 的泰勒级数为：\n$$ R(\\mathbf{U} + i h \\mathbf{v}) = R(\\mathbf{U}) + i h \\mathbf{J}\\mathbf{v} - \\frac{h^2}{2}\\mathbf{H}[\\mathbf{v},\\mathbf{v}] - i\\frac{h^3}{6}\\mathbf{T}[\\mathbf{v},\\mathbf{v},\\mathbf{v}] + O(h^4) $$\n取虚部并除以 $h$ 可得：\n$$ \\frac{\\operatorname{Im}\\!\\left[ R(\\mathbf{U} + i h \\mathbf{v}) \\right]}{h} = \\mathbf{J}\\mathbf{v} - \\frac{h^2}{6}\\mathbf{T}[\\mathbf{v},\\mathbf{v},\\mathbf{v}] + O(h^4) $$\n截断误差为 $O(h^2)$，与中心差分相同。然而，关键在于，该公式不涉及两个相近数值的相减。因此，它不受减法抵消舍入误差的影响。主要误差是机器精度水平的数值噪声，即 $\\varepsilon_{\\text{mach}}$。对于足够小的 $h$，该方法可以以接近机器精度的准确度近似方向导数。该提议正确地指出，此测试取决于残差分量的复解析性。问题陈述的背景，包括“光滑熵修正”和“带有 $\\delta > 0$ 的光滑斜率限制器”，是特意设计来允许这种解析延拓的，因为这些特性用光滑、可微的对应物（例如，用 $\\sqrt{\\lambda^2+\\epsilon^2}$ 代替 $|\\lambda|$）替换了诸如 `abs()` 或 `min()`/`max()` 之类的非解析函数。\n\n结论：**正确**。这是一种高度准确且功能强大的验证方法，在残差函数满足指定属性的情况下适用。\n\n**选项 C 分析**\n\n这个提议有严重缺陷。首先，使用单一、固定的步长 $h = 10^{-2}$ 是不可靠的。有限差分近似的精度对 $h$ 高度敏感。如果不通过对 $h$ 进行扫描来观察收敛速率，就无法区分正确的雅可比矩阵和一个恰好在某个特定 $h$ 值上误差较小的错误矩阵。其次，对于高维系统，使用单个随机方向 $\\mathbf{v}$ 进行测试在统计上是不充分的，因为它可能无法激发与错误雅可比矩阵条目相对应的模式。第三，容差 $\\lVert \\mathbf{J}\\mathbf{v} - F_{h}(\\mathbf{v}) \\rVert_{2} \\le 0.01$ 是任意的。预期的误差取决于 $R$ 的高阶导数的大小，而这是与问题相关的。一个正确的测试应该验证收敛的*速率*，而不是遵守一个任意的阈值。\n\n结论：**不正确**。此方法是临时的、不可靠的，并且不是一个适定的诊断测试。\n\n**选项 D 分析**\n\n该选项建议将中心差分导数（$\\mathbf{J}\\mathbf{v}$ 的一个近似）与量 $\\mathbf{J}^{\\top}\\mathbf{v}$ 进行比较。这是基于一个错误的前提，即认为 $\\mathbf{J}\\mathbf{v}$ 和 $\\mathbf{J}^{\\top}\\mathbf{v}$ 是方向导数的等价表示。向量 $\\mathbf{J}\\mathbf{v}$ 是雅可比矩阵对 $\\mathbf{v}$ 的作用，而 $\\mathbf{J}^{\\top}\\mathbf{v}$ 是伴随（转置）算子对 $\\mathbf{v}$ 的作用。通常，对于非对称矩阵 $\\mathbf{J}$，$\\mathbf{J}\\mathbf{v} \\neq \\mathbf{J}^{\\top}\\mathbf{v}$。由包含一阶导数对流项的流体动力学方程离散化产生的雅可比矩阵几乎总是不对称的。因此，这个测试比较的是两个根本不同的量。\n\n结论：**不正确**。此测试基于一个关于雅可比矩阵及其转置性质的重大数学错误。\n\n**选项 E 分析**\n\n该选项提出了一种混合策略来选择测试方向 $\\mathbf{v}$，即结合随机向量和标准基向量 $\\mathbf{e}_k$。它正确地主张使用中心差分并分析误差对 $h$ 的依赖性以验证收敛速率，与选项 A 一样。包含标准基向量是一个显著的增强。当 $\\mathbf{v} = \\mathbf{e}_k$ 时，乘积 $\\mathbf{J}\\mathbf{v}$ 变为 $\\mathbf{J}\\mathbf{e}_k$，即雅可比矩阵的第 $k$ 列。相应的有限差分 $\\left[ R(\\mathbf{U} + h \\mathbf{e}_k) - R(\\mathbf{U} - h \\mathbf{e}_k) \\right] / (2h)$ 提供了对这个特定列的直接且准确的近似。这允许对与单个自由度相关的雅可比矩阵条目进行有针对性的验证，这对于调试特定的实现错误（如索引错误、符号错误或边界条件项的不正确构建）极为有效。全局统计检查（随机向量）和特定目标检查（基向量）的结合构成了一个全面而稳健的验证策略。\n\n结论：**正确**。这代表了一种结合了随机抽样和针对性探测优点的最佳实践、全面的方法。\n\n**选项 F 分析**\n\n该选项建议仅扰动边界条件参数，并且如果由此产生的雅可比作用与残差的变化相匹配，就推断整个雅可比矩阵是正确的。测试本身——扰动边界值并检查响应——是验证与边界条件相关的雅可比矩阵特定行和列的有效方法。然而，提议的推论是不合逻辑的（non sequitur）。内部单元的残差方程依赖于相邻内部单元的状态。表示这些内部-内部耦合的雅可比矩阵条目（对于内部单元 $i, j$ 的 $\\partial R_i / \\partial \\mathbf{U}_j$）的正确性，无法通过在区域内部为零的扰动来评估。这样的测试将完全无法发现内部通量雅可比矩阵离散化中的错误。\n\n结论：**不正确**。该测试过于狭隘，并且从中得出的结论是一个无效的推断。\n\n**总结**\n\n选项 A、B 和 E 描述了用于验证 CFD 雅可比矩阵的理论上可靠、适定且实践上有效的方法。选项 A 是一个可靠的基准测试。选项 B 是针对解析函数的高精度方法。选项 E 代表了一种结合了全局和局部测试的综合性“最佳实践”。选项 C、D 和 F 因糟糕的数值实践、数学错误或无效的逻辑推断而存在缺陷。",
            "answer": "$$\\boxed{ABE}$$"
        },
        {
            "introduction": "虽然精确的雅可比矩阵能确保牛顿法具有理想的二次收敛性，但实际的求解器为了效率常常采用近似方法。这项编程练习让你能够直接观察并量化这些近似所带来的影响。通过为一个跨音速流动问题实现一个使用精确、近似及冻结雅可比矩阵的牛顿求解器，你将用数值方法衡量线性化精度如何影响收敛速度，从而对其中的权衡有一个切实的理解。",
            "id": "3973418",
            "problem": "考虑在跨声速区中，环绕翼型的细流管内的稳定、无粘、等熵、可压缩流动。在计算流体动力学（CFD）中，此类流动的离散化残差可以根据从质量守恒和等熵热力学中得到的面积-马赫数关系来构建。从基本定律出发，稳定一维流管的质量守恒意味着 $ \\rho U A = \\text{constant} $，其中 $ \\rho $ 是密度，$ U $ 是轴向速度，$ A $ 是局部横截面积。在等熵条件下，压力-密度关系 $ p/\\rho^\\gamma = \\text{constant} $ 成立，其中 $ \\gamma $ 是比热比。将这些结合起来，得到可压缩面积-马赫数关系，\n$$\n\\frac{A}{A^\\ast}(M) \\;=\\; \\frac{1}{M}\\left(\\frac{2}{\\gamma+1}\\left(1+\\frac{\\gamma-1}{2}M^2\\right)\\right)^{\\frac{\\gamma+1}{2(\\gamma-1)}},\n$$\n其中 $ M $ 是马赫数，$ A^\\ast $ 是声速面积。该关系对 $ M > 0 $ 有效，在 $ M = 1 $ 时有最小值 $ A/A^\\ast = 1 $，并在 $ A/A^\\ast > 1 $ 时产生两个分支（亚声速和超声速）。在跨声速翼型的情况下，沿表面坐标 $ s \\in [0,1] $ 的光滑马赫数场 $ M(s) $ 将在 $ M \\approx 1 $ 附近穿过。\n\n将均匀间隔节点 $ s_i \\in [0,1] $ 上的节点马赫数向量 $ \\mathbf{m} = (m_1,\\dots,m_N) $ 的非线性残差定义为\n$$\nR_i(\\mathbf{m}) \\;=\\; \\frac{A}{A^\\ast}(m_i) \\;-\\; \\frac{A}{A^\\ast}(M_{\\text{true}}(s_i)),\n$$\n其中 $ M_{\\text{true}}(s) $ 是一个给定的光滑跨声速目标场，\n$$\nM_{\\text{true}}(s) \\;=\\; 0.8 \\;+\\; 0.4 \\exp\\!\\left(-\\frac{(s-0.6)^2}{(0.05)^2}\\right),\n$$\n且 $ \\gamma = 1.4 $。根据构造，$ R_i(\\mathbf{m})=0 $ 的精确解是 $ m_i = M_{\\text{true}}(s_i) $。设初始猜测为\n$$\nm_i^{(0)} \\;=\\; M_{\\text{true}}(s_i) \\;+\\; \\delta \\sin(2\\pi s_i), \\quad \\delta = 0.02.\n$$\n\n牛顿法更新 $ \\mathbf{m}^{(k+1)} = \\mathbf{m}^{(k)} - \\mathbf{J}(\\mathbf{m}^{(k)})^{-1}\\mathbf{R}(\\mathbf{m}^{(k)}) $，其中 $ \\mathbf{J} $ 是雅可比矩阵，其元素为 $ J_{ij} = \\partial R_i / \\partial m_j $。由于 $ R_i $ 仅依赖于 $ m_i $，$ \\mathbf{J} $ 是对角矩阵，其对角元素为 $ J_{ii} = \\frac{d}{dM}\\left(\\frac{A}{A^\\ast}(M)\\right)\\big|_{M=m_i} $。可以通过用近似值替换精确导数来改变线性化精度：\n- 精确雅可比矩阵：$ J_{ii} = \\left(\\frac{A}{A^\\ast}\\right)^\\prime(m_i^{(k)}) $。\n- 有限差分雅可比矩阵：$ J_{ii} \\approx \\dfrac{\\frac{A}{A^\\ast}(m_i^{(k)}+\\epsilon) - \\frac{A}{A^\\ast}(m_i^{(k)})}{\\epsilon} $，其中 $ \\epsilon > 0 $ 为指定值。\n- 冻结雅可比矩阵：$ J_{ii} $ 在 $ m_i^{(0)} $ 处计算一次，并在所有迭代中保持不变。\n\n将第 $ k $ 次迭代的全局误差定义为无穷范数\n$$\ne^{(k)} \\;=\\; \\left\\|\\mathbf{m}^{(k)} - \\mathbf{M}_{\\text{true}}\\right\\|_\\infty.\n$$\n使用三次连续误差通过\n$$\np \\;\\approx\\; \\frac{\\ln\\!\\left(e^{(k+1)}/e^{(k)}\\right)}{\\ln\\!\\left(e^{(k)}/e^{(k-1)}\\right)},\n$$\n来估计观测收敛率 $ p $，该值是在固定的总迭代次数后，根据最后三次迭代计算得出。\n\n您的任务是实现一个程序，该程序：\n1. 在 $ [0,1] $ 区间内均匀构建 $ N = 200 $ 个节点 $ s_i $。\n2. 如上所述，建立 $ M_{\\text{true}}(s_i) $、残差 $ R_i(\\mathbf{m}) $ 并初始化 $ \\mathbf{m}^{(0)} $。\n3. 使用以下各种雅可比矩阵线性化策略，运行固定次数（使用 $ 8 $ 次迭代）的牛顿迭代：\n   - 精确雅可比矩阵。\n   - 有限差分雅可比矩阵，其中 $ \\epsilon = 10^{-6} $。\n   - 有限差分雅可比矩阵，其中 $ \\epsilon = 10^{-3} $。\n   - 从初始猜测中获取的冻结雅可比矩阵。\n4. 对于每种策略，使用最后三个误差 $ e^{(k)} $ 计算观测收敛率 $ p $。\n5. 将四个 $ p $ 值汇总到一个列表中。\n\n测试套件：\n- 情况 $ 1 $：精确雅可比矩阵。\n- 情况 $ 2 $：有限差分雅可比矩阵，其中 $ \\epsilon = 10^{-6} $。\n- 情况 $ 3 $：有限差分雅可比矩阵，其中 $ \\epsilon = 10^{-3} $。\n- 情况 $ 4 $：从初始猜测中获取的冻结雅可比矩阵。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$ [p_1,p_2,p_3,p_4] $）。输出中的所有数字必须是不带单位的普通浮点数值。本问题不需要物理单位，所有量均为无量纲。本问题中不出现角度，也不使用百分比。",
            "solution": "该问题旨在解决一个由流体动力学问题离散化而产生的非线性方程组的数值解。具体来说，它关注的是寻找满足一组代数方程 $ \\mathbf{R}(\\mathbf{m}) = \\mathbf{0} $ 的马赫数分布 $ \\mathbf{m} $。\n\n**1. 物理和数学基础**\n问题的核心是一维可压缩流的等熵面积-马赫数关系：\n$$ \\frac{A}{A^\\ast}(M) = \\frac{1}{M}\\left(\\frac{2}{\\gamma+1}\\left(1+\\frac{\\gamma-1}{2}M^2\\right)\\right)^{\\frac{\\gamma+1}{2(\\gamma-1)}} $$\n该方程将局部流马赫数 $ M $ 与局部流管面积 $ A $ 和声速面积 $ A^\\ast $ 的比率联系起来。该问题为沿空间坐标 $ s $ 的 $ N $ 个离散点集合定义了一个非线性残差向量 $ \\mathbf{R} $。残差的第 $ i $ 个分量是：\n$$ R_i(\\mathbf{m}) = \\frac{A}{A^\\ast}(m_i) - \\frac{A}{A^\\ast}(M_{\\text{true}}(s_i)) $$\n这里，$ \\mathbf{m} = \\{m_i\\}_{i=1}^N $ 是未知节点马赫数的向量。项 $ \\frac{A}{A^\\ast}(M_{\\text{true}}(s_i)) $ 表示对应于已知精确解 $ \\mathbf{M}_{\\text{true}} $ 的面积比。目标是求解方程组 $ \\mathbf{R}(\\mathbf{m}) = \\mathbf{0} $，根据构造，其解为 $ m_i = M_{\\text{true}}(s_i) $。\n\n**2. 数值方法：牛顿-拉夫逊法**\n牛顿法是一种用于寻找非线性方程组根的迭代算法。给定一个初始猜测 $ \\mathbf{m}^{(k)} $，下一个迭代值 $ \\mathbf{m}^{(k+1)} $ 是通过求解残差在 $ \\mathbf{m}^{(k)} $ 附近的一阶泰勒展开所产生的线性系统来找到的：\n$$ \\mathbf{R}(\\mathbf{m}^{(k+1)}) \\approx \\mathbf{R}(\\mathbf{m}^{(k)}) + \\mathbf{J}(\\mathbf{m}^{(k)})(\\mathbf{m}^{(k+1)} - \\mathbf{m}^{(k)}) = \\mathbf{0} $$\n这导出了更新公式：\n$$ \\mathbf{m}^{(k+1)} = \\mathbf{m}^{(k)} - \\mathbf{J}(\\mathbf{m}^{(k)})^{-1}\\mathbf{R}(\\mathbf{m}^{(k)}) $$\n矩阵 $ \\mathbf{J} $ 是残差向量的雅可比矩阵，其元素为 $ J_{ij} = \\partial R_i / \\partial m_j $。在这个问题中，$ R_i $ 仅依赖于 $ m_i $，使得雅可比矩阵成为一个对角矩阵。其对角元素为：\n$$ J_{ii} = \\frac{d}{dM}\\left(\\frac{A}{A^\\ast}(M)\\right)\\bigg|_{M=m_i} $$\n解析地，这个导数可求得为：\n$$ \\left(\\frac{A}{A^\\ast}\\right)'(M) = \\frac{A}{A^\\ast}(M) \\frac{M^2-1}{M(1+\\frac{\\gamma-1}{2}M^2)} $$\n\n**3. 雅可比矩阵线性化策略与收敛性**\n研究的核心在于如何计算雅可比矩阵 $ \\mathbf{J} $，因为这会显著影响收敛率和计算成本。该问题评估了四种策略：\n\n- **精确雅可比矩阵**：使用解析导数可提供最精确的线性化。通常，对于单根，使用精确雅可比矩阵的牛顿法表现出二次收敛性，意味着误差 $ e^{(k+1)} $ 与 $ (e^{(k)})^2 $ 成正比，收敛率 $ p $ 为 $ 2 $。\n\n- **有限差分雅可比矩阵**：数值近似导数，例如 $ J_{ii} \\approx (\\frac{A}{A^\\ast}(m_i+\\epsilon) - \\frac{A}{A^\\ast}(m_i))/\\epsilon $，会引入一个 $ O(\\epsilon) $ 阶的近似误差。这通常会将收敛性降低到线性（$ p=1 $），此时每步的误差减少量变为常数。这种线性收敛的速度取决于 $ \\epsilon $ 的大小。\n\n- **冻结雅可比矩阵**：仅在初始猜测 $ \\mathbf{m}^{(0)} $ 处计算一次雅可比矩阵，并在所有后续迭代中重复使用它，这将牛顿法转换为一种准牛顿法（或弦截法）。这样可以避免重新计算雅可比矩阵的成本，但会将收敛率降低到线性（$ p=1 $）。\n\n**4. 跨声速奇点 ($ M=1 $)**\n这个问题的一个关键物理和数值特征是流动的跨声速特性，即马赫数会穿过 $ M=1 $。在 $ M=1 $ 处，导数 $ (A/A^\\ast)'(M) $ 为零。对于收敛到导数 $ J(m^*) $ 非零的根 $ m^* $ 的标准牛顿迭代，收敛是二次的。然而，如果 $ J(m^*) = 0 $，收敛会退化为线性，收敛因子为 $ 0.5 $，即 $ p=1 $。\n在这个问题中，精确解 $ \\mathbf{M}_{\\text{true}} $ 包含 $ M_{true}(s_i) \\approx 1 $ 的点。由无穷范数 $ e^{(k)} = \\max_i |m_i^{(k)} - M_{\\text{true}}(s_i)| $ 定义的全局误差将由收敛最慢的节点的误差主导。由于靠近 $ M=1 $ 的节点表现出线性收敛，而其他节点可能二次收敛，因此“精确雅可比矩阵”情况下的总体观测收敛率 $ p $ 预计将接近 $ 1 $，而不是 $ 2 $。其他策略本质上是线性的，因此也预计会得到 $ p \\approx 1 $。该实现将计算这些观测到的速率。\n\n**5. 实现步骤**\n该解决方案将使用 `numpy` 库在 Python 中实现。\n1.  定义常数 $ \\gamma, N, \\delta $ 和迭代次数。\n2.  将域 $ s \\in [0,1] $ 离散化为 $ N=200 $ 个节点。\n3.  实现 $ A/A^\\ast(M) $、其导数 $ (A/A^\\ast)'(M) $ 和目标场 $ M_{\\text{true}}(s) $ 的向量化函数。\n4.  计算精确解向量 $ \\mathbf{M}_{\\text{true}} $ 和初始猜测 $ \\mathbf{m}^{(0)} $。\n5.  遍历四种指定的雅可比矩阵策略。对于每种策略：\n    a. 将解向量初始化为 $ \\mathbf{m}^{(0)} $。\n    b. 运行牛顿迭代循环 $ 8 $ 步，在每一步存储误差的无穷范数。\n    c. 根据当前策略（精确、有限差分或冻结）计算雅可比矩阵元素 $ J_{ii} $。\n    d. 在每一步更新解向量 $ \\mathbf{m} $。\n6.  迭代结束后，使用最后三次迭代的误差（$ e^{(6)}, e^{(7)}, e^{(8)} $）为每种策略计算观测收敛率 $ p $。\n7.  将四个计算出的速率 $ p $ 收集到一个列表中，并按规定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nonlinear residual problem for transonic flow using Newton's method\n    with different Jacobian approximations and computes the observed convergence rates.\n    \"\"\"\n    \n    # --- 1. Problem Setup ---\n    N = 200\n    GAMMA = 1.4\n    DELTA = 0.02\n    NUM_ITER = 8\n    \n    # Spatial domain discretization\n    s = np.linspace(0, 1, N)\n\n    # --- 2. Core Physical and Mathematical Functions ---\n    \n    def A_A_star(M, gamma=GAMMA):\n        \"\"\"\n        Calculates the compressible area-Mach number relation A/A*.\n        Vectorized to operate on numpy arrays.\n        \"\"\"\n        # The function is not defined for M = 0, but our M range is safe.\n        M = np.maximum(M, 1e-9)\n\n        gp1 = gamma + 1.0\n        gm1 = gamma - 1.0\n        \n        term1 = 2.0 / gp1\n        term2 = 1.0 + (gm1 / 2.0) * M**2\n        exponent = gp1 / (2.0 * gm1)\n        \n        return (1.0 / M) * (term1 * term2)**exponent\n\n    def dA_A_star_dM(M, gamma=GAMMA):\n        \"\"\"\n        Calculates the exact derivative of the A/A* function with respect to M.\n        Vectorized to operate on numpy arrays.\n        \"\"\"\n        M = np.maximum(M, 1e-9)\n\n        gm1 = gamma - 1.0\n        \n        # A/A*(M) value is needed for the derivative formula\n        val_A_A_star = A_A_star(M, gamma)\n        \n        numerator = M**2 - 1.0\n        denominator = M * (1.0 + (gm1 / 2.0) * M**2)\n        \n        # Avoid division by zero if M is close to zero, although problem context prevents this.\n        mask_den_zero = np.abs(denominator)  1e-12\n        denominator[mask_den_zero] = 1e-12\n        \n        return val_A_A_star * (numerator / denominator)\n\n    def M_true_func(s_val):\n        \"\"\"\n        Calculates the prescribed true Mach number distribution.\n        \"\"\"\n        return 0.8 + 0.4 * np.exp(-((s_val - 0.6)**2) / (0.05**2))\n\n    # Static computations\n    M_true = M_true_func(s)\n    m0 = M_true + DELTA * np.sin(2 * np.pi * s)\n    A_A_star_true = A_A_star(M_true)\n\n    # --- 3. Strategies and Solver ---\n    \n    strategies = [\n        {'type': 'exact'},\n        {'type': 'fd', 'epsilon': 1e-6},\n        {'type': 'fd', 'epsilon': 1e-3},\n        {'type': 'frozen'}\n    ]\n    \n    convergence_rates = []\n\n    for strategy in strategies:\n        m = m0.copy()\n        errors = []\n\n        # Calculate initial error e^(0)\n        initial_error = np.linalg.norm(m - M_true, ord=np.inf)\n        errors.append(initial_error)\n        \n        # Pre-compute frozen Jacobian if needed\n        if strategy['type'] == 'frozen':\n            J_frozen = dA_A_star_dM(m)\n            # Regularize to prevent division by zero at sonic points\n            mask_j_zero = np.abs(J_frozen)  1e-12\n            if np.any(mask_j_zero):\n                 J_frozen[mask_j_zero] = np.sign(J_frozen[mask_j_zero]) * 1e-12\n\n        # Newton iteration loop\n        for _ in range(NUM_ITER):\n            # Calculate residual R(m)\n            R = A_A_star(m) - A_A_star_true\n            \n            # Calculate Jacobian J(m) based on strategy\n            if strategy['type'] == 'exact':\n                J = dA_A_star_dM(m)\n            elif strategy['type'] == 'fd':\n                epsilon = strategy['epsilon']\n                J = (A_A_star(m + epsilon) - A_A_star(m)) / epsilon\n            elif strategy['type'] == 'frozen':\n                J = J_frozen\n            \n            # Regularize Jacobian to prevent division by very small numbers near M=1\n            mask_j_zero = np.abs(J)  1e-12\n            if np.any(mask_j_zero):\n                J[mask_j_zero] = np.sign(J[mask_j_zero]) * 1e-12\n\n            # Newton update step\n            delta_m = -R / J\n            m = m + delta_m\n            \n            # Store error e^(k)\n            error = np.linalg.norm(m - M_true, ord=np.inf)\n            errors.append(error)\n\n        # --- 4. Convergence Rate Calculation ---\n        # The convergence rate p is estimated using the last three errors from the list.\n        # The list has NUM_ITER+1 = 9 elements (indices 0 to 8).\n        # We use e^(k-1), e^(k), e^(k+1) where k+1 = 8. So k=7, k-1=6.\n        # These are at indices 6, 7, 8.\n        \n        e_k_minus_1 = errors[6] # e^(6)\n        e_k = errors[7]         # e^(7)\n        e_k_plus_1 = errors[8]  # e^(8)\n        \n        # Handle cases where error reduction stops, to avoid log(1) or division by zero\n        if e_k > 0 and e_k_plus_1 > 0:\n            log_term_num = np.log(e_k_plus_1 / e_k)\n        else:\n            log_term_num = -np.inf\n        \n        if e_k_minus_1 > 0 and e_k > 0:\n            log_term_den = np.log(e_k / e_k_minus_1)\n        else:\n            log_term_den = -np.inf\n\n        if log_term_den == 0.0 or log_term_den == -np.inf:\n            p = 1.0 # If stalled, convergence is at best linear with factor 1.\n        else:\n            p = log_term_num / log_term_den\n\n        convergence_rates.append(p)\n\n    # --- 5. Output ---\n    # Format the results into the required string format\n    result_str = \",\".join(map(str, convergence_rates))\n    print(f\"[{result_str}]\")\n\n\nsolve()\n```"
        }
    ]
}