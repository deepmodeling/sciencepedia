{
    "hands_on_practices": [
        {
            "introduction": "在适当正交分解（POD）中，一个关键步骤是决定保留多少个基模态来创建一个既高效又精确的降阶模型（ROM）。这个决定通常基于“能量”准则，其中快照矩阵的奇异值平方代表了每个模态的能量含量。这项练习  提供了实施这一基本截断策略的实践经验，包括计算累积能量曲线，并选择ROM阶数 $r$ 以满足预设的精度容差 $\\epsilon$。",
            "id": "3990098",
            "problem": "考虑基于本征正交分解 (Proper Orthogonal Decomposition, POD) 的航空航天计算流体动力学降阶建模。令快照矩阵表示为 $X \\in \\mathbb{R}^{m \\times n}$，并假设其可进行奇异值分解 (Singular Value Decomposition, SVD) $X = U \\Sigma V^\\top$，其中 $\\Sigma$ 的对角线元素是奇异值 $\\sigma_1, \\sigma_2, \\dots, \\sigma_k$，$k = \\min(m,n)$，$U$ 和 $V$ 是标准正交矩阵。在 POD 中，与模态 $i$ 相关的能量含量与 $\\sigma_i^2$ 成正比，总能量与 $\\sum_{i=1}^{k} \\sigma_i^2$ 成正比。秩为 $r$ 的近似模型保留的累积能量定义为前 $r$ 个奇异值所捕获的总能量的比例。被忽略的能量分数定义为保留分数的补集。\n\n从这些定义和 SVD 的性质出发，对每个给定的测试用例执行以下操作。您必须将任何奇异值列表视为非负实数的无序多重集，并在进行任何计算之前首先按非递增顺序对其进行排序。\n\n1. 给定一个奇异值列表 $\\{\\sigma_i\\}_{i=1}^k$，计算由下式定义的累积能量保留曲线 $\\{E_r\\}_{r=0}^k$\n$$\nE_r = \\frac{\\sum_{i=1}^{r} \\sigma_i^2}{\\sum_{i=1}^{k} \\sigma_i^2},\n$$\n约定 $E_0 = 0$。如果 $\\sum_{i=1}^{k} \\sigma_i^2 = 0$，则对所有 $r$ 定义 $E_r = 0$，并且为了满足下文的容差准则，将被忽略的能量分数定义为 $0$。\n2. 给定一个容差 $\\epsilon \\in [0,1]$（以小数而非百分比表示），选择最小的整数 $r \\in \\{0,1,\\dots,k\\}$，使得被忽略的能量分数 $1 - E_r \\le \\epsilon$。\n3. 对于每个测试用例，输出一个形式为 $[r, [E_0, E_1, \\dots, E_k], \\text{ok}]$ 的列表，其中 $r$ 是所选的秩，$[E_0, E_1, \\dots, E_k]$ 是累积能量保留曲线，而 $\\text{ok}$ 是一个布尔值，指示不等式 $1 - E_r \\le \\epsilon$ 对于所选的 $r$ 是否成立。\n\n使用以下奇异值数组和容差的测试套件，其设计旨在覆盖典型行为、边界条件以及探测对容差敏感度的边缘情况：\n- 测试用例 1：奇异值 $[4.0, 2.0, 1.0, 0.5, 0.25]$，容差 $\\epsilon = 0.05$。\n- 测试用例 2：奇异值 $[3.0, 0.0, 0.0]$，容差 $\\epsilon = 0$。\n- 测试用例 3：奇异值 $[0.5, 2.0, 1.0]$，容差 $\\epsilon = 0.2$。\n- 测试用例 4：奇异值 $[10, 9.9, 0.1, 0.1, 0.1]$，容差 $\\epsilon = 0.0002$。\n- 测试用例 5：奇异值 $[10, 9.9, 0.1, 0.1, 0.1]$，容差 $\\epsilon = 0.00015$。\n- 测试用例 6：奇异值 $[0.0, 0.0]$，容差 $\\epsilon = 0.5$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素按顺序对应一个测试用例。例如，输出格式必须严格符合 $[[r_1,[E_{0,1},\\dots,E_{k_1,1}],\\text{ok}_1],[r_2,[E_{0,2},\\dots,E_{k_2,2}],\\text{ok}_2],\\dots]$ 的形式。",
            "solution": "该问题要求实现一个基于本征正交分解 (POD) 的算法，以针对给定的能量容差确定最优的降阶模型秩。该过程涉及分析从快照矩阵导出的一组奇异值。对于每个测试用例，解决方案被构建为一系列定义明确的计算步骤。\n\n首先，将给定的奇异值列表表示为一个多重集 $\\{\\sigma_i\\}_{i=1}^k$。根据问题陈述，必须将这些值按非递增顺序排序，以正确表示 POD 模态的能量层级。令排序后的奇异值为 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_k \\ge 0$。此处，$k$ 是奇异值的总数。\n\n与第 $i$ 个 POD 模态相关的能量含量，或简称为“能量”，与其对应的奇异值的平方 $\\sigma_i^2$ 成正比。快照中捕获的系统总能量与所有模态的能量之和成正比，即 $E_{\\text{total}} = \\sum_{i=1}^{k} \\sigma_i^2$。\n\n问题的核心是计算由秩为 $r$ 的近似模型保留的累积能量，其定义如下：\n$$\nE_r = \\frac{\\sum_{i=1}^{r} \\sigma_i^2}{\\sum_{i=1}^{k} \\sigma_i^2} \\quad \\text{for } r \\in \\{1, 2, \\dots, k\\}\n$$\n按照约定，对于秩为 0 的模型（不包含任何模态），保留的能量为零，因此 $E_0 = 0$。序列 $\\{E_r\\}_{r=0}^k$ 构成了累积能量保留曲线。根据定义，该序列是单调非递减的，从 $E_0 = 0$ 开始，到 $E_k = 1$ 结束。当总能量为零（$E_{\\text{total}} = 0$）时，会出现一种特殊情况，这当且仅当所有奇异值都为零时发生。在这种情况下，问题规定对于所有 $r \\in \\{0, 1, \\dots, k\\}$，$E_r = 0$。\n\n对于每个提供奇异值列表和容差 $\\epsilon \\in [0,1]$ 的测试用例，算法按以下步骤进行：\n\n1.  **初始化与排序**：将输入的奇异值列表转换为数值数组，并按非递增顺序排序，以获得序列 $\\sigma_1, \\sigma_2, \\dots, \\sigma_k$。\n\n2.  **能量计算**：计算每个奇异值的平方 $\\sigma_i^2$。然后计算总能量 $E_{\\text{total}} = \\sum_{i=1}^{k} \\sigma_i^2$。\n\n3.  **累积能量曲线构建**：\n    - 如果 $E_{\\text{total}}$ 为零，则累积能量曲线 $\\{E_r\\}_{r=0}^k$ 是一个包含 $k+1$ 个零的序列。\n    - 如果 $E_{\\text{total}}$ 为正，则计算奇异值平方的部分和 $S_r = \\sum_{i=1}^{r} \\sigma_i^2$（其中 $r=1, \\dots, k$）。然后，每个秩的累积能量为 $E_r = S_r / E_{\\text{total}}$。最终的曲线是序列 $[E_0, E_1, \\dots, E_k]$。\n\n4.  **秩选择**：主要任务是找到最小的整数秩 $r \\in \\{0, 1, \\dots, k\\}$，使得被忽略的能量分数不超过指定的容差 $\\epsilon$。此条件由不等式表示：\n    $$\n    1 - E_r \\le \\epsilon\n    $$\n    这在数学上等价于找到满足以下条件的最小 $r$：\n    $$\n    E_r \\ge 1 - \\epsilon\n    $$\n    由于序列 $\\{E_r\\}$ 是单调非递减的，我们可以从 $r=0$ 开始搜索序列，从而高效地找到满足此标准的最小 $r$。搜索在满足条件的第一个秩处终止。对于 $E_{\\text{total}} = 0$ 的特殊情况，问题将被忽略的能量分数定义为 $0$。条件变为 $0 \\le \\epsilon$，对于 $\\epsilon \\in [0,1]$ 恒为真。因此，满足条件的最小秩为 $r=0$。\n\n5.  **验证**：问题要求一个布尔值 $\\text{ok}$，以确认所选的秩 $r$ 确实满足不等式 $1 - E_r \\le \\epsilon$。根据我们的秩选择方法的构造，此条件将始终被满足。此步骤用作对结果的正式验证。\n\n6.  **输出组装**：对于每个测试用例，最终结果被组装成一个包含三个元素的列表：所选的秩 $r$、完整的累积能量曲线 $[E_0, E_1, \\dots, E_k]$ 以及布尔验证标志 $\\text{ok}$。\n\n此过程为问题提供了一个完整且确定性的解决方案，正确处理了指定的定义、约定和边缘情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(sigma_values, epsilon):\n    \"\"\"\n    Processes a single test case of singular values and a tolerance.\n\n    Args:\n        sigma_values (list): A list of non-negative real numbers representing singular values.\n        epsilon (float): The tolerance for neglected energy, in the range [0, 1].\n\n    Returns:\n        list: A list of the form [r, E_curve, ok], where r is the selected rank,\n              E_curve is the cumulative energy list, and ok is the verification boolean.\n    \"\"\"\n    # Use float64 for better precision in calculations.\n    sv = np.array(sigma_values, dtype=np.float64)\n\n    # 1. Sort singular values in non-increasing order.\n    sv_sorted = np.sort(sv)[::-1]\n    k = len(sv_sorted)\n\n    # 2. Calculate squared values and total energy.\n    sv_squared = np.square(sv_sorted)\n    total_energy = np.sum(sv_squared)\n\n    # 3. Handle the zero total energy edge case.\n    if np.isclose(total_energy, 0.0):\n        E_curve = [0.0] * (k + 1)\n        # As per the problem: neglected energy fraction is defined as 0.\n        # The condition is 0 = epsilon, which is always true for valid epsilon >= 0.\n        # The smallest rank r is therefore 0.\n        r = 0\n        ok = 0.0 = epsilon\n        return [r, E_curve, ok]\n\n    # 4. Calculate the cumulative energy retained curve {E_r}.\n    cumulative_energies = np.cumsum(sv_squared) / total_energy\n    # Prepend E_0 = 0 to form the full curve {E_r}_{r=0 to k}.\n    E_curve = np.insert(cumulative_energies, 0, 0.0)\n\n    # 5. Find the smallest rank r such that 1 - E_r = epsilon,\n    # which is equivalent to E_r >= 1 - epsilon.\n    threshold = 1.0 - epsilon\n\n    # Since E_curve is monotonically non-decreasing, we can find the\n    # first index where the condition is met. np.searchsorted is efficient for this.\n    # It finds the first index `i` such that E_curve[i] >= threshold.\n    r = np.searchsorted(E_curve, threshold, side='left')\n\n    # The rank r must be at most k. This is guaranteed because E_curve[k] is very\n    # close to 1.0 and the threshold is at most 1.0.\n    r = int(min(r, k))\n\n    # 6. Verify that the selected rank r satisfies the condition.\n    # By construction of the search for r, this should always be true,\n    # barring floating point inaccuracies which we must handle carefully.\n    neglected_energy = 1.0 - E_curve[r]\n    ok = neglected_energy = epsilon or np.isclose(neglected_energy, epsilon)\n\n    return [int(r), E_curve.tolist(), ok]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: Typical decay\n        ([4.0, 2.0, 1.0, 0.5, 0.25], 0.05),\n        # Test case 2: Rank-deficient, zero tolerance\n        ([3.0, 0.0, 0.0], 0.0),\n        # Test case 3: Unordered input\n        ([0.5, 2.0, 1.0], 0.2),\n        # Test case 4: Tolerance sensitivity 1\n        ([10.0, 9.9, 0.1, 0.1, 0.1], 0.0002),\n        # Test case 5: Tolerance sensitivity 2\n        ([10.0, 9.9, 0.1, 0.1, 0.1], 0.00015),\n        # Test case 6: Zero energy\n        ([0.0, 0.0], 0.5),\n    ]\n\n    all_results = []\n    for sv, eps in test_cases:\n        result = process_case(sv, eps)\n        all_results.append(result)\n\n    # Format the final output string to match the required format exactly.\n    # [[r1,[E...],ok1],[r2,[E...],ok2],...]\n    # Example format: [3,[0.0,0.75...,1.0],true]\n    result_strings = []\n    for res in all_results:\n        r, E_curve, ok = res\n        E_curve_str = f\"[{','.join(map(str, E_curve))}]\"\n        ok_str = str(ok).lower()\n        result_strings.append(f\"[{r},{E_curve_str},{ok_str}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了如何选择模态之后，下一步是为一个依赖于物理参数的系统构建并测试一个降阶模型。本练习探讨了如何构建一个单一的POD基，以表示在一系列参数（本例中为热方程的热扩散系数 $\\kappa$）下的解。通过实施这个工作流程 ，您将学习如何生成训练数据，通过奇异值分解（SVD）构建一个全局基，并通过测量新、未见参数值的投影误差来评估模型的泛化性能。",
            "id": "3184782",
            "problem": "你需要实现一个完整的、可运行的程序，该程序从一维热方程的训练快照中构建一个本征正交分解 (POD) 基，然后评估对于指定范围内几个未见过的热扩散系数参数，正交投影误差如何随着保留的 POD 模态数量的增加而衰减。所有量都必须纯粹用数学术语处理，不带物理单位。\n\n考虑在单位区间上具有零狄利克雷边界条件的一维热方程：\n- 控制方程：$u_t = \\kappa\\,u_{xx}$，对于 $x \\in [0,1]$ 和 $t \\ge 0$。\n- 边界条件：$u(0,t) = 0$ 和 $u(1,t) = 0$，对于所有 $t \\ge 0$。\n- 初始条件：$u(x,0) = \\sum_{n=1}^{8} a_n \\sin(n\\pi x)$，其中系数为 $a_1=1.0$, $a_2=0.5$, $a_3=-0.3$, $a_4=0.2$, $a_5=0.1$, $a_6=-0.05$, $a_7=0.04$, $a_8=-0.02$。\n\n解构造的基本依据：一个经过充分验证的事实是，在这些边界条件下，上述初边值问题的解允许使用傅里叶正弦级数表示，其模态振幅随时间呈指数衰减。你必须利用这一事实来解析地计算快照，而无需对偏微分方程进行数值离散化。\n\n定义和所需计算：\n- 将解析解定义为 $u(x,t;\\kappa) = \\sum_{n=1}^{8} a_n \\exp\\!\\big(-\\kappa (n\\pi)^2 t\\big)\\,\\sin(n\\pi x)$。\n- 设空间网格在 $[0,1]$ 上均匀分布，有 $N_x = 200$ 个点，包括端点。\n- 设训练参数值为 $\\kappa_{\\text{train}} \\in \\{0.06, 0.14, 0.22\\}$，训练快照时间为 $t \\in \\{0.00, 0.05, 0.10, 0.20, 0.50\\}$。\n- 通过将指定集合中的每个 $t$ 和指定训练集中的每个 $\\kappa$ 对应的所有空间快照 $u(\\cdot, t; \\kappa)$ 按任意固定的确定性顺序作为列进行拼接，构建训练快照矩阵 $M_{\\text{train}} \\in \\mathbb{R}^{N_x \\times N_{\\text{snap}}}$。\n- 通过奇异值分解 (SVD) $M_{\\text{train}} = U \\Sigma V^\\top$ 得到 $U$ 的列作为 POD 基进行计算，其中 $U \\in \\mathbb{R}^{N_x \\times r_{\\max}}$ 具有正交标准列，且 $r_{\\max} \\le \\min(N_x, N_{\\text{snap}})$。按顺序使用这些 $U$ 的列作为 POD 模态；不要减去均值（即，直接对 $M_{\\text{train}}$ 执行 POD）。\n- 为了进行评估，使用未见过的测试参数 $\\kappa_{\\text{test}} \\in \\{0.05, 0.10, 0.17, 0.25\\}$ 和相同的时间集合 $t \\in \\{0.00, 0.05, 0.10, 0.20, 0.50\\}$，为每个测试参数构建 $M_{\\text{test}}(\\kappa) \\in \\mathbb{R}^{N_x \\times N_{\\text{test}}}$。\n- 对于给定的保留模态数 $r$，定义正交投影算子 $P_r = U_r U_r^\\top$，其中 $U_r \\in \\mathbb{R}^{N_x \\times r}$ 包含前 $r$ 个 POD 模态。对于每个测试参数 $\\kappa$，计算相对投影误差\n$$\nE(\\kappa,r) = \\frac{\\lVert M_{\\text{test}}(\\kappa) - P_r M_{\\text{test}}(\\kappa) \\rVert_F}{\\lVert M_{\\text{test}}(\\kappa) \\rVert_F},\n$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示弗罗贝尼乌斯范数。取 $E(\\kappa,0)$ 为零近似的相对误差（即，$P_0 = 0$）。\n- 对 $r \\in \\{0,1,2,3,5,8,10\\}$ 和每个 $\\kappa \\in \\{0.05, 0.10, 0.17, 0.25\\}$，计算 $E(\\kappa,r)$。\n\n测试套件与覆盖范围理据：\n- 选择 $r=0$ 测试了不保留任何模态的边界情况。\n- 选择 $r=10$ 超过了初始非零傅里叶分量的数量，用以探究预期的误差饱和至零的情况。\n- 测试参数包括区间端点 $0.05$ 和 $0.25$ 以及内部值 $0.10$ 和 $0.17$，这些值均未在训练中使用，从而检验在整个参数范围内的泛化能力。\n\n最终输出要求：\n- 你的程序应生成单行输出，其中包含一个浮点数的嵌套列表作为结果，且无空格。外层列表必须按测试参数 $\\kappa \\in [0.05, 0.10, 0.17, 0.25]$ 的升序排列。对于每个测试参数，内层列表必须严格按照此 $r$ 值的顺序包含误差 $[E(\\kappa,0), E(\\kappa,1), E(\\kappa,2), E(\\kappa,3), E(\\kappa,5), E(\\kappa,8), E(\\kappa,10)]$。每个浮点数表示为四舍五入到八位小数。例如，打印的格式必须类似于 $[[e_{11},e_{12},\\dots],[e_{21},\\dots],\\dots]$，其中 $e_{ij}$ 的位置为数值条目。",
            "solution": "该问题要求实现一个基于本征正交分解 (POD) 的一维热方程降阶模型。该过程涉及生成训练数据、构建一个低维基，并在未见过的测试数据上评估该基的有效性。整个过程基于解析解，从而避免了控制偏微分方程 (PDE) 的离散化误差。\n\n步骤 1：解析解与数据生成\n\n该问题关注的是在定义域 $x \\in [0,1]$ 上，具有零狄利克雷边界条件 $u(0,t) = u(1,t) = 0$ 的热方程 $u_t = \\kappa\\,u_{xx}$。初始条件是一个有限傅里葉级数，$u(x,0) = \\sum_{n=1}^{8} a_n \\sin(n\\pi x)$，系数 $\\{a_n\\}$ 已知。通过分离变量法推导出的解析解已提供如下：\n$$\nu(x,t;\\kappa) = \\sum_{n=1}^{8} a_n \\exp\\!\\big(-\\kappa (n\\pi)^2 t\\big)\\,\\sin(n\\pi x)\n$$\n此公式使我们能够生成解场的“快照”，这些快照是表示在特定时间 $t$ 和给定热扩散系数 $\\kappa$ 下的温度分布 $u(\\cdot, t; \\kappa)$ 的向量。这些快照在 $[0,1]$ 上的一个包含 $N_x = 200$ 个点的均匀空间网格上进行评估。\n\n步骤 2：训练快照矩阵的构建\n\n为了构建一个降阶模型，我们首先收集一组代表性解。训练数据是使用训练参数集 $\\kappa_{\\text{train}} \\in \\{0.06, 0.14, 0.22\\}$ 和快照时间 $t \\in \\{0.00, 0.05, 0.10, 0.20, 0.50\\}$ 生成的。对于训练集中的每一对 $(\\kappa, t)$，我们计算相应的解快照向量。然后将这些快照向量按列拼接，形成训练快照矩阵 $M_{\\text{train}} \\in \\mathbb{R}^{N_x \\times N_{\\text{snap}}}$。这里，$N_x = 200$，快照总数为 $N_{\\text{snap}} = |\\kappa_{\\text{train}}| \\times |t| = 3 \\times 5 = 15$。\n\n步骤 3：本征正交分解 (POD)\n\nPOD 的核心是找到一个标准正交基，该基在最小二乘意义上是表示训练数据的最优基。这通过对快照矩阵进行奇异值分解 (SVD) 来实现：\n$$\nM_{\\text{train}} = U \\Sigma V^\\top\n$$\n矩阵 $U \\in \\mathbb{R}^{N_x \\times N_{\\text{snap}}}$ 的列（来自薄奇异值分解，因为 $N_x  N_{\\text{snap}}$）是左奇异向量。这些向量构成了 POD 基。它们根据对角矩阵 $\\Sigma \\in \\mathbb{R}^{N_{\\text{snap}} \\times N_{\\text{snap}}}$ 中相应奇异值的大小进行排序，其中 $U$ 的第一列是能量最高的模态。\n一个重要的观察是，对于任何 $t$ 和 $\\kappa$，所有快照都位于由函数 $\\{\\sin(n\\pi x)\\}_{n=1}^8$ 张成的 8 维子空间内。因此，快照矩阵 $M_{\\text{train}}$ 的秩不能超过 8。这意味着只有前 8 个奇异值会显著非零，并且 POD 基的有效维度为 8。\n\n步骤 4：投影与误差评估\n\nPOD 基允许通过将任何解快照（无论是训练集内还是训练集外）正交投影到由前 $r$ 个 POD 模态张成的子空间上来近似该快照。我们将截断的基矩阵表示为 $U_r \\in \\mathbb{R}^{N_x \\times r}$，它包含 $U$ 的前 $r$ 列。到这个子空间上的正交投影算子是 $P_r = U_r U_r^\\top$。\n\n为了评估基的质量，我们使用相同的时间点集合，为一组未见过的参数 $\\kappa_{\\text{test}} \\in \\{0.05, 0.10, 0.17, 0.25\\}$ 生成测试数据。对于每个 $\\kappa \\in \\kappa_{\\text{test}}$，我们形成一个测试快照矩阵 $M_{\\text{test}}(\\kappa)$。使用 $r$ 个模态对此测试矩阵的近似由 $P_r M_{\\text{test}}(\\kappa)$ 给出。此近似的误差使用相对弗罗贝尼乌斯范数进行量化：\n$$\nE(\\kappa,r) = \\frac{\\lVert M_{\\text{test}}(\\kappa) - P_r M_{\\text{test}}(\\kappa) \\rVert_F}{\\lVert M_{\\text{test}}(\\kappa) \\rVert_F}\n$$\n为提高计算效率，投影 $P_r M_{\\text{test}}(\\kappa)$ 计算为 $U_r (U_r^\\top M_{\\text{test}}(\\kappa))$。$r=0$ 的情况对应于用零来近似解，产生的误差为 $E(\\kappa,0)=1$。我们为每个 $\\kappa \\in \\kappa_{\\text{test}}$ 和一组指定的保留模态数 $r \\in \\{0, 1, 2, 3, 5, 8, 10\\}$ 计算此误差。结果被汇总到一个嵌套列表中作为最终输出。由于底层解空间是 8 维的，我们预计当 $r \\ge 8$ 时，误差将降至接近零。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Constructs a POD basis for the 1D heat equation and evaluates projection error.\n    \"\"\"\n    # Define problem parameters\n    A_COEFFS = np.array([1.0, 0.5, -0.3, 0.2, 0.1, -0.05, 0.04, -0.02])\n    NX = 200\n    KAPPA_TRAIN = [0.06, 0.14, 0.22]\n    T_POINTS = [0.00, 0.05, 0.10, 0.20, 0.50]\n    KAPPA_TEST = [0.05, 0.10, 0.17, 0.25]\n    R_VALUES = [0, 1, 2, 3, 5, 8, 10]\n\n    # Spatial grid\n    x = np.linspace(0, 1, NX)\n\n    def analytical_u(x_grid, t, kappa, coeffs):\n        \"\"\"Computes the analytical solution u(x, t; kappa).\"\"\"\n        sol = np.zeros_like(x_grid)\n        for n_idx, a_n in enumerate(coeffs):\n            n = n_idx + 1\n            mode_component = a_n * np.exp(-kappa * (n * np.pi)**2 * t) * np.sin(n * np.pi * x_grid)\n            sol += mode_component\n        return sol\n\n    # --- Step 1: Construct Training Snapshot Matrix ---\n    train_snapshots = []\n    for kappa_train_val in KAPPA_TRAIN:\n        for t_val in T_POINTS:\n            snapshot = analytical_u(x, t_val, kappa_train_val, A_COEFFS)\n            train_snapshots.append(snapshot)\n    \n    M_train = np.stack(train_snapshots, axis=1)\n\n    # --- Step 2: Compute POD Basis via SVD ---\n    # Use thin SVD since Nx > N_snap\n    U, s, vh = linalg.svd(M_train, full_matrices=False)\n\n    # --- Step 3: Evaluate Projection Error for Test Cases ---\n    all_results = []\n    for kappa_test_val in KAPPA_TEST:\n        # Build the test snapshot matrix for the current kappa\n        test_snapshots = []\n        for t_val in T_POINTS:\n            snapshot = analytical_u(x, t_val, kappa_test_val, A_COEFFS)\n            test_snapshots.append(snapshot)\n        \n        M_test = np.stack(test_snapshots, axis=1)\n\n        norm_M_test = linalg.norm(M_test, 'fro')\n        \n        kappa_errors = []\n        for r in R_VALUES:\n            if norm_M_test == 0:\n                 # Should not happen in this problem, but for robustness\n                 # If M_test is zero, projection is perfect (error 0), except for r=0\n                 error = 1.0 if r == 0 else 0.0\n            elif r == 0:\n                # Per problem spec, P_0 = 0. Error is ||M - 0|| / ||M|| = 1.\n                error = 1.0\n            else:\n                # Truncate the POD basis\n                Ur = U[:, :r]\n                \n                # Project M_test onto the r-dimensional subspace\n                # P_r * M_test = Ur * Ur.T * M_test\n                projected_M_test = Ur @ (Ur.T @ M_test)\n                \n                # Compute the relative Frobenius norm of the error\n                error_matrix = M_test - projected_M_test\n                norm_error = linalg.norm(error_matrix, 'fro')\n                error = norm_error / norm_M_test\n\n            kappa_errors.append(error)\n        \n        all_results.append(kappa_errors)\n        \n    # --- Step 4: Format output string ---\n    outer_parts = []\n    for inner_list in all_results:\n        inner_parts = [f\"{x:.8f}\" for x in inner_list]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    final_string = f\"[{','.join(outer_parts)}]\"\n\n    print(final_string)\n\nsolve()\n```"
        },
        {
            "introduction": "一个精确的POD基能够确保对训练数据的良好重构，但这并不保证所产生的降阶模型（ROM）的动态行为是稳定的。这项高级实践展示了伽辽金投影的一个关键失效模式：一个由非正规算子控制的稳定的高保真系统，可能会产生一个不稳定的ROM。这项练习  为基于投影的降阶模型可能存在的陷阱提供了至关重要的一课，促使您在评估模型可靠性时，不仅要考虑数据的特性，还要考虑系统算子的性质。",
            "id": "2432128",
            "problem": "要求您在降阶建模中实现一个完整的数值实验，以展示以下现象：一个 Proper Orthogonal Decomposition (POD) 基可以出色地重构一个稳定全阶线性时不变系统的训练快照，然而通过 Galerkin 投影得到的降阶模型 (ROM) 在进行时间积分时却可能产生不稳定的、会发散的动力学行为。\n\n您的实现必须从全阶常微分方程开始\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b},\n$$\n其中 $\\mathbf{A}\\in\\mathbb{R}^{n\\times n}$ 和 $\\mathbf{b}\\in\\mathbb{R}^{n}$ 是常数，$\\mathbf{x}(t)\\in\\mathbb{R}^{n}$ 是状态。所有计算都在实数域上进行，使用标准的欧几里得内积。在整个实验中，您将使用 $n=2$。\n\n基本定义与要求：\n- Proper Orthogonal Decomposition (POD) 基：给定一个快照矩阵\n$$\n\\mathbf{X} = \\begin{bmatrix}\\mathbf{x}(t_1)  \\mathbf{x}(t_2)  \\cdots  \\mathbf{x}(t_m)\\end{bmatrix}\\in\\mathbb{R}^{n\\times m},\n$$\n计算其奇异值分解 (SVD) $\\mathbf{X}=\\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$。秩为 $r$ 的 POD 基 $\\mathbf{Q}\\in\\mathbb{R}^{n\\times r}$ 取为 $\\mathbf{U}$ 的前 $r$ 列。\n- Galerkin 投影：降阶算子和降阶强迫项为\n$$\n\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}\\in\\mathbb{R}^{r\\times r},\\qquad \\mathbf{b}_r=\\mathbf{Q}^\\top\\mathbf{b}\\in\\mathbb{R}^{r}.\n$$\n降阶状态 $\\mathbf{z}(t)\\in\\mathbb{R}^{r}$ 按如下方式演化\n$$\n\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r \\mathbf{z} + \\mathbf{b}_r,\\qquad \\mathbf{x}_r(t)=\\mathbf{Q}\\mathbf{z}(t).\n$$\n- 时间积分：对全阶模型和 ROM 均使用经典的四阶 Runge–Kutta 方法，并采用固定的时间步长 $h0$。设置初始条件为 $\\mathbf{x}(0)=\\mathbf{0}$ 和 $\\mathbf{z}(0)=\\mathbf{Q}^\\top\\mathbf{x}(0)=\\mathbf{0}$。\n- 快照收集：在训练时间域 $[0,T_{\\text{train}}]$ 上以恒定时间步长 $h$ 对全阶模型进行积分，在每一步对状态进行采样以构成 $\\mathbf{X}$。\n- 重构误差：将训练快照的相对 POD 重构误差度量为\n$$\n\\varepsilon_{\\text{rec}} = \\frac{\\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F}{\\lVert \\mathbf{X}\\rVert_F},\n$$\n其中 $\\lVert\\cdot\\rVert_F$ 表示 Frobenius 范数。\n- 发散检测：在测试时间域 $[0,T_{\\text{test}}]$ 上以相同的 $h$ 对全阶模型和 ROM 进行演化。如果在任何时间步，当前状态的欧几里得范数超过阈值 $M$，或任何分量变为非数值或无穷大，则宣称该解“已发散”。使用阈值 $M=10^6$。\n\n为引发 ROM 不稳定性而构造的强迫项：\n- 对于每个测试，您必须按如下方式构造常数强迫项 $\\mathbf{b}$。计算对称部分 $\\mathbf{S}=\\frac{1}{2}(\\mathbf{A}+\\mathbf{A}^\\top)$ 及其与 $\\mathbf{S}$ 的最大特征值相关联的主单位特征向量 $\\mathbf{q}\\in\\mathbb{R}^{n}$（以任意但确定性的方式处理并列情况）。设置\n$$\n\\mathbf{b}=-\\mathbf{A}\\mathbf{q}.\n$$\n该构造确保了全阶稳态为 $\\mathbf{x}_\\infty = -\\mathbf{A}^{-1}\\mathbf{b}=\\mathbf{q}$。当 $\\mathbf{A}$ 是高度非正规的且 $\\mathbf{S}$ 的最大特征值为正时，使用 $r=1$ 和 $\\mathbf{Q}=\\mathbf{q}$ 获得的标量 ROM 具有降阶动力学 $\\frac{dz}{dt} = a_r z + b_r$，其中 $a_r=\\mathbf{q}^\\top\\mathbf{A}\\mathbf{q}0$ 且 $b_r=-a_r$，这是不稳定的，并会从 $z(0)=0$ 开始发散。\n\n所有测试共用的数值设定：\n- 使用 $n=2$。\n- 使用 $h=10^{-3}$。\n- 使用经典的四阶 Runge–Kutta 方法。\n- 所有向量范数均使用欧几里得范数。\n- 使用 $\\mathbf{x}(0)=\\mathbf{0}$。\n\n测试套件：\n为以下参数集实现上述过程。在每种情况下，定义 $\\mathbf{A}$，按规定计算 $\\mathbf{q}$ 和 $\\mathbf{b}$，在 $[0,T_{\\text{train}}]$ 上收集快照以形成 $\\mathbf{Q}$，然后构建 ROM 并在 $[0,T_{\\text{test}}]$ 上运行两个模型。\n\n- 测试 1 (高度非正规，秩为 1 的 POD):\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=50.0$，\n  - $r=1$,\n  - $T_{\\text{train}}=4.0$,\n  - $T_{\\text{test}}=1.0$.\n- 测试 2 (高度非正规，秩为 2 的 POD):\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=50.0$，\n  - $r=2$,\n  - $T_{\\text{train}}=4.0$,\n  - $T_{\\text{test}}=1.0$.\n- 测试 3 (对称负定，秩为 1 的 POD):\n  - $\\mathbf{A}=\\begin{bmatrix}-1.0  0.0 \\\\ 0.0  -2.0\\end{bmatrix}$,\n  - $r=1$,\n  - $T_{\\text{train}}=4.0$,\n  - $T_{\\text{test}}=1.0$.\n- 测试 4 (更高度非正规，秩为 1 的 POD):\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=120.0$，\n  - $r=1$,\n  - $T_{\\text{train}}=4.0$,\n  - $T_{\\text{test}}=1.0$.\n\n要求的输出：\n- 对于每个测试，输出一个包含三个条目的列表：\n  - 标量 $\\varepsilon_{\\text{rec}}$（四舍五入到六位小数），\n  - 一个指示 ROM 是否在 $[0,T_{\\text{test}}]$ 上发散的布尔值，\n  - 一个指示全阶模型是否在 $[0,T_{\\text{test}}]$ 上发散的布尔值。\n- 将所有测试的结果汇总为单行，形式为用方括号括起来的逗号分隔列表，顺序与测试顺序相同。示例格式：\n$[\\,[\\varepsilon_{\\text{rec}}^{(1)},\\,\\text{ROM}^{(1)}\\_\\text{blowup},\\,\\text{FOM}^{(1)}\\_\\text{blowup}],\\,[\\varepsilon_{\\text{rec}}^{(2)},\\,\\text{ROM}^{(2)}\\_\\text{blowup},\\,\\text{FOM}^{(2)}\\_\\text{blowup}],\\,\\ldots\\,]$。",
            "solution": "用户提出了一个计算工程领域的问题，具体涉及通过 Proper Orthogonal Decomposition (POD) 和 Galerkin 投影导出的降阶模型 (ROM) 的稳定性。任务是通过数值实验来演示一种已知的失效模式：尽管全阶模型 (FOM) 是稳定的，但 ROM 却可能不稳定。这种现象是由高度非正规算子控制的系统的典型特征。\n\n问题陈述已经过验证，被认为是科学上合理、适定且完整的。所有的定义、参数和程序都足够清晰明确，可以得到唯一且可验证的解。我们将继续进行分析和实现。\n\n问题的核心在于矩阵 $\\mathbf{A}$ 的谱与其数值范围（或值域）之间的区别，数值范围定义为 $W(\\mathbf{A}) = \\{\\mathbf{v}^\\dagger\\mathbf{A}\\mathbf{v} : \\mathbf{v} \\in \\mathbb{C}^n, \\lVert\\mathbf{v}\\rVert_2 = 1\\}$。对于线性时不变系统 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x}$，稳定性由 $\\mathbf{A}$ 的特征值（谱，$\\sigma(\\mathbf{A})$）决定。如果所有特征值都具有负实部，则系统是稳定的，并且当 $t\\to\\infty$ 时 $\\lVert\\mathbf{x}(t)\\rVert \\to 0$。然而，如果 $\\mathbf{A}$ 是非正规的（即 $\\mathbf{A}\\mathbf{A}^\\top \\neq \\mathbf{A}^\\top\\mathbf{A}$），则可能出现瞬态增长。数值范围为这种瞬态行为提供了洞见。数值范围的实部由矩阵的对称部分 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{A} + \\mathbf{A}^\\top)$ 控制，因为 $\\text{Re}(\\mathbf{v}^\\top\\mathbf{A}\\mathbf{v}) = \\mathbf{v}^\\top\\mathbf{S}\\mathbf{v}$。$\\mathbf{S}$ 的一个正特征值意味着 $\\mathbf{A}$ 的数值范围延伸到右半平面，表明存在瞬态能量增长的可能。\n\n使用秩为 $r$ 的 POD 基 $\\mathbf{Q}$ 进行 Galerkin 投影，将 FOM $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b}$ 变换为 ROM $\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r\\mathbf{z} + \\mathbf{b}_r$，其中 $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$。ROM 的稳定性由降阶矩阵 $\\mathbf{A}_r$ 的特征值决定。关键的是，$\\mathbf{A}_r$ 的特征值包含在 $\\mathbf{A}$ 的数值范围内，但不一定在其谱的凸包内。如果数值范围 $W(\\mathbf{A})$ 跨入右半平面，就有可能找到一个投影子空间（基为 $\\mathbf{Q}$），使得 $\\mathbf{A}_r$ 具有正实部的特征值，从而使 ROM 不稳定。\n\n问题的构造旨在揭示这一病态问题。FOM 是稳定的（$\\mathbf{A}$ 的特征值为 $\\{-0.1, -1.0\\}$）。强迫项 $\\mathbf{b} = -\\mathbf{A}\\mathbf{q}$ 的选择使得 FOM 的稳态为 $\\mathbf{x}_{\\infty} = \\mathbf{q}$，其中 $\\mathbf{q}$ 是对应于 $\\mathbf{S}$ 最大特征值的特征向量。这将系统动力学推向最大瞬态增长的方向。由此产生的快照将由该方向主导，导致主 POD 模态（$\\mathbf{Q}$ 的第一列）与 $\\mathbf{q}$ 对齐。对于秩为 1 的 ROM（$r=1$），降阶矩阵 $\\mathbf{A}_r$ 变为标量 $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$。如果 $\\mathbf{Q} \\approx \\mathbf{q}$，则 $a_r \\approx \\mathbf{q}^\\top\\mathbf{A}\\mathbf{q} = \\mathbf{q}^\\top\\mathbf{S}\\mathbf{q} = \\lambda_{\\max}(\\mathbf{S})$。对于测试 1 和测试 4 中的非正规矩阵，$\\lambda_{\\max}(\\mathbf{S})  0$，从而导致不稳定的 ROM。\n\n每个测试用例的计算过程如下：\n$1$. 定义系统参数：矩阵 $\\mathbf{A}$、ROM 秩 $r$ 以及时间域 $T_{\\text{train}}$ 和 $T_{\\text{test}}$。维度为 $n=2$，时间步长为 $h=10^{-3}$。\n$2$. 构造强迫项：计算对称部分 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{A} + \\mathbf{A}^\\top)$。求其特征值和特征向量。令 $\\mathbf{q}$ 为对应于最大特征值的归一化特征向量。设置 $\\mathbf{b} = -\\mathbf{A}\\mathbf{q}$。\n$3$. 生成训练数据：使用经典的四阶 Runge-Kutta 方法，从 $\\mathbf{x}(0)=\\mathbf{0}$ 开始，在时间区间 $[0, T_{\\text{train}}]$ 上对 FOM $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b}$ 进行积分。将每个时间步的状态收集到快照矩阵 $\\mathbf{X}$ 中。\n$4$. 计算 POD 基：对快照矩阵进行奇异值分解 (SVD)，$\\mathbf{X} = \\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$。秩为 $r$ 的 POD 基 $\\mathbf{Q}$ 由 $\\mathbf{U}$ 的前 $r$ 列构成。\n$5$. 计算重构误差：相对 Frobenius 范数误差计算为 $\\varepsilon_{\\text{rec}} = \\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F / \\lVert \\mathbf{X}\\rVert_F$。\n$6$. 构建 ROM：降阶系统矩阵为 $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ 和 $\\mathbf{b}_r = \\mathbf{Q}^\\top\\mathbf{b}$。\n$7$. 为测试进行时间积分：从零初始条件（$\\mathbf{x}(0)=\\mathbf{0}$，$\\mathbf{z}(0)=\\mathbf{0}$）开始，在区间 $[0, T_{\\text{test}}]$ 上对 FOM 和 ROM 进行积分。在积分过程中，每一步都将状态向量的欧几里得范数与发散阈值 $M=10^6$ 进行比较。\n$8$. 记录结果：测试的最终输出是计算出的 $\\varepsilon_{\\text{rec}}$、一个指示 ROM 是否发散的布尔值，以及一个指示 FOM 是否发散的布尔值。\n\n测试的预期结果：\n- **测试 1**：（$\\mathbf{A}$ 非正规, $r=1$）：$\\mathbf{A}$ 是稳定的。$\\mathbf{b}$ 的构造和 $r=1$ 的选择旨在产生一个不稳定的 ROM。我们预期 $\\varepsilon_{\\text{rec}}$ 很小，ROM 发散，而 FOM 不发散。\n- **测试 2**：（$\\mathbf{A}$ 非正规, $r=2$）：此处，$r=n=2$。POD 基 $\\mathbf{Q}$ 将是 $\\mathbb{R}^2$ 的一个完备标准正交基。因此，$\\mathbf{Q}\\mathbf{Q}^\\top = \\mathbf{I}$，这意味着重构误差 $\\varepsilon_{\\text{rec}}$ 将为零（或在机器精度量级）。ROM 在动力学上等效于 FOM，只是在不同的基中表示。由于 FOM 是稳定的，ROM 也将是稳定的。我们预期 $\\varepsilon_{\\text{rec}} \\approx 0$，ROM 不发散，FOM 也不发散。\n- **测试 3**：（$\\mathbf{A}$ 对称, $r=1$）：$\\mathbf{A}$ 是一个正规矩阵。其数值范围是其特征值 $\\{-1.0, -2.0\\}$ 的凸包。因此，数值范围是实轴上的区间 $[-2.0, -1.0]$。降阶算子 $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ 必须为负。ROM 将是稳定的。我们预期两个模型都不会发散。\n- **测试 4**：（$\\mathbf{A}$ 更高度非正规, $r=1$）：与测试 1 类似，但具有更大的非对角项 $\\alpha=120.0$。这增加了非正规性，导致 $\\mathbf{S}$ 有一个更大的正特征值。ROM 的不稳定性应该会更加显著。我们预期 $\\varepsilon_{\\text{rec}}$ 很小，ROM 发散，而 FOM 不发散。\n\n现在将实现上述逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Implements the full numerical experiment to demonstrate ROM instability\n    for a stable FOM.\n    \"\"\"\n\n    def rk4_step(f, y, h, A, b):\n        \"\"\"A single step of the classical fourth-order Runge-Kutta method.\"\"\"\n        k1 = f(y, A, b)\n        k2 = f(y + h / 2 * k1, A, b)\n        k3 = f(y + h / 2 * k2, A, b)\n        k4 = f(y + h * k3, A, b)\n        return y + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def lti_rhs(y, A, b):\n        \"\"\"RHS of the LTI system dy/dt = Ay + b.\"\"\"\n        return A @ y + b\n\n    def simulate(A, b, y0, T, h, M):\n        \"\"\"\n        Simulates an LTI system and returns snapshots and blow-up status.\n        \"\"\"\n        num_steps = int(T / h)\n        y = y0.copy()\n        snapshots = [y0.copy()]\n        blew_up = False\n        \n        for _ in range(num_steps):\n            y = rk4_step(lti_rhs, y, h, A, b)\n            if not blew_up and (np.linalg.norm(y) > M or not np.all(np.isfinite(y))):\n                blew_up = True\n            snapshots.append(y.copy())\n            \n        return np.array(snapshots).T, blew_up\n\n    # General parameters\n    n = 2\n    h = 1e-3\n    M = 1e6\n    x0 = np.zeros(n)\n\n    # Test cases from the problem statement.\n    test_cases = [\n        # (A_params, r, T_train, T_test)\n        ({\"alpha\": 50.0}, 1, 4.0, 1.0),\n        ({\"alpha\": 50.0}, 2, 4.0, 1.0),\n        ({\"alpha\": None}, 1, 4.0, 1.0), # Symmetric case\n        ({\"alpha\": 120.0}, 1, 4.0, 1.0),\n    ]\n\n    results = []\n    \n    for i, (params, r, T_train, T_test) in enumerate(test_cases):\n        # 1. Define A\n        if i == 2: # Test 3: Symmetric case\n            A = np.array([[-1.0, 0.0], [0.0, -2.0]])\n        else: # Tests 1, 2, 4: Non-normal case\n            alpha = params[\"alpha\"]\n            A = np.array([[-0.1, alpha], [0.0, -1.0]])\n\n        # 2. Construct b\n        S = 0.5 * (A + A.T)\n        eigvals, eigvecs = eigh(S)\n        q = eigvecs[:, -1] # Dominant eigenvector (eigh sorts eigenvalues)\n        b = -A @ q\n\n        # 3. Generate FOM snapshots for training\n        X, _ = simulate(A, b, x0, T_train, h, M)\n\n        # 4. Compute POD basis Q\n        U, s, _ = np.linalg.svd(X, full_matrices=False)\n        Q = U[:, :r]\n\n        # 5. Calculate reconstruction error\n        # eps_rec = norm(X - Q @ Q.T @ X) / norm(X)\n        # Using singular values is more direct: sqrt(sum(s_i^2 for i>r)) / sqrt(sum(s_i^2))\n        if X.shape[1] > 1:\n            norm_X_sq = np.sum(s**2)\n            if norm_X_sq > 0:\n                norm_err_sq = np.sum(s[r:]**2)\n                eps_rec = np.sqrt(norm_err_sq / norm_X_sq)\n            else:\n                eps_rec = 0.0\n        else:\n            eps_rec = 0.0\n\n\n        # 6. Form the ROM\n        Ar = Q.T @ A @ Q\n        br = Q.T @ b\n        z0 = np.zeros(r)\n\n        # 7. Simulate FOM and ROM for testing, check blow-up\n        _, fom_blew_up = simulate(A, b, x0, T_test, h, M)\n        _, rom_blew_up = simulate(Ar, br, z0, T_test, h, M)\n\n        # 8. Record results\n        results.append([round(eps_rec, 6), rom_blew_up, fom_blew_up])\n\n    # Final print statement in the exact required format.\n    # Convert bools to lowercase 'true'/'false' for JS-like format\n    formatted_results = []\n    for res in results:\n        eps_str = f\"{res[0]:.6f}\"\n        rom_bool_str = str(res[1]).lower()\n        fom_bool_str = str(res[2]).lower()\n        formatted_results.append(f\"[{eps_str},{rom_bool_str},{fom_bool_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}