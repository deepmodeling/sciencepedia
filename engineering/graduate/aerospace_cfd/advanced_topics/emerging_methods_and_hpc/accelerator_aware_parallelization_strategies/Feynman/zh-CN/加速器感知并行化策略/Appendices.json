{
    "hands_on_practices": [
        {
            "introduction": "占用率（Occupancy）是衡量图形处理器（GPU）硬件利用率的关键指标。理解占用率不仅仅是查询一个性能分析工具的输出，更重要的是要明白它是由硬件资源（如寄存器和共享内存）的根本限制以及内核启动参数共同决定的。本练习将引导你从第一性原理出发，推导占用率的上限表达式，从而深刻理解每个线程的资源消耗与可实现的并行度之间的直接权衡关系 。",
            "id": "3940860",
            "problem": "考虑一个用于航空航天计算流体动力学（CFD）的可压缩纳维-斯托克斯求解器，该求解器在图形处理器（GPU）上推进面法向通量。该求解器采用单指令多线程（SIMT）执行模型和协作线程阵列，其中每个线程块将面和单元数据暂存到共享内存中，以计算网格瓦片的对流和扩散通量贡献。该核函数专为流式多处理器（SM）设计，SM 具有一个寄存器文件和一个共享内存池，这些资源在并发驻留的线程块之间进行划分。\n\n假设核函数中的每个线程需要 $r$ 个架构寄存器，每个线程块启动 $T_b$ 个线程，并且每个线程块分配 $s$ 字节的共享内存。SM 可提供共 $R_{\\text{SM}}$ 个寄存器和共 $S_{\\text{SM}}$ 字节的共享内存，这些资源可分配给驻留的线程块。每个 SM 的最大驻留线程数为 $T_{\\text{SM}}$，线程束大小为 $W$，占用率定义为活跃线程束与每个 SM 上硬件最大驻留线程束的比率。\n\n仅从以下基本事实出发：\n1. 寄存器和共享内存是 SM 上的有限资源；一个驻留块消耗 $r T_b$ 个寄存器和 $s$ 字节共享内存，多个驻留块的消耗量会累加。\n2. 线程束是调度的基本单元；一个包含 $T_b$ 个线程的块包含 $\\lceil T_b / W \\rceil$ 个线程束，每个 SM 的硬件最大驻留线程束数等于 $T_{\\text{SM}} / W$。\n3. 占用率等于活跃线程束的数量除以硬件最大驻留线程束的数量。\n\n请从第一性原理出发，推导一个仅由有限的寄存器和共享内存施加的占用率上限的闭式解析表达式（忽略所有其他约束，如每个 SM 的最大块数和每个 SM 的最大线程数，除非它们在归一化占用率中起作用）。将您的最终结果表示为关于 $r$、$s$、$T_b$、$R_{\\text{SM}}$、$S_{\\text{SM}}$、$T_{\\text{SM}}$ 和 $W$ 的单个解析表达式。无需进行数值评估。无需单位。",
            "solution": "该问题要求推导图形处理器（GPU）流式多处理器（SM）上占用率上限的闭式解析表达式，且仅考虑寄存器和共享内存资源施加的约束。占用率（我们用 $O$ 表示）是衡量硬件利用率的关键指标。\n\n首先，我们从给定的占用率定义（基本事实3）开始：\n$$\nO = \\frac{\\text{活跃线程束数量}}{\\text{最大可能驻留线程束数量}}\n$$\n\n分母，即一个 SM 上可能的最大驻留线程束数量，是一个固定的硬件特性。根据基本事实2，这个最大值是一个 SM 可以支持的总线程数 $T_{\\text{SM}}$ 除以一个线程束中的线程数 $W$。我们将其记为 $W_{\\text{max}}$。\n$$\nW_{\\text{max}} = \\frac{T_{\\text{SM}}}{W}\n$$\n问题指明线程束是调度的基本单元，因此这个比率正确地表示了最大线程束容量。\n\n接下来，我们必须确定分子：活跃线程束的数量。这个数量不是固定的，而是取决于核函数的资源需求。活跃线程束的数量 $W_{\\text{active}}$ 是可以在 SM 上并发驻留的线程块数量（我们记为 $N_b$）与每个线程块的线程束数量（记为 $W_b$）的乘积。\n$$\nW_{\\text{active}} = N_b \\times W_b\n$$\n\n每个块的线程束数量 $W_b$ 由每个块的线程数 $T_b$ 和线程束大小 $W$ 决定。由于线程被分组为离散的线程束，任何不完整的线程束仍然需要分配一个完整的线程束。因此，我们必须使用向上取整函数。根据基本事实2，我们有：\n$$\nW_b = \\left\\lceil \\frac{T_b}{W} \\right\\rceil\n$$\n\n关键步骤是找到 $N_b$（最大并发驻留块数）的表达式。问题陈述规定，这个数量*仅*受寄存器和共享内存可用性的限制。根据基本事实1，这些资源是有限的，并在驻留块之间进行分配。\n\n我们首先考虑寄存器文件施加的约束。SM 共有 $R_{\\text{SM}}$ 个寄存器。每个线程需要 $r$ 个寄存器，一个线程块包含 $T_b$ 个线程。因此，单个线程块消耗的寄存器总数为 $r T_b$。寄存器文件可以容纳的最大块数 $N_{b,R}$ 是可用寄存器总数除以每块消耗的寄存器数。由于块是不可分割的实体，我们必须对这个比率作向下取整。\n$$\nN_{b,R} = \\left\\lfloor \\frac{R_{\\text{SM}}}{r T_b} \\right\\rfloor\n$$\n\n其次，我们考虑共享内存施加的约束。SM 共有 $S_{\\text{SM}}$ 字节的共享内存。每个线程块分配 $s$ 字节。可用共享内存可以容纳的最大块数 $N_{b,S}$ 是共享内存总量除以每块消耗的数量。同样，我们必须使用向下取整函数。\n$$\nN_{b,S} = \\left\\lfloor \\frac{S_{\\text{SM}}}{s} \\right\\rfloor\n$$\n\n为了让一个线程块在 SM 上启动并驻留，必须有足够的寄存器和共享内存*两种*资源。因此，实际的最大驻留块数 $N_b$ 由这两个约束中更严格的一个决定。这可以通过取两个计算出的极限中的最小值来找到。\n$$\nN_b = \\min(N_{b,R}, N_{b,S}) = \\min\\left(\\left\\lfloor \\frac{R_{\\text{SM}}}{r T_b} \\right\\rfloor, \\left\\lfloor \\frac{S_{\\text{SM}}}{s} \\right\\rfloor\\right)\n$$\n\n现在我们拥有了构建占用率 $O$ 最终表达式所需的所有组件。将 $W_{\\text{active}}$ 和 $W_{\\text{max}}$ 的表达式代入占用率的初始定义中：\n$$\nO = \\frac{W_{\\text{active}}}{W_{\\text{max}}} = \\frac{N_b \\times W_b}{T_{\\text{SM}} / W}\n$$\n代入我们为 $N_b$ 和 $W_b$ 推导出的表达式：\n$$\nO = \\frac{\\min\\left(\\left\\lfloor \\frac{R_{\\text{SM}}}{r T_b} \\right\\rfloor, \\left\\lfloor \\frac{S_{\\text{SM}}}{s} \\right\\rfloor\\right) \\times \\left\\lceil \\frac{T_b}{W} \\right\\rceil}{\\frac{T_{\\text{SM}}}{W}}\n$$\n将此表达式重新整理为其最终的闭式解析形式，即可得到作为指定参数函数的占用率上限。\n$$\nO = \\frac{W}{T_{\\text{SM}}} \\min\\left(\\left\\lfloor \\frac{R_{\\text{SM}}}{r T_b} \\right\\rfloor, \\left\\lfloor \\frac{S_{\\text{SM}}}{s} \\right\\rfloor\\right) \\left\\lceil \\frac{T_b}{W} \\right\\rceil\n$$\n该表达式表示由核函数的寄存器和共享内存占用所施加的理论占用率上限，它是严格从所提供的第一性原理推导出来的。",
            "answer": "$$\\boxed{\\frac{W}{T_{\\text{SM}}} \\min\\left(\\left\\lfloor \\frac{R_{\\text{SM}}}{r T_b} \\right\\rfloor, \\left\\lfloor \\frac{S_{\\text{SM}}}{s} \\right\\rfloor\\right) \\left\\lceil \\frac{T_b}{W} \\right\\rceil}$$"
        },
        {
            "introduction": "在掌握了底层的硬件占用率概念之后，我们转向一个更宏观的性能预测工具——Roofline模型。该模型能够清晰地揭示一个计算核心（kernel）的性能瓶颈在于计算能力还是内存带宽。本练习将运用Roofline模型，通过分析两种常用优化策略——改变数据布局（SoA）和核函数融合（kernel fusion）——对算术强度（arithmetic intensity）的影响，来评估它们的性能提升潜力 。",
            "id": "3940816",
            "problem": "一个在非结构化网格上的有限体积法可压缩纳维-斯托克斯残差核被映射到图形处理单元（GPU）加速器上。对于此核，您已经测量了其算术强度，定义为浮点运算次数与片外数据移动量之比，$I \\equiv \\frac{\\text{FLOPs}}{\\text{bytes}}$，对于当前的结构数组（array-of-structures）数据布局，其值为 $I_{0} = 0.60\\,\\text{FLOP/byte}$。目标加速器具有峰值浮点吞吐量 $P_{\\text{peak}}$ 和持续片外内存带宽 $B$，分别取值为 $P_{\\text{peak}} = 19.5\\times 10^{12}\\,\\text{FLOP s}^{-1}$ 和 $B = 1.6\\times 10^{12}\\,\\text{byte s}^{-1}$。假设 Roofline 性能模型适用，且算术强度是在高带宽内存（HBM）级别测量的。\n\n考虑两种面向加速器的并行化和数据移动策略：\n1. 一种数组结构（structure-of-arrays, SoA）数据布局，它在浮点工作量相同的情况下，将片外数据流量减少 $25\\%$（也就是说，片外字节数变为基线的 $0.75$ 倍），而浮点运算次数没有变化。\n2. 将 $s$ 个连续的物理更新（例如，通量和源项的应用）进行核融合（kernel fusion），这将浮点运算次数乘以 $s$，同时在片外数据加载一次后完全重用（也就是说，相对于未融合的情况，片外字节数保持不变）。\n\n仅使用以下基本依据：\n- 算术强度的定义 $I = \\frac{\\text{FLOPs}}{\\text{bytes}}$。\n- 性能的定义 $P = \\frac{\\text{FLOPs}}{t}$，以及带宽限制的时间 $t_{\\text{mem}} \\ge \\frac{\\text{bytes}}{B}$ 和计算限制的时间 $t_{\\text{comp}} \\ge \\frac{\\text{FLOPs}}{P_{\\text{peak}}}$。\n- Roofline 性能上限 $P_{\\text{roof}} = \\min\\!\\big(P_{\\text{peak}},\\, I\\,B\\big)$。\n\n任务：\n- 使用 Roofline 模型计算以下四种情况的预期持续性能（单位为 $\\text{GFLOP s}^{-1}$）：基线、仅 SoA、仅融合（$s=3$）以及 SoA 加融合（$s=3$）。\n- 然后，确定最小正整数融合因子 $s_{\\min}$，使得在应用 SoA 优化后，该核在 Roofline 模型下变为计算密集型（compute-bound），即 $I_{\\text{SoA}\\,+\\,s_{\\min}}\\,B \\ge P_{\\text{peak}}$。\n\n将四种性能以 $\\text{GFLOP s}^{-1}$ 为单位表示，并四舍五入到四位有效数字。将您的最终答案以行向量 $\\big[P_{\\text{base}},\\,P_{\\text{SoA}},\\,P_{\\text{fuse}},\\,P_{\\text{SoA+fuse}},\\,s_{\\min}\\big]$ 的形式报告。请注意，$1\\,\\text{GFLOP s}^{-1} = 10^{9}\\,\\text{FLOP s}^{-1}$ 且 $1\\,\\text{TB s}^{-1} = 10^{12}\\,\\text{byte s}^{-1}$。",
            "solution": "用户希望使用 Roofline 性能模型分析计算流体动力学（CFD）核在 GPU 上的性能。首先验证问题的正确性和可解性。\n\n### 步骤 1：提取已知条件\n- 基线算术强度：$I_{0} = 0.60\\,\\text{FLOP/byte}$\n- 峰值浮点吞吐量：$P_{\\text{peak}} = 19.5\\times 10^{12}\\,\\text{FLOP s}^{-1}$\n- 持续片外内存带宽：$B = 1.6\\times 10^{12}\\,\\text{byte s}^{-1}$\n- Roofline 性能模型：$P_{\\text{roof}} = \\min\\!\\big(P_{\\text{peak}},\\, I\\,B\\big)$\n- SoA 优化：将片外数据减少 $25\\%$，即 $\\text{bytes}_{\\text{new}} = 0.75 \\times \\text{bytes}_{\\text{old}}$。浮点运算（$\\text{FLOPs}$）次数不变。\n- 核融合优化：将 $\\text{FLOPs}$ 乘以一个因子 $s$。片外数据（$\\text{bytes}$）不变。\n- 用于性能计算的特定融合因子：$s=3$。\n- 任务 1：计算四种情况的持续性能：基线、仅 SoA、仅融合（$s=3$）以及 SoA 加融合（$s=3$）。性能值必须以 $\\text{GFLOP s}^{-1}$ 为单位，并四舍五入到四位有效数字。\n- 任务 2：确定使 SoA 优化的核变为计算密集型所需的最小正整数融合因子 $s_{\\min}$。\n- 计算密集型条件：$I\\,B \\ge P_{\\text{peak}}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，使用了标准的 Roofline 模型，这是高性能计算性能分析的基石。算术强度、数据布局（AoS/SoA）和核融合等概念是 GPU 计算和并行编程的基础。所提供的峰值性能和内存带宽的数值对于当代加速器硬件是符合实际的。该问题定义明确，提供了所有必要的定义、数据和约束，可以得出一个唯一的、有意义的解决方案。语言客观而精确。该问题是性能建模原理的标准应用，没有违反任何指定的无效标准。\n\n### 步骤 3：结论和行动\n问题有效。将提供详细的解决方案。\n\n### 解题推导\n解决方案涉及将 Roofline 模型 $P_{\\text{roof}} = \\min(P_{\\text{peak}}, I \\cdot B)$ 应用于每个指定场景。问题的核心是确定每种优化策略如何影响算术强度 $I = \\text{FLOPs}/\\text{bytes}$。\n\n首先，我们计算加速器的临界算术强度，或称“屋脊点”（ridge point）$I_{\\text{crit}}$。这是当内存性能天花板等于峰值计算性能时的 $I$ 值。\n$$I_{\\text{crit}} = \\frac{P_{\\text{peak}}}{B} = \\frac{19.5 \\times 10^{12}\\,\\text{FLOP s}^{-1}}{1.6 \\times 10^{12}\\,\\text{byte s}^{-1}} = 12.1875\\,\\text{FLOP/byte}$$\n如果一个核的算术强度 $I$ 小于 $I_{\\text{crit}}$，其性能受内存带宽限制（$P = I \\cdot B$）。如果 $I \\ge I_{\\text{crit}}$，其性能受峰值计算吞吐量限制（$P = P_{\\text{peak}}$）。\n\n设基线浮点运算次数为 $\\text{FLOPs}_0$，基线数据移动字节数为 $\\text{bytes}_0$。基线算术强度为 $I_0 = \\frac{\\text{FLOPs}_0}{\\text{bytes}_0} = 0.60\\,\\text{FLOP/byte}$。\n\n**情况 1：基线**\n给定的算术强度为 $I_{\\text{base}} = I_0 = 0.60\\,\\text{FLOP/byte}$。\n由于 $I_{\\text{base}} = 0.60  12.1875 = I_{\\text{crit}}$，该核是内存密集型（memory-bound）。\n预期性能 $P_{\\text{base}}$ 为：\n$$P_{\\text{base}} = I_{\\text{base}} \\cdot B = 0.60\\,\\text{FLOP/byte} \\times 1.6 \\times 10^{12}\\,\\text{byte s}^{-1} = 0.96 \\times 10^{12}\\,\\text{FLOP s}^{-1}$$\n转换为 $\\text{GFLOP s}^{-1}$（$1\\,\\text{GFLOP s}^{-1} = 10^9\\,\\text{FLOP s}^{-1}$）：\n$$P_{\\text{base}} = 0.96 \\times 10^3\\,\\text{GFLOP s}^{-1} = 960\\,\\text{GFLOP s}^{-1}$$\n四舍五入到四位有效数字，结果为 $960.0\\,\\text{GFLOP s}^{-1}$。\n\n**情况 2：仅 SoA**\n数组结构（SoA）数据布局在 FLOP 次数保持不变的情况下，将数据流量减少了 $25\\%$。\n$$\\text{FLOPs}_{\\text{SoA}} = \\text{FLOPs}_0$$\n$$\\text{bytes}_{\\text{SoA}} = 0.75 \\cdot \\text{bytes}_0$$\n新的算术强度 $I_{\\text{SoA}}$ 为：\n$$I_{\\text{SoA}} = \\frac{\\text{FLOPs}_{\\text{SoA}}}{\\text{bytes}_{\\text{SoA}}} = \\frac{\\text{FLOPs}_0}{0.75 \\cdot \\text{bytes}_0} = \\frac{1}{0.75} I_0 = \\frac{4}{3} I_0 = \\frac{4}{3} \\cdot 0.60 = 0.80\\,\\text{FLOP/byte}$$\n由于 $I_{\\text{SoA}} = 0.80  I_{\\text{crit}}$，该核仍然是内存密集型。\n$$P_{\\text{SoA}} = I_{\\text{SoA}} \\cdot B = 0.80\\,\\text{FLOP/byte} \\times 1.6 \\times 10^{12}\\,\\text{byte s}^{-1} = 1.28 \\times 10^{12}\\,\\text{FLOP s}^{-1}$$\n以 $\\text{GFLOP s}^{-1}$ 为单位：\n$$P_{\\text{SoA}} = 1.28 \\times 10^3\\,\\text{GFLOP s}^{-1} = 1280\\,\\text{GFLOP s}^{-1}$$\n该值有四位有效数字。\n\n**情况 3：仅融合 ($s=3$)**\n使用因子 $s=3$ 进行核融合，使得在相同数据传输量下，FLOP 次数变为三倍。\n$$\\text{FLOPs}_{\\text{fuse}} = 3 \\cdot \\text{FLOPs}_0$$\n$$\\text{bytes}_{\\text{fuse}} = \\text{bytes}_0$$\n新的算术强度 $I_{\\text{fuse}}$ 为：\n$$I_{\\text{fuse}} = \\frac{3 \\cdot \\text{FLOPs}_0}{\\text{bytes}_0} = 3 \\cdot I_0 = 3 \\cdot 0.60 = 1.80\\,\\text{FLOP/byte}$$\n由于 $I_{\\text{fuse}} = 1.80  I_{\\text{crit}}$，该核仍然是内存密集型。\n$$P_{\\text{fuse}} = I_{\\text{fuse}} \\cdot B = 1.80\\,\\text{FLOP/byte} \\times 1.6 \\times 10^{12}\\,\\text{byte s}^{-1} = 2.88 \\times 10^{12}\\,\\text{FLOP s}^{-1}$$\n以 $\\text{GFLOP s}^{-1}$ 为单位：\n$$P_{\\text{fuse}} = 2.88 \\times 10^3\\,\\text{GFLOP s}^{-1} = 2880\\,\\text{GFLOP s}^{-1}$$\n该值有四位有效数字。\n\n**情况 4：SoA 加融合 ($s=3$)**\n同时应用两种优化。FLOP 次数变为三倍，数据流量减少 $25\\%$。\n$$\\text{FLOPs}_{\\text{SoA+fuse}} = 3 \\cdot \\text{FLOPs}_0$$\n$$\\text{bytes}_{\\text{SoA+fuse}} = 0.75 \\cdot \\text{bytes}_0$$\n新的算术强度 $I_{\\text{SoA+fuse}}$ 为：\n$$I_{\\text{SoA+fuse}} = \\frac{3 \\cdot \\text{FLOPs}_0}{0.75 \\cdot \\text{bytes}_0} = \\frac{3}{0.75} I_0 = 4 \\cdot I_0 = 4 \\cdot 0.60 = 2.40\\,\\text{FLOP/byte}$$\n由于 $I_{\\text{SoA+fuse}} = 2.40  I_{\\text{crit}}$，该核仍然是内存密集型。\n$$P_{\\text{SoA+fuse}} = I_{\\text{SoA+fuse}} \\cdot B = 2.40\\,\\text{FLOP/byte} \\times 1.6 \\times 10^{12}\\,\\text{byte s}^{-1} = 3.84 \\times 10^{12}\\,\\text{FLOP s}^{-1}$$\n以 $\\text{GFLOP s}^{-1}$ 为单位：\n$$P_{\\text{SoA+fuse}} = 3.84 \\times 10^3\\,\\text{GFLOP s}^{-1} = 3840\\,\\text{GFLOP s}^{-1}$$\n该值有四位有效数字。\n\n**任务 2：最小融合因子 $s_{\\min}$**\n我们需要找到最小的正整数 $s$，使得经过 SoA 和融合优化的核变为计算密集型。计算密集型的条件是 $I \\ge I_{\\text{crit}}$。\n结合 SoA 和融合（使用一个通用因子 $s$）的算术强度为：\n$$I_{\\text{SoA}+s} = \\frac{s \\cdot \\text{FLOPs}_0}{0.75 \\cdot \\text{bytes}_0} = \\frac{s}{0.75} I_0 = \\frac{4s}{3} I_0$$\n将其设为大于或等于临界强度：\n$$\\frac{4s}{3} I_0 \\ge I_{\\text{crit}}$$\n现在我们求解 $s$：\n$$s \\ge \\frac{3 \\cdot I_{\\text{crit}}}{4 \\cdot I_0}$$\n代入数值：\n$$s \\ge \\frac{3 \\cdot 12.1875}{4 \\cdot 0.60} = \\frac{36.5625}{2.4} = 15.234375$$\n由于融合因子 $s$ 必须是正整数，满足此不等式的最小值 $s_{\\min}$ 是大于或等于 $15.234375$ 的最小整数。\n$$s_{\\min} = \\lceil 15.234375 \\rceil = 16$$\n\n所要求的五个值为：\n- $P_{\\text{base}} = 960.0\\,\\text{GFLOP s}^{-1}$\n- $P_{\\text{SoA}} = 1280\\,\\text{GFLOP s}^{-1}$\n- $P_{\\text{fuse}} = 2880\\,\\text{GFLOP s}^{-1}$\n- $P_{\\text{SoA+fuse}} = 3840\\,\\text{GFLOP s}^{-1}$\n- $s_{\\min} = 16$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n960.0  1280  2880  3840  16\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "从理论评估过渡到具体的数值计算，我们可以更精确地量化优化策略带来的收益。核函数融合是优化内存密集型应用的关键技术，因为它避免了将中间结果写入和读出全局内存。本练习提供了一个源自计算流体动力学（CFD）求解器的实际场景，要求你基于内存流量和核函数执行时间等可测量，定量估算通过核函数融合可获得的加速比，从而将算术强度这一抽象概念与实际性能增益联系起来 。",
            "id": "3940885",
            "problem": "一个用于三维空间可压缩纳维-斯托克斯方程的显式有限体积求解器在图形处理单元（GPU）上执行。在一个时间步内，两个核函数被顺序启动：首先是斜率限制器核函数，然后是残差组装核函数。目标是利用测得的核函数时间和估计的设备内存带宽限制，来估算将这两个核函数融合成一个单一核函数所带来的加速比，这种融合避免了为中间的受限斜率产生全局内存流量。假设使用双精度（每个标量 $8$ 字节）。设控制体的数量为 $N = 2.0 \\times 10^{7}$，单元的平均价（每个单元的面数）为 $m = 6$。该求解器每个单元存储 $5$ 个守恒变量。现有以下设备级信息：\n\n- 估计的持续设备内存带宽限制：$B = 1.2 \\times 10^{12}$ 字节/秒。\n- 测得的限制器核函数墙上时间：$T_{\\ell} = 6.9$ 毫秒。\n- 测得的残差核函数墙上时间：$T_{r} = 6.3$ 毫秒。\n\n假设以下每个单元的内存访问模式具有代表性：\n\n- 限制器核函数（分别执行）：\n  - 从局部单元读取 $5$ 个守恒变量，并从其 $m$ 个相邻单元各读取 $5$ 个守恒变量，总共读取 $5\\,(1+m)$ 个双精度浮点数。\n  - 写入一个受限斜率向量，该向量包含 $5$ 个变量中每个变量的 $3$ 个分量，总共写入 $15$ 个双精度浮点数。\n- 残差核函数（分别执行）：\n  - 读取受限斜率向量，即 $15$ 个双精度浮点数。\n  - 读取每个面的几何数据：每个面一个包含 $3$ 个分量的面法线，总共读取 $3m$ 个双精度浮点数。\n  - 读取局部单元的 $5$ 个守恒变量，即 $5$ 个双精度浮点数。\n  - 写入 $5$ 个守恒变量的残差，即 $5$ 个双精度浮点数。\n- 融合核函数（单次执行）：\n  - 从局部单元及其相邻单元读取 $5\\,(1+m)$ 个守恒变量双精度浮点数。\n  - 读取每个面的几何数据，即 $3m$ 个双精度浮点数。\n  - 写入残差，即 $5$ 个双精度浮点数。\n  - 不向全局内存写入或从中读取受限斜率向量（受限斜率保留在寄存器或共享内存中并被立即消耗）。\n\n使用 Roofline 模型基于带宽限制的内存约束时间估计，即核函数执行时间的下界为总传输字节数与带宽之比。将融合核函数视为在给定限制 $B$ 下受内存带宽约束。将分别执行的总时间视为使用测量值计算的 $T_{\\ell}+T_{r}$ 之和。计算加速比 $S$，定义为分别执行的总时间与融合执行的时间之比。将最终加速比表示为一个纯数（无单位），并将答案四舍五入到 $4$ 位有效数字。在进行任何计算之前，将所有时间转换为秒。",
            "solution": "用户希望我遵循指定的角色、规则和格式来解决这个问题。\n\n**1. 问题验证**\n\n*   **步骤 1：提取给定信息**\n    *   求解器和方法：用于三维可压缩纳维-斯托克斯方程的显式有限体积法。\n    *   硬件：图形处理单元（GPU）。\n    *   核函数：斜率限制器和残差组装。\n    *   数据精度：双精度，即每个标量 $8$ 字节。\n    *   控制体数量：$N = 2.0 \\times 10^{7}$。\n    *   平均单元价：$m = 6$。\n    *   守恒变量数量：每个单元 $5$ 个。\n    *   持续设备内存带宽限制：$B = 1.2 \\times 10^{12}$ 字节/秒。\n    *   测得的限制器核函数墙上时间：$T_{\\ell} = 6.9$ 毫秒。\n    *   测得的残差核函数墙上时间：$T_{r} = 6.3$ 毫秒。\n    *   每个单元的内存访问（分别执行的核函数）：\n        *   限制器读取：$5(1+m)$ 个双精度浮点数。\n        *   限制器写入：$15$ 个双精度浮点数。\n        *   残差读取：$15$ 个双精度浮点数（斜率）、$3m$ 个双精度浮点数（几何数据）、$5$ 个双精度浮点数（局部单元变量）。\n        *   残差写入：$5$ 个双精度浮点数。\n    *   每个单元的内存访问（融合核函数）：\n        *   读取：$5(1+m)$ 个双精度浮点数（守恒变量）、$3m$ 个双精度浮点数（几何数据）。\n        *   写入：$5$ 个双精度浮点数（残差）。\n        *   中间数据（受限斜率）不与全局内存进行传输。\n    *   建模假设：\n        *   融合核函数时间被估计为内存约束型：$T_{\\text{fused}} = (\\text{总字节数}) / B$。\n        *   分别执行的核函数总时间是测量时间的总和：$T_{\\text{separate}} = T_{\\ell} + T_{r}$。\n    *   目标：计算加速比 $S = T_{\\text{separate}} / T_{\\text{fused}}$。\n    *   输出格式：四舍五入到 $4$ 位有效数字。\n\n*   **步骤 2：使用提取的给定信息进行验证**\n    *   **科学基础**：该问题在计算流体动力学（CFD）和高性能计算（HPC）领域具有坚实的科学基础。核函数融合是针对 GPU 等加速器上内存约束问题的标准优化技术。Roofline 模型是一个被广泛接受的性能模型。物理和计算参数（网格大小、带宽、核函数时间）对于现代硬件和大规模模拟是符合实际的。\n    *   **适定性**：该问题是适定的，提供了所有必要的数据、清晰的定义和具体的目标。可以获得唯一的数值解。\n    *   **客观性**：语言技术性强、精确且没有主观性。\n    *   **完整性和一致性**：该问题是自洽的。数据依赖关系是合乎逻辑的（限制器产生斜率，残差消耗它们），并且对核函数融合的描述正确地指出了消除中间内存流量是性能提升的来源。没有矛盾之处。\n    *   **无其他缺陷**：该问题是一个标准的性能估算任务，并非琐碎、不适定或科学上不合理。\n\n*   **步骤 3：结论与行动**\n    *   该问题被视为**有效**。我将继续进行求解。\n\n**2. 详细解法**\n\n目标是计算加速比 $S$，它被定义为分别执行核函数的总时间 $T_{\\text{separate}}$ 与融合核函数执行的估计时间 $T_{\\text{fused}}$ 之比。\n$$S = \\frac{T_{\\text{separate}}}{T_{\\text{fused}}}$$\n求解过程分为三个步骤：计算 $T_{\\text{separate}}$，估计 $T_{\\text{fused}}$，最后计算它们的比值 $S$。\n\n首先，我们使用测得的墙上时间计算两个核函数分别执行的总时间。问题提供了 $T_{\\ell} = 6.9 \\text{ ms}$ 和 $T_{r} = 6.3 \\text{ ms}$。我们必须按要求将这些时间转换为秒。\n$$T_{\\ell} = 6.9 \\times 10^{-3} \\text{ s}$$\n$$T_{r} = 6.3 \\times 10^{-3} \\text{ s}$$\n分别执行的总时间是这两个时间之和：\n$$T_{\\text{separate}} = T_{\\ell} + T_{r} = (6.9 + 6.3) \\times 10^{-3} \\text{ s} = 13.2 \\times 10^{-3} \\text{ s}$$\n\n接下来，我们估计融合核函数的执行时间 $T_{\\text{fused}}$。问题指出，这应该使用 Roofline 模型的内存约束假设来完成，即时间等于总传输数据量除以内存带宽。\n$$T_{\\text{fused}} = \\frac{\\text{Bytes}_{\\text{total}}}{B}$$\n我们必须首先确定总传输字节数 $\\text{Bytes}_{\\text{total}}$。设 $D_{\\text{size}}$ 是一个双精度标量的大小，给定为 $8$ 字节。\n融合核函数每个单元的内存访问模式是：\n- 读取：用于守恒变量的 $5(1+m)$ 个双精度浮点数和用于几何数据的 $3m$ 个双精度浮点数。\n- 写入：用于残差的 $5$ 个双精度浮点数。\n由 $15$ 个双精度浮点数组成的受限斜率在核函数内部生成和消耗，不写入全局内存，也不从全局内存读取。\n每个单元传输的双精度浮点数总数 $C_{\\text{doubles}}$ 是读取和写入的总和：\n$$C_{\\text{doubles}} = \\left( 5(1+m) + 3m \\right) + 5 = 5 + 5m + 3m + 5 = 10 + 8m$$\n给定平均单元价 $m=6$：\n$$C_{\\text{doubles}} = 10 + 8(6) = 10 + 48 = 58 \\text{ doubles/cell}$$\n所有 $N$ 个单元传输的总数据量（以字节为单位）为：\n$$\\text{Bytes}_{\\text{total}} = N \\times C_{\\text{doubles}} \\times D_{\\text{size}}$$\n使用给定值 $N = 2.0 \\times 10^{7}$，$C_{\\text{doubles}} = 58$ 和 $D_{\\text{size}} = 8$：\n$$\\text{Bytes}_{\\text{total}} = (2.0 \\times 10^{7}) \\times 58 \\times 8 = 928 \\times 10^{7} \\text{ bytes} = 9.28 \\times 10^{9} \\text{ bytes}$$\n现在，我们可以使用持续内存带宽 $B = 1.2 \\times 10^{12} \\text{ 字节/秒}$ 来计算 $T_{\\text{fused}}$：\n$$T_{\\text{fused}} = \\frac{9.28 \\times 10^{9} \\text{ bytes}}{1.2 \\times 10^{12} \\text{ bytes/s}} = \\frac{9.28}{1.2} \\times 10^{-3} \\text{ s} \\approx 7.7333 \\times 10^{-3} \\text{ s}$$\n\n最后，我们计算加速比 $S$：\n$$S = \\frac{T_{\\text{separate}}}{T_{\\text{fused}}} = \\frac{13.2 \\times 10^{-3} \\text{ s}}{7.7333... \\times 10^{-3} \\text{ s}} = \\frac{13.2}{7.7333...} = \\frac{13.2}{9.28/1.2} = \\frac{13.2 \\times 1.2}{9.28} = \\frac{15.84}{9.28}$$\n$$S \\approx 1.70689655...$$\n问题要求答案四舍五入到 $4$ 位有效数字。\n$$S \\approx 1.707$$",
            "answer": "$$\n\\boxed{1.707}\n$$"
        }
    ]
}