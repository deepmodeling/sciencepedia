{
    "hands_on_practices": [
        {
            "introduction": "定义了核函数之后，下一步是利用它来近似微分算子，例如梯度。在流体动力学中，梯度算子对于计算压力梯度力等至关重要。本计算练习将指导你实现 SPH 梯度算子，并使用“人造解方法”（Method of Manufactured Solutions）来验证其精度，这是一种确保代码正确性的关键计算科学技能。通过这项实践，你将能评估 SPH 梯度近似的收敛阶，从而建立对数值实现正确性的信心。",
            "id": "3994498",
            "problem": "考虑在单位正方形域 $[0,1] \\times [0,1]$上定义的人工向量场 $\\mathbf{v}(x,y) = (x^2, y^2)$。在光滑粒子流体动力学（SPH）中，连续场由具有均匀质量和密度的粒子表示。设粒子布局为均匀的笛卡尔网格，两个方向上的间距均为 $\\Delta x$，均匀密度 $\\rho = 1$（无量纲），粒子质量 $m = \\Delta x^2$。光滑长度为 $h = \\alpha \\Delta x$，其中 $\\alpha$ 是一个正常数。使用具有紧支集 $2h$ 的二维经典三次样条SPH核函数，其表达式为\n$$\nW(q;h) =\n\\begin{cases}\n\\dfrac{\\sigma}{h^2} \\left(1 - \\dfrac{3}{2} q^2 + \\dfrac{3}{4} q^3 \\right), & 0 \\le q  1, \\\\\n\\dfrac{\\sigma}{h^2} \\left(\\dfrac{1}{4} (2 - q)^3 \\right),  1 \\le q  2, \\\\\n0,  q \\ge 2,\n\\end{cases}\n$$\n其中 $q = r/h$，$r = \\|\\mathbf{r}\\|$，二维归一化常数 $\\sigma = \\dfrac{10}{7\\pi}$。核函数梯度为 $\\nabla W(\\mathbf{r};h) = \\dfrac{\\partial W}{\\partial r} \\dfrac{\\mathbf{r}}{r}$，其中 $\\dfrac{\\partial W}{\\partial r} = \\dfrac{\\sigma}{h^3} \\dfrac{d \\Phi}{d q}(q)$ 且\n$$\n\\dfrac{d \\Phi}{d q}(q) =\n\\begin{cases}\n-3 q + \\dfrac{9}{4} q^2,  0 \\le q  1, \\\\\n-\\dfrac{3}{4} (2 - q)^2,  1 \\le q  2, \\\\\n0,  q \\ge 2.\n\\end{cases}\n$$\n从连续SPH插值的角度出发，一个标量场 $f(\\mathbf{x})$ 可以通过核函数加权积分来近似，其梯度可以通过在积分号下求导来近似。以此为基础，为 $\\mathbf{v}$ 的每个标量分量推导出一个一致的离散SPH梯度算子，该算子用粒子质量、密度和核函数梯度表示。实现您推导的离散算子，以在粒子位置逐分量地近似雅可比矩阵 $\\nabla \\mathbf{v}$。\n\n为避免核函数支集在边界处被截断，将误差评估限制在“内部”粒子集上，这些粒子与每个域边界的距离至少为 $2h$。对于每个位于位置 $(x_i,y_i)$ 的内部粒子，计算近似雅可比矩阵\n$$\n\\nabla \\mathbf{v}(\\mathbf{x}_i) \\approx\n\\begin{pmatrix}\n\\partial_x (x^2)  \\partial_y (x^2) \\\\\n\\partial_x (y^2)  \\partial_y (y^2)\n\\end{pmatrix}_{\\text{SPH}},\n$$\n并将其与精确雅可比矩阵进行比较\n$$\n\\nabla \\mathbf{v}_{\\text{exact}}(x_i,y_i) =\n\\begin{pmatrix}\n2x_i  0 \\\\\n0  2y_i\n\\end{pmatrix}.\n$$\n通过近似雅可比矩阵与精确雅可比矩阵之差的弗罗贝尼乌斯范数来衡量每个内部粒子的误差，并通过均方根（RMS）在所有内部粒子上汇总误差\n$$\nE(\\Delta x, \\alpha) = \\sqrt{\\dfrac{1}{N_{\\text{int}}} \\sum_{i \\in \\text{interior}} \\left\\| \\nabla \\mathbf{v}_{\\text{SPH}}(\\mathbf{x}_i) - \\nabla \\mathbf{v}_{\\text{exact}}(\\mathbf{x}_i) \\right\\|_F^2 },\n$$\n其中 $N_{\\text{int}}$ 是内部粒子的数量。对于固定的 $\\alpha$，通过对 $(\\log \\Delta x, \\log E)$ 进行线性拟合并提取斜率 $p$ 来评估当 $\\Delta x$ 减小时SPH梯度近似的收敛性，该斜率 $p$ 作为由 $E \\propto (\\Delta x)^p$ 定义的观测精度阶。\n\n实现程序以计算以下测试套件中每个 $\\Delta x$ 对应的 $E$，并使用对所有提供的 $\\Delta x$ 值的最小二乘回归报告每个套件的观测阶数 $p$：\n\n- 测试用例1（理想情况）：$\\alpha = 1.0$，$\\Delta x \\in \\{0.2, 0.1, 0.05\\}$。\n- 测试用例2（核函数变化）：$\\alpha = 0.8$，$\\Delta x \\in \\{0.2, 0.1, 0.05\\}$。\n- 测试用例3（边界限制的内部，边界情况）：$\\alpha = 1.0$，$\\Delta x \\in \\{0.25, 0.125, 0.0625\\}$。\n\n所有计算都是无量纲的。此问题不涉及角度，因此不需要角度单位。您的程序应生成单行输出，其中包含三个观测到的阶数，以逗号分隔的列表形式包含在方括号内，每个数字四舍五入到六位小数（例如，\"[p1,p2,p3]\"）。",
            "solution": "该问题已经过验证，被认定是有效的。它在科学上基于光滑粒子流体动力学（SPH）的原理，这是一种标准的数值方法。该问题是适定的，提供了所有必要的定义、常数和参数，以计算出唯一且有意义的结果。语言客观明确，设置内部一致。\n\n任务的核心是推导并实现一个离散SPH梯度算子，以近似给定向量场的雅可比矩阵，并随后评估该近似的数值收敛性。\n\n**1. SPH梯度算子的推导**\n\nSPH方法始于使用具有特征光滑长度 $h$ 的光滑核函数 $W$ 对标量场 $f(\\mathbf{x})$ 进行的连续积分表示：\n$$\nf(\\mathbf{x}) \\approx \\int_{\\Omega} f(\\mathbf{x}') W(\\mathbf{x} - \\mathbf{x}', h) \\, d\\mathbf{x}'\n$$\n该场的梯度 $\\nabla f(\\mathbf{x})$ 是通过将梯度算子应用于积分表示来找到的。假设场 $f$ 和核函数 $W$ 具有足够好的性质，微分可以移到积分内部：\n$$\n\\nabla f(\\mathbf{x}) \\approx \\int_{\\Omega} f(\\mathbf{x}') \\nabla_{\\mathbf{x}} W(\\mathbf{x} - \\mathbf{x}', h) \\, d\\mathbf{x}'\n$$\n其中 $\\nabla_{\\mathbf{x}}$ 表示关于坐标 $\\mathbf{x}$ 的梯度。\n\n为了过渡到基于粒子的离散格式，域 $\\Omega$ 由一组粒子表示。积分被替换为对这些粒子的求和。每个位于位置 $\\mathbf{x}_j$ 的粒子 $j$ 具有质量 $m_j$ 和密度 $\\rho_j$。其关联的体积元为 $d\\mathbf{x}' \\approx V_j = m_j/\\rho_j$。因此，位于粒子 $i$ 位置 $\\mathbf{x}_i$ 处的梯度可通过求和近似为：\n$$\n\\nabla f(\\mathbf{x}_i) \\approx \\sum_j f(\\mathbf{x}_j) \\nabla_i W(\\mathbf{x}_i - \\mathbf{x}_j, h) V_j\n$$\n其中 $\\nabla_i W_{ij} \\equiv \\nabla_{\\mathbf{x}} W(\\mathbf{x} - \\mathbf{x}', h)|_{\\mathbf{x}=\\mathbf{x}_i, \\mathbf{x}'=\\mathbf{x}_j}$。\n\n问题要求推导一个“一致的”离散算子。一个基本的一致性要求是常数场的梯度必须为零。上面显示的直接离散化不能保证此属性。使用乘积法则恒等式 $\\nabla f = \\frac{1}{\\rho} \\nabla(\\rho f) - \\frac{f}{\\rho} \\nabla \\rho$ 可以获得更稳健的公式。将SPH离散化应用于 $\\rho f$ 和 $\\rho$ 的梯度，可得：\n$$\n\\nabla f_i \\approx \\frac{1}{\\rho_i} \\left( \\sum_j (\\rho_j f_j) \\frac{m_j}{\\rho_j} \\nabla_i W_{ij} \\right) - \\frac{f_i}{\\rho_i} \\left( \\sum_j \\rho_j \\frac{m_j}{\\rho_j} \\nabla_i W_{ij} \\right)\n$$\n简化并合并求和项，得到SPH梯度算子的“差分形式”：\n$$\n\\nabla f_i \\approx \\frac{1}{\\rho_i} \\sum_j m_j (f_j - f_i) \\nabla_i W_{ij}\n$$\n这种形式固有地满足了常数场（$f_j = f_i$）的梯度恰好为零的条件。由于问题指定了均匀密度 $\\rho=1$ 和均匀粒子质量 $m = \\Delta x^2$，我们将实现的算子是：\n$$\n\\nabla f_i = \\sum_j m \\left( f_j - f_i \\right) \\nabla_i W_{ij}\n$$\n其中求和遍及粒子 $i$ 的核函数支集半径内的所有相邻粒子 $j$。\n\n**2. 雅可比矩阵近似**\n\n向量场 $\\mathbf{v}(x,y) = (v_x, v_y)$ 的雅可比矩阵由 $\\nabla \\mathbf{v} = \\begin{pmatrix} \\partial_x v_x  \\partial_y v_x \\\\ \\partial_x v_y  \\partial_y v_y \\end{pmatrix}$ 给出。该矩阵的每个分量都是一个标量场的偏导数，我们使用上面推导的SPH梯度算子来近似它。对于粒子 $i$，SPH近似的雅可比矩阵为：\n$$\n(\\nabla \\mathbf{v}_{\\text{SPH}})_i = \\sum_j m (\\mathbf{v}_j - \\mathbf{v}_i) \\otimes \\nabla_i W_{ij}\n$$\n其中 $\\otimes$ 表示外积。这得到矩阵：\n$$\n(\\nabla \\mathbf{v}_{\\text{SPH}})_i = \\sum_j m\n\\begin{pmatrix}\n(v_{x,j} - v_{x,i}) \\frac{\\partial W_{ij}}{\\partial x_i}  (v_{x,j} - v_{x,i}) \\frac{\\partial W_{ij}}{\\partial y_i} \\\\\n(v_{y,j} - v_{y,i}) \\frac{\\partial W_{ij}}{\\partial x_i}  (v_{y,j} - v_{y,i}) \\frac{\\partial W_{ij}}{\\partial y_i}\n\\end{pmatrix}\n$$\n对于给定的场 $\\mathbf{v}(x,y) = (x^2, y^2)$，我们有 $v_x = x^2$ 和 $v_y = y^2$。\n\n核函数梯度 $\\nabla_i W_{ij}$ 使用提供的公式 $\\nabla W(\\mathbf{r};h) = \\frac{\\partial W}{\\partial r} \\frac{\\mathbf{r}}{r}$ 计算，其中 $\\mathbf{r} = \\mathbf{x}_i - \\mathbf{x}_j$。令 $r_{ij} = \\|\\mathbf{r}\\|$。\n$$\n\\nabla_i W_{ij} = \\frac{\\mathbf{x}_i - \\mathbf{x}_j}{r_{ij}} \\frac{\\partial W}{\\partial r}(r_{ij}; h) = \\frac{\\mathbf{x}_i - \\mathbf{x}_j}{r_{ij}} \\left( \\frac{\\sigma}{h^3} \\frac{d\\Phi}{dq}(q_{ij}) \\right)\n$$\n其中 $q_{ij} = r_{ij}/h$，$\\sigma = 10/(7\\pi)$，并且 $\\frac{d\\Phi}{dq}$ 由问题陈述中的分段函数给出。\n\n**3. 算法步骤**\n\n计算误差和收敛阶的总体算法如下：\n\n1.  **粒子生成**：对于给定的间距 $\\Delta x$，在域 $[0,1] \\times [0,1]$上创建均匀的笛卡尔粒子网格。粒子位置为 $\\mathbf{x}_{k,l} = (k \\Delta x, l \\Delta x)$，其中整数 $k,l$ 的取值应能覆盖整个域。\n\n2.  **识别内部粒子**：分析被限制在“内部”粒子上，以避免在边界处因核函数截断而产生的误差。如果位于位置 $(x_i, y_i)$ 的粒子到所有四个边界（$x=0, x=1, y=0, y=1$）的距离至少为核函数支集半径 $2h$，则该粒子是内部粒子。也就是说，$x_i \\in [2h, 1-2h]$ 且 $y_i \\in [2h, 1-2h]$，其中 $h=\\alpha \\Delta x$。\n\n3.  **雅可比矩阵和误差计算**：\n    对于每个内部粒子 $i$：\n    a. 将SPH雅可比矩阵 $(\\nabla \\mathbf{v}_{\\text{SPH}})_i$ 初始化为零。\n    b. 遍历所有其他粒子 $j$ 以寻找邻居。如果距离 $r_{ij} = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|$ 在范围 $(0, 2h)$ 内，则粒子 $j$ 是一个邻居。条件 $r_{ij} > 0$ 排除了粒子自身。\n    c. 对于每个邻居 $j$，计算核函数梯度 $\\nabla_i W_{ij}$ 和向量场差 $\\mathbf{v}_j - \\mathbf{v}_i$。\n    d. 计算对雅可比矩阵的贡献 $m (\\mathbf{v}_j - \\mathbf{v}_i) \\otimes \\nabla_i W_{ij}$，并将其加到 $(\\nabla \\mathbf{v}_{\\text{SPH}})_i$ 上。\n    e. 在对所有邻居求和后，计算在 $\\mathbf{x}_i$ 处的精确雅可比矩阵：$\\nabla \\mathbf{v}_{\\text{exact}}(x_i,y_i) = \\begin{pmatrix} 2x_i  0 \\\\ 0  2y_i \\end{pmatrix}$。\n    f. 计算误差矩阵的弗罗贝尼乌斯范数的平方：$E_i^2 = \\| (\\nabla \\mathbf{v}_{\\text{SPH}})_i - (\\nabla \\mathbf{v}_{\\text{exact}})_i \\|_F^2$。\n\n4.  **汇总RMS误差**：对所有 $N_{\\text{int}}$ 个内部粒子的平方误差求和，并计算均方根（RMS）误差：\n    $$\n    E(\\Delta x, \\alpha) = \\sqrt{\\frac{1}{N_{\\text{int}}} \\sum_{i \\in \\text{interior}} E_i^2}\n    $$\n\n5.  **收敛阶分析**：对于每个测试套件，我们获得一组与一组网格间距 $\\Delta x$ 对应的误差值 $E$。精度阶 $p$ 由关系 $E \\propto (\\Delta x)^p$ 定义。对两边取对数得到 $\\log E = p \\log \\Delta x + C$。因此，$p$ 是拟合数据点 $(\\log \\Delta x, \\log E)$ 的直线的斜率。对于每个测试用例，此斜率使用线性最小二乘回归计算。\n\n实现将针对指定的三个测试用例中的每一个遵循此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to execute the SPH convergence study as per the problem statement.\n    \"\"\"\n\n    test_cases = [\n        {\"alpha\": 1.0, \"dx_values\": [0.2, 0.1, 0.05]},\n        {\"alpha\": 0.8, \"dx_values\": [0.2, 0.1, 0.05]},\n        {\"alpha\": 1.0, \"dx_values\": [0.25, 0.125, 0.0625]},\n    ]\n\n    orders_of_accuracy = []\n\n    for case in test_cases:\n        alpha = case[\"alpha\"]\n        dx_values = case[\"dx_values\"]\n        \n        errors = []\n        \n        for dx in dx_values:\n            error = compute_rms_error(dx, alpha)\n            errors.append(error)\n\n        log_dx = np.log(dx_values)\n        log_E = np.log(errors)\n        \n        # Perform linear regression to find the slope (order of accuracy)\n        slope, _, _, _, _ = stats.linregress(log_dx, log_E)\n        orders_of_accuracy.append(slope)\n\n    # Format the final output\n    formatted_results = [f\"{p:.6f}\" for p in orders_of_accuracy]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef get_dPhi_dq(q):\n    \"\"\"\n    Computes the derivative of the cubic spline kernel shape function Phi w.r.t. q.\n    \"\"\"\n    if 0.0 = q  1.0:\n        return -3.0 * q + 2.25 * q**2\n    elif 1.0 = q  2.0:\n        return -0.75 * (2.0 - q)**2\n    else:\n        return 0.0\n\ndef compute_rms_error(dx, alpha):\n    \"\"\"\n    Computes the RMS error of the SPH Jacobian approximation for a given dx and alpha.\n    \"\"\"\n    h = alpha * dx\n    m = dx**2\n    sigma = 10.0 / (7.0 * np.pi)\n    support_radius = 2.0 * h\n\n    # Generate particle grid\n    # Add a small epsilon to the range to ensure the endpoint 1.0 is included\n    coords = np.arange(0, 1.0 + dx/2, dx)\n    x_coords, y_coords = np.meshgrid(coords, coords)\n    particles = np.vstack([x_coords.ravel(), y_coords.ravel()]).T\n    \n    # Identify interior particles\n    interior_mask = (particles[:, 0] >= support_radius)  \\\n                    (particles[:, 0] = 1.0 - support_radius)  \\\n                    (particles[:, 1] >= support_radius)  \\\n                    (particles[:, 1] = 1.0 - support_radius)\n    \n    interior_indices = np.where(interior_mask)[0]\n    \n    if len(interior_indices) == 0:\n        # This can happen if 2h > 0.5. The problem setup avoids this.\n        # It's good practice to handle it.\n        return np.nan\n        \n    total_squared_frobenius_norm = 0.0\n\n    for i in interior_indices:\n        xi = particles[i]\n        vi = xi**2  # Vector (xi^2, yi^2)\n        \n        sph_jacobian = np.zeros((2, 2))\n        \n        # Loop over all other particles to find neighbors\n        for j in range(len(particles)):\n            # Exclude self-interaction\n            if i == j:\n                continue\n\n            r_vec = xi - particles[j]\n            r_norm = np.linalg.norm(r_vec)\n\n            if 0.0  r_norm  support_radius:\n                q = r_norm / h\n                dPhi_dq_val = get_dPhi_dq(q)\n                \n                # Grad W_ij = (r_vec / r_norm) * (sigma / h^3) * dPhi_dq\n                # This can be rewritten to avoid division by r_norm if r_norm is very small\n                # but for this problem, r_norm is always >= dx, which is safe.\n                grad_W_factor = (sigma / (h**3 * r_norm)) * dPhi_dq_val\n                grad_W = r_vec * grad_W_factor\n\n                vj = particles[j]**2\n                v_diff = vj - vi\n                \n                # Accumulate Jacobian contribution: m * outer(v_diff, grad_W)\n                sph_jacobian += m * np.outer(v_diff, grad_W)\n\n        # Exact Jacobian at xi\n        exact_jacobian = np.array([[2.0 * xi[0], 0.0], [0.0, 2.0 * xi[1]]])\n        \n        # Error matrix\n        error_matrix = sph_jacobian - exact_jacobian\n        \n        # Squared Frobenius norm\n        total_squared_frobenius_norm += np.sum(error_matrix**2)\n\n    # RMS Error\n    rms_error = np.sqrt(total_squared_frobenius_norm / len(interior_indices))\n    return rms_error\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "拥有一个经过验证的力计算方法后，我们便可以模拟系统的动态演化。然而，时间积分方案的选择对模拟的长期稳定性和物理真实性有重大影响。本练习将探讨在一个经典的涡旋问题中，不同时间积分格式（如前向欧拉法、速度Verlet法和四阶龙格-库塔法）如何影响能量守恒。你将亲身比较这些常用积分器，并理解为何某些方法比其他方法更适合长期保守系统的模拟。",
            "id": "3994524",
            "problem": "考虑一个二维无粘性的正压涡，由角速度为 $\\Omega$（单位为弧度/秒）的刚体旋转表示。其连续介质动量方程为无粘性流动的欧拉方程，由 $D\\mathbf{v}/Dt=-(1/\\rho)\\nabla P$ 给出，其中 $\\mathbf{v}$ 是速度，$\\rho$ 是质量密度， $P$ 是压力， $D/Dt$ 是物质时间导数。对于均匀密度 $\\rho_0$ 和压力场 $P(\\mathbf{x})=P_0+\\tfrac{1}{2}\\rho_0\\Omega^2\\|\\mathbf{x}\\|^2$，流体质点的加速度为 $\\mathbf{a}(\\mathbf{x})=-(1/\\rho_0)\\nabla P(\\mathbf{x})=-\\Omega^2\\mathbf{x}$。这个加速度可以看作是由单位质量的有效势 $V(\\mathbf{x})=\\tfrac{1}{2}\\Omega^2\\|\\mathbf{x}\\|^2$ 产生的，每个粒子的总机械能 $E_i$ 为 $E_i=\\tfrac{1}{2}\\|\\mathbf{v}_i\\|^2+V(\\mathbf{x}_i)$，在精确动力学中，该能量应守恒。\n\n使用光滑粒子流体动力学（SPH），为一组具有位置 $\\mathbf{x}_i\\in\\mathbb{R}^2$、速度 $\\mathbf{v}_i\\in\\mathbb{R}^2$、相等质量 $m$ 和均匀参考密度 $\\rho_0$ 的 $N$ 个粒子，如下近似压力梯度力。采用对称SPH压力梯度近似和光滑长度为 $h$ 的二维三次样条核函数 $W(\\mathbf{r},h)$，\n$$\n\\mathbf{a}_i \\approx -\\sum_{j=1}^N m\\left(\\frac{P_i}{\\rho_0^2}+\\frac{P_j}{\\rho_0^2}\\right)\\nabla W(\\mathbf{x}_i-\\mathbf{x}_j,h),\n$$\n其中 $P_i=P(\\mathbf{x}_i)$，二维三次样条核函数为\n$$\nW(r,h)=\\alpha_2\n\\begin{cases}\n1-\\tfrac{3}{2}q^2+\\tfrac{3}{4}q^3,  0\\le q  1,\\\\\n\\tfrac{1}{4}(2-q)^3,  1\\le q  2,\\\\\n0,  q\\ge 2,\n\\end{cases}\n\\quad \\text{其中 } q=\\frac{r}{h},\\quad \\alpha_2=\\frac{10}{7\\pi h^2},\\quad r=\\|\\mathbf{r}\\|.\n$$\n其梯度为\n$$\n\\nabla W(\\mathbf{r},h)=\\frac{dW}{dr}\\frac{\\mathbf{r}}{r},\\quad \\frac{dW}{dr}=\\frac{\\alpha_2}{h}\n\\begin{cases}\n-3q+\\tfrac{9}{4}q^2,  0\\le q  1,\\\\\n-\\tfrac{3}{4}(2-q)^2,  1\\le q  2,\\\\\n0,  q\\ge 2.\n\\end{cases}\n$$\n\n在一个以原点为中心、边长为 $2L$ 的正方形域上，使用均匀的笛卡尔网格初始化 $N$ 个粒子，网格间距为 $\\Delta x$，且 $m=\\rho_0\\Delta x^2$。根据刚体旋转设置初始速度 $\\mathbf{v}_i(0)=\\Omega\\,(-y_i,x_i)$，其中 $\\mathbf{x}_i(0)=(x_i,y_i)$。使用三种不同的时间积分方案对一阶系统 $\\dot{\\mathbf{x}}=\\mathbf{v}$，$\\dot{\\mathbf{v}}=\\mathbf{a}(\\mathbf{x})$ 进行积分：\n- 前向（显式）欧拉法： $\\mathbf{x}_{n+1}=\\mathbf{x}_n+\\mathbf{v}_n\\Delta t$，$\\mathbf{v}_{n+1}=\\mathbf{v}_n+\\mathbf{a}(\\mathbf{x}_n)\\Delta t$。\n- 速度-Verlet 法（一种辛方法）： $\\mathbf{x}_{n+1}=\\mathbf{x}_n+\\mathbf{v}_n\\Delta t+\\tfrac{1}{2}\\mathbf{a}_n\\Delta t^2$，然后计算 $\\mathbf{a}_{n+1}=\\mathbf{a}(\\mathbf{x}_{n+1})$，并更新 $\\mathbf{v}_{n+1}=\\mathbf{v}_n+\\tfrac{1}{2}(\\mathbf{a}_n+\\mathbf{a}_{n+1})\\Delta t$。\n- 应用于 $(\\mathbf{x},\\mathbf{v})$ 的经典四阶龙格-库塔法（RK4）。\n\n对于每种积分器，计算总能量\n$$\nE(t)=\\sum_{i=1}^N m\\left(\\tfrac{1}{2}\\|\\mathbf{v}_i(t)\\|^2+\\tfrac{1}{2}\\Omega^2\\|\\mathbf{x}_i(t)\\|^2\\right)\n$$\n在 $t=0$ 和最终时间 $t=T$ 时。报告能量漂移\n$$\n\\delta=\\frac{E(T)}{E(0)}-1,\n$$\n以无量纲小数形式。所有长度单位必须是米，时间单位是秒，密度单位是千克/平方米，角速度单位是弧度/秒。角度单位是弧度。能量漂移以小数形式表示（不带百分号）。\n\n实现程序以执行以下测试套件，每个测试由 $(\\text{积分器},\\Delta t,\\text{步数})$ 定义，使用共同的物理参数 $\\rho_0=1\\,\\mathrm{kg/m^2}$、$L=0.25\\,\\mathrm{m}$、$\\Omega=2\\pi\\,\\mathrm{rad/s}$，以及光滑长度 $h=1.2\\,\\Delta x$，其中对于 $N_x=N_y=6$ 的网格，$\\Delta x=(2L)/(N_x-1)$：\n1. $(\\text{欧拉法},\\, 0.001\\,\\mathrm{s},\\, 2000)$ 作为“理想路径”的小时间步长案例。\n2. $(\\text{欧拉法},\\, 0.005\\,\\mathrm{s},\\, 400)$ 作为展示不稳定趋势的边界案例。\n3. $(\\text{速度-Verlet法},\\, 0.002\\,\\mathrm{s},\\, 1000)$ 作为保守的辛方法案例。\n4. $(\\text{RK4},\\, 0.002\\,\\mathrm{s},\\, 500)$ 作为高阶非辛方法案例。\n\n您的程序应生成单行输出，其中包含四个案例的能量漂移，格式为方括号内以逗号分隔的列表（例如 '[drift1,drift2,drift3,drift4]'），顺序与上面列出的一致。每个列表元素必须是十进制单位的浮点数（无量纲），并由 Python 的默认字符串转换进行四舍五入。",
            "solution": "该问题要求为一个二维刚体旋转涡实现一个光滑粒子流体动力学（SPH）模拟。目标是比较三种不同时间积分方案的能量守恒特性：前向欧拉法、速度-Verlet法和四阶龙格-库塔法（RK4）。性能的衡量标准是在指定积分步数内的相对能量漂移 $\\delta$。\n\n首先，我们根据问题陈述确定物理和数值参数。\n模拟区域是一个以原点为中心、边长为 $2L$（$L=0.25\\,\\mathrm{m}$）的正方形。\n粒子被放置在一个大小为 $N_x \\times N_y$ 的均匀笛卡尔网格上，其中 $N_x=N_y=6$。粒子总数为 $N = N_x \\times N_y = 36$。\n网格间距为 $\\Delta x = \\frac{2L}{N_x-1} = \\frac{2 \\times 0.25}{6-1} = 0.1\\,\\mathrm{m}$。\n均匀参考密度为 $\\rho_0 = 1\\,\\mathrm{kg/m^2}$。\n每个粒子的质量是恒定的， $m = \\rho_0 \\Delta x^2 = 1 \\times (0.1)^2 = 0.01\\,\\mathrm{kg}$。\n涡的角速度为 $\\Omega = 2\\pi\\,\\mathrm{rad/s}$。\nSPH 光滑长度为 $h = 1.2\\,\\Delta x = 1.2 \\times 0.1 = 0.12\\,\\mathrm{m}$。\n二维三次样条核函数的归一化常数为 $\\alpha_2 = \\frac{10}{7\\pi h^2}$。\n\n系统的初始状态定义如下：\n初始位置 $\\mathbf{x}_i(0) = (x_i, y_i)$ 是跨越 $[-0.25, 0.25] \\times [-0.25, 0.25]$ 的 $6 \\times 6$ 笛卡尔网格上点的坐标。\n初始速度 $\\mathbf{v}_i(0)$ 由刚体旋转确定：$\\mathbf{v}_i(0) = \\Omega(-y_i, x_i)$。\n\n模拟的核心是粒子加速度的计算。问题指定使用SPH对称压力梯度近似：\n$$\n\\mathbf{a}_i = -\\sum_{j=1}^N m\\left(\\frac{P_i}{\\rho_0^2}+\\frac{P_j}{\\rho_0^2}\\right)\\nabla W(\\mathbf{x}_i-\\mathbf{x}_j,h)\n$$\n粒子位置 $\\mathbf{x}_i$ 处的压力 $P_i$ 由涡的解析公式给出，$P_i = P(\\mathbf{x}_i) = P_0 + \\tfrac{1}{2}\\rho_0\\Omega^2\\|\\mathbf{x}_i\\|^2$。恒定的基础压力 $P_0$ 对梯度力没有贡献，可以设为 $P_0=0$。因此，$P_i = \\tfrac{1}{2}\\rho_0\\Omega^2\\|\\mathbf{x}_i\\|^2$。\n\n对每对粒子 $(i, j)$ 计算核函数的梯度 $\\nabla W$。令 $\\mathbf{r} = \\mathbf{x}_i - \\mathbf{x}_j$ 且 $r = \\|\\mathbf{r}\\|$。梯度为 $\\nabla W(\\mathbf{r}, h) = \\frac{dW}{dr}\\frac{\\mathbf{r}}{r}$。导数 $\\frac{dW}{dr}$ 由 $q=r/h$ 的分段函数给出：\n$$\n\\frac{dW}{dr}=\\frac{\\alpha_2}{h}\n\\begin{cases}\n-3q+\\tfrac{9}{4}q^2,  0\\le q  1,\\\\\n-\\tfrac{3}{4}(2-q)^2,  1\\le q  2,\\\\\n0,  q\\ge 2.\n\\end{cases}\n$$\n每个粒子 $\\mathbf{a}_i$ 的加速度是通过对所有其他粒子 $j$ 的贡献求和来计算的，这些贡献由质量、压力项和核函数梯度加权。这个计算必须在每个时间步执行（对于高阶积分器，可能每个步长执行多次）。\n\n系统的演化由一阶常微分方程 $\\dot{\\mathbf{x}} = \\mathbf{v}$ 和 $\\dot{\\mathbf{v}} = \\mathbf{a}$ 控制。我们实现三种数值方案来对这些方程进行积分。\n\n1.  **前向（显式）欧拉法：** 这是一种一阶方法。给定时间 $t_n$ 的状态 $(\\mathbf{x}_n, \\mathbf{v}_n)$，时间 $t_{n+1}=t_n+\\Delta t$ 的状态为：\n    $$\n    \\mathbf{a}_n = \\mathbf{a}(\\mathbf{x}_n) \\\\\n    \\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_n\\Delta t \\\\\n    \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n\\Delta t\n    $$\n\n2.  **速度-Verlet法：** 这是一种二阶辛积分器，以在哈密顿系统中具有良好的长期能量守恒性而闻名。更新分三步进行：\n    $$\n    \\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_n\\Delta t + \\tfrac{1}{2}\\mathbf{a}_n\\Delta t^2 \\\\\n    \\mathbf{a}_{n+1} = \\mathbf{a}(\\mathbf{x}_{n+1}) \\\\\n    \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\tfrac{1}{2}(\\mathbf{a}_n + \\mathbf{a}_{n+1})\\Delta t\n    $$\n    如果不是因为 $\\mathbf{a}_n$ 是从上一步的后半部分继承而来，这将需要在每个时间步进行两次加速度计算。在实现中，我们在第 $n$ 步开始时计算 $\\mathbf{a}_n$，执行位置和速度更新，并保存最终加速度 $\\mathbf{a}_{n+1}$ 以供下一步使用。\n\n3.  **经典四阶龙格-库塔法（RK4）：** 这是一种高精度、非辛方法。对于系统 $\\dot{\\mathbf{y}} = f(\\mathbf{y})$，其中 $\\mathbf{y}=(\\mathbf{x}, \\mathbf{v})$，一个步长包括计算四个中间斜率（$k_1, k_2, k_3, k_4$）并取其加权平均值。令 $f(\\mathbf{x}, \\mathbf{v}) = (\\mathbf{v}, \\mathbf{a}(\\mathbf{x}))$。位置（$\\mathbf{k}_x$）和速度（$\\mathbf{k}_v$）的斜率是：\n    $$\n    \\begin{aligned}\n    \\mathbf{k}_{v1} = \\mathbf{a}(\\mathbf{x}_n) \\\\\n    \\mathbf{k}_{x1} = \\mathbf{v}_n \\\\\n    \\mathbf{k}_{v2} = \\mathbf{a}(\\mathbf{x}_n + \\tfrac{\\Delta t}{2}\\mathbf{k}_{x1}) \\\\\n    \\mathbf{k}_{x2} = \\mathbf{v}_n + \\tfrac{\\Delta t}{2}\\mathbf{k}_{v1} \\\\\n    \\mathbf{k}_{v3} = \\mathbf{a}(\\mathbf{x}_n + \\tfrac{\\Delta t}{2}\\mathbf{k}_{x2}) \\\\\n    \\mathbf{k}_{x3} = \\mathbf{v}_n + \\tfrac{\\Delta t}{2}\\mathbf{k}_{v2} \\\\\n    \\mathbf{k}_{v4} = \\mathbf{a}(\\mathbf{x}_n + \\Delta t\\,\\mathbf{k}_{x3}) \\\\\n    \\mathbf{k}_{x4} = \\mathbf{v}_n + \\Delta t\\,\\mathbf{k}_{v3}\n    \\end{aligned}\n    $$\n    然后状态更新如下：\n    $$\n    \\mathbf{x}_{n+1} = \\mathbf{x}_n + \\tfrac{\\Delta t}{6}(\\mathbf{k}_{x1} + 2\\mathbf{k}_{x2} + 2\\mathbf{k}_{x3} + \\mathbf{k}_{x4}) \\\\\n    \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\tfrac{\\Delta t}{6}(\\mathbf{k}_{v1} + 2\\mathbf{k}_{v2} + 2\\mathbf{k}_{v3} + \\mathbf{k}_{v4})\n    $$\n    这要求在每个时间步内对加速度函数 $\\mathbf{a}(\\mathbf{x})$ 进行四次评估。\n\n最后，我们评估每种方法的能量守恒性。系统的总机械能由以下公式给出：\n$$\nE(t) = \\sum_{i=1}^N m \\left( \\tfrac{1}{2}\\|\\mathbf{v}_i(t)\\|^2 + \\tfrac{1}{2}\\Omega^2\\|\\mathbf{x}_i(t)\\|^2 \\right)\n$$\n我们计算初始能量 $E(0)$ 和在指定步数后的最终能量 $E(T)$（$T = \\text{步数} \\times \\Delta t$）。然后能量漂移 $\\delta$ 计算如下：\n$$\n\\delta = \\frac{E(T)}{E(0)} - 1\n$$\n对问题中指定的四个测试案例中的每一个重复此过程，并报告所得的漂移。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_acceleration(pos, N, m, rho0, Omega, h, alpha2):\n    \"\"\"\n    Calculates particle accelerations using the SPH pressure gradient approximation.\n    \"\"\"\n    pressures = 0.5 * rho0 * Omega**2 * np.sum(pos**2, axis=1)\n    acc = np.zeros_like(pos)\n    \n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n\n            r_vec = pos[i] - pos[j]\n            r = np.linalg.norm(r_vec)\n            \n            if r == 0 or r >= 2 * h:\n                continue\n\n            q = r / h\n\n            dWdr = 0.0\n            # dW/dr for the 2D cubic spline kernel\n            if q  1:\n                dWdr = (alpha2 / h) * (-3.0 * q + 2.25 * q**2)\n            elif q  2:\n                dWdr = (alpha2 / h) * (-0.75 * (2.0 - q)**2)\n            \n            if dWdr == 0.0:\n                continue\n            \n            # Gradient of the kernel W\n            grad_W = (dWdr / r) * r_vec\n            \n            # Symmetrized pressure term\n            pressure_term = (pressures[i] / rho0**2) + (pressures[j] / rho0**2)\n            \n            # Accumulate acceleration contribution from particle j\n            acc[i] -= m * pressure_term * grad_W\n\n    return acc\n\ndef calculate_total_energy(pos, vel, m, Omega):\n    \"\"\"\n    Calculates the total mechanical energy of the particle system.\n    \"\"\"\n    kinetic_energy_sum = np.sum(vel**2)\n    potential_energy_sum = Omega**2 * np.sum(pos**2)\n    total_energy = 0.5 * m * (kinetic_energy_sum + potential_energy_sum)\n    return total_energy\n\ndef run_simulation(integrator, dt, steps, L, rho0, Omega, Nx, Ny):\n    \"\"\"\n    Runs a single SPH simulation for a given integrator and parameters.\n    \"\"\"\n    # Derived parameters\n    N = Nx * Ny\n    dx = (2 * L) / (Nx - 1)\n    h = 1.2 * dx\n    m = rho0 * dx**2\n    alpha2 = 10.0 / (7.0 * np.pi * h**2)\n\n    # Particle initialization\n    x_coords = np.linspace(-L, L, Nx, dtype=np.float64)\n    y_coords = np.linspace(-L, L, Ny, dtype=np.float64)\n    xx, yy = np.meshgrid(x_coords, y_coords)\n    pos = np.vstack([xx.ravel(), yy.ravel()]).T\n    vel = Omega * np.vstack([-pos[:, 1], pos[:, 0]]).T\n\n    # Initial energy\n    E0 = calculate_total_energy(pos, vel, m, Omega)\n    if E0 == 0:\n        return 0.0\n\n    # Integration loop\n    if integrator == 'Euler':\n        for _ in range(steps):\n            acc = calculate_acceleration(pos, N, m, rho0, Omega, h, alpha2)\n            pos += vel * dt\n            vel += acc * dt\n    \n    elif integrator == 'Velocity-Verlet':\n        acc = calculate_acceleration(pos, N, m, rho0, Omega, h, alpha2)\n        for _ in range(steps):\n            pos += vel * dt + 0.5 * acc * dt**2\n            acc_new = calculate_acceleration(pos, N, m, rho0, Omega, h, alpha2)\n            vel += 0.5 * (acc + acc_new) * dt\n            acc = acc_new\n\n    elif integrator == 'RK4':\n        for _ in range(steps):\n            # k1\n            kv1 = calculate_acceleration(pos, N, m, rho0, Omega, h, alpha2)\n            kx1 = vel\n            \n            # k2\n            pos_temp2 = pos + 0.5 * dt * kx1\n            kv2 = calculate_acceleration(pos_temp2, N, m, rho0, Omega, h, alpha2)\n            kx2 = vel + 0.5 * dt * kv1\n\n            # k3\n            pos_temp3 = pos + 0.5 * dt * kx2\n            kv3 = calculate_acceleration(pos_temp3, N, m, rho0, Omega, h, alpha2)\n            kx3 = vel + 0.5 * dt * kv2\n\n            # k4\n            pos_temp4 = pos + dt * kx3\n            kv4 = calculate_acceleration(pos_temp4, N, m, rho0, Omega, h, alpha2)\n            kx4 = vel + dt * kv3\n\n            # Update position and velocity\n            pos += (dt / 6.0) * (kx1 + 2*kx2 + 2*kx3 + kx4)\n            vel += (dt / 6.0) * (kv1 + 2*kv2 + 2*kv3 + kv4)\n\n    # Final energy and drift\n    ET = calculate_total_energy(pos, vel, m, Omega)\n    drift = ET / E0 - 1.0\n    return drift\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Common physical parameters\n    rho0 = 1.0\n    L = 0.25\n    Omega = 2.0 * np.pi\n    Nx, Ny = 6, 6\n    \n    # Test cases: (integrator_name, dt, steps)\n    test_cases = [\n        ('Euler', 0.001, 2000),\n        ('Euler', 0.005, 400),\n        ('Velocity-Verlet', 0.002, 1000),\n        ('RK4', 0.002, 500),\n    ]\n\n    results = []\n    for integrator, dt, steps in test_cases:\n        drift = run_simulation(integrator, dt, steps, L, rho0, Omega, Nx, Ny)\n        results.append(drift)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}