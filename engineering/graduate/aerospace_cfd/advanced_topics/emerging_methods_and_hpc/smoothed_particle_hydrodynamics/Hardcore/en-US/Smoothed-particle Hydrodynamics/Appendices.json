{
    "hands_on_practices": [
        {
            "introduction": "The kernel function is the cornerstone of the Smoothed-Particle Hydrodynamics (SPH) method, defining how physical quantities are interpolated in space. For the SPH framework to be mathematically consistent and conserve fundamental quantities like mass, the kernel must satisfy a normalization condition. This analytical exercise  challenges you to derive the normalization constant for the widely-used cubic spline kernel from first principles, providing essential practice with the mathematical foundations that ensure the validity of SPH approximations.",
            "id": "3994546",
            "problem": "In Smoothed-Particle Hydrodynamics (SPH), a kernel function $W(\\mathbf{r},h)$ of smoothing length $h$ must satisfy the normalization condition $\\int_{\\mathbb{R}^{3}} W(\\mathbf{r},h)\\,d\\mathbf{r} = 1$ to preserve mass and ensure consistency of the interpolation operator. Consider the isotropic $3$-dimensional cubic spline kernel with compact support of radius $2h$. Let $r = \\|\\mathbf{r}\\|$ and $q = r/h$. The kernel is defined by\n$$\nW(r,h) = \\frac{\\alpha}{h^{3}}\\,w(q),\n$$\nwhere the dimensionless function $w(q)$ is given piecewise by\n$$\nw(q) = \n\\begin{cases}\n1 - \\frac{3}{2}q^{2} + \\frac{3}{4}q^{3}  0 \\le q  1 \\\\\n\\frac{1}{4}(2 - q)^{3}  1 \\le q  2 \\\\\n0  q \\ge 2.\n\\end{cases}\n$$\nStarting from the normalization requirement and first principles (coordinate transformations and radial symmetry), derive the value of the normalization constant $\\alpha$ such that $\\int_{\\mathbb{R}^{3}} W(\\mathbf{r},h)\\,d\\mathbf{r} = 1$. Provide the final value of $\\alpha$ as a single closed-form analytic expression. No rounding is required, and no units are associated with $\\alpha$.",
            "solution": "To find the normalization constant $\\alpha$, we start with the normalization requirement for the kernel function $W(\\mathbf{r},h)$ in three dimensions:\n$$\n\\int_{\\mathbb{R}^{3}} W(\\mathbf{r},h)\\,d\\mathbf{r} = 1\n$$\nSubstitute the given form of the kernel, $W(\\mathbf{r},h) = \\frac{\\alpha}{h^3} w(q)$, where $q = r/h$ and $r = \\|\\mathbf{r}\\|$:\n$$\n\\int_{\\mathbb{R}^{3}} \\frac{\\alpha}{h^3} w\\left(\\frac{\\|\\mathbf{r}\\|}{h}\\right) \\,d\\mathbf{r} = 1\n$$\nSince the kernel is isotropic (depends only on the radius $r$), we can switch to spherical coordinates. The volume element becomes $d\\mathbf{r} = r^2 \\sin\\theta \\,dr\\,d\\theta\\,d\\phi$. Integrating over the solid angle ($\\int_0^{2\\pi} \\int_0^{\\pi} \\sin\\theta \\,d\\theta\\,d\\phi = 4\\pi$) simplifies the expression:\n$$\n\\frac{4\\pi\\alpha}{h^3} \\int_0^\\infty w\\left(\\frac{r}{h}\\right) r^2 \\,dr = 1\n$$\nNext, we perform a change of variables from $r$ to the dimensionless radius $q = r/h$. This gives $r = qh$ and $dr = h\\,dq$. Substituting these into the integral:\n$$\n\\frac{4\\pi\\alpha}{h^3} \\int_0^\\infty w(q) (qh)^2 (h\\,dq) = 1\n$$\n$$\n\\frac{4\\pi\\alpha}{h^3} \\int_0^\\infty w(q) q^2 h^3 \\,dq = 1\n$$\n$$\n4\\pi\\alpha \\int_0^\\infty w(q) q^2 \\,dq = 1\n$$\nThe kernel has compact support up to $q=2$, so the integral's upper limit is 2. We split the integral into two parts according to the piecewise definition of $w(q)$:\n$$\n\\int_0^2 w(q) q^2 \\,dq = \\int_0^1 \\left(1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3\\right) q^2 \\,dq + \\int_1^2 \\left(\\frac{1}{4}(2-q)^3\\right) q^2 \\,dq\n$$\nWe evaluate each integral separately.\nFor the first integral (from 0 to 1):\n$$\n\\int_0^1 \\left(q^2 - \\frac{3}{2}q^4 + \\frac{3}{4}q^5\\right) \\,dq = \\left[\\frac{q^3}{3} - \\frac{3}{10}q^5 + \\frac{1}{8}q^6\\right]_0^1 = \\frac{1}{3} - \\frac{3}{10} + \\frac{1}{8} = \\frac{40 - 36 + 15}{120} = \\frac{19}{120}\n$$\nFor the second integral (from 1 to 2), we first expand the cubic term $(2-q)^3 = 8 - 12q + 6q^2 - q^3$:\n$$\n\\int_1^2 \\frac{1}{4}(8 - 12q + 6q^2 - q^3) q^2 \\,dq = \\frac{1}{4} \\int_1^2 (8q^2 - 12q^3 + 6q^4 - q^5) \\,dq\n$$\n$$\n= \\frac{1}{4} \\left[\\frac{8}{3}q^3 - \\frac{12}{4}q^4 + \\frac{6}{5}q^5 - \\frac{1}{6}q^6\\right]_1^2 = \\frac{1}{4} \\left[\\frac{8}{3}q^3 - 3q^4 + \\frac{6}{5}q^5 - \\frac{1}{6}q^6\\right]_1^2\n$$\nEvaluating at the limits:\n$$\n= \\frac{1}{4} \\left[ \\left(\\frac{8}{3}(8) - 3(16) + \\frac{6}{5}(32) - \\frac{1}{6}(64)\\right) - \\left(\\frac{8}{3} - 3 + \\frac{6}{5} - \\frac{1}{6}\\right) \\right]\n$$\n$$\n= \\frac{1}{4} \\left[ \\left(\\frac{64}{3} - 48 + \\frac{192}{5} - \\frac{32}{3}\\right) - \\left(\\frac{80 - 90 + 36 - 5}{30}\\right) \\right]\n$$\n$$\n= \\frac{1}{4} \\left[ \\left(\\frac{32}{3} - 48 + \\frac{192}{5}\\right) - \\left(\\frac{21}{30}\\right) \\right] = \\frac{1}{4} \\left[ \\left(\\frac{160 - 720 + 576}{15}\\right) - \\frac{7}{10} \\right]\n$$\n$$\n= \\frac{1}{4} \\left[ \\frac{16}{15} - \\frac{7}{10} \\right] = \\frac{1}{4} \\left[ \\frac{32 - 21}{30} \\right] = \\frac{1}{4} \\left( \\frac{11}{30} \\right) = \\frac{11}{120}\n$$\nNow, summing the two parts:\n$$\n\\int_0^2 w(q) q^2 \\,dq = \\frac{19}{120} + \\frac{11}{120} = \\frac{30}{120} = \\frac{1}{4}\n$$\nSubstitute this result back into the normalization equation:\n$$\n4\\pi\\alpha \\left(\\frac{1}{4}\\right) = 1 \\implies \\pi\\alpha = 1\n$$\nSolving for $\\alpha$, we get:\n$$\n\\alpha = \\frac{1}{\\pi}\n$$\nThis confirms the required normalization constant.",
            "answer": "$$\n\\boxed{\\frac{1}{\\pi}}\n$$"
        },
        {
            "introduction": "Once a valid kernel is established, the next step is to use it to construct discrete differential operators, such as the gradient, which are essential for evaluating terms in the governing equations of fluid dynamics. The reliability of an SPH simulation depends critically on the accuracy of these operators. This computational practice  employs the Method of Manufactured Solutions—a standard verification technique in CFD—to assess the numerical convergence rate of the SPH gradient operator, giving you direct insight into how the approximation error behaves as particle resolution is refined.",
            "id": "3994498",
            "problem": "Consider the manufactured vector field $\\mathbf{v}(x,y) = (x^2, y^2)$ defined on the unit square domain $[0,1] \\times [0,1]$. In Smoothed-Particle Hydrodynamics (SPH), the continuous field is represented by particles of uniform mass and density. Let the particle layout be a uniform Cartesian grid with spacing $\\Delta x$ in both directions, uniform density $\\rho = 1$ (nondimensional), and particle mass $m = \\Delta x^2$. The smoothing length is $h = \\alpha \\Delta x$, where $\\alpha$ is a positive constant. Use the classical cubic spline SPH kernel in two spatial dimensions with compact support $2h$, given by\n$$\nW(q;h) =\n\\begin{cases}\n\\dfrac{\\sigma}{h^2} \\left(1 - \\dfrac{3}{2} q^2 + \\dfrac{3}{4} q^3 \\right),  0 \\le q  1, \\\\\n\\dfrac{\\sigma}{h^2} \\left(\\dfrac{1}{4} (2 - q)^3 \\right),  1 \\le q  2, \\\\\n0,  q \\ge 2,\n\\end{cases}\n$$\nwith $q = r/h$, $r = \\|\\mathbf{r}\\|$, and normalization constant $\\sigma = \\dfrac{10}{7\\pi}$ for two dimensions. The kernel gradient is $\\nabla W(\\mathbf{r};h) = \\dfrac{\\partial W}{\\partial r} \\dfrac{\\mathbf{r}}{r}$, where $\\dfrac{\\partial W}{\\partial r} = \\dfrac{\\sigma}{h^3} \\dfrac{d \\Phi}{d q}(q)$ and\n$$\n\\dfrac{d \\Phi}{d q}(q) =\n\\begin{cases}\n-3 q + \\dfrac{9}{4} q^2,  0 \\le q  1, \\\\\n-\\dfrac{3}{4} (2 - q)^2,  1 \\le q  2, \\\\\n0,  q \\ge 2.\n\\end{cases}\n$$\nStart from the continuous SPH interpolation perspective that a scalar field $f(\\mathbf{x})$ can be approximated by a kernel-weighted integral and its gradient by differentiating under the integral sign. Use this fundamental base to derive a consistent discrete SPH gradient operator for each scalar component of $\\mathbf{v}$, expressed in terms of particle masses, densities, and kernel gradients. Implement your derived discrete operator to approximate the Jacobian matrix $\\nabla \\mathbf{v}$ component-wise at particle locations.\n\nTo avoid boundary truncation of the kernel support, restrict error evaluation to the set of \"interior\" particles whose distance from every domain boundary is at least $2h$. For each interior particle at position $(x_i,y_i)$, compute the approximate Jacobian\n$$\n\\nabla \\mathbf{v}(\\mathbf{x}_i) \\approx\n\\begin{pmatrix}\n\\partial_x (x^2)  \\partial_y (x^2) \\\\\n\\partial_x (y^2)  \\partial_y (y^2)\n\\end{pmatrix}_{\\text{SPH}},\n$$\nand compare it to the exact Jacobian\n$$\n\\nabla \\mathbf{v}_{\\text{exact}}(x_i,y_i) =\n\\begin{pmatrix}\n2x_i  0 \\\\\n0  2y_i\n\\end{pmatrix}.\n$$\nMeasure the error at each interior particle by the Frobenius norm of the difference between the approximate and exact Jacobians, and aggregate the error over all interior particles by the root-mean-square (RMS)\n$$\nE(\\Delta x, \\alpha) = \\sqrt{\\dfrac{1}{N_{\\text{int}}} \\sum_{i \\in \\text{interior}} \\left\\| \\nabla \\mathbf{v}_{\\text{SPH}}(\\mathbf{x}_i) - \\nabla \\mathbf{v}_{\\text{exact}}(\\mathbf{x}_i) \\right\\|_F^2 },\n$$\nwhere $N_{\\text{int}}$ is the number of interior particles. For a fixed $\\alpha$, assess convergence of the SPH gradient approximation as $\\Delta x$ decreases by fitting a line to $(\\log \\Delta x, \\log E)$ and extracting the slope $p$, which serves as the observed order of accuracy defined by $E \\propto (\\Delta x)^p$.\n\nImplement the program to compute $E$ for each $\\Delta x$ in the following test suites and report the observed order $p$ for each suite using least-squares regression over all provided $\\Delta x$ values:\n\n- Test Case 1 (happy path): $\\alpha = 1.0$, $\\Delta x \\in \\{0.2, 0.1, 0.05\\}$.\n- Test Case 2 (kernel variation): $\\alpha = 0.8$, $\\Delta x \\in \\{0.2, 0.1, 0.05\\}$.\n- Test Case 3 (boundary-limited interior, edge case): $\\alpha = 1.0$, $\\Delta x \\in \\{0.25, 0.125, 0.0625\\}$.\n\nAll computations are nondimensional. Angles do not appear in this problem, so no angle unit is required. Your program should produce a single line of output containing the three observed orders as a comma-separated list enclosed in square brackets, with each number rounded to six decimal places (e.g., \"[p1,p2,p3]\").",
            "solution": "The problem is subjected to validation and is found to be valid. It is scientifically grounded in the principles of Smoothed-Particle Hydrodynamics (SPH), a standard numerical method. The problem is well-posed, providing all necessary definitions, constants, and parameters to compute a unique, meaningful result. The language is objective and unambiguous, and the setup is internally consistent.\n\nThe core of the task is to derive and implement a discrete SPH gradient operator to approximate the Jacobian of a given vector field and to subsequently assess the numerical convergence of this approximation.\n\n**1. Derivation of the SPH Gradient Operator**\n\nThe SPH methodology begins with the continuous integral representation of a scalar field $f(\\mathbf{x})$ using a smoothing kernel $W$ with a characteristic smoothing length $h$:\n$$\nf(\\mathbf{x}) \\approx \\int_{\\Omega} f(\\mathbf{x}') W(\\mathbf{x} - \\mathbf{x}', h) \\, d\\mathbf{x}'\n$$\nThe gradient of this field, $\\nabla f(\\mathbf{x})$, is found by applying the gradient operator to the integral representation. Assuming the field $f$ and kernel $W$ are sufficiently well-behaved, the differentiation can be moved inside the integral:\n$$\n\\nabla f(\\mathbf{x}) \\approx \\int_{\\Omega} f(\\mathbf{x}') \\nabla_{\\mathbf{x}} W(\\mathbf{x} - \\mathbf{x}', h) \\, d\\mathbf{x}'\n$$\nwhere $\\nabla_{\\mathbf{x}}$ denotes the gradient with respect to the coordinates $\\mathbf{x}$.\n\nTo transition to a discrete particle-based formulation, the domain $\\Omega$ is represented by a set of particles. The integral is replaced by a summation over these particles. Each particle $j$, located at position $\\mathbf{x}_j$, has a mass $m_j$ and density $\\rho_j$. Its associated volume element is $d\\mathbf{x}' \\approx V_j = m_j/\\rho_j$. The gradient at the position of particle $i$, $\\mathbf{x}_i$, is thus approximated by the summation:\n$$\n\\nabla f(\\mathbf{x}_i) \\approx \\sum_j f(\\mathbf{x}_j) \\nabla_i W(\\mathbf{x}_i - \\mathbf{x}_j, h) V_j\n$$\nwhere $\\nabla_i W_{ij} \\equiv \\nabla_{\\mathbf{x}} W(\\mathbf{x} - \\mathbf{x}', h)|_{\\mathbf{x}=\\mathbf{x}_i, \\mathbf{x}'=\\mathbf{x}_j}$.\n\nThe problem requires the derivation of a \"consistent\" discrete operator. A fundamental consistency requirement is that the gradient of a constant field must be zero. The direct discretization shown above does not guarantee this property. A more robust formulation is obtained using the product rule identity $\\nabla f = \\frac{1}{\\rho} \\nabla(\\rho f) - \\frac{f}{\\rho} \\nabla \\rho$. Applying the SPH discretization to the gradients of $\\rho f$ and $\\rho$ leads to:\n$$\n\\nabla f_i \\approx \\frac{1}{\\rho_i} \\left( \\sum_j (\\rho_j f_j) \\frac{m_j}{\\rho_j} \\nabla_i W_{ij} \\right) - \\frac{f_i}{\\rho_i} \\left( \\sum_j \\rho_j \\frac{m_j}{\\rho_j} \\nabla_i W_{ij} \\right)\n$$\nSimplifying and combining the sums gives the \"difference form\" of the SPH gradient operator:\n$$\n\\nabla f_i \\approx \\frac{1}{\\rho_i} \\sum_j m_j (f_j - f_i) \\nabla_i W_{ij}\n$$\nThis form inherently satisfies the condition that the gradient of a constant field ($f_j = f_i$) is exactly zero. As the problem specifies a uniform density $\\rho=1$ and uniform particle mass $m = \\Delta x^2$, the operator we will implement is:\n$$\n\\nabla f_i = \\sum_j m \\left( f_j - f_i \\right) \\nabla_i W_{ij}\n$$\nwhere the sum is over all neighboring particles $j$ within the kernel's support radius of particle $i$.\n\n**2. Jacobian Matrix Approximation**\n\nThe Jacobian matrix of the vector field $\\mathbf{v}(x,y) = (v_x, v_y)$ is given by $\\nabla \\mathbf{v} = \\begin{pmatrix} \\partial_x v_x  \\partial_y v_x \\\\ \\partial_x v_y  \\partial_y v_y \\end{pmatrix}$. Each component of this matrix is the partial derivative of a scalar field, which we approximate using the SPH gradient operator derived above. For a particle $i$, the SPH-approximated Jacobian is:\n$$\n(\\nabla \\mathbf{v}_{\\text{SPH}})_i = \\sum_j m (\\mathbf{v}_j - \\mathbf{v}_i) \\otimes \\nabla_i W_{ij}\n$$\nwhere $\\otimes$ denotes the outer product. This results in the matrix:\n$$\n(\\nabla \\mathbf{v}_{\\text{SPH}})_i = \\sum_j m\n\\begin{pmatrix}\n(v_{x,j} - v_{x,i}) \\frac{\\partial W_{ij}}{\\partial x_i}  (v_{x,j} - v_{x,i}) \\frac{\\partial W_{ij}}{\\partial y_i} \\\\\n(v_{y,j} - v_{y,i}) \\frac{\\partial W_{ij}}{\\partial x_i}  (v_{y,j} - v_{y,i}) \\frac{\\partial W_{ij}}{\\partial y_i}\n\\end{pmatrix}\n$$\nFor the given field $\\mathbf{v}(x,y) = (x^2, y^2)$, we have $v_x = x^2$ and $v_y = y^2$.\n\nThe kernel gradient $\\nabla_i W_{ij}$ is calculated using the provided formula $\\nabla W(\\mathbf{r};h) = \\frac{\\partial W}{\\partial r} \\frac{\\mathbf{r}}{r}$, where $\\mathbf{r} = \\mathbf{x}_i - \\mathbf{x}_j$. Let $r_{ij} = \\|\\mathbf{r}\\|$.\n$$\n\\nabla_i W_{ij} = \\frac{\\mathbf{x}_i - \\mathbf{x}_j}{r_{ij}} \\frac{\\partial W}{\\partial r}(r_{ij}; h) = \\frac{\\mathbf{x}_i - \\mathbf{x}_j}{r_{ij}} \\left( \\frac{\\sigma}{h^3} \\frac{d\\Phi}{dq}(q_{ij}) \\right)\n$$\nwith $q_{ij} = r_{ij}/h$, $\\sigma = 10/(7\\pi)$, and $\\frac{d\\Phi}{dq}$ given by the piecewise function in the problem statement.\n\n**3. Algorithmic Procedure**\n\nThe overall algorithm to compute the error and convergence order is as follows:\n\n1.  **Particle Generation**: For a given spacing $\\Delta x$, create a uniform Cartesian grid of particles over the domain $[0,1] \\times [0,1]$. Particle positions are $\\mathbf{x}_{k,l} = (k \\Delta x, l \\Delta x)$ for integers $k,l$ such that the domain is covered.\n\n2.  **Identify Interior Particles**: The analysis is restricted to \"interior\" particles to avoid errors from kernel truncation at the boundaries. A particle at position $(x_i, y_i)$ is interior if its distance to all four boundaries ($x=0, x=1, y=0, y=1$) is at least the kernel support radius, $2h$. That is, $x_i \\in [2h, 1-2h]$ and $y_i \\in [2h, 1-2h]$, where $h=\\alpha \\Delta x$.\n\n3.  **Jacobian and Error Calculation**:\n    For each interior particle $i$:\n    a. Initialize the SPH Jacobian matrix $(\\nabla \\mathbf{v}_{\\text{SPH}})_i$ to zeros.\n    b. Iterate through all other particles $j$ to find neighbors. A particle $j$ is a neighbor if the distance $r_{ij} = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|$ is in the range $(0, 2h)$. The condition $r_{ij}  0$ excludes the particle itself.\n    c. For each neighbor $j$, calculate the kernel gradient $\\nabla_i W_{ij}$ and the vector field difference $\\mathbf{v}_j - \\mathbf{v}_i$.\n    d. Compute the contribution to the Jacobian, $m (\\mathbf{v}_j - \\mathbf{v}_i) \\otimes \\nabla_i W_{ij}$, and add it to $(\\nabla \\mathbf{v}_{\\text{SPH}})_i$.\n    e. After summing over all neighbors, calculate the exact Jacobian at $\\mathbf{x}_i$: $\\nabla \\mathbf{v}_{\\text{exact}}(x_i,y_i) = \\begin{pmatrix} 2x_i  0 \\\\ 0  2y_i \\end{pmatrix}$.\n    f. Compute the squared Frobenius norm of the error matrix: $E_i^2 = \\| (\\nabla \\mathbf{v}_{\\text{SPH}})_i - (\\nabla \\mathbf{v}_{\\text{exact}})_i \\|_F^2$.\n\n4.  **Aggregate RMS Error**: Sum the squared errors over all $N_{\\text{int}}$ interior particles and compute the Root-Mean-Square (RMS) error:\n    $$\n    E(\\Delta x, \\alpha) = \\sqrt{\\frac{1}{N_{\\text{int}}} \\sum_{i \\in \\text{interior}} E_i^2}\n    $$\n\n5.  **Convergence Order Analysis**: For each test suite, we obtain a set of error values $E$ corresponding to a set of grid spacings $\\Delta x$. The order of accuracy, $p$, is defined by the relationship $E \\propto (\\Delta x)^p$. Taking the logarithm of both sides gives $\\log E = p \\log \\Delta x + C$. Thus, $p$ is the slope of a line fitted to the data points $(\\log \\Delta x, \\log E)$. This slope is computed using linear least-squares regression for each test case.\n\nThe implementation will follow this procedure for each of the three test cases specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to execute the SPH convergence study as per the problem statement.\n    \"\"\"\n\n    test_cases = [\n        {\"alpha\": 1.0, \"dx_values\": [0.2, 0.1, 0.05]},\n        {\"alpha\": 0.8, \"dx_values\": [0.2, 0.1, 0.05]},\n        {\"alpha\": 1.0, \"dx_values\": [0.25, 0.125, 0.0625]},\n    ]\n\n    orders_of_accuracy = []\n\n    for case in test_cases:\n        alpha = case[\"alpha\"]\n        dx_values = case[\"dx_values\"]\n        \n        errors = []\n        \n        for dx in dx_values:\n            error = compute_rms_error(dx, alpha)\n            errors.append(error)\n\n        log_dx = np.log(dx_values)\n        log_E = np.log(errors)\n        \n        # Perform linear regression to find the slope (order of accuracy)\n        slope, _, _, _, _ = stats.linregress(log_dx, log_E)\n        orders_of_accuracy.append(slope)\n\n    # Format the final output\n    formatted_results = [f\"{p:.6f}\" for p in orders_of_accuracy]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef get_dPhi_dq(q):\n    \"\"\"\n    Computes the derivative of the cubic spline kernel shape function Phi w.r.t. q.\n    \"\"\"\n    if 0.0 = q  1.0:\n        return -3.0 * q + 2.25 * q**2\n    elif 1.0 = q  2.0:\n        return -0.75 * (2.0 - q)**2\n    else:\n        return 0.0\n\ndef compute_rms_error(dx, alpha):\n    \"\"\"\n    Computes the RMS error of the SPH Jacobian approximation for a given dx and alpha.\n    \"\"\"\n    h = alpha * dx\n    m = dx**2\n    sigma = 10.0 / (7.0 * np.pi)\n    support_radius = 2.0 * h\n\n    # Generate particle grid\n    # Add a small epsilon to the range to ensure the endpoint 1.0 is included\n    coords = np.arange(0, 1.0 + dx/2, dx)\n    x_coords, y_coords = np.meshgrid(coords, coords)\n    particles = np.vstack([x_coords.ravel(), y_coords.ravel()]).T\n    \n    # Identify interior particles\n    interior_mask = (particles[:, 0] = support_radius)  \\\n                    (particles[:, 0] = 1.0 - support_radius)  \\\n                    (particles[:, 1] = support_radius)  \\\n                    (particles[:, 1] = 1.0 - support_radius)\n    \n    interior_indices = np.where(interior_mask)[0]\n    \n    if len(interior_indices) == 0:\n        # This can happen if 2h  0.5. The problem setup avoids this.\n        # It's good practice to handle it.\n        return np.nan\n        \n    total_squared_frobenius_norm = 0.0\n\n    for i in interior_indices:\n        xi = particles[i]\n        vi = xi**2  # Vector (xi^2, yi^2)\n        \n        sph_jacobian = np.zeros((2, 2))\n        \n        # Loop over all other particles to find neighbors\n        for j in range(len(particles)):\n            # Exclude self-interaction\n            if i == j:\n                continue\n\n            r_vec = xi - particles[j]\n            r_norm = np.linalg.norm(r_vec)\n\n            if 0.0  r_norm  support_radius:\n                q = r_norm / h\n                dPhi_dq_val = get_dPhi_dq(q)\n                \n                # Grad W_ij = (r_vec / r_norm) * (sigma / h^3) * dPhi_dq\n                # This can be rewritten to avoid division by r_norm if r_norm is very small\n                # but for this problem, r_norm is always = dx, which is safe.\n                grad_W_factor = (sigma / (h**3 * r_norm)) * dPhi_dq_val\n                grad_W = r_vec * grad_W_factor\n\n                vj = particles[j]**2\n                v_diff = vj - vi\n                \n                # Accumulate Jacobian contribution: m * outer(v_diff, grad_W)\n                sph_jacobian += m * np.outer(v_diff, grad_W)\n\n        # Exact Jacobian at xi\n        exact_jacobian = np.array([[2.0 * xi[0], 0.0], [0.0, 2.0 * xi[1]]])\n        \n        # Error matrix\n        error_matrix = sph_jacobian - exact_jacobian\n        \n        # Squared Frobenius norm\n        total_squared_frobenius_norm += np.sum(error_matrix**2)\n\n    # RMS Error\n    rms_error = np.sqrt(total_squared_frobenius_norm / len(interior_indices))\n    return rms_error\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "A complete SPH simulation combines spatial discretization with a temporal integration scheme to evolve the system over time. The choice of time integrator is crucial, as it profoundly impacts the long-term stability and physical accuracy of the simulation, particularly with respect to conserved quantities like energy. This practice  explores the dynamics of a classic inviscid vortex to compare the energy conservation properties of different numerical integrators, demonstrating how symplectic methods can prevent the unphysical energy drift often seen in simpler or non-conservative schemes.",
            "id": "3994524",
            "problem": "Consider a two-dimensional, inviscid, barotropic vortex represented by a solid-body rotation with angular velocity $\\Omega$ (in radians per second). The continuum momentum equation is the Euler equation for inviscid flow, given by $D\\mathbf{v}/Dt=-(1/\\rho)\\nabla P$, where $\\mathbf{v}$ is velocity, $\\rho$ is mass density, $P$ is pressure, and $D/Dt$ is the material time derivative. For a uniform density $\\rho_0$ and a pressure field $P(\\mathbf{x})=P_0+\\tfrac{1}{2}\\rho_0\\Omega^2\\|\\mathbf{x}\\|^2$, the acceleration of a fluid parcel is $\\mathbf{a}(\\mathbf{x})=-(1/\\rho_0)\\nabla P(\\mathbf{x})=-\\Omega^2\\mathbf{x}$. This acceleration can be viewed as arising from an effective potential per unit mass $V(\\mathbf{x})=\\tfrac{1}{2}\\Omega^2\\|\\mathbf{x}\\|^2$, and the total mechanical energy per particle $E_i$ is $E_i=\\tfrac{1}{2}\\|\\mathbf{v}_i\\|^2+V(\\mathbf{x}_i)$, which is expected to be conserved for exact dynamics.\n\nUsing Smoothed-Particle Hydrodynamics (SPH), approximate the pressure-gradient force for a set of $N$ particles with positions $\\mathbf{x}_i\\in\\mathbb{R}^2$, velocities $\\mathbf{v}_i\\in\\mathbb{R}^2$, equal masses $m$, and uniform reference density $\\rho_0$ as follows. With the symmetric SPH pressure-gradient approximation and the two-dimensional cubic spline kernel $W(\\mathbf{r},h)$ of smoothing length $h$,\n$$\n\\mathbf{a}_i \\approx -\\sum_{j=1}^N m\\left(\\frac{P_i}{\\rho_0^2}+\\frac{P_j}{\\rho_0^2}\\right)\\nabla W(\\mathbf{x}_i-\\mathbf{x}_j,h),\n$$\nwhere $P_i=P(\\mathbf{x}_i)$ and the two-dimensional cubic spline kernel is\n$$\nW(r,h)=\\alpha_2\n\\begin{cases}\n1-\\tfrac{3}{2}q^2+\\tfrac{3}{4}q^3,  0\\le q1,\\\\\n\\tfrac{1}{4}(2-q)^3,  1\\le q2,\\\\\n0,  q\\ge 2,\n\\end{cases}\n\\quad \\text{with } q=\\frac{r}{h},\\quad \\alpha_2=\\frac{10}{7\\pi h^2},\\quad r=\\|\\mathbf{r}\\|.\n$$\nThe gradient is\n$$\n\\nabla W(\\mathbf{r},h)=\\frac{dW}{dr}\\frac{\\mathbf{r}}{r},\\quad \\frac{dW}{dr}=\\frac{\\alpha_2}{h}\n\\begin{cases}\n-3q+\\tfrac{9}{4}q^2,  0\\le q1,\\\\\n-\\tfrac{3}{4}(2-q)^2,  1\\le q2,\\\\\n0,  q\\ge 2.\n\\end{cases}\n$$\n\nInitialize $N$ particles on a uniform Cartesian grid covering a square domain of side length $2L$ centered at the origin, with grid spacing $\\Delta x$ and $m=\\rho_0\\Delta x^2$. Set initial velocities from the solid-body rotation $\\mathbf{v}_i(0)=\\Omega\\,(-y_i,x_i)$ where $\\mathbf{x}_i(0}=(x_i,y_i)$. Integrate the particle system using three different time integration schemes applied to the first-order system $\\dot{\\mathbf{x}}=\\mathbf{v}$, $\\dot{\\mathbf{v}}=\\mathbf{a}(\\mathbf{x})$:\n- Forward (explicit) Euler: $\\mathbf{x}_{n+1}=\\mathbf{x}_n+\\mathbf{v}_n\\Delta t$, $\\mathbf{v}_{n+1}=\\mathbf{v}_n+\\mathbf{a}(\\mathbf{x}_n)\\Delta t$.\n- Velocity-Verlet (a symplectic method): $\\mathbf{x}_{n+1}=\\mathbf{x}_n+\\mathbf{v}_n\\Delta t+\\tfrac{1}{2}\\mathbf{a}_n\\Delta t^2$, then compute $\\mathbf{a}_{n+1}=\\mathbf{a}(\\mathbf{x}_{n+1})$, and update $\\mathbf{v}_{n+1}=\\mathbf{v}_n+\\tfrac{1}{2}(\\mathbf{a}_n+\\mathbf{a}_{n+1})\\Delta t$.\n- Classical fourth-order Runge–Kutta (RK4) applied to $(\\mathbf{x},\\mathbf{v})$.\n\nFor each integrator, compute the total energy\n$$\nE(t)=\\sum_{i=1}^N m\\left(\\tfrac{1}{2}\\|\\mathbf{v}_i(t)\\|^2+\\tfrac{1}{2}\\Omega^2\\|\\mathbf{x}_i(t)\\|^2\\right)\n$$\nat $t=0$ and at the final time $t=T$. Report the energy drift\n$$\n\\delta=\\frac{E(T)}{E(0)}-1,\n$$\nas a dimensionless decimal number. All lengths must be in meters, time in seconds, density in kilograms per square meter, and angular velocity in radians per second. Angles are in radians. Express the energy drift as a decimal (not with a percentage sign).\n\nImplement the program to perform the following test suite, each defined by $(\\text{integrator},\\Delta t,\\text{steps})$ with common physical parameters $\\rho_0=1\\,\\mathrm{kg/m^2}$, $L=0.25\\,\\mathrm{m}$, $\\Omega=2\\pi\\,\\mathrm{rad/s}$, and smoothing length $h=1.2\\,\\Delta x$ where $\\Delta x=(2L)/(N_x-1)$ for a grid of $N_x=N_y=6$:\n1. $(\\text{Euler},\\, 0.001\\,\\mathrm{s},\\, 2000)$ as a \"happy path\" small time step case.\n2. $(\\text{Euler},\\, 0.005\\,\\mathrm{s},\\, 400)$ as a boundary case demonstrating instability tendencies.\n3. $(\\text{Velocity-Verlet},\\, 0.002\\,\\mathrm{s},\\, 1000)$ as a conservative, symplectic case.\n4. $(\\text{RK4},\\, 0.002\\,\\mathrm{s},\\, 500)$ as a high-order, non-symplectic case.\n\nYour program should produce a single line of output containing the energy drifts for the four cases as a comma-separated list enclosed in square brackets (e.g., \"[drift1,drift2,drift3,drift4]\") in the order listed above. Each list element must be a floating-point number in decimal units (dimensionless), rounded by the default string conversion of Python.",
            "solution": "The problem requires the implementation of a Smoothed-Particle Hydrodynamics (SPH) simulation for a two-dimensional solid-body rotating vortex. The goal is to compare the energy conservation properties of three different time integration schemes: Forward Euler, Velocity-Verlet, and fourth-order Runge-Kutta (RK4). The measure of performance is the relative energy drift, $\\delta$, over a specified number of integration steps.\n\nFirst, we establish the physical and numerical parameters from the problem statement.\nThe simulation domain is a square of side length $2L$ with $L=0.25\\,\\mathrm{m}$, centered at the origin.\nThe particles are placed on a uniform Cartesian grid of size $N_x \\times N_y$, with $N_x=N_y=6$. The total number of particles is $N = N_x \\times N_y = 36$.\nThe grid spacing is $\\Delta x = \\frac{2L}{N_x-1} = \\frac{2 \\times 0.25}{6-1} = 0.1\\,\\mathrm{m}$.\nThe uniform reference density is $\\rho_0 = 1\\,\\mathrm{kg/m^2}$.\nThe mass of each particle is constant, $m = \\rho_0 \\Delta x^2 = 1 \\times (0.1)^2 = 0.01\\,\\mathrm{kg}$.\nThe angular velocity of the vortex is $\\Omega = 2\\pi\\,\\mathrm{rad/s}$.\nThe SPH smoothing length is $h = 1.2\\,\\Delta x = 1.2 \\times 0.1 = 0.12\\,\\mathrm{m}$.\nThe normalization constant for the 2D cubic spline kernel is $\\alpha_2 = \\frac{10}{7\\pi h^2}$.\n\nThe initial state of the system is defined as follows:\nThe initial positions $\\mathbf{x}_i(0) = (x_i, y_i)$ are the coordinates of the points on the $6 \\times 6$ Cartesian grid spanning $[-0.25, 0.25] \\times [-0.25, 0.25]$.\nThe initial velocities $\\mathbf{v}_i(0)$ are determined by the solid-body rotation: $\\mathbf{v}_i(0) = \\Omega(-y_i, x_i)$.\n\nThe core of the simulation is the calculation of particle accelerations. The problem specifies using the SPH symmetric pressure-gradient approximation:\n$$\n\\mathbf{a}_i = -\\sum_{j=1}^N m\\left(\\frac{P_i}{\\rho_0^2}+\\frac{P_j}{\\rho_0^2}\\right)\\nabla W(\\mathbf{x}_i-\\mathbf{x}_j,h)\n$$\nThe pressure $P_i$ at a particle's position $\\mathbf{x}_i$ is given by the analytical formula for the vortex, $P_i = P(\\mathbf{x}_i) = P_0 + \\tfrac{1}{2}\\rho_0\\Omega^2\\|\\mathbf{x}_i\\|^2$. The constant base pressure $P_0$ does not contribute to the gradient force and can be set to $P_0=0$. Thus, $P_i = \\tfrac{1}{2}\\rho_0\\Omega^2\\|\\mathbf{x}_i\\|^2$.\n\nThe gradient of the kernel, $\\nabla W$, is computed for each pair of particles $(i, j)$. Let $\\mathbf{r} = \\mathbf{x}_i - \\mathbf{x}_j$ and $r = \\|\\mathbf{r}\\|$. The gradient is $\\nabla W(\\mathbf{r}, h) = \\frac{dW}{dr}\\frac{\\mathbf{r}}{r}$. The derivative $\\frac{dW}{dr}$ is given by a piecewise function of $q=r/h$:\n$$\n\\frac{dW}{dr}=\\frac{\\alpha_2}{h}\n\\begin{cases}\n-3q+\\tfrac{9}{4}q^2,  0\\le q1,\\\\\n-\\tfrac{3}{4}(2-q)^2,  1\\le q2,\\\\\n0,  q\\ge 2.\n\\end{cases}\n$$\nThe acceleration for each particle $\\mathbf{a}_i$ is computed by summing the contributions from all other particles $j$, weighted by mass, the pressure term, and the kernel gradient. This calculation must be performed at each time step (or multiple times per step for higher-order integrators).\n\nThe evolution of the system is governed by the first-order ordinary differential equations $\\dot{\\mathbf{x}} = \\mathbf{v}$ and $\\dot{\\mathbf{v}} = \\mathbf{a}$. We implement three numerical schemes to integrate these equations.\n\n1.  **Forward (Explicit) Euler:** This is a first-order method. Given the state $(\\mathbf{x}_n, \\mathbf{v}_n)$ at time $t_n$, the state at $t_{n+1}=t_n+\\Delta t$ is:\n    $$\n    \\mathbf{a}_n = \\mathbf{a}(\\mathbf{x}_n) \\\\\n    \\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_n\\Delta t \\\\\n    \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n\\Delta t\n    $$\n\n2.  **Velocity-Verlet:** This is a second-order, symplectic integrator known for good long-term energy conservation in Hamiltonian systems. The update proceeds in three steps:\n    $$\n    \\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_n\\Delta t + \\tfrac{1}{2}\\mathbf{a}_n\\Delta t^2 \\\\\n    \\mathbf{a}_{n+1} = \\mathbf{a}(\\mathbf{x}_{n+1}) \\\\\n    \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\tfrac{1}{2}(\\mathbf{a}_n + \\mathbf{a}_{n+1})\\Delta t\n    $$\n    This requires two acceleration calculations per time step if not for the fact that $\\mathbf{a}_n$ is carried over from the previous step's second half. In implementation, one computes $\\mathbf{a}_n$ at the start of step $n$, performs the position and velocity updates, and saves the final acceleration $\\mathbf{a}_{n+1}$ for the next step.\n\n3.  **Classical Fourth-Order Runge-Kutta (RK4):** This is a high-accuracy, non-symplectic method. For the system $\\dot{\\mathbf{y}} = f(\\mathbf{y})$ with $\\mathbf{y}=(\\mathbf{x}, \\mathbf{v})$, one step involves computing four intermediate slopes ($k_1, k_2, k_3, k_4$) and taking a weighted average. Let $f(\\mathbf{x}, \\mathbf{v}) = (\\mathbf{v}, \\mathbf{a}(\\mathbf{x}))$. The slopes for position ($\\mathbf{k}_x$) and velocity ($\\mathbf{k}_v$) are:\n    $$\n    \\begin{aligned}\n    \\mathbf{k}_{v1} = \\mathbf{a}(\\mathbf{x}_n) \\\\\n    \\mathbf{k}_{x1} = \\mathbf{v}_n \\\\\n    \\mathbf{k}_{v2} = \\mathbf{a}(\\mathbf{x}_n + \\tfrac{\\Delta t}{2}\\mathbf{k}_{x1}) \\\\\n    \\mathbf{k}_{x2} = \\mathbf{v}_n + \\tfrac{\\Delta t}{2}\\mathbf{k}_{v1} \\\\\n    \\mathbf{k}_{v3} = \\mathbf{a}(\\mathbf{x}_n + \\tfrac{\\Delta t}{2}\\mathbf{k}_{x2}) \\\\\n    \\mathbf{k}_{x3} = \\mathbf{v}_n + \\tfrac{\\Delta t}{2}\\mathbf{k}_{v2} \\\\\n    \\mathbf{k}_{v4} = \\mathbf{a}(\\mathbf{x}_n + \\Delta t\\,\\mathbf{k}_{x3}) \\\\\n    \\mathbf{k}_{x4} = \\mathbf{v}_n + \\Delta t\\,\\mathbf{k}_{v3}\n    \\end{aligned}\n    $$\n    The state is then updated as:\n    $$\n    \\mathbf{x}_{n+1} = \\mathbf{x}_n + \\tfrac{\\Delta t}{6}(\\mathbf{k}_{x1} + 2\\mathbf{k}_{x2} + 2\\mathbf{k}_{x3} + \\mathbf{k}_{x4}) \\\\\n    \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\tfrac{\\Delta t}{6}(\\mathbf{k}_{v1} + 2\\mathbf{k}_{v2} + 2\\mathbf{k}_{v3} + \\mathbf{k}_{v4})\n    $$\n    This requires four evaluations of the acceleration function $\\mathbf{a}(\\mathbf{x})$ per time step.\n\nFinally, we assess the energy conservation of each method. The total mechanical energy of the system is given by:\n$$\nE(t) = \\sum_{i=1}^N m \\left( \\tfrac{1}{2}\\|\\mathbf{v}_i(t)\\|^2 + \\tfrac{1}{2}\\Omega^2\\|\\mathbf{x}_i(t)\\|^2 \\right)\n$$\nWe calculate the initial energy $E(0)$ and the final energy $E(T)$ after the specified number of steps ($T = \\text{steps} \\times \\Delta t$). The energy drift $\\delta$ is then computed as:\n$$\n\\delta = \\frac{E(T)}{E(0)} - 1\n$$\nThis procedure is repeated for each of the four test cases specified in the problem, and the resulting drifts are reported.",
            "answer": "```python\nimport numpy as np\n\ndef calculate_acceleration(pos, N, m, rho0, Omega, h, alpha2):\n    \"\"\"\n    Calculates particle accelerations using the SPH pressure gradient approximation.\n    \"\"\"\n    pressures = 0.5 * rho0 * Omega**2 * np.sum(pos**2, axis=1)\n    acc = np.zeros_like(pos)\n    \n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n\n            r_vec = pos[i] - pos[j]\n            r = np.linalg.norm(r_vec)\n            \n            if r == 0 or r = 2 * h:\n                continue\n\n            q = r / h\n\n            dWdr = 0.0\n            # dW/dr for the 2D cubic spline kernel\n            if q  1:\n                dWdr = (alpha2 / h) * (-3.0 * q + 2.25 * q**2)\n            elif q  2:\n                dWdr = (alpha2 / h) * (-0.75 * (2.0 - q)**2)\n            \n            if dWdr == 0.0:\n                continue\n            \n            # Gradient of the kernel W\n            grad_W = (dWdr / r) * r_vec\n            \n            # Symmetrized pressure term\n            pressure_term = (pressures[i] / rho0**2) + (pressures[j] / rho0**2)\n            \n            # Accumulate acceleration contribution from particle j\n            acc[i] -= m * pressure_term * grad_W\n\n    return acc\n\ndef calculate_total_energy(pos, vel, m, Omega):\n    \"\"\"\n    Calculates the total mechanical energy of the particle system.\n    \"\"\"\n    kinetic_energy_sum = np.sum(vel**2)\n    potential_energy_sum = Omega**2 * np.sum(pos**2)\n    total_energy = 0.5 * m * (kinetic_energy_sum + potential_energy_sum)\n    return total_energy\n\ndef run_simulation(integrator, dt, steps, L, rho0, Omega, Nx, Ny):\n    \"\"\"\n    Runs a single SPH simulation for a given integrator and parameters.\n    \"\"\"\n    # Derived parameters\n    N = Nx * Ny\n    dx = (2 * L) / (Nx - 1)\n    h = 1.2 * dx\n    m = rho0 * dx**2\n    alpha2 = 10.0 / (7.0 * np.pi * h**2)\n\n    # Particle initialization\n    x_coords = np.linspace(-L, L, Nx, dtype=np.float64)\n    y_coords = np.linspace(-L, L, Ny, dtype=np.float64)\n    xx, yy = np.meshgrid(x_coords, y_coords)\n    pos = np.vstack([xx.ravel(), yy.ravel()]).T\n    vel = Omega * np.vstack([-pos[:, 1], pos[:, 0]]).T\n\n    # Initial energy\n    E0 = calculate_total_energy(pos, vel, m, Omega)\n    if E0 == 0:\n        return 0.0\n\n    # Integration loop\n    if integrator == 'Euler':\n        for _ in range(steps):\n            acc = calculate_acceleration(pos, N, m, rho0, Omega, h, alpha2)\n            pos += vel * dt\n            vel += acc * dt\n    \n    elif integrator == 'Velocity-Verlet':\n        acc = calculate_acceleration(pos, N, m, rho0, Omega, h, alpha2)\n        for _ in range(steps):\n            pos += vel * dt + 0.5 * acc * dt**2\n            acc_new = calculate_acceleration(pos, N, m, rho0, Omega, h, alpha2)\n            vel += 0.5 * (acc + acc_new) * dt\n            acc = acc_new\n\n    elif integrator == 'RK4':\n        for _ in range(steps):\n            # k1\n            kv1 = calculate_acceleration(pos, N, m, rho0, Omega, h, alpha2)\n            kx1 = vel\n            \n            # k2\n            pos_temp2 = pos + 0.5 * dt * kx1\n            kv2 = calculate_acceleration(pos_temp2, N, m, rho0, Omega, h, alpha2)\n            kx2 = vel + 0.5 * dt * kv1\n\n            # k3\n            pos_temp3 = pos + 0.5 * dt * kx2\n            kv3 = calculate_acceleration(pos_temp3, N, m, rho0, Omega, h, alpha2)\n            kx3 = vel + 0.5 * dt * kv2\n\n            # k4\n            pos_temp4 = pos + dt * kx3\n            kv4 = calculate_acceleration(pos_temp4, N, m, rho0, Omega, h, alpha2)\n            kx4 = vel + dt * kv3\n\n            # Update position and velocity\n            pos += (dt / 6.0) * (kx1 + 2*kx2 + 2*kx3 + kx4)\n            vel += (dt / 6.0) * (kv1 + 2*kv2 + 2*kv3 + kv4)\n\n    # Final energy and drift\n    ET = calculate_total_energy(pos, vel, m, Omega)\n    drift = ET / E0 - 1.0\n    return drift\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Common physical parameters\n    rho0 = 1.0\n    L = 0.25\n    Omega = 2.0 * np.pi\n    Nx, Ny = 6, 6\n    \n    # Test cases: (integrator_name, dt, steps)\n    test_cases = [\n        ('Euler', 0.001, 2000),\n        ('Euler', 0.005, 400),\n        ('Velocity-Verlet', 0.002, 1000),\n        ('RK4', 0.002, 500),\n    ]\n\n    results = []\n    for integrator, dt, steps in test_cases:\n        drift = run_simulation(integrator, dt, steps, L, rho0, Omega, Nx, Ny)\n        results.append(drift)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}