{
    "hands_on_practices": [
        {
            "introduction": "在光滑粒子流体动力学（SPH）中，梯度算子是计算压力梯度力、粘性力等所有空间导数的基础。在将我们的代码应用于复杂的流体模拟之前，验证其实现的正确性至关重要。本练习通过“制造解方法”（Method of Manufactured Solutions）这一标准验证技术，让您实现 SPH 梯度算子，并评估其在粒子间距减小时的数值收敛阶数，从而确保其准确性 。",
            "id": "3994498",
            "problem": "考虑在单位正方形域 $[0,1] \\times [0,1]$ 上定义的人造矢量场 $\\mathbf{v}(x,y) = (x^2, y^2)$。在光滑粒子流体动力学（SPH）中，连续场由具有均匀质量和密度的粒子表示。设粒子布局为均匀的笛卡尔网格，两个方向上的间距均为 $\\Delta x$，均匀密度 $\\rho = 1$（无量纲），粒子质量 $m = \\Delta x^2$。光滑长度为 $h = \\alpha \\Delta x$，其中 $\\alpha$ 是一个正常数。使用具有紧支集 $2h$ 的二维空间中的经典三次样条SPH核函数，其表达式为\n$$\nW(q;h) =\n\\begin{cases}\n\\dfrac{\\sigma}{h^2} \\left(1 - \\dfrac{3}{2} q^2 + \\dfrac{3}{4} q^3 \\right),  0 \\le q  1, \\\\\n\\dfrac{\\sigma}{h^2} \\left(\\dfrac{1}{4} (2 - q)^3 \\right),  1 \\le q  2, \\\\\n0,  q \\ge 2,\n\\end{cases}\n$$\n其中 $q = r/h$，$r = \\|\\mathbf{r}\\|$，二维归一化常数 $\\sigma = \\dfrac{10}{7\\pi}$。核函数梯度为 $\\nabla W(\\mathbf{r};h) = \\dfrac{\\partial W}{\\partial r} \\dfrac{\\mathbf{r}}{r}$，其中 $\\dfrac{\\partial W}{\\partial r} = \\dfrac{\\sigma}{h^3} \\dfrac{d \\Phi}{d q}(q)$ 且\n$$\n\\dfrac{d \\Phi}{d q}(q) =\n\\begin{cases}\n-3 q + \\dfrac{9}{4} q^2,  0 \\le q  1, \\\\\n-\\dfrac{3}{4} (2 - q)^2,  1 \\le q  2, \\\\\n0,  q \\ge 2.\n\\end{cases}\n$$\n从连续SPH插值的角度出发，一个标量场 $f(\\mathbf{x})$ 可以通过核函数加权积分来近似，其梯度可以通过在积分号下微分得到。以此为基础，为 $\\mathbf{v}$ 的每个标量分量推导一个一致的离散SPH梯度算子，该算子用粒子质量、密度和核函数梯度表示。实现您推导的离散算子，以在粒子位置处逐分量地近似雅可比矩阵 $\\nabla \\mathbf{v}$。\n\n为避免核函数支集的边界截断，将误差评估限制在“内部”粒子集合上，这些粒子与每个域边界的距离至少为 $2h$。对于每个位于位置 $(x_i,y_i)$ 的内部粒子，计算近似的雅可比矩阵\n$$\n\\nabla \\mathbf{v}(\\mathbf{x}_i) \\approx\n\\begin{pmatrix}\n\\partial_x (x^2)  \\partial_y (x^2) \\\\\n\\partial_x (y^2)  \\partial_y (y^2)\n\\end{pmatrix}_{\\text{SPH}},\n$$\n并将其与精确的雅可比矩阵进行比较\n$$\n\\nabla \\mathbf{v}_{\\text{exact}}(x_i,y_i) =\n\\begin{pmatrix}\n2x_i  0 \\\\\n0  2y_i\n\\end{pmatrix}.\n$$\n通过近似雅可比矩阵与精确雅可比矩阵之差的弗罗贝尼乌斯范数来衡量每个内部粒子的误差，并通过均方根（RMS）汇总所有内部粒子的误差\n$$\nE(\\Delta x, \\alpha) = \\sqrt{\\dfrac{1}{N_{\\text{int}}} \\sum_{i \\in \\text{interior}} \\left\\| \\nabla \\mathbf{v}_{\\text{SPH}}(\\mathbf{x}_i) - \\nabla \\mathbf{v}_{\\text{exact}}(\\mathbf{x}_i) \\right\\|_F^2 },\n$$\n其中 $N_{\\text{int}}$ 是内部粒子的数量。对于固定的 $\\alpha$，通过对 $(\\log \\Delta x, \\log E)$ 进行线性拟合并提取斜率 $p$ 来评估当 $\\Delta x$ 减小时SPH梯度近似的收敛性，该斜率 $p$ 即为由 $E \\propto (\\Delta x)^p$ 定义的观测精度阶。\n\n实现程序以计算以下每个测试套件中每个 $\\Delta x$ 对应的 $E$，并使用对所有提供的 $\\Delta x$ 值的最小二乘回归报告每个套件的观测阶 $p$：\n\n- 测试用例1（理想情况）：$\\alpha = 1.0$，$\\Delta x \\in \\{0.2, 0.1, 0.05\\}$。\n- 测试用例2（核函数变化）：$\\alpha = 0.8$，$\\Delta x \\in \\{0.2, 0.1, 0.05\\}$。\n- 测试用例3（边界限制的内部区域，边界情况）：$\\alpha = 1.0$，$\\Delta x \\in \\{0.25, 0.125, 0.0625\\}$。\n\n所有计算都是无量纲的。此问题不涉及角度，因此不需要角度单位。您的程序应生成单行输出，其中包含三个观测到的阶数，格式为方括号内以逗号分隔的列表，每个数字四舍五入到六位小数（例如，“[p1,p2,p3]”）。",
            "solution": "该问题已经过验证，并被认定为有效。它在科学上基于光滑粒子流体动力学（SPH）的原理，这是一种标准的数值方法。该问题是适定的，提供了计算唯一、有意义结果所需的所有必要定义、常数和参数。语言客观明确，设置内部一致。\n\n任务的核心是推导并实现一个离散SPH梯度算子，以近似给定矢量场的雅可比矩阵，并随后评估此近似的数值收敛性。\n\n**1. SPH梯度算子的推导**\n\nSPH方法论始于使用具有特征光滑长度 $h$ 的光滑核函数 $W$ 对标量场 $f(\\mathbf{x})$ 进行连续积分表示：\n$$\nf(\\mathbf{x}) \\approx \\int_{\\Omega} f(\\mathbf{x}') W(\\mathbf{x} - \\mathbf{x}', h) \\, d\\mathbf{x}'\n$$\n该场的梯度 $\\nabla f(\\mathbf{x})$ 是通过将梯度算子应用于积分表示来找到的。假设场 $f$ 和核函数 $W$ 具有足够好的性质，微分可以移到积分内部：\n$$\n\\nabla f(\\mathbf{x}) \\approx \\int_{\\Omega} f(\\mathbf{x}') \\nabla_{\\mathbf{x}} W(\\mathbf{x} - \\mathbf{x}', h) \\, d\\mathbf{x}'\n$$\n其中 $\\nabla_{\\mathbf{x}}$ 表示关于坐标 $\\mathbf{x}$ 的梯度。\n\n为了过渡到离散的、基于粒子的公式，域 $\\Omega$ 由一组粒子表示。积分被替换为对这些粒子的求和。每个位于位置 $\\mathbf{x}_j$ 的粒子 $j$ 具有质量 $m_j$ 和密度 $\\rho_j$。其关联的体积元为 $d\\mathbf{x}' \\approx V_j = m_j/\\rho_j$。因此，在粒子 $i$ 的位置 $\\mathbf{x}_i$ 处的梯度通过以下求和来近似：\n$$\n\\nabla f(\\mathbf{x}_i) \\approx \\sum_j f(\\mathbf{x}_j) \\nabla_i W(\\mathbf{x}_i - \\mathbf{x}_j, h) V_j\n$$\n其中 $\\nabla_i W_{ij} \\equiv \\nabla_{\\mathbf{x}} W(\\mathbf{x} - \\mathbf{x}', h)|_{\\mathbf{x}=\\mathbf{x}_i, \\mathbf{x}'=\\mathbf{x}_j}$。\n\n该问题要求推导一个“一致的”离散算子。一个基本的一致性要求是常数场的梯度必须为零。上面展示的直接离散化不能保证这一性质。使用乘积法则恒等式 $\\nabla f = \\frac{1}{\\rho} \\nabla(\\rho f) - \\frac{f}{\\rho} \\nabla \\rho$ 可以获得一个更稳健的公式。将SPH离散化应用于 $\\rho f$ 和 $\\rho$ 的梯度，得到：\n$$\n\\nabla f_i \\approx \\frac{1}{\\rho_i} \\left( \\sum_j (\\rho_j f_j) \\frac{m_j}{\\rho_j} \\nabla_i W_{ij} \\right) - \\frac{f_i}{\\rho_i} \\left( \\sum_j \\rho_j \\frac{m_j}{\\rho_j} \\nabla_i W_{ij} \\right)\n$$\n简化并合并求和项，得到SPH梯度算子的“差分形式”：\n$$\n\\nabla f_i \\approx \\frac{1}{\\rho_i} \\sum_j m_j (f_j - f_i) \\nabla_i W_{ij}\n$$\n这种形式内在地满足了常数场（$f_j = f_i$）的梯度恰好为零的条件。由于问题指定了均匀密度 $\\rho=1$ 和均匀粒子质量 $m = \\Delta x^2$，我们将实现的算子是：\n$$\n\\nabla f_i = \\sum_j m \\left( f_j - f_i \\right) \\nabla_i W_{ij}\n$$\n其中求和遍及粒子 $i$ 的核函数支持半径内的所有邻近粒子 $j$。\n\n**2. 雅可比矩阵近似**\n\n矢量场 $\\mathbf{v}(x,y) = (v_x, v_y)$ 的雅可比矩阵由 $\\nabla \\mathbf{v} = \\begin{pmatrix} \\partial_x v_x  \\partial_y v_x \\\\ \\partial_x v_y  \\partial_y v_y \\end{pmatrix}$ 给出。该矩阵的每个分量都是一个标量场的偏导数，我们使用上面推导的SPH梯度算子来近似它。对于粒子 $i$，SPH近似的雅可比矩阵是：\n$$\n(\\nabla \\mathbf{v}_{\\text{SPH}})_i = \\sum_j m (\\mathbf{v}_j - \\mathbf{v}_i) \\otimes \\nabla_i W_{ij}\n$$\n其中 $\\otimes$ 表示外积。这得到矩阵：\n$$\n(\\nabla \\mathbf{v}_{\\text{SPH}})_i = \\sum_j m\n\\begin{pmatrix}\n(v_{x,j} - v_{x,i}) \\frac{\\partial W_{ij}}{\\partial x_i}  (v_{x,j} - v_{x,i}) \\frac{\\partial W_{ij}}{\\partial y_i} \\\\\n(v_{y,j} - v_{y,i}) \\frac{\\partial W_{ij}}{\\partial x_i}  (v_{y,j} - v_{y,i}) \\frac{\\partial W_{ij}}{\\partial y_i}\n\\end{pmatrix}\n$$\n对于给定的场 $\\mathbf{v}(x,y) = (x^2, y^2)$，我们有 $v_x = x^2$ 和 $v_y = y^2$。\n\n核函数梯度 $\\nabla_i W_{ij}$ 使用提供的公式 $\\nabla W(\\mathbf{r};h) = \\frac{\\partial W}{\\partial r} \\frac{\\mathbf{r}}{r}$ 计算，其中 $\\mathbf{r} = \\mathbf{x}_i - \\mathbf{x}_j$。令 $r_{ij} = \\|\\mathbf{r}\\|$。\n$$\n\\nabla_i W_{ij} = \\frac{\\mathbf{x}_i - \\mathbf{x}_j}{r_{ij}} \\frac{\\partial W}{\\partial r}(r_{ij}; h) = \\frac{\\mathbf{x}_i - \\mathbf{x}_j}{r_{ij}} \\left( \\frac{\\sigma}{h^3} \\frac{d\\Phi}{dq}(q_{ij}) \\right)\n$$\n其中 $q_{ij} = r_{ij}/h$，$\\sigma = 10/(7\\pi)$，且 $\\frac{d\\Phi}{dq}$ 由问题陈述中的分段函数给出。\n\n**3. 算法步骤**\n\n计算误差和收敛阶的总体算法如下：\n\n1.  **粒子生成**：对于给定的间距 $\\Delta x$，在域 $[0,1] \\times [0,1]$ 上创建一个均匀的笛卡尔粒子网格。粒子位置为 $\\mathbf{x}_{k,l} = (k \\Delta x, l \\Delta x)$，其中整数 $k,l$ 的取值应能覆盖整个域。\n\n2.  **识别内部粒子**：为避免边界处核函数截断引起的误差，分析仅限于“内部”粒子。一个位于位置 $(x_i, y_i)$ 的粒子，如果其到所有四个边界（$x=0, x=1, y=0, y=1$）的距离至少为核函数支持半径 $2h$，则为内部粒子。即 $x_i \\in [2h, 1-2h]$ 且 $y_i \\in [2h, 1-2h]$，其中 $h=\\alpha \\Delta x$。\n\n3.  **雅可比矩阵和误差计算**：对于每个内部粒子 $i$：\n    a. 将SPH雅可比矩阵 $(\\nabla \\mathbf{v}_{\\text{SPH}})_i$ 初始化为零。\n    b. 遍历所有其他粒子 $j$ 以找到邻居。如果距离 $r_{ij} = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|$ 在范围 $(0, 2h)$ 内，则粒子 $j$ 是一个邻居。条件 $r_{ij}  0$ 排除了粒子自身。\n    c. 对于每个邻居 $j$，计算核函数梯度 $\\nabla_i W_{ij}$ 和矢量场差 $\\mathbf{v}_j - \\mathbf{v}_i$。\n    d. 计算对雅可比矩阵的贡献 $m (\\mathbf{v}_j - \\mathbf{v}_i) \\otimes \\nabla_i W_{ij}$，并将其加到 $(\\nabla \\mathbf{v}_{\\text{SPH}})_i$ 上。\n    e. 对所有邻居求和后，计算在 $\\mathbf{x}_i$ 处的精确雅可比矩阵：$\\nabla \\mathbf{v}_{\\text{exact}}(x_i,y_i) = \\begin{pmatrix} 2x_i  0 \\\\ 0  2y_i \\end{pmatrix}$。\n    f. 计算误差矩阵的弗罗贝尼乌斯范数的平方：$E_i^2 = \\| (\\nabla \\mathbf{v}_{\\text{SPH}})_i - (\\nabla \\mathbf{v}_{\\text{exact}})_i \\|_F^2$。\n\n4.  **聚合RMS误差**：对所有 $N_{\\text{int}}$ 个内部粒子的平方误差求和，并计算均方根（RMS）误差：\n    $$\n    E(\\Delta x, \\alpha) = \\sqrt{\\frac{1}{N_{\\text{int}}} \\sum_{i \\in \\text{interior}} E_i^2}\n    $$\n\n5.  **收敛阶分析**：对于每个测试套件，我们获得一组与网格间距 $\\Delta x$ 集合相对应的误差值 $E$。精度阶 $p$ 由关系式 $E \\propto (\\Delta x)^p$ 定义。对两边取对数得到 $\\log E = p \\log \\Delta x + C$。因此，$p$ 是拟合数据点 $(\\log \\Delta x, \\log E)$ 的直线的斜率。对每个测试用例，使用线性最小二乘回归计算此斜率。\n\n实现将针对指定的三个测试用例遵循此程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to execute the SPH convergence study as per the problem statement.\n    \"\"\"\n\n    test_cases = [\n        {\"alpha\": 1.0, \"dx_values\": [0.2, 0.1, 0.05]},\n        {\"alpha\": 0.8, \"dx_values\": [0.2, 0.1, 0.05]},\n        {\"alpha\": 1.0, \"dx_values\": [0.25, 0.125, 0.0625]},\n    ]\n\n    orders_of_accuracy = []\n\n    for case in test_cases:\n        alpha = case[\"alpha\"]\n        dx_values = case[\"dx_values\"]\n        \n        errors = []\n        \n        for dx in dx_values:\n            error = compute_rms_error(dx, alpha)\n            errors.append(error)\n\n        log_dx = np.log(dx_values)\n        log_E = np.log(errors)\n        \n        # Perform linear regression to find the slope (order of accuracy)\n        slope, _, _, _, _ = stats.linregress(log_dx, log_E)\n        orders_of_accuracy.append(slope)\n\n    # Format the final output\n    formatted_results = [f\"{p:.6f}\" for p in orders_of_accuracy]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef get_dPhi_dq(q):\n    \"\"\"\n    Computes the derivative of the cubic spline kernel shape function Phi w.r.t. q.\n    \"\"\"\n    if 0.0 = q  1.0:\n        return -3.0 * q + 2.25 * q**2\n    elif 1.0 = q  2.0:\n        return -0.75 * (2.0 - q)**2\n    else:\n        return 0.0\n\ndef compute_rms_error(dx, alpha):\n    \"\"\"\n    Computes the RMS error of the SPH Jacobian approximation for a given dx and alpha.\n    \"\"\"\n    h = alpha * dx\n    m = dx**2\n    sigma = 10.0 / (7.0 * np.pi)\n    support_radius = 2.0 * h\n\n    # Generate particle grid\n    # Add a small epsilon to the range to ensure the endpoint 1.0 is included\n    coords = np.arange(0, 1.0 + dx/2, dx)\n    x_coords, y_coords = np.meshgrid(coords, coords)\n    particles = np.vstack([x_coords.ravel(), y_coords.ravel()]).T\n    \n    # Identify interior particles\n    interior_mask = (particles[:, 0] >= support_radius)  \\\n                    (particles[:, 0] = 1.0 - support_radius)  \\\n                    (particles[:, 1] >= support_radius)  \\\n                    (particles[:, 1] = 1.0 - support_radius)\n    \n    interior_indices = np.where(interior_mask)[0]\n    \n    if len(interior_indices) == 0:\n        # This can happen if 2h > 0.5. The problem setup avoids this.\n        # It's good practice to handle it.\n        return np.nan\n        \n    total_squared_frobenius_norm = 0.0\n\n    for i in interior_indices:\n        xi = particles[i]\n        vi = xi**2  # Vector (xi^2, yi^2)\n        \n        sph_jacobian = np.zeros((2, 2))\n        \n        # Loop over all other particles to find neighbors\n        for j in range(len(particles)):\n            # Exclude self-interaction\n            if i == j:\n                continue\n\n            r_vec = xi - particles[j]\n            r_norm = np.linalg.norm(r_vec)\n\n            if 0.0  r_norm  support_radius:\n                q = r_norm / h\n                dPhi_dq_val = get_dPhi_dq(q)\n                \n                # Grad W_ij = (r_vec / r_norm) * (sigma / h^3) * dPhi_dq\n                # This can be rewritten to avoid division by r_norm if r_norm is very small\n                # but for this problem, r_norm is always >= dx, which is safe.\n                grad_W_factor = (sigma / (h**3 * r_norm)) * dPhi_dq_val\n                grad_W = r_vec * grad_W_factor\n\n                vj = particles[j]**2\n                v_diff = vj - vi\n                \n                # Accumulate Jacobian contribution: m * outer(v_diff, grad_W)\n                sph_jacobian += m * np.outer(v_diff, grad_W)\n\n        # Exact Jacobian at xi\n        exact_jacobian = np.array([[2.0 * xi[0], 0.0], [0.0, 2.0 * xi[1]]])\n        \n        # Error matrix\n        error_matrix = sph_jacobian - exact_jacobian\n        \n        # Squared Frobenius norm\n        total_squared_frobenius_norm += np.sum(error_matrix**2)\n\n    # RMS Error\n    rms_error = np.sqrt(total_squared_frobenius_norm / len(interior_indices))\n    return rms_error\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "掌握了基本的 SPH 算子后，我们可以转向一个更具挑战性的实际问题：多相流。在模拟像空气和水这样密度差异巨大的流体时，标准 SPH 方法常常会在界面处产生非物理性的压力振荡。本练习将引导您在一个简化的静态一维模型中重现并量化这一现象，从而深入理解 SPH 在处理多相流问题时的内在挑战 。",
            "id": "3194363",
            "problem": "本题要求您在一个简化的、具有大密度比的一维光滑粒子流体动力学（SPH）设置中，检验材料界面处的压力振荡，以此作为空气-水问题的近似模型。从质量守恒和SPH中基于核函数的插值定义出发，并采用带有压力偏移的可压缩状态方程来施加一个共同的环境压力。利用这些原理，设计、实现并执行一个程序，量化在一个静态双流体构型中，由求和密度引起的跨界面伪压力振荡。\n\n使用的基本假设和定义，这些在文献中已广为接受，并作为出发点：\n\n- 粒子离散化下的质量守恒意味着粒子索引 $i$ 处的SPH求和密度为\n$$\n\\rho_i \\;=\\; \\sum_{j} m_j \\, W\\!\\left(\\lvert x_i - x_j \\rvert, h\\right),\n$$\n其中 $x_i$ 是位置， $m_j$ 是粒子质量， $h$ 是光滑长度， $W$ 是光滑核函数。\n\n- 使用标准的一维三次样条核函数 $W(r,h)$ ，其中 $q = r/h$ ，定义如下\n$$\nW(r,h) \\;=\\;\n\\begin{cases}\n\\dfrac{1}{h}\\left(\\dfrac{2}{3} - q^2 + \\dfrac{1}{2}q^3\\right),  0 \\le q  1,\\\\\n\\dfrac{1}{6h}\\left(2 - q\\right)^3,  1 \\le q  2,\\\\\n0,  q \\ge 2.\n\\end{cases}\n$$\n\n- 使用带有压力偏移的 Tait 型状态方程来施加一个共同的环境压力 $p_0$ ，即\n$$\np_i \\;=\\; p_0 \\;+\\; B_i \\left[\\left(\\dfrac{\\rho_i}{\\rho_{0,i}}\\right)^{\\gamma_i} - 1\\right],\n$$\n其中\n$$\nB_i \\;=\\; \\dfrac{c_0^2 \\, \\rho_{0,i}}{\\gamma_i},\n$$\n这里 $\\rho_{0,i}$ 是粒子 $i$ 所在相的静止密度， $\\gamma_i$ 是该相的多方指数， $c_0$ 是选定的人工声速，使得 $\\left.\\dfrac{\\partial p}{\\partial \\rho}\\right|_{\\rho=\\rho_{0,i}} = c_0^2$ 。\n\n场景：\n\n- 考虑一个长度为 $L$ 米的一维域，其中有 $N$ 个均匀分布的粒子，位置为 $x_i$ ，覆盖范围为 $[0,L]$ ，间距为 $\\Delta x = L/(N-1)$ 。在 $x = L/2$ 处设置一个界面。位置 $x_i \\le L/2$ 的粒子属于 A 相（“类水”），而位置 $x_i \\ge L/2$ 的粒子属于 B 相（“类空气”）。\n\n- 为 A 相和 B 相分别指定静止密度 $\\rho_{0,\\mathrm{w}}$ 和 $\\rho_{0,\\mathrm{a}}$ 。指定多方指数 $\\gamma_{\\mathrm{w}}$ 和 $\\gamma_{\\mathrm{a}}$ 。对两相使用相同的人工声速 $c_0$ 。环境压力为 $p_0$ 帕斯卡。\n\n- 通过 $m_i = \\rho_{0,i} \\, \\Delta x$ 设置粒子质量，使得离散质量与该相的静止密度和均匀间距相对应。\n\n- 使用上述核函数计算求和密度 $\\rho_i$ ，然后使用所述的状态方程计算压力 $p_i$ 。\n\n- 定义一个“界面窗口”集合 $\\mathcal{S} = \\{ i \\,:\\, \\lvert x_i - L/2 \\rvert \\le 3h \\}$ ，其中 $h$ 是核函数中使用的光滑长度。将此窗口内的振荡幅度测量为\n$$\nE \\;=\\; \\max_{i \\in \\mathcal{S}} \\left\\lvert p_i - p_0 \\right\\rvert.\n$$\n\n- 对每个测试用例，报告无量纲量 $E/p_0$ 作为稳健性度量。\n\n所有测试用例中使用的常量：\n\n- 域长度 $L = 1\\,\\mathrm{m}$ 。\n- 粒子数 $N = 201$ 。\n- 环境压力 $p_0 = 100000\\,\\mathrm{Pa}$ 。\n- 人工声速 $c_0 = 50\\,\\mathrm{m/s}$ 。\n- A 相（“类水”）的多方指数 $\\gamma_{\\mathrm{w}} = 7$ 。\n- B 相（“类空气”）的多方指数 $\\gamma_{\\mathrm{a}} = 1.4$ 。\n\n测试套件：\n\n每个测试用例由 $(\\rho_{0,\\mathrm{w}}, \\rho_{0,\\mathrm{a}}, \\alpha)$ 指定，其中 $h = \\alpha \\,\\Delta x$ 。\n\n- 用例 $1$ （理想路径，中等密度比）： $(1000,\\,100,\\,1.2)$ 。\n- 用例 $2$ （大密度比）： $(1000,\\,1,\\,1.2)$ 。\n- 用例 $3$ （边缘情况，最小光滑）： $(1000,\\,1,\\,1.0)$ 。\n- 用例 $4$ （边缘情况，重度光滑）： $(1000,\\,1,\\,2.0)$ 。\n\n需要实现的内容：\n\n- 如上所述，离散化域并分配粒子属性。\n- 精确实现所述的一维三次样条核函数。\n- 通过求和密度计算 $\\rho_i$ ，然后通过状态方程计算 $p_i$ 。\n- 对每个测试用例，计算界面窗口内的 $E/p_0$ 。\n\n角度单位不适用。将最终结果表示为无量纲十进制数，每个测试用例一个，并按照上面列出的确切顺序。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,r4]”），其中每个 $r_k$ 是为用例 $k$ 计算出的 $E/p_0$ 。",
            "solution": "我们从质量守恒和基于核函数的插值出发，这在光滑粒子流体动力学（SPH）中给出了粒子索引 $i$ 的求和密度：\n$$\n\\rho_i \\;=\\; \\sum_{j} m_j \\, W\\!\\left(\\lvert x_i - x_j \\rvert, h\\right),\n$$\n其中 $m_j$ 是粒子 $j$ 的质量， $x_i$ 表示直线上粒子的位置， $W$ 是一个具有光滑长度 $h$ 的紧支集光滑核函数。此表达式是质量密度与核函数卷积的离散近似，其推导基于强制粒子承载质量并按核函数形状分布的原则。\n\n对于核函数，我们使用标准的一维三次样条，由 $q = r/h$ 定义，\n$$\nW(r,h) \\;=\\;\n\\begin{cases}\n\\dfrac{1}{h}\\left(\\dfrac{2}{3} - q^2 + \\dfrac{1}{2}q^3\\right),  0 \\le q  1,\\\\\n\\dfrac{1}{6h}\\left(2 - q\\right)^3,  1 \\le q  2,\\\\\n0,  q \\ge 2.\n\\end{cases}\n$$\n该核函数非负、归一化且在 $[0,2h)$ 上具有紧支集，因其良好的光滑性和精度特性而被广泛使用。\n\n为了封闭系统并从密度计算压力，我们在弱可压缩格式中使用带有压力偏移的 Tait 型状态方程。当 $\\rho_i = \\rho_{0,i}$ 时，压力偏移确保两相都在一个共同的环境压力 $p_0$ 下初始化。Tait 定律为\n$$\np_i \\;=\\; p_0 \\;+\\; B_i \\left[ \\left(\\dfrac{\\rho_i}{\\rho_{0,i}}\\right)^{\\gamma_i} - 1 \\right].\n$$\n选择系数 $B_i$ ，使得局部可压缩性由一个共同的人工声速 $c_0$ 设定：\n$$\n\\left.\\dfrac{\\partial p}{\\partial \\rho}\\right|_{\\rho = \\rho_{0,i}} \\;=\\; \\dfrac{B_i \\gamma_i}{\\rho_{0,i}} \\;=\\; c_0^2,\n\\quad\\Rightarrow\\quad\nB_i \\;=\\; \\dfrac{c_0^2 \\, \\rho_{0,i}}{\\gamma_i}.\n$$\n这种选择约束了密度波动，并使得在 $\\rho_{0,i}$ 附近的小偏差产生的压力变化在数值上易于处理。\n\n我们构建一个长度为 $L$ 的一维域，其中有 $N$ 个均匀间隔的粒子，位置为 $x_i$ ，覆盖范围为 $[0,L]$ ，间距为 $\\Delta x = L/(N-1)$ 。我们将界面置于 $x=L/2$ 。位置 $x_i \\le L/2$ 的粒子被分配到 A 相（“类水”），其静止密度为 $\\rho_{0,\\mathrm{w}}$ ，多方指数为 $\\gamma_{\\mathrm{w}}$ ；位置 $x_i \\ge L/2$ 的粒子被分配到 B 相（“类空气”），其静止密度为 $\\rho_{0,\\mathrm{a}}$ ，多方指数为 $\\gamma_{\\mathrm{a}}$ 。粒子质量为 $m_i = \\rho_{0,i} \\, \\Delta x$ ，确保离散质量与静止密度积分一致。光滑长度选择为 $h = \\alpha \\Delta x$ ，其中因子 $\\alpha$ 在每个测试用例中给出。使用的常量为 $L=1\\,\\mathrm{m}$ ， $N=201$ ， $p_0=100000\\,\\mathrm{Pa}$ ， $c_0=50\\,\\mathrm{m/s}$ ， $\\gamma_{\\mathrm{w}}=7$ ，以及 $\\gamma_{\\mathrm{a}}=1.4$ 。\n\n算法如下：\n- 计算 $i=1,\\dots,N$ 的位置 $x_i$ 。\n- 根据每个 $x_i$ 相对于 $L/2$ 的位置确定其所属相，并相应地分配 $\\rho_{0,i}$ 和 $\\gamma_i$ 。\n- 计算 $m_i = \\rho_{0,i} \\Delta x$ 。\n- 形成所有成对距离 $r_{ij} = \\lvert x_i - x_j \\rvert$ 。\n- 使用三次样条定义计算 $W(r_{ij}, h)$ 。由于 $W$ 在 $2h$ 之外为零，求和实际上是局部的，但对于 $N=201$ ，直接求和既高效又简单。\n- 对所有 $i$ 计算 $\\rho_i = \\sum_j m_j W(r_{ij}, h)$ 。\n- 计算 $B_i = c_0^2 \\rho_{0,i} / \\gamma_i$ ，然后计算 $p_i = p_0 + B_i [ (\\rho_i/\\rho_{0,i})^{\\gamma_i} - 1 ]$ 。\n- 定义界面窗口 $\\mathcal{S} = \\{ i : \\lvert x_i - L/2 \\rvert \\le 3h \\}$ ，它捕捉了受跨相核函数重叠影响最严重的区域。\n- 计算振荡幅度 $E = \\max_{i \\in \\mathcal{S}} \\lvert p_i - p_0 \\rvert$ 。\n- 报告无量纲比率 $E/p_0$ 。\n\n科学原理：\n- 求和密度是核函数插值下质量守恒的离散表达式；在不连续点（如材料界面）附近的偏差是预料之中的，因为核函数平均会跨界面混合属性。\n- 由于 $\\rho_{0,\\mathrm{w}} \\gg \\rho_{0,\\mathrm{a}}$ 和均匀的 $\\Delta x$ 意味着粒子质量 $m_i$ 差异很大，界面附近低密度侧的密度主要由高密度侧因核函数支撑域重叠而产生的贡献所主导。这导致在轻流体侧 $\\rho_i \\gg \\rho_{0,\\mathrm{a}}$ ，并通过 Tait 定律导致 $p_i \\gg p_0$ ；反之，在重流体侧邻近界面的地方，可能出现 $\\rho_i  \\rho_{0,\\mathrm{w}}$ ，从而产生 $p_i  p_0$ 。得到的 $E$ 量化了这些伪振荡。\n- 光滑长度 $h$ 影响平均区域的宽度。小的 $h$ 会减少跨界面的污染，但可能导致核函数欠解析；大的 $h$ 会增加平均范围，并可能加剧振荡。\n\n测试覆盖范围：\n- 用例 1 探测中等密度比以建立基线响应。\n- 用例 2 探测非常大的密度比（典型的空气-水情况）以评估稳健性。\n- 用例 3 将光滑尺度减小到最小值 $h=\\Delta x$ （窄支撑域）以检查边缘行为。\n- 用例 4 将光滑尺度增加到 $h=2\\Delta x$ （宽支撑域）以测试对过度光滑的敏感性。\n\n该程序直接实现了这些定义，确保了对每个测试用例 $E/p_0$ 的计算是可复现和可验证的，并按要求格式生成单行列表输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef cubic_spline_W(r, h):\n    \"\"\"\n    One-dimensional cubic spline kernel W(r,h).\n    q = r/h\n    W = (1/h)*(2/3 - q^2 + 0.5*q^3) for 0 = q  1\n        (1/(6h))*(2 - q)^3          for 1 = q  2\n        0                            otherwise\n    \"\"\"\n    q = r / h\n    W = np.zeros_like(q)\n    # Region 0 = q  1\n    mask1 = (q >= 0)  (q  1)\n    q1 = q[mask1]\n    W[mask1] = (1.0 / h) * (2.0/3.0 - q1**2 + 0.5*q1**3)\n    # Region 1 = q  2\n    mask2 = (q >= 1)  (q  2)\n    q2 = q[mask2]\n    W[mask2] = (1.0 / (6.0*h)) * (2.0 - q2)**3\n    return W\n\ndef compute_oscillation_ratio(rho_w, rho_a, h_factor,\n                              L=1.0, N=201, p0=100000.0, c0=50.0,\n                              gamma_w=7.0, gamma_a=1.4):\n    \"\"\"\n    Compute E/p0 for a static two-phase 1D SPH configuration:\n    - Phase A (\"water-like\"): x = L/2, rho0 = rho_w, gamma = gamma_w\n    - Phase B (\"air-like\"):   x >= L/2, rho0 = rho_a, gamma = gamma_a\n    - Masses m_i = rho0_i * dx\n    - Smoothing length h = h_factor * dx\n    \"\"\"\n    # Discretize domain\n    x = np.linspace(0.0, L, N)\n    dx = x[1] - x[0]\n    h = h_factor * dx\n    interface_x = 0.5 * L\n\n    # Assign phase properties\n    is_water = x = interface_x\n    rho0 = np.where(is_water, rho_w, rho_a)\n    gamma = np.where(is_water, gamma_w, gamma_a)\n    m = rho0 * dx\n\n    # Pairwise distances\n    r = np.abs(x[:, None] - x[None, :])\n    # Kernel matrix\n    W = cubic_spline_W(r, h)\n    # Summation density\n    rho = W @ m\n\n    # Equation of state parameters and pressure\n    B = (c0**2) * rho0 / gamma\n    # Avoid division by zero in case rho0 has zeros (should not happen by construction)\n    ratio = rho / rho0\n    # Pressures\n    p = p0 + B * (np.power(ratio, gamma) - 1.0)\n\n    # Interface window: |x - L/2| = 3h\n    mask_window = np.abs(x - interface_x) = (3.0 * h)\n    if not np.any(mask_window):\n        # If window is empty due to extreme parameters, fall back to nearest-neighbor inclusion\n        # This is extremely unlikely for the given test suite.\n        nearest_idx = np.argmin(np.abs(x - interface_x))\n        mask_window = np.zeros_like(x, dtype=bool)\n        mask_window[nearest_idx] = True\n\n    E = np.max(np.abs(p[mask_window] - p0))\n    return E / p0\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple is (rho_w, rho_a, h_factor)\n    test_cases = [\n        (1000.0, 100.0, 1.2),  # Case 1: moderate density ratio\n        (1000.0, 1.0,   1.2),  # Case 2: large density ratio\n        (1000.0, 1.0,   1.0),  # Case 3: minimal smoothing\n        (1000.0, 1.0,   2.0),  # Case 4: heavy smoothing\n    ]\n\n    results = []\n    for rho_w, rho_a, h_factor in test_cases:\n        result = compute_oscillation_ratio(\n            rho_w=rho_w,\n            rho_a=rho_a,\n            h_factor=h_factor,\n            L=1.0,\n            N=201,\n            p0=100000.0,\n            c0=50.0,\n            gamma_w=7.0,\n            gamma_a=1.4\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "成功的 SPH 模拟不仅需要精确的空间离散，还需要稳定可靠的时间积分方案。不同的时间积分器在长期模拟中对能量等守恒量的保持能力差异显著，直接影响模拟的物理真实性。本练习通过模拟一个理想化的无粘性涡旋，要求您比较几种常见积分器（如欧拉法、Verlet 法和龙格-库塔法）的能量守恒特性，揭示数值耗散和不稳定性是如何产生的 。",
            "id": "3994524",
            "problem": "考虑一个二维、无粘性的正压涡旋，它以角速度 $\\Omega$（单位为弧度/秒）进行刚体旋转。其连续介质动量方程是用于无粘性流动的欧拉方程，由 $D\\mathbf{v}/Dt=-(1/\\rho)\\nabla P$ 给出，其中 $\\mathbf{v}$ 是速度，$\\rho$ 是质量密度， $P$ 是压力， $D/Dt$ 是物质时间导数。对于均匀密度 $\\rho_0$ 和压力场 $P(\\mathbf{x})=P_0+\\tfrac{1}{2}\\rho_0\\Omega^2\\|\\mathbf{x}\\|^2$，流体质点的加速度为 $\\mathbf{a}(\\mathbf{x})=-(1/\\rho_0)\\nabla P(\\mathbf{x})=-\\Omega^2\\mathbf{x}$。这个加速度可以看作是由单位质量的有效势 $V(\\mathbf{x})=\\tfrac{1}{2}\\Omega^2\\|\\mathbf{x}\\|^2$ 产生的，并且每个粒子的总机械能 $E_i$ 为 $E_i=\\tfrac{1}{2}\\|\\mathbf{v}_i\\|^2+V(\\mathbf{x}_i)$，对于精确动力学，该能量预期是守恒的。\n\n使用光滑粒子流体动力学 (SPH)，为一组具有位置 $\\mathbf{x}_i\\in\\mathbb{R}^2$、速度 $\\mathbf{v}_i\\in\\mathbb{R}^2$、相等质量 $m$ 和均匀参考密度 $\\rho_0$ 的 $N$ 个粒子近似压力梯度力，如下所示。使用对称的 SPH 压力梯度近似和光滑长度为 $h$ 的二维三次样条核函数 $W(\\mathbf{r},h)$，\n$$\n\\mathbf{a}_i \\approx -\\sum_{j=1}^N m\\left(\\frac{P_i}{\\rho_0^2}+\\frac{P_j}{\\rho_0^2}\\right)\\nabla W(\\mathbf{x}_i-\\mathbf{x}_j,h),\n$$\n其中 $P_i=P(\\mathbf{x}_i)$，二维三次样条核函数为\n$$\nW(r,h)=\\alpha_2\n\\begin{cases}\n1-\\tfrac{3}{2}q^2+\\tfrac{3}{4}q^3,  0\\le q1,\\\\\n\\tfrac{1}{4}(2-q)^3,  1\\le q2,\\\\\n0,  q\\ge 2,\n\\end{cases}\n\\quad \\text{with } q=\\frac{r}{h},\\quad \\alpha_2=\\frac{10}{7\\pi h^2},\\quad r=\\|\\mathbf{r}\\|.\n$$\n其梯度为\n$$\n\\nabla W(\\mathbf{r},h)=\\frac{dW}{dr}\\frac{\\mathbf{r}}{r},\\quad \\frac{dW}{dr}=\\frac{\\alpha_2}{h}\n\\begin{cases}\n-3q+\\tfrac{9}{4}q^2,  0\\le q1,\\\\\n-\\tfrac{3}{4}(2-q)^2,  1\\le q2,\\\\\n0,  q\\ge 2.\n\\end{cases}\n$$\n\n在以原点为中心、边长为 $2L$ 的正方形域上，使用均匀的笛卡尔网格初始化 $N$ 个粒子，网格间距为 $\\Delta x$，且 $m=\\rho_0\\Delta x^2$。根据刚体旋转设置初始速度 $\\mathbf{v}_i(0)=\\Omega\\,(-y_i,x_i)$，其中 $\\mathbf{x}_i(0)=(x_i,y_i)$。应用三种不同的时间积分方案，对一阶系统 $\\dot{\\mathbf{x}}=\\mathbf{v}$，$\\dot{\\mathbf{v}}=\\mathbf{a}(\\mathbf{x})$ 进行积分：\n- 前向（显式）欧拉法：$\\mathbf{x}_{n+1}=\\mathbf{x}_n+\\mathbf{v}_n\\Delta t$，$\\mathbf{v}_{n+1}=\\mathbf{v}_n+\\mathbf{a}(\\mathbf{x}_n)\\Delta t$。\n- Velocity-Verlet（一种辛方法）：$\\mathbf{x}_{n+1}=\\mathbf{x}_n+\\mathbf{v}_n\\Delta t+\\tfrac{1}{2}\\mathbf{a}_n\\Delta t^2$，然后计算 $\\mathbf{a}_{n+1}=\\mathbf{a}(\\mathbf{x}_{n+1})$，并更新 $\\mathbf{v}_{n+1}=\\mathbf{v}_n+\\tfrac{1}{2}(\\mathbf{a}_n+\\mathbf{a}_{n+1})\\Delta t$。\n- 应用于 $(\\mathbf{x},\\mathbf{v})$ 的经典四阶龙格-库塔 (RK4) 法。\n\n对于每个积分器，计算总能量\n$$\nE(t)=\\sum_{i=1}^N m\\left(\\tfrac{1}{2}\\|\\mathbf{v}_i(t)\\|^2+\\tfrac{1}{2}\\Omega^2\\|\\mathbf{x}_i(t)\\|^2\\right)\n$$\n在 $t=0$ 和最终时间 $t=T$ 时。报告能量漂移\n$$\n\\delta=\\frac{E(T)}{E(0)}-1,\n$$\n其为一个无量纲十进制数。所有长度单位必须是米，时间单位是秒，密度单位是千克/平方米，角速度单位是弧度/秒。角度单位是弧度。将能量漂移表示为十进制数（不带百分号）。\n\n实现程序以执行以下测试套件，每个套件由 $(\\text{integrator},\\Delta t,\\text{steps})$ 定义，并具有共同的物理参数 $\\rho_0=1\\,\\mathrm{kg/m^2}$，$L=0.25\\,\\mathrm{m}$，$\\Omega=2\\pi\\,\\mathrm{rad/s}$，以及光滑长度 $h=1.2\\,\\Delta x$，其中对于 $N_x=N_y=6$ 的网格，$\\Delta x=(2L)/(N_x-1)$：\n1. $(\\text{Euler},\\, 0.001\\,\\mathrm{s},\\, 2000)$ 作为一个“理想状况”的小时间步长案例。\n2. $(\\text{Euler},\\, 0.005\\,\\mathrm{s},\\, 400)$ 作为一个展示不稳定趋势的边界案例。\n3. $(\\text{Velocity-Verlet},\\, 0.002\\,\\mathrm{s},\\, 1000)$ 作为一个保守的辛方法案例。\n4. $(\\text{RK4},\\, 0.002\\,\\mathrm{s},\\, 500)$ 作为一个高阶非辛方法案例。\n\n您的程序应生成单行输出，其中包含四个案例的能量漂移，格式为逗号分隔的列表，并用方括号括起来（例如，“[drift1,drift2,drift3,drift4]”），顺序与上面列出的一致。每个列表元素必须是十进制单位（无量纲）的浮点数，并由 Python 的默认字符串转换进行舍入。",
            "solution": "该问题要求实现一个用于二维刚体旋转涡旋的光滑粒子流体动力学 (SPH) 模拟。目标是比较三种不同时间积分方案的能量守恒特性：前向欧拉法、Velocity-Verlet 和四阶龙格-库塔 (RK4)。性能的衡量标准是在指定数量的积分步数内的相对能量漂移 $\\delta$。\n\n首先，我们根据问题陈述确定物理和数值参数。\n模拟区域是一个以原点为中心、边长为 $2L$（其中 $L=0.25\\,\\mathrm{m}$）的正方形。\n粒子被放置在一个大小为 $N_x \\times N_y$ 的均匀笛卡尔网格上，其中 $N_x=N_y=6$。粒子总数为 $N = N_x \\times N_y = 36$。\n网格间距为 $\\Delta x = \\frac{2L}{N_x-1} = \\frac{2 \\times 0.25}{6-1} = 0.1\\,\\mathrm{m}$。\n均匀参考密度为 $\\rho_0 = 1\\,\\mathrm{kg/m^2}$。\n每个粒子的质量是恒定的，$m = \\rho_0 \\Delta x^2 = 1 \\times (0.1)^2 = 0.01\\,\\mathrm{kg}$。\n涡旋的角速度为 $\\Omega = 2\\pi\\,\\mathrm{rad/s}$。\nSPH 光滑长度为 $h = 1.2\\,\\Delta x = 1.2 \\times 0.1 = 0.12\\,\\mathrm{m}$。\n二维三次样条核函数的归一化常数为 $\\alpha_2 = \\frac{10}{7\\pi h^2}$。\n\n系统的初始状态定义如下：\n初始位置 $\\mathbf{x}_i(0) = (x_i, y_i)$ 是跨越 $[-0.25, 0.25] \\times [-0.25, 0.25]$ 的 $6 \\times 6$ 笛卡尔网格上点的坐标。\n初始速度 $\\mathbf{v}_i(0)$ 由刚体旋转确定：$\\mathbf{v}_i(0) = \\Omega(-y_i, x_i)$。\n\n模拟的核心是粒子加速度的计算。问题指定使用 SPH 对称压力梯度近似：\n$$\n\\mathbf{a}_i = -\\sum_{j=1}^N m\\left(\\frac{P_i}{\\rho_0^2}+\\frac{P_j}{\\rho_0^2}\\right)\\nabla W(\\mathbf{x}_i-\\mathbf{x}_j,h)\n$$\n粒子位置 $\\mathbf{x}_i$ 处的压力 $P_i$ 由涡旋的解析公式给出，$P_i = P(\\mathbf{x}_i) = P_0 + \\tfrac{1}{2}\\rho_0\\Omega^2\\|\\mathbf{x}_i\\|^2$。常数基准压力 $P_0$ 对梯度力没有贡献，可以设置为 $P_0=0$。因此，$P_i = \\tfrac{1}{2}\\rho_0\\Omega^2\\|\\mathbf{x}_i\\|^2$。\n\n核函数的梯度 $\\nabla W$ 是为每对粒子 $(i, j)$ 计算的。设 $\\mathbf{r} = \\mathbf{x}_i - \\mathbf{x}_j$ 且 $r = \\|\\mathbf{r}\\|$。梯度为 $\\nabla W(\\mathbf{r}, h) = \\frac{dW}{dr}\\frac{\\mathbf{r}}{r}$。导数 $\\frac{dW}{dr}$ 由 $q=r/h$ 的分段函数给出：\n$$\n\\frac{dW}{dr}=\\frac{\\alpha_2}{h}\n\\begin{cases}\n-3q+\\tfrac{9}{4}q^2,  0\\le q1,\\\\\n-\\tfrac{3}{4}(2-q)^2,  1\\le q2,\\\\\n0,  q\\ge 2.\n\\end{cases}\n$$\n每个粒子 $\\mathbf{a}_i$ 的加速度是通过将所有其他粒子 $j$ 的贡献相加来计算的，这些贡献由质量、压力项和核函数梯度加权。这个计算必须在每个时间步中执行（对于高阶积分器，每个步长可能需要多次计算）。\n\n系统的演化由一阶常微分方程 $\\dot{\\mathbf{x}} = \\mathbf{v}$ 和 $\\dot{\\mathbf{v}} = \\mathbf{a}$ 控制。我们实现三种数值方案来对这些方程进行积分。\n\n1.  **前向（显式）欧拉法：** 这是一种一阶方法。给定在时间 $t_n$ 的状态 $(\\mathbf{x}_n, \\mathbf{v}_n)$，在 $t_{n+1}=t_n+\\Delta t$ 的状态是：\n    $$\n    \\mathbf{a}_n = \\mathbf{a}(\\mathbf{x}_n) \\\\\n    \\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_n\\Delta t \\\\\n    \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n\\Delta t\n    $$\n\n2.  **Velocity-Verlet：** 这是一种二阶辛积分器，以在哈密顿系统中具有良好的长期能量守恒性而闻名。更新过程分三步进行：\n    $$\n    \\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_n\\Delta t + \\tfrac{1}{2}\\mathbf{a}_n\\Delta t^2 \\\\\n    \\mathbf{a}_{n+1} = \\mathbf{a}(\\mathbf{x}_{n+1}) \\\\\n    \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\tfrac{1}{2}(\\mathbf{a}_n + \\mathbf{a}_{n+1})\\Delta t\n    $$\n    这每个时间步需要两次加速度计算，但考虑到 $\\mathbf{a}_n$ 是从上一步的后半部分继承过来的。在实现中，我们在第 $n$ 步开始时计算 $\\mathbf{a}_n$，执行位置和速度更新，并保存最终的加速度 $\\mathbf{a}_{n+1}$ 供下一步使用。\n\n3.  **经典四阶龙格-库塔 (RK4)：** 这是一种高精度、非辛方法。对于系统 $\\dot{\\mathbf{y}} = f(\\mathbf{y})$，其中 $\\mathbf{y}=(\\mathbf{x}, \\mathbf{v})$，一个步骤涉及计算四个中间斜率（$k_1, k_2, k_3, k_4$）并取其加权平均值。设 $f(\\mathbf{x}, \\mathbf{v}) = (\\mathbf{v}, \\mathbf{a}(\\mathbf{x}))$。位置（$\\mathbf{k}_x$）和速度（$\\mathbf{k}_v$）的斜率是：\n    $$\n    \\begin{aligned}\n    \\mathbf{k}_{v1} = \\mathbf{a}(\\mathbf{x}_n) \\\\\n    \\mathbf{k}_{x1} = \\mathbf{v}_n \\\\\n    \\mathbf{k}_{v2} = \\mathbf{a}(\\mathbf{x}_n + \\tfrac{\\Delta t}{2}\\mathbf{k}_{x1}) \\\\\n    \\mathbf{k}_{x2} = \\mathbf{v}_n + \\tfrac{\\Delta t}{2}\\mathbf{k}_{v1} \\\\\n    \\mathbf{k}_{v3} = \\mathbf{a}(\\mathbf{x}_n + \\tfrac{\\Delta t}{2}\\mathbf{k}_{x2}) \\\\\n    \\mathbf{k}_{x3} = \\mathbf{v}_n + \\tfrac{\\Delta t}{2}\\mathbf{k}_{v2} \\\\\n    \\mathbf{k}_{v4} = \\mathbf{a}(\\mathbf{x}_n + \\Delta t\\,\\mathbf{k}_{x3}) \\\\\n    \\mathbf{k}_{x4} = \\mathbf{v}_n + \\Delta t\\,\\mathbf{k}_{v3}\n    \\end{aligned}\n    $$\n    然后状态更新如下：\n    $$\n    \\mathbf{x}_{n+1} = \\mathbf{x}_n + \\tfrac{\\Delta t}{6}(\\mathbf{k}_{x1} + 2\\mathbf{k}_{x2} + 2\\mathbf{k}_{x3} + \\mathbf{k}_{x4}) \\\\\n    \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\tfrac{\\Delta t}{6}(\\mathbf{k}_{v1} + 2\\mathbf{k}_{v2} + 2\\mathbf{k}_{v3} + \\mathbf{k}_{v4})\n    $$\n    这每个时间步需要四次加速度函数 $\\mathbf{a}(\\mathbf{x})$ 的评估。\n\n最后，我们评估每种方法的能量守恒性。系统的总机械能由以下公式给出：\n$$\nE(t) = \\sum_{i=1}^N m \\left( \\tfrac{1}{2}\\|\\mathbf{v}_i(t)\\|^2 + \\tfrac{1}{2}\\Omega^2\\|\\mathbf{x}_i(t)\\|^2 \\right)\n$$\n我们计算初始能量 $E(0)$ 和在指定步数（$T = \\text{steps} \\times \\Delta t$）后的最终能量 $E(T)$。然后能量漂移 $\\delta$ 计算如下：\n$$\n\\delta = \\frac{E(T)}{E(0)} - 1\n$$\n对问题中指定的四个测试案例中的每一个重复此过程，并报告所得的漂移。",
            "answer": "```python\nimport numpy as np\n\ndef calculate_acceleration(pos, N, m, rho0, Omega, h, alpha2):\n    \"\"\"\n    Calculates particle accelerations using the SPH pressure gradient approximation.\n    \"\"\"\n    pressures = 0.5 * rho0 * Omega**2 * np.sum(pos**2, axis=1)\n    acc = np.zeros_like(pos)\n    \n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n\n            r_vec = pos[i] - pos[j]\n            r = np.linalg.norm(r_vec)\n            \n            if r == 0 or r >= 2 * h:\n                continue\n\n            q = r / h\n\n            dWdr = 0.0\n            # dW/dr for the 2D cubic spline kernel\n            if q  1:\n                dWdr = (alpha2 / h) * (-3.0 * q + 2.25 * q**2)\n            elif q  2:\n                dWdr = (alpha2 / h) * (-0.75 * (2.0 - q)**2)\n            \n            if dWdr == 0.0:\n                continue\n            \n            # Gradient of the kernel W\n            grad_W = (dWdr / r) * r_vec\n            \n            # Symmetrized pressure term\n            pressure_term = (pressures[i] / rho0**2) + (pressures[j] / rho0**2)\n            \n            # Accumulate acceleration contribution from particle j\n            acc[i] -= m * pressure_term * grad_W\n\n    return acc\n\ndef calculate_total_energy(pos, vel, m, Omega):\n    \"\"\"\n    Calculates the total mechanical energy of the particle system.\n    \"\"\"\n    kinetic_energy_sum = np.sum(vel**2)\n    potential_energy_sum = Omega**2 * np.sum(pos**2)\n    total_energy = 0.5 * m * (kinetic_energy_sum + potential_energy_sum)\n    return total_energy\n\ndef run_simulation(integrator, dt, steps, L, rho0, Omega, Nx, Ny):\n    \"\"\"\n    Runs a single SPH simulation for a given integrator and parameters.\n    \"\"\"\n    # Derived parameters\n    N = Nx * Ny\n    dx = (2 * L) / (Nx - 1)\n    h = 1.2 * dx\n    m = rho0 * dx**2\n    alpha2 = 10.0 / (7.0 * np.pi * h**2)\n\n    # Particle initialization\n    x_coords = np.linspace(-L, L, Nx, dtype=np.float64)\n    y_coords = np.linspace(-L, L, Ny, dtype=np.float64)\n    xx, yy = np.meshgrid(x_coords, y_coords)\n    pos = np.vstack([xx.ravel(), yy.ravel()]).T\n    vel = Omega * np.vstack([-pos[:, 1], pos[:, 0]]).T\n\n    # Initial energy\n    E0 = calculate_total_energy(pos, vel, m, Omega)\n    if E0 == 0:\n        return 0.0\n\n    # Integration loop\n    if integrator == 'Euler':\n        for _ in range(steps):\n            acc = calculate_acceleration(pos, N, m, rho0, Omega, h, alpha2)\n            pos += vel * dt\n            vel += acc * dt\n    \n    elif integrator == 'Velocity-Verlet':\n        acc = calculate_acceleration(pos, N, m, rho0, Omega, h, alpha2)\n        for _ in range(steps):\n            pos += vel * dt + 0.5 * acc * dt**2\n            acc_new = calculate_acceleration(pos, N, m, rho0, Omega, h, alpha2)\n            vel += 0.5 * (acc + acc_new) * dt\n            acc = acc_new\n\n    elif integrator == 'RK4':\n        for _ in range(steps):\n            # k1\n            kv1 = calculate_acceleration(pos, N, m, rho0, Omega, h, alpha2)\n            kx1 = vel\n            \n            # k2\n            pos_temp2 = pos + 0.5 * dt * kx1\n            kv2 = calculate_acceleration(pos_temp2, N, m, rho0, Omega, h, alpha2)\n            kx2 = vel + 0.5 * dt * kv1\n\n            # k3\n            pos_temp3 = pos + 0.5 * dt * kx2\n            kv3 = calculate_acceleration(pos_temp3, N, m, rho0, Omega, h, alpha2)\n            kx3 = vel + 0.5 * dt * kv2\n\n            # k4\n            pos_temp4 = pos + dt * kx3\n            kv4 = calculate_acceleration(pos_temp4, N, m, rho0, Omega, h, alpha2)\n            kx4 = vel + dt * kv3\n\n            # Update position and velocity\n            pos += (dt / 6.0) * (kx1 + 2*kx2 + 2*kx3 + kx4)\n            vel += (dt / 6.0) * (kv1 + 2*kv2 + 2*kv3 + kv4)\n\n    # Final energy and drift\n    ET = calculate_total_energy(pos, vel, m, Omega)\n    drift = ET / E0 - 1.0\n    return drift\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Common physical parameters\n    rho0 = 1.0\n    L = 0.25\n    Omega = 2.0 * np.pi\n    Nx, Ny = 6, 6\n    \n    # Test cases: (integrator_name, dt, steps)\n    test_cases = [\n        ('Euler', 0.001, 2000),\n        ('Euler', 0.005, 400),\n        ('Velocity-Verlet', 0.002, 1000),\n        ('RK4', 0.002, 500),\n    ]\n\n    results = []\n    for integrator, dt, steps in test_cases:\n        drift = run_simulation(integrator, dt, steps, L, rho0, Omega, Nx, Ny)\n        results.append(drift)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}