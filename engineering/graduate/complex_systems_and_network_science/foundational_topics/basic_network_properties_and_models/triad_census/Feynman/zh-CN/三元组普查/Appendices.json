{
    "hands_on_practices": [
        {
            "introduction": "在进行任何三元组普查分析之前，我们必须掌握一项基本技能：如何以编程方式明确无误地识别任意一个三节点子图的类型。本练习将指导你为16种三元组同构类构建一个唯一的、同构不变的“签名”，这是计算图论中的一个核心概念。完成此练习将为你提供进行任何三元组普查分析所必需的基础工具。",
            "id": "4312800",
            "problem": "考虑一个固定的包含 $3$ 个标记节点的有向简单图，图中没有自环，且任意有序节点对之间最多只有一条有向边。这 $3$ 个节点上的导出子图可以被归类为三元组普查（triad census）的 $16$ 个同构类之一，传统上用名称 $\\{003, 012, 102, 021D, 021U, 021C, 111D, 111U, 030T, 030C, 201, 120D, 120U, 120C, 210, 300\\}$ 来表示。任务是构建一个算法，仅使用节点的入度、节点的出度以及无序节点对的互反性指标，将任意给定的 $3$ 节点有向导出子图分类到这 $16$ 个类中的一个。\n\n基本基础。使用以下图论中的核心定义和事实作为基础出发点：\n- 一个有向简单图 $G = (V, E)$ 有一个有限的节点集 $V$ 和一个有向边集 $E \\subseteq V \\times V$，图中没有自环，且不同节点之间的每个方向上最多只有一条边。\n- 对于节点 $i \\in V$，其入度 $d_i^{in}$ 是形如 $(j, i) \\in E$ 的边的数量，其出度 $d_i^{out}$ 是形如 $(i, j) \\in E$ 的边的数量。\n- 对于任意不同的节点组成的无序对 $\\{i,j\\}$，定义互反性指标 $M_{ij}$：如果 $(i,j) \\in E$ 和 $(j,i) \\in E$ 同时成立，则为 $1$，否则为 $0$。\n- 对于一个 $3$ 节点导出子图，存在 $3$ 个无序对（二元组）。每个二元组要么是空（两个方向都没有边），要么是非对称（恰好存在一条有向边），要么是互反（两条有向边都存在）。令 $m$ 表示互反二元组的数量，$a$ 表示非对称二元组的数量，$n$ 表示空二元组的数量。则有 $m + a + n = 3$。有向边的总数 $|E|$ 满足 $$|E| = \\sum_{i=1}^{3} d_i^{out} = \\sum_{i=1}^{3} d_i^{in} = 2m + a,$$ 因为每个互反二元组贡献 $2$ 条有向边，每个非对称二元组贡献 $1$ 条有向边。\n\n设计目标。基于上述基础，推导出一个完整的判定程序，该程序仅使用每个节点的度对 $\\{(d_i^{in}, d_i^{out})\\}_{i=1}^{3}$ 和 $3$ 个无序对的互反性指标 $\\{M_{ij}\\}$ 来识别 $3$ 节点导出子图唯一的三元组普查类。该分类必须在节点标签方面具有同构不变性。\n\n输出规范。根据以下映射，将 $16$ 个三元组类别编码为整数标识符：\n- $003 \\mapsto 0$\n- $012 \\mapsto 1$\n- $102 \\mapsto 2$\n- $021D \\mapsto 3$\n- $021U \\mapsto 4$\n- $021C \\mapsto 5$\n- $111D \\mapsto 6$\n- $111U \\mapsto 7$\n- $030T \\mapsto 8$\n- $030C \\mapsto 9$\n- $201 \\mapsto 10$\n- $120D \\mapsto 11$\n- $120U \\mapsto 12$\n- $120C \\mapsto 13$\n- $210 \\mapsto 14$\n- $300 \\mapsto 15$\n\n您的程序必须实现分类算法，并将其应用于以下包含 $16$ 个导出子图的测试套件，每个子图由其在节点 $\\{1,2,3\\}$ 上的有向边集指定：\n- 测试 $1$：$\\varnothing$。\n- 测试 $2$：$\\{(1,2)\\}$。\n- 测试 $3$：$\\{(1,2),(2,1)\\}$。\n- 测试 $4$：$\\{(1,2),(1,3)\\}$。\n- 测试 $5$：$\\{(2,1),(3,1)\\}$。\n- 测试 $6$：$\\{(1,2),(2,3)\\}$。\n- 测试 $7$：$\\{(1,2),(2,1),(1,3)\\}$。\n- 测试 $8$：$\\{(1,2),(2,1),(3,1)\\}$。\n- 测试 $9$：$\\{(1,2),(1,3),(2,3)\\}$。\n- 测试 $10$：$\\{(1,2),(2,3),(3,1)\\}$。\n- 测试 $11$：$\\{(1,2),(2,1),(1,3),(3,1)\\}$。\n- 测试 $12$：$\\{(1,2),(2,1),(1,3),(2,3)\\}$。\n- 测试 $13$：$\\{(1,2),(2,1),(3,1),(3,2)\\}$。\n- 测试 $14$：$\\{(1,2),(2,1),(1,3),(3,2)\\}$。\n- 测试 $15$：$\\{(1,2),(2,1),(1,3),(3,1),(2,3)\\}$。\n- 测试 $16$：$\\{(1,2),(2,1),(1,3),(3,1),(2,3),(3,2)\\}$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含一个逗号分隔的 $16$ 个整数标识符列表，按测试 $1$ 到 $16$ 的顺序排列，并用方括号括起来（例如，$[r_1,r_2,\\dots,r_{16}]$）。此问题不涉及物理单位或角度。程序必须在没有任何输入的情况下运行，且不得访问外部文件或网络。该算法必须仅在其决策逻辑中使用每个节点的度和互反性指标，如上所述。",
            "solution": "### 步骤 1：提取给定信息\n问题为 $3$ 节点有向导出子图的分类提供了以下数据、定义和约束：\n- **图结构**：该图是一个包含 $3$ 个标记节点的有向简单图。它没有自环，且任意有序节点对之间最多只有一条有向边。\n- **节点集**：$V = \\{1, 2, 3\\}$。\n- **入度和出度**：对于节点 $i \\in V$，入度 $d_i^{in}$ 是入边的数量，出度 $d_i^{out}$ 是出边的数量。\n- **互反性指标**：对于任意不同的节点组成的无序对 $\\{i,j\\}$，如果 $(i,j)$ 和 $(j,i)$ 都是边，则 $M_{ij} = 1$，否则为 $0$。\n- **二元组计数**：对于 $3$ 个二元组（无序节点对），$m$ 是互反二元组的数量，$a$ 是非对称二元组的数量，$n$ 是空二元组的数量。这些计数满足 $m + a + n = 3$。\n- **边数关系**：有向边的总数 $|E|$ 由 $|E| = \\sum_{i=1}^{3} d_i^{out} = \\sum_{i=1}^{3} d_i^{in} = 2m + a$ 给出。\n- **设计目标**：分类算法必须仅使用每个节点的度对 $\\{(d_i^{in}, d_i^{out})\\}_{i=1}^{3}$ 和 $3$ 个无序对的互反性指标 $\\{M_{ij}\\}$。分类必须是同构不变的。\n- **输出映射**：提供了一个从 $16$ 个三元组普查类名到整数标识符 $0$ 到 $15$ 的特定映射。\n- **测试套件**：提供了一个包含 $16$ 个测试用例的列表，每个用例由节点 $\\{1,2,3\\}$ 上的有向边集定义，用于验证。\n\n### 步骤 2：使用提取的给定信息进行验证\n根据验证标准对问题陈述进行评估：\n\n1.  **科学依据**：该问题植根于网络科学和图论的既定领域，特别是关于三元组普查，这是由 Holland 和 Leinhardt 开发的用于网络模体分析的标准工具。所有定义（入度、出度、互反性）都是标准的。$3$ 节点有向图的 $16$ 个同构类的枚举是该领域的一个基本结果。该问题在科学上是合理的。\n2.  **适定性**：问题要求一种算法，将任何 $3$ 节点有向图唯一地分类到 $16$ 个不同的同构类之一。如下所示，所提供的信息（度对和互反性指标）足以构建一个完整且明确的分类方案。因此，存在唯一且有意义的解。\n3.  **客观性**：问题使用精确、形式化的数学语言陈述。所有术语都有明确定义，目标清晰且可量化。没有主观或基于意见的内容。\n4.  **不完整或矛盾的设置**：问题是自洽的。所有必要的定义和约束都已提供。定义在内部是一致的（例如，边数、度和二元组计数之间的关系成立）。\n5.  **不切实际或不可行**：问题处理的是抽象的数学对象（图），不涉及物理约束。指定的任务在计算上是可行的。\n6.  **不适定或结构不良**：问题结构良好。目标是找到一种同构不变的分类方法，而提供的输入（度和互反性）是可用于构建此类不变量的属性。\n7.  **伪深刻、琐碎或同义反复**：问题解决的是一个非琐碎的分类任务。虽然解决方案是系统性的，但它需要仔细的推导来证明给定的信息基础是充分的，这构成了一个有效的概念性练习。\n8.  **超出科学可验证性**：问题及其解决方案完全在数学领域内，可以进行形式化验证。\n\n### 步骤 3：结论与行动\n问题有效。这是一个适定的、有科学依据的、形式化指定的图论任务。将提供一个解决方案。\n\n### 分类算法的推导\n\n目标是创建一个针对 $3$ 节点有向导出子图的同构不变分类程序，仅使用节点度和二元组互反性。同构不变属性是指对于同一同构类中的所有图都相同的属性。\n\n设三个节点为 $v_1, v_2, v_3$。可用于分类的信息是度对集合 $\\{(d_1^{in}, d_1^{out}), (d_2^{in}, d_2^{out}), (d_3^{in}, d_3^{out})\\}$ 和互反性指标集合 $\\{M_{12}, M_{13}, M_{23}\\}$。\n\n为确保同构不变性，我们必须使用不依赖于节点任意标记的特征。我们可以如下构建这些特征：\n1.  **总互反数（$m$）**：互反二元组的数量 $m = \\sum_{\\{i,j\\}} M_{ij}$ 在节点重标记下是不变的。\n2.  **排序度序列**：度对集合依赖于节点标签。然而，这些对的排序列表是同构不变量。我们将按字典序对 $(d_i^{in}, d_i^{out})$ 对的列表进行排序。\n\n因此，任何三元组类的唯一特征标记将是元组 $(m, \\text{排序度对})$。我们将证明该特征标记唯一地标识了 $16$ 个三元组类中的每一个。\n\n分类过程如下：\n1.  给定一个 $3$ 节点子图的边集，计算 $3$ 个节点中每个节点的入度和出度。\n2.  计算互反二元组的数量 $m$。\n3.  将三个 $(d^{in}, d^{out})$ 对组成一个列表并按字典序排序。\n4.  $m$ 和排序后的度对列表的组合构成一个唯一的键，直接映射到 $16$ 个三元组类之一。\n\n我们现在系统地推导每个 $16$ 个类的特征标记。这些类按互反二元组的数量 $m \\in \\{0, 1, 2, 3\\}$ 分组。\n\n**情况 $m=0$（无互反二元组）**\n总边数为 $|E| = a$。\n-   **类 003 (ID 0)**: $a=0, n=3 \\implies |E|=0$。所有度均为 $(0,0)$。\n    -   特征标记：$m=0$, 排序度：$((0,0), (0,0), (0,0))$。\n-   **类 012 (ID 1)**: $a=1, n=2 \\implies |E|=1$。一条边 $(v_1, v_2)$。度：$d_1: (0,1)$, $d_2: (1,0)$, $d_3: (0,0)$。\n    -   特征标记：$m=0$, 排序度：$((0,0), (0,1), (1,0))$。\n-   **类 021 (IDs 3, 4, 5)**: $a=2, n=1 \\implies |E|=2$。\n    -   **021D (ID 3)**：“向下”构型，例如 $(v_1, v_2), (v_1, v_3)$。一个源节点。度：$d_1: (0,2)$, $d_2: (1,0)$, $d_3: (1,0)$。\n        -   特征标记：$m=0$, 排序度：$((0,2), (1,0), (1,0))$。\n    -   **021U (ID 4)**：“向上”构型，例如 $(v_2, v_1), (v_3, v_1)$。一个汇节点。度：$d_1: (2,0)$, $d_2: (0,1)$, $d_3: (0,1)$。\n        -   特征标记：$m=0$, 排序度：$((0,1), (0,1), (2,0))$。\n    -   **021C (ID 5)**：“循环”路径，例如 $(v_1, v_2), (v_2, v_3)$。度：$d_1: (0,1)$, $d_2: (1,1)$, $d_3: (1,0)$。\n        -   特征标记：$m=0$, 排序度：$((0,1), (1,0), (1,1))$。\n-   **类 030 (IDs 8, 9)**: $a=3, n=0 \\implies |E|=3$。\n    -   **030T (ID 8)**：传递性竞赛图，例如 $(v_1,v_2), (v_2,v_3), (v_1,v_3)$。度：$d_1: (0,2)$, $d_2: (1,1)$, $d_3: (2,0)$。\n        -   特征标记：$m=0$, 排序度：$((0,2), (1,1), (2,0))$。\n    -   **030C (ID 9)**：循环性竞赛图，例如 $(v_1,v_2), (v_2,v_3), (v_3,v_1)$。度：$d_1: (1,1)$, $d_2: (1,1)$, $d_3: (1,1)$。\n        -   特征标记：$m=0$, 排序度：$((1,1), (1,1), (1,1))$。\n\n**情况 $m=1$（一个互反二元组）**\n总边数为 $|E| = 2+a$。\n-   **类 102 (ID 2)**: $a=0, n=2 \\implies |E|=2$。一个互反二元组，例如 $(v_1,v_2), (v_2,v_1)$。度：$d_1: (1,1)$, $d_2: (1,1)$, $d_3: (0,0)$。\n    -   特征标记：$m=1$, 排序度：$((0,0), (1,1), (1,1))$。\n-   **类 111 (IDs 6, 7)**: $a=1, n=1 \\implies |E|=3$。\n    -   **111D (ID 6)**：互反二元组 + 出边，例如 $(v_1,v_2), (v_2,v_1), (v_1,v_3)$。度：$d_1: (1,2)$, $d_2: (1,1)$, $d_3: (1,0)$。\n        -   特征标记：$m=1$, 排序度：$((1,0), (1,1), (1,2))$。\n    -   **111U (ID 7)**：互反二元组 + 入边，例如 $(v_1,v_2), (v_2,v_1), (v_3,v_1)$。度：$d_1: (2,1)$, $d_2: (1,1)$, $d_3: (0,1)$。\n        -   特征标记：$m=1$, 排序度：$((0,1), (1,1), (2,1))$。\n-   **类 120 (IDs 11, 12, 13)**: $a=2, n=0 \\implies |E|=4$。\n    -   **120D (ID 11)**：互反二元组 + 两条出边，例如 $(v_1,v_2), (v_2,v_1), (v_1,v_3), (v_2,v_3)$。度：$d_1: (1,2)$, $d_2: (1,2)$, $d_3: (2,0)$。\n        -   特征标记：$m=1$, 排序度：$((1,2), (1,2), (2,0))$。\n    -   **120U (ID 12)**：互反二元组 + 两条入边，例如 $(v_1,v_2), (v_2,v_1), (v_3,v_1), (v_3,v_2)$。度：$d_1: (2,1)$, $d_2: (2,1)$, $d_3: (0,2)$。\n        -   特征标记：$m=1$, 排序度：$((0,2), (2,1), (2,1))$。\n    -   **120C (ID 13)**：互反二元组 + 路径，例如 $(v_1,v_2), (v_2,v_1), (v_1,v_3), (v_3,v_2)$。度：$d_1: (1,2)$, $d_2: (2,1)$, $d_3: (1,1)$。\n        -   特征标记：$m=1$, 排序度：$((1,1), (1,2), (2,1))$。\n\n**情况 $m=2$（两个互反二元组）**\n总边数为 $|E| = 4+a$。\n-   **类 201 (ID 10)**: $a=0, n=1 \\implies |E|=4$。例如 $(v_1,v_2), (v_2,v_1), (v_1,v_3), (v_3,v_1)$。中心节点 $v_1$。度：$d_1: (2,2)$, $d_2: (1,1)$, $d_3: (1,1)$。\n    -   特征标记：$m=2$, 排序度：$((1,1), (1,1), (2,2))$。\n-   **类 210 (ID 14)**: $a=1, n=0 \\implies |E|=5$。两个互反二元组 + 一条非对称边，例如 $(v_1,v_2), (v_2,v_1), (v_1,v_3), (v_3,v_1), (v_2,v_3)$。度：$d_1: (2,2)$, $d_2: (1,2)$, $d_3: (2,1)$。\n    -   特征标记：$m=2$, 排序度：$((1,2), (2,1), (2,2))$。\n\n**情况 $m=3$（三个互反二元组）**\n-   **类 300 (ID 15)**: $a=0, n=0 \\implies |E|=6$。完全有向图。度：$d_1, d_2, d_3$ 均为 $(2,2)$。\n    -   特征标记：$m=3$, 排序度：$((2,2), (2,2), (2,2))$。\n\n此分析证实，特征标记 $(m, \\text{排序度对})$ 对于 $16$ 个同构类中的每一个都是唯一的。算法可以预先计算这些特征标记并将其存储在查找表中，以实现高效分类。实现将构建此查找表，用于将测试图计算出的特征标记映射到其对应的整数 ID。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the triad census classification problem for the given test suite.\n    \"\"\"\n\n    # Mapping from triad census names to the specified integer IDs.\n    CLASS_TO_ID = {\n        '003': 0, '012': 1, '102': 2, '021D': 3, '021U': 4,\n        '021C': 5, '111D': 6, '111U': 7, '030T': 8, '030C': 9,\n        '201': 10, '120D': 11, '120U': 12, '120C': 13, '210': 14,\n        '300': 15\n    }\n\n    # This signature map is the core of the classification algorithm.\n    # It maps the unique signature (m, sorted_degree_pairs) to a triad class ID.\n    # The degree pairs are sorted lexicographically.\n    SIGNATURE_TO_ID = {\n        # m = 0\n        (0, ((0, 0), (0, 0), (0, 0))): CLASS_TO_ID['003'],\n        (0, ((0, 0), (0, 1), (1, 0))): CLASS_TO_ID['012'],\n        (0, ((0, 2), (1, 0), (1, 0))): CLASS_TO_ID['021D'],\n        (0, ((0, 1), (0, 1), (2, 0))): CLASS_TO_ID['021U'],\n        (0, ((0, 1), (1, 0), (1, 1))): CLASS_TO_ID['021C'],\n        (0, ((0, 2), (1, 1), (2, 0))): CLASS_TO_ID['030T'],\n        (0, ((1, 1), (1, 1), (1, 1))): CLASS_TO_ID['030C'],\n        # m = 1\n        (1, ((0, 0), (1, 1), (1, 1))): CLASS_TO_ID['102'],\n        (1, ((1, 0), (1, 1), (1, 2))): CLASS_TO_ID['111D'],\n        (1, ((0, 1), (1, 1), (2, 1))): CLASS_TO_ID['111U'],\n        (1, ((1, 2), (1, 2), (2, 0))): CLASS_TO_ID['120D'],\n        (1, ((0, 2), (2, 1), (2, 1))): CLASS_TO_ID['120U'],\n        (1, ((1, 1), (1, 2), (2, 1))): CLASS_TO_ID['120C'],\n        # m = 2\n        (2, ((1, 1), (1, 1), (2, 2))): CLASS_TO_ID['201'],\n        (2, ((1, 2), (2, 1), (2, 2))): CLASS_TO_ID['210'],\n        # m = 3\n        (3, ((2, 2), (2, 2), (2, 2))): CLASS_TO_ID['300'],\n    }\n\n    def classify_triad(edges):\n        \"\"\"\n        Classifies a 3-node directed graph based on its edge set.\n        The algorithm uses only node degrees and mutuality indicators as required.\n        Nodes are assumed to be 1, 2, 3 as in the problem, but are mapped to\n        0, 1, 2 for array indexing.\n        \"\"\"\n        num_nodes = 3\n        adj = np.zeros((num_nodes, num_nodes), dtype=int)\n        for u, v in edges:\n            if 1 = u = num_nodes and 1 = v = num_nodes:\n                adj[u - 1, v - 1] = 1\n\n        # Calculate in-degrees and out-degrees for each node.\n        # axis=0 sums columns (incoming edges), axis=1 sums rows (outgoing edges).\n        in_degrees = adj.sum(axis=0)\n        out_degrees = adj.sum(axis=1)\n\n        degree_pairs = []\n        for i in range(num_nodes):\n            degree_pairs.append((in_degrees[i], out_degrees[i]))\n\n        # Sort the degree pairs to create an isomorphism-invariant feature.\n        # Python's default tuple sorting is lexicographical.\n        degree_pairs.sort()\n        \n        # Calculate mutuality indicators and the total count of mutual dyads (m).\n        m = 0\n        node_indices = range(num_nodes)\n        for i in node_indices:\n            for j in range(i + 1, num_nodes):\n                if adj[i, j] == 1 and adj[j, i] == 1:\n                    m += 1\n\n        # The signature is the tuple of m and the sorted degree pairs.\n        # The list of pairs must be converted to a tuple to be a dictionary key.\n        signature = (m, tuple(degree_pairs))\n\n        # Look up the signature to get the class ID.\n        return SIGNATURE_TO_ID.get(signature)\n\n    # Test suite from the problem statement.\n    test_cases = [\n        set(),                                             # Test 1: 003\n        {(1, 2)},                                          # Test 2: 012\n        {(1, 2), (2, 1)},                                  # Test 3: 102\n        {(1, 2), (1, 3)},                                  # Test 4: 021D\n        {(2, 1), (3, 1)},                                  # Test 5: 021U\n        {(1, 2), (2, 3)},                                  # Test 6: 021C\n        {(1, 2), (2, 1), (1, 3)},                          # Test 7: 111D\n        {(1, 2), (2, 1), (3, 1)},                          # Test 8: 111U\n        {(1, 2), (1, 3), (2, 3)},                          # Test 9: 030T\n        {(1, 2), (2, 3), (3, 1)},                          # Test 10: 030C\n        {(1, 2), (2, 1), (1, 3), (3, 1)},                  # Test 11: 201\n        {(1, 2), (2, 1), (1, 3), (2, 3)},                  # Test 12: 120D\n        {(1, 2), (2, 1), (3, 1), (3, 2)},                  # Test 13: 120U\n        {(1, 2), (2, 1), (1, 3), (3, 2)},                  # Test 14: 120C\n        {(1, 2), (2, 1), (1, 3), (3, 1), (2, 3)},          # Test 15: 210\n        {(1, 2), (2, 1), (1, 3), (3, 1), (2, 3), (3, 2)},  # Test 16: 300\n    ]\n\n    results = []\n    for case in test_cases:\n        result_id = classify_triad(case)\n        results.append(str(result_id))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了如何对三元组进行计数后，下一步是解读这些计数的意义。本练习将揭示一个关键点：若没有合适的基准进行比较，原始计数值本身是毫无意义的。通过一个具体的定量例子，你将看到不同零模型的选择会如何彻底改变关于网络结构模式的科学结论，这是统计网络分析中至关重要的一课。",
            "id": "4312795",
            "problem": "考虑一个包含 $n=60$ 个顶点的有向简单网络。三元组普查统计有向网络中3节点子图的同构类数量。前馈环 (FFL) 三元组是一种传递有向三元组，它在三个节点上构成，包含有向边 $A \\to B$、$A \\to C$ 和 $B \\to C$，且没有互反弧；在标准三元组普查表示法中，这类通常被记为 $030\\mathrm{T}$。给定该网络的以下全局统计数据：\n- 对于任意有序的不同节点对，存在一条有向边的边际概率为 $p=0.25$，因此每个无序二元组（节点对）的期望边数为 $d=2p=0.5$。\n- 无序节点对的二元组状态分布为：互惠二元组概率 $m=0.18$（双向边都存在），非对称二元组概率 $a=0.14$（恰好存在一个方向的边），以及空二元组概率 $u=0.68$（两个方向都没有边），因此满足 $2m+a=d$。\n- 观测到的 FFL 三元组数量为 $T_{\\mathrm{obs}}=300$。\n\n考虑两种零模型：\n- 零模型 $\\mathcal{N}_1$：有向 Erdős–Rényi (ER) 模型，其中每条可能的有向边都以概率 $p$ 独立存在，二元组的状态由独立存在的边涌现而出。\n- 零模型 $\\mathcal{N}_2$：一个保持互惠性的二元组独立模型，其中每个无序二元组以概率 $m$、$a$、$u$ 被独立地赋予一个状态，对于非对称二元组，其方向在两个可能方向上是等可能的，且在不同二元组之间是独立的。\n\n仅从三元组普查的核心定义、零模型中的独立性假设以及基本概率论出发，推导在每种零模型下，一个给定的不同节点三元组形成 FFL 三元组的期望概率，并由此推导出 FFL 三元组的期望数量。使用这些结果来评估与每种零模型相比，FFL 是过度表示还是表示不足。为了使评估定量化，通过将不同的节点三元组视为具有所推导出的 FFL 概率的独立伯努利试验，来近似计算每种零模型下三元组计数的方差，并计算相应的 $z$-分数 $z=(T_{\\mathrm{obs}}-\\mathbb{E}[T])/\\sqrt{\\mathrm{Var}(T)}$。\n\n哪个选项正确地给出了期望计数、表示评估，并证明了一个不合适的零模型（此处为 $\\mathcal{N}_1$）相对于一个更合适的零模型（$\\mathcal{N}_2$）可以反转过度/表示不足的符号？\n\nA. 在 $p=0.25$ 的 $\\mathcal{N}_1$ 模型下，期望 FFL 计数为 $\\binom{60}{3}\\cdot 6p^3(1-p)^3\\approx 1353$，得出表示不足，且 $z\\approx -29$。在 $a=0.14$ 的 $\\mathcal{N}_2$ 模型下，期望 FFL 计数为 $\\binom{60}{3}\\cdot \\tfrac{3}{4}a^3\\approx 70$，得出过度表示，且 $z\\approx 27$，从而在两种零模型之间反转了符号。\n\nB. 在 $\\mathcal{N}_1$ 模型下，期望 FFL 计数为 $\\binom{60}{3}\\cdot p^3(1-p)^3\\approx 226$，在 $\\mathcal{N}_2$ 模型下，其值为 $\\binom{60}{3}\\cdot \\tfrac{1}{2}a^3\\approx 130$；在这两种情况下，相对于期望值，FFL 都是过度表示的。\n\nC. 在 $\\mathcal{N}_1$ 模型下，期望 FFL 计数为 $\\binom{60}{3}\\cdot 2p^3(1-p)^3\\approx 451$，而在 $\\mathcal{N}_2$ 模型下，其值为 $\\binom{60}{3}\\cdot \\tfrac{3}{4}a^2\\approx 504$；在这两种情况下，FFL 都是表示不足的。\n\nD. FFL 的期望概率与互惠性无关，在任何匹配 $p$ 的零模型下都等于 $6p^3(1-p)^3$；由于 $T_{\\mathrm{obs}}=300$，它在两种零模型下都是表示不足的。",
            "solution": "用户希望我分析一个关于有向网络中前馈环 (FFL) 三元组模体的问题。我将首先验证问题陈述的有效性，如果有效，则继续进行完整的推导和对给定选项的评估。\n\n### 问题验证\n\n**第1步：提取已知条件**\n\n- 网络类型：有向简单网络\n- 顶点数：$n=60$\n- 关注的模体：前馈环 (FFL)，一种传递有向三元组，包含有向边 $A \\to B$、$A \\to C$ 和 $B \\to C$，且没有互反弧。这对应于三元组同构类 $030\\mathrm{T}$。\n- 全局网络统计数据：\n    - 边际弧概率：$p=0.25$\n    - 每个无序二元组的期望边数：$d=2p=0.5$\n    - 无序节点对的二元组状态概率：\n        - 互惠二元组概率 ($m$)：$m=0.18$\n        - 非对称二元组概率 ($a$)：$a=0.14$\n        - 空二元组概率 ($u$)：$u=0.68$\n    - 提供的一致性检查：$2m+a = 2(0.18) + 0.14 = 0.36 + 0.14 = 0.50 = d$，满足条件。此外，概率之和为1：$m+a+u = 0.18+0.14+0.68=1.0$。\n- 观测到的 FFL 三元组数量：$T_{\\mathrm{obs}}=300$\n- 用于比较的零模型：\n    - $\\mathcal{N}_1$：有向 Erdős–Rényi (ER) 模型，其中 $n(n-1)$ 条可能的有向边中的每一条都以概率 $p=0.25$ 独立存在。\n    - $\\mathcal{N}_2$：一个保持互惠性的二元组独立模型，其中 $\\binom{n}{2}$ 个无序二元组中的每一个都以概率 $m, a, u$ 被独立地赋予一个状态（互惠、非对称、空）。对于非对称二元组，单向边的方向以 $1/2$ 的概率选择两个可能性之一。\n- 任务：推导每种零模型下 FFL 的期望数量 $\\mathbb{E}[T]$。通过计算 $z$-分数 $z=(T_{\\mathrm{obs}}-\\mathbb{E}[T])/\\sqrt{\\mathrm{Var}(T)}$ 来评估 FFL 模体的过度/表示不足，其中方差近似为将不同的节点三元组视为独立的伯努利试验。\n\n**第2步：使用提取的已知条件进行验证**\n\n- **科学依据：** 该问题牢固地植根于网络科学，特别是在网络模体分析领域。三元组普查、FFL、Erdős–Rényi 模型和（如 $\\mathcal{N}_2$ 的）配置模型等概念都是该领域的标准内容。\n- **良构性：** 问题是良构的。所有必要的参数（$n, p, m, a, u, T_{\\mathrm{obs}}$）都已提供，并且零模型被精确定义。任务要求计算具体的、可计算的量。\n- **客观性：** 语言是客观和技术性的。\n- **一致性：** 如第1步所示，提供的数值（$p, m, a, u$）是内部一致的。\n- **缺陷检查：** 问题不违反任何无效性标准。这是一个标准的、非平凡的概率网络分析练习，突出了零模型选择的关键作用。\n\n**第3步：结论和行动**\n\n问题陈述有效。我将继续进行推导。\n\n### 推导与求解\n\n网络中不同节点三元组的总数为 $N_{triples} = \\binom{n}{3}$。当 $n=60$ 时，这个值为：\n$$ \\binom{60}{3} = \\frac{60 \\times 59 \\times 58}{3 \\times 2 \\times 1} = 10 \\times 59 \\times 58 = 34220 $$\n\nFFL 是三个节点上的一种特定类型的导出子图。问题将其定义为类别 $030\\mathrm{T}$ 的传递有向三元组，这意味着恰好有三条有向边形成一个传递模式（例如，$A \\to B, B \\to C, A \\to C$），且这三个节点之间没有其他边。这意味着连接这些节点的三个二元组必须都是非对称的。\n\n**在零模型 $\\mathcal{N}_1$ (有向 ER 模型) 下的分析**\n\n在 $\\mathcal{N}_1$ 模型下，每条可能的 $n(n-1)$ 条有向边都以概率 $p=0.25$ 独立存在。对于一个给定的不同节点三元组，比如 $\\{V_1, V_2, V_3\\}$，存在 $2\\binom{3}{2}=6$ 条可能的有向边。\n\n要形成一个 FFL，我们需要恰好3条边呈传递模式，而另外3条可能的边必须不存在。让我们考虑一个特定的 FFL 构型，例如 $V_1 \\to V_2, V_1 \\to V_3, V_2 \\to V_3$。这需要以下六个独立事件：\n1. 边 $V_1 \\to V_2$ 存在（概率为 $p$）\n2. 边 $V_2 \\to V_1$ 不存在（概率为 $1-p$）\n3. 边 $V_1 \\to V_3$ 存在（概率为 $p$）\n4. 边 $V_3 \\to V_1$ 不存在（概率为 $1-p$）\n5. 边 $V_2 \\to V_3$ 存在（概率为 $p$）\n6. 边 $V_3 \\to V_2$ 不存在（概率为 $1-p$）\n\n这个特定构型的概率是 $p^3(1-p)^3$。\n\n对于任意给定的节点三元组，有多种方式可以形成 FFL。一个 FFL 有一个唯一的“源”节点（出度为2）、一个“中间”节点（入度为1，出度为1）和一个“汇”节点（入度为2）。我们可以从3个节点中选择源节点，从剩下的2个节点中选择汇节点，最后一个则是中间节点。这就在一个标记三元-组上给出了 $3 \\times 2 \\times 1 = 3! = 6$ 种可能的、互斥的 FFL 构型。\n\n一个随机选择的节点三元组形成 FFL 的概率 $P_{FFL}(\\mathcal{N}_1)$ 是这6种构型概率之和：\n$$ P_{FFL}(\\mathcal{N}_1) = 6 \\cdot p^3(1-p)^3 $$\nFFL 的期望数量 $\\mathbb{E}[T_{\\mathcal{N}_1}]$ 是三元组总数乘以这个概率：\n$$ \\mathbb{E}[T_{\\mathcal{N}_1}] = \\binom{n}{3} \\cdot 6 p^3(1-p)^3 $$\n使用给定的值 $n=60$ 和 $p=0.25$：\n$$ \\mathbb{E}[T_{\\mathcal{N}_1}] = 34220 \\cdot 6 \\cdot (0.25)^3 (1-0.25)^3 = 34220 \\cdot 6 \\cdot \\left(\\frac{1}{4}\\right)^3 \\left(\\frac{3}{4}\\right)^3 = 34220 \\cdot 6 \\cdot \\frac{27}{4096} = 34220 \\cdot \\frac{162}{4096} \\approx 1353.18 $$\n观测数量为 $T_{\\mathrm{obs}}=300$，远低于期望数量 $\\approx 1353$。因此，相对于 $\\mathcal{N}_1$，FFL 是**表示不足**的。\n\n为了计算 $z$-分数，我们将方差近似为 $\\mathrm{Var}(T) \\approx N_{triples} P_{FFL} (1-P_{FFL}) \\approx \\mathbb{E}[T] (1-P_{FFL})$。\n$$ P_{FFL}(\\mathcal{N}_1) = 6 \\cdot \\frac{27}{4096} \\approx 0.03955 $$\n$$ \\mathrm{Var}(T_{\\mathcal{N}_1}) \\approx 1353.18 \\cdot (1 - 0.03955) \\approx 1299.66 $$\n$$ \\sigma_{\\mathcal{N}_1} = \\sqrt{\\mathrm{Var}(T_{\\mathcal{N}_1})} \\approx \\sqrt{1299.66} \\approx 36.05 $$\n$z$-分数为：\n$$ z_1 = \\frac{T_{\\mathrm{obs}} - \\mathbb{E}[T_{\\mathcal{N}_1}]}{\\sigma_{\\mathcal{N}_1}} \\approx \\frac{300 - 1353.18}{36.05} \\approx -29.21 $$\n\n**在零模型 $\\mathcal{N}_2$ (保持互惠性的二元组独立模型) 下的分析**\n\n在 $\\mathcal{N}_2$ 模型下，连接节点 $\\{V_1, V_2, V_3\\}$ 的三个二元组的状态是独立的。要形成 FFL，所有三个二元组都必须是非对称的。单个二元组为非对称的概率是 $a=0.14$。所有三个二元组都为非对称的概率是 $a^3$。\n\n给定三个二元组都是非对称的，我们需要找到它们的朝向形成传递模式（FFL）而不是循环模式的概率。对于每个非对称二元组，有两种可能的朝向，每种概率为 $1/2$。因此，对于三个二元组，有 $2^3 = 8$ 种同样可能的朝向模式。\n这8种模式对应于3个标记顶点上所有可能的锦标赛的边集。其中有两个循环锦标赛（$V_1 \\to V_2 \\to V_3 \\to V_1$ 和 $V_1 \\to V_3 \\to V_2 \\to V_1$）和 $8-2=6$ 个传递锦标赛（FFL）。\n因此，给定三个非对称二元组，形成 FFL 的条件概率是 $6/8 = 3/4$。\n\n一个随机选择的节点三元组形成 FFL 的概率 $P_{FFL}(\\mathcal{N}_2)$ 是：\n$$ P_{FFL}(\\mathcal{N}_2) = P(\\text{所有3个二元组都是非对称的}) \\times P(\\text{模式是传递的} | \\text{3个非对称二元组}) $$\n$$ P_{FFL}(\\mathcal{N}_2) = a^3 \\cdot \\frac{3}{4} $$\nFFL 的期望数量 $\\mathbb{E}[T_{\\mathcal{N}_2}]$ 是：\n$$ \\mathbb{E}[T_{\\mathcal{N}_2}] = \\binom{n}{3} \\cdot \\frac{3}{4} a^3 $$\n使用给定的值 $n=60$ 和 $a=0.14$：\n$$ \\mathbb{E}[T_{\\mathcal{N}_2}] = 34220 \\cdot \\frac{3}{4} \\cdot (0.14)^3 = 34220 \\cdot 0.75 \\cdot 0.002744 \\approx 70.42 $$\n观测数量为 $T_{\\mathrm{obs}}=300$，远高于期望数量 $\\approx 70$。因此，相对于 $\\mathcal{N}_2$，FFL 是**过度表示**的。\n\n为了计算 $z$-分数，我们再次近似方差：\n$$ P_{FFL}(\\mathcal{N}_2) = 0.75 \\cdot (0.14)^3 \\approx 0.002058 $$\n$$ \\mathrm{Var}(T_{\\mathcal{N}_2}) \\approx 70.42 \\cdot (1 - 0.002058) \\approx 70.27 $$\n$$ \\sigma_{\\mathcal{N}_2} = \\sqrt{\\mathrm{Var}(T_{\\mathcal{N}_2})} \\approx \\sqrt{70.27} \\approx 8.38 $$\n$z$-分数为：\n$$ z_2 = \\frac{T_{\\mathrm{obs}} - \\mathbb{E}[T_{\\mathcal{N}_2}]}{\\sigma_{\\mathcal{N}_2}} \\approx \\frac{300 - 70.42}{8.38} \\approx 27.39 $$\n\n**结论与选项评估**\n\n- 在 $\\mathcal{N}_1$ 下，$\\mathbb{E}[T] \\approx 1353$ 且 $z \\approx -29$，表明显著的表示不足。\n- 在 $\\mathcal{N}_2$ 下，$\\mathbb{E}[T] \\approx 70$ 且 $z \\approx 27$，表明显著的过度表示。\n- 零模型的选择反转了关于模体显著性的结论。$\\mathcal{N}_1$ 是一个不佳的零模型，因为它与观测到的二元组普查不匹配（例如，它预测的互惠性 $m=p^2=0.0625$，远低于观测到的 $m=0.18$）。$\\mathcal{N}_2$ 更为合适，因为它通过构造保留了二元组结构。\n\n现在我将评估每个选项。\n\n**A. 在 $p=0.25$ 的 $\\mathcal{N}_1$ 模型下，期望 FFL 计数为 $\\binom{60}{3}\\cdot 6p^3(1-p)^3\\approx 1353$，得出表示不足，且 $z\\approx -29$。在 $a=0.14$ 的 $\\mathcal{N}_2$ 模型下，期望 FFL 计数为 $\\binom{60}{3}\\cdot \\tfrac{3}{4}a^3\\approx 70$，得出过度表示，且 $z\\approx 27$，从而在两种零模型之间反转了符号。**\n- $\\mathbb{E}[T_{\\mathcal{N}_1}]$ 的公式是正确的。计算值 $\\approx 1353$ 是正确的。表示不足的评估和 $z \\approx -29$ 也是正确的。\n- $\\mathbb{E}[T_{\\mathcal{N}_2}]$ 的公式是正确的。计算值 $\\approx 70$ 是正确的。过度表示的评估和 $z \\approx 27$ 也是正确的。\n- 表示符号被反转的观察是正确的。\n- **结论：正确。**\n\n**B. 在 $\\mathcal{N}_1$ 模型下，期望 FFL 计数为 $\\binom{60}{3}\\cdot p^3(1-p)^3\\approx 226$，在 $\\mathcal{N}_2$ 模型下，其值为 $\\binom{60}{3}\\cdot \\tfrac{1}{2}a^3\\approx 130$；在这两种情况下，相对于期望值，FFL 都是过度表示的。**\n- $\\mathbbE}[T_{\\mathcal{N}_1}]$ 的公式不正确；它缺少了组合因子 6。\n- $\\mathbbE}[T_{\\mathcal{N}_2}]$ 的公式不正确；它使用了因子 $1/2$ 而不是正确的 $3/4$。\n- FFL 在两种情况下都是过度表示的结论是不正确的（对于 $\\mathcal{N}_1$ 是表示不足）。\n- **结论：不正确。**\n\n**C. 在 $\\mathcal{N}_1$ 模型下，期望 FFL 计数为 $\\binom{60}{3}\\cdot 2p^3(1-p)^3\\approx 451$，而在 $\\mathcal{N}_2$ 模型下，其值为 $\\binom{60}{3}\\cdot \\tfrac{3}{4}a^2\\approx 504$；在这两种情况下，FFL 都是表示不足的。**\n- $\\mathbbE}[T_{\\mathcal{N}_1}]$ 的公式不正确；它使用了因子 $2$ 而不是 $6$。\n- $\\mathbbE}[T_{\\mathcal{N}_2}]$ 的公式不正确；它使用了 $a^2$ 而不是 $a^3$。\n- FFL 在两种情况下都是表示不足的结论是不正确的（对于 $\\mathcal{N}_2$ 是过度表示）。\n- **结论：不正确。**\n\n**D. FFL 的期望概率与互惠性无关，在任何匹配 $p$ 的零模型下都等于 $6p^3(1-p)^3$；由于 $T_{\\mathrm{obs}}=300$，它在两种零模型下都是表示不足的。**\n- 概率与零模型的互惠性结构无关的说法是错误的。我们的推导明确显示了 $\\mathcal{N}_1$ 和 $\\mathcal{N}_2$ 的两种不同概率，尽管两种模型都受到相同的经验弧密度 $p$ 的约束（因为 $d=2p$ 与 $m, a, u$ 一致）。\n- 在两种零模型下都是表示不足的结论是错误的。\n- **结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "现实世界中的网络规模可能极其庞大，这使得计算效率成为首要考虑的问题。最后的这项练习将挑战你为大规模图设计一个并行的三元组普查算法。练习的重点在于如何通过巧妙的设计来避免诸如竞争条件之类的常见并行计算陷阱，同时确保结果的正确性和算法的可扩展性，从而将网络理论与高性能计算实践联系起来。",
            "id": "4312812",
            "problem": "给定一个有向简单图 $G = (V, E)$，其中 $|V| = n$，其邻接矩阵为 $A \\in \\{0, 1\\}^{n \\times n}$，且对于所有 $i \\in \\{0, 1, \\dots, n-1\\}$ 都有 $A_{ii} = 0$。一个三元组定义为三个不同顶点的无序集 $\\{i, j, k\\} \\subset V$，其二元结构由三个无序对 $(i, j)$、$(i, k)$ 和 $(j, k)$ 之间存在的有向边给出。对于每个无序对 $(p, q)$，其二元组类型分为：若 $A_{pq} = 1$ 且 $A_{qp} = 1$，则为互惠型；若 $A_{pq}$ 或 $A_{qp}$ 中恰好有一个等于 $1$，则为非对称型；否则为空型。令 $m$ 表示一个三元组中互惠二元组的数量，$a$ 表示非对称二元组的数量，$c$ 表示空二元组的数量，满足 $m + a + c = 3$。聚合三元组普查类别由元组 $(m, a, c)$ 定义，并映射到以下代码：$003$ (互惠 $0$，非对称 $0$，空 $3$)、$012$ ($0, 1, 2$)、$021$ ($0, 2, 1$)、$030$ ($0, 3, 0$)、$102$ ($1, 0, 2$)、$111$ ($1, 1, 1$)、$120$ ($1, 2, 0$)、$201$ ($2, 0, 1$)、$210$ ($2, 1, 0$) 和 $300$ ($3, 0, 0$)。\n\n从有向图、无序三元组和二元组类型的核心定义出发，设计一个计算聚合三元组普查的并行算法，该算法需满足以下属性：\n\n- 算法必须通过锚定于三元组的唯一最小索引来确保每个无序三元组 $\\{i, j, k\\}$ 被且仅被枚举一次。即，若 $i  j  k$，则该三元组被分配给锚点 $i$。这必须从第一性原理进行形式化推导，并证明其可以避免重复计数。\n- 算法必须在线程间划分计算任务，以最小化线程间竞争。你必须从共享内存并行中的写入竞争和读取共享等基本考虑因素出发，推导出一个线程分配策略，确保线程局部计数器在三元组枚举期间消除共享写入，并仅通过一个最终的归约步骤来聚合结果。该设计必须从最小化竞争的基本原则出发进行论证。\n- 该算法必须能以任何现代编程语言实现为一个完整的、可运行的程序。并行性必须以线程的形式体现。算法必须在如下指定的内部图测试套件上运行，无需外部输入。\n\n必须使用的基本原理：有向图和邻接矩阵的定义，关于无序三元组数量的组合恒等式 $\\binom{n}{3}$，以及基于 $A_{pq}$ 和 $A_{qp}$ 的二元组分类标准。你不得使用专门的三元组普查公式或直接提供三元组分类的外部库。\n\n图测试套件（顶点标记为 $0$ 到 $n-1$）：\n\n- 测试用例 1：图 $G_1$，$n = 5$，边集 $E_1 = \\{(0, 1), (1, 0), (2, 3), (3, 2), (1, 2), (1, 3), (1, 4), (4, 1), (0, 3), (3, 4), (2, 4)\\}$。\n- 测试用例 2：图 $G_2$，$n = 4$，空边集 $E_2 = \\emptyset$。\n- 测试用例 3：图 $G_3$，$n = 4$，完全双向边集 $E_3 = \\{(i, j) \\mid i \\neq j\\}$，即对于每个无序对 $\\{i, j\\}$，都有 $A_{ij} = 1$ 和 $A_{ji} = 1$。\n- 测试用例 4：图 $G_4$，$n = 3$，边集 $E_4 = \\{(0, 1), (1, 2), (2, 0)\\}$。\n\n每个测试用例的所需输出：一个整数列表，按固定顺序 $[003, 012, 102, 021, 111, 030, 201, 120, 210, 300]$ 给出聚合三元组代码的计数。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身也是一个按固定代码顺序排列的列表（例如，[[c_{003}, c_{012}, \\dots, c_{300}], [\\dots], [\\dots], [\\dots]]$）。不涉及物理单位或角度，也不需要百分比。确保所有计数均为精确整数。",
            "solution": "所述问题是有效的。它在网络科学领域有坚实的科学基础，问题阐述清晰，定义和目标明确，没有矛盾或含糊之处。它提出了图论中的一个标准计算问题——三元组普查，并要求一个从第一性原理推导出的解决方案，包括并行化策略。\n\n解决方案分三个阶段进行。首先，我们推导一种枚举所有唯一无序三元组的方法。其次，我们定义每个三元组的分类过程。第三，我们设计一个并行算法来高效地执行此计算，重点是最小化线程间竞争。\n\n**1. 无序三元组的无歧义枚举**\n\n给定一个有向图 $G = (V, E)$，其中 $V$ 是一个包含 $n = |V|$ 个顶点的集合。我们用整数 $\\{0, 1, \\dots, n-1\\}$ 标记顶点。一个三元组是三个不同顶点的无序集，记为 $\\{i, j, k\\}$。在一个有 $n$ 个顶点的图中，这种三元组的总数由二项式系数 $\\binom{n}{3}$ 给出。\n\n为了设计一个对每个三元组仅处理一次的算法，我们必须为每个无序集建立一个规范表示。一种可靠的方法是对我们考虑的任何三元组内的顶点索引强制执行严格的排序。按照惯例，我们可以用有序元组 $(i', j', k')$ 来表示三元组 $\\{i, j, k\\}$，其中 $i'  j'  k'$。对于每个由三个顶点组成的无序集，这种表示是唯一的。\n\n这导出了一个直接的枚举算法：一个三重嵌套循环结构。\n设顶点索引从 $0$到 $n-1$。\n1.  外层循环遍历第一个顶点 $i$，从 $0$到 $n-3$。\n2.  第二层循环遍历第二个顶点 $j$，从 $i+1$ 到 $n-2$。\n3.  内层循环遍历第三个顶点 $k$，从 $j+1$ 到 $n-1$。\n\n此过程生成满足 $0 \\leq i  j  k \\leq n-1$ 的有序元组 $(i, j, k)$。\n\n**正确性证明：**\n- **唯一性：** 此循环生成的每个元组 $(i, j, k)$ 对应于无序集 $\\{i, j, k\\}$。假设同一个无序集可以由两个不同的元组 $(i_1, j_1, k_1)$ 和 $(i_2, j_2, k_2)$ 生成。由于循环结构强制执行严格排序，这两个元组都必须是其顶点索引按字典序排序后的表示。因此，如果 $\\{i_1, j_1, k_1\\} = \\{i_2, j_2, k_2\\}$，那么对这两个集合的元素进行排序必须产生相同的有序元组。因此，$(i_1, j_1, k_1)$ 必须与 $(i_2, j_2, k_2)$ 相同。这与它们是不同元组的假设相矛盾。因此，每个无序三元组只被生成一次。\n- **完备性：** 考虑任意一个无序三元组 $\\{v_1, v_2, v_3\\}$。令 $i = \\min(v_1, v_2, v_3)$，$j = \\text{median}(v_1, v_2, v_3)$，以及 $k = \\max(v_1, v_2, v_3)$。根据定义，我们有 $i  j  k$。嵌套循环结构最终将达到第一个循环变量为 $i$，第二个为 $j$，第三个为 $k$ 的状态，从而生成元组 $(i, j, k)$ 并计入三元组 $\\{v_1, v_2, v_3\\}$。\n\n此枚举策略以最小索引 $i$ 为锚点，正如问题所要求的，因为对于 $i$ 的每个值，内层循环都会找到所有以 $i$ 为最小顶点索引的三元组。\n\n**2. 三元组分类**\n\n对于每个枚举出的三元组 $\\{i, j, k\\}$，我们必须确定其聚合三元组普查代码。该代码由元组 $(m, a, c)$ 定义，其中 $m$ 是互惠二元组的数量，$a$ 是非对称二元组的数量，$c$ 是空二元组的数量。该三元组由三个二元组（顶点的无序对）组成：$\\{i, j\\}$、$\\{j, k\\}$ 和 $\\{i, k\\}$。\n\n一个二元组 $\\{p, q\\}$ 的分类取决于邻接矩阵 $A$ 中的条目：\n- **互惠型 ($m$)：** 存在互惠边。$A_{pq} = 1$ 且 $A_{qp} = 1$。\n- **非对称型 ($a$)：** 边只存在于一个方向。($A_{pq} = 1$ 且 $A_{qp} = 0$) 或 ($A_{pq} = 0$ 且 $A_{qp} = 1$)。这等价于 $A_{pq} + A_{qp} = 1$。\n- **空型 ($c$)：** 两个方向都不存在边。$A_{pq} = 0$ 且 $A_{qp} = 0$。\n\n对单个三元组 $\\{i, j, k\\}$ 进行分类的算法如下：\n1. 初始化局部计数器 $m=0, a=0, c=0$。\n2. 检查二元组 $\\{i, j\\}$：\n   - 若 $A_{ij} = 1$ 且 $A_{ji} = 1$，则 $m$ 递增。\n   - 否则若 $A_{ij} + A_{ji} = 1$，则 $a$ 递增。\n   - 否则 ($A_{ij} = 0$ 且 $A_{ji} = 0$)，则 $c$ 递增。\n3. 对二元组 $\\{j, k\\}$ 使用 $A_{jk}$ 和 $A_{kj}$ 重复步骤 2。\n4. 对二元组 $\\{i, k\\}$ 使用 $A_{ik}$ 和 $A_{ki}$ 重复步骤 2。\n5. 最终得到的元组 $(m, a, c)$ 给出了该三元组的分类。然后，与此元组对应的全局计数器递增。\n\n十种可能的分类元组 $(m, a, c)$ 必须映射到它们对应的代码（$003, 012, \\dots, 300$），以更新最终的普查计数。这通过一个预定义的映射来实现。\n\n**3. 并行算法设计**\n\n一种朴素的并行化方法是让多个线程执行枚举循环，并更新一个单一的、共享的普查计数数组。这种方法会因**写入竞争**而造成性能瓶颈。多个线程试图递增同一个计数器（例如，针对一种常见的三元组类型）将需要锁等同步机制，这实际上会使它们的更新串行化，从而抵消了并行化带来的好处。\n\n一个更优的设计，正如题目所要求的，通过划分工作负载和使用线程局部存储来最小化这种竞争。\n\n- **工作划分：** 所有三元组的集合根据锚点顶点 $i$ 进行划分。最外层循环的范围 $i \\in [0, n-3]$ 在可用线程之间进行分配。对于 $T$ 个线程，线程 $t \\in \\{0, \\dots, T-1\\}$ 可以被分配一个连续的 $i$ 索引块。例如，线程 $t$ 处理所有满足 $i \\pmod T = t$ 的 $i$。此策略保证每个线程处理一组不相交的锚点顶点。由于我们的枚举方法确保任何三元组 $\\{i, j, k\\}$ 都唯一地与其最小索引 $i$ 相关联，因此按 $i$ 划分可确保任意两个线程永远不会处理同一个三元组。这是对问题空间的无竞争划分。\n\n- **使用线程局部存储的无竞争计算：** 为了消除写入竞争，每个线程维护自己的私有三元组计数器数组 `local_counts_t`。该数组的结构与最终的全局普查数组相同。在执行过程中，每个线程只从共享的、只读的邻接矩阵 $A$ 中读取数据，并且只写入其自己的 `local_counts_t` 数组。由于没有共享写入，因此在计算密集的枚举阶段不需要锁或其他昂贵的同步原语。对矩阵 $A$ 的并发读取是安全的，并且在现代共享内存架构上通常不会导致显著的性能下降。\n\n- **最终归约步骤：** 在所有线程完成其分配的三元组处理后，必须将其局部结果进行聚合。执行一个最终的归约步骤，将所有线程的 `local_counts_t` 数组求和到一个单一的全局结果数组中。\n$$ \\text{global\\_counts}[k] = \\sum_{t=0}^{T-1} \\text{local\\_counts}_t[k] \\quad \\forall k \\in \\{\\text{census codes}\\} $$\n与主枚举任务相比，此步骤的计算成本非常低。它可以由一个主线程在一个简单的循环中执行。对于任何非平凡的图大小，这个最终串行步骤的开销都可以忽略不计。\n\n这种设计——按锚点索引划分、使用线程局部计数器和最终归约——是并行计数算法的一种标准且有效的模式。它通过确保主要计算工作没有线程间的写依赖，从而最大化了并行执行效率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a serial algorithm to compute the aggregated triad census for a set of test graphs.\n    The logic follows the derived enumeration and classification principles.\n    The algorithm is structured to be directly adaptable to a parallel implementation as described in the solution.\n    \"\"\"\n\n    # Define the mapping from (m, a, c) tuple to the index in the result list.\n    # The order of codes in the output list is fixed:\n    # [003, 012, 102, 021, 111, 030, 201, 120, 210, 300]\n    code_map = {\n        (0, 0, 3): 0,  # 003\n        (0, 1, 2): 1,  # 012\n        (1, 0, 2): 2,  # 102\n        (0, 2, 1): 3,  # 021\n        (1, 1, 1): 4,  # 111\n        (0, 3, 0): 5,  # 030\n        (2, 0, 1): 6,  # 201\n        (1, 2, 0): 7,  # 120\n        (2, 1, 0): 8,  # 210\n        (3, 0, 0): 9   # 300\n    }\n    \n    num_codes = len(code_map)\n\n    def compute_triad_census(A):\n        \"\"\"\n        Computes the triad census for a given adjacency matrix A.\n        This function represents the work that would be partitioned in a parallel implementation.\n        \"\"\"\n        n = A.shape[0]\n        # In a parallel design, this would be a thread-local counter array.\n        counts = np.zeros(num_codes, dtype=int)\n\n        if n  3:\n            return counts.tolist()\n\n        # Enumerate each unique unordered triad {i, j, k} by ensuring i  j  k.\n        # This loop structure is the core of the enumeration.\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    # For each triad, classify its three dyads.\n                    m, a, c = 0, 0, 0\n\n                    # Dyad {i, j}\n                    ij_sum = A[i, j] + A[j, i]\n                    if ij_sum == 2:\n                        m += 1\n                    elif ij_sum == 1:\n                        a += 1\n                    else:\n                        c += 1\n\n                    # Dyad {j, k}\n                    jk_sum = A[j, k] + A[k, j]\n                    if jk_sum == 2:\n                        m += 1\n                    elif jk_sum == 1:\n                        a += 1\n                    else:\n                        c += 1\n                    \n                    # Dyad {i, k}\n                    ik_sum = A[i, k] + A[k, i]\n                    if ik_sum == 2:\n                        m += 1\n                    elif ik_sum == 1:\n                        a += 1\n                    else:\n                        c += 1\n                    \n                    # Get the code index from the (m, a, c) tuple and increment the counter.\n                    triad_tuple = (m, a, c)\n                    if triad_tuple in code_map:\n                        code_index = code_map[triad_tuple]\n                        counts[code_index] += 1\n        \n        return counts.tolist()\n\n    # --- Test Case Definitions ---\n\n    # Test Case 1: n=5\n    n1 = 5\n    E1 = [(0, 1), (1, 0), (2, 3), (3, 2), (1, 2), (1, 3), (1, 4), (4, 1), (0, 3), (3, 4), (2, 4)]\n    A1 = np.zeros((n1, n1), dtype=int)\n    for u, v in E1:\n        A1[u, v] = 1\n\n    # Test Case 2: n=4, empty graph\n    n2 = 4\n    A2 = np.zeros((n2, n2), dtype=int)\n\n    # Test Case 3: n=4, complete bidirected graph\n    n3 = 4\n    A3 = np.ones((n3, n3), dtype=int) - np.eye(n3, dtype=int)\n\n    # Test Case 4: n=3, directed 3-cycle\n    n4 = 3\n    E4 = [(0, 1), (1, 2), (2, 0)]\n    A4 = np.zeros((n4, n4), dtype=int)\n    for u, v in E4:\n        A4[u, v] = 1\n\n    test_cases = [A1, A2, A3, A4]\n    \n    # --- Execution ---\n    \n    results = []\n    for A in test_cases:\n        result = compute_triad_census(A)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [[0,1,0,1,2,0,1,5,0,0],[4,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,4],[0,0,0,0,0,1,0,0,0,0]]\n    list_of_lists_str = ','.join(map(str, results))\n    print(f\"[{list_of_lists_str}]\")\n\nsolve()\n```"
        }
    ]
}