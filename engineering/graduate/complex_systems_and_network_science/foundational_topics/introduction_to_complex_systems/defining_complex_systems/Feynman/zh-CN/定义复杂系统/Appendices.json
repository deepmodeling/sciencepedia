{
    "hands_on_practices": [
        {
            "introduction": "非线性是复杂系统的核心特征之一，它能导致简单系统中无法出现的丰富行为。其中最基本也最重要的现象之一是双稳态（bistability），即系统存在两个稳定的平衡状态。这个练习  将通过一个经典的一维动力学模型$\\dot{x} = ax - bx^3$来分析这一现象。通过求解这个系统的稳态解并分析其稳定性，你将亲手揭示系统如何根据参数和初始条件在两个稳定点之间做出选择，并借助势函数$U(x)$的概念来直观理解其动态行为。",
            "id": "4271109",
            "problem": "考虑一维常微分方程 (ODE) $\\frac{dx}{dt} = a x - b x^{3}$，其中$a>0$且$b>0$。使用动力系统的基本定义，通过条件$f(x^{\\ast})=0$来定义不动点$x^{\\ast}$，其中$f(x)=a x - b x^{3}$，并通过一维情况下导数$f'(x^{\\ast})$的符号来定义不动点的线性稳定性。在复杂系统中，双稳态指的是两个具有不同吸引盆的渐近稳定不动点与一个不稳定不动点共存的现象。从这些定义出发，并且不使用任何预先推导的快捷公式，执行以下操作：\n- 确定系统的所有不动点，用$a$和$b$表示。\n- 在每个不动点附近将系统线性化，以确定其稳定性，从而证明对于合适的正参数$a$和$b$，系统存在双稳态。\n- 通过识别一个标量势$U(x)$使得$\\frac{dx}{dt} = -\\frac{dU}{dx}$，将该系统解释为梯度流，并通过要求$U(0)=0$来固定$U(x)$的加性常数。\n- 将双稳态势垒高度定义为分隔吸引盆的不稳定不动点与任一稳定不动点之间的势能差。精确计算此势垒高度，用$a$和$b$表示。\n\n以单一闭式解析表达式的形式提供您的最终答案。无需四舍五入。最终表达式中不包含任何单位。",
            "solution": "该问题陈述经评估具有科学依据、提法恰当、客观且自洽。它提出了动力系统理论中的一个标准问题，没有任何明显的缺陷、矛盾或含糊之处。因此，我们可以着手求解。\n\n给定的一维常微分方程 (ODE) 为 $\\frac{dx}{dt} = f(x)$，其中 $f(x) = a x - b x^{3}$，参数$a$和$b$为正实数，即$a>0$且$b>0$。\n\n首先，我们通过求解方程$f(x^{\\ast})=0$来确定不动点，记为$x^{\\ast}$。\n$$a x^{\\ast} - b (x^{\\ast})^{3} = 0$$\n提出公因子$x^{\\ast}$，我们得到：\n$$x^{\\ast} (a - b (x^{\\ast})^{2}) = 0$$\n由于$a>0$且$b>0$，该方程有三个不同的实数解：\n1. $x^{\\ast}_{1} = 0$\n2. $a - b (x^{\\ast})^{2} = 0 \\implies (x^{\\ast})^{2} = \\frac{a}{b} \\implies x^{\\ast} = \\pm\\sqrt{\\frac{a}{b}}$\n\n因此，系统的三个不动点是 $x^{\\ast}_{1} = 0$，$x^{\\ast}_{2} = \\sqrt{\\frac{a}{b}}$ 和 $x^{\\ast}_{3} = -\\sqrt{\\frac{a}{b}}$。\n\n接下来，我们分析每个不动点的线性稳定性。稳定性由导数$f'(x) = \\frac{df}{dx}$在不动点$x^{\\ast}$处的值的符号决定。\n首先，我们计算$f(x)$的导数：\n$$f'(x) = \\frac{d}{dx}(a x - b x^{3}) = a - 3 b x^{2}$$\n现在，我们在三个不动点处分别计算该导数的值：\n- 对于 $x^{\\ast}_{1} = 0$：\n  $$f'(0) = a - 3 b (0)^{2} = a$$\n  因为给定$a>0$，所以$f'(0)>0$。导数为正表示该不动点是不稳定的。\n- 对于 $x^{\\ast}_{2} = \\sqrt{\\frac{a}{b}}$：\n  $$f'\\left(\\sqrt{\\frac{a}{b}}\\right) = a - 3 b \\left(\\sqrt{\\frac{a}{b}}\\right)^{2} = a - 3 b \\left(\\frac{a}{b}\\right) = a - 3a = -2a$$\n  因为给定$a>0$，所以$f'(\\sqrt{\\frac{a}{b}}) = -2a  0$。导数为负表示该不动点是渐近稳定的。\n- 对于 $x^{\\ast}_{3} = -\\sqrt{\\frac{a}{b}}$：\n  $$f'\\left(-\\sqrt{\\frac{a}{b}}\\right) = a - 3 b \\left(-\\sqrt{\\frac{a}{b}}\\right)^{2} = a - 3 b \\left(\\frac{a}{b}\\right) = a - 3a = -2a$$\n  同样地，因为$a>0$，所以$f'(-\\sqrt{\\frac{a}{b}}) = -2a  0$。这个不动点也是渐近稳定的。\n\n该系统拥有两个稳定不动点$x^{\\ast}_{2} = \\sqrt{\\frac{a}{b}}$和$x^{\\ast}_{3} = -\\sqrt{\\frac{a}{b}}$，它们被一个不稳定不动点$x^{\\ast}_{1} = 0$分隔。这证实了问题陈述中定义的双稳态的存在。\n\n现在，我们通过寻找一个势函数$U(x)$使得$\\frac{dx}{dt} = -\\frac{dU}{dx}$，将该系统解释为梯度流。\n我们将给定的动力学方程与此条件等同：\n$$a x - b x^{3} = -\\frac{dU}{dx}$$\n这意味着：\n$$\\frac{dU}{dx} = -a x + b x^{3}$$\n为了求得$U(x)$，我们将$\\frac{dU}{dx}$的表达式对$x$进行积分：\n$$U(x) = \\int (-a x + b x^{3}) \\, dx = -a \\frac{x^{2}}{2} + b \\frac{x^{4}}{4} + C$$\n其中$C$是积分常数。我们利用给定的条件$U(0)=0$来确定这个常数。\n$$U(0) = -a \\frac{0^{2}}{2} + b \\frac{0^{4}}{4} + C = 0 \\implies C = 0$$\n因此，势函数为：\n$$U(x) = -\\frac{a x^{2}}{2} + \\frac{b x^{4}}{4}$$\n稳定不动点对应于势$U(x)$的局部极小值，而不稳定不动点对应于局部极大值。\n\n最后，我们计算双稳态势垒高度，它被定义为不稳定不动点与任一稳定不动点之间的势能差。令$\\Delta U$表示此势垒高度。\n不稳定不动点是$x^{\\ast}_{\\text{unstable}} = 0$。此点的势为：\n$$U(x^{\\ast}_{\\text{unstable}}) = U(0) = 0$$\n稳定不动点是$x^{\\ast}_{\\text{stable}} = \\pm\\sqrt{\\frac{a}{b}}$。由于势函数具有偶对称性($U(x) = U(-x)$)，两个稳定不动点处的势值相同。我们计算$x = \\sqrt{\\frac{a}{b}}$处的势值：\n$$U\\left(\\sqrt{\\frac{a}{b}}\\right) = -\\frac{a}{2}\\left(\\sqrt{\\frac{a}{b}}\\right)^{2} + \\frac{b}{4}\\left(\\sqrt{\\frac{a}{b}}\\right)^{4}$$\n$$U\\left(\\sqrt{\\frac{a}{b}}\\right) = -\\frac{a}{2}\\left(\\frac{a}{b}\\right) + \\frac{b}{4}\\left(\\frac{a^{2}}{b^{2}}\\right)$$\n$$U\\left(\\sqrt{\\frac{a}{b}}\\right) = -\\frac{a^{2}}{2b} + \\frac{a^{2}}{4b} = -\\frac{2a^{2}}{4b} + \\frac{a^{2}}{4b} = -\\frac{a^{2}}{4b}$$\n势垒高度$\\Delta U$是不稳定鞍点处的势与稳定极小值点处的势之差：\n$$\\Delta U = U(x^{\\ast}_{\\text{unstable}}) - U(x^{\\ast}_{\\text{stable}})$$\n$$\\Delta U = U(0) - U\\left(\\sqrt{\\frac{a}{b}}\\right) = 0 - \\left(-\\frac{a^{2}}{4b}\\right) = \\frac{a^{2}}{4b}$$\n这就是所求的双稳态势垒高度。",
            "answer": "$$\n\\boxed{\\frac{a^{2}}{4b}}\n$$"
        },
        {
            "introduction": "复杂行为可以从极其简单的确定性规则中涌现，混沌理论（chaos theory）深刻地揭示了这一点。混沌系统对初始条件具有敏感依赖性，即所谓的“蝴蝶效应”，这是许多复杂系统的一个标志性特征。这个练习  将带你探索混沌动力学的经典范例——逻辑斯谛映射（logistic map）。你将通过编写程序来计算李雅普诺夫指数$\\lambda$，这是一个量化混沌的关键指标，并理解正的李雅普诺夫指数如何成为系统存在敏感依赖性的明确证据。",
            "id": "4271118",
            "problem": "你需要编写一个完整的程序，来估计一维逻辑斯谛映射的最大李雅普诺夫指数，并用它来解释混沌作为复杂系统的一个定义性特征的存在。逻辑斯谛映射是一个离散时间动力系统，由递推关系$x_{t+1} = f_r(x_t)$给出，其中$f_r(x) = r x (1 - x)$，$r \\in [0,4]$是一个实数参数，$x_t \\in [0,1]$是在离散时间$t \\in \\{0,1,2,\\dots\\}$的状态。对于一维映射，最大李雅普诺夫指数$\\lambda$的基本定义是，在一个典型轨道上，对映射进行线性化后，一个无穷小扰动的长期增长率，即：\n$$\n\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{t=0}^{n-1} \\ln \\left| f_r'(x_t) \\right|,\n$$\n其中$f_r'(x) = \\frac{d}{dx} f_r(x)$是导数。对于逻辑斯谛映射，$f_r'(x) = r(1-2x)$。$\\lambda$的符号决定了邻近轨道的指数发散或收敛：如果$\\lambda > 0$，则典型的邻近轨道会以指数速度发散，表明对初始条件具有敏感依赖性（混沌）；如果$\\lambda  0$，轨道会收敛到一个稳定的周期轨道或不动点；如果$\\lambda = 0$，系统处于一个分岔阈值。\n\n你的程序必须严格根据上述基本定义和逻辑斯谛映射的导数来实现以下任务：\n- 对于给定的参数$r$、初始条件$x_0 \\in (0,1)$、用于舍弃初始步骤的暂态长度$n_{\\mathrm{trans}} \\in \\mathbb{N}$和测量长度$n \\in \\mathbb{N}$，计算一个估计量\n$$\n\\hat{\\lambda}(r; x_0, n_{\\mathrm{trans}}, n) = \\frac{1}{n} \\sum_{t=n_{\\mathrm{trans}}}^{n_{\\mathrm{trans}} + n - 1} \\ln \\left( \\left| r \\left( 1 - 2 x_t \\right) \\right| + \\varepsilon \\right),\n$$\n其中$\\varepsilon = 10^{-12}$是一个固定的数值保护，以避免对零取对数。状态序列$\\{x_t\\}$是从$x_0$开始，通过迭代$x_{t+1} = r x_t (1 - x_t)$生成的。\n- 通过一个带有容差$\\tau = 10^{-4}$的决策规则返回一个布尔值$c$来解释混沌的存在：如果$\\hat{\\lambda} > \\tau$则设置$c = \\mathrm{True}$，否则设置$c = \\mathrm{False}$。该规则体现的解释是，一个严格为正的李雅普诺夫指数表示持续的敏感依赖性，其中包含一个用于处理有限时间估计误差的小容差。\n\n使用以下参数值$(r, x_0, n_{\\mathrm{trans}}, n)$的测试套件：\n- 情况 1：$r = 0.5$, $x_0 = 0.123456789$, $n_{\\mathrm{trans}} = 10000$, $n = 200000$。\n- 情况 2：$r = 2.5$, $x_0 = 0.123456789$, $n_{\\mathrm{trans}} = 10000$, $n = 200000$。\n- 情况 3：$r = 3.2$, $x_0 = 0.123456789$, $n_{\\mathrm{trans}} = 10000$, $n = 200000$。\n- 情况 4：$r = 3.5$, $x_0 = 0.123456789$, $n_{\\mathrm{trans}} = 10000$, $n = 200000$。\n- 情况 5：$r = 3.56995$, $x_0 = 0.123456789$, $n_{\\mathrm{trans}} = 10000$, $n = 200000$。\n- 情况 6：$r = 3.7$, $x_0 = 0.123456789$, $n_{\\mathrm{trans}} = 10000$, $n = 200000$。\n- 情况 7：$r = 3.83$, $x_0 = 0.123456789$, $n_{\\mathrm{trans}} = 10000$, $n = 200000$。\n- 情况 8：$r = 4.0$, $x_0 = 0.123456789$, $n_{\\mathrm{trans}} = 10000$, $n = 200000$。\n\n对于每种情况，计算由四舍五入后的李雅普诺夫估计值和混沌标志组成的数对。使用标准四舍五入规则将每个$\\hat{\\lambda}$四舍五入到 6 位小数。\n\n最终输出格式要求：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身都是一个形如$[\\hat{\\lambda}, c]$的双元素列表。例如，三个情况的输出将类似于`[[0.123456,True],[-0.000789,False],[0.693147,True]]`。\n- 除了所需的单行输出外，不允许有任何额外的文本或空白字符。\n- 此问题不涉及任何物理单位。",
            "solution": "问题陈述经评估有效。它在科学上基于成熟的动力系统和混沌理论，特别是关于逻辑斯谛映射，这是该领域的经典模型。该问题是适定的，为获得唯一的数值解提供了完整且无歧义的定义、方程和参数集。语言客观且数学上精确。所提供的估计李雅普诺夫指数的方法是一种标准的数值技术。\n\n解决方案将首先通过实现一个函数来模拟逻辑斯谛映射并按定义计算最大李雅普诺夫指数估计量$\\hat{\\lambda}$来开发。随后，将应用指定的决策规则将动力学行为分类为混沌或非混沌。\n\n逻辑斯谛映射是一个离散时间动力系统，由递推关系描述：\n$$\nx_{t+1} = f_r(x_t) = r x_t (1 - x_t)\n$$\n其中$x_t \\in [0,1]$是系统在时间步$t$的状态，$r \\in [0,4]$是一个控制参数。\n\n最大李雅普诺夫指数$\\lambda$量化了邻近轨道发散或收敛的平均指数率。正指数$\\lambda > 0$是混沌的一个定义性特征，表示对初始条件的敏感依赖性。其形式化定义为：\n$$\n\\lambda = \\lim_{n \\to \\infty} \\frac{1}{n} \\sum_{t=0}^{n-1} \\ln \\left| f_r'(x_t) \\right|\n$$\n其中$f_r'(x)$是映射函数的导数。对于逻辑斯谛映射，该导数为$f_r'(x) = r(1-2x)$。项$\\ln |f_r'(x_t)|$表示在状态$x_t$时，一个无穷小扰动的局部（或瞬时）对数扩张或收缩率。李雅普诺夫指数是这些局部速率在一个典型轨道上的长期平均值。\n\n为一组给定参数$(r, x_0, n_{\\mathrm{trans}}, n)$估计$\\lambda$的算法步骤如下：\n\n1.  **初始化**：从初始条件$x_0$开始。\n\n2.  **暂态舍弃**：将映射迭代$n_{\\mathrm{trans}}$步。状态$x_t$根据$x_{t+1} = r x_t (1 - x_t)$更新，其中$t = 0, 1, \\dots, n_{\\mathrm{trans}}-1$。这个初始阶段让系统的轨道稳定到其吸引子上（例如，一个不动点、一个周期轨道或一个奇异吸引子）。通过舍弃这些暂态，后续对$\\lambda$的计算反映了吸引子的内禀动力学，而与$x_0$的具体选择无关（排除一组测度为零的初始条件）。\n\n3.  **李雅普诺夫求和**：暂态阶段之后，再执行$n$次迭代。在此测量阶段，对于从$n_{\\mathrm{trans}}$到$n_{\\mathrm{trans}} + n - 1$的每一步$t$，计算导数项$f_r'(x_t) = r(1-2x_t)$并累加其对数量值的和。问题指定使用一个求和来计算估计量$\\hat{\\lambda}$：\n    $$\n    S = \\sum_{t=n_{\\mathrm{trans}}}^{n_{\\mathrm{trans}} + n - 1} \\ln \\left( \\left| r \\left( 1 - 2 x_t \\right) \\right| + \\varepsilon \\right)\n    $$\n    小常数$\\varepsilon = 10^{-12}$是一个数值保护措施，用以防止因`log(0)`而出错，当轨道上的点$x_t$到达临界点$x_c = 0.5$（此时$f_r'(0.5) = 0$）时，就会发生这种情况。在计算局部项之后，将状态更新为$x_{t+1}$以进行下一次迭代。\n\n4.  **求平均**：估计量$\\hat{\\lambda}$是累加和在$n$个测量步骤上的平均值：\n    $$\n    \\hat{\\lambda} = \\frac{S}{n}\n    $$\n    该值是真实李雅普诺夫指数$\\lambda$的一个近似。当$n \\to \\infty$时，近似的质量会提高。\n\n5.  **混沌分类**：李雅普诺夫指数的符号决定了系统的稳定性。问题定义了一个决策规则来对动力学进行分类，使用容差$\\tau = 10^{-4}$来考虑有限时间数值估计的误差，尤其是在$\\lambda$可能接近于零的分岔点附近。用于表示混沌的布尔标志$c$的确定方式如下：\n    $$\n    c = \\begin{cases} \\mathrm{True}  \\text{if } \\hat{\\lambda} > \\tau \\\\ \\mathrm{False}  \\text{if } \\hat{\\lambda} \\le \\tau \\end{cases}\n    $$\n    $c = \\mathrm{True}$的值表示系统表现出对初始条件的敏感依赖性（混沌），而$c = \\mathrm{False}$则表示非混沌行为（收敛到稳定的不动点或周期轨道）。\n\n最后，为了报告目的，计算出的估计量$\\hat{\\lambda}$被四舍五入到 6 位小数。程序将对每个指定的测试用例执行此过程，并将结果格式化为$[\\hat{\\lambda}_{\\text{rounded}}, c]$形式的数对列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the largest Lyapunov exponent for the logistic map for a suite of\n    test cases and classifies the dynamics as chaotic or not.\n    \"\"\"\n\n    test_cases = [\n        # (r, x0, n_trans, n)\n        (0.5, 0.123456789, 10000, 200000),\n        (2.5, 0.123456789, 10000, 200000),\n        (3.2, 0.123456789, 10000, 200000),\n        (3.5, 0.123456789, 10000, 200000),\n        (3.56995, 0.123456789, 10000, 200000),\n        (3.7, 0.123456789, 10000, 200000),\n        (3.83, 0.123456789, 10000, 200000),\n        (4.0, 0.123456789, 10000, 200000),\n    ]\n\n    # Constants defined in the problem\n    epsilon = 1e-12\n    tau = 1e-4\n\n    results = []\n    \n    for r, x0, n_trans, n in test_cases:\n        # Initial state\n        x = x0\n\n        # Discard transient iterations to let the trajectory settle on the attractor\n        for _ in range(n_trans):\n            x = r * x * (1.0 - x)\n\n        # Measurement phase: compute the sum for the Lyapunov exponent\n        lyapunov_sum = 0.0\n        for _ in range(n):\n            # The derivative of the logistic map is f'(x) = r*(1-2x)\n            derivative = r * (1.0 - 2.0 * x)\n            # Add the local contribution to the sum, with a numerical safeguard\n            lyapunov_sum += np.log(np.abs(derivative) + epsilon)\n            # Iterate the map to the next state\n            x = r * x * (1.0 - x)\n\n        # Compute the estimator for the Lyapunov exponent\n        lambda_hat = lyapunov_sum / n\n\n        # Round the result to 6 decimal places for output\n        rounded_lambda = round(lambda_hat, 6)\n\n        # Apply the decision rule to classify chaos\n        is_chaotic = lambda_hat > tau\n        \n        results.append([rounded_lambda, is_chaotic])\n\n    # Format the final output according to the specified format\n    # The str() representation of a Python list and boolean matches the required format.\n    output_string = str(results).replace(\" \", \"\")\n    \n    print(output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "许多复杂系统由大量相互作用的智能体（agent）组成，它们各自的决策共同塑造了宏观层面的整体模式。本练习  旨在探索微观层面的智能体行为（如强化学习）与整个系统涌现出的集体统计均衡之间的深刻联系。你将分析一个网络上的多智能体博弈模型，其中智能体使用学习规则来更新其策略。通过计算系统的吉布斯分布（Gibbs distribution），你将能够预测系统的长期行为，并理解集体秩序是如何从简单的适应性规则、交互结构和随机性（由温度参数$\\tau$控制）中涌现的。",
            "id": "4271082",
            "problem": "考虑一个由$N$个相互作用的智能体组成的系统，该系统位于一个无向加权网络上，由对称权重矩阵$W \\in \\mathbb{R}^{N \\times N}$（其中$W_{ij} = W_{ji}$且$W_{ii} = 0$）和特定于智能体的偏置$H \\in \\mathbb{R}^{N}$表示。每个智能体$i \\in \\{1,\\dots,N\\}$选择一个二元行动$a_i \\in \\{0,1\\}$，联合行動配置为$a = (a_1,\\dots,a_N) \\in \\{0,1\\}^N$。在配置$a$下，智能体$i$的效用定义为\n$$\nu_i(a) = \\sum_{j \\neq i} W_{ij} \\cdot \\mathbf{1}\\{a_i = a_j\\} + H_i \\cdot \\mathbf{1}\\{a_i = 1\\},\n$$\n其中$\\mathbf{1}\\{\\cdot\\}$表示指示函数。定义势函数\n$$\n\\Phi(a) = \\sum_{1 \\leq i  j \\leq N} W_{ij} \\cdot \\mathbf{1}\\{a_i = a_j\\} + \\sum_{i=1}^{N} H_i \\cdot \\mathbf{1}\\{a_i = 1\\}.\n$$\n这个设定产生了一个势博弈，即任何智能体$i$的单方面偏离所产生的$u_i$变化量等于$\\Phi$的变化量。\n\n智能体使用多智能体强化学习（MARL）中典型的 softmax 规则（也称为 logit 选择）异步更新其行动。在给定的温度参数$\\tau > 0$下，当智能体$i$在$a_{-i}$固定的情况下进行更新时，其选择行动$x \\in \\{0,1\\}$的概率为\n$$\n\\mathbb{P}\\big(a_i = x \\mid a_{-i}\\big) = \\frac{\\exp\\big(u_i(x,a_{-i})/\\tau\\big)}{\\exp\\big(u_i(0,a_{-i})/\\tau\\big) + \\exp\\big(u_i(1,a_{-i})/\\tau\\big)}.\n$$\n在这种异步对数线性学习动态下，在$\\{0,1\\}^N$上诱导的马尔可夫链具有唯一的平稳分布，该分布由吉布斯测度给出\n$$\n\\pi(a) = \\frac{\\exp\\left(\\Phi(a)/\\tau\\right)}{Z(\\tau)}, \\quad \\text{其中} \\quad Z(\\tau) = \\sum_{s \\in \\{0,1\\}^N} \\exp\\left(\\Phi(s)/\\tau\\right).\n$$\n\n一个纯策略纳什均衡 (NE) 是一个配置$a^\\star$，使得对于每个智能体$i$，\n$$\nu_i(a^\\star_i, a^\\star_{-i}) \\geq u_i(1 - a^\\star_i, a^\\star_{-i}).\n$$\n允许相等情况；也就是说，相等关系满足 NE 条件。\n\n您的任务是编写一个完整的、可运行的程序，针对下面指定的每个测试用例，计算所有$2^N$个配置上的平稳分布$\\pi(a)$，并为该测试用例返回所有纯策略纳什均衡的总概率质量，定义为\n$$\nP_{\\mathrm{NE}}(\\tau) = \\sum_{a \\in \\mathcal{E}} \\pi(a),\n$$\n其中$\\mathcal{E}$是所有纯策略纳什均衡的集合。\n\n程序必须：\n- 枚举所有$2^N$个配置$a \\in \\{0,1\\}^N$。\n- 使用提供的$W$和$H$为每个配置计算$\\Phi(a)$。\n- 通过对所有配置上的$\\exp(\\Phi(a)/\\tau)$进行归一化来计算$\\pi(a)$。为了数值稳定性，请使用任何能保持最终归一化概率精确性的标准技术。\n- 根据提供的$u_i$识别纯策略纳什均衡集合$\\mathcal{E}$。\n- 将$P_{\\mathrm{NE}}(\\tau)$计算为浮点数。\n\n测试套件：\n对于每个测试用例，使用给定的参数$(N, W, H, \\tau)$。\n\n1. 案例1（协调，低温）：\n   - $N = 4$\n   - $W = \\begin{bmatrix}\n   0  1.0  1.0  1.0 \\\\\n   1.0  0  1.0  1.0 \\\\\n   1.0  1.0  0  1.0 \\\\\n   1.0  1.0  1.0  0\n   \\end{bmatrix}$\n   - $H = \\begin{bmatrix}0.2,\\,0.2,\\,0.2,\\,0.2\\end{bmatrix}$\n   - $\\tau = 0.1$\n\n2. 案例2（协调，中等温度）：\n   - $N = 4$\n   - $W$和$H$如案例1所示\n   - $\\tau = 1.0$\n\n3. 案例3（协调，高温）：\n   - $N = 4$\n   - $W$和$H$如案例1所示\n   - $\\tau = 10.0$\n\n4. 案例4（链上的混合耦合，低温）：\n   - $N = 5$\n   - $W = \\begin{bmatrix}\n   0  1.0  0  0  0 \\\\\n   1.0  0  -1.5  0  0 \\\\\n   0  -1.5  0  1.0  0 \\\\\n   0  0  1.0  0  -1.5 \\\\\n   0  0  0  -1.5  0\n   \\end{bmatrix}$\n   - $H = \\begin{bmatrix}0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1\\end{bmatrix}$\n   - $\\tau = 0.2$\n\n5. 案例5（无相互作用，高温）：\n   - $N = 5$\n   - $W = \\mathbf{0}_{5 \\times 5}$ (所有条目为零)\n   - $H = \\begin{bmatrix}0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1\\end{bmatrix}$\n   - $\\tau = 10.0$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个测试用例的结果，结果为逗号分隔的列表，并用方括号括起来。每个浮点数结果需四舍五入到六位小数，并按上述案例的顺序列出。例如，形式为\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]\n$$\n的输出必须精确地打印为单行文本，其中每个$\\text{result}_k$是一个格式化为六位小数的十进制数。",
            "solution": "该问题要求计算一个由$N$个相互作用的智能体组成的系统中所有纯策略纳什均衡（NE）的总概率质量。该系统被定义为一个势博弈，智能体的异步更新遵循 logit 选择模型，从而在所有可能的联合行动配置空间上形成一个吉布斯-玻尔兹曼平稳分布。\n\n解决方案对每个提供的测试用例采用严谨、分步的计算方法。由于智能体数量较少（$N=4$和$N=5$），枚举整个由$2^N$种可能性组成的联合配置状态空间在计算上是可行的。\n\n过程步骤如下：\n\n1.  **状态空间枚举**：所有可能的联合行动配置的集合是$\\{0,1\\}^N$。我们通过遍历从$0$到$2^N - 1$的所有整数，并使用它们的 N 位二进制表示来生成每个配置$a = (a_1, \\dots, a_N)$。每个比特位对应一个智能体的行动。\n\n2.  **势函数计算**：对于每个配置$a \\in \\{0,1\\}^N$，我们根据给定的公式计算其势$\\Phi(a)$：\n    $$\n    \\Phi(a) = \\sum_{1 \\leq i  j \\leq N} W_{ij} \\cdot \\mathbf{1}\\{a_i = a_j\\} + \\sum_{i=1}^{N} H_i \\cdot a_i\n    $$\n    此处，$\\mathbf{1}\\{\\cdot\\}$是指示函数，当其参数为真时等于$1$，否则为$0$。由于$a_i \\in \\{0,1\\}$，项$H_i \\cdot \\mathbf{1}\\{a_i=1\\}$等价于$H_i \\cdot a_i$。此计算对所有$2^N$个配置执行，并将得到的势值存储起来。\n\n3.  **识别纯策略纳什均衡**：如果没有任何智能体有单方面改变其行动的动机，则配置$a^\\star$是一个纯策略纳什均衡。这可以正式表述为：\n    $$\n    u_i(a^\\star_i, a^\\star_{-i}) \\geq u_i(1 - a^\\star_i, a^\\star_{-i}) \\quad \\forall i \\in \\{1, \\dots, N\\}\n    $$\n    效用函数$u_i(a)$由下式给出：\n    $$\n    u_i(a) = \\sum_{j \\neq i} W_{ij} \\cdot \\mathbf{1}\\{a_i = a_j\\} + H_i \\cdot a_i\n    $$\n    对于$2^N$个配置中的每一个，我们遍历所有$N$个智能体。对于每个智能体$i$，我们计算其当前行动$a_i$下的效用$u_i(a)$，以及切换到行动$1-a_i$时将获得的假设效用$u_i(1-a_i, a_{-i})$。如果对任何智能体来说，这种切换是严格有利的（即不等式被违反），则该配置不是 NE。如果该条件对所有$N$个智能体都成立，则该配置被归类为纯策略 NE。我们维护一个布尔列表来标记哪些配置是 NE。\n\n4.  **平稳分布计算**：观察到配置$a$的平稳概率由吉布斯测度给出：\n    $$\n    \\pi(a) = \\frac{\\exp\\left(\\Phi(a)/\\tau\\right)}{Z(\\tau)}, \\quad \\text{其中} \\quad Z(\\tau) = \\sum_{s \\in \\{0,1\\}^N} \\exp\\left(\\Phi(s)/\\tau\\right)\n    $$\n    如果参数$\\Phi(a)/\\tau$很大，直接计算$\\exp(\\Phi(a)/\\tau)$可能会导致数值溢出。为确保数值稳定性，我们使用 log-sum-exp 技巧。令$\\phi_a = \\Phi(a)/\\tau$。我们找到最大值$\\phi_{\\max} = \\max_{s \\in \\{0,1\\}^N} \\phi_s$。概率$\\pi(a)$可以重写为：\n    $$\n    \\pi(a) = \\frac{\\exp(\\phi_a - \\phi_{\\max})}{\\sum_{s \\in \\{0,1\\}^N} \\exp(\\phi_s - \\phi_{\\max})}\n    $$\n    这种变换确保指数函数的参数都是非正数，从而防止溢出，同时保持最终归一化概率的精确性。我们为所有$2^N$个配置计算$\\pi(a)$。\n\n5.  **NE 概率聚合**：最终要计算的量是所有纯策略纳什均衡集合$\\mathcal{E}$的总概率质量。这由下式给出：\n    $$\n    P_{\\mathrm{NE}}(\\tau) = \\sum_{a \\in \\mathcal{E}} \\pi(a)\n    $$\n    我们将步骤 3 中识别为 NE 的所有配置$a$的概率$\\pi(a)$相加。这个总和给出了一个测试用例的最终结果。\n\n整个过程被封装起来，并针对问题陈述中指定的五个测试用例中的每一个，使用相应的参数$N$、$W$、$H$和$\\tau$来执行。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all specified test cases.\n    It sets up each test case's parameters and calls the core solver function,\n    then formats and prints the results as required.\n    \"\"\"\n\n    def solve_case(N, W, H, tau):\n        \"\"\"\n        Computes the total probability mass of pure-strategy Nash equilibria for a single test case.\n\n        Args:\n            N (int): The number of agents.\n            W (np.ndarray): The symmetric weight matrix (N x N).\n            H (np.ndarray): The agent-specific bias vector (N).\n            tau (float): The temperature parameter.\n\n        Returns:\n            float: The total probability mass of all pure-strategy NEs.\n        \"\"\"\n        num_profiles = 1  N  # Equivalent to 2**N\n        profiles = []\n        # Step 1: Enumerate all 2^N profiles\n        for i in range(num_profiles):\n            profile = np.array([int(bit) for bit in bin(i)[2:].zfill(N)])\n            profiles.append(profile)\n\n        potentials = np.zeros(num_profiles, dtype=float)\n        is_ne = np.zeros(num_profiles, dtype=bool)\n\n        for idx, a in enumerate(profiles):\n            # Step 2: Calculate Potential Phi(a)\n            phi_a = 0.0\n            # Interaction term: sum_{1 = i  j = N} W_ij * 1{a_i = a_j}\n            for i in range(N):\n                for j in range(i + 1, N):\n                    if a[i] == a[j]:\n                        phi_a += W[i, j]\n            # Bias term: sum_{i=1 to N} H_i * a_i\n            phi_a += np.dot(H, a)\n            potentials[idx] = phi_a\n\n            # Step 3: Identify if 'a' is a Pure-Strategy Nash Equilibrium\n            ne_flag = True\n            for i in range(N):\n                # Utility of current action a_i\n                u_current = 0.0\n                for j in range(N):\n                    if i == j: continue\n                    if a[i] == a[j]:\n                        u_current += W[i, j]\n                if a[i] == 1:\n                    u_current += H[i]\n\n                # Utility of alternative action 1 - a_i\n                alt_action = 1 - a[i]\n                u_alternative = 0.0\n                for j in range(N):\n                    if i == j: continue\n                    if alt_action == a[j]:\n                        u_alternative += W[i, j]\n                if alt_action == 1:\n                    u_alternative += H[i]\n                \n                # Check for profitable deviation\n                if u_current  u_alternative:\n                    ne_flag = False\n                    break  # This profile is not an NE\n            \n            if ne_flag:\n                is_ne[idx] = True\n\n        # Step 4: Compute stationary distribution pi(a)\n        scaled_potentials = potentials / tau\n        # Use log-sum-exp trick for numerical stability\n        max_scaled_potential = np.max(scaled_potentials) if potentials.size > 0 else 0\n        exp_terms = np.exp(scaled_potentials - max_scaled_potential)\n        partition_function = np.sum(exp_terms)\n        \n        pi = exp_terms / partition_function\n        \n        # Step 5: Compute P_NE by summing probabilities of all NE profiles\n        p_ne = np.sum(pi[is_ne])\n        \n        return p_ne\n\n    # --- Test Suite Definition ---\n\n    # Case 1, 2, 3 parameters\n    W1 = np.array([\n        [0.0, 1.0, 1.0, 1.0],\n        [1.0, 0.0, 1.0, 1.0],\n        [1.0, 1.0, 0.0, 1.0],\n        [1.0, 1.0, 1.0, 0.0]\n    ])\n    H1 = np.array([0.2, 0.2, 0.2, 0.2])\n    \n    # Case 4 parameters\n    W4 = np.array([\n        [0.0,  1.0,  0.0,  0.0,  0.0],\n        [1.0,  0.0, -1.5,  0.0,  0.0],\n        [0.0, -1.5,  0.0,  1.0,  0.0],\n        [0.0,  0.0,  1.0,  0.0, -1.5],\n        [0.0,  0.0,  0.0, -1.5,  0.0]\n    ])\n    H4 = np.array([0.1, 0.1, 0.1, 0.1, 0.1])\n    \n    # Case 5 parameters\n    W5 = np.zeros((5, 5))\n    H5 = np.array([0.1, 0.1, 0.1, 0.1, 0.1])\n    \n    test_cases = [\n        # Case 1: N=4, coordination, low temperature\n        {'N': 4, 'W': W1, 'H': H1, 'tau': 0.1},\n        # Case 2: N=4, coordination, medium temperature\n        {'N': 4, 'W': W1, 'H': H1, 'tau': 1.0},\n        # Case 3: N=4, coordination, high temperature\n        {'N': 4, 'W': W1, 'H': H1, 'tau': 10.0},\n        # Case 4: N=5, mixed couplings, low temperature\n        {'N': 5, 'W': W4, 'H': H4, 'tau': 0.2},\n        # Case 5: N=5, no interactions, high temperature\n        {'N': 5, 'W': W5, 'H': H5, 'tau': 10.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case['N'], case['W'], case['H'], case['tau'])\n        results.append(result)\n\n    # Format and print the final output\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}