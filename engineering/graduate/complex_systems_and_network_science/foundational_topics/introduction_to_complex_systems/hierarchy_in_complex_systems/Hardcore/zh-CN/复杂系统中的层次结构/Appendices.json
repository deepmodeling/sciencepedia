{
    "hands_on_practices": [
        {
            "introduction": "理解复杂系统中层次结构的一个基本方法是量化节点与其邻居节点的层次级别之间的关系。同配性（Assortativity）这个概念，通常通过皮尔逊相关系数来衡量，为我们提供了一个强有力的工具。当我们将节点的层次级别作为其属性时，层次同配性（level assortativity）便能量化网络中节点是倾向于连接到相同、相似还是不同级别的节点。这个练习 () 将指导你从第一性原理出发，推导出计算一个无向网络中标量节点属性同配性的通用公式，并将其应用于一个具体的层次网络，从而让你对如何用精确的数学语言描述和度量层次结构有更深入的理解。",
            "id": "4281144",
            "problem": "考虑一个表示层级系统的无向网络，其节点标记为 $1$ 到 $8$，并带有一个属性 $\\ell_i \\in \\mathbb{N}$，表示节点 $i$ 的层级。各层级定义为 $\\ell_1 = 0$, $\\ell_2 = 1$, $\\ell_3 = 1$, $\\ell_4 = 2$, $\\ell_5 = 2$, $\\ell_6 = 2$, $\\ell_7 = 2$, 和 $\\ell_8 = 3$。该网络包含以下无向边：\n$$(1,2),\\ (1,3),\\ (2,4),\\ (2,5),\\ (3,6),\\ (3,7),\\ (4,5),\\ (6,7),\\ (5,8),\\ (7,8),\\ (2,3)。$$\n使用皮尔逊相关系数（PCC）的定义，将无向网络的层级同配系数 $r_{\\mathrm{level}}$ 定义为当无向边被均匀随机抽样时，边两端节点层级之间的相关性。从两个实值随机变量相关性的基本定义出发，推导一个适用于节点上具有标量属性的无向网络的 $r_{\\mathrm{level}}$ 公式。然后，为上述网络精确计算 $r_{\\mathrm{level}}$。将最终答案表示为单个最简有理数。无需四舍五入。",
            "solution": "该问题被评估为有效，因为它在网络科学方面有科学依据，问题明确，客观，并包含获得唯一解所需的所有信息。\n\n该问题要求推导层级同配系数 $r_{\\mathrm{level}}$ 的通用公式，并为特定网络计算其值。层级同配系数定义为边两端节点层级的皮尔逊相关系数（PCC）。\n\n首先，我们推导通用公式。设网络由节点集 $V$ 和无向边集 $E$ 描述。节点数为 $N = |V|$，边数为 $M = |E|$。每个节点 $i \\in V$ 都有一个标量属性，即其层级，记为 $\\ell_i$。\n\n两个随机变量 $X$ 和 $Y$ 的皮尔逊相关系数 $\\rho_{X,Y}$ 定义为：\n$$\n\\rho_{X,Y} = \\frac{\\mathrm{Cov}(X,Y)}{\\sigma_X \\sigma_Y} = \\frac{E[XY] - E[X]E[Y]}{\\sqrt{E[X^2] - (E[X])^2} \\sqrt{E[Y^2] - (E[Y])^2}}\n$$\n为了将其应用于我们的网络，我们必须定义样本空间和随机变量。问题陈述我们“无方向地均匀随机”抽样边。对于无向网络，一种标准而严谨的形式化方法是考虑一个包含 $2M$ 条有向边的样本空间，其中每条无向边 $(i,j) \\in E$ 对应于两条有向边 $i \\to j$ 和 $j \\to i$。这 $2M$ 条有向边中的每一条都以相等的概率 $\\frac{1}{2M}$ 被选中。\n\n设 $X$ 和 $Y$ 分别是随机选择的有向边的源节点和目标节点的层级的随机变量。对于一条有向边 $i \\to j$，观测值为 $(\\ell_i, \\ell_j)$。\n\n$X$ 的值集是 $\\{\\ell_i | \\text{对于每条有向边 } i \\to j\\}$，$Y$ 的值集是 $\\{\\ell_j | \\text{对于每条有向边 } i \\to j\\}$。因为网络是无向的，所有源节点的集合与所有目标节点的集合相同，$X$ 和 $Y$ 的分布是相同的。因此，$E[X] = E[Y]$ 且 $\\sigma_X = \\sigma_Y$。$r_{\\mathrm{level}}$ 的公式简化为：\n$$\nr_{\\mathrm{level}} = \\frac{E[XY] - (E[X])^2}{E[X^2] - (E[X])^2}\n$$\n我们现在用网络属性来表示期望值。设 $d_i$ 是节点 $i$ 的度。在 $2M$ 条有向边的集合中，节点 $i$ 作为源节点出现 $d_i$ 次。\n$X$ 的期望值为：\n$$\nE[X] = \\sum_{i \\to j} \\frac{1}{2M} \\ell_i = \\frac{1}{2M} \\sum_{i \\in V} d_i \\ell_i\n$$\n$X^2$ 的期望值为：\n$$\nE[X^2] = \\sum_{i \\to j} \\frac{1}{2M} \\ell_i^2 = \\frac{1}{2M} \\sum_{i \\in V} d_i \\ell_i^2\n$$\n联合期望 $E[XY]$ 是对所有 $2M$ 条有向边计算的：\n$$\nE[XY] = \\sum_{i \\to j} \\frac{1}{2M} \\ell_i \\ell_j = \\frac{1}{2M} \\sum_{(i,j) \\in E} (\\ell_i \\ell_j + \\ell_j \\ell_i) = \\frac{2}{2M} \\sum_{(i,j) \\in E} \\ell_i \\ell_j = \\frac{1}{M} \\sum_{(i,j) \\in E} \\ell_i \\ell_j\n$$\n将这些表达式代入 $r_{\\mathrm{level}}$ 的公式中：\n$$\nr_{\\mathrm{level}} = \\frac{\\frac{1}{M} \\sum_{(i,j) \\in E} \\ell_i \\ell_j - \\left(\\frac{1}{2M} \\sum_{k \\in V} d_k \\ell_k\\right)^2}{\\frac{1}{2M} \\sum_{k \\in V} d_k \\ell_k^2 - \\left(\\frac{1}{2M} \\sum_{k \\in V} d_k \\ell_k\\right)^2}\n$$\n为简化表达式，我们将分子和分母同乘以 $4M^2$：\n$$\nr_{\\mathrm{level}} = \\frac{4M \\sum_{(i,j) \\in E} \\ell_i \\ell_j - \\left(\\sum_{k \\in V} d_k \\ell_k\\right)^2}{2M \\sum_{k \\in V} d_k \\ell_k^2 - \\left(\\sum_{k \\in V} d_k \\ell_k\\right)^2}\n$$\n这就是无向网络节点上标量属性的同配系数的通用公式。\n\n现在，我们为给定的网络计算 $r_{\\mathrm{level}}$。\n该网络有 $N=8$ 个节点和 $M=11$ 条边。\n层级为： $\\ell_1=0$, $\\ell_2=1$, $\\ell_3=1$, $\\ell_4=2$, $\\ell_5=2$, $\\ell_6=2$, $\\ell_7=2$, $\\ell_8=3$。\n边为： $(1,2), (1,3), (2,4), (2,5), (3,6), (3,7), (4,5), (6,7), (5,8), (7,8), (2,3)$。\n\n首先，我们计算每个节点 $i$ 的度 $d_i$：\n$d_1 = 2$ (到 $2, 3$ 的边)\n$d_2 = 4$ (到 $1, 4, 5, 3$ 的边)\n$d_3 = 4$ (到 $1, 6, 7, 2$ 的边)\n$d_4 = 2$ (到 $2, 5$ 的边)\n$d_5 = 3$ (到 $2, 4, 8$ 的边)\n$d_6 = 2$ (到 $3, 7$ 的边)\n$d_7 = 3$ (到 $3, 6, 8$ 的边)\n$d_8 = 2$ (到 $5, 7$ 的边)\n度的总和是 $\\sum_{i=1}^8 d_i = 2+4+4+2+3+2+3+2=22$，这正确地等于 $2M = 2 \\times 11$。\n\n接下来，我们计算公式所需的三个总和：\n$1$. $S_1 = \\sum_{k \\in V} d_k \\ell_k$:\n$S_1 = d_1\\ell_1 + d_2\\ell_2 + d_3\\ell_3 + d_4\\ell_4 + d_5\\ell_5 + d_6\\ell_6 + d_7\\ell_7 + d_8\\ell_8$\n$S_1 = (2)(0) + (4)(1) + (4)(1) + (2)(2) + (3)(2) + (2)(2) + (3)(2) + (2)(3)$\n$S_1 = 0 + 4 + 4 + 4 + 6 + 4 + 6 + 6 = 34$\n\n$2$. $S_2 = \\sum_{k \\in V} d_k \\ell_k^2$:\n$S_2 = d_1\\ell_1^2 + d_2\\ell_2^2 + d_3\\ell_3^2 + d_4\\ell_4^2 + d_5\\ell_5^2 + d_6\\ell_6^2 + d_7\\ell_7^2 + d_8\\ell_8^2$\n$S_2 = (2)(0^2) + (4)(1^2) + (4)(1^2) + (2)(2^2) + (3)(2^2) + (2)(2^2) + (3)(2^2) + (2)(3^2)$\n$S_2 = 0 + 4 + 4 + 8 + 12 + 8 + 12 + 18 = 66$\n\n$3$. $S_3 = \\sum_{(i,j) \\in E} \\ell_i \\ell_j$:\n$S_3 = \\ell_1\\ell_2 + \\ell_1\\ell_3 + \\ell_2\\ell_4 + \\ell_2\\ell_5 + \\ell_3\\ell_6 + \\ell_3\\ell_7 + \\ell_4\\ell_5 + \\ell_6\\ell_7 + \\ell_5\\ell_8 + \\ell_7\\ell_8 + \\ell_2\\ell_3$\n$S_3 = (0)(1) + (0)(1) + (1)(2) + (1)(2) + (1)(2) + (1)(2) + (2)(2) + (2)(2) + (2)(3) + (2)(3) + (1)(1)$\n$S_3 = 0 + 0 + 2 + 2 + 2 + 2 + 4 + 4 + 6 + 6 + 1 = 29$\n\n现在我们将这些值代入 $r_{\\mathrm{level}}$ 的公式中，其中 $M=11$：\n$$\nr_{\\mathrm{level}} = \\frac{4M S_3 - S_1^2}{2M S_2 - S_1^2} = \\frac{4(11)(29) - (34)^2}{2(11)(66) - (34)^2}\n$$\n计算分子：\n$4(11)(29) = 44 \\times 29 = 1276$\n$34^2 = 1156$\n分子 = $1276 - 1156 = 120$\n\n计算分母：\n$2(11)(66) = 22 \\times 66 = 1452$\n$34^2 = 1156$\n分母 = $1452 - 1156 = 296$\n\n所以，层级同配系数为：\n$$\nr_{\\mathrm{level}} = \\frac{120}{296}\n$$\n最后，我们将分数化为最简形式。我们求 $120$ 和 $296$ 的最大公约数：\n$120 = 12 \\times 10 = (2^2 \\times 3) \\times (2 \\times 5) = 2^3 \\times 3 \\times 5$\n$296 = 4 \\times 74 = 2^2 \\times (2 \\times 37) = 2^3 \\times 37$\n最大公约数是 $2^3 = 8$。\n$$\nr_{\\mathrm{level}} = \\frac{120 \\div 8}{296 \\div 8} = \\frac{15}{37}\n$$\n给定网络的层级同配系数的精确值为 $\\frac{15}{37}$。",
            "answer": "$$\\boxed{\\frac{15}{37}}$$"
        },
        {
            "introduction": "在许多有向网络（如信息流、基因调控或组织指挥链）中，层次结构的核心体现为可达性（reachability）的差异——少数节点可以触及网络中的大部分其他节点，而多数节点的影响范围则非常有限。全局可达中心性（Global Reaching Centrality, GRC）正是衡量这种可达性异质性的一个有效指标。此练习 () 旨在通过一个计算实践，让你掌握如何量化这种层次结构，并探索它与网络局部属性（如度分布）之间的区别。你将实现一个标准的“度保持重连”（degree-preserving rewiring）算法，这是一种在不改变任何节点出入度的情况下随机化网络连接的零模型方法，通过比较重连前后 $GRC$ 的变化，你将亲眼见证层次结构作为一个非局域的宏观属性，是如何在局部属性保持不变的情况下被破坏的。",
            "id": "4281098",
            "problem": "你的任务是形式化并计算有向网络中的度保持重连如何影响一个称为“全局可达中心性”(Global Reaching Centrality)的层级度量。你的程序必须从复杂系统和网络科学的核心定义出发，不得依赖任何预设答案的捷径或启发式方法。一个有向图由一个大小为 $N$ 的节点集和一组有向边定义。有向图的入度和出度序列分别是每个节点的入边和出边数量的计数。度保持重连是对边集的任何一种变换，该变换能使每个节点的入度和出度序列都保持不变。一种能保持度序列的标准微观操作是双边交换：选取两条不同的边 $(u \\to v)$ 和 $(x \\to y)$，若有效，则将其替换为 $(u \\to y)$ 和 $(x \\to v)$；有效性要求不产生自环，不引入平行边（即，图仍为简单有向图），并且替换后的两条边与原始边不相同。\n\n节点 $i$ 的局部可达中心性 (local reaching centrality) 定义为它能通过有向路径到达的其他节点的比例。对于一个有 $N$ 个节点的有向图，设可达性计数 $R_i$ 为从节点 $i$ 出发沿有向路径可达的不同节点的数量（不包括 $i$ 自身）。那么，局部可达中心性为 $c(i) = R_i / (N-1)$。全局可达中心性 (GRC) 通过聚合所有节点与最大局部可达中心性 $c_{\\max} = \\max_j c(j)$ 的差距，来刻画局部可达中心性的异质性。你必须基于这些定义，推导并实现这个网络层面度量的计算。\n\n你的程序必须：\n- 为每个节点 $i$ 实现有向可达性计算，以统计 $R_i$；并由此为每个节点 $i$ 计算 $c(i)$；然后以 $c_{\\max}$ 和集合 $\\{c(i)\\}$ 为基础，通过聚合计算全局可达中心性。\n- 根据上述规范，基于重复的有效双边交换实现度保持重连。设 $E$ 表示有向边的数量。对于给定的重连强度参数 $f \\in [0,1]$，需执行恰好 $S = \\lfloor f \\cdot E \\rfloor$ 次成功的交换。为保证可复现性，随机性必须由一个给定的整数种子 $s$ 控制。\n- 对于下面提供的每个测试用例，计算原始图的全局可达中心性，使用指定的 $(f,s)$ 对图进行重连，然后再次计算全局可达中心性。返回一个由初始值、重连后的值以及它们的差值（重连后减去重连前）组成的三元组。\n\n使用以下测试套件，其中节点标记为 $0,1,\\dots,N-1$，每条边是一个有序对 $(u,v)$，表示一条有向边 $u \\to v$。此处提供的所有数字（包括 $N$、$E$、$f$ 和 $s$ 的值）都必须严格按字面值使用。\n\n- 测试用例 $1$ (层级树状结构):\n  - $N = 9$\n  - 边集: $(0,1)$, $(0,2)$, $(0,3)$, $(1,4)$, $(1,5)$, $(2,6)$, $(3,7)$, $(3,8)$\n  - $f = 1.0$\n  - 种子 $s = 42$\n\n- 测试用例 $2$ (有向环):\n  - $N = 8$\n  - 边集: $(0,1)$, $(1,2)$, $(2,3)$, $(3,4)$, $(4,5)$, $(5,6)$, $(6,7)$, $(7,0)$\n  - $f = 1.0$\n  - 种子 $s = 7$\n\n- 测试用例 $3$ (前馈有向无环图):\n  - $N = 10$\n  - 边集: $(0,2)$, $(0,3)$, $(1,3)$, $(1,4)$, $(2,5)$, $(2,6)$, $(3,6)$, $(4,7)$, $(5,8)$, $(6,8), $(7,9), $(8,9)$\n  - $f = 0.5$\n  - 种子 $s = 123$\n\n- 测试用例 $4$ (边界无重连情况):\n  - $N = 7$\n  - 边集: $(0,1)$, $(0,2)$, $(1,3)$, $(2,3)$, $(3,4)$, $(4,5)$, $(5,6)$\n  - $f = 0.0$\n  - 种子 $s = 99$\n\n最终输出格式:\n- 你的程序必须生成单行输出，其中包含一个扁平列表，按顺序包含每个测试用例的3个浮点数，并连接成一个列表。对于每个测试用例，输出初始全局可达中心性、重连后全局可达中心性以及它们的差值（重连后减去重连前）。将所有测试用例的这些三元组连接成一个单一列表。每个浮点数必须四舍五入到恰好6位小数。最后一行必须如下所示\n  - $[\\text{r}_{1,1},\\text{r}_{1,2},\\text{r}_{1,3},\\text{r}_{2,1},\\dots,\\text{r}_{4,3}]$\n  其中 $\\text{r}_{k,j}$ 是测试用例 $k$ 的第 $j$ 个结果。",
            "solution": "经过严格审查，该问题被认定是有效的。它在网络科学方面有坚实的科学基础，问题定义明确且客观。全局可达中心性 (GRC) 的定义被表述为对各节点与最大局部中心性之间差距的聚合。虽然没有指定确切的聚合函数，但科学文献中存在一个标准定义，我将采用该定义。此问题可通过标准图算法的组合来解决。\n\n解决方案分为三个主要阶段：首先，形式化并计算全局可达中心性 (GRC)；其次，实现度保持重连过程；最后，将这些方法应用于每个测试用例。\n\n### 1. 全局可达中心性 (GRC)\n\n问题将有向图中一个节点 $i$ 的局部可达中心性 $c(i)$ 定义为它能到达的其他节点的比例（该图共有 $N$ 个节点）。设 $R_i$ 是从节点 $i$ 出发，通过有向路径可达的不同节点的数量（不包括节点 $i$ 自身）。那么，局部可达中心性为：\n$$c(i) = \\frac{R_i}{N-1}$$\n当 $N > 1$ 时，该值是良定义的。\n\n全局可达中心性 (GRC) 被描述为衡量这些局部中心性异质性的指标，基于其与观察到的最大中心性 $c_{\\max} = \\max_j c(j)$ 的偏差。遵循复杂系统文献中的标准定义，我们将 GRC 形式化为网络中所有节点上这些偏差的归一化总和：\n$$GRC = \\frac{\\sum_{i=0}^{N-1} (c_{\\max} - c(i))}{N-1}$$\n当 $N>1$ 时，此公式也是良定义的。GRC 为 0 表示所有节点具有相同的局部可达中心性（一种“平等主义”结构），而较高的 GRC 值则表示更大的异质性，这是层级结构的特征，即少数节点可以到达许多其他节点，而大多数节点的可达范围非常有限。\n\n为了计算 GRC，我们必须首先为每个节点 $i \\in \\{0, 1, \\dots, N-1\\}$ 计算 $R_i$。这是一个有向图上的标准可达性问题。对于每个节点 $i$，我们可以从 $i$ 开始执行图遍历算法，如广度优先搜索 (BFS) 或深度优先搜索 (DFS)。所有被访问过的节点（不包括起始节点 $i$）的集合构成了可达节点的集合。该集合的大小即为 $R_i$。计算 GRC 的整体算法如下：\n1. 对每个节点 $i=0, \\dots, N-1$：\n   a. 从 $i$ 开始执行图遍历（例如 BFS）以找到所有可达节点。\n   b. 统计可达节点的数量以得到 $R_i$。\n   c. 计算 $c(i) = R_i / (N-1)$。\n2. 找到最大局部中心性 $c_{\\max} = \\max_i c(i)$。\n3. 使用公式 $GRC = (\\sum_i (c_{\\max} - c(i))) / (N-1)$ 计算 GRC。\n\n### 2. 度保持重连\n\n问题指定了一种度保持重连机制：双边交换。此过程在修改网络拓扑的同时，确保每个节点的入度和出度保持不变。该过程如下：\n1. 从图的边集中随机选择两条不同的有向边 $(u \\to v)$ 和 $(x \\to y)$。\n2. 尝试用一对新边 $(u \\to y)$ 和 $(x \\to v)$ 替换它们。\n3. 只有当交换遵循简单有向图的以下有效性条件时，才被认为是“成功的”：\n   a. **无自环**：新边不能是自环，即 $u \\neq y$ 且 $x \\neq v$。\n   b. **无平行边**：新边 $(u \\to y)$ 和 $(x \\to v)$ 不能已存在于图中。\n   c. **非平凡性**：新边集必须与原边集不同。这当且仅当 $u \\neq x$ 且 $v \\neq y$ 时成立。此条件确保交换确实修改了图的结构。\n\n对于一个具有 $E$ 条边和重连强度参数 $f \\in [0,1]$ 的给定图，算法必须执行恰好 $S = \\lfloor f \\cdot E \\rfloor$ 次成功的交换。为实现这一目标，我们重复选择边对并根据有效性条件进行测试，直到累积了 $S$ 次成功的交换。随机性由种子 $s$ 管理以确保可复现性。\n\n因此，重连的算法如下：\n1. 使用给定的种子 $s$ 初始化一个伪随机数生成器。\n2. 设当前边集为 $\\mathcal{E}$。设 $E = |\\mathcal{E}|$。\n3. 计算目标交换次数 $S = \\lfloor f \\cdot E \\rfloor$。\n4. 如果 $S > 0$，则进入一个循环以执行 $S$ 次成功的交换：\n   a. 从当前边列表中重复选择两条不同的边 $(u, v)$ 和 $(x, y)$。\n   b. 检查交换为 $(u, y)$ 和 $(x, v)$ 是否有效（无自环、无平行边、非平凡）。\n   c. 如果有效，更新边集：$\\mathcal{E} \\leftarrow (\\mathcal{E} \\setminus \\{(u,v), (x,y)\\}) \\cup \\{(u,y), (x,v)\\}}$。这构成一次成功的交换。增加成功计数器并进行下一次交换。\n   d. 如果无效，则放弃本次选择，并尝试一对新的随机边。\n\n### 3. 每个测试用例的总体流程\n\n对于每个由节点数 $N$、初始边集、重连强度 $f$ 和种子 $s$ 定义的测试用例，执行以下步骤：\n1. 根据给定的 $N$ 和边集构建初始图。\n2. 使用第1节中描述的方法计算初始全局可达中心性 $GRC_{initial}$。\n3. 使用参数 $f$ 和 $s$ 执行第2节中描述的度保持重连算法，以获得一个新的、重连后的图。如果 $f=0$，则不发生重连，图保持不变。\n4. 计算重连后图的全局可达中心性 $GRC_{post}$。\n5. 计算差值 $\\Delta_{GRC} = GRC_{post} - GRC_{initial}$。\n6. 该测试用例的最终结果是三元组 $(GRC_{initial}, GRC_{post}, \\Delta_{GRC})$。将所有测试用例的三元组连接起来，生成最终输出。",
            "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 9,\n            \"edges\": [(0, 1), (0, 2), (0, 3), (1, 4), (1, 5), (2, 6), (3, 7), (3, 8)],\n            \"f\": 1.0,\n            \"s\": 42\n        },\n        {\n            \"N\": 8,\n            \"edges\": [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 0)],\n            \"f\": 1.0,\n            \"s\": 7\n        },\n        {\n            \"N\": 10,\n            \"edges\": [\n                (0, 2), (0, 3), (1, 3), (1, 4), (2, 5), (2, 6), \n                (3, 6), (4, 7), (5, 8), (6, 8), (7, 9), (8, 9)\n            ],\n            \"f\": 0.5,\n            \"s\": 123\n        },\n        {\n            \"N\": 7,\n            \"edges\": [(0, 1), (0, 2), (1, 3), (2, 3), (3, 4), (4, 5), (5, 6)],\n            \"f\": 0.0,\n            \"s\": 99\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N, edges, f, s = case[\"N\"], case[\"edges\"], case[\"f\"], case[\"s\"]\n        initial_grc, post_grc, diff_grc = process_case(N, edges, f, s)\n        results.extend([initial_grc, post_grc, diff_grc])\n\n    # Format output to exactly 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _get_reachable_set(start_node, N, adj):\n    \"\"\"\n    Computes the set of reachable nodes from a given start_node using BFS.\n    \"\"\"\n    if start_node not in adj:\n        return set()\n    \n    q = deque([start_node])\n    visited = {start_node}\n    \n    while q:\n        u = q.popleft()\n        if u in adj:\n            for v in adj[u]:\n                if v not in visited:\n                    visited.add(v)\n                    q.append(v)\n                    \n    return visited - {start_node}\n\ndef calculate_grc(N, edges):\n    \"\"\"\n    Calculates the Global Reaching Centrality for a given graph.\n    \"\"\"\n    if N == 1:\n        return 0.0\n\n    adj = {i: [] for i in range(N)}\n    for u, v in edges:\n        adj[u].append(v)\n\n    local_centralities = np.zeros(N)\n    for i in range(N):\n        reachable_nodes = _get_reachable_set(i, N, adj)\n        R_i = len(reachable_nodes)\n        local_centralities[i] = R_i / (N - 1)\n\n    if len(local_centralities) == 0:\n        return 0.0\n        \n    c_max = np.max(local_centralities)\n    \n    grc_numerator = np.sum(c_max - local_centralities)\n    grc = grc_numerator / (N - 1)\n    \n    return grc\n\ndef process_case(N, edges, f, s):\n    \"\"\"\n    Processes a single test case: calculates initial GRC, performs rewiring,\n    and calculates post-rewiring GRC.\n    \"\"\"\n    # Calculate initial GRC\n    initial_grc = calculate_grc(N, edges)\n\n    # Perform rewiring\n    E = len(edges)\n    num_swaps = int(f * E)\n    \n    if num_swaps == 0:\n        post_grc = initial_grc\n    else:\n        rng = np.random.default_rng(seed=s)\n        edge_set = set(edges)\n        edge_list = list(edges)\n\n        successful_swaps = 0\n        # Add a failsafe for potentially difficult-to-rewire topologies\n        max_attempts = 100 * E * num_swaps if num_swaps > 0 else 1\n        attempts = 0\n\n        while successful_swaps  num_swaps and attempts  max_attempts:\n            attempts += 1\n            if len(edge_list)  2:\n                break # Not enough edges to perform a swap\n            \n            # 1. Pick two distinct edges\n            idx1, idx2 = rng.choice(len(edge_list), size=2, replace=False)\n            u, v = edge_list[idx1]\n            x, y = edge_list[idx2]\n\n            # 2. Check for non-triviality\n            if u == x or v == y:\n                continue\n\n            # Proposed new edges\n            new_edge1 = (u, y)\n            new_edge2 = (x, v)\n\n            # 3. Validity checks\n            # a. No self-loops\n            if u == y or x == v:\n                continue\n            # b. No parallel edges\n            if new_edge1 in edge_set or new_edge2 in edge_set:\n                continue\n            \n            # The swap is valid and successful\n            # Update edge_set\n            edge_set.remove((u, v))\n            edge_set.remove((x, y))\n            edge_set.add(new_edge1)\n            edge_set.add(new_edge2)\n            \n            # Update edge_list for next random sampling\n            edge_list[idx1] = new_edge1\n            edge_list[idx2] = new_edge2\n\n            successful_swaps += 1\n\n        # Calculate post-rewiring GRC\n        post_grc = calculate_grc(N, list(edge_set))\n\n    # Calculate difference\n    diff_grc = post_grc - initial_grc\n\n    return initial_grc, post_grc, diff_grc\n\nsolve()\n```"
        },
        {
            "introduction": "某些层次系统的一个显著特征是自相似性，即系统的结构在不同尺度下呈现出统计上的相似性，就像分形几何对象一样。这种结构上的重复模式是层次组织的有力证据。为了探测和量化这种自相似层次结构，我们可以使用分形分析中的“盒子覆盖法”（box-covering method）。此练习 () 将引导你实现一个贪心算法来近似计算在不同半径 $r$ 下覆盖整个网络所需的最小“盒子”数量 $N_B(r)$。通过分析 $N_B(r)$ 与 $r$ 之间的标度关系，你不仅能估算出网络的分形维数 $d_B$，还将学习如何评估这种标度关系的稳定性——一个稳定的分形维数是判断系统是否具有真正自相似层次结构的关键证据。",
            "id": "4281053",
            "problem": "您的任务是在无向、无权图上实现一个广义的盒覆盖程序，通过研究分形（盒）维数的稳定性来探讨层次自相似性。请从以下基本概念出发：图的定义、最短路径距离的定义，以及分形网络的经验标度关系。目标是计算在多个盒半径下覆盖图所需的最小盒数，拟合盒标度指数，并判断该指数是否在不同尺度上保持稳定。\n\n定义与要求：\n- 设图表示为 $G = (V, E)$，其中 $V$ 是一个包含 $\\lvert V \\rvert = n$ 个节点的有限集合，$E \\subseteq \\{ \\{u,v\\} \\mid u,v \\in V, u \\neq v \\}$ 是一个无向边集合，图中没有自环或多重边。\n- 设 $d(u,v)$ 为节点 $u$ 和 $v$ 之间的最短路径距离，定义为在图 $G$ 中从 $u$ 到 $v$ 的任意简单路径上的最小边数。如果不存在路径，则距离定义为无穷大；然而，这里考虑的所有图都是连通的，因此所有节点对之间的距离都是有限的。\n- 对于整数半径 $r \\geq 1$，定义以节点 $c \\in V$ 为中心的半径为 $r$ 的盒为集合 $B_r(c) = \\{ v \\in V \\mid d(c,v) \\leq r \\}$。图的一个半径为 $r$ 的盒覆盖是满足 $\\bigcup_{i=1}^{N} B_r(c_i) = V$ 的任意盒族 $\\{ B_r(c_i) \\}_{i=1}^{N}$。半径为 $r$ 时的最小盒数记为 $N_B(r)$。\n- 当标度关系 $N_B(r) \\propto r^{-d_B}$ 在多个 $r$ 的尺度上近似有效时，盒（分形）维数 $d_B$ 可通过此关系进行操作性定义。在实践中，指数 $d_B$ 通过对 $\\log N_B(r)$ 与 $\\log r$ 进行线性回归来估计，$d_B$ 等于斜率的相反数。\n\n算法约束：\n- 对于一般图，计算精确的最小 $N_B(r)$ 是一个组合上困难的问题。您必须实现一个基于最大排除质量燃烧逻辑的有原则的贪心近似算法：迭代选择一个节点作为盒中心，该节点能在半径 $r$ 内覆盖最多数量的当前未覆盖节点，然后将这些节点标记为已覆盖，并持续此过程直至所有节点都被覆盖。这个贪心过程为每个 $r$ 定义了一个近似的 $N_B(r)$。\n- 使用从每个节点开始的广度优先搜索来计算所有节点对之间的最短路径距离 $d(u,v)$，以确保在无权图中的正确性。\n\n稳定性评估：\n- 对于给定的半径集合 $\\{ r_1, r_2, \\dots, r_m \\}$，其中 $r_i \\in \\mathbb{N}$ 且 $r_i \\geq 1$，计算所有 $i$ 对应的 $N_B(r_i)$。\n- 使用最小二乘法将直线 $y = a + b x$ 拟合到点 $(x_i, y_i)$，其中 $x_i = \\log r_i$ 且 $y_i = \\log N_B(r_i)$。估计的盒维数为 $d_B = -b$。\n- 计算拟合的决定系数 $R^2$，其定义为 $R^2 = 1 - \\frac{\\sum_{i=1}^{m} (y_i - \\hat{y}_i)^2}{\\sum_{i=1}^{m} (y_i - \\bar{y})^2}$，其中 $\\hat{y}_i = a + b x_i$，$\\bar{y}$ 是 $y_i$ 值的均值。\n- 通过 $s_i = - \\frac{y_{i+1} - y_i}{x_{i+1} - x_i}$（对于 $i = 1, \\dots, m-1$）定义连续尺度之间的局部斜率。设 $\\mu_s$ 为 $\\{ s_i \\}$ 的均值，$\\sigma_s$ 为其标准差。当 $\\mu_s > 0$ 时，定义变异系数 $\\mathrm{CV} = \\sigma_s / \\mu_s$。\n- 当且仅当以下条件同时成立时，宣布该估计是稳定分形的（解释为层次自相似性的证据）：(i) $m \\geq 3$，(ii) $\\mu_s > 0$，(iii) $\\mathrm{CV} \\leq \\tau$，以及 (iv) $R^2 \\geq \\rho$。使用 $\\tau = 0.15$ 和 $\\rho = 0.90$。\n- 如果 $m  3$，您必须将稳定性判定设置为假，因为无法在少于三个尺度上评估稳定性。\n\n您的程序必须实现以上内容，并为以下测试套件生成结果：\n\n测试套件：\n1. 方形晶格图：设 $G$ 是一个边长为 $s = 6$ 的二维网格，有 $n = 36$ 个节点，其中节点与其存在的四个曼哈顿邻居相连。使用半径 $\\{ r \\in \\mathbb{N} \\mid r \\in \\{ 1, 2, 3 \\} \\}$。\n2. 星形图：设 $G$ 是一个有一个中心节点和 $L = 20$ 个叶节点的星形图，因此有 $n = 21$ 个节点，其边为 $\\{ \\{0,i\\} \\mid i \\in \\{1, \\dots, 20\\} \\}$。使用半径 $\\{ r \\in \\mathbb{N} \\mid r \\in \\{ 1, 2 \\} \\}$。\n3. 平衡有根树：设 $G$ 是一个分支因子为 $b = 3$、高度为 $h = 3$ 的有根树，共有 $n = 1 + 3 + 9 + 27 = 40$ 个节点。该树通过确定性地将 $\\ell$ 层的每个节点连接到 $\\ell + 1$ 层的 $b$ 个子节点来构建，其中 $\\ell \\in \\{ 0,1,2 \\}$。使用半径 $\\{ r \\in \\mathbb{N} \\mid r \\in \\{ 1, 2, 3, 4 \\} \\}$。\n\n最终输出规范：\n- 对于每个测试用例，输出一个包含两个元素的列表 $[d_B, \\text{stable}]$，其中 $d_B$ 是一个四舍五入到四位小数的浮点数，$\\text{stable}$ 是一个文本形式为 $\\mathrm{True}$ 或 $\\mathrm{False}$ 的布尔值。\n- 将三个用例的输出聚合到一个列表中，并以一行无空格的形式打印，格式严格为 $[[d_{B,1},\\mathrm{stable}_1],[d_{B,2},\\mathrm{stable}_2],[d_{B,3},\\mathrm{stable}_3]]$。\n- 不涉及物理单位。不使用角度。所有答案均为纯数值或布尔值。",
            "solution": "任务是实现一种图上的广义盒覆盖程序，通过分析分形维数的稳定性来评估层次自相似性。这包括几个步骤：构建指定的图，计算所有节点对之间的最短路径，应用贪心算法来近似计算不同半径 $r$ 下的最小盒数 $N_B(r)$，最后对 $(r, N_B(r))$ 数据进行标度分析，以确定盒维数 $d_B$ 及其在不同尺度上的稳定性。\n\n首先，我们使用邻接表来表示图 $G=(V, E)$，这是一种用于稀疏图的标准且高效的数据结构。节点数用 $n = |V|$ 表示。我们需要函数来构建三种指定的图拓扑结构：\n1.  边长为 $s$ 的二维方形晶格，产生 $n = s^2$ 个节点。每个节点 $(i, j)$ 与其曼哈顿邻居 $(i \\pm 1, j)$ 和 $(i, j \\pm 1)$ 相连，前提是这些邻居在网格边界内。\n2.  具有一个中心节点和 $L$ 个叶节点的星形图，总共有 $n = L+1$ 个节点。中心节点与所有叶节点相连，叶节点之间没有连接。\n3.  分支因子为 $b$、高度为 $h$ 的平衡有根树。总节点数为 $n = \\sum_{i=0}^{h} b^i = \\frac{b^{h+1}-1}{b-1}$。该图从第0层的根节点开始，逐层构建。\n\n盒覆盖方法的基础是任意两个节点 $u, v \\in V$ 之间的最短路径距离 $d(u,v)$。由于图是无权的，最短路径距离就是连接节点的路径中的最小边数。在无权图中计算所有节点对之间的最短路径（APSP）最直接的方法是从图中的每个节点开始执行广度优先搜索（BFS）。对于每个源节点 $s$，BFS 逐层探索图，确保通过最短路径到达任何节点 $v$。从 $s$到所有其他节点的距离被存储下来。通过对所有 $n$ 个节点重复此过程作为源节点，我们填充一个存储所有 $d(u,v)$ 值的 $n \\times n$ 距离矩阵。\n\n问题的核心是确定 $N_B(r)$，即覆盖图所需的半径为 $r$ 的盒的最小数量。一个盒 $B_r(c)$ 是距离中心节点 $c$ 不超过 $r$ 的所有节点的集合。找到精确的最小值等价于集合覆盖问题，这是一个NP难问题。因此，我们使用指定的贪心近似算法：\n1.  将未覆盖节点集 $U$ 初始化为整个节点集 $V$。将盒数初始化为 $0$。\n2.  当 $U$ 不为空时：\n    a. 增加盒计数。\n    b. 确定最优的盒中心 $c^* \\in V$，它能最大化其所能覆盖的当前未覆盖节点的数量，即 $c^* = \\arg\\max_{c \\in V} |B_r(c) \\cap U|$。\n    c. 通过移除所选盒中包含的所有节点来更新未覆盖节点集：$U \\leftarrow U \\setminus B_r(c^*)$。\n3.  最终的盒数是算法对 $N_B(r)$ 的估计值。\n对指定集合 $\\{r_1, r_2, \\dots, r_m\\}$ 中的每个半径 $r$ 重复此过程。\n\n最后一步是标度分析。如果一个图在一系列尺度 $r$ 上表现出幂律标度 $N_B(r) \\propto r^{-d_B}$，则它被认为是类分形的。对这个关系取对数会得到一个线性方程：$\\log N_B(r) = C - d_B \\log r$，其中 C 是一个常数。我们可以通过对数据点 $(x_i, y_i) = (\\log r_i, \\log N_B(r_i))$ 进行线性最小二乘回归来估计盒维数 $d_B$。估计的维数 $d_B$ 是计算出的斜率的相反数。\n\n这种标度的稳定性通过两个指标进行评估。首先，决定系数 $R^2 = 1 - \\frac{\\sum (y_i - \\hat{y}_i)^2}{\\sum (y_i - \\bar{y})^2}$ 量化了线性拟合的优度。接近 $1$ 的 $R^2$ 值表明幂律模型很好地描述了数据。其次，我们通过计算局部斜率 $s_i = - \\frac{\\log N_B(r_{i+1}) - \\log N_B(r_i)}{\\log r_{i+1} - \\log r_i}$ 来分析标度指数在不同尺度上的一致性。如果标度是稳定的，这些局部斜率应该几乎是常数。我们使用变异系数 $\\mathrm{CV} = \\sigma_s / \\mu_s$ 来量化它们的变化，其中 $\\mu_s$ 和 $\\sigma_s$ 分别是局部斜率 $\\{s_i\\}$ 的均值和标准差。低的 CV 值表示稳定的标度。\n\n如果一个图在至少 $m \\geq 3$ 个尺度上进行测量，平均局部斜率 $\\mu_s$ 为正，拟合质量高（$R^2 \\geq \\rho=0.90$），且局部斜率变化低（$\\mathrm{CV} \\leq \\tau=0.15$），则该图被宣布具有稳定的分形维数。如果 $m  3$，稳定性评估没有意义，结果定义为不稳定。\n实现将遵循这些原则，使用 `numpy` 进行高效的数值计算，如线性回归、均值和标准差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef create_square_lattice(s):\n    \"\"\"Creates an adjacency list for an s x s square lattice graph.\"\"\"\n    n = s * s\n    adj_list = [[] for _ in range(n)]\n    for i in range(s):\n        for j in range(s):\n            node_idx = i * s + j\n            if i > 0:\n                adj_list[node_idx].append((i - 1) * s + j)\n            if i  s - 1:\n                adj_list[node_idx].append((i + 1) * s + j)\n            if j > 0:\n                adj_list[node_idx].append(i * s + (j - 1))\n            if j  s - 1:\n                adj_list[node_idx].append(i * s + (j + 1))\n    return adj_list\n\ndef create_star_graph(L):\n    \"\"\"Creates an adjacency list for a star graph with L leaves.\"\"\"\n    n = L + 1\n    adj_list = [[] for _ in range(n)]\n    hub = 0\n    for leaf in range(1, n):\n        adj_list[hub].append(leaf)\n        adj_list[leaf].append(hub)\n    return adj_list\n\ndef create_balanced_tree(b, h):\n    \"\"\"Creates an adjacency list for a balanced rooted tree.\"\"\"\n    if b == 1:\n        n = h + 1\n    else:\n        n = (b**(h + 1) - 1) // (b - 1)\n\n    adj_list = [[] for _ in range(n)]\n    if n = 1:\n        return adj_list\n    \n    current_node = 1\n    parents = [0]\n    for _ in range(h):\n        next_parents = []\n        for p in parents:\n            for _ in range(b):\n                if current_node  n:\n                    adj_list[p].append(current_node)\n                    adj_list[current_node].append(p)\n                    next_parents.append(current_node)\n                    current_node += 1\n        parents = next_parents\n    return adj_list\n\ndef calculate_apsp(adj_list):\n    \"\"\"Calculates all-pairs shortest paths using BFS from each node.\"\"\"\n    n = len(adj_list)\n    dist_matrix = np.full((n, n), -1, dtype=int)\n    for i in range(n):\n        dist_matrix[i, i] = 0\n        q = deque([(i, 0)])\n        visited = {i}\n        while q:\n            u, d = q.popleft()\n            for v in adj_list[u]:\n                if v not in visited:\n                    visited.add(v)\n                    dist_matrix[i, v] = d + 1\n                    q.append((v, d + 1))\n    return dist_matrix\n\ndef compute_nb_greedy(dist_matrix, r):\n    \"\"\"Computes N_B(r) using the specified greedy algorithm.\"\"\"\n    n = dist_matrix.shape[0]\n    uncovered_nodes = set(range(n))\n    num_boxes = 0\n    \n    potential_covers = [\n        {v for v in range(n) if dist_matrix[c, v] = r} for c in range(n)\n    ]\n\n    while uncovered_nodes:\n        num_boxes += 1\n        best_center = -1\n        max_newly_covered_count = -1\n        \n        for c in range(n):\n            newly_covered_count = len(potential_covers[c].intersection(uncovered_nodes))\n            if newly_covered_count > max_newly_covered_count:\n                max_newly_covered_count = newly_covered_count\n                best_center = c\n        \n        if max_newly_covered_count == 0:\n            break\n            \n        nodes_in_chosen_box = potential_covers[best_center]\n        uncovered_nodes.difference_update(nodes_in_chosen_box)\n        \n    return num_boxes\n\ndef analyze_scaling(radii, nb_values):\n    \"\"\"Analyzes scaling to find d_B and stability.\"\"\"\n    m = len(radii)\n    tau = 0.15\n    rho = 0.90\n    \n    if m  3:\n        stable = False\n        if m  2:\n            db = 0.0\n        else: # m == 2\n            x = np.log(radii)\n            if np.isclose(x[1], x[0]): \n                db = 0.0\n                return db, stable\n            y = np.log(nb_values)\n            if np.isclose(y[1], y[0]):\n                db = 0.0\n            else:\n                b = (y[1] - y[0]) / (x[1] - x[0])\n                db = -b\n        return db, stable\n\n    x = np.log(radii)\n    y = np.log(nb_values)\n    \n    if np.allclose(y, y[0]):\n        return 0.0, False\n\n    b, a = np.polyfit(x, y, 1)\n    db = -b\n    \n    y_pred = b * x + a\n    ss_res = np.sum((y - y_pred)**2)\n    ss_tot = np.sum((y - np.mean(y))**2)\n    if ss_tot == 0: # All y are the same, should have been caught by np.allclose\n        r_squared = 1.0 if ss_res == 0 else 0.0\n    else:\n        r_squared = 1 - (ss_res / ss_tot)\n        \n    local_slopes = -np.diff(y) / np.diff(x)\n    \n    if len(local_slopes)  1:\n        return db, False\n        \n    mu_s = np.mean(local_slopes)\n    \n    if mu_s = 0 or len(local_slopes)  2:\n        return db, False\n        \n    sigma_s = np.std(local_slopes, ddof=1)\n    cv = sigma_s / mu_s if mu_s != 0 else float('inf')\n    \n    stable = (mu_s > 0) and (cv = tau) and (r_squared >= rho)\n    \n    return db, stable\n\ndef solve():\n    test_suite = [\n        {'type': 'lattice', 'params': {'s': 6}, 'radii': [1, 2, 3]},\n        {'type': 'star', 'params': {'L': 20}, 'radii': [1, 2]},\n        {'type': 'tree', 'params': {'b': 3, 'h': 3}, 'radii': [1, 2, 3, 4]} \n    ]\n    \n    final_results = []\n    \n    for test in test_suite:\n        if test['type'] == 'lattice':\n            adj = create_square_lattice(**test['params'])\n        elif test['type'] == 'star':\n            adj = create_star_graph(**test['params'])\n        elif test['type'] == 'tree':\n            adj = create_balanced_tree(**test['params'])\n            \n        dist_matrix = calculate_apsp(adj)\n        \n        radii = test['radii']\n        nb_values = [compute_nb_greedy(dist_matrix, r) for r in radii]\n            \n        db, stable = analyze_scaling(radii, nb_values)\n        \n        final_results.append(f\"[{db:.4f},{str(stable)}]\")\n        \n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"
        }
    ]
}