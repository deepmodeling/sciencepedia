{
    "hands_on_practices": [
        {
            "introduction": "在复杂系统中，一个核心挑战是如何形式化地定义系统与环境之间的边界。概率图模型中的马尔可夫毯（Markov blanket）概念为此提供了一个基于统计依赖关系的严谨答案。本练习旨在通过推导马尔可夫毯如何实现变量的条件独立性，并构建一个仅依赖于边界变量的预测估计器，来巩固您对这一核心概念的理解。",
            "id": "4306340",
            "problem": "考虑一个复杂系统，由一组随机变量 $\\{X_{v}\\}_{v \\in V}$ 表示，这些变量由一个无向网络 $G=(V,E)$ 的节点集 $V$ 索引。固定一个节点 $i \\in V$，并设其马尔可夫毯 $B$ 为 $V \\setminus \\{i\\}$ 的一个最小子集，使得在给定 $X_{B}$ 的条件下，$X_{i}$ 与其余变量 $R := V \\setminus (\\{i\\} \\cup B)$ 条件独立。马尔可夫毯编码了一个有原则的系统边界：$X_{i}$ 仅通过 $X_{B}$ 与环境相互作用。\n\n假设以下基本性质：\n- 根据概率的链式法则，对于变量的任意划分，联合分布可以分解为条件概率的乘积。\n- 根据全局马尔可夫性质和 Hammersley–Clifford 定理，对于与 $G$ 一致的严格正分布，马尔可夫毯 $B$ 将 $i$ 与 $R$ 分隔开，即 $X_{i} \\perp X_{R} \\mid X_{B}$。\n\nA部分（边界诱导的分解）。仅使用这些基本性质和马尔可夫毯的定义，推导出联合分布的一个边界分解，其形式如下：\n$$\nP(x) = P(x_{B}) \\, P(x_{i} \\mid x_{B}) \\, P(x_{R} \\mid x_{B}),\n$$\n其中 $x$ 表示 $X_{V}$ 的一个实现，$x_{S}$ 表示对 $S \\subseteq V$ 中索引的限制。\n\nB部分（仅依赖于马尔可夫毯的估计器）。现在假设 $X := (X_{v})_{v \\in V}$ 服从一个与 $G$ 一致的零均值高斯马尔可夫随机场，其密度为\n$$\nP(x) \\propto \\exp\\!\\left( -\\tfrac{1}{2} \\, x^{\\top} \\Lambda \\, x \\right),\n$$\n其中 $\\Lambda \\in \\mathbb{R}^{|V| \\times |V|}$ 是一个对称正定精度矩阵，其稀疏模式与 $G$ 匹配，即当 $(i,j) \\notin E$ 且 $i \\neq j$ 时，$\\Lambda_{ij} = 0$。将变量划分为 $x = (x_{i}, x_{B}, x_{R})$，并相应地将 $\\Lambda$ 分块为 $(\\Lambda_{ii}, \\Lambda_{iB}, \\Lambda_{iR}, \\Lambda_{BB}, \\Lambda_{BR}, \\Lambda_{RR})$。\n\n推导在给定马尔可夫毯变量的条件下 $X_{i}$ 的最小均方误差 (MMSE) 估计器 $\\widehat{x}_{i}(x_{B}) := \\mathbb{E}[X_{i} \\mid X_{B} = x_{B}]$，并将其表示为一个仅依赖于 $\\Lambda_{ii}$、$\\Lambda_{iB}$ 和 $x_{B}$ 的闭式解析表达式。\n\n您的最终答案必须是 $\\widehat{x}_{i}(x_{B})$ 的单个闭式表达式，不带单位。不需要进行数值舍入。",
            "solution": "该问题关注的是一个无向网络系统中的系统边界和环境。马尔可夫毯构成了边界，它通过使得 $X_{i}$ 在给定边界变量 $X_{B}$ 的条件下与 $X_{R}$ 独立，从而将节点 $i$ 与环境的其余部分 $R$ 隔离开。我们分两部分进行。\n\nA部分。边界诱导的分解源于基本法则。根据概率的链式法则，对于将 $V$ 划分为三个不相交子集 $\\{i\\}$、$B$ 和 $R$ 的任意情况，我们有\n$$\nP(x) = P(x_{B}) \\, P(x_{i}, x_{R} \\mid x_{B}) = P(x_{B}) \\, P(x_{i} \\mid x_{B}, x_{R}) \\, P(x_{R} \\mid x_{B}).\n$$\n根据马尔可夫毯的定义性质，$X_{i} \\perp X_{R} \\mid X_{B}$，这意味着\n$$\nP(x_{i} \\mid x_{B}, x_{R}) = P(x_{i} \\mid x_{B}).\n$$\n将此等式代入链式法则分解中，得到\n$$\nP(x) = P(x_{B}) \\, P(x_{i} \\mid x_{B}) \\, P(x_{R} \\mid x_{B}),\n$$\n这就是所需的边界分解。这表明马尔可夫毯是一个系统边界：内部变量 $X_{i}$ 在概率上仅通过边界 $X_{B}$ 与环境 $X_{R}$ 相互作用。\n\nB部分。我们现在在高斯马尔可夫随机场设定下推导一个仅依赖于马尔可夫毯的估计器。随机向量 $X$ 是零均值高斯分布，其密度为\n$$\nP(x) \\propto \\exp\\!\\left( -\\tfrac{1}{2} \\, x^{\\top} \\Lambda \\, x \\right),\n$$\n其中 $\\Lambda$ 是一个对称正定精度矩阵，其稀疏性与无向图 $G$ 匹配。将 $x$ 划分为 $x = (x_{i}, x_{B}, x_{R})$，并用分块坐标写出二次型：\n$$\nx^{\\top} \\Lambda x\n= \n\\begin{pmatrix}\nx_{i}  x_{B}^{\\top}  x_{R}^{\\top}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\Lambda_{ii}  \\Lambda_{iB}  \\Lambda_{iR} \\\\\n\\Lambda_{Bi}  \\Lambda_{BB}  \\Lambda_{BR} \\\\\n\\Lambda_{Ri}  \\Lambda_{RB}  \\Lambda_{RR} \n\\end{pmatrix}\n\\begin{pmatrix}\nx_{i} \\\\ x_{B} \\\\ x_{R}\n\\end{pmatrix}.\n$$\n展开包含 $x_{i}$ 的项，\n$$\nx^{\\top} \\Lambda x\n=\n\\Lambda_{ii} x_{i}^{2} + 2 x_{i} \\left( \\Lambda_{iB} x_{B} + \\Lambda_{iR} x_{R} \\right) + \\text{与 } x_{i} \\text{ 无关的项}.\n$$\n条件密度 $P(x_{i} \\mid x_{B}, x_{R})$ 与这个关于 $x_{i}$ 的二次型的负二分之一的指数成正比，这是一个一元高斯分布，其精度（逆方差）为 $\\Lambda_{ii}$，线性系数为 $\\Lambda_{iB} x_{B} + \\Lambda_{iR} x_{R}$。通过配方法，条件均值为\n$$\n\\mathbb{E}[X_{i} \\mid X_{B} = x_{B}, X_{R} = x_{R}]\n= - \\Lambda_{ii}^{-1} \\left( \\Lambda_{iB} x_{B} + \\Lambda_{iR} x_{R} \\right).\n$$\n根据与 $G$ 一致的 $\\Lambda$ 的稀疏性质，对于 $r \\in R$，只要 $(i,r) \\notin E$，我们就有 $\\Lambda_{ir} = 0$。由于在无向图中，根据 $B$ 作为邻居集（马尔可夫毯）的构造，$R$ 只包含 $i$ 的非邻居节点，因此 $\\Lambda_{iR} = 0$。因此，\n$$\n\\mathbb{E}[X_{i} \\mid X_{B} = x_{B}, X_{R} = x_{R}]\n= - \\Lambda_{ii}^{-1} \\Lambda_{iB} x_{B}.\n$$\n此外，边界诱导的条件独立性 $X_{i} \\perp X_{R} \\mid X_{B}$ 意味着\n$$\n\\mathbb{E}[X_{i} \\mid X_{B} = x_{B}] = \\mathbb{E}[X_{i} \\mid X_{B} = x_{B}, X_{R} = x_{R}]\n$$\n对于任意 $x_{R}$ 成立，因此仅使用马尔可夫毯变量的最小均方误差 (MMSE) 估计器是相同的表达式：\n$$\n\\widehat{x}_{i}(x_{B}) := \\mathbb{E}[X_{i} \\mid X_{B} = x_{B}]\n= - \\Lambda_{ii}^{-1} \\Lambda_{iB} x_{B}.\n$$\n该估计器仅依赖于精度子块 $\\Lambda_{ii}$ 和 $\\Lambda_{iB}$ 以及观测到的马尔可夫毯值 $x_{B}$，从而将马尔可夫毯操作化为系统变量 $X_{i}$ 与其环境之间的预测边界。",
            "answer": "$$\\boxed{-\\Lambda_{ii}^{-1}\\,\\Lambda_{iB}\\,x_{B}}$$"
        },
        {
            "introduction": "正确界定系统边界对于得出有效的因果结论至关重要。如果边界设置得过于狭窄，忽略了环境中关键的混杂变量（confounder），我们可能会观察到具有误导性的、甚至是自相矛盾的关联。本练习将通过一个经典的辛普森悖论（Simpson's paradox）案例，让您亲手实践如何通过扩展系统边界、运用因果推断的调整方法来揭示真实的因果效应。",
            "id": "4306410",
            "problem": "一名研究人员在一个由两个环境分层 $S \\in \\{A,B\\}$ 组成的群体中研究一个二元处理 $T \\in \\{0,1\\}$ 和一个二元结果 $Y \\in \\{0,1\\}$。最初，系统边界排除了 $S$，只考虑了 $T$ 和 $Y$ 之间的总体关联。后来，边界被扩展以明确包含 $S$ 及其因果关系。相关的结构关系由一个有向无环图 (DAG) 表示，其箭头为 $S \\rightarrow T$、$S \\rightarrow Y$ 和 $T \\rightarrow Y$，这与 $S$ 存在混杂效应的情况一致。\n\n以下观测数量通过经验得到了良好估计：\n- 层内条件结果率：\n  - $P(Y=1 \\mid T=1,S=A) = 0.95$， $P(Y=1 \\mid T=0,S=A) = 0.90$。\n  - $P(Y=1 \\mid T=1,S=B) = 0.35$， $P(Y=1 \\mid T=0,S=B) = 0.30$。\n- 目标群体中的分层分布：\n  - $P(S=A) = 0.5$， $P(S=B) = 0.5$。\n- 按分层观测到的处理选择情况：\n  - $P(S=A \\mid T=1) = 0.1$， $P(S=B \\mid T=1) = 0.9$。\n  - $P(S=A \\mid T=0) = 0.9$， $P(S=B \\mid T=0) = 0.1$。\n\n您可以假设存在一个结构因果模型 (SCM)，其中干预 $\\mathrm{do}(T=t)$ 将 $T$ 设置为 $t$ 并切断所有指向 $T$ 的因果箭头，同时保持 $S$ 的分布不变。反事实结果用 $Y_t$ 表示，因果效应根据干预分布 $P(Y \\mid \\mathrm{do}(T=t))$ 定义。全概率定律和 DAG 的图示推论均适用。\n\n鉴于以上信息，总体关联 $P(Y=1 \\mid T=1)$ 与 $P(Y=1 \\mid T=0)$ 表现出辛普森悖论，与层内比较相比发生了逆转。在包含 $S$ 的扩展系统边界下，请选择一个选项，该选项通过提供正确的形式化表达式和根据所提供数据计算出的因果风险差异 $P(Y=1 \\mid \\mathrm{do}(T=1)) - P(Y=1 \\mid \\mathrm{do}(T=0))$ 的正确数值，从而正确地构建反事实来展示悖论是如何被解决的。\n\n选项：\n- A. $P(Y=1 \\mid T=1) - P(Y=1 \\mid T=0) = \\left(0.1 \\cdot 0.95 + 0.9 \\cdot 0.35\\right) - \\left(0.9 \\cdot 0.90 + 0.1 \\cdot 0.30\\right) = 0.41 - 0.84 = -0.43$。\n\n- B. $P(Y=1 \\mid \\mathrm{do}(T=1)) = \\sum_{s \\in \\{A,B\\}} P(Y=1 \\mid T=1,S=s)\\,P(S=s \\mid T=1)$ 和 $P(Y=1 \\mid \\mathrm{do}(T=0)) = \\sum_{s \\in \\{A,B\\}} P(Y=1 \\mid T=0,S=s)\\,P(S=s \\mid T=0)$，得出 $0.41 - 0.84 = -0.43$。\n\n- C. $P(Y=1 \\mid \\mathrm{do}(T=1)) = \\sum_{s \\in \\{A,B\\}} P(Y=1 \\mid T=1,S=s)\\,P(S=s) = 0.5 \\cdot 0.95 + 0.5 \\cdot 0.35 = 0.65$，和 $P(Y=1 \\mid \\mathrm{do}(T=0)) = \\sum_{s \\in \\{A,B\\}} P(Y=1 \\mid T=0,S=s)\\,P(S=s) = 0.5 \\cdot 0.90 + 0.5 \\cdot 0.30 = 0.60$，因此风险差异为 $0.65 - 0.60 = 0.05$。\n\n- D. $P(Y=1 \\mid \\mathrm{do}(T=1)) - P(Y=1 \\mid \\mathrm{do}(T=0)) = \\left(0.95 - 0.90\\right) + \\left(0.35 - 0.30\\right) = 0.10$。",
            "solution": "用户希望我解决一个在因果关系和结构因果模型背景下关于辛普森悖论的问题。\n\n我的角色是成为一名严谨的STEM教授。这意味着我必须首先严格验证问题陈述。\n\n**1. 问题验证**\n\n让我们分解问题陈述并提取所有给定条件。\n\n**步骤1：提取给定条件**\n\n- **系统变量**：\n    - 二元处理：$T \\in \\{0,1\\}$\n    - 二元结果：$Y \\in \\{0,1\\}$\n    - 二元环境分层：$S \\in \\{A,B\\}$\n\n- **因果结构**：\n    - 由带有箭头的有向无环图 (DAG) 表示：\n        - $S \\rightarrow T$ (S 是 T 的原因，即存在混杂)\n        - $S \\rightarrow Y$ (S 是 Y 的原因，即存在混杂)\n        - $T \\rightarrow Y$ (T 是 Y 的原因，是我们关心的直接效应)\n    - 该结构意味着 S 是 T 和 Y 的共同原因，使其成为一个混杂因素。\n\n- **观测数量（已得到良好估计）**：\n    - **层内条件结果率**：\n        - $P(Y=1 \\mid T=1,S=A) = 0.95$\n        - $P(Y=1 \\mid T=0,S=A) = 0.90$\n        - $P(Y=1 \\mid T=1,S=B) = 0.35$\n        - $P(Y=1 \\mid T=0,S=B) = 0.30$\n    - **目标群体中的分层分布**：\n        - $P(S=A) = 0.5$\n        - $P(S=B) = 0.5$\n    - **按分层观测到的处理选择**：\n        - $P(S=A \\mid T=1) = 0.1$\n        - $P(S=B \\mid T=1) = 0.9$\n        - $P(S=A \\mid T=0) = 0.9$\n        - $P(S=B \\mid T=0) = 0.1$\n\n- **假设与定义**：\n    - 假设存在一个结构因果模型 (SCM)。\n    - 干预 $\\mathrm{do}(T=t)$ 将 T 设置为 t，并切断所有指向 T 的因果箭头（即切断 $S \\rightarrow T$ 箭头）。\n    - 干预不改变 S 的分布。这与 DAG 一致，因为 T 不是 S 的原因。\n    - 反事实结果用 $Y_t$ 表示。\n    - 因果效应由干预分布 $P(Y \\mid \\mathrm{do}(T=t))$ 定义。\n    - 全概率定律和 DAG 的图示推论均适用。\n\n- **核心问题任务**：\n    - 问题陈述，总体关联 $P(Y=1 \\mid T=1)$ 与 $P(Y=1 \\mid T=0)$ 表现出辛普森悖论。\n    - 我需要选择正确构建反事实以展示悖论如何被解决的选项。\n    - 这涉及为因果风险差异 $P(Y=1 \\mid \\mathrm{do}(T=1)) - P(Y=1 \\mid \\mathrm{do}(T=0))$ 找到正确的形式化表达式和数值。\n\n**步骤2：使用提取的给定条件进行验证**\n\n现在，我将根据标准检查其有效性。\n\n- **科学依据**：该问题植根于因果推断、统计学和网络科学（特别是复杂系统）等成熟领域。DAG、SCM、do-算子、辛普森悖论和混杂等概念都是标准且严谨的。该问题是用于阐明这些概念的经典例子。不存在伪科学或有争议的主张。\n\n- **适定的**：该问题要求计算一个特定量，即因果风险差异，并提供了足够的计算数据。因果结构由 DAG 明确定义。SCM 的假设和 $\\mathrm{do}$-算子的定义都是标准的。目标是明确的。应该存在唯一解。\n    - 让我仔细检查一下所提供的观测数量是否一致。\n    - 我们有 $P(S=A \\mid T=t)$ 和 $P(S=B \\mid T=t)$。检查：$P(S=A \\mid T=1) + P(S=B \\mid T=1) = 0.1 + 0.9 = 1$。这是一致的。$P(S=A \\mid T=0) + P(S=B \\mid T=0) = 0.9 + 0.1 = 1$。这也是一致的。\n    - 给定 $P(S=A)=0.5$ 和 $P(S=B)=0.5$。\n    - 我们能从给定信息中推导出 $P(T=1)$ 和 $P(T=0)$ 吗？\n    - 使用全概率定律：\n        - $P(S=A) = P(S=A \\mid T=1)P(T=1) + P(S=A \\mid T=0)P(T=0)$\n        - 设 $p_T = P(T=1)$。则 $P(T=0) = 1-p_T$。\n        - $0.5 = (0.1) \\cdot p_T + (0.9) \\cdot (1-p_T)$\n        - $0.5 = 0.1 p_T + 0.9 - 0.9 p_T$\n        - $0.5 = 0.9 - 0.8 p_T$\n        - $0.8 p_T = 0.4$\n        - $p_T = 0.4 / 0.8 = 0.5$。\n    - 所以，$P(T=1) = 0.5$ 且 $P(T=0) = 0.5$。\n    - 让我们用 $P(S=B)$ 来检验一下：\n        - $P(S=B) = P(S=B \\mid T=1)P(T=1) + P(S=B \\mid T=0)P(T=0)$\n        - $0.5 = (0.9) \\cdot (0.5) + (0.1) \\cdot (0.5)$\n        - $0.5 = 0.45 + 0.05$\n        - $0.5 = 0.5$。\n    - 所提供的概率在内部是一致的。这是一个非常好的迹象。该问题构建得很好。\n\n- **客观性**：语言清晰、精确且客观。它定义了所有术语（$T$、$Y$、$S$、DAG、do-算子）并提供了数值数据。没有主观陈述。\n\n让我们检查是否存在特定的无效性缺陷：\n1. **科学上不健全**：否，该问题基于标准的因果推断理论。\n2. **不可形式化**：否，这是一个形式化的数学问题。它与复杂系统中的系统边界和环境主题直接相关，因为它讨论了扩展边界以包含混杂因素 S。\n3. **不完整/矛盾**：否，如上所示，数据是完整且一致的。我们有足够的信息来计算关联效应和因果效应。\n4. **不切实际/不可行**：概率都在 0 和 1 之间。它们代表了一个合理的、尽管是风格化的场景。\n5. **不适定**：问题非常具体，要求一个唯一的量。混杂因素 S 的存在使问题有意义。\n6. **伪深刻/琐碎**：该问题是关于混杂以及关联与因果之间差异的一个经典、非琐碎的例证。它没有以一种将核心问题琐碎化的方式进行人为设计或过分简化。\n7. **外部可验证性**：该问题是一个数学和逻辑问题，完全可以在其框架内进行验证。\n\n**步骤3：结论与行动**\n\n问题陈述是有效的。这是一个在因果推断中形式良好、一致且标准的问题。我将进入解答阶段。\n\n---\n\n**解答阶段**\n\n任务是计算因果风险差异 $P(Y=1 \\mid \\mathrm{do}(T=1)) - P(Y=1 \\mid \\mathrm{do}(T=0))$，并找出正确的选项。\n\n首先，让我们验证辛普森悖论的说法。这需要计算总体的观测关联 $P(Y=1 \\mid T=1) - P(Y=1 \\mid T=0)$。\n\n**1. 计算总体观测关联**\n\n问题陈述，总体关联与层内比较相比发生了逆转。让我们检查一下。\n\n首先，层内风险差异：\n- 分层 A：$P(Y=1 \\mid T=1, S=A) - P(Y=1 \\mid T=0, S=A) = 0.95 - 0.90 = 0.05$。（正相关）\n- 分层 B：$P(Y=1 \\mid T=1, S=B) - P(Y=1 \\mid T=0, S=B) = 0.35 - 0.30 = 0.05$。（正相关）\n在两个分层中，处理都与结果概率增加 0.05 相关联。\n\n现在，计算总体（边际）关联 $P(Y=1 \\mid T=1)$ 和 $P(Y=1 \\mid T=0)$。我们使用全概率定律，以 S 为条件：\n\n$P(Y=1 \\mid T=1) = \\sum_{s \\in \\{A,B\\}} P(Y=1 \\mid T=1, S=s)P(S=s \\mid T=1)$\n使用给定值：\n$P(Y=1 \\mid T=1) = P(Y=1 \\mid T=1, S=A)P(S=A \\mid T=1) + P(Y=1 \\mid T=1, S=B)P(S=B \\mid T=1)$\n$P(Y=1 \\mid T=1) = (0.95)(0.1) + (0.35)(0.9)$\n$P(Y=1 \\mid T=1) = 0.095 + 0.315 = 0.41$\n\n$P(Y=1 \\mid T=0) = \\sum_{s \\in \\{A,B\\}} P(Y=1 \\mid T=0, S=s)P(S=s \\mid T=0)$\n使用给定值：\n$P(Y=1 \\mid T=0) = P(Y=1 \\mid T=0, S=A)P(S=A \\mid T=0) + P(Y=1 \\mid T=0, S=B)P(S=B \\mid T=0)$\n$P(Y=1 \\mid T=0) = (0.90)(0.9) + (0.30)(0.1)$\n$P(Y=1 \\mid T=0) = 0.81 + 0.03 = 0.84$\n\n总体风险差异（观测的）是：\n$P(Y=1 \\mid T=1) - P(Y=1 \\mid T=0) = 0.41 - 0.84 = -0.43$。\n\n这是一个负相关。由于层内关联均为正 (+0.05)，我们证实了辛普森悖论的存在。与分层特定的关联相比，总体关联发生了逆转。\n\n从数据中可以清楚地看出悖论的原因：\n- 处理 $T=1$ 与分层 B 强相关 ($P(S=B|T=1)=0.9$)，该层的结果率较低 (约 0.3)。\n- 对照 $T=0$ 与分层 A 强相关 ($P(S=A|T=0)=0.9$)，该层的结果率较高 (约 0.9)。\n所以，$P(Y=1|T=1)$ 与 $P(Y=1|T=0)$ 的比较并非同类比较。它主要是在比较分层 B 中个体（接受处理者）的结果与分层 A 中个体（未接受处理者）的结果。由于分层 A 的基线风险要高得多，这种由 S 引起的混杂造成了处理有害的假象。\n\n**2. 计算因果风险差异**\n\n为了解决这个悖论并找到真实的因果效应，我们必须“调整”或“控制”混杂因素 S。在 SCM 框架中，实现这一点的正式方法是计算干预分布 $P(Y=1 \\mid \\mathrm{do}(T=1))$ 和 $P(Y=1 \\mid \\mathrm{do}(T=0))$。\n\nDAG 是 $S \\rightarrow T$、$S \\rightarrow Y$ 和 $T \\rightarrow Y$。在这里，S 是一个满足后门准则的混杂因素，可用于调整 T 对 Y 的效应。调整公式（也称为后门调整公式或标准化）是：\n$$P(Y=1 \\mid \\mathrm{do}(T=t)) = \\sum_{s} P(Y=1 \\mid T=t, S=s)P(S=s)$$\n\n这个公式构建了一个反事实场景。它提出这样一个问题：如果我们强制每个人都接受处理 $T=t$，但混杂因素 S 的分布保持其在群体中的自然状态，即 $P(S=s)$，那么 $Y=1$ 的概率会是多少？\n\n让我们为 $t=1$ 和 $t=0$ 计算这个值。\n\n对于 $t=1$：\n$P(Y=1 \\mid \\mathrm{do}(T=1)) = \\sum_{s \\in \\{A,B\\}} P(Y=1 \\mid T=1, S=s)P(S=s)$\n$P(Y=1 \\mid \\mathrm{do}(T=1)) = P(Y=1 \\mid T=1, S=A)P(S=A) + P(Y=1 \\mid T=1, S=B)P(S=B)$\n使用给定值：\n$P(Y=1 \\mid \\mathrm{do}(T=1)) = (0.95)(0.5) + (0.35)(0.5)$\n$P(Y=1 \\mid \\mathrm{do}(T=1)) = 0.475 + 0.175 = 0.65$\n\n对于 $t=0$：\n$P(Y=1 \\mid \\mathrm{do}(T=0)) = \\sum_{s \\in \\{A,B\\}} P(Y=1 \\mid T=0, S=s)P(S=s)$\n$P(Y=1 \\mid \\mathrm{do}(T=0)) = P(Y=1 \\mid T=0, S=A)P(S=A) + P(Y=1 \\mid T=0, S=B)P(S=B)$\n使用给定值：\n$P(Y=1 \\mid \\mathrm{do}(T=0)) = (0.90)(0.5) + (0.30)(0.5)$\n$P(Y=1 \\mid \\mathrm{do}(T=0)) = 0.45 + 0.15 = 0.60$\n\n现在，因果风险差异（也称为平均因果效应，ACE，或平均处理效应，ATE）是：\n$P(Y=1 \\mid \\mathrm{do}(T=1)) - P(Y=1 \\mid \\mathrm{do}(T=0)) = 0.65 - 0.60 = 0.05$。\n\n这个因果效应是正的，与层内关联的符号相匹配。这就是对悖论的解决。粗略的观测关联是 -0.43，但因果效应是 +0.05。这种逆转是由 S 的混杂造成的。\n\n这个结果也可以看作是分层特定风险差异的加权平均值：\n因果风险差异 $ = \\sum_s [P(Y=1|T=1,S=s) - P(Y=1|T=0,S=s)] P(S=s)$\n因果风险差异 $ = (0.95 - 0.90)P(S=A) + (0.35 - 0.30)P(S=B)$\n因果风险差异 $ = (0.05)(0.5) + (0.05)(0.5)$\n因果风险差异 $ = 0.025 + 0.025 = 0.05$。\n这证实了结果。\n\n**3. 评估选项**\n\n现在，我将根据我推导出的解决方案来评估每个选项。\n\n- **选项 A**：$P(Y=1 \\mid T=1) - P(Y=1 \\mid T=0) = \\left(0.1 \\cdot 0.95 + 0.9 \\cdot 0.35\\right) - \\left(0.9 \\cdot 0.90 + 0.1 \\cdot 0.30\\right) = 0.41 - 0.84 = -0.43$。\n    - 所使用的公式是 $P(Y=1 \\mid T=t) = \\sum_s P(Y=1|T=t,S=s)P(S=s|T=t)$。这正确地计算了*观测*或*关联*风险差异，但不是*因果*风险差异。问题要求的是解决悖论的反事实。这个选项呈现了悖论本身，而不是其解决方案。\n    - **结论：错误。**\n\n- **选项 B**：$P(Y=1 \\mid \\mathrm{do}(T=1)) = \\sum_{s \\in \\{A,B\\}} P(Y=1 \\mid T=1,S=s)\\,P(S=s \\mid T=1)$ 和 $P(Y=1 \\mid \\mathrm{do}(T=0)) = \\sum_{s \\in \\{A,B\\}} P(Y=1 \\mid T=0,S=s)\\,P(S=s \\mid T=0)$，得出 $0.41 - 0.84 = -0.43$。\n    - 这个选项为干预概率提供了一个不正确的形式化表达式。它将因果量 $P(Y=1 \\mid \\mathrm{do}(T=t))$ 等同于观测量 $P(Y=1 \\mid T=t)$。正确的后门调整公式要求通过混杂因素的边际概率 $P(S=s)$ 进行加权，而不是条件概率 $P(S=s \\mid T=t)$。使用 $P(S=s \\mid T=t)$ 正是引入混杂偏误的原因。\n    - **结论：错误。**\n\n- **选项 C**：$P(Y=1 \\mid \\mathrm{do}(T=1)) = \\sum_{s \\in \\{A,B\\}} P(Y=1 \\mid T=1,S=s)\\,P(S=s) = 0.5 \\cdot 0.95 + 0.5 \\cdot 0.35 = 0.65$，和 $P(Y=1 \\mid \\mathrm{do}(T=0)) = \\sum_{s \\in \\{A,B\\}} P(Y=1 \\mid T=0,S=s)\\,P(S=s) = 0.5 \\cdot 0.90 + 0.5 \\cdot 0.30 = 0.60$，因此风险差异为 $0.65 - 0.60 = 0.05$。\n    - 这个选项为因果效应提供了正确的形式化表达式，即后门调整公式（或标准化）。它通过将分层特定的结果按分层的边际流行率 $P(S=s)$ 进行加权，正确地计算了干预概率。数值计算是准确的，得出的因果风险差异 0.05 是正确的。这个计算通过展示处理的真实、无混杂的正效应，解决了这个悖论。\n    - **结论：正确。**\n\n- **选项 D**：$P(Y=1 \\mid \\mathrm{do}(T=1)) - P(Y=1 \\mid \\mathrm{do}(T=0)) = \\left(0.95 - 0.90\\right) + \\left(0.35 - 0.30\\right) = 0.10$。\n    - 这个表达式错误地将分层特定的风险差异相加。平均因果效应是这些差异的*加权平均值*，而不是它们的简单和。权重必须是分层的概率 $P(S=s)$。公式 $\\sum_s [P(Y=1|T=1,S=s) - P(Y=1|T=0,S=s)]$ 在因果理论中没有依据，并且在维度上是可疑的，因为它会随着分层数量的增加而增长。\n    - **结论：错误。**",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "在处理大规模动态系统时，对整个系统进行建模往往是不可行的。因此，我们需要找到一个“充分”的系统边界，以构建一个既能准确捕捉目标行为又能显著降低计算复杂度的有效模型。本编程练习将引导您实现一种模型降维方法，通过迭代寻找最小充分边界，将抽象的理论概念转化为具体的计算实践。",
            "id": "4306421",
            "problem": "给定一个有限的、加权的、无向图，其节点集为 $\\{1,2,\\dots,n\\}$，权重为非负对称权重 $W_{ij}=W_{ji}\\ge 0$。考虑在 $\\mathbb{R}^n$ 上的线性时不变动力学，由常微分方程 (ODE) $d\\mathbf{x}/dt = A \\mathbf{x}$ 定义，其中 $A = W - D$，$D$ 是一个对角矩阵，其元素为 $D_{ii} = \\sum_{j=1}^n W_{ij} + \\delta_i$。量 $\\delta_i>0$ 是各节点的衰减率。设初始条件为 $\\mathbf{x}(0) = \\mathbf{e}_{i^\\star}$，这是以选定的目标节点 $i^\\star \\in \\{1,\\dots,n\\}$ 为中心的标准基向量。定义在时间 $T>0$ 时的目标可观测量为 $Y(T) = \\mathbf{e}_{i^\\star}^\\top e^{A T} \\mathbf{e}_{i^\\star}$，其中 $e^{A T}$ 表示矩阵指数。\n\n对于一个非负整数半径 $r$，将边界集 $B(r)$ 定义为与 $i^\\star$ 的无权最短路径距离至多为 $r$ 的节点集合。令 $E(r)$ 表示环境，即 $B(r)$ 在 $\\{1,\\dots,n\\}$ 中的补集。将 $A$ 相应地分块为\n$$\nA = \\begin{pmatrix}\nA_{BB}  A_{BE} \\\\\nA_{EB}  A_{EE}\n\\end{pmatrix}\n$$\n其中这些块对应于边界 $B(r)$ 和环境 $E(r)$。在标准的绝热消除（快环境）近似下，环境受限于边界，满足 $\\mathbf{x}_E \\approx -A_{EE}^{-1} A_{EB} \\mathbf{x}_B$，这在边界上导出有效生成元\n$$\nA_{\\text{eff}}(r) = A_{BB} - A_{BE} A_{EE}^{-1} A_{EB}.\n$$\n将可观测量近似定义为\n$$\n\\widehat{Y}(T;r) = \\mathbf{e}_{i^\\star,B}^\\top e^{A_{\\text{eff}}(r) T} \\mathbf{e}_{i^\\star,B},\n$$\n其中 $\\mathbf{e}_{i^\\star,B}$ 表示标准基向量在由 $B(r)$ 索引的坐标上的限制。对于给定的误差容限 $\\epsilon>0$，如果 $|Y(T) - \\widehat{Y}(T;r)| \\le \\epsilon$，则边界 $B(r)$ 是充分的；如果在所有充分边界中其基数 $|B(r)|$ 最小，则它是最小的。\n\n您的任务是编写一个完整的程序，对下面的每个测试用例，计算最小充分边界基数 $|B(r^\\star)|$，其中\n$$\nr^\\star = \\min\\{r \\in \\{0,1,2,\\dots\\}: |Y(T) - \\widehat{Y}(T;r)| \\le \\epsilon\\}.\n$$\n如果在 $\\{0,1,2,\\dots,n-1\\}$ 中没有半径 $r$ 满足该不等式，则定义 $r^\\star = n-1$。\n\n下面所有图在计算最短路径时均是无权的，无论 $W$ 如何，并且节点标签使用基于1的索引。在所有情况下，用于分配衰减率和定义边界层的距离都是通过从 $i^\\star$ 出发的无权最短路径计算的。程序应实现以下测试套件：\n\n- 测试用例 1（具有三级衰减的单链）：\n    - 图：一个长度为 $n=12$ 的链，节点之间有边相连，对称权重为 $W_{i,i+1} = W_{i+1,i} = g$（对于 $i=1,\\dots,11$），其他 $W_{ij}=0$。\n    - 参数：$g=0.25$，目标节点 $i^\\star=6$，最终时间 $T=1.0$，容限 $\\epsilon=10^{-4}$。\n    - 衰减率：令 $d(i)$ 为从 $i^\\star$ 到 $i$ 的无权最短路径距离。设置\n      $\\delta_i = \\delta_{\\text{slow}}$ 如果 $d(i) \\le 1$，\n      $\\delta_i = \\delta_{\\text{medium}}$ 如果 $2 \\le d(i) \\le 3$，\n      且 $\\delta_i = \\delta_{\\text{fast}}$ 如果 $d(i) \\ge 4$，\n      其中 $\\delta_{\\text{slow}}=0.05$，$\\delta_{\\text{medium}}=0.20$，$\\delta_{\\text{fast}}=1.50$。\n\n- 测试用例 2（更长的链，更严格的容限）：\n    - 图：一个长度为 $n=20$ 的链，节点之间有边相连，对称权重为 $W_{i,i+1} = W_{i+1,i} = g$（对于 $i=1,\\dots,19$），其他 $W_{ij}=0$。\n    - 参数：$g=0.40$，目标节点 $i^\\star=10$，最终时间 $T=3.0$，容限 $\\epsilon=10^{-8}$。\n    - 衰减率：令 $d(i)$ 为从 $i^\\star$ 到 $i$ 的无权最短路径距离。设置\n      $\\delta_i = \\delta_{\\text{slow}}$ 如果 $d(i) \\le 1$，\n      $\\delta_i = \\delta_{\\text{medium}}$ 如果 $2 \\le d(i) \\le 4$，\n      且 $\\delta_i = \\delta_{\\text{fast}}$ 如果 $d(i) \\ge 5$，\n      其中 $\\delta_{\\text{slow}}=0.02$，$\\delta_{\\text{medium}}=0.10$，$\\delta_{\\text{fast}}=2.00$。\n\n- 测试用例 3（两个弱连接的链）：\n    - 图：由单个弱连接相连的两个不相交的链。链 A 长度为 8，位于节点 $1,\\dots,8$ 上，其中 $W_{i,i+1} = W_{i+1,i} = g_A$（对于 $i=1,\\dots,7$）。链 B 长度为 5，位于节点 $9,\\dots,13$ 上，其中 $W_{j,j+1} = W_{j+1,j} = g_B$（对于 $j=9,\\dots,12$）。一条权重为 $\\gamma$ 的跨边连接节点 8 和节点 9。所有其他 $W_{ij}=0$。\n    - 参数：$g_A=0.30$, $g_B=0.30$, $\\gamma=0.001$，目标节点 $i^\\star=4$，最终时间 $T=1.0$，容限 $\\epsilon=10^{-3}$。\n    - 衰减率：令 $d(i)$ 为在完整图（包括弱连接）中从 $i^\\star$ 到 $i$ 的无权最短路径距离。设置\n      $\\delta_i = \\delta_{\\text{slow}}$ 如果 $d(i) \\le 1$，\n      $\\delta_i = \\delta_{\\text{medium}}$ 如果 $2 \\le d(i) \\le 4$，\n      且 $\\delta_i = \\delta_{\\text{fast}}$ 如果 $d(i) \\ge 5$，\n      其中 $\\delta_{\\text{slow}}=0.05$, $\\delta_{\\text{medium}}=0.20$, $\\delta_{\\text{fast}}=1.20$。\n\n实现要求：\n- 通过矩阵指数 $e^{A T}$ 精确计算 $Y(T)$。\n- 对每个半径 $r=0,1,\\dots,n-1$，通过 $A_{\\text{eff}}(r) = A_{BB} - A_{BE} A_{EE}^{-1} A_{EB}$ 计算 $A_{\\text{eff}}(r)$。如果 $A_{EE}$ 是奇异或病态的，使用 Moore–Penrose 伪逆代替 $A_{EE}^{-1}$。\n- 计算 $\\widehat{Y}(T;r)$ 和误差 $|Y(T) - \\widehat{Y}(T;r)|$；选择使误差至多为 $\\epsilon$ 的最小 $r$。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3]$），每个条目是相应测试用例的最小充分边界基数 $|B(r^\\star)|$。\n\n所有量都是无量纲的；不出现角度；没有百分比。最终输出应为一个整数列表。",
            "solution": "该问题要求我们为一个图上的线性动力学系统确定最小的充分边界大小。这是一个模型简化问题，我们用一个定义在子区域（“边界”）上的更小的有效模型来近似一个大系统。此近似的充分性由特定可观测量中的误差来衡量，我们寻求满足给定误差容限的最小边界。\n\n对于每个测试用例，总体方法包括以下步骤：\n1.  **系统定义**：构建表示系统的数学对象：权重矩阵 $W$，各节点衰减率 $\\delta_i$，以及完整的系统动力学矩阵 $A = W - D$，其中 $D_{ii} = (\\sum_j W_{ij}) + \\delta_i$。\n2.  **最短路径计算**：确定从目标节点 $i^\\star$到图中每个其他节点 $i$ 的无权最短路径距离 $d(i)$。这通过广度优先搜索 (BFS) 算法完成，该算法对于无权图是最优的。这些距离用于定义衰减率 $\\delta_i$ 和同心边界集 $B(r)$。\n3.  **精确可观测量计算**：计算目标可观测量 $Y(T) = \\mathbf{e}_{i^\\star}^\\top e^{A T} \\mathbf{e}_{i^\\star}$ 的“精确”值。这需要计算完整系统矩阵 $A$ 乘以时间 $T$ 后的矩阵指数 $e^{A T}$。结果 $Y(T)$ 是该矩阵指数中对应于目标节点 $i^\\star$ 的对角线元素。\n4.  **迭代搜索最小半径**：遍历可能的边界半径 $r = 0, 1, 2, \\dots, n-1$。对于每个半径 $r$：\n    a.  **系统划分**：将所有节点的集合 $\\{1, \\dots, n\\}$ 划分为一个边界集 $B(r) = \\{i \\mid d(i) \\le r\\}$ 和一个环境集 $E(r) = \\{i \\mid d(i) > r\\}$。系统矩阵 $A$ 相应地被划分为块 $A_{BB}$, $A_{BE}$, $A_{EB}$ 和 $A_{EE}$。\n    b.  **有效模型构建**：使用绝热消除公式计算边界动力学的有效生成元：$A_{\\text{eff}}(r) = A_{BB} - A_{BE} A_{EE}^{-1} A_{EB}$。为确保数值稳定性并处理环境块 $A_{EE}$ 可能奇异的情况，使用其 Moore-Penrose 伪逆代替标准逆 $A_{EE}^{-1}$。如果环境集 $E(r)$ 为空，则有效模型就是限制在边界上的完整系统，即 $A_{\\text{eff}}(r) = A_{BB} = A$，此时近似变为精确。\n    c.  **近似可观测量计算**：计算近似可观测量 $\\widehat{Y}(T;r) = \\mathbf{e}_{i^\\star,B}^\\top e^{A_{\\text{eff}}(r) T} \\mathbf{e}_{i^\\star,B}$。这涉及对较小的有效矩阵 $A_{\\text{eff}}(r)$ 进行矩阵求幂，并提取在边界的局部索引中对应于目标节点 $i^\\star$ 的对角线元素。\n    d.  **误差评估**：计算绝对误差 $|Y(T) - \\widehat{Y}(T;r)|$ 并与指定的容限 $\\epsilon$ 进行比较。\n5.  **结果确定**：第一个使误差小于或等于 $\\epsilon$ 的半径 $r^\\star$ 即为最小充分半径。由于边界集大小 $|B(r)|$ 是半径 $r$ 的单调非递减函数，因此最小化 $r$ 等同于最小化边界基数。该测试用例的最终结果是这个最小充分边界的基数 $|B(r^\\star)|$。\n\n此过程系统地应用于指定的三个测试用例。所有涉及矩阵和向量的计算都使用 `numpy` 库执行。矩阵指数通过 `scipy.linalg.expm` 计算，伪逆通过 `numpy.linalg.pinv` 计算。问题中给出的基于1的节点索引在内部计算中被转换为基于0的索引。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm, pinv\nfrom collections import deque\n\ndef _get_shortest_paths_bfs(n, adj_list, start_node_0):\n    \"\"\"Computes unweighted shortest-path distances from a start node using BFS.\"\"\"\n    distances = np.full(n, -1, dtype=int)\n    queue = deque([(start_node_0, 0)])\n    distances[start_node_0] = 0\n\n    while queue:\n        u, d = queue.popleft()\n        for v in adj_list[u]:\n            if distances[v] == -1:\n                distances[v] = d + 1\n                queue.append((v, d + 1))\n    \n    return distances\n\ndef _process_case(n, i_star, T, epsilon, adj_list, W, delta_rules):\n    \"\"\"\n    Solves for the minimal sufficient boundary cardinality for a single test case.\n    \"\"\"\n    # 1. Use 0-based indexing for all internal calculations\n    i_star_0 = i_star - 1\n\n    # 2. Get shortest path distances from the target node\n    distances = _get_shortest_paths_bfs(n, adj_list, i_star_0)\n\n    # 3. Construct the delta vector based on distance rules\n    deltas = np.zeros(n)\n    max_dist = np.max(distances)\n    for min_d, max_d, val in delta_rules:\n        # Handle maximum distance for open-ended rules\n        effective_max_d = max_dist if max_d >= n else max_d\n        indices = np.where((distances >= min_d)  (distances = effective_max_d))[0]\n        deltas[indices] = val\n\n    # 4. Construct the full system matrix A\n    D = np.diag(np.sum(W, axis=1) + deltas)\n    A = W - D\n\n    # 5. Compute the exact observable Y(T)\n    expm_AT = expm(A * T)\n    Y_T = expm_AT[i_star_0, i_star_0]\n\n    # 6. Iterate through radii r = 0, 1, ..., n-1 to find the minimal sufficient radius\n    for r in range(n):\n        # 7. Define boundary B(r) and environment E(r) index sets\n        B_indices = np.where(distances = r)[0]\n        E_indices = np.where(distances > r)[0]\n        \n        # Sort for consistent matrix slicing\n        B_indices.sort()\n        E_indices.sort()\n\n        Y_hat_T_r = 0.0 # Initialize approximated observable\n        \n        if E_indices.size == 0:\n            # If the environment is empty, the approximation is exact.\n            Y_hat_T_r = Y_T\n        else:\n            # 8. Partition matrix A and compute the effective generator A_eff\n            A_BB = A[np.ix_(B_indices, B_indices)]\n            A_BE = A[np.ix_(B_indices, E_indices)]\n            A_EB = A[np.ix_(E_indices, B_indices)]\n            A_EE = A[np.ix_(E_indices, E_indices)]\n\n            A_eff = A_BB - A_BE @ pinv(A_EE) @ A_EB\n            \n            # Find the index of the target node within the boundary set\n            i_star_B_idx = np.where(B_indices == i_star_0)[0][0]\n            \n            # 9. Compute the approximate observable Y_hat(T;r)\n            expm_A_eff_T = expm(A_eff * T)\n            Y_hat_T_r = expm_A_eff_T[i_star_B_idx, i_star_B_idx]\n\n        # 10. Check the error condition\n        error = abs(Y_T - Y_hat_T_r)\n        if error = epsilon:\n            # Found the minimal sufficient radius r*; return its cardinality\n            return len(B_indices)\n\n    # This part should not be reached because for r large enough, E is empty,\n    # error is 0, and the condition is met.\n    return n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = []\n\n    # Test Case 1\n    n1 = 12\n    W1 = np.zeros((n1, n1))\n    adj1 = [[] for _ in range(n1)]\n    for i in range(n1 - 1):\n        W1[i, i + 1] = W1[i + 1, i] = 0.25\n        adj1[i].append(i + 1)\n        adj1[i+1].append(i)\n    case1_params = {\n        \"n\": n1, \"i_star\": 6, \"T\": 1.0, \"epsilon\": 1e-4,\n        \"adj_list\": adj1, \"W\": W1,\n        \"delta_rules\": [(0, 1, 0.05), (2, 3, 0.20), (4, n1, 1.50)]\n    }\n    test_cases.append(case1_params)\n\n    # Test Case 2\n    n2 = 20\n    W2 = np.zeros((n2, n2))\n    adj2 = [[] for _ in range(n2)]\n    for i in range(n2 - 1):\n        W2[i, i + 1] = W2[i + 1, i] = 0.40\n        adj2[i].append(i + 1)\n        adj2[i+1].append(i)\n    case2_params = {\n        \"n\": n2, \"i_star\": 10, \"T\": 3.0, \"epsilon\": 1e-8,\n        \"adj_list\": adj2, \"W\": W2,\n        \"delta_rules\": [(0, 1, 0.02), (2, 4, 0.10), (5, n2, 2.00)]\n    }\n    test_cases.append(case2_params)\n\n    # Test Case 3\n    n3 = 13\n    gA, gB, gamma = 0.30, 0.30, 0.001\n    W3 = np.zeros((n3, n3))\n    adj3 = [[] for _ in range(n3)]\n    # Chain A: nodes 1..8 (indices 0..7)\n    for i in range(7):\n        W3[i, i + 1] = W3[i + 1, i] = gA\n        adj3[i].append(i + 1)\n        adj3[i+1].append(i)\n    # Chain B: nodes 9..13 (indices 8..12)\n    for i in range(8, 12):\n        W3[i, i + 1] = W3[i + 1, i] = gB\n        adj3[i].append(i + 1)\n        adj3[i+1].append(i)\n    # Link: node 8 to 9 (indices 7 to 8)\n    W3[7, 8] = W3[8, 7] = gamma\n    adj3[7].append(8)\n    adj3[8].append(7)\n    case3_params = {\n        \"n\": n3, \"i_star\": 4, \"T\": 1.0, \"epsilon\": 1e-3,\n        \"adj_list\": adj3, \"W\": W3,\n        \"delta_rules\": [(0, 1, 0.05), (2, 4, 0.20), (5, n3, 1.20)]\n    }\n    test_cases.append(case3_params)\n\n    results = []\n    for case_params in test_cases:\n        result = _process_case(**case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}