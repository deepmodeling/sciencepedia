{
    "hands_on_practices": [
        {
            "introduction": "在任何网络分析流程中，验证输入数据的有效性是至关重要的第一步。此练习旨在实践如何对表征无向无环图的邻接矩阵 $A$ 实施基本的一致性检查。通过此练习 ，您将亲手实现验证邻接矩阵对称性及对角线元素为零的核心属性，并学会处理浮点数计算中常见的数值精度问题。",
            "id": "4291927",
            "problem": "考虑一个顶点集为 $V$（大小为 $n$）的有限图，并设 $A \\in \\mathbb{R}^{n \\times n}$ 为一个提议的邻接矩阵表示。根据定义，对于无向图，顶点之间的成对关系是对称的，并且不存在自环要求没有顶点与自身相邻。从这些核心定义可以得出，一个有效的无向无环图的邻接矩阵必须是方阵、对称的，并且对角线元素为零。在具有实数值条目的计算环境中，由于浮点表示，通常需要近似相等；因此，可以使用一个容差参数 $\\varepsilon > 0$ 来操作化等式检查。\n\n你的任务是实现一个程序，对每个提供的矩阵执行以下源自基本定义的一致性检查：\n- 验证 $A$ 是方阵，即对于某个整数 $n \\geq 1$，$A \\in \\mathbb{R}^{n \\times n}$。\n- 通过计算满足 $|a_{ij} - a_{ji}| > \\varepsilon$ 的无序顶点对 $\\{i,j\\}$（其中 $1 \\leq i  j \\leq n$）的数量，来量化对称性违规。\n- 通过计算满足 $|a_{ii}|  \\varepsilon$ 的索引 $i \\in \\{1,\\dots,n\\}$ 的数量，来量化对角线违规。\n\n如果一个矩阵不是方阵，则对称性和对角线违规计数是未定义的。在这种情况下，将方阵检查报告为假，并对两个违规计数使用整数 $-1$ 来表示未定义的值。\n\n对所有绝对值比较使用容差 $\\varepsilon = 10^{-9}$。\n\n实现上述逻辑，并将其应用于以下矩阵测试套件。每个矩阵被指定为一个实数值数组；行以方括号列表形式列出：\n- 测试用例 1：\n  [\n    [$0$, $1$, $0$],\n    [$1$, $0$, $1$],\n    [$0$, $1$, $0$]\n  ]\n- 测试用例 2：\n  [\n    [$0$, $2$, $0$],\n    [$2$, $1$, $3$],\n    [$0$, $3$, $0$]\n  ]\n- 测试用例 3：\n  [\n    [$0$, $1$, $0$],\n    [$0$, $0$, $1$],\n    [$0$, $1$, $0$]\n  ]\n- 测试用例 4：\n  [\n    [$1$, $1$, $0$],\n    [$0$, $0$, $0$],\n    [$0$, $0$, $0$]\n  ]\n- 测试用例 5：\n  [\n    [$0.0$]\n  ]\n- 测试用例 6：\n  [\n    [$1 \\times 10^{-12}$]\n  ]\n- 测试用例 7 (非方阵)：\n  [\n    [$0$, $1$, $0$],\n    [$1$, $0$, $1$]\n  ]\n- 测试用例 8：\n  [\n    [$0.0$, $1.0000000005$],\n    [$1.0$, $0.0$]\n  ]\n- 测试用例 9：\n  [\n    [$0.0$, $1.000000002$],\n    [$1.0$, $0.0$]\n  ]\n- 测试用例 10：\n  [\n    [$0$, $2.5$, $0$],\n    [$2.5$, $0$, $4.1$],\n    [$0$, $4.1$, $0$]\n  ]\n\n输出规范：\n- 对每个测试用例，生成一个形式为 $[s, c_{\\text{sym}}, c_{\\text{diag}}]$ 的列表，其中 $s$ 是一个布尔值，指示矩阵是否为方阵，$c_{\\text{sym}}$ 是对称性违规的整数计数，$c_{\\text{diag}}$ 是对角线违规的整数计数（当 $s$ 为假时，这两个计数均为 $-1$）。\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，形式为用方括号括起来的逗号分隔列表。具体来说，输出必须是结果列表的单行字符串表示，例如 $[r_1, r_2, \\dots, r_{10}]$，其中每个 $r_k$ 是上述的单个测试用例列表。",
            "solution": "目标是根据一个有限、无向、无环图的邻接矩阵所需的基本性质，来验证一个给定的矩阵 $A$。这些性质是：矩阵必须是方阵、对称的，并且对角线元素为零。验证将以计算方式执行，采用数值容差 $\\varepsilon = 10^{-9}$ 以考虑浮点数的不精确性。对于每个提供的矩阵，我们必须执行三个检查：方阵性、对称性违规和对角线违规。\n\n假设一个候选矩阵以二维实数数组的形式提供。我们用 $a_{ij}$ 表示其元素，其中 $i$ 是行索引，$j$ 是列索引。过程如下：\n\n1.  **方阵性验证**：邻接矩阵表示大小为 $n$ 的集合 $V$ 中顶点之间的关系。这要求矩阵的行（或列）与图的顶点之间存在一一对应关系。因此，矩阵必须是方阵，即具有相同的行数和列数。设矩阵 $A$ 有 $m$ 行和 $p$ 列。要使 $A$ 成为一个非空图的有效邻接矩阵，它必须满足 $m=p$ 且 $n=m=p \\geq 1$。如果给定矩阵未能通过此测试，它就不能是邻接矩阵。问题规定，在这种情况下，对称性和对角线违规计数是未定义的，应报告为整数 $-1$。因此，非方阵矩阵的结果是 $[\\text{False}, -1, -1]$。\n\n2.  **对称性违规量化**：对于无向图，任意两个顶点 $i$ 和 $j$ 之间的关系是对称的。如果顶点 $i$ 与顶点 $j$ 相邻，那么顶点 $j$ 也必须与顶点 $i$ 相邻。在邻接矩阵 $A$ 中，这转化为对称性质：$A = A^T$，或对于所有索引对 $(i, j)$，$a_{ij} = a_{ji}$。为了在数值上下文中量化对此性质的偏离，我们计算其对应矩阵条目在给定容差 $\\varepsilon$ 内不相等的不同顶点无序对 $\\{i,j\\}$ 的数量。如果 $|a_{ij} - a_{ji}|  \\varepsilon$，则发生了对 $\\{i,j\\}$ 的对称性违规。我们遍历所有满足 $1 \\leq i  j \\leq n$ 的唯一索引对 $(i, j)$，并对每个违反此条件的对递增计数器 $c_{\\text{sym}}$。索引集 $1 \\leq i  j \\leq n$ 对应于矩阵的严格上三角部分中的条目。\n\n3.  **对角线违规量化**：根据定义，无环图没有连接顶点自身的边。这意味着对于任何顶点 $i$，邻接矩阵中的条目 $a_{ii}$ 必须为零。与对称性检查类似，我们使用容差 $\\varepsilon$ 来测试此性质。如果顶点 $i$ 对应的对角线条目 $a_{ii}$ 的绝对值大于容差，即 $|a_{ii}|  \\varepsilon$，则发生了对顶点 $i$ 的对角线违规。我们遍历从 $i=1$ 到 $n$ 的所有对角线条目，并对每个违反该条件的条目递增计数器 $c_{\\text{diag}}$。\n\n整个过程是首先检查方阵性。如果矩阵是方阵，我们继续计算 $c_{\\text{sym}}$ 和 $c_{\\text{diag}}$。单个矩阵的最终输出是一个列表 $[s, c_{\\text{sym}}, c_{\\text{diag}}]$，其中 $s$ 是方阵性测试的布尔结果。此过程系统地应用于提供的每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates a set of matrices against the properties of an adjacency matrix\n    for an undirected, loopless graph and reports consistency check results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        [\n            [0, 1, 0],\n            [1, 0, 1],\n            [0, 1, 0]\n        ],\n        # Test case 2\n        [\n            [0, 2, 0],\n            [2, 1, 3],\n            [0, 3, 0]\n        ],\n        # Test case 3\n        [\n            [0, 1, 0],\n            [0, 0, 1],\n            [0, 1, 0]\n        ],\n        # Test case 4\n        [\n            [1, 1, 0],\n            [0, 0, 0],\n            [0, 0, 0]\n        ],\n        # Test case 5\n        [\n            [0.0]\n        ],\n        # Test case 6\n        [\n            [1e-12]\n        ],\n        # Test case 7 (non-square)\n        [\n            [0, 1, 0],\n            [1, 0, 1]\n        ],\n        # Test case 8\n        [\n            [0.0, 1.0000000005],\n            [1.0, 0.0]\n        ],\n        # Test case 9\n        [\n            [0.0, 1.000000002],\n            [1.0, 0.0]\n        ],\n        # Test case 10\n        [\n            [0, 2.5, 0],\n            [2.5, 0, 4.1],\n            [0, 4.1, 0]\n        ]\n    ]\n\n    epsilon = 1e-9\n    results = []\n\n    for case_data in test_cases:\n        # Convert list of lists to a NumPy array for efficient computation.\n        # Use dtype=float to handle all specified numeric types.\n        matrix = np.array(case_data, dtype=float)\n\n        # Step 1: Verify that the matrix is square (n x n with n = 1).\n        if matrix.ndim == 2 and matrix.shape[0] == matrix.shape[1] and matrix.shape[0] = 1:\n            is_square = True\n        else:\n            is_square = False\n\n        if not is_square:\n            # For non-square matrices, symmetry and diagonal counts are undefined.\n            results.append([False, -1, -1])\n            continue\n\n        n = matrix.shape[0]\n\n        # Step 2: Quantify diagonal violations.\n        # Count where the absolute value of a diagonal element exceeds epsilon.\n        diag_violations = np.sum(np.abs(np.diag(matrix))  epsilon)\n\n        # Step 3: Quantify symmetry violations.\n        # For a 1x1 matrix, there are no off-diagonal elements to check.\n        if n == 1:\n            sym_violations = 0\n        else:\n            # Vectorized approach: compare upper triangle with transposed lower triangle.\n            # np.triu(matrix, k=1) gets elements above the main diagonal.\n            upper_triangle = np.triu(matrix, k=1)\n            # np.tril(matrix, k=-1).T gets elements below the main diagonal and transposes them\n            # into the upper triangle for element-wise comparison.\n            lower_triangle_transposed = np.tril(matrix, k=-1).T\n            \n            # Calculate the absolute difference and count violations.\n            diff_matrix = np.abs(upper_triangle - lower_triangle_transposed)\n            sym_violations = np.sum(diff_matrix  epsilon)\n\n        # Append the result for the current case. Cast numpy integers to standard python ints.\n        results.append([True, int(sym_violations), int(diag_violations)])\n\n    # The final print statement must match the specified single-line format.\n    # The `str` of a list adds spaces, e.g., `[True, 0, 0]`.\n    # The code `','.join(map(str, results))` joins these string representations\n    # with a comma, and the f-string wraps the whole thing in brackets.\n    # This results in a string like '[[True, 0, 0],[True, 0, 1],...]'\n    final_output_string = f\"[{','.join(map(str, results))}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "不同的网络算法对数据结构有不同的偏好，因此在各种表示之间进行转换是一项基本技能。本练习将探讨如何高效地将邻接矩阵 $A$ 转换为边列表，其核心思想是利用矩阵的对称性，仅扫描上三角部分即可避免重复枚举边。这项实践  不仅能锻炼您的算法实现能力，还将引导您使用关联矩阵 $B$ 及其乘积 $B B^T$ 来验证结果，从而揭示不同图表示之间的深刻代数关联。",
            "id": "4291946",
            "problem": "考虑一个定义在大小为 $n \\in \\mathbb{N}$ 的顶点集上的有限、简单、无向图。邻接矩阵是一个方形二元矩阵 $\\mathbf{A} \\in \\{0,1\\}^{n \\times n}$，其元素 $A_{ij} = 1$ 当且仅当顶点 $i$ 和顶点 $j$ 之间存在一条无向边，并且对所有 $i$ 都有 $A_{ii} = 0$。对于无向图，$\\mathbf{A}$ 是对称的，即对所有 $i,j$ 都有 $A_{ij} = A_{ji}$。边列表是代表边的无序对 $\\{i,j\\}$ 的集合；为避免重复，边可以用 $i  j$ 的形式进行规范表示。关联矩阵 $\\mathbf{B} \\in \\{0,1\\}^{n \\times m}$（其中 $m$ 是边的数量）每列对应一条边，每行对应一个顶点，如果顶点 $i$ 是边 $k$ 的一个端点，则 $B_{ik} = 1$，否则 $B_{ik} = 0$。\n\n从这些基本定义出发，推导一个正确的算法，该算法通过仅扫描邻接矩阵的严格上三角部分来生成一个简单无向图的边列表。论证为什么这个过程能且仅能枚举每条无向边一次，以及为什么其关于 $n$ 的时间复杂度是 $O(n^2)$。作为一项独立的正确性检查，从推导出的边列表构造关联矩阵，并用它来验证乘积 $\\mathbf{B}\\mathbf{B}^\\top$ 的非对角线元素与原始邻接矩阵 $\\mathbf{A}$ 的相应元素相匹配。\n\n你的程序必须针对以下邻接矩阵测试套件实现此算法和验证过程，并为每个测试用例返回：\n- 指示 $\\mathbf{A}$ 是否表示一个有效的简单无向图的布尔值（即 $\\mathbf{A}$ 是对称的，对角线为零，且元素在 $\\{0,1\\}$ 内），\n- 找到的边的整数数量 $m$，\n- 严格上三角部分中检查的位置的整数数量，即 $n(n-1)/2$，\n- 指示 $\\mathbf{B}\\mathbf{B}^\\top$ 的非对角线元素是否与 $\\mathbf{A}$ 的非对角线元素一致的布尔值，\n- 以 $i  j$ 的形式表示的规范化边列表。",
            "solution": "问题陈述定义明确，科学上基于图论的基本原理，并为一个具体的计算任务提供了一套完整的规范。简单无向图、邻接矩阵 $\\mathbf{A}$、边列表和关联矩阵 $\\mathbf{B}$ 的定义都是标准的。所提出的 $\\mathbf{B}\\mathbf{B}^\\top$ 的非对角线元素与 $\\mathbf{A}$ 之间的关系是代数图论中的一个已知结果。因此，该问题是有效的，并且可以推导出解决方案。\n\n任务是设计并论证一个算法，用于将简单无向图的邻接矩阵表示转换为边列表，分析其计算复杂性，并通过从一个中间的关联矩阵表示重构邻接矩阵来执行验证步骤。\n\n**1. 边列表生成算法**\n\n一个包含 $n$ 个顶点的简单无向图由其顶点集 $V = \\{0, 1, \\dots, n-1\\}$ 和其边集 $E$ 定义。邻接矩阵 $\\mathbf{A} \\in \\{0,1\\}^{n \\times n}$ 编码了连通性，其中如果顶点 $i$ 和顶点 $j$ 之间存在边，则 $A_{ij} = 1$，否则 $A_{ij} = 0$。\n\n对于无向图，$i$ 和 $j$ 之间存在边意味着两个方向都是邻接的，因此 $\\mathbf{A}$ 是对称的，即 $A_{ij} = A_{ji}$。对于简单图，不存在自环，这意味着对所有 $i \\in V$ 都有 $A_{ii} = 0$。\n\n一条边是不同顶点的一个无序对 $\\{i,j\\}$。$\\mathbf{A}$ 的对称性意味着每条边 $\\{i,j\\}$ 对应于矩阵中的两个非零元素：$A_{ij}=1$ 和 $A_{ji}=1$。为了能且仅能枚举每条边一次，我们必须采用一种约定来避免这种重复。一条边 $\\{i,j\\}$ 的规范表示是一个有序对 $(i,j)$，其中 $i  j$。这个约定将每条边映射到邻接矩阵严格上三角部分的一个唯一元素上，即元素集合 $\\{A_{ij} \\mid 0 \\le i  j  n\\}$。\n\n这引出了以下生成边列表的算法：\n1. 初始化一个空列表 `edge_list`。\n2. 遍历所有满足 $0 \\le i  j  n$ 的顶点索引对 $(i,j)$。\n3. 对于每对 $(i,j)$，检查矩阵元素 $A_{ij}$ 的值。\n4. 如果 $A_{ij} = 1$，则将对 $(i,j)$ 添加到 `edge_list` 中。\n\n这个过程保证了每条边都被找到且仅被记录一次。图中的任何边 $\\{u,v\\}$ 都对应于 $A_{uv}=1$ 和 $A_{vu}=1$。按照约定，我们可以假设 $u  v$。该算法在扫描严格上三角部分时将检查元素 $A_{uv}$ 并将 $(u,v)$ 添加到列表中。相应的元素 $A_{vu}$ 位于严格下三角部分，永远不会被检查，从而防止了边被第二次添加。\n\n**2. 时间复杂度分析**\n\n算法的计算成本主要由其必须检查的邻接矩阵中的元素数量决定。该过程遍历 $n \\times n$ 矩阵的严格上三角部分。此类元素的数量由以下总和给出：\n$$ \\sum_{i=0}^{n-2} (n-1-i) = (n-1) + (n-2) + \\dots + 1 = \\frac{(n-1)n}{2} $$\n这个总和计算结果为 $\\frac{1}{2}n^2 - \\frac{1}{2}n$。由于操作次数与此数量成正比，时间复杂度由 $n$ 的最高次幂决定。因此，从邻接矩阵生成边列表的时间复杂度为 $O(n^2)$。\n\n**3. 通过关联矩阵进行验证**\n\n问题要求通过从生成的边列表构造关联矩阵 $\\mathbf{B}$ 并验证矩阵乘积 $\\mathbf{B}\\mathbf{B}^\\top$ 的一个性质来进行正确性检查。\n\n设生成的边列表为 $E = \\{e_1, e_2, \\dots, e_m\\}$，其中 $m$ 是边的总数。关联矩阵 $\\mathbf{B}$ 是一个 $n \\times m$ 矩阵，其中如果顶点 $i$ 是边 $e_k$ 的一个端点，则元素 $B_{ik}$ 为 $1$，否则为 $0$。$\\mathbf{B}$ 的每一列对应一条边，并恰好包含两个非零元素。\n\n我們要分析乘积 $\\mathbf{C} = \\mathbf{B}\\mathbf{B}^\\top$，它是一个 $n \\times n$ 矩阵。元素 $C_{ij}$ 是 $\\mathbf{B}$ 的第 $i$ 行和第 $j$ 行的点积：\n$$ C_{ij} = (\\mathbf{B}\\mathbf{B}^\\top)_{ij} = \\sum_{k=1}^{m} B_{ik} B_{jk} $$\n让我们分析 $\\mathbf{C}$ 的元素：\n\n*   **对角线元素 ($i=j$)**:\n    $$ C_{ii} = \\sum_{k=1}^{m} B_{ik} B_{ik} = \\sum_{k=1}^{m} B_{ik}^2 $$\n    由于 $B_{ik} \\in \\{0,1\\}$，我们有 $B_{ik}^2 = B_{ik}$。因此，\n    $$ C_{ii} = \\sum_{k=1}^{m} B_{ik} $$\n    这个总和计算了与顶点 $i$ 相关联的边的数量，根据定义，这就是顶点 $i$ 的度，记作 $\\deg(i)$。\n\n*   **非对角线元素 ($i \\neq j$)**:\n    $$ C_{ij} = \\sum_{k=1}^{m} B_{ik} B_{jk} $$\n    项 $B_{ik}B_{jk}$ 为非零（等于 $1$）当且仅当 $B_{ik}=1$ 和 $B_{jk}=1$ 同时成立。这个条件意味着顶点 $i$ 和顶点 $j$ 都是同一条边 $e_k$ 的端点。在一个简单图中，任意两个不同的顶点 $i$ 和 $j$ 之间最多只能有一条边连接。\n    - 如果在 $i$ 和 $j$ 之间存在一条边，设这条边为 $e_p$。那么当 $k=p$ 时，$B_{ip}B_{jp} = 1 \\times 1 = 1$。对于任何其他 $k \\neq p$ 的边 $e_k$，它不可能同时连接 $i$ 和 $j$，所以 $B_{ik}$ 或 $B_{jk}$ 中至少有一个必须为零，使得乘积 $B_{ik}B_{jk}=0$。因此，$C_{ij}$ 的总和计算结果为 $1$。\n    - 如果在 $i$ 和 $j$ 之间没有边，那么对于所有的边 $e_k$，$i$ 和 $j$ 不可能同时是其端点。因此，对于所有 $k \\in \\{1, \\dots, m\\}$，乘积 $B_{ik}B_{jk}$ 都为 $0$，总和 $C_{ij}$ 计算结果为 $0$。\n\n这表明对于 $i \\neq j$，$C_{ij}=1$ 如果 $i$ 和 $j$ 之间有边，否则 $C_{ij}=0$。这正是邻接矩阵元素 $A_{ij}$ 的定义。因此，我们已经确认 $\\mathbf{B}\\mathbf{B}^\\top$ 的非对角线元素与原始邻接矩阵 $\\mathbf{A}$ 的相应元素相同。这为验证生成的边列表的正确性提供了一种稳健的方法。完整的关系可以简洁地表示为 $\\mathbf{B}\\mathbf{B}^\\top = \\mathbf{A} + \\mathbf{D}$，其中 $\\mathbf{D}$ 是顶点度的对角矩阵。\n\n实现将执行以下步骤：验证输入矩阵，通过扫描上三角部分生成边列表，构造关联矩阵，计算 $\\mathbf{B}\\mathbf{B}^\\top$，并将其非对角线部分与原始矩阵 $\\mathbf{A}$ 进行比较。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the graph representation problem for a suite of test cases.\n    \"\"\"\n\n    def process_matrix(A):\n        \"\"\"\n        Processes a single adjacency matrix according to the problem statement.\n\n        Args:\n            A (np.ndarray): The adjacency matrix.\n\n        Returns:\n            list: A list containing the results for this test case in the specified format.\n                  [is_valid, num_edges, num_inspected, recon_ok, edge_list]\n        \"\"\"\n        A = np.array(A, dtype=int)\n        \n        # Determine matrix properties\n        n = A.shape[0]\n\n        # 1. Validate the adjacency matrix\n        is_square = (A.ndim == 2 and A.shape[0] == A.shape[1])\n        is_symmetric = is_square and np.array_equal(A, A.T)\n        has_zero_diagonal = is_square and np.all(np.diag(A) == 0)\n        has_binary_entries = np.all((A == 0) | (A == 1))\n        \n        is_valid = is_symmetric and has_zero_diagonal and has_binary_entries\n\n        # 2. Generate edge list by scanning the strictly upper triangular part\n        edge_list = []\n        if n  0:\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if A[i, j] == 1:\n                        edge_list.append([i, j])\n        \n        num_edges = len(edge_list)\n        \n        # 3. Calculate the number of inspected positions\n        num_inspected = n * (n - 1) // 2 if n  0 else 0\n\n        # 4. Verification using incidence matrix\n        recon_ok = False\n        if is_square: # Proceed with verification only if matrix is square\n            if num_edges == 0:\n                # If no edges, B is n x 0, and BB^T is the n x n zero matrix.\n                # This must match A for the reconstruction to be ok.\n                B_BT = np.zeros((n, n), dtype=int)\n            else:\n                # Construct incidence matrix B\n                B = np.zeros((n, num_edges), dtype=int)\n                for k, edge in enumerate(edge_list):\n                    i, j = edge\n                    B[i, k] = 1\n                    B[j, k] = 1\n                \n                # Calculate B * B^T\n                B_BT = B @ B.T\n            \n            # The off-diagonal entries of B * B^T should match A.\n            # We can check this by creating a copy of B*B^T, setting its\n            # diagonal to 0, and comparing with A.\n            # This works because A is required to have a zero diagonal.\n            recon_A = B_BT.copy()\n            np.fill_diagonal(recon_A, 0)\n            \n            recon_ok = np.array_equal(A, recon_A)\n\n        # Format the output for this specific case\n        # Note: edge_list must be a standard python list for correct string representation\n        return [is_valid, num_edges, num_inspected, recon_ok, edge_list]\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (n=5), sparse graph\n        [[0, 1, 0, 1, 0],\n         [1, 0, 0, 0, 1],\n         [0, 0, 0, 1, 0],\n         [1, 0, 1, 0, 0],\n         [0, 1, 0, 0, 0]],\n        \n        # Test case 2 (n=4), empty graph\n        [[0, 0, 0, 0],\n         [0, 0, 0, 0],\n         [0, 0, 0, 0],\n         [0, 0, 0, 0]],\n        \n        # Test case 3 (n=4), complete graph\n        [[0, 1, 1, 1],\n         [1, 0, 1, 1],\n         [1, 1, 0, 1],\n         [1, 1, 1, 0]],\n        \n        # Test case 4 (n=1), trivial graph\n        [[0]]\n    ]\n\n    results = [process_matrix(A) for A in test_cases]\n\n    # Format the final output string as specified\n    case_strings = []\n    for res in results:\n        # res[4] is the edge_list, which needs special formatting to remove spaces\n        edge_list_str = str(res[4]).replace(' ', '')\n        case_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{edge_list_str}]\"\n        case_strings.append(case_str)\n\n    # Final print statement in the exact required format.\n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界的网络通常是动态变化的，这要求我们采用能够高效处理图结构增删的算法。本练习将您的视角从静态图表示提升到动态图维护，要求您设计一个增量算法，以在一系列边更新操作下保持邻接矩阵 $A$ 和边列表 $E$ 的同步。通过在一个明确的成本模型下分析该算法的性能 ，您将深入理解摊销时间复杂度和动态空间使用等关键概念，这对于评估处理演化网络的算法性能至关重要。",
            "id": "4291956",
            "problem": "给定一个有向简单图，其顶点由整数 $0,1,\\dots,n-1$ 标记。邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 用于编码边，其中当且仅当存在从顶点 $u$ 到顶点 $v$ 的有向边时，$A_{uv} = 1$，否则 $A_{uv} = 0$。边列表 $E$ 是对应于图中存在的边的有序对 $(u,v)$ 的集合。您必须设计一个增量算法，在向边列表中添加或移除边时更新 $A$，并在指定的成本模型下分析摊销时间与空间成本。该算法应从邻接矩阵和边列表的基本定义中逻辑推导得出，并且必须在以下针对基本操作的单位成本模型下运行。\n\n假设在一个随机存取机（RAM）模型中，以下每个基本操作的成本均为单位成本：\n- 在集合 $E$ 中对有序对 $(u,v)$ 进行成员资格查询的成本为 $1$。\n- 将 $(u,v)$ 插入 $E$ 或从 $E$ 中删除 $(u,v)$ 的成本为 $1$。\n- 写入单个单元格 $A_{uv} \\leftarrow b$（其中 $b \\in \\{0,1\\}$）的成本为 $1$。\n\n您的算法必须处理一个包含 $U$ 个更新操作的序列，每个操作的形式为“add $(u,v)$”或“remove $(u,v)$”。对于每次更新，执行且仅执行一次成员资格查询。如果查询表明该操作会改变边集（即，添加当前不存在的边或移除当前存在的边），则执行一次集合更新（插入或删除）和一次邻接矩阵写入，以保持 $A$ 和 $E$ 的一致性。如果操作不改变集合（例如，尝试添加已存在的边或移除不存在的边），则除了成员资格查询外，不执行任何额外工作。假设在此模型下，自环 $(u,u)$ 是允许的，并被当作普通边处理。\n\n对于每个测试用例，计算并返回以下量：\n1. 最终的边数 $|E|$（整数）。\n2. 矩阵 $A$ 的所有元素之和，即 $\\sum_{u=0}^{n-1}\\sum_{v=0}^{n-1} A_{uv}$（整数）。\n3. 最大出度 $\\max_{u \\in \\{0,\\dots,n-1\\}} \\sum_{v=0}^{n-1} A_{uv}$（整数）。\n4. 执行的基本时间步总数，定义为所有更新中单位成本的成员资格查询、集合更新和邻接矩阵写入的总次数（整数）。\n5. 每次更新的摊销时间，定义为基本时间步总数除以更新次数 $U$（浮点数）。\n6. 超出邻接矩阵基线的峰值动态空间使用量，定义为在处理过程中任意时刻观察到的 $E$ 的最大基数（整数）。\n7. 超出邻接矩阵基线的平均动态空间使用量，定义为 $U$ 次更新后状态下 $E$ 的基数的平均值（浮点数）。\n8. 一个布尔值，指示最终 $A$ 是否与 $E$ 一致，即 $A_{uv} = 1$ 的位置集合是否与 $E$ 完全相等。\n\n使用以下测试套件。顶点标记为 $0,1,\\dots,n-1$，每个操作指定为“add $(u,v)$”或“remove $(u,v)$”。\n- 测试用例 1：$n=5$，更新操作如下\n  - add $(0,1)$, add $(1,2)$, add $(2,3)$, add $(3,4)$, add $(4,0)$, remove $(2,3)$, add $(2,3)$, add $(2,3)$, remove $(0,2)$.\n- 测试用例 2：$n=4$，更新操作如下\n  - remove $(0,0)$, remove $(1,2)$, remove $(3,1)$, remove $(2,2)$.\n- 测试用例 3：$n=100$，更新操作如下\n  - add $(0,99)$, add $(25,25)$, add $(50,51)$, add $(51,50)$, remove $(25,25)$, add $(99,0)$, remove $(52,52)$.\n- 测试用例 4：$n=10$，更新操作如下\n  - add $(0,0)$, add $(0,1)$, add $(0,2)$, add $(0,3)$, add $(0,4)$, add $(0,5)$, add $(0,6)$, add $(0,7)$, add $(0,8)$, add $(0,9)$,\n  - add $(1,0)$, add $(2,0)$, add $(3,0)$, add $(4,0)$, add $(5,0)$, add $(6,0)$, add $(7,0)$, add $(8,0)$, add $(9,0)$,\n  - remove $(0,0)$, remove $(0,1)$, remove $(5,0)$, remove $(7,0)$, remove $(0,9)$, remove $(9,0)$.\n- 测试用例 5：$n=3$，更新操作如下\n  - add $(0,0)$, add $(0,0)$, remove $(0,0)$, remove $(0,0)$, add $(1,2)$, add $(1,2)$, add $(2,1)$, remove $(1,2)$.\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的列表的逗号分隔列表，每个内部列表按上述顺序包含八个量。例如，输出格式必须类似于 $[[r^{(1)}_1,r^{(1)}_2,\\dots,r^{(1)}_8],[r^{(2)}_1,\\dots,r^{(2)}_8],\\dots]$，其中 $r^{(i)}_j$ 表示第 $i$ 个测试用例的第 $j$ 个结果。不涉及物理单位或角度；所有数值响应必须以整数、浮点数或布尔值的形式给出，与算法计算的结果完全一致。",
            "solution": "该问题要求设计并分析一种增量算法，用于在一系列边的添加和移除操作下，维护有向图的邻接矩阵 $A$ 和边列表 $E$ 之间的一致性。分析在指定的单位成本随机存取机（RAM）模型下进行。\n\n首先，我们对问题的组成部分进行形式化。有向图是一个对偶 $G=(V, E)$，其中 $V=\\{0, 1, \\dots, n-1\\}$ 是一个包含 $n$ 个顶点的集合，而 $E \\subseteq V \\times V$ 是一个表示有向边的有序对集合。该问题涉及此图的两种不同表示方法：\n1.  邻接矩阵 $A$，一个 $n \\times n$ 矩阵，其元素定义如下：\n    $$A_{uv} = \\begin{cases} 1  \\text{if } (u,v) \\in E \\\\ 0  \\text{if } (u,v) \\notin E \\end{cases}$$\n2.  边列表 $E$，它被显式地维护为一个有序对 $(u,v)$ 的集合。\n\n算法从一个空图开始，其中 $E$ 为空集，$E = \\emptyset$，而 $A$ 是一个 $n \\times n$ 的零矩阵。然后，它处理一个包含 $U$ 个更新操作的序列。算法的核心是确保在每次更新后，对于所有顶点对 $(u,v) \\in V \\times V$，属性 $A_{uv}=1 \\iff (u,v) \\in E$ 始终成立。\n\n单个更新操作的算法已在问题陈述中明确定义。让我们分析每种操作类型的逻辑。设操作前的状态为 $(A, E)$，操作后的状态为 $(A', E')$。\n\n对于“add $(u,v)$”操作：\n1.  执行一次成员资格查询，检查 $(u,v) \\in E$ 是否成立。这会产生 $1$ 个时间单位的成本。\n2.  如果查询返回 false（即 $(u,v) \\notin E$），则必须添加该边。这会触发另外两个基本操作：\n    a. 插入到边集合中：$E' = E \\cup \\{(u,v)\\}$。成本为 $1$。\n    b. 写入邻接矩阵：$A'_{uv} = 1$。成本为 $1$。\n    添加一条新边的总成本为 $1+1+1=3$。最终状态为 $(A', E')$，其中 $A'$ 与 $A$ 相同，除了 $A'_{uv}=1$。\n3.  如果查询返回 true（即 $(u,v) \\in E$），则该边已存在。图的表示形式不发生任何变化，因此 $E' = E$ 且 $A' = A$。此冗余操作的总成本仅为初始查询的成本，即 $1$。\n\n对于“remove $(u,v)$”操作：\n1.  执行一次成员资格查询，检查 $(u,v) \\in E$ 是否成立。这会产生 $1$ 个时间单位的成本。\n2.  如果查询返回 true（即 $(u,v) \\in E$），则必须移除该边。这会触发另外两个基本操作：\n    a. 从边集合中删除：$E' = E \\setminus \\{(u,v)\\}$。成本为 $1$。\n    b. 写入邻接矩阵：$A'_{uv} = 0$。成本为 $1$。\n    移除一条已存在边的总成本为 $1+1+1=3$。最终状态为 $(A', E')$，其中 $A'$ 与 $A$ 相同，除了 $A'_{uv}=0$。\n3.  如果查询返回 false（即 $(u,v) \\notin E$），则不存在该边可供移除。不发生任何变化，因此 $E' = E$ 且 $A' = A$。此冗余操作的总成本为 $1$。\n\n为了提供所需的输出量，我们必须为每个测试用例模拟此过程，并跟踪几个指标。设 $U$ 为更新总数。设 $E_k$ 为第 $k$ 次更新后的边集，其中 $k=1, \\dots, U$。\n\n所需的八个量计算如下：\n1.  最终边数 $|E|$：这是在处理完所有 $U$ 次更新后，边集 $E_U$ 的基数。$|E_U|$。\n2.  矩阵 $A$ 的所有元素之和：由于算法保持了一致性，此和等于边的数量。$\\sum_{u=0}^{n-1}\\sum_{v=0}^{n-1} A_{uv} = |E_U|$。\n3.  最大出度：顶点 $u$ 的出度是从它发出的边的数量，由 $A$ 的第 $u$ 行之和给出：$\\text{deg}^+(u) = \\sum_{v=0}^{n-1} A_{uv}$。最大出度是 $\\max_{u \\in V} \\text{deg}^+(u)$。这是根据最终的邻接矩阵 $A_U$ 计算的。\n4.  基本时间步总数：这是所有已执行操作的成本的累积和。我们维护一个运行总和，根据上述逻辑，在 $U$ 次更新中的每一次都将其增加 $1$ 或 $3$。设 $T$ 为此总数。\n5.  每次更新的摊销时间：这是总时间成本除以更新次数，$T/U$。它表示整个序列中每次操作的平均成本。\n6.  峰值动态空间使用量：动态空间是边列表的大小，即 $|E_k|$。我们在每次更新后跟踪此值，并找出在整个序列中观察到的最大值：$\\max_{k=1,\\dots,U} |E_k|$。\n7.  平均动态空间使用量：这是更新序列中边集基数的算术平均值：$\\frac{1}{U} \\sum_{k=1}^{U} |E_k|$。\n8.  一致性布尔值：进行最终检查以验证最终矩阵 $A_U$ 和边集 $E_U$ 是否一致。当且仅当对于每个顶点对 $(u,v) \\in V \\times V$，条件 $(A_U)_{uv} = 1$ 等价于 $(u,v) \\in E_U$ 时，此值为真。根据构造，我们的算法确保了这一点，因此结果应始终为真。\n\n实现将涉及为 $A$ 初始化一个 $n \\times n$ 的零矩阵（使用 `numpy` 以提高矩阵运算效率）和为 $E$ 初始化一个空 `set`。模拟过程通过遍历每个测试用例的更新列表，应用指定的逻辑，并累积必要的统计数据来计算最终的八元素结果向量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"n\": 5,\n            \"updates\": [\n                (\"add\", (0, 1)), (\"add\", (1, 2)), (\"add\", (2, 3)),\n                (\"add\", (3, 4)), (\"add\", (4, 0)), (\"remove\", (2, 3)),\n                (\"add\", (2, 3)), (\"add\", (2, 3)), (\"remove\", (0, 2))\n            ]\n        },\n        # Test case 2\n        {\n            \"n\": 4,\n            \"updates\": [\n                (\"remove\", (0, 0)), (\"remove\", (1, 2)), \n                (\"remove\", (3, 1)), (\"remove\", (2, 2))\n            ]\n        },\n        # Test case 3\n        {\n            \"n\": 100,\n            \"updates\": [\n                (\"add\", (0, 99)), (\"add\", (25, 25)), (\"add\", (50, 51)),\n                (\"add\", (51, 50)), (\"remove\", (25, 25)), (\"add\", (99, 0)),\n                (\"remove\", (52, 52))\n            ]\n        },\n        # Test case 4\n        {\n            \"n\": 10,\n            \"updates\": [\n                (\"add\", (0, 0)), (\"add\", (0, 1)), (\"add\", (0, 2)),\n                (\"add\", (0, 3)), (\"add\", (0, 4)), (\"add\", (0, 5)),\n                (\"add\", (0, 6)), (\"add\", (0, 7)), (\"add\", (0, 8)),\n                (\"add\", (0, 9)), (\"add\", (1, 0)), (\"add\", (2, 0)),\n                (\"add\", (3, 0)), (\"add\", (4, 0)), (\"add\", (5, 0)),\n                (\"add\", (6, 0)), (\"add\", (7, 0)), (\"add\", (8, 0)),\n                (\"add\", (9, 0)), (\"remove\", (0, 0)), (\"remove\", (0, 1)),\n                (\"remove\", (5, 0)), (\"remove\", (7, 0)), (\"remove\", (0, 9)),\n                (\"remove\", (9, 0))\n            ]\n        },\n        # Test case 5\n        {\n            \"n\": 3,\n            \"updates\": [\n                (\"add\", (0, 0)), (\"add\", (0, 0)), (\"remove\", (0, 0)),\n                (\"remove\", (0, 0)), (\"add\", (1, 2)), (\"add\", (1, 2)),\n                (\"add\", (2, 1)), (\"remove\", (1, 2))\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        updates = case[\"updates\"]\n        U = len(updates)\n\n        # Initialize data structures and tracking variables\n        A = np.zeros((n, n), dtype=int)\n        E = set()\n        \n        total_time_steps = 0\n        cardinality_history = []\n        peak_space = 0\n\n        for op, edge in updates:\n            u, v = edge\n            \n            # 1. Membership query (cost = 1)\n            total_time_steps += 1\n            is_present = edge in E\n\n            if op == \"add\":\n                if not is_present:\n                    # 2. Set insertion (cost = 1)\n                    total_time_steps += 1\n                    E.add(edge)\n                    \n                    # 3. Adjacency matrix write (cost = 1)\n                    total_time_steps += 1\n                    A[u, v] = 1\n            elif op == \"remove\":\n                if is_present:\n                    # 2. Set deletion (cost = 1)\n                    total_time_steps += 1\n                    E.remove(edge)\n\n                    # 3. Adjacency matrix write (cost = 1)\n                    total_time_steps += 1\n                    A[u, v] = 0\n\n            # Track space usage after each update\n            current_cardinality = len(E)\n            cardinality_history.append(current_cardinality)\n            if current_cardinality  peak_space:\n                peak_space = current_cardinality\n\n        # Calculate final quantities\n        # 1. Final number of edges\n        final_num_edges = len(E)\n\n        # 2. Sum of all entries of A\n        sum_A = np.sum(A)\n\n        # 3. Maximum out-degree\n        if n  0 and final_num_edges > 0:\n            max_out_degree = np.max(np.sum(A, axis=1))\n        else:\n            max_out_degree = 0\n\n        # 4. Total number of primitive time steps (already calculated)\n\n        # 5. Amortized time per update\n        if U  0:\n            amortized_time = total_time_steps / U\n        else:\n            amortized_time = 0.0\n\n        # 6. Peak dynamic space usage (already calculated)\n\n        # 7. Average dynamic space usage\n        if U  0:\n            avg_space = sum(cardinality_history) / U\n        else:\n            avg_space = 0.0\n            \n        # 8. Consistency boolean\n        is_consistent = True\n        if n > 0:\n            for r in range(n):\n                for c in range(n):\n                    if (A[r, c] == 1) != ((r, c) in E):\n                        is_consistent = False\n                        break\n                if not is_consistent:\n                    break\n        \n        case_results = [\n            int(final_num_edges),\n            int(sum_A),\n            int(max_out_degree),\n            int(total_time_steps),\n            float(amortized_time),\n            int(peak_space),\n            float(avg_space),\n            is_consistent\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string\n    result_str = \"[\" + \",\".join([str(res).replace(\" \", \"\") for res in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}