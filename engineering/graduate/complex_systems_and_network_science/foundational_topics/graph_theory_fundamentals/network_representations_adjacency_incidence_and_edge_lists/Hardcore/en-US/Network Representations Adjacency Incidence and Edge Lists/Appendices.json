{
    "hands_on_practices": [
        {
            "introduction": "Before performing any analysis or conversion, it is crucial to verify that a given data structure correctly represents a graph. This first exercise focuses on the fundamental properties that an adjacency matrix $\\mathbf{A}$ must satisfy to represent a simple, undirected graph. By implementing checks for symmetry and a zero diagonal, you will develop a foundational skill for ensuring data integrity in any network science workflow .",
            "id": "4291927",
            "problem": "Consider a finite graph with vertex set $V$ of size $n$, and let $A \\in \\mathbb{R}^{n \\times n}$ be a proposed adjacency matrix representation. By definition, for an undirected graph, the pairwise relationship between vertices is symmetric, and the absence of self-loops requires that no vertex is adjacent to itself. From these core definitions, it follows that a valid adjacency matrix for an undirected loopless graph must be square, symmetric, and have a zero diagonal. In computational settings with real-valued entries, approximate equality is often required due to floating-point representation; therefore a tolerance parameter $\\varepsilon > 0$ can be used to operationalize equality checks.\n\nYour task is to implement a program that, for each provided matrix, performs the following consistency checks derived from the fundamental definitions:\n- Verify that $A$ is square, that is $A \\in \\mathbb{R}^{n \\times n}$ for some integer $n \\geq 1$.\n- Quantify symmetry violations by counting the number of unordered vertex pairs $\\{i,j\\}$ with $1 \\leq i < j \\leq n$ such that $|a_{ij} - a_{ji}| > \\varepsilon$.\n- Quantify diagonal violations by counting the number of indices $i \\in \\{1,\\dots,n\\}$ such that $|a_{ii}| > \\varepsilon$.\n\nIf a matrix is not square, the symmetry and diagonal violation counts are undefined. In that case, report the squareness check as false and use the integer $-1$ for both violation counts to denote undefined values.\n\nUse the tolerance $\\varepsilon = 10^{-9}$ for all absolute-value comparisons.\n\nImplement the above logic and apply it to the following test suite of matrices. Each matrix is specified as a real-valued array; rows are listed as bracketed lists:\n- Test case $1$:\n  [\n    [0, 1, 0],\n    [1, 0, 1],\n    [0, 1, 0]\n  ]\n- Test case $2$:\n  [\n    [0, 2, 0],\n    [2, 1, 3],\n    [0, 3, 0]\n  ]\n- Test case $3$:\n  [\n    [0, 1, 0],\n    [0, 0, 1],\n    [0, 1, 0]\n  ]\n- Test case $4$:\n  [\n    [1, 1, 0],\n    [0, 0, 0],\n    [0, 0, 0]\n  ]\n- Test case $5$:\n  [\n    [0.0]\n  ]\n- Test case $6$:\n  [\n    [1e-12]\n  ]\n- Test case $7$ (non-square):\n  [\n    [0, 1, 0],\n    [1, 0, 1]\n  ]\n- Test case $8$:\n  [\n    [0.0, 1.0000000005],\n    [1.0, 0.0]\n  ]\n- Test case $9$:\n  [\n    [0.0, 1.000000002],\n    [1.0, 0.0]\n  ]\n- Test case $10$:\n  [\n    [0, 2.5, 0],\n    [2.5, 0, 4.1],\n    [0, 4.1, 0]\n  ]\n\nOutput specification:\n- For each test case, produce a list of the form [$s$, $c_{\\text{sym}}$, $c_{\\text{diag}}$], where $s$ is a boolean indicating whether the matrix is square, $c_{\\text{sym}}$ is the integer count of symmetry violations, and $c_{\\text{diag}}$ is the integer count of diagonal violations (or $-1$ for both counts when $s$ is false).\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets. Concretely, the output must be a single line string representation of the list of results, such as $[r_1, r_2, \\dots, r_{10}]$, where each $r_k$ is the per-test-case list described above.",
            "solution": "The objective is to validate a given matrix $A$ against the fundamental properties required for it to be an adjacency matrix of a finite, undirected, loopless graph. These properties are that the matrix must be square, symmetric, and have a zero diagonal. The validation will be performed computationally, employing a numerical tolerance $\\varepsilon = 10^{-9}$ to account for floating-point inaccuracies. For each supplied matrix, we must perform three checks: squareness, symmetry violations, and diagonal violations.\n\nLet a candidate matrix be provided as a two-dimensional array of real numbers. We denote its elements by $a_{ij}$, where $i$ is the row index and $j$ is the column index. The procedure is as follows:\n\n1.  **Squareness Verification**: An adjacency matrix represents relationships between vertices in a set $V$ of size $n$. This requires a one-to-one correspondence between the rows (or columns) of the matrix and the vertices of the graph. Consequently, the matrix must be square, i.e., have the same number of rows and columns. Let the matrix $A$ have $m$ rows and $p$ columns. For $A$ to be a valid adjacency matrix for a non-empty graph, it must satisfy $m=p$ and $n=m=p \\geq 1$. If a given matrix fails this test, it cannot be an adjacency matrix. The problem specifies that in this case, the symmetry and diagonal violation counts are undefined and should be reported as the integer $-1$. The result for a non-square matrix is thus $[\\text{False}, -1, -1]$.\n\n2.  **Symmetry Violation Quantification**: For an undirected graph, the relationship between any two vertices $i$ and $j$ is symmetric. If vertex $i$ is adjacent to vertex $j$, then vertex $j$ must be adjacent to vertex $i$. In terms of the adjacency matrix $A$, this translates to the property of symmetry: $A = A^T$, or $a_{ij} = a_{ji}$ for all pairs of indices $(i, j)$. To quantify deviations from this property in a numerical context, we count the number of unordered pairs of distinct vertices $\\{i,j\\}$ for which the corresponding matrix entries are not equal, within the given tolerance $\\varepsilon$. A symmetry violation for the pair $\\{i,j\\}$ occurs if $|a_{ij} - a_{ji}| > \\varepsilon$. We iterate over all unique pairs of indices $(i, j)$ such that $1 \\leq i < j \\leq n$ and increment a counter, $c_{\\text{sym}}$, for each pair that violates this condition. The set of indices $1 \\leq i < j \\leq n$ corresponds to the entries in the strict upper triangle of the matrix.\n\n3.  **Diagonal Violation Quantification**: A loopless graph, by definition, has no edges connecting a vertex to itself. This means that for any vertex $i$, the entry $a_{ii}$ in the adjacency matrix must be zero. Similar to the symmetry check, we use the tolerance $\\varepsilon$ to test this property. A diagonal violation for vertex $i$ occurs if its corresponding diagonal entry $a_{ii}$ has a magnitude greater than the tolerance, i.e., $|a_{ii}| > \\varepsilon$. We iterate through all diagonal entries from $i=1$ to $n$ and increment a counter, $c_{\\text{diag}}$, for each entry that violates the condition.\n\nThe overall process is to first check for squareness. If the matrix is square, we proceed to compute $c_{\\text{sym}}$ and $c_{\\text{diag}}$. The final output for a single matrix is a list $[s, c_{\\text{sym}}, c_{\\text{diag}}]$, where $s$ is the boolean result of the squareness test. This procedure is applied systematically to every test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates a set of matrices against the properties of an adjacency matrix\n    for an undirected, loopless graph and reports consistency check results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        [\n            [0, 1, 0],\n            [1, 0, 1],\n            [0, 1, 0]\n        ],\n        # Test case 2\n        [\n            [0, 2, 0],\n            [2, 1, 3],\n            [0, 3, 0]\n        ],\n        # Test case 3\n        [\n            [0, 1, 0],\n            [0, 0, 1],\n            [0, 1, 0]\n        ],\n        # Test case 4\n        [\n            [1, 1, 0],\n            [0, 0, 0],\n            [0, 0, 0]\n        ],\n        # Test case 5\n        [\n            [0.0]\n        ],\n        # Test case 6\n        [\n            [1e-12]\n        ],\n        # Test case 7 (non-square)\n        [\n            [0, 1, 0],\n            [1, 0, 1]\n        ],\n        # Test case 8\n        [\n            [0.0, 1.0000000005],\n            [1.0, 0.0]\n        ],\n        # Test case 9\n        [\n            [0.0, 1.000000002],\n            [1.0, 0.0]\n        ],\n        # Test case 10\n        [\n            [0, 2.5, 0],\n            [2.5, 0, 4.1],\n            [0, 4.1, 0]\n        ]\n    ]\n\n    epsilon = 1e-9\n    results = []\n\n    for case_data in test_cases:\n        # Convert list of lists to a NumPy array for efficient computation.\n        # Use dtype=float to handle all specified numeric types.\n        matrix = np.array(case_data, dtype=float)\n\n        # Step 1: Verify that the matrix is square (n x n with n >= 1).\n        if matrix.ndim == 2 and matrix.shape[0] == matrix.shape[1] and matrix.shape[0] >= 1:\n            is_square = True\n        else:\n            is_square = False\n\n        if not is_square:\n            # For non-square matrices, symmetry and diagonal counts are undefined.\n            results.append([False, -1, -1])\n            continue\n\n        n = matrix.shape[0]\n\n        # Step 2: Quantify diagonal violations.\n        # Count where the absolute value of a diagonal element exceeds epsilon.\n        diag_violations = np.sum(np.abs(np.diag(matrix)) > epsilon)\n\n        # Step 3: Quantify symmetry violations.\n        # For a 1x1 matrix, there are no off-diagonal elements to check.\n        if n <= 1:\n            sym_violations = 0\n        else:\n            # Vectorized approach: compare upper triangle with transposed lower triangle.\n            # np.triu(matrix, k=1) gets elements above the main diagonal.\n            upper_triangle = np.triu(matrix, k=1)\n            # np.tril(matrix, k=-1).T gets elements below the main diagonal and transposes them\n            # into the upper triangle for element-wise comparison.\n            lower_triangle_transposed = np.tril(matrix, k=-1).T\n            \n            # Calculate the absolute difference and count violations.\n            diff_matrix = np.abs(upper_triangle - lower_triangle_transposed)\n            sym_violations = np.sum(diff_matrix > epsilon)\n\n        # Append the result for the current case. Cast numpy integers to standard python ints.\n        results.append([True, int(sym_violations), int(diag_violations)])\n\n    # The final print statement must match the specified single-line format.\n    # The `str` of a list adds spaces, e.g., `[True, 0, 0]`.\n    # The code `','.join(map(str, results))` joins these string representations\n    # with a comma, and the f-string wraps the whole thing in brackets.\n    # This results in a string like '[[True, 0, 0],[True, 0, 1],...]'\n    final_output_string = f\"[{','.join(map(str, results))}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Different network algorithms are optimized for different data representations, making conversion between them a core competency. This practice challenges you to convert an adjacency matrix $\\mathbf{A}$ into an edge list, a format often preferred for its compactness in sparse networks. You will not only implement an efficient $O(n^2)$ algorithm but also verify its correctness by exploring the algebraic relationship between the adjacency matrix and the incidence matrix $\\mathbf{B}$, specifically through the product $\\mathbf{B}\\mathbf{B}^\\top$ .",
            "id": "4291946",
            "problem": "Consider a finite, simple, undirected graph defined on a vertex set of size $n \\in \\mathbb{N}$. The adjacency matrix is a square binary matrix $\\mathbf{A} \\in \\{0,1\\}^{n \\times n}$ with entries $A_{ij} = 1$ if and only if there is an undirected edge between vertex $i$ and vertex $j$, and $A_{ii} = 0$ for all $i$. For an undirected graph, $\\mathbf{A}$ is symmetric, that is, $A_{ij} = A_{ji}$ for all $i,j$. The edge list is a collection of unordered pairs $\\{i,j\\}$ representing the edges; to avoid duplication, edges can be represented canonically with $i < j$. The incidence matrix $\\mathbf{B} \\in \\{0,1\\}^{n \\times m}$, where $m$ is the number of edges, has one column per edge and one row per vertex, with $B_{ik} = 1$ if vertex $i$ is an endpoint of edge $k$ and $B_{ik} = 0$ otherwise.\n\nStarting from these foundational definitions, derive a correct algorithm that produces the edge list of a simple, undirected graph by scanning only the strictly upper triangular part of the adjacency matrix. Justify why this procedure enumerates each undirected edge exactly once and why its time complexity in terms of $n$ is $O(n^2)$. As an independent correctness check, construct the incidence matrix from the derived edge list and use it to verify that the off-diagonal entries of the product $\\mathbf{B}\\mathbf{B}^\\top$ match those of the original adjacency matrix $\\mathbf{A}$.\n\nYour program must implement this algorithm and verification for the following test suite of adjacency matrices, and for each test case return:\n- the boolean indicating whether $\\mathbf{A}$ represents a valid simple undirected graph (that is, $\\mathbf{A}$ is symmetric, has a zero diagonal, and has entries in $\\{0,1\\}$),\n- the integer number of edges $m$ found,\n- the integer number of inspected positions in the strictly upper triangular part, which is $n(n-1)/2$,\n- the boolean indicating whether the off-diagonal entries of $\\mathbf{B}\\mathbf{B}^\\top$ coincide with those of $\\mathbf{A}$,\n- the edge list represented as a list of pairs $[i,j]$ with $i<j$.\n\nUse the test suite below:\n- Test case $1$ ($n=5$), sparse graph:\n$$\n\\mathbf{A}^{(1)}=\n\\begin{bmatrix}\n0 & 1 & 0 & 1 & 0 \\\\\n1 & 0 & 0 & 0 & 1 \\\\\n0 & 0 & 0 & 1 & 0 \\\\\n1 & 0 & 1 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 0\n\\end{bmatrix}\n$$\n- Test case $2$ ($n=4$), empty graph:\n$$\n\\mathbf{A}^{(2)}=\n\\begin{bmatrix}\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0\n\\end{bmatrix}\n$$\n- Test case $3$ ($n=4$), complete graph:\n$$\n\\mathbf{A}^{(3)}=\n\\begin{bmatrix}\n0 & 1 & 1 & 1 \\\\\n1 & 0 & 1 & 1 \\\\\n1 & 1 & 0 & 1 \\\\\n1 & 1 & 1 & 0\n\\end{bmatrix}\n$$\n- Test case $4$ ($n=1$), trivial graph:\n$$\n\\mathbf{A}^{(4)}=\n\\begin{bmatrix}\n0\n\\end{bmatrix}\n$$\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces, where each element corresponds to one test case and is itself a list in the order specified above. For example, the output must have the form\n$[\\text{case}_1,\\text{case}_2,\\text{case}_3,\\text{case}_4]$\nwith each $\\text{case}_k$ rendered as $[valid,m,inspected,recon\\_ok,edge\\_list]$ (booleans as $True$ or $False$, integers in base-$10$, and lists using square brackets).",
            "solution": "The problem statement is well-defined, scientifically grounded in the elementary principles of graph theory, and provides a complete set of specifications for a concrete computational task. The definitions of a simple undirected graph, adjacency matrix $\\mathbf{A}$, edge list, and incidence matrix $\\mathbf{B}$ are standard. The proposed relationship between the off-diagonal entries of $\\mathbf{B}\\mathbf{B}^\\top$ and $\\mathbf{A}$ is a known result in algebraic graph theory. The problem is therefore valid and a solution can be derived.\n\nThe task is to devise and justify an algorithm for converting an adjacency matrix representation of a simple, undirected graph into an edge list, analyze its computational complexity, and perform a verification step by reconstructing the adjacency matrix from an intermediate incidence matrix representation.\n\n**1. Algorithm for Edge List Generation**\n\nA simple, undirected graph on $n$ vertices is defined by its vertex set $V = \\{0, 1, \\dots, n-1\\}$ and its edge set $E$. The adjacency matrix $\\mathbf{A} \\in \\{0,1\\}^{n \\times n}$ encodes the connectivity, where $A_{ij} = 1$ if an edge exists between vertex $i$ and vertex $j$, and $A_{ij} = 0$ otherwise.\n\nFor an undirected graph, the presence of an edge between $i$ and $j$ implies adjacency in both directions, so $\\mathbf{A}$ is symmetric, i.e., $A_{ij} = A_{ji}$. For a simple graph, there are no self-loops, meaning $A_{ii} = 0$ for all $i \\in V$.\n\nAn edge is an unordered pair of distinct vertices $\\{i,j\\}$. The symmetry of $\\mathbf{A}$ means that each edge $\\{i,j\\}$ corresponds to two non-zero entries in the matrix: $A_{ij}=1$ and $A_{ji}=1$. To enumerate each edge exactly once, we must adopt a convention that avoids this duplication. A canonical representation for an edge $\\{i,j\\}$ is an ordered pair $(i,j)$ where $i < j$. This convention maps each edge to a unique entry in the strictly upper triangular part of the adjacency matrix, i.e., the set of entries $\\{A_{ij} \\mid 0 \\le i < j < n\\}$.\n\nThis leads to the following algorithm for generating the edge list:\n1. Initialize an empty list, `edge_list`.\n2. Iterate through all pairs of vertex indices $(i,j)$ such that $0 \\le i < n$ and $i < j < n$.\n3. For each pair $(i,j)$, inspect the value of the matrix entry $A_{ij}$.\n4. If $A_{ij} = 1$, add the pair $(i,j)$ to `edge_list`.\n\nThis procedure guarantees that every edge is found and recorded exactly once. Any edge $\\{u,v\\}$ in the graph corresponds to $A_{uv}=1$ and $A_{vu}=1$. By convention, we can assume $u < v$. The algorithm will inspect the entry $A_{uv}$ during its scan of the strictly upper triangular part and add $(u,v)$ to the list. The corresponding entry $A_{vu}$ is in the strictly lower triangular part and is never inspected, thus preventing the edge from being added a second time.\n\n**2. Time Complexity Analysis**\n\nThe algorithm's computational cost is dominated by the number of entries it must inspect in the adjacency matrix. The procedure iterates through the strictly upper triangular part of the $n \\times n$ matrix. The number of such entries is given by the sum:\n$$ \\sum_{i=0}^{n-2} (n-1-i) = (n-1) + (n-2) + \\dots + 1 = \\frac{(n-1)n}{2} $$\nThis sum evaluates to $\\frac{1}{2}n^2 - \\frac{1}{2}n$. Since the number of operations is proportional to this quantity, the time complexity is determined by the highest power of $n$. Therefore, the time complexity of generating the edge list from the adjacency matrix is $O(n^2)$.\n\n**3. Verification via Incidence Matrix**\n\nThe problem requires a correctness check by constructing the incidence matrix $\\mathbf{B}$ from the generated edge list and verifying a property of the matrix product $\\mathbf{B}\\mathbf{B}^\\top$.\n\nLet the generated edge list be $E = \\{e_1, e_2, \\dots, e_m\\}$, where $m$ is the total number of edges. The incidence matrix $\\mathbf{B}$ is an $n \\times m$ matrix where the entry $B_{ik}$ is $1$ if vertex $i$ is an endpoint of edge $e_k$, and $0$ otherwise. Each column of $\\mathbf{B}$ corresponds to an edge and contains exactly two non-zero entries.\n\nWe are to analyze the product $\\mathbf{C} = \\mathbf{B}\\mathbf{B}^\\top$, which is an $n \\times n$ matrix. An entry $C_{ij}$ is the dot product of the $i$-th row and the $j$-th row of $\\mathbf{B}$:\n$$ C_{ij} = (\\mathbf{B}\\mathbf{B}^\\top)_{ij} = \\sum_{k=1}^{m} B_{ik} B_{jk} $$\nLet us analyze the entries of $\\mathbf{C}$:\n\n*   **Diagonal entries ($i=j$)**:\n    $$ C_{ii} = \\sum_{k=1}^{m} B_{ik} B_{ik} = \\sum_{k=1}^{m} B_{ik}^2 $$\n    Since $B_{ik} \\in \\{0,1\\}$, we have $B_{ik}^2 = B_{ik}$. Thus,\n    $$ C_{ii} = \\sum_{k=1}^{m} B_{ik} $$\n    This sum counts the number of edges incident to vertex $i$, which is by definition the degree of vertex $i$, denoted $\\deg(i)$.\n\n*   **Off-diagonal entries ($i \\neq j$)**:\n    $$ C_{ij} = \\sum_{k=1}^{m} B_{ik} B_{jk} $$\n    The term $B_{ik}B_{jk}$ is non-zero (equal to $1$) if and only if both $B_{ik}=1$ and $B_{jk}=1$. This condition means that vertex $i$ and vertex $j$ are both endpoints of the same edge $e_k$. In a simple graph, there can be at most one edge connecting any two distinct vertices $i$ and $j$.\n    - If there is an edge between $i$ and $j$, let this edge be $e_p$. Then for $k=p$, $B_{ip}B_{jp} = 1 \\times 1 = 1$. For any other edge $e_k$ with $k \\neq p$, it cannot connect both $i$ and $j$, so at least one of $B_{ik}$ or $B_{jk}$ must be zero, making the product $B_{ik}B_{jk}=0$. The sum for $C_{ij}$ thus evaluates to $1$.\n    - If there is no edge between $i$ and $j$, then for all edges $e_k$, it is not possible for both $i$ and $j$ to be its endpoints. Thus, for all $k \\in \\{1, \\dots, m\\}$, the product $B_{ik}B_{jk}$ is $0$, and the sum $C_{ij}$ evaluates to $0$.\n\nThis shows that for $i \\neq j$, $C_{ij}=1$ if there is an edge between $i$ and $j$, and $C_{ij}=0$ otherwise. This is precisely the definition of the adjacency matrix entries $A_{ij}$. Therefore, we have confirmed that the off-diagonal entries of $\\mathbf{B}\\mathbf{B}^\\top$ are identical to the corresponding entries of the original adjacency matrix $\\mathbf{A}$. This provides a robust method for verifying the correctness of the generated edge list. The full relationship is succinctly expressed as $\\mathbf{B}\\mathbf{B}^\\top = \\mathbf{A} + \\mathbf{D}$, where $\\mathbf{D}$ is the diagonal matrix of vertex degrees.\n\nThe implementation will perform these steps: validate the input matrix, generate the edge list by scanning the upper triangle, construct the incidence matrix, compute $\\mathbf{B}\\mathbf{B}^\\top$, and compare its off-diagonal part with the original matrix $\\mathbf{A}$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the graph representation problem for a suite of test cases.\n    \"\"\"\n\n    def process_matrix(A):\n        \"\"\"\n        Processes a single adjacency matrix according to the problem statement.\n\n        Args:\n            A (np.ndarray): The adjacency matrix.\n\n        Returns:\n            list: A list containing the results for this test case in the specified format.\n                  [is_valid, num_edges, num_inspected, recon_ok, edge_list]\n        \"\"\"\n        A = np.array(A, dtype=int)\n        \n        # Determine matrix properties\n        n = A.shape[0]\n\n        # 1. Validate the adjacency matrix\n        is_square = (A.ndim == 2 and A.shape[0] == A.shape[1])\n        is_symmetric = is_square and np.array_equal(A, A.T)\n        has_zero_diagonal = is_square and np.all(np.diag(A) == 0)\n        has_binary_entries = np.all((A == 0) | (A == 1))\n        \n        is_valid = is_symmetric and has_zero_diagonal and has_binary_entries\n\n        # 2. Generate edge list by scanning the strictly upper triangular part\n        edge_list = []\n        if n > 0:\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if A[i, j] == 1:\n                        edge_list.append([i, j])\n        \n        num_edges = len(edge_list)\n        \n        # 3. Calculate the number of inspected positions\n        num_inspected = n * (n - 1) // 2 if n > 0 else 0\n\n        # 4. Verification using incidence matrix\n        recon_ok = False\n        if is_square: # Proceed with verification only if matrix is square\n            if num_edges == 0:\n                # If no edges, B is n x 0, and BB^T is the n x n zero matrix.\n                # This must match A for the reconstruction to be ok.\n                B_BT = np.zeros((n, n), dtype=int)\n            else:\n                # Construct incidence matrix B\n                B = np.zeros((n, num_edges), dtype=int)\n                for k, edge in enumerate(edge_list):\n                    i, j = edge\n                    B[i, k] = 1\n                    B[j, k] = 1\n                \n                # Calculate B * B^T\n                B_BT = B @ B.T\n            \n            # The off-diagonal entries of B * B^T should match A.\n            # We can check this by creating a copy of B*B^T, setting its\n            # diagonal to 0, and comparing with A.\n            # This works because A is required to have a zero diagonal.\n            recon_A = B_BT.copy()\n            np.fill_diagonal(recon_A, 0)\n            \n            recon_ok = np.array_equal(A, recon_A)\n\n        # Format the output for this specific case\n        # Note: edge_list must be a standard python list for correct string representation\n        return [is_valid, num_edges, num_inspected, recon_ok, edge_list]\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (n=5), sparse graph\n        [[0, 1, 0, 1, 0],\n         [1, 0, 0, 0, 1],\n         [0, 0, 0, 1, 0],\n         [1, 0, 1, 0, 0],\n         [0, 1, 0, 0, 0]],\n        \n        # Test case 2 (n=4), empty graph\n        [[0, 0, 0, 0],\n         [0, 0, 0, 0],\n         [0, 0, 0, 0],\n         [0, 0, 0, 0]],\n        \n        # Test case 3 (n=4), complete graph\n        [[0, 1, 1, 1],\n         [1, 0, 1, 1],\n         [1, 1, 0, 1],\n         [1, 1, 1, 0]],\n        \n        # Test case 4 (n=1), trivial graph\n        [[0]]\n    ]\n\n    results = [process_matrix(A) for A in test_cases]\n\n    # Format the final output string as specified\n    case_strings = []\n    for res in results:\n        # res[4] is the edge_list, which needs special formatting to remove spaces\n        edge_list_str = str(res[4]).replace(' ', '')\n        case_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{edge_list_str}]\"\n        case_strings.append(case_str)\n\n    # Final print statement in the exact required format.\n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Many real-world systems are best modeled as multigraphs, which permit self-loops and parallel edgesâ€”features that are disallowed in simple graphs. This final practice expands your toolkit by tasking you with constructing an incidence matrix $\\mathbf{B}$ from an edge list that represents a multigraph. You will implement the specific conventions for encoding loops and parallel edges that ensure critical properties, like vertex degree, are preserved correctly .",
            "id": "4291936",
            "problem": "You are given a finite, undirected multigraph represented by an edge list with possible loops and parallel edges. Let the graph be denoted by $G = (V, E)$ where $V = \\{0,1,\\ldots,n-1\\}$ is the vertex set of size $n$, and $E = \\{e_0, e_1, \\ldots, e_{m-1}\\}$ is the multiset of edges of size $m$ in the order they are provided. Each edge $e_j$ is an unordered pair $(u_j, v_j)$ with $u_j, v_j \\in V$. A loop is the case $u_j = v_j$. Parallel edges are repeated unordered pairs in $E$.\n\nFundamental base:\n- The degree of a vertex $v \\in V$ in an undirected multigraph is defined as the number of edge endpoints incident to $v$, counting a loop at $v$ as contributing $2$.\n- The undirected incidence matrix (Incidence Matrix (IM)) $B \\in \\mathbb{Z}^{n \\times m}$ encodes incidences between vertices and edges and is designed so that summing the incidences per vertex recovers the degree. Degrees must be consistent with the fundamental definition above, including the multiplicative contribution of loops and each copy of parallel edges.\n\nTask:\n- Construct an algorithm that, given $n$ and an edge list $E$ (with loops and parallel edges allowed), builds the incidence matrix $B$ such that the degree vector $\\mathbf{d} \\in \\mathbb{Z}^n$ recovered by $\\mathbf{d} = B \\mathbf{1}_m$ matches the degree counting rule stated in the fundamental base, where $\\mathbf{1}_m$ denotes the $m$-dimensional all-ones vector.\n- Your algorithm must specify and implement how to treat loops and parallel edges so that degree correctness is retained for every vertex. The treatment must be consistent with the undirected, non-oriented incidence convention in which each non-loop edge contributes one unit of incidence to each of its two endpoints and each loop contributes two units to its unique endpoint.\n- Additionally, verify a structural property of $B$ that encodes parallel edge multiplicities: for $u \\neq v$, the off-diagonal entry $(B B^\\top)_{uv}$ equals the number of edges between $u$ and $v$ (i.e., the multiplicity of the unordered pair $\\{u,v\\}$ in $E$). Loops do not contribute to off-diagonal entries.\n\nInput specification for your program:\n- There is no external input. Instead, use the following test suite embedded in the program.\n\nTest suite:\n- Test case $1$: $n = 6$, $E = [(0,1),(1,2),(2,2),(3,4),(3,4),(4,4)]$. Expected degrees: $[1,2,3,2,4,0]$. Pairs to check in $B B^\\top$: $(3,4) \\mapsto 2$, $(0,1) \\mapsto 1$, $(1,2) \\mapsto 1$.\n- Test case $2$: $n = 3$, $E = [(0,0),(0,0),(2,2)]$. Expected degrees: $[4,0,2]$. Pairs to check: $(0,1) \\mapsto 0$.\n- Test case $3$: $n = 4$, $E = []$. Expected degrees: $[0,0,0,0]$. Pairs to check: $(0,1) \\mapsto 0$.\n- Test case $4$: $n = 5$, $E = [(0,3),(0,3),(0,3),(1,1),(2,4)]$. Expected degrees: $[3,2,1,3,1]$. Pairs to check: $(0,3) \\mapsto 3$, $(2,4) \\mapsto 1$, $(0,2) \\mapsto 0$.\n- Test case $5$: $n = 2$, $E = [(0,1),(1,1)]$. Expected degrees: $[1,3]$. Pairs to check: $(0,1) \\mapsto 1$.\n\nValidation criteria per test case:\n- Criterion $1$ (shape): $B$ must have shape $n \\times m$.\n- Criterion $2$ (degree correctness): $B \\mathbf{1}_m$ equals the expected degree vector.\n- Criterion $3$ (pair multiplicity correctness): For each pair $(u,v)$ listed for the test, the off-diagonal entry $(B B^\\top)_{uv}$ equals the specified multiplicity.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4,result_5]$), where each $result_i$ is a boolean indicating whether all three validation criteria passed for test case $i$.",
            "solution": "The problem asks for the construction and validation of the undirected incidence matrix $B$ for a given multigraph $G=(V,E)$ with $n$ vertices and $m$ edges, which may include loops and parallel edges. The construction must satisfy two key properties: a degree recovery property and a pair multiplicity property.\n\nLet the vertex set be $V = \\{0, 1, \\ldots, n-1\\}$ and the edge multiset be $E = \\{e_0, e_1, \\ldots, e_{m-1}\\}$. The incidence matrix $B$ will be an $n \\times m$ integer matrix. The element $B_{ij}$ represents the incidence of vertex $i$ on edge $j$.\n\n**1. Algorithm for Constructing the Incidence Matrix $B$**\n\nThe construction of $B$ is dictated by the degree recovery property, which states that the degree vector $\\mathbf{d}$ must be recoverable via the product $\\mathbf{d} = B \\mathbf{1}_m$, where $\\mathbf{1}_m$ is the $m$-dimensional all-ones column vector. The degree of a vertex $v$ is defined as the number of edge endpoints incident to it, with loops contributing $2$ to the degree of their vertex.\n\nTo satisfy this, we must define the columns of $B$ corresponding to each edge such that the sum over each row of $B$ equals the degree of the corresponding vertex.\n\nLet's consider an arbitrary edge $e_j = (u_k, v_l) \\in E$.\n\n-   **Case 1: Non-loop edge** ($u_k \\neq v_l$). This edge has two distinct endpoints, $u_k$ and $v_l$. It must contribute $1$ to the degree of $u_k$ and $1$ to the degree of $v_l$. To achieve this via the product $B \\mathbf{1}_m$, the sum of the $j$-th column of $B$ must be $2$, distributed as a $1$ for each vertex. Therefore, for the $j$-th column of $B$, we set $B_{u_k, j} = 1$ and $B_{v_l, j} = 1$. All other entries in this column, $B_{i,j}$ for $i \\notin \\{u_k, v_l\\}$, are $0$.\n\n-   **Case 2: Loop edge** ($u_k = v_l$). A loop at vertex $u_k$ contributes $2$ to the degree of $u_k$. To ensure this, the contribution from the edge $e_j$ must be entirely focused on vertex $u_k$. Thus, for the $j$-th column of $B$, we set $B_{u_k, j} = 2$. All other entries in this column, $B_{i,j}$ for $i \\neq u_k$, are $0$.\n\nThis construction uniquely defines the matrix $B$ for any given graph $G=(V, E)$. The algorithm is as follows:\n1.  Initialize an $n \\times m$ matrix $B$ with all entries set to $0$. Let $m$ be the number of edges in the input list $E$.\n2.  Iterate through the edge list $E$ with index $j = 0, \\ldots, m-1$. For each edge $e_j = (u,v)$:\n    a. If $u \\neq v$, set $B_{u,j} = 1$ and $B_{v,j} = 1$.\n    b. If $u = v$, set $B_{u,j} = 2$.\n3.  The resulting matrix $B$ is the required incidence matrix.\n\n**2. Validation Criteria**\n\n**Criterion 1: Shape Correctness**\nThe construction directly yields a matrix with $n$ rows (for the $n$ vertices) and $m$ columns (for the $m$ edges). The shape is thus $n \\times m$, satisfying the first criterion. A special case is when $E$ is empty, meaning $m=0$. In this case, $B$ is an $n \\times 0$ matrix.\n\n**Criterion 2: Degree Correctness**\nThe degree of vertex $i$, $d_i$, is the $i$-th element of the vector $\\mathbf{d} = B \\mathbf{1}_m$. This is calculated as $d_i = \\sum_{j=0}^{m-1} B_{i,j} \\cdot 1 = \\sum_{j=0}^{m-1} B_{i,j}$. This sum accumulates the contributions from each edge. According to our construction:\n-   A non-loop edge incident to vertex $i$ contributes $1$ to the sum (as $B_{i,j} = 1$).\n-   A loop at vertex $i$ contributes $2$ to the sum (as $B_{i,j} = 2$).\n-   Edges not incident to vertex $i$ contribute $0$.\nThe sum is therefore $(\\text{number of non-loop edges at } i) + 2 \\times (\\text{number of loops at } i)$, which is the definition of degree provided. This confirms the validity of the degree-recovery property for our construction. For $m=0$, the degree vector is correctly the zero vector.\n\n**Criterion 3: Pair Multiplicity Correctness**\nWe need to verify that for $u \\neq v$, the off-diagonal entry $(B B^\\top)_{uv}$ equals the number of edges between vertices $u$ and $v$. The matrix product $B B^\\top$ is an $n \\times n$ matrix. Its $(u,v)$-th entry is given by the dot product of the $u$-th row and $v$-th row of $B$:\n$$ (B B^\\top)_{uv} = \\sum_{j=0}^{m-1} B_{uj} B_{vj} $$\nLet's analyze the term $B_{uj} B_{vj}$ for each edge $e_j$:\n-   If $e_j=(p,q)$ is a non-loop edge, its corresponding column $j$ in $B$ has two non-zero entries: $B_{pj}=1$ and $B_{qj}=1$. The product $B_{uj} B_{vj}$ is non-zero only if $\\{u, v\\} = \\{p, q\\}$. In this case, $B_{uj} B_{vj} = 1 \\cdot 1 = 1$. For all other pairs of rows $(u', v')$, the product is $0$.\n-   If $e_j=(p,p)$ is a loop, its column $j$ has one non-zero entry: $B_{pj}=2$. Since we are considering an off-diagonal entry where $u \\neq v$, it is impossible for both $B_{uj}$ and $B_{vj}$ to be non-zero. Thus, $B_{uj} B_{vj} = 0$.\n\nThe sum $\\sum_{j=0}^{m-1} B_{uj} B_{vj}$ therefore counts $1$ for each time an edge exists between vertices $u$ and $v$. This sum is precisely the multiplicity of the edge $\\{u,v\\}$. Loops correctly do not contribute to off-diagonal entries. This confirms the structural property. For $m=0$, $B B^\\top$ is the $n \\times n$ zero matrix, and all multiplicities are correctly $0$.\n\nThe implemented algorithm will follow these principles, constructing the matrix $B$ and performing the specified numerical checks for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and validates the incidence matrix for multigraphs according to the problem specification.\n    \"\"\"\n    # Test suite as defined in the problem statement.\n    # Each tuple contains:\n    # 1. n (number of vertices)\n    # 2. E (edge list)\n    # 3. expected_degrees (the ground truth degree vector)\n    # 4. pairs_to_check (a list of ((u, v), expected_multiplicity) tuples)\n    test_suite = [\n        (6, [(0, 1), (1, 2), (2, 2), (3, 4), (3, 4), (4, 4)], [1, 2, 3, 2, 4, 0], [((3, 4), 2), ((0, 1), 1), ((1, 2), 1)]),\n        (3, [(0, 0), (0, 0), (2, 2)], [4, 0, 2], [((0, 1), 0)]),\n        (4, [], [0, 0, 0, 0], [((0, 1), 0)]),\n        (5, [(0, 3), (0, 3), (0, 3), (1, 1), (2, 4)], [3, 2, 1, 3, 1], [((0, 3), 3), ((2, 4), 1), ((0, 2), 0)]),\n        (2, [(0, 1), (1, 1)], [1, 3], [((0, 1), 1)]),\n    ]\n\n    results = []\n\n    for n, E, expected_degrees, pairs_to_check in test_suite:\n        m = len(E)\n\n        # Initialize the n x m incidence matrix B with zeros.\n        # Ensure it has the correct integer type.\n        B = np.zeros((n, m), dtype=int)\n\n        # Populate the incidence matrix B based on the edge list.\n        for j, edge in enumerate(E):\n            u, v = edge\n            if u == v:  # Loop edge\n                B[u, j] = 2\n            else:  # Non-loop edge\n                B[u, j] = 1\n                B[v, j] = 1\n\n        # --- Validation ---\n        all_criteria_passed = True\n\n        # Criterion 1: Shape correctness\n        # The shape of B must be n x m.\n        if B.shape != (n, m):\n            all_criteria_passed = False\n\n        # Criterion 2: Degree correctness\n        # The calculated degree vector d = B * 1_m must match the expected degrees.\n        # numpy handles the m=0 case correctly, producing a zero vector.\n        if m > 0:\n            ones_m = np.ones(m, dtype=int)\n            calculated_degrees = B @ ones_m\n        else:\n            calculated_degrees = np.zeros(n, dtype=int)\n\n        if not np.array_equal(calculated_degrees, np.array(expected_degrees)):\n            all_criteria_passed = False\n        \n        # Criterion 3: Pair multiplicity correctness\n        # The off-diagonal entries of B * B^T must match pair multiplicities.\n        # numpy handles the m=0 case correctly, producing a zero matrix.\n        if m > 0:\n            BB_T = B @ B.T\n        else:\n            BB_T = np.zeros((n, n), dtype=int)\n\n        for (u, v), expected_multiplicity in pairs_to_check:\n            # Check (u, v) entry. Since BB_T is symmetric, (v, u) is identical.\n            if BB_T[u, v] != expected_multiplicity:\n                all_criteria_passed = False\n                break # A single failure is enough for this criterion\n        \n        results.append(all_criteria_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\nsolve()\n\n```"
        }
    ]
}