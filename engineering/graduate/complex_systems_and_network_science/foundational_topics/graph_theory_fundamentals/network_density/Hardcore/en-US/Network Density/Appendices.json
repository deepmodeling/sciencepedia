{
    "hands_on_practices": [
        {
            "introduction": "To build a strong intuition for network density, it is useful to apply the concept to canonical graph structures that represent extremes of connectivity. This first exercise  asks you to calculate the density for two such archetypes: the complete graph ($K_n$), which represents maximum interconnectedness, and the star graph ($S_n$), a minimally connected tree structure. By deriving their densities, you will see how the measure $D$ quantitatively captures the vast structural differences between a fully decentralized and a highly centralized network.",
            "id": "4290435",
            "problem": "Consider simple, undirected networks with $n \\geq 2$ nodes, with no self-loops and no multiple edges. Let $S_n$ denote the star graph on $n$ nodes, consisting of a single hub node adjacent to all other $n-1$ nodes (which are leaves), and let $K_n$ denote the complete graph on $n$ nodes, in which every unordered pair of distinct nodes is connected by an edge. Network density $D$ is defined conceptually as the proportion of realized ties relative to the maximum number of ties that could exist under the same constraints. Using this conceptual definition as the foundational basis, compute the exact symbolic expressions for $D$ in terms of $n$ for $S_n$ and for $K_n$. Then, briefly interpret how these values of $D$ reflect structural extremes in simple, undirected networks. Express your final answer as a two-entry row matrix $\\left(D(S_n),\\,D(K_n)\\right)$, with each entry given in closed form as a function of $n$. No rounding is required, and no units are needed.",
            "solution": "The problem is well-defined and based on fundamental concepts in network science and graph theory. The definitions for simple, undirected networks, star graphs ($S_n$), complete graphs ($K_n$), and network density ($D$) are standard and self-consistent. The constraint $n \\geq 2$ is appropriate for the context.\n\nThe first step is to formalize the conceptual definition of network density. For a simple, undirected graph with $n$ nodes, a \"tie\" is an edge. The density $D$ is the ratio of the number of actual edges, $|E|$, to the maximum possible number of edges, $|E_{max}|$.\n$$D = \\frac{|E|}{|E_{max}|}$$\nThe maximum number of edges in a simple graph with $n$ nodes occurs when every distinct pair of nodes is connected by an edge. The number of ways to choose $2$ distinct nodes from a set of $n$ nodes is given by the binomial coefficient $\\binom{n}{2}$. Therefore, the maximum number of edges is:\n$$|E_{max}| = \\binom{n}{2} = \\frac{n(n-1)}{2}$$\nThis expression for $|E_{max}|$ is valid for $n \\geq 2$.\n\nNext, we calculate the density for the star graph, $S_n$. A star graph on $n$ nodes consists of a central \"hub\" node connected to the remaining $n-1$ \"leaf\" nodes. There are no edges between the leaf nodes. The number of edges is therefore equal to the number of connections from the hub, which is $n-1$.\n$$|E(S_n)| = n-1$$\nThe density of the star graph, $D(S_n)$, is the ratio of its actual edges to the maximum possible edges:\n$$D(S_n) = \\frac{|E(S_n)|}{|E_{max}|} = \\frac{n-1}{\\frac{n(n-1)}{2}}$$\nFor $n \\geq 2$, the term $n-1$ is non-zero, allowing for simplification.\n$$D(S_n) = \\frac{1}{\\frac{n}{2}} = \\frac{2}{n}$$\nThis formula correctly handles the case $n=2$, where $S_2$ is identical to $K_2$, yielding $D(S_2) = \\frac{2}{2} = 1$.\n\nNow, we calculate the density for the complete graph, $K_n$. By definition, a complete graph on $n$ nodes contains every possible edge between its $n$ nodes. Thus, the number of edges in $K_n$ is equal to the maximum possible number of edges.\n$$|E(K_n)| = |E_{max}| = \\frac{n(n-1)}{2}$$\nThe density of the complete graph, $D(K_n)$, is therefore:\n$$D(K_n) = \\frac{|E(K_n)|}{|E_{max}|} = \\frac{\\frac{n(n-1)}{2}}{\\frac{n(n-1)}{2}} = 1$$\nThis result holds for all $n \\geq 2$, as $|E_{max}| > 0$.\n\nLastly, we interpret these values. The star graph $S_n$ and the complete graph $K_n$ represent two extremes of network structure.\nThe density of the complete graph, $D(K_n)=1$, is the maximum possible density for any simple graph. It represents a state of maximum interconnectedness, where a path of length $1$ exists between any two nodes.\nThe density of the star graph, $D(S_n) = \\frac{2}{n}$, approaches $0$ as the number of nodes $n$ becomes large ($D(S_n) \\to 0$ as $n \\to \\infty$). This indicates a very sparse network. The star graph is a tree, which is a minimally connected graph; it contains the smallest number of edges ($n-1$) required for a graph on $n$ nodes to be connected. Thus, $S_n$ represents an extreme of sparsity and centralization, where connectivity is maintained through the most economical number of edges, all routed through a single hub. Together, $S_n$ and $K_n$ bound the range of densities for connected simple graphs on $n$ nodes, from nearly $0$ to exactly $1$.",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{2}{n} & 1 \\end{pmatrix}}$$"
        },
        {
            "introduction": "Moving from specific graph instances to the properties of large-scale networks, this practice  explores the crucial relationship between a network's average degree and its density. You will derive the asymptotic behavior of density for graphs where the average degree remains constant as the network grows—a common feature of many real-world systems. This exercise formally establishes the concept of a 'sparse' graph ($D=\\mathcal{O}(1/n)$) and touches upon its profound implications for computational algorithm design.",
            "id": "4290374",
            "problem": "Consider a sequence of simple undirected graphs $G_{n}$ with $n$ vertices, no self-loops, and a symmetric, hollow adjacency matrix $A^{(n)} \\in \\{0,1\\}^{n \\times n}$. Let the average degree $\\bar{k}(n)$ satisfy $\\lim_{n \\to \\infty} \\bar{k}(n) = c$ for some fixed constant $c$ with $0 < c < \\infty$. The network density $D(n)$ is defined as the proportion of realized undirected edges among all possible undirected edges without self-loops on $n$ vertices. Starting only from fundamental graph relationships (specifically, the conservation of incidence across edges and the combinatorial count of possible undirected edges), derive an expression for $D(n)$ in terms of $n$ and $\\bar{k}(n)$, and compute the limit $L = \\lim_{n \\to \\infty} n \\, D(n)$. Additionally, justify, in terms of asymptotic orders, a regime in which $D(n)$ vanishes as $n$ grows, and explain one algorithmic implication for the sparsity of $A^{(n)}$ (for example, storage or time complexity considerations). Report the single symbolic value $L$ as your final answer. No rounding is required.",
            "solution": "The problem statement is validated as scientifically sound, well-posed, and objective. All definitions and conditions are standard in graph theory and network science. We may proceed with the solution.\n\nThe problem asks for a derivation of the network density $D(n)$ for a sequence of simple undirected graphs $G_n$, the computation of a related limit $L$, and a discussion on the implications of the graph's structure.\n\nFirst, we derive an expression for the network density $D(n)$ in terms of the number of vertices $n$ and the average degree $\\bar{k}(n)$. The derivation starts from the fundamental relationship between the degrees of vertices and the number of edges in a graph.\n\nLet $E(n)$ be the number of edges in the graph $G_n$, which has $n$ vertices. For any undirected graph, the sum of the degrees of all vertices is equal to twice the number of edges. This is known as the Handshaking Lemma. If $k_i(n)$ is the degree of vertex $i$ in graph $G_n$, then:\n$$ \\sum_{i=1}^{n} k_i(n) = 2E(n) $$\nThe average degree $\\bar{k}(n)$ is defined as the total sum of degrees divided by the number of vertices $n$:\n$$ \\bar{k}(n) = \\frac{1}{n} \\sum_{i=1}^{n} k_i(n) $$\nBy substituting the expression for the sum of degrees into the definition of the average degree, we obtain a relationship between $\\bar{k}(n)$, $E(n)$, and $n$:\n$$ \\bar{k}(n) = \\frac{2E(n)}{n} $$\nFrom this equation, we can express the number of realized edges, $E(n)$, in terms of $n$ and $\\bar{k}(n)$:\n$$ E(n) = \\frac{n \\bar{k}(n)}{2} $$\nThe network density $D(n)$ is defined as the proportion of realized edges among all possible edges. For a simple graph with $n$ vertices (no self-loops), the maximum possible number of undirected edges is the number of ways to choose $2$ distinct vertices from the set of $n$ vertices. This is given by the binomial coefficient $\\binom{n}{2}$:\n$$ \\binom{n}{2} = \\frac{n(n-1)}{2} $$\nNow, we can write the expression for the network density $D(n)$ as the ratio of the number of realized edges $E(n)$ to the maximum possible number of edges:\n$$ D(n) = \\frac{E(n)}{\\binom{n}{2}} = \\frac{\\frac{n \\bar{k}(n)}{2}}{\\frac{n(n-1)}{2}} $$\nSimplifying this expression by canceling the common factors of $\\frac{n}{2}$ in the numerator and denominator yields the desired expression for $D(n)$:\n$$ D(n) = \\frac{\\bar{k}(n)}{n-1} $$\nNext, we are asked to compute the limit $L = \\lim_{n \\to \\infty} n \\, D(n)$. We substitute the derived expression for $D(n)$:\n$$ L = \\lim_{n \\to \\infty} n \\left( \\frac{\\bar{k}(n)}{n-1} \\right) $$\nWe can rewrite this as the product of two limits:\n$$ L = \\lim_{n \\to \\infty} \\left( \\frac{n}{n-1} \\right) \\cdot \\lim_{n \\to \\infty} \\bar{k}(n) $$\nThe first limit can be evaluated as:\n$$ \\lim_{n \\to \\infty} \\frac{n}{n-1} = \\lim_{n \\to \\infty} \\frac{n}{n(1 - \\frac{1}{n})} = \\lim_{n \\to \\infty} \\frac{1}{1 - \\frac{1}{n}} = \\frac{1}{1-0} = 1 $$\nThe problem statement provides that $\\lim_{n \\to \\infty} \\bar{k}(n) = c$, where $c$ is a fixed positive constant. Therefore, the second limit is $c$.\nCombining these results, we find the value of $L$:\n$$ L = 1 \\cdot c = c $$\nThe regime in which $D(n)$ vanishes as $n$ grows is precisely the one specified by the problem: a sequence of graphs where the average degree $\\bar{k}(n)$ converges to a finite constant $c$. In this regime, the asymptotic order of $D(n)$ is:\n$$ D(n) = \\frac{\\bar{k}(n)}{n-1} = O\\left(\\frac{1}{n}\\right) $$\nSince $\\lim_{n \\to \\infty} \\frac{1}{n} = 0$, the density $D(n)$ vanishes as $n$ becomes large. This is the definition of a sparse graph. A dense graph, by contrast, would have $D(n)$ approaching a non-zero constant, which would necessitate that $\\bar{k}(n)$ grows proportionally with $n$, i.e., $\\bar{k}(n) = O(n)$.\n\nFinally, we discuss an algorithmic implication for the sparsity of the adjacency matrix $A^{(n)}$. The matrix $A^{(n)}$ is an $n \\times n$ matrix. The number of non-zero entries in a symmetric adjacency matrix without self-loops is equal to $2E(n)$. From our derivation, $2E(n) = n \\bar{k}(n)$. Given that $\\bar{k}(n)$ approaches a constant $c$, the number of non-zero entries is asymptotically $c n$, which is of order $O(n)$. The total number of entries in the matrix is $n^2$. Since the number of non-zero entries $O(n)$ grows much slower than the total number of entries $O(n^2)$, the matrix is sparse.\n\nAn important algorithmic implication of this sparsity relates to data storage. Storing the full $n \\times n$ adjacency matrix would require $O(n^2)$ memory. For large $n$, this becomes prohibitive. However, because the matrix is sparse, one can use more efficient data structures. For example, an adjacency list representation stores for each vertex only the list of its neighbors. The total memory required for an adjacency list is the sum of the degrees of all vertices, which is $\\sum k_i(n) = 2E(n) = n\\bar{k}(n)$. In this regime, the storage complexity is $O(n)$. This reduction in memory requirement from $O(n^2)$ to $O(n)$ is crucial for handling large-scale networks and enables the application of graph algorithms that would be computationally intractable with a dense matrix representation.",
            "answer": "$$ \\boxed{c} $$"
        },
        {
            "introduction": "The final step in mastering a concept is translating it into a working computational tool. This problem  challenges you to design and analyze an efficient algorithm for calculating network density from an adjacency list representation, a standard data structure for storing sparse graphs. Proving the algorithm's $\\mathcal{O}(n+m)$ time complexity will solidify your understanding of why the insights from the previous exercise on sparsity are not just theoretical, but essential for practical network analysis.",
            "id": "4290385",
            "problem": "You are given a finite network modeled as a simple graph, where a simple graph is defined here as having no parallel edges and no self-loops. Let the graph be represented as adjacency lists: for each vertex index $i$ in a vertex set $V$ with $|V| = n$, an array of neighbor indices $L_i$ specifies its out-neighbors if the graph is directed, or its neighbors if the graph is undirected. The network density is defined as the ratio of the number of observed links to the maximum number of links possible under the constraints stated above, with the interpretation of \"links\" respecting the graph’s directionality. Design a single-pass algorithm whose running time is Big-Oh $\\mathcal{O}(n+m)$, where $m$ is the number of edges, that computes the density directly from the adjacency lists. Prove the correctness and the time complexity of your algorithm starting from first principles and well-tested facts in graph theory, and justify how your algorithm treats the degenerate cases where $n \\leq 1$. Implement the algorithm exactly as specified, and apply it to the following test suite.\n\nThe test suite consists of graphs with vertices labeled $0,1,\\dots,n-1$. Each test case is defined by an explicit list of adjacency arrays and a boolean that indicates whether the graph is directed ($\\text{True}$) or undirected ($\\text{False}$). The adjacency lists conform to the constraints: no self-loops, no parallel edges, and for undirected graphs, symmetric adjacency (if $u$ lists $v$, then $v$ lists $u$).\n\nTest cases:\n- Case A (undirected path): $n=5$, adjacency lists $L_0=[1]$, $L_1=[0,2]$, $L_2=[1,3]$, $L_3=[2,4]$, $L_4=[3]$, directed flag $\\text{False}$.\n- Case B (undirected complete graph): $n=4$, adjacency lists $L_0=[1,2,3]$, $L_1=[0,2,3]$, $L_2=[0,1,3]$, $L_3=[0,1,2]$, directed flag $\\text{False}$.\n- Case C (directed empty graph): $n=3$, adjacency lists $L_0=[\\,]$, $L_1=[\\,]$, $L_2=[\\,]$, directed flag $\\text{True}$.\n- Case D (directed complete graph without self-loops): $n=4$, adjacency lists $L_0=[1,2,3]$, $L_1=[0,2,3]$, $L_2=[0,1,3]$, $L_3=[0,1,2]$, directed flag $\\text{True}$.\n- Case E (undirected single-vertex graph): $n=1$, adjacency lists $L_0=[\\,]$, directed flag $\\text{False}$.\n- Case F (directed single-vertex graph): $n=1$, adjacency lists $L_0=[\\,]$, directed flag $\\text{True}$.\n- Case G (empty graph with no vertices): $n=0$, adjacency lists are the empty family $[\\,]$, directed flag $\\text{True}$.\n\nYour program should produce a single line of output containing the results of all seven test cases in order, as a comma-separated list enclosed in square brackets (for example, $[x_A,x_B,x_C,x_D,x_E,x_F,x_G]$). Each entry must be a decimal number (float). No physical units or angle units are involved in this task. Treat degenerate cases by returning a density of $0$ when the maximum possible number of links is $0$. The final algorithm must use only a number of operations proportional to $n+m$ and must not rely on any preprocessing beyond iterating through the adjacency lists.",
            "solution": "The problem as stated is valid. It is scientifically grounded in the domain of graph theory, well-posed with all necessary definitions and constraints provided, and objective in its formulation. We can therefore proceed with a solution.\n\nThe core task is to compute the network density, $\\rho$, defined as the ratio of the count of observed edges, $m$, to the maximum possible count of edges, $m_{\\text{max}}$, in a simple graph.\n$$ \\rho = \\frac{m}{m_{\\text{max}}} $$\nThe algorithm must derive this from an adjacency list representation in $\\mathcal{O}(n+m)$ time, where $n$ is the number of vertices and $m$ is the number of edges.\n\nThe derivation of the algorithm proceeds in several steps: calculating $m$, calculating $m_{\\text{max}}$, handling degenerate cases, and finally analyzing the algorithm's performance.\n\n**1. Computation of Observed Edges ($m$)**\n\nThe number of observed edges, $m$, is determined by summing the lengths of the provided adjacency lists, $\\{L_i\\}_{i=0}^{n-1}$, and interpreting this sum based on the graph's directionality. The sum of the lengths of the adjacency lists, $M = \\sum_{i=0}^{n-1} |L_i|$, represents the sum of degrees (for an undirected graph) or out-degrees (for a directed graph) over all vertices.\n\n*   **Directed Graph**: In a directed graph, each entry in an adjacency list $L_i$ corresponds to a unique directed edge originating from vertex $i$. Therefore, the total number of edges $m$ is precisely the sum of the out-degrees of all vertices.\n    $$ m_{\\text{directed}} = \\sum_{i=0}^{n-1} \\text{deg}^+(v_i) = \\sum_{i=0}^{n-1} |L_i| $$\n\n*   **Undirected Graph**: In an undirected graph, each edge $\\{u, v\\}$ is accounted for twice in the adjacency list representation: once as $v \\in L_u$ and once as $u \\in L_v$. This is a direct consequence of the Handshaking Lemma, which states that the sum of the degrees of all vertices is equal to twice the number of edges ($\\sum_{v \\in V} \\text{deg}(v) = 2m$). Consequently, $m$ is half the sum of the lengths of the adjacency lists.\n    $$ m_{\\text{undirected}} = \\frac{1}{2} \\sum_{i=0}^{n-1} |L_i| $$\n\n**2. Computation of Maximum Possible Edges ($m_{\\text{max}}$)**\n\nThe maximum number of edges depends on the number of vertices $n$ and whether the graph is directed or undirected, under the constraint that the graph is simple (no self-loops and no parallel edges).\n\n*   **Undirected Graph**: For an undirected simple graph with $n$ vertices, the maximum number of edges corresponds to a complete graph, $K_n$. An edge can be placed between any distinct pair of vertices. The number of ways to choose $2$ vertices from a set of $n$ is given by the binomial coefficient $\\binom{n}{2}$.\n    $$ m_{\\text{max}}^{\\text{undirected}} = \\binom{n}{2} = \\frac{n(n-1)}{2} $$\n\n*   **Directed Graph**: For a directed simple graph with $n$ vertices, the maximum number of edges occurs when for every ordered pair of distinct vertices $(u, v)$, there is a directed edge from $u$ to $v$. The total number of such ordered pairs is $n(n-1)$.\n    $$ m_{\\text{max}}^{\\text{directed}} = n(n-1) $$\n\n**3. Handling of Degenerate Cases ($n \\le 1$)**\n\nThe problem provides a specific directive for cases where the denominator $m_{\\text{max}}$ might be zero: \"Treat degenerate cases by returning a density of $0$ when the maximum possible number of links is $0$.\"\n\nWe analyze when $m_{\\text{max}} = 0$:\n*   For both undirected and directed graphs, the formulae for $m_{\\text{max}}$ involve the term $n(n-1)$. This term equals $0$ if and only if $n=0$ or $n=1$.\n*   Thus, for any graph with $n \\le 1$ vertices, $m_{\\text{max}} = 0$. Adhering to the problem's rule, the density for these cases is defined to be $0$. This approach resolves the potential for division by zero and provides a consistent, meaningful value for these trivial graph structures. For any $n>1$, $m_{\\text{max}}$ is strictly positive.\n\n**4. Algorithm Design and Complexity Analysis**\n\nBased on the preceding principles, a single-pass algorithm is designed as follows:\n1.  Given the number of vertices $n$, first check if $n \\le 1$. If true, the density is $0.0$, and the computation for this case is complete.\n2.  If $n > 1$, initialize a counter `total_degree_sum` to $0$.\n3.  Perform a single pass through the adjacency list representation. Iterate from $i=0$ to $n-1$, and for each vertex $i$, add the length of its adjacency list, $|L_i|$, to `total_degree_sum`.\n4.  Calculate the number of observed edges, $m$. If the graph is directed, $m = \\text{total\\_degree\\_sum}$. If it is undirected, $m = \\text{total\\_degree\\_sum} / 2$.\n5.  Calculate the maximum possible number of edges, $m_{\\text{max}}$. If the graph is directed, $m_{\\text{max}} = n(n-1)$. If it is undirected, $m_{\\text{max}} = n(n-1)/2$.\n6.  Compute the final density as $\\rho = m/m_{\\text{max}}$.\n\n**Correctness and Time Complexity Proof**:\n*   **Correctness**: The algorithm's correctness is guaranteed as it is a direct implementation of the foundational definitions of edge counting from degree sums (as established by the Handshaking Lemma for the undirected case) and the standard combinatorial formulae for the number of edges in complete simple graphs. The explicit handling of the $n \\le 1$ base cases ensures correctness across all possible values of $n \\ge 0$.\n*   **Time Complexity**: The computational cost is dominated by Step 3, which involves iterating through the adjacency lists. This requires visiting each of the $n$ vertices and, for each vertex, traversing its list of neighbors. The total number of neighbor-list elements traversed is $M = \\sum_{i=0}^{n-1} |L_i|$. As shown previously, $M$ is either $m$ (directed) or $2m$ (undirected), making $M$ proportional to $m$, i.e., $M \\in \\mathcal{O}(m)$. The total time complexity for this step is therefore $\\mathcal{O}(n+M) = \\mathcal{O}(n+m)$. All other steps involve a constant number of arithmetic operations, taking $\\mathcal{O}(1)$ time. The algorithm's total time complexity is thus $\\mathcal{O}(n+m)$, satisfying the problem's requirements.\n\nBelow is a Python implementation of the algorithm.\n\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes network density for a suite of test cases.\n    \"\"\"\n    \n    # Each test case is a dictionary specifying the graph's properties.\n    test_cases = [\n        # Case A (undirected path)\n        {'n': 5, 'adj_lists': [[1], [0, 2], [1, 3], [2, 4], [3]], 'is_directed': False},\n        # Case B (undirected complete graph)\n        {'n': 4, 'adj_lists': [[1, 2, 3], [0, 2, 3], [0, 1, 3], [0, 1, 2]], 'is_directed': False},\n        # Case C (directed empty graph)\n        {'n': 3, 'adj_lists': [[], [], []], 'is_directed': True},\n        # Case D (directed complete graph without self-loops)\n        {'n': 4, 'adj_lists': [[1, 2, 3], [0, 2, 3], [0, 1, 3], [0, 1, 2]], 'is_directed': True},\n        # Case E (undirected single-vertex graph)\n        {'n': 1, 'adj_lists': [[]], 'is_directed': False},\n        # Case F (directed single-vertex graph)\n        {'n': 1, 'adj_lists': [[]], 'is_directed': True},\n        # Case G (empty graph with no vertices)\n        {'n': 0, 'adj_lists': [], 'is_directed': True}\n    ]\n\n    def calculate_density(n: int, adj_lists: list, is_directed: bool) -> float:\n        \"\"\"\n        Calculates the density of a simple graph in O(n+m) time.\n\n        Args:\n            n: The number of vertices.\n            adj_lists: The adjacency list representation of the graph.\n            is_directed: A boolean indicating if the graph is directed.\n\n        Returns:\n            The density of the graph as a float.\n        \"\"\"\n        # Per the problem statement, for n = 1, the maximum possible number\n        # of edges is 0. In this case, the density is defined as 0.\n        if n = 1:\n            return 0.0\n\n        # Calculate the sum of the lengths of all adjacency lists.\n        # This is the sum of out-degrees for directed graphs, or the sum of \n        # degrees for undirected graphs. This step takes O(n+m) time.\n        total_degree_sum = sum(len(neighbors) for neighbors in adj_lists)\n\n        # Calculate the number of observed edges (m).\n        if is_directed:\n            m = float(total_degree_sum)\n        else:\n            # For an undirected graph, sum of degrees is 2*m.\n            m = float(total_degree_sum) / 2.0\n\n        # Calculate the maximum possible number of edges (m_max).\n        if is_directed:\n            # For a simple directed graph, the max edges is n*(n-1).\n            m_max = float(n * (n - 1))\n        else:\n            # For a simple undirected graph, the max edges is nC2 = n*(n-1)/2.\n            m_max = float(n * (n - 1)) / 2.0\n        \n        # At this point, n > 1, so m_max is guaranteed to be non-zero.\n        density = m / m_max\n        return density\n\n    results = []\n    for case in test_cases:\n        result = calculate_density(case['n'], case['adj_lists'], case['is_directed'])\n        results.append(result)\n\n    # The problem asks for the output as the final answer.\n    # We can print it to see what the script produces.\n    # print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```",
            "answer": "[0.4,1.0,0.0,1.0,0.0,0.0,0.0]"
        }
    ]
}