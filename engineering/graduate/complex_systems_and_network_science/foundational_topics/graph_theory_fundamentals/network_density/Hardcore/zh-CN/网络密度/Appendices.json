{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握一个网络度量，最好的方法是从基本定义出发，并将其应用于典型的示例中。这个练习将网络密度的概念应用于两种极端的网络结构：星形图 ($S_n$) 和完全图 ($K_n$) 。通过从第一性原理推导它们的密度表达式，您将对稀疏和稠密网络的含义建立起直观的理解，并领会密度如何量化网络的整体连通性。",
            "id": "4290435",
            "problem": "考虑具有 $n \\geq 2$ 个节点的简单无向网络，网络中无自环也无重边。设 $S_n$ 表示 $n$ 个节点上的星形图，它由一个中心节点与所有其他 $n-1$ 个节点（叶节点）相邻构成；设 $K_n$ 表示 $n$ 个节点上的完全图，其中每一对不同的无序节点都由一条边连接。网络密度 $D$ 的概念性定义为：在相同约束下，已实现的连接数与可能存在的最大连接数之比。以此概念性定义为基础，计算 $S_n$ 和 $K_n$ 的网络密度 $D$ 关于 $n$ 的精确符号表达式。然后，简要解释这些 $D$ 值如何反映简单无向网络中的结构极端情况。将最终答案表示为一个二元行矩阵 $\\left(D(S_n),\\,D(K_n)\\right)$，其中每个元素都以 $n$ 的闭式函数形式给出。无需四舍五入，也无需单位。",
            "solution": "该问题定义明确，基于网络科学和图论的基本概念。简单无向网络、星形图 ($S_n$)、完全图 ($K_n$) 和网络密度 ($D$) 的定义都是标准且自洽的。约束条件 $n \\geq 2$ 在此背景下是合适的。\n\n第一步是形式化网络密度的概念性定义。对于一个有 $n$ 个节点的简单无向图，一个“连接”就是一条边。密度 $D$ 是实际边数 $|E|$ 与最大可能边数 $|E_{max}|$ 的比值。\n$$D = \\frac{|E|}{|E_{max}|}$$\n在一个有 $n$ 个节点的简单图中，当每一对不同节点之间都有一条边连接时，边数达到最大值。从 $n$ 个节点中选取 $2$ 个不同节点的方法数由二项式系数 $\\binom{n}{2}$ 给出。因此，最大边数为：\n$$|E_{max}| = \\binom{n}{2} = \\frac{n(n-1)}{2}$$\n这个 $|E_{max}|$ 的表达式对 $n \\geq 2$ 成立。\n\n接下来，我们计算星形图 $S_n$ 的密度。一个有 $n$ 个节点的星形图由一个中心“枢纽”节点连接到其余 $n-1$ 个“叶”节点构成。叶节点之间没有边。因此，边数等于从枢纽节点出发的连接数，即 $n-1$。\n$$|E(S_n)| = n-1$$\n星形图的密度 $D(S_n)$ 是其实际边数与最大可能边数的比值：\n$$D(S_n) = \\frac{|E(S_n)|}{|E_{max}|} = \\frac{n-1}{\\frac{n(n-1)}{2}}$$\n对于 $n \\geq 2$，$n-1$ 项不为零，因此可以进行化简。\n$$D(S_n) = \\frac{1}{\\frac{n}{2}} = \\frac{2}{n}$$\n该公式能正确处理 $n=2$ 的情况，此时 $S_2$ 与 $K_2$ 相同，得出 $D(S_2) = \\frac{2}{2} = 1$。\n\n现在，我们计算完全图 $K_n$ 的密度。根据定义，一个有 $n$ 个节点的完全图包含其 $n$ 个节点之间所有可能的边。因此，$K_n$ 中的边数等于最大可能边数。\n$$|E(K_n)| = |E_{max}| = \\frac{n(n-1)}{2}$$\n因此，完全图的密度 $D(K_n)$ 为：\n$$D(K_n) = \\frac{|E(K_n)|}{|E_{max}|} = \\frac{\\frac{n(n-1)}{2}}{\\frac{n(n-1)}{2}} = 1$$\n这个结果对所有 $n \\geq 2$ 都成立，因为 $|E_{max}| > 0$。\n\n最后，我们对这些值进行解释。星形图 $S_n$ 和完全图 $K_n$ 代表了网络结构的两种极端情况。\n完全图的密度 $D(K_n)=1$，是任何简单图可能达到的最大密度。它代表了一种最大程度互联的状态，其中任意两个节点之间都存在长度为 $1$ 的路径。\n星形图的密度 $D(S_n) = \\frac{2}{n}$，当节点数 $n$ 变得很大时，该密度趋近于 $0$（当 $n \\to \\infty$ 时，$D(S_n) \\to 0$）。这表明网络非常稀疏。星形图是一种树，而树是最小连通图；它包含了使一个 $n$ 节点图保持连通所需的最少边数（$n-1$ 条）。因此，$S_n$ 代表了稀疏性和中心化的一个极端，其连通性通过最经济的边数来维持，且所有边都经过一个单一的枢纽节点。总而言之，$S_n$ 和 $K_n$ 界定了 $n$ 节点连通简单图的密度范围，从接近 $0$ 到恰好为 $1$。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{2}{n}  1 \\end{pmatrix}}$$"
        },
        {
            "introduction": "网络不仅是静态的，它们还会随时间演化，例如节点的加入或离开。理解单个节点的变化如何影响全局网络属性是网络科学中的一个核心问题。此练习引导您推导当移除一个节点时，网络全局密度发生变化的精确表达式 。这个推导过程不仅能锻炼您的分析能力，还能揭示一个深刻的原理：节点移除对网络密度的影响取决于该节点的度与网络平均度的关系。",
            "id": "4290433",
            "problem": "考虑一个包含 $n$ 个节点和 $m$ 条边的简单无向无权图，该图无自环、无重边。全局网络密度定义为图中现有边数与最大可能边数的比率。现移除一个度为 $k$ 的节点 $v$ 及其所有邻接边。请从图密度和 $n$ 个节点间可能边数的组合计数的核心定义出发，依据第一性原理，推导出一个因移除节点 $v$ 而引起的全局密度变化 $\\Delta D$ 的精确表达式，该表达式应为 $n$、$m$ 和 $k$ 的闭式解析函数。请以单个解析表达式的形式给出结果；无需进行数值近似或舍入。此外，请在推导过程中简要论证为什么移除一个度数较高的节点会倾向于降低全局密度，并将您的结果与原始图的平均度联系起来。您的最终答案应该是一个用 $n$、$m$ 和 $k$ 表示的 $\\Delta D$ 的单个精确表达式。",
            "solution": "本问题要求推导在一个简单无向图中移除单个节点后，其全局网络密度变化量 $\\Delta D$ 的精确表达式。推导过程必须从第一性原理出发。\n\n设图表示为 $G=(V, E)$，其中 $V$ 是节点集，$E$ 是边集。\n初始节点数为 $|V| = n$。\n初始边数为 $|E| = m$。\n该图是简单无向图，意味着它没有自环，任意一对节点之间也没有多条边。\n\n在这样一个有 $n$ 个节点的图中，最大可能边数 $M$ 是从 $n$ 个节点中选取 2 个的方法数，由二项式系数给出：\n$$\nM = \\binom{n}{2} = \\frac{n(n-1)}{2}\n$$\n全局网络密度 $D$ 定义为现有边数与最大可能边数的比率。因此，图的初始密度 $D_1$ 为：\n$$\nD_1 = \\frac{m}{M} = \\frac{m}{\\binom{n}{2}} = \\frac{2m}{n(n-1)}\n$$\n现从图中移除一个度为 $k$ 的节点 $v \\in V$。节点的度是与其邻接的边数。移除节点 $v$ 意味着图结构发生两项变化：\n1. 节点 $v$ 本身被移除。\n2. 所有与 $v$ 邻接的 $k$ 条边被移除。\n\n设新图表示为 $G'=(V', E')$。\n新图中的节点数为 $n' = |V'| = n - 1$。\n新图中的边数为 $m' = |E'| = m - k$。\n\n在新图中，有 $n' = n-1$ 个节点，其最大可能边数 $M'$ 为：\n$$\nM' = \\binom{n'}{2} = \\binom{n-1}{2} = \\frac{(n-1)(n-2)}{2}\n$$\n新图的密度 $D_2$ 为：\n$$\nD_2 = \\frac{m'}{M'} = \\frac{m-k}{\\binom{n-1}{2}} = \\frac{2(m-k)}{(n-1)(n-2)}\n$$\n全局密度的变化量 $\\Delta D$ 是最终密度减去初始密度：\n$$\n\\Delta D = D_2 - D_1\n$$\n代入 $D_1$ 和 $D_2$ 的表达式：\n$$\n\\Delta D = \\frac{2(m-k)}{(n-1)(n-2)} - \\frac{2m}{n(n-1)}\n$$\n为简化此表达式，我们求其公分母，即 $n(n-1)(n-2)$。\n$$\n\\Delta D = \\frac{2(m-k)n}{n(n-1)(n-2)} - \\frac{2m(n-2)}{n(n-1)(n-2)}\n$$\n现在，我们将分数合并到公分母上：\n$$\n\\Delta D = \\frac{2n(m-k) - 2m(n-2)}{n(n-1)(n-2)}\n$$\n展开分子中的各项：\n$$\n\\Delta D = \\frac{(2mn - 2kn) - (2mn - 4m)}{n(n-1)(n-2)}\n$$\n$$\n\\Delta D = \\frac{2mn - 2kn - 2mn + 4m}{n(n-1)(n-2)}\n$$\n$2mn$ 项相消，剩下：\n$$\n\\Delta D = \\frac{4m - 2kn}{n(n-1)(n-2)}\n$$\n从分子中提取因子 $2$，得到最终的闭式表达式：\n$$\n\\Delta D = \\frac{2(2m - kn)}{n(n-1)(n-2)}\n$$\n此表达式在 $n > 2$ 时有效。如果 $n \\le 2$，分母会变为零或图结构变得平凡。对于 $n=2$，分母为 $0$。对于 $n=1$ 或 $n=0$，在此情境下移除节点的概念没有明确定义。\n\n为解答问题的第二部分，我们分析密度减小的条件，即 $\\Delta D  0$。对于 $n>2$，分母 $n(n-1)(n-2)$ 是正数。因此，$\\Delta D$ 的符号由分子 $2(2m-kn)$ 的符号决定。\n密度减小的条件是：\n$$\n2m - kn  0\n$$\n$$\n2m  kn\n$$\n$$\nk > \\frac{2m}{n}\n$$\n原始图的平均度 $\\langle k \\rangle$ 定义为所有节点的度数之和除以节点数。根据握手引理，度数之和等于边数的两倍：$\\sum_{i=1}^{n} k_i = 2m$。\n因此，平均度为：\n$$\n\\langle k \\rangle = \\frac{2m}{n}\n$$\n因此，密度减小（$\\Delta D  0$）的条件是 $k > \\langle k \\rangle$。这意味着，当且仅当被移除节点的度 $k$ 大于原始图的平均度时，移除该节点才会导致全局网络密度降低。一个“度数较高”的节点通常被理解为其度数显著大于平均度的节点。因此，移除这样的节点会倾向于降低全局密度，这一点由我们推导出的 $\\Delta D$ 表达式直接证明。相反，移除一个度数小于平均度的节点则会增加网络密度。",
            "answer": "$$\n\\boxed{\\frac{2(2m - kn)}{n(n-1)(n-2)}}\n$$"
        },
        {
            "introduction": "在计算网络科学中，将理论概念转化为高效的算法是至关重要的一步。这个实践任务旨在弥合理论与实践之间的鸿沟，要求您设计一个能在线性时间复杂度 $\\mathcal{O}(n+m)$ 内从邻接表计算网络密度的算法 。通过完成这个练习，您不仅能学会如何为有向图和无向图实现密度计算，还能掌握如何严谨地处理诸如空图或单节点图等退化情况，从而加深对网络密度定义的理解。",
            "id": "4290385",
            "problem": "给定一个有限网络，其模型为一个简单图，此处的简单图定义为没有平行边和自环。设该图由邻接表表示：对于顶点集 $V$（其中 $|V| = n$）中的每个顶点索引 $i$，一个邻居索引数组 $L_i$ 指定了其出邻点（如果图是有向的）或邻点（如果图是无向的）。网络密度定义为在上述约束下，观测到的链接数与可能的最大链接数之比，其中“链接”的解释应符合图的方向性。设计一个单遍算法，其运行时间为大O符号 $\\mathcal{O}(n+m)$（其中 $m$ 是边的数量），该算法直接从邻接表计算密度。从第一性原理和图论中公认的事实出发，证明你的算法的正确性和时间复杂度，并论证你的算法如何处理 $n \\leq 1$ 的退化情况。完全按照规定实现该算法，并将其应用于以下测试套件。\n\n测试套件包含顶点标记为 $0,1,\\dots,n-1$ 的图。每个测试用例由一个显式的邻接数组列表和一个布尔值定义，该布尔值指示图是有向（$\\text{True}$）还是无向（$\\text{False}$）。邻接表符合以下约束：无自环，无平行边，对于无向图，邻接关系是对称的（如果 $u$ 的列表中有 $v$，那么 $v$ 的列表中也有 $u$）。\n\n测试用例：\n- A例（无向路径）：$n=5$，邻接表 $L_0=[1]$，$L_1=[0,2]$，$L_2=[1,3]$，$L_3=[2,4]$，$L_4=[3]$，有向标记 $\\text{False}$。\n- B例（无向完全图）：$n=4$，邻接表 $L_0=[1,2,3]$，$L_1=[0,2,3]$，$L_2=[0,1,3]$，$L_3=[0,1,2]$，有向标记 $\\text{False}$。\n- C例（有向空图）：$n=3$，邻接表 $L_0=[\\,]$，$L_1=[\\,]$，$L_2=[\\,]$，有向标记 $\\text{True}$。\n- D例（无自环的有向完全图）：$n=4$，邻接表 $L_0=[1,2,3]$，$L_1=[0,2,3]$，$L_2=[0,1,3]$，$L_3=[0,1,2]$，有向标记 $\\text{True}$。\n- E例（无向单顶点图）：$n=1$，邻接表 $L_0=[\\,]$，有向标记 $\\text{False}$。\n- F例（有向单顶点图）：$n=1$，邻接表 $L_0=[\\,]$，有向标记 $\\text{True}$。\n- G例（无顶点的空图）：$n=0$，邻接表为空集 $[\\,]$，有向标记 $\\text{True}$。\n\n你的程序应生成单行输出，其中按顺序包含所有七个测试用例的结果，格式为方括号括起来的逗号分隔列表（例如，$[x_A,x_B,x_C,x_D,x_E,x_F,x_G]$）。每个条目必须是十进制数（浮点数）。此任务不涉及物理单位或角度单位。当可能的最大链接数为 $0$ 时，返回密度 $0$ 来处理退化情况。最终算法只能使用与 $n+m$ 成正比的操作次数，并且除了遍历邻接表外，不得依赖任何预处理。",
            "solution": "所述问题是有效的。它在图论领域有科学依据，定义和约束完备，表述客观。因此，我们可以着手解决。\n\n核心任务是计算网络密度 $\\rho$，其定义为在一个简单图中，观测到的边数 $m$ 与可能的最大边数 $m_{\\text{max}}$ 之比。\n$$ \\rho = \\frac{m}{m_{\\text{max}}} $$\n算法必须在 $\\mathcal{O}(n+m)$ 时间内从邻接表表示中推导出这个值，其中 $n$ 是顶点数，$m$ 是边数。\n\n算法的推导过程分为几个步骤：计算 $m$，计算 $m_{\\text{max}}$，处理退化情况，以及最后分析算法的性能。\n\n**1. 观测边数（$m$）的计算**\n\n观测到的边数 $m$ 是通过对所提供邻接表 $\\{L_i\\}_{i=0}^{n-1}$ 的长度求和，并根据图的方向性来解释这个总和来确定的。邻接表长度的总和 $M = \\sum_{i=0}^{n-1} |L_i|$ 代表了所有顶点的度之和（对于无向图）或出度之和（对于有向图）。\n\n*   **有向图**：在有向图中，邻接表 $L_i$ 中的每个条目对应于一条从顶点 $i$ 出发的唯一有向边。因此，总边数 $m$ 恰好是所有顶点出度之和。\n    $$ m_{\\text{directed}} = \\sum_{i=0}^{n-1} \\text{deg}^+(v_i) = \\sum_{i=0}^{n-1} |L_i| $$\n\n*   **无向图**：在无向图中，每条边 $\\{u, v\\}$ 在邻接表表示中被计算两次：一次是 $v \\in L_u$，另一次是 $u \\in L_v$。这是握手引理的直接推论，该引理指出所有顶点的度之和等于边数的两倍（$\\sum_{v \\in V} \\text{deg}(v) = 2m$）。因此，$m$ 是邻接表长度总和的一半。\n    $$ m_{\\text{undirected}} = \\frac{1}{2} \\sum_{i=0}^{n-1} |L_i| $$\n\n**2. 最大可能边数（$m_{\\text{max}}$）的计算**\n\n最大边数取决于顶点数 $n$ 以及图是有向还是无向，同时要满足图是简单的（无自环和无平行边）这一约束。\n\n*   **无向图**：对于一个有 $n$ 个顶点的无向简单图，最大边数对应于一个完全图 $K_n$。可以在任何一对不同顶点之间放置一条边。从 $n$ 个顶点中选择 2 个顶点的方式数由二项式系数 $\\binom{n}{2}$ 给出。\n    $$ m_{\\text{max}}^{\\text{undirected}} = \\binom{n}{2} = \\frac{n(n-1)}{2} $$\n\n*   **有向图**：对于一个有 $n$ 个顶点的有向简单图，当每对不同的顶点 $(u, v)$ 之间都存在一条从 $u$ 到 $v$ 的有向边时，边数达到最大。这种有序对的总数为 $n(n-1)$。\n    $$ m_{\\text{max}}^{\\text{directed}} = n(n-1) $$\n\n**3. 退化情况（$n \\le 1$）的处理**\n\n问题对分母 $m_{\\text{max}}$ 可能为零的情况给出了具体指令：“当可能的最大链接数为 $0$ 时，返回密度 $0$ 来处理退化情况。”\n\n我们分析何时 $m_{\\text{max}} = 0$：\n*   对于无向图和有向图，$m_{\\text{max}}$ 的公式都包含项 $n(n-1)$。该项等于 $0$ 当且仅当 $n=0$ 或 $n=1$。\n*   因此，对于任何顶点数 $n \\le 1$ 的图，$m_{\\text{max}} = 0$。遵循问题的规则，这些情况下的密度定义为 $0$。这种方法解决了可能出现的除零问题，并为这些平凡的图结构提供了一个一致且有意义的值。对于任何 $n>1$，$m_{\\text{max}}$ 严格为正。\n\n**4. 算法设计与复杂度分析**\n\n基于上述原理，设计一个单遍算法如下：\n1.  给定顶点数 $n$，首先检查是否 $n \\le 1$。如果是，则密度为 $0.0$，此情况的计算完成。\n2.  如果 $n > 1$，初始化一个计数器 `total_degree_sum` 为 $0$。\n3.  对邻接表表示进行单遍处理。从 $i=0$ 到 $n-1$ 迭代，对于每个顶点 $i$，将其邻接表长度 $|L_i|$ 加到 `total_degree_sum` 中。\n4.  计算观测到的边数 $m$。如果图是有向的，$m = \\text{total\\_degree\\_sum}$。如果是无向的，$m = \\text{total\\_degree\\_sum} / 2$。\n5.  计算最大可能边数 $m_{\\text{max}}$。如果图是有向的，$m_{\\text{max}} = n(n-1)$。如果是无向的，$m_{\\text{max}} = n(n-1)/2$。\n6.  计算最终密度为 $\\rho = m/m_{\\text{max}}$。\n\n**正确性与时间复杂度证明**：\n*   **正确性**：该算法的正确性得到了保证，因为它是对基于度数和计算边数（对于无向情况，由握手引理确立）的基本定义以及完全简单图中边数的标准组合公式的直接实现。对 $n \\le 1$ 基本情况的显式处理确保了算法在所有可能的 $n \\ge 0$ 值下的正确性。\n*   **时间复杂度**：计算成本主要由第3步决定，该步骤涉及遍历邻接表。这需要访问 $n$ 个顶点中的每一个，并对每个顶点遍历其邻居列表。遍历的邻居列表元素总数为 $M = \\sum_{i=0}^{n-1} |L_i|$。如前所示，$M$ 等于 $m$（有向图）或 $2m$（无向图），因此 $M$ 与 $m$ 成正比，即 $M \\in \\mathcal{O}(m)$。因此，此步骤的总时间复杂度为 $\\mathcal{O}(n+M) = \\mathcal{O}(n+m)$。所有其他步骤都涉及常数次算术运算，耗时 $\\mathcal{O}(1)$。因此，算法的总时间复杂度为 $\\mathcal{O}(n+m)$，满足问题要求。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes network density for a suite of test cases.\n    \"\"\"\n    \n    # Each test case is a dictionary specifying the graph's properties.\n    test_cases = [\n        # Case A (undirected path)\n        {'n': 5, 'adj_lists': [[1], [0, 2], [1, 3], [2, 4], [3]], 'is_directed': False},\n        # Case B (undirected complete graph)\n        {'n': 4, 'adj_lists': [[1, 2, 3], [0, 2, 3], [0, 1, 3], [0, 1, 2]], 'is_directed': False},\n        # Case C (directed empty graph)\n        {'n': 3, 'adj_lists': [[], [], []], 'is_directed': True},\n        # Case D (directed complete graph without self-loops)\n        {'n': 4, 'adj_lists': [[1, 2, 3], [0, 2, 3], [0, 1, 3], [0, 1, 2]], 'is_directed': True},\n        # Case E (undirected single-vertex graph)\n        {'n': 1, 'adj_lists': [[]], 'is_directed': False},\n        # Case F (directed single-vertex graph)\n        {'n': 1, 'adj_lists': [[]], 'is_directed': True},\n        # Case G (empty graph with no vertices)\n        {'n': 0, 'adj_lists': [], 'is_directed': True}\n    ]\n\n    def calculate_density(n: int, adj_lists: list, is_directed: bool) - float:\n        \"\"\"\n        Calculates the density of a simple graph in O(n+m) time.\n\n        Args:\n            n: The number of vertices.\n            adj_lists: The adjacency list representation of the graph.\n            is_directed: A boolean indicating if the graph is directed.\n\n        Returns:\n            The density of the graph as a float.\n        \"\"\"\n        # Per the problem statement, for n = 1, the maximum possible number\n        # of edges is 0. In this case, the density is defined as 0.\n        if n = 1:\n            return 0.0\n\n        # Calculate the sum of the lengths of all adjacency lists.\n        # This is the sum of out-degrees for directed graphs, or the sum of \n        # degrees for undirected graphs. This step takes O(n+m) time.\n        total_degree_sum = sum(len(neighbors) for neighbors in adj_lists)\n\n        # Calculate the number of observed edges (m).\n        if is_directed:\n            m = float(total_degree_sum)\n        else:\n            # For an undirected graph, sum of degrees is 2*m.\n            m = float(total_degree_sum) / 2.0\n\n        # Calculate the maximum possible number of edges (m_max).\n        if is_directed:\n            # For a simple directed graph, the max edges is n*(n-1).\n            m_max = float(n * (n - 1))\n        else:\n            # For a simple undirected graph, the max edges is nC2 = n*(n-1)/2.\n            m_max = float(n * (n - 1)) / 2.0\n        \n        # At this point, n > 1, so m_max is guaranteed to be non-zero.\n        density = m / m_max\n        return density\n\n    results = []\n    for case in test_cases:\n        result = calculate_density(case['n'], case['adj_lists'], case['is_directed'])\n        results.append(result)\n\n    # Print results in the specified format: [res_A,res_B,...,res_G]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}