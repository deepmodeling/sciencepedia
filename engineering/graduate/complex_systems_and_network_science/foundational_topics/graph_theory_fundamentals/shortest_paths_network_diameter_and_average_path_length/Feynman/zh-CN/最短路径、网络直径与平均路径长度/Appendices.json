{
    "hands_on_practices": [
        {
            "introduction": "第一个练习是基础热身。通过为三种典型的图家族——路径图、环形图和完全图——推导精确的距离属性，你将巩固对直径和平均路径长度核心定义的理解。这项练习有助于建立关于基本网络拓扑如何直接影响这些关键全局指标的直观认识。",
            "id": "4302457",
            "problem": "考虑包含 $n$ 个顶点的三类无向、无权、简单、连通图：路径图 $P_n$ $(n \\geq 2)$、圈图 $C_n$ $(n \\geq 3)$ 和完全图 $K_n$ $(n \\geq 2)$。对于一个顶点集为 $V$ 的图 $G$，将顶点 $u$ 和 $v$ 之间的图论距离 $d_G(u,v)$ 定义为 $u$ 和 $v$ 之间最短路径的长度（边的数量）。图的直径 $D(G)$ 定义为 $D(G) = \\max\\{ d_G(u,v) : u,v \\in V, u \\neq v \\}$。平均路径长度 $L(G)$ 定义为所有不同顶点组成的无序对的 $d_G(u,v)$ 的平均值，即\n$$\nL(G) = \\frac{2}{n(n-1)} \\sum_{ \\{u,v\\} \\subset V,\\, u \\neq v } d_G(u,v).\n$$\n将图 $G$ 的精确距离分布定义为序列 $\\{N_k(G)\\}_{k \\geq 1}$，其中 $N_k(G)$ 是距离恰好为 $k$ 的无序顶点对的数量。严格地从这些定义和图距离的基本原理出发，推导出精确距离分布 $\\{N_k(P_n)\\}$、$\\{N_k(C_n)\\}$ 和 $\\{N_k(K_n)\\}$ 作为 $n$ 的函数，并从中计算出平均路径长度 $L(P_n)$、$L(C_n)$ 和 $L(K_n)$ 以及直径 $D(P_n)$、$D(C_n)$ 和 $D(K_n)$ 的闭式表达式。将你的最终答案按照以下顺序表示为一个单行矩阵：\n$$\n\\big(L(P_n),\\, L(C_n),\\, L(K_n),\\, D(P_n),\\, D(C_n),\\, D(K_n)\\big),\n$$\n使用精确的符号形式。不要四舍五入；提供精确表达式。如果需要分段表达式，请在最终答案中明确地给出。",
            "solution": "该问题是有效的，因为它是标准图论中一个适定、自洽且具有科学依据的问题。解题过程是通过分析三个图系列——路径图 ($P_n$)、圈图 ($C_n$) 和完全图 ($K_n$)——中的每一个来确定它们各自的距离分布，并由此推导出直径和平均路径长度。\n\n**1. 路径图 $P_n$ ($n \\geq 2$)**\n设 $P_n$ 的顶点被标记为 $v_0, v_1, \\dots, v_{n-1}$，使得对于 $i=0, \\dots, n-2$，$v_i$ 和 $v_{i+1}$ 之间存在边。该图是一条线。任意两个顶点 $v_i$ 和 $v_j$ 之间的最短路径是唯一的，其长度由图论距离 $d_{P_n}(v_i, v_j) = |i-j|$ 给出。\n\n距离分布 $N_k(P_n)$ 是满足 $|i-j| = k$ 的无序对 $\\{v_i, v_j\\}$ 的数量。对于一个固定的距离 $k \\in \\{1, 2, \\dots, n-1\\}$，这些对的形式为 $\\{v_i, v_{i+k}\\}$。索引 $i$ 的范围可以从 $0$ 到 $n-1-k$。因此，这些对是 $\\{v_0, v_k\\}, \\{v_1, v_{k+1}\\}, \\dots, \\{v_{n-1-k}, v_{n-1}\\}$。这类对的数量是 $(n-1-k) - 0 + 1 = n-k$。\n距离分布为：\n$$\nN_k(P_n) = n-k \\quad \\text{对于 } k \\in \\{1, 2, \\dots, n-1\\}\n$$\n且对于 $k \\geq n$，$N_k(P_n)=0$。\n\n直径 $D(P_n)$ 是最大可能距离，也就是使 $N_k(P_n) > 0$ 的 $k$ 的最大值。这在 $k=n-1$ 时发生，对应于端点 $v_0$ 和 $v_{n-1}$ 之间的距离。\n$$\nD(P_n) = n-1\n$$\n平均路径长度 $L(P_n)$ 是所有距离的总和 $S_{P_n}$ 除以总的对数 $\\binom{n}{2} = \\frac{n(n-1)}{2}$。\n$$\nS_{P_n} = \\sum_{\\substack{\\{u,v\\} \\subset V \\\\ u \\neq v}} d(u,v) = \\sum_{k=1}^{n-1} k \\cdot N_k(P_n) = \\sum_{k=1}^{n-1} k(n-k)\n$$\n使用幂和的标准公式 $\\sum_{i=1}^{m} i = \\frac{m(m+1)}{2}$ 和 $\\sum_{i=1}^{m} i^2 = \\frac{m(m+1)(2m+1)}{6}$，其中 $m=n-1$：\n$$\nS_{P_n} = n \\sum_{k=1}^{n-1} k - \\sum_{k=1}^{n-1} k^2 = n \\frac{(n-1)n}{2} - \\frac{(n-1)n(2(n-1)+1)}{6}\n$$\n$$\nS_{P_n} = \\frac{n^2(n-1)}{2} - \\frac{n(n-1)(2n-1)}{6} = \\frac{3n^2(n-1) - n(n-1)(2n-1)}{6}\n$$\n$$\nS_{P_n} = \\frac{n(n-1)}{6} [3n - (2n-1)] = \\frac{n(n-1)(n+1)}{6} = \\frac{n(n^2-1)}{6}\n$$\n那么平均路径长度是：\n$$\nL(P_n) = \\frac{S_{P_n}}{\\binom{n}{2}} = \\frac{\\frac{n(n^2-1)}{6}}{\\frac{n(n-1)}{2}} = \\frac{n(n-1)(n+1)}{6} \\cdot \\frac{2}{n(n-1)} = \\frac{n+1}{3}\n$$\n\n**2. 圈图 $C_n$ ($n \\geq 3$)**\n设 $C_n$ 的顶点沿着圈的顺序被标记为 $v_0, v_1, \\dots, v_{n-1}$。$v_i$ 和 $v_{i+1 \\pmod n}$ 之间存在一条边。两个顶点 $v_i$ 和 $v_j$ 之间的距离是沿着圈的两条路径中较短者的长度：\n$$\nd_{C_n}(v_i, v_j) = \\min(|i-j|, n - |i-j|)\n$$\n直径 $D(C_n)$ 是这些最短路径中最长的。根据对称性，我们可以找到距离 $v_0$ 最远的顶点。到 $v_k$ 的距离是 $\\min(k, n-k)$。这个关于 $k$ 的函数在 $k$ 尽可能接近 $n-k$ 时（即 $k \\approx \\frac{n}{2}$）达到最大值。最大值为 $\\lfloor \\frac{n}{2} \\rfloor$。\n$$\nD(C_n) = \\lfloor \\frac{n}{2} \\rfloor\n$$\n距离分布 $N_k(C_n)$ 取决于 $n$ 的奇偶性。根据对称性，对于给定的顶点 $v_i$ 和满足 $1 \\leq k  \\frac{n}{2}$ 的距离 $k$，恰好有两个顶点与它的距离为 $k$。这给出了 $n$ 个距离为 $k$ 的点对。如果 $n$ 是偶数且 $k=\\frac{n}{2}$，则每个顶点只有一个对跖点，得到 $\\frac{n}{2}$ 个点对。\n\n情况1：$n$ 是奇数。设 $n=2m+1$。最大距离是 $m = \\frac{n-1}{2}$。对于任何 $k \\in \\{1, 2, \\dots, m\\}$，都有 $n$ 个点对的距离为 $k$。\n$$\nN_k(C_{2m+1}) = n \\quad \\text{对于 } k \\in \\{1, \\dots, m\\}\n$$\n距离总和为 $S_{C_n} = \\sum_{k=1}^{m} k \\cdot n = n \\frac{m(m+1)}{2}$。代入 $m=\\frac{n-1}{2}$：\n$$\nS_{C_n} = n \\frac{\\frac{n-1}{2}(\\frac{n-1}{2}+1)}{2} = n \\frac{(\\frac{n-1}{2})(\\frac{n+1}{2})}{2} = \\frac{n(n^2-1)}{8}\n$$\n对于奇数 $n$，平均路径长度为：\n$$\nL(C_n) = \\frac{S_{C_n}}{\\binom{n}{2}} = \\frac{\\frac{n(n^2-1)}{8}}{\\frac{n(n-1)}{2}} = \\frac{n(n-1)(n+1)}{8} \\cdot \\frac{2}{n(n-1)} = \\frac{n+1}{4}\n$$\n情况2：$n$ 是偶数。设 $n=2m$。最大距离是 $m=\\frac{n}{2}$。对于 $k \\in \\{1, ..., m-1\\}$，$N_k(C_{2m}) = n$。对于 $k=m$，$N_m(C_{2m}) = \\frac{n}{2}$。距离总和为：\n$$\nS_{C_n} = \\left(\\sum_{k=1}^{m-1} k \\cdot n\\right) + m \\cdot \\frac{n}{2} = n \\frac{(m-1)m}{2} + \\frac{nm}{2} = \\frac{nm}{2} ((m-1)+1) = \\frac{nm^2}{2}\n$$\n代入 $m=\\frac{n}{2}$：\n$$\nS_{C_n} = \\frac{n(\\frac{n}{2})^2}{2} = \\frac{n(\\frac{n^2}{4})}{2} = \\frac{n^3}{8}\n$$\n对于偶数 $n$，平均路径长度为：\n$$\nL(C_n) = \\frac{S_{C_n}}{\\binom{n}{2}} = \\frac{\\frac{n^3}{8}}{\\frac{n(n-1)}{2}} = \\frac{n^3}{8} \\cdot \\frac{2}{n(n-1)} = \\frac{n^2}{4(n-1)}\n$$\n\n**3. 完全图 $K_n$ ($n \\geq 2$)**\n在完全图 $K_n$ 中，每一对不同的顶点 $\\{u,v\\}$ 都由一条边相连。因此，对于所有不同的顶点对，最短路径长度为 $1$。\n$$\nd_{K_n}(u,v) = 1 \\quad \\text{对于所有 } u \\neq v\n$$\n距离分布只包含一个非零项。距离为 $k=1$ 的顶点对数量就是顶点的总对数：\n$$\nN_1(K_n) = \\binom{n}{2} = \\frac{n(n-1)}{2}, \\text{ 且当 } k > 1 \\text{ 时, } N_k(K_n) = 0\n$$\n直径 $D(K_n)$ 是最大距离，即 $1$。\n$$\nD(K_n) = 1\n$$\n平均路径长度 $L(K_n)$ 也是 $1$，因为每对顶点的距离都是 $1$：\n$$\nL(K_n) = \\frac{\\sum d(u,v)}{\\binom{n}{2}} = \\frac{1 \\cdot N_1(K_n)}{\\binom{n}{2}} = \\frac{\\binom{n}{2}}{\\binom{n}{2}} = 1\n$$",
            "answer": "$$ \\boxed{ \\left( L(P_n)=\\frac{n+1}{3},\\, L(C_n)=\\begin{cases} \\frac{n+1}{4}  n \\text{ 为奇数} \\\\ \\frac{n^2}{4(n-1)}  n \\text{ 为偶数} \\end{cases},\\, L(K_n)=1,\\, D(P_n)=n-1,\\, D(C_n)=\\lfloor \\frac{n}{2} \\rfloor,\\, D(K_n)=1 \\right) } $$"
        },
        {
            "introduction": "真实世界的网络连接通常具有不同的强度或成本，这通过边的权重来表示。本练习将超越简单的跳数，探讨无权（拓扑）距离与加权距离之间的关键区别。通过分析一个小型加权网络，你将发现边权重如何能够产生非显而易见的最短路径，这一现象对于理解交通、通信和经济系统至关重要。",
            "id": "4302468",
            "problem": "考虑一个无向正权网络，其节点集为 $V=\\{1,2,3,4,5,6\\}$。边是对称的，对于下面列出的每个无序对 $\\{i,j\\}$，其权重为 $w_{ij}=w_{ji}$：\n- 边 {1,2}，权重 $w_{12}=9$，\n- 边 {2,3}，权重 $w_{23}=1$，\n- 边 {3,4}，权重 $w_{34}=1$，\n- 边 {4,5}，权重 $w_{45}=1$，\n- 边 {5,6}，权重 $w_{56}=1$，\n- 边 {6,1}，权重 $w_{16}=2$，\n- 边 {1,3}，权重 $w_{13}=3$，\n- 边 {2,5}，权重 $w_{25}=2$，\n- 边 {3,6}，权重 $w_{36}=8$，\n- 边 {2,4}，权重 $w_{24}=10$。\n任何未列出的无序对 $\\{i,j\\}$ 之间没有边。\n\n仅使用此处陈述的基本定义：\n- 节点 $i$ 和 $j$ 之间的路径是任意一个节点序列 $(i=v_{0},v_{1},\\dots,v_{k}=j)$，其中每个相邻的无序对 $\\{v_{\\ell},v_{\\ell+1}\\}$ 都是一条边。其加权长度是和 $\\sum_{\\ell=0}^{k-1} w_{v_{\\ell} v_{\\ell+1}}$。\n- 加权最短路径距离 $d_{w}(i,j)$ 是 $i$ 和 $j$ 之间所有路径的最小加权长度。\n- 基于跳数（未加权）的最短路径距离 $d_{h}(i,j)$ 是在忽略权重的情况下，$i$ 和 $j$ 之间所有路径的最小边数 $k$。\n- 对于一个有 $n$ 个节点的无向网络，平均最短路径长度是所有 $i",
            "solution": "该问题定义明确，具有科学依据，并提供了进行求解所需的所有信息。该图由其节点集 $V=\\{1,2,3,4,5,6\\}$、边集以及相应的正权重指定。任务是计算基于跳数和加权的最短路径距离，各自的平均路径长度，以及这些平均值的比率，同时说明特定的寻路现象。\n\n节点数为 $n=6$。不同节点的无序对数量为 $\\binom{n}{2} = \\binom{6}{2} = \\frac{6 \\times 5}{2} = 15$。平均最短路径长度 $L$ 计算为 $L=\\frac{1}{15}\\sum_{i",
            "answer": "$$\\boxed{\\frac{17}{10}}$$"
        },
        {
            "introduction": "对于大规模网络，精确计算所有最短路径指标通常在计算上是不可行的。最后一个练习将介绍一种强大且广泛应用的技术：通过随机抽样来估计平均路径长度。你不仅将实现一个基于抽样的估计器，还将学习如何通过构建置信区间来量化其准确性，从而弥合图论与大规模网络实际数据分析之间的差距。",
            "id": "4302440",
            "problem": "考虑一个有限、简单、无向、无权且连通的图 $G=(V,E)$，其中 $|V|=n$。两个顶点 $u,v \\in V$ 之间的最短路径距离表示为 $d(u,v)$，定义为连接 $u$ 和 $v$ 的所有路径中边的最小数量。网络直径 $D$ 定义为 $D=\\max_{u,v \\in V} d(u,v)$。平均路径长度 $\\ell$ 定义在无序顶点对上，其公式为\n$$\n\\ell \\;=\\; \\frac{2}{n(n-1)} \\sum_{u  v} d(u,v).\n$$\n广度优先搜索 (BFS) 在以顶点 $r$ 为根时，计算所有 $v \\in V$ 的 $d(r,v)$。您需要通过在 $m$ 个独立同分布 (i.i.d.) 的均匀随机顶点上采样并构建 BFS 树，来构造 $\\ell$ 的一个估计量 $\\widehat{\\ell}$，然后基于基本定义和界限，使用 Hoeffding 不等式推导一个置信区间。\n\n从上述核心定义出发，对于 $V$ 中的一个均匀随机根 $R$，定义以根为条件的平均最短路径长度\n$$\nZ_R \\;=\\; \\frac{1}{n-1} \\sum_{v \\in V \\setminus \\{R\\}} d(R,v).\n$$\n对于从 $V$ 中均匀抽取的独立同分布样本 $R_1, R_2, \\ldots, R_m$，设\n$$\n\\widehat{\\ell} \\;=\\; \\frac{1}{m} \\sum_{i=1}^m Z_{R_i}.\n$$\n利用对所有 $u,v \\in V$ 都有 $0 \\le d(u,v) \\le D$ 这一事实，基于有界独立随机变量的 Hoeffding 不等式，为 $\\ell$ 推导一个置信区间。对于 $Z_{R_i}$，使用界限范围 $[a,b]=[0,D]$。\n\n您的程序必须为每个测试用例执行以下操作：\n- 使用基本定义和 BFS 计算精确的网络直径 $D$ 和精确的平均路径长度 $\\ell$，不使用任何捷径或近似方法。\n- 通过从 $V$ 中采样 $m$ 个独立同分布的均匀根并对 $Z_{R_i}$ 求平均值来估计 $\\widehat{\\ell}$。\n- 计算一个置信水平为 $1-\\delta$ 的双边置信区间 $[\\widehat{\\ell}-\\varepsilon,\\widehat{\\ell}+\\varepsilon]$，其中 $\\varepsilon$ 是通过对 $m$ 个在 $[0,D]$ 内的有界独立同分布变量的样本均值应用 Hoeffding 不等式并反解得到的。具体来说，\n$$\n\\varepsilon \\;=\\; D \\sqrt{\\frac{\\ln\\!\\left(\\frac{2}{\\delta}\\right)}{2m}}.\n$$\n将该区间限制在可行范围 $[0,D]$ 内。\n\n仅使用基于最短路径、直径和平均路径长度定义的纯数学和算法推理。除了所述的对根进行独立同分布均匀采样外，不要使用任何外部数据或概率捷径。所有计算都是无量纲的；不涉及任何物理单位。\n\n测试套件：\n为以下三（3）个测试用例提供结果。为保证可复现性，在对 $m$ 个根进行采样时，请使用固定的伪随机数生成器种子 $12345$，并进行有放回采样（即在 $V$ 上进行独立同分布的均匀采样）。\n\n1. 路径图，有 $n=5$ 个顶点 $V=\\{0,1,2,3,4\\}$ 和边 $E=\\{(0,1),(1,2),(2,3),(3,4)\\}$。使用 $m=1$ 和 $\\delta=0.05$。\n2. 星形图，有 $n=6$ 个顶点 $V=\\{0,1,2,3,4,5\\}$，中心点 $0$ 连接到所有叶节点，边为 $E=\\{(0,1),(0,2),(0,3),(0,4),(0,5)\\}$。使用 $m=2$ 和 $\\delta=0.05$。\n3. 大小为 $3 \\times 3$ 的二维网格图，有 $n=9$ 个顶点，按坐标 $(i,j)$ 标记（其中 $i,j \\in \\{0,1,2\\}$），并按行主序映射到整数 $\\{0,\\ldots,8\\}$，边存在于正交相邻的顶点之间。使用 $m=9$ 和 $\\delta=0.05$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身也是一个方括号括起来的逗号分隔列表，格式为 $[\\widehat{\\ell},\\text{lower},\\text{upper},D,\\ell]$，所有条目均为十进制浮点数。例如，三个测试用例的完整输出必须如下所示：$[[\\widehat{\\ell}_1,\\text{lower}_1,\\text{upper}_1,D_1,\\ell_1],[\\widehat{\\ell}_2,\\text{lower}_2,\\text{upper}_2,D_2,\\ell_2],[\\widehat{\\ell}_3,\\text{lower}_3,\\text{upper}_3,D_3,\\ell_3]]$。",
            "solution": "我们从图论的基本定义开始。设 $G=(V,E)$ 是一个有限、简单、无向、无权且连通的图，其中 $|V|=n$。对于任意两个顶点 $u,v \\in V$，最短路径距离 $d(u,v)$ 是连接 $u$ 和 $v$ 的所有路径中边的最小数量，可通过在 $u$ 或 $v$ 上运行广度优先搜索 (BFS) 计算得出。网络直径 $D$ 定义为 $D=\\max_{u,v \\in V} d(u,v)$，而对于无序的不同顶点对的平均路径长度为\n$$\n\\ell \\;=\\; \\frac{2}{n(n-1)} \\sum_{u  v} d(u,v).\n$$\n\n构造估计量。为 $V$ 中的一个均匀随机根 $R \\in V$ 定义一个随机变量：\n$$\nZ_R \\;=\\; \\frac{1}{n-1} \\sum_{v \\in V \\setminus \\{R\\}} d(R,v).\n$$\n这个 $Z_R$ 是从 $R$ 到所有其他顶点的条件平均距离。考虑独立同分布 (i.i.d.) 的样本 $R_1,\\ldots,R_m \\sim \\text{Uniform}(V)$，并定义样本均值\n$$\n\\widehat{\\ell} \\;=\\; \\frac{1}{m} \\sum_{i=1}^m Z_{R_i}.\n$$\n我们断言 $\\mathbb{E}[Z_R]=\\ell$，因此 $\\widehat{\\ell}$ 是 $\\ell$ 的一个无偏估计量。为了证明这一点，我们进行展开并利用对称性：\n$$\n\\mathbb{E}[Z_R] \\;=\\; \\frac{1}{n} \\sum_{r \\in V} \\frac{1}{n-1} \\sum_{v \\in V \\setminus \\{r\\}} d(r,v)\n\\;=\\; \\frac{1}{n(n-1)} \\sum_{r \\in V} \\sum_{v \\in V \\setminus \\{r\\}} d(r,v).\n$$\n该双重求和对每个 $u \\neq v$ 的有序对 $(u,v)$ 恰好计数一次，所以\n$$\n\\mathbb{E}[Z_R] \\;=\\; \\frac{1}{n(n-1)} \\sum_{u \\neq v} d(u,v)\n\\;=\\; \\frac{2}{n(n-1)} \\sum_{u  v} d(u,v)\n\\;=\\; \\ell.\n$$\n因此 $\\widehat{\\ell}$ 是 $\\ell$ 的无偏估计量。\n\n界定与集中。每个距离都满足 $0 \\le d(u,v) \\le D$。对于任何固定的 $r$，平均值 $Z_r$ 是 $(n-1)$ 个项的均值，每一项都在 $[0,D]$ 范围内，因此 $Z_r \\in [0,D]$。$Z_{R_1},\\ldots,Z_{R_m}$ 这些变量是独立同分布的，并且界定在 $[0,D]$ 内。根据有界独立随机变量的 Hoeffding 不等式，\n$$\n\\mathbb{P}\\left( \\left| \\frac{1}{m} \\sum_{i=1}^m Z_{R_i} - \\mathbb{E}[Z_R] \\right| \\ge \\varepsilon \\right)\n\\;\\le\\; 2 \\exp\\!\\left( - \\frac{2 m \\varepsilon^2}{(b-a)^2} \\right),\n$$\n其中 $[a,b]=[0,D]$。令右侧等于 $\\delta$ 并求解 $\\varepsilon$ 可得\n$$\n\\varepsilon \\;=\\; (b-a) \\sqrt{ \\frac{\\ln(2/\\delta)}{2m} }\n\\;=\\; D \\sqrt{ \\frac{\\ln(2/\\delta)}{2m} }.\n$$\n因此，区间\n$$\n\\left[ \\widehat{\\ell} - \\varepsilon,\\; \\widehat{\\ell} + \\varepsilon \\right]\n$$\n包含 $\\ell$ 的概率至少为 $1-\\delta$。因为 $\\ell \\in [0,D]$，我们将此区间限制在 $[0,D]$ 内。\n\n算法设计。\n\n1. 精确最短路径和直径。对每个顶点 $u \\in V$，运行 BFS 以获得到所有顶点 $v \\in V$ 的距离 $d(u,v)$。计算离心率 $e(u)=\\max_{v} d(u,v)$；则 $D=\\max_{u} e(u)$。为计算精确的平均路径长度 $\\ell$，通过累加 $\\sum_{u} \\sum_{vu} d(u,v)$ 来对所有无序对的 $d(u,v)$ 求和，然后除以 $\\binom{n}{2}$。\n\n2. 采样估计量。为保证可复现性，使用固定的伪随机种子，从 $V$ 中有放回地抽取 $m$ 个独立同分布的均匀根。对每个根 $r$，运行 BFS 计算距离 $d(r,v)$；然后计算 $Z_r = \\frac{1}{n-1} \\sum_{v \\neq r} d(r,v)$。将这些值平均以获得 $\\widehat{\\ell}$。\n\n3. 置信区间。如上文所述精确计算 $D$。设 $\\varepsilon = D \\sqrt{ \\frac{\\ln(2/\\delta)}{2m} }$ 并输出限制后的区间 $[\\max\\{0,\\widehat{\\ell}-\\varepsilon\\},\\min\\{D,\\widehat{\\ell}+\\varepsilon\\}]$。\n\n复杂度。每次 BFS 运行时间为 $\\mathcal{O}(n+|E|)$。计算精确的 $D$ 和 $\\ell$ 需要进行 $n$ 次 BFS，对于测试套件中的小图，总时间为 $\\mathcal{O}(n(n+|E|))$。采样步骤运行 $m$ 次 BFS 遍历，时间为 $\\mathcal{O}(m(n+|E|))$。\n\n测试用例详情。\n\n1. 路径图，有 $n=5$ 个顶点，边为 $E=\\{(0,1),(1,2),(2,3),(3,4)\\}$；设 $m=1$, $\\delta=0.05$。精确直径为 $D=4$，精确平均路径长度为 $\\ell=2$。\n\n2. 星形图，有 $n=6$ 个顶点，边为 $E=\\{(0,1),(0,2),(0,3),(0,4),(0,5)\\}$；设 $m=2$, $\\delta=0.05$。精确直径为 $D=2$，精确平均路径长度为 $\\ell=\\frac{5}{3}$。\n\n3. $3 \\times 3$ 网格图，有 $n=9$ 个顶点和正交邻接关系；设 $m=9$, $\\delta=0.05$。精确的 $D$ 和 $\\ell$ 按规定通过 BFS 计算。\n\n最终输出为单行字符串：\n$$\n\\big[ [\\widehat{\\ell}_1,\\text{lower}_1,\\text{upper}_1,D_1,\\ell_1],\\; [\\widehat{\\ell}_2,\\text{lower}_2,\\text{upper}_2,D_2,\\ell_2],\\; [\\widehat{\\ell}_3,\\text{lower}_3,\\text{upper}_3,D_3,\\ell_3] \\big].\n$$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef bfs_distances(n, adj, root):\n    \"\"\"Compute shortest path distances from root to all nodes in an unweighted graph using BFS.\"\"\"\n    from collections import deque\n    dist = [-1] * n\n    dist[root] = 0\n    q = deque([root])\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n    return dist\n\ndef exact_diameter_and_avg_path_length(n, adj):\n    \"\"\"Compute exact diameter D and exact average path length ell via BFS.\"\"\"\n    # Accumulate distances and eccentricities\n    total_sum = 0\n    num_pairs = n * (n - 1) // 2\n    diameter = 0\n    all_dists = []\n    for u in range(n):\n        du = bfs_distances(n, adj, u)\n        # Eccentricity of u\n        ecc_u = max(du)\n        diameter = max(diameter, ecc_u)\n        all_dists.append(du)\n    # Sum over unordered pairs u  v\n    for u in range(n):\n        du = all_dists[u]\n        for v in range(u + 1, n):\n            total_sum += du[v]\n    ell = total_sum / num_pairs\n    return diameter, ell\n\ndef sample_estimator(n, adj, m, rng):\n    \"\"\"Estimate ell by sampling m i.i.d. uniform roots and averaging mean distances.\"\"\"\n    z_values = []\n    for _ in range(m):\n        r = int(rng.integers(0, n))\n        d = bfs_distances(n, adj, r)\n        # Exclude self distance (0) and compute mean to other vertices\n        s = sum(d)\n        z_r = s / (n - 1)\n        z_values.append(z_r)\n    hat_ell = float(np.mean(z_values)) if z_values else 0.0\n    return hat_ell\n\ndef build_path_graph(n):\n    \"\"\"Build adjacency list for a path graph with n vertices 0..n-1.\"\"\"\n    adj = [[] for _ in range(n)]\n    for i in range(n - 1):\n        adj[i].append(i + 1)\n        adj[i + 1].append(i)\n    return adj\n\ndef build_star_graph(n, center=0):\n    \"\"\"Build adjacency list for a star graph with n vertices, center connected to all others.\"\"\"\n    adj = [[] for _ in range(n)]\n    for v in range(n):\n        if v != center:\n            adj[center].append(v)\n            adj[v].append(center)\n    return adj\n\ndef build_grid_graph(rows, cols):\n    \"\"\"Build adjacency list for an orthogonal 2D grid graph with given rows and cols, row-major indexing.\"\"\"\n    n = rows * cols\n    adj = [[] for _ in range(n)]\n    def idx(r, c):\n        return r * cols + c\n    for r in range(rows):\n        for c in range(cols):\n            u = idx(r, c)\n            # Connect to right neighbor\n            if c + 1  cols:\n                v = idx(r, c + 1)\n                adj[u].append(v)\n                adj[v].append(u)\n            # Connect to bottom neighbor\n            if r + 1  rows:\n                v = idx(r + 1, c)\n                adj[u].append(v)\n                adj[v].append(u)\n    return adj\n\ndef hoeffding_epsilon(D, m, delta):\n    \"\"\"Compute epsilon from Hoeffding's inequality for bounded variables in [0,D].\"\"\"\n    if m == 0:\n        return 0.0\n    return float(D * np.sqrt(np.log(2.0 / delta) / (2.0 * m)))\n\ndef format_case_result(values):\n    \"\"\"Format a list of floats into a bracketed, comma-separated string with fixed decimals and no spaces.\"\"\"\n    return \"[\" + \",\".join(f\"{v:.6f}\" for v in values) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (n, adj, m, delta)\n    # Use fixed RNG seed for reproducible sampling with replacement.\n    rng = np.random.default_rng(12345)\n\n    # Test case 1: Path graph n=5, m=1, delta=0.05\n    n1 = 5\n    adj1 = build_path_graph(n1)\n    m1 = 1\n    delta1 = 0.05\n\n    # Test case 2: Star graph n=6, m=2, delta=0.05\n    n2 = 6\n    adj2 = build_star_graph(n2, center=0)\n    m2 = 2\n    delta2 = 0.05\n\n    # Test case 3: Grid graph 3x3, n=9, m=9, delta=0.05\n    rows3, cols3 = 3, 3\n    n3 = rows3 * cols3\n    adj3 = build_grid_graph(rows3, cols3)\n    m3 = 9\n    delta3 = 0.05\n\n    test_cases = [\n        (n1, adj1, m1, delta1),\n        (n2, adj2, m2, delta2),\n        (n3, adj3, m3, delta3),\n    ]\n\n    results_str = []\n\n    for (n, adj, m, delta) in test_cases:\n        # Exact diameter and exact average path length\n        D_exact, ell_exact = exact_diameter_and_avg_path_length(n, adj)\n        # Sampling estimator\n        hat_ell = sample_estimator(n, adj, m, rng)\n        # Hoeffding epsilon and CI clamped to [0, D_exact]\n        eps = hoeffding_epsilon(D_exact, m, delta)\n        lower = max(0.0, hat_ell - eps)\n        upper = min(float(D_exact), hat_ell + eps)\n        # Collect case result: [hat_ell, lower, upper, D_exact, ell_exact]\n        case_values = [hat_ell, lower, upper, float(D_exact), float(ell_exact)]\n        results_str.append(format_case_result(case_values))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        }
    ]
}