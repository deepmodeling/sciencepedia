{
    "hands_on_practices": [
        {
            "introduction": "理解社会资本和结构洞理论的第一步是学会如何量化它们。罗纳德·伯特（Ronald Burt）的结构约束（structural constraint）概念是一个核心指标，它衡量了个体在多大程度上受其网络中冗余关系的限制。本练习将引导你通过一个具体的自我中心网络案例，亲手计算结构约束，从而深入理解直接关系和间接关系如何共同塑造个体的机会与限制。",
            "id": "4303500",
            "problem": "考虑一个以自我为中心的加权有向社交网络，该网络模拟了行动者之间的信息或资源分配。设自我为行动者 $i$，他者为 $A$、$B$ 和 $C$。对于任意有序行动者对 $(a,b)$，令 $w_{ab}$ 表示行动者 $a$ 对 $b$ 的总出向投资所占的比例。假设不存在自返边，即对所有行动者 $a$，$w_{aa}=0$。并且，每个行动者的所有出向权重均为非负，且总和为1。将归一化曝露度（比例）$p_{ab}$ 定义为行动者的相对投资，$p_{ab} = w_{ab} / \\sum_{k} w_{ak}$，因此当行动者 $a$ 的出向权重总和已为1时，$p_{ab} = w_{ab}$。\n\n自我的出向权重由 $w_{iA} = 0.5$，$w_{iB} = 0.3$ 和 $w_{iC} = 0.2$ 给出，且满足 $\\sum_{j \\in \\{A,B,C\\}} w_{ij} = 1$。每个他者对其他他者的出向权重满足相同的归一化条件，并由以下给出：\n- $w_{AB} = 0.6$ 和 $w_{AC} = 0.4$，\n- $w_{BA} = 0.2$ 和 $w_{BC} = 0.8$，\n- $w_{CA} = 0.7$ 和 $w_{CB} = 0.3$。\n\n使用基本定义——自我对某个他者 $j$ 的曝露度包括通过 $i \\to j$ 的直接曝露和通过邻居 $q \\in \\{A,B,C\\}$ 的两步路径 $i \\to q \\to j$ 的间接曝露——计算 $j \\in \\{A,B,C\\}$ 的详细约束分量 $c_{ij}$，以及自我所受的总网络约束 $C_{i}$（作为所有他者约束分量的总和）。基于这些值，从三元闭包、弱关系和结构洞的角度，定性解释每个他者如何对自我 $i$ 的约束产生影响。\n\n将总网络约束 $C_i$ 的最终答案表示为无单位小数，并四舍五入到四位有效数字。",
            "solution": "首先对问题的科学性、良定性和客观性进行验证。\n\n### 步骤1：提取已知条件\n- 网络是以自我为中心的、加权的、有向的。\n- 自我：行动者 $i$。他者：$j \\in \\{A, B, C\\}$。\n- 权重 $w_{ab}$：行动者 $a$ 对 $b$ 的总出向投资所占的比例。\n- 无自返边：$w_{aa}=0$。\n- 归一化：对任意行动者 $a$，$\\sum_{b} w_{ab} = 1$。\n- 归一化曝露度：$p_{ab} = w_{ab} / \\sum_{k} w_{ak}$，简化为 $p_{ab}=w_{ab}$。\n- 自我的出向权重：$w_{iA} = 0.5$，$w_{iB} = 0.3$，$w_{iC} = 0.2$。\n- 他者的出向权重：\n    - 行动者 $A$：$w_{AB} = 0.6$，$w_{AC} = 0.4$。\n    - 行动者 $B$：$w_{BA} = 0.2$，$w_{BC} = 0.8$。\n    - 行动者 $C$：$w_{CA} = 0.7$，$w_{CB} = 0.3$。\n- 任务：计算约束分量 $c_{ij}$ 和总约束 $C_i = \\sum_j c_{ij}$。\n- 曝露度的定义：“自我对某个他者 $j$ 的曝露度包括通过 $i \\to j$ 的直接曝露和通过邻居 $q \\in \\{A,B,C\\}$ 的两步路径 $i \\to q \\to j$ 的间接曝露”。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题在网络科学领域具有科学依据，特别引用了由 Ronald Burt 发展的网络约束概念。所提供的数据内部一致，所有出向权重之和如所述为 $1$。该问题是良定的，因为它提供了计算所要求数量所需的所有值。唯一的模糊之处在于术语“约束分量 $c_{ij}$”，该术语未被明确定义。然而，关于曝露度（直接路径加间接路径）的描述与 Burt 对网络约束的正式定义中括号内的项完全匹配。在该领域，通常将自我 $i$ 从他者 $j$ 处感受到的约束分量 $c_{ij}$ 定义为 $i$ 对 $j$ 的总曝露度的平方。问题中“使用基本定义...”的措辞暗示应使用此标准定义。因此，在采用此标准定义的假设下，该问题被认为是有效的。\n\n### 步骤3：结论与行动\n问题有效。解题过程将应用网络约束的标准定义。\n\n### 解题过程\n该网络由一个自我行动者 $i$ 和一组三个他者 $\\{A, B, C\\}$ 组成。相互作用由权重 $w_{ab}$ 描述，表示行动者 $a$ 对行动者 $b$ 的投资比例。由于每个行动者的出向权重都归一化为总和为 $1$，所以归一化曝露度 $p_{ab}$ 等于权重 $w_{ab}$。\n\n自我 $i$ 从他者 $j$ 处受到的网络约束是衡量 $i \\to j$ 这条关系冗余度的指标。它的基本定义基于 $i$ 对 $j$ 的总曝露度，这包括直接关系 $p_{ij}$ 和所有通过中介行动者 $q$ 的间接关系。约束分量 $c_{ij}$ 是这个总曝露度的平方。根据 R. Burt 建立的公式是：\n$$\nc_{ij} = \\left( p_{ij} + \\sum_{q \\neq i, j} p_{iq} p_{qj} \\right)^2\n$$\n在这里，$p_{ij}$ 表示直接曝露，求和项 $\\sum_{q \\neq i, j} p_{iq} p_{qj}$ 表示通过所有其他他者 $q$ 的间接曝露。自我 $i$ 所受的总网络约束是来自所有他者的分量之和：$C_i = \\sum_j c_{ij}$。\n\n我们计算每个他者 $j \\in \\{A, B, C\\}$ 的约束分量。\n\n1.  **来自他者 A 的约束 ($c_{iA}$)**\n    可以作为中介的他者是 $q \\in \\{B, C\\}$。公式为：\n    $$\n    c_{iA} = \\left( p_{iA} + p_{iB}p_{BA} + p_{iC}p_{CA} \\right)^2\n    $$\n    使用给定的权重，其中 $p_{ab} = w_{ab}$：\n    - 直接曝露：$p_{iA} = 0.5$。\n    - 通过 $B$ 的间接曝露：$p_{iB}p_{BA} = (0.3)(0.2) = 0.06$。\n    - 通过 $C$ 的间接曝露：$p_{iC}p_{CA} = (0.2)(0.7) = 0.14$。\n    - 对 $A$ 的总间接曝露：$0.06 + 0.14 = 0.20$。\n    $i$ 对 $A$ 的总曝露度是 $0.5 + 0.20 = 0.70$。\n    约束分量是：\n    $$\n    c_{iA} = (0.70)^2 = 0.49\n    $$\n\n2.  **来自他者 B 的约束 ($c_{iB}$)**\n    可以作为中介的他者是 $q \\in \\{A, C\\}$。公式为：\n    $$\n    c_{iB} = \\left( p_{iB} + p_{iA}p_{AB} + p_{iC}p_{CB} \\right)^2\n    $$\n    使用给定的权重：\n    - 直接曝露：$p_{iB} = 0.3$。\n    - 通过 $A$ 的间接曝露：$p_{iA}p_{AB} = (0.5)(0.6) = 0.30$。\n    - 通过 $C$ 的间接曝露：$p_{iC}p_{CB} = (0.2)(0.3) = 0.06$。\n    - 对 $B$ 的总间接曝露：$0.30 + 0.06 = 0.36$。\n    $i$ 对 $B$ 的总曝露度是 $0.3 + 0.36 = 0.66$。\n    约束分量是：\n    $$\n    c_{iB} = (0.66)^2 = 0.4356\n    $$\n\n3.  **来自他者 C 的约束 ($c_{iC}$)**\n    可以作为中介的他者是 $q \\in \\{A, B\\}$。公式为：\n    $$\n    c_{iC} = \\left( p_{iC} + p_{iA}p_{AC} + p_{iB}p_{BC} \\right)^2\n    $$\n    使用给定的权重：\n    - 直接曝露：$p_{iC} = 0.2$。\n    - 通过 $A$ 的间接曝露：$p_{iA}p_{AC} = (0.5)(0.4) = 0.20$。\n    - 通过 $B$ 的间接曝露：$p_{iB}p_{BC} = (0.3)(0.8) = 0.24$。\n    - 对 $C$ 的总间接曝露：$0.20 + 0.24 = 0.44$。\n    $i$ 对 $C$ 的总曝露度是 $0.2 + 0.44 = 0.64$。\n    约束分量是：\n    $$\n    c_{iC} = (0.64)^2 = 0.4096\n    $$\n\n最后，我们通过将这些分量相加来计算自我所受的总网络约束 $C_i$：\n$$\nC_i = c_{iA} + c_{iB} + c_{iC} = 0.49 + 0.4356 + 0.4096 = 1.3352\n$$\n\n### 定性解释\n计算出的约束分量为 $c_{iA} = 0.49$，$c_{iB} \\approx 0.436$ 和 $c_{iC} \\approx 0.410$。总约束为 $C_i \\approx 1.335$。高约束值表明自我的关系是冗余的，其社会资本集中在一个密集、内聚的群体中。\n\n-   **三元闭包**：所有三个他者都对自我 $i$ 施加了显著的约束。这表明了强的三元闭包。对于自我的每一条关系（例如 $i \\to A$），都存在通过其他他者（例如 $i \\to B \\to A$ 和 $i \\to C \\to A$）的强间接路径。这意味着他者 $A$、$B$ 和 $C$ 自身高度互联，在自我周围形成了一个紧密的集群。高的间接曝露值（对 $A$ 为 $0.20$，对 $B$ 为 $0.36$，对 $C$ 为 $0.44$）量化了这种冗余。例如，即使是最弱的直接关系 $i \\to C$ ($w_{iC}=0.2$)，也因通过 $A$ 和 $B$ 与 $C$ 存在非常强的间接联系而变得具有高约束性 ($c_{iC}=0.4096$)。\n\n-   **结构洞**：像 $C_i = 1.3352$ 这样的高总约束值意味着自我的网络中缺乏结构洞。结构洞是社会结构中的间隙，自我通过这些间隙连接到彼此不相连的行动者。通过桥接这样的洞，自我可以中介信息和控制资源。在这个网络中，自我的所有他者都相互连接，这意味着没有可供自我跨越的洞。自我 $i$ 嵌入在单一的内聚组件中，而不是桥接不同的群体。\n\n-   **弱关系**：根据 Granovetter 的理论，弱关系之所以有价值，是因为它们通常充当通往新信息和不同社交圈的桥梁。在这个网络中，自我的所有关系在结构意义上都是“强”的，因为它们被深度嵌入且是冗余的。即使是权重最低的关系（$w_{iC}=0.2$）在 Granovetter 的意义上也不是结构上的“弱”关系，因为它被强的三元关系所加强。因此，自我的网络很可能提供冗余信息，并且限制了由中介作用产生的社会或经济优势的机会。他者 $A$ 对这一约束的贡献最大（$c_{iA}=0.49$），这主要是因为它既是自我的主要投资对象，也与其他他者有良好的连接。\n\n将 $C_i$ 的最终答案四舍五入到四位有效数字，得到 $1.335$。",
            "answer": "$$\n\\boxed{1.335}\n$$"
        },
        {
            "introduction": "在理解了如何计算静态网络中的结构约束之后，一个自然而然的进阶问题是：当我们主动改变网络结构时，约束会如何变化？本练习要求你从代数层面进行推导，分析当一个个体（ego）将其关系投资从一个紧密联系的旧关系重新分配到两个不相关的“新关系”时，其网络总约束的变化。通过这个练习，你将能更深刻地体会到建立“桥梁”和跨越“结构洞”的战略价值。",
            "id": "4303471",
            "problem": "考虑一个有向加权社交网络中的自我节点 $i$，其中关系强度被归一化为比例。设 $p_{ij}$ 表示自我节点 $i$ 分配给其联系人 $j$ 的关系投入比例，且满足 $\\sum_{j} p_{ij} = 1$。自我节点 $i$ 的 Burt 结构约束由一个来自结构洞文献的标准公式定义，用 $p_{ij}$ 和他者间的关系比例表示。\n\n初始时，自我节点 $i$ 与他者 $A$ 有一个强关系，并与他者 $X_{1},\\dots,X_{n}$ 有 $n$ 个额外的关系。关系比例为 $p_{iA} = s$（其中 $0  s  1$），以及 $p_{iX_{k}} = w_{k} > 0$（对于 $k=1,\\dots,n$），满足 $\\sum_{k=1}^{n} w_{k} = 1 - s$。假设在自我节点 $i$ 的他者中，只有 $A$ 对他者 $X_{k}$ 有出向关系，比例为 $p_{AX_{k}} = a_{k} \\ge 0$（对于 $k=1,\\dots,n$），并且每个 $X_{k}$ 对 $A$ 有一个出向关系，比例为 $p_{X_{k} A} = b_{k} \\ge 0$。对于所有配对 $X_{k} \\neq X_{\\ell}$，假设在自我节点 $i$ 的邻域内，它们之间没有出向关系（即，对于所有 $k \\neq \\ell$，$p_{X_{k} X_{\\ell}} = 0$）。这意味着，在自我节点 $i$ 的他者之间，与间接关系相关的邻域内出向关系仅有 $A \\to X_{k}$ 和 $X_{k} \\to A$。\n\n现在，自我节点 $i$ 移除了与 $A$ 的关系，并将相同的总强度 $s$ 平均重新分配给两个新的他者 $B$ 和 $C$。这两个新他者在其他方面与自我节点 $i$ 的现有他者没有连接。也就是说，重新分配后，$p_{iB} = p_{iC} = s/2$，$p_{iA} = 0$，且之前的 $w_{k}$ 保持不变；此外，假设对于每个先前的他者 $q \\in \\{X_{1},\\dots,X_{n}\\}$ 以及两个新的他者 $B$ 和 $C$，都有 $p_{qB} = 0$ 和 $p_{qC} = 0$，并且在自我节点 $i$ 的邻域内，$B$、$C$ 和任何 $X_{k}$ 之间没有出向关系。\n\n仅使用结构洞和社会网络分析文献中的标准、广为接受的定义，推导由于此次重新分配导致的自我节点 $i$ 总约束变化的精确闭式表达式，该变化定义为新约束减去旧约束。请用 $s$、$\\{w_k\\}_{k=1}^n$、$\\{a_k\\}_{k=1}^n$ 和 $\\{b_k\\}_{k=1}^n$ 来表示您的最终答案。不需要进行数值近似；请提供精确的代数表达式。",
            "solution": "该问题要求计算因指定的社会关系重新分配而导致的自我节点 $i$ 的结构约束的变化。由 Burt 定义的结构约束，量化了自我节点的他者之间相互连接的程度，从而限制了自我节点中介连接和获取非冗余信息的机会。\n\n首先，我们必须陈述 Burt 对自我节点 $i$ 的总结构约束的标准公式。设 $J$ 为自我节点 $i$ 与之有关系的全体他者的集合。$i$ 在他者 $j \\in J$ 上的投入比例为 $p_{ij}$，且 $\\sum_{j \\in J} p_{ij} = 1$。他者 $j$ 对自我节点 $i$ 施加的约束表示为 $c_{ij}$，由以下公式给出：\n$$c_{ij} = \\left( p_{ij} + \\sum_{q \\in J, q \\neq j} p_{iq} p_{qj} \\right)^2$$\n项 $\\sum_{q \\in J, q \\neq j} p_{iq} p_{qj}$ 表示从 $i$ 通过第三方他者 $q$ 到达 $j$ 的间接关系强度。自我节点 $i$ 上的总约束（表示为 $C_i$）是其所有他者施加的约束之和：\n$$C_i = \\sum_{j \\in J} c_{ij}$$\n问题要求计算总约束的变化量 $\\Delta C = C_{new} - C_{old}$，其中 $C_{old}$ 是初始网络配置下的约束，而 $C_{new}$ 是变化后的约束。\n\n我们分别计算 $C_{old}$ 和 $C_{new}$。\n\n**初始约束 ($C_{old}$) 的计算**\n\n在初始状态下，自我节点 $i$ 的他者集合为 $J_{old} = \\{A, X_{1}, \\dots, X_{n}\\}$。来自 $i$ 的直接关系比例为 $p_{iA} = s$ 和 $p_{iX_{k}} = w_{k}$（对于 $k \\in \\{1, \\dots, n\\}$）。\n总约束是来自每个他者的约束之和：$C_{old} = c_{iA} + \\sum_{k=1}^{n} c_{iX_k}$。\n\n1.  **来自他者 $A$ 的约束 ($c_{iA}$):**\n    对 $A$ 的间接投入来自于通过他者 $X_{k}$ 的路径。\n    $$c_{iA} = \\left( p_{iA} + \\sum_{k=1}^{n} p_{iX_{k}} p_{X_{k}A} \\right)^2$$\n    代入给定值 $p_{iA} = s$、$p_{iX_k} = w_k$ 和 $p_{X_k A} = b_k$：\n    $$c_{iA} = \\left( s + \\sum_{k=1}^{n} w_{k} b_{k} \\right)^2$$\n\n2.  **来自他者 $X_j$ 的约束 ($c_{iX_j}$，对于任何 $j \\in \\{1, \\dots, n\\}$):**\n    对 $X_j$ 的间接投入可以来自通过他者 $A$ 或其他他者 $X_k$（其中 $k \\neq j$）的路径。\n    $$c_{iX_j} = \\left( p_{iX_j} + p_{iA} p_{AX_j} + \\sum_{k=1, k \\neq j}^{n} p_{iX_k} p_{X_k X_j} \\right)^2$$\n    我们已知对于所有 $k \\neq j$，$p_{X_k X_j} = 0$。因此，关于 $k$ 的求和项为零。代入给定值 $p_{iX_j} = w_j$、$p_{iA} = s$ 和 $p_{AX_j} = a_j$：\n    $$c_{iX_j} = \\left( w_j + s a_j + 0 \\right)^2 = \\left( w_j + s a_j \\right)^2$$\n\n3.  **总旧约束 ($C_{old}$):**\n    将所有他者的约束相加：\n    $$C_{old} = c_{iA} + \\sum_{j=1}^{n} c_{iX_j} = \\left( s + \\sum_{k=1}^{n} w_{k} b_{k} \\right)^2 + \\sum_{j=1}^{n} \\left( w_j + s a_j \\right)^2$$\n\n**新约束 ($C_{new}$) 的计算**\n\n重新分配后，与 $A$ 的关系被移除，并增加了两个新的他者 $B$ 和 $C$。自我节点 $i$ 的新他者集合为 $J_{new} = \\{B, C, X_{1}, \\dots, X_{n}\\}$。新的直接关系比例为 $p_{iB} = s/2$、$p_{iC} = s/2$ 和 $p_{iX_k} = w_k$（对于 $k \\in \\{1, \\dots, n\\}$）。题目明确指出，新他者 ($B, C$) 与旧他者 ($\\{X_k\\}$) 之间没有关系， $B$ 和 $C$ 之间也没有关系。\n新的总约束为 $C_{new} = c_{iB} + c_{iC} + \\sum_{k=1}^{n} c'_{iX_k}$。\n\n1.  **来自他者 $B$ 的约束 ($c_{iB}$):**\n    对 $B$ 的间接投入来自于通过 $C$ 或任何 $X_k$ 的路径。\n    $$c_{iB} = \\left( p_{iB} + p_{iC} p_{CB} + \\sum_{k=1}^{n} p_{iX_k} p_{X_k B} \\right)^2$$\n    根据题目陈述，对于所有 $k$，$p_{CB} = 0$ 且 $p_{X_k B} = 0$。\n    $$c_{iB} = \\left( \\frac{s}{2} + 0 + 0 \\right)^2 = \\left( \\frac{s}{2} \\right)^2 = \\frac{s^2}{4}$$\n\n2.  **来自他者 $C$ 的约束 ($c_{iC}$):**\n    通过与他者 $B$ 的对称性，计算是相同的。\n    $$c_{iC} = \\left( p_{iC} + p_{iB} p_{BC} + \\sum_{k=1}^{n} p_{iX_k} p_{X_k C} \\right)^2 = \\left( \\frac{s}{2} \\right)^2 = \\frac{s^2}{4}$$\n\n3.  **来自他者 $X_j$ 的新约束 ($c'_{iX_j}$，对于任何 $j \\in \\{1, \\dots, n\\}$):**\n    在新的网络中，对 $X_j$ 的间接投入可能来自于通过 $B$、$C$ 或其他他者 $X_k$（其中 $k \\neq j$）的路径。\n    $$c'_{iX_j} = \\left( p_{iX_j} + p_{iB} p_{BX_j} + p_{iC} p_{CX_j} + \\sum_{k=1, k \\neq j}^{n} p_{iX_k} p_{X_k X_j} \\right)^2$$\n    我们已知 $p_{BX_j} = 0$、$p_{CX_j} = 0$ 和 $p_{X_k X_j} = 0$。\n    $$c'_{iX_j} = \\left( w_j + 0 + 0 + 0 \\right)^2 = w_j^2$$\n\n4.  **总新约束 ($C_{new}$):**\n    将新网络中所有他者的约束相加：\n    $$C_{new} = c_{iB} + c_{iC} + \\sum_{j=1}^{n} c'_{iX_j} = \\frac{s^2}{4} + \\frac{s^2}{4} + \\sum_{j=1}^{n} w_j^2 = \\frac{s^2}{2} + \\sum_{j=1}^{n} w_j^2$$\n\n**约束变化量 ($\\Delta C$) 的计算**\n\n总约束的变化量为 $\\Delta C = C_{new} - C_{old}$。\n$$\\Delta C = \\left( \\frac{s^2}{2} + \\sum_{j=1}^{n} w_j^2 \\right) - \\left( \\left( s + \\sum_{k=1}^{n} w_{k} b_{k} \\right)^2 + \\sum_{j=1}^{n} \\left( w_j + s a_j \\right)^2 \\right)$$\n现在，我们展开 $C_{old}$ 表达式中的平方项：\n$$\\left( s + \\sum_{k=1}^{n} w_{k} b_{k} \\right)^2 = s^2 + 2s \\sum_{k=1}^{n} w_{k} b_{k} + \\left( \\sum_{k=1}^{n} w_{k} b_{k} \\right)^2$$\n$$\\sum_{j=1}^{n} \\left( w_j + s a_j \\right)^2 = \\sum_{j=1}^{n} \\left( w_j^2 + 2w_j s a_j + s^2 a_j^2 \\right) = \\sum_{j=1}^{n} w_j^2 + 2s \\sum_{j=1}^{n} w_j a_j + s^2 \\sum_{j=1}^{n} a_j^2$$\n将这些代回 $\\Delta C$ 的表达式中：\n$$\\Delta C = \\frac{s^2}{2} + \\sum_{j=1}^{n} w_j^2 - \\left[ s^2 + 2s \\sum_{k=1}^{n} w_{k} b_{k} + \\left( \\sum_{k=1}^{n} w_{k} b_{k} \\right)^2 \\right] - \\left[ \\sum_{j=1}^{n} w_j^2 + 2s \\sum_{j=1}^{n} w_j a_j + s^2 \\sum_{j=1}^{n} a_j^2 \\right]$$\n我们现在可以分配负号并进行化简。求和索引是哑变量，因此我们可以统一使用 $k$。\n$$\\Delta C = \\frac{s^2}{2} + \\sum_{k=1}^{n} w_k^2 - s^2 - 2s \\sum_{k=1}^{n} w_{k} b_{k} - \\left( \\sum_{k=1}^{n} w_{k} b_{k} \\right)^2 - \\sum_{k=1}^{n} w_k^2 - 2s \\sum_{k=1}^{n} w_k a_k - s^2 \\sum_{k=1}^{n} a_k^2$$\n项 $\\sum_{k=1}^{n} w_k^2$ 和 $-\\sum_{k=1}^{n} w_k^2$ 相互抵消。合并剩余项：\n$$\\Delta C = \\left(\\frac{s^2}{2} - s^2\\right) - s^2 \\sum_{k=1}^{n} a_k^2 - 2s \\left(\\sum_{k=1}^{n} w_k a_k + \\sum_{k=1}^{n} w_k b_k\\right) - \\left( \\sum_{k=1}^{n} w_{k} b_{k} \\right)^2$$\n$$\\Delta C = -\\frac{s^2}{2} - s^2 \\sum_{k=1}^{n} a_k^2 - 2s \\sum_{k=1}^{n} w_{k}(a_k + b_k) - \\left( \\sum_{k=1}^{n} w_{k} b_{k} \\right)^2$$\n这就是自我节点 $i$ 的总结构约束变化的最终闭式表达式。所有项都是非正的（因为 $s > 0$，$w_k > 0$，$a_k \\ge 0$，$b_k \\ge 0$），这表明自我节点 $i$ 上的约束减小了，这与用两个外围、不相连的联系人取代一个具有约束力的中心联系人的直觉相符。",
            "answer": "$$ \\boxed{ -\\frac{s^2}{2} - s^2 \\sum_{k=1}^{n} a_{k}^{2} - 2s \\sum_{k=1}^{n} w_{k}(a_{k}+b_{k}) - \\left(\\sum_{k=1}^{n} w_{k} b_{k}\\right)^{2} } $$"
        },
        {
            "introduction": "理论的生命力在于其能否解释和预测真实世界的现象。本练习将理论付诸实践，模拟一个计算社会科学的研究任务，旨在通过经验数据检验马克·格兰诺维特（Mark Granovetter）的“弱关系优势”理论。你将需要计算一系列网络指标，并运用回归分析来量化关系强度与节点“桥梁”作用之间的关联，从而掌握将抽象理论转化为可检验假设的核心技能。",
            "id": "4303487",
            "problem": "给定代表通话详单记录的加权无向图，其中每条边的权重记录了在固定观察窗口内两个个体之间的总通话次数。目标是量化连接强度与桥接中介中心性之间的关联（在控制度的影响下），将其表述为一个回归模型，并为一个指定的图测试套件实现此流程。所生成的程序必须是自包含的，并且无需用户输入即可产生所需的输出。\n\n基本原理和定义：\n- 设网络由一个加权无向图表示，其邻接矩阵为 $\\mathbf{A} \\in \\mathbb{R}^{n \\times n}$，其中对于所有 $i$，$A_{ij} = A_{ji} \\ge 0$ 且 $A_{ii} = 0$。当且仅当 $A_{ij} > 0$ 时，节点 $i$ 和 $j$ 之间存在一条边。\n- 节点 $i$ 的无权结构度为 $k_i = \\left|\\{j \\in \\{1,\\dots,n\\} : A_{ij} > 0\\}\\right|$。\n- 节点 $i$ 的连接强度定义为其邻边的平均权重，$s_i = \\frac{1}{k_i} \\sum_{j : A_{ij} > 0} A_{ij}$。\n- 考虑加权最短路径，其中对于 $A_{ij} > 0$ 的每条边 $(i,j)$，其长度为 $\\ell_{ij} = \\frac{1}{A_{ij}}$。节点 $s$ 和 $t$ 之间的距离是从 $s$ 到 $t$ 的任何路径上 $\\ell_{uv}$ 的最小总和。\n- 节点 $i$ 的节点中介中心性 $C_B(i)$ 定义为 $C_B(i) = \\sum_{s \\ne i \\ne t, s \\ne t} \\frac{\\sigma_{st}(i)}{\\sigma_{st}}$，其中 $\\sigma_{st}$ 是 $s$ 和 $t$ 之间最短路径的总数，而 $\\sigma_{st}(i)$ 是这些最短路径中经过节点 $i$ 的数量。对于加权图，最短路径是根据长度 $\\ell_{ij}$ 计算的。\n- 节点 $i$ 的桥接中介中心性定义为 $B(i) = \\frac{C_B(i)}{k_i}$，该定义强调了在群体之间起到中介作用的节点（结构洞），同时对具有较大 $k_i$ 的中心节点进行惩罚。\n- 为了在控制度的影响下估计连接强度和桥接中介中心性之间的关联，我们采用普通最小二乘法（OLS）回归：对于每个节点 $i$，设响应变量为 $y_i = B(i)$，预测变量为 $x_{i1} = s_i$ 和 $x_{i2} = k_i$，并包含一个截距。模型为 $y_i = \\beta_0 + \\beta_1 x_{i1} + \\beta_2 x_{i2} + \\varepsilon_i$。OLS 估计量为 $\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y}$，其中 $\\mathbf{X}$ 是设计矩阵，其行向量为 $(1, x_{i1}, x_{i2})$，$\\mathbf{y}$ 是响应向量。系数 $\\hat{\\beta}_1$ 量化了在控制度的影响下，连接强度与桥接中介中心性之间的关联。\n\n任务：\n- 对于测试套件中的每个图，使用上述定义为所有节点计算 $k_i$、$s_i$、$C_B(i)$ 和 $B(i)$，然后拟合 OLS 回归模型 $y_i = \\beta_0 + \\beta_1 s_i + \\beta_2 k_i + \\varepsilon_i$，并提取 $\\hat{\\beta}_1$（$s_i$ 的系数）。\n- 所有最短路径的计算都必须在加权图上进行，边的长度为 $\\ell_{ij} = 1/A_{ij}$。\n- 所有图都是无向连通图，因此对所有 $i$ 都有 $k_i \\ge 1$。\n\n测试套件：\n提供三个邻接矩阵，每个矩阵为测试用例 $m$ 指定为 $\\mathbf{A}^{(m)}$。\n\n1. 测试用例 1（由弱连接桥接的两个内聚群体），$n=6$：\n$$\n\\mathbf{A}^{(1)} =\n\\begin{bmatrix}\n0   5   4   0   0   0 \\\\\n5   0   5   0   0   0 \\\\\n4   5   0   1   0   0 \\\\\n0   0   1   0   5   4 \\\\\n0   0   0   5   0   5 \\\\\n0   0   0   4   5   0\n\\end{bmatrix}.\n$$\n\n2. 测试用例 2（具有异构连接强度的星形拓扑），$n=5$：\n$$\n\\mathbf{A}^{(2)} =\n\\begin{bmatrix}\n0   10  1   2   3 \\\\\n10  0   0   0   0 \\\\\n1   0   0   0   0 \\\\\n2   0   0   0   0 \\\\\n3   0   0   0   0\n\\end{bmatrix}.\n$$\n\n3. 测试用例 3（一个紧密闭合的三元组通过弱连接与一个线性链相连），$n=5$：\n$$\n\\mathbf{A}^{(3)} =\n\\begin{bmatrix}\n0   6   6   0   0 \\\\\n6   0   6   0   0 \\\\\n6   6   0   1   0 \\\\\n0   0   1   0   2 \\\\\n0   0   0   2   0\n\\end{bmatrix}.\n$$\n\n输出规范：\n- 对于每个测试用例 $m \\in \\{1,2,3\\}$，计算连接强度 $s_i$ 的 OLS 系数 $\\hat{\\beta}_1^{(m)}$。\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如，`[result1,result2,result3]`）。每个结果必须是浮点数。不应打印任何其他文本。",
            "solution": "该问题要求计算一个特定的回归系数，此系数用于量化在一组指定图上节点级连接强度与桥接中介中心性之间的关系，同时控制节点度的影响。该解决方案通过实施一个基于所提供定义的计算流程来执行。对于每个图，这涉及一个多步骤过程：计算基本节点属性，确定所有节点对之间的最短路径以计算中介中心性，最后进行普通最小二乘法（OLS）回归。\n\n设给定的加权无向图由其邻接矩阵 $\\mathbf{A}$ 表示，其中 $A_{ij}$ 是节点 $i$ 和 $j$ 之间边的权重。\n\n**第一步：计算节点级结构属性**\n\n对于图中 $n$ 个节点中的每个节点 $i$，我们首先计算其基本属性：结构度（$k_i$）和连接强度（$s_i$）。\n\n1.  **结构度（$k_i$）**：度 $k_i$ 是节点 $i$ 拥有的直接连接数。通过计算邻接矩阵 $\\mathbf{A}$ 的第 $i$ 行（或列）中的非零元素数量得出：\n    $$k_i = \\left|\\{j \\in \\{1,\\dots,n\\} : A_{ij} > 0\\}\\right|$$\n    问题说明所有图都是连通的，这意味着对所有 $i$ 都有 $k_i \\ge 1$。\n\n2.  **连接强度（$s_i$）**：连接强度 $s_i$ 定义为与节点 $i$ 相连的所有边的平均权重。它通过将这些边的权重相加并除以节点的度 $k_i$ 来计算：\n    $$s_i = \\frac{1}{k_i} \\sum_{j : A_{ij} > 0} A_{ij}$$\n\n**第二步：计算桥接中介中心性**\n\n此步骤包括两个子过程：计算节点中介中心性（$C_B(i)$），然后通过节点的度进行归一化，得到桥接中介中心性（$B(i)$）。\n\n1.  **节点中介中心性（$C_B(i)$）**：此度量量化了一个节点 $i$ 出现在其他节点对 $(s, t)$ 之间最短路径上的频率。问题将其定义为：\n    $$C_B(i) = \\sum_{s \\ne i \\ne t, s \\ne t} \\frac{\\sigma_{st}(i)}{\\sigma_{st}}$$\n    其中 $\\sigma_{st}$ 是节点 $s$ 和 $t$ 之间最短路径的总数，而 $\\sigma_{st}(i)$ 是这些路径中通过节点 $i$ 的数量。\n\n    最短路径的计算在一个图上进行，其中边的长度与连接强度（权重）成反比，即对于 $A_{ij} > 0$ 有 $\\ell_{ij} = 1/A_{ij}$。这正确地将更强的连接建模为更短的“社会距离”。\n\n    对所有节点计算 $C_B(i)$ 最有效的方法是使用 Brandes 算法。该算法避免了计算上昂贵的所有路径的枚举。它通过将每个节点 $s$ 作为源点进行迭代并执行以下操作：\n    a.  **单源最短路径（SSSP）**：从源点 $s$ 运行一个修改过的 Dijkstra 算法，以计算到所有其他节点 $t$ 的最短距离 $d(s, t)$ 和最短路径数 $\\sigma_{st}$。使用优先队列按距离递增的顺序探索节点。在此遍历过程中，对于每个节点 $v$，我们维护其在从 $s$ 出发的最短路径上的前驱节点列表 $P(v)$。\n    b.  **依赖累积**：在 SSSP 阶段之后，按与 $s$ 距离递减的顺序处理节点。对于每个节点 $w$，计算其对源点 $s$ 的依赖性，记为 $\\delta_s(w)$。这表示从 $s$ 到其他节点 $t$ 的最短路径中经过 $w$ 的部分之和。节点 $v$ 的依赖性根据其在从 $s$ 出发的最短路径上的后继节点 $w$ 的依赖性进行更新：\n    $$\\delta_s(v) = \\sum_{w : v \\in P(w)} \\frac{\\sigma_{sv}}{\\sigma_{sw}}(1 + \\delta_s(w))$$\n    中介中心性 $C_B(v)$ 是这些依赖性在所有可能的源点 $s$ 上的总和：$C_B(v) = \\sum_{s \\ne v} \\delta_s(v)$。定义中的求和是针对有序对 $(s,t)$ 的，这正是 Brandes 算法所计算的，因此在此定义下，对于无向图不需要额外的归一化因子（例如 $1/2$）。\n\n2.  **桥接中介中心性（$B(i)$）**：此度量是通过将标准中介中心性 $C_B(i)$ 按节点的度 $k_i$ 进行归一化得出的。\n    $$B(i) = \\frac{C_B(i)}{k_i}$$\n    这种归一化对高阶节点（中心节点）进行惩罚，并强调那些充当不同网络区域之间桥梁的节点，这些节点通常度较低但中心性较高。\n\n**第三步：普通最小二乘法（OLS）回归**\n\n最后一步是量化连接强度（$s_i$）与桥接中介中心性（$B(i)$）之间的关联，同时控制度（$k_i$）的影响。这通过拟合一个线性回归模型来实现。对于每个节点 $i$，我们定义一个响应变量 $y_i = B(i)$ 和一组预测变量：$x_{i1} = s_i$ 和 $x_{i2} = k_i$。该模型包含一个截距项 $\\beta_0$：\n$$y_i = \\beta_0 + \\beta_1 x_{i1} + \\beta_2 x_{i2} + \\varepsilon_i$$\n这可以用矩阵形式表示为 $\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon}$。响应向量为 $\\mathbf{y} = [B(0), B(1), \\dots, B(n-1)]^\\top$。设计矩阵 $\\mathbf{X}$ 是一个 $n \\times 3$ 的矩阵，其中每一行 $i$ 是 $[1, s_i, k_i]$。\n\n系数向量 $\\boldsymbol{\\beta} = [\\beta_0, \\beta_1, \\beta_2]^\\top$ 的 OLS 估计量 $\\hat{\\boldsymbol{\\beta}}$ 由正规方程给出：\n$$\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^\\top \\mathbf{X})^{-1} \\mathbf{X}^\\top \\mathbf{y}$$\n我们感兴趣的系数是 $\\hat{\\beta}_1$，它表示在保持度不变的情况下，连接强度对桥接中介中心性的偏效应。这可以通过从先前计算的度量构建矩阵 $\\mathbf{X}$ 和 $\\mathbf{y}$，并求解这个线性方程组（例如，使用 `numpy.linalg.solve`）来获得。\n\n将此完整流程应用于所提供的三个测试用例邻接矩阵中的每一个，从而得出系数 $\\hat{\\beta}_1$ 的三个不同值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main solver function that processes each test case and prints the results.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        np.array([\n            [0, 5, 4, 0, 0, 0],\n            [5, 0, 5, 0, 0, 0],\n            [4, 5, 0, 1, 0, 0],\n            [0, 0, 1, 0, 5, 4],\n            [0, 0, 0, 5, 0, 5],\n            [0, 0, 0, 4, 5, 0]\n        ]),\n        # Test case 2\n        np.array([\n            [0, 10, 1, 2, 3],\n            [10, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0],\n            [2, 0, 0, 0, 0],\n            [3, 0, 0, 0, 0]\n        ]),\n        # Test case 3\n        np.array([\n            [0, 6, 6, 0, 0],\n            [6, 0, 6, 0, 0],\n            [6, 6, 0, 1, 0],\n            [0, 0, 1, 0, 2],\n            [0, 0, 0, 2, 0]\n        ])\n    ]\n\n    results = []\n    for A in test_cases:\n        beta_1 = _process_graph(A)\n        results.append(beta_1)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _process_graph(A):\n    \"\"\"\n    Computes node metrics and performs OLS regression for a single graph.\n    \"\"\"\n    n = A.shape[0]\n\n    # Step 1: Compute k_i and s_i\n    k = np.zeros(n)\n    s = np.zeros(n)\n    for i in range(n):\n        neighbors = np.where(A[i] > 0)[0]\n        k[i] = len(neighbors)\n        if k[i] > 0:\n            s[i] = np.sum(A[i, neighbors]) / k[i]\n\n    # Step 2: Compute C_B(i) and B(i)\n    # Create length matrix L where L_ij = 1/A_ij\n    with np.errstate(divide='ignore'):\n        L = 1.0 / A\n    L[A == 0] = np.inf\n    np.fill_diagonal(L, 0)\n    \n    C_B = _compute_betweenness_centrality(n, A, L)\n    \n    # an explicit check to avoid division by zero although problem statement\n    # ensures k_i >= 1\n    B = np.zeros(n)\n    non_zero_k_indices = np.where(k > 0)[0]\n    B[non_zero_k_indices] = C_B[non_zero_k_indices] / k[non_zero_k_indices]\n\n    # Step 3: Perform OLS Regression\n    # Construct design matrix X and response vector y\n    X = np.ones((n, 3))\n    X[:, 1] = s\n    X[:, 2] = k\n    y = B\n\n    # Solve for beta using np.linalg.solve for numerical stability\n    XTX = X.T @ X\n    XTy = X.T @ y\n    \n    # Handle cases of perfect multicollinearity resulting in a singular matrix\n    if np.linalg.det(XTX) == 0:\n        # Use pseudo-inverse for non-unique solutions.\n        # This is a robust way to handle the linear algebra.\n        beta_hat = np.linalg.pinv(XTX) @ XTy\n    else:\n        beta_hat = np.linalg.solve(XTX, XTy)\n\n    beta_1 = beta_hat[1]\n    return beta_1\n\ndef _compute_betweenness_centrality(n, adj, length_matrix):\n    \"\"\"\n    Computes node betweenness centrality for a weighted graph using Brandes' algorithm.\n    \"\"\"\n    betweenness = np.zeros(n, dtype=np.float64)\n    for s_node in range(n):\n        # SSSP phase using Dijkstra's algorithm\n        stack = []\n        predecessors = [[] for _ in range(n)]\n        sigma = np.zeros(n, dtype=np.float64)\n        sigma[s_node] = 1.0\n        dist = np.full(n, np.inf, dtype=np.float64)\n        dist[s_node] = 0.0\n        \n        pq = [(0.0, s_node)]\n        \n        while pq:\n            d, u = heapq.heappop(pq)\n            \n            if d > dist[u]:\n                continue\n            \n            stack.append(u)\n            \n            # Iterate through neighbors\n            neighbors = np.where(adj[u] > 0)[0]\n            for v in neighbors:\n                l_uv = length_matrix[u, v]\n                # Path relaxation\n                if dist[v] > dist[u] + l_uv:\n                    dist[v] = dist[u] + l_uv\n                    heapq.heappush(pq, (dist[v], v))\n                    sigma[v] = 0.0\n                    predecessors[v] = []\n                \n                # Path counting on shortest path\n                # Use a small tolerance for floating point comparisons\n                if np.isclose(dist[v], dist[u] + l_uv):\n                    sigma[v] += sigma[u]\n                    predecessors[v].append(u)\n\n        # Accumulation phase\n        delta = np.zeros(n, dtype=np.float64)\n        while stack:\n            w = stack.pop()\n            for v_pred in predecessors[w]:\n                if sigma[w] != 0:\n                    delta[v_pred] += (sigma[v_pred] / sigma[w]) * (1.0 + delta[w])\n            if w != s_node:\n                betweenness[w] += delta[w]\n                \n    return betweenness\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}