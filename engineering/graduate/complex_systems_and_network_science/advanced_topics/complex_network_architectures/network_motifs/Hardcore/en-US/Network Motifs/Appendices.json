{
    "hands_on_practices": [
        {
            "introduction": "The concept of a network motif is fundamentally statistical. A recurring pattern is only considered a motif if it appears significantly more often than expected by chance. This practice  challenges you to explore this core principle through a carefully constructed thought experiment, demonstrating how high-degree nodes can create frequent subgraphs that are not, in fact, motifs. Mastering this distinction is crucial for correctly interpreting the structural organization of complex networks.",
            "id": "2753902",
            "problem": "Consider a directed gene regulatory network in synthetic biology with $N=100$ genes and no self-loops. Let node $A$ and node $B$ be two transcription factors (regulators) with very high out-degrees: $k^{\\mathrm{out}}_A=80$ and $k^{\\mathrm{out}}_B=80$. Empirically, you observe that the directed edge $A \\to B$ is present and that $A$ and $B$ co-regulate $s=50$ of the same downstream targets (that is, there are $50$ distinct nodes $C$ for which both $A \\to C$ and $B \\to C$ are present). This yields $50$ instances of the $3$-node feed-forward loop (Feed-Forward Loop (FFL): $A \\to B$, $A \\to C$, $B \\to C$) anchored at the middle edge $A \\to B$. A network motif is defined here as a subgraph that is significantly overrepresented relative to an ensemble of randomized networks that preserve the degree sequence.\n\nUse as the appropriate null model a degree-sequence-preserving directed configuration model specialized to the case where all in-degrees are approximately equal, so that each regulator $i$ independently chooses its $k^{\\mathrm{out}}_i$ distinct targets uniformly at random from the $N-1$ possible nodes (excluding itself), without replacement. Starting from these definitions and the random sampling description, reason from first principles to assess whether the observed $50$ FFLs are expected or overrepresented under the null. In particular:\n- Derive the expected number of FFLs of the form $A \\to B$, $A \\to C$, $B \\to C$ under the null.\n- Using a Poisson approximation for the variance of the count of such triads, determine whether the observed count is significantly higher than expected.\n\nWhich option best explains why, in this constructed example, the $3$-node FFL is frequent in the empirical network yet does not qualify as a network motif under the specified null model?\n\nA. The FFL is frequent because of the extreme out-degree heterogeneity of $A$ and $B$, which causes many shared targets purely by combinatorics; under the degree-sequence-preserving null, the expected FFL count is of the same order as the observation, so the pattern is not significantly overrepresented and thus not a motif.\n\nB. Any subgraph that occurs $50$ or more times is automatically a motif, because frequency alone determines significance, independent of the choice of null model.\n\nC. The FFL is not a motif because the null model preserves only the average degree and not the exact degree sequence, which artificially inflates the expected count; with a degree-sequence-preserving null, the FFL would be highly significant.\n\nD. The FFL must be a motif because it implements a useful input-output logic function; its biological function guarantees statistical overrepresentation regardless of degree distributions or null models.",
            "solution": "The problem requires an analysis of a specific subgraph's frequency in a synthetic gene regulatory network to determine if it qualifies as a network motif. I will first validate the problem statement, then proceed with a quantitative analysis based on the provided null model.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n-   Total number of genes (nodes): $N = 100$.\n-   Network is directed, with no self-loops.\n-   Node A is a regulator with out-degree $k^{\\mathrm{out}}_A = 80$.\n-   Node B is a regulator with out-degree $k^{\\mathrm{out}}_B = 80$.\n-   A specific directed edge $A \\to B$ is present.\n-   Nodes A and B co-regulate $s = 50$ distinct downstream targets, forming $50$ instances of the $3$-node feed-forward loop (FFL) of the form $A \\to B, A \\to C, B \\to C$.\n-   Definition of a network motif: A subgraph that is significantly overrepresented relative to an ensemble of randomized networks that preserve the degree sequence.\n-   Specified null model: A degree-sequence-preserving directed configuration model.\n-   Approximation for the null model: Each regulator $i$ independently chooses its $k^{\\mathrm{out}}_i$ distinct targets uniformly at random from the $N-1$ possible nodes (excluding itself), without replacement.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientific Grounding**: The concepts presented—gene regulatory networks, feed-forward loops, network motifs, and degree-sequence-preserving null models—are standard and fundamental in systems and synthetic biology. The problem is scientifically grounded.\n-   **Well-Posedness**: The problem asks for a quantitative assessment based on a clearly defined null model and provides all necessary numerical data. The question is specific and answerable.\n-   **Objectivity**: The problem is stated in objective, mathematical terms.\n-   **Consistency and Completeness**: The problem provides all necessary data ($N$, $k^{\\mathrm{out}}_A$, $k^{\\mathrm{out}}_B$, observed count $s$). The description of the null model is a standard computational approximation of a configuration model which preserves the out-degree sequence exactly. While the provided out-degrees ($80$ out of a possible $99$) are unusually high for typical biological networks, they are mathematically consistent and serve to illustrate a specific principle of network analysis. The problem is self-contained and consistent.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. I will proceed to the solution.\n\n### Derivation and Analysis\n\nThe core of the problem is to compare the observed number of FFLs, $s_{obs} = 50$, with the expected number under the specified null model. The FFLs in question share the common edge $A \\to B$ and a common target node $C$. The number of such FFLs is equal to the number of nodes $C$ (where $C \\neq A, B$) such that edges $A \\to C$ and $B \\to C$ both exist.\n\n**1. Calculate the Expected Number of FFLs**\n\nThe null model states that each regulator $i$ chooses its $k^{\\mathrm{out}}_i$ targets independently and uniformly at random from the $N-1$ other nodes. We need to find the expected number of nodes $C$ that are targeted by both A and B.\n\nLet us consider a specific node $C$, where $C \\neq A$ and $C \\neq B$. There are $N-2 = 100-2 = 98$ such potential nodes.\n\nThe probability that node A has an edge to node C, $P(A \\to C)$, is the probability that $C$ is chosen as one of A's $k^{\\mathrm{out}}_A$ targets from the $N-1$ available nodes. This probability is:\n$$ P(A \\to C) = \\frac{k^{\\mathrm{out}}_A}{N-1} = \\frac{80}{100-1} = \\frac{80}{99} $$\nSimilarly, the probability that node B has an edge to node C, $P(B \\to C)$, is:\n$$ P(B \\to C) = \\frac{k^{\\mathrm{out}}_B}{N-1} = \\frac{80}{100-1} = \\frac{80}{99} $$\nAccording to the null model, the choices of targets for A and B are independent events. Therefore, the probability that a specific node $C$ is a common target of both A and B is:\n$$ P(A \\to C \\text{ and } B \\to C) = P(A \\to C) \\times P(B \\to C) = \\left(\\frac{80}{99}\\right) \\times \\left(\\frac{80}{99}\\right) = \\frac{6400}{9801} \\approx 0.65299 $$\nThe expected number of common targets, $\\langle s \\rangle$, is the sum of these probabilities over all possible nodes $C$ (of which there are $N-2 = 98$). By linearity of expectation:\n$$ \\langle s \\rangle = \\sum_{C \\neq A, B} P(A \\to C \\text{ and } B \\to C) = (N-2) \\times P(A \\to C \\text{ and } B \\to C) $$\n$$ \\langle s \\rangle = 98 \\times \\frac{6400}{9801} = \\frac{627200}{9801} \\approx 63.99 $$\nThus, the expected number of FFLs of this type under the null model is approximately $\\langle N_{FFL} \\rangle = \\langle s \\rangle \\approx 64$.\n\n**2. Assess Significance**\n\nThe observed number of FFLs is $s_{obs}=50$. The expected number is $\\langle s \\rangle \\approx 64$.\nA network motif is defined as being *significantly overrepresented*. Here, the observed count ($50$) is *less than* the expected count ($64$). The pattern is not overrepresented at all; in fact, it is slightly underrepresented.\n\nTo formalize this, we can calculate the Z-score as suggested. The problem states to use a Poisson approximation for the variance. In a Poisson distribution, the variance is equal to the mean.\n$$ \\lambda = \\langle s \\rangle \\approx 64 $$\n$$ \\sigma^2 = \\mathrm{Var}(s) \\approx \\lambda \\approx 64 $$\nThe standard deviation is $\\sigma = \\sqrt{64} = 8$.\n\nThe Z-score measures how many standard deviations the observation is from the mean:\n$$ Z = \\frac{s_{obs} - \\langle s \\rangle}{\\sigma} = \\frac{50 - 64}{8} = \\frac{-14}{8} = -1.75 $$\nA Z-score must be large and positive for a pattern to be considered significantly overrepresented (typically $Z  2$ or $Z  3$). A negative Z-score indicates underrepresentation. Therefore, the FFL is not a network motif in this context.\n\nThe high expected count is a direct consequence of the extremely high out-degrees of nodes A and B. When two nodes each target over $80\\%$ of the network, a large overlap in their targets is expected purely by random chance. The null model, by preserving these high degrees, correctly captures this combinatorial effect.\n\n### Option-by-Option Analysis\n\n**A. The FFL is frequent because of the extreme out-degree heterogeneity of $A$ and $B$, which causes many shared targets purely by combinatorics; under the degree-sequence-preserving null, the expected FFL count is of the same order as the observation, so the pattern is not significantly overrepresented and thus not a motif.**\nThis statement aligns perfectly with the derivation. The FFL frequency of $50$ is indeed high in absolute terms. The cause is the extreme out-degrees ($k^{\\mathrm{out}}=80$) of nodes A and B, which represent a form of degree heterogeneity (they are hubs). The null model based on these degrees predicts an expected count of $\\approx 64$, which is on the same order of magnitude as the observation of $50$. Because the observed count is not significantly greater than the expected count, the subgraph is not a motif. This explanation is entirely correct.\n**Verdict: Correct.**\n\n**B. Any subgraph that occurs $50$ or more times is automatically a motif, because frequency alone determines significance, independent of the choice of null model.**\nThis statement is fundamentally incorrect. The definition of a network motif, as provided in the problem, is based on statistical significance relative to a null model. Absolute frequency is not sufficient. My analysis shows that a frequency of $50$ is not significant in this case.\n**Verdict: Incorrect.**\n\n**C. The FFL is not a motif because the null model preserves only the average degree and not the exact degree sequence, which artificially inflates the expected count; with a degree-sequence-preserving null, the FFL would be highly significant.**\nThis statement mischaracterizes the null model. The model described (\"each regulator $i$ independently chooses its $k^{\\mathrm{out}}_i$ distinct targets\") *does* preserve the out-degree sequence exactly. It is precisely *because* it preserves the high degrees of A and B that the expected count is high. A simpler null model (like Erdős-Rényi, which only preserves average degree) would have resulted in a much lower expectation, making the pattern appear significant. The statement's logic is inverted.\n**Verdict: Incorrect.**\n\n**D. The FFL must be a motif because it implements a useful input-output logic function; its biological function guarantees statistical overrepresentation regardless of degree distributions or null models.**\nThis is an argument from teleology, which is irrelevant to the statistical definition of a network motif. While a subgraph's function might provide an evolutionary reason for its overrepresentation, the status of \"motif\" is a statistical designation derived from comparing observed frequency to a null model. Function does not automatically confer motif status.\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Once we understand the statistical basis of motifs, the next step is to develop methods for counting them. This practice  introduces a powerful and elegant technique from spectral graph theory: using the trace of the adjacency matrix's powers to count closed walks. You will derive and apply the classic formula for counting 3-node directed cycles, gaining hands-on experience with a fundamental tool that connects the algebraic representation of a network to its topological structure.",
            "id": "4365973",
            "problem": "In the context of systems biomedicine, consider a directed gene regulatory subnetwork with $6$ transcriptional regulators $X_1,\\dots,X_6$. A directed edge $X_i \\to X_j$ indicates that $X_i$ regulates $X_j$. The network contains no self-loops and no multi-edges. The directed interactions are:\n- $X_1 \\to X_2$, $X_2 \\to X_3$, $X_3 \\to X_1$,\n- $X_2 \\to X_4$, $X_4 \\to X_5$, $X_5 \\to X_2$,\n- $X_3 \\to X_5$, $X_5 \\to X_6$, $X_6 \\to X_3$,\n- $X_1 \\to X_4$, $X_4 \\to X_6$, $X_2 \\to X_6$.\n\nTasks:\n1. Construct the adjacency matrix $A \\in \\mathbb{R}^{6 \\times 6}$ of this directed graph using the node ordering $(X_1,X_2,X_3,X_4,X_5,X_6)$ and the convention $A_{ij}=1$ if and only if there is a directed edge $X_i \\to X_j$, and $A_{ij}=0$ otherwise.\n2. Starting only from the definition of matrix multiplication and the characterization of closed walks in a directed graph by powers of the adjacency matrix, derive an expression for the number of distinct simple $3$-node directed cycles in terms of $\\mathrm{trace}(A^3)$, including any necessary correction factors for edge directions and node labeling.\n3. Evaluate your expression on the given network to compute the number of distinct simple $3$-node directed cycles. Express the final answer as a single integer with no units.",
            "solution": "The user-provided problem is a well-defined task in graph theory, applied to the context of gene regulatory networks. It consists of three parts: constructing an adjacency matrix, deriving a formula for counting 3-cycles, and applying the formula.\n\n### Part 1: Construction of the Adjacency Matrix\n\nThe network consists of $6$ nodes, labeled $X_1, \\dots, X_6$. The adjacency matrix $A$ is a $6 \\times 6$ matrix where $A_{ij}=1$ if there is a directed edge from node $X_i$ to node $X_j$, and $A_{ij}=0$ otherwise. The node ordering is specified as $(X_1, X_2, X_3, X_4, X_5, X_6)$.\n\nThe given directed interactions are:\n- $X_1 \\to X_2$, so $A_{12} = 1$.\n- $X_2 \\to X_3$, so $A_{23} = 1$.\n- $X_3 \\to X_1$, so $A_{31} = 1$.\n- $X_2 \\to X_4$, so $A_{24} = 1$.\n- $X_4 \\to X_5$, so $A_{45} = 1$.\n- $X_5 \\to X_2$, so $A_{52} = 1$.\n- $X_3 \\to X_5$, so $A_{35} = 1$.\n- $X_5 \\to X_6$, so $A_{56} = 1$.\n- $X_6 \\to X_3$, so $A_{63} = 1$.\n- $X_1 \\to X_4$, so $A_{14} = 1$.\n- $X_4 \\to X_6$, so $A_{46} = 1$.\n- $X_2 \\to X_6$, so $A_{26} = 1$.\n\nAll other entries are $0$. The problem states there are no self-loops, so all diagonal entries $A_{ii}$ are $0$. The resulting adjacency matrix $A$ is:\n$$\nA = \\begin{pmatrix}\n0  1  0  1  0  0 \\\\\n0  0  1  1  0  1 \\\\\n1  0  0  0  1  0 \\\\\n0  0  0  0  1  1 \\\\\n0  1  0  0  0  1 \\\\\n0  0  1  0  0  0\n\\end{pmatrix}\n$$\n\n### Part 2: Derivation for the Number of 3-Cycles\n\nLet $A$ be the adjacency matrix of a directed graph $G$ with $n$ nodes. By the definition of matrix multiplication, the entry $(A^k)_{ij}$ of the matrix $A^k$ represents the number of distinct walks of length $k$ from node $i$ to node $j$.\n\nWe are interested in simple $3$-node directed cycles. A simple $3$-node directed cycle is a closed walk of length $3$ passing through three distinct nodes, i.e., a walk of the form $i \\to j \\to k \\to i$, where $i, j, k$ are distinct.\n\nThe number of closed walks of length $3$ starting and ending at node $i$ is given by the diagonal entry $(A^3)_{ii}$. The total number of all closed walks of length $3$ in the graph is the sum of these counts over all possible starting nodes, which is the trace of the matrix $A^3$:\n$$\n\\mathrm{trace}(A^3) = \\sum_{i=1}^{n} (A^3)_{ii}\n$$\nFrom the definition of matrix multiplication, $(A^3)_{ii}$ can be expressed as:\n$$\n(A^3)_{ii} = \\sum_{j=1}^{n} \\sum_{k=1}^{n} A_{ij} A_{jk} A_{ki}\n$$\nThus, the trace is:\n$$\n\\mathrm{trace}(A^3) = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\sum_{k=1}^{n} A_{ij} A_{jk} A_{ki}\n$$\nEach term $A_{ij} A_{jk} A_{ki}$ in this sum is equal to $1$ if and only if the sequence of edges $i \\to j \\to k \\to i$ exists in the graph, forming a closed walk of length $3$. Otherwise, the term is $0$.\n\nThe problem specifies that the graph contains no self-loops. This means $A_{ll} = 0$ for all nodes $l$. Let's examine the indices $i, j, k$ for a non-zero term $A_{ij} A_{jk} A_{ki}$:\n1.  If $i=j$, the term becomes $A_{ii} A_{ik} A_{ki}$. Since $A_{ii}=0$, the term is $0$.\n2.  If $j=k$, the term becomes $A_{ij} A_{jj} A_{ji}$. Since $A_{jj}=0$, the term is $0$.\n3.  If $k=i$, the term becomes $A_{ij} A_{ji} A_{ii}$. Since $A_{ii}=0$, the term is $0$.\n4.  If $i=j=k$, the term is $A_{ii}A_{ii}A_{ii}$, which is $0$.\n\nTherefore, a non-zero contribution to the sum can only occur if the indices $i, j,$ and $k$ are all distinct. In this case, the walk $i \\to j \\to k \\to i$ is a simple $3$-node directed cycle.\n\nThe quantity $\\mathrm{trace}(A^3)$ counts the total number of ordered triples of distinct nodes $(i, j, k)$ that form a directed cycle. A single cycle, which is defined by an unordered set of three nodes $\\{v_1, v_2, v_3\\}$ and a specific cyclic ordering of edges (e.g., $v_1 \\to v_2 \\to v_3 \\to v_1$), is counted multiple times in the trace sum.\nSpecifically, this cycle will be counted for each of its nodes as a starting point:\n- As the walk $v_1 \\to v_2 \\to v_3 \\to v_1$, contributing to $(A^3)_{v_1 v_1}$.\n- As the walk $v_2 \\to v_3 \\to v_1 \\to v_2$, contributing to $(A^3)_{v_2 v_2}$.\n- As the walk $v_3 \\to v_1 \\to v_2 \\to v_3$, contributing to $(A^3)_{v_3 v_3}$.\n\nEach distinct simple $3$-node directed cycle is therefore counted exactly $3$ times by $\\mathrm{trace}(A^3)$. To find the number of distinct cycles, denoted $N_3$, we must divide the total count by $3$. This gives the expression:\n$$\nN_3 = \\frac{1}{3} \\mathrm{trace}(A^3)\n$$\nThis expression is the required result. The factor of $\\frac{1}{3}$ is the correction for the overcounting of each cycle due to the choice of starting node.\n\n### Part 3: Evaluation for the Given Network\n\nTo compute $N_3$, we must first calculate $A^2$ and then $A^3$.\n$$\nA^2 = A \\times A = \\begin{pmatrix}\n0  1  0  1  0  0 \\\\\n0  0  1  1  0  1 \\\\\n1  0  0  0  1  0 \\\\\n0  0  0  0  1  1 \\\\\n0  1  0  0  0  1 \\\\\n0  0  1  0  0  0\n\\end{pmatrix}\n\\begin{pmatrix}\n0  1  0  1  0  0 \\\\\n0  0  1  1  0  1 \\\\\n1  0  0  0  1  0 \\\\\n0  0  0  0  1  1 \\\\\n0  1  0  0  0  1 \\\\\n0  0  1  0  0  0\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0  0  1  1  1  2 \\\\\n1  0  1  0  2  1 \\\\\n0  2  0  1  0  1 \\\\\n0  1  1  0  0  1 \\\\\n0  0  2  1  0  1 \\\\\n1  0  0  0  1  0\n\\end{pmatrix}\n$$\nNext, we compute the diagonal elements of $A^3 = A \\times A^2$, as only these are needed for the trace.\n$(A^3)_{ii} = (\\text{Row } i \\text{ of } A) \\cdot (\\text{Column } i \\text{ of } A^2)$.\n- $(A^3)_{11} = (0,1,0,1,0,0) \\cdot (0,1,0,0,0,1)^T = 0 \\cdot 0 + 1 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 0 + 0 \\cdot 0 + 0 \\cdot 1 = 1$\n- $(A^3)_{22} = (0,0,1,1,0,1) \\cdot (0,0,2,1,0,0)^T = 0 \\cdot 0 + 0 \\cdot 0 + 1 \\cdot 2 + 1 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 0 = 3$\n- $(A^3)_{33} = (1,0,0,0,1,0) \\cdot (1,1,0,1,2,0)^T = 1 \\cdot 1 + 0 \\cdot 1 + 0 \\cdot 0 + 0 \\cdot 1 + 1 \\cdot 2 + 0 \\cdot 0 = 3$\n- $(A^3)_{44} = (0,0,0,0,1,1) \\cdot (1,0,1,0,1,0)^T = 0 \\cdot 1 + 0 \\cdot 0 + 0 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 1 + 1 \\cdot 0 = 1$\n- $(A^3)_{55} = (0,1,0,0,0,1) \\cdot (1,2,0,0,0,1)^T = 0 \\cdot 1 + 1 \\cdot 2 + 0 \\cdot 0 + 0 \\cdot 0 + 0 \\cdot 0 + 1 \\cdot 1 = 3$\n- $(A^3)_{66} = (0,0,1,0,0,0) \\cdot (2,1,1,1,1,0)^T = 0 \\cdot 2 + 0 \\cdot 1 + 1 \\cdot 1 + 0 \\cdot 1 + 0 \\cdot 1 + 0 \\cdot 0 = 1$\n\nThe trace of $A^3$ is the sum of these diagonal elements:\n$$\n\\mathrm{trace}(A^3) = 1 + 3 + 3 + 1 + 3 + 1 = 12\n$$\nUsing the derived formula, the number of distinct simple $3$-node directed cycles is:\n$$\nN_3 = \\frac{1}{3} \\mathrm{trace}(A^3) = \\frac{1}{3} (12) = 4\n$$\nThere are $4$ such cycles in the given network. For completeness, these cycles are:\n1. $X_1 \\to X_2 \\to X_3 \\to X_1$\n2. $X_2 \\to X_4 \\to X_5 \\to X_2$\n3. $X_3 \\to X_5 \\to X_6 \\to X_3$\n4. $X_2 \\to X_3 \\to X_5 \\to X_2$",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "The significance of network motifs extends beyond global network characterization to the roles of individual nodes. This advanced practice  guides you through computing node-level motif participation profiles and using them to classify nodes into distinct functional roles, such as 'clique-oriented' or 'broker-oriented'. By comparing a node's motif involvement to that of a randomized null model, you will learn to uncover the functional signatures encoded in the local connectivity patterns of a network.",
            "id": "4291115",
            "problem": "You are given undirected, simple graphs represented by adjacency matrices. Your task is to compute node-level motif participation profiles for each node and use these profiles to classify nodes into functional roles. The motifs considered are the $3$-node triangle and the $3$-node wedge (open triad centered at a node). The classification must be computed from first principles and be deterministic.\n\nFundamental base definitions and constraints:\n- A graph is represented by a symmetric adjacency matrix $A \\in \\{0,1\\}^{n \\times n}$ with $A_{ii} = 0$ for all $i$, where $n$ is the number of nodes.\n- For node $i$, let $N(i) = \\{j \\in \\{1,\\dots,n\\} \\mid A_{ij} = 1\\}$ denote its neighbor set, and $d_i = |N(i)|$ its degree.\n- A triangle participated by node $i$ is defined as any unordered pair $\\{j,k\\} \\subset N(i)$ with $A_{jk}=1$. The node-level triangle count is\n$$\nT_i = \\sum_{\\{j,k\\} \\subset N(i),\\, jk} \\mathbf{1}\\{A_{jk} = 1\\}.\n$$\n- A wedge participated by node $i$ is defined as any unordered pair $\\{j,k\\} \\subset N(i)$ with $A_{jk}=0$. The node-level wedge count is\n$$\nW_i = \\sum_{\\{j,k\\} \\subset N(i),\\, jk} \\mathbf{1}\\{A_{jk} = 0\\}.\n$$\n- The combination identity $T_i + W_i = \\binom{d_i}{2}$ must hold for all $i$.\n\nNull model and statistical profiling:\n- Use a degree-preserving randomization based on edge swaps (also called the switching model) to generate reference graphs. One swap attempt picks two edges $\\{u,v\\}$ and $\\{x,y\\}$ with $u  v$, $x  y$ and all endpoints distinct, and proposes rewiring to either $\\{u,y\\}, \\{x,v\\}$ or $\\{u,x\\}, \\{v,y\\}$ chosen uniformly, provided the proposed edges do not already exist and do not create self-loops. Accepted swaps preserve degrees and maintain a simple graph.\n- For each test case, generate $R$ randomized graphs and for each randomized graph perform $S$ swap attempts starting from the original $A$ to encourage mixing. For each node $i$ record $T_i^{(r)}$ and $W_i^{(r)}$ across $r \\in \\{1,\\dots,R\\}$.\n- Estimate the node-level expectations and standard deviations under the null as\n$$\n\\mu_{T,i} = \\frac{1}{R} \\sum_{r=1}^{R} T_i^{(r)}, \\quad \\sigma_{T,i} = \\sqrt{\\frac{1}{R-1} \\sum_{r=1}^{R} \\left(T_i^{(r)} - \\mu_{T,i}\\right)^2},\n$$\n$$\n\\mu_{W,i} = \\frac{1}{R} \\sum_{r=1}^{R} W_i^{(r)}, \\quad \\sigma_{W,i} = \\sqrt{\\frac{1}{R-1} \\sum_{r=1}^{R} \\left(W_i^{(r)} - \\mu_{W,i}\\right)^2}.\n$$\n- Define node-level motif $z$-scores\n$$\nz_{T,i} = \\begin{cases}\n\\frac{T_i - \\mu_{T,i}}{\\sigma_{T,i}},  \\text{if } \\sigma_{T,i}  0,\\\\\n0,  \\text{otherwise,}\n\\end{cases}\n\\qquad\nz_{W,i} = \\begin{cases}\n\\frac{W_i - \\mu_{W,i}}{\\sigma_{W,i}},  \\text{if } \\sigma_{W,i}  0,\\\\\n0,  \\text{otherwise.}\n\\end{cases}\n$$\n\nRole classification:\n- Assign each node a role based on its node-level motif significance profile $(z_{T,i}, z_{W,i})$ and degree $d_i$ using the following deterministic rule:\n    - If $d_i  2$, assign role $0$ (peripheral).\n    - Else, if $z_{T,i} \\ge z_{W,i}$, assign role $1$ (clique-oriented).\n    - Else, assign role $2$ (broker-oriented).\nThis rule operationalizes the intuition that triangles indicate local clustering (clique-oriented) and wedges indicate bridging potential (broker-oriented).\n\nTest suite:\n- Use the following three test graphs, each specified by its number of nodes and undirected edge list. The values of $R$ (number of randomized graphs), $S$ (swap attempts per randomized graph), and the pseudorandom seed are also specified for reproducibility. All numbers are fixed.\n    1. Graph $G_1$ (a $4$-clique with a dangling bridge):\n        - Nodes: $n = 6$.\n        - Edges: $\\{(0,1),(0,2),(0,3),(1,2),(1,3),(2,3),(0,4),(4,5)\\}$.\n        - Randomization parameters: $R = 200$, $S = 400$, seed $= 202311$.\n    2. Graph $G_2$ (a $6$-cycle):\n        - Nodes: $n = 6$.\n        - Edges: $\\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,0)\\}$.\n        - Randomization parameters: $R = 200$, $S = 400$, seed $= 202312$.\n    3. Graph $G_3$ (a $6$-node star):\n        - Nodes: $n = 6$.\n        - Edges: $\\{(0,1),(0,2),(0,3),(0,4),(0,5)\\}$.\n        - Randomization parameters: $R = 200$, $S = 400$, seed $= 202313$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the classification results for all test cases as a comma-separated list enclosed in square brackets, where each test case result is itself a comma-separated list enclosed in square brackets of the per-node integer roles in node index order. For example, an output of the form $[[r_{1,0},r_{1,1},\\dots],[r_{2,0},\\dots],[r_{3,0},\\dots]]$ must be printed exactly with no spaces: \"[[...],[...],[...]]\".\n- All outputs are integers; there are no physical units involved.\n\nYour implementation must be a complete, runnable program adhering strictly to the specified environment.",
            "solution": "We begin with the fundamental representation of a simple undirected graph by a symmetric adjacency matrix $A \\in \\{0,1\\}^{n \\times n}$ with zero diagonal. For each node $i$, its neighbor set $N(i)$ and degree $d_i$ are defined by $N(i) = \\{j \\mid A_{ij} = 1\\}$ and $d_i = |N(i)|$.\n\nThe node-level motifs considered are the triangle and the wedge (an open triad centered at the node). The triangle count $T_i$ counts unordered neighbor pairs $\\{j,k\\} \\subset N(i)$ that are mutually connected, while the wedge count $W_i$ counts unordered neighbor pairs that are not connected. Formally,\n$$\nT_i = \\sum_{\\{j,k\\} \\subset N(i),\\, jk} \\mathbf{1}\\{A_{jk} = 1\\}, \\quad\nW_i = \\sum_{\\{j,k\\} \\subset N(i),\\, jk} \\mathbf{1}\\{A_{jk} = 0\\}.\n$$\nBecause every unordered pair of neighbors is either connected or not, we have the identity\n$$\nT_i + W_i = \\binom{d_i}{2}.\n$$\n\nTo interpret motif participation in a statistically grounded way, we compare the observed counts $(T_i, W_i)$ to a null model that preserves degrees. The switching model (degree-preserving edge swaps) constructs randomized graphs with the same degree sequence by repeatedly selecting two edges $\\{u,v\\}$ and $\\{x,y\\}$ with all endpoints distinct and proposing a rewiring to either $\\{u,y\\}, \\{x,v\\}$ or $\\{u,x\\}, \\{v,y\\}$ uniformly, provided the rewiring does not create self-loops and does not introduce duplicate edges. Accepting such swaps preserves degrees of all nodes and maintains a simple graph.\n\nFor a fixed graph $A$, we generate $R$ randomized graphs by starting from $A$ and performing $S$ swap attempts per randomized graph. On each randomized graph $r \\in \\{1,\\dots,R\\}$ we compute node-level counts $T_i^{(r)}$ and $W_i^{(r)}$. From these samples we estimate the per-node expectations and standard deviations,\n$$\n\\mu_{T,i} = \\frac{1}{R} \\sum_{r=1}^{R} T_i^{(r)}, \\quad\n\\sigma_{T,i} = \\sqrt{\\frac{1}{R-1} \\sum_{r=1}^{R} \\left(T_i^{(r)} - \\mu_{T,i}\\right)^2},\n$$\n$$\n\\mu_{W,i} = \\frac{1}{R} \\sum_{r=1}^{R} W_i^{(r)}, \\quad\n\\sigma_{W,i} = \\sqrt{\\frac{1}{R-1} \\sum_{r=1}^{R} \\left(W_i^{(r)} - \\mu_{W,i}\\right)^2}.\n$$\nWe then compute node-level $z$-scores,\n$$\nz_{T,i} = \\begin{cases}\n\\frac{T_i - \\mu_{T,i}}{\\sigma_{T,i}},  \\text{if } \\sigma_{T,i}  0,\\\\\n0,  \\text{otherwise,}\n\\end{cases}\n\\qquad\nz_{W,i} = \\begin{cases}\n\\frac{W_i - \\mu_{W,i}}{\\sigma_{W,i}},  \\text{if } \\sigma_{W,i}  0,\\\\\n0,  \\text{otherwise.}\n\\end{cases}\n$$\nThis normalization ensures that nodes are compared relative to the variability expected under the degree-preserving null model. If the variability is zero (which can occur for certain degree sequences or small graphs), setting the corresponding $z$-score to $0$ avoids undefined behavior.\n\nFinally, we classify nodes into roles:\n- If $d_i  2$, we assign role $0$ (peripheral). This accounts for nodes that cannot participate in any $3$-node motif by definition, since $\\binom{d_i}{2} = 0$ when $d_i  2$.\n- Otherwise, we compare $z_{T,i}$ and $z_{W,i}$. If $z_{T,i} \\ge z_{W,i}$, we assign role $1$ (clique-oriented); else role $2$ (broker-oriented). This deterministic rule uses the node-level motif significance profile to favor triangle participation as indicative of local clustering versus wedge participation as indicative of bridging structure.\n\nAlgorithmic steps:\n1. Construct the adjacency matrix $A$ from the given edge list.\n2. Compute $d_i$ for all $i$ and the observed $(T_i, W_i)$ using pairwise checks within $N(i)$.\n3. For the given $R$, $S$, and fixed seed, draw $R$ randomized graphs via degree-preserving edge swaps, each with $S$ swap attempts starting from $A$.\n4. On each randomized graph, compute $(T_i^{(r)}, W_i^{(r)})$ for all nodes; aggregate into $\\mu_{T,i}$, $\\sigma_{T,i}$, $\\mu_{W,i}$, $\\sigma_{W,i}$.\n5. Compute $z_{T,i}$ and $z_{W,i}$ with the fallback to $0$ if the standard deviation is $0$.\n6. Apply the role classification rule to produce an integer role for each node.\n7. Repeat for each test graph and aggregate the per-graph role lists into the required output format without spaces.\n\nDesign considerations ensure scientific realism:\n- The motifs, counts, and null model are standard in network science, preserving the degree sequence which is a fundamental structural property.\n- The classification rule derives from the principle that triangles contribute to local cohesion while wedges contribute to brokerage, anchored by $z$-scores that measure deviation from a well-defined null model.\n- Boundary conditions are explicitly handled via the degree threshold $d_i  2$.\n\nThe program implements these steps and produces the required single-line output of integer lists for the provided test suite.",
            "answer": "```python\nimport numpy as np\n\ndef build_adjacency(n, edges):\n    \"\"\"Build symmetric adjacency matrix for an undirected simple graph.\"\"\"\n    A = np.zeros((n, n), dtype=int)\n    for u, v in edges:\n        if u == v:\n            continue\n        A[u, v] = 1\n        A[v, u] = 1\n    np.fill_diagonal(A, 0)\n    return A\n\ndef neighbors_of(A, i):\n    \"\"\"Return neighbors of node i.\"\"\"\n    return np.where(A[i] == 1)[0]\n\ndef count_triangles_wedges_per_node(A):\n    \"\"\"Count triangles and wedges per node.\"\"\"\n    n = A.shape[0]\n    triangles = np.zeros(n, dtype=int)\n    wedges = np.zeros(n, dtype=int)\n    for i in range(n):\n        nbrs = neighbors_of(A, i)\n        k = len(nbrs)\n        if k  2:\n            continue\n        # count unordered pairs among neighbors\n        for a in range(k):\n            for b in range(a + 1, k):\n                u = nbrs[a]\n                v = nbrs[b]\n                if A[u, v] == 1:\n                    triangles[i] += 1\n                else:\n                    wedges[i] += 1\n    return triangles, wedges\n\ndef get_edge_list(A):\n    \"\"\"Return list of undirected edges (u,v) with u  v.\"\"\"\n    n = A.shape[0]\n    edges = []\n    for u in range(n):\n        for v in range(u + 1, n):\n            if A[u, v] == 1:\n                edges.append((u, v))\n    return edges\n\ndef attempt_swap(A, rng):\n    \"\"\"Attempt a single degree-preserving edge swap; return True if performed.\"\"\"\n    edges = get_edge_list(A)\n    m = len(edges)\n    if m  2:\n        return False\n    # choose two distinct edges uniformly at random\n    idx = rng.integers(0, m, size=2)\n    if idx[0] == idx[1]:\n        return False\n    (u, v) = edges[idx[0]]\n    (x, y) = edges[idx[1]]\n    # ensure all endpoints distinct\n    endpoints = {u, v, x, y}\n    if len(endpoints)  4:\n        return False\n    # choose one of two rewiring options at random\n    if rng.integers(0, 2) == 0:\n        a, b = u, y\n        c, d = x, v\n    else:\n        a, b = u, x\n        c, d = v, y\n    # avoid self-loops\n    if a == b or c == d:\n        return False\n    # avoid existing edges and parallel edges\n    if A[a, b] == 1 or A[c, d] == 1:\n        return False\n    # perform swap: remove original edges, add new edges\n    A[u, v] = 0\n    A[v, u] = 0\n    A[x, y] = 0\n    A[y, x] = 0\n    A[a, b] = 1\n    A[b, a] = 1\n    A[c, d] = 1\n    A[d, c] = 1\n    return True\n\ndef randomize_graph(A, swaps, rng):\n    \"\"\"Return a randomized graph via degree-preserving swaps starting from A.\"\"\"\n    Ar = A.copy()\n    attempts = 0\n    successes = 0\n    # perform up to 'swaps' attempts; successful swaps will be = swaps\n    while attempts  swaps:\n        attempts += 1\n        if attempt_swap(Ar, rng):\n            successes += 1\n    return Ar\n\ndef null_stats(A, R, S, rng):\n    \"\"\"Compute null model mean and std for triangles and wedges per node.\"\"\"\n    n = A.shape[0]\n    tri_samples = np.zeros((R, n), dtype=float)\n    wed_samples = np.zeros((R, n), dtype=float)\n    for r in range(R):\n        Ar = randomize_graph(A, S, rng)\n        T, W = count_triangles_wedges_per_node(Ar)\n        tri_samples[r] = T\n        wed_samples[r] = W\n    mu_T = tri_samples.mean(axis=0)\n    mu_W = wed_samples.mean(axis=0)\n    # sample standard deviation (ddof=1); handle R==1 separately if needed\n    if R  1:\n        sigma_T = tri_samples.std(axis=0, ddof=1)\n        sigma_W = wed_samples.std(axis=0, ddof=1)\n    else:\n        sigma_T = np.zeros(n, dtype=float)\n        sigma_W = np.zeros(n, dtype=float)\n    return mu_T, sigma_T, mu_W, sigma_W\n\ndef classify_roles(A, R, S, seed):\n    \"\"\"Classify nodes into roles 0,1,2 based on node-level motif z-scores.\"\"\"\n    rng = np.random.default_rng(seed)\n    degrees = A.sum(axis=1)\n    T_obs, W_obs = count_triangles_wedges_per_node(A)\n    mu_T, sigma_T, mu_W, sigma_W = null_stats(A, R, S, rng)\n    # compute z-scores with zero fallback\n    z_T = np.zeros_like(mu_T)\n    z_W = np.zeros_like(mu_W)\n    for i in range(A.shape[0]):\n        if sigma_T[i]  0:\n            z_T[i] = (T_obs[i] - mu_T[i]) / sigma_T[i]\n        else:\n            z_T[i] = 0.0\n        if sigma_W[i]  0:\n            z_W[i] = (W_obs[i] - mu_W[i]) / sigma_W[i]\n        else:\n            z_W[i] = 0.0\n    roles = []\n    for i in range(A.shape[0]):\n        if degrees[i]  2:\n            roles.append(0)  # peripheral\n        else:\n            if z_T[i] = z_W[i]:\n                roles.append(1)  # clique-oriented\n            else:\n                roles.append(2)  # broker-oriented\n    return roles\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, edges, R, S, seed)\n        (6, [(0,1),(0,2),(0,3),(1,2),(1,3),(2,3),(0,4),(4,5)], 200, 400, 202311),\n        (6, [(0,1),(1,2),(2,3),(3,4),(4,5),(5,0)], 200, 400, 202312),\n        (6, [(0,1),(0,2),(0,3),(0,4),(0,5)], 200, 400, 202313),\n    ]\n\n    results = []\n    for n, edges, R, S, seed in test_cases:\n        A = build_adjacency(n, edges)\n        roles = classify_roles(A, R, S, seed)\n        results.append(roles)\n\n    # Format the output as a single line with no spaces: [[...],[...],[...]]\n    formatted = \"[\" + \",\".join(\"[\" + \",\".join(map(str, r)) + \"]\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}