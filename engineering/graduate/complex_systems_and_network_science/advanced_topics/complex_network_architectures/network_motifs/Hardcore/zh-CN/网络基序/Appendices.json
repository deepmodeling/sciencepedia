{
    "hands_on_practices": [
        {
            "introduction": "网络基序并不仅仅是频繁出现的子图；它的出现频率必须显著高于在随机网络中的期望。本练习将通过一个思想实验，挑战你对这一基本区别的理解。你将分析一个假设情景：其中一种模式虽然常见，但并不满足基序的条件，从而让你深刻体会到“零模型”在基序发现中的关键作用。",
            "id": "2753902",
            "problem": "考虑一个合成生物学中的有向基因调控网络，该网络包含 $N=100$ 个基因且无自环。设节点 $A$ 和节点 $B$ 是两个具有极高出度的转录因子（调控因子）：$k^{\\mathrm{out}}_A=80$ 和 $k^{\\mathrm{out}}_B=80$。根据经验观察，有向边 $A \\to B$ 存在，并且 $A$ 和 $B$ 共同调控 $s=50$ 个相同的下游靶标（即，存在 $50$ 个不同的节点 $C$，使得 $A \\to C$ 和 $B \\to C$ 两条边都存在）。这产生了 $50$ 个以中间边 $A \\to B$ 为锚点的 $3$ 节点前馈环（Feed-Forward Loop (FFL): $A \\to B$, $A \\to C$, $B \\to C$）实例。在此，网络基序定义为：与一个保持度序列的随机网络系综相比，其出现频率显著富集的子图。\n\n使用一个保持度序列的有向配置模型作为合适的零模型，该模型专门针对所有入度近似相等的情况，因此每个调控因子 $i$ 从 $N-1$ 个可能的节点（不包括其自身）中，独立、均匀、无放回地随机选择其 $k^{\\mathrm{out}}_i$ 个不同的靶标。从这些定义和随机抽样描述出发，根据第一性原理进行推理，以评估在零模型下，观测到的 $50$ 个 FFL 是符合预期的还是显著富集的。具体来说：\n- 在零模型下，推导形式为 $A \\to B$, $A \\to C$, $B \\to C$ 的 FFL 的期望数量。\n- 使用泊松近似来计算此类三元组计数的方差，判断观测到的计数是否显著高于期望值。\n\n在本文构建的例子中，哪个选项最好地解释了为什么 $3$ 节点 FFL 在经验网络中频繁出现，但在指定的零模型下却不符合网络基序的资格？\n\nA. FFL 的频繁出现是由于 $A$ 和 $B$ 极端的出度异质性，这纯粹由组合学导致了许多共享靶标；在保持度序列的零模型下，FFL 的期望计数与观测值处于同一数量级，因此该模式并非显著富集，故而不构成基序。\n\nB. 任何出现 $50$ 次或以上的子图都会自动成为基序，因为仅频率本身就决定了显著性，而与零模型的选择无关。\n\nC. FFL 不是基序，因为零模型只保留了平均度而不是确切的度序列，这人为地夸大了期望计数；如果使用保持度序列的零模型，FFL 将是高度显著的。\n\nD. FFL 必定是基序，因为它实现了一个有用的输入输出逻辑功能；其生物学功能保证了其统计上的显著富集，而与度分布或零模型无关。",
            "solution": "该问题要求分析一个特定子图在合成基因调控网络中的频率，以确定它是否符合网络基序的资格。我将首先验证问题陈述，然后基于提供的零模型进行定量分析。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n-   基因（节点）总数：$N = 100$。\n-   网络是有向的，无自环。\n-   节点 A 是一个出度为 $k^{\\mathrm{out}}_A = 80$ 的调控因子。\n-   节点 B 是一个出度为 $k^{\\mathrm{out}}_B = 80$ 的调控因子。\n-   存在一条特定的有向边 $A \\to B$。\n-   节点 A 和 B 共同调控 $s = 50$ 个不同的下游靶标，形成 $50$ 个形式为 $A \\to B, A \\to C, B \\to C$ 的 $3$ 节点前馈环 (FFL) 实例。\n-   网络基序的定义：与一个保持度序列的随机网络系综相比，其出现频率显著富集的子图。\n-   指定的零模型：一个保持度序列的有向配置模型。\n-   零模型的近似：每个调控因子 $i$ 从 $N-1$ 个可能的节点（不包括其自身）中，独立、均匀、无放回地随机选择其 $k^{\\mathrm{out}}_i$ 个不同的靶标。\n\n**步骤 2：使用已知条件进行验证**\n-   **科学基础**：所呈现的概念——基因调控网络、前馈环、网络基序和保持度序列的零模型——都是系统生物学和合成生物学中的标准和基本概念。该问题具有科学依据。\n-   **良定性**：该问题要求基于一个明确定义的零模型进行定量评估，并提供了所有必要的数值数据。问题具体且可回答。\n-   **客观性**：问题以客观的数学术语陈述。\n-   **一致性和完整性**：问题提供了所有必要的数据（$N$, $k^{\\mathrm{out}}_A$, $k^{\\mathrm{out}}_B$, 观测计数 $s$）。对零模型的描述是一个配置模型的标准计算近似，该模型能精确地保持出度序列。尽管所提供的出度（在可能的 $99$ 个中占 $80$ 个）对于典型的生物网络来说异常高，但它们在数学上是一致的，并用于说明网络分析的一个特定原理。该问题是自洽且一致的。\n\n**步骤 3：结论与行动**\n问题陈述是有效的。我将继续进行解答。\n\n### 推导与分析\n\n问题的核心是将观测到的 FFL 数量 $s_{obs} = 50$ 与指定零模型下的期望数量进行比较。所讨论的 FFL 共享公共边 $A \\to B$ 和一个公共靶节点 $C$。此类 FFL 的数量等于满足边 $A \\to C$ 和 $B \\to C$ 同时存在的节点 $C$（其中 $C \\neq A, B$）的数量。\n\n**1. 计算 FFL 的期望数量**\n\n零模型规定，每个调控因子 $i$ 从其他 $N-1$ 个节点中独立、均匀、随机地选择其 $k^{\\mathrm{out}}_i$ 个靶标。我们需要计算同时被 A 和 B 作为靶标的节点 $C$ 的期望数量。\n\n让我们考虑一个特定的节点 $C$，其中 $C \\neq A$ 且 $C \\neq B$。共有 $N-2 = 100-2 = 98$ 个这样的潜在节点。\n\n节点 A 到节点 C 存在一条边的概率 $P(A \\to C)$，是节点 C 从 $N-1$ 个可用节点中被选为 A 的 $k^{\\mathrm{out}}_A$ 个靶标之一的概率。这个概率是：\n$$ P(A \\to C) = \\frac{k^{\\mathrm{out}}_A}{N-1} = \\frac{80}{100-1} = \\frac{80}{99} $$\n类似地，节点 B 到节点 C 存在一条边的概率 $P(B \\to C)$ 是：\n$$ P(B \\to C) = \\frac{k^{\\mathrm{out}}_B}{N-1} = \\frac{80}{100-1} = \\frac{80}{99} $$\n根据零模型，A 和 B 的靶标选择是独立事件。因此，一个特定节点 $C$ 同时是 A 和 B 的公共靶标的概率是：\n$$ P(A \\to C \\text{ and } B \\to C) = P(A \\to C) \\times P(B \\to C) = \\left(\\frac{80}{99}\\right) \\times \\left(\\frac{80}{99}\\right) = \\frac{6400}{9801} \\approx 0.65299 $$\n公共靶标的期望数量 $\\langle s \\rangle$ 是对所有可能的节点 $C$（共有 $N-2 = 98$ 个）的这些概率求和。根据期望的线性性：\n$$ \\langle s \\rangle = \\sum_{C \\neq A, B} P(A \\to C \\text{ and } B \\to C) = (N-2) \\times P(A \\to C \\text{ and } B \\to C) $$\n$$ \\langle s \\rangle = 98 \\times \\frac{6400}{9801} = \\frac{627200}{9801} \\approx 63.99 $$\n因此，在这种零模型下，此类 FFL 的期望数量约为 $\\langle N_{FFL} \\rangle = \\langle s \\rangle \\approx 64$。\n\n**2. 评估显著性**\n\n观测到的 FFL 数量为 $s_{obs}=50$。期望数量为 $\\langle s \\rangle \\approx 64$。\n网络基序被定义为*显著富集*。在这里，观测计数（$50$）*小于*期望计数（$64$）。该模式根本没有富集；实际上，它略有稀疏。\n\n为了将其形式化，我们可以按建议计算 Z 分数。问题指出使用泊松近似来计算方差。在泊松分布中，方差等于均值。\n$$ \\lambda = \\langle s \\rangle \\approx 64 $$\n$$ \\sigma^2 = \\mathrm{Var}(s) \\approx \\lambda \\approx 64 $$\n标准差是 $\\sigma = \\sqrt{64} = 8$。\n\nZ 分数衡量观测值与均值之间相差多少个标准差：\n$$ Z = \\frac{s_{obs} - \\langle s \\rangle}{\\sigma} = \\frac{50 - 64}{8} = \\frac{-14}{8} = -1.75 $$\n一个模式要被认为是显著富集，其 Z 分数必须是大的正数（通常 $Z > 2$ 或 $Z > 3$）。负的 Z 分数表示稀疏。因此，在此背景下，FFL 不是网络基序。\n\n高的期望计数是节点 A 和 B 极高出度的直接结果。当两个节点各自靶向网络中超过 $80\\%$ 的节点时，纯粹由于随机机会，它们的靶标就会有很大的重叠。通过保留这些高 度，零模型正确地捕捉到了这种组合效应。\n\n### 逐项分析\n\n**A. FFL 的频繁出现是由于 $A$ 和 $B$ 极端的出度异质性，这纯粹由组合学导致了许多共享靶标；在保持度序列的零模型下，FFL 的期望计数与观测值处于同一数量级，因此该模式并非显著富集，故而不构成基序。**\n该陈述与推导完全一致。FFL 出现的频率 $50$ 在绝对值上确实很高。其原因是节点 A 和 B 极端的出度（$k^{\\mathrm{out}}=80$），这代表了一种度异质性（它们是枢纽节点）。基于这些度的零模型预测的期望计数约为 $64$，与 $50$ 的观测值在同一数量级。因为观测计数没有显著大于期望计数，所以该子图不是一个基序。这个解释完全正确。\n**结论：正确。**\n\n**B. 任何出现 $50$ 次或以上的子图都会自动成为基序，因为仅频率本身就决定了显著性，而与零模型的选择无关。**\n这一陈述从根本上是错误的。如问题中所述，网络基序的定义是基于相对于零模型的统计显著性。绝对频率是不够的。我的分析表明，在这种情况下，频率为 $50$ 并不显著。\n**结论：错误。**\n\n**C. FFL 不是基序，因为零模型只保留了平均度而不是确切的度序列，这人为地夸大了期望计数；如果使用保持度序列的零模型，FFL 将是高度显著的。**\n这个陈述错误地描述了零模型。所描述的模型（“每个调控因子 $i$ 独立选择其 $k^{\\mathrm{out}}_i$ 个不同的靶标”）*确实*精确地保持了出度序列。正是*因为*它保留了 A 和 B 的高度，期望计数才会很高。一个更简单的零模型（如只保留平均度的 Erdős-Rényi 模型）会导致期望值低得多，从而使该模式显得显著。该陈述的逻辑是颠倒的。\n**结论：错误。**\n\n**D. FFL 必定是基序，因为它实现了一个有用的输入输出逻辑功能；其生物学功能保证了其统计上的显著富集，而与度分布或零模型无关。**\n这是一个目的论的论点，与网络基序的统计定义无关。虽然子图的功能可能为其显著富集提供了进化上的原因，但“基序”的地位是一个统计上的称号，源于将观测频率与零模型进行比较。功能并不会自动赋予其基序的地位。\n**结论：错误。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "有了统计定义之后，我们需要高效的算法来计数基序。本练习将深入探讨图论与线性代数之间优美的联系，演示如何推导和应用一个基于邻接矩阵的公式来计算3节点有向环——这是最简单也最重要的有向基序之一。",
            "id": "4365973",
            "problem": "在系统生物医学的背景下，考虑一个包含 $6$ 个转录调节因子 $X_1,\\dots,X_6$ 的有向基因调控子网络。一条有向边 $X_i \\to X_j$ 表示 $X_i$ 调控 $X_j$。该网络不包含自环和多重边。有向相互作用如下：\n- $X_1 \\to X_2$、 $X_2 \\to X_3$、 $X_3 \\to X_1$，\n- $X_2 \\to X_4$、 $X_4 \\to X_5$、 $X_5 \\to X_2$，\n- $X_3 \\to X_5$、 $X_5 \\to X_6$、 $X_6 \\to X_3$，\n- $X_1 \\to X_4$、 $X_4 \\to X_6$、 $X_2 \\to X_6$。\n\n任务：\n1. 使用节点顺序 $(X_1,X_2,X_3,X_4,X_5,X_6)$ 和约定（当且仅当存在一条从 $X_i$ 到 $X_j$ 的有向边时，$A_{ij}=1$，否则 $A_{ij}=0$）构建此有向图的邻接矩阵 $A \\in \\mathbb{R}^{6 \\times 6}$。\n2. 仅从矩阵乘法的定义和通过邻接矩阵的幂来表征有向图中的闭合路径出发，推导出一个用 $\\mathrm{trace}(A^3)$ 表示的不同简单3节点有向环数量的表达式，包括任何因边方向和节点标记所需的必要校正因子。\n3. 在给定的网络上计算你推导的表达式，以求出不同简单3节点有向环的数量。将最终答案表示为一个无单位的整数。",
            "solution": "用户提供的问题是一个图论中定义明确的任务，应用于基因调控网络的背景。它包括三个部分：构建邻接矩阵，推导计算3环的公式，以及应用该公式。\n\n### 第1部分：构建邻接矩阵\n\n该网络包含 $6$ 个节点，标记为 $X_1, \\dots, X_6$。邻接矩阵 $A$ 是一个 $6 \\times 6$ 的矩阵，其中如果存在从节点 $X_i$ 到节点 $X_j$ 的有向边，则 $A_{ij}=1$，否则 $A_{ij}=0$。节点顺序指定为 $(X_1, X_2, X_3, X_4, X_5, X_6)$。\n\n给定的有向相互作用如下：\n- $X_1 \\to X_2$，所以 $A_{12} = 1$。\n- $X_2 \\to X_3$，所以 $A_{23} = 1$。\n- $X_3 \\to X_1$，所以 $A_{31} = 1$。\n- $X_2 \\to X_4$，所以 $A_{24} = 1$。\n- $X_4 \\to X_5$，所以 $A_{45} = 1$。\n- $X_5 \\to X_2$，所以 $A_{52} = 1$。\n- $X_3 \\to X_5$，所以 $A_{35} = 1$。\n- $X_5 \\to X_6$，所以 $A_{56} = 1$。\n- $X_6 \\to X_3$，所以 $A_{63} = 1$。\n- $X_1 \\to X_4$，所以 $A_{14} = 1$。\n- $X_4 \\to X_6$，所以 $A_{46} = 1$。\n- $X_2 \\to X_6$，所以 $A_{26} = 1$。\n\n所有其他项均为 $0$。问题陈述该网络没有自环，因此所有对角线元素 $A_{ii}$ 均为 $0$。得到的邻接矩阵 $A$ 是：\n$$\nA = \\begin{pmatrix}\n0  1  0  1  0  0 \\\\\n0  0  1  1  0  1 \\\\\n1  0  0  0  1  0 \\\\\n0  0  0  0  1  1 \\\\\n0  1  0  0  0  1 \\\\\n0  0  1  0  0  0\n\\end{pmatrix}\n$$\n\n### 第2部分：3环数量的推导\n\n设 $A$ 是一个具有 $n$ 个节点的有向图 $G$ 的邻接矩阵。根据矩阵乘法的定义，矩阵 $A^k$ 的元素 $(A^k)_{ij}$ 表示从节点 $i$ 到节点 $j$ 的长度为 $k$ 的不同路径的数量。\n\n我们关心的是简单3节点有向环。一个简单3节点有向环是一个经过三个不同节点的长度为3的闭合路径，即形如 $i \\to j \\to k \\to i$ 的路径，其中 $i, j, k$ 是不同的。\n\n从节点 $i$ 开始并结束于节点 $i$ 的长度为3的闭合路径的数量由对角线元素 $(A^3)_{ii}$ 给出。图中所有长度为3的闭合路径的总数是这些计数在所有可能起始节点上的总和，也就是矩阵 $A^3$ 的迹：\n$$\n\\mathrm{trace}(A^3) = \\sum_{i=1}^{n} (A^3)_{ii}\n$$\n根据矩阵乘法的定义，$(A^3)_{ii}$ 可以表示为：\n$$\n(A^3)_{ii} = \\sum_{j=1}^{n} \\sum_{k=1}^{n} A_{ij} A_{jk} A_{ki}\n$$\n因此，迹为：\n$$\n\\mathrm{trace}(A^3) = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\sum_{k=1}^{n} A_{ij} A_{jk} A_{ki}\n$$\n这个和中的每一项 $A_{ij} A_{jk} A_{ki}$ 当且仅当边序列 $i \\to j \\to k \\to i$ 在图中存在，形成一个长度为3的闭合路径时，才等于1。否则，该项为0。\n\n问题指明该图不包含自环。这意味着对于所有节点 $l$，$A_{ll} = 0$。让我们检查一个非零项 $A_{ij} A_{jk} A_{ki}$ 的索引 $i, j, k$：\n1.  如果 $i=j$，该项变为 $A_{ii} A_{ik} A_{ki}$。因为 $A_{ii}=0$，所以该项为 $0$。\n2.  如果 $j=k$，该项变为 $A_{ij} A_{jj} A_{ji}$。因为 $A_{jj}=0$，所以该项为 $0$。\n3.  如果 $k=i$，该项变为 $A_{ij} A_{ji} A_{ii}$。因为 $A_{ii}=0$，所以该项为 $0$。\n4.  如果 $i=j=k$，该项是 $A_{ii}A_{ii}A_{ii}$，其值为 $0$。\n\n因此，只有当索引 $i, j, k$ 全部不同时，才可能对和有非零贡献。在这种情况下，路径 $i \\to j \\to k \\to i$ 是一个简单3节点有向环。\n\n量 $\\mathrm{trace}(A^3)$ 计算了形成有向环的不同节点的有序三元组 $(i, j, k)$ 的总数。一个单一的环，由三个节点的无序集 $\\{v_1, v_2, v_3\\}$ 和一个特定的边的循环顺序（例如 $v_1 \\to v_2 \\to v_3 \\to v_1$）定义，在迹的和中被多次计数。\n具体来说，这个环会以其每个节点作为起点被计数：\n- 作为路径 $v_1 \\to v_2 \\to v_3 \\to v_1$，对 $(A^3)_{v_1 v_1}$ 有贡献。\n- 作为路径 $v_2 \\to v_3 \\to v_1 \\to v_2$，对 $(A^3)_{v_2 v_2}$ 有贡献。\n- 作为路径 $v_3 \\to v_1 \\to v_2 \\to v_3$，对 $(A^3)_{v_3 v_3}$ 有贡献。\n\n因此，每个不同的简单3节点有向环被 $\\mathrm{trace}(A^3)$ 精确地计数了3次。为了求出不同环的数量（记作 $N_3$），我们必须将总计数除以3。这给出了以下表达式：\n$$\nN_3 = \\frac{1}{3} \\mathrm{trace}(A^3)\n$$\n这个表达式就是所要求的结果。因子 $\\frac{1}{3}$ 是由于起始节点的选择而对每个环的过计数所做的校正。\n\n### 第3部分：对给定网络求值\n\n为了计算 $N_3$，我们必须首先计算 $A^2$，然后计算 $A^3$。\n$$\nA^2 = A \\times A = \\begin{pmatrix}\n0  1  0  1  0  0 \\\\\n0  0  1  1  0  1 \\\\\n1  0  0  0  1  0 \\\\\n0  0  0  0  1  1 \\\\\n0  1  0  0  0  1 \\\\\n0  0  1  0  0  0\n\\end{pmatrix}\n\\begin{pmatrix}\n0  1  0  1  0  0 \\\\\n0  0  1  1  0  1 \\\\\n1  0  0  0  1  0 \\\\\n0  0  0  0  1  1 \\\\\n0  1  0  0  0  1 \\\\\n0  0  1  0  0  0\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0  0  1  1  1  2 \\\\\n1  0  1  0  2  1 \\\\\n0  2  0  1  0  1 \\\\\n0  1  1  0  0  1 \\\\\n0  0  2  1  0  1 \\\\\n1  0  0  0  1  0\n\\end{pmatrix}\n$$\n接下来，我们计算 $A^3 = A \\times A^2$ 的对角线元素，因为只有这些是计算迹所需要的。\n$(A^3)_{ii} = (A \\text{ 的第 } i \\text{ 行}) \\cdot (A^2 \\text{ 的第 } i \\text{ 列})$。\n- $(A^3)_{11} = (0,1,0,1,0,0) \\cdot (0,1,0,0,0,1)^T = 0 \\cdot 0 + 1 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 0 + 0 \\cdot 0 + 0 \\cdot 1 = 1$\n- $(A^3)_{22} = (0,0,1,1,0,1) \\cdot (0,0,2,1,0,0)^T = 0 \\cdot 0 + 0 \\cdot 0 + 1 \\cdot 2 + 1 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 0 = 3$\n- $(A^3)_{33} = (1,0,0,0,1,0) \\cdot (1,1,0,1,2,1)^T = 1 \\cdot 1 + 0 \\cdot 1 + 0 \\cdot 0 + 0 \\cdot 1 + 1 \\cdot 2 + 0 \\cdot 1 = 3$\n- $(A^3)_{44} = (0,0,0,0,1,1) \\cdot (1,0,1,0,1,0)^T = 0 \\cdot 1 + 0 \\cdot 0 + 0 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 1 + 1 \\cdot 0 = 1$\n- $(A^3)_{55} = (0,1,0,0,0,1) \\cdot (1,2,0,0,0,1)^T = 0 \\cdot 1 + 1 \\cdot 2 + 0 \\cdot 0 + 0 \\cdot 0 + 0 \\cdot 0 + 1 \\cdot 1 = 3$\n- $(A^3)_{66} = (0,0,1,0,0,0) \\cdot (2,1,1,1,1,0)^T = 0 \\cdot 2 + 0 \\cdot 1 + 1 \\cdot 1 + 0 \\cdot 1 + 0 \\cdot 1 + 0 \\cdot 0 = 1$\n\n$A^3$ 的迹是这些对角线元素的和：\n$$\n\\mathrm{trace}(A^3) = 1 + 3 + 3 + 1 + 3 + 1 = 12\n$$\n使用推导出的公式，不同简单3节点有向环的数量为：\n$$\nN_3 = \\frac{1}{3} \\mathrm{trace}(A^3) = \\frac{1}{3} (12) = 4\n$$\n在给定的网络中有4个这样的环。为完整起见，这些环是：\n1. $X_1 \\to X_2 \\to X_3 \\to X_1$\n2. $X_2 \\to X_4 \\to X_5 \\to X_2$\n3. $X_3 \\to X_5 \\to X_6 \\to X_3$\n4. $X_2 \\to X_3 \\to X_5 \\to X_2$",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "超越全局网络属性，基序分析可以揭示单个节点的特定功能角色。这个高级计算练习将指导你构建节点级别的基序谱，使用 $z$-score 等统计指标来量化节点参与“三角形”与“楔形”的倾向，并最终根据其结构特征对节点进行分类。",
            "id": "4291115",
            "problem": "给定一个无向简单图，以邻接矩阵表示。您的任务是为每个节点计算节点级的模体参与谱（motif participation profile），并利用这些谱将节点分类为不同的功能角色。所考虑的模体是 $3$-节点三角形和 $3$-节点楔形（以该节点为中心的开放三元组）。分类必须从第一性原理计算，并且是确定性的。\n\n**基本定义和约束：**\n- **图**：由一个对称邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 表示，其中对于所有 $i$，都有 $A_{ii} = 0$，而 $n$ 是节点数。\n- **邻居和度**：对于节点 $i$，令 $N(i) = \\{j \\mid A_{ij} = 1\\}$ 表示其邻居集合，而 $d_i = |N(i)|$ 表示其度。\n- **节点级模体计数**：\n  - 节点 $i$ 参与的**三角形**数量 $T_i$ 是指以 $i$ 为一个顶点的三角形总数。这等于其邻居集合 $N(i)$ 中相互连接的无序邻居对 $\\{j,k\\}$ 的数量。\n  - 节点 $i$ 参与的**楔形**数量 $W_i$ 是指以 $i$ 为中心节点的楔形（即长度为2的路径）总数。这等于其邻居集合 $N(i)$ 中未连接的无序邻居对的数量。\n  - 关系：对于一个度为 $d_i$ 的节点，其邻居对的总数为 $\\binom{d_i}{2}$。因此，$T_i + W_i = \\binom{d_i}{2}$。\n- **Z-scores**: 对于每个节点 $i$ 和每种模体类型（$m \\in \\{T, W\\}$），z-score 定义为：\n$$ z_m(i) = \\frac{N_m^{\\text{obs}}(i) - \\langle N_m^{\\text{null}}(i) \\rangle}{\\sigma_m^{\\text{null}}(i)} $$\n其中，观测值 $N_m^{\\text{obs}}(i)$ 是在原始图中计算的计数，而 $\\langle N_m^{\\text{null}}(i) \\rangle$ 和 $\\sigma_m^{\\text{null}}(i)$ 分别是在保持度序列的随机图系综下的期望均值和标准差。如果 $\\sigma=0$，则定义 $z=0$。\n- **节点角色分类**：\n  - **角色 0 (外围节点, Peripheral)**: 度 $d_i  2$ 的节点。\n  - **角色 1 (集团导向节点, Clique-oriented)**: 度 $d_i \\ge 2$ 且 $z_T(i) \\ge z_W(i)$ 的节点。\n  - **角色 2 (中介导向节点, Broker-oriented)**: 度 $d_i \\ge 2$ 且 $z_T(i)  z_W(i)$ 的节点。\n\n**任务：**\n为以下三个测试用例实现此分类方案。对于每个用例，使用给定的随机数种子，通过 $R$ 次重复生成零模型系综，每次重复执行 $S$ 次成功的边交换来使网络随机化。\n\n1.  **测试用例 1 (类杠铃图)**：$n=6$，边为 `[(0,1),(0,2),(0,3),(1,2),(1,3),(2,3),(0,4),(4,5)]`。参数: $R=200, S=400, \\text{seed}=202311$。\n2.  **测试用例 2 (六边形环)**：$n=6$，边为 `[(0,1),(1,2),(2,3),(3,4),(4,5),(5,0)]`。参数: $R=200, S=400, \\text{seed}=202312$。\n3.  **测试用例 3 (星形图)**：$n=6$，边为 `[(0,1),(0,2),(0,3),(0,4),(0,5)]`。参数: $R=200, S=400, \\text{seed}=202313$。\n\n编写一个 Python 程序来执行此分类，并以列表的列表形式返回所有三个测试用例的结果，例如 `[[...],[...],[...]]`。",
            "solution": "该问题要求根据节点参与三角形和楔形模体的统计显著性，对无向图中的节点进行分类。此过程需要将观测到的模体计数与从保持度序列的零模型中获得的期望值进行比较。\n\n该解决方案的逻辑流程可以分解为以下几个步骤，这些步骤均在答案部分提供的Python代码中实现：\n\n**1. 观测模体计数**\n对于图中的每个节点 $i$，我们首先需要计算它所参与的三角形数量 $T_i$ 和楔形数量 $W_i$。\n-   $T_i$ 的计算方法是：遍历节点 $i$ 的所有邻居对 $\\{j, k\\}$，并统计其中存在边 $(j,k)$ 的对数。这在代码的 `count_triangles_wedges_per_node` 函数中实现。\n-   $W_i$ 可以通过类似的方式计算（统计不存在边 $(j,k)$ 的邻居对），或者更简单地利用关系 $W_i = \\binom{d_i}{2} - T_i$ 来计算，其中 $d_i$ 是节点 $i$ 的度。\n\n**2. 零模型生成**\n为了评估观测计数的统计显著性，我们需要一个合适的零模型。问题指定使用一个保持度序列的随机图系综。这可以通过**边交换算法**（也称为Maslov-Sneppen算法）来实现：\n-   随机选择网络中的两条不同边，例如 $(u, v)$ 和 $(x, y)$。\n-   确保这四点互不相同。\n-   将它们重新连接为 $(u, y)$ 和 $(x, v)$（或 $(u, x)$ 和 $(v, y)$），但前提是新生成的边在图中尚不存在，且不会产生自环。\n-   重复此过程（问题中指定了 $S$ 次成功的交换）会使网络随机化，同时严格保持每个节点的度不变。\n此过程在 `attempt_swap` 和 `randomize_graph` 函数中实现。\n\n**3. 零模型统计**\n为了获得稳健的统计数据，我们生成 $R$ 个独立的随机化网络实例。\n-   对于每个随机网络实例，我们为每个节点计算 $T_i$ 和 $W_i$。\n-   收集完所有 $R$ 个实例的计数后，对于每个节点 $i$，我们计算其三角形计数和楔形计数的均值（$\\mu_T(i), \\mu_W(i)$）和样本标准差（$\\sigma_T(i), \\sigma_W(i)$）。\n`null_stats` 函数负责执行此步骤。\n\n**4. Z-Score计算**\nZ-score 量化了观测值偏离零模型均值的程度（以标准差为单位）。\n-   对于每个节点 $i$，我们使用公式 $z_T(i) = (T_i^{\\text{obs}} - \\mu_T(i)) / \\sigma_T(i)$ 和 $z_W(i) = (W_i^{\\text{obs}} - \\mu_W(i)) / \\sigma_W(i)$ 来计算z-score。\n-   一个正的z-score表示该模体在该节点周围的出现频率高于随机预期，而负值则表示低于预期。如果标准差为零（即在所有随机样本中计数都相同），则z-score定义为0。\n\n**5. 节点分类**\n最后，根据节点的度和计算出的z-score对其进行分类：\n-   度小于2的节点无法形成三元组，被归类为**外围节点（角色0）**。\n-   对于度大于等于2的节点，我们比较 $z_T(i)$ 和 $z_W(i)$。\n    -   如果 $z_T(i) \\ge z_W(i)$，意味着该节点形成闭合三元组（三角形）的倾向相对于随机情况更强（或稀疏程度更弱）。它被归类为**集团导向节点（角色1）**。\n    -   如果 $z_T(i)  z_W(i)$，意味着该节点形成开放三元组（楔形）的倾向相对更强。它被归类为**中介导向节点（角色2）**，因为它更倾向于连接两个原本不相连的邻居。\n\n`classify_roles` 函数整合了所有这些步骤，以生成最终的分类列表。答案中的Python代码是对这一完整逻辑流程的确定性实现。",
            "answer": "```python\nimport numpy as np\n\ndef build_adjacency(n, edges):\n    \"\"\"Build symmetric adjacency matrix for an undirected simple graph.\"\"\"\n    A = np.zeros((n, n), dtype=int)\n    for u, v in edges:\n        if u == v:\n            continue\n        A[u, v] = 1\n        A[v, u] = 1\n    np.fill_diagonal(A, 0)\n    return A\n\ndef neighbors_of(A, i):\n    \"\"\"Return neighbors of node i.\"\"\"\n    return np.where(A[i] == 1)[0]\n\ndef count_triangles_wedges_per_node(A):\n    \"\"\"Count triangles and wedges per node.\"\"\"\n    n = A.shape[0]\n    triangles = np.zeros(n, dtype=int)\n    wedges = np.zeros(n, dtype=int)\n    for i in range(n):\n        nbrs = neighbors_of(A, i)\n        k = len(nbrs)\n        if k  2:\n            continue\n        # count unordered pairs among neighbors\n        for a in range(k):\n            for b in range(a + 1, k):\n                u = nbrs[a]\n                v = nbrs[b]\n                if A[u, v] == 1:\n                    triangles[i] += 1\n                else:\n                    wedges[i] += 1\n    return triangles, wedges\n\ndef get_edge_list(A):\n    \"\"\"Return list of undirected edges (u,v) with u  v.\"\"\"\n    n = A.shape[0]\n    edges = []\n    for u in range(n):\n        for v in range(u + 1, n):\n            if A[u, v] == 1:\n                edges.append((u, v))\n    return edges\n\ndef attempt_swap(A, rng):\n    \"\"\"Attempt a single degree-preserving edge swap; return True if performed.\"\"\"\n    edges = get_edge_list(A)\n    m = len(edges)\n    if m  2:\n        return False\n    # choose two distinct edges uniformly at random\n    idx = rng.choice(m, size=2, replace=False)\n    (u, v) = edges[idx[0]]\n    (x, y) = edges[idx[1]]\n    # ensure all endpoints distinct\n    endpoints = {u, v, x, y}\n    if len(endpoints)  4:\n        return False\n    # choose one of two rewiring options at random\n    if rng.integers(0, 2) == 0:\n        a, b = u, y\n        c, d = x, v\n    else:\n        a, b = u, x\n        c, d = v, y\n    # avoid self-loops\n    if a == b or c == d:\n        return False\n    # avoid existing edges and parallel edges\n    if A[a, b] == 1 or A[c, d] == 1:\n        return False\n    # perform swap: remove original edges, add new edges\n    A[u, v] = 0\n    A[v, u] = 0\n    A[x, y] = 0\n    A[y, x] = 0\n    A[a, b] = 1\n    A[b, a] = 1\n    A[c, d] = 1\n    A[d, c] = 1\n    return True\n\ndef randomize_graph(A, swaps, rng):\n    \"\"\"Return a randomized graph via degree-preserving swaps starting from A.\"\"\"\n    Ar = A.copy()\n    success_count = 0\n    # The number of attempts can be larger than successes. \n    # A common heuristic is to attempt 10x or 100x the number of edges.\n    # Here we perform S *successful* swaps to be faithful to the problem.\n    max_attempts = swaps * 20 # Safety break\n    current_attempts = 0\n    while success_count  swaps and current_attempts  max_attempts:\n        if attempt_swap(Ar, rng):\n            success_count += 1\n        current_attempts += 1\n    return Ar\n\ndef null_stats(A, R, S, rng):\n    \"\"\"Compute null model mean and std for triangles and wedges per node.\"\"\"\n    n = A.shape[0]\n    tri_samples = np.zeros((R, n), dtype=float)\n    wed_samples = np.zeros((R, n), dtype=float)\n    for r in range(R):\n        Ar = randomize_graph(A, S, rng)\n        T, W = count_triangles_wedges_per_node(Ar)\n        tri_samples[r] = T\n        wed_samples[r] = W\n    mu_T = tri_samples.mean(axis=0)\n    mu_W = wed_samples.mean(axis=0)\n    # sample standard deviation (ddof=1)\n    if R > 1:\n        sigma_T = tri_samples.std(axis=0, ddof=1)\n        sigma_W = wed_samples.std(axis=0, ddof=1)\n    else:\n        sigma_T = np.zeros(n, dtype=float)\n        sigma_W = np.zeros(n, dtype=float)\n    return mu_T, sigma_T, mu_W, sigma_W\n\ndef classify_roles(A, R, S, seed):\n    \"\"\"Classify nodes into roles 0,1,2 based on node-level motif z-scores.\"\"\"\n    rng = np.random.default_rng(seed)\n    degrees = A.sum(axis=1)\n    T_obs, W_obs = count_triangles_wedges_per_node(A)\n    mu_T, sigma_T, mu_W, sigma_W = null_stats(A, R, S, rng)\n    # compute z-scores with zero fallback\n    z_T = np.zeros_like(mu_T)\n    z_W = np.zeros_like(mu_W)\n    for i in range(A.shape[0]):\n        if sigma_T[i] > 1e-9:\n            z_T[i] = (T_obs[i] - mu_T[i]) / sigma_T[i]\n        else:\n            z_T[i] = 0.0\n        if sigma_W[i] > 1e-9:\n            z_W[i] = (W_obs[i] - mu_W[i]) / sigma_W[i]\n        else:\n            z_W[i] = 0.0\n    roles = []\n    for i in range(A.shape[0]):\n        if degrees[i]  2:\n            roles.append(0)  # peripheral\n        else:\n            if z_T[i] >= z_W[i]:\n                roles.append(1)  # clique-oriented\n            else:\n                roles.append(2)  # broker-oriented\n    return roles\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, edges, R, S, seed)\n        (6, [(0,1),(0,2),(0,3),(1,2),(1,3),(2,3),(0,4),(4,5)], 200, 400, 202311),\n        (6, [(0,1),(1,2),(2,3),(3,4),(4,5),(5,0)], 200, 400, 202312),\n        (6, [(0,1),(0,2),(0,3),(0,4),(0,5)], 200, 400, 202313),\n    ]\n\n    results = []\n    for n, edges, R, S, seed in test_cases:\n        A = build_adjacency(n, edges)\n        roles = classify_roles(A, R, S, seed)\n        results.append(roles)\n\n    # Format the output as a single line with no spaces: [[...],[...],[...]]\n    formatted = \"[\" + \",\".join(\"[\" + \",\".join(map(str, r)) + \"]\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}