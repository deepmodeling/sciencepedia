{
    "hands_on_practices": [
        {
            "introduction": "网络模体分析的第一步是有效地识别和计数。这个练习将引导你掌握一种基础但非常强大的技术：使用邻接矩阵的代数性质来量化网络中的三节点环路。通过推导并应用基于矩阵迹（trace）的公式 ，你将深刻理解图的拓扑结构与其代数表示之间的联系，这是进行更复杂网络分析的算法基础。",
            "id": "4365973",
            "problem": "在系统生物医学的背景下，考虑一个包含 $6$ 个转录调控因子 $X_1,\\dots,X_6$ 的有向基因调控子网络。一条有向边 $X_i \\to X_j$ 表示 $X_i$ 调控 $X_j$。该网络不含自环和多重边。其有向相互作用如下：\n- $X_1 \\to X_2$, $X_2 \\to X_3$, $X_3 \\to X_1$,\n- $X_2 \\to X_4$, $X_4 \\to X_5$, $X_5 \\to X_2$,\n- $X_3 \\to X_5$, $X_5 \\to X_6$, $X_6 \\to X_3$,\n- $X_1 \\to X_4$, $X_4 \\to X_6$, $X_2 \\to X_6$。\n\n任务：\n1. 使用节点顺序 $(X_1,X_2,X_3,X_4,X_5,X_6)$ 以及约定“当且仅当存在一条有向边 $X_i \\to X_j$ 时，$A_{ij}=1$，否则 $A_{ij}=0$”，构建此有向图的邻接矩阵 $A \\in \\mathbb{R}^{6 \\times 6}$。\n2. 仅从矩阵乘法的定义和通过邻接矩阵的幂来刻画有向图中的闭合路径出发，推导一个用 $\\mathrm{trace}(A^3)$ 表示的不同简单3节点有向环数量的表达式，包括任何因边的方向和节点标记所需的修正因子。\n3. 对给定网络评估你的表达式，计算不同简单3节点有向环的数量。将最终答案表示为一个不带单位的整数。",
            "solution": "用户提供的问题是图论中一个明确定义的任务，应用于基因调控网络的背景。它由三部分组成：构建邻接矩阵，推导计算3-环的公式，以及应用该公式。\n\n### 第1部分：构建邻接矩阵\n\n该网络由 $6$ 个节点组成，标记为 $X_1, \\dots, X_6$。邻接矩阵 $A$ 是一个 $6 \\times 6$ 的矩阵，其中如果存在从节点 $X_i$ 到节点 $X_j$ 的有向边，则 $A_{ij}=1$，否则 $A_{ij}=0$。节点顺序指定为 $(X_1, X_2, X_3, X_4, X_5, X_6)$。\n\n给定的有向相互作用是：\n- $X_1 \\to X_2$，所以 $A_{12} = 1$。\n- $X_2 \\to X_3$，所以 $A_{23} = 1$。\n- $X_3 \\to X_1$，所以 $A_{31} = 1$。\n- $X_2 \\to X_4$，所以 $A_{24} = 1$。\n- $X_4 \\to X_5$，所以 $A_{45} = 1$。\n- $X_5 \\to X_2$，所以 $A_{52} = 1$。\n- $X_3 \\to X_5$，所以 $A_{35} = 1$。\n- $X_5 \\to X_6$，所以 $A_{56} = 1$。\n- $X_6 \\to X_3$，所以 $A_{63} = 1$。\n- $X_1 \\to X_4$，所以 $A_{14} = 1$。\n- $X_4 \\to X_6$，所以 $A_{46} = 1$。\n- $X_2 \\to X_6$，所以 $A_{26} = 1$。\n\n所有其他项均为 $0$。问题陈述中说明没有自环，因此所有对角线项 $A_{ii}$ 均为 $0$。最终的邻接矩阵 $A$ 是：\n$$\nA = \\begin{pmatrix}\n0   1  0  1  0  0 \\\\\n0   0  1  1  0  1 \\\\\n1   0  0  0  1  0 \\\\\n0   0  0  0  1  1 \\\\\n0   1  0  0  0  1 \\\\\n0   0  1  0  0  0\n\\end{pmatrix}\n$$\n\n### 第2部分：3-环数量的推导\n\n设 $A$ 为一个有 $n$ 个节点的有向图 $G$ 的邻接矩阵。根据矩阵乘法的定义，矩阵 $A^k$ 的项 $(A^k)_{ij}$ 表示从节点 $i$ 到节点 $j$ 的长度为 $k$ 的不同路径的数量。\n\n我们感兴趣的是简单3节点有向环。一个简单3节点有向环是一个经过三个不同节点的长度为3的闭合路径，即形式为 $i \\to j \\to k \\to i$ 的路径，其中 $i, j, k$ 互不相同。\n\n从节点 $i$ 出发并返回节点 $i$ 的长度为3的闭合路径数量由对角线项 $(A^3)_{ii}$ 给出。图中所有长度为3的闭合路径的总数是这些计数对所有可能的起始节点的总和，也就是矩阵 $A^3$ 的迹：\n$$\n\\mathrm{trace}(A^3) = \\sum_{i=1}^{n} (A^3)_{ii}\n$$\n根据矩阵乘法的定义，$(A^3)_{ii}$ 可以表示为：\n$$\n(A^3)_{ii} = \\sum_{j=1}^{n} \\sum_{k=1}^{n} A_{ij} A_{jk} A_{ki}\n$$\n因此，迹是：\n$$\n\\mathrm{trace}(A^3) = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\sum_{k=1}^{n} A_{ij} A_{jk} A_{ki}\n$$\n这个和中的每一项 $A_{ij} A_{jk} A_{ki}$ 等于1，当且仅当图中存在边序列 $i \\to j \\to k \\to i$ 形成一条长度为3的闭合路径。否则，该项为0。\n\n问题指明该图不含自环。这意味着对所有节点 $l$，$A_{ll} = 0$。我们来考察一个非零项 $A_{ij} A_{jk} A_{ki}$ 的下标 $i, j, k$：\n1.  如果 $i=j$，该项变为 $A_{ii} A_{ik} A_{ki}$。由于 $A_{ii}=0$，该项为 $0$。\n2.  如果 $j=k$，该项变为 $A_{ij} A_{jj} A_{ji}$。由于 $A_{jj}=0$，该项为 $0$。\n3.  如果 $k=i$，该项变为 $A_{ij} A_{ji} A_{ii}$。由于 $A_{ii}=0$，该项为 $0$。\n4.  如果 $i=j=k$，该项为 $A_{ii}A_{ii}A_{ii}$，其值为 $0$。\n\n因此，只有当索引 $i, j$ 和 $k$ 都互不相同时，才可能对总和产生非零贡献。在这种情况下，路径 $i \\to j \\to k \\to i$ 是一个简单3节点有向环。\n\n量 $\\mathrm{trace}(A^3)$ 计算了形成有向环的不同节点的有序三元组 $(i, j, k)$ 的总数。一个单一的环，由一个无序的三个节点集合 $\\{v_1, v_2, v_3\\}$ 和一个特定的循环边序（例如 $v_1 \\to v_2 \\to v_3 \\to v_1$）定义，在迹的总和中被多次计数。\n具体来说，这个环会以其每个节点作为起点被计数一次：\n- 作为路径 $v_1 \\to v_2 \\to v_3 \\to v_1$，对 $(A^3)_{v_1 v_1}$ 有贡献。\n- 作为路径 $v_2 \\to v_3 \\to v_1 \\to v_2$，对 $(A^3)_{v_2 v_2}$ 有贡献。\n- 作为路径 $v_3 \\to v_1 \\to v_2 \\to v_3$，对 $(A^3)_{v_3 v_3}$ 有贡献。\n\n因此，每个不同的简单3节点有向环被 $\\mathrm{trace}(A^3)$ 精确地计数了 $3$ 次。为了求出不同环的数量，记为 $N_3$，我们必须将总计数除以 $3$。这给出了表达式：\n$$\nN_3 = \\frac{1}{3} \\mathrm{trace}(A^3)\n$$\n这个表达式就是所要求的结果。因子 $\\frac{1}{3}$ 是由于选择不同起始节点而对每个环重复计数的修正。\n\n### 第3部分：对给定网络求值\n\n为了计算 $N_3$，我们必须先计算 $A^2$，然后计算 $A^3$。\n$$\nA^2 = A \\times A = \\begin{pmatrix}\n0  1  0  1  0  0 \\\\\n0  0  1  1  0  1 \\\\\n1  0  0  0  1  0 \\\\\n0  0  0  0  1  1 \\\\\n0  1  0  0  0  1 \\\\\n0  0  1  0  0  0\n\\end{pmatrix}\n\\begin{pmatrix}\n0  1  0  1  0  0 \\\\\n0  0  1  1  0  1 \\\\\n1  0  0  0  1  0 \\\\\n0  0  0  0  1  1 \\\\\n0  1  0  0  0  1 \\\\\n0  0  1  0  0  0\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0  0  1  1  1  2 \\\\\n1  0  1  0  2  1 \\\\\n0  2  0  1  0  1 \\\\\n0  1  1  0  0  1 \\\\\n0  0  2  1  0  1 \\\\\n1  0  0  0  1  0\n\\end{pmatrix}\n$$\n接下来，我们计算 $A^3 = A \\times A^2$ 的对角线元素，因为计算迹只需要这些元素。\n$(A^3)_{ii} = (A \\text{ 的第 } i \\text{ 行}) \\cdot (A^2 \\text{ 的第 } i \\text{ 列})$。\n- $(A^3)_{11} = (0,1,0,1,0,0) \\cdot (0,1,0,0,0,1)^T = 1$\n- $(A^3)_{22} = (0,0,1,1,0,1) \\cdot (0,0,2,1,0,0)^T = 3$\n- $(A^3)_{33} = (1,0,0,0,1,0) \\cdot (1,1,0,1,2,1)^T = 3$\n- $(A^3)_{44} = (0,0,0,0,1,1) \\cdot (1,0,1,0,1,0)^T = 1$\n- $(A^3)_{55} = (0,1,0,0,0,1) \\cdot (1,2,0,0,0,1)^T = 3$\n- $(A^3)_{66} = (0,0,1,0,0,0) \\cdot (2,1,1,1,1,0)^T = 1$\n\n$A^3$ 的迹是这些对角线元素的和：\n$$\n\\mathrm{trace}(A^3) = 1 + 3 + 3 + 1 + 3 + 1 = 12\n$$\n使用推导出的公式，不同简单3节点有向环的数量是：\n$$\nN_3 = \\frac{1}{3} \\mathrm{trace}(A^3) = \\frac{1}{3} (12) = 4\n$$\n在给定的网络中有4个这样的环。为完整起见，这些环是：\n1. $X_1 \\to X_2 \\to X_3 \\to X_1$\n2. $X_2 \\to X_4 \\to X_5 \\to X_2$\n3. $X_3 \\to X_5 \\to X_6 \\to X_3$\n4. $X_2 \\to X_3 \\to X_5 \\to X_2$",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "一个反复出现的子图模式是否就是一个“模体”？这个练习旨在挑战这一直观想法，并揭示网络模体的核心统计学定义。通过分析一个精心设计的思想实验 ，你将探讨为何一个高频出现的模式（如此处的前馈环路）在适当的零模型下可能并不显著。这个过程会让你深刻理解区分“频率”与“统计显著性”的重要性，以及度分布等网络宏观特性如何影响我们对局部结构的预期。",
            "id": "2753902",
            "problem": "考虑一个合成生物学中的有向基因调控网络，该网络包含 $N=100$ 个基因且没有自环。假设节点 $A$ 和节点 $B$ 是两个具有非常高出度的转录因子（调控因子）：$k^{\\mathrm{out}}_A=80$ 和 $k^{\\mathrm{out}}_B=80$。根据经验，你观察到有向边 $A \\to B$ 存在，并且 $A$ 和 $B$ 共同调控 $s=50$ 个相同的下游靶标（也就是说，存在 $50$ 个不同的节点 $C$，使得 $A \\to C$ 和 $B \\to C$ 两条边都存在）。这产生了 $50$ 个以中间边 $A \\to B$ 为锚点的 $3$ 节点前馈环（Feed-Forward Loop, FFL）实例：$A \\to B$，$A \\to C$，$B \\to C$。在此，网络基序（network motif）被定义为：与一个保留度序列的随机网络系综相比，其出现频率显著过高的子图。\n\n使用一个保留度序列的有向配置模型作为适当的零模型，该模型特化于所有入度近似相等的情况，因此每个调控因子 $i$ 从 $N-1$ 个可能的节点（不包括其自身）中，独立、无放回地、均匀随机地选择其 $k^{\\mathrm{out}}_i$ 个不同的靶标。从这些定义和随机抽样描述出发，根据第一性原理进行推理，以评估在零模型下，观察到的 $50$ 个 FFL 是符合预期还是出现频率过高。具体而言：\n- 在零模型下，推导形式为 $A \\to B$，$A \\to C$，$B \\to C$ 的 FFL 的期望数量。\n- 使用泊松近似来计算这类三元组计数的方差，判断观察到的计数是否显著高于预期。\n\n在本文构建的例子中，哪个选项最能解释为什么 $3$ 节点 FFL 在经验网络中频繁出现，但在指定的零模型下却不符合网络基序的资格？\n\nA. FFL 频繁出现是由于 $A$ 和 $B$ 的出度异质性极大，纯粹由组合学导致了许多共享靶标；在保留度序列的零模型下，FFL 的期望计数与观测值处于同一数量级，因此该模式没有显著过表达，故而不是一个基序。\n\nB. 任何出现 $50$ 次或以上的子图都会自动成为基序，因为仅凭频率本身就能决定其显著性，而与零模型的选择无关。\n\nC. FFL 不是一个基序，因为零模型只保留了平均度而不是确切的度序列，这人为地夸大了期望计数；如果使用保留度序列的零模型，FFL 将会是高度显著的。\n\nD. FFL 必须是一个基序，因为它实现了一个有用的输入-输出逻辑功能；其生物学功能保证了其统计上的过表达，而与度分布或零模型无关。",
            "solution": "该问题要求分析一个特定子图在合成基因调控网络中的频率，以确定它是否符合网络基序的资格。我将首先验证问题陈述，然后基于所提供的零模型进行定量分析。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n-   基因（节点）总数：$N = 100$。\n-   网络为有向网络，无自环。\n-   节点 A 是一个调控因子，其出度为 $k^{\\mathrm{out}}_A = 80$。\n-   节点 B 是一个调控因子，其出度为 $k^{\\mathrm{out}}_B = 80$。\n-   存在一条特定的有向边 $A \\to B$。\n-   节点 A 和 B 共同调控 $s = 50$ 个不同的下游靶标，形成了 $50$ 个形式为 $A \\to B, A \\to C, B \\to C$ 的 $3$ 节点前馈环（FFL）实例。\n-   网络基序的定义：与一个保留度序列的随机网络系综相比，其出现频率显著过高的子图。\n-   指定的零模型：一个保留度序列的有向配置模型。\n-   零模型的近似：每个调控因子 $i$ 从 $N-1$ 个可能的节点（不包括其自身）中，独立、无放回地、均匀随机地选择其 $k^{\\mathrm{out}}_i$ 个不同的靶标。\n\n**步骤2：使用提取的已知条件进行验证**\n-   **科学依据**：所提出的概念——基因调控网络、前馈环、网络基序以及保留度序列的零模型——都是系统生物学和合成生物学中的标准和基本概念。该问题具有科学依据。\n-   **良构性**：该问题要求基于一个明确定义的零模型进行定量评估，并提供了所有必要的数值数据。问题具体且可回答。\n-   **客观性**：该问题以客观的数学术语陈述。\n-   **一致性与完整性**：问题提供了所有必要的数据（$N$、$k^{\\mathrm{out}}_A$、$k^{\\mathrm{out}}_B$、观测计数 $s$）。对零模型的描述是一个配置模型的标准计算近似，该模型精确地保留了出度序列。尽管所提供的出度（在可能的 $99$ 个中占 $80$ 个）对于典型的生物网络来说异常高，但它们在数学上是一致的，并用于阐述网络分析的一个特定原理。该问题是自洽和一致的。\n\n**步骤3：结论与行动**\n问题陈述有效。我将继续进行解答。\n\n### 推导与分析\n\n问题的核心是将观察到的 FFL 数量 $s_{obs} = 50$ 与指定零模型下的期望数量进行比较。所讨论的 FFL 共享公共边 $A \\to B$ 和一个公共靶标节点 $C$。此类 FFL 的数量等于满足边 $A \\to C$ 和 $B \\to C$ 同时存在的节点 $C$（其中 $C \\neq A, B$）的数量。\n\n**1. 计算 FFL 的期望数量**\n\n零模型指出，每个调控因子 $i$ 从其他 $N-1$ 个节点中独立、均匀随机地选择其 $k^{\\mathrm{out}}_i$ 个靶标。我们需要找到同时被 A 和 B 作为靶标的节点 $C$ 的期望数量。\n\n让我们考虑一个特定的节点 $C$，其中 $C \\neq A$ 且 $C \\neq B$。共有 $N-2 = 100-2 = 98$ 个这样的潜在节点。\n\n节点 A 有一条边指向节点 C 的概率 $P(A \\to C)$，是节点 $C$ 从 $N-1$ 个可用节点中被选为 A 的 $k^{\\mathrm{out}}_A$ 个靶标之一的概率。这个概率是：\n$$ P(A \\to C) = \\frac{k^{\\mathrm{out}}_A}{N-1} = \\frac{80}{100-1} = \\frac{80}{99} $$\n类似地，节点 B 有一条边指向节点 C 的概率 $P(B \\to C)$ 是：\n$$ P(B \\to C) = \\frac{k^{\\mathrm{out}}_B}{N-1} = \\frac{80}{100-1} = \\frac{80}{99} $$\n根据零模型，A 和 B 的靶标选择是独立事件。因此，特定节点 $C$ 同时是 A 和 B 的公共靶标的概率是：\n$$ P(A \\to C \\text{ and } B \\to C) = P(A \\to C) \\times P(B \\to C) = \\left(\\frac{80}{99}\\right) \\times \\left(\\frac{80}{99}\\right) = \\frac{6400}{9801} \\approx 0.65299 $$\n公共靶标的期望数量 $\\langle s \\rangle$ 是这些概率在所有可能的节点 $C$（共有 $N-2 = 98$ 个）上的总和。根据期望的线性性质：\n$$ \\langle s \\rangle = \\sum_{C \\neq A, B} P(A \\to C \\text{ and } B \\to C) = (N-2) \\times P(A \\to C \\text{ and } B \\to C) $$\n$$ \\langle s \\rangle = 98 \\times \\frac{6400}{9801} = \\frac{627200}{9801} \\approx 63.99 $$\n因此，在零模型下，这种类型的 FFL 的期望数量约为 $\\langle N_{FFL} \\rangle = \\langle s \\rangle \\approx 64$。\n\n**2. 评估显著性**\n\n观察到的 FFL 数量为 $s_{obs}=50$。期望数量为 $\\langle s \\rangle \\approx 64$。\n网络基序被定义为*显著过表达*。在这里，观察到的计数（$50$）*小于*期望计数（$64$）。该模式根本没有过表达；实际上，它略有低表达。\n\n为了形式化这一点，我们可以按照建议计算 Z-score。问题陈述使用泊松近似来计算方差。在泊松分布中，方差等于均值。\n$$ \\lambda = \\langle s \\rangle \\approx 64 $$\n$$ \\sigma^2 = \\mathrm{Var}(s) \\approx \\lambda \\approx 64 $$\n标准差为 $\\sigma = \\sqrt{64} = 8$。\n\nZ-score 衡量观测值偏离均值的标准差倍数：\n$$ Z = \\frac{s_{obs} - \\langle s \\rangle}{\\sigma} = \\frac{50 - 64}{8} = \\frac{-14}{8} = -1.75 $$\n一个模式要被认为是显著过表达，其 Z-score 必须是一个大的正数（通常 $Z  2$ 或 $Z  3$）。负的 Z-score 表示低表达。因此，在这种情况下，FFL 不是一个网络基序。\n\n高的期望计数是节点 A 和 B 极高出度的直接结果。当两个节点各自靶向网络中超过 $80\\%$ 的节点时，纯粹由于随机机会，它们的靶标就会有很大的重叠。零模型通过保留这些高度，正确地捕捉了这种组合效应。\n\n### 逐项分析选项\n\n**A. FFL 频繁出现是由于 $A$ 和 $B$ 的出度异质性极大，纯粹由组合学导致了许多共享靶标；在保留度序列的零模型下，FFL 的期望计数与观测值处于同一数量级，因此该模式没有显著过表达，故而不是一个基序。**\n该陈述与推导完全一致。FFL 出现的频率 $50$ 在绝对值上确实很高。其原因是节点 A 和 B 的极高出度（$k^{\\mathrm{out}}=80$），这代表了一种度异质性（它们是枢纽节点）。基于这些度的零模型预测的期望计数约为 $64$，与观测值 $50$ 处于同一数量级。因为观测计数没有显著大于期望计数，所以该子图不是一个基序。这个解释完全正确。\n**结论：正确。**\n\n**B. 任何出现 $50$ 次或以上的子图都会自动成为基序，因为仅凭频率本身就能决定其显著性，而与零模型的选择无关。**\n这个陈述是根本错误的。根据问题中的定义，网络基序是基于相对于零模型的统计显著性。绝对频率是不够的。我的分析表明，在这种情况下，频率为 $50$ 并不显著。\n**结论：错误。**\n\n**C. FFL 不是一个基序，因为零模型只保留了平均度而不是确切的度序列，这人为地夸大了期望计数；如果使用保留度序列的零模型，FFL 将会是高度显著的。**\n这个陈述错误地描述了零模型。所描述的模型（“每个调控因子 $i$ 独立选择其 $k^{\\mathrm{out}}_i$ 个不同的靶标”）*确实*精确地保留了出度序列。正是*因为*它保留了 A 和 B 的高度，期望计数才会很高。一个更简单的零模型（如只保留平均度的 Erdős-Rényi 模型）会导致低得多的期望值，从而使该模式显得显著。该陈述的逻辑是颠倒的。\n**结论：错误。**\n\n**D. FFL 必须是一个基序，因为它实现了一个有用的输入-输出逻辑功能；其生物学功能保证了其统计上的过表达，而与度分布或零模型无关。**\n这是一个目的论的论点，与网络基序的统计定义无关。虽然子图的功能可能为其过表达提供进化上的原因，但“基序”的地位是一个统计上的称号，是通过将观测频率与零模型进行比较得出的。功能不会自动赋予基序的地位。\n**结论：错误。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "网络模体分析的最终目标是揭示网络的功能组织。这个高级实践将指导你从全局计数转向对单个节点的精细刻画 。你将学习如何通过计算每个节点的模体参与谱（motif participation profile），并将其与度保持的零模型进行比较，从而量化节点在网络中的结构角色。这种方法使我们能够以数据驱动的方式区分“社团核心”型节点和“信息中介”型节点，为理解复杂系统中的功能分化提供了有力工具。",
            "id": "4291115",
            "problem": "给定由邻接矩阵表示的无向简单图。您的任务是为每个节点计算节点级模体参与概况，并使用这些概况将节点分类为不同的功能角色。所考虑的模体是$3$节点三角形和$3$节点楔形（以节点为中心的开放三元组）。分类必须从第一性原理计算得出，并且是确定性的。\n\n**基本定义与约束：**\n- 一个图由对称邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 表示，其中对所有 $i$ 都有 $A_{ii} = 0$，$n$ 是节点数。\n- 对于节点 $i$，令 $N(i) = \\{j \\in \\{1,\\dots,n\\} \\mid A_{ij} = 1\\}$ 表示其邻居集合，而 $d_i = |N(i)|$ 表示其度。\n- 节点 $i$ 参与的三角形数量 $T_i$ 定义为其邻居中相互连接的无序对的数量：\n$$\nT_i = \\sum_{\\{j,k\\} \\subset N(i),\\, jk} A_{jk}\n$$\n- 节点 $i$ 参与的楔形数量 $W_i$ 定义为其邻居中未连接的无序对的数量。它与 $T_i$ 和 $d_i$ 相关，因为邻居对的总数是 $\\binom{d_i}{2}$：\n$$\nW_i = \\binom{d_i}{2} - T_i\n$$\n- **零模型：** 为了评估 $T_i$ 和 $W_i$ 的统计显著性，我们使用一个保持度序列的随机图系综。该系综通过对原始图进行大量的度保持边交换（edge swaps）来生成。您需要为每个测试用例生成 $R$ 个随机网络。每个随机网络通过对原始图执行 $S$ 次成功的边交换来创建。\n- **Z-score计算：** 对于每个节点 $i$，根据从 $R$ 个随机网络中得到的样本，计算其三角形计数和楔形计数的均值（$\\mu_T(i), \\mu_W(i)$）和标准差（$\\sigma_T(i), \\sigma_W(i)$）。然后计算观测值的Z-score：\n$$\nz_T(i) = \\frac{T_i - \\mu_T(i)}{\\sigma_T(i)}, \\quad z_W(i) = \\frac{W_i - \\mu_W(i)}{\\sigma_W(i)}\n$$\n如果标准差为零，则Z-score也应为零。\n\n- **节点角色分类：** 根据以下确定性规则为每个节点分配一个角色（整数 $0, 1, 2$）：\n    1.  如果 $d_i  2$，则该节点为**外围节点（Peripheral）**，角色为 **0**。\n    2.  如果 $d_i \\ge 2$ 且 $z_T(i) \\ge z_W(i)$，则该节点为**集团导向型（Clique-oriented）**，角色为 **1**。\n    3.  如果 $d_i \\ge 2$ 且 $z_T(i)  z_W(i)$，则该节点为**中介导向型（Broker-oriented）**，角色为 **2**。\n\n**任务：**\n为以下三个测试用例实现此分类算法，并返回一个包含三个角色列表的列表。\n1.  **测试用例 1：** $n=6$, 边集 $E_1 = \\{(0,1),(0,2),(0,3),(1,2),(1,3),(2,3),(0,4),(4,5)\\}$, $R=200, S=400, \\text{seed}=202311$。\n2.  **测试用例 2：** $n=6$, 边集 $E_2 = \\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,0)\\}$, $R=200, S=400, \\text{seed}=202312$。\n3.  **测试用例 3：** $n=6$, 边集 $E_3 = \\{(0,1),(0,2),(0,3),(0,4),(0,5)\\}$, $R=200, S=400, \\text{seed}=202313$。\n\n您的代码应输出一个形如 `[[...],[...],[...]]` 的单一字符串，其中包含三个测试用例的角色分类结果列表。",
            "solution": "该问题的解决方案是编写一个Python程序，该程序精确地实现了问题描述中定义的节点分类算法。提供的答案代码通过一系列函数化步骤完成了这一任务。\n\n1.  **图的表示与初始化** (`build_adjacency`)：代码首先将给定的边列表转换为一个NumPy邻接矩阵 $A$，这是进行后续矩阵和图操作的基础。\n\n2.  **观测模体计数** (`count_triangles_wedges_per_node`)：该函数遍历图中每个节点 $i$，检查其所有邻居对 $\\{j,k\\}$。如果 $j$ 和 $k$ 之间存在边（即 $A_{jk}=1$），则节点 $i$ 的三角形计数 $T_i$ 加一；否则，其楔形计数 $W_i$ 加一。这直接计算了观测网络中的 $T_{obs}$ 和 $W_{obs}$。\n\n3.  **零模型生成** (`randomize_graph`, `attempt_swap`)：为了生成用于统计比较的零模型，代码实现了一个标准的度保持边交换算法。`randomize_graph` 函数通过重复调用 `attempt_swap` 来对图进行随机化。`attempt_swap` 随机选择两条边 $(u,v)$ 和 $(x,y)$，并尝试将它们重新连接为 $(u,y)$ 和 $(x,v)$（或 $(u,x)$ 和 $(v,y)$），前提是这种交换不会产生自环或多重边。通过执行 $S$ 次成功的交换，可以生成一个与原始图具有相同度序列但边被随机化的新图。\n\n4.  **统计数据收集** (`null_stats`)：此函数是统计分析的核心。它通过循环 $R$ 次来构建零模型系综，每次都生成一个新的随机图并计算其上每个节点的 $T$ 和 $W$ 计数。然后，它计算这 $R$ 个样本在每个节点上的均值（$\\mu_T, \\mu_W$）和标准差（$\\sigma_T, \\sigma_W$）。\n\n5.  **Z-score计算与分类** (`classify_roles`)：这是主函数，它整合了所有步骤。它首先计算观测图的 $T_{obs}$ 和 $W_{obs}$，然后调用 `null_stats` 来获取零模型的统计数据。接着，它为每个节点计算 $z_T(i)$ 和 $z_W(i)$，并小心处理标准差为零的情况。最后，它根据问题中定义的确定性规则（基于度和Z-score的比较）为每个节点分配角色 $0, 1$ 或 $2$。\n\n将这套逻辑应用于问题中给出的三个测试用例，代码将计算并输出每个案例的节点角色列表，最终格式化为所要求的单一列表字符串。",
            "answer": "```python\nimport numpy as np\n\ndef build_adjacency(n, edges):\n    \"\"\"Build symmetric adjacency matrix for an undirected simple graph.\"\"\"\n    A = np.zeros((n, n), dtype=int)\n    for u, v in edges:\n        if u == v:\n            continue\n        A[u, v] = 1\n        A[v, u] = 1\n    np.fill_diagonal(A, 0)\n    return A\n\ndef neighbors_of(A, i):\n    \"\"\"Return neighbors of node i.\"\"\"\n    return np.where(A[i] == 1)[0]\n\ndef count_triangles_wedges_per_node(A):\n    \"\"\"Count triangles and wedges per node.\"\"\"\n    n = A.shape[0]\n    triangles = np.zeros(n, dtype=int)\n    wedges = np.zeros(n, dtype=int)\n    for i in range(n):\n        nbrs = neighbors_of(A, i)\n        k = len(nbrs)\n        if k  2:\n            continue\n        # count unordered pairs among neighbors\n        for a in range(k):\n            for b in range(a + 1, k):\n                u = nbrs[a]\n                v = nbrs[b]\n                if A[u, v] == 1:\n                    triangles[i] += 1\n                else:\n                    wedges[i] += 1\n    return triangles, wedges\n\ndef get_edge_list(A):\n    \"\"\"Return list of undirected edges (u,v) with u  v.\"\"\"\n    n = A.shape[0]\n    edges = []\n    for u in range(n):\n        for v in range(u + 1, n):\n            if A[u, v] == 1:\n                edges.append((u, v))\n    return edges\n\ndef attempt_swap(A, rng):\n    \"\"\"Attempt a single degree-preserving edge swap; return True if performed.\"\"\"\n    edges = get_edge_list(A)\n    m = len(edges)\n    if m  2:\n        return False\n    # choose two distinct edges uniformly at random\n    idx = rng.integers(0, m, size=2)\n    if idx[0] == idx[1]:\n        return False\n    (u, v) = edges[idx[0]]\n    (x, y) = edges[idx[1]]\n    # ensure all endpoints distinct\n    endpoints = {u, v, x, y}\n    if len(endpoints)  4:\n        return False\n    # choose one of two rewiring options at random\n    if rng.integers(0, 2) == 0:\n        a, b = u, y\n        c, d = x, v\n    else:\n        a, b = u, x\n        c, d = v, y\n    # avoid self-loops\n    if a == b or c == d:\n        return False\n    # avoid existing edges and parallel edges\n    if A[a, b] == 1 or A[c, d] == 1:\n        return False\n    # perform swap: remove original edges, add new edges\n    A[u, v] = 0\n    A[v, u] = 0\n    A[x, y] = 0\n    A[y, x] = 0\n    A[a, b] = 1\n    A[b, a] = 1\n    A[c, d] = 1\n    A[d, c] = 1\n    return True\n\ndef randomize_graph(A, swaps, rng):\n    \"\"\"Return a randomized graph via degree-preserving swaps starting from A.\"\"\"\n    Ar = A.copy()\n    attempts = 0\n    successes = 0\n    # perform up to 'swaps' attempts; successful swaps will be = swaps\n    while attempts  swaps:\n        attempts += 1\n        if attempt_swap(Ar, rng):\n            successes += 1\n    return Ar\n\ndef null_stats(A, R, S, rng):\n    \"\"\"Compute null model mean and std for triangles and wedges per node.\"\"\"\n    n = A.shape[0]\n    tri_samples = np.zeros((R, n), dtype=float)\n    wed_samples = np.zeros((R, n), dtype=float)\n    for r in range(R):\n        Ar = randomize_graph(A, S, rng)\n        T, W = count_triangles_wedges_per_node(Ar)\n        tri_samples[r] = T\n        wed_samples[r] = W\n    mu_T = tri_samples.mean(axis=0)\n    mu_W = wed_samples.mean(axis=0)\n    # sample standard deviation (ddof=1); handle R==1 separately if needed\n    if R  1:\n        sigma_T = tri_samples.std(axis=0, ddof=1)\n        sigma_W = wed_samples.std(axis=0, ddof=1)\n    else:\n        sigma_T = np.zeros(n, dtype=float)\n        sigma_W = np.zeros(n, dtype=float)\n    return mu_T, sigma_T, mu_W, sigma_W\n\ndef classify_roles(A, R, S, seed):\n    \"\"\"Classify nodes into roles 0,1,2 based on node-level motif z-scores.\"\"\"\n    rng = np.random.default_rng(seed)\n    degrees = A.sum(axis=1)\n    T_obs, W_obs = count_triangles_wedges_per_node(A)\n    mu_T, sigma_T, mu_W, sigma_W = null_stats(A, R, S, rng)\n    # compute z-scores with zero fallback\n    z_T = np.zeros_like(mu_T)\n    z_W = np.zeros_like(mu_W)\n    for i in range(A.shape[0]):\n        if sigma_T[i]  0:\n            z_T[i] = (T_obs[i] - mu_T[i]) / sigma_T[i]\n        else:\n            z_T[i] = 0.0\n        if sigma_W[i]  0:\n            z_W[i] = (W_obs[i] - mu_W[i]) / sigma_W[i]\n        else:\n            z_W[i] = 0.0\n    roles = []\n    for i in range(A.shape[0]):\n        if degrees[i]  2:\n            roles.append(0)  # peripheral\n        else:\n            if z_T[i] = z_W[i]:\n                roles.append(1)  # clique-oriented\n            else:\n                roles.append(2)  # broker-oriented\n    return roles\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, edges, R, S, seed)\n        (6, [(0,1),(0,2),(0,3),(1,2),(1,3),(2,3),(0,4),(4,5)], 200, 400, 202311),\n        (6, [(0,1),(1,2),(2,3),(3,4),(4,5),(5,0)], 200, 400, 202312),\n        (6, [(0,1),(0,2),(0,3),(0,4),(0,5)], 200, 400, 202313),\n    ]\n\n    results = []\n    for n, edges, R, S, seed in test_cases:\n        A = build_adjacency(n, edges)\n        roles = classify_roles(A, R, S, seed)\n        results.append(roles)\n\n    # Format the output as a single line with no spaces: [[...],[...],[...]]\n    formatted = \"[\" + \",\".join(\"[\" + \",\".join(map(str, r)) + \"]\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}