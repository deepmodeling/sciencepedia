{
    "hands_on_practices": [
        {
            "introduction": "This exercise provides a foundational experience in identifying network motifs by their structural definition. By manually scanning a small, directed network for the Feed-Forward Loop (FFL), a pattern common in gene regulation and other information-processing networks, you will build an intuitive grasp of the concept before tackling automated and statistical methods .",
            "id": "1452418",
            "problem": "In systems biology, a gene regulatory network can be modeled as a directed graph where nodes represent genes and a directed edge from gene X to gene Y (denoted as X → Y) signifies that the protein product of gene X regulates the expression of gene Y. A particularly important network motif, which is a recurring pattern of interconnections, is the three-node Feed-Forward Loop (FFL). An FFL consists of three genes, which we can label as a master regulator (X), an intermediate gene (Y), and a target gene (Z), such that X regulates Y (X → Y), Y regulates Z (Y → Z), and X also directly regulates Z (X → Z).\n\nConsider a hypothetical small-scale gene regulatory network consisting of five genes: A, B, C, D, and E. The complete set of regulatory interactions is given as follows: A regulates B, A regulates C, A regulates D, B regulates C, B regulates D, C regulates E, and D regulates E.\n\nIdentify all the three-node FFL motifs present in this network. The FFLs should be represented by an ordered triplet of gene names (Master Regulator, Intermediate Gene, Target Gene).\n\nWhich of the following options represents the complete set of all three-node FFLs in the network?\n\nA. {(A, B, C), (A, B, D)}\n\nB. {(C, E, A), (D, E, A)}\n\nC. {(A, C, E), (A, D, E)}\n\nD. {(B, C, E), (B, D, E)}\n\nE. {(A, B, C)}",
            "solution": "A three-node feed-forward loop (FFL) with ordered triplet $(X,Y,Z)$ requires the directed edges $X \\to Y$, $Y \\to Z$, and $X \\to Z$ to all be present.\n\nThe given edges are $A \\to B$, $A \\to C$, $A \\to D$, $B \\to C$, $B \\to D$, $C \\to E$, $D \\to E$.\n\nCheck candidates by master regulator $X$:\n- For $X=A$: possible $Y$ are $B$, $C$, $D$ since $A \\to B$, $A \\to C$, $A \\to D$.\n  - $Y=B$: $B \\to Z$ gives $Z \\in \\{C,D\\}$. Check $A \\to Z$: $A \\to C$ and $A \\to D$ both hold. Thus $(A,B,C)$ and $(A,B,D)$ are valid FFLs.\n  - $Y=C$: $C \\to Z$ gives $Z=E$. Check $A \\to E$: not present. Thus $(A,C,E)$ is not an FFL.\n  - $Y=D$: $D \\to Z$ gives $Z=E$. Check $A \\to E$: not present. Thus $(A,D,E)$ is not an FFL.\n- For $X=B$: possible $Y$ are $C$, $D$. Then $Z=E$ in both cases. Check $B \\to E$: not present. Thus $(B,C,E)$ and $(B,D,E)$ are not FFLs.\n- For $X=C$ or $X=D$: their only outgoing edges go to $E$, but $E$ has no outgoing edges, so no triplet $(X,E,Z)$ can satisfy $E \\to Z$.\n\nTherefore, the complete set of FFLs is $\\{(A,B,C),(A,B,D)\\}$, which corresponds to option A.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "The essence of a network motif lies not merely in its frequency but in its statistical overrepresentation compared to a random baseline. This critical thought experiment uses a hypothetical scenario to demonstrate why this distinction is crucial, challenging the intuition that 'common' equals 'important' . By working through this example, you will see how high-degree 'hub' nodes can create frequent patterns by pure chance, highlighting the indispensable role of a proper null model in motif discovery.",
            "id": "2753902",
            "problem": "Consider a directed gene regulatory network in synthetic biology with $N=100$ genes and no self-loops. Let node $A$ and node $B$ be two transcription factors (regulators) with very high out-degrees: $k^{\\mathrm{out}}_A=80$ and $k^{\\mathrm{out}}_B=80$. Empirically, you observe that the directed edge $A \\to B$ is present and that $A$ and $B$ co-regulate $s=50$ of the same downstream targets (that is, there are $50$ distinct nodes $C$ for which both $A \\to C$ and $B \\to C$ are present). This yields $50$ instances of the $3$-node feed-forward loop (Feed-Forward Loop (FFL): $A \\to B$, $A \\to C$, $B \\to C$) anchored at the middle edge $A \\to B$. A network motif is defined here as a subgraph that is significantly overrepresented relative to an ensemble of randomized networks that preserve the degree sequence.\n\nUse as the appropriate null model a degree-sequence-preserving directed configuration model specialized to the case where all in-degrees are approximately equal, so that each regulator $i$ independently chooses its $k^{\\mathrm{out}}_i$ distinct targets uniformly at random from the $N-1$ possible nodes (excluding itself), without replacement. Starting from these definitions and the random sampling description, reason from first principles to assess whether the observed $50$ FFLs are expected or overrepresented under the null. In particular:\n- Derive the expected number of FFLs of the form $A \\to B$, $A \\to C$, $B \\to C$ under the null.\n- Using a Poisson approximation for the variance of the count of such triads, determine whether the observed count is significantly higher than expected.\n\nWhich option best explains why, in this constructed example, the $3$-node FFL is frequent in the empirical network yet does not qualify as a network motif under the specified null model?\n\nA. The FFL is frequent because of the extreme out-degree heterogeneity of $A$ and $B$, which causes many shared targets purely by combinatorics; under the degree-sequence-preserving null, the expected FFL count is of the same order as the observation, so the pattern is not significantly overrepresented and thus not a motif.\n\nB. Any subgraph that occurs $50$ or more times is automatically a motif, because frequency alone determines significance, independent of the choice of null model.\n\nC. The FFL is not a motif because the null model preserves only the average degree and not the exact degree sequence, which artificially inflates the expected count; with a degree-sequence-preserving null, the FFL would be highly significant.\n\nD. The FFL must be a motif because it implements a useful input-output logic function; its biological function guarantees statistical overrepresentation regardless of degree distributions or null models.",
            "solution": "The problem requires an analysis of a specific subgraph's frequency in a synthetic gene regulatory network to determine if it qualifies as a network motif. I will first validate the problem statement, then proceed with a quantitative analysis based on the provided null model.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n-   Total number of genes (nodes): $N = 100$.\n-   Network is directed, with no self-loops.\n-   Node A is a regulator with out-degree $k^{\\mathrm{out}}_A = 80$.\n-   Node B is a regulator with out-degree $k^{\\mathrm{out}}_B = 80$.\n-   A specific directed edge $A \\to B$ is present.\n-   Nodes A and B co-regulate $s = 50$ distinct downstream targets, forming $50$ instances of the $3$-node feed-forward loop (FFL) of the form $A \\to B, A \\to C, B \\to C$.\n-   Definition of a network motif: A subgraph that is significantly overrepresented relative to an ensemble of randomized networks that preserve the degree sequence.\n-   Specified null model: A degree-sequence-preserving directed configuration model.\n-   Approximation for the null model: Each regulator $i$ independently chooses its $k^{\\mathrm{out}}_i$ distinct targets uniformly at random from the $N-1$ possible nodes (excluding itself), without replacement.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientific Grounding**: The concepts presented—gene regulatory networks, feed-forward loops, network motifs, and degree-sequence-preserving null models—are standard and fundamental in systems and synthetic biology. The problem is scientifically grounded.\n-   **Well-Posedness**: The problem asks for a quantitative assessment based on a clearly defined null model and provides all necessary numerical data. The question is specific and answerable.\n-   **Objectivity**: The problem is stated in objective, mathematical terms.\n-   **Consistency and Completeness**: The problem provides all necessary data ($N$, $k^{\\mathrm{out}}_A$, $k^{\\mathrm{out}}_B$, observed count $s$). The description of the null model is a standard computational approximation of a configuration model which preserves the out-degree sequence exactly. While the provided out-degrees ($80$ out of a possible $99$) are unusually high for typical biological networks, they are mathematically consistent and serve to illustrate a specific principle of network analysis. The problem is self-contained and consistent.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. I will proceed to the solution.\n\n### Derivation and Analysis\n\nThe core of the problem is to compare the observed number of FFLs, $s_{obs} = 50$, with the expected number under the specified null model. The FFLs in question share the common edge $A \\to B$ and a common target node $C$. The number of such FFLs is equal to the number of nodes $C$ (where $C \\neq A, B$) such that edges $A \\to C$ and $B \\to C$ both exist.\n\n**1. Calculate the Expected Number of FFLs**\n\nThe null model states that each regulator $i$ chooses its $k^{\\mathrm{out}}_i$ targets independently and uniformly at random from the $N-1$ other nodes. We need to find the expected number of nodes $C$ that are targeted by both A and B.\n\nLet us consider a specific node $C$, where $C \\neq A$ and $C \\neq B$. There are $N-2 = 100-2 = 98$ such potential nodes.\n\nThe probability that node A has an edge to node C, $P(A \\to C)$, is the probability that $C$ is chosen as one of A's $k^{\\mathrm{out}}_A$ targets from the $N-1$ available nodes. This probability is:\n$$ P(A \\to C) = \\frac{k^{\\mathrm{out}}_A}{N-1} = \\frac{80}{100-1} = \\frac{80}{99} $$\nSimilarly, the probability that node B has an edge to node C, $P(B \\to C)$, is:\n$$ P(B \\to C) = \\frac{k^{\\mathrm{out}}_B}{N-1} = \\frac{80}{100-1} = \\frac{80}{99} $$\nAccording to the null model, the choices of targets for A and B are independent events. Therefore, the probability that a specific node $C$ is a common target of both A and B is:\n$$ P(A \\to C \\text{ and } B \\to C) = P(A \\to C) \\times P(B \\to C) = \\left(\\frac{80}{99}\\right) \\times \\left(\\frac{80}{99}\\right) = \\frac{6400}{9801} \\approx 0.65299 $$\nThe expected number of common targets, $\\langle s \\rangle$, is the sum of these probabilities over all possible nodes $C$ (of which there are $N-2 = 98$). By linearity of expectation:\n$$ \\langle s \\rangle = \\sum_{C \\neq A, B} P(A \\to C \\text{ and } B \\to C) = (N-2) \\times P(A \\to C \\text{ and } B \\to C) $$\n$$ \\langle s \\rangle = 98 \\times \\frac{6400}{9801} = \\frac{627200}{9801} \\approx 63.99 $$\nThus, the expected number of FFLs of this type under the null model is approximately $\\langle N_{FFL} \\rangle = \\langle s \\rangle \\approx 64$.\n\n**2. Assess Significance**\n\nThe observed number of FFLs is $s_{obs}=50$. The expected number is $\\langle s \\rangle \\approx 64$.\nA network motif is defined as being *significantly overrepresented*. Here, the observed count ($50$) is *less than* the expected count ($64$). The pattern is not overrepresented at all; in fact, it is slightly underrepresented.\n\nTo formalize this, we can calculate the Z-score as suggested. The problem states to use a Poisson approximation for the variance. In a Poisson distribution, the variance is equal to the mean.\n$$ \\lambda = \\langle s \\rangle \\approx 64 $$\n$$ \\sigma^2 = \\mathrm{Var}(s) \\approx \\lambda \\approx 64 $$\nThe standard deviation is $\\sigma = \\sqrt{64} = 8$.\n\nThe Z-score measures how many standard deviations the observation is from the mean:\n$$ Z = \\frac{s_{obs} - \\langle s \\rangle}{\\sigma} = \\frac{50 - 64}{8} = \\frac{-14}{8} = -1.75 $$\nA Z-score must be large and positive for a pattern to be considered significantly overrepresented (typically $Z > 2$ or $Z > 3$). A negative Z-score indicates underrepresentation. Therefore, the FFL is not a network motif in this context.\n\nThe high expected count is a direct consequence of the extremely high out-degrees of nodes A and B. When two nodes each target over $80\\%$ of the network, a large overlap in their targets is expected purely by random chance. The null model, by preserving these high degrees, correctly captures this combinatorial effect.\n\n### Option-by-Option Analysis\n\n**A. The FFL is frequent because of the extreme out-degree heterogeneity of $A$ and $B$, which causes many shared targets purely by combinatorics; under the degree-sequence-preserving null, the expected FFL count is of the same order as the observation, so the pattern is not significantly overrepresented and thus not a motif.**\nThis statement aligns perfectly with the derivation. The FFL frequency of $50$ is indeed high in absolute terms. The cause is the extreme out-degrees ($k^{\\mathrm{out}}=80$) of nodes A and B, which represent a form of degree heterogeneity (they are hubs). The null model based on these degrees predicts an expected count of $\\approx 64$, which is on the same order of magnitude as the observation of $50$. Because the observed count is not significantly greater than the expected count, the subgraph is not a motif. This explanation is entirely correct.\n**Verdict: Correct.**\n\n**B. Any subgraph that occurs $50$ or more times is automatically a motif, because frequency alone determines significance, independent of the choice of null model.**\nThis statement is fundamentally incorrect. The definition of a network motif, as provided in the problem, is based on statistical significance relative to a null model. Absolute frequency is not sufficient. My analysis shows that a frequency of $50$ is not significant in this case.\n**Verdict: Incorrect.**\n\n**C. The FFL is not a motif because the null model preserves only the average degree and not the exact degree sequence, which artificially inflates the expected count; with a degree-sequence-preserving null, the FFL would be highly significant.**\nThis statement mischaracterizes the null model. The model described (\"each regulator $i$ independently chooses its $k^{\\mathrm{out}}_i$ distinct targets\") *does* preserve the out-degree sequence exactly. It is precisely *because* it preserves the high degrees of A and B that the expected count is high. A simpler null model (like Erdős-Rényi, which only preserves average degree) would have resulted in a much lower expectation, making the pattern appear significant. The statement's logic is inverted.\n**Verdict: Incorrect.**\n\n**D. The FFL must be a motif because it implements a useful input-output logic function; its biological function guarantees statistical overrepresentation regardless of degree distributions or null models.**\nThis is an argument from teleology, which is irrelevant to the statistical definition of a network motif. While a subgraph's function might provide an evolutionary reason for its overrepresentation, the status of \"motif\" is a statistical designation derived from comparing observed frequency to a null model. Function does not automatically confer motif status.\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "This advanced practice moves from analyzing global motif counts to characterizing the roles of individual nodes based on their local network environment. You will implement a complete computational workflow to generate node-level motif profiles, comparing observed triangle and wedge counts against a degree-preserving null model . This powerful technique is central to modern network science, allowing us to classify nodes into functional roles, such as being core to a cohesive group or acting as a broker between different communities.",
            "id": "4291115",
            "problem": "You are given undirected, simple graphs represented by adjacency matrices. Your task is to compute node-level motif participation profiles for each node and use these profiles to classify nodes into functional roles. The motifs considered are the $3$-node triangle and the $3$-node wedge (open triad centered at a node). The classification must be computed from first principles and be deterministic.\n\nFundamental base definitions and constraints:\n- A graph is represented by a symmetric adjacency matrix $A \\in \\{0,1\\}^{n \\times n}$ with $A_{ii} = 0$ for all $i$, where $n$ is the number of nodes.\n- For node $i$, let $N(i) = \\{j \\in \\{1,\\dots,n\\} \\mid A_{ij} = 1\\}$ denote its neighbor set, and $d_i = |N(i)|$ its degree.\n- A triangle participated by node $i$ is defined as any unordered pair $\\{j,k\\} \\subset N(i)$ with $A_{jk}=1$. The node-level triangle count is\n$$\nT_i = \\sum_{\\{j,k\\} \\subset N(i),\\, j<k} \\mathbf{1}\\{A_{jk} = 1\\}.\n$$\n- A wedge participated by node $i$ is defined as any unordered pair $\\{j,k\\} \\subset N(i)$ with $A_{jk}=0$. The node-level wedge count is\n$$\nW_i = \\sum_{\\{j,k\\} \\subset N(i),\\, j<k} \\mathbf{1}\\{A_{jk} = 0\\}.\n$$\n- The combination identity $T_i + W_i = \\binom{d_i}{2}$ must hold for all $i$.\n\nNull model and statistical profiling:\n- Use a degree-preserving randomization based on edge swaps (also called the switching model) to generate reference graphs. One swap attempt picks two edges $\\{u,v\\}$ and $\\{x,y\\}$ with $u < v$, $x < y$ and all endpoints distinct, and proposes rewiring to either $\\{u,y\\}, \\{x,v\\}$ or $\\{u,x\\}, \\{v,y\\}$ chosen uniformly, provided the proposed edges do not already exist and do not create self-loops. Accepted swaps preserve degrees and maintain a simple graph.\n- For each test case, generate $R$ randomized graphs and for each randomized graph perform $S$ swap attempts starting from the original $A$ to encourage mixing. For each node $i$ record $T_i^{(r)}$ and $W_i^{(r)}$ across $r \\in \\{1,\\dots,R\\}$.\n- Estimate the node-level expectations and standard deviations under the null as\n$$\n\\mu_{T,i} = \\frac{1}{R} \\sum_{r=1}^{R} T_i^{(r)}, \\quad \\sigma_{T,i} = \\sqrt{\\frac{1}{R-1} \\sum_{r=1}^{R} \\left(T_i^{(r)} - \\mu_{T,i}\\right)^2},\n$$\n$$\n\\mu_{W,i} = \\frac{1}{R} \\sum_{r=1}^{R} W_i^{(r)}, \\quad \\sigma_{W,i} = \\sqrt{\\frac{1}{R-1} \\sum_{r=1}^{R} \\left(W_i^{(r)} - \\mu_{W,i}\\right)^2}.\n$$\n- Define node-level motif $z$-scores\n$$\nz_{T,i} = \\begin{cases}\n\\frac{T_i - \\mu_{T,i}}{\\sigma_{T,i}}, & \\text{if } \\sigma_{T,i} > 0,\\\\\n0, & \\text{otherwise,}\n\\end{cases}\n\\qquad\nz_{W,i} = \\begin{cases}\n\\frac{W_i - \\mu_{W,i}}{\\sigma_{W,i}}, & \\text{if } \\sigma_{W,i} > 0,\\\\\n0, & \\text{otherwise.}\n\\end{cases}\n$$\n\nRole classification:\n- Assign each node a role based on its node-level motif significance profile $(z_{T,i}, z_{W,i})$ and degree $d_i$ using the following deterministic rule:\n    - If $d_i < 2$, assign role $0$ (peripheral).\n    - Else, if $z_{T,i} \\ge z_{W,i}$, assign role $1$ (clique-oriented).\n    - Else, assign role $2$ (broker-oriented).\nThis rule operationalizes the intuition that triangles indicate local clustering (clique-oriented) and wedges indicate bridging potential (broker-oriented).\n\nTest suite:\n- Use the following three test graphs, each specified by its number of nodes and undirected edge list. The values of $R$ (number of randomized graphs), $S$ (swap attempts per randomized graph), and the pseudorandom seed are also specified for reproducibility. All numbers are fixed.\n    1. Graph $G_1$ (a $4$-clique with a dangling bridge):\n        - Nodes: $n = 6$.\n        - Edges: $\\{(0,1),(0,2),(0,3),(1,2),(1,3),(2,3),(0,4),(4,5)\\}$.\n        - Randomization parameters: $R = 200$, $S = 400$, seed $= 202311$.\n    2. Graph $G_2$ (a $6$-cycle):\n        - Nodes: $n = 6$.\n        - Edges: $\\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,0)\\}$.\n        - Randomization parameters: $R = 200$, $S = 400$, seed $= 202312$.\n    3. Graph $G_3$ (a $6$-node star):\n        - Nodes: $n = 6$.\n        - Edges: $\\{(0,1),(0,2),(0,3),(0,4),(0,5)\\}$.\n        - Randomization parameters: $R = 200$, $S = 400$, seed $= 202313$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the classification results for all test cases as a comma-separated list enclosed in square brackets, where each test case result is itself a comma-separated list enclosed in square brackets of the per-node integer roles in node index order. For example, an output of the form $[[r_{1,0},r_{1,1},\\dots],[r_{2,0},\\dots],[r_{3,0},\\dots]]$ must be printed exactly with no spaces: \"[[...],[...],[...]]\".\n- All outputs are integers; there are no physical units involved.\n\nYour implementation must be a complete, runnable program adhering strictly to the specified environment.",
            "solution": "We begin with the fundamental representation of a simple undirected graph by a symmetric adjacency matrix $A \\in \\{0,1\\}^{n \\times n}$ with zero diagonal. For each node $i$, its neighbor set $N(i)$ and degree $d_i$ are defined by $N(i) = \\{j \\mid A_{ij} = 1\\}$ and $d_i = |N(i)|$.\n\nThe node-level motifs considered are the triangle and the wedge (an open triad centered at the node). The triangle count $T_i$ counts unordered neighbor pairs $\\{j,k\\} \\subset N(i)$ that are mutually connected, while the wedge count $W_i$ counts unordered neighbor pairs that are not connected. Formally,\n$$\nT_i = \\sum_{\\{j,k\\} \\subset N(i),\\, j<k} \\mathbf{1}\\{A_{jk} = 1\\}, \\quad\nW_i = \\sum_{\\{j,k\\} \\subset N(i),\\, j<k} \\mathbf{1}\\{A_{jk} = 0\\}.\n$$\nBecause every unordered pair of neighbors is either connected or not, we have the identity\n$$\nT_i + W_i = \\binom{d_i}{2}.\n$$\n\nTo interpret motif participation in a statistically grounded way, we compare the observed counts $(T_i, W_i)$ to a null model that preserves degrees. The switching model (degree-preserving edge swaps) constructs randomized graphs with the same degree sequence by repeatedly selecting two edges $\\{u,v\\}$ and $\\{x,y\\}$ with all endpoints distinct and proposing a rewiring to either $\\{u,y\\}, \\{x,v\\}$ or $\\{u,x\\}, \\{v,y\\}$ uniformly, provided the rewiring does not create self-loops and does not introduce duplicate edges. Accepting such swaps preserves degrees of all nodes and maintains a simple graph.\n\nFor a fixed graph $A$, we generate $R$ randomized graphs by starting from $A$ and performing $S$ swap attempts per randomized graph. On each randomized graph $r \\in \\{1,\\dots,R\\}$ we compute node-level counts $T_i^{(r)}$ and $W_i^{(r)}$. From these samples we estimate the per-node expectations and standard deviations,\n$$\n\\mu_{T,i} = \\frac{1}{R} \\sum_{r=1}^{R} T_i^{(r)}, \\quad\n\\sigma_{T,i} = \\sqrt{\\frac{1}{R-1} \\sum_{r=1}^{R} \\left(T_i^{(r)} - \\mu_{T,i}\\right)^2},\n$$\n$$\n\\mu_{W,i} = \\frac{1}{R} \\sum_{r=1}^{R} W_i^{(r)}, \\quad\n\\sigma_{W,i} = \\sqrt{\\frac{1}{R-1} \\sum_{r=1}^{R} \\left(W_i^{(r)} - \\mu_{W,i}\\right)^2}.\n$$\nWe then compute node-level $z$-scores,\n$$\nz_{T,i} = \\begin{cases}\n\\frac{T_i - \\mu_{T,i}}{\\sigma_{T,i}}, & \\text{if } \\sigma_{T,i} > 0,\\\\\n0, & \\text{otherwise,}\n\\end{cases}\n\\qquad\nz_{W,i} = \\begin{cases}\n\\frac{W_i - \\mu_{W,i}}{\\sigma_{W,i}}, & \\text{if } \\sigma_{W,i} > 0,\\\\\n0, & \\text{otherwise.}\n\\end{cases}\n$$\nThis normalization ensures that nodes are compared relative to the variability expected under the degree-preserving null model. If the variability is zero (which can occur for certain degree sequences or small graphs), setting the corresponding $z$-score to $0$ avoids undefined behavior.\n\nFinally, we classify nodes into roles:\n- If $d_i < 2$, we assign role $0$ (peripheral). This accounts for nodes that cannot participate in any $3$-node motif by definition, since $\\binom{d_i}{2} = 0$ when $d_i < 2$.\n- Otherwise, we compare $z_{T,i}$ and $z_{W,i}$. If $z_{T,i} \\ge z_{W,i}$, we assign role $1$ (clique-oriented); else role $2$ (broker-oriented). This deterministic rule uses the node-level motif significance profile to favor triangle participation as indicative of local clustering versus wedge participation as indicative of bridging structure.\n\nAlgorithmic steps:\n1. Construct the adjacency matrix $A$ from the given edge list.\n2. Compute $d_i$ for all $i$ and the observed $(T_i, W_i)$ using pairwise checks within $N(i)$.\n3. For the given $R$, $S$, and fixed seed, draw $R$ randomized graphs via degree-preserving edge swaps, each with $S$ swap attempts starting from $A$.\n4. On each randomized graph, compute $(T_i^{(r)}, W_i^{(r)})$ for all nodes; aggregate into $\\mu_{T,i}$, $\\sigma_{T,i}$, $\\mu_{W,i}$, $\\sigma_{W,i}$.\n5. Compute $z_{T,i}$ and $z_{W,i}$ with the fallback to $0$ if the standard deviation is $0$.\n6. Apply the role classification rule to produce an integer role for each node.\n7. Repeat for each test graph and aggregate the per-graph role lists into the required output format without spaces.\n\nDesign considerations ensure scientific realism:\n- The motifs, counts, and null model are standard in network science, preserving the degree sequence which is a fundamental structural property.\n- The classification rule derives from the principle that triangles contribute to local cohesion while wedges contribute to brokerage, anchored by $z$-scores that measure deviation from a well-defined null model.\n- Boundary conditions are explicitly handled via the degree threshold $d_i < 2$.\n\nThe program implements these steps and produces the required single-line output of integer lists for the provided test suite.",
            "answer": "```python\nimport numpy as np\n\ndef build_adjacency(n, edges):\n    \"\"\"Build symmetric adjacency matrix for an undirected simple graph.\"\"\"\n    A = np.zeros((n, n), dtype=int)\n    for u, v in edges:\n        if u == v:\n            continue\n        A[u, v] = 1\n        A[v, u] = 1\n    np.fill_diagonal(A, 0)\n    return A\n\ndef neighbors_of(A, i):\n    \"\"\"Return neighbors of node i.\"\"\"\n    return np.where(A[i] == 1)[0]\n\ndef count_triangles_wedges_per_node(A):\n    \"\"\"Count triangles and wedges per node.\"\"\"\n    n = A.shape[0]\n    triangles = np.zeros(n, dtype=int)\n    wedges = np.zeros(n, dtype=int)\n    for i in range(n):\n        nbrs = neighbors_of(A, i)\n        k = len(nbrs)\n        if k < 2:\n            continue\n        # count unordered pairs among neighbors\n        for a in range(k):\n            for b in range(a + 1, k):\n                u = nbrs[a]\n                v = nbrs[b]\n                if A[u, v] == 1:\n                    triangles[i] += 1\n                else:\n                    wedges[i] += 1\n    return triangles, wedges\n\ndef get_edge_list(A):\n    \"\"\"Return list of undirected edges (u,v) with u < v.\"\"\"\n    n = A.shape[0]\n    edges = []\n    for u in range(n):\n        for v in range(u + 1, n):\n            if A[u, v] == 1:\n                edges.append((u, v))\n    return edges\n\ndef attempt_swap(A, rng):\n    \"\"\"Attempt a single degree-preserving edge swap; return True if performed.\"\"\"\n    edges = get_edge_list(A)\n    m = len(edges)\n    if m < 2:\n        return False\n    # choose two distinct edges uniformly at random\n    idx = rng.integers(0, m, size=2)\n    if idx[0] == idx[1]:\n        return False\n    (u, v) = edges[idx[0]]\n    (x, y) = edges[idx[1]]\n    # ensure all endpoints distinct\n    endpoints = {u, v, x, y}\n    if len(endpoints) < 4:\n        return False\n    # choose one of two rewiring options at random\n    if rng.integers(0, 2) == 0:\n        a, b = u, y\n        c, d = x, v\n    else:\n        a, b = u, x\n        c, d = v, y\n    # avoid self-loops\n    if a == b or c == d:\n        return False\n    # avoid existing edges and parallel edges\n    if A[a, b] == 1 or A[c, d] == 1:\n        return False\n    # perform swap: remove original edges, add new edges\n    A[u, v] = 0\n    A[v, u] = 0\n    A[x, y] = 0\n    A[y, x] = 0\n    A[a, b] = 1\n    A[b, a] = 1\n    A[c, d] = 1\n    A[d, c] = 1\n    return True\n\ndef randomize_graph(A, swaps, rng):\n    \"\"\"Return a randomized graph via degree-preserving swaps starting from A.\"\"\"\n    Ar = A.copy()\n    attempts = 0\n    successes = 0\n    # perform up to 'swaps' attempts; successful swaps will be <= swaps\n    while attempts < swaps:\n        attempts += 1\n        if attempt_swap(Ar, rng):\n            successes += 1\n    return Ar\n\ndef null_stats(A, R, S, rng):\n    \"\"\"Compute null model mean and std for triangles and wedges per node.\"\"\"\n    n = A.shape[0]\n    tri_samples = np.zeros((R, n), dtype=float)\n    wed_samples = np.zeros((R, n), dtype=float)\n    for r in range(R):\n        Ar = randomize_graph(A, S, rng)\n        T, W = count_triangles_wedges_per_node(Ar)\n        tri_samples[r] = T\n        wed_samples[r] = W\n    mu_T = tri_samples.mean(axis=0)\n    mu_W = wed_samples.mean(axis=0)\n    # sample standard deviation (ddof=1); handle R==1 separately if needed\n    if R > 1:\n        sigma_T = tri_samples.std(axis=0, ddof=1)\n        sigma_W = wed_samples.std(axis=0, ddof=1)\n    else:\n        sigma_T = np.zeros(n, dtype=float)\n        sigma_W = np.zeros(n, dtype=float)\n    return mu_T, sigma_T, mu_W, sigma_W\n\ndef classify_roles(A, R, S, seed):\n    \"\"\"Classify nodes into roles 0,1,2 based on node-level motif z-scores.\"\"\"\n    rng = np.random.default_rng(seed)\n    degrees = A.sum(axis=1)\n    T_obs, W_obs = count_triangles_wedges_per_node(A)\n    mu_T, sigma_T, mu_W, sigma_W = null_stats(A, R, S, rng)\n    # compute z-scores with zero fallback\n    z_T = np.zeros_like(mu_T)\n    z_W = np.zeros_like(mu_W)\n    for i in range(A.shape[0]):\n        if sigma_T[i] > 0:\n            z_T[i] = (T_obs[i] - mu_T[i]) / sigma_T[i]\n        else:\n            z_T[i] = 0.0\n        if sigma_W[i] > 0:\n            z_W[i] = (W_obs[i] - mu_W[i]) / sigma_W[i]\n        else:\n            z_W[i] = 0.0\n    roles = []\n    for i in range(A.shape[0]):\n        if degrees[i] < 2:\n            roles.append(0)  # peripheral\n        else:\n            if z_T[i] >= z_W[i]:\n                roles.append(1)  # clique-oriented\n            else:\n                roles.append(2)  # broker-oriented\n    return roles\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, edges, R, S, seed)\n        (6, [(0,1),(0,2),(0,3),(1,2),(1,3),(2,3),(0,4),(4,5)], 200, 400, 202311),\n        (6, [(0,1),(1,2),(2,3),(3,4),(4,5),(5,0)], 200, 400, 202312),\n        (6, [(0,1),(0,2),(0,3),(0,4),(0,5)], 200, 400, 202313),\n    ]\n\n    results = []\n    for n, edges, R, S, seed in test_cases:\n        A = build_adjacency(n, edges)\n        roles = classify_roles(A, R, S, seed)\n        results.append(roles)\n\n    # Format the output as a single line with no spaces: [[...],[...],[...]]\n    formatted = \"[\" + \",\".join(\"[\" + \",\".join(map(str, r)) + \"]\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}