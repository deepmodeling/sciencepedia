{
    "hands_on_practices": [
        {
            "introduction": "In static networks, the concept of a \"shortest path\" is typically unambiguous. However, in temporal networks, we must distinguish between different optimization goals. This exercise  illuminates the crucial difference between the \"foremost path,\" which minimizes the final arrival time, and the \"fastest path,\" which minimizes the actual travel duration. Understanding this distinction is fundamental to correctly formulating and solving real-world routing and scheduling problems on time-varying infrastructures.",
            "id": "4307297",
            "problem": "Consider a directed temporal network, represented as a contact sequence of time-stamped interactions. A contact is a quadruple $(u,v,t,\\tau)$ indicating that an agent located at node $u$ can depart at time $t$ along the directed edge to node $v$ and will arrive at time $t+\\tau$ after a traversal latency of $\\tau$. An agent may wait at any node for future contacts. For a given source node $s$, destination node $z$, and start time $t_{0}$, a temporal path is a sequence of contacts whose departure times are non-decreasing and respect the causality implied by arrival and waiting. The arrival time of a temporal path is the arrival time at the final contact in the sequence, and the path duration is the arrival time minus the actual departure time of the first used contact. The foremost path (also called earliest-arrival path) is any temporal path from $s$ to $z$ that minimizes the arrival time among all paths that depart no earlier than $t_{0}$. The fastest path is any temporal path from $s$ to $z$ that minimizes the path duration among all paths that depart no earlier than $t_{0}$.\n\nYou are given a specific temporal network with nodes $\\{s,a,b,z\\}$, start time $t_{0}=0$, and the following contact set:\n- $(s,a,0,3)$,\n- $(a,z,3,1)$,\n- $(s,b,5,1)$,\n- $(b,z,6,1)$.\n\nTasks:\n1. Using only the definitions above, determine the foremost path from $s$ to $z$ for start time $t_{0}=0$, its departure time and its arrival time, and compute its duration.\n2. Using only the definitions above, determine the fastest path from $s$ to $z$ for start time $t_{0}=0$, its departure time and its arrival time, and compute its duration.\n3. Verify that, in this example, the fastest path departs later than the foremost path.\n4. Define the trade-off ratio $\\rho$ as\n$$\n\\rho \\equiv \\frac{t_{\\mathrm{dep}}^{\\mathrm{fast}} - t_{\\mathrm{dep}}^{\\mathrm{fore}}}{\\mathrm{dur}^{\\mathrm{fore}} - \\mathrm{dur}^{\\mathrm{fast}}}\\,,\n$$\nwhere $t_{\\mathrm{dep}}^{\\mathrm{fast}}$ and $t_{\\mathrm{dep}}^{\\mathrm{fore}}$ denote the departure times of the fastest and foremost paths, respectively, and $\\mathrm{dur}^{\\mathrm{fast}}$ and $\\mathrm{dur}^{\\mathrm{fore}}$ denote their durations. Compute $\\rho$ as an exact reduced fraction.\n\nYour final answer must be the single value of $\\rho$ (dimensionless). No rounding is required; express it as an exact fraction in lowest terms.",
            "solution": "The problem as stated is well-defined, internally consistent, and scientifically grounded within the field of network science. All definitions and data required for a unique solution are provided. We can therefore proceed with the solution by systematically analyzing the possible temporal paths from the source node $s$ to the destination node $z$ starting at or after time $t_{0}=0$.\n\nThe set of available contacts is given as $\\{ (s,a,0,3), (a,z,3,1), (s,b,5,1), (b,z,6,1) \\}$. There are two possible sequences of contacts forming paths from $s$ to $z$: one via node $a$ and one via node $b$.\n\nPath 1: The path through node $a$, denoted $P_a$.\nThis path is composed of two contacts: $(s,a,0,3)$ and $(a,z,3,1)$.\n- The first contact, $(s,a,0,3)$, represents a departure from $s$ at time $t=0$ and an arrival at $a$ at time $0+3=3$. The departure time $t=0$ is valid because it is greater than or equal to the specified start time $t_{0}=0$.\n- The second contact, $(a,z,3,1)$, represents a departure from $a$ at time $t=3$ and an arrival at $z$ at time $3+1=4$.\n- This sequence is a valid temporal path because the agent arrives at node $a$ at time $3$ and can immediately take the departing contact at time $3$. The departure times of the contacts in the sequence ($0$ and $3$) are non-decreasing.\n- For this path, the departure time from the source $s$ is the departure time of the first contact, which is $0$.\n- The arrival time at the destination $z$ is the arrival time of the final contact, which is $4$.\n- The duration of this path, according to the definition, is the arrival time minus the departure time: $4 - 0 = 4$.\n\nPath 2: The path through node $b$, denoted $P_b$.\nThis path is composed of two contacts: $(s,b,5,1)$ and $(b,z,6,1)$.\n- The first contact, $(s,b,5,1)$, represents a departure from $s$ at time $t=5$ and an arrival at $b$ at time $5+1=6$. The departure time $t=5$ is valid as it is greater than or equal to $t_{0}=0$.\n- The second contact, $(b,z,6,1)$, represents a departure from $b$ at time $t=6$ and an arrival at $z$ at time $6+1=7$.\n- This sequence is a valid temporal path. The agent arrives at node $b$ at time $6$ and can immediately take the departing contact at time $6$. The departure times ($5$ and $6$) are non-decreasing.\n- For this path, the departure time from the source $s$ is $5$.\n- The arrival time at the destination $z$ is $7$.\n- The duration of this path is the arrival time minus the departure time: $7 - 5 = 2$.\n\nNow we address the specific tasks from the problem statement.\n\nTask 1: Determine the foremost path.\nThe foremost path is defined as the path that minimizes the arrival time.\n- Arrival time of path $P_a$ is $4$.\n- Arrival time of path $P_b$ is $7$.\nComparing the arrival times, $4 < 7$. The minimum arrival time is $4$, which corresponds to path $P_a$. Thus, the foremost path is $s \\to a \\to z$.\n- The departure time of the foremost path is $t_{\\mathrm{dep}}^{\\mathrm{fore}} = 0$.\n- The arrival time of the foremost path is $t_{\\mathrm{arr}}^{\\mathrm{fore}} = 4$.\n- The duration of the foremost path is $\\mathrm{dur}^{\\mathrm{fore}} = t_{\\mathrm{arr}}^{\\mathrm{fore}} - t_{\\mathrm{dep}}^{\\mathrm{fore}} = 4 - 0 = 4$.\n\nTask 2: Determine the fastest path.\nThe fastest path is defined as the path that minimizes the path duration.\n- Duration of path $P_a$ is $4$.\n- Duration of path $P_b$ is $2$.\nComparing the durations, $2 < 4$. The minimum duration is $2$, which corresponds to path $P_b$. Thus, the fastest path is $s \\to b \\to z$.\n- The departure time of the fastest path is $t_{\\mathrm{dep}}^{\\mathrm{fast}} = 5$.\n- The arrival time of the fastest path is $t_{\\mathrm{arr}}^{\\mathrm{fast}} = 7$.\n- The duration of the fastest path is $\\mathrm{dur}^{\\mathrm{fast}} = t_{\\mathrm{arr}}^{\\mathrm{fast}} - t_{\\mathrm{dep}}^{\\mathrm{fast}} = 7 - 5 = 2$.\n\nTask 3: Verify that the fastest path departs later than the foremost path.\nWe compare the departure times found in the previous tasks.\n- Departure time of the fastest path: $t_{\\mathrm{dep}}^{\\mathrm{fast}} = 5$.\n- Departure time of the foremost path: $t_{\\mathrm{dep}}^{\\mathrm{fore}} = 0$.\nIndeed, $5 > 0$, so $t_{\\mathrm{dep}}^{\\mathrm{fast}} > t_{\\mathrm{dep}}^{\\mathrm{fore}}$. The statement is verified. This highlights that waiting for a later departure can result in a shorter travel duration.\n\nTask 4: Compute the trade-off ratio $\\rho$.\nThe ratio $\\rho$ is defined as:\n$$\n\\rho \\equiv \\frac{t_{\\mathrm{dep}}^{\\mathrm{fast}} - t_{\\mathrm{dep}}^{\\mathrm{fore}}}{\\mathrm{dur}^{\\mathrm{fore}} - \\mathrm{dur}^{\\mathrm{fast}}}\n$$\nWe substitute the values we have calculated:\n- $t_{\\mathrm{dep}}^{\\mathrm{fast}} = 5$\n- $t_{\\mathrm{dep}}^{\\mathrm{fore}} = 0$\n- $\\mathrm{dur}^{\\mathrm{fore}} = 4$\n- $\\mathrm{dur}^{\\mathrm{fast}} = 2$\n\nThe calculation is as follows:\n$$\n\\rho = \\frac{5 - 0}{4 - 2} = \\frac{5}{2}\n$$\nThe value of $\\rho$ is the exact reduced fraction $\\frac{5}{2}$.",
            "answer": "$$\\boxed{\\frac{5}{2}}$$"
        },
        {
            "introduction": "Having established that temporal optimality is multifaceted, we now explore why finding optimal paths can be counter-intuitive. This practice  demonstrates the \"slow is faster\" effect, a classic phenomenon where a locally greedy strategy—such as minimizing waiting time at an intermediate stop—can lead to a delayed final arrival. You will analyze how this non-monotonic behavior arises from violations of the First-In-First-Out (FIFO) property, revealing the limitations of simple heuristics in temporal pathfinding.",
            "id": "4307306",
            "problem": "Consider a temporal network with node set $V=\\{s,u,v,t\\}$ and a finite set of directed contacts, each specified by a departure time and the corresponding arrival time. A contact $(i\\to j)$ available at departure time $\\tau$ delivers the traveler to node $j$ at arrival time $\\eta(\\tau)$, where $\\eta(\\tau)\\ge \\tau$. A temporal path (also called a time-respecting path) from a source node $s$ to a target node $t$ is a sequence of contacts $\\big((i_1\\to i_2,\\tau_1,\\eta_1), (i_2\\to i_3,\\tau_2,\\eta_2),\\dots,(i_{m}\\to i_{m+1},\\tau_m,\\eta_m)\\big)$ such that $\\tau_{k}\\ge \\eta_{k-1}$ for all $k\\ge 2$, meaning the traveler can wait at intermediate nodes until the next contact’s departure. The earliest arrival problem seeks the minimum attainable arrival time at $t$ over all temporal paths that depart $s$ no earlier than a given start time $\\tau_0$.\n\nStarting from the core definitions above, analyze the following contact schedule (all times are in consistent units; waiting at nodes is allowed without penalty):\n\n- Contacts out of $s$:\n  - $s\\to u$ available at departure time $\\tau=0$, arriving at $u$ at time $\\eta=2$.\n  - $s\\to v$ available at departure time $\\tau=1$, arriving at $v$ at time $\\eta=3$.\n- Contacts out of $u$:\n  - $u\\to t$ available at departure time $\\tau=2.2$, arriving at $t$ at time $\\eta=11$.\n  - $u\\to t$ available at departure time $\\tau=5$, arriving at $t$ at time $\\eta=7$.\n- Contacts out of $v$:\n  - $v\\to t$ available at departure time $\\tau=3$, arriving at $t$ at time $\\eta=9$.\n\nAssume the traveler starts at node $s$ at time $\\tau_0=0$. Consider two decision paradigms:\n\n- Greedy minimal-wait policy: upon arriving at any node, immediately take the earliest available outgoing contact, i.e., the contact with the smallest departure time $\\tau$ that is at least the arrival time at that node; no intentional additional waiting beyond what is necessary to be eligible for the next contact.\n- Global earliest-arrival objective: among all time-respecting paths departing from $s$ no earlier than $\\tau_0=0$, choose the path that minimizes the arrival time at $t$, even if this requires intentional waiting at intermediate nodes.\n\nUsing only the core definitions of time-respecting paths, waiting, and earliest arrival, and by systematically enumerating feasible paths and their arrival times, decide which of the following statements are correct:\n\nA. The globally earliest arrival time at $t$ from $s$ with start time $\\tau_0=0$ is $7$, achieved by taking $s\\to u$ at $\\tau=0$ and then waiting at $u$ until $\\tau=5$ to take $u\\to t$, arriving at $\\eta=7$.\n\nB. Under the greedy minimal-wait policy, the traveler reaches $t$ at arrival time $11$, which demonstrates that reducing waiting time can increase the earliest arrival time due to missing a faster downstream contact.\n\nC. The network satisfies the First-In-First-Out (FIFO) property on every edge, so departing later on any edge can never produce an earlier arrival on that edge.\n\nD. The nonmonotonic effect arises because the edge $u\\to t$ violates the FIFO property: there exist departures $\\tau_1<\\tau_2$ such that the corresponding arrivals satisfy $\\eta(\\tau_2)<\\eta(\\tau_1)$.\n\nE. There is no time-respecting path from $s$ to $t$ starting at $\\tau_0=0$, so neither the greedy minimal-wait policy nor the global earliest-arrival objective can reach $t$.\n\nSelect all correct options.",
            "solution": "The user has provided a problem in the domain of temporal networks. I will first validate the problem statement according to the specified protocol, and then, if it is valid, I will proceed to derive the solution and evaluate each option.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n-   **Node Set**: $V=\\{s,u,v,t\\}$\n-   **Temporal Path Definition**: A sequence of contacts $\\big((i_1\\to i_2,\\tau_1,\\eta_1), (i_2\\to i_3,\\tau_2,\\eta_2),\\dots,(i_{m}\\to i_{m+1},\\tau_m,\\eta_m)\\big)$ is time-respecting if the departure time of a subsequent contact is greater than or equal to the arrival time of the previous one, i.e., $\\tau_{k}\\ge \\eta_{k-1}$ for all $k\\ge 2$.\n-   **Start Condition**: The traveler starts at node $s$ at time $\\tau_0=0$.\n-   **Contact Schedule**:\n    -   $s\\to u$: departure $\\tau=0$, arrival $\\eta=2$.\n    -   $s\\to v$: departure $\\tau=1$, arrival $\\eta=3$.\n    -   $u\\to t$: departure $\\tau=2.2$, arrival $\\eta=11$.\n    -   $u\\to t$: departure $\\tau=5$, arrival $\\eta=7$.\n    -   $v\\to t$: departure $\\tau=3$, arrival $\\eta=9$.\n-   **Decision Paradigms**:\n    1.  **Greedy minimal-wait policy**: At any node, take the outgoing contact with the smallest departure time $\\tau$ that is greater than or equal to the current arrival time at that node.\n    2.  **Global earliest-arrival objective**: Find the path that minimizes the final arrival time at the target node $t$, allowing for intentional waiting at intermediate nodes.\n\n**Step 2: Validate Using Extracted Givens**\n\n-   **Scientifically Grounded**: The problem is a standard exercise in temporal network theory, which is a well-established subfield of network science and complex systems. The concepts of time-respecting paths, waiting, the earliest arrival problem, and the distinction between local greedy policies and global optima are fundamental to the field. The setup is scientifically sound.\n-   **Well-Posed**: The problem is well-posed. The network has a finite number of nodes and contacts. The rules for path construction and the objectives for both policies are clearly and unambiguously defined. This structure guarantees that a unique solution (earliest arrival time) exists and can be found through systematic enumeration or algorithmic approaches.\n-   **Objective**: The problem statement is expressed in precise, objective, mathematical language. It is free of any subjectivity or ambiguity.\n-   **Flaw Check**: The problem does not violate any of the specified invalidity criteria. It is scientifically sound, well-posed, complete, and its terms are clearly defined.\n\n**Step 3: Verdict and Action**\n\n-   **Verdict**: The problem is **valid**.\n-   **Action**: Proceed to the solution phase.\n\n### Solution Derivation\n\nThe goal is to find all feasible time-respecting paths from the source node $s$ to the target node $t$, starting at time $\\tau_0=0$. We will then analyze these paths to determine the outcomes of the two decision paradigms.\n\n**Path Enumeration**\n\nThere are two initial choices from node $s$: a path through node $u$ or a path through node $v$.\n\n**Path 1: Through node $u$ ($s \\to u \\to t$)**\n\n1.  The traveler starts at $s$ at $\\tau_0=0$. The first available contact is $s\\to u$ with departure $\\tau=0$. Since $0 \\ge \\tau_0$, this is a valid start.\n2.  The traveler departs $s$ at $\\tau=0$ and arrives at $u$ at time $\\eta=2$.\n3.  From node $u$, where the traveler is present from time $2$ onwards, there are two outgoing contacts to $t$:\n    -   Contact 1: $u\\to t$ with departure $\\tau=2.2$. This is a valid connection since the departure time $2.2$ is greater than the arrival time at $u$, which was $2$ (i.e., $2.2 \\ge 2$). The waiting time at $u$ is $2.2 - 2 = 0.2$. Taking this contact results in arrival at $t$ at time $\\eta=11$.\n    -   Contact 2: $u\\to t$ with departure $\\tau=5$. This is also a valid connection since $5 \\ge 2$. To take this contact, the traveler must wait at $u$ from time $2$ until time $5$. The waiting time is $5 - 2 = 3$. Taking this contact results in arrival at $t$ at time $\\eta=7$.\n\nThus, we have two sub-paths through $u$:\n-   Path 1a: $(s\\to u, \\tau=0, \\eta=2) \\to (u\\to t, \\tau=2.2, \\eta=11)$. Final arrival time at $t$ is $11$.\n-   Path 1b: $(s\\to u, \\tau=0, \\eta=2) \\to (u\\to t, \\tau=5, \\eta=7)$. Final arrival time at $t$ is $7$.\n\n**Path 2: Through node $v$ ($s \\to v \\to t$)**\n\n1.  The traveler starts at $s$ at $\\tau_0=0$. The contact $s\\to v$ has a departure time $\\tau=1$. The traveler must wait at $s$ from time $0$ to time $1$. This is a valid start as $1 \\ge \\tau_0$.\n2.  The traveler departs $s$ at $\\tau=1$ and arrives at $v$ at time $\\eta=3$.\n3.  From node $v$, where the traveler is present from time $3$ onwards, there is one outgoing contact to $t$:\n    -   Contact: $v\\to t$ with departure $\\tau=3$. This is a valid connection since the departure time $3$ is greater than or equal to the arrival time at $v$, which was $3$ (i.e., $3 \\ge 3$). The waiting time at $v$ is $3 - 3 = 0$. Taking this contact results in arrival at $t$ at time $\\eta=9$.\n\nThus, we have one path through $v$:\n-   Path 2: $(s\\to v, \\tau=1, \\eta=3) \\to (v\\to t, \\tau=3, \\eta=9)$. Final arrival time at $t$ is $9$.\n\n**Analysis of Policies**\n\n**Global Earliest-Arrival Objective:**\nWe must find the minimum arrival time among all feasible time-respecting paths. The possible arrival times are $11$, $7$, and $9$.\n$$\\min(11, 7, 9) = 7$$\nThe globally earliest arrival time at $t$ is $7$. This is achieved via Path 1b: $s\\to u \\to t$, using the contact from $u$ that departs at $\\tau=5$.\n\n**Greedy Minimal-Wait Policy:**\nThe traveler makes decisions locally at each node to minimize waiting, i.e., by picking the earliest possible departure.\n1.  **At node $s$, start time $\\tau_0=0$**: There are two options: $s\\to u$ departing at $\\tau=0$ and $s\\to v$ departing at $\\tau=1$. The earliest departure is $\\tau=0$. The greedy policy chooses the $s\\to u$ contact.\n2.  The traveler arrives at $u$ at time $\\eta=2$.\n3.  **At node $u$, arrival time $2$**: There are two options: $u\\to t$ departing at $\\tau=2.2$ and $u\\to t$ departing at $\\tau=5$. The earliest departure time greater than or equal to $2$ is $\\tau=2.2$. The greedy policy chooses this contact.\n4.  The traveler arrives at $t$ at time $\\eta=11$.\nUnder the greedy minimal-wait policy, the traveler follows Path 1a, resulting in a final arrival time of $11$.\n\n### Option-by-Option Analysis\n\n**A. The globally earliest arrival time at $t$ from $s$ with start time $\\tau_0=0$ is $7$, achieved by taking $s\\to u$ at $\\tau=0$ and then waiting at $u$ until $\\tau=5$ to take $u\\to t$, arriving at $\\eta=7$.**\nOur analysis for the global earliest-arrival objective found that the minimum arrival time is indeed $7$. The path that achieves this is precisely the one described: take $s\\to u$ (depart $\\tau=0$, arrive $\\eta=2$), wait at $u$ until $\\tau=5$, then take $u\\to t$ (depart $\\tau=5$, arrive $\\eta=7$). This statement is fully consistent with our derivation.\n**Verdict: Correct.**\n\n**B. Under the greedy minimal-wait policy, the traveler reaches $t$ at arrival time $11$, which demonstrates that reducing waiting time can increase the earliest arrival time due to missing a faster downstream contact.**\nOur analysis of the greedy policy confirms that it leads to an arrival time of $11$. This policy chooses the path $s\\to u\\to t$ using the contact from $u$ departing at $\\tau=2.2$. This local optimization (minimizing wait time at $u$) leads to a globally suboptimal outcome ($11$) compared to the earliest possible arrival ($7$). The reason for this is that the greedy choice misses a later but much faster connection. The statement correctly identifies the outcome of the greedy policy and provides an accurate interpretation of the underlying phenomenon.\n**Verdict: Correct.**\n\n**C. The network satisfies the First-In-First-Out (FIFO) property on every edge, so departing later on any edge can never produce an earlier arrival on that edge.**\nThe FIFO property for a directed edge from node $i$ to node $j$ states that for any two contacts with departure times $\\tau_1$ and $\\tau_2$ such that $\\tau_1 < \\tau_2$, their corresponding arrival times $\\eta_1$ and $\\eta_2$ must satisfy $\\eta_1 \\le \\eta_2$. Let's examine the contacts from $u$ to $t$:\n-   Contact 1: Departure $\\tau_1 = 2.2$, Arrival $\\eta_1 = 11$.\n-   Contact 2: Departure $\\tau_2 = 5$, Arrival $\\eta_2 = 7$.\nWe have $\\tau_1 < \\tau_2$ ($2.2 < 5$), but $\\eta_1 > \\eta_2$ ($11 > 7$). This is a direct violation of the FIFO property. Therefore, the premise that the network satisfies the FIFO property is false.\n**Verdict: Incorrect.**\n\n**D. The nonmonotonic effect arises because the edge $u\\to t$ violates the FIFO property: there exist departures $\\tau_1<\\tau_2$ such that the corresponding arrivals satisfy $\\eta(\\tau_2)<\\eta(\\tau_1)$.**\nThe \"nonmonotonic effect\" described here is the phenomenon where a locally optimal (e.g., minimal-wait) strategy does not yield a globally optimal solution. In our case, the greedy policy yields arrival time $11$, whereas waiting longer at node $u$ allows for an earlier arrival at time $7$. This effect is also known as the \"slow is faster\" effect in temporal networks. The statement attributes this to a violation of the FIFO property on the edge $u\\to t$. As established in the analysis of option C, the edge $u\\to t$ indeed violates FIFO. Specifically, for departures $\\tau_1=2.2$ and $\\tau_2=5$, we have $\\tau_1<\\tau_2$ and $\\eta(\\tau_2) < \\eta(\\tau_1)$ since $7 < 11$. This violation is precisely what causes the nonmonotonic effect: waiting for the later departure from $u$ gives access to a \"faster\" transit (travel time $7-5=2$ vs $11-2.2=8.8$), leading to an earlier final arrival. The statement is a correct diagnosis of the cause of the observed behavior.\n**Verdict: Correct.**\n\n**E. There is no time-respecting path from $s$ to $t$ starting at $\\tau_0=0$, so neither the greedy minimal-wait policy nor the global earliest-arrival objective can reach $t$.**\nThis statement is factually incorrect. Our derivation has explicitly constructed three distinct time-respecting paths from $s$ to $t$ starting at or after $\\tau_0=0$, with final arrival times of $11$, $7$, and $9$. Since such paths exist, node $t$ is reachable from $s$.\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{ABD}$$"
        },
        {
            "introduction": "Moving beyond the analysis of individual paths, this final practice challenges you to assess the structural importance of interactions within the network as a whole. You will implement a procedure to compute temporal betweenness centrality, a key metric that quantifies how often specific events lie on the most efficient pathways between other nodes . This capstone exercise requires constructing an event graph and applying dynamic programming, consolidating your skills in both representing and analyzing the complex flow of information in temporal systems.",
            "id": "4307340",
            "problem": "You are given a temporal contact network specified as a finite set of instantaneous pairwise contact events. Each event is a triplet $(u,v,t)$ with $u$ and $v$ denoting distinct nodes, and $t$ denoting a time in seconds. Let there be $m$ events indexed by $i\\in\\{0,1,\\dots,m-1\\}$, written as $e_i=(u_i,v_i,t_i)$. Fix a maximum waiting time parameter $\\tau>0$. Consider the event graph representation in which each event $e_i$ is a vertex, and there is a directed edge from event $e_i$ to event $e_j$ if and only if $t_j-t_i\\in(0,\\tau]$ and $\\{u_i,v_i\\}\\cap\\{u_j,v_j\\}\\neq\\varnothing$ (that is, the two events share at least one node and the later event occurs strictly after the earlier one, within the waiting time bound).\n\nA temporal path from a source node $s$ to a target node $t$ is defined as any sequence of events $(e_{i_0},e_{i_1},\\dots,e_{i_L})$ such that:\n- $L\\geq 0$,\n- $s\\in\\{u_{i_0},v_{i_0}\\}$,\n- $t\\in\\{u_{i_L},v_{i_L}\\}$,\n- for every $k\\in\\{0,\\dots,L-1\\}$ there is a directed event-graph edge from $e_{i_k}$ to $e_{i_{k+1}}$ (strictly increasing times with shared node within $\\tau$),\n- the duration of the path is $t_{i_L}-t_{i_0}$.\n\nAmong all temporal paths from $s$ to $t$, call a path temporally shortest if it minimizes $t_{i_L}-t_{i_0}$; denote by $\\sigma_{st}$ the number of temporally shortest $s\\to t$ paths, and by $\\sigma_{st}(e)$ the number of temporally shortest $s\\to t$ paths that include event $e$ as a strict interior element (that is, $e\\neq e_{i_0}$ and $e\\neq e_{i_L}$ but $e$ appears in the sequence).\n\nDefine the temporal betweenness centrality for an event $e$ as\n$$\nB(e)\\;=\\;\\sum_{\\substack{s,t\\in V\\\\ s\\neq t}}\\frac{\\sigma_{st}(e)}{\\sigma_{st}},\n$$\nwhere $V$ is the set of nodes appearing in at least one event, and by convention terms with $\\sigma_{st}=0$ contribute $0$ to the sum.\n\nStarting only from the above core definitions and the event-graph construct, your tasks are:\n1. Derive a principled dynamic-programming procedure to compute $\\sigma_{st}$ and $\\sigma_{st}(e)$ for all ordered pairs $(s,t)$ and all events $e$, and hence compute $B(e)$ for every event $e$.\n2. Explain the computational complexity of your procedure in terms of the number of events $m$, the number of directed edges $\\alpha$ in the event graph, and the number of nodes $n=|V|$.\n3. Implement the procedure as a complete, runnable program that takes no input and operates on a fixed test suite embedded in the code.\n\nFor scientific realism, use strictly increasing time edges as specified above (no edges connect events at equal time), and treat contacts as undirected in the sense that a path can proceed via either node incident to an event.\n\nTest Suite:\n- Case A (baseline chain): events $[(A,B,1),(B,C,3),(C,D,6)]$, with $\\tau=10$. Event indices are $0,1,2$ respectively.\n- Case B (multiple shortest paths via concurrency): events $[(A,B,1),(B,C,2),(A,C,2)]$, with $\\tau=5$. Event indices are $0,1,2$ respectively.\n- Case C (disconnected under tight waiting): events $[(A,B,1),(C,D,5)]$, with $\\tau=1$. Event indices are $0,1$ respectively.\n\nRequired Program Output:\n- For each case, compute the list of temporal betweenness $[B(e_0),B(e_1),\\dots]$ in the order of events as listed in the case specification. Each $B(e_i)$ must be output as a floating-point number. Your program should produce a single line of output containing the results as a comma-separated list of these per-case lists enclosed in square brackets, for example, \"[[x0,x1,...],[y0,y1,...],[z0,z1,...]]\". No units are involved, and angles are not applicable.\n\nYour implementation must be a complete, runnable program in Python that adheres to the execution environment constraints specified separately. The code must be self-contained and must not read any input, as the test suite is embedded. The final printed line must exactly follow the format specified above.",
            "solution": "The problem statement asks for the derivation and implementation of a procedure to compute the temporal betweenness centrality of events in a temporal network. The definition of temporal paths, their duration, and the centrality metric are provided. The problem is grounded in the established field of network science, specifically the analysis of temporal networks. All terms are mathematically and algorithmically well-defined.\n\n### Step 1: Problem Validation\n\n**1.1. Extraction of Givens**\n-   A set of $m$ contact events $e_i = (u_i, v_i, t_i)$ for $i \\in \\{0, 1, \\dots, m-1\\}$.\n-   A maximum waiting time parameter $\\tau > 0$.\n-   **Event Graph:** A directed graph where events are vertices. A directed edge exists from $e_i$ to $e_j$ iff $t_j - t_i \\in (0, \\tau]$ and $\\{u_i, v_i\\} \\cap \\{u_j, v_j\\} \\neq \\varnothing$.\n-   **Temporal Path:** A sequence of events $(e_{i_0}, \\dots, e_{i_L})$ such that $s \\in \\{u_{i_0}, v_{i_0}\\}$, $t \\in \\{u_{i_L}, v_{i_L}\\}$, and an event-graph edge exists from $e_{i_k}$ to $e_{i_{k+1}}$ for all $k$.\n-   **Path Duration:** $t_{i_L} - t_{i_0}$.\n-   **Temporally Shortest Path:** A path from node $s$ to node $t$ that minimizes the duration.\n-   $\\sigma_{st}$: The number of temporally shortest paths from $s$ to $t$.\n-   $\\sigma_{st}(e)$: The number of temporally shortest paths from $s$ to $t$ for which event $e$ is a strict interior element (i.e., not the start or end event of the path).\n-   **Temporal Betweenness Centrality:** $B(e) = \\sum_{s,t \\in V, s \\neq t} \\frac{\\sigma_{st}(e)}{\\sigma_{st}}$, with the convention that terms with $\\sigma_{st}=0$ are zero.\n-   **Task:** Derive a dynamic programming procedure to compute $B(e)$, analyze its complexity, and implement it for a given test suite.\n\n**1.2. Validation against Criteria**\n-   **Scientific Grounding:** The problem is a well-defined graph-theoretic problem rooted in temporal network theory, a standard topic in complex systems and network science. All concepts (temporal paths, betweenness) are standard, albeit with specific definitions for this context. This is valid.\n-   **Well-Posedness:** The definitions are precise and unambiguous. The objective function for path length (duration) is clearly stated. The centrality formula is well-defined, including the handling of division by zero. A unique solution for $B(e)$ exists for any given input. This is valid.\n-   **Objectivity:** The problem is stated in formal mathematical language, free from subjectivity or ambiguity. This is valid.\n-   **Flaw Checklist:** The problem does not violate any of the invalidity criteria. It is scientifically sound, formalizable, complete, feasible, well-posed, non-trivial, and verifiable.\n\n**1.3. Verdict**\nThe problem is **valid**.\n\n### Step 2: Derivation of the Dynamic Programming Procedure\n\nThe calculation of $B(e)$ requires aggregating information over all pairs of source-target nodes $(s, t)$. The formula for $B(e)$ can be computationally intensive if evaluated directly. A more tractable approach rearranges the summation.\n\nLet $e_k$ be the event for which we are computing the betweenness. By definition, $e_k$ must be a strict interior element of a path. This means any such path must be of the form $(e_i, \\dots, e_k, \\dots, e_j)$ where $t_i < t_k < t_j$.\n\nThe number of shortest paths from $s$ to $t$ passing through $e_k$ as an interior node, $\\sigma_{st}(e_k)$, can be expressed as a sum over all possible start and end events, $e_i$ and $e_j$ respectively:\n$$ \\sigma_{st}(e_k) = \\sum_{\\substack{e_i, e_j \\text{ s.t. } s \\in e_i, t \\in e_j \\\\ t_j-t_i = D_{st} \\\\ t_i < t_k < t_j}} (\\# \\text{paths from } e_i \\text{ to } e_k) \\times (\\# \\text{paths from } e_k \\text{ to } e_j) $$\nHere, $D_{st}$ is the duration of a temporally shortest path from $s$ to $t$. The number of paths is counted on the event graph.\n\nThe betweenness centrality formula is:\n$$ B(e_k) = \\sum_{s \\neq t} \\frac{\\sigma_{st}(e_k)}{\\sigma_{st}} $$\nSubstituting the expression for $\\sigma_{st}(e_k)$ and swapping the order of summation is complex because of the $D_{st}$ and $\\sigma_{st}$ terms, which depend on $(s,t)$. A more structured approach, inspired by Brandes' algorithm for classical betweenness, is to sum contributions differently. We can rewrite the expression for $B(e_k)$ by summing over all possible start events $e_i$ and end events $e_j$ for which $e_k$ could be an intermediary.\n$$ B(e_k) = \\sum_{i,j \\text{ s.t. } t_i < t_k < t_j} (\\# \\text{paths } e_i \\to e_k) \\times (\\# \\text{paths } e_k \\to e_j) \\times \\left( \\sum_{\\substack{s \\in e_i, t \\in e_j, s \\neq t \\\\ t_j-t_i = D_{st}}} \\frac{1}{\\sigma_{st}} \\right) $$\nThis formulation allows for a staged computation.\n\nThe overall procedure is as follows:\n\n**1. Pre-computation on the Event Graph:**\nFirst, we process the event graph structure. The events are inherently ordered by time, making the event graph a Directed Acyclic Graph (DAG).\n-   **Sort Events:** Sort the $m$ events by their timestamp $t_i$. This is crucial for the subsequent dynamic programming steps.\n-   **Build Adjacency List:** Construct the event graph by creating a directed edge from event $e_i$ to $e_j$ if $0 < t_j - t_i \\le \\tau$ and they share at least one node. With sorted events, this can be done in $O(m^2)$.\n-   **Count Paths Between Events:** We need to find the number of distinct paths between any two events $e_i$ and $e_j$ in the event graph. Let this be $N(e_i, e_j)$. Since it's a DAG, we can use dynamic programming. We compute an $m \\times m$ matrix `num_paths` where `num_paths[i][j]` stores $N(e_i, e_j)$. For each starting event $e_i$, we can compute the number of paths to all subsequent events $e_j$ ($j>i$).\n    - For each starting event $i$ from $0$ to $m-1$:\n        - Initialize a temporary array `dp_counts` of size $m$ to zeros. Set `dp_counts[i] = 1`.\n        - Iterate $j$ from $i+1$ to $m-1$:\n            - For each predecessor $p$ of $j$ in the event graph:\n                - `dp_counts[j] += dp_counts[p]`.\n        - Store `dp_counts` as the $i$-th row of the `num_paths` matrix.\n\n**2. Compute All-Pairs Node-to-Node Shortest Path Information:**\nNext, we aggregate the event-level path information to find the shortest path durations and counts for all pairs of nodes $(s, t)$.\n-   Initialize two $n \\times n$ matrices: `min_duration[s][t]` to $\\infty$ and `sigma_st[s][t]` to $0$.\n-   Iterate through all pairs of events $(e_i, e_j)$ where $t_i \\le t_j$.\n    - If a path exists from $e_i$ to $e_j$ (i.e., `num_paths[i][j] > 0`, or $i=j$):\n        - Let the path duration be $D = t_j - t_i$.\n        - Let the number of such event-paths be $N = \\text{num\\_paths}[i][j]$ (or $N=1$ if $i=j$).\n        - For each pair of nodes $(s, t)$ with $s \\in e_i$, $t \\in e_j$ and $s \\neq t$:\n            - If $D < \\text{min\\_duration}[s][t]$: Update $\\text{min\\_duration}[s][t] = D$ and set $\\sigma_{st}[s][t] = N$.\n            - If $D == \\text{min\\_duration}[s][t]$: Increment $\\sigma_{st}[s][t]$ by $N$.\n\n**3. Compute Betweenness Centrality:**\nFinally, we apply the rearranged summation formula using the pre-computed values.\n-   Initialize an array `B` of size $m$ to all zeros.\n-   Iterate through each event $e_k$ from $0$ to $m-1$.\n-   Iterate through each possible start event $e_i$ (where $i < k$).\n-   Iterate through each possible end event $e_j$ (where $j > k$).\n    - The number of paths from $e_i$ to $e_j$ passing through $e_k$ is `term = num_paths[i][k] * num_paths[k][j]`.\n    - If `term == 0`, there are no such paths, so continue.\n    - Calculate the duration for this path class: $D = t_j - t_i$.\n    - Initialize an `inner_sum = 0`.\n    - For each pair of nodes $(s, t)$ with $s \\in e_i, t \\in e_j$ and $s \\neq t$:\n        - Check if this duration is the minimum for this node pair: if $D == \\text{min\\_duration}[s][t]$.\n        - If it is, this path class contributes to the shortest paths. Add its share to the `inner_sum`: `inner_sum += 1.0 / sigma_st[s][t]`.\n    - Update the betweenness of $e_k$: `B[k] += term * inner_sum`.\n\nThis procedure correctly implements the definition of temporal betweenness centrality by systematically enumerating all components of the summation.\n\n### Step 3: Computational Complexity Analysis\n\nLet $m$ be the number of events, $n$ be the number of unique nodes, and $\\alpha$ be the number of edges in the event graph.\n1.  **Event Graph Construction:** Sorting events takes $O(m \\log m)$. The nested loops to find edges take $O(m^2)$. Total: $O(m^2)$.\n2.  **Path Counting (`num_paths` matrix):** This involves $m$ single-source path counting runs on a DAG. Each run visits nodes and edges accessible from the source. The total complexity is the sum of costs for each source, which is $O(m \\cdot (m+\\alpha_i))$, where $\\alpha_i$ is number of edges reachable from $i$. In the worst case, this is $O(m \\cdot (m+\\alpha)) = O(m^2 + m\\alpha)$.\n3.  **Node-Pair Information (`min_duration`, `sigma_st`):** This step involves iterating through all $O(m^2)$ event pairs. For each pair, we check up to $4$ node pairs. This takes $O(m^2)$.\n4.  **Betweenness Calculation:** This is the most expensive part. It involves three nested loops over events ($i, j, k$), giving $O(m^3)$. Inside the innermost loop, we do a constant number of node-pair lookups ($4$). The total complexity for this step is $O(m^3)$.\n\nThe overall complexity is dominated by the most expensive steps, resulting in $O(m^2 + m\\alpha + m^3)$. Since $\\alpha$ is at most $O(m^2)$, the total complexity is $O(m^3)$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the temporal betweenness problem for the given test suite.\n    \"\"\"\n    \n    # Define test cases as per the problem description.\n    # Format: (List of event tuples (u, v, t), tau value)\n    test_cases = [\n        (\n            [('A', 'B', 1), ('B', 'C', 3), ('C', 'D', 6)], \n            10\n        ),\n        (\n            [('A', 'B', 1), ('B', 'C', 2), ('A', 'C', 2)],\n            5\n        ),\n        (\n            [('A', 'B', 1), ('C', 'D', 5)],\n            1\n        )\n    ]\n\n    all_results = []\n    for events_in, tau in test_cases:\n        result = compute_temporal_betweenness(events_in, tau)\n        all_results.append(result)\n\n    # Format the final output string as required.\n    # e.g., [[1.0,2.0],[0.0,0.0]]\n    output_str = '[' + ','.join(['[' + ','.join(f\"{x:.1f}\" for x in res) + ']' for res in all_results]) + ']'\n    print(output_str)\n\ndef compute_temporal_betweenness(events_in, tau):\n    \"\"\"\n    Computes temporal betweenness centrality for a given set of events and tau.\n    \"\"\"\n    if not events_in:\n        return []\n\n    # Sort events by time. This is a critical prerequisite for the DP.\n    # The original index is saved to report results in the initial order.\n    events = sorted([(i, e) for i, e in enumerate(events_in)], key=lambda x: x[1][2])\n    original_indices = [item[0] for item in events]\n    m = len(events)\n    \n    # Create a mapping from node labels to integer indices\n    node_set = set()\n    for _, (u, v, t) in events:\n        node_set.add(u)\n        node_set.add(v)\n    \n    nodes = sorted(list(node_set))\n    node_to_idx = {node: i for i, node in enumerate(nodes)}\n    n = len(nodes)\n\n    # Step 1: Build Event Graph (adjacency list)\n    adj = [[] for _ in range(m)]\n    pred = [[] for _ in range(m)] # Predecessor list for convenience\n    for j in range(m):\n        _, (uj, vj, tj) = events[j]\n        for i in range(j):\n            _, (ui, vi, ti) = events[i]\n            if 0  tj - ti = tau:\n                if len({ui, vi}.intersection({uj, vj})) > 0:\n                    adj[i].append(j)\n                    pred[j].append(i)\n\n    # Step 2: Count paths between all event pairs (Dynamic Programming on DAG)\n    num_paths = np.zeros((m, m), dtype=np.int64)\n    for i in range(m):\n        # Paths from i to subsequent events j > i\n        # dp_counts[k] will store the number of paths from i to k\n        dp_counts = np.zeros(m, dtype=np.int64)\n        dp_counts[i] = 1\n        for j in range(i + 1, m):\n            for p in pred[j]:\n                if p >= i:\n                    dp_counts[j] += dp_counts[p]\n        num_paths[i, :] = dp_counts\n    \n    # Step 3: Compute all-pairs node-to-node shortest path durations and counts\n    min_duration = np.full((n, n), np.inf)\n    sigma_st = np.zeros((n, n), dtype=np.int64)\n    np.fill_diagonal(min_duration, 0)\n    \n    for i in range(m):\n        for j in range(i, m):\n            duration = events[j][1][2] - events[i][1][2]\n            \n            # Case i == j: single-event path\n            if i == j:\n                path_count = 1\n            else: # Case i  j: multi-event path\n                path_count = num_paths[i, j]\n\n            if path_count > 0:\n                nodes_i = {events[i][1][0], events[i][1][1]}\n                nodes_j = {events[j][1][0], events[j][1][1]}\n                \n                for s_node in nodes_i:\n                    for t_node in nodes_j:\n                        if s_node == t_node:\n                            continue\n                        \n                        s_idx, t_idx = node_to_idx[s_node], node_to_idx[t_node]\n                        \n                        if duration  min_duration[s_idx, t_idx]:\n                            min_duration[s_idx, t_idx] = duration\n                            sigma_st[s_idx, t_idx] = path_count\n                        elif duration == min_duration[s_idx, t_idx]:\n                            sigma_st[s_idx, t_idx] += path_count\n\n    # Step 4: Compute betweenness centrality for each event\n    betweenness = np.zeros(m, dtype=float)\n    for k in range(m):  # The event being passed through\n        for i in range(k):  # The start event of the path\n            for j in range(k + 1, m):  # The end event of the path\n                \n                # Number of paths i -> ... -> k -> ... -> j\n                term = num_paths[i, k] * num_paths[k, j]\n                if term == 0:\n                    continue\n                \n                duration = events[j][1][2] - events[i][1][2]\n                \n                inner_sum = 0.0\n                nodes_i = {events[i][1][0], events[i][1][1]}\n                nodes_j = {events[j][1][0], events[j][1][1]}\n                \n                for s_node in nodes_i:\n                    for t_node in nodes_j:\n                        if s_node == t_node:\n                            continue\n                        \n                        s_idx, t_idx = node_to_idx[s_node], node_to_idx[t_node]\n                        \n                        if sigma_st[s_idx, t_idx] > 0 and np.isclose(duration, min_duration[s_idx, t_idx]):\n                            inner_sum += 1.0 / sigma_st[s_idx, t_idx]\n                \n                betweenness[k] += term * inner_sum\n    \n    # Reorder results to match original event input order\n    final_betweenness = np.zeros(m, dtype=float)\n    for i in range(m):\n        final_betweenness[original_indices[i]] = betweenness[i]\n        \n    return final_betweenness.tolist()\n\nsolve()\n```"
        }
    ]
}