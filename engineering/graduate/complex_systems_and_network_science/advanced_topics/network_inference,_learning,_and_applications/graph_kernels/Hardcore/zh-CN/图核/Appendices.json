{
    "hands_on_practices": [
        {
            "introduction": "Weisfeiler-Leman (WL) 核是图核方法中功能最强大、应用最广泛的一类。它借鉴了图同构测试中的经典 WL 测试算法，通过迭代式地聚合邻域信息来为节点生成富有表现力的特征。本练习将引导你亲手完成一次 WL 迭代的完整计算过程，从最基本的层面揭示其运作机制。通过为两个简单的图计算节点签名、执行标签压缩并构建特征向量，你将深入理解 WL 核如何将图的局部结构信息系统地转化为可用于机器学习的数值表示。",
            "id": "4279075",
            "problem": "考虑两个有限、简单、无向、节点标记的图，其标记取自字母表 $\\Sigma = \\{\\alpha,\\beta\\}$。设图 $G = (V_G,E_G)$ 的顶点集为 $V_G = \\{1,2,3,4\\}$，边集为 $E_G = \\{\\{1,2\\},\\{2,3\\},\\{3,1\\},\\{2,4\\}\\}$。设图 $H = (V_H,E_H)$ 的顶点集为 $V_H = \\{5,6,7,8\\}$，边集为 $E_H = \\{\\{5,6\\},\\{6,7\\},\\{7,5\\},\\{7,8\\}\\}$。初始节点标记函数为 $\\ell_G^{(0)} : V_G \\to \\Sigma$，由 $\\ell_G^{(0)}(1) = \\alpha$, $\\ell_G^{(0)}(2) = \\beta$, $\\ell_G^{(0)}(3) = \\alpha$, $\\ell_G^{(0)}(4) = \\beta$ 给出；以及 $\\ell_H^{(0)} : V_H \\to \\Sigma$，由 $\\ell_H^{(0)}(5) = \\alpha$, $\\ell_H^{(0)}(6) = \\alpha$, $\\ell_H^{(0)}(7) = \\beta$, $\\ell_H^{(0)}(8) = \\beta$ 给出。令 $N_G(v)$ 和 $N_H(v)$ 分别表示图 $G$ 和 $H$ 中节点 $v$ 的邻居集合。\n\n一维 Weisfeiler–Leman (WL) 细化的一轮迭代为每个节点 $v$ 构建高度 $t=1$ 处的签名为一个序对\n$$\n\\sigma^{(1)}(v) := \\Big(\\ell^{(0)}(v),\\, \\mathrm{sort}\\big(\\{\\!\\{\\ell^{(0)}(u) : u \\in N(v)\\}\\!\\}\\big)\\Big),\n$$\n其中 $\\mathrm{sort}$ 返回根据固定排序 $\\alpha  \\beta$ 的非递减顺序的标记序列，而 $\\{\\!\\{\\cdot\\}\\!\\}$ 表示多重集。然后构建一个全局单射压缩映射 $\\kappa_1$，方法是收集 $v \\in V_G \\cup V_H$ 上的所有不同 $\\sigma^{(1)}(v)$，并使用以下规则对这些序对进行字典序排序：首先按 $\\alpha  \\beta$ 比较第一个分量，然后按邻居序列的长度递增比较，最后按 $\\alpha  \\beta$ 下的字典序比较；按此排序顺序分配从1开始的连续整数。高度为 $1$ 处的压缩细化标记为 $\\ell^{(1)}(v) := \\kappa_1(\\sigma^{(1)}(v))$。类似地，为初始标记定义一个全局压缩映射 $\\kappa_0$，方法是在 $\\alpha  \\beta$ 下对 $\\{\\alpha,\\beta\\}$ 进行排序，并分配 $\\kappa_0(\\alpha) = 1$，$\\kappa_0(\\beta) = 2$；压缩后的初始标记为 $\\tilde{\\ell}^{(0)}(v) := \\kappa_0(\\ell^{(0)}(v))$。\n\n对于每个高度 $t \\in \\{0,1\\}$，定义特征计数向量 $\\phi_t(G)$，其分量为图 $G$ 中在全局映射下具有每个高度 $t$ 处压缩标记的节点数。类似地为 $H$ 定义 $\\phi_t(H)$。$G$ 和 $H$ 之间高度为 $h=1$ 的 Weisfeiler–Leman (WL) 核是在高度 $t=0$ 和 $t=1$ 上的聚合计数向量的内积：\n$$\nK_{\\mathrm{WL}}^{(1)}(G,H) := \\langle \\phi_0(G), \\phi_0(H) \\rangle + \\langle \\phi_1(G), \\phi_1(H) \\rangle.\n$$\n\n从上述核心定义出发，对 $G$ 和 $H$ 执行一轮 WL 细化迭代（$t=1$），构建全局压缩映射，计算细化后的标记计数，并评估 $K_{\\mathrm{WL}}^{(1)}(G,H)$。将最终答案表示为一个实数值。不需要四舍五入。",
            "solution": "该问题要求计算两个图 $G$ 和 $H$ 之间高度为 $h=1$ 的 Weisfeiler–Leman (WL) 核。该核定义为高度 $t=0$ 和 $t=1$ 处的特征计数向量的内积之和：\n$$\nK_{\\mathrm{WL}}^{(1)}(G,H) = \\langle \\phi_0(G), \\phi_0(H) \\rangle + \\langle \\phi_1(G), \\phi_1(H) \\rangle.\n$$\n我们将分别计算每一项。\n\n**第一部分：高度 $t=0$ 分析**\n\n首先，我们确定高度 $t=0$ 时初始节点标记的特征计数向量。标记字母表为 $\\Sigma = \\{\\alpha, \\beta\\}$，排序为 $\\alpha  \\beta$。\n\n图 $G$ 的初始节点标记为：\n- $\\ell_G^{(0)}(1) = \\alpha$\n- $\\ell_G^{(0)}(2) = \\beta$\n- $\\ell_G^{(0)}(3) = \\alpha$\n- $\\ell_G^{(0)}(4) = \\beta$\n$G$ 中标记的计数为 $\\alpha$ 有 $2$ 个，$\\beta$ 有 $2$ 个。\n\n图 $H$ 的初始节点标记为：\n- $\\ell_H^{(0)}(5) = \\alpha$\n- $\\ell_H^{(0)}(6) = \\alpha$\n- $\\ell_H^{(0)}(7) = \\beta$\n- $\\ell_H^{(0)}(8) = \\beta$\n$H$ 中标记的计数为 $\\alpha$ 有 $2$ 个，$\\beta$ 有 $2$ 个。\n\n初始标记的全局压缩映射 $\\kappa_0$ 是通过对 $\\{\\alpha, \\beta\\}$ 进行排序得到序列 $(\\alpha, \\beta)$ 并从 $1$ 开始分配整数标记来定义的：\n- $\\kappa_0(\\alpha) = 1$\n- $\\kappa_0(\\beta) = 2$\n节点 $v$ 的压缩初始标记为 $\\tilde{\\ell}^{(0)}(v) = \\kappa_0(\\ell^{(0)}(v))$。\n\n特征计数向量 $\\phi_0(G)$ 的分量对应于压缩标记 $\\{1, 2\\}$ 的计数。\n对于图 $G$，标记 $1$（来自 $\\alpha$）的计数为 $2$，标记 $2$（来自 $\\beta$）的计数为 $2$。\n因此，$\\phi_0(G) = \\begin{pmatrix} 2  2 \\end{pmatrix}^\\top$。\n\n类似地，对于图 $H$，标记 $1$ 的计数为 $2$，标记 $2$ 的计数为 $2$。\n因此，$\\phi_0(H) = \\begin{pmatrix} 2  2 \\end{pmatrix}^\\top$。\n\n在高度 $t=0$ 处的内积是：\n$$\n\\langle \\phi_0(G), \\phi_0(H) \\rangle = (2 \\times 2) + (2 \\times 2) = 4 + 4 = 8.\n$$\n\n**第二部分：高度 $t=1$ 分析**\n\n接下来，我们执行一轮 WL 细化以计算高度 $t=1$ 处的特征计数向量。这涉及到为每个节点 $v \\in V_G \\cup V_H$ 计算签名 $\\sigma^{(1)}(v)$。签名定义为 $\\sigma^{(1)}(v) = (\\ell^{(0)}(v),\\, \\mathrm{sort}(\\{\\!\\{\\ell^{(0)}(u) : u \\in N(v)\\}\\!\\}\\big))$。\n\n**对于图 G：**\n- 节点 $1$：$\\ell_G^{(0)}(1)=\\alpha$。邻居 $N_G(1)=\\{2,3\\}$。邻居标记：$\\{\\ell_G^{(0)}(2), \\ell_G^{(0)}(3)\\} = \\{\\beta, \\alpha\\}$。排序后的多重集：$\\{\\alpha, \\beta\\}$。\n  $\\sigma^{(1)}(1) = (\\alpha, \\{\\alpha, \\beta\\})$。\n- 节点 $2$：$\\ell_G^{(0)}(2)=\\beta$。邻居 $N_G(2)=\\{1,3,4\\}$。邻居标记：$\\{\\ell_G^{(0)}(1), \\ell_G^{(0)}(3), \\ell_G^{(0)}(4)\\} = \\{\\alpha, \\alpha, \\beta\\}$。排序后的多重集：$\\{\\alpha, \\alpha, \\beta\\}$。\n  $\\sigma^{(1)}(2) = (\\beta, \\{\\alpha, \\alpha, \\beta\\})$。\n- 节点 $3$：$\\ell_G^{(0)}(3)=\\alpha$。邻居 $N_G(3)=\\{1,2\\}$。邻居标记：$\\{\\ell_G^{(0)}(1), \\ell_G^{(0)}(2)\\} = \\{\\alpha, \\beta\\}$。排序后的多重集：$\\{\\alpha, \\beta\\}$。\n  $\\sigma^{(1)}(3) = (\\alpha, \\{\\alpha, \\beta\\})$。\n- 节点 $4$：$\\ell_G^{(0)}(4)=\\beta$。邻居 $N_G(4)=\\{2\\}$。邻居标记：$\\{\\ell_G^{(0)}(2)\\} = \\{\\beta\\}$。排序后的多重集：$\\{\\beta\\}$。\n  $\\sigma^{(1)}(4) = (\\beta, \\{\\beta\\})$。\n\n**对于图 H：**\n- 节点 $5$：$\\ell_H^{(0)}(5)=\\alpha$。邻居 $N_H(5)=\\{6,7\\}$。邻居标记：$\\{\\ell_H^{(0)}(6), \\ell_H^{(0)}(7)\\} = \\{\\alpha, \\beta\\}$。排序后的多重集：$\\{\\alpha, \\beta\\}$。\n  $\\sigma^{(1)}(5) = (\\alpha, \\{\\alpha, \\beta\\})$。\n- 节点 $6$：$\\ell_H^{(0)}(6)=\\alpha$。邻居 $N_H(6)=\\{5,7\\}$。邻居标记：$\\{\\ell_H^{(0)}(5), \\ell_H^{(0)}(7)\\} = \\{\\alpha, \\beta\\}$。排序后的多重集：$\\{\\alpha, \\beta\\}$。\n  $\\sigma^{(1)}(6) = (\\alpha, \\{\\alpha, \\beta\\})$。\n- 节点 $7$：$\\ell_H^{(0)}(7)=\\beta$。邻居 $N_H(7)=\\{5,6,8\\}$。邻居标记：$\\{\\ell_H^{(0)}(5), \\ell_H^{(0)}(6), \\ell_H^{(0)}(8)\\} = \\{\\alpha, \\alpha, \\beta\\}$。排序后的多重集：$\\{\\alpha, \\alpha, \\beta\\}$。\n  $\\sigma^{(1)}(7) = (\\beta, \\{\\alpha, \\alpha, \\beta\\})$。\n- 节点 $8$：$\\ell_H^{(0)}(8)=\\beta$。邻居 $N_H(8)=\\{7\\}$。邻居标记：$\\{\\ell_H^{(0)}(7)\\} = \\{\\beta\\}$。排序后的多重集：$\\{\\beta\\}$。\n  $\\sigma^{(1)}(8) = (\\beta, \\{\\beta\\})$。\n\n现在，我们收集 $V_G \\cup V_H$ 中的所有不同签名，并对它们进行排序以创建全局压缩映射 $\\kappa_1$。不同的签名集合是：\n- $s_A = (\\alpha, \\{\\alpha, \\beta\\})$\n- $s_B = (\\beta, \\{\\alpha, \\alpha, \\beta\\})$\n- $s_C = (\\beta, \\{\\beta\\})$\n\n我们按字典序对它们进行排序。\n1. 使用 $\\alpha  \\beta$ 比较第一个分量。这将 $s_A$ 排在第一位。\n2. 比较 $s_B$ 和 $s_C$。它们的第一个分量都是 $\\beta$。我们首先按长度比较它们的第二个分量（邻居多重集）。$s_C$ 的长度是 $1$，$s_B$ 的长度是 $3$。因此，$s_C$ 在 $s_B$ 之前。\n\n唯一的签名的排序列表是：\n1. $(\\alpha, \\{\\alpha, \\beta\\})$\n2. $(\\beta, \\{\\beta\\})$\n3. $(\\beta, \\{\\alpha, \\alpha, \\beta\\})$\n\n压缩映射 $\\kappa_1$ 将整数分配给这些排序后的签名：\n- $\\kappa_1((\\alpha, \\{\\alpha, \\beta\\})) = 1$\n- $\\kappa_1((\\beta, \\{\\beta\\})) = 2$\n- $\\kappa_1((\\beta, \\{\\alpha, \\alpha, \\beta\\})) = 3$\n\n使用 $\\kappa_1$，我们找到压缩后的细化标记 $\\ell^{(1)}(v) = \\kappa_1(\\sigma^{(1)}(v))$。\n对于图 G：\n- $\\ell^{(1)}(1) = \\kappa_1((\\alpha, \\{\\alpha, \\beta\\})) = 1$\n- $\\ell^{(1)}(2) = \\kappa_1((\\beta, \\{\\alpha, \\alpha, \\beta\\})) = 3$\n- $\\ell^{(1)}(3) = \\kappa_1((\\alpha, \\{\\alpha, \\beta\\})) = 1$\n- $\\ell^{(1)}(4) = \\kappa_1((\\beta, \\{\\beta\\})) = 2$\n$G$ 中细化标记的计数是：两个节点标记为 $1$，一个节点标记为 $2$，一个节点标记为 $3$。\n因此，特征计数向量为 $\\phi_1(G) = \\begin{pmatrix} 2  1  1 \\end{pmatrix}^\\top$。\n\n对于图 H：\n- $\\ell^{(1)}(5) = \\kappa_1((\\alpha, \\{\\alpha, \\beta\\})) = 1$\n- $\\ell^{(1)}(6) = \\kappa_1((\\alpha, \\{\\alpha, \\beta\\})) = 1$\n- $\\ell^{(1)}(7) = \\kappa_1((\\beta, \\{\\alpha, \\alpha, \\beta\\})) = 3$\n- $\\ell^{(1)}(8) = \\kappa_1((\\beta, \\{\\beta\\})) = 2$\n$H$ 中细化标记的计数是：两个节点标记为 $1$，一个节点标记为 $2$，一个节点标记为 $3$。\n因此，特征计数向量为 $\\phi_1(H) = \\begin{pmatrix} 2  1  1 \\end{pmatrix}^\\top$。\n\n在高度 $t=1$ 处的内积是：\n$$\n\\langle \\phi_1(G), \\phi_1(H) \\rangle = (2 \\times 2) + (1 \\times 1) + (1 \\times 1) = 4 + 1 + 1 = 6.\n$$\n\n**第三部分：最终核计算**\n\n最后，我们将两个高度的内积相加，以获得 WL 核的值。\n$$\nK_{\\mathrm{WL}}^{(1)}(G,H) = \\langle \\phi_0(G), \\phi_0(H) \\rangle + \\langle \\phi_1(G), \\phi_1(H) \\rangle = 8 + 6 = 14.\n$$",
            "answer": "$$\n\\boxed{14}\n$$"
        },
        {
            "introduction": "与其关注局部邻域，一些图核方法转而捕捉图的全局拓扑特性，而最短路径核正是其中的经典代表。它通过统计图中所有节点对之间最短路径长度的分布来对图进行表征，从而为每个图生成一个全局性的结构“指纹”。在此练习中，你将为两种不同结构（链式图与星形图）的图计算所有节点对之间的最短路径，构建长度分布的直方图，并最终使用高斯核函数来衡量这两种分布的相似性。这个过程清晰地展示了如何将图的基本属性转化为特征向量，并将其与成熟的核方法相结合，以实现图的比较与分类。",
            "id": "4279073",
            "problem": "考虑两个无向、简单、连通的加权图 $G$ 和 $H$，它们都有 $5$ 个标记节点 $\\{1,2,3,4,5\\}$，其边权重函数 $w: E \\to \\mathbb{R}_{0}$ 具体规定如下。在图 $G$ 中，仅有的边是 $(1,2)$、$(2,3)$、$(3,4)$、$(4,5)$，每条边的权重 $w(e)=1$。在图 $H$ 中，仅有的边是 $(3,1)$、$(3,2)$、$(3,4)$、$(3,5)$，每条边的权重 $w(e)=1$。两个图中都没有其他边。\n\n您需要为每个图构建一个最短路径长度分布作为其特征表示，然后计算这些特征分布之间的高斯径向基函数（RBF）核，以得到 $k(G,H)$。请使用以下基本定义和步骤：\n\n- 节点 $u$ 和 $v$ 之间的最短路径长度，记为 $d(u,v)$，是连接 $u$ 和 $v$ 的所有路径 $\\pi$ 中，沿 $\\pi$ 的边权重之和的最小值。\n- 考虑所有无序节点对 $\\{u,v\\}$，其中 $u,v \\in \\{1,\\dots,5\\}$ 且 $u  v$。\n- 对于每个图，构建一个特征向量 $v \\in \\mathbb{R}_{\\ge 0}^d$，其分量 $v_k$ 是长度为 $k$ 的最短路径的数量，其中 $k=1, 2, \\dots$。由于图是有限的，这个向量将只有有限个非零分量。\n- 图 $G$ 和 $H$ 之间的高斯 RBF 核由下式给出：\n  $$\n  k(G,H) = \\exp\\left(-\\gamma \\|v_G - v_H\\|^2\\right)\n  $$\n  其中 $v_G$ 和 $v_H$ 是分别为图 $G$ 和 $H$ 构建的特征向量，$\\|\\cdot\\|^2$ 是欧几里得范数的平方。使用参数 $\\gamma = 1/50$。\n\n计算 $k(G,H)$ 的值。",
            "solution": "该问题要求计算两个图 $G$ 和 $H$ 之间的高斯 RBF 核。这需要三个步骤：为每个图计算其最短路径长度分布，将这些分布表示为特征向量，然后计算这些向量之间的 RBF 核。\n\n**第一步：计算图 G 的特征向量 $v_G$**\n\n图 $G$ 是一个有 5 个节点的路径图：$1-2-3-4-5$。所有边的权重为 1。我们需要计算所有 $\\binom{5}{2}=10$ 个无序节点对之间的最短路径长度。\n\n- **长度为 1 的最短路径**：\n  - $d(1,2)=1$, $d(2,3)=1$, $d(3,4)=1$, $d(4,5)=1$。\n  - 总共有 **4** 条。\n\n- **长度为 2 的最短路径**：\n  - $d(1,3)=2$, $d(2,4)=2$, $d(3,5)=2$。\n  - 总共有 **3** 条。\n\n- **长度为 3 的最短路径**：\n  - $d(1,4)=3$, $d(2,5)=3$。\n  - 总共有 **2** 条。\n\n- **长度为 4 的最短路径**：\n  - $d(1,5)=4$。\n  - 总共有 **1** 条。\n\n我们将这些计数编译成特征向量 $v_G$，其中第 $k$ 个分量是长度为 $k$ 的最短路径数。\n$v_G = (4, 3, 2, 1, 0, \\dots)$。\n\n**第二步：计算图 H 的特征向量 $v_H$**\n\n图 $H$ 是一个以节点 3 为中心的星形图。所有边的权重为 1。我们再次计算 10 个节点对之间的最短路径长度。\n\n- **长度为 1 的最短路径**：这些是从中心节点 3 到所有其他节点的路径。\n  - $d(3,1)=1$, $d(3,2)=1$, $d(3,4)=1$, $d(3,5)=1$。\n  - 总共有 **4** 条。\n\n- **长度为 2 的最短路径**：这些是任意两个非中心节点之间的路径，它们都必须经过中心节点 3。\n  - $d(1,2) = d(1,3) + d(3,2) = 1+1=2$\n  - $d(1,4) = d(1,3) + d(3,4) = 1+1=2$\n  - $d(1,5) = d(1,3) + d(3,5) = 1+1=2$\n  - $d(2,4) = d(2,3) + d(3,4) = 1+1=2$\n  - $d(2,5) = d(2,3) + d(3,5) = 1+1=2$\n  - $d(4,5) = d(4,3) + d(3,5) = 1+1=2$\n  - 总共有 **6** 条。\n\n- **更长路径**：不存在比 2 更长的最短路径。\n\n我们将这些计数编译成特征向量 $v_H$。\n$v_H = (4, 6, 0, 0, 0, \\dots)$。\n\n**第三步：计算高斯 RBF 核**\n\n核函数定义为 $k(G,H) = \\exp\\left(-\\gamma \\|v_G - v_H\\|^2\\right)$，其中 $\\gamma = 1/50$。\n\n首先，计算特征向量的差：\n$v_G - v_H = (4-4, 3-6, 2-0, 1-0, 0-0, \\dots) = (0, -3, 2, 1, 0, \\dots)$。\n\n接下来，计算这个差向量的欧几里得范数的平方：\n$\\|v_G - v_H\\|^2 = 0^2 + (-3)^2 + 2^2 + 1^2 = 0 + 9 + 4 + 1 = 14$。\n\n最后，将这个值代入 RBF 核公式：\n$k(G,H) = \\exp\\left(-\\frac{1}{50} \\times 14\\right) = \\exp\\left(-\\frac{14}{50}\\right) = \\exp\\left(-\\frac{7}{25}\\right)$。\n\n因此，图 $G$ 和 $H$ 之间的高斯 RBF 核的值为 $\\exp\\left(-\\frac{7}{25}\\right)$。",
            "answer": "$$\\boxed{\\exp\\left(-\\frac{7}{25}\\right)}$$"
        },
        {
            "introduction": "更为高阶的图核方法源于对图上扩散过程的研究，而这些过程又与图的谱属性紧密相连。热核（Heat Kernel）正是其中一种，它通过比较“热量”在不同图结构中随时间扩散的模式来衡量图的相似性。这一过程由图拉普拉斯算子的特征值所决定，其产生的“热迹”构成了对图连通性的一个丰富、多尺度的描述。本练习要求你从第一性原理出发，通过编程实现一个扩散特征核的计算。你将需要构建图拉普拉斯矩阵，计算其特征值以获得在不同扩散时间尺度 $\\beta$ 下的热迹，并利用数值积分来计算最终的核值。这项实践将抽象的谱图理论与一个强大而实用的核函数计算联系起来，展示了如何有效利用连续的结构特征来进行图分析。",
            "id": "4279068",
            "problem": "您的任务是使用图热迹为小型无向图构建和评估扩散特征核。请遵循谱图论的基本原理进行操作：对于一个具有邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 和度矩阵 $D \\in \\mathbb{R}^{n \\times n}$（定义为 $D_{ii} = \\sum_{j=1}^{n} A_{ij}$）的简单无向图，定义其组合拉普拉斯算子为 $L = D - A$。对于任意扩散尺度参数 $\\beta \\geq 0$，通过矩阵指数定义热核 $H(\\beta) = \\exp(-\\beta L)$，以及热迹 $h(\\beta) = \\operatorname{tr}(H(\\beta))$。两个图 $G$ 和 $H$ 在区间 $\\beta \\in [\\beta_{\\min}, \\beta_{\\max}]$ 上的扩散特征核由以下积分定义\n$$\nK(G,H) = \\int_{\\beta_{\\min}}^{\\beta_{\\max}} h_G(\\beta)\\, h_H(\\beta)\\, d\\beta,\n$$\n其中 $h_G(\\beta)$ 和 $h_H(\\beta)$ 分别是这两个图的热迹。您必须使用梯形法则，在指定的网格 $\\{\\beta_0, \\beta_1, \\ldots, \\beta_m\\}$（其中 $\\beta_0 = \\beta_{\\min}$ 且 $\\beta_m = \\beta_{\\max}$）上对此积分进行数值近似：\n$$\n\\widehat{K}(G,H) = \\sum_{i=0}^{m-1} \\frac{\\Delta \\beta_i}{2}\\,\\Big(h_G(\\beta_i)\\,h_H(\\beta_i) + h_G(\\beta_{i+1})\\,h_H(\\beta_{i+1})\\Big),\n$$\n其中 $\\Delta \\beta_i = \\beta_{i+1} - \\beta_i$。使用谱定理，通过 $L$ 的特征值 $\\{\\lambda_k\\}_{k=1}^{n}$ 来计算 $h(\\beta)$：\n$$\nh(\\beta) = \\sum_{k=1}^{n} e^{-\\beta \\lambda_k}.\n$$\n所有量均为无单位量。\n\n请实现一个程序，为提供的测试套件执行以下任务。对于每一对图，计算在给定 $\\beta$ 值下的热迹列表，然后在整个 $\\beta$ 范围内计算扩散特征核 $\\widehat{K}$ 的梯形近似值。\n\n图由其在带标签顶点 $\\{0,1,\\ldots,n-1\\}$ 上的边集指定，是无向、无权重的简单图（无自环，无重边）。对于每一对图，$\\beta$ 网格是明确给出的，并定义了积分边界。\n\n测试套件：\n- 第 1 对：\n  - 图 $G_A$：一个 4 节点的路径图，边集为 $\\{(0,1),(1,2),(2,3)\\}$。\n  - 图 $G_B$：一个 4 节点的星形图，中心节点为 0，边集为 $\\{(0,1),(0,2),(0,3)\\}$。\n  - 网格 $\\mathcal{B}_1 = [\\,0.0,\\,0.25,\\,0.5,\\,1.0,\\,2.0\\,]$，因此 $\\beta_{\\min} = 0.0$，$\\beta_{\\max} = 2.0$。\n  - 任务：计算 $[h_{G_A}(\\beta): \\beta \\in \\mathcal{B}_1]$、$[h_{G_B}(\\beta): \\beta \\in \\mathcal{B}_1]$ 以及在 $[0.0, 2.0]$ 上的 $\\widehat{K}(G_A,G_B)$。\n- 第 2 对：\n  - 图 $G_C$：一个三角形（3 节点的环图），边集为 $\\{(0,1),(1,2),(2,0)\\}$。\n  - 图 $G_D$：一个 3 节点的路径图，边集为 $\\{(0,1),(1,2)\\}$。\n  - 网格 $\\mathcal{B}_2 = [\\,0.0,\\,0.1,\\,0.2,\\,0.5,\\,1.0\\,]$，因此 $\\beta_{\\min} = 0.0$，$\\beta_{\\max} = 1.0$。\n  - 任务：计算 $[h_{G_C}(\\beta): \\beta \\in \\mathcal{B}_2]$、$[h_{G_D}(\\beta): \\beta \\in \\mathcal{B}_2]$ 以及在 $[0.0, 1.0]$ 上的 $\\widehat{K}(G_C,G_D)$。\n- 第 3 对：\n  - 图 $G_E$：2 个孤立节点，无边。\n  - 图 $G_F$：2 个节点上的单条边，边集为 $\\{(0,1)\\}$。\n  - 网格 $\\mathcal{B}_3 = [\\,0.0,\\,5.0\\,]$，因此 $\\beta_{\\min} = 0.0$，$\\beta_{\\max} = 5.0$。\n  - 任务：计算 $[h_{G_E}(\\beta): \\beta \\in \\mathcal{B}_3]$、$[h_{G_F}(\\beta): \\beta \\in \\mathcal{B}_3]$ 以及在 $[0.0,5.0]$ 上的 $\\widehat{K}(G_E,G_F)$。\n\n您的程序必须：\n- 从给定的边构建每个拉普拉斯算子 $L$。\n- 使用上述特征值公式计算所有热迹。\n- 在提供的网格上使用梯形法则近似每个扩散特征核。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。这九个项目必须按顺序为：\n  - $G_A$ 在 $\\mathcal{B}_1$ 上的热迹列表，\n  - $G_B$ 在 $\\mathcal{B}_1$ 上的热迹列表，\n  - 标量 $\\widehat{K}(G_A,G_B)$，\n  - $G_C$ 在 $\\mathcal{B}_2$ 上的热迹列表，\n  - $G_D$ 在 $\\mathcal{B}_2$ 上的热迹列表，\n  - 标量 $\\widehat{K}(G_C,G_D)$，\n  - $G_E$ 在 $\\mathcal{B}_3$ 上的热迹列表，\n  - $G_F$ 在 $\\mathcal{B}_3$ 上的热迹列表，\n  - 标量 $\\widehat{K}(G_E,G_F)$。\n- 每个浮点数至少用 15 位小数表示。\n- 输出不得包含空格，例如：“[[...],[...],0.123456789012345,[...],[...],0.234567890123456,[...],[...],0.345678901234567]”。",
            "solution": "问题陈述经评估为**有效**。它具有科学依据，问题定义明确且客观。所有定义、数据和约束都已提供，没有矛盾，并且基于谱图论和数值分析的既定原则。该问题是一个定义明确的计算任务，在理论上是合理的，在实践中是可行的。\n\n解决方案通过实现指定的数学形式来推进。问题的核心是计算图对之间的一种相似性度量，即扩散特征核。对于每一对图 $G$ 和 $H$，这需要三个主要步骤。\n\n1.  **图拉普拉斯算子构建**：图从根本上由其连通性表示。对于一个有 $n$ 个顶点的简单无向图 $G$，我们首先构建其邻接矩阵 $A$，这是一个 $n \\times n$ 矩阵，其中如果顶点 $i$ 和顶点 $j$ 之间存在边，则 $A_{ij} = 1$，否则 $A_{ij} = 0$。根据 $A$，我们构建对角度矩阵 $D$，其中每个对角元素 $D_{ii}$ 是顶点 $i$ 的度，计算方式为 $D_{ii} = \\sum_{j=1}^{n} A_{ij}$。然后定义组合拉普拉斯矩阵 $L$ 为 $L = D - A$。该矩阵是谱图论的基石，其属性编码了有关图的重要结构信息。\n\n2.  **通过特征值分解计算热迹**：图上的热扩散由图热方程建模，其解涉及拉普拉斯算子的矩阵指数 $H(\\beta) = \\exp(-\\beta L)$，其中 $\\beta$ 是一个类时间的扩散尺度参数。热迹 $h(\\beta) = \\operatorname{tr}(H(\\beta))$ 是一个图不变量，它捕捉了图在不同扩散尺度下的结构信息。直接计算矩阵指数的计算成本很高。问题指定了一种使用谱定理的更有效方法。由于拉普拉斯矩阵 $L$ 是实对称的，因此它是可对角化的，并具有一组完整的实特征值 $\\{\\lambda_k\\}_{k=1}^{n}$。矩阵的迹是其特征值之和。因此，矩阵函数（如矩阵指数）的迹是将该函数应用于每个特征值后的总和。因此，热迹可以计算为：\n    $$\n    h(\\beta) = \\operatorname{tr}(\\exp(-\\beta L)) = \\sum_{k=1}^{n} \\lambda_k(\\exp(-\\beta L)) = \\sum_{k=1}^{n} \\exp(-\\beta \\lambda_k)\n    $$\n    对于每个图，我们计算其拉普拉斯矩阵 $L$ 的特征值。然后，对于指定网格 $\\mathcal{B}$ 中的每个 $\\beta$ 值，我们使用此求和公式计算 $h(\\beta)$。一个关键属性是，对于任何具有 $n$ 个顶点的图，都有 $h(0) = \\sum_{k=1}^{n} \\exp(0) = n$，这可以作为一个有用的健全性检查。\n\n3.  **核的数值积分**：扩散特征核 $K(G,H)$ 定义为两个图的热迹乘积在一系列 $\\beta$ 值上的积分：\n    $$\n    K(G,H) = \\int_{\\beta_{\\min}}^{\\beta_{\\max}} h_G(\\beta)\\, h_H(\\beta)\\, d\\beta\n    $$\n    该积分衡量了图在不同尺度上扩散轮廓的相似性。问题要求使用梯形法则，在给定的 $\\beta$ 值网格 $\\mathcal{B} = \\{\\beta_0, \\beta_1, \\ldots, \\beta_m\\}$ 上对该积分进行数值近似 $\\widehat{K}(G,H)$。其公式由下式给出：\n    $$\n    \\widehat{K}(G,H) = \\sum_{i=0}^{m-1} \\frac{\\Delta \\beta_i}{2}\\,\\Big(f(\\beta_i) + f(\\beta_{i+1})\\Big),\n    $$\n    其中 $f(\\beta) = h_G(\\beta)h_H(\\beta)$ 是被积函数，$\\Delta \\beta_i = \\beta_{i+1} - \\beta_i$ 是步长，步长可能不均匀。对每一对图，使用它们在网格点上计算出的热迹值执行此求和。\n\n对于问题中指定的三个测试对，均实施此三步过程。然后将结果——每对图的热迹列表和标量核值——收集并按照严格的输出要求格式化为单个字符串。整个过程依赖于标准的、数值稳定的算法，即对称矩阵的特征值计算和数值积分的梯形法则，这些算法在 `numpy` 库中随时可用。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the graph kernel problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"graphs\": {\n                \"G_A\": {\"n\": 4, \"edges\": [(0, 1), (1, 2), (2, 3)]},\n                \"G_B\": {\"n\": 4, \"edges\": [(0, 1), (0, 2), (0, 3)]},\n            },\n            \"beta_grid\": [0.0, 0.25, 0.5, 1.0, 2.0],\n        },\n        {\n            \"graphs\": {\n                \"G_C\": {\"n\": 3, \"edges\": [(0, 1), (1, 2), (2, 0)]},\n                \"G_D\": {\"n\": 3, \"edges\": [(0, 1), (1, 2)]},\n            },\n            \"beta_grid\": [0.0, 0.1, 0.2, 0.5, 1.0],\n        },\n        {\n            \"graphs\": {\n                \"G_E\": {\"n\": 2, \"edges\": []},\n                \"G_F\": {\"n\": 2, \"edges\": [(0, 1)]},\n            },\n            \"beta_grid\": [0.0, 5.0],\n        },\n    ]\n\n    all_results_str = []\n    \n    def get_heat_traces(n, edges, beta_grid):\n        \"\"\"\n        Computes the heat traces for a single graph.\n        \n        Args:\n            n (int): Number of nodes in the graph.\n            edges (list of tuples): Edge list of the graph.\n            beta_grid (list of float): Grid of beta values.\n            \n        Returns:\n            list of float: List of heat trace values h(beta).\n        \"\"\"\n        adj_matrix = np.zeros((n, n), dtype=float)\n        for u, v in edges:\n            adj_matrix[u, v] = 1\n            adj_matrix[v, u] = 1\n        \n        degree_matrix = np.diag(np.sum(adj_matrix, axis=1))\n        laplacian = degree_matrix - adj_matrix\n        \n        # For a real symmetric matrix, eigvalsh is preferred for numerical stability\n        eigenvalues = np.linalg.eigvalsh(laplacian)\n        \n        heat_traces = []\n        for beta in beta_grid:\n            h_beta = np.sum(np.exp(-beta * eigenvalues))\n            heat_traces.append(h_beta)\n            \n        return heat_traces\n\n    for case in test_cases:\n        graph_defs = case[\"graphs\"]\n        beta_grid = np.array(case[\"beta_grid\"])\n        \n        graph_A_def = list(graph_defs.values())[0]\n        graph_B_def = list(graph_defs.values())[1]\n\n        h_A = get_heat_traces(graph_A_def[\"n\"], graph_A_def[\"edges\"], beta_grid)\n        h_B = get_heat_traces(graph_B_def[\"n\"], graph_B_def[\"edges\"], beta_grid)\n        \n        # Compute the integrand for the trapezoidal rule\n        integrand = np.array(h_A) * np.array(h_B)\n        \n        # Compute the kernel value using the trapezoidal rule\n        kernel_val = np.trapz(integrand, beta_grid)\n        \n        # Format results as specified\n        h_A_str = f\"[{','.join([f'{v:.15f}' for v in h_A])}]\"\n        h_B_str = f\"[{','.join([f'{v:.15f}' for v in h_B])}]\"\n        kernel_str = f\"{kernel_val:.15f}\"\n        \n        all_results_str.append(h_A_str)\n        all_results_str.append(h_B_str)\n        all_results_str.append(kernel_str)\n\n    # Final print statement in the exact required format\n    # The precision in the problem was \"at least 10\", but the example used more. Let's use 15 for safety.\n    final_output_str = f\"[{','.join(all_results_str)}]\"\n    # The problem description's example output has a format like \"[[...],[...],0.123...,...]\"\n    # My generated string looks like \"[ [...], [...], 0.123... ,... ]\"\n    # Need to remove the spaces inside the final string.\n    final_output_str = final_output_str.replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}