{
    "hands_on_practices": [
        {
            "introduction": "Weisfeiler-Lehman (WL) 测试的核心是通过迭代地聚合邻域信息来为图中的节点着色。这个练习将通过一个经典的例子，让你亲手计算$1$-WL的颜色精化过程，并揭示其基本局限性。通过对比两个结构不同但局部特征相似的图，你将直观地理解为什么$1$-WL测试有时无法区分非同构的正则图。",
            "id": "4311865",
            "problem": "考虑两个简单无向图 $G$ 和 $H$，它们定义在共同的顶点集 $\\{1,2,3,4,5,6\\}$ 上，其边集分别指定如下：\n- 图 $G$：两个不相交的三角形，其边集为 $E(G) = \\{(1,2),(2,3),(3,1),(4,5),(5,6),(6,4)\\}$。\n- 图 $H$：一个 $6$-环，其边集为 $E(H) = \\{(1,2),(2,3),(3,4),(4,5),(5,6),(6,1)\\}$。\n\n使用一维Weisfeiler-Lehman（WL）颜色细化算法，从所有顶点统一的初始颜色开始，通过根据每个顶点的当前颜色及其邻域中颜色的多重集对每个顶点进行重新着色，进行迭代细化，直到着色稳定（即不再发生细化）。对于每个图，计算其稳定着色和颜色直方图（每种颜色的顶点数量）。通过比较它们的稳定颜色直方图，判断 $1$-WL 是否能证明 $G$ 和 $H$ 是非同构的。\n\n将您的最终决定表示为单个数字：如果 $1$-WL 证明了非同构性（即稳定颜色直方图不同），则写 $1$；如果 $1$-WL 未能证明非同构性（即稳定颜色直方图相同），则写 $0$。无需四舍五入。答案没有单位。",
            "solution": "该问题要求将一维Weisfeiler-Lehman（$1$-WL）颜色细化算法应用于两个图 $G$ 和 $H$，以确定该算法是否能区分它们。这两个图定义在共同的顶点集 $V = \\{1,2,3,4,5,6\\}$ 上。\n图 $G$ 由边集 $E(G) = \\{(1,2),(2,3),(3,1),(4,5),(5,6),(6,4)\\}$ 指定，它对应于两个不相交的三角形。\n图 $H$ 由边集 $E(H) = \\{(1,2),(2,3),(3,4),(4,5),(5,6),(6,1)\\}$ 指定，它对应于一个长度为 $6$ 的环。\n\n$1$-WL 算法的操作如下：\n1.  **初始化**：所有顶点都被赋予相同的初始颜色。\n2.  **迭代**：在每一步中，根据其邻居当前颜色的多重集为每个顶点分配一个新颜色。具体来说，当且仅当两个顶点在上一步中具有相同的颜色，并且其邻居颜色的多重集也相同时，它们才会获得相同的新颜色。\n3.  **终止**：当顶点的颜色类划分在迭代之间不再变化时，算法停止。这个最终的划分就是稳定着色。\n\n如果两个图的稳定颜色直方图（每种最终颜色的顶点计数）不同，则 $1$-WL 测试可证明它们是非同构的。\n\n让我们将该算法应用于这两个图。\n\n**对图G（两个不相交的三角形）的分析**\n- **迭代 0**：\n所有 $6$ 个顶点都被赋予一个统一的初始颜色，我们称之为 $c_0$。\n着色为 $C_0(G) = \\{v \\mapsto c_0 \\text{ for all } v \\in V\\}$。\n颜色直方图为 $\\{c_0: 6\\}$。\n\n- **迭代 1**：\n我们需要为每个顶点计算新颜色。新颜色由签名 $(c_{prev}(v), M_{prev}(v))$ 决定，其中 $c_{prev}(v)$ 是顶点 $v$ 的前一个颜色，$M_{prev}(v)$ 是其邻居的前一个颜色的多重集。\n$G$ 的两个子图（两个三角形）都是 $2$-正则的，这意味着每个顶点的度都为 $2$。\n我们来分析一个任意顶点，例如顶点 $v=1$。它的邻居是 $\\{2,3\\}$。\n在迭代 $0$ 中，顶点 $1$ 的颜色是 $c_0$。它的邻居，顶点 $2$ 和 $3$，的颜色也是 $c_0$。\n因此，顶点 $1$ 的签名是 $(c_0, \\{c_0, c_0\\})$。\n由于 $G$ 中的每个顶点度都为 $2$ 且所有顶点都具有相同的初始颜色 $c_0$，所以 $G$ 中每个顶点的签名都是相同的：$(c_0, \\{c_0, c_0\\})$。\n因为所有顶点都具有相同的签名，所以在此次迭代中它们都被赋予相同的新颜色。我们称这个新颜色为 $c_1$。\n现在的着色是 $C_1(G) = \\{v \\mapsto c_1 \\text{ for all } v \\in V\\}$。\n颜色直方图为 $\\{c_1: 6\\}$。\n\n- **稳定化**：\n在迭代 $0$ 时，顶点的划分是一个包含 $6$ 个顶点的类：$\\{\\{1,2,3,4,5,6\\}\\}$。\n在迭代 $1$ 时，顶点的划分也是一个包含 $6$ 个顶点的类：$\\{\\{1,2,3,4,5,6\\}\\}$。\n由于顶点的划分没有被细化，算法已经稳定。\n$G$ 的最终颜色直方图是一个包含所有 $6$ 个顶点的颜色类。\n\n**对图H（一个6-环）的分析**\n- **迭代 0**：\n与 $G$ 类似， $H$ 的所有 $6$ 个顶点都被赋予初始颜色 $c_0$。\n着色为 $C_0(H) = \\{v \\mapsto c_0 \\text{ for all } v \\in V\\}$。\n颜色直方图为 $\\{c_0: 6\\}$。\n\n- **迭代 1**：\n图 $H$ 是一个 $6$-环，它也是一个 $2$-正则图。每个顶点的度都为 $2$。\n我们来分析一个任意顶点，比如 $v=1$。它的邻居是 $\\{2,6\\}$。\n在迭代 $0$ 中，顶点 $1$ 的颜色是 $c_0$。它的邻居，顶点 $2$ 和 $6$，的颜色也是 $c_0$。\n顶点 $1$ 的签名是 $(c_0, \\{c_0, c_0\\})$。\n与图 $G$ 一样，$H$ 中的每个顶点的度都为 $2$，并且所有顶点都以相同的颜色 $c_0$ 开始。因此，$H$ 中每个顶点的签名也是 $(c_0, \\{c_0, c_0\\})$。\n由于 $H$ 中的所有顶点都具有相同的签名，它们都被赋予相同的新颜色。因为它们的签名与 $G$ 中顶点的签名相同，所以它们被赋予相同的新颜色 $c_1$。\n着色为 $C_1(H) = \\{v \\mapsto c_1 \\text{ for all } v \\in V\\}$。\n颜色直方图为 $\\{c_1: 6\\}$。\n\n- **稳定化**：\n与图 $G$ 一样，从迭代 $0$ 到迭代 $1$，顶点的划分没有改变。算法已经稳定。\n$H$ 的最终颜色直方图是一个包含所有 $6$ 个顶点的颜色类。\n\n**结论**\n图 $G$ 的稳定颜色直方图由一个包含 $6$ 个顶点的颜色类组成。\n图 $H$ 的稳定颜色直方图也由一个包含 $6$ 个顶点的颜色类组成。\n两个直方图是相同的。\n\n因此，一维Weisfeiler-Lehman算法无法区分图 $G$ 和图 $H$。它未能证明它们是非同构的。题目要求如果证明了非同构性则输出 $1$，否则输出 $0$。由于该测试没有定论，所以正确输出是 $0$。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "既然$1$-WL测试存在表达能力的上限，一个自然的问题是我们如何能增强它？这个练习将向你介绍更高维度的WL测试，即$2$-WL，它通过考察节点对的颜色来捕捉更丰富的结构信息。通过解决一个$1$-WL测试失败而$2$-WL测试成功的例子，你将深入理解WL测试的层级性质及其表达能力的差异。",
            "id": "4311895",
            "problem": "考虑以下简单、无向、无标签图的族。对于整数 $n \\geq 2$，令 $G_n$ 为 $n$ 个长度为 $3$ 的圈（即 $n$ 个 $C_3$ 的副本）的不相交并，令 $H_n$ 为长度为 $3n$ 的单个圈（即 $C_{3n}$）。这两个图都有 $3n$ 个顶点并且是 2-正则的。\n\nWeisfeiler-Lehman (WL) 测试是用于图同构问题的一种组合精化过程。$1$-WL测试（颜色精化）根据每个顶点邻居的颜色多重集来迭代地精化顶点着色。$2$-WL测试根据所有 $w \\in V$ 上的颜色对 $\\big(\\chi_2(u,w),\\chi_2(w,v)\\big)$ 的多重集来精化有序顶点对 $(u,v)$ 的着色。\n\n仅使用WL方法的核心定义和经过充分检验的事实，按如下步骤进行：\n\n1. 从基本原理出发，论证为什么$1$-WL测试对 $G_n$ 和 $H_n$ 产生相同的稳定顶点颜色划分，因此无法区分 $G_n$ 和 $H_n$。\n2. 对于应用于有序对 $(u,v)$ 的$2$-WL测试，采用标准的初始化方法，即根据相等和邻接状态对着色：$u=v$；$u \\neq v$ 且 $\\{u,v\\} \\in E$；以及 $u \\neq v$ 且 $\\{u,v\\} \\notin E$。然后定义精化更新，将 $(u,v)$ 的当前颜色与多重集 $\\{\\!\\{ \\big(\\chi_2(u,w),\\chi_2(w,v)\\big) : w \\in V \\}\\!\\}$ 映射到一个新颜色。\n3. 证明经过$2$-WL测试的一步精化后，由于 $G_n$ 中存在三角形而 $H_n$ 中不存在， $G_n$ 和 $H_n$ 在分配给有序邻接对 $(u,v)$ 的颜色上有所不同。\n4. 令 $\\Delta(n)$ 表示在第一次精化步骤后，$G_n$ 中由端点恰好有一个公共邻居的有序邻接对 $(u,v)$ 组成的唯一2-WL颜色类的大小，与 $H_n$ 中相应颜色类的大小之差。\n\n将 $\\Delta(n)$ 计算为关于 $n$ 的闭式表达式。提供精确表达式；无需四舍五入，也无需使用单位。",
            "solution": "#### 第1部分：1维WL测试的失败\n\n1维Weisfeiler-Lehman（$1$-WL）测试，也称为颜色精化算法，其工作原理如下。\n最初，图中所有顶点都被赋予相同的颜色，我们称之为颜色 $c^{(0)}$。因此，对于任何顶点 $v$，其初始颜色为 $\\chi_0(v) = c^{(0)}$。这对图 $G_n$ 和 $H_n$ 都成立。\n\n在随后的每一步 $k+1$ 中，顶点 $v$ 的颜色会根据其邻居在第 $k$ 步的颜色多重集进行更新。具体来说，新颜色 $\\chi_{k+1}(v)$ 是对 $(\\chi_k(v), M_v^k)$ 的一个函数，其中 $M_v^k = \\{\\!\\{ \\chi_k(u) : \\{v, u\\} \\in E \\}\\!\\}$ 是 $v$ 的邻居的颜色多重集。\n\n让我们将此应用于 $G_n$ 和 $H_n$。\n问题指出 $G_n$ 和 $H_n$ 都是 2-正则图。这意味着两个图中的每个顶点都恰好有两个邻居。\n\n在第一次迭代（$k=0$）时：\n对于 $G_n$ 或 $H_n$ 中的任何顶点 $v$，其度为 2。在初始着色 $\\chi_0$ 下，它的两个邻居都具有颜色 $c^{(0)}$。因此，任何顶点 $v$ 的邻居颜色多重集为 $M_v^0 = \\{\\!\\{ c^{(0)}, c^{(0)} \\}\\!\\}$。\n新颜色 $\\chi_1(v)$ 由对 $(\\chi_0(v), M_v^0) = (c^{(0)}, \\{\\!\\{ c^{(0)}, c^{(0)} \\}\\!\\}$ 决定。由于这个对对于 $G_n$ 和 $H_n$ 中的每个顶点都是相同的，所以两个图中的所有顶点都将被赋予相同的新颜色，比如 $c^{(1)}$。\n\n着色已经稳定。对于 $G_n$ 和 $H_n$ 而言，最终的划分都只包含一个集合，其中含有所有 $3n$ 个顶点。$G_n$ 的颜色直方图是（$3n$ 个颜色为 $c^{(1)}$ 的顶点），$H_n$ 的颜色直方图也是（$3n$ 个颜色为 $c^{(1)}$ 的顶点）。由于直方图相同，1-WL测试无法区分 $G_n$ 和 $H_n$。\n\n#### 第2、3、4部分：使用2维WL测试进行区分并计算 $\\Delta(n)$\n\n2维WL测试作用于有序顶点对 $(u,v)$。\n**初始化：**\n初始着色 $\\chi_2^0$ 根据问题的规定将顶点对划分为三类：\n1.  颜色 $c_{id}$：对于对 $(u,v)$ 其中 $u=v$。\n2.  颜色 $c_{adj}$：对于对 $(u,v)$ 其中 $\\{u,v\\} \\in E$。\n3.  颜色 $c_{non-adj}$：对于对 $(u,v)$ 其中 $u \\neq v$ 且 $\\{u,v\\} \\notin E$。\n\n**第一步精化：**\n新颜色 $\\chi_2^1(u,v)$ 由对 $(\\chi_2^0(u,v), M_{u,v}^0)$ 决定，其中 $M_{u,v}^0$ 是颜色对的多重集 $\\{\\!\\{ (\\chi_2^0(u,w), \\chi_2^0(w,v)) : w \\in V \\}\\!\\}$。\n\n我们关心的是有序邻接对 $(u,v)$，所以它们的初始颜色是 $\\chi_2^0(u,v) = c_{adj}$。新颜色将由多重集 $M_{u,v}^0$ 决定。让我们分析顶点 $w$ 对这个多重集的贡献。\n- 如果 $w=u$，颜色对为 $(\\chi_2^0(u,u), \\chi_2^0(u,v)) = (c_{id}, c_{adj})$。\n- 如果 $w=v$，颜色对为 $(\\chi_2^0(u,v), \\chi_2^0(v,v)) = (c_{adj}, c_{id})$。\n- 如果 $w$ 是 $u$ 和 $v$ 的一个公共邻居（即 $\\{u,w\\} \\in E$ 且 $\\{v,w\\} \\in E$），颜色对为 $(\\chi_2^0(u,w), \\chi_2^0(w,v)) = (c_{adj}, c_{adj})$。多重集中此类对的数量等于 $u$ 和 $v$ 的公共邻居的数量。\n- 其他 $w$ 的情况涉及 $c_{non-adj}$。\n\n$G_n$ 和 $H_n$ 之间的关键区别在于邻接对 $(u,v)$ 的公共邻居数量。\n\n**对 $G_n$ 的分析：**\n图 $G_n$ 是 $n$ 个三角形（$C_3$）的不相交并。设 $(u,v)$ 是一个有序邻接对。这两个顶点属于一个特定的 $C_3$。这个三角形的第三个顶点同时是 $u$ 和 $v$ 的邻居。因此，$G_n$ 中的任何邻接对 $(u,v)$ 都有恰好一个公共邻居。因为 $G_n$ 的所有顶点都在三角形中，所以没有公共邻居为零的邻接对。对于 $G_n$ 中的任何邻接对 $(u,v)$，其路径-颜色-对的多重集将恰好包含一个 $(c_{adj}, c_{adj})$ 实例。\n\n**对 $H_n$ 的分析：**\n图 $H_n$ 是一个单圈 $C_{3n}$。问题说明 $n \\geq 2$，所以圈的长度为 $3n \\geq 6$。$C_{3n}$ 的围长（最短圈的长度）是 $3n$。三角形是长度为 3 的圈。由于 $3n \\geq 6$，$H_n$ 不包含三角形。如果一个邻接对 $(u,v)$ 有一个公共邻居 $w$，那么顶点 $\\{u,v,w\\}$ 将构成一个三角形。由于 $H_n$ 没有三角形，因此 $H_n$ 中的任何邻接对 $(u,v)$ 都没有公共邻居。对于 $H_n$ 中的任何邻接对 $(u,v)$，其路径-颜色-对的多重集将包含零个 $(c_{adj}, c_{adj})$ 实例。\n\n**关于可区分性的结论：**\n由于 $G_n$ 和 $H_n$ 中邻接对的精化多重集不同，$G_n$ 中的所有邻接对都将被赋予一个新颜色，比如 $c_{A}$，而 $H_n$ 中的所有邻接对都将被赋予另一个不同的新颜色，比如 $c_{B}$。最终的顶点对着色直方图将会不同，因此 $2$-WL测试在一步之后就能区分 $G_n$ 和 $H_n$。\n\n**$\\Delta(n)$ 的计算：**\n问题要求计算 $\\Delta(n)$，即 $G_n$ 和 $H_n$ 之间某个特定颜色类的大小之差。该颜色类被定义为包含“其端点恰好有一个公共邻居的有序邻接对 $(u,v)$”。\n\n首先，我们来计算 $G_n$ 中这类对的集合大小。\n在 $G_n$ 中，如前所述，每个邻接对都都有恰好一个公共邻居。我们需要计算有序邻接对的总数。\n- $G_n$ 由 $n$ 个不相交的 $C_3$ 副本组成。\n- 每个 $C_3$ 有 3 个顶点和 3 条边。\n- 对于每条边 $\\{u,v\\}$，有两个有序邻接对：$(u,v)$ 和 $(v,u)$。\n- 所以，每个 $C_3$ 贡献了 $3 \\times 2 = 6$ 个这样的对。\n- 有 $n$ 个这样的分量，所以在 $G_n$ 中有序邻接对的总数是 $6n$。\n所有这 $6n$ 个对都属于指定的类别。经过一步精化后，它们将形成一个大小为 $6n$ 的单一颜色类。\n\n接下来，我们计算 $H_n$ 中相应对集合的大小。\n在 $H_n$ 中，如前所述，由于图是无三角形的（对于 $n \\geq 2$），没有邻接对有公共邻居。\n因此，$H_n$ 中“其端点恰好有一个公共邻居的有序邻接对 $(u,v)$”的数量是 0。$H_n$ 中相应颜色类的大小是 0。\n\n最后，我们计算 $\\Delta(n)$ 作为这两个大小之差：\n$$ \\Delta(n) = (G_n \\text{ 中类别的大小}) - (H_n \\text{ 中类别的大小}) $$\n$$ \\Delta(n) = 6n - 0 $$\n$$ \\Delta(n) = 6n $$",
            "answer": "$$\n\\boxed{6n}\n$$"
        },
        {
            "introduction": "理论上的算法最终需要通过代码实现来发挥其作用。这个练习将引导你将Weisfeiler-Lehman颜色精化算法转化为一个具体的计算程序，用以生成图的一种“范式标签”。你将通过实践验证，这种基于WL测试的范式标签对于节点的不同编号方式是不变的，从而真正理解其作为图不变量的底层逻辑。",
            "id": "4311866",
            "problem": "实现一个程序，为小图计算基于 Weisfeiler-Lehman (WL) 的典范形式，并验证其在顶点重标记下的不变性。使用以下基础。\n\n图是一个有限、简单、无向图 $G = (V, E)$，其中 $V = \\{0, 1, \\dots, n-1\\}$ 是顶点集，而 $E \\subseteq \\{\\{i,j\\} : i, j \\in V, i \\neq j\\}$ 是边集。图由一个对称邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 表示，其中当且仅当 $\\{i,j\\} \\in E$ 时 $A_{i,j} = 1$，否则 $A_{i,j} = 0$。对于一个置换 $\\pi : V \\to V$，置换后的邻接矩阵 $A^{\\pi}$ 按分量定义为 $A^{\\pi}_{i,j} = A_{\\pi(i), \\pi(j)}$。\n\nWeisfeiler-Lehman (WL) 同构测试对顶点标签执行迭代颜色细化。令 $c_t : V \\to \\mathbb{N}$ 为第 $t$ 次迭代时的着色，初始化为对所有 $v \\in V$ 都有 $c_0(v) = 0$。对于每个 $t \\ge 1$，通过对由局部邻域形成的令牌（token）进行压缩来定义 $c_t$：\n1. 对于每个顶点 $v \\in V$，形成令牌 $T_t(v) = \\left(c_{t-1}(v), \\text{sort}\\big(\\{c_{t-1}(u) : u \\in N(v)\\}\\big)\\right)$，其中 $N(v) = \\{u \\in V : A_{v,u} = 1\\}$ 并且 $\\text{sort}(\\cdot)$ 将多重集转换为一个排序后的元组。\n2. 计算唯一令牌的集合 $U_t = \\{T_t(v) : v \\in V\\}$，并按字典序对 $U_t$ 进行排序，得到一个有序列表。\n3. 定义一个压缩映射 $\\phi_t : U_t \\to \\{0, 1, \\dots, |U_t|-1\\}$，将每个令牌映射到其在排序列表中的索引。\n4. 对所有 $v \\in V$，设置 $c_t(v) = \\phi_t\\big(T_t(v)\\big)$。\n\n当达到最小的 $T$ 使得对所有 $v \\in V$ 都有 $c_T(v) = c_{T-1}(v)$ 时，迭代停止（称为稳定）。图的基于 WL 的典范形式定义为最终稳定颜色的排序列表，即\n$$\n\\text{CF}(A) = \\text{sort}\\left([c_T(0), c_T(1), \\dots, c_T(n-1)]\\right).\n$$\n这种典范形式旨在在顶点重标记（索引的置换）下保持不变，因为 WL 细化仅使用置换不变的多重集操作以及通过排序令牌顺序进行的全局确定性压缩。\n\n任务：实现一个程序，对于每个测试用例，计算 $\\text{CF}(A)$ 并将其与 $\\text{CF}(A^{\\pi})$（对于重标记的变体）或 $\\text{CF}(B)$（对于结构不同的图）进行比较，返回一个表示是否相等的布尔值。\n\n使用以下图和置换的测试套件：\n- 测试用例 1 (正常情况，非平凡连通性)：图 $G_1$ 是一个有 $4$ 个顶点的路径图，其邻接矩阵为\n$$\nA^{(1)} = \\begin{bmatrix}\n0  1  0  0 \\\\\n1  0  1  0 \\\\\n0  1  0  1 \\\\\n0  0  1  0\n\\end{bmatrix}.\n$$\n置换 $\\pi^{(1)}$ 是反转操作 $\\pi^{(1)}(0)=3$, $\\pi^{(1)}(1)=2$, $\\pi^{(1)}(2)=1$, $\\pi^{(1)}(3)=0$。比较 $\\text{CF}\\left(A^{(1)}\\right)$ 与 $\\text{CF}\\left((A^{(1)})^{\\pi^{(1)}}\\right)$。\n\n- 测试用例 2 (边界条件，含孤立点)：图 $G_2$ 是一个有 $4$ 个顶点的图，包含一条边和两个孤立顶点，其邻接矩阵为\n$$\nA^{(2)} = \\begin{bmatrix}\n0  1  0  0 \\\\\n1  0  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  0\n\\end{bmatrix}.\n$$\n置换 $\\pi^{(2)}$ 是交换操作 $\\pi^{(2)}(0)=2$, $\\pi^{(2)}(1)=3$, $\\pi^{(2)}(2)=0$, $\\pi^{(2)}(3)=1$。比较 $\\text{CF}\\left(A^{(2)}\\right)$ 与 $\\text{CF}\\left((A^{(2)})^{\\pi^{(2)}}\\right)$。\n\n- 测试用例 3 (与非同构图对比)：将 $G_1$ 的典范形式与一个 $4$ 顶点星形图 $G_3$ 的典范形式进行比较，该星形图的中心为顶点 $0$，其邻接矩阵为\n$$\nA^{(3)} = \\begin{bmatrix}\n0  1  1  1 \\\\\n1  0  0  0 \\\\\n1  0  0  0 \\\\\n1  0  0  0\n\\end{bmatrix}.\n$$\n比较 $\\text{CF}\\left(A^{(1)}\\right)$ 与 $\\text{CF}\\left(A^{(3)}\\right)$。\n\n最终输出格式：你的程序应产生一行输出，包含用方括号括起来的逗号分隔列表形式的结果，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$，其中每个 $\\text{result}_i$ 是一个对应于上述测试用例比较的布尔值。此问题不涉及物理单位、角度单位或百分比。",
            "solution": "为解决此问题，我们将按所述实现 Weisfeiler-Lehman (WL) 算法。WL 测试的核心原理是迭代地细化图顶点的着色。在每一步中，一个顶点的颜色由其上一步自身的颜色以及其邻居颜色的多重集决定。这个过程有效地聚合了局部邻域信息。如果两个图是同构的，在假定存在确定性决胜规则（tie-breaking rule）的情况下，它们的 WL 颜色细化过程在每一步都将是相同的。所述算法通过按字典序对唯一令牌进行排序来创建压缩颜色映射，从而提供了这种确定性。最终稳定的着色为每个顶点提供了一个结构签名。然后，通过对最终顶点颜色列表进行排序，得出整个图的典范表示 $\\text{CF}(A)$。根据构造，这种典范形式对于顶点的初始标记是不变的。同构图必然会产生相同的典范形式。\n\n实现过程如下：\n1.  一个函数 `weisfeiler_lehman_canonical_form` 将接受图的邻接矩阵 $A$ 作为输入。\n2.  顶点数 $n$ 由 $A$ 的维度确定。创建一个初始颜色向量 $c_0$，其中对于所有 $v \\in \\{0, \\dots, n-1\\}$，$c_0(v) = 0$。\n3.  开始一个迭代循环。在每次迭代 $t$ 中：\n    a. 生成一个令牌列表。对于每个顶点 $v$，其令牌 $T_t(v)$ 是一个由其前一颜色 $c_{t-1}(v)$ 和其邻居颜色的排序元组 $\\text{sort}(\\{c_{t-1}(u) : u \\in N(v)\\})$ 组成的对。\n    b. 识别所有顶点的唯一令牌集合 $U_t$，然后按字典序对其进行排序。\n    c. 创建一个压缩映射 $\\phi_t$，它将每个唯一令牌映射到其在排序列表中的索引。这为每个不同的邻域签名分配一个新的、压缩的整数颜色。\n    d. 通过将 $\\phi_t$ 应用于每个顶点的令牌 $T_t(v)$ 来计算新的颜色向量 $c_t$。\n4.  当颜色向量稳定时，即对于所有 $v$ 都有 $c_t(v) = c_{t-1}(v)$，循环终止。最终的稳定向量记为 $c_T$。\n5.  典范形式 $\\text{CF}(A)$ 即为 $c_T$ 各分量的排序列表。\n6.  另一个函数 `permute_adjacency_matrix` 将使用数组索引实现顶点重标记 $A^{\\pi}_{i,j} = A_{\\pi(i), \\pi(j)}$。\n7.  对于每个测试用例，构造相应的邻接矩阵。对比较中涉及的每个图（或其置换变体）调用 WL 典范形式函数。将得到的典范形式（即整数的排序列表）进行相等性比较，以产生所需的布尔结果。",
            "answer": "```python\nimport numpy as np\n\ndef permute_adjacency_matrix(adj_matrix, perm_indices):\n    \"\"\"\n    Applies a vertex permutation to an adjacency matrix.\n\n    Args:\n        adj_matrix (np.ndarray): The input adjacency matrix.\n        perm_indices (list or np.ndarray): A list where perm_indices[i] is the\n                                          new label for the old vertex i.\n                                          The problem states pi(i) is the new label,\n                                          so we use it as A[pi(i), pi(j)] which in\n                                          numpy is A[perm_indices, :][:, perm_indices].\n\n    Returns:\n        np.ndarray: The permuted adjacency matrix A_pi.\n    \"\"\"\n    perm_indices = np.array(perm_indices)\n    # A_pi[i, j] = A[pi(i), pi(j)]\n    # This is achieved by permuting both rows and columns.\n    return adj_matrix[perm_indices, :][:, perm_indices]\n\ndef weisfeiler_lehman_canonical_form(adj_matrix):\n    \"\"\"\n    Computes the Weisfeiler-Lehman based canonical form of a graph.\n\n    Args:\n        adj_matrix (np.ndarray): The adjacency matrix of the graph.\n\n    Returns:\n        list: The sorted list of final stabilized colors (the canonical form).\n    \"\"\"\n    n = adj_matrix.shape[0]\n    colors = np.zeros(n, dtype=int)\n    \n    while True:\n        old_colors = colors.copy()\n        \n        # 1. Form tokens for each vertex\n        tokens = []\n        for i in range(n):\n            # Find neighbors of vertex i\n            neighbors = np.where(adj_matrix[i] == 1)[0]\n            # Get multiset of neighbor colors and sort it\n            neighbor_colors_multiset = sorted([old_colors[j] for j in neighbors])\n            # Form token\n            token = (old_colors[i], tuple(neighbor_colors_multiset))\n            tokens.append(token)\n            \n        # 2. Compute unique tokens and sort them\n        unique_tokens = sorted(list(set(tokens)))\n        \n        # 3. Define compression map\n        compression_map = {token: i for i, token in enumerate(unique_tokens)}\n        \n        # 4. Set new colors\n        colors = np.array([compression_map[token] for token in tokens])\n        \n        # Check for stabilization\n        if np.array_equal(colors, old_colors):\n            break\n            \n    # The canonical form is the sorted list of final colors\n    return sorted(list(colors))\n\ndef solve():\n    \"\"\"\n    Runs the test suite for the Weisfeiler-Lehman canonical form implementation.\n    \"\"\"\n    # Test case 1 data\n    A1 = np.array([\n        [0, 1, 0, 0],\n        [1, 0, 1, 0],\n        [0, 1, 0, 1],\n        [0, 0, 1, 0]\n    ])\n    pi1 = [3, 2, 1, 0]  # pi(0)=3, pi(1)=2, etc.\n\n    # Test case 2 data\n    A2 = np.array([\n        [0, 1, 0, 0],\n        [1, 0, 0, 0],\n        [0, 0, 0, 0],\n        [0, 0, 0, 0]\n    ])\n    pi2 = [2, 3, 0, 1]  # pi(0)=2, pi(1)=3, etc.\n\n    # Test case 3 data\n    A3 = np.array([\n        [0, 1, 1, 1],\n        [1, 0, 0, 0],\n        [1, 0, 0, 0],\n        [1, 0, 0, 0]\n    ])\n\n    results = []\n\n    # Process test case 1\n    cf_A1 = weisfeiler_lehman_canonical_form(A1)\n    A1_pi = permute_adjacency_matrix(A1, pi1)\n    cf_A1_pi = weisfeiler_lehman_canonical_form(A1_pi)\n    results.append(cf_A1 == cf_A1_pi)\n\n    # Process test case 2\n    cf_A2 = weisfeiler_lehman_canonical_form(A2)\n    A2_pi = permute_adjacency_matrix(A2, pi2)\n    cf_A2_pi = weisfeiler_lehman_canonical_form(A2_pi)\n    results.append(cf_A2 == cf_A2_pi)\n\n    # Process test case 3\n    # cf_A1 is already computed\n    cf_A3 = weisfeiler_lehman_canonical_form(A3)\n    results.append(cf_A1 == cf_A3)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}