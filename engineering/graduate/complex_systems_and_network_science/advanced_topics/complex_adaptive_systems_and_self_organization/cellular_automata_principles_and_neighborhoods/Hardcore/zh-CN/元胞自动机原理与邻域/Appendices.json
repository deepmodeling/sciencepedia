{
    "hands_on_practices": [
        {
            "introduction": "掌握初等元胞自动机（ECA）的第一步是理解其规则的定义方式。Wolfram 编码为一维元胞自动机提供了一种紧凑的表示法，但要应用这些规则，我们必须能够将其解码为明确的局部函数。这个练习  旨在训练您完成这种转换，并进一步将这种局部确定性规则应用于分析随机初始条件下的宏观统计性质，从而连接起规则的微观定义与系统的宏观演化。",
            "id": "4267330",
            "problem": "考虑一个初等元胞自动机 (ECA)，其定义为一个一维双态元胞自动机，邻域半径为 $1$，因此在时刻 $t$ 的每个元胞 $i$ 都有一个由三个元胞组成的邻域 $(s_{i-1}(t), s_{i}(t), s_{i+1}(t)) \\in \\{0,1\\}^{3}$，且下一时刻的状态由一个局部更新函数 $f: \\{0,1\\}^{3} \\to \\{0,1\\}$ 决定。Wolfram 编码约定为每个规则数 $R \\in \\{0,1,\\dots,255\\}$ 分配一个 8 位二进制字符串，其中从最高有效位到最低有效位的比特按顺序对应于输出 $f(1,1,1)$, $f(1,1,0)$, $f(1,0,1)$, $f(1,0,0)$, $f(0,1,1)$, $f(0,1,0)$, $f(0,0,1)$, $f(0,0,0)$。\n\n仅使用上述定义和独立的伯努利随机变量的标准性质，对特定的规则数 $R=110$ 执行以下操作：\n\n1. 推导 $R$ 的 8 位二进制表示，并按照指定的顺序为所有八种邻域模式 $(a,b,c) \\in \\{0,1\\}^{3}$ 写出明确的局部规则映射 $f(a,b,c)$。验证每个映射都与 Wolfram 编码约定下 $R$ 的正确比特位相对应。\n\n2. 假设在时刻 $t$ 的当前构型是一个参数为 $p$ 的独立同分布 (i.i.d.) 伯努利场，即 $P(s_{j}(t)=1)=p$ 且 $\\{s_{j}(t)\\}$ 对于所有 $j$ 相互独立。仅使用独立性和局部规则 $f$，推导概率 $P(s_{i}(t+1)=1)$ 作为 $p$ 的函数。\n\n将你的最终答案报告为关于 $p$ 的单个简化解析表达式。无需四舍五入，也不应包含单位。",
            "solution": "出发点是初等元胞自动机 (ECA) 的定义，它带有一个局部更新函数 $f: \\{0,1\\}^{3} \\to \\{0,1\\}$，该函数根据由三个元胞组成的邻域 $(s_{i-1}(t), s_{i}(t), s_{i+1}(t))$ 来指定下一时刻的状态 $s_{i}(t+1)$。Wolfram 编码约定提供了一个从规则数 $R \\in \\{0,1,\\dots,255\\}$ 到 $f$ 在八种可能的邻域构型上的输出的映射，这些构型按照 $R$ 的 8 位二进制表示从最高有效位到最低有效位的顺序排列为 $111, 110, 101, 100, 011, 010, 001, 000$。\n\n步骤 $1$：解码规则数 $R=110$ 并明确写出 $f$。\n\n我们首先将 $R=110$ 转换为其 8 位二进制表示。数值 $110$ 分解为\n$$\n110 = 64 + 32 + 8 + 4 + 2 = 2^{6} + 2^{5} + 2^{3} + 2^{2} + 2^{1}.\n$$\n因此，从最高有效位到最低有效位的 8 位二进制展开式为\n$$\n01101110,\n$$\n这对应于比特向量\n$$\nb_{7}\\ b_{6}\\ b_{5}\\ b_{4}\\ b_{3}\\ b_{2}\\ b_{1}\\ b_{0} = 0\\ 1\\ 1\\ 0\\ 1\\ 1\\ 1\\ 0,\n$$\n其中 $b_{k} \\in \\{0,1\\}$ 且 $b_{7}$ 是最高有效位。根据 Wolfram 约定，这些比特按以下顺序映射到邻域构型：\n$$\n111 \\mapsto b_{7},\\quad 110 \\mapsto b_{6},\\quad 101 \\mapsto b_{5},\\quad 100 \\mapsto b_{4},\\quad 011 \\mapsto b_{3},\\quad 010 \\mapsto b_{2},\\quad 001 \\mapsto b_{1},\\quad 000 \\mapsto b_{0}.\n$$\n因此，明确的局部规则值为\n- $f(1,1,1) = 0$,\n- $f(1,1,0) = 1$,\n- $f(1,0,1) = 1$,\n- $f(1,0,0) = 0$,\n- $f(0,1,1) = 1$,\n- $f(0,1,0) = 1$,\n- $f(0,0,1) = 1$,\n- $f(0,0,0) = 0$.\n\n这个映射是对 $R=110$ 的二进制表示 $01101110$ 的直接验证，与 Wolfram 编码顺序一致。\n\n步骤 $2$：在时刻 $t$ 的独立同分布伯努利$(p)$场下计算 $P(s_{i}(t+1)=1)$。\n\n在独立同分布伯努利$(p)$的假设下，在时刻 $t$ 观察到一个特定邻域 $(a,b,c) \\in \\{0,1\\}^{3}$ 的概率完全由该模式中 1 的数量决定。令 $k(a,b,c) = a + b + c$ 为 1 的计数。那么\n$$\nP\\big((s_{i-1}(t), s_{i}(t), s_{i+1}(t)) = (a,b,c)\\big) = p^{k(a,b,c)} (1-p)^{3 - k(a,b,c)}.\n$$\n下一时刻的状态 $s_{i}(t+1)$ 等于 1，当且仅当邻域满足 $f(a,b,c)=1$。从步骤 1 可知，产生 1 的邻域是\n$$\n(1,1,0),\\ (1,0,1),\\ (0,1,1),\\ (0,1,0),\\ (0,0,1).\n$$\n按 1 的数量分组：\n- 构型 $(1,1,0)$、$(1,0,1)$、$(0,1,1)$ 各有 $k=2$ 个 1，贡献的总概率为 $3\\, p^{2}(1-p)$。\n- 构型 $(0,1,0)$ 和 $(0,0,1)$ 各有 $k=1$ 个 1，贡献的总概率为 $2\\, p(1-p)^{2}$。\n\n因此，\n$$\nP\\big(s_{i}(t+1)=1\\big) = 3\\, p^{2}(1-p) + 2\\, p(1-p)^{2}.\n$$\n我们简化这个表达式：\n$$\n3\\, p^{2}(1-p) + 2\\, p(1-p)^{2} = 3p^{2} - 3p^{3} + 2p - 4p^{2} + 2p^{3} = 2p - p^{2} - p^{3}.\n$$\n因此，所求的概率作为 $p$ 的函数是\n$$\n2p - p^{2} - p^{3}.\n$$\n\n这个结果直接源于 ECA 规则的 Wolfram 编码的基本定义以及各元胞上伯努利随机变量的独立性。",
            "answer": "$$\\boxed{2 p - p^{2} - p^{3}}$$"
        },
        {
            "introduction": "除了初等元胞自动机，外总和规则（outer-totalistic rules）是另一类重要的规则，在模拟生命游戏（Conway's Game of Life）等复杂系统中尤为常见。这类规则的更新仅依赖于中心细胞自身的状态及其邻居状态的总和，而非邻居的具体排列。这个练习  将让您亲手计算一个具体构型在此外总和规则下的演化，从而加深对同步更新和邻域求和等核心操作的理解，并探讨规则的单调性这一重要性质。",
            "id": "4267327",
            "problem": "考虑一个定义在循环图上的一维二元元胞自动机（CA），该图有 $N = 12$ 个位点，索引为 $i \\in \\{0,1,\\dots,11\\}$，索引采用模运算。在时间 $t$ 的二元状态为 $x_t(i) \\in \\{0,1\\}$，半径为 $r$ 的邻域定义为 $\\mathcal{N}_r(i) = \\{i-r, i-(r-1), \\dots, i-1, i+1, \\dots, i+(r-1), i+r\\}$，其中所有索引均按模 $N$ 解释。局部更新规则是外总和型的：它仅取决于当前位点的状态及其邻居状态的总和。令 $r = 2$，并定义邻居计数为\n$$\nM(i) = \\sum_{j \\in \\mathcal{N}_2(i)} x_t(j).\n$$\n该元胞自动机根据一个外总和型阈值规则演化，其生存阈值为 $\\tau_s$，诞生阈值为 $\\tau_b$，具体如下：对每个位点 $i$，\n$$\nx_{t+1}(i) = \\begin{cases}\n1  \\text{如果 } x_t(i) = 1 \\text{ 且 } M(i) \\ge \\tau_s,\\\\\n1  \\text{如果 } x_t(i) = 0 \\text{ 且 } M(i) \\ge \\tau_b,\\\\\n0  \\text{其它情况.}\n\\end{cases}\n$$\n假设 $\\tau_s = 2$ 且 $\\tau_b = 3$。时间 $t$ 的初始构型由下式给出：\n$$\n(x_t(0), x_t(1), \\dots, x_t(11)) = (1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0).\n$$\n任务1：仅使用上述定义和指定参数，计算下一状态向量 $(x_{t+1}(0), x_{t+1}(1), \\dots, x_{t+1}(11))$，然后计算在时间 $t+1$ 的活跃位点总数，\n$$\nS = \\sum_{i=0}^{11} x_{t+1}(i).\n$$\n将 $S$ 的值作为你的最终答案。\n\n任务2：从给定定义出发（不引入任何未经检验或简化的公式），分别针对 $x_t(i) = 0$ 和 $x_t(i) = 1$ 的情况，验证位点 $i$ 处的局部更新函数关于邻居计数 $M(i)$ 是单调不减的。也就是说，证明对于任一固定的当前状态情况，增加 $M(i)$ 不会导致 $x_{t+1}(i)$ 从 $1$ 变为 $0$。任务2不需要提供额外的数值输出。",
            "solution": "该问题被验证为是自洽的，在元胞自动机理论中具有科学依据，并且是良定的。求解所需的所有定义和参数都已明确给出。\n\n第一个任务是计算一维二元元胞自动机在时间 $t+1$ 的状态向量及其分量之和。第二个任务是验证更新规则的一个性质。\n\n**任务1：计算下一状态及总和**\n\n元胞自动机定义在一个有 $N=12$ 个位点的循环图上，索引为 $i \\in \\{0, 1, \\dots, 11\\}$，采用模运算。位点的状态为 $x_t(i) \\in \\{0, 1\\}$。位点 $i$ 的邻域半径为 $r=2$，由 $\\mathcal{N}_2(i) = \\{i-2, i-1, i+1, i+2\\}$ 给出，其中所有索引均按模12计算。位点 $i$ 的邻居计数为 $M(i) = \\sum_{j \\in \\mathcal{N}_2(i)} x_t(j)$。邻域的大小为 $k=2r=4$。\n\n更新规则是外总和型的，生存阈值为 $\\tau_s = 2$，诞生阈值为 $\\tau_b = 3$。下一时间步的状态 $x_{t+1}(i)$ 由当前状态 $x_t(i)$ 和邻居计数 $M(i)$ 决定，如下所示：\n$$\nx_{t+1}(i) = \\begin{cases}\n1  \\text{如果 } x_t(i) = 1 \\text{ 且 } M(i) \\ge 2, \\\\\n1  \\text{如果 } x_t(i) = 0 \\text{ 且 } M(i) \\ge 3, \\\\\n0  \\text{其它情况.}\n\\end{cases}\n$$\n时间 $t$ 的初始构型为：\n$$\nx_t = (1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0)\n$$\n我们为从 $0$ 到 $11$ 的每个位点 $i$ 计算下一状态 $x_{t+1}(i)$。\n\n对于位点 $i=0$：$x_t(0)=1$。邻居是 $\\{10, 11, 1, 2\\}$。这些邻居的状态是 $x_t(10)=1$, $x_t(11)=0$, $x_t(1)=0$, $x_t(2)=1$。邻居计数为 $M(0) = 1+0+0+1=2$。由于 $x_t(0)=1$ 且 $M(0)=2 \\ge \\tau_s=2$，该位点存活。因此，$x_{t+1}(0)=1$。\n\n对于位点 $i=1$：$x_t(1)=0$。邻居是 $\\{11, 0, 2, 3\\}$。这些邻居的状态是 $x_t(11)=0$, $x_t(0)=1$, $x_t(2)=1$, $x_t(3)=1$。邻居计数为 $M(1)=0+1+1+1=3$。由于 $x_t(1)=0$ 且 $M(1)=3 \\ge \\tau_b=3$，一个新元胞诞生。因此，$x_{t+1}(1)=1$。\n\n对于位点 $i=2$：$x_t(2)=1$。邻居是 $\\{0, 1, 3, 4\\}$。这些邻居的状态是 $x_t(0)=1$, $x_t(1)=0$, $x_t(3)=1$, $x_t(4)=0$。邻居计数为 $M(2)=1+0+1+0=2$。由于 $x_t(2)=1$ 且 $M(2)=2 \\ge \\tau_s=2$，该位点存活。因此，$x_{t+1}(2)=1$。\n\n对于位点 $i=3$：$x_t(3)=1$。邻居是 $\\{1, 2, 4, 5\\}$。这些邻居的状态是 $x_t(1)=0$, $x_t(2)=1$, $x_t(4)=0$, $x_t(5)=0$。邻居计数为 $M(3)=0+1+0+0=1$。由于 $x_t(3)=1$ 且 $M(3)=1  \\tau_s=2$，该位点死亡。因此，$x_{t+1}(3)=0$。\n\n对于位点 $i=4$：$x_t(4)=0$。邻居是 $\\{2, 3, 5, 6\\}$。这些邻居的状态是 $x_t(2)=1$, $x_t(3)=1$, $x_t(5)=0$, $x_t(6)=1$。邻居计数为 $M(4)=1+1+0+1=3$。由于 $x_t(4)=0$ 且 $M(4)=3 \\ge \\tau_b=3$，一个新元胞诞生。因此，$x_{t+1}(4)=1$。\n\n对于位点 $i=5$：$x_t(5)=0$。邻居是 $\\{3, 4, 6, 7\\}$。这些邻居的状态是 $x_t(3)=1$, $x_t(4)=0$, $x_t(6)=1$, $x_t(7)=0$。邻居计数为 $M(5)=1+0+1+0=2$。由于 $x_t(5)=0$ 且 $M(5)=2  \\tau_b=3$，该位点保持非活跃状态。因此，$x_{t+1}(5)=0$。\n\n对于位点 $i=6$：$x_t(6)=1$。邻居是 $\\{4, 5, 7, 8\\}$。这些邻居的状态是 $x_t(4)=0$, $x_t(5)=0$, $x_t(7)=0$, $x_t(8)=0$。邻居计数为 $M(6)=0+0+0+0=0$。由于 $x_t(6)=1$ 且 $M(6)=0  \\tau_s=2$，该位点死亡。因此，$x_{t+1}(6)=0$。\n\n对于位点 $i=7$：$x_t(7)=0$。邻居是 $\\{5, 6, 8, 9\\}$。这些邻居的状态是 $x_t(5)=0$, $x_t(6)=1$, $x_t(8)=0$, $x_t(9)=1$。邻居计数为 $M(7)=0+1+0+1=2$。由于 $x_t(7)=0$ 且 $M(7)=2  \\tau_b=3$，该位点保持非活跃状态。因此，$x_{t+1}(7)=0$。\n\n对于位点 $i=8$：$x_t(8)=0$。邻居是 $\\{6, 7, 9, 10\\}$。这些邻居的状态是 $x_t(6)=1$, $x_t(7)=0$, $x_t(9)=1$, $x_t(10)=1$。邻居计数为 $M(8)=1+0+1+1=3$。由于 $x_t(8)=0$ 且 $M(8)=3 \\ge \\tau_b=3$，一个新元胞诞生。因此，$x_{t+1}(8)=1$。\n\n对于位点 $i=9$：$x_t(9)=1$。邻居是 $\\{7, 8, 10, 11\\}$。这些邻居的状态是 $x_t(7)=0$, $x_t(8)=0$, $x_t(10)=1$, $x_t(11)=0$。邻居计数为 $M(9)=0+0+1+0=1$。由于 $x_t(9)=1$ 且 $M(9)=1  \\tau_s=2$，该位点死亡。因此，$x_{t+1}(9)=0$。\n\n对于位点 $i=10$：$x_t(10)=1$。邻居是 $\\{8, 9, 11, 0\\}$。这些邻居的状态是 $x_t(8)=0$, $x_t(9)=1$, $x_t(11)=0$, $x_t(0)=1$。邻居计数为 $M(10)=0+1+0+1=2$。由于 $x_t(10)=1$ 且 $M(10)=2 \\ge \\tau_s=2$，该位点存活。因此，$x_{t+1}(10)=1$。\n\n对于位点 $i=11$：$x_t(11)=0$。邻居是 $\\{9, 10, 0, 1\\}$。这些邻居的状态是 $x_t(9)=1$, $x_t(10)=1$, $x_t(0)=1$, $x_t(1)=0$。邻居计数为 $M(11)=1+1+1+0=3$。由于 $x_t(11)=0$ 且 $M(11)=3 \\ge \\tau_b=3$，一个新元胞诞生。因此，$x_{t+1}(11)=1$。\n\n时间 $t+1$ 的状态向量为：\n$$\nx_{t+1} = (1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1)\n$$\n在时间 $t+1$ 的活跃位点总数是此向量各分量之和：\n$$\nS = \\sum_{i=0}^{11} x_{t+1}(i) = 1+1+1+0+1+0+0+0+1+0+1+1 = 7.\n$$\n\n**任务2：单调性验证**\n\n我们必须验证局部更新函数（我们记为 $f(x_t(i), M(i)) = x_{t+1}(i)$）在当前状态 $x_t(i)$ 固定的情况下，是关于邻居计数 $M(i)$ 的单调不减函数。这意味着对于任意两个邻居计数 $M_1$ 和 $M_2$，若 $M_1  M_2$，则必须有 $f(x_t(i), M_1) \\le f(x_t(i), M_2)$ 成立。\n\n情况1：当前位点是活跃的，$x_t(i) = 1$。\n更新规则为：如果 $M(i) \\ge \\tau_s$，则 $x_{t+1}(i) = 1$；如果 $M(i)  \\tau_s$，则 $x_{t+1}(i) = 0$。这可以写成 $f(1, M(i)) = H(M(i) - \\tau_s)$，其中 $H$ 是亥维赛阶跃函数，当 $z\\ge 0$ 时 $H(z)=1$，当 $z0$ 时 $H(z)=0$。\n为证明单调不减性，我们必须证明当 $M_1  M_2$ 时，$f(1, M_1)=1$ 且 $f(1, M_2)=0$ 的情况是不可能发生的。\n假设 $f(1, M_1)=1$。这意味着 $M_1 \\ge \\tau_s$。\n假设 $f(1, M_2)=0$。这意味着 $M_2  \\tau_s$。\n如果两者都成立，我们将得到 $M_1 \\ge \\tau_s$ 和 $M_2  \\tau_s$，这意味着 $M_2  M_1$。这与 $M_1  M_2$ 的假设相矛盾。\n因此，对于任意 $M_1  M_2$，我们不可能有 $f(1, M_1) > f(1, M_2)$。所以，$f(1, M(i))$ 是关于 $M(i)$ 的一个非减函数。\n\n情况2：当前位点是非活跃的，$x_t(i) = 0$。\n更新规则为：如果 $M(i) \\ge \\tau_b$，则 $x_{t+1}(i) = 1$；如果 $M(i)  \\tau_b$，则 $x_{t+1}(i) = 0$。这可以写成 $f(0, M(i)) = H(M(i) - \\tau_b)$。\n为证明单调不减性，我们必须证明当 $M_1  M_2$ 时，$f(0, M_1)=1$ 且 $f(0, M_2)=0$ 的情况是不可能发生的。\n假设 $f(0, M_1)=1$。这意味着 $M_1 \\ge \\tau_b$。\n假设 $f(0, M_2)=0$。这意味着 $M_2  \\tau_b$。\n如果两者都成立，我们将得到 $M_1 \\ge \\tau_b$ 和 $M_2  \\tau_b$，这意味着 $M_2  M_1$。这与 $M_1  M_2$ 的假设相矛盾。\n因此，对于任意 $M_1  M_2$，我们不可能有 $f(0, M_1) > f(0, M_2)$。所以，$f(0, M(i))$ 是关于 $M(i)$ 的一个非减函数。\n\n在这两种情况下，对于固定的状态 $x_t(i)$，增加邻居计数 $M(i)$ 绝不会导致下一状态 $x_{t+1}(i)$ 从 $1$ 变为 $0$。该更新函数是关于 $M(i)$ 单调不减的。验证完成。",
            "answer": "$$\n\\boxed{7}\n$$"
        },
        {
            "introduction": "要深入理解元胞自动机全局动力学的性质，例如可逆性（reversibility）或一个构型的前驱状态（preimage）数量，仅靠模拟是不够的，我们需要更强大的分析工具。这个练习  引入了德布鲁因图（de Bruijn graph），这是一个关键的理论工具，它将元胞自动机的动力学问题映射为一个图论问题。通过构建和分析这个图，我们可以精确地计算前驱状态的数量，并判断系统在给定尺寸的环上是否可逆。",
            "id": "3104885",
            "problem": "给定一个定义在长度为 $L$ 的周期环（环形边界）上的一维、二元、半径为 $1$ 的元胞自动机，它由一个作用于邻域 $(a,b,c)$ 的局部规则 $f:\\{0,1\\}^3 \\to \\{0,1\\}$ 指定，形式为 $y_i = f(x_{i-1}, x_i, x_{i+1})$，其中索引对 $L$ 取模。该局部规则由其 Wolfram 规则编号 $R \\in \\{0,1,\\dots,255\\}$ 编码，其中邻域 $(a,b,c)$ 的输出由 $R$ 在位置 $p = 4a + 2b + c$ 处的比特位给出，即 $f(a,b,c) = \\left\\lfloor \\frac{R}{2^p} \\right\\rfloor \\bmod 2$。\n\n您的任务是，从第一性原理出发，为给定的局部规则推导出 de Bruijn 图，并用它来计算目标构型的单步原像计数，以及检测在给定长度的有限环上的可逆性。对于半径为 $1$ 的二元元胞自动机，其 de Bruijn 图的节点集对应所有长度为 $2$ 的二元词，即 $V = \\{00,01,10,11\\}$，有向边对应所有长度为 $3$ 的二元词，即对于每个三元组 $(a,b,c) \\in \\{0,1\\}^3$，都有一条从节点 $ab$ 到节点 $bc$ 的边。每条边都由局部规则的输出 $f(a,b,c) \\in \\{0,1\\}$ 进行标记。定义大小为 $4 \\times 4$ 的整数邻接矩阵 $A_0$ 和 $A_1$，其中当且仅当存在一条从 $u$到 $v$ 且标记为 $\\ell \\in \\{0,1\\}$ 的边时，$(A_\\ell)_{u,v} = 1$，否则 $(A_\\ell)_{u,v} = 0$。\n\n使用的基本原理：\n- 元胞自动机定义：$y_i = f(x_{i-1}, x_i, x_{i+1})$，其中 $f$ 是局部规则，索引对 $L$ 取模。\n- 半径为 $1$ 的 de Bruijn 图构造：节点是长度为 $2$ 的词，边是长度为 $3$ 的词，重叠部分和边标记由 $f$ 决定。\n- 通过邻接矩阵进行路径计数：长度为 $L$ 且具有固定标记序列的闭路数量等于邻接矩阵乘积的迹。\n\n目标推导与算法：\n- 通过枚举所有 $(a,b,c) \\in \\{0,1\\}^3$ 来从给定的 $R$ 构建 $A_0$ 和 $A_1$。\n- 对于给定的目标词 $y \\in \\{0,1\\}^L$，计算在周期性边界条件下，全局规则一步演化后的原像数量，公式如下\n$$\\text{preimages}(y) = \\operatorname{trace}\\!\\left(A_{y_0} A_{y_1} \\cdots A_{y_{L-1}}\\right),$$\n其中 $y_i$ 是 $y$ 的第 $i$ 个比特位，如果 $y_i=0$，则 $A_{y_i}$ 为 $A_0$；如果 $y_i=1$，则 $A_{y_i}$ 为 $A_1$。\n- 对于长度为 $L$ 的有限环上的可逆性，全局映射是双射的当且仅当对于每个目标 $y \\in \\{0,1\\}^L$，其原像数量恰好为 $1$。使用上述公式测试所有 $2^L$ 个目标词。\n\n单位与格式：\n- 没有物理量；所有输出均为纯数学和逻辑值。所有数值量化输出必须是整数或布尔值。\n- 不使用角度。\n- 不使用百分比。\n\n测试套件和所需输出：\n实现一个程序，为给定规则构建 $A_0$ 和 $A_1$，并按顺序生成以下结果。对于每个原像计数案例，输出整数计数值。对于每个可逆性案例，输出一个布尔值，指示在指定长度的环上的全局映射是否为双射（True 表示可逆，False 表示不可逆）。\n\n测试案例：\n1. $R=240$ 和 $y = \\text{\"10101\"}$（长度 $L = 5$）的原像计数。\n2. $R=204$ 和 $y = \\text{\"0110\"}$（长度 $L = 4$）的原像计数。\n3. $R=90$ 和 $y = \\text{\"00\"}$（长度 $L = 2$）的原像计数。\n4. $R=30$ 和 $y = \\text{\"0000\"}$（长度 $L = 4$）的原像计数。\n5. $R=240$ 在环长度为 $L = 6$ 上的可逆性。\n6. $R=170$ 在环长度为 $L = 5$ 上的可逆性。\n7. $R=90$ 在环长度为 $L = 5$ 上的可逆性。\n8. $R=150$ 在环长度为 $L = 5$ 上的可逆性。\n9. $R=204$ 在环长度为 $L = 1$ 上的可逆性。\n10. $R=90$ 在环长度为 $L = 1$ 上的可逆性。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,...,result10]”），结果顺序与上述测试案例完全一致。",
            "solution": "所提出的问题是有效的。它在科学上基于元胞自动机和符号动力学的既定理论，问题陈述清晰，包含了所有必要的定义和约束，并以客观、正式的语言表述。它提出了一个标准的、非平凡的问题，可以使用所提供的原理通过算法解决。\n\n一维元胞自动机（CA）根据局部邻域中的状态更新格网上每个元胞的状态。对于一个在长度为 $L$ 的周期环上的半径为 $1$ 的元胞自动机，在下一个时间步，元胞 $i$ 的状态 $y_i$ 是当前时间步元胞 $i-1$、$i$ 和 $i+1$ 状态的函数 $f$，当前构型表示为 $x = (x_0, x_1, \\dots, x_{L-1})$。从 $x$ 到 $y$ 的整个构型的全局演化是通过在所有位置上同时应用局部规则 $f$ 来确定的：$y_i = f(x_{i-1}, x_i, x_{i+1})$，其中索引对 $L$ 取模。\n\n这种系统的动力学可以使用 de Bruijn 图进行分析。对于半径为 $1$ 的二元元胞自动机，de Bruijn 图的构造如下。图的节点 $V$ 表示所有可能的状态块，其长度为 $2r=2$，其中半径 $r=1$。因此，节点集为 $V = \\{00, 01, 10, 11\\}$。对于每个可能的状态三元组 $(a,b,c) \\in \\{0,1\\}^3$，都存在一条从节点 $u=ab$到节点 $v=bc$ 的有向边。这条边对应于长度为 $2r+1=3$ 的状态块 $abc$。每条边都由其对应状态块的局部规则输出 $\\ell = f(a,b,c)$ 进行标记。\n\n长度为 $L$ 的环上的一个构型 $x = (x_0, x_1, \\dots, x_{L-1})$ 可以表示为一个长度为 $2$ 的重叠块序列：$(x_0x_1), (x_1x_2), \\dots, (x_{L-2}x_{L-1}), (x_{L-1}x_0)$。这对应于 de Bruijn 图中一条长度为 $L$ 的闭路：$x_0x_1 \\to x_1x_2 \\to \\dots \\to x_{L-1}x_0$。如果局部规则输出序列与目标构型 $y = (y_0, y_1, \\dots, y_{L-1})$ 相匹配，则构型 $x$ 是 $y$ 的一个原像。在图表示中，这意味着对应于 $x$ 的闭路上的边标记序列必须恰好是 $(y_0, y_1, \\dots, y_{L-1})$。\n\n为了计算这类路径的数量，我们引入带标记的邻接矩阵。设节点 $\\{00, 01, 10, 11\\}$ 由 $u, v \\in \\{0, 1, 2, 3\\}$ 索引。我们定义两个 $4 \\times 4$ 的矩阵 $A_0$ 和 $A_1$。如果存在一条从节点 $u$ 到节点 $v$ 且标记为 $\\ell \\in \\{0,1\\}$ 的边，则矩阵项 $(A_\\ell)_{u,v}$ 为 $1$，否则为 $0$。Wolfram 规则编号 $R$ 编码了函数 $f$。对于 $2^3=8$ 个可能的邻域 $(a,b,c)$ 中的每一个，我们可以确定其整数表示 $p=4a+2b+c$。规则输出即为 $R$ 的第 $p$ 个比特位，$f(a,b,c) = (R \\gg p) \\ 1$。这个输出 $\\ell$ 决定了是在矩阵 $A_0$ 还是 $A_1$ 中设置一个条目。源节点是 $u=2a+b$，目标节点是 $v=2b+c$。因此，我们设置 $(A_\\ell)_{2a+b, 2b+c} = 1$。\n\n具有特定标记序列 $y=(y_0, \\dots, y_{L-1})$ 的长度为 $L$ 的路径数量可以通过将相应的邻接矩阵相乘得到。矩阵乘积 $M_y = A_{y_0} A_{y_1} \\cdots A_{y_{L-1}}$ 包含的矩阵项 $(M_y)_{u,v}$ 计录了从节点 $u$ 开始、到节点 $v$ 结束且标记序列为 $y$ 的长度为 $L$ 的路径数量。要找到 $y$ 的原像数量，我们需要计算具有此标记序列的*闭路*总数。这等于 $M_y$ 的对角元素之和，也就是它的迹：\n$$ \\text{preimages}(y) = \\sum_{u=0}^{3} (M_y)_{u,u} = \\operatorname{trace}(M_y) $$\n\n如果一个元胞自动机的全局映射在所有 $2^L$ 个构型的集合上是双射，则认为它在长度为 $L$ 的环上是可逆的。对于有限集上的函数，双射等价于单射和满射。这意味着对于每个目标构型 $y$，必须存在且仅存在一个原像构型 $x$。因此，一个规则在长度为 $L$ 的环上是可逆的，当且仅当对于所有 $2^L$ 个可能的目标构型 $y$，都有 $\\text{preimages}(y) = 1$。检查可逆性的算法包括遍历每个可能的目标字符串 $y \\in \\{0,1\\}^L$，使用迹公式计算其原像数量，并验证在每种情况下该数量是否恰好为 $1$。如果任何一个计数不为 $1$，则该规则是不可逆的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cellular automata problem by constructing de Bruijn graph\n    adjacency matrices and using them to count preimages and check reversibility.\n    \"\"\"\n\n    # --- Helper Functions ---\n\n    memoized_matrices = {}\n\n    def get_adjacency_matrices(R):\n        \"\"\"\n        Constructs the labeled adjacency matrices A0 and A1 for a given\n        Wolfram rule number R.\n        \"\"\"\n        if R in memoized_matrices:\n            return memoized_matrices[R]\n\n        # Nodes are '00', '01', '10', '11'. We map them to indices 0, 1, 2, 3.\n        # node_map = {'00': 0, '01': 1, '10': 2, '11': 3}\n        # which corresponds to int(s, 2)\n        A0 = np.zeros((4, 4), dtype=np.int64)\n        A1 = np.zeros((4, 4), dtype=np.int64)\n\n        # Iterate through all 8 possible neighborhoods (a, b, c)\n        for p in range(8):\n            # Decode neighborhood from p\n            a = (p >> 2)  1\n            b = (p >> 1)  1\n            c = p  1\n\n            # Determine source and destination nodes from the neighborhood\n            # u = 'ab', v = 'bc'\n            u_idx = 2 * a + b\n            v_idx = 2 * b + c\n\n            # Determine the rule output (the edge label)\n            label = (R >> p)  1\n\n            if label == 0:\n                A0[u_idx, v_idx] = 1\n            else:\n                A1[u_idx, v_idx] = 1\n        \n        memoized_matrices[R] = (A0, A1)\n        return A0, A1\n\n    def count_preimages(y_str, A0, A1):\n        \"\"\"\n        Computes the preimage count for a target string y.\n        \"\"\"\n        y = [int(bit) for bit in y_str]\n        L = len(y)\n\n        if L == 0:\n            return 0\n        \n        # Start with the matrix for the first bit of y\n        if y[0] == 0:\n            M = A0.copy()\n        else:\n            M = A1.copy()\n\n        # Multiply by subsequent matrices\n        for i in range(1, L):\n            if y[i] == 0:\n                M = M @ A0\n            else:\n                M = M @ A1\n        \n        return int(np.trace(M))\n\n    def check_reversibility(R, L, A0, A1):\n        \"\"\"\n        Checks if the rule R is reversible on a ring of length L.\n        \"\"\"\n        num_configs = 1  L\n        for i in range(num_configs):\n            # Generate the binary string for the target configuration y\n            y_str = format(i, f'0{L}b')\n            \n            # Calculate preimage count for this y\n            preimage_count = count_preimages(y_str, A0, A1)\n            \n            # If the count is not 1, the map is not a bijection\n            if preimage_count != 1:\n                return False\n        \n        # If all 2^L configurations have exactly one preimage, it's reversible\n        return True\n\n    # --- Test Case Execution ---\n\n    test_cases = [\n        ('preimage', {'R': 240, 'y': \"10101\"}),\n        ('preimage', {'R': 204, 'y': \"0110\"}),\n        ('preimage', {'R': 90, 'y': \"00\"}),\n        ('preimage', {'R': 30, 'y': \"0000\"}),\n        ('reversibility', {'R': 240, 'L': 6}),\n        ('reversibility', {'R': 170, 'L': 5}),\n        ('reversibility', {'R': 90, 'L': 5}),\n        ('reversibility', {'R': 150, 'L': 5}),\n        ('reversibility', {'R': 204, 'L': 1}),\n        ('reversibility', {'R': 90, 'L': 1}),\n    ]\n\n    results = []\n    for test_type, params in test_cases:\n        R = params['R']\n        A0, A1 = get_adjacency_matrices(R)\n        \n        if test_type == 'preimage':\n            y = params['y']\n            result = count_preimages(y, A0, A1)\n        elif test_type == 'reversibility':\n            L = params['L']\n            result = check_reversibility(R, L, A0, A1)\n        \n        results.append(result)\n\n    # --- Final Output ---\n    # Convert booleans to \"True\" or \"False\" strings as per standard conversion\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}