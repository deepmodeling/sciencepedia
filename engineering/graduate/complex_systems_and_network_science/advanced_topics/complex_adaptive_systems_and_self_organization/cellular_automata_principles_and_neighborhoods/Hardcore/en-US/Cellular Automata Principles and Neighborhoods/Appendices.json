{
    "hands_on_practices": [
        {
            "introduction": "This practice starts with the fundamentals of Elementary Cellular Automata (ECAs). We will directly engage with the Wolfram coding scheme, a concise method for representing the local update rule. By decoding a rule number into its explicit lookup table, you will solidify your understanding of how a simple integer can define a complex dynamical system, and then apply this knowledge to analyze the system's behavior under random initial conditions .",
            "id": "4267330",
            "problem": "Consider an Elementary Cellular Automaton (ECA), defined as a one-dimensional binary-state cellular automaton with neighborhood radius $1$, so that each site $i$ at time $t$ has a neighborhood of three sites $(s_{i-1}(t), s_{i}(t), s_{i+1}(t)) \\in \\{0,1\\}^{3}$, and the next state is determined by a local update function $f: \\{0,1\\}^{3} \\to \\{0,1\\}$. The Wolfram coding convention assigns to each rule number $R \\in \\{0,1,\\dots,255\\}$ an $8$-bit binary string, where the bits from most significant to least significant correspond, in order, to the outputs $f(1,1,1)$, $f(1,1,0)$, $f(1,0,1)$, $f(1,0,0)$, $f(0,1,1)$, $f(0,1,0)$, $f(0,0,1)$, $f(0,0,0)$.\n\nUsing only the definitions above and standard properties of independent Bernoulli random variables, perform the following for the specific rule number $R=110$:\n\n1. Derive the $8$-bit binary representation of $R$ and write the explicit local rule mapping $f(a,b,c)$ for all eight neighborhood patterns $(a,b,c) \\in \\{0,1\\}^{3}$ in the ordering specified. Verify that each mapping corresponds to the correct bit of $R$ under the Wolfram coding convention.\n\n2. Assume the present configuration at time $t$ is an independent and identically distributed (i.i.d.) Bernoulli field with parameter $p$, meaning $P(s_{j}(t)=1)=p$ and the $\\{s_{j}(t)\\}$ are mutually independent across $j$. Using only independence and the local rule $f$, derive the probability $P(s_{i}(t+1)=1)$ as a function of $p$.\n\nReport your final answer as a single simplified analytic expression in $p$. No rounding is required and no units should be included.",
            "solution": "The starting point is the definition of an Elementary Cellular Automaton (ECA) with a local update function $f: \\{0,1\\}^{3} \\to \\{0,1\\}$ that specifies the next state $s_{i}(t+1)$ in terms of the three-site neighborhood $(s_{i-1}(t), s_{i}(t), s_{i+1}(t))$. The Wolfram coding convention provides a mapping from a rule number $R \\in \\{0,1,\\dots,255\\}$ to the outputs of $f$ on the eight possible neighborhood configurations, ordered as $111, 110, 101, 100, 011, 010, 001, 000$ from the most significant to the least significant bit of the $8$-bit binary representation of $R$.\n\nStep $1$: Decode the rule number $R=110$ and write $f$ explicitly.\n\nWe first convert $R=110$ to its $8$-bit binary representation. The value $110$ decomposes as\n$$\n110 = 64 + 32 + 8 + 4 + 2 = 2^{6} + 2^{5} + 2^{3} + 2^{2} + 2^{1}.\n$$\nThus the $8$-bit binary expansion, from most significant bit to least significant bit, is\n$$\n01101110,\n$$\nwhich corresponds to the bit vector\n$$\nb_{7}\\ b_{6}\\ b_{5}\\ b_{4}\\ b_{3}\\ b_{2}\\ b_{1}\\ b_{0} = 0\\ 1\\ 1\\ 0\\ 1\\ 1\\ 1\\ 0,\n$$\nwhere $b_{k} \\in \\{0,1\\}$ and $b_{7}$ is the most significant bit. Under the Wolfram convention, these bits map to the neighborhood configurations in the order\n$$\n111 \\mapsto b_{7},\\quad 110 \\mapsto b_{6},\\quad 101 \\mapsto b_{5},\\quad 100 \\mapsto b_{4},\\quad 011 \\mapsto b_{3},\\quad 010 \\mapsto b_{2},\\quad 001 \\mapsto b_{1},\\quad 000 \\mapsto b_{0}.\n$$\nTherefore, the explicit local rule values are\n- $f(1,1,1) = 0$,\n- $f(1,1,0) = 1$,\n- $f(1,0,1) = 1$,\n- $f(1,0,0) = 0$,\n- $f(0,1,1) = 1$,\n- $f(0,1,0) = 1$,\n- $f(0,0,1) = 1$,\n- $f(0,0,0) = 0$.\n\nThis mapping is a direct verification from the binary representation $01101110$ of $R=110$, consistent with the Wolfram coding order.\n\nStep $2$: Compute $P(s_{i}(t+1)=1)$ under an independent and identically distributed Bernoulli$(p)$ field at time $t$.\n\nUnder the i.i.d. Bernoulli$(p)$ assumption, the probability of observing a specific neighborhood $(a,b,c) \\in \\{0,1\\}^{3}$ at time $t$ is determined solely by the number of ones in the pattern. Let $k(a,b,c) = a + b + c$ be the count of ones. Then\n$$\nP\\big((s_{i-1}(t), s_{i}(t), s_{i+1}(t)) = (a,b,c)\\big) = p^{k(a,b,c)} (1-p)^{3 - k(a,b,c)}.\n$$\nThe next state $s_{i}(t+1)$ equals $1$ precisely for those neighborhoods with $f(a,b,c)=1$. From Step $1$, the neighborhoods yielding $1$ are\n$$\n(1,1,0),\\ (1,0,1),\\ (0,1,1),\\ (0,1,0),\\ (0,0,1).\n$$\nGrouping by the number of ones:\n- The configurations $(1,1,0)$, $(1,0,1)$, $(0,1,1)$ each have $k=2$ ones and contribute a total probability of $3\\, p^{2}(1-p)$.\n- The configurations $(0,1,0)$ and $(0,0,1)$ each have $k=1$ one and contribute a total probability of $2\\, p(1-p)^{2}$.\n\nTherefore,\n$$\nP\\big(s_{i}(t+1)=1\\big) = 3\\, p^{2}(1-p) + 2\\, p(1-p)^{2}.\n$$\nWe simplify this expression:\n$$\n3\\, p^{2}(1-p) + 2\\, p(1-p)^{2} = 3p^{2} - 3p^{3} + 2p - 4p^{2} + 2p^{3} = 2p - p^{2} - p^{3}.\n$$\nThus, the desired probability as a function of $p$ is\n$$\n2p - p^{2} - p^{3}.\n$$\n\nThis result follows directly from the foundational definitions of the Wolfram coding of ECA rules and the independence of Bernoulli random variables across sites.",
            "answer": "$$\\boxed{2 p - p^{2} - p^{3}}$$"
        },
        {
            "introduction": "Moving from the static definition of a rule to its dynamic behavior, this exercise explores how a cellular automaton evolves over time on a finite lattice. You will computationally investigate the profound impact of different boundary conditions—periodic, fixed, and reflective—on the long-term dynamics. This practice highlights how implementation details can fundamentally alter a system's trajectory, leading to different transient phases and limit cycles .",
            "id": "4267346",
            "problem": "Consider a one-dimensional, binary-state Elementary Cellular Automaton (ECA), defined on a finite array of length $n$, with neighborhood radius $r=1$ and a deterministic local update function $f:\\{0,1\\}^3\\to\\{0,1\\}$. The global configuration at discrete time $t$ is denoted by $x(t)\\in\\{0,1\\}^n$. The ECA Rule $54$ is specified by the mapping from triplets $(a,b,c)\\in\\{0,1\\}^3$ to a new state $f(a,b,c)$ as follows:\n$$\nf(1,1,1)=0,\\quad f(1,1,0)=0,\\quad f(1,0,1)=1,\\quad f(1,0,0)=1,\\quad f(0,1,1)=0,\\quad f(0,1,0)=1,\\quad f(0,0,1)=1,\\quad f(0,0,0)=0.\n$$\nThe dependence of ECA dynamics on boundary conditions is to be analyzed by comparing three boundary models applied to the same local rule:\n- Periodic boundary: for all indices $i\\in\\{0,1,\\dots,n-1\\}$, the left neighbor of cell $i$ is $x_{(i-1)\\bmod n}$ and the right neighbor is $x_{(i+1)\\bmod n}$.\n- Fixed boundary: define ghost cells $x_{-1}=0$ and $x_{n}=0$; for $i=0$, the left neighbor is $x_{-1}=0$ and the right neighbor is $x_{1}$; for $i=n-1$, the left neighbor is $x_{n-2}$ and the right neighbor is $x_{n}=0$; for interior indices $1\\le i\\le n-2$, standard neighbors apply.\n- Reflective boundary: define ghost cells $x_{-1}=x_{0}$ and $x_{n}=x_{n-1}$; for $i=0$, the left neighbor is $x_{-1}=x_{0}$ and the right neighbor is $x_{1}$; for $i=n-1$, the left neighbor is $x_{n-2}$ and the right neighbor is $x_{n}=x_{n-1}$; for interior indices $1\\le i\\le n-2$, standard neighbors apply.\n\nStarting from an initial configuration $x(0)$, the dynamics under any fixed boundary condition is a deterministic map on a finite state space $\\{0,1\\}^n$, and hence must eventually enter a periodic orbit. Define the transient length $\\tau$ and cycle length $p$ as follows. Let $t$ be the smallest nonnegative integer such that there exists $t_0<t$ with $x(t)=x(t_0)$. Then the transient length is $\\tau=t_0$ and the cycle length is $p=t-t_0$. Your task is to implement the three boundary conditions, simulate the ECA Rule $54$ from each initial configuration, and compute $(\\tau,p)$ for each boundary condition. For each test case, report the results in the order $[\\tau_{\\mathrm{fixed}},p_{\\mathrm{fixed}},\\tau_{\\mathrm{reflective}},p_{\\mathrm{reflective}},\\tau_{\\mathrm{periodic}},p_{\\mathrm{periodic}}]$.\n\nUse the following test suite of parameter values, where the initial configurations are specified as binary strings; each length must exactly match $n$. All numbers below are integers:\n- Test case $1$: $n=12$, initial configuration `000001111100`.\n- Test case $2$: $n=12$, initial configuration `100000000001`.\n- Test case $3$: $n=1$, initial configuration `1`.\n- Test case $4$: $n=2$, initial configuration `10`.\n- Test case $5$: $n=16$, initial configuration `0011011000110110`.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a comma-separated list in square brackets. That is, the final output must have the format\n$$\n\\text{[[\\tau_{\\mathrm{fixed}},p_{\\mathrm{fixed}},\\tau_{\\mathrm{reflective}},p_{\\mathrm{reflective}},\\tau_{\\mathrm{periodic}},p_{\\mathrm{periodic}}],\\dots]}.\n$$\nNo physical units or angles are involved, so no unit specification is necessary. The final answer for each test case must be a list of integers as described above.",
            "solution": "The user wants to analyze the dynamics of Elementary Cellular Automaton (ECA) Rule $54$ on a finite one-dimensional lattice of size $n$ under three different boundary conditions: fixed, reflective, and periodic. For a given initial configuration, the task is to compute the transient length $\\tau$ and cycle length $p$ of the trajectory for each boundary condition.\n\nThe problem is computationally well-defined and grounded in the standard theory of cellular automata. The state space of the system is finite, with $2^n$ possible configurations. Since the update rule is deterministic, starting from any initial configuration $x(0)$, the system generates a sequence of configurations $x(0), x(1), x(2), \\ldots$. Due to the finiteness of the state space, a configuration must eventually be repeated. Let $t$ be the first time step at which a repeated configuration appears, i.e., $x(t) = x(t_0)$ for some $t_0 < t$, and $t$ is minimal. The problem defines the transient length as $\\tau = t_0$ and the cycle length as $p = t - t_0$.\n\nOur approach is to simulate the automaton's evolution step by step and detect the first occurrence of a repeated state. This is a classic cycle detection problem in a finite state machine. A straightforward and efficient method for the given constraints on $n$ (up to $16$) is to store each generated configuration and the time step at which it appeared.\n\nThe algorithm proceeds as follows:\n1.  **Rule Representation**: The local update rule, Rule $54$, is defined by the problem for all $2^3 = 8$ possible neighborhood states $(x_{i-1}, x_i, x_{i+1})$. We can store this mapping in a dictionary or a hash map for efficient lookup. The key will be a tuple representing the neighborhood triplet, e.g., $(1, 0, 1)$, and the value will be the resulting state of the central cell, e.g., $1$.\n\n2.  **State Evolution**: We will implement a function that computes the configuration at time $t+1$ from the configuration at time $t$. This function takes the current state array, its length $n$, and the type of boundary condition as input.\n    - Inside this function, a new state array for time $t+1$ is initialized.\n    - It iterates through each cell $i$ from $0$ to $n-1$.\n    - For each cell $i$, it determines the state of its left neighbor, the cell itself (center), and its right neighbor. The states of the neighbors are determined according to the specified boundary condition:\n        - **Periodic**: The lattice is treated as a circle. The left neighbor of cell $0$ is cell $n-1$, and the right neighbor of cell $n-1$ is cell $0$. For any cell $i$, the left neighbor is at index $(i-1) \\pmod n$ and the right neighbor is at index $(i+1) \\pmod n$.\n        - **Fixed**: The lattice is extended with two \"ghost\" cells, $x_{-1}$ and $x_{n}$, which are permanently fixed to the state $0$. So, for cell $0$, the left neighbor is $0$, and for cell $n-1$, the right neighbor is $0$.\n        - **Reflective**: The ghost cells mirror the state of their adjacent cell on the lattice. That is, $x_{-1} = x_0$ and $x_n = x_{n-1}$. So, for cell $0$, the left neighbor has the same state as cell $0$, and for cell $n-1$, the right neighbor has the same state as cell $n-1$.\n    - The neighborhood triplet is used as a key to look up the new state of cell $i$ in the Rule $54$ map.\n    - The new state is assigned to the corresponding cell in the new state array.\n    - The function returns the completed new state array.\n\n3.  **Cycle Detection**: We implement a function to find $(\\tau, p)$.\n    - This function initializes a dictionary `history` to store each unique configuration encountered and the time step of its first appearance. The initial configuration $x(0)$ is stored with time step $t=0$.\n    - It then enters a loop, starting from $t=1$. In each iteration, it computes the next configuration $x(t)$ using the state evolution function described above.\n    - Before proceeding to the next step, it checks if the new configuration $x(t)$ is already present in the `history` dictionary. Since NumPy arrays are not hashable, we convert the state array to a tuple to use it as a dictionary key.\n    - If $x(t)$ is found in `history`, a cycle has been detected. The time of its first appearance, $t_0$, is retrieved from the dictionary. The transient length is $\\tau = t_0$, and the cycle length is $p = t - t_0$. The function returns this pair $(\\tau, p)$.\n    - If $x(t)$ is not in `history`, it is added to the dictionary with the current time step $t$, and the simulation continues with this new state.\n\n4.  **Main Routine**: The main part of the program iterates through the provided test cases. For each test case, specified by an initial configuration string and its length $n$, it calls the cycle detection function three times, once for each boundary condition ('fixed', 'reflective', 'periodic'). The resulting six integer values—$(\\tau, p)$ for each of the three conditions—are collected and formatted into the required output string. The final output is a list of lists, with each inner list corresponding to a test case.\n\nThis complete, deterministic procedure guarantees finding the correct transient and cycle lengths for each scenario as defined in the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the ECA Rule 54 dynamics problem for a suite of test cases.\n    \"\"\"\n\n    # Rule 54 is defined by the mapping from a neighborhood (left, center, right)\n    # to the new state of the center cell.\n    # The rule number 54 comes from the binary string 00110110, which corresponds\n    # to the outputs for neighborhoods (1,1,1) through (0,0,0) in that order.\n    RULE_54_MAP = {\n        (1, 1, 1): 0, (1, 1, 0): 0, (1, 0, 1): 1, (1, 0, 0): 1,\n        (0, 1, 1): 0, (0, 1, 0): 1, (0, 0, 1): 1, (0, 0, 0): 0\n    }\n\n    def get_next_state(state: np.ndarray, boundary: str) -> np.ndarray:\n        \"\"\"\n        Computes the next state of the cellular automaton for a given configuration\n        and boundary condition.\n\n        Args:\n            state: A 1D numpy array representing the current configuration.\n            boundary: A string specifying the boundary condition ('fixed', 'reflective', 'periodic').\n\n        Returns:\n            A 1D numpy array for the next configuration.\n        \"\"\"\n        n = len(state)\n        new_state = np.empty(n, dtype=int)\n\n        for i in range(n):\n            center = state[i]\n            \n            if boundary == 'periodic':\n                left = state[(i - 1 + n) % n]\n                right = state[(i + 1) % n]\n            elif boundary == 'fixed':\n                left = state[i - 1] if i > 0 else 0\n                right = state[i + 1] if i < n - 1 else 0\n            elif boundary == 'reflective':\n                left = state[i - 1] if i > 0 else state[0]\n                right = state[i + 1] if i < n - 1 else state[n - 1]\n            else:\n                raise ValueError(\"Invalid boundary condition specified.\")\n\n            triplet = (left, center, right)\n            new_state[i] = RULE_54_MAP[triplet]\n\n        return new_state\n\n    def find_cycle(initial_state_str: str, boundary: str) -> tuple[int, int]:\n        \"\"\"\n        Simulates the ECA and finds the transient length (tau) and cycle length (p).\n\n        Args:\n            initial_state_str: The initial configuration as a binary string.\n            boundary: The boundary condition to apply.\n\n        Returns:\n            A tuple (tau, p).\n        \"\"\"\n        initial_state = np.array([int(c) for c in initial_state_str], dtype=int)\n        \n        # history stores {config_tuple: time_step}\n        history = {tuple(initial_state): 0}\n        current_state = initial_state\n        time = 0\n\n        while True:\n            time += 1\n            next_state = get_next_state(current_state, boundary)\n            next_state_tuple = tuple(next_state)\n\n            if next_state_tuple in history:\n                t0 = history[next_state_tuple]\n                tau = t0\n                p = time - t0\n                return tau, p\n            \n            history[next_state_tuple] = time\n            current_state = next_state\n\n    test_cases = [\n        (12, \"000001111100\"),\n        (12, \"100000000001\"),\n        (1, \"1\"),\n        (2, \"10\"),\n        (16, \"0011011000110110\"),\n    ]\n\n    all_results = []\n    for n, initial_config in test_cases:\n        case_results = []\n        \n        # Fixed boundary\n        tau_f, p_f = find_cycle(initial_config, 'fixed')\n        case_results.extend([tau_f, p_f])\n\n        # Reflective boundary\n        tau_r, p_r = find_cycle(initial_config, 'reflective')\n        case_results.extend([tau_r, p_r])\n\n        # Periodic boundary\n        tau_p, p_p = find_cycle(initial_config, 'periodic')\n        case_results.extend([tau_p, p_p])\n        \n        all_results.append(case_results)\n\n    # Format the final output string as specified\n    case_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice introduces a powerful analytical tool from symbolic dynamics, the de Bruijn graph, for a deeper analysis of CA properties. Instead of relying on direct simulation, you will construct this graph to answer sophisticated questions about the global mapping, such as counting the number of predecessor states (preimages) for any given configuration. This method provides a direct pathway to determining fundamental properties like reversibility, revealing the global consequences of the local rule in a rigorous manner .",
            "id": "3104885",
            "problem": "You are given a one-dimensional, binary, radius-$1$ cellular automaton defined on a periodic ring (circular boundary) of length $L$, specified by a local rule $f:\\{0,1\\}^3 \\to \\{0,1\\}$ acting on neighborhoods $(a,b,c)$ as $y_i = f(x_{i-1}, x_i, x_{i+1})$, with indices taken modulo $L$. The local rule is encoded by its Wolfram rule number $R \\in \\{0,1,\\dots,255\\}$, where the output for the neighborhood $(a,b,c)$ is given by the bit of $R$ at position $p = 4a + 2b + c$, that is, $f(a,b,c) = \\left\\lfloor \\frac{R}{2^p} \\right\\rfloor \\pmod 2$.\n\nYour task is to derive, from first principles, the de Bruijn graph for the given local rule and use it to compute one-step preimage counts of target configurations, and to detect reversibility on a finite ring of given length. The de Bruijn graph for a radius-$1$ binary cellular automaton has a node set corresponding to all binary words of length $2$, that is, $V = \\{00,01,10,11\\}$, and directed edges corresponding to all binary words of length $3$, that is, from node $ab$ to node $bc$ for each triple $(a,b,c) \\in \\{0,1\\}^3$. Each edge is labeled by the local rule output $f(a,b,c) \\in \\{0,1\\}$. Define the adjacency matrices $A_0$ and $A_1$ of size $4 \\times 4$ over the integers, where $(A_\\ell)_{u,v} = 1$ if and only if there is an edge $u \\to v$ labeled $\\ell \\in \\{0,1\\}$, and $(A_\\ell)_{u,v} = 0$ otherwise.\n\nFundamental base to use:\n- Cellular automata definition: $y_i = f(x_{i-1}, x_i, x_{i+1})$ with $f$ a local rule and indices modulo $L$.\n- De Bruijn graph construction for radius-$1$: nodes are length-$2$ words, edges are length-$3$ words, with overlap and edge labels determined by $f$.\n- Walk-counting via adjacency matrices: the number of closed walks of length $L$ with a fixed label sequence equals the trace of a product of adjacency matrices.\n\nTarget derivations and algorithm:\n- Construct $A_0$ and $A_1$ from the given $R$ by enumerating all $(a,b,c) \\in \\{0,1\\}^3$.\n- For a given target word $y \\in \\{0,1\\}^L$, compute the preimage count under one step of the global rule with periodic boundary as\n$$\\text{preimages}(y) = \\operatorname{trace}\\!\\left(A_{y_0} A_{y_1} \\cdots A_{y_{L-1}}\\right),$$\nwhere $y_i$ is the $i$-th bit of $y$ and $A_{y_i}$ is $A_0$ if $y_i=0$ and $A_1$ if $y_i=1$.\n- For reversibility on the finite ring of length $L$, the global map is a bijection if and only if for every target $y \\in \\{0,1\\}^L$ the preimage count is exactly $1$. Use the above formula to test all $2^L$ target words.\n\nUnits and formatting:\n- There are no physical quantities; all outputs are purely mathematical and logical. All numerically quantified outputs must be integers or booleans.\n- Angles are not used.\n- Percentages are not used.\n\nTest suite and required outputs:\nImplement a program that constructs $A_0$ and $A_1$ for the given rule and produces the following results in order. For each preimage-count case, output the integer count. For each reversibility case, output a boolean indicating whether the global map on a ring of the specified length is a bijection (True means reversible, False means not reversible).\n\nTest cases:\n1. Preimage count for $R=240$ and $y = \\text{\"10101\"}$ of length $L = 5$.\n2. Preimage count for $R=204$ and $y = \\text{\"0110\"}$ of length $L = 4$.\n3. Preimage count for $R=90$ and $y = \\text{\"00\"}$ of length $L = 2$.\n4. Preimage count for $R=30$ and $y = \\text{\"0000\"}$ of length $L = 4$.\n5. Reversibility for $R=240$ on ring length $L = 6$.\n6. Reversibility for $R=170$ on ring length $L = 5$.\n7. Reversibility for $R=90$ on ring length $L = 5$.\n8. Reversibility for $R=150$ on ring length $L = 5$.\n9. Reversibility for $R=204$ on ring length $L = 1$.\n10. Reversibility for $R=90$ on ring length $L = 1$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...,result10]\") in the exact order of the above test cases.",
            "solution": "The problem posed is valid. It is scientifically grounded in the established theory of cellular automata and symbolic dynamics, is well-posed with all necessary definitions and constraints, and is expressed in objective, formal language. It presents a standard, non-trivial problem that can be solved algorithmically using the provided principles.\n\nA one-dimensional cellular automaton (CA) updates the state of each cell on a lattice based on the states in a local neighborhood. For a radius-$1$ CA on a periodic ring of length $L$, the state $y_i$ of cell $i$ at the next time step is a function $f$ of the states of cells $i-1$, $i$, and $i+1$ at the current time step, denoted by the configuration $x = (x_0, x_1, \\dots, x_{L-1})$. The global evolution of the entire configuration from $x$ to $y$ is determined by applying the local rule $f$ simultaneously at all positions: $y_i = f(x_{i-1}, x_i, x_{i+1})$, where indices are taken modulo $L$.\n\nThe dynamics of such a system can be analyzed using a de Bruijn graph. For a radius-$1$ binary CA, the de Bruijn graph is constructed as follows. The nodes of the graph, $V$, represent all possible blocks of states of length $2r=2$, where $r=1$ is the radius. Thus, the node set is $V = \\{00, 01, 10, 11\\}$. A directed edge exists from node $u=ab$ to node $v=bc$ for every possible state triple $(a,b,c) \\in \\{0,1\\}^3$. This edge corresponds to the block of states $abc$ of length $2r+1=3$. Each edge is labeled by the output of the local rule for its corresponding block, $\\ell = f(a,b,c)$.\n\nA configuration $x = (x_0, x_1, \\dots, x_{L-1})$ on a ring of length $L$ can be represented as a sequence of overlapping blocks of length $2$: $(x_0x_1), (x_1x_2), \\dots, (x_{L-2}x_{L-1}), (x_{L-1}x_0)$. This corresponds to a closed walk of length $L$ in the de Bruijn graph: $x_0x_1 \\to x_1x_2 \\to \\dots \\to x_{L-1}x_0$. A configuration $x$ is a preimage of a target configuration $y = (y_0, y_1, \\dots, y_{L-1})$ if the sequence of local rule outputs matches $y$. In the graph representation, this means the sequence of edge labels along the closed walk corresponding to $x$ must be precisely $(y_0, y_1, \\dots, y_{L-1})$.\n\nTo count the number of such walks, we introduce labeled adjacency matrices. Let the nodes $\\{00, 01, 10, 11\\}$ be indexed by $u, v \\in \\{0, 1, 2, 3\\}$. We define two $4 \\times 4$ matrices, $A_0$ and $A_1$. The entry $(A_\\ell)_{u,v}$ is $1$ if there is an edge from node $u$ to node $v$ with label $\\ell \\in \\{0,1\\}$, and $0$ otherwise. The Wolfram rule number $R$ encodes the function $f$. For each of the $2^3=8$ possible neighborhoods $(a,b,c)$, we can determine its integer representation $p=4a+2b+c$. The rule output is then given by the $p$-th bit of $R$, $f(a,b,c) = (R \\gg p) \\& 1$. This output $\\ell$ determines which matrix, $A_0$ or $A_1$, gets an entry. The source node is $u=2a+b$ and the destination node is $v=2b+c$. Thus, we set $(A_\\ell)_{2a+b, 2b+c} = 1$.\n\nThe number of paths of length $L$ with a specific label sequence $y=(y_0, \\dots, y_{L-1})$ is found by multiplying the corresponding adjacency matrices. The matrix product $M_y = A_{y_0} A_{y_1} \\cdots A_{y_{L-1}}$ contains entries $(M_y)_{u,v}$ that count the number of walks of length $L$ starting at node $u$, ending at node $v$, and having the label sequence $y$. To find the number of preimages of $y$, we need to count the total number of *closed* walks with this label sequence. This is the sum of the diagonal elements of $M_y$, which is its trace:\n$$ \\text{preimages}(y) = \\sum_{u=0}^{3} (M_y)_{u,u} = \\operatorname{trace}(M_y) $$\n\nA CA's global map is considered reversible on a ring of length $L$ if it is a bijection on the set of all $2^L$ configurations. For a function on a finite set, being bijective is equivalent to being injective and surjective. This means that for every target configuration $y$, there must exist exactly one preimage configuration $x$. Therefore, a rule is reversible on a ring of length $L$ if and only if $\\text{preimages}(y) = 1$ for all $2^L$ possible target configurations $y$. The algorithm to check for reversibility involves iterating through every possible target string $y \\in \\{0,1\\}^L$, computing its preimage count using the trace formula, and verifying that the count is exactly $1$ in every case. If any count differs from $1$, the rule is not reversible.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cellular automata problem by constructing de Bruijn graph\n    adjacency matrices and using them to count preimages and check reversibility.\n    \"\"\"\n\n    # --- Helper Functions ---\n\n    memoized_matrices = {}\n\n    def get_adjacency_matrices(R):\n        \"\"\"\n        Constructs the labeled adjacency matrices A0 and A1 for a given\n        Wolfram rule number R.\n        \"\"\"\n        if R in memoized_matrices:\n            return memoized_matrices[R]\n\n        # Nodes are '00', '01', '10', '11'. We map them to indices 0, 1, 2, 3.\n        # node_map = {'00': 0, '01': 1, '10': 2, '11': 3}\n        # which corresponds to int(s, 2)\n        A0 = np.zeros((4, 4), dtype=np.int64)\n        A1 = np.zeros((4, 4), dtype=np.int64)\n\n        # Iterate through all 8 possible neighborhoods (a, b, c)\n        for p in range(8):\n            # Decode neighborhood from p\n            a = (p >> 2) & 1\n            b = (p >> 1) & 1\n            c = p & 1\n\n            # Determine source and destination nodes from the neighborhood\n            # u = 'ab', v = 'bc'\n            u_idx = 2 * a + b\n            v_idx = 2 * b + c\n\n            # Determine the rule output (the edge label)\n            label = (R >> p) & 1\n\n            if label == 0:\n                A0[u_idx, v_idx] = 1\n            else:\n                A1[u_idx, v_idx] = 1\n        \n        memoized_matrices[R] = (A0, A1)\n        return A0, A1\n\n    def count_preimages(y_str, A0, A1):\n        \"\"\"\n        Computes the preimage count for a target string y.\n        \"\"\"\n        y = [int(bit) for bit in y_str]\n        L = len(y)\n\n        if L == 0:\n            return 0\n        \n        # Start with the matrix for the first bit of y\n        if y[0] == 0:\n            M = A0.copy()\n        else:\n            M = A1.copy()\n\n        # Multiply by subsequent matrices\n        for i in range(1, L):\n            if y[i] == 0:\n                M = M @ A0\n            else:\n                M = M @ A1\n        \n        return int(np.trace(M))\n\n    def check_reversibility(R, L, A0, A1):\n        \"\"\"\n        Checks if the rule R is reversible on a ring of length L.\n        \"\"\"\n        num_configs = 1 << L\n        for i in range(num_configs):\n            # Generate the binary string for the target configuration y\n            y_str = format(i, f'0{L}b')\n            \n            # Calculate preimage count for this y\n            preimage_count = count_preimages(y_str, A0, A1)\n            \n            # If the count is not 1, the map is not a bijection\n            if preimage_count != 1:\n                return False\n        \n        # If all 2^L configurations have exactly one preimage, it's reversible\n        return True\n\n    # --- Test Case Execution ---\n\n    test_cases = [\n        ('preimage', {'R': 240, 'y': \"10101\"}),\n        ('preimage', {'R': 204, 'y': \"0110\"}),\n        ('preimage', {'R': 90, 'y': \"00\"}),\n        ('preimage', {'R': 30, 'y': \"0000\"}),\n        ('reversibility', {'R': 240, 'L': 6}),\n        ('reversibility', {'R': 170, 'L': 5}),\n        ('reversibility', {'R': 90, 'L': 5}),\n        ('reversibility', {'R': 150, 'L': 5}),\n        ('reversibility', {'R': 204, 'L': 1}),\n        ('reversibility', {'R': 90, 'L': 1}),\n    ]\n\n    results = []\n    for test_type, params in test_cases:\n        R = params['R']\n        A0, A1 = get_adjacency_matrices(R)\n        \n        if test_type == 'preimage':\n            y = params['y']\n            result = count_preimages(y, A0, A1)\n        elif test_type == 'reversibility':\n            L = params['L']\n            result = check_reversibility(R, L, A0, A1)\n        \n        results.append(result)\n\n    # --- Final Output ---\n    # Convert booleans to \"True\" or \"False\" strings as per standard conversion\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}