{
    "hands_on_practices": [
        {
            "introduction": "在基于主体的建模（ABM）中，一个最基本却又常常被忽视的决策是如何调度主体的更新。同步（所有主体同时更新）和异步（主体顺序更新）这两种模式，即便在主体层面规则完全相同的情况下，也可能导致系统宏观行为的巨大差异。这个练习  提供了一个极简的可解范例，清晰地揭示了这一原理，强调了更新机制的选择是一个关键的建模决策，而不仅仅是技术实现的细节。",
            "id": "4113495",
            "problem": "考虑一个复杂自适应系统建模领域中的基于主体的模型（ABM），该模型包含两个主体，标记为 $i \\in \\{1,2\\}$，位于一个由连接这两个主体的一条边组成的无向网络上。在离散时间 $t \\in \\mathbb{Z}_{\\ge 0}$，每个主体都有一个二元状态 $x_i(t) \\in \\{0,1\\}$。该ABM采用确定性阈值决策规则：一个主体在下一时间步变为活动状态，当且仅当其活动邻居的比例达到或超过其阈值。形式上，对于任意主体 $i$，令 $N_i$ 表示 $i$ 的邻居集合，令 $m_i(\\tau) = \\frac{1}{|N_i|} \\sum_{j \\in N_i} x_j(\\tau)$ 为在更新参考时间 $\\tau$ 时活动邻居的比例。主体 $i$ 的阈值参数为 $\\theta_i \\in [0,1]$，其个体更新规则为\n$$\nx_i(\\text{next}) = \n\\begin{cases}\n1,   \\text{if } m_i(\\tau) \\ge \\theta_i, \\\\\n0,   \\text{if } m_i(\\tau)  \\theta_i.\n\\end{cases}\n$$\n考虑两种更新机制：\n\n- 同步更新：两个主体都使用时间 $t$ 的状态计算 $m_i(t)$，并根据阈值规则同时设置 $x_i(t+1)$。\n- 按固定顺序 $(1,2)$ 的序贯更新：主体1首先使用 $m_1(t)$ 更新以设置 $x_1(t+1)$，然后主体2使用 $m_2(t+1)$ 更新，其中 $m_2(t+1)$ 是根据主体1更新后最新的可用邻居状态计算的。\n\n假设初始条件为 $x_1(0) = 0$ 和 $x_2(0) = 1$，阈值为 $\\theta_1 = \\frac{1}{2}$ 和 $\\theta_2 = 1$。由于网络只有一条边，每个主体 $i$ 的 $m_i(\\tau)$ 等于其邻居在指定参考时间的状态。将有限时间范围 $T$ 内的轨迹差异定义为两种机制轨迹之间的累积汉明距离，\n$$\nD(T) = \\sum_{t=0}^{T} \\left( \\left| x_1^{\\text{sync}}(t) - x_1^{\\text{seq}}(t) \\right| + \\left| x_2^{\\text{sync}}(t) - x_2^{\\text{seq}}(t) \\right| \\right),\n$$\n其中 $x_i^{\\text{sync}}(t)$ 和 $x_i^{\\text{seq}}(t)$ 分别表示在同步和序贯更新下，主体 $i$ 在时间 $t$ 的状态。\n\n计算时间范围 $T = 10$ 时的 $D(T)$。将最终答案以单个实数形式给出。本题无需四舍五入。",
            "solution": "该问题提法明确，科学上基于基于主体的模型（ABM）和复杂自适应系统理论，并包含得出唯一解所需的所有信息。验证标准已满足。\n\n任务是计算一个双主体系统在同步和序贯更新机制下，时间范围 $T=10$ 内状态轨迹之间的累积汉明距离 $D(T)$。我们首先分析主体的更新规则，然后模拟两种机制下的轨迹，最后计算所需的总和。\n\n首先，我们形式化主体 $i \\in \\{1, 2\\}$ 的更新规则，其阈值分别为 $\\theta_1 = \\frac{1}{2}$ 和 $\\theta_2 = 1$。该网络由连接两个主体的一条边组成，因此主体1的邻居集合为 $N_1 = \\{2\\}$，主体2的邻居集合为 $N_2 = \\{1\\}$。主体 $i$ 的活动邻居比例为 $m_i(\\tau) = \\frac{1}{|N_i|} \\sum_{j \\in N_i} x_j(\\tau)$。这可以简化为 $m_1(\\tau) = x_2(\\tau)$ 和 $m_2(\\tau) = x_1(\\tau)$。\n\n个体更新规则为：如果 $m_i(\\tau) \\ge \\theta_i$，则 $x_i(\\text{next}) = 1$，否则 $x_i(\\text{next}) = 0$。鉴于二元状态空间 $x_i \\in \\{0, 1\\}$，每个主体的规则变为：\n- 对于主体1：$x_1(\\text{next}) = 1$ 当且仅当 $x_2(\\tau) \\ge \\theta_1 = \\frac{1}{2}$。这意味着只有当 $x_2(\\tau)=1$ 时，$x_1(\\text{next}) = 1$。因此，规则是 $x_1(\\text{next}) = x_2(\\tau)$。\n- 对于主体2：$x_2(\\text{next}) = 1$ 当且仅当 $x_1(\\tau) \\ge \\theta_2 = 1$。这意味着只有当 $x_1(\\tau)=1$ 时，$x_2(\\text{next}) = 1$。因此，规则是 $x_2(\\text{next}) = x_1(\\tau)$。\n\n现在我们从初始条件 $(x_1(0), x_2(0)) = (0, 1)$ 开始，生成两种更新机制下的轨迹。\n\n**1. 同步更新轨迹**\n在同步更新下，两个主体的下一状态都是基于系统在时间 $t$ 的当前状态计算的。规则如下：\n$$\n\\begin{cases}\nx_1^{\\text{sync}}(t+1) = x_2^{\\text{sync}}(t) \\\\\nx_2^{\\text{sync}}(t+1) = x_1^{\\text{sync}}(t)\n\\end{cases}\n$$\n我们计算在 $t \\in \\{0, 1, \\dots, 10\\}$ 时的状态向量 $(x_1^{\\text{sync}}(t), x_2^{\\text{sync}}(t))$：\n- $t=0$: $(0, 1)$ (初始条件)\n- $t=1$: $(x_1(1), x_2(1)) = (x_2(0), x_1(0)) = (1, 0)$\n- $t=2$: $(x_1(2), x_2(2)) = (x_2(1), x_1(1)) = (0, 1)$\n- $t=3$: $(x_1(3), x_2(3)) = (x_2(2), x_1(2)) = (1, 0)$\n系统以周期为 $2$ 进行振荡。当 $t$ 为偶数时，状态为 $(0, 1)$；当 $t$ 为奇数时，状态为 $(1, 0)$。\n\n**2. 序贯更新轨迹（顺序 1, 2）**\n在按顺序 $(1, 2)$ 的序贯更新下，主体1首先基于时间 $t$ 的状态更新其在时间 $t+1$ 的状态。然后，主体2使用最新的状态（包括主体1已更新的状态）来更新其在时间 $t+1$ 的状态。\n从时间 $t$ 到 $t+1$ 的一个时间步的规则如下：\n$$\n\\begin{cases}\nx_1^{\\text{seq}}(t+1) = x_2^{\\text{seq}}(t) \\\\\nx_2^{\\text{seq}}(t+1) = x_1^{\\text{seq}}(t+1)\n\\end{cases}\n$$\n我们计算在 $t \\in \\{0, 1, \\dots, 10\\}$ 时的状态向量 $(x_1^{\\text{seq}}(t), x_2^{\\text{seq}}(t))$：\n- $t=0$: $(0, 1)$ (初始条件)\n- $t=1$:\n  - 主体1更新：$x_1^{\\text{seq}}(1) = x_2^{\\text{seq}}(0) = 1$。\n  - 主体2更新：$x_2^{\\text{seq}}(1) = x_1^{\\text{seq}}(1) = 1$。\n  - 在 $t=1$ 时的状态是 $(1, 1)$。\n- $t=2$:\n  - 主体1更新：$x_1^{\\text{seq}}(2) = x_2^{\\text{seq}}(1) = 1$。\n  - 主体2更新：$x_2^{\\text{seq}}(2) = x_1^{\\text{seq}}(2) = 1$。\n  - 在 $t=2$ 时的状态是 $(1, 1)$。\n系统在 $t=1$ 时达到不动点 $(1, 1)$。因此，对于所有 $t \\ge 1$，状态均为 $(x_1^{\\text{seq}}(t), x_2^{\\text{seq}}(t)) = (1, 1)$。\n\n**3. 计算轨迹差异 $D(10)$**\n轨迹差异定义为 $D(T) = \\sum_{t=0}^{T} d(t)$，其中每一步的汉明距离为 $d(t) = |x_1^{\\text{sync}}(t) - x_1^{\\text{seq}}(t)| + |x_2^{\\text{sync}}(t) - x_2^{\\text{seq}}(t)|$。我们计算从 $t=0$ 到 $10$ 每个 $t$ 的 $d(t)$。\n\n- 对于 $t=0$：\n  - $x^{\\text{sync}}(0) = (0, 1)$ 且 $x^{\\text{seq}}(0) = (0, 1)$。\n  - $d(0) = |0-0| + |1-1| = 0$。\n\n- 对于 $t \\ge 1$：\n  - 序贯轨迹是固定的：$x^{\\text{seq}}(t) = (1, 1)$。\n  - 同步轨迹交替变化。\n  - 对于奇数 $t \\in \\{1, 3, 5, 7, 9\\}$：\n    - $x^{\\text{sync}}(t) = (1, 0)$。\n    - $d(t) = |1-1| + |0-1| = 0 + 1 = 1$。\n  - 对于偶数 $t \\in \\{2, 4, 6, 8, 10\\}$：\n    - $x^{\\text{sync}}(t) = (0, 1)$。\n    - $d(t) = |0-1| + |1-1| = 1 + 0 = 1$。\n\n因此，我们有 $d(0)=0$ 且对于所有 $t \\in \\{1, 2, \\dots, 10\\}$，都有 $d(t)=1$。\n\n最后，我们将这些值相加来求 $D(10)$：\n$$\nD(10) = \\sum_{t=0}^{10} d(t) = d(0) + \\sum_{t=1}^{10} d(t)\n$$\n$$\nD(10) = 0 + (d(1) + d(2) + \\dots + d(10))\n$$\n$$\nD(10) = 0 + \\sum_{t=1}^{10} 1 = 10 \\times 1 = 10\n$$\n在时间范围 $T=10$ 内的累积汉明距离是 $10$。",
            "answer": "$$\n\\boxed{10}\n$$"
        },
        {
            "introduction": "构建复杂的ABM很容易出错，因此一个至关重要的实践是模型的验证与确认（VV），即确保编码实现的模型与其设计意图一致。这个练习  将指导你设计单元测试，并运用守恒律（不变量）来验证模型的完整性。通过检查诸如总财富之类的量是否在模拟中保持守恒，我们可以极大地增强对模型实现的信心。",
            "id": "4284335",
            "problem": "考虑一个环形网络上的基于代理的模型，其中每个代理由 $i \\in \\{0,1,\\dots,N-1\\}$ 索引，并在离散时间 $t \\in \\mathbb{N}$ 时具有状态 $s_i(t) = (w_i(t), x_i(t))$。网络中代理 $i$ 与代理 $(i+1) \\pmod N$ 之间存在无向边。每个时间步包含对所有 $N$ 条边的一次完整扫描，按 $i=0$ 到 $i=N-1$ 的顺序进行成对交互，每对 $(i, (i+1) \\pmod N)$ 在每次扫描中交互一次。状态更新使用以下基本定义，用于代理 $i$ 和 $j$（其中 $j = (i+1) \\pmod N$）之间的成对交互：\n\n- 带参数 $\\gamma \\in [0,1]$ 的财富交换规则：\n  - 如果 $\\gamma = 0$，则 $(w_i', w_j') = (w_i, w_j)$。\n  - 否则，如果 $w_i = w_j$，则 $(w_i', w_j') = (w_i, w_j)$。\n  - 否则，如果 $\\gamma = 1$，则 $(w_i', w_j') = (w_j, w_i)$。\n  - 否则，$(w_i', w_j') = \\left(w_i + \\gamma (w_j - w_i),\\ w_j - \\gamma (w_j - w_i)\\right)$。\n\n- 带参数 $\\mu \\in [0,1]$ 和阈值 $\\theta \\ge 0$ 的观点更新规则：\n  - 如果 $\\mu = 0$，则 $(x_i', x_j') = (x_i, x_j)$。\n  - 否则，如果 $|x_i - x_j| \\le \\theta$，则 $(x_i', x_j') = (x_i, x_j)$。\n  - 否则，$(x_i', x_j') = \\left(x_i + \\mu (x_j - x_i),\\ x_j + \\mu (x_i - x_j)\\right)$。\n\n您必须为这些代理状态更新和交互规则设计单元测试，以达到指定的分支覆盖率和不变性属性。对您的更新实现进行插桩，以记录在整个测试套件中以下哪些不同分支至少被执行了一次：\n\n- 财富分支：\"gamma zero no-op\"、\"equal wealth no-op\"、\"gamma one full swap\"、\"regular exchange\"。\n- 观点分支：\"mu zero no-op\"、\"threshold no-op\"、\"regular update\"。\n\n根据上述定义，推导并验证以下不变性属性对于任何单次完整扫描（$T=1$）均成立：\n- 总财富不变性：$$\\sum_{i=0}^{N-1} w_i(1) = \\sum_{i=0}^{N-1} w_i(0)$$\n- 财富非负不变性：给定所有 $i$ 都有 $w_i(0) \\ge 0$，则所有 $i$ 都有 $w_i(1) \\ge 0$。\n- 观点范围不变性：给定所有 $i$ 都有 $x_i(0) \\in [-1,1]$，则所有 $i$ 都有 $x_i(1) \\in [-1,1]$。\n\n您的程序必须严格按照所述实现更新规则，并对分支执行进行插桩，以计算分支覆盖率，其定义为\n$$\n\\text{覆盖率} = \\frac{\\text{在套件中命中的不同分支数量}}{\\text{枚举的所有不同分支总数}}。\n$$\n\n测试套件：\n使用以下参数集。对于每个测试用例 $k$，在环形网络上使用给定的初始状态和参数执行恰好一次完整扫描（$T=1$）。所有数组均按代理索引 $i=0,1,\\dots,N-1$ 的顺序列出。\n\n- 用例 $\\mathrm{A}$ (正常路径)：$N=4$, $\\gamma=0.5$, $\\mu=0.5$, $\\theta=0.0$, $w(0)=[1,0,2,3]$, $x(0)=[-0.5,0.5,-1.0,1.0]$。\n- 用例 $\\mathrm{B}$ (财富 gamma 为零，观点阈值无操作)：$N=4$, $\\gamma=0.0$, $\\mu=0.4$, $\\theta=0.5$, $w(0)=[1,2,3,4]$, $x(0)=[0.1,0.1,0.1,0.1]$。\n- 用例 $\\mathrm{C}$ (财富相等分支，mu 为零无操作)：$N=4$, $\\gamma=0.5$, $\\mu=0.0$, $\\theta=0.0$, $w(0)=[2,2,3,4]$, $x(0)=[-0.2,0.6,-0.6,0.2]$。\n- 用例 $\\mathrm{D}$ (gamma 为一完全交换，观点极端更新)：$N=4$, $\\gamma=1.0$, $\\mu=1.0$, $\\theta=0.0$, $w(0)=[5,1,5,1]$, $x(0)=[-1.0,1.0,-1.0,1.0]$。\n- 用例 $\\mathrm{E}$ (网络规模边界)：$N=1$, $\\gamma=0.7$, $\\mu=0.3$, $\\theta=0.1$, $w(0)=[3.0]$, $x(0)=[0.0]$。\n\n每个测试用例所需的布尔结果：当且仅当该用例同时满足所有三个不变性（总财富不变性、财富非负不变性和观点范围不变性）时，不变性属性才算满足。每个用例返回一个布尔值表示此结果。\n\n要求的覆盖率目标：对于整个测试套件，计算如上定义的分支覆盖率，并四舍五入到小数点后 $3$ 位。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须包含五个布尔值（每个测试用例一个），后跟一个浮点数，即整个套件实现的分支覆盖率，四舍五入到小数点后三位。例如：`[b_A,b_B,b_C,b_D,b_E,c]`，其中每个 $b_\\cdot$ 是一个布尔值，$c$ 是一个四舍五入到小数点后 $3$ 位的浮点数。不应打印任何其他文本。",
            "solution": "该问题要求在环形网络上实现并测试一个特定的基于代理的模型。任务的核心是编写一个程序，该程序能对给定的测试套件进行模型仿真，验证某些不变性属性，并计算实现的后验分支覆盖率。\n\n首先，我将对指定的不变性属性进行形式化分析，以确认它们在给定更新规则下的数学有效性。这为后续的计算验证提供了理论基础。系统在时间 $t$ 的状态由财富向量 $w(t) = [w_0(t), \\dots, w_{N-1}(t)]$ 和观点向量 $x(t) = [x_0(t), \\dots, x_{N-1}(t)]$ 给出。单个时间步 $t=1$ 由代理 $(i, (i+1) \\bmod N)$（其中 $i=0, 1, \\dots, N-1$）之间的一系列 $N$ 次成对交互组成。\n\n**不变性属性分析**\n\n1.  **总财富不变性：** $\\sum_{k=0}^{N-1} w_k(1) = \\sum_{k=0}^{N-1} w_k(0)$。\n    让我们考虑代理 $i$ 和 $j$ 之间的一次成对交互。设它们交互前的财富为 $w_i$ 和 $w_j$，交互后为 $w_i'$ 和 $w_j'$。\n    - 如果 $\\gamma = 0$ 或 $w_i = w_j$，则 $w_i' = w_i$ 且 $w_j' = w_j$。因此，$w_i' + w_j' = w_i + w_j$。\n    - 如果 $\\gamma = 1$，则 $w_i' = w_j$ 且 $w_j' = w_i$。因此，$w_i' + w_j' = w_j + w_i = w_i + w_j$。\n    - 对于常规交换情况，$w_i' = w_i + \\gamma (w_j - w_i)$ 且 $w_j' = w_j - \\gamma (w_j - w_i)$。将它们相加可得：\n    $$w_i' + w_j' = \\left(w_i + \\gamma (w_j - w_i)\\right) + \\left(w_j - \\gamma (w_j - w_i)\\right) = w_i + w_j.$$\n    在所有情况下，交互对的财富总和是守恒的。从 $t=0$ 到 $t=1$ 的一次完整扫描是这样一系列成对交互的序列。由于每次交互都保持局部总和守恒，因此在整个扫描过程中，所有代理的总财富总和必须是守恒的。因此，总财富不变性属性成立。\n\n2.  **财富非负不变性：** 给定所有 $k$ 都有 $w_k(0) \\ge 0$，则所有 $k$ 都有 $w_k(1) \\ge 0$。\n    所有测试用例的初始条件都提供了 $w_k(0) \\ge 0$。我们需要证明在任何交互之后，财富都保持非负。\n    - 无操作和交换情况显然保持非负性。\n    - 对于常规交换，新的财富为：\n    $$w_i' = w_i + \\gamma (w_j - w_i) = (1-\\gamma)w_i + \\gamma w_j$$\n    $$w_j' = w_j - \\gamma (w_j - w_i) = w_j + \\gamma (w_i - w_j) = (1-\\gamma)w_j + \\gamma w_i$$\n    由于 $\\gamma \\in [0,1]$，因此 $(1-\\gamma) \\in [0,1]$。因此，$w_i'$ 和 $w_j'$ 是 $w_i$ 和 $w_j$ 的凸组合。如果 $w_i, w_j \\ge 0$，它们的任何凸组合都必须是非负的。因此，$w_i', w_j' \\ge 0$。由于这在扫描中的每次交互都成立，财富非负性是系统的一个不变量。\n\n3.  **观点范围不变性：** 给定所有 $k$ 都有 $x_k(0) \\in [-1,1]$，则所有 $k$ 都有 $x_k(1) \\in [-1,1]$。\n    初始条件提供了 $x_k(0) \\in [-1,1]$。我们分析代理 $i$ 和 $j$ 之间的一次观点更新。\n    - 无操作情况显然保持范围。\n    - 对于常规更新，新的观点为：\n    $$x_i' = x_i + \\mu (x_j - x_i) = (1-\\mu)x_i + \\mu x_j$$\n    $$x_j' = x_j + \\mu (x_i - x_j) = (1-\\mu)x_j + \\mu x_i$$\n    由于 $\\mu \\in [0,1]$，因此 $(1-\\mu) \\in [0,1]$。与财富类似，$x_i'$ 和 $x_j'$ 是 $x_i$ 和 $x_j$ 的凸组合。凸组合的一个众所周知的性质是，它们的值介于其分量的最小值和最大值之间。设 $m = \\min(x_i, x_j)$ 和 $M = \\max(x_i, x_j)$。则 $m \\le x_i', x_j' \\le M$。给定 $x_i, x_j \\in [-1,1]$，我们有 $-1 \\le m \\le M \\le 1$。因此，$x_i', x_j' \\in [m, M] \\subseteq [-1,1]$。观点范围在每次交互中都得到保持，因此在整个扫描过程中也得到保持。\n\n所有三个不变性属性在数学上都是合理的。现在，实现必须对给定的测试用例进行计算验证。\n\n**实现设计**\n\n程序的核心将是一个函数，该函数为给定的测试用例模拟一个完整的时间步。该函数将接受模型参数（$N, \\gamma, \\mu, \\theta$）和初始状态（$w(0), x(0)$）作为输入。\n\n将使用一个全局集合 `hit_branches` 来记录整个测试套件中每个不同逻辑分支的执行情况。财富更新规则有4个分支（\"gamma zero no-op\"、\"equal wealth no-op\"、\"gamma one full swap\"、\"regular exchange\"），观点更新规则有3个分支（\"mu zero no-op\"、\"threshold no-op\"、\"regular update\"），总共需要监控7个不同的分支。\n\n一次完整扫描的模拟通过迭代 $i$ 从 $0$ 到 $N-1$ 来进行。对于每个 $i$，交互的代理对是 $(i, j)$，其中 $j = (i+1) \\bmod N$。代理 $i$ 和 $j$ 的状态是顺序更新的。代理 $i$ 在 $(i-1, i)$（模 $N$）交互后的状态更新，将成为 $(i, i+1)$ 交互的输入。必须通过在扫描过程中就地修改状态数组来正确处理这种顺序更新。\n\n在对给定测试用例完成完整扫描后，将最终状态 $w(1)$ 和 $x(1)$ 与初始状态 $w(0)$ 和 $x(0)$ 进行比较，以验证三个不变性属性。\n- **总财富：** 使用 `np.isclose` 进行验证，以处理潜在的浮点数不精确问题，即 `np.isclose(np.sum(w(1)), np.sum(w(0)))`。\n- **财富非负性：** 通过检查 $w(1)$ 的所有元素是否大于或等于 $0$ 来验证。\n- **观点范围：** 通过检查 $x(1)$ 的所有元素是否位于闭区间 $[-1,1]$ 内来验证。\n\n为每个测试用例生成一个布尔结果，当且仅当所有三个属性都成立时，该结果为 `True`。处理完所有测试用例后，分支覆盖率计算为 `hit_branches` 中唯一分支的数量除以总分支数（$7$）。该比率四舍五入到小数点后 $3$ 位。最终输出是一个包含五个布尔结果和计算出的覆盖率的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the agent-based model,\n    verify invariants, and compute branch coverage.\n    \"\"\"\n    test_cases = [\n        # Case A (happy path)\n        {'N': 4, 'gamma': 0.5, 'mu': 0.5, 'theta': 0.0, 'w0': [1, 0, 2, 3], 'x0': [-0.5, 0.5, -1.0, 1.0]},\n        # Case B (wealth gamma zero, opinion threshold no-op)\n        {'N': 4, 'gamma': 0.0, 'mu': 0.4, 'theta': 0.5, 'w0': [1, 2, 3, 4], 'x0': [0.1, 0.1, 0.1, 0.1]},\n        # Case C (equal wealth branch, mu zero no-op)\n        {'N': 4, 'gamma': 0.5, 'mu': 0.0, 'theta': 0.0, 'w0': [2, 2, 3, 4], 'x0': [-0.2, 0.6, -0.6, 0.2]},\n        # Case D (gamma one full swap, opinion update extreme)\n        {'N': 4, 'gamma': 1.0, 'mu': 1.0, 'theta': 0.0, 'w0': [5, 1, 5, 1], 'x0': [-1.0, 1.0, -1.0, 1.0]},\n        # Case E (network size boundary)\n        {'N': 1, 'gamma': 0.7, 'mu': 0.3, 'theta': 0.1, 'w0': [3.0], 'x0': [0.0]},\n    ]\n\n    total_branches = {\n        \"gamma zero no-op\", \"equal wealth no-op\", \"gamma one full swap\", \"regular exchange\",\n        \"mu zero no-op\", \"threshold no-op\", \"regular update\"\n    }\n    hit_branches = set()\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        gamma = case['gamma']\n        mu = case['mu']\n        theta = case['theta']\n        \n        w0 = np.array(case['w0'], dtype=float)\n        x0 = np.array(case['x0'], dtype=float)\n        \n        w = w0.copy()\n        x = x0.copy()\n\n        if N > 0:\n            for i in range(N):\n                j = (i + 1) % N\n                \n                # Wealth update logic\n                wi, wj = w[i], w[j]\n                if gamma == 0:\n                    hit_branches.add(\"gamma zero no-op\")\n                    # No change\n                elif wi == wj:\n                    hit_branches.add(\"equal wealth no-op\")\n                    # No change\n                elif gamma == 1:\n                    hit_branches.add(\"gamma one full swap\")\n                    w[i], w[j] = wj, wi\n                else:\n                    hit_branches.add(\"regular exchange\")\n                    delta_w = gamma * (wj - wi)\n                    w[i] += delta_w\n                    w[j] -= delta_w\n\n                # Opinion update logic\n                xi, xj = x[i], x[j]\n                if mu == 0:\n                    hit_branches.add(\"mu zero no-op\")\n                    # No change\n                elif abs(xi - xj) = theta:\n                    hit_branches.add(\"threshold no-op\")\n                    # No change\n                else:\n                    hit_branches.add(\"regular update\")\n                    delta_x_i = mu * (xj - xi)\n                    delta_x_j = mu * (xi - xj)\n                    x[i] += delta_x_i\n                    x[j] += delta_x_j\n\n        # Verify invariants\n        total_wealth_inv = np.isclose(np.sum(w0), np.sum(w))\n        \n        # Check non-negativity only if initial wealth is non-negative\n        wealth_nonneg_inv = np.all(w >= 0) if np.all(w0 >= 0) else True\n\n        # Check bounds only if initial opinions are bounded\n        opinion_bounds_inv = (np.all(x >= -1) and np.all(x = 1)) if (np.all(x0 >= -1) and np.all(x0 = 1)) else True\n\n        invariants_hold = all([total_wealth_inv, wealth_nonneg_inv, opinion_bounds_inv])\n        results.append(invariants_hold)\n\n    coverage_ratio = len(hit_branches) / len(total_branches)\n    results.append(round(coverage_ratio, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一旦模型被正确构建和验证，下一个挑战就是理解它，例如探究哪些参数对模型输出的影响最大。敏感性分析为这个问题提供了系统性的答案。这个练习  向你介绍局部和全局敏感性的概念，并让你亲手实践莫里斯（Morris）筛选法——一种计算上高效的技术，用以识别模型中最重要的参数。",
            "id": "4284337",
            "problem": "考虑一个程式化的基于主体的模型（Agent-Based Model, ABM），其定义为一组相互作用的主体，其微观层面的规则产生宏观层面的涌现结果。设宏观层面的结果由一个代理映射 $f:\\,[0,1]^3\\to \\mathbb{R}$ 概括，该映射从拟合ABM模拟数据的回归元模型中获得。三个归一化参数分别为 $x_1$（接触倾向）、$x_2$（行为遵从性）和 $x_3$（网络重连趋势）。对于本练习，设代理响应为\n$$\nf(x_1,x_2,x_3)=x_1+2\\,x_2+3\\,x_3+x_1\\,x_2.\n$$\n为了进行全局敏感性分析，假设所有参数在 $[0,1]$ 上独立且均匀分布。\n\n从 (i) 局部敏感性的定义（输出在特定点相对于每个参数的无穷小变化率）和 (ii) 全局敏感性的定义（在参数不确定性下，每个参数对输出方差的贡献）出发，完成以下任务：\n\n1. 使用基于微积分的全微分概念，推导代理映射 $f$ 在一个通用点 $x=(x_1,x_2,x_3)$ 处的局部敏感性向量。清晰阐述这是如何从导数的基本定义得出的。\n\n2. 对于独立输入 $x_1, x_2, x_3 \\sim \\mathrm{Uniform}(0,1)$，使用全方差定律，根据方差和条件期望来定义一阶全局敏感性度量。解释这些度量作为量化可归因于单个参数的方差贡献的基本原理。\n\n3. 在参数空间中，为 $p=4$ 个网格水平和步长 $\\Delta=\\frac{1}{3}$ 推导一条Morris筛选轨迹。从基点 $x^{(0)}=\\left(\\frac{1}{3},\\,0,\\,\\frac{2}{3}\\right)$ 开始构建轨迹，按 $\\{x_1,\\,x_2,\\,x_3\\}$ 的顺序，每次对一个参数进行 $+\\Delta$ 的扰动，确保轨迹保持在网格上。然后，计算此轨迹上每个参数对应的基本效应，其定义为单参数扰动下 $f$ 的有限差分变化量除以 $\\Delta$。\n\n4. 设 $\\mu^{\\star}$ 表示从第3步中的单条轨迹获得的基本效应绝对值向量。计算该向量的欧几里得范数 $\\|\\mu^{\\star}\\|_2$。将最终答案表示为单一的、无四舍五入的精确闭式表达式。\n\n你的最终答案必须是单一的精确解析表达式。无需单位。不要四舍五入；不要使用百分号。",
            "solution": "在提供解答之前，对问题进行验证。\n\n### 第1步：提取已知条件\n- 代理映射：$f(x_1, x_2, x_3) = x_1 + 2x_2 + 3x_3 + x_1x_2$，其中 $f:\\,[0,1]^3 \\to \\mathbb{R}$。\n- 参数：$x_1$（接触倾向）、$x_2$（行为遵从性）、$x_3$（网络重连趋势）。\n- 参数分布：所有参数 $x_i$ 在 $[0,1]$ 上独立且均匀分布。\n- 局部敏感性定义：输出相对于每个参数的无穷小变化率。\n- 全局敏感性定义：在参数不确定性下，每个参数对输出方差的贡献。\n- 关于Morris筛选法（第3部分）：\n    - 网格水平数：$p=4$。\n    - 步长：$\\Delta = \\frac{1}{3}$。\n    - 基点：$x^{(0)} = (\\frac{1}{3}, 0, \\frac{2}{3})$。\n    - 扰动顺序：$\\{x_1, x_2, x_3\\}$。\n    - 扰动方向：$+\\Delta$。\n- 基本效应定义：$EE = \\frac{\\Delta f}{\\Delta}$，其中 $\\Delta f$ 是 $f$ 在单个参数大小为 $\\Delta$ 的扰动下的变化量。\n- 待计算量（第4部分）：向量 $\\mu^{\\star}$ 的欧几里得范数 $\\|\\mu^{\\star}\\|_2$，其中 $\\mu^{\\star}$ 定义为由第3部分构建的单条轨迹得到的基本效应绝对值向量。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学依据充分：** 问题使用了敏感性分析中的标准、成熟概念（基于偏导数的局部敏感性、基于方差的全局Sobol指数以及基于筛选的Morris方法）。代理模型的函数形式是一个简单的多项式，这是此类分析中元模型的常见选择。该问题在科学上是合理的。\n- **适定性：** 问题的四个部分都陈述得非常精确。函数、参数空间、起始点和步长都已明确给出，从而可以进行唯一且可验证的计算序列。\n- **客观性：** 问题以精确的数学语言陈述，没有歧义或主观论断。\n- **完整性和一致性：** 问题是自洽的。网格水平数 $p=4$ 与步长 $\\Delta = \\frac{1}{p-1} = \\frac{1}{4-1} = \\frac{1}{3}$ 一致。起始点 $x^{(0)} = (\\frac{1}{3}, 0, \\frac{2}{3})$ 由位于已定义网格 $\\{0, \\frac{1}{3}, \\frac{2}{3}, 1\\}$ 上的值组成。没有信息缺失或矛盾。\n\n### 第3步：结论与行动\n问题是有效的，因为它科学依据充分、适定、客观且内部一致。将提供完整解答。\n\n---\n\n### 第1部分：局部敏感性向量\n\n局部敏感性衡量在参数空间中的一个固定点上，输入参数的无穷小变化对输出的影响。这由输出函数相对于该参数的偏导数来捕捉。\n\n函数 $f(x_1, x_2, x_3)$ 的全微分提供了由参数的无穷小变化 $dx_1, dx_2, dx_3$ 引起的 $f$ 变化的主要线性部分：\n$$\ndf = \\frac{\\partial f}{\\partial x_1}dx_1 + \\frac{\\partial f}{\\partial x_2}dx_2 + \\frac{\\partial f}{\\partial x_3}dx_3\n$$\n微分 $dx_i$ 的系数即偏导数，代表了局部敏感性。由这些偏导数组成的向量是 $f$ 的梯度 $\\nabla f$，它作为局部敏感性向量。\n\n代理响应函数由下式给出：\n$$\nf(x_1, x_2, x_3) = x_1 + 2x_2 + 3x_3 + x_1x_2\n$$\n我们计算关于每个参数的偏导数：\n1.  对 $x_1$ 的敏感性：\n    $$\n    \\frac{\\partial f}{\\partial x_1} = \\frac{\\partial}{\\partial x_1}(x_1 + 2x_2 + 3x_3 + x_1x_2) = 1 + x_2\n    $$\n2.  对 $x_2$ 的敏感性：\n    $$\n    \\frac{\\partial f}{\\partial x_2} = \\frac{\\partial}{\\partial x_2}(x_1 + 2x_2 + 3x_3 + x_1x_2) = 2 + x_1\n    $$\n3.  对 $x_3$ 的敏感性：\n    $$\n    \\frac{\\partial f}{\\partial x_3} = \\frac{\\partial}{\\partial x_3}(x_1 + 2x_2 + 3x_3 + x_1x_2) = 3\n    $$\n在通用点 $x = (x_1, x_2, x_3)$ 处的局部敏感性向量是 $f$ 的梯度：\n$$\n\\nabla f(x_1, x_2, x_3) = \\left( \\frac{\\partial f}{\\partial x_1}, \\frac{\\partial f}{\\partial x_2}, \\frac{\\partial f}{\\partial x_3} \\right) = (1+x_2, 2+x_1, 3)\n$$\n\n### 第2部分：一阶全局敏感性度量\n\n全局敏感性分析评估参数在其整个不确定性范围内的影响。基于方差的方法，如Sobol方法，将模型输出的总方差分解为来自单个参数及其相互作用的贡献。\n\n设 $Y = f(X_1, X_2, \\dots, X_k)$ 为模型输出，其中 $X_i$ 是独立的随机输入变量。全方差定律允许对总输出方差 $\\mathrm{Var}(Y)$ 进行分解。参数 $X_i$ 的一阶敏感性指数 $S_i$ 定义为由 $X_i$ 自身的方差引起的 $Y$ 的总方差的比例。\n\n在数学上，它定义为：\n$$\nS_i = \\frac{V_i}{\\mathrm{Var}(Y)}\n$$\n其中 $\\mathrm{Var}(Y)$ 是输出的总方差：\n$$\n\\mathrm{Var}(Y) = E[Y^2] - (E[Y])^2\n$$\n而 $V_i$ 是在给定 $X_i$ 的条件下 $Y$ 的条件期望的方差：\n$$\nV_i = \\mathrm{Var}(E[Y|X_i]) = E[(E[Y|X_i])^2] - (E[E[Y|X_i]])^2\n$$\n根据全期望定律，$E[E[Y|X_i]] = E[Y]$，所以 $V_i$ 的表达式简化为：\n$$\nV_i = \\mathrm{Var}(E[Y|X_i])\n$$\n项 $E[Y|X_i=x_i^*]$ 表示当参数 $X_i$ 固定在值 $x_i^*$ 而所有其他参数 $X_{j \\neq i}$ 在其分布上变化时，输出 $Y$ 的期望值。这个量的方差 $\\mathrm{Var}(E[Y|X_i])$ 衡量了当 $X_i$ 在其定义域内变化时，期望输出平均变化多少。因此，$S_i$ 量化了 $X_i$ 对输出方差的主效应，表示如果 $X_i$ 的真值已知，输出方差的预期减少量。\n\n### 第3部分：Morris筛选轨迹与基本效应\n\nMorris方法使用基本效应来筛选重要参数。一个参数的基本效应是其导数的有限差分近似，该近似是沿参数空间中的一条特定轨迹计算的。\n\n给定 $p=4$ 个网格水平，得到每个参数的网格为 $\\{0, \\frac{1}{3}, \\frac{2}{3}, 1\\}$。步长为 $\\Delta = \\frac{1}{3}$。基点为 $x^{(0)} = (\\frac{1}{3}, 0, \\frac{2}{3})$。扰动顺序为 $\\{x_1, x_2, x_3\\}$。\n\n首先，我们计算函数在基点 $x^{(0)}$ 处的值：\n$$\nf(x^{(0)}) = f\\left(\\frac{1}{3}, 0, \\frac{2}{3}\\right) = \\frac{1}{3} + 2(0) + 3\\left(\\frac{2}{3}\\right) + \\left(\\frac{1}{3}\\right)(0) = \\frac{1}{3} + 2 = \\frac{7}{3}\n$$\n\n**第1步：扰动 $x_1$**\n我们通过将 $\\Delta$ 加到 $x^{(0)}$ 的第一个分量上来创建下一个点 $x^{(1)}$：\n$$\nx^{(1)} = x^{(0)} + (\\Delta, 0, 0) = \\left(\\frac{1}{3}+\\frac{1}{3}, 0, \\frac{2}{3}\\right) = \\left(\\frac{2}{3}, 0, \\frac{2}{3}\\right)\n$$\n计算 $f$ 在 $x^{(1)}$ 处的值：\n$$\nf(x^{(1)}) = f\\left(\\frac{2}{3}, 0, \\frac{2}{3}\\right) = \\frac{2}{3} + 2(0) + 3\\left(\\frac{2}{3}\\right) + \\left(\\frac{2}{3}\\right)(0) = \\frac{2}{3} + 2 = \\frac{8}{3}\n$$\n$x_1$ 的基本效应是：\n$$\nEE_1 = \\frac{f(x^{(1)}) - f(x^{(0)})}{\\Delta} = \\frac{\\frac{8}{3} - \\frac{7}{3}}{\\frac{1}{3}} = \\frac{\\frac{1}{3}}{\\frac{1}{3}} = 1\n$$\n\n**第2步：扰动 $x_2$**\n我们通过将 $\\Delta$ 加到 $x^{(1)}$ 的第二个分量上来创建 $x^{(2)}$：\n$$\nx^{(2)} = x^{(1)} + (0, \\Delta, 0) = \\left(\\frac{2}{3}, 0+\\frac{1}{3}, \\frac{2}{3}\\right) = \\left(\\frac{2}{3}, \\frac{1}{3}, \\frac{2}{3}\\right)\n$$\n计算 $f$ 在 $x^{(2)}$ 处的值：\n$$\nf(x^{(2)}) = f\\left(\\frac{2}{3}, \\frac{1}{3}, \\frac{2}{3}\\right) = \\frac{2}{3} + 2\\left(\\frac{1}{3}\\right) + 3\\left(\\frac{2}{3}\\right) + \\left(\\frac{2}{3}\\right)\\left(\\frac{1}{3}\\right) = \\frac{2}{3} + \\frac{2}{3} + 2 + \\frac{2}{9} = \\frac{6+6+18+2}{9} = \\frac{32}{9}\n$$\n$x_2$ 的基本效应是：\n$$\nEE_2 = \\frac{f(x^{(2)}) - f(x^{(1)})}{\\Delta} = \\frac{\\frac{32}{9} - \\frac{8}{3}}{\\frac{1}{3}} = \\frac{\\frac{32 - 24}{9}}{\\frac{1}{3}} = \\frac{\\frac{8}{9}}{\\frac{1}{3}} = \\frac{8}{9} \\times 3 = \\frac{8}{3}\n$$\n\n**第3步：扰动 $x_3$**\n我们通过将 $\\Delta$ 加到 $x^{(2)}$ 的第三个分量上来创建 $x^{(3)}$：\n$$\nx^{(3)} = x^{(2)} + (0, 0, \\Delta) = \\left(\\frac{2}{3}, \\frac{1}{3}, \\frac{2}{3}+\\frac{1}{3}\\right) = \\left(\\frac{2}{3}, \\frac{1}{3}, 1\\right)\n$$\n计算 $f$ 在 $x^{(3)}$ 处的值：\n$$\nf(x^{(3)}) = f\\left(\\frac{2}{3}, \\frac{1}{3}, 1\\right) = \\frac{2}{3} + 2\\left(\\frac{1}{3}\\right) + 3(1) + \\left(\\frac{2}{3}\\right)\\left(\\frac{1}{3}\\right) = \\frac{2}{3} + \\frac{2}{3} + 3 + \\frac{2}{9} = \\frac{6+6+27+2}{9} = \\frac{41}{9}\n$$\n$x_3$ 的基本效应是：\n$$\nEE_3 = \\frac{f(x^{(3)}) - f(x^{(2)})}{\\Delta} = \\frac{\\frac{41}{9} - \\frac{32}{9}}{\\frac{1}{3}} = \\frac{\\frac{9}{9}}{\\frac{1}{3}} = \\frac{1}{\\frac{1}{3}} = 3\n$$\n沿此轨迹计算出的基本效应为 $\\{EE_1, EE_2, EE_3\\} = \\{1, \\frac{8}{3}, 3\\}$。\n\n### 第4部分：基本效应绝对值的欧几里得范数\n\n问题将 $\\mu^{\\star}$ 定义为第3部分中单条轨迹得到的基本效应绝对值向量。由于所有基本效应均为正数，其绝对值不变。\n$$\n\\mu^{\\star} = (|EE_1|, |EE_2|, |EE_3|) = \\left(1, \\frac{8}{3}, 3\\right)\n$$\n该向量的欧几里得范数（或 $L_2$-范数）由 $\\|\\mu^{\\star}\\|_2 = \\sqrt{\\sum_{i=1}^3 (\\mu^{\\star}_i)^2}$ 给出。\n$$\n\\|\\mu^{\\star}\\|_2 = \\sqrt{1^2 + \\left(\\frac{8}{3}\\right)^2 + 3^2}\n$$\n$$\n\\|\\mu^{\\star}\\|_2 = \\sqrt{1 + \\frac{64}{9} + 9}\n$$\n$$\n\\|\\mu^{\\star}\\|_2 = \\sqrt{10 + \\frac{64}{9}}\n$$\n为了对平方根下的各项求和，我们找到一个公分母：\n$$\n\\|\\mu^{\\star}\\|_2 = \\sqrt{\\frac{10 \\times 9}{9} + \\frac{64}{9}} = \\sqrt{\\frac{90}{9} + \\frac{64}{9}} = \\sqrt{\\frac{154}{9}}\n$$\n将分数的平方根分开：\n$$\n\\|\\mu^{\\star}\\|_2 = \\frac{\\sqrt{154}}{\\sqrt{9}} = \\frac{\\sqrt{154}}{3}\n$$\n数字 $154$ 的质因数分解为 $2 \\times 7 \\times 11$，因此其平方根无法进一步简化。",
            "answer": "$$\n\\boxed{\\frac{\\sqrt{154}}{3}}\n$$"
        }
    ]
}