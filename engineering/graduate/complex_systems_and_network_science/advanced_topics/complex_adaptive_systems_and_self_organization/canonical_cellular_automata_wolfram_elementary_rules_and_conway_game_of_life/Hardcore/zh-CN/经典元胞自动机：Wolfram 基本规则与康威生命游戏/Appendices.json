{
    "hands_on_practices": [
        {
            "introduction": "元胞自动机理论的学习不仅在于理解其抽象概念，更在于动手实践。沃尔夫勒姆编码（Wolfram code）是一种将256种可能的基本元胞自动机（ECA）规则进行紧凑表示的标准方法。本节的第一个实践将引导你掌握这一基础，通过构建一个算法，将一个整数规则编号 $R \\in \\{0, \\dots, 255\\}$ 转换回其对应的布尔函数真值表，这是模拟或分析任何ECA的第一步，也是至关重要的一步。",
            "id": "4266078",
            "problem": "考虑一个初等元胞自动机 (ECA)，它被定义为具有二进制状态和最近邻相互作用的一维元胞自动机 (CA)。形式上，设局部更新规则为一个布尔函数 $f:\\{0,1\\}^3 \\to \\{0,1\\}$，它将一个邻域三元组 $(x_{i-1}(t), x_i(t), x_{i+1}(t)) \\in \\{0,1\\}^3$ 映射到一个更新后的状态 $x_i(t+1) \\in \\{0,1\\}$。全局动力学将函数 $f$ 同步地应用于一个构型的每个位点，以生成下一个构型。\n\n所有可能邻域的一个规范枚举是按降序字典序排列的八个二进制三元组：\n$$\n(1,1,1),\\ (1,1,0),\\ (1,0,1),\\ (1,0,0),\\ (0,1,1),\\ (0,1,0),\\ (0,0,1),\\ (0,0,0).\n$$\n对于任何布尔函数 $f:\\{0,1\\}^3 \\to \\{0,1\\}$，其在此排序下的真值表 $v \\in \\{0,1\\}^8$ 定义为\n$$\nv = \\big(f(1,1,1),\\ f(1,1,0),\\ f(1,0,1),\\ f(1,0,0),\\ f(0,1,1),\\ f(0,1,0),\\ f(0,0,1),\\ f(0,0,0)\\big).\n$$\n一个 ECA 规则的 Wolfram 编码是整数 $R \\in \\{0,\\dots,255\\}$，该整数是根据 ECA 文献中使用的标准约定，将真值表以二进制编码得到的。这在 $\\{0,\\dots,255\\}$ 内的整数与 $\\{0,1\\}^3$ 上的所有布尔函数之间建立了一个双射。\n\n任务：根据二进制位值表示法的第一性原理和上述规范邻域排序，推导一个算法。给定 $R \\in \\{0,\\dots,255\\}$，该算法输出对应的布尔函数 $f$，其形式为与上述邻域顺序对齐的真值表向量 $v \\in \\{0,1\\}^8$。你的推导必须仅依赖于二进制表示和布尔函数的基本定义和性质。\n\n你的程序必须实现此算法，并在一系列 Wolfram 编码整数的测试集上进行评估：\n- $R=0$ (边界情况：所有输出为 $0$)，\n- $R=1$ (边界情况：最低有效位被设置)，\n- $R=30$ (典型复杂规则)，\n- $R=90$ (典型加性规则)，\n- $R=110$ (典型复杂规则)，\n- $R=128$ (边界情况：最高有效位被设置)，\n- $R=255$ (边界情况：所有输出为 $1$)。\n\n对于每个测试用例，以列表形式返回包含八个整数的真值表向量 $v$，其顺序固定，对应于邻域 $(1,1,1)$、$(1,1,0)$、$(1,0,1)$、$(1,0,0)$、$(0,1,1)$、$(0,1,0)$、$(0,0,1)$、$(0,0,0)$。\n\n你的程序应生成单行输出，其中包含结果，形式为一个由逗号分隔的、包含八个条目的列表的列表，并用方括号括起来。例如，预期的格式是\n$$\n\\big[\\,[v_{R_1}],\\,[v_{R_2}],\\,\\dots\\,\\big]\n$$\n其中每个 $[v_{R_k}]$ 本身就是一个包含八个整数的列表。本问题不涉及任何物理单位或角度单位，所有输出均为 $\\{0,1\\}$ 中的整数。",
            "solution": "该问题已被验证，并被确定为计算科学和复杂系统领域内一个良置且有科学依据的问题。任务是推导并实现一个算法，将一个初等元胞自动机 (ECA) 的 Wolfram 编码，即一个整数 $R \\in \\{0, \\dots, 255\\}$，转换为其对应的 8 位真值表向量 $v$。\n\n### 从第一性原理推导\n\n问题的核心在于理解整数 $R$ 与真值表向量 $v$ 之间的关系。我们将根据所提供的定义和二进制表示的基本原理来推导这种关系。\n\n**1. Wolfram 编码的形式化定义**\n\n一个 ECA 的局部更新规则是一个布尔函数 $f:\\{0,1\\}^3 \\to \\{0,1\\}$。该函数有 $2^3 = 8$ 种可能的输入（邻域）。问题为这些邻域指定了一个按降序字典序排列的规范排序：\n$$\n(1,1,1), (1,1,0), (1,0,1), (1,0,0), (0,1,1), (0,1,0), (0,0,1), (0,0,0)\n$$\n函数 $f$ 的真值表是一个 8 位向量 $v$，其中每个位是 $f$ 对指定顺序中相应邻域的输出：\n$$\nv = (v_1, v_2, v_3, v_4, v_5, v_6, v_7, v_8)\n$$\n其中 $v_1 = f(1,1,1)$，$v_2 = f(1,1,0)$，依此类推，直到 $v_8 = f(0,0,0)$。\n\nWolfram 编码 $R$ 被定义为其二进制表示为向量 $v$ 的整数。与指定的降序邻域顺序一致的标准约定将 $v_1$ 视为最高有效位 (MSB)，将 $v_8$ 视为最低有效位 (LSB)。\n\n根据位值记数法原理，一个 8 位二进制数 $(b_7 b_6 b_5 b_4 b_3 b_2 b_1 b_0)_2$ 对应于由以 2 为底的多项式给出的整数 $N$：\n$$\nN = \\sum_{i=0}^{7} b_i \\cdot 2^i = b_7 \\cdot 2^7 + b_6 \\cdot 2^6 + \\dots + b_0 \\cdot 2^0\n$$\n在我们的例子中，二进制表示由 $v$ 的元素给出，其中 $v_1$ 对应于最高次幂的位 ($b_7$)，$v_2$ 对应于下一个位 ($b_6$)，依此类推，直到 $v_8$ 对应于最低次幂的位 ($b_0$)。映射这些索引，位 $v_k$ (对于 $k \\in \\{1, \\dots, 8\\}$) 对应于位置系数 $b_{8-k}$。因此，整数 $R$ 定义为：\n$$\nR = v_1 \\cdot 2^7 + v_2 \\cdot 2^6 + v_3 \\cdot 2^5 + v_4 \\cdot 2^4 + v_5 \\cdot 2^3 + v_6 \\cdot 2^2 + v_7 \\cdot 2^1 + v_8 \\cdot 2^0 = \\sum_{k=1}^{8} v_k \\cdot 2^{8-k}\n$$\n\n**2. 逆映射的推导 (从 R 到 v)**\n\n任务是执行逆操作：给定一个整数 $R$，我们必须找到其二进制展开的系数 $v_k \\in \\{0,1\\}$。这是一个标准的进制转换过程，可以被形式化地推导出来。\n\n让我们从 $R$ 中找到一个通用位 $v_k$，其中 $k \\in \\{1, \\dots, 8\\}$。位 $v_k$ 是项 $2^{8-k}$ 的系数。设 $p_k = 8-k$ 是对应于 $v_k$ 的 2 的幂。幂 $p_k$ 的范围从 $p_1=7$ (对于 MSB $v_1$) 到 $p_8=0$ (对于 LSB $v_8$)。\n\n为了分离出 $v_k$，我们可以操作 $R$ 的表达式。让我们将 $R$ 除以 $2^{p_k}$：\n$$\n\\frac{R}{2^{p_k}} = \\frac{1}{2^{p_k}} \\sum_{j=1}^{8} v_j \\cdot 2^{8-j} = \\sum_{j=1}^{8} v_j \\cdot 2^{(8-j)-p_k}\n$$\n我们可以在索引 $k$ 处将和式拆分：\n$$\n\\frac{R}{2^{p_k}} = \\sum_{j=1}^{k} v_j \\cdot 2^{(p_j - p_k)} + \\sum_{j=k+1}^{8} v_j \\cdot 2^{(p_j - p_k)}\n$$\n第一个求和部分由 2 的非负次幂的项组成，而第二部分由负次幂的项组成。\n$$\n\\frac{R}{2^{p_k}} = \\underbrace{(v_1 \\cdot 2^{p_1-p_k} + \\dots + v_{k-1} \\cdot 2^{p_{k-1}-p_k} + v_k \\cdot 2^0)}_{\\text{整数部分}} + \\underbrace{(v_{k+1} \\cdot 2^{-1} + \\dots + v_8 \\cdot 2^{-(8-k)})}_{\\text{小数部分}}\n$$\n通过对此表达式取底，我们消除了小数部分：\n$$\n\\left\\lfloor \\frac{R}{2^{p_k}} \\right\\rfloor = v_1 \\cdot 2^{p_1-p_k} + \\dots + v_{k-1} \\cdot 2^{1} + v_k\n$$\n和式中的每一项，除了最后一项 ($v_k$)，都是 2 的倍数。因此，如果我们对整个表达式取模 2，我们就能分离出 $v_k$：\n$$\n\\left\\lfloor \\frac{R}{2^{p_k}} \\right\\rfloor \\pmod 2 = (v_1 \\cdot 2^{p_1-p_k} + \\dots + v_{k-1} \\cdot 2^{1} + v_k) \\pmod 2 = v_k\n$$\n这为我们提供了计算每个位 $v_k$ 的直接公式：\n$$\nv_k = \\left\\lfloor \\frac{R}{2^{8-k}} \\right\\rfloor \\pmod 2, \\quad \\text{for } k=1, 2, \\dots, 8.\n$$\n\n**3. 算法步骤**\n\n推导出的公式可以直接转化为一个算法。要构建向量 $v = (v_1, \\dots, v_8)$，我们可以从 $k=1$ 迭代到 $k=8$。在编程中，整除 `R // (2**p)` 对应于 $\\lfloor R / 2^p \\rfloor$，而模运算符 `... % 2` 对应于 $\\pmod 2$。\n\n更高效地，这些操作可以使用位运算符来实现。操作 $\\lfloor R / 2^p \\rfloor$ 等价于将 $R$ 按位右移 $p$ 个位置（记作 $R \\gg p$）。操作 $\\pmod 2$ 等价于与 $1$ 进行按位与（记作 $\\ 1$）。\n\n因此，算法如下：\n1. 为真值表向量 $v$ 初始化一个空列表。\n2. 使用索引 $k$ 从 $1$ 迭代到 $8$。这对应于 $v$ 的分量。\n3. 对于每个 $k$，计算对应的位位置（2的幂）为 $p = 8 - k$。这将使 $p$ 从 $7$ 迭代到 $0$。\n4. 计算位值为 $v_k = (R \\gg p) \\ 1$。\n5. 将此位值附加到列表 $v$ 中。\n6. 循环完成后，列表 $v$ 将按正确顺序包含真值表的 8 个位。\n\n该算法是所推导出的数学过程的直接实现，并且仅依赖于二进制表示的基本性质。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# No external libraries are needed for this solution.\n\ndef solve():\n    \"\"\"\n    Solves the problem of converting Wolfram codes for Elementary Cellular Automata\n    into their corresponding truth table vectors.\n    \"\"\"\n\n    def get_truth_table_vector(wolfram_code: int) -> list[int]:\n        \"\"\"\n        Derives the 8-bit truth table vector from an ECA Wolfram code.\n\n        The Wolfram code R is the integer representation of the 8-bit truth table\n        v = (v1, v2, ..., v8), where v1 is the most significant bit.\n        The truth table bits correspond to the neighborhood outputs in the order:\n        (1,1,1), (1,1,0), (1,0,1), (1,0,0), (0,1,1), (0,1,0), (0,0,1), (0,0,0).\n\n        The bit v_k corresponds to the coefficient of 2^(8-k). It can be extracted\n        using bitwise operations. The bit at position p (from the right, 0-indexed)\n        is found by (R >> p)  1.\n        For v1, p=7. For v2, p=6, ..., for v8, p=0.\n\n        Args:\n            wolfram_code: An integer between 0 and 255.\n\n        Returns:\n            A list of 8 integers (0 or 1) representing the truth table.\n        \"\"\"\n        if not 0 = wolfram_code = 255:\n            raise ValueError(\"Wolfram code must be between 0 and 255.\")\n\n        vector = []\n        # The powers of 2 for the bits range from 7 (MSB) down to 0 (LSB).\n        for power in range(7, -1, -1):\n            # Isolate the bit at the current power's position.\n            # (wolfram_code >> power) shifts the bit to the LSB position.\n            #  1 extracts this bit's value.\n            bit = (wolfram_code >> power)  1\n            vector.append(bit)\n        \n        return vector\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0,   # Boundary case: all outputs 0\n        1,   # Boundary case: least significant bit set\n        30,  # Canonical complex rule\n        90,  # Canonical additive rule\n        110, # Canonical complex rule\n        128, # Boundary case: most significant bit set\n        255  # Boundary case: all outputs 1\n    ]\n\n    results = []\n    for R in test_cases:\n        truth_table = get_truth_table_vector(R)\n        results.append(truth_table)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list in Python includes spaces,\n    # which is consistent with the problem's LaTeX example format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何明确定义一个规则后，我们便可以深入分析其动态特性。一个核心问题涉及时间上的可逆性：给定一个演化后的构型，我们能否确定其“父”构型？本实践将向你介绍一种强大的分析工具——转移矩阵法（transfer matrix method），用于精确计算在规则184下特定构型的前驱态数量，并借此探讨诸如“伊甸园”（Garden of Eden）状态等基本概念。",
            "id": "4266043",
            "problem": "考虑一个长度为 $L$ 的周期性晶格（环）上的二元一维初等元胞自动机（ECA），其半径 $r=1$，更新规则由沃尔夫勒姆的规则 $184$ 给出。时刻 $t$ 的 ECA 状态由序列 $\\{s_i(t)\\}_{i=0}^{L-1}$ 表示，其中 $s_i(t) \\in \\{0,1\\}$，并满足周期性边界条件 $s_{i+L}(t) = s_i(t)$。局部更新规则根据规则 $184$ 的真值表产生下一状态 $s_i(t+1) = f(s_{i-1}(t), s_i(t), s_{i+1}(t))$：\n$$\nf(1,1,1)=1,\\quad f(1,1,0)=0,\\quad f(1,0,1)=1,\\quad f(1,0,0)=1,\\quad f(0,1,1)=1,\\quad f(0,1,0)=0,\\quad f(0,0,1)=0,\\quad f(0,0,0)=0.\n$$\n已知该自动机可用于模拟保守输运（交通流），其中 $1$ 代表粒子，$0$ 代表空位。\n\n设 $L=20$ 并定义目标构型 $\\{t_i\\}_{i=0}^{19}$ 为 $t_i = i \\bmod 2$，即长度为 $20$ 的严格交替模式 $t = 0101\\cdots 01$，其中 $t_0=0$。$t$ 的一个前驱是任何构型 $\\{s_i\\}_{i=0}^{19} \\in \\{0,1\\}^{20}$，使得对其应用一次规则 $184$（在环形拓扑下）可以得到 $t$。\n\n从元胞自动机的基本定义及其在环上的局部映射组合出发，推导出一个有原则的方法来计算在规则 $184$ 下 $t$ 的不同前驱的数量 $N$。根据您的推导，确定 $t$ 是否是伊甸园构型（即没有前驱的构型）。\n\n将您的最终答案报告为有序对 $(N,g)$，其中 $N$ 是 $t$ 的前驱总数，如果 $t$ 是伊甸园构型，则 $g$ 等于 $1$，否则等于 $0$。无需四舍五入，不涉及单位。按最终答案格式说明的方式表示该有序对 $(N,g)$。",
            "solution": "用户希望求出初等元胞自动机中一个特定构型的前驱数量。\n\n### 步骤1：提取已知条件\n- **系统**：二元一维初等元胞自动机（ECA）。\n- **晶格**：长度为 $L=20$ 的周期性环。\n- **半径**：$r=1$。\n- **更新规则**：沃尔夫勒姆规则184。\n- **真值表**：\n  - $f(1,1,1)=1$\n  - $f(1,1,0)=0$\n  - $f(1,0,1)=1$\n  - $f(1,0,0)=1$\n  - $f(0,1,1)=1$\n  - $f(0,1,0)=0$\n  - $f(0,0,1)=0$\n  - $f(0,0,0)=0$\n- **状态表示**：$\\{s_i(t)\\}_{i=0}^{L-1}$，$s_i(t) \\in \\{0,1\\}$。\n- **边界条件**：周期性，$s_{i+L}(t) = s_i(t)$。\n- **局部更新规则**：$s_i(t+1) = f(s_{i-1}(t), s_i(t), s_{i+1}(t))$。\n- **目标构型**：$\\{t_i\\}_{i=0}^{19}$，其中 $t_i = i \\bmod 2$。\n- **定义**：$t$ 的一个前驱是任何构型 $\\{s_i\\}$，使得对其应用一次规则184可以得到 $t$。\n- **定义**：伊甸园构型是前驱数量为零的构型。\n- **目标**：求出前驱数量 $N$ 和一个标志 $g$，其中如果构型是伊甸园构型，则 $g=1$，否则 $g=0$。\n- **最终答案格式**：一个有序对 $(N, g)$。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题在科学上是合理的，是元胞自动机理论中的一个标准问题。问题是适定的，所有必要参数（$L$、规则、目标构型）都已明确定义。语言客观、正式。问题是自洽的、一致的，并且需要严谨且不平凡的数学推导。前驱和伊甸园构型的概念是研究元胞自动机动力学的基础。\n\n### 步骤3：结论与行动\n问题有效。将推导完整解法。\n\n### 推导\n如果对于每个位置 $i \\in \\{0, 1, \\dots, L-1\\}$，以下方程都成立，则构型 $s = \\{s_i\\}_{i=0}^{L-1}$ 是目标构型 $t = \\{t_i\\}_{i=0}^{L-1}$ 的一个前驱：\n$$t_i = f(s_{i-1}, s_i, s_{i+1})$$\n其中索引在模 $L=20$ 的意义下取值。这构成了关于变量 $\\{s_i\\}$ 的一个包含 $20$ 个耦合非线性方程的系统。\n\n这个系统可以使用转移矩阵法求解。我们将每个位置 $i$ 的“状态”定义为元胞值对 $(s_{i-1}, s_i)$。共有 $2^2=4$ 种可能的状态：$(0,0)$, $(0,1)$, $(1,0)$, 和 $(1,1)$。局部规则 $t_i = f(s_{i-1}, s_i, s_{i+1})$ 作为从位置 $i$ 的状态 $(s_{i-1}, s_i)$ 到位置 $i+1$ 的状态 $(s_i, s_{i+1})$ 的转移约束。\n\n目标构型由 $t_i = i \\bmod 2$ 给出，得到模式 $t = 010101\\dots01$。由于 $t_i$ 的值取决于 $i$ 的奇偶性，我们必须定义两个独立的转移矩阵：\n1.  $M_0$ 用于偶数 $i$，此时 $t_i=0$。\n2.  $M_1$ 用于奇数 $i$，此时 $t_i=1$。\n\n转移矩阵的元素 $(M_k)_{uv}$ 为 $1$（如果从状态 $u=(s_{i-1}, s_i)$ 到状态 $v=(s_i, s_{i+1})$ 的转移在约束 $t_i=k$ 下是允许的），否则为 $0$。我们将状态映射到索引如下：$0 \\leftrightarrow (0,0)$，$1 \\leftrightarrow (0,1)$，$2 \\leftrightarrow (1,0)$，$3 \\leftrightarrow (1,1)$。\n\n**构建 $M_0$ (对于 $t_i=0$)：**\n在规则184下，映射到 $0$ 的输入邻域 $(s_{i-1}, s_i, s_{i+1})$ 集合是：\n$\\{(1,1,0), (0,1,0), (0,0,1), (0,0,0)\\}$.\n- 从状态 $(0,0)$：邻域为 $(0,0,0)$ 和 $(0,0,1)$。这些导致下一个状态为 $(0,0)$ 和 $(0,1)$。\n- 从状态 $(0,1)$：邻域为 $(0,1,0)$，导致下一个状态为 $(1,0)$。\n- 从状态 $(1,0)$：没有以 $(1,0)$ 开头且映射到 $0$ 的邻域。\n- 从状态 $(1,1)$：邻域为 $(1,1,0)$，导致下一个状态为 $(1,0)$。\n这给出了矩阵：\n$$M_0 = \\begin{pmatrix} 1  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  0 \\\\ 0  0  1  0 \\end{pmatrix}$$\n\n**构建 $M_1$ (对于 $t_i=1$)：**\n映射到 $1$ 的输入邻域集合是：\n$\\{(1,1,1), (1,0,1), (1,0,0), (0,1,1)\\}$.\n- 从状态 $(0,0)$：没有以 $(0,0)$ 开头且映射到 $1$ 的邻域。\n- 从状态 $(0,1)$：邻域为 $(0,1,1)$，导致下一个状态为 $(1,1)$。\n- 从状态 $(1,0)$：邻域为 $(1,0,0)$ 和 $(1,0,1)$。这些导致下一个状态为 $(0,0)$ 和 $(0,1)$。\n- 从状态 $(1,1)$：邻域为 $(1,1,1)$，导致下一个状态为 $(1,1)$。\n这给出了矩阵：\n$$M_1 = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  0  1 \\\\ 1  1  0  0 \\\\ 0  0  0  1 \\end{pmatrix}$$\n\n前驱构型的总数 $N$ 是环上长度为 $L=20$ 的有效闭合路径的数量。这由总转移矩阵 $M_{total}$ 的迹给出。总矩阵是每个位置的单个矩阵的乘积，按其索引的逆序排列。\n$$M_{total} = M_{t_{19}} M_{t_{18}} \\cdots M_{t_1} M_{t_0}$$\n给定 $t=0101\\dots01$，我们有 $t_0=0, t_1=1, t_2=0, \\dots, t_{18}=0, t_{19}=1$。\n$$M_{total} = M_1 M_0 M_1 M_0 \\cdots M_1 M_0 = (M_1 M_0)^{10}$$\n\n让我们计算乘积 $A = M_1 M_0$：\n$$A = M_1 M_0 = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  0  1 \\\\ 1  1  0  0 \\\\ 0  0  0  1 \\end{pmatrix} \\begin{pmatrix} 1  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  0 \\\\ 0  0  1  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  1  0 \\\\ 1  1  1  0 \\\\ 0  0  1  0 \\end{pmatrix}$$\n我们需要计算 $N = \\text{Tr}(A^{10})$。我们可以通过找到 $A^n$ 的通项形式来做到这一点。设 $F_n$ 为第 $n$ 个斐波那契数，其中 $F_0=0, F_1=1, F_2=1, \\dots$。\n让我们假设 $n \\ge 1$ 时 $A^n$ 的形式为：\n$$A^n = \\begin{pmatrix} 0  0  0  0 \\\\ F_{n-1}  F_{n-1}  F_{n}  0 \\\\ F_{n}  F_{n}  F_{n+1}  0 \\\\ F_{n-1}  F_{n-1}  F_{n}  0 \\end{pmatrix}$$\n（约定 $F_{-1}=1$）。\n让我们检查 $n=1$ 的情况：$A^1 = \\begin{pmatrix} 0  0  0  0 \\\\ F_0  F_0  F_1  0 \\\\ F_1  F_1  F_2  0 \\\\ F_0  F_0  F_1  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  1  0 \\\\ 1  1  1  0 \\\\ 0  0  1  0 \\end{pmatrix}$。这与我们的矩阵 $A$ 相符。\n\n我们用归纳法证明这个形式。假设它对 $n$ 成立。那么对于 $n+1$：\n$$A^{n+1} = A^n A = \\begin{pmatrix} 0  0  0  0 \\\\ F_{n-1}  F_{n-1}  F_{n}  0 \\\\ F_{n}  F_{n}  F_{n+1}  0 \\\\ F_{n-1}  F_{n-1}  F_{n}  0 \\end{pmatrix} \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  1  0 \\\\ 1  1  1  0 \\\\ 0  0  1  0 \\end{pmatrix}$$\n将 $A^n$ 的第三行乘以 $A$：\n$$(F_n, F_n, F_{n+1}, 0) \\cdot A = (F_{n+1}, F_{n+1}, F_n+F_{n+1}, 0) = (F_{n+1}, F_{n+1}, F_{n+2}, 0)$$\n这与假设的 $A^{n+1}$ 的第3行的形式一致。\n将 $A^n$ 的第二行乘以 $A$：\n$$(F_{n-1}, F_{n-1}, F_{n}, 0) \\cdot A = (F_n, F_n, F_{n-1}+F_n, 0) = (F_n, F_n, F_{n+1}, 0)$$\n这与 $A^{n+1}$ 的第2行的形式一致。第四行与第二行相同。第一行保持为零。归纳成立。\n\n现在我们可以计算 $N = \\text{Tr}(A^{10})$：\n$$A^{10} = \\begin{pmatrix} 0  0  0  0 \\\\ F_{9}  F_{9}  F_{10}  0 \\\\ F_{10}  F_{10}  F_{11}  0 \\\\ F_9  F_9  F_{10}  0 \\end{pmatrix}$$\n$$N = \\text{Tr}(A^{10}) = 0 + F_9 + F_{11} + 0 = F_9 + F_{11}$$\n我们计算所需的斐波那契数：\n$F_0=0, F_1=1, F_2=1, F_3=2, F_4=3, F_5=5, F_6=8, F_7=13, F_8=21, F_9=34, F_{10}=55, F_{11}=89$。\n$$N = 34 + 89 = 123$$\n不同前驱的数量为 $N=123$。\n\n如果一个构型没有前驱（即 $N=0$），则它是伊甸园构型。由于 $N=123 \\ne 0$，目标构型 $t$ 不是伊甸园构型。因此，指示变量 $g$ 为 $0$。\n\n最终答案是有序对 $(N,g) = (123,0)$。\n这个结果可以用 $A$ 的特征值进行交叉检验。特征多项式是 $\\det(A-\\lambda I) = \\lambda^2(\\lambda^2-\\lambda-1)$。特征值为 $\\lambda=0$（重数为2）、$\\lambda=\\phi = \\frac{1+\\sqrt{5}}{2}$ 和 $\\lambda=1-\\phi = \\frac{1-\\sqrt{5}}{2}$。矩阵是可对角化的，所以 $\\text{Tr}(A^{10}) = \\sum \\lambda_i^{10} = 0^{10} + 0^{10} + \\phi^{10} + (1-\\phi)^{10}$。这个和是第10个卢卡斯数 $L_{10}$ 的定义。卢卡斯数序列以 $L_0=2, L_1=1, L_2=3, \\dots$ 开始，递推关系为 $L_n=L_{n-1}+L_{n-2}$。我们求得 $L_{10}=123$。恒等式 $L_n=F_{n-1}+F_{n+1}$ 进一步证实了 $L_{10} = F_9+F_{11}$，验证了我们的矩阵幂运算结果。",
            "answer": "$$ \\boxed{\\begin{pmatrix} 123  0 \\end{pmatrix}} $$"
        },
        {
            "introduction": "元胞自动机的真正魅力在于，简单的局部规则能够涌现出复杂的宏观行为。最后的这项实践将视角从分析单个构型提升到研究统计系综。通过为康威生命游戏（Conway's Game of Life）、规则30和规则110等不同系统编写并运行模拟，你将亲手估算出稳定结构开始占据主导地位的临界初始密度，从而获得对复杂系统中“相变”（phase transition）概念的直观体验。",
            "id": "4266022",
            "problem": "考虑在 Wolfram 的初级 CA 和 Conway 的生命游戏 (GoL) 的经典更新规则下的二元状态细胞自动机 (CA)。设状态空间是离散且有限的，时间以离散步长推进。本问题的根本基础是定义了同步应用于所有位点的确定性局部更新规则，以及通过独立同分布的伯努利试验对构型进行概率性初始化。\n\n定义和设置：\n- 一个一维初级 CA 由一个含 $M$ 个细胞的环组成，细胞具有二元状态 $\\{0,1\\}$，在时间 $t \\mapsto t+1$ 时根据一个由 Wolfram 规则数 $R \\in \\{0,1,\\dots,255\\}$ 决定的映射进行同步更新。每个位点的更新取决于其半径为 1 的邻域 $\\{x_{i-1}(t), x_{i}(t), x_{i+1}(t)\\}$。\n- Conway 的生命游戏 (GoL) 由一个大小为 $N \\times N$ 的二维环形网格构成，细胞具有二元状态 $\\{0,1\\}$。在时间 $t \\mapsto t+1$ 时的更新规则是：如果一个活细胞恰好有 2 个或 3 个活邻居，则它保持存活；如果一个死细胞恰好有 3 个活邻居，则它变为活细胞；否则，该细胞变为或保持死亡状态。邻居计数是根据环面上的 8 个最近邻居计算的。\n- 密度为 $p \\in [0,1]$ 的随机初始构型通过独立的伯努利试验生成，其中每个位点以概率 $p$ 存活（状态 1），以概率 $1-p$ 死亡（状态 0）。\n- 如果存在一个有限的瞬态时间，在此之后全局构型满足 $X_{t} = X_{t-1}$（周期 1）或 $X_{t} = X_{t-2}$（周期 2），则称该构型为周期小于或等于 2 的最终周期性构型。我们将这种最终周期性的出现称为稳定结构的出现。\n\n目标：\n对于密度为 $p$ 的随机初始构型，估计稳定结构出现的临界 $p$。该临界 $p$ 定义为：在一个给定的离散密度集合中，使得稳定化（在固定时间范围内最终周期小于或等于 2）的经验概率至少为 0.5 的最小 $p$ 值。然后，将这些估计值与针对经典规则报告的定性经验发现进行比较。\n\n估计协议：\n- 对每个选定的 $p$，运行 $S$ 次独立试验（每次试验使用独立的随机种子），从随机初始构型开始将 CA 演化 $T$ 步，并检验最终构型 $X_{T}$ 是否满足 $X_{T}=X_{T-1}$ 或 $X_{T}=X_{T-2}$。令 $\\hat{q}(p)$ 表示满足此稳定性标准的试验所占的比例。\n- 将估计的临界密度 $p^{\\star}$ 定义为使得 $\\hat{q}(p) \\ge 0.5$ 的最小测试密度 $p$。如果没有测试的 $p$ 达到 $\\hat{q}(p) \\ge 0.5$，则输出 $-1.0$ 作为估计值，表示“在网格内未找到”。\n\n科学真实性和约束条件：\n- 所有模拟均使用环形边界条件以避免边界效应并确保空间均匀性。\n- 测试范围 $T$ 和试验次数 $S$ 是有限的，这承认了最终周期可能在时间 $T$ 之后发生，但估计标准使用观测到的范围。\n\n测试套件：\n评估三个案例以检验动力学的不同方面：\n1. 在 $N \\times N$ 环面上运行的 GoL，其中 $N=64$，$T=256$，$S=16$，测试密度 $p \\in \\{0.05, 0.10, 0.20, 0.30, 0.40\\}$。\n2. 在大小为 $M=256$ 的一维环上运行的初级 CA 规则 $R=110$，其中 $T=256$，$S=16$，测试密度 $p \\in \\{0.05, 0.10, 0.20, 0.30, 0.40\\}$。\n3. 在大小为 $M=256$ 的一维环上运行的初级 CA 规则 $R=30$，其中 $T=256$，$S=16$，测试密度 $p \\in \\{0.05, 0.10, 0.20, 0.30, 0.40\\}$。\n\n答案规格：\n- 对于上述三个案例中的每一个，使用上面的定义计算估计的 $p^{\\star}$，并将每个结果四舍五入到两位小数。\n- 如果在测试的网格内未找到临界密度（即稳定化比例从未达到 0.5），则该案例输出 $-1.00$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按案例 1 到 3 的顺序排列结果，例如：“[$p^{\\star}_{\\mathrm{GoL}},$ $p^{\\star}_{110},$ $p^{\\star}_{30}$]”。这些值必须打印为四舍五入到两位小数的浮点数。\n\n此问题不涉及角度或物理单位，因此不需要单位说明。",
            "solution": "用户提供了一个有效、适定且具有科学依据的计算问题。任务是估计三个不同细胞自动机系统中出现简单周期性行为的临界参数，即初始密度 $p^{\\star}$。该问题根植于复杂系统这一经典领域，特别是关于 Wolfram 的初级细胞自动机 (CA) 和 Conway 的生命游戏 (GoL) 的动力学。所有参数、定义和程序都以足够的严谨性进行了规定，从而可以得到唯一且可验证的解。\n\n该问题将通过按规定实现蒙特卡洛模拟协议来解决。对于每个系统和给定离散集合中的每个候选密度 $p$，我们将模拟自动机在指定试验次数和时间步数内的演化。然后，我们将根据系统达到稳定状态的经验概率来确定临界密度 $p^{\\star}$。\n\n每个测试案例的总体方法由以下几个关键阶段组成：\n$1$. **系统初始化**：对于 $S$ 次独立试验中的每一次，生成一个初始构型。这是一个细胞网格（对于初级 CA，是大小为 $M$ 的一维环；对于 GoL，是大小为 $N \\times N$ 的二维环面），其中每个细胞以概率 $p$ 设置为状态 1（活），以概率 $1-p$ 设置为状态 0（死）。这是通过对每个位点从伯努利分布中抽样来实现的。\n\n$2$. **时间演化**：自动机同步演化 $T$ 个离散时间步。在每一步 $t$，时间 $t+1$ 时每个细胞的状态是根据其在时间 $t$ 时的局部邻域状态计算得出的。更新规则是确定性的，并同时应用于所有细胞。为了管理边界效应并保持空间均匀性，所有模拟都采用周期性（环形）边界条件。\n\n$3$. **稳定性评估**：该协议将稳定性定义为出现周期为 1 或 2 的周期性构型。这在模拟范围的末尾，即时间 $T$ 进行测试。如果自动机在时间 $T$ 的全局状态（表示为 $X_{T}$）与前一步 $X_{T-1}$ 或再前一步 $X_{T-2}$ 的状态相同，则该试验被视为稳定。也就是说，条件是 $X_{T} = X_{T-1} \\lor X_{T} = X_{T-2}$。为了执行此检查，必须存储最后三个时间步（$T-2$、$T-1$ 和 $T$）的构型。\n\n$4$. **$p^{\\star}$ 的统计估计**：对于给定的密度 $p$，稳定化的经验概率 $\\hat{q}(p)$ 计算为满足稳定性标准的 $S$ 次试验的比例。然后，临界密度 $p^{\\star}$ 定义为测试集合 $\\{0.05, 0.10, 0.20, 0.30, 0.40\\}$ 中使得 $\\hat{q}(p) \\ge 0.5$ 的最小密度 $p$。如果没有测试的密度满足此条件，则将 $p^{\\star}$ 指定为 $-1.0$。\n\n三个测试案例的具体更新规则实现如下：\n\n**案例 1：Conway 的生命游戏 (GoL)**\nGoL 在一个二维网格上演化。一个细胞的邻域由其 8 个相邻细胞（摩尔邻域）组成。更新规则，称为 B3/S23，是：\n- 一个恰好有 3 个活邻居的死细胞变为活细胞（诞生）。\n- 一个有 2 或 3 个活邻居的活细胞保持存活（存活）。\n- 在所有其他情况下，细胞会因为过度拥挤或孤独而变为或保持死亡状态。\n可以使用二维卷积高效地计算网格中每个细胞的活邻居数量。一个核矩阵 $K = \\begin{pmatrix} 1  1  1 \\\\ 1  0  1 \\\\ 1  1  1 \\end{pmatrix}$ 与二元状态网格进行卷积。周期性边界条件通过卷积函数的 ‘wrap’ 模式来处理。\n\n**案例 2 和 3：初级细胞自动机（规则 $110$ 和 $30$）**\n初级 CA 在一维环上演化。细胞 $x_i$ 在时间 $t+1$ 的状态由其在时间 $t$ 的半径为 1 的邻域 $\\{x_{i-1}(t), x_i(t), x_{i+1}(t)\\}$ 的状态决定。有 $2^3 = 8$ 种可能的邻域构型，可以解释为从 $(0,0,0)$ 到 $(1,1,1)$ 的 3 位二进制数，对应整数值 0 到 7。Wolfram 规则数 $R \\in \\{0, \\dots, 255\\}$ 是一个 8 位整数。$R$ 的第 $k$ 位（从右到左，0-索引）指定了整数值为 $k$ 的邻域构型的输出状态。\n例如，对于规则 $R=30$，其二进制表示为 $00011110_2$。对于邻域 $(0,0,0)$ 到 $(1,1,1)$，规则的查找表分别为 $[0, 1, 1, 1, 1, 0, 0, 0]$。整个网格的更新可以被高效地向量化。对于一个网格 `c`，所有细胞的邻域索引计算为 $4 \\times \\text{roll}(c, 1) + 2 \\times c + 1 \\times \\text{roll}(c, -1)$，其中 `roll` 执行循环移位。然后通过使用这个索引数组对规则的查找表进行索引来生成新的网格。同样的过程也适用于规则 $R=110$ 和规则 $R=30$。\n\n规则 $30$ 以其混沌行为（Wolfram III 类）而闻名，使其成为伪随机数生成器的候选者。其动力学高度不可预测，不太可能稳定到简单的周期轨道上。规则 $110$ 是一个 IV 类自动机，以其支持复杂、持久结构（滑翔机）的能力而闻名，并且是计算上通用的。这种复杂性也表明它可能不容易稳定。GoL 以其丰富的模式“动物园”而著称，从简单的静态或振荡形式到复杂的“滑翔机”和“宇宙飞船”，其最终命运对初始密度高度敏感。将执行指定的协议，以量化这三个不同系统在随机初始条件下稳定的倾向。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef solve():\n    \"\"\"\n    Main function to run the cellular automata simulations and find the critical densities.\n    \"\"\"\n\n    # For reproducibility of the entire set of results.\n    np.random.seed(42)\n\n    # --- Helper functions for simulations ---\n\n    def _get_eca_lookup_table(rule_number):\n        \"\"\"Generates the lookup table for a Wolfram elementary CA rule.\"\"\"\n        if not (0 = rule_number = 255):\n            raise ValueError(\"Rule number must be between 0 and 255.\")\n        # The binary string corresponds to neighborhoods 7 down to 0.\n        # We reverse it to map index k to neighborhood k.\n        binary_string = f'{rule_number:08b}'\n        return np.array([int(bit) for bit in binary_string], dtype=np.int8)[::-1]\n\n    ECA_LOOKUP_TABLES = {\n        30: _get_eca_lookup_table(30),\n        110: _get_eca_lookup_table(110)\n    }\n\n    def _estimate_p_star_eca(M, R, T, S, p_grid):\n        \"\"\"\n        Estimates the critical density p* for an elementary cellular automaton.\n        \"\"\"\n        lookup_table = ECA_LOOKUP_TABLES[R]\n        for p in p_grid:\n            stable_count = 0\n            for _ in range(S):\n                # 1. Initialization\n                grid = (np.random.rand(M)  p).astype(np.int8)\n                \n                # History stores [t-2, t-1, t]\n                history = [None, None, grid.copy()]\n\n                # 2. Temporal Evolution\n                for _ in range(T):\n                    # Efficiently calculate neighborhood indices for all cells\n                    left_shifted = np.roll(grid, 1)\n                    right_shifted = np.roll(grid, -1)\n                    indices = 4 * left_shifted + 2 * grid + 1 * right_shifted\n                    \n                    grid = lookup_table[indices]\n\n                    # Update history\n                    history[0] = history[1]\n                    history[1] = history[2]\n                    history[2] = grid.copy()\n\n                # 3. Stability Assessment\n                is_period_1 = np.array_equal(history[2], history[1])\n                is_period_2 = (history[0] is not None) and np.array_equal(history[2], history[0])\n                \n                if is_period_1 or is_period_2:\n                    stable_count += 1\n            \n            # 4. Statistical Estimation\n            q_hat = stable_count / S\n            if q_hat >= 0.5:\n                return p\n        \n        return -1.0\n    \n    def _estimate_p_star_gol(N, T, S, p_grid):\n        \"\"\"\n        Estimates the critical density p* for Conway's Game of Life.\n        \"\"\"\n        # Kernel for counting neighbors using convolution\n        kernel = np.array([[1, 1, 1], \n                           [1, 0, 1], \n                           [1, 1, 1]], dtype=np.int8)\n        \n        for p in p_grid:\n            stable_count = 0\n            for _ in range(S):\n                # 1. Initialization\n                grid = (np.random.rand(N, N)  p).astype(np.int8)\n                history = [None, None, grid.copy()]\n\n                # 2. Temporal Evolution\n                for _ in range(T):\n                    # Count neighbors using convolution with 'wrap' for toroidal boundaries\n                    neighbor_counts = convolve2d(grid, kernel, mode='same', boundary='wrap')\n                    \n                    # Apply GoL rules (B3/S23)\n                    # Birth: dead cell (grid==0) with 3 neighbors becomes live\n                    births = (grid == 0)  (neighbor_counts == 3)\n                    # Survival: live cell (grid==1) with 2 or 3 neighbors stays live\n                    survivals = (grid == 1)  ((neighbor_counts == 2) | (neighbor_counts == 3))\n                    \n                    grid = (births | survivals).astype(np.int8)\n                    \n                    # Update history\n                    history[0] = history[1]\n                    history[1] = history[2]\n                    history[2] = grid.copy()\n\n                # 3. Stability Assessment\n                is_period_1 = np.array_equal(history[2], history[1])\n                is_period_2 = (history[0] is not None) and np.array_equal(history[2], history[0])\n\n                if is_period_1 or is_period_2:\n                    stable_count += 1\n            \n            # 4. Statistical Estimation\n            q_hat = stable_count / S\n            if q_hat >= 0.5:\n                return p\n\n        return -1.0\n\n    # --- Define and run test cases ---\n\n    test_cases = [\n        {\n            \"id\": \"GoL\", \"func\": _estimate_p_star_gol,\n            \"params\": {\"N\": 64, \"T\": 256, \"S\": 16, \"p_grid\": [0.05, 0.10, 0.20, 0.30, 0.40]}\n        },\n        {\n            \"id\": \"Rule 110\", \"func\": _estimate_p_star_eca,\n            \"params\": {\"M\": 256, \"R\": 110, \"T\": 256, \"S\": 16, \"p_grid\": [0.05, 0.10, 0.20, 0.30, 0.40]}\n        },\n        {\n            \"id\": \"Rule 30\", \"func\": _estimate_p_star_eca,\n            \"params\": {\"M\": 256, \"R\": 30, \"T\": 256, \"S\": 16, \"p_grid\": [0.05, 0.10, 0.20, 0.30, 0.40]}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = case[\"func\"](**case[\"params\"])\n        results.append(result)\n\n    # --- Format and print the final output ---\n    \n    # The format string ensures two decimal places, e.g., 0.1 -> \"0.10\", -1.0 -> \"-1.00\"\n    formatted_results = [f\"{r:.2f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}