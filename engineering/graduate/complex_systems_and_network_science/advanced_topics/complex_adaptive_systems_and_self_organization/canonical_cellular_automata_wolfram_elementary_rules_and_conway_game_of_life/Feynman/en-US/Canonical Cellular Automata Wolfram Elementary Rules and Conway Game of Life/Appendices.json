{
    "hands_on_practices": [
        {
            "introduction": "The Wolfram numbering system is a cornerstone for the study of elementary cellular automata, providing a concise label for each of the 256 possible local update rules. This practice guides you through the reverse process: translating a given rule number back into its fundamental truth table, which specifies the output for every possible neighborhood. Mastering this conversion is a crucial first step toward simulating or analyzing these complex systems from first principles, connecting the abstract integer representation to the concrete logical function it encodes .",
            "id": "4266078",
            "problem": "Consider an Elementary Cellular Automaton (ECA), defined as a one-dimensional Cellular Automaton (CA) with binary states and nearest-neighbor interactions. Formally, let the local update rule be a Boolean function $f:\\{0,1\\}^3 \\to \\{0,1\\}$ that maps a neighborhood triplet $(x_{i-1}(t), x_i(t), x_{i+1}(t)) \\in \\{0,1\\}^3$ to an updated state $x_i(t+1) \\in \\{0,1\\}$. The global dynamics apply $f$ synchronously to every site of a configuration to produce the next configuration.\n\nA canonical enumeration of all possible neighborhoods considers the eight binary triplets in descending lexicographic order:\n$$\n(1,1,1),\\ (1,1,0),\\ (1,0,1),\\ (1,0,0),\\ (0,1,1),\\ (0,1,0),\\ (0,0,1),\\ (0,0,0).\n$$\nFor any Boolean function $f:\\{0,1\\}^3 \\to \\{0,1\\}$, its truth table $v \\in \\{0,1\\}^8$ under this ordering is defined by\n$$\nv = \\big(f(1,1,1),\\ f(1,1,0),\\ f(1,0,1),\\ f(1,0,0),\\ f(0,1,1),\\ f(0,1,0),\\ f(0,0,1),\\ f(0,0,0)\\big).\n$$\nThe Wolfram code of an ECA rule is the integer $R \\in \\{0,\\dots,255\\}$ obtained by encoding the truth table in base $2$ under the standard convention used in the ECA literature. This establishes a bijection between integers in $\\{0,\\dots,255\\}$ and all Boolean functions on $\\{0,1\\}^3$.\n\nTask: Derive, from first principles of base-$2$ positional representation and the above canonical neighborhood ordering, an algorithm that, given $R \\in \\{0,\\dots,255\\}$, outputs the corresponding Boolean function $f$ in the form of its truth table vector $v \\in \\{0,1\\}^8$ aligned with the neighborhood order specified above. Your derivation must rely only on fundamental definitions and properties of binary representation and Boolean functions.\n\nYour program must implement this algorithm and evaluate it on the following test suite of Wolfram code integers:\n- $R=0$ (boundary case: all outputs $0$),\n- $R=1$ (boundary case: least significant bit set),\n- $R=30$ (canonical complex rule),\n- $R=90$ (canonical additive rule),\n- $R=110$ (canonical complex rule),\n- $R=128$ (boundary case: most significant bit set),\n- $R=255$ (boundary case: all outputs $1$).\n\nFor each test case, return the truth table vector $v$ as a list of eight integers in the fixed order corresponding to neighborhoods $(1,1,1)$, $(1,1,0)$, $(1,0,1)$, $(1,0,0)$, $(0,1,1)$, $(0,1,0)$, $(0,0,1)$, $(0,0,0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of the eight-entry lists, enclosed in square brackets. For example, the intended format is\n$$\n\\big[\\,[v_{R_1}],\\,[v_{R_2}],\\,\\dots\\,\\big]\n$$\nwhere each $[v_{R_k}]$ is itself a list of eight integers. No physical units or angle units are involved in this problem, and all outputs are integers in $\\{0,1\\}$.",
            "solution": "The problem has been validated and is determined to be a well-posed and scientifically grounded question within the domain of computational science and complex systems. The task is to derive and implement an algorithm that converts a Wolfram code, an integer $R \\in \\{0, \\dots, 255\\}$, into its corresponding $8$-bit truth table vector $v$ for an Elementary Cellular Automaton (ECA).\n\n### Derivation from First Principles\n\nThe core of the problem lies in understanding the relationship between the integer $R$ and the truth table vector $v$. We will derive this relationship from the definitions provided and the fundamental principles of base-$2$ representation.\n\n**1. Formal Definition of the Wolfram Code**\n\nAn ECA's local update rule is a Boolean function $f:\\{0,1\\}^3 \\to \\{0,1\\}$. There are $2^3 = 8$ possible inputs (neighborhoods) to this function. The problem specifies a canonical ordering for these neighborhoods in descending lexicographic order:\n$$\n(1,1,1), (1,1,0), (1,0,1), (1,0,0), (0,1,1), (0,1,0), (0,0,1), (0,0,0)\n$$\nThe truth table for the function $f$ is an $8$-bit vector $v$, where each bit is the output of $f$ for the corresponding neighborhood in the specified order:\n$$\nv = (v_1, v_2, v_3, v_4, v_5, v_6, v_7, v_8)\n$$\nwhere $v_1 = f(1,1,1)$, $v_2 = f(1,1,0)$, and so on, until $v_8 = f(0,0,0)$.\n\nThe Wolfram code $R$ is defined as the integer whose base-$2$ representation is the vector $v$. The standard convention, which is consistent with the specified descending neighborhood order, treats $v_1$ as the most significant bit (MSB) and $v_8$ as the least significant bit (LSB).\n\nAccording to the principles of positional number systems, an $8$-bit binary number $(b_7 b_6 b_5 b_4 b_3 b_2 b_1 b_0)_2$ corresponds to the integer $N$ given by the polynomial in base $2$:\n$$\nN = \\sum_{i=0}^{7} b_i \\cdot 2^i = b_7 \\cdot 2^7 + b_6 \\cdot 2^6 + \\dots + b_0 \\cdot 2^0\n$$\nIn our case, the binary representation is given by the elements of $v$, where $v_1$ corresponds to the highest-power bit ($b_7$), $v_2$ to the next bit ($b_6$), and so on, down to $v_8$ which corresponds to the lowest-power bit ($b_0$). Mapping the indices, bit $v_k$ (for $k \\in \\{1, \\dots, 8\\}$) corresponds to the positional coefficient $b_{8-k}$. Therefore, the integer $R$ is defined as:\n$$\nR = v_1 \\cdot 2^7 + v_2 \\cdot 2^6 + v_3 \\cdot 2^5 + v_4 \\cdot 2^4 + v_5 \\cdot 2^3 + v_6 \\cdot 2^2 + v_7 \\cdot 2^1 + v_8 \\cdot 2^0 = \\sum_{k=1}^{8} v_k \\cdot 2^{8-k}\n$$\n\n**2. Derivation of the Inverse Mapping (R to v)**\n\nThe task is to perform the inverse operation: given an integer $R$, we must find the coefficients $v_k \\in \\{0,1\\}$ of its binary expansion. This is a standard base conversion procedure, which can be derived formally.\n\nLet's find a generic bit $v_k$ from $R$, for $k \\in \\{1, \\dots, 8\\}$. The bit $v_k$ is the coefficient of the term $2^{8-k}$. Let $p_k = 8-k$ be the power of $2$ corresponding to $v_k$. The powers $p_k$ range from $p_1=7$ (for MSB $v_1$) down to $p_8=0$ (for LSB $v_8$).\n\nTo isolate $v_k$, we can manipulate the expression for $R$. Let's divide $R$ by $2^{p_k}$:\n$$\n\\frac{R}{2^{p_k}} = \\frac{1}{2^{p_k}} \\sum_{j=1}^{8} v_j \\cdot 2^{8-j} = \\sum_{j=1}^{8} v_j \\cdot 2^{(8-j)-p_k}\n$$\nWe can split the sum at index $k$:\n$$\n\\frac{R}{2^{p_k}} = \\sum_{j=1}^{k} v_j \\cdot 2^{(p_j - p_k)} + \\sum_{j=k+1}^{8} v_j \\cdot 2^{(p_j - p_k)}\n$$\nThe first summation consists of terms with non-negative powers of $2$, while the second consists of terms with negative powers.\n$$\n\\frac{R}{2^{p_k}} = \\underbrace{(v_1 \\cdot 2^{p_1-p_k} + \\dots + v_{k-1} \\cdot 2^{p_{k-1}-p_k} + v_k \\cdot 2^0)}_{\\text{Integer Part}} + \\underbrace{(v_{k+1} \\cdot 2^{-1} + \\dots + v_8 \\cdot 2^{-(8-k)})}_{\\text{Fractional Part}}\n$$\nBy taking the floor of this expression, we eliminate the fractional part:\n$$\n\\left\\lfloor \\frac{R}{2^{p_k}} \\right\\rfloor = v_1 \\cdot 2^{p_1-p_k} + \\dots + v_{k-1} \\cdot 2^{1} + v_k\n$$\nEvery term in the sum, except for the last one ($v_k$), is a multiple of $2$. Therefore, if we take this entire expression modulo $2$, we isolate $v_k$:\n$$\n\\left\\lfloor \\frac{R}{2^{p_k}} \\right\\rfloor \\pmod 2 = (v_1 \\cdot 2^{p_1-p_k} + \\dots + v_{k-1} \\cdot 2^{1} + v_k) \\pmod 2 = v_k\n$$\nThis gives us a direct formula for each bit $v_k$:\n$$\nv_k = \\left\\lfloor \\frac{R}{2^{8-k}} \\right\\rfloor \\pmod 2, \\quad \\text{for } k=1, 2, \\dots, 8.\n$$\n\n**3. Algorithmic Procedure**\n\nThe derived formula translates directly into an algorithm. To construct the vector $v = (v_1, \\dots, v_8)$, we can iterate from $k=1$ to $k=8$. In programming, integer division `R // (2**p)` corresponds to $\\lfloor R / 2^p \\rfloor$, and the modulo operator `... % 2` corresponds to $\\pmod 2$.\n\nMore efficiently, these operations can be implemented using bitwise operators. The operation $\\lfloor R / 2^p \\rfloor$ is equivalent to a bitwise right shift of $R$ by $p$ positions (denoted $R \\gg p$). The operation $\\pmod 2$ is equivalent to a bitwise AND with $1$ (denoted $\\land 1$).\n\nThus, the algorithm is as follows:\n1. Initialize an empty list for the truth table vector, $v$.\n2. Iterate with an index $k$ from $1$ to $8$. This corresponds to the components of $v$.\n3. For each $k$, calculate the corresponding bit position (power of $2$) as $p = 8 - k$. This will iterate $p$ from $7$ down to $0$.\n4. Calculate the bit value as $v_k = (R \\gg p) \\land 1$.\n5. Append this bit value to the list $v$.\n6. After the loop completes, the list $v$ contains the $8$ bits of the truth table in the correct order.\n\nThis algorithm is a direct implementation of the derived mathematical procedure and relies only on the fundamental properties of base-$2$ representation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# No external libraries are needed for this solution.\n\ndef solve():\n    \"\"\"\n    Solves the problem of converting Wolfram codes for Elementary Cellular Automata\n    into their corresponding truth table vectors.\n    \"\"\"\n\n    def get_truth_table_vector(wolfram_code: int) -> list[int]:\n        \"\"\"\n        Derives the 8-bit truth table vector from an ECA Wolfram code.\n\n        The Wolfram code R is the integer representation of the 8-bit truth table\n        v = (v1, v2, ..., v8), where v1 is the most significant bit.\n        The truth table bits correspond to the neighborhood outputs in the order:\n        (1,1,1), (1,1,0), (1,0,1), (1,0,0), (0,1,1), (0,1,0), (0,0,1), (0,0,0).\n\n        The bit v_k corresponds to the coefficient of 2^(8-k). It can be extracted\n        using bitwise operations. The bit at position p (from the right, 0-indexed)\n        is found by (R >> p) & 1.\n        For v1, p=7. For v2, p=6, ..., for v8, p=0.\n\n        Args:\n            wolfram_code: An integer between 0 and 255.\n\n        Returns:\n            A list of 8 integers (0 or 1) representing the truth table.\n        \"\"\"\n        if not 0 <= wolfram_code <= 255:\n            raise ValueError(\"Wolfram code must be between 0 and 255.\")\n\n        vector = []\n        # The powers of 2 for the bits range from 7 (MSB) down to 0 (LSB).\n        for power in range(7, -1, -1):\n            # Isolate the bit at the current power's position.\n            # (wolfram_code >> power) shifts the bit to the LSB position.\n            # & 1 extracts this bit's value.\n            bit = (wolfram_code >> power) & 1\n            vector.append(bit)\n        \n        return vector\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0,   # Boundary case: all outputs 0\n        1,   # Boundary case: least significant bit set\n        30,  # Canonical complex rule\n        90,  # Canonical additive rule\n        110, # Canonical complex rule\n        128, # Boundary case: most significant bit set\n        255  # Boundary case: all outputs 1\n    ]\n\n    results = []\n    for R in test_cases:\n        truth_table = get_truth_table_vector(R)\n        results.append(truth_table)\n\n    # Final print statement in the exact required format.\n    # The default string representation of a list in Python includes spaces,\n    # which is consistent with the problem's LaTeX example format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While cellular automata evolve deterministically forward in time, reversing this process is not always straightforward or even possible. This exercise delves into the concepts of preimages and the \"Garden of Eden\"—configurations that have no predecessors and thus can only appear as initial states. By applying the powerful transfer matrix method, a key technique in statistical mechanics, you will count the number of predecessors for a specific configuration, gaining deep insight into the automaton's dynamical properties and information flow .",
            "id": "4266043",
            "problem": "Consider a binary, one-dimensional Elementary Cellular Automaton (ECA) on a periodic lattice (ring) of length $L$, with radius $r=1$ and the update rule given by Wolfram’s Rule $184$. The ECA state at time $t$ is denoted by a sequence $\\{s_i(t)\\}_{i=0}^{L-1}$ with $s_i(t) \\in \\{0,1\\}$, and periodic boundary conditions $s_{i+L}(t) = s_i(t)$. The local update rule produces the next state $s_i(t+1) = f(s_{i-1}(t), s_i(t), s_{i+1}(t))$ according to the truth table for Rule $184$:\n$$\nf(1,1,1)=1,\\quad f(1,1,0)=0,\\quad f(1,0,1)=1,\\quad f(1,0,0)=1,\\quad f(0,1,1)=1,\\quad f(0,1,0)=0,\\quad f(0,0,1)=0,\\quad f(0,0,0)=0.\n$$\nThis automaton is known to model conservative transport (traffic flow), where a $1$ represents a particle and a $0$ a vacancy.\n\nLet $L=20$ and define the target configuration $\\{t_i\\}_{i=0}^{19}$ by $t_i = i \\bmod 2$, i.e., the strictly alternating pattern $t = 0101\\cdots 01$ of length $20$ with $t_0=0$. A predecessor of $t$ is any configuration $\\{s_i\\}_{i=0}^{19} \\in \\{0,1\\}^{20}$ such that applying Rule $184$ once (with the ring topology) yields $t$.\n\nStarting from the fundamental definitions of cellular automata and their local map composition on a ring, derive a principled method to count the number $N$ of distinct predecessors of $t$ under Rule $184$. Based on your derivation, determine whether $t$ is a Garden of Eden (a configuration with zero predecessors).\n\nReport your final answer as the ordered pair $(N,g)$, where $N$ is the total number of predecessors of $t$, and $g$ equals $1$ if $t$ is a Garden of Eden and $0$ otherwise. No rounding is required, and no units are involved. Express the pair $(N,g)$ as instructed in the final answer format.",
            "solution": "The user wants to find the number of predecessors for a specific configuration in an elementary cellular automaton.\n\n### Step 1: Extract Givens\n- **System**: Binary, one-dimensional Elementary Cellular Automaton (ECA).\n- **Lattice**: Periodic ring of length $L=20$.\n- **Radius**: $r=1$.\n- **Update Rule**: Wolfram's Rule 184.\n- **Truth Table**:\n  - $f(1,1,1)=1$\n  - $f(1,1,0)=0$\n  - $f(1,0,1)=1$\n  - $f(1,0,0)=1$\n  - $f(0,1,1)=1$\n  - $f(0,1,0)=0$\n  - $f(0,0,1)=0$\n  - $f(0,0,0)=0$\n- **State notation**: $\\{s_i(t)\\}_{i=0}^{L-1}$, $s_i(t) \\in \\{0,1\\}$.\n- **Boundary conditions**: Periodic, $s_{i+L}(t) = s_i(t)$.\n- **Local update rule**: $s_i(t+1) = f(s_{i-1}(t), s_i(t), s_{i+1}(t))$.\n- **Target configuration**: $\\{t_i\\}_{i=0}^{19}$ with $t_i = i \\bmod 2$.\n- **Definition**: A predecessor of $t$ is a configuration $\\{s_i\\}$ such that applying Rule 184 once yields $t$.\n- **Definition**: A Garden of Eden is a configuration with zero predecessors.\n- **Objective**: Find the number of predecessors $N$ and a flag $g$ where $g=1$ if the configuration is a Garden of Eden and $g=0$ otherwise.\n- **Final Answer Format**: An ordered pair $(N, g)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, being a standard problem in the theory of cellular automata. It is well-posed, with all necessary parameters ($L$, rule, target configuration) explicitly defined. The language is objective and formal. The problem is self-contained, consistent, and requires a rigorous, non-trivial mathematical derivation. The concepts of predecessors and Garden of Eden are fundamental to the study of cellular automata dynamics.\n\n### Step 3: Verdict and Action\nThe problem is valid. A full solution will be derived.\n\n### Derivation\nA configuration $s = \\{s_i\\}_{i=0}^{L-1}$ is a predecessor of the target configuration $t = \\{t_i\\}_{i=0}^{L-1}$ if for every site $i \\in \\{0, 1, \\dots, L-1\\}$, the following equation holds:\n$$t_i = f(s_{i-1}, s_i, s_{i+1})$$\nwhere indices are taken modulo $L=20$. This constitutes a system of $20$ coupled non-linear equations for the variables $\\{s_i\\}$.\n\nThis system can be solved using the transfer matrix method. We define the \"state\" at each position $i$ by the pair of cell values $(s_{i-1}, s_i)$. There are $2^2=4$ possible states: $(0,0)$, $(0,1)$, $(1,0)$, and $(1,1)$. The local rule $t_i = f(s_{i-1}, s_i, s_{i+1})$ acts as a constraint on the transition from state $(s_{i-1}, s_i)$ at position $i$ to state $(s_i, s_{i+1})$ at position $i+1$.\n\nThe target configuration is given by $t_i = i \\bmod 2$, which results in the pattern $t = 010101\\cdots 01$. Since the value of $t_i$ depends on whether $i$ is even or odd, we must define two separate transfer matrices:\n1.  $M_0$ for even $i$, where $t_i=0$.\n2.  $M_1$ for odd $i$, where $t_i=1$.\n\nThe entry $(M_k)_{uv}$ of a transfer matrix is $1$ if a transition from state $u=(s_{i-1}, s_i)$ to state $v=(s_i, s_{i+1})$ is allowed under the constraint $t_i=k$, and $0$ otherwise. We map the states to indices as follows: $0 \\leftrightarrow (0,0)$, $1 \\leftrightarrow (0,1)$, $2 \\leftrightarrow (1,0)$, $3 \\leftrightarrow (1,1)$.\n\n**Constructing $M_0$ (for $t_i=0$):**\nThe set of input neighborhoods $(s_{i-1}, s_i, s_{i+1})$ that map to $0$ under Rule $184$ is:\n$\\{(1,1,0), (0,1,0), (0,0,1), (0,0,0)\\}$.\n- From state $(0,0)$: Neighborhoods are $(0,0,0)$ and $(0,0,1)$. These lead to next states $(0,0)$ and $(0,1)$.\n- From state $(0,1)$: Neighborhood is $(0,1,0)$, leading to next state $(1,0)$.\n- From state $(1,0)$: No neighborhood starts with $(1,0)$ and maps to $0$.\n- From state $(1,1)$: Neighborhood is $(1,1,0)$, leading to next state $(1,0)$.\nThis gives the matrix:\n$$M_0 = \\begin{pmatrix} 1 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix}$$\n\n**Constructing $M_1$ (for $t_i=1$):**\nThe set of input neighborhoods that map to $1$ is:\n$\\{(1,1,1), (1,0,1), (1,0,0), (0,1,1)\\}$.\n- From state $(0,0)$: No neighborhood starts with $(0,0)$ and maps to $1$.\n- From state $(0,1)$: Neighborhood is $(0,1,1)$, leading to next state $(1,1)$.\n- From state $(1,0)$: Neighborhoods are $(1,0,0)$ and $(1,0,1)$. These lead to next states $(0,0)$ and $(0,1)$.\n- From state $(1,1)$: Neighborhood is $(1,1,1)$, leading to next state $(1,1)$.\nThis gives the matrix:\n$$M_1 = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}$$\n\nThe total number of predecessor configurations $N$ is the number of valid closed paths of length $L=20$ around the ring. This is given by the trace of the total transfer matrix $M_{total}$. The total matrix is the product of the individual matrices for each site, in reverse order of their indices.\n$$M_{total} = M_{t_{19}} M_{t_{18}} \\cdots M_{t_1} M_{t_0}$$\nGiven $t=0101\\dots01$, we have $t_0=0, t_1=1, t_2=0, \\dots, t_{18}=0, t_{19}=1$.\n$$M_{total} = M_1 M_0 M_1 M_0 \\cdots M_1 M_0 = (M_1 M_0)^{10}$$\n\nLet's compute the product $A = M_1 M_0$:\n$$A = M_1 M_0 = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ 1 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 1 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix}$$\nWe need to compute $N = \\text{Tr}(A^{10})$. We can do this by finding a general form for $A^n$. Let $F_n$ be the $n$-th Fibonacci number, with $F_0=0, F_1=1, F_2=1, \\dots$.\nLet's hypothesize a form for $A^n$ for $n \\ge 1$:\n$$A^n = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ F_{n-1} & F_{n-1} & F_{n} & 0 \\\\ F_{n} & F_{n} & F_{n+1} & 0 \\\\ F_{n-1} & F_{n-1} & F_{n} & 0 \\end{pmatrix}$$\n(with the convention $F_{-1}=1$).\nLet's check for $n=1$: $A^1 = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ F_0 & F_0 & F_1 & 0 \\\\ F_1 & F_1 & F_2 & 0 \\\\ F_0 & F_0 & F_1 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 1 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix}$. This matches our matrix $A$.\n\nWe prove the form by induction. Assume it holds for $n$. Then for $n+1$:\n$$A^{n+1} = A^n A = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ F_{n-1} & F_{n-1} & F_{n} & 0 \\\\ F_{n} & F_{n} & F_{n+1} & 0 \\\\ F_{n-1} & F_{n-1} & F_{n} & 0 \\end{pmatrix} \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 1 & 1 & 1 & 0 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix}$$\nMultiplying the third row of $A^n$ by $A$:\n$$(F_n, F_n, F_{n+1}, 0) \\cdot A = (F_{n+1}, F_{n+1}, F_n+F_{n+1}, 0) = (F_{n+1}, F_{n+1}, F_{n+2}, 0)$$\nThis is consistent with the hypothesized form for row 3 of $A^{n+1}$.\nMultiplying the second row of $A^n$ by $A$:\n$$(F_{n-1}, F_{n-1}, F_{n}, 0) \\cdot A = (F_n, F_n, F_{n-1}+F_n, 0) = (F_n, F_n, F_{n+1}, 0)$$\nThis is consistent with the form for row 2 of $A^{n+1}$. The fourth row is identical to the second. The first row remains zero. The induction holds.\n\nNow we can compute $N = \\text{Tr}(A^{10})$:\n$$A^{10} = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ F_{9} & F_{9} & F_{10} & 0 \\\\ F_{10} & F_{10} & F_{11} & 0 \\\\ F_9 & F_9 & F_{10} & 0 \\end{pmatrix}$$\n$$N = \\text{Tr}(A^{10}) = 0 + F_9 + F_{11} + 0 = F_9 + F_{11}$$\nWe compute the required Fibonacci numbers:\n$F_0=0, F_1=1, F_2=1, F_3=2, F_4=3, F_5=5, F_6=8, F_7=13, F_8=21, F_9=34, F_{10}=55, F_{11}=89$.\n$$N = 34 + 89 = 123$$\nThe number of distinct predecessors is $N=123$.\n\nA configuration is a Garden of Eden if it has zero predecessors, i.e., $N=0$. Since $N=123 \\ne 0$, the target configuration $t$ is not a Garden of Eden. The indicator variable $g$ is therefore $0$.\n\nThe final answer is the ordered pair $(N,g) = (123,0)$.\nThis result can be cross-checked using the eigenvalues of $A$. The characteristic polynomial is $\\det(A-\\lambda I) = \\lambda^2(\\lambda^2-\\lambda-1)$. The eigenvalues are $\\lambda=0$ (multiplicity 2), $\\lambda=\\phi = \\frac{1+\\sqrt{5}}{2}$, and $\\lambda=1-\\phi = \\frac{1-\\sqrt{5}}{2}$. The matrix is diagonalizable, so $\\text{Tr}(A^{10}) = \\sum \\lambda_i^{10} = 0^{10} + 0^{10} + \\phi^{10} + (1-\\phi)^{10}$. This sum is the definition of the $10$-th Lucas number, $L_{10}$. The sequence of Lucas numbers begins $L_0=2, L_1=1, L_2=3, \\dots$ with the recurrence $L_n=L_{n-1}+L_{n-2}$. We find $L_{10}=123$. The identity $L_n=F_{n-1}+F_{n+1}$ further confirms that $L_{10} = F_9+F_{11}$, validating our matrix exponentiation result.",
            "answer": "$$ \\boxed{\\begin{pmatrix} 123 & 0 \\end{pmatrix}} $$"
        },
        {
            "introduction": "The long-term behavior of a cellular automaton evolving from a random configuration is a central question in the science of complexity. This simulation-based practice invites you to explore the statistical tendencies of iconic systems like Conway's Game of Life, the chaotic Rule 30, and the complex Rule 110. By empirically estimating the critical initial density at which stable patterns emerge, you will develop a practical understanding of emergent phenomena, phase transitions, and the foundational Wolfram classes of computational behavior .",
            "id": "4266022",
            "problem": "Consider binary-state Cellular Automata (CA) under the canonical update rules of Wolfram's elementary CA and Conway's Game of Life (GoL). Let the state space be discrete and finite, and let time advance in discrete steps. The fundamental base of this problem is the definition of deterministic local update rules applied synchronously to all sites, and the probabilistic initialization of configurations by independent and identically distributed Bernoulli trials.\n\nDefinitions and setup:\n- A one-dimensional elementary CA consists of a ring of $M$ cells with binary states $\\{0,1\\}$, updated synchronously at time $t \\mapsto t+1$ according to a mapping determined by a Wolfram rule number $R \\in \\{0,1,\\dots,255\\}$. Each site update depends on its radius-$1$ neighborhood $\\{x_{i-1}(t), x_{i}(t), x_{i+1}(t)\\}$.\n- Conway's Game of Life (GoL) consists of a two-dimensional toroidal lattice of size $N \\times N$ with binary states $\\{0,1\\}$. The update rule at time $t \\mapsto t+1$ is: a live cell remains live if it has exactly $2$ or $3$ live neighbors; a dead cell becomes live if it has exactly $3$ live neighbors; otherwise the cell becomes or remains dead. Neighbor counts are computed from the $8$ nearest neighbors on the torus.\n- A random initial configuration with density $p \\in [0,1]$ is generated by independent Bernoulli trials where each site is live (state $1$) with probability $p$ and dead (state $0$) with probability $1-p$.\n- A configuration is called eventually periodic with period less than or equal to $2$ if there exists a finite transient time after which the global configuration satisfies $X_{t} = X_{t-1}$ (period $1$) or $X_{t} = X_{t-2}$ (period $2$). We call the emergence of such eventual periodicity the emergence of stable structures.\n\nObjective:\nFor random initial configurations with density $p$, estimate the critical $p$ at which stable structures emerge, defined as the smallest $p$ in a given discrete set of densities for which the empirical probability of stabilization (eventual period less than or equal to $2$ within a fixed time horizon) is at least $0.5$. Then compare the estimates to qualitative empirical findings reported for canonical rules.\n\nEstimation protocol:\n- For each selected $p$, run $S$ independent trials (each trial uses an independent random seed), evolve the CA for $T$ steps from the random initial configuration, and test whether the final configuration $X_{T}$ satisfies $X_{T}=X_{T-1}$ or $X_{T}=X_{T-2}$. Let $\\hat{q}(p)$ denote the fraction of trials that satisfy this stability criterion.\n- Define the estimated critical density $p^{\\star}$ as the smallest tested density $p$ such that $\\hat{q}(p) \\ge 0.5$. If no tested $p$ achieves $\\hat{q}(p) \\ge 0.5$, then output $-1.0$ for the estimate to indicate \"not found within grid.\"\n\nScientific realism and constraints:\n- All simulations use toroidal boundary conditions to avoid boundary artifacts and to ensure spatial homogeneity.\n- The test horizon $T$ and the number of trials $S$ are finite, acknowledging that an eventual period might occur after time $T$, but the estimation criterion uses the observed horizon.\n\nTest suite:\nEvaluate three cases to exercise different facets of the dynamics:\n1. GoL on an $N \\times N$ torus with $N=64$, $T=256$, $S=16$, and tested densities $p \\in \\{0.05, 0.10, 0.20, 0.30, 0.40\\}$.\n2. Elementary CA rule $R=110$ on a one-dimensional ring of size $M=256$, $T=256$, $S=16$, and tested densities $p \\in \\{0.05, 0.10, 0.20, 0.30, 0.40\\}$.\n3. Elementary CA rule $R=30$ on a one-dimensional ring of size $M=256$, $T=256$, $S=16$, and tested densities $p \\in \\{0.05, 0.10, 0.20, 0.30, 0.40\\}$.\n\nAnswer specification:\n- For each of the above three cases, compute the estimated $p^{\\star}$ using the definition above, and round each result to two decimal places.\n- If no critical density is found within the tested grid (i.e., the stabilization fraction never reaches $0.5$), output $-1.00$ for that case.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of cases $1$ to $3$, for example: \"[$p^{\\star}_{\\mathrm{GoL}},$ $p^{\\star}_{110},$ $p^{\\star}_{30}$]\". The values must be printed as floats rounded to two decimal places.\n\nNo angles or physical units are involved in this problem, so no unit specification is required.",
            "solution": "The user has provided a valid, well-posed, and scientifically grounded computational problem. The task is to estimate a critical parameter, the initial density $p^{\\star}$, for the emergence of simple periodic behavior in three distinct cellular automata systems. The problem is rooted in the canonical field of complex systems, specifically concerning the dynamics of Wolfram's elementary Cellular Automata (CA) and Conway's Game of Life (GoL). All parameters, definitions, and procedures are specified with sufficient rigor to permit a unique and verifiable solution.\n\nThe problem will be solved by implementing a Monte Carlo simulation protocol as specified. For each system and for each candidate density $p$ from a given discrete set, we will simulate the automaton's evolution for a specified number of trials and timesteps. We will then determine the critical density $p^{\\star}$ based on the empirical probability of the system reaching a stable state.\n\nThe overall methodology is composed of several key stages for each test case:\n$1$. **System Initialization**: For each of the $S$ independent trials, an initial configuration is generated. This is a grid of cells (a $1$D ring of size $M$ for elementary CA, or a $2$D torus of size $N \\times N$ for GoL) where each cell is set to state $1$ (live) with probability $p$ and state $0$ (dead) with probability $1-p$. This is achieved by sampling from a Bernoulli distribution for each site.\n\n$2$. **Temporal Evolution**: The automaton is evolved synchronously for $T$ discrete time steps. At each step $t$, the state of every cell at time $t+1$ is calculated based on the states of its local neighborhood at time $t$. The update rules are deterministic and are applied to all cells simultaneously. To manage boundary effects and maintain spatial homogeneity, all simulations employ periodic (toroidal) boundary conditions.\n\n$3$. **Stability Assessment**: The protocol defines stability as the emergence of a configuration that is periodic with a period of $1$ or $2$. This is tested at the end of the simulation horizon, at time $T$. A trial is deemed stable if the global state of the automaton at time $T$, denoted $X_{T}$, is identical to the state at the previous step, $X_{T-1}$, or the step before that, $X_{T-2}$. That is, the condition is $X_{T} = X_{T-1} \\lor X_{T} = X_{T-2}$. To perform this check, the configurations from the last three time steps ($T-2$, $T-1$, and $T$) must be stored.\n\n$4$. **Statistical Estimation of $p^{\\star}$**: For a given density $p$, the empirical probability of stabilization, $\\hat{q}(p)$, is calculated as the fraction of the $S$ trials that meet the stability criterion. The critical density, $p^{\\star}$, is then defined as the smallest density $p$ in the tested set $\\{0.05, 0.10, 0.20, 0.30, 0.40\\}$ for which $\\hat{q}(p) \\ge 0.5$. If no tested density satisfies this condition, $p^{\\star}$ is designated as $-1.0$.\n\nThe specific update rules for the three test cases are implemented as follows:\n\n**Case 1: Conway's Game of Life (GoL)**\nGoL evolves on a $2$D grid. The neighborhood of a cell consists of its $8$ adjacent cells (the Moore neighborhood). The update rule, known as B3/S23, is:\n- A dead cell with exactly $3$ live neighbors becomes live (Birth).\n- A live cell with $2$ or $3$ live neighbors remains live (Survival).\n- In all other cases, a cell becomes or remains dead (due to Overpopulation or Loneliness).\nThe number of live neighbors for every cell in the grid can be computed efficiently using a $2$D convolution. A kernel matrix, $K = \\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & 0 & 1 \\\\ 1 & 1 & 1 \\end{pmatrix}$, is convolved with the binary state grid. The periodic boundary condition is handled by the 'wrap' mode of the convolution function.\n\n**Cases 2 & 3: Elementary Cellular Automata (Rules $110$ and $30$)**\nElementary CAs evolve on a $1$D ring. The state of a cell $x_i$ at time $t+1$ is determined by the states of its radius-$1$ neighborhood $\\{x_{i-1}(t), x_i(t), x_{i+1}(t)\\}$ at time $t$. There are $2^3 = 8$ possible neighborhood configurations, which can be interpreted as $3$-bit binary numbers from $(0,0,0)$ to $(1,1,1)$, corresponding to integer values $0$ to $7$. A Wolfram rule number $R \\in \\{0, \\dots, 255\\}$ is an $8$-bit integer. The $k$-th bit of $R$ (from right to left, $0$-indexed) specifies the output state for the neighborhood configuration with integer value $k$.\nFor example, for rule $R=30$, its binary representation is $00011110_2$. The rule's lookup table is $[0, 1, 1, 1, 1, 0, 0, 0]$ for neighborhoods $(0,0,0)$ through $(1,1,1)$ respectively. The update for the entire grid can be vectorized efficiently. For a grid `c`, the neighborhood indices for all cells are calculated as $4 \\times \\text{roll}(c, 1) + 2 \\times c + 1 \\times \\text{roll}(c, -1)$, where `roll` performs a circular shift. The new grid is then generated by indexing the rule's lookup table with this array of indices. This same procedure is applied for both Rule $R=110$ and Rule $R=30$.\n\nRule $30$ is known for its chaotic behavior (Wolfram Class III), making it a candidate for a pseudo-random number generator. Its dynamics are highly unpredictable and unlikely to settle into simple periodic orbits. Rule $110$ is a Class IV automaton, known for its ability to support complex, persistent structures (gliders) and is computationally universal. This complexity also suggests it may not readily stabilize. GoL is famed for its rich zoo of patterns, from simple static or oscillating forms to complex \"gliders\" and \"spaceships,\" and its fate is highly sensitive to initial density. The specified protocol will be executed to quantify the propensity of these three distinct systems to stabilize under random initial conditions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef solve():\n    \"\"\"\n    Main function to run the cellular automata simulations and find the critical densities.\n    \"\"\"\n\n    # For reproducibility of the entire set of results.\n    np.random.seed(42)\n\n    # --- Helper functions for simulations ---\n\n    def _get_eca_lookup_table(rule_number):\n        \"\"\"Generates the lookup table for a Wolfram elementary CA rule.\"\"\"\n        if not (0 <= rule_number <= 255):\n            raise ValueError(\"Rule number must be between 0 and 255.\")\n        # The binary string corresponds to neighborhoods 7 down to 0.\n        # We reverse it to map index k to neighborhood k.\n        binary_string = f'{rule_number:08b}'\n        return np.array([int(bit) for bit in binary_string], dtype=np.int8)[::-1]\n\n    ECA_LOOKUP_TABLES = {\n        30: _get_eca_lookup_table(30),\n        110: _get_eca_lookup_table(110)\n    }\n\n    def _estimate_p_star_eca(M, R, T, S, p_grid):\n        \"\"\"\n        Estimates the critical density p* for an elementary cellular automaton.\n        \"\"\"\n        lookup_table = ECA_LOOKUP_TABLES[R]\n        for p in p_grid:\n            stable_count = 0\n            for _ in range(S):\n                # 1. Initialization\n                grid = (np.random.rand(M) < p).astype(np.int8)\n                \n                # History stores [t-2, t-1, t]\n                history = [None, None, grid.copy()]\n\n                # 2. Temporal Evolution\n                for _ in range(T):\n                    # Efficiently calculate neighborhood indices for all cells\n                    left_shifted = np.roll(grid, 1)\n                    right_shifted = np.roll(grid, -1)\n                    indices = 4 * left_shifted + 2 * grid + 1 * right_shifted\n                    \n                    grid = lookup_table[indices]\n\n                    # Update history\n                    history[0] = history[1]\n                    history[1] = history[2]\n                    history[2] = grid.copy()\n\n                # 3. Stability Assessment\n                is_period_1 = np.array_equal(history[2], history[1])\n                is_period_2 = (history[0] is not None) and np.array_equal(history[2], history[0])\n                \n                if is_period_1 or is_period_2:\n                    stable_count += 1\n            \n            # 4. Statistical Estimation\n            q_hat = stable_count / S\n            if q_hat >= 0.5:\n                return p\n        \n        return -1.0\n    \n    def _estimate_p_star_gol(N, T, S, p_grid):\n        \"\"\"\n        Estimates the critical density p* for Conway's Game of Life.\n        \"\"\"\n        # Kernel for counting neighbors using convolution\n        kernel = np.array([[1, 1, 1], \n                           [1, 0, 1], \n                           [1, 1, 1]], dtype=np.int8)\n        \n        for p in p_grid:\n            stable_count = 0\n            for _ in range(S):\n                # 1. Initialization\n                grid = (np.random.rand(N, N) < p).astype(np.int8)\n                history = [None, None, grid.copy()]\n\n                # 2. Temporal Evolution\n                for _ in range(T):\n                    # Count neighbors using convolution with 'wrap' for toroidal boundaries\n                    neighbor_counts = convolve2d(grid, kernel, mode='same', boundary='wrap')\n                    \n                    # Apply GoL rules (B3/S23)\n                    # Birth: dead cell (grid==0) with 3 neighbors becomes live\n                    births = (grid == 0) & (neighbor_counts == 3)\n                    # Survival: live cell (grid==1) with 2 or 3 neighbors stays live\n                    survivals = (grid == 1) & ((neighbor_counts == 2) | (neighbor_counts == 3))\n                    \n                    grid = (births | survivals).astype(np.int8)\n                    \n                    # Update history\n                    history[0] = history[1]\n                    history[1] = history[2]\n                    history[2] = grid.copy()\n\n                # 3. Stability Assessment\n                is_period_1 = np.array_equal(history[2], history[1])\n                is_period_2 = (history[0] is not None) and np.array_equal(history[2], history[0])\n\n                if is_period_1 or is_period_2:\n                    stable_count += 1\n            \n            # 4. Statistical Estimation\n            q_hat = stable_count / S\n            if q_hat >= 0.5:\n                return p\n\n        return -1.0\n\n    # --- Define and run test cases ---\n\n    test_cases = [\n        {\n            \"id\": \"GoL\", \"func\": _estimate_p_star_gol,\n            \"params\": {\"N\": 64, \"T\": 256, \"S\": 16, \"p_grid\": [0.05, 0.10, 0.20, 0.30, 0.40]}\n        },\n        {\n            \"id\": \"Rule 110\", \"func\": _estimate_p_star_eca,\n            \"params\": {\"M\": 256, \"R\": 110, \"T\": 256, \"S\": 16, \"p_grid\": [0.05, 0.10, 0.20, 0.30, 0.40]}\n        },\n        {\n            \"id\": \"Rule 30\", \"func\": _estimate_p_star_eca,\n            \"params\": {\"M\": 256, \"R\": 30, \"T\": 256, \"S\": 16, \"p_grid\": [0.05, 0.10, 0.20, 0.30, 0.40]}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = case[\"func\"](**case[\"params\"])\n        results.append(result)\n\n    # --- Format and print the final output ---\n    \n    # The format string ensures two decimal places, e.g., 0.1 -> \"0.10\", -1.0 -> \"-1.00\"\n    formatted_results = [f\"{r:.2f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}