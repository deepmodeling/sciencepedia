{
    "hands_on_practices": [
        {
            "introduction": "在功能磁共振成像（fMRI）数据中，邻近大脑区域的信号往往会因为生理噪声和数据预处理的平滑效应而表现出虚假的相似性。本练习将指导您量化这种由空间邻近性引起的混淆效应，并推导出一个统计控制方法来校正功能连接估计，从而更准确地揭示真实的神经活动模式。",
            "id": "4277694",
            "problem": "考虑一项高阶研究生水平的研究，该研究探讨了在功能性磁共振成像 (fMRI) 测量的血氧水平依赖 (BOLD) 信号所衍生的脑网络功能连接性估计中，空间邻近性的混淆效应。设大脑活动在脑区（parcel）层面进行概括，脑区 $i$ 位于空间坐标 $\\mathbf{x}_i \\in \\mathbb{R}^3$ 处，脑区 $j$ 位于 $\\mathbf{x}_j \\in \\mathbb{R}^3$ 处。定义欧几里得距离 $d_{ij} = \\|\\mathbf{x}_i - \\mathbf{x}_j\\|$。\n\n假设每个观测到的脑区时间序列 $y_i(t)$ 是一个未观测到的神经信号 $s_i(t)$ 和一个源于非神经来源（例如，运动、血管系统或空间平滑的预处理伪影）的空间自相关混淆变量 $n(\\mathbf{x}_i, t)$ 的总和。形式上，\n$$\ny_i(t) = s_i(t) + n(\\mathbf{x}_i, t).\n$$\n假设 $s_i(t)$ 和 $n(\\mathbf{x}_i, t)$ 是零均值、宽平稳、相互独立的过程。设所有脑区的 $\\mathrm{Var}(s_i) = \\sigma_s^2$，并设神经信号的互协方差满足 $\\mathrm{Cov}(s_i, s_j) = \\rho_{ij} \\sigma_s^2$，其中 $\\rho_{ij} \\in [-1,1]$ 编码了独立于测量混淆的脑区 $i$ 和 $j$ 之间的真实功能耦合。\n\n将混淆变量 $n(\\mathbf{x}, t)$ 建模为一个以空间位置 $\\mathbf{x}$ 为索引的零均值高斯随机场 (GRF)，其协方差为\n$$\n\\mathrm{Cov}\\!\\big(n(\\mathbf{x}_i, t), n(\\mathbf{x}_j, t)\\big) = \\sigma_n^2 \\exp\\!\\left(-\\frac{d_{ij}^2}{2 \\ell^2}\\right),\n$$\n其中 $\\sigma_n^2 > 0$ 是混淆方差，$\\ell > 0$ 是空间相关长度尺度。假设时间序列足够长，使得样本相关性等于其系综期望。\n\n仅使用协方差、方差和皮尔逊相关性的核心定义，以及上述 GRF 协方差模型：\n\n1. 推导 $y_i(t)$ 和 $y_j(t)$ 之间的期望皮尔逊相关性，将其表示为 $d_{ij}$、$\\rho_{ij}$、$\\sigma_s^2$、$\\sigma_n^2$ 和 $\\ell$ 的函数。解释对于较小的 $d_{ij}$，空间邻近性如何夸大了这种观测到的相关性。\n\n2. 提出一种空间统计控制方法，以消除 GRF 引起的夸大。具体来说，通过回归剔除已知的 GRF 核贡献，或等效地，减去在距离 $d_{ij}$ 处的 GRF 期望，来构建期望相关性的无偏估计量。提供此无偏期望相关性关于 $\\rho_{ij}$、$\\sigma_s^2$ 和 $\\sigma_n^2$ 的闭式表达式。\n\n3. 对于一对具体的脑区，其参数为 $\\sigma_s^2 = 2$，$\\sigma_n^2 = 1$，$\\ell = 20$ mm，$d_{ij} = 10$ mm，以及 $\\rho_{ij} = 0.3$，计算该无偏期望相关性。将答案四舍五入到四位有效数字。将最终答案表示为一个无单位的实数。",
            "solution": "该问题经评估是有效的。它在科学上植根于应用于神经影像数据的信号处理和空间统计学原理，这是复杂系统和网络科学中的一个常见课题。该问题是适定的，提供了所有必要的变量、假设和定义，以推导出唯一解。语言客观且正式。\n\n### 第 1 部分：观测相关性的推导\n\n观测时间序列 $y_i(t)$ 和 $y_j(t)$ 之间的皮尔逊相关系数定义为：\n$$\n\\mathrm{Corr}(y_i, y_j) = \\frac{\\mathrm{Cov}(y_i, y_j)}{\\sqrt{\\mathrm{Var}(y_i) \\mathrm{Var}(y_j)}}\n$$\n我们必须首先推导分子和分母中的协方差和方差项。\n\n对于任何脑区 $k$，观测时间序列由模型 $y_k(t) = s_k(t) + n(\\mathbf{x}_k, t)$ 给出。为简单起见，我们记 $n_k(t) = n(\\mathbf{x}_k, t)$。\n\n$y_i(t)$ 和 $y_j(t)$ 之间的协方差是：\n$$\n\\mathrm{Cov}(y_i, y_j) = \\mathrm{Cov}(s_i + n_i, s_j + n_j)\n$$\n利用协方差算子的双线性：\n$$\n\\mathrm{Cov}(y_i, y_j) = \\mathrm{Cov}(s_i, s_j) + \\mathrm{Cov}(s_i, n_j) + \\mathrm{Cov}(n_i, s_j) + \\mathrm{Cov}(n_i, n_j)\n$$\n问题陈述中说明，神经信号 $s_k(t)$ 和混淆过程 $n_k(t)$ 是相互独立的。这意味着它们的协方差为零，即对于所有的 $i$ 和 $j$，$\\mathrm{Cov}(s_i, n_j) = 0$ 且 $\\mathrm{Cov}(n_i, s_j) = 0$。\n因此，表达式简化为：\n$$\n\\mathrm{Cov}(y_i, y_j) = \\mathrm{Cov}(s_i, s_j) + \\mathrm{Cov}(n_i, n_j)\n$$\n代入给定的信号和混淆的协方差表达式：\n$$\n\\mathrm{Cov}(s_i, s_j) = \\rho_{ij} \\sigma_s^2\n$$\n$$\n\\mathrm{Cov}(n_i, n_j) = \\mathrm{Cov}\\!\\big(n(\\mathbf{x}_i, t), n(\\mathbf{x}_j, t)\\big) = \\sigma_n^2 \\exp\\!\\left(-\\frac{d_{ij}^2}{2 \\ell^2}\\right)\n$$\n因此，总的观测协方差是：\n$$\n\\mathrm{Cov}(y_i, y_j) = \\rho_{ij} \\sigma_s^2 + \\sigma_n^2 \\exp\\!\\left(-\\frac{d_{ij}^2}{2 \\ell^2}\\right)\n$$\n接下来，我们计算观测时间序列 $y_i(t)$ 的方差。方差是变量与其自身的协方差。\n$$\n\\mathrm{Var}(y_i) = \\mathrm{Cov}(y_i, y_i) = \\mathrm{Cov}(s_i + n_i, s_i + n_i)\n$$\n$$\n\\mathrm{Var}(y_i) = \\mathrm{Var}(s_i) + \\mathrm{Var}(n_i) + 2\\mathrm{Cov}(s_i, n_i)\n$$\n由于独立性，$\\mathrm{Cov}(s_i, n_i) = 0$。信号的方差给出为 $\\mathrm{Var}(s_i) = \\sigma_s^2$。脑区 $i$ 处混淆的方差 $\\mathrm{Var}(n_i)$ 可以通过在其协方差函数中设置 $j=i$（因此 $d_{ii} = 0$）来找到：\n$$\n\\mathrm{Var}(n_i) = \\mathrm{Cov}(n_i, n_i) = \\sigma_n^2 \\exp\\!\\left(-\\frac{d_{ii}^2}{2 \\ell^2}\\right) = \\sigma_n^2 \\exp(0) = \\sigma_n^2\n$$\n所以，观测信号的总方差是：\n$$\n\\mathrm{Var}(y_i) = \\sigma_s^2 + \\sigma_n^2\n$$\n因为这对任何脑区 $i$ 都成立，所以我们也有 $\\mathrm{Var}(y_j) = \\sigma_s^2 + \\sigma_n^2$。\n\n现在我们可以组装皮尔逊相关性：\n$$\n\\mathrm{Corr}(y_i, y_j) = \\frac{\\rho_{ij} \\sigma_s^2 + \\sigma_n^2 \\exp\\!\\left(-\\frac{d_{ij}^2}{2 \\ell^2}\\right)}{\\sqrt{(\\sigma_s^2 + \\sigma_n^2)(\\sigma_s^2 + \\sigma_n^2)}} = \\frac{\\rho_{ij} \\sigma_s^2 + \\sigma_n^2 \\exp\\!\\left(-\\frac{d_{ij}^2}{2 \\ell^2}\\right)}{\\sigma_s^2 + \\sigma_n^2}\n$$\n这可以写成：\n$$\n\\mathrm{Corr}(y_i, y_j) = \\frac{\\rho_{ij} \\sigma_s^2}{\\sigma_s^2 + \\sigma_n^2} + \\frac{\\sigma_n^2}{\\sigma_s^2 + \\sigma_n^2} \\exp\\!\\left(-\\frac{d_{ij}^2}{2 \\ell^2}\\right)\n$$\n第二项 $\\frac{\\sigma_n^2}{\\sigma_s^2 + \\sigma_n^2} \\exp\\!\\left(-\\frac{d_{ij}^2}{2 \\ell^2}\\right)$ 代表了由空间自相关混淆引起的观测相关性的夸大。这一项始终是非负的。其大小取决于欧几里得距离 $d_{ij}$。对于小距离（$d_{ij} \\ll \\ell$），指数项接近于 1，夸大程度达到最大。随着距离 $d_{ij}$ 的增加，指数项衰减到 0，夸大效应消失。因此，空间邻近性（小的 $d_{ij}$）人为地夸大了观测到的功能连接性估计。\n\n### 第 2 部分：无偏期望相关性\n\n问题要求通过减去 GRF 混淆的贡献来构建期望相关性的无偏估计量。从第 1 部分推导的表达式可知，观测相关性是两个分量的总和：一个与真实神经相关性 $\\rho_{ij}$ 有关，另一个纯粹由混淆产生。\n\n混淆对观测相关性的贡献是当没有神经耦合时（即 $\\rho_{ij} = 0$）相关性所取的值。这就是上面推导的第二项：\n$$\nR_{ij}^{\\text{confound}} = \\frac{\\sigma_n^2 \\exp\\!\\left(-\\frac{d_{ij}^2}{2 \\ell^2}\\right)}{\\sigma_s^2 + \\sigma_n^2}\n$$\n期望相关性的无偏估计量，我们记为 $\\rho_{ij}^{\\text{debiased}}$，是通过从总观测相关性 $\\mathrm{Corr}(y_i, y_j)$ 中减去这个混淆贡献得到的：\n$$\n\\rho_{ij}^{\\text{debiased}} = \\mathrm{Corr}(y_i, y_j) - R_{ij}^{\\text{confound}}\n$$\n$$\n\\rho_{ij}^{\\text{debiased}} = \\left( \\frac{\\rho_{ij} \\sigma_s^2 + \\sigma_n^2 \\exp\\!\\left(-\\frac{d_{ij}^2}{2 \\ell^2}\\right)}{\\sigma_s^2 + \\sigma_n^2} \\right) - \\left( \\frac{\\sigma_n^2 \\exp\\!\\left(-\\frac{d_{ij}^2}{2 \\ell^2}\\right)}{\\sigma_s^2 + \\sigma_n^2} \\right)\n$$\n$$\n\\rho_{ij}^{\\text{debiased}} = \\frac{\\rho_{ij} \\sigma_s^2 + \\sigma_n^2 \\exp\\!\\left(-\\frac{d_{ij}^2}{2 \\ell^2}\\right) - \\sigma_n^2 \\exp\\!\\left(-\\frac{d_{ij}^2}{2 \\ell^2}\\right)}{\\sigma_s^2 + \\sigma_n^2}\n$$\n涉及混淆的项相互抵消，得到无偏期望相关性的闭式表达式：\n$$\n\\rho_{ij}^{\\text{debiased}} = \\frac{\\rho_{ij} \\sigma_s^2}{\\sigma_s^2 + \\sigma_n^2}\n$$\n这个表达式代表了真实的神经相关性 $\\rho_{ij}$ 乘以信号占总方差的比例 $\\frac{\\sigma_s^2}{\\sigma_s^2 + \\sigma_n^2}$，这个比例通常被称为信号与总方差之比。请注意，这个校正后的值与距离 $d_{ij}$ 和长度尺度 $\\ell$ 无关，因为空间效应已被适当地移除。\n\n### 第 3 部分：数值计算\n\n我们被要求使用推导出的公式和给定的参数来计算无偏期望相关性：\n- $\\sigma_s^2 = 2$\n- $\\sigma_n^2 = 1$\n- $\\ell = 20$ mm\n- $d_{ij} = 10$ mm\n- $\\rho_{ij} = 0.3$\n\n无偏期望相关性由第 2 部分的表达式给出：\n$$\n\\rho_{ij}^{\\text{debiased}} = \\frac{\\rho_{ij} \\sigma_s^2}{\\sigma_s^2 + \\sigma_n^2}\n$$\n代入给定的数值：\n$$\n\\rho_{ij}^{\\text{debiased}} = \\frac{(0.3)(2)}{2 + 1} = \\frac{0.6}{3} = 0.2\n$$\n问题要求答案四舍五入到四位有效数字。精确值为 $0.2$，写成四位有效数字为 $0.2000$。",
            "answer": "$$\n\\boxed{0.2000}\n$$"
        },
        {
            "introduction": "除了测量伪影，功能网络中看似真实的连接也可能源于共同的神经输入。本练习探讨了一个经典的时间序列分析问题：如何区分两个区域间的直接相互作用与它们由第三方区域共同驱动所产生的虚假相关。您将通过推导和设计统计检验，学习使用部分相关等方法来解决这一混淆问题。",
            "id": "4277727",
            "problem": "考虑结构性大脑网络（物理轴突连接）和功能性大脑网络（神经信号之间的统计依赖关系）之间的区别。假设一个实验记录了三个零均值离散时间随机过程：一个假定的共同驱动 $S_t$，以及两个区域信号 $X_t$ 和 $Y_t$。共同驱动 $S_t$ 是一阶自回归的，即 $S_t$ 满足 $S_t = \\phi S_{t-1} + \\eta_t$，其中 $|\\phi| < 1$，$\\eta_t$ 是方差为 $\\sigma_\\eta^2$ 的独立同分布高斯新息。令 $X_t$ 和 $Y_t$ 由下式生成：\n$$\nX_t = a\\, S_{t-\\ell_x} + u_t,\n\\qquad\nY_t = b\\, S_{t-\\ell_y} + c\\, X_{t-\\tau} + v_t,\n$$\n其中 $a$、$b$、$c$ 是实常数，$\\ell_x$、$\\ell_y$、$\\tau$ 是非负整数，$u_t$、$v_t$ 分别是方差为 $\\sigma_u^2$ 和 $\\sigma_v^2$ 的独立高斯白噪声过程。所有噪声项都独立于 $S_t$。你不知道直接耦合参数 $c$ 是否为零。你在滞后 $\\tau$ 处观察到 $X_{t-\\tau}$ 和 $Y_t$ 之间存在正的样本互相关。\n\n第1部分。仅使用协方差的线性性质、自回归模型的定义以及 $S_t$ 的平稳性，从机制上解释即使在 $c=0$ 的情况下，由于共享输入 $S_t$，$X_{t-\\tau}$ 和 $Y_t$ 之间如何产生时滞相关。在零假设 $c=0$ 下，用 $a$、$b$、$\\phi$、$\\sigma_\\eta^2$、$\\ell_x$、$\\ell_y$ 和 $\\tau$ 推导出理论互协方差 $\\operatorname{Cov}(X_{t-\\tau}, Y_t)$。\n\n第2部分。你的任务是设计一个统计检验，使用偏相关或残差化来区分真实交互（$c \\neq 0$）和共同驱动混杂。假设有 $N$ 个样本可用且高斯假设成立。下面的哪个程序通过移除来自 $S_t$ 的混杂路径，同时保留对从 $X_{t-\\tau}$到 $Y_t$ 的直接交互的检验，从而正确地针对零假设 $H_0: c=0$？\n\nA. 如果 $X_{t-\\tau}$ 和 $Y_t$ 之间的样本互相关显著大于零，则声明存在直接交互，其使用的阈值是根据独立性假设下相关系数的渐近方差推导出来的。\n\nB. 构造控制向量 $Z_t$，其包含进入 $X_{t-\\tau}$ 和 $Y_t$ 的 $S_t$ 的滞后项，例如 $Z_t = \\big(S_{t-\\ell_y}, S_{t-\\tau-\\ell_x}, S_{t-\\ell_y-1}, \\dots, S_{t-\\tau-\\ell_x-1}, \\dots\\big)$，其阶数有限，足以捕捉 $S_t$ 的自相关性，然后通过以下任一方式检验 $H_0: c = 0$：(i) 计算偏相关 $\\rho_{X_{t-\\tau}, Y_t \\cdot Z_t}$ 并使用其自由度为 $N - q - 2$ 的 $t$ 统计量，其中 $q$ 是 $Z_t$ 的维度；或 (ii) 拟合普通最小二乘 (OLS) 回归 $Y_t = \\beta_0 + \\beta_X X_{t-\\tau} + \\beta^\\top Z_t + \\varepsilon_t$ 并检验 $H_0: \\beta_X = 0$；在线性高斯假设下两者是等价的。\n\nC. 计算 $X_{t-\\tau}$ 和 $Y_t$ 之间的偏相关，仅控制瞬时驱动 $S_t$，即 $\\rho_{X_{t-\\tau}, Y_t \\cdot S_t}$，并使用自由度为 $N-3$ 的 $t$ 检验。\n\nD. 通过先对 $X_{t-\\tau}$ 进行回归来对 $Y_t$ 进行残差化，得到 $Y_t^{\\perp X} = Y_t - \\hat{\\gamma} X_{t-\\tau}$，然后使用联合显著性检验来检验 $Y_t^{\\perp X}$ 是否与 $S_t$ 的任何滞后项不相关；如果残差与 $S_t$ 无关，则声明从 $X_{t-\\tau}$ 到 $Y_t$ 存在直接交互。",
            "solution": "问题陈述在科学上是合理的、适定的且无歧义的。它提出了时间序列分析中一个区分直接交互与间接（混杂）交互的经典场景，这是网络神经科学中的一个基本课题。模型是标准的，所有必要的参数和假设都已明确定义。因此，我们可以继续进行推导和分析。\n\n**第1部分。伪相关与互协方差推导**\n\n问题要求从机制上解释即使在直接耦合常数 $c$ 为零的情况下，$X_{t-\\tau}$ 和 $Y_t$ 之间如何产生相关，并推导出理论互协方差。\n\n**机制解释：**\n在零假设 $H_0: c=0$ 下，信号 $X_t$ 和 $Y_t$ 按如下方式生成：\n$$\nX_t = a\\, S_{t-\\ell_x} + u_t\n$$\n$$\nY_t = b\\, S_{t-\\ell_y} + v_t\n$$\n$X_t$ 和 $Y_t$ 都受到相同的基础过程 $S_t$ 的影响，该过程被称为“共同驱动”。过程 $S_t$ 是自回归的，意味着其在任何时间 $t$ 的值都与其过去的值相关。具体来说，$S_t = \\phi S_{t-1} + \\eta_t$。此属性称为自相关。\n\n当我们考察 $X_{t-\\tau}$ 和 $Y_t$ 之间的关系时，我们是在比较时间 $t-\\tau$ 的信号 $X$ 和时间 $t$ 的信号 $Y$。它们的表达式是：\n$$\nX_{t-\\tau} = a\\, S_{t-\\tau-\\ell_x} + u_{t-\\tau}\n$$\n$$\nY_t = b\\, S_{t-\\ell_y} + v_t\n$$\n$X_{t-\\tau}$ 和 $Y_t$ 之间的相关性之所以产生，是因为它们共享一个共同的原因，即过程 $S_t$。信号 $X_{t-\\tau}$ 受到时间 $t-\\tau-\\ell_x$ 的 $S_t$ 的影响，而 $Y_t$ 受到时间 $t-\\ell_y$ 的 $S_t$ 的影响。由于 $S_t$ 的自相关性，$S_{t-\\tau-\\ell_x}$ 和 $S_{t-\\ell_y}$ 的值本身是相关的。这种相关性通过常数 $a$ 和 $b$ 传播，即使在完全没有从 $X$到 $Y$ 的直接因果联系（即当 $c=0$ 时）的情况下，也会在 $X_{t-\\tau}$ 和 $Y_t$ 之间引起统计依赖（相关）。这种现象是混杂的一个经典例子。\n\n**互协方差的推导：**\n$X_{t-\\tau}$ 和 $Y_t$ 之间的互协方差定义为 $\\operatorname{Cov}(X_{t-\\tau}, Y_t) = \\operatorname{E}[X_{t-\\tau} Y_t] - \\operatorname{E}[X_{t-\\tau}]\\operatorname{E}[Y_t]$。由于所有过程都假定为零均值，这可以简化为 $\\operatorname{Cov}(X_{t-\\tau}, Y_t) = \\operatorname{E}[X_{t-\\tau} Y_t]$。\n\n在零假设 $c=0$ 下，我们有：\n$$\n\\operatorname{Cov}(X_{t-\\tau}, Y_t) = \\operatorname{E}[(a\\, S_{t-\\tau-\\ell_x} + u_{t-\\tau})(b\\, S_{t-\\ell_y} + v_t)]\n$$\n展开乘积可得：\n$$\n\\operatorname{Cov}(X_{t-\\tau}, Y_t) = \\operatorname{E}[ab\\, S_{t-\\tau-\\ell_x} S_{t-\\ell_y} + a\\, S_{t-\\tau-\\ell_x} v_t + b\\, S_{t-\\ell_y} u_{t-\\tau} + u_{t-\\tau} v_t]\n$$\n根据期望的线性性质，我们可以分离各项：\n$$\n\\operatorname{Cov}(X_{t-\\tau}, Y_t) = ab\\, \\operatorname{E}[S_{t-\\tau-\\ell_x} S_{t-\\ell_y}] + a\\, \\operatorname{E}[S_{t-\\tau-\\ell_x} v_t] + b\\, \\operatorname{E}[S_{t-\\ell_y} u_{t-\\tau}] + \\operatorname{E}[u_{t-\\tau} v_t]\n$$\n根据问题陈述，所有噪声项（$u_t, v_t, \\eta_t$）相互独立，且独立于 $S_t$。由于过程是零均值的，独立变量乘积的期望为零。\n- $\\operatorname{E}[S_{t-\\tau-\\ell_x} v_t] = \\operatorname{E}[S_{t-\\tau-\\ell_x}] \\operatorname{E}[v_t] = 0 \\cdot 0 = 0$。\n- $\\operatorname{E}[S_{t-\\ell_y} u_{t-\\tau}] = \\operatorname{E}[S_{t-\\ell_y}] \\operatorname{E}[u_{t-\\tau}] = 0 \\cdot 0 = 0$。\n- $\\operatorname{E}[u_{t-\\tau} v_t] = \\operatorname{E}[u_{t-\\tau}] \\operatorname{E}[v_t] = 0 \\cdot 0 = 0$（因为 $u_t$ 和 $v_t$ 是独立过程）。\n\n这只剩下第一项：\n$$\n\\operatorname{Cov}(X_{t-\\tau}, Y_t) = ab\\, \\operatorname{E}[S_{t-\\tau-\\ell_x} S_{t-\\ell_y}]\n$$\n$\\operatorname{E}[S_{t-\\tau-\\ell_x} S_{t-\\ell_y}]$ 项是平稳过程 $S_t$ 的自协方差，记作 $\\gamma_S(k)$，其中滞后 $k$ 是时间索引的差值：$k = (t-\\ell_y) - (t-\\tau-\\ell_x) = \\tau + \\ell_x - \\ell_y$。\n所以，\n$$\n\\operatorname{Cov}(X_{t-\\tau}, Y_t) = ab\\, \\gamma_S(\\tau + \\ell_x - \\ell_y)\n$$\n对于平稳 AR(1) 过程 $S_t = \\phi S_{t-1} + \\eta_t$ 且 $|\\phi|<1$，方差为 $\\gamma_S(0) = \\operatorname{Var}(S_t) = \\frac{\\sigma_\\eta^2}{1-\\phi^2}$。自协方差函数为 $\\gamma_S(k) = \\phi^{|k|} \\gamma_S(0)$。代入此式，我们得到最终表达式：\n$$\n\\operatorname{Cov}(X_{t-\\tau}, Y_t) = ab\\, \\frac{\\sigma_\\eta^2}{1-\\phi^2} \\phi^{|\\tau + \\ell_x - \\ell_y|}\n$$\n如果 $a \\neq 0$、$b \\neq 0$ 且 $\\phi \\neq 0$，这个量通常不为零，这明确显示了即使在 $c=0$ 的情况下，非零的互协方差是如何由共同驱动产生的。\n\n**第2部分。统计检验的设计**\n\n任务是找到一个能正确检验零假设 $H_0: c=0$ 的程序。这需要将 $X_{t-\\tau}$ 对 $Y_t$ 的直接影响与由共同驱动 $S_t$ 介导的间接影响分离开来。正确的方法是对混杂变量进行统计控制。\n\n完整模型是 $Y_t = b\\, S_{t-\\ell_y} + c\\, X_{t-\\tau} + v_t$。变量 $X_{t-\\tau}$ 本身依赖于 $S_{t-\\tau-\\ell_x}$。对于 $Y_t$ 和我们感兴趣的预测变量 $X_{t-\\tau}$ 来说，它们的共同原因是 $S_t$ 的不同滞后项。要检验 $X_{t-\\tau}$ 对 $Y_t$ 的独特贡献，必须考虑 $S_t$ 过程的解释能力。\n\n**选项分析：**\n\n**A.** 仅基于 $X_{t-\\tau}$ 和 $Y_t$ 之间的简单样本互相关来声明交互，正是那种无法区分直接效应和混杂效应的有缺陷的方法。如第1部分所推导，即使 $c=0$，这种相关性也可能显著。此方法检验的是*功能连接*（任何统计关联），而非*有效连接*（直接因果影响）。\n**结论：不正确。**\n\n**B.** 该选项建议从共同驱动 $S_t$ 的滞后项构建一个控制向量 $Z_t$，然后在控制 $Z_t$ *之后* 检验 $X_{t-\\tau}$ 和 $Y_t$ 之间的关系。这可以通过计算偏相关 $\\rho_{X_{t-\\tau}, Y_t \\cdot Z_t}$ 或通过在多元回归模型 $Y_t = \\beta_0 + \\beta_X X_{t-\\tau} + \\beta^\\top Z_t + \\varepsilon_t$ 中检验系数 $\\beta_X$ 的显著性来完成。这是处理线性系统中混杂变量的标准、正确程序。通过在模型中包含 $S_t$ 的相关动态，我们可以分离出由 $X_{t-\\tau}$ 提供的额外解释力，在本模型下，这对应于由 $c$ 参数化的直接路径。对于线性高斯模型，偏相关检验与回归系数的t检验等价是一个标准结果。对 $Z_t$ 的描述正确地指出了它应包含导致混杂的 $S_t$ 的滞后项。\n**结论：正确。**\n\n**C.** 该选项建议仅控制瞬时驱动 $S_t$。然而，混杂效应是由特定的滞后项 $S_{t-\\ell_y}$ 和 $S_{t-\\tau-\\ell_x}$ 介导的。控制 $S_t$ 是任意的，并且通常是不正确的；它不能恰当地移除导致混杂的特定滞后项的影响。虽然 $S_t$ 与其所有滞后项都相关，但控制它通常只能部分而非完全地移除混杂效应，从而导致无效的检验。\n**结论：不正确。**\n\n**D.** 该选项描述了一个不正确的逻辑顺序。它首先将 $Y_t$ 对 $X_{t-\\tau}$ 进行回归，然后检验残差是否与 $S_t$ 相关。如果执行回归 $Y_t = \\hat{\\gamma} X_{t-\\tau} + Y_t^{\\perp X}$，估计的系数 $\\hat{\\gamma}$ 将由于遗漏了混杂变量 $S_t$ 而产生偏差。发现残差 $Y_t^{\\perp X}$ 与 $S_t$ 相关，仅仅证实了最初的简单回归模型设定有误，因为它遗漏了一个相关变量（$S_t$）。此程序不能为零假设 $H_0: c=0$ 提供有效的检验。正确的逻辑是在控制 $S_t$ *之后* 检验 $X_{t-\\tau}$ 的影响，而不是反过来。\n**结论：不正确。**",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "在解决了测量和网络动态的混淆之后，我们面临一个更根本的问题：即使我们拥有一个完美的、无噪声的功能连接矩阵，它是否能唯一确定其底层的有向结构网络？本编码练习将通过构建两个因果结构不同但观测统计量无法区分的模型，来揭示从观测数据推断因果方向性的内在局限性。",
            "id": "4277686",
            "problem": "考虑一对由两个节点组成的脑区，其被建模为一个线性高斯结构方程模型（SEM），该模型为结构性脑网络提供了一种数学表示。结构性脑网络由一个有向邻接矩阵 $B$ 和一个独立噪声协方差矩阵 $\\Omega$ 捕捉，而功能性脑网络由观测变量的二阶（协方差）统计量捕捉。对于一个线性无环SEM，可观测协方差矩阵 $\\Sigma$ 通过一个经过充分检验的公式与结构相关联：$\\Sigma = (I - B)^{-1} \\Omega (I - B)^{-T}$，其中 $I$ 是单位矩阵，$B$ 编码有向边，而 $\\Omega$ 编码每个节点的独立高斯噪声。这个关系是本问题的基础。\n\n您将构建一个合成数据集，以证明两种不同的有向架构可以在零延迟下产生无法区分的二阶统计量，从而表明在没有干预或更丰富的可观测数据的情况下，纯粹的观测二阶统计量不足以识别方向性。\n\n使用两个标量变量 $x$ 和 $y$。考虑两种备选的有向架构：\n- 模型 $A$：一条从 $y$ 到 $x$ 的有向边，对应于方程 $x = \\alpha y + \\epsilon_x$ 和 $y = \\epsilon_y$，其中 $\\epsilon_x$ 和 $\\epsilon_y$ 是独立的零均值高斯噪声。\n- 模型 $B$：一条从 $x$ 到 $y$ 的有向边，对应于方程 $y = \\beta x + \\epsilon_y'$ 和 $x = \\epsilon_x'$，其中 $\\epsilon_x'$ 和 $\\epsilon_y'$ 是独立的零均值高斯噪声。\n\n您的任务是：\n- 利用结构参数和功能协方差之间的关系，为模型 $A$ 选择参数 $(\\alpha, \\operatorname{Var}(\\epsilon_x), \\operatorname{Var}(\\epsilon_y))$，为模型 $B$ 选择参数 $(\\beta, \\operatorname{Var}(\\epsilon_x'), \\operatorname{Var}(\\epsilon_y'))$，使得两个模型都能产生相同的目标可观测协方差矩阵 $\\Sigma$，其边际方差和相关性如下文指定。\n- 使用对噪声项的独立高斯抽样，为两个模型生成大小为 $n$ 的合成数据集，并根据模型定义构建观测变量。\n- 计算两个数据集的样本协方差矩阵，并评估这些矩阵之间的最大元素绝对差。如果该最大差值小于指定的容差，则宣布这两个模型在二阶统计量上是无法区分的。\n\n科学真实性约束：\n- 确保所有噪声方差均为非负，并且隐含的协方差矩阵是半正定的。\n- 所有变量都是无量纲的，因此不需要物理单位。\n- 不使用角度，因此不需要角度单位。\n\n测试套件：\n提供一个程序来执行以下测试用例，每个测试用例都有一个由边际方差 $\\sigma_x^2$、$\\sigma_y^2$ 和相关系数 $\\rho$ 定义的目标协方差，以及样本大小 $n$、随机种子 $s$ 和用于不可区分性的数值容差 $\\tau$。\n\n- 测试用例 1（一般情况）：$\\sigma_x^2 = 1.0$，$\\sigma_y^2 = 1.0$，$\\rho = 0.4$，$n = 100000$，$s = 0$，$\\tau = 2 \\times 10^{-3}$。\n- 测试用例 2（边界情况）：$\\sigma_x^2 = 1.0$，$\\sigma_y^2 = 2.0$，$\\rho = 0.0$，$n = 100000$，$s = 1$，$\\tau = 2 \\times 10^{-3}$。\n- 测试用例 3（强相关性的边缘情况）：$\\sigma_x^2 = 1.0$，$\\sigma_y^2 = 1.0$，$\\rho = 0.95$，$n = 150000$，$s = 2$，$\\tau = 5 \\times 10^{-3}$。\n\n对于每个测试用例：\n- 为模型 $A$ 和模型 $B$ 构建参数，使得两者都产生相同的目标协方差矩阵 $\\Sigma$，其元素为 $\\Sigma_{xx} = \\sigma_x^2$，$\\Sigma_{yy} = \\sigma_y^2$ 和 $\\Sigma_{xy} = \\rho \\sigma_x \\sigma_y$。\n- 使用给定的种子为两个模型模拟 $n$ 个样本。\n- 计算样本协方差矩阵，并返回一个布尔值，指示两个样本协方差矩阵之间的最大绝对差是否小于 $\\tau$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），其中每个结果都是一个布尔值，对应于相应测试用例的不可区分性判定。",
            "solution": "根本问题在于证明两个被称为模型 $A$ 和模型 $B$ 的不同有向因果结构，在二阶统计量方面可以是观测上等价的。这意味着两个模型都可以生成具有完全相同理论协方差矩阵 $\\Sigma$ 的数据，从而使得它们在零延迟下从纯观测数据中无法区分。我们将首先为每个模型推导实现这种等价性的参数，然后概述用于验证的数值模拟。\n\n对于线性无环结构方程模型（SEM），结构参数（有向邻接矩阵 $B$ 和独立噪声协方差矩阵 $\\Omega$）与可观测协方差矩阵 $\\Sigma$ 之间的关系由下式给出：\n$$\n\\Sigma = (I - B)^{-1} \\Omega (I - B)^{-T}\n$$\n在此，$I$ 是 $2 \\times 2$ 单位矩阵，我们考虑变量按向量 $\\begin{pmatrix} x \\\\ y \\end{pmatrix}$ 的顺序排列。目标可观测协方差矩阵 $\\Sigma$ 用边际方差 $\\sigma_x^2$ 和 $\\sigma_y^2$ 以及相关系数 $\\rho$ 表示：\n$$\n\\Sigma = \\begin{pmatrix} \\Sigma_{xx}  \\Sigma_{xy} \\\\ \\Sigma_{yx}  \\Sigma_{yy} \\end{pmatrix} = \\begin{pmatrix} \\sigma_x^2  \\rho \\sigma_x \\sigma_y \\\\ \\rho \\sigma_x \\sigma_y  \\sigma_y^2 \\end{pmatrix}\n$$\n\n**模型 A ($y \\to x$) 的参数推导**\n\n模型 $A$ 表示从 $y$ 到 $x$ 的一条有向边。其结构方程为：\n$$\nx = \\alpha y + \\epsilon_x \\\\\ny = \\epsilon_y\n$$\n其中 $\\epsilon_x$ 和 $\\epsilon_y$ 分别是方差为 $\\operatorname{Var}(\\epsilon_x)$ 和 $\\operatorname{Var}(\\epsilon_y)$ 的独立零均值高斯噪声。该系统的矩阵表示为 $\\vec{v} = B \\vec{v} + \\vec{\\epsilon}$，由此得到结构矩阵：\n$$\nB_A = \\begin{pmatrix} 0  \\alpha \\\\ 0  0 \\end{pmatrix}, \\quad \\Omega_A = \\begin{pmatrix} \\operatorname{Var}(\\epsilon_x)  0 \\\\ 0  \\operatorname{Var}(\\epsilon_y) \\end{pmatrix}\n$$\n为了求得最终的协方差矩阵 $\\Sigma_A$，我们首先计算矩阵 $(I - B_A)^{-1}$：\n$$\nI - B_A = \\begin{pmatrix} 1  -\\alpha \\\\ 0  1 \\end{pmatrix} \\implies (I - B_A)^{-1} = \\begin{pmatrix} 1  \\alpha \\\\ 0  1 \\end{pmatrix}\n$$\n其转置为 $(I - B_A)^{-T} = \\begin{pmatrix} 1  0 \\\\ \\alpha  1 \\end{pmatrix}$。将这些代入主协方差公式：\n$$\n\\Sigma_A = (I - B_A)^{-1} \\Omega_A (I - B_A)^{-T} = \\begin{pmatrix} 1  \\alpha \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} \\operatorname{Var}(\\epsilon_x)  0 \\\\ 0  \\operatorname{Var}(\\epsilon_y) \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ \\alpha  1 \\end{pmatrix}\n$$\n执行矩阵乘法可得：\n$$\n\\Sigma_A = \\begin{pmatrix} \\operatorname{Var}(\\epsilon_x) + \\alpha^2 \\operatorname{Var}(\\epsilon_y)  \\alpha \\operatorname{Var}(\\epsilon_y) \\\\ \\alpha \\operatorname{Var}(\\epsilon_y)  \\operatorname{Var}(\\epsilon_y) \\end{pmatrix}\n$$\n我们将 $\\Sigma_A$ 的元素与目标矩阵 $\\Sigma$ 的相应元素相等，以求解模型参数 $(\\alpha, \\operatorname{Var}(\\epsilon_x), \\operatorname{Var}(\\epsilon_y))$：\n1.  从元素 $(2,2)$ 可得：$\\Sigma_{yy} = \\operatorname{Var}(\\epsilon_y) \\implies \\operatorname{Var}(\\epsilon_y) = \\sigma_y^2$。\n2.  从元素 $(1,2)$ 可得：$\\Sigma_{xy} = \\alpha \\operatorname{Var}(\\epsilon_y) \\implies \\rho \\sigma_x \\sigma_y = \\alpha \\sigma_y^2$。假设 $\\sigma_y \\neq 0$，我们得到 $\\alpha = \\frac{\\rho \\sigma_x}{\\sigma_y}$。\n3.  从元素 $(1,1)$ 可得：$\\Sigma_{xx} = \\operatorname{Var}(\\epsilon_x) + \\alpha^2 \\operatorname{Var}(\\epsilon_y) \\implies \\sigma_x^2 = \\operatorname{Var}(\\epsilon_x) + \\left(\\frac{\\rho \\sigma_x}{\\sigma_y}\\right)^2 \\sigma_y^2$。这可以简化为 $\\operatorname{Var}(\\epsilon_x) = \\sigma_x^2 - \\rho^2 \\sigma_x^2 = \\sigma_x^2(1 - \\rho^2)$。\n\n**模型 B ($x \\to y$) 的参数推导**\n\n模型 $B$ 表示从 $x$ 到 $y$ 的一条有向边。其结构方程为：\n$$\ny = \\beta x + \\epsilon_y' \\\\\nx = \\epsilon_x'\n$$\n其中 $\\epsilon_x'$ 和 $\\epsilon_y'$ 是方差为 $\\operatorname{Var}(\\epsilon_x')$ 和 $\\operatorname{Var}(\\epsilon_y')$ 的独立零均值高斯噪声。其结构矩阵为：\n$$\nB_B = \\begin{pmatrix} 0  0 \\\\ \\beta  0 \\end{pmatrix}, \\quad \\Omega_B = \\begin{pmatrix} \\operatorname{Var}(\\epsilon_x')  0 \\\\ 0  \\operatorname{Var}(\\epsilon_y') \\end{pmatrix}\n$$\n我们计算 $(I - B_B)^{-1}$：\n$$\nI - B_B = \\begin{pmatrix} 1  0 \\\\ -\\beta  1 \\end{pmatrix} \\implies (I - B_B)^{-1} = \\begin{pmatrix} 1  0 \\\\ \\beta  1 \\end{pmatrix}\n$$\n其转置为 $(I - B_B)^{-T} = \\begin{pmatrix} 1  \\beta \\\\ 0  1 \\end{pmatrix}$。代入协方差公式：\n$$\n\\Sigma_B = (I - B_B)^{-1} \\Omega_B (I - B_B)^{-T} = \\begin{pmatrix} 1  0 \\\\ \\beta  1 \\end{pmatrix} \\begin{pmatrix} \\operatorname{Var}(\\epsilon_x')  0 \\\\ 0  \\operatorname{Var}(\\epsilon_y') \\end{pmatrix} \\begin{pmatrix} 1  \\beta \\\\ 0  1 \\end{pmatrix}\n$$\n执行矩阵乘法可得：\n$$\n\\Sigma_B = \\begin{pmatrix} \\operatorname{Var}(\\epsilon_x')  \\beta \\operatorname{Var}(\\epsilon_x') \\\\ \\beta \\operatorname{Var}(\\epsilon_x')  \\beta^2 \\operatorname{Var}(\\epsilon_x') + \\operatorname{Var}(\\epsilon_y') \\end{pmatrix}\n$$\n将 $\\Sigma_B$ 的元素与 $\\Sigma$ 的元素相等，以求解 $(\\beta, \\operatorname{Var}(\\epsilon_x'), \\operatorname{Var}(\\epsilon_y'))$：\n1.  从元素 $(1,1)$ 可得：$\\Sigma_{xx} = \\operatorname{Var}(\\epsilon_x') \\implies \\operatorname{Var}(\\epsilon_x') = \\sigma_x^2$。\n2.  从元素 $(1,2)$ 可得：$\\Sigma_{xy} = \\beta \\operatorname{Var}(\\epsilon_x') \\implies \\rho \\sigma_x \\sigma_y = \\beta \\sigma_x^2$。假设 $\\sigma_x \\neq 0$，我们得到 $\\beta = \\frac{\\rho \\sigma_y}{\\sigma_x}$。\n3.  从元素 $(2,2)$ 可得：$\\Sigma_{yy} = \\beta^2 \\operatorname{Var}(\\epsilon_x') + \\operatorname{Var}(\\epsilon_y') \\implies \\sigma_y^2 = \\left(\\frac{\\rho \\sigma_y}{\\sigma_x}\\right)^2 \\sigma_x^2 + \\operatorname{Var}(\\epsilon_y')$。这可以简化为 $\\operatorname{Var}(\\epsilon_y') = \\sigma_y^2 - \\rho^2 \\sigma_y^2 = \\sigma_y^2(1 - \\rho^2)$。\n\n**模拟与验证算法**\n\n对于每个具有给定值 $(\\sigma_x^2, \\sigma_y^2, \\rho, n, s, \\tau)$ 的测试用例，执行以下步骤：\n1.  用种子 $s$ 初始化一个伪随机数生成器。\n2.  计算标准差 $\\sigma_x = \\sqrt{\\sigma_x^2}$ 和 $\\sigma_y = \\sqrt{\\sigma_y^2}$。\n3.  **模拟模型 A：**\n    a. 确定模型参数：$\\alpha = \\frac{\\rho \\sigma_x}{\\sigma_y}$，$\\operatorname{std}(\\epsilon_y) = \\sigma_y$ 和 $\\operatorname{std}(\\epsilon_x) = \\sigma_x \\sqrt{1 - \\rho^2}$。\n    b. 生成 $n$ 个噪声样本：$\\epsilon_y \\sim \\mathcal{N}(0, \\sigma_y^2)$ 和 $\\epsilon_x \\sim \\mathcal{N}(0, \\sigma_x^2(1 - \\rho^2))$。\n    c. 根据模型合成可观测数据：$y_A = \\epsilon_y$ 和 $x_A = \\alpha y_A + \\epsilon_x$。\n4.  **模拟模型 B：**\n    a. 确定模型参数：$\\beta = \\frac{\\rho \\sigma_y}{\\sigma_x}$，$\\operatorname{std}(\\epsilon_x') = \\sigma_x$ 和 $\\operatorname{std}(\\epsilon_y') = \\sigma_y \\sqrt{1 - \\rho^2}$。\n    b. 生成 $n$ 个新的噪声样本：$\\epsilon_x' \\sim \\mathcal{N}(0, \\sigma_x^2)$ 和 $\\epsilon_y' \\sim \\mathcal{N}(0, \\sigma_y^2(1 - \\rho^2))$。\n    c. 合成可观测数据：$x_B = \\epsilon_x'$ 和 $y_B = \\beta x_B + \\epsilon_y'$。\n5.  **验证：**\n    a. 构建两个 $2 \\times n$ 的数据矩阵，$D_A = \\begin{pmatrix} x_A \\\\ y_A \\end{pmatrix}$ 和 $D_B = \\begin{pmatrix} x_B \\\\ y_B \\end{pmatrix}$。\n    b. 计算样本协方差矩阵 $\\hat{\\Sigma}_A = \\operatorname{Cov}(D_A)$ 和 $\\hat{\\Sigma}_B = \\operatorname{Cov}(D_B)$。\n    c. 计算两个样本矩阵元素之间的最大绝对差：$\\Delta = \\max_{i,j} \\left| (\\hat{\\Sigma}_A)_{ij} - (\\hat{\\Sigma}_B)_{ij} \\right|$。\n    d. 返回一个布尔值结果，如果 $\\Delta < \\tau$ 则为 `True`，否则为 `False`。\n这种结构化的方法使我们能够从数值上验证不同的因果结构可以从其二阶统计量上无法区分这一理论发现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_test_case(var_x, var_y, rho, n, seed, tau):\n    \"\"\"\n    Executes a single test case for comparing Model A and Model B.\n\n    Args:\n        var_x (float): Target variance of variable x.\n        var_y (float): Target variance of variable y.\n        rho (float): Target correlation coefficient between x and y.\n        n (int): Number of samples to generate.\n        seed (int): Seed for the random number generator.\n        tau (float): Tolerance for indistinguishability.\n\n    Returns:\n        bool: True if the models are indistinguishable within tolerance, False otherwise.\n    \"\"\"\n    \n    # Initialize a random number generator with the specified seed.\n    rng = np.random.default_rng(seed)\n\n    # Calculate standard deviations from variances.\n    sigma_x = np.sqrt(var_x)\n    sigma_y = np.sqrt(var_y)\n    \n    # --- Model A (y -> x) ---\n    # Equations:\n    # x = alpha * y + eps_x\n    # y = eps_y\n    # Derived parameters:\n    # alpha = rho * sigma_x / sigma_y\n    # Var(eps_y) = var_y\n    # Var(eps_x) = var_x * (1 - rho^2)\n\n    # Handle the case sigma_y = 0, though problem constraints prevent it.\n    if sigma_y == 0:\n        alpha = 0.0\n    else:\n        alpha = rho * sigma_x / sigma_y\n    \n    std_eps_y_A = sigma_y\n    std_eps_x_A = sigma_x * np.sqrt(1 - rho**2)\n\n    # Generate noise terms for Model A.\n    eps_y_A = rng.normal(loc=0.0, scale=std_eps_y_A, size=n)\n    eps_x_A = rng.normal(loc=0.0, scale=std_eps_x_A, size=n)\n\n    # Synthesize data for Model A.\n    y_A = eps_y_A\n    x_A = alpha * y_A + eps_x_A\n\n    # --- Model B (x -> y) ---\n    # Equations:\n    # y = beta * x + eps_y_prime\n    # x = eps_x_prime\n    # Derived parameters:\n    # beta = rho * sigma_y / sigma_x\n    # Var(eps_x_prime) = var_x\n    # Var(eps_y_prime) = var_y * (1 - rho^2)\n\n    # Handle the case sigma_x = 0, though problem constraints prevent it.\n    if sigma_x == 0:\n        beta = 0.0\n    else:\n        beta = rho * sigma_y / sigma_x\n\n    std_eps_x_B = sigma_x\n    std_eps_y_B = sigma_y * np.sqrt(1 - rho**2)\n\n    # Generate noise terms for Model B.\n    # Note: These are independent draws from the Model A noises.\n    eps_x_B = rng.normal(loc=0.0, scale=std_eps_x_B, size=n)\n    eps_y_B = rng.normal(loc=0.0, scale=std_eps_y_B, size=n)\n\n    # Synthesize data for Model B.\n    x_B = eps_x_B\n    y_B = beta * x_B + eps_y_B\n\n    # --- Verification ---\n\n    # Arrange data for covariance calculation (rows are variables, columns are observations).\n    data_A = np.vstack((x_A, y_A))\n    data_B = np.vstack((x_B, y_B))\n\n    # Compute the sample covariance matrices.\n    cov_A = np.cov(data_A)\n    cov_B = np.cov(data_B)\n\n    # Calculate the maximum absolute entrywise difference.\n    max_abs_diff = np.max(np.abs(cov_A - cov_B))\n    \n    # Check if the difference is within the specified tolerance.\n    is_indistinguishable = max_abs_diff  tau\n    \n    return is_indistinguishable\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (var_x, var_y, rho, n, seed, tau)\n    test_cases = [\n        (1.0, 1.0, 0.4, 100000, 0, 2e-3),\n        (1.0, 2.0, 0.0, 100000, 1, 2e-3),\n        (1.0, 1.0, 0.95, 150000, 2, 5e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        var_x, var_y, rho, n, s, tau = case\n        result = run_test_case(var_x, var_y, rho, n, s, tau)\n        results.append(str(result).lower()) # Convert boolean to lowercase string\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}