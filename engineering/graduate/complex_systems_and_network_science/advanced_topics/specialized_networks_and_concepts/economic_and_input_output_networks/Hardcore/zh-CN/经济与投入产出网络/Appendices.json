{
    "hands_on_practices": [
        {
            "introduction": "任何复杂的分析都始于对基本构件的透彻理解。本练习旨在通过一个具体的数值示例，巩固对投入产出（IO）分析核心会计关系的掌握。您将直接从行业间交易数据（$Z$ 矩阵）和总产出数据（$x$ 向量）出发，亲手构建技术系数矩阵 $A$，并验证列昂惕夫（Leontief）体系中最基本的平衡恒等式 $x = Ax + y$。这项基础实践对于将抽象的经济概念转化为可操作的计算至关重要，是后续所有高级应用（如乘数分析或冲击模拟）的基石 ()。",
            "id": "4273284",
            "problem": "考虑一个由产业间交易矩阵 $Z \\in \\mathbb{R}^{3 \\times 3}$ 和总产出向量 $x \\in \\mathbb{R}^{3}$ 表示的三部门（$3$）经济体。$Z$ 的元素 $z_{ij}$ 表示部门 $i$ 提供给部门 $j$ 的中间投入的货币价值（单位：十亿货币单位）。总产出 $x_{j}$ 是部门 $j$ 生产的总产出的货币价值（单位：十亿货币单位）。在瓦西里·列昂惕夫（Wassily Leontief）的投入产出（IO）框架中，技术系数矩阵 $A$ 按列由核心定义 $a_{ij} = z_{ij}/x_{j}$ 给出，基本核算恒等式为 $x = A x + y$，其中 $y \\in \\mathbb{R}^{3}$ 是最终需求向量（单位：十亿货币单位）。\n\n给定以下数据（所有数值单位均为十亿货币单位）：\n$$\nZ = \\begin{pmatrix}\n40  30  20 \\\\\n50  60  40 \\\\\n30  50  20\n\\end{pmatrix},\n\\qquad\nx = \\begin{pmatrix}\n260 \\\\\n340 \\\\\n220\n\\end{pmatrix}.\n$$\n\n任务：\n1. 仅使用技术系数的核心定义，根据 $Z$ 和 $x$ 计算矩阵 $A$。\n2. 从基本平衡恒等式 $x = A x + y$ 出发，根据 $x$ 和 $A$ 计算最终需求向量 $y$。\n3. 通过计算等式两边并逐分量证明其相等，来显式验证该平衡恒等式。\n\n所有货币价值均以十亿货币单位表示。请给出最终需求向量 $y$ 的第二个分量 $y_{2}$ 作为你唯一的最终数值答案。无需四舍五入。",
            "solution": "该问题经验证具有科学依据、适定、客观且内部一致。它是经济学中列昂惕夫投入产出模型的标准应用。所有必要的数据和定义均已提供，可求得唯一解。我们可以开始求解。\n\n该问题要求我们基于一个三部门经济的列昂惕夫投入产出模型进行计算。我们已知产业间交易矩阵 $Z$ 和总产出向量 $x$。所有货币价值均以十亿货币单位表示。\n\n给定数据如下：\n$$\nZ = \\begin{pmatrix}\n40  30  20 \\\\\n50  60  40 \\\\\n30  50  20\n\\end{pmatrix}\n\\qquad\nx = \\begin{pmatrix}\n260 \\\\\n340 \\\\\n220\n\\end{pmatrix}\n$$\n\n**任务1：计算技术系数矩阵 $A$。**\n\n技术系数 $a_{ij}$ 表示生产部门 $j$ 的一个单位产出所需的部门 $i$ 的投入量。它由关系式 $a_{ij} = \\frac{z_{ij}}{x_j}$ 定义，其中 $z_{ij}$ 是部门 $i$ 对部门 $j$ 的投入，而 $x_j$ 是部门 $j$ 的总产出。我们逐列计算矩阵 $A$。\n\n对于第一列（$j=1$），对应于总产出为 $x_1 = 260$ 的部门1：\n$a_{11} = \\frac{z_{11}}{x_1} = \\frac{40}{260} = \\frac{4}{26} = \\frac{2}{13}$\n$a_{21} = \\frac{z_{21}}{x_1} = \\frac{50}{260} = \\frac{5}{26}$\n$a_{31} = \\frac{z_{31}}{x_1} = \\frac{30}{260} = \\frac{3}{26}$\n\n对于第二列（$j=2$），对应于总产出为 $x_2 = 340$ 的部门2：\n$a_{12} = \\frac{z_{12}}{x_2} = \\frac{30}{340} = \\frac{3}{34}$\n$a_{22} = \\frac{z_{22}}{x_2} = \\frac{60}{340} = \\frac{6}{34} = \\frac{3}{17}$\n$a_{32} = \\frac{z_{32}}{x_2} = \\frac{50}{340} = \\frac{5}{34}$\n\n对于第三列（$j=3$），对应于总产出为 $x_3 = 220$ 的部门3：\n$a_{13} = \\frac{z_{13}}{x_3} = \\frac{20}{220} = \\frac{2}{22} = \\frac{1}{11}$\n$a_{23} = \\frac{z_{23}}{x_3} = \\frac{40}{220} = \\frac{4}{22} = \\frac{2}{11}$\n$a_{33} = \\frac{z_{33}}{x_3} = \\frac{20}{220} = \\frac{2}{22} = \\frac{1}{11}$\n\n将这些系数组合起来，技术系数矩阵 $A$ 为：\n$$\nA = \\begin{pmatrix}\n\\frac{2}{13}  \\frac{3}{34}  \\frac{1}{11} \\\\\n\\frac{5}{26}  \\frac{3}{17}  \\frac{2}{11} \\\\\n\\frac{3}{26}  \\frac{5}{34}  \\frac{1}{11}\n\\end{pmatrix}\n$$\n\n**任务2：计算最终需求向量 $y$。**\n\n投入产出模型的基本核算恒等式是 $x = Ax + y$，其中 $x$ 是总产出向量，$Ax$ 是中间需求向量，$y$ 是最终需求向量。为了求出 $y$，我们将该恒等式重排为 $y = x - Ax$。\n\n首先，我们计算中间需求向量 $Ax$：\n$$\nAx = \\begin{pmatrix}\n\\frac{2}{13}  \\frac{3}{34}  \\frac{1}{11} \\\\\n\\frac{5}{26}  \\frac{3}{17}  \\frac{2}{11} \\\\\n\\frac{3}{26}  \\frac{5}{34}  \\frac{1}{11}\n\\end{pmatrix}\n\\begin{pmatrix}\n260 \\\\\n340 \\\\\n220\n\\end{pmatrix}\n$$\n所得向量的分量为：\n$(Ax)_1 = \\left(\\frac{2}{13}\\right)(260) + \\left(\\frac{3}{34}\\right)(340) + \\left(\\frac{1}{11}\\right)(220) = 2 \\cdot 20 + 3 \\cdot 10 + 1 \\cdot 20 = 40 + 30 + 20 = 90$\n$(Ax)_2 = \\left(\\frac{5}{26}\\right)(260) + \\left(\\frac{3}{17}\\right)(340) + \\left(\\frac{2}{11}\\right)(220) = 5 \\cdot 10 + 3 \\cdot 20 + 2 \\cdot 20 = 50 + 60 + 40 = 150$\n$(Ax)_3 = \\left(\\frac{3}{26}\\right)(260) + \\left(\\frac{5}{34}\\right)(340) + \\left(\\frac{1}{11}\\right)(220) = 3 \\cdot 10 + 5 \\cdot 10 + 1 \\cdot 20 = 30 + 50 + 20 = 100$\n\n因此，中间需求向量为：\n$$\nAx = \\begin{pmatrix}\n90 \\\\\n150 \\\\\n100\n\\end{pmatrix}\n$$\n注意到该向量就是交易矩阵 $Z$ 的行和向量，因为 $(Ax)_i = \\sum_{j} a_{ij} x_j = \\sum_{j} \\frac{z_{ij}}{x_j} x_j = \\sum_{j} z_{ij}$。\n\n现在，我们可以计算最终需求向量 $y$：\n$$\ny = x - Ax = \\begin{pmatrix}\n260 \\\\\n340 \\\\\n220\n\\end{pmatrix} - \\begin{pmatrix}\n90 \\\\\n150 \\\\\n100\n\\end{pmatrix} = \\begin{pmatrix}\n260 - 90 \\\\\n340 - 150 \\\\\n220 - 100\n\\end{pmatrix} = \\begin{pmatrix}\n170 \\\\\n190 \\\\\n120\n\\end{pmatrix}\n$$\n所以，最终需求向量是 $y = \\begin{pmatrix} 170 \\\\ 190 \\\\ 120 \\end{pmatrix}$ 十亿货币单位。\n\n**任务3：验证平衡恒等式。**\n\n我们必须验证 $x = Ax + y$。\n等式左边（LHS）是总产出向量：\n$$\n\\text{LHS} = x = \\begin{pmatrix}\n260 \\\\\n340 \\\\\n220\n\\end{pmatrix}\n$$\n等式右边（RHS）是中间需求与最终需求之和：\n$$\n\\text{RHS} = Ax + y = \\begin{pmatrix}\n90 \\\\\n150 \\\\\n100\n\\end{pmatrix} + \\begin{pmatrix}\n170 \\\\\n190 \\\\\n120\n\\end{pmatrix} = \\begin{pmatrix}\n90 + 170 \\\\\n150 + 190 \\\\\n100 + 120\n\\end{pmatrix} = \\begin{pmatrix}\n260 \\\\\n340 \\\\\n220\n\\end{pmatrix}\n$$\n由于 LHS = RHS，该平衡恒等式已逐分量验证。\n\n问题要求最终需求向量 $y$ 的第二个分量 $y_2$。根据我们在任务2中的计算，我们得到 $y_2 = 190$。",
            "answer": "$$\n\\boxed{190}\n$$"
        },
        {
            "introduction": "在掌握了描述经济体系中产品流动的数量模型后，我们转向其对偶的视角——价格模型。这个练习将引导您探索产品价格是如何由其生产成本（包括中间投入和增加值等主要投入）决定的。通过计算，您不仅能确定各行业的均衡价格，还将学习如何运用列昂惕夫逆矩阵来分解一个产品的最终价格，揭示价值是如何在生产网络中从上游行业向下游行业传递和累积的。这项技能对于理解价值链、成本推动型通货膨胀以及评估政策对价格的影响具有深刻的价值 ()。",
            "id": "4273266",
            "problem": "考虑一个包含三个部门的产业间投入产出（IO）价格体系，其中直接需求矩阵 $\\mathbf{A}$ 的元素 $a_{ij}$ 表示生产一单位部门 $j$ 的产出所直接需要的部门 $i$ 的产出单位数。设 $\\mathbf{v}$ 为各部门单位产出的外生初级投入成本（增加值）向量，以货币单位计量。假设存在竞争性定价且无加价，因此对于每个部门 $j$，单位价格等于生产一单位产出所产生的所有中间投入成本与初级投入成本之和。给定\n$$\n\\mathbf{A} \\;=\\;\n\\begin{pmatrix}\n0.10  0.20  0.25 \\\\\n0.00  0.10  0.15 \\\\\n0.00  0.00  0.10\n\\end{pmatrix},\n\\qquad\n\\mathbf{v} \\;=\\;\n\\begin{pmatrix}\n0.30 \\\\\n0.35 \\\\\n0.25\n\\end{pmatrix}.\n$$\n从上述基本成本核算恒等式和投入产出系统的核心定义出发，推导部门单位价格向量 $\\mathbf{p}$ 的价格体系，并计算部门 3 的单位价格。然后，通过一种有原则的分解方法，解释各上游部门对部门 3 单位价格的贡献，该分解应能区分源于部门 1、2、3 的增加值是如何通过网络传递到部门 3 的价格中的。\n\n以货币单位表示部门 3 的数值单位价格，并将答案四舍五入至四位有效数字。不要报告任何百分比；若您呈现份额或比率，请用小数或分数表示。您的最终答案必须是一个数字。",
            "solution": "该问题陈述有效，因为它代表了投入产出经济学中一个标准的、适定的列昂惕夫价格模型，这是经济网络研究的一个核心课题。所提供的数据是完整、一致且有科学依据的。\n\n基于无加价的竞争性定价原则，基本成本核算恒等式指出，部门 $j$ 一单位产出的价格（记为 $p_j$）必须等于其生产的总成本。该成本是所有中间投入的成本与初级投入（增加值）的成本之和。\n\n生产一单位部门 $j$ 产出所需的中间投入成本由总和 $\\sum_{i=1}^3 a_{ij} p_i$ 给出，其中 $a_{ij}$ 是所需部门 $i$ 产出的数量， $p_i$ 是其单位价格。部门 $j$ 单位产出的初级投入成本为 $v_j$。因此，对于每个部门 $j \\in \\{1, 2, 3\\}$，定价方程为：\n$$ p_j = \\sum_{i=1}^3 a_{ij} p_i + v_j $$\n令 $\\mathbf{p} = \\begin{pmatrix} p_1 \\\\ p_2 \\\\ p_3 \\end{pmatrix}$ 为单位价格的列向量，$\\mathbf{v} = \\begin{pmatrix} v_1 \\\\ v_2 \\\\ v_3 \\end{pmatrix}$ 为单位增加值的列向量。该方程组可以用矩阵形式写出。习惯上使用行向量表示价格，即 $\\mathbf{p}^T = \\begin{pmatrix} p_1  p_2  p_3 \\end{pmatrix}$。总和 $\\sum_{i=1}^3 a_{ij} p_i$ 是矩阵乘积 $\\mathbf{p}^T \\mathbf{A}$ 的第 $j$ 个元素。因此，该系统是：\n$$ \\mathbf{p}^T = \\mathbf{p}^T \\mathbf{A} + \\mathbf{v}^T $$\n重新整理此方程以求解 $\\mathbf{p}^T$：\n$$ \\mathbf{p}^T - \\mathbf{p}^T \\mathbf{A} = \\mathbf{v}^T $$\n$$ \\mathbf{p}^T (\\mathbf{I} - \\mathbf{A}) = \\mathbf{v}^T $$\n$$ \\mathbf{p}^T = \\mathbf{v}^T (\\mathbf{I} - \\mathbf{A})^{-1} $$\n矩阵 $\\mathbf{L} = (\\mathbf{I} - \\mathbf{A})^{-1}$ 是列昂惕夫逆矩阵。求解价格向量 $\\mathbf{p}$ 的另一种等效方法是对方程进行转置：\n$$ \\mathbf{p} = \\mathbf{A}^T \\mathbf{p} + \\mathbf{v} $$\n$$ (\\mathbf{I} - \\mathbf{A}^T) \\mathbf{p} = \\mathbf{v} $$\n$$ \\mathbf{p} = (\\mathbf{I} - \\mathbf{A}^T)^{-1} \\mathbf{v} $$\n给定矩阵：\n$$ \\mathbf{A} = \\begin{pmatrix} 0.10  0.20  0.25 \\\\ 0.00  0.10  0.15 \\\\ 0.00  0.00  0.10 \\end{pmatrix}, \\quad \\mathbf{v} = \\begin{pmatrix} 0.30 \\\\ 0.35 \\\\ 0.25 \\end{pmatrix} $$\n首先，我们计算 $\\mathbf{I} - \\mathbf{A}^T$：\n$$ \\mathbf{A}^T = \\begin{pmatrix} 0.10  0.00  0.00 \\\\ 0.20  0.10  0.00 \\\\ 0.25  0.15  0.10 \\end{pmatrix} $$\n$$ \\mathbf{I} - \\mathbf{A}^T = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} - \\begin{pmatrix} 0.10  0.00  0.00 \\\\ 0.20  0.10  0.00 \\\\ 0.25  0.15  0.10 \\end{pmatrix} = \\begin{pmatrix} 0.90  0.00  0.00 \\\\ -0.20  0.90  0.00 \\\\ -0.25  -0.15  0.90 \\end{pmatrix} $$\n系统 $(\\mathbf{I} - \\mathbf{A}^T)\\mathbf{p} = \\mathbf{v}$ 为：\n$$ \\begin{pmatrix} 0.90  0.00  0.00 \\\\ -0.20  0.90  0.00 \\\\ -0.25  -0.15  0.90 \\end{pmatrix} \\begin{pmatrix} p_1 \\\\ p_2 \\\\ p_3 \\end{pmatrix} = \\begin{pmatrix} 0.30 \\\\ 0.35 \\\\ 0.25 \\end{pmatrix} $$\n由于该矩阵是下三角矩阵，我们可以使用向前代入法求解 $\\mathbf{p}$。\n由第一个方程：\n$$ 0.90 p_1 = 0.30 \\implies p_1 = \\frac{0.30}{0.90} = \\frac{1}{3} $$\n由第二个方程：\n$$ -0.20 p_1 + 0.90 p_2 = 0.35 \\implies 0.90 p_2 = 0.35 + 0.20 p_1 = 0.35 + 0.20 \\left(\\frac{1}{3}\\right) = \\frac{7}{20} + \\frac{1}{15} = \\frac{21+4}{60} = \\frac{25}{60} = \\frac{5}{12} $$\n$$ p_2 = \\frac{5/12}{0.90} = \\frac{5/12}{9/10} = \\frac{50}{108} = \\frac{25}{54} $$\n由第三个方程：\n$$ -0.25 p_1 - 0.15 p_2 + 0.90 p_3 = 0.25 \\implies 0.90 p_3 = 0.25 + 0.25 p_1 + 0.15 p_2 $$\n$$ 0.90 p_3 = \\frac{1}{4} + \\frac{1}{4}\\left(\\frac{1}{3}\\right) + \\frac{3}{20}\\left(\\frac{25}{54}\\right) = \\frac{1}{4} + \\frac{1}{12} + \\frac{5}{72} = \\frac{18}{72} + \\frac{6}{72} + \\frac{5}{72} = \\frac{29}{72} $$\n$$ p_3 = \\frac{29/72}{0.90} = \\frac{29/72}{9/10} = \\frac{290}{648} = \\frac{145}{324} $$\n部门 3 的单位价格为 $p_3 = \\frac{145}{324}$。\n\n接下来，我们解释各部门的增加值对此价格的贡献。价格方程 $\\mathbf{p}^T = \\mathbf{v}^T \\mathbf{L}$ 意味着部门 $j$ 的价格为 $p_j = \\sum_{i=1}^3 v_i l_{ij}$，其中 $l_{ij}$ 是列昂惕夫逆矩阵 $\\mathbf{L} = (\\mathbf{I}-\\mathbf{A})^{-1}$ 的第 $(i,j)$ 个元素。项 $l_{ij}$ 表示生产一单位部门 $j$ 的最终产出所需的部门 $i$ 的总产出（包括直接和间接）。因此，乘积 $v_i l_{ij}$ 表示源于部门 $i$ 并体现在一单位部门 $j$ 最终产品中的总增加值。\n\n为分解 $p_3$，我们需要计算贡献 $v_1 l_{13}$、$v_2 l_{23}$ 和 $v_3 l_{33}$。这需要列昂惕夫逆矩阵 $\\mathbf{L}$ 的第三列。设此列为 $\\mathbf{c}_3 = \\begin{pmatrix} l_{13} \\\\ l_{23} \\\\ l_{33} \\end{pmatrix}$。它可以通过求解系统 $\\mathbf{L} = (\\mathbf{I}-\\mathbf{A})^{-1} \\mathbf{I}$，具体来说是 $(\\mathbf{I}-\\mathbf{A})\\mathbf{c}_3 = \\mathbf{e}_3$ 来求得，其中 $\\mathbf{e}_3 = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}$。\n首先，我们计算 $\\mathbf{I}-\\mathbf{A}$：\n$$ \\mathbf{I}-\\mathbf{A} = \\begin{pmatrix} 0.90  -0.20  -0.25 \\\\ 0.00  0.90  -0.15 \\\\ 0.00  0.00  0.90 \\end{pmatrix} $$\n待解系统为：\n$$ \\begin{pmatrix} 0.90  -0.20  -0.25 \\\\ 0.00  0.90  -0.15 \\\\ 0.00  0.00  0.90 \\end{pmatrix} \\begin{pmatrix} l_{13} \\\\ l_{23} \\\\ l_{33} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} $$\n使用回代法：\n由第三行：$0.90 l_{33} = 1 \\implies l_{33} = \\frac{1}{0.90} = \\frac{10}{9}$。\n由第二行：$0.90 l_{23} - 0.15 l_{33} = 0 \\implies 0.90 l_{23} = 0.15 \\left(\\frac{10}{9}\\right) = \\frac{1.5}{9} = \\frac{1}{6} \\implies l_{23} = \\frac{1/6}{0.90} = \\frac{10}{54} = \\frac{5}{27}$。\n由第一行：$0.90 l_{13} - 0.20 l_{23} - 0.25 l_{33} = 0 \\implies 0.90 l_{13} = 0.20 \\left(\\frac{5}{27}\\right) + 0.25 \\left(\\frac{10}{9}\\right) = \\frac{1}{27} + \\frac{2.5}{9} = \\frac{1}{27} + \\frac{7.5}{27} = \\frac{8.5}{27} = \\frac{17}{54}$。\n$l_{13} = \\frac{17/54}{0.90} = \\frac{170}{486} = \\frac{85}{243}$。\n\n现在我们可以计算对 $p_3 = v_1 l_{13} + v_2 l_{23} + v_3 l_{33}$ 的增加值贡献：\n给定 $\\mathbf{v}^T = \\begin{pmatrix} 0.30  0.35  0.25 \\end{pmatrix} = \\begin{pmatrix} \\frac{3}{10}  \\frac{7}{20}  \\frac{1}{4} \\end{pmatrix}$。\n\n来自部门 1 增加值的贡献：\n$$ v_1 l_{13} = \\left(\\frac{3}{10}\\right) \\left(\\frac{85}{243}\\right) = \\frac{255}{2430} = \\frac{17}{162} $$\n来自部门 2 增加值的贡献：\n$$ v_2 l_{23} = \\left(\\frac{7}{20}\\right) \\left(\\frac{5}{27}\\right) = \\frac{35}{540} = \\frac{7}{108} $$\n来自部门 3 增加值的贡献：\n$$ v_3 l_{33} = \\left(\\frac{1}{4}\\right) \\left(\\frac{10}{9}\\right) = \\frac{10}{36} = \\frac{5}{18} $$\n将这些贡献相加以验证我们先前计算的 $p_3$：\n$$ p_3 = \\frac{17}{162} + \\frac{7}{108} + \\frac{5}{18} = \\frac{17 \\cdot 2}{324} + \\frac{7 \\cdot 3}{324} + \\frac{5 \\cdot 18}{324} = \\frac{34 + 21 + 90}{324} = \\frac{145}{324} $$\n总和与我们的结果相符，证实了分解的正确性。\n部门 3 产出的价格 $p_3 \\approx 0.4475$ 由源于部门 1 的增加值（$\\frac{17}{162} \\approx 0.1049$）、源于部门 2 的增加值（$\\frac{7}{108} \\approx 0.0648$）以及源于部门 3 自身的增加值（$\\frac{5}{18} \\approx 0.2778$）构成，因为这些初级成本通过生产网络进行传递和累积。\n\n部门 3 的最终数值单位价格为 $p_3 = \\frac{145}{324} \\approx 0.44753086...$。\n四舍五入到四位有效数字得到 $0.4475$。",
            "answer": "$$\\boxed{0.4475}$$"
        },
        {
            "introduction": "经济网络不仅是价值和产品的静态管道，也是冲击和风险传播的动态媒介。本练习将引导您超越静态均衡分析，进入网络动力学的领域。您将构建一个级联失效模型，其中一个行业的生存依赖于从其供应商那里获得足够的投入。这项实践将投入产出网络的结构用作模拟系统性风险的底层基础，通过迭代过程，您可以直观地看到一个局部冲击（例如一个行业的产出下降）是如何通过网络相互依赖性传播，并可能引发大规模的连锁反应。掌握这种建模方法是理解和量化复杂系统中稳定性和脆弱性的关键一步 ()。",
            "id": "4273243",
            "problem": "考虑一个包含 $n$ 个部门的有向加权经济投入产出网络，其由一个非负的部门间流量矩阵 $F \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 表示，其中 $F_{ij}$ 表示从部门 $j$ 输送到部门 $i$ 的基准投入量。设部门 $i$ 的基准总输入需求为 $R_i = \\sum_{j=1}^{n} F_{ij}$，并将这些需求汇集成一个向量 $R \\in \\mathbb{R}_{\\ge 0}^{n}$。给定一个阈值向量 $\\theta \\in [0,1]^{n}$，其中 $\\theta_i$ 是部门 $i$ 为避免失效所需的 $R_i$ 的最小比例。一个外生容量冲击由向量 $c \\in [0,1]^{n}$ 指定，其中 $c_j$ 是部门 $j$ 相对于其基准产出的比例。在每次迭代中，部门 $i$ 接收到的输入由 $I_i = \\sum_{j=1}^{n} F_{ij} \\, \\kappa_j$ 给出，其中 $\\kappa_j$ 是部门 $j$ 的当前容量，该容量会随着迭代而演变。初始时，$\\kappa_j = c_j$。当且仅当 $I_i  \\theta_i R_i$ 时，部门 $i$ 失效，此时其容量在所有后续迭代中均被设置为 $\\kappa_i = 0$。由于冲击，$c_j = 0$ 的部门被视为初始失效。失效过程通过迭代更新 $\\kappa$ 并移除失效部门来进行，直到达到不动点（没有新的失效发生）。将级联规模定义为除了初始失效部门之外，因级联而失效的部门数量。\n\n从这些基本定义出发，通过实现一个符合上述规则的迭代移除过程，确定每个指定测试用例的级联规模。所有 $I_i$ 与 $\\theta_i R_i$ 的比较必须使用严格不等式 $I_i  \\theta_i R_i$ 来判断失效。将所有测试用例的最终答案表示为整数。\n\n使用以下测试套件，其中包括一个共享网络和多个冲击与阈值配置，用于探究一般情况、阈值相等、无冲击、极端阈值和完全崩溃等情景：\n\n- 网络规模：$n = 5$。\n- 基准部门间流量矩阵：\n$$\nF = \\begin{pmatrix}\n0  0.6  0.4  0  0 \\\\\n0  0  0.5  0.5  0 \\\\\n0  0  0  0.7  0.3 \\\\\n0.2  0  0  0  0.8 \\\\\n0.3  0.3  0  0  0\n\\end{pmatrix}.\n$$\n- 测试用例 1：$\\theta = (0.8, 0.7, 0.65, 0.9, 0.5)$，$c = (1, 1, 0.5, 1, 1)$。该用例至少包含一个部门处于阈值相等的情况。\n- 测试用例 2：$\\theta = (0.8, 0.7, 0.65, 0.9, 0.5)$，$c = (1, 0, 1, 1, 1)$。该用例引入一个初始失效的供应部门，从而引发级联。\n- 测试用例 3：$\\theta = (0.8, 0.7, 0.65, 0.9, 0.5)$，$c = (1, 1, 1, 1, 1)$。该用例没有冲击。\n- 测试用例 4：$\\theta = (0, 0, 0, 0, 0)$，$c = (0, 0, 1, 1, 1)$。该用例使用零阈值来测试边界条件，即没有部门会因输入不足而失效。\n- 测试用例 5：$\\theta = (1, 1, 1, 1, 1)$，$c = (1, 1, 0.9, 1, 1)$。该用例使用最大阈值来测试对小规模冲击的敏感性。\n\n您的程序应生成单行输出，其中包含五个测试用例的级联规模，格式为方括号内以逗号分隔的列表（例如，$[a,b,c,d,e]$），其中每个条目是对应测试用例的级联规模的整数。不涉及任何物理单位、角度单位或百分比；所有量均为无量纲量，所有阈值和容量均以小数形式指定。程序必须实现所述的迭代移除过程，在达到不动点时终止，并且只计算那些在初始失效（$c_j = 0$）之外发生的失效。",
            "solution": "该问题定义明确且有效。它在科学上植根于网络动力学和经济投入产出模型的既定理论，特别是关于级联失效的理论。所有术语、变量（$F$、$R$、$\\theta$、$c$、$\\kappa$）和条件都经过了数学上的明确指定，确保了问题的客观性和适定性。该动力学过程是确定性的，并保证在有限步数内达到不动点，因为可以失效的部门数量有限（$n=5$），且失效是不可逆状态。问题是自包含的，没有缺失或矛盾的信息。所提供的数据在数值上是一致的，并且适用于该模型。\n\n该问题描述了一个离散时间的迭代过程，用于模拟经济网络中的级联失效。系统在任何迭代中的状态由容量向量 $\\kappa \\in [0,1]^n$ 捕捉，其中 $\\kappa_i$ 是部门 $i$ 的运营容量。\n\n首先，我们从基准部门间流量矩阵 $F$ 推导出常数参数：\n$$\nF = \\begin{pmatrix}\n0  0.6  0.4  0  0 \\\\\n0  0  0.5  0.5  0 \\\\\n0  0  0  0.7  0.3 \\\\\n0.2  0  0  0  0.8 \\\\\n0.3  0.3  0  0  0\n\\end{pmatrix}\n$$\n每个部门 $i$ 的基准总输入需求 $R_i$ 是从所有部门 $j$ 到 $i$ 的输入之和，这对应于 $F$ 的第 $i$ 行之和。\n$$R_i = \\sum_{j=1}^{n} F_{ij}$$\n为每个部门计算这个值，得到向量 $R$：\n$R_1 = 0 + 0.6 + 0.4 + 0 + 0 = 1.0$\n$R_2 = 0 + 0 + 0.5 + 0.5 + 0 = 1.0$\n$R_3 = 0 + 0 + 0 + 0.7 + 0.3 = 1.0$\n$R_4 = 0.2 + 0 + 0 + 0 + 0.8 = 1.0$\n$R_5 = 0.3 + 0.3 + 0 + 0 + 0 = 0.6$\n所以，基准需求向量是 $R = (1.0, 1.0, 1.0, 1.0, 0.6)^T$。\n\n模拟的核心是一个迭代算法：\n\n1.  **初始化**：对于每个由冲击向量 $c$ 和阈值向量 $\\theta$ 指定的测试用例：\n    a. 初始容量向量被设置为冲击向量：$\\kappa^{(0)} = c$。\n    b. 初始失效部门集合为 $S_{initial} = \\{j \\mid c_j = 0\\}$。\n    c. 计算每个部门的失效阈值 $T_i = \\theta_i R_i$。该向量在整个模拟过程中保持不变。\n    d. 维护一个布尔向量，表示活跃（未失效）的部门。初始时，如果 $\\kappa_i > 0$，则部门 $i$ 是活跃的。\n\n2.  **迭代**：该过程以离散步骤持续进行，直到在完整的一步中没有新的失效发生（达到不动点）。在每次迭代 $t$ 中：\n    a. 根据其供应部门的当前容量计算每个部门 $i$ 接收到的总输入：$I_i^{(t)} = \\sum_{j=1}^{n} F_{ij} \\kappa_j^{(t)}$。用矩阵表示为 $I^{(t)} = F \\kappa^{(t)}$。\n    b. 对于每个活跃部门 $i$（其中 $\\kappa_i^{(t)} > 0$），我们检查失效条件：$I_i^{(t)}  T_i$。\n    c. 如果条件满足，部门 $i$ 失效。\n    d. 通过将所有新失效部门的 $\\kappa_i^{(t+1)}$ 设置为 $0$ 来形成新的容量向量 $\\kappa^{(t+1)}$。其他部门的容量与 $\\kappa^{(t)}$ 相比保持不变。\n\n3.  **终止**：当一次迭代没有产生新的失效时，循环终止。\n\n4.  **结果**：最终的失效部门集合是 $S_{final} = \\{j \\mid \\kappa_j^{final} = 0\\}$。级联规模定义为在级联过程中失效的部门数量，即 $|S_{final}| - |S_{initial}|$。\n\n我们现在将此算法应用于每个测试用例。\n\n**测试用例 1**：$\\theta = (0.8, 0.7, 0.65, 0.9, 0.5)$，$c = (1, 1, 0.5, 1, 1)$。\n- 输入阈值：$T = (0.8 \\times 1.0, 0.7 \\times 1.0, 0.65 \\times 1.0, 0.9 \\times 1.0, 0.5 \\times 0.6)^T = (0.8, 0.7, 0.65, 0.9, 0.3)^T$。\n- 初始状态：$\\kappa^{(0)} = (1, 1, 0.5, 1, 1)^T$。初始失效数量为 $0$。\n- 迭代 1：$I^{(0)} = F \\kappa^{(0)} = (0.8, 0.75, 1.0, 1.0, 0.6)^T$。\n- 比较：\n  - $I_1 = 0.8$, $T_1 = 0.8$。（$0.8  0.8$ 为假）。\n  - $I_2 = 0.75$, $T_2 = 0.7$。（$0.75  0.7$ 为假）。\n  - $I_3 = 1.0$, $T_3 = 0.65$。（$1.0  0.65$ 为假）。\n  - $I_4 = 1.0$, $T_4 = 0.9$。（$1.0  0.9$ 为假）。\n  - $I_5 = 0.6$, $T_5 = 0.3$。（$0.6  0.3$ 为假）。\n- 没有部门失效。系统是稳定的。\n- 级联规模 = $0 - 0 = 0$。\n\n**测试用例 2**：$\\theta = (0.8, 0.7, 0.65, 0.9, 0.5)$，$c = (1, 0, 1, 1, 1)$。\n- 输入阈值：$T = (0.8, 0.7, 0.65, 0.9, 0.3)^T$。\n- 初始状态：$\\kappa^{(0)} = (1, 0, 1, 1, 1)^T$。部门 $2$ 初始失效。初始失效数量为 $1$。\n- 迭代 1：$I^{(0)} = F \\kappa^{(0)} = (0.4, 1.0, 1.0, 1.0, 0.3)^T$。\n  - $I_1 = 0.4  T_1=0.8 \\implies$ 部门 $1$ 失效。\n- 新状态：$\\kappa^{(1)} = (0, 0, 1, 1, 1)^T$。\n- 迭代 2：$I^{(1)} = F \\kappa^{(1)} = (0.4, 1.0, 1.0, 0.8, 0)^T$。\n  - $I_4 = 0.8  T_4=0.9 \\implies$ 部门 $4$ 失效。\n  - $I_5 = 0  T_5=0.3 \\implies$ 部门 $5$ 失效。\n- 新状态：$\\kappa^{(2)} = (0, 0, 1, 0, 0)^T$。\n- 迭代 3：$I^{(2)} = F \\kappa^{(2)} = (0.4, 0.5, 0, 0, 0)^T$。\n  - $I_3 = 0  T_3=0.65 \\implies$ 部门 $3$ 失效。\n- 新状态：$\\kappa^{(3)} = (0, 0, 0, 0, 0)^T$。\n- 没有活跃部门剩下。过程终止。\n- 最终失效部门：$\\{1, 2, 3, 4, 5\\}$。总失效数 = $5$。初始失效数 = $1$。\n- 级联规模 = $5 - 1 = 4$。\n\n**测试用例 3**：$\\theta = (0.8, 0.7, 0.65, 0.9, 0.5)$，$c = (1, 1, 1, 1, 1)$。\n- 输入阈值：$T = (0.8, 0.7, 0.65, 0.9, 0.3)^T$。\n- 初始状态：$\\kappa^{(0)} = (1, 1, 1, 1, 1)^T$。初始失效数量为 $0$。\n- 迭代 1：$I^{(0)} = F \\kappa^{(0)} = R = (1.0, 1.0, 1.0, 1.0, 0.6)^T$。\n- 比较：失效条件是 $R_i  \\theta_i R_i$，简化为 $1  \\theta_i$（因为 $R_i > 0$）。对于所有 $i$ 这都是假的，因为 $\\theta_i \\in [0,1]$。没有部门失效。\n- 级联规模 = $0 - 0 = 0$。\n\n**测试用例 4**：$\\theta = (0, 0, 0, 0, 0)$，$c = (0, 0, 1, 1, 1)$。\n- 输入阈值：$T = (0, 0, 0, 0, 0)^T$。\n- 初始状态：$\\kappa^{(0)} = (0, 0, 1, 1, 1)^T$。部门 $1$ 和 $2$ 初始失效。初始失效数量为 $2$。\n- 迭代 1：失效条件是 $I_i  0$。由于 $F_{ij} \\ge 0$ 且 $\\kappa_j \\ge 0$，输入 $I_i = \\sum_j F_{ij} \\kappa_j$ 必须是非负的（$I_i \\ge 0$）。因此，该条件永远不会满足。没有新的部门失效。\n- 级联规模 = $2 - 2 = 0$。\n\n**测试用例 5**：$\\theta = (1, 1, 1, 1, 1)$，$c = (1, 1, 0.9, 1, 1)$。\n- 输入阈值：$T = 1.0 \\times R = (1.0, 1.0, 1.0, 1.0, 0.6)^T$。\n- 初始状态：$\\kappa^{(0)} = (1, 1, 0.9, 1, 1)^T$。初始失效数量为 $0$。\n- 迭代 1：$I^{(0)} = F \\kappa^{(0)} = (0.96, 0.95, 1.0, 1.0, 0.6)^T$。\n  - $I_1 = 0.96  T_1=1.0 \\implies$ 部门 $1$ 失效。\n  - $I_2 = 0.95  T_2=1.0 \\implies$ 部门 $2$ 失效。\n- 新状态：$\\kappa^{(1)} = (0, 0, 0.9, 1, 1)^T$。\n- 迭代 2：$I^{(1)} = F \\kappa^{(1)} = (0.36, 0.95, 1.0, 0.8, 0)^T$。\n  - $I_4 = 0.8  T_4=1.0 \\implies$ 部门 $4$ 失效。\n  - $I_5 = 0  T_5=0.6 \\implies$ 部门 $5$ 失效。\n- 新状态：$\\kappa^{(2)} = (0, 0, 0.9, 0, 0)^T$。\n- 迭代 3：$I^{(2)} = F \\kappa^{(2)} = (0.36, 0.45, 0, 0, 0)^T$。\n  - $I_3 = 0  T_3=1.0 \\implies$ 部门 $3$ 失效。\n- 新状态：$\\kappa^{(3)} = (0, 0, 0, 0, 0)^T$。\n- 没有活跃部门剩下。过程终止。\n- 最终失效部门：$\\{1, 2, 3, 4, 5\\}$。总失效数 = $5$。初始失效数 = $0$。\n- 级联规模 = $5 - 0 = 5$。\n\n结果总结：\n- 用例 1：$0$\n- 用例 2：$4$\n- 用例 3：$0$\n- 用例 4：$0$\n- 用例 5：$5$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the cascade size in an economic input-output network model\n    for a series of test cases.\n    \"\"\"\n    \n    # Shared network parameters\n    F = np.array([\n        [0.0, 0.6, 0.4, 0.0, 0.0],\n        [0.0, 0.0, 0.5, 0.5, 0.0],\n        [0.0, 0.0, 0.0, 0.7, 0.3],\n        [0.2, 0.0, 0.0, 0.0, 0.8],\n        [0.3, 0.3, 0.0, 0.0, 0.0]\n    ])\n    n = F.shape[0]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'theta': np.array([0.8, 0.7, 0.65, 0.9, 0.5]), 'c': np.array([1.0, 1.0, 0.5, 1.0, 1.0])},\n        {'theta': np.array([0.8, 0.7, 0.65, 0.9, 0.5]), 'c': np.array([1.0, 0.0, 1.0, 1.0, 1.0])},\n        {'theta': np.array([0.8, 0.7, 0.65, 0.9, 0.5]), 'c': np.array([1.0, 1.0, 1.0, 1.0, 1.0])},\n        {'theta': np.array([0.0, 0.0, 0.0, 0.0, 0.0]), 'c': np.array([0.0, 0.0, 1.0, 1.0, 1.0])},\n        {'theta': np.array([1.0, 1.0, 1.0, 1.0, 1.0]), 'c': np.array([1.0, 1.0, 0.9, 1.0, 1.0])}\n    ]\n\n    # Baseline total input requirement vector R\n    R = F.sum(axis=1)\n    \n    results = []\n    \n    for case in test_cases:\n        theta = case['theta']\n        c = case['c']\n        \n        # Calculate the constant failure threshold vector T\n        T_vector = theta * R\n        \n        # Initialize capacity vector kappa from the shock vector c\n        kappa = np.copy(c)\n        \n        # Identify initially failed sectors (where c_j = 0)\n        num_initial_failures = np.sum(c == 0)\n        \n        # Iteratively remove failed sectors until a fixed point is reached\n        while True:\n            # Get a mask of sectors that are currently active (not failed)\n            active_sectors_mask = kappa > 0\n            \n            # If no sectors are active, the cascade is complete\n            if not np.any(active_sectors_mask):\n                break\n\n            # Calculate received inputs I = F * kappa\n            I_vector = F @ kappa\n            \n            # Identify sectors that fail in this iteration:\n            # They must be active AND their input must be strictly less than the threshold.\n            newly_failed_mask = (I_vector  T_vector)  active_sectors_mask\n            \n            # Check for fixed point: if no new sectors failed, terminate\n            if not np.any(newly_failed_mask):\n                break\n            \n            # Update kappa: set capacity of newly failed sectors to 0\n            kappa[newly_failed_mask] = 0.0\n            \n    \n        # After the cascade, count the total number of failed sectors\n        num_final_failures = n - np.sum(kappa > 0)\n        \n        # The cascade size is the number of new failures beyond the initial ones\n        cascade_size = num_final_failures - num_initial_failures\n        results.append(cascade_size)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}