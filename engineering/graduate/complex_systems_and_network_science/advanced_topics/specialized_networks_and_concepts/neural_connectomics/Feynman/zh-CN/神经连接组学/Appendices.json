{
    "hands_on_practices": [
        {
            "introduction": "要理解连接组的复杂性，一种有效方法是将其分解为基本的结构单元，即“网络基序”。这项练习提供了一种精确计算这些基本回路模式的系统性方法。 掌握这项基于邻接矩阵运算的计数技术，是理解局部连接模式如何影响整个神经网络功能的关键第一步。",
            "id": "4293135",
            "problem": "一个定向突触图将局部神经微环路建模为一个无自环的简单有向图，其中从神经元 $i$ 到神经元 $j$ 的一条有向边代表一个突触 $i \\to j$。在复杂系统和网络科学中的神经连接组学背景下，网络基序是一种在固定数量节点上指定的诱导子图模式，它在图同构（标签置换）的意义下被考虑，并且通常相对于一个适当的零模型（如度保持的配置模型）来评估其统计上的过表达情况。请关注 $3$ 个节点规模的基序。\n\n从有向图、邻接矩阵、诱导子图和图同构的基本定义出发，定义有向图中 $3$ 节点基序的含义，并推导一种通用的、精确的计数方法，该方法用于计数所有 $3$ 节点基序，需使用邻接矩阵运算、针对一个三元组中需要存在和禁止存在的边的指示函数，以及考虑每个基序同构类的自同构群的组合校正。你的方法必须用对不同节点三元组的求和以及邻接矩阵元素及其补的乘积来表示，并且必须包括将有序节点三元组的计数转换为未标记的诱导基序计数所需的对称性校正。\n\n然后，将你的方法应用于以下由 $n=6$ 个神经元组成的定向突触网络，其邻接矩阵为 $\\mathbf{A} \\in \\{0,1\\}^{6 \\times 6}$，其中如果存在突触 $i \\to j$，则 $\\mathbf{A}_{ij}=1$，否则 $\\mathbf{A}_{ij}=0$：\n$$\n\\mathbf{A}=\n\\begin{pmatrix}\n0  1  1  0  0  0 \\\\\n0  0  1  0  0  0 \\\\\n0  0  0  0  0  0 \\\\\n0  0  0  0  1  1 \\\\\n0  0  0  0  0  1 \\\\\n0  0  0  0  0  0 \\\\\n\\end{pmatrix}.\n$$\n假设没有自环，并且每个有序神经元对之间最多只有一条有向边。\n\n对于称为前馈环（定义为一个诱导的 $3$ 节点有向无环三元组，恰好有 $i \\to j$、$j \\to k$ 和 $i \\to k$ 这三条边，且三元组内所有反向边均不存在）的特定基序类型，计算该网络中存在的诱导前馈环基序的确切数量。请将最终答案表示为一个整数。无需四舍五入。",
            "solution": "该问题要求两个主要部分：首先，推导一种使用邻接矩阵运算和组合校正来计数有向图中 $3$ 节点基序的通用、精确方法；其次，应用此方法在给定的特定网络中找出诱导前馈环基序的数量。\n\n首先，我们建立必要的定义。有向图是一个对 $G=(V, E)$，其中 $V=\\{1, 2, \\dots, n\\}$ 是一个包含 $n$ 个节点（神经元）的集合，$E \\subseteq V \\times V$ 是一个有向边（突触）的集合。该图由其邻接矩阵 $\\mathbf{A}$ 表示，这是一个 $n \\times n$ 矩阵，其中如果存在从节点 $i$ 到节点 $j$ 的边（即 $(i,j) \\in E$），则 $\\mathbf{A}_{ij}=1$，否则 $\\mathbf{A}_{ij}=0$。问题说明没有自环，这意味着对所有 $i \\in V$ 都有 $\\mathbf{A}_{ii}=0$。在一个节点集 $S \\subseteq V$ 上的诱导子图是图 $G[S]$，它由节点 $S$ 以及 $E$ 中连接 $S$ 内部节点的所有边组成。一个 $3$ 节点基序是三个节点上诱导子图的一个同构类。我们旨在计算不同的三节点集合 $S=\\{i,j,k\\}$ 的数量，其诱导子图 $G[S]$ 与一个特定的基序模式同构。\n\n为推导一种通用的计数方法，我们遍历所有有序且不同的节点三元组 $(i, j, k)$，其总数为 $n(n-1)(n-2)$。对于每个有序三元组，我们可以确定它们之间六条可能边（$i \\leftrightarrow j$，$i \\leftrightarrow k$ 和 $j \\leftrightarrow k$）的具体标记模式。设 $M$ 为一个目标基序同构类，由顶点为 $\\{v_1, v_2, v_3\\}$ 的图 $G_M$ 表示。我们可以通过将 $G_M$ 中节点的角色映射到有序三元组 $(i,j,k)$ 中的位置来定义一个规范的标记模式。例如，我们可以指定 $i$ 扮演 $v_1$ 的角色，$j$ 扮演 $v_2$ 的角色，$k$ 扮演 $v_3$ 的角色。\n\n我们可以为这个规范的标记模式构建一个指示函数 $I_M(i,j,k)$。如果 $(i,j,k)$ 上的子图与该模式匹配，则此函数等于 $1$，否则等于 $0$。它被表述为对应三个节点之间六条可能有向边的六个项的乘积。对于模式中要求存在的每条边，例如 $u \\to v$，我们包含一个因子 $\\mathbf{A}_{uv}$。对于要求不存在的每条边，我们包含一个因子 $(1-\\mathbf{A}_{uv})$。\n\n在整个图中，这种特定规范标记模式的总出现次数可以通过对所有不同的有序三元组求和指示函数得到：\n$$N_{raw} = \\sum_{i,j,k \\text{ distinct}} I_M(i,j,k)$$\n这个和 $N_{raw}$ 并不直接等于未标记的诱导基序数量 $N_M$。由于对称性，需要进行重复计数的校正。一个在节点集 $\\{u,v,w\\}$ 上的单一诱导基序，如果这些节点的不同置换都能匹配规范的标记模式，那么它可能在 $N_{raw}$ 中被多次计数。对于单个基序实例，这种匹配置换的数量就是组合对称因子 $S_M$。该因子等于基序图的自同构群的大小 $|\\text{Aut}(G_M)|$，即保持其边结构不变的基序节点置换的数量。\n\n因此，计算 $M$ 类诱导基序数量的最终通用公式为：\n$$N_M = \\frac{N_{raw}}{S_M} = \\frac{1}{|\\text{Aut}(G_M)|} \\sum_{i,j,k \\text{ distinct}} I_M(i,j,k)$$\n\n接下来，我们应用此方法来计数称为前馈环（FFL）的特定基序。FFL被定义为一个诱导的 $3$ 节点三元组，恰好有三条边形成一条带捷径的有向无环路径：$i \\to j$、$j \\to k$ 和 $i \\to k$。我们将其定义为有序三元组 $(i,j,k)$ 的规范标记模式，其中 $i$ 是源节点，$j$ 是中间节点，$k$ 是汇节点。\n\n该模式的指示函数 $I_{FFL}(i,j,k)$ 要求存在边 $i \\to j$、$j \\to k$ 和 $i \\to k$，并且不存在反向边 $j \\to i$、$k \\to j$ 和 $k \\to i$。该函数为：\n$$I_{FFL}(i,j,k) = \\mathbf{A}_{ij}\\mathbf{A}_{jk}\\mathbf{A}_{ik}(1-\\mathbf{A}_{ji})(1-\\mathbf{A}_{kj})(1-\\mathbf{A}_{ki})$$\n为了找到对称因子 $S_{FFL}$，我们确定 FFL 图的自同构群的大小。FFL 中的节点具有独特的角色，可通过其在基序内的入度和出度来区分：\n- 源节点 ($i$)：入度为 $0$，出度为 $2$。\n- 中间节点 ($j$)：入度为 $1$，出度为 $1$。\n- 汇节点 ($k$)：入度为 $2$，出度为 $0$。\n由于所有三个节点都具有不同的度特征，任何自同构都必须将每个节点映射到其自身。因此，自同构群是平凡的，仅包含单位置换。所以，$|\\text{Aut}(FFL)| = 1$，对称因子 $S_{FFL}=1$。\n这意味着对于网络中每个诱导 FFL 子图的实例，其节点中恰好只有一个有序三元组能匹配该规范模式。因此，总数就是原始求和：\n$$N_{FFL} = \\sum_{i,j,k \\text{ distinct}} I_{FFL}(i,j,k)$$\n我们现在对给定的邻接矩阵计算这个和：\n$$\n\\mathbf{A}=\n\\begin{pmatrix}\n0  1  1  0  0  0 \\\\\n0  0  1  0  0  0 \\\\\n0  0  0  0  0  0 \\\\\n0  0  0  0  1  1 \\\\\n0  0  0  0  0  1 \\\\\n0  0  0  0  0  0 \\\\\n\\end{pmatrix}\n$$\n$I_{FFL}$ 中的乘积仅在 $\\mathbf{A}_{ij}=1$, $\\mathbf{A}_{jk}=1$ 和 $\\mathbf{A}_{ik}=1$ 时非零。条件 $\\mathbf{A}_{ij}\\mathbf{A}_{jk}=1$ 意味着存在一条从 $i$ 经过 $j$ 到 $k$ 的长度为 $2$ 的路径。我们可以系统地寻找这样的路径。\n\n让我们搜索满足 $\\mathbf{A}_{ij}=1$ 和 $\\mathbf{A}_{jk}=1$ 的三元组 $(i,j,k)$:\n1.  路径 $1 \\to 2 \\to 3$：我们有 $\\mathbf{A}_{12}=1$ 和 $\\mathbf{A}_{23}=1$。这给出了候选三元组 $(i,j,k) = (1,2,3)$。\n    - 我们检查捷径边：$\\mathbf{A}_{ik} = \\mathbf{A}_{13}=1$。此条件满足。\n    - 我们检查不存在的边：\n        - $\\mathbf{A}_{ji} = \\mathbf{A}_{21}=0$。满足。\n        - $\\mathbf{A}_{kj} = \\mathbf{A}_{32}=0$。满足。\n        - $\\mathbf{A}_{ki} = \\mathbf{A}_{31}=0$。满足。\n    所有条件都满足。三元组 $(1,2,3)$ 对总和贡献 1。\n\n2.  路径 $4 \\to 5 \\to 6$：我们有 $\\mathbf{A}_{45}=1$ 和 $\\mathbf{A}_{56}=1$。这给出了候选三元组 $(i,j,k) = (4,5,6)$。\n    - 我们检查捷径边：$\\mathbf{A}_{ik} = \\mathbf{A}_{46}=1$。此条件满足。\n    - 我们检查不存在的边：\n        - $\\mathbf{A}_{ji} = \\mathbf{A}_{54}=0$。满足。\n        - $\\mathbf{A}_{kj} = \\mathbf{A}_{65}=0$。满足。\n        - $\\mathbf{A}_{ki} = \\mathbf{A}_{64}=0$。满足。\n    所有条件都满足。三元组 $(4,5,6)$ 对总和贡献 1。\n\n是否还有其他长度为 2 的路径？我们可以检查图的结构。\n- 节点 $1$ 有到 $2$ 和 $3$ 的出边。节点 $2$ 有到 $3$ 的出边。节点 $3$ 没有出边。这只产生了路径 $1 \\to 2 \\to 3$。\n- 节点 $4$ 有到 $5$ 和 $6$ 的出边。节点 $5$ 有到 $6$ 的出边。节点 $6$ 没有出边。这只产生了路径 $4 \\to 5 \\to 6$。\n图中没有其他 $i \\to j \\to k$ 的序列。该图由两个不连通的分量 $\\{1,2,3\\}$ 和 $\\{4,5,6\\}$ 组成，对每个分量内的搜索都已完成。\n\n仅有两个有序三元组 $(1,2,3)$ 和 $(4,5,6)$ 使求和项非零。\n因此，前馈环基序的总数为：\n$$N_{FFL} = 1 + 1 = 2$$\n这两个诱导 FFL 基序位于节点集 $\\{1,2,3\\}$ 和 $\\{4,5,6\\}$ 上。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "在分析了局部基序之后，下一步是理解神经元如何组合成更大的功能单元或社区。本练习探讨了模块度的概念，这是社区发现中的一个关键指标，并解释了分辨率参数 $ \\gamma $ 如何让我们在不同尺度上探索这种组织结构。 通过这项实践，你将深化对如何将网络划分为有意义模块的理解，并掌握其背后的数学原理。",
            "id": "4293166",
            "problem": "考虑一个从神经连接组中提取的小型加权有向微电路，其节点集为 $\\{1,2,3,4\\}$，加权邻接项 $w_{ij}$ 的非零值如下：$w_{12}=3$，$w_{13}=1$，$w_{21}=2$，$w_{23}=2$，$w_{24}=1$，$w_{32}=1$，$w_{34}=2$，$w_{41}=1$，$w_{43}=2$，而对于所有其他有序对 $(i,j)$（包括对所有 $i$ 都有 $w_{ii}=0$），$w_{ij}=0$。令 $m=\\sum_{i,j} w_{ij}$ 表示总权重。假设社群分配为 $c_{1}=c_{2}$ 和 $c_{3}=c_{4}$（两个模块），并且模块度的定义是通过将观察到的社群内部权重与在加权有向网络的度保持（强度保持）零模型下的期望值进行比较，其中带有一个可调分辨率参数 $\\gamma>0$，该参数用于重新缩放期望权重的基线。\n\n任务：\n仅从以下原则出发：\n(1) 一个划分的模块度衡量的是社群内部权重与零模型下期望值之间的归一化偏差。\n(2) 加权有向网络的度保持零模型是这样一个最大熵系综，它固定了每个节点的出强度 $s_{i}^{\\mathrm{out}}=\\sum_{j} w_{ij}$ 和入强度 $s_{j}^{\\mathrm{in}}=\\sum_{i} w_{ij}$ 以及总权重 $m$，\n推导模块度 $Q(\\gamma)$ 的一个显式解析表达式，用 $w_{ij}$、$s_{i}^{\\mathrm{out}}$、$s_{j}^{\\mathrm{in}}$、$m$、$\\gamma$ 和社群标签 $c_{i}$ 表示，并解释在此框架内 $\\gamma$ 对检测到的社群规模的作用和影响。\n\n然后，对于给定的网络和指定的划分，在 $\\gamma=\\frac{6}{5}$ 时计算 $Q(\\gamma)$ 的值，使用约定即 $Q(\\gamma)$ 中的求和遍及所有有序对 $(i,j)$（包括 $i=j$），且 $w_{ii}=0$。将您的最终答案表示为一个精确分数。模块度值是无量纲的。不要提供中间数值的四舍五入；最终答案必须是精确的。",
            "solution": "该问题要求推导带分辨率参数的加权有向网络的模块度表达式，解释该参数的作用，并对一个特定的微电路进行计算。解题过程首先是验证问题陈述，我们发现它是科学合理的、问题明确的且客观的。因此，我们可以继续进行解答。\n\n首先，我们根据所给原则推导模块度 $Q(\\gamma)$ 的解析表达式。\n\n原则(1)指出，模块度衡量的是社群内部权重与零模型下期望值之间的归一化偏差。设节点集为 $V$，节点 $i$ 的社群分配为 $c_i$，加权邻接矩阵为 $W = (w_{ij})$。网络中的总权重为 $m = \\sum_{i,j \\in V} w_{ij}$。模块度 $Q$ 通常表示为对所有节点对 $(i,j)$ 的求和，求和项是观察到的权重 $w_{ij}$ 与零模型下的期望权重 $P_{ij}$ 之差，但仅限于当节点 $i$ 和 $j$ 处于同一社群时。这种选择通过克罗内克δ函数 $\\delta(c_i, c_j)$ 来实现，当 $c_i = c_j$ 时其值为 $1$，否则为 $0$。求和结果由总权重 $m$ 进行归一化。问题还引入了一个分辨率参数 $\\gamma > 0$，用于重新缩放期望权重的基线。综合这些，模块度的表达式为：\n$$\nQ(\\gamma) = \\frac{1}{m} \\sum_{i,j} \\left[ w_{ij} - \\gamma P_{ij} \\right] \\delta(c_i, c_j)\n$$\n\n原则(2)指定了零模型。它是一个最大熵系综，保持每个节点的出强度 $s_i^{\\mathrm{out}} = \\sum_j w_{ij}$ 和入强度 $s_j^{\\mathrm{in}} = \\sum_i w_{ij}$ 不变。这是加权有向网络的标准配置模型。在此模型中，从节点 $i$到节点 $j$ 的有向边的期望权重 $P_{ij}$ 与 $i$ 的出强度和 $j$ 的入强度成正比。一个单位的权重从节点 $i$ 发出的概率是 $\\frac{s_i^{\\mathrm{out}}}{m}$，而在节点 $j$ 终止的概率是 $\\frac{s_j^{\\mathrm{in}}}{m}$。假设这些是独立事件，一个单位的权重从 $i$ 流向 $j$ 的概率是 $\\frac{s_i^{\\mathrm{out}}s_j^{\\mathrm{in}}}{m^2}$。由于系统中总共有 $m$ 个单位的权重，从 $i$到 $j$ 的期望总权重是：\n$$\nP_{ij} = m \\times \\left( \\frac{s_i^{\\mathrm{out}}}{m} \\frac{s_j^{\\mathrm{in}}}{m} \\right) = \\frac{s_i^{\\mathrm{out}} s_j^{\\mathrm{in}}}{m}\n$$\n将此 $P_{ij}$ 的表达式代入模块度方程，得到所需的显式解析表达式：\n$$\nQ(\\gamma) = \\frac{1}{m} \\sum_{i,j} \\left( w_{ij} - \\gamma \\frac{s_i^{\\mathrm{out}} s_j^{\\mathrm{in}}}{m} \\right) \\delta(c_i, c_j)\n$$\n\n接下来，我们解释分辨率参数 $\\gamma$ 的作用。$\\gamma \\frac{s_i^{\\mathrm{out}} s_j^{\\mathrm{in}}}{m}$ 项作为对社群内部连接的惩罚项，这些连接在一个具有相同强度序列的网络中是随机期望存在的。\n- 如果 $\\gamma  1$，惩罚被放大。这使得一组节点更难被识别为一个社群；只有社群内部连通性显著高于期望值的群体才会产生正的模块度贡献。这种设置有利于检测更小、更密集的社群，从而提供高分辨率的社群结构。\n- 如果 $0  \\gamma  1$，惩罚被减弱。这使得一组节点更容易被识别为社群，即使它们的内部连通性不是特别强。这种设置有利于检测更大、密度较低的社群，提供对网络组织的低分辨率视图。\n- 如果 $\\gamma = 1$，表达式简化为加权有向图模块度的标准形式。因此，$\\gamma$ 是一个可调参数，允许在不同尺度上探索社群结构。\n\n最后，我们针对给定的网络、划分和 $\\gamma = \\frac{6}{5}$ 计算 $Q(\\gamma)$ 的值。该网络的节点集为 $\\{1, 2, 3, 4\\}$，其非零权重如下：$w_{12}=3$，$w_{13}=1$，$w_{21}=2$，$w_{23}=2$，$w_{24}=1$，$w_{32}=1$，$w_{34}=2$，$w_{41}=1$，$w_{43}=2$。\n\n首先，我们计算强度序列和总权重 $m$。\n出强度为：\n$s_1^{\\mathrm{out}} = w_{12} + w_{13} = 3 + 1 = 4$\n$s_2^{\\mathrm{out}} = w_{21} + w_{23} + w_{24} = 2 + 2 + 1 = 5$\n$s_3^{\\mathrm{out}} = w_{32} + w_{34} = 1 + 2 = 3$\n$s_4^{\\mathrm{out}} = w_{41} + w_{43} = 1 + 2 = 3$\n\n入强度为：\n$s_1^{\\mathrm{in}} = w_{21} + w_{41} = 2 + 1 = 3$\n$s_2^{\\mathrm{in}} = w_{12} + w_{32} = 3 + 1 = 4$\n$s_3^{\\mathrm{in}} = w_{13} + w_{23} + w_{43} = 1 + 2 + 2 = 5$\n$s_4^{\\mathrm{in}} = w_{24} + w_{34} = 1 + 2 = 3$\n\n总权重为 $m = \\sum_i s_i^{\\mathrm{out}} = 4 + 5 + 3 + 3 = 15$。（检验：$\\sum_j s_j^{\\mathrm{in}} = 3 + 4 + 5 + 3 = 15$）。\n\n给定的划分是两个模块：$C_1 = \\{1, 2\\}$ 和 $C_2 = \\{3, 4\\}$。\n我们可以通过对每个社群的项进行分组来重写模块度求和：\n$$\nQ(\\gamma) = \\frac{1}{m} \\left[ \\sum_{i,j \\in C_1} \\left( w_{ij} - \\gamma \\frac{s_i^{\\mathrm{out}} s_j^{\\mathrm{in}}}{m} \\right) + \\sum_{i,j \\in C_2} \\left( w_{ij} - \\gamma \\frac{s_i^{\\mathrm{out}} s_j^{\\mathrm{in}}}{m} \\right) \\right]\n$$\n让我们分析每个社群的贡献。\n\n对于社群 $C_1 = \\{1, 2\\}$：\n总内部权重为 $W_1 = \\sum_{i,j \\in C_1} w_{ij} = w_{11} + w_{12} + w_{21} + w_{22} = 0 + 3 + 2 + 0 = 5$。\n出强度之和为 $S_1^{\\mathrm{out}} = s_1^{\\mathrm{out}} + s_2^{\\mathrm{out}} = 4 + 5 = 9$。\n入强度之和为 $S_1^{\\mathrm{in}} = s_1^{\\mathrm{in}} + s_2^{\\mathrm{in}} = 3 + 4 = 7$。\n期望内部权重项为 $\\sum_{i,j \\in C_1} \\frac{s_i^{\\mathrm{out}} s_j^{\\mathrm{in}}}{m} = \\frac{1}{m} (\\sum_{i \\in C_1} s_i^{\\mathrm{out}})(\\sum_{j \\in C_1} s_j^{\\mathrm{in}}) = \\frac{S_1^{\\mathrm{out}} S_1^{\\mathrm{in}}}{m} = \\frac{9 \\times 7}{15} = \\frac{63}{15} = \\frac{21}{5}$。\n\n对于社群 $C_2 = \\{3, 4\\}$：\n总内部权重为 $W_2 = \\sum_{i,j \\in C_2} w_{ij} = w_{33} + w_{34} + w_{43} + w_{44} = 0 + 2 + 2 + 0 = 4$。\n出强度之和为 $S_2^{\\mathrm{out}} = s_3^{\\mathrm{out}} + s_4^{\\mathrm{out}} = 3 + 3 = 6$。\n入强度之和为 $S_2^{\\mathrm{in}} = s_3^{\\mathrm{in}} + s_4^{\\mathrm{in}} = 5 + 3 = 8$。\n期望内部权重项为 $\\sum_{i,j \\in C_2} \\frac{s_i^{\\mathrm{out}} s_j^{\\mathrm{in}}}{m} = \\frac{S_2^{\\mathrm{out}} S_2^{\\mathrm{in}}}{m} = \\frac{6 \\times 8}{15} = \\frac{48}{15} = \\frac{16}{5}$。\n\n现在我们结合这些结果得到 $Q(\\gamma)$:\n$$\nQ(\\gamma) = \\frac{1}{m} \\left[ \\left(W_1 - \\gamma \\frac{S_1^{\\mathrm{out}} S_1^{\\mathrm{in}}}{m}\\right) + \\left(W_2 - \\gamma \\frac{S_2^{\\mathrm{out}} S_2^{\\mathrm{in}}}{m}\\right) \\right]\n$$\n$$\nQ(\\gamma) = \\frac{1}{15} \\left[ \\left(5 - \\gamma \\frac{21}{5}\\right) + \\left(4 - \\gamma \\frac{16}{5}\\right) \\right] = \\frac{1}{15} \\left[ 9 - \\gamma \\left(\\frac{21}{5} + \\frac{16}{5}\\right) \\right] = \\frac{1}{15} \\left( 9 - \\gamma \\frac{37}{5} \\right)\n$$\n最后，我们代入 $\\gamma = \\frac{6}{5}$：\n$$\nQ\\left(\\frac{6}{5}\\right) = \\frac{1}{15} \\left( 9 - \\frac{6}{5} \\cdot \\frac{37}{5} \\right) = \\frac{1}{15} \\left( 9 - \\frac{222}{25} \\right)\n$$\n为了减去分数，我们找到一个共同的分母：\n$$\nQ\\left(\\frac{6}{5}\\right) = \\frac{1}{15} \\left( \\frac{9 \\times 25}{25} - \\frac{222}{25} \\right) = \\frac{1}{15} \\left( \\frac{225 - 222}{25} \\right) = \\frac{1}{15} \\left( \\frac{3}{25} \\right)\n$$\n$$\nQ\\left(\\frac{6}{5}\\right) = \\frac{3}{15 \\times 25} = \\frac{1}{5 \\times 25} = \\frac{1}{125}\n$$\n模块度值是按要求给出的精确分数。",
            "answer": "$$\\boxed{\\frac{1}{125}}$$"
        },
        {
            "introduction": "神经网络不仅仅是抽象的图，它们是嵌入在物理空间中的系统，其布线成本至关重要。本练习通过一个约束优化问题，将“布线经济学”原理付诸实践。 通过在保持网络基本属性（如度序列和连通性）的同时尝试减少总布线长度，你将获得关于物理约束如何塑造神经连接组拓扑结构的第一手经验。",
            "id": "4293136",
            "problem": "考虑一个表示神经连接组的空间嵌入无向简单图，其中节点为神经元，边为轴突或树突连接。每个节点 $i$ 都有一个固定位置 $\\mathbf{x}_i \\in \\mathbb{R}^2$，一条无向边 $\\{u,v\\}$ 产生的布线成本等于其欧几里得距离 $\\|\\mathbf{x}_u - \\mathbf{x}_v\\|_2$。图 $G=(V,E)$ 的总布线长度为 $$L(G) = \\sum_{\\{u,v\\}\\in E} \\|\\mathbf{x}_u - \\mathbf{x}_v\\|_2.$$ 神经连接组学中的布线经济原则假定，对于给定的功能结构，生物神经网络通常在满足结构约束的前提下最小化总布线长度。在本问题中，这些约束是固定的度序列和保持全局连通性。\n\n请构建一个约束优化问题，通过保持节点度和全局连通性的重布线，将总布线长度减少一个固定比例 $r \\in (0,1)$。允许的重布线操作是双边交换：将两条不相交的边 $\\{a,b\\}$ 和 $\\{c,d\\}$（其中 $a,b,c,d$ 均不相同）替换为 $\\{a,c\\}$ 和 $\\{b,d\\}$ 或 $\\{a,d\\}$ 和 $\\{b,c\\}$，前提是生成的图保持简单性（无自环或平行边）和连通性。目标是找到一个此类交换的序列，得到一个图 $G'$，使得 $L(G') \\leq (1-r)\\,L(G)$，同时保持每个节点的度和图的连通性。如果不存在这样的图，则该过程应在这些操作下于一个局部最优解处终止。\n\n从以下三个测试用例开始，实现一个确定性算法，该算法迭代地应用最佳可用双边交换（即最大程度减少总布线长度的交换），同时保持图的简单性和连通性，直到达到目标缩减量或不存在改进交换为止。对于每个测试用例，计算比率 $L(G_{\\text{final}})/L(G_{\\text{initial}})$，四舍五入至六位小数，其中 $G_{\\text{final}}$ 是终止时的图。当使用角度时，必须以弧度为单位。\n\n测试套件：\n- 测试用例 A（理想路径，中等规模，异构几何）：\n  - 节点 $V = \\{0,1,2,3,4,5,6,7,8,9\\}$ 及其位置\n    - $\\mathbf{x}_0 = (0.05, 0.10)$,\n    - $\\mathbf{x}_1 = (0.15, 0.92)$,\n    - $\\mathbf{x}_2 = (0.90, 0.80)$,\n    - $\\mathbf{x}_3 = (0.85, 0.15)$,\n    - $\\mathbf{x}_4 = (0.40, 0.50)$,\n    - $\\mathbf{x}_5 = (0.60, 0.55)$,\n    - $\\mathbf{x}_6 = (0.20, 0.20)$,\n    - $\\mathbf{x}_7 = (0.30, 0.85)$,\n    - $\\mathbf{x}_8 = (0.70, 0.25)$,\n    - $\\mathbf{x}_9 = (0.10, 0.60)$。\n  - 初始无向边集 $E$：\n    - $\\{0,2\\}$, $\\{0,7\\}$, $\\{0,6\\}$, $\\{1,3\\}$, $\\{1,9\\}$, $\\{1,5\\}$, $\\{2,8\\}$, $\\{2,5\\}$, $\\{3,4\\}$, $\\{3,6\\}$, $\\{4,5\\}$, $\\{4,9\\}$, $\\{7,9\\}$, $\\{6,8\\}$, $\\{7,8\\}$。\n  - 目标缩减比例 $r = 0.07$。\n- 测试用例 B（趋向局部最优的边界情况，几何环形晶格）：\n  - 节点 $V = \\{0,1,2,3,4,5,6,7,8,9,10,11\\}$ 排列在一个以 $(0.5, 0.5)$ 为中心、半径为 $0.45$ 的圆上：\n    - $\\mathbf{x}_i = \\big(0.5 + 0.45 \\cos(2\\pi i / 12),\\; 0.5 + 0.45 \\sin(2\\pi i / 12)\\big)$，对于 $i \\in \\{0,1,\\dots,11\\}$，角度以弧度为单位。\n  - 初始无向边集 $E$ 通过将每个节点连接到其两个最近的环上邻居和一个较长的弦而形成：\n    - 对于每个 $i$，包含 $\\{i, (i+1)\\bmod 12\\}$、$\\{i, (i-1)\\bmod 12\\}$ 和 $\\{i, (i+3)\\bmod 12\\}$，将图视为无向简单图（即，每个无序对只包含一次）。\n  - 目标缩减比例 $r = 0.02$。\n- 测试用例 C（边缘情况，完全图；无法进行重布线更改）：\n  - 节点 $V = \\{0,1,2,3,4,5,6,7\\}$ 及其位置\n    - $\\mathbf{x}_0 = (0.10, 0.10)$,\n    - $\\mathbf{x}_1 = (0.20, 0.80)$,\n    - $\\mathbf{x}_2 = (0.80, 0.20)$,\n    - $\\mathbf{x}_3 = (0.90, 0.90)$,\n    - $\\mathbf{x}_4 = (0.50, 0.50)$,\n    - $\\mathbf{x}_5 = (0.30, 0.70)$,\n    - $\\mathbf{x}_6 = (0.70, 0.30)$,\n    - $\\mathbf{x}_7 = (0.40, 0.60)$。\n  - 初始无向边集 $E$ 是 8 个节点上的完全图：包含所有满足 $0 \\le i  j \\le 7$ 的点对 $\\{i,j\\}$。\n  - 目标缩减比例 $r = 0.10$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result}_A,\\text{result}_B,\\text{result}_C]$）。每个结果必须是相应测试用例的最终总布线长度除以初始总布线长度，作为一个浮点数，四舍五入到小数点后六位，无单位。",
            "solution": "该问题提出了一个基于神经连接组学中布线经济原则的约束优化任务。我们得到一个空间嵌入的无向简单图 $G=(V, E)$，其中节点 $V$ 代表具有固定位置 $\\mathbf{x}_i \\in \\mathbb{R}^2$ 的神经元，边 $E$ 代表连接。一条边 $\\{u,v\\}$ 的成本是其欧几里得长度 $\\|\\mathbf{x}_u - \\mathbf{x}_v\\|_2$，图的总布线长度为 $L(G) = \\sum_{\\{u,v\\}\\in E} \\|\\mathbf{x}_u - \\mathbf{x}_v\\|_2$。\n\n目标是将总布线长度 $L(G)$ 减少一个目标比例 $r \\in (0,1)$，达到新值 $L(G') \\leq (1-r)L(G)$。此优化受到两个关键要求的约束：必须保持每个节点的度，且图必须保持连通。唯一允许的操作是双边交换，这是一种标准的保持度的重布线移动。此操作选择两条不相交的边 $\\{a,b\\}$ 和 $\\{c,d\\}$，并将它们替换为两对可能的新边之一：要么是 $\\{a,c\\}$ 和 $\\{b,d\\}$，要么是 $\\{a,d\\}$ 和 $\\{b,c\\}$。仅当结果图保持简单（无平行边）和连通时，交换才有效。\n\n该问题要求实现一个确定性的贪心算法。在每一步中，算法必须识别所有可能的有效双边交换，并执行那个能带来最大总布线长度减少的交换。这个迭代过程持续进行，直到达到目标布线长度，或者直到没有进一步减少长度的交换可用为止，此时图相对于交换操作处于局部最小值。每个测试用例的最终输出是最终布线长度与初始布线长度之比，$L(G_{\\text{final}})/L(G_{\\text{initial}})$。\n\n方法论步骤如下：\n\n$1$. **初始化**：对于每个测试用例，使用节点位置 $\\mathbf{x}_i$ 和初始边集 $E$ 来构建图表示。计算初始总布线长度 $L_{\\text{initial}}$。由此确定目标长度 $L_{\\text{target}} = (1-r)L_{\\text{initial}}$。我们使用一组排序元组来表示无向简单图，其中每个元组 `(u, v)` (其中 $u  v$) 对应一条边 $\\{u,v\\}$。\n\n$2$. **贪心迭代优化**：算法的核心是一个循环，只要当前布线长度 $L_{\\text{current}}$ 大于 $L_{\\text{target}}$，该循环就会继续。\n   a. **候选搜索**：在每次迭代中，我们搜索最优的有效交换。这涉及遍历当前图中所有不同的边对 $\\{a,b\\}$ 和 $\\{c,d\\}$。对于每个这样的对，我们确保四个节点 $a, b, c, d$ 是互不相同的。\n   b. **交换评估**：我们评估两种可能的交换：\n      i. 交换 1：用新边 $\\{a,c\\}, \\{b,d\\}$ 替换 $\\{a,b\\}, \\{c,d\\}$。\n      ii. 交换 2：用新边 $\\{a,d\\}, \\{b,c\\}$ 替换 $\\{a,b\\}, \\{c,d\\}$。\n   c. **约束验证**：对于每个潜在的交换，我们验证两个约束：\n      i. **简单性**：提议的新边不能已存在于图中。使用基于集合的图表示法可以高效地进行此检查。\n      ii. **连通性**：交换后图必须保持连通。我们通过创建一个带有交换后边的临时图状态，并从任意节点开始执行图遍历（如广度优先搜索 (BFS) 或深度优先搜索 (DFS)）来验证这一点。当且仅当遍历访问了所有 $|V|$ 个节点时，图是连通的。\n   d. **成本效益分析**：如果交换有效，我们计算布线长度的变化量 $\\Delta L = L_{\\text{new}} - L_{\\text{old}}$。如果 $\\Delta L  0$，则交换是改进的。我们跟踪提供最大长度减少（即最负的 $\\Delta L$）的有效交换。\n   e. **状态更新**：在评估所有可能的交换后，如果找到了改进的交换，我们就将最佳交换应用于图的边集，并更新当前总长度 $L_{\\text{current}}$。如果不存在改进的交换，则图处于局部最优状态，该测试用例的优化过程终止。\n\n$3$. **终止与输出**：当达到目标长度 $L_{\\text{target}}$ 或收敛到局部最小值时，循环终止。最终布线长度 $L_{\\text{final}}$ 是终止时图的长度。然后计算所需的比率 $L_{\\text{final}}/L_{\\text{initial}}$。\n\n对于测试用例 C，它涉及一个完全图 $K_8$，不可能进行任何双边交换。对于任何一对不相交的边 $\\{a,b\\}$ 和 $\\{c,d\\}$，潜在的新边 $\\{a,c\\}, \\{b,d\\}, \\{a,d\\}, \\{b,c\\}$ 保证已存在于完全图中。因此，简单性约束永远不会满足，不会执行任何交换，算法预计会立即终止，从而产生 1.0 的长度比。这证明了算法能正确处理约束检查。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the neural connectome wiring economy problem for three test cases.\n    \"\"\"\n\n    def run_single_case(params):\n        \"\"\"\n        Executes the greedy optimization for a single test case.\n        \"\"\"\n        node_positions, initial_edges, r = params\n        \n        positions = np.array(node_positions)\n        edge_set = {tuple(sorted(e)) for e in initial_edges}\n        num_nodes = len(positions)\n\n        def get_dist(n1, n2):\n            return np.linalg.norm(positions[n1] - positions[n2])\n\n        def get_total_length(current_edges):\n            if not current_edges:\n                return 0.0\n            return sum(get_dist(u, v) for u, v in current_edges)\n\n        def is_connected(current_edges):\n            if num_nodes == 0:\n                return True\n            adj = {i: [] for i in range(num_nodes)}\n            if not current_edges:\n                return num_nodes == 1\n            \n            for u, v in current_edges:\n                adj[u].append(v)\n                adj[v].append(u)\n\n            start_node = next(iter(current_edges))[0]\n            q = deque([start_node])\n            visited = {start_node}\n            count = 0\n            while q:\n                u = q.popleft()\n                count += 1\n                for v_neighbor in adj[u]:\n                    if v_neighbor not in visited:\n                        visited.add(v_neighbor)\n                        q.append(v_neighbor)\n            return count == num_nodes\n\n        initial_length = get_total_length(edge_set)\n        if initial_length == 0.0:\n            return 1.0\n\n        target_length = (1.0 - r) * initial_length\n        current_length = initial_length\n\n        while current_length  target_length:\n            best_swap_info = None\n            max_reduction = 0.0\n            \n            edge_list = list(edge_set)\n            \n            for i in range(len(edge_list)):\n                for j in range(i + 1, len(edge_list)):\n                    u1, v1 = edge_list[i]\n                    u2, v2 = edge_list[j]\n\n                    if len({u1, v1, u2, v2}) != 4:\n                        continue\n\n                    original_pair_length = get_dist(u1, v1) + get_dist(u2, v2)\n\n                    # Swap 1: {u1,v1}, {u2,v2} - {u1,u2}, {v1,v2}\n                    new_e1 = tuple(sorted((u1, u2)))\n                    new_e2 = tuple(sorted((v1, v2)))\n                    \n                    if new_e1 not in edge_set and new_e2 not in edge_set:\n                        new_pair_length = get_dist(u1, u2) + get_dist(v1, v2)\n                        reduction = original_pair_length - new_pair_length\n                        \n                        if reduction  max_reduction:\n                            temp_edges = edge_set.copy()\n                            temp_edges.remove(tuple(sorted((u1, v1))))\n                            temp_edges.remove(tuple(sorted((u2, v2))))\n                            temp_edges.add(new_e1)\n                            temp_edges.add(new_e2)\n                            if is_connected(temp_edges):\n                                max_reduction = reduction\n                                best_swap_info = ((u1, v1), (u2, v2), new_e1, new_e2)\n                    \n                    # Swap 2: {u1,v1}, {u2,v2} - {u1,v2}, {v1,u2}\n                    new_e1_alt = tuple(sorted((u1, v2)))\n                    new_e2_alt = tuple(sorted((v1, u2)))\n\n                    if new_e1_alt not in edge_set and new_e2_alt not in edge_set:\n                        new_pair_length_alt = get_dist(u1, v2) + get_dist(v1, u2)\n                        reduction_alt = original_pair_length - new_pair_length_alt\n                        \n                        if reduction_alt  max_reduction:\n                            temp_edges = edge_set.copy()\n                            temp_edges.remove(tuple(sorted((u1, v1))))\n                            temp_edges.remove(tuple(sorted((u2, v2))))\n                            temp_edges.add(new_e1_alt)\n                            temp_edges.add(new_e2_alt)\n                            if is_connected(temp_edges):\n                                max_reduction = reduction_alt\n                                best_swap_info = ((u1, v1), (u2, v2), new_e1_alt, new_e2_alt)\n\n            if best_swap_info:\n                old1, old2, new1, new2 = best_swap_info\n                edge_set.remove(tuple(sorted(old1)))\n                edge_set.remove(tuple(sorted(old2)))\n                edge_set.add(new1)\n                edge_set.add(new2)\n                current_length -= max_reduction\n            else:\n                break\n        \n        final_length = get_total_length(edge_set)\n        ratio = final_length / initial_length\n        return round(ratio, 6)\n\n    # Test Case A\n    nodes_A = [\n        (0.05, 0.10), (0.15, 0.92), (0.90, 0.80), (0.85, 0.15), (0.40, 0.50),\n        (0.60, 0.55), (0.20, 0.20), (0.30, 0.85), (0.70, 0.25), (0.10, 0.60)\n    ]\n    edges_A = [\n        {0,2}, {0,7}, {0,6}, {1,3}, {1,9}, {1,5}, {2,8}, {2,5}, {3,4},\n        {3,6}, {4,5}, {4,9}, {7,9}, {6,8}, {7,8}\n    ]\n    r_A = 0.07\n    case_A = (nodes_A, edges_A, r_A)\n\n    # Test Case B\n    num_nodes_B = 12\n    nodes_B = [(0.5 + 0.45 * np.cos(2 * np.pi * i / num_nodes_B),\n                0.5 + 0.45 * np.sin(2 * np.pi * i / num_nodes_B)) for i in range(num_nodes_B)]\n    edges_B = set()\n    for i in range(num_nodes_B):\n        edges_B.add(tuple(sorted((i, (i + 1) % num_nodes_B))))\n        edges_B.add(tuple(sorted((i, (i - 1 + num_nodes_B) % num_nodes_B))))\n        edges_B.add(tuple(sorted((i, (i + 3) % num_nodes_B))))\n    r_B = 0.02\n    case_B = (nodes_B, list(edges_B), r_B)\n\n    # Test Case C\n    num_nodes_C = 8\n    nodes_C = [\n        (0.10, 0.10), (0.20, 0.80), (0.80, 0.20), (0.90, 0.90),\n        (0.50, 0.50), (0.30, 0.70), (0.70, 0.30), (0.40, 0.60)\n    ]\n    edges_C = []\n    for i in range(num_nodes_C):\n        for j in range(i + 1, num_nodes_C):\n            edges_C.append((i, j))\n    r_C = 0.10\n    case_C = (nodes_C, edges_C, r_C)\n    \n    test_cases = [case_A, case_B, case_C]\n    \n    results = []\n    for case in test_cases:\n        result = run_single_case(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}