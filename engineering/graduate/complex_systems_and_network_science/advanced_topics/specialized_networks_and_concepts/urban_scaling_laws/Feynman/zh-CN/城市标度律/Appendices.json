{
    "hands_on_practices": [
        {
            "introduction": "对城市标度律的任何实证分析，其起点都是将模型与数据进行拟合。虽然理论常指向一个幂律关系，但通过统计方法验证这一假设，并与其它备选模型进行比较是至关重要的。本练习将引导您使用赤池信息准则（Akaike Information Criterion, $AIC$）、贝叶斯信息准则（Bayesian Information Criterion, $BIC$）和似然比检验（Likelihood Ratio Test, $LRT$）等标准工具，来比较一个简单的幂律模型和一个更灵活的对数二次模型，从而为您严谨地进行模型选择提供基础技能。",
            "id": "4312862",
            "problem": "考虑一组城市，其人口规模由 $N_i$ 表示，某个城市量由 $Y_i$ 表示，其中 $i$ 是城市的索引。城市标度律假设，平均而言，城市量 $Y$ 与人口 $N$ 遵循幂律关系进行标度，同时在该均值周围表现出乘性涨落。为了在复杂系统和网络科学的高级研究生水平上执行有原则的模型选择和拟合优度评估，你必须形式化以下内容：\n\n1. 基于定义和经过充分检验的观测的基本假设：\n   - 经典的城市标度律假说假设平均关系 $Y(N)$ 是一个幂律。在对数形式下，该关系是线性的，且乘性的对数正态涨落变为加性的高斯噪声。具体来说，令 $y_i = \\log Y_i$ 和 $x_i = \\log N_i$。那么，单标度（幂律）模型假定 $y_i = a + \\beta x_i + \\varepsilon_i$，其中 $\\varepsilon_i$ 是独立同分布的高斯残差，均值为零，方差为 $\\sigma^2$。\n   - 为了考虑可能由网络结构或社会经济转型引起的标度关系中的曲率，考虑一个扩展的对数-二次模型 $y_i = a + \\beta x_i + \\gamma x_i^2 + \\varepsilon_i$，并采用相同的高斯残差假设。\n   - 在高斯假设下，任一模型中的参数都将通过最大似然估计（MLE）进行估计。\n\n2. 从第一性原理出发，使用以下方法选择最合适的模型并评估其拟合优度：\n   - Akaike 信息准则（AIC），其定义针对一个具有 $k$ 个自由参数和最大对数似然 $\\ell$ 的模型。\n   - Bayesian 信息准则（BIC），其定义针对一个具有 $k$ 个自由参数、样本大小为 $n$ 和最大对数似然 $\\ell$ 的模型。\n   - 用于嵌套模型的似然比检验（LRT），通过比较单标度模型和对数-二次模型，并报告在适当的渐近分布下的 $p$ 值。\n   - 一种基于残差的拟合优度诊断方法：用 $\\sigma$ 的最大似然估计（MLE）对拟合模型下的残差进行标准化，并对标准正态分布应用单样本 Kolmogorov-Smirnov（KS）检验以获得 $p$ 值。该检验用于验证由乘性对数正态涨落所隐含的高斯残差假设的充分性。\n\n3. 实现要求：\n   - 通过在 $x_i = \\log N_i$ 空间中求解相应的高斯残差线性回归，对单标度模型和对数-二次模型执行最大似然估计（MLE）。\n   - 在高斯假设下，使用残差方差的MLE计算每个模型的最大对数似然 $\\ell$，并如下推导 AIC 和 BIC 的 $k$ 值：将所有回归系数和残差方差参数 $\\sigma^2$ 都包含在 $k$ 中。对于单标度模型，$k=3$。对于对数-二次模型，$k=4$。\n   - 使用LRT比较单标度模型和对数-二次模型。当 $\\gamma = 0$ 时，对数-二次模型嵌套了单标度模型。使用针对回归系数数量差异（本例中为 $1$）的渐近卡方分布报告LRT的 $p$ 值。\n   - 为进行拟合优度评估，通过将残差除以其标准差的MLE来计算标准化残差 $z_i$，并对标准正态分布应用 Kolmogorov-Smirnov 检验以获得 $p$ 值。\n\n4. 测试套件和数据生成：\n   - 您必须确定性地生成合成数据集，不使用任何随机数生成器，以确保可复现性。对每个数据集执行以下操作：\n     - 令 $n$ 为城市数量。\n     - 令 $N_{\\min}$ 和 $N_{\\max}$ 定义人口规模范围。\n     - 令 $a$、$\\beta$、$\\gamma$ 定义对数均值关系 $y_i = a + \\beta x_i + \\gamma x_i^2 + \\varepsilon_i$，其中 $x_i = \\log N_i$。\n     - 令 $\\sigma$ 定义高斯残差的尺度。\n     - 对于 $i=1,\\dots,n$，将 $x_i$ 构建为在 $\\log N_{\\min}$ 和 $\\log N_{\\max}$ 之间线性间隔的值。具体来说，$x_i$ 是在 $[\\log N_{\\min}, \\log N_{\\max}]$ 上的 $n$ 个等间距点。\n     - 通过选择分位数 $q_i = \\frac{i - 0.5}{n}$ 并设置 $\\varepsilon_i = \\sigma \\Phi^{-1}(q_i)$ 来构造确定性的高斯残差，其中 $\\Phi^{-1}$ 是标准正态分布的逆累积分布函数。\n     - 设置 $y_i = a + \\beta x_i + \\gamma x_i^2 + \\varepsilon_i$ 和 $Y_i = \\exp(y_i)$。\n   - 定义四个数据集（测试用例），每个由 $(n, N_{\\min}, N_{\\max}, a, \\beta, \\gamma, \\sigma)$ 指定：\n     1. 用例 1：$n = 20$, $N_{\\min} = 10000$, $N_{\\max} = 10000000$, $a = 1.0$, $\\beta = 1.15$, $\\gamma = 0.0$, $\\sigma = 0.2$。\n     2. 用例 2：$n = 25$, $N_{\\min} = 5000$, $N_{\\max} = 20000000$, $a = 0.5$, $\\beta = 0.9$, $\\gamma = 0.06$, $\\sigma = 0.15$。\n     3. 用例 3：$n = 8$, $N_{\\min} = 20000$, $N_{\\max} = 2000000$, $a = 2.0$, $\\beta = 1.0$, $\\gamma = 0.0$, $\\sigma = 0.3$。\n     4. 用例 4：$n = 30$, $N_{\\min} = 8000$, $N_{\\max} = 30000000$, $a = 1.0$, $\\beta = 1.05$, $\\gamma = -0.02$, $\\sigma = 0.25$。\n\n5. 所需输出：\n   - 对于每个数据集，按此顺序计算并返回四个值：\n     1. 基于AIC的模型选择指标，其中 $1$ 表示单标度（幂律）模型，$2$ 表示对数-二次模型。\n     2. 基于BIC的模型选择指标，其中 $1$ 表示单标度模型，$2$ 表示对数-二次模型。\n     3. 比较单标度模型与对数-二次模型的LRT $p$ 值。\n     4. AIC所选模型的标准化残差相对于标准正态分布的KS检验 $p$ 值。\n   - 最终输出必须将所有四个数据集的结果汇总到单行中。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$。具体来说，输出必须包含 $16$ 个条目，对应于 $4$ 个测试用例中每个用例的四个值，并按测试用例排序。整数指标必须打印为整数，每个 $p$ 值必须打印为四舍五入到六位小数的小数。",
            "solution": "该问题是有效的。这是一个在计算统计学领域中提法明确、有科学依据的问题，特别关注城市标度律的模型选择和拟合优度。其前提与复杂系统领域的既有文献一致，并且各项任务都以数学精度进行了规定，包括模型、估计方法、检验统计量和数据生成过程。所有术语都定义清晰，问题是自洽的。\n\n解决方案的步骤是首先生成所需的合成数据集，然后按规定对每个数据集应用一系列统计分析。\n\n### 1. 数据生成\n对于四个测试用例中的每一个，都确定性地构建一个合成数据集。每个用例的参数由元组 $(n, N_{\\min}, N_{\\max}, a, \\beta, \\gamma, \\sigma)$ 给出，其中 $n$ 是城市数量，$N_{\\min}$ 和 $N_{\\max}$ 定义了人口范围，$a, \\beta, \\gamma, \\sigma$ 是生成模型的参数。\n\n自变量，即对数人口 $x_i = \\log N_i$，是通过在区间 $[\\log N_{\\min}, \\log N_{\\max}]$ 上创建 $n$ 个线性间隔点来构建的。\n$$ x_i = \\log N_{\\min} + (i-1) \\frac{\\log N_{\\max} - \\log N_{\\min}}{n-1} \\quad \\text{for } i = 1, \\dots, n $$\n残差 $\\varepsilon_i$ 是确定性地生成的，以服从均值为 $0$、标准差为 $\\sigma$ 的高斯分布。这是通过使用标准正态累积分布函数的逆函数 $\\Phi^{-1}(q)$（也称为分位数函数）来实现的。我们定义分位数 $q_i = \\frac{i-0.5}{n}$（对于 $i=1, \\dots, n$），并将残差设置为：\n$$ \\varepsilon_i = \\sigma \\Phi^{-1}(q_i) $$\n最后，因变量，即对数量 $y_i = \\log Y_i$，使用指定的对数-二次模型形式生成：\n$$ y_i = a + \\beta x_i + \\gamma x_i^2 + \\varepsilon_i $$\n\n### 2. 模型拟合与对数似然\n将两个模型拟合到每个合成数据集 $(x_i, y_i)$：\n- **模型 1（单标度）:** $y_i = a_1 + \\beta_1 x_i + \\varepsilon_i$\n- **模型 2（对数-二次）:** $y_i = a_2 + \\beta_2 x_i + \\gamma_2 x_i^2 + \\varepsilon_i$\n\n在独立同分布（i.i.d.）高斯残差的假设下，回归系数 $(a, \\beta, \\gamma)$ 的最大似然估计（MLE）等价于普通最小二乘法（OLS）。对于每个模型，我们求解线性系统以找到最小化残差平方和的系数。\n\n设数据点数量为 $n$。对于给定模型，设预测值为 $\\hat{y}_i$。残差为 $\\hat{\\varepsilon}_i = y_i - \\hat{y}_i$。残差方差的 MLE 为：\n$$ \\hat{\\sigma}^2_{\\text{MLE}} = \\frac{1}{n} \\sum_{i=1}^n \\hat{\\varepsilon}_i^2 $$\n对于一个具有 $n$ 个数据点和方差MLE估计值为 $\\hat{\\sigma}^2_{\\text{MLE}}$ 的模型，其最大化对数似然 $\\ell_{\\max}$ 由下式给出：\n$$ \\ell_{\\max} = - \\frac{n}{2} \\log(2\\pi) - \\frac{n}{2} \\log(\\hat{\\sigma}^2_{\\text{MLE}}) - \\frac{1}{2\\hat{\\sigma}^2_{\\text{MLE}}} \\sum_{i=1}^n \\hat{\\varepsilon}_i^2 = - \\frac{n}{2} \\left( \\log(2\\pi\\hat{\\sigma}^2_{\\text{MLE}}) + 1 \\right) $$\n对模型1和模型2都执行此计算，分别得到 $\\ell_{\\max,1}$ 和 $\\ell_{\\max,2}$。\n\n### 3. 模型选择\n我们使用两个信息准则，AIC 和 BIC，来选择更优的模型。这两个准则都会对参数更多的模型进行惩罚。准则值较低的模型更优。\n\n- **Akaike 信息准则 (AIC):** $AIC = 2k - 2\\ell_{\\max}$\n- **Bayesian 信息准则 (BIC):** $BIC = k \\log(n) - 2\\ell_{\\max}$\n\n此处，$k$ 是估计参数的总数。根据规定，$k$ 包括回归系数和方差。\n- 对于模型 1，参数为 $(a_1, \\beta_1, \\sigma_1^2)$，所以 $k_1 = 3$。\n- 对于模型 2，参数为 $(a_2, \\beta_2, \\gamma_2, \\sigma_2^2)$，所以 $k_2 = 4$。\n\n如果选择模型1，则分配指标 $1$；如果选择模型2，则分配指标 $2$。如果出现平局，则选择更简单的模型（模型1）。\n\n### 4. 似然比检验（LRT）\nLRT 用于比较嵌套模型。模型1嵌套于模型2中，因为当 $\\gamma=0$ 时，模型2即为模型1。零假设为 $H_0: \\gamma=0$。检验统计量为：\n$$ \\lambda_{LR} = 2(\\ell_{\\max,2} - \\ell_{\\max,1}) $$\n在 $H_0$ 假设下，$\\lambda_{LR}$ 渐近服从卡方分布 $\\chi^2(df)$，其中自由度 $df$ 是两个模型之间自由回归系数数量的差值。此处，模型2多一个系数（$\\gamma$），因此 $df=1$。$p$ 值是在假设 $H_0$ 为真的情况下，观测到等于或比计算出的检验统计量更极端的统计量的概率：\n$$ p_{\\text{LRT}} = P(\\chi^2_1 \\ge \\lambda_{LR}) $$\n\n### 5. 拟合优度：Kolmogorov-Smirnov (KS) 检验\n该检验评估拟合模型的残差是否与假设的高斯分布一致。\n首先，确定由AIC选择的模型。然后，使用标准差的MLE $\\hat{\\sigma}_{\\text{MLE}} = \\sqrt{\\hat{\\sigma}^2_{\\text{MLE}}}$ 对其残差 $\\hat{\\varepsilon}_i$ 进行标准化：\n$$ z_i = \\frac{\\hat{\\varepsilon}_i}{\\hat{\\sigma}_{\\text{MLE}}} $$\n接着，对这些标准化残差 $\\{z_i\\}$ 应用单样本 Kolmogorov-Smirnov 检验。它将标准化残差的经验累积分布函数（ECDF）与标准正态分布的累积分布函数（CDF）$\\Phi(z)$进行比较。该检验得出一个 $p$ 值，$p_{\\text{KS}}$。较高的 $p$ 值（例如 $>0.05$）表明数据与残差来自标准正态分布的零假设并不矛盾，这表示拟合良好。\n\n针对每个测试用例实施这些步骤将产生四个所需的输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm, chi2, kstest\n\ndef solve():\n    \"\"\"\n    Performs model selection and goodness-of-fit analysis for urban scaling laws\n    on four deterministically generated synthetic datasets.\n    \"\"\"\n\n    test_cases = [\n        # (n, N_min, N_max, a, beta, gamma, sigma)\n        (20, 10000, 10000000, 1.0, 1.15, 0.0, 0.2),\n        (25, 5000, 20000000, 0.5, 0.9, 0.06, 0.15),\n        (8, 20000, 2000000, 2.0, 1.0, 0.0, 0.3),\n        (30, 8000, 30000000, 1.0, 1.05, -0.02, 0.25),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        n, N_min, N_max, a_true, beta_true, gamma_true, sigma_true = params\n\n        # === 1. Data Generation ===\n        x_min = np.log(N_min)\n        x_max = np.log(N_max)\n        x = np.linspace(x_min, x_max, n)\n        \n        quantiles = (np.arange(1, n + 1) - 0.5) / n\n        eps = sigma_true * norm.ppf(quantiles)\n        \n        y = a_true + beta_true * x + gamma_true * x**2 + eps\n\n        # === 2. Model Fitting and Log-Likelihood ===\n\n        # Model 1: Single-Scaling (linear) y = a + beta*x\n        X1 = np.c_[np.ones(n), x]\n        k1 = 3 # Parameters: a, beta, sigma^2\n        coeffs1, sum_sq_res1, _, _ = np.linalg.lstsq(X1, y, rcond=None)\n        sigma2_1_hat = sum_sq_res1[0] / n\n        log_L1 = -n / 2 * (np.log(2 * np.pi * sigma2_1_hat) + 1)\n\n        # Model 2: Log-Quadratic y = a + beta*x + gamma*x^2\n        X2 = np.c_[np.ones(n), x, x**2]\n        k2 = 4 # Parameters: a, beta, gamma, sigma^2\n        coeffs2, sum_sq_res2, _, _ = np.linalg.lstsq(X2, y, rcond=None)\n        sigma2_2_hat = sum_sq_res2[0] / n\n        log_L2 = -n / 2 * (np.log(2 * np.pi * sigma2_2_hat) + 1)\n\n        # === 3. Model Selection (AIC/BIC) ===\n        aic1 = 2 * k1 - 2 * log_L1\n        aic2 = 2 * k2 - 2 * log_L2\n        aic_indicator = 1 if aic1 = aic2 else 2\n\n        bic1 = k1 * np.log(n) - 2 * log_L1\n        bic2 = k2 * np.log(n) - 2 * log_L2\n        bic_indicator = 1 if bic1 = bic2 else 2\n\n        # === 4. Likelihood Ratio Test (LRT) ===\n        # H0: single-scaling (gamma=0), H1: log-quadratic\n        lrt_stat = 2 * (log_L2 - log_L1)\n        # The test statistic must be non-negative\n        lrt_stat = max(0, lrt_stat)\n        lrt_p_value = chi2.sf(lrt_stat, df=1) # df = k2_coeffs - k1_coeffs = 3 - 2 = 1\n\n        # === 5. Goodness-of-Fit (KS Test) ===\n        if aic_indicator == 1:\n            y_pred = X1 @ coeffs1\n            residuals = y - y_pred\n            sigma_mle = np.sqrt(sigma2_1_hat)\n        else: # aic_indicator == 2\n            y_pred = X2 @ coeffs2\n            residuals = y - y_pred\n            sigma_mle = np.sqrt(sigma2_2_hat)\n\n        standardized_residuals = residuals / sigma_mle\n        ks_stat, ks_p_value = kstest(standardized_residuals, 'norm')\n\n        # === Aggregate and format results for the current case ===\n        all_results.extend([\n            aic_indicator,\n            bic_indicator,\n            f\"{lrt_p_value:.6f}\",\n            f\"{ks_p_value:.6f}\"\n        ])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多统计模型，包括常用于估计标度指数的普通最小二乘法（Ordinary Least Squares, $OLS$），都依赖一个关键假设：观测误差是相互独立的。然而，城市并非孤立的实体；它们在地理空间中的邻近性可能导致空间依赖，从而违反这一假设。本实践通过一个动手模拟，让您探究空间自相关存在时可能产生的影响，并介绍了莫兰指数（Moran's $I$）这一重要的诊断工具，用于检测模型残差中是否存在此类空间模式。",
            "id": "4312852",
            "problem": "考虑典型的城市规模缩放公式，其中城市 $i \\in \\{1,\\dots,n\\}$ 的一个非负城市指标 $Y_{i}$ 相对于其人口 $N_{i}$ 遵循乘法定律，即 $Y_{i} = a \\, N_{i}^{\\beta} \\, \\varepsilon_{i}$，其中 $a0$ 是一个常数，$\\beta$ 是我们感兴趣的标度指数，$\\varepsilon_{i}$ 是一个正的乘性扰动。取对数可得 $\\log Y_{i} = \\log a + \\beta \\log N_{i} + \\eta_{i}$，其中 $\\eta_{i} = \\log \\varepsilon_{i}$ 是一个加性扰动。在许多城市系统中，扰动可能因未观测到的区域因素或相互作用过程而表现出空间依赖性。对扰动中空间依赖性的一个标准表示是空间误差模型（SEM），其中 $\\boldsymbol{\\eta}$ 满足 $(\\mathbf{I} - \\rho \\mathbf{W}) \\boldsymbol{\\eta} = \\mathbf{u}$，$\\rho \\in (-1,1)$ 控制空间自相关的强度和符号，$\\mathbf{W}$ 是一个行标准化的空间权重矩阵，$\\mathbf{I}$ 是单位矩阵，$\\mathbf{u}$ 是一个独立同分布的零均值高斯向量，每个分量的方差为 $\\sigma^{2}$。\n\n您的任务是实现一个程序，该程序针对一组指定的测试用例，在上述假设下模拟合成的城市数据，通过对数-对数关系的普通最小二乘法（OLS）估计标度指数，使用莫兰指数 $I$ 量化 OLS 残差中的空间自相关，并报告估计的指数和诊断信息。\n\n使用以下基本依据：\n- 城市规模缩放定义：$\\log Y_{i} = \\log a + \\beta \\log N_{i} + \\eta_{i}$。\n- 普通最小二乘法（OLS）：对于 $\\mathbf{y} = \\log \\mathbf{Y}$ 和 $\\mathbf{X} = [\\mathbf{1}, \\log \\mathbf{N}]$，估计量为 $\\hat{\\boldsymbol{\\theta}} = (\\mathbf{X}^{\\top}\\mathbf{X})^{-1}\\mathbf{X}^{\\top}\\mathbf{y}$，其中 $\\hat{\\boldsymbol{\\theta}} = [\\widehat{\\log a}, \\hat{\\beta}]^{\\top}$。\n- 莫兰指数 $I$：$I = \\dfrac{n}{S_{0}} \\cdot \\dfrac{\\mathbf{e}^{\\top} \\mathbf{W} \\mathbf{e}}{\\mathbf{e}^{\\top} \\mathbf{e}}$，其中 $\\mathbf{e}$ 是 OLS 残差，$S_{0} = \\sum_{i}\\sum_{j} w_{ij}$，$w_{ij}$ 是 $\\mathbf{W}$ 的 $(i,j)$ 项。在无空间自相关的随机化零假设下，期望值为 $\\mathbb{E}[I] = -\\dfrac{1}{n-1}$。\n- 空间误差模型（SEM）：$(\\mathbf{I} - \\rho \\mathbf{W}) \\boldsymbol{\\eta} = \\mathbf{u}$，其中 $\\mathbf{u} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^{2} \\mathbf{I})$ 且 $|\\rho|  1$，以确保对于行标准化的 $\\mathbf{W}$，$(\\mathbf{I} - \\rho \\mathbf{W})$ 是可逆的。\n\n您的程序必须为每个测试用例实现以下步骤：\n1. 从单位正方形中独立抽样，生成 $n$ 个城市位置 $\\{(x_{i}, y_{i})\\}_{i=1}^{n}$，即 $(x_{i}, y_{i}) \\sim \\text{Uniform}([0,1]^{2})$。在每个测试用例中，为该用例的所有随机抽取使用指定的整数随机种子。\n2. 在这些位置上构建 $k$-最近邻空间权重矩阵 $\\mathbf{W}$，过程如下：对于每个城市 $i$，找到与 $i$ 欧几里得距离最小的 $k$ 个不同城市 $j \\neq i$；如果 $j$ 是 $i$ 的 $k$-最近邻之一，则设 $w_{ij} = 1$，否则设 $w_{ij} = 0$；然后进行行标准化，使每个非零行的和为 $1$（即，$w_{ij} \\leftarrow w_{ij} / \\sum_{j} w_{ij}$）。这将产生一个行随机的 $\\mathbf{W}$，其 $S_{0} = \\sum_{i}\\sum_{j} w_{ij} = n$。\n3. 抽取 $\\mathbf{u} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^{2}\\mathbf{I})$ 并通过求解 $(\\mathbf{I} - \\rho \\mathbf{W}) \\boldsymbol{\\eta} = \\mathbf{u}$ 来计算空间自相关的扰动 $\\boldsymbol{\\eta}$。\n4. 首先通过抽取 $\\log N_{i} \\sim \\mathcal{N}(\\mu, \\tau^{2})$（其中 $\\mu = 11.0$ 和 $\\tau = 1.0$）来生成独立的城市人口，然后设置 $N_{i} = \\exp(\\log N_{i})$。这确保了城市规模分布广泛且符合实际。假设 $\\log N_{i}$ 与 $\\boldsymbol{\\eta}$ 之间相互独立。\n5. 设置 $a = 1$ 并构成 $Y_{i} = a \\, N_{i}^{\\beta} \\, \\exp(\\eta_{i})$。然后计算 $\\mathbf{y} = \\log \\mathbf{Y}$ 和 $\\mathbf{X} = [\\mathbf{1}, \\log \\mathbf{N}]$。通过 OLS 估计 $\\hat{\\beta}$。计算 OLS 残差向量 $\\mathbf{e} = \\mathbf{y} - \\mathbf{X}\\hat{\\boldsymbol{\\theta}}$。\n6. 使用上述公式计算莫兰指数 $I$ 以及零假设下的期望值 $\\mathbb{E}[I] = -\\dfrac{1}{n-1}$。报告估计的指数 $\\hat{\\beta}$、偏差 $\\hat{\\beta} - \\beta$、残差的莫兰指数 $I$ 以及零假设下的期望值。\n\n设计一个测试套件，涵盖无自相关、中等正自相关、强正自相关、负自相关和小样本情况：\n- 测试用例 1：$(n, k, \\beta, \\rho, \\sigma, \\text{seed}) = (64, 4, 1.15, 0.0, 0.2, 1)$。\n- 测试用例 2：$(n, k, \\beta, \\rho, \\sigma, \\text{seed}) = (64, 4, 1.15, 0.6, 0.2, 2)$。\n- 测试用例 3：$(n, k, \\beta, \\rho, \\sigma, \\text{seed}) = (64, 4, 0.85, 0.9, 0.3, 3)$。\n- 测试用例 4：$(n, k, \\beta, \\rho, \\sigma, \\text{seed}) = (64, 4, 1.00, -0.5, 0.2, 4)$。\n- 测试用例 5：$(n, k, \\beta, \\rho, \\sigma, \\text{seed}) = (16, 3, 1.20, 0.7, 0.5, 5)$。\n\n您的程序必须按给定顺序为五个测试用例生成单行输出，其中包含一个长度为 5 的列表，每个元素是一个包含四个浮点数的列表：$[\\hat{\\beta}, \\hat{\\beta}-\\beta, I, \\mathbb{E}[I]]$，每个值都四舍五入到 6 位小数。最终打印的行必须严格为一个 Python 风格的列表的列表，例如 $[[b_{1},\\Delta_{1},I_{1},E_{1}],[b_{2},\\Delta_{2},I_{2},E_{2}],\\dots]$，不得包含任何额外文本。",
            "solution": "该问题被认为是有效的，因为它具有科学依据、问题明确、无歧义，并且所有必要的参数和步骤都已明确定义。所提出的模型和方法——城市规模缩放定律、空间误差模型（SEM）、普通最小二乘法（OLS）和莫兰指数 $I$——都是标准方法，适合此项任务。\n\n目标是进行一项模拟研究，以评估在存在空间自相关扰动的情况下，城市规模缩放指数的 OLS 估计量的表现。对于每个测试用例，我们将根据指定的流程生成合成数据，估计模型参数，并计算空间自相关的诊断统计量。\n\n其理论基础是城市规模缩放定律，该定律假设城市指标 $Y_i$ 与城市人口 $N_i$ 之间存在幂律关系：\n$$Y_{i} = a \\, N_{i}^{\\beta} \\, \\varepsilon_{i}$$\n这里，$a  0$ 是一个归一化常数，$\\beta$ 是标度指数，$\\varepsilon_{i}$ 是一个乘性扰动项。为便于线性估计，此方程进行对数转换：\n$$\\log Y_{i} = \\log a + \\beta \\log N_{i} + \\eta_{i}$$\n其中 $\\eta_{i} = \\log \\varepsilon_{i}$ 现在是一个加性扰动。用向量符号表示，此式为 $\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\theta} + \\boldsymbol{\\eta}$，其中 $\\mathbf{y} = \\log\\mathbf{Y}$，设计矩阵为 $\\mathbf{X} = [\\mathbf{1}, \\log\\mathbf{N}]$，参数向量为 $\\boldsymbol{\\theta} = [\\log a, \\beta]^{\\top}$。\n\n问题的一个关键假设是扰动项 $\\eta_i$ 不是独立的，而是表现出空间自相关。这通过空间误差模型（SEM）进行建模，该模型是空间计量经济学的基石。SEM 通过以下关系定义扰动向量 $\\boldsymbol{\\eta}$：\n$$(\\mathbf{I} - \\rho \\mathbf{W}) \\boldsymbol{\\eta} = \\mathbf{u}$$\n其中 $\\mathbf{I}$ 是 $n \\times n$ 的单位矩阵，$\\rho$ 是一个控制空间自相关强度和符号的标量参数，$\\mathbf{W}$ 是一个编码了城市的邻里结构的 $n \\times n$ 空间权重矩阵，$\\mathbf{u}$ 是一个独立同分布误差的向量，具体为 $\\mathbf{u} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^{2}\\mathbf{I})$。因此，扰动向量可以生成为 $\\boldsymbol{\\eta} = (\\mathbf{I} - \\rho \\mathbf{W})^{-1} \\mathbf{u}$。对于行标准化的 $\\mathbf{W}$，约束条件 $|\\rho|  1$ 是必需的，以确保矩阵 $(\\mathbf{I} - \\rho \\mathbf{W})$ 是可逆的。\n\n空间权重矩阵 $\\mathbf{W}$ 是根据城市的地理位置构建的。程序步骤如下：\n1.  从单位正方形 $[0,1]^2$ 上的均匀分布中独立随机抽样，生成 $n$ 个城市位置 $\\{(x_{i}, y_{i})\\}_{i=1}^{n}$。\n2.  对于每个城市 $i$，根据欧几里得距离确定其 $k$ 个最近邻。\n3.  构建一个初始二元矩阵，如果城市 $j$ 是城市 $i$ 的 $k$ 个最近邻之一，则矩阵项 $w_{ij}$ 为 $1$，否则为 $0$。对角线元素 $w_{ii}$ 始终为 $0$。\n4.  通过将每个元素 $w_{ij}$ 除以其行和 $\\sum_j w_{ij}$ 来对该矩阵进行行标准化。得到的矩阵 $\\mathbf{W}$ 是行随机的，意味着每行的和为 $1$。因此，其所有元素的总和 $S_0 = \\sum_{i}\\sum_{j} w_{ij}$ 等于 $n$。\n\n每个测试用例的完整模拟和估计过程如下：\n1.  为保证可复现性，使用特定的种子初始化伪随机数生成器。\n2.  生成城市位置并构建相应的行标准化 $k$-最近邻矩阵 $\\mathbf{W}$。\n3.  从 $\\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I})$ 中抽取独立同分布的误差向量 $\\mathbf{u}$。然后通过求解线性系统 $(\\mathbf{I} - \\rho \\mathbf{W})\\boldsymbol{\\eta} = \\mathbf{u}$ 来计算空间相关的误差向量 $\\boldsymbol{\\eta}$。\n4.  通过从 $\\mathcal{N}(\\mu=11.0, \\tau^2=1.0^2)$ 中抽取 $\\log N_i$ 来生成城市人口 $N_i$。\n5.  使用对数线性模型创建因变量 $\\mathbf{y} = \\log\\mathbf{Y}$，参数为 $a=1$（因此 $\\log a=0$）和给定的 $\\beta$：$\\mathbf{y} = \\beta\\log\\mathbf{N} + \\boldsymbol{\\eta}$。\n6.  使用普通最小二乘法（OLS）估计参数。$\\boldsymbol{\\theta}$ 的 OLS 估计量由公式 $\\hat{\\boldsymbol{\\theta}} = (\\mathbf{X}^{\\top}\\mathbf{X})^{-1}\\mathbf{X}^{\\top}\\mathbf{y}$ 给出。估计的标度指数 $\\hat{\\beta}$ 是 $\\hat{\\boldsymbol{\\theta}}$ 的第二个元素。\n7.  计算 OLS 残差 $\\mathbf{e} = \\mathbf{y} - \\mathbf{X}\\hat{\\boldsymbol{\\theta}}$。然后使用莫兰指数 $I$ 对这些残差进行空间自相关检验。莫兰指数 $I$ 的公式是 $I = \\dfrac{n}{S_{0}} \\cdot \\dfrac{\\mathbf{e}^{\\top} \\mathbf{W} \\mathbf{e}}{\\mathbf{e}^{\\top} \\mathbf{e}}$。由于 $\\mathbf{W}$ 被构建为行随机矩阵，$S_0 = n$，公式简化为 $I = \\dfrac{\\mathbf{e}^{\\top} \\mathbf{W} \\mathbf{e}}{\\mathbf{e}^{\\top} \\mathbf{e}}$。\n8.  将计算出的 $I$ 值与无空间自相关的零假设下的期望值 $\\mathbb{E}[I] = -1/(n-1)$ 进行比较。\n9.  最后，报告四个值：估计的指数 $\\hat{\\beta}$、其偏差 $\\hat{\\beta} - \\beta$、计算出的残差莫兰指数 $I$ 以及零假设下的期望值 $\\mathbb{E}[I]$。\n\n整个过程被系统地实现为代码，以运行指定的测试用例并生成所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef calculate_for_case(params):\n    \"\"\"\n    Runs a single simulation case for the urban scaling model with spatial errors.\n    \"\"\"\n    n, k, beta, rho, sigma, seed = params\n    mu_log_N, tau_log_N = 11.0, 1.0\n    a = 1.0  # As per problem, log(a) = 0\n\n    rng = np.random.default_rng(seed)\n\n    # 1. Generate n city locations from Uniform([0,1]^2)\n    locations = rng.uniform(0.0, 1.0, size=(n, 2))\n\n    # 2. Construct k-nearest-neighbor spatial weight matrix W\n    dist_matrix = cdist(locations, locations, 'euclidean')\n    np.fill_diagonal(dist_matrix, np.inf)\n\n    # Get indices of k nearest neighbors for each city\n    neighbor_indices = np.argpartition(dist_matrix, k, axis=1)[:, :k]\n\n    # Create binary weight matrix\n    W_unstd = np.zeros((n, n))\n    np.put_along_axis(W_unstd, neighbor_indices, 1, axis=1)\n\n    # Row-standardize the matrix\n    row_sums = W_unstd.sum(axis=1, keepdims=True)\n    W = np.divide(W_unstd, row_sums, out=np.zeros_like(W_unstd), where=row_sums != 0)\n\n    # 3. Generate spatially autocorrelated disturbance eta\n    u = rng.normal(loc=0.0, scale=sigma, size=n)\n    A = np.identity(n) - rho * W\n    eta = np.linalg.solve(A, u)\n\n    # 4. Generate city populations N\n    log_N = rng.normal(loc=mu_log_N, scale=tau_log_N, size=n)\n\n    # 5. Formulate log-linear model and estimate by OLS\n    # log(Y) = log(a) + beta * log(N) + eta. Since a=1, log(a)=0.\n    y = beta * log_N + eta\n    \n    # Construct design matrix X = [1, log(N)]\n    X = np.vstack([np.ones(n), log_N]).T\n\n    # Compute OLS estimator: theta_hat = (X'X)^-1 X'y\n    try:\n        XTX_inv = np.linalg.inv(X.T @ X)\n        theta_hat = XTX_inv @ X.T @ y\n    except np.linalg.LinAlgError:\n        # Fallback for singular matrix, although not expected here\n        theta_hat, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n\n    beta_hat = theta_hat[1]\n\n    # Compute OLS residuals\n    e = y - X @ theta_hat\n\n    # 6. Compute Moran’s I\n    # For row-standardized W, S0=n, so the formula is I = (e'We) / (e'e)\n    numerator_I = e.T @ W @ e\n    denominator_I = e.T @ e\n    \n    # Handle case where residuals are all zero\n    if denominator_I == 0.0:\n        moran_I = 0.0\n    else:\n        moran_I = numerator_I / denominator_I\n\n    # Expected value of Moran's I under the null hypothesis\n    E_I = -1.0 / (n - 1)\n    \n    # Bias of the exponent estimate\n    bias = beta_hat - beta\n\n    return [beta_hat, bias, moran_I, E_I]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (n, k, beta, rho, sigma, seed)\n        (64, 4, 1.15, 0.0, 0.2, 1),\n        (64, 4, 1.15, 0.6, 0.2, 2),\n        (64, 4, 0.85, 0.9, 0.3, 3),\n        (64, 4, 1.00, -0.5, 0.2, 4),\n        (16, 3, 1.20, 0.7, 0.5, 5),\n    ]\n\n    results = []\n    for case in test_cases:\n        result_metrics = calculate_for_case(case)\n        results.append(result_metrics)\n\n    # Format the results to 6 decimal places per the problem specification.\n    # The final print statement must match the required format exactly.\n    formatted_results = [[round(val, 6) for val in res] for res in results]\n    print(f\"{formatted_results}\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的城市数据集常常表现出层次结构，例如城市嵌套在不同的区域或国家内，这种结构可能引入系统性的变异。分层模型（Hierarchical Models）为捕捉此类群体层面的效应提供了一种优雅的解决方案。本练习将介绍一个贝叶斯框架来拟合一个分层标度模型，使您能够同时估计一个全局的标度指数和特定于群体的调整项，从而展示一种处理数据异质性的强大方法。",
            "id": "4312865",
            "problem": "考虑经典的城市规模缩放定律，该定律将一个外延性城市量与人口联系起来：城市产出 $Y$ 的期望值与人口 $N$ 呈幂律关系进行规模缩放。标准公式假设存在一个乘性的对数正态波动，得到 $Y = A N^{\\beta} \\exp(\\varepsilon)$，其中 $A$ 是基线因子，$\\beta$ 是规模缩放指数，$\\varepsilon$ 是零均值随机项。取自然对数后，在存在高斯噪声的情况下得到一个线性关系：$y = a + \\beta x + \\varepsilon$，其中 $y = \\log Y$，$x = \\log N$，且 $\\varepsilon \\sim \\mathcal{N}(0,\\sigma^2)$。\n\n在许多实证研究中，城市隶属于不同的群体（例如，国家或地区），这些群体会以一种仅靠人口无法完全解释的方式调节基线。一个简约的层级扩展模型将截距中的群体水平偏差建模为 $y_i = a + \\beta x_i + u_{g(i)} + \\varepsilon_i$，其中 $u_{g(i)}$ 是观测值 $i$ 所在群体 $g(i)$ 的群体水平随机截距，并且对于不同观测值，$\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$ 是独立的。\n\n我们对所有参数采用方差已知的高斯先验，以构建一个共轭正态-正态模型：\n- $a \\sim \\mathcal{N}(m_a, s_a^2)$，\n- $\\beta \\sim \\mathcal{N}(m_{\\beta}, s_{\\beta}^2)$，\n- 对于每个群体索引 $j$，$u_j \\sim \\mathcal{N}(0, \\tau^2)$ 独立，\n- 且 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$。\n\n令设计矩阵 $X$ 包含一个全局截距、协变量 $x$ 以及每个群体 $u_j$ 对应的一个指示符列。令参数向量为 $w = [a, \\beta, u_1, \\dots, u_G]^{\\top}$，其先验均值为 $m = [m_a, m_{\\beta}, 0, \\dots, 0]^{\\top}$，先验协方差为 $S = \\mathrm{diag}(s_a^2, s_{\\beta}^2, \\tau^2, \\dots, \\tau^2)$。似然函数为 $p(y \\mid w) = \\mathcal{N}(X w, \\sigma^2 I)$，根据贝叶斯法则，后验分布 $p(w \\mid y)$ 是高斯分布，其精度和均值由以下公式给出：\n$$\\Lambda_{\\text{post}} = S^{-1} + \\frac{1}{\\sigma^2} X^{\\top} X,$$\n$$\\mu_{\\text{post}} = \\Lambda_{\\text{post}}^{-1} \\left( S^{-1} m + \\frac{1}{\\sigma^2} X^{\\top} y \\right).$$\n后验均值 $\\mu_{\\text{post}}$ 在这个共轭设定下，既是平方误差损失下的贝叶斯估计量，也是最大后验估计。对于新协变量 $x_{\\star}$ 和群体 $g_{\\star}$ 的预测， $y_{\\star}$ 的后验预测均值由线性形式 $x_{\\star}^{\\top} \\mu_{\\text{post}}$ 给出，其中 $x_{\\star}$ 是相应的设计向量（包括截距和适当的群体指示符）。\n\n你必须实现一个程序，针对下面给定的固定数据集和指定的先验方差及已知噪声水平的测试套件，计算：\n- 规模缩放指数 $\\beta$ 的后验均值，\n- 在 $x_{\\star}$ 和 $g_{\\star}$ 处 $y_{\\star}$ 的后验预测均值，\n对于每个测试用例。\n\n数据（所有值均为自然对数，因此无量纲）：\n- 观测值 $i \\in \\{1,2,3,4,5,6\\}$，包含数据对 $(x_i,y_i)$ 和群体索引 $g(i)$：\n  - $i = 1$: $x_1 = 10.5$, $y_1 = 2.375$, $g(1) = 0$。\n  - $i = 2$: $x_2 = 12.0$, $y_2 = 3.95$, $g(2) = 0$。\n  - $i = 3$: $x_3 = 11.0$, $y_3 = 2.75$, $g(3) = 1$。\n  - $i = 4$: $x_4 = 13.0$, $y_4 = 4.75$, $g(4) = 1$。\n  - $i = 5$: $x_5 = 9.8$, $y_5 = 1.45$, $g(5) = 0$。\n  - $i = 6$: $x_6 = 12.6$, $y_6 = 4.39$, $g(6) = 1$。\n- 共有 $G = 2$ 个群体，索引为 $j \\in \\{0,1\\}$。\n\n所有测试用例的固定先验均值：\n- $m_a = -9.5$,\n- $m_{\\beta} = 1.1$,\n- $m_{u_0} = 0$,\n- $m_{u_1} = 0$.\n\n所有测试用例的固定新预测点：\n- $x_{\\star} = 11.5$,\n- $g_{\\star} = 0$.\n\n包含四个测试用例的测试套件，每个用例指定 $(s_a^2, s_{\\beta}^2, \\tau^2, \\sigma^2)$ 和一个建模方案：\n1. 基线层级案例：$s_a^2 = 4.0$, $s_{\\beta}^2 = 0.25$, $\\tau^2 = 0.25$, $\\sigma^2 = 0.04$，包含群体随机效应。\n2. 对 $\\beta$ 的强先验：$s_a^2 = 4.0$, $s_{\\beta}^2 = 0.01$, $\\tau^2 = 0.25$, $\\sigma^2 = 0.04$，包含群体随机效应。\n3. 无随机效应（无群体偏差的固定效应模型）：$s_a^2 = 4.0$, $s_{\\beta}^2 = 0.25$, $\\tau^2 = 0$, $\\sigma^2 = 0.04$，不包含群体随机效应。\n4. 高观测噪声：$s_a^2 = 4.0$, $s_{\\beta}^2 = 0.25$, $\\tau^2 = 0.25$, $\\sigma^2 = 0.25$，包含群体随机效应。\n\n计算要求：\n- 对于层级案例，构建设计矩阵 $X$，其列为 $[1, x, \\mathbb{I}(g=0), \\mathbb{I}(g=1)]$；对于无随机效应案例，其列为 $[1, x]$。\n- 对于层级案例，将先验协方差 $S$ 构建为对角矩阵，其对角线元素与 $[a, \\beta, u_0, u_1]$ 的方差相匹配；对于无随机效应案例，其对角线元素与 $[a, \\beta]$ 的方差相匹配。使用相应的先验均值向量 $m$。\n- 使用上述方程计算后验均值 $\\mu_{\\text{post}}$。\n- 提取 $\\beta$ 的后验均值，并计算在 $(x_{\\star}, g_{\\star})$ 处的后验预测均值，即 $x_{\\star}^{\\top} \\mu_{\\text{post}}$。\n\n答案规格：\n- 对于四个测试用例中的每一个，输出两个十进制数：第一个是 $\\beta$ 的后验均值，第二个是 $y_{\\star}$ 的后验预测均值。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。顺序必须是 $[\\beta_{\\text{post}}^{(1)}, y_{\\star}^{(1)}, \\beta_{\\text{post}}^{(2)}, y_{\\star}^{(2)}, \\beta_{\\text{post}}^{(3)}, y_{\\star}^{(3)}, \\beta_{\\text{post}}^{(4)}, y_{\\star}^{(4)}]$，其中上标 $(k)$ 按上文给出的顺序索引测试用例。\n\n由于所有变量都是有量纲量的对数，从而得到无量纲值，因此不涉及物理单位。将所有输出表示为十进制浮点数。",
            "solution": "我们从被称为城市规模缩放的经验规律出发，即一个外延性城市量与人口呈幂律关系进行规模缩放。这被建模为 $Y = A N^{\\beta} \\exp(\\varepsilon)$，其中 $A$ 和 $\\beta$ 是参数，$\\varepsilon$ 是一个波动项。取自然对数得到线性模型 $y = a + \\beta x + \\varepsilon$，其中 $a = \\log A$，$x = \\log N$，并且 $\\varepsilon$ 被建模为高斯噪声，$\\varepsilon \\sim \\mathcal{N}(0,\\sigma^2)$。\n\n为了解释例如国家之间基线的群体水平异质性，我们扩展模型以包含随机截距：$y_i = a + \\beta x_i + u_{g(i)} + \\varepsilon_i$，其中 $u_{g(i)}$ 是一个特定于群体的偏差，$\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$。我们假定独立的先验高斯分布 $a \\sim \\mathcal{N}(m_a, s_a^2)$、$\\beta \\sim \\mathcal{N}(m_{\\beta}, s_{\\beta}^2)$，以及对每个群体 $j$ 的 $u_j \\sim \\mathcal{N}(0, \\tau^2)$。观测噪声方差 $\\sigma^2$、群体方差 $\\tau^2$ 以及先验方差 $s_a^2$ 和 $s_{\\beta}^2$ 被视为已知的超参数，这导出了一个共轭正态-正态贝叶斯模型。\n\n我们构建线性代数表示。令设计矩阵 $X$ 的每一行对应一个观测值，列分别对应截距、$x$ 和每个群体的一个指示符。对于有 $G = 2$ 个群体且群体索引在 $\\{0,1\\}$ 中的层级案例，我们定义\n$$\nX = \\begin{bmatrix}\n1  x_1  \\mathbb{I}(g(1)=0)  \\mathbb{I}(g(1)=1) \\\\\n\\vdots  \\vdots  \\vdots  \\vdots \\\\\n1  x_n  \\mathbb{I}(g(n)=0)  \\mathbb{I}(g(n)=1)\n\\end{bmatrix},\n$$\n和参数向量\n$$\nw = \\begin{bmatrix} a \\\\ \\beta \\\\ u_0 \\\\ u_1 \\end{bmatrix}, \\quad\nm = \\begin{bmatrix} m_a \\\\ m_{\\beta} \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\nS = \\mathrm{diag}\\left(s_a^2, s_{\\beta}^2, \\tau^2, \\tau^2\\right).\n$$\n对于无随机效应的案例，我们排除群体列和参数，得到\n$$\nX = \\begin{bmatrix}\n1  x_1 \\\\\n\\vdots  \\vdots \\\\\n1  x_n\n\\end{bmatrix}, \\quad\nw = \\begin{bmatrix} a \\\\ \\beta \\end{bmatrix}, \\quad\nm = \\begin{bmatrix} m_a \\\\ m_{\\beta} \\end{bmatrix}, \\quad\nS = \\mathrm{diag}\\left(s_a^2, s_{\\beta}^2\\right).\n$$\n\n给定高斯似然 $p(y \\mid w) = \\mathcal{N}(Xw, \\sigma^2 I)$ 和高斯先验 $p(w) = \\mathcal{N}(m, S)$，后验分布 $p(w \\mid y)$ 是高斯分布，其精度矩阵和均值由标准共轭更新给出：\n$$\n\\Lambda_{\\text{post}} = S^{-1} + \\frac{1}{\\sigma^2} X^{\\top} X,\n$$\n$$\n\\mu_{\\text{post}} = \\Lambda_{\\text{post}}^{-1} \\left( S^{-1} m + \\frac{1}{\\sigma^2} X^{\\top} y \\right).\n$$\n这通过对后验对数进行配方得出，后验对数正比于\n$$\n- \\frac{1}{2} (y - X w)^{\\top} \\left( \\frac{1}{\\sigma^2} I \\right) (y - X w) - \\frac{1}{2} (w - m)^{\\top} S^{-1} (w - m).\n$$\n收集 $w$ 的二次项和一次项，得到精度 $\\Lambda_{\\text{post}}$ 和线性项 $\\eta = S^{-1} m + \\frac{1}{\\sigma^2} X^{\\top} y$，从而给出后验均值 $\\mu_{\\text{post}} = \\Lambda_{\\text{post}}^{-1} \\eta$。\n\n规模缩放指数 $\\beta$ 的后验均值是 $\\mu_{\\text{post}}$ 的第二个分量，这在两种模型方案（层级和无随机效应）中都成立，因为我们按 $[a, \\beta, \\dots]$ 的顺序列出参数。对于新数据点 $(x_{\\star}, g_{\\star})$ 的预测，$y_{\\star}$ 的后验预测分布是高斯分布，其均值等于后验分布下 $X_{\\star} w$ 的期望，即 $x_{\\star}^{\\top} \\mu_{\\text{post}}$，其中 $x_{\\star}$ 是新数据点的设计向量。具体来说，对于有两个群体的层级案例，$x_{\\star} = [1, x_{\\star}, \\mathbb{I}(g_{\\star}=0), \\mathbb{I}(g_{\\star}=1)]^{\\top}$。对于无随机效应案例，$x_{\\star} = [1, x_{\\star}]^{\\top}$。观测噪声的均值为零，因此对预测均值没有贡献。\n\n每个测试用例的算法步骤：\n1. 根据固定数据集和指定的建模方案（包含或排除群体指示符）构建 $X$。\n2. 将 $S$ 构建为对角矩阵，其对角线元素为该方案下参数的适当方差，并按规定构建 $m$。\n3. 通过对对角线元素求逆来计算 $S^{-1}$。\n4. 计算 $\\Lambda_{\\text{post}} = S^{-1} + \\frac{1}{\\sigma^2} X^{\\top} X$。\n5. 计算 $\\eta = S^{-1} m + \\frac{1}{\\sigma^2} X^{\\top} y$。\n6. 使用数值稳定的求解器求解线性系统 $\\Lambda_{\\text{post}} \\mu_{\\text{post}} = \\eta$ 以获得 $\\mu_{\\text{post}}$。\n7. 提取 $\\beta$ 的后验均值，即 $\\mu_{\\text{post}}[1]$。\n8. 构建 $x_{\\star}$ 并计算 $y_{\\star}$ 的预测均值，即 $x_{\\star}^{\\top} \\mu_{\\text{post}}$。\n\n测试套件与输出：\n- 测试用例 1：$s_a^2 = 4.0$, $s_{\\beta}^2 = 0.25$, $\\tau^2 = 0.25$, $\\sigma^2 = 0.04$，层级模型。\n- 测试用例 2：$s_a^2 = 4.0$, $s_{\\beta}^2 = 0.01$, $\\tau^2 = 0.25$, $\\sigma^2 = 0.04$，层级模型。\n- 测试用例 3：$s_a^2 = 4.0$, $s_{\\beta}^2 = 0.25$, $\\tau^2 = 0$, $\\sigma^2 = 0.04$，无随机效应。\n- 测试用例 4：$s_a^2 = 4.0$, $s_{\\beta}^2 = 0.25$, $\\tau^2 = 0.25$, $\\sigma^2 = 0.25$，层级模型。\n\n程序必须以 $[\\beta_{\\text{post}}^{(1)}, y_{\\star}^{(1)}, \\beta_{\\text{post}}^{(2)}, y_{\\star}^{(2)}, \\beta_{\\text{post}}^{(3)}, y_{\\star}^{(3)}, \\beta_{\\text{post}}^{(4)}, y_{\\star}^{(4)}]$ 的格式输出单行结果，其中包含每个量的十进制浮点数，对应每个测试用例在 $(x_{\\star} = 11.5, g_{\\star} = 0)$ 处的 $\\beta$ 后验均值和后验预测均值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef posterior_mean_and_predictive(x, y, groups, m_a, m_beta, s2_a, s2_beta,\n                                  tau2, sigma2, include_random_effects,\n                                  x_star, g_star, n_groups=2):\n    \"\"\"\n    Compute the posterior mean for parameters in a Gaussian linear hierarchical model\n    and the posterior predictive mean for a new observation.\n\n    Parameters:\n        x: np.ndarray, shape (n,)\n            Log-population covariate values.\n        y: np.ndarray, shape (n,)\n            Log-output response values.\n        groups: np.ndarray, shape (n,)\n            Integer group indices for each observation in [0, n_groups-1].\n        m_a, m_beta: float\n            Prior means for a and beta.\n        s2_a, s2_beta: float\n            Prior variances for a and beta.\n        tau2: float\n            Prior variance for each group random intercept (ignored if include_random_effects is False).\n        sigma2: float\n            Known observation noise variance.\n        include_random_effects: bool\n            Whether to include group random intercepts.\n        x_star: float\n            New covariate value for prediction.\n        g_star: int\n            Group index for the new observation.\n        n_groups: int\n            Number of groups (default 2).\n\n    Returns:\n        beta_post_mean: float\n            Posterior mean of beta.\n        y_pred_mean: float\n            Posterior predictive mean at (x_star, g_star).\n    \"\"\"\n    n = x.shape[0]\n\n    # Build design matrix X\n    if include_random_effects:\n        # Intercept, x, group indicators\n        X = np.zeros((n, 2 + n_groups))\n        X[:, 0] = 1.0  # intercept\n        X[:, 1] = x    # slope covariate\n        for i in range(n):\n            X[i, 2 + groups[i]] = 1.0  # group indicator\n        # Prior mean and covariance (diagonal)\n        m = np.zeros(2 + n_groups)\n        m[0] = m_a\n        m[1] = m_beta\n        # Diagonal prior variances\n        S_diag = np.zeros(2 + n_groups)\n        S_diag[0] = s2_a\n        S_diag[1] = s2_beta\n        S_diag[2:] = tau2\n        # New point design vector\n        x_star_vec = np.zeros(2 + n_groups)\n        x_star_vec[0] = 1.0\n        x_star_vec[1] = x_star\n        x_star_vec[2 + g_star] = 1.0\n    else:\n        # Intercept and x only\n        X = np.zeros((n, 2))\n        X[:, 0] = 1.0\n        X[:, 1] = x\n        m = np.array([m_a, m_beta], dtype=float)\n        S_diag = np.array([s2_a, s2_beta], dtype=float)\n        x_star_vec = np.array([1.0, x_star], dtype=float)\n\n    # Compute posterior precision and mean\n    # Prior precision is inverse of diagonal variances\n    S_inv_diag = 1.0 / S_diag\n    # Lambda_post = S^{-1} + (1/sigma^2) X^T X\n    Lambda_post = np.diag(S_inv_diag) + (X.T @ X) / sigma2\n    # eta = S^{-1} m + (1/sigma^2) X^T y\n    eta = S_inv_diag * m + (X.T @ y) / sigma2\n    # Solve for posterior mean\n    mu_post = np.linalg.solve(Lambda_post, eta)\n\n    # Extract beta posterior mean (index 1)\n    beta_post_mean = float(mu_post[1])\n    # Predictive mean y_star = x_star^T mu_post\n    y_pred_mean = float(x_star_vec @ mu_post)\n\n    return beta_post_mean, y_pred_mean\n\ndef solve():\n    # Fixed dataset\n    x = np.array([10.5, 12.0, 11.0, 13.0, 9.8, 12.6], dtype=float)\n    y = np.array([2.375, 3.95, 2.75, 4.75, 1.45, 4.39], dtype=float)\n    groups = np.array([0, 0, 1, 1, 0, 1], dtype=int)\n\n    # Fixed prior means\n    m_a = -9.5\n    m_beta = 1.1\n\n    # Prediction point\n    x_star = 11.5\n    g_star = 0\n\n    # Test cases: (s2_a, s2_beta, tau2, sigma2, include_random_effects)\n    test_cases = [\n        (4.0, 0.25, 0.25, 0.04, True),   # Case 1: baseline hierarchical\n        (4.0, 0.01, 0.25, 0.04, True),   # Case 2: strong prior on beta\n        (4.0, 0.25, 0.0, 0.04, False),   # Case 3: no random effects\n        (4.0, 0.25, 0.25, 0.25, True),   # Case 4: high observational noise\n    ]\n\n    results = []\n    for s2_a, s2_beta, tau2, sigma2, include_re in test_cases:\n        beta_post, y_pred = posterior_mean_and_predictive(\n            x=x, y=y, groups=groups,\n            m_a=m_a, m_beta=m_beta,\n            s2_a=s2_a, s2_beta=s2_beta,\n            tau2=tau2, sigma2=sigma2,\n            include_random_effects=include_re,\n            x_star=x_star, g_star=g_star,\n            n_groups=2\n        )\n        results.append(beta_post)\n        results.append(y_pred)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}