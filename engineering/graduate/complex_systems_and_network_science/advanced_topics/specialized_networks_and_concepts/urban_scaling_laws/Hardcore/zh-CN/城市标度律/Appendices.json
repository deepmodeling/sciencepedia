{
    "hands_on_practices": [
        {
            "introduction": "在城市标度律的实证分析中，首要任务是将模型与数据进行拟合。然而，简单的拟合只是第一步，我们还必须回答一个关键问题：简单的幂律模型是否是描述数据的最佳选择？本练习将指导您使用赤池信息准则 ($AIC$)、贝叶斯信息准则 ($BIC$) 和似然比检验 ($LRT$) 等统计工具，来比较标准的幂律模型和一个更具弹性的二次模型，并通过柯尔莫哥洛夫-斯米尔诺夫检验 (Kolmogorov-Smirnov test) 来验证模型残差是否符合我们的假设。",
            "id": "4312862",
            "problem": "考虑一个城市集合，其人口规模由 $N_i$ 表示，城市量由 $Y_i$ 表示，其中 $i$ 是城市的索引。城市标度律假设，平均而言，城市量 $Y$ 与人口 $N$ 遵循幂律关系，同时围绕该均值表现出乘性涨落。为了在复杂系统和网络科学的高级研究生水平上执行有原则的模型选择和拟合优度评估，您必须形式化以下内容：\n\n1. 基于定义和经过充分检验的观察的基本假设：\n   - 经典的城市标度律假说假设平均关系 $Y(N)$ 是一个幂律。在对数形式下，这是线性的，乘性的对数正态涨落变成了加性的高斯噪声。具体来说，令 $y_i = \\log Y_i$ 和 $x_i = \\log N_i$。那么，单标度（幂律）模型假设 $y_i = a + \\beta x_i + \\varepsilon_i$，其中 $\\varepsilon_i$ 是独立同分布的高斯残差，其均值为零，方差为 $\\sigma^2$。\n   - 为了考虑可能由网络结构或社会经济转型引起的标度曲率，考虑一个扩展的对数二次模型 $y_i = a + \\beta x_i + \\gamma x_i^2 + \\varepsilon_i$，并采用相同的高斯残差假设。\n   - 在高斯假设下，任一模型中的参数都将通过最大似然估计 (MLE) 进行估计。\n\n2. 从第一性原理出发，选择最合适的模型并使用以下方法评估拟合优度：\n   - 赤池信息准则 (AIC)，为一个具有 $k$ 个自由参数和最大化对数似然 $\\ell$ 的模型定义。\n   - 贝叶斯信息准则 (BIC)，为一个具有 $k$ 个自由参数、样本量 $n$ 和最大化对数似然 $\\ell$ 的模型定义。\n   - 针对嵌套模型的似然比检验 (LRT)，比较单标度模型与对数二次模型，并报告在适当的渐近分布下的 $p$-值。\n   - 一种基于残差的拟合优度诊断：在拟合模型下，通过 $\\sigma$ 的 MLE 对残差进行标准化，并应用单样本柯尔莫哥洛夫-斯米尔诺夫 (KS) 检验与标准正态分布进行比较，以获得一个 $p$-值。这检验了由乘性对数正态涨落所隐含的高斯残差假设的充分性。\n\n3. 实现要求：\n   - 通过在 $x_i = \\log N_i$ 空间中求解带有高斯残差的相应线性回归问题，对单标度模型和对数二次模型执行 MLE。\n   - 在高斯假设下，使用 MLE 残差方差为每个模型计算最大化对数似然 $\\ell$，并如下推导 AIC 和 BIC 的 $k$ 值：将所有回归系数和残差方差参数 $\\sigma^2$ 包括在 $k$ 中。对于单标-度模型，$k=3$。对于对数二次模型，$k=4$。\n   - 在单标度模型和对数二次模型之间使用 LRT。当 $\\gamma = 0$ 时，对数二次模型嵌套了单标度模型。使用回归系数数量差异（在此例中为 $1$）的渐近卡方分布报告 LRT 的 $p$-值。\n   - 为了进行拟合优度评估，通过将残差除以 MLE 标准差来计算标准化残差 $z_i$，并应用柯尔莫哥洛夫-斯米尔诺夫检验与标准正态分布进行比较，以获得一个 $p$-值。\n\n4. 测试套件和数据生成：\n   - 您必须确定性地生成合成数据集，不使用任何随机数生成器，以确保可复现性。对于每个数据集，执行以下操作：\n     - 令 $n$ 为城市数量。\n     - 令 $N_{\\min}$ 和 $N_{\\max}$ 定义人口规模的范围。\n     - 令 $a$、$\\beta$、$\\gamma$ 定义对数均值关系 $y_i = a + \\beta x_i + \\gamma x_i^2 + \\varepsilon_i$，其中 $x_i = \\log N_i$。\n     - 令 $\\sigma$ 定义高斯残差的尺度。\n     - 将 $x_i$ 构建为在 $\\log N_{\\min}$ 和 $\\log N_{\\max}$ 之间线性间隔的点，对于 $i=1,\\dots,n$。明确地，$x_i$ 是在 $[\\log N_{\\min}, \\log N_{\\max}]$ 上的 $n$ 个均匀间隔点。\n     - 通过选择分位数 $q_i = \\frac{i - 0.5}{n}$ 并设置 $\\varepsilon_i = \\sigma \\Phi^{-1}(q_i)$ 来构造确定性高斯残差，其中 $\\Phi^{-1}$ 是标准正态分布的逆累积分布函数。\n     - 设置 $y_i = a + \\beta x_i + \\gamma x_i^2 + \\varepsilon_i$ 和 $Y_i = \\exp(y_i)$。\n   - 定义四个数据集（测试用例），每个都由 $(n, N_{\\min}, N_{\\max}, a, \\beta, \\gamma, \\sigma)$ 指定：\n     1. 用例 1：$n = 20$, $N_{\\min} = 10000$, $N_{\\max} = 10000000$, $a = 1.0$, $\\beta = 1.15$, $\\gamma = 0.0$, $\\sigma = 0.2$。\n     2. 用例 2：$n = 25$, $N_{\\min} = 5000$, $N_{\\max} = 20000000$, $a = 0.5$, $\\beta = 0.9$, $\\gamma = 0.06$, $\\sigma = 0.15$。\n     3. 用例 3：$n = 8$, $N_{\\min} = 20000$, $N_{\\max} = 2000000$, $a = 2.0$, $\\beta = 1.0$, $\\gamma = 0.0$, $\\sigma = 0.3$。\n     4. 用例 4：$n = 30$, $N_{\\min} = 8000$, $N_{\\max} = 30000000$, $a = 1.0$, $\\beta = 1.05$, $\\gamma = -0.02$, $\\sigma = 0.25$。\n\n5. 所需输出：\n   - 对于每个数据集，按此顺序计算并返回四个值：\n     1. 基于 AIC 的模型选择指标，用 $1$ 表示单标度（幂律）模型，用 $2$ 表示对数二次模型。\n     2. 基于 BIC 的选择指标，用 $1$ 表示单标度模型，用 $2$ 表示对数二次模型。\n     3. 比较单标度模型与对数二次模型的 LRT $p$-值。\n     4. AIC 选择模型的标准化残差相对于标准正态分布的 KS $p$-值。\n   - 最终输出必须将所有四个数据集的结果汇总到一行中。您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$。具体来说，输出必须包含 $16$ 个条目，对应于 $4$ 个测试用例中的每一个的四个值，按测试用例排序。整数指标必须打印为整数，每个 $p$-值必须打印为保留六位小数的十进制数。",
            "solution": "该问题是有效的。这是一个在计算统计学中提法恰当、有科学依据的问题，特别关注城市标度律的模型选择和拟合优度。其前提与复杂系统领域的既有文献一致，任务以数学精度具体化，包括模型、估计方法、检验统计量和数据生成过程。所有术语都得到了明确定义，问题是自洽的。\n\n解决方案首先生成所需的合成数据集，然后按规定对每个数据集应用一系列统计分析。\n\n### 1. 数据生成\n对于四个测试用例中的每一个，都确定性地构建一个合成数据集。每个用例的参数由元组 $(n, N_{\\min}, N_{\\max}, a, \\beta, \\gamma, \\sigma)$ 给出，其中 $n$ 是城市数量，$N_{\\min}$ 和 $N_{\\max}$ 定义了人口范围，$a, \\beta, \\gamma, \\sigma$ 是生成模型的参数。\n\n自变量，即对数人口 $x_i = \\log N_i$，是通过在区间 $[\\log N_{\\min}, \\log N_{\\max}]$ 上创建 $n$ 个线性间隔的点来构建的。\n$$ x_i = \\log N_{\\min} + (i-1) \\frac{\\log N_{\\max} - \\log N_{\\min}}{n-1} \\quad \\text{for } i = 1, \\dots, n $$\n残差 $\\varepsilon_i$ 被确定性地生成，以遵循均值为 $0$、标准差为 $\\sigma$ 的高斯分布。这是通过使用标准正态累积分布函数的逆函数 $\\Phi^{-1}(q)$（也称为分位数函数）来实现的。我们定义分位数 $q_i = \\frac{i-0.5}{n}$（对于 $i=1, \\dots, n$），并将残差设置为：\n$$ \\varepsilon_i = \\sigma \\Phi^{-1}(q_i) $$\n最后，因变量，即对数量 $y_i = \\log Y_i$，使用指定的对数二次模型形式生成：\n$$ y_i = a + \\beta x_i + \\gamma x_i^2 + \\varepsilon_i $$\n\n### 2. 模型拟合与对数似然\n将两个模型拟合到每个合成数据集 $(x_i, y_i)$：\n- **模型 1 (单标度):** $y_i = a_1 + \\beta_1 x_i + \\varepsilon_i$\n- **模型 2 (对数二次):** $y_i = a_2 + \\beta_2 x_i + \\gamma_2 x_i^2 + \\varepsilon_i$\n\n在独立同分布 (i.i.d.) 高斯残差的假设下，回归系数 $(a, \\beta, \\gamma)$ 的最大似然估计 (MLE) 等价于普通最小二乘法 (OLS)。对于每个模型，我们求解线性系统以找到使残差平方和最小化的系数。\n\n设数据点数量为 $n$。对于给定的模型，设预测值为 $\\hat{y}_i$。残差为 $\\hat{\\varepsilon}_i = y_i - \\hat{y}_i$。残差方差的 MLE 为：\n$$ \\hat{\\sigma}^2_{\\text{MLE}} = \\frac{1}{n} \\sum_{i=1}^n \\hat{\\varepsilon}_i^2 $$\n对于一个具有 $n$ 个数据点和 MLE 方差估计 $\\hat{\\sigma}^2_{\\text{MLE}}$ 的模型，其最大化对数似然 $\\ell_{\\max}$ 由下式给出：\n$$ \\ell_{\\max} = - \\frac{n}{2} \\log(2\\pi) - \\frac{n}{2} \\log(\\hat{\\sigma}^2_{\\text{MLE}}) - \\frac{1}{2\\hat{\\sigma}^2_{\\text{MLE}}} \\sum_{i=1}^n \\hat{\\varepsilon}_i^2 = - \\frac{n}{2} \\left( \\log(2\\pi\\hat{\\sigma}^2_{\\text{MLE}}) + 1 \\right) $$\n对模型 1 和模型 2 都执行此计算，分别得到 $\\ell_{\\max,1}$ 和 $\\ell_{\\max,2}$。\n\n### 3. 模型选择\n我们使用两个信息准则，AIC 和 BIC，来选择更好的模型。这两个准则都对具有更多参数的模型进行惩罚。准则值较低的模型更受青睐。\n\n- **赤池信息准则 (AIC):** $AIC = 2k - 2\\ell_{\\max}$\n- **贝叶斯信息准则 (BIC):** $BIC = k \\log(n) - 2\\ell_{\\max}$\n\n在这里，$k$ 是估计参数的总数。根据规定，$k$ 包括回归系数和方差。\n- 对于模型 1，参数为 $(a_1, \\beta_1, \\sigma_1^2)$，所以 $k_1 = 3$。\n- 对于模型 2，参数为 $(a_2, \\beta_2, \\gamma_2, \\sigma_2^2)$，所以 $k_2 = 4$。\n\n如果选择模型 1，则分配指标 1；如果选择模型 2，则分配指标 2。平局情况倾向于选择更简单的模型（模型 1）。\n\n### 4. 似然比检验 (LRT)\nLRT 用于比较嵌套模型。模型 1 嵌套在模型 2 中，因为模型 1 是模型 2 在 $\\gamma=0$ 时的特例。零假设是 $H_0: \\gamma=0$。检验统计量为：\n$$ \\lambda_{LR} = 2(\\ell_{\\max,2} - \\ell_{\\max,1}) $$\n在 $H_0$ 下，$\\lambda_{LR}$ 渐近服从卡方分布 $\\chi^2(df)$，其中自由度 $df$ 是两个模型之间自由回归系数数量的差异。在这里，模型 2 有一个额外的系数 ($\\gamma$)，所以 $df=1$。$p$-值是在假设 $H_0$ 为真的情况下，观察到与计算出的检验统计量一样极端或更极端的概率：\n$$ p_{\\text{LRT}} = P(\\chi^2_1 \\ge \\lambda_{LR}) $$\n\n### 5. 拟合优度：柯尔莫哥洛夫-斯米尔诺夫 (KS) 检验\n该检验评估拟合模型的残差是否与假设的高斯分布一致。\n首先，确定由 AIC 选择的模型。然后，使用标准差的 MLE $\\hat{\\sigma}_{\\text{MLE}} = \\sqrt{\\hat{\\sigma}^2_{\\text{MLE}}}$ 对其残差 $\\hat{\\varepsilon}_i$ 进行标准化：\n$$ z_i = \\frac{\\hat{\\varepsilon}_i}{\\hat{\\sigma}_{\\text{MLE}}} $$\n然后将单样本柯尔莫哥洛夫-斯米尔诺夫检验应用于这些标准化残差 $\\{z_i\\}$。它将标准化残差的经验累积分布函数 (ECDF) 与标准正态分布的累积分布函数 (CDF) $\\Phi(z)$ 进行比较。该检验得出一个 $p$-值，$p_{\\text{KS}}$。一个高的 $p$-值（例如，$>0.05$）表明数据与残差来自标准正态分布的零假设并不矛盾，从而表明拟合良好。\n\n对每个测试用例实施这些步骤将产生四个所需的输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm, chi2, kstest\n\ndef solve():\n    \"\"\"\n    Performs model selection and goodness-of-fit analysis for urban scaling laws\n    on four deterministically generated synthetic datasets.\n    \"\"\"\n\n    test_cases = [\n        # (n, N_min, N_max, a, beta, gamma, sigma)\n        (20, 10000, 10000000, 1.0, 1.15, 0.0, 0.2),\n        (25, 5000, 20000000, 0.5, 0.9, 0.06, 0.15),\n        (8, 20000, 2000000, 2.0, 1.0, 0.0, 0.3),\n        (30, 8000, 30000000, 1.0, 1.05, -0.02, 0.25),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        n, N_min, N_max, a_true, beta_true, gamma_true, sigma_true = params\n\n        # === 1. Data Generation ===\n        x_min = np.log(N_min)\n        x_max = np.log(N_max)\n        x = np.linspace(x_min, x_max, n)\n        \n        quantiles = (np.arange(1, n + 1) - 0.5) / n\n        eps = sigma_true * norm.ppf(quantiles)\n        \n        y = a_true + beta_true * x + gamma_true * x**2 + eps\n\n        # === 2. Model Fitting and Log-Likelihood ===\n\n        # Model 1: Single-Scaling (linear) y = a + beta*x\n        X1 = np.c_[np.ones(n), x]\n        k1 = 3 # Parameters: a, beta, sigma^2\n        coeffs1, sum_sq_res1, _, _ = np.linalg.lstsq(X1, y, rcond=None)\n        sigma2_1_hat = sum_sq_res1[0] / n\n        log_L1 = -n / 2 * (np.log(2 * np.pi * sigma2_1_hat) + 1)\n\n        # Model 2: Log-Quadratic y = a + beta*x + gamma*x^2\n        X2 = np.c_[np.ones(n), x, x**2]\n        k2 = 4 # Parameters: a, beta, gamma, sigma^2\n        coeffs2, sum_sq_res2, _, _ = np.linalg.lstsq(X2, y, rcond=None)\n        sigma2_2_hat = sum_sq_res2[0] / n\n        log_L2 = -n / 2 * (np.log(2 * np.pi * sigma2_2_hat) + 1)\n\n        # === 3. Model Selection (AIC/BIC) ===\n        aic1 = 2 * k1 - 2 * log_L1\n        aic2 = 2 * k2 - 2 * log_L2\n        aic_indicator = 1 if aic1 = aic2 else 2\n\n        bic1 = k1 * np.log(n) - 2 * log_L1\n        bic2 = k2 * np.log(n) - 2 * log_L2\n        bic_indicator = 1 if bic1 = bic2 else 2\n\n        # === 4. Likelihood Ratio Test (LRT) ===\n        # H0: single-scaling (gamma=0), H1: log-quadratic\n        lrt_stat = 2 * (log_L2 - log_L1)\n        # The test statistic must be non-negative\n        lrt_stat = max(0, lrt_stat)\n        lrt_p_value = chi2.sf(lrt_stat, df=1) # df = k2_coeffs - k1_coeffs = 3 - 2 = 1\n\n        # === 5. Goodness-of-Fit (KS Test) ===\n        if aic_indicator == 1:\n            y_pred = X1 @ coeffs1\n            residuals = y - y_pred\n            sigma_mle = np.sqrt(sigma2_1_hat)\n        else: # aic_indicator == 2\n            y_pred = X2 @ coeffs2\n            residuals = y - y_pred\n            sigma_mle = np.sqrt(sigma2_2_hat)\n\n        standardized_residuals = residuals / sigma_mle\n        ks_stat, ks_p_value = kstest(standardized_residuals, 'norm')\n\n        # === Aggregate and format results for the current case ===\n        all_results.extend([\n            aic_indicator,\n            bic_indicator,\n            f\"{lrt_p_value:.6f}\",\n            f\"{ks_p_value:.6f}\"\n        ])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "城市并非孤立的数据点，它们存在于地理空间之中，并相互影响，这导致了空间自相关性的普遍存在。本练习将探讨这一常见问题，即邻近城市的属性往往是相关的。您将学习如何模拟带有空间效应的数据，观察它如何对标度指数的普通最小二乘 ($OLS$) 估计产生偏差，并使用一个关键的诊断工具——莫兰指数 (Moran's $I$)——来检测模型残差中的空间自相关现象。",
            "id": "4312852",
            "problem": "考虑一个典型的城市规模缩放公式，其中城市 $i \\in \\{1,\\dots,n\\}$ 的一个非负城市指标 $Y_{i}$ 服从于其人口 $N_{i}$ 的一个乘性定律，即 $Y_{i} = a \\, N_{i}^{\\beta} \\, \\varepsilon_{i}$，其中 $a0$ 是一个常数，$\\beta$ 是我们感兴趣的规模缩放指数，而 $\\varepsilon_{i}$ 是一个正的乘性扰动项。取对数后得到 $\\log Y_{i} = \\log a + \\beta \\log N_{i} + \\eta_{i}$，其中 $\\eta_{i} = \\log \\varepsilon_{i}$ 是一个加性扰动项。在许多城市系统中，扰动项可能由于未观察到的区域因素或相互作用过程而表现出空间依赖性。扰动项中空间依赖性的一种标准表示是空间误差模型（SEM），其中 $\\boldsymbol{\\eta}$ 满足 $(\\mathbf{I} - \\rho \\mathbf{W}) \\boldsymbol{\\eta} = \\mathbf{u}$，其中 $\\rho \\in (-1,1)$ 控制空间自相关的强度和符号，$\\mathbf{W}$ 是一个行标准化的空间权重矩阵，$\\mathbf{I}$ 是单位矩阵，$\\mathbf{u}$ 是一个独立同分布的零均值高斯向量，每个分量的方差为 $\\sigma^{2}$。\n\n您的任务是实现一个程序，针对一组指定的测试用例，根据上述假设模拟合成的城市数据，通过对数-对数关系使用普通最小二乘法（OLS）估计规模缩放指数，使用莫兰指数（Moran's $I$）量化 OLS 残差中的空间自相关，并报告估计的指数和诊断信息。\n\n使用以下基本原理：\n- 城市规模缩放定义：$\\log Y_{i} = \\log a + \\beta \\log N_{i} + \\eta_{i}$。\n- 普通最小二乘法（OLS）：估计量 $\\hat{\\boldsymbol{\\theta}} = (\\mathbf{X}^{\\top}\\mathbf{X})^{-1}\\mathbf{X}^{\\top}\\mathbf{y}$，其中 $\\mathbf{y} = \\log \\mathbf{Y}$ 且 $\\mathbf{X} = [\\mathbf{1}, \\log \\mathbf{N}]$，且 $\\hat{\\boldsymbol{\\theta}} = [\\widehat{\\log a}, \\hat{\\beta}]^{\\top}$。\n- 莫兰指数（Moran's $I$）：$I = \\dfrac{n}{S_{0}} \\cdot \\dfrac{\\mathbf{e}^{\\top} \\mathbf{W} \\mathbf{e}}{\\mathbf{e}^{\\top} \\mathbf{e}}$，其中 $\\mathbf{e}$ 是 OLS 残差，而 $S_{0} = \\sum_{i}\\sum_{j} w_{ij}$，其中 $w_{ij}$ 是 $\\mathbf{W}$ 的 $(i,j)$ 项。在无空间自相关的随机化零假设下，期望值为 $\\mathbb{E}[I] = -\\dfrac{1}{n-1}$。\n- 空间误差模型（SEM）：$(\\mathbf{I} - \\rho \\mathbf{W}) \\boldsymbol{\\eta} = \\mathbf{u}$，其中 $\\mathbf{u} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^{2} \\mathbf{I})$ 且 $|\\rho|  1$，以确保对于行标准化的 $\\mathbf{W}$，$(\\mathbf{I} - \\rho \\mathbf{W})$ 是可逆的。\n\n您的程序必须为每个测试用例实现以下步骤：\n1. 从单位正方形（即 $(x_{i}, y_{i}) \\sim \\text{Uniform}([0,1]^{2})$）中独立抽样，生成 $n$ 个城市位置 $\\{(x_{i}, y_{i})\\}_{i=1}^{n}$。对该测试用例中的所有随机抽取，使用指定的整数随机种子。\n2. 构建这些位置上的 $k$ 最近邻空间权重矩阵 $\\mathbf{W}$，步骤如下：对于每个城市 $i$，找到与 $i$ 欧几里得距离最小的 $k$ 个不同城市 $j \\neq i$；如果 $j$ 是 $i$ 的 $k$ 最近邻，则设 $w_{ij} = 1$，否则设 $w_{ij} = 0$；然后进行行标准化，使每个非零行的和为 1（即 $w_{ij} \\leftarrow w_{ij} / \\sum_{j} w_{ij}$）。这将产生一个行随机的 $\\mathbf{W}$，其 $S_{0} = \\sum_{i}\\sum_{j} w_{ij} = n$。\n3. 抽取 $\\mathbf{u} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^{2}\\mathbf{I})$ 并通过求解 $(\\mathbf{I} - \\rho \\mathbf{W}) \\boldsymbol{\\eta} = \\mathbf{u}$ 计算空间自相关扰动项 $\\boldsymbol{\\eta}$。\n4. 首先通过抽取 $\\log N_{i} \\sim \\mathcal{N}(\\mu, \\tau^{2})$（其中 $\\mu = 11.0$ 且 $\\tau = 1.0$）来生成独立的城市人口，然后设置 $N_{i} = \\exp(\\log N_{i})$。这确保了广泛且真实的城市规模分布。假设 $\\log N_{i}$ 与 $\\boldsymbol{\\eta}$ 之间相互独立。\n5. 设置 $a = 1$ 并构建 $Y_{i} = a \\, N_{i}^{\\beta} \\, \\exp(\\eta_{i})$。然后计算 $\\mathbf{y} = \\log \\mathbf{Y}$ 和 $\\mathbf{X} = [\\mathbf{1}, \\log \\mathbf{N}]$。通过 OLS 估计 $\\hat{\\beta}$。计算 OLS 残差向量 $\\mathbf{e} = \\mathbf{y} - \\mathbf{X}\\hat{\\boldsymbol{\\theta}}$。\n6. 使用上述公式计算莫兰指数 $I$ 以及零假设下的期望值 $\\mathbb{E}[I] = -\\dfrac{1}{n-1}$。报告估计的指数 $\\hat{\\beta}$、偏差 $\\hat{\\beta} - \\beta$、残差的莫兰指数 $I$ 和零假设下的期望值。\n\n设计一个测试套件，涵盖无自相关、中等正自相关、强正自相关、负自相关和小样本情况：\n- 测试用例 1：$(n, k, \\beta, \\rho, \\sigma, \\text{seed}) = (64, 4, 1.15, 0.0, 0.2, 1)$。\n- 测试用例 2：$(n, k, \\beta, \\rho, \\sigma, \\text{seed}) = (64, 4, 1.15, 0.6, 0.2, 2)$。\n- 测试用例 3：$(n, k, \\beta, \\rho, \\sigma, \\text{seed}) = (64, 4, 0.85, 0.9, 0.3, 3)$。\n- 测试用例 4：$(n, k, \\beta, \\rho, \\sigma, \\text{seed}) = (64, 4, 1.00, -0.5, 0.2, 4)$。\n- 测试用例 5：$(n, k, \\beta, \\rho, \\sigma, \\text{seed}) = (16, 3, 1.20, 0.7, 0.5, 5)$。\n\n您的程序必须按给定顺序为五个测试用例生成单行输出，其中包含一个长度为 5 的列表，每个元素是一个包含四个浮点数的列表：$[\\hat{\\beta}, \\hat{\\beta}-\\beta, I, \\mathbb{E}[I]]$，每个浮点数四舍五入到 6 位小数。最终打印的行必须严格为一个 Python 风格的列表的列表，例如 $[[b_{1},\\Delta_{1},I_{1},E_{1}],[b_{2},\\Delta_{2},I_{2},E_{2}],\\dots]$，不含任何额外文本。",
            "solution": "该问题被认为是有效的，因为它具有科学依据、问题设定良好、无歧义，并且所有必要的参数和程序都已明确定义。所提出的模型和方法——城市规模缩放定律、空间误差模型（SEM）、普通最小二乘法（OLS）和莫兰指数（Moran's I）——都是标准且适合该任务的。\n\n目标是进行一项模拟研究，以评估在存在空间自相关扰动的情况下，城市规模缩放指数的 OLS 估计量的表现。对于每个测试用例，我们将根据指定的流程生成合成数据，估计模型参数，并计算空间自相关的诊断统计量。\n\n理论基础是城市规模缩放定律，它假设城市指标 $Y_i$ 与城市人口 $N_i$ 之间存在幂律关系：\n$$Y_{i} = a \\, N_{i}^{\\beta} \\, \\varepsilon_{i}$$\n此处，$a > 0$ 是一个归一化常数，$\\beta$ 是规模缩放指数，$\\varepsilon_{i}$ 是一个乘性扰动项。为便于线性估计，此方程被对数转换：\n$$\\log Y_{i} = \\log a + \\beta \\log N_{i} + \\eta_{i}$$\n其中 $\\eta_{i} = \\log \\varepsilon_{i}$ 现在是一个加性扰动项。用向量表示法，这表示为 $\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\theta} + \\boldsymbol{\\eta}$，其中 $\\mathbf{y} = \\log\\mathbf{Y}$，设计矩阵为 $\\mathbf{X} = [\\mathbf{1}, \\log\\mathbf{N}]$，参数向量为 $\\boldsymbol{\\theta} = [\\log a, \\beta]^{\\top}$。\n\n该问题的一个关键假设是扰动项 $\\eta_i$ 不是独立的，而是表现出空间自相关。这使用空间误差模型（SEM）进行建模，该模型是空间计量经济学的基石。SEM 通过以下关系定义扰动向量 $\\boldsymbol{\\eta}$：\n$$(\\mathbf{I} - \\rho \\mathbf{W}) \\boldsymbol{\\eta} = \\mathbf{u}$$\n其中 $\\mathbf{I}$ 是 $n \\times n$ 的单位矩阵，$\\rho$ 是控制空间自相关强度和符号的标量参数，$\\mathbf{W}$ 是一个 $n \\times n$ 的空间权重矩阵，用于编码城市的邻里结构，$\\mathbf{u}$ 是一个独立同分布误差向量，具体为 $\\mathbf{u} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^{2}\\mathbf{I})$。因此，扰动向量可以生成为 $\\boldsymbol{\\eta} = (\\mathbf{I} - \\rho \\mathbf{W})^{-1} \\mathbf{u}$。对于行标准化的 $\\mathbf{W}$，需要约束 $|\\rho|  1$ 以确保矩阵 $(\\mathbf{I} - \\rho \\mathbf{W})$ 是可逆的。\n\n空间权重矩阵 $\\mathbf{W}$ 是根据城市的地理位置构建的。程序步骤如下：\n1.  从单位正方形 $[0,1]^2$ 上的均匀分布中生成 $n$ 个城市位置 $\\{(x_{i}, y_{i})\\}_{i=1}^{n}$ 作为独立的随机样本。\n2.  对每个城市 $i$，根据欧几里得距离确定其 $k$ 个最近邻。\n3.  构建一个初始二元矩阵，如果城市 $j$ 是城市 $i$ 的 $k$ 个最近邻之一，则条目 $w_{ij}$ 为 $1$，否则为 $0$。对角线元素 $w_{ii}$ 始终为 $0$。\n4.  通过将每个元素 $w_{ij}$ 除以其行和 $\\sum_j w_{ij}$ 来对该矩阵进行行标准化。得到的矩阵 $\\mathbf{W}$ 是行随机的，意味着每行之和为 $1$。因此，其所有元素之和 $S_0 = \\sum_{i}\\sum_{j} w_{ij}$ 等于 $n$。\n\n每个测试用例的完整模拟和估算流程如下：\n1.  使用特定的种子初始化伪随机数生成器以确保可复现性。\n2.  生成城市位置并构建相应的行标准化 $k$ 最近邻矩阵 $\\mathbf{W}$。\n3.  从 $\\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I})$ 中抽取独立同分布的误差向量 $\\mathbf{u}$。然后通过求解线性系统 $(\\mathbf{I} - \\rho \\mathbf{W})\\boldsymbol{\\eta} = \\mathbf{u}$ 计算空间相关的误差向量 $\\boldsymbol{\\eta}$。\n4.  从对数正态分布生成城市人口 $N_i$，具体通过从 $\\mathcal{N}(\\mu=11.0, \\tau^2=1.0^2)$ 中抽取 $\\log N_i$ 来指定。\n5.  使用对数线性模型创建因变量 $\\mathbf{y} = \\log\\mathbf{Y}$，参数为 $a=1$（因此 $\\log a=0$）和给定的 $\\beta$：$\\mathbf{y} = \\beta\\log\\mathbf{N} + \\boldsymbol{\\eta}$。\n6.  使用普通最小二乘法（OLS）估计参数。$\\boldsymbol{\\theta}$ 的 OLS 估计量由公式 $\\hat{\\boldsymbol{\\theta}} = (\\mathbf{X}^{\\top}\\mathbf{X})^{-1}\\mathbf{X}^{\\top}\\mathbf{y}$ 给出。估计的规模缩放指数 $\\hat{\\beta}$ 是 $\\hat{\\boldsymbol{\\theta}}$ 的第二个元素。\n7.  计算 OLS 残差 $\\mathbf{e} = \\mathbf{y} - \\mathbf{X}\\hat{\\boldsymbol{\\theta}}$。然后使用莫兰指数 $I$ 检验这些残差的空间自相关性。莫兰指数 $I$ 的公式为 $I = \\dfrac{n}{S_{0}} \\cdot \\dfrac{\\mathbf{e}^{\\top} \\mathbf{W} \\mathbf{e}}{\\mathbf{e}^{\\top} \\mathbf{e}}$。由于 $\\mathbf{W}$ 是构造成行随机的，所以 $S_0 = n$，公式简化为 $I = \\dfrac{\\mathbf{e}^{\\top} \\mathbf{W} \\mathbf{e}}{\\mathbf{e}^{\\top} \\mathbf{e}}$。\n8.  将计算出的 $I$ 值与无空间自相关的零假设下的期望值 $\\mathbb{E}[I] = -1/(n-1)$ 进行比较。\n9.  最后，报告四个值：估计的指数 $\\hat{\\beta}$、其偏差 $\\hat{\\beta} - \\beta$、残差的莫兰指数 $I$ 计算值以及零假设下的期望值 $\\mathbb{E}[I]$。\n\n整个过程被系统地实现为代码，以运行指定的测试用例并生成所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef calculate_for_case(params):\n    \"\"\"\n    Runs a single simulation case for the urban scaling model with spatial errors.\n    \"\"\"\n    n, k, beta, rho, sigma, seed = params\n    mu_log_N, tau_log_N = 11.0, 1.0\n    a = 1.0  # As per problem, log(a) = 0\n\n    rng = np.random.default_rng(seed)\n\n    # 1. Generate n city locations from Uniform([0,1]^2)\n    locations = rng.uniform(0.0, 1.0, size=(n, 2))\n\n    # 2. Construct k-nearest-neighbor spatial weight matrix W\n    dist_matrix = cdist(locations, locations, 'euclidean')\n    np.fill_diagonal(dist_matrix, np.inf)\n\n    # Get indices of k nearest neighbors for each city\n    neighbor_indices = np.argpartition(dist_matrix, k, axis=1)[:, :k]\n\n    # Create binary weight matrix\n    W_unstd = np.zeros((n, n))\n    np.put_along_axis(W_unstd, neighbor_indices, 1, axis=1)\n\n    # Row-standardize the matrix\n    row_sums = W_unstd.sum(axis=1, keepdims=True)\n    W = np.divide(W_unstd, row_sums, out=np.zeros_like(W_unstd), where=row_sums != 0)\n\n    # 3. Generate spatially autocorrelated disturbance eta\n    u = rng.normal(loc=0.0, scale=sigma, size=n)\n    A = np.identity(n) - rho * W\n    eta = np.linalg.solve(A, u)\n\n    # 4. Generate city populations N\n    log_N = rng.normal(loc=mu_log_N, scale=tau_log_N, size=n)\n\n    # 5. Formulate log-linear model and estimate by OLS\n    # log(Y) = log(a) + beta * log(N) + eta. Since a=1, log(a)=0.\n    y = beta * log_N + eta\n    \n    # Construct design matrix X = [1, log(N)]\n    X = np.vstack([np.ones(n), log_N]).T\n\n    # Compute OLS estimator: theta_hat = (X'X)^-1 X'y\n    try:\n        XTX_inv = np.linalg.inv(X.T @ X)\n        theta_hat = XTX_inv @ X.T @ y\n    except np.linalg.LinAlgError:\n        # Fallback for singular matrix, although not expected here\n        theta_hat, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n\n    beta_hat = theta_hat[1]\n\n    # Compute OLS residuals\n    e = y - X @ theta_hat\n\n    # 6. Compute Moran’s I\n    # For row-standardized W, S0=n, so the formula is I = (e'We) / (e'e)\n    numerator_I = e.T @ W @ e\n    denominator_I = e.T @ e\n    \n    # Handle case where residuals are all zero\n    if denominator_I == 0.0:\n        moran_I = 0.0\n    else:\n        moran_I = numerator_I / denominator_I\n\n    # Expected value of Moran's I under the null hypothesis\n    E_I = -1.0 / (n - 1)\n    \n    # Bias of the exponent estimate\n    bias = beta_hat - beta\n\n    return [beta_hat, bias, moran_I, E_I]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (n, k, beta, rho, sigma, seed)\n        (64, 4, 1.15, 0.0, 0.2, 1),\n        (64, 4, 1.15, 0.6, 0.2, 2),\n        (64, 4, 0.85, 0.9, 0.3, 3),\n        (64, 4, 1.00, -0.5, 0.2, 4),\n        (16, 3, 1.20, 0.7, 0.5, 5),\n    ]\n\n    results = []\n    for case in test_cases:\n        result_metrics = calculate_for_case(case)\n        results.append(result_metrics)\n\n    # Format the results to 6 decimal places per the problem specification.\n    # The final print statement must match the required format exactly.\n    formatted_results = [[round(val, 6) for val in res] for res in results]\n    print(f\"{formatted_results}\")\n\nsolve()\n```"
        },
        {
            "introduction": "单一、普适的标度律可能无法完全捕捉到不同群体（例如，国家或地区）中城市系统的细微差异。本节的高级实践将介绍贝叶斯分层建模，这是一个强大的框架，它既能估计一个共享的标度指数，又能捕捉群体间的系统性差异。您将亲手实现一个贝叶斯模型，通过融合先验知识与数据来更新我们对城市标度律的认识，并学习如何在这种更复杂的模型下进行参数估计与预测。",
            "id": "4312865",
            "problem": "考虑一个典型的城市标度律，它将一个广泛性城市量与人口相关联：城市产出 $Y$ 的期望值与人口 $N$ 呈幂律关系。标准公式假设存在一个乘性的对数正态波动，得到 $Y = A N^{\\beta} \\exp(\\varepsilon)$，其中 $A$ 是一个基线因子，$\\beta$ 是标度指数，而 $\\varepsilon$ 是一个零均值的随机项。取自然对数后，在存在高斯噪声的情况下，得到一个线性关系：$y = a + \\beta x + \\varepsilon$，其中 $y = \\log Y$，$x = \\log N$，且 $\\varepsilon \\sim \\mathcal{N}(0,\\sigma^2)$。\n\n在许多经验情境中，城市隶属于不同的组（例如，国家或地区），这些组会以一种仅靠人口无法完全解释的方式调节基线。一个简约的分层扩展将截距中的组级偏差建模为 $y_i = a + \\beta x_i + u_{g(i)} + \\varepsilon_i$，其中 $u_{g(i)}$ 是观测值 $i$ 所在组 $g(i)$ 的组级随机截距，且对于不同观测值，$\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$ 是独立的。\n\n我们对所有参数采用方差已知的高斯先验，以创建一个共轭正态-正态模型：\n- $a \\sim \\mathcal{N}(m_a, s_a^2)$,\n- $\\beta \\sim \\mathcal{N}(m_{\\beta}, s_{\\beta}^2)$,\n- 对于每个组索引 $j$，$u_j \\sim \\mathcal{N}(0, \\tau^2)$ 独立，\n- 以及 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$。\n\n设设计矩阵 $X$ 包含一个全局截距、协变量 $x$，以及为每个组的 $u_j$ 设置的一个指示符列。设参数向量为 $w = [a, \\beta, u_1, \\dots, u_G]^{\\top}$，其先验均值为 $m = [m_a, m_{\\beta}, 0, \\dots, 0]^{\\top}$，先验协方差为 $S = \\mathrm{diag}(s_a^2, s_{\\beta}^2, \\tau^2, \\dots, \\tau^2)$。似然为 $p(y \\mid w) = \\mathcal{N}(X w, \\sigma^2 I)$，根据贝叶斯法则，后验 $p(w \\mid y)$ 是高斯分布，其精度和均值由以下公式给出\n$$\\Lambda_{\\text{post}} = S^{-1} + \\frac{1}{\\sigma^2} X^{\\top} X,$$\n$$\\mu_{\\text{post}} = \\Lambda_{\\text{post}}^{-1} \\left( S^{-1} m + \\frac{1}{\\sigma^2} X^{\\top} y \\right).$$\n后验均值 $\\mu_{\\text{post}}$ 在此共轭设定中既是平方误差损失下的贝叶斯估计量，也是最大后验估计。对于新协变量 $x_{\\star}$ 和组 $g_{\\star}$ 的预测， $y_{\\star}$ 的后验预测均值由线性形式 $x_{\\star}^{\\top} \\mu_{\\text{post}}$ 给出，其中 $x_{\\star}$ 是相应的设计向量（包括截距和适当的组指示符）。\n\n您必须实现一个程序，该程序针对下方的固定数据集以及指定的先验方差和已知噪声水平的测试套件，计算：\n- 标度指数 $\\beta$ 的后验均值，\n- 在 $x_{\\star}$ 和 $g_{\\star}$ 处 $y_{\\star}$ 的后验预测均值，\n针对每个测试案例。\n\n数据（所有值均为自然对数，因此是无量纲的）：\n- 观测值 $i \\in \\{1,2,3,4,5,6\\}$，包含数据对 $(x_i,y_i)$ 和组索引 $g(i)$：\n  - $i = 1$: $x_1 = 10.5$, $y_1 = 2.375$, $g(1) = 0$。\n  - $i = 2$: $x_2 = 12.0$, $y_2 = 3.95$, $g(2) = 0$。\n  - $i = 3$: $x_3 = 11.0$, $y_3 = 2.75$, $g(3) = 1$。\n  - $i = 4$: $x_4 = 13.0$, $y_4 = 4.75$, $g(4) = 1$。\n  - $i = 5$: $x_5 = 9.8$, $y_5 = 1.45$, $g(5) = 0$。\n  - $i = 6$: $x_6 = 12.6$, $y_6 = 4.39$, $g(6) = 1$。\n- 共有 $G = 2$ 个组，索引为 $j \\in \\{0,1\\}$。\n\n所有测试案例的固定先验均值：\n- $m_a = -9.5$,\n- $m_{\\beta} = 1.1$,\n- $m_{u_0} = 0$,\n- $m_{u_1} = 0$。\n\n所有测试案例的固定新预测点：\n- $x_{\\star} = 11.5$,\n- $g_{\\star} = 0$。\n\n包含四个测试案例的测试套件，每个案例指定 $(s_a^2, s_{\\beta}^2, \\tau^2, \\sigma^2)$ 和一个建模方案：\n1. 基线分层案例：$s_a^2 = 4.0$, $s_{\\beta}^2 = 0.25$, $\\tau^2 = 0.25$, $\\sigma^2 = 0.04$，包含组随机效应。\n2. $\\beta$ 的强先验：$s_a^2 = 4.0$, $s_{\\beta}^2 = 0.01$, $\\tau^2 = 0.25$, $\\sigma^2 = 0.04$，包含组随机效应。\n3. 无随机效应（无组偏差的固定效应模型）：$s_a^2 = 4.0$, $s_{\\beta}^2 = 0.25$, $\\tau^2 = 0$, $\\sigma^2 = 0.04$，排除组随机效应。\n4. 高观测噪声：$s_a^2 = 4.0$, $s_{\\beta}^2 = 0.25$, $\\tau^2 = 0.25$, $\\sigma^2 = 0.25$，包含组随机效应。\n\n计算要求：\n- 对于分层案例，构建设计矩阵 $X$，其列为 $[1, x, \\mathbb{I}(g=0), \\mathbb{I}(g=1)]$；对于无随机效应案例，其列为 $[1, x]$。\n- 对于分层案例，将先验协方差 $S$ 构造成一个对角矩阵，其对角元素与 $[a, \\beta, u_0, u_1]$ 的方差相匹配；对于无随机效应案例，其对角元素与 $[a, \\beta]$ 的方差相匹配。使用相应的先验均值向量 $m$。\n- 使用上述方程计算后验均值 $\\mu_{\\text{post}}$。\n- 提取 $\\beta$ 的后验均值，并将在 $(x_{\\star}, g_{\\star})$ 处的后验预测均值计算为 $x_{\\star}^{\\top} \\mu_{\\text{post}}$。\n\n答案规格：\n- 对于四个测试案例中的每一个，输出两个十进制数：第一个是 $\\beta$ 的后验均值，第二个是 $y_{\\star}$ 的后验预测均值。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。顺序必须是\n$[\\beta_{\\text{post}}^{(1)}, y_{\\star}^{(1)}, \\beta_{\\text{post}}^{(2)}, y_{\\star}^{(2)}, \\beta_{\\text{post}}^{(3)}, y_{\\star}^{(3)}, \\beta_{\\text{post}}^{(4)}, y_{\\star}^{(4)}]$,\n其中上标 $(k)$ 按照上面给出的顺序索引测试案例。\n\n不涉及物理单位，因为所有变量都是有量纲量的对数，从而得到无量纲的值。所有输出都表示为十进制浮点数。",
            "solution": "我们从业界熟知的经验规律——城市标度律开始，其中一个广泛性城市量与人口呈幂律关系。这被建模为 $Y = A N^{\\beta} \\exp(\\varepsilon)$，其中 $A$ 和 $\\beta$ 是参数，$\\varepsilon$ 是一个波动项。取自然对数后得到线性模型 $y = a + \\beta x + \\varepsilon$，其中 $a = \\log A$，$x = \\log N$，且 $\\varepsilon$ 被建模为高斯噪声 $\\varepsilon \\sim \\mathcal{N}(0,\\sigma^2)$。\n\n为了解释例如不同国家之间基线的组级异质性，我们扩展模型以包含随机截距：$y_i = a + \\beta x_i + u_{g(i)} + \\varepsilon_i$，其中 $u_{g(i)}$ 是特定于组的偏差，且 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$。我们为每个组 $j$ 假设独立的高斯先验 $a \\sim \\mathcal{N}(m_a, s_a^2)$，$\\beta \\sim \\mathcal{N}(m_{\\beta}, s_{\\beta}^2)$ 和 $u_j \\sim \\mathcal{N}(0, \\tau^2)$。观测噪声方差 $\\sigma^2$、组方差 $\\tau^2$ 以及先验方差 $s_a^2$ 和 $s_{\\beta}^2$ 被视为已知的超参数，这导出了一个共轭正态-正态贝叶斯模型。\n\n我们组建线性代数表示。设设计矩阵 $X$ 每行对应一个观测值，列分别对应截距、$x$ 和每个组的一个指示符。对于具有 $G = 2$ 个组且组索引在 $\\{0,1\\}$ 中的分层案例，我们定义\n$$\nX = \\begin{bmatrix}\n1  x_1  \\mathbb{I}(g(1)=0)  \\mathbb{I}(g(1)=1) \\\\\n\\vdots  \\vdots  \\vdots  \\vdots \\\\\n1  x_n  \\mathbb{I}(g(n)=0)  \\mathbb{I}(g(n)=1)\n\\end{bmatrix},\n$$\n和参数向量\n$$\nw = \\begin{bmatrix} a \\\\ \\beta \\\\ u_0 \\\\ u_1 \\end{bmatrix}, \\quad\nm = \\begin{bmatrix} m_a \\\\ m_{\\beta} \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\nS = \\mathrm{diag}\\left(s_a^2, s_{\\beta}^2, \\tau^2, \\tau^2\\right).\n$$\n对于无随机效应的案例，我们排除组的列和参数，得到\n$$\nX = \\begin{bmatrix}\n1  x_1 \\\\\n\\vdots  \\vdots \\\\\n1  x_n\n\\end{bmatrix}, \\quad\nw = \\begin{bmatrix} a \\\\ \\beta \\end{bmatrix}, \\quad\nm = \\begin{bmatrix} m_a \\\\ m_{\\beta} \\end{bmatrix}, \\quad\nS = \\mathrm{diag}\\left(s_a^2, s_{\\beta}^2\\right).\n$$\n\n给定高斯似然 $p(y \\mid w) = \\mathcal{N}(Xw, \\sigma^2 I)$ 和高斯先验 $p(w) = \\mathcal{N}(m, S)$，后验分布 $p(w \\mid y)$ 是高斯分布，其精度矩阵和均值由标准共轭更新给出：\n$$\n\\Lambda_{\\text{post}} = S^{-1} + \\frac{1}{\\sigma^2} X^{\\top} X,\n$$\n$$\n\\mu_{\\text{post}} = \\Lambda_{\\text{post}}^{-1} \\left( S^{-1} m + \\frac{1}{\\sigma^2} X^{\\top} y \\right).\n$$\n这通过在对数后验中通过配方法推导得出，对数后验正比于\n$$\n- \\frac{1}{2} (y - X w)^{\\top} \\left( \\frac{1}{\\sigma^2} I \\right) (y - X w) - \\frac{1}{2} (w - m)^{\\top} S^{-1} (w - m).\n$$\n收集 $w$ 的二次项和线性项，得到精度 $\\Lambda_{\\text{post}}$ 和线性项 $\\eta = S^{-1} m + \\frac{1}{\\sigma^2} X^{\\top} y$，从而给出后验均值 $\\mu_{\\text{post}} = \\Lambda_{\\text{post}}^{-1} \\eta$。\n\n标度指数 $\\beta$ 的后验均值在两种模型方案（分层和无随机效应）中都是 $\\mu_{\\text{post}}$ 的第二个分量，因为我们按 $[a, \\beta, \\dots]$ 的顺序排列参数。对于新点 $(x_{\\star}, g_{\\star})$ 的预测，$y_{\\star}$ 的后验预测分布是高斯分布，其均值等于 $X_{\\star} w$ 在后验下的期望，即 $x_{\\star}^{\\top} \\mu_{\\text{post}}$，其中 $x_{\\star}$ 是新点的设计向量。具体来说，对于具有两个组的分层案例，$x_{\\star} = [1, x_{\\star}, \\mathbb{I}(g_{\\star}=0), \\mathbb{I}(g_{\\star}=1)]^{\\top}$。对于无随机效应的案例，$x_{\\star} = [1, x_{\\star}]^{\\top}$。观测噪声的均值为零，因此它对预测均值没有贡献。\n\n每个测试案例的算法步骤：\n1. 根据指定的建模方案（包含或排除组指示符）从固定数据集中构建 $X$。\n2. 将 $S$ 构造成一个对角矩阵，其对角元素为方案中参数的相应方差，并按规定构成 $m$。\n3. 通过对对角元素求逆来计算 $S^{-1}$。\n4. 计算 $\\Lambda_{\\text{post}} = S^{-1} + \\frac{1}{\\sigma^2} X^{\\top} X$。\n5. 计算 $\\eta = S^{-1} m + \\frac{1}{\\sigma^2} X^{\\top} y$。\n6. 使用数值稳定的求解器求解线性系统 $\\Lambda_{\\text{post}} \\mu_{\\text{post}} = \\eta$ 以获得 $\\mu_{\\text{post}}$。\n7. 提取 $\\beta$ 的后验均值为 $\\mu_{\\text{post}}[1]$。\n8. 构建 $x_{\\star}$ 并计算 $y_{\\star}$ 的预测均值为 $x_{\\star}^{\\top} \\mu_{\\text{post}}$。\n\n测试套件和输出：\n- 测试案例 1：$s_a^2 = 4.0$, $s_{\\beta}^2 = 0.25$, $\\tau^2 = 0.25$, $\\sigma^2 = 0.04$，分层。\n- 测试案例 2：$s_a^2 = 4.0$, $s_{\\beta}^2 = 0.01$, $\\tau^2 = 0.25$, $\\sigma^2 = 0.04$，分层。\n- 测试案例 3：$s_a^2 = 4.0$, $s_{\\beta}^2 = 0.25$, $\\tau^2 = 0$, $\\sigma^2 = 0.04$，无随机效应。\n- 测试案例 4：$s_a^2 = 4.0$, $s_{\\beta}^2 = 0.25$, $\\tau^2 = 0.25$, $\\sigma^2 = 0.25$，分层。\n\n程序必须以以下格式输出单行\n$[\\beta_{\\text{post}}^{(1)}, y_{\\star}^{(1)}, \\beta_{\\text{post}}^{(2)}, y_{\\star}^{(2)}, \\beta_{\\text{post}}^{(3)}, y_{\\star}^{(3)}, \\beta_{\\text{post}}^{(4)}, y_{\\star}^{(4)}]$,\n包含每个量的十进制浮点数，对应于每个测试案例中 $\\beta$ 的后验均值和在 $(x_{\\star} = 11.5, g_{\\star} = 0)$ 处的后验预测均值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef posterior_mean_and_predictive(x, y, groups, m_a, m_beta, s2_a, s2_beta,\n                                  tau2, sigma2, include_random_effects,\n                                  x_star, g_star, n_groups=2):\n    \"\"\"\n    Compute the posterior mean for parameters in a Gaussian linear hierarchical model\n    and the posterior predictive mean for a new observation.\n\n    Parameters:\n        x: np.ndarray, shape (n,)\n            Log-population covariate values.\n        y: np.ndarray, shape (n,)\n            Log-output response values.\n        groups: np.ndarray, shape (n,)\n            Integer group indices for each observation in [0, n_groups-1].\n        m_a, m_beta: float\n            Prior means for a and beta.\n        s2_a, s2_beta: float\n            Prior variances for a and beta.\n        tau2: float\n            Prior variance for each group random intercept (ignored if include_random_effects is False).\n        sigma2: float\n            Known observation noise variance.\n        include_random_effects: bool\n            Whether to include group random intercepts.\n        x_star: float\n            New covariate value for prediction.\n        g_star: int\n            Group index for the new observation.\n        n_groups: int\n            Number of groups (default 2).\n\n    Returns:\n        beta_post_mean: float\n            Posterior mean of beta.\n        y_pred_mean: float\n            Posterior predictive mean at (x_star, g_star).\n    \"\"\"\n    n = x.shape[0]\n\n    # Build design matrix X\n    if include_random_effects:\n        # Intercept, x, group indicators\n        X = np.zeros((n, 2 + n_groups))\n        X[:, 0] = 1.0  # intercept\n        X[:, 1] = x    # slope covariate\n        for i in range(n):\n            X[i, 2 + groups[i]] = 1.0  # group indicator\n        # Prior mean and covariance (diagonal)\n        m = np.zeros(2 + n_groups)\n        m[0] = m_a\n        m[1] = m_beta\n        # Diagonal prior variances\n        S_diag = np.zeros(2 + n_groups)\n        S_diag[0] = s2_a\n        S_diag[1] = s2_beta\n        S_diag[2:] = tau2\n        # New point design vector\n        x_star_vec = np.zeros(2 + n_groups)\n        x_star_vec[0] = 1.0\n        x_star_vec[1] = x_star\n        x_star_vec[2 + g_star] = 1.0\n    else:\n        # Intercept and x only\n        X = np.zeros((n, 2))\n        X[:, 0] = 1.0\n        X[:, 1] = x\n        m = np.array([m_a, m_beta], dtype=float)\n        S_diag = np.array([s2_a, s2_beta], dtype=float)\n        x_star_vec = np.array([1.0, x_star], dtype=float)\n\n    # Compute posterior precision and mean\n    # Prior precision is inverse of diagonal variances\n    S_inv_diag = 1.0 / S_diag\n    # Lambda_post = S^{-1} + (1/sigma^2) X^T X\n    Lambda_post = np.diag(S_inv_diag) + (X.T @ X) / sigma2\n    # eta = S^{-1} m + (1/sigma^2) X^T y\n    eta = S_inv_diag * m + (X.T @ y) / sigma2\n    # Solve for posterior mean\n    mu_post = np.linalg.solve(Lambda_post, eta)\n\n    # Extract beta posterior mean (index 1)\n    beta_post_mean = float(mu_post[1])\n    # Predictive mean y_star = x_star^T mu_post\n    y_pred_mean = float(x_star_vec @ mu_post)\n\n    return beta_post_mean, y_pred_mean\n\ndef solve():\n    # Fixed dataset\n    x = np.array([10.5, 12.0, 11.0, 13.0, 9.8, 12.6], dtype=float)\n    y = np.array([2.375, 3.95, 2.75, 4.75, 1.45, 4.39], dtype=float)\n    groups = np.array([0, 0, 1, 1, 0, 1], dtype=int)\n\n    # Fixed prior means\n    m_a = -9.5\n    m_beta = 1.1\n\n    # Prediction point\n    x_star = 11.5\n    g_star = 0\n\n    # Test cases: (s2_a, s2_beta, tau2, sigma2, include_random_effects)\n    test_cases = [\n        (4.0, 0.25, 0.25, 0.04, True),   # Case 1: baseline hierarchical\n        (4.0, 0.01, 0.25, 0.04, True),   # Case 2: strong prior on beta\n        (4.0, 0.25, 0.0, 0.04, False),   # Case 3: no random effects\n        (4.0, 0.25, 0.25, 0.25, True),   # Case 4: high observational noise\n    ]\n\n    results = []\n    for s2_a, s2_beta, tau2, sigma2, include_re in test_cases:\n        beta_post, y_pred = posterior_mean_and_predictive(\n            x=x, y=y, groups=groups,\n            m_a=m_a, m_beta=m_beta,\n            s2_a=s2_a, s2_beta=s2_beta,\n            tau2=tau2, sigma2=sigma2,\n            include_random_effects=include_re,\n            x_star=x_star, g_star=g_star,\n            n_groups=2\n        )\n        results.append(beta_post)\n        results.append(y_pred)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}