{
    "hands_on_practices": [
        {
            "introduction": "在分析网络的稳健性之前，我们必须首先掌握其内在结构。无标度网络最显著的特征是其高度的异质性，即存在少数拥有大量连接的“中心节点”（hub）。本练习旨在通过量化这些结构特征，帮助你具体感受无标度网络的异质性：我们将从理论上估算网络中最大节点的度，并计算高度数节点的比例。这个基础计算是理解其“鲁棒而又脆弱”特性的第一步。",
            "id": "4301052",
            "problem": "考虑一个简单的无向无标度网络，其中节点度被建模为从一个连续幂律分布中抽取的独立同分布（IID）样本，该分布的指数为 $\\gamma$，支撑集为 $[k_{\\min}, \\infty)$，概率密度为 $p(k)$，且分布已作适当归一化。假设 $\\gamma>2$ 且网络规模 $N$ 足够大，以使极值估计有意义。仅使用以下基本要素：\n- 无标度度分布的定义：其尾部遵循幂律 $k^{-\\gamma}$。\n- 归一化要求 $\\int_{k_{\\min}}^{\\infty} p(k)\\,dk = 1$。\n- 生存（尾）函数 $S(k) = \\int_{k}^{\\infty} p(x)\\,dx$，它给出了度不小于 $k$ 的节点的比例。\n- IID样本的基本次序统计学推理：在一个大小为 $N$ 的样本中，典型的最大值渐近地是生存概率为 $1/N$ 阶的分位数。\n\n从这些原则出发，推导：\n1. 最大度 $k_{\\max}$ 作为 $N$、$\\gamma$ 和 $k_{\\min}$ 函数的渐近标度表达式。\n2. 度不小于阈值 $K$ 的节点比例的表达式，用 $\\gamma$ 和 $k_{\\min}$ 表示。\n\n然后，使用 $N = 10^{5}$、$\\gamma = 2.5$、$k_{\\min} = 1$ 和 $K = 100$ 对两者进行求值。将您的数值答案四舍五入到四位有效数字。将两个结果都表示为无量纲量。",
            "solution": "问题陈述经验证是科学上合理的、适定的、客观的和完整的。它描述了复杂网络研究中的一个典型问题，基于统计力学和概率论的既定原理。其中一些假设，例如用连续概率分布对离散的节点度进行建模，是标准的理论近似，适用于大网络规模 ($N$) 和所要求的渐近分析。因此，我们可以进行完整的解答。\n\n问题要求我们推导与无标度网络相关的两个量。问题陈述节点度被建模为从支撑集为 $[k_{\\min}, \\infty)$、指数为 $\\gamma$ 的连续幂律概率密度函数 (PDF) $p(k)$ 中抽取的独立同分布 (IID) 随机变量。\n\n首先，我们必须确定归一化后的 PDF $p(k)$ 的显式形式。问题指定了幂律形式，我们可以将其写为 $p(k) = Ck^{-\\gamma}$（对于 $k \\ge k_{\\min}$），其中 $C$ 是归一化常数。通过强制执行归一化条件 $\\int_{k_{\\min}}^{\\infty} p(k) \\, dk = 1$ 来求出 $C$ 的值。\n\n$$ \\int_{k_{\\min}}^{\\infty} C k^{-\\gamma} \\, dk = 1 $$\n$$ C \\left[ \\frac{k^{1-\\gamma}}{1-\\gamma} \\right]_{k_{\\min}}^{\\infty} = 1 $$\n鉴于问题指定 $\\gamma > 2$，指数 $1-\\gamma$ 小于 $-1$，这保证了当 $k \\to \\infty$ 时，$k^{1-\\gamma}$ 项收敛于 $0$。因此，积分的计算结果为：\n$$ C \\left( 0 - \\frac{k_{\\min}^{1-\\gamma}}{1-\\gamma} \\right) = C \\frac{k_{\\min}^{1-\\gamma}}{\\gamma-1} = 1 $$\n求解常数 $C$，我们得到：\n$$ C = (\\gamma-1)k_{\\min}^{\\gamma-1} $$\n因此，适当归一化的 PDF 是：\n$$ p(k) = (\\gamma-1)k_{\\min}^{\\gamma-1} k^{-\\gamma} \\quad \\text{for } k \\ge k_{\\min} $$\n\n接下来，我们处理第二个任务：推导度不小于阈值 $K$ 的节点比例的表达式。这个比例由生存函数 $S(k)$ 给出，也称为互补累积分布函数 (CCDF)。生存函数的定义为 $S(k) = \\int_{k}^{\\infty} p(x) \\, dx$。我们对一个任意阈值 $k$ 计算此积分，之后可以将其设为 $K$。\n\n$$ S(k) = \\int_{k}^{\\infty} (\\gamma-1)k_{\\min}^{\\gamma-1} x^{-\\gamma} \\, dx $$\n$$ S(k) = (\\gamma-1)k_{\\min}^{\\gamma-1} \\left[ \\frac{x^{1-\\gamma}}{1-\\gamma} \\right]_{k}^{\\infty} $$\n再次利用条件 $\\gamma > 2$，积分上限处的项消失。\n$$ S(k) = (\\gamma-1)k_{\\min}^{\\gamma-1} \\left( 0 - \\frac{k^{1-\\gamma}}{1-\\gamma} \\right) = (\\gamma-1)k_{\\min}^{\\gamma-1} \\left( \\frac{k^{1-\\gamma}}{\\gamma-1} \\right) $$\n$$ S(k) = k_{\\min}^{\\gamma-1} k^{1-\\gamma} = \\left(\\frac{k}{k_{\\min}}\\right)^{1-\\gamma} $$\n这个 $S(k)$ 的表达式代表了度不小于 $k$ 的节点的比例。对于特定阈值 $K$，该比例为 $S(K) = \\left(\\frac{K}{k_{\\min}}\\right)^{1-\\gamma}$。这完成了问题第二部分的符号推导。\n\n现在我们处理第一个任务：推导最大度 $k_{\\max}$ 的渐近标度表达式。问题指导我们使用次序统计学推理。对于一个规模为 $N$ 的大网络，典型的最大度 $k_{\\max}$ 是这样一个值，我们期望在该网络中大约能找到一个度等于或大于 $k_{\\max}$ 的节点。度不小于 $k_{\\max}$ 的节点的期望数量是总节点数 $N$ 乘以单个节点具有这样度的概率 $S(k_{\\max})$。将此期望设为 $1$ 即可得到控制条件：\n\n$$ N \\cdot S(k_{\\max}) \\approx 1 \\implies S(k_{\\max}) \\approx \\frac{1}{N} $$\n代入我们推导出的生存函数表达式：\n$$ \\left(\\frac{k_{\\max}}{k_{\\min}}\\right)^{1-\\gamma} \\approx \\frac{1}{N} $$\n我们现在解这个方程求 $k_{\\max}$：\n$$ \\frac{k_{\\max}}{k_{\\min}} \\approx \\left(\\frac{1}{N}\\right)^{\\frac{1}{1-\\gamma}} = N^{-\\frac{1}{1-\\gamma}} = N^{\\frac{1}{\\gamma-1}} $$\n$$ k_{\\max} \\approx k_{\\min} N^{\\frac{1}{\\gamma-1}} $$\n这就是所要求的最大度 $k_{\\max}$ 作为 $N$、$\\gamma$ 和 $k_{\\min}$ 函数的渐近标度表达式。这完成了问题第一部分的符号推导。\n\n最后，我们使用给定值进行数值计算：$N = 10^5$，$\\gamma = 2.5$，$k_{\\min} = 1$，以及 $K = 100$。\n\n对于最大度 $k_{\\max}$：\n$$ k_{\\max} \\approx k_{\\min} N^{\\frac{1}{\\gamma-1}} = (1) \\left(10^5\\right)^{\\frac{1}{2.5-1}} = \\left(10^5\\right)^{\\frac{1}{1.5}} = \\left(10^5\\right)^{2/3} = 10^{5 \\times \\frac{2}{3}} = 10^{10/3} $$\n$$ k_{\\max} \\approx 2154.43469\\dots $$\n将此结果四舍五入到四位有效数字，得到 $k_{\\max} \\approx 2154$。\n\n对于度不小于 $K = 100$ 的节点比例，我们计算 $S(100)$：\n$$ S(100) = \\left(\\frac{100}{k_{\\min}}\\right)^{1-\\gamma} = \\left(\\frac{100}{1}\\right)^{1-2.5} = 100^{-1.5} = (10^2)^{-1.5} = 10^{-3} $$\n$$ S(100) = 0.001 $$\n这个结果是精确值。为了按要求用四位有效数字表示，我们将其写成科学记数法 $1.000 \\times 10^{-3}$。\n\n根据问题陈述的要求，两个结果都是无量纲量。度 $k_{\\max}$ 是一个计数，而 $S(K)$ 是一个比例。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 2154  1.000 \\times 10^{-3} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "渗流理论是研究网络稳健性的经典框架。本练习将运用强大的生成函数方法，对两种不同的随机故障模式——节点移除（点渗流）和连边移除（边渗流）——对网络完整性的影响进行理论比较。通过这一推导，你将发现一个简洁而普适的数学关系，它深刻揭示了这两种故障模式在破坏网络连通性方面的根本差异。",
            "id": "4301081",
            "problem": "考虑一个大型稀疏的构型模型网络，其度分布为 $P(k) \\propto k^{-\\gamma}$，其中 $k$ 为整数，$k \\in \\{k_{\\min}, k_{\\min}+1, \\dots, k_{\\max}\\}$，$\\gamma = 2.7$，$k_{\\min} \\geq 1$，$k_{\\max}$ 服从一个结构性截断标度，以确保在有限网络规模下二阶矩有限。假设网络是局部树状的。应用了两个独立的渗流过程：\n- 点渗流，其中每个节点以概率 $p_{n}$ 独立地被占据。\n- 边渗流，其中每条边以概率 $p_{e}$ 独立地被占据。\n\n将平均度降低因子定义为渗流后网络中的平均度与原始网络中平均度的比率。选择 $p_{n}$ 和 $p_{e}$，使得点渗流和边渗流产生完全相同的平均度降低因子。使用构型模型的概率生成函数 (PGF) 框架，推导在此相等条件下巨组分分数之比 $S_{\\mathrm{bond}} / S_{\\mathrm{site}}$ 的闭式解析表达式。将您的最终答案仅表示为共同占据概率 $p$ 的函数。不需要数值近似。",
            "solution": "该问题已经过验证，并被确定为一个有效的科学问题。\n\n求解过程首先为原始网络建立概率生成函数 (PGF) 框架。然后，我们分析点渗流和边渗流对平均度的影响，以建立它们各自概率之间的关系。最后，我们推导两种过程中巨组分分数的表达式，并计算它们的比率。\n\n设原始网络的度分布为 $P(k)$。该分布的 PGF 定义为：\n$$\nG_0(x) = \\sum_{k=k_{\\min}}^{k_{\\max}} P(k) x^k\n$$\n网络的平均度为 $\\langle k \\rangle = G_0'(1)$。\n\n超度分布 $Q(k) = \\frac{(k+1)P(k+1)}{\\langle k \\rangle}$，是沿着一条随机边到达的节点的度分布，不计入所经过的那条边。其 PGF 为：\n$$\nG_1(x) = \\sum_{k=k_{\\min}-1}^{k_{\\max}-1} Q(k) x^k = \\frac{1}{\\langle k \\rangle} \\sum_{j=k_{\\min}}^{k_{\\max}} j P(j) x^{j-1} = \\frac{G_0'(x)}{G_0'(1)}\n$$\n\n首先，我们通过令平均度降低因子相等来确定 $p_n$ 和 $p_e$ 之间的关系。\n\n对于概率为 $p_n$ 的点渗流，度为 $k$ 的节点以概率 $p_n$ 被保留，以概率 $1-p_n$ 被移除。被移除节点的有效度为 $0$。点渗流后网络中（包括被移除的节点）的度分布的 PGF 为：\n$$\nG_{0, \\mathrm{site}}(x) = p_n G_0(x) + (1-p_n)x^0 = 1 - p_n + p_n G_0(x)\n$$\n渗流后网络的平均度为 $\\langle k \\rangle_{\\mathrm{site}} = G'_{0, \\mathrm{site}}(1) = p_n G_0'(1) = p_n \\langle k \\rangle$。\n平均度降低因子为 $\\frac{\\langle k \\rangle_{\\mathrm{site}}}{\\langle k \\rangle} = p_n$。\n\n对于概率为 $p_e$ 的边渗流，每条边以概率 $p_e$ 独立地被保留。对于一个原始度为 $k$ 的节点，其结果度 $k'$ 服从二项分布 $B(k, p_e)$。新度分布的 PGF 是通过将原始 PGF 与二项过程的 PGF $(1-p_e+p_e x)^k$ 进行复合得到的。\n$$\nG_{0, \\mathrm{bond}}(x) = \\sum_k P(k) (1-p_e + p_e x)^k = G_0(1-p_e + p_e x)\n$$\n这个渗流后网络的平均度为 $\\langle k \\rangle_{\\mathrm{bond}} = G'_{0, \\mathrm{bond}}(1)$。使用链式法则：\n$$\n\\langle k \\rangle_{\\mathrm{bond}} = G_0'(1-p_e + p_e \\cdot 1) \\cdot p_e = p_e G_0'(1) = p_e \\langle k \\rangle\n$$\n平均度降低因子为 $\\frac{\\langle k \\rangle_{\\mathrm{bond}}}{\\langle k \\rangle} = p_e$。\n\n问题陈述这两个因子相等。因此：\n$$\np_n = p_e\n$$\n我们定义这个共同的占据概率为 $p \\equiv p_n = p_e$。问题要求最终答案用这个 $p$ 来表示。\n\n接下来，我们为每个过程推导巨组分的大小。\n\n对于点渗流，巨组分由初始被占据节点的一个子集构成。巨组分中的节点分数，相对于原始网络中的总节点数，为 $S_{\\mathrm{site}}$。\n设 $u_{\\mathrm{site}}$ 为原始网络中随机选择的一条边通向一个有限的被占据节点簇的概率。一条边通向一个邻居，该邻居以概率 $p$ 被占据。如果邻居未被占据（概率为 $1-p$），则路径终止，因此是有限簇的一部分。如果邻居被占据（概率为 $p$），它具有超度分布，其 PGF 为 $G_1(x)$。要使这个邻居属于一个有限簇，其所有其他出边也必须通向有限簇。其中一条这样的边通向有限簇的概率是 $u_{\\mathrm{site}}$。\n因此，$u_{\\mathrm{site}}$ 必须满足自洽方程：\n$$\nu_{\\mathrm{site}} = (1-p) + p \\sum_k \\frac{k P(k)}{\\langle k \\rangle} (u_{\\mathrm{site}})^{k-1} = 1 - p + p G_1(u_{\\mathrm{site}})\n$$\n一个随机选择的节点在一个有限簇中，如果它未被占据（因此是孤立的），或者它被占据但其所有邻居都通向有限簇。一个度为 $k$ 的被占据节点位于有限簇中的概率是 $(u_{\\mathrm{site}})^k$。一个随机选择的被占据节点位于有限簇中的概率是 $\\sum_k P(k) (u_{\\mathrm{site}})^k = G_0(u_{\\mathrm{site}})$。\n巨组分中被占据节点的分数是 $1-G_0(u_{\\mathrm{site}})$。因为最初只有分数 $p$ 的节点被占据，所以巨组分中节点的总分数为：\n$$\nS_{\\mathrm{site}} = p(1 - G_0(u_{\\mathrm{site}}))\n$$\n\n对于边渗流，我们可以直接使用渗流后网络的 PGF。设 $u$ 为渗流后网络中的一条边通向一个有限组分的概率。这必须满足 $u = G_{1, \\mathrm{bond}}(u)$，其中 $G_{1, \\mathrm{bond}}$ 是边渗流网络的超度 PGF。\n$$\nG'_{0, \\mathrm{bond}}(x) = \\frac{d}{dx} G_0(1-p+px) = p G_0'(1-p+px)\n$$\n$$\n\\langle k \\rangle_{\\mathrm{bond}} = G'_{0, \\mathrm{bond}}(1) = p G_0'(1) = p\\langle k \\rangle\n$$\n$$\nG_{1, \\mathrm{bond}}(x) = \\frac{G'_{0, \\mathrm{bond}}(x)}{\\langle k \\rangle_{\\mathrm{bond}}} = \\frac{p G_0'(1-p+px)}{p G_0'(1)} = G_1(1-p+px)\n$$\n$u_{\\mathrm{bond}}$ 的自洽方程，即渗流图中随机一条边通向一个有限组分的概率，是：\n$$\nu_{\\mathrm{bond}} = G_{1, \\mathrm{bond}}(u_{\\mathrm{bond}}) = G_1(1-p+p u_{\\mathrm{bond}})\n$$\n巨组分中的节点分数为 $S_{\\mathrm{bond}} = 1 - G_{0, \\mathrm{bond}}(u_{\\mathrm{bond}})$，其中 $G_{0, \\mathrm{bond}}$ 是渗流图的度 PGF。\n$$\nS_{\\mathrm{bond}} = 1 - G_0(1-p+p u_{\\mathrm{bond}})\n$$\n\n现在，我们比较 $u_{\\mathrm{site}}$ 和 $u_{\\mathrm{bond}}$ 的自洽方程。\n点渗流：$u_{\\mathrm{site}} = 1 - p + p G_1(u_{\\mathrm{site}})$\n边渗流：$u_{\\mathrm{bond}} = G_1(1 - p + p u_{\\mathrm{bond}})$\n\n让我们定义一个新变量 $v = 1-p+p u_{\\mathrm{bond}}$。整理得到 $u_{\\mathrm{bond}}$ 的表达式为 $u_{\\mathrm{bond}} = \\frac{v - (1-p)}{p}$。将 $v$ 代入边渗流方程的参数中得到：\n$$\nu_{\\mathrm{bond}} = G_1(v)\n$$\n现在代入 $u_{\\mathrm{bond}}$ 以 $v$ 表示的表达式：\n$$\n\\frac{v - (1-p)}{p} = G_1(v) \\implies v - (1-p) = p G_1(v) \\implies v = 1 - p + p G_1(v)\n$$\n这恰好是 $u_{\\mathrm{site}}$ 必须满足的同一个自洽方程。由于我们关心的是巨组分，我们取最小的非负解，这个解对两者来说必须是唯一的。因此，我们可以得出结论：\n$$\nu_{\\mathrm{site}} = v = 1 - p + p u_{\\mathrm{bond}}\n$$\n我们称这个共同解为 $u^*$，所以 $u_{\\mathrm{site}} = u^*$。\n\n现在我们用 $u^*$ 来表示 $S_{\\mathrm{site}}$ 和 $S_{\\mathrm{bond}}$：\n$$\nS_{\\mathrm{site}} = p(1-G_0(u_{\\mathrm{site}})) = p(1-G_0(u^*))\n$$\n对于 $S_{\\mathrm{bond}}$，我们有：\n$$\nS_{\\mathrm{bond}} = 1 - G_0(1-p+p u_{\\mathrm{bond}}) = 1 - G_0(v) = 1 - G_0(u^*)\n$$\n我们需要求出比率 $S_{\\mathrm{bond}} / S_{\\mathrm{site}}$。\n$$\n\\frac{S_{\\mathrm{bond}}}{S_{\\mathrm{site}}} = \\frac{1 - G_0(u^*)}{p(1 - G_0(u^*))}\n$$\n假设网络处于渗流阈值以上（即，$p$ 足够大以至于存在巨组分），那么 $S_{\\mathrm{site}} > 0$。这意味着 $1-G_0(u^*) \\neq 0$。因此我们可以从分子和分母中消去这一项。\n$$\n\\frac{S_{\\mathrm{bond}}}{S_{\\mathrm{site}}} = \\frac{1}{p}\n$$\n这个结果与度分布 $P(k)$ 的具体形式无关，只要网络是大型、稀疏且局部树状的，这些都是 PGF 形式主义有效的标准假设。参数 $\\gamma=2.7$、$k_{\\min}$ 和 $k_{\\max}$ 确保网络处于该分析有意义的区域（例如，具有有限的平均度和明确定义的渗流相变）。",
            "answer": "$$\n\\boxed{\\frac{1}{p}}\n$$"
        },
        {
            "introduction": "现实世界中的网络故障往往不是孤立事件，而可能引发连锁反应。这个计算实践将模拟一个更贴近现实的场景：移除网络中的核心“中心节点”后，负载如何在剩余节点间重新分配，并可能触发一系列级联失效。通过编程实现该模型，你将亲手探索无标度网络在面对蓄意攻击时的脆弱性，并研究如何通过调整系统的“容忍度”参数 $\\alpha$ 来避免灾难性的网络崩溃。",
            "id": "4301020",
            "problem": "考虑一个有限无向简单图，该图代表一个无标度网络，其度分布遵循幂律 $P(k) \\propto k^{-\\gamma}$，指数 $\\gamma = 2.4$。无标度网络是指其节点的度 $k$（连接到节点的连接数）在 $[k_{\\min}, k_{\\max}]$ 范围内遵循幂律分布的网络。此类网络在蓄意攻击下的鲁棒性可以通过移除一小部分度最高的节点（中心节点）并观察在负载-容量模型下由此产生的过载级联来研究。目标是确定级联规模如何依赖于容忍参数，并找出使网络稳定的临界容忍度。\n\n使用以下基本设定：\n- 度分布满足 $P(k) \\propto k^{-\\gamma}$，其中 $\\gamma = 2.4$，且被 $k_{\\min}$ 和 $k_{\\max}$ 截断。\n- 节点 $i$ 上的负载 $L_i$ 由其在无向、无权网络中基于最短路径的介数中心性给出，定义为 $L_i = \\sum_{s \\neq i \\neq t} \\frac{\\sigma_{st}(i)}{\\sigma_{st}}$，其中 $\\sigma_{st}$ 是节点 $s$ 和 $t$ 之间的最短路径数量，而 $\\sigma_{st}(i)$ 是这些最短路径中经过节点 $i$ 的数量。\n- 节点 $i$ 的容量 $C_i$ 满足 $C_i = (1 + \\alpha)L_i$，其中 $\\alpha \\geq 0$ 是一个全局容忍参数。\n- 通过移除度数最高的一小部分节点（比例为 $f$）来引发过载级联（蓄意攻击）。移除后，在剩余网络上重新计算负载；任何新负载 $L_i^{\\text{new}}$ 超过其容量 $C_i$ 的节点 $i$ 都会失效并被移除。此过程重复进行，直到没有新的失效发生。\n- 级联规模定义为除最初移除的节点外，因级联而失效的节点所占的比例（以小数表示）。\n\n您的任务：\n1. 使用配置模型，根据一个截断的幂律度序列生成一个随机无标度网络，该序列具有指数 $\\gamma = 2.4$，最小度 $k_{\\min}$，最大度 $k_{\\max}$，以及节点数 $N$。在连续截断分布上使用逆变换采样法生成度序列，然后四舍五入为整数，并通过随机均匀配对末端来构建图。移除自环并合并多重边，以使最终的图是简单图。所有随机性必须由给定的种子控制。\n2. 在无向无权图中，使用基于最短路径的介数中心性计算所有节点的初始负载 $L_i$。为提高效率，使用基于广度优先搜索（BFS）的Brandes算法。\n3. 对于移除比例 $f = 0.01$（即度最高的 $1\\%$ 中心节点），移除度最高的 $r = \\max(1, \\lfloor fN \\rfloor)$ 个节点。为一系列容忍参数 $\\alpha \\in \\{0.0, 0.1, \\dots, 1.0\\}$ 模拟过载级联，过程如下：\n   - 使用移除前的负载 $L_i$ 固定容量 $C_i = (1+\\alpha)L_i$。\n   - 移除中心节点后，在剩余网络上重新计算负载。任何负载 $L_i^{\\text{new}} > C_i$ 的节点 $i$ 将失效并被移除。重复此过程，直到没有新的失效发生。\n   - 记录级联规模，即除最初移除节点外失效的节点所占的比例（以小数形式）。\n4. 将稳定性的临界容忍度 $\\alpha_c$ 定义为测试集合中使得级联规模小于或等于给定小数阈值 $\\theta$ 的最小 $\\alpha$ 值（例如，$\\theta = 0.01$ 表示最多有 $1\\%$ 的额外节点失效）。如果没有测试的 $\\alpha$ 满足稳定性条件，则返回 $-1.0$。\n\n测试套件：\n对于每个测试用例，仅报告计算出的 $\\alpha_c$（作为浮点数）。使用以下参数集：\n- 测试用例1：$N=200$, $k_{\\min}=2$, $k_{\\max}=25$, seed $=42$, $\\theta=0.02$。\n- 测试用例2（边界条件：严格稳定性）：$N=80$, $k_{\\min}=2$, $k_{\\max}=15$, seed $=123$, $\\theta=0.00$。\n- 测试用例3（边缘情况：更高异质性）：$N=150$, $k_{\\min}=3$, $k_{\\max}=30$, seed $=7$, $\\theta=0.01$。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含三个结果，格式为方括号内的逗号分隔列表，顺序为 $[\\alpha_c^{(1)}, \\alpha_c^{(2)}, \\alpha_c^{(3)}]$，其中每个 $\\alpha_c^{(j)}$ 是一个保留三位小数的浮点数。不应打印任何其他文本。",
            "solution": "其基础是无标度度分布和负载-容量级联模型。一个无标度网络的度分布为 $P(k) \\propto k^{-\\gamma}$，其中 $\\gamma = 2.4$，截断于 $k \\in [k_{\\min}, k_{\\max}]$。为了生成度序列，我们对连续截断幂律分布使用逆变换采样法。对于 $\\gamma \\neq 1$，在 $[k_{\\min}, k_{\\max}]$ 上的截断连续幂律的累积分布函数为\n$$\nF(k) = \\frac{k^{1-\\gamma} - k_{\\min}^{1-\\gamma}}{k_{\\max}^{1-\\gamma} - k_{\\min}^{1-\\gamma}}.\n$$\n如果 $u \\sim \\text{Uniform}(0, 1)$，对 $F$ 求逆可得\n$$\nk(u) = \\left(u \\left(k_{\\max}^{1-\\gamma} - k_{\\min}^{1-\\gamma}\\right) + k_{\\min}^{1-\\gamma} \\right)^{\\frac{1}{1-\\gamma}}.\n$$\n我们抽取 $N$ 个样本 $k(u)$，将它们四舍五入为整数，强制 $k \\geq k_{\\min}$ 且 $k \\leq k_{\\max}$，并调整总和的奇偶性以确保度之和为偶数。配置模型通过随机均匀地配对度的“末端”来构建一个随机多重图。为获得一个适合最短路径计算的简单图，我们移除自环并合并平行边，从而得到一个使用邻接表存储唯一邻居的无向简单图。\n\n负载由无向无权图中的介数中心性定义，它衡量了通过一个节点的所有最短路径的比例。Brandes算法可以高效地计算介数。对于每个源节点 $s$，执行一次广度优先搜索（BFS）以获得从 $s$ 到所有 $v$ 的距离 $d_s(v)$ 和最短路径计数 $\\sigma_s(v)$。维护前驱节点列表以了解在从 $s$ 出发的最短路径上哪些节点在 $w$ 之前。然后使用以下公式反向累积依赖性 $\\delta_s(v)$\n$$\n\\delta_s(v) = \\sum_{w: v \\in \\text{pred}_s(w)} \\frac{\\sigma_s(v)}{\\sigma_s(w)} \\left(1 + \\delta_s(w)\\right),\n$$\n并更新介数\n$$\nL(v) \\mathrel{+}= \\delta_s(v)\n$$\n对于 $v \\neq s$。对于无向图，最后将累积值除以 $2$ 以避免重复计算，从而得到负载 $L(v)$（即介数中心性）。\n\n容量模型为 $C_i = (1+\\alpha)L_i$，其中 $L_i$ 是在移除节点前计算的。这种固定的容量反映了与初始负载成比例的设计容忍度。为了探究在蓄意攻击下的脆弱性，我们移除度数最高的一部分节点，比例为 $f = 0.01$，即 $r = \\max(1, \\lfloor fN \\rfloor)$ 个中心节点。移除后，在剩余的图上重新计算负载。任何当前负载 $L_i^{\\text{new}}$ 超过其容量 $C_i$ 的节点 $i$ 都会失效并被移除。这个过程是迭代的：在每个移除步骤之后，重新计算负载并应用失效标准，直到没有新的节点失效为止。\n\n级联规模是除最初移除的节点外，因过载而失效的节点所占的比例（一个小数）：如果 $F_{\\text{extra}}$ 是由过载引起的失效节点数量，则级联规模为 $F_{\\text{extra}}/N$。为了将级联规模映射为 $\\alpha$ 的函数，我们在预定义的网格 $\\{0.0, 0.1, \\dots, 1.0\\}$ 上评估 $\\alpha$，为每个 $\\alpha$ 模拟级联过程，并记录级联规模。临界容忍度 $\\alpha_c$ 定义为该网格上使得级联规模小于或等于每个测试用例指定的阈值 $\\theta$ 的最小 $\\alpha$ 值。如果没有 $\\alpha$ 满足此标准，则将 $\\alpha_c$ 设为 $-1.0$，表示在测试范围内未达到稳定性。\n\n算法设计：\n- 度序列：使用逆变换采样获得与 $\\gamma = 2.4$ 一致的重尾分布，并截断到 $[k_{\\min}, k_{\\max}]$。调整度之和为偶数。这为配置模型生成了末端。\n- 图构建：随机配对末端。丢弃自环并合并多重边以强制简单性。将邻接表构建为集合以移除重复项，然后转换为列表以便迭代。\n- 负载计算：使用队列实现带有广度优先搜索（BFS）的Brandes算法。对于每个活动的源节点 $s$，维护距离 $d$、最短路径计数 $\\sigma$、前驱节点列表、用于跟踪遍历顺序的栈和依赖性 $\\delta$ 的数组。在每个源的累积过程结束时更新介数，对于无向图则除以 $2$。\n- 级联模拟：对于网格上的每个 $\\alpha$，根据初始负载计算一次容量。移除度最高的 $r$ 个中心节点。在活动的子图上迭代地重新计算负载，并移除负载超过容量的节点，直到收敛。记录级联规模 $F_{\\text{extra}}/N$。\n- 临界容忍度：扫描记录的级联规模，并选择其级联规模 $\\leq \\theta$ 的最小 $\\alpha$。如果没有可接受的值，则输出 $-1.0$。\n- 测试套件覆盖范围：选择三个案例来探究典型行为（中等网络规模）、严格稳定性要求（只有零级联才可接受的边界情况）和更高异质性（具有较大 $k_{\\max}$ 的边缘情况）。所有结果都以保留三位小数的浮点数形式报告在一个列表中。\n\n该方法从无标度网络和介数中心性的核心定义逻辑推导而来，将经过充分测试的用于最短路径的Brandes算法与基于容量的过载规则相结合，并为蓄意中心节点移除下的鲁棒性分析生成可量化的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef sample_truncated_power_law(N, gamma, k_min, k_max, rng):\n    \"\"\"\n    Sample N degrees from a truncated continuous power-law distribution\n    with exponent gamma over [k_min, k_max], then round to integers and clamp.\n    Ensure the sum of degrees is even.\n    \"\"\"\n    # Inverse CDF sampling for continuous truncated power law\n    # F(k) = (k^(1-gamma) - k_min^(1-gamma)) / (k_max^(1-gamma) - k_min^(1-gamma))\n    # Inversion: k = [u*(k_max^(1-gamma)-k_min^(1-gamma)) + k_min^(1-gamma)]^(1/(1-gamma))\n    a = k_min ** (1.0 - gamma)\n    b = k_max ** (1.0 - gamma)\n    u = rng.random(N)\n    ks = (u * (b - a) + a) ** (1.0 / (1.0 - gamma))\n    # Round and clamp\n    degs = np.clip(np.rint(ks).astype(int), k_min, k_max)\n    # Ensure sum of degrees is even\n    total = degs.sum()\n    if total % 2 != 0:\n        # Adjust one random element within bounds to fix parity\n        idxs = np.where((degs > k_min)  (degs  k_max))[0]\n        if idxs.size == 0:\n            # If all at bounds, flip one element between k_min and k_max\n            # to fix parity; choose a random index and toggle by +1 if possible, else -1\n            i = rng.integers(0, N)\n            if degs[i]  k_max:\n                degs[i] += 1\n            else:\n                degs[i] -= 1\n        else:\n            i = rng.choice(idxs)\n            # Toggle parity by adding 1 (stay within bounds)\n            degs[i] += 1\n    return degs.tolist()\n\ndef configuration_model_simple_graph(degrees, rng):\n    \"\"\"\n    Build a graph from the degree sequence via the configuration model,\n    then remove self-loops and collapse multi-edges to create a simple undirected graph.\n    Returns adjacency lists (list of lists).\n    \"\"\"\n    N = len(degrees)\n    stubs = []\n    for i, k in enumerate(degrees):\n        stubs.extend([i] * k)\n    rng.shuffle(stubs)\n\n    # Pair stubs\n    edges = []\n    # If odd number of stubs, drop the last one\n    pair_count = len(stubs) // 2\n    for p in range(pair_count):\n        u = stubs[2 * p]\n        v = stubs[2 * p + 1]\n        if u != v:\n            edges.append((u, v))\n        # self-loops are ignored here\n\n    # Build adjacency sets to collapse multi-edges\n    adj_sets = [set() for _ in range(N)]\n    for u, v in edges:\n        if u == v:\n            continue\n        adj_sets[u].add(v)\n        adj_sets[v].add(u)\n\n    # Convert to lists\n    adj = [list(neigh) for neigh in adj_sets]\n    return adj\n\ndef betweenness_centrality_undirected(adj, active_mask):\n    \"\"\"\n    Compute betweenness centrality for an undirected, unweighted graph\n    using Brandes algorithm. Nodes not active (active_mask[i] == False)\n    are considered removed; paths cannot go through them or start from them.\n    \"\"\"\n    N = len(adj)\n    BC = [0.0] * N\n    for s in range(N):\n        if not active_mask[s]:\n            continue\n        # Initialization\n        stack = []\n        pred = [[] for _ in range(N)]\n        sigma = [0] * N  # number of shortest paths from s\n        dist = [-1] * N  # distance from s\n        sigma[s] = 1\n        dist[s] = 0\n        Q = deque([s])\n        # BFS\n        while Q:\n            v = Q.popleft()\n            stack.append(v)\n            for w in adj[v]:\n                if not active_mask[w]:\n                    continue\n                if dist[w]  0:\n                    dist[w] = dist[v] + 1\n                    Q.append(w)\n                if dist[w] == dist[v] + 1:\n                    sigma[w] += sigma[v]\n                    pred[w].append(v)\n        # Accumulation\n        delta = [0.0] * N\n        while stack:\n            w = stack.pop()\n            # Avoid division by zero if sigma[w] == 0 (disconnected)\n            sw = sigma[w]\n            if sw > 0:\n                coef = 1.0 + delta[w]\n                for v in pred[w]:\n                    delta[v] += (sigma[v] / sw) * coef\n            if w != s:\n                BC[w] += delta[w]\n    # For undirected graphs, divide by 2 to correct double-counting\n    for i in range(N):\n        BC[i] *= 0.5\n    return BC\n\ndef degrees_from_adj(adj):\n    return [len(neigh) for neigh in adj]\n\ndef simulate_cascade(adj, initial_loads, alpha, removal_fraction=0.01):\n    \"\"\"\n    Simulate the overload cascade after removing the top hubs by degree.\n    initial_loads: betweenness centrality on the full pre-removal graph.\n    alpha: tolerance parameter; capacity C_i = (1 + alpha) * initial_loads[i].\n    removal_fraction: fraction of top-degree nodes to remove initially.\n    Returns cascade size (fraction of extra failures beyond initial removal).\n    \"\"\"\n    N = len(adj)\n    capacities = [ (1.0 + alpha) * L for L in initial_loads ]\n    degs = degrees_from_adj(adj)\n    r = max(1, int(np.floor(removal_fraction * N)))\n    # Get indices sorted by degree descending\n    hub_order = sorted(range(N), key=lambda i: degs[i], reverse=True)\n    initial_fail = set(hub_order[:r])\n\n    active = [True] * N\n    for i in initial_fail:\n        active[i] = False\n\n    extra_failed_count = 0\n\n    while True:\n        # Compute loads on the current active subgraph\n        loads_new = betweenness_centrality_undirected(adj, active)\n        # Identify overloads\n        to_fail = []\n        for i in range(N):\n            if not active[i]:\n                continue\n            if loads_new[i] > capacities[i] + 1e-12:\n                to_fail.append(i)\n        if not to_fail:\n            break\n        for i in to_fail:\n            active[i] = False\n        extra_failed_count += len(to_fail)\n\n    cascade_fraction = extra_failed_count / N\n    return cascade_fraction\n\ndef compute_alpha_c(adj, alpha_values, threshold, removal_fraction=0.01):\n    \"\"\"\n    Compute initial loads and evaluate cascade across alpha_values.\n    Return the smallest alpha whose cascade size = threshold.\n    If none, return -1.0.\n    \"\"\"\n    N = len(adj)\n    active_full = [True] * N\n    initial_loads = betweenness_centrality_undirected(adj, active_full)\n\n    alpha_c = None\n    for alpha in alpha_values:\n        size = simulate_cascade(adj, initial_loads, alpha, removal_fraction=removal_fraction)\n        if size = threshold:\n            alpha_c = alpha\n            break\n    if alpha_c is None:\n        return -1.0\n    return alpha_c\n\ndef build_scale_free_graph(N, gamma, k_min, k_max, seed):\n    rng = np.random.default_rng(seed)\n    degrees = sample_truncated_power_law(N, gamma, k_min, k_max, rng)\n    adj = configuration_model_simple_graph(degrees, rng)\n    return adj\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, k_min, k_max, seed, threshold)\n    test_cases = [\n        (200, 2, 25, 42, 0.02),   # Test Case 1: happy path\n        (80,  2, 15, 123, 0.00),  # Test Case 2: boundary strict stability\n        (150, 3, 30, 7,  0.01),   # Test Case 3: edge case higher heterogeneity\n    ]\n\n    gamma = 2.4\n    alpha_values = [round(0.1 * i, 1) for i in range(11)]  # 0.0 to 1.0 inclusive\n\n    results = []\n    for N, k_min, k_max, seed, theta in test_cases:\n        adj = build_scale_free_graph(N, gamma, k_min, k_max, seed)\n        alpha_c = compute_alpha_c(adj, alpha_values, threshold=theta, removal_fraction=0.01)\n        # Round to three decimals\n        results.append(f\"{alpha_c:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}