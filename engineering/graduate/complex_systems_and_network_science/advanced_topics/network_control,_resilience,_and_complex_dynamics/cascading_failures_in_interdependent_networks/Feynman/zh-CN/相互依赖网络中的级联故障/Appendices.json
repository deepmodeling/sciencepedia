{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握级联失效的动态过程，我们的第一个练习是在一个定义明确的小型系统上手动追踪整个过程。这个实践通过展示失效如何在网络连通性和相互依赖关系的相互作用下逐步传播，从而揭开抽象规则的神秘面纱。通过完成这个例子 ，您将为理解崩溃的迭代本质建立起具体的直觉。",
            "id": "4266384",
            "problem": "考虑两个无向网络 $A$ 和 $B$，它们通过双向的一对一依赖对相互依赖。设节点集合为 $A=\\{a_1,a_2,a_3,a_4,a_5,a_6\\}$ 和 $B=\\{b_1,b_2,b_3,b_4,b_5,b_6,b_7\\}$。边集合为\n$$\nE_A=\\{(a_1,a_2),(a_2,a_3),(a_3,a_4),(a_1,a_3),(a_5,a_6)\\}\n$$\n和\n$$\nE_B=\\{(b_1,b_2),(b_2,b_3),(b_1,b_3),(b_4,b_5),(b_5,b_6),(b_6,b_7)\\}.\n$$\n相互依赖关系由双向依赖集合指定\n$$\nD=\\{(a_1,b_2),(a_2,b_3),(a_3,b_1),(a_4,b_4),(a_5,b_5),(a_6,b_6)\\},\n$$\n因此对于每个 $(a_i,b_j)\\in D$，都有一个对应的 $(b_j,a_i)\\in D$。节点 $b_7$ 没有依赖伙伴，是自治节点。\n\n连锁失效动力学定义如下，从网络 $A$ 中的一个初始移除开始。在给定阶段，一个节点是功能正常的，当且仅当以下两个条件都成立：它属于其自身网络当前活动子图的最大连通分量 (LCC)，并且，如果它在另一个网络中有依赖伙伴，该伙伴也必须是功能正常的。该过程是单调的：一旦一个节点变为非功能性，它将保持非功能性。定义 $S_A^{(t)}$ 和 $S_B^{(t)}$ 分别为经过 $t$ 个完整连锁失效轮次后网络 $A$ 和 $B$ 中的功能节点集合，其中 $t\\in\\mathbb{N}_0$。初始化为 $S_A^{(0)}=A\\setminus R$ 和 $S_B^{(0)}=B$，其中初始移除集合为 $R=\\{a_2\\}$。一个完整的连锁失效轮次由以下步骤序列组成：\n- 计算由 $S_A^{(t)}$ 在 $A$ 中诱导的子图的LCC；移除 $A$ 中所有不在此LCC中的节点，得到中间活动集 $S_{A,\\mathrm{LCC}}^{(t)}$。\n- 将依赖关系传播到 $B$：从 $S_B^{(t)}$ 中移除其在 $A$ 中的依赖伙伴不在 $S_{A,\\mathrm{LCC}}^{(t)}$ 内的任何 $B$ 中节点，得到 $S_{B,\\mathrm{dep}}^{(t)}$。\n- 计算由 $S_{B,\\mathrm{dep}}^{(t)}$ 在 $B$ 中诱导的子图的LCC；移除 $B$ 中所有不在此LCC中的节点，得到 $S_B^{(t+1)}$。\n- 将依赖关系传播到 $A$：从 $S_{A,\\mathrm{LCC}}^{(t)}$ 中移除其在 $B$ 中的依赖伙伴不在 $S_B^{(t+1)}$ 内的任何 $A$ 中节点，然后取 $A$ 中剩余子图的LCC；结果为 $S_A^{(t+1)}$。\n\n假设最大连通分量大小的平局通过确定性方式打破，即选择在映射 $a_i\\mapsto i$ 和 $b_j\\mapsto j$ 下节点标签总和最小的分量。从指定的 $R=\\{a_2\\}$ 开始，执行恰好 $2$ 个完整的连锁失效轮次。将基数 $|S_A^{(2)}|$ 和 $|S_B^{(2)}|$ 作为最终答案报告，格式化为行矩阵。无需四舍五入。",
            "solution": "该问题描述了两个相互依赖的网络 $A$ 和 $B$ 上的连锁失效过程。我们需要模拟此过程两个完整轮次，并确定每个网络中幸存节点的数量。\n\n### 问题验证\n**步骤 1：提取已知条件**\n- 网络 $A$ 的节点集合：$A=\\{a_1, a_2, a_3, a_4, a_5, a_6\\}$\n- 网络 $A$ 的边集合：$E_A=\\{(a_1,a_2),(a_2,a_3),(a_3,a_4),(a_1,a_3),(a_5,a_6)\\}$\n- 网络 $B$ 的节点集合：$B=\\{b_1,b_2,b_3,b_4,b_5,b_6,b_7\\}$\n- 网络 $B$ 的边集合：$E_B=\\{(b_1,b_2),(b_2,b_3),(b_1,b_3),(b_4,b_5),(b_5,b_6),(b_6,b_7)\\}$\n- 双向依赖集合：$D=\\{(a_1,b_2),(a_2,b_3),(a_3,b_1),(a_4,b_4),(a_5,b_5),(a_6,b_6)\\}$\n- 自治节点：$b_7$\n- 初始移除集合：$R=\\{a_2\\}$\n- 初始功能集合：$S_A^{(0)}=A\\setminus R$ 和 $S_B^{(0)}=B$。\n- 连锁失效动力学：从时间 $t$ 到 $t+1$ 的一个完整轮次由四个操作序列定义：\n  1. 找到由 $S_A^{(t)}$ 诱导的子图的最大连通分量 (LCC)，得到 $S_{A,\\mathrm{LCC}}^{(t)}$。\n  2. 从 $S_B^{(t)}$ 中移除其依赖伙伴不在 $S_{A,\\mathrm{LCC}}^{(t)}$ 中的节点，得到 $S_{B,\\mathrm{dep}}^{(t)}$。\n  3. 找到由 $S_{B,\\mathrm{dep}}^{(t)}$ 诱导的子图的LCC，得到 $S_B^{(t+1)}$。\n  4. 从 $S_{A,\\mathrm{LCC}}^{(t)}$ 中移除其依赖伙伴不在 $S_B^{(t+1)}$ 中的节点，然后找到剩余子图的LCC，得到 $S_A^{(t+1)}$。\n- LCC的平局打破规则：选择节点索引总和最小的分量。\n- 任务：报告 $|S_A^{(2)}|$ 和 $|S_B^{(2)}|$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，描述了网络科学中的一个著名模型。这是一个适定问题，所有组成部分（网络、依赖关系、初始条件、动力学和打破平局规则）都得到了清晰明确的定义，确保了唯一、确定性的结果。问题是客观且可形式化的。其设置是完整和一致的，没有任何矛盾或信息缺失。它需要进行程序化模拟，这使其具有一定挑战性。\n\n**步骤 3：结论与行动**\n问题有效。将提供完整的解决方案。\n\n### 解答\n我们将分步模拟两个轮次的连锁失效过程。\n\n**初始状态 ($t=0$)**\n该过程从网络 $A$ 中移除节点 $a_2$ 开始。\n网络 $A$ 中的初始功能节点集合是 $S_A^{(0)} = A \\setminus \\{a_2\\} = \\{a_1, a_3, a_4, a_5, a_6\\}$。\n网络 $B$ 中的初始功能节点集合是 $S_B^{(0)} = B = \\{b_1, b_2, b_3, b_4, b_5, b_6, b_7\\}$。\n\n**连锁失效第 1 轮 ($t=0 \\to t=1$)**\n1.  **网络A中的LCC：** 我们考虑由 $S_A^{(0)} = \\{a_1, a_3, a_4, a_5, a_6\\}$ 诱导的 $A$ 的子图。该子图内来自 $E_A$ 的边为 $(a_1, a_3)$、$(a_3, a_4)$ 和 $(a_5, a_6)$。此子图有两个连通分量：大小为3的 $C_{A,1} = \\{a_1, a_3, a_4\\}$ 和大小为2的 $C_{A,2} = \\{a_5, a_6\\}$。最大连通分量 (LCC) 是 $C_{A,1}$。因此，此分量之外的节点失效。$A$ 中的中间功能节点集为 $S_{A,\\mathrm{LCC}}^{(0)} = \\{a_1, a_3, a_4\\}$。\n\n2.  **依赖关系传播到网络B：** 如果 $B$ 中某个节点在 $A$ 中的依赖伙伴不再是功能性的，则该节点失效。现在 $A$ 中所有失效节点的集合是 $\\{a_2\\}$ (初始移除) 和 $\\{a_5, a_6\\}$ (因LCC隔离)。它们在 $B$ 中的依赖伙伴分别是 $\\{b_3\\}$、$\\{b_5\\}$ 和 $\\{b_6\\}$。我们从 $S_B^{(0)}$ 中移除这些节点。\n    $B$ 中的中间功能节点集为 $S_{B,\\mathrm{dep}}^{(0)} = S_B^{(0)} \\setminus \\{b_3, b_5, b_6\\} = \\{b_1, b_2, b_4, b_7\\}$。\n\n3.  **网络B中的LCC：** 我们找到由 $S_{B,\\mathrm{dep}}^{(0)} = \\{b_1, b_2, b_4, b_7\\}$ 诱导的 $B$ 的子图的LCC。该子图内来自 $E_B$ 的唯一边是 $(b_1, b_2)$。这形成了三个连通分量：大小为2的 $C_{B,1}=\\{b_1, b_2\\}$，大小为1的 $C_{B,2}=\\{b_4\\}$，以及大小为1的 $C_{B,3}=\\{b_7\\}$。LCC是 $C_{B,1}$。这定义了下一轮的功能集：$S_B^{(1)} = \\{b_1, b_2\\}$。\n\n4.  **依赖关系传播到网络A及最终LCC：** 我们从集合 $S_{A,\\mathrm{LCC}}^{(0)} = \\{a_1, a_3, a_4\\}$ 开始，并移除其依赖伙伴不在 $S_B^{(1)} = \\{b_1, b_2\\}$ 中的任何节点。\n    - $a_1$ 的伙伴是 $b_2$，且 $b_2 \\in S_B^{(1)}$。所以 $a_1$ 保留。\n    - $a_3$ 的伙伴是 $b_1$，且 $b_1 \\in S_B^{(1)}$。所以 $a_3$ 保留。\n    - $a_4$ 的伙伴是 $b_4$，且 $b_4 \\notin S_B^{(1)}$。所以 $a_4$ 失效。\n    剩余节点集为 $\\{a_1, a_3\\}$。我们现在必须找到由这些节点诱导的子图的LCC。由于边 $(a_1, a_3) \\in E_A$，该子图是连通的。因此，其LCC就是该集合本身。\n    这定义了下一轮的功能集：$S_A^{(1)} = \\{a_1, a_3\\}$。\n\n在第1轮结束时，功能集为 $S_A^{(1)} = \\{a_1, a_3\\}$ 和 $S_B^{(1)} = \\{b_1, b_2\\}$。\n\n**连锁失效第 2 轮 ($t=1 \\to t=2$)**\n我们从功能集 $S_A^{(1)} = \\{a_1, a_3\\}$ 和 $S_B^{(1)} = \\{b_1, b_2\\}$ 开始。\n\n1.  **网络A中的LCC：** 由 $S_A^{(1)}$ 诱导的子图由于边 $(a_1, a_3)$ 的存在是连通的。LCC就是该集合本身。所以，$S_{A,\\mathrm{LCC}}^{(1)} = \\{a_1, a_3\\}$。\n\n2.  **依赖关系传播到网络B：** 我们检查 $S_B^{(1)} = \\{b_1, b_2}\\}$ 中节点的依赖伙伴。\n    - $b_1$ 的伙伴是 $a_3$，它在 $S_{A,\\mathrm{LCC}}^{(1)}$ 中。所以 $b_1$ 保留。\n    - $b_2$ 的伙伴是 $a_1$，它在 $S_{A,\\mathrm{LCC}}^{(1)}$ 中。所以 $b_2$ 保留。\n    没有节点因依赖关系失效。中间集为 $S_{B,\\mathrm{dep}}^{(1)} = \\{b_1, b_2\\}$。\n\n3.  **网络B中的LCC：** 由 $S_{B,\\mathrm{dep}}^{(1)} = \\{b_1, b_2\\}$ 诱导的子图由于边 $(b_1, b_2)$ 的存在是连通的。LCC就是该集合本身。因此，$S_B^{(2)} = \\{b_1, b_2\\}$。\n\n4.  **依赖关系传播到网络A及最终LCC：** 我们从 $S_{A,\\mathrm{LCC}}^{(1)} = \\{a_1, a_3\\}$ 开始，并根据 $S_B^{(2)} = \\{b_1, b_2\\}$ 检查依赖关系。\n    - $a_1$ 的伙伴是 $b_2 \\in S_B^{(2)}$。所以 $a_1$ 保留。\n    - $a_3$ 的伙伴是 $b_1 \\in S_B^{(2)}$。所以 $a_3$ 保留。\n    没有节点因依赖关系失效。剩余集合为 $\\{a_1, a_3\\}$。由该集合诱导的子图是连通的，所以其LCC就是该集合本身。\n    因此，$S_A^{(2)} = \\{a_1, a_3\\}$。\n\n两轮过后，系统已稳定，功能集为 $S_A^{(2)} = S_A^{(1)} = \\{a_1, a_3\\}$ 和 $S_B^{(2)} = S_B^{(1)} = \\{b_1, b_2\\}$。\n基数分别为 $|S_A^{(2)}| = 2$ 和 $|S_B^{(2)}| = 2$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 2 & 2 \\end{pmatrix}}$$"
        },
        {
            "introduction": "相互依赖网络以其突然的、不连续的崩溃而著称，这是一个关键的理论发现。这个练习  将该理论与一个实际挑战联系起来：找到瓦解一个网络的最高效方式。通过要求您识别出能触发整个系统崩溃的最小节点集合，本练习将磨练您的分析能力。",
            "id": "4266428",
            "problem": "考虑两个完全相互依赖的网络，标记为 $A$ 和 $B$，它们通过在包含 $N$ 个节点的相同集合上的一对一双向依赖映射进行耦合。网络 $A$ 中存在的一个节点依赖于网络 $B$ 中的唯一一个对应节点（反之亦然），并且一个节点是功能性的，当且仅当它存在并且属于其自身网络中功能节点集合内的最大连通分量（巨分量）。将相互巨分量 (MGC) 定义为在级联过程稳定后，在两个网络中都保持功能性的节点集合。设 $P_{\\infty}(p)$ 表示在网络 $A$ 中随机初始移除比例为 $1-p$ 的节点（依赖映射会随之移除网络 $B$ 中的相应节点），并在级联的每个阶段对不属于其网络巨分量的节点进行迭代剪枝后，MGC 中节点的比例。\n\n第一部分（无限大尺寸理论）：假设网络 $A$ 是一个平均度为 $z_A$ 的 Erdős–Rényi (ER) 随机图 $G(N, z_A/N)$，网络 $B$ 是一个平均度为 $z_B$ 的 ER 随机图 $G(N, z_B/N)$，且 $N \\to \\infty$。从 ER 随机图的局部树状属性和随机图上点渗流的概率生成函数方法出发，推导出关于 $p$、$z_A$ 和 $z_B$ 的 $P_{\\infty}(p)$ 的封闭不动点关系式。仅使用此关系式和标准分岔分析，通过证明临界点 $(p_c, P_{\\infty}(p_c))$ 是由一个在非零 $P_{\\infty}(p_c)$ 处的相切条件所确定的，来论证相互依赖网络对中的渗流相变是不连续的。给出定义临界点的显式方程，并解释为什么当 $p$ 减小并经过 $p_c$ 时，这些方程意味着 $P_{\\infty}$ 会发生不连续的下降。\n\n第二部分（有限玩具ER对与割集分析）：考虑一个玩具实例，其中有 $N=6$ 个标记为 $\\{1,2,3,4,5,6\\}$ 的节点，以及一对一的依赖关系 $i \\leftrightarrow i$。网络 $A$ 和 $B$ 是在这 $6$ 个节点上相同的 ER 样本，由以下无向边指定：\n- 在网络 $A$ 中：边集为 $\\{(1,2), (2,3), (1,3), (3,4), (4,5), (5,6), (4,6)\\}$。\n- 在网络 $B$ 中：边集与 $A$ 相同。\n\n在进行任何移除之前，请验证 MGC 包含所有 6 个节点。设一个节点移除割集 $S \\subset \\{1,2,3,4,5,6\\}$ 触发了如上所述的相互依赖级联。确定最小基数 $k^{\\star} = |S|$，使得存在一个大小为 $k^{\\star}$ 的 $S$ 的选择，在级联稳定后，存活节点中的每个相互连通分量的大小最多为 $2$。使用一个考虑了相互依赖性的割集论证，来证明其可行性（存在一个大小为 $k^{\\star}$ 的 $S$）和最小性（没有更小的 $|S|$ 能达到相同的结果）。将单个整数 $k^{\\star}$ 作为最终答案。无需四舍五入。",
            "solution": "这个问题包含两部分。第一部分要求在热力学极限 ($N \\to \\infty$)下，对一个由两个相互依赖的 Erdős–Rényi (ER) 网络组成的系统，推导并分析其渗流相变。第二部分要求分析一个具体的、有限的玩具例子。\n\n**第一部分：无限大尺寸理论**\n\n系统的状态由 $P_{\\infty}$ 表征，即属于相互巨分量 (MGC) 的节点比例。一个节点在 MGC 中，如果它在初始的随机节点移除中存活下来，并且同时是网络 $A$ 和网络 $B$ 中巨分量的一部分，而这些巨分量本身是由属于 MGC 的节点构成的。\n\n设 $P_{\\infty}$ 是 MGC 中的节点比例。一个节点要成为 MGC 的一部分，它必须是功能性的。功能节点的集合恰好就是 MGC。因此，在最终稳态下，网络 $A$ 和网络 $B$ 都有效地定义在一个节点基底上，其中每个节点以概率 $P_{\\infty}$ 存在。\n\n让我们定义 $f_A(P_{\\infty})$ 为从 MGC 中随机选择的一个节点属于网络 $A$ 的巨分量（该巨分量被限制在 MGC 内）的概率。在一个 ER 图 $G(N, z/N)$ 中，如果节点以概率 $x$ 被占据，则一个节点属于巨分量的概率是 $1-u$，其中 $u$ 是该节点不与巨分量相连的概率。这个概率 $u$ 满足自洽方程 $u = G_0(1 - x(1-u))$，其中 $G_0(s)$ 是度分布的生成函数。对于 ER 图，度分布是平均值为 $z$ 的泊松分布，所以 $G_0(s) = \\exp(z(s-1))$。\n\n在我们的情况中，网络被限制在 MGC 上，所以有效占据概率是 $P_{\\infty}$。MGC 内的一个节点必须通过其他 MGC 节点连接到 A 的巨分量。一个节点连接到 MGC 中的 A-分量的概率 $f_A(P_{\\infty})$ 满足 $f_A(P_{\\infty}) = 1-q_A$，其中 $q_A$ 是它未连接的概率。如果一个节点的所有路径都通向有限大小的分量，则它不与 A 的巨分量相连。MGC 中的一个节点不属于 A-巨分量的概率 $q_A$ 由以下方程的解给出：\n$$q_A = \\exp[z_A P_{\\infty} (q_A - 1)]$$\n代入 $q_A = 1 - f_A(P_{\\infty})$，我们得到一个关于 $f_A(P_{\\infty})$ 的隐式方程：\n$$1 - f_A(P_{\\infty}) = \\exp[z_A P_{\\infty} (1 - f_A(P_{\\infty}) - 1)] = \\exp[-z_A P_{\\infty} f_A(P_{\\infty})]$$\n类似地，对于网络 $B$，设 $f_B(P_{\\infty})$ 为 MGC 中的一个节点属于网络 $B$ 的巨分量的概率。它满足：\n$$1 - f_B(P_{\\infty}) = \\exp[-z_B P_{\\infty} f_B(P_{\\infty})]$$\n现在，一个节点要存在于 MGC 中，必须满足三个条件：\n$1$。它必须在初始攻击中未被移除（概率为 $p$）。\n$2$。它必须连接到网络 $A$ 的巨分量（概率为 $f_A(P_{\\infty})$）。\n$3$。它必须连接到网络 $B$ 的巨分量（概率为 $f_B(P_{\\infty})$）。\n\n由于网络 $A$ 和网络 $B$ 的拓扑结构是独立的，因此连接到各自巨分量的事件是独立的。因此，我们可以将它们的概率相乘。$P_{\\infty}$ 的自洽方程是：\n$$P_{\\infty} = p \\cdot f_A(P_{\\infty}) \\cdot f_B(P_{\\infty})$$\n这构成了 $P_{\\infty}$ 的封闭不动点关系式。这是一个隐式方程，因为 $f_A$ 和 $f_B$ 本身都依赖于 $P_{\\infty}$。我们定义函数 $F(P_{\\infty}) = p \\cdot f_A(P_{\\infty}) \\cdot f_B(P_{\\infty})$。MGC 大小的解就是不动点 $P_{\\infty} = F(P_{\\infty})$。\n\n为了分析相变的性质，我们研究函数 $F(P_{\\infty})$。\n首先，注意到 $P_{\\infty} = 0$ 总是一个解，因为 $f_A(0)=0$ 且 $f_B(0)=0$，这意味着 $F(0)=0$。\n接下来，我们分析 $F(P_{\\infty})$ 在 $P_{\\infty}=0$ 处的导数。$f_A(P_{\\infty})$ 关于 $P_{\\infty}$ 的导数可以通过对 $1 - f_A = \\exp[-z_A P_{\\infty} f_A]$ 进行隐式微分得到：\n$$-f_A' = \\exp[-z_A P_{\\infty} f_A] \\cdot (-z_A (f_A + P_{\\infty} f_A')) = (1 - f_A)(-z_A f_A - z_A P_{\\infty} f_A')$$\n$$f_A' (z_A P_{\\infty} (1-f_A) - 1) = z_A f_A (1-f_A) \\implies f_A'(P_{\\infty}) = \\frac{z_A f_A(P_{\\infty})(1-f_A(P_{\\infty}))}{1 - z_A P_{\\infty}(1-f_A(P_{\\infty}))}$$\n当 $P_{\\infty} \\to 0$ 时， $f_A(P_{\\infty}) \\to 0$。分子趋近于 $0$。因此，$f_A'(0)=0$。类似地，$f_B'(0)=0$。\n$F(P_{\\infty})$ 的导数是 $F'(P_{\\infty}) = p [ f_A'(P_{\\infty})f_B(P_{\\infty}) + f_A(P_{\\infty})f_B'(P_{\\infty}) ]$。\n在 $P_{\\infty}=0$ 处，我们有 $F'(0) = p [f_A'(0)f_B(0) + f_A(0)f_B'(0)] = p [0 \\cdot 0 + 0 \\cdot 0] = 0$。\n\n由于 $F(0)=0$ 和 $F'(0)=0$，曲线 $y=F(P_{\\infty})$ 在原点总是与 $P_{\\infty}$ 轴相切。这意味着对于任何 $p$，该曲线都从直线 $y=P_{\\infty}$ 的下方开始。一个连续（二阶）相变，它将对应于一个从 $P_{\\infty}=0$ 连续出现的非零解，需要满足 $F'(0) \\ge 1$。由于情况并非如此，所以相变不可能是连续的。\n\n一个非平凡解（$P_{\\infty} > 0$）只有在 S 形曲线 $y=F(P_{\\infty})$ 上升到与直线 $y=P_{\\infty}$ 在某个 $P_{\\infty} > 0$ 处相交时才可能存在。非平凡解的出现发生在直线 $y=P_{\\infty}$ 与曲线 $y=F(P_{\\infty})$ 相切时。这个切点定义了临界点 $(p_c, P_{\\infty,c})$。\n相切的条件是：\n$1$。$P_{\\infty,c} = F(P_{\\infty,c}) = p_c f_A(P_{\\infty,c}) f_B(P_{\\infty,c})$ (不动点条件)\n$2$。$1 = F'(P_{\\infty,c}) = p_c [f_A'(P_{\\infty,c})f_B(P_{\\infty,c}) + f_A(P_{\\infty,c})f_B'(P_{\\infty,c})]$ (斜率匹配条件)\n\n使用导数 $f_A'$ 和 $f_B'$ 的表达式，第二个条件变为：\n$$1 = p_c \\left[ \\frac{z_A f_A(1-f_A)}{1 - z_A P_{\\infty,c}(1-f_A)} f_B + f_A \\frac{z_B f_B(1-f_B)}{1 - z_B P_{\\infty,c}(1-f_B)} \\right]$$\n其中所有函数 $f_A, f_B$ 都在 $P_{\\infty,c}$ 处求值。\n由于相切发生在点 $P_{\\infty,c} > 0$ 处，当控制参数 $p$ 降低到临界值 $p_c$ 以下时，非平凡解会突然消失。MGC 的大小从 $P_{\\infty,c}$ 不连续地降至 $0$。这证明了渗流相变是不连续的（一阶）。\n\n**第二部分：有限玩具ER对**\n\n网络 $A$ 和 $B$ 是相同的，定义在节点集 $V=\\{1,2,3,4,5,6\\}$ 上。边集为 $E = \\{(1,2), (2,3), (1,3), (3,4), (4,5), (5,6), (4,6)\\}$。该图由两个三角形 $\\{1,2,3\\}$ 和 $\\{4,5,6\\}$ 组成，它们通过顶点之间的边 $(3,4)$ 连接。网络是完全连通的，因此在进行任何移除之前，MGC 包含所有 6 个节点。\n\n目标是找到移除集 $S$ 的最小基数 $k^{\\star}$，使得所有最终的相互连通分量的大小最多为 $2$。\n\n首先，我们建立 $k^{\\star}$ 的一个下界。\n我们来测试 $k=1$。我们移除单个节点 $v \\in V$ 及其对应节点。\n情况1：$S=\\{1\\}$。剩余节点为 $V'=\\{2,3,4,5,6\\}$。在 $V'$ 上诱导的子图是连通的（例如，通过路径 $2-3-4-5-6$）。因此，在 $A$ 和 $B$ 中，最大连通分量 (LCC) 都是整个集合 $V'$，大小为 5。级联立即停止。最终的 MGC 大小为 5，大于 2。根据对称性，移除 $\\{2\\}$、$\\{5\\}$ 或 $\\{6\\}$ 会得到相同的结果。\n情况2：$S=\\{3\\}$。剩余节点为 $V'=\\{1,2,4,5,6\\}$。在诱导子图中剩余的边是 $\\{(1,2)\\}$ 和 $\\{(4,5), (5,6), (4,6)\\}$。该图有两个连通分量：$\\{1,2\\}$（大小为 2）和 $\\{4,5,6\\}$（大小为 3）。在 $A$ 和 $B$ 中，LCC 都是分量 $\\{4,5,6\\}$。LCC 中的节点集为 $V_{LCC}=\\{4,5,6\\}$。在级联的下一阶段，我们考虑由 $V_{LCC}$ 诱导的子图。这个子图是一个三角形，是连通的。因此，级联稳定下来，最终的 MGC 是 $\\{4,5,6\\}$，大小为 3。这大于 2。根据对称性，移除 $\\{4\\}$ 会得到一个大小为 3 的 MGC（即 $\\{1,2,3\\}$）。\n由于移除任何单个节点都未能将 MGC 分解为大小最多为 2 的分量，我们必须有 $k^{\\star} > 1$。\n\n接下来，我们通过测试 $k=2$ 来建立 $k^{\\star}$ 的一个上界。\n让我们选择割集 $S=\\{3,4\\}$，它针对连接两个三角形的两个中心节点。\n初始移除 $S=\\{3,4\\}$ 后，剩下节点集 $V'=\\{1,2,5,6\\}$。在两个网络中，于 $V'$ 上诱导的子图的边集为 $\\{(1,2), (5,6)\\}$。该图由两个不连通的分量组成：$\\{1,2\\}$ 和 $\\{5,6\\}$。两个分量的大小都为 2。\n根据问题描述，一个节点如果属于最大连通分量，则它是功能性的。在这里，最大尺寸出现了并列，均为 2。因此，属于任何一个 LCC 的所有节点的集合是 $\\{1,2,5,6\\}$。\n设 $LCC_A$ 为 A 在 $V'$ 上的 LCCs 中的节点集合，所以 $LCC_A = \\{1,2,5,6\\}$。类似地，$LCC_B = \\{1,2,5,6\\}$。新的功能节点集是 $V'' = LCC_A \\cap LCC_B = \\{1,2,5,6\\}$。由于 $V''=V'$，级联已经稳定。最终的功能节点集是 $\\{1,2,5,6\\}$。相互连通分量是该集合上图的连通分量，即 $\\{1,2\\}$ 和 $\\{5,6\\}$。两者的大小都为 2。这满足了所有分量大小最多为 2 的条件。\n因为存在一个大小为 $|S|=2$ 的割集，我们有 $k^{\\star} \\le 2$。\n\n结合这两个界，我们有 $1  k^{\\star} \\le 2$。由于 $k^{\\star}$ 必须是一个整数，唯一可能性是 $k^{\\star}=2$。最小基数为 2。",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "我们的最后一个实践将我们带入现代计算网络科学的领域。现实世界的网络并非完美的理论对象；它们的结构只能通过有限且含噪声的数据来了解。这个练习  将指导您构建一个完整的计算流程，以分析在这种不确定性下的网络弹性。您将通过实现理论模型来找到网络的临界点，并使用自举法 (bootstrap methods) 来量化您预测的置信度，这完整地模拟了当代研究的过程。",
            "id": "4266361",
            "problem": "考虑两个完全相依的网络，记为 $A$ 和 $B$。每个网络都是一个配置模型，完全由其观测度序列定义。相依关系是一一对应的双向关系：网络 $A$ 中的每个节点恰好依赖于网络 $B$ 中的一个节点，反之亦然。如果一个节点未连接到其自身网络的巨连通分量，或者其在另一个网络中的相依对应节点失效，则该节点失效。一次初始随机失效会从两个网络中均匀随机地移除比例为 $1 - p$ 的节点，其中 $p \\in [0,1]$ 是保留下来的节点比例。\n\n使用的基本和核心定义：\n- 配置模型网络由其度分布 $P(k)$ 指定，$P(k)$ 是一个随机选择的节点度为 $k$ 的概率。其平均度为 $\\langle k \\rangle = \\sum_{k=0}^{\\infty} k P(k)$。\n- 度分布的生成函数是普通生成函数 $G_0(x) = \\sum_{k=0}^{\\infty} P(k) x^k$ 和余度生成函数 $G_1(x) = \\sum_{k=1}^{\\infty} \\frac{k P(k)}{\\langle k \\rangle} x^{k-1}$。余度生成函数的产生是由于沿着一条随机边到达某个节点时，该节点剩余边数的分布与 $k P(k)$ 成正比。\n- 在占据比例为 $x \\in [0,1]$ 的单个配置模型网络上的位点渗流中，巨连通分量的大小比例由一个自洽不动点方程确定。该方程源于生成函数框架和分支过程近似。这个不动点将一条边不通向巨连通分量的概率与保留比例 $x$ 联系起来，最终的巨连通分量比例是 $x$、$G_0(\\cdot)$ 和 $G_1(\\cdot)$ 的函数。\n- 在两个完全相依的网络中，级联失效通过由相依节点移除触发的、交替进行的单网络渗流步骤来演进，从而产生一个跨越网络 $A$ 和 $B$ 的耦合不动点条件。\n\n任务：\n1. 基于上述基本原理，推导单个配置模型网络中占据比例到巨连通分量关系的函数 $S(x)$，其中 $x$ 是保留比例。然后，推导两个相依网络的耦合不动点迭代过程，其中保留比例对 $(x_A, x_B)$ 从 $(p,p)$ 开始，通过交替应用单网络映射进行演化，直至收敛或崩溃。\n2. 将临界保留比例 $p_c$ 定义为 $p \\in [0,1]$ 的下确界，使得级联过程不崩溃为零，并且耦合不动点在两个网络中都产生严格为正的共同巨连通分量。论证度序列的样本间变异性，会通过生成函数 $G_0(x)$ 和 $G_1(x)$ 对经验度分布的依赖性，导致 $p_c$ 的涨落。\n3. 实现一个程序，对于下述每个测试用例，通过迭代级联和对 $p$ 的二分法来数值求解耦合不动点，从而计算出点估计 $\\hat{p}_c$。然后，通过对观测度序列进行自助法重抽样（有放回），并对每个自助法复制样本重复不动点求解过程以获得 $p_c$ 的自助法分布，从而计算出 $p_c$ 的双侧 $95\\%$ 置信区间。该置信区间必须以水平为 $0.025$ 和 $0.975$ 的下分位数和上分位数形式返回。所有答案必须表示为十进制浮点数。不适用任何物理单位或角度单位。使用适当的数值容差以确保算法收敛。\n\n测试套件：\n对于每个测试用例，完全按照规定生成观测度序列，使用指定的伪随机种子以确保可复现性。对观测序列和自助法重抽样样本使用相同的网络规模。对于每个测试用例，返回一个包含三个浮点数的列表 $[\\hat{p}_c, \\text{CI}_{\\text{lower}}, \\text{CI}_{\\text{upper}}]$，按上述方法计算。\n\n- 测试用例 1 (平衡，中等连通性):\n  - 网络 A：使用种子 $s_A = 1234$，从均值为 $\\lambda_A = 3.0$ 的泊松分布中独立抽取 $N_A = 800$ 个度值。\n  - 网络 B：使用种子 $s_B = 5678$，从均值为 $\\lambda_B = 3.0$ 的泊松分布中独立抽取 $N_B = 800$ 个度值。\n  - 自助法复制样本数：$B = 200$。\n\n- 测试用例 2 (异构且失配的连通性):\n  - 网络 A：使用种子 $s_A = 222$，从整数 $k \\in \\{1,2,\\dots,50\\}$ 上的截断幂律分布中抽取 $N_A = 1000$ 个度值，其指数为 $\\alpha = 2.5$，即概率与 $k^{-\\alpha}$ 成正比。\n  - 网络 B：使用种子 $s_B = 333$，从参数为 $(r = 3, p = 0.5)$ 的负二项分布中抽取 $N_B = 1000$ 个度值。\n  - 自助法复制样本数：$B = 200$。\n\n- 测试用例 3 (近临界稀疏网络):\n  - 网络 A：使用种子 $s_A = 444$，从均值为 $\\lambda_A = 1.2$ 的泊松分布中抽取 $N_A = 600$ 个度值。\n  - 网络 B：使用种子 $s_B = 555$，从均值为 $\\lambda_B = 1.2$ 的泊松分布中抽取 $N_B = 600$ 个度值。\n  - 自助法复制样本数：$B = 150$。\n\n- 测试用例 4 (退化的低度结构):\n  - 网络 A：$N_A = 400$，其中恰好有 $380$ 个度为 $1$ 的节点，$18$ 个度为 $2$ 的节点，以及 $2$ 个度为 $3$ 的节点。\n  - 网络 B：与网络 A 相同。\n  - 自助法复制样本数：$B = 100$。\n\n算法规范：\n- 对于每个网络，从观测到的度值构建经验度分布 $P(k)$ 并计算其平均度 $\\langle k \\rangle$。使用由经验 $P(k)$ 导出的生成函数 $G_0(x)$ 和 $G_1(x)$。\n- 对于占据比例为 $x$ 的单个网络，通过从生成函数导出的适当不动点解来计算其巨连通分量比例 $S(x)$；在内部不动点计算中使用容差为 $\\varepsilon = 10^{-12}$、最大迭代次数为 $10^4$ 的数值不动点迭代。\n- 对于两个相依网络，从 $(p,p)$ 开始，对 $(x_A, x_B)$ 执行同步级联更新，为每个网络使用单网络映射，直到在容差 $\\varepsilon = 10^{-12}$ 内收敛或达到最大 $5000$ 次级联迭代。如果两个极限值都严格大于 $10^{-8}$，则声明为存活。\n- 通过对 $p \\in [0,1]$ 进行最多 $40$ 步的二分法来确定 $p_c$。如果即使在 $p=1$ 时也无法存活，则设 $p_c = 1.0$。\n- 对于自助法，对每个网络独立地进行有放回的度值重抽样，重新计算经验 $P(k)$，按上述方法求解 $p_c$，并收集自助法分布；报告在 $0.025$ 和 $0.975$ 处的经验分位数作为置信区间。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应测试用例的、包含三个浮点数的列表，顺序与上面列出的一致。例如：\"[[result_case1_p_hat,result_case1_ci_lower,result_case1_ci_upper],[result_case2_p_hat,result_case2_ci_lower,result_case2_ci_upper],...]\"。",
            "solution": "该问题要求推导并数值实现一个关于两个相依网络 $A$ 和 $B$ 中级联失效的模型，然后使用自助法重抽样对临界点进行统计分析。\n\n### 第 1 部分：不动点方程的推导\n\n该模型基于配置模型网络上的渗流理论，并扩展到两个相依网络的系统。分析的核心在于使用度分布的生成函数。\n\n#### 1.1 单网络渗流\n\n我们首先考虑一个具有度分布 $P(k)$ 的单个网络。相应的普通生成函数和余度生成函数分别为 $G_0(x) = \\sum_{k=0}^{\\infty} P(k) x^k$ 和 $G_1(x) = \\sum_{k=1}^{\\infty} \\frac{k P(k)}{\\langle k \\rangle} x^{k-1}$，其中 $\\langle k \\rangle = \\sum_k k P(k)$ 是平均度。\n\n假设比例为 $x$ 的节点被随机“占据”（即保留），比例为 $1-x$ 的节点被移除。我们想找到属于巨连通分量（GC）的节点比例 $S(x)$。这通过一个自洽论证来确定。\n\n设 $f$ 为沿着一条随机边到达的节点*不*属于巨连通分量的概率。如果一个节点最初被移除（对任何节点，此事件概率为 $1-x$），或者它被占据（概率为 $x$）但其所有其他边都不通向巨连通分量，那么该节点就不在巨连通分量中。\n\n从一个通过随机边到达的节点出发的“其他”边的数量是 $k-1$，其中度 $k$ 从余度分布 $\\frac{kP(k)}{\\langle k \\rangle}$ 中抽取。所有 $k-1$ 条其他边都不通向巨连通分量的概率是 $f^{k-1}$。对所有可能的度 $k$ 求和，我们得到 $f$ 的不动点方程：\n$$ f = (1-x) + x \\sum_{k=1}^{\\infty} \\frac{k P(k)}{\\langle k \\rangle} f^{k-1} $$\n求和项恰好是余度生成函数 $G_1(f)$。因此，方程简化为：\n$$ f = 1 - x + x G_1(f) $$\n该方程的最小非负解 $f^*$ 对应于所求的概率。这个方程可以通过不动点迭代进行数值求解，例如，从一个初始猜测值（如 $f_0=0.5$）开始，使用 $f_{n+1} = 1 - x + x G_1(f_n)$。\n\n一旦确定了 $f^*$，我们就可以找到巨连通分量中的节点比例 $S(x)$。一个随机选择的节点在巨连通分量中，当且仅当它被占据（概率为 $x$）并且它连接到巨连通分量。一个随机节点*不*在巨连通分量中的概率是它未被占据的概率（$1-x$）与它被占据但其所有边都只通向有限分支的概率之和。后者的概率是 $x \\sum_{k=0}^{\\infty} P(k) (f^*)^k = x G_0(f^*)$。所以，不在巨连通分量中的概率是 $(1-x) + xG_0(f^*)$。因此，巨连通分量中的节点比例是：\n$$ S(x) = 1 - \\left[ (1-x) + x G_0(f^*) \\right] = x - x G_0(f^*) = x(1 - G_0(f^*)) $$\n这个函数 $S(x)$ 将保留的节点比例 $x$ 映射到最终的巨连通分量中的节点比例。\n\n#### 1.2 相依网络\n\n现在，考虑两个相依网络 $A$ 和 $B$。初始时，比例为 $1-p$ 的节点从两者中移除。一个节点能在级联失效中存活，条件是它没有在初始时被移除，它属于其自身网络的巨连通分量，并且其在另一个网络中的相依伙伴也存活。\n\n设 $P_A$ 和 $P_B$ 分别是网络 $A$ 和 $B$ 中一个随机选择的节点属于最终共同巨连通分量的概率。这些是我们希望求出的量。\n\n考虑网络 $A$ 中的一个节点。要使其成为最终功能组件的一部分，必须满足三个条件：\n1. 它必须没有在初始攻击中被移除（概率为 $p$）。\n2. 它在网络 $B$ 中的相依伙伴必须是 $B$ 的最终功能组件的一部分（概率为 $P_B$）。\n3. 该节点必须属于网络 $A$ 的巨连通分量，条件是只有满足 (1) 和 (2) 的节点才被视为“占据”状态。\n\n网络 $A$ 中被占据节点的有效比例是一个节点满足 (1) 和 (2) 的概率，由于随机的一一对应相依关系，该比例为 $\\psi_A = p \\cdot P_B$。给定此有效占据比例 $\\psi_A$，网络 $A$ 中属于其巨连通分量的节点比例由单网络映射 $S_A(\\psi_A) = S_A(p \\cdot P_B)$ 给出。这个比例必须等于我们试图找到的概率 $P_A$。\n\n通过对称性，我们得到了相依系统的耦合不动点方程：\n$$ P_A = S_A(p \\cdot P_B) $$\n$$ P_B = S_B(p \\cdot P_A) $$\n其中 $S_A$ 和 $S_B$ 分别是上一节中推导的各自的单网络巨连通分量映射函数。\n\n这些方程可以通过同步迭代求解：\n1. 初始化 $(P_A^{(0)}, P_B^{(0)}) = (p, p)$。\n2. 对 $n=0, 1, 2, \\dots$ 进行迭代：\n   $$ P_A^{(n+1)} = S_A(p \\cdot P_B^{(n)}) $$\n   $$ P_B^{(n+1)} = S_B(p \\cdot P_A^{(n)}) $$\n3. 迭代持续进行，直到对 $(P_A, P_B)$ 收敛到一个不动点 $(P_A^*, P_B^*)$。如果不动点是严格为正的，则网络存活。否则，网络崩溃。\n\n### 第 2 部分：临界比例和自助法置信区间\n\n临界保留比例 $p_c$ 是使得非零解 $(P_A^* > 0, P_B^* > 0)$ 存在的 $p$ 的最小值。当 $p$ 低于 $p_c$ 时，唯一稳定的解是 $(0,0)$。这个值标志着相依系统的渗流阈值。\n\n$p_c$ 的值取决于函数 $S_A$ 和 $S_B$，而这些函数又取决于生成函数 $G_{0,A}, G_{1,A}, G_{0,B}, G_{1,B}$。在这个问题中，这些函数是从*经验*度序列中推导出来的。由于这些序列是有限样本，它们会受到统计涨落的影响。如果我们抽取不同的度值样本，我们将得到略有不同的经验分布，从而导致不同的 $S$ 函数和不同的计算出的 $p_c$ 值。这证明了 $p_c$ 本身是一个随机变量，其分布是由度值的抽样过程所引致的。\n\n为了数值估计 $p_c$ 及其不确定性，我们执行两项任务：\n1.  **点估计 ($\\hat{p}_c$)**: 对于单个观测到的度序列对，我们使用二分搜索来找到 $p_c$。我们定义一个函数 `survives(p)`，如果给定 $p$ 的迭代级联过程收敛到一个非零不动点，则返回真，否则返回假。然后我们在区间 $p \\in [0, 1]$ 中搜索存活与崩溃之间的边界。\n2.  **置信区间 (CI)**: 我们使用自助法重抽样来近似 $\\hat{p}_c$ 的抽样分布。我们通过从原始观测序列中有放回地重抽样，生成大量的（$B$ 个）新度序列对。对于这 $B$ 个自助法复制样本中的每一个，我们都计算出 $\\hat{p}_c$。这 $B$ 个值的集合构成了自助法分布。然后通过取该分布的 $2.5\\%$ 和 $97.5\\%$ 分位数来估计 $95\\%$ 置信区间。\n\n### 第 3 部分：算法实现\n\n整体算法流程如下：\n1.  对于每个测试用例，为网络 $A$ 和 $B$ 生成指定的原始度序列。\n2.  实现一个函数 `make_s_of_x`，它接受一个度序列，计算经验生成函数 $G_0$ 和 $G_1$，并返回相应的单网络映射函数 $S(x)$。这涉及到对 $f$ 的数值不动点求解。\n3.  实现一个函数 `check_survival(p, S_A, S_B)`，它为给定的 $p$ 和两个网络映射求解耦合级联方程，如果最终的共同巨连通分量非零，则返回真。\n4.  实现 `find_pc(S_A, S_B)`，它通过调用 `check_survival` 在 $p \\in [0, 1]$ 上使用二分法来找到临界阈值。\n5.  使用原始度序列计算点估计 $\\hat{p}_c$。\n6.  执行 $B$ 次复制的自助法循环：\n    a. 通过从原始序列中有放回地重抽样来创建自助法度序列。\n    b. 为自助法样本创建相应的 $S_A$ 和 $S_B$ 函数。\n    c. 计算并存储此复制样本得到的 $p_c$。\n7.  从存储的自助法 $p_c$ 值中计算 $0.025$ 和 $0.975$ 分位数以构建置信区间。\n8.  为每个测试用例收集 $[\\hat{p}_c, \\text{CI}_{\\text{lower}}, \\text{CI}_{\\text{upper}}]$ 并格式化最终输出。\n\n为了性能，特别是在生成函数的计算中，使用了向量化的 `numpy` 操作，因为生成函数会被重复调用。",
            "answer": "```python\nimport numpy as np\nimport collections\n\n# Algorithmic constants from the problem statement\nFP_TOL = 1e-12\nFP_MAX_ITER = 10000\nCASCADE_TOL = 1e-12\nCASCADE_MAX_ITER = 5000\nBISECTION_STEPS = 40\nSURVIVAL_THRESH = 1e-8\n\ndef get_generating_functions(degrees):\n    \"\"\"\n    Computes the ordinary and excess-degree generating functions from an empirical degree sequence.\n    \"\"\"\n    if len(degrees) == 0:\n        return lambda x: 1.0, lambda x: 0.0\n\n    unique_k, counts = np.unique(degrees, return_counts=True)\n    probs = counts / len(degrees)\n    mean_k = np.mean(degrees)\n\n    def G0(x):\n        if x == 0:\n            return probs[unique_k == 0][0] if 0 in unique_k else 0.0\n        return np.sum(probs * np.power(x, unique_k))\n\n    def G1(x):\n        if mean_k == 0:\n            return 0.0\n        \n        valid_indices = unique_k > 0\n        if not np.any(valid_indices):\n            return 0.0\n            \n        k_vals = unique_k[valid_indices]\n        prob_vals = probs[valid_indices]\n        \n        if x == 0:\n            return (k_vals[0] * prob_vals[0] / mean_k) if k_vals[0] == 1 else 0.0\n\n        return np.sum(k_vals * prob_vals / mean_k * np.power(x, k_vals - 1))\n\n    return G0, G1\n\ndef make_s_of_x_func(degrees):\n    \"\"\"\n    Creates the single-network mapping S(x) for a given degree sequence.\n    \"\"\"\n    G0, G1 = get_generating_functions(degrees)\n\n    def s_of_x(x):\n        if x == 0:\n            return 0.0\n        if x >= 1:\n            x = 1.0\n        \n        f = 0.5\n        for _ in range(FP_MAX_ITER):\n            f_next = 1.0 - x + x * G1(f)\n            if abs(f_next - f)  FP_TOL:\n                f = f_next\n                break\n            f = f_next\n        \n        return x * (1.0 - G0(f))\n\n    return s_of_x\n\ndef check_survival(p, S_A, S_B):\n    \"\"\"\n    Solves the coupled cascade equations for a given p and returns if the system survives.\n    \"\"\"\n    if p == 0:\n        return False\n        \n    pa, pb = p, p\n    for _ in range(CASCADE_MAX_ITER):\n        pa_next = S_A(p * pb)\n        pb_next = S_B(p * pa)\n        \n        if max(abs(pa_next - pa), abs(pb_next - pb))  CASCADE_TOL:\n            pa, pb = pa_next, pb_next\n            break\n        pa, pb = pa_next, pb_next\n\n    return pa > SURVIVAL_THRESH and pb > SURVIVAL_THRESH\n\ndef find_pc(S_A, S_B):\n    \"\"\"\n    Finds the critical retained fraction p_c using bisection search.\n    \"\"\"\n    if not check_survival(1.0, S_A, S_B):\n        return 1.0\n    \n    low, high = 0.0, 1.0\n    for _ in range(BISECTION_STEPS):\n        mid = (low + high) / 2.0\n        if mid == low or mid == high: # Precision limit reached\n            break\n        if check_survival(mid, S_A, S_B):\n            high = mid\n        else:\n            low = mid\n            \n    return high\n\ndef generate_degrees(spec):\n    \"\"\"\n    Generates degree sequences based on the test case specification.\n    \"\"\"\n    dist_type = spec['dist']\n    N = spec['N']\n    seed = spec.get('seed')\n    rng = np.random.default_rng(seed)\n\n    if dist_type == 'poisson':\n        return rng.poisson(spec['lambda'], size=N)\n    elif dist_type == 'truncated_power_law':\n        k_min, k_max = 1, spec['k_max']\n        alpha = spec['alpha']\n        k_range = np.arange(k_min, k_max + 1, dtype=np.float64)\n        weights = k_range**(-alpha)\n        probs = weights / np.sum(weights)\n        return rng.choice(k_range, size=N, p=probs).astype(int)\n    elif dist_type == 'negative_binomial':\n        r, p_param = spec['r'], spec['p']\n        return rng.negative_binomial(r, p_param, size=N)\n    elif dist_type == 'fixed':\n        return np.array(spec['sequence'], dtype=int)\n    else:\n        raise ValueError(f\"Unknown distribution type: {dist_type}\")\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and produce the final output.\n    \"\"\"\n    test_cases_spec = [\n        {\n            'A': {'dist': 'poisson', 'N': 800, 'lambda': 3.0, 'seed': 1234},\n            'B': {'dist': 'poisson', 'N': 800, 'lambda': 3.0, 'seed': 5678},\n            'B_reps': 200\n        },\n        {\n            'A': {'dist': 'truncated_power_law', 'N': 1000, 'alpha': 2.5, 'k_max': 50, 'seed': 222},\n            'B': {'dist': 'negative_binomial', 'N': 1000, 'r': 3, 'p': 0.5, 'seed': 333},\n            'B_reps': 200\n        },\n        {\n            'A': {'dist': 'poisson', 'N': 600, 'lambda': 1.2, 'seed': 444},\n            'B': {'dist': 'poisson', 'N': 600, 'lambda': 1.2, 'seed': 555},\n            'B_reps': 150\n        },\n        {\n            'A': {'dist': 'fixed', 'N': 400, 'sequence': [1]*380 + [2]*18 + [3]*2},\n            'B': {'dist': 'fixed', 'N': 400, 'sequence': [1]*380 + [2]*18 + [3]*2},\n            'B_reps': 100\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases_spec:\n        # Generate original degree sequences\n        degrees_A_orig = generate_degrees(case['A'])\n        degrees_B_orig = generate_degrees(case['B'])\n        \n        # Create S(x) functions for original data\n        S_A_orig = make_s_of_x_func(degrees_A_orig)\n        S_B_orig = make_s_of_x_func(degrees_B_orig)\n\n        # Calculate point estimate for p_c\n        pc_hat = find_pc(S_A_orig, S_B_orig)\n\n        # Bootstrap\n        B_reps = case['B_reps']\n        bootstrap_pcs = np.zeros(B_reps)\n        \n        boot_rng = np.random.default_rng() \n        N_A, N_B = case['A']['N'], case['B']['N']\n\n        for i in range(B_reps):\n            degrees_A_boot = boot_rng.choice(degrees_A_orig, size=N_A, replace=True)\n            degrees_B_boot = boot_rng.choice(degrees_B_orig, size=N_B, replace=True)\n\n            S_A_boot = make_s_of_x_func(degrees_A_boot)\n            S_B_boot = make_s_of_x_func(degrees_B_boot)\n            \n            bootstrap_pcs[i] = find_pc(S_A_boot, S_B_boot)\n\n        # Calculate confidence interval\n        ci_lower, ci_upper = np.quantile(bootstrap_pcs, [0.025, 0.975])\n\n        all_results.append([pc_hat, ci_lower, ci_upper])\n\n    # Format the final output string\n    result_str = \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in all_results])\n    print(f\"[{result_str}]\")\n\n# Placeholder for final result as running the code is not possible.\n# solve()\n# The problem asks for the numerical result, but provides code. \n# As I cannot run the code, I will output the corrected code block as the answer.\n# The expected output format is a list of lists of floats, e.g. [[0.82, 0.81, 0.83], ...]\n```"
        }
    ]
}