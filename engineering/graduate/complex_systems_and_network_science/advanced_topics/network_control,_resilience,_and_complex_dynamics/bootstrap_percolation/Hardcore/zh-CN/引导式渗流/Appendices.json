{
    "hands_on_practices": [
        {
            "introduction": "这项实践深入探讨了自举渗流在稀疏种子情境下的核心机制：成核（nucleation）。你将探索全局激活如何依赖于“临界核”这一罕见事件的形成。本练习  将指导你应用泊松近似这一统计物理学中的强大工具，来推导系统被完全激活的概率，从而揭示系统大小、种子密度与相变之间的关键关系。",
            "id": "4265156",
            "problem": "考虑在二维整数格点上限制于一个 $a \\times b$ 矩形区域内的二邻居自举渗流，边界条件为开放边界条件。每个位点初始以概率 $p \\in (0,1)$ 独立地被感染（成为一个种子），动力学过程以离散时间步进行：任何拥有至少 $r=2$ 个被感染最近邻（在冯·诺依曼邻域意义下）的健康位点会被感染，且被感染的位点永久保持感染状态。如果从一个集合内部包含的种子开始，并假设集合外的所有位点都为健康状态，动力学过程最终能感染该集合中的每一个位点，则称该集合是内部张成的。\n\n仅使用二邻居自举渗流的基本定义和关于二维空间中 $r=2$ 时存在一个尖锐临界长度尺度的已验证事实，推导在稀疏种子机制下，固定的 $a \\times b$ 矩形被内部张成的概率关于 $a$、$b$ 和 $p$ 的主阶渐近行为。特别地，假设存在以下标度机制：\n- $p \\to 0$，\n- $a \\to \\infty$ 且 $b \\to \\infty$，\n- 乘积 $a b$ 随 $p$ 的增长方式使得\n$$\na b \\,\\exp\\!\\Big(-\\frac{\\pi^{2}}{18\\,p}\\Big) \\;\\longrightarrow\\; \\lambda \\in (0,\\infty) \\quad \\text{当 } p \\to 0 \\text{ 时}.\n$$\n\n在这些假设下，计算内部张成概率的极限值，将其表示为极限参数 $\\lambda$ 的一个显式闭式函数。你的最终答案必须是关于 $\\lambda$ 的一个无单位的单一闭式解析表达式。无需四舍五入。\n\n此外，在你的推导中，请从自举渗流的核心定义以及由二维二邻居模型的严格结果验证的标准成核-液滴启发法出发，分析结果如何体现了与 $a$、$b$ 和 $p$ 的标度关系。不要在没有基于这些基础进行论证的情况下引用任何快捷公式。",
            "solution": "问题要求在初始种子概率 $p$ 趋于 $0$ 的特定极限机制下，一个 $a \\times b$ 矩形在二邻居自举渗流模型中被内部张成的渐近概率。\n\n该模型是作用于二维整数格点 $\\mathbb{Z}^2$ 的一个大小为 $a \\times b$ 的矩形子集上的二邻居（$r=2$）自举渗流。每个位点初始以独立的概率 $p$ 被指定为受感染状态。该过程以离散时间步演化：任何拥有至少 $r=2$ 个受感染最近邻（在冯·诺依曼意义下）的健康位点会变为受感染状态。受感染的位点永久保持受感染状态。该矩形采用开放边界条件，意味着矩形外的位点被视为永久健康。如果一个 $a \\times b$ 矩形内的初始种子构型能够最终导致所有 $ab$ 个位点被感染，则称该矩形是“内部张成的”。\n\n我们关注的是稀疏种子机制，其中 $p \\to 0$。在这种机制下，张成一个大区域的全局事件是一种极其罕见的现象。该动力学由成核与生长原理主导。为了使整个矩形被感染，初始的随机种子构型必须包含至少一个“临界核”或“液滴”——这是一种稳定的、能够生长并感染其周围区域的局部受感染位点构型。如果没有形成这样的核，不连通的小感染簇通常会保持很小，无法在整个系统中传播。\n\n问题的核心依赖于一个关于二邻居自举渗流模型中形成临界核概率的公认结果。在任何特定位置形成一个核是一个特定的局部事件，其概率（我们可以将其解释为成核中心密度 $\\rho(p)$）已知对 $p$ 有非常强的依赖性。对于 $\\mathbb{Z}^2$ 上的 $r=2$ 模型，严格的分析已经表明，该密度的主阶渐近行为由以下公式给出：\n$$\n\\rho(p) \\sim \\exp\\Big(-\\frac{\\pi^{2}}{18p}\\Big) \\quad \\text{当 } p \\to 0 \\text{ 时}\n$$\n常数 $\\frac{\\pi^2}{18}$ 是这个特定模型的一个非平凡特征。问题陈述给出的标度关系明确地建立在这一基本结果之上，引导我们将其作为一个“已验证事实”来使用。\n\n设 $N$ 为代表 $a \\times b$ 矩形内临界核数量的随机变量。矩形内的总位点数为 $ab$。由于 $p \\to 0$，形成一个核是一个非常罕见的事件。在不同位点（尤其是相距很远的位点）的成核事件是近似独立的。在一个大区域内，一个罕见的、局部的且近似独立的事件发生的总次数可以很好地用泊松分布来近似。因此，我们可以将 $N$ 建模为一个泊松随机变量，$N \\sim \\text{Poisson}(\\mu)$。\n\n这个泊松分布的均值（或参数）$\\mu$ 是矩形内临界核的期望数量。它由一个核的潜在位置数（即面积 $ab$）与每个位点形成一个核的概率（密度 $\\rho(p)$）的乘积给出。因此，\n$$\n\\mu = \\mathbb{E}[N] \\approx ab \\cdot \\rho(p)\n$$\n代入 $\\rho(p)$ 的已知渐近形式，我们得到\n$$\n\\mu \\approx ab \\cdot \\exp\\Big(-\\frac{\\pi^{2}}{18p}\\Big)\n$$\n问题指定了一个联合渐近极限，其中 $p \\to 0$，$a \\to \\infty$，$b \\to \\infty$，且方式使得下面这个量收敛到一个有限的正数常量 $\\lambda$：\n$$\nab \\exp\\Big(-\\frac{\\pi^{2}}{18p}\\Big) \\longrightarrow \\lambda\n$$\n这恰好意味着矩形中临界核的期望数量收敛于 $\\lambda$。该标度律的设计是为了确保在极限情况下，我们处于一个临界窗口，其中核的数量为一阶。\n\n在此极限下，$a \\times b$ 矩形被内部张成的事件等价于其边界内至少存在一个临界核的事件，即 $N \\ge 1$。这是因为任何这样的核，由于其“临界”性，根据定义能够自我维持生长。考虑到开放边界条件和矩形尺寸的发散性（$a, b \\to \\infty$），一个在离边界足够远的地方形成的核将会生长并填满整个区域。当 $p \\to 0$ 时，在没有合适核的情况下，由亚临界构型张成大矩形的概率变得可以忽略不计。\n\n因此，矩形被内部张成的概率 $P_{\\text{span}}$ 收敛于概率 $P(N \\ge 1)$。对于一个均值 $\\mu \\to \\lambda$ 的泊松随机变量 $N$，这个概率计算如下：\n$$\nP(N \\ge 1) = 1 - P(N=0)\n$$\n泊松分布的概率质量函数是 $P(N=k) = \\frac{\\mu^k e^{-\\mu}}{k!}$。对于 $k=0$，我们有：\n$$\nP(N=0) = \\frac{\\mu^0 e^{-\\mu}}{0!} = e^{-\\mu}\n$$\n由于我们处于 $\\mu \\to \\lambda$ 的极限下，没有发现核的极限概率是 $e^{-\\lambda}$。\n\n因此，矩形被张成的极限概率是：\n$$\n\\lim_{p \\to 0} P_{\\text{span}} = 1 - \\lim_{\\mu \\to \\lambda} e^{-\\mu} = 1 - e^{-\\lambda}\n$$\n这个结果展示了系统维度（$a$、$b$）的标度和种子概率（$p$）是如何耦合的。乘积 $ab$ 代表了成核机会的“体积”，而项 $\\exp(-\\frac{\\pi^2}{18p})$ 代表了在任何给定位置这一事件的极端稀有性。它们的乘积 $\\lambda$ 是“成功”成核事件的期望数量，它直接决定了宏观相变（系统张成）的概率。",
            "answer": "$$\\boxed{1 - \\exp(-\\lambda)}$$"
        },
        {
            "introduction": "自举渗流的协同激活规则，如何使其区别于标准位点渗流等更简单的过程？这项实践  通过分析一个特殊设计的图来回答这个问题。通过在同一结构上比较两种过程的结果，你将具体理解自举动力学如何利用网络拓扑（例如一个密集连接的核心），来实现普通渗流模型无法达成的广泛激活。",
            "id": "4265164",
            "problem": "考虑以下图族，该图族凸显了标准点渗流与 $r$-自举渗流之间的差异。令 $G_{m,d}$ 由一个包含 $m$ 个节点的全连接核心（一个团）组成，其中每个核心节点都连接着 $d$ 个不同的悬挂邻居（度为1的叶节点）。节点总数为 $n = m(1+d)$。执行标准点渗流，每个节点以概率 $\\phi \\in (0,1)$ 被独立占据，并考虑被占据节点中的最大连通分量。独立地，初始化阈值为 $r=2$ 的 $r$-自举渗流，将点渗流步骤中被占据的节点精确地声明为初始激活节点，然后迭代地激活任何至少有 $r$ 个激活邻居的节点，重复此过程直到没有更多节点可以被激活。\n\n从点渗流是独立的节点占据过程以及 $r$-自举渗流是图上的一种迭代阈值激活动态过程的核心定义出发，在固定 $d$ 且 $m \\to \\infty$ 的极限下分析 $G_{m,d}$。\n\n您的任务是：\n- 从第一性原理推导，对于任何固定的 $\\phi \\in (0,1)$，标准点渗流过程是否会产生一个巨分量，以及对于相同的 $\\phi$，阈值为 $r=2$ 的 $r$-自举渗流过程是否会完全激活整个图。\n- 定义差异 $\\Delta(\\phi,d)$ 为 $r$-自举渗流过程结束时激活节点的极限期望分数减去标准点渗流下属于最大连通分量的节点的极限期望分数，并为 $\\Delta(\\phi,d)$ 推导出一个闭式解析表达式。\n\n将最终答案表示为关于 $\\phi$ 和 $d$ 的单个闭式表达式。不需要数值近似；不要四舍五入。该问题不涉及物理单位。",
            "solution": "该问题被评估为有效，因为它在网络科学方面有科学依据，问题设定良好、客观且内部一致。它提出了一个可解的理论问题，没有任何事实或逻辑上的缺陷。\n\n该问题要求在核心大小 $m \\to \\infty$ 而每个核心节点的悬挂点数量 $d$ 保持固定的极限情况下，在一个特定的图族 $G_{m,d}$ 上分析两个过程，即标准点渗流和 $r$-自举渗流。图 $G_{m,d}$ 由一个包含 $m$ 个核心节点的团组成，每个核心节点都连接着 $d$ 个不同的悬挂邻居（叶节点）。图中的节点总数为 $n = m + md = m(1+d)$。\n\n让我们分别分析每个过程，以确定最大分量或最终激活集合中的节点期望分数。\n\n**1. 标准点渗流**\n\n在标准点渗流中，$G_{m,d}$ 中的每个节点都以概率 $\\phi \\in (0,1)$ 被独立占据。我们关心的是被占据节点的最大连通分量（LCC）的大小。\n\n图的核心是一个包含 $m$ 个节点的团。根据定义，任意两个被占据的核心节点都是相连的。设 $N_{core}^{occ}$ 为被占据的核心节点数。$N_{core}^{occ}$ 服从二项分布，$N_{core}^{occ} \\sim \\text{Bin}(m, \\phi)$。当 $m \\to \\infty$ 时，$N_{core}^{occ}  2$ 的概率趋于零。具体来说，$P(N_{core}^{occ}=0)=(1-\\phi)^m \\to 0$ 且 $P(N_{core}^{occ}=1)=m\\phi(1-\\phi)^{m-1} \\to 0$。因此，以趋近于 $1$ 的概率，我们至少有两个被占据的核心节点，它们自身形成一个单一的连通分量。这个分量构成了LCC的核心。\n\n悬挂节点是叶节点，度为 $1$。它唯一的邻居是一个核心节点。对于一个被占据的悬挂节点，要成为一个大小大于 $1$ 的连通分量的一部分，其唯一的核心邻居也必须是该分量的一部分。因此，LCC将由所有被占据的核心节点，加上任何连接到被占据核心节点的被占据悬掛节点组成。\n\n让我们计算LCC的期望大小，记为 $\\langle S_{LCC} \\rangle$。根据期望的线性性质，这是每个节点属于LCC的概率之和。\n一个核心节点如果被占据，就属于LCC。被占据的核心节点的期望数量是 $m\\phi$。\n一个悬挂节点如果被占据且其核心邻居也被占据，就属于LCC。由于这些是独立事件，特定悬挂节点属于LCC的概率是 $\\phi \\times \\phi = \\phi^2$。共有 $md$ 个悬挂节点。所以，LCC中悬挂节点的期望数量是 $md\\phi^2$。\n\nLCC的总期望大小是这两个量的和：\n$$ \\langle S_{LCC} \\rangle = m\\phi + md\\phi^2 = m\\phi(1+d\\phi) $$\nLCC中节点的期望分数是 $\\langle S_{LCC} \\rangle/n$。在 $m \\to \\infty$ 的极限下：\n$$ \\lim_{m\\to\\infty} \\frac{\\langle S_{LCC} \\rangle}{n} = \\lim_{m\\to\\infty} \\frac{m\\phi(1+d\\phi)}{m(1+d)} = \\frac{\\phi(1+d\\phi)}{1+d} $$\n对于任何固定的 $\\phi \\in (0,1)$ 和整数 $d \\ge 1$，这个分数都严格大于 $0$。在无限系统极限下，包含总节点非零分量的分量就是巨分量。因此，对于任何固定的 $\\phi \\in (0,1)$，标准点渗流过程都会产生一个巨分量。\n\n**2. $r=2$ 的 $r$-自举渗流**\n\n在这个过程中，初始激活节点集是点渗流步骤中的被占据节点集。随后，如果一个非激活节点至少有 $r=2$ 个激活邻居，它就会变为激活状态。这个规则被迭代应用，直到没有更多节点可以被激活。\n\n让我们分析不同类型节点的激活情况：\n-   **悬挂节点**：悬挂节点的度为 $1$。它永远不可能有 $2$ 个或更多的激活邻居。因此，一个悬挂节点只有在初始时就是激活的（即被占据的），才能成为最终激活集合的一部分。它不能通过自举动态过程被激活。\n-   **核心节点**：一个核心节点与其他所有 $m-1$ 个核心节点相连。如果至少有两个核心节点初始时是激活的，比如 $C_i$ 和 $C_j$，那么任何其他非激活的核心节点 $C_k$ 都有至少两个激活邻居（$C_i$ 和 $C_j$）。因此，$C_k$ 将在自举过程的第一步被激活。这意味着，只要至少有两个核心节点初始时是激活的，所有 $m$ 个核心节点都将变为激活状态。\n\n初始激活的核心节点数量服从二项分布 $\\text{Bin}(m, \\phi)$。初始激活的核心节点少于两个的概率是 $P(\\text{少于2个}) = P(0) + P(1) = (1-\\phi)^m + m\\phi(1-\\phi)^{m-1}$。对于任何固定的 $\\phi \\in (0,1)$，当 $m \\to \\infty$ 时，这个概率趋于 $0$。因此，以趋近于 $1$ 的概率，整个包含 $m$ 个节点的核心都会变为激活状态。\n\n让我们计算在 $m \\to \\infty$ 极限下最终激活集合的期望大小 $\\langle S_{BP} \\rangle$。\n最终激活集合由所有核心节点（以趋近于 $1$ 的概率）和所有初始激活的悬挂节点组成。\n在 $m \\to \\infty$ 极限下，激活的核心节点的期望数量是 $m$。\n激活的悬挂节点的期望数量等于初始被占据的悬挂节点的期望数量，即 $md\\phi$。\n最终激活集合的总期望大小是：\n$$ \\langle S_{BP} \\rangle = m + md\\phi = m(1+d\\phi) $$\n激活节点的极限期望分数是：\n$$ \\lim_{m\\to\\infty} \\frac{\\langle S_{BP} \\rangle}{n} = \\lim_{m\\to\\infty} \\frac{m(1+d\\phi)}{m(1+d)} = \\frac{1+d\\phi}{1+d} $$\n问题询问该过程是否完全激活了图。完全激活意味着激活节点的比例为 $1$。推导出的分数仅在 $1+d\\phi = 1+d$ 时为 $1$，而这需要 $\\phi=1$。由于问题指定 $\\phi \\in (0,1)$，该分数总是小于 $1$。因此，$r$-自举渗流过程不会完全激活整个图。\n\n**3. 差异 $\\Delta(\\phi, d)$**\n\n差异 $\\Delta(\\phi,d)$ 被定义为自举过程中激活节点的极限期望分数减去点渗流下LCC中节点的极限期望分数。使用上面推导的结果：\n$$ \\Delta(\\phi, d) = \\left( \\lim_{m\\to\\infty} \\frac{\\langle S_{BP} \\rangle}{n} \\right) - \\left( \\lim_{m\\to\\infty} \\frac{\\langle S_{LCC} \\rangle}{n} \\right) $$\n$$ \\Delta(\\phi, d) = \\frac{1+d\\phi}{1+d} - \\frac{\\phi(1+d\\phi)}{1+d} $$\n我们可以通过提取公因式 $(1+d\\phi)$ 来简化这个表达式：\n$$ \\Delta(\\phi, d) = \\frac{(1+d\\phi) - \\phi(1+d\\phi)}{1+d} $$\n$$ \\Delta(\\phi, d) = \\frac{(1+d\\phi)(1-\\phi)}{1+d} $$\n这可以展开成另一种形式：\n$$ \\Delta(\\phi, d) = \\frac{1 - \\phi + d\\phi - d\\phi^2}{1+d} $$\n这个表达式代表了在自举过程中，初始未被占据但后来变为激活状态的节点的极限期望分数。这种情况只发生在核心节点上，它们被招募进激活集合，并使得它们各自被占据的悬挂邻居（在点渗流中会被孤立）得以被计入最终的激活集合中。",
            "answer": "$$\\boxed{\\frac{(1-\\phi)(1+d\\phi)}{1+d}}$$"
        },
        {
            "introduction": "在模拟动态系统时，一个关键选择是更新方案：是同时更新所有节点（同步），还是一次更新一个（异步）？这项实践  探讨了自举渗流（一个经典的单调系统）中的这个基本问题。你将首先通过形式化证明，揭示最终结果与更新方案无关，然后编写程序来通过经验验证这一关键理论，从而连接数学证明与计算实践。",
            "id": "4265169",
            "problem": "设一个有限树图表示为 $G = (V,E)$，其中 $|V| = n$ 且边为无向边。考虑如下定义的 $r$-自举渗流：给定一个初始激活集 $A_0 \\subseteq V$。其动态是渐进的，意味着一个顶点一旦被激活，它将一直保持激活状态。更新规则是：一个未激活的顶点 $v$ 变为激活状态，当且仅当它至少有 $r$ 个激活的邻居。考虑两种更新方案：同步更新和异步更新。在同步更新中，所有在给定轮次满足激活规则的顶点会同时被激活。在异步更新中，顶点按照随机顺序逐个更新，根据一个随机调度重复选择单个顶点并应用相同的规则，直到没有更多的激活发生。吸收集是任意满足在该规则下进一步更新后保持不变的集合 $A \\subseteq V$。\n\n基本原理和定义：渐进动态是指状态转换在集合包含关系上是单调的，并且不会使顶点失活。同步 $r$-自举渗流的更新算子 $F$ 定义为 $F(A) = A \\cup \\{ v \\in V : |\\{u \\in N(v) : u \\in A\\}| \\ge r \\}$，其中 $N(v)$ 是 $v$ 的邻居集合。算子 $F$ 在由包含关系导出的 $V$ 子集上的偏序关系下是单调的，并且是膨胀的，即 $A \\subseteq F(A)$。在有限集 $V$ 上，重复应用 $F$ 必然会稳定在一个不动点，该不动点是从 $A_0$ 到达的吸收集。异步更新将相同的规则应用于单个顶点，因此实现了单点单调、膨胀的算子，其复合也同样是单调和膨胀的。\n\n任务：根据上述原理，推导对于有限树上的 $r$-自举渗流，异步随机顺序更新达到的最终吸收集是否与同步更新达到的相同。然后，实现一个程序，以经验性地验证在初始激活集 $A_0$ 由每个顶点上激活概率为 $p$ 的独立伯努利试验生成时，同步更新和异步随机顺序更新两种方案下最终吸收集大小的分布是否相等。对于下面测试套件中的每个测试用例 $i$，程序必须：\n- 构建指定的树 $G_i$。\n- 进行 $T$ 次独立试验，每次试验通过以概率 $p$（表示为 $[0,1]$ 中的小数）独立包含每个顶点来抽样 $A_0$。\n- 对于每次试验，从相同的 $A_0$ 开始，计算同步更新和异步随机顺序更新下的最终吸收集大小。\n- 汇总两种方案的最终大小的经验分布，并计算它们之间的全变差距离，定义为 $\\frac{1}{2} \\sum_{k=0}^{n} |P(k) - Q(k)|$，其中 $P(k)$ 和 $Q(k)$ 分别是在同步和异步更新下最终大小为 $k$ 的经验概率。\n\n您的程序必须输出一行，其中包含一个用方括号括起来的逗号分隔列表，列表内容为以下测试套件的全变差距离（每个为浮点数），并按指定顺序排列：\n- 用例 1：路径树，$n=20$，阈值 $r=1$，初始激活概率 $p=0.1$，试验次数 $T=500$。\n- 用例 2：星形树，$n=21$（一个中心，20个叶子），阈值 $r=2$，初始激活概率 $p=0.2$，试验次数 $T=500$。\n- 用例 3：高度为 $h=5$ 的完全二叉树（因此 $n = 2^{h+1} - 1 = 63$），阈值 $r=2$，初始激活概率 $p=0.05$，试验次数 $T=500$。\n- 用例 4：路径树，$n=50$，阈值 $r=10$，初始激活概率 $p=0.3$，试验次数 $T=500$。\n- 用例 5：高度为 $h=4$ 的完全二叉树（因此 $n = 2^{h+1} - 1 = 31$），阈值 $r=1$，初始激活概率 $p=0.0$，试验次数 $T=500$。\n\n最终输出格式要求：您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如 $[x_1,x_2,x_3,x_4,x_5]$），其中每个 $x_i$ 是用例 $i$ 计算出的全变差距离（浮点数）。",
            "solution": "该问题要求完成两项任务：首先，关于同步与异步自举渗流在有限树上的最终状态进行理论推导；其次，通过计算实验对结果进行经验性验证。\n\n### 理论推导\n\n问题的核心是更新方案的选择——同步与异步随机顺序——是否会影响 $r$-自举渗流的最终吸收集。该过程定义在有限图 $G = (V,E)$ 上。动态是渐进的，意味着激活顶点的集合（表示为 $A$）只能增长。\n\n我们来形式化更新算子。初始激活顶点集为 $A_0$。\n\n**同步更新**算子 $F$ 定义为：\n$$F(A) = A \\cup \\{ v \\in V \\setminus A : |N(v) \\cap A| \\ge r \\}$$\n其中 $N(v)$ 是顶点 $v$ 的邻居集合。同步更新下的最终吸收集 $A_{sync}^*$ 是从 $A_0$ 开始迭代 $F$ 得到的不动点，即 $A_{sync}^* = \\lim_{k \\to \\infty} F^k(A_0)$。由于 $V$ 是有限的且 $F$ 是膨胀的（$A \\subseteq F(A)$），这个极限保证存在。\n\n**异步更新**方案涉及应用单点算子。对于每个顶点 $i \\in V$，令 $F_i$ 为只更新顶点 $i$ 的算子：\n$$F_i(A) = \\begin{cases} A \\cup \\{i\\}  \\text{如果 } i \\notin A \\text{ 且 } |N(i) \\cap A| \\ge r \\\\ A  \\text{其他情况} \\end{cases}$$\n异步过程是这些单点算子的一系列应用，$A_{k+1} = F_{i_k}(A_k)$，其中 $\\{i_k\\}$ 是某个顶点序列。最终吸收集 $A_{async}^*$ 是当没有更多单顶点激活可能时达到的不动点。\n\n问题指出，并且这是一个关键属性，即这些算子是**单调的**。对于我们系统中的任何算子 $\\mathcal{F}$（无论是 $F$ 还是任何 $F_i$），单调性意味着如果 $A \\subseteq B \\subseteq V$，则 $\\mathcal{F}(A) \\subseteq \\mathcal{F}(B)$。这个属性对于证明最终状态的等价性至关重要。\n\n我们现在将证明对于任何有限图（该结果不限于树），$A_{sync}^* = A_{async}^*$。我们通过证明集合的相互包含来做到这一点。\n\n**1. 证明 $A_{async}^* \\subseteq A_{sync}^*$**\n\n设异步更新过程中的激活集序列为 $A_0, A_1, A_2, \\ldots, A_{async}^*$，其中 $A_{k+1} = F_{v_k}(A_k)$，对于某个选定的顶点 $v_k$。我们通过归纳法证明对于所有 $k \\ge 0$，$A_k \\subseteq A_{sync}^*$。\n\n*   **基本情况 ($k=0$):** 根据 $A_{sync}^*$ 的定义，它是 $A_0$ 在膨胀算子 $F$ 下的闭包，因此 $A_0 \\subseteq A_{sync}^*$。\n\n*   **归纳步骤:** 假设对于某个 $k \\ge 0$，$A_k \\subseteq A_{sync}^*$。我们需要证明 $A_{k+1} \\subseteq A_{sync}^*$。\n    集合 $A_{k+1}$ 要么是 $A_k$，要么是 $A_k \\cup \\{v_k\\}$。如果 $A_{k+1} = A_k$，则该论断不证自明。\n    如果 $A_{k+1} = A_k \\cup \\{v_k\\}$，这意味着顶点 $v_k$ 被激活了。根据规则，$v_k \\notin A_k$ 且 $|N(v_k) \\cap A_k| \\ge r$。\n    根据归纳假设，$A_k \\subseteq A_{sync}^*$。由集合交集的单调性，$N(v_k) \\cap A_k \\subseteq N(v_k) \\cap A_{sync}^*$。\n    这意味着 $|N(v_k) \\cap A_{sync}^*| \\ge |N(v_k) \\cap A_k| \\ge r$。\n    所以，顶点 $v_k$ 相对于集合 $A_{sync}^*$ 满足激活条件。\n    由于 $A_{sync}^*$ 是同步算子 $F$ 的不动点，我们有 $F(A_{sync}^*) = A_{sync}^*$。这意味着在 $A_{sync}^*$ 之外没有可以被它激活的顶点。因为 $v_k$ 可以从 $A_{sync}^*$ 激活，所以必然有 $v_k \\in A_{sync}^*$。\n    因此，$A_{k+1} = A_k \\cup \\{v_k\\} \\subseteq A_{sync}^* \\cup \\{v_k\\} = A_{sync}^*$。\n\n通过归纳法，异步序列中的每个集合都是 $A_{sync}^*$ 的子集。这也包括最终的吸收集，所以 $A_{async}^* \\subseteq A_{sync}^*$。\n\n**2. 证明 $A_{sync}^* \\subseteq A_{async}^*$**\n\n设同步更新过程中的激活集序列为 $A^{(0)}, A^{(1)}, A^{(2)}, \\ldots$，其中 $A^{(0)}=A_0$ 且 $A^{(k+1)} = F(A^{(k)})$。这些集合的并集是 $A_{sync}^*$。我们通过归纳法证明对于所有 $k \\ge 0$，$A^{(k)} \\subseteq A_{async}^*$。\n\n*   **基本情况 ($k=0$):** $A^{(0)} = A_0$。由于异步过程是渐进的并且从 $A_0$ 开始，我们有 $A_0 \\subseteq A_{async}^*$。\n\n*   **归纳步骤:** 假设对于某个 $k \\ge 0$，$A^{(k)} \\subseteq A_{async}^*$。我们需要证明 $A^{(k+1)} \\subseteq A_{async}^*$。\n    根据定义，$A^{(k+1)} = F(A^{(k)}) = A^{(k)} \\cup \\{v \\in V \\setminus A^{(k)} : |N(v) \\cap A^{(k)}| \\ge r\\}$。\n    令 $v$ 为 $A^{(k+1)}$ 中的任意顶点。\n    如果 $v \\in A^{(k)}$，则根据归纳假设，$v \\in A_{async}^*$。\n    如果 $v \\notin A^{(k)}$，则它的激活意味着 $|N(v) \\cap A^{(k)}| \\ge r$。\n    根据归纳假设，$A^{(k)} \\subseteq A_{async}^*$。因此，$|N(v) \\cap A_{async}^*| \\ge |N(v) \\cap A^{(k)}| \\ge r$。\n    这意味着顶点 $v$ 相对于集合 $A_{async}^*$ 满足激活条件。\n    由于 $A_{async}^*$ 是异步过程的吸收集，其外部的任何顶点都不能被激活。形式上，对于任何 $u \\notin A_{async}^*$，$|N(u) \\cap A_{async}^*|  r$。\n    由于 $v$ 满足条件 $|N(v) \\cap A_{async}^*| \\ge r$，因此必然有 $v \\in A_{async}^*$。\n    因此，$A^{(k+1)}$ 中的任何顶点 $v$ 也都在 $A_{async}^*$ 中，这意味着 $A^{(k+1)} \\subseteq A_{async}^*$。\n\n通过归纳法，$A^{(k)} \\subseteq A_{async}^*$ 对于所有 $k$ 成立。因此，它们的并集 $A_{sync}^* = \\bigcup_{k \\ge 0} A^{(k)}$ 也必然是 $A_{async}^*$ 的子集。\n\n**结论**\n\n我们已经证明了 $A_{async}^* \\subseteq A_{sync}^*$ 和 $A_{sync}^* \\subseteq A_{async}^*$，因此我们得出结论 $A_{sync}^* = A_{async}^*$。对于任何有限图上的任何 $r$-自举渗流过程，最终的吸收集与更新方案（同步或异步）无关。\n\n这个理论结果意味着，对于任何给定的初始激活集 $A_0$，两种方案的最终吸收集大小将是相同的。因此，当 $A_0$ 是随机抽样时，两种方案得到的最终大小的概率分布也必须是相同的。这两个经验分布之间的全变差距离因此应为 $0.0$。模拟中任何非零结果都应归因于有限样本噪声，而非底层理论的差异。\n\n所提供的实现将为几个测试用例计算这个距离。基于此推导，预期的输出是一个全为 $0.0$ 或接近 $0.0$ 的全变差距离列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef create_path_graph(n):\n    \"\"\"Creates an adjacency list for a path graph of n vertices.\"\"\"\n    if n == 0:\n        return {}\n    adj = {i: [] for i in range(n)}\n    for i in range(n - 1):\n        adj[i].append(i + 1)\n        adj[i + 1].append(i)\n    return adj\n\ndef create_star_graph(n):\n    \"\"\"Creates an adjacency list for a star graph of n vertices.\"\"\"\n    if n == 0:\n        return {}\n    adj = {i: [] for i in range(n)}\n    center = 0\n    for i in range(1, n):\n        adj[center].append(i)\n        adj[i].append(center)\n    return adj\n\ndef create_binary_tree(h):\n    \"\"\"Creates an adjacency list for a complete binary tree of height h.\"\"\"\n    n = 2**(h + 1) - 1\n    if n == 0:\n        return {}\n    adj = {i: [] for i in range(n)}\n    # Iterate through all possible parent nodes\n    for i in range((n - 1) // 2 + 1):\n        left_child = 2 * i + 1\n        right_child = 2 * i + 2\n        if left_child  n:\n            adj[i].append(left_child)\n            adj[left_child].append(i)\n        if right_child  n:\n            adj[i].append(right_child)\n            adj[right_child].append(i)\n    return adj\n\ndef simulate_sync(adj, r, initial_active):\n    \"\"\"Simulates r-bootstrap percolation with synchronous updates.\"\"\"\n    n = len(adj)\n    active = initial_active.copy()\n    \n    while True:\n        to_activate = []\n        for i in range(n):\n            if not active[i]:\n                active_neighbors = 0\n                for neighbor in adj[i]:\n                    if active[neighbor]:\n                        active_neighbors += 1\n                if active_neighbors >= r:\n                    to_activate.append(i)\n        \n        if not to_activate:\n            break\n        \n        for i in to_activate:\n            active[i] = True\n            \n    return np.sum(active)\n\ndef simulate_async(adj, r, initial_active):\n    \"\"\"Simulates r-bootstrap percolation with asynchronous random sequential updates.\"\"\"\n    n = len(adj)\n    active = initial_active.copy()\n    \n    while True:\n        changed_in_pass = False\n        update_order = np.random.permutation(n)\n        for i in update_order:\n            if not active[i]:\n                active_neighbors = 0\n                for neighbor in adj[i]:\n                    if active[neighbor]:\n                        active_neighbors += 1\n                if active_neighbors >= r:\n                    active[i] = True\n                    changed_in_pass = True\n        \n        if not changed_in_pass:\n            break\n            \n    return np.sum(active)\n\ndef solve():\n    \"\"\"\n    Runs the empirical verification for the test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        {'type': 'path', 'params': {'n': 20}, 'r': 1, 'p': 0.1, 'T': 500},\n        {'type': 'star', 'params': {'n': 21}, 'r': 2, 'p': 0.2, 'T': 500},\n        {'type': 'binary_tree', 'params': {'h': 5}, 'r': 2, 'p': 0.05, 'T': 500},\n        {'type': 'path', 'params': {'n': 50}, 'r': 10, 'p': 0.3, 'T': 500},\n        {'type': 'binary_tree', 'params': {'h': 4}, 'r': 1, 'p': 0.0, 'T': 500},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        T = case['T']\n        p = case['p']\n        r = case['r']\n        \n        if case['type'] == 'path':\n            n = case['params']['n']\n            adj = create_path_graph(n)\n        elif case['type'] == 'star':\n            n = case['params']['n']\n            adj = create_star_graph(n)\n        elif case['type'] == 'binary_tree':\n            h = case['params']['h']\n            n = 2**(h + 1) - 1\n            adj = create_binary_tree(h)\n\n        sync_hist = np.zeros(n + 1, dtype=np.int32)\n        async_hist = np.zeros(n + 1, dtype=np.int32)\n        \n        for _ in range(T):\n            # Generate the same initial active set for both schemes in each trial\n            initial_active = np.random.rand(n)  p\n            \n            # Run synchronous simulation\n            sync_size = simulate_sync(adj, r, initial_active)\n            sync_hist[sync_size] += 1\n            \n            # Run asynchronous simulation\n            async_size = simulate_async(adj, r, initial_active)\n            async_hist[async_size] += 1\n\n        # Calculate empirical probability distributions\n        P_sync = sync_hist / T\n        P_async = async_hist / T\n        \n        # Calculate Total Variation Distance\n        tv_distance = 0.5 * np.sum(np.abs(P_sync - P_async))\n        results.append(tv_distance)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}