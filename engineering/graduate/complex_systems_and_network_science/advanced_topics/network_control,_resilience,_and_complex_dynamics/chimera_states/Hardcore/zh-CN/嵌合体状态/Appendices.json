{
    "hands_on_practices": [
        {
            "introduction": "在深入复杂的分析之前，掌握数值实验的基本工作流程至关重要。本练习将引导你梳理寻找振子网络中嵌合态所需的仿真设置逻辑顺序，从定义系统参数到分析最终输出。 掌握这一过程是成功进行任何非线性动力学计算研究的第一步。",
            "id": "1666625",
            "problem": "一名非线性动力学导论课程的学生，其任务是数值研究嵌合态（chimera states）。这是一种特殊的时空模式，出现在相同振子的网络中，其中一部分振子同步，而其余振子则保持非相干状态。该学生考虑一个由 $N$ 个相同相位振子组成的一维环，它们之间存在非局域耦合，由 Kuramoto-Sakaguchi 方程描述：\n$$ \\frac{d\\theta_i}{dt} = \\omega - \\frac{K}{2R+1} \\sum_{j=i-R}^{j=i+R} \\sin(\\theta_i - \\theta_j + \\alpha) $$\n此处，$\\theta_i$ 是第 $i$ 个振子的相位（下标对 $N$ 取模），$\\omega$ 是均匀的自然频率，$K$ 是耦合强度，$R$ 是定义邻域大小的耦合半径，$\\alpha$ 是一个相位延迟参数。\n\n为了找到嵌合态，学生必须按精确的顺序执行一系列步骤。以下是进行此数值实验所需的五个基本操作：\n\n(i) 使用数值积分方法（例如，龙格-库塔法）将包含 $N$ 个耦合常微分方程（ODE）的系统在时间上向前演化大量的步长。\n(ii) 指定系统的固定参数：振子数 $N$、它们的自然频率 $\\omega$、耦合强度 $K$、耦合半径 $R$ 以及相位延迟 $\\alpha$。\n(iii) 演化之后，分析振子的行为，以检查嵌合态的标志性特征：一群具有相同有效频率的振子与另一群具有不同有效频率分布的振子共存。\n(iv) 为系统设置初始条件，即在时间 $t=0$ 时为每个振子分配一个相位 $\\theta_i(0)$。对于嵌合态，通常需要一个特殊准备的非均匀状态。\n(v) 忽略时间演化初始部分的数据，以确保任何暂态行为已经衰减，且系统已稳定到其长期吸引子上。\n\n以下哪个选项代表了成功设置并执行模拟以寻找嵌合态的正确逻辑顺序？\n\nA. (ii) → (iv) → (i) → (v) → (iii)\n\nB. (ii) → (iv) → (iii) → (i) → (v)\n\nC. (iv) → (ii) → (i) → (v) → (iii)\n\nD. (ii) → (i) → (iv) → (v) → (iii)\n\nE. (ii) → (iv) → (i) → (iii) → (v)",
            "solution": "我们需要确定在一个由 Kuramoto-Sakaguchi 方程控制的、$N$ 个非局域耦合相位振子组成的给定系统中，数值搜索嵌合态的正确逻辑操作顺序。\n$$\n\\frac{d\\theta_{i}}{dt}=\\omega-\\frac{K}{2R+1}\\sum_{j=i-R}^{i+R}\\sin\\!\\big(\\theta_{i}-\\theta_{j}+\\alpha\\big),\n$$\n其中下标对 $N$ 取模。这为 $N$ 个耦合的一阶常微分方程定义了一个初值问题。对于此类问题，必须首先在进行任何时间积分之前完全指定向量场和初始条件，然后向前积分，去除暂态以关注长期行为（吸引子），最后分析能够揭示嵌合态特征的观测量。\n\n首先，必须指定模型的固定参数，以定义常微分方程右侧的映射 $f:\\mathbb{T}^{N}\\to\\mathbb{R}^{N}$。将系统简写为\n$$\n\\dot{\\theta}_{i}=f_{i}(\\theta;\\omega,K,R,\\alpha), \\quad i\\in\\{1,\\dots,N\\},\n$$\n我们可以看到向量场依赖于常数 $N$、$\\omega$、$K$、$R$ 和 $\\alpha$。没有这些参数，常微分方程就未完全定义。因此，步骤 (ii) 必须在所有其他步骤之前。\n\n其次，一个初值问题需要一个初始条件。必须为所有的 $i$ 分配相位 $\\theta_{i}(0)$。由于目标是找到嵌合态，通常会选择一个特殊准备的非均匀初始条件，以使动力学倾向于相干和非相干群组的共存。因此，步骤 (iv) 自然地跟在步骤 (ii) 指定参数之后。\n\n第三，在指定了向量场 $f$ 和初始条件 $\\theta(0)$ 之后，就可以使用适当的方法（例如，龙格-库塔格式）将常微分方程在时间上向前进行数值积分，这是步骤 (i)。这将产生一条轨迹 $t\\mapsto\\theta(t)$。\n\n第四，为了观察长期行为，需要丢弃一个初始的暂态区间，以使轨迹接近其吸引子。记暂态时间为 $T_{\\mathrm{trans}}$，并只考虑 $t\\geq T_{\\mathrm{trans}}$ 的数据。这是步骤 (v)。这种做法确保了任何由初始条件引起的短时效应不会污染渐近诊断。\n\n第五，分析暂态后的动力学，以检测嵌合态的标志性特征：同步子群和非相干子群的共存。一个标准的诊断方法是计算每个振子的有效频率，即在暂态之后进行长时间平均：\n$$\n\\Omega_{i}=\\lim_{T\\to\\infty}\\frac{\\theta_{i}(T_{\\mathrm{trans}}+T)-\\theta_{i}(T_{\\mathrm{trans}})}{T}.\n$$\n在嵌合态中，存在一个下标子集，其中 $\\Omega_{i}$ 取相同的值（锁相组），以及一个互补的子集，其中 $\\Omega_{i}$ 在一个区间内分布（漂移组）。这个分析对应于步骤 (iii)，并且必须在积分和去除暂态之后进行。\n\n将逻辑上必要的顺序组合起来，得到序列：指定参数 (ii) → 设置初始条件 (iv) → 积分 (i) → 丢弃暂态 (v) → 分析嵌合态 (iii)。在给定的选项中，这对应于选项 A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "研究嵌合态的一个关键挑战是，如何将其与其它模式（例如含噪声的聚类态）进行客观区分。本练习介绍了一种名为“间隙范围比”（Gap-to-Range Ratio, $\\mathcal{C}$）的统计指标，用以量化振子频率数据集中的聚类程度。 通过应用此度量，你将学会一种分析仿真输出的实用技术，从而对系统的集体行为进行数据驱动的分类。",
            "id": "1666687",
            "problem": "在复杂系统的研究中，嵌合态是在相同耦合振子网络中观察到的一种特殊的时空模式，其中系统的一部分表现出同步行为，而另一部分则保持非相干状态。将真正的嵌合态与其他模式（例如噪声多簇态）区分开来，是非线性动力学中的一个重要挑战。\n\n一位研究人员提出了一种称为间隙-范围比（GRR）的统计量，用于量化一维数据集中的聚类程度。GRR 记作 $\\mathcal{C}$，由一组 $N$ 个数据点按如下方式计算：\n1. 将数据点 $x_i$ 排序，得到一个有序序列 $x_{(1)} \\le x_{(2)} \\le \\dots \\le x_{(N)}$。\n2. 计算排序后各点之间的连续间隙：$g_i = x_{(i+1)} - x_{(i)}$，其中 $i = 1, \\dots, N-1$。\n3. GRR 定义为最大间隙与平均间隙之比。这可以用以下简化公式表示：\n$$ \\mathcal{C} = \\frac{(N-1) \\max_{i}\\{g_i\\}}{x_{(N)} - x_{(1)}} $$\n\n研究人员将此度量应用于在一次数值实验中观察到的 $N=12$ 个振子的时间平均角频率。记录的频率（单位为弧度/秒）由以下集合给出：\n$$ \\{3.14, 4.15, 3.12, 5.82, 3.19, 5.79, 3.09, 5.88, 3.15, 5.85, 3.11, 4.22\\} $$\n\n计算此数据集的间隙-范围比 $\\mathcal{C}$ 的值。将最终答案四舍五入到三位有效数字。",
            "solution": "给定 $N=12$ 个数据点和间隙-范围比的定义\n$$\n\\mathcal{C}=\\frac{(N-1)\\max_{i}\\{g_{i}\\}}{x_{(N)}-x_{(1)}}, \\quad g_{i}=x_{(i+1)}-x_{(i)}.\n$$\n第一步：对数据进行排序。排序后的值为\n$$\nx_{(1)}=3.09,\\ x_{(2)}=3.11,\\ x_{(3)}=3.12,\\ x_{(4)}=3.14,\\ x_{(5)}=3.15,\\ x_{(6)}=3.19,\\ x_{(7)}=4.15,\\ x_{(8)}=4.22,\\ x_{(9)}=5.79,\\ x_{(10)}=5.82,\\ x_{(11)}=5.85,\\ x_{(12)}=5.88.\n$$\n第二步：计算连续间隙 $g_{i}=x_{(i+1)}-x_{(i)}$，其中 $i=1,\\dots,11$：\n$$\n\\begin{aligned}\ng_1=3.11-3.09=0.02, \\quad g_2=3.12-3.11=0.01, \\quad g_3=3.14-3.12=0.02, \\\\\ng_4=3.15-3.14=0.01, \\quad g_5=3.19-3.15=0.04, \\quad g_6=4.15-3.19=0.96, \\\\\ng_7=4.22-4.15=0.07, \\quad g_8=5.79-4.22=1.57, \\quad g_9=5.82-5.79=0.03, \\\\\ng_{10}=5.85-5.82=0.03, \\quad g_{11}=5.88-5.85=0.03.\n\\end{aligned}\n$$\n因此，$\\max_{i}\\{g_{i}\\}=1.57$。\n\n第三步：计算范围 $x_{(N)}-x_{(1)}=5.88-3.09=2.79$。\n\n第四步：应用公式，其中 $N-1=11$：\n$$\n\\mathcal{C}=\\frac{11\\cdot 1.57}{2.79}=\\frac{17.27}{2.79}\\approx 6.19,\n$$\n其中最终值被四舍五入到三位有效数字。",
            "answer": "$$\\boxed{6.19}$$"
        },
        {
            "introduction": "从简单的度量标准发展到稳健的分析工具，是高级研究的一个标志。这项综合练习要求你设计并实现一个完整算法，该算法使用局域 Kuramoto 序参量 ($R_i$) 将网络分割为相干和非相干区域。 你不仅需要对数据进行分类，还需要对照合成的嵌合态数据来验证你的算法，这是开发可靠科学软件的一项关键技能。",
            "id": "4268035",
            "problem": "考虑一个由 $N$ 个相位振子组成的环形网络，其相位为 $\\theta_i \\in [0,2\\pi)$（以弧度为单位），索引为 $i \\in \\{0,1,\\dots,N-1\\}$，并具有周期性边界条件。奇美拉态是一种时空模式，其中一部分振子是相位相干的，而其互补的另一部分则是相位非相干的。从基本定义出发，设计并实现一个算法，该算法使用局域序参量的阈值将环形网络分割为相干域和非相干域，然后根据具有已知基准域的合成数据来验证分类结果。\n\n推导的基础是 Kuramoto 序参量（KOP）。对于给定的相位集合 $\\{\\theta_j\\}$，全局 KOP 定义为\n$$\nR = \\left| \\frac{1}{N} \\sum_{j=0}^{N-1} e^{\\mathrm{i} \\theta_j} \\right| ,\n$$\n它衡量了网络的整体相位相干性。为了执行空间分割，定义节点 $i$ 的局域邻域 $\\mathcal{N}_i$ 为索引集合\n$$\n\\mathcal{N}_i = \\{i-w, i-w+1, \\dots, i+w\\} \\ (\\text{模 } N),\n$$\n其中 $w$ 是一个正整数，邻域大小为 $m = 2w+1$。节点 $i$ 处的局域 KOP 则为\n$$\nR_i = \\left| \\frac{1}{m} \\sum_{j \\in \\mathcal{N}_i} e^{\\mathrm{i} \\theta_j} \\right| .\n$$\n在相位局域相干的域中，$R_i$ 接近 $1$；而在具有近似均匀随机相位的非相干区域中，单位复数的平均值趋于抵消，使得随着 $m$ 的增长，$R_i$ 接近 $0$。\n\n分类规则。给定两个满足 $1 \\ge T_{\\text{coh}} \\ge T_{\\text{incoh}} \\ge 0$ 的阈值 $T_{\\text{coh}}$ 和 $T_{\\text{incoh}}$，将每个节点 $i$ 分类如下：\n- 如果 $R_i \\ge T_{\\text{coh}}$，则为相干，\n- 如果 $R_i \\le T_{\\text{incoh}}$，则为非相干，\n- 否则为不确定。\n整个过程中的角度单位是弧度。\n\n合成数据生成。按如下方式构建具有已知基准标签的合成奇美拉快照。固定 $N$、相干比例 $f \\in [0,1]$、相位斜率 $k \\ge 0$（单位：弧度/节点），以及相干域和非相干域的噪声水平 $\\sigma_c \\ge 0$ 和 $\\sigma_u \\ge 0$。设 $C = \\lfloor f N \\rfloor$ 为相干域的大小，占据索引 $i = 0,1,\\dots,C-1$，非相干域占据索引 $i = C,\\dots,N-1$。从 $\\mathrm{Uniform}(0,2\\pi)$ 中抽取一个基准相位 $\\theta_0$。通过以下方式生成相位：\n$$\n\\theta_i =\n\\begin{cases}\n\\theta_0 + k i + \\eta_i \\pmod{2\\pi},  i \\in \\{0,\\dots,C-1\\},\\ \\eta_i \\sim \\mathcal{N}(0,\\sigma_c^2),\\\\\n\\phi_i + \\xi_i \\pmod{2\\pi},  i \\in \\{C,\\dots,N-1\\},\\ \\phi_i \\sim \\mathrm{Uniform}(0,2\\pi),\\ \\xi_i \\sim \\mathcal{N}(0,\\sigma_u^2).\n\\end{cases}\n$$\n定义基准标签 $y_i = 1$（如果 $i  C$）和 $y_i = 0$（否则）。\n\n验证指标。设 $\\hat{y}_i \\in \\{1,0,-1\\}$ 是基于上述规则对节点 $i$ 的预测标签，其中 $-1$ 表示不确定。仅考虑已覆盖的节点（$\\hat{y}_i \\ne -1$）来评估分类。定义覆盖率\n$$\n\\text{coverage} = \\frac{\\#\\{i : \\hat{y}_i \\ne -1\\}}{N} .\n$$\n在已覆盖的子集上，定义准确率\n$$\n\\text{accuracy} = \n\\begin{cases}\n\\frac{\\#\\{i : \\hat{y}_i = y_i \\}}{\\#\\{i : \\hat{y}_i \\ne -1\\}},  \\text{若 } \\#\\{i : \\hat{y}_i \\ne -1\\} > 0,\\\\\n0,  \\text{否则}.\n\\end{cases}\n$$\n对于已覆盖子集上的每个类别 $c \\in \\{0,1\\}$，定义精确率 $\\text{Prec}_c = \\frac{\\text{TP}_c}{\\text{TP}_c + \\text{FP}_c}$ 和召回率 $\\text{Rec}_c = \\frac{\\text{TP}_c}{\\text{TP}_c + \\text{FN}_c}$，并约定除以零的结果为 $0$。定义类别 $F_1$ 分数\n$$\nF_{1,c} =\n\\begin{cases}\n\\frac{2 \\,\\text{Prec}_c \\,\\text{Rec}_c}{\\text{Prec}_c + \\text{Rec}_c},  \\text{若 } \\text{Prec}_c + \\text{Rec}_c > 0,\\\\\n0,  \\text{否则},\n\\end{cases}\n$$\n以及宏 $F_1$ 分数 $F_1^{\\text{macro}} = \\tfrac{1}{2}(F_{1,0} + F_{1,1})$。如果覆盖率为零，则将准确率和 $F_1^{\\text{macro}}$ 均设为 $0$。\n\n算法任务。实现：\n1. 一个按规定生成合成奇美拉快照的生成器，在给定种子的情况下具有可复现的随机性。\n2. 在环上使用半宽度为 $w$ 的邻域，计算所有 $i$ 的局域 KOP $R_i$。\n3. 使用阈值 $T_{\\text{coh}}$ 和 $T_{\\text{incoh}}$ 对节点进行分割。\n4. 使用上面定义的覆盖率、准确率和宏 $F_1$ 指标，仅在已覆盖节点上对基准进行验证。\n\n测试套件。您的程序必须在以下参数集上评估算法，并按顺序返回每个集合的指标。角度以弧度为单位，邻域使用周期性索引。\n- 情况 1（一般混合奇美拉态，正常路径）：$N=128$, $w=4$（因此 $m=9$），$T_{\\text{coh}}=0.92$, $T_{\\text{incoh}}=0.60$, $f=0.50$, $k=0.02$, $\\sigma_c=0.03$, $\\sigma_u=0.20$, 种子 $=1$。\n- 情况 2（完全相干域）：$N=128$, $w=4$, $T_{\\text{coh}}=0.95$, $T_{\\text{incoh}}=0.50$, $f=1.00$, $k=0.01$, $\\sigma_c=0.02$, $\\sigma_u=0.20$（未使用但已提供），种子 $=2$。\n- 情况 3（高噪声，可能出现不确定性）：$N=128$, $w=6$（因此 $m=13$），$T_{\\text{coh}}=0.90$, $T_{\\text{incoh}}=0.70$, $f=0.50$, $k=0.02$, $\\sigma_c=0.30$, $\\sigma_u=0.30$, 种子 $=3$。\n- 情况 4（单阈值边界，无不确定性）：$N=128$, $w=2$（因此 $m=5$），$T_{\\text{coh}}=0.80$, $T_{\\text{incoh}}=0.80$, $f=0.30$, $k=0.03$, $\\sigma_c=0.05$, $\\sigma_u=0.40$, 种子 $=4$。\n\n最终输出格式。您的程序应生成一行输出，其中包含四个情况的结果，形式为方括号括起来的逗号分隔列表，每个情况的结果是列表 $[\\text{accuracy},\\text{coverage},F_1^{\\text{macro}}]$。例如，输出必须具有以下形式\n$$\n\\big[ [a_1,c_1,f_1], [a_2,c_2,f_2], [a_3,c_3,f_3], [a_4,c_4,f_4] \\big],\n$$\n其中每个 $a_i$、$c_i$ 和 $f_i$ 都是实数。",
            "solution": "该问题要求设计并实现一种算法，用于识别相位振子环形网络中的奇美拉态。这包括生成具有已知基准域的合成数据，计算局域序参量以对节点进行分类，并使用明确定义的指标评估分类性能。该方法是基于网络科学和统计分析的基本原理系统地构建的。\n\n解决方案分四个阶段进行：（1）生成代表奇美拉态的合成相位数据，（2）为每个振子计算局域 Kuramoto 序参量，（3）基于此参量将振子分为相干、非相干或不确定状态，以及（4）使用指定的性能指标对照基准验证分类。\n\n**1. 合成奇美拉态的生成**\n\n为了验证分类算法，我们首先构建一个具有已知相干域和非相干域的振子相位合成快照。该网络由环上的 $N$ 个振子组成，索引为 $i \\in \\{0, 1, \\dots, N-1\\}$。\n\n基准结构由相干比例 $f \\in [0,1]$ 定义。一个由 $C = \\lfloor f N \\rfloor$ 个振子组成的块，其索引为 $i \\in \\{0, 1, \\dots, C-1\\}$，构成相干域（基准标签 $y_i=1$）。剩余的 $N-C$ 个振子，其索引为 $i \\in \\{C, \\dots, N-1\\}$，构成非相干域（基准标签 $y_i=0$）。\n\n相位 $\\theta_i \\in [0, 2\\pi)$ 按以下方式生成，使用由给定种子初始化的可复现伪随机数生成器：\n\n- **相干域 ($i \\in \\{0, \\dots, C-1\\}$)**：相位被设计为强相关。从均匀分布中抽取单个基准相位 $\\theta_{\\text{base}} \\sim \\mathrm{Uniform}(0, 2\\pi)$。然后，相干振子的相位由一个具有相位斜率 $k \\ge 0$（单位：弧度/节点）的线性级数加上少量高斯噪声确定。振子 $i$ 的相位由下式给出：\n    $$\n    \\theta_i = (\\theta_{\\text{base}} + k i + \\eta_i) \\pmod{2\\pi}\n    $$\n    其中噪声项 $\\eta_i$ 从均值为 $0$、方差为 $\\sigma_c^2$ 的正态分布中抽取，即 $\\eta_i \\sim \\mathcal{N}(0, \\sigma_c^2)$。较小的噪声水平 $\\sigma_c$ 确保相位保持在确定性序列 $\\theta_{\\text{base}} + ki$ 附近。\n\n- **非相干域 ($i \\in \\{C, \\dots, N-1\\}$)**：相位被设计为不相关。对于此域中的每个振子 $i$，从均匀分布 $\\mathrm{Uniform}(0, 2\\pi)$ 中抽取一个新的独立相位 $\\phi_i$。同时还添加了一个额外的高斯噪声项。振子 $i$ 的相位为：\n    $$\n    \\theta_i = (\\phi_i + \\xi_i) \\pmod{2\\pi}\n    $$\n    其中噪声项 $\\xi_i$ 从正态分布 $\\mathcal{N}(0, \\sigma_u^2)$ 中抽取。均匀分布的基准相位 $\\phi_i$ 和噪声 $\\xi_i$ 的组合产生了一组很大程度上不相关的相位。\n\n模 $2\\pi$ 运算确保所有相位都位于区间 $[0, 2\\pi)$ 内。\n\n**2. 局域相干性测量**\n\n为了在空间上区分相干和非相干区域，我们采用局域 Kuramoto 序参量（KOP）$R_i$。该指标量化了每个振子局域邻域内的相位同步程度。\n\n振子 $i$ 的邻域 $\\mathcal{N}_i$ 定义为以 $i$ 为中心的 $m = 2w+1$ 个振子的集合，其中 $w$ 是邻域半宽度。由于是环形拓扑，索引对 $N$ 取模：\n$$\n\\mathcal{N}_i = \\{ (i-w+j) \\pmod N \\mid j=0, 1, \\dots, 2w \\}\n$$\n局域 KOP $R_i$ 是邻域 $\\mathcal{N}_i$ 中所有振子 $j$ 的相量 $e^{\\mathrm{i}\\theta_j}$ 的平均值的模：\n$$\nR_i = \\left| \\frac{1}{m} \\sum_{j \\in \\mathcal{N}_i} e^{\\mathrm{i} \\theta_j} \\right|\n$$\n从概念上讲，如果邻域中的相位 $\\theta_j$ 几乎相同，则复平面上对应的单位矢量将指向相似的方向，其平均值的模 $R_i$ 将接近 $1$。相反，如果相位均匀分布，这些矢量将趋于相互抵消，导致平均值的模 $R_i$ 接近 $0$。\n\n在计算上，此过程通过首先将相位向量 $\\boldsymbol{\\theta}$ 转换为复相量向量 $\\mathbf{z} = (e^{\\mathrm{i}\\theta_0}, \\dots, e^{\\mathrm{i}\\theta_{N-1}})$ 来对每个振子 $i$ 进行。然后，对于每个 $i$，我们对 $\\mathcal{N}_i$ 中索引对应的相量求和，除以邻域大小 $m$，然后取绝对值。周期性边界条件通过按需环绕索引来处理。\n\n**3. 基于阈值的分割**\n\n在为每个振子计算出局域序参量 $R_i$ 后，我们就可以对每个节点进行分类。分类规则使用两个阈值 $T_{\\text{coh}}$ 和 $T_{\\text{incoh}}$，它们必须满足 $1 \\ge T_{\\text{coh}} \\ge T_{\\text{incoh}} \\ge 0$。每个节点 $i$ 的预测标签 $\\hat{y}_i$ 按如下方式分配：\n\n- 如果 $R_i \\ge T_{\\text{coh}}$，则节点被分类为**相干**（$\\hat{y}_i = 1$）。\n- 如果 $R_i \\le T_{\\text{incoh}}$，则节点被分类为**非相干**（$\\hat{y}_i = 0$）。\n- 如果 $T_{\\text{incoh}}  R_i  T_{\\text{coh}}$，则节点的状态为**不确定**（$\\hat{y}_i = -1$）。\n\n该规则将网络划分为三个集合：一个预测为相干的集合，一个预测为非相干的集合，以及一个分类不明确的集合。$T_{\\text{coh}}$ 和 $T_{\\text{incoh}}$ 之间的间隔创建了一个缓冲区，减少了对具有中等 $R_i$ 值的节点的错误分类，这些节点通常出现在域的边界或高噪声区域。\n\n**4. 定量验证**\n\n最后一步是评估分类算法的性能。评估仅在未被分类为不确定的节点子集上进行（即 $\\hat{y}_i \\in \\{0, 1\\}$）。\n\n计算以下指标：\n\n- **覆盖率（Coverage）**：获得确定性分类（相干或非相干）的节点比例。\n    $$\n    \\text{coverage} = \\frac{\\#\\{i : \\hat{y}_i \\ne -1\\}}{N}\n    $$\n- **准确率（Accuracy）**：在已覆盖的节点中，被正确分类的比例。\n    $$\n    \\text{accuracy} = \\frac{\\#\\{i : \\hat{y}_i = y_i \\text{ and } \\hat{y}_i \\ne -1\\}}{\\#\\{i : \\hat{y}_i \\ne -1\\}}\n    $$\n    如果覆盖率为 $0$，则准确率定义为 $0$。\n\n- **宏 F1 分数（Macro $F_1$ Score）**：该指标为两个类别（相干和非相干）提供了一个平衡的性能度量。它是个类别 F1 分数的平均值。对于每个类别 $c \\in \\{0, 1\\}$，我们在已覆盖子集上计算精确率（$\\text{Prec}_c$）和召回率（$\\text{Rec}_c$）。\n    - 真阳性（$\\text{TP}_c$）：$\\#\\{i : \\hat{y}_i=c \\text{ and } y_i=c\\}$。\n    - 伪阳性（$\\text{FP}_c$）：$\\#\\{i : \\hat{y}_i=c \\text{ and } y_i \\ne c\\}$。\n    - 伪阴性（$\\text{FN}_c$）：$\\#\\{i : \\hat{y}_i \\ne c \\text{ and } y_i=c \\text{ and } \\hat{y}_i \\ne -1\\}$。\n    \n    精确率和召回率则为：\n    $$\n    \\text{Prec}_c = \\frac{\\text{TP}_c}{\\text{TP}_c + \\text{FP}_c}, \\quad \\text{Rec}_c = \\frac{\\text{TP}_c}{\\text{TP}_c + \\text{FN}_c}\n    $$\n    其中除以零的结果为 $0$。类别 $c$ 的 F1 分数是精确率和召回率的调和平均值：\n    $$\n    F_{1,c} = \\frac{2 \\cdot \\text{Prec}_c \\cdot \\text{Rec}_c}{\\text{Prec}_c + \\text{Rec}_c}\n    $$\n    同样，除以零的结果为 $0$。最后，宏平均 F1 分数为：\n    $$\n    F_1^{\\text{macro}} = \\frac{1}{2}(F_{1,0} + F_{1,1})\n    $$\n    如果覆盖率为 $0$，$F_1^{\\text{macro}}$ 也设为 $0$。\n\n这四个步骤构成了一个基于局域相位相干性来生成、分析和验证奇美拉态检测算法的完整流程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_chimera_snapshot(N, f, k, sigma_c, sigma_u, seed):\n    \"\"\"\n    Generates a synthetic chimera snapshot with ground truth labels.\n\n    Args:\n        N (int): Number of oscillators.\n        f (float): Fraction of coherent oscillators.\n        k (float): Phase slope for the coherent domain.\n        sigma_c (float): Noise level (std dev) for the coherent domain.\n        sigma_u (float): Noise level (std dev) for the incoherent domain.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The array of phases theta.\n            - np.ndarray: The ground truth labels y (1 for coherent, 0 for incoherent).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    theta = np.zeros(N)\n    y = np.zeros(N, dtype=int)\n    \n    # Coherent domain\n    C = int(np.floor(f * N))\n    if C  0:\n        y[:C] = 1\n        base_phase = rng.uniform(0, 2 * np.pi)\n        coherent_indices = np.arange(C)\n        noise_c = rng.normal(0, sigma_c, size=C)\n        theta[:C] = (base_phase + k * coherent_indices + noise_c) % (2 * np.pi)\n        \n    # Incoherent domain\n    if N - C  0:\n        incoherent_indices = np.arange(C, N)\n        num_incoherent = len(incoherent_indices)\n        phi = rng.uniform(0, 2 * np.pi, size=num_incoherent)\n        noise_u = rng.normal(0, sigma_u, size=num_incoherent)\n        theta[C:] = (phi + noise_u) % (2 * np.pi)\n        \n    return theta, y\n\ndef compute_local_kop(theta, w):\n    \"\"\"\n    Computes the local Kuramoto order parameter for each oscillator.\n\n    Args:\n        theta (np.ndarray): Array of oscillator phases.\n        w (int): Half-width of the neighborhood.\n\n    Returns:\n        np.ndarray: The array of local KOP values R_i.\n    \"\"\"\n    N = len(theta)\n    m = 2 * w + 1\n    R = np.zeros(N)\n    phasors = np.exp(1j * theta)\n    \n    # Pad the phasors array to handle periodic boundary conditions easily\n    padded_phasors = np.pad(phasors, (w, w), mode='wrap')\n    \n    for i in range(N):\n        # The neighborhood of node i in the original array corresponds to\n        # the slice from i to i + 2w in the padded array.\n        neighborhood_sum = np.sum(padded_phasors[i : i + m])\n        R[i] = np.abs(neighborhood_sum / m)\n        \n    return R\n\ndef classify_nodes(R, T_coh, T_incoh):\n    \"\"\"\n    Classifies nodes based on local KOP and thresholds.\n\n    Args:\n        R (np.ndarray): Array of local KOP values.\n        T_coh (float): Coherence threshold.\n        T_incoh (float): Incoherence threshold.\n\n    Returns:\n        np.ndarray: Array of predicted labels (1: coherent, 0: incoherent, -1: indeterminate).\n    \"\"\"\n    y_hat = np.full(R.shape, -1, dtype=int)\n    y_hat[R = T_coh] = 1\n    y_hat[R = T_incoh] = 0\n    return y_hat\n\ndef calculate_metrics(y, y_hat):\n    \"\"\"\n    Calculates coverage, accuracy, and macro F1 score.\n\n    Args:\n        y (np.ndarray): Ground truth labels.\n        y_hat (np.ndarray): Predicted labels.\n\n    Returns:\n        list: A list containing [accuracy, coverage, f1_macro].\n    \"\"\"\n    N = len(y)\n    covered_mask = y_hat != -1\n    num_covered = np.sum(covered_mask)\n    \n    coverage = num_covered / N\n    \n    if num_covered == 0:\n        return [0.0, 0.0, 0.0]\n        \n    y_covered = y[covered_mask]\n    y_hat_covered = y_hat[covered_mask]\n    \n    accuracy = np.sum(y_covered == y_hat_covered) / num_covered\n    \n    F1_scores = []\n    for c in [0, 1]:  # 0: incoherent, 1: coherent\n        tp = np.sum((y_hat_covered == c)  (y_covered == c))\n        fp = np.sum((y_hat_covered == c)  (y_covered != c))\n        fn = np.sum((y_hat_covered != c)  (y_covered == c))\n        \n        prec_denom = tp + fp\n        rec_denom = tp + fn\n        \n        precision = tp / prec_denom if prec_denom  0 else 0.0\n        recall = tp / rec_denom if rec_denom  0 else 0.0\n        \n        f1_denom = precision + recall\n        f1 = (2 * precision * recall / f1_denom) if f1_denom  0 else 0.0\n        F1_scores.append(f1)\n        \n    f1_macro = np.mean(F1_scores)\n    \n    return [accuracy, coverage, f1_macro]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        {'N': 128, 'w': 4, 'T_coh': 0.92, 'T_incoh': 0.60, 'f': 0.50, 'k': 0.02, 'sigma_c': 0.03, 'sigma_u': 0.20, 'seed': 1},\n        {'N': 128, 'w': 4, 'T_coh': 0.95, 'T_incoh': 0.50, 'f': 1.00, 'k': 0.01, 'sigma_c': 0.02, 'sigma_u': 0.20, 'seed': 2},\n        {'N': 128, 'w': 6, 'T_coh': 0.90, 'T_incoh': 0.70, 'f': 0.50, 'k': 0.02, 'sigma_c': 0.30, 'sigma_u': 0.30, 'seed': 3},\n        {'N': 128, 'w': 2, 'T_coh': 0.80, 'T_incoh': 0.80, 'f': 0.30, 'k': 0.03, 'sigma_c': 0.05, 'sigma_u': 0.40, 'seed': 4},\n    ]\n\n    results = []\n    for params in test_cases:\n        # 1. Generate synthetic data\n        theta, y = generate_chimera_snapshot(\n            params['N'], params['f'], params['k'], params['sigma_c'], params['sigma_u'], params['seed']\n        )\n        \n        # 2. Compute local KOP\n        R = compute_local_kop(theta, params['w'])\n        \n        # 3. Classify nodes\n        y_hat = classify_nodes(R, params['T_coh'], params['T_incoh'])\n        \n        # 4. Validate and calculate metrics\n        metrics = calculate_metrics(y, y_hat)\n        results.append(metrics)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}