{
    "hands_on_practices": [
        {
            "introduction": "在开始任何复杂的数值研究之前，建立一个清晰且合乎逻辑的工作流程至关重要。这个基础性练习将引导你完成寻找嵌合态的模拟实验所必需的几个关键步骤，从定义系统参数到分析最终输出。掌握这个流程将为你后续在非线性动力学领域进行计算实验提供一个坚实的蓝图。",
            "id": "1666625",
            "problem": "一位非线性动力学入门课程的学生，其任务是数值研究嵌合态。嵌合态是全同振子网络中的一种特殊时空模式，其中一部分振子同步，而其余部分则保持非相干。该学生考虑了一个由$N$个全同相位振子组成的一维环，振子之间存在非局域耦合，其动力学由Kuramoto-Sakaguchi方程描述：\n$$ \\frac{d\\theta_i}{dt} = \\omega - \\frac{K}{2R+1} \\sum_{j=i-R}^{j=i+R} \\sin(\\theta_i - \\theta_j + \\alpha) $$\n此处，$\\theta_i$是第$i$个振子的相位（下标对$N$取模），$\\omega$是统一的自然频率，$K$是耦合强度，$R$是定义邻域大小的耦合半径，$\\alpha$是相位延迟参数。\n\n为了找到嵌合态，学生必须按精确的顺序执行一系列步骤。以下是进行此数值实验所需的五个基本操作：\n\n(i) 使用数值积分方法（例如，Runge-Kutta）对$N$个耦合常微分方程（ODEs）组成的系统进行长时间步的时间演化。\n(ii) 指定系统的固定参数：振子数$N$、它们的自然频率$\\omega$、耦合强度$K$、耦合半径$R$以及相位延迟$\\alpha$。\n(iii) 演化结束后，分析振子的行为，以检查是否存在嵌合态的标志：即一组具有相同有效频率的振子与另一组具有不同有效频率分布的振子共存。\n(iv) 为系统设置初始条件，即在时间$t=0$时为每个振子赋予一个相位$\\theta_i(0)$。对于嵌合态，通常需要一个特殊准备的非均匀初始状态。\n(v) 忽略时间演化初始阶段的数据，以确保任何瞬态行为已经衰减，并且系统已稳定到其长期吸引子上。\n\n以下哪个选项代表了成功设置并执行模拟以寻找嵌合态的正确逻辑顺序？\n\nA. (ii) → (iv) → (i) → (v) → (iii)\nB. (ii) → (iv) → (iii) → (i) → (v)\nC. (iv) → (ii) → (i) → (v) → (iii)\nD. (ii) → (i) → (iv) → (v) → (iii)\nE. (ii) → (iv) → (i) → (iii) → (v)",
            "solution": "我们需要确定在由Kuramoto-Sakaguchi方程\n$$\n\\frac{d\\theta_{i}}{dt}=\\omega-\\frac{K}{2R+1}\\sum_{j=i-R}^{i+R}\\sin\\!\\big(\\theta_{i}-\\theta_{j}+\\alpha\\big),\n$$\n（下标对$N$取模）所描述的、$N$个非局域耦合相位振子组成的给定系统中，数值寻找嵌合态的正确逻辑顺序。这定义了一个由$N$个耦合一阶常微分方程构成的初值问题。对于这类问题，在进行任何时间积分之前，必须首先完全指定矢量场和初始条件，然后向前积分，去除瞬态以关注长期行为（吸引子），最后分析能揭示嵌合态特征的可观测量。\n\n首先，必须指定模型的固定参数，以定义常微分方程的右端映射 $f:\\mathbb{T}^{N}\\to\\mathbb{R}^{N}$。将系统简写为\n$$\n\\dot{\\theta}_{i}=f_{i}(\\theta;\\omega,K,R,\\alpha), \\quad i\\in\\{1,\\dots,N\\},\n$$\n我们可以看到矢量场依赖于常数$N$、$\\omega$、$K$、$R$和$\\alpha$。没有这些参数，常微分方程就没有被完全定义。因此，步骤(ii)必须先于所有其他步骤。\n\n其次，一个初值问题需要一个初始条件。必须为所有的$i$指定相位$\\theta_{i}(0)$。由于目标是找到嵌合态，通常会选择一个特殊准备的非均匀初始条件，以引导动力学趋向于相干和非相干群组的共存。因此，步骤(iv)自然地跟在指定参数的步骤(ii)之后。\n\n第三，在指定了矢量场$f$和初始条件$\\theta(0)$之后，就可以使用适当的方法（例如，Runge-Kutta格式）对常微分方程进行时间上的数值前向积分，这即是步骤(i)。此过程会生成一条轨迹$t\\mapsto\\theta(t)$。\n\n第四，为了观察长期行为，需要丢弃初始的瞬态区间，以使轨迹接近其吸引子。记瞬态时间为$T_{\\mathrm{trans}}$，并且只考虑$t\\geq T_{\\mathrm{trans}}$的数据。这即是步骤(v)。这种做法确保了任何由初始条件引起的短时效应不会污染对渐近行为的诊断。\n\n第五，分析瞬态结束后的动力学，以检测嵌合态的标志：同步子群和非相干子群的共存。一种标准的诊断方法是计算每个振子的有效频率，该频率在瞬态结束后通过长时间平均计算得出：\n$$\n\\Omega_{i}=\\lim_{T\\to\\infty}\\frac{\\theta_{i}(T_{\\mathrm{trans}}+T)-\\theta_{i}(T_{\\mathrm{trans}})}{T}.\n$$\n在嵌合态中，存在一个下标子集，其对应的$\\Omega_{i}$取相同的值（锁相群），以及一个互补的子集，其对应的$\\Omega_{i}$在一个区间内分布（漂移群）。这个分析对应于步骤(iii)，并且必须在积分和去除瞬态之后进行。\n\n将这些逻辑上必要的步骤按顺序组合，得到序列：指定参数(ii) → 设置初始条件(iv) → 积分(i) → 丢弃瞬态(v) → 分析嵌合态(iii)。在给出的选项中，这对应于选项A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "模拟复杂系统后的一个关键挑战是如何从产生的数据中定量地识别出感兴趣的模式。本练习介绍了一种统计工具，用于分析嵌合态的一个决定性特征：振子频率的聚类。通过应用“间隙-范围比”(Gap-to-Range Ratio)，你将学习一种从原始数值输出中区分同步群体与非相干群体的动手方法，从而将数据转化为有意义的物理洞察。",
            "id": "1666687",
            "problem": "在复杂系统的研究中，嵌合态（chimera state）是在相同耦合振子网络中观察到的一种特殊的时空模式，其中系统的部分表现出同步行为，而其他部分则保持非相干状态。在非线性动力学中，将真正的嵌合态与其他模式（例如嘈杂的多簇状态）区分开来是一个重大的挑战。\n\n一位研究人员提出了一种称为间隙-范围比（Gap-to-Range Ratio, GRR）的统计量度，用于量化一维数据集中的聚类程度。GRR，记为 $\\mathcal{C}$，由一组 $N$ 个数据点按以下方式计算：\n1. 将数据点 $x_i$ 排序，得到有序序列 $x_{(1)} \\le x_{(2)} \\le \\dots \\le x_{(N)}$。\n2. 计算有序点之间的连续间隙：$g_i = x_{(i+1)} - x_{(i)}$，其中 $i = 1, \\dots, N-1$。\n3. GRR 定义为最大间隙与平均间隙之比。这可以用简化公式表示：\n$$ \\mathcal{C} = \\frac{(N-1) \\max_{i}\\{g_i\\}}{x_{(N)} - x_{(1)}} $$\n\n该研究人员将此度量应用于数值实验中观察到的 $N=12$ 个振子的时间平均角频率。记录的频率（单位为弧度/秒）由以下集合给出：\n$$ \\{3.14, 4.15, 3.12, 5.82, 3.19, 5.79, 3.09, 5.88, 3.15, 5.85, 3.11, 4.22\\} $$\n\n计算该数据集的间隙-范围比 $\\mathcal{C}$ 的值。将您的最终答案四舍五入至三位有效数字。",
            "solution": "我们已知 $N=12$ 个数据点和间隙-范围比的定义\n$$\n\\mathcal{C}=\\frac{(N-1)\\max_{i}\\{g_{i}\\}}{x_{(N)}-x_{(1)}}, \\quad g_{i}=x_{(i+1)}-x_{(i)}.\n$$\n步骤1：对数据进行排序。排序后的值为\n$$\nx_{(1)}=3.09,\\ x_{(2)}=3.11,\\ x_{(3)}=3.12,\\ x_{(4)}=3.14,\\ x_{(5)}=3.15,\\ x_{(6)}=3.19,\\ x_{(7)}=4.15,\\ x_{(8)}=4.22,\\ x_{(9)}=5.79,\\ x_{(10)}=5.82,\\ x_{(11)}=5.85,\\ x_{(12)}=5.88.\n$$\n步骤2：计算连续间隙 $g_{i}=x_{(i+1)}-x_{(i)}$，其中 $i=1,\\dots,11$：\n$$\n\\begin{aligned}\ng_{1}=3.11-3.09=0.02,\\quad g_{2}=3.12-3.11=0.01,\\quad g_{3}=3.14-3.12=0.02,\\\\\ng_{4}=3.15-3.14=0.01,\\quad g_{5}=3.19-3.15=0.04,\\quad g_{6}=4.15-3.19=0.96,\\\\\ng_{7}=4.22-4.15=0.07,\\quad g_{8}=5.79-4.22=1.57,\\quad g_{9}=5.82-5.79=0.03,\\\\\ng_{10}=5.85-5.82=0.03,\\quad g_{11}=5.88-5.85=0.03.\n\\end{aligned}\n$$\n因此，$\\max_{i}\\{g_{i}\\}=1.57$。\n\n步骤3：计算范围 $x_{(N)}-x_{(1)}=5.88-3.09=2.79$。\n\n步骤4：应用公式，其中 $N-1=11$：\n$$\n\\mathcal{C}=\\frac{11\\cdot 1.57}{2.79}=\\frac{17.27}{2.79}\\approx 6.19,\n$$\n其中最终值四舍五入至三位有效数字。",
            "answer": "$$\\boxed{6.19}$$"
        },
        {
            "introduction": "从简单的分析走向综合性的研究任务，这个高级实践将挑战你构建一个用于识别嵌合态的完整计算流程。你将实现一个算法，它不仅能生成合成的嵌合态数据，还能使用局部序参量对网络进行分割，并根据已知的基准真相严格验证你的结果。这个项目模拟了计算研究的端到端过程，从模型创建到性能评估，旨在巩固你在复杂系统分析中的实践技能。",
            "id": "4268035",
            "problem": "考虑一个由 $N$ 个相位振子组成的环形网络，其相位为 $\\theta_i \\in [0,2\\pi)$（单位为弧度），索引为 $i \\in \\{0,1,\\dots,N-1\\}$，并具有周期性边界条件。嵌合态（chimera state）是一种时空模式，其中一部分振子是相位一致的，而其互补的另一部分则是相位非一致的。从基本定义出发，设计并实现一个算法，该算法使用局部序参数的阈值将环形网络分割为一致性区域和非一致性区域，然后根据具有已知基准真相（ground-truth）区域的合成数据验证分类结果。\n\n该推导的基础是 Kuramoto 序参数（KOP）。对于给定的相位集合 $\\{\\theta_j\\}$，全局 KOP 定义为\n$$\nR = \\left| \\frac{1}{N} \\sum_{j=0}^{N-1} e^{\\mathrm{i} \\theta_j} \\right| ,\n$$\n它衡量网络的整体相位一致性。为了进行空间分割，定义节点 $i$ 的局部邻域 $\\mathcal{N}_i$ 为索引集合\n$$\n\\mathcal{N}_i = \\{i-w, i-w+1, \\dots, i+w\\} \\ (\\text{taken modulo } N),\n$$\n其中 $w$ 是一个正整数，邻域大小为 $m = 2w+1$。节点 $i$ 的局部 KOP 则为\n$$\nR_i = \\left| \\frac{1}{m} \\sum_{j \\in \\mathcal{N}_i} e^{\\mathrm{i} \\theta_j} \\right| .\n$$\n在相位局部一致的区域中，$R_i$ 接近 $1$；而在具有近乎均匀随机相位的非一致区域中，单位复数的平均值趋于抵消，使得当 $m$ 增大时 $R_i$ 接近 $0$。\n\n分类规则。给定两个满足 $1 \\ge T_{\\text{coh}} \\ge T_{\\text{incoh}} \\ge 0$ 的阈值 $T_{\\text{coh}}$ 和 $T_{\\text{incoh}}$，对每个节点 $i$ 进行如下分类：\n- 如果 $R_i \\ge T_{\\text{coh}}$，则为一致性节点，\n- 如果 $R_i \\le T_{\\text{incoh}}$，则为非一致性节点，\n- 否则为不确定节点。\n全文的角度单位均为弧度。\n\n合成数据生成。按如下方式构建具有已知基准真值标签的合成嵌合态快照。固定 $N$、一致性比例 $f \\in [0,1]$、相位斜率 $k \\ge 0$（单位：弧度/节点），以及分别为一致性和非一致性区域设定的噪声水平 $\\sigma_c \\ge 0$ 和 $\\sigma_u \\ge 0$。令 $C = \\lfloor f N \\rfloor$ 为一致性区域的大小，占据索引 $i = 0,1,\\dots,C-1$；令非一致性区域占据索引 $i = C,\\dots,N-1$。抽取一个基础相位 $\\theta_0 \\sim \\mathrm{Uniform}(0,2\\pi)$。通过以下方式生成相位\n$$\n\\theta_i =\n\\begin{cases}\n\\theta_0 + k i + \\eta_i \\pmod{2\\pi},  i \\in \\{0,\\dots,C-1\\},\\ \\eta_i \\sim \\mathcal{N}(0,\\sigma_c^2),\\\\\n\\phi_i + \\xi_i \\pmod{2\\pi},  i \\in \\{C,\\dots,N-1\\},\\ \\phi_i \\sim \\mathrm{Uniform}(0,2\\pi),\\ \\xi_i \\sim \\mathcal{N}(0,\\sigma_u^2).\n\\end{cases}\n$$\n定义基准真值标签，如果 $i  C$ 则 $y_i = 1$，否则 $y_i = 0$。\n\n验证指标。令 $\\hat{y}_i \\in \\{1,0,-1\\}$ 为基于上述规则对节点 $i$ 的预测标签，其中 $-1$ 表示不确定。仅考虑被覆盖的节点（即 $\\hat{y}_i \\ne -1$ 的节点）来评估分类。定义覆盖率\n$$\n\\text{coverage} = \\frac{\\#\\{i : \\hat{y}_i \\ne -1\\}}{N} .\n$$\n在被覆盖的子集上，定义准确率\n$$\n\\text{accuracy} = \n\\begin{cases}\n\\frac{\\#\\{i : \\hat{y}_i = y_i \\}}{\\#\\{i : \\hat{y}_i \\ne -1\\}},  \\text{if } \\#\\{i : \\hat{y}_i \\ne -1\\} > 0,\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n对于被覆盖子集上的每个类别 $c \\in \\{0,1\\}$，定义精确率 $\\text{Prec}_c = \\frac{\\text{TP}_c}{\\text{TP}_c + \\text{FP}_c}$ 和召回率 $\\text{Rec}_c = \\frac{\\text{TP}_c}{\\text{TP}_c + \\text{FN}_c}$，并约定除以零的结果为 $0$。定义各类别下的 $F_1$ 分数\n$$\nF_{1,c} =\n\\begin{cases}\n\\frac{2 \\,\\text{Prec}_c \\,\\text{Rec}_c}{\\text{Prec}_c + \\text{Rec}_c},  \\text{if } \\text{Prec}_c + \\text{Rec}_c > 0,\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n以及宏 $F_1$ 分数 $F_1^{\\text{macro}} = \\tfrac{1}{2}(F_{1,0} + F_{1,1})$。如果覆盖率为零，则将准确率和 $F_1^{\\text{macro}}$ 均设为 $0$。\n\n算法任务。实现：\n1. 一个按规定生成合成嵌合态快照的生成器，在给定种子的情况下具有可复现的随机性。\n2. 在环形网络上使用半宽度为 $w$ 的邻域，计算所有 $i$ 的局部 KOP $R_i$。\n3. 使用阈值 $T_{\\text{coh}}$ 和 $T_{\\text{incoh}}$ 对节点进行分割。\n4. 使用上面定义的覆盖率、准确率和宏 $F_1$ 指标，对基准真值进行验证，计算仅在被覆盖节点上进行。\n\n测试套件。您的程序必须在以下参数集上评估该算法，并按顺序返回每个集合的指标。角度单位为弧度，邻域使用周期性索引。\n- 案例1（一般混合嵌合态，理想路径）：$N=128$, $w=4$ (因此 $m=9$), $T_{\\text{coh}}=0.92$, $T_{\\text{incoh}}=0.60$, $f=0.50$, $k=0.02$, $\\sigma_c=0.03$, $\\sigma_u=0.20$, 种子 $=1$。\n- 案例2（完全一致性区域）：$N=128$, $w=4$, $T_{\\text{coh}}=0.95$, $T_{\\text{incoh}}=0.50$, $f=1.00$, $k=0.01$, $\\sigma_c=0.02$, $\\sigma_u=0.20$ (未使用但提供), 种子 $=2$。\n- 案例3（高噪声，可能出现不确定性）：$N=128$, $w=6$ (因此 $m=13$), $T_{\\text{coh}}=0.90$, $T_{\\text{incoh}}=0.70$, $f=0.50$, $k=0.02$, $\\sigma_c=0.30$, $\\sigma_u=0.30$, 种子 $=3$。\n- 案例4（单阈值边界，无不确定性）：$N=128$, $w=2$ (因此 $m=5$), $T_{\\text{coh}}=0.80$, $T_{\\text{incoh}}=0.80$, $f=0.30$, $k=0.03$, $\\sigma_c=0.05$, $\\sigma_u=0.40$, 种子 $=4$。\n\n最终输出格式。您的程序应生成单行输出，其中包含四个案例的结果，形式为一个由方括号括起来的逗号分隔列表，每个案例的结果是列表 $[\\text{accuracy},\\text{coverage},F_1^{\\text{macro}}]$。例如，输出必须具有以下形式\n$$\n\\big[ [a_1,c_1,f_1], [a_2,c_2,f_2], [a_3,c_3,f_3], [a_4,c_4,f_4] \\big],\n$$\n其中每个 $a_i$、$c_i$ 和 $f_i$ 都是实数。",
            "solution": "该问题要求设计并实现一种算法，用于识别环形网络中相位振子的嵌合态。这包括生成具有已知基准真值区域的合成数据，计算局部序参数以对节点进行分类，并使用明确定义的指标评估分类性能。该方法是基于网络科学和统计分析的基本原理系统地构建的。\n\n解决方案分四个阶段进行：（1）生成代表嵌合态的合成相位数据；（2）为每个振子计算局部 Kuramoto 序参数；（3）基于该参数将振子分类为一致、非一致或不确定状态；以及（4）使用指定的性能指标，对照基准真值验证分类结果。\n\n**1. 合成嵌合态生成**\n\n为了验证分类算法，我们首先构建一个具有已知一致性和非一致性区域的振子相位合成快照。网络由环上的 $N$ 个振子组成，索引为 $i \\in \\{0, 1, \\dots, N-1\\}$。\n\n基准真值结构由一致性比例 $f \\in [0,1]$ 定义。一个由 $C = \\lfloor f N \\rfloor$ 个振子组成的区块，其索引为 $i \\in \\{0, 1, \\dots, C-1\\}$，构成一致性区域（基准真值标签 $y_i=1$）。剩余的 $N-C$ 个振子，其索引为 $i \\in \\{C, \\dots, N-1\\}$，构成非一致性区域（基准真值标签 $y_i=0$）。\n\n相位 $\\theta_i \\in [0, 2\\pi)$ 通过以下方式生成，使用由给定种子初始化的可复现伪随机数生成器：\n\n-   **一致性区域 ($i \\in \\{0, \\dots, C-1\\}$)**：设计的相位具有强相关性。从均匀分布中抽取一个单一的基础相位 $\\theta_{\\text{base}} \\sim \\mathrm{Uniform}(0, 2\\pi)$。然后，一致性振子的相位由一个相位斜率为 $k \\ge 0$（单位：弧度/节点）的线性级数加上少量高斯噪声确定。振子 $i$ 的相位由下式给出：\n    $$\n    \\theta_i = (\\theta_{\\text{base}} + k i + \\eta_i) \\pmod{2\\pi}\n    $$\n    其中噪声项 $\\eta_i$ 从均值为 $0$、方差为 $\\sigma_c^2$ 的正态分布中抽取，即 $\\eta_i \\sim \\mathcal{N}(0, \\sigma_c^2)$。较小的噪声水平 $\\sigma_c$ 确保相位保持在确定性序列 $\\theta_{\\text{base}} + ki$ 附近。\n\n-   **非一致性区域 ($i \\in \\{C, \\dots, N-1\\}$)**：设计的相位不具相关性。对于此区域中的每个振子 $i$，从均匀分布 $\\mathrm{Uniform}(0, 2\\pi)$ 中抽取一个新的、独立的相位 $\\phi_i$。此外还添加一个额外的高斯噪声项。振子 $i$ 的相位为：\n    $$\n    \\theta_i = (\\phi_i + \\xi_i) \\pmod{2\\pi}\n    $$\n    其中噪声项 $\\xi_i$ 从正态分布 $\\mathcal{N}(0, \\sigma_u^2)$ 中抽取。均匀分布的基础相位 $\\phi_i$ 和噪声 $\\xi_i$ 的组合产生了一组很大程度上不相关的相位。\n\n模 $2\\pi$ 运算确保所有相位都位于区间 $[0, 2\\pi)$ 内。\n\n**2. 局部一致性度量**\n\n为了在空间上区分一致性区域和非一致性区域，我们采用局部 Kuramoto 序参数（KOP），$R_i$。该指标量化了每个振子局部邻域内的相位同步程度。\n\n振子 $i$ 的邻域 $\\mathcal{N}_i$ 被定义为以 $i$ 为中心的 $m = 2w+1$ 个振子的集合，其中 $w$ 是邻域半宽度。由于是环形拓扑，索引取模 $N$：\n$$\n\\mathcal{N}_i = \\{ (i-w+j) \\pmod N \\mid j=0, 1, \\dots, 2w \\}\n$$\n局部 KOP，$R_i$，是邻域 $\\mathcal{N}_i$ 中所有振子 $j$ 的相量（phasor） $e^{\\mathrm{i}\\theta_j}$ 平均值的模：\n$$\nR_i = \\left| \\frac{1}{m} \\sum_{j \\in \\mathcal{N}_i} e^{\\mathrm{i} \\theta_j} \\right|\n$$\n从概念上讲，如果邻域内的相位 $\\theta_j$ 几乎相同，复平面上对应的单位向量将指向相似的方向，其平均值的模 $R_i$ 将接近 $1$。相反，如果相位是均匀分布的，这些向量将趋于相互抵消，导致平均值的模 $R_i$ 接近 $0$。\n\n在计算上，此过程对每个振子 $i$ 执行：首先将相位向量 $\\boldsymbol{\\theta}$ 转换为复相量向量 $\\mathbf{z} = (e^{\\mathrm{i}\\theta_0}, \\dots, e^{\\mathrm{i}\\theta_{N-1}})$。然后，对于每个 $i$，我们对邻域 $\\mathcal{N}_i$ 中索引对应的相量求和，除以邻域大小 $m$，然后取绝对值。周期性边界条件通过按需环绕索引来处理。\n\n**3. 基于阈值的分割**\n\n在为每个振子计算出局部序参数 $R_i$ 后，我们可以对每个节点进行分类。分类规则使用两个阈值 $T_{\\text{coh}}$ 和 $T_{\\text{incoh}}$，它们必须满足 $1 \\ge T_{\\text{coh}} \\ge T_{\\text{incoh}} \\ge 0$。每个节点 $i$ 的预测标签 $\\hat{y}_i$ 按如下方式分配：\n\n-   如果 $R_i \\ge T_{\\text{coh}}$，节点被分类为**一致性**（$\\hat{y}_i = 1$）。\n-   如果 $R_i \\le T_{\\text{incoh}}$，节点被分类为**非一致性**（$\\hat{y}_i = 0$）。\n-   如果 $T_{\\text{incoh}}  R_i  T_{\\text{coh}}$，节点的状态为**不确定**（$\\hat{y}_i = -1$）。\n\n此规则将网络划分为三个集合：预测为一致性的集合、预测为非一致性的集合以及分类不明确的集合。$T_{\\text{coh}}$ 和 $T_{\\text{incoh}}$ 之间的间隔创建了一个缓冲区，减少了对具有中等 $R_i$ 值的节点的错误分类，这些节点通常出现在区域边界或高噪声区域。\n\n**4. 定量验证**\n\n最后一步是评估分类算法的性能。评估仅在未被分类为不确定（即 $\\hat{y}_i \\in \\{0, 1\\}$）的节点子集上进行。\n\n计算以下指标：\n\n-   **覆盖率**：获得确定分类（一致性或非一致性）的节点比例。\n    $$\n    \\text{coverage} = \\frac{\\#\\{i : \\hat{y}_i \\ne -1\\}}{N}\n    $$\n-   **准确率**：在被覆盖的节点中，被正确分类的节点比例。\n    $$\n    \\text{accuracy} = \\frac{\\#\\{i : \\hat{y}_i = y_i \\text{ and } \\hat{y}_i \\ne -1\\}}{\\#\\{i : \\hat{y}_i \\ne -1\\}}\n    $$\n    如果覆盖率为 $0$，则准确率定义为 $0$。\n\n-   **宏 $F_1$ 分数**：该指标提供了跨两个类别（一致性和非一致性）的平衡性能度量。它是个类别 $F_1$ 分数的平均值。对于每个类别 $c \\in \\{0, 1\\}$，我们在被覆盖的子集上计算精确率（$\\text{Prec}_c$）和召回率（$\\text{Rec}_c$）。\n    -   真阳性（$\\text{TP}_c$）：$\\#\\{i : \\hat{y}_i=c \\text{ and } y_i=c\\}$。\n    -   假阳性（$\\text{FP}_c$）：$\\#\\{i : \\hat{y}_i=c \\text{ and } y_i \\ne c\\}$。\n    -   假阴性（$\\text{FN}_c$）：$\\#\\{i : \\hat{y}_i \\ne c \\text{ and } y_i=c \\text{ and } \\hat{y}_i \\ne -1\\}$。\n    \n    精确率和召回率则为：\n    $$\n    \\text{Prec}_c = \\frac{\\text{TP}_c}{\\text{TP}_c + \\text{FP}_c}, \\quad \\text{Rec}_c = \\frac{\\text{TP}_c}{\\text{TP}_c + \\text{FN}_c}\n    $$\n    其中除以零的结果为 $0$。类别 $c$ 的 $F_1$ 分数是精确率和召回率的调和平均数：\n    $$\n    F_{1,c} = \\frac{2 \\cdot \\text{Prec}_c \\cdot \\text{Rec}_c}{\\text{Prec}_c + \\text{Rec}_c}\n    $$\n    同样，除以零的结果为 $0$。最后，宏平均 $F_1$ 分数为：\n    $$\n    F_1^{\\text{macro}} = \\frac{1}{2}(F_{1,0} + F_{1,1})\n    $$\n    如果覆盖率为 $0$，$F_1^{\\text{macro}}$ 也设为 $0$。\n\n这四个步骤构成了一个完整的流程，用于生成、分析和验证一个基于局部相位一致性的嵌合态检测算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_chimera_snapshot(N, f, k, sigma_c, sigma_u, seed):\n    \"\"\"\n    Generates a synthetic chimera snapshot with ground truth labels.\n\n    Args:\n        N (int): Number of oscillators.\n        f (float): Fraction of coherent oscillators.\n        k (float): Phase slope for the coherent domain.\n        sigma_c (float): Noise level (std dev) for the coherent domain.\n        sigma_u (float): Noise level (std dev) for the incoherent domain.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The array of phases theta.\n            - np.ndarray: The ground truth labels y (1 for coherent, 0 for incoherent).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    theta = np.zeros(N)\n    y = np.zeros(N, dtype=int)\n    \n    # Coherent domain\n    C = int(np.floor(f * N))\n    if C > 0:\n        y[:C] = 1\n        base_phase = rng.uniform(0, 2 * np.pi)\n        coherent_indices = np.arange(C)\n        noise_c = rng.normal(0, sigma_c, size=C)\n        theta[:C] = (base_phase + k * coherent_indices + noise_c) % (2 * np.pi)\n        \n    # Incoherent domain\n    if N - C > 0:\n        incoherent_indices = np.arange(C, N)\n        num_incoherent = len(incoherent_indices)\n        phi = rng.uniform(0, 2 * np.pi, size=num_incoherent)\n        noise_u = rng.normal(0, sigma_u, size=num_incoherent)\n        theta[C:] = (phi + noise_u) % (2 * np.pi)\n        \n    return theta, y\n\ndef compute_local_kop(theta, w):\n    \"\"\"\n    Computes the local Kuramoto order parameter for each oscillator.\n\n    Args:\n        theta (np.ndarray): Array of oscillator phases.\n        w (int): Half-width of the neighborhood.\n\n    Returns:\n        np.ndarray: The array of local KOP values R_i.\n    \"\"\"\n    N = len(theta)\n    m = 2 * w + 1\n    R = np.zeros(N)\n    phasors = np.exp(1j * theta)\n    \n    # Pad the phasors array to handle periodic boundary conditions easily\n    padded_phasors = np.pad(phasors, (w, w), mode='wrap')\n    \n    for i in range(N):\n        # The neighborhood of node i in the original array corresponds to\n        # the slice from i to i + 2w in the padded array.\n        neighborhood_sum = np.sum(padded_phasors[i : i + m])\n        R[i] = np.abs(neighborhood_sum / m)\n        \n    return R\n\ndef classify_nodes(R, T_coh, T_incoh):\n    \"\"\"\n    Classifies nodes based on local KOP and thresholds.\n\n    Args:\n        R (np.ndarray): Array of local KOP values.\n        T_coh (float): Coherence threshold.\n        T_incoh (float): Incoherence threshold.\n\n    Returns:\n        np.ndarray: Array of predicted labels (1: coherent, 0: incoherent, -1: indeterminate).\n    \"\"\"\n    y_hat = np.full(R.shape, -1, dtype=int)\n    y_hat[R >= T_coh] = 1\n    y_hat[R = T_incoh] = 0\n    return y_hat\n\ndef calculate_metrics(y, y_hat):\n    \"\"\"\n    Calculates coverage, accuracy, and macro F1 score.\n\n    Args:\n        y (np.ndarray): Ground truth labels.\n        y_hat (np.ndarray): Predicted labels.\n\n    Returns:\n        list: A list containing [accuracy, coverage, f1_macro].\n    \"\"\"\n    N = len(y)\n    covered_mask = y_hat != -1\n    num_covered = np.sum(covered_mask)\n    \n    coverage = num_covered / N\n    \n    if num_covered == 0:\n        return [0.0, 0.0, 0.0]\n        \n    y_covered = y[covered_mask]\n    y_hat_covered = y_hat[covered_mask]\n    \n    accuracy = np.sum(y_covered == y_hat_covered) / num_covered\n    \n    F1_scores = []\n    for c in [0, 1]:  # 0: incoherent, 1: coherent\n        tp = np.sum((y_hat_covered == c)  (y_covered == c))\n        fp = np.sum((y_hat_covered == c)  (y_covered != c))\n        fn = np.sum((y_hat_covered != c)  (y_covered == c))\n        \n        prec_denom = tp + fp\n        rec_denom = tp + fn\n        \n        precision = tp / prec_denom if prec_denom > 0 else 0.0\n        recall = tp / rec_denom if rec_denom > 0 else 0.0\n        \n        f1_denom = precision + recall\n        f1 = (2 * precision * recall / f1_denom) if f1_denom > 0 else 0.0\n        F1_scores.append(f1)\n        \n    f1_macro = np.mean(F1_scores)\n    \n    return [accuracy, coverage, f1_macro]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        {'N': 128, 'w': 4, 'T_coh': 0.92, 'T_incoh': 0.60, 'f': 0.50, 'k': 0.02, 'sigma_c': 0.03, 'sigma_u': 0.20, 'seed': 1},\n        {'N': 128, 'w': 4, 'T_coh': 0.95, 'T_incoh': 0.50, 'f': 1.00, 'k': 0.01, 'sigma_c': 0.02, 'sigma_u': 0.20, 'seed': 2},\n        {'N': 128, 'w': 6, 'T_coh': 0.90, 'T_incoh': 0.70, 'f': 0.50, 'k': 0.02, 'sigma_c': 0.30, 'sigma_u': 0.30, 'seed': 3},\n        {'N': 128, 'w': 2, 'T_coh': 0.80, 'T_incoh': 0.80, 'f': 0.30, 'k': 0.03, 'sigma_c': 0.05, 'sigma_u': 0.40, 'seed': 4},\n    ]\n\n    results = []\n    for params in test_cases:\n        # 1. Generate synthetic data\n        theta, y = generate_chimera_snapshot(\n            params['N'], params['f'], params['k'], params['sigma_c'], params['sigma_u'], params['seed']\n        )\n        \n        # 2. Compute local KOP\n        R = compute_local_kop(theta, params['w'])\n        \n        # 3. Classify nodes\n        y_hat = classify_nodes(R, params['T_coh'], params['T_incoh'])\n        \n        # 4. Validate and calculate metrics\n        metrics = calculate_metrics(y, y_hat)\n        results.append(metrics)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}