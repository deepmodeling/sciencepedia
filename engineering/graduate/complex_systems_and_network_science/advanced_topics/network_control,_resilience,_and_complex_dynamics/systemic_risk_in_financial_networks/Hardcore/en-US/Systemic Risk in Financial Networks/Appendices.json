{
    "hands_on_practices": [
        {
            "introduction": "To truly grasp how financial contagion unfolds, it is essential to work through the mechanics by hand. This first exercise challenges you to calculate the final state of a small, three-bank system using the foundational Eisenberg-Noe model. By manually determining the clearing payment vector, you will develop a concrete intuition for the fixed-point logic that governs financial clearing and see how an initial shortfall can propagate through a network .",
            "id": "4306720",
            "problem": "Consider a financial system of three banks indexed by $i \\in \\{1,2,3\\}$ modeled by the Eisenberg–Noe (EN) framework. Each bank $i$ has total nominal liabilities $\\bar{p}_{i} \\ge 0$ to the system and faces external assets $a_{i} \\ge 0$. The relative liabilities matrix $\\Pi$ has entries $\\Pi_{ij} \\in [0,1]$ that represent the fraction of bank $i$’s total nominal liabilities owed to creditor $j$, with $\\sum_{j=1}^{3} \\Pi_{ij} = 1$ whenever $\\bar{p}_{i} > 0$. Let $p \\in \\mathbb{R}_{+}^{3}$ denote the realized payments vector at clearing.\n\nAssume limited liability and proportionality of repayments, so that each bank’s realized payment equals the minimum of its total nominal liabilities and its available resources (external assets plus realized interbank inflows). Formally, the clearing payments must satisfy, for each $i$,\n$$\n0 \\le p_{i} \\le \\bar{p}_{i}, \\quad p_{i} = \\min\\!\\left\\{ \\bar{p}_{i},\\ a_{i} + \\sum_{j=1}^{3} \\Pi_{j i}\\, p_{j} \\right\\}.\n$$\n\nYou are given the following instance (all quantities are in the same monetary unit):\n- Total nominal liabilities vector $\\bar{p} = (\\bar{p}_{1}, \\bar{p}_{2}, \\bar{p}_{3}) = (100, 90, 80)$.\n- Relative liabilities matrix\n$$\n\\Pi \\;=\\;\n\\begin{pmatrix}\n0  0.5  0.5 \\\\\n0.4  0  0.6 \\\\\n0.5  0.5  0\n\\end{pmatrix}.\n$$\n- External assets vector $a = (a_{1}, a_{2}, a_{3}) = (20, 30, 35)$.\n\nStarting from the definitions of limited liability and proportional repayment embedded in the Eisenberg–Noe framework, derive the fixed point equations for the clearing problem and solve explicitly for the clearing vector $p$. Identify the default set $D = \\{\\, i \\in \\{1,2,3\\} : p_{i}  \\bar{p}_{i} \\,\\}$ at the fixed point. \n\nAnswer format requirement: Report your final answer as a single row matrix containing six entries in the order $(p_{1}, p_{2}, p_{3}, d_{1}, d_{2}, d_{3})$, where $d_{i} = 1$ if bank $i$ defaults and $d_{i} = 0$ otherwise. No rounding is required. Do not include units in your final boxed answer.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It is a standard application of the Eisenberg–Noe financial clearing model, with all necessary data provided.\n\nThe clearing vector $p=(p_1, p_2, p_3)$ is determined by the fixed-point condition for each bank $i \\in \\{1,2,3\\}$:\n$$\np_{i} = \\min\\!\\left\\{ \\bar{p}_{i},\\ a_{i} + \\sum_{j=1}^{3} \\Pi_{j i}\\, p_{j} \\right\\}\n$$\nwhere $\\bar{p} = (100, 90, 80)$ is the vector of total nominal liabilities, $a = (20, 30, 35)$ is the vector of external assets, and $\\Pi$ is the relative liabilities matrix. The term $\\sum_{j=1}^{3} \\Pi_{j i}\\, p_{j}$ represents the total interbank assets received by bank $i$. This sum can be expressed using the transpose of $\\Pi$, denoted $\\Pi^T$, where $(\\Pi^T)_{ij} = \\Pi_{ji}$. The system of equations is:\n$$\n\\begin{pmatrix} p_1 \\\\ p_2 \\\\ p_3 \\end{pmatrix} = \\min\\!\\left\\{ \\begin{pmatrix} \\bar{p}_1 \\\\ \\bar{p}_2 \\\\ \\bar{p}_3 \\end{pmatrix}, \\begin{pmatrix} a_1 \\\\ a_2 \\\\ a_3 \\end{pmatrix} + \\Pi^T \\begin{pmatrix} p_1 \\\\ p_2 \\\\ p_3 \\end{pmatrix} \\right\\}\n$$\nGiven the matrix $\\Pi$, its transpose is:\n$$\n\\Pi^T =\n\\begin{pmatrix}\n0  0.4  0.5 \\\\\n0.5  0  0.5 \\\\\n0.5  0.6  0\n\\end{pmatrix}\n$$\nThe system of equations for the clearing payments becomes:\n$$\np_1 = \\min\\{100,\\, 20 + 0.4 p_2 + 0.5 p_3\\} \\\\\np_2 = \\min\\{90,\\, 30 + 0.5 p_1 + 0.5 p_3\\} \\\\\np_3 = \\min\\{80,\\, 35 + 0.5 p_1 + 0.6 p_2\\}\n$$\nTo solve this system, we can partition the set of banks into two disjoint sets: the set of defaulting banks, $D = \\{i : p_i  \\bar{p}_i\\}$, and the set of solvent banks, $S = \\{i : p_i = \\bar{p}_i\\}$. For a bank $i \\in D$, its realized payment equals its available resources. For a bank $i \\in S$, its realized payment equals its nominal liabilities, and its available resources must be sufficient to cover these liabilities.\nThis leads to the following system of equations and inequalities based on a hypothetical partition $(D, S)$:\nFor $i \\in D$: $p_i = a_i + \\sum_{j=1}^{3} \\Pi_{ji} p_j$\nFor $i \\in S$: $p_i = \\bar{p}_i$ and $a_i + \\sum_{j=1}^{3} \\Pi_{ji} p_j \\ge \\bar{p}_i$\n\nLet's first test the hypothesis that no bank defaults, i.e., $D = \\emptyset$ and $S = \\{1, 2, 3\\}$. This would mean $p = \\bar{p} = (100, 90, 80)$. We must check if the resource constraint is satisfied for all banks.\nFor bank $1$: $a_1 + \\sum_{j=1}^{3} \\Pi_{j1} p_j = 20 + 0.4(90) + 0.5(80) = 20 + 36 + 40 = 96$.\nThe condition for solvency is $96 \\ge \\bar{p}_1 = 100$, which is false. Therefore, the hypothesis $D = \\emptyset$ is incorrect. At least bank $1$ must default.\n\nLet's test the hypothesis $D = \\{1\\}$ and $S = \\{2, 3\\}$. This implies:\n1. Bank $1$ defaults: $p_1  100$, so $p_1 = 20 + 0.4 p_2 + 0.5 p_3$.\n2. Bank $2$ is solvent: $p_2 = \\bar{p}_2 = 90$.\n3. Bank $3$ is solvent: $p_3 = \\bar{p}_3 = 80$.\n\nWe substitute the values of $p_2$ and $p_3$ into the equation for $p_1$:\n$$\np_1 = 20 + 0.4(90) + 0.5(80) = 20 + 36 + 40 = 96\n$$\nThis gives a candidate solution vector $p = (96, 90, 80)$. Now, we must verify the consistency of this solution with our initial hypothesis for the partition $(D,S)$.\n- For bank $1 \\in D$: Is $p_1  \\bar{p}_1$? We have $96  100$. This is consistent.\n- For bank $2 \\in S$: Is $p_2 = \\bar{p}_2$ and are its resources sufficient? We set $p_2=90$. We must check if $a_2 + \\sum_{j=1}^{3} \\Pi_{j2} p_j \\ge \\bar{p}_2$.\n$$\n30 + 0.5 p_1 + 0.5 p_3 = 30 + 0.5(96) + 0.5(80) = 30 + 48 + 40 = 118\n$$\nThe condition is $118 \\ge 90$, which is true. This is consistent.\n- For bank $3 \\in S$: Is $p_3 = \\bar{p}_3$ and are its resources sufficient? We set $p_3=80$. We must check if $a_3 + \\sum_{j=1}^{3} \\Pi_{j3} p_j \\ge \\bar{p}_3$.\n$$\n35 + 0.5 p_1 + 0.6 p_2 = 35 + 0.5(96) + 0.6(90) = 35 + 48 + 54 = 137\n$$\nThe condition is $137 \\ge 80$, which is true. This is also consistent.\n\nSince all conditions for the partition $D=\\{1\\}, S=\\{2,3\\}$ are satisfied, this partition is correct, and the unique clearing vector is $p = (96, 90, 80)$.\n\nThe default set is $D = \\{i : p_i  \\bar{p}_i\\}$.\n- Bank $1$: $p_1 = 96  \\bar{p}_1 = 100$, so bank $1$ defaults. The default indicator is $d_1 = 1$.\n- Bank $2$: $p_2 = 90 = \\bar{p}_2 = 90$, so bank $2$ does not default. The default indicator is $d_2 = 0$.\n- Bank $3$: $p_3 = 80 = \\bar{p}_3 = 80$, so bank $3$ does not default. The default indicator is $d_3 = 0$.\n\nThe resulting clearing vector is $p=(p_1, p_2, p_3) = (96, 90, 80)$, and the default indicator vector is $d=(d_1, d_2, d_3) = (1, 0, 0)$. The final answer must be reported as the single row matrix $(p_1, p_2, p_3, d_1, d_2, d_3)$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n96  90  80  1  0  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While manual calculations build intuition, real-world financial networks are far too large and complex to be solved by hand. This practice guides you through implementing the Fictitious Default Algorithm (FDA), the standard computational method for finding the Eisenberg-Noe clearing vector. You will not only translate the model into code but also formally prove its convergence, a crucial step in developing robust computational tools for systemic risk analysis .",
            "id": "4306697",
            "problem": "Consider the Eisenberg–Noe (EN) model of interbank clearing payments in a financial network with $n$ banks. Let $L \\in \\mathbb{R}_{+}^{n \\times n}$ be the matrix of nominal interbank liabilities where $L_{i j}$ denotes the obligation of bank $i$ to bank $j$. Let $\\bar{p} \\in \\mathbb{R}_{+}^{n}$ be the vector of total nominal liabilities of each bank to all creditors (including non-bank creditors such as depositors), and let $x \\in \\mathbb{R}_{+}^{n}$ be the vector of exogenous assets of each bank available for paying liabilities. Define the relative liability matrix $\\Pi \\in [0,1]^{n \\times n}$ by $\\Pi_{ij} = \\frac{L_{ij}}{\\bar{p}_i}$ when $\\bar{p}_i > 0$ and $\\Pi_{ij} = 0$ when $\\bar{p}_i = 0$. The EN clearing mechanism seeks a payment vector $p \\in \\mathbb{R}_{+}^{n}$ that respects limited liability and absolute priority: each bank $i$ pays $p_i = \\min\\{\\bar{p}_i, x_i + \\sum_{j=1}^{n} \\Pi_{ji} p_j\\}$.\n\nTask A (implementation): Implement the Fictitious Default Algorithm (FDA) for computing the clearing payment vector $p$ as defined above. Your implementation must be general for any $n$, and rely only on the base definitions provided. No additional assumptions beyond those in this problem statement should be introduced.\n\nTask B (termination proof): Provide a clear proof that the FDA terminates in at most $n$ iterations for a system of $n$ banks, under the EN model assumptions stated, and explain why each iteration strictly increases the set of defaulting banks or terminates.\n\nTask C (application to test suite): Apply your implementation to the following test suite of parameter sets $(L, \\bar{p}, x)$ and compute the corresponding clearing payment vector $p$ for each case.\n\n- Test Case $1$ (happy path, no defaults expected): $n = 3$, \n  $$L = \\begin{pmatrix}\n  0  1  0.5 \\\\\n  0.5  0  0.5 \\\\\n  0.2  0.3  0\n  \\end{pmatrix}, \\quad \\bar{p} = \\begin{pmatrix} 1.5 \\\\ 1.0 \\\\ 0.5 \\end{pmatrix}, \\quad x = \\begin{pmatrix} 2.0 \\\\ 0.7 \\\\ 0.6 \\end{pmatrix}.$$\n- Test Case $2$ (cascade with outside obligations): $n = 3$, \n  $$L = \\begin{pmatrix}\n  0  0.9  0 \\\\\n  0  0  0.9 \\\\\n  0.9  0  0\n  \\end{pmatrix}, \\quad \\bar{p} = \\begin{pmatrix} 1.5 \\\\ 1.5 \\\\ 1.5 \\end{pmatrix}, \\quad x = \\begin{pmatrix} 0.1 \\\\ 0.1 \\\\ 0.1 \\end{pmatrix}.$$\n- Test Case $3$ (boundary: a bank with zero total obligations): $n = 2$,\n  $$L = \\begin{pmatrix}\n  0  0 \\\\\n  0.4  0\n  \\end{pmatrix}, \\quad \\bar{p} = \\begin{pmatrix} 0.0 \\\\ 0.4 \\end{pmatrix}, \\quad x = \\begin{pmatrix} 0.0 \\\\ 0.0 \\end{pmatrix}.$$\n- Test Case $4$ (edge case: single bank, obligations to society only): $n = 1$,\n  $$L = \\begin{pmatrix} 0 \\end{pmatrix}, \\quad \\bar{p} = \\begin{pmatrix} 1.0 \\end{pmatrix}, \\quad x = \\begin{pmatrix} 0.3 \\end{pmatrix}.$$\n\nOutput specification: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3]$). For each test case, output the computed payment vector $p$ as a nested list of floats in the order of bank indices (from $1$ to $n$). Thus, the final output must be of the form $[[p^{(1)}_1,\\ldots,p^{(1)}_{n_1}],[p^{(2)}_1,\\ldots,p^{(2)}_{n_2}],\\ldots]$ with no additional text.\n\nAll quantities are dimensionless and must be treated as real numbers. Angles and physical units do not apply. The answer for each test case is the list of floats representing the clearing payments for that case.",
            "solution": "The problem asks for the implementation and theoretical justification of the Fictitious Default Algorithm (FDA) for the Eisenberg–Noe (EN) model of interbank clearing, and its application to a specific test suite.\n\n### Problem Formulation\n\nFirst, we formalize the model based on the provided definitions. We have a system of $n$ banks.\n- $L \\in \\mathbb{R}_{+}^{n \\times n}$: The matrix of nominal interbank liabilities, where $L_{ij}$ is the amount bank $i$ owes bank $j$.\n- $\\bar{p} \\in \\mathbb{R}_{+}^{n}$: The vector of total nominal liabilities, where $\\bar{p}_i$ is the total amount bank $i$ owes to all creditors (interbank and external).\n- $x \\in \\mathbb{R}_{+}^{n}$: The vector of exogenous assets available to each bank.\n- $\\Pi \\in [0,1]^{n \\times n}$: The relative liability matrix, with entries $\\Pi_{ij} = \\frac{L_{ij}}{\\bar{p}_i}$ if $\\bar{p}_i > 0$, and $\\Pi_{ij} = 0$ if $\\bar{p}_i = 0$. The value $\\Pi_{ij}$ represents the fraction of bank $i$'s total payments that are directed to bank $j$.\n\nThe goal is to find the clearing payment vector $p \\in \\mathbb{R}_{+}^{n}$, which is the solution to the fixed-point equation:\n$$ p_i = \\min\\left\\{\\bar{p}_i, c_i(p)\\right\\} \\quad \\text{for } i=1, \\dots, n $$\nwhere $c_i(p)$ is the total cash available to bank $i$:\n$$ c_i(p) = x_i + \\sum_{j=1}^{n} (\\text{payment from } j \\text{ to } i) $$\nA payment of $p_j$ by bank $j$ is distributed proportionally to its creditors. The payment from bank $j$ to bank $i$ is $p_j \\frac{L_{ji}}{\\bar{p}_j} = p_j \\Pi_{ji}$. Thus, the income for bank $i$ from the interbank system is $\\sum_{j=1}^{n} p_j \\Pi_{ji}$. Note that the summation is over the first index of $\\Pi_{ji}$.\nThe fixed-point equation is therefore:\n$$ p_i = \\min\\left\\{\\bar{p}_i, x_i + \\sum_{j=1}^{n} \\Pi_{ji} p_j\\right\\} \\quad (*) $$\nA bank $i$ is solvent if it can pay its full liabilities, i.e., $p_i = \\bar{p}_i$. It defaults if $p_i  \\bar{p}_i$, which occurs when its available cash $c_i(p)$ is less than $\\bar{p}_i$. In case of default, the bank pays out all of its available cash, so $p_i = c_i(p)$.\n\n### Task A  B: The Fictitious Default Algorithm and Its Termination\n\nThe Fictitious Default Algorithm (FDA) is an iterative procedure to find this clearing vector $p$.\n\n**Algorithm Description (Task A Conceptual Basis)**\n\nThe algorithm iteratively builds a set of defaulting banks. Let $V = \\{1, \\dots, n\\}$ be the set of all banks.\n\n1.  **Initialization**: Start with a candidate set of defaulting banks $D_0 = \\emptyset$. The banks in $A_0 = V \\setminus D_0$ are assumed to be solvent.\n2.  **Iteration $k$ (for $k \\ge 1$)**:\n    a. Given the set of defaulters $D_{k-1}$ from the previous iteration, we define a hypothetical payment vector $p^{(k-1)}$. Banks $j \\in A_{k-1} = V \\setminus D_{k-1}$ are assumed to be solvent and pay their full obligations, i.e., $p_j^{(k-1)} = \\bar{p}_j$.\n    b. For banks $i \\in D_{k-1}$ (the fictitious defaulters), their payments are determined by their available cash. Their cash includes their exogenous assets $x_i$ plus receipts from all other banks. This leads to a system of linear equations for the payments $(p_i)_{i \\in D_{k-1}}$:\n       $$ p_i = x_i + \\sum_{j \\in A_{k-1}} \\Pi_{ji} \\bar{p}_j + \\sum_{j \\in D_{k-1}} \\Pi_{ji} p_j \\quad \\text{for all } i \\in D_{k-1} $$\n       This system can be written in matrix form as $(I - \\Pi_{D_{k-1}, D_{k-1}}^T) p_{D_{k-1}} = x_{D_{k-1}} + \\Pi_{D_{k-1}, A_{k-1}}^T \\bar{p}_{A_{k-1}}$, where $p_{D_{k-1}} = (p_i)_{i \\in D_{k-1}}$ and $\\Pi^T$ is the transpose of the relative liability matrix. The solution for $p_{D_{k-1}}$ gives the payments for the banks in $D_{k-1}$.\n    c. We now have the full hypothetical payment vector $p^{(k-1)}$, where components are $\\bar{p}_j$ for $j \\in A_{k-1}$ and the just-computed values for $j \\in D_{k-1}$.\n    d. Using this vector $p^{(k-1)}$, we identify the \"true\" defaulters. A bank $i$ defaults if its total available assets are less than its total liabilities:\n       $$ x_i + \\sum_{j=1}^n \\Pi_{ji} p_j^{(k-1)}  \\bar{p}_i $$\n       Let the set of all such banks be $D_k$.\n    e. **Termination Check**: If $D_k = D_{k-1}$, the set of defaulters has stabilized. The algorithm terminates, and the final clearing vector is $p = p^{(k-1)}$. Otherwise, we set $k \\to k+1$ and repeat the process.\n\n**Proof of Termination (Task B)**\n\nWe must prove that the algorithm terminates in at most $n$ iterations (of updating the default set).\n\n1.  **Monotonicity of Default Sets**: We show that the sequence of default sets is non-decreasing, i.e., $D_{k-1} \\subseteq D_k$ for all $k \\ge 1$.\n    Let $p^{(k-1)}$ be the hypothetical payment vector computed based on the default set $D_{k-1}$. By construction, for any bank $j$, we have $p_j^{(k-1)} \\le \\bar{p}_j$.\n    The set $D_k$ is defined as $D_k = \\{i \\in V \\mid x_i + \\sum_{j} \\Pi_{ji} p_j^{(k-1)}  \\bar{p}_i\\}$. For any bank $i \\in D_{k-1}$, its payment was determined by the clearing equation $p_i^{(k-1)} = x_i + \\sum_{j} \\Pi_{ji} p_j^{(k-1)}$. It is a known property of the EN model that a defaulting bank's payment is strictly less than its liability, so $p_i^{(k-1)}  \\bar{p}_i$. Substituting the equation for $p_i^{(k-1)}$ into this inequality gives $x_i + \\sum_{j} \\Pi_{ji} p_j^{(k-1)}  \\bar{p}_i$. This is exactly the condition for bank $i$ to be in $D_k$. Thus, any bank in $D_{k-1}$ must also be in $D_k$. Therefore, $D_{k-1} \\subseteq D_k$.\n\n2.  **Strict Increase or Termination**: The algorithm terminates if $D_k = D_{k-1}$. If it does not terminate, then $D_k \\neq D_{k-1}$. Combined with $D_{k-1} \\subseteq D_k$, this implies that $D_{k-1}$ is a strict subset of $D_k$.\n    Consequently, the cardinality of the default set must strictly increase: $|D_k|  |D_{k-1}|$.\n\n3.  **Bounded Growth**: The sequence of cardinalities $|D_0|, |D_1|, |D_2|, \\ldots$ is a sequence of integers. It starts at $|D_0| = 0$. As long as the algorithm does not terminate, the sequence is strictly increasing:\n    $$ 0 = |D_0|  |D_1|  |D_2|  \\dots $$\n    The set of defaulters is a subset of the set of all banks $V$, so its size is bounded by $n$: $|D_k| \\le n$.\n    A strictly increasing sequence of integers that is bounded above must be finite. The sequence can have at most $n+1$ elements ($0, 1, \\dots, n$). This means the set of defaulters can grow at most $n$ times. After at most $n$ iterations in which the default set is augmented, it must stabilize.\n\nTherefore, the Fictitious Default Algorithm is guaranteed to terminate in at most $n$ update iterations for a system of $n$ banks.\n\n### Task C: Application to Test Suite\n\nThe algorithm described above is implemented and applied to the four test cases. The implementation computes the relative liability matrix $\\Pi$, then enters the iterative loop of the FDA. Within each loop, it identifies the current sets of defaulting ($D$) and solvent ($A$) banks, solves the linear system for payments of banks in $D$, checks for new defaulters in $A$, and terminates when the set $D$ no longer grows.\n\n- **Test Case 1** is a \"happy path\" where all banks have sufficient exogenous assets and interbank receivables to cover their obligations. The algorithm terminates in the first iteration with an empty default set, so all banks pay their full liabilities, $p = \\bar{p}$.\n- **Test Case 2** exemplifies a contagion cascade. Initially assuming all banks are solvent leads to the discovery that none can meet their obligations. All three banks are added to the default set. The subsequent iteration solves a $3 \\times 3$ linear system for the defaulting banks' payments, at which point the default set stabilizes, and the algorithm terminates.\n- **Test Case 3** involves a bank with zero total obligations. Such a bank will always pay $p_i=0$, as this is the minimum of its obligation ($0$) and its assets. The other bank defaults, as it has zero exogenous assets and receives no payments.\n- **Test Case 4** is a simple single-bank system that defaults because its exogenous assets are less than its obligations to external creditors.\n\nThe final computed payment vectors $p$ for each test case are calculated by the provided program.",
            "answer": "```python\nimport numpy as np\n\ndef compute_clearing_vector(L, p_bar, x):\n    \"\"\"\n    Computes the Eisenberg-Noe clearing payment vector using the Fictitious Default Algorithm.\n\n    Args:\n        L (np.ndarray): The n x n matrix of nominal interbank liabilities.\n        p_bar (np.ndarray): The n-element vector of total nominal liabilities.\n        x (np.ndarray): The n-element vector of exogenous assets.\n\n    Returns:\n        np.ndarray: The n-element clearing payment vector p.\n    \"\"\"\n    n = L.shape[0]\n    if n == 0:\n        return np.array([])\n        \n    # Step 1: Compute the relative liability matrix Pi\n    pi = np.zeros_like(L, dtype=float)\n    for i in range(n):\n        if p_bar[i]  0:\n            pi[i, :] = L[i, :] / p_bar[i]\n\n    pi_T = pi.T  # Transpose for easier income calculation: income_i = (pi_T @ p)_i\n\n    # Step 2: Fictitious Default Algorithm\n    D_indices = set()\n    all_indices = set(range(n))\n\n    # The algorithm is guaranteed to terminate in at most n iterations.\n    # We loop n+1 times, with an early exit.\n    for _ in range(n + 1):\n        D_old_size = len(D_indices)\n        A_indices = all_indices - D_indices\n\n        D_list = sorted(list(D_indices))\n        A_list = sorted(list(A_indices))\n        \n        # Step 2a: Solve for payments of defaulting banks\n        p_iter = np.zeros(n, dtype=float)\n        \n        if D_list:\n            # System for defaulting banks: (I - Pi_T_DD) * p_D = x_D + Pi_T_DA * p_bar_A\n            pi_T_DD = pi_T[np.ix_(D_list, D_list)]\n            matrix = np.identity(len(D_list)) - pi_T_DD\n            \n            rhs = x[D_list]\n            if A_list:\n                pi_T_DA = pi_T[np.ix_(D_list, A_list)]\n                rhs += pi_T_DA @ p_bar[A_list]\n            \n            # Using try-except for singular matrix, although not expected in a well-formed EN model\n            try:\n                p_D = np.linalg.solve(matrix, rhs)\n                # Payments must be non-negative.\n                p_D[p_D  0] = 0\n                p_iter[D_list] = p_D\n            except np.linalg.LinAlgError:\n                # This case indicates a problem with the model setup, not expected here.\n                # As a fallback, assume they pay what they have without inter-default-group payments.\n                p_iter[D_list] = x[D_list]\n\n\n        # Step 2b: Assume solvent banks pay in full\n        p_iter[A_list] = p_bar[A_list]\n\n        # Step 2c: Check for new defaults among currently solvent banks\n        newly_defaulting_indices = set()\n        for i in A_list:\n            # Check p_bar  0 to avoid division by zero or nonsensical checks for banks with no obligations.\n            if p_bar[i]  0:\n                assets = x[i] + pi_T[i, :] @ p_iter\n                if assets  p_bar[i]:\n                    newly_defaulting_indices.add(i)\n        \n        D_indices.update(newly_defaulting_indices)\n\n        # Step 2d: Check for termination\n        if len(D_indices) == D_old_size:\n            # The set of defaulters did not grow, equilibrium found.\n            # Final clearing vector is p_iter, but we need to calculate it one last time\n            # with the final D set to return the correct vector.\n            \n            # The final correct payment vector `p` is the one that was just used to check for new defaults.\n            return p_iter\n\n    # This part should not be reached if the termination proof is correct.\n    raise RuntimeError(\"Algorithm failed to converge within n iterations.\")\n\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the solver.\n    \"\"\"\n    test_cases = [\n        {\n            \"L\": np.array([[0, 1, 0.5], [0.5, 0, 0.5], [0.2, 0.3, 0]]),\n            \"p_bar\": np.array([1.5, 1.0, 0.5]),\n            \"x\": np.array([2.0, 0.7, 0.6])\n        },\n        {\n            \"L\": np.array([[0, 0.9, 0], [0, 0, 0.9], [0.9, 0, 0]]),\n            \"p_bar\": np.array([1.5, 1.5, 1.5]),\n            \"x\": np.array([0.1, 0.1, 0.1])\n        },\n        {\n            \"L\": np.array([[0, 0], [0.4, 0]]),\n            \"p_bar\": np.array([0.0, 0.4]),\n            \"x\": np.array([0.0, 0.0])\n        },\n        {\n            \"L\": np.array([[0]]),\n            \"p_bar\": np.array([1.0]),\n            \"x\": np.array([0.3])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p = compute_clearing_vector(case['L'], case['p_bar'], case['x'])\n        results.append(list(p))\n\n    # Format output as specified: [[p_1,...,p_n], [p_1,...,p_m], ...]\n    # Example: [[1.5, 1.0, 0.5], [0.25, 0.25, 0.25]]\n    output_str = \"[\" + \",\".join([str(res) for res in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "With a robust model and algorithm in hand, we can move from passive analysis to active intervention. This final practice applies the Eisenberg-Noe framework to a critical policy question: what is the minimum capital injection required to stabilize a network and prevent a systemic collapse after an initial shock? By solving for this value, you will see how these quantitative models provide essential tools for regulators and policymakers aiming to mitigate systemic risk .",
            "id": "2435808",
            "problem": "Consider a financial system with $n$ institutions, represented by a directed weighted liability network. Let $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ be the nominal liability matrix where $L_{ij}$ is the obligation of institution $i$ to institution $j$. Define the total nominal liabilities vector $\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$ by\n$$\n\\bar{p}_i \\equiv \\sum_{j=1}^{n} L_{ij}.\n$$\nDefine the relative liability matrix $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ by\n$$\n\\Pi_{ij} \\equiv \n\\begin{cases}\n\\dfrac{L_{ij}}{\\bar{p}_i},  \\text{if } \\bar{p}_i  0, \\\\\n0,  \\text{if } \\bar{p}_i = 0,\n\\end{cases}\n$$\nso that each row of $\\Pi$ sums to at most $1$. Let $x \\in \\mathbb{R}_{\\ge 0}^{n}$ be the vector of external assets prior to any shock.\n\nAn initial shock of size $S_0 \\ge 0$ to a designated node $i \\in \\{1,\\dots,n\\}$ reduces its external assets to $x_i' = \\max\\{x_i - S_0, 0\\}$, while $x_k' = x_k$ for all $k \\ne i$. A non-negative capital injection $\\Delta C \\ge 0$ may then be allocated exclusively to the shocked node $i$, yielding post-injection external assets $x_i'' = x_i' + \\Delta C$ and $x_k'' = x_k'$ for all $k \\ne i$.\n\nPayments clear according to the Eisenberg–Noe fixed-point model: a clearing payment vector $p \\in \\mathbb{R}_{\\ge 0}^{n}$ must satisfy\n$$\np = \\min\\left\\{\\bar{p},\\, \\Pi^\\top p + x''\\right\\},\n$$\nwhere the minimum is taken componentwise and $x''$ is the post-injection external assets vector.\n\nDefine “stabilize the network” to mean that all institutions pay in full, i.e., the clearing payments equal the total nominal liabilities: $p = \\bar{p}$. In other words, stabilization requires that full repayment by all institutions is feasible under the Eisenberg–Noe model with the given shock and the capital injection applied only to node $i$.\n\nTask. For each test case below, compute the minimum capital injection $\\Delta C_{\\min}$ (in the same capital units as $x$ and $L$) required to stabilize the network after the initial shock of size $S_0$ to the specified node $i$. If no finite non-negative $\\Delta C$ allocated exclusively to node $i$ can achieve full repayment by all institutions, return the value $-1.0$ for that test case.\n\nYour program must produce a single line of output containing all results as a comma-separated list enclosed in square brackets, with each number rounded to exactly $6$ decimals. For example, a valid output for four results is of the form $[r_1,r_2,r_3,r_4]$ with each $r_k$ displayed to $6$ decimals.\n\nUse the following test suite. In each case, the network size is $n = 3$.\n\nTest case $1$ (general case):\n- Node index shocked: $i = 1$ (using $1$-based indexing; your program may use $0$-based internally but must respect the data as given here).\n- Initial shock: $S_0 = 1.5$.\n- Liability matrix:\n$$\nL = \\begin{bmatrix}\n0  2  0 \\\\\n0  0  1 \\\\\n1  0  0\n\\end{bmatrix}.\n$$\n- External assets:\n$$\nx = \\begin{bmatrix}\n2 \\\\\n1 \\\\\n0.5\n\\end{bmatrix}.\n$$\n\nTest case $2$ (already stable after shock, requiring zero injection):\n- Node index shocked: $i = 1$.\n- Initial shock: $S_0 = 0.2$.\n- Liability matrix:\n$$\nL = \\begin{bmatrix}\n0  2  0 \\\\\n0  0  1 \\\\\n1  0  0\n\\end{bmatrix}.\n$$\n- External assets:\n$$\nx = \\begin{bmatrix}\n2 \\\\\n1 \\\\\n0.5\n\\end{bmatrix}.\n$$\n\nTest case $3$ (impossible to stabilize by injecting only at the shocked node):\n- Node index shocked: $i = 3$.\n- Initial shock: $S_0 = 0$.\n- Liability matrix:\n$$\nL = \\begin{bmatrix}\n0  1  0 \\\\\n0  0  1 \\\\\n0  0  0\n\\end{bmatrix}.\n$$\n- External assets:\n$$\nx = \\begin{bmatrix}\n0.1 \\\\\n0.1 \\\\\n0.1\n\\end{bmatrix}.\n$$\n\nTest case $4$ (boundary case with a zero-liability node being shocked):\n- Node index shocked: $i = 1$.\n- Initial shock: $S_0 = 10.0$.\n- Liability matrix:\n$$\nL = \\begin{bmatrix}\n0  0  0 \\\\\n1  0  0 \\\\\n0  1  0\n\\end{bmatrix}.\n$$\n- External assets:\n$$\nx = \\begin{bmatrix}\n0.5 \\\\\n0.5 \\\\\n1.0\n\\end{bmatrix}.\n$$\n\nFinal output format requirement. Your program should produce a single line of output containing the results in order for Test cases $1$ through $4$ as a comma-separated list enclosed in square brackets, with each value rounded to exactly $6$ decimals, for example\n$$\n[\\Delta C_{\\min}^{(1)},\\Delta C_{\\min}^{(2)},\\Delta C_{\\min}^{(3)},\\Delta C_{\\min}^{(4)}].\n$$\nIf stabilization is impossible by injecting only at the shocked node, print $-1.000000$ for that case.",
            "solution": "The problem statement is subjected to validation.\n\nStep 1: Extract Givens\n- The number of institutions is $n$.\n- The nominal liability matrix is $L \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$, where $L_{ij}$ is the debt of institution $i$ to $j$.\n- The total nominal liabilities vector is $\\bar{p} \\in \\mathbb{R}_{\\ge 0}^{n}$, defined by $\\bar{p}_i \\equiv \\sum_{j=1}^{n} L_{ij}$.\n- The relative liability matrix is $\\Pi \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$, defined by $\\Pi_{ij} \\equiv L_{ij}/\\bar{p}_i$ if $\\bar{p}_i  0$, and $\\Pi_{ij} = 0$ if $\\bar{p}_i = 0$.\n- The vector of external assets is $x \\in \\mathbb{R}_{\\ge 0}^{n}$.\n- An initial shock of size $S_0 \\ge 0$ is applied to a designated node $i$.\n- The post-shock external assets vector $x'$ is defined by $x_i' = \\max\\{x_i - S_0, 0\\}$ and $x_k' = x_k$ for $k \\ne i$.\n- A capital injection $\\Delta C \\ge 0$ is allocated to the shocked node $i$.\n- The post-injection external assets vector $x''$ is defined by $x_i'' = x_i' + \\Delta C$ and $x_k'' = x_k'$ for $k \\ne i$.\n- The clearing payment vector $p \\in \\mathbb{R}_{\\ge 0}^{n}$ satisfies the fixed-point equation $p = \\min\\left\\{\\bar{p},\\, \\Pi^\\top p + x''\\right\\}$.\n- Network stabilization is defined as the condition where all institutions pay in full, i.e., $p = \\bar{p}$.\n- The task is to find the minimum capital injection $\\Delta C_{\\min}$ to stabilize the network. If stabilization by injecting only at node $i$ is not possible, the value is $-1.0$.\n- Four test cases are provided with specific values for $n$, $L$, $x$, $i$, and $S_0$.\n\nStep 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on the Eisenberg–Noe model of financial clearing, a cornerstone of systemic risk analysis in computational economics. The model is mathematically rigorous and widely accepted. The premises are factually sound within this framework.\n- **Well-Posed**: The problem asks for the minimum of a non-negative quantity, $\\Delta C$, subject to a set of linear inequalities. This structure is well-posed. The conditions for existence and uniqueness of a solution are well-defined by the problem's constraints.\n- **Objective**: All terms are defined with mathematical precision. The instructions are clear and unambiguous, free of subjective language.\n- **Completeness and Consistency**: The problem provides all necessary data ($L, x, i, S_0$) and definitions to formulate a solution. There are no internal contradictions.\n\nStep 3: Verdict and Action\nThe problem is valid. It is a well-defined mathematical exercise in the context of a recognized economic model. A solution will now be formulated.\n\nThe core of the problem is to determine the minimum non-negative capital injection, $\\Delta C_{\\min}$, required to achieve network stabilization. Stabilization is defined by the clearing payment vector $p$ being equal to the total nominal liabilities vector $\\bar{p}$, that is, $p = \\bar{p}$.\n\nThe clearing process is governed by the fixed-point equation:\n$$\np = \\min\\left\\{\\bar{p}, \\Pi^\\top p + x''\\right\\}\n$$\nwhere the minimum is taken component-wise. For stabilization to occur, we must have $p = \\bar{p}$. Substituting this condition into the equation yields:\n$$\n\\bar{p} = \\min\\left\\{\\bar{p}, \\Pi^\\top \\bar{p} + x''\\right\\}\n$$\nThis equality holds if and only if for every institution $k \\in \\{1, \\dots, n\\}$, the following inequality is satisfied:\n$$\n\\bar{p}_k \\le (\\Pi^\\top \\bar{p})_k + x''_k\n$$\nThis system of $n$ linear inequalities represents the condition that each institution's total available funds (incoming payments from other institutions, $\\Pi^\\top \\bar{p}$, plus its own post-injection external assets, $x''$) are sufficient to cover its total nominal liabilities, $\\bar{p}$. Let us expand the matrix-vector product term:\n$$\n(\\Pi^\\top \\bar{p})_k = \\sum_{j=1}^{n} (\\Pi^\\top)_{kj} \\bar{p}_j = \\sum_{j=1}^{n} \\Pi_{jk} \\bar{p}_j\n$$\nThe post-injection external assets vector $x''$ depends on the initial shock $S_0$ and the capital injection $\\Delta C$, both applied to a single node $i$. The components of $x''$ are:\n$$\nx''_k = \\begin{cases}\n\\max\\{x_i - S_0, 0\\} + \\Delta C,  \\text{if } k=i \\\\\nx_k,  \\text{if } k \\ne i \\text{ and } k \\text{ is not the shocked node}\n\\end{cases}\n$$\nMore precisely, the shock is applied to node $i$, after which the injection is applied to the same node $i$. Let the shocked node have index $i_{shock}$.\nThen for any node $k$:\n$$\nx'_k = \\begin{cases}\n\\max\\{x_{i_{shock}} - S_0, 0\\},  \\text{if } k=i_{shock} \\\\\nx_k,  \\text{if } k \\ne i_{shock}\n\\end{cases}\n$$\nAnd the post-injection assets are:\n$$\nx''_k = \\begin{cases}\nx'_{i_{shock}} + \\Delta C,  \\text{if } k=i_{shock} \\\\\nx'_k,  \\text{if } k \\ne i_{shock}\n\\end{cases}\n$$\nWe substitute this into our system of inequalities.\n\nFor any institution $k \\ne i_{shock}$, the stability condition is:\n$$\n\\bar{p}_k \\le \\sum_{j=1}^{n} \\Pi_{jk} \\bar{p}_j + x_k\n$$\nThis condition is independent of the shock $S_0$ and the injection $\\Delta C$. Let us define the \"solvency gap\" for each node $k$, pre-injection, as:\n$$\nG_k = \\bar{p}_k - \\left( \\sum_{j=1}^{n} \\Pi_{jk} \\bar{p}_j + x'_k \\right)\n$$\nFor stabilization to be possible by only injecting capital into node $i_{shock}$, all other nodes $k \\ne i_{shock}$ must be solvent on their own. That is, for all $k \\ne i_{shock}$, it must be that $G_k \\le 0$. If there exists any $k \\ne i_{shock}$ such that $G_k  0$, then no amount of capital injected into node $i_{shock}$ can remedy the shortfall at node $k$. In this case, stabilization is impossible, and the result is $-1.0$.\n\nFor the shocked node $k = i_{shock}$, the stability condition is:\n$$\n\\bar{p}_{i_{shock}} \\le \\sum_{j=1}^{n} \\Pi_{j,i_{shock}} \\bar{p}_j + x''_{i_{shock}}\n$$\nSubstituting $x''_{i_{shock}} = x'_{i_{shock}} + \\Delta C$:\n$$\n\\bar{p}_{i_{shock}} \\le \\sum_{j=1}^{n} \\Pi_{j,i_{shock}} \\bar{p}_j + x'_{i_{shock}} + \\Delta C\n$$\nWe can rearrange this inequality to solve for the required injection $\\Delta C$:\n$$\n\\Delta C \\ge \\bar{p}_{i_{shock}} - \\left( \\sum_{j=1}^{n} \\Pi_{j,i_{shock}} \\bar{p}_j + x'_{i_{shock}} \\right) = G_{i_{shock}}\n$$\nSince the capital injection must be non-negative ($\\Delta C \\ge 0$), the minimum capital injection required is $\\Delta C_{\\min} = \\max\\{0, G_{i_{shock}}\\}$.\n\nThe complete algorithm is as follows:\n1.  Given $L$, $x$, $i_{shock}$ (1-based), and $S_0$. Convert $i_{shock}$ to a 0-based index.\n2.  Compute the vector of total nominal liabilities $\\bar{p}$ from $L$: $\\bar{p}_i = \\sum_j L_{ij}$.\n3.  Compute the relative liability matrix $\\Pi$. For each row $i$: if $\\bar{p}_i  0$, $\\Pi_{ij} = L_{ij} / \\bar{p}_i$; otherwise $\\Pi_{ij} = 0$.\n4.  Compute the post-shock external asset vector $x'$. Let $i_{idx} = i_{shock} - 1$.\n    - $x'_{i_{idx}} = \\max\\{x_{i_{idx}} - S_0, 0\\}$.\n    - For all $k \\ne i_{idx}$, $x'_k = x_k$.\n5.  Compute the vector of total expected incoming payments from other institutions, assuming full repayment: $v = \\Pi^\\top \\bar{p}$.\n6.  For each institution $k=0, \\dots, n-1$, compute the solvency gap $G_k = \\bar{p}_k - (v_k + x'_k)$.\n7.  Check for impossibility. For each $k \\ne i_{idx}$, if $G_k  0$, stabilization is impossible. Return $-1.0$.\n8.  If the check in step 7 passes, calculate the minimum required injection: $\\Delta C_{\\min} = \\max\\{0, G_{i_{idx}}\\}$. Return this value.\n\nThis procedure correctly addresses all aspects of the problem statement.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the minimum capital injection to stabilize a financial network\n    for a series of test cases.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        {\n            \"shocked_node_idx\": 1,\n            \"S0\": 1.5,\n            \"L\": np.array([\n                [0, 2, 0],\n                [0, 0, 1],\n                [1, 0, 0]\n            ]),\n            \"x\": np.array([2, 1, 0.5])\n        },\n        {\n            \"shocked_node_idx\": 1,\n            \"S0\": 0.2,\n            \"L\": np.array([\n                [0, 2, 0],\n                [0, 0, 1],\n                [1, 0, 0]\n            ]),\n            \"x\": np.array([2, 1, 0.5])\n        },\n        {\n            \"shocked_node_idx\": 3,\n            \"S0\": 0.0,\n            \"L\": np.array([\n                [0, 1, 0],\n                [0, 0, 1],\n                [0, 0, 0]\n            ]),\n            \"x\": np.array([0.1, 0.1, 0.1])\n        },\n        {\n            \"shocked_node_idx\": 1,\n            \"S0\": 10.0,\n            \"L\": np.array([\n                [0, 0, 0],\n                [1, 0, 0],\n                [0, 1, 0]\n            ]),\n            \"x\": np.array([0.5, 0.5, 1.0])\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L = case[\"L\"]\n        x = case[\"x\"]\n        # Convert 1-based shocked_node_idx to 0-based index\n        shocked_node_idx_0based = case[\"shocked_node_idx\"] - 1\n        S0 = case[\"S0\"]\n        n = L.shape[0]\n\n        # Step 2: Compute total nominal liabilities p_bar\n        p_bar = np.sum(L, axis=1)\n\n        # Step 3: Compute relative liability matrix Pi\n        Pi = np.zeros_like(L, dtype=float)\n        # Use np.divide to handle division by zero where p_bar_i is 0\n        non_zero_liabilities = p_bar  1e-12 # Use tolerance for float comparison\n        Pi[non_zero_liabilities] = np.divide(\n            L[non_zero_liabilities], \n            p_bar[non_zero_liabilities, np.newaxis]\n        )\n\n        # Step 4: Compute post-shock external asset vector x_prime\n        x_prime = x.copy().astype(float)\n        x_prime[shocked_node_idx_0based] = np.maximum(\n            x[shocked_node_idx_0based] - S0, 0\n        )\n\n        # Step 5: Compute expected incoming payments v = Pi^T * p_bar\n        v = Pi.T @ p_bar\n\n        # Step 6: Compute solvency gaps G_k\n        # G_k = p_bar_k - (v_k + x_prime_k)\n        gaps = p_bar - (v + x_prime)\n\n        # Step 7: Check for impossibility\n        is_impossible = False\n        for k in range(n):\n            if k != shocked_node_idx_0based:\n                # If any non-shocked node has a positive gap, stabilization is impossible.\n                # A small tolerance is used for floating point comparisons.\n                if gaps[k]  1e-9:\n                    is_impossible = True\n                    break\n        \n        if is_impossible:\n            results.append(-1.0)\n            continue\n\n        # Step 8: Calculate minimum injection for the shocked node\n        # delta_C_min = max(0, G_{i_shock})\n        delta_C_min = np.maximum(0.0, gaps[shocked_node_idx_0based])\n        results.append(delta_C_min)\n\n    # Format the final output according to problem specification\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}