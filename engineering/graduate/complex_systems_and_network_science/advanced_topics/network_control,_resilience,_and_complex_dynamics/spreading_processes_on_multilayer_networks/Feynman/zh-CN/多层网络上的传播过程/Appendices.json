{
    "hands_on_practices": [
        {
            "introduction": "我们的第一个实践练习将作为一个基础性的思想实验。我们将采用最简洁的平均场近似来分析多层网络上的SIS（易感-感染-易感）模型，并将其结果与一个具有等效总度的单层网络进行比较。这项练习旨在揭示最简单模型的内在局限性，并强调为何需要更精细的理论来捕捉多层结构独有的复杂动态 ()。",
            "id": "4304228",
            "problem": "考虑一个$2$层多层网络，其节点集大小为$N$，由无自环的无向、简单邻接矩阵$A^{(1)}$和$A^{(2)}$表示。设第$1$层的平均度为$k^{(1)} \\equiv \\frac{1}{N}\\sum_{i,j} A^{(1)}_{ij}$，第$2$层的平均度为$k^{(2)} \\equiv \\frac{1}{N}\\sum_{i,j} A^{(2)}_{ij}$。一个易感-感染-易感 (SIS) 传播过程在该多层网络上按如下方式演化：每个易感节点在层 $\\ell \\in \\{1,2\\}$ 中从其每个受感染的邻居处以每个接触$\\beta_{\\ell}$的速率被感染，每个感染节点以速率$\\mu_{\\ell}$恢复，回到易感状态。假设在平均场意义下是均匀混合的：在任何时间$t$，任何节点被感染的概率对所有节点都是相同的，等于$x(t)$，并且忽略了节点间和层间的动态状态相关性。进一步假设$\\beta_{1}=\\beta_{2}=\\beta$和$\\mu_{1}=\\mu_{2}=\\mu$，且参数设置使得存在一个非平凡的地方病稳态。\n\n从平均场感染通量和恢复通量平衡的第一性原理出发，推导多层网络上地方病流行率$x^{\\ast}_{\\mathrm{multi}}$的闭式表达式。然后，考虑一个具有相同节点集和平均度$k_{\\mathrm{single}} \\equiv k^{(1)}+k^{(2)}$的单层网络，在该网络上，一个具有相同感染率$\\beta$和恢复率$\\mu$的SIS过程在相同的均匀混合近似下演化。推导这种单层情况下地方病流行率$x^{\\ast}_{\\mathrm{single}}$的闭式表达式。最后，给出差值$\\Delta \\equiv x^{\\ast}_{\\mathrm{multi}} - x^{\\ast}_{\\mathrm{single}}$的代数表达式。\n\n你的最终答案必须是单个解析表达式或一个包含所求表达式的行矩阵。如果方便，请用$\\beta$、$\\mu$、$k^{(1)}$和$k^{(2)}$表示你的最终答案，并写成行矩阵的形式。不包含任何单位。不需要进行数值评估或四舍五入。",
            "solution": "问题陈述经评估是有效的，因为它基于网络上传播动力学的既有理论，具有科学依据，提法良好，信息充分且一致，并使用客观、正式的语言进行表述。它代表了网络科学中的一个标准问题。\n\n我们的任务是在均匀平均场近似下，推导一个$2$层多层网络和一个等效单层网络上易感-感染-易感 (SIS) 过程的地方病流行率。\n\n设$x(t)$为在时间$t$时大小为$N$的群体中受感染节点的比例。在平均场框架下，$x(t)$的变化率由感染通量和恢复通量之间的平衡决定：\n$$\n\\frac{dx}{dt} = (\\text{人均新感染率}) - (\\text{人均恢复率})\n$$\n\n### 第1部分：多层网络上的地方病流行率 ($x^{\\ast}_{\\mathrm{multi}}$)\n\n人均恢复率涉及受感染节点返回易感状态。由于有比例为$x$的节点被感染，且每个节点以速率$\\mu$（因为$\\mu_1 = \\mu_2 = \\mu$）恢复，因此恢复通量为$\\mu x$。\n\n人均新感染率涉及易感节点被感染。易感节点的比例是$(1-x)$。一个易感节点可以被其在第1层或第2层的邻居感染。\n\n在均匀平均场近似下，我们假设任何邻居被感染的概率就是全局流行率$x$。作用于一个易感节点上的感染力是其所有邻居暴露率的总和。对于一个随机选择的节点，其在层$\\ell$中的平均邻居数是平均度$k^{(\\ell)}$。\n\n在两层中，来自单个受感染邻居的感染率均为$\\beta$（因为$\\beta_1 = \\beta_2 = \\beta$）。\n一个易感节点所经历的总感染力$\\lambda_{\\mathrm{multi}}$是来自两层的感染力之和：\n$$\n\\lambda_{\\mathrm{multi}} = (\\text{来自第1层的感染率}) + (\\text{来自第2层的感染率})\n$$\n$$\n\\lambda_{\\mathrm{multi}} = \\beta \\times (\\text{第1层中的平均邻居数}) \\times (\\text{邻居被感染的概率}) + \\beta \\times (\\text{第2层中的平均邻居数}) \\times (\\text{邻居被感染的概率})\n$$\n$$\n\\lambda_{\\mathrm{multi}} = \\beta k^{(1)} x + \\beta k^{(2)} x = \\beta (k^{(1)} + k^{(2)}) x\n$$\n人均新感染率是易感个体比例与该感染力的乘积：\n$$\n(\\text{人均新感染率}) = (1-x) \\lambda_{\\mathrm{multi}} = (1-x) \\beta (k^{(1)} + k^{(2)}) x\n$$\n结合感染项和恢复项，我们得到多层网络系统的平均场速率方程：\n$$\n\\frac{dx}{dt} = \\beta (k^{(1)} + k^{(2)}) x(1-x) - \\mu x\n$$\n在平衡状态下，$\\frac{dx}{dt} = 0$。这会产生两个解：\n$$\nx \\left( \\beta (k^{(1)} + k^{(2)}) (1-x) - \\mu \\right) = 0\n$$\n一个解是$x=0$，对应于无病平衡态 (DFE)。问题陈述指出存在一个非平凡的地方病稳态，这对应于第二个解，即括号中的项为零：\n$$\n\\beta (k^{(1)} + k^{(2)}) (1-x^{\\ast}_{\\mathrm{multi}}) - \\mu = 0\n$$\n解出地方病流行率$x^{\\ast}_{\\mathrm{multi}}$：\n$$\n1-x^{\\ast}_{\\mathrm{multi}} = \\frac{\\mu}{\\beta (k^{(1)} + k^{(2)})}\n$$\n$$\nx^{\\ast}_{\\mathrm{multi}} = 1 - \\frac{\\mu}{\\beta (k^{(1)} + k^{(2)})}\n$$\n\n### 第2部分：单层网络上的地方病流行率 ($x^{\\ast}_{\\mathrm{single}}$)\n\n接下来，我们考虑一个具有相同感染率$\\beta$、恢复率$\\mu$和平均度$k_{\\mathrm{single}} = k^{(1)} + k^{(2)}$的单层网络。该单层网络的平均场动力学可以使用相同的逻辑推导。\n\n恢复通量仍然是$\\mu x$。\n作用于易感节点上的感染力是$\\lambda_{\\mathrm{single}} = \\beta k_{\\mathrm{single}} x$。\n代入$k_{\\mathrm{single}} = k^{(1)} + k^{(2)}$，我们得到：\n$$\n\\lambda_{\\mathrm{single}} = \\beta (k^{(1)} + k^{(2)}) x\n$$\n人均新感染率为$(1-x) \\lambda_{\\mathrm{single}} = (1-x) \\beta (k^{(1)} + k^{(2)}) x$。\n因此，速率方程为：\n$$\n\\frac{dx}{dt} = \\beta (k^{(1)} + k^{(2)}) x(1-x) - \\mu x\n$$\n这个方程与为多层网络推导的方程完全相同。因此，非平凡的地方病稳态流行率$x^{\\ast}_{\\mathrm{single}}$也必然相同。求解地方病稳态$x^{\\ast}_{\\mathrm{single}} \\neq 0$：\n$$\n\\beta (k^{(1)} + k^{(2)}) (1-x^{\\ast}_{\\mathrm{single}}) - \\mu = 0\n$$\n$$\nx^{\\ast}_{\\mathrm{single}} = 1 - \\frac{\\mu}{\\beta (k^{(1)} + k^{(2)})}\n$$\n这个结果表明，在均匀平均场近似下，多层网络上的动力学与一个其平均度是多层网络各层平均度之和的单层网络上的动力学是无法区分的。这种近似有效地忽略了详细的层结构。\n\n### 第3部分：差值 $\\Delta$\n\n最后，我们计算差值$\\Delta \\equiv x^{\\ast}_{\\mathrm{multi}} - x^{\\ast}_{\\mathrm{single}}$。\n使用上面推导的表达式：\n$$\n\\Delta = \\left( 1 - \\frac{\\mu}{\\beta (k^{(1)} + k^{(2)})} \\right) - \\left( 1 - \\frac{\\mu}{\\beta (k^{(1)} + k^{(2)})} \\right)\n$$\n$$\n\\Delta = 0\n$$\n差值恰好为零。\n\n所求的三个量是$x^{\\ast}_{\\mathrm{multi}}$，$x^{\\ast}_{\\mathrm{single}}$和$\\Delta$。我们可以将它们表示为一个行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 - \\frac{\\mu}{\\beta (k^{(1)} + k^{(2)})}  1 - \\frac{\\mu}{\\beta (k^{(1)} + k^{(2)})}  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在认识到均匀混合模型的局限性之后，我们现在转向一种更精细的分析方法。本练习将介绍N-交织平均场近似（NIMFA）和超邻接矩阵的概念，这些是分析多层系统的核心工具。通过计算一个具体双层网络的特征值，我们将学习如何利用网络谱（即矩阵的特征值）来预测疫情爆发的阈值和规模，从而将抽象的线性代数工具与具体的流行病学预测联系起来 ()。",
            "id": "4304262",
            "problem": "考虑一个在双层多重网络上的易感-感染-易感 (SIS) 传播过程，该过程由N-交织平均场近似 (NIMFA) 建模。每层有 $3$ 个节点，且具有相同的层内邻接矩阵 $A \\in \\mathbb{R}^{3 \\times 3}$，由下式给出\n$$\nA \\;=\\; \\begin{pmatrix}\n0  1  1 \\\\\n1  0  1 \\\\\n1  1  0\n\\end{pmatrix}.\n$$\n层间耦合以权重 $\\omega = \\tfrac{1}{2}$ 连接各层间的副本节点，因此超邻接矩阵 $A^{\\mathrm{sup}} \\in \\mathbb{R}^{6 \\times 6}$ 呈分块形式\n$$\nA^{\\mathrm{sup}} \\;=\\; \\begin{pmatrix}\nA  \\omega I_{3} \\\\\n\\omega I_{3}  A\n\\end{pmatrix},\n$$\n其中 $I_{3}$ 是 $3 \\times 3$ 的单位矩阵。感染率为 $\\beta = \\tfrac{3}{5}$，恢复率为 $\\mu = \\tfrac{1}{5}$，因此感染率与恢复率之比为 $\\tau = \\beta / \\mu$。\n\n从SIS动态的N-交织平均场近似方程出发，并使用关于无病平衡点的线性化方法，推导流行病阈值条件，用相互作用算子的最大特征值表示。然后，采用基于在主特征向量上的投影的一维粗粒化方法，并对非线性项使用齐次闭合，来获得预测的稳态爆发规模（受感染节点的比例）$S_{\\mathrm{pred}}(\\tau,\\lambda)$ 的解析表达式，作为感染恢复比 $\\tau$ 和相关邻接算子的谱半径 $\\lambda$ 的函数。使用此表达式：\n\n- 计算完整双层系统的最大特征值 $\\lambda_{\\max}(A^{\\mathrm{sup}})$ 和缺少一整层得到的单层系统的最大特征值 $\\lambda_{\\max}(A)$。\n- 在给定的 $(\\beta,\\mu)$ 下，评估相应的预测爆发规模 $S_{\\mathrm{full}}$（双层）和 $S_{\\mathrm{miss}}$（缺少一层）。\n- 通过计算相对误差来量化缺少一整层的影响\n$$\nE_{\\mathrm{rel}} \\;=\\; \\frac{\\big|\\,S_{\\mathrm{full}} - S_{\\mathrm{miss}}\\,\\big|}{S_{\\mathrm{full}}}.\n$$\n\n以单个实数的形式提供最终的 $E_{\\mathrm{rel}}$。以小数或分数形式表示答案，不要使用百分号。如果选择小数表示，请将答案四舍五入到四位有效数字。",
            "solution": "用户想要解决一个关于双层网络上易感-感染-易感 (SIS) 流行病的问题。我将开始解题。\n\n### 第1步：问题验证\n\n**1.1. 提取已知条件**\n- **模型**：易感-感染-易感 (SIS) 过程，N-交织平均场近似 (NIMFA)。\n- **网络**：双层多重网络，每层 $3$ 个节点。\n- **层内邻接矩阵**：\n$$\nA \\;=\\; \\begin{pmatrix}\n0  1  1 \\\\\n1  0  1 \\\\\n1  1  0\n\\end{pmatrix}\n$$\n- **层间耦合权重**：$\\omega = \\frac{1}{2}$。\n- **超邻接矩阵**：\n$$\nA^{\\mathrm{sup}} \\;=\\; \\begin{pmatrix}\nA  \\omega I_{3} \\\\\n\\omega I_{3}  A\n\\end{pmatrix}\n$$\n- **感染率**：$\\beta = \\frac{3}{5}$。\n- **恢复率**：$\\mu = \\frac{1}{5}$。\n- **感染恢复比**：$\\tau = \\frac{\\beta}{\\mu}$。\n- **任务**：\n    1. 推导流行病阈值条件。\n    2. 使用一维粗粒化和齐次闭合，推导预测的稳态爆发规模 $S_{\\mathrm{pred}}(\\tau,\\lambda)$ 的解析表达式。\n    3. 计算最大特征值 $\\lambda_{\\max}(A^{\\mathrm{sup}})$ 和 $\\lambda_{\\max}(A)$。\n    4. 评估预测的爆发规模 $S_{\\mathrm{full}}$ 和 $S_{\\mathrm{miss}}$。\n    5. 计算相对误差 $E_{\\mathrm{rel}} = \\frac{|S_{\\mathrm{full}} - S_{\\mathrm{miss}}|}{S_{\\mathrm{full}}}$。\n\n**1.2. 使用提取的已知条件进行验证**\n- **科学依据**：该问题基于网络流行病学中标准、成熟的模型（SIS模型，NIMFA）和数学技术（线性稳定性分析，特征值分解）。设置是科学合理的。\n- **适定性**：该问题提供了所有必要的参数和矩阵，并要求一个唯一可确定的定量结果。结构逻辑清晰，可导向唯一解。\n- **客观性**：该问题使用精确的数学语言和定义进行陈述，没有歧义或主观因素。\n\n**1.3. 结论与行动**\n问题是有效的，因为它具有科学依据、适定性且客观。我将着手解决它。\n\n### 第2步：推导与计算\n\n**2.1. 流行病阈值和爆发规模公式**\n描述由邻接算子 $M$（可以是 $A$ 或 $A^{\\mathrm{sup}}$）定义的网络上的SIS模型的N-交织平均场近似 (NIMFA) 描述了节点 $i$ 被感染的概率 $p_i$ 的演化。微分方程组为：\n$$\n\\frac{dp_i}{dt} \\;=\\; -\\mu p_i + \\beta (1 - p_i) \\sum_{j} M_{ij} p_j\n$$\n以向量形式，此为 $\\frac{d\\vec{p}}{dt} = -\\mu \\vec{p} + \\beta \\text{diag}(\\vec{1}-\\vec{p}) M \\vec{p}$。无病平衡点 (DFE) 在 $\\vec{p} = \\vec{0}$。为了找到流行病阈值，我们在此平衡点附近对系统进行线性化。对于小的 $\\vec{p}$，$\\text{diag}(\\vec{1}-\\vec{p}) \\approx I$（单位矩阵）。线性化系统为：\n$$\n\\frac{d\\vec{p}}{dt} \\;\\approx\\; -\\mu I \\vec{p} + \\beta M \\vec{p} \\;=\\; (\\beta M - \\mu I) \\vec{p}\n$$\n如果雅可比矩阵 $J = \\beta M - \\mu I$ 的最大特征值为正，则DFE变得不稳定，导致流行病爆发。设 $\\lambda_{\\max}(M)$ 为 $M$ 的最大特征值（谱半径）。$J$ 的特征值为 $\\beta \\lambda_k(M) - \\mu$，其中 $\\lambda_k(M)$ 是 $M$ 的特征值。不稳定的条件是：\n$$\n\\beta \\lambda_{\\max}(M) - \\mu \\;\\; 0 \\quad \\implies \\quad \\frac{\\beta}{\\mu} \\lambda_{\\max}(M) \\;\\; 1 \\quad \\implies \\quad \\tau \\lambda_{\\max}(M) \\;\\; 1\n$$\n这就是流行病阈值条件。阈值在 $\\tau_c = 1/\\lambda_{\\max}(M)$。\n\n为了找到稳态爆发规模，我们设置 $\\frac{dp_i}{dt} = 0$：\n$$\n\\mu p_i \\;=\\; \\beta (1 - p_i) \\sum_{j} M_{ij} p_j\n$$\n问题要求使用一维粗粒化和齐次闭合。这包含两个近似：\n1. 感染分布与 $M$ 的主特征向量 $v_1$ 成正比：$\\vec{p} \\approx S \\vec{v_1}$。\n2. 项 $(1-p_i)$ 被全局平均值 $(1-S_{\\mathrm{pred}})$ 替代，其中 $S_{\\mathrm{pred}}$ 是受感染节点的平均比例。\n\n将第二个近似（齐次闭合）应用于稳态方程，得到：\n$$\n\\mu p_i \\;\\approx\\; \\beta (1 - S_{\\mathrm{pred}}) \\sum_{j} M_{ij} p_j\n$$\n以向量形式：$\\mu \\vec{p} \\approx \\beta (1 - S_{\\mathrm{pred}}) M \\vec{p}$。这可以重写为一个特征值方程：\n$$\nM \\vec{p} \\;\\approx\\; \\frac{\\mu}{\\beta (1 - S_{\\mathrm{pred}})} \\vec{p}\n$$\n对于一个非平凡稳态 ($\\vec{p} \\neq \\vec{0}$)，右侧的项必须是 $M$ 的一个特征值。为了使爆发从DFE中出现，$\\vec{p}$ 必须是主特征向量，因此标量必须是最大特征值 $\\lambda_{\\max}(M)$。\n$$\n\\lambda_{\\max}(M) \\;=\\; \\frac{\\mu}{\\beta (1 - S_{\\mathrm{pred}})} \\;=\\; \\frac{1}{\\tau (1 - S_{\\mathrm{pred}})}\n$$\n求解预测的爆发规模 $S_{\\mathrm{pred}}$：\n$$\n\\tau \\lambda_{\\max}(M) (1 - S_{\\mathrm{pred}}) \\;=\\; 1 \\quad \\implies \\quad 1 - S_{\\mathrm{pred}} \\;=\\; \\frac{1}{\\tau \\lambda_{\\max}(M)} \\quad \\implies \\quad S_{\\mathrm{pred}} \\;=\\; 1 - \\frac{1}{\\tau \\lambda_{\\max}(M)}\n$$\n这就是所要求的预测爆发规模的解析表达式，我们将其表示为 $S_{\\mathrm{pred}}(\\tau, \\lambda)$，其中 $\\lambda = \\lambda_{\\max}(M)$。\n\n**2.2. 特征值计算**\n首先，我们求层内矩阵 $A$ 的特征值。矩阵 $A$ 是移除了自环的完全图 $K_3$ 的邻接矩阵。$A = J - I_3$，其中 $J$ 是 $3 \\times 3$ 的全一矩阵。$J$ 的特征值为 $\\{3, 0, 0\\}$。因此，$A$ 的特征值为 $\\{3-1, 0-1, 0-1\\} = \\{2, -1, -1\\}$。单层系统的最大特征值为：\n$$\n\\lambda_{\\max}(A) \\;=\\; 2\n$$\n接下来，我们求超邻接矩阵 $A^{\\mathrm{sup}}$ 的特征值。设 $v$ 是 $A$ 的一个特征向量，其特征值为 $\\lambda_A$。我们寻找 $A^{\\mathrm{sup}}$ 的形如 $\\begin{pmatrix} v \\\\ \\alpha v \\end{pmatrix}$ 的特征向量。\n$$\nA^{\\mathrm{sup}} \\begin{pmatrix} v \\\\ \\alpha v \\end{pmatrix} \\;=\\; \\begin{pmatrix} A  \\omega I_3 \\\\ \\omega I_3  A \\end{pmatrix} \\begin{pmatrix} v \\\\ \\alpha v \\end{pmatrix} \\;=\\; \\begin{pmatrix} Av + \\omega (\\alpha v) \\\\ \\omega v + A(\\alpha v) \\end{pmatrix} \\;=\\; \\begin{pmatrix} (\\lambda_A + \\alpha \\omega)v \\\\ (\\omega + \\alpha \\lambda_A)v \\end{pmatrix}\n$$\n为了使之成为特征值为 $\\Lambda$ 的特征向量，我们必须有 $\\Lambda \\begin{pmatrix} v \\\\ \\alpha v \\end{pmatrix} = \\begin{pmatrix} \\Lambda v \\\\ \\Lambda \\alpha v \\end{pmatrix}$。这给出两个方程：\n$$\n\\Lambda \\;=\\; \\lambda_A + \\alpha \\omega\n$$\n$$\n\\Lambda \\alpha \\;=\\; \\omega + \\alpha \\lambda_A \\quad \\implies \\quad \\Lambda \\;=\\; \\frac{\\omega}{\\alpha} + \\lambda_A\n$$\n令 $\\Lambda$ 的表达式相等，得到 $\\alpha \\omega = \\frac{\\omega}{\\alpha}$，因为 $\\omega = \\frac{1}{2} \\neq 0$，这意味着 $\\alpha^2 = 1$，所以 $\\alpha = \\pm 1$。\n- 对于 $\\alpha=1$，特征值为 $\\Lambda_+ = \\lambda_A + \\omega$。\n- 对于 $\\alpha=-1$，特征值为 $\\Lambda_- = \\lambda_A - \\omega$。\n使用 $A$ 的特征值 $\\{2, -1, -1\\}$ 和 $\\omega = \\frac{1}{2}$：\n- 由 $\\lambda_A = 2$：$\\Lambda = 2 \\pm \\frac{1}{2}$，得到 $\\{2.5, 1.5\\}$。\n- 由 $\\lambda_A = -1$：$\\Lambda = -1 \\pm \\frac{1}{2}$，得到 $\\{-0.5, -1.5\\}$。由于 $\\lambda_A = -1$ 的重数为2，这些导出的特征值也是如此。\n$A^{\\mathrm{sup}}$ 的特征值集合是 $\\{2.5, 1.5, -0.5, -0.5, -1.5, -1.5\\}$。最大特征值为：\n$$\n\\lambda_{\\max}(A^{\\mathrm{sup}}) \\;=\\; 2.5 \\;=\\; \\frac{5}{2}\n$$\n\n**2.3. 爆发规模与相对误差计算**\n感染恢复比为 $\\tau = \\frac{\\beta}{\\mu} = \\frac{3/5}{1/5} = 3$。\n\n- **完整系统（双层）**：\n相关的邻接算子是 $A^{\\mathrm{sup}}$，其 $\\lambda_{\\mathrm{full}} = \\lambda_{\\max}(A^{\\mathrm{sup}}) = \\frac{5}{2}$。阈值参数为 $\\tau \\lambda_{\\mathrm{full}} = 3 \\times \\frac{5}{2} = \\frac{15}{2} = 7.5  1$，因此会发生爆发。\n预测的爆发规模是：\n$$\nS_{\\mathrm{full}} \\;=\\; 1 - \\frac{1}{\\tau \\lambda_{\\mathrm{full}}} \\;=\\; 1 - \\frac{1}{3 \\times \\frac{5}{2}} \\;=\\; 1 - \\frac{1}{\\frac{15}{2}} \\;=\\; 1 - \\frac{2}{15} \\;=\\; \\frac{13}{15}\n$$\n\n- **缺失层系统（单层）**：\n相关的邻接算子是 $A$，其 $\\lambda_{\\mathrm{miss}} = \\lambda_{\\max}(A) = 2$。阈值参数为 $\\tau \\lambda_{\\mathrm{miss}} = 3 \\times 2 = 6  1$，因此会发生爆发。\n预测的爆发规模是：\n$$\nS_{\\mathrm{miss}} \\;=\\; 1 - \\frac{1}{\\tau \\lambda_{\\mathrm{miss}}} \\;=\\; 1 - \\frac{1}{3 \\times 2} \\;=\\; 1 - \\frac{1}{6} \\;=\\; \\frac{5}{6}\n$$\n\n- **相对误差**：\n我们现在计算相对误差 $E_{\\mathrm{rel}}$。\n$$\nE_{\\mathrm{rel}} \\;=\\; \\frac{\\big|\\,S_{\\mathrm{full}} - S_{\\mathrm{miss}}\\,\\big|}{S_{\\mathrm{full}}} \\;=\\; \\frac{\\left| \\frac{13}{15} - \\frac{5}{6} \\right|}{\\frac{13}{15}}\n$$\n首先，计算分子中的差值。公分母是 $30$。\n$$\n\\frac{13}{15} - \\frac{5}{6} \\;=\\; \\frac{13 \\times 2}{15 \\times 2} - \\frac{5 \\times 5}{6 \\times 5} \\;=\\; \\frac{26}{30} - \\frac{25}{30} \\;=\\; \\frac{1}{30}\n$$\n现在，将此代回 $E_{\\mathrm{rel}}$ 的表达式中：\n$$\nE_{\\mathrm{rel}} \\;=\\; \\frac{\\frac{1}{30}}{\\frac{13}{15}} \\;=\\; \\frac{1}{30} \\times \\frac{15}{13} \\;=\\; \\frac{15}{30 \\times 13} \\;=\\; \\frac{1}{2 \\times 13} \\;=\\; \\frac{1}{26}\n$$\n问题要求以小数或分数形式给出答案。精确分数为 $\\frac{1}{26}$。\n作为四舍五入到四位有效数字的小数，$\\frac{1}{26} \\approx 0.0384615...$，即 $0.03846$。分数形式是精确的。",
            "answer": "$$\n\\boxed{\\frac{1}{26}}\n$$"
        },
        {
            "introduction": "理论分析为我们提供了深刻的见解，但计算实践对于验证这些见解和解决实际问题至关重要。最后一个练习将引导您从纸笔推导过渡到编程实现。您将通过精确枚举所有可能的传播路径（键渗流状态），来计算独立级联模型（IC模型）在小型多层网络上的期望爆发规模，并比较基于不同中心性指标（单层度中心性与多层PageRank）的种子节点选择策略的有效性 ()。",
            "id": "4304302",
            "problem": "您需要编写一个完整、可运行的程序，通过键渗流枚举计算精确的预期爆发规模，从而比较多层网络上传播过程的两种种子选择策略。该传播模型是在一个由 $N$ 个相同物理节点构成的 $L=2$ 层的多层网络上的独立级联（IC）模型。两种种子选择策略是：(i) 在指定层中按最高层内度数选择种子，以及 (ii) 按多层 PageRank 选择种子。您的任务是实现这两种策略，并为每个测试用例计算预期最终爆发比例的差异（多层 PageRank 种子选择减去层内度数种子选择），结果四舍五入到六位小数。程序必须输出单行内容：一个包含所有测试用例的浮点数列表，按顺序排列，用方括号括起来，并用逗号分隔。\n\n基本原理和定义：\n- 一个具有 $L=2$ 层的多层网络由大小为 $N \\times N$ 的邻接矩阵 $\\mathbf{A}^{[1]}$ 和 $\\mathbf{A}^{[2]}$ 给出，每个矩阵代表在相同的 $N$ 个标记节点 $\\{0,1,\\dots,N-1\\}$ 上的一个无向简单图。\n- 在无向图上的独立级联（IC）模型中，每个被感染的节点会尝试沿着每条边以概率（传播概率）$p$ 感染易感邻居节点，此过程仅发生一次，之后该节点变为非活动状态（恢复）。对于一个具有固定边传播概率 $p$ 的静态图，从给定种子集合开始的最终爆发集合，其分布与在一个键渗流图（其中每条边以概率 $p$ 独立保留（开放），以概率 $1-p$ 移除（关闭））中从该种子集合可达的连通分量相同。\n- 在一个具有 $L=2$ 层的多层网络上，假设层1和层2具有特定于层的传播概率 $p_1$ 和 $p_2$。每个层 $\\ell \\in \\{1,2\\}$ 都有其自己的每条边的开放概率 $p_\\ell$。通过任何层被感染的物理节点都会整体被感染，并能通过所有层进行传播；因此，从一个种子集合开始的最终爆发等于在渗流后各层的并集中包含这些种子的连通分量中的节点集合，其中层 $\\ell$ 的边以概率 $p_\\ell$ 独立开放。\n- 对于一个给定的种子集合，其预期的最终爆发规模可以通过枚举两层中所有边的所有键渗流状态来精确计算，用其概率对每个状态进行加权，并对包含种子的连通分量的并集大小求和。预期的最终爆发比例是预期规模除以 $N$。\n\n待比较的种子选择策略：\n- 层内度数种子选择：给定一个层索引 $\\ell \\in \\{1,2\\}$ 和一个种子预算 $k$，选择在 $\\mathbf{A}^{[\\ell]}$ 中度数最大的 $k$ 个节点。通过优先选择较小的节点索引来打破平局。\n- 多层 PageRank 种子选择：构建一个 $2N \\times 2N$ 的超邻接矩阵\n$$\n\\mathbf{W} = \\begin{pmatrix}\n\\mathbf{A}^{[1]}  \\omega \\mathbf{I} \\\\\n\\omega \\mathbf{I}  \\mathbf{A}^{[2]}\n\\end{pmatrix},\n$$\n其中 $\\omega \\ge 0$ 是层间耦合，它将每个节点与其在另一层中的副本连接起来。对于随机游走转移，将无向边视为双向的。通过对 $\\mathbf{W}$ 的行进行归一化来形成行随机转移矩阵 $\\mathbf{P}$；如果某行的和为零，则用在 $2N$ 个超节点上的均匀分布替换该行。将超图上的 PageRank (PR) 计算为以下方程的平稳解 $\\mathbf{r}$\n$$\n\\mathbf{r} = (1-\\alpha)\\mathbf{v} + \\alpha \\mathbf{P}^{\\top}\\mathbf{r},\n$$\n其中阻尼因子 $\\alpha \\in (0,1)$，$\\mathbf{v}$ 是在 $2N$ 个节点上的均匀瞬移向量。将物理节点的多层 PageRank 分数汇总为 $r_i^{\\text{phys}} = r_i + r_{i+N}$，然后选择具有最大 $r_i^{\\text{phys}}$ 的 $k$ 个节点，通过优先选择较小的索引来打破平局。\n\n算法要求：\n- 使用键渗流状态枚举来计算每种种子选择策略的精确预期最终爆发比例。对于每个层 $\\ell$，每条边都以概率 $p_\\ell$ 独立开放。对于每个渗流结果，考虑在 $N$ 个物理节点上跨两层的开放边的并集图，并计算从种子集合可达的节点数量。用其概率对每个结果进行加权。将期望值除以 $N$ 以获得爆发比例。\n- 对两种策略都实现按节点索引进行确定性平局打破。\n- 在所有测试用例中，PageRank 使用的阻尼因子 $\\alpha = 0.85$。每个测试用例使用其提供的 $\\omega$。\n\n测试套件：\n对于每个测试用例，计算差异\n$$\n\\Delta = \\text{预期爆发比例}(\\text{PR 种子}) - \\text{预期爆发比例}(\\text{度数种子})\n$$\n并四舍五入到六位小数。四个测试用例如下：\n\n- 测试用例 1 (基准测试 A，强调层1度数)：\n  - $N = 4$。\n  - 层 1 边：$(0,1),(1,2),(2,3)$。\n  - 层 2 边：$(0,1),(0,2),(0,3)$。\n  - 传播概率：$p_1 = 0.30$, $p_2 = 0.05$。\n  - 层间耦合：$\\omega = 0.5$。\n  - 种子预算：$k = 1$。\n  - 度数种子选择层：$\\ell = 1$。\n\n- 测试用例 2 (基准测试 A，强调层2传播概率)：\n  - 与测试用例 1 中相同的 $\\mathbf{A}^{[1]}$ 和 $\\mathbf{A}^{[2]}$。\n  - 传播概率：$p_1 = 0.05$, $p_2 = 0.30$。\n  - 层间耦合：$\\omega = 0.5$。\n  - 种子预算：$k = 1$。\n  - 度数种子选择层：$\\ell = 1$。\n\n- 测试用例 3 (基准测试 B，零层间耦合，多个种子)：\n  - $N = 5$。\n  - 层 1 边：$(0,1),(1,2),(2,3),(3,4),(4,0)$ (一个环)。\n  - 层 2 边：$(0,2),(1,3),(0,4)$。\n  - 传播概率：$p_1 = 0.20$, $p_2 = 0.20$。\n  - 层间耦合：$\\omega = 0.0$。\n  - 种子预算：$k = 2$。\n  - 度数种子选择层：$\\ell = 1$。\n\n- 测试用例 4 (边界情况：所有节点都作为种子)：\n  - 与测试用例 1 中相同的多层网络。\n  - 传播概率：$p_1 = 0.25$, $p_2 = 0.25$。\n  - 层间耦合：$\\omega = 1.0$。\n  - 种子预算：$k = 4$ (即所有节点)。\n  - 度数种子选择层：$\\ell = 2$。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来。第 $i$ 个条目必须是测试用例 $i$ 的 $\\Delta$ 值，四舍五入到六位小数，表示为十进制数（无百分号）。例如，一个有效的输出可能看起来像：\"[0.012345,-0.054321,0.000000,0.000000]\"。\n\n不提供用户输入；程序必须能直接运行。不涉及物理单位。不使用角度。所有计算必须是确定性的和可复现的。",
            "solution": "用户希望解决一个关于多层网络上传播过程的问题。\n\n### 第一步：提取已知条件\n- **多层网络**：$L=2$ 层，$N$ 个节点。邻接矩阵 $\\mathbf{A}^{[1]}$ 和 $\\mathbf{A}^{[2]}$ 是针对节点 $\\{0, 1, \\dots, N-1\\}$ 上的无向简单图。\n- **传播模型**：具有特定于层的传播概率 $p_1$ 和 $p_2$ 的独立级联（IC）模型。\n- **爆发规模**：从一个种子集合开始的最终爆发规模是在渗流后各层的并集图中包含这些种子的连通分量的大小。\n- **预期爆发规模计算**：必须通过枚举所有 $2^{M_{total}}$ 个键渗流状态来精确计算，其中 $M_{total}$ 是两层中边的总数。预期爆发比例是此预期规模除以 $N$。\n- **种子选择策略 1（层内度数）**：在指定的层 $\\ell \\in \\{1,2\\}$ 中选择度数最高的 $k$ 个节点。打破平局：优先选择较小的节点索引。\n- **种子选择策略 2（多层 PageRank）**：\n    - 构建超邻接矩阵：$\\mathbf{W} = \\begin{pmatrix} \\mathbf{A}^{[1]}  \\omega \\mathbf{I} \\\\ \\omega \\mathbf{I}  \\mathbf{A}^{[2]} \\end{pmatrix}$。\n    - 从 $\\mathbf{W}$ 创建一个行随机转移矩阵 $\\mathbf{P}$。$\\mathbf{W}$ 中和为零的行将被替换为在所有 $2N$ 个超节点上的均匀分布。\n    - 通过 $\\mathbf{r} = (1-\\alpha)\\mathbf{v} + \\alpha \\mathbf{P}^{\\top}\\mathbf{r}$ 计算 PageRank 向量 $\\mathbf{r}$，其中阻尼因子 $\\alpha = 0.85$，$\\mathbf{v}$ 是一个均匀瞬移向量。\n    - 汇总物理节点的分数：$r_i^{\\text{phys}} = r_i + r_{i+N}$。\n    - 选择具有最高 $r_i^{\\text{phys}}$ 的 $k$ 个节点。打破平局：优先选择较小的节点索引。\n- **任务**：对于每个测试用例，计算差异 $\\Delta = \\text{预期爆发比例}(\\text{PR 种子}) - \\text{预期爆发比例}(\\text{度数种子})$，四舍五入到六位小数。\n- **测试用例**：\n    - **用例 1**：$N=4$；层1边：$(0,1),(1,2),(2,3)$；层2边：$(0,1),(0,2),(0,3)$；$p_1=0.30, p_2=0.05$；$\\omega=0.5, k=1$；度数层 $\\ell=1$。\n    - **用例 2**：与用例1相同，但 $p_1=0.05, p_2=0.30$。\n    - **用例 3**：$N=5$；层1边：$(0,1),(1,2),(2,3),(3,4),(4,0)$；层2边：$(0,2),(1,3),(0,4)$；$p_1=0.20, p_2=0.20$；$\\omega=0.0, k=2$；度数层 $\\ell=1$。\n    - **用例 4**：与用例1相同，但 $p_1=0.25, p_2=0.25$；$\\omega=1.0, k=4$；度数层 $\\ell=2$。\n- **输出**：一行包含浮点数列表（每个用例计算出的 $\\Delta$），例如 `[0.012345,-0.054321,0.000000,0.000000]`。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学基础**：该问题在网络科学中有充分的依据。多层网络、独立级联模型、键渗流和 PageRank 都是标准概念。精确枚举的方法虽然计算密集，但对于小型网络是有效的。所有定义和公式都是标准的。\n- **定义明确**：问题被完全指定。每个测试用例都提供了所有必要的参数（$N$、边、$p_1, p_2, \\omega, k, \\ell$）。打破平局的规则是确定性的，确保了唯一的解决方案。\n- **客观性**：问题以精确、定量的术语陈述，没有主观性。\n- **缺陷分析**：\n    1.  **科学上不合理**：无。\n    2.  **无法形式化**：无。该问题是一个直接、可形式化的计算任务。\n    3.  **不完整/矛盾**：无。所有信息均已提供且一致。\n    4.  **不切实际/不可行**：键渗流状态的完全枚举（$2^M$ 个状态）对于给定的测试用例在计算上是可行的。用例 1、2、4 共有 $M=3+3=6$ 条边（$2^6=64$ 个状态）。用例 3 共有 $M=5+3=8$ 条边（$2^8=256$ 个状态）。这些数字都很小。\n    5.  **不适定**：无。问题定义明确，具有唯一、可计算的解。\n    6.  **过于简单**：否，该问题需要实现几个非平凡的算法（PageRank，带有 BFS 的状态空间枚举）。用例 4 是一个特殊情况（所有节点都作为种子），可作为一个逻辑上的健全性检查（差异 $\\Delta$ 必须为 $0$）。\n    7.  **无法验证**：否，计算是确定性的，可以独立验证。\n\n### 第三步：结论与行动\n问题是有效的。将开发并实施一个解决方案。\n\n### 基于原则的设计\n解决方案将分解为执行问题陈述所需的不同任务的逻辑组件。\n\n1.  **网络表示**：多层网络的两个层 $\\mathbf{A}^{[1]}$ 和 $\\mathbf{A}^{[2]}$ 将被表示为 $N \\times N$ 的 `numpy` 数组。每层的唯一边将存储在一个列表中，用于渗流枚举。\n\n2.  **种子选择策略实现**：\n    *   **层内度数种子选择**：一个函数将计算指定层 $\\ell$ 中所有节点的度数。然后它将按度数降序、节点索引升序对节点进行排序以处理平局，并选择前 $k$ 个节点。\n    *   **多层 PageRank 种子选择**：这涉及几个步骤：\n        a.  按定义构建 $2N \\times 2N$ 的超邻接矩阵 $\\mathbf{W}$。\n        b.  对 $\\mathbf{W}$ 进行归一化，形成行随机转移矩阵 $\\mathbf{P}$。特别注意和为零的行（悬挂节点），这些行将被替换为在所有 $2N$ 个超节点上的均匀概率分布。\n        c.  使用幂法对方程 $\\mathbf{r} = (1-\\alpha)\\mathbf{v} + \\alpha \\mathbf{P}^{\\top}\\mathbf{r}$ 进行迭代计算，以求得 PageRank 向量 $\\mathbf{r}$。迭代将持续固定步数或直到达到收敛。\n        d.  通过求和其副本的分数 $r_i^{\\text{phys}} = r_i + r_{i+N}$，来汇总每个物理节点 $i$ 的 PageRank 分数。\n        e.  根据这些汇总的分数选择前 $k$ 个种子，采用相同的打破平局规则（优先选择较小的节点索引）。\n\n3.  **预期爆发比例计算**：这是模拟的核心。将实现一个函数来为给定的种子集合执行此计算。\n    a.  两层上的总边数 $M = M_1 + M_2$ 决定了状态空间的大小，$2^M$。\n    b.  算法将遍历从 $0$ 到 $2^M - 1$ 的每个整数。每个整数的二进制表示对应一个唯一的键渗流状态（即开放和关闭边的配置）。\n    c.  对于每个状态，计算两个量：\n        i.  该状态的概率，即单个边概率的乘积：对于层 $\\ell$ 中的每个开放边为 $p_\\ell$，对于每个关闭边为 $(1-p_\\ell)$。\n        ii. 爆发的规模，即在该状态下由所有开放边形成的并集图中，从初始种子集合可达的节点数。这将使用从种子节点开始的广度优先搜索（BFS）来找到。\n    d.  预期规模是所有 $2^M$ 个状态的 `(爆发规模 * 状态概率)` 之和。\n    e.  最终的预期比例是预期规模除以 $N$。\n\n4.  **主执行逻辑**：主函数将处理四个测试用例。对于每个用例，它将：\n    a.  通过度数和 PageRank 两种策略确定种子集合。\n    b.  如果种子集合相同（如测试用例 4），则差异 $\\Delta$ 立即为 $0.0$。\n    c.  否则，它将为两个种子集合调用预期爆发比例计算函数。\n    d.  它将计算差异 $\\Delta$，将其四舍五入到六位小数，并存储起来。\n    e.  最后，它将所有结果格式化为所需的单行字符串输出。\n\n这种基于原则的方法确保问题的每个部分都由一个独立的、可验证的模块来处理，从而得到一个正确且健壮的最终程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the multiplex spreading problem.\n    It defines helper classes and functions, processes test cases, and prints the final result.\n    \"\"\"\n\n    class MultiplexSpreadingSolver:\n        \"\"\"\n        Encapsulates the logic for solving the problem for a single test case.\n        \"\"\"\n        def __init__(self, N, L1_edges, L2_edges, p1, p2, omega, k, degree_layer):\n            self.N = N\n            self.A1, self.edges1 = self._get_graph_data(L1_edges, N)\n            self.A2, self.edges2 = self._get_graph_data(L2_edges, N)\n            self.p1 = p1\n            self.p2 = p2\n            self.omega = omega\n            self.k = k\n            self.degree_layer = degree_layer\n            self.alpha = 0.85\n\n        def _get_graph_data(self, edge_list, N):\n            \"\"\"Constructs adjacency matrix and a unique edge list.\"\"\"\n            adj = np.zeros((N, N), dtype=int)\n            for u, v in edge_list:\n                adj[u, v] = 1\n                adj[v, u] = 1\n            \n            rows, cols = np.where(np.triu(adj, k=1))\n            unique_edges = list(zip(rows.tolist(), cols.tolist()))\n            return adj, unique_edges\n\n        def _get_degree_seeds(self):\n            \"\"\"Selects seeds based on per-layer degree.\"\"\"\n            A_deg = self.A1 if self.degree_layer == 1 else self.A2\n            degrees = A_deg.sum(axis=1)\n            # Sort by descending degree, then ascending node index for tie-breaking\n            nodes_with_degrees = sorted(enumerate(degrees), key=lambda x: (-x[1], x[0]))\n            seeds = {node_idx for node_idx, _ in nodes_with_degrees[:self.k]}\n            return seeds\n\n        def _get_pagerank_seeds(self):\n            \"\"\"Selects seeds based on multiplex PageRank.\"\"\"\n            # Trivial case: all nodes are seeded\n            if self.k == self.N:\n                return set(range(self.N))\n\n            # 1. Construct the supra-adjacency matrix W\n            W = np.zeros((2 * self.N, 2 * self.N))\n            W[0:self.N, 0:self.N] = self.A1\n            W[self.N:2 * self.N, self.N:2 * self.N] = self.A2\n            interlayer_coupling = self.omega * np.identity(self.N)\n            W[0:self.N, self.N:2 * self.N] = interlayer_coupling\n            W[self.N:2 * self.N, 0:self.N] = interlayer_coupling\n\n            # 2. Form row-stochastic transition matrix P\n            row_sums = W.sum(axis=1)\n            P = np.zeros_like(W)\n            \n            non_zero_rows_mask = row_sums != 0\n            P[non_zero_rows_mask] = W[non_zero_rows_mask] / row_sums[non_zero_rows_mask, np.newaxis]\n            \n            zero_rows_mask = ~non_zero_rows_mask\n            if np.any(zero_rows_mask):\n                P[zero_rows_mask, :] = 1.0 / (2 * self.N)\n\n            # 3. Compute PageRank via power iteration\n            PT = P.T\n            r = np.full(2 * self.N, 1.0 / (2 * self.N))\n            v = np.full(2 * self.N, 1.0 / (2 * self.N))\n            \n            for _ in range(100):  # 100 iterations are sufficient for convergence on small graphs\n                r_new = (1 - self.alpha) * v + self.alpha * (PT @ r)\n                if np.linalg.norm(r - r_new, 1)  1e-12:\n                    r = r_new\n                    break\n                r = r_new\n            \n            # 4. Aggregate scores and select seeds\n            phys_scores = r[0:self.N] + r[self.N:2 * self.N]\n            nodes_with_scores = sorted(enumerate(phys_scores), key=lambda x: (-x[1], x[0]))\n            seeds = {node_idx for node_idx, _ in nodes_with_scores[:self.k]}\n            return seeds\n\n        def _calculate_expected_fraction(self, seeds):\n            \"\"\"Computes exact expected outbreak fraction by enumerating percolation states.\"\"\"\n            if not seeds:\n                return 0.0\n\n            all_edges = self.edges1 + self.edges2\n            M1 = len(self.edges1)\n            M = len(all_edges)\n            \n            all_ps = [self.p1] * M1 + [self.p2] * len(self.edges2)\n            \n            total_expected_size = 0.0\n\n            # Iterate through all 2^M percolation states\n            for i in range(1  M):\n                state_prob = 1.0\n                open_edges = []\n                \n                # Determine state probability and the set of open edges\n                for j in range(M):\n                    is_open = (i  j)  1\n                    if is_open:\n                        state_prob *= all_ps[j]\n                        open_edges.append(all_edges[j])\n                    else:\n                        state_prob *= (1 - all_ps[j])\n                \n                # Build adjacency list for the percolated graph state\n                adj = {node: [] for node in range(self.N)}\n                for u, v in open_edges:\n                    adj[u].append(v)\n                    adj[v].append(u)\n                \n                # Find size of component(s) containing seeds using BFS\n                q = list(seeds)\n                visited = set(seeds)\n                head = 0\n                while head  len(q):\n                    u = q[head]\n                    head += 1\n                    for neighbor in adj[u]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            q.append(neighbor)\n                \n                component_size = len(visited)\n                total_expected_size += component_size * state_prob\n\n            return total_expected_size / self.N\n\n        def compute_difference(self):\n            \"\"\"Computes the main result: Delta = E_frac(PR) - E_frac(Degree).\"\"\"\n            seed_set_deg = self._get_degree_seeds()\n            seed_set_pr = self._get_pagerank_seeds()\n            \n            # Optimization: if seed sets are identical, the difference is zero.\n            if seed_set_deg == seed_set_pr:\n                return 0.0\n\n            exp_frac_deg = self._calculate_expected_fraction(seed_set_deg)\n            exp_frac_pr = self._calculate_expected_fraction(seed_set_pr)\n            \n            delta = exp_frac_pr - exp_frac_deg\n            return delta\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 4, \"L1_edges\": [(0, 1), (1, 2), (2, 3)], \"L2_edges\": [(0, 1), (0, 2), (0, 3)],\n            \"p1\": 0.30, \"p2\": 0.05, \"omega\": 0.5, \"k\": 1, \"degree_layer\": 1\n        },\n        {\n            \"N\": 4, \"L1_edges\": [(0, 1), (1, 2), (2, 3)], \"L2_edges\": [(0, 1), (0, 2), (0, 3)],\n            \"p1\": 0.05, \"p2\": 0.30, \"omega\": 0.5, \"k\": 1, \"degree_layer\": 1\n        },\n        {\n            \"N\": 5, \"L1_edges\": [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)], \"L2_edges\": [(0, 2), (1, 3), (0, 4)],\n            \"p1\": 0.20, \"p2\": 0.20, \"omega\": 0.0, \"k\": 2, \"degree_layer\": 1\n        },\n        {\n            \"N\": 4, \"L1_edges\": [(0, 1), (1, 2), (2, 3)], \"L2_edges\": [(0, 1), (0, 2), (0, 3)],\n            \"p1\": 0.25, \"p2\": 0.25, \"omega\": 1.0, \"k\": 4, \"degree_layer\": 2\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        solver_instance = MultiplexSpreadingSolver(**case_params)\n        delta = solver_instance.compute_difference()\n        # Round the result to six decimal places as required.\n        results.append(round(delta, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}