{
    "hands_on_practices": [
        {
            "introduction": "我们从一个基础的分析模型开始，旨在揭示过度简化假设的局限性。均质混合（或称均场）近似是网络科学中的一个基石，它假设所有节点都是等价的。这个练习将指导你推导在这种近似下，一个双层网络上的SIS传播过程的稳态感染率，并将其与一个具有等效总度的单层网络进行比较。其结果不仅能巩固你对基本流行病模型的理解，更能突显出简单的平均场理论在捕捉多层结构特有动态时可能存在的不足。",
            "id": "4304228",
            "problem": "考虑一个$2$层多层网络，其节点集对各层是共同的，大小为$N$，该网络由无向、简单且无自环的邻接矩阵 $A^{(1)}$ 和 $A^{(2)}$ 表示。设第$1$层的平均度为 $k^{(1)} \\equiv \\frac{1}{N}\\sum_{i,j} A^{(1)}_{ij}$，第$2$层的平均度为 $k^{(2)} \\equiv \\frac{1}{N}\\sum_{i,j} A^{(2)}_{ij}$。一个易感-感染-易感（SIS）传播过程在该多层网络上按如下方式演化：每个易感节点从其在第 $\\ell \\in \\{1,2\\}$ 层的每个已感染邻居处以每次接触 $\\beta_{\\ell}$ 的速率获得感染，并且每个已感染节点以速率 $\\mu_{\\ell}$ 恢复，回到易感状态。在平均场意义下假设均匀混合：在任意时刻 $t$，一个节点被感染的概率对所有节点都相同，等于 $x(t)$，并且节点间和层间的动态状态关联被忽略。进一步假设 $\\beta_{1}=\\beta_{2}=\\beta$ 和 $\\mu_{1}=\\mu_{2}=\\mu$，且参数取值保证存在一个非平凡的地方性流行病平衡态。\n\n从感染和恢复通量的平均场平衡这一基本原理出发，推导该多层网络上地方性流行率 $x^{\\ast}_{\\mathrm{multi}}$ 的闭式表达式。然后，考虑一个具有相同节点集和平均度 $k_{\\mathrm{single}} \\equiv k^{(1)}+k^{(2)}$ 的单层网络，在该网络上，一个具有相同感染率 $\\beta$ 和恢复率 $\\mu$ 的SIS过程在同样的均匀混合近似下演化。推导这种单层情况下地方性流行率 $x^{\\ast}_{\\mathrm{single}}$ 的闭式表达式。最后，给出差值 $\\Delta \\equiv x^{\\ast}_{\\mathrm{multi}} - x^{\\ast}_{\\mathrm{single}}$ 的代数表达式。\n\n你的最终答案必须是单个解析表达式，或是一个包含所求表达式的行矩阵。如果方便，请用关于 $\\beta$、$\\mu$、$k^{(1)}$ 和 $k^{(2)}$ 的行矩阵表示你的最终答案。答案中不应包含任何单位。无需进行数值计算或舍入。",
            "solution": "该问题陈述经评估是有效的，因为它科学地植根于已成熟的网络上传播动力学理论，问题提法适定（well-posed），信息充分且一致，并使用客观、正式的语言进行阐述。它代表了网络科学中的一个标准问题。\n\n我们的任务是在均匀平均场近似下，推导一个在$2$层多层网络和一个等效单层网络上的易感-感染-易感（SIS）过程的地方性流行率。\n\n设 $x(t)$ 为在时刻 $t$ 大小为 $N$ 的总体中已感染节点所占的比例。在平均场框架下，$x(t)$ 的变化率由感染通量和恢复通量之间的平衡所决定：\n$$\n\\frac{dx}{dt} = (\\text{人均新感染率}) - (\\text{人均恢复率})\n$$\n\n### 第1部分：多层网络上的地方性流行率 ($x^{\\ast}_{\\mathrm{multi}}$)\n\n人均恢复率涉及已感染节点返回易感状态。由于有比例为 $x$ 的节点被感染，且每个节点以速率 $\\mu$ 恢复（因为 $\\mu_1 = \\mu_2 = \\mu$），所以恢复通量为 $\\mu x$。\n\n人均新感染率涉及易感节点变为感染状态。易感节点的比例为 $(1-x)$。一个易感节点可以被其在第1层或第2层的邻居感染。\n\n在均匀平均场近似下，我们假设任何一个邻居被感染的概率就是全局流行率 $x$。作用于一个易感节点上的感染力是来自其所有邻居的感染速率之和。对于一个随机选择的节点，其在第 $\\ell$ 层的平均邻居数是平均度 $k^{(\\ell)}$。\n\n在两层中，来自单个已感染邻居的感染速率均为 $\\beta$（因为 $\\beta_1 = \\beta_2 = \\beta$）。\n一个易感节点所经历的总感染力 $\\lambda_{\\mathrm{multi}}$ 是来自两层的感染力之和：\n$$\n\\lambda_{\\mathrm{multi}} = (\\text{来自第1层的感染率}) + (\\text{来自第2层的感染率})\n$$\n$$\n\\lambda_{\\mathrm{multi}} = \\beta \\times (\\text{第1层的平均邻居数}) \\times (\\text{邻居被感染的概率}) + \\beta \\times (\\text{第2层的平均邻居数}) \\times (\\text{邻居被感染的概率})\n$$\n$$\n\\lambda_{\\mathrm{multi}} = \\beta k^{(1)} x + \\beta k^{(2)} x = \\beta (k^{(1)} + k^{(2)}) x\n$$\n人均新感染率是易感个体比例与此感染力的乘积：\n$$\n(\\text{人均新感染率}) = (1-x) \\lambda_{\\mathrm{multi}} = (1-x) \\beta (k^{(1)} + k^{(2)}) x\n$$\n结合感染项和恢复项，我们得到多层网络系统的平均场速率方程：\n$$\n\\frac{dx}{dt} = \\beta (k^{(1)} + k^{(2)}) x(1-x) - \\mu x\n$$\n在平衡状态下，$\\frac{dx}{dt} = 0$。这会得到两个解：\n$$\nx \\left( \\beta (k^{(1)} + k^{(2)}) (1-x) - \\mu \\right) = 0\n$$\n一个解是 $x=0$，对应于无病平衡态（DFE）。问题陈述中提到存在一个非平凡的地方性流行病平衡态，这对应于第二个解，即括号内的项为零：\n$$\n\\beta (k^{(1)} + k^{(2)}) (1-x^{\\ast}_{\\mathrm{multi}}) - \\mu = 0\n$$\n求解地方性流行率 $x^{\\ast}_{\\mathrm{multi}}$：\n$$\n1-x^{\\ast}_{\\mathrm{multi}} = \\frac{\\mu}{\\beta (k^{(1)} + k^{(2)})}\n$$\n$$\nx^{\\ast}_{\\mathrm{multi}} = 1 - \\frac{\\mu}{\\beta (k^{(1)} + k^{(2)})}\n$$\n\n### 第2部分：单层网络上的地方性流行率 ($x^{\\ast}_{\\mathrm{single}}$)\n\n接下来，我们考虑一个具有相同感染率 $\\beta$、恢复率 $\\mu$ 和平均度 $k_{\\mathrm{single}} = k^{(1)} + k^{(2)}$ 的单层网络。此单层网络的平均场动力学可使用相同的逻辑推导。\n\n恢复通量仍然是 $\\mu x$。\n作用于易感节点上的感染力是 $\\lambda_{\\mathrm{single}} = \\beta k_{\\mathrm{single}} x$。代入 $k_{\\mathrm{single}} = k^{(1)} + k^{(2)}$，我们得到：\n$$\n\\lambda_{\\mathrm{single}} = \\beta (k^{(1)} + k^{(2)}) x\n$$\n人均新感染率为 $(1-x) \\lambda_{\\mathrm{single}} = (1-x) \\beta (k^{(1)} + k^{(2)}) x$。因此，速率方程为：\n$$\n\\frac{dx}{dt} = \\beta (k^{(1)} + k^{(2)}) x(1-x) - \\mu x\n$$\n该方程与为多层网络推导的方程完全相同。因此，其非平凡的地方性流行病平衡率 $x^{\\ast}_{\\mathrm{single}}$ 也必然相同。求解地方性流行病稳态 $x^{\\ast}_{\\mathrm{single}} \\neq 0$：\n$$\n\\beta (k^{(1)} + k^{(2)}) (1-x^{\\ast}_{\\mathrm{single}}) - \\mu = 0\n$$\n$$\nx^{\\ast}_{\\mathrm{single}} = 1 - \\frac{\\mu}{\\beta (k^{(1)} + k^{(2)})}\n$$\n这个结果表明，在均匀平均场近似下，多层网络上的动力学与一个其平均度为多层各层平均度之和的单层网络上的动力学是不可区分的。这种近似有效地忽略了详细的层结构。\n\n### 第3部分：差值 $\\Delta$\n\n最后，我们计算差值 $\\Delta \\equiv x^{\\ast}_{\\mathrm{multi}} - x^{\\ast}_{\\mathrm{single}}$。使用上面推导出的表达式：\n$$\n\\Delta = \\left( 1 - \\frac{\\mu}{\\beta (k^{(1)} + k^{(2)})} \\right) - \\left( 1 - \\frac{\\mu}{\\beta (k^{(1)} + k^{(2)})} \\right)\n$$\n$$\n\\Delta = 0\n$$\n差值恰好为零。\n\n所求的三个量是 $x^{\\ast}_{\\mathrm{multi}}$、$x^{\\ast}_{\\mathrm{single}}$ 和 $\\Delta$。我们可以将它们表示为一个行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 - \\frac{\\mu}{\\beta (k^{(1)} + k^{(2)})}  1 - \\frac{\\mu}{\\beta (k^{(1)} + k^{(2)})}  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在认识到简单模型的局限性之后，我们转向一个更精细的分析框架——N-交织均场近似（NIMFA）。该模型不再假设所有节点等价，而是追踪每个节点的感染概率，其动态行为由超邻接矩阵的谱特性（最大特征值）决定。通过这个练习，你将亲手运用线性代数来分析流行病阈值和预测爆发规模，并定量评估缺失一整层网络结构对传播结果的巨大影响。这提供了一种将网络结构与宏观动态联系起来的强大工具。",
            "id": "4304262",
            "problem": "考虑一个在双层复用网络上的易感-感染-易感（SIS）传播过程，该过程由N-纠缠平均场近似（NIMFA）建模。每层有 $3$ 个节点，且具有相同的层内邻接矩阵 $A \\in \\mathbb{R}^{3 \\times 3}$，由下式给出：\n$$\nA \\;=\\; \\begin{pmatrix}\n0  1  1 \\\\\n1  0  1 \\\\\n1  1  0\n\\end{pmatrix}.\n$$\n层间耦合以权重 $\\omega = \\tfrac{1}{2}$ 连接跨层的副本节点，因此超邻接矩阵 $A^{\\mathrm{sup}} \\in \\mathbb{R}^{6 \\times 6}$ 采用以下分块形式：\n$$\nA^{\\mathrm{sup}} \\;=\\; \\begin{pmatrix}\nA  \\omega I_{3} \\\\\n\\omega I_{3}  A\n\\end{pmatrix},\n$$\n其中 $I_{3}$ 是 $3 \\times 3$ 的单位矩阵。感染率为 $\\beta = \\tfrac{3}{5}$，恢复率为 $\\mu = \\tfrac{1}{5}$，因此感染恢复比为 $\\tau = \\beta / \\mu$。\n\n从SIS动态的N-纠缠平均场近似方程出发，并使用围绕无病平衡点的线性化方法，推导以相互作用算子的最大特征值表示的流行病阈值条件。然后，采用基于向主特征向量投影的一维粗粒化方法，并对非线性项使用齐次闭合，以获得预测的稳态爆发规模（感染节点的分数）$S_{\\mathrm{pred}}(\\tau,\\lambda)$ 的解析表达式，该表达式是感染恢复比 $\\tau$ 和相关邻接算子谱半径 $\\lambda$ 的函数。使用此表达式：\n\n- 计算完整的双层系统的最大特征值 $\\lambda_{\\max}(A^{\\mathrm{sup}})$ 和缺少一整个单层所得到的单层系统的最大特征值 $\\lambda_{\\max}(A)$。\n- 在给定的 $(\\beta,\\mu)$ 下，评估相应的预测爆发规模 $S_{\\mathrm{full}}$（双层）和 $S_{\\mathrm{miss}}$（缺少一层）。\n- 通过计算相对误差来量化缺少整个层的影响\n$$\nE_{\\mathrm{rel}} \\;=\\; \\frac{\\big|\\,S_{\\mathrm{full}} - S_{\\mathrm{miss}}\\,\\big|}{S_{\\mathrm{full}}}.\n$$\n\n将最终的 $E_{\\mathrm{rel}}$ 以单个实数的形式给出。答案以小数或分数形式表示，不要使用百分号。如果选择小数表示，请将答案四舍五入到四位有效数字。",
            "solution": "用户想要解决一个关于双层网络上易感-感染-易感（SIS）流行病的问题。我将开始进行解答。\n\n### 步骤1：问题验证\n\n**1.1. 提取已知条件**\n- **模型**：易感-感染-易感（SIS）过程，N-纠缠平均场近似（NIMFA）。\n- **网络**：双层复用网络，每层 $3$ 个节点。\n- **层内邻接矩阵**：\n$$\nA \\;=\\; \\begin{pmatrix}\n0  1  1 \\\\\n1  0  1 \\\\\n1  1  0\n\\end{pmatrix}\n$$\n- **层间耦合权重**：$\\omega = \\frac{1}{2}$。\n- **超邻接矩阵**：\n$$\nA^{\\mathrm{sup}} \\;=\\; \\begin{pmatrix}\nA  \\omega I_{3} \\\\\n\\omega I_{3}  A\n\\end{pmatrix}\n$$\n- **感染率**：$\\beta = \\frac{3}{5}$。\n- **恢复率**：$\\mu = \\frac{1}{5}$。\n- **感染恢复比**：$\\tau = \\frac{\\beta}{\\mu}$。\n- **任务**：\n    1. 推导流行病阈值条件。\n    2. 使用一维粗粒化和齐次闭合，推导预测的稳态爆发规模 $S_{\\mathrm{pred}}(\\tau,\\lambda)$ 的解析表达式。\n    3. 计算最大特征值 $\\lambda_{\\max}(A^{\\mathrm{sup}})$ 和 $\\lambda_{\\max}(A)$。\n    4. 评估预测的爆发规模 $S_{\\mathrm{full}}$ 和 $S_{\\mathrm{miss}}$。\n    5. 计算相对误差 $E_{\\mathrm{rel}} = \\frac{|S_{\\mathrm{full}} - S_{\\mathrm{miss}}|}{S_{\\mathrm{full}}}$。\n\n**1.2. 使用提取的已知条件进行验证**\n- **科学依据**：该问题基于网络流行病学中的标准、成熟模型（SIS模型，NIMFA）和数学技术（线性稳定性分析，特征值分解）。设置在科学上是合理的。\n- **适定性**：该问题提供了所有必需的参数和矩阵，并要求一个唯一可确定的量化结果。结构逻辑清晰，导向唯一的解。\n- **客观性**：该问题使用精确的数学语言和定义进行陈述，没有歧义或主观因素。\n\n**1.3. 结论和行动**\n该问题是有效的，因为它有科学依据、适定且客观。我将继续解决它。\n\n### 步骤2：推导与计算\n\n**2.1. 流行病阈值和爆发规模公式**\n对于由邻接算子 $M$（可以是 $A$ 或 $A^{\\mathrm{sup}}$）描述的网络上的SIS模型，N-纠缠平均场近似（NIMFA）描述了节点 $i$ 被感染的概率 $p_i$ 的演化。该微分方程组为：\n$$\n\\frac{dp_i}{dt} \\;=\\; -\\mu p_i + \\beta (1 - p_i) \\sum_{j} M_{ij} p_j\n$$\n以向量形式表示，即为 $\\frac{d\\vec{p}}{dt} = -\\mu \\vec{p} + \\beta \\text{diag}(\\vec{1}-\\vec{p}) M \\vec{p}$。无病平衡点（DFE）在 $\\vec{p} = \\vec{0}$ 处。为了找到流行病阈值，我们围绕这个平衡点对系统进行线性化。对于小的 $\\vec{p}$，$\\text{diag}(\\vec{1}-\\vec{p}) \\approx I$（单位矩阵）。线性化后的系统为：\n$$\n\\frac{d\\vec{p}}{dt} \\;\\approx\\; -\\mu I \\vec{p} + \\beta M \\vec{p} \\;=\\; (\\beta M - \\mu I) \\vec{p}\n$$\n如果雅可比矩阵 $J = \\beta M - \\mu I$ 的最大特征值为正，则DFE变得不稳定，导致流行病爆发。设 $\\lambda_{\\max}(M)$ 为 $M$ 的最大特征值（谱半径）。$J$ 的特征值为 $\\beta \\lambda_k(M) - \\mu$，其中 $\\lambda_k(M)$ 是 $M$ 的特征值。不稳定的条件是：\n$$\n\\beta \\lambda_{\\max}(M) - \\mu \\;\\; 0 \\quad \\implies \\quad \\frac{\\beta}{\\mu} \\lambda_{\\max}(M) \\;\\; 1 \\quad \\implies \\quad \\tau \\lambda_{\\max}(M) \\;\\; 1\n$$\n这就是流行病阈值条件。阈值在 $\\tau_c = 1/\\lambda_{\\max}(M)$。\n\n为了求稳态爆发规模，我们令 $\\frac{dp_i}{dt} = 0$：\n$$\n\\mu p_i \\;=\\; \\beta (1 - p_i) \\sum_{j} M_{ij} p_j\n$$\n问题要求使用一维粗粒化和齐次闭合。这包含两个近似：\n1. 感染分布与 $M$ 的主特征向量 $v_1$ 成比例：$\\vec{p} \\approx S \\vec{v_1}$。\n2. 项 $(1-p_i)$ 被全局平均值 $(1-S_{\\mathrm{pred}})$ 替代，其中 $S_{\\mathrm{pred}}$ 是感染节点的平均分数。\n\n将第二个近似（齐次闭合）应用于稳态方程，得到：\n$$\n\\mu p_i \\;\\approx\\; \\beta (1 - S_{\\mathrm{pred}}) \\sum_{j} M_{ij} p_j\n$$\n向量形式为：$\\mu \\vec{p} \\approx \\beta (1 - S_{\\mathrm{pred}}) M \\vec{p}$。这可以重写为一个特征值方程：\n$$\nM \\vec{p} \\;\\approx\\; \\frac{\\mu}{\\beta (1 - S_{\\mathrm{pred}})} \\vec{p}\n$$\n对于非平凡稳态（$\\vec{p} \\neq \\vec{0}$），右侧的项必须是 $M$ 的一个特征值。为了使爆发从DFE中出现，$\\vec{p}$ 必须是主特征向量，因此该标量必须是最大特征值 $\\lambda_{\\max}(M)$。\n$$\n\\lambda_{\\max}(M) \\;=\\; \\frac{\\mu}{\\beta (1 - S_{\\mathrm{pred}})} \\;=\\; \\frac{1}{\\tau (1 - S_{\\mathrm{pred}})}\n$$\n求解预测的爆发规模 $S_{\\mathrm{pred}}$：\n$$\n\\tau \\lambda_{\\max}(M) (1 - S_{\\mathrm{pred}}) \\;=\\; 1 \\quad \\implies \\quad 1 - S_{\\mathrm{pred}} \\;=\\; \\frac{1}{\\tau \\lambda_{\\max}(M)} \\quad \\implies \\quad S_{\\mathrm{pred}} \\;=\\; 1 - \\frac{1}{\\tau \\lambda_{\\max}(M)}\n$$\n这就是所要求的预测爆发规模的解析表达式，我们将其记为 $S_{\\mathrm{pred}}(\\tau, \\lambda)$，其中 $\\lambda = \\lambda_{\\max}(M)$。\n\n**2.2. 特征值计算**\n首先，我们求层内矩阵 $A$ 的特征值。矩阵 $A$ 是移除了自环的完全图 $K_3$ 的邻接矩阵。$A = J - I_3$，其中 $J$ 是 $3 \\times 3$ 的全一矩阵。$J$ 的特征值为 $\\{3, 0, 0\\}$。因此，$A$ 的特征值为 $\\{3-1, 0-1, 0-1\\} = \\{2, -1, -1\\}$。单层系统的最大特征值为：\n$$\n\\lambda_{\\max}(A) \\;=\\; 2\n$$\n接下来，我们求超邻接矩阵 $A^{\\mathrm{sup}}$ 的特征值。设 $v$ 是 $A$ 的一个特征向量，其特征值为 $\\lambda_A$。我们寻找 $A^{\\mathrm{sup}}$ 形如 $\\begin{pmatrix} v \\\\ \\alpha v \\end{pmatrix}$ 的特征向量。\n$$\nA^{\\mathrm{sup}} \\begin{pmatrix} v \\\\ \\alpha v \\end{pmatrix} \\;=\\; \\begin{pmatrix} A  \\omega I_3 \\\\ \\omega I_3  A \\end{pmatrix} \\begin{pmatrix} v \\\\ \\alpha v \\end{pmatrix} \\;=\\; \\begin{pmatrix} Av + \\omega (\\alpha v) \\\\ \\omega v + A(\\alpha v) \\end{pmatrix} \\;=\\; \\begin{pmatrix} (\\lambda_A + \\alpha \\omega)v \\\\ (\\omega + \\alpha \\lambda_A)v \\end{pmatrix}\n$$\n为了使其成为一个特征值为 $\\Lambda$ 的特征向量，必须有 $\\Lambda \\begin{pmatrix} v \\\\ \\alpha v \\end{pmatrix} = \\begin{pmatrix} \\Lambda v \\\\ \\Lambda \\alpha v \\end{pmatrix}$。这给出两个方程：\n$$\n\\Lambda \\;=\\; \\lambda_A + \\alpha \\omega\n$$\n$$\n\\Lambda \\alpha \\;=\\; \\omega + \\alpha \\lambda_A \\quad \\implies \\quad \\Lambda \\;=\\; \\frac{\\omega}{\\alpha} + \\lambda_A\n$$\n令 $\\Lambda$ 的表达式相等，得到 $\\alpha \\omega = \\frac{\\omega}{\\alpha}$，因为 $\\omega = \\frac{1}{2} \\neq 0$，这意味着 $\\alpha^2 = 1$，所以 $\\alpha = \\pm 1$。\n- 对于 $\\alpha=1$，特征值为 $\\Lambda_+ = \\lambda_A + \\omega$。\n- 对于 $\\alpha=-1$，特征值为 $\\Lambda_- = \\lambda_A - \\omega$。\n使用 $A$ 的特征值 $\\{2, -1, -1\\}$ 和 $\\omega = \\frac{1}{2}$：\n- 由 $\\lambda_A = 2$：$\\Lambda = 2 \\pm \\frac{1}{2}$，得到 $\\{2.5, 1.5\\}$。\n- 由 $\\lambda_A = -1$：$\\Lambda = -1 \\pm \\frac{1}{2}$，得到 $\\{-0.5, -1.5\\}$。由于 $\\lambda_A = -1$ 的重数为2，这些导出的特征值也是如此。\n$A^{\\mathrm{sup}}$ 的特征值集合是 $\\{2.5, 1.5, -0.5, -0.5, -1.5, -1.5\\}$。最大特征值为：\n$$\n\\lambda_{\\max}(A^{\\mathrm{sup}}) \\;=\\; 2.5 \\;=\\; \\frac{5}{2}\n$$\n\n**2.3. 爆发规模与相对误差计算**\n感染恢复比为 $\\tau = \\frac{\\beta}{\\mu} = \\frac{3/5}{1/5} = 3$。\n\n- **完整系统（双层）**：\n相关的邻接算子是 $A^{\\mathrm{sup}}$，其 $\\lambda_{\\mathrm{full}} = \\lambda_{\\max}(A^{\\mathrm{sup}}) = \\frac{5}{2}$。阈值参数为 $\\tau \\lambda_{\\mathrm{full}} = 3 \\times \\frac{5}{2} = \\frac{15}{2} = 7.5 > 1$，因此会发生爆发。\n预测的爆发规模为：\n$$\nS_{\\mathrm{full}} \\;=\\; 1 - \\frac{1}{\\tau \\lambda_{\\mathrm{full}}} \\;=\\; 1 - \\frac{1}{3 \\times \\frac{5}{2}} \\;=\\; 1 - \\frac{1}{\\frac{15}{2}} \\;=\\; 1 - \\frac{2}{15} \\;=\\; \\frac{13}{15}\n$$\n\n- **缺层系统（单层）**：\n相关的邻接算子是 $A$，其 $\\lambda_{\\mathrm{miss}} = \\lambda_{\\max}(A) = 2$。阈值参数为 $\\tau \\lambda_{\\mathrm{miss}} = 3 \\times 2 = 6 > 1$，因此会发生爆发。\n预测的爆发规模为：\n$$\nS_{\\mathrm{miss}} \\;=\\; 1 - \\frac{1}{\\tau \\lambda_{\\mathrm{miss}}} \\;=\\; 1 - \\frac{1}{3 \\times 2} \\;=\\; 1 - \\frac{1}{6} \\;=\\; \\frac{5}{6}\n$$\n\n- **相对误差**：\n我们现在计算相对误差 $E_{\\mathrm{rel}}$。\n$$\nE_{\\mathrm{rel}} \\;=\\; \\frac{\\big|\\,S_{\\mathrm{full}} - S_{\\mathrm{miss}}\\,\\big|}{S_{\\mathrm{full}}} \\;=\\; \\frac{\\left| \\frac{13}{15} - \\frac{5}{6} \\right|}{\\frac{13}{15}}\n$$\n首先，计算分子的差。公分母是 $30$。\n$$\n\\frac{13}{15} - \\frac{5}{6} \\;=\\; \\frac{13 \\times 2}{15 \\times 2} - \\frac{5 \\times 5}{6 \\times 5} \\;=\\; \\frac{26}{30} - \\frac{25}{30} \\;=\\; \\frac{1}{30}\n$$\n现在，将此代回 $E_{\\mathrm{rel}}$ 的表达式中：\n$$\nE_{\\mathrm{rel}} \\;=\\; \\frac{\\frac{1}{30}}{\\frac{13}{15}} \\;=\\; \\frac{1}{30} \\times \\frac{15}{13} \\;=\\; \\frac{15}{30 \\times 13} \\;=\\; \\frac{1}{2 \\times 13} \\;=\\; \\frac{1}{26}\n$$\n问题要求答案以小数或分数形式给出。确切的分数是 $\\frac{1}{26}$。\n以四舍五入到四位有效数字的小数表示，$\\frac{1}{26} \\approx 0.0384615...$，即 $0.03846$。分数形式是精确的。",
            "answer": "$$\n\\boxed{\\frac{1}{26}}\n$$"
        },
        {
            "introduction": "最后的练习将理论付诸实践，从分析模型过渡到计算模拟。虽然解析模型能提供深刻的洞察，但对具体网络进行精确计算对于验证理论和评估干预策略至关重要。这项任务要求你编写程序，通过枚举所有可能的键渗流状态来精确计算独立级联模型中的预期爆发规模。这个编程实践不仅能加深你对多层网络传播基本定义的理解，还提供了一个严谨比较不同种子节点选择策略（例如基于度中心性和多层PageRank）有效性的框架。",
            "id": "4304302",
            "problem": "你需要编写一个完整、可运行的程序，通过键渗流枚举计算精确的预期爆发规模，从而比较多层网络上传播过程的两种种子策略。传播模型是在一个由 $L=2$ 个层构成的多层网络上的独立级联（IC）模型，该网络覆盖了同一组 $N$ 个物理节点。两种种子策略是：(i) 在指定层中按层度数最高选择种子，以及 (ii) 按多层 PageRank 选择种子。你的任务是实现这两种策略，并为每个测试用例计算预期最终爆发比例的差异（多层 PageRank 种子策略减去按层度数种子策略），结果四舍五入到六位小数。程序必须输出单行：一个包含所有测试用例结果的浮点数列表，按顺序排列，用方括号括起，并用逗号分隔。\n\n基本原理和定义：\n- 一个具有 $L=2$ 层的多层网络由大小为 $N \\times N$ 的邻接矩阵 $\\mathbf{A}^{[1]}$ 和 $\\mathbf{A}^{[2]}$ 给出，每个矩阵代表在同一组 $N$ 个带标签的节点 $\\{0,1,\\dots,N-1\\}$ 上的一个无向简单图。\n- 在无向图上的独立级联（IC）模型中，每个受感染节点会尝试沿着每条边以概率（传播率）$p$ 感染易感邻居，此过程仅发生一次，之后该节点变为非活动状态（恢复）。对于一个具有固定边传播率 $p$ 的静态图，给定种子集的最终爆发集合的分布，与在一个键渗流图中从该种子集可达的连通分量的分布相同。在键渗流图中，每条边独立地以概率 $p$ 保留（开放），以概率 $1-p$ 移除（闭合）。\n- 在一个具有 $L=2$ 层的多层网络上，假设层 1 和层 2 的传播率分别为 $p_1$ 和 $p_2$。每个层 $\\ell \\in \\{1,2\\}$ 都有其自身的每条边的开放概率 $p_\\ell$。一个通过任何层受感染的物理节点会整体上被感染，并能通过所有层进行传播；因此，从一个种子集开始的最终爆发等于在渗流后的各层并集中包含这些种子的连通分量中的节点集合，其中层 $\\ell$ 的边以概率 $p_\\ell$ 独立开放。\n- 对于给定的种子集，其预期的最终爆发规模可以通过枚举两层中所有边的所有键渗流状态来精确计算，将每个状态的规模按其概率加权，然后求和。预期的最终爆发比例是预期规模除以 $N$。\n\n待比较的种子策略：\n- 按层度数选择种子：给定一个层索引 $\\ell \\in \\{1,2\\}$ 和一个种子预算 $k$，选择在 $\\mathbf{A}^{[\\ell]}$ 中度数最大的 $k$ 个节点。若度数相同，则优先选择节点索引较小的。\n- 多层 PageRank 选择种子：构建一个 $2N \\times 2N$ 的超邻接矩阵\n$$\n\\mathbf{W} = \\begin{pmatrix}\n\\mathbf{A}^{[1]}  \\omega \\mathbf{I} \\\\\n\\omega \\mathbf{I}  \\mathbf{A}^{[2]}\n\\end{pmatrix},\n$$\n其中 $\\omega \\ge 0$ 是层间耦合，它将每个节点与其在另一层中的副本连接起来。将无向边视为用于随机游走转换的双向边。通过对 $\\mathbf{W}$ 的行进行归一化，形成行随机转移矩阵 $\\mathbf{P}$；如果某行的和为零，则用在所有 $2N$ 个超节点上的均匀分布替换该行。将超图上的 PageRank (PR) 计算为以下方程的稳态解 $\\mathbf{r}$：\n$$\n\\mathbf{r} = (1-\\alpha)\\mathbf{v} + \\alpha \\mathbf{P}^{\\top}\\mathbf{r},\n$$\n其中阻尼因子 $\\alpha \\in (0,1)$，$\\mathbf{v}$ 是在 $2N$ 个节点上的均匀传送向量。将物理节点的多层 PageRank 得分汇总为 $r_i^{\\text{phys}} = r_i + r_{i+N}$，然后选择具有最大 $r_i^{\\text{phys}}$ 的 $k$ 个节点，平局时选择索引较小的节点。\n\n算法要求：\n- 使用键渗流状态枚举来计算每种种子策略的精确预期最终爆发比例。对于每个层 $\\ell$，每条边都以概率 $p_\\ell$ 独立开放。对于每个渗流结果，考虑在 $N$ 个物理节点上跨两层的所有开放边的并集图，并计算从种子集可达的节点数。将每个结果按其概率加权。将期望值除以 $N$ 得到爆发比例。\n- 对两种策略都实现按节点索引的确定性平局打破规则。\n- 在所有测试用例中，PageRank 的阻尼因子使用 $\\alpha = 0.85$。每个测试用例使用其提供的 $\\omega$。\n\n测试套件：\n对于每个测试用例，计算差值\n$$\n\\Delta = \\text{ExpectedOutbreakFraction}(\\text{PR seeds}) - \\text{ExpectedOutbreakFraction}(\\text{Degree seeds})\n$$\n并四舍五入到六位小数。四个测试用例如下：\n\n- 测试用例 1（基准 A，层-1 度数侧重）：\n  - $N = 4$。\n  - 层 1 边：$(0,1),(1,2),(2,3)$。\n  - 层 2 边：$(0,1),(0,2),(0,3)$。\n  - 传播率：$p_1 = 0.30$, $p_2 = 0.05$。\n  - 层间耦合：$\\omega = 0.5$。\n  - 种子预算：$k = 1$。\n  - 按度数选择种子的层：$\\ell = 1$。\n\n- 测试用例 2（基准 A，层-2 传播率侧重）：\n  - $\\mathbf{A}^{[1]}$ 和 $\\mathbf{A}^{[2]}$ 与测试用例 1 相同。\n  - 传播率：$p_1 = 0.05$, $p_2 = 0.30$。\n  - 层间耦合：$\\omega = 0.5$。\n  - 种子预算：$k = 1$。\n  - 按度数选择种子的层：$\\ell = 1$。\n\n- 测试用例 3（基准 B，零层间耦合，多个种子）：\n  - $N = 5$。\n  - 层 1 边：$(0,1),(1,2),(2,3),(3,4),(4,0)$（一个环）。\n  - 层 2 边：$(0,2),(1,3),(0,4)$。\n  - 传播率：$p_1 = 0.20$, $p_2 = 0.20$。\n  - 层间耦合：$\\omega = 0.0$。\n  - 种子预算：$k = 2$。\n  - 按度数选择种子的层：$\\ell = 1$。\n\n- 测试用例 4（边界情况：所有节点都为种子）：\n  - 多层网络与测试用例 1 相同。\n  - 传播率：$p_1 = 0.25$, $p_2 = 0.25$。\n  - 层间耦合：$\\omega = 1.0$。\n  - 种子预算：$k = 4$（即所有节点）。\n  - 按度数选择种子的层：$\\ell = 2$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。第 $i$ 个条目必须是测试用例 $i$ 的 $\\Delta$，四舍五入到六位小数，表示为十进制数（无百分号）。例如，一个有效的输出可能看起来像：\"[0.012345,-0.054321,0.000000,0.000000]\"。\n\n程序无需用户输入；必须能直接运行。不涉及物理单位。不使用角度。所有计算必须是确定性的和可复现的。",
            "solution": "用户想要解决一个关于多层网络上传播过程的问题。\n\n### 第一步：提取已知条件\n- **多层网络**：$L=2$ 层，$N$ 个节点。邻接矩阵 $\\mathbf{A}^{[1]}$ 和 $\\mathbf{A}^{[2]}$ 是针对节点 $\\{0, 1, \\dots, N-1\\}$ 上的无向简单图。\n- **传播模型**：独立级联（IC），具有特定于层的传播率 $p_1$ 和 $p_2$。\n- **爆发规模**：从一个种子集开始的最终爆发规模是在渗流后的各层并集图中包含这些种子的连通分量的大小。\n- **预期爆发规模计算**：必须通过枚举所有 $2^{M_{total}}$ 个键渗流状态来精确计算，其中 $M_{total}$ 是两层中总的边数。预期爆发比例是这个预期规模除以 $N$。\n- **种子策略1（按层度数）**：在指定的层 $\\ell \\in \\{1,2\\}$ 中选择 $k$ 个度数最高的节点。平局打破规则：优先选择节点索引较小的。\n- **种子策略2（多层 PageRank）**：\n    - 构建超邻接矩阵：$\\mathbf{W} = \\begin{pmatrix} \\mathbf{A}^{[1]}  \\omega \\mathbf{I} \\\\ \\omega \\mathbf{I}  \\mathbf{A}^{[2]} \\end{pmatrix}$。\n    - 从 $\\mathbf{W}$ 创建一个行随机转移矩阵 $\\mathbf{P}$。$\\mathbf{W}$ 中和为零的行被替换为在所有 $2N$ 个超节点上的均匀分布。\n    - 通过 $\\mathbf{r} = (1-\\alpha)\\mathbf{v} + \\alpha \\mathbf{P}^{\\top}\\mathbf{r}$ 计算 PageRank 向量 $\\mathbf{r}$，其中阻尼因子 $\\alpha = 0.85$，$\\mathbf{v}$ 是一个均匀传送向量。\n    - 汇总物理节点的分数：$r_i^{\\text{phys}} = r_i + r_{i+N}$。\n    - 选择 $k$ 个具有最高 $r_i^{\\text{phys}}$ 的节点。平局打破规则：优先选择节点索引较小的。\n- **任务**：对于每个测试用例，计算差值 $\\Delta = \\text{ExpectedOutbreakFraction}(\\text{PR seeds}) - \\text{ExpectedOutbreakFraction}(\\text{Degree seeds})$，结果四舍五入到六位小数。\n- **测试用例**：\n    - **用例 1**：$N=4$；L1 边：$(0,1),(1,2),(2,3)$；L2 边：$(0,1),(0,2),(0,3)$；$p_1=0.30, p_2=0.05$；$\\omega=0.5, k=1$；度数层 $\\ell=1$。\n    - **用例 2**：与用例 1 相同，但 $p_1=0.05, p_2=0.30$。\n    - **用例 3**：$N=5$；L1 边：$(0,1),(1,2),(2,3),(3,4),(4,0)$；L2 边：$(0,2),(1,3),(0,4)$；$p_1=0.20, p_2=0.20$；$\\omega=0.0, k=2$；度数层 $\\ell=1$。\n    - **用例 4**：与用例 1 相同，但 $p_1=0.25, p_2=0.25$；$\\omega=1.0, k=4$；度数层 $\\ell=2$。\n- **输出**：包含每个用例计算出的 $\\Delta$ 的浮点数列表的单行，例如 `[0.012345,-0.054321,0.000000,0.000000]`。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学上合理**：该问题在网络科学领域有坚实的基础。多层网络、独立级联模型、键渗流和 PageRank 都是标准概念。精确枚举方法计算量大，但对于小型网络是可行的。所有定义和公式都是标准的。\n- **定义明确**：问题是完全指定的。为每个测试用例提供了所有必要的参数（$N$、边、$p_1, p_2, \\omega, k, \\ell$）。平局打破规则是确定性的，确保了唯一的解决方案。\n- **客观性**：问题以精确、定量的术语陈述，没有主观性。\n- **缺陷分析**：\n    1.  **科学上不健全**：无。\n    2.  **不可形式化**：无。该问题是一个直接、可形式化的计算任务。\n    3.  **不完整/矛盾**：无。所有信息都已提供且一致。\n    4.  **不切实际/不可行**：对键渗流状态的全枚举（$2^M$ 个状态）对于给定的测试用例是计算可行的。用例 1、2、4 共有 $M=3+3=6$ 条边（$2^6=64$ 个状态）。用例 3 共有 $M=5+3=8$ 条边（$2^8=256$ 个状态）。这些都是小数目。\n    5.  **不适定**：无。问题定义明确，有唯一的可计算解。\n    6.  **过于简单**：否，该问题需要实现几个不平凡的算法（PageRank、带 BFS 的状态空间枚举）。用例 4 是一个特殊情况（所有节点都是种子），它作为一个逻辑上的健全性检查（差值 $\\Delta$ 必须为 $0$）。\n    7.  **不可验证**：否，计算是确定性的，可以独立验证。\n\n### 第三步：结论与行动\n该问题有效。将开发并实现一个解决方案。\n\n### 基于原则的设计\n解决方案将被构造成执行问题陈述所要求的不同任务的逻辑组件。\n\n1.  **网络表示**：多层网络的两个层 $\\mathbf{A}^{[1]}$ 和 $\\mathbf{A}^{[2]}$ 将被表示为 $N \\times N$ 的 `numpy` 数组。每个层的唯一边将存储在一个列表中，用于渗流枚举。\n\n2.  **种子策略实现**：\n    *   **按层度数选择种子**：一个函数将计算指定层 $\\ell$ 中所有节点的度数。然后，它将首先按度数降序，然后按节点索引升序对节点进行排序以处理平局，并选择前 $k$ 个节点。\n    *   **多层 PageRank 选择种子**：这涉及几个步骤：\n        a.  按定义构建 $2N \\times 2N$ 的超邻接矩阵 $\\mathbf{W}$。\n        b.  对 $\\mathbf{W}$ 进行归一化，形成行随机转移矩阵 $\\mathbf{P}$。特别注意和为零的行（悬挂节点），这些行将被替换为在所有 $2N$ 个超节点上的均匀概率分布。\n        c.  使用幂迭代法在方程 $\\mathbf{r} = (1-\\alpha)\\mathbf{v} + \\alpha \\mathbf{P}^{\\top}\\mathbf{r}$ 上迭代计算 PageRank 向量 $\\mathbf{r}$。迭代将持续固定次数或直到达到收敛。\n        d.  通过求和其副本的分数来汇总每个物理节点 $i$ 的 PageRank 得分，$r_i^{\\text{phys}} = r_i + r_{i+N}$。\n        e.  基于这些汇总分数选择前 $k$ 个种子，使用相同的平局打破规则（优先选择节点索引较小的）。\n\n3.  **预期爆发比例计算**：这是模拟的核心。将实现一个函数，为给定的种子集执行此计算。\n    a.  两层总边数 $M = M_1 + M_2$ 决定了状态空间的大小 $2^M$。\n    b.  算法将遍历从 $0$ 到 $2^M - 1$ 的每个整数。每个整数的二进制表示对应一个唯一的键渗流状态（即开放和闭合边的配置）。\n    c.  对于每个状态，计算两个量：\n        i.  状态的概率，即单个边概率的乘积：对于层 $\\ell$ 中的每个开放边为 $p_\\ell$，对于每个闭合边为 $(1-p_\\ell)$。\n        ii. 爆发的规模，即在该状态下由所有开放边形成的并集图中，从初始种子集可达的节点数。这将使用从种子节点开始的广度优先搜索（BFS）找到。\n    d.  预期规模是所有 $2^M$ 个状态上 `(爆发规模 * 状态概率)` 的总和。\n    e.  最终的预期比例是预期规模除以 $N$。\n\n4.  **主执行逻辑**：主函数将处理四个测试用例中的每一个。对于每个用例，它将：\n    a.  根据度数和 PageRank 策略确定种子集。\n    b.  如果种子集相同（如测试用例 4 中），则差值 $\\Delta$ 立即为 $0.0$。\n    c.  否则，它将为两个种子集调用预期爆发比例计算函数。\n    d.  它将计算差值 $\\Delta$，将其四舍五入到六位小数，并存储它。\n    e.  最后，它将所有结果格式化为所需的单行字符串输出。\n\n这种基于原则的方法确保问题的每个部分都由一个独立的、可验证的模块来处理，从而得到一个正确且健壮的最终程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the multiplex spreading problem.\n    It defines helper classes and functions, processes test cases, and prints the final result.\n    \"\"\"\n\n    class MultiplexSpreadingSolver:\n        \"\"\"\n        Encapsulates the logic for solving the problem for a single test case.\n        \"\"\"\n        def __init__(self, N, L1_edges, L2_edges, p1, p2, omega, k, degree_layer):\n            self.N = N\n            self.A1, self.edges1 = self._get_graph_data(L1_edges, N)\n            self.A2, self.edges2 = self._get_graph_data(L2_edges, N)\n            self.p1 = p1\n            self.p2 = p2\n            self.omega = omega\n            self.k = k\n            self.degree_layer = degree_layer\n            self.alpha = 0.85\n\n        def _get_graph_data(self, edge_list, N):\n            \"\"\"Constructs adjacency matrix and a unique edge list.\"\"\"\n            adj = np.zeros((N, N), dtype=int)\n            for u, v in edge_list:\n                adj[u, v] = 1\n                adj[v, u] = 1\n            \n            rows, cols = np.where(np.triu(adj, k=1))\n            unique_edges = list(zip(rows.tolist(), cols.tolist()))\n            return adj, unique_edges\n\n        def _get_degree_seeds(self):\n            \"\"\"Selects seeds based on per-layer degree.\"\"\"\n            A_deg = self.A1 if self.degree_layer == 1 else self.A2\n            degrees = A_deg.sum(axis=1)\n            # Sort by descending degree, then ascending node index for tie-breaking\n            nodes_with_degrees = sorted(enumerate(degrees), key=lambda x: (-x[1], x[0]))\n            seeds = {node_idx for node_idx, _ in nodes_with_degrees[:self.k]}\n            return seeds\n\n        def _get_pagerank_seeds(self):\n            \"\"\"Selects seeds based on multiplex PageRank.\"\"\"\n            # Trivial case: all nodes are seeded\n            if self.k == self.N:\n                return set(range(self.N))\n\n            # 1. Construct the supra-adjacency matrix W\n            W = np.zeros((2 * self.N, 2 * self.N))\n            W[0:self.N, 0:self.N] = self.A1\n            W[self.N:2 * self.N, self.N:2 * self.N] = self.A2\n            interlayer_coupling = self.omega * np.identity(self.N)\n            W[0:self.N, self.N:2 * self.N] = interlayer_coupling\n            W[self.N:2 * self.N, 0:self.N] = interlayer_coupling\n\n            # 2. Form row-stochastic transition matrix P\n            row_sums = W.sum(axis=1)\n            P = np.zeros_like(W)\n            \n            non_zero_rows_mask = row_sums != 0\n            P[non_zero_rows_mask] = W[non_zero_rows_mask] / row_sums[non_zero_rows_mask, np.newaxis]\n            \n            zero_rows_mask = ~non_zero_rows_mask\n            if np.any(zero_rows_mask):\n                P[zero_rows_mask, :] = 1.0 / (2 * self.N)\n\n            # 3. Compute PageRank via power iteration\n            PT = P.T\n            r = np.full(2 * self.N, 1.0 / (2 * self.N))\n            v = np.full(2 * self.N, 1.0 / (2 * self.N))\n            \n            for _ in range(100):  # 100 iterations are sufficient for convergence on small graphs\n                r_new = (1 - self.alpha) * v + self.alpha * (PT @ r)\n                if np.linalg.norm(r - r_new, 1)  1e-12:\n                    r = r_new\n                    break\n                r = r_new\n            \n            # 4. Aggregate scores and select seeds\n            phys_scores = r[0:self.N] + r[self.N:2 * self.N]\n            nodes_with_scores = sorted(enumerate(phys_scores), key=lambda x: (-x[1], x[0]))\n            seeds = {node_idx for node_idx, _ in nodes_with_scores[:self.k]}\n            return seeds\n\n        def _calculate_expected_fraction(self, seeds):\n            \"\"\"Computes exact expected outbreak fraction by enumerating percolation states.\"\"\"\n            if not seeds:\n                return 0.0\n\n            all_edges = self.edges1 + self.edges2\n            M1 = len(self.edges1)\n            M = len(all_edges)\n            \n            all_ps = [self.p1] * M1 + [self.p2] * len(self.edges2)\n            \n            total_expected_size = 0.0\n\n            # Iterate through all 2^M percolation states\n            for i in range(1  M):\n                state_prob = 1.0\n                open_edges = []\n                \n                # Determine state probability and the set of open edges\n                for j in range(M):\n                    is_open = (i >> j)  1\n                    if is_open:\n                        state_prob *= all_ps[j]\n                        open_edges.append(all_edges[j])\n                    else:\n                        state_prob *= (1 - all_ps[j])\n                \n                # Build adjacency list for the percolated graph state\n                adj = {node: [] for node in range(self.N)}\n                for u, v in open_edges:\n                    adj[u].append(v)\n                    adj[v].append(u)\n                \n                # Find size of component(s) containing seeds using BFS\n                q = list(seeds)\n                visited = set(seeds)\n                head = 0\n                while head  len(q):\n                    u = q[head]\n                    head += 1\n                    for neighbor in adj[u]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            q.append(neighbor)\n                \n                component_size = len(visited)\n                total_expected_size += component_size * state_prob\n\n            return total_expected_size / self.N\n\n        def compute_difference(self):\n            \"\"\"Computes the main result: Delta = E_frac(PR) - E_frac(Degree).\"\"\"\n            seed_set_deg = self._get_degree_seeds()\n            seed_set_pr = self._get_pagerank_seeds()\n            \n            # Optimization: if seed sets are identical, the difference is zero.\n            if seed_set_deg == seed_set_pr:\n                return 0.0\n\n            exp_frac_deg = self._calculate_expected_fraction(seed_set_deg)\n            exp_frac_pr = self._calculate_expected_fraction(seed_set_pr)\n            \n            delta = exp_frac_pr - exp_frac_deg\n            return delta\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 4, \"L1_edges\": [(0, 1), (1, 2), (2, 3)], \"L2_edges\": [(0, 1), (0, 2), (0, 3)],\n            \"p1\": 0.30, \"p2\": 0.05, \"omega\": 0.5, \"k\": 1, \"degree_layer\": 1\n        },\n        {\n            \"N\": 4, \"L1_edges\": [(0, 1), (1, 2), (2, 3)], \"L2_edges\": [(0, 1), (0, 2), (0, 3)],\n            \"p1\": 0.05, \"p2\": 0.30, \"omega\": 0.5, \"k\": 1, \"degree_layer\": 1\n        },\n        {\n            \"N\": 5, \"L1_edges\": [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)], \"L2_edges\": [(0, 2), (1, 3), (0, 4)],\n            \"p1\": 0.20, \"p2\": 0.20, \"omega\": 0.0, \"k\": 2, \"degree_layer\": 1\n        },\n        {\n            \"N\": 4, \"L1_edges\": [(0, 1), (1, 2), (2, 3)], \"L2_edges\": [(0, 1), (0, 2), (0, 3)],\n            \"p1\": 0.25, \"p2\": 0.25, \"omega\": 1.0, \"k\": 4, \"degree_layer\": 2\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        solver_instance = MultiplexSpreadingSolver(**case_params)\n        delta = solver_instance.compute_difference()\n        # Round the result to six decimal places as required.\n        results.append(f\"{delta:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}