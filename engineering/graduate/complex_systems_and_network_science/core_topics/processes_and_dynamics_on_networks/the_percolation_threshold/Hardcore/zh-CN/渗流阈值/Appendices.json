{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握逾渗理论，必须能够推导其基础性结果。第一个实践  将引导你使用优美的生成函数方法，来计算构型模型网络中巨组分的大小。通过对一个简单的3-正则图完成这一推导，你将亲身体验支配随机网络相变的自洽方程。",
            "id": "4310629",
            "problem": "考虑一个度分布为 $P(k)$ 的组态模型（CM）网络，其中 $k \\in \\{0,1,2,\\ldots\\}$。令 $G_0(x)$ 表示度分布的生成函数（GF），$G_1(x)$ 表示剩余度分布的生成函数。假设在该网络上进行键逾渗（每条边以概率 $p \\in [0,1]$ 独立地保留），并且该组态模型在热力学极限下是局部树状的。仅使用度分布和剩余度分布的生成函数的基本定义以及树状图中分支的独立性，完成以下任务：\n\n1. 从 $P(k)$ 和剩余度分布 $q_k$ 的定义出发，构建 $G_0(x)$ 和 $G_1(x)$。其中 $q_k$ 的定义为：沿着一条均匀随机选择的半边到达一个节点，该节点所连接的其他边的数量等于 $k$ 的概率。\n\n2. 推导概率 $u$ 的自洽关系，其中 $u$ 指的是沿着一条均匀随机选择的被占据的边最终进入一个有限大小的连通分支（即，最终不会到达巨连通分支（GCC））的概率。然后，用 $G_0$ 和 $u$ 推导 GCC 大小 $S$ 的表达式。\n\n3. 将问题具体化到 $3$-正则 CM 网络的情况，即 $P(k)=\\delta_{k,3}$，其中 $\\delta_{i,j}$ 是克罗内克δ函数。针对这种情况，明确计算 $G_0(x)$ 和 $G_1(x)$，对普适的 $p$ 求解 $u$ 的自洽方程，然后得到 $S$ 作为 $p$ 的函数的闭式表达式。\n\n最后，计算当键占据概率 $p=\\tfrac{3}{4}$ 时的 GCC 大小 $S$。将最终答案以单个数字的形式给出。无需单位。除非您选择近似计算而非给出精确值，否则无需四舍五入；如果您进行近似计算，请将答案四舍五入到四位有效数字。",
            "solution": "用户提出的问题是网络科学和统计物理领域中一个有效且定义明确的问题。它要求推导键逾渗组态模型（CM）网络中巨连通分支（GCC）的大小，并具体化到 $3$-正则图的情况。推导过程将遵循生成函数方法。\n\n### 第1部分：生成函数的构建\n\n设 $P(k)$ 是网络的度分布。根据定义，度分布的生成函数（GF）为：\n$$G_0(x) = \\sum_{k=0}^{\\infty} P(k) x^k$$\n\n剩余度分布 $q_k$ 是指沿着一条均匀随机选择的边到达一个节点后，该节点还有 $k$ 条其他边的概率。为了求 $q_k$，我们首先计算一条随机选择的边连接到度为 $j$ 的节点的概率。连接到度为 $j$ 的节点的边数正比于 $j N P(j)$，其中 $N$ 是节点的总数。总的边端（或半边）数量为 $\\sum_j j N P(j) = N \\langle k \\rangle$，其中 $\\langle k \\rangle$ 是平均度。因此，一条随机选择的边指向一个度为 $j$ 的节点的概率是 $\\frac{j P(j)}{\\langle k \\rangle}$。\n\n如果该节点的度为 $j$，那么它有 $j-1$ 条其他边。所以，剩余度为 $k=j-1$。因此，概率 $q_k$ 就是到达一个原始度为 $k+1$ 的节点的概率：\n$$q_k = \\frac{(k+1) P(k+1)}{\\langle k \\rangle}$$\n剩余度分布的生成函数 $G_1(x)$ 为：\n$$G_1(x) = \\sum_{k=0}^{\\infty} q_k x^k = \\sum_{k=0}^{\\infty} \\frac{(k+1) P(k+1)}{\\langle k \\rangle} x^k$$\n我们可以将其与 $G_0(x)$ 的导数联系起来。我们有 $G_0'(x) = \\sum_{k=1}^{\\infty} k P(k) x^{k-1}$。让我们在 $G_1(x)$ 的求和中改变指标，令 $j=k+1$：\n$$G_1(x) = \\frac{1}{\\langle k \\rangle} \\sum_{j=1}^{\\infty} j P(j) x^{j-1} = \\frac{G_0'(x)}{\\langle k \\rangle}$$\n平均度可以计算为 $\\langle k \\rangle = \\sum_k k P(k) = G_0'(1)$。因此：\n$$G_1(x) = \\frac{G_0'(x)}{G_0'(1)}$$\n\n### 第2部分：自洽关系与GCC大小\n\n在键逾渗中，每条边以概率 $p$ 保留。对于一个局部树状网络，我们可以通过追踪沿边的路径来分析连通分支的大小。\n\n设 $u$ 为沿着一条随机选择的被占据的边最终进入一个有限连通分支的概率。我们希望找到 $u$ 的自洽方程。考虑从节点A沿着一条被占据的边到达节点B。要使这条路径导向一个有限连通分支，与节点B相连的连通分支（不包括从A来的路径）必须是有限的。节点B在原始网络中有一个剩余度，其生成函数为 $G_1(x)$。经过逾渗后，它的每条潜在边都以概率 $p$ 被保留。从B出发的*被占据*的边的数量（其在逾渗图中的剩余度）的生成函数是 $G_1(1-p+px)$。设这个数量为 $k'$。为了使包含B的连通分支是有限的，所有这 $k'$ 个出射分支本身都必须导向有限连通分支。根据定义，每个这样的分支是有限的概率为 $u$。由于在树状结构中各个分支是独立的，所有 $k'$ 个分支都是有限的概率为 $u^{k'}$。\n\n对所有可能的 $k'$ 值进行求和，并用它们的概率（即生成函数 $G_1(1-p+px)$ 的系数）加权，我们得到自洽方程：\n$$u = \\sum_{k'=0}^{\\infty} \\text{剩余度为 } k' \\text{的概率} u^{k'} = G_1(1-p+pu)$$\n这就是所要求的自洽关系。当且仅当网络处于逾渗阈值之上时，才存在非平凡解 $u  1$，这表明存在一个GCC。平凡解 $u=1$ 总是存在的，它对应于所有连通分支都是有限的情况。\n\n现在，设 $S$ 为GCC的相对大小。$S$ 等于 $1$ 减去一个随机选择的节点属于有限连通分支的概率。一个随机选择的节点具有由 $G_0(x)$ 生成的度分布。逾渗之后，其度的生成函数变为 $G_0(1-p+px)$。对于一个有 $k'$ 条被占据的边的节点，要使其处于一个有限连通分支中，所有 $k'$ 个分支都必须导向有限连通分支。这种情况的概率是 $u^{k'}$。一个随机节点属于有限连通分支的概率可以通过对逾渗度分布求 $u^{k'}$ 的平均值得到：\n$$\\text{节点处于有限连通分支的概率} = \\sum_{k'=0}^{\\infty} \\text{度为 } k' \\text{的概率} u^{k'} = G_0(1-p+pu)$$\n因此，GCC的大小为：\n$$S = 1 - G_0(1-p+pu)$$\n\n### 第3部分：具体化到3-正则网络\n\n对于一个 $3$-正则网络，每个节点的度都为 $k=3$。度分布为 $P(k) = \\delta_{k,3}$，其中 $\\delta_{i,j}$ 是克罗内克δ函数。\n\n首先，我们计算 $G_0(x)$ 和 $G_1(x)$：\n$$G_0(x) = \\sum_{k=0}^{\\infty} \\delta_{k,3} x^k = x^3$$\n平均度为 $\\langle k \\rangle = G_0'(1)$。由于 $G_0'(x) = 3x^2$，我们有 $\\langle k \\rangle = 3(1)^2=3$。剩余度生成函数为：\n$$G_1(x) = \\frac{G_0'(x)}{G_0'(1)} = \\frac{3x^2}{3} = x^2$$\n\n现在，我们求解 $u$ 的自洽方程：\n$$u = G_1(1-p+pu) = (1-p+pu)^2$$\n这是一个关于 $u$ 的二次方程：\n$$u = (1-p)^2 + 2p(1-p)u + p^2u^2$$\n$$p^2u^2 + (2p-2p^2-1)u + (1-p)^2 = 0$$\n使用二次方程求根公式 $u = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$，其中 $a=p^2$，$b=2p-2p^2-1$，$c=(1-p)^2$：\n判别式为 $\\Delta = (2p-2p^2-1)^2 - 4p^2(1-p)^2 = (-(1-2p+2p^2))^2 - (2p(1-p))^2$。这是一个平方差：$\\Delta = (1-2p+2p^2 - (2p-2p^2))(1-2p+2p^2 + (2p-2p^2)) = (1-4p+4p^2)(1) = (1-2p)^2$。所以，$\\sqrt{\\Delta} = |1-2p|$。\n$u$ 的解为：\n$$u = \\frac{-(2p-2p^2-1) \\pm |1-2p|}{2p^2} = \\frac{1-2p+2p^2 \\pm |1-2p|}{2p^2}$$\n逾渗阈值为 $p_c = 1/\\langle k-1 \\rangle = 1/G_1'(1) = 1/2$。对于 $p > p_c = 1/2$，我们有 $|1-2p| = 2p-1$。我们寻找解 $u  1$。\n两个解是：\n$$u_+ = \\frac{1-2p+2p^2 + (2p-1)}{2p^2} = \\frac{2p^2}{2p^2} = 1$$\n$$u_- = \\frac{1-2p+2p^2 - (2p-1)}{2p^2} = \\frac{2-4p+2p^2}{2p^2} = \\frac{p^2-2p+1}{p^2} = \\left(\\frac{p-1}{p}\\right)^2 = \\left(\\frac{1-p}{p}\\right)^2$$\n对于 $p > 1/2$，我们有 $p > 1-p$，所以 $\\frac{1-p}{p}  1$，这使得 $u_-  1$。这是逾渗相具有物理意义的解。因此，对于 $p>1/2$，$u = \\left(\\frac{1-p}{p}\\right)^2$。\n\n最后，我们求出 $S$ 的闭式表达式：\n$$S = 1 - G_0(1-p+pu) = 1 - (1-p+pu)^3$$\n从自洽方程可知，$u = (1-p+pu)^2$，这意味着 $1-p+pu = \\sqrt{u}$（因为概率是非负的，所以必须取正根）。\n将此代入 $S$ 的表达式中：\n$$S = 1 - (\\sqrt{u})^3 = 1 - u^{3/2}$$\n现在，我们将 $p>1/2$ 时的 $u$ 的表达式代入：\n$$S(p) = 1 - \\left[\\left(\\frac{1-p}{p}\\right)^2\\right]^{3/2} = 1 - \\left(\\frac{1-p}{p}\\right)^3$$\n这就是当 $p > 1/2$ 时GCC大小的表达式。\n\n### 最终计算\n\n我们被要求计算 $p = \\frac{3}{4}$ 时的 $S$。由于 $\\frac{3}{4} > \\frac{1}{2}$，存在GCC。\n$$S\\left(\\frac{3}{4}\\right) = 1 - \\left(\\frac{1-\\frac{3}{4}}{\\frac{3}{4}}\\right)^3 = 1 - \\left(\\frac{\\frac{1}{4}}{\\frac{3}{4}}\\right)^3 = 1 - \\left(\\frac{1}{3}\\right)^3$$\n$$S = 1 - \\frac{1}{27} = \\frac{26}{27}$$",
            "answer": "$$\\boxed{\\frac{26}{27}}$$"
        },
        {
            "introduction": "逾渗理论不仅仅是一个抽象概念，它还是理解现实世界系统弹性的强大工具。本练习  将逾渗框架应用于评估无标度网络的鲁棒性——这是一种在技术和自然界中无处不在的结构。你将推导并比较在随机故障和蓄意、有针对性的攻击下，网络破碎的临界阈值，从而揭示这些网络的一个根本性弱点。",
            "id": "4310614",
            "problem": "考虑一个由组态模型生成的大型网络，该网络有 $N$ 个节点，其度分布 $P(k)$ 为无标度分布，定义在整数度 $k \\in [k_{\\min}, k_{\\max}]$ 上，其中 $k_{\\min} \\geq 1$ 且 $k_{\\max}  \\infty$。假设用积分对求和的连续近似有效，且度分布为 $P(k) = C k^{-\\gamma}$，其中指数 $\\gamma = 3$，归一化常数 $C > 0$。两种节点移除策略被应用于此网络：\n\n- 随机移除：每个节点以概率 $q$ 被独立移除，以概率 $p = 1 - q$ 被保留。\n- 度靶向移除：对于某个阈值 $K$，所有度 $k \\geq K$ 的节点被移除，而度 $k  K$ 的节点被保留。\n\n从第一性原理出发——具体来说，即组态模型中巨连通分量的分支过程表征，以及用依赖于度的节点保留概率表示的点渗流准则——推导在普遍的度依赖移除下的渗流阈值条件，然后将其具体应用到上述两种策略中。对于随机移除，确定恰好使网络破碎（消除巨连通分量）的临界移除比例 $q_{c}$。对于度靶向移除，确定恰好使网络破碎的临界阈值 $K_{c}$，并由此推导出临界移除比例 $f_{c}$。\n\n将您的最终答案表示为 $k_{\\min}$ 和 $k_{\\max}$ 的闭式函数，如果需要，可使用特殊函数，并采用连续近似。在单行中报告两个阈值比例，顺序为：度靶向移除的临界移除比例 $f_{c}$，然后是随机移除的临界移除比例 $q_{c}$。无需物理单位。无需四舍五入；请提供精确表达式。",
            "solution": "用户希望分析一个无标度网络在两种不同节点移除策略下的渗流阈值。\n\n### 步骤1：提取已知条件\n- 网络模型：具有 $N$ 个节点的组态模型。\n- 度分布：$P(k) = C k^{-\\gamma}$，对于整数 $k \\in [k_{\\min}, k_{\\max}]$，其中 $k_{\\min} \\geq 1$ 且 $k_{\\max}  \\infty$。\n- 度指数：$\\gamma = 3$。\n- 近似：用积分对求和的连续近似，$\\sum_k \\to \\int dk$，是有效的。\n- 移除策略1（随机）：每个节点以概率 $q$ 被移除，以概率 $p=1-q$ 被保留。\n- 移除策略2（度靶向）：所有度 $k \\geq K$ 的节点被移除；度 $k  K$ 的节点被保留。\n- 任务：推导普适的渗流条件，将其具体化以求出随机移除的临界移除比例 $q_c$，以及靶向移除的临界阈值 $K_c$ 和相应的临界移除比例 $f_c$。\n- 输出：将 $f_c$ 和 $q_c$ 表示为 $k_{\\min}$ 和 $k_{\\max}$ 的闭式函数。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学基础**：该问题在复杂网络的统计力学中有充分的依据。组态模型、无标度分布、渗流理论和分支过程形式体系都是该领域的标准和核心概念。\n- **适定性**：该问题是适定的，提供了推导所要求量所需的所有必要信息（$P(k)$ 的形式、$\\gamma$ 的值、度的范围）。目标（$q_c$ 和 $f_c$）定义清晰。\n- **客观性**：问题以精确、客观和形式化的科学语言陈述。\n- **完整性**：问题是自洽的。常数 $C$ 通过归一化定义，所有其他需要的量都可以从已知条件中推导出来。\n- **一致性与可行性**：该设置为一个标准的理论模型，没有内部矛盾或科学上不合理之处。\n- **结论**：问题有效，可以按所述方式解决。\n\n### 步骤3：推导与求解\n\n**普适渗流准则**\n\n组态模型中巨连通分量的存在性可以通过分析网络上的一个分支过程来确定。当且仅当沿着一条随机边到达一个节点后，从该节点出发的平均出边数大于1时，巨连通分量才存在。设 $\\phi(k)$ 是度为 $k$ 的节点在移除过程后被保留在网络中的概率。\n\n度分布为 $P(k)$。平均度为 $\\langle k \\rangle = \\int k P(k) dk$。\n随机选择一条边会通向一个度为 $k$ 的节点的概率由剩余度分布给出，该分布与 $k P(k)$ 成正比。归一化后的分布为 $\\frac{kP(k)}{\\langle k \\rangle}$。\n\n到达一个度为 $k$ 的节点后（该节点以概率 $\\phi(k)$ 被保留），还有 $k-1$ 条其他边可以分支出去。这类新分支的平均数量，我们记为 $B$，是：\n$$B = \\int_{k_{\\min}}^{k_{\\max}} (k-1) \\phi(k) \\frac{k P(k)}{\\langle k \\rangle} dk$$\n渗流阈值对应于巨连通分量恰好消失的临界点，此时 $B=1$。因此，渗流阈值的准则为：\n$$ \\int_{k_{\\min}}^{k_{\\max}} k(k-1) \\phi(k) P(k) dk = \\langle k \\rangle = \\int_{k_{\\min}}^{k_{\\max}} k P(k) dk $$\n这就是我们将要使用的普适条件。\n\n**$P(k) = Ck^{-3}$ 时的网络性质**\n\n首先，我们确定归一化常数 $C$。\n$$ \\int_{k_{\\min}}^{k_{\\max}} P(k) dk = 1 \\implies C \\int_{k_{\\min}}^{k_{\\max}} k^{-3} dk = C \\left[ -\\frac{1}{2}k^{-2} \\right]_{k_{\\min}}^{k_{\\max}} = 1 $$\n$$ C \\left( \\frac{1}{2k_{\\min}^2} - \\frac{1}{2k_{\\max}^2} \\right) = 1 \\implies C = \\frac{2}{\\frac{1}{k_{\\min}^2} - \\frac{1}{k_{\\max}^2}} = \\frac{2 k_{\\min}^2 k_{\\max}^2}{k_{\\max}^2 - k_{\\min}^2} $$\n接着，我们计算一阶矩（平均度）$\\langle k \\rangle$。\n$$ \\langle k \\rangle = \\int_{k_{\\min}}^{k_{\\max}} k P(k) dk = C \\int_{k_{\\min}}^{k_{\\max}} k^{-2} dk = C \\left[ -k^{-1} \\right]_{k_{\\min}}^{k_{\\max}} = C \\left( \\frac{1}{k_{\\min}} - \\frac{1}{k_{\\max}} \\right) $$\n代入 $C$：\n$$ \\langle k \\rangle = \\frac{2 k_{\\min}^2 k_{\\max}^2}{k_{\\max}^2 - k_{\\min}^2} \\frac{k_{\\max} - k_{\\min}}{k_{\\min} k_{\\max}} = \\frac{2 k_{\\min} k_{\\max} (k_{\\max}-k_{\\min})}{(k_{\\max}-k_{\\min})(k_{\\max}+k_{\\min})} = \\frac{2 k_{\\min} k_{\\max}}{k_{\\max} + k_{\\min}} $$\n\n**策略1：随机移除**\n\n对于随机移除，节点以概率 $p = 1-q$ 被保留，这与它的度无关。因此，$\\phi(k) = p$。设 $p_c$ 为临界保留概率。渗流准则变为：\n$$ \\int_{k_{\\min}}^{k_{\\max}} k(k-1) p_c P(k) dk = \\langle k \\rangle $$\n$$ p_c \\left( \\int_{k_{\\min}}^{k_{\\max}} k^2 P(k) dk - \\int_{k_{\\min}}^{k_{\\max}} k P(k) dk \\right) = \\langle k \\rangle $$\n$$ p_c (\\langle k^2 \\rangle - \\langle k \\rangle) = \\langle k \\rangle \\implies p_c = \\frac{\\langle k \\rangle}{\\langle k^2 \\rangle - \\langle k \\rangle} $$\n我们需要计算二阶矩 $\\langle k^2 \\rangle$：\n$$ \\langle k^2 \\rangle = \\int_{k_{\\min}}^{k_{\\max}} k^2 P(k) dk = C \\int_{k_{\\min}}^{k_{\\max}} k^{-1} dk = C \\left[ \\ln(k) \\right]_{k_{\\min}}^{k_{\\max}} = C \\ln\\left(\\frac{k_{\\max}}{k_{\\min}}\\right) $$\n临界移除比例为 $q_c = 1 - p_c = 1 - \\frac{1}{\\frac{\\langle k^2 \\rangle}{\\langle k \\rangle} - 1} = \\frac{\\frac{\\langle k^2 \\rangle}{\\langle k \\rangle} - 2}{\\frac{\\langle k^2 \\rangle}{\\langle k \\rangle} - 1}$。\n我们来计算比值 $\\frac{\\langle k^2 \\rangle}{\\langle k \\rangle}$：\n$$ \\frac{\\langle k^2 \\rangle}{\\langle k \\rangle} = \\frac{C \\ln\\left(\\frac{k_{\\max}}{k_{\\min}}\\right)}{C \\left(\\frac{1}{k_{\\min}} - \\frac{1}{k_{\\max}}\\right)} = \\frac{\\ln\\left(\\frac{k_{\\max}}{k_{\\min}}\\right)}{\\frac{k_{\\max} - k_{\\min}}{k_{\\min}k_{\\max}}} = \\frac{k_{\\min}k_{\\max}}{k_{\\max}-k_{\\min}} \\ln\\left(\\frac{k_{\\max}}{k_{\\min}}\\right) $$\n将此代入 $q_c$ 的表达式中：\n$$ q_c = \\frac{\\frac{k_{\\min}k_{\\max}}{k_{\\max}-k_{\\min}} \\ln\\left(\\frac{k_{\\max}}{k_{\\min}}\\right) - 2}{\\frac{k_{\\min}k_{\\max}}{k_{\\max}-k_{\\min}} \\ln\\left(\\frac{k_{\\max}}{k_{\\min}}\\right) - 1} $$\n\n**策略2：度靶向移除**\n\n对于度靶向移除，度 $k \\geq K$ 的节点被移除。保留概率为 $\\phi(k) = 1$（对于 $k  K$）和 $\\phi(k) = 0$（对于 $k \\geq K$）。临界阈值 $K_c$ 可通过在普适准则的左侧将积分上限设为 $K_c$ 来求得：\n$$ \\int_{k_{\\min}}^{K_c} k(k-1) P(k) dk = \\langle k \\rangle $$\n$$ C \\int_{k_{\\min}}^{K_c} (k^2-k) k^{-3} dk = C \\int_{k_{\\min}}^{K_c} (k^{-1} - k^{-2}) dk = C\\left(\\frac{1}{k_{\\min}} - \\frac{1}{k_{\\max}}\\right) $$\n常数 $C$ 消掉了。\n$$ \\left[ \\ln(k) + \\frac{1}{k} \\right]_{k_{\\min}}^{K_c} = \\frac{1}{k_{\\min}} - \\frac{1}{k_{\\max}} $$\n$$ \\left( \\ln(K_c) + \\frac{1}{K_c} \\right) - \\left( \\ln(k_{\\min}) + \\frac{1}{k_{\\min}} \\right) = \\frac{1}{k_{\\min}} - \\frac{1}{k_{\\max}} $$\n$$ \\ln(K_c) + \\frac{1}{K_c} = \\ln(k_{\\min}) + \\frac{2}{k_{\\min}} - \\frac{1}{k_{\\max}} $$\n这是一个关于 $K_c$ 的超越方程。令 $A = \\ln(k_{\\min}) + \\frac{2}{k_{\\min}} - \\frac{1}{k_{\\max}}$ 且 $x=K_c$。方程 $x e^{1/x} = e^A$ 可以使用朗伯W函数 $W(z)$ 求解，该函数定义为 $W(z)e^{W(z)}=z$。大于1的 $K_c$ 解由主分支 $W_0$ 给出：\n$$ K_c = -\\frac{1}{W_0\\left(-e^{-A}\\right)} = -\\frac{1}{W_0\\left(-\\exp\\left(-\\left(\\ln(k_{\\min}) + \\frac{2}{k_{\\min}} - \\frac{1}{k_{\\max}}\\right)\\right)\\right)} $$\n这可以写成：\n$$ K_c = -\\left(W_0\\left(-\\frac{1}{k_{\\min}}\\exp\\left(\\frac{1}{k_{\\max}}-\\frac{2}{k_{\\min}}\\right)\\right)\\right)^{-1} $$\n被移除节点的临界比例 $f_c$ 是 $P(k)$ 在被移除的度区间上的积分，即从 $K_c$到 $k_{\\max}$。\n$$ f_c = \\int_{K_c}^{k_{\\max}} P(k) dk = C \\int_{K_c}^{k_{\\max}} k^{-3} dk = C \\left[-\\frac{1}{2}k^{-2}\\right]_{K_c}^{k_{\\max}} = \\frac{C}{2}\\left(\\frac{1}{K_c^2} - \\frac{1}{k_{\\max}^2}\\right) $$\n回顾 $1 = \\int_{k_{\\min}}^{k_{\\max}} P(k) dk = \\frac{C}{2}\\left(\\frac{1}{k_{\\min}^2} - \\frac{1}{k_{\\max}^2}\\right)$，我们可以将 $f_c$ 写为：\n$$ f_c = \\frac{\\frac{1}{K_c^2} - \\frac{1}{k_{\\max}^2}}{\\frac{1}{k_{\\min}^2} - \\frac{1}{k_{\\max}^2}} = \\frac{K_c^{-2} - k_{\\max}^{-2}}{k_{\\min}^{-2} - k_{\\max}^{-2}} $$\n代入 $K_c^{-1}$ 的表达式：\n$$ K_c^{-1} = -W_0\\left(-\\frac{1}{k_{\\min}}\\exp\\left(\\frac{1}{k_{\\max}}-\\frac{2}{k_{\\min}}\\right)\\right) $$\n所以，$K_c^{-2} = \\left[W_0\\left(-\\frac{1}{k_{\\min}}\\exp\\left(\\frac{1}{k_{\\max}}-\\frac{2}{k_{\\min}}\\right)\\right)\\right]^2$。\n$f_c$ 的最终表达式是：\n$$ f_c = \\frac{\\left[W_0\\left(-\\frac{1}{k_{\\min}}\\exp\\left(\\frac{1}{k_{\\max}}-\\frac{2}{k_{\\min}}\\right)\\right)\\right]^2 - k_{\\max}^{-2}}{k_{\\min}^{-2} - k_{\\max}^{-2}} $$\n\n最终答案需要两个比例，$f_c$ 和 $q_c$。",
            "answer": "$$ \\boxed{ \\frac{\\left[W_0\\left(-\\frac{1}{k_{\\min}}\\exp\\left(\\frac{1}{k_{\\max}}-\\frac{2}{k_{\\min}}\\right)\\right)\\right]^2 - k_{\\max}^{-2}}{k_{\\min}^{-2} - k_{\\max}^{-2}}, \\quad \\frac{\\frac{k_{\\min}k_{\\max}}{k_{\\max}-k_{\\min}} \\ln\\left(\\frac{k_{\\max}}{k_{\\min}}\\right) - 2}{\\frac{k_{\\min}k_{\\max}}{k_{\\max}-k_{\\min}} \\ln\\left(\\frac{k_{\\max}}{k_{\\min}}\\right) - 1} } $$"
        },
        {
            "introduction": "虽然解析模型能提供深刻的见解，但许多复杂系统最好通过计算来探索。最后一个实践  从纸笔推演转向编程，指导你实现高效的“并查集”算法来模拟键逾渗。通过构建此模拟，你将学习到测量巨组分大小和磁化率等宏观可观测量值的标准计算技术，从而架起理论预测与数值实验之间的桥梁。",
            "id": "4310671",
            "problem": "设计并实现一个完整的程序，使用并查集（Disjoint Set Union, DSU）数据结构来识别方格晶格上键逾渗中的连通分量，并计算两个可观测量——最大连通分量中的分数 $P_\\infty$ 和易感性 $\\chi$，将其作为键占据概率 $p$ 的函数。您的程序必须是自包含的，不得读取外部输入，并且必须按照下面指定的格式生成单行输出。\n\n背景与基本原理：\n- 考虑一个无向图 $G = (V, E)$，其中 $V$ 是一个包含 $|V| = N$ 个节点的集合，$E$ 是一个包含 $|E| = M$ 个键（边）的集合。在键逾渗中，$E$ 中的每个键都以概率 $p \\in [0,1]$ 独立地处于激活（存在）状态，并以概率 $1 - p$ 处于非激活（不存在）状态。\n- 连通分量是 $V$ 的一个最大子集，使得该子集中的每对节点都通过一条由激活的键组成的路径相连。并查集（DSU）数据结构（也称为 union–find 数据结构）维护了 $V$ 的一个划分为不相交的集合，这些集合代表了连通分量，并支持两种操作：find（检索集合的代表元）和 union（合并两个集合）。\n- 程序必须在指定的 $p$ 值下测量两个标准的逾渗可观测量：\n  1. 最大连通分量中的分数 $P_\\infty = s_{\\max} / N$，其中 $s_{\\max}$ 是最大连通分量的大小。\n  2. 易感性 $\\chi$，在有限图上通过排除最大连通分量来定义。设 $s_i$ 是所有连通分量的大小，并设 $s_{\\max}$ 表示最大的那个。那么\n  $$\\chi = \\frac{\\sum_{i: s_i \\neq s_{\\max}} s_i^2}{\\sum_{i: s_i \\neq s_{\\max}} s_i}。$$\n  如果不存在有限分量（即，如果 $s_{\\max} = N$），按惯例定义 $\\chi = 0$。\n- 您必须对跨越不同 $p$ 值的逾渗构型使用单调耦合来计算这些可观测量：生成一个单一的键的随机排序，并按该顺序激活它们。对于给定的 $p$，令 $k = \\lfloor p \\, M \\rfloor$ 为激活键的数量；然后考虑由该顺序中前 $k$ 个键形成的子图。这种耦合确保了随着 $p$ 的增加，构型是嵌套的。\n\n要使用的图模型：\n- 在线性尺寸为 $L$ 的方格晶格上使用键逾渗模型。节点集 $V$ 是一个 $L \\times L$ 网格上的格点集合，采用开放边界条件。键集 $E$ 包含最近邻的水平和垂直键（无对角线），因此 $M = 2 L (L - 1)$ 且 $N = L^2$。\n\n算法要求：\n- 实现带有路径压缩和按大小合并（或按秩合并）的 DSU。维护每个分量的大小，以便在每次 union 操作时能以 $\\mathcal{O}(1)$ 的时间复杂度更新 $s_{\\max}$。同时维护分量大小的平方和，\n  $$S_2 = \\sum_i s_i^2，$$\n  并在合并两个大小为 $a$ 和 $b$ 的分量时，使用恒等式\n  $$(a + b)^2 - a^2 - b^2 = 2ab$$\n  以 $\\mathcal{O}(1)$ 的时间复杂度更新 $S_2$。然后计算\n  $$P_\\infty = \\frac{s_{\\max}}{N}, \\quad \\chi = \\begin{cases}\n  \\dfrac{S_2 - s_{\\max}^2}{N - s_{\\max}},  \\text{如果 } s_{\\max} \\neq N,\\\\\n  0,  \\text{如果 } s_{\\max} = N.\n  \\end{cases}$$\n- 对于每个测试用例，使用以指定种子初始化的伪随机数生成器生成所有 $M$ 个键的单一随机排列，并根据该排列增量激活键，直到每个检查点 $p$。\n\n测试套件：\n您的程序必须为以下测试用例计算可观测量。对于每个用例， $p$ 值的列表是按非递减顺序排列的。\n- 测试用例 1：$L = 16$，种子 $= 12345$，检查点 $p \\in [0.0, 0.2, 0.4, 0.5, 0.6, 0.8, 1.0]$。\n- 测试用例 2：$L = 32$，种子 $= 2024$，检查点 $p \\in [0.0, 0.48, 0.5, 0.52, 1.0]$。\n- 测试用例 3：$L = 8$，种子 $= 7$，检查点 $p \\in [0.0, 1.0]$。\n- 测试用例 4：$L = 24$，种子 $= 99$，检查点 $p \\in [0.3, 0.7]$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个列表，每个元素对应一个测试用例，顺序与上面列出的一致。\n- 对于每个测试用例，输出一个包含两个元素的列表：第一个元素是在指定检查点处的 $P_\\infty$ 值列表（顺序与检查点列表相同），第二个元素是在这些检查点处的 $\\chi$ 值列表。\n- 因此，总输出必须是一个浮点数列表的列表的列表，其确切形状为\n  $$\\big[ [ [P_{\\infty,1}(p_1), \\dots], [\\chi_1(p_1), \\dots] ],\\ \\dots\\ \\big]。$$\n- 输出必须打印为单行，形式为用方括号括起来的逗号分隔列表，不含任何额外文本。不涉及角度和物理单位；所有数值输出都是无单位的实数（浮点数）。",
            "solution": "用户需要一个程序来模拟二维方格晶格上的键逾渗，并计算关键的可观测量。\n\n### 问题验证\n我对问题陈述进行了彻底的验证。\n- **提取的已知条件**：\n    - 模型：在具有开放边界的 $L \\times L$ 方格晶格上的键逾渗。\n    - 节点：$N = L^2$。\n    - 键：$M = 2L(L-1)$ 个最近邻键。\n    - 过程：单调耦合，其中键从单个随机排列中增量添加。激活键的数量为 $k = \\lfloor pM \\rfloor$。\n    - 可观测量：\n        1. 最大连通分量中的分数，$P_\\infty = s_{\\max} / N$。\n        2. 易感性，$\\chi = \\frac{\\sum_{i: s_i \\neq s_{\\max}} s_i^2}{\\sum_{i: s_i \\neq s_{\\max}} s_i}$，并提供了计算公式 $\\chi = \\frac{S_2 - s_{\\max}^2}{N - s_{\\max}}$（当 $s_{\\max}  N$ 时）和 $\\chi=0$（当 $s_{\\max} = N$ 时）。\n    - 算法：带有路径压缩和按大小合并的并查集（DSU）。$s_{\\max}$ 和 $S_2 = \\sum_i s_i^2$ 的更新时间复杂度为 O(1)。\n    - 测试用例：给出了四个具体用例，包含参数 $L$、`seed` 和检查点概率 $p$。\n    - 输出：一个单行字符串，表示一个包含每个测试用例结果的列表。\n- **验证结论**：该问题是 **有效的**。它在科学上是合理的、适定的、客观的、完整的，并且在计算上是可行的。模型和可观测量是统计物理中的标准内容，而指定的算法是此类模拟的经典方法。测试用例定义明确。\n\n### 解决方案设计\n\n解决方案将是一个 Python 程序，用于实现指定的模拟。程序的核心将是一个执行单个测试用例的函数，并辅以辅助结构来管理逾渗过程。\n\n**1. 晶格与键**\n对于给定的线性尺寸 $L$，晶格包含 $N=L^2$ 个格点，我们可以从 $0$ 到 $N-1$ 对其进行索引。位于坐标 $(r, c)$（其中 $0 \\le r, c  L$）的格点映射到索引 $i = r \\cdot L + c$。$M=2L(L-1)$ 个可能的最近邻键（水平和垂直）将被生成并存储在一个列表中。一个使用种子进行初始化的伪随机数生成器，用于创建这些键的单一随机排列。此排列决定了键被激活的顺序。\n\n**2. 并查集 (DSU) 数据结构**\n为了在添加键时高效地跟踪图的连通分量，我们将实现一个 DSU 数据结构。该结构将维护 $N$ 个格点的一个不相交集合划分。我们的实现将：\n- 使用一个 `parent` 数组，其中 `parent[i]` 存储格点 $i$ 的父节点。一个分量由其根来标识，即满足 `parent[i] == i` 的格点 $i$。\n- 实现带有 **路径压缩** 的 **find** 操作。此操作找到包含给定格点的分量的根，并在此过程中“压平”树结构，从而显著提高长期运行速度。\n- 使用一个 `comp_size` 数组，其中如果 $i$ 是一个根，`comp_size[i]` 存储该分量中的格点数。\n- **union** 操作将使用 **按大小合并** 的启发式方法执行：当合并两个分量时，较小分量的根总是连接到较大分量的根上。这能使树保持较浅。\n\n**3. 通过单调耦合进行模拟**\n模拟是增量进行的。我们遍历已排序的检查点概率 $p$ 列表。对于每个 $p$，我们确定要激活的键的总数，$k = \\lfloor pM \\rfloor$。然后，我们从上一步停止的地方开始，从排列好的列表中添加键，直到有 $k$ 个键被激活。\n\n对于每个添加的键 $(u, v)$：\n- 我们找到包含格点 $u$ 和 $v$ 的分量的根。\n- 如果根不同，则这两个格点在不同的分量中，需要进行合并。我们执行一次 union 操作。\n- 设被合并的两个分量的大小为 $s_a$ 和 $s_b$。新分量的大小将是 $s_a+s_b$。此事件会触发我们对全局可观测量的更新。\n\n**4. 可观测量计算**\n为了高效地计算 $P_\\infty$ 和 $\\chi$，我们在整个模拟过程中维护三个全局量：\n- $N$：格点总数，是一个常数 ($L^2$)。\n- $s_{\\max}$：最大连通分量的大小。最初，所有格点都位于大小为 1 的分量中，因此 $s_{\\max}^{(0)} = 1$。\n- $S_2$：所有分量大小的平方和，$S_2 = \\sum_i s_i^2$。最初，$S_2^{(0)} = \\sum_{i=1}^{N} 1^2 = N$。\n\n当两个大小为 $s_a$ 和 $s_b$ 的分量合并时，这些量在 $\\mathcal{O}(1)$ 时间内更新：\n- 新的大小是 $s_{new} = s_a+s_b$。\n- 新的最大分量大小是 $s'_{\\max} = \\max(s_{\\max}, s_{new})$。\n- 平方和使用恒等式 $(s_a+s_b)^2 - s_a^2 - s_b^2 = 2s_as_b$ 进行更新。新的和是 $S'_2 = S_2 - s_a^2 - s_b^2 + (s_a+s_b)^2 = S_2 + 2s_as_b$。\n\n为给定的检查点 $p$ 添加了所需数量的键后，可观测量计算如下：\n- $P_\\infty(p) = \\frac{s_{\\max}}{N}$\n- $\\chi(p) = \\begin{cases} \\frac{S_2 - s_{\\max}^2}{N - s_{\\max}}  \\text{若 } s_{\\max}  N \\\\ 0  \\text{若 } s_{\\max} = N \\end{cases}$\n\n这种增量方法非常高效，因为我们只需遍历一次键，就可以处理给定晶格的所有检查点。单个测试用例（有 $C$ 个检查点）的总体复杂度主要由键处理循环决定，大约为 $\\mathcal{O}(M \\alpha(N) + C)$，其中 $\\alpha(N)$ 是由 DSU 操作产生的增长极其缓慢的反阿克曼函数。",
            "answer": "```python\nimport numpy as np\n\nclass DSU:\n    \"\"\"一个带有路径压缩和按大小合并的并查集数据结构。\"\"\"\n    def __init__(self, n):\n        # parent[i] 是站点 i 的父节点\n        self.parent = np.arange(n)\n        # comp_size[i] 是分量的大小，如果 i 是一个根节点\n        self.comp_size = np.ones(n, dtype=np.int64)\n\n    def find(self, i):\n        \"\"\"查找包含站点 i 的分量的根，并进行路径压缩。\"\"\"\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\ndef run_percolation_simulation(L, seed, p_checkpoints):\n    \"\"\"\n    在 L x L 网格上运行键逾渗模拟。\n\n    Args:\n        L (int): 方格晶格的线性尺寸。\n        seed (int): 伪随机数生成器的种子。\n        p_checkpoints (list of float): 一个非递减的键占据概率列表，\n                                       用于在这些概率点上测量可观测量。\n\n    Returns:\n        list: 一个包含两个列表的列表：\n              1. 每个检查点对应的 P_infinity 值列表。\n              2. 每个检查点对应的 chi 值列表。\n    \"\"\"\n    N = L * L\n    if L == 1:\n        M = 0\n    else:\n        M = 2 * L * (L - 1)\n\n    # 1. 在 L x L 网格上生成所有可能的键\n    bonds = []\n    # 水平键\n    for r in range(L):\n        for c in range(L - 1):\n            u = r * L + c\n            v = r * L + (c + 1)\n            bonds.append((u, v))\n    # 垂直键\n    for r in range(L - 1):\n        for c in range(L):\n            u = r * L + c\n            v = (r + 1) * L + c\n            bonds.append((u, v))\n\n    # 2. 为单调耦合创建键的单一随机排列\n    rng = np.random.default_rng(seed)\n    permuted_bonds = rng.permutation(bonds, axis=0)\n\n    # 3. 初始化 DSU 和可观测量跟踪器\n    dsu = DSU(N)\n    \n    # 跟踪分量大小的平方和 (S2) 和最大分量大小 (s_max)\n    # 最初有 N 个大小为 1 的分量。\n    S2 = float(N) if N > 0 else 0.0\n    s_max = 1 if N > 0 else 0\n\n    results_P_inf = []\n    results_chi = []\n    \n    current_bond_idx = 0\n\n    # 4. 单调添加键并在检查点计算可观测量\n    for p in p_checkpoints:\n        target_num_bonds = int(p * M)\n        \n        while current_bond_idx  target_num_bonds:\n            u, v = permuted_bonds[current_bond_idx]\n            \n            root_u = dsu.find(u)\n            root_v = dsu.find(v)\n            \n            if root_u != root_v:\n                size_u = dsu.comp_size[root_u]\n                size_v = dsu.comp_size[root_v]\n                \n                # 按大小合并：将较小的树附加到较大树的根上\n                if size_u  size_v:\n                    root_u, root_v = root_v, root_u\n                    size_u, size_v = size_v, size_u\n                \n                dsu.parent[root_v] = root_u\n                new_size = size_u + size_v\n                dsu.comp_size[root_u] = new_size\n                \n                # 以 O(1) 复杂度更新可观测量\n                S2 += 2 * size_u * size_v\n                s_max = max(s_max, new_size)\n            \n            current_bond_idx += 1\n            \n        # 5. 为当前检查点计算并存储可观测量\n        if N == 0:\n            P_inf = 0.0\n            chi = 0.0\n        else:\n            P_inf = s_max / N\n            if s_max == N:\n                chi = 0.0\n            else:\n                chi = (S2 - s_max**2) / (N - s_max)\n                \n        results_P_inf.append(P_inf)\n        results_chi.append(chi)\n        \n    return [results_P_inf, results_chi]\n\ndef solve():\n    \"\"\"\n    定义并运行逾渗模拟的测试套件，\n    然后按要求格式打印结果。\n    \"\"\"\n    test_cases = [\n        {'L': 16, 'seed': 12345, 'p_checkpoints': [0.0, 0.2, 0.4, 0.5, 0.6, 0.8, 1.0]},\n        {'L': 32, 'seed': 2024, 'p_checkpoints': [0.0, 0.48, 0.5, 0.52, 1.0]},\n        {'L': 8, 'seed': 7, 'p_checkpoints': [0.0, 1.0]},\n        {'L': 24, 'seed': 99, 'p_checkpoints': [0.3, 0.7]},\n    ]\n\n    results = []\n    for case in test_cases:\n        result_for_case = run_percolation_simulation(\n            case['L'], case['seed'], case['p_checkpoints']\n        )\n        results.append(result_for_case)\n\n    # 严格按照要求格式化最终输出字符串\n    # 使用repr()来获得Python对象的字符串表示，然后去除外层引号\n    # 这比手动拼接字符串更可靠\n    output_str = repr(results)\n    # 移除Python repr()可能添加的空格以获得更紧凑的输出\n    output_str = output_str.replace(\" \", \"\")\n    print(output_str)\n\n# 由于环境限制，我们不能直接运行solve()。但是，上述代码是为执行该任务而设计的。\n# 因此，我们将打印最终格式化的代码。\n# solve()\n# The calling logic is moved inside the triple backticks so it's part of the answer code block.\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}