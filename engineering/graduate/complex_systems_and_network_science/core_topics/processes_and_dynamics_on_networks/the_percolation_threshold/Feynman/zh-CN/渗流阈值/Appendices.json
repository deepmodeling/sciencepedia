{
    "hands_on_practices": [
        {
            "introduction": "理论学习之后，我们通过一系列动手实践来巩固和深化理解。第一个实践将带你从第一性原理出发，掌握使用生成函数分析渗流问题的核心技术。通过为特定的随机网络（正则图的构型模型）推导巨连通分支的大小，你将学会如何将微观的节点度分布与宏观的网络结构联系起来。",
            "id": "4310629",
            "problem": "考虑一个度分布为 $P(k)$ 的配相模型（Configuration Model, CM）网络，其中 $k \\in \\{0,1,2,\\ldots\\}$。设 $G_0(x)$ 表示度分布的生成函数（generating function, GF），$G_1(x)$ 表示超度分布（excess-degree distribution）的生成函数。假设在该网络上进行键渗流（每条边以概率 $p \\in [0,1]$ 独立地保留），并且该配相模型在热力学极限下是局部树状的。仅使用度分布和超度分布的生成函数的基本定义以及树状图中分支的独立性，完成以下任务：\n\n1. 从 $P(k)$ 和超度分布 $q_k$ 的定义出发，构建 $G_0(x)$ 和 $G_1(x)$。其中 $q_k$ 的定义为：沿着一条均匀随机选择的半边到达一个节点，该节点所连接的其他边的数量等于 $k$ 的概率。\n\n2. 推导概率 $u$ 的自洽关系式，$u$ 指的是沿着一条均匀随机选择的已占据边最终进入一个有限连通片（即，最终不会到达巨大连通片（giant connected component, GCC））的概率。然后，用 $G_0$ 和 $u$ 推导出 GCC 大小 $S$ 的表达式。\n\n3. 将问题具体化到 3-正则配相模型网络的情况，即 $P(k)=\\delta_{k,3}$，其中 $\\delta_{i,j}$ 是克罗内克（Kronecker）$\\delta$ 函数。对于这种情况，明确计算 $G_0(x)$ 和 $G_1(x)$，对普适的 $p$ 求解关于 $u$ 的自洽方程，然后得到 $S$ 作为 $p$ 的函数的闭式表达式。\n\n最后，计算当键占据概率为 $p=\\tfrac{3}{4}$ 时的 GCC 大小 $S$。以单个数字形式给出最终答案。无需单位。除非您选择近似值而非精确值，否则无需四舍五入；如果进行近似，请将答案四舍五入到四位有效数字。",
            "solution": "用户提出的问题是网络科学和统计物理领域中一个有效且适定的问题。它要求推导在键渗流的配相模型（CM）网络中巨大连通片（GCC）的大小，并具体化到 3-正则图的情况。推导过程将遵循生成函数方法。\n\n### 第 1 部分：生成函数的构建\n\n设 $P(k)$ 是网络的度分布。根据定义，度分布的生成函数（GF）为：\n$$G_0(x) = \\sum_{k=0}^{\\infty} P(k) x^k$$\n\n超度分布 $q_k$ 是指沿着一条均匀随机选择的边到达的节点有 $k$ 条其他边的概率。为了求 $q_k$，我们首先求出一条随机边连接到度为 $j$ 的节点的概率。连接到度为 $j$ 的节点的边数与 $j N P(j)$ 成正比，其中 $N$ 是节点总数。边的端点（或半边）的总数为 $\\sum_j j N P(j) = N \\langle k \\rangle$，其中 $\\langle k \\rangle$ 是平均度。因此，一条随机边导向度为 $j$ 的节点的概率是 $\\frac{j P(j)}{\\langle k \\rangle}$。\n\n如果该节点度为 $j$，它就有 $j-1$ 条其他边。所以，超度为 $k=j-1$。因此，概率 $q_k$ 等于到达一个原始度为 $k+1$ 的节点的概率：\n$$q_k = \\frac{(k+1) P(k+1)}{\\langle k \\rangle}$$\n超度分布的生成函数 $G_1(x)$ 为：\n$$G_1(x) = \\sum_{k=0}^{\\infty} q_k x^k = \\sum_{k=0}^{\\infty} \\frac{(k+1) P(k+1)}{\\langle k \\rangle} x^k$$\n我们可以将其与 $G_0(x)$ 的导数联系起来。我们有 $G_0'(x) = \\sum_{k=1}^{\\infty} k P(k) x^{k-1}$。让我们通过设 $j=k+1$ 来改变 $G_1(x)$ 求和式中的索引：\n$$G_1(x) = \\frac{1}{\\langle k \\rangle} \\sum_{j=1}^{\\infty} j P(j) x^{j-1} = \\frac{G_0'(x)}{\\langle k \\rangle}$$\n平均度可以计算为 $\\langle k \\rangle = \\sum_k k P(k) = G_0'(1)$。因此：\n$$G_1(x) = \\frac{G_0'(x)}{G_0'(1)}$$\n\n### 第 2 部分：自洽关系式与 GCC 大小\n\n在键渗流中，每条边以概率 $p$ 被保留。对于一个局部树状网络，我们可以通过追踪沿边的路径来分析连通片的大小。\n\n设 $u$ 为沿着一条随机选择的已占据边导向一个有限连通片的概率。我们希望找到 $u$ 的一个自洽方程。考虑沿着一条已占据的边从节点 A 到达节点 B。要使这条路径导向一个有限连通片，连接到 B 的连通片（不包括从 A 来的路径）必须是有限的。节点 B 在原始网络中有一个超度，由生成函数 $G_1(x)$ 描述。渗流之后，它的每条潜在边都以概率 $p$ 被保留。从 B 发出的*已占据*边数的生成函数（即它在渗流图中的超度）是 $G_1(1-p+px)$。设这个数为 $k'$。为使包含 B 的连通片是有限的，所有这 $k'$ 个出射分支本身都必须导向有限连通片。根据定义，每个这样的分支是有限的概率为 $u$。由于在树状结构中各分支是独立的，所有 $k'$ 个分支都是有限的概率为 $u^{k'}$。\n\n对 $k'$ 的所有可能值求和，并按其概率（即生成函数 $G_1(1-p+px)$ 的系数）加权，我们得到自洽方程：\n$$u = \\sum_{k'=0}^{\\infty} \\text{超度为 } k' \\text{ 的概率} u^{k'} = G_1(1-p+pu)$$\n这就是所求的自洽关系式。一个非平凡解 $u  1$ 存在的充要条件是网络处于渗流阈值之上，这表明存在一个 GCC。平凡解 $u=1$ 总是存在的，它对应于所有连通片都是有限的情况。\n\n现在，设 $S$ 为 GCC 的相对大小。$S$ 等于 $1$ 减去一个随机选择的节点属于一个有限连通片的概率。一个随机选择的节点，其度分布由 $G_0(x)$ 生成。渗流之后，其度的生成函数为 $G_0(1-p+px)$。对于一个有 $k'$ 条已占据边的节点，要使其处于一个有限连通片中，所有 $k'$ 个分支都必须导向有限连通片。这个事件的概率是 $u^{k'}$。一个随机节点属于有限连通片的概率，可以通过对 $u^{k'}$ 在渗流后的度分布上取平均得到：\n$$\\text{节点处于有限连通片中的概率} = \\sum_{k'=0}^{\\infty} \\text{度为 } k' \\text{ 的概率} u^{k'} = G_0(1-p+pu)$$\n因此，GCC 的大小为：\n$$S = 1 - G_0(1-p+pu)$$\n\n### 第 3 部分：具体化到 3-正则网络\n\n对于一个 3-正则网络，每个节点的度都是 $k=3$。度分布为 $P(k) = \\delta_{k,3}$，其中 $\\delta_{i,j}$ 是克罗内克 $\\delta$ 函数。\n\n首先，我们计算 $G_0(x)$ 和 $G_1(x)$：\n$$G_0(x) = \\sum_{k=0}^{\\infty} \\delta_{k,3} x^k = x^3$$\n平均度为 $\\langle k \\rangle = G_0'(1)$。由于 $G_0'(x) = 3x^2$，我们有 $\\langle k \\rangle = 3(1)^2=3$。\n超度生成函数是：\n$$G_1(x) = \\frac{G_0'(x)}{G_0'(1)} = \\frac{3x^2}{3} = x^2$$\n\n现在，我们求解关于 $u$ 的自洽方程：\n$$u = G_1(1-p+pu) = (1-p+pu)^2$$\n这是一个关于 $u$ 的二次方程：\n$$u = (1-p)^2 + 2p(1-p)u + p^2u^2$$\n$$p^2u^2 + (2p-2p^2-1)u + (1-p)^2 = 0$$\n使用二次公式 $u = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$，其中 $a=p^2$, $b=2p-2p^2-1$ 且 $c=(1-p)^2$：\n判别式为 $\\Delta = (2p-2p^2-1)^2 - 4p^2(1-p)^2 = (-(1-2p+2p^2))^2 - (2p(1-p))^2$。\n这是一个平方差：$\\Delta = (1-2p+2p^2 - (2p-2p^2))(1-2p+2p^2 + (2p-2p^2)) = (1-4p+4p^2)(1) = (1-2p)^2$。\n所以，$\\sqrt{\\Delta} = |1-2p|$。\n$u$ 的解为：\n$$u = \\frac{-(2p-2p^2-1) \\pm |1-2p|}{2p^2} = \\frac{1-2p+2p^2 \\pm |1-2p|}{2p^2}$$\n渗流阈值为 $p_c = 1/\\langle k-1 \\rangle = 1/G_1'(1) = 1/2$。对于 $p > p_c = 1/2$，我们有 $|1-2p| = 2p-1$。我们寻找 $u  1$ 的解。两个解是：\n$$u_+ = \\frac{1-2p+2p^2 + (2p-1)}{2p^2} = \\frac{2p^2}{2p^2} = 1$$\n$$u_- = \\frac{1-2p+2p^2 - (2p-1)}{2p^2} = \\frac{2-4p+2p^2}{2p^2} = \\frac{p^2-2p+1}{p^2} = \\left(\\frac{p-1}{p}\\right)^2 = \\left(\\frac{1-p}{p}\\right)^2$$\n对于 $p > 1/2$，我们有 $p > 1-p$，所以 $\\frac{1-p}{p}  1$，这使得 $u_-  1$。这是渗流相具有物理意义的解。因此，对于 $p>1/2$，$u = \\left(\\frac{1-p}{p}\\right)^2$。\n\n最后，我们求出 $S$ 的闭式表达式：\n$$S = 1 - G_0(1-p+pu) = 1 - (1-p+pu)^3$$\n从自洽方程，我们有 $u = (1-p+pu)^2$，这意味着 $1-p+pu = \\sqrt{u}$（必须取正根，因为概率是非负的）。\n将此代入 $S$ 的表达式中：\n$$S = 1 - (\\sqrt{u})^3 = 1 - u^{3/2}$$\n现在，我们将 $p>1/2$ 时 $u$ 的表达式代入：\n$$S(p) = 1 - \\left[\\left(\\frac{1-p}{p}\\right)^2\\right]^{3/2} = 1 - \\left(\\frac{1-p}{p}\\right)^3$$\n这就是当 $p > 1/2$ 时 GCC 大小的表达式。\n\n### 最终求值\n\n题目要求我们计算 $p = \\frac{3}{4}$ 时的 $S$。由于 $\\frac{3}{4} > \\frac{1}{2}$，存在一个 GCC。\n$$S\\left(\\frac{3}{4}\\right) = 1 - \\left(\\frac{1-\\frac{3}{4}}{\\frac{3}{4}}\\right)^3 = 1 - \\left(\\frac{\\frac{1}{4}}{\\frac{3}{4}}\\right)^3 = 1 - \\left(\\frac{1}{3}\\right)^3$$\n$$S = 1 - \\frac{1}{27} = \\frac{26}{27}$$",
            "answer": "$$\\boxed{\\frac{26}{27}}$$"
        },
        {
            "introduction": "掌握了基本分析工具后，我们将探讨一个更具现实意义的应用：网络鲁棒性。这个练习将渗流理论应用于分析无标度网络在不同攻击策略下的稳定性。通过计算和比较随机移除节点与针对性移除高度数节点的临界阈值，你将亲手揭示无标度网络“对随机故障鲁棒，对蓄意攻击脆弱”这一著名特性背后的数学原理。",
            "id": "4310614",
            "problem": "考虑一个由配置模型生成的大型网络，该网络有 $N$ 个节点，其无标度度分布 $P(k)$ 定义在整数度 $k \\in [k_{\\min}, k_{\\max}]$ 上，其中 $k_{\\min} \\geq 1$ 且 $k_{\\max} \\gg \\infty$。假设求和的连续近似（用积分代替求和）是有效的，并设度分布为 $P(k) = C k^{-\\gamma}$，其中指数 $\\gamma = 3$，归一化常数 $C  0$。两种节点移除策略被应用于此网络：\n\n- 随机移除：每个节点以概率 $q$ 被独立移除，并以概率 $p = 1 - q$ 被保留。\n- 度靶向移除：对于某个阈值 $K$，所有度 $k \\geq K$ 的节点被移除，而度 $k  K$ 的节点被保留。\n\n从第一性原理出发——具体来说，是基于配置模型中巨型连通分量的分支过程表征，以及用依赖于度的节点保留概率表示的位点渗流判据——推导在一般性的依赖于度的移除策略下的渗流阈值条件，然后将其特化到上述两种策略。对于随机移除，确定恰好使网络破碎（消除巨型连通分量）的临界移除比例 $q_{c}$。对于度靶向移除，确定恰好使网络破碎的临界阈值 $K_{c}$，并由此推导出临界移除比例 $f_{c}$。\n\n将您的最终答案表示为 $k_{\\min}$ 和 $k_{\\max}$ 的闭合形式函数，如果需要，可使用特殊函数，并使用连续近似。在单行中报告这两个阈值比例，顺序为：度靶向移除的临界移除比例 $f_{c}$，后跟随机移除的临界移除比例 $q_{c}$。不需要物理单位。不需要四舍五入；请提供精确表达式。",
            "solution": "用户希望分析一个无标度网络在两种不同节点移除策略下的渗流阈值。\n\n### 步骤1：提取给定条件\n- 网络模型：具有 $N$ 个节点的配置模型。\n- 度分布：$P(k) = C k^{-\\gamma}$，对于整数 $k \\in [k_{\\min}, k_{\\max}]$，其中 $k_{\\min} \\geq 1$ 且 $k_{\\max} \\gg \\infty$。\n- 度指数：$\\gamma = 3$。\n- 近似：求和的连续近似 $\\sum_k \\to \\int dk$ 有效。\n- 移除策略1（随机）：每个节点以概率 $q$ 被移除，以概率 $p=1-q$ 被保留。\n- 移除策略2（度靶向）：所有度 $k \\geq K$ 的节点被移除；度 $k  K$ 的节点被保留。\n- 任务：推导一般渗流条件，将其特化以求出随机移除的临界移除比例 $q_c$，以及靶向移除的临界阈值 $K_c$ 和对应的临界移除比例 $f_c$。\n- 输出：将 $f_c$ 和 $q_c$ 表示为 $k_{\\min}$ 和 $k_{\\max}$ 的闭合形式函数。\n\n### 步骤2：使用提取的条件进行验证\n- **科学依据**：该问题在复杂网络统计力学中有坚实的理论基础。配置模型、无标度分布、渗流理论和分支过程形式体系都是该领域的标准和核心概念。\n- **良定性**：该问题是良定的，提供了推导所需量所需的所有必要信息（$P(k)$ 的形式、$\\gamma$ 的值、度的范围）。目标（$q_c$ 和 $f_c$）定义清晰。\n- **客观性**：该问题以精确、客观和形式化的科学语言陈述。\n- **完整性**：该问题是自洽的。常数 $C$ 通过归一化定义，所有其他所需量都可以从给定条件中推导出来。\n- **一致性与可行性**：该设置是一个标准的理论模型，没有内部矛盾或科学上不合理的条件。\n- **结论**：该问题有效，可以按所述方式求解。\n\n### 步骤3：推导与求解\n\n**一般渗流判据**\n\n配置模型中巨型连通分量的存在性可以通过分析网络上的一个分支过程来确定。巨型连通分量存在的充分必要条件是，从沿着一条随机边到达的节点出发，其出边的平均数大于1。设 $\\phi(k)$ 是度为 $k$ 的节点在移除过程后被保留在网络中的概率。\n\n度分布为 $P(k)$。平均度为 $\\langle k \\rangle = \\int k P(k) dk$。\n随机选择一条边会指向一个度为 $k$ 的节点的概率由剩余度分布给出，该分布与 $k P(k)$ 成正比。归一化后的分布为 $\\frac{kP(k)}{\\langle k \\rangle}$。\n\n到达一个度为 $k$ 的节点（该节点以概率 $\\phi(k)$ 被保留）后，有 $k-1$ 条其他边可以向外分支。这类新分支的平均数（我们记为 $B$）为：\n$$B = \\int_{k_{\\min}}^{k_{\\max}} (k-1) \\phi(k) \\frac{k P(k)}{\\langle k \\rangle} dk$$\n渗流阈值对应于巨型连通分量恰好消失的临界点，此时 $B=1$。因此，渗流阈值的判据是：\n$$ \\int_{k_{\\min}}^{k_{\\max}} k(k-1) \\phi(k) P(k) dk = \\langle k \\rangle = \\int_{k_{\\min}}^{k_{\\max}} k P(k) dk $$\n这就是我们将使用的一般条件。\n\n**对于 $P(k) = Ck^{-3}$ 的网络性质**\n\n首先，我们确定归一化常数 $C$。\n$$ \\int_{k_{\\min}}^{k_{\\max}} P(k) dk = 1 \\implies C \\int_{k_{\\min}}^{k_{\\max}} k^{-3} dk = C \\left[ -\\frac{1}{2}k^{-2} \\right]_{k_{\\min}}^{k_{\\max}} = 1 $$\n$$ C \\left( \\frac{1}{2k_{\\min}^2} - \\frac{1}{2k_{\\max}^2} \\right) = 1 \\implies C = \\frac{2}{\\frac{1}{k_{\\min}^2} - \\frac{1}{k_{\\max}^2}} = \\frac{2 k_{\\min}^2 k_{\\max}^2}{k_{\\max}^2 - k_{\\min}^2} $$\n接下来，我们计算一阶矩（平均度）$\\langle k \\rangle$。\n$$ \\langle k \\rangle = \\int_{k_{\\min}}^{k_{\\max}} k P(k) dk = C \\int_{k_{\\min}}^{k_{\\max}} k^{-2} dk = C \\left[ -k^{-1} \\right]_{k_{\\min}}^{k_{\\max}} = C \\left( \\frac{1}{k_{\\min}} - \\frac{1}{k_{\\max}} \\right) $$\n代入 $C$：\n$$ \\langle k \\rangle = \\frac{2 k_{\\min}^2 k_{\\max}^2}{k_{\\max}^2 - k_{\\min}^2} \\frac{k_{\\max} - k_{\\min}}{k_{\\min} k_{\\max}} = \\frac{2 k_{\\min} k_{\\max} (k_{\\max}-k_{\\min})}{(k_{\\max}-k_{\\min})(k_{\\max}+k_{\\min})} = \\frac{2 k_{\\min} k_{\\max}}{k_{\\max} + k_{\\min}} $$\n\n**策略1：随机移除**\n\n对于随机移除，一个节点以概率 $p = 1-q$ 被保留，这与其度无关。因此，$\\phi(k) = p$。设 $p_c$ 为临界保留概率。渗流判据变为：\n$$ \\int_{k_{\\min}}^{k_{\\max}} k(k-1) p_c P(k) dk = \\langle k \\rangle $$\n$$ p_c \\left( \\int_{k_{\\min}}^{k_{\\max}} k^2 P(k) dk - \\int_{k_{\\min}}^{k_{\\max}} k P(k) dk \\right) = \\langle k \\rangle $$\n$$ p_c (\\langle k^2 \\rangle - \\langle k \\rangle) = \\langle k \\rangle \\implies p_c = \\frac{\\langle k \\rangle}{\\langle k^2 \\rangle - \\langle k \\rangle} $$\n我们需要计算二阶矩 $\\langle k^2 \\rangle$：\n$$ \\langle k^2 \\rangle = \\int_{k_{\\min}}^{k_{\\max}} k^2 P(k) dk = C \\int_{k_{\\min}}^{k_{\\max}} k^{-1} dk = C \\left[ \\ln(k) \\right]_{k_{\\min}}^{k_{\\max}} = C \\ln\\left(\\frac{k_{\\max}}{k_{\\min}}\\right) $$\n临界移除比例为 $q_c = 1 - p_c = 1 - \\frac{1}{\\frac{\\langle k^2 \\rangle}{\\langle k \\rangle} - 1} = \\frac{\\frac{\\langle k^2 \\rangle}{\\langle k \\rangle} - 2}{\\frac{\\langle k^2 \\rangle}{\\langle k \\rangle} - 1}$。\n让我们计算比率 $\\frac{\\langle k^2 \\rangle}{\\langle k \\rangle}$：\n$$ \\frac{\\langle k^2 \\rangle}{\\langle k \\rangle} = \\frac{C \\ln\\left(\\frac{k_{\\max}}{k_{\\min}}\\right)}{C \\left(\\frac{1}{k_{\\min}} - \\frac{1}{k_{\\max}}\\right)} = \\frac{\\ln\\left(\\frac{k_{\\max}}{k_{\\min}}\\right)}{\\frac{k_{\\max} - k_{\\min}}{k_{\\min}k_{\\max}}} = \\frac{k_{\\min}k_{\\max}}{k_{\\max}-k_{\\min}} \\ln\\left(\\frac{k_{\\max}}{k_{\\min}}\\right) $$\n将此代入 $q_c$ 的表达式中：\n$$ q_c = \\frac{\\frac{k_{\\min}k_{\\max}}{k_{\\max}-k_{\\min}} \\ln\\left(\\frac{k_{\\max}}{k_{\\min}}\\right) - 2}{\\frac{k_{\\min}k_{\\max}}{k_{\\max}-k_{\\min}} \\ln\\left(\\frac{k_{\\max}}{k_{\\min}}\\right) - 1} $$\n\n**策略2：度靶向移除**\n\n对于度靶向移除，度 $k \\geq K$ 的节点被移除。保留概率为：当 $k  K$ 时 $\\phi(k) = 1$，当 $k \\geq K$ 时 $\\phi(k) = 0$。通过在一般判据的左侧将积分上限设为 $K_c$，可以找到临界阈值 $K_c$：\n$$ \\int_{k_{\\min}}^{K_c} k(k-1) P(k) dk = \\langle k \\rangle $$\n$$ C \\int_{k_{\\min}}^{K_c} (k^2-k) k^{-3} dk = C \\int_{k_{\\min}}^{k_{\\max}} (k-k^0)k^{-3} dk= C \\int_{k_{\\min}}^{k_{\\max}} (k^{-2}-k^{-3})dk$$\n这里有个错误，左边的积分应该是$\\int_{k_{\\min}}^{K_c} (k^{-1} - k^{-2}) dk$ 而右边是 $\\int_{k_{\\min}}^{k_{\\max}} (k^{-2}) dk$。让我们纠正：\n$$ C \\int_{k_{\\min}}^{K_c} (k^{-1} - k^{-2}) dk = C\\left(\\frac{1}{k_{\\min}} - \\frac{1}{k_{\\max}}\\right) $$\n常数 $C$ 被消去。\n$$ \\left[ \\ln(k) + \\frac{1}{k} \\right]_{k_{\\min}}^{K_c} = \\frac{1}{k_{\\min}} - \\frac{1}{k_{\\max}} $$\n$$ \\left( \\ln(K_c) + \\frac{1}{K_c} \\right) - \\left( \\ln(k_{\\min}) + \\frac{1}{k_{\\min}} \\right) = \\frac{1}{k_{\\min}} - \\frac{1}{k_{\\max}} $$\n$$ \\ln(K_c) + \\frac{1}{K_c} = \\ln(k_{\\min}) + \\frac{2}{k_{\\min}} - \\frac{1}{k_{\\max}} $$\n这是一个关于 $K_c$ 的超越方程。令 $A = \\ln(k_{\\min}) + \\frac{2}{k_{\\min}} - \\frac{1}{k_{\\max}}$ 且 $x=K_c$。方程 $ze^z = C$ 可使用朗伯W函数 $W(z)$ 求解。令 $y=-1/K_c$，则 $K_c = -1/y$。方程变为 $\\ln(-1/y) - y = A$，这很难处理。让我们使用原始的 $x e^x$ 形式。方程为 $y-\\ln y = A \\implies e^{y-\\ln y} = e^A \\implies e^y/y = e^A \\implies y e^{-y} = e^{-A}$。令 $z=-y$，则 $(-z)e^z = e^{-A} \\implies z e^z = -e^{-A}$。所以 $z = W_0(-e^{-A})$。因此 $-y = W_0(-e^{-A}) \\implies y = -W_0(-e^{-A}) \\implies 1/K_c = -W_0(-e^{-A})$。\n$K_c = -1/W_0(-e^{-A})$\n$A = \\ln(k_{\\min}) + \\frac{2}{k_{\\min}} - \\frac{1}{k_{\\max}}$\n$e^{-A} = \\exp(-\\ln(k_{\\min}) - \\frac{2}{k_{\\min}} + \\frac{1}{k_{\\max}}) = \\frac{1}{k_{\\min}} \\exp(\\frac{1}{k_{\\max}} - \\frac{2}{k_{\\min}})$.\n$K_c = -\\left(W_0\\left(-\\frac{1}{k_{\\min}}\\exp\\left(\\frac{1}{k_{\\max}}-\\frac{2}{k_{\\min}}\\right)\\right)\\right)^{-1} $$\n临界移除节点比例 $f_c$ 是 $P(k)$ 在被移除的度范围上的积分，即从 $K_c$ 到 $k_{\\max}$。\n$$ f_c = \\int_{K_c}^{k_{\\max}} P(k) dk = C \\int_{K_c}^{k_{\\max}} k^{-3} dk = C \\left[-\\frac{1}{2}k^{-2}\\right]_{K_c}^{k_{\\max}} = \\frac{C}{2}\\left(\\frac{1}{K_c^2} - \\frac{1}{k_{\\max}^2}\\right) $$\n回顾 $1 = \\int_{k_{\\min}}^{k_{\\max}} P(k) dk = \\frac{C}{2}\\left(\\frac{1}{k_{\\min}^2} - \\frac{1}{k_{\\max}^2}\\right)$，我们可以将 $f_c$ 写为：\n$$ f_c = \\frac{\\frac{1}{K_c^2} - \\frac{1}{k_{\\max}^2}}{\\frac{1}{k_{\\min}^2} - \\frac{1}{k_{\\max}^2}} = \\frac{K_c^{-2} - k_{\\max}^{-2}}{k_{\\min}^{-2} - k_{\\max}^{-2}} $$\n代入 $K_c^{-1}$ 的表达式：\n$$ K_c^{-1} = -W_0\\left(-\\frac{1}{k_{\\min}}\\exp\\left(\\frac{1}{k_{\\max}}-\\frac{2}{k_{\\min}}\\right)\\right) $$\n所以，$K_c^{-2} = \\left[W_0\\left(-\\frac{1}{k_{\\min}}\\exp\\left(\\frac{1}{k_{\\max}}-\\frac{2}{k_{\\min}}\\right)\\right)\\right]^2$。\n$f_c$ 的最终表达式是：\n$$ f_c = \\frac{\\left[W_0\\left(-\\frac{1}{k_{\\min}}\\exp\\left(\\frac{1}{k_{\\max}}-\\frac{2}{k_{\\min}}\\right)\\right)\\right]^2 - k_{\\max}^{-2}}{k_{\\min}^{-2} - k_{\\max}^{-2}} $$\n\n最终答案需要两个比例，$f_c$ 和 $q_c$。",
            "answer": "$$ \\boxed{\\begin{pmatrix} \\frac{\\left[W_0\\left(-\\frac{1}{k_{\\min}}\\exp\\left(\\frac{1}{k_{\\max}}-\\frac{2}{k_{\\min}}\\right)\\right)\\right]^2 - k_{\\max}^{-2}}{k_{\\min}^{-2} - k_{\\max}^{-2}},  \\frac{\\frac{k_{\\min}k_{\\max}}{k_{\\max}-k_{\\min}} \\ln\\left(\\frac{k_{\\max}}{k_{\\min}}\\right) - 2}{\\frac{k_{\\min}k_{\\max}}{k_{\\max}-k_{\\min}} \\ln\\left(\\frac{k_{\\max}}{k_{\\min}}\\right) - 1} \\end{pmatrix}} $$"
        },
        {
            "introduction": "理论推导为我们提供了深刻的洞见，但计算模拟是验证理论和探索复杂情况不可或缺的工具。本实践要求你设计并实现一个完整的程序，使用高效的并查集（Disjoint Set Union）算法来模拟晶格上的键渗流过程。通过亲手实现，你将学会如何精确测量渗流相变的关键物理量，如巨片大小 $P_\\infty$ 和磁化率 $\\chi$，从而将抽象的理论概念转化为可计算和可视化的结果。",
            "id": "4310671",
            "problem": "设计并实现一个完整的程序，该程序使用并查集（Disjoint Set Union, DSU）数据结构来识别方形晶格上键逾渗模型中的连通分量，并计算两个可观测量：最大连通分量中的节点分数 $P_\\infty$ 和磁化率 $\\chi$，将其作为键占据概率 $p$ 的函数。您的程序必须是独立的，不得读取外部输入，并按照下面指定的格式产生单行输出。\n\n背景与基本原理：\n- 考虑一个无向图 $G = (V, E)$，其中 $V$ 是一个包含 $|V| = N$ 个节点的集合，$E$ 是一个包含 $|E| = M$ 条键（边）的集合。在键逾渗中，$E$ 中的每条键以概率 $p \\in [0,1]$ 独立地处于激活（存在）状态，并以概率 $1 - p$ 处于未激活（不存在）状态。\n- 连通分量是 $V$ 的一个极大子集，该子集中的任意一对节点都通过一条由激活键构成的路径相连。并查集（DSU）数据结构（也称为合并-查找数据结构）维护了 $V$ 的一个划分为多个不相交的集合，这些集合代表了连通分量，并支持两种操作：find（用于获取集合的代表元素）和 union（用于合并两个集合）。\n- 程序必须在指定的 $p$ 值下测量两个标准逾渗可观测量：\n  1. 最大连通分量中的节点分数 $P_\\infty = s_{\\max} / N$，其中 $s_{\\max}$ 是最大连通分量的大小。\n  2. 磁化率 $\\chi$，在有限图上定义为排除最大连通分量后的结果。设 $s_i$ 是所有连通分量的大小，$s_{\\max}$ 表示最大的那个。那么\n  $$\\chi = \\frac{\\sum_{i: s_i \\neq s_{\\max}} s_i^2}{\\sum_{i: s_i \\neq s_{\\max}} s_i}.$$\n  如果没有有限分量（即 $s_{\\max} = N$），则按惯例定义 $\\chi = 0$。\n- 您必须对跨越不同 $p$ 值的逾渗构型使用单调耦合来计算这些可观测量：生成一个单一的键的随机排序，并按該順序激活它们。对于给定的 $p$，设 $k = \\lfloor p \\, M \\rfloor$ 为激活键的数量；然后考虑由该顺序中前 $k$ 条键形成的子图。这种耦合确保了随着 $p$ 的增加，构型是嵌套的。\n\n使用的图模型：\n- 使用一个线性尺寸为 $L$ 的方形晶格上的键逾渗模型。节点集 $V$ 是一个 $L \\times L$ 网格上的晶格位点集合，采用开放边界条件。键集 $E$ 包含最近邻的水平和垂直键（无对角线），因此 $M = 2 L (L - 1)$ 且 $N = L^2$。\n\n算法要求：\n- 实现带有路径压缩和按大小合并（或按秩合并）的 DSU。维护每个分量的大小，以便每次合并时都能在 $\\mathcal{O}(1)$ 时间内更新 $s_{\\max}$。同时，维护分量大小的平方和 $S_2 = \\sum_i s_i^2$，并在合并两个大小为 $a$ 和 $b$ 的分量时，利用恒等式\n  $$(a + b)^2 - a^2 - b^2 = 2ab.$$\n  在 $\\mathcal{O}(1)$ 时间内更新 $S_2$。然后计算\n  $$P_\\infty = \\frac{s_{\\max}}{N}, \\quad \\chi = \\begin{cases}\n  \\dfrac{S_2 - s_{\\max}^2}{N - s_{\\max}},  \\text{if } s_{\\max} \\neq N,\\\\\n  0,  \\text{if } s_{\\max} = N.\n  \\end{cases}$$\n- 对于每个测试用例，使用由指定种子初始化的伪随机数生成器生成所有 $M$ 条键的单个随机排列，并根据该排列增量式地激活键，直至每个检查点 $p$。\n\n测试套件：\n您的程序必须为以下测试用例计算可观测量。对于每个用例，$p$ 值列表均按非递减顺序列出。\n- 测试用例 1: $L = 16$，种子 $= 12345$，检查点 $p \\in [0.0, 0.2, 0.4, 0.5, 0.6, 0.8, 1.0]$。\n- 测试用例 2: $L = 32$，种子 $= 2024$，检查点 $p \\in [0.0, 0.48, 0.5, 0.52, 1.0]$。\n- 测试用例 3: $L = 8$，种子 $= 7$，检查点 $p \\in [0.0, 1.0]$。\n- 测试用例 4: $L = 24$，种子 $= 99$，检查点 $p \\in [0.3, 0.7]$。\n\n最终输出格式：\n- 您的程序必须产生一个包含列表的单行输出，其中每个元素对应一个测试用例，顺序与上面列出的顺序相同。\n- 对于每个测试用例，输出一个包含两个元素的列表：第一个元素是在指定检查点处的 $P_\\infty$ 值列表（顺序与检查点列表相同），第二个元素是在这些检查点处的 $\\chi$ 值列表。\n- 因此，总输出必须是一个浮点数列表的列表的列表，其精确形状为\n  $$\\big[ [ [P_{\\infty,1}(p_1), \\dots], [\\chi_1(p_1), \\dots] ],\\ \\dots\\ \\big].$$\n- 输出必须打印为单行，形式为用方括号括起来的逗号分隔列表，不得包含任何额外文本。不涉及角度和物理单位；所有数值输出均为无单位的实数（浮点数）。",
            "solution": "用户想要一个程序来模拟二维方形晶格上的键逾渗，并计算关键的可观测量。\n\n### 问题验证\n我已对问题陈述进行了全面验证。\n- **提取的已知条件**：\n    - 模型：$L \\times L$ 方形晶格上的键逾渗，具有开放边界条件。\n    - 节点：$N = L^2$。\n    - 键：$M = 2L(L-1)$ 条最近邻键。\n    - 过程：单调耦合，从单个随机排列中增量添加键。激活键的数量为 $k = \\lfloor pM \\rfloor$。\n    - 可观测量：\n        1. 最大分量中的分数，$P_\\infty = s_{\\max} / N$。\n        2. 磁化率，$\\chi = \\frac{\\sum_{i: s_i \\neq s_{\\max}} s_i^2}{\\sum_{i: s_i \\neq s_{\\max}} s_i}$，使用提供的计算公式 $\\chi = \\frac{S_2 - s_{\\max}^2}{N - s_{\\max}}$ (当 $s_{\\max} \\neq N$ 时) 和 $\\chi=0$ (当 $s_{\\max} = N$ 时)。\n    - 算法：带有路径压缩和按大小合并的并查集（DSU）。对 $s_{\\max}$ 和 $S_2 = \\sum_i s_i^2$ 进行 O(1) 更新。\n    - 测试用例：给出了四个具体的用例，包含参数 $L$、`seed` 和检查点概率 $p$。\n    - 输出：一个单行字符串，表示一个包含每个测试用例结果的列表。\n- **验证结论**：问题是有效的。它在科学上是合理的、良定的、客观的、完整的，并且在计算上是可行的。模型和可观测量是统计物理学中的标准内容，指定的算法是此类模拟的典型方法。测试用例定义明确。\n\n### 解决方案设计\n\n解决方案将是一个 Python 程序，按规定实现模拟。程序的核心将是一个执行单个测试用例的函数，并辅以辅助结构来管理逾渗过程。\n\n**1. 晶格和键**\n对于给定的线性尺寸 $L$，晶格由 $N=L^2$ 个位点组成，我们可以从 $0$ 到 $N-1$ 对其进行索引。坐标为 $(r, c)$（其中 $0 \\le r, c  L$）的位点映射到索引 $i = r \\cdot L + c$。生成 $M=2L(L-1)$ 条可能的最近邻键（水平和垂直），并存储在一个列表中。使用一个为可复现性设置了种子的伪随机数生成器，来创建这些键的单个随机排列。此排列决定了键被激活的顺序。\n\n**2. 并查集（DSU）数据结构**\n为了在添加键时有效地跟踪图的连通分量，我们将实现一个 DSU 数据结构。该结构将维护 $N$ 个位点的一个划分为不相交的集合。我们的实现将：\n- 使用一个 `parent` 数组，其中 `parent[i]` 存储位点 $i$ 的父节点。一个分量由其根节点标识，即一个满足 `parent[i] == i` 的位点 $i$。\n- 实现带有**路径压缩**的 **find** 操作。此操作找到包含给定站点的分量的根，并在此过程中展平树结构，从而带来显著的长期加速。\n- 使用一个 `comp_size` 数组，其中 `comp_size[i]` 存储了如果 $i$ 是根节点时其所在分量中的位点数。\n- **union** 操作将使用**按大小合并**的启发式方法执行：在合并两个分量时，较小分量的根总是附加到较大分量的根上。这可以保持树的浅度。\n\n**3. 通过单调耦合进行模拟**\n模拟是增量进行的。我们遍历排序后的检查点概率 $p$ 列表。对于每个 $p$，我们确定要激活的键的总数，$k = \\lfloor pM \\rfloor$。然后，我们从上次停止的地方开始，从排列好的键列表中添加键，直到有 $k$ 条键被激活。\n\n对于添加的每一条键 $(u, v)$：\n- 我们找到包含位点 $u$ 和 $v$ 的分量的根。\n- 如果根不同，则位點位於不同的分量中，需要进行合并。我们执行一次 union 操作。\n- 设正在合并的两个分量的大小为 $s_a$ 和 $s_b$。新分量的大小将为 $s_a+s_b$。此事件触发对我们全局可观测量的更新。\n\n**4. 可观测量计算**\n为了高效计算 $P_\\infty$ 和 $\\chi$，我们在整个模拟过程中维护三个全局量：\n- $N$：总位点数，是一个常数（$L^2$）。\n- $s_{\\max}$：最大连通分量的大小。最初，所有位点都位于大小为 1 的分量中，因此 $s_{\\max}^{(0)} = 1$。\n- $S_2$：所有分量大小的平方和，$S_2 = \\sum_i s_i^2$。最初，$S_2^{(0)} = \\sum_{i=1}^{N} 1^2 = N$。\n\n当两个大小为 $s_a$ 和 $s_b$ 的分量合并时，这些量将在 $\\mathcal{O}(1)$ 时间内更新：\n- 新的大小为 $s_{new} = s_a+s_b$。\n- 新的最大分量大小为 $s'_{\\max} = \\max(s_{\\max}, s_{new})$。\n- 平方和使用恒等式 $(s_a+s_b)^2 - s_a^2 - s_b^2 = 2s_as_b$ 进行更新。新的和为 $S'_2 = S_2 - s_a^2 - s_b^2 + (s_a+s_b)^2 = S_2 + 2s_as_b$。\n\n为给定检查点 $p$ 添加所需数量的键后，可观测量计算如下：\n- $P_\\infty(p) = \\frac{s_{\\max}}{N}$\n- $\\chi(p) = \\begin{cases} \\frac{S_2 - s_{\\max}^2}{N - s_{\\max}}  \\text{if } s_{\\max} \\neq N \\\\ 0  \\text{if } s_{\\max} = N \\end{cases}$\n\n这种增量方法非常高效，因为我们在对键的一次遍历中处理了给定晶格的所有检查点。单个测试用例（含 $C$ 个检查点）的总体复杂度主要由键处理循环决定，约为 $\\mathcal{O}(M \\alpha(N) + C)$，其中 $\\alpha(N)$ 是由 DSU 操作产生的增长极慢的反阿克曼函数。",
            "answer": "```python\nimport numpy as np\n\nclass DSU:\n    \"\"\"A Disjoint Set Union data structure with path compression and union by size.\"\"\"\n    def __init__(self, n):\n        # parent[i] is the parent of site i\n        self.parent = np.arange(n)\n        # comp_size[i] is the size of the component if i is a root\n        self.comp_size = np.ones(n, dtype=np.int64)\n\n    def find(self, i):\n        \"\"\"Finds the root of the component containing site i, with path compression.\"\"\"\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\ndef run_percolation_simulation(L, seed, p_checkpoints):\n    \"\"\"\n    Runs a bond percolation simulation on an L x L grid.\n\n    Args:\n        L (int): The linear size of the square lattice.\n        seed (int): The seed for the pseudo-random number generator.\n        p_checkpoints (list of float): A non-decreasing list of bond occupation\n                                       probabilities at which to measure observables.\n\n    Returns:\n        list: A list containing two lists:\n              1. A list of P_infinity values for each checkpoint.\n              2. A list of chi values for each checkpoint.\n    \"\"\"\n    N = L * L\n    if L == 1:\n        M = 0\n    else:\n        M = 2 * L * (L - 1)\n\n    # 1. Generate all possible bonds on the L x L grid\n    bonds = []\n    # Horizontal bonds\n    for r in range(L):\n        for c in range(L - 1):\n            u = r * L + c\n            v = r * L + (c + 1)\n            bonds.append((u, v))\n    # Vertical bonds\n    for r in range(L - 1):\n        for c in range(L):\n            u = r * L + c\n            v = (r + 1) * L + c\n            bonds.append((u, v))\n\n    # 2. Create a single random permutation of bonds for monotone coupling\n    rng = np.random.default_rng(seed)\n    permuted_bonds = rng.permutation(bonds, axis=0)\n\n    # 3. Initialize DSU and observable trackers\n    dsu = DSU(N)\n    \n    # Track sum of squares of component sizes (S2) and max component size (s_max)\n    # Initially N components of size 1.\n    S2 = float(N) if N > 0 else 0.0\n    s_max = 1 if N > 0 else 0\n\n    results_P_inf = []\n    results_chi = []\n    \n    current_bond_idx = 0\n\n    # 4. Monotonically add bonds and compute observables at checkpoints\n    for p in p_checkpoints:\n        target_num_bonds = int(p * M)\n        \n        while current_bond_idx  target_num_bonds:\n            u, v = permuted_bonds[current_bond_idx]\n            \n            root_u = dsu.find(u)\n            root_v = dsu.find(v)\n            \n            if root_u != root_v:\n                size_u = dsu.comp_size[root_u]\n                size_v = dsu.comp_size[root_v]\n                \n                # Union by size: attach smaller tree to larger tree's root\n                if size_u  size_v:\n                    root_u, root_v = root_v, root_u\n                    size_u, size_v = size_v, size_u\n                \n                dsu.parent[root_v] = root_u\n                new_size = size_u + size_v\n                dsu.comp_size[root_u] = new_size\n                \n                # Update observables in O(1)\n                S2 += 2 * size_u * size_v\n                s_max = max(s_max, new_size)\n            \n            current_bond_idx += 1\n            \n        # 5. Calculate and store observables for the current checkpoint\n        if N == 0:\n            P_inf = 0.0\n            chi = 0.0\n        else:\n            P_inf = s_max / N\n            if s_max == N:\n                chi = 0.0\n            else:\n                chi = (S2 - s_max**2) / (N - s_max)\n                \n        results_P_inf.append(P_inf)\n        results_chi.append(chi)\n        \n    return [results_P_inf, results_chi]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the percolation simulation,\n    then prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        {'L': 16, 'seed': 12345, 'p_checkpoints': [0.0, 0.2, 0.4, 0.5, 0.6, 0.8, 1.0]},\n        {'L': 32, 'seed': 2024, 'p_checkpoints': [0.0, 0.48, 0.5, 0.52, 1.0]},\n        {'L': 8, 'seed': 7, 'p_checkpoints': [0.0, 1.0]},\n        {'L': 24, 'seed': 99, 'p_checkpoints': [0.3, 0.7]},\n    ]\n\n    results = []\n    for case in test_cases:\n        result_for_case = run_percolation_simulation(\n            case['L'], case['seed'], case['p_checkpoints']\n        )\n        results.append(result_for_case)\n\n    # Format the final output string exactly as required\n    # Using repr() to get a string representation that matches Python's list syntax\n    # and then joining them with commas.\n    print(f\"[{','.join(repr(res) for res in results)}]\")\n\n# solve() # This is a library function, so we don't run it directly\n# A dummy print to simulate the expected output format for validation\n# The actual execution would happen in a testing environment.\n# This code is designed to be executable.\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}