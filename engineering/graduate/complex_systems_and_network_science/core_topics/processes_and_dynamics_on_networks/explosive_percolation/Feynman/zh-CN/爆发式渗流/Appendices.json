{
    "hands_on_practices": [
        {
            "introduction": "理论是理解现象的基础，但亲手实现模型并观察其行为是培养直觉和深化理解的无可替代的方式。这项实践将指导你编写一个受控逾渗过程的模拟程序。通过实现一个带有前瞻视野的Achlioptas类型选择规则，你将能直接观察到“选择的力量”如何抑制小团簇的合并，从而延迟并最终导致一个急剧的、爆炸性相变的发生。这个练习不仅能巩固你对爆炸性逾渗核心机制的理解，还能让你掌握网络科学研究中必不可少的计算模拟技能。",
            "id": "4275752",
            "problem": "考虑一个在 $n$ 个已标记顶点的完全图上的离散时间随机图过程，其中演化网络初始时没有边。所有可能的无向边集合在开始时被一次性均匀随机排列，然后按顺序无放回地处理。在每个时间步 $t$，一个具有前瞻范围 $h$ 的在线控制器会得到这个固定的全局排列中接下来的 $h$ 条候选边组成的连续窗口，并且必须不可撤销地选择其中恰好一条边加入网络，并丢弃其余的 $h-1$ 条候选边。控制器的选择仅限于纯在线方式：它只能使用网络当前的连通分量划分以及这 $h$ 条候选边的身份信息。将控制规则定义如下：在这 $h$ 条候选边中，选择那条能使其端点所在连通分量大小的乘积最小化的边；如果某条边的两个端点已在同一个分量中，则将其乘积定义为 $+\\infty$，以便在存在其他选项时降低冗余边的优先级。此选择规则是一种在线 Achlioptas 型最小化，其中 $h$ 控制前瞻范围。\n\n基本和核心定义：\n- 在时间 $t$ 的当前图的一个连通分量是一个顶点的最大集合，使得集合中任意一对顶点都通过在时间 $t$ 存在的边路径相连。\n- 令 $L(t)$ 表示在时间 $t$ 的最大连通分量的大小，其中 $L(0)=1$，因为所有顶点最初都是孤立的。\n- 定义归一化最大分量大小 $S(t) = L(t)/n$。\n- 爆发性将通过 $S(t)$ 的最大单步跳跃来量化，即 $J_{\\max} = \\max_{1 \\le t \\le T} \\left(S(t) - S(t-1)\\right)$，其中 $S(0)=1/n$。\n- 定义半巨型组件出现的临界交叉索引为使得 $S(t)\\ge 1/2$ 的最小时间 $t$；相关的边密度代理是 $p_{1/2} = t/n$，如果在已添加边的范围内不存在这样的 $t$，则返回 $-1$。\n- 计算成本定义为控制器执行的边评估总数；在 $h$-前瞻规则下，这是 $C = h \\cdot T$，其中 $T$ 是实际添加的边数。\n\n任务：\n- 实现一个完整、可运行的程序，为多种参数设置模拟上述在线受控渗流过程，使用不相交集并 (Disjoint Set Union, DSU)（也称为并查集）并结合路径压缩和按大小合并来高效地维护连通分量。程序必须为每个测试用例计算元组 $\\left(J_{\\max}, p_{1/2}, C, T\\right)$，其中 $J_{\\max}$ 和 $p_{1/2}$是浮点数，$C$ 和 $T$ 是整数。\n\n科学真实性和约束：\n- 边的随机排列必须在每个测试用例中都使用固定的伪随机种子生成一次，以确保可复现性。\n- 每个时间步从排列中消耗 $h$ 条候选边，并向图中精确添加一条选定的边，丢弃其他 $h-1$ 条候选边。这意味着 $h \\cdot T$ 不能超过完全图中的不同边总数 $\\frac{n(n-1)}{2}$（以避免候选边耗尽）。\n\n测试套件：\n为以下五个参数设置提供结果，每个设置由 $(n,h,T,\\text{seed})$ 指定：\n1. $(n,h,T,\\text{seed}) = (200,1,200,7)$\n2. $(n,h,T,\\text{seed}) = (200,4,200,7)$\n3. $(n,h,T,\\text{seed}) = (200,8,200,7)$\n4. $(n,h,T,\\text{seed}) = (30,4,80,3)$\n5. $(n,h,T,\\text{seed}) = (50,20,50,11)$\n\n答案规范：\n- 对于每个测试用例，使用上述定义计算 $\\left(J_{\\max}, p_{1/2}, C, T\\right)$。将 $J_{\\max}$ 和 $p_{1/2}$ 表示为十进制浮点数，$C$ 和 $T$ 表示为整数。\n- 你的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来，每个测试用例的结果本身格式化为一个四元列表。例如，一个有效的输出格式是 $\\left[ [J_{\\max}^{(1)},p_{1/2}^{(1)},C^{(1)},T^{(1)}], [J_{\\max}^{(2)},p_{1/2}^{(2)},C^{(2)},T^{(2)}], \\dots \\right]$。",
            "solution": "该问题定义明确，在网络科学领域有坚实的科学基础，并为计算模拟提供了一套清晰、可形式化的规则。所有参数和定义都非常精确，约束条件也保持一致。因此，我们着手解决该问题。\n\n这个问题的核心是在特定增长规则下高效地跟踪图中连通分量的演变。对于这项任务，不相交集并 (DSU) 数据结构（也称为并查集数据结构）非常适用。按照规定，我们的实现利用了两个关键优化：路径压缩和按大小合并。\n\n- **路径压缩**：在执行 `find` 操作（确定一个分量的代表或根）期间，我们通过使查找路径上的每个节点直接指向根来“压平”树的结构。这极大地加速了该分量中节点未来的 `find` 操作。\n- **按大小合并**：在 `union` 操作中合并两个分量时，我们总是将较小分量的根附加到较大分量的根上。这种启发式方法有助于保持分量树较浅，从而使 `find` 操作保持快速。对 $n$ 个元素执行 $m$ 次操作的摊销时间复杂度接近常数，具体为 $O(m \\alpha(n))$，其中 $\\alpha(n)$ 是增长极其缓慢的反阿克曼函数。\n\n对于由参数 $(n,h,T,\\text{seed})$ 给出的每个测试用例，模拟过程如下：\n\n1.  **初始化**：\n    - 使用给定的 `seed` 值为伪随机数生成器设定种子，以确保边排列的可复现性。\n    - 我们为 $n$ 个顶点的图生成所有 $\\frac{n(n-1)}{2}$ 条可能的无向边。然后对此集合进行洗牌，以创建一个单一、固定、随机的候选边排列，该排列将被顺序处理。\n    - 为 $n$ 个顶点初始化 DSU 结构，每个顶点 $i \\in \\{0, 1, \\dots, n-1\\}$ 都被放置在各自大小为 $1$ 的分量中。\n    - 初始最大连通分量大小为 $L(0)=1$（对于 $n0$），其归一化对应值为 $S(0)=L(0)/n = 1/n$。我们用这个初始值 $S(0)$ 初始化一个记录这些归一化大小的历史记录，我们可以将其表示为 `S_history`。\n    - 我们初始化待计算的指标：最大跳跃 $J_{\\max}$ 设置为 $0.0$，半巨型组件交叉的密度代理 $p_{1/2}$ 设置为 $-1.0$，以表示阈值尚未被跨越。\n\n2.  **迭代过程**：模拟总共运行 $T$ 个时间步，从 $t=1$ 到 $t=T$。在每一步 $t$ 中：\n    - 从全局排列的列表中顺序抽取一个包含 $h$ 条候选边的窗口。这会消耗排列中的 $h$ 条边。\n    - 控制器评估窗口中的每条候选边 $(u, v)$。对于每条边，它使用 DSU 的 `find` 操作来识别其端点 $u$ 和 $v$ 所属的分量。\n    - 应用选择规则：\n        - 如果端点 $u$ 和 $v$ 已经属于同一个分量（即 `find(u) == find(v)`），则该边被视为冗余。其成本乘积被视为 $+\\infty$。\n        - 如果端点属于不同的分量，成本是它们各自所在分量大小的乘积。这些大小可以从我们的 DSU 结构中轻松获得，该结构在 `union` 操作期间会维护它们。\n    - 控制器选择具有最小有限成本乘积的候选边。如果多条边共享相同的最小乘积，则选择在 $h$ 边窗口中首先出现的那条，这提供了一个确定性的平局决胜规则。\n    - 如果选择了一条非冗余边，则对其端点执行 `union` 操作，合并它们的两个分量。如果新形成的分量大于之前的最大值，则更新最大分量的大小 $L(t)$。如果所有 $h$ 个候选边都是冗余的，则不会执行改变分量结构的 `union` 操作，因此 $L(t) = L(t-1)$。\n    - 计算并记录归一化大小 $S(t) = L(t)/n$。\n    - 通过取当前值与当前步骤的跳跃 $S(t) - S(t-1)$ 的最大值来更新最大跳跃 $J_{\\max}$。\n    - 如果首次跨越半巨型组件阈值 $S(t) \\ge 0.5$（即 $p_{1/2}$ 仍为 $-1.0$），则将临界边密度代理记录为 $p_{1/2} = t/n$。\n\n3.  **最终确定**：\n    - 经过 $T$ 步后，计算总计算成本，定义为边评估次数，即 $C = h \\cdot T$。\n    - 将最终的结果元组 $(J_{\\max}, p_{1/2}, C, T)$ 组合并存储。\n\n整个过程被封装在一个 Python 程序中。该程序遍历所提供的测试套件，为每个参数集执行模拟，并将收集到的结果格式化为指定的单行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\nclass DSU:\n    \"\"\"\n    A Disjoint Set Union (DSU) data structure with path compression and\n    union by size. This is used to efficiently track the connected\n    components of the graph.\n    \"\"\"\n    def __init__(self, n):\n        # parent[i] is the parent of element i\n        self.parent = list(range(n))\n        # comp_size[i] is the size of the component if i is a root\n        self.comp_size = [1] * n\n\n    def find(self, i):\n        \"\"\"Finds the representative (root) of the set containing element i.\"\"\"\n        if self.parent[i] == i:\n            return i\n        # Path compression: make the node point directly to the root\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        \"\"\"Merges the sets containing elements i and j.\"\"\"\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            # Union by size: attach the smaller tree to the root of the larger tree\n            if self.comp_size[root_i]  self.comp_size[root_j]:\n                root_i, root_j = root_j, root_i\n            self.parent[root_j] = root_i\n            self.comp_size[root_i] += self.comp_size[root_j]\n            return self.comp_size[root_i]\n        return self.comp_size[root_i]\n\ndef simulate(n, h, T, seed):\n    \"\"\"\n    Runs a single simulation of the controlled percolation process.\n\n    Args:\n        n (int): Number of vertices.\n        h (int): Lookahead horizon.\n        T (int): Number of edges to add.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        list: A list containing [J_max, p_1/2, C, T].\n    \"\"\"\n    # 1. Initialization\n    rng = np.random.default_rng(seed)\n    dsu = DSU(n)\n    \n    # Generate and permute all possible edges\n    all_edges = []\n    if n > 0:\n        for i in range(n):\n            for j in range(i + 1, n):\n                all_edges.append((i, j))\n    rng.shuffle(all_edges)\n    permuted_edges = all_edges\n    \n    L_current = 1 if n > 0 else 0\n    # S_history stores S(0), S(1), ..., S(T)\n    S_history = [L_current / n if n > 0 else 0.0]\n    \n    J_max = 0.0\n    p_half = -1.0\n    \n    edge_idx = 0\n\n    # 2. Simulation Loop for T time steps\n    for t in range(1, T + 1):\n        candidate_edges = permuted_edges[edge_idx : edge_idx + h]\n        edge_idx += h\n        \n        best_edge = None\n        min_product = float('inf')\n        \n        # Controller's selection logic\n        for u, v in candidate_edges:\n            root_u = dsu.find(u)\n            root_v = dsu.find(v)\n            \n            if root_u != root_v:\n                product = dsu.comp_size[root_u] * dsu.comp_size[root_v]\n                if product  min_product:\n                    min_product = product\n                    best_edge = (u, v)\n\n        S_previous = S_history[-1]\n        \n        # Add the selected edge and update component sizes\n        if best_edge:\n            u_best, v_best = best_edge\n            new_comp_size = dsu.union(u_best, v_best)\n            L_current = max(L_current, new_comp_size)\n\n        # If best_edge is None, L_current does not change\n        \n        S_current = L_current / n\n        S_history.append(S_current)\n        \n        # Update metrics\n        if p_half == -1.0 and S_current >= 0.5:\n            p_half = t / n\n            \n        J_max = max(J_max, S_current - S_previous)\n\n    # 3. Finalization\n    C = h * T\n    \n    return [J_max, p_half, C, T]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, h, T, seed)\n        (200, 1, 200, 7),\n        (200, 4, 200, 7),\n        (200, 8, 200, 7),\n        (30, 4, 80, 3),\n        (50, 20, 50, 11),\n    ]\n\n    results = []\n    for params in test_cases:\n        n, h, T, seed = params\n        result = simulate(n, h, T, seed)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Format: [[J_max1,p_1/2_1,C1,T1],[J_max2,p_1/2_2,C2,T2],...]\n    formatted_results = []\n    for res in results:\n        # res is [J_max, p_half, C, T]\n        formatted_res = f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\"\n        formatted_results.append(formatted_res)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在计算科学中，一个优雅的算法与一个低效的算法之间可能隔着从“可行”到“不可能”的鸿沟，尤其是在处理大规模网络时。在建立了逾渗过程的模拟之后，下一步自然是分析其计算效率。这项练习要求你深入研究模拟程序的核心——并查集（Disjoint Set Union, DSU）数据结构，并推导Achlioptas过程每一步的时间复杂度。通过这个分析，你将理解为什么高效的数据结构对于精确模拟大系统中的临界现象至关重要，并学会如何通过优化来确保算法性能。",
            "id": "4275775",
            "problem": "考虑在一个初始为空、包含 $N$ 个带标签顶点的简单无向图上，使用 Achlioptas $m$ 选最优乘积规则来模拟爆炸渗流。在每个离散步骤中，你从当前不存在的边集合中无放回地均匀采样 $m$ 条候选边。对于每条候选边 $\\{u,v\\}$，你计算其乘积规则得分，即 $s_{u} s_{v}$，其中 $s_{u}$ 和 $s_{v}$ 分别是包含 $u$ 和 $v$ 的连通分量的大小。被选中的边是那些连接两个不同分量的候选边中得分最小的一条；若得分相同则任意选择一条，然后将选中的边加入图中。连通分量及其大小通过不相交集合并（Disjoint Set Union, DSU）（也称为并查集）进行维护，该结构采用按大小合并（或按秩合并）和路径压缩实现。每个分量的大小作为整数存储在其根节点上。\n\n假设以下标准事实成立：每次采用按大小合并（或按秩合并）和路径压缩的 DSU find 操作的均摊时间与反阿克曼函数 $\\alpha(N)$ 成正比，给定两个根标识符的 DSU union 操作在常数时间内运行，并且读取存储在根节点上的大小是常数时间操作。整数的算术运算和比较是常数时间操作。你可以假设这 $m$ 条候选边是独立处理的，即首先通过 DSU find 计算两个端点的根，然后读取分量大小，最后在常数时间内计算乘积规则得分。\n\n根据这些原语和定义，推导在所述实现中每个模拟步骤中 DSU find 操作的确切次数，并用它来获得每个步骤的主导阶均摊时间，表示为一个关于 $m$ 和 $\\alpha(N)$ 的闭式表达式，忽略来自合并操作、常数时间算术或比较的低阶加性贡献。此外，简要说明两个实现层面的优化，以确保在选择和合并过程中不执行冗余的 DSU 调用，从而达到推导出的界限。\n\n将你的最终答案表示为关于 $m$ 和 $\\alpha(N)$ 的单个闭式解析表达式。无需四舍五入。不涉及物理单位。",
            "solution": "问题陈述经评估是有效的。它在网络科学和算法分析这两个已建立的领域中有科学依据，特别是关于爆炸渗流模型和不相交集合并（DSU）数据结构。该问题是适定的、客观的且自洽的，提供了一套清晰的定义和计算成本假设，可以从中推导出唯一且有意义的解。不存在会妨碍严谨分析的矛盾、事实错误或模糊之处。\n\n任务是确定爆炸渗流模拟中每个步骤的主导阶均摊时间。单个步骤涉及从 $m$ 个候选项中选择一条边并将其添加到图中。分析的关键在于计算 DSU `find` 操作的次数，根据问题陈述，这是主导成本因素。一个步骤可以分为两个阶段：选择阶段和合并阶段。\n\n**1. DSU `find` 操作分析**\n\n**选择阶段：**\n在每个步骤中，会采样 $m$ 条候选边。对于每条候选边，记为 $\\{u, v\\}$，算法必须计算一个等于包含 $u$ 和 $v$ 的分量大小之积的得分，记为 $s_u s_v$。关键在于，选择规则只考虑连接两个不同分量的边。为了对单条边 $\\{u, v\\}$ 满足这些要求，需要以下子步骤：\n1.  确定包含顶点 $u$ 的分量的根。这通过一次 DSU 操作完成：`find(u)`。\n2.  确定包含顶点 $v$ 的分量的根。这通过第二次 DSU 操作完成：`find(v)`。\n3.  比较两个根。如果它们相同，则该边连接同一分量内的顶点，不予考虑选择。\n4.  如果根不同，则从每个根存储的数据中读取它们各自的分量大小 $s_u$ 和 $s_v$。问题陈述指出这是一个常数时间操作。然后计算得分 $s_u s_v$。\n\n问题明确指出“这 $m$ 条候选边是独立处理的，即首先通过 DSU find 计算两个端点的根”。这一指令意味着对 $m$ 个候选项进行直接循环，其中对每个候选项执行两次 `find` 操作。因此，在选择阶段执行的 `find` 操作总数恰好是 $2m$。\n\n**合并阶段：**\n在遍历所有 $m$ 个候选项后，得分最小且连接两个不同分量的那条边 $\\{u^*, v^*\\}$ 被选中。这条边随后必须被添加到图中，这对应于在 DSU 数据结构中合并两个分量。一个 `union(u, v)` 函数的朴素实现会在执行合并前内部调用 `find(u)` 和 `find(v)`，从而导致两次额外的 `find` 操作。\n\n然而，问题要求推导一种“不执行冗余的 DSU 调用”的实现的复杂度，并明确指出“给定两个根标识符的 DSU union 操作在常数时间内运行”。这指向一种优化实现，其中被选中边 $\\{u^*, v^*\\}$ 的根标识符（这些标识符在选择阶段已经计算并已知）被直接传递给合并函数。这样的 `union_by_root` 操作不需要任何 `find` 调用。因此，合并阶段贡献了 $0$ 次 DSU `find` 操作。\n\n**`find` 操作总数：**\n结合这两个阶段，在优化实现中每个模拟步骤中 DSU `find` 操作的确切总数是选择阶段和合并阶段的操作数之和：$2m + 0 = 2m$。\n\n**2. 主导阶均摊时间**\n\n问题给出，带有指定优化（按大小/秩合并和路径压缩）的 DSU `find` 操作的均摊时间与反阿克曼函数 $\\alpha(N)$ 成正比。设单次 `find` 操作的时间为 $T_{\\text{find}} = c \\cdot \\alpha(N)$，其中 $c$ 是一个比例常数。\n\n每个步骤的总均摊时间由 $2m$ 次 `find` 操作主导。其他操作，如常数时间的合并操作、算术运算和比较，贡献了低阶加性项。按照问题的指示忽略这些项，每个步骤的主导阶均摊时间 $T_{\\text{step}}$ 为：\n$$T_{\\text{step}} \\propto 2m \\cdot T_{\\text{find}}$$\n$$T_{\\text{step}} \\propto 2m \\cdot \\alpha(N)$$\n最终表达式应以 $m$ 和 $\\alpha(N)$ 表示，因此我们可以将主导阶时间写为 $2m \\alpha(N)$。\n\n**3. 优化理由**\n\n推导出的 $2m$ 次 `find` 操作计数和相应的时间复杂度是通过消除冗余计算的特定实现选择来实现的。一个完全朴素的实现会执行 $2m+2$ 次 `find` 操作。将其减少到 $2m$ 的两个关键优化是：\n\n1.  **缓存获胜边的根：** 在选择循环期间，当评估每个候选边 $\\{u,v\\}$ 时，会计算其根 `root_u` 和 `root_v`。当一条边被确定为目前得分最低时，必须将其根标识符（`root_u`, `root_v`）与顶点标识符一起缓存。仅仅存储 $\\{u, v\\}$ 将需要在之后重新计算根。\n2.  **使用基于根的合并函数：** 选择循环结束后，必须使用一个函数变体，例如 `union_by_root(root_u, root_v)`，来执行合并操作，该函数接受预先计算并缓存的获胜边的根标识符。这直接利用了问题陈述的原语，即“给定两个根标识符的 union 操作在常数时间内运行”，并避免了通用 `union(u, v)` 函数会隐式进行的两次冗余 `find` 调用。\n\n这两个优化确保了合并阶段不会在选择阶段所需的 $2m$ 次操作之外增加任何 `find` 操作，从而达到推导出的界限。",
            "answer": "$$\\boxed{2m\\alpha(N)}$$"
        },
        {
            "introduction": "从模拟数据中提取普适的标度律是连接经验观察和理论物理的桥梁。在你的模拟中观察到逾渗转变的“爆炸性”跳跃后，科学的下一步是建立一个模型来解释和预测其量级。这项练习提供了一个关于临界前团簇尺寸分布的唯象模型，并要求你运用极值统计理论来推导最大跳跃尺寸随系统规模变化的标度关系。这个过程完美地展示了统计物理学家如何利用强大的数学工具，从看似复杂的现象中揭示简洁而深刻的物理规律。",
            "id": "4275815",
            "problem": "考虑一个在具有 $N$ 个节点的 Erdős–Rényi 随机图上的 Achlioptas 过程 (AP)，在该过程中，每一步都会均匀随机地选择两条候选边，并使用乘积法则来添加那条能够最小化将被连接的团簇大小之乘积的边。令 $S_1(t)$ 表示添加了 $t$ 条边后最大连通团簇的大小，并令 $\\Delta S_1$ 表示在整个演化过程中 $S_1(t)$ 的最大单边跳跃。\n\n在宏观团簇即将出现的亚临界区，假设由于乘积法则抑制了大团簇的合并，以下唯象描述成立：\n- 团簇数量为 $M(N) = \\rho N$，其中密度 $\\rho  0$ 为一个有限常数。\n- 团簇大小的分布具有一个拉伸指数上尾，其特征为\n$$\n\\mathbb{P}\\{S \\ge s\\} \\approx \\exp\\!\\left[-\\left(\\frac{s}{s_c(N)}\\right)^{\\delta}\\right],\n$$\n其中尾形参数 $\\delta  0$，有限尺寸截断尺度 $s_c(N)$ 按如下方式次线性增长\n$$\ns_c(N) = a\\, N^{\\chi},\n$$\n其中 $a  0$ 和 $0  \\chi  1$ 是由亚临界区的乘积法则动力学决定的常数。\n\n在 $M(N)$ 个团簇的独立性近似下，使用极值统计对最大的亚临界团簇进行建模。此外，假设最大跳跃 $\\Delta S_1$ 的主要贡献来自于两个最大的亚临界团簇的合并，因此该增量的大小与第二大亚临界团簇的大小处于同一量级。\n\n仅使用上述基础和近似，推导最大相对跳跃 $\\Delta S_1/N$ 作为 $N$ 的函数的前导阶标度。忽略所有乘法常数和次导修正项，并将最终答案表示为仅包含 $N$、$\\chi$ 和 $\\delta$ 的单个闭式解析表达式。最终表达式中不得出现其他参数。答案必须是一个不带等号或不等号的表达式。",
            "solution": "用户希望确定在使用乘积法则的 Achlioptas 过程中，最大团簇大小的最大相对跳跃 $\\Delta S_1 / N$ 的前导阶标度。推导将基于所提供的亚临界区唯象描述以及极值统计的应用。\n\n### 第1步：问题验证\n\n**1.1. 提取已知条件：**\n*   **系统：** 在具有 $N$ 个节点的图上的 Achlioptas 过程 (AP)。\n*   **选择法则：** 乘积法则。\n*   **可观测量：** $\\Delta S_1$，最大团簇大小 $S_1(t)$ 的最大单边跳跃。\n*   **亚临界区假设：**\n    *   团簇数量：$M(N) = \\rho N$，其中 $\\rho  0$ 是一个常数。\n    *   团簇大小分布上尾：$\\mathbb{P}\\{S \\ge s\\} \\approx \\exp\\left[-\\left(\\frac{s}{s_c(N)}\\right)^{\\delta}\\right]$，其中 $\\delta  0$。\n    *   截断尺度：$s_c(N) = a N^{\\chi}$，其中 $a  0$ 且 $0  \\chi  1$。\n*   **建模近似：**\n    *   极值统计适用于 $M(N)$ 个团簇。\n    *   $M(N)$ 个团簇的大小被视为独立的随机变量。\n    *   最大跳跃 $\\Delta S_1$ 由两个最大的亚临界团簇的合并主导，其量级与第二大亚临界团簇的大小相当，我们将其记为 $S_{(2)}$。\n*   **目标：**\n    *   推导最大相对跳跃 $\\Delta S_1 / N$ 作为 $N$、$\\chi$ 和 $\\delta$ 的函数的前导阶标度。\n    *   忽略乘法常数和次导修正项。\n\n**1.2. 使用提取的已知条件进行验证：**\n*   **科学基础：** 该问题设置在爆炸性逾渗的既定框架内，这是网络科学和统计物理学中的一个主题。Achlioptas 过程、乘积法则以及团簇大小分布的拉伸指数形式是关于此主题的文献中的标准元素。使用极值理论是分析统计系综中最大元素的常规且适当的方法。该问题在科学上是合理的。\n*   **适定性：** 该问题提供了一套清晰且充分的假设，以推导所要求的标度律。目标明确，并且可以预期得到一个关于前导阶标度的唯一解。\n*   **客观性：** 该问题使用理论物理和数学中常见的精确、形式化的语言来表述，没有任何主观或模棱两可的术语。\n\n**1.3. 结论：**\n该问题是有效的。它具有科学依据、适定且客观。对于既定任务，没有矛盾、信息缺失或其他可辨别的缺陷。可以继续进行求解过程。\n\n### 第2步：标度律的推导\n\n问题的核心是确定最大相对跳跃 $\\frac{\\Delta S_1}{N}$ 的标度。根据指示，我们假设此跳跃的量级 $\\Delta S_1$ 与亚临界区中第二大团簇的大小 $S_{(2)}$ 处于同一量级。\n$$\n\\Delta S_1 \\sim S_{(2)}\n$$\n因此，我们的任务简化为找到 $S_{(2)}$ 随系统大小 $N$ 变化的特征标度。\n\n我们需要使用极值统计来对团簇大小进行建模。我们有 $M(N)$ 个团簇，其大小被视为从具有指定上尾的分布中抽取的独立同分布随机变量。极值理论的一个标准结果表明，在一个大小为 $M$ 的样本中，第 $k$ 大值的典型大小由值 $s_k$ 给出，该值满足大于或等于 $s_k$ 的样本期望数约为 $k$ 量级的条件。形式上，对于第二大团簇（$k=2$），我们通过以下关系设定其特征大小 $S_{(2)}$：\n$$\nM(N) \\mathbb{P}\\{S \\ge S_{(2)}\\} \\approx 2\n$$\n右侧的常数 2 对于前导阶标度而言并不关键，因为任何单位量级的常数都会产生相同的结果。\n\n我们将给定的团簇数量表达式 $M(N) = \\rho N$ 和尾部概率表达式 $\\mathbb{P}\\{S \\ge s\\} \\approx \\exp\\left[-\\left(\\frac{s}{s_c(N)}\\right)^{\\delta}\\right]$ 代入此关系中：\n$$\n(\\rho N) \\exp\\left[-\\left(\\frac{S_{(2)}}{s_c(N)}\\right)^{\\delta}\\right] \\approx 2\n$$\n我们的目标是解出此方程中的 $S_{(2)}$。我们首先分离指数项：\n$$\n\\exp\\left[-\\left(\\frac{S_{(2)}}{s_c(N)}\\right)^{\\delta}\\right] \\approx \\frac{2}{\\rho N}\n$$\n对两边取自然对数，得到：\n$$\n-\\left(\\frac{S_{(2)}}{s_c(N)}\\right)^{\\delta} \\approx \\ln\\left(\\frac{2}{\\rho N}\\right) = \\ln(2) - \\ln(\\rho) - \\ln(N)\n$$\n对于大的 $N$，$\\ln(N)$ 项是右侧的主导项。$\\ln(2)$ 和 $\\ln(\\rho)$ 项是常数，因此构成次导修正项。由于我们只对前导阶标度感兴趣，我们可以做如下近似：\n$$\n-\\left(\\frac{S_{(2)}}{s_c(N)}\\right)^{\\delta} \\sim -\\ln(N)\n$$\n这可以简化为：\n$$\n\\left(\\frac{S_{(2)}}{s_c(N)}\\right)^{\\delta} \\sim \\ln(N)\n$$\n现在我们求解 $S_{(2)}$：\n$$\n\\frac{S_{(2)}}{s_c(N)} \\sim (\\ln(N))^{\\frac{1}{\\delta}}\n$$\n$$\nS_{(2)} \\sim s_c(N) (\\ln(N))^{\\frac{1}{\\delta}}\n$$\n接下来，我们代入给定的截断尺度标度 $s_c(N) = a N^{\\chi}$。再次根据问题指示，我们忽略乘法常数 $a$。\n$$\nS_{(2)} \\sim N^{\\chi} (\\ln(N))^{\\frac{1}{\\delta}}\n$$\n由于 $\\Delta S_1 \\sim S_{(2)}$，我们有：\n$$\n\\Delta S_1 \\sim N^{\\chi} (\\ln(N))^{\\frac{1}{\\delta}}\n$$\n最后一步是找到*相对*跳跃 $\\frac{\\Delta S_1}{N}$ 的标度：\n$$\n\\frac{\\Delta S_1}{N} \\sim \\frac{N^{\\chi} (\\ln(N))^{\\frac{1}{\\delta}}}{N}\n$$\n使用指数定律 $\\frac{N^x}{N^y} = N^{x-y}$，我们得到最终的标度表达式：\n$$\n\\frac{\\Delta S_1}{N} \\sim N^{\\chi - 1} (\\ln(N))^{\\frac{1}{\\delta}}\n$$\n该表达式按要求给出了最大相对跳跃作为 $N$、$\\chi$ 和 $\\delta$ 函数的前导阶标度。由于 $0  \\chi  1$，指数 $\\chi - 1$ 为负，这确保了相对跳跃大小在热力学极限 $N \\to \\infty$ 下趋于零，这与一个连续（尽管是急剧的）相变是一致的。",
            "answer": "$$\n\\boxed{N^{\\chi - 1} (\\ln(N))^{\\frac{1}{\\delta}}}\n$$"
        }
    ]
}