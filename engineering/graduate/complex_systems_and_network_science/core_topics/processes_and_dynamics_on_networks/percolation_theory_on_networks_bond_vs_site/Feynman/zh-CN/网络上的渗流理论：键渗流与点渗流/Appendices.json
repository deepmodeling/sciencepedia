{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导您从第一性原理出发，推导随机网络上的渗流阈值。您将不再仅仅应用已知公式，而是运用来自统计物理学的强大工具——空穴方法（cavity method）——来建立临界条件 。这项练习对于深刻理解巨连通分支的出现为何由非回溯矩阵（non-backtracking matrix）的谱性质决定，以及它如何与度分布的矩（moments）联系起来，是至关重要的一步。",
            "id": "4296412",
            "problem": "考虑一个由配置模型生成的大型、稀疏、无向网络上的逾渗过程，该网络具有度分布 $P(k)$，并在热力学极限下是局部树状的。定义了两种逾渗过程：边逾渗（每条边以概率 $p$ 独立保留）和点逾渗（每个节点以概率 $q$ 独立保留，若节点被移除，则其所有邻接边均被移除）。需要通过在网络的有向边表示上进行消息传递，并使用忽略回溯环路的空腔方法，来分析巨连通分量 (GCC) 的出现。\n\n仅从边逾渗和点逾渗的定义、巨连通分量 (GCC) 的概念，以及代表沿有向边不会导向 GCC 的概率的有向边消息的构造出发，推导对应于一般图上不存在 GCC 的平凡不动点的线性化稳定性条件。识别主导线性化消息动力学的算子，并用其谱半径表示 GCC 出现的临界参数。\n\n然后，将您的结果特化到局部树状的配置模型网络，并将相关的谱半径与平均剩余度联系起来，该平均剩余度用度分布 $P(k)$ 的前两阶矩 $\\langle k \\rangle$ 和 $\\langle k^{2} \\rangle$ 表示。\n\n最后，计算给定度分布下的边逾渗和点逾渗阈值\n$$\nP(k) = \\frac{1}{2}\\,\\delta_{k,1} + \\frac{1}{2}\\,\\delta_{k,3},\n$$\n其中 $\\delta_{i,j}$ 是克罗内克δ函数，从而得出临界边占据概率 $p_{c}$ 和临界点占据概率 $q_{c}$ 的明确值。\n\n将您的最终结果表示为最简精确分数。将最终答案表示为一个包含 $p_c$ 和 $q_c$（按此顺序）的行矩阵。无需单位，也无需四舍五入。",
            "solution": "本问题要求推导配置模型网络上的边逾渗和点逾渗的逾渗阈值。解题过程将分三个阶段进行：首先，使用消息传递方法在一般图上推导巨连通分量 (GCC) 出现的通用框架；其次，通过将临界条件与度分布的矩相关联，将此框架特化到配置模型网络；第三，计算给定度分布的具体阈值。\n\n让我们首先为一般的大型、稀疏、无向网络建立消息传递框架。我们分析对应于不存在 GCC 的平凡不动点的稳定性。当此不动点变得不稳定时，GCC 就会出现。该方法依赖于空腔方法，此方法假定网络是局部树状的，这使得它在热力学极限下对配置模型网络是精确的。\n\n设每个无向边 $\\{i, j\\}$ 对应一组有向边 $(i, j)$。从节点 $i$ 传递到邻居 $j$ 的消息量化了在“空腔图”中某个事件发生的概率，即在移除了涉及节点 $i$ 的连接（或仅是边 $(i,j)$）的原始图中。\n\n**第 1 部分：通过消息传递进行一般性推导**\n\n**边逾渗**\n\n在边逾渗中，每条边独立地以概率 $p$ 存在。令 $u_{i \\to j}$ 为沿着有向边 $i \\to j$ **不**会导向 GCC 的概率。该事件发生，要么是因为边 $\\{i,j\\}$ 不存在（概率为 $1-p$），要么是因为边存在（概率为 $p$）但节点 $j$ 未能通过其任何其他邻居 $k \\in \\mathcal{N}(j) \\setminus \\{i\\}$ 连接到 GCC。在空腔/树状近似下，从 $j$ 出发到其其他邻居的路径是独立的。根据定义，$j$ 到邻居 $k$ 的路径未能到达 GCC 的概率是 $u_{j \\to k}$。\n\n因此，消息的自洽方程为：\n$$\nu_{i \\to j} = (1 - p) + p \\prod_{k \\in \\mathcal{N}(j) \\setminus \\{i\\}} u_{j \\to k}\n$$\n不存在 GCC 对应于平凡不动点，即对所有有向边 $(i,j)$ 都有 $u_{i \\to j} = 1$。让我们验证这一点：$1 = (1-p) + p \\prod 1 = 1-p+p = 1$。为了分析此不动点的稳定性，我们在此不动点周围对该方程进行线性化。令 $u_{i \\to j} = 1 - \\epsilon_{i \\to j}$，其中 $\\epsilon_{i \\to j}$ 是一个小的正微扰。将此代入方程得到：\n$$\n1 - \\epsilon_{i \\to j} = (1 - p) + p \\prod_{k \\in \\mathcal{N}(j) \\setminus \\{i\\}} (1 - \\epsilon_{j \\to k})\n$$\n对于小的 $\\epsilon$，我们可以将乘积展开到一阶：$\\prod (1 - \\epsilon_k) \\approx 1 - \\sum \\epsilon_k$。\n$$\n1 - \\epsilon_{i \\to j} \\approx (1 - p) + p \\left(1 - \\sum_{k \\in \\mathcal{N}(j) \\setminus \\{i\\}} \\epsilon_{j \\to k}\\right)\n$$\n$$\n1 - \\epsilon_{i \\to j} \\approx 1 - p + p - p \\sum_{k \\in \\mathcal{N}(j) \\setminus \\{i\\}} \\epsilon_{j \\to k}\n$$\n这简化为微扰的线性化动力学方程：\n$$\n\\epsilon_{i \\to j} = p \\sum_{k \\in \\mathcal{N}(j) \\setminus \\{i\\}} \\epsilon_{j \\to k}\n$$\n\n**点逾渗**\n\n在点逾渗中，每个节点独立地以概率 $q$ 存在。如果一个节点被移除，其所有邻接边也会被移除。令 $v_{i \\to j}$ 为从邻居 $i$ 的角度看（即在移除了 $i$ 的空腔图中），节点 $j$ **不**属于 GCC 的概率。此事件发生，要么是因为节点 $j$ 不存在（概率为 $1-q$），要么是因为节点 $j$ 存在（概率为 $q$）但它未能通过其任何其他邻居 $k \\in \\mathcal{N}(j) \\setminus \\{i\\}$ 连接到 GCC。\n\n因此，自洽方程为：\n$$\nv_{i \\to j} = (1 - q) + q \\prod_{k \\in \\mathcal{N}(j) \\setminus \\{i\\}} v_{j \\to k}\n$$\n此方程在数学上与边逾渗的方程同构。平凡不动点是 $v_{i \\to j} = 1$。通过设 $v_{i \\to j} = 1 - \\delta_{i \\to j}$ 在此不动点周围进行线性化，得到：\n$$\n\\delta_{i \\to j} = q \\sum_{k \\in \\mathcal{N}(j) \\setminus \\{i\\}} \\delta_{j \\to k}\n$$\n\n**线性化动力学与临界条件**\n\n两个线性化方程都可以用图的非回溯矩阵 $\\mathbf{B}$ 这一线性算子来表示。算子 $\\mathbf{B}$ 作用于定义在有向边集合上的函数。其作用由下式给出：\n$$\n(\\mathbf{B} f)(i \\to j) = \\sum_{k \\in \\mathcal{N}(j) \\setminus \\{i\\}} f(j \\to k)\n$$\n微扰向量 $\\vec{\\epsilon}$ 和 $\\vec{\\delta}$ 的线性化动力学可以分别写为 $\\vec{\\epsilon}^{(t+1)} = p \\mathbf{B} \\vec{\\epsilon}^{(t)}$ 和 $\\vec{\\delta}^{(t+1)} = q \\mathbf{B} \\vec{\\delta}^{(t)}$。当相应线性算子的最大特征值（谱半径 $\\rho$）大于 1 时，平凡不动点（无 GCC）变得不稳定。\n对于边逾渗，算子是 $\\mathbf{T}_{\\text{bond}} = p\\mathbf{B}$。临界条件是 $\\rho(\\mathbf{T}_{\\text{bond}}) = p_c \\rho(\\mathbf{B}) = 1$。\n对于点逾渗，算子是 $\\mathbf{T}_{\\text{site}} = q\\mathbf{B}$。临界条件是 $\\rho(\\mathbf{T}_{\\text{site}}) = q_c \\rho(\\mathbf{B}) = 1$。\n由此可得临界阈值与非回溯矩阵谱半径的关系：\n$$\np_c = \\frac{1}{\\rho(\\mathbf{B})} \\quad \\text{和} \\quad q_c = \\frac{1}{\\rho(\\mathbf{B})}\n$$\n\n**第 2 部分：特化到配置模型网络**\n\n对于由具有度分布 $P(k)$ 的配置模型生成的大型随机图，局部树状假设是精确的。在此极限下，非回溯矩阵的谱半径 $\\rho(\\mathbf{B})$ 等于网络的平均超额度。\n\n一个节点的超额度是其度减一；它是节点上除了我们到达该节点所用的边之外的边数。为了找到平均超额度，我们考虑遍历一条随机边。这条边导向一个度为 $k$ 的节点的概率不是 $P(k)$，而是与 $kP(k)$ 成正比。随机选择一条边的末端节点的度数的归一化分布是 $\\frac{kP(k)}{\\langle k \\rangle}$，其中 $\\langle k \\rangle = \\sum_k k P(k)$ 是平均度。\n\n一个度为 $k$ 的节点有 $k-1$ 条出边（超额度）。平均超额度是 $k-1$ 在此分布下的平均值：\n$$\n\\rho(\\mathbf{B}) = \\sum_{k} (k-1) \\frac{k P(k)}{\\langle k \\rangle} = \\frac{1}{\\langle k \\rangle} \\sum_{k} (k^2 - k) P(k)\n$$\n使用矩的定义 $\\langle f(k) \\rangle = \\sum_k f(k) P(k)$，我们可以将其写为：\n$$\n\\rho(\\mathbf{B}) = \\frac{\\langle k^2 \\rangle - \\langle k \\rangle}{\\langle k \\rangle}\n$$\n其中 $\\langle k^2 \\rangle = \\sum_k k^2 P(k)$ 是度分布的二阶矩。\n\n将此 $\\rho(\\mathbf{B})$ 的表达式代入我们的临界条件，得到配置模型的逾渗阈值：\n$$\np_c = \\frac{\\langle k \\rangle}{\\langle k^2 \\rangle - \\langle k \\rangle}\n$$\n$$\nq_c = \\frac{\\langle k \\rangle}{\\langle k^2 \\rangle - \\langle k \\rangle}\n$$\n这就是著名的 Molloy-Reed 巨分量出现判据。\n\n**第 3 部分：针对特定度分布的计算**\n\n我们给定的度分布是 $P(k) = \\frac{1}{2}\\,\\delta_{k,1} + \\frac{1}{2}\\,\\delta_{k,3}$。这描述了一个网络，其中一半节点的度为 1，另一半节点的度为 3。\n\n首先，我们计算一阶矩（平均度）$\\langle k \\rangle$：\n$$\n\\langle k \\rangle = \\sum_{k} k P(k) = (1) \\cdot P(1) + (3) \\cdot P(3) = (1)\\left(\\frac{1}{2}\\right) + (3)\\left(\\frac{1}{2}\\right) = \\frac{1}{2} + \\frac{3}{2} = \\frac{4}{2} = 2\n$$\n接下来，我们计算二阶矩 $\\langle k^2 \\rangle$：\n$$\n\\langle k^2 \\rangle = \\sum_{k} k^2 P(k) = (1^2) \\cdot P(1) + (3^2) \\cdot P(3) = (1)\\left(\\frac{1}{2}\\right) + (9)\\left(\\frac{1}{2}\\right) = \\frac{1}{2} + \\frac{9}{2} = \\frac{10}{2} = 5\n$$\n现在我们可以计算 $\\langle k^2 \\rangle - \\langle k \\rangle$ 的值：\n$$\n\\langle k^2 \\rangle - \\langle k \\rangle = 5 - 2 = 3\n$$\n最后，我们将这些值代入临界阈值 $p_c$ 和 $q_c$ 的公式中：\n$$\np_c = \\frac{\\langle k \\rangle}{\\langle k^2 \\rangle - \\langle k \\rangle} = \\frac{2}{3}\n$$\n$$\nq_c = \\frac{\\langle k \\rangle}{\\langle k^2 \\rangle - \\langle k \\rangle} = \\frac{2}{3}\n$$\n对于该网络系综，边逾渗和点逾渗阈值是相同的，均为 $\\frac{2}{3}$。最终答案应以包含 $p_c$ 和 $q_c$ 的行矩阵形式给出。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{2}{3}  \\frac{2}{3} \\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了基础理论之后，本问题将带您探索一个更细致的场景，以突显不同渗流过程之间的差异。您将分析一个节点保留概率依赖于其度的网络，并将其与标准的键渗流进行比较 。这项练习旨在锻炼您将分支过程理论应用于非均匀渗流规则的能力，并揭示微观细节如何影响宏观的临界行为。",
            "id": "4296414",
            "problem": "考虑一个大型配置模型网络，其度分布仅在两个度上取值：一个节点的度为 $k=1$ 的概率为 $a \\in (0,1)$，度为 $k=4$ 的概率为 $1-a$。设度分布的概率生成函数 (PGF) 为 $G_{0}(x)$，剩余度分布的 PGF 为 $G_{1}(x)$。假设在热力学极限下，网络具有局部树状性质。\n\n考虑两个独立的渗流过程：\n- 键渗流：每条边以概率 $p \\in [0,1]$ 被独立地保留。\n- 具有度依赖保留概率的点渗流：每个度为 $k$ 的节点以概率 $q_{k}$ 被独立地保留，其中 $q_{1}=q$ 且 $q_{4}=t\\,q$，参数 $t \\in (0,1]$ 且 $q \\in [0,1]$。被保留的节点通过在原始配置模型中连接它们的所有边保持连接。\n\n仅使用配置模型的核心定义、PGF $G_{0}(x)$ 和 $G_{1}(x)$，以及巨片出现的分支过程解释，推导该网络上键渗流的临界占据概率 $p_{c}$ 和上述度依赖点渗流的临界占据概率 $q_{c}$，并用 $a$ 和 $t$（在适用时）表示。然后，对于参数值 $a=\\frac{1}{2}$ 和 $t=\\frac{1}{2}$，计算比值 $\\rho \\equiv \\frac{q_{c}}{p_{c}}$。请以单个实数的形式给出 $\\rho$ 的最终值。无需四舍五入。",
            "solution": "首先验证问题的科学合理性、良定性和客观性。\n\n### 步骤1：提取已知条件\n-   **网络模型**：大型配置模型网络。\n-   **度分布**：节点度为 $k=1$ 的概率为 $a$，度为 $k=4$ 的概率为 $1-a$。$a \\in (0,1)$。概率生成函数 (PGF) 为 $G_0(x)$。\n-   **剩余度分布PGF**：$G_1(x)$。\n-   **假设**：网络是局部树状的。\n-   **过程1：键渗流**：每条边以概率 $p \\in [0,1]$ 独立地保留。\n-   **过程2：点渗流**：节点以度依赖的概率 $q_k$ 保留。\n    -   对于度为 $k=1$ 的节点，保留概率为 $q_1=q$。\n    -   对于度为 $k=4$ 的节点，保留概率为 $q_4=tq$。\n    -   参数：$q \\in [0,1]$ 且 $t \\in (0,1]$。\n-   **任务**：\n    1.  推导键渗流的临界概率 $p_c$。\n    2.  推导点渗流的临界概率 $q_c$。\n    3.  在 $a=\\frac{1}{2}$ 和 $t=\\frac{1}{2}$ 的特定情况下，计算比值 $\\rho = \\frac{q_c}{p_c}$。\n\n### 步骤2：使用提取的已知条件进行验证\n-   **科学依据**：该问题利用了复杂网络上渗流理论的既定原理，包括配置模型、概率生成函数 (PGF) 以及用于确定巨片出现的分支过程形式化方法。这些概念在统计物理和网络科学中是标准内容。\n-   **良定性**：该问题提供了推导临界概率 $p_c$ 和 $q_c$ 的唯一解析表达式所需的所有必要信息和定义。目标明确，并且在理论框架内保证了解的存在性。\n-   **客观性**：该问题使用精确的数学和科学语言陈述，没有歧义、主观性或观点。\n\n### 步骤3：结论与行动\n该问题被认为是**有效的**，因为它是科学合理的、良定的和客观的。我现在将继续进行解答。\n\n### 临界概率的推导\n\n网络中的度分布由 $P(k) = a\\delta_{k,1} + (1-a)\\delta_{k,4}$ 给出，其中 $\\delta_{i,j}$ 是克罗内克（Kronecker）δ函数。\n\n度分布的概率生成函数 (PGF) $G_0(x)$ 为：\n$$\nG_0(x) = \\sum_{k} P(k)x^k = a x^1 + (1-a)x^4\n$$\n平均度 $\\langle k \\rangle$ 可由 $G_0(x)$ 的一阶导数在 $x=1$ 处的值得到：\n$$\nG_0'(x) = a + 4(1-a)x^3\n$$\n$$\n\\langle k \\rangle = G_0'(1) = a + 4(1-a) = 4-3a\n$$\n剩余度分布的 PGF $G_1(x)$ 给出的是沿着一条随机边到达的节点所连接的其他边的数量分布，其表达式为：\n$$\nG_1(x) = \\frac{G_0'(x)}{G_0'(1)} = \\frac{a + 4(1-a)x^3}{4-3a}\n$$\n巨片的出现可以看作一个分支过程来分析。巨片存在的判据是分支过程第二代后代的期望数量必须大于1。临界点是该期望值等于1的地方。\n\n**1. 键渗流**\n\n在键渗流中，每条边以概率 $p$ 存在。渗流后网络的剩余度分布的 PGF $G_1^{(p)}(x)$，是通过将 $G_1(x)$ 与单条边被保留的 PGF（即 $(1-p) + px$）进行复合得到的。\n$$\nG_1^{(p)}(x) = G_1(1-p+px)\n$$\n后代的期望数量是该 PGF 在 $x=1$ 处的导数：\n$$\n\\frac{d}{dx}G_1^{(p)}(x) \\bigg|_{x=1} = G_1'(1-p+px) \\cdot p \\bigg|_{x=1} = p G_1'(1)\n$$\n临界条件是 $p_c G_1'(1) = 1$。我们需要计算 $G_1'(1)$：\n$$\nG_1'(x) = \\frac{d}{dx}\\left(\\frac{a + 4(1-a)x^3}{4-3a}\\right) = \\frac{12(1-a)x^2}{4-3a}\n$$\n$$\nG_1'(1) = \\frac{12(1-a)}{4-3a}\n$$\n这个量也即是 $\\frac{\\langle k(k-1) \\rangle}{\\langle k \\rangle}$。\n临界键渗流概率 $p_c$ 是：\n$$\np_c = \\frac{1}{G_1'(1)} = \\frac{4-3a}{12(1-a)}\n$$\n\n**2. 点渗流**\n\n对于点渗流，我们沿着网络追踪一条路径。从一个被占据的节点开始，我们沿着一条随机边前进。为了使团簇增长，另一端的节点也必须是被占据的。在临界状态下，从这样一个新到达的被占据节点分支出去的新路径的期望数量必须为1。\n\n一条随机选择的边通向一个度为 $k$ 的节点的概率是 $\\frac{kP(k)}{\\langle k \\rangle}$。该节点被占据的概率是 $q_k$。如果被占据，它将提供 $k-1$ 条新的边以供探索。因此，新分支的期望数量是：\n$$\n\\sum_k \\frac{kP(k)}{\\langle k \\rangle} q_k (k-1) = \\frac{1}{\\langle k \\rangle} \\sum_k k(k-1)P(k)q_k\n$$\n在临界点，这个期望值等于1，且占据概率为 $q_1 = q_c$ 和 $q_4 = tq_c$。\n$$\n\\frac{1}{\\langle k \\rangle} \\sum_k k(k-1)P(k)q_{k,c} = 1\n$$\n我们来计算给定分布下的这个和：\n$$\n\\sum_k k(k-1)P(k)q_{k,c} = 1(1-1)P(1)q_{1,c} + 4(4-1)P(4)q_{4,c}\n$$\n$$\n= 0 \\cdot a \\cdot q_c + 12 \\cdot (1-a) \\cdot (tq_c) = 12(1-a)tq_c\n$$\n将此代入临界条件：\n$$\n\\frac{12(1-a)tq_c}{4-3a} = 1\n$$\n求解临界点占据概率 $q_c$：\n$$\nq_c = \\frac{4-3a}{12t(1-a)}\n$$\n\n**3. 比值计算**\n\n我们需要计算比值 $\\rho = \\frac{q_c}{p_c}$。\n$$\n\\rho = \\frac{q_c}{p_c} = \\frac{\\frac{4-3a}{12t(1-a)}}{\\frac{4-3a}{12(1-a)}}\n$$\n公因式 $\\frac{4-3a}{12(1-a)}$ 被约去，从而得到一个简单的比值表达式：\n$$\n\\rho = \\frac{1}{t}\n$$\n值得注意的是，该比值与参数 $a$ 无关。这是因为度为 $k=1$ 的节点有一个因子 $k(k-1)=0$，因此它们对通过剩余度分布上的分支过程来确定临界性的求和没有贡献。\n\n问题要求在参数 $a=\\frac{1}{2}$ 和 $t=\\frac{1}{2}$ 下 $\\rho$ 的值。计算该比值不需要 $a$ 的值。\n$$\n\\rho = \\frac{1}{t} = \\frac{1}{\\frac{1}{2}} = 2\n$$\n比值的最终值为 2。",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "本练习通过一个动手计算模拟，架起了从抽象的渗流理论到具体物理测量的桥梁。您将把渗流团簇建模为一个随机电阻网络，并数值计算其等效电导率 。通过分析电导率在临界阈值附近如何标度（scaling），您将估算一个普适的临界指数（critical exponent），这是相变理论中的一个核心概念，它将渗流现象与广泛的物理世界联系起来。",
            "id": "3171738",
            "problem": "您将编写一个完整、可运行的程序，通过将逾渗问题映射到一个随机电阻网络来估计二维键逾渗的电导临界指数 $t$。在该网络中，每个被占据的键的电导为 $g=1$，而每个未被占据的键则不存在。该估计必须通过计算方形晶格在逾渗阈值 $p_c$ 附近、位于两个相对侧之间的等效体电导率 $\\sigma(p)$，然后对 $p>p_c$ 的标度关系 $\\sigma(p)\\propto (p-p_c)^t$ 进行拟合来完成。\n\n基本原理与假设。使用以下基础且经过充分检验的原理：\n- 欧姆定律描述了流经一个电导为 $g$ 的电阻器的电流 $I$ 与电压差 $\\Delta V$ 之间的关系：$I=g\\,\\Delta V$。\n- 基尔霍夫电流定律指出，对于电阻网络的任何内部节点，当系统处于稳态时，离开该节点的电流的代数和为 $0$。\n- 在固定边界电压下，网络解可通过求解从基尔霍夫电流定律和欧姆定律推导出的离散泊松方程（带有狄利克雷边界条件的图拉普拉斯算子）得到。\n- 对于无限方形晶格上的键逾渗，其键逾渗阈值为 $p_c=\\tfrac{1}{2}$（这是一个精确已知且被广泛接受的事实）。\n\n定义与数值设置。考虑一个 $L\\times L$ 的方形节点晶格，其中键仅存在于最近邻（水平和垂直）之间。每个可能的键以概率 $p\\in(0,1)$ 独立地被占据，每个被占据的键被赋予电导 $g=1$，而未被占据的键则不存在。在左边界（列索引 $x=0$）的所有节点上施加狄利克雷边界条件 $V=1$，在右边界（列索引 $x=L-1$）的所有节点上施加 $V=0$。顶部和底部边界（行索引 $y=0$ 和 $y=L-1$）是电学自由的（无固定电势）。对于任何一次实现，等效电导率 $\\sigma(p)$ 定义为在施加的单位电压降 $\\Delta V=1$ 下注入左边界的总净电流，这等于左右边界之间的等效两端电导（以任意单位计）。\n\n为确保数值可解性，任何未连接到左边界或右边界的内部节点连通分量都应从线性系统中排除，因为在狄利克雷边界条件下，其电势是未确定的。实际上，您必须将求解限制在通过被占据的键连接到至少一个狄利克雷边界的内部节点集合上。\n\n$t$ 指数的估计方法。对于每个测试用例，您将：\n- 对于给定的一组大于 $p_c$ 的 $p$ 值，为每个 $p$ 生成多个独立的网络实现，并计算每个实现的等效电导率 $\\sigma(p)$，然后取其样本均值 $\\overline{\\sigma}(p)$。\n- 仅使用那些 $\\overline{\\sigma}(p)>0$ 的 $p$ 值，通过普通最小二乘法（未加权）对线性关系 $\\log \\overline{\\sigma}(p)=t\\log(p-p_c)+C$（作为 $\\log(p-p_c)$ 的函数）进行拟合，以估计 $t$。对数可以是任意底数；为明确起见，请使用自然对数。\n- 如果 $\\overline{\\sigma}(p)>0$ 的不同 $p$ 值少于 $2$ 个，则该测试用例返回哨兵值 $-1.0$。\n\n程序必须遵循的实现细节：\n- 在至少连接到一个狄利克雷边界的内部节点集上构建图拉普拉斯算子。对于一个内部节点 $i$，其对角线元素等于到其被占据邻居的电导之和，而非对角线元素对于连接到其他内部节点的被占据键等于 $-g$。右侧项 $b$ 的贡献来自连接到具有固定电压的边界节点的被占据键（$+gV_{\\text{boundary}}$）。\n- 求解稀疏线性系统 $A\\mathbf{v}=\\mathbf{b}$ 以获得内部节点电压 $\\mathbf{v}$；然后计算注入左边界的净电流，即对每个连接左边界节点与其最近内部邻居的被占据键，求和 $g\\,(1-V_{\\text{neighbor}})$。\n- 对每个被占据的键使用 $g=1$，对未被占据的键使用 $g=0$。\n- 使用逾渗阈值 $p_c=\\tfrac{1}{2}$。\n- 使用具有受控种子的伪随机数生成器以确保可复现性。对于测试用例索引 $k\\in\\{0,1,2\\}$ 和样本索引 $s\\in\\{0,1,\\dots,S-1\\}$，将种子设置为 $12345+1000k+s$。\n\n测试套件。您的程序必须为以下三个测试用例估计 $t$，每个用例使用指定的晶格尺寸 $L$、占据概率集合 $p$（每个都严格大于 $p_c$）以及每个 $p$ 的独立样本数 $S$：\n- 用例 0: $L=24$, $p\\in\\{0.55,\\,0.60,\\,0.65,\\,0.70\\}$, $S=12$。\n- 用例 1: $L=16$, $p\\in\\{0.52,\\,0.56,\\,0.60,\\,0.64\\}$, $S=12$。\n- 用例 2: $L=12$, $p\\in\\{0.505,\\,0.530,\\,0.560,\\,0.620\\}$, $S=20$。\n\n可量化的输出。对于每个用例，输出是一个实数：通过上述线性拟合得到的估计指数 $t$，使用自然对数计算。如果在通过 $\\overline{\\sigma}(p)>0$ 进行筛选后，剩余可用的 $p$ 值少于 $2$ 个，则该用例输出哨兵值 $-1.0$。最终的数值输出没有物理单位，必须打印并四舍五入到三位小数。\n\n最终输出格式。您的程序应生成单行输出，其中包含按用例顺序排列的三个结果，形式为逗号分隔的列表，并用方括号括起来，例如：$[1.234,1.289,1.301]$。不应打印任何其他文本。",
            "solution": "我们概述一种基于基础电网络理论和逾渗定义的、有原则的计算方法，以估计电导指数 $t$。\n\n目标标度关系是，对于二维方形晶格上的键逾渗，在其逾渗阈值 $p_c$ 附近，当 $p$ 从上方趋近于 $p_c$ 时（$p\\downarrow p_c$），等效体电导率的行为如同 $\\sigma(p)\\propto (p-p_c)^t$。取对数得到 $\\log \\sigma(p) = t \\log(p-p_c) + C$，这启发我们将 $t$ 估计为 $\\log \\sigma(p)$ 相对于 $\\log(p-p_c)$ （对于 $p>p_c$）的斜率。\n\n我们完全基于欧姆定律和基尔霍夫电流定律，从逾渗得到的随机电阻网络中构建 $\\sigma(p)$, 过程如下。考虑一个 $L\\times L$ 的方形节点网格，键位于水平和垂直方向的最近邻之间。每个可能的键以概率 $p$ 独立地被占据。每个被占据的键被赋予电导 $g=1$（任意单位），而未被占据的键则不存在（$g=0$）。通过将左边界所有节点的电势设置为 $V=1$，右边界所有节点的电势设置为 $V=0$ 来施加狄利克雷边界条件。顶部和底部边界是电学自由的（无固定电势）。对于给定的网络实现，内部节点的电压由每个内部节点 $i$ 处的基尔霍夫电流定律决定：\n$$\n\\sum_{j\\in \\mathcal{N}(i)} g_{ij}\\,(V_i - V_j) = 0,\n$$\n其中 $\\mathcal{N}(i)$ 表示节点 $i$ 的邻居集合，$g_{ij}\\in\\{0,1\\}$ 是 $i$ 和 $j$ 之间键的电导。这将产生一个关于内部节点电压 $\\mathbf{v}$ 的线性系统 $A\\mathbf{v}=\\mathbf{b}$，其中 $A$ 是限制在内部节点上的图拉普拉斯算子，$\\mathbf{b}$ 收集了来自连接到狄利克雷边界节点的被占据键的贡献。具体来说，对于一个内部节点 $i$，$A$ 的对角线元素是 $i$ 到其所有被占据邻居的电导之和，每个非对角线元素 $A_{ij}$ 对于内部节点 $i$ 和 $j$ 之间的被占据键等于 $-g_{ij}$。右侧项 $b_i$ 是 $\\sum_{j\\in \\partial \\Omega} g_{ij}\\,V_j$，对从 $i$ 到具有固定电势 $V_j$ 的边界节点 $j$ 的所有被占据键求和。\n\n一个微妙之处在于，如果一个内部连通分量没有连接到任何狄利克雷边界，那么该分量内的电势将相差一个附加常数而不确定，对应于该分量的子矩阵是奇异的。为避免此问题，我们将线性系统的求解域限制在通过被占据的键连接到至少一个狄利克雷边界（左或右）的内部节点集合上。这可以通过图遍历（如图形优先搜索）实现，从左边界和右边界出发，跨越被占据的键，并保留从任一侧可达的内部节点的并集。未连接到任一边界的节点被排除在 $A$ 和 $\\mathbf{b}$ 之外，因为它们不会影响边界之间的电流。\n\n求解 $A\\mathbf{v}=\\mathbf{b}$ 后，我们利用欧姆定律计算注入左边界的总电流，该电流流过连接左边界节点（固定在 $V=1$）与其直接内部邻居的被占据键。如果一个被占据的键连接一个左边界节点到一个电势为 $V_{\\text{n}}$ 的内部节点，流经该键从左到内部的电流为 $g\\,(1 - V_{\\text{n}})$。对所有此类键求和得到净注入电流 $I_{\\text{L}}$。由于右边界固定在 $V=0$，边界间的总电压降为 $\\Delta V=1$，因此等效电导（在这些任意单位下的体电导率）等于 $\\sigma = I_{\\text{L}}$。\n\n为了估计 $t$，我们对每个测试用例执行以下步骤：\n- 对于一组预设的占据概率 $p>p_c$ 和独立样本数 $S$，我们使用伪随机数生成器生成 $S$ 个独立的键构型，其种子确定性地设置为 $12345+1000k+s$，其中 $k$ 是测试用例索引，$s\\in\\{0,1,\\dots,S-1\\}$ 是样本索引。对于每个构型，我们按上述方法计算 $\\sigma(p)$。然后我们计算 $S$ 个样本的样本均值 $\\overline{\\sigma}(p)$。\n- 我们丢弃任何 $\\overline{\\sigma}(p)\\le 0$ 的 $p$ 值（这可能由于有限尺寸效应或在 $p_c$ 附近采样不足而发生）。如果至少剩下 2 个 $p$ 值，我们通过普通最小二乘回归法使用自然对数拟合线性模型 $\\log \\overline{\\sigma}(p) = t \\log(p - p_c) + C$。拟合的斜率即为我们对 $t$ 的估计。如果剩余可用点少于 2 个，我们输出哨兵值 $-1.0$。\n\n方形晶格上键逾渗的逾渗阈值为 $p_c=\\tfrac{1}{2}$，我们对所有测试用例均使用此值。测试套件包含三个用例：\n- 用例 0: $L=24$, $p\\in\\{0.55,\\,0.60,\\,0.65,\\,0.70\\}$, $S=12$。\n- 用例 1: $L=16$, $p\\in\\{0.52,\\,0.56,\\,0.60,\\,0.64\\}$, $S=12$。\n- 用例 2: $L=12$, $p\\in\\{0.505,\\,0.530,\\,0.560,\\,0.620\\}$, $S=20$。\n\n这些用例分别探测了一个具有多个远高于 $p_c$ 的 $p$ 值的中等规模系统，一个包含更接近 $p_c$ 的 $p$ 值以测试灵敏度和潜在有限尺寸效应的较小系统，以及一个通过增加采样来减轻 $p_c$ 附近噪声的小型系统。最终程序打印一行，包含按 $[t_0,t_1,t_2]$ 精确格式排列的三个估计斜率，四舍五入到三位小数，例如 $[1.234,1.289,1.301]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import coo_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\nfrom collections import deque\n\ndef generate_bonds(L, p, rng):\n    \"\"\"\n    Generate occupied bond arrays for an LxL lattice.\n    Horizontal bonds H[y, x] connect (x,y) -> (x+1,y) for x in [0..L-2], y in [0..L-1].\n    Vertical bonds V[y, x] connect (x,y) -> (x,y+1) for y in [0..L-2], x in [0..L-1].\n    Returns boolean arrays H (shape L x (L-1)) and V ((L-1) x L).\n    \"\"\"\n    H = rng.random((L, L - 1))  p\n    V = rng.random((L - 1, L))  p\n    return H, V\n\ndef bfs_reachable(L, H, V, from_left=True):\n    \"\"\"\n    BFS to find nodes reachable from the left (x=0) or right (x=L-1) boundary via occupied bonds.\n    Returns a boolean array reach[y, x] of shape (L, L).\n    \"\"\"\n    reach = np.zeros((L, L), dtype=bool)\n    q = deque()\n    if from_left:\n        x0 = 0\n        for y in range(L):\n            reach[y, x0] = True\n            q.append((x0, y))\n    else:\n        x0 = L - 1\n        for y in range(L):\n            reach[y, x0] = True\n            q.append((x0, y))\n\n    while q:\n        x, y = q.popleft()\n        # Left neighbor\n        if x > 0 and H[y, x - 1]:\n            nx, ny = x - 1, y\n            if not reach[ny, nx]:\n                reach[ny, nx] = True\n                q.append((nx, ny))\n        # Right neighbor\n        if x  L - 1 and H[y, x]:\n            nx, ny = x + 1, y\n            if not reach[ny, nx]:\n                reach[ny, nx] = True\n                q.append((nx, ny))\n        # Up neighbor\n        if y > 0 and V[y - 1, x]:\n            nx, ny = x, y - 1\n            if not reach[ny, nx]:\n                reach[ny, nx] = True\n                q.append((nx, ny))\n        # Down neighbor\n        if y  L - 1 and V[y, x]:\n            nx, ny = x, y + 1\n            if not reach[ny, nx]:\n                reach[ny, nx] = True\n                q.append((nx, ny))\n\n    return reach\n\ndef build_system(L, H, V, reach_union):\n    \"\"\"\n    Build the sparse linear system A v = b for interior nodes that are reachable from either boundary.\n    Interior nodes are those with x in [1..L-2]. Boundary nodes at x=0 (V=1) and x=L-1 (V=0) are Dirichlet.\n    reach_union is boolean mask of nodes reachable from left or right boundaries.\n    Returns (A_csr, b, node_index, index_to_node).\n    node_index maps (x,y) -> idx in [0..n-1] for interior reachable nodes.\n    index_to_node is list mapping idx -> (x,y).\n    \"\"\"\n    # Map interior reachable nodes to indices\n    node_index = {}\n    index_to_node = []\n    for y in range(L):\n        for x in range(1, L - 1):\n            if reach_union[y, x]:\n                node_index[(x, y)] = len(index_to_node)\n                index_to_node.append((x, y))\n\n    n = len(index_to_node)\n    if n == 0:\n        # Empty system\n        A = coo_matrix((0, 0), dtype=float).tocsr()\n        b = np.zeros((0,), dtype=float)\n        return A, b, node_index, index_to_node\n\n    rows = []\n    cols = []\n    data = []\n    b = np.zeros(n, dtype=float)\n\n    def add_entry(i, j, val):\n        rows.append(i)\n        cols.append(j)\n        data.append(val)\n\n    for idx, (x, y) in enumerate(index_to_node):\n        diag = 0.0\n\n        # Neighbor to the left: (x-1, y) via H[y, x-1]\n        if x - 1 >= 0 and H[y, x - 1]:\n            diag += 1.0\n            if x - 1 == 0:\n                # Left boundary at V=1\n                b[idx] += 1.0 * 1.0\n            else:\n                # Interior node at (x-1, y)\n                if reach_union[y, x - 1]:\n                    jdx = node_index[(x - 1, y)]\n                    add_entry(idx, jdx, -1.0)\n                else:\n                    # Not in system (should not happen for an occupied bond unless excluded)\n                    pass\n\n        # Neighbor to the right: (x+1, y) via H[y, x]\n        if x  L - 1 and H[y, x]:\n            diag += 1.0\n            if x + 1 == L - 1:\n                # Right boundary at V=0 => no contribution to b\n                pass\n            else:\n                if reach_union[y, x + 1]:\n                    jdx = node_index[(x + 1, y)]\n                    add_entry(idx, jdx, -1.0)\n\n        # Neighbor above: (x, y-1) via V[y-1, x]\n        if y - 1 >= 0 and V[y - 1, x]:\n            diag += 1.0\n            if reach_union[y - 1, x]:\n                jdx = node_index.get((x, y - 1))\n                if jdx is not None:\n                    add_entry(idx, jdx, -1.0)\n                else:\n                    # Could be boundary column (but y-1 same column), handled by reach mask\n                    pass\n\n        # Neighbor below: (x, y+1) via V[y, x]\n        if y  L - 1 and V[y, x]:\n            diag += 1.0\n            if reach_union[y + 1, x]:\n                jdx = node_index.get((x, y + 1))\n                if jdx is not None:\n                    add_entry(idx, jdx, -1.0)\n\n        # Diagonal entry\n        add_entry(idx, idx, diag)\n\n    A = coo_matrix((data, (rows, cols)), shape=(n, n), dtype=float).tocsr()\n    return A, b, node_index, index_to_node\n\ndef compute_sigma(L, p, seed):\n    \"\"\"\n    Compute effective conductance sigma for one random instance at given L, p, with RNG seed.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    H, V = generate_bonds(L, p, rng)\n\n    # Reachable from left and right boundaries\n    reach_left = bfs_reachable(L, H, V, from_left=True)\n    reach_right = bfs_reachable(L, H, V, from_left=False)\n    reach_union = np.logical_or(reach_left, reach_right)\n\n    # Build and solve system\n    A, b, node_index, index_to_node = build_system(L, H, V, reach_union)\n\n    if A.shape[0] == 0:\n        # No interior reachable nodes => no conduction\n        return 0.0\n\n    try:\n        v = spsolve(A, b)\n    except Exception:\n        # Numerical fallback: treat as zero conductance if solve fails\n        return 0.0\n\n    # Map voltages back for easy lookup\n    volt = {}\n    for idx, (x, y) in enumerate(index_to_node):\n        volt[(x, y)] = v[idx]\n\n    # Net current injected at left boundary across occupied bonds to column x=1\n    total_current = 0.0\n    x_left_neighbor = 1\n    for y in range(L):\n        if H[y, 0]:  # Bond between (0,y) and (1,y)\n            vn = volt.get((x_left_neighbor, y))\n            if vn is not None:\n                total_current += (1.0 - vn)  # g=1\n\n    # sigma equals total current for unit voltage drop\n    return float(total_current)\n\ndef mean_sigma_over_samples(L, p, case_index, S):\n    \"\"\"\n    Compute mean sigma over S samples for given L and p with deterministic seeding.\n    \"\"\"\n    sigmas = []\n    for s in range(S):\n        seed = 12345 + 1000 * case_index + s\n        sigmas.append(compute_sigma(L, p, seed))\n    return float(np.mean(sigmas))\n\ndef estimate_t(p_values, sigma_means, pc=0.5):\n    \"\"\"\n    Estimate exponent t by linear regression of log(sigma) vs log(p - pc).\n    Returns -1.0 if fewer than two usable points.\n    \"\"\"\n    x = []\n    y = []\n    for p, sm in zip(p_values, sigma_means):\n        if sm > 0.0 and p > pc:\n            x.append(np.log(p - pc))\n            y.append(np.log(sm))\n    if len(x)  2:\n        return -1.0\n    x = np.array(x)\n    y = np.array(y)\n    # Ordinary least squares fit: y = t * x + c\n    t, c = np.polyfit(x, y, 1)\n    return float(t)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (case_index, L, p_list, samples S)\n        (0, 24, [0.55, 0.60, 0.65, 0.70], 12),\n        (1, 16, [0.52, 0.56, 0.60, 0.64], 12),\n        (2, 12, [0.505, 0.530, 0.560, 0.620], 20),\n    ]\n\n    pc = 0.5\n    results = []\n    for case_index, L, p_list, S in test_cases:\n        sigma_means = []\n        for p in p_list:\n            m = mean_sigma_over_samples(L, p, case_index, S)\n            sigma_means.append(m)\n        t_est = estimate_t(p_list, sigma_means, pc=pc)\n        # Round to three decimals for output\n        if np.isnan(t_est) or np.isinf(t_est):\n            t_est = -1.0\n        t_est_rounded = f\"{t_est:.3f}\"\n        results.append(t_est_rounded)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}