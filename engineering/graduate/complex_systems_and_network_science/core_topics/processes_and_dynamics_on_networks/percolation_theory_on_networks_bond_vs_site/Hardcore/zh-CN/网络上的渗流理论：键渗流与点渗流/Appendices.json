{
    "hands_on_practices": [
        {
            "introduction": "这第一个练习为分析网络上的逾渗奠定了理论基础。通过采用强大的空穴方法和消息传递形式 ，你将从第一性原理推导出巨连通分支出现的临界条件。这个练习展示了相变这一抽象概念如何与网络的非回溯矩阵的光谱性质，并最终与其度分布的简单矩联系起来。",
            "id": "4296412",
            "problem": "考虑一个由度分布为 $P(k)$ 的配置模型生成的大型、稀疏、无向网络上的逾渗过程，该网络在热力学极限下是局部树状的。定义了两种逾渗过程：键逾渗（每条边以概率 $p$ 独立保留）和点逾渗（每个节点以概率 $q$ 独立保留，若节点被移除，则所有与之相连的边也均被移除）。我们将通过在网络有向边表示上进行消息传递，并使用忽略回溯环路的腔方法来分析巨连通分量（GCC）的出现。\n\n仅从键逾渗和点逾渗的定义、巨连通分量（GCC）的概念，以及表示沿有向边不会导向GCC的概率的有向边消息的构建出发，推导在一般图上对应于不存在GCC的平凡不动点的线性化稳定性条件。识别出主导线性化消息动力学的算子，并用其谱半径表示GCC出现的临界参数。\n\n然后，将您的结果具体化到局部树状的配置模型网络，并将相关的谱半径与平均超额度联系起来，用度分布 $P(k)$ 的前两阶矩 $\\langle k \\rangle$ 和 $\\langle k^{2} \\rangle$ 来表示。\n\n最后，计算特定度分布下的键逾渗和点逾渗阈值\n$$\nP(k) = \\frac{1}{2}\\,\\delta_{k,1} + \\frac{1}{2}\\,\\delta_{k,3},\n$$\n其中 $\\delta_{i,j}$ 是克罗内克δ函数，从而得出临界键占据概率 $p_{c}$ 和临界点占据概率 $q_{c}$ 的明确值。\n\n将您的最终结果表示为最简形式的精确分数。以包含 $p_{c}$ 和 $q_{c}$（按此顺序）的行矩阵形式提供最终答案。无需单位，也无需四舍五入。",
            "solution": "此问题要求推导配置模型网络上键逾渗和点逾渗的逾渗阈值。解题过程将分三个阶段进行：首先，使用消息传递方法在一般图上推导巨连通分量（GCC）出现的通用框架；其次，通过将临界条件与度分布的矩相关联，将此框架具体化到配置模型网络；第三，计算给定度分布下的具体阈值。\n\n我们首先为一个大型、稀疏、无向的通用网络建立消息传递框架。我们分析对应于不存在GCC的平凡不动点的稳定性。当此不动点变得不稳定时，GCC便会出现。该方法依赖于腔方法，该方法假设网络是局部树状的，这使得它在热力学极限下对于配置模型网络是精确的。\n\n对于每条无向边 $\\{i, j\\}$，相应地存在一个有向边集合 $(i, j)$。从节点 $i$ 传递到邻居 $j$ 的消息量化了在“腔图”（即移除涉及节点 $i$ 的连接或仅移除边 $(i,j)$ 的原始图）中发生某个事件的概率。\n\n**第一部分：通过消息传递进行一般性推导**\n\n**键逾渗**\n\n在键逾渗中，每条边独立地以概率 $p$ 存在。令 $u_{i \\to j}$ 为沿着有向边 $i \\to j$ **不**会导向GCC的概率。此事件发生有两种情况：要么边 $\\{i,j\\}$ 不存在（概率为 $1-p$），要么边存在（概率为 $p$）但节点 $j$ 未能通过其任何其他邻居 $k \\in \\mathcal{N}(j) \\setminus \\{i\\}$ 连接到GCC。在腔/树状近似下，从 $j$ 出发朝向其其他邻居的路径是独立的。根据定义，$j$ 朝向邻居 $k$ 的路径未能到达GCC的概率是 $u_{j \\to k}$。\n\n因此，消息的自洽方程为：\n$$\nu_{i \\to j} = (1 - p) + p \\prod_{k \\in \\mathcal{N}(j) \\setminus \\{i\\}} u_{j \\to k}\n$$\n不存在GCC对应于平凡不动点，即对所有有向边 $(i,j)$ 都有 $u_{i \\to j} = 1$。让我们验证这一点：$1 = (1-p) + p \\prod 1 = 1-p+p = 1$。为了分析此不动点的稳定性，我们围绕它进行线性化。令 $u_{i \\to j} = 1 - \\epsilon_{i \\to j}$，其中 $\\epsilon_{i \\to j}$ 是一个小的正微扰。将此代入方程得到：\n$$\n1 - \\epsilon_{i \\to j} = (1 - p) + p \\prod_{k \\in \\mathcal{N}(j) \\setminus \\{i\\}} (1 - \\epsilon_{j \\to k})\n$$\n对于小的 $\\epsilon$，我们可以将乘积展开到一阶：$\\prod (1 - \\epsilon_k) \\approx 1 - \\sum \\epsilon_k$。\n$$\n1 - \\epsilon_{i \\to j} \\approx (1 - p) + p \\left(1 - \\sum_{k \\in \\mathcal{N}(j) \\setminus \\{i\\}} \\epsilon_{j \\to k}\\right)\n$$\n$$\n1 - \\epsilon_{i \\to j} \\approx 1 - p + p - p \\sum_{k \\in \\mathcal{N}(j) \\setminus \\{i\\}} \\epsilon_{j \\to k}\n$$\n这可简化为微扰的线性化动力学方程：\n$$\n\\epsilon_{i \\to j} = p \\sum_{k \\in \\mathcal{N}(j) \\setminus \\{i\\}} \\epsilon_{j \\to k}\n$$\n\n**点逾渗**\n\n在点逾渗中，每个节点独立地以概率 $q$ 存在。如果一个节点被移除，其所有相连的边也均被移除。令 $v_{i \\to j}$ 为从邻居 $i$ 的角度看（即在移除了 $i$ 的腔图中），节点 $j$ **不**属于GCC的概率。此事件发生有两种情况：要么节点 $j$ 不存在（概率为 $1-q$），要么节点 $j$ 存在（概率为 $q$）但它未能通过其任何其他邻居 $k \\in \\mathcal{N}(j) \\setminus \\{i\\}$ 连接到GCC。\n\n因此，自洽方程为：\n$$\nv_{i \\to j} = (1 - q) + q \\prod_{k \\in \\mathcal{N}(j) \\setminus \\{i\\}} v_{j \\to k}\n$$\n这个方程在数学上与键逾渗的方程同构。平凡不动点是 $v_{i \\to j} = 1$。通过设置 $v_{i \\to j} = 1 - \\delta_{i \\to j}$ 在此不动点附近进行线性化，得到：\n$$\n\\delta_{i \\to j} = q \\sum_{k \\in \\mathcal{N}(j) \\setminus \\{i\\}} \\delta_{j \\to k}\n$$\n\n**线性化动力学和临界条件**\n\n两个线性化方程都可以用图的非回溯矩阵 $\\mathbf{B}$ 这个线性算子来表示。算子 $\\mathbf{B}$ 作用于定义在有向边集合上的函数。其作用由下式给出：\n$$\n(\\mathbf{B} f)(i \\to j) = \\sum_{k \\in \\mathcal{N}(j) \\setminus \\{i\\}} f(j \\to k)\n$$\n微扰向量 $\\vec{\\epsilon}$ 和 $\\vec{\\delta}$ 的线性化动力学可以分别写为 $\\vec{\\epsilon}^{(t+1)} = p \\mathbf{B} \\vec{\\epsilon}^{(t)}$ 和 $\\vec{\\delta}^{(t+1)} = q \\mathbf{B} \\vec{\\delta}^{(t)}$。当相应线性算子的最大特征值（谱半径 $\\rho$）大于1时，平凡不动点（无GCC）变得不稳定。\n对于键逾渗，算子是 $\\mathbf{T}_{\\text{bond}} = p\\mathbf{B}$。临界条件是 $\\rho(\\mathbf{T}_{\\text{bond}}) = p_c \\rho(\\mathbf{B}) = 1$。\n对于点逾渗，算子是 $\\mathbf{T}_{\\text{site}} = q\\mathbf{B}$。临界条件是 $\\rho(\\mathbf{T}_{\\text{site}}) = q_c \\rho(\\mathbf{B}) = 1$。\n这得出了以非回溯矩阵谱半径表示的临界阈值：\n$$\np_c = \\frac{1}{\\rho(\\mathbf{B})} \\quad \\text{和} \\quad q_c = \\frac{1}{\\rho(\\mathbf{B})}\n$$\n\n**第二部分：具体化到配置模型网络**\n\n对于由度分布为 $P(k)$ 的配置模型生成的大型随机图，局部树状假设是精确的。在此极限下，非回溯矩阵的谱半径 $\\rho(\\mathbf{B})$ 等于网络的平均超额度。\n\n节点的超额度是其度数减一；它是离开一个节点的边的数量，不包括我们到达该节点所用的那条边。为了找到平均超额度，我们考虑遍历一条随机边。这条边导向一个度为 $k$ 的节点的概率不是 $P(k)$，而是与 $kP(k)$ 成正比。随机边末端节点的度分布的归一化分布是 $\\frac{kP(k)}{\\langle k \\rangle}$，其中 $\\langle k \\rangle = \\sum_k k P(k)$ 是平均度。\n\n一个度为 $k$ 的节点有 $k-1$ 条出边（超额度）。平均超额度是在此分布上对 $k-1$ 的平均值：\n$$\n\\rho(\\mathbf{B}) = \\sum_{k} (k-1) \\frac{k P(k)}{\\langle k \\rangle} = \\frac{1}{\\langle k \\rangle} \\sum_{k} (k^2 - k) P(k)\n$$\n使用矩的定义 $\\langle f(k) \\rangle = \\sum_k f(k) P(k)$，我们可以将其写为：\n$$\n\\rho(\\mathbf{B}) = \\frac{\\langle k^2 \\rangle - \\langle k \\rangle}{\\langle k \\rangle}\n$$\n其中 $\\langle k^2 \\rangle = \\sum_k k^2 P(k)$ 是度分布的二阶矩。\n\n将 $\\rho(\\mathbf{B})$ 的这个表达式代入我们的临界条件，得到配置模型的逾渗阈值：\n$$\np_c = \\frac{\\langle k \\rangle}{\\langle k^2 \\rangle - \\langle k \\rangle}\n$$\n$$\nq_c = \\frac{\\langle k \\rangle}{\\langle k^2 \\rangle - \\langle k \\rangle}\n$$\n这是著名的 Molloy-Reed 判据，用于判断巨型连通分量的出现。\n\n**第三部分：针对特定度分布的计算**\n\n给定度分布为 $P(k) = \\frac{1}{2}\\,\\delta_{k,1} + \\frac{1}{2}\\,\\delta_{k,3}$。这描述了一个网络，其中一半节点的度为1，另一半节点的度为3。\n\n首先，我们计算一阶矩（平均度） $\\langle k \\rangle$：\n$$\n\\langle k \\rangle = \\sum_{k} k P(k) = (1) \\cdot P(1) + (3) \\cdot P(3) = (1)\\left(\\frac{1}{2}\\right) + (3)\\left(\\frac{1}{2}\\right) = \\frac{1}{2} + \\frac{3}{2} = \\frac{4}{2} = 2\n$$\n接下来，我们计算二阶矩 $\\langle k^2 \\rangle$：\n$$\n\\langle k^2 \\rangle = \\sum_{k} k^2 P(k) = (1^2) \\cdot P(1) + (3^2) \\cdot P(3) = (1)\\left(\\frac{1}{2}\\right) + (9)\\left(\\frac{1}{2}\\right) = \\frac{1}{2} + \\frac{9}{2} = \\frac{10}{2} = 5\n$$\n现在我们可以计算 $\\langle k^2 \\rangle - \\langle k \\rangle$：\n$$\n\\langle k^2 \\rangle - \\langle k \\rangle = 5 - 2 = 3\n$$\n最后，我们将这些值代入临界阈值 $p_c$ 和 $q_c$ 的公式中：\n$$\np_c = \\frac{\\langle k \\rangle}{\\langle k^2 \\rangle - \\langle k \\rangle} = \\frac{2}{3}\n$$\n$$\nq_c = \\frac{\\langle k \\rangle}{\\langle k^2 \\rangle - \\langle k \\rangle} = \\frac{2}{3}\n$$\n对于此网络系综，键逾渗和点逾渗的阈值是相同的，均为 $\\frac{2}{3}$。最终答案将以包含 $p_c$ 和 $q_c$ 的行矩阵形式呈现。",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{2}{3}  \\frac{2}{3} \\end{pmatrix}}$$"
        },
        {
            "introduction": "在基础框架之上，这个练习引入了一个更细致的场景：具有度相关保留概率的位点渗流 。这是为真实世界系统建模的关键扩展，因为在真实世界中，并非所有节点都同等稳健或重要。通过这个问题，你将学会如何调整生成函数方法来处理异质性，并揭示不同渗流过程之间优雅的、有时是出人意料的关系。",
            "id": "4296414",
            "problem": "考虑一个大型组态模型网络，其度分布仅包含两种度：一个节点的度为 $k=1$ 的概率为 $a \\in (0,1)$，度为 $k=4$ 的概率为 $1-a$。设度分布的概率生成函数 (PGF) 为 $G_{0}(x)$，超额度分布的 PGF 为 $G_{1}(x)$。假设在热力学极限下，网络具有局部树状性质。\n\n考虑两种独立的逾渗过程：\n- 边逾渗：每条边以概率 $p \\in [0,1]$ 被独立保留。\n- 具有度相关保留概率的点逾渗：每个度为 $k$ 的节点以概率 $q_{k}$ 被独立保留，其中 $q_{1}=q$ 且 $q_{4}=t\\,q$，参数 $t \\in (0,1]$ 和 $q \\in [0,1]$。保留的节点通过连接它们的原始组态模型中的所有边保持连接。\n\n请仅使用组态模型的核心定义、PGF $G_{0}(x)$ 和 $G_{1}(x)$，以及关于巨组分出现的分支过程解释，推导该网络上边逾渗的临界占据概率 $p_{c}$ 和上述度相关点逾渗的临界占据概率 $q_{c}$，并在适当时用 $a$ 和 $t$ 表示。然后，对于参数值 $a=\\frac{1}{2}$ 和 $t=\\frac{1}{2}$，计算比值 $\\rho \\equiv \\frac{q_{c}}{p_{c}}$。请将 $\\rho$ 的最终值以单个实数的形式给出。无需四舍五入。",
            "solution": "### 临界概率的推导\n\n网络的度分布由 $P(k) = a\\delta_{k,1} + (1-a)\\delta_{k,4}$ 给出，其中 $\\delta_{i,j}$ 是克罗内克 (Kronecker) delta 函数。\n\n度分布的概率生成函数 (PGF) $G_0(x)$ 为：\n$$\nG_0(x) = \\sum_{k} P(k)x^k = a x^1 + (1-a)x^4\n$$\n平均度 $\\langle k \\rangle$ 可由 $G_0(x)$ 的一阶导数在 $x=1$ 处的值得到：\n$$\nG_0'(x) = a + 4(1-a)x^3\n$$\n$$\n\\langle k \\rangle = G_0'(1) = a + 4(1-a) = 4-3a\n$$\n超额度分布的 PGF $G_1(x)$ 给出的是沿一条随机边到达的节点所连接的其他边的数量分布，其表达式为：\n$$\nG_1(x) = \\frac{G_0'(x)}{G_0'(1)} = \\frac{a + 4(1-a)x^3}{4-3a}\n$$\n巨组分的出现可以作为分支过程来分析。巨组分存在的判据是分支过程第二代后代的期望数量必须大于1。临界点是该期望值等于1的地方。\n\n**1. 边逾渗**\n\n在边逾渗中，每条边以概率 $p$ 存在。逾渗后网络的超额度分布的 PGF $G_1^{(p)}(x)$，是通过将 $G_1(x)$ 与单条边被保留的 PGF $(1-p) + px$ 进行复合得到的。\n$$\nG_1^{(p)}(x) = G_1(1-p+px)\n$$\n后代的期望数量是该 PGF 在 $x=1$ 处的导数：\n$$\n\\frac{d}{dx}G_1^{(p)}(x) \\bigg|_{x=1} = G_1'(1-p+px) \\cdot p \\bigg|_{x=1} = p G_1'(1)\n$$\n临界条件是 $p_c G_1'(1) = 1$。我们需要计算 $G_1'(1)$：\n$$\nG_1'(x) = \\frac{d}{dx}\\left(\\frac{a + 4(1-a)x^3}{4-3a}\\right) = \\frac{12(1-a)x^2}{4-3a}\n$$\n$$\nG_1'(1) = \\frac{12(1-a)}{4-3a}\n$$\n这个量也被称为 $\\frac{\\langle k(k-1) \\rangle}{\\langle k \\rangle}$。\n临界边逾渗概率 $p_c$ 是：\n$$\np_c = \\frac{1}{G_1'(1)} = \\frac{4-3a}{12(1-a)}\n$$\n\n**2. 点逾渗**\n\n对于点逾渗，我们在网络上追踪一条路径。从一个被占据的节点开始，我们沿着一条随机边前进。为了使团簇增长，另一端的节点也必须被占据。在临界状态下，从这样一个新到达的被占据节点分支出去的新路径的期望数量必须为1。\n\n随机选择的一条边通向一个度为 $k$ 的节点的概率是 $\\frac{kP(k)}{\\langle k \\rangle}$。该节点以概率 $q_k$ 被占据。如果被占据，它将提供 $k-1$ 条新边以供探索。因此，新分支的期望数量是：\n$$\n\\sum_k \\frac{kP(k)}{\\langle k \\rangle} q_k (k-1) = \\frac{1}{\\langle k \\rangle} \\sum_k k(k-1)P(k)q_k\n$$\n在临界点，该期望值等于1，且占据概率为 $q_1 = q_c$ 和 $q_4 = tq_c$。\n$$\n\\frac{1}{\\langle k \\rangle} \\sum_k k(k-1)P(k)q_{k,c} = 1\n$$\n让我们针对给定的分布计算这个和：\n$$\n\\sum_k k(k-1)P(k)q_{k,c} = 1(1-1)P(1)q_{1,c} + 4(4-1)P(4)q_{4,c}\n$$\n$$\n= 0 \\cdot a \\cdot q_c + 12 \\cdot (1-a) \\cdot (tq_c) = 12(1-a)tq_c\n$$\n将此代入临界条件：\n$$\n\\frac{12(1-a)tq_c}{4-3a} = 1\n$$\n求解临界点占据概率 $q_c$：\n$$\nq_c = \\frac{4-3a}{12t(1-a)}\n$$\n\n**3. 比值计算**\n\n我们需要计算比值 $\\rho = \\frac{q_c}{p_c}$。\n$$\n\\rho = \\frac{q_c}{p_c} = \\frac{\\frac{4-3a}{12t(1-a)}}{\\frac{4-3a}{12(1-a)}}\n$$\n公因子 $\\frac{4-3a}{12(1-a)}$ 被消去，得到一个简单的比值表达式：\n$$\n\\rho = \\frac{1}{t}\n$$\n值得注意的是，该比值与参数 $a$ 无关。这是因为度为 $k=1$ 的节点有一个因子 $k(k-1)=0$，因此对通过超额度分布上的分支过程确定临界性的求和没有贡献。\n\n题目要求计算参数 $a=\\frac{1}{2}$ 和 $t=\\frac{1}{2}$ 时的 $\\rho$ 值。计算该比值不需要 $a$ 的值。\n$$\n\\rho = \\frac{1}{t} = \\frac{1}{\\frac{1}{2}} = 2\n$$\n比值的最终值为2。",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "这最后一个练习从解析理论转向计算实验，这是任何现代网络科学家的一项至关重要的技能。你将通过将逾渗建模为随机电阻网络，实现一个算法来估计电导率临界指数 。这个动手编程练习巩固了对逾渗转变背后的物理直觉，并提供了在模拟复杂系统和从数值数据中分析临界现象方面的实践经验。",
            "id": "3171738",
            "problem": "您将编写一个完整、可运行的程序，通过将逾渗映射到一个随机电阻网络来估算二维键逾渗的电导率临界指数 $t$。在该网络中，每个被占据的键的电导为 $g=1$，而每个未被占据的键则不存在。该估算必须通过计算方形晶格在逾渗阈值 $p_c$ 附近两个相对侧之间的有效体电导率 $\\sigma(p)$，然后对 $pp_c$ 的情况拟合标度关系 $\\sigma(p)\\propto (p-p_c)^t$ 来完成。\n\n基本原理与假设。请使用以下经过充分检验的基本原理：\n- 欧姆定律描述了电导为 $g$ 的电阻两端的电流 $I$ 和电压差 $\\Delta V$ 之间的关系：$I=g\\,\\Delta V$。\n- 基尔霍夫电流定律指出，对于电阻网络的任何内部节点，当系统处于稳态时，离开该节点的电流代数和为 $0$。\n- 在固定边界电压下，网络解可通过求解由基尔霍夫电流定律和欧姆定律推导出的离散泊松方程（带有狄利克雷边界条件的图拉普拉斯算子）得到。\n- 对于无限方形晶格上的键逾渗，其键逾渗阈值为 $p_c=\\tfrac{1}{2}$（这是一个精确已知且被广泛接受的事实）。\n\n定义与数值设置。考虑一个 $L\\times L$ 的方形节点晶格，键只存在于最近邻（水平和垂直方向）之间。每个可能的键以概率 $p\\in(0,1)$ 独立地被占据，每个被占据的键被赋予电导 $g=1$，而未被占据的键则不存在。在左边界（列索引 $x=0$）的所有节点上施加狄利克雷边界条件 $V=1$，在右边界（列索引 $x=L-1$）的所有节点上施加 $V=0$。顶部和底部边界（行索引 $y=0$ 和 $y=L-1$）是电学自由的（无固定电势）。对于任意一次实现，有效电导率 $\\sigma(p)$ 定义为在施加的单位电压降 $\\Delta V=1$ 下，从左边界注入的总净电流，这等于左右边界之间的有效两端电导（以任意单位计）。\n\n为确保数值可解性，任何未连接到左边界或右边界的内部节点连通分量都应从线性系统中排除，因为在狄利克雷边界条件下，其电势是未确定的。实际上，您必须将求解限制在通过被占据的键与至少一个狄利克雷边界相连的内部节点集合上。\n\n指数 $t$ 的估计方法。对于每个测试用例，您需要：\n- 对于一组给定的高于 $p_c$ 的 $p$ 值中的每一个，生成多个独立的网络实现，并为每个实现计算有效电导率 $\\sigma(p)$，然后取样本均值 $\\overline{\\sigma}(p)$。\n- 仅使用那些 $\\overline{\\sigma}(p)0$ 的 $p$ 值，通过普通最小二乘法（未加权）将 $\\log \\overline{\\sigma}(p)$ 作为 $\\log(p-p_c)$ 的函数拟合线性关系 $\\log \\overline{\\sigma}(p)=t\\log(p-p_c)+C$，以估计 $t$。对数可以取任意底；为明确起见，请使用自然对数。\n- 如果剩下满足 $\\overline{\\sigma}(p)0$ 的不同 $p$ 值少于 2 个，则该测试用例返回哨兵值 $-1.0$。\n\n程序必须遵循的实现细节：\n- 在至少连接到一个狄利克雷边界的内部节点集上构建图拉普拉斯算子。对于一个内部节点 $i$，对角线元素等于其与所有被占据邻居的电导之和，非对角线元素对于连接到其他内部节点的被占据键等于 $-g$。右侧项 $b$ 的贡献来自连接到具有固定电压的边界节点的被占据键（$+gV_{\\text{boundary}}$）。\n- 求解稀疏线性系统 $A\\mathbf{v}=\\mathbf{b}$ 以获得内部节点电压 $\\mathbf{v}$；然后计算从左边界注入的净电流，其值为所有连接左边界节点与其最近邻内部节点的被占据键的 $g\\,(1-V_{\\text{neighbor}})$ 之和。\n- 对每个被占据的键使用 $g=1$，对未被占据的键使用 $g=0$。\n- 使用逾渗阈值 $p_c=\\tfrac{1}{2}$。\n- 使用带有受控种子的伪随机数生成器以确保可复现性。对于测试用例索引 $k\\in\\{0,1,2\\}$ 和样本索引 $s\\in\\{0,1,\\dots,S-1\\}$，将种子设置为 $12345+1000k+s$。\n\n测试套件。您的程序必须为以下三个测试用例估算 $t$，每个用例使用指定的晶格尺寸 $L$、占据概率集 $p$（每个都严格大于 $p_c$）以及每个 $p$ 值的独立样本数 $S$：\n- 用例 0: $L=24$, $p\\in\\{0.55,\\,0.60,\\,0.65,\\,0.70\\}$, $S=12$。\n- 用例 1: $L=16$, $p\\in\\{0.52,\\,0.56,\\,0.60,\\,0.64\\}$, $S=12$。\n- 用例 2: $L=12$, $p\\in\\{0.505,\\,0.530,\\,0.560,\\,0.620\\}$, $S=20$。\n\n可量化的输出。对于每个用例，输出是一个实数：通过上述线性拟合得到的估计指数 $t$，使用自然对数计算。如果在通过 $\\overline{\\sigma}(p)0$ 过滤后，可用的 $p$ 值少于 2 个，则该用例输出哨兵值 $-1.0$。最终的数值输出没有物理单位，并且必须打印并四舍五入到三位小数。\n\n最终输出格式。您的程序应生成单行输出，其中按用例顺序包含三个结果，格式为方括号括起来的逗号分隔列表，例如：$[1.234,1.289,1.301]$。不应打印任何其他文本。",
            "solution": "我们概述一种基于基本电网络理论和逾渗定义的、有原理可循的计算方法，用以估计电导率指数 $t$。\n\n目标标度关系是，对于二维方形晶格上的键逾渗，当概率 $p$ 在其逾渗阈值 $p_c$ 附近从上方趋近于 $p_c$ 时，有效体电导率的行为符合 $\\sigma(p)\\propto (p-p_c)^t$。两边取对数得到 $\\log \\sigma(p) = t \\log(p-p_c) + C$，这启发我们将 $t$ 估计为 $\\log \\sigma(p)$ 相对于 $\\log(p-p_c)$ （对于 $pp_c$）的斜率。\n\n我们完全基于欧姆定律和基尔霍夫电流定律，通过逾渗得到的随机电阻网络来构造 $\\sigma(p)$，过程如下。考虑一个 $L\\times L$ 的方形节点网格，键存在于水平和垂直方向的最近邻之间。每个可能的键以概率 $p$ 独立地被占据。每个被占据的键被赋予电导 $g=1$（任意单位），而未被占据的键则不存在（$g=0$）。通过将左边界所有节点的电势设置为 $V=1$、右边界所有节点的电势设置为 $V=0$ 来施加狄利克雷边界条件。顶部和底部边界保持电学自由（无固定电势）。对于给定的网络实现，内部节点的电压由每个内部节点 $i$ 处的基尔霍夫电流定律确定：\n$$\n\\sum_{j\\in \\mathcal{N}(i)} g_{ij}\\,(V_i - V_j) = 0,\n$$\n其中 $\\mathcal{N}(i)$ 表示节点 $i$ 的邻居集合，$g_{ij}\\in\\{0,1\\}$ 是 $i$ 和 $j$ 之间键的电导。这对内部节点的电压 $\\mathbf{v}$ 产生一个线性系统 $A\\mathbf{v}=\\mathbf{b}$，其中 $A$ 是限制在内部节点上的图拉普拉斯算子，$\\mathbf{b}$ 收集了来自连接到狄利克雷边界节点的被占据键的贡献。具体来说，对于一个内部节点 $i$，$A$ 的对角线元素是 $i$ 到其所有被占据邻居的电导之和，每个非对角线元素 $A_{ij}$ 对于内部节点 $i$ 和 $j$ 之间的被占据键为 $-g_{ij}$。右侧项 $b_i$ 是 $\\sum_{j\\in \\partial \\Omega} g_{ij}\\,V_j$，即对从 $i$ 连接到具有固定电势 $V_j$ 的边界节点 $j$ 的所有被占据键进行求和。\n\n如果一个内部连通分量没有连接到任何狄利克雷边界，就会出现一个微妙的问题：该分量内的电势在相差一个加性常数的意义下是不确定的，并且对应于该分量的子矩阵是奇异的。为避免这种情况，我们将线性系统的定义域限制在通过被占据的键与至少一个狄利克雷边界（左或右）相连的内部节点集上。这可以通过图遍历（如广度优先搜索）实现，从左边界和右边界出发，穿过被占据的键，并保留从任一边界可达的内部节点的并集。未连接到任一边界的节点被排除在 $A$ 和 $\\mathbf{b}$ 之外，因为它们不会影响边界之间的电流。\n\n在求解 $A\\mathbf{v}=\\mathbf{b}$ 之后，我们使用欧姆定律计算从左边界注入的总电流，计算方法是考察连接左边界节点（固定在 $V=1$）与其直接内部邻居的被占据键。如果一个被占据的键连接一个左边界节点和一个电势为 $V_{\\text{n}}$ 的内部节点，那么通过该键从左到内的电流是 $g\\,(1 - V_{\\text{n}})$。对所有这样的键求和，得到净注入电流 $I_{\\text{L}}$。由于右边界固定在 $V=0$，边界间的总电压降为 $\\Delta V=1$，因此有效电导（在这些任意单位下的体电导率）等于 $\\sigma = I_{\\text{L}}$。\n\n为了估计 $t$，我们对每个测试用例按以下步骤进行：\n- 对于一组给定的占据概率 $pp_c$ 和一个独立样本数 $S$，我们使用伪随机数生成器生成 $S$ 个独立的键构型，其种子对于测试用例索引 $k$ 和样本索引 $s\\in\\{0,1,\\dots,S-1\\}$ 确定性地设置为 $12345+1000k+s$。对于每个构型，我们按照上述方法计算 $\\sigma(p)$。然后，我们计算这 $S$ 个样本的样本均值 $\\overline{\\sigma}(p)$。\n- 我们舍弃任何满足 $\\overline{\\sigma}(p)\\le 0$ 的 $p$ 值（这种情况可能是由于有限尺寸效应或在 $p_c$ 附近采样不足造成的）。如果至少还剩下 2 个 $p$ 值，我们通过使用自然对数的普通最小二乘回归来拟合线性模型 $\\log \\overline{\\sigma}(p) = t \\log(p - p_c) + C$。拟合的斜率就是我们对 $t$ 的估计。如果剩下的可用点少于 2 个，我们输出哨兵值 $-1.0$。\n\n方形晶格上键逾渗的逾渗阈值是 $p_c=\\tfrac{1}{2}$，我们在所有测试用例中都使用这个值。测试套件包括三个用例：\n- 用例 0: $L=24$, $p\\in\\{0.55,\\,0.60,\\,0.65,\\,0.70\\}$, $S=12$。\n- 用例 1: $L=16$, $p\\in\\{0.52,\\,0.56,\\,0.60,\\,0.64\\}$, $S=12$。\n- 用例 2: $L=12$, $p\\in\\{0.505,\\,0.530,\\,0.560,\\,0.620\\}$, $S=20$。\n\n这些用例分别探测一个具有多个远高于 $p_c$ 的 $p$ 值的中等规模系统；一个包含更接近 $p_c$ 的 $p$ 值以测试敏感性和潜在有限尺寸效应的较小系统；以及一个通过增加采样来减轻 $p_c$ 附近噪声的小型系统。最终程序会打印单行内容，其中包含三个按三位小数四舍五入的估计斜率，格式严格为 $[t_0,t_1,t_2]$，例如 $[1.234,1.289,1.301]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import coo_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\nfrom collections import deque\n\ndef generate_bonds(L, p, rng):\n    \"\"\"\n    Generate occupied bond arrays for an LxL lattice.\n    Horizontal bonds H[y, x] connect (x,y) -> (x+1,y) for x in [0..L-2], y in [0..L-1].\n    Vertical bonds V[y, x] connect (x,y) -> (x,y+1) for y in [0..L-2], x in [0..L-1].\n    Returns boolean arrays H (shape L x (L-1)) and V ((L-1) x L).\n    \"\"\"\n    H = rng.random((L, L - 1))  p\n    V = rng.random((L - 1, L))  p\n    return H, V\n\ndef bfs_reachable(L, H, V, from_left=True):\n    \"\"\"\n    BFS to find nodes reachable from the left (x=0) or right (x=L-1) boundary via occupied bonds.\n    Returns a boolean array reach[y, x] of shape (L, L).\n    \"\"\"\n    reach = np.zeros((L, L), dtype=bool)\n    q = deque()\n    if from_left:\n        x0 = 0\n        for y in range(L):\n            reach[y, x0] = True\n            q.append((x0, y))\n    else:\n        x0 = L - 1\n        for y in range(L):\n            reach[y, x0] = True\n            q.append((x0, y))\n\n    while q:\n        x, y = q.popleft()\n        # Left neighbor\n        if x > 0 and H[y, x - 1]:\n            nx, ny = x - 1, y\n            if not reach[ny, nx]:\n                reach[ny, nx] = True\n                q.append((nx, ny))\n        # Right neighbor\n        if x  L - 1 and H[y, x]:\n            nx, ny = x + 1, y\n            if not reach[ny, nx]:\n                reach[ny, nx] = True\n                q.append((nx, ny))\n        # Up neighbor\n        if y > 0 and V[y - 1, x]:\n            nx, ny = x, y - 1\n            if not reach[ny, nx]:\n                reach[ny, nx] = True\n                q.append((nx, ny))\n        # Down neighbor\n        if y  L - 1 and V[y, x]:\n            nx, ny = x, y + 1\n            if not reach[ny, nx]:\n                reach[ny, nx] = True\n                q.append((nx, ny))\n\n    return reach\n\ndef build_system(L, H, V, reach_union):\n    \"\"\"\n    Build the sparse linear system A v = b for interior nodes that are reachable from either boundary.\n    Interior nodes are those with x in [1..L-2]. Boundary nodes at x=0 (V=1) and x=L-1 (V=0) are Dirichlet.\n    reach_union is boolean mask of nodes reachable from left or right boundaries.\n    Returns (A_csr, b, node_index, index_to_node).\n    node_index maps (x,y) -> idx in [0..n-1] for interior reachable nodes.\n    index_to_node is list mapping idx -> (x,y).\n    \"\"\"\n    # Map interior reachable nodes to indices\n    node_index = {}\n    index_to_node = []\n    for y in range(L):\n        for x in range(1, L - 1):\n            if reach_union[y, x]:\n                node_index[(x, y)] = len(index_to_node)\n                index_to_node.append((x, y))\n\n    n = len(index_to_node)\n    if n == 0:\n        # Empty system\n        A = coo_matrix((0, 0), dtype=float).tocsr()\n        b = np.zeros((0,), dtype=float)\n        return A, b, node_index, index_to_node\n\n    rows = []\n    cols = []\n    data = []\n    b = np.zeros(n, dtype=float)\n\n    def add_entry(i, j, val):\n        rows.append(i)\n        cols.append(j)\n        data.append(val)\n\n    for idx, (x, y) in enumerate(index_to_node):\n        diag = 0.0\n\n        # Neighbor to the left: (x-1, y) via H[y, x-1]\n        if x - 1 >= 0 and H[y, x - 1]:\n            diag += 1.0\n            if x - 1 == 0:\n                # Left boundary at V=1\n                b[idx] += 1.0 * 1.0\n            else:\n                # Interior node at (x-1, y)\n                if reach_union[y, x - 1]:\n                    jdx = node_index[(x - 1, y)]\n                    add_entry(idx, jdx, -1.0)\n                else:\n                    # Not in system (should not happen for an occupied bond unless excluded)\n                    pass\n\n        # Neighbor to the right: (x+1, y) via H[y, x]\n        if x  L - 1 and H[y, x]:\n            diag += 1.0\n            if x + 1 == L - 1:\n                # Right boundary at V=0 => no contribution to b\n                pass\n            else:\n                if reach_union[y, x + 1]:\n                    jdx = node_index[(x + 1, y)]\n                    add_entry(idx, jdx, -1.0)\n\n        # Neighbor above: (x, y-1) via V[y-1, x]\n        if y - 1 >= 0 and V[y - 1, x]:\n            diag += 1.0\n            if reach_union[y - 1, x]:\n                jdx = node_index.get((x, y - 1))\n                if jdx is not None:\n                    add_entry(idx, jdx, -1.0)\n                else:\n                    # Could be boundary column (but y-1 same column), handled by reach mask\n                    pass\n\n        # Neighbor below: (x, y+1) via V[y, x]\n        if y  L - 1 and V[y, x]:\n            diag += 1.0\n            if reach_union[y + 1, x]:\n                jdx = node_index.get((x, y + 1))\n                if jdx is not None:\n                    add_entry(idx, jdx, -1.0)\n\n        # Diagonal entry\n        add_entry(idx, idx, diag)\n\n    A = coo_matrix((data, (rows, cols)), shape=(n, n), dtype=float).tocsr()\n    return A, b, node_index, index_to_node\n\ndef compute_sigma(L, p, seed):\n    \"\"\"\n    Compute effective conductance sigma for one random instance at given L, p, with RNG seed.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    H, V = generate_bonds(L, p, rng)\n\n    # Reachable from left and right boundaries\n    reach_left = bfs_reachable(L, H, V, from_left=True)\n    reach_right = bfs_reachable(L, H, V, from_left=False)\n    reach_union = np.logical_or(reach_left, reach_right)\n\n    # Build and solve system\n    A, b, node_index, index_to_node = build_system(L, H, V, reach_union)\n\n    if A.shape[0] == 0:\n        # No interior reachable nodes => no conduction\n        return 0.0\n\n    try:\n        v = spsolve(A, b)\n    except Exception:\n        # Numerical fallback: treat as zero conductance if solve fails\n        return 0.0\n\n    # Map voltages back for easy lookup\n    volt = {}\n    for idx, (x, y) in enumerate(index_to_node):\n        volt[(x, y)] = v[idx]\n\n    # Net current injected at left boundary across occupied bonds to column x=1\n    total_current = 0.0\n    x_left_neighbor = 1\n    for y in range(L):\n        if H[y, 0]:  # Bond between (0,y) and (1,y)\n            vn = volt.get((x_left_neighbor, y))\n            if vn is not None:\n                total_current += (1.0 - vn)  # g=1\n\n    # sigma equals total current for unit voltage drop\n    return float(total_current)\n\ndef mean_sigma_over_samples(L, p, case_index, S):\n    \"\"\"\n    Compute mean sigma over S samples for given L and p with deterministic seeding.\n    \"\"\"\n    sigmas = []\n    for s in range(S):\n        seed = 12345 + 1000 * case_index + s\n        sigmas.append(compute_sigma(L, p, seed))\n    return float(np.mean(sigmas))\n\ndef estimate_t(p_values, sigma_means, pc=0.5):\n    \"\"\"\n    Estimate exponent t by linear regression of log(sigma) vs log(p - pc).\n    Returns -1.0 if fewer than two usable points.\n    \"\"\"\n    x = []\n    y = []\n    for p, sm in zip(p_values, sigma_means):\n        if sm > 0.0 and p > pc:\n            x.append(np.log(p - pc))\n            y.append(np.log(sm))\n    if len(x)  2:\n        return -1.0\n    x = np.array(x)\n    y = np.array(y)\n    # Ordinary least squares fit: y = t * x + c\n    t, c = np.polyfit(x, y, 1)\n    return float(t)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (case_index, L, p_list, samples S)\n        (0, 24, [0.55, 0.60, 0.65, 0.70], 12),\n        (1, 16, [0.52, 0.56, 0.60, 0.64], 12),\n        (2, 12, [0.505, 0.530, 0.560, 0.620], 20),\n    ]\n\n    pc = 0.5\n    results = []\n    for case_index, L, p_list, S in test_cases:\n        sigma_means = []\n        for p in p_list:\n            m = mean_sigma_over_samples(L, p, case_index, S)\n            sigma_means.append(m)\n        t_est = estimate_t(p_list, sigma_means, pc=pc)\n        # Round to three decimals for output\n        if np.isnan(t_est) or np.isinf(t_est):\n            t_est = -1.0\n        t_est_rounded = f\"{t_est:.3f}\"\n        results.append(t_est_rounded)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}