{
    "hands_on_practices": [
        {
            "introduction": "这项实践将带你深入了解模型机制的核心。在使用一个模型之前，我们必须理解它的行为。本练习要求你量化当模型的参数（边激活概率）不确定或变化时，预期结果（级联规模）会如何变化。通过计算级联规模的稳健界限和模型对参数的敏感度，你将对模型响应参数变化的动态获得深刻的定量理解，这是任何建模工作中的一项关键技能。",
            "id": "4309573",
            "problem": "考虑一个有向图，其节点集为 $V$，边集为 $E \\subseteq V \\times V$。在独立级联（Independent Cascade, IC）模型中，一个种子集 $S \\subseteq V$ 在时间 $t=0$ 时初始激活。每条有向边 $(u,v) \\in E$ 都有一个激活概率 $p_{uv} \\in [0,1]$。当节点 $u$ 被激活时，它有且仅有一次机会通过边 $(u,v)$ 激活节点 $v$，成功概率为 $p_{uv}$。所有边上的激活事件都是相互独立的。该过程以离散时间步进行，直到没有新的激活发生为止。令 $X(S,\\mathbf{p})$ 表示当激活概率由向量 $\\mathbf{p} = (p_e)_{e \\in E}$ 给出时，最终激活节点的随机数量。我们关注的量是最终级联规模的期望值 $\\mathbb{E}[X(S,\\mathbf{p})]$。\n\n在概率不确定的情况下，每条边 $(u,v)$ 都有一个区间 $[\\underline{p}_{uv}, \\overline{p}_{uv}]$（其中 $\\underline{p}_{uv} \\le \\overline{p}_{uv}$），代表未知激活概率的下界和上界。鲁棒性问题是要在所有与这些区间一致的 $\\mathbf{p}$ 上，确定 $\\mathbb{E}[X(S,\\mathbf{p})]$ 的最小值和最大值。敏感性问题要求计算关于 $\\mathbf{p}$ 的偏导数向量 $\\nabla \\mathbb{E}[X(S,\\mathbf{p})]$，并在不确定性区间内指定的 $\\mathbf{p}$ 处求值。\n\n仅从独立级联模型的基本定义、边激活的独立性以及期望的定义出发，编写一个完整且可运行的程序，为下面指定的每个测试用例计算：\n- 鲁棒下界 $L := \\min_{\\mathbf{p} \\in [\\underline{\\mathbf{p}}, \\overline{\\mathbf{p}}]} \\mathbb{E}[X(S,\\mathbf{p})]$。\n- 鲁棒上界 $U := \\max_{\\mathbf{p} \\in [\\underline{\\mathbf{p}}, \\overline{\\mathbf{p}}]} \\mathbb{E}[X(S,\\mathbf{p})]$。\n- 在中点概率 $\\mathbf{p}^{\\mathrm{mid}} := \\frac{1}{2}(\\underline{\\mathbf{p}} + \\overline{\\mathbf{p}})$ （其中加法和除法是按分量进行的）处求值的敏感性向量 $\\left(\\frac{\\partial}{\\partial p_e} \\mathbb{E}[X(S,\\mathbf{p})]\\right)_{e \\in E}$。\n\n所有计算都必须是概率意义上的精确计算，而非渐近或启发式的，并且必须从定义推导得出。对于有限图，可以通过枚举所有可能的“活性边”子图来进行精确计算，其中每条边以其激活概率独立地被包含进来，而从 $S$ 出发的可达性决定了最终的激活集。最终的期望值是所有活性边实现的可达集大小乘以其概率的总和。\n\n您的程序必须解决以下测试用例。对于每个测试用例，有向边 $E$ 按指定顺序列出，并且对于该顺序中的每条边 $e_i$，都给出了相应的下界和上界 $\\underline{p}_{e_i}$ 和 $\\overline{p}_{e_i}$。种子集 $S$ 作为节点列表提供。\n\n测试套件：\n- 测试用例 1：\n    - 节点：$V = \\{0,1,2,3,4\\}$，因此 $|V| = 5$。\n    - 有序边：$E = [(0,1),(1,2),(2,3),(1,3),(0,4),(4,3)]$，因此 $|E| = 6$。\n    - 下界：$\\underline{\\mathbf{p}} = [0.1,\\,0.2,\\,0.25,\\,0.15,\\,0.05,\\,0.3]$，顺序与 $E$ 相同。\n    - 上界：$\\overline{\\mathbf{p}} = [0.3,\\,0.5,\\,0.6,\\,0.5,\\,0.2,\\,0.7]$，顺序与 $E$ 相同。\n    - 种子集：$S = \\{0\\}$。\n- 测试用例 2：\n    - 节点：$V = \\{0,1\\}$，因此 $|V| = 2$。\n    - 有序边：$E = [(0,1)]$，因此 $|E| = 1$。\n    - 下界：$\\underline{\\mathbf{p}} = [0.2]$。\n    - 上界：$\\overline{\\mathbf{p}} = [0.2]$。\n    - 种子集：$S = \\{0\\}$。\n- 测试用例 3：\n    - 节点：$V = \\{0,1,2,3\\}$，因此 $|V| = 4$。\n    - 有序边：$E = [(0,1),(0,2),(1,3),(2,3)]$，因此 $|E| = 4$。\n    - 下界：$\\underline{\\mathbf{p}} = [0.1,\\,0.1,\\,0.2,\\,0.2]$。\n    - 上界：$\\overline{\\mathbf{p}} = [0.9,\\,0.8,\\,0.7,\\,0.6]$。\n    - 种子集：$S = \\{0\\}$。\n\n对于每个测试用例，要求的输出是：\n- 鲁棒下界 $L$，作为一个实数。\n- 鲁棒上界 $U$，作为一个实数。\n- 在 $\\mathbf{p}^{\\mathrm{mid}}$ 处的敏感性向量，按与 $E$ 相同的顺序列出，作为实数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个实数列表，顺序如下：首先是 $L$，然后是 $U$，接着是在 $\\mathbf{p}^{\\mathrm{mid}}$ 处的敏感性向量的分量。例如，包含三个测试用例的一行应类似于 $[[L_1,U_1,d_{1,1},\\dots,d_{1,|E_1|}],[L_2,U_2,d_{2,1},\\dots,d_{2,|E_2|}],[L_3,U_3,d_{3,1},\\dots,d_{3,|E_3|}]]$.\n\n没有物理单位，也没有角度单位；所有输出都是无单位的实数。请严格使用小数表示任何与比例相关的量。\n\n您的程序必须是自包含的，不需要用户输入，并通过与上述定义一致的有限枚举来计算精确值。",
            "solution": "该问题要求在概率不确定性下，计算独立级联（IC）模型中期望级联规模的鲁棒界和敏感性。我们首先对期望级联规模 $\\mathbb{E}[X(S,\\mathbf{p})]$ 进行形式化。\n\n该随机过程的一个特定结果对应于一个“活性边子图” $G' = (V, E')$，其中 $E' \\subseteq E$ 是成功激活的边的集合。由于激活事件的相互独立性，实现一个特定的活性边子图 $G'$ 的概率由下式给出：\n$$\n\\mathbb{P}(G' | \\mathbf{p}) = \\left( \\prod_{e \\in E'} p_e \\right) \\left( \\prod_{e \\in E \\setminus E'} (1 - p_e) \\right)\n$$\n对于一个给定的活性边子图 $G'=(V, E')$，最终的激活节点集是从初始种子集 $S$ 可达的所有节点的集合。我们将其表示为 $R(S, G')$。级联的规模即为 $|R(S, G')|$。\n\n根据期望的定义，期望级联规模是所有可能的活性边子图的级联规模与其相应概率加权的和：\n$$\n\\mathbb{E}[X(S,\\mathbf{p})] = \\sum_{E' \\subseteq E} |R(S, (V, E'))| \\cdot \\mathbb{P}((V, E') | \\mathbf{p})\n$$\n这个表达式是关于概率变量 $\\{p_e\\}_{e\\in E}$ 的多线性多项式。对于边数较少的有限图，此公式允许通过枚举所有 $2^{|E|}$ 个子图来进行精确计算。\n\n**鲁棒性分析：下界和上界（$L$ 和 $U$）**\n\n为了确定 $\\mathbb{E}[X(S,\\mathbf{p})]$ 在由 $\\mathbf{p} \\in [\\underline{\\mathbf{p}}, \\overline{\\mathbf{p}}]$ 定义的超矩形上的最小值和最大值，我们首先分析该函数对任意边 $e_k \\in E$ 的单个边概率 $p_k$ 的依赖性。我们计算偏导数 $\\frac{\\partial}{\\partial p_k} \\mathbb{E}[X(S,\\mathbf{p})]$。\n\n我们将对 $E' \\subseteq E$ 的求和分为两部分：一部分是 $e_k \\in E'$，另一部分是 $e_k \\notin E'$。任何不包含 $e_k$ 的 $E' \\subseteq E$ 都可以写成 $E'' \\subseteq E \\setminus \\{e_k\\}$。任何包含 $e_k$ 的 $E' \\subseteq E$ 都可以写成 $E'' \\cup \\{e_k\\}$，其中 $E'' \\subseteq E \\setminus \\{e_k\\}$。令 $\\mathbb{P}_{\\neg k}(E'')$ 表示从 $E \\setminus \\{e_k\\}$ 中取边的子图 $(V, E'')$ 的概率。\n$$\n\\mathbb{E}[X(S,\\mathbf{p})] = \\sum_{E'' \\subseteq E \\setminus \\{e_k\\}} \\left[ |R(S, (V, E''))| (1-p_k) + |R(S, (V, E'' \\cup \\{e_k\\}))| p_k \\right] \\mathbb{P}_{\\neg k}(E'')\n$$\n对 $p_k$ 求偏导数：\n$$\n\\frac{\\partial}{\\partial p_k} \\mathbb{E}[X(S,\\mathbf{p})] = \\sum_{E'' \\subseteq E \\setminus \\{e_k\\}} \\left[ |R(S, (V, E'' \\cup \\{e_k\\}))| - |R(S, (V, E''))| \\right] \\mathbb{P}_{\\neg k}(E'')\n$$\n向图中添加一条边时，从任何源节点可达的节点集只会增大或保持不变。因此，对于任何 $E''$，都有 $|R(S, (V, E'' \\cup \\{e_k\\}))| \\ge |R(S, (V, E''))|$。由于概率 $\\mathbb{P}_{\\neg k}(E'')$ 是非负的，所以和中的每一项都是非负的。因此，\n$$\n\\frac{\\partial}{\\partial p_k} \\mathbb{E}[X(S,\\mathbf{p})] \\ge 0\n$$\n这表明 $\\mathbb{E}[X(S,\\mathbf{p})]$ 是关于每个概率分量 $p_k$ 的单调非递减函数。因此，要找到函数在定义域 $[\\underline{\\mathbf{p}}, \\overline{\\mathbf{p}}]$ 上的最小值和最大值，我们只需在该超矩形的顶点处进行求值。当所有概率都取其可能的最低值时，达到最小值 $L$；当所有概率都取其最高值时，达到最大值 $U$。\n$$\nL := \\min_{\\mathbf{p}} \\mathbb{E}[X(S,\\mathbf{p})] = \\mathbb{E}[X(S, \\underline{\\mathbf{p}})]\n$$\n$$\nU := \\max_{\\mathbf{p}} \\mathbb{E}[X(S,\\mathbf{p})] = \\mathbb{E}[X(S, \\overline{\\mathbf{p}})]\n$$\n\n**敏感性分析：梯度向量（$\\nabla \\mathbb{E}$）**\n\n敏感性向量是梯度 $\\nabla \\mathbb{E}[X(S,\\mathbf{p})]$，它由每条边 $e_k \\in E$ 的偏导数 $\\frac{\\partial}{\\partial p_k} \\mathbb{E}[X(S,\\mathbf{p})]$ 组成。上面推导出的偏导数公式提供了一种直接的计算方法。对于每条边 $e_k$，我们必须计算：\n$$\n\\frac{\\partial}{\\partial p_k} \\mathbb{E}[X(S,\\mathbf{p})]\\bigg|_{\\mathbf{p}=\\mathbf{p}^{\\mathrm{mid}}} = \\sum_{E'' \\subseteq E \\setminus \\{e_k\\}} \\left[ |R(S, (V, E'' \\cup \\{e_k\\}))| - |R(S, (V, E''))| \\right] \\mathbb{P}_{\\neg k}(E'')\\bigg|_{\\mathbf{p}=\\mathbf{p}^{\\mathrm{mid}}}\n$$\n项 $|R(S, (V, E'' \\cup \\{e_k\\}))| - |R(S, (V, E''))|$ 表示在其他活性边恰好为集合 $E''$ 的条件下，由于边 $e_k$ 的存在而导致的激活节点数量的边际增加。\n\n**算法设计**\n\n$L$、$U$ 和敏感性向量的计算可以基于这些推导出的公式来实现。\n\n1.  一个函数 `compute_expected_cascade(graph_params, probabilities)` 将实现主要的期望公式。它会遍历所有 $2^{|E|}$ 个子图。对于每个子图 $E'$，它计算其概率 $\\mathbb{P}((V,E')|\\mathbf{p})$ 和可达集的大小 $|R(S,(V,E'))|$。后者通过从种子节点 $S$ 开始的广度优先搜索（BFS）找到。大小和概率的乘积相加以得出最终期望。\n2.  通过使用下界概率向量 $\\underline{\\mathbf{p}}$ 调用此函数来计算下界 $L$。\n3.  通过使用上界概率向量 $\\overline{\\mathbf{p}}$ 调用此函数来计算上界 $U$。\n4.  一个函数 `compute_gradient(graph_params, probabilities)` 将计算敏感性向量。它遍历每条边 $e_k \\in E$。对于每个 $e_k$，它遍历 $E \\setminus \\{e_k\\}$ 的所有 $2^{|E|-1}$ 个子图 $E''$。在每个内层循环中，它使用 $\\mathbf{p}^{\\mathrm{mid}}$ 的相应分量计算 $E''$ 的概率，并计算级联规模的差异 $|R(S, (V, E'' \\cup \\{e_k\\}))| - |R(S, (V, E''))|$，同样使用 BFS 计算可達性。将这些乘积相加以求得在 $\\mathbf{p}^{\\mathrm{mid}}$ 处的偏导数 $\\frac{\\partial \\mathbb{E}}{\\partial p_k}$。\n\n这种基于枚举子图的方法对于测试用例中指定的小图规模是计算上可行的，并提供了从第一性原理推导出的精确解。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"num_nodes\": 5,\n            \"edges\": [(0, 1), (1, 2), (2, 3), (1, 3), (0, 4), (4, 3)],\n            \"p_lower\": [0.1, 0.2, 0.25, 0.15, 0.05, 0.3],\n            \"p_upper\": [0.3, 0.5, 0.6, 0.5, 0.2, 0.7],\n            \"seed_set\": {0},\n        },\n        {\n            \"num_nodes\": 2,\n            \"edges\": [(0, 1)],\n            \"p_lower\": [0.2],\n            \"p_upper\": [0.2],\n            \"seed_set\": {0},\n        },\n        {\n            \"num_nodes\": 4,\n            \"edges\": [(0, 1), (0, 2), (1, 3), (2, 3)],\n            \"p_lower\": [0.1, 0.1, 0.2, 0.2],\n            \"p_upper\": [0.9, 0.8, 0.7, 0.6],\n            \"seed_set\": {0},\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = get_results_for_case(case)\n        all_results.append(result)\n\n    # Format the final output string as specified.\n    # e.g., [[L1,U1,d1,...],[L2,U2,d2,...]]\n    output_str = \"[\" + \",\".join(\n        \"[\" + \",\".join(f\"{x:.10f}\" for x in res) + \"]\" for res in all_results\n    ) + \"]\"\n    print(output_str)\n\n\ndef get_results_for_case(case):\n    \"\"\"\n    Computes L, U, and sensitivity for a single test case.\n    \"\"\"\n    num_nodes = case[\"num_nodes\"]\n    edges = case[\"edges\"]\n    p_lower = np.array(case[\"p_lower\"])\n    p_upper = np.array(case[\"p_upper\"])\n    seed_set = case[\"seed_set\"]\n\n    # Calculate L (lower bound)\n    L = compute_expected_cascade(num_nodes, edges, seed_set, p_lower)\n\n    # Calculate U (upper bound)\n    U = compute_expected_cascade(num_nodes, edges, seed_set, p_upper)\n    \n    # Calculate sensitivities at midpoint\n    p_mid = 0.5 * (p_lower + p_upper)\n    sensitivity_vector = compute_gradient(num_nodes, edges, seed_set, p_mid)\n\n    return [L, U] + sensitivity_vector\n\n\ndef bfs(num_nodes, edge_list, start_nodes):\n    \"\"\"\n    Performs a Breadth-First Search to find all reachable nodes.\n    \n    Args:\n        num_nodes (int): Total number of nodes in the graph.\n        edge_list (list): A list of (u, v) tuples representing live edges.\n        start_nodes (set): The set of starting nodes for the search.\n\n    Returns:\n        set: The set of nodes reachable from start_nodes.\n    \"\"\"\n    if not start_nodes:\n        return set()\n\n    adj = [[] for _ in range(num_nodes)]\n    for u, v in edge_list:\n        adj[u].append(v)\n    \n    q = deque(list(start_nodes))\n    visited = set(start_nodes)\n    \n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if v not in visited:\n                visited.add(v)\n                q.append(v)\n    return visited\n\ndef compute_expected_cascade(num_nodes, edges, seed_set, probabilities):\n    \"\"\"\n    Computes the expected cascade size by enumerating all live-edge subgraphs.\n    \"\"\"\n    num_edges = len(edges)\n    total_expected_size = 0.0\n\n    # Iterate through all 2^m possible live-edge subgraphs\n    for i in range(1  num_edges):\n        live_edges = []\n        subgraph_prob = 1.0\n        \n        for j in range(num_edges):\n            p_j = probabilities[j]\n            if (i >> j)  1:  # If j-th edge is in the live set\n                live_edges.append(edges[j])\n                subgraph_prob *= p_j\n            else:\n                subgraph_prob *= (1.0 - p_j)\n        \n        # Calculate cascade size for this subgraph\n        reachable_nodes = bfs(num_nodes, live_edges, seed_set)\n        cascade_size = len(reachable_nodes)\n        \n        total_expected_size += cascade_size * subgraph_prob\n        \n    return total_expected_size\n\ndef compute_gradient(num_nodes, edges, seed_set, probabilities):\n    \"\"\"\n    Computes the gradient of the expected cascade size.\n    \"\"\"\n    num_edges = len(edges)\n    gradient = [0.0] * num_edges\n\n    for k in range(num_edges):\n        # Edges excluding e_k\n        other_edges = edges[:k] + edges[k+1:]\n        other_probs = np.concatenate((probabilities[:k], probabilities[k+1:]))\n        num_other_edges = len(other_edges)\n        \n        derivative_k = 0.0\n\n        # Iterate through all subgraphs of E \\ {e_k}\n        for i in range(1  num_other_edges):\n            subgraph_prime = []\n            prob_subgraph_prime = 1.0\n            \n            for j in range(num_other_edges):\n                p_j = other_probs[j]\n                if (i >> j)  1:\n                    subgraph_prime.append(other_edges[j])\n                    prob_subgraph_prime *= p_j\n                else:\n                    prob_subgraph_prime *= (1.0 - p_j)\n\n            # Cascade size without edge e_k\n            size_without_ek = len(bfs(num_nodes, subgraph_prime, seed_set))\n            \n            # Cascade size with edge e_k\n            subgraph_with_ek = subgraph_prime + [edges[k]]\n            size_with_ek = len(bfs(num_nodes, subgraph_with_ek, seed_set))\n            \n            derivative_k += (size_with_ek - size_without_ek) * prob_subgraph_prime\n        \n        gradient[k] = derivative_k\n        \n    return gradient\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "现实世界中的信息传播很少在真空中发生；通常是多种思想、产品或病毒相互竞争以获得接受。这项实践将基本的独立级联模型扩展到一个竞争场景。你将通过编程实现一个模拟，来确定每种传染在竞争中的预期成功率，并需要处理当影响同时发生时的优先权规则，这是竞争性扩散模型的一个关键特征。",
            "id": "4309576",
            "problem": "给定一个关于有限有向图上多个传染病竞争性扩散的形式化模型，该模型遵循独立级联（IC）框架。考虑一个有向图 $G=(V,E)$，一个表示传染病数量的整数 $K \\in \\mathbb{N}$，一个由序列 $(1,2,\\dots,K)$ 给出的传染病优先级顺序（其中较小的索引意味着较高的优先级），每个传染病 $k \\in \\{1,\\dots,K\\}$ 的一个种子集合 $S_k \\subseteq V$，以及对于每个传染病 $k$ 的一组独立激活概率 $\\{p_k(u,v)\\}_{(u,v)\\in E}$，其中 $p_k(u,v) \\in [0,1]$ 是传染病 $k$ 沿有向边 $(u,v)$ 的激活尝试成功的概率。所有激活事件在边与边之间以及传染病与传染病之间都是独立的。\n\n独立级联（IC）过程在离散时间步中展开，如下所示：在时间 $t=0$ 时，每个属于至少一个种子集合的节点 $v \\in V$ 被认为仅对一个传染病激活，该传染病在需要时由优先级顺序确定（也就是说，如果 $v \\in S_i \\cap S_j$ 且 $i \\neq j$，则 $v$ 被分配给索引较小的传染病）。在随后的每个整数时间 $t=1,2,\\dots$，任何在时间 $t-1$ 刚被传染病 $k$ 激活的节点，都有一次机会去激活其尚未被任何传染病激活的出邻居 $w$。传染病 $k$ 从 $v$到 $w$ 沿边 $(v,w)$ 的激活尝试以概率 $p_k(v,w)$ 成功，且独立于所有其他尝试。如果在同一时间步内，有多个传染病试图激活同一个节点 $w$，则节点 $w$ 会被在此时刻尝试激活它的传染病中索引最小的那个激活。一旦一个节点被某个传染病激活，它将保持对该传染病激活的状态，此后不再改变。\n\n你的任务是，对于以下每个测试用例，计算在过程终止后，最终被每种传染病激活的节点的精确期望数量。该期望是针对独立级联模型指定的所有随机性来源计算的。最终值必须根据给定的概率精确计算，而不是通过蒙特卡洛模拟。\n\n你可以假设以下基本原理：上述独立级联模型的定义；激活事件在边与边之间以及传染病与传染病之间的独立性；以及与活边渗透观点的著名等价性，在该观点中，每条有向边 $(u,v)$ 对于传染病 $k$ 以概率 $p_k(u,v)$ 被独立地声明为活边，否则为阻断边，并且采纳结果由这些活边子图中的可达性以及指定的离散时间平局打破规则共同确定。\n\n实现一个程序，对所有传染病的所有活边实现进行精确枚举，并计算预期的采纳数量。使用以下测试套件。\n\n测试用例 1：\n- 节点 $V=\\{0,1,2\\}$。\n- 有向边 $E=\\{(0,1),(0,2),(2,1)\\}$。\n- 传染病数量 $K=2$，优先级顺序为 $(1 \\succ 2)$。\n- 种子集合：$S_1=\\{0\\}$, $S_2=\\{2\\}$。\n- 激活概率：\n  - 对于传染病 1：$p_1(0,1)=0.7$, $p_1(0,2)=0.4$, $p_1(2,1)=0.1$。\n  - 对于传染病 2：$p_2(0,1)=0.2$, $p_2(0,2)=0.6$, $p_2(2,1)=0.9$。\n\n测试用例 2：\n- 节点 $V=\\{0,1,2,3\\}$。\n- 有向边 $E=\\{(0,1),(1,2),(0,2),(2,3),(1,3)\\}$。\n- 传染病数量 $K=3$，优先级顺序为 $(1 \\succ 2 \\succ 3)$。\n- 种子集合：$S_1=\\{0\\}$, $S_2=\\{1\\}$, $S_3=\\{2\\}$。\n- 激活概率：\n  - 对于传染病 1：$p_1(0,1)=0.9$, $p_1(1,2)=0.0$, $p_1(0,2)=0.5$, $p_1(2,3)=0.6$, $p_1(1,3)=0.7$。\n  - 对于传染病 2：$p_2(0,1)=0.0$, $p_2(1,2)=0.8$, $p_2(0,2)=0.0$, $p_2(2,3)=0.6$, $p_2(1,3)=0.4$。\n  - 对于传染病 3：$p_3(0,1)=0.0$, $p_3(1,2)=0.0$, $p_3(0,2)=0.0$, $p_3(2,3)=0.9$, $p_3(1,3)=0.0$。\n\n测试用例 3 (边界情况)：\n- 节点 $V=\\{0,1\\}$。\n- 有向边 $E=\\{(0,1)\\}$。\n- 传染病数量 $K=2$，优先级顺序为 $(1 \\succ 2)$。\n- 种子集合：$S_1=\\emptyset$, $S_2=\\{0\\}$。\n- 激活概率：\n  - 对于传染病 1：$p_1(0,1)=0.0$。\n  - 对于传染病 2：$p_2(0,1)=1.0$。\n\n输出要求：\n- 对于每个测试用例，计算一个列表 $[\\mathbb{E}[X_1],\\dots,\\mathbb{E}[X_K]]$，其中 $\\mathbb{E}[X_k]$ 是最终被传染病 $k$ 激活的节点的期望数量。每个 $\\mathbb{E}[X_k]$ 必须四舍五入到恰好 $6$ 位小数。\n- 将所有测试用例的结果按顺序聚合成一个扁平列表，通过在每个测试用例内部按传染病索引的顺序进行连接。也就是说，生成一个单一列表 $[r_{1,1},\\dots,r_{1,K_1},r_{2,1},\\dots,r_{2,K_2},\\dots]$，其中 $r_{i,k}$ 表示测试用例 $i$ 中传染病 $k$ 的四舍五入后的期望数量。\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_{1,1},r_{1,2},r_{2,1}]$）。不应打印任何其他文本。\n\n角度单位不适用。不涉及物理单位。所有数值答案必须按规定报告为四舍五入到 $6$ 位小数的小数。",
            "solution": "该问题要求计算在有向图上几种相互竞争的传染病传播后，每种传染病激活的节点的精确期望数量。其动态遵循一个竞争性的独立级联（IC）模型，并使用固定的优先级顺序来打破平局。要求的是直接的解析解，而非蒙特卡洛模拟。\n\n我们将使用的基本原理是期望的线性性质。由传染病 $k$ 激活的节点的期望数量，记为 $\\mathbb{E}[X_k]$，是图中每个节点 $v$ 被传染病 $k$ 激活的概率之和。\n$$\n\\mathbb{E}[X_k] = \\sum_{v \\in V} P(v \\text{ is activated by } k)\n$$\n因此，问题的核心是计算每个节点 $v$ 和每种传染病 $k$ 的 $P(v \\text{ is activated by } k)$。\n\n为了计算这个概率，我们必须考虑随机过程的所有可能结果。问题陈述通过提及 IC 模型与“活边渗透观点”的等价性提供了一个关键提示。在此框架下，对于每种传染病 $k$ 和每条边 $(u,v) \\in E$，该边以概率 $p_k(u,v)$ 被声明为对 $k$ “活化”，否则为“阻断”，且与所有其他边和传染病独立。所有传染病的所有活边和阻断边的特定配置构成一个单独的“可能世界”或实现，记为 $\\omega$。由于所有这些事件都是独立的，特定世界 $\\omega$ 发生的概率是每个独立边-传染病状态概率的乘积：\n$$\nP(\\omega) = \\prod_{k=1}^{K} \\prod_{(u,v) \\in E} P(\\text{state of edge } (u,v) \\text{ for contagion } k \\text{ in } \\omega)\n$$\n其中，如果边是活边，则 $P(\\text{state})$ 为 $p_k(u,v)$，如果边是阻断边，则为 $1-p_k(u,v)$。\n\n总期望值可以通过对所有可能世界求和来计算：\n$$\n\\mathbb{E}[X_k] = \\sum_{\\omega} P(\\omega) \\cdot N_k(\\omega)\n$$\n其中 $N_k(\\omega)$ 是在特定世界 $\\omega$ 中被传染病 $k$ 激活的节点数量。问题陈述指出，我们必须执行“对所有活边实现的精确枚举”。对于一个有 $|E|$ 条边和 $K$ 种传染病的图，存在 $K \\cdot |E|$ 个独立的二元随机事件（每条边对每种传染病是活化还是阻断）。这导致 $2^{K \\cdot |E|}$ 个不同的可能世界。对于测试用例中提供的小图，这个数字在计算上是可控的，允许采用直接枚举策略。\n\n算法流程如下：\n1.  将每种传染病的期望数量 $\\mathbb{E}[X_k]$ 初始化为 $0$。\n2.  遍历从 $1$ 到 $2^{K \\cdot |E|}$ 的每一个可能的“世界” $\\omega$。\n3.  对于每个世界 $\\omega$：\n    a. 通过将每种传染病对应的活边/阻断边配置的概率相乘，来计算其概率 $P(\\omega)$。如果 $P(\\omega) = 0$，则该世界无贡献，可以跳过。\n    b. 对于这个确定的世界，确定每个节点的最终状态。在给定的世界中，每种传染病的活边集合是固定的。结果由哪种传染病首先到达一个节点决定。“到达时间”是在相应活边图中最短路径的长度。\n    c. 在世界 $\\omega$ 中确定节点状态的详细过程是：\n        i.   **初始化 ($t=0$):** 首先，确定初始激活节点的集合。一个存在于一个或多个种子集合 $S_j$ 中的节点 $v$ 在 $t=0$ 时被激活。如果它属于多个种子集合，它将被分配给优先级最高的传染病 $k$（即索引最小），即 $k = \\min\\{j \\mid v \\in S_j\\}$。让我们将初始时被传染病 $k$ 激活的节点集合表示为 $A_k^{(0)}$。这些节点为其各自的激活传染病计数。\n        ii.  **最短路径计算：** 对每种传染病 $k$，构建其活边子图 $G_k(\\omega)$。然后，计算从其初始激活集合 $A_k^{(0)}$ 到图中每个其他节点 $v$ 的最短路径距离 $d_k(v)$。广度优先搜索（BFS）是执行此操作的标准算法，从 $A_k^{(0)}$ 中的所有节点同时开始。如果一个节点 $v$ 不可达，其距离为 $d_k(v) = \\infty$。距离 $d_k(v)$ 代表传染病 $k$ 首次到达节点 $v$ 的时间步。\n        iii. **赢家确定：** 对于每个在 $t=0$ 时未被激活的节点 $v$，找到其最早可能的激活时间 $t_{\\min}(v) = \\min_{k \\in \\{1,\\dots,K\\}} \\{d_k(v)\\}$。如果 $t_{\\min}(v) = \\infty$，则该节点永远不会被激活。否则，该节点将被能够在 $t_{\\min}(v)$ 时激活它的所有传染病中优先级最高的那个 $k_{\\text{winner}}$ 激活。也就是说，$k_{\\text{winner}} = \\min\\{k \\mid d_k(v) = t_{\\min}(v)\\}$。\n    d.  **计数与更新：** 在确定每个节点的获胜传染病后，计算每种传染病激活的节点总数 $N_k(\\omega)$。通过加上该世界的贡献来更新总期望计数：$\\mathbb{E}[X_k] \\mathrel{+}= P(\\omega) \\cdot N_k(\\omega)$。\n4.  遍历所有可能的世界后，累积的值就是最终的精确期望计数。然后将这些值按要求四舍五入到 $6$ 位小数。\n\n该方法通过系统地探索扩散过程的整个概率空间，提供了一个精确、确定性的解决方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the solver.\n    \"\"\"\n\n    # Test case 1\n    tc1_nodes = {0, 1, 2}\n    tc1_edges = {(0, 1), (0, 2), (2, 1)}\n    tc1_K = 2\n    tc1_seeds = [{0}, {2}]\n    tc1_probs = [\n        # Probs for Contagion 1\n        {(0, 1): 0.7, (0, 2): 0.4, (2, 1): 0.1},\n        # Probs for Contagion 2\n        {(0, 1): 0.2, (0, 2): 0.6, (2, 1): 0.9}\n    ]\n\n    # Test case 2\n    tc2_nodes = {0, 1, 2, 3}\n    tc2_edges = {(0, 1), (1, 2), (0, 2), (2, 3), (1, 3)}\n    tc2_K = 3\n    tc2_seeds = [{0}, {1}, {2}]\n    tc2_probs = [\n        # Probs for Contagion 1\n        {(0, 1): 0.9, (1, 2): 0.0, (0, 2): 0.5, (2, 3): 0.6, (1, 3): 0.7},\n        # Probs for Contagion 2\n        {(0, 1): 0.0, (1, 2): 0.8, (0, 2): 0.0, (2, 3): 0.6, (1, 3): 0.4},\n        # Probs for Contagion 3\n        {(0, 1): 0.0, (1, 2): 0.0, (0, 2): 0.0, (2, 3): 0.9, (1, 3): 0.0}\n    ]\n\n    # Test case 3\n    tc3_nodes = {0, 1}\n    tc3_edges = {(0, 1)}\n    tc3_K = 2\n    tc3_seeds = [set(), {0}]\n    tc3_probs = [\n        # Probs for Contagion 1\n        {(0, 1): 0.0},\n        # Probs for Contagion 2\n        {(0, 1): 1.0}\n    ]\n\n    test_cases = [\n        (tc1_nodes, tc1_edges, tc1_K, tc1_seeds, tc1_probs),\n        (tc2_nodes, tc2_edges, tc2_K, tc2_seeds, tc2_probs),\n        (tc3_nodes, tc3_edges, tc3_K, tc3_seeds, tc3_probs),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        nodes, edges, K, seed_sets, probabilities = case\n        result = _compute_expectations(nodes, edges, K, seed_sets, probabilities)\n        all_results.extend(result)\n\n    formatted_results = [f\"{x:.6f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef _compute_expectations(nodes, edges, K, seed_sets, probabilities):\n    \"\"\"\n    Computes the exact expected number of active nodes for each contagion.\n    \"\"\"\n    num_nodes = len(nodes)\n    num_edges = len(edges)\n    \n    expected_counts = np.zeros(K)\n    \n    # Use a sorted list of edges for a consistent mapping from bits to edge states.\n    ordered_edges = sorted(list(edges)) \n    \n    num_edge_contagion_pairs = num_edges * K\n    total_worlds = 1  num_edge_contagion_pairs\n\n    for world_id in range(total_worlds):\n        world_prob = 1.0\n        live_graphs = {k: {u: [] for u in nodes} for k in range(1, K + 1)}\n        \n        # 1. Construct the world (live graphs and probability)\n        bit_pos = 0\n        for k in range(1, K + 1):\n            for u, v in ordered_edges:\n                p_live = probabilities[k - 1].get((u, v), 0.0)\n                is_live = (world_id >> bit_pos)  1\n                \n                if is_live:\n                    world_prob *= p_live\n                    live_graphs[k][u].append(v)\n                else:\n                    world_prob *= (1.0 - p_live)\n                bit_pos += 1\n        \n        if world_prob == 0:\n            continue\n\n        # 2. Determine initial active sets at t=0 based on seed sets and priority\n        initial_active_nodes = {}\n        for k in range(1, K + 1):\n            for seed_node in seed_sets[k - 1]:\n                if seed_node not in initial_active_nodes:\n                    initial_active_nodes[seed_node] = k\n        \n        # 3. Compute shortest path distances for each contagion from its initial active set\n        all_distances = {}\n        for k in range(1, K + 1):\n            distances = {node: float('inf') for node in nodes}\n            queue = deque()\n            \n            for node, active_k in initial_active_nodes.items():\n                if active_k == k:\n                    if distances[node] == float('inf'):\n                        distances[node] = 0\n                        queue.append(node)\n            \n            while queue:\n                u = queue.popleft()\n                for v in live_graphs[k].get(u, []):\n                    if distances[v] == float('inf'):\n                        distances[v] = distances[u] + 1\n                        queue.append(v)\n            all_distances[k] = distances\n\n        # 4. Determine final state of each node and count for this world\n        world_counts = np.zeros(K)\n        for node in nodes:\n            # Nodes activated at t=0 (seeds)\n            if node in initial_active_nodes:\n                winner_k = initial_active_nodes[node]\n                world_counts[winner_k - 1] += 1\n                continue\n\n            # For non-seed nodes, find the winning contagion based on minimum time and priority\n            min_dist = float('inf')\n            winner_k = -1\n\n            for k in range(1, K + 1):\n                dist = all_distances[k][node]\n                if dist  min_dist:\n                    min_dist = dist\n                    winner_k = k\n            \n            if winner_k != -1:\n                world_counts[winner_k - 1] += 1\n        \n        # 5. Add this world's weighted contribution to the total expectation\n        expected_counts += world_prob * world_counts\n        \n    return expected_counts\n\nsolve()\n\n```"
        }
    ]
}