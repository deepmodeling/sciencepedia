{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握线性阈值模型，我们必须从其基本机理入手。第一个练习将指导你在一个定义明确的小型网络上，进行单步的扩散过程模拟。通过手动计算每个节点的社会信号，并将其与采纳阈值进行比较，你将具体地理解影响是如何根据模型规则传播的，为更复杂的分析打下坚实的基础。",
            "id": "4123782",
            "problem": "考虑一个住宅能源系统中的程式化社会技术转型，其中家庭根据其本地网络中的社会影响来决定是否采用某项需求响应技术。本地影响网络由一个覆盖节点 $1,2,3,4,5$ 的加权无向邻接矩阵 $A \\in \\mathbb{R}^{5 \\times 5}$ 表示，其中 $A_{ij} = A_{ji} \\geq 0$ 表示节点 $i$ 和 $j$ 之间社会联系的强度。邻接矩阵为\n$$\nA \\;=\\; \\begin{pmatrix}\n0  & 0.6 & 0 & 0.4 & 0 \\\\\n0.6 & 0 & 0.7 & 0.5 & 0 \\\\\n0 & 0.7 & 0 & 0 & 0.3 \\\\\n0.4 & 0.5 & 0 & 0 & 0.6 \\\\\n0 & 0 & 0.3 & 0.6 & 0\n\\end{pmatrix}.\n$$\n在离散时间 $t \\in \\mathbb{N}$，每个节点 $i$ 都有一个采纳状态 $x_i(t) \\in \\{0,1\\}$，其中 $x_i(t)=1$ 表示节点 $i$ 在时间 $t$ 或之前已经采纳了该技术。采纳是不可逆的：一旦 $x_i(t)=1$，那么对于所有 $t' \\geq t$，都有 $x_i(t')=1$。现定义影响归一化线性阈值规则如下。对于时间 $t$ 的节点 $i$，计算其归一化社会信号\n$$\ns_i(t) \\;=\\; \\frac{\\sum_{j=1}^{5} A_{ij} \\, x_j(t)}{\\sum_{j=1}^{5} A_{ij}},\n$$\n我们约定，对于所考虑的所有节点 $i$，分母都严格为正。线性阈值模型 (LTM) 的更新在所有节点间是同步的，并由下式给出\n$$\nx_i(t+1) \\;=\\; \\begin{cases}\n1,  \\text{if } x_i(t)=1 \\text{ or } s_i(t) \\geq \\theta_i, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n所有节点的阈值是统一的，即 $\\theta_i = \\theta = 0.5$。假设在时间 $t=0$ 时的初始采纳者是节点 $1$ 和 $3$，因此 $x_1(0)=1$, $x_3(0)=1$，且 $x_2(0)=x_4(0)=x_5(0)=0$。模拟一次到时间 $t=1$ 的同步 LTM 更新，并确定新增采纳者的数量（即满足 $x_i(0)=0$ 且 $x_i(1)=1$ 的节点 $i$ 的数量）。请以单个整数形式提供您的答案；无需四舍五入。",
            "solution": "该问题已经过验证。\n\n### 第 1 步：提取已知条件\n- 系统由 5 个节点组成，索引为 $i, j \\in \\{1, 2, 3, 4, 5\\}$。\n- 社会影响网络由一个加权无向邻接矩阵 $A \\in \\mathbb{R}^{5 \\times 5}$ 给出：\n$$\nA \\;=\\; \\begin{pmatrix}\n0  & 0.6 & 0 & 0.4 & 0 \\\\\n0.6 & 0 & 0.7 & 0.5 & 0 \\\\\n0 & 0.7 & 0 & 0 & 0.3 \\\\\n0.4 & 0.5 & 0 & 0 & 0.6 \\\\\n0 & 0 & 0.3 & 0.6 & 0\n\\end{pmatrix}\n$$\n- 在离散时间 $t \\in \\mathbb{N}$，节点 $i$ 的采纳状态为 $x_i(t) \\in \\{0,1\\}$。\n- 采纳是不可逆的：如果 $x_i(t)=1$，那么对于所有 $t' \\geq t$，都有 $x_i(t')=1$。\n- 在时间 $t$，节点 $i$ 的归一化社会信号为 $s_i(t) = \\frac{\\sum_{j=1}^{5} A_{ij} \\, x_j(t)}{\\sum_{j=1}^{5} A_{ij}}$。对于所有 $i$，分母都严格为正。\n- LTM 更新规则是同步的，并由下式给出：\n$$\nx_i(t+1) \\;=\\; \\begin{cases}\n1,  \\text{if } x_i(t)=1 \\text{ or } s_i(t) \\geq \\theta_i, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n- 采纳阈值是统一的：对于所有 $i$，$\\theta_i = \\theta = 0.5$。\n- 在时间 $t=0$ 时的初始状态为 $x_1(0)=1$, $x_3(0)=1$，且 $x_2(0)=x_4(0)=x_5(0)=0$。\n- 任务是找出在时间 $t=1$ 时新增采纳者的数量。一个新增采纳者是指满足 $x_i(0)=0$ 且 $x_i(1)=1$ 的节点 $i$。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题描述了一个小型网络上的线性阈值模型模拟。\n- **科学依据：** 线性阈值模型是网络科学中研究扩散过程的一个标准且成熟的模型。它在能源系统建模中应用于社会技术转型是一个合理的研究领域。该模型在数学上是合理的。\n- **良构性：** 所有必要组成部分都已提供：网络结构（$A$）、初始状态（$x(0)$）、模型动力学（LTM 更新规则）和模型参数（$\\theta$）。问题要求一个具体的、可计算的量。\n- **客观性：** 问题使用精确的数学定义进行陈述，不包含主观或模棱两可的语言。\n- **一致性检查：** 如题所述，矩阵 $A$ 是对称的（$A_{ij} = A_{ji}$）。行和（总影响权重）均为正：$\\sum_j A_{1j}=1.0$，$\\sum_j A_{2j}=1.8$，$\\sum_j A_{3j}=1.0$，$\\sum_j A_{4j}=1.5$，$\\sum_j A_{5j}=0.9$。这证实了社会信号计算中分母严格为正的条件。\n\n### 第 3 步：结论与行动\n该问题是有效的。它是一个良构的、自洽的、科学合理的标准网络模型应用。我将继续进行求解。\n\n在时间 $t=0$ 时系统的状态可以用向量 $x(0) = [x_1(0), x_2(0), x_3(0), x_4(0), x_5(0)]^T = [1, 0, 1, 0, 0]^T$ 表示。\n我们需要确定在时间 $t=1$ 时的状态向量 $x(1)$。LTM 更新规则同步地应用于所有节点。\n\n节点 $i$ 的更新规则是，如果 $x_i(0)=1$ 或 $s_i(0) \\geq \\theta$，则 $x_i(1) = 1$。否则，$x_i(1)=0$。阈值为 $\\theta = 0.5$。\n\n对于在 $t=0$ 时已经采纳的节点，由于采纳的不可逆性，它们的状态保持不变。\n- 对于节点 $1$：$x_1(0)=1$，所以 $x_1(1)=1$。\n- 对于节点 $3$：$x_3(0)=1$，所以 $x_3(1)=1$。\n\n对于在 $t=0$ 时尚未采纳的节点（即 $x_i(0)=0$），我们必须计算它们的社会信号 $s_i(0)$ 并将其与阈值 $\\theta$ 进行比较。未采纳者是节点 $2$、$4$ 和 $5$。\n\n社会信号为 $s_i(0) = \\frac{\\sum_{j=1}^{5} A_{ij} x_j(0)}{\\sum_{j=1}^{5} A_{ij}}$。\n分子是来自已采纳邻居的影响总和。由于在 $t=0$ 时只有节点 $1$ 和 $3$ 是采纳者，节点 $i$ 的分子可简化为 $A_{i1} x_1(0) + A_{i3} x_3(0) = A_{i1}(1) + A_{i3}(1) = A_{i1} + A_{i3}$。\n\n首先，我们计算总影响权重（分母），即矩阵 $A$ 的行和。令 $W_i = \\sum_{j=1}^{5} A_{ij}$。\n$W_1 = A_{12} + A_{14} = 0.6 + 0.4 = 1.0$\n$W_2 = A_{21} + A_{23} + A_{24} = 0.6 + 0.7 + 0.5 = 1.8$\n$W_3 = A_{32} + A_{35} = 0.7 + 0.3 = 1.0$\n$W_4 = A_{41} + A_{42} + A_{45} = 0.4 + 0.5 + 0.6 = 1.5$\n$W_5 = A_{53} + A_{54} = 0.3 + 0.6 = 0.9$\n\n现在我们为每个未采纳者评估其采纳条件：\n\n**节点 2：**\n来自初始采纳者对节点 $2$ 的影响为 $A_{21} + A_{23} = 0.6 + 0.7 = 1.3$。\n社会信号为 $s_2(0) = \\frac{1.3}{W_2} = \\frac{1.3}{1.8}$。\n我们检查 $s_2(0) \\geq \\theta$ 是否成立：\n$\\frac{1.3}{1.8} \\geq 0.5 \\implies 1.3 \\geq 0.5 \\times 1.8 \\implies 1.3 \\geq 0.9$。\n这个不等式成立。因此，节点 $2$ 在 $t=1$ 时采纳，所以 $x_2(1)=1$。\n\n**节点 4：**\n来自初始采纳者对节点 $4$ 的影响为 $A_{41} + A_{43} = 0.4 + 0 = 0.4$。\n社会信号为 $s_4(0) = \\frac{0.4}{W_4} = \\frac{0.4}{1.5}$。\n我们检查 $s_4(0) \\geq \\theta$ 是否成立：\n$\\frac{0.4}{1.5} \\geq 0.5 \\implies 0.4 \\geq 0.5 \\times 1.5 \\implies 0.4 \\geq 0.75$。\n这个不等式不成立。因此，节点 $4$ 在 $t=1$ 时不采纳，所以 $x_4(1)=0$。\n\n**节点 5：**\n来自初始采纳者对节点 $5$ 的影响为 $A_{51} + A_{53} = 0 + 0.3 = 0.3$。\n社会信号为 $s_5(0) = \\frac{0.3}{W_5} = \\frac{0.3}{0.9} = \\frac{1}{3}$。\n我们检查 $s_5(0) \\geq \\theta$ 是否成立：\n$\\frac{1}{3} \\geq 0.5$。\n这等价于 $1 \\geq 1.5$，是不成立的。因此，节点 $5$ 在 $t=1$ 时不采纳，所以 $x_5(1)=0$。\n\n在时间 $t=1$ 时的状态向量是 $x(1) = [x_1(1), x_2(1), x_3(1), x_4(1), x_5(1)]^T = [1, 1, 1, 0, 0]^T$。\n一个新增采纳者是满足 $x_i(0)=0$ 且 $x_i(1)=1$ 的节点 $i$。\n比较 $x(0)=[1, 0, 1, 0, 0]^T$ 与 $x(1)=[1, 1, 1, 0, 0]^T$：\n- 节点 $2$：$x_2(0)=0$ 且 $x_2(1)=1$。节点 $2$ 是一个新增采纳者。\n- 节点 $4$：$x_4(0)=0$ 且 $x_4(1)=0$。节点 $4$ 不是新增采纳者。\n- 节点 $5$：$x_5(0)=0$ 且 $x_5(1)=0$。节点 $5$ 不是新增采纳者。\n\n只有一个新增采纳者，即节点 $2$。新增采纳者的数量是 $1$。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "掌握了基本的更新规则后，我们可以探索更细致、更真实的场景。这个练习挑战了一个普遍的直觉：连接最多的“中心”节点总是最有效的影响力传播者。通过构建一个节点阈值与其度相关的场景，本练习揭示了一个关键的洞见：节点的结构重要性（中心性）并不能保证其影响力，特别是当它对采纳的抵抗性很高时。",
            "id": "4271418",
            "problem": "考虑一个简单、无向、无权重的网络（图）$G=(V,E)$，其节点集为 $V=\\{h,a,b,c,d,e,f,g\\}$，边集 $E$ 由以下邻接规范给出：$h$ 与 $a, b, c, d, e$ 相连；$c$ 与 $h, d, e, f$ 相连；$d$ 与 $h, c, e, f, g$ 相连；$e$ 与 $h, c, d, g$ 相连；$f$ 与 $c, d$ 相连；$g$ 与 $d, e$ 相连；$a$ 与 $h$ 相连；$b$ 与 $h$ 相连。令 $k_i$ 表示节点 $i$ 的度（邻居数量），并令 $k_{\\max}=\\max_{i\\in V} k_i$。\n\n动态过程是线性阈值模型（LTM），定义如下。时间以离散步长 $t=0,1,2,\\dots$ 演化。每个节点 $i$ 有一个阈值分数 $f_i \\in [0,1]$，并且处于非激活或激活状态。在每一步，如果一个非激活节点 $i$ 的激活邻居的比例至少达到其阈值分数，它就会变为激活状态；即，如果 $\\frac{\\text{节点 }i\\text{ 的激活邻居数}}{k_i} \\ge f_i$。一旦激活，节点将保持激活状态。该过程在 $t=0$ 时开始，有一个单独的种子节点 $s$ 被设置为激活状态，所有其他节点都处于非激活状态。种子 $s$ 的影响力定义为最终的级联规模 $S(s)$，即过程收敛时激活节点的总数。\n\n构建一个异质阈值LTM，其中高度数节点的阈值根据规则 $f_i = f_0 + \\gamma \\frac{k_i}{k_{\\max}}$ 更高，参数为 $f_0=0.1$ 和 $\\gamma=0.5$。在图 $G$ 上使用此构造，分析度中心性（由 $k_i$ 衡量）是否以及如何预测单一种子影响力 $S(i)$。\n\n在此模型和网络下，以下哪个陈述是正确的？\n\nA. 将节点 $d$ 作为种子会产生一个激活所有节点的全局级联，而将节点 $h$ 作为种子则不会，尽管 $k_d = k_h$。因此，在异质阈值下，度中心性无法预测单一种子影响力。\n\nB. 对于任何单节点种子 $i$，最终级联规模 $S(i)$ 严格随 $k_i$ 递增（更高的度总是意味着更大的级联）。\n\nC. 将节点 $h$ 作为种子会产生所有单节点种子中最大的级联，因为 $k_h$ 是最大的。\n\nD. 在指定的阈值下，当作为种子时，具有相同度中心性的节点总是产生相同大小的级联。",
            "solution": "首先验证问题陈述，以确保其科学上合理、定义明确且客观。\n\n### 步骤1：提取已知条件\n-   网络是一个简单、无向、无权重的图 $G=(V,E)$。\n-   节点集为 $V=\\{h,a,b,c,d,e,f,g\\}$，因此节点总数为 $|V|=8$。\n-   边集 $E$ 由邻接表定义：\n    -   $N(h) = \\{a, b, c, d, e\\}$\n    -   $N(a) = \\{h\\}$\n    -   $N(b) = \\{h\\}$\n    -   $N(c) = \\{h, d, e, f\\}$\n    -   $N(d) = \\{h, c, e, f, g\\}$\n    -   $N(e) = \\{h, c, d, g\\}$\n    -   $N(f) = \\{c, d\\}$\n    -   $N(g) = \\{d, e\\}$\n-   动态过程由线性阈值模型（LTM）控制。\n-   如果一个非激活节点 $i$ 的激活邻居的比例达到或超过其阈值 $f_i$，它就会变为激活状态：$\\frac{|N(i) \\cap \\text{Active}|}{k_i} \\ge f_i$。\n-   在 $t=0$ 时，一个单独的种子节点 $s$ 是激活的。\n-   影响力 $S(s)$ 是最终的激活节点数。\n-   节点 $i$ 的阈值由规则 $f_i = f_0 + \\gamma \\frac{k_i}{k_{\\max}}$ 给出。\n-   参数为 $f_0=0.1$ 和 $\\gamma=0.5$。\n-   $k_i$ 是节点 $i$ 的度。\n-   $k_{\\max} = \\max_{i \\in V} k_i$。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题描述了一个在明确定义的图上使用线性阈值模型的标准影响力最大化场景。LTM是网络科学中的一个基本模型。所有参数都已指定，图结构明确且一致（邻接表是对称的）。该问题是自洽的、可数学形式化的，并且在复杂系统领域有科学依据。没有矛盾、歧义或事实错误。该问题有效。\n\n### 步骤3：推导\n解决方案需要对每个可能的种子节点模拟LTM级联过程，以确定其影响力 $S(s)$。\n\n首先，我们计算每个节点 $i \\in V$ 的度 $k_i$：\n-   $k_h = |\\{a, b, c, d, e\\}| = 5$\n-   $k_a = |\\{h\\}| = 1$\n-   $k_b = |\\{h\\}| = 1$\n-   $k_c = |\\{h, d, e, f\\}| = 4$\n-   $k_d = |\\{h, c, e, f, g\\}| = 5$\n-   $k_e = |\\{h, c, d, g\\}| = 4$\n-   $k_f = |\\{c, d\\}| = 2$\n-   $k_g = |\\{d, e\\}| = 2$\n\n最大度为 $k_{\\max} = \\max(5,1,1,4,5,4,2,2) = 5$。\n\n接下来，我们使用公式 $f_i = 0.1 + 0.5 \\frac{k_i}{5} = 0.1 + 0.1 k_i$ 计算每个节点的激活阈值 $f_i$：\n-   $f_h = 0.1 + 0.1(5) = 0.6$\n-   $f_a = 0.1 + 0.1(1) = 0.2$\n-   $f_b = 0.1 + 0.1(1) = 0.2$\n-   $f_c = 0.1 + 0.1(4) = 0.5$\n-   $f_d = 0.1 + 0.1(5) = 0.6$\n-   $f_e = 0.1 + 0.1(4) = 0.5$\n-   $f_f = 0.1 + 0.1(2) = 0.3$\n-   $f_g = 0.1 + 0.1(2) = 0.3$\n\n现在，我们为选项中提到的每个相关种子节点（$h$ 和 $d$）以及为完成分析所需的其他节点模拟级联过程。令 $A_t$ 为步骤 $t$ 时的激活节点集。\n\n**种子 $s=h$：**\n-   $t=0$：$A_0 = \\{h\\}$。级联规模 $S=1$。\n-   $t=1$：检查 $h$ 的邻居：$\\{a,b,c,d,e\\}$。\n    -   节点 $a$（$k_a=1, f_a=0.2$）：有 $1$ 个邻居，其中 $1$ 个是激活的（$h$）。比例 = $1/1 = 1.0$。因为 $1.0 \\ge 0.2$，所以 $a$ 变为激活状态。\n    -   节点 $b$（$k_b=1, f_b=0.2$）：有 $1$ 个邻居，其中 $1$ 个是激活的（$h$）。比例 = $1/1 = 1.0$。因为 $1.0 \\ge 0.2$，所以 $b$ 变为激活状态。\n    -   节点 $c$（$k_c=4, f_c=0.5$）：有 $4$ 个邻居，其中 $1$ 个是激活的（$h$）。比例 = $1/4 = 0.25$。因为 $0.25  0.5$，所以 $c$ 保持非激活状态。\n    -   节点 $d$（$k_d=5, f_d=0.6$）：有 $5$ 个邻居，其中 $1$ 个是激活的（$h$）。比例 = $1/5 = 0.2$。因为 $0.2  0.6$，所以 $d$ 保持非激活状态。\n    -   节点 $e$（$k_e=4, f_e=0.5$）：有 $4$ 个邻居，其中 $1$ 个是激活的（$h$）。比例 = $1/4 = 0.25$。因为 $0.25  0.5$，所以 $e$ 保持非激活状态。\n-   $A_1 = \\{h, a, b\\}$。$S=3$。\n-   $t=2$：从 $t=1$ 开始的新激活节点是 $\\{a,b\\}$。它们唯一的邻居是 $h$，而 $h$ 已经激活。没有其他非激活节点受到影响。级联停止。\n-   最终级联规模：$S(h) = 3$。\n\n**种子 $s=d$：**\n-   $t=0$：$A_0 = \\{d\\}$。级联规模 $S=1$。\n-   $t=1$：检查 $d$ 的邻居：$\\{h,c,e,f,g\\}$。\n    -   节点 $f$（$k_f=2, f_f=0.3$）：有 $2$ 个邻居，其中 $1$ 个是激活的（$d$）。比例 = $1/2 = 0.5$。因为 $0.5 \\ge 0.3$，所以 $f$ 变为激活状态。\n    -   节点 $g$（$k_g=2, f_g=0.3$）：有 $2$ 个邻居，其中 $1$ 个是激活的（$d$）。比例 = $1/2 = 0.5$。因为 $0.5 \\ge 0.3$，所以 $g$ 变为激活状态。\n    -   节点 $h, c, e$ 的度数很高，不会被单个邻居激活。\n-   $A_1 = \\{d, f, g\\}$。$S=3$。\n-   $t=2$：新的激活节点是 $\\{f,g\\}$。检查它们的非激活邻居 $\\{c, e\\}$。\n    -   节点 $c$（$k_c=4, f_c=0.5$）：在 $\\{h,d,e,f\\}$ 中有激活邻居 $\\{d,f\\}$。比例 = $2/4 = 0.5$。因为 $0.5 \\ge 0.5$，所以 $c$ 变为激活状态。\n    -   节点 $e$（$k_e=4, f_e=0.5$）：在 $\\{h,c,d,g\\}$ 中有激活邻居 $\\{d,g\\}$。比例 = $2/4 = 0.5$。因为 $0.5 \\ge 0.5$，所以 $e$ 变为激活状态。\n-   $A_2 = \\{d, f, g, c, e\\}$。$S=5$。\n-   $t=3$：新的激活节点是 $\\{c,e\\}$。检查它们的非激活邻居。唯一的共同非激活邻居是 $h$。\n    -   节点 $h$（$k_h=5, f_h=0.6$）：在 $\\{a,b,c,d,e\\}$ 中有激活邻居 $\\{c,d,e\\}$。比例 = $3/5 = 0.6$。因为 $0.6 \\ge 0.6$，所以 $h$ 变为激活状态。\n-   $A_3 = \\{d, f, g, c, e, h\\}$。$S=6$。\n-   $t=4$：新的激活节点是 $h$。检查其非激活邻居 $\\{a,b\\}$。\n    -   节点 $a$（$k_a=1, f_a=0.2$）：有 $1$ 个邻居，其中 $1$ 个是激活的（$h$）。比例 = $1/1 = 1.0$。因为 $1.0 \\ge 0.2$，所以 $a$ 变为激活状态。\n    -   节点 $b$（$k_b=1, f_b=0.2$）：有 $1$ 个邻居，其中 $1$ 个是激活的（$h$）。比例 = $1/1 = 1.0$。因为 $1.0 \\ge 0.2$，所以 $b$ 变为激活状态。\n-   $A_4 = \\{d, f, g, c, e, h, a, b\\}$。$S=8$。\n-   所有节点都已激活。这是一个全局级联。过程收敛。\n-   最终级联规模：$S(d) = 8$。\n\n为了评估所有选项，我们计算其他种子的级联规模。\n-   $S(a)=1, S(b)=1, S(f)=1, S(g)=1$，因为它们各自的邻居（$a,b$ 的邻居 $h$；$f$ 的邻居 $c,d$；$g$ 的邻居 $d,e$）的阈值太高，无法被一个节点激活。\n-   $S(c)=2$（激活 $f$）。\n-   $S(e)=2$（激活 $g$）。\n\n结果总结：\n-   $k_h=5, S(h)=3$\n-   $k_d=5, S(d)=8$\n-   $k_c=4, S(c)=2$\n-   $k_e=4, S(e)=2$\n-   $k_f=2, S(f)=1$\n-   $k_g=2, S(g)=1$\n-   $k_a=1, S(a)=1$\n-   $k_b=1, S(b)=1$\n\n### 逐项分析\n\n**A. 将节点 $d$ 作为种子会产生一个激活所有节点的全局级联，而将节点 $h$ 作为种子则不会，尽管 $k_d = k_h$。因此，在异质阈值下，度中心性无法预测单一种子影响力。**\n我们的模拟显示，将 $d$ 作为种子会激活所有 $8$ 个节点，导致全局级联（$S(d)=8$）。将节点 $h$ 作为种子导致级联规模为 $3$（$S(h)=3$），这不是全局的。两个节点具有相同的最大度，$k_d = k_h = 5$。由于两个具有相同度中心性的节点产生了截然不同的影响力（$S(d)=8 \\ne S(h)=3$），因此在这种情况下，度中心性本身并不是一个可靠的影响力预测指标。该陈述完全得到我们分析的支持。\n**结论：正确。**\n\n**B. 对于任何单节点种子 $i$，最终级联规模 $S(i)$ 严格随 $k_i$ 递增（更高的度总是意味着更大的级联）。**\n该陈述意味着对于任意两个节点 $i$ 和 $j$，如果 $k_i  k_j$，则 $S(i)  S(j)$。我们用一个反例来检验。考虑节点 $f$（$k_f=2$）和节点 $a$（$k_a=1$）。这里，$k_f  k_a$。要使该陈述为真，必须有 $S(f)  S(a)$。然而，我们的计算显示 $S(f)=1$ 和 $S(a)=1$。由于 $S(f)$ 并不严格大于 $S(a)$，因此该关系不是严格递增的。\n**结论：不正确。**\n\n**C. 将节点 $h$ 作为种子会产生所有单节点种子中最大的级联，因为 $k_h$ 是最大的。**\n我们的模拟显示，将节点 $h$ 作为种子产生的级联规模为 $S(h)=3$。将节点 $d$ 作为种子产生的级联规模为 $S(d)=8$，这是可能的最大值。因此，将节点 $h$ 作为种子并不能产生最大的级联。该陈述的前提是错误的。\n**结论：不正确。**\n\n**D. 在指定的阈值下，当作为种子时，具有相同度中心性的节点总是产生相同大小的级联。**\n该陈述声称如果 $k_i = k_j$，那么 $S(i) = S(j)$。我们来检验一下。节点 $d$ 和 $h$ 的度都为 $k_d = k_h = 5$。然而，它们的级联规模分别为 $S(d)=8$ 和 $S(h)=3$。由于 $S(d) \\ne S(h)$，我们有了一个直接的反例。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "当理论洞见能够通过计算得到验证和探索时，其力量最为强大。最后一个练习将从纸笔分析转向代码实现，要求你构建一个模拟，为“高-度节点播种”这一启发式策略提供一个清晰的反例。通过编写线性阈值模型的代码，并在一个特殊设计的网络上测试不同的播种策略，你不仅能巩固概念理解，还能培养在自己的研究中建模和分析传染动态所需的实践技能。",
            "id": "4149767",
            "problem": "考虑一个有限、无向、简单图 $G = (V, E)$ 上的确定性线性阈值模型 (DLTM) 扩散过程，其中 $|V| = n$。每个节点 $i \\in V$ 都有一个采纳阈值 $\\phi_i \\in [0,1]$ 和一个度 $k_i = \\sum_{j=1}^{n} A_{ij}$，其中 $A \\in \\{0,1\\}^{n \\times n}$ 是邻接矩阵，当且仅当 $(i,j) \\in E$ 时，$A_{ij} = 1$。设二元采纳状态为 $x_i(t) \\in \\{0,1\\}$，其中 $x_i(t) = 1$ 表示节点 $i$ 在时间 $t$ 已采纳。更新规则是同步且单调的：在时间 $t$ 尚未采纳的节点 $i$ 在时间 $t+1$ 采纳，当且仅当\n$$\n\\frac{\\sum_{j=1}^{n} A_{ij} \\, x_j(t)}{k_i} \\ge \\phi_i,\n$$\n且一旦采纳，节点将永远保持采纳状态。设初始种子集合 $S \\subseteq V$ 为在 $t=0$ 时被强制采纳的节点集合，即对于 $i \\in S$，有 $x_i(0) = 1$，否则 $x_i(0) = 0$。\n\n我们研究一个反例，其中由于分配给中心节点的高阈值，选择度最高的节点作为种子是次优的，而将脆弱的低度节点作为种子则更优。对于一个固定的 $k \\in \\mathbb{N}$，定义两种播种策略：\n- 高度节点播种策略：选择度 $k_i$ 最大的 $k$ 个节点（按最小索引打破平局）。\n- 脆弱低度节点目标策略：选择度 $k_i$ 最小的 $k$ 个节点（按最小索引打破平局）。\n\n对于每种策略，模拟 DLTM 动态过程直到其达到一个不动点，并报告最终的级联规模 $C(S) = \\sum_{i=1}^{n} x_i(\\infty)$，其中 $x_i(\\infty)$ 是收敛时的采纳状态。将脆弱低度节点目标策略相对于高度节点播种策略的增益量化为整数差\n$$\n\\Delta = C(S_{\\mathrm{low}}) - C(S_{\\mathrm{high}}),\n$$\n其中 $S_{\\mathrm{low}}$ 是来自脆弱低度节点目标策略的种子集合，$S_{\\mathrm{high}}$ 是来自高度节点播种策略的种子集合。\n\n使用以下测试套件，它们都定义在同一个具有 $n = 16$ 个节点的基础图 $G$ 上：\n- 图的构造：节点 $\\{0,1,2,3,4,5\\}$ 形成一个团 $K_6$（即所有节点对都相连），节点 $\\{6,7,\\dots,15\\}$ 形成一个长度为 $10$ 的简单环（即边 $(6,7),(7,8),\\dots,(15,6)$），并且有一条连接团与环的桥边 $(0,6)$。该图是无向的，因此 $A_{ij} = A_{ji}$。\n- 度：团中的节点对于 $i \\in \\{1,2,3,4,5\\}$ 有度 $k_i = 5$，由于桥边，$k_0 = 6$；环中的节点对于 $i \\in \\{7,8,\\dots,15\\}$ 有度 $k_i = 2$，由于桥边，$k_6 = 3$。\n\n定义三个测试用例，它们改变阈值向量 $(\\phi_i)$ 和种子预算 $k$：\n- 测试用例 1：对于 $i \\in \\{0,1,2,3,4,5\\}$（中心节点），阈值 $\\phi_i = 0.9$，对于 $i \\in \\{6,7,\\dots,15\\}$（外围节点），阈值 $\\phi_i = 0.5$；种子预算 $k = 1$。\n- 测试用例 2：阈值与测试用例 1 相同；种子预算 $k = 2$。\n- 测试用例 3：对于 $i \\in \\{0,1,2,3,4,5\\}$（中心节点），阈值 $\\phi_i = 0.1$，对于 $i \\in \\{6,7,\\dots,15\\}$（外围节点），阈值 $\\phi_i = 0.7$；种子预算 $k = 1$。\n\n实现 DLTM 模拟，对每个测试用例应用两种播种策略，并计算如上定义的整数增益 $\\Delta$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\Delta_1,\\Delta_2,\\Delta_3]$），其中 $\\Delta_1$、$\\Delta_2$ 和 $\\Delta_3$ 分别是测试用例 1、2 和 3 的增益。不涉及物理单位或角度单位，所有输出必须是整数。",
            "solution": "已分析并验证用户提供的问题陈述。\n\n### 步骤 1：提取已知信息\n- **模型**：确定性线性阈值模型 (DLTM)，作用于一个具有 $n=|V|=16$ 个节点的有限、无向、简单图 $G=(V,E)$ 上。\n- **节点状态**：$x_i(t) \\in \\{0,1\\}$，其中 $1$ 表示采纳。\n- **节点属性**：阈值 $\\phi_i \\in [0,1]$ 和度 $k_i$。\n- **更新规则**：一个在时间 $t$ 未采纳的节点 $i$ 在 $t+1$ 时采纳，如果 $\\frac{\\sum_{j} A_{ij} x_j(t)}{k_i} \\ge \\phi_i$。更新是同步的，且采纳是永久性的。\n- **图结构**：\n    - 节点 $\\{0,1,2,3,4,5\\}$ 形成一个团 $K_6$。\n    - 节点 $\\{6,7,\\dots,15\\}$ 形成一个长度为 $10$ 的简单环。\n    - 一条桥边 $(0,6)$ 连接这两个组件。\n- **节点度（从结构中推导）**：\n    - $k_0 = 6$。\n    - 对于 $i \\in \\{1,\\dots,5\\}$，$k_i = 5$。\n    - $k_6 = 3$。\n    - 对于 $i \\in \\{7,\\dots,15\\}$，$k_i = 2$。\n- **播种策略（预算 $k$）**：\n    - $S_{\\mathrm{high}}$：按度数排名前 $k$ 的节点，按最小节点索引打破平局。\n    - $S_{\\mathrm{low}}$：按度数排名后 $k$ 的节点，按最小节点索引打破平局。\n- **度量指标**：$\\Delta = C(S_{\\mathrm{low}}) - C(S_{\\mathrm{high}})$，其中 $C(S)$ 是最终采纳的节点数。\n- **测试用例 1**：$k=1$；对于 $i \\in \\{0,\\dots,5\\}$（中心节点），$\\phi_i=0.9$；对于 $i \\in \\{6,\\dots,15\\}$（外围节点），$\\phi_i=0.5$。\n- **测试用例 2**：$k=2$；$\\phi_i$ 与测试用例 1 相同。\n- **测试用例 3**：$k=1$；对于 $i \\in \\{0,\\dots,5\\}$（中心节点），$\\phi_i=0.1$；对于 $i \\in \\{6,\\dots,15\\}$（外围节点），$\\phi_i=0.7$。\n\n### 步骤 2：使用提取的已知信息进行验证\n该问题具有科学依据，采用了网络科学中成熟的 DLTM 模型。问题是适定的：模型在有限图上的确定性和单调性确保了唯一不动点的存在。问题是客观的，所有术语、条件和参数都得到了精确定义，包括图结构、节点属性、带有平局打破规则的播种策略以及测试用例。整个设置是完整的、自洽的且逻辑一致的。\n\n### 步骤 3：结论与行动\n问题是**有效**的。将推导解决方案。\n\n### 求解过程\n\n该解决方案需要构建指定的图，实现两种播种策略，并对三个测试用例中的每一个模拟 DLTM 传染过程，以找到最终的级联规模。\n\n**1. 图和度的规范**\n图有 $n=16$ 个节点，索引从 $0$ 到 $15$。根据问题描述构建邻接矩阵 $A \\in \\{0,1\\}^{16 \\times 16}$。通过对 $A$ 的行求和来计算度 $k_i$。\n度为：$k_0=6$，$k_{1..5}=5$，$k_6=3$，$k_{7..15}=2$。\n（节点索引，度）对的列表是：\n$(0,6), (1,5), (2,5), (3,5), (4,5), (5,5), (6,3), (7,2), (8,2), (9,2), (10,2), (11,2), (12,2), (13,2), (14,2), (15,2)$。\n\n**2. 播种策略的实现**\n为了选择种子集合，我们对节点进行排序。\n- 对于高度节点播种策略 ($S_{\\mathrm{high}}$)，节点按度降序排序，然后按索引升序排序。\n- 对于脆弱低度节点目标策略 ($S_{\\mathrm{low}}$)，节点按度升序排序，然后按索引升序排序。\n\n**3. DLTM 模拟算法**\n模拟以离散、同步的时间步进行。\n设 $x(t)$ 为时间 $t$ 的状态向量。最初，$x(0)$ 由种子集合 $S$ 设置。\n在每个步骤中，确定一组新采纳的节点。如果一个未采纳的节点 $i$（其中 $x_i(t)=0$）其采纳的邻居比例达到或超过其阈值，则将其添加到该集合中：\n$$ \\frac{\\sum_{j=1}^{n} A_{ij} x_j(t)}{k_i} \\ge \\phi_i $$\n该集合中的所有节点同时被激活，形成状态 $x(t+1)$。当一个步骤没有产生新的采纳时，模拟终止，此时达到一个不动点。最终的级联规模 $C(S)$ 是采纳节点的总数，即 $\\sum_{i=1}^n x_i(\\infty)$。\n\n**4. 测试用例分析**\n\n**测试用例 1：$k=1$，中心节点 $\\phi_i=0.9$，外围节点 $\\phi_i=0.5$**\n- **播种**：\n    - 高度排序顺序：$(0,6), (1,5), (2,5), \\dots$。对于 $k=1$，$S_{\\mathrm{high}} = \\{0\\}$。\n    - 低度排序顺序：$(7,2), (8,2), \\dots$。对于 $k=1$，$S_{\\mathrm{low}} = \\{7\\}$。\n- **高度节点级联 ($S_{\\mathrm{high}} = \\{0\\}$)**：\n    - $t=0$：节点 $0$ 被采纳。$C=1$。\n    - $t=1$：我们检查节点 $0$ 的邻居。\n        - 对于节点 $i \\in \\{1,\\dots,5\\}$，影响为 $1/k_i = 1/5 = 0.2$，小于它们的阈值 $\\phi_i=0.9$。它们不采纳。\n        - 对于节点 $6$，影响为 $1/k_6 = 1/3 \\approx 0.333$，小于其阈值 $\\phi_6=0.5$。它不采纳。\n    - 级联停止。$C(S_{\\mathrm{high}}) = 1$。\n- **低度节点级联 ($S_{\\mathrm{low}} = \\{7\\}$)**：\n    - $t=0$：节点 $7$ 被采纳。$C=1$。\n    - $t=1$：我们检查节点 $7$ 的邻居：节点 $6$ 和 $8$。\n        - 节点 $6$：影响 $1/k_6 = 1/3  \\phi_6=0.5$。不采纳。\n        - 节点 $8$：影响 $1/k_8 = 1/2 \\ge \\phi_8=0.5$。节点 $8$ 采纳。\n    - 采纳沿环路传播：$8 \\to 9 \\to \\dots \\to 15$。在 $t=8$ 时，所有节点 $\\{7, \\dots, 15\\}$ 都被采纳。\n    - 在 $t=9$ 时，我们重新评估节点 $6$。它的邻居 $7$ 和 $15$ 现在都已采纳。影响为 $2/k_6 = 2/3 \\approx 0.667$，大于 $\\phi_6=0.5$。节点 $6$ 采纳。现在所有的外围节点 $\\{6, \\dots, 15\\}$ 都被采纳。\n    - 在 $t=10$ 时，我们检查新采纳的节点 $6$ 的邻居节点 $0$。影响为 $1/k_0 = 1/6 \\approx 0.167  \\phi_0=0.9$。不采纳。\n    - 级联停止。最终采纳集合是 $\\{6, \\dots, 15\\}$，总共 $10$ 个节点。$C(S_{\\mathrm{low}}) = 10$。\n- **增益**：$\\Delta_1 = C(S_{\\mathrm{low}}) - C(S_{\\mathrm{high}}) = 10 - 1 = 9$。\n\n**测试用例 2：$k=2$，中心节点 $\\phi_i=0.9$，外围节点 $\\phi_i=0.5$**\n- **播种**：\n    - 对于 $k=2$，$S_{\\mathrm{high}} = \\{0, 1\\}$。\n    - 对于 $k=2$，$S_{\\mathrm{low}} = \\{7, 8\\}$。\n- **高度节点级联 ($S_{\\mathrm{high}} = \\{0, 1\\}$)**：\n    - $t=0$：节点 $0,1$ 被采纳。$C=2$。\n    - $t=1$：检查未采纳的节点。\n        - 对于节点 $i \\in \\{2,\\dots,5\\}$，来自邻居 $0,1$ 的影响为 $2/k_i = 2/5 = 0.4  \\phi_i=0.9$。不采纳。\n        - 对于节点 $6$，来自邻居 $0$ 的影响为 $1/k_6 = 1/3  \\phi_6=0.5$。不采纳。\n    - 级联停止。$C(S_{\\mathrm{high}}) = 2$。\n- **低度节点级联 ($S_{\\mathrm{low}} = \\{7, 8\\}$)**：\n    - $t=0$：节点 $7,8$ 被采纳。$C=2$。\n    - 级联过程与前一情况相同，因为来自节点 $7$ 的影响不足以单独激活节点 $6$，而节点 $8$ 的激活在环路中引发了一波传播。最终采纳集合再次是 $\\{6, \\dots, 15\\}$。\n    - 级联停止。$C(S_{\\mathrm{low}}) = 10$。\n- **增益**：$\\Delta_2 = C(S_{\\mathrm{low}}) - C(S_{\\mathrm{high}}) = 10 - 2 = 8$。\n\n**测试用例 3：$k=1$，中心节点 $\\phi_i=0.1$，外围节点 $\\phi_i=0.7$**\n- **播种**：\n    - 对于 $k=1$，$S_{\\mathrm{high}} = \\{0\\}$ 和 $S_{\\mathrm{low}} = \\{7\\}$。\n- **高度节点级联 ($S_{\\mathrm{high}} = \\{0\\}$)**：\n    - $t=0$：节点 $0$ 被采纳。$C=1$。\n    - $t=1$：\n        - 对于节点 $i \\in \\{1,\\dots,5\\}$，影响为 $1/k_i = 1/5 = 0.2 \\ge \\phi_i=0.1$。所有节点 $\\{1, \\dots, 5\\}$ 都采纳。\n        - 对于节点 $6$，影响为 $1/k_6 = 1/3 \\approx 0.333  \\phi_6=0.7$。不采纳。\n    - 在 $t=1$ 时，整个团 $\\{0, \\dots, 5\\}$ 都被采纳。由于节点 $6$ 仍未激活，不可能有进一步的进展。\n    - 级联停止。$C(S_{\\mathrm{high}}) = 6$。\n- **低度节点级联 ($S_{\\mathrm{low}} = \\{7\\}$)**：\n    - $t=0$：节点 $7$ 被采纳。$C=1$。\n    - $t=1$：检查 $7$ 的邻居。\n        - 节点 $6$：影响 $1/k_6 = 1/3  \\phi_6=0.7$。不采纳。\n        - 节点 $8$：影响 $1/k_8 = 1/2 = 0.5  \\phi_8=0.7$。不采纳。\n    - 级联停止。$C(S_{\\mathrm{low}}) = 1$。\n- **增益**：$\\Delta_3 = C(S_{\\mathrm{low}}) - C(S_{\\mathrm{high}}) = 1 - 6 = -5$。\n\n最终计算值为 $\\Delta_1=9$、$\\Delta_2=8$ 和 $\\Delta_3=-5$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_graph(n):\n    \"\"\"\n    Constructs the adjacency matrix and degree vector for the specified graph.\n    \"\"\"\n    A = np.zeros((n, n), dtype=int)\n    \n    # Clique K6 on nodes {0, ..., 5}\n    for i in range(6):\n        for j in range(i + 1, 6):\n            A[i, j] = 1\n            A[j, i] = 1\n            \n    # 10-cycle on nodes {6, ..., 15}\n    for i in range(6, 15):\n        A[i, i + 1] = 1\n        A[i + 1, i] = 1\n    A[15, 6] = 1\n    A[6, 15] = 1\n    \n    # Bridge edge (0, 6)\n    A[0, 6] = 1\n    A[6, 0] = 1\n    \n    degrees = np.sum(A, axis=1)\n    return A, degrees\n\ndef get_seed_sets(degrees, k):\n    \"\"\"\n    Determines seed sets for high-degree and low-degree strategies.\n    \"\"\"\n    n = len(degrees)\n    nodes = list(range(n))\n    \n    # Sort for high-degree seeding: degree desc, index asc\n    nodes_sorted_high = sorted(nodes, key=lambda i: (-degrees[i], i))\n    S_high = set(nodes_sorted_high[:k])\n    \n    # Sort for low-degree seeding: degree asc, index asc\n    nodes_sorted_low = sorted(nodes, key=lambda i: (degrees[i], i))\n    S_low = set(nodes_sorted_low[:k])\n    \n    return S_high, S_low\n\ndef run_simulation(A, degrees, phi, S_initial):\n    \"\"\"\n    Simulates the Deterministic Linear Threshold Model (DLTM).\n    \"\"\"\n    n = A.shape[0]\n    x = np.zeros(n, dtype=int)\n    if S_initial:\n        x[list(S_initial)] = 1\n\n    while True:\n        nodes_to_activate = []\n        \n        # Find which non-adopted nodes will be activated in the next step\n        # based on the current state 'x'. This is a synchronous update.\n        non_adopted_indices = np.where(x == 0)[0]\n        \n        for i in non_adopted_indices:\n            # Calculate influence from adopted neighbors\n            adopted_neighbors_sum = np.dot(A[i, :], x)\n            k_i = degrees[i]\n            \n            if k_i > 0:\n                pressure = adopted_neighbors_sum / k_i\n                if pressure >= phi[i]:\n                    nodes_to_activate.append(i)\n\n        # If no new nodes adopt, the system has reached a fixed point\n        if not nodes_to_activate:\n            break\n        \n        # Activate all identified nodes simultaneously for the next time step\n        x[nodes_to_activate] = 1\n            \n    return int(np.sum(x))\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and produce the final output.\n    \"\"\"\n    n = 16\n    A, degrees = build_graph(n)\n    \n    test_cases = [\n        # (k, phi_hubs, phi_periphery)\n        (1, 0.9, 0.5),\n        (2, 0.9, 0.5),\n        (1, 0.1, 0.7),\n    ]\n\n    results = []\n    \n    for k, phi_hubs, phi_periphery in test_cases:\n        # Construct the threshold vector for the current test case\n        phi = np.zeros(n)\n        phi[0:6] = phi_hubs       # Hubs: nodes 0-5\n        phi[6:16] = phi_periphery # Periphery: nodes 6-15\n        \n        # Determine the seed sets for both strategies\n        S_high, S_low = get_seed_sets(degrees, k)\n        \n        # Run simulation for high-degree seeding\n        C_high = run_simulation(A, degrees, phi, S_high)\n        \n        # Run simulation for low-degree seeding\n        C_low = run_simulation(A, degrees, phi, S_low)\n        \n        # Calculate the gain and append to results\n        delta = C_low - C_high\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}