{
    "hands_on_practices": [
        {
            "introduction": "掌握平均首次通过时间（MFPT）的计算始于最基本的情景。本练习将引导你通过“第一步分析”方法，为一个简单的双态连续时间马尔可夫链推导MFPT。这个基础练习旨在巩固MFPT的定义，并让你熟练掌握从基本原理出发进行推导的核心技能。",
            "id": "2654448",
            "problem": "考虑一个具有 $2$ 个状态（标记为 $1$ 和 $2$）的可逆单分子反应网络，代表化学物种间的相互转化 $X_1 \\rightleftharpoons X_2$。其动力学被建模为连续时间马尔可夫链 (CTMC)，从状态 $1$ 到状态 $2$ 的转移速率为常数 $k_{12}$，从状态 $2$ 到状态 $1$ 的转移速率为常数 $k_{21}$。假设满足标准的马尔可夫跳跃过程假设：等待时间呈指数分布，其参数等于当前状态所有出射速率之和，且转移是无记忆的。\n\n定义平均首达时间 (MFPT) $T_i$ 为从状态 $i$ 出发首次到达状态 $2$ 的期望时间。使用基于指数等待时间定义和马尔可夫性质的首步分析法，推导 $T_1$ 的方程，并求解以获得一个用 $k_{12}$ 和 $k_{21}$ 表示的闭式表达式。明确陈述你所施加的任何边界条件，并从物理上证明其合理性。\n\n将 $T_1$ 的最终答案以秒为单位，用 $k_{12}$ 和 $k_{21}$ 表示，作为一个单一的闭式解析表达式。不要进行四舍五入。",
            "solution": "在尝试求解之前，对问题陈述进行验证。\n\n首先，从问题陈述中逐字提取已知条件：\n- 具有 $2$ 个状态（标记为 $1$ 和 $2$）的可逆单分子反应网络。\n- 该网络代表物种间的相互转化 $X_1 \\rightleftharpoons X_2$。\n- 动力学被建模为连续时间马尔可夫链 (CTMC)。\n- 从状态 $1$ 到状态 $2$ 的转移速率为常数 $k_{12}$。\n- 从状态 $2$ 到状态 $1$ 的转移速率为常数 $k_{21}$。\n- 满足标准的马尔可夫跳跃过程假设：等待时间呈指数分布且转移是无记忆的。\n- 平均首达时间 (MFPT) $T_i$ 是从状态 $i$ 出发首次到达状态 $2$ 的期望时间。\n- 任务是使用首步分析法推导 $T_1$ 的方程并求解。\n\n其次，根据所需标准对问题进行验证。\n- **科学性**：该问题基于连续时间马尔可夫链的标准理论，这是化学动力学和随机过程中的一个基本工具。平均首达时间的概念及其通过首步分析法的推导是标准的、成熟的程序。该问题在科学上是合理的。\n- **适定性**：该问题对一个双态 CTMC 进行了完整描述，并要求计算一个具体、可计算的量 ($T_1$)。此计算所需的所有必要参数 ($k_{12}$) 均已提供。该问题是适定的，且存在唯一解。\n- **客观性**：该问题使用精确、无歧义的数学和科学术语进行陈述。它不含任何主观或推测性内容。\n\n该问题未违反任何指定的无效标准。它是化学动力学中的一个标准、可形式化的问题。虽然指定了速率 $k_{21}$，但它与计算*到*状态 $2$ 的首达时间最终无关，因为该过程被定义为在首次到达此目标状态时即停止。这并不构成矛盾，而是此类问题的一个共同特点，旨在考验学生识别相关信息的能力。\n\n结论是该问题是**有效**的。下面将提供解答。\n\n目标是求出系统从状态 $1$ 开始，到达状态 $2$ 的平均首达时间 (MFPT)。设系统在时间 $t$ 的状态为 $X(t) \\in \\{1, 2\\}$。从状态 $i$ 到状态 $j$ 的 MFPT 记为 $T_{i \\to j}$。这里，我们关心的是 $T_{1 \\to 2}$，问题中记为 $T_1$。形式上，$T_i = E[\\tau_2 | X(0) = i]$，其中 $\\tau_2 = \\inf\\{t \\ge 0 : X(t) = 2\\}$ 是到达状态 $2$ 的首达时间。\n\n所采用的方法是首步分析法，即对一个无穷小时间间隔 $\\Delta t$ 内发生的第一个事件进行条件分析。\n\n首先，我们确定边界条件。问题要求的是首次到达状态 $2$ 的期望时间。如果过程从状态 $2$ 开始（即 $i=2$），那么它在时间 $t=0$ 时就已经到达了目标状态。因此，所用时间为零。边界条件是：\n$$T_2 = 0$$\n\n现在，我们来推导 $T_1$ 的方程。考虑系统在时间 $t=0$ 时从状态 $1$ 开始。我们在一个微小的时间间隔 $[0, \\Delta t]$ 内分析该过程。根据 CTMC 的性质，在此间隔内从状态 $1$ 转移到状态 $2$ 的概率是 $k_{12} \\Delta t + o(\\Delta t)$，其中 $o(\\Delta t)$ 代表比 $\\Delta t$ 更快趋于零的项。相应地，停留在状态 $1$ 的概率是 $1 - k_{12} \\Delta t + o(\\Delta t)$。\n\n根据全期望定律，我们可以将 $T_1$ 写成基于第一个时间间隔 $\\Delta t$ 内发生事件的条件期望之和：\n$$T_1 = E[\\tau_2 | \\text{在 } \\Delta t \\text{ 内跳跃到 } 2] P(\\text{在 } \\Delta t \\text{ 内跳跃到 } 2) + E[\\tau_2 | \\text{在 } \\Delta t \\text{ 内无跳跃}] P(\\text{在 } \\Delta t \\text{ 内无跳跃})$$\n\n让我们分析每一项：\n1. 如果在 $\\Delta t$ 内发生从状态 $1$ 到状态 $2$ 的跳跃，则经过的时间约为 $\\Delta t$。一旦到达状态 $2$，到达状态 $2$ 的剩余期望时间为 $T_2$。这种情况下总的期望时间是 $\\Delta t + T_2$。\n2. 如果没有发生跳跃，则经过的时间为 $\\Delta t$。由于马尔可夫过程的无记忆性，系统仍处于状态 $1$，从此刻起到达状态 $2$ 的剩余期望时间仍然是 $T_1$。这种情况下总的期望时间是 $\\Delta t + T_1$。\n\n将这些项及其各自的概率代入方程，得到：\n$$T_1 = (\\Delta t + T_2)(k_{12} \\Delta t + o(\\Delta t)) + (\\Delta t + T_1)(1 - k_{12} \\Delta t + o(\\Delta t))$$\n\n现在，我们代入边界条件 $T_2=0$：\n$$T_1 = (\\Delta t)(k_{12} \\Delta t + o(\\Delta t)) + (\\Delta t + T_1)(1 - k_{12} \\Delta t + o(\\Delta t))$$\n展开表达式：\n$$T_1 = k_{12} (\\Delta t)^2 + \\Delta t \\cdot o(\\Delta t) + \\Delta t - k_{12} T_1 \\Delta t + T_1 \\cdot o(\\Delta t) + T_1 - k_{12} T_1 \\Delta t + T_1 \\cdot o(\\Delta t)$$\n我们合并各项，并认识到 $(\\Delta t)^2$ 项和 $o(\\Delta t)$ 项是高阶项，可以合并为一个单一的 $o(\\Delta t)$ 项：\n$$T_1 = T_1 + \\Delta t - k_{12} T_1 \\Delta t + o(\\Delta t)$$\n两边减去 $T_1$ 得：\n$$0 = \\Delta t - k_{12} T_1 \\Delta t + o(\\Delta t)$$\n整个方程除以 $\\Delta t$（对于 $\\Delta t \\neq 0$）：\n$$0 = 1 - k_{12} T_1 + \\frac{o(\\Delta t)}{\\Delta t}$$\n当 $\\Delta t \\to 0$ 时取极限，根据定义，$\\frac{o(\\Delta t)}{\\Delta t}$ 项趋于 $0$。这就得到了关于 $T_1$ 的最终线性方程：\n$$1 - k_{12} T_1 = 0$$\n这就是问题所要求的 $T_1$ 的方程。求解 $T_1$ 的过程很简单：\n$$k_{12} T_1 = 1$$\n$$T_1 = \\frac{1}{k_{12}}$$\n\n这个结果在物理上是直观的。系统处于状态 $1$，唯一的逃逸路径通向目标状态 $2$。在状态 $1$ 的等待时间服从速率参数为 $k_{12}$ 的指数分布。该指数分布的均值为 $1/k_{12}$。因此，离开状态 $1$（从而首次到达状态 $2$）的平均时间恰好是 $1/k_{12}$。速率 $k_{21}$ 是无关的，因为该过程被定义为一旦到达状态 $2$ 即停止，这使得状态 $2$ 在此特定计算中成为一个吸收态。如果速率 $k_{12}$ 和 $k_{21}$ 的单位是反秒 ($s^{-1}$)，那么 $T_1$ 的单位将是秒。",
            "answer": "$$\\boxed{\\frac{1}{k_{12}}}$$"
        },
        {
            "introduction": "当网络结构变得更加复杂时，直接应用第一步分析可能变得繁琐。本练习引入了一个强大的工具：随机游走与电网络之间的类比，其中MFPT与有效电阻相关联。你将把这个概念应用于一个结构化的“中心-模块”树状网络，从而揭示MFPT与图的拓扑性质（如节点度和网络体积）之间的深刻联系。",
            "id": "4286920",
            "problem": "考虑一个在无向加权树上的离散时间随机游走。其转移规则如下：从节点 $u$ 出发，游走者以概率 $P_{uv} = c_{uv} / w_u$ 移动到邻居节点 $v$，其中 $c_{uv}  0$ 是边 $\\{u,v\\}$ 上的电导（边权重），$w_u = \\sum_{x \\sim u} c_{ux}$ 是节点 $u$ 的加权度。令 $\\mathrm{vol}(G) = \\sum_{u} w_u$ 表示图的体积。\n\n该树 $G$ 具有中心-模块结构（hub-and-modules structure）：有一个中心枢纽节点 $h$，通过电导为 $c_1$ 的边连接到 $k$ 个不同的模块节点 $m_1,\\dots,m_k$。每个模块节点 $m_j$ 又通过电导为 $c_2$ 的边连接到 $r$ 个叶节点 $\\ell_{j,1},\\dots,\\ell_{j,r}$。图中不存在其他边。\n\n令 $H_{ij}$ 表示从节点 $i$ 开始的随机游走首次到达节点 $j$ 的平均首达时间（MFPT），以步数计算。请从无向加权图上可逆马尔可夫链的基本定义以及随机游走的电网络表示出发，推导从模块1中的一个叶节点到模块2中的一个叶节点的 MFPT，即 $H_{\\ell_{1,1} \\to \\ell_{2,1}}$ 的闭式表达式，该表达式用 $k$、$r$、$c_1$ 和 $c_2$ 表示。您的推导必须从第一性原理出发，不能预先假设目标的 MFPT 公式。请利用树上有效电阻的性质以及该拓扑结构中度异质性带来的影响。\n\n请将您的最终答案表示为单个解析表达式。无需四舍五入。请以一种能够明确展示其通过加权度和总体积对 $k$ 和 $r$ 的依赖关系的形式来呈现最终表达式。",
            "solution": "这个问题提法得当，有科学依据，并包含了获得唯一解所需的所有信息。因此，我们可以开始推导。\n\n题目要求计算从模块1中的一个叶节点 $i = \\ell_{1,1}$ 出发的随机游走首次到达模块2中的一个叶节点 $j = \\ell_{2,1}$ 的平均首达时间（MFPT），记为 $H_{ij}$。推导将基于随机游走与电网络之间的基本关系。\n\n首先，我们描述图的结构及其性质。该图是一棵树，有一个中心枢纽节点 $h$，$k$ 个模块节点 $m_1, \\dots, m_k$，并且对于每个模块 $m_j$，有 $r$ 个叶节点 $\\ell_{j,1}, \\dots, \\ell_{j,r}$。边的电导为 $c_{\\{h,m_j\\}} = c_1$ 和 $c_{\\{m_j, \\ell_{j,i}\\}} = c_2$。\n\n我们为每种类型的节点计算加权度 $w_u = \\sum_{v \\sim u} c_{uv}$：\n1.  叶节点 $\\ell_{j,i}$：每个叶节点仅与其父模块节点 $m_j$ 相连。\n    $$w_{\\ell} \\equiv w_{\\ell_{j,i}} = c_2$$\n2.  模块节点 $m_j$：每个模块节点连接到中心枢纽节点 $h$ 和 $r$ 个叶节点。\n    $$w_m \\equiv w_{m_j} = c_1 + r c_2$$\n3.  枢纽节点 $h$：该枢纽节点连接到所有 $k$ 个模块节点。\n    $$w_h = k c_1$$\n\n图的总体积 $\\mathrm{vol}(G) = \\sum_{u \\in V} w_u$ 是所有加权度之和。图中有1个枢纽节点，$k$ 个模块节点和 $k \\times r$ 个叶节点。\n$$ \\mathrm{vol}(G) = w_h + \\sum_{j=1}^k w_{m_j} + \\sum_{j=1}^k\\sum_{i=1}^r w_{\\ell_{j,i}} $$\n$$ \\mathrm{vol}(G) = (k c_1) + k(c_1 + r c_2) + kr(c_2) = k c_1 + k c_1 + k r c_2 + k r c_2 $$\n$$ \\mathrm{vol}(G) = 2 k c_1 + 2 k r c_2 = 2k(c_1 + r c_2) $$\n注意，我们可以用模块节点的度简洁地表示体积：$\\mathrm{vol}(G) = 2k w_m$。\n\n随机游走的电网络类比的核心是往返时间公式（Commute Time Formula），它将往返时间 $T_{ij} = H_{ij} + H_{ji}$ 与节点 $i$ 和 $j$ 之间的有效电阻 $R_{ij}$ 联系起来：\n$$ T_{ij} = \\mathrm{vol}(G) R_{ij} $$\n在这里，$R_{ij}$ 是一个电网络中的有效电阻，该网络中原始图的每条边 $\\{u,v\\}$ 都被一个阻值为 $1/c_{uv}$ 的电阻器所替代。\n\n为了从 $T_{ij}$ 求出 $H_{ij}$，我们必须确定 $H_{ij}$ 和 $H_{ji}$ 之间的关系。该图结构表现出高度的对称性。令 $i = \\ell_{1,1}$ 和 $j = \\ell_{2,1}$。考虑一个图自同构 $\\phi$，它完全交换模块1和模块2：\n-   $\\phi(h) = h$\n-   $\\phi(m_1) = m_2$，$\\phi(m_2) = m_1$，且对于 $p \\ge 3$，$\\phi(m_p) = m_p$。\n-   对于所有 $q \\in \\{1, \\dots, r\\}$，$\\phi(\\ell_{1,q}) = \\ell_{2,q}$ 且 $\\phi(\\ell_{2,q}) = \\ell_{1,q}$。\n-   对于 $p \\ge 3$，$\\phi(\\ell_{p,q}) = \\ell_{p,q}$。\n\n这个映射保留了所有的邻接关系和边电导，因此它是该加权图的一个有效自同构。关键的是，它将起始节点映射到目标节点，$\\phi(i) = \\phi(\\ell_{1,1}) = \\ell_{2,1} = j$，反之亦然，$\\phi(j) = \\phi(\\ell_{2,1}) = \\ell_{1,1} = i$。由于随机游走的演化完全由图结构决定，从 $i$ 出发到达 $j$ 的随机过程与从 $j$ 出发到达 $i$ 的随机过程在统计上是相同的。因此，它们的平均首达时间必然相等：\n$$ H_{\\ell_{1,1} \\to \\ell_{2,1}} = H_{\\ell_{2,1} \\to \\ell_{1,1}} \\implies H_{ij} = H_{ji} $$\n\n将此对称性与往返时间公式相结合，我们得到：\n$$ T_{ij} = H_{ij} + H_{ij} = 2 H_{ij} = \\mathrm{vol}(G) R_{ij} $$\n$$ H_{ij} = \\frac{1}{2} \\mathrm{vol}(G) R_{ij} $$\n这就将问题简化为计算有效电阻 $R_{ij}$。\n\n由于该图是一棵树，任意两节点之间的路径是唯一的。对于树来说，两节点之间的有效电阻就是这条唯一路径上各边电阻之和。从 $i = \\ell_{1,1}$ 到 $j = \\ell_{2,1}$ 的路径是：\n$$ \\ell_{1,1} \\longleftrightarrow m_1 \\longleftrightarrow h \\longleftrightarrow m_2 \\longleftrightarrow \\ell_{2,1} $$\n这条路径上各边的电阻为：\n-   边 $\\{\\ell_{1,1}, m_1\\}$ 的电阻器： $1/c_2$\n-   边 $\\{m_1, h\\}$ 的电阻器： $1/c_1$\n-   边 $\\{h, m_2\\}$ 的电阻器： $1/c_1$\n-   边 $\\{m_2, \\ell_{2,1}\\}$ 的电阻器： $1/c_2$\n\n将这些电阻相加，得到有效电阻 $R_{ij}$：\n$$ R_{ij} = \\frac{1}{c_2} + \\frac{1}{c_1} + \\frac{1}{c_1} + \\frac{1}{c_2} = 2\\left(\\frac{1}{c_1} + \\frac{1}{c_2}\\right) $$\n\n现在我们将 $\\mathrm{vol}(G)$ 和 $R_{ij}$ 的表达式代入 $H_{ij}$ 的方程中：\n$$ H_{ij} = \\frac{1}{2} \\left[ 2k(c_1 + r c_2) \\right] \\left[ 2\\left(\\frac{1}{c_1} + \\frac{1}{c_2}\\right) \\right] $$\n$$ H_{ij} = 2k(c_1 + r c_2) \\left(\\frac{1}{c_1} + \\frac{1}{c_2}\\right) $$\n为了得到最终表达式，我们化简括号中的项：\n$$ H_{ij} = 2k(c_1 + r c_2) \\left(\\frac{c_2 + c_1}{c_1 c_2}\\right) $$\n$$ H_{ij} = \\frac{2k(c_1 + c_2)(c_1 + r c_2)}{c_1 c_2} $$\n\n按照要求，我们可以表达这个结果，以明确其对加权度和体积的依赖关系。使用 $H_{ij} = \\frac{1}{2} \\mathrm{vol}(G) R_{ij}$：\n$$ R_{ij} = 2\\left(\\frac{1}{c_1} + \\frac{1}{c_2}\\right) = 2\\left(\\frac{k}{k c_1} + \\frac{1}{c_2}\\right) = 2\\left(\\frac{k}{w_h} + \\frac{1}{w_{\\ell}}\\right) $$\n这得到：\n$$ H_{ij} = \\frac{1}{2} \\mathrm{vol}(G) \\cdot 2\\left(\\frac{k}{w_h} + \\frac{1}{w_{\\ell}}\\right) = \\mathrm{vol}(G) \\left(\\frac{k}{w_h} + \\frac{1}{w_{\\ell}}\\right) $$\n这种形式清晰地将依赖于 $k$ 和 $r$ 的全局图属性 $\\mathrm{vol}(G)$ 与一个和路径上局部电阻相关的项分离开来，后者通过加权度 $w_h$（依赖于 $k$）和 $w_{\\ell}$ 表示。对 $r$ 的依赖完全包含在 $\\mathrm{vol}(G)$ 项中，因为 $\\mathrm{vol}(G) = 2(w_h + krw_\\ell)$。\n\n以给定参数 $k, r, c_1, c_2$ 表示的最终闭式表达式是最基本的表示形式。",
            "answer": "$$\n\\boxed{\\frac{2k(c_1+c_2)(c_1+rc_2)}{c_1c_2}}\n$$"
        },
        {
            "introduction": "虽然解析解非常强大，但许多真实世界的网络对于这种方法来说过于庞大或复杂。本练习将理论转向计算实践，要求你通过编程来构建小世界网络。通过这个实践，你将亲眼见证只需添加极少数“快捷方式”边，就能如何戏剧性地改变网络的全局传输特性，如平均MFPT和网络直径。",
            "id": "4286927",
            "problem": "给定一个无向图族，该图族通过从一个一维周期格（一个环）开始，然后添加少量随机放置的快捷边来构建。考虑在此类图上的离散时间简单随机游走：在每个时间步，位于节点 $i$ 的游走者会从其邻居中均匀随机地选择一个并移动到那里。我们感兴趣的量是平均首达时间（Mean First Passage Time, MFPT），定义为当从指定的源节点出发时，随机游走首次到达目标节点所需的期望步数。形式上，从节点 $i$ 到节点 $j$ 的平均首达时间（MFPT）是到达时间 $T_{ij}$ 的期望值，其中 $T_{ij}$ 是在初始位置为 $i$ 的条件下，随机游走的位置首次等于 $j$ 的时间 $t$。所有有序源-目标对的平均MFPT用 $\\langle T \\rangle$ 表示，是所有 $i \\neq j$ 的有序对 $(i,j)$ 的 $T_{ij}$ 的平均值。\n\n你的任务是实现一个完整的程序，该程序：\n- 构建一个包含 $N$ 个节点的环形格图，其中节点 $i$ 与节点 $(i-1) \\bmod N$ 和 $(i+1) \\bmod N$ 之间有无向边连接。\n- 通过从所有尚未在格中通过边连接的非相邻节点对中，无放回地均匀随机选择 $m$ 个无序节点对，来添加 $m$ 条快捷边，并在每个选定的对之间插入无向边。每个测试用例都指定一个随机种子，以使快捷边的选择可复现。\n- 对于每个生成的图，计算：\n    1. 图中离散时间简单随机游走在所有不同节点的有序对 $(i,j)$ 上的平均首达时间 $\\langle T \\rangle$。\n    2. 平均测地线长度 $\\langle d \\rangle$，定义为使用无权边时，所有 $i \\neq j$ 的有序对 $(i,j)$ 的最短路径距离 $d(i,j)$ 的平均值。\n    3. 图直径 $D$，定义为所有无序对 $\\{i,j\\}$ 的 $d(i,j)$ 的最大值。\n\n计算的基本原理：\n- 将随机游走视为一个时间齐次马尔可夫链，其转移矩阵为 $P = (p_{ij})$，其中 $p_{ij}$ 等于在一步内从节点 $i$ 移动到节点 $j$ 的概率，对于邻接矩阵 $A$ 和节点 $i$ 的度 $k_i$，有 $p_{ij} = A_{ij}/k_i$。\n- 将从 $i$ 到 $j$ 的首达时间定义为链从 $i$ 开始首次访问 $j$ 的时间。MFPT是其期望值。\n- 仅使用马尔可夫链和吸收态的基本定义来构建计算 $\\langle T \\rangle$ 的方法；不要假设任何专门的快捷公式。\n\n数值细节和单位：\n- 时间以随机游走的离散步数来衡量。以“步”为单位，将 $\\langle T \\rangle$ 报告为实数。\n- 距离以最短路径中的边数来衡量。将 $\\langle d \\rangle$ 报告为实数，将 $D$ 报告为整数。\n\n测试套件：\n- 用例 1：$N = 60$， $m = 0$， 种子 $= 1$。\n- 用例 2：$N = 60$， $m = 3$， 种子 $= 1$。\n- 用例 3：$N = 90$， $m = 0$， 种子 $= 2$。\n- 用例 4：$N = 90$， $m = 4$， 种子 $= 2$。\n- 用例 5：$N = 90$， $m = 1$， 种子 $= 42$。\n\n程序要求：\n- 对于每个测试用例，按照规定构建图，计算 $\\langle T \\rangle$、$\\langle d \\rangle$ 和 $D$，并按规定的输出格式汇总结果。\n- 最终输出格式必须是单行，包含一个用方括号括起来的、以逗号分隔的各用例结果列表。每个用例的结果本身必须是按 $[\\langle T \\rangle,\\langle d \\rangle,D]$ 顺序排列的三个值的列表。例如：$[[t_1,d_1,D_1],[t_2,d_2,D_2],\\ldots]$。\n- 将 $\\langle T \\rangle$ 和 $\\langle d \\rangle$ 表示为十进制浮点数，$D$ 表示为整数。打印数值时不得附加单位。\n\n您的实现必须完全自包含且可直接运行。不允许外部输入。程序应使用基于所提供种子的可复现随机性，并且不应依赖任何外部文件或网络访问。程序必须为给定的测试套件精确计算所有量，并仅以指定格式打印单行最终输出。",
            "solution": "该问题定义明确，并基于图论和马尔可夫链理论的既定原则。它要求为一类被称为小世界网络的图计算关键网络指标——平均测地线距离、直径和平均首达时间。解决方案首先构建指定的图，然后基于基本定义计算所需的指标。\n\n计算过程分为三个主要部分：图的构建、测地路径指标的计算以及平均首达时间的计算。\n\n**1. 图的构建**\n\n对于每个测试用例，我们都给定节点数 $N$、快捷边数 $m$ 和用于可复现性的随机种子。一个无向图由其邻接矩阵 $A$ 表示，这是一个 $N \\times N$ 的对称矩阵，其中如果节点 $i$ 和 $j$ 之间存在边，则 $A_{ij}=1$，否则 $A_{ij}=0$。\n\n首先，构建一个一维周期格（一个环）。这是通过在每个节点 $i$ 与其邻居 $(i-1) \\pmod N$ 和 $(i+1) \\pmod N$ 之间创建边来实现的，其中 $i \\in \\{0, 1, \\dots, N-1\\}$。\n\n接下来，添加 $m$ 条快捷边。生成所有可能的非相邻节点的无序对集合。从这个集合中，使用以测试用例中指定的值为种子的随机数生成器，无放回地均匀随机选择 $m$ 对。对于每个选定的对 $\\{u,v\\}$，更新邻接矩阵中的相应条目，使得 $A_{uv} = A_{vu} = 1$。得到的矩阵 $A$ 代表了将要计算指标的最终图。\n\n**2. 测地路径指标：直径 ($D$) 和平均距离 ($\\langle d \\rangle$)**\n\n在无权图中，两个节点 $i$ 和 $j$ 之间的测地线距离 $d(i,j)$ 是连接它们的最短路径中的边数。通过从图中的每个节点开始执行广度优先搜索（BFS）算法，可以系统地计算所有节点对的这些距离。这种所有对最短路径计算的结果是一个距离矩阵 $\\mathbf{D}$，其中条目 $\\mathbf{D}_{ij} = d(i,j)$。\n\n从距离矩阵 $\\mathbf{D}$ 中，按如下方式计算所需指标：\n- 图直径 $D$ 是图中任意两个节点之间的最大距离。由于图是无向的，所以 $d(i,j) = d(j,i)$，直径是距离矩阵中的最大值：\n$$ D = \\max_{i,j} d(i,j) $$\n- 平均测地线长度 $\\langle d \\rangle$ 是所有不同节点的有序对的最短路径距离的平均值。它通过将距离矩阵的所有非对角线元素求和，然后除以这类对的总数 $N(N-1)$ 来计算：\n$$ \\langle d \\rangle = \\frac{1}{N(N-1)} \\sum_{i=0}^{N-1} \\sum_{j=0, j \\neq i}^{N-1} d(i,j) $$\n\n**3. 平均首达时间 ($\\langle T \\rangle$)**\n\n图上的简单随机游走是一个离散时间的马尔可夫链。状态空间是节点集合 $\\{0, 1, \\dots, N-1\\}$。从节点 $i$ 移动到节点 $j$ 的转移概率 $P_{ij}$ 仅在它们之间有边连接时非零，此时概率为 $1/k_i$，其中 $k_i = \\sum_j A_{ij}$ 是节点 $i$ 的度。因此，转移矩阵是 $P = (P_{ij})$，且 $P_{ij} = A_{ij}/k_i$。\n\n平均首达时间（MFPT）$T_{ij}$ 是从源节点 $i$ 开始首次到达目标节点 $j$ 所需的期望步数。问题要求从基本原理出发进行计算。这可以通过考虑一个修改过的过程来实现，其中目标节点 $j$ 是一个吸收态。\n\n对于一个固定的目标节点 $j$，从任何其他节点 $i \\neq j$ 到 $j$ 的 MFPT 满足以下递推关系，该关系通过对游走的第一步进行条件化得到：\n$$ T_{ij} = 1 + \\sum_{k=0}^{N-1} P_{ik} T_{kj} $$\n这个方程表明，从 $i$ 到达 $j$ 的时间是 $1$ 步加上从新节点 $k$ 出发的期望剩余时间。我们使用边界条件，即从目标自身到达目标的时间为零，$T_{jj} = 0$。\n\n对于一个固定的目标 $j$，这为 $N-1$ 个未知值 $\\{T_{ij} | i \\neq j\\}$ 定义了一个包含 $N-1$ 个线性方程的系统。设 $S' = \\{0, 1, \\dots, N-1\\} \\setminus \\{j\\}$ 是瞬态（非目标）状态的集合。对于任何 $i \\in S'$，方程为：\n$$ T_{ij} = 1 + \\sum_{k \\in S'} P_{ik} T_{kj} + P_{ij}T_{jj} = 1 + \\sum_{k \\in S'} P_{ik} T_{kj} $$\n整理各项，我们得到：\n$$ T_{ij} - \\sum_{k \\in S'} P_{ik} T_{kj} = 1, \\quad \\forall i \\in S' $$\n这可以用矩阵形式表示。设 $\\mathbf{t}_j$ 是一个大小为 $N-1$ 的列向量，包含所有 $i \\in S'$ 的 $T_{ij}$ 值。设 $Q_j$ 是 $P$ 的一个 $(N-1) \\times (N-1)$ 子矩阵，对应于瞬态 $S'$ 之间的转移。方程组变为：\n$$ \\mathbf{t}_j - Q_j \\mathbf{t}_j = \\mathbf{1} $$\n其中 $\\mathbf{1}$ 是一个大小为 $N-1$ 的全一列向量。这可以写作：\n$$ (I - Q_j) \\mathbf{t}_j = \\mathbf{1} $$\n其中 $I$ 是 $(N-1) \\times (N-1)$ 的单位矩阵。\n\n到目标 $j$ 的 MFPT 向量 $\\mathbf{t}_j$ 可通过求解该线性方程组得到。为了数值稳定性和效率，这比直接计算矩阵逆 $(I-Q_j)^{-1}$ 更可取。对 $N$ 个可能的目标节点 $j \\in \\{0, 1, \\dots, N-1\\}$ 中的每一个重复此过程，使我们能够填充完整的 MFPT 矩阵 $\\mathbf{T} = (T_{ij})$。\n\n最后，通过对所有 $N(N-1)$ 个不同的源和目标节点的有序对的 $T_{ij}$ 进行平均，计算出平均首达时间 $\\langle T \\rangle$：\n$$ \\langle T \\rangle = \\frac{1}{N(N-1)} \\sum_{i=0}^{N-1} \\sum_{j=0, j \\neq i}^{N-1} T_{ij} $$\n\n对于每个测试用例，实现将遵循这个三部分结构，为每组参数生成所需的 $[\\langle T \\rangle, \\langle d \\rangle, D]$ 列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path\n\ndef compute_metrics(N, m, seed):\n    \"\"\"\n    Constructs a graph and computes its average MFPT, average geodesic length, and diameter.\n\n    Args:\n        N (int): The number of nodes in the graph.\n        m (int): The number of random shortcut edges to add.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        list: A list containing [average_mfpt, average_distance, diameter].\n    \"\"\"\n    # 1. Graph Construction\n    rng = np.random.default_rng(seed)\n    adj = np.zeros((N, N), dtype=int)\n    \n    # Build the ring lattice\n    for i in range(N):\n        adj[i, (i - 1) % N] = 1\n        adj[i, (i + 1) % N] = 1\n\n    # Identify all possible non-adjacent pairs for shortcuts\n    possible_shortcuts = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if adj[i, j] == 0:\n                possible_shortcuts.append((i, j))\n    \n    # Add m shortcuts\n    if m > 0 and len(possible_shortcuts) > 0:\n        if m > len(possible_shortcuts):\n            m = len(possible_shortcuts)\n        chosen_indices = rng.choice(len(possible_shortcuts), size=m, replace=False)\n        for index in chosen_indices:\n            u, v = possible_shortcuts[index]\n            adj[u, v] = 1\n            adj[v, u] = 1\n\n    # 2. Geodesic Path Metrics Calculation\n    dist_matrix = shortest_path(csgraph=adj, directed=False, unweighted=True)\n    \n    # Diameter\n    diameter = int(np.max(dist_matrix))\n    \n    # Average geodesic length\n    # Sum of all non-diagonal elements divided by N*(N-1)\n    avg_dist = np.sum(dist_matrix) / (N * (N - 1))\n    \n    # 3. Mean First Passage Time (MFPT) Calculation\n    degrees = np.sum(adj, axis=1)\n    # Transition matrix for the simple random walk\n    P = adj / degrees[:, np.newaxis]\n    \n    mfpt_matrix = np.zeros((N, N))\n    \n    for j in range(N):  # j is the target node\n        # Define the set of transient states S'\n        transient_states = list(range(N))\n        transient_states.remove(j)\n        \n        # Get the submatrix Q_j for transitions between transient states\n        Q_j = P[np.ix_(transient_states, transient_states)]\n        \n        # Form the linear system (I - Q_j) * t_j = 1\n        I_minus_Q = np.identity(N - 1) - Q_j\n        ones_vec = np.ones(N - 1)\n        \n        # Solve for the vector of MFPTs to target j\n        t_j = np.linalg.solve(I_minus_Q, ones_vec)\n        \n        # Populate the MFPT matrix\n        mfpt_matrix[transient_states, j] = t_j\n        \n    # Calculate the overall average MFPT\n    # Sum of all non-diagonal elements (diagonal is already 0)\n    avg_mfpt = np.sum(mfpt_matrix) / (N * (N - 1))\n    \n    return [avg_mfpt, avg_dist, diameter]\n\ndef main():\n    \"\"\"\n    Runs the computations for the specified test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        (60, 0, 1),\n        (60, 3, 1),\n        (90, 0, 2),\n        (90, 4, 2),\n        (90, 1, 42),\n    ]\n    \n    results = []\n    for N, m, seed in test_cases:\n        result = compute_metrics(N, m, seed)\n        results.append(result)\n    \n    # Format the final output string as per requirements\n    output_str = \"[\" + \",\".join([f\"[{t:.6f},{d:.6f},{D}]\" for t, d, D in results]) + \"]\"\n    print(output_str)\n\nif __name__ == \"__main__\":\n    main()\n```"
        }
    ]
}