{
    "hands_on_practices": [
        {
            "introduction": "掌握一个新概念，最好的方式莫过于将其应用于典型的网络结构中进行计算。环形图（Cycle Graph）是模拟去中心化、规则网络（例如环形通信协议）的理想模型。通过这个练习，你将固化对归一化度中心性的理解，并观察它在每个节点结构等价的同质化网络中的表现。",
            "id": "1495247",
            "problem": "考虑一个具有 $n$ 个顶点的图 $G$，其中 $n \\geq 3$。这些顶点被标记为 $v_1, v_2, \\dots, v_n$。其边集的构造方式是：每个顶点 $v_i$ 都与 $v_{i-1}$ 和 $v_{i+1}$ 相连，其中索引按模 $n$ 计算（因此 $v_1$ 与 $v_n$ 和 $v_2$ 相连，而 $v_n$ 与 $v_{n-1}$ 和 $v_1$ 相连）。这种特定的图拓扑结构被称为圈图，记作 $C_n$。\n\n在网络分析中，顶点的度中心性是衡量其连通性的一个基本指标。对于一个有 $N$ 个顶点的图中的一个顶点 $v$，其归一化度中心性 $C_D(v)$ 定义为该顶点的度 $\\deg(v)$ 除以一个具有 $N$ 个顶点的简单图中任何顶点可能的最大度，即 $N-1$。\n$$C_D(v) = \\frac{\\deg(v)}{N-1}$$\n\n确定圈图 $C_n$ 中任意顶点 $v_i$ 的归一化度中心性。请用关于 $n$ 的封闭形式解析表达式给出你的答案。",
            "solution": "根据构造，圈图 $C_{n}$ 有 $N=n$ 个顶点，每个顶点 $v_{i}$ 都恰好与两个顶点相邻，即 $v_{i-1}$ 和 $v_{i+1}$（索引按模 $n$ 计算）。因此，任何顶点的度都是 $\\deg(v_{i})=2$。归一化度中心性定义为\n$$\nC_{D}(v)=\\frac{\\deg(v)}{N-1}.\n$$\n代入 $N=n$ 和 $\\deg(v_{i})=2$ 可得\n$$\nC_{D}(v_{i})=\\frac{2}{n-1}.\n$$\n该表达式对于 $n\\geq 3$ 的 $C_{n}$ 中的任何 $v_{i}$ 都成立。",
            "answer": "$$\\boxed{\\frac{2}{n-1}}$$"
        },
        {
            "introduction": "在掌握了基本计算之后，让我们进入一个更深层次的问题：节点的中心性度量如何揭示网络结构的内在约束？一个网络的度序列并非仅仅是一组数字，它蕴含了关于网络拓扑可能性的基本限制。这个练习要求你扮演网络分析师的角色，通过基于简单图属性和度中心性的逻辑推理，来验证一组网络数据的有效性。这是数据验证和理论建模中的一项关键技能。",
            "id": "1495196",
            "problem": "在网络科学领域，社交网络通常被建模为一个简单图，其中顶点代表个体，边代表相互认识的关系。简单图是指没有环（连接顶点自身的边）且任意一对顶点之间最多只有一条边的图。一个顶点的未归一化度中心性，或简称为其度，是与它相连的边的数量。\n\n一位研究人员正在分析一个由5个个体组成的小型孤立群体。他们假设这个社交网络中个体的度由集合 $\\{4, 4, 3, 2, 1\\}$ 给出。然而，他们的同事声称，不可能构建一个具有5个顶点且度集为该特定集合的简单图。\n\n下列哪个陈述为此类简单图无法存在的正确逻辑原因？\n\nA. 集合中的度之和为15，是一个奇数，根据握手引理，这对于任何图都是不可能的。\n\nB. 在一个有5个顶点的简单图中，任何顶点的最大允许度为3，但该集合包含度为4的顶点。\n\nC. 存在两个度为4的顶点将要求图中所有其他顶点的度至少为2，这与存在度为1的顶点相矛盾。\n\nD. 一个简单图的度序列中不能有超过一个顶点具有最大度。",
            "solution": "假设一个具有 $n=5$ 个顶点的简单图的度序列为 $\\{4,4,3,2,1\\}$。\n\n根据握手引理，所有顶点的度之和等于边数的两倍：\n$$\n\\sum_{i=1}^{5} d_{i} \\;=\\; 2|E|.\n$$\n计算其和：\n$$\n4+4+3+2+1 \\;=\\; 14 \\;=\\; 2|E|,\n$$\n结果是偶数，因此与握手引理没有矛盾。所以，陈述A是错误的。\n\n在任何具有 $n$ 个顶点的简单图中，最大可能的度为 $n-1$。这里 $n=5$，所以最大允许度为4，度为4是允许的。因此，陈述B是错误的。\n\n现在假设在一个5顶点的简单图中，有两个顶点，称它们为 $u$ 和 $v$，它们的度都为4。度为4意味着每个顶点都与所有其他顶点相邻。因此，对于任何其他顶点 $w \\neq u,v$，边 $(u,w)$ 和 $(v,w)$ 都必须存在。所以，\n$$\n\\deg(w) \\;\\ge\\; 2 \\quad \\text{for every } w \\notin \\{u,v\\}.\n$$\n这意味着没有顶点的度可以为1，这与序列中存在1相矛盾。这正是陈述C中的逻辑，因此它是正确的。\n\n最后，陈述D通常是错误的：例如，完全图 $K_{5}$ 有五个顶点，它们的度都为最大度4。\n\n因此，正确的逻辑原因由陈述C给出。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "从静态分析到动态过程的跨越，是复杂系统研究的核心。真实网络并非一成不变，而是在不断演化。这个实践练习模拟了一个经典场景：通过移除网络中连接最多的节点来攻击网络。这个动手编程问题将揭示此类攻击所引发的非线性反馈效应——移除一个节点会改变其他节点的中心性，并可能导致网络连接性的急剧变化。这是理解网络鲁棒性和韧性的关键一步。",
            "id": "4271422",
            "problem": "考虑一个由二元邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 表示的无向简单图，其中对所有 $i,j$ 都有 $A_{ii} = 0$ 和 $A_{ij} = A_{ji}$。节点的度中心性定义为其关联边的数量，即对应行条目之和，但仅限于当前存在的节点。定义一个顺序移除策略：在每个离散步骤 $t$，计算所有剩余节点的当前度 $k_i^{(t)}$，并移除当前度中心性最大的节点；如果存在平局，则选择索引最小的节点。每次移除后，重新计算度并评估剩余图的连通性。\n\n您的推理和算法应基于以下基本定义：\n- 图 $G = (V,E)$ 由 $A$ 指定，其中 $V = \\{0,1,\\dots,n-1\\}$ 且当且仅当 $A_{ij} = 1$ 时，$(i,j) \\in E$。\n- 在步骤 $t$ 时节点 $i$ 的度为 $k_i^{(t)} = \\sum_{j \\in V^{(t)}} A_{ij}$，其中 $V^{(t)} \\subseteq V$ 是在步骤 $t$ 尚未被移除的节点集合。\n- 连通性由 $V^{(t)}$ 上的导出子图的连通分量数量确定；最大连通分量的大小是这些分量大小的最大值。\n\n实现移除策略，并按如下方式分析其对后续度和连通性的非线性反馈：\n- 在每个步骤 $t$，移除所选节点 $r$ 后，计算剩余节点的度变化向量 $\\Delta k^{(t)}$：对每个 $j \\in V^{(t+1)}$，定义 $\\Delta k_j^{(t)} = k_j^{(t+1)} - k_j^{(t)}$。\n- 定义累积非线性反馈度量 $F$ 为度变化向量的欧几里得范数平方在所有步骤上的总和：$F = \\sum_{t=1}^{T} \\sum_{j \\in V^{(t+1)}} \\left(\\Delta k_j^{(t)}\\right)^2$，其中 $T$ 是移除步骤的总数，直到 $V^{(T)}$ 为空。\n- 每次移除后，计算剩余图的最大连通分量大小并记录。同时记录在任何步骤 $t \\ge 1$ 时剩余图是否变得不连通，即连通分量数量大于 $1$。\n\n您的程序必须将上述方法应用于以下图的测试套件，每个图由其邻接矩阵 $A$ 定义，节点索引从 $0$ 开始。\n\n测试用例 1（一个 6 节点的混合连通性图）：\n$A = \\begin{bmatrix}\n0  1  1  0  0  0 \\\\\n1  0  1  1  0  0 \\\\\n1  1  0  1  0  0 \\\\\n0  1  1  0  1  0 \\\\\n0  0  0  1  0  1 \\\\\n0  0  0  0  1  0\n\\end{bmatrix}$\n\n测试用例 2（一个 5 节点的完全图 $K_5$）：\n$A = \\begin{bmatrix}\n0  1  1  1  1 \\\\\n1  0  1  1  1 \\\\\n1  1  0  1  1 \\\\\n1  1  1  0  1 \\\\\n1  1  1  1  0\n\\end{bmatrix}$\n\n测试用例 3（一个以节点 0 为中心的 6 节点星形图）：\n$A = \\begin{bmatrix}\n0  1  1  1  1  1 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0\n\\end{bmatrix}$\n\n测试用例 4（两个不相交的 6 节点三角形）：\n$A = \\begin{bmatrix}\n0  1  1  0  0  0 \\\\\n1  0  1  0  0  0 \\\\\n1  1  0  0  0  0 \\\\\n0  0  0  0  1  1 \\\\\n0  0  0  1  0  1 \\\\\n0  0  0  1  1  0\n\\end{bmatrix}$\n\n测试用例 5（一个 1 节点的单节点图）：\n$A = \\begin{bmatrix}\n0\n\\end{bmatrix}$\n\n对于每个测试用例，您的程序必须按顺序输出一个包含以下四个元素的列表：\n1. 移除序列，为节点索引的列表。\n2. 每次移除步骤后最大连通分量大小的列表（包括最后一步剩余图为空时的情况）。\n3. 如上定义的累积非线性反馈度量 $F$。\n4. 一个布尔值，指示在任何步骤 $t \\ge 1$ 时剩余图是否变得不连通。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个逗号分隔的列表，并用方括号括起来。每个测试用例的结果本身也是一个包含上述四个元素的列表。例如，一个有效的输出结构是 $[ [\\dots], [\\dots], \\dots ]$。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在图论方面有科学依据，移除策略具有确定性，问题陈述良好，并且表达客观。因此，我们可以进行形式化的求解。\n\n该问题要求我们在给定图上模拟一个顺序节点移除过程。在每一步中，移除当前度中心性最高的节点。通过选择索引最小的节点来打破平局。在此过程中，我们必须跟踪四个关键指标：被移除节点的序列、每次移除后最大连通分量（LCC）的大小、一个累积反馈度量 $F$ 以及一个指示图是否曾变得不连通的布尔标志。\n\n设图为 $G = (V, E)$，由邻接矩阵 $A$ 表示。初始节点集为 $V_0 = \\{0, 1, \\dots, n-1\\}$，其中 $n$ 是节点数。该过程通过 $n$ 个离散步骤展开，索引为 $t=1, 2, \\dots, n$。\n\n设 $V_{t-1}$ 为步骤 $t$ 之前图中存在的节点集合。在此阶段，节点 $i \\in V_{t-1}$ 的度由 $k_i(V_{t-1}) = \\sum_{j \\in V_{t-1}} A_{ij}$ 给出。\n\n算法对从 $1$ 到 $n$ 的每个步骤 $t$ 按如下方式进行：\n\n1.  **节点选择**：我们确定要移除的节点 $r_t$。这是当前集合 $V_{t-1}$ 中满足最大度准则及平局打破规则的节点：\n    $$r_t = \\min \\{ i \\in V_{t-1} \\mid k_i(V_{t-1}) = \\max_{j \\in V_{t-1}} k_j(V_{t-1}) \\}$$\n    移除序列是有序列表 $[r_1, r_2, \\dots, r_n]$。\n\n2.  **累积反馈度量 ($F$) 计算**：问题基于度变化的平方和定义了一个度量 $F$。让我们分析这个定义。图的状态从节点集 $V_{t-1}$ 过渡到 $V_t = V_{t-1} \\setminus \\{r_t\\}$。任何剩余节点 $j \\in V_t$ 的度从 $k_j(V_{t-1})$ 变为 $k_j(V_t)$。\n    在步骤 $t$ 时节点 $j$ 的度变化为：\n    $$\\Delta k_j^{(t)} = k_j(V_t) - k_j(V_{t-1})$$\n    根据度的定义，我们有：\n    $$k_j(V_{t-1}) = \\sum_{l \\in V_{t-1}} A_{jl} = \\sum_{l \\in V_t \\cup \\{r_t\\}} A_{jl} = \\left( \\sum_{l \\in V_t} A_{jl} \\right) + A_{j,r_t} = k_j(V_t) + A_{j,r_t}$$\n    因此，度的变化就是：\n    $$\\Delta k_j^{(t)} = -A_{j,r_t}$$\n    由于邻接矩阵 $A$ 是二元的，如果节点 $j$ 与被移除的节点 $r_t$ 相连，则 $\\Delta k_j^{(t)}$ 为 $-1$，否则为 $0$。\n\n    问题使用了一个稍微不同的索引约定来定义 $F$，我们遵循这个约定。它被定义为 $F = \\sum_{t=1}^{T} \\sum_{j \\in V^{(t+1)}} (\\Delta k_j^{(t)})^2$，其中 $V^{(t)}$ 表示第 $t$ 次移除前的节点集合。这对应于我们的 $V_{t-1}$。因此，$V^{(t+1)}$ 对应于我们的 $V_t$。\n    代入我们推导出的度变化表达式：\n    $$F = \\sum_{t=1}^{n} \\sum_{j \\in V_t} (-A_{j,r_t})^2 = \\sum_{t=1}^{n} \\sum_{j \\in V_t} (A_{j,r_t})^2$$\n    由于 $A_{ij} \\in \\{0,1\\}$，我们有 $A_{ij}^2 = A_{ij}$。\n    $$F = \\sum_{t=1}^{n} \\sum_{j \\in V_t} A_{j,r_t}$$\n    内层和 $\\sum_{j \\in V_t} A_{j,r_t}$ 计算的是被移除节点 $r_t$ 在其被移除*后*剩余节点中的邻居数量。这恰好是 $r_t$ 在被移除时刻图中的度，即 $k_{r_t}(V_{t-1})$。\n    $$k_{r_t}(V_{t-1}) = \\sum_{j \\in V_{t-1}, j \\neq r_t} A_{r_t,j} = \\sum_{j \\in V_t} A_{j,r_t}$$\n    因此，度量 $F$ 简化为节点在被移除时其度的总和：\n    $$F = \\sum_{t=1}^{n} k_{r_t}(V_{t-1})$$\n    这就是我们将要计算的量。\n\n3.  **连通性分析**：每次移除 $r_t$ 后，我们得到节点集 $V_t$ 上的导出子图。我们必须确定连通分量的数量和最大连通分量（LCC）的大小。这可以通过图遍历算法（如广度优先搜索 (BFS) 或深度优先搜索 (DFS)）来完成。我们遍历 $V_t$ 中的所有节点。如果一个节点尚未被访问，我们从它开始进行遍历，计算所有可达节点以找到其分量的大小，并将它们标记为已访问。我们跟踪找到的最大分量大小。空图（在最后一次移除后）的LCC大小为 $0$。LCC大小的列表将有 $n$ 个元素，对应于 $n$ 次移除后每次的图状态。\n\n4.  **不连通标志**：如果一个图有一个以上的连通分量，则称其为不连通的。这仅对至少有两个节点的图有意义。我们初始化一个布尔标志 `is_disconnected` 为 `False`。在每个步骤 $t \\in \\{1, \\dots, n-1\\}$，移除 $r_t$ 后，我们检查剩余图 $V_t$ 上的连通分量数量是否大于 $1$。如果是，我们将该标志设置为 `True`。报告此标志的最终值。\n\n对于给定的邻接矩阵 $A$，整体算法如下：\n1. 初始化活动节点集 $V_{active}$ 为 $\\{0, \\dots, n-1\\}$。初始化移除序列、LCC大小列表、$F$ 和不连通标志。\n2. 对于 $t=1$ 到 $n$：\n    a. 在由 $V_{active}$ 导出的子图中，计算所有 $i \\in V_{active}$ 的度。\n    b. 选择度最大（平局时索引最小）的节点 $r_t$。\n    c. 将 $r_t$ 的计算度数加到 $F$ 上。\n    d. 将 $r_t$ 追加到移除序列中。\n    e. 从 $V_{active}$ 中移除 $r_t$。\n    f. 对由新的 $V_{active}$ 导出的子图进行连通性分析（例如，使用BFS）。\n    g. 将得到的 LCC 大小追加到 LCC 大小列表中。\n    h. 如果分量数量大于 $1$，则将不连通标志设置为 `True`。\n3. 以列表形式返回四个计算出的度量。\n此过程应用于每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the node removal simulation on all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        np.array([\n            [0, 1, 1, 0, 0, 0],\n            [1, 0, 1, 1, 0, 0],\n            [1, 1, 0, 1, 0, 0],\n            [0, 1, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0, 1],\n            [0, 0, 0, 0, 1, 0]\n        ]),\n        # Test case 2\n        np.array([\n            [0, 1, 1, 1, 1],\n            [1, 0, 1, 1, 1],\n            [1, 1, 0, 1, 1],\n            [1, 1, 1, 0, 1],\n            [1, 1, 1, 1, 0]\n        ]),\n        # Test case 3\n        np.array([\n            [0, 1, 1, 1, 1, 1],\n            [1, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0]\n        ]),\n        # Test case 4\n        np.array([\n            [0, 1, 1, 0, 0, 0],\n            [1, 0, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0, 0],\n            [0, 0, 0, 0, 1, 1],\n            [0, 0, 0, 1, 0, 1],\n            [0, 0, 0, 1, 1, 0]\n        ]),\n        # Test case 5\n        np.array([\n            [0]\n        ])\n    ]\n\n    results = []\n    for A in test_cases:\n        result = process_graph(A)\n        results.append(result)\n\n    # Convert results to string representation for the final output format.\n    # The default str() for lists creates the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_graph(A):\n    \"\"\"\n    Applies the sequential removal strategy to a single graph.\n    \n    Args:\n        A (np.ndarray): The adjacency matrix of the graph.\n\n    Returns:\n        list: A list containing [removal_sequence, lcc_sizes, F, was_disconnected].\n    \"\"\"\n    n = A.shape[0]\n    if n == 0:\n        return [[], [0], 0, False]\n\n    active_nodes = list(range(n))\n    adj = A.copy()\n\n    removal_sequence = []\n    lcc_sizes = []\n    F = 0\n    was_disconnected = False\n\n    for _ in range(n):\n        if not active_nodes:\n            # This branch should not be hit in a standard n-step loop\n            # But is good practice for robustness.\n            break\n\n        # Step 1: Compute degrees and find node to remove\n        degrees = {node: 0 for node in active_nodes}\n        for i in active_nodes:\n            degree = 0\n            for j in active_nodes:\n                if adj[i, j] == 1:\n                    degree += 1\n            degrees[i] = degree\n\n        max_deg = -1\n        node_to_remove = -1\n\n        # Iterate through sorted active nodes to handle tie-breaking\n        # (smallest index for same max degree)\n        for node in sorted(degrees.keys()):\n            if degrees[node] > max_deg:\n                max_deg = degrees[node]\n                node_to_remove = node\n\n        # Step 2: Update metrics based on the removal\n        removal_sequence.append(node_to_remove)\n        F += max_deg\n        active_nodes.remove(node_to_remove)\n\n        # Step 3: Analyze connectivity of the remaining graph\n        lcc_size, num_components = analyze_connectivity(adj, active_nodes)\n        lcc_sizes.append(lcc_size)\n        if num_components > 1:\n            was_disconnected = True\n\n    return [removal_sequence, lcc_sizes, F, was_disconnected]\n\ndef analyze_connectivity(adj, nodes):\n    \"\"\"\n    Finds the number of connected components and the size of the largest one.\n\n    Args:\n        adj (np.ndarray): The full adjacency matrix.\n        nodes (list): The list of currently active nodes.\n\n    Returns:\n        tuple: (largest_component_size, number_of_components)\n    \"\"\"\n    if not nodes:\n        return 0, 0\n\n    visited = set()\n    num_components = 0\n    max_size = 0\n    \n    # Create a set from the list for efficient 'in' checks\n    node_set = set(nodes)\n\n    for start_node in nodes:\n        if start_node not in visited:\n            num_components += 1\n            component_size = 0\n            q = [start_node]  # Queue for BFS\n            visited.add(start_node)\n            \n            while q:\n                u = q.pop(0)\n                component_size += 1\n                \n                # Check neighbors\n                for v_idx, is_neighbor in enumerate(adj[u]):\n                    if is_neighbor and v_idx in node_set and v_idx not in visited:\n                        visited.add(v_idx)\n                        q.append(v_idx)\n            \n            if component_size > max_size:\n                max_size = component_size\n                \n    return max_size, num_components\n\nsolve()\n```"
        }
    ]
}