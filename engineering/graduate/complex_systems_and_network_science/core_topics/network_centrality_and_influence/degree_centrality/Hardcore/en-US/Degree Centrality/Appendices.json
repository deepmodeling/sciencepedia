{
    "hands_on_practices": [
        {
            "introduction": "To build a strong foundation, we begin by analyzing degree centrality in one of the most fundamental network topologies: the star graph. This exercise  challenges you to quantify the influence of nodes in a perfectly centralized system. By comparing the centrality of the hub to that of a peripheral node, you will develop a concrete intuition for how this measure reflects a node's structural importance.",
            "id": "1495207",
            "problem": "A simple computer network is designed with a total of $n$ nodes, where $n \\geq 3$. The network architecture is centralized: one node acts as a 'central hub' and is directly connected to each of the other $n-1$ 'peripheral' nodes. The peripheral nodes are not connected to each other. In this network, the \"normalized influence\" of a node is a measure of its direct connectivity. It is calculated by taking the number of direct connections a node has and dividing this by the maximum possible number of direct connections any single node could have in a network of $n$ nodes, which is $n-1$.\n\nDetermine the ratio of the normalized influence of the central hub to the normalized influence of any single peripheral node. Express your answer as a function of $n$.",
            "solution": "Let $n \\geq 3$ be the total number of nodes. In a centralized star network, one node (the hub) is directly connected to all other $n-1$ nodes, and each peripheral node is connected only to the hub.\n\nBy definition, the normalized influence of a node is its number of direct connections (degree) divided by the maximum possible number of direct connections any node could have in a network of $n$ nodes, which is $n-1$.\n\n1) For the central hub, the degree is $n-1$. Its normalized influence is therefore\n$$\nI_{\\text{hub}}=\\frac{n-1}{n-1}=1.\n$$\n\n2) For any peripheral node, the degree is $1$. Its normalized influence is therefore\n$$\nI_{\\text{per}}=\\frac{1}{n-1}.\n$$\n\n3) The required ratio of the normalized influence of the hub to that of a peripheral node is\n$$\nR=\\frac{I_{\\text{hub}}}{I_{\\text{per}}}=\\frac{1}{\\frac{1}{n-1}}=n-1.\n$$\nThus, the ratio as a function of $n$ is $n-1$.",
            "answer": "$$\\boxed{n-1}$$"
        },
        {
            "introduction": "Degree centrality is not just a descriptive statistic; it imposes fundamental constraints on a network's structure. This next problem  shifts our focus from calculation to logical deduction, asking you to determine why a specific set of degrees is impossible for a simple graph. Solving this puzzle will deepen your understanding of how local properties like degree dictate global network topology.",
            "id": "1495196",
            "problem": "In the field of network science, a social network is often modeled as a simple graph, where vertices represent individuals and edges represent a mutual acquaintance. A simple graph is one that has no loops (edges connecting a vertex to itself) and no more than one edge between any pair of vertices. The unnormalized degree centrality of a vertex, or simply its degree, is the number of edges connected to it.\n\nA researcher is analyzing a small, isolated group of 5 individuals. They hypothesize that the degrees of the individuals in this social network are given by the set $\\{4, 4, 3, 2, 1\\}$. However, their colleague claims that it is impossible to construct a simple graph with 5 vertices that has this specific set of degrees.\n\nWhich of the following statements provides the correct logical reason for why such a simple graph cannot exist?\n\nA. The sum of the degrees in the set is 15, an odd number, which is not possible for any graph according to the handshaking lemma.\n\nB. In a simple graph with 5 vertices, the maximum allowed degree for any vertex is 3, but the set contains degrees of 4.\n\nC. The existence of two vertices with degree 4 would require every other vertex in the graph to have a degree of at least 2, which contradicts the presence of a vertex with degree 1.\n\nD. A simple graph cannot have more than one vertex with the maximum degree present in its degree sequence.",
            "solution": "Let the purported degree sequence be $\\{4,4,3,2,1\\}$ for a simple graph on $n=5$ vertices.\n\nBy the handshaking lemma, the sum of the degrees equals twice the number of edges:\n$$\n\\sum_{i=1}^{5} d_{i} \\;=\\; 2|E|.\n$$\nCompute the sum:\n$$\n4+4+3+2+1 \\;=\\; 14 \\;=\\; 2|E|,\n$$\nwhich is even, so there is no contradiction with the handshaking lemma. Therefore, statement A is false.\n\nIn any simple graph on $n$ vertices, the maximum possible degree is $n-1$. Here $n=5$, so the maximum allowed degree is $4$, and degrees of $4$ are permissible. Therefore, statement B is false.\n\nNow suppose there are two vertices, call them $u$ and $v$, each of degree $4$ in a $5$-vertex simple graph. Degree $4$ means each is adjacent to every other vertex. Hence, for any other vertex $w \\neq u,v$, both edges $(u,w)$ and $(v,w)$ must be present. Therefore,\n$$\n\\deg(w) \\;\\ge\\; 2 \\quad \\text{for every } w \\notin \\{u,v\\}.\n$$\nThis implies that no vertex can have degree $1$, contradicting the presence of $1$ in the sequence. This is exactly the logic in statement C, which is therefore correct.\n\nFinally, statement D is false in general: for example, the complete graph $K_{5}$ has five vertices all with the maximum degree $4$.\n\nThus, the correct logical reason is given by statement C.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "Our final practice is a graduate-level challenge that moves from static analysis to the dynamics of network resilience. In this simulation , you will implement a targeted attack strategy, sequentially removing nodes with the highest degree centrality. This exercise provides critical, hands-on experience in analyzing how local interventions can trigger cascading changes and affect the global connectivity of the entire system.",
            "id": "4271422",
            "problem": "Consider an undirected, simple graph represented by a binary adjacency matrix $A \\in \\{0,1\\}^{n \\times n}$ with $A_{ii} = 0$ and $A_{ij} = A_{ji}$ for all $i,j$. The degree centrality of a node is defined as the count of incident edges, which is the sum of the corresponding row entries restricted to nodes currently present. Define a sequential removal strategy where at each discrete step $t$, you compute the current degrees $k_i^{(t)}$ for all remaining nodes and remove the node with maximal current degree centrality; if there is a tie, select the node with the smallest index. After each removal, recompute degrees and assess connectivity of the remaining graph.\n\nBase your reasoning and algorithm on the following fundamental definitions:\n- A graph $G = (V,E)$ is specified by $A$, where $V = \\{0,1,\\dots,n-1\\}$ and $(i,j) \\in E$ if and only if $A_{ij} = 1$.\n- The degree of a node $i$ at step $t$ is $k_i^{(t)} = \\sum_{j \\in V^{(t)}} A_{ij}$, where $V^{(t)} \\subseteq V$ is the set of nodes not yet removed at step $t$.\n- Connectivity is determined by the number of connected components of the induced subgraph on $V^{(t)}$; the largest connected component size is the maximum over sizes of these components.\n\nImplement the removal strategy and analyze the nonlinear feedback on subsequent degrees and connectivity as follows:\n- At each step $t$, after removing the chosen node $r$, compute the degree change vector $\\Delta k^{(t)}$ for the remaining nodes: for each $j \\in V^{(t+1)}$, define $\\Delta k_j^{(t)} = k_j^{(t+1)} - k_j^{(t)}$.\n- Define the cumulative nonlinear feedback metric $F$ as the sum over steps of the squared Euclidean norm of the degree change vector: $F = \\sum_{t=1}^{T} \\sum_{j \\in V^{(t+1)}} \\left(\\Delta k_j^{(t)}\\right)^2$, where $T$ is the total number of removal steps until $V^{(T)}$ is empty.\n- After each removal, compute the largest connected component size of the remaining graph and record it. Also record whether the remaining graph is disconnected at any step $t \\ge 1$, meaning the number of connected components is greater than $1$.\n\nYour program must apply the above to the following test suite of graphs, each defined by its adjacency matrix $A$, with node indices starting at $0$.\n\nTest case $1$ (a mixed-connectivity graph on $6$ nodes):\n$A = \\begin{bmatrix}\n0 & 1 & 1 & 0 & 0 & 0 \\\\\n1 & 0 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 0 \\\\\n0 & 1 & 1 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 0 & 1 & 0\n\\end{bmatrix}$\n\nTest case $2$ (the complete graph $K_5$ on $5$ nodes):\n$A = \\begin{bmatrix}\n0 & 1 & 1 & 1 & 1 \\\\\n1 & 0 & 1 & 1 & 1 \\\\\n1 & 1 & 0 & 1 & 1 \\\\\n1 & 1 & 1 & 0 & 1 \\\\\n1 & 1 & 1 & 1 & 0\n\\end{bmatrix}$\n\nTest case $3$ (a star graph on $6$ nodes with center at node $0$):\n$A = \\begin{bmatrix}\n0 & 1 & 1 & 1 & 1 & 1 \\\\\n1 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0\n\\end{bmatrix}$\n\nTest case $4$ (two disjoint triangles on $6$ nodes):\n$A = \\begin{bmatrix}\n0 & 1 & 1 & 0 & 0 & 0 \\\\\n1 & 0 & 1 & 0 & 0 & 0 \\\\\n1 & 1 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 1 & 1 \\\\\n0 & 0 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 1 & 1 & 0\n\\end{bmatrix}$\n\nTest case $5$ (a single-node graph on $1$ node):\n$A = \\begin{bmatrix}\n0\n\\end{bmatrix}$\n\nFor each test case, your program must output a list with the following four elements in order:\n$1.$ The removal sequence as a list of node indices.\n$2.$ The list of largest connected component sizes after each removal step (including the final step when the remaining graph is empty).\n$3.$ The cumulative nonlinear feedback metric $F$ as defined above.\n$4.$ A boolean indicating whether the remaining graph is disconnected at any step $t \\ge 1$.\n\nFinal output format:\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each test case result is itself a list of the four elements described above. For example, a valid output structure is $[ [\\dots], [\\dots], \\dots ]$.",
            "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically grounded in graph theory, well-posed with a deterministic removal strategy, and expressed objectively. We may therefore proceed with a formal solution.\n\nThe problem requires us to simulate a sequential node removal process on a given graph. At each step, the node with the highest current degree centrality is removed. Ties are broken by choosing the node with the smallest index. We must track four key metrics throughout this process: the sequence of removed nodes, the size of the largest connected component (LCC) after each removal, a cumulative feedback metric $F$, and a boolean flag indicating if the graph ever becomes disconnected.\n\nLet the graph be $G = (V, E)$, represented by an adjacency matrix $A$. The initial set of nodes is $V_0 = \\{0, 1, \\dots, n-1\\}$, where $n$ is the number of nodes. The process unfolds over $n$ discrete steps, indexed by $t=1, 2, \\dots, n$.\n\nLet $V_{t-1}$ be the set of nodes present in the graph just before step $t$. The degree of a node $i \\in V_{t-1}$ at this stage is given by $k_i(V_{t-1}) = \\sum_{j \\in V_{t-1}} A_{ij}$.\n\nThe algorithm proceeds as follows for each step $t$ from $1$ to $n$:\n\n1.  **Node Selection**: We identify the node to be removed, $r_t$. This is the node in the current set $V_{t-1}$ that satisfies the maximal degree criterion with the a tie-breaking rule:\n    $$r_t = \\min \\{ i \\in V_{t-1} \\mid k_i(V_{t-1}) = \\max_{j \\in V_{t-1}} k_j(V_{t-1}) \\}$$\n    The removal sequence is the ordered list $[r_1, r_2, \\dots, r_n]$.\n\n2.  **Cumulative Feedback Metric ($F$) Calculation**: The problem defines a metric $F$ based on the sum of squared degree changes. Let us analyze this definition. The state of the graph transitions from having node set $V_{t-1}$ to $V_t = V_{t-1} \\setminus \\{r_t\\}$. The degree of any remaining node $j \\in V_t$ changes from $k_j(V_{t-1})$ to $k_j(V_t)$.\n    The change in degree for node $j$ at step $t$ is:\n    $$\\Delta k_j^{(t)} = k_j(V_t) - k_j(V_{t-1})$$\n    From the definition of degree, we have:\n    $$k_j(V_{t-1}) = \\sum_{l \\in V_{t-1}} A_{jl} = \\sum_{l \\in V_t \\cup \\{r_t\\}} A_{jl} = \\left( \\sum_{l \\in V_t} A_{jl} \\right) + A_{j,r_t} = k_j(V_t) + A_{j,r_t}$$\n    Therefore, the degree change is simply:\n    $$\\Delta k_j^{(t)} = -A_{j,r_t}$$\n    Since the adjacency matrix $A$ is binary, $\\Delta k_j^{(t)}$ is either $-1$ if node $j$ was connected to the removed node $r_t$, or $0$ otherwise.\n\n    The problem defines $F$ using a slightly different indexing convention, which we conform to. It is defined as $F = \\sum_{t=1}^{T} \\sum_{j \\in V^{(t+1)}} (\\Delta k_j^{(t)})^2$, where $V^{(t)}$ represents the set of nodes before the $t$-th removal. This corresponds to our $V_{t-1}$. Consequently, $V^{(t+1)}$ corresponds to our $V_t$.\n    Substituting our derived expression for the degree change:\n    $$F = \\sum_{t=1}^{n} \\sum_{j \\in V_t} (-A_{j,r_t})^2 = \\sum_{t=1}^{n} \\sum_{j \\in V_t} (A_{j,r_t})^2$$\n    As $A_{ij} \\in \\{0,1\\}$, we have $A_{ij}^2 = A_{ij}$.\n    $$F = \\sum_{t=1}^{n} \\sum_{j \\in V_t} A_{j,r_t}$$\n    The inner sum, $\\sum_{j \\in V_t} A_{j,r_t}$, counts the neighbors of the removed node $r_t$ among the nodes that remain *after* its removal. This is precisely the degree of $r_t$ within the graph at the moment of its removal, i.e., $k_{r_t}(V_{t-1})$.\n    $$k_{r_t}(V_{t-1}) = \\sum_{j \\in V_{t-1}, j \\neq r_t} A_{r_t,j} = \\sum_{j \\in V_t} A_{j,r_t}$$\n    Thus, the metric $F$ simplifies to the sum of the degrees of the nodes at the time they are removed:\n    $$F = \\sum_{t=1}^{n} k_{r_t}(V_{t-1})$$\n    This is the quantity we will compute.\n\n3.  **Connectivity Analysis**: After each removal of $r_t$, we are left with the induced subgraph on the node set $V_t$. We must determine the number of connected components and the size of the largest one (LCC). This can be accomplished using a graph traversal algorithm such as Breadth-First Search (BFS) or Depth-First Search (DFS). We iterate through all nodes in $V_t$. If a node has not yet been visited, we start a traversal from it, counting all reachable nodes to find the size of its component and marking them as visited. We track the maximum component size found. The LCC size for the empty graph (after the final removal) is $0$. The list of LCC sizes will have $n$ elements, corresponding to the state of the graph after each of the $n$ removals.\n\n4.  **Disconnection Flag**: A graph is disconnected if it has more than one connected component. This is only meaningful for graphs with at least two nodes. We initialize a boolean flag `is_disconnected` to `False`. At each step $t \\in \\{1, \\dots, n-1\\}$, after removing $r_t$, we check if the number of connected components in the remaining graph on $V_t$ is greater than $1$. If it is, we set the flag to `True`. The final value of this flag is reported.\n\nThe overall algorithm for a given adjacency matrix $A$ is:\n1. Initialize an active node set $V_{active}$ to $\\{0, \\dots, n-1\\}$. Initialize the removal sequence, LCC size list, $F$, and the disconnection flag.\n2. For $t=1$ to $n$:\n    a. Compute degrees for all $i \\in V_{active}$ within the subgraph induced by $V_{active}$.\n    b. Select node $r_t$ with maximum degree (and minimum index for ties).\n    c. Add the computed degree of $r_t$ to $F$.\n    d. Append $r_t$ to the removal sequence.\n    e. Remove $r_t$ from $V_{active}$.\n    f. Perform a connectivity analysis (e.g., using BFS) on the subgraph induced by the new $V_{active}$.\n    g. Append the resulting LCC size to the LCC size list.\n    h. If the number of components is greater than $1$, set the disconnection flag to `True`.\n3. Return the four computed metrics as a list.\nThis procedure is applied to each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the node removal simulation on all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        np.array([\n            [0, 1, 1, 0, 0, 0],\n            [1, 0, 1, 1, 0, 0],\n            [1, 1, 0, 1, 0, 0],\n            [0, 1, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0, 1],\n            [0, 0, 0, 0, 1, 0]\n        ]),\n        # Test case 2\n        np.array([\n            [0, 1, 1, 1, 1],\n            [1, 0, 1, 1, 1],\n            [1, 1, 0, 1, 1],\n            [1, 1, 1, 0, 1],\n            [1, 1, 1, 1, 0]\n        ]),\n        # Test case 3\n        np.array([\n            [0, 1, 1, 1, 1, 1],\n            [1, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0]\n        ]),\n        # Test case 4\n        np.array([\n            [0, 1, 1, 0, 0, 0],\n            [1, 0, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0, 0],\n            [0, 0, 0, 0, 1, 1],\n            [0, 0, 0, 1, 0, 1],\n            [0, 0, 0, 1, 1, 0]\n        ]),\n        # Test case 5\n        np.array([\n            [0]\n        ])\n    ]\n\n    results = []\n    for A in test_cases:\n        result = process_graph(A)\n        results.append(result)\n\n    # Convert results to string representation for the final output format.\n    # The default str() for lists creates the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_graph(A):\n    \"\"\"\n    Applies the sequential removal strategy to a single graph.\n    \n    Args:\n        A (np.ndarray): The adjacency matrix of the graph.\n\n    Returns:\n        list: A list containing [removal_sequence, lcc_sizes, F, was_disconnected].\n    \"\"\"\n    n = A.shape[0]\n    if n == 0:\n        return [[], [0], 0, False]\n\n    active_nodes = list(range(n))\n    adj = A.copy()\n\n    removal_sequence = []\n    lcc_sizes = []\n    F = 0\n    was_disconnected = False\n\n    for _ in range(n):\n        if not active_nodes:\n            # This branch should not be hit in a standard n-step loop\n            # But is good practice for robustness.\n            break\n\n        # Step 1: Compute degrees and find node to remove\n        degrees = {node: 0 for node in active_nodes}\n        for i in active_nodes:\n            degree = 0\n            for j in active_nodes:\n                if adj[i, j] == 1:\n                    degree += 1\n            degrees[i] = degree\n\n        max_deg = -1\n        node_to_remove = -1\n\n        # Iterate through sorted active nodes to handle tie-breaking\n        # (smallest index for same max degree)\n        for node in sorted(degrees.keys()):\n            if degrees[node] > max_deg:\n                max_deg = degrees[node]\n                node_to_remove = node\n\n        # Step 2: Update metrics based on the removal\n        removal_sequence.append(node_to_remove)\n        F += max_deg\n        active_nodes.remove(node_to_remove)\n\n        # Step 3: Analyze connectivity of the remaining graph\n        lcc_size, num_components = analyze_connectivity(adj, active_nodes)\n        lcc_sizes.append(lcc_size)\n        if num_components > 1:\n            was_disconnected = True\n\n    return [removal_sequence, lcc_sizes, F, was_disconnected]\n\ndef analyze_connectivity(adj, nodes):\n    \"\"\"\n    Finds the number of connected components and the size of the largest one.\n\n    Args:\n        adj (np.ndarray): The full adjacency matrix.\n        nodes (list): The list of currently active nodes.\n\n    Returns:\n        tuple: (largest_component_size, number_of_components)\n    \"\"\"\n    if not nodes:\n        return 0, 0\n\n    visited = set()\n    num_components = 0\n    max_size = 0\n    \n    # Create a set from the list for efficient 'in' checks\n    node_set = set(nodes)\n\n    for start_node in nodes:\n        if start_node not in visited:\n            num_components += 1\n            component_size = 0\n            q = [start_node]  # Queue for BFS\n            visited.add(start_node)\n            \n            while q:\n                u = q.pop(0)\n                component_size += 1\n                \n                # Check neighbors\n                for v_idx, is_neighbor in enumerate(adj[u]):\n                    if is_neighbor and v_idx in node_set and v_idx not in visited:\n                        visited.add(v_idx)\n                        q.append(v_idx)\n            \n            if component_size > max_size:\n                max_size = component_size\n                \n    return max_size, num_components\n\nsolve()\n```"
        }
    ]
}