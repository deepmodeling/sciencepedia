{
    "hands_on_practices": [
        {
            "introduction": "本练习将通过一个星形图来探讨度中心性最直观的应用。星形图是模拟高度中心化系统（例如一台主服务器连接多个客户端）的理想假设模型。通过计算并比较中心枢纽与外围节点的中心性，你将具体理解该指标如何量化一个节点的结构重要性。",
            "id": "1495207",
            "problem": "一个简单的计算机网络设计有总共 $n$ 个节点，其中 $n \\geq 3$。该网络架构是中心化的：一个节点作为“中心枢纽”，并直接连接到其他所有 $n-1$ 个“外围”节点。外围节点之间不互相连接。在这个网络中，一个节点的“归一化影响力”是其直接连接性的一个度量。它的计算方法是，取一个节点拥有的直接连接数，并将其除以在一个包含 $n$ 个节点的网络中任何单个节点可能拥有的最大直接连接数，即 $n-1$。\n\n确定中心枢纽的归一化影响力与任何单个外围节点的归一化影响力之比。将你的答案表示为关于 $n$ 的函数。",
            "solution": "设 $n \\geq 3$ 是节点的总数。在一个中心化的星形网络中，一个节点（枢纽）直接连接到所有其他 $n-1$ 个节点，而每个外围节点只连接到枢纽。\n\n根据定义，一个节点的归一化影响力是其直接连接数（度）除以在一个包含 $n$ 个节点的网络中任何节点可能拥有的最大直接连接数，即 $n-1$。\n\n1) 对于中心枢纽，其度为 $n-1$。因此其归一化影响力为\n$$\nI_{\\text{hub}}=\\frac{n-1}{n-1}=1.\n$$\n\n2) 对于任何一个外围节点，其度为 $1$。因此其归一化影响力为\n$$\nI_{\\text{per}}=\\frac{1}{n-1}.\n$$\n\n3) 所求的枢纽的归一化影响力与外围节点的归一化影响力之比为\n$$\nR=\\frac{I_{\\text{hub}}}{I_{\\text{per}}}=\\frac{1}{\\frac{1}{n-1}}=n-1.\n$$\n因此，作为 $n$ 的函数的比率是 $n-1$。",
            "answer": "$$\\boxed{n-1}$$"
        },
        {
            "introduction": "与中心化的星形图形成对比，本练习将考察一种去中心化的结构：环形图。这种拓扑结构可以代表简单的点对点网络或环形通信系统，其中没有单个节点占据特权位置。通过计算环形图中节点的度中心性，你将看到该指标如何反映网络的结构同质性，并为理解更复杂的非层级网络提供了基础。",
            "id": "1495247",
            "problem": "考虑一个图 $G$，它有 $n$ 个顶点，其中 $n \\geq 3$。这些顶点被标记为 $v_1, v_2, \\dots, v_n$。其边集的构造方式是，每个顶点 $v_i$ 都与 $v_{i-1}$ 和 $v_{i+1}$ 相连，其中索引按模 $n$ 计算（因此 $v_1$ 与 $v_n$ 和 $v_2$ 相连，而 $v_n$ 与 $v_{n-1}$ 和 $v_1$ 相连）。这种特定的图拓扑结构被称为圈图，记作 $C_n$。\n\n在网络分析中，顶点的度中心性是衡量其连通性的一个基本指标。对于一个有 $N$ 个顶点的图中的顶点 $v$，其归一化度中心性 $C_D(v)$ 定义为该顶点的度 $\\deg(v)$ 除以一个具有 $N$ 个顶点的简单图中任意顶点可能的最大度，即 $N-1$。\n$$C_D(v) = \\frac{\\deg(v)}{N-1}$$\n\n确定圈图 $C_n$ 中任意顶点 $v_i$ 的归一化度中心性。请用一个关于 $n$ 的封闭形式解析表达式给出你的答案。",
            "solution": "根据构造，圈图 $C_{n}$ 有 $N=n$ 个顶点，每个顶点 $v_{i}$ 恰好与两个顶点相邻，即 $v_{i-1}$ 和 $v_{i+1}$（索引按模 $n$ 计算）。因此，任何顶点的度都是 $\\deg(v_{i})=2$。归一化度中心性的定义为\n$$\nC_{D}(v)=\\frac{\\deg(v)}{N-1}.\n$$\n代入 $N=n$ 和 $\\deg(v_{i})=2$ 可得\n$$\nC_{D}(v_{i})=\\frac{2}{n-1}.\n$$\n对于 $n\\geq 3$ 的 $C_{n}$ 中的任何 $v_{i}$，此表达式均成立。",
            "answer": "$$\\boxed{\\frac{2}{n-1}}$$"
        },
        {
            "introduction": "本高级练习超越了静态测量，深入探讨了度中心性的动态影响。你将实现一个节点移除策略，模拟针对网络中连接最紧密的节点发起的蓄意攻击。此练习不仅是计算，更是一场计算实验，旨在探索网络韧性、连通性以及网络结构演化过程中出现的非线性反馈效应，这些都是复杂系统研究中的核心概念。",
            "id": "4271422",
            "problem": "考虑一个由二元邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 表示的无向简单图，其中对于所有 $i,j$，都有 $A_{ii} = 0$ 和 $A_{ij} = A_{ji}$。节点的度中心性定义为其关联边的数量，即对应行条目中当前存在节点的总和。定义一个顺序移除策略：在每个离散步骤 $t$，为所有剩余节点计算当前度 $k_i^{(t)}$，并移除具有最大当前度中心性的节点；如果存在平局，则选择索引最小的节点。每次移除后，重新计算度数并评估剩余图的连通性。\n\n请将您的推理和算法建立在以下基本定义之上：\n- 图 $G = (V,E)$ 由 $A$ 指定，其中 $V = \\{0,1,\\dots,n-1\\}$ 且 $(i,j) \\in E$ 当且仅当 $A_{ij} = 1$。\n- 在步骤 $t$，节点 $i$ 的度为 $k_i^{(t)} = \\sum_{j \\in V^{(t)}} A_{ij}$，其中 $V^{(t)} \\subseteq V$ 是在步骤 $t$ 尚未被移除的节点集合。\n- 连通性由 $V^{(t)}$ 上的诱导子图的连通分量数量确定；最大连通分量的大小是这些分量大小的最大值。\n\n实施移除策略并按如下方式分析对后续度数和连通性的非线性反馈：\n- 在每个步骤 $t$，移除选定节点 $r$ 后，计算剩余节点的度变化向量 $\\Delta k^{(t)}$：对于每个 $j \\in V^{(t+1)}$，定义 $\\Delta k_j^{(t)} = k_j^{(t+1)} - k_j^{(t)}$。\n- 定义累积非线性反馈度量 $F$ 为各步骤中度变化向量的欧几里得范数平方之和：$F = \\sum_{t=1}^{T} \\sum_{j \\in V^{(t+1)}} \\left(\\Delta k_j^{(t)}\\right)^2$，其中 $T$ 是移除步骤的总数，直到 $V^{(T)}$ 为空。\n- 每次移除后，计算剩余图的最大连通分量大小并记录下来。同时记录在任何步骤 $t \\ge 1$ 时剩余图是否变得不连通，即连通分量的数量大于 $1$。\n\n您的程序必须将上述方法应用于以下图的测试套件，每个图由其邻接矩阵 $A$ 定义，节点索引从 $0$ 开始。\n\n测试用例 1（一个包含 $6$ 个节点的混合连通性图）：\n$A = \\begin{bmatrix}\n0  1  1  0  0  0 \\\\\n1  0  1  1  0  0 \\\\\n1  1  0  1  0  0 \\\\\n0  1  1  0  1  0 \\\\\n0  0  0  1  0  1 \\\\\n0  0  0  0  1  0\n\\end{bmatrix}$\n\n测试用例 2（一个包含 $5$ 个节点的完全图 $K_5$）：\n$A = \\begin{bmatrix}\n0  1  1  1  1 \\\\\n1  0  1  1  1 \\\\\n1  1  0  1  1 \\\\\n1  1  1  0  1 \\\\\n1  1  1  1  0\n\\end{bmatrix}$\n\n测试用例 3（一个包含 $6$ 个节点、中心为节点 $0$ 的星形图）：\n$A = \\begin{bmatrix}\n0  1  1  1  1  1 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0 \\\\\n1  0  0  0  0  0\n\\end{bmatrix}$\n\n测试用例 4（一个包含 $6$ 个节点的两个不相交的三角形）：\n$A = \\begin{bmatrix}\n0  1  1  0  0  0 \\\\\n1  0  1  0  0  0 \\\\\n1  1  0  0  0  0 \\\\\n0  0  0  0  1  1 \\\\\n0  0  0  1  0  1 \\\\\n0  0  0  1  1  0\n\\end{bmatrix}$\n\n测试用例 5（一个包含 $1$ 个节点的单节点图）：\n$A = \\begin{bmatrix}\n0\n\\end{bmatrix}$\n\n对于每个测试用例，您的程序必须按顺序输出一个包含以下四个元素的列表：\n$1.$ 移除序列，以节点索引列表的形式表示。\n$2.$ 每次移除步骤后最大连通分量大小的列表（包括剩余图为空的最后一步）。\n$3.$ 如上文定义的累积非线性反馈度量 $F$。\n$4.$ 一个布尔值，指示在任何步骤 $t \\ge 1$ 时剩余图是否变得不连通。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，其中每个测试用例的结果本身就是包含上述四个元素的列表。例如，一个有效的输出结构是 $[ [\\dots], [\\dots], \\dots ]$。",
            "solution": "问题陈述已经过严格审查，并被确定为有效。它在图论方面具有科学依据，问题设定良好，具有确定性的移除策略，并且表述客观。因此，我们可以着手进行形式化的求解。\n\n该问题要求我们在给定图上模拟一个顺序节点移除过程。在每一步，当前度中心性最高的节点被移除。平局通过选择索引最小的节点来解决。在此过程中，我们必须跟踪四个关键指标：被移除节点的序列、每次移除后最大连通分量（LCC）的大小、一个累积反馈度量 $F$ 以及一个指示图是否曾变得不连通的布尔标志。\n\n设图为 $G = (V, E)$，由邻接矩阵 $A$ 表示。初始节点集为 $V_0 = \\{0, 1, \\dots, n-1\\}$，其中 $n$ 是节点数。该过程在 $n$ 个离散步骤中展开，索引为 $t=1, 2, \\dots, n$。\n\n设 $V_{t-1}$ 是在步骤 $t$ 之前图中存在的节点集合。此时，节点 $i \\in V_{t-1}$ 的度由 $k_i(V_{t-1}) = \\sum_{j \\in V_{t-1}} A_{ij}$ 给出。\n\n对于从 $1$ 到 $n$ 的每个步骤 $t$，算法按以下方式进行：\n\n1.  **节点选择**：我们确定要移除的节点 $r_t$。这是当前集合 $V_{t-1}$ 中满足最大度准则并遵循平局打破规则的节点：\n    $$r_t = \\min \\{ i \\in V_{t-1} \\mid k_i(V_{t-1}) = \\max_{j \\in V_{t-1}} k_j(V_{t-1}) \\}$$\n    移除序列是有序列表 $[r_1, r_2, \\dots, r_n]$。\n\n2.  **累积反馈度量（$F$）计算**：问题基于度变化的平方和定义了一个度量 $F$。让我们分析这个定义。图的状态从拥有节点集 $V_{t-1}$ 转变为 $V_t = V_{t-1} \\setminus \\{r_t\\}$。任何剩余节点 $j \\in V_t$ 的度从 $k_j(V_{t-1})$ 变为 $k_j(V_t)$。\n    在步骤 $t$，节点 $j$ 的度变化为：\n    $$\\Delta k_j^{(t)} = k_j(V_t) - k_j(V_{t-1})$$\n    根据度的定义，我们有：\n    $$k_j(V_{t-1}) = \\sum_{l \\in V_{t-1}} A_{jl} = \\sum_{l \\in V_t \\cup \\{r_t\\}} A_{jl} = \\left( \\sum_{l \\in V_t} A_{jl} \\right) + A_{j,r_t} = k_j(V_t) + A_{j,r_t}$$\n    因此，度变化简化为：\n    $$\\Delta k_j^{(t)} = -A_{j,r_t}$$\n    由于邻接矩阵 $A$ 是二元的，$\\Delta k_j^{(t)}$ 的值要么是 $-1$（如果节点 $j$ 与被移除的节点 $r_t$ 相连），要么是 $0$（否则）。\n\n    问题使用略有不同的索引约定来定义 $F$，我们遵循该约定。它被定义为 $F = \\sum_{t=1}^{T} \\sum_{j \\in V^{(t+1)}} (\\Delta k_j^{(t)})^2$，其中 $V^{(t)}$ 表示第 $t$ 次移除前的节点集。这对应于我们的 $V_{t-1}$。因此，$V^{(t+1)}$ 对应于我们的 $V_t$。\n    代入我们推导出的度变化表达式：\n    $$F = \\sum_{t=1}^{n} \\sum_{j \\in V_t} (-A_{j,r_t})^2 = \\sum_{t=1}^{n} \\sum_{j \\in V_t} (A_{j,r_t})^2$$\n    由于 $A_{ij} \\in \\{0,1\\}$，我们有 $A_{ij}^2 = A_{ij}$。\n    $$F = \\sum_{t=1}^{n} \\sum_{j \\in V_t} A_{j,r_t}$$\n    内层求和 $\\sum_{j \\in V_t} A_{j,r_t}$ 计算了被移除节点 $r_t$ 在其移除*之后*剩余的节点中的邻居数量。这恰好是 $r_t$ 在其被移除瞬间在图中的度，即 $k_{r_t}(V_{t-1})$。\n    $$k_{r_t}(V_{t-1}) = \\sum_{j \\in V_{t-1}, j \\neq r_t} A_{r_t,j} = \\sum_{j \\in V_t} A_{j,r_t}$$\n    因此，度量 $F$ 简化为节点在被移除时度的总和：\n    $$F = \\sum_{t=1}^{n} k_{r_t}(V_{t-1})$$\n    这就是我们将要计算的量。\n\n3.  **连通性分析**：每次移除 $r_t$ 后，我们剩下节点集 $V_t$ 上的诱导子图。我们必须确定连通分量的数量和最大连通分量（LCC）的大小。这可以通过图遍历算法（如广度优先搜索（BFS）或深度优先搜索（DFS））来完成。我们遍历 $V_t$ 中的所有节点。如果一个节点尚未被访问，我们从它开始进行遍历，计算所有可达节点以找到其分量的大小，并将它们标记为已访问。我们跟踪找到的最大分量大小。空图（在最后一次移除后）的 LCC 大小为 $0$。LCC 大小列表将有 $n$ 个元素，对应于 $n$ 次移除后每次的图状态。\n\n4.  **不连通标志**：如果一个图有一个以上的连通分量，则它是不连通的。这仅对至少有两个节点的图有意义。我们初始化一个布尔标志 `is_disconnected` 为 `False`。在每个步骤 $t \\in \\{1, \\dots, n-1\\}$，移除 $r_t$ 后，我们检查剩余图 $V_t$ 上的连通分量数是否大于 $1$。如果是，我们将该标志设置为 `True`。报告此标志的最终值。\n\n对于给定的邻接矩阵 $A$ 的整体算法是：\n1. 初始化一个活动节点集 $V_{active}$ 为 $\\{0, \\dots, n-1\\}$。初始化移除序列、LCC 大小列表、$F$ 和不连通标志。\n2. 对于 $t=1$ 到 $n$：\n    a. 计算 $V_{active}$ 诱导的子图中所有 $i \\in V_{active}$ 的度。\n    b. 选择度最大（若平局则索引最小）的节点 $r_t$。\n    c. 将 $r_t$ 的计算度数加到 $F$ 上。\n    d. 将 $r_t$ 附加到移除序列中。\n    e. 从 $V_{active}$ 中移除 $r_t$。\n    f. 在新的 $V_{active}$ 诱导的子图上进行连通性分析（例如，使用 BFS）。\n    g. 将得到的 LCC 大小附加到 LCC 大小列表中。\n    h. 如果分量数大于 $1$，则将不连通标志设置为 `True`。\n3. 返回这四个计算出的指标，作为一个列表。\n此过程将应用于每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the node removal simulation on all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        np.array([\n            [0, 1, 1, 0, 0, 0],\n            [1, 0, 1, 1, 0, 0],\n            [1, 1, 0, 1, 0, 0],\n            [0, 1, 1, 0, 1, 0],\n            [0, 0, 0, 1, 0, 1],\n            [0, 0, 0, 0, 1, 0]\n        ]),\n        # Test case 2\n        np.array([\n            [0, 1, 1, 1, 1],\n            [1, 0, 1, 1, 1],\n            [1, 1, 0, 1, 1],\n            [1, 1, 1, 0, 1],\n            [1, 1, 1, 1, 0]\n        ]),\n        # Test case 3\n        np.array([\n            [0, 1, 1, 1, 1, 1],\n            [1, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0],\n            [1, 0, 0, 0, 0, 0]\n        ]),\n        # Test case 4\n        np.array([\n            [0, 1, 1, 0, 0, 0],\n            [1, 0, 1, 0, 0, 0],\n            [1, 1, 0, 0, 0, 0],\n            [0, 0, 0, 0, 1, 1],\n            [0, 0, 0, 1, 0, 1],\n            [0, 0, 0, 1, 1, 0]\n        ]),\n        # Test case 5\n        np.array([\n            [0]\n        ])\n    ]\n\n    results = []\n    for A in test_cases:\n        result = process_graph(A)\n        results.append(result)\n\n    # Convert results to string representation for the final output format.\n    # The default str() for lists creates the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_graph(A):\n    \"\"\"\n    Applies the sequential removal strategy to a single graph.\n    \n    Args:\n        A (np.ndarray): The adjacency matrix of the graph.\n\n    Returns:\n        list: A list containing [removal_sequence, lcc_sizes, F, was_disconnected].\n    \"\"\"\n    n = A.shape[0]\n    if n == 0:\n        return [[], [0], 0, False]\n\n    active_nodes = list(range(n))\n    adj = A.copy()\n\n    removal_sequence = []\n    lcc_sizes = []\n    F = 0\n    was_disconnected = False\n\n    for _ in range(n):\n        if not active_nodes:\n            # This branch should not be hit in a standard n-step loop\n            # But is good practice for robustness.\n            break\n\n        # Step 1: Compute degrees and find node to remove\n        degrees = {node: 0 for node in active_nodes}\n        for i in active_nodes:\n            degree = 0\n            for j in active_nodes:\n                if adj[i, j] == 1:\n                    degree += 1\n            degrees[i] = degree\n\n        max_deg = -1\n        node_to_remove = -1\n\n        # Iterate through sorted active nodes to handle tie-breaking\n        # (smallest index for same max degree)\n        for node in sorted(degrees.keys()):\n            if degrees[node] > max_deg:\n                max_deg = degrees[node]\n                node_to_remove = node\n\n        # Step 2: Update metrics based on the removal\n        removal_sequence.append(node_to_remove)\n        F += max_deg\n        active_nodes.remove(node_to_remove)\n\n        # Step 3: Analyze connectivity of the remaining graph\n        lcc_size, num_components = analyze_connectivity(adj, active_nodes)\n        lcc_sizes.append(lcc_size)\n        if num_components > 1:\n            was_disconnected = True\n\n    return [removal_sequence, lcc_sizes, F, was_disconnected]\n\ndef analyze_connectivity(adj, nodes):\n    \"\"\"\n    Finds the number of connected components and the size of the largest one.\n\n    Args:\n        adj (np.ndarray): The full adjacency matrix.\n        nodes (list): The list of currently active nodes.\n\n    Returns:\n        tuple: (largest_component_size, number_of_components)\n    \"\"\"\n    if not nodes:\n        return 0, 0\n\n    visited = set()\n    num_components = 0\n    max_size = 0\n    \n    # Create a set from the list for efficient 'in' checks\n    node_set = set(nodes)\n\n    for start_node in nodes:\n        if start_node not in visited:\n            num_components += 1\n            component_size = 0\n            q = [start_node]  # Queue for BFS\n            visited.add(start_node)\n            \n            while q:\n                u = q.pop(0)\n                component_size += 1\n                \n                # Check neighbors\n                for v_idx, is_neighbor in enumerate(adj[u]):\n                    if is_neighbor and v_idx in node_set and v_idx not in visited:\n                        visited.add(v_idx)\n                        q.append(v_idx)\n            \n            if component_size > max_size:\n                max_size = component_size\n                \n    return max_size, num_components\n\nsolve()\n```"
        }
    ]
}