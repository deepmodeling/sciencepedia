{
    "hands_on_practices": [
        {
            "introduction": "虽然大多数非线性系统无法求得解析解，但某些特殊参数下的情况却可以精确求解。这个练习将指导你通过一个巧妙的变量代换，求出逻辑斯蒂映射在参数 $r=2$ 时的精确解 。通过这个过程，你不仅能清晰地看到系统如何收敛到一个不动点，还能掌握变换和求解非线性递推关系的基本技巧，为理解更复杂的动力学行为打下坚实的基础。",
            "id": "4310178",
            "problem": "考虑单位区间上的离散时间逻辑斯谛映射，由递推关系 $x_{n+1} = r\\,x_n\\,(1 - x_n)$ 定义，其中 $n \\in \\mathbb{N}$，参数 $r \\in \\mathbb{R}$。重点研究 $r = 2$ 的情况。从迭代映射和不动点的核心定义出发：对于映射 $f(x) = r\\,x\\,(1 - x)$，不动点 $x^{\\ast}$ 满足 $x^{\\ast} = f(x^{\\ast})$，且不动点的稳定性可以通过局域线性化来评估，其中 $|f'(x^{\\ast})|  1$ 意味着局域吸引。\n\n你的任务是：\n1. 对于递推关系 $x_{n+1} = 2\\,x_n\\,(1 - x_n)$，从第一性原理出发，不借助任何预先给定的解形式，推导出一个关于 $x_0$ 和 $n$ 的 $x_n$ 的闭式解析表达式。\n2. 使用你得到的表达式，验证当 $x_0 \\in [0,1]$ 时 $x_n$ 的收敛性质，包括确定吸引不动点和任何例外的初始条件。\n\n请提供所有必要的步骤和基于所述定义与事实的论证。你的最终答案必须是 $x_n$ 作为 $n$ 和 $x_0$ 的函数的单个闭式解析表达式。不需要数值取整，也不涉及物理单位。",
            "solution": "该问题要求推导参数 $r=2$ 的逻辑斯谛映射的闭式解，并基于该解分析其收敛性质。\n\n具体的递推关系由下式给出：\n$$x_{n+1} = 2x_n(1 - x_n)$$\n初始条件 $x_0$ 属于区间 $[0,1]$。\n\n为了找到 $x_n$ 的闭式解，我们寻求一种变换，将这个非线性递推关系简化为线性或更简单的形式。对于二次映射，一种标准技巧是平移变量，将映射的顶点置于原点。函数 $f(x) = 2x(1-x) = 2x - 2x^2$ 是一个抛物线，其顶点位于 $x = -\\frac{2}{2(-2)} = \\frac{1}{2}$。这启发我们进行如下变量代换：\n$$x_n = \\frac{1}{2} - z_n$$\n将此代入递推关系，得到：\n$$\\frac{1}{2} - z_{n+1} = 2\\left(\\frac{1}{2} - z_n\\right)\\left(1 - \\left(\\frac{1}{2} - z_n\\right)\\right)$$\n$$\\frac{1}{2} - z_{n+1} = 2\\left(\\frac{1}{2} - z_n\\right)\\left(\\frac{1}{2} + z_n\\right)$$\n右侧是一个平方差：\n$$\\frac{1}{2} - z_{n+1} = 2\\left(\\left(\\frac{1}{2}\\right)^2 - z_n^2\\right)$$\n$$\\frac{1}{2} - z_{n+1} = 2\\left(\\frac{1}{4} - z_n^2\\right)$$\n$$\\frac{1}{2} - z_{n+1} = \\frac{1}{2} - 2z_n^2$$\n这简化为关于 $z_n$ 的一个更简单的递推关系：\n$$z_{n+1} = 2z_n^2$$\n我们可以通过迭代来解这个新的递推关系。\n对于 $n=1$：$z_1 = 2z_0^2$。\n对于 $n=2$：$z_2 = 2z_1^2 = 2(2z_0^2)^2 = 2(4z_0^4) = 8z_0^4 = 2^3 z_0^{2^2}$。\n对于 $n=3$：$z_3 = 2z_2^2 = 2(2^3 z_0^4)^2 = 2(2^6 z_0^8) = 2^7 z_0^{2^3}$。\n我们观察到一个模式。让我们提出通式 $z_n = \\frac{1}{2}(2z_0)^{2^n}$。\n我们用归纳法来验证。$n=0$ 的基础情形是 $z_0 = \\frac{1}{2}(2z_0)^{2^0} = \\frac{1}{2}(2z_0)^1 = z_0$，这是正确的。\n假设该公式对 $n$ 成立。那么 $z_{n+1} = 2z_n^2 = 2\\left(\\frac{1}{2}(2z_0)^{2^n}\\right)^2 = 2\\left(\\frac{1}{4}\\left((2z_0)^{2^n}\\right)^2\\right) = \\frac{1}{2}(2z_0)^{2^n \\times 2} = \\frac{1}{2}(2z_0)^{2^{n+1}}$。\n根据归纳法，该公式成立。\n\n现在，我们代换回去求 $x_n$ 的表达式。\n首先，用 $x_0$ 表示 $z_0$：$z_0 = \\frac{1}{2} - x_0$。\n然后将 $z_n$ 和 $z_0$ 代换回变换式 $x_n = \\frac{1}{2} - z_n$ 中：\n$$x_n = \\frac{1}{2} - \\frac{1}{2}(2z_0)^{2^n}$$\n$$x_n = \\frac{1}{2}\\left(1 - (2z_0)^{2^n}\\right)$$\n$$x_n = \\frac{1}{2}\\left(1 - \\left(2\\left(\\frac{1}{2} - x_0\\right)\\right)^{2^n}\\right)$$\n$$x_n = \\frac{1}{2}\\left(1 - (1 - 2x_0)^{2^n}\\right)$$\n这就是 $x_n$ 关于 $x_0$ 和 $n$ 的闭式解析表达式。\n\n接下来，我们使用这个表达式来分析当 $x_0 \\in [0,1]$ 时的收敛性质。\n当 $n \\to \\infty$ 时，序列 $\\{x_n\\}$ 的长期行为取决于项 $(1 - 2x_0)^{2^n}$。令 $c = 1 - 2x_0$。\n由于 $x_0 \\in [0,1]$，我们有：\n$0 \\le x_0 \\le 1$\n$0 \\ge -2x_0 \\ge -2$\n$1 \\ge 1 - 2x_0 \\ge -1$\n所以，底数 $c$ 位于区间 $[-1, 1]$ 内。我们根据 $c$ 的值来分析极限。\n\n情况 1: $|c|  1$。\n这对应于 $-1  1 - 2x_0  1$。\n不等式 $1 - 2x_0  1$ 意味着 $-2x_0  0$，所以 $x_0  0$。\n不等式 $-1  1 - 2x_0$ 意味着 $2x_0  2$，所以 $x_0  1$。\n因此， $|c|  1$ 等价于 $x_0 \\in (0,1)$。\n对于这些初始条件，当 $n \\to \\infty$ 时，指数 $2^n \\to \\infty$。由于 $|c|  1$，我们有 $\\lim_{n\\to\\infty} c^{2^n} = 0$。\n因此，序列的极限是：\n$$\\lim_{n\\to\\infty} x_n = \\lim_{n\\to\\infty} \\frac{1}{2}(1 - (1 - 2x_0)^{2^n}) = \\frac{1}{2}(1 - 0) = \\frac{1}{2}$$\n对于开区间 $(0,1)$ 内的任何初始条件 $x_0$，序列收敛于 $\\frac{1}{2}$。这表明 $x^{\\ast} = \\frac{1}{2}$ 是一个吸引不动点。\n这与给定的稳定性判据一致。$f(x)=2x(1-x)$ 的不动点是方程 $x = 2x(1-x)$ 的解。这给出 $x=0$ 和 $1 = 2(1-x)$，解得 $x=\\frac{1}{2}$。导数是 $f'(x) = 2 - 4x$。在不动点 $x^{\\ast}=\\frac{1}{2}$ 处，导数为 $f'(\\frac{1}{2}) = 2 - 4(\\frac{1}{2}) = 0$。由于 $|f'(\\frac{1}{2})| = 0  1$，该不动点是局域吸引的（特别是，超吸引的）。\n\n情况 2: $|c| = 1$。\n这对应于 $x_0$ 区间的端点。这些是例外的初始条件。\n子情况 2a: $c = 1$。\n$1 - 2x_0 = 1 \\implies -2x_0 = 0 \\implies x_0 = 0$。\n如果 $x_0 = 0$，闭式表达式给出 $x_n = \\frac{1}{2}(1 - 1^{2^n}) = \\frac{1}{2}(1 - 1) = 0$ 对所有 $n$ 成立。序列是 $\\{0, 0, 0, \\dots\\}$。这是不动点 $x^{\\ast}=0$。稳定性分析表明 $|f'(0)| = |2 - 4(0)| = 2  1$，所以这个不动点是排斥的。\n\n子情况 2b: $c = -1$。\n$1 - 2x_0 = -1 \\implies -2x_0 = -2 \\implies x_0 = 1$。\n如果 $x_0 = 1$，闭式表达式给出 $x_n = \\frac{1}{2}(1 - (-1)^{2^n})$。\n对于 $n \\ge 1$，指数 $2^n$ 是一个偶数。因此，对所有 $n \\ge 1$ 都有 $(-1)^{2^n} = 1$。\n这意味着对所有 $n \\ge 1$，$x_n = \\frac{1}{2}(1-1) = 0$。\n从 $x_0=1$ 开始的序列是 $\\{1, 0, 0, 0, \\dots\\}$。系统在一次迭代后演化到排斥不动点 $x^{\\ast}=0$。\n\n总之，推导出的闭式解证实了对于逻辑斯谛映射 $x_{n+1} = 2x_n(1-x_n)$，点 $x^{\\ast}=\\frac{1}{2}$ 是一个吸引不动点，其吸引盆是区间 $(0,1)$。点 $x_0=0$ 和 $x_0=1$ 是导致系统趋向排斥不动点 $x^{\\ast}=0$ 的例外初始条件。",
            "answer": "$$\n\\boxed{\\frac{1}{2}\\left(1 - (1 - 2x_0)^{2^n}\\right)}\n$$"
        },
        {
            "introduction": "倍周期分岔是通往混沌的经典路径，其背后蕴藏着深刻的普适性规律。尽管不同映射的分岔点各不相同，但它们汇聚到混沌边缘的速率却由一个普适常数——费根鲍姆常数 $\\delta$ ——所决定 。本计算练习将引导你通过数值方法，定位超稳定周期轨道的参数值，并利用这些值来估算这个动力学系统中的基本常数，亲身体验从具体系统到普适理论的跨越。",
            "id": "4310123",
            "problem": "考虑由函数 $f_r:[0,1]\\to[0,1]$ 定义的一维离散时间逻辑斯谛映射，其表达式为 $f_r(x)=r\\,x\\,(1-x)$，其中参数 $r\\in[0,4]$。当 $r$ 接近混沌起始点时，逻辑斯谛映射展现出吸引环的周期倍增序列和参数空间中的一个累积点，这可以通过超稳定环进行探测。一个超稳定周期-$2^n$ 环的特征是环中包含了临界点 $x=\\tfrac{1}{2}$。这样的参数 $r=r_n^{\\mathrm{ss}}$ 满足条件 $f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$，其中 $f_r^{k}$ 表示 $f_r$ 与自身的 $k$ 次复合。\n\n仅使用映射迭代和连续性的基本定义，以及基于这些原理的数值求根方法，编写一个完整的、可运行的程序，该程序：\n\n1. 实现对任意整数 $k\\geq 1$ 和实数 $x\\in[0,1]$ 的复合 $f_r^{k}(x)$。\n2. 对于指定测试集中的每个整数 $n$，求解 $r_n^{\\mathrm{ss}}$，其为满足 $f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$ 的、大于 $r_{n-1}^{\\mathrm{ss}}$（其中 $r_0^{\\mathrm{ss}}$ 由方程 $f_r\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$ 定义）的最小参数 $r$。必须通过在 $g_n$ 变号的 $r$ 区间内寻找连续函数 $g_n(r)=f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)-\\tfrac{1}{2}$ 的根来获得解。\n3. 对测试集中所有表达式有明确定义的情况，计算由连续区间比率定义的 Feigenbaum 标度估计 $\\delta_n$\n$$\n\\delta_n=\\frac{r_{n-1}^{\\mathrm{ss}}-r_{n-2}^{\\mathrm{ss}}}{r_n^{\\mathrm{ss}}-r_{n-1}^{\\mathrm{ss}}}\n$$\n已知这些比率会趋近于与周期倍增通往混沌之路相关的 Feigenbaum 常数 $\\delta$。\n\n你的算法必须从核心定义和事实出发：逻辑斯谛映射 $f_r(x)=r\\,x\\,(1-x)$、复合 $f_r^{k}$、固定迭代深度下对 $r$ 的连续性，以及用于证明基于区间套的求根过程合理性的介值定理。除这些基本原理外，避免使用任何非推导的快捷公式。\n\n测试集：\n- 计算 $n\\in\\{0,1,2,3,4,5\\}$ 的 $r_n^{\\mathrm{ss}}$，约定 $r_0^{\\mathrm{ss}}$ 解方程 $f_r\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$。\n- 根据上述定义，计算 $n\\in\\{2,3,4,5\\}$ 的 $\\delta_n$。\n\n输出规范：\n- 你的程序应生成单行输出，包含一个逗号分隔的列表，用方括号括起，顺序为 $[r_0^{\\mathrm{ss}},r_1^{\\mathrm{ss}},r_2^{\\mathrm{ss}},r_3^{\\mathrm{ss}},r_4^{\\mathrm{ss}},r_5^{\\mathrm{ss}},\\delta_2,\\delta_3,\\delta_4,\\delta_5]$。\n- 每个数值条目必须表示为实数（无单位），并四舍五入到 $12$ 位小数。\n- 不得打印任何其他文本或格式。\n\n科学真实性要求：\n- 使用区间套法和二分法（或等效的连续区间套方法）来定位每个根 $r_n^{\\mathrm{ss}}$，使其为在科学合理的上限（例如，$r\\leq 3.58$）内，大于 $r_{n-1}^{\\mathrm{ss}}$ 的最小解，该上限对应于主周期倍增级联。\n- 确保所有计算都使用基于给定定义的确定性数值程序进行。",
            "solution": "用户请求了一个关于逻辑斯谛映射和 Feigenbaum 常数的计算问题的解决方案。该问题陈述已经过验证，被认为是具有科学依据、提法恰当且客观的。它代表了计算物理和混沌系统研究中的一个标准练习。解决方案的步骤如下。\n\n### **问题验证**\n\n**第 1 步：提取的已知条件**\n-   **逻辑斯谛映射：** $f_r:[0,1]\\to[0,1]$，由 $f_r(x)=r\\,x\\,(1-x)$ 定义，参数 $r\\in[0,4]$。\n-   **映射复合：** $f_r^k$ 是 $f_r$ 与自身的 $k$ 次复合。\n-   **超稳定环条件：** 当参数 $r=r_n^{\\mathrm{ss}}$ 满足条件 $f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$ 时，存在一个超稳定周期-$2^n$ 环，因为该环必须包含映射的临界点 $x=\\tfrac{1}{2}$。\n-   **任务 1：实现：** 实现复合映射 $f_r^k(x)$。\n-   **任务 2：求根：** 对每个 $n \\in \\{0, 1, 2, 3, 4, 5\\}$，求解 $r_n^{\\mathrm{ss}}$。\n    -   $r_0^{\\mathrm{ss}}$ 由方程 $f_r(\\tfrac{1}{2})=\\tfrac{1}{2}$ 的解定义。\n    -   对于 $n  0$，$r_n^{\\mathrm{ss}}$ 是满足超稳定条件的、大于 $r_{n-1}^{\\mathrm{ss}}$ 的最小参数值 $r$。\n    -   该方法必须是在函数 $g_n(r)=f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)-\\tfrac{1}{2}$ 上使用区间套方法的数值求根，其合理性由介值定理保证。\n-   **任务 3：Feigenbaum Delta 计算：** 对 $n \\in \\{2, 3, 4, 5\\}$，计算标度估计 $\\delta_n=\\frac{r_{n-1}^{\\mathrm{ss}}-r_{n-2}^{\\mathrm{ss}}}{r_n^{\\mathrm{ss}}-r_{n-1}^{\\mathrm{ss}}}$。\n-   **测试集与输出：** 计算 $[r_0^{\\mathrm{ss}}, r_1^{\\mathrm{ss}}, ..., r_5^{\\mathrm{ss}}, \\delta_2, ..., \\delta_5]$，每个值四舍五入到 $12$ 位小数。\n-   **约束：** 仅使用基本定义。根的搜索应限制在一个合理的参数范围内，如 $r \\le 3.58$。\n\n**第 2 步：验证结论**\n该问题有效。它是一个定义明确的数学问题，植根于已建立的动力系统和混沌理论。所有术语都有正式定义，目标清晰，所需的方法论也已指定且恰当。问题是自洽的，没有矛盾或歧义。\n\n### **基于原理的求解设计**\n\n问题的核心是找到特定的参数值 $r_n^{\\mathrm{ss}}$，在这些值下，逻辑斯谛映射表现出周期为 $2^n$ 的超稳定环。通过将数学定义直接转化为数值算法来构建解决方案。\n\n**1. 映射复合函数**\n首先，我们实现函数 $f_r^k(x)$，它表示逻辑斯谛映射 $f_r(x) = r\\,x\\,(1-x)$ 的第 $k$ 次迭代。这通过一个简单的循环实现，该循环从一个初始值 $x$ 开始，将映射公式应用 $k$ 次。这个我们称之为 `logistic_map_composed(k, r, x)` 的函数是基本构建块。\n\n**2. 超稳定环方程**\n周期为 $2^n$ 的超稳定环的条件是 $f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$。为了使用数值求根器求解 $r$，我们定义一个目标函数 $g_n(r) = f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right) - \\tfrac{1}{2}$。$g_n(r)=0$ 的根对应于所需的参数值 $r_n^{\\mathrm{ss}}$。该函数关于 $r$ 是连续的，这证明了使用像二分法或 Brent 方法这样的区间套求根方法是合理的，因为如果能找到一个区间 $[a, b]$ 使得 $g_n(a)$ 和 $g_n(b)$ 异号（这是介值定理的一个推论），这些方法保证收敛。\n\n**3. 顺序求根**\n问题要求按顺序为 $n=0, 1, \\dots, 5$ 找到参数 $r_n^{\\mathrm{ss}}$。\n\n-   **基本情况 ($n=0$)：** 我们需要解 $f_r(\\tfrac{1}{2}) = \\tfrac{1}{2}$。即 $r(\\tfrac{1}{2})(1-\\tfrac{1}{2}) = \\tfrac{1}{2}$，简化为 $r/4 = \\tfrac{1}{2}$，得到解析解 $r_0^{\\mathrm{ss}} = 2$。为了与方法论保持一致，我们将通过数值方法找到 $g_0(r) = f_r^1(\\tfrac{1}{2}) - \\tfrac{1}{2} = 0$ 的根来求解。一个合适的区间是 $[1, 3]$，因为 $g_0(1) = -0.25$ 且 $g_0(3) = 0.25$。\n\n-   **迭代步骤 ($n  0$)：** 对每个 $n$，我们必须找到 $g_n(r) = 0$ 的大于先前找到的根 $r_{n-1}^{\\mathrm{ss}}$ 的最小根。一个关键的观察是，如果 $r_{n-1}^{\\mathrm{ss}}$ 产生一个周期为 $2^{n-1}$ 的超稳定环，那么 $f_{r_{n-1}^{\\mathrm{ss}}}^{2^{n-1}}(\\tfrac{1}{2}) = \\tfrac{1}{2}$。由此可知 $f_{r_{n-1}^{\\mathrm{ss}}}^{2^n}(\\tfrac{1}{2}) = f_{r_{n-1}^{\\mathrm{ss}}}^{2^{n-1}}(f_{r_{n-1}^{\\mathrm{ss}}}^{2^{n-1}}(\\tfrac{1}{2})) = f_{r_{n-1}^{\\mathrm{ss}}}^{2^{n-1}}(\\tfrac{1}{2}) = \\tfrac{1}{2}$，这意味着 $g_n(r_{n-1}^{\\mathrm{ss}}) = 0$。因此，$r_{n-1}^{\\mathrm{ss}}$ 也是 $g_n(r)=0$ 的一个根。我们的任务是找到*下一个*根。\n\n    为此，我们建立一个从略高于 $r_{n-1}^{\\mathrm{ss}}$ 的地方开始的搜索区间。设搜索下界为 $a = r_{n-1}^{\\mathrm{ss}} + \\epsilon$，其中 $\\epsilon  0$ 是一个非常小的数。然后我们对 $r  a$ 的点进行采样，以一个小的步长递增，直到找到一个值 $b$ 使得 $\\mathrm{sign}(g_n(a)) \\neq \\mathrm{sign}(g_n(b))$。这个区间 $[a, b]$ 就成为根 $r_n^{\\mathrm{ss}}$ 的有效区间套。此搜索的步长必须小于预期的距离 $r_n^{\\mathrm{ss}} - r_{n-1}^{\\mathrm{ss}}$，以确保我们不会跳过所要的根。由于这个距离是几何级数递减的，因此选择一个足够小的步长（例如 $10^{-6}$）。一旦找到区间套，就使用像 Brent 方法 (`scipy.optimize.brentq`) 这样的鲁棒算法来高精度地找到根。\n\n**4. Feigenbaum Delta 计算**\n在计算出序列 $[r_0^{\\mathrm{ss}}, \\dots, r_5^{\\mathrm{ss}}]$ 后，对 $n \\in \\{2, 3, 4, 5\\}$ 的 Feigenbaum 比率估计值 $\\delta_n$ 直接根据它们的定义计算：$\\delta_n = (r_{n-1}^{\\mathrm{ss}} - r_{n-2}^{\\mathrm{ss}}) / (r_n^{\\mathrm{ss}} - r_{n-1}^{\\mathrm{ss}})$。已知这些值会收敛到普适 Feigenbaum 常数 $\\delta \\approx 4.669201...$。\n\n**5. 实现**\n该算法使用 Python 实现，借助 `numpy` 库以保证数值稳定性，并使用 `scipy.optimize.brentq` 函数进行高效准确的求根。所有计算均使用标准的双精度浮点算术（`float64`），这对于在这些迭代层级上达到所需精度是足够的。最终结果被收集并按要求格式化到 $12$ 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Computes the superstable cycle parameters r_n and Feigenbaum delta estimates\n    for the logistic map, based on fundamental definitions and numerical root-finding.\n    \"\"\"\n    \n    def logistic_map_composed(k: int, r: float, x: float) - float:\n        \"\"\"\n        Computes the k-th composition of the logistic map f_r(x).\n        \n        Args:\n            k: The number of compositions (integer = 1).\n            r: The logistic map parameter.\n            x: The initial value.\n            \n        Returns:\n            The value of f_r^k(x).\n        \"\"\"\n        val = x\n        for _ in range(k):\n            val = r * val * (1.0 - val)\n        return val\n\n    def g_n_func(r: float, n: int) - float:\n        \"\"\"\n        The objective function g_n(r) = f_r^(2^n)(1/2) - 1/2.\n        The roots of this function are the superstable cycle parameters.\n        \n        Args:\n            r: The logistic map parameter.\n            n: The period-doubling level.\n            \n        Returns:\n            The value of g_n(r).\n        \"\"\"\n        k = 2**n\n        x0 = 0.5\n        return logistic_map_composed(k, r, x0) - x0\n\n    r_ss = []\n    \n    # n=0: Find r_0^ss\n    # The condition is f_r(1/2) = 1/2, which analytically gives r=2.\n    # We solve numerically using brentq for methodological consistency.\n    # A bracket is [1.0, 3.0] since g_0(1)=-0.25 and g_0(3)=0.25.\n    try:\n        r0 = brentq(g_n_func, 1.0, 3.0, args=(0,))\n        r_ss.append(r0)\n    except ValueError:\n        # This fallback should not be needed for this well-behaved case.\n        r_ss.append(2.0)\n\n    # Sequentially find r_n^ss for n = 1, 2, 3, 4, 5\n    max_r = 3.58  # Scientific realism constraint from problem statement.\n    num_n = 5\n\n    for n in range(1, num_n + 1):\n        r_prev = r_ss[n-1]\n        \n        # We search for the smallest root r  r_prev. We know that r_prev is also a\n        # root of g_n(r), so we must start our search for a bracketing interval\n        # just above r_prev.\n        \n        # Start search slightly above the previous root.\n        bracket_a = r_prev + 1e-9\n        sign_a = np.sign(g_n_func(bracket_a, n))\n\n        # Handle unlikely case where start point is a root.\n        if sign_a == 0:\n            bracket_a += 1e-9 \n            sign_a = np.sign(g_n_func(bracket_a, n))\n\n        # The search step for the bracket's other end must be small enough to\n        # not miss the first root. The distance between roots shrinks by ~4.669 each time.\n        # r_5 - r_4 is on the order of 10^-3, so 10^-6 is a safe step size.\n        search_step = 1e-6\n        bracket_b = bracket_a\n        \n        found_bracket = False\n        while bracket_b = max_r:\n            bracket_b += search_step\n            if np.sign(g_n_func(bracket_b, n)) != sign_a:\n                found_bracket = True\n                break\n        \n        if not found_bracket:\n            raise RuntimeError(f\"Could not find a root-finding bracket for n={n} within r = {max_r}\")\n\n        # Use brentq to find the precise root within the bracket [bracket_a, bracket_b].\n        r_n = brentq(g_n_func, bracket_a, bracket_b, args=(n,))\n        r_ss.append(r_n)\n\n    # Compute the Feigenbaum delta estimates\n    deltas = []\n    for n in range(2, num_n + 1):\n        delta = (r_ss[n-1] - r_ss[n-2]) / (r_ss[n] - r_ss[n-1])\n        deltas.append(delta)\n\n    # Combine results and format for output\n    final_results = r_ss + deltas\n    formatted_results = [f\"{x:.12f}\" for x in final_results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当系统在参数 $r_{\\infty}$ 处进入混沌边缘时，其长期行为被限制在一个复杂的自相似集合上，即分形吸引子。这个练习将超越吸引子上的动力学，转向对其几何结构本身的量化分析 。通过亲手实现盒计数算法，你将能够数值估算出该吸引子的分形维数，从而对支撑混沌系统的奇异几何学获得直观而深刻的理解。",
            "id": "4310136",
            "problem": "您将使用以下数学基础，为一维逻辑斯谛映射在倍周期累积点处的吸引子实现一个盒计数维度的数值估计器：逻辑斯谛映射的定义、吸引子的概念以及盒计数（容量）维度的定义。逻辑斯谛映射由 $x_{n+1} = r x_n (1 - x_n)$ 定义在区间 $[0,1]$ 上，其中 $r$ 是一个实参数，$x_n$ 表示在离散时间 $n$ 的状态。倍周期累积参数是 $r_{\\infty} \\approx 3.569945672$，它是稳定轨道周期加倍的分岔参数序列的极限。在 $r = r_{\\infty}$ 时，长时间动力学被支撑在一个分形吸引子上。\n\n集合 $A \\subset \\mathbb{R}$ 的盒计数（容量）维度 $D_0$ 定义为\n$$\nD_0 = \\lim_{\\varepsilon \\to 0} \\frac{\\log N(\\varepsilon)}{\\log(1/\\varepsilon)},\n$$\n其中 $N(\\varepsilon)$ 是覆盖 $A$ 所需的长度为 $\\varepsilon$ 的最小区间（盒子）数量。在实践中，对于一个采样的有限子集 $S \\subset A$，当将 $[0,1]$ 划分为 $M$ 个宽度为 $\\varepsilon = 1/M$ 的等宽区间时，通过计算被占据的盒子数量来估计 $N(\\varepsilon)$，并可能对多个网格偏移进行平均以减少对齐偏差。\n\n任务要求：\n- 推导并实现一个程序，该程序能够：\n  1. 为逻辑斯谛映射 $x_{n+1} = r x_n (1 - x_n)$ 生成一个数值轨道，需给定初始条件 $x_0 \\in (0,1)$、要丢弃的指定暂态迭代次数以及要保留的样本量。允许使用可选的步幅来稀疏化保留的样本，以减少短期相关性。\n  2. 对于一组尺度 $\\{\\varepsilon_k\\}$，使用每尺度 $M_k = 1/\\varepsilon_k$ 个区间来估计 $N(\\varepsilon)$，通过计算非空区间的数量。为减少边界引起的偏差，在分箱前通过平移数据并对1取模，对 $[0,\\varepsilon_k)$ 内的 $K$ 个均匀间隔的网格偏移上的盒子数进行平均。\n  3. 对所提供尺度范围内的 $\\log N(\\varepsilon_k)$ 与 $\\log(1/\\varepsilon_k)$ 进行普通最小二乘回归，以估计斜率作为盒计数维度 $\\widehat{D}_0$。同时计算回归中斜率的标准误差作为拟合不确定性的度量，但最终输出仅报告 $\\widehat{D}_0$。\n- 通过从上述定义出发证明每一步的合理性，并清晰地指定所有数值参数，确保科学真实性。\n- 不允许使用任何维度的快捷公式；估计器必须从定义中推导。\n\n测试套件：\n您必须在以下三个参数集上运行您的估计器，每个参数集指定为一个元组 $(r, x_0, \\text{sample\\_size}, \\text{discard}, \\text{stride}, \\{M_k\\}, K)$，其中 $M_k$ 是每尺度的盒子数，$K$ 是每尺度的偏移量数：\n1. 情况A（理想情况，在 $r_{\\infty}$ 处有足够采样）：$(r = 3.569945672, x_0 = 0.123456789, \\text{sample\\_size} = 120000, \\text{discard} = 50000, \\text{stride} = 1, \\{M_k\\} = \\{64, 128, 256, 512, 1024\\}, K = 7)$。\n2. 情况B（边缘情况，在 $r_{\\infty}$ 处采样较少以暴露有限样本偏差）：$(r = 3.569945672, x_0 = 0.123456789, \\text{sample\\_size} = 20000, \\text{discard} = 50000, \\text{stride} = 1, \\{M_k\\} = \\{64, 128, 256, 512, 1024\\}, K = 7)$。\n3. 情况C（边界比较，区间上完全混沌的映射）：$(r = 4.0, x_0 = 0.123456789, \\text{sample\\_size} = 120000, \\text{discard} = 1000, \\text{stride} = 1, \\{M_k\\} = \\{64, 128, 256, 512, 1024\\}, K = 7)$。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含一个逗号分隔的列表，内含上述三个测试用例的盒计数维度估计值 $\\widehat{D}_0$，四舍五入到六位小数，并用方括号括起来。例如，输出应类似于 `[0.538000,0.532100,0.999500]`。\n- 不应打印任何其他文本。\n\n注意：\n- 所有计算都是无量纲的；不涉及物理单位。\n- 不使用角度。\n- 不得使用百分比；报告原始小数值。",
            "solution": "我们从逻辑斯谛映射和盒计数维度的定义开始。逻辑斯谛映射由 $x_{n+1} = r x_n (1 - x_n)$ 定义，其中 $x_n \\in [0,1]$ 且 $r \\in [0,4]$。参数 $r_{\\infty}$ 是倍周期分岔序列的极限，标志着通过倍周期路径进入混沌的开端。在 $r = r_{\\infty}$ 时，支撑该动力学的不变集是一个类康托尔分形吸引子。\n\n一个集合 $A \\subset \\mathbb{R}$ 的盒计数（容量）维度，记为 $D_0$，由下式给出\n$$\nD_0 = \\lim_{\\varepsilon \\to 0} \\frac{\\log N(\\varepsilon)}{\\log(1/\\varepsilon)},\n$$\n其中 $N(\\varepsilon)$ 是覆盖 $A$ 所需的长度为 $\\varepsilon$ 的最小区间数量。这是一个基本定义；我们的估计器必须使用有限数据来模拟这个极限。对于一个采样的子集 $S \\subset A$，我们通过在将区间 $[0,1]$ 划分为 $M = 1/\\varepsilon$ 个宽度为 $\\varepsilon = 1/M$ 的等宽区间时，计算被占据的盒子数来近似 $N(\\varepsilon)$。为了减轻盒子对齐相对于集合几何形状所产生的偏差，我们对 $K$ 个偏移量上的占据数进行平均。对于每个偏移量，我们将数据平移一个量 $s \\in [0,\\varepsilon)$，然后对1取模，这样可以有效地平移区间的边界，同时仍然覆盖整个区间。\n\n算法推导：\n1.  轨道生成：对于给定的 $r$、初始条件 $x_0$ 以及用于暂态丢弃和样本量的整数，我们计算迭代 $x_{n+1} = r x_n (1 - x_n)$（对于 $n = 0,1,\\dots$），丢弃前 $\\text{discard}$ 个值以消除暂态，并保留接下来的 $\\text{sample\\_size}$ 个点。一个可选的步幅 $\\text{stride}$ 保留每 $\\text{stride}$ 个点，以减少短期相关性，而不改变吸引子的支撑集。\n\n2.  尺度 $\\varepsilon = 1/M$ 上的盒子占据情况：对于固定的 $M$，我们考虑 $K$ 个偏移量 $s_j = j \\varepsilon / K$（对于 $j=0,1,\\dots,K-1$）。对于每个偏移量 $s_j$，我们通过 $y_i = x_i - s_j$ 变换样本，然后进行环绕处理：如果 $y_i  0$，则用 $y_i + 1$ 替换 $y_i$。此操作将样本映射到 $[0,1]$ 上，同时有效地移动了分箱网格。然后我们将 $[0,1]$ 划分为 $M$ 个箱，并计算非零占据的箱数。最终的盒子数 $N(\\varepsilon)$ 是 $K$ 个偏移量上计数的平均值。\n\n3.  维度估计：设尺度由 $M_k \\in \\{64, 128, 256, 512, 1024\\}$ 给出，因此 $\\varepsilon_k = 1/M_k$。计算 $x_k = \\log(1/\\varepsilon_k) = \\log(M_k)$ 和 $y_k = \\log N(\\varepsilon_k)$。使用普通最小二乘法拟合线性模型 $y_k = \\beta_0 + \\beta_1 x_k + \\varepsilon_k$，其中 $\\beta_1$ 是斜率。估计的斜率 $\\widehat{\\beta}_1$ 即为我们的估计器 $\\widehat{D}_0$。计算斜率的标准误差以评估拟合质量：如果 $\\widehat{y}_k = \\widehat{\\beta}_0 + \\widehat{\\beta}_1 x_k$，残差为 $r_k = y_k - \\widehat{y}_k$，残差方差为 $\\widehat{\\sigma}^2 = \\sum_k r_k^2 / (n - 2)$，斜率的标准误差为 $\\text{SE}(\\widehat{\\beta}_1) = \\sqrt{\\widehat{\\sigma}^2 / \\sum_k (x_k - \\bar{x})^2}$，其中 $n$ 是尺度数量。\n\n基于第一性原理的论证：\n-   该估计器通过在对数-对数尺度上进行线性回归，直接实现了 $D_0$ 的定义，这是检测幂律标度的标准方法。对偏移量进行平均可以减少因分箱网格相对于吸引子空隙的对齐而产生的系统误差。\n-   丢弃暂态是合理的，因为对于泛型 $x_0$ 的初始条件，早期迭代会向不变集收敛；包含它们会因过度表示吸引子以外的区域而使占据计数产生偏差。\n-   包含步幅是为了在不改变几何支撑集的情况下减少有限时间序列中的短期时间相关性，这一点很重要，因为连续的迭代可能会以一种在精细尺度上暂时性地偏置占据计数的方式聚集。\n\n误差来源与缓解措施：\n-   有限样本量：仅有有限数量的点，随着 $\\varepsilon$ 减小，$N(\\varepsilon)$ 会饱和，导致 $\\log N$ 对 $\\log(1/\\varepsilon)$ 的图中出现曲率。更大的样本量和适当的 $M_k$ 范围可以缓解此问题，但会受计算预算的限制。\n-   尺度选择：如果 $M_k$ 值太小（粗糙的箱），几何结构的分辨率不足；如果太大（精细的箱），占据情况会受到有限样本和数值精度的限制。一个能提供明显线性区域的中等范围的 $M_k$ 是理想的。\n-   网格对齐偏差：固定的网格可能交替地高估或低估空隙集；在 $[0,\\varepsilon)$ 范围内的多个偏移量上进行平均可以减少这种偏差。\n-   $r_{\\infty}$ 处的参数不确定性：使用 $r_{\\infty}$ 的有限精度近似会引入微小偏差；这可以通过长暂态和采样来缓解，尽管在严格的 $r_{\\infty}$ 处的豪斯多夫维度只是被近似。\n-   数值精度和舍入误差：迭代 $x_{n+1} = r x_n (1 - x_n)$ 会累积浮点误差；然而，对于指定的样本量，双精度通常是足够的。\n-   时间相关性：如果不进行稀疏化，相邻的迭代点可能会聚集在箱内；步幅以减少点数为代价来降低序列相关性。\n\n测试用例：\n-   情况A针对 $r = r_{\\infty}$，具有足够的采样以获得合理的标度窗口，目标是得到小于1的维度。\n-   情况B使用较少的样本来暴露有限样本偏差和较大的标准误差。\n-   情况C使用 $r = 4.0$，此时吸引子是整个区间 $[0,1]$，其维度为1；估计器应返回一个接近1的值。\n\n输出规格：\n-   程序应打印单行，其中包含情况A、B和C的三个估计值 $\\widehat{D}_0$，按此顺序排列，四舍五入到六位小数，并用方括号括起来，用逗号分隔，不含空格，例如 `[0.538000,0.532100,0.999500]`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef logistic_orbit(r: float, x0: float, sample_size: int, discard: int, stride: int) - np.ndarray:\n    \"\"\"\n    Generate a logistic map orbit: x_{n+1} = r x_n (1 - x_n), discarding transients and retaining samples.\n    Parameters:\n        r: logistic map parameter.\n        x0: initial condition in (0,1).\n        sample_size: number of points to retain.\n        discard: number of transient iterations to discard.\n        stride: keep every `stride`-th point after transient.\n    Returns:\n        points: numpy array of retained points of length `sample_size`.\n    \"\"\"\n    total_iters = discard + sample_size * stride\n    x = x0\n    retained = np.empty(sample_size, dtype=np.float64)\n    idx = 0\n    for n in range(total_iters):\n        x = r * x * (1.0 - x)\n        if n = discard:\n            if (n - discard) % stride == 0:\n                retained[idx] = x\n                idx += 1\n                if idx = sample_size:\n                    break\n    return retained\n\ndef average_box_count(points: np.ndarray, M: int, offsets: int) - float:\n    \"\"\"\n    Compute average number of occupied boxes over multiple offsets for given scale M (number of bins).\n    Parameters:\n        points: sample points in [0,1].\n        M: number of bins (boxes), epsilon = 1/M.\n        offsets: number of offsets to average over.\n    Returns:\n        avg_count: average occupied box count across offsets.\n    \"\"\"\n    eps = 1.0 / M\n    counts = []\n    # Evenly spaced offsets in [0, eps)\n    for j in range(offsets):\n        s = (j / offsets) * eps\n        shifted = points - s\n        # Wrap modulo 1 without using slow Python mod\n        shifted_copy = shifted.copy()\n        mask = shifted_copy  0.0\n        if np.any(mask):\n            shifted_copy[mask] += 1.0\n        hist = np.histogram(shifted_copy, bins=M, range=(0.0, 1.0))[0]\n        count = np.count_nonzero(hist)\n        counts.append(count)\n    return float(np.mean(counts))\n\ndef estimate_box_dimension(points: np.ndarray, Ms: np.ndarray, offsets: int) - float:\n    \"\"\"\n    Estimate box-counting dimension from points using scales Ms and averaging over offsets.\n    Parameters:\n        points: sample points.\n        Ms: array of numbers of bins (scales).\n        offsets: number of offsets per scale.\n    Returns:\n        dimension_estimate: slope of log N vs log M.\n    \"\"\"\n    Ms = np.asarray(Ms, dtype=np.int64)\n    log_M = np.log(Ms.astype(np.float64))\n    log_N = np.empty_like(log_M)\n    for i, M in enumerate(Ms):\n        N_avg = average_box_count(points, int(M), offsets)\n        # Prevent log(0) by ensuring at least 1 occupied bin (for degenerate cases)\n        N_eff = max(N_avg, 1.0)\n        log_N[i] = np.log(N_eff)\n    # Ordinary least squares for slope and intercept\n    x = log_M\n    y = log_N\n    X = np.vstack([x, np.ones_like(x)]).T\n    beta, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n    slope = float(beta[0])\n    return slope\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (r, x0, sample_size, discard, stride, Ms_list, offsets)\n    test_cases = [\n        (3.569945672, 0.123456789, 120000, 50000, 1, [64, 128, 256, 512, 1024], 7),   # Case A\n        (3.569945672, 0.123456789, 20000, 50000, 1, [64, 128, 256, 512, 1024], 7),    # Case B\n        (4.0,         0.123456789, 120000, 1000,  1, [64, 128, 256, 512, 1024], 7),   # Case C\n    ]\n\n    results = []\n    for r, x0, sample_size, discard, stride, Ms_list, offsets in test_cases:\n        points = logistic_orbit(r, x0, sample_size, discard, stride)\n        d_est = estimate_box_dimension(points, np.array(Ms_list, dtype=np.int64), offsets)\n        results.append(f\"{d_est:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}