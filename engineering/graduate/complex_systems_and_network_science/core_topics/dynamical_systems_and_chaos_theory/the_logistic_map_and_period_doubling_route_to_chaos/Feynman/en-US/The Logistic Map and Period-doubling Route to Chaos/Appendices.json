{
    "hands_on_practices": [
        {
            "introduction": "While the logistic map is renowned for its chaotic behavior, for certain parameter values, its dynamics are surprisingly orderly and can be solved exactly. This exercise challenges you to derive a closed-form solution for the map at $r=2$ through a clever change of variables . Mastering this analytical technique provides a solid foundation for understanding convergence to fixed points and builds intuition before we venture into more complex, non-integrable regimes.",
            "id": "4310178",
            "problem": "Consider the discrete-time logistic map on the unit interval defined by the recurrence $x_{n+1} = r\\,x_n\\,(1 - x_n)$ for $n \\in \\mathbb{N}$ and parameter $r \\in \\mathbb{R}$. Focus on the case $r = 2$. Begin from the core definitions of iterated maps and fixed points: a fixed point $x^{\\ast}$ satisfies $x^{\\ast} = f(x^{\\ast})$ for the map $f(x) = r\\,x\\,(1 - x)$, and stability of a fixed point can be assessed by local linearization, wherein $|f'(x^{\\ast})|  1$ implies local attraction.\n\nYour tasks are:\n1. Derive, from first principles and without invoking pre-stated solution forms, a closed-form analytic expression for $x_n$ in terms of $x_0$ and $n$ for the recurrence $x_{n+1} = 2\\,x_n\\,(1 - x_n)$.\n2. Use the expression you obtain to verify convergence properties of $x_n$ for $x_0 \\in [0,1]$, including identification of the attracting fixed point and any exceptional initial conditions.\n\nProvide all necessary steps and justifications rooted in the stated definitions and facts. Your final answer must be a single closed-form analytic expression for $x_n$ as a function of $n$ and $x_0$. No numerical rounding is required, and no physical units are involved.",
            "solution": "The problem requires the derivation of a closed-form solution for the logistic map with parameter $r=2$, and an analysis of its convergence properties based on that solution.\n\nThe specific recurrence relation is given by:\n$$x_{n+1} = 2x_n(1 - x_n)$$\nwith the initial condition $x_0$ belonging to the interval $[0,1]$.\n\nTo find a closed-form solution for $x_n$, we seek a transformation that simplifies this non-linear recurrence into a linear or simpler form. A standard technique for quadratic maps is to shift the variable to center the map's vertex at the origin. The function $f(x) = 2x(1-x) = 2x - 2x^2$ is a parabola with its vertex at $x = -\\frac{2}{2(-2)} = \\frac{1}{2}$. This motivates the change of variables:\n$$x_n = \\frac{1}{2} - z_n$$\nSubstituting this into the recurrence relation yields:\n$$\\frac{1}{2} - z_{n+1} = 2\\left(\\frac{1}{2} - z_n\\right)\\left(1 - \\left(\\frac{1}{2} - z_n\\right)\\right)$$\n$$\\frac{1}{2} - z_{n+1} = 2\\left(\\frac{1}{2} - z_n\\right)\\left(\\frac{1}{2} + z_n\\right)$$\nThe right-hand side is a difference of squares:\n$$\\frac{1}{2} - z_{n+1} = 2\\left(\\left(\\frac{1}{2}\\right)^2 - z_n^2\\right)$$\n$$\\frac{1}{2} - z_{n+1} = 2\\left(\\frac{1}{4} - z_n^2\\right)$$\n$$\\frac{1}{2} - z_{n+1} = \\frac{1}{2} - 2z_n^2$$\nThis simplifies to a much simpler recurrence for $z_n$:\n$$z_{n+1} = 2z_n^2$$\nWe can solve this new recurrence by iteration.\nFor $n=1$: $z_1 = 2z_0^2$.\nFor $n=2$: $z_2 = 2z_1^2 = 2(2z_0^2)^2 = 2(4z_0^4) = 8z_0^4 = 2^3 z_0^{2^2}$.\nFor $n=3$: $z_3 = 2z_2^2 = 2(2^3 z_0^4)^2 = 2(2^6 z_0^8) = 2^7 z_0^{2^3}$.\nWe observe a pattern. Let's propose the general form $z_n = \\frac{1}{2}(2z_0)^{2^n}$.\nWe verify this by induction. The base case for $n=0$ is $z_0 = \\frac{1}{2}(2z_0)^{2^0} = \\frac{1}{2}(2z_0)^1 = z_0$, which is correct.\nAssume the formula holds for $n$. Then $z_{n+1} = 2z_n^2 = 2\\left(\\frac{1}{2}(2z_0)^{2^n}\\right)^2 = 2\\left(\\frac{1}{4}\\left((2z_0)^{2^n}\\right)^2\\right) = \\frac{1}{2}(2z_0)^{2^n \\times 2} = \\frac{1}{2}(2z_0)^{2^{n+1}}$.\nThe formula holds by induction.\n\nNow, we substitute back to find the expression for $x_n$.\nFirst, express $z_0$ in terms of $x_0$: $z_0 = \\frac{1}{2} - x_0$.\nThen substitute $z_n$ and $z_0$ back into the transformation $x_n = \\frac{1}{2} - z_n$:\n$$x_n = \\frac{1}{2} - \\frac{1}{2}(2z_0)^{2^n}$$\n$$x_n = \\frac{1}{2}\\left(1 - (2z_0)^{2^n}\\right)$$\n$$x_n = \\frac{1}{2}\\left(1 - \\left(2\\left(\\frac{1}{2} - x_0\\right)\\right)^{2^n}\\right)$$\n$$x_n = \\frac{1}{2}\\left(1 - (1 - 2x_0)^{2^n}\\right)$$\nThis is the closed-form analytic expression for $x_n$ in terms of $x_0$ and $n$.\n\nNext, we use this expression to analyze the convergence properties for $x_0 \\in [0,1]$.\nThe long-term behavior of the sequence $\\{x_n\\}$ as $n \\to \\infty$ depends on the term $(1 - 2x_0)^{2^n}$. Let $c = 1 - 2x_0$.\nSince $x_0 \\in [0,1]$, we have:\n$0 \\le x_0 \\le 1$\n$0 \\ge -2x_0 \\ge -2$\n$1 \\ge 1 - 2x_0 \\ge -1$\nSo, the base $c$ is in the interval $[-1, 1]$. We analyze the limit based on the value of $c$.\n\nCase 1: $|c|  1$.\nThis corresponds to $-1  1 - 2x_0  1$.\nThe inequality $1 - 2x_0  1$ implies $-2x_0  0$, so $x_0  0$.\nThe inequality $-1  1 - 2x_0$ implies $2x_0  2$, so $x_0  1$.\nThus, $|c|  1$ is equivalent to $x_0 \\in (0,1)$.\nFor these initial conditions, as $n \\to \\infty$, the exponent $2^n \\to \\infty$. Since $|c|  1$, we have $\\lim_{n\\to\\infty} c^{2^n} = 0$.\nTherefore, the limit of the sequence is:\n$$\\lim_{n\\to\\infty} x_n = \\lim_{n\\to\\infty} \\frac{1}{2}(1 - (1 - 2x_0)^{2^n}) = \\frac{1}{2}(1 - 0) = \\frac{1}{2}$$\nFor any initial condition $x_0$ in the open interval $(0,1)$, the sequence converges to $\\frac{1}{2}$. This identifies $x^{\\ast} = \\frac{1}{2}$ as an attracting fixed point.\nThis is consistent with the stability criterion given. The fixed points of $f(x)=2x(1-x)$ are solutions to $x = 2x(1-x)$. This gives $x=0$ and $1 = 2(1-x)$, which yields $x=\\frac{1}{2}$. The derivative is $f'(x) = 2 - 4x$. At the fixed point $x^{\\ast}=\\frac{1}{2}$, the derivative is $f'(\\frac{1}{2}) = 2 - 4(\\frac{1}{2}) = 0$. Since $|f'(\\frac{1}{2})| = 0  1$, the fixed point is locally attracting (specifically, super-attracting).\n\nCase 2: $|c| = 1$.\nThis corresponds to the endpoints of the interval for $x_0$. These are the exceptional initial conditions.\nSubcase 2a: $c = 1$.\n$1 - 2x_0 = 1 \\implies -2x_0 = 0 \\implies x_0 = 0$.\nIf $x_0 = 0$, the closed-form expression gives $x_n = \\frac{1}{2}(1 - 1^{2^n}) = \\frac{1}{2}(1 - 1) = 0$ for all $n$. The sequence is $\\{0, 0, 0, \\dots\\}$. This is the fixed point $x^{\\ast}=0$. The stability analysis shows $|f'(0)| = |2 - 4(0)| = 2  1$, so this fixed point is repelling.\n\nSubcase 2b: $c = -1$.\n$1 - 2x_0 = -1 \\implies -2x_0 = -2 \\implies x_0 = 1$.\nIf $x_0 = 1$, the closed-form expression gives $x_n = \\frac{1}{2}(1 - (-1)^{2^n})$.\nFor $n \\ge 1$, the exponent $2^n$ is an even integer. Thus, $(-1)^{2^n} = 1$ for all $n \\ge 1$.\nThis means $x_n = \\frac{1}{2}(1-1) = 0$ for all $n \\ge 1$.\nThe sequence starting from $x_0=1$ is $\\{1, 0, 0, 0, \\dots\\}$. The system evolves to the repelling fixed point $x^{\\ast}=0$ in one iteration.\n\nIn summary, the derived closed-form solution confirms that for the logistic map $x_{n+1} = 2x_n(1-x_n)$, the point $x^{\\ast}=\\frac{1}{2}$ is an attracting fixed point whose basin of attraction is the interval $(0,1)$. The points $x_0=0$ and $x_0=1$ are exceptional initial conditions that lead to the repelling fixed point $x^{\\ast}=0$.",
            "answer": "$$\n\\boxed{\\frac{1}{2}\\left(1 - (1 - 2x_0)^{2^n}\\right)}\n$$"
        },
        {
            "introduction": "The stability of a periodic orbit is the key to understanding how a system's behavior changes as a parameter is varied. This practice introduces the multiplier, a powerful tool for quantifying the stability of a cycle, and explores the special case of superstable cycles . By proving that these cycles, which play a pivotal role in the period-doubling cascade, have a multiplier of zero, you will uncover the mathematical signature of maximal stability.",
            "id": "4310152",
            "problem": "Consider the logistic family of one-dimensional maps defined by $f_{r}(x)=r\\,x\\,(1-x)$ with parameter $r \\in [0,4]$. A $k$-cycle is a set of $k$ distinct points $\\{x_{0},x_{1},\\dots,x_{k-1}\\}$ such that $f_{r}(x_{j})=x_{j+1}$ for $j=0,1,\\dots,k-2$ and $f_{r}(x_{k-1})=x_{0}$. The $k$-fold iterate is defined by $f_{r}^{k}=f_{r} \\circ f_{r} \\circ \\cdots \\circ f_{r}$ ($k$ times). The multiplier of the $k$-cycle is defined as the derivative of the $k$-fold iterate evaluated at any point of the cycle, $\\Lambda=\\left(f_{r}^{k}\\right)^{\\prime}(x_{0})$. A cycle is called superstable if it contains the unique critical point $x_{c}=\\frac{1}{2}$ of $f_{r}$. Starting only from these definitions and basic calculus (specifically, the chain rule), derive an explicit expression for $\\Lambda$ in terms of the local derivatives $f_{r}^{\\prime}(x_{j})$ along the cycle and use it to deduce the exact value of $\\Lambda$ for any superstable $k$-cycle of $f_{r}$. Report the final value of $\\Lambda$ as a single exact number with no units.",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It presents a standard problem in the theory of one-dimensional discrete dynamical systems, specifically concerning the logistic map, and all definitions and premises are standard and correct. We can proceed with the derivation.\n\nThe logistic map is defined as $f_r(x) = r x (1-x)$ for a parameter $r \\in [0, 4]$ and state variable $x \\in [0, 1]$.\nA $k$-cycle is a set of $k$ distinct points $\\{x_0, x_1, \\dots, x_{k-1}\\}$ that are periodic with period $k$ under the map $f_r$. This means:\n$$x_1 = f_r(x_0)$$\n$$x_2 = f_r(x_1)$$\n$$\\vdots$$\n$$x_{k-1} = f_r(x_{k-2})$$\n$$x_0 = f_r(x_{k-1})$$\nThese relations can be expressed using the $k$-fold iterate of the map, $f_r^k = f_r \\circ \\dots \\circ f_r$ ($k$ times). For any point $x_j$ in the cycle, we have $f_r^k(x_j) = x_j$.\n\nThe multiplier, $\\Lambda$, of the $k$-cycle is defined as the derivative of the $k$-fold iterate evaluated at any point of the cycle. Let's choose $x_0$:\n$$\\Lambda = (f_r^k)'(x_0)$$\nTo find an explicit expression for $\\Lambda$, we must differentiate $f_r^k(x)$. The function $f_r^k(x)$ is a composition of $f_r$ with itself $k$ times:\n$$f_r^k(x) = f_r(f_r(\\dots f_r(x) \\dots))$$\nWe apply the chain rule for differentiation. Let's start with $k=2$:\n$$(f_r^2)'(x) = (f_r(f_r(x)))' = f_r'(f_r(x)) \\cdot f_r'(x)$$\nFor $k=3$:\n$$(f_r^3)'(x) = (f_r(f_r^2(x)))' = f_r'(f_r^2(x)) \\cdot (f_r^2)'(x) = f_r'(f_r^2(x)) \\cdot f_r'(f_r(x)) \\cdot f_r'(x)$$\nBy induction, the general formula for the derivative of the $k$-fold iterate is:\n$$(f_r^k)'(x) = f_r'(f_r^{k-1}(x)) \\cdot f_r'(f_r^{k-2}(x)) \\cdots f_r'(f_r(x)) \\cdot f_r'(x)$$\nThis can be written as a product:\n$$(f_r^k)'(x) = \\prod_{i=0}^{k-1} f_r'(f_r^i(x))$$\nwhere $f_r^0(x) = x$.\n\nNow, we evaluate this derivative at the point $x_0$ of the $k$-cycle to find the multiplier $\\Lambda$:\n$$\\Lambda = (f_r^k)'(x_0) = \\prod_{i=0}^{k-1} f_r'(f_r^i(x_0))$$\nThe points in the orbit of $x_0$ are $f_r^0(x_0)=x_0$, $f_r^1(x_0)=x_1$, $f_r^2(x_0)=x_2$, up to $f_r^{k-1}(x_0)=x_{k-1}$. Substituting these into the product gives:\n$$\\Lambda = f_r'(x_0) \\cdot f_r'(x_1) \\cdot f_r'(x_2) \\cdots f_r'(x_{k-1})$$\n$$\\Lambda = \\prod_{j=0}^{k-1} f_r'(x_j)$$\nThis is the explicit expression for the multiplier $\\Lambda$ in terms of the local derivatives along the cycle. The value of $\\Lambda$ is the same regardless of which cycle point $x_j$ is used for the evaluation, as the product is over all points of the cycle, and multiplication is commutative.\n\nNext, we must deduce the value of $\\Lambda$ for a superstable cycle. A cycle is defined as superstable if it contains the critical point of the map $f_r(x)$. The critical point, $x_c$, is a point where the derivative of the map is zero.\nFirst, we find the derivative of $f_r(x)$:\n$$f_r'(x) = \\frac{d}{dx} [r x (1-x)] = \\frac{d}{dx} [r x - r x^2] = r - 2rx = r(1-2x)$$\nSetting the derivative to zero to find the critical point(s):\n$$f_r'(x_c) = r(1-2x_c) = 0$$\nFor $r0$, this implies $1-2x_c = 0$, which gives $x_c = \\frac{1}{2}$. This confirms the value given in the problem statement.\n\nFor a superstable $k$-cycle, one of the points in the cycle $\\{x_0, x_1, \\dots, x_{k-1}\\}$ must be the critical point $x_c = \\frac{1}{2}$. Let's say $x_j = x_c = \\frac{1}{2}$ for some index $j \\in \\{0, 1, \\dots, k-1\\}$.\n\nThe multiplier $\\Lambda$ is the product of the derivatives at each point in the cycle:\n$$\\Lambda = \\prod_{i=0}^{k-1} f_r'(x_i) = f_r'(x_0) \\cdot f_r'(x_1) \\cdots f_r'(x_j) \\cdots f_r'(x_{k-1})$$\nSince one point in the cycle is $x_j = \\frac{1}{2}$, one term in this product is $f_r'(x_j) = f_r'(\\frac{1}{2})$. We have already calculated that the derivative at the critical point is zero:\n$$f_r'(\\frac{1}{2}) = r(1-2(\\frac{1}{2})) = r(1-1) = 0$$\nTherefore, the product for $\\Lambda$ contains a factor of $0$:\n$$\\Lambda = f_r'(x_0) \\cdots f_r'(x_{j-1}) \\cdot (0) \\cdot f_r'(x_{j+1}) \\cdots f_r'(x_{k-1})$$\nA product of any finite set of numbers that includes $0$ is equal to $0$. Thus, for any superstable $k$-cycle of the logistic map $f_r(x)$, the multiplier is exactly zero.\n\n$$\\Lambda = 0$$\nThis result is independent of the period $k$ of the superstable cycle and the specific value of the parameter $r$ that gives rise to it.",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "One of the most profound discoveries in chaos theory is universality: quantitative features that are identical across a wide range of different systems. This computational practice guides you through a numerical experiment to witness this phenomenon firsthand . By locating the parameter values of superstable cycles, you will compute an estimate of the Feigenbaum constant $\\delta$, a universal benchmark for the period-doubling route to chaos.",
            "id": "4310123",
            "problem": "Consider the one-dimensional, discrete-time logistic map defined by the function $f_r:[0,1]\\to[0,1]$ given by $f_r(x)=r\\,x\\,(1-x)$ for a parameter $r\\in[0,4]$. For $r$ near the onset of chaos, the logistic map exhibits a period-doubling sequence of attracting cycles and an accumulation point in parameter space, which can be probed via superstable cycles. A superstable period-$2^n$ cycle is characterized by the inclusion of the critical point $x=\\tfrac{1}{2}$ in the cycle. Such parameters $r=r_n^{\\mathrm{ss}}$ satisfy the condition $f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$, where $f_r^{k}$ denotes the $k$-fold composition of $f_r$ with itself.\n\nUsing only the fundamental definitions of map iteration and continuity, and numerical root finding grounded in these principles, write a complete, runnable program that:\n\n1. Implements the composition $f_r^{k}(x)$ for any integer $k\\geq 1$ and real $x\\in[0,1]$.\n2. For each integer $n$ in the specified test suite, solves for $r_n^{\\mathrm{ss}}$ as the smallest parameter $r$ exceeding $r_{n-1}^{\\mathrm{ss}}$ (with $r_0^{\\mathrm{ss}}$ defined by the equation $f_r\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$) such that $f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$ holds. The solution must be obtained by finding a root of the continuous function $g_n(r)=f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)-\\tfrac{1}{2}$ over a bracket in $r$ where $g_n$ changes sign.\n3. Computes the Feigenbaum scaling estimates $\\delta_n$ defined by the successive interval ratio\n$$\n\\delta_n=\\frac{r_{n-1}^{\\mathrm{ss}}-r_{n-2}^{\\mathrm{ss}}}{r_n^{\\mathrm{ss}}-r_{n-1}^{\\mathrm{ss}}}\n$$\nfor all $n$ in the test suite where the expression is well-defined. These ratios are known to approach the Feigenbaum constant $\\delta$ associated with the period-doubling route to chaos.\n\nYour algorithm must start from the core definitions and facts: the logistic map $f_r(x)=r\\,x\\,(1-x)$, composition $f_r^{k}$, continuity in $r$ for fixed iteration depth, and the Intermediate Value Theorem to justify a bracketing-based root-finding procedure. Avoid any use of non-derived shortcut formulas beyond these fundamentals.\n\nTest suite:\n- Compute $r_n^{\\mathrm{ss}}$ for $n\\in\\{0,1,2,3,4,5\\}$, using the convention $r_0^{\\mathrm{ss}}$ solves $f_r\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$.\n- Compute $\\delta_n$ for $n\\in\\{2,3,4,5\\}$ according to the definition above.\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[r_0^{\\mathrm{ss}},r_1^{\\mathrm{ss}},r_2^{\\mathrm{ss}},r_3^{\\mathrm{ss}},r_4^{\\mathrm{ss}},r_5^{\\mathrm{ss}},\\delta_2,\\delta_3,\\delta_4,\\delta_5]$.\n- Each numeric entry must be expressed as a real number (unitless) rounded to $12$ decimal places.\n- No other text or formatting may be printed.\n\nScientific realism requirements:\n- Use bracketing and bisection (or equivalent continuous bracketing methods) to locate each root $r_n^{\\mathrm{ss}}$ as the smallest solution larger than $r_{n-1}^{\\mathrm{ss}}$ within a scientifically reasonable upper bound for the principal period-doubling cascade (for example, $r\\leq 3.58$).\n- Ensure all computations are performed using deterministic numerical procedures based on the definitions given.",
            "solution": "The user has requested a solution to a computational problem concerning the logistic map and the Feigenbaum constant. The problem statement has been validated and found to be scientifically grounded, well-posed, and objective. It represents a standard exercise in computational physics and the study of chaotic systems. The solution proceeds as follows.\n\n### **Problem Validation**\n\n**Step 1: Extracted Givens**\n-   **Logistic Map:** $f_r:[0,1]\\to[0,1]$ defined by $f_r(x)=r\\,x\\,(1-x)$ for a parameter $r\\in[0,4]$.\n-   **Map Composition:** $f_r^k$ is the $k$-fold composition of $f_r$ with itself.\n-   **Superstable Cycle Condition:** A superstable period-$2^n$ cycle exists for a parameter $r=r_n^{\\mathrm{ss}}$ that satisfies the condition $f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$, as the cycle must contain the map's critical point $x=\\tfrac{1}{2}$.\n-   **Task 1: Implementation:** Implement the composed map $f_r^k(x)$.\n-   **Task 2: Root Finding:** For each $n \\in \\{0, 1, 2, 3, 4, 5\\}$, solve for $r_n^{\\mathrm{ss}}$.\n    -   $r_0^{\\mathrm{ss}}$ is defined by the solution to $f_r(\\tfrac{1}{2})=\\tfrac{1}{2}$.\n    -   For $n  0$, $r_n^{\\mathrm{ss}}$ is the smallest parameter value $r  r_{n-1}^{\\mathrm{ss}}$ satisfying the superstable condition.\n    -   The method must be numerical root-finding on the function $g_n(r)=f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)-\\tfrac{1}{2}$ using a bracketing method, justified by the Intermediate Value Theorem.\n-   **Task 3: Feigenbaum Delta Calculation:** Compute the scaling estimates $\\delta_n=\\frac{r_{n-1}^{\\mathrm{ss}}-r_{n-2}^{\\mathrm{ss}}}{r_n^{\\mathrm{ss}}-r_{n-1}^{\\mathrm{ss}}}$ for $n \\in \\{2, 3, 4, 5\\}$.\n-   **Test Suite  Output:** Compute $[r_0^{\\mathrm{ss}}, r_1^{\\mathrm{ss}}, ..., r_5^{\\mathrm{ss}}, \\delta_2, ..., \\delta_5]$, with each value rounded to $12$ decimal places.\n-   **Constraints:** Use only fundamental definitions. The search for roots should be contained within a reasonable parameter range, such as $r \\le 3.58$.\n\n**Step 2: Validation Verdict**\nThe problem is valid. It is a well-defined mathematical problem grounded in the established theory of dynamical systems and chaos. All terms are defined formally, the objectives are clear, and the required methodology is specified and appropriate. The problem is self-contained and free of contradictions or ambiguities.\n\n### **Principle-Based Solution Design**\n\nThe core of the problem is to find specific parameter values $r_n^{\\mathrm{ss}}$ for which the logistic map exhibits superstable cycles of period $2^n$. The solution is constructed by directly translating the mathematical definitions into a numerical algorithm.\n\n**1. Map Composition Function**\nFirst, we implement the function $f_r^k(x)$, representing the $k$-th iteration of the logistic map $f_r(x) = r\\,x\\,(1-x)$. This is achieved by a simple loop that applies the map's formula $k$ times, starting with an initial value $x$. This function, which we will call `logistic_map_composed(k, r, x)`, is the fundamental building block.\n\n**2. Superstable Cycle Equation**\nThe condition for a superstable cycle of period $2^n$ is $f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right)=\\tfrac{1}{2}$. To solve this for $r$ using a numerical root-finder, we define an objective function $g_n(r) = f_r^{2^n}\\!\\left(\\tfrac{1}{2}\\right) - \\tfrac{1}{2}$. The roots of $g_n(r)=0$ correspond to the desired parameter values $r_n^{\\mathrm{ss}}$. This function is continuous with respect to $r$, which justifies the use of bracketing root-finding methods like the bisection method or Brent's method, as these are guaranteed to converge if a bracket $[a, b]$ can be found where $g_n(a)$ and $g_n(b)$ have opposite signs (a consequence of the Intermediate Value Theorem).\n\n**3. Sequential Root Finding**\nThe problem requires finding the parameters $r_n^{\\mathrm{ss}}$ sequentially for $n=0, 1, \\dots, 5$.\n\n-   **Base Case ($n=0$):** We need to solve $f_r(\\tfrac{1}{2}) = \\tfrac{1}{2}$. This is $r(\\tfrac{1}{2})(1-\\tfrac{1}{2}) = \\tfrac{1}{2}$, which simplifies to $r/4 = \\tfrac{1}{2}$, yielding the analytical solution $r_0^{\\mathrm{ss}} = 2$. For consistency with the methodology, we will solve for this root numerically by finding a root of $g_0(r) = f_r^1(\\tfrac{1}{2}) - \\tfrac{1}{2} = 0$. A suitable bracket is $[1, 3]$, as $g_0(1) = -0.25$ and $g_0(3) = 0.25$.\n\n-   **Iterative Step ($n  0$):** For each $n$, we must find the smallest root of $g_n(r) = 0$ that is greater than the previously found root, $r_{n-1}^{\\mathrm{ss}}$. A key observation is that if $r_{n-1}^{\\mathrm{ss}}$ gives a superstable cycle of period $2^{n-1}$, then $f_{r_{n-1}^{\\mathrm{ss}}}^{2^{n-1}}(\\tfrac{1}{2}) = \\tfrac{1}{2}$. It follows that $f_{r_{n-1}^{\\mathrm{ss}}}^{2^n}(\\tfrac{1}{2}) = f_{r_{n-1}^{\\mathrm{ss}}}^{2^{n-1}}(f_{r_{n-1}^{\\mathrm{ss}}}^{2^{n-1}}(\\tfrac{1}{2})) = f_{r_{n-1}^{\\mathrm{ss}}}^{2^{n-1}}(\\tfrac{1}{2}) = \\tfrac{1}{2}$, meaning $g_n(r_{n-1}^{\\mathrm{ss}}) = 0$. Therefore, $r_{n-1}^{\\mathrm{ss}}$ is also a root of $g_n(r)=0$. Our task is to find the *next* root.\n\n    To do this, we establish a search interval starting just above $r_{n-1}^{\\mathrm{ss}}$. Let the lower bound of our search be $a = r_{n-1}^{\\mathrm{ss}} + \\epsilon$ for a very small $\\epsilon  0$. We then sample points $r  a$, incrementing by a small step, until we find a value $b$ such that $\\mathrm{sign}(g_n(a)) \\neq \\mathrm{sign}(g_n(b))$. This interval $[a, b]$ becomes a valid bracket for the root $r_n^{\\mathrm{ss}}$. The step size for this search must be smaller than the expected distance $r_n^{\\mathrm{ss}} - r_{n-1}^{\\mathrm{ss}}$ to ensure we do not skip over the desired root. Since this distance decreases geometrically, a sufficiently small step (e.g., $10^{-6}$) is chosen. Once the bracket is found, a robust algorithm like Brent's method (`scipy.optimize.brentq`) is used to find the root with high precision.\n\n**4. Feigenbaum Delta Calculation**\nAfter computing the sequence $[r_0^{\\mathrm{ss}}, \\dots, r_5^{\\mathrm{ss}}]$, the Feigenbaum ratio estimates $\\delta_n$ for $n \\in \\{2, 3, 4, 5\\}$ are calculated directly from their definition: $\\delta_n = (r_{n-1}^{\\mathrm{ss}} - r_{n-2}^{\\mathrm{ss}}) / (r_n^{\\mathrm{ss}} - r_{n-1}^{\\mathrm{ss}})$. These values are known to converge to the universal Feigenbaum constant $\\delta \\approx 4.669201...$.\n\n**5. Implementation**\nThe algorithm is implemented in Python using the `numpy` library for numerical stability and the `scipy.optimize.brentq` function for efficient and accurate root finding. All computations are performed using standard double-precision floating-point arithmetic (`float64`), which is sufficient for the required precision at these iteration levels. The final results are collected and formatted to $12$ decimal places as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Computes the superstable cycle parameters r_n and Feigenbaum delta estimates\n    for the logistic map, based on fundamental definitions and numerical root-finding.\n    \"\"\"\n    \n    def logistic_map_composed(k: int, r: float, x: float) - float:\n        \"\"\"\n        Computes the k-th composition of the logistic map f_r(x).\n        \n        Args:\n            k: The number of compositions (integer = 1).\n            r: The logistic map parameter.\n            x: The initial value.\n            \n        Returns:\n            The value of f_r^k(x).\n        \"\"\"\n        val = x\n        for _ in range(k):\n            val = r * val * (1.0 - val)\n        return val\n\n    def g_n_func(r: float, n: int) - float:\n        \"\"\"\n        The objective function g_n(r) = f_r^(2^n)(1/2) - 1/2.\n        The roots of this function are the superstable cycle parameters.\n        \n        Args:\n            r: The logistic map parameter.\n            n: The period-doubling level.\n            \n        Returns:\n            The value of g_n(r).\n        \"\"\"\n        k = 2**n\n        x0 = 0.5\n        return logistic_map_composed(k, r, x0) - x0\n\n    r_ss = []\n    \n    # n=0: Find r_0^ss\n    # The condition is f_r(1/2) = 1/2, which analytically gives r=2.\n    # We solve numerically using brentq for methodological consistency.\n    # A bracket is [1.0, 3.0] since g_0(1)=-0.25 and g_0(3)=0.25.\n    try:\n        r0 = brentq(g_n_func, 1.0, 3.0, args=(0,))\n        r_ss.append(r0)\n    except ValueError:\n        # This fallback should not be needed for this well-behaved case.\n        r_ss.append(2.0)\n\n    # Sequentially find r_n^ss for n = 1, 2, 3, 4, 5\n    max_r = 3.58  # Scientific realism constraint from problem statement.\n    num_n = 5\n\n    for n in range(1, num_n + 1):\n        r_prev = r_ss[n-1]\n        \n        # We search for the smallest root r  r_prev. We know that r_prev is also a\n        # root of g_n(r), so we must start our search for a bracketing interval\n        # just above r_prev.\n        \n        # Start search slightly above the previous root.\n        bracket_a = r_prev + 1e-9\n        sign_a = np.sign(g_n_func(bracket_a, n))\n\n        # Handle unlikely case where start point is a root.\n        if sign_a == 0:\n            bracket_a += 1e-9 \n            sign_a = np.sign(g_n_func(bracket_a, n))\n\n        # The search step for the bracket's other end must be small enough to\n        # not miss the first root. The distance between roots shrinks by ~4.669 each time.\n        # r_5 - r_4 is on the order of 10^-3, so 10^-6 is a safe step size.\n        search_step = 1e-6\n        bracket_b = bracket_a\n        \n        found_bracket = False\n        while bracket_b = max_r:\n            bracket_b += search_step\n            if np.sign(g_n_func(bracket_b, n)) != sign_a:\n                found_bracket = True\n                break\n        \n        if not found_bracket:\n            raise RuntimeError(f\"Could not find a root-finding bracket for n={n} within r = {max_r}\")\n\n        # Use brentq to find the precise root within the bracket [bracket_a, bracket_b].\n        r_n = brentq(g_n_func, bracket_a, bracket_b, args=(n,))\n        r_ss.append(r_n)\n\n    # Compute the Feigenbaum delta estimates\n    deltas = []\n    for n in range(2, num_n + 1):\n        delta = (r_ss[n-1] - r_ss[n-2]) / (r_ss[n] - r_ss[n-1])\n        deltas.append(delta)\n\n    # Combine results and format for output\n    final_results = r_ss + deltas\n    formatted_results = [f\"{x:.12f}\" for x in final_results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}