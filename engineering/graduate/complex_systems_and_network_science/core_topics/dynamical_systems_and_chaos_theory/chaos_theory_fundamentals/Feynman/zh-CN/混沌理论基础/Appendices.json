{
    "hands_on_practices": [
        {
            "introduction": "通往混沌的倍周期分岔路径是许多非线性系统共有的一种普遍行为。本练习将通过数值方法，精确地定位逻辑斯蒂映射中的超稳定参数点，并利用这些点来估算普适的费根鲍姆常数 $\\delta$ 。这个实践不仅能锻炼你的数值算法实现能力，还将让你亲手验证混沌理论中的一个标志性普适律。",
            "id": "4267656",
            "problem": "考虑一个一维迭代动力系统，称为逻辑斯谛映射，其定义为 $f_{r}(x) = r x (1 - x)$，其中参数 $r$ 是实数，且 $x \\in [0,1]$。随着 $r$ 的增加，逻辑斯谛映射表现出倍周期级联现象，并在一个有限的参数值处汇集，此时混沌出现。Feigenbaum常数 $\\delta$ 表征了与此倍周期过程相关的连续参数区间长度的几何收敛性。常数 $\\delta$ 定义为当 $n \\to \\infty$ 时，连续差值的极限比值 $\\frac{r_{n} - r_{n-1}}{r_{n+1} - r_{n}}$，其中 $r_{n}$ 表示系统从周期为 $2^{n-1}$ 的稳定轨道分岔到周期为 $2^{n}$ 的稳定轨道时的参数值。在实践中，可以通过识别超稳定参数值 $s_{n}$ 来估计这些 $r_{n}$ 值。在这些 $s_{n}$ 值上，临界点 $x_{c} = \\frac{1}{2}$ 属于周期为 $2^{n}$ 的吸引环。等价地，$s_{n}$ 是方程 $f_{s_{n}}^{(2^{n})}\\!\\left(\\frac{1}{2}\\right) - \\frac{1}{2} = 0$ 的一个根，其中 $f_{r}^{(k)}$ 表示 $k$ 次复合。\n\n从迭代映射的定义、$f_{r}(x)$ 关于 $r$ 和 $x$ 的连续性以及连续函数的介值定理这些基本原理出发，您必须：\n\n- 推导并实现一个稳健的数值方法，通过求解 $F_{n}(r) = f_{r}^{(2^{n})}\\!\\left(\\frac{1}{2}\\right) - \\frac{1}{2} = 0$（其中 $n \\in \\mathbb{N}$）来定位逻辑斯谛映射的超稳定参数 $s_{n}$。从对应于不动点的 $s_{0} = 2$ 开始，并为每个后续的 $n$，搜索满足 $F_{n}(r) = 0$ 的最小 $r > s_{n-1}$。\n- 使用区间限定策略来保证 $F_{n}(r)$ 根区间的存在，然后对该区间应用二分法以高精度计算 $s_{n}$。您必须确保所有步骤都保持数值稳定性。\n- 对指定的 $n$ 值，计算Feigenbaum比率估计值序列 $\\delta_{n} = \\frac{s_{n} - s_{n-1}}{s_{n+1} - s_{n}}$，并分析其收敛行为。\n\n您的程序必须为以下测试套件生成输出，该测试套件旨在评估正确性、稳定性和收敛性：\n\n- 使用您的方法获得的超稳定序列 $\\{s_{n}\\}$，计算 $n \\in \\{1,2,3,4,5,6,7\\}$ 的Feigenbaum比率估计值 $\\delta_{n}$。\n- 另外，计算两个布尔型诊断指标：\n  1. $M_{s}$：$\\{s_{n}\\}$ 序列在计算范围内是否严格递增，即对于所有考虑的连续对，是否 $s_{n+1} > s_{n}$。\n  2. $D_{\\delta}$：对于您计算集合中最后三个可用的连续索引，绝对差 $|\\delta_{n+1} - \\delta_{n}|$ 是否严格递减，这用于探查经验收敛行为。\n\n所有量均为纯数值且无单位。不涉及角度。最终输出必须以单行形式呈现，包含一个用方括号括起来的逗号分隔列表，结构如下：\n$[\\delta_{1},\\delta_{2},\\delta_{3},\\delta_{4},\\delta_{5},\\delta_{6},\\delta_{7},M_{s},D_{\\delta}]$，\n其中前七个条目是浮点数，后两个条目是布尔值。您的程序必须在没有任何外部输入或文件的情况下计算这些值，并且必须能在标准环境中按原样运行。\n\n您的算法必须从上述基本原理推导得出，且不得使用任何快捷公式或预先制表的分岔点。它必须根据给定的定义和基本连续性属性，通过算法生成所有值。",
            "solution": "该问题要求对Feigenbaum常数 $\\delta$ 进行数值计算，该常数表征了通向混沌的倍周期路径中的普适标度行为。我们的任务是针对一维逻辑斯谛映射这一特定情况来完成此项工作，该映射由迭代函数 $f_{r}(x) = r x (1 - x)$ 定义，其中状态变量 $x$ 被限制在区间 $[0, 1]$ 内，而 $r$ 是一个实数参数。解决方案必须从基本原理推导得出，即迭代映射的定义、其迭代的连续性以及介值定理。\n\n首先，我们建立理论和算法基础。映射的第 $k$ 次迭代由复合 $f_{r}^{(k)}(x) = f_r(f_r(\\dots f_r(x)\\dots))$ 定义，其中函数 $f_r$ 被应用 $k$ 次。对于任意固定的整数 $k$ 和初始点 $x$，函数 $g(r) = f_{r}^{(k)}(x)$ 是一个关于 $r$ 的多项式。其直接推论是，$g(r)$ 对所有 $r \\in \\mathbb{R}$ 都是关于 $r$ 的连续函数。这种连续性是我们数值方法所依赖的核心支柱，因为它允许应用介值定理。\n\n问题指示我们使用超稳定环来近似倍周期分岔点。当映射的临界点 $x_c$ 属于周期为 $p$ 的吸引环时，该吸引环是超稳定的。对于逻辑斯谛映射 $f_r(x)$，其临界点可通过求解 $f_r'(x_c) = r(1-2x_c) = 0$ 找到，得出 $x_c = 1/2$。周期为 $2^n$ 的超稳定环是指 $x_c=1/2$ 的轨道周期为 $2^n$ 的环。产生这种环的参数值 $s_n$ 可通过求解方程 $f_{s_n}^{(2^n)}(1/2) = 1/2$ 找到。这引导我们定义一个函数序列 $F_n(r) = f_{r}^{(2^n)}(1/2) - 1/2$。超稳定参数 $s_n$ 是方程 $F_n(r)=0$ 的根。由于 $f_r^{(2^n)}(1/2)$ 关于 $r$ 是连续的，因此 $F_n(r)$ 也是连续的。\n\n我们的目标是找到根序列 $\\{s_n\\}$（其中 $n=0, 1, 2, \\dots$）。问题规定，对于每个 $n \\geq 1$，我们必须找到方程 $F_n(r)=0$ 的严格大于 $s_{n-1}$ 的最小根。基例是 $s_0=2$，它对应于超稳定不动点（$n=0$，周期 $2^0=1$）。我们可以验证这一点：$F_0(r) = f_r(1/2) - 1/2 = r(1/2)(1-1/2) - 1/2 = r/4 - 1/2$。令 $F_0(r)=0$ 得到 $r/4=1/2$，因此 $s_0=2$。\n\n为了找到每个后续的根 $s_n$，我们采用一个基于 $F_n(r)$ 连续性的两阶段数值算法：\n1.  **根的区间限定**：介值定理指出，对于一个在区间 $[a, b]$ 上的连续函数 $F_n(r)$，如果 $F_n(a)$ 和 $F_n(b)$ 符号相反，则在 $(a, b)$ 内至少存在一个根。我们的算法必须首先为期望的根 $s_n$ 找到这样一个限定区间 $[a, b]$。我们从一个比先前找到的根 $s_{n-1}$ 稍大的点开始搜索，并以足够小的步长在 $r$ 上前进，在每个点上评估 $F_n(r)$ 的符号。第一个检测到符号变化的区间就成为我们的限定区间。这个过程可靠地分离出“大于 $s_{n-1}$ 的最小根”。\n\n2.  **通过二分法进行根的精化**：一旦根被限定在区间 $[a, b]$ 内，二分法就提供了一个稳健且保证收敛的算法来精化其值。该方法按如下步骤进行：\n    a. 计算中点 $c = (a+b)/2$ 并评估 $F_n(c)$。\n    b. 如果 $F_n(a)$ 和 $F_n(c)$ 符号相反，根位于 $[a, c]$ 内，因此我们设置 $b=c$。\n    c. 否则，根必定位于 $[c, b]$ 内，我们设置 $a=c$。\n    d. 重复此过程，每一步都将区间宽度减半，直到宽度 $(b-a)$ 小于预定的数值容差 $\\epsilon$。最终区间的中点被作为 $s_n$ 的高精度估计值。计算成本主要由 $F_n(r)$ 的求值决定，这需要对逻辑斯谛映射进行 $2^n$ 次迭代。\n\n这个过程被顺序地应用于计算序列 $s_0, s_1, s_2, \\dots, s_8$。高容差（例如 $\\epsilon=10^{-15}$）是必要的，因为后续Feigenbaum比率的计算对 $s_n$ 值的精度很敏感。\n\n计算出序列 $\\{s_n\\}_{n=0}^8$ 后，我们可以找到Feigenbaum常数的估计值 $\\delta_n$。它们由超稳定点之间连续参数区间的长度比给出：\n$$ \\delta_n = \\frac{s_n - s_{n-1}}{s_{n+1} - s_n} $$\n我们将为 $n \\in \\{1, 2, 3, 4, 5, 6, 7\\}$ 计算这些值。\n\n最后，计算两个诊断布尔值：\n-   $M_s$：该值检查计算出的序列是否严格单调递增，即对所有相关的 $k$ 是否有 $s_{k+1} > s_k$。这是一个预期的理论属性。\n-   $D_\\delta$：该值通过检查我们计算集合中最后三个可用连续索引的绝对差 $|\\delta_{n+1} - \\delta_n|$ 是否严格递减，来探查 $\\delta_n$ 序列的收敛性。这对应于测试是否 $|\\delta_5 - \\delta_4| > |\\delta_6 - \\delta_5| > |\\delta_7 - \\delta_6|$。\n\n这个稳健的、基于第一性原理的算法能够在不借助预先制表的值或高级库函数的情况下，精确确定所需的量，严格遵守了问题的约束条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is available but not used to adhere to the problem's\n# requirement of deriving and implementing the numerical method.\n\ndef solve():\n    \"\"\"\n    Computes Feigenbaum constant estimates for the logistic map by finding\n    superstable parameter values using a custom bisection root-finder.\n    \"\"\"\n    # Configuration\n    N_MAX = 8  # We need s_0 through s_8 to compute delta_1 through delta_7\n    BISECTION_TOL = 1e-15\n\n    # A dictionary of search step sizes for the bracketing algorithm.\n    # The step size must decrease as n increases because the distance\n    # between successive s_n values shrinks geometrically.\n    SEARCH_STEPS = {\n        1: 1e-1, 2: 1e-2, 3: 5e-3, 4: 1e-3,\n        5: 1e-4, 6: 1e-5, 7: 1e-6, 8: 1e-7\n    }\n\n    def iterate_map(r, x0, k):\n        \"\"\"Computes the k-th iterate of the logistic map f_r(x) starting from x0.\"\"\"\n        x = x0\n        for _ in range(k):\n            # Using np.float64 for operations to maintain precision\n            x = np.float64(r) * x * (np.float64(1.0) - x)\n        return x\n\n    def F_n(r, n):\n        \"\"\"The target function whose root is the superstable parameter s_n.\n        F_n(r) = f_r^(2^n)(1/2) - 1/2\n        \"\"\"\n        k = 1  n  # 2**n using bitwise shift\n        x_final = iterate_map(r, np.float64(0.5), k)\n        return x_final - np.float64(0.5)\n\n    def bisection(func, a, b, tol):\n        \"\"\"\n        Finds a root of func in the bracket [a, b] to a given tolerance.\n        Assumes func(a) and func(b) have opposite signs.\n        \"\"\"\n        fa = func(a)\n        if fa * func(b)  0:\n            raise ValueError(f\"Root is not bracketed in [{a}, {b}].\")\n        \n        while (b - a)  tol:\n            c = a + (b - a) / 2\n            fc = func(c)\n            if fc == 0:\n                return c\n            if fa * fc  0:\n                b = c\n            else:\n                a = c\n                fa = fc\n        return a + (b - a) / 2\n\n    s = [np.float64(2.0)]  # Start with s_0 = 2\n\n    # Sequentially compute s_1, s_2, ..., s_N_MAX\n    for n in range(1, N_MAX + 1):\n        target_func = lambda r: F_n(r, n)\n        \n        # --- Root Bracketing ---\n        # Start search for s_n just after s_{n-1}\n        # Add a small epsilon to avoid starting exactly at the previous root\n        r_a = s[n-1] + 1e-9\n        \n        search_step = SEARCH_STEPS.get(n, 1e-8)\n        val_a = target_func(r_a)\n        \n        while True:\n            r_b = r_a + search_step\n            val_b = target_func(r_b)\n            if val_a * val_b  0:\n                # Bracket found\n                break\n            r_a = r_b\n            val_a = val_b\n            if r_a  4.0: # Safety break; chaos is confined to r = 4\n                raise RuntimeError(f\"Bracket search failed for s_{n}\")\n\n        # --- Root Refinement ---\n        s_n = bisection(target_func, r_a, r_b, BISECTION_TOL)\n        s.append(s_n)\n\n    # Compute Feigenbaum ratio estimates delta_n\n    deltas = []\n    for n in range(1, 8):  # n from 1 to 7\n        numerator = s[n] - s[n-1]\n        denominator = s[n+1] - s[n]\n        delta_n = numerator / denominator\n        deltas.append(delta_n)\n    \n    # Compute diagnostic booleans\n    # M_s: Check if the s_n sequence is strictly increasing\n    M_s = all(s[i]  s[i+1] for i in range(len(s) - 1))\n    \n    # D_delta: Check for convergence behavior in the delta_n sequence.\n    # We check if the absolute differences |delta_{n+1} - delta_n|\n    # are strictly decreasing for the last three available indices.\n    delta_diffs_abs = [abs(deltas[i+1] - deltas[i]) for i in range(len(deltas) - 1)]\n    # This checks |d5-d4| > |d6-d5| AND |d6-d5| > |d7-d6|\n    D_delta = (delta_diffs_abs[3]  delta_diffs_abs[4]) and \\\n              (delta_diffs_abs[4]  delta_diffs_abs[5])\n              \n    # Format and print the final result\n    final_results = deltas + [M_s, D_delta]\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论分析为我们提供了精确的概念，但在实践中，我们大多依赖数值模拟来探索动力系统的行为。本练习将引导你探究在生成分岔图或计算动力学不变量时，有限的计算资源和算法选择（如暂态过程的丢弃长度和数据采样策略）如何影响我们对吸引子和李雅普诺夫指数的经验测量结果 。这个过程将加深你对不变测度和遍历性在混沌动力学中核心作用的理解。",
            "id": "4267640",
            "problem": "考虑单位区间 $[0,1]$ 上的一维逻辑斯谛映射 $f(x)=r\\,x(1-x)$，参数 $r=4$。该映射 $f$ 在 $[0,1]$ 上保持一个绝对连续不变概率测度 $\\mu$，其关于勒贝格测度的密度为 $\\rho(x)=\\frac{1}{\\pi\\sqrt{x(1-x)}}$。对于 $\\mu$-几乎所有的初始条件 $x_{0}\\in[0,1]$，最大李雅普诺夫指数定义为\n$$\n\\lambda(x_{0})=\\lim_{n\\to\\infty}\\frac{1}{n}\\sum_{k=0}^{n-1}\\ln\\big|f'(x_{k})\\big|\\quad\\text{其中 }x_{k}=f^{k}(x_{0})。\n$$\n从不变测度和 Birkhoff 遍历定理 (BET) 的核心定义出发，并假设在 $r=4$ 时测度 $\\mu$ 对于映射 $f$ 是遍历的，推导最大李雅普诺夫指数的空间平均表示，即一个关于 $\\rho$ 的积分。然后，仅使用给定的不变密度和基础微积分，计算该映射在 $r=4$ 时的最大李雅普诺夫指数的精确闭式解值。将最终答案表示为包含自然对数的单个精确表达式，不要进行四舍五入。最终答案无需物理单位。",
            "solution": "该问题要求分两部分作答：首先，利用所提供的定义和 Birkhoff 遍历定理 (BET) 推导最大李雅普诺夫指数的空间平均表示；其次，计算逻辑斯谛映射在指定参数值下该指数的精确值。\n\n问题陈述已经过验证，被认为是有效的。它在科学上基于遍历理论和非线性动力学的既定原理，是适定的，并且表述客观。所有必要的信息都已提供。\n\n**第一部分：空间平均表示的推导**\n\n最大李雅普诺夫指数 $\\lambda(x_0)$ 被给出为沿一条始于 $x_0$ 的轨道的时间平均：\n$$\n\\lambda(x_0) = \\lim_{n\\to\\infty}\\frac{1}{n}\\sum_{k=0}^{n-1}\\ln\\big|f'(x_k)\\big|\n$$\n其中 $x_k = f^k(x_0) = f(f(...f(x_0)...))$ 是映射 $f(x)$ 的第 $k$ 次迭代。\n\n该表达式具有函数 $g(x) = \\ln|f'(x)|$ 沿轨迹 $\\{x_k\\}_{k=0}^\\infty$ 的时间平均形式。Birkhoff 遍历定理 (BET) 建立了时间平均和空间平均之间的基本联系。该定理指出，对于一个概率空间 $(X, \\mathcal{B}, \\mu)$ 上的保测变换 $f$，如果 $f$ 关于测度 $\\mu$ 是遍历的，并且对于任何可积函数 $g \\in L^1(\\mu)$，对于 $\\mu$-几乎每一个初始点 $x_0 \\in X$，函数 $g$ 沿轨道的时间平均等于 $g$ 的空间平均。\n在数学上，对于 $\\mu$-几乎每一个 $x_0$：\n$$\n\\lim_{n\\to\\infty}\\frac{1}{n}\\sum_{k=0}^{n-1}g(f^k(x_0)) = \\int_X g(x) \\,d\\mu(x)\n$$\n在本问题的背景下：\n- 空间是单位区间，$X = [0, 1]$。\n- 变换是逻辑斯谛映射，$f(x) = 4x(1-x)$。\n- 假设系统对于不变概率测度 $\\mu$ 是遍历的。\n- 被平均的函数是 $g(x) = \\ln|f'(x)|$。我们必须确保 $g(x)$ 关于 $\\mu$ 是可积的，这一点我们将在计算过程中确认。\n\n通过应用 BET，我们可以将李雅普诺夫指数的时间平均定义与其空间平均对应项等同起来。由于该定理对 $\\mu$-几乎每一个 $x_0$ 都成立，所以对于这组点，李雅普诺夫指数 $\\lambda$ 与初始条件无关。\n$$\n\\lambda = \\int_0^1 \\ln|f'(x)| \\,d\\mu(x)\n$$\n问题陈述指出，不变测度 $\\mu$ 关于勒贝格测度 $dx$ 是绝对连续的，并给出了其概率密度函数 $\\rho(x)$。这意味着测度微分元 $d\\mu(x)$ 可以写成 $\\rho(x)dx$。将此代入积分，得到所需的空间平均表示：\n$$\n\\lambda = \\int_0^1 \\ln|f'(x)| \\rho(x) \\,dx\n$$\n推导至此完成。\n\n**第二部分：李雅普诺夫指数的计算**\n\n我们现在计算上面推导出的积分的值。给定的组成部分是：\n- 映射：$f(x) = 4x(1-x) = 4x - 4x^2$。\n- 导数：$f'(x) = 4 - 8x = 4(1-2x)$。\n- 不变密度：$\\rho(x) = \\frac{1}{\\pi\\sqrt{x(1-x)}}$。\n\n将这些代入 $\\lambda$ 的空间平均公式：\n$$\n\\lambda = \\int_0^1 \\ln|4(1-2x)| \\frac{1}{\\pi\\sqrt{x(1-x)}} \\,dx\n$$\n我们可以将对数项 $\\ln|4(1-2x)| = \\ln(4) + \\ln|1-2x|$ 分开。积分可以因此分成两部分：\n$$\n\\lambda = \\frac{1}{\\pi}\\int_0^1 \\frac{\\ln(4)}{\\sqrt{x(1-x)}} \\,dx + \\frac{1}{\\pi}\\int_0^1 \\frac{\\ln|1-2x|}{\\sqrt{x(1-x)}} \\,dx\n$$\n让我们分别计算每个积分。\n\n第一个积分 $I_1$：\n$$\nI_1 = \\frac{\\ln(4)}{\\pi} \\int_0^1 \\frac{1}{\\sqrt{x(1-x)}} \\,dx\n$$\n这个积分与概率密度函数 $\\rho(x)$ 的归一化有关。根据定义，概率密度函数的积分必须为 1：\n$$\n\\int_0^1 \\rho(x) \\,dx = \\int_0^1 \\frac{1}{\\pi\\sqrt{x(1-x)}} \\,dx = 1\n$$\n这意味着 $\\int_0^1 \\frac{1}{\\sqrt{x(1-x)}} \\,dx = \\pi$。因此，第一项是：\n$$\nI_1 = \\frac{\\ln(4)}{\\pi} \\cdot \\pi = \\ln(4)\n$$\n\n第二个积分 $I_2$：\n$$\nI_2 = \\frac{1}{\\pi}\\int_0^1 \\frac{\\ln|1-2x|}{\\sqrt{x(1-x)}} \\,dx\n$$\n为计算该积分，我们采用三角换元。令 $x = \\sin^2(\\theta)$。\n那么 $dx = 2\\sin(\\theta)\\cos(\\theta) \\,d\\theta$。积分上下限变化如下：当 $x=0$ 时，$\\theta=0$；当 $x=1$ 时，$\\theta=\\pi/2$。\n被积函数中的各项变为：\n- $\\sqrt{x(1-x)} = \\sqrt{\\sin^2(\\theta)(1-\\sin^2(\\theta))} = \\sqrt{\\sin^2(\\theta)\\cos^2(\\theta)} = \\sin(\\theta)\\cos(\\theta)$ 对于 $\\theta \\in [0, \\pi/2]$。\n- $1-2x = 1 - 2\\sin^2(\\theta) = \\cos(2\\theta)$。\n将这些直接代入 $\\lambda$ 的表达式中：\n$$\n\\lambda = \\frac{1}{\\pi} \\int_0^{\\pi/2} \\frac{\\ln|4\\cos(2\\theta)|}{\\sin(\\theta)\\cos(\\theta)} \\left(2\\sin(\\theta)\\cos(\\theta)\\right) \\,d\\theta = \\frac{2}{\\pi} \\int_0^{\\pi/2} \\ln|4\\cos(2\\theta)| \\,d\\theta\n$$\n我们可以再次拆分对数：\n$$\n\\lambda = \\frac{2}{\\pi} \\int_0^{\\pi/2} \\left(\\ln(4) + \\ln|\\cos(2\\theta)|\\right) \\,d\\theta = \\frac{2}{\\pi} \\left( \\int_0^{\\pi/2} \\ln(4) \\,d\\theta + \\int_0^{\\pi/2} \\ln|\\cos(2\\theta)| \\,d\\theta \\right)\n$$\n第一部分是 $\\frac{2}{\\pi} \\left( \\ln(4) \\cdot \\frac{\\pi}{2} \\right) = \\ln(4)$。这与 $I_1$ 相符。\n第二部分正是变量代换后的 $I_2$：\n$$\nI_2 = \\frac{2}{\\pi}\\int_0^{\\pi/2} \\ln|\\cos(2\\theta)| \\,d\\theta\n$$\n对数的自变量 $\\cos(2\\theta)$ 在 $\\theta \\in [0, \\pi/4)$ 时为正，在 $\\theta \\in (\\pi/4, \\pi/2]$ 时为负。我们在 $\\theta = \\pi/4$ 处拆分积分：\n$$\nI_2 = \\frac{2}{\\pi} \\left[ \\int_0^{\\pi/4} \\ln(\\cos(2\\theta)) \\,d\\theta + \\int_{\\pi/4}^{\\pi/2} \\ln(-\\cos(2\\theta)) \\,d\\theta \\right]\n$$\n对于第一个子积分，令 $u=2\\theta$，则 $d\\theta = du/2$。积分限变为 0 到 $\\pi/2$。\n$\\int_0^{\\pi/4} \\ln(\\cos(2\\theta)) \\,d\\theta = \\frac{1}{2}\\int_0^{\\pi/2} \\ln(\\cos(u)) \\,du$。\n对于第二个子积分，令 $v=\\pi - 2\\theta$，则 $d\\theta = -dv/2$。积分限变为 $\\pi/2$ 到 0。$-\\cos(2\\theta) = -\\cos(\\pi-v) = -(-\\cos(v)) = \\cos(v)$。\n$\\int_{\\pi/4}^{\\pi/2} \\ln(-\\cos(2\\theta)) \\,d\\theta = \\int_{\\pi/2}^0 \\ln(\\cos(v)) \\left(-\\frac{dv}{2}\\right) = \\frac{1}{2}\\int_0^{\\pi/2} \\ln(\\cos(v)) \\,dv$。\n因此，这两个子积分是相同的。\n$$\nI_2 = \\frac{2}{\\pi} \\left[ \\frac{1}{2}\\int_0^{\\pi/2} \\ln(\\cos(u)) \\,du + \\frac{1}{2}\\int_0^{\\pi/2} \\ln(\\cos(v)) \\,dv \\right] = \\frac{2}{\\pi} \\int_0^{\\pi/2} \\ln(\\cos(u)) \\,du\n$$\n这是一个标准的定积分结果。令 $J = \\int_0^{\\pi/2} \\ln(\\cos u) \\,du$。利用性质 $\\int_a^b f(x)dx = \\int_a^b f(a+b-x)dx$，我们也有 $J = \\int_0^{\\pi/2} \\ln(\\sin u) \\,du$。\n将这两种形式相加得到：\n$$\n2J = \\int_0^{\\pi/2} (\\ln(\\sin u) + \\ln(\\cos u)) \\,du = \\int_0^{\\pi/2} \\ln(\\sin u \\cos u) \\,du = \\int_0^{\\pi/2} \\ln\\left(\\frac{\\sin(2u)}{2}\\right) \\,du\n$$\n$$\n2J = \\int_0^{\\pi/2} \\ln(\\sin(2u)) \\,du - \\int_0^{\\pi/2} \\ln(2) \\,du\n$$\n第二项是 $\\frac{\\pi}{2}\\ln(2)$。对于第一项，令 $w=2u$，则 $du = dw/2$。积分限为 0 到 $\\pi$。\n$\\int_0^{\\pi/2} \\ln(\\sin(2u)) \\,du = \\frac{1}{2}\\int_0^{\\pi} \\ln(\\sin w) \\,dw$。根据 $\\sin(w)$ 关于 $w=\\pi/2$ 的对称性，此项为 $\\frac{1}{2} \\left( 2 \\int_0^{\\pi/2} \\ln(\\sin w) \\,dw \\right) = \\int_0^{\\pi/2} \\ln(\\sin w) \\,dw = J$。\n代回原式：\n$$\n2J = J - \\frac{\\pi}{2}\\ln(2) \\implies J = -\\frac{\\pi}{2}\\ln(2)\n$$\n最后，我们可以计算出 $I_2$：\n$$\nI_2 = \\frac{2}{\\pi} J = \\frac{2}{\\pi} \\left(-\\frac{\\pi}{2}\\ln(2)\\right) = -\\ln(2)\n$$\n综合 $I_1$ 和 $I_2$ 的结果：\n$$\n\\lambda = I_1 + I_2 = \\ln(4) - \\ln(2) = \\ln(2^2) - \\ln(2) = 2\\ln(2) - \\ln(2) = \\ln(2)\n$$\n逻辑斯谛映射在 $r=4$ 时的最大李雅普诺夫指数为 $\\ln(2)$。",
            "answer": "$$\\boxed{\\ln(2)}$$"
        },
        {
            "introduction": "理论分析为我们提供了精确的概念，但在实践中，我们大多依赖数值模拟来探索动力系统的行为。本练习将引导你探究在生成分岔图或计算动力学不变量时，有限的计算资源和算法选择（如暂态过程的丢弃长度和数据采样策略）如何影响我们对吸引子和李雅普诺夫指数的经验测量结果 。完成这项练习将使你对计算动力学研究中的常见陷阱有更敏锐的认识，并掌握进行可靠数值实验的关键技能。",
            "id": "4267582",
            "problem": "您的任务是分析用于构建一维逻辑斯谛映射分岔图的有限时间数值程序如何影响其长期行为的经验表示。逻辑斯谛映射是由函数 $f_r:[0,1]\\to[0,1]$ 定义的离散时间动力系统，其更新规则为 $x_{n+1} = f_r(x_n) = r\\,x_n(1-x_n)$，其中 $r \\in [0,4]$ 是一个实数参数，$x_n \\in [0,1]$ 是在离散时间 $n \\in \\mathbb{N}$ 的状态。对于每个固定的参数 $r$，轨道 $(x_n)_{n\\ge 0}$ 由初始条件 $x_0 \\in (0,1)$ 决定。分岔图可视化了当 $r$ 变化时轨道值的渐近集合，其经验构建依赖于两个数值设计选择：舍弃有限的暂态部分和对轨道的有限子序列进行采样。\n\n基本定义和经过充分检验的事实，作为您推理的基础：\n- 当几乎每条轨道的长时间统计都收敛到相同的分布时，映射 $f_r$ 接受 $[0,1]$ 上的一个不变概率测度 $\\mu_r$；对于混沌吸引子，这通常是 Sinai–Ruelle–Bowen (SRB) 测度。对于像 $f_r$ 这样的一维分段光滑映射，长轨道的经验分布通常用作 $\\mu_r$ 的近似。\n- 最大李雅普诺夫指数定义为（当极限存在时）$\\lambda(r) = \\lim_{N\\to\\infty} \\frac{1}{N} \\sum_{n=0}^{N-1} \\ln |f_r'(x_n)|$，其中 $f_r'(x) = r(1-2x)$。对于遍历测度，根据 Birkhoff 遍历定理，沿典型轨道的时间平均等于相对于 $\\mu_r$ 的空间平均。\n\n您的程序必须为每个测试用例参数 $r$ 执行以下操作：\n1. 从相同的固定初始条件 $x_0 = 0.123456789$ 开始，生成逻辑斯谛映射 $x_{n+1} = r\\,x_n(1-x_n)$ 的单条轨道，长度为 $N = 10^5$ 次迭代。\n2. 考虑两个暂态舍弃长度 $T_{\\text{short}}$ 和 $T_{\\text{long}}$，其中 $0  T_{\\text{short}}  T_{\\text{long}}  N$，以及两种采样方案：步长为 $s_{\\text{dense}} = 1$ 的密集采样和步长为 $s_{\\text{thin}} \\in \\mathbb{N}$（$s_{\\text{thin}} \\ge 2$）的稀疏采样。\n3. 为确保在固定的总迭代次数 $N$ 预算下，各方案之间能进行公平比较，通过以下方式定义共同样本大小 $M_0$：\n$$\nM_0 = \\min\\left\\{N - T_{\\text{short}},\\; N - T_{\\text{long}},\\; \\left\\lfloor \\frac{N - T_{\\text{long}}}{s_{\\text{thin}}} \\right\\rfloor \\right\\}。\n$$\n然后，使用以下三种配置中的每一种，精确提取 $M_0$ 个样本：\n- 短暂态密集采样：舍弃 $T_{\\text{short}}$ 个点，然后以步长 $s_{\\text{dense}} = 1$ 取 $M_0$ 个连续点。\n- 长暂态密集采样：舍弃 $T_{\\text{long}}$ 个点，然后以步长 $s_{\\text{dense}} = 1$ 取 $M_0$ 个连续点。\n- 长暂态稀疏采样：舍弃 $T_{\\text{long}}$ 个点，然后以步长 $s_{\\text{thin}}$ 取 $M_0$ 个点。\n4. 对于每个样本集，在区间 $[0,1]$ 上计算一个包含 $B = 200$ 个等宽箱的归一化直方图，以近似该采样方案导出的经验不变测度 $\\mu_r$。设所得的概率向量为 $p_{\\text{short,dense}}$、$p_{\\text{long,dense}}$ 和 $p_{\\text{long,thin}}$。\n5. 通过计算以下两个距离，来量化吸引子的经验视觉测度如何受到暂态舍弃和采样的影响：\n- 暂态敏感性，即具有短暂态和长暂态的密集采样直方图之间的总变差距离：\n$$\nD_{\\text{transient}} = \\frac{1}{2} \\sum_{i=1}^{B} \\left| \\left(p_{\\text{short,dense}}\\right)_i - \\left(p_{\\text{long,dense}}\\right)_i \\right|。\n$$\n- 采样敏感性，即长暂态密集采样和长暂态稀疏采样直方图之间的总变差距离：\n$$\nD_{\\text{sampling}} = \\frac{1}{2} \\sum_{i=1}^{B} \\left| \\left(p_{\\text{long,dense}}\\right)_i - \\left(p_{\\text{long,thin}}\\right)_i \\right|。\n$$\n6. 对于每个样本集，通过有限时间平均估计最大李雅普诺夫指数：\n$$\n\\hat{\\lambda} = \\frac{1}{M_0} \\sum_{m=1}^{M_0} \\ln \\left| r \\left( 1 - 2 x_m \\right) \\right|,\n$$\n其中 $x_m$ 遍历采样的子序列。使用这些估计值，计算：\n- $\\Delta_{\\text{transient}} = \\left| \\hat{\\lambda}_{\\text{short,dense}} - \\hat{\\lambda}_{\\text{long,dense}} \\right|$，\n- $\\Delta_{\\text{sampling}} = \\left| \\hat{\\lambda}_{\\text{long,dense}} - \\hat{\\lambda}_{\\text{long,thin}} \\right|$。\n\n测试套件和参数覆盖范围：\n- 情况1（周期-2 区域和混叠边界情况）：$r = 3.0$，$T_{\\text{short}} = 100$，$T_{\\text{long}} = 5000$，$s_{\\text{thin}} = 2$。\n- 情况2（倍周期分岔后的周期窗口）：$r = 3.5$，$T_{\\text{short}} = 100$，$T_{\\text{long}} = 5000$，$s_{\\text{thin}} = 2$。\n- 情况3（完全混沌区域）：$r = 3.7$，$T_{\\text{short}} = 100$，$T_{\\text{long}} = 5000$，$s_{\\text{thin}} = 5$。\n- 情况4（强混沌区域，接近上界）：$r = 3.9$，$T_{\\text{short}} = 100$，$T_{\\text{long}} = 5000$，$s_{\\text{thin}} = 7$。\n\n要求的输出：\n- 对于每种情况，输出一个包含四个浮点数的列表 $[D_{\\text{transient}}, D_{\\text{sampling}}, \\Delta_{\\text{transient}}, \\Delta_{\\text{sampling}}]$，其中每个浮点数四舍五入到恰好六位小数。\n- 您的程序应生成单行输出，其中包含这些列表组成的、以逗号分隔的列表，并用方括号括起来。例如，一个有效的形状是 $[[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4],\\ldots]$，不含空格。\n\n关于科学真实性的说明：\n- 按照规定，每个参数的总迭代步数保持在 $N = 10^5$ 以内。\n- 使用 $x_0 = 0.123456789$，并确保所有直方图的箱均匀覆盖 $[0,1]$。\n- 在计算 $\\ln |f_r'(x)|$ 时，如果 $|f_r'(x)|$ 发生数值下溢，请使用一个标准的小的正常数阈值以避免对零取自然对数，并在您的解题思路中明确说明这一选择。",
            "solution": "用户提供的问题经评估为有效。该问题在科学上是合理的，提法明确，并且所有变量和条件都得到了清晰的规定。该问题构成了非线性动力学和混沌理论领域的一项标准数值研究，专注于逻辑斯谛映射分析中的计算假象。\n\n解决方案通过实施指定的数值实验来进行。对于每个参数集，分析涉及轨道生成、根据三种不同方案进行子采样，以及随后计算统计量和动力学量以量化这些方案引起的差异。\n\n### 基于原理的设计\n\n所研究的基本原理是动力系统的长期行为与其有限时间数值近似之间的对应关系。对于遍历系统，Birkhoff 遍历定理保证了对于几乎所有的初始条件，沿轨道的可观测量的长时间平均会收敛到相对于系统自然不变测度 $\\mu_r$ 的空间平均。数值模拟分岔图涉及两个关键的近似：\n1.  **舍弃暂态**：将轨道迭代一段有限时间 $T$，使其稳定到吸引子上，并舍弃最初的 $T$ 个点。\n2.  **采样吸引子**：记录系统在后续有限次迭代中的状态，以构建吸引子的几何形态及其上支撑的不变测度的图像。\n\n本问题将对这些选择如何影响动力学的两个主要特征进行形式化的研究：其一是不变测度本身（由直方图近似），其二是最大李雅普诺夫指数 $\\hat{\\lambda}$（衡量系统对初始条件的敏感性）。\n\n### 算法实现\n\n对于每个由参数集 $(r, T_{\\text{short}}, T_{\\text{long}}, s_{\\text{thin}})$ 定义的测试用例，将执行以下步骤序列。\n\n1.  **轨道生成**：使用逻辑斯谛映射的递推关系 $x_{n+1} = r\\,x_n(1-x_n)$ 生成一个长度为 $N = 10^5$ 的单一时间序列 $(x_n)_{n=0}^{N-1}$。初始条件固定为 $x_0 = 0.123456789$。这个长轨道作为所有后续分析的基础数据。\n\n2.  **共同样本大小计算**：为确保公平比较，所有统计估计都基于相同数量的数据点 $M_0$。该大小由限制性最强的采样方案确定：\n    $$\n    M_0 = \\min\\left\\{N - T_{\\text{short}},\\; N - T_{\\text{long}},\\; \\left\\lfloor \\frac{N - T_{\\text{long}}}{s_{\\text{thin}}} \\right\\rfloor \\right\\}\n    $$\n    这确保了任何观察到的差异都是由采样策略本身（即选择哪些点）引起的，而不是由于不同样本大小相关的统计不确定性。\n\n3.  **数据提取**：从主轨道中提取三个不同的大小均为 $M_0$ 的样本：\n    *   **短暂态密集样本**：该子序列在 $T_{\\text{short}}$ 次迭代后开始，由 $M_0$ 个连续点组成。这对应于 `orbit[T_short : T_short + M_0]`。\n    *   **长暂态密集样本**：该子序列在 $T_{\\text{long}}$ 次迭代后开始，由 $M_0$ 个连续点组成。这对应于 `orbit[T_long : T_long + M_0]`。\n    *   **长暂态稀疏样本**：该子序列在 $T_{\\text{long}}$ 次迭代后开始，但以 $s_{\\text{thin}}$ 的步长取点。这对应于 `orbit[T_long : T_long + M_0 * s_thin : s_thin]`。\n\n4.  **经验不变测度的估计**：对于三个样本中的每一个，我们近似不变测度 $\\mu_r$。这是通过在区间 $[0,1]$ 上使用 $B = 200$ 个等宽箱构建归一化直方图来完成的。如果 $c_i$ 是第 $i$ 个箱中的样本点计数，则该箱的概率为 $p_i = c_i / M_0$。此过程产生三个概率向量：$p_{\\text{short,dense}}$、$p_{\\text{long,dense}}$ 和 $p_{\\text{long,thin}}$。\n\n5.  **量化测度差异**：使用总变差距离（一种衡量概率分布的标准度量）来量化经验测度之间的差异。计算的两个特定量是：\n    *   暂态敏感性：$D_{\\text{transient}} = \\frac{1}{2} \\sum_{i=1}^{B} | (p_{\\text{short,dense}})_i - (p_{\\text{long,dense}})_i |$。这衡量了延长暂态舍弃周期的影响。\n    *   采样敏感性：$D_{\\text{sampling}} = \\frac{1}{2} \\sum_{i=1}^{B} | (p_{\\text{long,dense}})_i - (p_{\\text{long,thin}})_i |$。这衡量了在长暂态之后，稀疏采样与密集采样的影响。\n\n6.  **有限时间李雅普诺夫指数的估计**：最大李雅普诺夫指数是混沌的关键指标。对于一维映射，它通过对映射导数绝对值的自然对数沿轨道进行平均来估计。对于每个样本，估计值 $\\hat{\\lambda}$ 计算如下：\n    $$\n    \\hat{\\lambda} = \\frac{1}{M_0} \\sum_{m=1}^{M_0} \\ln \\left| r \\left( 1 - 2 x_m \\right) \\right|\n    $$\n    其中 $\\{x_m\\}_{m=1}^{M_0}$ 是样本中的点。一个关键的实现细节是处理对数参数为零的情况，这种情况发生于轨道点 $x_m$ 恰好等于临界点 $x=0.5$ 时。为了防止出现致命的数学错误（$\\ln(0)$）并保持数值稳定性，在取对数之前，将一个小的正常数 `numpy.finfo(float).tiny` 加到绝对值 $|f_r'(x_m)|$上。\n\n7.  **量化李雅普诺夫指数的差异**：李雅普诺夫指数估计对采样方案的敏感性通过绝对差来衡量：\n    *   暂态敏感性：$\\Delta_{\\text{transient}} = | \\hat{\\lambda}_{\\text{short,dense}} - \\hat{\\lambda}_{\\text{long,dense}} |$。\n    *   采样敏感性：$\\Delta_{\\text{sampling}} = | \\hat{\\lambda}_{\\text{long,dense}} - \\hat{\\lambda}_{\\text{long,thin}} |$。\n\n对四个指定的测试用例中的每一个都执行这些计算，并按要求编译和格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries outside the Python standard library are permitted.\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (r, T_short, T_long, s_thin)\n        (3.0, 100, 5000, 2),\n        (3.5, 100, 5000, 2),\n        (3.7, 100, 5000, 5),\n        (3.9, 100, 5000, 7),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = analyze_logistic_map(*params)\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    # Format: [[a,b,c,d],[e,f,g,h],...]\n    output_parts = []\n    for res_list in all_results:\n        formatted_list = ','.join([f'{x:.6f}' for x in res_list])\n        output_parts.append(f'[{formatted_list}]')\n    \n    print(f\"[{','.join(output_parts)}]\")\n\ndef analyze_logistic_map(r, T_short, T_long, s_thin):\n    \"\"\"\n    Performs the analysis for a single set of parameters for the logistic map.\n    \n    Args:\n        r (float): The parameter of the logistic map.\n        T_short (int): Short transient discard length.\n        T_long (int): Long transient discard length.\n        s_thin (int): Stride for thin sampling.\n\n    Returns:\n        list: A list containing [D_transient, D_sampling, Delta_transient, Delta_sampling].\n    \"\"\"\n    N = 100000\n    x0 = 0.123456789\n    B = 200\n\n    # 1. Generate the orbit\n    orbit = np.zeros(N)\n    orbit[0] = x0\n    for n in range(N - 1):\n        orbit[n + 1] = r * orbit[n] * (1 - orbit[n])\n        \n    # 2. Define the common sample size M0\n    M0 = min(N - T_short, N - T_long, (N - T_long) // s_thin)\n\n    # 3. Extract the three sample sets\n    sample_short_dense = orbit[T_short : T_short + M0]\n    sample_long_dense = orbit[T_long : T_long + M0]\n    # The stop index for thin sampling ensures exactly M0 points are taken\n    stop_index_thin = T_long + M0 * s_thin\n    sample_long_thin = orbit[T_long : stop_index_thin : s_thin]\n\n    # 4. Compute normalized histograms\n    hist_short_dense, _ = np.histogram(sample_short_dense, bins=B, range=(0, 1))\n    hist_long_dense, _ = np.histogram(sample_long_dense, bins=B, range=(0, 1))\n    hist_long_thin, _ = np.histogram(sample_long_thin, bins=B, range=(0, 1))\n\n    # Normalize to get probability vectors\n    p_short_dense = hist_short_dense / M0\n    p_long_dense = hist_long_dense / M0\n    p_long_thin = hist_long_thin / M0\n    \n    # 5. Compute total variation distances\n    D_transient = 0.5 * np.sum(np.abs(p_short_dense - p_long_dense))\n    D_sampling = 0.5 * np.sum(np.abs(p_long_dense - p_long_thin))\n\n    # 6. Estimate largest Lyapunov exponents\n    # Define a helper function for clarity\n    def estimate_lyapunov(sample, r_param):\n        # Add a small epsilon to avoid ln(0)\n        # np.finfo(float).tiny is the smallest positive representable number.\n        log_derivs = np.log(np.abs(r_param * (1 - 2 * sample)) + np.finfo(float).tiny)\n        return np.mean(log_derivs)\n\n    lambda_short_dense = estimate_lyapunov(sample_short_dense, r)\n    lambda_long_dense = estimate_lyapunov(sample_long_dense, r)\n    lambda_long_thin = estimate_lyapunov(sample_long_thin, r)\n    \n    # Compute differences in Lyapunov estimates\n    Delta_transient = np.abs(lambda_short_dense - lambda_long_dense)\n    Delta_sampling = np.abs(lambda_long_dense - lambda_long_thin)\n    \n    return [D_transient, D_sampling, Delta_transient, Delta_sampling]\n\nsolve()\n```"
        }
    ]
}