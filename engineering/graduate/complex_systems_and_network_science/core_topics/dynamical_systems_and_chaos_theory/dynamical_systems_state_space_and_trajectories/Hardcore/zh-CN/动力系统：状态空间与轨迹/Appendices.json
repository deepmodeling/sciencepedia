{
    "hands_on_practices": [
        {
            "introduction": "逻辑斯谛映射 (logistic map) 是研究非线性动力学的范例。理解一个动力系统不仅在于找到其平衡点，更在于确定哪些初始状态会导向何种长期行为。本练习  提供了一个具体的实践机会，旨在为一个稳定不动点确定其吸引盆，并理解不稳定点在塑造这些吸引盆边界中所起的关键作用。",
            "id": "4272727",
            "problem": "考虑由逻辑斯谛映射 $f_{r}:[0,1]\\to[0,1]$ 定义的离散时间动力系统，该映射由 $f_{r}(x)=r\\,x\\,(1-x)$ 给出，其中 $r$ 是一个参数，$x$ 是状态变量。状态空间是紧区间 $[0,1]$，轨迹由 $x_{k+1}=f_{r}(x_{k})$ 生成。在参数范围 $1  r \\le 3$ 内，非零不动点 $p_r = 1 - 1/r$ 是渐近稳定的。请确定它的吸引盆，即所有最终收敛于 $p_r$ 的初始点 $x_0 \\in [0,1]$ 的集合。这个集合是一个开区间 $(a,b)$。你的任务是确定上界 $b$ 的值。",
            "solution": "该问题要求在参数范围 $1  r \\le 3$ 内，为逻辑斯谛映射 $f_r(x) = r x (1-x)$ 的非零稳定不动点确定其吸引盆的上界。\n\n**步骤 1：找到不动点**\n不动点是满足 $f_r(x) = x$ 的点。\n$$ x = r x (1 - x) $$\n该方程的一个解是 $x=0$。如果 $x \\neq 0$，我们可以两边除以 $x$：\n$$ 1 = r (1 - x) \\implies 1 = r - rx \\implies rx = r - 1 \\implies x = 1 - \\frac{1}{r} $$\n因此，我们有两个不动点：$p_0 = 0$ 和 $p_r = 1 - 1/r$。\n\n**步骤 2：分析不动点的稳定性**\n稳定性由导数 $f_r'(x) = r(1-2x)$ 在不动点处的值决定。\n- 对于 $p_0 = 0$：$f_r'(0) = r$。因为题目设定 $r > 1$，所以 $|f_r'(0)| > 1$。这意味着不动点 $p_0 = 0$ 是不稳定的（是一个排斥子）。\n- 对于 $p_r = 1 - 1/r$：\n  $$ f_r'(p_r) = r \\left(1 - 2\\left(1 - \\frac{1}{r}\\right)\\right) = r \\left(1 - 2 + \\frac{2}{r}\\right) = r \\left(-1 + \\frac{2}{r}\\right) = 2 - r $$\n  在给定的参数范围 $1  r \\le 3$ 内，我们有 $-1 \\le 2 - r  1$。因此，导数的绝对值 $|f_r'(p_r)| \\le 1$。这意味着不动点 $p_r$ 是稳定的（对于 $1  r  3$ 是渐近稳定的，对于 $r=3$ 是中性稳定的）。\n\n**步骤 3：确定吸引盆**\n吸引盆是所有最终收敛到稳定不动点 $p_r$ 的初始点的集合。我们考虑状态空间 $[0,1]$。\n- 不动点 $p_0 = 0$ 是一个排斥子，所以从它附近（非零）的任何点出发的轨迹都会远离它。因此，$0$ 是吸引盆的一个边界点。\n- 考虑区间的另一个端点 $x=1$。$f_r(1) = r \\cdot 1 \\cdot (1-1) = 0$。点 $1$ 会在一次迭代后被映射到不稳定的不动点 $0$。因此，它本身不收敛于 $p_r$，并且是吸引盆的另一个边界点。\n- 对于任何 $x_0 \\in (0, 1)$，轨迹 $x_{k+1} = f_r(x_k)$ 将保持在 $(0, 1)$ 内，并最终收敛到稳定的不动点 $p_r = 1 - 1/r$。\n因此，$p_r$ 的吸引盆是开区间 $(0, 1)$。\n\n**步骤 4：回答问题**\n问题要求确定吸引盆开区间 $(a,b)$ 的上界 $b$。根据我们的分析，该区间是 $(0,1)$，所以上界 $b=1$。",
            "answer": "$$ \\boxed{1} $$"
        },
        {
            "introduction": "在理解了吸引盆之后，我们可以进一步深入研究单个轨迹的结构。本练习  专注于离散时间系统中的基本概念：轨道和原像。通过为映射 $F(x) = x^2 - 2$ 显式计算其正向轨道和反向原像，学习者可以亲身体会到一个简单的非线性函数迭代如何能够产生复杂的周期性行为。",
            "id": "4272770",
            "problem": "考虑实直线上的一个离散时间动力系统，其状态空间为 $\\mathbb{R}$，演化由映射 $F:\\mathbb{R}\\to\\mathbb{R}$ 给出，定义为 $F(x)=x^{2}-2$。设初始条件为 $x_{0}=2\\cos\\!\\left(\\frac{\\pi}{9}\\right)$，其中所有角度均以弧度为单位。\n\n仅使用离散时间动力系统中轨道、正向像和原像的基本定义，以及经过验证的三角恒等式，完成以下任务：\n\n1. 构建正向轨道 $\\{x_{k}\\}_{k\\geq 0}$，其中 $x_{k}=F^{k}(x_{0})$，直至并包括 $k=6$。将每个 $x_{k}$ 符号化地表示为在 $\\frac{\\pi}{9}$ 的某个倍数上求值的单一三角函数。\n2. 确定 $x_{0}$ 在 $F$ 下的一阶原像的完整集合，即集合 $F^{-1}(x_{0})=\\{x\\in\\mathbb{R}:F(x)=x_{0}\\}$。\n3. 确定位于区间 $[-2,2]$ 内的 $x_{0}$ 的二阶原像的完整集合，即集合 $\\{x\\in[-2,2]:F^{2}(x)=x_{0}\\}$。\n\n所有中间结果都用符号表示；不要使用数值近似。你的最终任务是提供 $x_{6}$ 的精确封闭形式表达式的单一值。不要进行数值近似，也不要包含单位。",
            "solution": "在尝试解答之前，对问题进行验证。\n\n### 步骤1：提取已知条件\n- 动力系统：实直线上的离散时间系统。\n- 状态空间：$\\mathbb{R}$。\n- 演化映射：$F: \\mathbb{R} \\to \\mathbb{R}$，定义为 $F(x) = x^{2} - 2$。\n- 初始条件：$x_{0} = 2\\cos(\\frac{\\pi}{9})$。\n- 记号：$x_{k} = F^{k}(x_{0}) = F(F(...F(x_0)...))$，$F$ 在 $x_0$ 上的第 $k$ 次迭代。\n- 任务1：构建直至 $k=6$ 的正向轨道 $\\{x_{k}\\}_{k\\geq 0}$，将每个 $x_k$ 表示为特定的三角函数形式。\n- 任务2：求一阶原像集 $F^{-1}(x_{0}) = \\{x \\in \\mathbb{R} : F(x) = x_{0}\\}$。\n- 任务3：求区间 $[-2, 2]$ 内的二阶原像集，即 $\\{x \\in [-2, 2] : F^{2}(x) = x_{0}\\}$。\n- 最终答案要求：提供 $x_6$ 的精确封闭形式值。\n\n### 步骤2：使用提取的已知条件进行验证\n问题定义良好且数学上合理。\n- **科学依据：** 映射 $F(x) = x^{2} - 2$ 是动力系统研究中的一个著名对象，称为第二类切比雪夫多项式 $T_{2}(x)$。对于区间 $[-2, 2]$ 内的初始条件，其动力学行为与圆上的倍角映射共轭，后者是混沌理论中的一个基本模型。该问题基于既定的数学原理。\n- **适定性：** 函数 $F$ 定义清晰，初始条件是一个特定的实数，任务表述明确无误。存在唯一且有意义的解。\n- **客观性：** 问题陈述由形式化的数学定义和问题构成，没有任何主观或偏见的语言。\n\n所有有效性标准均已满足。该问题并非不合理、不可形式化、不完整、不切实际、不适定、琐碎或不可验证。\n\n### 步骤3：结论与行动\n问题有效。将提供完整解答。\n\n### 解\n\n通过变量替换可以大大简化映射 $F(x) = x^{2} - 2$ 的动力学行为，特别是对于区间 $[-2, 2]$ 内的初始条件。设 $x = 2\\cos(\\theta)$，其中 $\\theta$ 为某个角度。将映射 $F$ 应用于此形式，得到：\n$$F(x) = F(2\\cos(\\theta)) = (2\\cos(\\theta))^{2} - 2 = 4\\cos^{2}(\\theta) - 2$$\n使用倍角三角恒等式 $2\\cos^{2}(\\theta) - 1 = \\cos(2\\theta)$，我们可以简化表达式：\n$$F(2\\cos(\\theta)) = 2(2\\cos^{2}(\\theta) - 1) = 2\\cos(2\\theta)$$\n这表明，对于由 $2\\cos(\\theta)$ 表示的状态 $x$，下一个状态 $F(x)$ 由 $2\\cos(2\\theta)$ 表示。将映射迭代 $k$ 次对应于将角度重复加倍：\n$$F^{k}(2\\cos(\\theta)) = 2\\cos(2^{k}\\theta)$$\n这种共轭关系提供了一种直接方法来解决问题的所有部分。\n\n#### 1. 正向轨道构建\n初始条件为 $x_{0} = 2\\cos(\\frac{\\pi}{9})$。这已经是 $2\\cos(\\theta_{0})$ 的形式，其中 $\\theta_{0} = \\frac{\\pi}{9}$。我们现在可以使用公式 $x_{k} = 2\\cos(2^{k}\\theta_{0})$ 计算正向轨道 $\\{x_{k}\\}_{k=0}^{6}$。\n\n- 对于 $k=0$：$x_{0} = 2\\cos(2^{0} \\cdot \\frac{\\pi}{9}) = 2\\cos(\\frac{\\pi}{9})$。\n- 对于 $k=1$：$x_{1} = 2\\cos(2^{1} \\cdot \\frac{\\pi}{9}) = 2\\cos(\\frac{2\\pi}{9})$。\n- 对于 $k=2$：$x_{2} = 2\\cos(2^{2} \\cdot \\frac{\\pi}{9}) = 2\\cos(\\frac{4\\pi}{9})$。\n- 对于 $k=3$：$x_{3} = 2\\cos(2^{3} \\cdot \\frac{\\pi}{9}) = 2\\cos(\\frac{8\\pi}{9})$。使用恒等式 $\\cos(\\pi - \\alpha) = -\\cos(\\alpha)$，我们可以写出 $x_{3} = 2\\cos(\\pi - \\frac{\\pi}{9}) = -2\\cos(\\frac{\\pi}{9}) = -x_{0}$。\n- 对于 $k=4$：$x_{4} = F(x_{3}) = F(-x_{0}) = (-x_{0})^{2} - 2 = x_{0}^{2} - 2 = F(x_{0}) = x_{1}$。因此，$x_{4} = 2\\cos(\\frac{2\\pi}{9})$。\n- 对于 $k=5$：由于轨道已进入一个循环（$x_{4} = x_{1}$），我们有 $x_{5} = F(x_{4}) = F(x_{1}) = x_{2}$。因此，$x_{5} = 2\\cos(\\frac{4\\pi}{9})$。\n- 对于 $k=6$：类似地，$x_{6} = F(x_{5}) = F(x_{2}) = x_{3}$。因此，$x_{6} = 2\\cos(\\frac{8\\pi}{9})$。\n\n直至 $k=6$ 的正向轨道是：\n$\\{2\\cos(\\frac{\\pi}{9}), 2\\cos(\\frac{2\\pi}{9}), 2\\cos(\\frac{4\\pi}{9}), 2\\cos(\\frac{8\\pi}{9}), 2\\cos(\\frac{2\\pi}{9}), 2\\cos(\\frac{4\\pi}{9}), 2\\cos(\\frac{8\\pi}{9})\\}$。\n\n#### 2. $x_{0}$ 的一阶原像\n我们要求解集合 $F^{-1}(x_{0}) = \\{x \\in \\mathbb{R} : F(x) = x_{0}\\}$。这需要解方程 $x^{2} - 2 = x_{0}$。\n$$x^{2} = x_{0} + 2$$\n$$x = \\pm\\sqrt{x_{0} + 2}$$\n代入 $x_{0} = 2\\cos(\\frac{\\pi}{9})$：\n$$x = \\pm\\sqrt{2\\cos(\\frac{\\pi}{9}) + 2} = \\pm\\sqrt{2(1 + \\cos(\\frac{\\pi}{9}))}$$\n使用半角恒等式 $1 + \\cos(2\\alpha) = 2\\cos^{2}(\\alpha)$，令 $2\\alpha = \\frac{\\pi}{9}$（因此 $\\alpha = \\frac{\\pi}{18}$）：\n$$x = \\pm\\sqrt{2 \\cdot 2\\cos^{2}(\\frac{\\pi}{18})} = \\pm\\sqrt{4\\cos^{2}(\\frac{\\pi}{18})} = \\pm 2\\cos(\\frac{\\pi}{18})$$\n一阶原像集为 $F^{-1}(x_{0}) = \\{2\\cos(\\frac{\\pi}{18}), -2\\cos(\\frac{\\pi}{18})\\}$。\n\n#### 3. $[-2, 2]$ 内 $x_{0}$ 的二阶原像\n我们要求解集合 $\\{x \\in [-2, 2] : F^{2}(x) = x_{0}\\}$，这是 $F^{-1}(x_{0})$ 中元素的原像集。设 $y \\in F^{-1}(x_{0})$。我们必须对 $x$ 解方程 $F(x) = y$，即 $x^{2} - 2 = y$。这得到 $x = \\pm\\sqrt{y+2}$。如果 $y \\in [-2, 2]$，则限制条件 $x \\in [-2, 2]$ 自动满足，而我们的集合 $F^{-1}(x_{0})$ 正是这种情况。\n\n情况1：$y = 2\\cos(\\frac{\\pi}{18})$\n$$x = \\pm\\sqrt{2\\cos(\\frac{\\pi}{18}) + 2} = \\pm\\sqrt{2(1 + \\cos(\\frac{\\pi}{18}))}$$\n使用半角恒等式，令 $2\\alpha = \\frac{\\pi}{18}$（因此 $\\alpha = \\frac{\\pi}{36}$）：\n$$x = \\pm\\sqrt{2 \\cdot 2\\cos^{2}(\\frac{\\pi}{36})} = \\pm 2\\cos(\\frac{\\pi}{36})$$\n\n情况2：$y = -2\\cos(\\frac{\\pi}{18})$\n$$x = \\pm\\sqrt{-2\\cos(\\frac{\\pi}{18}) + 2} = \\pm\\sqrt{2(1 - \\cos(\\frac{\\pi}{18}))}$$\n使用半角恒等式 $1 - \\cos(2\\alpha) = 2\\sin^{2}(\\alpha)$，令 $2\\alpha = \\frac{\\pi}{18}$（因此 $\\alpha = \\frac{\\pi}{36}$）：\n$$x = \\pm\\sqrt{2 \\cdot 2\\sin^{2}(\\frac{\\pi}{36})} = \\pm\\sqrt{4\\sin^{2}(\\frac{\\pi}{36})} = \\pm 2\\sin(\\frac{\\pi}{36})$$\n\n二阶原像的完整集合包含四个值：$\\{2\\cos(\\frac{\\pi}{36}), -2\\cos(\\frac{\\pi}{36}), 2\\sin(\\frac{\\pi}{36}), -2\\sin(\\frac{\\pi}{36})\\}$。为了将它们全部用余弦函数表示，我们使用恒等式 $\\cos(\\pi - \\alpha) = -\\cos(\\alpha)$ 和 $\\sin(\\alpha) = \\cos(\\frac{\\pi}{2} - \\alpha)$：\n- $2\\cos(\\frac{\\pi}{36})$\n- $-2\\cos(\\frac{\\pi}{36}) = 2\\cos(\\pi - \\frac{\\pi}{36}) = 2\\cos(\\frac{35\\pi}{36})$\n- $2\\sin(\\frac{\\pi}{36}) = 2\\cos(\\frac{\\pi}{2} - \\frac{\\pi}{36}) = 2\\cos(\\frac{17\\pi}{36})$\n- $-2\\sin(\\frac{\\pi}{36}) = -2\\cos(\\frac{17\\pi}{36}) = 2\\cos(\\pi - \\frac{17\\pi}{36}) = 2\\cos(\\frac{19\\pi}{36})$\n\n因此，在 $[-2, 2]$ 内的二阶原像集为 $\\{2\\cos(\\frac{\\pi}{36}), 2\\cos(\\frac{17\\pi}{36}), 2\\cos(\\frac{19\\pi}{36}), 2\\cos(\\frac{35\\pi}{36})\\}$。\n\n#### 最终答案计算\n最终任务是提供 $x_{6}$ 的单一值。正如在第1部分中确定的，轨道是前周期的，其中 $x_{0}$ 是一个瞬态，导向 3-周期轨道 $\\{x_{1}, x_{2}, x_{3}\\}$。具体来说，$x_{4}=x_{1}$，$x_{5}=x_{2}$，以及 $x_{6}=x_{3}$。\n$x_{3}$ 的值为：\n$$x_{3} = 2\\cos(\\frac{8\\pi}{9})$$\n因此，$x_{6} = 2\\cos(\\frac{8\\pi}{9})$。\n这即为所要求的精确封闭形式表达式。",
            "answer": "$$\\boxed{2\\cos\\left(\\frac{8\\pi}{9}\\right)}$$"
        },
        {
            "introduction": "现在，我们将从解析方法转向复杂系统研究中更常见的计算方法，因为在这些系统中，解析解往往是不存在的。洛伦兹系统是混沌理论中的一个经典范例。对于这类高维连续系统，一个强大的分析工具是庞加莱映射 (Poincaré map)，它能将动力学过程简化为一个较低维度的离散映射。这项计算练习  将引导学习者完成数值生成轨迹、构建庞加莱截面以及分析所得返回映射的全过程，从而将理论概念与实用的数据分析技能联系起来。",
            "id": "4272789",
            "problem": "考虑三维自治常微分方程（ODE），即洛伦兹系统，其定义在状态空间 $\\mathbb{R}^3$ 上的流为\n$$\n\\dot{x} = \\sigma (y - x), \\quad \\dot{y} = x (\\rho - z) - y, \\quad \\dot{z} = x y - \\beta z,\n$$\n其中 $\\sigma$、$\\rho$ 和 $\\beta$ 是正常数参数，$(x,y,z)$ 是状态向量。庞加莱截面是状态空间中的一个余维为一的曲面，轨迹会横截此曲面，从而可以构建一个庞加莱回归映射，该映射将一个交点映射到其与该截面的下一个交点。目标是为洛伦兹系统设计一个合适的庞加莱截面，并从模拟的轨迹数据中数值估计一个一维（1D）回归映射。\n\n您的任务是：\n1. 提出并使用由平面 $y=0$ 定义的庞加莱截面，并考虑向上方向的穿越（即从 $y0$ 到 $y\\ge 0$）。对于每个交点，通过在连续时间样本之间进行线性插值来近似交点。\n2. 根据下文的测试用例规范，将第 $n$ 个交点处的标量可观测量 $u_n$ 定义为该交点的 $x$ 坐标或 $z$ 坐标。\n3. 通过使用连续的交点形成配对 $(u_n, u_{n+1})$ 来构建经验回归映射，并在指定情况下，在计算统计数据之前丢弃一组初始交点作为瞬态。\n\n从基本原理出发，您的程序必须：\n- 使用固定步长 $\\Delta t$ 的数值方法，从给定的初始条件 $(x_0,y_0,z_0)$ 出发，在总模拟时间 $T$ 内对洛伦兹常微分方程进行积分。\n- 通过监测连续步骤中 $y$ 的符号，检测向上穿越庞加莱截面 $y=0$ 的事件。当发生穿越时，沿两个连续采样状态之间的线段进行线性插值，以近似交点。\n- 从连续的交点形成经验回归映射，并根据下文指定的每个测试用例计算所请求的统计量。\n- 如果在丢弃瞬态后，回归映射对少于两对，或者由于方差为零导致所请求的统计量未定义，则对于请求的浮点统计量返回 $0.0$。如果测试用例请求布尔值或整数，则根据计算出的数据返回逻辑上正确的值。\n\n使用以下测试套件，其中指定了参数和请求的输出：\n\n- 测试用例 1（混沌状态，斜率估计）：\n  - 参数：$\\sigma=10$, $\\rho=28$, $\\beta=8/3$, $T=50$, $\\Delta t=10^{-3}$, $(x_0,y_0,z_0)=(1,1,1)$。\n  - 可观测量：每次向上穿越 $y=0$ 时的 $u_n=x$。\n  - 瞬态丢弃：$N_{\\mathrm{skip}}=100$ 个交点。\n  - 输出：对保留的配对使用普通最小二乘法估计最佳拟合仿射关系 $u_{n+1}\\approx a\\,u_n + b$ 的斜率 $a$。以浮点数形式返回 $a$。\n\n- 测试用例 2（混沌状态，连续交点的相关性）：\n  - 参数：$\\sigma=10$, $\\rho=28$, $\\beta=8/3$, $T=50$, $\\Delta t=10^{-3}$, $(x_0,y_0,z_0)=(1,1,1)$。\n  - 可观测量：每次向上穿越 $y=0$ 时的 $u_n=z$。\n  - 瞬态丢弃：$N_{\\mathrm{skip}}=100$ 个交点。\n  - 输出：计算保留配对中 $u_n$ 和 $u_{n+1}$ 之间的皮尔逊相关系数 $r$。以浮点数形式返回 $r$。\n\n- 测试用例 3（短时间积分，数据充分性检查）：\n  - 参数：$\\sigma=10$, $\\rho=28$, $\\beta=8/3$, $T=2$, $\\Delta t=10^{-3}$, $(x_0,y_0,z_0)=(1,1,1)$。\n  - 可观测量：每次向上穿越 $y=0$ 时的 $u_n=x$。\n  - 瞬态丢弃：$N_{\\mathrm{skip}}=0$ 个交点。\n  - 输出：返回一个布尔值，指示可用的回归映射对的数量是否大于或等于 $5$。\n\n- 测试用例 4（限制叶，带滤波器的斜率估计）：\n  - 参数：$\\sigma=10$, $\\rho=28$, $\\beta=8/3$, $T=50$, $\\Delta t=10^{-3}$, $(x_0,y_0,z_0)=(1,1,1)$。\n  - 可观测量：每次向上穿越 $y=0$ 时的 $u_n=x$，但只保留 $x>0$ 的交点（以限制在吸引子的一个叶上）。\n  - 瞬态丢弃：$N_{\\mathrm{skip}}=100$ 个交点。\n  - 输出：对保留的配对使用普通最小二乘法估计最佳拟合仿射关系 $u_{n+1}\\approx a\\,u_n + b$ 的斜率 $a$。以浮点数形式返回 $a$。\n\n- 测试用例 5（非混沌状态，计数配对）：\n  - 参数：$\\sigma=10$, $\\rho=20$, $\\beta=8/3$, $T=50$, $\\Delta t=10^{-3}$, $(x_0,y_0,z_0)=(1,1,1)$。\n  - 可观测量：每次向上穿越 $y=0$ 时的 $u_n=x$。\n  - 瞬态丢弃：$N_{\\mathrm{skip}}=0$ 个交点。\n  - 输出：返回在整个模拟过程中计算出的可用回归映射对的整数数量。\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含五个测试用例的结果，格式为方括号内以逗号分隔的列表，顺序为测试用例 1 到 5；例如，$[a_1,r_2,b_3,a_4,n_5]$，其中 $a_1$ 和 $a_4$ 是浮点数，$r_2$ 是浮点数，$b_3$ 是布尔值，$n_5$ 是整数。不应打印任何其他文本。",
            "solution": "该问题要求对洛伦兹系统进行数值分析，这是一个展现混沌行为的三维自治动力系统的典型例子。分析将通过从模拟轨迹构建一维庞加莱回归映射来进行。解决方案涉及数值积分、检测与庞加莱截面的交点，以及对生成的交点序列进行统计分析。\n\n系统的状态由向量 $\\mathbf{x}(t) = (x(t), y(t), z(t))^{\\mathsf{T}} \\in \\mathbb{R}^3$ 给出。其演化由洛伦兹方程决定：\n$$\n\\begin{aligned}\n\\dot{x} = \\sigma (y - x) \\\\\n\\dot{y} = x (\\rho - z) - y \\\\\n\\dot{z} = x y - \\beta z\n\\end{aligned}\n$$\n其中 $\\sigma$、$\\rho$ 和 $\\beta$ 是正常实数参数。\n\n解决方案的核心是通过对这些常微分方程（ODE）进行数值积分，生成系统的离散时间轨迹。按照指定，一种标准且稳健的固定步长数值方法是四阶龙格-库塔（RK4）方法。给定在时间 $t_i$ 的状态 $\\mathbf{x}_i$，在时间 $t_{i+1} = t_i + \\Delta t$ 的状态 $\\mathbf{x}_{i+1}$ 按如下方式计算：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\Delta t \\cdot f(\\mathbf{x}_i, t_i) \\\\\n\\mathbf{k}_2 = \\Delta t \\cdot f(\\mathbf{x}_i + \\frac{1}{2}\\mathbf{k}_1, t_i + \\frac{1}{2}\\Delta t) \\\\\n\\mathbf{k}_3 = \\Delta t \\cdot f(\\mathbf{x}_i + \\frac{1}{2}\\mathbf{k}_2, t_i + \\frac{1}{2}\\Delta t) \\\\\n\\mathbf{k}_4 = \\Delta t \\cdot f(\\mathbf{x}_i + \\mathbf{k}_3, t_i + \\Delta t) \\\\\n\\mathbf{x}_{i+1} = \\mathbf{x}_i + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{aligned}\n$$\n其中 $f(\\mathbf{x}, t)$ 代表洛伦兹方程的右侧。此过程在总模拟时间 $T$ 内重复进行。\n\n庞加莱截面定义为平面 $S = \\{ (x, y, z) \\in \\mathbb{R}^3 \\mid y = 0 \\}$。我们关心的是以“向上”方向穿越该截面的轨迹，即从 $y  0$ 的状态到 $y \\ge 0$ 的状态。在从时间 $t_i$ 到 $t_{i+1}$ 的每个积分步骤中，我们检查 $y$ 坐标的符号。如果 $y(t_i)  0$ 且 $y(t_{i+1}) \\ge 0$，则检测到穿越。\n\n当在状态 $\\mathbf{x}_i$ 和 $\\mathbf{x}_{i+1}$ 之间检测到穿越时，使用线性插值来近似平面 $y=0$ 上的交点 $\\mathbf{x}^*$。轨迹与平面相交的小数时间步长 $s \\in [0, 1)$ 通过求解 $y(t_i) + s(y(t_{i+1}) - y(t_i)) = 0$ 来找到 $s$：\n$$\ns = \\frac{-y(t_i)}{y(t_{i+1}) - y(t_i)}\n$$\n然后，交点近似为：\n$$\n\\mathbf{x}^* = \\mathbf{x}_i + s (\\mathbf{x}_{i+1} - \\mathbf{x}_i)\n$$\n根据构造，$\\mathbf{x}^*$ 的 $y$ 坐标为 $0$。\n\n此过程产生一个按时间排序的交点序列 $\\{\\mathbf{x}^*_1, \\mathbf{x}^*_2, \\dots, \\mathbf{x}^*_M\\}$。对于每个测试用例，标量可观测量 $u_n$ 定义为第 $n$ 个交点 $\\mathbf{x}^*_n$ 的 $x$ 坐标或 $z$ 坐标。这将创建一个序列 $\\{u_1, u_2, \\dots, u_M\\}$。\n\n通过形成连续观测值的配对 $(u_n, u_{n+1})$ 来构建经验回归映射。在分析之前，可以丢弃初始数量的交点 $N_{\\mathrm{skip}}$ 以消除瞬态动力学，从而得到一个从 $u_{N_{\\mathrm{skip}}+1}$ 开始的新序列。\n\n然后根据剩余的配对 $(u_n, u_{n+1})$ 计算每个测试用例的具体统计量：\n- **仿射拟合的斜率（用例 1 和 4）：** 对于配对 $(u_n, u_{n+1})$（我们可以表示为 $(x_i, y_i)$），使用普通最小二乘法估计最佳拟合直线 $y \\approx ax+b$ 的斜率 $a$。斜率的公式为：\n$$\na = \\frac{\\text{cov}(u_n, u_{n+1})}{\\text{var}(u_n)} = \\frac{\\sum_{i=1}^{N} (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^{N} (x_i - \\bar{x})^2}\n$$\n其中 $N$ 是配对的数量，$\\bar{x}, \\bar{y}$ 是样本均值。如果 $u_n$ 的方差为零，则斜率未定义，根据问题规范返回 $0.0$。\n\n- **皮尔逊相关系数（用例 2）：** 计算序列 $\\{u_n\\}$ 和 $\\{u_{n+1}\\}$ 之间的皮尔逊相关系数 $r$。其定义为：\n$$\nr = \\frac{\\text{cov}(u_n, u_{n+1})}{\\sigma_{u_n} \\sigma_{u_{n+1}}}\n$$\n其中 $\\sigma$ 表示标准差。如果任一序列的方差为零，则 $r$ 未定义，并返回 $0.0$。\n\n- **数据充分性（用例 3 和 5）：** 这些用例涉及在应用任何指定的过滤器和瞬态丢弃规则后，计算获得的有效回归映射对 $(u_n, u_{n+1})$ 的数量。对于用例 3，返回一个布尔值，指示此计数是否至少为 $5$。对于用例 5，返回整数计数值本身。\n\n为每个测试用例实现了特殊处理，例如在用例 4 中筛选 $x>0$ 的交点。整个过程被封装在一个程序中，该程序遍历指定的测试用例，为每个用例执行模拟和分析，并以所需格式报告结果。如果在任何阶段，数据点的数量不足以形成所需数量的配对（例如，用于斜率/相关性计算的配对少于两对），则返回指定的默认值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    test_cases = [\n        {\n            'case_id': 1, 'params': (10.0, 28.0, 8.0/3.0), 'T': 50.0, 'dt': 1e-3,\n            'ic': (1.0, 1.0, 1.0), 'observable': 'x', 'N_skip': 100,\n            'output_type': 'float'\n        },\n        {\n            'case_id': 2, 'params': (10.0, 28.0, 8.0/3.0), 'T': 50.0, 'dt': 1e-3,\n            'ic': (1.0, 1.0, 1.0), 'observable': 'z', 'N_skip': 100,\n            'output_type': 'float'\n        },\n        {\n            'case_id': 3, 'params': (10.0, 28.0, 8.0/3.0), 'T': 2.0, 'dt': 1e-3,\n            'ic': (1.0, 1.0, 1.0), 'observable': 'x', 'N_skip': 0,\n            'output_type': 'bool'\n        },\n        {\n            'case_id': 4, 'params': (10.0, 28.0, 8.0/3.0), 'T': 50.0, 'dt': 1e-3,\n            'ic': (1.0, 1.0, 1.0), 'observable': 'x', 'N_skip': 100,\n            'output_type': 'float_filtered'\n        },\n        {\n            'case_id': 5, 'params': (10.0, 20.0, 8.0/3.0), 'T': 50.0, 'dt': 1e-3,\n            'ic': (1.0, 1.0, 1.0), 'observable': 'x', 'N_skip': 0,\n            'output_type': 'int'\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation_and_analysis(case)\n        results.append(result)\n    \n    # Format boolean 'True' - 'True' as per standard str() behavior.\n    # If 'true' is required, str(r).lower() would be used.\n    # The problem description is ambiguous; standard str() is the most direct interpretation.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef lorenz_deriv(state, sigma, rho, beta):\n    \"\"\"Computes the derivative of the Lorenz system.\"\"\"\n    x, y, z = state\n    dx_dt = sigma * (y - x)\n    dy_dt = x * (rho - z) - y\n    dz_dt = x * y - beta * z\n    return np.array([dx_dt, dy_dt, dz_dt], dtype=np.float64)\n\ndef run_simulation_and_analysis(case_params):\n    \"\"\"\n    Runs the simulation for a single test case and computes the required statistic.\n    \"\"\"\n    sigma, rho, beta = case_params['params']\n    T, dt = case_params['T'], case_params['dt']\n    x0, y0, z0 = case_params['ic']\n    observable_name = case_params['observable']\n    N_skip = case_params['N_skip']\n    case_id = case_params['case_id']\n    output_type = case_params['output_type']\n\n    # --- Simulation Phase ---\n    state = np.array([x0, y0, z0], dtype=np.float64)\n    num_steps = int(round(T / dt))\n    \n    intersections = []\n    \n    for _ in range(num_steps):\n        state_prev = state\n        y_prev = state[1]\n\n        # 4th-order Runge-Kutta integration step\n        k1 = dt * lorenz_deriv(state, sigma, rho, beta)\n        k2 = dt * lorenz_deriv(state + 0.5 * k1, sigma, rho, beta)\n        k3 = dt * lorenz_deriv(state + 0.5 * k2, sigma, rho, beta)\n        k4 = dt * lorenz_deriv(state + k3, sigma, rho, beta)\n        state = state + (k1 + 2*k2 + 2*k3 + k4) / 6.0\n        y_next = state[1]\n\n        # Upward crossing detection (y0 to y>=0)\n        if y_prev  0.0 and y_next >= 0.0:\n            if y_next == y_prev:\n                s = 1.0\n            else:\n                s = -y_prev / (y_next - y_prev)\n            \n            interp_state = state_prev + s * (state - state_prev)\n            intersections.append(interp_state)\n\n    # --- Analysis Phase ---\n    \n    # Special filter for Case 4\n    if output_type == 'float_filtered':\n        intersections = [p for p in intersections if p[0] > 0.0]\n\n    # Create observable sequence\n    obs_idx = 0 if observable_name == 'x' else 2\n    u_full = np.array([p[obs_idx] for p in intersections])\n\n    # Discard transients\n    if len(u_full) = N_skip:\n        u = np.array([])\n    else:\n        u = u_full[N_skip:]\n    \n    num_pairs = len(u) - 1 if len(u) > 0 else 0\n\n    # Case-specific return values\n    if output_type == 'bool':\n        return num_pairs >= 5\n\n    if output_type == 'int':\n        return num_pairs\n    \n    # For float outputs (slope, correlation)\n    if num_pairs  2:\n        return 0.0\n\n    u_n = u[:-1]\n    u_n_plus_1 = u[1:]\n\n    if output_type in ['float', 'float_filtered']: # Slope calculation\n        var_un = np.var(u_n)\n        if var_un == 0.0:\n            return 0.0\n        \n        # OLS slope a = cov(x,y)/var(x)\n        cov_val = np.cov(u_n, u_n_plus_1, ddof=0)[0, 1]\n        slope = cov_val / var_un\n        return slope\n\n    # This part of the code is for case_id 2 (correlation)\n    # np.corrcoef returns a 2x2 matrix; the correlation is at [0,1]\n    corr = np.corrcoef(u_n, u_n_plus_1)[0, 1]\n    \n    # Return 0.0 if statistic is undefined (e.g., zero variance)\n    return 0.0 if np.isnan(corr) else corr\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}