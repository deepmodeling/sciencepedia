{
    "hands_on_practices": [
        {
            "introduction": "为了真正掌握分辨率极限，我们从一个经典的解析练习开始。通过构建一个简单对称的网络——一个由团块组成的环——我们可以精确地计算当合并相邻社区时模块度的变化。这个基础性问题  让我们能够推导出模块度优化偏好更粗糙分区的确切条件，从而揭示分辨率极限的数学根源。",
            "id": "4311135",
            "problem": "考虑一个如下构造的无向、无权环形网络：取 $r$ 个大小为 $s$ 的团，并将相邻的团用一条边连接起来，形成一个环。假设 $r \\geq 4$ 是偶数且 $s \\geq 3$。令 $m$ 表示网络中边的总数。使用无向、无权网络的标准模块度定义，\n$$\nQ \\;=\\; \\sum_{C} \\left( e_{C} \\;-\\; a_{C}^{2} \\right),\n$$\n其中 $e_{C}$ 是两端均在社群 $C$ 内部的边的比例，而 $a_{C}$ 是连接到社群 $C$ 中节点的边末端的比例，请执行以下操作：\n\n1. 计算 $m$。\n2. 计算将网络划分为 $r$ 个社群时的模块度 $Q_{r}$，其中每个团构成一个独立的社群。\n3. 计算将网络划分为 $r/2$ 个社群时的模块度 $Q_{r/2}$，该划分是通过将相邻的团两两合并得到的（因此每个社群由两个相邻的团以及它们之间的连接边组成）。\n4. 给出以下表达式的闭式解析形式：\n$$\n\\Delta Q(r,s) \\;=\\; Q_{r/2} \\;-\\; Q_{r}.\n$$\n\n不需要进行数值近似或四舍五入。您的最终答案必须是关于 $r$ 和 $s$ 的单个闭式表达式。",
            "solution": "用户要求我分析一个特定网络结构在两种不同社群划分下的模块度。\n\n### 第 1 步：提取已知条件\n- **网络结构**：一个由 $r$ 个团组成的无向、无权环形网络。\n- **团的大小**：每个团的大小为 $s$。\n- **连接方式**：相邻的团通过一条边连接，形成一个环。\n- **参数**：\n    - $r$：团的数量，$r \\geq 4$ 且为偶数。\n    - $s$：每个团的大小，$s \\geq 3$。\n- **模块度定义**：$Q = \\sum_{C} ( e_{C} - a_{C}^{2} )$，其中 $e_{C}$ 是两端均在社群 $C$ 内部的边的比例，而 $a_{C}$ 是连接到社群 $C$ 中节点的边末端的比例。\n- **任务**：\n    1. 计算总边数 $m$。\n    2. 计算划分为 $r$ 个社群（每个团为一个社群）时的模块度 $Q_{r}$。\n    3. 计算划分为 $r/2$ 个社群（相邻的团两两合并）时的模块度 $Q_{r/2}$。\n    4. 计算 $\\Delta Q(r,s) = Q_{r/2} - Q_{r}$。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题基于模块度的标准定义和一个明确定义的网络拓扑（团环），这些都是网络科学中的基本概念。问题背景，即模块度的分辨率极限，是一个公认的研究课题。该问题具有科学合理性。\n- **适定性**：网络结构和社群划分都得到了精确描述。待计算的量定义清晰。对 $r$ 和 $s$ 的约束确保了结构的非平凡性。存在唯一且有意义的解。\n- **客观性**：问题陈述使用了精确的数学和网络科学术语，不含任何主观或有偏见的语言。\n\n### 第 3 步：结论与行动\n该问题是有效的。这是一个网络模块度计算的标准练习。我将继续进行求解。\n\n### 第 1 部分：计算总边数 $m$\n该网络包含两种类型的边：团内部的边和连接团的边。\n一个大小为 $s$ 的完全图（团）中的边数为 $\\binom{s}{2} = \\frac{s(s-1)}{2}$。\n因为有 $r$ 个这样的团，所以所有团内部的总边数为 $r \\times \\frac{s(s-1)}{2}$。\n$r$ 个团排列成一个环，每个团通过一条边与其两个邻居相连。这形成了一个团的环，从而产生 $r$ 条连接边。\n总边数 $m$ 是这两部分数量之和：\n$$\nm = r \\frac{s(s-1)}{2} + r = r \\left( \\frac{s^2-s}{2} + 1 \\right) = \\frac{r}{2}(s^2 - s + 2)\n$$\n\n### 第 2 部分：计算模块度 $Q_r$\n在此划分中，有 $r$ 个社群，每个社群 $C_i$（$i=1, \\dots, r$）是大小为 $s$ 的一个团。由于网络的对称性，所有社群的 $e_{C_i}$ 和 $a_{C_i}$ 值都相同。我们可以对任意一个社群 $C$ 计算这些值，然后求和。\n模块度为 $Q_r = \\sum_{i=1}^{r} (e_{C_i} - a_{C_i}^2) = r(e_C - a_C^2)$。\n\n$e_C$ 是社群 $C$ 内部的边所占的比例。内部边的数量是一个大小为 $s$ 的团中的边数，即 $\\frac{s(s-1)}{2}$。\n$$\ne_C = \\frac{\\text{社群 C 内部的边数}}{m} = \\frac{\\frac{s(s-1)}{2}}{\\frac{r}{2}(s^2-s+2)} = \\frac{s^2-s}{r(s^2-s+2)}\n$$\n\n$a_C$ 是连接到社群 $C$ 中节点的边末端（或称半连接）所占的比例。网络中边末端的总数为 $2m$。连接到 $C$ 中节点的边末端数量是 $C$ 中所有节点的度之和，记为 $k_C$。\n度之和 $k_C$ 可以通过内部边数的两倍加上外部边数来计算。社群 $C$ 与另外两个团相连，因此有 2 条外部边。\n$$\nk_C = 2 \\times (\\text{内部边数}) + (\\text{外部边数}) = 2 \\times \\frac{s(s-1)}{2} + 2 = s^2 - s + 2\n$$\n因此，$a_C$ 为：\n$$\na_C = \\frac{k_C}{2m} = \\frac{s^2-s+2}{2 \\times \\frac{r}{2}(s^2-s+2)} = \\frac{s^2-s+2}{r(s^2-s+2)} = \\frac{1}{r}\n$$\n现在我们可以计算 $Q_r$：\n$$\nQ_r = r(e_C - a_C^2) = r \\left( \\frac{s^2-s}{r(s^2-s+2)} - \\left(\\frac{1}{r}\\right)^2 \\right) = \\frac{s^2-s}{s^2-s+2} - \\frac{r}{r^2} = \\frac{s^2-s}{s^2-s+2} - \\frac{1}{r}\n$$\n\n### 第 3 部分：计算模块度 $Q_{r/2}$\n在此划分中，有 $r/2$ 个社群。每个新社群（我们称之为 $C'$）由一对相邻的团（例如 $C_1$ 和 $C_2$）以及连接它们的单条边合并而成。\n同样，根据对称性，我们可以计算一个这样的社群 $C'$ 的贡献，然后乘以社群数量 $r/2$。\n模块度为 $Q_{r/2} = \\frac{r}{2}(e_{C'} - a_{C'}^2)$。\n\n$e_{C'}$ 是社群 $C'$ 内部的边所占的比例。内部边包括第一个团内部的边、第二个团内部的边，以及连接它们的那一条边。\n$C'$ 内部的边数 = $\\frac{s(s-1)}{2} + \\frac{s(s-1)}{2} + 1 = s(s-1)+1 = s^2-s+1$。\n$$\ne_{C'} = \\frac{s^2-s+1}{m} = \\frac{s^2-s+1}{\\frac{r}{2}(s^2-s+2)} = \\frac{2(s^2-s+1)}{r(s^2-s+2)}\n$$\n\n$a_{C'}$ 是 $C'$ 中边末端所占的比例。一个合并后的社群 $C'$ 由两个原始的团（例如 $C_1$ 和 $C_2$）组成。$C'$ 中的节点集是 $C_1$ 和 $C_2$ 中节点集的不交并。节点的度是图的属性，而不是划分的属性。因此，$C'$ 中节点的度之和等于 $C_1$ 中节点的度之和加上 $C_2$ 中节点的度之和。\n$$\nk_{C'} = k_{C_1} + k_{C_2} = (s^2-s+2) + (s^2-s+2) = 2(s^2-s+2)\n$$\n或者，边末端的总数是 $2 \\times (\\text{内部边数}) + (\\text{外部边数})$。对于 $C'$，有两条外部边（一条来自原来的 $C_1$ 连接到其另一个邻居，另一条来自原来的 $C_2$ 连接到其另一个邻居）。\n$k_{C'} = 2(s^2-s+1) + 2 = 2s^2-2s+4 = 2(s^2-s+2)$。两种方法结果一致。\n因此，$a_{C'}$ 为：\n$$\na_{C'} = \\frac{k_{C'}}{2m} = \\frac{2(s^2-s+2)}{2 \\times \\frac{r}{2}(s^2-s+2)} = \\frac{2(s^2-s+2)}{r(s^2-s+2)} = \\frac{2}{r}\n$$\n现在我们可以计算 $Q_{r/2}$：\n$$\nQ_{r/2} = \\frac{r}{2}(e_{C'} - a_{C'}^2) = \\frac{r}{2} \\left( \\frac{2(s^2-s+1)}{r(s^2-s+2)} - \\left(\\frac{2}{r}\\right)^2 \\right)\n$$\n$$\nQ_{r/2} = \\frac{r}{2} \\frac{2(s^2-s+1)}{r(s^2-s+2)} - \\frac{r}{2} \\frac{4}{r^2} = \\frac{s^2-s+1}{s^2-s+2} - \\frac{2}{r}\n$$\n\n### 第 4 部分：计算差值 $\\Delta Q(r,s)$\n最后，我们计算差值 $\\Delta Q(r,s) = Q_{r/2} - Q_{r}$。\n$$\n\\Delta Q(r,s) = \\left( \\frac{s^2-s+1}{s^2-s+2} - \\frac{2}{r} \\right) - \\left( \\frac{s^2-s}{s^2-s+2} - \\frac{1}{r} \\right)\n$$\n$$\n\\Delta Q(r,s) = \\left( \\frac{s^2-s+1}{s^2-s+2} - \\frac{s^2-s}{s^2-s+2} \\right) + \\left( -\\frac{2}{r} + \\frac{1}{r} \\right)\n$$\n$$\n\\Delta Q(r,s) = \\frac{(s^2-s+1) - (s^2-s)}{s^2-s+2} - \\frac{1}{r}\n$$\n$$\n\\Delta Q(r,s) = \\frac{1}{s^2-s+2} - \\frac{1}{r}\n$$\n\n这个表达式代表了当相邻的团两两合并时模块度的变化。$\\Delta Q$ 的正值表示模块度度量更偏好更粗糙的划分（包含 $r/2$ 个社群），这正是分辨率极限问题的核心。这种情况发生在 $\\frac{1}{s^2-s+2} > \\frac{1}{r}$ 时，即 $r > s^2-s+2$。",
            "answer": "$$\n\\boxed{\\frac{1}{s^2 - s + 2} - \\frac{1}{r}}\n$$"
        },
        {
            "introduction": "在环形模型的基础上，我们现在在一个不同但同样基础的网络结构中探讨分辨率极限：两个定义明确的社区，它们之间具有可调的“耦合”强度。这个思想实验  帮助我们将此现象理解为一种相变，当社区间的连接强度增加到超过一个临界点时，在模块度函数看来，不同的社区会突然合并成一个。",
            "id": "4311076",
            "problem": "考虑一个由两个相同模块组成的无向加权网络，每个模块都是一个包含 $n$ 个节点的全连接团。每条模块内边的权重为 $1$。在模块之间，跨模块的每一对节点都相连（即模块间拓扑是完全二分的），且每条模块间边的权重为可调的 $w \\geq 0$。网络中的总权重是所有边权重之和。假设社群检测是通过最大化标准的加权 Newman–Girvan 模块度（NGM）来执行的。\n\n从基本原理和加权 Newman–Girvan 模块度的定义出发，分析当模块间耦合 $w$ 从 $0$ 开始连续增加时，最优社群结构如何变化，并确定最优模块度最大化划分从两个社群（每个团作为一个社群）过渡到包含所有 $2n$ 个节点的单个合并社群时的精确临界值 $w$。\n\n您的推导必须：\n- 从加权图的模块度定义和给定的网络结构开始，计算两社群划分和单社群划分的模块度。\n- 仅使用图中已声明的属性以及可从中导出的量（总边权重、节点强度和社群级别的聚合量）。\n- 最终结果应为一个关于 $n$ 的临界耦合 $w_c$ 的闭式解析表达式。\n\n请用单一解析表达式表达您的最终答案。不需要数值近似。",
            "solution": "该问题陈述具有科学依据、问题明确、客观，并包含了获得唯一解所需的所有信息。这是网络科学中的一个有效问题，特别地，它探讨了模块度最大化的分辨率极限问题。我们可以开始求解。\n\n对于一个加权无向网络，其 Newman–Girvan 模块度（NGM）由以下表达式给出：\n$$\nQ = \\frac{1}{2m} \\sum_{i,j} \\left[ A_{ij} - \\frac{k_i k_j}{2m} \\right] \\delta(c_i, c_j)\n$$\n其中 $A_{ij}$ 是节点 $i$ 和 $j$ 之间边的权重，$k_i = \\sum_j A_{ij}$ 是节点 $i$ 的强度（加权度），$m = \\frac{1}{2} \\sum_i k_i$ 是网络中所有边的总权重，$c_i$ 是节点 $i$ 所属的社群，当 $c_i = c_j$ 时 $\\delta(c_i, c_j) = 1$，否则为 $0$。\n\n首先，我们对给定的网络结构进行刻画。\n该网络由 $2n$ 个节点组成，分为两个各含 $n$ 个节点的团。\n我们来计算所有边的总权重 $m$。\n在每个团内部，有 $\\binom{n}{2} = \\frac{n(n-1)}{2}$ 条边，每条边的权重为 $1$。这些模块内边的总权重为 $2 \\times \\frac{n(n-1)}{2} = n(n-1)$。\n在两个团之间，有 $n \\times n = n^2$ 条边，每条边的权重为 $w$。这些模块间边的总权重为 $n^2 w$。\n因此，网络中所有边的总权重为：\n$$\nm = n(n-1) + n^2 w\n$$\n接下来，我们确定任意节点 $i$ 的强度 $k_i$。由于网络的对称性，所有节点的强度都相同。考虑其中一个团中的一个节点 $i$。它与自身所在团内的 $n-1$ 个其他节点相连（每条连接权重为 $1$），并与另一个团中的 $n$ 个节点相连（每条连接权重为 $w$）。\n任意节点 $i$ 的强度为：\n$$\nk_i = k = (n-1) \\times 1 + n \\times w = n-1 + nw\n$$\n我们可以用节点强度来验证我们关于 $m$ 的表达式：$2m = \\sum_i k_i = (2n)k = 2n(n-1+nw)$，这得到 $m = n(n-1+nw) = n(n-1) + n^2w$，与我们之前的计算相符。\n\n现在，我们评估两种指定划分的模块度。\n\n**划分1：两个社群 ($P_2$)**\n在这种划分中，每个团构成一个独立的社群。我们称它们为 $C_1$ 和 $C_2$。模块度公式可以表示为对所有社群求和的形式：\n$$\nQ = \\sum_{c} \\left( \\frac{L_c}{m} - \\left(\\frac{K_c}{2m}\\right)^2 \\right)\n$$\n其中 $L_c$ 是完全在社群 $c$ 内部的边的权重之和，$K_c$ 是社群 $c$ 中所有节点强度之和。\n\n对于社群 $C_1$（对 $C_2$ 也完全相同）：\n内部边的权重之和 $L_1$ 是该团的总权重，即 $L_1 = \\binom{n}{2} \\times 1 = \\frac{n(n-1)}{2}$。\n节点强度之和 $K_1$ 是社群中的节点数乘以每个节点的强度：$K_1 = n \\times k = n(n-1+nw)$。\n\n这种两社群划分的总模块度 $Q_2$ 为：\n$$\nQ_2 = \\left( \\frac{L_1}{m} - \\left(\\frac{K_1}{2m}\\right)^2 \\right) + \\left( \\frac{L_2}{m} - \\left(\\frac{K_2}{2m}\\right)^2 \\right)\n$$\n由于 $L_1 = L_2$ 且 $K_1 = K_2$，上式可简化为：\n$$\nQ_2 = 2 \\left( \\frac{L_1}{m} - \\left(\\frac{K_1}{2m}\\right)^2 \\right)\n$$\n我们来计算 $\\frac{K_1}{2m}$ 这一项：\n$$\n\\frac{K_1}{2m} = \\frac{n k}{2nk} = \\frac{1}{2}\n$$\n这个非常简洁的结果适用于任何将网络二分成两个总度数相等的部分的情况。\n将此结果代入 $Q_2$ 的表达式中：\n$$\nQ_2 = 2 \\left( \\frac{n(n-1)/2}{m} - \\left(\\frac{1}{2}\\right)^2 \\right) = \\frac{n(n-1)}{m} - 2 \\left(\\frac{1}{4}\\right) = \\frac{n(n-1)}{m} - \\frac{1}{2}\n$$\n最后，代入 $m$ 的表达式：\n$$\nQ_2(w) = \\frac{n(n-1)}{n(n-1) + n^2 w} - \\frac{1}{2}\n$$\n\n**划分2：单个社群 ($P_1$)**\n在这种划分中，所有 $2n$ 个节点都属于同一个社群。我们使用与上面相同的公式，但求和项只有一个。\n这个单一社群包含了整个网络。\n内部边的权重之和 $L_{total}$ 是网络中所有边的权重之和，即 $m$。\n节点强度之和 $K_{total}$ 是网络中所有节点强度之和，即 $2m$。\n这种单社群划分的模块度 $Q_1$ 为：\n$$\nQ_1 = \\frac{L_{total}}{m} - \\left(\\frac{K_{total}}{2m}\\right)^2 = \\frac{m}{m} - \\left(\\frac{2m}{2m}\\right)^2 = 1 - 1^2 = 0\n$$\n将网络划分为单个社群的模块度始终为零。\n\n**确定临界耦合 $w_c$**\n最优划分是模块度最高的划分。当 $Q_2(w) > Q_1$ 时，两社群结构 ($P_2$) 是更优的。当 $Q_1 > Q_2(w)$ 时，单社群结构 ($P_1$) 是更优的。过渡发生在耦合的临界值 $w_c$ 处，此时两种划分的模块度相等。\n$$\nQ_2(w_c) = Q_1\n$$\n$$\n\\frac{n(n-1)}{n(n-1) + n^2 w_c} - \\frac{1}{2} = 0\n$$\n求解 $w_c$：\n$$\n\\frac{n(n-1)}{n(n-1) + n^2 w_c} = \\frac{1}{2}\n$$\n$$\n2n(n-1) = n(n-1) + n^2 w_c\n$$\n假设 $n > 1$（对于一个非平凡的团），我们可以进行简化。\n$$\nn(n-1) = n^2 w_c\n$$\n两边同除以 $n^2$（假设 $n \\neq 0$）：\n$$\nw_c = \\frac{n(n-1)}{n^2} = \\frac{n-1}{n}\n$$\n这个表达式给出了临界的模块间边权重 $w_c$。对于 $w  w_c$，$Q_2(w) > 0$，使得两社群划分成为最优。对于 $w > w_c$，$Q_2(w)  0$，使得单社群划分（其 $Q_1 = 0$）成为最优。在 $w=w_c$ 时，两种划分的模块度都为 $0$。",
            "answer": "$$\\boxed{\\frac{n-1}{n}}$$"
        },
        {
            "introduction": "我们最后的练习将理论与实践相结合，从理想化的确定性图转向使用随机块模型（Stochastic Block Model, SBM）的随机网络领域。在这个计算任务  中，您将实现一个贪心社区检测算法，并通过测量算法精度如何随着整个网络规模的增加而降低（即使对于分离良好的社区），来观察分辨率极限的实际后果。",
            "id": "4311141",
            "problem": "考虑由等大小的随机分块模型（SBM）生成的无向、无权图，该模型有 $B$ 个块，每个块的大小为 $s$，因此 $N = B s$。设平均度为 $k$，混合参数 $\\mu \\in [0,1]$ 表示一个节点的预期边中超出其自身块的边的比例。对于等大小的块，设定块内连接概率 $p_{\\mathrm{in}}$ 和跨块连接概率 $p_{\\mathrm{out}}$ 以满足预期度约束，可得\n$$\np_{\\mathrm{in}} = \\frac{(1 - \\mu) k}{s - 1}, \\quad p_{\\mathrm{out}} = \\frac{\\mu k}{N - s}.\n$$\n基准划分将每个节点分配到其所在的块。节点集的一个划分 $\\{c_i\\}$ 的模块度 $Q$ 为\n$$\nQ = \\frac{1}{2m} \\sum_{i,j} \\left(A_{ij} - \\frac{k_i k_j}{2m}\\right) \\delta(c_i, c_j),\n$$\n其中 $A_{ij}$ 是邻接矩阵，$k_i$ 是节点 $i$ 的度，$m$ 是总边数。模块度的分辨率限制描述了当总系统规模增加时，即使小社团定义明确，模块度优化仍倾向于合并这些小社团的现象。\n\n任务：实现一个完整的程序，对下面的每个测试用例执行以下步骤：\n- 使用上述概率 $p_{\\mathrm{in}}$ 和 $p_{\\mathrm{out}}$，生成一个具有指定参数 $(N, s, k, \\mu)$ 的 SBM 实现。\n- 将划分初始化为基准块分配。\n- 迭代并贪心地合并能产生最大严格正模块度 $Q$ 增益的社团对，当没有合并能产生正 $Q$ 增益时停止。只允许成对合并。\n- 计算最终检测到的划分与基准划分之间的归一化互信息（NMI），定义为\n$$\n\\mathrm{NMI}(X,Y) = \\frac{2 I(X;Y)}{H(X) + H(Y)},\n$$\n其中互信息为\n$$\nI(X;Y) = \\sum_{x \\in X} \\sum_{y \\in Y} \\frac{n_{xy}}{N} \\log \\left(\\frac{n_{xy} N}{n_x n_y}\\right),\n$$\n熵为\n$$\nH(X) = - \\sum_{x \\in X} \\frac{n_x}{N} \\log \\left(\\frac{n_x}{N}\\right), \\quad H(Y) = - \\sum_{y \\in Y} \\frac{n_y}{N} \\log \\left(\\frac{n_y}{N}\\right),\n$$\n其中 $n_{xy}$ 是在划分 $X$ 中被分配到社团 $x$ 且在划分 $Y$ 中被分配到社团 $y$ 的节点数，$n_x$ 和 $n_y$ 是边际计数。使用自然对数。\n\n参数：\n- 块大小 $s = 16$（所有测试中固定）。\n- 平均度 $k = 12$（所有测试中固定）。\n- 混合参数 $\\mu$ 因测试而异。\n- 总系统大小 $N$ 因测试而异。\n\n测试组：\n1. $(N = 64, \\mu = 0.10)$\n2. $(N = 64, \\mu = 0.40)$\n3. $(N = 160, \\mu = 0.10)$\n4. $(N = 160, \\mu = 0.30)$\n5. $(N = 320, \\mu = 0.10)$\n6. $(N = 320, \\mu = 0.35)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含六个 NMI 值，每个值对应上述顺序的一个测试用例，四舍五入到四位小数，格式为方括号括起来的逗号分隔列表（例如，“[0.9321,0.4810,0.9023,0.7123,0.8532,0.6011]”）。\n\n不涉及物理单位或角度单位。每次测试用例的所有随机数生成必须是确定性的，以确保可复现性。程序必须完全自包含，无需用户输入。",
            "solution": "该问题是有效的。这是一个定义明确的计算任务，基于网络科学中的既定原则，特别是社团检测和模块度分辨率限制的研究。所有参数、公式和步骤都已明确指定，且测试用例在计算上是可行的。\n\n解决方案通过为每个测试用例实现指定的算法来推进。核心步骤是：(1) 从随机分块模型（SBM）生成图，(2) 应用贪婪凝聚算法来优化模块度，以及 (3) 使用归一化互信息（NMI）将所得划分与基准进行评估。\n\n### 1. 随机分块模型（SBM）图生成\n对于每个具有总节点数 $N$、块大小 $s$、平均度 $k$ 和混合参数 $\\mu$ 的测试用例，我们首先推导出必要的模型参数。块的数量为 $B = N/s$。创建两个节点之间边的概率为：\n- $p_{\\mathrm{in}} = \\frac{(1 - \\mu) k}{s - 1}$ 适用于同一块内的两个节点。\n- $p_{\\mathrm{out}} = \\frac{\\mu k}{N - s}$ 适用于不同块中的两个节点。\n\n生成一个具有 $N$ 个节点的无向、无权图实例。基准划分通过将节点 $0, \\dots, s-1$ 分配给块 $0$，节点 $s, \\dots, 2s-1$ 分配给块 $1$，依此类推来定义。通过考虑每一对 $i  j$ 的节点 $(i, j)$ 来构造一个 $N \\times N$ 的邻接矩阵 $A$。如果节点 $i$ 和 $j$ 属于同一块，则以概率 $p_{\\mathrm{in}}$ 创建一条边 $(i, j)$；如果它们属于不同的块，则以概率 $p_{\\mathrm{out}}$ 创建。为按要求确保可复现性，每个测试用例的伪随机数生成器都使用一个唯一的整数作为种子。\n\n### 2. 贪婪模块度优化\n社团检测算法从基准划分开始，其中 $B$ 个块中的每一个都构成一个社团。该过程迭代地合并社团对，以最大化模块度 $Q$ 的增益。\n\n一个划分的模块度由下式给出：\n$$\nQ = \\frac{1}{2m} \\sum_{i,j} \\left(A_{ij} - \\frac{k_i k_j}{2m}\\right) \\delta(c_i, c_j)\n$$\n其中 $m$ 是总边数，$A$ 是邻接矩阵，$k_i$ 是节点 $i$ 的度，$c_i$ 是节点 $i$ 所属的社团。一个等效的、更利于跟踪变化的公式是：\n$$\nQ = \\sum_{c \\in C} \\left( \\frac{L_{c}}{m} - \\left(\\frac{k_C}{2m}\\right)^2 \\right)\n$$\n其中，求和是对社团集合 $C$ 进行的，$L_c$ 是社团 $c$ 内部的边数，$k_C$ 是社团 $c$ 中所有节点的度之和。\n\n当两个不同的社团 $c_i$ 和 $c_j$ 合并时，模块度的变化 $\\Delta Q_{ij}$ 可以高效地计算：\n$$\n\\Delta Q_{ij} = Q_{\\text{merged}} - Q_{\\text{original}} = 2 \\left( \\frac{L_{ij}}{2m} - \\frac{k_{C_i} k_{C_j}}{(2m)^2} \\right)\n$$\n其中 $L_{ij}$ 是社团 $c_i$ 和 $c_j$ 之间的边数，$k_{C_i}$ 是社团 $c_i$ 的总度数，$k_{C_j}$ 是社团 $c_j$ 的总度数。\n\n贪婪算法如下：\n1. 将划分初始化为基准块。\n2. 在每一步中，为每一对可能的不同社团 $(c_i, c_j)$ 计算 $\\Delta Q_{ij}$。\n3. 找到能产生最大正模块度增益 $\\max(\\Delta Q_{ij})$ 的社团对 $(c_i^*, c_j^*)$。\n4. 如果 $\\max(\\Delta Q_{ij}) > 0$，则合并社团 $c_i^*$ 和 $c_j^*$。更新划分和社团级别的属性（总度数和社团间边数）。\n5. 从步骤2开始重复，直到没有任何合并能导致 $Q$ 的严格正增长。\n\n这个过程产生一个最终划分，其社团数量可能少于初始的 $B$ 个块，这展示了分辨率限制。\n\n### 3. 归一化互信息（NMI）\n为了量化最终检测到的划分 $X$与基准划分 $Y$ 的匹配程度，我们计算归一化互信息（NMI）。首先，构建一个列联表（或混淆矩阵），其条目为 $n_{xy}$，其中 $n_{xy}$ 是在划分 $X$ 中属于社团 $x$ 且在划分 $Y$ 中属于社团 $y$ 的节点数。\n\n互信息 $I(X;Y)$ 计算如下：\n$$\nI(X;Y) = \\sum_{x \\in X} \\sum_{y \\in Y} \\frac{n_{xy}}{N} \\log \\left(\\frac{n_{xy} N}{n_x n_y}\\right)\n$$\n其中 $n_x = \\sum_y n_{xy}$ 和 $n_y = \\sum_x n_{xy}$ 是边际计数（社团大小），并使用自然对数。$n_{xy}=0$ 的项被视为零。\n\n划分的熵为：\n$$\nH(X) = - \\sum_{x \\in X} \\frac{n_x}{N} \\log \\left(\\frac{n_x}{N}\\right)\n$$\n$$\nH(Y) = - \\sum_{y \\in Y} \\frac{n_y}{N} \\log \\left(\\frac{n_y}{N}\\right)\n$$\n\n最后，NMI 由下式给出：\n$$\n\\mathrm{NMI}(X,Y) = \\frac{2 I(X;Y)}{H(X) + H(Y)}\n$$\nNMI为 $1$ 表示划分之间完全一致，而 NMI 为 $0$ 表示一致性不超过随机预期的水平。即使在低 $\\mu$ 值下，对于较大的 N，较低的 NMI 值也将说明分辨率限制。\n\n### 4. 实现细节\n整个过程被封装在一个程序中，该程序遍历六个提供的测试用例。对于每个用例，它确定性地生成图，运行贪婪合并算法，计算所得划分的 NMI，并存储该值。最终输出是这些 NMI 值的列表，四舍五入到四位小数。",
            "answer": "```python\nimport numpy as np\n\ndef generate_sbm(N, s, k, mu, seed):\n    \"\"\"\n    Generates an undirected, unweighted SBM graph.\n\n    Args:\n        N (int): Total number of nodes.\n        s (int): Size of each block.\n        k (float): Average degree.\n        mu (float): Mixing parameter.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: Adjacency matrix of the graph.\n            - np.ndarray: Ground truth partition array.\n    \"\"\"\n    if N % s != 0:\n        raise ValueError(\"N must be a multiple of s.\")\n    B = N // s\n    \n    if s == 1:\n        p_in = 0  # No self-loops, so probability of in-block edge is 0\n    else:\n        p_in = (1 - mu) * k / (s - 1)\n    \n    if N == s:\n        p_out = 0 # No other blocks to connect to\n    else:\n        p_out = mu * k / (N - s)\n\n    if p_in  1 or p_out  1:\n        # This check is for robustness, though problem parameters are safe.\n        raise ValueError(f\"Probabilities must be = 1. Got p_in={p_in}, p_out={p_out}\")\n\n    adj = np.zeros((N, N), dtype=np.int8)\n    ground_truth = np.repeat(np.arange(B), s)\n    rng = np.random.default_rng(seed)\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            prob = p_in if ground_truth[i] == ground_truth[j] else p_out\n            if rng.random()  prob:\n                adj[i, j] = 1\n                adj[j, i] = 1\n                \n    return adj, ground_truth\n\ndef calculate_nmi(p_true, p_pred, N):\n    \"\"\"\n    Calculates the Normalized Mutual Information (NMI) between two partitions.\n    \n    Args:\n        p_true (np.ndarray): The ground truth partition labels.\n        p_pred (np.ndarray): The predicted partition labels.\n        N (int): Total number of nodes.\n\n    Returns:\n        float: The NMI value.\n    \"\"\"\n    # Create unique labels for communities\n    true_labels = np.unique(p_true)\n    pred_labels = np.unique(p_pred)\n    \n    true_map = {label: i for i, label in enumerate(true_labels)}\n    pred_map = {label: i for i, label in enumerate(pred_labels)}\n\n    # Contingency table\n    contingency = np.zeros((len(true_labels), len(pred_labels)))\n    for i in range(N):\n        contingency[true_map[p_true[i]], pred_map[p_pred[i]]] += 1\n\n    # Marginals\n    n_x = np.sum(contingency, axis=0) # Sum over rows for pred communities\n    n_y = np.sum(contingency, axis=1) # Sum over columns for true communities\n    \n    # Mutual Information I(X; Y)\n    I_xy = 0\n    for i in range(len(true_labels)):\n        for j in range(len(pred_labels)):\n            if contingency[i, j]  0:\n                n_ij = contingency[i,j]\n                I_xy += (n_ij / N) * np.log((n_ij * N) / (n_y[i] * n_x[j]))\n    \n    # Entropy H(X) and H(Y)\n    H_x = 0\n    for val in n_x:\n        if val  0:\n            H_x -= (val / N) * np.log(val / N)\n            \n    H_y = 0\n    for val in n_y:\n        if val  0:\n            H_y -= (val / N) * np.log(val / N)\n            \n    # NMI\n    if (H_x + H_y) == 0:\n        return 1.0 if np.array_equal(p_true, p_pred) else 0.0\n    \n    return 2 * I_xy / (H_x + H_y)\n\ndef run_single_case(N, s, k, mu, seed):\n    \"\"\"\n    Runs the full simulation for a single test case.\n    \"\"\"\n    adj, ground_truth = generate_sbm(N, s, k, mu, seed)\n    \n    num_edges = np.sum(adj) / 2\n    if num_edges == 0: # Handle disconnected graph case\n        return calculate_nmi(ground_truth, np.arange(N), N)\n\n    total_degree_2m = 2 * num_edges\n    \n    node_degrees = np.sum(adj, axis=1)\n    \n    # --- Greedy merging algorithm ---\n    \n    # Initial partition is the ground truth\n    current_partition = ground_truth.copy()\n    comm_ids = list(np.unique(current_partition))\n    num_comms = len(comm_ids)\n\n    # Use dictionaries for flexible community management\n    id_map = {cid: i for i, cid in enumerate(comm_ids)}\n    \n    while True:\n        # Re-evaluate community properties at each step for simplicity\n        # For larger problems, an update mechanism would be more efficient\n        \n        # Calculate community degrees and inter-community edges\n        k_comm = {cid: 0 for cid in comm_ids}\n        for i in range(N):\n            k_comm[current_partition[i]] += node_degrees[i]\n            \n        L_inter = np.zeros((num_comms, num_comms))\n        comm_nodes = {cid: np.where(current_partition == cid)[0] for cid in comm_ids}\n\n        for i in range(num_comms):\n            for j in range(i + 1, num_comms):\n                cid1 = comm_ids[i]\n                cid2 = comm_ids[j]\n                nodes1 = comm_nodes[cid1]\n                nodes2 = comm_nodes[cid2]\n                \n                # Number of edges between the two communities\n                edges_between = np.sum(adj[np.ix_(nodes1, nodes2)])\n                L_inter[i, j] = edges_between\n\n        # Find best merge\n        max_delta_q = -1.0\n        best_pair = None\n        \n        for i in range(num_comms):\n            for j in range(i + 1, num_comms):\n                cid1, cid2 = comm_ids[i], comm_ids[j]\n                \n                L_ij = L_inter[i, j]\n                k_C_i = k_comm[cid1]\n                k_C_j = k_comm[cid2]\n                \n                delta_q = 2 * ( (L_ij / total_degree_2m) - (k_C_i * k_C_j) / (total_degree_2m**2) )\n\n                if delta_q  max_delta_q:\n                    max_delta_q = delta_q\n                    best_pair = (cid1, cid2)\n\n        if max_delta_q  0:\n            # Perform merge\n            c_absorb, c_merge_into = min(best_pair), max(best_pair)\n            \n            # Update partition array\n            current_partition[current_partition == c_merge_into] = c_absorb\n            \n            # Update community list\n            comm_ids.remove(c_merge_into)\n            num_comms = len(comm_ids)\n        else:\n            # No positive Q increase, stop\n            break\n\n    # Calculate NMI of final partition\n    nmi_result = calculate_nmi(ground_truth, current_partition, N)\n    return nmi_result\n    \ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Fixed parameters\n    s_fixed = 16\n    k_fixed = 12\n\n    # Test suite: (N, mu)\n    test_cases = [\n        (64, 0.10),\n        (64, 0.40),\n        (160, 0.10),\n        (160, 0.30),\n        (320, 0.10),\n        (320, 0.35),\n    ]\n\n    results = []\n    for i, (N_val, mu_val) in enumerate(test_cases):\n        # Use test case index as seed for reproducibility\n        seed = i\n        nmi = run_single_case(N_val, s_fixed, k_fixed, mu_val, seed)\n        results.append(f\"{nmi:.4f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}