{
    "hands_on_practices": [
        {
            "introduction": "理解模块度分辨率极限最经典的方法之一是分析“团环”网络模型。这个练习将引导您通过分析计算来揭示该极限的内在机制。您将为两种不同的社群划分方案计算模块度：一种是将每个团视为独立的社群，另一 strana是将相邻的团两两合并。通过推导模块度变化量 $\\Delta Q$ 的精确表达式 ，您将亲眼看到网络的全局规模（由团的数量 $r$ 体现）如何能够压倒局部结构，迫使算法合并定义明确的社群，这正是分辨率极限的核心所在。",
            "id": "4311135",
            "problem": "考虑一个无向、无权的环形网络，其构造如下：取 $r$ 个大小为 $s$ 的团，并将连续的团用单条边连接起来形成一个环。假设 $r \\geq 4$ 且为偶数，且 $s \\geq 3$。令 $m$ 表示网络中的总边数。使用无向、无权网络的模块度标准定义，\n$$\nQ = \\sum_{C} \\left( e_{C} - a_{C}^{2} \\right),\n$$\n其中 $e_{C}$ 是两端均在社区 $C$ 内部的边的分数，而 $a_{C}$ 是连接到社区 $C$ 中节点的边端点的分数，请执行以下操作：\n\n1. 计算 $m$。\n2. 计算划分为 $r$ 个社区（其中每个团构成其自身的社区）时的模块度 $Q_{r}$。\n3. 计算划分为 $r/2$ 个社区时的模块度 $Q_{r/2}$，该划分通过将相邻的团两两合并得到（因此每个社区由两个相邻的团以及它们之间的边组成）。\n4. 给出以下表达式的闭式解析形式：\n$$\n\\Delta Q(r,s) = Q_{r/2} - Q_{r}.\n$$\n\n不需要进行数值近似或四舍五入。最终答案必须是关于 $r$ 和 $s$ 的单个闭式表达式。",
            "solution": "用户希望我分析一个特定网络结构在两种不同社区划分下的模块度。\n\n### 步骤 1：提取已知条件\n- **网络结构**：由 $r$ 个团构成的无向、无权环形网络。\n- **团的大小**：每个团的大小为 $s$。\n- **连接方式**：连续的团由单条边连接形成一个环。\n- **参数**：\n    - $r$：团的数量，$r \\geq 4$ 且为偶数。\n    - $s$：每个团的大小，$s \\geq 3$。\n- **模块度定义**：$Q = \\sum_{C} ( e_{C} - a_{C}^{2} )$，其中 $e_{C}$ 是两端均在社区 $C$ 内的边的分数，而 $a_{C}$ 是连接到社区 $C$ 中节点的边端点的分数。\n- **任务**：\n    1. 计算总边数 $m$。\n    2. 计算划分为 $r$ 个社区（每个团是一个社区）时的模块度 $Q_{r}$。\n    3. 计算划分为 $r/2$ 个社区（相邻的团两两合并）时的模块度 $Q_{r/2}$。\n    4. 计算 $\\Delta Q(r,s) = Q_{r/2} - Q_{r}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于模块度的标准定义和一个明确定义的网络拓扑（团环），这些都是网络科学中的基本概念。问题背景，即模块度的分辨率极限，是一个公认的研究课题。该问题在科学上是合理的。\n- **良构性**：网络结构和社区划分都得到了精确描述。待计算的量定义清晰。对 $r$ 和 $s$ 的约束确保了结构的非平凡性。存在唯一且有意义的解。\n- **客观性**：问题陈述使用了精确的数学和网络科学术语，没有任何主观或偏见的语言。\n\n### 步骤 3：结论与行动\n问题有效。这是一个网络模块度计算的标准练习。我将继续进行求解。\n\n### 第 1 部分：计算总边数 $m$\n该网络包含两种类型的边：团内部的边和连接团之间的边。\n一个大小为 $s$ 的完全图（团）中的边数由 $\\binom{s}{2} = \\frac{s(s-1)}{2}$ 给出。\n由于有 $r$ 个这样的团，所有团内部的总边数为 $r \\times \\frac{s(s-1)}{2}$。\n这 $r$ 个团排列成一个环，每个团通过一条边连接到它的两个邻居。这形成了一个团的环路，从而产生 $r$ 条连接边。\n总边数 $m$ 是这两部分数量之和：\n$$\nm = r \\frac{s(s-1)}{2} + r = r \\left( \\frac{s^2-s}{2} + 1 \\right) = \\frac{r}{2}(s^2 - s + 2)\n$$\n\n### 第 2 部分：计算模块度 $Q_r$\n在这种划分中，有 $r$ 个社区，每个社区 $C_i$（其中 $i=1, \\dots, r$）是大小为 $s$ 的一个团。由于网络的对称性，所有社区的 $e_{C_i}$ 和 $a_{C_i}$ 的值都将相同。我们可以计算任意一个社区 $C$ 的值，然后求和。\n模块度为 $Q_r = \\sum_{i=1}^{r} (e_{C_i} - a_{C_i}^2) = r(e_C - a_C^2)$。\n\n$e_C$ 是社区 $C$ 内部的边所占的分数。内部边的数量是一个大小为 $s$ 的团中的边数，即 $\\frac{s(s-1)}{2}$。\n$$\ne_C = \\frac{\\text{edges within } C}{m} = \\frac{\\frac{s(s-1)}{2}}{\\frac{r}{2}(s^2-s+2)} = \\frac{s^2-s}{r(s^2-s+2)}\n$$\n\n$a_C$ 是连接到社区 $C$ 中节点的边端点（或半连接）的分数。网络中边端点的总数为 $2m$。连接到 $C$ 中节点的边端点数量是 $C$ 中所有节点度数之和，记为 $k_C$。\n度数之和 $k_C$ 可以通过两倍的内部边数加上外部边数来计算。社区 $C$ 连接到另外两个团，所以它有 2 条外部边。\n$$\nk_C = 2 \\times (\\text{internal edges}) + (\\text{external edges}) = 2 \\times \\frac{s(s-1)}{2} + 2 = s^2 - s + 2\n$$\n所以，$a_C$ 是：\n$$\na_C = \\frac{k_C}{2m} = \\frac{s^2-s+2}{2 \\times \\frac{r}{2}(s^2-s+2)} = \\frac{s^2-s+2}{r(s^2-s+2)} = \\frac{1}{r}\n$$\n现在我们可以计算 $Q_r$：\n$$\nQ_r = r(e_C - a_C^2) = r \\left( \\frac{s^2-s}{r(s^2-s+2)} - \\left(\\frac{1}{r}\\right)^2 \\right) = \\frac{s^2-s}{s^2-s+2} - \\frac{r}{r^2} = \\frac{s^2-s}{s^2-s+2} - \\frac{1}{r}\n$$\n\n### 第 3 部分：计算模块度 $Q_{r/2}$\n在这种划分中，我们有 $r/2$ 个社区。每个新社区（我们称之为 $C'$）由一对相邻的团（例如 $C_1$ 和 $C_2$）以及连接它们的单条边合并而成。\n同样，根据对称性，我们可以计算一个这样的社区 $C'$ 的贡献，然后乘以社区数量 $r/2$。\n模块度为 $Q_{r/2} = \\frac{r}{2}(e_{C'} - a_{C'}^2)$。\n\n$e_{C'}$ 是社区 $C'$ 内部的边所占的分数。内部边是第一个团内部的边、第二个团内部的边以及连接它们的单条边。\n$C'$ 中的内部边数 = $\\frac{s(s-1)}{2} + \\frac{s(s-1)}{2} + 1 = s(s-1)+1 = s^2-s+1$。\n$$\ne_{C'} = \\frac{s^2-s+1}{m} = \\frac{s^2-s+1}{\\frac{r}{2}(s^2-s+2)} = \\frac{2(s^2-s+1)}{r(s^2-s+2)}\n$$\n\n$a_{C'}$ 是 $C'$ 中边端点的分数。一个合并后的社区 $C'$ 由两个原始团组成，比如说 $C_1$ 和 $C_2$。$C'$ 中的节点集是 $C_1$ 和 $C_2$ 中节点的不相交并集。节点的度数是图的属性，而不是划分的属性。因此，$C'$ 中节点的度数之和是 $C_1$ 中节点的度数之和加上 $C_2$ 中节点的度数之和。\n$$\nk_{C'} = k_{C_1} + k_{C_2} = (s^2-s+2) + (s^2-s+2) = 2(s^2-s+2)\n$$\n或者，边端点之和为 $2 \\times (\\text{内部边数}) + (\\text{外部边数})$。对于 $C'$，有两条外部边（一条从前 $C_1$ 到其另一个邻居，一条从前 $C_2$ 到其另一个邻居）。\n$k_{C'} = 2(s^2-s+1) + 2 = 2s^2-2s+4 = 2(s^2-s+2)$。两种方法结果一致。\n所以，$a_{C'}$ 是：\n$$\na_{C'} = \\frac{k_{C'}}{2m} = \\frac{2(s^2-s+2)}{2 \\times \\frac{r}{2}(s^2-s+2)} = \\frac{2(s^2-s+2)}{r(s^2-s+2)} = \\frac{2}{r}\n$$\n现在我们可以计算 $Q_{r/2}$：\n$$\nQ_{r/2} = \\frac{r}{2}(e_{C'} - a_{C'}^2) = \\frac{r}{2} \\left( \\frac{2(s^2-s+1)}{r(s^2-s+2)} - \\left(\\frac{2}{r}\\right)^2 \\right)\n$$\n$$\nQ_{r/2} = \\frac{r}{2} \\frac{2(s^2-s+1)}{r(s^2-s+2)} - \\frac{r}{2} \\frac{4}{r^2} = \\frac{s^2-s+1}{s^2-s+2} - \\frac{2}{r}\n$$\n\n### 第 4 部分：计算差值 $\\Delta Q(r,s)$\n最后，我们计算差值 $\\Delta Q(r,s) = Q_{r/2} - Q_{r}$。\n$$\n\\Delta Q(r,s) = \\left( \\frac{s^2-s+1}{s^2-s+2} - \\frac{2}{r} \\right) - \\left( \\frac{s^2-s}{s^2-s+2} - \\frac{1}{r} \\right)\n$$\n$$\n\\Delta Q(r,s) = \\left( \\frac{s^2-s+1}{s^2-s+2} - \\frac{s^2-s}{s^2-s+2} \\right) + \\left( -\\frac{2}{r} + \\frac{1}{r} \\right)\n$$\n$$\n\\Delta Q(r,s) = \\frac{(s^2-s+1) - (s^2-s)}{s^2-s+2} - \\frac{1}{r}\n$$\n$$\n\\Delta Q(r,s) = \\frac{1}{s^2-s+2} - \\frac{1}{r}\n$$\n\n这个表达式表示当相邻的团对合并时模块度的变化。$\\Delta Q$ 的正值表示模块度度量更偏好更粗粒度的划分（即包含 $r/2$ 个社区的划分），这正是分辨率极限问题的核心所在。这种情况发生在 $\\frac{1}{s^2-s+2} > \\frac{1}{r}$ 时，即 $r > s^2-s+2$。",
            "answer": "$$\n\\boxed{\\frac{1}{s^2 - s + 2} - \\frac{1}{r}}\n$$"
        },
        {
            "introduction": "为了证明分辨率极限并非仅存在于特定网络拓扑（如稀疏连接的团环）中，本练习将考察一个不同的场景：两个内部完全连接的团，它们之间通过权重为 $w$ 的边密集连接。您的任务是确定一个临界耦合权重 $w_c$，当超过此值时，模块度优化将倾向于将这两个明显分离的团合并成一个社群。这个练习  的结果异常简洁明了，它有力地说明了即使社群间的连接远弱于社群内部的连接，模块度最大化仍可能无法正确识别它们，从而加深您对分辨率极限普适性的理解。",
            "id": "4311076",
            "problem": "考虑一个无向加权网络，该网络由两个相同的模块组成，每个模块都是一个包含 $n$ 个节点的全连接团（clique）。每个模块内部的边的权重均为 $1$。模块之间，任意一对跨模块的节点都相互连接（即，模块间的拓扑结构是完全二分图），且每条模块间边的权重均为可调的 $w \\geq 0$。网络中的总权重是所有边权重之和。假设社群检测是通过最大化标准的加权纽曼-吉文模块度（NGM）来执行的。\n\n从第一性原理和加权纽曼-吉文模块度的定义出发，分析当模块间耦合强度 $w$ 从 $0$ 开始连续增加时，最优社群结构如何变化，并确定最优模块度划分从两个社群（每个团簇各自为一个社群）过渡到包含所有 $2n$ 个节点的单个合并社群时的精确临界值 $w$。\n\n你的推导必须：\n- 从加权图的模块度定义和给定的网络结构开始，计算两社群划分和单社群划分的模块度。\n- 仅使用图中已声明的属性以及可由它们导出的量（总边权、节点强度和社群级别的聚合量）。\n- 以 $n$ 的函数形式，给出一个关于临界耦合强度 $w_c$ 的封闭解析表达式作为最终结果。\n\n将你的最终答案表示为单个解析表达式。不需要数值近似。",
            "solution": "该问题陈述具有科学依据，表述清晰，客观，并包含了获得唯一解所需的所有信息。这是网络科学中的一个有效问题，具体涉及模块度最大化的分辨率极限问题。我们可以开始求解。\n\n对于一个加权无向网络，纽曼-吉文模块度（NGM）由以下表达式给出：\n$$\nQ = \\frac{1}{2m} \\sum_{i,j} \\left[ A_{ij} - \\frac{k_i k_j}{2m} \\right] \\delta(c_i, c_j)\n$$\n其中 $A_{ij}$ 是节点 $i$ 和 $j$ 之间边的权重，$k_i = \\sum_j A_{ij}$ 是节点 $i$ 的强度（加权度），$m = \\frac{1}{2} \\sum_i k_i$ 是网络中所有边的总权重，$c_i$ 是节点 $i$ 所属的社群，当 $c_i = c_j$ 时 $\\delta(c_i, c_j) = 1$，否则为 $0$。\n\n首先，我们描述给定的网络结构。\n该网络包含 $2n$ 个节点，分为两个各含 $n$ 个节点的团簇。\n我们来计算边的总权重 $m$。\n在每个团簇内部，有 $\\binom{n}{2} = \\frac{n(n-1)}{2}$ 条边，每条边的权重为 $1$。这些模块内部边的总权重为 $2 \\times \\frac{n(n-1)}{2} = n(n-1)$。\n在两个团簇之间，有 $n \\times n = n^2$ 条边，每条边的权重为 $w$。这些模块间边的总权重为 $n^2 w$。\n因此，网络中所有边的总权重为：\n$$\nm = n(n-1) + n^2 w\n$$\n接下来，我们确定任意节点 $i$ 的强度 $k_i$。由于网络的对称性，所有节点的强度都相同。考虑某个团簇中的一个节点 $i$。它与自身团簇内的其他 $n-1$ 个节点相连（每条连接的权重为 $1$），并与另一个团簇中的 $n$ 个节点相连（每条连接的权重为 $w$）。\n任何节点 $i$ 的强度为：\n$$\nk_i = k = (n-1) \\times 1 + n \\times w = n-1 + nw\n$$\n我们可以用节点强度来验证我们关于 $m$ 的表达式：$2m = \\sum_i k_i = (2n)k = 2n(n-1+nw)$，这给出 $m = n(n-1+nw) = n(n-1) + n^2w$，与我们之前的计算相符。\n\n现在，我们为两种指定的划分计算模块度。\n\n**划分1：两个社群 ($P_2$)**\n在这种划分中，每个团簇构成一个独立的社群。我们称它们为 $C_1$ 和 $C_2$。模块度公式可以表示为对所有社群求和的形式：\n$$\nQ = \\sum_{c} \\left( \\frac{L_c}{m} - \\left(\\frac{K_c}{2m}\\right)^2 \\right)\n$$\n其中 $L_c$ 是完全在社群 $c$ 内部的边的权重之和，$K_c$ 是社群 $c$ 中所有节点的强度之和。\n\n对于社群 $C_1$（对 $C_2$ 也完全相同）：\n内部边的权重之和 $L_1$ 是该团簇的总权重，即 $L_1 = \\binom{n}{2} \\times 1 = \\frac{n(n-1)}{2}$。\n节点强度之和 $K_1$ 是社群中的节点数乘以每个节点的强度：$K_1 = n \\times k = n(n-1+nw)$。\n\n这个两社群划分的总模块度 $Q_2$ 是：\n$$\nQ_2 = \\left( \\frac{L_1}{m} - \\left(\\frac{K_1}{2m}\\right)^2 \\right) + \\left( \\frac{L_2}{m} - \\left(\\frac{K_2}{2m}\\right)^2 \\right)\n$$\n由于 $L_1 = L_2$ 且 $K_1 = K_2$，上式可简化为：\n$$\nQ_2 = 2 \\left( \\frac{L_1}{m} - \\left(\\frac{K_1}{2m}\\right)^2 \\right)\n$$\n我们来计算 $\\frac{K_1}{2m}$ 这一项：\n$$\n\\frac{K_1}{2m} = \\frac{n k}{2m} = \\frac{1}{2}\n$$\n这个非常简洁的结果适用于任何将网络二分成两个总度数相等的部分的划分。\n将此结果代入 $Q_2$ 的表达式中：\n$$\nQ_2 = 2 \\left( \\frac{n(n-1)/2}{m} - \\left(\\frac{1}{2}\\right)^2 \\right) = \\frac{n(n-1)}{m} - 2 \\left(\\frac{1}{4}\\right) = \\frac{n(n-1)}{m} - \\frac{1}{2}\n$$\n最后，代入 $m$ 的表达式：\n$$\nQ_2(w) = \\frac{n(n-1)}{n(n-1) + n^2 w} - \\frac{1}{2}\n$$\n\n**划分2：单个社群 ($P_1$)**\n在这种划分中，所有 $2n$ 个节点都属于同一个社群。我们使用与上面相同的公式，但求和项只有一个。\n这个单独的社群包含了整个网络。\n内部边的权重之和 $L_{total}$ 是网络中所有边的权重之和，即 $m$。\n节点强度之和 $K_{total}$ 是网络中所有节点强度之和，即 $2m$。\n这个单社群划分的模块度 $Q_1$ 是：\n$$\nQ_1 = \\frac{L_{total}}{m} - \\left(\\frac{K_{total}}{2m}\\right)^2 = \\frac{m}{m} - \\left(\\frac{2m}{2m}\\right)^2 = 1 - 1^2 = 0\n$$\n将网络划分为单个社群的模块度始终为零。\n\n**确定临界耦合强度 $w_c$**\n最优划分是模块度最高的划分。当 $Q_2(w) > Q_1$ 时，两社群结构（$P_2$）更优。当 $Q_1 > Q_2(w)$ 时，单社群结构（$P_1$）更优。当模块度值相等时，发生相变，此时对应的耦合强度即为临界值 $w_c$。\n$$\nQ_2(w_c) = Q_1\n$$\n$$\n\\frac{n(n-1)}{n(n-1) + n^2 w_c} - \\frac{1}{2} = 0\n$$\n求解 $w_c$：\n$$\n\\frac{n(n-1)}{n(n-1) + n^2 w_c} = \\frac{1}{2}\n$$\n$$\n2n(n-1) = n(n-1) + n^2 w_c\n$$\n假设 $n > 1$（对于一个非平凡的团簇），我们可以进行简化。\n$$\nn(n-1) = n^2 w_c\n$$\n两边同时除以 $n^2$（假设 $n \\neq 0$）：\n$$\nw_c = \\frac{n(n-1)}{n^2} = \\frac{n-1}{n}\n$$\n这个表达式给出了临界的模块间边权重 $w_c$。当 $w  w_c$ 时，$Q_2(w) > 0$，两社群划分是最优的。当 $w > w_c$ 时，$Q_2(w)  0$，单社群划分（其模块度 $Q_1 = 0$）是最优的。在 $w=w_c$ 时，两种划分的模块度都为 $0$。",
            "answer": "$$\\boxed{\\frac{n-1}{n}}$$"
        },
        {
            "introduction": "在理论分析之后，这个实践练习将带您进入一个更接近真实世界研究的计算领域。您将使用随机块模型（Stochastic Block Model, SBM）——一个用于生成带社群结构网络的标准模型——来生成图。您的任务是实现一个贪心合并算法来优化模块度，并使用归一化互信息（Normalized Mutual Information, NMI）来评估检测到的社群与“真实”社群之间的一致性。通过这个编码练习 ，您将能够通过模拟观察到分辨率极限的统计效应：即便是当社区的“质量”（由混合参数 $\\mu$ 控制）保持不变时，社群检测的准确性也会随着网络总规模的增大而下降。",
            "id": "4311141",
            "problem": "考虑由等大小的随机块模型 (SBM) 生成的无向、无权图，该模型有 $B$ 个块，每个块的大小为 $s$，因此 $N = B s$。设平均度为 $k$，混合参数 $\\mu \\in [0,1]$ 表示一个节点的期望边中，超出其自身块的边所占的比例。对于等大小的块，设置块内连接概率 $p_{\\mathrm{in}}$ 和跨块连接概率 $p_{\\mathrm{out}}$ 以满足期望度约束，可得\n$$\np_{\\mathrm{in}} = \\frac{(1 - \\mu) k}{s - 1}, \\quad p_{\\mathrm{out}} = \\frac{\\mu k}{N - s}.\n$$\n基准划分将每个节点分配到其所在的块。节点集的一个划分 $\\{c_i\\}$ 的模块度 $Q$ 为\n$$\nQ = \\frac{1}{2m} \\sum_{i,j} \\left(A_{ij} - \\frac{k_i k_j}{2m}\\right) \\delta(c_i, c_j),\n$$\n其中 $A_{ij}$ 是邻接矩阵，$k_i$ 是节点 $i$ 的度，$m$ 是总边数。模块度的分辨率极限描述了当总系统规模增加时，即使小社区定义明确，模块度优化也倾向于合并这些小社区的趋势。\n\n任务：实现一个完整的程序，对下面的每个测试用例执行以下步骤：\n- 使用上述概率 $p_{\\mathrm{in}}$ 和 $p_{\\mathrm{out}}$，根据指定的参数 $(N, s, k, \\mu)$ 生成一个 SBM 实现。\n- 将划分初始化为基准块分配。\n- 迭代地、贪婪地合并能产生模块度 $Q$ 最大严格正增量的那对社区，当没有合并能产生正的 $Q$ 增量时停止。只允许成对合并。\n- 计算最终检测到的划分与基准划分之间的标准化互信息 (NMI)，定义为\n$$\n\\mathrm{NMI}(X,Y) = \\frac{2 I(X;Y)}{H(X) + H(Y)},\n$$\n其中互信息为\n$$\nI(X;Y) = \\sum_{x \\in X} \\sum_{y \\in Y} \\frac{n_{xy}}{N} \\log \\left(\\frac{n_{xy} N}{n_x n_y}\\right),\n$$\n熵为\n$$\nH(X) = - \\sum_{x \\in X} \\frac{n_x}{N} \\log \\left(\\frac{n_x}{N}\\right), \\quad H(Y) = - \\sum_{y \\in Y} \\frac{n_y}{N} \\log \\left(\\frac{n_y}{N}\\right),\n$$\n其中 $n_{xy}$ 是在划分 $X$ 中分配给社区 $x$ 并在划分 $Y$ 中分配给社区 $y$ 的节点数，而 $n_x$ 和 $n_y$ 是边际计数。使用自然对数。\n\n参数：\n- 块大小 $s = 16$（所有测试中固定）。\n- 平均度 $k = 12$（所有测试中固定）。\n- 混合参数 $\\mu$ 每个测试不同。\n- 总系统规模 $N$ 每个测试不同。\n\n测试套件：\n1. $(N = 64, \\mu = 0.10)$\n2. $(N = 64, \\mu = 0.40)$\n3. $(N = 160, \\mu = 0.10)$\n4. $(N = 160, \\mu = 0.30)$\n5. $(N = 320, \\mu = 0.10)$\n6. $(N = 320, \\mu = 0.35)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含六个 NMI 值，每个测试用例一个，按上述顺序排列，四舍五入到四位小数，格式为用方括号括起来的逗号分隔列表（例如，“[0.9321,0.4810,0.9023,0.7123,0.8532,0.6011]”）。\n\n不适用任何物理单位或角度单位。为确保可复现性，每个测试用例的所有随机数生成必须是确定性的。程序必须完全自包含，无需用户输入。",
            "solution": "该问题是有效的。它是一个定义明确的计算任务，基于网络科学中的既定原则，特别是社区检测和模块度分辨率极限的研究。所有参数、公式和程序都已明确指定，并且测试用例在计算上是可行的。\n\n解决方案通过为每个测试用例实现指定的算法来进行。核心步骤是：(1) 从随机块模型 (SBM) 生成一个图，(2) 应用贪婪凝聚算法来优化模块度，以及 (3) 使用标准化互信息 (NMI) 对比最终划分与基准划分进行评估。\n\n### 1. 随机块模型 (SBM) 图生成\n对于每个具有总节点数 $N$、块大小 $s$、平均度 $k$ 和混合参数 $\\mu$ 的测试用例，我们首先推导出必要的模型参数。块的数量是 $B = N/s$。在两个节点之间创建一条边的概率是：\n- $p_{\\mathrm{in}} = \\frac{(1 - \\mu) k}{s - 1}$，对于同一块内的两个节点。\n- $p_{\\mathrm{out}} = \\frac{\\mu k}{N - s}$，对于不同块中的两个节点。\n\n一个图实例被生成为一个具有 $N$ 个节点的无向、无权图。基准划分是通过将节点 $0, \\dots, s-1$ 分配给块 $0$，节点 $s, \\dots, 2s-1$ 分配给块 $1$，依此类推来定义的。通过考虑每对节点 $(i, j)$（其中 $i  j$），构建一个 $N \\times N$ 的邻接矩阵 $A$。如果节点 $i$ 和 $j$ 属于同一块，则以概率 $p_{\\mathrm{in}}$ 创建一条边 $(i, j)$；如果它们属于不同的块，则以概率 $p_{\\mathrm{out}}$ 创建。为了确保所需的可复现性，伪随机数生成器对每个测试用例都使用一个唯一的整数作为种子。\n\n### 2. 贪婪模块度优化\n社区检测算法从基准划分开始，其中 $B$ 个块中的每一个都构成一个社区。该过程迭代地合并社区对，以最大化模块度 $Q$ 的增量。\n\n一个划分的模块度由以下公式给出：\n$$\nQ = \\frac{1}{2m} \\sum_{i,j} \\left(A_{ij} - \\frac{k_i k_j}{2m}\\right) \\delta(c_i, c_j)\n$$\n其中 $m$ 是总边数，$A$ 是邻接矩阵，$k_i$ 是节点 $i$ 的度，$c_i$ 是节点 $i$ 所属的社区。一个等价的、更便于跟踪变化的公式是：\n$$\nQ = \\sum_{c \\in C} \\left( \\frac{L_{c}}{m} - \\left(\\frac{k_C}{2m}\\right)^2 \\right)\n$$\n其中总和是对社区集合 $C$ 进行的，$L_c$ 是社区 $c$ 内部的边数，$k_C$ 是社区 $c$ 中所有节点的度之和。\n\n当两个不同的社区 $c_i$ 和 $c_j$ 合并时，模块度的变化 $\\Delta Q_{ij}$ 可以高效地计算：\n$$\n\\Delta Q_{ij} = Q_{\\text{merged}} - Q_{\\text{original}} = 2 \\left( \\frac{L_{ij}}{2m} - \\frac{k_{C_i} k_{C_j}}{(2m)^2} \\right)\n$$\n其中 $L_{ij}$ 是社区 $c_i$ 和 $c_j$ 之间的边数，$k_{C_i}$ 是社区 $c_i$ 的总度数，$k_{C_j}$ 是社区 $c_j$ 的总度数。\n\n贪婪算法如下：\n1. 将划分初始化为基准块。\n2. 在每一步中，计算每对可能的不同社区 $(c_i, c_j)$ 的 $\\Delta Q_{ij}$。\n3. 找到产生最大正模块度增量 $\\max(\\Delta Q_{ij})$ 的那一对 $(c_i^*, c_j^*)$。\n4. 如果 $\\max(\\Delta Q_{ij}) > 0$，则合并社区 $c_i^*$ 和 $c_j^*$。更新划分和社区级别的属性（总度数和社区间边数）。\n5. 从第 2 步重复，直到没有合并能导致 $Q$ 的严格正增量。\n\n这个过程产生一个最终划分，其社区数量可能少于初始的 $B$ 个块，这展示了分辨率极限。\n\n### 3. 标准化互信息 (NMI)\n为了量化最终检测到的划分 $X$ 与基准划分 $Y$ 的匹配程度，我们计算标准化互信息 (NMI)。首先，构建一个列联表（或混淆矩阵），其条目为 $n_{xy}$，其中 $n_{xy}$ 是属于划分 $X$ 中社区 $x$ 和划分 $Y$ 中社区 $y$ 的节点数。\n\n互信息 $I(X;Y)$ 计算如下：\n$$\nI(X;Y) = \\sum_{x \\in X} \\sum_{y \\in Y} \\frac{n_{xy}}{N} \\log \\left(\\frac{n_{xy} N}{n_x n_y}\\right)\n$$\n其中 $n_x = \\sum_y n_{xy}$ 和 $n_y = \\sum_x n_{xy}$ 是边际计数（社区大小），并使用自然对数。$n_{xy}=0$ 的项视为零。\n\n划分的熵为：\n$$\nH(X) = - \\sum_{x \\in X} \\frac{n_x}{N} \\log \\left(\\frac{n_x}{N}\\right)\n$$\n$$\nH(Y) = - \\sum_{y \\in Y} \\frac{n_y}{N} \\log \\left(\\frac{n_y}{N}\\right)\n$$\n\n最后，NMI 由以下公式给出：\n$$\n\\mathrm{NMI}(X,Y) = \\frac{2 I(X;Y)}{H(X) + H(Y)}\n$$\nNMI 为 1 表示划分之间完全一致，而 NMI 为 0 表示一致性不高于随机预期的水平。即使 $\\mu$ 值较低，对于较大的 N，NMI 值较低将说明分辨率极限。\n\n### 4. 实现细节\n整个过程被封装在一个程序中，该程序遍历所提供的六个测试用例。对于每个用例，它确定性地生成图，运行贪婪合并算法，计算所得划分的 NMI，并存储该值。最终输出是这些 NMI 值的列表，四舍五入到四位小数。",
            "answer": "```python\nimport numpy as np\n\ndef generate_sbm(N, s, k, mu, seed):\n    \"\"\"\n    Generates an undirected, unweighted SBM graph.\n\n    Args:\n        N (int): Total number of nodes.\n        s (int): Size of each block.\n        k (float): Average degree.\n        mu (float): Mixing parameter.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: Adjacency matrix of the graph.\n            - np.ndarray: Ground truth partition array.\n    \"\"\"\n    if N % s != 0:\n        raise ValueError(\"N must be a multiple of s.\")\n    B = N // s\n    \n    if s == 1:\n        p_in = 0  # No self-loops, so probability of in-block edge is 0\n    else:\n        p_in = (1 - mu) * k / (s - 1)\n    \n    if N == s:\n        p_out = 0 # No other blocks to connect to\n    else:\n        p_out = mu * k / (N - s)\n\n    if p_in  1 or p_out  1:\n        # This check is for robustness, though problem parameters are safe.\n        raise ValueError(f\"Probabilities must be = 1. Got p_in={p_in}, p_out={p_out}\")\n\n    adj = np.zeros((N, N), dtype=np.int8)\n    ground_truth = np.repeat(np.arange(B), s)\n    rng = np.random.default_rng(seed)\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            prob = p_in if ground_truth[i] == ground_truth[j] else p_out\n            if rng.random()  prob:\n                adj[i, j] = 1\n                adj[j, i] = 1\n                \n    return adj, ground_truth\n\ndef calculate_nmi(p_true, p_pred, N):\n    \"\"\"\n    Calculates the Normalized Mutual Information (NMI) between two partitions.\n    \n    Args:\n        p_true (np.ndarray): The ground truth partition labels.\n        p_pred (np.ndarray): The predicted partition labels.\n        N (int): Total number of nodes.\n\n    Returns:\n        float: The NMI value.\n    \"\"\"\n    # Create unique labels for communities\n    true_labels = np.unique(p_true)\n    pred_labels = np.unique(p_pred)\n    \n    true_map = {label: i for i, label in enumerate(true_labels)}\n    pred_map = {label: i for i, label in enumerate(pred_labels)}\n\n    # Contingency table\n    contingency = np.zeros((len(true_labels), len(pred_labels)))\n    for i in range(N):\n        contingency[true_map[p_true[i]], pred_map[p_pred[i]]] += 1\n\n    # Marginals\n    n_x = np.sum(contingency, axis=0) # Sum over rows for pred communities\n    n_y = np.sum(contingency, axis=1) # Sum over columns for true communities\n    \n    # Mutual Information I(X; Y)\n    I_xy = 0\n    for i in range(len(true_labels)):\n        for j in range(len(pred_labels)):\n            if contingency[i, j]  0:\n                n_ij = contingency[i,j]\n                I_xy += (n_ij / N) * np.log((n_ij * N) / (n_y[i] * n_x[j]))\n    \n    # Entropy H(X) and H(Y)\n    H_x = 0\n    for val in n_x:\n        if val  0:\n            H_x -= (val / N) * np.log(val / N)\n            \n    H_y = 0\n    for val in n_y:\n        if val  0:\n            H_y -= (val / N) * np.log(val / N)\n            \n    # NMI\n    if (H_x + H_y) == 0:\n        return 1.0 if np.array_equal(p_true, p_pred) else 0.0\n    \n    return 2 * I_xy / (H_x + H_y)\n\ndef run_single_case(N, s, k, mu, seed):\n    \"\"\"\n    Runs the full simulation for a single test case.\n    \"\"\"\n    adj, ground_truth = generate_sbm(N, s, k, mu, seed)\n    \n    num_edges = np.sum(adj) / 2\n    if num_edges == 0: # Handle disconnected graph case\n        return calculate_nmi(ground_truth, np.arange(N), N)\n\n    total_degree_2m = 2 * num_edges\n    \n    node_degrees = np.sum(adj, axis=1)\n    \n    # --- Greedy merging algorithm ---\n    \n    # Initial partition is the ground truth\n    current_partition = ground_truth.copy()\n    comm_ids = list(np.unique(current_partition))\n    num_comms = len(comm_ids)\n\n    # Use dictionaries for flexible community management\n    id_map = {cid: i for i, cid in enumerate(comm_ids)}\n    \n    while True:\n        # Re-evaluate community properties at each step for simplicity\n        # For larger problems, an update mechanism would be more efficient\n        \n        # Calculate community degrees and inter-community edges\n        k_comm = {cid: 0 for cid in comm_ids}\n        for i in range(N):\n            k_comm[current_partition[i]] += node_degrees[i]\n            \n        L_inter = np.zeros((num_comms, num_comms))\n        comm_nodes = {cid: np.where(current_partition == cid)[0] for cid in comm_ids}\n\n        for i in range(num_comms):\n            for j in range(i + 1, num_comms):\n                cid1 = comm_ids[i]\n                cid2 = comm_ids[j]\n                nodes1 = comm_nodes[cid1]\n                nodes2 = comm_nodes[cid2]\n                \n                # Number of edges between the two communities\n                edges_between = np.sum(adj[np.ix_(nodes1, nodes2)])\n                L_inter[i, j] = edges_between\n\n        # Find best merge\n        max_delta_q = -1.0\n        best_pair = None\n        \n        for i in range(num_comms):\n            for j in range(i + 1, num_comms):\n                cid1, cid2 = comm_ids[i], comm_ids[j]\n                \n                L_ij = L_inter[i, j]\n                k_C_i = k_comm[cid1]\n                k_C_j = k_comm[cid2]\n                \n                delta_q = 2 * ( (L_ij / total_degree_2m) - (k_C_i * k_C_j) / (total_degree_2m**2) )\n\n                if delta_q  max_delta_q:\n                    max_delta_q = delta_q\n                    best_pair = (cid1, cid2)\n\n        if max_delta_q  0:\n            # Perform merge\n            c_absorb, c_merge_into = min(best_pair), max(best_pair)\n            \n            # Update partition array\n            current_partition[current_partition == c_merge_into] = c_absorb\n            \n            # Update community list\n            comm_ids.remove(c_merge_into)\n            num_comms = len(comm_ids)\n        else:\n            # No positive Q increase, stop\n            break\n\n    # Calculate NMI of final partition\n    nmi_result = calculate_nmi(ground_truth, current_partition, N)\n    return nmi_result\n    \ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Fixed parameters\n    s_fixed = 16\n    k_fixed = 12\n\n    # Test suite: (N, mu)\n    test_cases = [\n        (64, 0.10),\n        (64, 0.40),\n        (160, 0.10),\n        (160, 0.30),\n        (320, 0.10),\n        (320, 0.35),\n    ]\n\n    results = []\n    for i, (N_val, mu_val) in enumerate(test_cases):\n        # Use test case index as seed for reproducibility\n        seed = i\n        nmi = run_single_case(N_val, s_fixed, k_fixed, mu_val, seed)\n        results.append(f\"{nmi:.4f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}