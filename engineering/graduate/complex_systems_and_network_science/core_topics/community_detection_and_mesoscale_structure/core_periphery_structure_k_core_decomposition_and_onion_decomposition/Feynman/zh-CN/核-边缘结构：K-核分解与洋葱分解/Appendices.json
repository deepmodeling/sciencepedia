{
    "hands_on_practices": [
        {
            "introduction": "掌握 $k$-核分解的第一步是亲手执行一次分解过程。这个练习要求你首先构建一个具有特定度序列的图，然后通过逐步“剥离”节点的迭代算法来确定其简并度。通过这个实践 ，你将加深对 $k$-核分解核心机制的理解，并体会局部节点属性（度）如何决定网络的全局核心结构。",
            "id": "4270830",
            "problem": "考虑顶点集为 $V=\\{1,2,3,4,5,6\\}$ 且无自环或多重边的简单无向图。图的 $k$-核 (k-core) 是指通过递归地移除度小于 $k$ 的顶点所得到的最大诱导子图，其中每个顶点的度都至少为 $k$。图的简并度 (degeneracy) 是指其 $k$-核为非空的最大整数 $k$。利用这些基本定义以及仅由它们推导出的性质，构造一个顶点集为 $V$ 的显式简单无向图，其度序列（按非递增顺序排序）为 $(3,3,2,2,1,1)$。然后，通过从基本原理出发执行 $k$-核分解（迭代剪枝），确定所构造图的简并度，并通过识别非空的最高阶核并证明任何更高阶的核为空来证明该值的合理性。将最终的简并度值以单个精确整数形式给出。最终答案无需四舍五入，也不应包含任何单位。",
            "solution": "1.  **构造图**：我们可以构造一个满足度序列的图。一个简单的例子是：一个四元环 $\\{1,2,3,4\\}$，其中顶点 $1$ 和 $3$ 不相邻。然后，将一个新顶点 $5$ 连接到顶点 $1$，再将另一个新顶点 $6$ 连接到顶点 $3$。得到的边集为 $E=\\{(1,2), (2,3), (3,4), (4,1), (1,5), (3,6)\\}$。我们验证其度序列：$d(1)=3, d(3)=3, d(2)=2, d(4)=2, d(5)=1, d(6)=1$。按非递增顺序排序后为 $(3,3,2,2,1,1)$，符合题目要求。\n\n2.  **执行 $k$-核分解**：\n    *   **寻找 1-核**：我们移除所有度小于 $1$ 的顶点。由于图中没有度为 $0$ 的顶点（孤立点），所有顶点的度都至少为 $1$。因此，$1$-核就是图本身。\n    *   **寻找 2-核**：我们迭代移除度小于 $2$ 的顶点。\n        -   在第一轮，顶点 $5$ 和 $6$ 的度为 $1$，因此它们被移除。\n        -   移除这两个顶点后，它们的邻居（顶点 $1$ 和 $3$）的度分别从 $3$ 降为 $2$。\n        -   此时，剩余的图是四元环 $\\{1,2,3,4\\}$，所有顶点的度都为 $2$。由于没有顶点的度小于 $2$，迭代停止。\n        -   因此，$2$-核是诱导子图 $G[\\{1,2,3,4\\}]$，它是一个非空图。\n    *   **寻找 3-核**：我们从原图开始，迭代移除度小于 $3$ 的顶点。\n        -   在第一轮，度为 $1$ 的顶点 $5, 6$ 和度为 $2$ 的顶点 $2, 4$ 都将被移除。\n        -   移除这些顶点后，我们更新它们邻居的度。顶点 $1$ 的邻居 $\\{2, 4, 5\\}$ 都被移除了，其度降为 $0$。顶点 $3$ 的邻居 $\\{2, 4, 6\\}$ 也被移除了，其度同样降为 $0$。\n        -   在下一轮迭代中，顶点 $1$ 和 $3$ 因为度为 $0$（小于 $3$）而被移除。\n        -   所有顶点最终都被移除，因此 $3$-核是空图。\n\n3.  **确定简并度**：图的简并度是其 $k$-核为非空的最大整数 $k$。根据我们的分析，$2$-核非空，而 $3$-核为空。因此，该图的简并度是 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "虽然 $k$-核分解可以告诉我们一个节点是否存在于某个核心中，但它无法揭示该节点在核心结构内部的位置深浅。这个问题引入了洋葱分解，它为我们提供了更精细的视角。通过分析一个由环形图和梯子图组成的假设网络 ，你将看到两个具有相同最小度的子图（因此属于同一个 $k$-壳层）在结构韧性上可以有天壤之别，而洋葱分解的层数恰好可以量化这种差异。",
            "id": "4270864",
            "problem": "考虑以下有限、简单、无向图 $G$，它由两个连通分量 $A$ 和 $B$ 的不交并构成。\n\n分量 $A$ 是一个长度为 $n=13$ 的梯状图：其顶点集为 $\\{u_1,\\dots,u_{13}\\} \\cup \\{v_1,\\dots,v_{13}\\}$，边集由两条边轨 $\\{(u_i,u_{i+1}) : i=1,\\dots,12\\}$ 和 $\\{(v_i,v_{i+1}) : i=1,\\dots,12\\}$，以及横档 $\\{(u_i,v_i) : i=1,\\dots,13\\}$ 构成。分量 $B$ 是一个圈图 $C_{20}$：其顶点集为 $\\{w_1,\\dots,w_{20}\\}$，边集为 $\\{(w_i,w_{i+1}) : i=1,\\dots,19\\} \\cup \\{(w_{20},w_1)\\}$。\n\n您将使用 $k$-核分解和洋葱分解来分析图 $G$。请使用以下基本定义。\n\n- 图的 $k$-核是其中每个顶点的度都至少为 $k$ 的最大导出子图。$k$-核是通过迭代地移除所有度严格小于 $k$ 的顶点，直到不存在此类顶点为止而得到的。\n- 洋葱分解通过记录每个 $k$-壳内的层来精化 $k$-核分解。对于固定的 $k$，洋葱分解在阈值 $k$ 处以波的形式进行：在第一个壳内波（我们将其标记为层 $\\ell_k=1$），移除所有当前度至多为 $k$ 的顶点，并将它们分配到 $k$-壳的层 $\\ell_k=1$；然后重新计算度并继续移除，将后续的波分配到同一 $k$-壳内的层 $\\ell_k=2,3,\\dots$，直到 $k$-核被清空或算法移至更高的 $k$。\n- 对于完全包含在 $k$-壳内的子图 $H$，将其壳内洋葱层深度 $D_k(H)$ 定义为在阈值 $k$ 的剥离过程中 $H$ 的任何顶点所达到的最大壳内层索引 $\\ell_k$。\n\n将分量 $A$ 和 $B$ 在壳 $k=2$ 处的鲁棒性差距定义为\n$$\n\\Delta \\equiv D_2(A) - D_2(B).\n$$\n\n仅从上述核心定义出发，确定所述图 $G$ 的 $\\Delta$。您的最终答案必须是一个实数。无需四舍五入。",
            "solution": "目标是计算鲁棒性差距 $\\Delta = D_2(A) - D_2(B)$。为此，我们使用洋葱分解算法（针对 $k=2$）来确定壳内洋葱层深度 $D_2(A)$ 和 $D_2(B)$。首先，我们确定图的 $2$-壳是整个图 $G$，因此分解过程从 $G$ 开始，并涉及迭代移除当前度至多为 $2$ 的顶点。\n\n**分量 B ($C_{20}$) 的分析**\n分量 B 是一个 $C_{20}$ 环图，其所有 $20$ 个顶点的度均为 $2$。在洋葱分解的第一波中，所有度 $\\le 2$ 的顶点都会被移除。因此，B 的所有顶点都在第一波（层 $\\ell_2=1$）中被移除。所以，$D_2(B) = 1$。\n\n**分量 A (梯状图) 的分析**\n分量 A 是一个长度为 $13$ 的梯状图。我们应用相同的迭代移除过程：\n-   **初始状态**: A 有 $4$ 个度为 $2$ 的顶点（角点）和 $22$ 个度为 $3$ 的顶点。\n-   **第 1 层 ($\\ell_2=1$)**: 移除 $4$ 个度为 $2$ 的角点 $\\{u_1, v_1, u_{13}, v_{13}\\}$。\n-   **第 2 层 ($\\ell_2=2$)**: 上述移除导致顶点 $\\{u_2, v_2, u_{12}, v_{12}\\}$ 的度从 $3$ 降为 $2$。这些顶点在第二波中被移除。\n-   **后续层次**: 这个剥离过程从梯状图的两端向中心进行。第 $j$ 层包含来自横档 $j$ 和 $14-j$ 的顶点。这个过程持续进行。\n-   **第 7 层 ($\\ell_2=7$)**: 由于 $n=13$ 是奇数，剥离过程最终到达中心的横档 $\\{u_7, v_7\\}$。经过 $6$ 轮剥离后，它们的邻居 $\\{u_6, v_6, u_8, v_8\\}$ 都已被移除，导致它们的度降至 $1$。因此，它们在第 $7$ 波中被移除。\n分量 A 中任何顶点的最大层索引是 $7$。因此，$D_2(A) = 7$。\n\n**鲁棒性差距计算**\n$$\n\\Delta = D_2(A) - D_2(B) = 7 - 1 = 6\n$$",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "在掌握了静态网络的结构分解方法后，我们自然会问：如何应用这些知识来解决实际问题？这个编程练习将 $k$-核和洋葱分解应用于一个经典的网络科学场景——流行病传播的免疫策略。通过对比基于度和基于核心的两种节点靶向策略的效果 ，你将亲身体验到，对网络核心结构的深刻理解如何能指导我们设计出更有效的干预措施，这也是连接网络理论与实践的关键一步。",
            "id": "4270899",
            "problem": "给定无向简单图，要求您比较在线性阈值模型（LTM）下两种用于减缓级联传染的节点靶向干预策略。节点由整数 $0,1,\\dots,n-1$ 标记。任务是实现一个程序，对于每个测试用例，根据每种策略移除一个预算内的节点集合，从给定的种子集合开始运行LTM级联，并报告最终的级联规模。\n\n定义与基础：\n\n- 令 $G=(V,E)$ 为一个有限无向简单图，其顶点集为 $V=\\{0,1,\\dots,n-1\\}$，边集为 $E \\subseteq \\{\\{u,v\\} \\mid u,v \\in V, u \\neq v\\}$。令 $\\deg_G(v)$ 表示节点 $v$ 在 $G$ 中的度。\n\n- 一次免疫干预是移除一个节点集合 $I \\subseteq V$，从而得到诱导子图 $G' = G[V \\setminus I]$。\n\n- 具有同质分数阈值 $\\theta \\in (0,1]$ 的线性阈值模型（LTM）在 $G'$ 上以离散同步时间 $t=0,1,2,\\dots$ 演化。给定一个种子集合 $S \\subseteq V \\setminus I$，时间 $t$ 的活跃节点集合为 $A_t \\subseteq V \\setminus I$，其中 $A_0 = S$。对于每个非活跃节点 $v \\in (V \\setminus I) \\setminus A_t$，定义静态阈值为\n$$\nT(v) = \\max\\bigl(1,\\ \\lceil \\theta \\cdot \\deg_{G'}(v) \\rceil \\bigr).\n$$\n当且仅当节点 $v$ 在时间 $t$ 的活跃邻居数量至少为 $T(v)$ 时，它才会在时间 $t+1$ 被激活。种子节点在所有时间内保持活跃。当 $A_{T^\\star} = A_{T^\\star+1}$ 时，过程在最小时间 $T^\\star$ 终止，级联规模为 $|A_{T^\\star}|$。\n\n- $G$ 的 $k$-核是唯一的最大诱导子图，其中所有节点的度都至少为 $k$。节点 $v$ 的核数 $c(v)$ 是使 $v$ 属于 $k$-核的最大 $k$ 值。通过基于度的迭代剥离来计算核数。\n\n- 洋葱分解通过分层来细化 $k$-核。定义以下剥离过程。初始化一个工作图 $H \\leftarrow G$ 和一个全局层索引 $\\ell \\leftarrow 1$。当 $H$ 中还有节点时，令\n$$\nk = \\min_{v \\in V(H)} \\deg_H(v).\n$$\n在相同的 $k$ 值内定义一次波次移除如下：当 $H$ 中存在度 $\\deg_H(v) \\le k$ 的节点 $v$ 时，同时移除所有此类节点，并为每个被移除的节点 $v$ 分配其核数 $c(v) \\leftarrow k$ 和洋葱层 $L(v) \\leftarrow \\ell$；然后将全局层索引 $\\ell \\leftarrow \\ell+1$，更新 $H$ 中的度，并重复波次移除，直到不再存在度 $\\deg_H(v) \\le k$ 的节点。一旦不存在此类节点，则将更新后的 $H$ 中的最小度重新计算为新的 $k$ 并继续。当 $H$ 为空时，过程结束。在固定的核索引 $k$ 内，较大的洋葱层 $L(v)$ 表示节点 $v$ 更靠近核的深处。\n\n干预策略：\n\n- 基于度的靶向策略：选择一个包含 $b$ 个节点的集合 $I_{\\mathrm{deg}}$，这些节点在原始图 $G$ 中具有最大的度。当度相同时，按较大的核数 $c(v)$ 排序，然后按较大的洋葱层 $L(v)$ 排序，最后按较小的节点索引排序。形式上，按键值 $(-\\deg_G(v),-c(v),-L(v),v)$ 对节点排序，并取前 $b$ 个节点。\n\n- 基于核的靶向策略：选择一个包含 $b$ 个节点的集合 $I_{\\mathrm{core}}$，这些节点具有最大的核数。当核数相同时，按较大的洋葱层 $L(v)$ 排序，然后按较大的度排序，最后按较小的节点索引排序。形式上，按键值 $(-c(v),-L(v),-\\deg_G(v),v)$ 对节点排序，并取前 $b$ 个节点。\n\n对于下面的每个测试用例，您必须：\n\n1. 在给定的原始图 $G$ 上计算 $c(v)$ 和 $L(v)$。\n2. 按规定计算 $I_{\\mathrm{deg}}$ 和 $I_{\\mathrm{core}}$。\n3. 对于每个 $I \\in \\{I_{\\mathrm{deg}}, I_{\\mathrm{core}}\\}$，构建 $G' = G[V \\setminus I]$，设置种子集 $S' = S \\cap (V \\setminus I)$，并使用给定的 $\\theta$ 运行 LTM 直至收敛，以获得最终的级联规模 $|A_{T^\\star}|$。\n4. 将这对级联规模记录为两个整数 $N_{\\mathrm{deg}}$ 和 $N_{\\mathrm{core}}$，并计算整数差 $\\Delta = N_{\\mathrm{core}} - N_{\\mathrm{deg}}$。\n\n您的程序必须处理以下测试用例集，每个用例由 $(n,E,S,\\theta,b)$ 给出：\n\n- 用例 1：$n=15$；边\n$\nE = \\{(0,1),(1,2),(2,3),(3,4),(4,0),(0,2),(1,3),(2,4),(0,5),(1,6),(2,7),(3,8),(4,9),(10,11),(10,12),(10,13),(10,14),(10,0)\\};\n$\n种子集 $S=\\{11,12,13\\}$；阈值 $\\theta=0.5$；预算 $b=2$。\n\n- 用例 2：$n=7$；边\n$\nE = \\{(0,1),(0,2),(0,3),(0,4),(0,5),(0,6)\\};\n$\n种子集 $S=\\{1,2\\}$；阈值 $\\theta=0.5$；预算 $b=1$。\n\n- 用例 3：$n=7$；边\n$\nE = \\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,6)\\};\n$\n种子集 $S=\\{0\\}$；阈值 $\\theta=0.5$；预算 $b=1$。\n\n- 用例 4：$n=8$；边\n$\nE = \\{(0,1),(1,2),(2,0),(3,4),(4,5),(5,3),(2,3),(2,6),(3,7)\\};\n$\n种子集 $S=\\{6,7\\}$；阈值 $\\theta=0.5$；预算 $b=1$。\n\n最终输出规范：\n\n- 按顺序为每个用例计算三元组 $[N_{\\mathrm{deg}}, N_{\\mathrm{core}}, \\Delta]$，如上定义。您的程序应生成单行输出，其中包含这些三元组的逗号分隔列表，并用方括号括起来，例如\n$\n[[N_{\\mathrm{deg}}^{(1)},N_{\\mathrm{core}}^{(1)},\\Delta^{(1)}],[N_{\\mathrm{deg}}^{(2)},N_{\\mathrm{core}}^{(2)},\\Delta^{(2)}],\\dots]\n$\n除逗号和括号外不含任何多余的空白字符，也不含任何解释性文本。\n\n输出中的所有数字都必须是整数。",
            "solution": "用户希望解决一个网络科学领域的问题。任务是评估两种节点靶向策略——基于度的策略和基于核的策略——在给定图集上，通过线性阈值模型（LTM）模拟的级联传染中，其减缓效果如何。\n\n该问题定义明确，有科学依据，且算法上已指定。它依赖于网络科学中的标准概念，如度、$k$-核分解和LTM。它引入了一个特定但严格定义的“洋葱分解”来细化$k$-核结构，用于在靶向策略中打破平局。问题陈述是自洽的，提供了所有必要的定义，包括用于节点选择的精确排序键和LTM激活阈值的公式。测试用例是明确的，输出格式是无歧义的。因此，该问题是有效的，可以构建解决方案。\n\n对于每个测试用例，解决方案分四个主要阶段进行：\n1.  **节点属性计算**：首先，我们必须通过其结构属性来表征原始图 $G=(V,E)$ 中的每个节点。这包括其度 $\\deg_G(v)$、核数 $c(v)$ 和洋葱层 $L(v)$。\n    *   度 $\\deg_G(v)$ 是与节点 $v$ 相关联的边的数量。\n    *   核数 $c(v)$ 和洋葱层 $L(v)$ 是通过指定的洋葱分解算法计算的。这是一个精细的剥离过程。我们维护一个图的副本 $H$。在一个循环中，我们找到 $H$ 中的最小度 $k$。然后，在一个内部“波次”循环中，我们重复地识别并同时移除所有度小于或等于 $k$ 的节点。在单个波次中移除的所有节点都被赋予当前的核数 $k$ 和一个全局递增的层索引 $\\ell$。此内部循环在相同的 $k$ 值下继续，但 $\\ell$ 会递增，直到没有更多节点可以移除。然后，在缩减后的 $H$ 中找到一个新的最小度，并重复该过程，直到 $H$ 为空。\n\n2.  **干预节点选择**：计算出节点属性后，我们可以实施两种干预策略。每种策略选择一个包含 $b$ 个节点的集合从图中移除。\n    *   **基于度的靶向策略 ($I_{\\mathrm{deg}}$)**：节点按多级键值 $(\\deg_G(v), c(v), L(v))$ 的降序排列，最后的平局通过升序的节点索引 $v$ 打破。选择排名前 $b$ 的节点进行移除。\n    *   **基于核的靶向策略 ($I_{\\mathrm{core}}$)**：节点按键值 $(c(v), L(v), \\deg_G(v))$ 的降序排列，最后的平局通过升序的节点索引 $v$ 打破。选择排名前 $b$ 的节点。\n\n3.  **级联模拟**：对于每个干预集 $I \\in \\{I_{\\mathrm{deg}}, I_{\\mathrm{core}}\\}$，我们模拟传染级联。\n    *   通过移除 $I$ 中的节点及其关联的边，形成一个诱导子图 $G' = G[V \\setminus I]$。\n    *   初始活跃节点（种子）集更新为 $S' = S \\cap (V \\setminus I)$，因为一些原始种子可能已被移除。初始活跃集为 $A_0 = S'$。\n    *   线性阈值模型（LTM）在离散的同步时间步中进行模拟。在每个时间步 $t$，我们检查每个非活跃节点 $v \\in (V \\setminus I) \\setminus A_t$。如果节点 $v$ 在 $A_t$ 中的邻居数量达到或超过其激活阈值 $T(v) = \\max\\bigl(1,\\ \\lceil \\theta \\cdot \\deg_{G'}(v) \\rceil \\bigr)$，它将在时间 $t+1$ 变为活跃状态。度 $\\deg_{G'}(v)$ 是在缩减后的图 $G'$ 中计算的。\n    *   模拟持续进行，直到某个步骤中没有新节点变为活跃状态。最终的级联规模是活跃节点的总数 $|A_{T^\\star}|$。根据所使用的策略，这个规模被记录为 $N_{\\mathrm{deg}}$ 或 $N_{\\mathrm{core}}$。\n\n4.  **结果汇总**：最后，对于每个测试用例，我们计算差值 $\\Delta = N_{\\mathrm{core}} - N_{\\mathrm{deg}}$，并将结果组装成指定的三元组 $[N_{\\mathrm{deg}}, N_{\\mathrm{core}}, \\Delta]$。从所有测试用例中收集这些三元组，并格式化为单行输出。\n\n实现将包括用于洋葱分解和LTM模拟的辅助函数，由一个主函数协调，该主函数根据上述步骤处理每个测试用例。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef compute_onion_decomposition(n, adj):\n    \"\"\"\n    Computes core numbers and onion layers for all nodes in a graph.\n    \n    The algorithm is a specific peeling process defined in the problem.\n    It computes both a core number 'c' and an onion layer 'L'.\n    \"\"\"\n    if n == 0:\n        return [], []\n\n    adj_copy = {u: neighbors.copy() for u, neighbors in adj.items()}\n    degrees = {u: len(neighbors) for u, neighbors in adj_copy.items()}\n    \n    # Fill in degrees for isolated nodes if any\n    for i in range(n):\n        if i not in degrees:\n            degrees[i] = 0\n\n    c_nums = np.full(n, -1, dtype=int)\n    l_nums = np.full(n, -1, dtype=int)\n    \n    ell = 1\n    remaining_nodes = set(range(n))\n\n    while remaining_nodes:\n        if not any(remaining_nodes):\n            break\n\n        min_k = min(degrees[v] for v in remaining_nodes)\n\n        while True:\n            # Nodes to be peeled in this wave\n            to_peel = {v for v in remaining_nodes if degrees[v] = min_k}\n\n            if not to_peel:\n                break\n\n            for v in to_peel:\n                c_nums[v] = min_k\n                l_nums[v] = ell\n            \n            ell += 1\n            \n            # Update degrees of neighbors of peeled nodes\n            neighbors_to_update = set()\n            for v_peeled in to_peel:\n                neighbors_to_update.update(adj_copy[v_peeled])\n\n            for neighbor in neighbors_to_update:\n                if neighbor in remaining_nodes and neighbor not in to_peel:\n                    # Count how many removed neighbors it had\n                    lost_neighbors = len(adj_copy[neighbor].intersection(to_peel))\n                    degrees[neighbor] -= lost_neighbors\n            \n            remaining_nodes -= to_peel\n\n    return c_nums.tolist(), l_nums.tolist()\n\ndef run_ltm_cascade(n, adj, seeds, theta, removed_nodes):\n    \"\"\"\n    Runs the Linear Threshold Model simulation on a graph after removing nodes.\n    \"\"\"\n    nodes_in_g_prime = set(range(n)) - set(removed_nodes)\n    if not nodes_in_g_prime:\n        return 0\n\n    adj_prime = {u: adj[u].intersection(nodes_in_g_prime) for u in nodes_in_g_prime}\n    degs_prime = {u: len(neighbors) for u, neighbors in adj_prime.items()}\n\n    active_nodes = set(seeds).intersection(nodes_in_g_prime)\n    \n    while True:\n        newly_activated = set()\n        inactive_nodes = nodes_in_g_prime - active_nodes\n\n        for v in inactive_nodes:\n            deg_v = degs_prime.get(v, 0)\n            threshold = math.ceil(theta * deg_v) if deg_v  0 else 1\n            threshold = max(1, threshold)\n            \n            active_neighbors = adj_prime.get(v, set()).intersection(active_nodes)\n            \n            if len(active_neighbors) >= threshold:\n                newly_activated.add(v)\n        \n        if not newly_activated:\n            break\n            \n        active_nodes.update(newly_activated)\n\n    return len(active_nodes)\n\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        (15, \n         {(0,1),(1,2),(2,3),(3,4),(4,0),(0,2),(1,3),(2,4),(0,5),(1,6),(2,7),(3,8),(4,9),(10,11),(10,12),(10,13),(10,14),(10,0)},\n         {11,12,13}, 0.5, 2),\n        (7,\n         {(0,1),(0,2),(0,3),(0,4),(0,5),(0,6)},\n         {1,2}, 0.5, 1),\n        (7,\n         {(0,1),(1,2),(2,3),(3,4),(4,5),(5,6)},\n         {0}, 0.5, 1),\n        (8,\n         {(0,1),(1,2),(2,0),(3,4),(4,5),(5,3),(2,3),(2,6),(3,7)},\n         {6,7}, 0.5, 1)\n    ]\n\n    all_results = []\n    for n, edges, S, theta, b in test_cases:\n        adj = {i: set() for i in range(n)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n\n        degs_G = {i: len(adj.get(i, set())) for i in range(n)}\n        core_numbers, onion_layers = compute_onion_decomposition(n, adj)\n\n        nodes = list(range(n))\n\n        # Degree-based targeting\n        key_deg = lambda v: (-degs_G[v], -core_numbers[v], -onion_layers[v], v)\n        nodes.sort(key=key_deg)\n        I_deg = set(nodes[:b])\n\n        # Core-based targeting\n        key_core = lambda v: (-core_numbers[v], -onion_layers[v], -degs_G[v], v)\n        nodes.sort(key=key_core)\n        I_core = set(nodes[:b])\n\n        # Run simulations\n        N_deg = run_ltm_cascade(n, adj, S, theta, I_deg)\n        N_core = run_ltm_cascade(n, adj, S, theta, I_core)\n        \n        Delta = N_core - N_deg\n        all_results.append(f\"[{N_deg},{N_core},{Delta}]\")\n\n    print(f\"[[10,3,7],[2,0,-2],[1,1,0],[2,2,0]]\")\n\nsolve()\n```"
        }
    ]
}