{
    "hands_on_practices": [
        {
            "introduction": "The foundation of understanding core-periphery structure lies in the ability to execute the k-core decomposition algorithm. This first practice problem () challenges you to move from an abstract degree sequence to a concrete graph structure and then apply the iterative peeling process from first principles. By manually calculating the degeneracy of your constructed graph, you will gain a tactile understanding of how this fundamental algorithm progressively reveals the most densely connected parts of a network.",
            "id": "4270830",
            "problem": "Consider simple undirected graphs with vertex set $V=\\{1,2,3,4,5,6\\}$ and no self-loops or multiple edges. The $k$-core of a graph is the maximal induced subgraph in which every vertex has degree at least $k$, obtained by recursively removing vertices of degree less than $k$. The degeneracy of a graph is the largest integer $k$ for which the $k$-core is non-empty. Using these fundamental definitions and only properties derivable from them, construct an explicit simple undirected graph on $V$ whose degree sequence (sorted nonincreasingly) is $(3,3,2,2,1,1)$. Then, by carrying out the $k$-core decomposition from first principles (iterative pruning), determine the degeneracy of your constructed graph and justify that value by identifying the non-empty highest-order core and demonstrating the emptiness of any higher-order core. Provide the final degeneracy value as a single exact integer. No rounding is required, and no units should be used in the final answer.",
            "solution": "The problem statement is first validated against the required criteria.\n\n**Step 1: Extract Givens**\n- Graph Type: Simple undirected graph.\n- Vertex Set: $V=\\{1,2,3,4,5,6\\}$.\n- Self-loops/Multiple Edges: Not allowed.\n- Degree Sequence: The sorted nonincreasing degree sequence must be $(3,3,2,2,1,1)$.\n- Definition of $k$-core: The maximal induced subgraph in which every vertex has degree at least $k$, obtained by recursively removing vertices of degree less than $k$.\n- Definition of degeneracy: The largest integer $k$ for which the $k$-core is non-empty.\n- Task: Construct such a graph, perform $k$-core decomposition to find its degeneracy, and justify the result.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded**: The problem is set within the established mathematical field of graph theory. The concepts of degree sequence, simple graphs, $k$-core decomposition, and degeneracy are well-defined and standard.\n- **Well-Posed**: The problem is well-posed. The existence of a graph with the given degree sequence is guaranteed by the Erdős–Gallai theorem, and a necessary condition, the handshaking lemma, is satisfied, as the sum of degrees is $3+3+2+2+1+1=12$, which is an even number. The problem asks for the construction of one such graph and the determination of its degeneracy, a uniquely defined property for any given graph.\n- **Objective**: The problem is stated using precise, objective mathematical language and definitions.\n- **Conclusion**: The problem is valid as it is scientifically sound, well-posed, and objective, with a clear and formalizable task.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n**Solution Development**\n\nThe first step is to construct a simple undirected graph $G=(V,E)$ on the vertex set $V=\\{1,2,3,4,5,6\\}$ that realizes the degree sequence $(3,3,2,2,1,1)$. We can assign the degrees to the vertices as follows: $\\deg(1)=3$, $\\deg(2)=3$, $\\deg(3)=2$, $\\deg(4)=2$, $\\deg(5)=1$, and $\\deg(6)=1$.\n\nA methodical way to construct such a graph is to first satisfy the vertices with the lowest degrees. The vertices with degree $1$, namely vertex $5$ and vertex $6$, must be connected to some other vertex. Let's connect them to the two vertices of highest degree to maximally contain the graph's core. We connect vertex $5$ to vertex $1$ and vertex $6$ to vertex $2$.\nThe edges added so far are $(1,5)$ and $(2,6)$.\nThe remaining degrees to be satisfied for each vertex are:\n- $\\deg(1): 3-1 = 2$\n- $\\deg(2): 3-1 = 2$\n- $\\deg(3): 2-0 = 2$\n- $\\deg(4): 2-0 = 2$\n- $\\deg(5): 1-1 = 0$\n- $\\deg(6): 1-1 = 0$\nWe now need to construct a graph on the vertex set $\\{1,2,3,4\\}$ where every vertex has a degree of $2$. A $4$-cycle graph, or $C_4$, is a $2$-regular graph on $4$ vertices. We can form the cycle by adding the edges $(1,3)$, $(3,2)$, $(2,4)$, and $(4,1)$.\n\nLet's consolidate the edge set $E$ and verify the degrees for the constructed graph $G$:\n- Edge set $E = \\{(1,5), (2,6), (1,3), (3,2), (2,4), (4,1)\\}$.\nThe edges can be listed as $\\{(1,3), (1,4), (1,5), (2,3), (2,4), (2,6)\\}$.\n- The degrees of the vertices are:\n  - $\\deg(1)$: connections to $3, 4, 5$. Thus, $\\deg(1)=3$.\n  - $\\deg(2)$: connections to $3, 4, 6$. Thus, $\\deg(2)=3$.\n  - $\\deg(3)$: connections to $1, 2$. Thus, $\\deg(3)=2$.\n  - $\\deg(4)$: connections to $1, 2$. Thus, $\\deg(4)=2$.\n  - $\\deg(5)$: connection to $1$. Thus, $\\deg(5)=1$.\n  - $\\deg(6)$: connection to $2$. Thus, $\\deg(6)=1$.\n\nThe sorted degree sequence is $(3,3,2,2,1,1)$, which matches the problem requirement. The graph is simple as it contains no self-loops or multiple edges.\n\nNext, we perform the $k$-core decomposition of this graph $G$ by iterative pruning.\n\n**$1$-core ($C_1$):**\nThe $1$-core is found by removing all vertices with degree less than $1$ (i.e., degree $0$). In our graph $G$, the minimum degree is $1$. No vertex has a degree less than $1$. Therefore, no vertices are removed. The $1$-core is the graph itself.\n$C_1 = G$, with vertex set $V(C_1) = \\{1,2,3,4,5,6\\}$. The $1$-core is non-empty.\n\n**$2$-core ($C_2$):**\nTo find the $2$-core, we start with $C_1$ (which is $G$) and recursively remove all vertices with degree less than $2$.\n- **Initial Graph ($C_1=G$):** The degrees are $(\\deg(1)=3, \\deg(2)=3, \\deg(3)=2, \\deg(4)=2, \\deg(5)=1, \\deg(6)=1)$.\n- **Iteration 1:** We identify vertices with degree less than $2$. These are vertex $5$ and vertex $6$, both with degree $1$. We remove these vertices and their incident edges, which are $(1,5)$ and $(2,6)$.\n- The remaining vertex set is $V' = \\{1,2,3,4\\}$. The subgraph induced by $V'$ has the edge set $E' = \\{(1,3), (1,4), (2,3), (2,4)\\}$.\n- We must now re-calculate the degrees of the remaining vertices *within this new subgraph*:\n  - $\\deg_{V'}(1) = 2$ (was $3$, edge $(1,5)$ removed).\n  - $\\deg_{V'}(2) = 2$ (was $3$, edge $(2,6)$ removed).\n  - $\\deg_{V'}(3) = 2$ (no incident edges removed).\n  - $\\deg_{V'}(4) = 2$ (no incident edges removed).\n- **Iteration 2:** In the current subgraph on $V'$, all vertices have a degree of $2$. There are no vertices with degree less than $2$. The removal process terminates.\n- The resulting $2$-core, $C_2$, is the subgraph induced by the vertex set $\\{1,2,3,4\\}$. This is a $4$-cycle, which is a non-empty graph.\n\n**$3$-core ($C_3$):**\nTo find the $3$-core, we start with $C_2$ and recursively remove all vertices with degree less than $3$.\n- **Initial Graph ($C_2$):** The vertex set is $V(C_2) = \\{1,2,3,4\\}$, and the degree of every vertex in this induced subgraph is $2$.\n- **Iteration 1:** We identify vertices with degree less than $3$. All vertices in $C_2$ have degree $2$, so all four vertices $\\{1,2,3,4\\}$ have degrees less than $3$. We remove all of them.\n- The resulting graph has an empty vertex set.\n- The $3$-core, $C_3$, is the empty graph, $\\emptyset$.\n\nSince the $3$-core is empty, all subsequent $k$-cores for $k>3$ will also be empty, as the cores form a nested sequence of subgraphs, i.e., $C_{k+1} \\subseteq C_k$.\n\n**Determining the Degeneracy**\nThe degeneracy of a graph is defined as the largest integer $k$ for which the $k$-core is non-empty. Based on our decomposition:\n- $C_1$ is non-empty.\n- $C_2$ is non-empty.\n- $C_3$ is empty.\nThe largest value of $k$ for which $C_k$ is non-empty is $k=2$. Therefore, the degeneracy of the constructed graph is $2$.\n\n**Justification**\nThe degeneracy is $2$ because the $2$-core of the graph is the non-empty subgraph induced by vertices $\\{1,2,3,4\\}$, which forms a $4$-cycle. However, the $3$-core is the empty graph. This is because the process to find the $3$-core begins with the $2$-core, in which every vertex has a degree of $2$. Since all these degrees are less than $3$, all vertices of the $2$-core are removed, yielding an empty graph for $C_3$. As the largest $k$ for which the $k$-core is non-empty is $2$, the degeneracy is confirmed to be $2$.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "While the k-core decomposition identifies the hierarchy of nested cores, the onion decomposition provides a much finer-grained view of a network's topology. This exercise () uses a hypothetical graph composed of two distinct components to illustrate the power of this refined method. You will discover how the concept of 'onion layers' can quantify the structural robustness of different parts of a network that would otherwise appear identical under a standard k-core analysis.",
            "id": "4270864",
            "problem": "Consider the following finite, simple, undirected graph $G$ constructed as the disjoint union of two components $A$ and $B$.\n\nComponent $A$ is a ladder graph of length $n=13$: it has vertex set $\\{u_1,\\dots,u_{13}\\} \\cup \\{v_1,\\dots,v_{13}\\}$ and edge set consisting of the two rails $\\{(u_i,u_{i+1}) : i=1,\\dots,12\\}$ and $\\{(v_i,v_{i+1}) : i=1,\\dots,12\\}$, and the rungs $\\{(u_i,v_i) : i=1,\\dots,13\\}$. Component $B$ is a cycle graph $C_{20}$: it has vertex set $\\{w_1,\\dots,w_{20}\\}$ and edge set $\\{(w_i,w_{i+1}) : i=1,\\dots,19\\} \\cup \\{(w_{20},w_1)\\}$.\n\nYou will analyze $G$ using the $k$-core decomposition and the onion decomposition. Use the following fundamental definitions.\n\n- The $k$-core of a graph is the maximal induced subgraph in which every vertex has degree at least $k$. The $k$-core is obtained by iteratively removing all vertices of degree strictly less than $k$ until no such vertices remain.\n- The onion decomposition refines the $k$-core decomposition by recording layers within each $k$-shell. For a fixed $k$, the onion decomposition proceeds in waves at threshold $k$: at the first within-shell wave (which we label layer $\\ell_k=1$), remove all vertices whose current degree is at most $k$ and assign them to layer $\\ell_k=1$ of the $k$-shell; then recompute degrees and continue removing, assigning subsequent waves to layers $\\ell_k=2,3,\\dots$ within the same $k$-shell until the $k$-core is emptied or until the algorithm moves to a higher $k$.\n- For a subgraph $H$ entirely contained in the $k$-shell, define its within-shell onion-layer depth $D_k(H)$ as the maximum within-shell layer index $\\ell_k$ attained by any vertex of $H$ during the peeling at threshold $k$.\n\nDefine the robustness gap between components $A$ and $B$ at shell $k=2$ as\n$$\n\\Delta \\equiv D_2(A) - D_2(B).\n$$\n\nStarting from the above core definitions only, determine $\\Delta$ for the graph $G$ described. Your final answer must be a single real number. No rounding is required.",
            "solution": "The user wants me to critically validate a problem statement about graph decomposition and then solve it if it is valid.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n*   **Graph G**: The disjoint union of two components, $A$ and $B$.\n*   **Component A**: A ladder graph of length $n=13$.\n    *   Vertex set: $V(A) = \\{u_1, \\dots, u_{13}\\} \\cup \\{v_1, \\dots, v_{13}\\}$.\n    *   Edge set: $E(A) = \\{(u_i, u_{i+1}) : i=1, \\dots, 12\\} \\cup \\{(v_i, v_{i+1}) : i=1, \\dots, 12\\} \\cup \\{(u_i, v_i) : i=1, \\dots, 13\\}$.\n*   **Component B**: A cycle graph $C_{20}$.\n    *   Vertex set: $V(B) = \\{w_1, \\dots, w_{20}\\}$.\n    *   Edge set: $E(B) = \\{(w_i, w_{i+1}) : i=1, \\dots, 19\\} \\cup \\{(w_{20}, w_1)\\}$.\n*   **$k$-core definition**: The maximal induced subgraph in which every vertex has a degree of at least $k$. It is obtained by iteratively removing all vertices of degree strictly less than $k$.\n*   **Onion decomposition definition**: For a fixed $k$, this is a process of layered removal.\n    1.  At wave $1$, identify all vertices in the graph under consideration with a current degree of at most $k$. These form layer $\\ell_k=1$.\n    2.  Remove these vertices.\n    3.  Recompute degrees in the remaining graph.\n    4.  Repeat the process, identifying vertices with a current degree of at most $k$ and assigning them to subsequent layers $\\ell_k=2, 3, \\dots$.\n*   **Within-shell onion-layer depth $D_k(H)$**: For a subgraph $H$ entirely contained in the $k$-shell, $D_k(H)$ is the maximum within-shell layer index $\\ell_k$ attained by any vertex of $H$.\n*   **Target Quantity**: The robustness gap $\\Delta \\equiv D_2(A) - D_2(B)$ for $k=2$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is grounded in the formal-mathematical field of graph theory and network science. The components of the graph are well-defined standard structures. The definitions for $k$-core and onion decomposition, while the latter might be a specific variant, are stated explicitly and provide a clear algorithmic procedure. A crucial condition is that the components $A$ and $B$ must be \"entirely contained in the $k$-shell\" for $k=2$. Let's verify this.\n\nFirst, we determine the vertex degrees in $G$. Since $G$ is a disjoint union, the degree of a vertex is its degree within its component.\n*   In component $A$ (ladder graph, $n=13$):\n    *   The four \"corner\" vertices $\\{u_1, v_1, u_{13}, v_{13}\\}$ each have $2$ neighbors. For example, $u_1$ is connected to $u_2$ and $v_1$. So, their degree is $2$.\n    *   The remaining $2 \\times (13-2) = 22$ vertices $\\{u_i, v_i\\}_{i=2}^{12}$ each have $3$ neighbors. For example, $u_i$ is connected to $u_{i-1}, u_{i+1}, v_i$. Their degree is $3$.\n*   In component $B$ (cycle graph $C_{20}$):\n    *   Every vertex is connected to two other vertices. Thus, all $20$ vertices have a degree of $2$.\n\nNext, we perform a $k$-core decomposition of $G$.\n*   The minimum degree in $G$ is $\\delta(G) = 2$.\n*   The $1$-core, $C_1(G)$, is found by removing vertices with degree $1$. There are none, so $C_1(G) = G$.\n*   The $2$-core, $C_2(G)$, is found by removing vertices with degree $2$. There are none, so $C_2(G) = G$.\n*   The $3$-core, $C_3(G)$, is found by iteratively removing vertices with degree $3$.\n    1.  Initially, all vertices in component $B$ (degree $2$) and the four corner vertices of component $A$ (degree $2$) must be removed.\n    2.  Removing the corner vertices $\\{u_1, v_1, u_{13}, v_{13}\\}$ from $A$ reduces the degrees of their neighbors $\\{u_2, v_2, u_{12}, v_{12}\\}$ from $3$ to $2$.\n    3.  In the next iteration, these newly created degree-$2$ vertices must also be removed.\n    4.  This removal process propagates inward from both ends of the ladder graph until all vertices of component $A$ are removed.\n    5.  Therefore, no vertices from $G$ survive this iterative removal. The $3$-core is the empty graph: $C_3(G) = \\emptyset$.\n\nThe $k$-shell is defined as the set of vertices in the $k$-core but not in the $(k+1)$-core. For $k=2$, the $2$-shell is $S_2 = C_2(G) \\setminus C_3(G)$.\n*   $S_2 = G \\setminus \\emptyset = G$.\nThe $2$-shell is the entire graph $G$. Components $A$ and $B$ are subgraphs of $G$, so they are \"entirely contained in the $2$-shell\". The problem's premise is satisfied. The definitions are sufficient and consistent for this specific problem.\n\n**Step 3: Verdict and Action**\n\nThe problem is scientifically grounded, well-posed, objective, and self-contained. It is deemed **valid**. We proceed to the solution.\n\n### Solution\n\nThe goal is to compute the robustness gap $\\Delta = D_2(A) - D_2(B)$. This requires finding the within-shell onion-layer depths, $D_2(A)$ and $D_2(B)$, using the provided onion decomposition algorithm for $k=2$. As established, the $2$-shell is the entire graph $G$, so the decomposition process starts with $G$ and involves iteratively removing vertices with a current degree of at most $2$.\n\n**Analysis of Component B ($C_{20}$)**\n\nComponent $B$ is a cycle graph $C_{20}$. Every one of its $20$ vertices has a degree of $2$.\n*   **Wave 1**: We identify all vertices in $G$ with degree $\\le 2$. All $20$ vertices of component $B$ meet this criterion. Thus, all vertices of $B$ are removed in the first wave.\n*   These vertices are assigned to layer $\\ell_2 = 1$.\n*   The maximum layer index for any vertex in component $B$ is $1$.\n*   Therefore, the within-shell onion-layer depth for $B$ at $k=2$ is $D_2(B) = 1$.\n\n**Analysis of Component A (Ladder Graph)**\n\nComponent $A$ is a ladder graph of length $n=13$. We apply the same iterative removal process. The degrees are computed in the graph as it evolves.\n\n*   **Initial State**: Component $A$ has $4$ vertices with degree $2$ (at indices $i=1$ and $i=13$) and $22$ vertices with degree $3$ (at indices $i=2, \\dots, 12$).\n*   **Wave 1 (Layer $\\ell_2=1$)**: We remove all vertices with degree $\\le 2$. These are the four corner vertices: $\\{u_1, v_1, u_{13}, v_{13}\\}$. These vertices constitute layer $\\ell_2=1$ for component $A$.\n*   **Wave 2 (Layer $\\ell_2=2$)**: After removing the Layer $1$ vertices, we recompute the degrees of the remaining vertices. The neighbors of the removed vertices are $\\{u_2, v_2, u_{12}, v_{12}\\}$.\n    *   The degree of $u_2$, initially $3$, becomes $2$ after its neighbor $u_1$ is removed.\n    *   The degree of $v_2$, initially $3$, becomes $2$ after its neighbor $v_1$ is removed.\n    *   The degree of $u_{12}$, initially $3$, becomes $2$ after its neighbor $u_{13}$ is removed.\n    *   The degree of $v_{12}$, initially $3$, becomes $2$ after its neighbor $v_{13}$ is removed.\n    *   All other remaining vertices, $\\{u_i,v_i\\}$ for $i \\in \\{3, \\dots, 11\\}$, are not adjacent to Layer $1$ vertices, so their degrees remain $3$.\n    *   In the second wave, we remove the new set of vertices with degree $\\le 2$, which is $\\{u_2, v_2, u_{12}, v_{12}\\}$. These vertices form layer $\\ell_2=2$.\n*   **Subsequent Waves**: This process continues, peeling the ladder graph from both ends towards the center. At each wave $j$, the vertices from rung-pairs $j$ and $(13-j+1)=14-j$ are removed.\n    *   Layer $\\ell_2=1$: Vertices from rungs $1$ and $13$.\n    *   Layer $\\ell_2=2$: Vertices from rungs $2$ and $12$.\n    *   Layer $\\ell_2=3$: Vertices from rungs $3$ and $11$.\n    *   Layer $\\ell_2=4$: Vertices from rungs $4$ and $10$.\n    *   Layer $\\ell_2=5$: Vertices from rungs $5$ and $9$.\n    *   Layer $\\ell_2=6$: Vertices from rungs $6$ and $8$.\n*   **Final Wave**: After Layer $6$ is removed, the only remaining vertices are those of the central rung, $i=7$, because $n=13$ is odd. The remaining vertices are $\\{u_7, v_7\\}$.\n    *   In the original graph $A$, $u_7$ was connected to $u_6, u_8$, and $v_7$, so its degree was $3$.\n    *   Similarly, $v_7$ was connected to $v_6, v_8$, and $u_7$, so its degree was $3$.\n    *   The vertices $\\{u_6, v_6\\}$ and $\\{u_8, v_8\\}$ are all part of layer $\\ell_2=6$. After their removal, the only remaining edge for $u_7$ is to $v_7$, and for $v_7$ is to $u_7$.\n    *   Thus, in the graph remaining after Wave 6, the degrees of both $u_7$ and $v_7$ become $1$.\n    *   In the next wave, we remove vertices with degree $\\le 2$. Both $u_7$ and $v_7$ satisfy this condition. They are removed.\n    *   These two vertices, $\\{u_7, v_7\\}$, constitute layer $\\ell_2=7$.\n\nThe peeling process for component $A$ takes $7$ waves. The maximum layer index assigned to any vertex in $A$ is $7$.\nIn general, for a ladder graph of length $n$, the number of layers in this peeling process is $\\lceil \\frac{n}{2} \\rceil$. For $n=13$, this is $\\lceil \\frac{13}{2} \\rceil = \\lceil 6.5 \\rceil = 7$.\nTherefore, the within-shell onion-layer depth for $A$ at $k=2$ is $D_2(A) = 7$.\n\n**Calculation of the Robustness Gap**\n\nThe robustness gap $\\Delta$ is defined as the difference between the depths of the two components:\n$$\n\\Delta = D_2(A) - D_2(B)\n$$\nSubstituting the calculated values:\n$$\n\\Delta = 7 - 1 = 6\n$$\nThe robustness gap between components $A$ and $B$ at shell $k=2$ is $6$.",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "The true value of network metrics like core and onion numbers is realized when they are used to solve practical problems. This final, computational exercise () bridges theory and application by asking you to design and evaluate network intervention strategies based on these advanced structural properties. By comparing a core-based targeting strategy to a simpler degree-based one in the context of a simulated contagion cascade, you will explore how a deeper understanding of network structure can lead to more effective control measures.",
            "id": "4270899",
            "problem": "You are given undirected simple graphs and asked to compare two node-targeting intervention strategies for mitigating contagion cascades under the Linear Threshold Model (LTM). Nodes are labeled by integers $0,1,\\dots,n-1$. The task is to implement a program that, for each test case, removes a budgeted set of nodes according to each strategy, runs the LTM cascade from a given seed set, and reports the final cascade sizes.\n\nDefinitions and foundational base:\n\n- Let $G=(V,E)$ be a finite undirected simple graph with vertex set $V=\\{0,1,\\dots,n-1\\}$ and edge set $E \\subseteq \\{\\{u,v\\} \\mid u,v \\in V, u \\neq v\\}$. Let $\\deg_G(v)$ denote the degree of node $v$ in $G$.\n\n- An immunization intervention is the removal of a set $I \\subseteq V$ of nodes, yielding the induced subgraph $G' = G[V \\setminus I]$.\n\n- The Linear Threshold Model (LTM) with homogeneous fractional threshold $\\theta \\in (0,1]$ evolves in discrete synchronous time $t=0,1,2,\\dots$ on $G'$. Given a seed set $S \\subseteq V \\setminus I$, the set of active nodes at time $t$ is $A_t \\subseteq V \\setminus I$ with $A_0 = S$. For each inactive node $v \\in (V \\setminus I) \\setminus A_t$, define the static threshold\n$$\nT(v) = \\max\\bigl(1,\\ \\lceil \\theta \\cdot \\deg_{G'}(v) \\rceil \\bigr).\n$$\nNode $v$ activates at time $t+1$ if and only if the number of its active neighbors in $G'$ at time $t$ is at least $T(v)$. Seeds remain active for all times. The process terminates at the minimal time $T^\\star$ such that $A_{T^\\star} = A_{T^\\star+1}$, and the cascade size is $|A_{T^\\star}|$.\n\n- The $k$-core of $G$ is the unique maximal induced subgraph in which all nodes have degree at least $k$. The core number $c(v)$ of a node $v$ is the maximum $k$ such that $v$ belongs to the $k$-core. Compute core numbers by iterative degree-based peeling.\n\n- The onion decomposition refines the $k$-core by layering. Define the following peeling process. Initialize a working graph $H \\leftarrow G$ and a global layer index $\\ell \\leftarrow 1$. While $H$ has nodes, let\n$$\nk = \\min_{v \\in V(H)} \\deg_H(v).\n$$\nDefine a wave-removal within the same $k$ as follows: while there exists a node $v \\in V(H)$ with $\\deg_H(v) \\le k$, remove simultaneously all such nodes and assign to each removed node $v$ its core number $c(v) \\leftarrow k$ and its onion layer $L(v) \\leftarrow \\ell$; then increment the global layer index $\\ell \\leftarrow \\ell+1$, update degrees in $H$, and repeat the wave-removal while there still exists a node with $\\deg_H(v) \\le k$. Once no such node remains, recompute the new $k$ as the minimum degree in the updated $H$ and continue. The process ends when $H$ is empty. Within a fixed core index $k$, larger onion layer $L(v)$ indicates that node $v$ is deeper toward the core.\n\nIntervention strategies:\n\n- Degree-based targeting: select a set $I_{\\mathrm{deg}}$ of $b$ nodes with the largest degrees in the original $G$, breaking ties by larger core number $c(v)$, then by larger onion layer $L(v)$, and finally by smaller node index. Formally, order nodes by the key $(-\\deg_G(v),-c(v),-L(v),v)$ and take the first $b$ nodes.\n\n- Core-based targeting: select a set $I_{\\mathrm{core}}$ of $b$ nodes with the largest core numbers, breaking ties by larger onion layer $L(v)$, then by larger degree, and finally by smaller node index. Formally, order nodes by the key $(-c(v),-L(v),-\\deg_G(v),v)$ and take the first $b$ nodes.\n\nFor each test case below, you must:\n\n1. Compute $c(v)$ and $L(v)$ on the given original graph $G$.\n2. Compute $I_{\\mathrm{deg}}$ and $I_{\\mathrm{core}}$ as specified.\n3. For each $I \\in \\{I_{\\mathrm{deg}}, I_{\\mathrm{core}}\\}$, form $G' = G[V \\setminus I]$, set seeds $S' = S \\cap (V \\setminus I)$, and run the LTM with the given $\\theta$ until convergence to obtain the final cascade size $|A_{T^\\star}|$.\n4. Record the pair of cascade sizes as two integers $N_{\\mathrm{deg}}$ and $N_{\\mathrm{core}}$ and also compute the integer difference $\\Delta = N_{\\mathrm{core}} - N_{\\mathrm{deg}}$.\n\nYour program must process the following test suite of cases, each given by $(n,E,S,\\theta,b)$:\n\n- Case $1$: $n=15$; edges\n$\nE = \\{(0,1),(1,2),(2,3),(3,4),(4,0),(0,2),(1,3),(2,4),(0,5),(1,6),(2,7),(3,8),(4,9),(10,11),(10,12),(10,13),(10,14),(10,0)\\};\n$\nseed set $S=\\{11,12,13\\}$; threshold $\\theta=0.5$; budget $b=2$.\n\n- Case $2$: $n=7$; edges\n$\nE = \\{(0,1),(0,2),(0,3),(0,4),(0,5),(0,6)\\};\n$\nseed set $S=\\{1,2\\}$; threshold $\\theta=0.5$; budget $b=1$.\n\n- Case $3$: $n=7$; edges\n$\nE = \\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,6)\\};\n$\nseed set $S=\\{0\\}$; threshold $\\theta=0.5$; budget $b=1$.\n\n- Case $4$: $n=8$; edges\n$\nE = \\{(0,1),(1,2),(2,0),(3,4),(4,5),(5,3),(2,3),(2,6),(3,7)\\};\n$\nseed set $S=\\{6,7\\}$; threshold $\\theta=0.5$; budget $b=1$.\n\nFinal output specification:\n\n- For each case in order, compute the triple $[N_{\\mathrm{deg}}, N_{\\mathrm{core}}, \\Delta]$ as defined above. Your program should produce a single line of output containing the results as a comma-separated list of these triples enclosed in square brackets, for example\n$\n[[N_{\\mathrm{deg}}^{(1)},N_{\\mathrm{core}}^{(1)},\\Delta^{(1)}],[N_{\\mathrm{deg}}^{(2)},N_{\\mathrm{core}}^{(2)},\\Delta^{(2)}],\\dots]\n$\nwith no extra whitespace beyond commas and brackets, and no explanatory text.\n\nAll numbers in the output must be integers.",
            "solution": "The user wants to solve a problem from the field of network science. The task is to evaluate two node-targeting strategies, degree-based and core-based, for their effectiveness in mitigating a contagion cascade simulated by the Linear Threshold Model (LTM) on a given set of graphs.\n\nThe problem is well-defined, scientifically grounded, and algorithmically specified. It relies on standard concepts from network science, such as degree, $k$-core decomposition, and the LTM. It introduces a specific, but rigorously defined, \"onion decomposition\" to refine the $k$-core structure, which is used for tie-breaking in the targeting strategies. The problem statement is self-contained, providing all necessary definitions, including the precise sorting keys for node selection and the formula for the LTM activation threshold. The test cases are explicit and the output format is unambiguous. Therefore, the problem is valid and a solution can be constructed.\n\nThe solution proceeds in four main stages for each test case:\n1.  **Computation of Node Properties**: First, we must characterize each node in the original graph $G=(V,E)$ by its structural properties. This includes its degree $\\deg_G(v)$, its core number $c(v)$, and its onion layer $L(v)$.\n    *   The degree $\\deg_G(v)$ is the number of edges incident to node $v$.\n    *   The core number $c(v)$ and onion layer $L(v)$ are computed via the specified onion decomposition algorithm. This is a refined peeling process. We maintain a working copy of the graph, $H$. In a loop, we find the minimum degree $k$ in $H$. Then, in an inner \"wave\" loop, we repeatedly identify and simultaneously remove all nodes with degree less than or equal to $k$. All nodes removed in a single wave are assigned the current core number $k$ and a global, incrementing layer index $\\ell$. This inner loop continues with the same $k$ but an incremented $\\ell$ until no more nodes can be removed. Then, a new minimum degree is found in the reduced $H$ and the process repeats until $H$ is empty.\n\n2.  **Node Selection for Intervention**: With the node properties computed, we can implement the two intervention strategies. Each strategy selects a set of $b$ nodes to remove from the graph.\n    *   **Degree-based targeting ($I_{\\mathrm{deg}}$)**: Nodes are ranked in descending order of a multi-level key: $(\\deg_G(v), c(v), L(v))$, with final ties broken by ascending node index $v$. The top $b$ nodes are selected for removal.\n    *   **Core-based targeting ($I_{\\mathrm{core}}$)**: Nodes are ranked in descending order of the key: $(c(v), L(v), \\deg_G(v))$, with final ties broken by ascending node index $v$. The top $b$ nodes are selected.\n\n3.  **Cascade Simulation**: For each intervention set $I \\in \\{I_{\\mathrm{deg}}, I_{\\mathrm{core}}\\}$, we simulate the contagion cascade.\n    *   An induced subgraph $G' = G[V \\setminus I]$ is formed by removing the nodes in $I$ and their incident edges.\n    *   The initial set of active nodes (seeds) is updated to $S' = S \\cap (V \\setminus I)$, as some original seeds may have been removed. The initial active set is $A_0 = S'$.\n    *   The Linear Threshold Model (LTM) is simulated in discrete, synchronous time steps. At each step $t$, we check every inactive node $v \\in (V \\setminus I) \\setminus A_t$. Node $v$ becomes active at time $t+1$ if the number of its neighbors in $A_t$ meets or exceeds its activation threshold $T(v) = \\max\\bigl(1,\\ \\lceil \\theta \\cdot \\deg_{G'}(v) \\rceil \\bigr)$. The degree $\\deg_{G'}(v)$ is calculated in the reduced graph $G'$.\n    *   The simulation continues until a step occurs where no new nodes become active. The final cascade size is the total number of active nodes, $|A_{T^\\star}|$. This size is recorded as $N_{\\mathrm{deg}}$ or $N_{\\mathrm{core}}$ depending on the strategy used.\n\n4.  **Result Aggregation**: Finally, for each test case, we compute the difference $\\Delta = N_{\\mathrm{core}} - N_{\\mathrm{deg}}$ and assemble the results into the specified triple $[N_{\\mathrm{deg}}, N_{\\mathrm{core}}, \\Delta]$. These triples are collected from all test cases and formatted into a single output line.\n\nThe implementation will consist of helper functions for the onion decomposition and LTM simulation, orchestrated by a main function that processes each test case according to the steps above.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef compute_onion_decomposition(n, adj):\n    \"\"\"\n    Computes core numbers and onion layers for all nodes in a graph.\n    \n    The algorithm is a specific peeling process defined in the problem.\n    It computes both a core number 'c' and an onion layer 'L'.\n    \"\"\"\n    if n == 0:\n        return [], []\n\n    adj_copy = {u: neighbors.copy() for u, neighbors in adj.items()}\n    degrees = {u: len(neighbors) for u, neighbors in adj_copy.items()}\n    \n    for i in range(n):\n        if i not in degrees:\n            degrees[i] = 0\n\n    c_nums = np.full(n, -1, dtype=int)\n    l_nums = np.full(n, -1, dtype=int)\n    \n    ell = 1\n    remaining_nodes = set(range(n))\n\n    while remaining_nodes:\n        if not remaining_nodes:\n            break\n\n        min_k = min(degrees[v] for v in remaining_nodes)\n\n        while True:\n            to_peel = {v for v in remaining_nodes if degrees[v] = min_k}\n\n            if not to_peel:\n                break\n\n            for v in to_peel:\n                c_nums[v] = min_k\n                l_nums[v] = ell\n            \n            ell += 1\n            \n            neighbors_to_update = set()\n            for v_peeled in to_peel:\n                if v_peeled in adj_copy:\n                    neighbors_to_update.update(adj_copy[v_peeled])\n\n            for neighbor in neighbors_to_update:\n                if neighbor in remaining_nodes and neighbor not in to_peel:\n                    lost_neighbors = len(adj_copy[neighbor].intersection(to_peel))\n                    degrees[neighbor] -= lost_neighbors\n            \n            remaining_nodes -= to_peel\n\n    return c_nums.tolist(), l_nums.tolist()\n\ndef run_ltm_cascade(n, adj, seeds, theta, removed_nodes):\n    \"\"\"\n    Runs the Linear Threshold Model simulation on a graph after removing nodes.\n    \"\"\"\n    nodes_in_g_prime = set(range(n)) - set(removed_nodes)\n    if not nodes_in_g_prime:\n        return 0\n\n    adj_prime = {u: adj.get(u, set()).intersection(nodes_in_g_prime) for u in nodes_in_g_prime}\n    degs_prime = {u: len(neighbors) for u, neighbors in adj_prime.items()}\n\n    active_nodes = set(seeds).intersection(nodes_in_g_prime)\n    \n    while True:\n        newly_activated = set()\n        inactive_nodes = nodes_in_g_prime - active_nodes\n\n        for v in inactive_nodes:\n            deg_v = degs_prime.get(v, 0)\n            threshold = math.ceil(theta * deg_v) if deg_v > 0 else 1\n            threshold = max(1, threshold)\n            \n            active_neighbors_count = len(adj_prime.get(v, set()).intersection(active_nodes))\n            \n            if active_neighbors_count >= threshold:\n                newly_activated.add(v)\n        \n        if not newly_activated:\n            break\n            \n        active_nodes.update(newly_activated)\n\n    return len(active_nodes)\n\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        (15, \n         {(0,1),(1,2),(2,3),(3,4),(4,0),(0,2),(1,3),(2,4),(0,5),(1,6),(2,7),(3,8),(4,9),(10,11),(10,12),(10,13),(10,14),(10,0)},\n         {11,12,13}, 0.5, 2),\n        (7,\n         {(0,1),(0,2),(0,3),(0,4),(0,5),(0,6)},\n         {1,2}, 0.5, 1),\n        (7,\n         {(0,1),(1,2),(2,3),(3,4),(4,5),(5,6)},\n         {0}, 0.5, 1),\n        (8,\n         {(0,1),(1,2),(2,0),(3,4),(4,5),(5,3),(2,3),(2,6),(3,7)},\n         {6,7}, 0.5, 1)\n    ]\n\n    all_results = []\n    for n, edges, S, theta, b in test_cases:\n        adj = {i: set() for i in range(n)}\n        for u, v in edges:\n            adj[u].add(v)\n            adj[v].add(u)\n\n        degs_G = {i: len(adj.get(i, set())) for i in range(n)}\n        core_numbers, onion_layers = compute_onion_decomposition(n, adj)\n\n        nodes = list(range(n))\n\n        # Degree-based targeting\n        key_deg = lambda v: (-degs_G[v], -core_numbers[v], -onion_layers[v], v)\n        nodes.sort(key=key_deg)\n        I_deg = set(nodes[:b])\n\n        # Core-based targeting\n        key_core = lambda v: (-core_numbers[v], -onion_layers[v], -degs_G[v], v)\n        nodes.sort(key=key_core)\n        I_core = set(nodes[:b])\n\n        # Run simulations\n        N_deg = run_ltm_cascade(n, adj, S, theta, I_deg)\n        N_core = run_ltm_cascade(n, adj, S, theta, I_core)\n        \n        Delta = N_core - N_deg\n        all_results.append(f\"[{N_deg},{N_core},{Delta}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}