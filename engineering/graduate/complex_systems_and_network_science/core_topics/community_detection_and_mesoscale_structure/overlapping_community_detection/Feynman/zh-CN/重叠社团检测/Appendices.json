{
    "hands_on_practices": [
        {
            "introduction": "团簇渗透方法（Clique Percolation Method, CPM）是一种直观的重叠社区发现算法，它基于社区是节点紧密连接的群组这一理念。本练习将引导你将CPM应用于一个特制的网络图，观察它是如何识别社区，以及关键地，识别那些连接不同社区的桥接节点。通过这个实践，你将具体地感受到局部密度如何涌现出全局的社区结构。",
            "id": "4295744",
            "problem": "考虑一个按如下方式构造的简单无向图 $G$。图中存在两个三角形环，记为环 $\\mathcal{A}$ 和环 $\\mathcal{B}$，它们仅在一个节点上接触，不共享任何边。环 $\\mathcal{A}$ 的节点集为 $\\{a_0, a_1, a_2, a_3, a_4, a_5\\}$，环 $\\mathcal{B}$ 的节点集为 $\\{b_0, b_1, b_2, b_3, b_4, b_5, b_6, b_7\\}$。将 $a_0$ 与 $b_0$ 等同，使得存在一个共享节点 $x$，满足 $x = a_0 = b_0$，并假设两个环的节点之间没有其他等同关系或边。对于环 $\\mathcal{A}$，对每个 $i \\in \\{0,1,2,3,4,5\\}$（下标模 $6$），在三元组 $\\{a_i, a_{i+1}, a_{i+2}\\}$ 中包含所有三条边，使得每个这样的三元组都构成一个三角形。对于环 $\\mathcal{B}$，对每个 $j \\in \\{0,1,2,3,4,5,6,7\\}$（下标模 $8$），在三元组 $\\{b_j, b_{j+1}, b_{j+2}\\}$ 中包含所有三条边，使得每个这样的三元组都构成一个三角形。图 $G$ 中不存在其他边。\n\n使用团渗透法（CPM），团大小 $k=3$，基于以下基本定义：\n\n- 一个 $k$-团是一组 $k$ 个节点，其中任意两个节点之间都有一条边相连。\n- 如果两个 $k$-团恰好共享 $k-1$ 个节点，则称它们是相邻的。\n- 一个 $k$-团渗透社区是 $k$-团的最大并集，其中并集中的任意一对 $k$-团都通过一条由相邻 $k$-团构成的路径相连；一个社区的节点集是其包含的 $k$-团中所有节点的并集。\n\n请确定图 $G$ 中 $k=3$ 的 CPM 社区，找出所有属于多个社区的节点，然后计算这两个 CPM 社区节点集之间的杰卡德相似系数（Jaccard similarity coefficient），其定义为对于两个集合 $X$ 和 $Y$，$J(X,Y) = \\frac{|X \\cap Y|}{|X \\cup Y|}$。将最终答案表示为最简分数。无需四舍五入。",
            "solution": "问题要求对一个特殊构造的图 $G$，使用团渗透法（CPM）和团大小 $k=3$ 来确定社区，然后计算所识别出的社区之间的杰卡德相似系数。分析过程遵循一系列逻辑步骤。\n\n### 第1步：识别 $k=3$ 的团\n\n一个 $k$-团是一个由 $k$ 个节点构成的完全子图。对于 $k=3$，一个 $3$-团就是一个三角形。问题陈述明确定义了图 $G$ 中存在的三角形。\n\n图 $G$ 由两个子图组成，即环 $\\mathcal{A}$ 和环 $\\mathcal{B}$，它们在一个单一节点 $x$ 处连接，其中 $x=a_0=b_0$。\n\n**环 $\\mathcal{A}$ 中的团：**\n节点集为 $\\{a_0, a_1, a_2, a_3, a_4, a_5\\}$。三角形由集合 $\\{a_i, a_{i+1}, a_{i+2}\\}$ 构成，其中 $i \\in \\{0, 1, 2, 3, 4, 5\\}$，下标模 $6$。环 $\\mathcal{A}$ 中的 $6$ 个三角形集合为：\n\\begin{itemize}\n    \\item $C_{A,0} = \\{a_0, a_1, a_2\\}$\n    \\item $C_{A,1} = \\{a_1, a_2, a_3\\}$\n    \\item $C_{A,2} = \\{a_2, a_3, a_4\\}$\n    \\item $C_{A,3} = \\{a_3, a_4, a_5\\}$\n    \\item $C_{A,4} = \\{a_4, a_5, a_0\\}$\n    \\item $C_{A,5} = \\{a_5, a_0, a_1\\}$\n\\end{itemize}\n\n**环 $\\mathcal{B}$ 中的团：**\n节点集为 $\\{b_0, b_1, b_2, b_3, b_4, b_5, b_6, b_7\\}$。三角形由集合 $\\{b_j, b_{j+1}, b_{j+2}\\}$ 构成，其中 $j \\in \\{0, 1, 2, 3, 4, 5, 6, 7\\}$，下标模 $8$。环 $\\mathcal{B}$ 中的 $8$ 个三角形集合为：\n\\begin{itemize}\n    \\item $C_{B,0} = \\{b_0, b_1, b_2\\}$\n    \\item $C_{B,1} = \\{b_1, b_2, b_3\\}$\n    \\item $C_{B,2} = \\{b_2, b_3, b_4\\}$\n    \\item $C_{B,3} = \\{b_3, b_4, b_5\\}$\n    \\item $C_{B,4} = \\{b_4, b_5, b_6\\}$\n    \\item $C_{B,5} = \\{b_5, b_6, b_7\\}$\n    \\item $C_{B,6} = \\{b_6, b_7, b_0\\}$\n    \\item $C_{B,7} = \\{b_7, b_0, b_1\\}$\n\\end{itemize}\n\n图 $G$ 中不存在其他边或三角形。\n\n### 第2步：$k=3$ 团的邻接性\n\n根据 CPM 的定义，如果两个 $k$-团恰好共享 $k-1$ 个节点，则它们是相邻的。对于 $k=3$，这意味着两个三角形必须恰好共享 $3-1 = 2$ 个节点（即一条边）。\n\n**环 $\\mathcal{A}$ 内部的邻接性：**\n考虑任意两个连续索引的三角形，例如 $C_{A,i} = \\{a_i, a_{i+1}, a_{i+2}\\}$ 和 $C_{A,i+1} = \\{a_{i+1}, a_{i+2}, a_{i+3}\\}$。它们的交集是 $C_{A,i} \\cap C_{A,i+1} = \\{a_{i+1}, a_{i+2}\\}$。这个交集的大小为 $2$。因此，对于所有的 $i \\in \\{0, 1, ..., 5\\}$，$C_{A,i}$ 和 $C_{A,i+1}$ 都是相邻的。这形成了一条由相邻团构成的路径：\n$$ C_{A,0} \\leftrightarrow C_{A,1} \\leftrightarrow C_{A,2} \\leftrightarrow C_{A,3} \\leftrightarrow C_{A,4} \\leftrightarrow C_{A,5} \\leftrightarrow C_{A,0} $$\n由于环 $\\mathcal{A}$ 中的所有 $6$ 个三角形都通过一条由相邻团构成的路径相连，它们形成了一个单一的最大连通分量。\n\n**环 $\\mathcal{B}$ 内部的邻接性：**\n类似地，对于环 $\\mathcal{B}$，考虑 $C_{B,j} = \\{b_j, b_{j+1}, b_{j+2}\\}$ 和 $C_{B,j+1} = \\{b_{j+1}, b_{j+2}, b_{j+3}\\}$。它们的交集是 $C_{B,j} \\cap C_{B,j+1} = \\{b_{j+1}, b_{j+2}\\}$，其大小为 $2$。因此，对于所有的 $j \\in \\{0, 1, ..., 7\\}$，$C_{B,j}$ 和 $C_{B,j+1}$ 都是相邻的。这也形成了一个由相邻团构成的环。环 $\\mathcal{B}$ 中的所有 $8$ 个三角形都属于一个单一的最大连通分量。\n\n**环 $\\mathcal{A}$ 与环 $\\mathcal{B}$ 之间的邻接性：**\n要使环 $\\mathcal{A}$ 中的一个团与环 $\\mathcal{B}$ 中的一个团相邻，它们必须共享 $2$ 个节点。环 $\\mathcal{A}$ 的节点是 $\\{a_0, ..., a_5\\}$，环 $\\mathcal{B}$ 的节点是 $\\{b_0, ..., b_7\\}$。问题规定这些集合之间唯一的等同关系是 $a_0 = b_0 = x$。因此，两个环的节点集的交集仅为 $\\{x\\}$。环 $\\mathcal{A}$ 中的任意一个团和环 $\\mathcal{B}$ 中的任意一个团最多只能共享这一个节点。由于它们不能共享 $2$ 个节点，所以环 $\\mathcal{A}$ 中的任何团都不与环 $\\mathcal{B}$ 中的任何团相邻。\n\n### 第3步：CPM 社区与重叠节点\n\n$k$-团渗透社区是通过邻接关系路径连接的 $k$-团的最大并集。根据以上分析，恰好存在两个这样的社区。\n\n**社区 1 ($X$)：**\n该社区由环 $\\mathcal{A}$ 中所有团的并集形成。该社区的节点集，记为 $X$，是这些团中节点的并集：\n$$ X = \\bigcup_{i=0}^{5} C_{A,i} = \\{a_0, a_1, a_2, a_3, a_4, a_5\\} $$\n该社区中的节点数为 $|X| = 6$。\n\n**社区 2 ($Y$)：**\n该社区由环 $\\mathcal{B}$ 中所有团的并集形成。该社区的节点集，记为 $Y$，是：\n$$ Y = \\bigcup_{j=0}^{7} C_{B,j} = \\{b_0, b_1, b_2, b_3, b_4, b_5, b_6, b_7\\} $$\n该社区中的节点数为 $|Y| = 8$。\n\n属于多个社区的节点是节点集 $X$ 和 $Y$ 交集中的节点。\n$$ X \\cap Y = \\{a_0, a_1, a_2, a_3, a_4, a_5\\} \\cap \\{b_0, b_1, \\dots, b_7\\} $$\n鉴于 $a_0 = b_0 = x$是唯一的共享节点，交集为：\n$$ X \\cap Y = \\{x\\} $$\n重叠节点的数量为 $|X \\cap Y| = 1$。唯一的重叠节点是 $x$。\n\n### 第4步：杰卡德相似系数\n\n两个集合 $X$ 和 $Y$ 之间的杰卡德相似系数定义为 $J(X,Y) = \\frac{|X \\cap Y|}{|X \\cup Y|}$。\n\n我们已经得到 $|X \\cap Y| = 1$。\n节点集并集的大小可以使用容斥原理计算：\n$$ |X \\cup Y| = |X| + |Y| - |X \\cap Y| $$\n代入已知值：\n$$ |X \\cup Y| = 6 + 8 - 1 = 13 $$\n这个值是图 $G$ 中不同节点的总数。\n\n现在，我们可以计算杰卡德相似系数：\n$$ J(X,Y) = \\frac{|X \\cap Y|}{|X \\cup Y|} = \\frac{1}{13} $$\n分数 $\\frac{1}{13}$ 是其最简形式。",
            "answer": "$$\\boxed{\\frac{1}{13}}$$"
        },
        {
            "introduction": "在学习了像CPM这样的局部、非参数化方法之后，我们转向一种全局性的、基于模型的方法。对称非负矩阵分解（Symmetric Nonnegative Matrix Factorization, SNMF）是一种强大的技术，它将整个网络的结构表示为节点-社区隶属度矩阵的乘积。本练习将更深入一步，要求你推导出其核心学习算法（即乘法更新规则），从而让你洞察寻找社区结构的优化过程是如何运作的。",
            "id": "4295754",
            "problem": "考虑一个包含 $n=4$ 个节点和 $r=2$ 个重叠社区的简单无向网络。设该网络由对称邻接矩阵表示\n$$\nA=\\begin{pmatrix}\n0  1  1  0 \\\\\n1  0  1  1 \\\\\n1  1  0  1 \\\\\n0  1  1  0\n\\end{pmatrix}.\n$$\n在通过对称非负矩阵分解 (Symmetric Nonnegative Matrix Factorization, SNMF) 进行重叠社区检测时，我们寻求一个非负隶属度矩阵 $U\\in\\mathbb{R}_{\\ge 0}^{n\\times r}$，其行编码了软隶属关系，方法是最小化以下目标函数\n$$\n\\min_{U\\ge 0}\\; \\frac{1}{2}\\,\\|A-UU^{\\top}\\|_{F}^{2}.\n$$\n从这个目标函数出发，利用第一性原理（弗罗贝尼乌斯范数的定义、矩阵微积分以及针对非负性约束的卡罗需-库恩-塔克 (Karush–Kuhn–Tucker, KKT) 条件），推导出标准的乘法更新规则。该规则能保持非负性，并且已知在对称情况下能单调递减目标函数。\n\n使用该更新规则，将隶属度矩阵初始化为\n$$\nU^{(0)}=\\begin{pmatrix}\n1  1 \\\\\n1  1 \\\\\n1  1 \\\\\n1  1\n\\end{pmatrix},\n$$\n并执行整整两次完整迭代以获得 $U^{(1)}$ 和 $U^{(2)}$。令 $S$ 表示第二次迭代后的总隶属度质量，\n$$\nS=\\sum_{i=1}^{n}\\sum_{k=1}^{r}U^{(2)}_{ik}.\n$$\n计算 $S$。将最终答案表示为一个精确的有理数。无需单位。",
            "solution": "该问题是有效的，因为它具有科学依据、适定且客观。它展示了对称非负矩阵分解 (SNMF) 在重叠社区检测中的一个标准应用。我们将首先推导乘法更新规则，然后应用该规则进行两次迭代。\n\n**第 1 部分：乘法更新规则的推导**\n\n目标是在 $U$ 的非负性约束下最小化函数 $L(U)$：\n$$\n\\min_{U \\ge 0} L(U) = \\min_{U \\ge 0} \\frac{1}{2} \\|A - UU^{\\top}\\|_F^2\n$$\n该约束优化问题的拉格朗日函数为：\n$$\n\\mathcal{L}(U, \\Lambda) = L(U) - \\sum_{i=1}^{n}\\sum_{k=1}^{r} \\Lambda_{ik} U_{ik}\n$$\n其中 $\\Lambda_{ik} \\ge 0$ 是与约束 $U_{ik} \\ge 0$ 相关的卡罗需-库恩-塔克 (KKT) 乘子。\n\n第一步是计算 $L(U)$ 相对于元素 $U_{ab}$ 的梯度。\n$$\nL(U) = \\frac{1}{2}\\sum_{i=1}^{n}\\sum_{j=1}^{n} \\left(A_{ij} - (UU^{\\top})_{ij}\\right)^2 = \\frac{1}{2}\\sum_{i,j} \\left(A_{ij} - \\sum_{k=1}^{r} U_{ik}U_{jk}\\right)^2\n$$\n相对于 $U_{ab}$ 的偏导数为：\n$$\n\\frac{\\partial L}{\\partial U_{ab}} = \\sum_{i,j} \\left(A_{ij} - \\sum_{k} U_{ik}U_{jk}\\right) \\left(-\\frac{\\partial}{\\partial U_{ab}}\\sum_{k} U_{ik}U_{jk}\\right)\n$$\n内层和的导数为：\n$$\n\\frac{\\partial}{\\partial U_{ab}}\\sum_{k} U_{ik}U_{jk} = \\sum_{k} \\left( \\delta_{ia}\\delta_{kb}U_{jk} + U_{ik}\\delta_{ja}\\delta_{kb} \\right) = \\delta_{ia}U_{jb} + U_{ib}\\delta_{ja}\n$$\n将此代回梯度表达式：\n$$\n\\frac{\\partial L}{\\partial U_{ab}} = -\\sum_{i,j} (A_{ij} - (UU^{\\top})_{ij}) (\\delta_{ia}U_{jb} + U_{ib}\\delta_{ja}) = -\\sum_{j} (A_{aj} - (UU^{\\top})_{aj})U_{jb} - \\sum_{i} (A_{ib} - (UU^{\\top})_{ib})U_{ib}\n$$\n由于 $A$ 和 $UU^{\\top}$ 是对称的，这两项是相同的。因此：\n$$\n\\frac{\\partial L}{\\partial U_{ab}} = -2 \\sum_{j} (A_{aj} - (UU^{\\top})_{aj}) U_{jb} = -2\\left((AU)_{ab} - (UU^{\\top}U)_{ab}\\right) = 2\\left((UU^{\\top}U)_{ab} - (AU)_{ab}\\right)\n$$\nKKT 平稳性条件是 $\\frac{\\partial \\mathcal{L}}{\\partial U_{ab}} = \\frac{\\partial L}{\\partial U_{ab}} - \\Lambda_{ab} = 0$，可得 $\\Lambda_{ab} = 2((UU^{\\top}U)_{ab} - (AU)_{ab})$。\nKKT 互补松弛性条件是 $\\Lambda_{ab}U_{ab} = 0$。将它们结合起来可得：\n$$\n\\left( (UU^{\\top}U)_{ab} - (AU)_{ab} \\right) U_{ab} = 0\n$$\n这是一个不动点方程。通过重新整理可以推导出乘法更新规则：\n$$\n(UU^{\\top}U)_{ab} U_{ab} = (AU)_{ab} U_{ab}\n$$\n这启发了以下更新规则：\n$$\nU_{ab} \\leftarrow U_{ab} \\frac{(AU)_{ab}}{(UU^{\\top}U)_{ab}}\n$$\n这是标准的乘法更新规则。对于迭代 $t$，其迭代形式为：\n$$\nU^{(t+1)}_{ik} = U^{(t)}_{ik} \\frac{(A U^{(t)})_{ik}}{(U^{(t)} (U^{(t)})^{\\top} U^{(t)})_{ik}}\n$$\n\n**第 2 部分：迭代计算**\n\n给定：\n$$\nA = \\begin{pmatrix} 0  1  1  0 \\\\ 1  0  1  1 \\\\ 1  1  0  1 \\\\ 0  1  1  0 \\end{pmatrix}, \\quad U^{(0)} = \\begin{pmatrix} 1  1 \\\\ 1  1 \\\\ 1  1 \\\\ 1  1 \\end{pmatrix}\n$$\n\n**迭代 1：计算 $U^{(1)}$**\n\n分子项 $N^{(0)} = A U^{(0)}$：\n$$\nA U^{(0)} = \\begin{pmatrix} 0  1  1  0 \\\\ 1  0  1  1 \\\\ 1  1  0  1 \\\\ 0  1  1  0 \\end{pmatrix} \\begin{pmatrix} 1  1 \\\\ 1  1 \\\\ 1  1 \\\\ 1  1 \\end{pmatrix} = \\begin{pmatrix} 2  2 \\\\ 3  3 \\\\ 3  3 \\\\ 2  2 \\end{pmatrix}\n$$\n分母项 $D^{(0)} = U^{(0)} (U^{(0)})^{\\top} U^{(0)}$：\n$$\n(U^{(0)})^{\\top} U^{(0)} = \\begin{pmatrix} 1  1  1  1 \\\\ 1  1  1  1 \\end{pmatrix} \\begin{pmatrix} 1  1 \\\\ 1  1 \\\\ 1  1 \\\\ 1  1 \\end{pmatrix} = \\begin{pmatrix} 4  4 \\\\ 4  4 \\end{pmatrix}\n$$\n$$\nD^{(0)} = U^{(0)} \\left( (U^{(0)})^{\\top} U^{(0)} \\right) = \\begin{pmatrix} 1  1 \\\\ 1  1 \\\\ 1  1 \\\\ 1  1 \\end{pmatrix} \\begin{pmatrix} 4  4 \\\\ 4  4 \\end{pmatrix} = \\begin{pmatrix} 8  8 \\\\ 8  8 \\\\ 8  8 \\\\ 8  8 \\end{pmatrix}\n$$\n应用更新规则（其中 $\\odot$ 是逐元素乘法，除法也是逐元素的）：\n$$\nU^{(1)} = U^{(0)} \\odot \\frac{N^{(0)}}{D^{(0)}} = \\begin{pmatrix} 1  1 \\\\ 1  1 \\\\ 1  1 \\\\ 1  1 \\end{pmatrix} \\odot \\begin{pmatrix} \\frac{2}{8}  \\frac{2}{8} \\\\ \\frac{3}{8}  \\frac{3}{8} \\\\ \\frac{3}{8}  \\frac{3}{8} \\\\ \\frac{2}{8}  \\frac{2}{8} \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{4}  \\frac{1}{4} \\\\ \\frac{3}{8}  \\frac{3}{8} \\\\ \\frac{3}{8}  \\frac{3}{8} \\\\ \\frac{1}{4}  \\frac{1}{4} \\end{pmatrix}\n$$\n\n**迭代 2：计算 $U^{(2)}$**\n\n分子项 $N^{(1)} = A U^{(1)}$：\n$$\nA U^{(1)} = \\begin{pmatrix} 0  1  1  0 \\\\ 1  0  1  1 \\\\ 1  1  0  1 \\\\ 0  1  1  0 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{4}  \\frac{1}{4} \\\\ \\frac{3}{8}  \\frac{3}{8} \\\\ \\frac{3}{8}  \\frac{3}{8} \\\\ \\frac{1}{4}  \\frac{1}{4} \\end{pmatrix} = \\begin{pmatrix} \\frac{3}{8}+\\frac{3}{8}  \\frac{3}{8}+\\frac{3}{8} \\\\ \\frac{1}{4}+\\frac{3}{8}+\\frac{1}{4}  \\frac{1}{4}+\\frac{3}{8}+\\frac{1}{4} \\\\ \\frac{1}{4}+\\frac{3}{8}+\\frac{1}{4}  \\frac{1}{4}+\\frac{3}{8}+\\frac{1}{4} \\\\ \\frac{3}{8}+\\frac{3}{8}  \\frac{3}{8}+\\frac{3}{8} \\end{pmatrix} = \\begin{pmatrix} \\frac{6}{8}  \\frac{6}{8} \\\\ \\frac{7}{8}  \\frac{7}{8} \\\\ \\frac{7}{8}  \\frac{7}{8} \\\\ \\frac{6}{8}  \\frac{6}{8} \\end{pmatrix} = \\begin{pmatrix} \\frac{3}{4}  \\frac{3}{4} \\\\ \\frac{7}{8}  \\frac{7}{8} \\\\ \\frac{7}{8}  \\frac{7}{8} \\\\ \\frac{3}{4}  \\frac{3}{4} \\end{pmatrix}\n$$\n分母项 $D^{(1)} = U^{(1)} (U^{(1)})^{\\top} U^{(1)}$：\n$$\n(U^{(1)})^{\\top} U^{(1)} = \\begin{pmatrix} \\frac{1}{4}  \\frac{3}{8}  \\frac{3}{8}  \\frac{1}{4} \\\\ \\frac{1}{4}  \\frac{3}{8}  \\frac{3}{8}  \\frac{1}{4} \\end{pmatrix} \\begin{pmatrix} \\frac{1}{4}  \\frac{1}{4} \\\\ \\frac{3}{8}  \\frac{3}{8} \\\\ \\frac{3}{8}  \\frac{3}{8} \\\\ \\frac{1}{4}  \\frac{1}{4} \\end{pmatrix} = \\begin{pmatrix} 2(\\frac{1}{16}) + 2(\\frac{9}{64})  2(\\frac{1}{16}) + 2(\\frac{9}{64}) \\\\ 2(\\frac{1}{16}) + 2(\\frac{9}{64})  2(\\frac{1}{16}) + 2(\\frac{9}{64}) \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{8}+\\frac{9}{32}  \\frac{1}{8}+\\frac{9}{32} \\\\ \\frac{1}{8}+\\frac{9}{32}  \\frac{1}{8}+\\frac{9}{32} \\end{pmatrix} = \\begin{pmatrix} \\frac{13}{32}  \\frac{13}{32} \\\\ \\frac{13}{32}  \\frac{13}{32} \\end{pmatrix}\n$$\n$$\nD^{(1)} = U^{(1)} \\left( (U^{(1)})^{\\top} U^{(1)} \\right) = \\begin{pmatrix} \\frac{1}{4}  \\frac{1}{4} \\\\ \\frac{3}{8}  \\frac{3}{8} \\\\ \\frac{3}{8}  \\frac{3}{8} \\\\ \\frac{1}{4}  \\frac{1}{4} \\end{pmatrix} \\begin{pmatrix} \\frac{13}{32}  \\frac{13}{32} \\\\ \\frac{13}{32}  \\frac{13}{32} \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2}(\\frac{13}{32})  \\frac{1}{2}(\\frac{13}{32}) \\\\ \\frac{3}{4}(\\frac{13}{32})  \\frac{3}{4}(\\frac{13}{32}) \\\\ \\frac{3}{4}(\\frac{13}{32})  \\frac{3}{4}(\\frac{13}{32}) \\\\ \\frac{1}{2}(\\frac{13}{32})  \\frac{1}{2}(\\frac{13}{32}) \\end{pmatrix} = \\begin{pmatrix} \\frac{13}{64}  \\frac{13}{64} \\\\ \\frac{39}{128}  \\frac{39}{128} \\\\ \\frac{39}{128}  \\frac{39}{128} \\\\ \\frac{13}{64}  \\frac{13}{64} \\end{pmatrix}\n$$\n应用更新规则计算 $U^{(2)}$：\n$$\nU^{(2)} = U^{(1)} \\odot \\frac{N^{(1)}}{D^{(1)}}\n$$\n对于第 1 行和第 4 行：\n$U^{(2)}_{1k} = U^{(2)}_{4k} = U^{(1)}_{1k} \\frac{N^{(1)}_{1k}}{D^{(1)}_{1k}} = \\frac{1}{4} \\frac{\\frac{3}{4}}{\\frac{13}{64}} = \\frac{1}{4} \\frac{3}{4} \\frac{64}{13} = \\frac{3 \\times 16}{4 \\times 13} = \\frac{12}{13}$\n对于第 2 行和第 3 行：\n$U^{(2)}_{2k} = U^{(2)}_{3k} = U^{(1)}_{2k} \\frac{N^{(1)}_{2k}}{D^{(1)}_{2k}} = \\frac{3}{8} \\frac{\\frac{7}{8}}{\\frac{39}{128}} = \\frac{3}{8} \\frac{7}{8} \\frac{128}{39} = \\frac{21}{64} \\frac{128}{39} = \\frac{21 \\times 2}{39} = \\frac{42}{39} = \\frac{14}{13}$\n因此，两次迭代后的矩阵为：\n$$\nU^{(2)} = \\begin{pmatrix} \\frac{12}{13}  \\frac{12}{13} \\\\ \\frac{14}{13}  \\frac{14}{13} \\\\ \\frac{14}{13}  \\frac{14}{13} \\\\ \\frac{12}{13}  \\frac{12}{13} \\end{pmatrix}\n$$\n\n**第 3 部分：计算总隶属度质量 S**\n\n总隶属度质量 $S$ 是 $U^{(2)}$ 中所有元素的和：\n$$\nS = \\sum_{i=1}^{4}\\sum_{k=1}^{2} U^{(2)}_{ik} = 2 \\times \\frac{12}{13} + 2 \\times \\frac{14}{13} + 2 \\times \\frac{14}{13} + 2 \\times \\frac{12}{13}\n$$\n$$\nS = 2 \\left( \\frac{12}{13} + \\frac{14}{13} + \\frac{14}{13} + \\frac{12}{13} \\right) = 2 \\left( \\frac{12+14+14+12}{13} \\right) = 2 \\left( \\frac{52}{13} \\right) = 2 \\times 4 = 8\n$$",
            "answer": "$$ \\boxed{8} $$"
        },
        {
            "introduction": "在掌握了两种不同的社区发现方法后，是时候批判性地思考它们的局限性了。本练习将引入“分辨率极限”这一关键概念，即某些算法倾向于忽略特定尺度以下的社区。通过分析一个简单的星形图（一个常用于揭示此问题的经典案例），你将推导出算法产生“伪”社区分配的具体条件，从而学习到关于算法参数敏感性的重要一课。",
            "id": "4295654",
            "problem": "考虑一个无向、无权的星形图 $S_m$，它由一个中心节点 $h$ 与 $m$ 个叶节点 $\\ell_1,\\dots,\\ell_m$ 连接而成，图中没有自环，叶节点之间也没有边。许多重叠社区检测方法从小的种子集并行地生长出多个局部社区，并在某个节点的加入能够改善局部社区质量目标时将其纳入社区。特别地，假设采用来自 Constant Potts Model (CPM) 的局部目标函数，对于任意节点集 $C$ 定义为 $f_{\\lambda}(C) = k_{\\text{in}}(C) - \\lambda\\,k_{\\text{out}}(C)$，其中 $k_{\\text{in}}(C)$ 是两个端点都在 $C$ 内的边数， $k_{\\text{out}}(C)$ 是只有一个端点在 $C$ 内的边数，而 $\\lambda \\ge 0$ 是一个分辨率参数。一个通用的贪心重叠过程在适应度增益 $\\Delta f_{\\lambda}(C; v) \\equiv f_{\\lambda}(C \\cup \\{v\\}) - f_{\\lambda}(C)$ 为正时，将节点 $v \\notin C$ 加入社区。\n\n以此为基础，构建星形图 $S_m$ 并分析由 $s$ 个叶节点作为种子的社区 $C_s = \\{\\ell_{i_1},\\dots,\\ell_{i_s}\\}$，其中 $1 \\le s  m$。仅使用上述基本定义，首先解释为什么当 $\\lambda$ 足够小时，中心节点 $h$ 会以正增益被添加到许多不同的种子集 $C_s$ 中，这意味着在该图中 $h$ 被分配给了多个重叠的社区。然后，推导最小分辨率参数值 $\\lambda^{\\star}(s)$（作为 $m$ 和 $s$ 的函数）的通用闭式表达式，该表达式确保在种子阶段 $\\Delta f_{\\lambda}(C_s; h) \\le 0$，从而对于大小为 $s$ 的种子避免这种虚假的多重隶属关系。请用一个关于 $m$ 和 $s$ 的单一解析表达式来表示你的最终答案。无需四舍五入。",
            "solution": "该问题陈述经确认为具有科学依据、定义明确、客观且自洽。它提出了一个网络社区检测中的标准理论练习，利用了公认的定义（星形图、Constant Potts Model）来探讨分辨率极限的概念。所有必要的变量和条件都已提供，没有矛盾或事实错误。该问题可形式化，并能导出一个唯一的、有意义的解析解。\n\n我们首先正式定义问题的各个组成部分。该图是一个星形图 $S_m$，其节点集为 $V = \\{h, \\ell_1, \\dots, \\ell_m\\}$，边集为 $E = \\{(h, \\ell_i) \\mid i=1,\\dots,m\\}$。中心节点的度为 $d(h)=m$，每个叶节点的度为 $d(\\ell_i)=1$。种子集是 $C_s = \\{\\ell_{i_1}, \\dots, \\ell_{i_s}\\}$，一个由 $s$ 个不同叶节点组成的集合，其中 $1 \\le s  m$。考虑要添加的节点是中心节点，即 $v=h$。\n\n将节点 $v$ 添加到社区 $C$ 的适应度增益由 $\\Delta f_{\\lambda}(C; v) = f_{\\lambda}(C \\cup \\{v\\}) - f_{\\lambda}(C)$ 给出。为了评估我们这个具体案例，我们必须首先计算初始社区 $C_s$ 和潜在新社区 $C_s \\cup \\{h\\}$ 的目标函数 $f_{\\lambda}(C) = k_{\\text{in}}(C) - \\lambda\\,k_{\\text{out}}(C)$。\n\n首先，考虑种子集 $C_s$。根据定义，任何两个叶节点之间都没有边。因此，内部边数为零。\n$$k_{\\text{in}}(C_s) = 0$$\n出边是那些只有一个端点在 $C_s$ 内的边。$C_s$ 中的 $s$ 个叶节点都连接到中心节点 $h$，而 $h \\notin C_s$。这些是连接到 $C_s$ 中节点的唯一边。因此，有 $s$ 条出边。\n$$k_{\\text{out}}(C_s) = s$$\n种子集的目标函数是：\n$$f_{\\lambda}(C_s) = 0 - \\lambda s = -\\lambda s$$\n\n接下来，考虑扩展后的社区 $C' = C_s \\cup \\{h\\}$。该集合包含中心节点和 $s$ 个叶节点。连接中心节点 $h$ 与这 $s$ 个叶节点的边现在两个端点都在 $C'$ 内。因此，内部边数为 $s$。\n$$k_{\\text{in}}(C_s \\cup \\{h\\}) = s$$\n从 $C'$ 出发的出边是连接 $C'$ 内部节点与 $C'$ 外部节点的边。$C' $内的中心节点 $h$ 总共连接了 $m$ 个叶节点。由于其中 $s$ 个叶节点在 $C'$ 内，剩下的 $m-s$ 个叶节点在 $C'$ 外。连接 $h$ 与这 $m-s$ 个叶节点的边即为出边。$C'$ 内的叶节点没有其他连接。\n$$k_{\\text{out}}(C_s \\cup \\{h\\}) = m-s$$\n扩展后社区的目标函数是：\n$$f_{\\lambda}(C_s \\cup \\{h\\}) = s - \\lambda(m-s)$$\n\n现在，我们可以计算适应度增益 $\\Delta f_{\\lambda}(C_s; h)$：\n$$ \\Delta f_{\\lambda}(C_s; h) = f_{\\lambda}(C_s \\cup \\{h\\}) - f_{\\lambda}(C_s) = [s - \\lambda(m-s)] - [-\\lambda s] $$\n$$ \\Delta f_{\\lambda}(C_s; h) = s - \\lambda(m-s) + \\lambda s = s - \\lambda m + \\lambda s + \\lambda s = s - \\lambda(m-2s) $$\n\n问题的第一部分要求解释为什么当 $\\lambda$ 较小时，中心节点 $h$ 会被添加到许多不同的种子集中。如果一个节点的适应度增益为正，即 $\\Delta f_{\\lambda}(C_s; h)  0$，它就会被添加。\n增益是 $\\lambda$ 的线性函数。在 $\\lambda=0$ 时，增益为 $\\Delta f_0(C_s; h) = s$。由于问题规定 $1 \\le s  m$，所以 $s$ 总是正的。因此，当 $\\lambda=0$ 时，中心节点总是被添加到种子集中。根据连续性，对于任何给定的 $s$ 和 $m$，必定存在一个 $\\lambda$ 值的区间 $(0, \\epsilon)$（对于某个 $\\epsilon  0$），在此区间内增益 $\\Delta f_{\\lambda}(C_s;h)$ 保持为正。增益的结果 $s - \\lambda(m-2s)$ 与叶节点的具体选择无关，仅取决于它们的数量 $s$。有 $\\binom{m}{s}$ 种方式可以选择 $s$ 个叶节点来形成一个种子集 $C_s$。对于一个足够小的 $\\lambda$，中心节点 $h$ 将被添加到由这 $\\binom{m}{s}$ 个不同集合中的任何一个作为种子的社区中，导致它被虚假地分配给大量重叠社区。\n\n问题的第二部分要求推导最小分辨率参数 $\\lambda^{\\star}(s)$，以确保中心节点不会被贪心地添加，即 $\\Delta f_{\\lambda}(C_s; h) \\le 0$。这设定了条件：\n$$ s - \\lambda(m-2s) \\le 0 $$\n为了解出 $\\lambda$，我们必须考虑项 $(m-2s)$ 的符号。\n情况1：$m - 2s  0$，等价于 $s  m/2$。\n在这种情况下，我们可以重排不等式：\n$$ s \\le \\lambda(m-2s) $$\n由于 $(m-2s)$ 是一个正量，我们可以用它来除不等式两边而不改变不等号的方向：\n$$ \\lambda \\ge \\frac{s}{m-2s} $$\n满足此条件的 $\\lambda$ 的最小值是边界值。因此，最小分辨率参数是：\n$$ \\lambda^{\\star}(s) = \\frac{s}{m-2s} $$\n这个表达式给出了 $\\lambda$ 的阈值。对于任何 $\\lambda  \\lambda^{\\star}(s)$，中心节点将被吸收；而对于任何 $\\lambda \\ge \\lambda^{\\star}(s)$，它将不会被吸收。\n\n情况2：$m - 2s \\le 0$，等价于 $s \\ge m/2$。\n增益为 $\\Delta f_{\\lambda}(C_s; h) = s - \\lambda(m-2s) = s + \\lambda(2s-m)$。\n由于 $s \\ge 1$，$\\lambda \\ge 0$ 且 $(2s-m) \\ge 0$，所以增益 $\\Delta f_{\\lambda}(C_s; h)$ 总是正的。它永远不可能小于或等于零。在这种情况下，无论 $\\lambda$ 变得多大，种子集对中心节点的拓扑拉力都太强，无法被对出边的惩罚所克服。因此，不存在一个有限的、非负的 $\\lambda^{\\star}(s)$ 值。\n然而，问题要求的是 $\\lambda^{\\star}(s)$ 的一个通用闭式表达式。在情况1中推导出的表达式 $\\lambda^{\\star}(s) = \\frac{s}{m-2s}$ 就是这个通用形式。它正确地定义了这样一个分辨率参数存在的区间（$s  m/2$）的临界边界。当 $s$ 从下方趋近 $m/2$ 时，$\\lambda^{\\star}(s)$ 发散到 $+\\infty$，这与情况2中的发现一致，即当 $s \\ge m/2$ 时，没有有限的 $\\lambda$ 可以阻止中心节点的加入。因此，这个表达式就是答案。",
            "answer": "$$\n\\boxed{\\frac{s}{m-2s}}\n$$"
        }
    ]
}