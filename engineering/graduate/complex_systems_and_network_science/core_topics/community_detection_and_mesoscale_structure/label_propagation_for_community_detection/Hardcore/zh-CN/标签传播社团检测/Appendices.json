{
    "hands_on_practices": [
        {
            "introduction": "为了扎实掌握标签传播算法（LPA）的核心机制，没有什么比亲手演算一个具体实例更有效了。本练习  提供了一个小型加权网络，要求你执行一轮完整的同步标签更新，包括处理权重和解决平局问题。通过这个基础实践，你将深刻理解LPA在节点层面是如何依据邻居标签进行决策的，并学会如何评估算法产生的社群划分质量。",
            "id": "4285516",
            "problem": "考虑一个无向加权网络，其节点集为 $\\{1,2,3,4,5,6\\}$，加权邻接矩阵 $W \\in \\mathbb{R}^{6 \\times 6}$ 如下所示：\n$$\nW \\;=\\;\n\\begin{pmatrix}\n0  1  1  0  0  0 \\\\\n1  0  1  0  2  0 \\\\\n1  1  0  1  0  0 \\\\\n0  0  1  0  1  1 \\\\\n0  2  0  1  0  1 \\\\\n0  0  0  1  1  0\n\\end{pmatrix}.\n$$\n我们将应用一次同步迭代的标签传播算法（LPA），其定义如下：在迭代 $t$ 时，每个节点 $i$将其标签更新为能使其与当前携带该标签的邻居 $j$ 之间的边权重 $W_{ij}$ 之和最大的标签。如果在两个或多个标签之间出现平局（即最大化权重和相等），则通过选择索引最小的标签来打破平局。设标签集为 $\\mathcal{L} = \\{\\ell_1, \\ell_2\\}$，索引顺序为 $\\ell_1 \\prec \\ell_2$。初始标签分配为\n$$\nL^{(0)} \\;=\\; (\\ell_1,\\; \\ell_2,\\; \\ell_2,\\; \\ell_1,\\; \\ell_2,\\; \\ell_1),\n$$\n分别分配给节点 $(1,2,3,4,5,6)$。\n\n执行恰好一次LPA的同步迭代以获得 $L^{(1)}$。然后，将 $L^{(1)}$ 视为节点的划分，计算该划分在标准的加权无向配置模型零基准下的模块度 $Q$。将最终的模块度表示为一个精确的有理数。不需要四舍五入。最终答案必须是一个实数值。",
            "solution": "我们从标签传播算法（LPA）的定义开始：每个节点选择能使其与携带该标签的邻居之间的入射边权重之和最大的标签。更新是同步的，因此所有节点都根据 $L^{(0)}$ 计算它们的新标签，并同时更新以形成 $L^{(1)}$。当最大值相等时，平局打破规则选择索引最小的标签，这里是 $\\ell_1 \\prec \\ell_2$。\n\n第1步：通过在 $L^{(0)}$ 下为每个节点按标签聚合邻居权重来计算 $L^{(1)}$。\n\n- 节点 $1$ 的邻居是 $\\{2,3\\}$，权重为 $W_{12} = 1$ 和 $W_{13} = 1$。在 $L^{(0)}$ 下，节点 $2$ 带有标签 $\\ell_2$，节点 $3$ 带有标签 $\\ell_2$。聚合权重为：$\\ell_1$：$0$，$\\ell_2$：$1+1 = 2$。节点 $1$ 更新为 $\\ell_2$。\n\n- 节点 $2$ 的邻居是 $\\{1,3,5\\}$，权重为 $W_{21} = 1$，$W_{23} = 1$，$W_{25} = 2$。在 $L^{(0)}$ 下，标签为 $L^{(0)}(1) = \\ell_1$，$L^{(0)}(3) = \\ell_2$，$L^{(0)}(5) = \\ell_2$。聚合权重为：$\\ell_1$：$1$，$\\ell_2$：$1+2 = 3$。节点 $2$ 更新为 $\\ell_2$（未改变）。\n\n- 节点 $3$ 的邻居是 $\\{1,2,4\\}$，权重为 $W_{31} = 1$，$W_{32} = 1$，$W_{34} = 1$。在 $L^{(0)}$ 下，标签为 $L^{(0)}(1) = \\ell_1$，$L^{(0)}(2) = \\ell_2$，$L^{(0)}(4) = \\ell_1$。聚合权重为：$\\ell_1$：$1+1 = 2$，$\\ell_2$：$1$。节点 $3$ 更新为 $\\ell_1$。\n\n- 节点 $4$ 的邻居是 $\\{3,5,6\\}$，权重为 $W_{43} = 1$，$W_{45} = 1$，$W_{46} = 1$。在 $L^{(0)}$ 下，标签为 $L^{(0)}(3) = \\ell_2$，$L^{(0)}(5) = \\ell_2$，$L^{(0)}(6) = \\ell_1$。聚合权重为：$\\ell_1$：$1$，$\\ell_2$：$1+1 = 2$。节点 $4$ 更新为 $\\ell_2$。\n\n- 节点 $5$ 的邻居是 $\\{2,4,6\\}$，权重为 $W_{52} = 2$，$W_{54} = 1$，$W_{56} = 1$。在 $L^{(0)}$ 下，标签为 $L^{(0)}(2) = \\ell_2$，$L^{(0)}(4) = \\ell_1$，$L^{(0)}(6) = \\ell_1$。聚合权重为：$\\ell_1$：$1+1 = 2$，$\\ell_2$：$2$。这是 $\\ell_1$ 和 $\\ell_2$ 在总权重为 $2$ 时的平局。根据平局打破规则，节点 $5$ 更新为 $\\ell_1$（索引最小的标签）。\n\n- 节点 $6$ 的邻居是 $\\{4,5\\}$，权重为 $W_{64} = 1$，$W_{65} = 1$。在 $L^{(0)}$ 下，标签为 $L^{(0)}(4) = \\ell_1$，$L^{(0)}(5) = \\ell_2$。聚合权重为：$\\ell_1$：$1$，$\\ell_2$：$1$。这是一个平局；根据平局打破规则，节点 $6$ 更新为 $\\ell_1$（未改变）。\n\n汇总所有更新，同步迭代产生\n$$\nL^{(1)} \\;=\\; (\\ell_2,\\; \\ell_2,\\; \\ell_1,\\; \\ell_2,\\; \\ell_1,\\; \\ell_1).\n$$\n\n第2步：计算由 $L^{(1)}$ 导出的划分在标准的加权无向配置模型基准下的模块度 $Q$。模块度是通过将观察到的社群内部边权重与零模型下的期望权重进行比较来定义的。对于一个无向加权图，设 $m$ 是所有边权重的总和，设 $k_i = \\sum_{j} W_{ij}$ 是节点 $i$ 的强度（加权度）。模块度的一个等价且标准的表达式是\n$$\nQ \\;=\\; \\sum_{s} \\left( \\frac{l_s}{m} \\;-\\; \\left( \\frac{d_s}{2m} \\right)^{2} \\right),\n$$\n其中，求和是对所有社群 $s$ 进行的，$l_s$ 是两个端点都在社群 $s$ 内的边的总权重，$d_s$ 是社群 $s$ 中所有节点的强度 $k_i$ 的总和。我们通过对每个社群内的节点对求和，并认识到 $\\sum_{i,j \\in s} W_{ij} = 2 l_s$ 和 $\\sum_{i \\in s} k_i = d_s$，从基准公式 $\\left(W_{ij} - \\frac{k_i k_j}{2m}\\right)$ 推导出这个恒等式。\n\n计算 $m$，即总边权重：\n$$\nm \\;=\\; W_{12} + W_{13} + W_{23} + W_{45} + W_{56} + W_{46} + W_{34} + W_{25}\n\\;=\\; 1+1+1+1+1+1+1+2 \\;=\\; 9.\n$$\n因此 $2m = 18$。\n\n计算 $i \\in \\{1,\\dots,6\\}$ 的强度 $k_i$：\n\\begin{align*}\nk_1 = W_{12} + W_{13} \\;=\\; 1 + 1 \\;=\\; 2, \\\\\nk_2 = W_{21} + W_{23} + W_{25} \\;=\\; 1 + 1 + 2 \\;=\\; 4, \\\\\nk_3 = W_{31} + W_{32} + W_{34} \\;=\\; 1 + 1 + 1 \\;=\\; 3, \\\\\nk_4 = W_{43} + W_{45} + W_{46} \\;=\\; 1 + 1 + 1 \\;=\\; 3, \\\\\nk_5 = W_{52} + W_{54} + W_{56} \\;=\\; 2 + 1 + 1 \\;=\\; 4, \\\\\nk_6 = W_{64} + W_{65} \\;=\\; 1 + 1 \\;=\\; 2.\n\\end{align*}\n一致性检查：$\\sum_{i=1}^{6} k_i = 2+4+3+3+4+2 = 18 = 2m$。\n\n在 $L^{(1)}$ 下，社群 $\\ell_1$ 包含节点 $\\{3,5,6\\}$，社群 $\\ell_2$ 包含节点 $\\{1,2,4\\}$。\n\n计算社群内部权重：\n- 对于社群 $\\ell_1$（节点 $\\{3,5,6\\}$），两个端点都在社群内部的边是 $(5,6)$，权重为 $W_{56} = 1$。在 $W$ 中没有边 $(3,5)$ 或 $(3,6)$。因此 $l_{\\ell_1} = 1$。\n\n- 对于社群 $\\ell_2$（节点 $\\{1,2,4\\}$），两个端点都在社群内部的边是 $(1,2)$，权重为 $W_{12} = 1$。没有边 $(1,4)$ 或 $(2,4)$。因此 $l_{\\ell_2} = 1$。\n\n计算社群强度：\n\\begin{align*}\nd_{\\ell_1} = k_3 + k_5 + k_6 \\;=\\; 3 + 4 + 2 \\;=\\; 9, \\\\\nd_{\\ell_2} = k_1 + k_2 + k_4 \\;=\\; 2 + 4 + 3 \\;=\\; 9.\n\\end{align*}\n\n现在计算 $Q$：\n\\begin{align*}\nQ = \\left( \\frac{l_{\\ell_1}}{m} - \\left( \\frac{d_{\\ell_1}}{2m} \\right)^{2} \\right)\n   + \\left( \\frac{l_{\\ell_2}}{m} - \\left( \\frac{d_{\\ell_2}}{2m} \\right)^{2} \\right) \\\\\n  = \\left( \\frac{1}{9} - \\left( \\frac{9}{18} \\right)^{2} \\right)\n   + \\left( \\frac{1}{9} - \\left( \\frac{9}{18} \\right)^{2} \\right) \\\\\n  = 2 \\left( \\frac{1}{9} - \\frac{1}{4} \\right)\n   \\;=\\; 2 \\left( \\frac{4 - 9}{36} \\right)\n   \\;=\\; 2 \\left( -\\frac{5}{36} \\right)\n   \\;=\\; -\\frac{10}{36}\n   \\;=\\; -\\frac{5}{18}.\n\\end{align*}\n\n因此，通过一次同步LPA迭代并使用指定的平局打破规则所产生的划分的模块度是 $-\\frac{5}{18}$。",
            "answer": "$$\\boxed{-\\frac{5}{18}}$$"
        },
        {
            "introduction": "标签传播算法的简洁性背后隐藏着一些动态行为上的复杂性，尤其是在同步更新模式下。本练习  是一个经典的思维实验，旨在揭示同步LPA的一个关键局限性：它不保证总是收敛。通过在一个理想化的二分图上进行分析，你将推导出系统如何陷入一个标签永久翻转的2周期振荡，从而深刻理解为何在实际应用中异步更新通常是更受青睐的选择。",
            "id": "4285556",
            "problem": "考虑标签传播算法（LPA），其中网络中的每个顶点带有一个集合 $\\{+1,-1\\}$ 中的标签，并且，在同步更新下，每个顶点同时采用其邻居标签中的严格多数标签。在出现严格平局的情况下，顶点保留其当前标签。设 $G$ 是完全二分图 $K_{m,n}$，其二分划分为 $(U,V)$，其中 $|U|=m$ 且 $|V|=n$，并且 $U$ 中的每个顶点都与 $V$ 中的每个顶点相连，而在 $U$ 或 $V$ 内部没有边。初始化标签，使得 $U$ 中的所有顶点标签为 $+1$，$V$ 中的所有顶点标签为 $-1$。\n\n仅使用同步标签更新的核心定义和二分图的结构，从这个初始条件出发，推导由此产生的同步标签动态。然后，确定这些动态所产生的轨道的最小周期（即，使得系统在恰好 $p$ 次同步更新后返回其初始标签的最小正整数 $p$）。你的最终答案必须是一个实数。不需要四舍五入。",
            "solution": "该问题陈述清晰，具有科学依据且自成一体。它描述了一个在明确定义的数学对象上的确定性过程。因此，我们可以着手求解。\n\n设在离散时间步 $t$ 时网络的状态由所有顶点标签的集合表示。设 $L_t(x)$ 是顶点 $x$ 在时间 $t$ 的标签。标签集为 $\\{+1, -1\\}$。网络是完全二分图 $G = K_{m,n}$，其二分划分为 $(U, V)$，其中 $|U|=m$ 且 $|V|=n$。\n\n在 $t=0$ 时的初始条件为：\n对于任何顶点 $u \\in U$，$L_0(u) = +1$。\n对于任何顶点 $v \\in V$，$L_0(v) = -1$。\n\n更新规则是同步的。在每个时间步 $t+1$，每个顶点 $x$ 同时将其标签 $L_{t+1}(x)$ 更新为在时间 $t$ 时其邻居所持有的严格多数标签。如果邻居标签之间出现严格平局，顶点将保留其当前标签，即 $L_{t+1}(x) = L_t(x)$。\n\n让我们分析系统从 $t=0$到 $t=1$的演化。\n\n首先，考虑一个任意顶点 $u \\in U$。根据完全二分图的定义， $u$ 的邻居集合，记作 $N(u)$，是整个集合 $V$。邻域的大小是 $|N(u)| = |V| = n$。在时间 $t=0$ 时，$V$ 中的所有顶点都具有标签 $-1$。因此，对于任何顶点 $u \\in U$，其所有 $n$ 个邻居都具有标签 $-1$。 $u$ 的邻居标签集合是 $\\{L_0(y) \\text{ for } y \\in N(u)\\} = \\{-1, -1, \\dots, -1\\}$。只要 $n > 0$，严格多数标签明确为 $-1$。不满足平局打破条件。因此，在时间 $t=1$ 时，$U$ 中的每个顶点都采用标签 $-1$。\n$$ \\forall u \\in U, \\quad L_1(u) = -1 $$\n\n接下来，考虑一个任意顶点 $v \\in V$。它的邻居集合 $N(v)$ 是整个集合 $U$。邻域的大小是 $|N(v)| = |U| = m$。在时间 $t=0$ 时，$U$ 中的所有顶点都具有标签 $+1$。因此，对于任何顶点 $v \\in V$，其所有 $m$ 个邻居都具有标签 $+1$。$v$ 的邻居标签集合是 $\\{L_0(y) \\text{ for } y \\in N(v)\\} = \\{+1, +1, \\dots, +1\\}$。只要 $m > 0$，严格多数标签明确为 $+1$。同样，平局打破条件无关紧要。因此，在时间 $t=1$ 时，$V$ 中的每个顶点都采用标签 $+1$。\n$$ \\forall v \\in V, \\quad L_1(v) = +1 $$\n\n所以，在时间 $t=1$ 时，系统的状态与初始状态完全相反：$U$ 中的所有顶点标签为 $-1$，$V$ 中的所有顶点标签为 $+1$。\n\n现在，让我们使用 $t=1$ 时的状态作为新的初始条件，来分析系统从 $t=1$ 到 $t=2$ 的演化。\n\n考虑一个任意顶点 $u \\in U$。它的邻居是 $V$ 中的 $n$ 个顶点。在时间 $t=1$ 时，所有这些邻居都具有标签 $+1$。因此，$u$ 的邻居中的严格多数标签是 $+1$。所以，在时间 $t=2$ 时，$U$ 中的每个顶点都采用标签 $+1$。\n$$ \\forall u \\in U, \\quad L_2(u) = +1 $$\n\n考虑一个任意顶点 $v \\in V$。它的邻居是 $U$ 中的 $m$ 个顶点。在时间 $t=1$ 时，所有这些邻居都具有标签 $-1$。因此，$v$ 的邻居中的严格多数标签是 $-1$。所以，在时间 $t=2$ 时，$V$ 中的每个顶点都采用标签 $-1$。\n$$ \\forall v \\in V, \\quad L_2(v) = -1 $$\n\n在 $t=2$ 时系统的状态是：对于所有 $u \\in U$，$L_2(u)=+1$；对于所有 $v \\in V$，$L_2(v)=-1$。这与 $t=0$ 时的初始状态完全相同。\n\n设 $S_t$ 是系统在时间 $t$ 的状态（标签的完整配置）。我们已经证明了 $S_2 = S_0$。由于更新规则是确定性的，系统的演化是周期性的。状态序列是 $S_0, S_1, S_2, S_3, \\dots$，这等价于 $S_0, S_1, S_0, S_1, \\dots$。\n\n问题要求轨道的最小周期，也就是满足 $S_p = S_0$ 的最小正整数 $p$。\n我们已经发现对于 $p=2$，$S_2 = S_0$。我们必须检查是否有更小的正整数满足此条件。唯一更小的正整数是 $p=1$。\n\n让我们比较一下 $t=1$ 时的状态和 $t=0$ 时的状态。\n状态 $S_0$：对于 $u \\in U$，$L_0(u)=+1$；对于 $v \\in V$，$L_0(v)=-1$。\n状态 $S_1$：对于 $u \\in U$，$L_1(u)=-1$；对于 $v \\in V$，$L_1(v)=+1$。\n\n假设图是非平凡的（即 $m \\ge 1$ 且 $n \\ge 1$），则集合 $U$ 和 $V$ 非空，且标签不同。因此，$S_1 \\neq S_0$。\n\n满足 $S_p = S_0$ 的最小正整数 $p$ 是 $p=2$。这个结果对任何 $m, n \\ge 1$ 都成立。系统立即进入一个长度为2的极限环。因此，该动态所产生的轨道的最小周期是 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "转向更实用且鲁棒的异步LPA后，算法的性能表现便成为关注的焦点，而这往往取决于微妙的实现细节。本练习  深入探讨了节点更新顺序这一关键因素对收敛速度的影响。你将结合理论推导（基于势函数证明收敛性）与编程实践，量化比较随机更新顺序与基于节点度的策略性更新顺序之间的效率差异，从而掌握优化LPA性能的进阶技巧。",
            "id": "4285584",
            "problem": "考虑一个由邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 表示的无向、无权、简单图，该矩阵是对称的，且对所有 $i$ 都有 $A_{ii} = 0$。\n\n定义标签传播算法 (LPA) 如下。每个节点 $i \\in \\{0,1,\\dots,n-1\\}$ 持有一个类别标签 $\\ell_i \\in \\mathbb{N}$。初始化时，对所有节点 $i$ 设置 $\\ell_i(0) = i$。对节点 $i$ 的单次异步更新操作是将其当前标签 $\\ell_i$ 替换为其邻居中最常见的标签，若出现平局，则通过选择并列标签中最小的那个来确定性地打破平局。形式上，对于邻居集合为 $N(i) = \\{ j \\mid A_{ij} = 1 \\}$ 且当前邻居标签为 $\\{ \\ell_j \\mid j \\in N(i) \\}$ 的节点 $i$，令 $c_x(i)$ 表示满足 $\\ell_j = x$ 的邻居 $j \\in N(i)$ 的数量。达到最大邻居计数的标签集合为 $M(i) = \\{ x \\mid c_x(i) = \\max_{y} c_y(i) \\}$。更新规则为 $\\ell_i \\leftarrow \\min M(i)$。如果 $N(i) = \\emptyset$，则保持 $\\ell_i$ 不变。\n\n一次扫描 (sweep) 是指以某种顺序对所有节点各应用一次上述更新操作。考虑两种更新顺序：\n- 随机排列扫描：在每次扫描 $t$ 中，按照由固定种子 $1729$ 的伪随机数生成器产生的 $\\{0,1,\\dots,n-1\\}$ 的一个随机排列顺序来更新节点。\n- 按度排序扫描：在每次扫描中，按照度的非递增顺序更新节点，其中度为 $k_i = \\sum_{j} A_{ij}$，按节点索引升序打破平局。\n\n每次扫描后，检查扫描期间是否有任何标签发生变化。定义收敛速度 $s$ 为经过该次数的扫描后，一次扫描中不再有标签发生变化的最小扫描次数。设置一个 $1000$ 次扫描的上限；如果在此规则下过程不收敛，则定义 $s = 1000$。\n\n任务：从第一性原理推导更新顺序为何以及如何影响异步 LPA 的收敛速度 $s$，并实现一个程序，在下面指定的测试套件中的每个图上计算并比较这两种顺序的收敛速度。对于每个图，计算随机排列扫描下的 $s_{\\mathrm{rand}}$ 和按度排序扫描下的 $s_{\\mathrm{deg}}$，然后报告整数差 $d = s_{\\mathrm{rand}} - s_{\\mathrm{deg}}$。\n\n推理和推导的基本依据：\n- 图是节点和边的集合；$A_{ij} = 1$ 表示一条无向边 $(i,j)$。\n- 可以将一个关于标签分配的势函数定义为标签不一致的边的数量，这是一个在多数动态和离散自旋系统中经过充分检验的构造。\n- 异步的类多数更新（带有确定性平局打破规则）可以被分析为不会增加该势函数的局部贪心移动，从而在有限图中最终达到稳定状态。\n\n图的测试套件：\n- 测试用例 1 (两个由桥连接的团)：令 $n = 12$。节点 $0,1,2,3,4,5$ 形成一个完全子图；节点 $6,7,8,9,10,11$ 形成一个完全子图。在节点 $5$ 和 $6$ 之间添加一条桥边。\n- 测试用例 2 (环形格)：令 $n = 12$。对所有 $i \\in \\{0,1,\\dots,11\\}$，边为 $(i,(i+1) \\bmod 12)$，无向。\n- 测试用例 3 (星形-团混合图与桥)：令 $n = 12$。创建一个以节点 $0$ 为中心、叶节点为 $1,2,3,4,5,6,7,8$ 的星形图。在节点 $9,10,11$ 上创建一个完全子图。在节点 $1$ 和 $9$ 之间添加一条桥边。\n- 测试用例 4 (含孤立节点的不连通分量)：令 $n = 9$。通过边 $(0,1),(1,2),(2,3),(3,4),(4,0)$ 在节点 $0,1,2,3,4$ 上创建一个 5-环。节点 $5$ 是孤立的。通过边 $(6,7),(7,8)$ 在节点 $6,7,8$ 上创建一条路径。\n\n实现要求：\n- 精确使用上述更新规则，并通过选择最小标签进行确定性平局打破。\n- 使用指定顺序的异步扫描。\n- 使用伪随机种子 $1729$ 的随机排列扫描。\n- 按定义将扫描次数上限设为 $1000$。\n\n最终输出格式：\n你的程序应产生单行输出，其中包含四个测试用例的结果，格式为方括号括起来的逗号分隔列表，每个条目是对应测试用例的整数差 $d = s_{\\mathrm{rand}} - s_{\\mathrm{deg}}$，顺序与上文列出的一致（例如，$\\left[ d_1, d_2, d_3, d_4 \\right]$ 应打印为“[d1,d2,d3,d4]”）。不应打印任何其他文本。",
            "solution": "该问题要求分析更新顺序对异步标签传播算法 (LPA) 收敛速度的影响，并对两种特定的排序方案——随机排列和按度非递增顺序——进行计算比较。\n\n### 第一部分：理论推导与分析\n\n标签传播算法的收敛行为可以通过势函数进行严格分析，这类似于统计物理学中的哈密顿量。让系统的状态由所有节点的标签分配 $\\mathcal{L} = \\{\\ell_0, \\ell_1, \\dots, \\ell_{n-1}\\}$ 定义。一个合适的势函数 $Q(\\mathcal{L})$ 是一个能够量化标签全局共识或一致性的函数。我们将 $Q(\\mathcal{L})$ 定义为图中其端点共享相同标签的边的总数。\n\n对于邻接矩阵为 $A$ 的图，其形式化表示为：\n$$ Q(\\mathcal{L}) = \\frac{1}{2} \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} A_{ij} \\delta(\\ell_i, \\ell_j) $$\n其中 $\\delta(x, y)$ 是克罗内克 δ，当 $x=y$ 时为 $1$，否则为 $0$。因子 $\\frac{1}{2}$ 是为了校正重复计数，因为对于无向图，邻接矩阵 $A$ 是对称的。\n\nLPA 更新规则被设计为一种贪心局部优化。当单个节点 $k$ 的标签从当前值 $\\ell_k$ 更新为新值 $\\ell'_k$ 时，可以计算势函数的变化 $\\Delta Q$。在 $Q(\\mathcal{L})$ 的求和中，唯一受影响的项是那些涉及与节点 $k$ 相连的边的项。其变化为：\n$$ \\Delta Q = Q(\\mathcal{L}') - Q(\\mathcal{L}) = \\sum_{j \\in N(k)} \\left[ \\delta(\\ell'_k, \\ell_j) - \\delta(\\ell_k, \\ell_j) \\right] $$\n其中 $N(k)$ 是节点 $k$ 的邻居集合。项 $\\sum_{j \\in N(k)} \\delta(\\ell'_k, \\ell_j)$ 正是具有标签 $\\ell'_k$ 的 $k$ 的邻居数量，问题中将其定义为 $c_{\\ell'_k}(k)$。类似地，$\\sum_{j \\in N(k)} \\delta(\\ell_k, \\ell_j) = c_{\\ell_k}(k)$。因此，势的变化为：\n$$ \\Delta Q = c_{\\ell'_k}(k) - c_{\\ell_k}(k) $$\nLPA 更新规则规定，新标签 $\\ell'_k$ 从集合 $M(k) = \\{x \\mid c_x(k) = \\max_{y} c_y(k)\\}$ 中选择。这意味着选择 $\\ell'_k$ 的目的是最大化标签一致的邻居数量。根据定义，$c_{\\ell'_k}(k) = \\max_{y} c_y(k)$。因此，对于所有标签 $x$（包括旧标签 $\\ell_k$），必然有 $c_{\\ell'_k}(k) \\ge c_{x}(k)$。这得出了一个关键结论：\n$$ \\Delta Q = c_{\\ell'_k}(k) - c_{\\ell_k}(k) \\ge 0 $$\n这表明 LPA 执行的每一次异步更新要么增加势函数，要么使其保持不变。势函数 $Q(\\mathcal{L})$ 是单调非递减的。\n\n由于图是有限的，且可能的标签集合也是有限的（初始化为 $\\{0, 1, \\dots, n-1\\}$），因此可能的标签分配总数（即状态空间）是有限的。势函数 $Q(\\mathcal{L})$ 的上界是图中的总边数。从有限集合中抽取的单调非递减序列最终必然会达到一个固定值。确定性的平局打破规则（$\\ell_k \\leftarrow \\min M(k)$）防止了在等势状态之间产生循环。因此，该算法保证会收敛到一个稳定的标签分配，即该动力系统的一个定点。\n\n到达此定点所需的扫描次数，即收敛速度 $s$，取决于在状态空间中所走的路径。这个路径由节点更新的序列决定。\n\n**更新顺序为何以及如何影响收敛速度 $s$？**\n\n对节点 $i$ 的一次异步更新会使用其邻居的当前标签。关键在于，其中一些邻居可能在同一次扫描中已经被更新，而另一些则没有。因此，一次扫描中节点的具体排列顺序决定了信息在网络中的流动方式。\n\n1.  按度排序扫描 ($s_{\\mathrm{deg}}$)：该策略采用一种结构感知的、确定性的更新顺序。节点按度 $k_i$ 的非递增顺序进行更新。高阶节点通常是网络结构的核心，并充当有影响力的中心节点。通过首先更新这些中心节点，算法允许它们基于最充分的信息（即最大数量的邻居）快速采用一个标签。这个选择在概率上是稳健的，能够创建出大片的、具有单一标签的稳定区域。然后，这个强大的、相干的信号以结构化的方式向外传播到低度节点。这种层级化的信息流可以迅速解决标签冲突，加速全局共识社区的形成，通常导致较小的收敛速度 $s$。\n\n2.  随机排列扫描 ($s_{\\mathrm{rand}}$)：该策略与网络结构无关。更新顺序是随机的。一个低度的、外围的节点与一个高度的、中心的节点有同等机会被先更新。这样的外围节点可能会基于嘈杂的、瞬态的局部信息来采用一个标签。从全局社区的角度来看，这个决定可能是“不正确的”，并且在更有影响力的节点稳定其标签后，需要在后续的扫描中被推翻。这可能导致标签振荡，特别是在新兴社区的边界处，因为节点会根据邻居更新的杂乱无章的序列而反复变换标签。这种效率较低、更混乱的信息扩散过程会延迟收敛，与按度排序的方法相比，通常导致更大的收敛速度 $s$。\n\n总而言之，收敛速度的差异 $d = s_{\\mathrm{rand}} - s_{\\mathrm{deg}}$ 源于策略性的、自上而下的信息传播（按度排序）与去中心化的、类似随机游走的信息传播（随机排列）之间的对比。虽然对于特定的图拓扑结构可能存在例外，但按度排序的启发式方法通常被期望收敛得更快或以相似的速率收敛，从而导致 $d \\ge 0$。\n\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LPA convergence speed problem for the given test suite.\n    \"\"\"\n\n    def run_lpa(A, order_type, rng=None):\n        \"\"\"\n        Runs the Label Propagation Algorithm on a graph.\n\n        Args:\n            A (np.ndarray): The adjacency matrix of the graph.\n            order_type (str): The update ordering ('random' or 'degree').\n            rng (np.random.Generator, optional): A random number generator for\n                                                 random-permutation sweeps.\n\n        Returns:\n            int: The number of sweeps to convergence (s).\n        \"\"\"\n        n = A.shape[0]\n        labels = np.arange(n, dtype=np.int64)\n        max_sweeps = 1000\n\n        update_order = None\n        if order_type == 'degree':\n            degrees = A.sum(axis=1)\n            node_indices = np.arange(n)\n            # Sort by degree (descending) and then node index (ascending)\n            # np.lexsort sorts by keys from last to first.\n            # We sort by node_indices first, then by -degrees.\n            sorted_indices = np.lexsort((node_indices, -degrees))\n            update_order = list(sorted_indices)\n\n        for sweep_count in range(1, max_sweeps + 2):\n            if sweep_count > max_sweeps:\n                return max_sweeps\n            \n            changed = False\n\n            if order_type == 'random':\n                # Generate a new random permutation for each sweep\n                current_order = rng.permutation(n)\n            else:  # degree-sorted\n                current_order = update_order\n\n            for i in current_order:\n                neighbors = np.where(A[i, :] == 1)[0]\n                if neighbors.size == 0:\n                    continue\n\n                neighbor_labels = labels[neighbors]\n                \n                unique_labels, counts = np.unique(neighbor_labels, return_counts=True)\n                max_count = np.max(counts)\n                \n                # Find all labels that are tied for the most frequent\n                tied_labels = unique_labels[counts == max_count]\n                \n                # Deterministic tie-breaking by choosing the smallest label\n                new_label = np.min(tied_labels)\n                \n                if labels[i] != new_label:\n                    labels[i] = new_label\n                    changed = True\n            \n            if not changed:\n                return sweep_count\n\n        return max_sweeps\n\n    def create_test_cases():\n        \"\"\"Creates the adjacency matrices for the four test cases.\"\"\"\n        cases = []\n        \n        # Test case 1: two cliques with a bridge\n        n1 = 12\n        A1 = np.zeros((n1, n1), dtype=int)\n        for i in range(6):\n            for j in range(i + 1, 6):\n                A1[i, j] = A1[j, i] = 1\n        for i in range(6, 12):\n            for j in range(i + 1, 12):\n                A1[i, j] = A1[j, i] = 1\n        A1[5, 6] = A1[6, 5] = 1\n        cases.append(A1)\n\n        # Test case 2: ring lattice\n        n2 = 12\n        A2 = np.zeros((n2, n2), dtype=int)\n        for i in range(n2):\n            A2[i, (i + 1) % n2] = 1\n            A2[(i + 1) % n2, i] = 1\n        cases.append(A2)\n\n        # Test case 3: star-clique hybrid with a bridge\n        n3 = 12\n        A3 = np.zeros((n3, n3), dtype=int)\n        for i in range(1, 9):\n            A3[0, i] = A3[i, 0] = 1\n        for i in range(9, 12):\n            for j in range(i + 1, 12):\n                A3[i, j] = A3[j, i] = 1\n        A3[1, 9] = A3[9, 1] = 1\n        cases.append(A3)\n\n        # Test case 4: disconnected components with an isolated node\n        n4 = 9\n        A4 = np.zeros((n4, n4), dtype=int)\n        edges4 = [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0), (6, 7), (7, 8)]\n        for u, v in edges4:\n            A4[u, v] = A4[v, u] = 1\n        cases.append(A4)\n        \n        return cases\n\n    test_matrices = create_test_cases()\n    results = []\n    \n    for A in test_matrices:\n        # Seed the random number generator for reproducibility\n        rng = np.random.default_rng(seed=1729)\n        \n        s_rand = run_lpa(A, 'random', rng=rng)\n        s_deg = run_lpa(A, 'degree')\n        \n        d = s_rand - s_deg\n        results.append(d)\n        \n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\n# The function call is commented out to prevent execution in this context,\n# but it is part of the original logic for generating the answer.\n# solve()\n```",
            "answer": "[0,1,0,1]"
        }
    ]
}