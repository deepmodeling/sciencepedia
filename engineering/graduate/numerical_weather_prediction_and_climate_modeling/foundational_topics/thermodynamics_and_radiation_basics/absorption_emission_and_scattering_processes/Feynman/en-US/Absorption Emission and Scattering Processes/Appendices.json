{
    "hands_on_practices": [
        {
            "introduction": "The absorption spectra of atmospheric gases are notoriously complex, containing thousands or even millions of individual lines. While a line-by-line (LBL) calculation provides a benchmark for accuracy, its computational expense is prohibitive for large-scale models. This practice  introduces the powerful correlated-k (c-k) distribution method, which drastically accelerates radiative transfer calculations by re-sorting the spectrum according to absorption strength. By implementing and comparing both methods, you will gain a concrete understanding of the trade-offs between computational efficiency and accuracy that underpin modern radiative parameterizations.",
            "id": "4008290",
            "problem": "Consider the computation of spectrally averaged transmissivity for a longwave band in an atmospheric column using two methods frequently employed in numerical weather prediction and climate modeling: the line-by-line approach and the correlated-$k$ distribution method. The focus is on absorption by molecular lines, neglecting emission and scattering for the purpose of computing transmissivity. The spectral band is defined by $[\\nu_1,\\nu_2] = [650,800] \\,\\mathrm{cm}^{-1}$, discretized uniformly with spacing $\\Delta \\nu = 0.02 \\,\\mathrm{cm}^{-1}$. The absorbers are carbon dioxide and water vapor, represented by a small set of physically plausible Lorentzian lines whose half-widths depend on pressure and temperature. For each atmospheric layer, the absorbers are specified by column number amounts in molecules per square centimeter. Transmissivity is dimensionless. All quantities must be treated in their stated units.\n\nSpecies and line parameters:\n- Carbon dioxide (CO$_2$): two lines centered at $\\nu_{0,1} = 667 \\,\\mathrm{cm}^{-1}$ and $\\nu_{0,2} = 720 \\,\\mathrm{cm}^{-1}$, with line strengths $S_1 = 1.0 \\times 10^{-20} \\,\\mathrm{cm}^2$ and $S_2 = 3.0 \\times 10^{-21} \\,\\mathrm{cm}^2$. Reference half-widths at half maximum at standard conditions are $\\gamma_{1,\\mathrm{ref}} = 0.08 \\,\\mathrm{cm}^{-1}$ and $\\gamma_{2,\\mathrm{ref}} = 0.06 \\,\\mathrm{cm}^{-1}$, with temperature exponents $n_{T,1} = 0.75$ and $n_{T,2} = 0.75$.\n- Water vapor (H$_2$O): three lines centered at $\\nu_{0,3} = 730 \\,\\mathrm{cm}^{-1}$, $\\nu_{0,4} = 750 \\,\\mathrm{cm}^{-1}$, and $\\nu_{0,5} = 740 \\,\\mathrm{cm}^{-1}$, with strengths $S_3 = 5.0 \\times 10^{-22} \\,\\mathrm{cm}^2$, $S_4 = 4.0 \\times 10^{-22} \\,\\mathrm{cm}^2$, and $S_5 = 1.0 \\times 10^{-22} \\,\\mathrm{cm}^2$. Reference half-widths are $\\gamma_{3,\\mathrm{ref}} = 0.12 \\,\\mathrm{cm}^{-1}$, $\\gamma_{4,\\mathrm{ref}} = 0.10 \\,\\mathrm{cm}^{-1}$, and $\\gamma_{5,\\mathrm{ref}} = 5.0 \\,\\mathrm{cm}^{-1}$ (the last representing a crude continuum-like broad feature), with temperature exponents $n_{T,3} = 0.80$, $n_{T,4} = 0.80$, and $n_{T,5} = 0.80$.\n\nReference conditions for pressure and temperature scaling of the half-widths are $p_{\\mathrm{ref}} = 1000 \\,\\mathrm{hPa}$ and $T_{\\mathrm{ref}} = 296 \\,\\mathrm{K}$. For a given layer with pressure $p$ in $\\mathrm{hPa}$ and temperature $T$ in $\\mathrm{K}$, each lineâ€™s half-width is scaled by\n$\\gamma = \\gamma_{\\mathrm{ref}} \\left(\\dfrac{p}{p_{\\mathrm{ref}}}\\right) \\left(\\dfrac{T_{\\mathrm{ref}}}{T}\\right)^{n_T}$.\nUse the normalized Lorentz line shape with half-width $\\gamma$:\n$g(\\nu;\\nu_0,\\gamma) = \\dfrac{1}{\\pi} \\dfrac{\\gamma}{(\\nu - \\nu_0)^2 + \\gamma^2}$,\nand assume the monochromatic absorption cross-section is the sum over lines of $S \\, g(\\nu;\\nu_0,\\gamma)$ for each species. The monochromatic optical depth is the sum over species of cross-section times the species column number amount in molecules per square centimeter for each layer, summed over layers; transmissivity is the exponential of the negative optical depth. Spectrally averaged transmissivity over the band is the arithmetic mean over the discretized grid.\n\nThe correlated-$k$ distribution (k-distribution) method should be implemented under the perfect correlation assumption across layers by sorting the band monochromatic absorption according to a common ranking that is consistent across layers and approximating the band integral using equal-probability bins. Use $M = 16$ equally weighted bins for the cumulative coordinate and assume equal weights $w_j = 1/M$ for $j = 1,\\dots,M$.\n\nTest suite (each test case is a list of layers, and each layer is given by pressure $p$ in $\\mathrm{hPa}$, temperature $T$ in $\\mathrm{K}$, and column number amounts $N_{\\mathrm{CO2}}$ and $N_{\\mathrm{H2O}}$ in molecules per square centimeter):\n- Case $1$ (optically thin, single layer): $[(p=200,\\, T=220,\\, N_{\\mathrm{CO2}}=2.0 \\times 10^{19},\\, N_{\\mathrm{H2O}}=1.0 \\times 10^{19})]$.\n- Case $2$ (moderate, single layer): $[(p=600,\\, T=260,\\, N_{\\mathrm{CO2}}=5.0 \\times 10^{20},\\, N_{\\mathrm{H2O}}=1.0 \\times 10^{20})]$.\n- Case $3$ (optically thick, single layer): $[(p=1000,\\, T=290,\\, N_{\\mathrm{CO2}}=2.0 \\times 10^{21},\\, N_{\\mathrm{H2O}}=5.0 \\times 10^{20})]$.\n- Case $4$ (two layers, varying conditions): $[(p=800,\\, T=285,\\, N_{\\mathrm{CO2}}=1.0 \\times 10^{21},\\, N_{\\mathrm{H2O}}=3.0 \\times 10^{20}),\\, (p=400,\\, T=250,\\, N_{\\mathrm{CO2}}=5.0 \\times 10^{20},\\, N_{\\mathrm{H2O}}=5.0 \\times 10^{19})]$.\n- Case $5$ (three layers, de-correlation stress test): $[(p=950,\\, T=295,\\, N_{\\mathrm{CO2}}=1.5 \\times 10^{21},\\, N_{\\mathrm{H2O}}=4.0 \\times 10^{20}),\\, (p=600,\\, T=270,\\, N_{\\mathrm{CO2}}=7.0 \\times 10^{20},\\, N_{\\mathrm{H2O}}=1.0 \\times 10^{20}),\\, (p=300,\\, T=230,\\, N_{\\mathrm{CO2}}=3.0 \\times 10^{20},\\, N_{\\mathrm{H2O}}=3.0 \\times 10^{19})]$.\n\nYour program must:\n- Construct the wavenumber grid over $[650,800] \\,\\mathrm{cm}^{-1}$ with $\\Delta \\nu = 0.02 \\,\\mathrm{cm}^{-1}$.\n- For each test case, compute the band-mean transmissivity using the line-by-line approach and the correlated-$k$ method with $M = 16$ bins under perfect correlation.\n- For each test case, compute the absolute difference between the two band-mean transmissivities.\n- Express each absolute difference as a float rounded to six decimal places (dimensionless).\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order of Cases $1$ through $5$, for example $[x_1,x_2,x_3,x_4,x_5]$ where each $x_i$ is the rounded float for Case $i$.\n\nNo external input is allowed; all constants and parameters are as specified above. Angles do not appear in this problem. Physical units are as stated; transmissivity and its differences are dimensionless.",
            "solution": "The problem requires the computation and comparison of spectrally averaged longwave transmissivity using two distinct methods: the line-by-line (LBL) approach, which serves as a high-fidelity benchmark, and the correlated-$k$ (c-k) distribution method, an approximation widely used for its computational efficiency in atmospheric models. The comparison will be performed for several atmospheric profiles, and the absolute difference in the results from the two methods will be reported.\n\nFirst, we establish the physical and mathematical framework. The spectral band of interest spans from $\\nu_1 = 650 \\,\\mathrm{cm}^{-1}$ to $\\nu_2 = 800 \\,\\mathrm{cm}^{-1}$. This band is discretized into a uniform grid of wavenumbers $\\nu_i$. The number of points, $N_\\nu$, is given by $(\\nu_2 - \\nu_1)/\\Delta\\nu + 1$, where $\\Delta\\nu = 0.02 \\,\\mathrm{cm}^{-1}$, resulting in $N_\\nu = (800-650)/0.02 + 1 = 7501$ points.\n\nThe core of the calculation is the monochromatic optical depth, $\\tau(\\nu)$, which quantifies the absorption at a specific wavenumber $\\nu$. For an atmospheric column composed of multiple layers, the total optical depth is the sum of the optical depths of individual layers:\n$$\n\\tau(\\nu) = \\sum_l \\tau_l(\\nu)\n$$\nwhere $\\tau_l(\\nu)$ is the optical depth of layer $l$. The optical depth of a single layer is determined by the absorbing species present. It is the sum over all species $s$ of the product of the species' monochromatic absorption cross-section $\\sigma_{s,l}(\\nu)$ and its column number amount $N_{s,l}$:\n$$\n\\tau_l(\\nu) = \\sum_s \\sigma_{s,l}(\\nu) N_{s,l}\n$$\nThe absorption cross-section for a given species is the sum of contributions from all its individual absorption lines. For a single line centered at $\\nu_0$ with strength $S$, its contribution to the cross-section is given by the product of its strength and a line shape function, $g(\\nu; \\nu_0, \\gamma)$.\n$$\n\\sigma_s(\\nu) = \\sum_{j \\in \\text{lines of } s} S_j g(\\nu; \\nu_{0,j}, \\gamma_j)\n$$\nThe problem specifies a normalized Lorentz line shape:\n$$\ng(\\nu; \\nu_0, \\gamma) = \\frac{1}{\\pi} \\frac{\\gamma}{(\\nu - \\nu_0)^2 + \\gamma^2}\n$$\nwhere $\\gamma$ is the half-width at half-maximum. This half-width is dependent on the pressure $p$ and temperature $T$ of the atmospheric layer, and it is scaled from reference values ($\\gamma_{\\mathrm{ref}}$, $p_{\\mathrm{ref}} = 1000 \\,\\mathrm{hPa}$, $T_{\\mathrm{ref}} = 296 \\,\\mathrm{K}$) using the relation:\n$$\n\\gamma = \\gamma_{\\mathrm{ref}} \\left(\\frac{p}{p_{\\mathrm{ref}}}\\right) \\left(\\frac{T_{\\mathrm{ref}}}{T}\\right)^{n_T}\n$$\nThe exponent $n_T$ is a line-specific parameter.\n\nWith the monochromatic optical depth $\\tau(\\nu)$ defined, we can now detail the two methods for calculating the band-averaged transmissivity, $\\bar{\\mathcal{T}}$.\n\n**1. Line-by-Line (LBL) Method**\n\nThis method is a direct, brute-force integration over the spectrum. For each wavenumber $\\nu_i$ on our high-resolution grid, the monochromatic transmissivity $\\mathcal{T}(\\nu_i)$ is calculated using the Beer-Lambert law, neglecting scattering and emission:\n$$\n\\mathcal{T}(\\nu_i) = e^{-\\tau(\\nu_i)}\n$$\nThe band-averaged transmissivity, $\\bar{\\mathcal{T}}_{\\mathrm{LBL}}$, is then the arithmetic mean of these monochromatic values over the entire spectral grid:\n$$\n\\bar{\\mathcal{T}}_{\\mathrm{LBL}} = \\frac{1}{N_\\nu} \\sum_{i=1}^{N_\\nu} \\mathcal{T}(\\nu_i)\n$$\n\n**2. Correlated-k (c-k) Distribution Method**\n\nThe c-k method aims to reduce the computational cost by reordering the spectral integration. Instead of integrating over wavenumber $\\nu$, it integrates over the absorption coefficient $k$. The method relies on the assumption that the spectral variations of absorption coefficients are correlated across different atmospheric layers. The problem specifies the \"perfect correlation\" assumption, which means that the ordering of wavenumbers from weakest to strongest absorption is identical for all layers.\n\nThe algorithm proceeds as follows:\na. First, we compute the total column optical depth spectrum, $\\tau(\\nu_i) = \\sum_l \\tau_l(\\nu_i)$, for all $N_\\nu$ grid points.\nb. The values of $\\tau(\\nu_i)$ are sorted in ascending order. This sorting defines a permutation of the wavenumber indices, which serves as the common ranking for all layers, thus enforcing the perfect correlation assumption.\nc. For each layer $l$, its monochromatic optical depth spectrum $\\tau_l(\\nu_i)$ is reordered according to this same permutation.\nd. The sorted spectrum (now representing an ordered \"g-space\") is divided into $M=16$ equally-sized bins. Due to discretization, the bins will contain approximately $N_\\nu/M$ points each.\ne. For each bin $j \\in \\{1, \\dots, M\\}$, we compute an average optical depth for each layer, $\\bar{\\tau}_{l,j}$, by taking the arithmetic mean of the reordered $\\tau_l$ values within that bin.\nf. The total average optical depth for bin $j$ is the sum over layers:\n$$\n\\bar{\\tau}_j = \\sum_l \\bar{\\tau}_{l,j}\n$$\ng. A single transmissivity value is computed for each bin using this average optical depth:\n$$\n\\mathcal{T}_j = e^{-\\bar{\\tau}_j}\n$$\nh. The final band-averaged transmissivity, $\\bar{\\mathcal{T}}_{\\mathrm{c-k}}$, is the weighted average of these bin transmissivities. As the problem specifies equally weighted bins with weights $w_j=1/M$, this is a simple arithmetic mean:\n$$\n\\bar{\\mathcal{T}}_{\\mathrm{c-k}} = \\frac{1}{M} \\sum_{j=1}^{M} \\mathcal{T}_j\n$$\n\nFor each test case, we will implement both methods, calculate $\\bar{\\mathcal{T}}_{\\mathrm{LBL}}$ and $\\bar{\\mathcal{T}}_{\\mathrm{c-k}}$, and then find the absolute difference, $|\\bar{\\mathcal{T}}_{\\mathrm{LBL}} - \\bar{\\mathcal{T}}_{\\mathrm{c-k}}|$. This difference quantifies the error introduced by the c-k approximation under the given conditions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes and compares band-mean transmissivity using Line-by-Line (LBL)\n    and Correlated-k (c-k) methods for specified atmospheric cases.\n    \"\"\"\n\n    # --- Constants and Spectral Grid Definition ---\n    NU_1, NU_2 = 650.0, 800.0  # cm^-1\n    D_NU = 0.02  # cm^-1\n    NUM_POINTS = int((NU_2 - NU_1) / D_NU) + 1\n    nu_grid = np.linspace(NU_1, NU_2, NUM_POINTS)\n\n    P_REF = 1000.0  # hPa\n    T_REF = 296.0  # K\n\n    M_BINS = 16  # Number of bins for c-k method\n\n    # --- Species and Line Parameters ---\n    # (nu_0, S, gamma_ref, n_T)\n    line_params_co2 = [\n        (667.0, 1.0e-20, 0.08, 0.75),\n        (720.0, 3.0e-21, 0.06, 0.75),\n    ]\n    line_params_h2o = [\n        (730.0, 5.0e-22, 0.12, 0.80),\n        (750.0, 4.0e-22, 0.10, 0.80),\n        (740.0, 1.0e-22, 5.0, 0.80),\n    ]\n    \n    # --- Test Cases ---\n    # Each case is a list of layers. Each layer is (p, T, N_co2, N_h2o).\n    test_cases = [\n        [(200.0, 220.0, 2.0e19, 1.0e19)],  # Case 1\n        [(600.0, 260.0, 5.0e20, 1.0e20)],  # Case 2\n        [(1000.0, 290.0, 2.0e21, 5.0e20)], # Case 3\n        [\n            (800.0, 285.0, 1.0e21, 3.0e20), \n            (400.0, 250.0, 5.0e20, 5.0e19)\n        ], # Case 4\n        [\n            (950.0, 295.0, 1.5e21, 4.0e20),\n            (600.0, 270.0, 7.0e20, 1.0e20),\n            (300.0, 230.0, 3.0e20, 3.0e19)\n        ], # Case 5\n    ]\n\n    def lorentz_profile(nu, nu_0, gamma):\n        \"\"\"Calculates the normalized Lorentz line shape.\"\"\"\n        return (1.0 / np.pi) * (gamma / ((nu - nu_0)**2 + gamma**2))\n\n    def calculate_results_for_case(layers):\n        \"\"\"\n        Calculates LBL and c-k transmissivities for a given atmospheric case.\n        \"\"\"\n        num_layers = len(layers)\n        optical_depth_layers = np.zeros((num_layers, NUM_POINTS))\n\n        for i, layer in enumerate(layers):\n            p, T, N_co2, N_h2o = layer\n            \n            # --- Calculate CO2 cross-section for the layer ---\n            sigma_co2 = np.zeros(NUM_POINTS)\n            for nu_0, S, gamma_ref, n_T in line_params_co2:\n                gamma = gamma_ref * (p / P_REF) * (T_REF / T)**n_T\n                sigma_co2 += S * lorentz_profile(nu_grid, nu_0, gamma)\n            \n            # --- Calculate H2O cross-section for the layer ---\n            sigma_h2o = np.zeros(NUM_POINTS)\n            for nu_0, S, gamma_ref, n_T in line_params_h2o:\n                gamma = gamma_ref * (p / P_REF) * (T_REF / T)**n_T\n                sigma_h2o += S * lorentz_profile(nu_grid, nu_0, gamma)\n                \n            # --- Calculate layer optical depth ---\n            optical_depth_layers[i, :] = sigma_co2 * N_co2 + sigma_h2o * N_h2o\n\n        # Total column optical depth\n        optical_depth_total = np.sum(optical_depth_layers, axis=0)\n\n        # --- 1. Line-by-Line (LBL) Calculation ---\n        transmissivity_lbl_mono = np.exp(-optical_depth_total)\n        transmissivity_lbl_mean = np.mean(transmissivity_lbl_mono)\n\n        # --- 2. Correlated-k (c-k) Calculation ---\n        # Sort based on total optical depth to enforce perfect correlation\n        sort_indices = np.argsort(optical_depth_total)\n        \n        # Split sorted indices into M bins\n        binned_indices = np.array_split(sort_indices, M_BINS)\n        \n        transmissivity_bins = np.zeros(M_BINS)\n        for j, bin_idx in enumerate(binned_indices):\n            # For each layer, average its optical depth over the current bin\n            avg_od_bin_layers = np.mean(optical_depth_layers[:, bin_idx], axis=1)\n            \n            # Sum layer-averaged ODs to get total bin OD\n            total_avg_od_bin = np.sum(avg_od_bin_layers)\n            \n            # Calculate bin transmissivity\n            transmissivity_bins[j] = np.exp(-total_avg_od_bin)\n\n        # Final c-k transmissivity is the mean of bin transmissivities\n        transmissivity_ck_mean = np.mean(transmissivity_bins)\n        \n        return transmissivity_lbl_mean, transmissivity_ck_mean\n\n    # --- Main Loop for Test Cases ---\n    results = []\n    for case in test_cases:\n        lbl_trans, ck_trans = calculate_results_for_case(case)\n        # Calculate absolute difference and round\n        abs_diff = np.abs(lbl_trans - ck_trans)\n        results.append(round(abs_diff, 6))\n\n    # --- Final Output Formatting ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Accurately representing scattering by clouds and aerosols is another major challenge, particularly because their phase functions are often strongly peaked in the forward direction. This forward-scattering peak is difficult to resolve with the low-order angular discretizations (like two-stream methods) used in climate models. The delta-Eddington scaling  offers a clever solution by analytically removing the forward-scattered component and renormalizing the remaining properties. This exercise will guide you through the derivation and implementation of this essential technique, revealing how it makes simplified radiative transfer solvers both efficient and physically sound.",
            "id": "4008326",
            "problem": "You are tasked with implementing a transformation used in shortwave radiative transfer for numerical weather prediction and climate modeling that accounts for strongly forward-peaked scattering. The transformation, called the delta-Eddington scaling, modifies the optical thickness, single-scattering albedo, and asymmetry parameter to remove an idealized forward-scattering spike and renormalize the remaining \"diffuse\" scattering. Your program must compute the transformed quantities for a set of test cases and output them in the specified format.\n\nBegin from the plane-parallel, monochromatic Radiative Transfer (RT) equation for intensity $I$ as a function of optical depth $\\tau$, direction cosine $\\mu$, and azimuth-integrated scattering:\n$$\n\\frac{d I(\\mu)}{d \\tau} = - I(\\mu) + \\omega_0 \\int_{-1}^{1} P(\\mu, \\mu') I(\\mu') \\, \\frac{d \\mu'}{2} + S(\\mu),\n$$\nwhere $S(\\mu)$ represents any source term (e.g., thermal emission or direct solar beam), $\\omega_0$ is the single-scattering albedo, and $P(\\mu, \\mu')$ is the scattering phase function. The single-scattering albedo $\\omega_0$ and asymmetry parameter $g$ are defined by fundamental optical properties:\n- $\\omega_0 = \\sigma_s / (\\sigma_s + \\sigma_a)$, where $\\sigma_s$ is the scattering coefficient and $\\sigma_a$ is the absorption coefficient.\n- $g = \\langle \\cos \\theta \\rangle$, the first moment of the phase function, expressing the mean cosine of the scattering angle $\\theta$.\n- The optical thickness $\\tau$ is defined by $\\tau = \\int (\\sigma_s + \\sigma_a) \\, dz$, which is dimensionless.\n\nTo treat forward-peaked scattering, the delta-Eddington approach conceptually decomposes the phase function into a Dirac delta spike concentrated at the forward direction and a residual diffuse part, with the spike carrying a fraction $f$ of the scattering probability. The spike does not contribute to net angular redistribution in the two-stream sense; its presence can be absorbed into modified (scaled) parameters that govern the diffuse field. The transformed parameters $(\\tau', \\omega_0', g')$ must conserve scattering probability and the first moment (asymmetry) of the residual phase function while reducing the effective extinction felt by the diffuse radiation.\n\nYour tasks:\n1. Using the principles above, derive and implement the delta-Eddington scaling that maps the original $(\\tau, \\omega_0, g)$ to $(\\tau', \\omega_0', g')$ by removing a forward delta spike fraction $f$ of the scattering and renormalizing the residual. The forward-peaked correction must be applied only when $g > 0$, and skipped (i.e., $(\\tau', \\omega_0', g') = (\\tau, \\omega_0, g)$) when $g \\le 0$ because a non-forward asymmetry does not justify the spike-removal model. All transformed quantities are dimensionless and must be output as decimal floats rounded to six decimal places.\n2. Implement the program to compute $(\\tau', \\omega_0', g')$ for each test case below. The physical units are dimensionless for $\\tau$, $\\omega_0$, and $g$, so you must express each output value as a float rounded to six decimal places.\n\nTest Suite:\n- Case $1$: $(\\tau, \\omega_0, g) = (2.0, 0.95, 0.85)$\n- Case $2$: $(\\tau, \\omega_0, g) = (10.0, 1.0, 0.85)$\n- Case $3$: $(\\tau, \\omega_0, g) = (1.0, 0.2, 0.7)$\n- Case $4$: $(\\tau, \\omega_0, g) = (0.8, 0.9, 0.0)$\n- Case $5$: $(\\tau, \\omega_0, g) = (0.5, 0.999, 0.999)$\n- Case $6$: $(\\tau, \\omega_0, g) = (3.0, 0.9, -0.2)$\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list of three floats $[\\tau', \\omega_0', g']$ rounded to six decimal places. For example, the final printed line should look like:\n$$\n\\text{[[\\tau'_1,\\omega'_1,g'_1],[\\tau'_2,\\omega'_2,g'_2],\\dots]}\n$$\nNo other text should be printed.",
            "solution": "The delta-Eddington approximation simplifies the treatment of strongly forward-peaked scattering. The core idea is to approximate the scattering phase function, $p(\\cos\\Theta)$, as a sum of a Dirac delta function in the forward direction ($\\Theta=0$, or $\\cos\\Theta=1$) and a less anisotropic, truncated Legendre polynomial series.\n\nThe phase function is decomposed as:\n$$\np(\\cos\\Theta) = 2f \\delta(1-\\cos\\Theta) + (1-f)p'(\\cos\\Theta)\n$$\nHere, $f$ is the fraction of scattering into the forward peak, and $p'(\\cos\\Theta)$ is the phase function for the remaining \"diffuse\" scattering. The factor of $2$ normalizes the delta function over the integral $\\int_{-1}^{1} \\dots d(\\cos\\Theta)$. Both $p$ and $p'$ are normalized such that their integral over $4\\pi$ steradians is $1$.\n\nSubstituting this decomposition into the integro-differential radiative transfer equation (ignoring the source term for clarity):\n$$\n\\frac{d I}{d \\tau} = -I + \\omega_0 \\int_{-1}^{1} \\left[ f \\delta(\\mu-\\mu') + \\frac{1-f}{2} p'(\\mu, \\mu') \\right] I(\\mu') d\\mu'\n$$\nThe integral over the delta function simply picks out $I(\\mu)$, so we have:\n$$\n\\frac{d I}{d \\tau} = -I + \\omega_0 f I(\\mu) + \\omega_0 (1-f) \\int_{-1}^{1} p'(\\mu, \\mu') I(\\mu') \\frac{d\\mu'}{2}\n$$\nRearranging terms yields:\n$$\n\\frac{d I}{d \\tau} = -(1 - \\omega_0 f)I(\\mu) + \\omega_0(1-f) \\int_{-1}^{1} p'(\\mu, \\mu') I(\\mu') \\frac{d\\mu'}{2}\n$$\nTo restore the standard form of the radiative transfer equation, we define a scaled optical thickness, $\\tau'$, such that $d\\tau' = (1 - \\omega_0 f)d\\tau$. Dividing the equation by $(1 - \\omega_0 f)$ gives:\n$$\n\\frac{d I}{d \\tau'} = -I(\\mu) + \\frac{\\omega_0(1-f)}{1 - \\omega_0 f} \\int_{-1}^{1} p'(\\mu, \\mu') I(\\mu') \\frac{d\\mu'}{2}\n$$\nThis equation has the same form as the original, but with a new set of scaled parameters:\n1.  **Scaled Optical Thickness**: $\\tau' = (1 - \\omega_0 f)\\tau$\n2.  **Scaled Single-Scattering Albedo**: $\\omega_0' = \\frac{\\omega_0(1-f)}{1 - \\omega_0 f}$\n\nNext, we determine the scaled asymmetry parameter, $g'$. The asymmetry parameter $g$ is the first moment of the phase function. Applying this definition to our decomposed phase function:\n$$\ng = \\int_{-1}^{1} \\mu p(\\mu) \\frac{d\\mu}{2} = \\int_{-1}^{1} \\mu \\left[ 2f \\delta(1-\\mu) + (1-f)p'(\\mu) \\right] \\frac{d\\mu}{2}\n$$\n$$\ng = f \\cdot 1 + (1-f)g'\n$$\nwhere $g'$ is the asymmetry parameter of the scaled phase function $p'$. Rearranging for $g'$:\n$$\ng' = \\frac{g - f}{1 - f}\n$$\nThe final step is to choose the fraction $f$. In the standard delta-Eddington approximation, $f$ is chosen to be $g^2$. This choice is derived from matching moments of the Henyey-Greenstein phase function. Thus, we set $f=g^2$.\n\nSubstituting $f=g^2$ into the scaling equations yields the final transformation relations, which are applied only when $g > 0$:\n1.  $\\tau' = (1 - \\omega_0 g^2)\\tau$\n2.  $\\omega_0' = \\frac{\\omega_0(1-g^2)}{1 - \\omega_0 g^2}$\n3.  $g' = \\frac{g - g^2}{1 - g^2} = \\frac{g(1-g)}{(1-g)(1+g)} = \\frac{g}{1+g}$\n\nFor cases where $g \\le 0$, the forward-peaked assumption is invalid, and the transformation is not applied, so $(\\tau', \\omega_0', g') = (\\tau, \\omega_0, g)$.\n\nThe algorithm for each test case is as follows:\n1.  Receive the input triplet $(\\tau, \\omega_0, g)$.\n2.  Check if $g > 0$.\n3.  If $g > 0$, compute $\\tau'$, $\\omega_0'$, and $g'$ using the formulas derived above.\n4.  If $g \\le 0$, set $\\tau' = \\tau$, $\\omega_0' = \\omega_0$, and $g' = g$.\n5.  Return the resulting triplet $(\\tau', \\omega_0', g')$, with each component rounded to six decimal places.\nThe final output will be an aggregation of these results into the specified list-of-lists format.",
            "answer": "```python\nimport numpy as np\nfrom typing import List, Tuple\n\ndef delta_eddington_scaling(tau: float, omega0: float, g: float) -> Tuple[float, float, float]:\n    \"\"\"\n    Computes the delta-Eddington scaled radiative properties.\n\n    The transformation is applied only if the asymmetry parameter g is positive,\n    as the method is designed to handle forward-peaked scattering.\n\n    Args:\n        tau (float): Original optical thickness (dimensionless).\n        omega0 (float): Original single-scattering albedo (dimensionless).\n        g (float): Original asymmetry parameter (dimensionless).\n\n    Returns:\n        A tuple (tau_prime, omega0_prime, g_prime) containing the\n        transformed, dimensionless optical properties.\n    \"\"\"\n    if g > 0:\n        # The choice f = g^2 is standard for the delta-Eddington approximation.\n        g_squared = np.power(g, 2)\n        \n        # Denominator for tau' and omega0' scaling factors\n        # This term is (1 - omega0 * f)\n        scaling_denominator = 1.0 - omega0 * g_squared\n\n        # Handle the edge case where the denominator might be zero, which can occur\n        # if omega0=1 and g=1. Physically, this represents pure forward scattering.\n        if scaling_denominator == 0:\n            # In this limit, tau' -> 0, omega0' -> 1, g' -> 0.5\n            # However, for numerical stability with floating point a small\n            # non-zero value is better than a direct check for 0.\n            # The test cases do not hit this exact singularity.\n            tau_prime = 0.0\n            omega0_prime = 1.0\n        else:\n            # Scaled optical thickness\n            tau_prime = tau * scaling_denominator\n            \n            # Scaled single-scattering albedo\n            omega0_prime = (omega0 * (1.0 - g_squared)) / scaling_denominator\n        \n        # Scaled asymmetry parameter\n        g_prime = g / (1.0 + g)\n        \n        return tau_prime, omega0_prime, g_prime\n    else:\n        # If g <= 0, the transformation is not applied.\n        return tau, omega0, g\n\ndef solve():\n    \"\"\"\n    Processes the test suite for the delta-Eddington transformation and\n    prints the results in the specified format.\n    \"\"\"\n    # Test Suite from the problem statement\n    test_cases = [\n        # (tau, omega0, g)\n        (2.0, 0.95, 0.85),\n        (10.0, 1.0, 0.85),\n        (1.0, 0.2, 0.7),\n        (0.8, 0.9, 0.0),\n        (0.5, 0.999, 0.999),\n        (3.0, 0.9, -0.2),\n    ]\n\n    all_results_str: List[str] = []\n\n    for case in test_cases:\n        tau, omega0, g = case\n        \n        # Calculate the transformed parameters\n        tau_prime, omega0_prime, g_prime = delta_eddington_scaling(tau, omega0, g)\n\n        # Format each number to six decimal places\n        formatted_numbers = [\n            f\"{tau_prime:.6f}\",\n            f\"{omega0_prime:.6f}\",\n            f\"{g_prime:.6f}\"\n        ]\n        \n        # Create the string for the inner list, e.g., \"[0.123456,0.234567,0.345678]\"\n        inner_list_str = f\"[{','.join(formatted_numbers)}]\"\n        all_results_str.append(inner_list_str)\n\n    # Join the inner list strings and wrap with the outer list brackets\n    # Final format: \"[[...],[...],...]\"\n    final_output = f\"[{','.join(all_results_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Once the physical problem has been simplified using approximations like the k-distribution and delta-scaling, the resulting differential equations must be solved numerically. The choice of integration scheme is not trivial; it critically affects the stability and accuracy of the solution, particularly in optically thick layers where naive methods can fail spectacularly. This practice  explores the behavior of different numerical solvers, demonstrating the unphysical oscillations of unstable schemes and the stabilizing effect of implicit methods and flux limiters. By comparing these solvers against an exact analytical solution, you will develop a crucial intuition for the origins and mitigation of numerical diffusion in radiative transfer codes.",
            "id": "4008315",
            "problem": "Consider a plane-parallel, homogeneous, isothermal atmospheric slab of total optical thickness $\\tau^{\\ast}$, with constant thermal source function $B$ (in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$). There is no external radiation incident from the top of the atmosphere (top-of-atmosphere downwelling intensity is zero), and the underlying surface is black with its own source function $B_{\\mathrm{sfc}}$ (in $\\mathrm{W}\\,\\mathrm{m}^{-2}\\,\\mathrm{sr}^{-1}$). Assume pure absorption and emission (no scattering), and approximate the angular dependence using a two-stream quadrature with the Eddington direction cosine $\\mu_{0} = 1/\\sqrt{3}$.\n\nFundamental base:\n- The plane-parallel radiative transfer equation for pure absorption and emission along a direction with cosine $\\mu$ to the zenith is\n$$\n\\mu\\,\\frac{d I(\\tau,\\mu)}{d \\tau} = - I(\\tau,\\mu) + B,\n$$\nwhere $I(\\tau,\\mu)$ is the specific intensity and $\\tau$ is downward optical depth.\n- The two-stream approximation replaces the integral over angles by two discrete streams at $\\mu = \\pm \\mu_{0}$ with appropriate quadrature weights.\n\nUnder these assumptions:\n1. Let $I^{\\downarrow}(\\tau)$ denote the downwelling intensity for $\\mu = +\\mu_{0}$ and $I^{\\uparrow}(\\tau)$ denote the upwelling intensity for $\\mu = -\\mu_{0}$. Use the radiative transfer equation to derive closed-form expressions for $I^{\\downarrow}(\\tau)$ subject to the boundary condition $I^{\\downarrow}(0) = 0$ and for $I^{\\uparrow}(\\tau)$ subject to the boundary condition $I^{\\uparrow}(\\tau^{\\ast}) = B_{\\mathrm{sfc}}$. From these intensities, derive the corresponding fluxes\n$$\nF^{\\downarrow}(\\tau) = 2\\pi\\,\\mu_{0}\\,I^{\\downarrow}(\\tau), \\quad F^{\\uparrow}(\\tau) = 2\\pi\\,\\mu_{0}\\,I^{\\uparrow}(\\tau).\n$$\nReport the closed-form expressions specifically for $F^{\\uparrow}(0)$ and $F^{\\downarrow}(\\tau^{\\ast})$.\n\n2. Now, consider the numerical solution of the two coupled first-order ordinary differential equations for $I^{\\downarrow}$ and $I^{\\uparrow}$ on a uniform grid of $N$ equal-thickness layers with $\\Delta \\tau = \\tau^{\\ast}/N$. Construct the following three discrete solvers:\n   - A forward (explicit) Euler update for downwelling, marching from $\\tau = 0$ to $\\tau = \\tau^{\\ast}$, and for upwelling, marching from $\\tau = \\tau^{\\ast}$ to $\\tau = 0$:\n     $$\n     I^{\\downarrow}_{n+1} = I^{\\downarrow}_{n} + r\\,\\big(B - I^{\\downarrow}_{n}\\big), \\quad\n     I^{\\uparrow}_{n-1} = I^{\\uparrow}_{n} + r\\,\\big(B - I^{\\uparrow}_{n}\\big),\n     $$\n     where $r = \\Delta \\tau / \\mu_{0}$ and $n$ is the layer index.\n   - A backward (implicit) Euler update:\n     $$\n     I^{\\downarrow}_{n+1} = \\frac{I^{\\downarrow}_{n} + r\\,B}{1 + r}, \\quad\n     I^{\\uparrow}_{n-1} = \\frac{I^{\\uparrow}_{n} + r\\,B}{1 + r}.\n     $$\n   - A flux-limited explicit update that enforces monotonicity and prevents overshoot by limiting $r$ to the interval $[0,1]$:\n     $$\n     r_{\\mathrm{lim}} = \\min\\big(\\max(r,0),1\\big), \\quad\n     I^{\\downarrow}_{n+1} = I^{\\downarrow}_{n} + r_{\\mathrm{lim}}\\,\\big(B - I^{\\downarrow}_{n}\\big), \\quad\n     I^{\\uparrow}_{n-1} = I^{\\uparrow}_{n} + r_{\\mathrm{lim}}\\,\\big(B - I^{\\uparrow}_{n}\\big).\n     $$\n\n3. Define the numerical diffusion or bias for a solver as the relative error (a dimensionless decimal) of the numerically computed flux compared to the closed-form flux, evaluated at the top-of-atmosphere upwelling flux $F^{\\uparrow}(0)$ and at the surface downwelling flux $F^{\\downarrow}(\\tau^{\\ast})$:\n$$\n\\epsilon^{\\uparrow} = \\frac{\\big|F^{\\uparrow}_{\\mathrm{num}}(0) - F^{\\uparrow}_{\\mathrm{exact}}(0)\\big|}{F^{\\uparrow}_{\\mathrm{exact}}(0)}, \\quad\n\\epsilon^{\\downarrow} = \\frac{\\big|F^{\\downarrow}_{\\mathrm{num}}(\\tau^{\\ast}) - F^{\\downarrow}_{\\mathrm{exact}}(\\tau^{\\ast})\\big|}{F^{\\downarrow}_{\\mathrm{exact}}(\\tau^{\\ast})}.\n$$\nExpress the final numerical diffusion or bias values as decimals without units.\n\nImplement a complete, runnable program that:\n- Uses $\\mu_{0} = 1/\\sqrt{3}$.\n- For each test case below, computes and returns the six relative errors corresponding to the explicit Euler, flux-limited explicit, and backward Euler solvers, first for $F^{\\uparrow}(0)$ and then for $F^{\\downarrow}(\\tau^{\\ast})$, in that order.\n\nTest suite:\n- Case 1 (moderate optical thickness, identical layer and surface source): $\\tau^{\\ast} = 1.0$, $N = 2$, $B = 1.0$, $B_{\\mathrm{sfc}} = 1.0$.\n- Case 2 (large optical thickness with coarse layers, cooler surface): $\\tau^{\\ast} = 10.0$, $N = 10$, $B = 1.0$, $B_{\\mathrm{sfc}} = 0.5$.\n- Case 3 (very large optical thickness and coarse layers, warmer surface than layer): $\\tau^{\\ast} = 100.0$, $N = 20$, $B = 0.8$, $B_{\\mathrm{sfc}} = 2.0$.\n- Case 4 (small optical thickness single layer, weakly emitting layer and warm surface): $\\tau^{\\ast} = 0.5$, $N = 1$, $B = 0.2$, $B_{\\mathrm{sfc}} = 1.0$.\n\nFinal output format:\n- Your program should produce a single line of output containing all results aggregated into one comma-separated list enclosed in square brackets. For each case, output the six values in this exact order: $\\epsilon^{\\uparrow}_{\\mathrm{explicit}}$, $\\epsilon^{\\uparrow}_{\\mathrm{limited}}$, $\\epsilon^{\\uparrow}_{\\mathrm{implicit}}$, $\\epsilon^{\\downarrow}_{\\mathrm{explicit}}$, $\\epsilon^{\\downarrow}_{\\mathrm{limited}}$, $\\epsilon^{\\downarrow}_{\\mathrm{implicit}}$. Concatenate the results for the four cases to form one flat list. For example, a valid output would be of the form\n$$\n[\\epsilon^{\\uparrow}_{\\mathrm{explicit,1}},\\epsilon^{\\uparrow}_{\\mathrm{limited,1}},\\epsilon^{\\uparrow}_{\\mathrm{implicit,1}},\\epsilon^{\\downarrow}_{\\mathrm{explicit,1}},\\epsilon^{\\downarrow}_{\\mathrm{limited,1}},\\epsilon^{\\downarrow}_{\\mathrm{implicit,1}}, \\ldots].\n$$\nAll reported values must be decimals without units.",
            "solution": "### Part 1: Analytical Solution\n\nThe problem starts with the plane-parallel radiative transfer equation for pure absorption and emission, with a constant source function $B$, in a two-stream approximation with direction cosine $\\mu_0 = 1/\\sqrt{3}$. The optical depth $\\tau$ is measured downwards from the top of the atmosphere at $\\tau = 0$.\n\nFor the downwelling stream, denoted $I^{\\downarrow}(\\tau)$, the propagation direction cosine is $\\mu = +\\mu_0$. The governing differential equation is:\n$$\n\\mu_0 \\frac{d I^{\\downarrow}(\\tau)}{d \\tau} = -I^{\\downarrow}(\\tau) + B\n$$\nThis is a first-order linear ordinary differential equation, which can be rearranged to:\n$$\n\\frac{d I^{\\downarrow}}{d \\tau} + \\frac{1}{\\mu_0} I^{\\downarrow} = \\frac{B}{\\mu_0}\n$$\nThe integrating factor is $e^{\\int (1/\\mu_0) d\\tau} = e^{\\tau/\\mu_0}$. Multiplying the equation by the integrating factor yields:\n$$\n\\frac{d}{d\\tau} \\left( I^{\\downarrow}(\\tau) e^{\\tau/\\mu_0} \\right) = \\frac{B}{\\mu_0} e^{\\tau/\\mu_0}\n$$\nIntegrating with respect to $\\tau$ gives:\n$$\nI^{\\downarrow}(\\tau) e^{\\tau/\\mu_0} = B e^{\\tau/\\mu_0} + C_1\n$$\nwhere $C_1$ is the constant of integration. The general solution for $I^{\\downarrow}(\\tau)$ is thus:\n$$\nI^{\\downarrow}(\\tau) = B + C_1 e^{-\\tau/\\mu_0}\n$$\nThe boundary condition at the top of the atmosphere ($\\tau=0$) is $I^{\\downarrow}(0) = 0$. Applying this condition:\n$$\n0 = B + C_1 e^{0} \\implies C_1 = -B\n$$\nThe specific solution for the downwelling intensity is:\n$$\nI^{\\downarrow}(\\tau) = B \\left( 1 - e^{-\\tau/\\mu_0} \\right)\n$$\n\nFor the upwelling stream, denoted $I^{\\uparrow}(\\tau)$, the propagation direction cosine is $\\mu = -\\mu_0$. The governing differential equation is:\n$$\n-\\mu_0 \\frac{d I^{\\uparrow}(\\tau)}{d \\tau} = -I^{\\uparrow}(\\tau) + B\n$$\nThis can be rearranged to:\n$$\n\\frac{d I^{\\uparrow}}{d \\tau} - \\frac{1}{\\mu_0} I^{\\uparrow} = -\\frac{B}{\\mu_0}\n$$\nThe integrating factor is $e^{\\int (-1/\\mu_0) d\\tau} = e^{-\\tau/\\mu_0}$. The equation becomes:\n$$\n\\frac{d}{d\\tau} \\left( I^{\\uparrow}(\\tau) e^{-\\tau/\\mu_0} \\right) = -\\frac{B}{\\mu_0} e^{-\\tau/\\mu_0}\n$$\nIntegrating with respect to $\\tau$ gives:\n$$\nI^{\\uparrow}(\\tau) e^{-\\tau/\\mu_0} = B e^{-\\tau/\\mu_0} + C_2\n$$\nThe general solution for $I^{\\uparrow}(\\tau)$ is:\n$$\nI^{\\uparrow}(\\tau) = B + C_2 e^{\\tau/\\mu_0}\n$$\nThe boundary condition is at the surface ($\\tau=\\tau^{\\ast}$), where the upward intensity is given by the surface source function, $I^{\\uparrow}(\\tau^{\\ast}) = B_{\\mathrm{sfc}}$. Applying this condition:\n$$\nB_{\\mathrm{sfc}} = B + C_2 e^{\\tau^{\\ast}/\\mu_0} \\implies C_2 = (B_{\\mathrm{sfc}} - B) e^{-\\tau^{\\ast}/\\mu_0}\n$$\nSubstituting $C_2$ back gives the specific solution for the upwelling intensity:\n$$\nI^{\\uparrow}(\\tau) = B + (B_{\\mathrm{sfc}} - B) e^{(\\tau - \\tau^{\\ast})/\\mu_0}\n$$\n\nFrom these intensities, we derive the required fluxes, $F(\\tau) = 2\\pi\\mu_0 I(\\tau)$.\nThe upwelling flux at the top of the atmosphere, $F^{\\uparrow}(0)$, is found by evaluating $I^{\\uparrow}(\\tau)$ at $\\tau=0$:\n$$\nI^{\\uparrow}(0) = B + (B_{\\mathrm{sfc}} - B) e^{-\\tau^{\\ast}/\\mu_0} = B(1 - e^{-\\tau^{\\ast}/\\mu_0}) + B_{\\mathrm{sfc}} e^{-\\tau^{\\ast}/\\mu_0}\n$$\nThus, the exact top-of-atmosphere upwelling flux is:\n$$\nF^{\\uparrow}_{\\mathrm{exact}}(0) = 2\\pi \\mu_0 \\left[ B(1 - e^{-\\tau^{\\ast}/\\mu_0}) + B_{\\mathrm{sfc}} e^{-\\tau^{\\ast}/\\mu_0} \\right]\n$$\nThe downwelling flux at the surface, $F^{\\downarrow}(\\tau^{\\ast})$, is found by evaluating $I^{\\downarrow}(\\tau)$ at $\\tau=\\tau^{\\ast}$:\n$$\nI^{\\downarrow}(\\tau^{\\ast}) = B(1 - e^{-\\tau^{\\ast}/\\mu_0})\n$$\nThus, the exact surface downwelling flux is:\n$$\nF^{\\downarrow}_{\\mathrm{exact}}(\\tau^{\\ast}) = 2\\pi \\mu_0 B(1 - e^{-\\tau^{\\ast}/\\mu_0})\n$$\n\n### Part 2: Numerical Solvers\n\nThe continuous optical depth domain $[0, \\tau^{\\ast}]$ is discretized into $N$ layers of equal thickness $\\Delta \\tau = \\tau^{\\ast}/N$. This defines $N+1$ levels, $\\tau_n = n \\Delta \\tau$ for $n=0, 1, \\dots, N$. The numerical solution provides intensities $I_n$ at these discrete levels.\n\nThe ODEs are discretized. For the downwelling stream, we use a forward difference for the derivative:\n$$\n\\mu_0 \\frac{I^{\\downarrow}_{n+1} - I^{\\downarrow}_n}{\\Delta\\tau} \\approx -I^{\\downarrow} + B\n$$\nFor the upwelling stream, we use a backward difference:\n$$\n\\mu_0 \\frac{I^{\\uparrow}_{n} - I^{\\uparrow}_{n-1}}{\\Delta\\tau} \\approx -(-I^{\\uparrow} + B) \\implies -\\mu_0 \\frac{I^{\\uparrow}_{n-1} - I^{\\uparrow}_{n}}{\\Delta\\tau} \\approx -I^{\\uparrow} + B\n$$\nThis gives a unified form for marching. Let $r = \\Delta\\tau/\\mu_0$. The downwelling update from level $n$ to $n+1$ and the upwelling update from level $n$ to $n-1$ are derived as follows.\n\n- **Forward (Explicit) Euler**: The right-hand side is evaluated at the known level ($n$ for downwelling, $n$ for upwelling).\n$$\nI^{\\downarrow}_{n+1} - I^{\\downarrow}_n = r(-I^{\\downarrow}_n + B) \\implies I^{\\downarrow}_{n+1} = I^{\\downarrow}_n + r(B - I^{\\downarrow}_n)\n$$\n$$\nI^{\\uparrow}_{n-1} - I^{\\uparrow}_n = r(-I^{\\uparrow}_n + B) \\implies I^{\\uparrow}_{n-1} = I^{\\uparrow}_n + r(B - I^{\\uparrow}_n)\n$$\nThis scheme is simple but only conditionally stable, requiring $r \\le 1$ for monotonic solutions. For $r > 1$, it produces unphysical oscillations.\n\n- **Backward (Implicit) Euler**: The right-hand side is evaluated at the unknown level ($n+1$ for downwelling, $n-1$ for upwelling).\n$$\nI^{\\downarrow}_{n+1} - I^{\\downarrow}_n = r(-I^{\\downarrow}_{n+1} + B) \\implies I^{\\downarrow}_{n+1}(1+r) = I^{\\downarrow}_n + rB \\implies I^{\\downarrow}_{n+1} = \\frac{I^{\\downarrow}_n + rB}{1+r}\n$$\n$$\nI^{\\uparrow}_{n-1} - I^{\\uparrow}_n = r(-I^{\\uparrow}_{n-1} + B) \\implies I^{\\uparrow}_{n-1}(1+r) = I^{\\uparrow}_n + rB \\implies I^{\\uparrow}_{n-1} = \\frac{I^{\\uparrow}_n + rB}{1+r}\n$$\nThis scheme is unconditionally stable for any $r > 0$.\n\n- **Flux-Limited Explicit Euler**: This is a modification of the explicit scheme to enforce stability and monotonicity by limiting the effective step size.\n$$\nr_{\\mathrm{lim}} = \\min(\\max(r, 0), 1)\n$$\nThe update equations are the same as the explicit scheme, but with $r$ replaced by $r_{\\mathrm{lim}}$:\n$$\nI^{\\downarrow}_{n+1} = I^{\\downarrow}_n + r_{\\mathrm{lim}}(B - I^{\\downarrow}_n)\n$$\n$$\nI^{\\uparrow}_{n-1} = I^{\\uparrow}_n + r_{\\mathrm{lim}}(B - I^{\\uparrow}_n)\n$$\nIf $r \\le 1$, this scheme is identical to the explicit one. If $r > 1$, it effectively uses $r_{\\mathrm{lim}}=1$, preventing overshoot and instability but introducing additional numerical diffusion.\n\nThe numerical procedure is as follows:\n1. Initialize $I^{\\downarrow}_{0} = 0$ and $I^{\\uparrow}_{N} = B_{\\mathrm{sfc}}$.\n2. For downwelling, march from $n=0$ to $N-1$, calculating $I^{\\downarrow}_{n+1}$ from $I^{\\downarrow}_{n}$.\n3. For upwelling, march from $n=N$ to $1$, calculating $I^{\\uparrow}_{n-1}$ from $I^{\\uparrow}_{n}$.\n4. The final numerical results are $I^{\\uparrow}_{\\mathrm{num}}(0) = I^{\\uparrow}_0$ and $I^{\\downarrow}_{\\mathrm{num}}(\\tau^{\\ast}) = I^{\\downarrow}_N$. These are used to compute the numerical fluxes.\n\n### Part 3: Error Calculation and Implementation\n\nThe numerical error is quantified by the relative difference between the numerical and exact fluxes:\n$$\n\\epsilon^{\\uparrow} = \\frac{\\left|F^{\\uparrow}_{\\mathrm{num}}(0) - F^{\\uparrow}_{\\mathrm{exact}}(0)\\right|}{F^{\\uparrow}_{\\mathrm{exact}}(0)}\n$$\n$$\n\\epsilon^{\\downarrow} = \\frac{\\left|F^{\\downarrow}_{\\mathrm{num}}(\\tau^{\\ast}) - F^{\\downarrow}_{\\mathrm{exact}}(\\tau^{\\ast})\\right|}{F^{\\downarrow}_{\\mathrm{exact}}(\\tau^{\\ast})}\n$$\nThe implementation will iterate through each test case. For each case, it will first compute the exact fluxes using the analytical formulas from Part 1. Then, for each of the three numerical solvers, it will execute the marching procedure described in Part 2 to find the numerical fluxes. Finally, it will compute the two relative errors, $\\epsilon^{\\uparrow}$ and $\\epsilon^{\\downarrow}$, for each solver, and aggregate the results into a single list as specified.\nThe case where $F^{\\uparrow}_{\\mathrm{exact}}(0) = 0$ or $F^{\\downarrow}_{\\mathrm{exact}}(\\tau^{\\ast}) = 0$ needs special handling for the relative error, but based on the test data and the physical setup (non-zero source functions), this degeneracy does not occur.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the radiative transfer problem for a set of test cases,\n    calculating numerical diffusion for three different solvers.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (tau_star, N, B, B_sfc)\n        (1.0, 2, 1.0, 1.0),\n        (10.0, 10, 1.0, 0.5),\n        (100.0, 20, 0.8, 2.0),\n        (0.5, 1, 0.2, 1.0),\n    ]\n\n    all_results = []\n    mu0 = 1.0 / np.sqrt(3.0)\n\n    for tau_star, N, B, B_sfc in test_cases:\n        # 1. Calculate analytical (exact) solutions\n        # exp_term is e^(-tau_star / mu0)\n        exp_term = np.exp(-tau_star / mu0)\n        \n        # Exact intensity at TOA (tau=0) for upwelling flux\n        I_up_exact_0 = B * (1.0 - exp_term) + B_sfc * exp_term\n        # Exact intensity at surface (tau=tau_star) for downwelling flux\n        I_down_exact_tau_star = B * (1.0 - exp_term)\n\n        # Exact fluxes\n        F_up_exact_0 = 2.0 * np.pi * mu0 * I_up_exact_0\n        F_down_exact_tau_star = 2.0 * np.pi * mu0 * I_down_exact_tau_star\n\n        # 2. Setup for numerical solutions\n        delta_tau = tau_star / N\n        r = delta_tau / mu0\n\n        solvers = {\n            \"explicit\": \"explicit\",\n            \"limited\": \"limited\",\n            \"implicit\": \"implicit\"\n        }\n        \n        case_results = []\n\n        # Order of solvers in the output\n        solver_order = [\"explicit\", \"limited\", \"implicit\"]\n        \n        # Store errors for upwelling and downwelling for each solver\n        errors_up = {}\n        errors_down = {}\n\n        for solver_name, solver_type in solvers.items():\n            I_down_num = np.zeros(N + 1)\n            I_up_num = np.zeros(N + 1)\n\n            # Boundary conditions\n            I_down_num[0] = 0.0\n            I_up_num[N] = B_sfc\n\n            # --- Downwelling calculation (march from n=0 to N-1) ---\n            if solver_type == \"explicit\":\n                for n in range(N):\n                    I_down_num[n+1] = I_down_num[n] + r * (B - I_down_num[n])\n            elif solver_type == \"limited\":\n                r_lim = min(max(r, 0.0), 1.0)\n                for n in range(N):\n                    I_down_num[n+1] = I_down_num[n] + r_lim * (B - I_down_num[n])\n            elif solver_type == \"implicit\":\n                for n in range(N):\n                    I_down_num[n+1] = (I_down_num[n] + r * B) / (1.0 + r)\n\n            # --- Upwelling calculation (march from n=N to 1) ---\n            if solver_type == \"explicit\":\n                for n in range(N, 0, -1):\n                    I_up_num[n-1] = I_up_num[n] + r * (B - I_up_num[n])\n            elif solver_type == \"limited\":\n                r_lim = min(max(r, 0.0), 1.0)\n                for n in range(N, 0, -1):\n                    I_up_num[n-1] = I_up_num[n] + r_lim * (B - I_up_num[n])\n            elif solver_type == \"implicit\":\n                for n in range(N, 0, -1):\n                    I_up_num[n-1] = (I_up_num[n] + r * B) / (1.0 + r)\n            \n            # Numerical fluxes\n            F_up_num_0 = 2.0 * np.pi * mu0 * I_up_num[0]\n            F_down_num_tau_star = 2.0 * np.pi * mu0 * I_down_num[N]\n            \n            # 3. Calculate relative errors (numerical diffusion/bias)\n            if F_up_exact_0 != 0:\n                epsilon_up = abs(F_up_num_0 - F_up_exact_0) / F_up_exact_0\n            else:\n                epsilon_up = 0.0 if F_up_num_0 == 0.0 else float('inf')\n\n            if F_down_exact_tau_star != 0:\n                epsilon_down = abs(F_down_num_tau_star - F_down_exact_tau_star) / F_down_exact_tau_star\n            else:\n                epsilon_down = 0.0 if F_down_num_tau_star == 0.0 else float('inf')\n\n            errors_up[solver_name] = epsilon_up\n            errors_down[solver_name] = epsilon_down\n\n        # Assemble results for the case in the specified order\n        for name in solver_order:\n            case_results.append(errors_up[name])\n        for name in solver_order:\n            case_results.append(errors_down[name])\n        \n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.15f}\".rstrip('0').rstrip('.') if '.' in f\"{res:.15f}\" else f\"{res:.0f}\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}