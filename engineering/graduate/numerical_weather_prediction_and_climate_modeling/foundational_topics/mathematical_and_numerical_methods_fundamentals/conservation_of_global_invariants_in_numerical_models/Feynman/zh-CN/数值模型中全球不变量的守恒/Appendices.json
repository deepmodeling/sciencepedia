{
    "hands_on_practices": [
        {
            "introduction": "守恒性是数值模型需满足的基本物理约束。此练习旨在从第一性原理出发，通过分析一个保守型有限体积格式，来严格证明在一个无源汇的周期性区域中，总质量是如何被精确守恒的。完成此分析推导将帮助你深入理解数值通量“伸缩相消”的离散特性，为你评估和设计高保真度数值格式奠定理论基础。",
            "id": "4025760",
            "problem": "考虑一个被动示踪剂场 $\\phi(\\mathbf{x},t)$，它在一个空间周期性域 $\\Omega \\subset \\mathbb{R}^{d}$ 中被速度场 $\\mathbf{u}(\\mathbf{x},t)$ 平流，该域具有周期性边界 $\\partial\\Omega$。示踪剂满足守恒律 $\\frac{\\partial \\phi}{\\partial t} + \\nabla \\cdot (\\phi \\mathbf{u}) = S$，其中 $S(\\mathbf{x},t)$ 是给定的单位体积源项，且速度场是无散的，即 $\\nabla \\cdot \\mathbf{u} = 0$。假设 $\\phi$ 的物理单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$，$\\mathbf{u}$ 的单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$，因此积分 $\\int_{\\Omega} \\phi\\, dV$ 的单位为 $\\mathrm{kg}$，其时间导数的单位为 $\\mathrm{kg}\\,\\mathrm{s}^{-1}$。\n\n用固定的剖分将 $\\Omega$ 离散为 $N$ 个不重叠的控制体 $\\{C_{i}\\}_{i=1}^{N}$，其体积为 $V_{i}$，平面面为 $\\{f\\}$，面积为 $A_{f}$。对于由网格 $i$ 和 $j$ 共享的每个内部面 $f$，固定一个从 $C_{i}$ 指向 $C_{j}$ 的唯一外向单位法向量 $\\mathbf{n}_{f}$。令 $\\phi_{i}(t)$ 表示 $\\phi$ 在 $C_{i}$ 上的网格平均值，并令 $\\Phi_{f}$ 表示数值面通量，它一致地逼近 $(\\phi \\mathbf{u}) \\cdot \\mathbf{n}_{f} A_{f}$，其格式的理论精度为2阶，该通量通过在每个面上从合适的迎风侧进行单面、守恒的线性重构来构造。每个网格 $i$ 的有限体积更新方程为\n$$\n\\frac{d}{dt}\\big(\\phi_{i} V_{i}\\big) = - \\sum_{f \\subset \\partial C_{i}} s_{i,f}\\,\\Phi_{f} + S_{i} V_{i},\n$$\n其中 $s_{i,f} \\in \\{-1,+1\\}$ 是表示固定的面法向量 $\\mathbf{n}_{f}$ 指向网格 $C_{i}$ 的外部（$+1$）还是内部（$-1$）的符号，而 $S_{i}$ 是 $S$ 在 $C_{i}$ 中的网格平均值。在周期性边界上，面与其方向相反的对应面配对，因此适用相同的约定。\n\n仅从连续守恒律、无散性质、周期性以及所述的守恒型有限体积形式（包括单面通量构造和符号约定）出发，推导所述二阶有限体积平流格式所蕴含的、域内积分示踪剂总量的全局变化率的精确表达式：\n$$\n\\frac{d}{dt}\\int_{\\Omega} \\phi\\, dV,\n$$\n然后，对于 $S \\equiv 0$ 的特殊情况，计算 $\\frac{d}{dt}\\int_{\\Omega}\\phi\\, dV$ 的值。以 $\\mathrm{kg}\\,\\mathrm{s}^{-1}$ 为单位表示您的最终答案，仅在需要时进行四舍五入；在最终的方框答案中不要包含任何单位符号。没有提供提示公式；您必须根据守恒律、守恒型有限体积法中的面通量反对称性以及周期性边界条件进行推理，以得出结论。",
            "solution": "问题要求解由特定有限体积数值格式所蕴含的、周期性域 $\\Omega$ 内被动示踪剂 $\\phi$ 总量的变化率。\n\n令由离散模型表示的域内示踪剂总量为 $M(t)$。这是每个控制体 $C_i$ 中示踪剂质量的总和：\n$$\nM(t) = \\sum_{i=1}^{N} \\phi_i(t) V_i\n$$\n这里，$\\phi_i(t)$ 是体积为 $V_i$ 的网格 $C_i$ 中的网格平均浓度，N 是网格总数。问题要求基于所提供的数值格式推导 $\\frac{dM}{dt}$ 的表达式。\n\n单个网格 $C_i$ 中示踪剂含量的时间演化由有限体积更新方程给出：\n$$\n\\frac{d}{dt}\\big(\\phi_{i} V_{i}\\big) = - \\sum_{f \\subset \\partial C_{i}} s_{i,f}\\,\\Phi_{f} + S_{i} V_{i}\n$$\n其中 $\\Phi_f$ 是穿过面 $f$ 的数值通量，$s_{i,f}$ 是一个符号因子，$S_i$ 是网格平均源项。\n\n为了求出示踪剂总量 $M(t)$ 的变化率，我们将域中所有 $N$ 个控制体的各个变化率相加：\n$$\n\\frac{dM}{dt} = \\frac{d}{dt}\\left(\\sum_{i=1}^{N} \\phi_i V_i\\right) = \\sum_{i=1}^{N} \\frac{d}{dt}(\\phi_i V_i)\n$$\n将给定的有限体积方程代入此和式，得到：\n$$\n\\frac{dM}{dt} = \\sum_{i=1}^{N} \\left( - \\sum_{f \\subset \\partial C_{i}} s_{i,f}\\,\\Phi_{f} + S_{i} V_{i} \\right)\n$$\n我们可以将这些项分为一个通量求和项和一个源项求和项：\n$$\n\\frac{dM}{dt} = - \\left( \\sum_{i=1}^{N} \\sum_{f \\subset \\partial C_{i}} s_{i,f}\\,\\Phi_{f} \\right) + \\left( \\sum_{i=1}^{N} S_{i} V_{i} \\right)\n$$\n我们来分析通量求和项 $\\mathcal{F} = \\sum_{i=1}^{N} \\sum_{f \\subset \\partial C_{i}} s_{i,f}\\,\\Phi_{f}$。这代表了所有网格的所有面上的通量之和。我们可以分析每个面对这个全局和的贡献。\n\n守恒型有限体积格式的一个关键特征是，对于每个面 $f$，数值通量 $\\Phi_f$ 是唯一定义的。问题指出，该格式采用“单面、守恒”的构造方法，这保证了此属性。\n\n考虑一个由两个相邻控制体 $C_i$ 和 $C_j$ 共享的内部面 $f$。问题为该面定义了一个固定的单位法向量 $\\mathbf{n}_f$，从 $C_i$ 指向 $C_j$。\n根据符号约定：\n- 对于网格 $C_i$，法向量 $\\mathbf{n}_f$ 指向外部，因此 $s_{i,f} = +1$。该面从网格 $C_i$ 对总和 $\\mathcal{F}$ 的贡献是 $(+1)\\Phi_f$。\n- 对于网格 $C_j$，同一个法向量 $\\mathbf{n}_f$ 指向内部，因此 $s_{j,f} = -1$。该面从网格 $C_j$ 对总和 $\\mathcal{F}$ 的贡献是 $(-1)\\Phi_f$。\n\n当我们对所有网格求和时，来自此内部面 $f$ 的总贡献是来自 $C_i$ 和 $C_j$ 的贡献之和，即 $(+1)\\Phi_f + (-1)\\Phi_f = 0$。因此，所有穿过内部面的通量都成对抵消了。\n\n现在，考虑域边界 $\\partial\\Omega$ 上的面。问题指出域是周期性的。在周期性域中，域一侧的每个边界面都与另一侧相应的边界面等同。这种配对有效地使域在拓扑上是闭合的，没有外部边界。这对周期性边界面作为一个逻辑上的内部界面。“单面、守恒”的通量构造和符号约定同样适用于这些逻辑界面，就像它们适用于几何内部面一样。因此，当在整个域上求和时，来自这些周期性边界面的通量贡献也成对抵消。\n\n由于所有内部面通量和所有周期性边界面通量都相互抵消，总通量和恒为零：\n$$\n\\mathcal{F} = \\sum_{i=1}^{N} \\sum_{f \\subset \\partial C_{i}} s_{i,f}\\,\\Phi_{f} = 0\n$$\n这个结果是守恒型有限体积格式在封闭或周期性域上的一个基本性质。关于格式是二阶或速度场是无散的这些细节，虽然对格式的其他性质很重要，但对于证明这一全局守恒性质并非必需。\n\n将此结果代回 $\\frac{dM}{dt}$ 的表达式中，我们发现：\n$$\n\\frac{dM}{dt} = - (0) + \\sum_{i=1}^{N} S_{i} V_{i}\n$$\n因此，所述有限体积格式所蕴含的、域内积分示踪剂总量的全局变化率的精确表达式为：\n$$\n\\frac{d}{dt}\\left(\\sum_{i=1}^{N} \\phi_i V_i\\right) = \\sum_{i=1}^{N} S_{i} V_{i}\n$$\n这表明该格式正确地确保了示踪剂总量仅因源项 $S$ 的积分效应而改变。\n\n问题的第二部分要求计算当源项 $S$ 恒为零，即 $S(\\mathbf{x},t) \\equiv 0$ 时的这个值。如果函数 $S$ 处处为零，那么它在任何控制体 $C_i$ 上的平均值也必定为零：\n$$\nS_{i} = \\frac{1}{V_i} \\int_{C_i} S(\\mathbf{x},t) dV = \\frac{1}{V_i} \\int_{C_i} 0 \\, dV = 0 \\quad \\text{for all } i=1, \\dots, N\n$$\n将 $S_i = 0$ 代入我们推导出的变化率表达式中，得到：\n$$\n\\frac{dM}{dt} = \\sum_{i=1}^{N} (0) V_{i} = 0\n$$\n在没有源项的情况下，域内积分示踪剂总量的全局变化率的值是 $0$。根据问题的规定，单位应为 $\\mathrm{kg}\\,\\mathrm{s}^{-1}$。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "理论上的通量守恒在复杂的真实网格上实现时会面临几何挑战。本实践将指导你在立方球网格上构建一个有限体积格式，通过编码数值验证所有面板边界上的通量之和是否能达到机器精度级别的抵消。这个练习旨在将抽象的守恒原理与全球模型中复杂的几何计算和编程实践联系起来，展示全局质量守恒是如何在离散层面被精确维护的。",
            "id": "4025781",
            "problem": "考虑在立方球 (CS) 上对单位球面二维表面上的标量示踪场进行保守有限体积 (FV) 离散化。目标是证明，在所有面板边界上，面积加权通量的离散总和可以抵消至机器精度，从而在全局上保持全局质量守恒 (GMC)。\n\n作为起点的基本定律和核心定义：\n- 在光滑的二维流形（单位球面）上，由切向速度 $\\mathbf{u}(\\mathbf{r},t)$ 输运的标量场 $q(\\mathbf{r},t)$ 的表面连续性方程为\n$$\\frac{\\mathrm{d}}{\\mathrm{d}t}\\int_{\\Omega} q \\, \\mathrm{d}A = -\\oint_{\\partial \\Omega} q\\, \\mathbf{u}\\cdot \\mathbf{n}_s \\, \\mathrm{d}s,$$\n其中 $\\Omega$ 是一个表面控制体积，$\\partial \\Omega$ 是其边界曲线，$\\mathbf{n}_s$ 是切平面内向外的单位法线（垂直于边界切线），$\\mathrm{d}A$ 和 $\\mathrm{d}s$ 分别是面积元和弧长元。\n- 有限体积法通过边通量之和来近似边界积分，\n$$\\mathcal{F}_e \\approx q_e \\, (\\mathbf{u}_e \\cdot \\mathbf{n}_{s,e})\\, \\ell_e,$$\n其中 $q_e$ 是边中心的示踪剂值，$\\mathbf{u}_e$ 是边中心的切向速度，$\\mathbf{n}_{s,e}$ 是边上表面内向外的单位法线，$\\ell_e$ 是边长。\n\n立方球等角球心投影映射：\n- 对每个 CS 面板，定义面板局部坐标 $(\\alpha,\\beta)\\in[-\\pi/4,\\pi/4]\\times[-\\pi/4,\\pi/4]$ 和球心投影坐标 $(\\xi,\\eta)=(\\tan\\alpha,\\tan\\beta)$。\n- 从面板局部坐标到单位球面 $\\mathbf{r}(\\alpha,\\beta)$ 的映射通过归一化一个与面相关的向量来给出：\n  - 面板 $+X$：$\\mathbf{r} = \\frac{1}{\\|\\mathbf{v}\\|}\\mathbf{v}$，其中 $\\mathbf{v}=(1,\\tan\\alpha,\\tan\\beta)$。\n  - 面板 $-X$：$\\mathbf{v}=(-1,\\tan\\alpha,\\tan\\beta)$。\n  - 面板 $+Y$：$\\mathbf{v}=(\\tan\\alpha,1,\\tan\\beta)$。\n  - 面板 $-Y$：$\\mathbf{v}=(\\tan\\alpha,-1,\\tan\\beta)$。\n  - 面板 $+Z$：$\\mathbf{v}=(\\tan\\alpha,\\tan\\beta,1)$。\n  - 面板 $-Z$：$\\mathbf{v}=(\\tan\\alpha,\\tan\\beta,-1)$。\n- 单位球面的半径为 $R=1$，位置向量 $\\mathbf{r}=(x,y,z)$ 满足 $\\|\\mathbf{r}\\|=1$。\n\n球面上的速度场：\n- 可以通过将一个常数向量 $\\mathbf{a}$ 投影到切平面上来构造切向速度：\n$$\\mathbf{u}(\\mathbf{r}) = \\mathbf{a} - (\\mathbf{a}\\cdot \\mathbf{r})\\, \\mathbf{r},$$\n该速度在各处都与单位球面相切。\n- 角速度为 $\\boldsymbol{\\omega}$ 的刚体旋转会产生一个切向速度\n$$\\mathbf{u}(\\mathbf{r}) = \\boldsymbol{\\omega}\\times \\mathbf{r}。$$\n\n立方球上的边几何：\n- 一条边由两个相邻的边界节点 $\\mathbf{r}_0$ 和 $\\mathbf{r}_1$ 定义。其中点是 $\\mathbf{r}_m=\\frac{\\mathbf{r}_0+\\mathbf{r}_1}{\\|\\mathbf{r}_0+\\mathbf{r}_1\\|}$。\n- 边长是大圆距离\n$$\\ell_e = \\arccos\\big(\\mathbf{r}_0\\cdot\\mathbf{r}_1\\big)。$$\n- 大圆平面法线为 $\\mathbf{n}_p=\\mathbf{r}_0\\times\\mathbf{r}_1$。在 $\\mathbf{r}_m$ 处沿边的单位切线是\n$$\\mathbf{t}_e = \\frac{\\mathbf{n}_p\\times \\mathbf{r}_m}{\\|\\mathbf{n}_p\\times \\mathbf{r}_m\\|}。$$\n- 一个候选的表面内向外单位法线是\n$$\\mathbf{n}_{s,e}^\\star = \\frac{\\mathbf{t}_e\\times \\mathbf{r}_m}{\\|\\mathbf{t}_e\\times \\mathbf{r}_m\\|}。$$\n$\\mathbf{n}_{s,e}$ 的符号选择使其指向远离面板内部，该方向由从面板局部坐标增量推断出的局部内部方向确定。例如，在左边界 $\\alpha=-\\pi/4$，内部方向是沿 $\\alpha$ 增大的方向；在右边界 $\\alpha=\\pi/4$，内部方向是沿 $\\alpha$ 减小的方向；底部和顶部边界对 $\\beta$ 的情况也类似。\n\n离散有限体积通量：\n- 对每个边界段使用线积分通量：\n$$\\mathcal{F}_e = q(\\mathbf{r}_m) \\, \\big(\\mathbf{u}(\\mathbf{r}_m)\\cdot \\mathbf{n}_{s,e}\\big)\\, \\ell_e,$$\n其中 $q(\\mathbf{r})$ 是在边中点处求值的给定光滑场（因此在单元更新中使用时，代表了一个面积加权的边中心值）。\n- 从一个面板流出的净通量是其边界段上 $\\mathcal{F}_e$ 的总和，其中 $\\mathbf{n}_{s,e}$ 被选为相对于面板内部向外。\n\n演示目标：\n- 数值上证明，当对所有六个面板的净流出通量求和时，每个共享边界段会贡献两次，且符号相反（由于向外法线方向相反），因此总和抵消至机器精度。\n\n实现任务：\n1. 通过在 $[-\\pi/4,\\pi/4]$ 上对 $(\\alpha,\\beta)$ 进行弧度均匀采样，为每个面板构建节点。每个方向有 $N+1$ 个节点，从而沿每条边产生 $N$ 个段。\n2. 对每个面板，构建其边界段（左、右、底、顶），计算 $\\mathbf{r}_0$、$\\mathbf{r}_1$、$\\mathbf{r}_m$、$\\ell_e$、$\\mathbf{t}_e$，并使用通过面板局部增量的内部方向测试来确定向外的 $\\mathbf{n}_{s,e}$。\n3. 定义光滑的示踪剂场和速度场：\n   - 示踪剂场：$q(\\mathbf{r}) = \\sin(2\\lambda)\\cos\\varphi$，其中 $\\lambda=\\arctan2(y,x)$ 是经度（弧度），$\\varphi=\\arcsin(z)$ 是纬度（弧度）。\n   - 速度场：如上所述的投影常数向量或刚体旋转。\n4. 计算每个面板的净流出通量 $\\mathcal{F}_{\\text{panel}}=\\sum_e \\mathcal{F}_e$，然后计算所有六个面板的总和并报告其绝对值。\n5. 测试套件规格：\n   - 使用以下测试用例，每个用例由 $(N,\\text{场类型},\\text{参数})$ 指定：\n     - 用例 1：$(N=4,\\text{投影},\\mathbf{a}=(0.3,-0.5,0.7))$。\n     - 用例 2：$(N=8,\\text{投影},\\mathbf{a}=(-0.1,0.2,0.3))$。\n     - 用例 3：$(N=4,\\text{旋转},\\boldsymbol{\\omega}=(0,0,1))$。\n     - 用例 4：$(N=1,\\text{投影},\\mathbf{a}=(0.9,-0.4,0.2))$（具有最低分辨率的边缘情况）。\n6. 单位规格：角度以弧度为单位；鉴于单位球面半径 $R=1$ 以及无量纲的示踪剂 $q$ 和速度参数，通量的大小是无量纲的。将最终总和报告为浮点数。\n7. 最终输出规格：您的程序应生成单行输出，其中包含四个用例的总通量和的绝对值，形式为用方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3,result4]\"），其中每个结果都是一个浮点数。\n\n您的代码必须精确实现上述步骤，并产生指定的输出格式。不需要用户输入。通过归一化向量、将反三角函数的参数裁剪到 $[-1,1]$ 区间，以及通过内部方向测试仔细选择向外法线符号，来确保数值鲁棒性。",
            "solution": "该问题陈述是计算流体动力学中一个有效且适定的练习，具体涉及数值方案中守恒性质的验证。其科学基础是流形上的向量微积分和有限体积法的原理。所有必需的定义、方程和参数都已提供，目标明确且可通过数值验证。因此，我们将着手提供一个完整的解决方案。\n\n需要证明的核心原理是，在单位球面上输运的标量示踪场 $q$ 的全局质量守恒 (GMC)。在一个没有源或汇的连续系统中，总质量，即 $q$ 在整个球面 $S^2$ 上的积分，必须随时间保持恒定。\n$$ \\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{S^2} q \\, \\mathrm{d}A = 0 $$\n对输运方程应用散度定理（或在此二维流形背景下的斯托克斯定理），这个守恒定律等价于通量散度在整个域上的积分为零的陈述。对于像球面这样没有边界的封闭流形，当在整个域上求和时，穿过任何分割域的闭合曲线的净通量必须为零。\n\n在有限体积 (FV) 离散化中，域被划分为有限数量的控制体积（单元）。对于立方球 (CS) 网格，球面被划分为六个面板，每个面板对应于一个立方体的面。每个面板再被细分为 $N \\times N$ 个单元。一个单元内的质量变化由穿过其边界的通量之和决定。如果对于任何两个相邻单元，离开一个单元、穿过它们共享边界的通量，与进入另一个单元的通量完全相同，那么就实现了全局守恒。这要求通量计算是守恒的。\n\n该问题要求在面板级别上验证此属性。如果我们对所有六个面板的净流出通量求和，那么所有面板间共享的内部边的贡献必须完全抵消，最终得到的总和在机器精度内为零。这证实了离散通量公式在全局上是守恒示踪剂量的。\n\n分步推导和实现计划如下：\n\n**1. 立方球网格生成**\n\n立方球网格是通过将立方体的面投影到一个同心球面上生成的。我们使用等角球心投影。对于六个面板中的每一个，我们定义一个局部坐标系 $(\\alpha, \\beta)$，其中 $\\alpha$ 和 $\\beta$ 的范围都是从 $-\\pi/4$ 到 $+\\pi/4$。这些角度通过 $\\xi = \\tan\\alpha$ 和 $\\eta=\\tan\\beta$ 与球心投影坐标 $(\\xi, \\eta)$ 相关联。\n\n面板上的一个点被映射到一个三维向量 $\\mathbf{v}$，然后将其归一化以获得单位球面上的位置向量 $\\mathbf{r}$（$\\|\\mathbf{r}\\|=1$）。每个面板的具体映射如下：\n- 面板 $+X$：$\\mathbf{v}=(1, \\tan\\alpha, \\tan\\beta)$\n- 面板 $-X$：$\\mathbf{v}=(-1, \\tan\\alpha, \\tan\\beta)$\n- 面板 $+Y$：$\\mathbf{v}=(\\tan\\alpha, 1, \\tan\\beta)$\n- 面板 $-Y$：$\\mathbf{v}=(\\tan\\alpha, -1, \\tan\\beta)$\n- 面板 $+Z$：$\\mathbf{v}=(\\tan\\alpha, \\tan\\beta, 1)$\n- 面板 $-Z$：$\\mathbf{v}=(\\tan\\alpha, \\tan\\beta, -1)$\n\n对于每个方向 $N$ 个单元的网格分辨率，我们需要 $N+1$ 个节点。面板局部坐标 $(\\alpha_i, \\beta_j)$ 被均匀离散化：\n$$ \\alpha_i = -\\frac{\\pi}{4} + i \\cdot \\Delta\\alpha, \\quad i \\in \\{0, 1, \\dots, N\\} $$\n$$ \\beta_j = -\\frac{\\pi}{4} + j \\cdot \\Delta\\beta, \\quad j \\in \\{0, 1, \\dots, N\\} $$\n其中 $\\Delta\\alpha = \\Delta\\beta = \\frac{\\pi/2}{N}$。这些 $(\\alpha_i, \\beta_j)$ 对被用来生成每个面板的网格节点的三维笛卡尔坐标 $\\mathbf{r}_{i,j}$。\n\n**2. 边界边几何与通量计算**\n\n我们通过对每个面板的四条边界（左、右、底、顶）上的所有段的通量求和，来计算从每个面板流出的净通量。对于由两个节点 $\\mathbf{r}_0$ 和 $\\mathbf{r}_1$ 定义的单个边段，离散通量为：\n$$ \\mathcal{F}_e = q(\\mathbf{r}_m) \\, \\big(\\mathbf{u}(\\mathbf{r}_m)\\cdot \\mathbf{n}_{s,e}\\big)\\, \\ell_e $$\n几何和物理分量的计算如下：\n\n- **边中点：** 中点 $\\mathbf{r}_m$ 通过平均节点向量并重新投影到单位球面上得到：\n  $$ \\mathbf{r}_m = \\frac{\\mathbf{r}_0 + \\mathbf{r}_1}{\\|\\mathbf{r}_0 + \\mathbf{r}_1\\|} $$\n- **边长：** 长度 $\\ell_e$ 是 $\\mathbf{r}_0$ 和 $\\mathbf{r}_1$ 之间的大圆距离。为确保数值稳定性，$\\arccos$ 的参数被裁剪到 $[-1, 1]$ 区间。\n  $$ \\ell_e = \\arccos(\\text{clip}(\\mathbf{r}_0\\cdot\\mathbf{r}_1, -1, 1)) $$\n- **向外法向量：** 这是确保守恒最关键的组成部分。过程如下：\n  a. 计算一个候选法线 $\\mathbf{n}_{s,e}^\\star$，它同时垂直于径向方向 $\\mathbf{r}_m$ 和边切线 $\\mathbf{t}_e$。\n     $$ \\mathbf{n}_p = \\mathbf{r}_0 \\times \\mathbf{r}_1 \\quad (\\text{大圆平面法线}) $$\n     $$ \\mathbf{t}_e = \\frac{\\mathbf{n}_p \\times \\mathbf{r}_m}{\\|\\mathbf{n}_p \\times \\mathbf{r}_m\\|} \\quad (\\text{在 } \\mathbf{r}_m \\text{ 处沿边的单位切线}) $$\n     $$ \\mathbf{n}_{s,e}^\\star = \\frac{\\mathbf{t}_e \\times \\mathbf{r}_m}{\\|\\mathbf{t}_e \\times \\mathbf{r}_m\\|} \\quad (\\text{切平面内的候选单位法线}) $$\n  b. 确定正确的方向（向外 vs. 向内）。这通过“内部方向测试”实现。我们构造一个从边指向面板内部的向量，并确保法线 $\\mathbf{n}_{s,e}$ 指向相反方向。通过从边中点的 $(\\alpha, \\beta)$ 坐标向面板内部迈出一小步，可以找到一个指向内部的向量 $\\mathbf{v}_{\\text{int}}$。例如，在左边界（$\\alpha = -\\pi/4$），内部是朝向 $\\alpha > -\\pi/4$ 的方向。我们可以计算在 $(\\alpha+\\delta\\alpha, \\beta)$ 处的一个点 $\\mathbf{r}_{\\text{int}}$，其中 $\\delta\\alpha > 0$ 是一个小数。从 $\\mathbf{r}_m$ 到 $\\mathbf{r}_{\\text{int}}$ 的向量，投影到 $\\mathbf{r}_m$ 处的切平面上，就给出了内部方向。选择 $\\mathbf{n}_{s,e}$ 的符号，使其与这个指向内部的向量的点积为负。设 $\\mathbf{v}_{\\text{in,tan}}$ 是指向内部向量的切平面分量。\n     $$ \\text{sign} = \\text{sgn}(\\mathbf{v}_{\\text{in,tan}} \\cdot \\mathbf{n}_{s,e}^\\star) $$\n     向外法线是 $\\mathbf{n}_{s,e} = -\\text{sign} \\cdot \\mathbf{n}_{s,e}^\\star$。这个精确、一致的定义确保了对于两个面板之间任何共享的边，它们各自的向外法线大小相等，方向相反：$\\mathbf{n}_{s,e}^{(\\text{面板 1})} = -\\mathbf{n}_{s,e}^{(\\text{面板 2})}$。\n\n**3. 物理场**\n\n问题指定了一个光滑的示踪剂场和两种类型的速度场，它们都在边中点 $\\mathbf{r}_m = (x_m, y_m, z_m)$ 处求值。\n- **示踪剂场：** $q(\\mathbf{r}) = \\sin(2\\lambda)\\cos\\varphi$，其中经度 $\\lambda = \\arctan2(y_m, x_m)$，纬度 $\\varphi = \\arcsin(z_m)$。\n- **投影速度场：** 一个常数向量 $\\mathbf{a}$ 被投影到 $\\mathbf{r}_m$ 处的切平面上：\n  $$ \\mathbf{u}(\\mathbf{r}_m) = \\mathbf{a} - (\\mathbf{a}\\cdot \\mathbf{r}_m)\\, \\mathbf{r}_m $$\n- **刚体旋转速度场：** 由角速度为 $\\boldsymbol{\\omega}$ 的刚体旋转所引起的速度场：\n  $$ \\mathbf{u}(\\mathbf{r}_m) = \\boldsymbol{\\omega}\\times \\mathbf{r}_m $$\n\n**4. 求和与验证**\n\n对于六个面板中的每一个，我们通过对其所有 $4N$ 个边界边上的通量 $\\mathcal{F}_e$ 求和，来计算净流出通量 $\\mathcal{F}_{\\text{panel}}$。\n$$ \\mathcal{F}_{\\text{panel}} = \\sum_{e \\in \\partial(\\text{panel})} \\mathcal{F}_e $$\n全局总通量是这些面板通量的总和：\n$$ \\mathcal{F}_{\\text{total}} = \\sum_{k=1}^{6} \\mathcal{F}_{\\text{panel}, k} $$\n因为对于每个内部边，几何项是相同的，而向外法线是相反的，所以它们的通量贡献会抵消，即 $\\mathcal{F}_e^{(1)} + \\mathcal{F}_e^{(2)} = 0$。因此，总和 $\\mathcal{F}_{\\text{total}}$ 应该为零。实现将计算这个总和，并报告其绝对值，由于浮点运算，预期该值在机器精度级别。这验证了离散通量公式的守恒性质。\n所提供的具有不同分辨率 $N$ 和速度场的测试用例，将用于证明该性质的鲁棒性。",
            "answer": "```python\nimport numpy as np\n\ndef gnomonic_map(panel_idx, alpha, beta):\n    \"\"\"\n    Maps panel-local coordinates (alpha, beta) to 3D Cartesian coordinates\n    on the unit sphere for a given panel index.\n    \"\"\"\n    v = np.zeros(3)\n    tan_a, tan_b = np.tan(alpha), np.tan(beta)\n    \n    if panel_idx == 0:  # +X\n        v = np.array([1.0, tan_a, tan_b])\n    elif panel_idx == 1:  # -X\n        v = np.array([-1.0, tan_a, tan_b])\n    elif panel_idx == 2:  # +Y\n        v = np.array([tan_a, 1.0, tan_b])\n    elif panel_idx == 3:  # -Y\n        v = np.array([tan_a, -1.0, tan_b])\n    elif panel_idx == 4:  # +Z\n        v = np.array([tan_a, tan_b, 1.0])\n    elif panel_idx == 5:  # -Z\n        v = np.array([tan_a, tan_b, -1.0])\n    \n    norm_v = np.linalg.norm(v)\n    return v / norm_v if norm_v > 0 else v\n\ndef get_panel_nodes(panel_idx, N):\n    \"\"\"\n    Constructs the N+1 x N+1 node coordinates for a given panel.\n    \"\"\"\n    nodes = np.zeros((N + 1, N + 1, 3))\n    alpha_vals = np.linspace(-np.pi / 4, np.pi / 4, N + 1)\n    beta_vals = np.linspace(-np.pi / 4, np.pi / 4, N + 1)\n    \n    for i in range(N + 1):\n        for j in range(N + 1):\n            nodes[i, j, :] = gnomonic_map(panel_idx, alpha_vals[i], beta_vals[j])\n            \n    return nodes\n\ndef get_tracer_field(r):\n    \"\"\"\n    Computes the scalar tracer field q at position r = (x, y, z).\n    \"\"\"\n    x, y, z = r\n    # Clip z to avoid domain errors with arcsin\n    z_clipped = np.clip(z, -1.0, 1.0)\n    \n    lam = np.arctan2(y, x)  # longitude\n    phi = np.arcsin(z_clipped)  # latitude\n    \n    return np.sin(2 * lam) * np.cos(phi)\n\ndef get_velocity_field(r, vel_type, params):\n    \"\"\"\n    Computes the velocity vector u at position r for a given field type.\n    \"\"\"\n    if vel_type == 'projected':\n        a = np.array(params)\n        u = a - (np.dot(a, r)) * r\n    elif vel_type == 'rotation':\n        omega = np.array(params)\n        u = np.cross(omega, r)\n    else:\n        raise ValueError(\"Unknown velocity field type\")\n    return u\n\ndef calculate_total_flux(N, vel_type, params):\n    \"\"\"\n    Calculates the sum of net outward fluxes over all six panels of the cubed-sphere.\n    \"\"\"\n    total_global_flux = 0.0\n    \n    for panel_idx in range(6):\n        panel_flux = 0.0\n        nodes = get_panel_nodes(panel_idx, N)\n        \n        # Define boundaries: (start_idx, end_idx, fixed_coord, step_dir)\n        # fixed_coord: 0 for alpha, 1 for beta\n        # step_dir: 1 for increasing index, -1 for decreasing index\n        # The indices define the start and end of the loop over segments.\n        boundaries = {\n            'bottom': (nodes[:, 0], 0, -np.pi/4, 1), # beta = -pi/4, interior is +beta\n            'top': (nodes[:, -1], 0, np.pi/4, -1),   # beta = +pi/4, interior is -beta\n            'left': (nodes[0, :], 1, -np.pi/4, 1),  # alpha = -pi/4, interior is +alpha\n            'right': (nodes[-1, :], 1, np.pi/4, -1)  # alpha = +pi/4, interior is -alpha\n        }\n        \n        alpha_coords = np.linspace(-np.pi/4, np.pi/4, N + 1)\n        beta_coords = np.linspace(-np.pi/4, np.pi/4, N + 1)\n\n        for _, (boundary_nodes, maj_ax, coord_val, sign_dir) in boundaries.items():\n            for i in range(N):\n                r0 = boundary_nodes[i]\n                r1 = boundary_nodes[i+1]\n                \n                # Edge midpoint\n                r_m = (r0 + r1) / np.linalg.norm(r0 + r1)\n                \n                # Edge length\n                dot_prod = np.clip(np.dot(r0, r1), -1.0, 1.0)\n                l_e = np.arccos(dot_prod)\n\n                if l_e  1e-15: continue\n\n                # Candidate outward normal\n                n_p = np.cross(r0, r1)\n                t_e_un = np.cross(n_p, r_m)\n                t_e = t_e_un / np.linalg.norm(t_e_un)\n                n_s_star_un = np.cross(t_e, r_m)\n                n_s_star = n_s_star_un / np.linalg.norm(n_s_star_un)\n\n                # Interior direction test for sign of normal\n                delta = 1e-8 # small step\n                if maj_ax == 0: # bottom or top, vary beta\n                    a_m = (alpha_coords[i] + alpha_coords[i+1]) / 2.0\n                    b_m_int = coord_val + sign_dir * delta\n                    r_int = gnomonic_map(panel_idx, a_m, b_m_int)\n                else: # left or right, vary alpha\n                    a_m_int = coord_val + sign_dir * delta\n                    b_m = (beta_coords[i] + beta_coords[i+1]) / 2.0\n                    r_int = gnomonic_map(panel_idx, a_m_int, b_m)\n\n                v_int = r_int - r_m\n                v_int_tan = v_int - np.dot(v_int, r_m) * r_m\n                \n                # The normal must point away from the interior\n                sign = np.sign(np.dot(v_int_tan, n_s_star))\n                n_s_e = sign * n_s_star\n\n                # Evaluate fields at midpoint\n                q_m = get_tracer_field(r_m)\n                u_m = get_velocity_field(r_m, vel_type, params)\n                \n                # Calculate flux for the edge\n                flux_e = q_m * np.dot(u_m, n_s_e) * l_e\n                panel_flux += flux_e\n\n        total_global_flux += panel_flux\n        \n    return abs(total_global_flux)\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    \n    test_cases = [\n        {'N': 4, 'type': 'projected', 'params': (0.3, -0.5, 0.7)},\n        {'N': 8, 'type': 'projected', 'params': (-0.1, 0.2, 0.3)},\n        {'N': 4, 'type': 'rotation', 'params': (0.0, 0.0, 1.0)},\n        {'N': 1, 'type': 'projected', 'params': (0.9, -0.4, 0.2)},\n    ]\n\n    results = []\n    for case in test_cases:\n        total_flux = calculate_total_flux(case['N'], case['type'], case['params'])\n        results.append(total_flux)\n\n    # Format the final output exactly as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "即使数值格式在理论上是守恒的，长时间积分中的累积误差仍会导致全局不变量（如总质量和总能量）发生漂移。本练习要求你设计一个完整的数值实验，在一个一维浅水波模型中量化这种漂移，并实现一种全局校正策略来强制约束质量和能量守恒。通过这个综合性项目，你将亲身体验从诊断数值耗散到主动修正模型状态的全过程，这对于确保气候模型等长期模拟的物理真实性和稳定性至关重要。",
            "id": "4025765",
            "problem": "您的任务是设计并实现一个独立的数值实验，用以量化和校正一个代表大规模地球物理流动的非线性双曲系统中的全局不变量漂移。使用周期域上的一维无粘浅水方程作为原型系统，这是数值天气预报和气候模拟中评估全局不变量守恒性的标准简化模型。在整个过程中，请使用无量纲单位；不需要物理单位。\n\n请基于以下基本定律和核心定义进行推导：\n- 长度为 $L$ 的周期域上的一维无粘浅水方程由下式给出：\n  - 连续性方程：$\\partial_t h + \\partial_x (h u) = 0$，\n  - 动量方程：$\\partial_t (h u) + \\partial_x \\left(h u^2 + \\tfrac{1}{2} g h^2\\right) = 0$，\n  其中 $h(x,t)$ 是水层深度，$u(x,t)$ 是速度，$g$ 是重力加速度参数。\n- 全局质量 $M(t)$ 和总能量 $E(t)$ 分别为：\n  $$M(t) = \\int_{0}^{L} h(x,t)\\,dx,$$\n  $$E(t) = \\int_{0}^{L} \\left(\\tfrac{1}{2} g h(x,t)^2 + \\tfrac{1}{2} h(x,t) u(x,t)^2\\right)\\,dx.$$\n  在周期域上，连续方程意味着 $\\frac{dM}{dt} = 0$ 和 $\\frac{dE}{dt} = 0$。\n- 自适应时间步长由 Courant-Friedrichs-Lewy (CFL) 条件确定，其中每一步的时间步长 $\\Delta t$ 满足：\n  $$\\Delta t = \\mathrm{CFL}\\, \\frac{\\Delta x}{\\max_i\\left(|u_i| + \\sqrt{g h_i}\\right)},$$\n  其中 $\\Delta x = L/N$，代表 $N$ 个均匀单元。\n\n您的任务是：\n1) 在一个均匀周期性网格上，使用任何一种能以精确守恒离散质量（在没有源汇项的情况下）的形式计算通量散度的守恒方法来离散化该系统，并使用显式方法和基于 CFL 条件的自适应时间步长进行时间积分。离散变量是单元平均值 $h_i(t)$ 和 $m_i(t) = h_i(t) u_i(t)$。\n2) 使用此离散化方法，在有限时间区间 $[0,T]$ 内使用自适应时间步长模拟该系统，并量化全局不变量的累积漂移，定义为最终绝对偏差：\n   $$\\Delta M = |M(T) - M(0)|,\\quad \\Delta E = |E(T) - E(0)|.$$\n3) 提出并实现一个全局校正策略，该策略在每个完整时间步上同时强制执行质量和能量的离散约束。您的校正必须限于不改变更新的离散通量形式的空间均匀变换，具体来说：\n   - 质量校正：通过一个常数偏移量 $\\delta$ 来平移水层深度，使得校正后的离散质量等于初始质量，即，设置 $h_i \\leftarrow h_i + \\delta$，其中 $\\delta$ 的选择应满足 $\\sum_i h_i \\Delta x = M(0)$。\n   - 能量校正：通过一个因子 $\\alpha$ 来统一缩放速度场（等效于在保持 $h_i$ 不变的情况下将动量 $m_i = h_i u_i$ 缩放 $\\alpha$），使得在质量校正后，总能量等于其初始值。如果动能为零，或者由固定的总能量和当前势能所隐含的期望动能为非正值，则保持速度不变。形式上，设 $P = \\tfrac{1}{2} g \\sum_i h_i^2 \\Delta x$ 和 $K = \\tfrac{1}{2} \\sum_i h_i u_i^2 \\Delta x$，选择 $\\alpha = \\sqrt{\\max(E(0) - P, 0)/\\max(K, \\epsilon)}$，其中 $\\epsilon$ 是一个小的数值容差，然后缩放 $u_i \\leftarrow \\alpha u_i$（等效于 $m_i \\leftarrow \\alpha m_i$）。\n4) 在相同的配置下，针对两种情况评估累积漂移 $\\Delta M$ 和 $\\Delta E$：(a) 无校正，以及 (b) 在每个完整时间步后应用质量和能量校正。每种配置报告四个量：无校正的最终绝对质量漂移，无校正的最终绝对能量漂移，有校正的最终绝对质量漂移，以及有校正的最终绝对能量漂移。\n\n初始和边界值设置：\n- 区域：$x \\in [0,L)$，具有周期性边界条件，且 $L = 1$。\n- 网格：$N$ 个均匀单元，$\\Delta x = L/N$。\n- 初始条件：\n  $$h(x,0) = H_0 + a \\cos(2\\pi x),\\quad u(x,0) = U_0 + b \\sin(2\\pi x).$$\n- 参数：$H_0  0$，小振幅 $a$ 和 $b$，重力加速度参数 $g  0$，以及最终时间 $T  0$。\n- 时间积分：显式方法，根据上述 CFL 条件和给定的 $\\mathrm{CFL}$ 数值来自适应步长。如果三角函数中出现任何角度，应解释为弧度。\n\n测试套件：\n实现并运行您的程序，使用以下参数集，每个参数集指定为一个元组 $(N, \\mathrm{CFL}, T, H_0, U_0, a, b, g)$:\n- 情况 1 (一般情况): $(128, 0.50, 1.0, 1.0, 0.0, 0.05, 0.10, 1.0)$。\n- 情况 2 (接近CFL边界): $(64, 0.90, 2.0, 1.0, 0.10, 0.02, 0.02, 1.0)$。\n- 情况 3 (初始动能退化): $(256, 0.30, 1.0, 1.0, 0.0, 0.05, 0.0, 1.0)$。\n\n程序输出规范：\n- 对于每个测试用例，计算四个浮点数：\n  - 无校正的 $\\Delta M$，\n  - 无校正的 $\\Delta E$，\n  - 有校正的 $\\Delta M$，\n  - 有校正的 $\\Delta E$。\n- 将所有测试用例的结果汇总到一行输出中，包含一个由逗号分隔的 $12$ 个浮点数的列表，并用方括号括起来（例如，\"[r1,r2,...,r12]\"）。使用十进制数。不要打印任何其他文本。\n\n您的程序必须是一个单一、独立、可运行的脚本，执行所有计算并以确切指定的格式打印结果。不允许用户输入或外部文件。解决方案应具有通用性，并对上述整个测试套件正确无误。",
            "solution": "该问题要求设计并实现一个数值实验，以研究一维无粘浅水方程数值模型中全局不变量的守恒性。任务包括离散化系统，在有和没有提出的校正方案的情况下模拟其演化，并量化全局质量和总能量的漂移。该问题是适定的、有科学依据的，并为唯一的数值解提供了所有必要的参数。\n\n控制方程是一维无粘浅水方程，它表达了质量和动量的守恒。这些方程以向量形式写成一个双曲守恒律系统：\n$$\n\\frac{\\partial \\mathbf{U}}{\\partial t} + \\frac{\\partial \\mathbf{F}(\\mathbf{U})}{\\partial x} = \\mathbf{0}\n$$\n其中 $\\mathbf{U}(x,t)$ 是守恒量的状态向量，$\\mathbf{F}(\\mathbf{U})$ 是通量向量。对于该系统，状态向量和通量向量为：\n$$\n\\mathbf{U} = \\begin{pmatrix} h \\\\ hu \\end{pmatrix} = \\begin{pmatrix} h \\\\ m \\end{pmatrix}, \\quad \\mathbf{F}(\\mathbf{U}) = \\begin{pmatrix} hu \\\\ hu^2 + \\frac{1}{2}gh^2 \\end{pmatrix} = \\begin{pmatrix} m \\\\ \\frac{m^2}{h} + \\frac{1}{2}gh^2 \\end{pmatrix}\n$$\n这里，$h(x,t)$ 是流体深度，$u(x,t)$ 是流体速度，$m(x,t) = h(x,t)u(x,t)$ 是动量密度，$g$ 是重力加速度参数。问题设定在周期域 $x \\in [0, L)$ 上。\n\n要求使用一种守恒的数值方法。我们采用有限体积法，该方法在构造上是守恒的。区域 $[0, L)$ 被离散化为 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀单元 $I_i = [x_{i-1/2}, x_{i+1/2}]$。离散状态变量 $\\mathbf{U}_i(t)$ 代表守恒量的单元平均值。方程的半离散形式为：\n$$\n\\frac{d\\mathbf{U}_i}{dt} = -\\frac{1}{\\Delta x} \\left( \\mathbf{F}_{i+1/2} - \\mathbf{F}_{i-1/2} \\right)\n$$\n其中 $\\mathbf{F}_{i \\pm 1/2}$ 是单元界面上的数值通量。对所有单元 $i=0, \\dots, N-1$ 在周期性边界下求和，会得到一个结果为零的可消项求和，这确保了总质量 $\\sum_i h_i \\Delta x$ 在机器精度范围内是守恒的。\n\n对于数值通量，我们选择简单且稳健的 Lax-Friedrichs 通量。它在单元 $i$ 和 $i+1$ 之间的界面 $x_{i+1/2}$ 处定义为：\n$$\n\\mathbf{F}_{i+1/2} = \\frac{1}{2} \\left[ \\mathbf{F}(\\mathbf{U}_i) + \\mathbf{F}(\\mathbf{U}_{i+1}) \\right] - \\frac{1}{2} C_{i+1/2} \\left( \\mathbf{U}_{i+1} - \\mathbf{U}_i \\right)\n$$\n耗散系数 $C_{i+1/2}$ 必须至少是最大局部特征速度，以确保数值稳定性。浅水系统的特征速度（通量雅可比矩阵的特征值）是 $u \\pm \\sqrt{gh}$。因此，一个稳定的选择是：\n$$\nC_{i+1/2} = \\max\\left(|u_i| + \\sqrt{gh_i}, |u_{i+1}| + \\sqrt{gh_{i+1}}\\right)\n$$\n\n对于时间积分，使用显式二阶强稳定保持 Runge-Kutta 方法 (SSP-RK2)，也称为 Heun 方法。给定半离散形式 $\\frac{d\\mathbf{U}}{dt} = \\mathcal{L}(\\mathbf{U})$，从时间步 $n$ 到 $n+1$ 的更新分两个阶段进行：\n1. 中间步：$\\mathbf{U}^* = \\mathbf{U}^n + \\Delta t \\, \\mathcal{L}(\\mathbf{U}^n)$\n2. 最终步：$\\mathbf{U}^{n+1} = \\frac{1}{2}\\mathbf{U}^n + \\frac{1}{2}\\left( \\mathbf{U}^* + \\Delta t \\, \\mathcal{L}(\\mathbf{U}^*) \\right)$\n\n时间步长 $\\Delta t$ 在每次迭代时根据 Courant-Friedrichs-Lewy (CFL) 条件进行调整，以维持稳定性：\n$$\n\\Delta t = \\mathrm{CFL} \\frac{\\Delta x}{\\max_{i}\\left(|u_i| + \\sqrt{g h_i}\\right)}\n$$\n其中 $\\mathrm{CFL}$ 是一个为此方案选择的不大于 $1$ 的数。\n\n离散的全局不变量，即质量 $M$ 和总能量 $E$，通过对所有单元求和来计算：\n$$\nM(t) = \\sum_{i=0}^{N-1} h_i(t) \\Delta x, \\quad E(t) = \\sum_{i=0}^{N-1} \\left( \\frac{1}{2} g h_i(t)^2 + \\frac{1}{2} h_i(t) u_i(t)^2 \\right) \\Delta x = \\sum_{i=0}^{N-1} \\left( \\frac{1}{2} g h_i(t)^2 + \\frac{1}{2} \\frac{m_i(t)^2}{h_i(t)} \\right) \\Delta x\n$$\n模拟在两种情况下进行。第一种情况不进行任何修改，并测量数值漂移。第二种情况在每个完整时间步后应用一个校正方案，以强制保持初始质量 $M_0$ 和初始能量 $E_0$ 的守恒。\n\n校正方案包括两个步骤：\n1.  **质量校正**：每个单元中的流体深度 $h_i$ 通过一个均匀偏移量 $\\delta$ 进行调整。设 $h'_i$ 是一个时间步后的深度。当前质量是 $M' = \\sum_i h'_i \\Delta x$。我们强制 $\\sum_i (h'_i + \\delta) \\Delta x = M_0$。这得到 $M' + \\delta (N \\Delta x) = M_0$，所以 $\\delta = (M_0 - M')/L$。校正后的深度是 $h''_i = h'_i + \\delta$。\n\n2.  **能量校正**：质量校正后，速度场通过一个统一因子 $\\alpha$ 进行缩放，以将总能量恢复到其初始值 $E_0$。设 $h''_i$ 是质量校正后的深度，$m'_i$ 是时间步后的动量。势能是 $P'' = \\frac{1}{2}g \\sum_i (h''_i)^2 \\Delta x$。缩放前的动能是 $K'' = \\frac{1}{2}\\sum_i (m'_i)^2/h''_i \\Delta x$。用 $\\alpha$ 缩放动量后（$m''_i = \\alpha m'_i$），新的动能将是 $\\alpha^2 K''$。我们要求 $P'' + \\alpha^2 K'' = E_0$。这导出了问题中指定的缩放因子：\n$$\n\\alpha = \\sqrt{\\frac{\\max(E_0 - P'', 0)}{\\max(K'', \\epsilon)}}\n$$\n其中 $\\epsilon$ 是一个小的容差以防止除以零。此公式通过设置 $\\alpha=0$ 正确处理了目标动能 $E_0 - P''$ 为非正值的情况，从而将动能清零。如果初始动能为零，$K''$ 将接近零，该公式也能处理这种情况。\n\n对每个测试用例，通过运行两个模拟来实现该算法：一个使用 `apply_correction=False`，另一个使用 `apply_correction=True`。计算并报告两种情况下的最终绝对漂移 $\\Delta M = |M(T) - M_0|$ 和 $\\Delta E = |E(T) - E_0|$。初始条件通过在单元中心点 $x_i = (i+0.5)\\Delta x$ 处计算给定函数来进行离散化。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the shallow-water equation problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        (128, 0.50, 1.0, 1.0, 0.0, 0.05, 0.10, 1.0),\n        (64, 0.90, 2.0, 1.0, 0.10, 0.02, 0.02, 1.0),\n        (256, 0.30, 1.0, 1.0, 0.0, 0.05, 0.0, 1.0),\n    ]\n\n    results = []\n    for params in test_cases:\n        N, CFL, T, H0, U0, a, b, g = params\n        \n        # Run simulation without correction\n        delta_M_uncorr, delta_E_uncorr = run_simulation(N, CFL, T, H0, U0, a, b, g, apply_correction=False)\n        \n        # Run simulation with correction\n        delta_M_corr, delta_E_corr = run_simulation(N, CFL, T, H0, U0, a, b, g, apply_correction=True)\n        \n        results.extend([delta_M_uncorr, delta_E_uncorr, delta_M_corr, delta_E_corr])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_rhs(h, m, g, dx):\n    \"\"\"\n    Computes the right-hand side of the semi-discrete finite volume scheme\n    using the Lax-Friedrichs flux.\n    \"\"\"\n    # Guard against division by zero for h, though it shouldn't be an issue\n    # with the given initial conditions.\n    h_safe = np.maximum(h, 1e-12)\n    u = m / h_safe\n\n    # Flux vectors F(U)\n    Fh = m\n    Fm = m**2 / h_safe + 0.5 * g * h**2\n\n    # Lax-Friedrichs dissipation term\n    c_char = np.abs(u) + np.sqrt(g * h)\n    c_char_p = np.roll(c_char, -1)\n    C_half = np.maximum(c_char, c_char_p)\n\n    # Shifted states for computing flux at i+1/2\n    h_p = np.roll(h, -1)\n    m_p = np.roll(m, -1)\n    Fh_p = np.roll(Fh, -1)\n    Fm_p = np.roll(Fm, -1)\n    \n    # Lax-Friedrichs fluxes at interface i+1/2\n    Fh_lf_half = 0.5 * (Fh + Fh_p) - 0.5 * C_half * (h_p - h)\n    Fm_lf_half = 0.5 * (Fm + Fm_p) - 0.5 * C_half * (m_p - m)\n\n    # Flux divergence (F_{i+1/2} - F_{i-1/2}) / dx\n    # F_{i-1/2} is obtained by rolling F_{i+1/2}\n    Fh_lf_half_m = np.roll(Fh_lf_half, 1)\n    Fm_lf_half_m = np.roll(Fm_lf_half, 1)\n\n    rhs_h = -(Fh_lf_half - Fh_lf_half_m) / dx\n    rhs_m = -(Fm_lf_half - Fm_lf_half_m) / dx\n    \n    return rhs_h, rhs_m\n\ndef run_simulation(N, CFL, T, H0, U0, a, b, g, apply_correction):\n    \"\"\"\n    Runs a single simulation for a given parameter set and correction flag.\n    \"\"\"\n    L = 1.0\n    dx = L / N\n    x = (np.arange(N) + 0.5) * dx\n    epsilon = 1e-15\n\n    # Initial conditions\n    h = H0 + a * np.cos(2 * np.pi * x / L)\n    u = U0 + b * np.sin(2 * np.pi * x / L)\n    m = h * u\n\n    def get_invariants(h_loc, m_loc):\n        mass = np.sum(h_loc) * dx\n        h_loc_safe = np.maximum(h_loc, 1e-12)\n        u_loc = m_loc / h_loc_safe\n        potential_energy = 0.5 * g * np.sum(h_loc**2) * dx\n        kinetic_energy = 0.5 * np.sum(h_loc * u_loc**2) * dx\n        total_energy = potential_energy + kinetic_energy\n        return mass, total_energy\n\n    M0, E0 = get_invariants(h, m)\n\n    t = 0.0\n    while t  T:\n        # Adaptive time step from CFL condition\n        h_safe = np.maximum(h, 1e-12)\n        u = m / h_safe\n        max_wave_speed = np.max(np.abs(u) + np.sqrt(g * h))\n        dt = CFL * dx / max_wave_speed\n        if t + dt > T:\n            dt = T - t\n\n        # SSP-RK2 time integration\n        # Stage 1\n        rhs_h1, rhs_m1 = compute_rhs(h, m, g, dx)\n        h1 = h + dt * rhs_h1\n        m1 = m + dt * rhs_m1\n        # Stage 2\n        rhs_h2, rhs_m2 = compute_rhs(h1, m1, g, dx)\n        h_new = 0.5 * h + 0.5 * (h1 + dt * rhs_h2)\n        m_new = 0.5 * m + 0.5 * (m1 + dt * rhs_m2)\n\n        h, m = h_new, m_new\n\n        if apply_correction:\n            # Mass correction\n            M_current = np.sum(h) * dx\n            delta = (M0 - M_current) / L\n            h += delta\n\n            # Energy correction\n            P_current = 0.5 * g * np.sum(h**2) * dx\n            # Use mass-corrected h for kinetic energy\n            h_safe = np.maximum(h, 1e-12)\n            K_current = 0.5 * np.sum(m**2 / h_safe) * dx\n            \n            # Calculate scaling factor alpha\n            alpha_sq_num = np.maximum(E0 - P_current, 0)\n            alpha_sq_den = np.maximum(K_current, epsilon)\n            alpha = np.sqrt(alpha_sq_num / alpha_sq_den)\n            \n            m *= alpha\n\n        t += dt\n\n    M_final, E_final = get_invariants(h, m)\n    delta_M = np.abs(M_final - M0)\n    delta_E = np.abs(E_final - E0)\n    \n    return delta_M, delta_E\n\nsolve()\n```"
        }
    ]
}