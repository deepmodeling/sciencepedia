{
    "hands_on_practices": [
        {
            "introduction": "The Nyquist-Shannon sampling theorem is a cornerstone of digital signal processing, yet its violation is a common pitfall in the analysis of geophysical data. This first exercise provides a direct, hands-on demonstration of aliasing, where high-frequency signals masquerade as lower frequencies due to insufficient sampling. By completing this practice , you will gain an intuitive understanding of how undersampling can lead to a fundamental misinterpretation of spectral content, a critical skill for anyone working with observational or model-generated time series.",
            "id": "4045320",
            "problem": "Consider a synthetic, evenly sampled, one-dimensional time series representative of a geophysical signal with $2$ sinusoidal components, such as diurnal and semidiurnal variability in atmospheric or oceanic fields. Let the underlying continuous-time signal be\n$$\ns(t) \\;=\\; A_1 \\cos\\!\\big(2\\pi F_1 t + \\phi_1\\big) \\;+\\; A_2 \\cos\\!\\big(2\\pi F_2 t + \\phi_2\\big),\n$$\nwhere $A_1, A_2$ are amplitudes, $F_1, F_2$ are frequencies in hertz (Hz), and $\\phi_1, \\phi_2$ are phases in radians. The signal is sampled at sampling frequency $f_s$ (in Hz) with sampling interval $\\Delta t = 1/f_s$ to produce a discrete-time sequence\n$$\nx[n] \\;=\\; s(n \\Delta t) \\;=\\; s\\!\\left(\\frac{n}{f_s}\\right), \\quad n = 0,1,\\dots,N-1,\n$$\nfor a total of $N$ samples. The discrete Fourier transform (DFT) of $x[n]$ is defined by\n$$\nX[k] \\;=\\; \\sum_{n=0}^{N-1} x[n]\\, e^{-i 2\\pi kn/N}, \\quad k = 0,1,\\dots,N-1,\n$$\nwith associated frequency bins\n$$\nf_k \\;=\\; \\frac{k f_s}{N}.\n$$\nFor real-valued $x[n]$, the one-sided amplitude spectrum can be formed from $X[k]$ by taking the magnitudes $|X[k]|$, scaling by $N$, and doubling all amplitudes except the direct current (DC) bin $k=0$ and, when $N$ is even, the Nyquist bin $k=N/2$.\n\nAliasing arises when a true frequency $F$ exceeds the Nyquist frequency $f_s/2$. In ideal sampling, distinct continuous-time sinusoids at $F$ and $F' = F \\pm m f_s$ for any integer $m$ yield identical sampled sequences. The apparent one-sided spectrum is then observed at the aliased frequency\n$$\nF_{\\text{alias}} \\;=\\; \\left| \\left(\\left(F + \\frac{f_s}{2}\\right) \\bmod f_s\\right) - \\frac{f_s}{2} \\right|,\n$$\nwhich lies in the interval $[0, f_s/2]$. In practice, for finite $N$ and a rectangular window, spectral leakage distributes energy near the true (or aliased) line into adjacent bins; thus the peak picked from the DFT magnitude occurs at the nearest resolvable bin frequency, quantized by the frequency resolution\n$$\n\\Delta f \\;=\\; \\frac{f_s}{N}.\n$$\n\nYour task is to implement a program that:\n- Synthesizes $x[n]$ from the given $s(t)$ using the parameters below.\n- Computes the one-sided amplitude spectrum using the discrete Fourier transform.\n- Identifies the two dominant spectral peaks by finding the two largest distinct peaks in the one-sided amplitude spectrum (excluding the DC bin), resolving ties by selecting the lower frequency bin first if necessary. To ensure distinct peaks, after selecting the largest peak at bin $k_1$, exclude a neighborhood of $\\pm 1$ bin around $k_1$ before selecting the second largest peak.\n- Returns, for each test case, the estimated frequencies (in Hz) of these two peaks, obtained by mapping the selected bin indices back to $f_k = k f_s/N$. Sort the two frequencies in ascending order and round each to six decimal places.\n\nUse the following fixed signal parameters across all test cases:\n- $A_1 = 2.0$, $A_2 = 1.0$ (dimensionless).\n- $F_1 = 5.0$ Hz, $F_2 = 12.0$ Hz.\n- $\\phi_1 = 0.0$ radians, $\\phi_2 = \\pi/3$ radians.\n\nAngles must be in radians. Frequencies must be expressed in Hz. Time must be in seconds.\n\nTest suite:\n- Case $1$ (happy path, both components below Nyquist): $f_s = 64$ Hz, $N = 256$.\n- Case $2$ (single-component aliasing, $F_2$ above Nyquist): $f_s = 20$ Hz, $N = 256$.\n- Case $3$ (boundary, $F_2$ exactly at Nyquist): $f_s = 24$ Hz, $N = 256$.\n- Case $4$ (both components alias, both above Nyquist): $f_s = 9$ Hz, $N = 256$.\n\nAlgorithmic and numerical requirements:\n- Construct $x[n]$ exactly as $x[n] = A_1 \\cos(2\\pi F_1 n/f_s + \\phi_1) + A_2 \\cos(2\\pi F_2 n/f_s + \\phi_2)$ for $n = 0,1,\\dots,N-1$.\n- Compute the one-sided spectrum using a real-to-complex DFT and apply correct amplitude scaling for a real signal, doubling all bins except DC and Nyquist (when applicable).\n- Exclude DC from peak picking by setting its amplitude to zero before searching for peaks.\n- Identify the two dominant peaks as specified and map their bin indices to Hz.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a two-element list of floats: the two estimated peak frequencies (in Hz) for the corresponding test case, sorted in ascending order and rounded to six decimal places. For example: [[f11,f12],[f21,f22],[f31,f32],[f41,f42]].\n\nThere is no user input. The program must be self-contained and must print only the final result line in the exact format specified above.",
            "solution": "We begin from the continuous-time signal\n$$\ns(t) \\;=\\; A_1 \\cos\\!\\big(2\\pi F_1 t + \\phi_1\\big) \\;+\\; A_2 \\cos\\!\\big(2\\pi F_2 t + \\phi_2\\big),\n$$\nwith fixed parameters $A_1 = 2.0$, $A_2 = 1.0$, $F_1 = 5.0$ Hz, $F_2 = 12.0$ Hz, $\\phi_1 = 0.0$ radians, $\\phi_2 = \\pi/3$ radians. The discrete sampling is performed at sampling frequency $f_s$ (in Hz) with sampling interval $\\Delta t = 1/f_s$, producing samples\n$$\nx[n] \\;=\\; s\\!\\left(\\frac{n}{f_s}\\right) \\;=\\; A_1 \\cos\\!\\Big(2\\pi F_1 \\frac{n}{f_s} + \\phi_1\\Big) \\;+\\; A_2 \\cos\\!\\Big(2\\pi F_2 \\frac{n}{f_s} + \\phi_2\\Big),\n$$\nfor $n = 0, 1, \\dots, N-1$. The discrete Fourier transform (DFT) of $x[n]$ is\n$$\nX[k] \\;=\\; \\sum_{n=0}^{N-1} x[n]\\, e^{-i 2\\pi kn/N}, \\quad k = 0,1,\\dots,N-1.\n$$\nFor real-valued sequences $x[n]$, the spectrum is conjugate symmetric, and it is sufficient to consider the one-sided spectrum for $k = 0,1,\\dots,\\lfloor N/2 \\rfloor$. The corresponding physical frequencies are\n$$\nf_k \\;=\\; \\frac{k f_s}{N}.\n$$\nTo form a physically interpretable one-sided amplitude spectrum $A(f_k)$, we compute\n$$\nA(f_k) \\;=\\; \\begin{cases}\n\\frac{1}{N}\\,|X[0]|, & k = 0, \\\\\n\\frac{2}{N}\\,|X[k]|, & 1 \\le k \\le \\frac{N}{2}-1 \\text{ (for even } N), \\\\\n\\frac{1}{N}\\,|X[N/2]|, & k = N/2 \\text{ (Nyquist, for even } N),\n\\end{cases}\n$$\nand the analogous definition when $N$ is odd (there is no Nyquist bin when $N$ is odd). Because $N$ is specified as $256$ in all test cases, we are always in the even-$N$ case, and the Nyquist bin $k = N/2$ is included without doubling.\n\nThe Nyquist-Shannon sampling theorem states that if $f_s \\ge 2 F_{\\max}$, where $F_{\\max}$ is the largest frequency present, then the continuous-time spectrum can be perfectly reconstructed from the samples. If the condition fails, continuous-time sinusoids at $F$ and $F \\pm m f_s$ (for any integer $m$) are indistinguishable after sampling, because\n$$\n\\cos\\!\\big(2\\pi (F \\pm m f_s) t + \\phi\\big)\\Big|_{t = n/f_s}\n= \\cos\\!\\Big(2\\pi F \\frac{n}{f_s} \\pm 2\\pi m n + \\phi\\Big)\n= \\cos\\!\\Big(2\\pi F \\frac{n}{f_s} + \\phi\\Big),\n$$\nusing the periodicity of the cosine function with period $2\\pi$. Thus, the apparent one-sided spectrum is observed at the aliased frequency\n$$\nF_{\\text{alias}} \\;=\\; \\left| \\left(\\left(F + \\frac{f_s}{2}\\right) \\bmod f_s\\right) - \\frac{f_s}{2} \\right| \\;\\in\\; [0, f_s/2].\n$$\n\nIn numerical computation with a finite window of $N$ samples and a rectangular window (implicit when taking the DFT of the raw data), spectral leakage occurs unless the sinusoid completes an integer number of cycles in the window. The Dirichlet kernel describes the spread of energy into neighboring bins. Consequently, the observed peak will be located at the nearest DFT frequency bin to the true line, quantized by the frequency resolution\n$$\n\\Delta f \\;=\\; \\frac{f_s}{N}.\n$$\n\nAlgorithmic steps implemented:\n- For each test case, construct $x[n]$ using the specified $A_1, A_2, F_1, F_2, \\phi_1, \\phi_2$, the given $f_s$ and $N$.\n- Compute the one-sided spectrum with a real-input fast Fourier transform, then scale amplitudes as above. Set the DC bin amplitude to zero to exclude it from peak selection.\n- Identify the largest peak index $k_1 = \\arg\\max A(f_k)$. To ensure the two peaks are distinct and not adjacent points of the same main lobe, zero out the amplitudes in a neighborhood of $\\pm 1$ bin around $k_1$ (clipped to valid indices). Then select the second-largest peak index $k_2$.\n- Map $k_1$ and $k_2$ to frequencies $f_{k_1}, f_{k_2}$ in Hz using $f_k = k f_s/N$, sort ascending, and round to six decimal places.\n\nReasoning about the test suite:\n- Case $1$: $f_s = 64$ Hz, $N = 256$. Nyquist is $32$ Hz, both $F_1 = 5$ Hz and $F_2 = 12$ Hz are below Nyquist. The frequency resolution is $\\Delta f = f_s/N = 0.25$ Hz. Both $F_1$ and $F_2$ are integer multiples of $\\Delta f$, so there is no leakage, and peaks are exactly at $5.0$ Hz and $12.0$ Hz.\n- Case $2$: $f_s = 20$ Hz, $N = 256$. Nyquist is $10$ Hz. $F_1 = 5$ Hz is below Nyquist and lands exactly on a bin because $\\Delta f = 20/256 = 0.078125$ Hz divides $5.0$ Hz exactly. $F_2 = 12$ Hz aliases to $F_{2,\\text{alias}} = |12 - 1\\cdot 20| = 8$ Hz. Because $8.0$ Hz is not an integer multiple of $\\Delta f$, leakage occurs and the observed maximum is at the nearest bin near $8$ Hz.\n- Case $3$: $f_s = 24$ Hz, $N = 256$. Nyquist is $12$ Hz, exactly equal to $F_2$, so the energy appears at the Nyquist bin without doubling. $F_1 = 5$ Hz is below Nyquist but not an exact multiple of $\\Delta f = 24/256 = 0.09375$ Hz, so the observed peak is the nearest bin near $5$ Hz.\n- Case $4$: $f_s = 9$ Hz, $N = 256$. Nyquist is $4.5$ Hz, so both $F_1 = 5$ Hz and $F_2 = 12$ Hz alias: $F_{1,\\text{alias}} = |5 - 1\\cdot 9| = 4$ Hz and $F_{2,\\text{alias}} = |12 - 1\\cdot 9| = 3$ Hz. With $\\Delta f = 9/256 \\approx 0.03515625$ Hz, neither is exactly on-bin, so peaks are near $4$ Hz and $3$ Hz.\n\nThe program implements these steps precisely and outputs, for each test case, the two picked peak frequencies in Hz, sorted ascending and rounded to six decimal places, as a single line in the required list-of-lists format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef one_sided_amplitude_spectrum(x, fs):\n    \"\"\"\n    Compute one-sided amplitude spectrum for a real-valued signal x sampled at fs.\n    Returns frequencies (Hz) and amplitudes.\n    \"\"\"\n    N = x.size\n    # Real FFT: length N//2 + 1 for even N\n    X = np.fft.rfft(x)\n    freqs = np.fft.rfftfreq(N, d=1.0/fs)\n    # Amplitude scaling to get one-sided amplitude spectrum\n    amp = np.abs(X) / N\n    if N > 1:\n        # Double all bins except DC and Nyquist (if N even)\n        amp[1:-1] *= 2.0\n    return freqs, amp\n\ndef synthesize_signal(N, fs, A1, A2, F1, F2, phi1, phi2):\n    n = np.arange(N)\n    t = n / fs\n    x = (A1 * np.cos(2.0 * np.pi * F1 * t + phi1) +\n         A2 * np.cos(2.0 * np.pi * F2 * t + phi2))\n    return x\n\ndef pick_two_dominant_peaks(freqs, amp):\n    \"\"\"\n    Pick two dominant peaks from one-sided amplitude spectrum.\n    Exclude DC by zeroing amp[0] before selection.\n    After picking the dominant peak, zero out a neighborhood of +/-1 bins to ensure distinct peaks.\n    Return the two peak frequencies in ascending order.\n    \"\"\"\n    amp = amp.copy()\n    # Exclude DC\n    if amp.size > 0:\n        amp[0] = 0.0\n    # First peak\n    idx1 = int(np.argmax(amp))\n    # Zero out neighborhood around first peak to avoid adjacent bins of same lobe\n    lo = max(1, idx1 - 1)  # keep DC excluded\n    hi = min(amp.size - 1, idx1 + 1)\n    amp[lo:hi+1] = 0.0\n    # Second peak\n    idx2 = int(np.argmax(amp))\n    f1 = freqs[idx1]\n    f2 = freqs[idx2]\n    return tuple(sorted((f1, f2)))\n\ndef solve():\n    # Fixed signal parameters\n    A1, A2 = 2.0, 1.0\n    F1, F2 = 5.0, 12.0  # Hz\n    phi1, phi2 = 0.0, np.pi / 3.0  # radians\n\n    # Define the test cases from the problem statement: (fs, N)\n    test_cases = [\n        (64.0, 256),  # Case 1: both below Nyquist\n        (20.0, 256),  # Case 2: F2 aliases\n        (24.0, 256),  # Case 3: F2 at Nyquist\n        (9.0, 256),   # Case 4: both alias\n    ]\n\n    results = []\n    for fs, N in test_cases:\n        x = synthesize_signal(N, fs, A1, A2, F1, F2, phi1, phi2)\n        freqs, amp = one_sided_amplitude_spectrum(x, fs)\n        f_low, f_high = pick_two_dominant_peaks(freqs, amp)\n        # Round to six decimals as required\n        results.append([round(f_low, 6), round(f_high, 6)])\n\n    # Final print statement in the exact required format: list of lists.\n    # Ensure six decimal places formatting.\n    formatted = \"[\" + \",\".join(\n        \"[\" + \",\".join(f\"{v:.6f}\" for v in pair) + \"]\" for pair in results\n    ) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "A common challenge in spectral analysis is that the true frequency of a signal component may lie between the discrete bins of a Discrete Fourier Transform (DFT), leading to inaccurate estimates of its peak amplitude and frequency. This practice explores zero-padding, a widely used computational method to address this issue by effectively interpolating the underlying continuous spectrum . Through this exercise, you will learn to distinguish between true spectral resolution, which is fixed by the observation window, and the grid density of the DFT, which can be enhanced to refine peak estimates.",
            "id": "4045295",
            "problem": "You are analyzing evenly sampled geoscience time series in the context of numerical weather prediction and climate modeling, where Fourier methods are used to estimate the energy content of diurnal and synoptic-scale variability. Consider a real-valued, finite-length discrete time series $x[n]$ for $n \\in \\{0,1,\\dots,N-1\\}$, sampled uniformly in time with sampling interval $\\Delta t$. The Discrete-Time Fourier Transform (DTFT) of $x[n]$ is defined, using angular frequency in radians, by\n$$\nX(\\omega) \\;=\\; \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\,\\omega\\, n} \\quad \\text{for } \\omega \\in \\mathbb{R}.\n$$\nThe Discrete Fourier Transform (DFT) samples the DTFT on a finite grid $\\omega_k = 2\\pi k/N$ for $k \\in \\{0,1,\\dots,N-1\\}$:\n$$\nX_N[k] \\;=\\; \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\,2\\pi\\, k\\, n / N}.\n$$\nNow define the zero-padded sequence $x_M[n]$ of length $M$ by $x_M[n] = x[n]$ for $0 \\le n \\le N-1$ and $x_M[n] = 0$ for $N \\le n \\le M-1$, where $M$ is an integer multiple of $N$, i.e., $M = L N$ with $L \\in \\mathbb{N}$. The $M$-point DFT of the zero-padded sequence is\n$$\nX_M[k] \\;=\\; \\sum_{n=0}^{M-1} x_M[n] \\, e^{-i \\,2\\pi\\, k\\, n / M}.\n$$\nTasks:\n1) Using only these definitions and the linearity of summation, derive from first principles why zero-padding increases the density of the sampled frequency grid from spacing $2\\pi/N$ to spacing $2\\pi/M$ without adding new information about $x[n]$. Explain why, when $M = L N$, the values $X_M[\\ell L]$ for $\\ell \\in \\{0,1,\\dots,\\lfloor N/2 \\rfloor\\}$ exactly equal $X_N[\\ell]$ for a real-valued $x[n]$ at the corresponding nonnegative frequencies, and interpret this as an interpolation of the same underlying $X(\\omega)$ rather than the creation of new spectral content.\n2) Implement a program that constructs real-valued time series for the following test suite. For each test case, compute the one-sided magnitude spectrum using the Real Fast Fourier Transform (RFFT) at length $N$ and at zero-padded length $M=L N$, and then compute the specified diagnostic to demonstrate the mathematical conclusions in part (1). Angles in any formula must be in radians, but your program’s outputs must be dimensionless floats or booleans as specified.\n\nTest Suite:\n- Test A (grid-consistency, happy path): Let $N = 128$ and $L = 4$. Define\n  $$\n  x[n] \\;=\\; \\sin(2\\pi \\cdot 0.125 \\, n) \\;+\\; 0.6 \\cos(2\\pi \\cdot 0.27 \\, n + 0.3) \\;+\\; 0.2 \\sin(2\\pi \\cdot 0.37 \\, n),\n  $$\n  for $n = 0,1,\\dots,127$. Compute the RFFT at length $N$ and at length $M = 512$. Let $X_N[\\ell]$ denote the RFFT output at indices $\\ell \\in \\{0,1,\\dots,N/2\\}$ and $X_M[k]$ denote the RFFT output at indices $k \\in \\{0,1,\\dots,M/2\\}$. Compute the maximum absolute difference\n  $$\n  d_A \\;=\\; \\max_{0 \\le \\ell \\le N/2} \\left| X_M[\\ell L] - X_N[\\ell] \\right|.\n  $$\n  Return $d_A$ as a float.\n- Test B (interpolated peak magnitude off-bin): Let $N = 180$, $L = 8$, and $f_0 = 23.7 / N$ cycles per sample. Define $x[n] = \\cos(2\\pi f_0 n)$ for $n = 0,1,\\dots,179$. Compute the maximum magnitude in the unpadded RFFT, $P_N = \\max_k |X_N[k]|$, and in the padded RFFT, $P_M = \\max_k |X_M[k]|$. Return a boolean indicating whether $P_M > P_N$.\n- Test C (interpolated frequency estimate improves): Let $N = 240$, $L = 10$, and $f_0 = 1/24 + 0.0037$ cycles per sample. Define $x[n] = \\cos(2\\pi f_0 n)$ for $n = 0,1,\\dots,239$. Let $\\hat{k}_N$ and $\\hat{k}_M$ be the indices of the largest-magnitude RFFT bins at lengths $N$ and $M$, respectively. Define the normalized-bin frequency estimates $\\hat{f}_N = \\hat{k}_N / N$ and $\\hat{f}_M = \\hat{k}_M / M$. Compute the ratio\n  $$\n  r_C \\;=\\; \\frac{|\\hat{f}_N - f_0|}{|\\hat{f}_M - f_0|}.\n  $$\n  Return $r_C$ as a float.\n- Test D (edge case, zero signal): Let $N = 64$ and $L = 16$, with $x[n] = 0$ for all $n$. Compute $d_D = \\max_{0 \\le \\ell \\le N/2} | X_M[\\ell L] - X_N[\\ell] |$ as in Test A. Return a boolean indicating whether $d_D = 0.0$.\n\nImplementation requirements:\n- Use only the Real Fast Fourier Transform to obtain the one-sided spectra. All angles in the signal definitions are in radians. The program must compute and return the four results in the order specified above.\n- The final output format must be a single line containing a Python-style list with the four results in order: $[d_A, \\text{resultB}, r_C, \\text{resultD}]$, where $d_A$ and $r_C$ are floats, and resultB and resultD are booleans.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[0.0,True,2.5,True]\"). No other output is permitted.",
            "solution": "The problem statement has been validated and is deemed sound. It is scientifically grounded in the principles of digital signal processing, well-posed with all necessary definitions and parameters, and objective. The tasks are formalizable and verifiable. We may therefore proceed with a solution.\n\nThe problem asks for a first-principles derivation of the effects of zero-padding on the Discrete Fourier Transform (DFT) of a time series, followed by a numerical implementation to demonstrate these effects.\n\n**Part 1: Theoretical Derivation and Interpretation**\n\nWe are asked to demonstrate why zero-padding a finite-length discrete time series $x[n]$ of length $N$ to a new length $M=LN$ increases the density of the frequency grid, and to prove the relationship between the original $N$-point DFT and the zero-padded $M$-point DFT.\n\nLet the original real-valued time series be $x[n]$ for $n \\in \\{0, 1, \\dots, N-1\\}$. Its Discrete-Time Fourier Transform (DTFT), a continuous function of angular frequency $\\omega$, is given by:\n$$\nX(\\omega) = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\omega n}\n$$\nThe $N$-point DFT, denoted $X_N[k]$, samples this DTFT at $N$ discrete frequencies $\\omega_k = \\frac{2\\pi k}{N}$ for $k \\in \\{0, 1, \\dots, N-1\\}$. The frequency spacing, or resolution, of this grid is $\\Delta \\omega_N = \\omega_{k+1} - \\omega_k = \\frac{2\\pi}{N}$.\n$$\nX_N[k] = X(\\omega_k) = X\\left(\\frac{2\\pi k}{N}\\right) = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\frac{2\\pi k n}{N}}\n$$\nNow, we define a zero-padded sequence $x_M[n]$ of length $M = LN$ where $L \\in \\mathbb{N}$ and $L > 1$:\n$$\nx_M[n] = \\begin{cases} x[n] & 0 \\le n \\le N-1 \\\\ 0 & N \\le n \\le M-1 \\end{cases}\n$$\nThe $M$-point DFT of this zero-padded sequence, denoted $X_M[k]$, is:\n$$\nX_M[k] = \\sum_{n=0}^{M-1} x_M[n] \\, e^{-i \\frac{2\\pi k n}{M}}\n$$\nBy substituting the definition of $x_M[n]$, the sum can be truncated at $N-1$ since all subsequent terms are zero:\n$$\nX_M[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\frac{2\\pi k n}{M}} + \\sum_{n=N}^{M-1} (0) \\cdot e^{-i \\frac{2\\pi k n}{M}} = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\frac{2\\pi k n}{M}}\n$$\nLet us compare this result to the original DTFT, $X(\\omega)$. If we evaluate $X(\\omega)$ at the new frequency grid points $\\omega'_k = \\frac{2\\pi k}{M}$, we get:\n$$\nX(\\omega'_k) = X\\left(\\frac{2\\pi k}{M}\\right) = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\left(\\frac{2\\pi k}{M}\\right) n}\n$$\nWe observe that $X_M[k] = X\\left(\\frac{2\\pi k}{M}\\right)$. This is the central finding. The $M$-point DFT of the zero-padded sequence is mathematically equivalent to sampling the DTFT of the *original, unpadded sequence* $x[n]$ at a finer set of frequency points $\\omega'_k$.\n\nThe spacing of this new frequency grid is $\\Delta \\omega_M = \\frac{2\\pi}{M}$. Since $M = LN > N$, the spacing $\\Delta \\omega_M$ is smaller than the original spacing $\\Delta \\omega_N$. Specifically, $\\Delta \\omega_M = \\frac{\\Delta \\omega_N}{L}$. This confirms that zero-padding increases the density of the sampled frequency grid.\n\nCrucially, this process does not add any new information about the signal $x[n]$. The underlying DTFT, $X(\\omega)$, is determined entirely by the original $N$ data points. Zero-padding is an efficient computational method for interpolating this DTFT onto a finer frequency grid. It does not improve the *true* spectral resolution, which is fundamentally limited by the original observation length $N \\Delta t$. However, it can reveal details of the spectral shape between the original DFT sample points, which is useful for more accurately estimating the frequency and magnitude of spectral peaks that do not fall exactly on one of the original coarse grid points.\n\nFinally, we must prove that at the original frequency sample locations, the new DFT matches the old one. We examine the values of $X_M[k]$ at indices $k = \\ell L$ for $\\ell \\in \\{0, 1, \\dots, N-1\\}$.\n$$\nX_M[\\ell L] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\frac{2\\pi (\\ell L) n}{M}}\n$$\nSubstituting $M = LN$, the factor $L$ cancels in the exponent:\n$$\nX_M[\\ell L] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\frac{2\\pi \\ell n}{N}}\n$$\nThe expression on the right-hand side is precisely the definition of the $N$-point DFT, $X_N[\\ell]$. Therefore, we have proven the identity:\n$$\nX_M[\\ell L] = X_N[\\ell]\n$$\nThis identity confirms that the interpolated spectrum $X_M$ exactly recovers the original spectrum $X_N$ at the original grid points. For a real-valued signal $x[n]$, the spectrum is conjugate symmetric, and a Real Fast Fourier Transform (RFFT) is typically used to compute only the unique components for non-negative frequencies. The problem specifies using the RFFT, which computes the transform for indices from $\\ell=0$ to $\\ell=\\lfloor N/2 \\rfloor$. The identity $X_M[\\ell L] = X_N[\\ell]$ holds for this range of indices as well, which will be numerically verified.\n\n**Part 2: Numerical Implementation and Verification**\n\nWe now implement the four test cases as described in the problem statement. The code will generate the specified signals, compute their $N$-point and zero-padded $M$-point RFFTs, and calculate the required diagnostics.\n\n- **Test A** verifies the identity $X_M[\\ell L] = X_N[\\ell]$ for a composite signal. Due to floating-point arithmetic, we expect the difference $d_A$ to be a very small number close to zero, but not necessarily exactly zero.\n- **Test B** demonstrates how zero-padding helps to find a more accurate peak magnitude for a signal component whose frequency falls between the bins of the coarse DFT grid. The peak magnitude in the padded transform, $P_M$, should be greater than that of the unpadded transform, $P_N$.\n- **Test C** shows that the denser frequency grid from zero-padding allows for a more accurate frequency estimate. The frequency estimate from the padded transform, $\\hat{f}_M$, will be closer to the true frequency $f_0$ than the estimate from the unpadded transform, $\\hat{f}_N$, resulting in an error ratio $r_C > 1$.\n- **Test D** is a sanity check using a null signal, for which the transform is identically zero. The difference $d_D$ must be exactly $0.0$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the four test cases specified in the problem statement\n    related to zero-padding in Fourier transforms.\n    \"\"\"\n    results = []\n\n    # Test A (grid-consistency, happy path)\n    N_A = 128\n    L_A = 4\n    M_A = N_A * L_A\n    n_A = np.arange(N_A)\n    x_A = (np.sin(2.0 * np.pi * 0.125 * n_A) +\n           0.6 * np.cos(2.0 * np.pi * 0.27 * n_A + 0.3) +\n           0.2 * np.sin(2.0 * np.pi * 0.37 * n_A))\n\n    # Compute RFFT at length N and M (with zero-padding)\n    # The 'n' parameter in rfft handles zero-padding if n > len(x)\n    X_N_A = np.fft.rfft(x_A)\n    X_M_A = np.fft.rfft(x_A, n=M_A)\n\n    # Verify that X_M[l*L] == X_N[l]\n    # The length of rfft output is n//2 + 1\n    ell_values_A = np.arange(N_A // 2 + 1)\n    k_values_A = ell_values_A * L_A\n    \n    # Calculate the maximum absolute difference\n    d_A = np.max(np.abs(X_M_A[k_values_A] - X_N_A[ell_values_A]))\n    results.append(d_A)\n\n    # Test B (interpolated peak magnitude off-bin)\n    N_B = 180\n    L_B = 8\n    M_B = N_B * L_B\n    f0_B = 23.7 / N_B\n    n_B = np.arange(N_B)\n    x_B = np.cos(2.0 * np.pi * f0_B * n_B)\n\n    X_N_B = np.fft.rfft(x_B)\n    X_M_B = np.fft.rfft(x_B, n=M_B)\n\n    P_N = np.max(np.abs(X_N_B))\n    P_M = np.max(np.abs(X_M_B))\n\n    result_B = P_M > P_N\n    results.append(result_B)\n\n    # Test C (interpolated frequency estimate improves)\n    N_C = 240\n    L_C = 10\n    M_C = N_C * L_C\n    f0_C = 1.0 / 24.0 + 0.0037\n    n_C = np.arange(N_C)\n    x_C = np.cos(2.0 * np.pi * f0_C * n_C)\n\n    X_N_C = np.fft.rfft(x_C)\n    X_M_C = np.fft.rfft(x_C, n=M_C)\n\n    # Find indices of largest magnitude bins\n    k_hat_N = np.argmax(np.abs(X_N_C))\n    k_hat_M = np.argmax(np.abs(X_M_C))\n\n    # Calculate normalized frequency estimates\n    f_hat_N = k_hat_N / N_C\n    f_hat_M = k_hat_M / M_C\n\n    # Compute the ratio of estimation errors\n    error_N = np.abs(f_hat_N - f0_C)\n    error_M = np.abs(f_hat_M - f0_C)\n    r_C = error_N / error_M\n    results.append(r_C)\n\n    # Test D (edge case, zero signal)\n    N_D = 64\n    L_D = 16\n    M_D = N_D * L_D\n    x_D = np.zeros(N_D)\n\n    X_N_D = np.fft.rfft(x_D)\n    X_M_D = np.fft.rfft(x_D, n=M_D)\n\n    ell_values_D = np.arange(N_D // 2 + 1)\n    k_values_D = ell_values_D * L_D\n\n    d_D = np.max(np.abs(X_M_D[k_values_D] - X_N_D[ell_values_D]))\n    result_D = (d_D == 0.0)\n    results.append(result_D)\n\n    # Format and print the final output as a single-line list\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving beyond the analysis of a single time series, we often need to understand the relationships between two or more geophysical processes, such as identifying teleconnections or tracking propagating waves. This advanced exercise introduces cross-spectral analysis, a powerful technique for quantifying the frequency-dependent relationship between two signals . By estimating the cross-spectrum and coherence, you will learn to extract key information about phase lags and the strength of linear coupling, providing insight into the physical mechanisms connecting different parts of the climate system.",
            "id": "4045315",
            "problem": "A pair of synthetic geoscience time series is used to represent scalar anomalies (for example, sea-level pressure anomalies) at two locations connected by advective transport with a known time delay. The signals share specified narrowband spectral components and independent broadband noise. The task is to estimate the cross-spectrum and magnitude-squared coherence using a variance-reduction approach based on segment-averaged discrete Fourier transforms, and to verify the recovery of the expected phase at the shared bands as implied by the time-lag, together with pronounced coherence peaks at those bands.\n\nFundamental base:\n- Let $x(t)$ and $y(t)$ be real-valued stationary processes sampled at interval $\\Delta t$ (seconds), with sampling frequency $F_s = 1/\\Delta t$ (hertz). The discrete-time samples are $x_n = x(n \\Delta t)$ and $y_n = y(n \\Delta t)$ for integer $n$.\n- The continuous-time Fourier transform of a function $x(t)$ is $X(f) = \\int_{-\\infty}^{\\infty} x(t) e^{-i 2 \\pi f t} \\, dt$, where $f$ is frequency in hertz. The time-shift property states that if $y(t) = x(t - \\tau)$, then $Y(f) = X(f) e^{-i 2 \\pi f \\tau}$ for time-lag $\\tau$ (seconds).\n- The cross-spectrum $S_{xy}(f)$ is defined for jointly stationary processes by $S_{xy}(f) = \\lim_{T \\to \\infty} \\mathbb{E}\\{\\overline{X_T(f)} Y_T(f)\\}$, where $\\overline{Y_T(f)}$ denotes complex conjugation. Under $y(t) = x(t - \\tau)$, the cross-spectrum satisfies $\\arg S_{xy}(f) = -2 \\pi f \\tau$ (radians).\n- The magnitude-squared coherence is defined by $\\gamma^2_{xy}(f) = \\dfrac{|S_{xy}(f)|^2}{S_{xx}(f) S_{yy}(f)}$, taking values in $[0,1]$, quantifying the fraction of power in $x$ at frequency $f$ that is linearly related to $y$.\n\nYou must implement a program that:\n1. Generates synthetic pairs $(x_n, y_n)$ by summing cosines at specified shared bands $\\{(f_i, A_i)\\}$ with known time-lag $\\tau$ and independent zero-mean Gaussian noise of specified standard deviations. Use $x_n = \\sum_i A_i \\cos(2 \\pi f_i t_n) + \\varepsilon^{(x)}_n$, $y_n = \\sum_i A_i \\cos(2 \\pi f_i (t_n - \\tau)) + \\varepsilon^{(y)}_n$, where $t_n = n \\Delta t$, and $\\varepsilon^{(x)}_n$, $\\varepsilon^{(y)}_n$ are independent identically distributed Gaussian noise sequences, each with the given standard deviation. Remove the sample mean (detrend of type constant) before spectral estimation.\n2. Estimates the cross-spectrum $S_{xy}(f)$ and the magnitude-squared coherence $\\gamma^2_{xy}(f)$ using Welch’s method (segment-averaged Discrete Fourier Transform with a Hann window, $50\\%$ overlap), returning frequency bins $f_k$ in hertz.\n3. For each specified shared band $f_i$, identifies the nearest frequency bin $f_k$ and computes:\n   - The estimated cross-spectral phase $\\hat{\\phi}_i = \\arg S_{xy}(f_k)$ in radians.\n   - The estimated coherence $\\hat{\\gamma}^2_i = \\gamma^2_{xy}(f_k)$.\n   - The expected phase $\\phi^{\\star}_i = -2 \\pi f_i \\tau$ in radians, reduced to $(-\\pi, \\pi]$; the phase error $\\delta_i$ must be computed as the wrapped angular difference between $\\hat{\\phi}_i$ and $\\phi^{\\star}_i$ in radians.\n4. Verifies, for each band, that:\n   - The absolute phase error satisfies $|\\delta_i| \\leq \\theta_{\\mathrm{tol}}$, with $\\theta_{\\mathrm{tol}} = 0.35$ (radians).\n   - The coherence exceeds a threshold $\\hat{\\gamma}^2_i \\geq \\gamma_{\\mathrm{min}}$, with $\\gamma_{\\mathrm{min}} = 0.7$, and is a local peak within a neighborhood of $\\pm r$ bins, with $r = 2$.\nA test case is deemed successful if all shared bands in that case satisfy both the phase and coherence conditions.\n\nPhysical and numerical units and angle unit:\n- Time-lag $\\tau$ must be in seconds.\n- Sampling interval $\\Delta t$ must be in seconds.\n- Frequencies $f_i$ must be in hertz.\n- Phases and phase errors must be in radians.\n\nYour program should implement the above and evaluate the following test suite. Each test case is a tuple $(\\Delta t, N, \\tau, \\{(f_i, A_i)\\}, \\sigma_x, \\sigma_y)$ specifying sampling interval, number of samples, time-lag, the set of shared bands with amplitudes, and noise standard deviations. Use the following cases:\n- Case $1$ (happy path, multi-band, positive lag): $(\\Delta t = 3600\\ \\mathrm{s},\\ N = 4320,\\ \\tau = 21600\\ \\mathrm{s},\\ \\{(f_1 = 1/86400\\ \\mathrm{Hz},\\ A_1 = 2.0),\\ (f_2 = 1/259200\\ \\mathrm{Hz},\\ A_2 = 1.5)\\},\\ \\sigma_x = 0.5,\\ \\sigma_y = 0.5)$.\n- Case $2$ (boundary, zero lag): $(\\Delta t = 3600\\ \\mathrm{s},\\ N = 2880,\\ \\tau = 0\\ \\mathrm{s},\\ \\{(f_1 = 1/86400\\ \\mathrm{Hz},\\ A_1 = 2.0),\\ (f_2 = 1/432000\\ \\mathrm{Hz},\\ A_2 = 1.2)\\},\\ \\sigma_x = 0.3,\\ \\sigma_y = 0.3)$.\n- Case $3$ (edge, near-Nyquist component, negative lag): $(\\Delta t = 21600\\ \\mathrm{s},\\ N = 1200,\\ \\tau = -10800\\ \\mathrm{s},\\ \\{(f_1 = 1/86400\\ \\mathrm{Hz},\\ A_1 = 1.0),\\ (f_2 = 0.9 \\times (1/(2 \\times 21600))\\ \\mathrm{Hz},\\ A_2 = 1.0)\\},\\ \\sigma_x = 0.3,\\ \\sigma_y = 0.3)$.\n- Case $4$ (low signal-to-noise, expected failure): $(\\Delta t = 3600\\ \\mathrm{s},\\ N = 1440,\\ \\tau = 14400\\ \\mathrm{s},\\ \\{(f_1 = 1/86400\\ \\mathrm{Hz},\\ A_1 = 0.6),\\ (f_2 = 1/432000\\ \\mathrm{Hz},\\ A_2 = 0.4)\\},\\ \\sigma_x = 1.5,\\ \\sigma_y = 1.5)$.\n\nRandomness and reproducibility:\n- Use a fixed pseudorandom seed for the Gaussian noise generation.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is a boolean indicating success for the corresponding test case, in the order listed above (for example, $[True,False,True,True]$).",
            "solution": "The problem requires the implementation and verification of a cross-spectral analysis method to estimate the time lag between two synthetically generated time series. The problem is scientifically sound, well-posed, and provides sufficient information for a unique solution, contingent on a standard assumption for a parameter in Welch's method. The validation procedure is as follows.\n\n**1. Problem Specification and Givens**\n\nThe core of the problem is to analyze two discrete-time series, $x_n$ and $y_n$, generated according to the model:\n$$x_n = \\sum_i A_i \\cos(2 \\pi f_i t_n) + \\varepsilon^{(x)}_n$$\n$$y_n = \\sum_i A_i \\cos(2 \\pi f_i (t_n - \\tau)) + \\varepsilon^{(y)}_n$$\nwhere $t_n = n \\Delta t$ for $n = 0, 1, \\dots, N-1$. The terms $\\varepsilon^{(x)}_n$ and $\\varepsilon^{(y)}_n$ represent independent, zero-mean Gaussian white noise sequences with specified standard deviations $\\sigma_x$ and $\\sigma_y$, respectively. The series $y_n$ is a time-lagged version of the deterministic component of $x_n$, with a lag of $\\tau$ seconds, plus independent noise.\n\nThe fundamental principle being tested is the time-shift property of the Fourier transform. For a continuous signal $x(t)$ with Fourier transform $X(f)$, a time-shifted version $y(t) = x(t-\\tau)$ has the transform $Y(f) = X(f) e^{-i 2 \\pi f \\tau}$. The cross-spectrum, defined as $S_{xy}(f) \\propto \\mathbb{E}\\{\\overline{X(f)}Y(f)\\}$ (the convention used by libraries like `scipy.signal.csd`), inherits this phase relationship. In the case where $y(t)$ lags $x(t)$ by $\\tau$, the phase of the cross-spectrum is directly proportional to the frequency and the negative of the time lag: $\\arg S_{xy}(f) = -2\\pi f \\tau$. This is the expected phase $\\phi^{\\star}$ used for verification.\n\nThe analysis is performed using Welch's method to estimate the cross-spectral density (CSD), $S_{xy}(f)$, and the magnitude-squared coherence, $\\gamma^2_{xy}(f) = \\frac{|S_{xy}(f)|^2}{S_{xx}(f) S_{yy}(f)}$. The problem specifies a Hann window and $50\\%$ overlap. The segment length, `nperseg`, a key parameter for Welch's method, is not specified. We will proceed under the standard and reasonable assumption of using the default value from the `scipy.signal` library, which is `nperseg=256`. This choice provides a good balance between frequency resolution and variance reduction for the given signal lengths. Pre-processing requires removing the sample mean from each time series before spectral estimation.\n\nVerification for each shared frequency band $f_i$ involves three conditions:\n1.  **Phase Accuracy**: The absolute wrapped phase error, $|\\delta_i|$, must not exceed a tolerance $\\theta_{\\mathrm{tol}} = 0.35$ radians.\n2.  **Coherence Magnitude**: The estimated coherence, $\\hat{\\gamma}^2_i$, must meet or exceed a minimum threshold $\\gamma_{\\mathrm{min}} = 0.7$.\n3.  **Coherence Peak**: The value $\\hat{\\gamma}^2_i$ must be a local maximum within a neighborhood of $\\pm r$ frequency bins, where $r=2$.\n\nA test case is deemed successful only if all its specified frequency bands satisfy all three conditions.\n\n**2. Algorithmic Procedure**\n\nFor each test case $(\\Delta t, N, \\tau, \\{(f_i, A_i)\\}, \\sigma_x, \\sigma_y)$:\n\n**Step 1: Signal Generation**\n- A pseudorandom number generator is initialized with a fixed seed to ensure reproducibility.\n- A time vector $t$ of length $N$ is created: $t = [0, \\Delta t, 2\\Delta t, \\dots, (N-1)\\Delta t]$.\n- The deterministic components of the signals $x$ and $y$ are synthesized by summing the specified cosine terms.\n- Independent Gaussian noise is generated and added to each signal.\n- The global mean of each complete time series is calculated and subtracted, as specified by the detrending requirement.\n\n**Step 2: Spectral Estimation**\n- The sampling frequency is calculated as $F_s = 1/\\Delta t$.\n- The cross-spectral density $S_{xy}$ is estimated using `scipy.signal.csd(x, y, fs=F_s, window='hann', nperseg=256, noverlap=128, detrend=False)`. `detrend=False` is used because the global mean has already been removed manually.\n- The magnitude-squared coherence $\\gamma^2_{xy}$ is estimated using `scipy.signal.coherence(x, y, fs=F_s, window='hann', nperseg=256, noverlap=128, detrend=False)`.\n- These functions return the estimated spectral quantities and the corresponding frequency array, $f_k$.\n\n**Step 3: Verification**\n- A flag, `case_successful`, is initialized to `True`.\n- For each target frequency $f_i$ in the test case:\n    - The index $k$ of the frequency bin $f_k$ closest to $f_i$ is found: $k = \\operatorname{argmin}_{j} |f_j - f_i|$.\n    - The estimated phase is extracted: $\\hat{\\phi}_i = \\operatorname{angle}(S_{xy}[k])$. This value is in the range $(-\\pi, \\pi]$.\n    - The theoretical expected phase is calculated, $\\phi^{\\star}_{i, \\text{raw}} = -2 \\pi f_i \\tau$, and then wrapped to the $(-\\pi, \\pi]$ interval: $\\phi^{\\star}_i = \\operatorname{atan2}(\\sin(\\phi^{\\star}_{i, \\text{raw}}), \\cos(\\phi^{\\star}_{i, \\text{raw}}))$.\n    - The wrapped phase difference (error) is computed: $\\delta_i = \\operatorname{atan2}(\\sin(\\hat{\\phi}_i - \\phi^{\\star}_i), \\cos(\\hat{\\phi}_i - \\phi^{\\star}_i))$.\n    - The condition $|\\delta_i| \\leq \\theta_{\\mathrm{tol}}$ is checked. If it fails, `case_successful` is set to `False`, and the verification for this test case terminates.\n    - The estimated coherence is extracted: $\\hat{\\gamma}^2_i = \\gamma^2_{xy}[k]$.\n    - The condition $\\hat{\\gamma}^2_i \\geq \\gamma_{\\mathrm{min}}$ is checked. If it fails, `case_successful` is set to `False` and the process terminates for the case.\n    - The local peak condition is checked. A slice of the coherence array from index $k-r$ to $k+r$ is extracted (with boundary handling). If $\\hat{\\gamma}^2_i$ is not the maximum value in this neighborhood, `case_successful` is set to `False`.\n- After checking all bands, the final value of `case_successful` is recorded for the test case.\n\nThis procedure is repeated for all four test cases, and the boolean results are compiled into a final list. The fourth case, designed with a low signal-to-noise ratio, is expected to fail the coherence checks, demonstrating the method's sensitivity to noise.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Solves the problem of verifying cross-spectral estimation of time lag\n    between two synthetic geoscience time series.\n    \"\"\"\n    \n    # Define verification parameters from the problem statement.\n    theta_tol = 0.35  # radians\n    gamma_min = 0.7\n    r = 2  # neighborhood radius for peak checking\n    \n    # Use a fixed seed for reproducibility of random noise.\n    rng = np.random.default_rng(seed=42)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (happy path, multi-band, positive lag)\n        (3600.0, 4320, 21600.0, [(1.0/86400.0, 2.0), (1.0/259200.0, 1.5)], 0.5, 0.5),\n        # Case 2: (boundary, zero lag)\n        (3600.0, 2880, 0.0, [(1.0/86400.0, 2.0), (1.0/432000.0, 1.2)], 0.3, 0.3),\n        # Case 3: (edge, near-Nyquist component, negative lag)\n        (21600.0, 1200, -10800.0, [(1.0/86400.0, 1.0), (0.9 * (1.0 / (2.0 * 21600.0)), 1.0)], 0.3, 0.3),\n        # Case 4: (low signal-to-noise, expected failure)\n        (3600.0, 1440, 14400.0, [(1.0/86400.0, 0.6), (1.0/432000.0, 0.4)], 1.5, 1.5),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        dt, N, tau, bands, sigma_x, sigma_y = case\n        \n        # --- 1. Generate synthetic time series ---\n        t = np.arange(N) * dt\n        x_signal = np.zeros(N)\n        y_signal = np.zeros(N)\n        \n        for f_i, A_i in bands:\n            x_signal += A_i * np.cos(2 * np.pi * f_i * t)\n            y_signal += A_i * np.cos(2 * np.pi * f_i * (t - tau))\n            \n        noise_x = rng.normal(0, sigma_x, N)\n        noise_y = rng.normal(0, sigma_y, N)\n        \n        x = x_signal + noise_x\n        y = y_signal + noise_y\n        \n        # Remove the sample mean (detrend of type constant)\n        x -= np.mean(x)\n        y -= np.mean(y)\n\n        # --- 2. Estimate cross-spectrum and coherence ---\n        fs = 1.0 / dt\n        nperseg = 256  # Using scipy default as it's not specified\n        noverlap = nperseg // 2 # 50% overlap\n\n        # Use detrend=False since we manually detrended the whole signal\n        freqs, S_xy = signal.csd(x, y, fs=fs, window='hann', nperseg=nperseg, noverlap=noverlap, detrend=False)\n        coh_freqs, C_xy = signal.coherence(x, y, fs=fs, window='hann', nperseg=nperseg, noverlap=noverlap, detrend=False)\n\n        case_successful = True\n        \n        # --- 3. Verify conditions for each shared band ---\n        for f_i, _ in bands:\n            # Find the nearest frequency bin\n            k = np.argmin(np.abs(freqs - f_i))\n\n            # a) Verify phase error\n            phi_est = np.angle(S_xy[k])\n            phi_exp_raw = -2 * np.pi * f_i * tau\n            \n            # Wrap expected phase to (-pi, pi] to match np.angle output\n            phi_exp = np.arctan2(np.sin(phi_exp_raw), np.cos(phi_exp_raw))\n\n            # Calculate wrapped angular difference\n            phase_error = np.arctan2(np.sin(phi_est - phi_exp), np.cos(phi_est - phi_exp))\n\n            if np.abs(phase_error) > theta_tol:\n                case_successful = False\n                break\n\n            # b) Verify coherence magnitude\n            gamma2_est = C_xy[k]\n            if gamma2_est  gamma_min:\n                case_successful = False\n                break\n                \n            # c) Verify coherence is a local peak\n            start_idx = max(0, k - r)\n            end_idx = min(len(C_xy), k + r + 1)\n            neighborhood = C_xy[start_idx:end_idx]\n            \n            # Check if the estimated coherence is the maximum in its neighborhood.\n            # np.isclose is used to handle potential floating-point inaccuracies.\n            if not np.isclose(gamma2_est, np.max(neighborhood)):\n                case_successful = False\n                break\n\n        if not case_successful: # break from outer loop if inner loop failed\n             results.append(False)\n             continue\n        \n        results.append(True)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}