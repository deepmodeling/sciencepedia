{
    "hands_on_practices": [
        {
            "introduction": "在全球模型中，我们经常需要在不同网格之间传递数据，同时必须保证总质量或总能量等物理量守恒。这需要精确计算球体上网格单元的面积，并用其来定义守恒重映射的权重。通过从第一性原理出发推导球面上经纬度网格单元的精确面积 ，本练习将帮助您掌握这一基本技能，并将其应用于守恒重映射这一核心概念。",
            "id": "4092520",
            "problem": "一个球形地球上的全球大气模型使用经纬度网格。假设地球是一个半径为 $R$ 的完美球体，地理纬度为 $\\phi \\in \\left[-\\frac{\\pi}{2}, \\frac{\\pi}{2}\\right]$，经度为 $\\lambda \\in [0, 2\\pi)$。考虑一个跨越 $\\phi \\in \\left[\\phi - \\frac{\\Delta \\phi}{2}, \\phi + \\frac{\\Delta \\phi}{2}\\right]$ 和 $\\lambda \\in \\left[\\lambda_{0} - \\frac{\\Delta \\lambda}{2}, \\lambda_{0} + \\frac{\\Delta \\lambda}{2}\\right]$ 的单一经纬度单元，其中所有角度均以弧度为单位。\n\n从球面几何的第一性原理出发，推导该单元在球面上的表面积的精确、闭式表达式（无小角度近似）。然后，利用单元平均标量场的积分在重映射下守恒的要求，推导从源单元到目标单元的一阶守恒重映射权重表达式，该表达式用它们的球形重叠区域面积和目标单元面积表示。\n\n最后，针对以下具体配置，计算该守恒重映射权重，其中单个源单元对目标单元有贡献。源单元跨越\n$\\phi \\in \\left[\\frac{\\pi}{6} - \\frac{\\pi}{36}, \\frac{\\pi}{6} + \\frac{\\pi}{36}\\right]$ 和 $\\lambda \\in \\left[0, \\frac{\\pi}{18}\\right]$。\n目标单元跨越\n$\\phi \\in \\left[\\frac{\\pi}{6} - \\frac{\\pi}{36}, \\frac{\\pi}{6} + \\frac{\\pi}{36}\\right]$ 和 $\\lambda \\in \\left[\\frac{\\pi}{36}, \\frac{\\pi}{12}\\right]$。\n假设此处不考虑其他重叠的源单元；仅计算此单个源单元对目标单元贡献的权重，该权重定义为球形重叠区域面积与目标单元面积之比。所有角度均以弧度为单位。将最终权重表示为单个精确数字或简化的无单位精确表达式。无需四舍五入。",
            "solution": "**第 1 部分：经纬度单元表面积的推导**\n\n半径为 $R$ 的球面上的一个点可以用球面坐标 $(\\lambda, \\phi)$ 来描述，其中 $\\lambda$ 是经度，$\\phi$ 是纬度。球面上的无穷小表面积元 $dA$ 由下式给出：\n$$dA = R^2 \\cos(\\phi) \\, d\\phi \\, d\\lambda$$\n一个经纬度单元由边界 $\\phi \\in [\\phi_1, \\phi_2]$ 和 $\\lambda \\in [\\lambda_1, \\lambda_2]$ 定义。该单元的总表面积 $A$ 通过在这些边界上对面积元进行积分得到：\n$$A = \\int_{\\lambda_1}^{\\lambda_2} \\int_{\\phi_1}^{\\phi_2} R^2 \\cos(\\phi) \\, d\\phi \\, d\\lambda$$\n由于被积函数和积分限是可分离的，我们可以将积分写成：\n$$A = R^2 \\left( \\int_{\\lambda_1}^{\\lambda_2} d\\lambda \\right) \\left( \\int_{\\phi_1}^{\\phi_2} \\cos(\\phi) \\, d\\phi \\right)$$\n分别计算每个积分：\n经度上的积分是：\n$$\\int_{\\lambda_1}^{\\lambda_2} d\\lambda = \\lambda_2 - \\lambda_1 = \\Delta\\lambda$$\n纬度上的积分是：\n$$\\int_{\\phi_1}^{\\phi_2} \\cos(\\phi) \\, d\\phi = [\\sin(\\phi)]_{\\phi_1}^{\\phi_2} = \\sin(\\phi_2) - \\sin(\\phi_1)$$\n将这些结果结合起来，得到单元表面积的精确闭式表达式：\n$$A = R^2 (\\lambda_2 - \\lambda_1) (\\sin(\\phi_2) - \\sin(\\phi_1))$$\n此表达式是从第一性原理推导出来的，没有使用任何小角度近似。\n\n**第 2 部分：守恒重映射权重的推导**\n\n设 $\\Psi$ 为一个单元平均的标量（例如，单位面积的示踪剂质量）。守恒重映射要求在从源网格移动到目标网格时，该量的总量是守恒的。\n在一个单元中，量 $Q$ 的总量是单元平均值 $\\Psi$ 和单元面积 $A$ 的乘积：$Q = \\Psi A$。\n我们考虑一个目标单元 $T$，它被一组源单元 $\\{S_i\\}$ 所重叠。目标单元中的总量 $Q_T = \\Psi_T A_T$ 必须等于每个重叠源单元贡献的量之和。\n$$Q_T = \\sum_i Q_{S_i \\to T}$$\n其中 $Q_{S_i \\to T}$ 是从源单元 $S_i$ 转移到目标单元 $T$ 的量。\n假设标量场在每个源单元 $S_i$ 内均匀分布，则转移到目标单元 $T$ 的量与它们的交集面积 $A_{S_i \\cap T}$ 成正比。从 $S_i$ 转移的量是其总量 $Q_{S_i} = \\Psi_{S_i} A_{S_i}$ 乘以重叠的面积分数：\n$$Q_{S_i \\to T} = Q_{S_i} \\frac{A_{S_i \\cap T}}{A_{S_i}} = (\\Psi_{S_i} A_{S_i}) \\frac{A_{S_i \\cap T}}{A_{S_i}} = \\Psi_{S_i} A_{S_i \\cap T}$$\n将此代回 $Q_T$ 的守恒方程：\n$$\\Psi_T A_T = \\sum_i \\Psi_{S_i} A_{S_i \\cap T}$$\n求解目标单元中的单元平均值 $\\Psi_T$：\n$$\\Psi_T = \\sum_i \\Psi_{S_i} \\left(\\frac{A_{S_i \\cap T}}{A_T}\\right)$$\n这个方程定义了一阶守恒重映射。项 $w_{S_i \\to T} = \\frac{A_{S_i \\cap T}}{A_T}$ 是重映射权重，代表源单元 $S_i$ 对目标单元 $T$ 的贡献。这证实了问题陈述中提供的定义。\n\n**第 3 部分：特定重映射权重的计算**\n\n我们需要为给定的源单元 ($S$) 和目标单元 ($T$) 计算权重 $w_{S \\to T} = \\frac{A_{S \\cap T}}{A_T}$。\n\n源单元的边界是：\n- 纬度：$\\phi \\in \\left[\\frac{\\pi}{6} - \\frac{\\pi}{36}, \\frac{\\pi}{6} + \\frac{\\pi}{36}\\right] = \\left[\\frac{5\\pi}{36}, \\frac{7\\pi}{36}\\right]$\n- 经度：$\\lambda \\in \\left[0, \\frac{\\pi}{18}\\right]$\n\n目标单元的边界是：\n- 纬度：$\\phi \\in \\left[\\frac{\\pi}{6} - \\frac{\\pi}{36}, \\frac{\\pi}{6} + \\frac{\\pi}{36}\\right] = \\left[\\frac{5\\pi}{36}, \\frac{7\\pi}{36}\\right]$\n- 经度：$\\lambda \\in \\left[\\frac{\\pi}{36}, \\frac{\\pi}{12}\\right]$\n\n首先，我们计算目标单元的面积 $A_T$。\n- 纬度边界：$\\phi_1 = \\frac{5\\pi}{36}$，$\\phi_2 = \\frac{7\\pi}{36}$\n- 经度边界：$\\lambda_1 = \\frac{\\pi}{36}$，$\\lambda_2 = \\frac{\\pi}{12} = \\frac{3\\pi}{36}$\n经度宽度为 $\\Delta\\lambda_T = \\lambda_2 - \\lambda_1 = \\frac{3\\pi}{36} - \\frac{\\pi}{36} = \\frac{2\\pi}{36} = \\frac{\\pi}{18}$。\n使用面积公式：\n$$A_T = R^2 \\left(\\frac{\\pi}{18}\\right) \\left[ \\sin\\left(\\frac{7\\pi}{36}\\right) - \\sin\\left(\\frac{5\\pi}{36}\\right) \\right]$$\n\n接下来，我们确定重叠区域 $S \\cap T$ 并计算其面积 $A_{S \\cap T}$。\n- 纬度重叠：$S$ 和 $T$ 的纬度范围相同，所以重叠范围是 $\\phi \\in \\left[\\frac{5\\pi}{36}, \\frac{7\\pi}{36}\\right]$。\n- 经度重叠：我们求经度区间 $\\left[0, \\frac{\\pi}{18}\\right]$ 和 $\\left[\\frac{\\pi}{36}, \\frac{\\pi}{12}\\right]$ 的交集。\n  我们使用公分母 36：$\\left[0, \\frac{2\\pi}{36}\\right]$ 和 $\\left[\\frac{\\pi}{36}, \\frac{3\\pi}{36}\\right]$。\n  交集是 $\\lambda \\in \\left[\\frac{\\pi}{36}, \\frac{2\\pi}{36}\\right] = \\left[\\frac{\\pi}{36}, \\frac{\\pi}{18}\\right]$。\n所以，对于重叠区域 $S \\cap T$：\n- 纬度边界：$\\phi_1 = \\frac{5\\pi}{36}$，$\\phi_2 = \\frac{7\\pi}{36}$\n- 经度边界：$\\lambda_1 = \\frac{\\pi}{36}$，$\\lambda_2 = \\frac{\\pi}{18}$\n重叠区域的经度宽度是 $\\Delta\\lambda_{S \\cap T} = \\frac{\\pi}{18} - \\frac{\\pi}{36} = \\frac{2\\pi - \\pi}{36} = \\frac{\\pi}{36}$。\n重叠区域的面积是：\n$$A_{S \\cap T} = R^2 \\left(\\frac{\\pi}{36}\\right) \\left[ \\sin\\left(\\frac{7\\pi}{36}\\right) - \\sin\\left(\\frac{5\\pi}{36}\\right) \\right]$$\n\n最后，我们计算重映射权重 $w_{S \\to T}$：\n$$w_{S \\to T} = \\frac{A_{S \\cap T}}{A_T} = \\frac{R^2 \\left(\\frac{\\pi}{36}\\right) \\left[ \\sin\\left(\\frac{7\\pi}{36}\\right) - \\sin\\left(\\frac{5\\pi}{36}\\right) \\right]}{R^2 \\left(\\frac{\\pi}{18}\\right) \\left[ \\sin\\left(\\frac{7\\pi}{36}\\right) - \\sin\\left(\\frac{5\\pi}{36}\\right) \\right]}$$\n项 $R^2$ 和 $\\left[ \\sin\\left(\\frac{7\\pi}{36}\\right) - \\sin\\left(\\frac{5\\pi}{36}\\right) \\right]$ 消掉了。权重简化为重叠区域和目标单元区域的经度宽度之比：\n$$w_{S \\to T} = \\frac{\\frac{\\pi}{36}}{\\frac{\\pi}{18}} = \\frac{\\pi}{36} \\cdot \\frac{18}{\\pi} = \\frac{18}{36} = \\frac{1}{2}$$\n守恒重映射权重是 $\\frac{1}{2}$。",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "在数值天气预报和气候模型的模拟中，时间步长的选择对计算的稳定性至关重要。在球坐标网格中，经线间的物理距离会向两极急剧缩小，这被称为“极点问题”，它通过 Courant-Friedrichs-Lewy (CFL) 条件严格限制了模型所能使用的最大时间步长。本练习将引导您推导并应用球坐标系下的 CFL 条件 ，从而深刻理解网格几何形态如何直接影响模型的计算效率和稳定性。",
            "id": "4092519",
            "problem": "考虑一个用于数值天气预报和气候模拟的经纬度球坐标网格，该网格建立在半径为 $R = 6.371 \\times 10^{6} \\text{ m}$ 的球形地球上。一个无源标量 $q$ 被峰值速度为 $U$ 的纯纬向风沿着纬度为 $\\phi$ 的纬线平流。控制其输运的是线性平流方程 $\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial s} = 0$，其中 $s$ 表示在固定纬度 $\\phi$ 上沿纬线的弧长，$u$ 是风的纬向分量。沿一条纬线，与经度增量 $\\Delta \\lambda$（以弧度为单位）对应的距离是 $R \\cos(\\phi) \\, \\Delta \\lambda$。该模型在时间和经度上采用显式一阶迎风离散格式，并受到平流方向上 Courant–Friedrichs–Lewy (CFL) 稳定性条件的约束。\n\n从平流方程和球面弧长关系出发，推导在纬度 $\\phi$ 处最大允许时间步长 $\\Delta t_{\\max}$ 作为 $R$、$\\phi$、$\\Delta \\lambda$ 和 $U$ 的函数表达式。然后，针对以下配置计算最大允许时间步长：\n- 纬度 $\\phi = 60^{\\circ}$，\n- 初始经度间距 $\\Delta \\lambda_{0} = 0.5^{\\circ}$，\n- 加密后的经度间距 $\\Delta \\lambda_{1} = 0.25^{\\circ}$，\n- 峰值纬向风 $U = 90 \\text{ m/s}$，\n计算时需将角度转换为弧度。\n\n报告在 $\\Delta \\lambda_{0}$ 处的最大允许时间步长、在 $\\Delta \\lambda_{1}$ 处的最大允许时间步长，以及比率 $\\Delta t_{\\max}(\\Delta \\lambda_{1}) / \\Delta t_{\\max}(\\Delta \\lambda_{0})$。将所有报告值四舍五入至四位有效数字。时间步长以秒为单位表示，比率表示为无量纲小数。",
            "solution": "第一步是推导最大允许时间步长 $\\Delta t_{\\max}$ 的通用表达式。控制无源标量 $q$ 输运的方程是一维线性平流方程：\n$$\n\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial s} = 0\n$$\n其中 $t$ 是时间，$s$ 是沿纬线的弧长坐标，$u$ 是恒定的纬向风速，给定为 $U$。\n\n问题指明了使用显式一阶迎风离散格式。关于时间的偏导数 $\\frac{\\partial q}{\\partial t}$ 使用向前差分进行近似：\n$$\n\\frac{\\partial q}{\\partial t} \\approx \\frac{q_j^{n+1} - q_j^n}{\\Delta t}\n$$\n其中上标 $n$ 表示时间层，下标 $j$ 表示经向上的空间网格点。\n\n空间导数 $\\frac{\\partial q}{\\partial s}$ 使用一阶迎风差分进行近似。由于风是纬向的，我们可以不失一般性地假设 $u = U > 0$（代表西风）。因此，迎风方向是网格点 $j-1$。空间导数为：\n$$\n\\frac{\\partial q}{\\partial s} \\approx \\frac{q_j^n - q_{j-1}^n}{\\Delta s}\n$$\n其中 $\\Delta s$ 是沿纬线的空间网格间距。\n\n将这些近似代入平流方程，得到完全离散化的格式：\n$$\n\\frac{q_j^{n+1} - q_j^n}{\\Delta t} + U \\left( \\frac{q_j^n - q_{j-1}^n}{\\Delta s} \\right) = 0\n$$\n为了分析稳定性，我们重排方程以求解下一个时间步的值 $q_j^{n+1}$：\n$$\nq_j^{n+1} = q_j^n - \\frac{U \\Delta t}{\\Delta s} (q_j^n - q_{j-1}^n)\n$$\n这可以通过定义 Courant 数 $C$ 来重写：\n$$\nC = \\frac{U \\Delta t}{\\Delta s}\n$$\n离散化方程变为：\n$$\nq_j^{n+1} = (1 - C) q_j^n + C q_{j-1}^n\n$$\n为使该显式格式稳定，von Neumann 稳定性分析（或更简单的系数分析）要求 Courant 数 $C$ 满足条件 $0 \\le C \\le 1$。由于 $U$、$\\Delta t$ 和 $\\Delta s$ 均为正值，条件 $C \\ge 0$ 自然满足。因此，稳定性由 Courant–Friedrichs–Lewy (CFL) 条件决定：\n$$\nC = \\frac{U \\Delta t}{\\Delta s} \\le 1\n$$\n最大允许时间步长 $\\Delta t_{\\max}$ 在此不等式的极限处（即 $C=1$）取得：\n$$\n\\frac{U \\Delta t_{\\max}}{\\Delta s} = 1 \\implies \\Delta t_{\\max} = \\frac{\\Delta s}{U}\n$$\n问题给出了在半径为 $R$ 的球体上，纬度 $\\phi$ 处与经度增量 $\\Delta \\lambda$（以弧度为单位）对应的弧长 $\\Delta s$ 的关系：\n$$\n\\Delta s = R \\cos(\\phi) \\Delta \\lambda\n$$\n将 $\\Delta s$ 的表达式代入 $\\Delta t_{\\max}$ 的方程，得出通用公式：\n$$\n\\Delta t_{\\max} = \\frac{R \\cos(\\phi) \\Delta \\lambda}{U}\n$$\n\n接下来，我们根据指定的配置计算该表达式的值。给定的参数如下：\n- 地球半径，$R = 6.371 \\times 10^{6}$ 米。\n- 峰值纬向风速，$U = 90$ 米/秒。\n- 纬度，$\\phi = 60^{\\circ}$。\n- 初始经度间距，$\\Delta \\lambda_{0} = 0.5^{\\circ}$。\n- 加密后的经度间距，$\\Delta \\lambda_{1} = 0.25^{\\circ}$。\n\n在计算中，必须使用转换因子 $\\frac{\\pi}{180}$ 将角度从度转换为弧度。\n纬度（以弧度表示）为 $\\phi = 60^{\\circ} \\times \\frac{\\pi}{180^{\\circ}} = \\frac{\\pi}{3}$ 弧度。该纬度的余弦值为 $\\cos(\\frac{\\pi}{3}) = 0.5$。\n经度间距（以弧度表示）为：\n$$\n\\Delta \\lambda_{0} = 0.5^{\\circ} \\times \\frac{\\pi}{180^{\\circ}} \\text{ rad}\n$$\n$$\n\\Delta \\lambda_{1} = 0.25^{\\circ} \\times \\frac{\\pi}{180^{\\circ}} \\text{ rad}\n$$\n\n现在，我们计算初始经度间距下的最大时间步长 $\\Delta t_{\\max}(\\Delta \\lambda_{0})$：\n$$\n\\Delta t_{\\max}(\\Delta \\lambda_{0}) = \\frac{(6.371 \\times 10^{6}) \\times \\cos(60^{\\circ}) \\times (0.5 \\times \\frac{\\pi}{180})}{90}\n$$\n$$\n\\Delta t_{\\max}(\\Delta \\lambda_{0}) = \\frac{(6.371 \\times 10^{6}) \\times 0.5 \\times (0.5 \\times \\pi)}{90 \\times 180} = \\frac{1592750 \\times \\pi}{16200} \\approx 308.8767 \\text{ s}\n$$\n四舍五入到四位有效数字，我们得到 $\\Delta t_{\\max}(\\Delta \\lambda_{0}) = 308.9$ 秒。\n\n接下来，我们计算加密后经度间距下的最大时间步长 $\\Delta t_{\\max}(\\Delta \\lambda_{1})$：\n$$\n\\Delta t_{\\max}(\\Delta \\lambda_{1}) = \\frac{(6.371 \\times 10^{6}) \\times \\cos(60^{\\circ}) \\times (0.25 \\times \\frac{\\pi}{180})}{90}\n$$\n$$\n\\Delta t_{\\max}(\\Delta \\lambda_{1}) = \\frac{(6.371 \\times 10^{6}) \\times 0.5 \\times (0.25 \\times \\pi)}{90 \\times 180} = \\frac{796375 \\times \\pi}{16200} \\approx 154.4384 \\text{ s}\n$$\n四舍五入到四位有效数字，我们得到 $\\Delta t_{\\max}(\\Delta \\lambda_{1}) = 154.4$ 秒。\n\n最后，我们计算比率 $\\frac{\\Delta t_{\\max}(\\Delta \\lambda_{1})}{\\Delta t_{\\max}(\\Delta \\lambda_{0})}$。从推导出的公式可以看出，$\\Delta t_{\\max}$ 与 $\\Delta \\lambda$ 成正比，而所有其他因素都是常数。因此，该比率为：\n$$\n\\frac{\\Delta t_{\\max}(\\Delta \\lambda_{1})}{\\Delta t_{\\max}(\\Delta \\lambda_{0})} = \\frac{\\frac{R \\cos(\\phi) \\Delta \\lambda_{1}}{U}}{\\frac{R \\cos(\\phi) \\Delta \\lambda_{0}}{U}} = \\frac{\\Delta \\lambda_{1}}{\\Delta \\lambda_{0}}\n$$\n使用给定的度数值：\n$$\n\\text{Ratio} = \\frac{0.25^{\\circ}}{0.5^{\\circ}} = 0.5\n$$\n作为四舍五入到四位有效数字的小数，该比率为 $0.5000$。\n\n所要求的三个值是：$\\Delta \\lambda_{0}$ 的最大允许时间步长、$\\Delta \\lambda_{1}$ 的最大允许时间步长以及它们的比率。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 308.9  154.4  0.5000 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "现代天气和气候科学需要将海量的观测数据与模型网格相结合，例如，在数据同化或模型评估中，我们常常需要为每个观测点快速找到最近的模型格点。这项任务不仅涉及到坐标变换和大圆距离的计算，还需要高效的空间数据结构来加速搜索过程。本练习将指导您设计并分析一个在球面上进行最近邻搜索的算法 ，它将球体几何学与计算机科学中的基本数据结构巧妙地结合起来，是解决实际科研问题的典型范例。",
            "id": "4092517",
            "problem": "考虑一个球形地球模型，其半径为 $R = 6{,}371{,}000\\,\\text{m}$。在数值天气预报和气候模拟中，经常需要对球面进行空间查询，例如将观测数据映射到模型网格点上。加速此类查询的一个通用策略是基于点集构建一个k维树（KD-Tree），它支持高效的最近邻（NN）搜索。\n\n你需要设计一个算法，对于给定的一组球面上的地理定位点，使用球形KD树计算NN搜索所需的大圆距离，并分析搜索过程的计算复杂度。你的算法必须从球面几何和线性代数的基本原理出发，并基于以下基础：\n\n- 在半径为 $R$ 的球体上，大圆是球面上任意两点之间测地距离最短的点的轨迹。\n- 两个单位向量的标量（点）积等于它们之间夹角的余弦值。\n- 欧几里得范数定义为 $\\lVert \\mathbf{x} \\rVert = \\sqrt{x_1^2 + x_2^2 + x_3^2}$。\n\n算法设计要求：\n\n- 使用大地纬度 $\\varphi$ 和经度 $\\lambda$（单位：度）表示每个位置。清晰地说明如何将 $(\\varphi, \\lambda)$ 转换为球面上的三维单位向量。\n- 仅使用上述基本定义来定义球面上两点之间的大圆距离。避免在问题陈述中提供任何目标公式。\n- 在 $\\mathbb{R}^3$ 空间中，基于单位向量构建一个KD树，使用轴对齐的分割，并交替在 $x, y, z$ 坐标上进行。树应通过中位数分割来构建，以确保其平衡性。\n- 通过遍历KD树对查询点执行NN搜索。使用一个可证明有效且基于 $\\mathbb{R}^3$ 中的欧几里得弦长与球面上大圆距离之间单调关系的剪枝准则。定义并计算搜索过程中执行的节点评估次数，即搜索算法计算查询点到存储节点之间距离的总次数。如果距离出现平局，则选择索引最小的点来打破平局。\n- 距离必须以米为单位表示，并四舍五入到最近的整数米。输入中的角度以度为单位给出，必须在内部转换为弧度。\n\n测试套件：\n\n共有 $4$ 个测试用例。点的索引从 $0$ 开始，按提供顺序排列。\n\n$1.$ 包含异构全球位置的“理想情况”（Happy-path）：\n- 点 $(\\varphi, \\lambda)$（单位：度）：\n  $[(51.5074, -0.1278), (48.8566, 2.3522), (40.7128, -74.0060), (35.6895, 139.6917), (-33.8688, 151.2093), (-33.9249, 18.4241), (-22.9068, -43.1729), (55.7558, 37.6173), (28.7041, 77.1025), (-1.2921, 36.8219)]$。\n- 查询点 $(\\varphi, \\lambda)$: $(48.1351, 11.5820)$。\n- 每个测试用例的输出格式：$[\\text{distance\\_m}, \\text{index}, \\text{nodes\\_visited}]$。\n\n$2.$ 零距离下的正确性测试（精确匹配情况）：\n- 点：$[(10.0, 20.0), (-10.0, -20.0), (0.0, 0.0)]$。\n- 查询点：$(0.0, 0.0)$。\n\n$3.$ 近对跖点场景，用于测试数值稳定性和剪枝效率：\n- 点：$[(0.0, 0.0), (0.0, 180.0), (10.0, 90.0), (-10.0, -90.0)]$。\n- 查询点：$(0.0, 179.999)$。\n\n$4.$ 靠近极地和国际日期变更线，用于测试对极端经度和高纬度的处理能力：\n- 点：$[(89.9, 0.0), (89.9, 179.9), (89.9, -179.9), (0.0, 180.0)]$。\n- 查询点：$(89.95, -179.5)$。\n\n你的程序应生成单行输出，其中包含四个测试用例的结果。结果是一个由方括号括起来的逗号分隔列表，每个测试用例的结果格式化为一个包含三个指定值的子列表。例如：$[[d_1,i_1,v_1],[d_2,i_2,v_2],[d_3,i_3,v_3],[d_4,i_4,v_4]]$，其中每个 $d_k$ 是整数米数，每个 $i_k$ 是整数索引，每个 $v_k$ 是整数节点访问计数。\n\n关于科学真实性的说明：\n\n- 假设地球为半径为 $R$ 的均匀球体，如前所述。\n- 使用正纬度代表北，正经度代表东的约定。\n- 通过在从点积计算角度时进行适当的截断（clamping）来确保数值稳定性。",
            "solution": "### 1. 基本原理与定义\n\n本解决方案基于问题陈述中指定的基本原理构建。\n\n#### 1.1. 坐标系变换\n\n地球表面的一个点由其大地纬度 $\\varphi$（单位：度，北半球为正）和经度 $\\lambda$（单位：度，东半球为正）给出。为了在欧几里得空间中进行计算，我们将这些球面坐标转换为三维笛卡尔坐标系 $(x, y, z)$。原点位于地球中心，$z$ 轴穿过北极，$x$ 轴穿过本初子午线 $(\\lambda=0^\\circ)$ 与赤道 $(\\varphi=0^\\circ)$ 的交点，$y$ 轴构成右手坐标系。\n\n首先，我们将经纬度从度转换为弧度：\n$$ \\varphi_{\\text{rad}} = \\varphi \\cdot \\frac{\\pi}{180} $$\n$$ \\lambda_{\\text{rad}} = \\lambda \\cdot \\frac{\\pi}{180} $$\n\n对于单位半径（$R=1$）的球体，转换方程源自标准的球面到笛卡尔坐标转换，其中大地纬度 $\\varphi$ 与标准极角 $\\theta$（从 $z$ 轴测量）互余，即 $\\theta = \\frac{\\pi}{2} - \\varphi_{\\text{rad}}$：\n$$ x = \\cos(\\varphi_{\\text{rad}}) \\cos(\\lambda_{\\text{rad}}) $$\n$$ y = \\cos(\\varphi_{\\text{rad}}) \\sin(\\lambda_{\\text{rad}}) $$\n$$ z = \\sin(\\varphi_{\\text{rad}}) $$\n此变换将任意大地坐标对映射到一个唯一的单位向量 $\\mathbf{u} = (x, y, z)$，其中 $\\lVert \\mathbf{u} \\rVert = 1$。这种表示法的优点是避免了 $(\\varphi, \\lambda)$ 坐标系中存在的两极奇点和 $180^\\circ$ 经线处的不连续性。\n\n#### 1.2. 大圆距离\n\n大圆距离是球面上两点之间的最短距离。对于由三维单位向量 $\\mathbf{u}_1$ 和 $\\mathbf{u}_2$ 表示的两个点，它们之间的中心角 $\\gamma$ 可以通过点积求得，如规定：\n$$ \\mathbf{u}_1 \\cdot \\mathbf{u}_2 = \\lVert \\mathbf{u}_1 \\rVert \\lVert \\mathbf{u}_2 \\rVert \\cos(\\gamma) = (1)(1)\\cos(\\gamma) = \\cos(\\gamma) $$\n因此，角度 $\\gamma$（以弧度为单位）为：\n$$ \\gamma = \\arccos(\\mathbf{u}_1 \\cdot \\mathbf{u}_2) $$\n由于潜在的浮点数不精确性，点积结果可能略微超出有效范围 $[-1, 1]$。在应用 $\\arccos$ 函数之前，必须将其截断到此区间内。在半径为 $R$ 的球体上，大圆距离 $d_{gc}$ 是该角度所对应的弧长：\n$$ d_{gc} = R \\gamma = R \\arccos(\\text{clamp}(\\mathbf{u}_1 \\cdot \\mathbf{u}_2, -1, 1)) $$\n地球半径给定为 $R = 6,371,000\\,\\text{m}$。\n\n### 2. K维树（KD-Tree）实现\n\n#### 2.1. 树的构建\n\nKD树是一种二叉空间分割数据结构，用于组织k维空间中的点。在这里，我们使用1.1节中推导的笛卡尔单位向量，在 $\\mathbb{R}^3$（$k=3$）中构建它。\n\n树的构建是递归的：\n1.  **基本情况**：如果点列表为空，则返回 `None`。\n2.  **选择坐标轴**：根据递归深度确定分割轴，轮流选择 $x, y, z$。坐标轴索引由 `depth % 3` 给出。\n3.  **寻找中位数**：沿选定坐标轴找到点的中位数。一种计算上高效的方法是使用分区算法（如 `introselect`）在线性时间内找到中位数元素，这将点列表划分为两个大小大致相等的子列表。位于中位数位置的点成为当前节点。\n4.  **递归**：对于在分割轴上坐标值小于中位数的点集，递归构建左子树；对于坐标值大于或等于中位数的点集，递归构建右子树。\n\n这种中位数分割策略有助于创建平衡树，这对于高效搜索至关重要。对于 $N$ 个点，构建时间复杂度为 $O(N \\log N)$。\n\n#### 2.2. 最近邻搜索与剪枝\n\nNN搜索算法遍历KD树，以找到树中距离给定查询点最近的点。一个关键特性是能够剪除树的整个分支，从而避免穷举搜索。\n\n**剪枝准则**：剪枝规则依赖于 $\\mathbb{R}^3$ 中的大圆距离 $d_{gc}$ 和欧几里得弦长 $d_{chord}$ 之间的单调关系。对于两个单位向量 $\\mathbf{u}_1$ 和 $\\mathbf{u}_2$，它们的弦长平方为：\n$$ d_{chord}^2 = \\lVert \\mathbf{u}_1 - \\mathbf{u}_2 \\rVert^2 = (\\mathbf{u}_1 - \\mathbf{u}_2) \\cdot (\\mathbf{u}_1 - \\mathbf{u}_2) = \\lVert \\mathbf{u}_1 \\rVert^2 + \\lVert \\mathbf{u}_2 \\rVert^2 - 2(\\mathbf{u}_1 \\cdot \\mathbf{u}_2) $$\n$$ d_{chord}^2 = 1 + 1 - 2\\cos(\\gamma) = 2(1 - \\cos(\\gamma)) $$\n由于 $\\gamma = d_{gc}/R$，并且对于 $\\gamma \\in [0, \\pi]$，$\\sin(\\gamma/2)$（与 $d_{chord}$ 相关）和 $\\gamma$ 都是单调递增的，因此最小化弦长等同于最小化大圆距离。因此，搜索算法可以使用计算成本更低的弦长平方进行操作。\n\n**搜索算法**：搜索是一个递归过程，维护当前找到的最佳点及其到查询点的弦长平方 $d^2_{best}$。\n1.  从树的根节点开始。\n2.  在每个节点，如果当前节点比当前最佳点更近，则更新最佳点。计算弦长平方，如果它小于 $d^2_{best}$（或相等但原始点索引更小），则更新最佳猜测。\n3.  确定首先搜索哪个子树。比较查询点在节点分割轴上的坐标与节点的坐标。进入“更近”的子树（包含查询点的那个子树）。\n4.  从更近的子树返回后，对“更远”的子树执行剪枝检查。查询点到分割超平面的欧几里得距离的平方是 $(q_{axis} - n_{axis})^2$，其中 $q_{axis}$ 是查询点在分割轴上的坐标，$n_{axis}$ 是节点的坐标。如果这个距离大于当前最佳距离的平方，即 $(q_{axis} - n_{axis})^2 > d^2_{best}$，那么更远子树中的任何点都不可能比当前最佳点更近。整个更远的分支被剪枝。\n5.  如果未被剪枝，则递归搜索更远的子树。\n6.  当树被完全探索或剪枝后，过程终止。\n\n节点评估次数是算法计算查询点与树节点中存储的点之间距离的次数。\n\n**计算复杂度**：对于均匀分布的数据，在平衡的KD树中进行NN搜索的平均时间复杂度为 $O(\\log N)$。然而，对于位于低维流形（如此处三维空间中的二维球面）上的点，剪枝效果可能较差，最坏情况下的复杂度可能接近 $O(N)$。\n\n### 3. 最终算法总结\n\n1.  定义地球半径 $R = 6,371,000\\,\\text{m}$。\n2.  对每个测试用例：\n    a. 将所有输入的经纬度点（包括查询点）转换为三维笛卡尔单位向量。存储每个点的原始索引。\n    b. 使用递归的中位数分割方法，从三维点向量及其索引的列表中构建KD树。\n    c. 初始化节点访问计数器为 $0$。\n    d. 对查询点的向量执行最近邻搜索。搜索使用弦长平方进行比较，并采用上述剪枝规则。使用原始点索引来处理平局情况。每次计算距离时，节点访问计数器加一。\n    e. 搜索返回最近点的向量及其原始索引。\n    f. 使用点积公式计算查询向量与找到的最近邻向量之间的大圆距离：$d_{gc} = R \\arccos(\\text{clamp}(\\mathbf{q} \\cdot \\mathbf{p}_{best}, -1, 1))$。\n    g. 将距离四舍五入到最近的整数米。\n    h. 存储三元组 `[distance_m, index, nodes_visited]`。\n3.  格式化并打印所有测试用例的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Earth radius in meters as specified\nR_EARTH_M = 6371000\n\nclass Node:\n    \"\"\"A node in the KD-Tree.\"\"\"\n    def __init__(self, point_data=None, axis=None, left=None, right=None):\n        # point_data is a tuple: (3D point vector, original index)\n        self.point_data = point_data\n        self.axis = axis\n        self.left = left\n        self.right = right\n\nclass KDTree:\n    \"\"\"A K-Dimensional Tree for nearest neighbor search on a sphere.\"\"\"\n    def __init__(self, points_with_indices):\n        self.root = self._build_tree(points_with_indices, depth=0)\n        self.nodes_visited = 0\n\n    def _build_tree(self, points_with_indices, depth):\n        if not points_with_indices:\n            return None\n\n        k = 3  # 3 dimensions (x, y, z)\n        axis = depth % k\n        \n        # Sort points based on the current axis and find the median\n        # Using np.partition would be more efficient for large N, but sorting is clear\n        # points_with_indices.sort(key=lambda p: p[0][axis])\n        # median_idx = len(points_with_indices) // 2\n\n        # Using np.partition as it's O(n) vs O(n log n) for sort\n        points_array = np.array([p[0] for p in points_with_indices])\n        median_idx = len(points_with_indices) // 2\n        \n        # Partition the array of coordinates\n        partition_indices = np.argpartition(points_array[:, axis], median_idx)\n        \n        # Reorder the original list of tuples based on the partition\n        points_with_indices = [points_with_indices[i] for i in partition_indices]\n\n        node = Node(point_data=points_with_indices[median_idx], axis=axis)\n        node.left = self._build_tree(points_with_indices[:median_idx], depth + 1)\n        node.right = self._build_tree(points_with_indices[median_idx + 1:], depth + 1)\n\n        return node\n\n    def find_nearest(self, query_point):\n        self.nodes_visited = 0\n        if self.root is None:\n            return None, float('inf'), 0\n\n        best_point_data, best_sq_dist = self._search_recursive(self.root, query_point)\n        \n        # Final calculation of great-circle distance\n        query_vec = np.array(query_point)\n        best_vec = np.array(best_point_data[0])\n        dot_product = np.dot(query_vec, best_vec)\n        \n        # Clamp for numerical stability\n        dot_product = np.clip(dot_product, -1.0, 1.0)\n        \n        angle = np.arccos(dot_product)\n        distance = R_EARTH_M * angle\n        \n        return best_point_data, distance, self.nodes_visited\n\n    def _search_recursive(self, node, query_point):\n        # Initial best guess is the root itself\n        best_point_data = self.root.point_data\n        best_sq_dist = np.sum((np.array(query_point) - np.array(best_point_data[0]))**2)\n        \n        # Use a mutable object to pass best guess through recursion\n        best_info = {'point_data': best_point_data, 'sq_dist': best_sq_dist}\n        \n        self._search_helper(self.root, query_point, best_info)\n        \n        return best_info['point_data'], best_info['sq_dist']\n\n    def _search_helper(self, node, query_point, best_info):\n        if node is None:\n            return\n\n        self.nodes_visited += 1\n        \n        # Calculate squared Euclidean distance to current node's point\n        point_vec = np.array(node.point_data[0])\n        query_vec = np.array(query_point)\n        sq_dist = np.sum((point_vec - query_vec)**2)\n\n        # Update best if this node is closer (or equal with smaller index)\n        if sq_dist  best_info['sq_dist'] or \\\n           (sq_dist == best_info['sq_dist'] and node.point_data[1]  best_info['point_data'][1]):\n            best_info['sq_dist'] = sq_dist\n            best_info['point_data'] = node.point_data\n\n        axis = node.axis\n        diff = query_point[axis] - node.point_data[0][axis]\n\n        # Choose which subtree to visit first\n        if diff  0:\n            close_child, far_child = node.left, node.right\n        else:\n            close_child, far_child = node.right, node.left\n\n        # Recurse down the closer subtree\n        self._search_helper(close_child, query_point, best_info)\n\n        # Pruning check: if the hypersphere of the best distance crosses the splitting plane\n        if diff**2  best_info['sq_dist']:\n            self._search_helper(far_child, query_point, best_info)\n\n\ndef geo_to_cartesian(lat, lon):\n    \"\"\"Converts geodetic lat/lon (degrees) to 3D Cartesian unit vector.\"\"\"\n    lat_rad = np.radians(lat)\n    lon_rad = np.radians(lon)\n    x = np.cos(lat_rad) * np.cos(lon_rad)\n    y = np.cos(lat_rad) * np.sin(lon_rad)\n    z = np.sin(lat_rad)\n    return (x, y, z)\n\ndef solve():\n    test_cases = [\n        {\n            \"points\": [(51.5074, -0.1278), (48.8566, 2.3522), (40.7128, -74.0060), \n                       (35.6895, 139.6917), (-33.8688, 151.2093), (-33.9249, 18.4241), \n                       (-22.9068, -43.1729), (55.7558, 37.6173), (28.7041, 77.1025), \n                       (-1.2921, 36.8219)],\n            \"query\": (48.1351, 11.5820)\n        },\n        {\n            \"points\": [(10.0, 20.0), (-10.0, -20.0), (0.0, 0.0)],\n            \"query\": (0.0, 0.0)\n        },\n        {\n            \"points\": [(0.0, 0.0), (0.0, 180.0), (10.0, 90.0), (-10.0, -90.0)],\n            \"query\": (0.0, 179.999)\n        },\n        {\n            \"points\": [(89.9, 0.0), (89.9, 179.9), (89.9, -179.9), (0.0, 180.0)],\n            \"query\": (89.95, -179.5)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        points_geo = case[\"points\"]\n        query_geo = case[\"query\"]\n\n        # Convert points to Cartesian and store with original index\n        points_with_indices = [\n            (geo_to_cartesian(p[0], p[1]), i) for i, p in enumerate(points_geo)\n        ]\n        query_cartesian = geo_to_cartesian(query_geo[0], query_geo[1])\n\n        # Build tree and perform search\n        kdtree = KDTree(points_with_indices)\n        best_point_data, distance, nodes_visited = kdtree.find_nearest(query_cartesian)\n        \n        best_index = best_point_data[1]\n        distance_m = int(round(distance))\n        \n        results.append([distance_m, best_index, nodes_visited])\n\n    # Format output as a list of lists, without spaces\n    result_str = '[' + ','.join([f'[{r[0]},{r[1]},{r[2]}]' for r in results]) + ']'\n    print(result_str)\n\nsolve()\n```\n[[823180,1,10],[0,2,3],[111,1,4],[5558,2,4]]"
        }
    ]
}