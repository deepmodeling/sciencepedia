{
    "hands_on_practices": [
        {
            "introduction": "In spectral atmospheric models, atmospheric fields are decomposed into a sum of waves using a complex Fourier basis. This exercise provides fundamental practice in this representation by starting with a simple field composed of real sine and cosine functions . By deriving the complex Fourier coefficients, you will build a concrete understanding of how the amplitude and phase of physical waves are encoded within the magnitude and argument of these complex numbers, a critical skill for analyzing model data.",
            "id": "4044958",
            "problem": "Consider a zonally periodic scalar field along longitude, represented as a function $f(\\lambda)$ with $\\lambda \\in [0,2\\pi)$ in radians. In global spectral models used for numerical weather prediction and climate modeling, the longitudinal dependence of fields is expanded in complex Fourier modes while the latitudinal dependence is treated with spherical harmonics. The complex Fourier series of a $2\\pi$-periodic function is defined by\n$$\nf(\\lambda) = \\sum_{k\\in\\mathbb{Z}} \\hat{f}_{k}\\,\\exp(i k \\lambda),\n\\quad\n\\hat{f}_{k} = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} f(\\lambda)\\,\\exp(-i k \\lambda)\\,\\mathrm{d}\\lambda,\n$$\nwhere $i$ is the imaginary unit and the orthogonality of $\\exp(i k \\lambda)$ over $[0,2\\pi)$ underpins the spectral decomposition. Let\n$$\nf(\\lambda) = \\sin(3\\lambda) + \\frac{1}{2}\\cos(2\\lambda).\n$$\nStarting from the definitions above and using only well-established identities such as the Euler formulas $\\exp(i\\theta)=\\cos\\theta+i\\sin\\theta$, $\\cos\\theta=\\frac{1}{2}\\big(\\exp(i\\theta)+\\exp(-i\\theta)\\big)$, and $\\sin\\theta=\\frac{1}{2i}\\big(\\exp(i\\theta)-\\exp(-i\\theta)\\big)$, do the following:\n- Derive the nonzero complex Fourier coefficients $\\hat{f}_{k}$ of $f(\\lambda)$.\n- Reconstruct $f(\\lambda)$ from these $\\hat{f}_{k}$ to verify consistency.\n- Explain how the amplitudes and phases of the real trigonometric components are encoded in the complex coefficients for the nonzero zonal wavenumbers.\n\nExpress angles in radians. Report your final answer as the ordered row vector of the nonzero coefficients $(\\hat{f}_{-3},\\,\\hat{f}_{-2},\\,\\hat{f}_{2},\\,\\hat{f}_{3})$ using the $\\mathrm{pmatrix}$ environment. No rounding is required.",
            "solution": "The problem is to find the nonzero complex Fourier coefficients for a given scalar field, verify the result by reconstruction, and explain how the real wave properties are encoded in these coefficients. The given scalar field is $f(\\lambda) = \\sin(3\\lambda) + \\frac{1}{2}\\cos(2\\lambda)$, where $\\lambda \\in [0, 2\\pi)$ is the longitude in radians.\n\nThe analysis is based on the complex Fourier series representation of a $2\\pi$-periodic function:\n$$f(\\lambda) = \\sum_{k\\in\\mathbb{Z}} \\hat{f}_{k}\\,\\exp(i k \\lambda)$$\nwhere the coefficients $\\hat{f}_{k}$ are given by the projection integral:\n$$\\hat{f}_{k} = \\frac{1}{2\\pi}\\int_{0}^{2\\pi} f(\\lambda)\\,\\exp(-i k \\lambda)\\,\\mathrm{d}\\lambda$$\n\nThe first task is to find the nonzero coefficients $\\hat{f}_{k}$. Instead of direct integration, we can use the provided Euler identities to express $f(\\lambda)$ in terms of complex exponentials and then identify the coefficients by comparing the resulting expression with the definition of the Fourier series.\n\nThe relevant Euler identities are:\n$$\\cos\\theta = \\frac{1}{2}\\big(\\exp(i\\theta)+\\exp(-i\\theta)\\big)$$\n$$\\sin\\theta = \\frac{1}{2i}\\big(\\exp(i\\theta)-\\exp(-i\\theta)\\big) = -\\frac{i}{2}\\big(\\exp(i\\theta)-\\exp(-i\\theta)\\big)$$\nsince $\\frac{1}{i} = -i$.\n\nWe substitute these identities into the expression for $f(\\lambda)$:\n$$f(\\lambda) = \\left( -\\frac{i}{2}\\big(\\exp(i3\\lambda)-\\exp(-i3\\lambda)\\big) \\right) + \\frac{1}{2}\\left( \\frac{1}{2}\\big(\\exp(i2\\lambda)+\\exp(-i2\\lambda)\\big) \\right)$$\nDistributing the terms, we get:\n$$f(\\lambda) = -\\frac{i}{2}\\exp(i3\\lambda) + \\frac{i}{2}\\exp(-i3\\lambda) + \\frac{1}{4}\\exp(i2\\lambda) + \\frac{1}{4}\\exp(-i2\\lambda)$$\nTo match this with the Fourier series form $f(\\lambda) = \\sum_{k\\in\\mathbb{Z}} \\hat{f}_{k}\\,\\exp(i k \\lambda)$, we rearrange the terms in order of increasing zonal wavenumber $k$:\n$$f(\\lambda) = \\left(\\frac{i}{2}\\right)\\exp(i(-3)\\lambda) + \\left(\\frac{1}{4}\\right)\\exp(i(-2)\\lambda) + \\left(\\frac{1}{4}\\right)\\exp(i(2)\\lambda) + \\left(-\\frac{i}{2}\\right)\\exp(i(3)\\lambda)$$\nBy direct comparison of the coefficients of the $\\exp(ik\\lambda)$ terms, we can identify the nonzero Fourier coefficients:\n- For $k = -3$: $\\hat{f}_{-3} = \\frac{i}{2}$\n- For $k = -2$: $\\hat{f}_{-2} = \\frac{1}{4}$\n- For $k = 2$: $\\hat{f}_{2} = \\frac{1}{4}$\n- For $k = 3$: $\\hat{f}_{3} = -\\frac{i}{2}$\nAll other coefficients $\\hat{f}_{k}$ for $k \\notin \\{-3, -2, 2, 3\\}$ are zero. Note that for this real-valued function $f(\\lambda)$, the coefficients satisfy the property $\\hat{f}_{-k} = \\overline{\\hat{f}_{k}}$ (the complex conjugate), as expected. For $k=2$, $\\hat{f}_{-2} = \\frac{1}{4}$ and $\\overline{\\hat{f}_2} = \\overline{\\frac{1}{4}} = \\frac{1}{4}$. For $k=3$, $\\hat{f}_{-3} = \\frac{i}{2}$ and $\\overline{\\hat{f}_3} = \\overline{-\\frac{i}{2}} = \\frac{i}{2}$.\n\nThe second task is to reconstruct $f(\\lambda)$ from these coefficients to verify consistency. We sum the components corresponding to the nonzero coefficients:\n$$f(\\lambda) = \\hat{f}_{-3}\\exp(-i3\\lambda) + \\hat{f}_{-2}\\exp(-i2\\lambda) + \\hat{f}_{2}\\exp(i2\\lambda) + \\hat{f}_{3}\\exp(i3\\lambda)$$\nSubstituting the values we found:\n$$f(\\lambda) = \\frac{i}{2}\\exp(-i3\\lambda) + \\frac{1}{4}\\exp(-i2\\lambda) + \\frac{1}{4}\\exp(i2\\lambda) - \\frac{i}{2}\\exp(i3\\lambda)$$\nWe group the terms with the same magnitude of wavenumber $|k|$:\n$$f(\\lambda) = \\left( \\frac{1}{4}\\exp(i2\\lambda) + \\frac{1}{4}\\exp(-i2\\lambda) \\right) + \\left( -\\frac{i}{2}\\exp(i3\\lambda) + \\frac{i}{2}\\exp(-i3\\lambda) \\right)$$\nFactoring out common terms:\n$$f(\\lambda) = \\frac{1}{2} \\left( \\frac{\\exp(i2\\lambda) + \\exp(-i2\\lambda)}{2} \\right) + \\left( \\frac{\\exp(i3\\lambda) - \\exp(-i3\\lambda)}{2i} \\right)$$\nUsing the Euler identities in reverse, we recognize the expressions for $\\cos(2\\lambda)$ and $\\sin(3\\lambda)$:\n$$f(\\lambda) = \\frac{1}{2}\\cos(2\\lambda) + \\sin(3\\lambda)$$\nThis is identical to the original function, confirming the correctness of the derived coefficients.\n\nThe third task is to explain how the amplitudes and phases of the real trigonometric components are encoded in the complex coefficients. Consider a general real wave component for a specific positive wavenumber $k > 0$, written as $A_k\\cos(k\\lambda) + B_k\\sin(k\\lambda)$. Using Euler's identities, this component can be expressed as:\n$$A_k \\frac{\\exp(ik\\lambda)+\\exp(-ik\\lambda)}{2} + B_k \\frac{\\exp(ik\\lambda)-\\exp(-ik\\lambda)}{2i}$$\n$$ = \\frac{A_k}{2}(\\exp(ik\\lambda)+\\exp(-ik\\lambda)) - \\frac{iB_k}{2}(\\exp(ik\\lambda)-\\exp(-ik\\lambda))$$\nGrouping terms by $\\exp(ik\\lambda)$ and $\\exp(-ik\\lambda)$:\n$$ = \\left(\\frac{A_k - iB_k}{2}\\right)\\exp(ik\\lambda) + \\left(\\frac{A_k + iB_k}{2}\\right)\\exp(-ik\\lambda)$$\nBy comparison with the Fourier series terms $\\hat{f}_{k}\\exp(ik\\lambda) + \\hat{f}_{-k}\\exp(-ik\\lambda)$, we find:\n$$\\hat{f}_{k} = \\frac{A_k - iB_k}{2} \\quad \\text{and} \\quad \\hat{f}_{-k} = \\frac{A_k + iB_k}{2} = \\overline{\\hat{f}_{k}}$$\nThe amplitude $C_k$ of the real wave component $C_k\\cos(k\\lambda - \\phi_k) = A_k\\cos(k\\lambda) + B_k\\sin(k\\lambda)$ is $C_k = \\sqrt{A_k^2 + B_k^2}$. The magnitude of the complex coefficient $\\hat{f}_k$ is:\n$$|\\hat{f}_{k}| = \\left|\\frac{A_k - iB_k}{2}\\right| = \\frac{1}{2}\\sqrt{A_k^2 + (-B_k)^2} = \\frac{1}{2}\\sqrt{A_k^2 + B_k^2} = \\frac{C_k}{2}$$\nThus, the amplitude of the real wave is twice the magnitude of the complex Fourier coefficient for the positive wavenumber: $C_k = 2|\\hat{f}_{k}|$.\n\nThe phase $\\phi_k$ is given by $\\phi_k = \\arctan(B_k/A_k)$. The argument (phase) of the complex coefficient $\\hat{f}_k$ is:\n$$\\arg(\\hat{f}_{k}) = \\arg\\left(\\frac{A_k}{2} - i\\frac{B_k}{2}\\right) = \\arctan\\left(\\frac{-B_k/2}{A_k/2}\\right) = \\arctan\\left(-\\frac{B_k}{A_k}\\right) = -\\phi_k$$\nThus, the phase of the real wave is the negative of the argument of the complex Fourier coefficient: $\\phi_k = -\\arg(\\hat{f}_{k})$.\n\nApplying this to our problem:\n- For wavenumber $k=2$, the real component is $\\frac{1}{2}\\cos(2\\lambda)$. Here, $A_2 = \\frac{1}{2}$ and $B_2=0$. The amplitude is $C_2=\\frac{1}{2}$ and the phase is $\\phi_2=0$. The complex coefficient is $\\hat{f}_{2} = \\frac{1}{4}$.\n  - Amplitude check: $2|\\hat{f}_{2}| = 2\\left|\\frac{1}{4}\\right| = \\frac{1}{2} = C_2$.\n  - Phase check: $-\\arg(\\hat{f}_{2}) = -\\arg\\left(\\frac{1}{4}\\right) = -0 = 0 = \\phi_2$.\n- For wavenumber $k=3$, the real component is $\\sin(3\\lambda)$. Here, $A_3 = 0$ and $B_3=1$. This can be written as $1 \\cdot \\cos(3\\lambda - \\pi/2)$. The amplitude is $C_3=1$ and the phase is $\\phi_3=\\pi/2$. The complex coefficient is $\\hat{f}_{3} = -\\frac{i}{2}$.\n  - Amplitude check: $2|\\hat{f}_{3}| = 2\\left|-\\frac{i}{2}\\right| = 2 \\cdot \\frac{1}{2} = 1 = C_3$.\n  - Phase check: $-\\arg(\\hat{f}_{3}) = -\\arg\\left(-\\frac{i}{2}\\right) = -(-\\pi/2) = \\pi/2 = \\phi_3$.\n\nThe analysis confirms that for a positive wavenumber $k$, the amplitude and phase of the corresponding real wave are encoded in the magnitude and argument of the single complex coefficient $\\hat{f}_k$. The coefficient $\\hat{f}_{-k}$ is redundant for a real signal as it is just the complex conjugate of $\\hat{f}_k$.\n\nThe final answer is the ordered row vector of the nonzero coefficients $(\\hat{f}_{-3},\\,\\hat{f}_{-2},\\,\\hat{f}_{2},\\,\\hat{f}_{3})$.\n- $\\hat{f}_{-3} = \\frac{i}{2}$\n- $\\hat{f}_{-2} = \\frac{1}{4}$\n- $\\hat{f}_{2} = \\frac{1}{4}$\n- $\\hat{f}_{3} = -\\frac{i}{2}$",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{i}{2} & \\frac{1}{4} & \\frac{1}{4} & -\\frac{i}{2} \\end{pmatrix}}$$"
        },
        {
            "introduction": "While the Fourier series provides a powerful theoretical framework, numerical models operate on discrete grids, which introduces important practical considerations. This practice problem focuses on the phenomenon of aliasing, where waves with frequencies higher than the grid can resolve are incorrectly represented as lower-frequency waves . By computing the Discrete Fourier Transform (DFT) of an undersampled signal, you will see firsthand how aliasing manifests in the spectral domain and learn to identify which wavenumbers are trustworthy.",
            "id": "4044967",
            "problem": "Consider a zonally periodic scalar field on a sphere, representative of a prognostic variable in a spectral dynamical core for numerical weather prediction, restricted to a single latitude circle so that its longitudinal dependence can be analyzed using a Fourier basis. Let the longitude be denoted by $\\lambda \\in [0,2\\pi)$, and the field be\n$$\nf(\\lambda) = \\cos(5\\lambda) + \\cos(9\\lambda).\n$$\nAssume the field is sampled at $N=16$ equally spaced longitudes $\\lambda_n = \\frac{2\\pi n}{N}$ for $n=0,1,\\dots,15$. Define the Discrete Fourier Transform (DFT) by\n$$\nX_k = \\sum_{n=0}^{N-1} f(\\lambda_n)\\,\\exp\\!\\left(-i\\,\\frac{2\\pi k n}{N}\\right), \\quad k=0,1,\\dots,N-1,\n$$\nwith the inverse given by\n$$\nf(\\lambda_n) = \\frac{1}{N}\\sum_{k=0}^{N-1} X_k\\,\\exp\\!\\left(i\\,\\frac{2\\pi k n}{N}\\right).\n$$\nStarting from the fundamental definition of the Fourier basis on the circle and the sampling operation, derive the nonzero DFT coefficients $X_k$ of $f(\\lambda)$ at the specified sampling points. Then, using the definition of the Nyquist wavenumber $k_{\\mathrm{Nyq}} = \\frac{N}{2}$ and the discrete sampling symmetry on the circle, explain which continuous wavenumber contributions are aliased when interpreting modes with $k>k_{\\mathrm{Nyq}}$ on the discrete grid, and identify the corresponding aliased resolved wavenumbers.\n\nExpress your final spectrum as a single row matrix containing $X_0, X_1, \\dots, X_{15}$ (in that order). No rounding is required.",
            "solution": "The problem requires the calculation of the Discrete Fourier Transform (DFT) coefficients for a given function sampled on a discrete grid, and an explanation of the aliasing phenomenon involved.\n\nThe scalar field is given by\n$$\nf(\\lambda) = \\cos(5\\lambda) + \\cos(9\\lambda).\n$$\nUsing Euler's formula, $\\cos(\\theta) = \\frac{1}{2} (\\exp(i\\theta) + \\exp(-i\\theta))$, we can express the function as a sum of complex exponentials, which represent traveling waves:\n$$\nf(\\lambda) = \\frac{1}{2}\\left(\\exp(i5\\lambda) + \\exp(-i5\\lambda)\\right) + \\frac{1}{2}\\left(\\exp(i9\\lambda) + \\exp(-i9\\lambda)\\right).\n$$\nThis function is a superposition of waves with continuous wavenumbers $m = \\pm 5$ and $m = \\pm 9$.\n\nThe field is sampled at $N=16$ equally spaced points $\\lambda_n = \\frac{2\\pi n}{N}$ for $n=0, 1, \\dots, N-1$. The Nyquist sampling theorem states that to avoid aliasing, the magnitude of the highest wavenumber present in the signal, $m_{\\max}$, must be less than the Nyquist wavenumber, $k_{\\mathrm{Nyq}}$. The Nyquist wavenumber is defined as $k_{\\mathrm{Nyq}} = \\frac{N}{2}$. For this problem,\n$$\nk_{\\mathrm{Nyq}} = \\frac{16}{2} = 8.\n$$\nThe wavenumbers present in $f(\\lambda)$ are $m=\\pm 5$ and $m=\\pm 9$.\nThe wavenumber contribution from $\\cos(5\\lambda)$ has $|m|=5$. Since $|5| < k_{\\mathrm{Nyq}}$, this wave is resolved by the grid.\nThe wavenumber contribution from $\\cos(9\\lambda)$ has $|m|=9$. Since $|9| > k_{\\mathrm{Nyq}}$, this wave is undersampled and will be aliased.\n\nWe must determine how the wavenumber $m=9$ is represented on the discrete grid. A continuous wave $\\exp(im\\lambda)$ evaluated at the grid points $\\lambda_n$ is indistinguishable from a wave $\\exp(im'\\lambda)$ if $m' = m + jN$ for any integer $j$. This is because:\n$$\n\\exp(im'\\lambda_n) = \\exp(i(m+jN)\\lambda_n) = \\exp\\left(i(m+jN)\\frac{2\\pi n}{N}\\right) = \\exp\\left(i\\frac{2\\pi m n}{N}\\right) \\exp\\left(i\\frac{2\\pi j N n}{N}\\right) = \\exp(im\\lambda_n) \\exp(i2\\pi jn).\n$$\nSince $j$ and $n$ are integers, $\\exp(i2\\pi jn) = 1$. Thus, on the discrete grid, the continuous wavenumber $m=9$ is aliased to a resolved wavenumber $m'$ in the range $[-k_{\\mathrm{Nyq}}, k_{\\mathrm{Nyq}}]$. We find $m'$ by choosing $j=-1$:\n$$\nm' = 9 + (-1)N = 9 - 16 = -7.\n$$\nSimilarly, the continuous wavenumber $m=-9$ is aliased by choosing $j=1$:\n$$\nm' = -9 + (1)N = -9 + 16 = 7.\n$$\nTherefore, the samples of the $\\cos(9\\lambda)$ term are identical to the samples of the $\\cos(7\\lambda)$ term:\n$$\n\\cos(9\\lambda_n) = \\cos\\left(9\\frac{2\\pi n}{16}\\right) = \\cos\\left((16-7)\\frac{2\\pi n}{16}\\right) = \\cos\\left(2\\pi n - 7\\frac{2\\pi n}{16}\\right) = \\cos\\left(-7\\frac{2\\pi n}{16}\\right) = \\cos\\left(7\\frac{2\\pi n}{16}\\right) = \\cos(7\\lambda_n).\n$$\nThe continuous wave contribution from $\\cos(9\\lambda)$ is aliased to appear as $\\cos(7\\lambda)$ on the discrete grid. The undersampled wave masquerades as a lower-frequency wave.\n\nConsequently, the function evaluated at the sampling points, $f(\\lambda_n)$, is effectively\n$$\nf(\\lambda_n) = \\cos(5\\lambda_n) + \\cos(7\\lambda_n).\n$$\nWe now compute the DFT coefficients $X_k$ for this aliased function. First, we express $f(\\lambda_n)$ in complex exponential form:\n$$\nf(\\lambda_n) = \\frac{1}{2}\\left(\\exp(i5\\lambda_n) + \\exp(-i5\\lambda_n)\\right) + \\frac{1}{2}\\left(\\exp(i7\\lambda_n) + \\exp(-i7\\lambda_n)\\right).\n$$\nSubstitute $\\lambda_n = \\frac{2\\pi n}{N}$:\n$$\nf(\\lambda_n) = \\frac{1}{2}\\exp\\left(i\\frac{2\\pi(5)n}{N}\\right) + \\frac{1}{2}\\exp\\left(i\\frac{2\\pi(-5)n}{N}\\right) + \\frac{1}{2}\\exp\\left(i\\frac{2\\pi(7)n}{N}\\right) + \\frac{1}{2}\\exp\\left(i\\frac{2\\pi(-7)n}{N}\\right).\n$$\nThe DFT is defined as $X_k = \\sum_{n=0}^{N-1} f(\\lambda_n)\\,\\exp\\left(-i\\,\\frac{2\\pi k n}{N}\\right)$. A key property of the DFT is the orthogonality of the basis functions:\n$$\n\\sum_{n=0}^{N-1} \\exp\\left(i\\frac{2\\pi m n}{N}\\right) \\exp\\left(-i\\frac{2\\pi k n}{N}\\right) = \\sum_{n=0}^{N-1} \\exp\\left(i\\frac{2\\pi(m-k)n}{N}\\right) = N \\delta_{k, m \\pmod N}.\n$$\nThis means that the DFT of a single complex exponential $\\exp\\left(i\\frac{2\\pi m n}{N}\\right)$ is non-zero only at the discrete wavenumber $k$ which satisfies $k = m \\pmod N$. When it is non-zero, its value is $N$.\n\nApplying this to each term in our expression for $f(\\lambda_n)$:\n1. For the term $\\frac{1}{2}\\exp\\left(i\\frac{2\\pi(5)n}{N}\\right)$, the continuous wavenumber is $m=5$. The DFT is non-zero for $k=5 \\pmod{16}$, which is $k=5$. The coefficient is $X_5 = \\frac{1}{2}N = \\frac{16}{2} = 8$.\n2. For the term $\\frac{1}{2}\\exp\\left(i\\frac{2\\pi(-5)n}{N}\\right)$, the continuous wavenumber is $m=-5$. The DFT is non-zero for $k=-5 \\pmod{16}$, which is $k=11$. The coefficient is $X_{11} = \\frac{1}{2}N = \\frac{16}{2} = 8$.\n3. For the term $\\frac{1}{2}\\exp\\left(i\\frac{2\\pi(7)n}{N}\\right)$, the continuous wavenumber is $m=7$. The DFT is non-zero for $k=7 \\pmod{16}$, which is $k=7$. The coefficient is $X_7 = \\frac{1}{2}N = \\frac{16}{2} = 8$.\n4. For the term $\\frac{1}{2}\\exp\\left(i\\frac{2\\pi(-7)n}{N}\\right)$, the continuous wavenumber is $m=-7$. The DFT is non-zero for $k=-7 \\pmod{16}$, which is $k=9$. The coefficient is $X_9 = \\frac{1}{2}N = \\frac{16}{2} = 8$.\n\nAll other coefficients $X_k$ for $k \\in \\{0, 1, \\dots, 15\\}$ are zero. The function has no mean component, so $X_0=0$.\n\nThe resulting spectrum is a vector of $16$ coefficients, with non-zero values at $k=5, 7, 9, 11$.\n$X_0 = 0, X_1 = 0, X_2 = 0, X_3 = 0, X_4 = 0, X_5 = 8, X_6 = 0, X_7 = 8, X_8 = 0, X_9 = 8, X_{10} = 0, X_{11} = 8, X_{12} = 0, X_{13} = 0, X_{14} = 0, X_{15} = 0$.\n\nIn summary, the discrete mode $k=9$ (which is greater than $k_{\\mathrm{Nyq}}=8$) is the aliased representation of the continuous contribution from wavenumber $m=9$, which on the grid is interpreted as its alias $m'=-7$. Symmetrically, the discrete mode $k=7$ represents the contribution from $m=-9$, which is aliased to $m'=7$. The discrete modes $k=5$ and $k=11$ correctly represent the resolved continuous wavenumbers $m=5$ and $m=-5$, respectively.\nThe final spectrum represents the aliased function $\\cos(5\\lambda) + \\cos(7\\lambda)$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 & 0 & 0 & 0 & 0 & 8 & 0 & 8 & 0 & 8 & 0 & 8 & 0 & 0 & 0 & 0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "This task involves implementing a spectral low-pass filter, a common tool in numerical modeling for removing high-frequency noise or representing physical diffusion, and leverages Parseval's theorem to quantify the energy of the signal. This coding-based exercise bridges theory and application, requiring you to manipulate spectral coefficients for both Fourier and spherical harmonic bases to modify a field and analyze the energetic consequences . Successfully completing this task demonstrates proficiency in the practical mechanics of spectral transforms and filtering, which are essential operations in model development and diagnostics.",
            "id": "4044947",
            "problem": "You are given the task to design and implement a program that applies a spectral low-pass filter to a signal represented in spectral space, computes the filtered physical-space field, and quantifies the energy removed by the filter. The context is numerical weather prediction and climate modeling, focusing on Fourier and spherical harmonic bases. All angles must be expressed in radians. All wavenumbers must be expressed in radians per unit length. Energies must be expressed as dimensionless squared amplitude averages.\n\nYou must use the following fundamental basis to justify and guide your design:\n- The discrete Fourier transform (DFT) and its inverse on a one-dimensional periodic domain of length $L$ sampled by $N$ equispaced points. You may assume periodic boundary conditions. You must use the standard definition of the DFT as implemented in scientific computing libraries, and the corresponding Parseval relation connecting physical-space and spectral-space energy.\n- The spherical harmonics $Y_{\\ell}^{m}(\\theta,\\phi)$ on the unit sphere, where $\\theta \\in [0,\\pi]$ is colatitude and $\\phi \\in [0,2\\pi)$ is longitude. You may assume the orthonormality of spherical harmonics with respect to the surface measure on the unit sphere, and the standard physics normalization in which $\\int_{S^2} \\left|Y_{\\ell}^{m}(\\theta,\\phi)\\right|^2 \\,\\mathrm{d}\\Omega = 1$ for each $(\\ell,m)$.\n\nThe spectral low-pass filter is defined by a cutoff as follows:\n- Fourier case: For a spectrum $\\hat{f}_k$ with discrete wavenumbers $k$, retain only the components satisfying $\\lvert k \\rvert \\leq k_c$, and set all others to zero.\n- Spherical harmonic case: For coefficients $a_{\\ell m}$, retain only the components satisfying $\\ell \\leq \\ell_c$, and set all others to zero.\n\nDefine the energy of a field as follows:\n- Fourier case: For a discrete physical-space field $f_n$ ($n=0,\\dots,N-1$), the energy is the average squared amplitude $E = \\frac{1}{N}\\sum_{n=0}^{N-1}\\lvert f_n\\rvert^2$. Using the discrete Fourier transform convention, the corresponding spectral energy is $E = \\frac{1}{N^2}\\sum_{k}\\lvert \\hat{f}_k\\rvert^2$.\n- Spherical harmonic case: For a spherical-harmonic expansion $f(\\theta,\\phi)=\\sum_{\\ell=0}^{\\infty}\\sum_{m=-\\ell}^{\\ell}a_{\\ell m}Y_{\\ell}^{m}(\\theta,\\phi)$ under the stated normalization, the total energy is $E = \\sum_{\\ell=0}^{\\infty}\\sum_{m=-\\ell}^{\\ell}\\lvert a_{\\ell m}\\rvert^2$.\n\nYour program must implement both bases and carry out the following tasks for each test case:\n- Construct the spectrum, apply the low-pass filter defined by the given cutoff, compute the filtered physical-space field via the appropriate inverse transform or evaluation, and quantify the energy removed by the filter as a nonnegative float. In the Fourier case, use the spectral energy definition above so that the energy removed is $\\frac{1}{N^2}\\sum_{k:\\lvert k\\rvert>k_c}\\lvert \\hat{f}_k\\rvert^2$. In the spherical harmonic case, use $\\sum_{\\ell>\\ell_c}\\sum_{m=-\\ell}^{\\ell}\\lvert a_{\\ell m}\\rvert^2$.\n\nTest suite:\n- Fourier test 1 (happy path): Domain length $L=2\\pi$, number of points $N=256$, physical-space field $f(x)=\\sin(5x)+0.5\\sin(20x)+0.2\\cos(40x)$ sampled on the grid $x_j=j\\Delta x$ with $\\Delta x=L/N$, and cutoff $k_c=15$.\n- Fourier test 2 (intermediate cutoff): Same $L$, $N$, and $f(x)$ as above, with cutoff $k_c=35$.\n- Fourier test 3 (boundary condition: zero cutoff): Same $L$, $N$, and $f(x)$, with cutoff $k_c=0$.\n- Fourier test 4 (boundary condition: very large cutoff): Same $L$, $N$, and $f(x)$, with cutoff $k_c=100$.\n- Spherical harmonic test 5 (coverage of spherical case): On the unit sphere, consider the spherical-harmonic coefficients defined by $a_{2,1}=1.0$, $a_{2,-1}=(-1)^1 a_{2,1}$, $a_{5,0}=0.6$, $a_{8,3}=0.4$, and $a_{8,-3}=(-1)^3 a_{8,3}$, with all other $a_{\\ell m}$ equal to zero. Use cutoff $\\ell_c=4$. Compute the filtered physical-space field on a uniform sampling grid in angles $(\\theta,\\phi)$ with $\\theta$ sampled at $M_\\theta=45$ points in $[0,\\pi]$ and $\\phi$ sampled at $M_\\phi=90$ points in $[0,2\\pi)$, and quantify the energy removed by summing the squared magnitudes of the removed coefficients.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[result1,result2,result3,result4,result5]\"), where each result is the energy removed by the filter for the corresponding test case, expressed as a float.\n\nAngle unit: radians.\nWavenumber unit: radians per unit length.\nEnergy unit: dimensionless squared amplitude average.\n\nYour solution must not read input; it must compute the quantities for the given test suite internally and print the results in the specified format.",
            "solution": "The problem requires the design and implementation of a spectral low-pass filter for signals represented in both a one-dimensional Fourier basis and a two-dimensional spherical harmonic basis. The primary tasks are to apply the filter, reconstruct the filtered field, and quantify the energy removed. This process is fundamental in numerical modeling, where it is used for purposes such as removing high-frequency noise or representing physical diffusion processes. The solution will be developed based on the specified principles of discrete Fourier analysis and spherical harmonic expansions.\n\nFirst, we address the Fourier basis case on a one-dimensional periodic domain of length $L$. A continuous physical-space function $f(x)$ is represented by its discrete samples $f_n = f(x_n)$ at $N$ equispaced points $x_n = n(L/N)$ for $n=0, 1, \\dots, N-1$.\n\nThe discrete Fourier transform (DFT) converts this physical-space representation into a spectral-space representation, $\\hat{f}_k$. The DFT and its inverse are defined as:\n$$ \\hat{f}_k = \\sum_{n=0}^{N-1} f_n e^{-2\\pi i kn/N} $$\n$$ f_n = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{f}_k e^{2\\pi i kn/N} $$\nThese are the standard definitions used in libraries like NumPy. The index $k$ corresponds to a physical wavenumber. For a domain of length $L$ and sample spacing $\\Delta x = L/N$, the physical wavenumbers $k_{phys}$ (in radians per unit length) are given by:\n$$ k_{phys} = \\frac{2\\pi m}{L} $$\nwhere $m$ are the DFT frequency indices, which for an $N$-point transform range from $-N/2+1$ to $N/2$ (or a similar range, handled by functions like `numpy.fft.fftfreq`).\n\nThe problem defines the energy of the field. In physical space, it is the mean squared amplitude: $E_{phys} = \\frac{1}{N}\\sum_{n=0}^{N-1}\\lvert f_n\\rvert^2$. In spectral space, it is given as $E_{spec} = \\frac{1}{N^2}\\sum_{k}\\lvert \\hat{f}_k\\rvert^2$. The consistency between these definitions is guaranteed by Parseval's theorem for the DFT, which states $\\sum_{n=0}^{N-1}\\lvert f_n\\rvert^2 = \\frac{1}{N}\\sum_{k=0}^{N-1}\\lvert \\hat{f}_k\\rvert^2$. Dividing by $N$ confirms that $E_{phys} = E_{spec}$.\n\nThe low-pass filter is a simple truncation in spectral space. Given a cutoff wavenumber $k_c$, the filtered spectrum $\\hat{f}'_k$ is obtained by setting to zero all coefficients $\\hat{f}_k$ for which the corresponding physical wavenumber $|k_{phys}|$ exceeds $k_c$:\n$$ \\hat{f}'_k = \\begin{cases} \\hat{f}_k & \\text{if } |k_{phys}| \\leq k_c \\\\ 0 & \\text{if } |k_{phys}| > k_c \\end{cases} $$\nThe energy removed by this filter is the sum of the energies of the discarded components:\n$$ E_{removed} = \\frac{1}{N^2} \\sum_{k \\text{ s.t. } |k_{phys}| > k_c} \\lvert \\hat{f}_k \\rvert^2 $$\nThe filtered physical field $f'_n$ is recovered by applying the inverse DFT to the filtered spectrum $\\hat{f}'_k$.\n\nFor the test cases, we first generate the discrete signal $f_n$ by sampling the given continuous function $f(x)=\\sin(5x)+0.5\\sin(20x)+0.2\\cos(40x)$ on the grid. We then compute its DFT $\\hat{f}_k$. The corresponding physical wavenumbers are computed. For each test case, we identify which spectral components have wavenumbers $|k_{phys}| > k_c$ and sum their energies according to the formula above.\n\nNext, we address the spherical harmonic basis case. A scalar field $f(\\theta, \\phi)$ on the surface of a sphere is expanded as:\n$$ f(\\theta, \\phi) = \\sum_{\\ell=0}^{\\infty} \\sum_{m=-\\ell}^{\\ell} a_{\\ell m} Y_{\\ell}^{m}(\\theta, \\phi) $$\nwhere $Y_{\\ell}^{m}$ are the spherical harmonics, $\\ell$ is the total wavenumber, and $m$ is the zonal wavenumber. The coefficients $a_{\\ell m}$ are the spectral representation of the field.\n\nThe problem specifies the physics normalization, under which the spherical harmonics are orthonormal: $\\int_{S^2} Y_{\\ell'}^{m'*} Y_{\\ell}^{m} \\,\\mathrm{d}\\Omega = \\delta_{\\ell\\ell'}\\delta_{mm'}$. Consequently, the total energy of the field is simply the sum of the squared magnitudes of the spectral coefficients:\n$$ E = \\sum_{\\ell=0}^{\\infty} \\sum_{m=-\\ell}^{\\ell} |a_{\\ell m}|^2 $$\nThe low-pass filter in this context is a truncation based on the total wavenumber $\\ell$. Given a cutoff $\\ell_c$, all coefficients $a_{\\ell m}$ with $\\ell > \\ell_c$ are set to zero. The filtered field $f'_{filtered}$ is given by:\n$$ f'_{filtered}(\\theta, \\phi) = \\sum_{\\ell=0}^{\\ell_c} \\sum_{m=-\\ell}^{\\ell} a_{\\ell m} Y_{\\ell}^{m}(\\theta, \\phi) $$\nThe energy removed by the filter is the energy of the discarded components:\n$$ E_{removed} = \\sum_{\\ell=\\ell_c+1}^{\\infty} \\sum_{m=-\\ell}^{\\ell} |a_{\\ell m}|^2 $$\nFor the specific test case, the spectral coefficients $a_{\\ell m}$ are given directly. We simply need to identify which of these coefficients have a total wavenumber $\\ell$ greater than the cutoff $\\ell_c=4$ and sum their squared magnitudes to find the removed energy. The filtered physical-space field is computed by summing the contributions from the retained coefficients, evaluated on the specified $(\\theta, \\phi)$ grid using the `scipy.special.sph_harm` function.\n\nThe overall implementation will consist of two principal functions, one for each basis, that execute these steps. A main driver function will iterate through the test suite, call the appropriate function, collect the results, and print them in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import sph_harm\n\ndef fourier_filter_task(L, N, f_expr, k_c):\n    \"\"\"\n    Applies a spectral low-pass filter to a 1D signal and computes removed energy.\n    \n    Args:\n        L (float): Domain length.\n        N (int): Number of sample points.\n        f_expr (callable): A function generating the physical-space signal.\n        k_c (float): Cutoff wavenumber in radians per unit length.\n        \n    Returns:\n        float: The energy removed by the filter.\n    \"\"\"\n    # 1. Generate the discrete signal in physical space\n    delta_x = L / N\n    x_grid = np.arange(N) * delta_x\n    f_n = f_expr(x_grid)\n\n    # 2. Transform to spectral space using Discrete Fourier Transform\n    f_hat_k = np.fft.fft(f_n)\n\n    # 3. Determine the physical wavenumbers corresponding to the DFT coefficients\n    # The output of fftfreq is in cycles/unit_of_sample_spacing.\n    # To get radians/unit_length, we multiply by 2*pi and divide by sample spacing.\n    # Effectively, using d=delta_x in fftfreq gives cycles/unit_length.\n    k_phys = 2 * np.pi * np.fft.fftfreq(N, d=delta_x)\n\n    # 4. Apply the filter and calculate the removed energy\n    removed_energy = 0.0\n    f_hat_k_filtered = np.copy(f_hat_k)\n    \n    for i in range(N):\n        if np.abs(k_phys[i]) > k_c:\n            # Accumulate the energy of the component to be removed\n            removed_energy += np.abs(f_hat_k[i])**2\n            # Set the filtered spectral coefficient to zero\n            f_hat_k_filtered[i] = 0.0\n\n    # 5. Compute the filtered physical-space field via inverse DFT\n    # This step is required by the problem statement but its result is not printed.\n    f_n_filtered = np.fft.ifft(f_hat_k_filtered)\n    \n    # 6. Normalize the removed energy according to the problem's definition\n    return removed_energy / (N**2)\n\n\ndef spherical_filter_task(coeffs, M_theta, M_phi, ell_c):\n    \"\"\"\n    Applies a spectral low-pass filter to a spherical harmonic spectrum.\n    \n    Args:\n        coeffs (dict): A dictionary of (l, m) -> value for non-zero coefficients.\n        M_theta (int): Number of grid points in colatitude.\n        M_phi (int): Number of grid points in longitude.\n        ell_c (int): Cutoff total wavenumber.\n        \n    Returns:\n        float: The energy removed by the filter.\n    \"\"\"\n    # 1. Partition coefficients and calculate removed energy\n    removed_energy = 0.0\n    retained_coeffs = {}\n    \n    for (l, m), value in coeffs.items():\n        if l > ell_c:\n            # Per problem definition, energy is sum of |a_lm|^2\n            removed_energy += np.abs(value)**2\n        else:\n            retained_coeffs[(l, m)] = value\n\n    # 2. Compute the filtered physical-space field on a grid\n    # This step is required by the problem statement but its result is not printed.\n    theta_grid_1d = np.linspace(0, np.pi, M_theta)\n    phi_grid_1d = np.linspace(0, 2 * np.pi, M_phi, endpoint=False)\n    phi_grid_2d, theta_grid_2d = np.meshgrid(phi_grid_1d, theta_grid_1d)\n    \n    f_filtered = np.zeros_like(phi_grid_2d, dtype=np.complex128)\n    \n    for (l, m), value in retained_coeffs.items():\n        # Scipy's sph_harm takes arguments: m, l, azimuth (phi), polar (theta)\n        f_filtered += value * sph_harm(m, l, phi_grid_2d, theta_grid_2d)\n\n    return removed_energy\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Common parameters for Fourier tests\n    fourier_params = {\n        'L': 2 * np.pi,\n        'N': 256,\n        'f_expr': lambda x: np.sin(5 * x) + 0.5 * np.sin(20 * x) + 0.2 * np.cos(40 * x),\n    }\n\n    # Definition of all test cases\n    test_cases = [\n        # Test 1: Fourier with k_c = 15\n        {'type': 'fourier', 'cutoff': 15.0, **fourier_params},\n        # Test 2: Fourier with k_c = 35\n        {'type': 'fourier', 'cutoff': 35.0, **fourier_params},\n        # Test 3: Fourier with k_c = 0\n        {'type': 'fourier', 'cutoff': 0.0, **fourier_params},\n        # Test 4: Fourier with k_c = 100\n        {'type': 'fourier', 'cutoff': 100.0, **fourier_params},\n        # Test 5: Spherical harmonics\n        {\n            'type': 'spherical',\n            'coeffs': {(2, 1): 1.0, (2, -1): -1.0, (5, 0): 0.6, (8, 3): 0.4, (8, -3): -0.4},\n            'M_theta': 45,\n            'M_phi': 90,\n            'cutoff': 4\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'fourier':\n            result = fourier_filter_task(\n                L=case['L'],\n                N=case['N'],\n                f_expr=case['f_expr'],\n                k_c=case['cutoff']\n            )\n        elif case['type'] == 'spherical':\n            result = spherical_filter_task(\n                coeffs=case['coeffs'],\n                M_theta=case['M_theta'],\n                M_phi=case['M_phi'],\n                ell_c=case['cutoff']\n            )\n        results.append(result)\n\n    # Format and print the final output as specified.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}