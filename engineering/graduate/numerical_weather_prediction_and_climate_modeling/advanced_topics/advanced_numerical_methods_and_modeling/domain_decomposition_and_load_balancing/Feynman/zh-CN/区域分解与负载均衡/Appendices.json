{
    "hands_on_practices": [
        {
            "introduction": "在并行计算中，域分解是分配计算任务的第一步。这个练习将带你实践最常见的技术之一：二维笛卡尔分解。通过一个实际的大气模型网格设置，你将计算如何将一个大型全局网格划分给一组处理器，并探索即使在最理想化的情况下（均匀网格和计算成本），由于网格点数和处理器数之间的整除关系，也会不可避免地产生微小的负载差异。这项基本功对于理解并行效率的几何基础至关重要。",
            "id": "4032181",
            "problem": "一个用于数值天气预报的全球大气模型，被离散化到一个水平维度为 $N_x \\times N_y$ 的均匀经纬度网格上，其中 $N_x$ 是经度方向的格点数，$N_y$ 是纬度方向的格点数。该模型使用有限体积法推进预报变量，每个水平网格单元的计算成本是均匀的，因此总计算成本与分配给每个进程的网格单元数量成正比。\n\n为了对模型进行并行化，采用了二维笛卡尔消息传递接口 (MPI) 区域分解，将水平网格沿 $x$ 方向划分为 $p_x$ 个块，沿 $y$ 方向划分为 $p_y$ 个块，每个子域分配一个 MPI 进程。给定 $N_x = 1536$，$N_y = 768$，以及总共 $p = 128$ 个 MPI 进程。出于架构对称性的原因，项目经理要求在水平分解中 $p_x = p_y$。为在每个单元成本均匀的情况下保持负载均衡，划分必须遵循以下广泛使用的块分布规则：\n- 沿每个维度 $\\alpha \\in \\{x,y\\}$，令 $q_{\\alpha} = \\lfloor N_{\\alpha} / p_{\\alpha} \\rfloor$ 且 $r_{\\alpha} = N_{\\alpha} \\bmod p_{\\alpha}$。沿维度 $\\alpha$ 的前 $r_{\\alpha}$ 个块会分到 $q_{\\alpha} + 1$ 个单元，剩下的 $p_{\\alpha} - r_{\\alpha}$ 个块会分到 $q_{\\alpha}$ 个单元。\n\n从这些定义和约束出发，确定：\n1. 满足 $p_x = p_y$ 和 $p_x p_y \\le p$ 的最大的可行整数 $p_x$ 和 $p_y$。\n2. 基本块大小 $q_x$ 和 $q_y$，较大的块大小 $q_x + 1$ 和 $q_y + 1$，以及余数 $r_x$ 和 $r_y$。\n3. 四种局部大小类别中，每一类别的进程数量：$(q_x + 1) \\times (q_y + 1)$，$(q_x + 1) \\times q_y$，$q_x \\times (q_y + 1)$ 和 $q_x \\times q_y$。\n4. 由 $p_x = p_y$ 约束导致的未使用 MPI 进程（空闲进程）的数量。\n5. 在每个单元成本均匀的假设下，所有进程中最大局部工作负载与最小局部工作负载的比率。\n\n将你的最终答案表示为一个行矩阵，使用 LaTeX 的 $\\mathrm{pmatrix}$ 环境，各条目按以下顺序排列：$p_x$，$p_y$，$q_x$，$q_x + 1$，$q_y$，$q_y + 1$，$r_x r_y$，$r_x (p_y - r_y)$，$(p_x - r_x) r_y$，$(p_x - r_x)(p_y - r_y)$，$p - p_x p_y$ 以及工作负载比率 $\\frac{(q_x + 1)(q_y + 1)}{q_x q_y}$。无需四舍五入，条目是无单位的纯数字。",
            "solution": "问题陈述经评估是有效的。其科学基础在于并行计算和数值方法的原理，特别是针对基于网格的模型的区域分解。这个问题是适定的，提供了所有必要的数据和约束（$N_x = 1536$，$N_y = 768$，$p = 128$，$p_x = p_y$），从而可以得出一个唯一的、有意义的解。定义和目标陈述清晰，没有歧义或矛盾。\n\n我们将按顺序解决问题的五个部分来给出解答。\n\n1. 确定 $p_x$ 和 $p_y$\n\n问题要求将网格进行二维笛卡尔分解，划分为 $p_x \\times p_y$ 个子域。给定约束条件为 $p_x = p_y$ 以及使用的 MPI 进程总数 $p_x p_y$ 不得超过可用的进程总数 $p = 128$。\n将第一个约束代入第二个约束，得到：\n$$p_x \\cdot p_x \\le p$$\n$$p_x^2 \\le 128$$\n我们需要找到满足此不等式的最大整数 $p_x$。对两边取平方根：\n$$p_x \\le \\sqrt{128} = \\sqrt{64 \\times 2} = 8\\sqrt{2}$$\n使用近似值 $\\sqrt{2} \\approx 1.414$，我们发现 $p_x \\le 8 \\times 1.414 = 11.312$。满足此条件的最大整数是 $p_x = 11$。\n根据约束 $p_x = p_y$，我们有 $p_y = 11$。\n使用的进程总数为 $p_x p_y = 11 \\times 11 = 121$，这确实小于或等于可用的 $128$ 个进程。\n\n2. 计算块大小和余数\n\n问题定义了一个基于整数除法的块分布规则。对于每个维度 $\\alpha \\in \\{x,y\\}$，基本块大小为 $q_{\\alpha} = \\lfloor N_{\\alpha} / p_{\\alpha} \\rfloor$，余数为 $r_{\\alpha} = N_{\\alpha} \\bmod p_{\\alpha}$。\n\n对于 $x$ 方向（经度）：\n给定 $N_x = 1536$ 和 $p_x = 11$。\n$$q_x = \\lfloor \\frac{1536}{11} \\rfloor = \\lfloor 139.636... \\rfloor = 139$$\n$$r_x = 1536 \\bmod 11$$\n为求余数，我们使用除法算法：$1536 = 11 \\times 139 + r_x$。\n$11 \\times 139 = 1529$。\n$1536 = 1529 + 7$，所以 $r_x = 7$。\n$x$ 方向的块大小为基本大小 $q_x = 139$ 和较大尺寸 $q_x + 1 = 140$。\n\n对于 $y$ 方向（纬度）：\n给定 $N_y = 768$ 和 $p_y = 11$。\n$$q_y = \\lfloor \\frac{768}{11} \\rfloor = \\lfloor 69.818... \\rfloor = 69$$\n$$r_y = 768 \\bmod 11$$\n使用除法算法：$768 = 11 \\times 69 + r_y$。\n$11 \\times 69 = 759$。\n$768 = 759 + 9$，所以 $r_y = 9$。\n$y$ 方向的块大小为基本大小 $q_y = 69$ 和较大尺寸 $q_y + 1 = 70$。\n\n3. 按局部大小类别统计进程数量\n\n总的 $p_x \\times p_y$ 区域根据局部网格大小被划分为四组。\n- 在 $x$ 方向上，前 $r_x = 7$ 个块的大小为 $q_x+1$，剩下的 $p_x - r_x = 11 - 7 = 4$ 个块的大小为 $q_x$。\n- 在 $y$ 方向上，前 $r_y = 9$ 个块的大小为 $q_y+1$，剩下的 $p_y - r_y = 11 - 9 = 2$ 个块的大小为 $q_y$。\n\n四种大小类别中每一种的进程数量是：\n- 大小为 $(q_x + 1) \\times (q_y + 1)$ 的子域：这些对应于前 $r_x$ 列和前 $r_y$ 行的交集。\n  进程数量 = $r_x \\times r_y = 7 \\times 9 = 63$。\n- 大小为 $(q_x + 1) \\times q_y$ 的子域：这些对应于前 $r_x$ 列和剩下的 $p_y - r_y$ 行。\n  进程数量 = $r_x \\times (p_y - r_y) = 7 \\times 2 = 14$。\n- 大小为 $q_x \\times (q_y + 1)$ 的子域：这些对应于剩下的 $p_x - r_x$ 列和前 $r_y$ 行。\n  进程数量 = $(p_x - r_x) \\times r_y = 4 \\times 9 = 36$。\n- 大小为 $q_x \\times q_y$ 的子域：这些对应于剩下的 $p_x - r_x$ 列和剩下的 $p_y - r_y$ 行。\n  进程数量 = $(p_x - r_x) \\times (p_y - r_y) = 4 \\times 2 = 8$。\n进程总数是 $63 + 14 + 36 + 8 = 121$，这与 $p_x p_y$ 相符。\n\n4. 确定未使用的进程\n\n未使用的（空闲的）MPI 进程数量是可用进程总数与分解中所用进程总数之差。\n空闲进程的数量 = $p - p_x p_y = 128 - 121 = 7$。\n\n5. 计算工作负载不均衡比率\n\n假设每个网格单元的计算成本是均匀的，一个进程的工作负载与其子域中的网格单元数量成正比。工作负载不均衡是最大工作负载与最小工作负载的比率。\n四种可能的子域大小（工作负载）是：\n- $W_{max} = (q_x + 1) \\times (q_y + 1) = (139 + 1) \\times (69 + 1) = 140 \\times 70 = 9800$。\n- $W_2 = (q_x + 1) \\times q_y = 140 \\times 69 = 9660$。\n- $W_3 = q_x \\times (q_y + 1) = 139 \\times 70 = 9730$。\n- $W_{min} = q_x \\times q_y = 139 \\times 69 = 9591$。\n最大工作负载是 $9800$，最小工作负载是 $9591$。问题要求计算最大值与最小值的比率，即 $\\frac{W_{max}}{W_{min}}$。\n$$\\text{Ratio} = \\frac{(q_x + 1)(q_y + 1)}{q_x q_y} = \\frac{9800}{9591}$$\n这个分数是不可约的，因为分子的素因数分解是 $9800 = 2^3 \\times 5^2 \\times 7^2$，分母是 $9591 = 3 \\times 23 \\times 139$。没有共同的素因数。\n\n最终结果按照指定的顺序组合。\n- $p_x = 11$\n- $p_y = 11$\n- $q_x = 139$\n- $q_x+1 = 140$\n- $q_y = 69$\n- $q_y+1 = 70$\n- $r_x r_y = 63$\n- $r_x(p_y-r_y) = 14$\n- $(p_x-r_x)r_y = 36$\n- $(p_x-r_x)(p_y-r_y) = 8$\n- $p - p_x p_y = 7$\n- 工作负载比率 = $\\frac{9800}{9591}$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n11 & 11 & 139 & 140 & 69 & 70 & 63 & 14 & 36 & 8 & 7 & \\frac{9800}{9591}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "理解了域分解如何产生不同大小的子域后，下一步是量化这种差异对性能的实际影响。在“单程序，多数据”(SPMD)模型中，所有处理器必须在同步点（例如，光环交换）等待最慢的那个，这导致了计算资源的浪费。这个练习提供了一个从第一性原理出发的方法，让你通过真实的单步计时数据，精确计算因负载不均衡而浪费的处理器周期比例，从而直观地感受到并行效率的损失。",
            "id": "4032234",
            "problem": "一个用于数值天气预报 (NWP) 的静力原始方程核心在一个单程序多数据 (SPMD) 模型中，通过消息传递接口 (MPI) 的多个进程执行。水平域被分解为六个子域，其每个时间步的墙上时钟时间反映了由极地滤波和地形触发的物理过程导致的真实异构性。用 $t_i$ 表示进程 $i$ 每个时间步的墙上时钟时间，并设时间步以一个施加了屏障同步语义的光环交换结束。测量得到的每个时间步的时间为\n$$t_1 = 17.8~\\mathrm{ms},\\quad t_2 = 18.2~\\mathrm{ms},\\quad t_3 = 19.5~\\mathrm{ms},\\quad t_4 = 18.0~\\mathrm{ms},\\quad t_5 = 23.7~\\mathrm{ms},\\quad t_6 = 18.9~\\mathrm{ms}.$$\n从 SPMD 中屏障同步和并行执行时间的第一性原理出发，定义一个负载不平衡因子，用于比较最慢进程与平均进程。然后，推导一个封闭形式的解析表达式，将此不平衡与每个时间步在同步屏障处浪费的处理器周期分数联系起来。使用给定数据，计算该分数。\n\n将最终分数表示为无单位的小数，并将答案四舍五入到四位有效数字。",
            "solution": "该问题有效，因为它科学地基于并行计算原理，给定数据充分，问题陈述明确客观。\n\n问题要求推导在一个带有屏障同步的单程序多数据 (SPMD) 并行执行模型中，由于负载不平衡而浪费的处理器周期的分数。我们得到了 $N=6$ 个消息传递接口 (MPI) 进程的每个时间步的计算墙上时钟时间。\n\n设 $N$ 为 MPI 进程的数量。在此问题中，$N=6$。\n设 $t_i$ 为进程 $i$ 在单个时间步内完成其计算任务所需的墙上时钟时间，对于 $i \\in \\{1, 2, \\dots, N\\}$。\n\n该执行模型在每个时间步结束时采用屏障同步。这意味着所有进程都必须在屏障处等待，直到最后一个（最慢的）进程完成其计算。因此，完成一个时间步的总墙上时钟时间，记为 $T_{\\text{step}}$，由各个进程时间的最大值决定：\n$$T_{\\text{step}} = \\max_{i=1, \\dots, N} \\{t_i\\}$$\n\n在这段时间 $T_{\\text{step}}$ 内，总共有 $N$ 个处理器被分配给该任务。一个时间步的总可用处理器时间（或分配的总处理器周期）是每个处理器被占用的时间之和，即 $N$ 乘以 $T_{\\text{step}}$。\n$$T_{\\text{total\\_alloc}} = N \\cdot T_{\\text{step}} = N \\cdot \\max_{i=1, \\dots, N} \\{t_i\\}$$\n\n所有进程用于执行有效计算的时间总量是各自计算时间的总和：\n$$T_{\\text{useful}} = \\sum_{i=1}^{N} t_i$$\n\n浪费的时间是较快的进程在同步屏障处空闲等待所花费的时间。这个浪费的时间是总分配处理器时间与有效计算时间之差：\n$$T_{\\text{wasted}} = T_{\\text{total\\_alloc}} - T_{\\text{useful}} = N \\cdot \\max_{i=1, \\dots, N} \\{t_i\\} - \\sum_{i=1}^{N} t_i$$\n\n浪费的处理器周期的分数，记为 $f_{\\text{waste}}$，是浪费的时间与总分配时间的比率：\n$$f_{\\text{waste}} = \\frac{T_{\\text{wasted}}}{T_{\\text{total\\_alloc}}} = \\frac{N \\cdot \\max_{i=1, \\dots, N} \\{t_i\\} - \\sum_{i=1}^{N} t_i}{N \\cdot \\max_{i=1, \\dots, N} \\{t_i\\}} = 1 - \\frac{\\sum_{i=1}^{N} t_i}{N \\cdot \\max_{i=1, \\dots, N} \\{t_i\\}}$$\n\n问题要求首先定义一个负载不平衡因子 $\\mathcal{L}$，用于比较最慢进程与平均进程。设 $t_{\\text{slowest}}$ 为最慢进程的时间， $t_{\\text{avg}}$ 为所有进程的平均时间。\n$$t_{\\text{slowest}} = \\max_{i=1, \\dots, N} \\{t_i\\}$$\n$$t_{\\text{avg}} = \\frac{1}{N} \\sum_{i=1}^{N} t_i$$\n负载不平衡因子的一个自然定义是这两个量的比率：\n$$\\mathcal{L} = \\frac{t_{\\text{slowest}}}{t_{\\text{avg}}} = \\frac{\\max_{i=1, \\dots, N} \\{t_i\\}}{\\frac{1}{N} \\sum_{i=1}^{N} t_i}$$\n\n现在，我们推导 $f_{\\text{waste}}$ 和 $\\mathcal{L}$ 之间的关系。根据 $t_{\\text{avg}}$ 的定义，我们有 $\\sum_{i=1}^{N} t_i = N \\cdot t_{\\text{avg}}$。将此代入 $f_{\\text{waste}}$ 的表达式中：\n$$f_{\\text{waste}} = 1 - \\frac{N \\cdot t_{\\text{avg}}}{N \\cdot \\max_{i=1, \\dots, N} \\{t_i\\}} = 1 - \\frac{t_{\\text{avg}}}{\\max_{i=1, \\dots, N} \\{t_i\\}}$$\n认识到项 $\\frac{t_{\\text{avg}}}{\\max_{i=1, \\dots, N} \\{t_i\\}}$ 是负载不平衡因子 $\\mathcal{L}$ 的倒数，我们得到封闭形式的解析表达式：\n$$f_{\\text{waste}} = 1 - \\frac{1}{\\mathcal{L}}$$\n\n最后，我们使用给定的数据计算 $f_{\\text{waste}}$ 的数值：\n$$t_1 = 17.8~\\mathrm{ms}, \\quad t_2 = 18.2~\\mathrm{ms}, \\quad t_3 = 19.5~\\mathrm{ms}, \\quad t_4 = 18.0~\\mathrm{ms}, \\quad t_5 = 23.7~\\mathrm{ms}, \\quad t_6 = 18.9~\\mathrm{ms}$$\n进程数为 $N=6$。\n\n首先，找到最慢进程的时间：\n$$t_{\\text{slowest}} = \\max\\{17.8, 18.2, 19.5, 18.0, 23.7, 18.9\\} = 23.7~\\mathrm{ms}$$\n\n接下来，计算时间的总和：\n$$\\sum_{i=1}^{6} t_i = 17.8 + 18.2 + 19.5 + 18.0 + 23.7 + 18.9 = 116.1~\\mathrm{ms}$$\n\n现在，我们可以直接计算浪费周期的分数。单位毫秒将消去。\n$$f_{\\text{waste}} = 1 - \\frac{\\sum_{i=1}^{6} t_i}{6 \\cdot t_{\\text{slowest}}} = 1 - \\frac{116.1}{6 \\cdot 23.7}$$\n$$f_{\\text{waste}} = 1 - \\frac{116.1}{142.2}$$\n$$f_{\\text{waste}} \\approx 1 - 0.816455696...$$\n$$f_{\\text{waste}} \\approx 0.183544303...$$\n将结果四舍五入到四位有效数字，得到 $0.1835$。",
            "answer": "$$\\boxed{0.1835}$$"
        },
        {
            "introduction": "分析问题之后，我们转向设计解决方案。现实世界中的负载不均衡主要源于模型物理过程的复杂性，例如，在有对流的区域计算成本会更高。这个高级实践将引导你构建一个预测模型，利用物理指标（如垂直层数、对流活动）来估计每个网格列的计算成本。通过实施一个基于回归的估计器和贪心分配算法，你将体验到如何将物理洞察转化为更智能、更高效的动态负载均衡策略，这是现代气候和天气模型优化的前沿技术。",
            "id": "4032223",
            "problem": "您正在为一个数值天气预报系统中的列式物理包所产生的计算负载进行建模。一个垂直大气柱被独立处理，大规模的区域分解将这些大气柱分配给不同的处理器。负载均衡的质量取决于在分配前对每列的成本进行预测。您的任务是基于预报变量的数量和特性，设计一个每列成本的估计器，并演示如何使用它来预测成本以及计算一个负载均衡指标。\n\n从一个基本假设开始：计算成本源于每列所需的浮点运算次数，该次数与预报变量和垂直层数的数量成比例，并因激活的物理参数化方案而增加。假设在固定的模型分辨率下，成本的每个贡献在主导阶上是可加的，并且每列的成本可以被建模为一个可测量的预报和物理指标的函数，并带有一个加性扰动项。将测得的每列成本视为以秒为单位的观测值。\n\n您的任务：\n\n1. 根据上述原理，构建一个预测模型，将每列成本与一个由预报和物理指标组成的特征向量关联起来。使用测量的训练数据，构建一个基于回归的估算器来估算模型系数，并从第一性原理出发证明其合理性。该模型必须从一个最小化原理推导得出，不得假设任何快捷公式。您必须实现一个对奇异设计矩阵具有鲁棒性的估计器。\n\n2. 使用该估计器，预测每个测试案例中评估列的每列成本（单位：秒），然后执行一个贪婪的最长处理时间分配算法，将任务分配给 $P$ 个处理器，以近似实现负载均衡。给定预测的每列成本，按降序排序，并将每一列分配给当前总分配负载最小的处理器。计算不平衡比，其定义为最大预测处理器负载除以平均预测处理器负载（以小数表示）。\n\n3. 输出格式：您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，并且本身是一个双元素列表 $[\\text{predicted\\_costs\\_list}, \\text{imbalance\\_ratio}]$。例如：`[[[p1,p2,...],r1],[[...],r2],[[...],r3]]`。预测成本必须以秒（s）为单位表示，不平衡比必须以小数表示。\n\n测试套件和覆盖范围：\n\n- 使用以下测试套件，它涵盖了一般行为、无对流激活的边界条件以及因训练行重复导致的秩亏损的边缘情况。在所有情况下，特征向量为 $[L, m, \\Delta t, c, q]$，其中 $L$ 是垂直层数（无量纲计数），$m$ 是湿预报变量的数量（无量纲计数），$\\Delta t$ 是以秒（s）为单位的时间步长，$c$ 是对流活动指示符（0或1），$q$ 是微物理复杂性指数（整数，取值范围为 $\\{1,2,3\\}$）。观测到的训练成本以秒（s）为单位。\n\n- 测试用例 1（一般情况）：\n    - 训练特征 $X_{\\text{train}}$ 和观测成本 $y_{\\text{train}}$：\n        - $[60,6,60,1,2] \\rightarrow 0.00641$ s\n        - $[65,5,60,0,2] \\rightarrow 0.00423$ s\n        - $[70,7,30,1,3] \\rightarrow 0.00771$ s\n        - $[62,5,30,0,2] \\rightarrow 0.00414$ s\n        - $[66,6,30,1,3] \\rightarrow 0.00743$ s\n        - $[58,5,60,0,2] \\rightarrow 0.00418$ s\n        - $[72,7,60,1,3] \\rightarrow 0.00766$ s\n        - $[60,5,60,0,1] \\rightarrow 0.00322$ s\n        - $[68,6,30,0,2] \\rightarrow 0.00440$ s\n        - $[63,6,60,1,2] \\rightarrow 0.00642$ s\n        - $[59,5,30,0,1] \\rightarrow 0.00310$ s\n        - $[61,7,30,1,2] \\rightarrow 0.00659$ s\n    - 评估特征 $X_{\\text{eval}}$：\n        - $[64,6,60,1,3]$\n        - $[70,5,30,0,1]$\n        - $[60,7,60,1,2]$\n        - $[62,5,60,0,3]$\n        - $[58,6,30,0,2]$\n        - $[72,7,60,1,2]$\n    - 处理器数量：$P=4$。\n\n- 测试用例 2（所有训练和评估行的 $c=0$ 的边界情况）：\n    - 训练特征 $X_{\\text{train}}$ 和观测成本 $y_{\\text{train}}$：\n        - $[50,4,30,0,1] \\rightarrow 0.00285$ s\n        - $[55,5,30,0,2] \\rightarrow 0.00407$ s\n        - $[60,6,60,0,2] \\rightarrow 0.00439$ s\n        - $[45,3,60,0,1] \\rightarrow 0.00266$ s\n        - $[52,4,30,0,1] \\rightarrow 0.00283$ s\n        - $[57,5,60,0,2] \\rightarrow 0.00415$ s\n        - $[48,4,30,0,1] \\rightarrow 0.00280$ s\n        - $[62,6,30,0,2] \\rightarrow 0.00437$ s\n    - 评估特征 $X_{\\text{eval}}$：\n        - $[50,3,60,0,1]$\n        - $[55,4,30,0,2]$\n        - $[60,5,30,0,1]$\n        - $[45,3,30,0,1]$\n    - 处理器数量：$P=2$。\n\n- 测试用例 3（因训练行相同导致的秩亏损的边缘情况）：\n    - 训练特征 $X_{\\text{train}}$ 和观测成本 $y_{\\text{train}}$：\n        - $[60,6,60,1,2] \\rightarrow 0.00640$ s\n        - $[60,6,60,1,2] \\rightarrow 0.00635$ s\n        - $[60,6,60,1,2] \\rightarrow 0.00638$ s\n        - $[62,6,60,1,2] \\rightarrow 0.00641$ s\n        - $[62,6,60,1,2] \\rightarrow 0.00638$ s\n    - 评估特征 $X_{\\text{eval}}$：\n        - $[61,6,60,1,2]$\n        - $[60,6,60,1,2]$\n        - $[63,6,60,1,2]$\n    - 处理器数量：$P=3$。\n\n您的程序必须：\n- 从第一性原理推导并实现回归估计器，并用它来拟合每个训练集。\n- 预测评估列的每列成本（单位：秒）。\n- 执行贪婪的最长处理时间分配算法，并计算不平衡比（以小数表示）。\n- 生成单行输出：一个由方括号括起来的逗号分隔列表，包含三个元素（每个测试用例一个），每个元素都是一个双元素列表 $[\\text{predicted\\_costs\\_list}, \\text{imbalance\\_ratio}]$，如上所述。",
            "solution": "该问题是有效的。它在性能建模和数值方法方面有科学依据，问题陈述清晰，设置完整且一致，并以客观、可形式化的语言表述。我们将着手提供一个解决方案。\n\n该问题要求对每个测试用例提供一个包含三部分的解决方案：首先，构建并实现一个鲁棒的线性回归模型来估计每列的计算成本；其次，使用该模型为一组评估列预测成本；第三，使用这些预测成本来模拟一个负载均衡算法，以计算性能指标。\n\n**1. 预测模型构建与系数估计**\n\n问题指出，每列的计算成本在主导阶上是若干预报和物理指标的加性函数。这为构建线性回归模型提供了直接的物理基础。单个大气柱的成本 $y$ 被建模为其对应特征的线性组合，外加一个未观测到的误差项 $\\epsilon$。\n\n一列的特征向量为 $[L, m, \\Delta t, c, q]$，其中 $L$ 是垂直层数， $m$ 是湿预报变量的数量，$\\Delta t$ 是时间步长，$c$ 是对流活动指示符，$q$ 是微物理复杂性指数。为了解释这些变量未捕捉到的任何基线计算开销，我们用一个常数项来增广特征向量。因此，对于每个观测值 $i$，我们定义一个增广特征向量 $\\mathbf{x}'_i$：\n$$\n\\mathbf{x}'_i = [1, L_i, m_i, \\Delta t_i, c_i, q_i]^T\n$$\n将特征与观测成本 $y_i$ 关联起来的线性模型是：\n$$\ny_i = \\mathbf{x}'^T_i \\boldsymbol{\\beta} + \\epsilon_i\n$$\n此处，$\\boldsymbol{\\beta} = [\\beta_0, \\beta_1, \\beta_2, \\beta_3, \\beta_4, \\beta_5]^T$ 是我们希望估计的模型系数向量。项 $\\beta_0$ 代表截距或基础成本。\n\n为了估计 $\\boldsymbol{\\beta}$，我们使用提供的训练数据，该数据由 $N$ 对特征向量及其对应的测量成本 $\\{(\\mathbf{x}_i, y_i)\\}_{i=1}^N$ 组成。我们可以将所有训练样本的关系表示为矩阵形式：\n$$\n\\mathbf{y} = X \\boldsymbol{\\beta} + \\boldsymbol{\\epsilon}\n$$\n其中 $\\mathbf{y}$ 是一个 $N \\times 1$ 的观测成本向量，$X$ 是一个 $N \\times 6$ 的设计矩阵，其行是增广特征向量 $\\mathbf{x}'^T_i$，而 $\\boldsymbol{\\epsilon}$ 是一个 $N \\times 1$ 的误差向量。\n\n问题要求从一个最小化原理推导出估计器。我们采用普通最小二乘法（OLS），该方法旨在寻找能够最小化残差平方和 $S(\\boldsymbol{\\beta})$ 的系数向量 $\\hat{\\boldsymbol{\\beta}}$。残差平方和是误差向量的欧几里得范数的平方：\n$$\nS(\\boldsymbol{\\beta}) = \\sum_{i=1}^N \\epsilon_i^2 = \\boldsymbol{\\epsilon}^T \\boldsymbol{\\epsilon} = (\\mathbf{y} - X \\boldsymbol{\\beta})^T (\\mathbf{y} - X \\boldsymbol{\\beta})\n$$\n展开此表达式可得：\n$$\nS(\\boldsymbol{\\beta}) = \\mathbf{y}^T\\mathbf{y} - 2\\boldsymbol{\\beta}^T X^T \\mathbf{y} + \\boldsymbol{\\beta}^T X^T X \\boldsymbol{\\beta}\n$$\n为了找到最小值，我们计算 $S(\\boldsymbol{\\beta})$ 相对于 $\\boldsymbol{\\beta}$ 的梯度，并将其设为零向量：\n$$\n\\nabla_{\\boldsymbol{\\beta}} S(\\boldsymbol{\\beta}) = -2X^T \\mathbf{y} + 2X^T X \\boldsymbol{\\beta} = \\mathbf{0}\n$$\n这就得出了 **正规方程**：\n$$\nX^T X \\hat{\\boldsymbol{\\beta}} = X^T \\mathbf{y}\n$$\n如果矩阵 $X^T X$ 是可逆的（当且仅当 $X$ 的列线性无关，即 $X$ 具有满列秩时成立），我们可以通过直接求逆来解出 $\\hat{\\boldsymbol{\\beta}}$：\n$$\n\\hat{\\boldsymbol{\\beta}} = (X^T X)^{-1} X^T \\mathbf{y}\n$$\n然而，问题明确要求估计器对奇异设计矩阵具有鲁棒性。当 $X$ 是秩亏损的时，就会出现奇异的 $X^T X$ 矩阵。测试用例 2 就是这种情况，其中特征 $c$ 对所有数据点都为 $0$，导致 $X$ 中相应的列成为零向量，从而产生线性相关性。测试用例 3 也是这种情况，其中几个特征在所有训练样本中都是常数，导致它们在 $X$ 中对应的列与截距列线性相关。\n\n为了处理这些情况，我们使用摩尔-彭若斯伪逆（Moore-Penrose pseudoinverse），用匕首符号（$+$）表示。正规方程的通解（在解不唯一的情况下也提供了最小范数解）由以下公式给出：\n$$\n\\hat{\\boldsymbol{\\beta}} = X^+ \\mathbf{y}\n$$\n其中 $X^+$ 是 $X$ 的伪逆。这可以通过对 $X$ 进行奇异值分解（SVD）来稳健地计算。如果 $X = U \\Sigma V^T$ 是 $X$ 的 SVD 分解，那么 $X^+ = V \\Sigma^+ U^T$，其中 $\\Sigma^+$ 是通过对 $\\Sigma$ 中的非零奇异值取倒数并转置得到的。这种方法找到了唯一的向量 $\\hat{\\boldsymbol{\\beta}}$，它既能最小化最小二乘代价函数 $\\|\\mathbf{y} - X \\boldsymbol{\\beta}\\|_2^2$，又具有最小可能的欧几里得范数 $\\|\\hat{\\boldsymbol{\\beta}}\\|_2$。\n\n**2. 成本预测与负载均衡模拟**\n\n一旦从训练数据中估计出系数向量 $\\hat{\\boldsymbol{\\beta}}$，我们就可以为任何具有特征向量 $\\mathbf{x}_{\\text{eval}}$ 的新评估列预测计算成本 $\\hat{y}$。预测是通过构建增广特征向量 $\\mathbf{x}'_{\\text{eval}} = [1, L_{\\text{eval}}, m_{\\text{eval}}, \\Delta t_{\\text{eval}}, c_{\\text{eval}}, q_{\\text{eval}}]^T$ 并计算点积来完成的：\n$$\n\\hat{y} = (\\mathbf{x}'_{\\text{eval}})^T \\hat{\\boldsymbol{\\beta}}\n$$\n在预测了评估集 $X_{\\text{eval}}$ 中所有列的成本之后，我们模拟一种负载均衡策略，将这些计算任务分配到 $P$ 个处理器上。指定的算法是贪婪的最长处理时间（LPT）启发式算法。步骤如下：\n1.  为 $P$ 个处理器中的每一个初始化一个总负载数组，其值均为零。\n2.  将预测的每列成本（任务）列表按降序排序。\n3.  遍历排序后的任务列表。对于每个任务，将其分配给当前总累积负载最小的处理器。\n\n最后，我们计算负载不平衡比 $R_{\\text{imbalance}}$，其定义为任何处理器上的最大总负载与所有处理器平均负载之比：\n$$\nR_{\\text{imbalance}} = \\frac{\\max(\\text{Processor Loads})}{\\text{mean}(\\text{Processor Loads})}\n$$\n接近 $1$ 的 $R_{\\text{imbalance}}$ 值表示负载分布非常均衡。平均负载就是所有评估列的总预测成本除以处理器数量 $P$。\n\n下面的实现将这整个过程应用于三个指定的测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It fits a linear model, predicts costs, performs load balancing,\n    and calculates the imbalance ratio for each case.\n    \"\"\"\n    test_cases = [\n        {\n            \"X_train\": np.array([\n                [60, 6, 60, 1, 2], [65, 5, 60, 0, 2], [70, 7, 30, 1, 3],\n                [62, 5, 30, 0, 2], [66, 6, 30, 1, 3], [58, 5, 60, 0, 2],\n                [72, 7, 60, 1, 3], [60, 5, 60, 0, 1], [68, 6, 30, 0, 2],\n                [63, 6, 60, 1, 2], [59, 5, 30, 0, 1], [61, 7, 30, 1, 2]\n            ]),\n            \"y_train\": np.array([\n                0.00641, 0.00423, 0.00771, 0.00414, 0.00743, 0.00418,\n                0.00766, 0.00322, 0.00440, 0.00642, 0.00310, 0.00659\n            ]),\n            \"X_eval\": np.array([\n                [64, 6, 60, 1, 3], [70, 5, 30, 0, 1], [60, 7, 60, 1, 2],\n                [62, 5, 60, 0, 3], [58, 6, 30, 0, 2], [72, 7, 60, 1, 2]\n            ]),\n            \"P\": 4\n        },\n        {\n            \"X_train\": np.array([\n                [50, 4, 30, 0, 1], [55, 5, 30, 0, 2], [60, 6, 60, 0, 2],\n                [45, 3, 60, 0, 1], [52, 4, 30, 0, 1], [57, 5, 60, 0, 2],\n                [48, 4, 30, 0, 1], [62, 6, 30, 0, 2]\n            ]),\n            \"y_train\": np.array([\n                0.00285, 0.00407, 0.00439, 0.00266, 0.00283, 0.00415,\n                0.00280, 0.00437\n            ]),\n            \"X_eval\": np.array([\n                [50, 3, 60, 0, 1], [55, 4, 30, 0, 2],\n                [60, 5, 30, 0, 1], [45, 3, 30, 0, 1]\n            ]),\n            \"P\": 2\n        },\n        {\n            \"X_train\": np.array([\n                [60, 6, 60, 1, 2], [60, 6, 60, 1, 2], [60, 6, 60, 1, 2],\n                [62, 6, 60, 1, 2], [62, 6, 60, 1, 2]\n            ]),\n            \"y_train\": np.array([\n                0.00640, 0.00635, 0.00638, 0.00641, 0.00638\n            ]),\n            \"X_eval\": np.array([\n                [61, 6, 60, 1, 2], [60, 6, 60, 1, 2], [63, 6, 60, 1, 2]\n            ]),\n            \"P\": 3\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        X_train, y_train, X_eval, P = case[\"X_train\"], case[\"y_train\"], case[\"X_eval\"], case[\"P\"]\n\n        # 1. Model Fitting using Moore-Penrose Pseudoinverse\n        # Augment feature matrices with a column of ones for the intercept term.\n        X_train_aug = np.hstack([np.ones((X_train.shape[0], 1)), X_train])\n        \n        # Calculate regression coefficients using the pseudoinverse for robustness\n        # to singular matrices (rank deficiency).\n        # beta = (X^T X)^+ X^T y = X^+ y\n        beta = np.linalg.pinv(X_train_aug) @ y_train\n\n        # 2. Prediction\n        X_eval_aug = np.hstack([np.ones((X_eval.shape[0], 1)), X_eval])\n        predicted_costs = X_eval_aug @ beta\n\n        # 3. Load Balancing (Longest-Processing-Time Algorithm)\n        processor_loads = np.zeros(P)\n        # Sort predicted costs in descending order\n        sorted_costs = np.sort(predicted_costs)[::-1]\n        \n        for cost in sorted_costs:\n            # Assign the current task to the processor with the minimum load\n            min_load_processor_idx = np.argmin(processor_loads)\n            processor_loads[min_load_processor_idx] += cost\n\n        # 4. Imbalance Ratio Calculation\n        max_load = np.max(processor_loads)\n        mean_load = np.mean(processor_loads)\n        \n        # Handle potential division by zero, although unlikely with positive costs\n        imbalance_ratio = max_load / mean_load if mean_load > 0 else 1.0\n\n        results.append([predicted_costs.tolist(), imbalance_ratio])\n\n    # Format the final output string exactly as specified\n    case_strings = []\n    for res in results:\n        costs_list_str = f\"[{','.join(map(str, res[0]))}]\"\n        case_strings.append(f\"[{costs_list_str},{res[1]}]\")\n    \n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```"
        }
    ]
}