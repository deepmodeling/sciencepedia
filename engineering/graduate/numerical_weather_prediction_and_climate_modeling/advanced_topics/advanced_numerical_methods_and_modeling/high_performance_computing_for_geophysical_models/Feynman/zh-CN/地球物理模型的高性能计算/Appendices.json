{
    "hands_on_practices": [
        {
            "introduction": "在高性能计算中，算术强度是一个基本指标，它量化了计算操作与内存数据移动之间的比率。理解一个计算核心（kernel）的算术强度至关重要，因为它能帮助我们判断该核心是受计算能力限制（compute-bound）还是受内存带宽限制（memory-bound）。 这项练习将指导您从第一性原理出发，推导出一个典型模板计算核心的算术强度，从而加深您对该概念的理解，并揭示其作为计算核心内在属性的本质。",
            "id": "4051457",
            "problem": "一个三维地球物理流体动力学核在一个均匀的笛卡尔网格上更新一个标量场，在每个内部网格点使用七点有限差分模板。假设在一个缓存一致的共享内存节点上进行流式执行，没有时间分块，因此从主内存的数据移动占主导地位，并且就计算的流量而言，每次更新都是独立的。设网格在 $x$ 方向有 $N_x$ 个点，在 $y$ 方向有 $N_y$ 个点，在 $z$ 方向有 $N_z$ 个点，每个时间步长有 $N \\equiv N_x N_y N_z$ 次内部更新。\n\n已知，对于每个网格点，该核执行 $n_f$ 次浮点运算，并导致 $n_b$ 字节的数据传入或传出主内存（包括在给定执行假设下更新所需的所有加载和存储）。从算术强度的定义出发，并根据计算工作量和数据移动量的第一性原理，推导出该模板核的算术强度，作为一个关于 $n_f$ 和 $n_b$ 的闭式解析表达式。\n\n最终的算术强度以每字节浮点运算次数（flops per byte）表示。无需四舍五入。",
            "solution": "该问题要求基于第一性原理推导模板核的算术强度。\n\n算术强度，用 $I$ 表示，其形式化定义为执行的总浮点运算次数与处理器和主内存之间移动的总数据量之比。其单位通常是每字节浮点运算次数。\n\n$$\nI = \\frac{\\text{总浮点运算次数}}{\\text{总数据移动量 (字节)}}\n$$\n\n我们给定一个在三维笛卡尔网格上运行的计算核。执行更新的内部网格点总数由 $N = N_x N_y N_z$ 给出。\n\n首先，我们确定总浮点运算次数，记为 $F$。问题陈述，该核在每个网格点的更新中执行 $n_f$ 次浮点运算。由于每个时间步长总共有 $N$ 次这样的独立更新，总计算工作量是每点工作量与点数的乘积。\n\n$$\nF = N \\times n_f\n$$\n\n接下来，我们确定总数据移动量，记为 $D$。问题指定了一种流式执行模型，其中从主内存的数据移动是主导因素，并且在计算字节流量时不考虑缓存效应（即，就从主内存加载和存储数据而言，每次更新都被视为独立的）。已知在每个网格点的更新中，有 $n_b$ 字节的数据传入或传出主内存。由于有 $N$ 次这样的更新，总数据传输量是每点字节数与点数的乘积。\n\n$$\nD = N \\times n_b\n$$\n\n现在，我们可以将总工作量 $F$ 和总数据移动量 $D$ 的这些表达式代入算术强度 $I$ 的定义中。\n\n$$\nI = \\frac{F}{D} = \\frac{N \\times n_f}{N \\times n_b}\n$$\n\n代表网格点总数的项 $N$ 同时出现在分子和分母中。我们可以通过消去该项来简化表达式。这表明，对于该模型，算术强度是单点计算及其相关内存访问模式的内在属性，与整体网格大小无关。\n\n$$\nI = \\frac{n_f}{n_b}\n$$\n\n这是该核算术强度的最终闭式解析表达式。它以给定的参数 $n_f$（每点浮点运算次数）和 $n_b$（每点字节数）表示，其单位确实是每字节浮点运算次数，符合要求。有关特定模板类型（七点）和网格维度（$N_x$、 $N_y$、 $N_z$）的上下文信息已隐式地包含在所提供的参数 $n_f$ 和 $n_b$ 中，因此不会显式地出现在最终表达式中。",
            "answer": "$$\n\\boxed{\\frac{n_f}{n_b}}\n$$"
        },
        {
            "introduction": "设计了最优的区域分解后，下一步是具体实现子区域之间的数据交换，即“光环交换”（halo exchange）。在实际编程中，使用高效的非阻塞通信原语（如 MPI 中的 non-blocking calls）可能会引入一种常见的、难以调试的错误：死锁。 这项练习要求您设计并模拟一个保证无死锁的3D光环交换算法，通过实施一种基于维度和奇偶校验的通信分阶段策略，您将获得编写正确且可扩展的并行通信代码的宝贵实践经验。",
            "id": "4051428",
            "problem": "一个用于数值天气预报 (NWP) 的结构化网格三维地球物理流体模型，使用域分解方法在一个分布式内存的高性能计算 (HPC) 系统上实现。每个计算节点拥有且仅拥有一个维度为 $n_x \\times n_y \\times n_z$ 的轴对齐内部网格单元矩形块，并在所有六个面上增加了一个宽度为 $h$ 的单元光环（halo），以支持模板计算和消息传递接口 (MPI) 交换。每个节点的内存容量为 $M$，每个网格单元包含 $q$ 个预报或诊断数组，每个数组元素存储占用 $b$ 字节，因此每个单元的有效内存占用为 $\\beta = q b$。假设每个时间步中，主要的节点间通信包括在六个面上交换厚度为 $h$ 的光环数据厚板。\n\n从几何优化和资源约束的基本原理出发，并仅使用上述定义，推导出能使每个时间步的总光环通信量最小化的内部块维度 $(n_x,n_y,n_z)$，其约束条件是恰好用尽每个节点的内存容量。将最终的最优内部块维度表示为仅含 $M$、$h$、$b$ 和 $q$ 的解析表达式。假设 $M$ 足够大以确保最优块维度为非负。不需要取整。将最终答案表示为每个维度上的单元数量。",
            "solution": "该问题要求我们找到内部网格维度 $(n_x, n_y, n_z)$，以在完全利用每个节点可用内存 $M$ 的同时，最小化节点间的通信量。这是一个经典的表面积与体积比优化问题。\n\n**1. 建立内存约束方程**\n\n每个计算节点存储一个大小为 $n_x \\times n_y \\times n_z$ 的内部块，以及在所有六个面上宽度为 $h$ 的光环。因此，存储在内存中的网格块的总维度为 $(n_x + 2h) \\times (n_y + 2h) \\times (n_z + 2h)$。\n\n一个节点上存储的网格单元总数 $N_{total}$ 是这个增广块的体积：\n$$N_{total} = (n_x + 2h)(n_y + 2h)(n_z + 2h)$$\n\n每个网格单元需要 $\\beta = qb$ 字节的内存。因此，每个节点使用的总内存 $V_{mem}$ 为：\n$$V_{mem} = N_{total} \\cdot \\beta = (n_x + 2h)(n_y + 2h)(n_z + 2h) q b$$\n\n问题陈述每个节点的内存容量 $M$ 被恰好用尽。这给出了我们的约束方程：\n$$(n_x + 2h)(n_y + 2h)(n_z + 2h) q b = M$$\n\n**2. 建立通信量目标函数**\n\n通信包括与相邻节点交换光环数据。要交换的数据量由内部块的表面积决定。对于厚度为 $h$ 的光环，通信数据来自内部块的六个表面，厚度也为 $h$。每个时间步通信的单元总数 $N_{comm}$ 是这些数据厚板体积的总和：\n$$N_{comm} = 2(n_x n_y h + n_x n_z h + n_y n_z h)$$\n\n以字节为单位的总通信量 $V_{comm}$ 是 $N_{comm} \\cdot qb$。为了最小化 $V_{comm}$，我们必须最小化内部块的表面积函数 $S(n_x, n_y, n_z)$：\n$$S(n_x, n_y, n_z) = n_x n_y + n_x n_z + n_y n_z$$\n\n**3. 求解约束优化问题**\n\n我们需要最小化 $S(n_x, n_y, n_z)$，其约束条件是总内存固定。这是一个经典的几何问题：在固定体积的情况下，立方体具有最小的表面积。我们可以通过拉格朗日乘数法严格证明。定义拉格朗日函数 $\\mathcal{L}$：\n$$\\mathcal{L}(n_x, n_y, n_z, \\lambda) = S(n_x, n_y, n_z) - \\lambda [ (n_x + 2h)(n_y + 2h)(n_z + 2h) q b - M ]$$\n对 $n_x, n_y, n_z$ 求偏导数并设为零：\n$$\\frac{\\partial \\mathcal{L}}{\\partial n_x} = n_y + n_z - \\lambda q b (n_y + 2h)(n_z + 2h) = 0$$\n$$\\frac{\\partial \\mathcal{L}}{\\partial n_y} = n_x + n_z - \\lambda q b (n_x + 2h)(n_z + 2h) = 0$$\n$$\\frac{\\partial \\mathcal{L}}{\\partial n_z} = n_x + n_y - \\lambda q b (n_x + 2h)(n_y + 2h) = 0$$\n通过对方程进行代数运算（例如，将前两个方程相除并化简），可以得出 $(n_z - 2h)(n_x - n_y) = 0$。同理，可以证明为求得通用解，必须有 $n_x = n_y = n_z$。这证明了最优的内部块形状是一个立方体。\n\n**4. 确定最优维度**\n\n设 $n_x = n_y = n_z = n$。将此代入内存约束方程中：\n$$(n + 2h)(n + 2h)(n + 2h) q b = M$$\n$$(n + 2h)^3 q b = M$$\n$$(n + 2h)^3 = \\frac{M}{q b}$$\n对两边取立方根：\n$$n + 2h = \\left(\\frac{M}{q b}\\right)^{1/3}$$\n最后，我们求解 $n$：\n$$n = \\left(\\frac{M}{q b}\\right)^{1/3} - 2h$$\n因此，最优的内部块维度 $(n_x, n_y, n_z)$ 的每个分量都等于这个值。",
            "answer": "$$\n\\boxed{\nn_x = n_y = n_z = \\left(\\frac{M}{q b}\\right)^{1/3} - 2h\n}\n$$"
        },
        {
            "introduction": "设计了最优的区域分解后，下一步是具体实现子区域之间的数据交换，即“光环交换”（halo exchange）。在实际编程中，使用高效的非阻塞通信原语（如 MPI 中的 non-blocking calls）可能会引入一种常见的、难以调试的错误：死锁。 这项练习要求您设计并模拟一个保证无死锁的3D光环交换算法，通过实施一种基于维度和奇偶校验的通信分阶段策略，您将获得编写正确且可扩展的并行通信代码的宝贵实践经验。",
            "id": "4051447",
            "problem": "考虑一个地球物理模型的$3$维域分解，该模型分布在一个大小为 $N_x \\times N_y \\times N_z$ 的笛卡尔处理器网格上，其中每个处理器持有一个子域，并与其六个面相邻的处理器交换晕轮数据。在高性能计算 (HPC) 中，晕轮交换通常使用消息传递接口 (MPI) 中的非阻塞原语来实现。在大消息的会合协议中，一个发送操作只有在目标端发布了匹配的接收操作后才能完成。假设非阻塞通信具有简化的、抽象的语义：\n\n- 每个处理器可以发布非阻塞接收操作，记为 $P_r$，该操作不消耗注入能力。\n- 每个处理器可以发布非阻塞发送操作，记为 $P_s$，最多可有 $C$ 个未完成的发送消息。注入能力 $C$ 以消息数量而非字节数计量。\n- 每个已发布的体积为 $V$ 字节的发送操作行为如下：\n  - 如果 $V \\le V_\\mathrm{RZ}$ (渴望模式)，只要注入能力允许发布 $P_s$，它就可以在没有预先匹配的接收操作的情况下完成。\n  - 如果 $V > V_\\mathrm{RZ}$ (会合模式)，它只有在目标端发布了匹配的 $P_r$ 后才能完成。\n- 一个等待操作，记为 $W$，会阻塞直到其作用域内所有先前发布的操作都已完成。\n- 网格是非周期性的；边界处理器拥有的邻居少于六个。\n\n在这个抽象模型中，死锁通过等待图定义：如果存在一个操作环路，其中每个处理器都在等待另一个处理器执行某个动作，而该动作由于已发布的操作和能力约束而无法发生，则系统处于死锁状态。\n\n任务：通过正确排序 $P_r$、$P_s$ 和 $W$ 操作，为$3$维分解构建一个无死锁的非阻塞晕轮交换算法。您的算法必须：\n\n1. 在 $V > V_\\mathrm{RZ}$ 时，遵循会合语义。\n2. 遵循每个处理器 $C$ 条消息的注入能力限制。\n3. 通过确保等待图是无环的来避免死锁。\n4. 完成沿 $x$、$y$ 和 $z$ 轴的晕轮交换。\n\n您必须在一个程序中实现此抽象协议的模拟。该模拟应为位于整数坐标 $(i,j,k)$（$0 \\le i < N_x$, $0 \\le j < N_y$, $0 \\le k < N_z$）的处理器建模，其单位距离邻居存在于六个轴对齐方向上。沿每个轴的晕轮交换最多包含每个处理器的两个方向性消息（一个发往负方向邻居，一个发往正方向邻居），并受边界条件约束。\n\n设计一种排序策略，通过沿每个轴分阶段操作并使用棋盘格奇偶性来串行化冲突的发送操作，从而实现会合消息的无死锁和终止。具体来说，您必须为每个轴决定处理器发布 $P_r$、发布 $P_s$ 和调用 $W$ 的顺序，同时考虑到 $C$ 可能小至 $1$。\n\n要实现的模拟规则：\n\n- 程序必须内部建模 $P_r$ 和 $P_s$ 操作的发布、它们的匹配以及在 $V > V_\\mathrm{RZ}$ 时根据会合约束的完成过程。\n- 发布一个 $P_s$ 会使处理器的未完成发送计数增加 $1$；该发送的完成会使其减少 $1$。\n- $P_r$ 可以在任何时候发布，不消耗能力。\n- 在会合模式下的发送操作只有在目标端已发布匹配的 $P_r$ 时才能完成。\n- 对一个轴的等待操作 $W$ 必须确保该轴所有已发布的操作完成后才能进入下一个轴。\n- 如果在执行 $W$ 期间，由于能力或排序约束，没有操作可以完成，也无法发布更多操作，则模拟应声明该测试用例死锁。\n\n您的程序应实现您的排序策略，并报告晕轮交换是否在一组测试用例中无死锁地完成。使用 $V_\\mathrm{RZ} = 512$ 字节。测试套件中所有消息体积 $V$ 的单位均为字节。\n\n测试套件 (每个用例是一个元组 $(N_x,N_y,N_z,V,C)$):\n\n- 用例 1：$(2,2,2,4096,1)$，会合模式，均衡网格；预期完成。\n- 用例 2：$(4,1,1,4096,1)$，会合模式，$x$ 轴线状分解；预期完成。\n- 用例 3：$(3,3,1,8192,1)$，会合模式，板状分解；预期完成。\n- 用例 4：$(3,3,3,8192,1)$，会合模式，立方体网格；预期完成。\n- 用例 5：$(2,2,2,8192,0)$，会合模式，注入能力为零；预期死锁。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如，“[$r_1$,$r_2$,$r_3$,$r_4$,$r_5$]”，其中每个 $r_i$ 是一个布尔值，表示对于第 $i$ 个用例，晕轮交换是完成 ($\\mathrm{True}$) 还是死锁 ($\\mathrm{False}$)。",
            "solution": "该问题要求设计并模拟一个用于$3$维笛卡尔处理器网格的无死锁非阻塞晕轮交换算法。该算法在用于大消息的会合通信协议和受限的单处理器注入能力 $C$（可能低至 $1$）下必须是正确的。\n\n### 基于原则的设计\n\n主要挑战是避免死锁。死锁通常源于循环的“等待”依赖关系。在我们的情境中，当两个或多个处理器都在等待对方为自己已发布的会合发送 ($P_s$) 发布一个接收 ($P_r$) 时，就会发生这种情况。在注入能力 $C$ 有限的情况下，一个处理器可能会用尽其能力来发布发送操作，从而无法继续发布其邻居所需的接收操作。\n\n标准且最稳健的解决方案，正如问题描述中所暗示的，是通过将通信分阶段构建来打破这些循环依赖。\n\n1.  **维度分阶段**：将完整的$3D$晕轮交换分解为三个独立的、顺序的交换，每个轴（$x$、$y$ 和 $z$）一次。在每个轴的交换之间放置一个全局同步屏障（一个等待操作 $W$）。这确保了例如，没有处理器会因为等待一个沿 $x$ 轴的消息，而其邻居又在等待一个沿 $y$ 轴的消息。这将所有依赖关系限制在单个轴内。\n\n2.  **基于奇偶性的角色分阶段（棋盘格模式）**：在单个轴的交换内部，我们仍必须防止相邻处理器（例如，处理器 $i$ 和 $i+1$ 同时向对方发送）之间发生死锁。这可以通过根据处理器坐标的奇偶性分配角色来解决。沿一个轴的交换被分为两个阶段：\n    -   **阶段 1**：沿该轴坐标索引为偶数的处理器被指定为“发送方”，坐标索引为奇数的处理器被指定为“接收方”。偶数索引的处理器向其奇数索引的邻居发布发送 ($P_s$)，奇数索引的处理器从其偶数索引的邻居发布接收 ($P_r$)。因为发送操作只从偶数处理器定向到奇数处理器，所以等待图是一个有向无环图 (DAG)，不会发生死锁。来自偶数处理器的会合发送总能在其奇数编号的目标端找到一个已经发布的相应接收。\n    -   **阶段 2**：角色反转。奇数索引的处理器成为“发送方”，偶数索引的处理器成为“接收方”。此阶段处理相反方向的通信，同样因为相同的原因而无死锁，并完成了该轴的双向晕轮交换。\n\n当注入能力 $C$ 很小时，这种两阶段、基于奇偶性的方法对于正确性至关重要。对于 $C=1$，一个拥有两个邻居的发送处理器一次只能发布一个发送。模拟必须正确地建模这个发送操作的完成（因为其目标在此阶段是一个只接收的处理器），从而释放注入能力以供第二个发送操作发布和完成。\n\n### 模拟算法\n\n模拟将根据规则对每个处理器的状态和通信操作的进展进行建模。\n\n-   **处理器状态**：每个位于坐标 $(i, j, k)$ 的处理器被建模为一个对象，维护其状态：\n    -   注入能力：$C$。\n    -   `outstanding_sends`：已发布但尚未完成的发送操作列表。此列表的大小不能超过 $C$。\n    -   `pending_sends`：已准备好发布但因注入能力已满而被阻塞的发送操作队列。\n    -   `posted_receives`：已发布的接收操作列表。\n\n-   **等待操作 ($W$) 模拟**：`wait` 操作被实现为一个模拟循环，该循环持续进行直到无法取得更多进展。在每次迭代中，该循环执行两个主要动作：\n    1.  **检查完成情况**：扫描所有 `outstanding_sends`。如果一个发送操作处于渴望模式 ($V \\le V_\\mathrm{RZ}$) 或在目标处理器上存在一个匹配的 `posted_receive`，则该操作可以完成。完成后，该发送操作将从 `outstanding_sends` 中移除，从而释放注入能力。\n    2.  **发布待处理的发送**：扫描所有处理器。如果一个处理器有 `pending_sends` 并且有可用的注入能力（因为先前的发送已完成），它会将一个待处理的发送移至其 `outstanding_sends` 列表。\n\n-   **死锁检测**：如果在 `wait` 循环的完整迭代中，没有发送操作可以完成，也没有新的发送操作可以发布，但仍有未完成的工作（即，非空的 `outstanding_sends` 或 `pending_sends` 列表），则模拟处于死锁状态。\n\n-   **整体流程**：\n    1.  初始化 $N_x \\times N_y \\times N_z$ 的处理器网格。\n    2.  对于 {$x, y, z$} 中的每个轴 `d`：\n        a.  **阶段 1 (偶数 → 奇数)**：\n            i.  所有在 `d` 轴上索引为奇数的处理器发布其所有来自邻居的接收操作。\n            ii. 所有在 `d` 轴上索引为偶数的处理器发布其向邻居的发送操作（如果超出能力则将其排入待处理队列）。\n            iii. 执行 `wait` 模拟循环。如果返回死锁，则整个交换失败。\n        b.  **阶段 2 (奇数 → 偶数)**：\n            i.  所有偶数索引的处理器发布接收操作。\n            ii. 所有奇数索引的处理器发布发送操作。\n            iii. 执行 `wait` 模拟循环。如果返回死锁，则交换失败。\n    3.  如果所有轴的所有阶段都成功完成，则晕轮交换成功。\n\n对于 $C \\ge 1$，此设计保证无死锁。对于 $C=0$ 的测试用例，没有任何处理器能发布发送操作，导致立即且被正确识别的死锁。",
            "answer": "```python\nimport numpy as np\nfrom collections import namedtuple\n\n# Define simple data structures for communication operations\nSendOperation = namedtuple('SendOperation', ['dest_coords'])\nRecvOperation = namedtuple('RecvOperation', ['source_coords'])\n\nclass Processor:\n    \"\"\"Models a single processor in the Cartesian grid.\"\"\"\n    \n    def __init__(self, coords, capacity):\n        self.coords = coords\n        self.capacity = capacity\n        self.reset_phase_state()\n\n    def reset_phase_state(self):\n        \"\"\"Resets the state for a new communication phase.\"\"\"\n        self.pending_sends = []\n        self.outstanding_sends = []\n        self.posted_receives = []\n\n    def post_send(self, dest_coords):\n        \"\"\"Posts a send operation, respecting injection capacity.\"\"\"\n        op = SendOperation(dest_coords=dest_coords)\n        if len(self.outstanding_sends)  self.capacity:\n            self.outstanding_sends.append(op)\n        else:\n            self.pending_sends.append(op)\n            \n    def post_receive(self, source_coords):\n        \"\"\"Posts a receive operation.\"\"\"\n        op = RecvOperation(source_coords=source_coords)\n        self.posted_receives.append(op)\n\ndef simulate_wait_phase(processors, is_rendezvous):\n    \"\"\"\n    Simulates the network until all posted operations complete for a phase.\n    Returns True on success, False on deadlock.\n    \"\"\"\n    while True:\n        made_progress = False\n\n        # --- Part 1: Try to complete outstanding sends ---\n        # We iterate over a snapshot of all sends to allow modification of lists during the loop\n        sends_to_check = []\n        for p in processors.values():\n            for send_op in p.outstanding_sends:\n                sends_to_check.append((p, send_op))\n        \n        for sender_proc, send_op in sends_to_check:\n            # Check if this send is still outstanding (might have been completed already in this loop)\n            if send_op not in sender_proc.outstanding_sends:\n                continue\n\n            dest_proc = processors[send_op.dest_coords]\n            \n            matching_recv = next((recv for recv in dest_proc.posted_receives if recv.source_coords == sender_proc.coords), None)\n            \n            can_complete = (not is_rendezvous) or (is_rendezvous and matching_recv is not None)\n            \n            if can_complete:\n                sender_proc.outstanding_sends.remove(send_op)\n                if matching_recv:\n                    dest_proc.posted_receives.remove(matching_recv)\n                made_progress = True\n\n        # --- Part 2: Try to post pending sends ---\n        for p in processors.values():\n            while p.pending_sends and len(p.outstanding_sends)  p.capacity:\n                op_to_post = p.pending_sends.pop(0)\n                p.outstanding_sends.append(op_to_post)\n                made_progress = True\n\n        # --- Part 3: Check for completion or deadlock ---\n        all_done = all(not p.pending_sends and not p.outstanding_sends for p in processors.values())\n        \n        if all_done:\n            # All posted and pending sends for this phase are complete.\n            # We must also check that all receives were matched.\n            if any(p.posted_receives for p in processors.values()):\n                # This indicates an asymmetry or error in the algorithm setup\n                return False \n            return True # Phase successful\n\n        if not made_progress:\n            return False # Deadlock: work remains but no progress was made.\n\ndef run_simulation(Nx, Ny, Nz, V, C):\n    \"\"\"\n    Runs the simulation for a single test case.\n    Returns True if the halo exchange completes, False if it deadlocks.\n    \"\"\"\n    V_RZ = 512\n    is_rendezvous = V > V_RZ\n    \n    processors = {\n        (i, j, k): Processor(coords=(i, j, k), capacity=C)\n        for i in range(Nx) for j in range(Ny) for k in range(Nz)\n    }\n\n    dimensions = [(0, Nx), (1, Ny), (2, Nz)]\n\n    for dim_idx, N_dim in dimensions:\n        if N_dim = 1:\n            continue\n\n        # --- Phase 1: Even-indexed processors send, Odd-indexed receive ---\n        for p in processors.values():\n            p.reset_phase_state()\n\n        # Odd processors post receives from their even neighbors\n        for coords, proc in processors.items():\n            if coords[dim_idx] % 2 != 0:\n                if coords[dim_idx] > 0: # has negative neighbor\n                    neg_coords = list(coords); neg_coords[dim_idx] -= 1\n                    proc.post_receive(source_coords=tuple(neg_coords))\n                if coords[dim_idx]  N_dim - 1: # has positive neighbor\n                    pos_coords = list(coords); pos_coords[dim_idx] += 1\n                    proc.post_receive(source_coords=tuple(pos_coords))\n\n        # Even processors post sends to their odd neighbors\n        for coords, proc in processors.items():\n            if coords[dim_idx] % 2 == 0:\n                if coords[dim_idx] > 0: # has negative neighbor\n                    neg_coords = list(coords); neg_coords[dim_idx] -= 1\n                    proc.post_send(dest_coords=tuple(neg_coords))\n                if coords[dim_idx]  N_dim - 1: # has positive neighbor\n                    pos_coords = list(coords); pos_coords[dim_idx] += 1\n                    proc.post_send(dest_coords=tuple(pos_coords))\n\n        if not simulate_wait_phase(processors, is_rendezvous):\n            return False\n\n        # --- Phase 2: Odd-indexed processors send, Even-indexed receive ---\n        for p in processors.values():\n            p.reset_phase_state()\n\n        # Even processors post receives from their odd neighbors\n        for coords, proc in processors.items():\n            if coords[dim_idx] % 2 == 0:\n                if coords[dim_idx] > 0:\n                    neg_coords = list(coords); neg_coords[dim_idx] -= 1\n                    proc.post_receive(source_coords=tuple(neg_coords))\n                if coords[dim_idx]  N_dim - 1:\n                    pos_coords = list(coords); pos_coords[dim_idx] += 1\n                    proc.post_receive(source_coords=tuple(pos_coords))\n\n        # Odd processors post sends to their even neighbors\n        for coords, proc in processors.items():\n            if coords[dim_idx] % 2 != 0:\n                if coords[dim_idx] > 0:\n                    neg_coords = list(coords); neg_coords[dim_idx] -= 1\n                    proc.post_send(dest_coords=tuple(neg_coords))\n                if coords[dim_idx]  N_dim - 1:\n                    pos_coords = list(coords); pos_coords[dim_idx] += 1\n                    proc.post_send(dest_coords=tuple(pos_coords))\n\n        if not simulate_wait_phase(processors, is_rendezvous):\n            return False\n\n    return True\n\ndef solve():\n    test_cases = [\n        (2, 2, 2, 4096, 1),\n        (4, 1, 1, 4096, 1),\n        (3, 3, 1, 8192, 1),\n        (3, 3, 3, 8192, 1),\n        (2, 2, 2, 8192, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, Nz, V, C = case\n        result = run_simulation(Nx, Ny, Nz, V, C)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}