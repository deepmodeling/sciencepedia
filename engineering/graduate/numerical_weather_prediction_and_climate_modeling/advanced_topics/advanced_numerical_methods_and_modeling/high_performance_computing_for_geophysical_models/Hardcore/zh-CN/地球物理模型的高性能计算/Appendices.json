{
    "hands_on_practices": [
        {
            "introduction": "在开始优化复杂的地球物理模型之前，我们必须首先理解其性能瓶颈。计算强度（Arithmetic Intensity）是衡量计算核心性能的一个基本指标，它揭示了计算操作数量与内存访问量之间的比率。 这个练习将指导你从第一性原理出发，推导出一个典型有限差分模板的计算强度，从而帮助你判断一个计算任务是受限于计算速度（compute-bound）还是内存带宽（memory-bound）。",
            "id": "4051457",
            "problem": "一个三维地球物理流体动力学核心在均匀笛卡尔网格上更新一个标量场，对每个内部网格点使用七点有限差分模板。假设在一个缓存一致性共享内存节点上进行流式执行，且没有时间分块，因此从主内存的数据移动占主导地位，并且就计算的流量而言，每次更新都是独立的。设网格在 $x$ 方向上有 $N_x$ 个点，在 $y$ 方向上有 $N_y$ 个点，在 $z$ 方向上有 $N_z$ 个点，每个时间步长有 $N \\equiv N_x N_y N_z$ 次内部更新。\n\n已知对于每个网格点，该核心执行 $n_f$ 次浮点运算，并导致 $n_b$ 字节数据传入或传出主内存（包括在给定执行假设下更新所需的所有加载和存储）。从算术强度的定义出发，并根据计算工作量和数据移动量的第一性原理，推导出该模板核心的算术强度的闭式解析表达式，用 $n_f$ 和 $n_b$ 表示。\n\n最终的算术强度以每字节浮点运算次数（flops per byte）表示。无需四舍五入。",
            "solution": "该问题要求基于第一性原理推导模板核心的算术强度。\n\n算术强度，记为 $I$，其形式化定义为所执行的浮点运算总次数与处理器和主内存之间移动的数据总量之比。其单位通常是每字节浮点运算次数。\n\n$$\nI = \\frac{\\text{Total Floating-Point Operations}}{\\text{Total Data Movement (Bytes)}}\n$$\n\n我们给定一个在三维笛卡尔网格上操作的计算核心。执行更新的内部网格点总数由 $N = N_x N_y N_z$ 给出。\n\n首先，我们确定浮点运算的总次数，记为 $W$。题目说明，该核心在每个网格点的更新中执行 $n_f$ 次浮点运算。由于每个时间步长总共有 $N$ 次这样的独立更新，因此总计算工作量是每点工作量与点数的乘积。\n\n$$\nW = N \\times n_f\n$$\n\n接下来，我们确定总数据移动量，记为 $Q$。题目指定了一个流式执行模型，其中从主内存的数据移动是主导因素，并且在计算字节流量时，不考虑缓存效应（即，就从主内存加载和存储数据而言，每次更新都被视为独立的）。已知对于每个网格点的更新，有 $n_b$ 字节的数据传入或传出主内存。由于有 $N$ 次这样的更新，因此传输的总数据量是每点字节数与点数的乘积。\n\n$$\nQ = N \\times n_b\n$$\n\n现在，我们可以将总工作量 $W$ 和总数据移动量 $Q$ 的这些表达式代入算术强度 $I$ 的定义中。\n\n$$\nI = \\frac{W}{Q} = \\frac{N \\times n_f}{N \\times n_b}\n$$\n\n代表网格点总数的项 $N$ 同时出现在分子和分母中。我们可以通过消去该项来简化表达式。这表明，对于该模型，算术强度是每点计算及其相关内存访问模式的内在属性，与整体网格大小无关。\n\n$$\nI = \\frac{n_f}{n_b}\n$$\n\n这就是该核心算术强度的最终闭式解析表达式。它用给定的参数 $n_f$（每点浮点运算次数）和 $n_b$（每点字节数）表示，其单位确实是每字节浮点运算次数，符合要求。关于特定模板类型（七点）和网格维度（$N_x$, $N_y$, $N_z$）的上下文信息已隐式地包含在所提供的参数 $n_f$ 和 $n_b$ 中，因此没有显式地出现在最终表达式中。",
            "answer": "$$\n\\boxed{\\frac{n_f}{n_b}}\n$$"
        },
        {
            "introduction": "在掌握了单核性能分析的基础后，下一步是解决如何在分布式系统上高效运行模型。区域分解（Domain decomposition）是将大问题划分到多个处理器上的标准策略，但这引入了通信开销。 这个练习将引导你解决一个核心的优化问题：在固定的内存限制下，如何划分三维计算区域以最小化“表面积-体积比”，从而减少处理器间的通信量，这是实现模型大规模可扩展性的关键。",
            "id": "4051428",
            "problem": "一个用于数值天气预报 (NWP) 的结构化网格三维地球物理流体模型，在使用区域分解的分布式内存高性能计算 (HPC) 系统上实现。每个计算节点拥有一个维度为 $n_x \\times n_y \\times n_z$ 的内部网格单元的轴对齐矩形块，并在所有六个面上增加了宽度为 $h$ 的单元晕环，以支持模板计算和消息传递接口 (MPI) 数据交换。每个节点的内存容量为 $M$，每个网格单元包含 $q$ 个预报或诊断数组，每个数组元素使用 $b$ 字节存储，因此每个单元的有效内存占用为 $\\beta = q b$。假设每个时间步中主要的节点间通信包括跨越六个面交换厚度为 $h$ 的晕环数据块。\n\n从几何优化和资源约束的第一性原理出发，仅使用上述定义，推导使每时间步总晕环通信量最小化的内部块维度 $(n_x,n_y,n_z)$，其约束条件是精确饱和每个节点的内存容量。将最终的最优内部块维度表示为仅包含 $M$、$h$、$b$ 和 $q$ 的解析表达式。假设 $M$ 足够大，以确保最优块维度为非负。无需取整。将最终答案表示为每个维度上的单元数。",
            "solution": "该问题要求我们找到内部网格维度 $(n_x, n_y, n_z)$，以在完全利用每个节点上可用内存 $M$ 的同时，最小化节点间的通信量。\n\n**1. 建立内存约束方程**\n每个节点存储的网格块的总维度是 $(n_x + 2h) \\times (n_y + 2h) \\times (n_z + 2h)$，包括内部块和晕环。每个网格单元占用 $\\beta = qb$ 字节。由于内存被精确饱和，我们得到约束方程：\n$$(n_x + 2h)(n_y + 2h)(n_z + 2h) q b = M$$\n\n**2. 建立通信量目标函数**\n总晕环通信量与内部块的六个面的总表面积成正比。为了最小化通信，我们需要最小化表面积函数 $S(n_x, n_y, n_z) = n_x n_y + n_x n_z + n_y n_z$。\n\n**3. 求解约束优化问题**\n这是一个在给定约束下最小化目标函数的问题，可以使用拉格朗日乘子法解决。设拉格朗日函数为：\n$$\\mathcal{L} = (n_x n_y + n_x n_z + n_y n_z) - \\lambda [ (n_x + 2h)(n_y + 2h)(n_z + 2h) q b - M ]$$\n将 $\\mathcal{L}$ 对 $n_x$、$n_y$ 和 $n_z$ 的偏导数设为零，我们得到：\n$$\\frac{\\partial \\mathcal{L}}{\\partial n_x} = n_y + n_z - \\lambda q b (n_y + 2h)(n_z + 2h) = 0$$\n$$\\frac{\\partial \\mathcal{L}}{\\partial n_y} = n_x + n_z - \\lambda q b (n_x + 2h)(n_z + 2h) = 0$$\n$$\\frac{\\partial \\mathcal{L}}{\\partial n_z} = n_x + n_y - \\lambda q b (n_x + 2h)(n_y + 2h) = 0$$\n通过对方程进行代数运算（例如，将前两个方程相除），可以得出 $n_x = n_y$。同理可得 $n_y = n_z$。因此，内部块的最优形状是一个立方体，即：\n$$n_x = n_y = n_z = n$$\n\n**4. 确定最优维度**\n将此结果代入内存约束方程：\n$$(n + 2h)^3 q b = M$$\n$$(n + 2h)^3 = \\frac{M}{q b}$$\n对两边取立方根：\n$$n + 2h = \\left(\\frac{M}{q b}\\right)^{1/3}$$\n最后，我们求解 $n$，得到内部立方体块每个维度的最优大小：\n$$n = \\left(\\frac{M}{q b}\\right)^{1/3} - 2h$$\n这就导出了最终的答案。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\left(\\frac{M}{q b}\\right)^{1/3} - 2h   \\left(\\frac{M}{q b}\\right)^{1/3} - 2h   \\left(\\frac{M}{q b}\\right)^{1/3} - 2h\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "当数据被优化地分布在各个处理器上后，最后的挑战便是实现它们之间的通信。晕圈交换（Halo exchange）是处理器共享边界数据的核心机制，但一个天真的实现很可能导致死锁（deadlock）。 这个练习要求你设计并模拟一个无死锁的非阻塞晕圈交换算法，通过实践掌握避免并行程序中循环等待依赖的经典策略，这是编写健壮地球物理模型的必备技能。",
            "id": "4051447",
            "problem": "考虑一个地球物理模型在大小为 $N_x \\times N_y \\times N_z$ 的笛卡尔处理器网格上的 $3$ 维区域分解，其中每个处理器持有一个子域，并与其六个面相邻的处理器交换光环数据。在高性能计算 (HPC) 中，光环交换通常使用消息传递接口 (MPI) 中的非阻塞原语实现。在用于大消息的会合协议中，一个发送操作只有在目标上发布了匹配的接收操作后才能完成。假设非阻塞通信具有以下简化的、抽象的语义：\n\n- 每个处理器可以发布非阻塞接收操作（记为 $P_r$），这不消耗注入能力。\n- 每个处理器可以发布非阻塞发送操作（记为 $P_s$），最多可有 $C$ 个未完成的发送消息，这个上限由注入能力决定。注入能力 $C$ 以消息数量而非字节数计量。\n- 每个已发布的体积为 $V$ 字节的发送操作行为如下：\n  - 如果 $V \\le V_\\mathrm{RZ}$ (饥饿模式)，只要注入能力允许发布 $P_s$，它就可以在没有预先匹配的接收的情况下完成。\n  - 如果 $V  V_\\mathrm{RZ}$ (会合模式)，它只有在目标发布了匹配的 $P_r$ 后才能完成。\n- 一个等待操作（记为 $W$）会阻塞，直到其作用域内所有先前发布的操作都已完成。\n- 网格是非周期性的；边界处理器拥有的邻居少于六个。\n\n在此抽象模型中，死锁通过等待图定义：如果存在一个操作循环，其中每个处理器都在等待另一个处理器执行一个因已发布的操作和能力约束而无法发生的操作，那么系统就处于死锁状态。\n\n任务：通过正确地对 $P_r$、$P_s$ 和 $W$ 操作进行排序，为 $3$ 维分解构建一个无死锁的非阻塞光环交换算法。您的算法必须：\n\n1. 当 $V  V_\\mathrm{RZ}$ 时，遵守会合语义。\n2. 遵守每个处理器 $C$ 条消息的注入能力限制。\n3. 通过确保等待图无环来避免死锁。\n4. 完成沿 $x$、$y$ 和 $z$ 轴的光环交换。\n\n您必须在一个程序中实现此抽象协议的模拟。模拟应为位于整数坐标 $(i,j,k)$（其中 $0 \\le i  N_x$, $0 \\le j  N_y$, $0 \\le k  N_z$）的处理器建模，这些处理器在存在的六个轴对齐方向上具有单位距离的邻居。沿一个轴的每次光环交换，每个处理器最多包含两个定向消息（一个发往负方向邻居，一个发往正方向邻居），这受边界条件的约束。\n\n设计一个排序策略，通过沿各轴分阶段操作并使用棋盘格奇偶性来序列化冲突的发送，从而实现会合消息的无死锁和终止。具体来说，您必须为每个轴决定处理器发布 $P_r$、发布 $P_s$ 和调用 $W$ 的顺序，同时要考虑到 $C$ 可能小至 $1$。\n\n需要实现的模拟规则：\n\n- 程序必须内部建模 $P_r$ 和 $P_s$ 操作的发布、它们的匹配以及在 $V  V_\\mathrm{RZ}$ 时会合约束下的完成过程。\n- 发布一个 $P_s$ 会使处理器的未完成发送计数增加 $1$；该发送的完成会使其减少 $1$。\n- $P_r$ 可以在任何时候发布，并且不消耗能力。\n- 在会合模式下的发送只有在目标发布了匹配的 $P_r$ 后才能完成。\n- 针对一个轴的等待操作 $W$ 必须确保该轴所有已发布的操作完成后才能进入下一个轴。\n- 如果在 $W$ 期间，由于能力或排序约束，没有操作可以完成，也无法进行进一步的发布，则模拟宣布该测试用例死锁。\n\n您的程序应实现您的排序策略，并针对一组测试用例报告光环交换是否无死锁地完成。使用 $V_\\mathrm{RZ} = 512$ 字节。测试套件中所有消息体积 $V$ 的单位都是字节。\n\n测试套件（每个用例是一个元组 $(N_x,N_y,N_z,V,C)$）：\n\n- 用例 $1$：$(2,2,2,4096,1)$，会合模式，平衡网格；预期完成。\n- 用例 $2$：$(4,1,1,4096,1)$，会合模式，$x$ 轴线状分解；预期完成。\n- 用例 $3$：$(3,3,1,8192,1)$，会合模式，板状分解；预期完成。\n- 用例 $4$：$(3,3,3,8192,1)$，会合模式，立方体网格；预期完成。\n- 用例 $5$：$(2,2,2,8192,0)$，会合模式，注入能力为零；预期死锁。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 \"[$r_1$,$r_2$,$r_3$,$r_4$,$r_5$]\"，其中每个 $r_i$ 是一个布尔值，表示用例 $i$ 的光环交换是完成（$\\mathrm{True}$）还是死锁（$\\mathrm{False}$）。",
            "solution": "该问题要求为 $3$ 维笛卡尔处理器网格设计并模拟一种无死锁的非阻塞光环交换算法。该算法必须在用于大消息的会合通信协议和受限的单处理器注入能力 $C$（可低至 $1$）的条件下正确运行。\n\n### 基于原则的设计\n\n主要挑战是避免死锁。死锁通常源于循环的“等待”依赖关系。在我们的情境中，当两个或多个处理器互相等待对方为自己已发布的会合发送（$P_s$）发布一个接收（$P_r$）时，就会发生这种情况。在注入能力 $C$ 有限的情况下，一个处理器可能会在发布发送时用尽其能力，从而无法继续发布其邻居所需要的接收。\n\n正如问题描述中所暗示的，标准且最健壮的解决方案是通过将通信分阶段构建来打破这些循环依赖。\n\n1.  **维度分阶段**：将完整的 $3D$ 光环交换分解为三个独立的、顺序的交换，每个轴（$x$、$y$ 和 $z$）一次。在每次轴交换之间放置一个全局同步屏障（一个等待操作 $W$）。这确保了例如，没有处理器会等待来自 $x$ 轴上一个邻居的消息，而该邻居又在等待来自 $y$ 轴的消息。这将所有依赖关系在同一时间限制在单个轴内。\n\n2.  **基于奇偶性的角色分阶段（棋盘格模式）**：在单次轴交换内部，我们仍必须防止相邻处理器之间（例如，处理器 $i$ 和 $i+1$ 同时向对方发送）的死锁。这通过根据处理器坐标的奇偶性分配角色来解决。沿一个轴的交换被分为两个阶段：\n    -   **阶段 1**：沿该轴具有偶数坐标索引的处理器被指定为“发送方”，而具有奇数坐标索引的处理器被指定为“接收方”。偶数索引的处理器向其奇数索引的邻居发布发送（$P_s$），而奇数索引的处理器从其偶数索引的邻居发布接收（$P_r$）。因为发送只从偶数处理器定向到奇数处理器，所以等待图是一个有向无环图（DAG），不会发生死锁。来自偶数处理器的会合发送总能在其奇数编号的目标处找到一个已经发布的相应接收。\n    -   **阶段 2**：角色反转。奇数索引的处理器成为“发送方”，偶数索引的处理器成为“接收方”。此阶段处理相反方向的通信，出于同样的原因也是无死锁的，并完成了该轴的双向光环交换。\n\n当注入能力 $C$ 很小时，这种基于奇偶性的两阶段方法对正确性至关重要。对于 $C=1$ 的情况，一个拥有两个邻居的发送处理器一次只能发布一个发送。模拟必须正确地建模这个发送的完成（因为其目标在此阶段是只接收的处理器），从而释放注入能力，以便第二个发送可以被发布和完成。\n\n### 模拟算法\n\n模拟将根据规则对每个处理器的状态和通信操作的进展进行建模。\n\n-   **处理器状态**：位于坐标 $(i, j, k)$ 的每个处理器都被建模为一个维护其状态的对象：\n    -   注入能力：$C$。\n    -   `outstanding_sends`：已发布但尚未完成的发送操作列表。此列表的大小不能超过 $C$。\n    -   `pending_sends`：已准备好发布但因注入能力已满而被阻塞的发送操作队列。\n    -   `posted_receives`：已发布的接收操作列表。\n\n-   **等待操作 ($W$) 模拟**：`wait` 操作被实现为一个模拟循环，该循环持续进行直到无法取得更多进展。在每次迭代中，循环执行两个主要操作：\n    1.  **检查完成情况**：它扫描所有的 `outstanding_sends`。一个发送操作如果处于饥饿模式 ($V \\le V_\\mathrm{RZ}$)，或者在目标处理器上存在匹配的 `posted_receive`，则可以完成。完成后，该发送将从 `outstanding_sends` 中移除，从而释放注入能力。\n    2.  **发布待处理的发送**：它扫描所有处理器。如果一个处理器有 `pending_sends` 并且有可用的注入能力（因为之前的发送已完成），它会将一个待处理的发送移至其 `outstanding_sends` 列表。\n\n-   **死锁检测**：如果在 `wait` 循环的一次完整迭代中，没有发送可以完成，也没有新的发送可以发布，但仍有未完成的工作（即，非空的 `outstanding_sends` 或 `pending_sends` 列表），则模拟处于死锁状态。\n\n-   **整体流程**：\n    1.  初始化 $N_x \\times N_y \\times N_z$ 的处理器网格。\n    2.  对于 {$x, y, z$} 中的每个轴 `d`：\n        a.  **阶段 1 (偶数 → 奇数)**：\n            i.  所有在轴 `d` 上的奇数索引处理器发布它们所有来自邻居的接收。\n            ii. 所有在轴 `d` 上的偶数索引处理器发布它们向邻居的发送（如果能力超限则排入待处理队列）。\n            iii. 执行 `wait` 模拟循环。如果返回死锁，则整个交换失败。\n        b.  **阶段 2 (奇数 → 偶数)**：\n            i.  所有偶数索引的处理器发布接收。\n            ii. 所有奇数索引的处理器发布发送。\n            iii. 执行 `wait` 模拟循环。如果返回死锁，则交换失败。\n    3.  如果所有轴的所有阶段都成功完成，则光环交换成功。\n\n对于 $C \\ge 1$ 的情况，此设计保证是无死锁的。对于 $C=0$ 的测试用例，没有任何处理器能够发布发送，这会导致一个立即发生并被正确识别的死锁。",
            "answer": "```python\nimport numpy as np\nfrom collections import namedtuple\n\n# Define simple data structures for communication operations\nSendOperation = namedtuple('SendOperation', ['dest_coords'])\nRecvOperation = namedtuple('RecvOperation', ['source_coords'])\n\nclass Processor:\n    \"\"\"Models a single processor in the Cartesian grid.\"\"\"\n    \n    def __init__(self, coords, capacity):\n        self.coords = coords\n        self.capacity = capacity\n        self.reset_phase_state()\n\n    def reset_phase_state(self):\n        \"\"\"Resets the state for a new communication phase.\"\"\"\n        self.pending_sends = []\n        self.outstanding_sends = []\n        self.posted_receives = []\n\n    def post_send(self, dest_coords):\n        \"\"\"Posts a send operation, respecting injection capacity.\"\"\"\n        op = SendOperation(dest_coords=dest_coords)\n        if len(self.outstanding_sends)  self.capacity:\n            self.outstanding_sends.append(op)\n        else:\n            self.pending_sends.append(op)\n            \n    def post_receive(self, source_coords):\n        \"\"\"Posts a receive operation.\"\"\"\n        op = RecvOperation(source_coords=source_coords)\n        self.posted_receives.append(op)\n\ndef simulate_wait_phase(processors, is_rendezvous):\n    \"\"\"\n    Simulates the network until all posted operations complete for a phase.\n    Returns True on success, False on deadlock.\n    \"\"\"\n    while True:\n        made_progress = False\n\n        # --- Part 1: Try to complete outstanding sends ---\n        # We iterate over a snapshot of all sends to allow modification of lists during the loop\n        sends_to_check = []\n        for p in processors.values():\n            for send_op in p.outstanding_sends:\n                sends_to_check.append((p, send_op))\n        \n        for sender_proc, send_op in sends_to_check:\n            # Check if this send is still outstanding (might have been completed already in this loop)\n            if send_op not in sender_proc.outstanding_sends:\n                continue\n\n            dest_proc = processors[send_op.dest_coords]\n            \n            matching_recv = next((recv for recv in dest_proc.posted_receives if recv.source_coords == sender_proc.coords), None)\n            \n            can_complete = (not is_rendezvous) or (is_rendezvous and matching_recv is not None)\n            \n            if can_complete:\n                sender_proc.outstanding_sends.remove(send_op)\n                if matching_recv:\n                    dest_proc.posted_receives.remove(matching_recv)\n                made_progress = True\n\n        # --- Part 2: Try to post pending sends ---\n        for p in processors.values():\n            while p.pending_sends and len(p.outstanding_sends)  self.capacity:\n                op_to_post = p.pending_sends.pop(0)\n                p.outstanding_sends.append(op_to_post)\n                made_progress = True\n\n        # --- Part 3: Check for completion or deadlock ---\n        all_done = all(not p.pending_sends and not p.outstanding_sends for p in processors.values())\n        \n        if all_done:\n            # All posted and pending sends for this phase are complete.\n            # We must also check that all receives were matched.\n            if any(p.posted_receives for p in processors.values()):\n                # This indicates an asymmetry or error in the algorithm setup\n                return False \n            return True # Phase successful\n\n        if not made_progress:\n            return False # Deadlock: work remains but no progress was made.\n\ndef run_simulation(Nx, Ny, Nz, V, C):\n    \"\"\"\n    Runs the simulation for a single test case.\n    Returns True if the halo exchange completes, False if it deadlocks.\n    \"\"\"\n    V_RZ = 512\n    is_rendezvous = V > V_RZ\n    \n    processors = {\n        (i, j, k): Processor(coords=(i, j, k), capacity=C)\n        for i in range(Nx) for j in range(Ny) for k in range(Nz)\n    }\n\n    dimensions = [(0, Nx), (1, Ny), (2, Nz)]\n\n    for dim_idx, N_dim in dimensions:\n        if N_dim = 1:\n            continue\n\n        # --- Phase 1: Even-indexed processors send, Odd-indexed receive ---\n        for p in processors.values():\n            p.reset_phase_state()\n\n        # Odd processors post receives from their even neighbors\n        for coords, proc in processors.items():\n            if coords[dim_idx] % 2 != 0:\n                if coords[dim_idx] > 0: # has negative neighbor\n                    neg_coords = list(coords); neg_coords[dim_idx] -= 1\n                    proc.post_receive(source_coords=tuple(neg_coords))\n                if coords[dim_idx]  N_dim - 1: # has positive neighbor\n                    pos_coords = list(coords); pos_coords[dim_idx] += 1\n                    proc.post_receive(source_coords=tuple(pos_coords))\n\n        # Even processors post sends to their odd neighbors\n        for coords, proc in processors.items():\n            if coords[dim_idx] % 2 == 0:\n                if coords[dim_idx] > 0: # has negative neighbor\n                    neg_coords = list(coords); neg_coords[dim_idx] -= 1\n                    proc.post_send(dest_coords=tuple(neg_coords))\n                if coords[dim_idx]  N_dim - 1: # has positive neighbor\n                    pos_coords = list(coords); pos_coords[dim_idx] += 1\n                    proc.post_send(dest_coords=tuple(pos_coords))\n\n        if not simulate_wait_phase(processors, is_rendezvous):\n            return False\n\n        # --- Phase 2: Odd-indexed processors send, Even-indexed receive ---\n        for p in processors.values():\n            p.reset_phase_state()\n\n        # Even processors post receives from their odd neighbors\n        for coords, proc in processors.items():\n            if coords[dim_idx] % 2 == 0:\n                if coords[dim_idx] > 0:\n                    neg_coords = list(coords); neg_coords[dim_idx] -= 1\n                    proc.post_receive(source_coords=tuple(neg_coords))\n                if coords[dim_idx]  N_dim - 1:\n                    pos_coords = list(coords); pos_coords[dim_idx] += 1\n                    proc.post_receive(source_coords=tuple(pos_coords))\n\n        # Odd processors post sends to their even neighbors\n        for coords, proc in processors.items():\n            if coords[dim_idx] % 2 != 0:\n                if coords[dim_idx] > 0:\n                    neg_coords = list(coords); neg_coords[dim_idx] -= 1\n                    proc.post_send(dest_coords=tuple(neg_coords))\n                if coords[dim_idx]  N_dim - 1:\n                    pos_coords = list(coords); pos_coords[dim_idx] += 1\n                    proc.post_send(dest_coords=tuple(pos_coords))\n\n        if not simulate_wait_phase(processors, is_rendezvous):\n            return False\n\n    return True\n\ndef solve():\n    test_cases = [\n        (2, 2, 2, 4096, 1),\n        (4, 1, 1, 4096, 1),\n        (3, 3, 1, 8192, 1),\n        (3, 3, 3, 8192, 1),\n        (2, 2, 2, 8192, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, Nz, V, C = case\n        result = run_simulation(Nx, Ny, Nz, V, C)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}