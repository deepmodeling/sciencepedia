{
    "hands_on_practices": [
        {
            "introduction": "在嵌套模型中，稳定而准确的模拟需要对父模型和子模型的时间步长进行仔细协调。本练习将引导您基于数值建模的基本原则——CFL条件，推导子循环的时间表。通过这项实践，您将学会如何检查时间步长的完美同步性，以避免因侧边界条件（LBC）更新不一致而产生的误差 。",
            "id": "4032922",
            "problem": "考虑一个用于数值天气预报的单向嵌套区域模型，该模型嵌入在一个较粗糙的母模型中。母模型在时间步长为 $\\Delta t_p$ 的均匀时间网格上推进预报场，而嵌套的子模型在时间步长为 $\\Delta t_c$ 的更精细的时间网格上推进。子模型从母模型接收侧边界条件（LBC），这些条件在母模型的时间层上更新，并在连续的母模型更新之间保持分段常数。假设细化比为 $r$（由空间网格比定义），并且使用时间子循环，以便子模型在每个母模型步长内执行多个子步。\n\n从线性平流方案的 Courant–Friedrichs–Lewy (CFL) 条件和嵌套网格上离散时间步长的定义出发，推导在单个母模型时间区间 $[t_n, t_{n+1}]$ 内的子模型子循环调度，用母模型时间层 $t_n = t_0 + n \\,\\Delta t_p$、子模型子步索引 $k \\in \\{1,\\dots,r\\}$ 以及时间步长 $\\Delta t_p$ 和 $\\Delta t_c$ 来表示。将您的结果具体化到 $r = 3$、$\\Delta t_p = 60$ s 以及子模型要求 $\\Delta t_c = 20$ s 的情况。然后，为了验证 LBC 更新与子模型子循环的时间一致性，定义 LBC 一致性残差\n$$\n\\delta \\equiv \\Delta t_p - r\\,\\Delta t_c,\n$$\n该残差衡量了母模型更新间隔与一整套 $r$ 个子模型子步的累积持续时间之间的不匹配程度。计算给定值下的 $\\delta$，并根据子模型的子步是否正好落在母模型的更新时间点上，或者是否需要对 LBC 进行时间插值来解释其值。\n\n以秒为单位，将 $\\delta$ 的值作为最终答案。最终答案中不需要推导过程。不需要四舍五入；报告精确值。",
            "solution": "问题陈述是有效的。它在科学上基于数值天气预报和气候建模的原理，特别是关于单向网格嵌套技术。母模型和子模型、时间步长细化、Courant–Friedrichs–Lewy (CFL) 条件以及侧边界条件 (LBC) 更新等概念都是标准的且定义明确的。该问题是自洽的、客观的且适定的，存在唯一且有意义的解。\n\n我们首先建立背景。在嵌套网格建模中，一个高分辨率的“子”模型被嵌入到一个低分辨率的“母”模型中。母模型为子模型提供初始状态和随时间变化的 LBC。为了在子模型更精细的空间网格（网格间距为 $\\Delta x_c$）上保持数值稳定性，通常需要比母模型的时间步长（$\\Delta t_p$）更小的时间步长（$\\Delta t_c$）。这是由 CFL 条件决定的，对于波速为 $u$ 的简单一维线性平流方程，该条件由下式给出：\n$$\nC = \\frac{u \\Delta t}{\\Delta x} \\le C_{\\text{max}}\n$$\n其中 $C$ 是 Courant 数，$C_{\\text{max}}$ 是一个常数，对于显式数值格式，其量级通常为 $1$。如果使用空间细化比 $r$，使得 $\\Delta x_c = \\Delta x_p / r$，那么为了在两个网格上保持相似的 Courant 数，时间步长必须近似满足关系 $\\Delta t_c \\approx \\Delta t_p / r$。这种做法被称为时间子循环，即母模型每执行一个时间步，子模型就执行 $r$ 个时间步。\n\n问题要求推导子模型的子循环调度。设母模型在由离散时间层 $t_n = t_0 + n \\Delta t_p$（整数 $n \\ge 0$）定义的时间网格上推进。考虑从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t_p$ 的单个母模型时间区间。子模型在此区间的积分始于时间 $t_n$，使用母模型提供的在时间 $t_n$ 有效的 LBC。这些 LBC 保持分段常数，直到下一个母模型更新时间 $t_{n+1}$。\n\n子模型执行 $r$ 个子步，每个子步的持续时间为 $\\Delta t_c$。令 $\\tau_{n,k}$ 表示在第 $n$ 个母模型区间内第 $k$ 个子模型子步*结束*时的时间，其中子步索引为 $k \\in \\{1, 2, \\dots, r\\}$。\n第一个子步从 $t_n$ 开始，结束于：\n$$\n\\tau_{n,1} = t_n + \\Delta t_c\n$$\n第二个子步从 $\\tau_{n,1}$ 开始，结束于：\n$$\n\\tau_{n,2} = \\tau_{n,1} + \\Delta t_c = (t_n + \\Delta t_c) + \\Delta t_c = t_n + 2 \\Delta t_c\n$$\n将其推广，第 $k$ 个子步结束时的时间由下式给出：\n$$\n\\tau_{n,k} = t_n + k \\Delta t_c\n$$\n代入母模型时间层 $t_n = t_0 + n \\Delta t_p$ 的表达式，我们得到子模型离散时间层的通用公式：\n$$\n\\tau_{n,k} = t_0 + n \\Delta t_p + k \\Delta t_c, \\quad \\text{其中 } n \\ge 0 \\text{ 且 } k \\in \\{1, 2, \\dots, r\\}\n$$\n这就是子模型的子循环调度。\n\n对于给定的具体情况，我们有细化比 $r = 3$，母模型时间步长 $\\Delta t_p = 60$ s，以及子模型时间步长 $\\Delta t_c = 20$ s。对于每个 60 s 的母模型步长，子模型将执行 3 个各为 20 s 的子步。对于一个从 $t_n$ 开始的母模型区间，子模型的时间将是：\n-   第1个子步结束：$\\tau_{n,1} = t_n + 1 \\times 20 \\text{ s}$\n-   第2个子步结束：$\\tau_{n,2} = t_n + 2 \\times 20 \\text{ s} = t_n + 40 \\text{ s}$\n-   第3个子步结束：$\\tau_{n,3} = t_n + 3 \\times 20 \\text{ s} = t_n + 60 \\text{ s}$\n母模型的下一个时间层是 $t_{n+1} = t_n + \\Delta t_p = t_n + 60$ s。我们观察到 $\\tau_{n,3} = t_{n+1}$，这表明完美的同步。\n\n接下来，我们计算并解释 LBC 一致性残差 $\\delta$。该量定义为：\n$$\n\\delta \\equiv \\Delta t_p - r \\Delta t_c\n$$\n这个残差衡量了母模型一个时间步长的持续时间 $\\Delta t_p$ 与子模型 $r$ 个子步完整循环的总累积时间 $r \\Delta t_c$ 之间的时间不匹配程度。\n\n使用给定值 $r=3$，$\\Delta t_p = 60$ s 和 $\\Delta t_c = 20$ s，我们计算 $\\delta$：\n$$\n\\delta = 60 \\text{ s} - (3)(20 \\text{ s}) = 60 \\text{ s} - 60 \\text{ s} = 0 \\text{ s}\n$$\n\n这个结果的解释如下：\n$\\delta = 0$ 的值表示母模型和子模型之间存在完美的时间同步。子模型的最后一个子步（第 $r$ 个子步）在母模型完成其时间步并为下一个区间提供新的 LBC 的确切时刻结束。在这种情况下，在时间 $t_n$、$t_{n+1}$ 等更新并保持分段常数的 LBC 可以应用于子模型，而没有任何时间上的模糊性或插值需求。子模型在准备开始其下一轮子步循环时，恰好接收到时间 $t_{n+1}$ 的边界数据。\n\n如果 $\\delta$ 非零，则表示存在时间上的不同步。例如，如果 $\\delta > 0$，子模型将在母模型提供新的 LBC 之前完成其 $r$ 个子步。如果 $\\delta  0$，母模型的更新时间将在子模型完成其全部 $r$ 个子步之前到来。在这两种异步情况（$\\delta \\neq 0$）中的任何一种，简单地分段常数应用 LBC 都会产生问题。为了保持准确性，通常需要将 LBC 从母模型的输出时间（$t_n, t_{n+1}$）进行时间插值（例如，线性插值）到子模型边界所需的特定时间。$\\delta=0$ 这一事实证实了正在使用理想且最简单的耦合策略。\n\n要求的最终答案是 $\\delta$ 的值，单位为秒。\n$$\n\\delta = 0\n$$",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "在建立了基本的时间结构之后，我们必须解决子模型如何在其边界上平滑地吸收来自父模型的信息。本练习探讨了牛顿松弛法，这是一种在缓冲区广泛使用的技术，用于衰减虚假波并防止解的不连续性。您将推导出一个扰动在穿过缓冲区时其振幅是如何衰减的，从而对这一关键机制的工作原理获得定量的理解 。",
            "id": "4032871",
            "problem": "一个侧向宽度为 $600 \\, \\mathrm{km}$ 的单向嵌套局地模式 (LAM) 采用了一个宽度均匀为 $W=60 \\, \\mathrm{km}$ 的侧向缓冲带，在该缓冲带内，以恒定的弛豫时间尺度 $\\tau=600 \\, \\mathrm{s}$ 随时间均匀地应用牛顿弛豫（也称为Davies型弛豫）。考虑一个被动标量振幅为 $a$ 的天气尺度扰动，它从外边界进入缓冲带，并以垂直于边界的恒定相速 $U=15 \\, \\mathrm{m\\,s^{-1}}$ 稳定地向内平流。假设该扰动在缓冲带内仅通过线性平流和线性牛顿弛豫演变，没有源、汇或非线性项，且 $a$ 足够小以支持线性叠加。\n\n从线性平流和沿拉格朗日轨迹的牛顿弛豫的基本原理出发，推导衰减因子 $A$ 的表达式，该因子定义为扰动在缓冲带内边界处的振幅与在外边界处的振幅之比。然后根据给定参数计算 $A$ 的值。将最终答案表示为一个无量纲数，并四舍五入到三位有效数字。",
            "solution": "该问题涉及一个在缓冲带内受牛顿弛豫影响的被动平流扰动的振幅演变。其基本要素是：\n\n1. 物质守恒量的线性平流意味着，沿拉格朗日轨迹，仅平流本身不会改变振幅 $a$；物质变化由非平流过程引起。\n2. 振幅为 $a$、时间尺度为 $\\tau$ 的扰动的牛顿弛豫会施加一个与 $-a/\\tau$ 成正比的线性阻尼趋势。\n\n令 $a(t)$ 表示气块穿过缓冲带时扰动的振幅。在所述假设下，缓冲带内沿拉格朗日轨迹的振幅演变由以下常微分方程控制：\n$$\n\\frac{\\mathrm{d}a}{\\mathrm{d}t} \\;=\\; -\\frac{1}{\\tau}\\,a.\n$$\n该方程源于这样一个事实：平流输送 $a$ 而不沿轨迹改变它，而唯一作用于 $a$ 的局地过程是速率为 $1/\\tau$ 的牛顿弛豫。\n\n通过分离变量法求解这个线性常微分方程，得到：\n$$\n\\frac{\\mathrm{d}a}{a} \\;=\\; -\\frac{\\mathrm{d}t}{\\tau}\n\\quad\\Rightarrow\\quad\n\\ln a(t) - \\ln a(0) \\;=\\; -\\frac{t}{\\tau}\n\\quad\\Rightarrow\\quad\na(t) \\;=\\; a(0)\\,\\exp\\!\\left(-\\frac{t}{\\tau}\\right).\n$$\n扰动在时间 $t=0$ 时从外边界进入缓冲带，并在时间 $t=t_{\\mathrm{buf}}$ 时从内边界离开缓冲带。以速度 $U$ 穿过宽度为 $W$ 的缓冲带所需的时间是平流时间：\n$$\nt_{\\mathrm{buf}} \\;=\\; \\frac{W}{U}.\n$$\n因此，衰减因子 $A$（定义为内边界振幅与外边界振幅之比）为：\n$$\nA \\;\\equiv\\; \\frac{a(t_{\\mathrm{buf}})}{a(0)} \\;=\\; \\exp\\!\\left(-\\frac{t_{\\mathrm{buf}}}{\\tau}\\right) \\;=\\; \\exp\\!\\left(-\\frac{W}{U\\,\\tau}\\right).\n$$\n\n对于给定的值 $W=60 \\, \\mathrm{km}=60{,}000 \\, \\mathrm{m}$，$U=15 \\, \\mathrm{m\\,s^{-1}}$ 和 $\\tau=600 \\, \\mathrm{s}$，我们计算：\n$$\nt_{\\mathrm{buf}} \\;=\\; \\frac{60{,}000\\ \\mathrm{m}}{15\\ \\mathrm{m}\\ \\mathrm{s}^{-1}} \\;=\\; 4{,}000\\ \\mathrm{s},\n$$\n因此，\n$$\n\\frac{t_{\\mathrm{buf}}}{\\tau} \\;=\\; \\frac{4{,}000\\ \\mathrm{s}}{600\\ \\mathrm{s}} \\;=\\; \\frac{20}{3} \\;\\approx\\; 6.666\\overline{6}.\n$$\n于是，\n$$\nA \\;=\\; \\exp\\!\\left(-\\frac{20}{3}\\right) \\;\\approx\\; 1.2726338\\times 10^{-3}.\n$$\n\n四舍五入到三位有效数字，衰减因子为 $1.27\\times 10^{-3}$。解释这个值，扰动在穿过缓冲带时经历了大约 $6.67$ 次e折衰减，这在缓冲带渡越时间内强烈地阻尼了传入的天气尺度扰动，表明所选的弛豫时间尺度对于 $U=15 \\, \\mathrm{m\\,s^{-1}}$ 的天气尺度运动是足够的。然而，根据要求，最终答案是 $A$ 的数值。",
            "answer": "$$\\boxed{1.27 \\times 10^{-3}}$$"
        },
        {
            "introduction": "动力降尺度的最终目标是通过提供更准确或更详细的局地预报来增加价值。这项实践将我们的重点从模型力学转移到模型评估，特别是针对强降水等极端事件，使用现代检验技术。您将应用基于分位数的技巧评分来量化高分辨率子模型是否确实比父模型的预报有所改进，这是证明嵌套模型计算成本合理性的关键一步 。",
            "id": "4032939",
            "problem": "考虑数值天气预报（NWP）中的一个嵌套动力降尺度设置，其中一个$12\\,\\mathrm{km}$的“父”模型提供侧边界条件，一个$3\\,\\mathrm{km}$的“子”模型在更小的区域上精细化求解。针对以极端降水为特征的事件，使用聚合到$5\\,\\mathrm{km}$尺度的观测数据进行验证。目标是量化父模型和子模型在极端分位数技巧上的差异，并解释子模型的附加价值。请完全使用以下定义和测试数据以数学术语进行分析。\n\n定义：\n- 令 $\\tau \\in (0,1)$ 表示分位数水平。对于极端情况，取接近$1$的$\\tau$值（例如，$\\tau=0.98$）。\n- 对于一组$n$个验证点，其观测降水强度为$y_i$（单位：$\\mathrm{mm}/\\mathrm{h}$），模型的预测$\\tau$-分位数为$q_i$，定义分位数评分（QS），也称为弹球损失（pinball loss），为\n$$\n\\mathrm{QS}_\\tau(y,q) \\equiv \\frac{1}{n}\\sum_{i=1}^{n} \\left(\\tau - \\mathbb{I}\\{y_i  q_i\\}\\right)\\,(y_i - q_i),\n$$\n其中 $\\mathbb{I}\\{\\cdot\\}$ 是指示函数。\n- 给定一个公共的参考分位数预测量$q_i^{\\mathrm{ref}}$（例如，气候学的$\\tau$-分位数），且$\\mathrm{QS}_\\tau(y,q^{\\mathrm{ref}})  0$，则对于一个分位数预测为$q$的模型，其分位数评分技巧（QSS）定义为\n$$\n\\mathrm{QSS}_\\tau(y,q; q^{\\mathrm{ref}}) \\equiv 1 - \\frac{\\mathrm{QS}_\\tau(y,q)}{\\mathrm{QS}_\\tau(y,q^{\\mathrm{ref}})}.\n$$\n$\\mathrm{QSS}_\\tau$的值越高，表示相对于参考预报的技巧越好。\n- 定义技巧差异\n$$\n\\Delta \\mathrm{QSS}_\\tau \\equiv \\mathrm{QSS}_\\tau(y,q^{\\mathrm{child}}; q^{\\mathrm{ref}}) - \\mathrm{QSS}_\\tau(y,q^{\\mathrm{parent}}; q^{\\mathrm{ref}}),\n$$\n其中$q^{\\mathrm{parent}}$和$q^{\\mathrm{child}}$分别是父模型和子模型的$\\tau$-分位数预测。$\\Delta \\mathrm{QSS}_\\tau$为正值表示相对于同一参考，子模型的技巧高于父模型。\n- 为了解释附加价值，还需考虑子模型相对于父模型在分位数评分方面的分数改进率：\n$$\n\\mathrm{AV}_\\tau \\equiv \\frac{\\mathrm{QS}_\\tau(y,q^{\\mathrm{parent}}) - \\mathrm{QS}_\\tau(y,q^{\\mathrm{child}})}{\\mathrm{QS}_\\tau(y,q^{\\mathrm{parent}})}.\n$$\n$\\mathrm{AV}_\\tau$为正值表示子模型带来了附加价值。\n\n使用以下测试集，其中$\\tau = 0.98$，降水强度单位为$\\mathrm{mm}/\\mathrm{h}$：\n\n- 测试用例1（包含无雨点和强降水点的综合性极端事件）：\n  - 观测值 $y$：$[0, 12, 35, 0.5, 60, 80]$。\n  - 父模型$\\tau$-分位数预测值 $q^{\\mathrm{parent}}$：$[5, 20, 40, 5, 50, 70]$。\n  - 子模型$\\tau$-分位数预测值 $q^{\\mathrm{child}}$：$[3, 25, 45, 2, 55, 85]$。\n  - 参考$\\tau$-分位数预测值 $q^{\\mathrm{ref}}$：$[10, 10, 10, 10, 10, 10]$。\n\n- 测试用例2（父模型和子模型预测相同的边界条件情况）：\n  - 观测值 $y$：$[10, 10, 10, 10]$。\n  - 父模型$\\tau$-分位数预测值 $q^{\\mathrm{parent}}$：$[12, 12, 12, 12]$。\n  - 子模型$\\tau$-分位数预测值 $q^{\\mathrm{child}}$：$[12, 12, 12, 12]$。\n  - 参考$\\tau$-分位数预测值 $q^{\\mathrm{ref}}$：$[15, 15, 15, 15]$。\n\n- 测试用例3（结合无雨点和极端强降水的边缘情况）：\n  - 观测值 $y$：$[0, 0, 0, 40, 100]$。\n  - 父模型$\\tau$-分位数预测值 $q^{\\mathrm{parent}}$：$[5, 5, 5, 50, 90]$。\n  - 子模型$\\tau$-分位数预测值 $q^{\\mathrm{child}}$：$[1, 1, 1, 60, 110]$。\n  - 参考$\\tau$-分位数预测值 $q^{\\mathrm{ref}}$：$[8, 8, 8, 40, 100]$。\n\n要求：\n- 实现上述定义，计算每个测试用例的$\\Delta \\mathrm{QSS}_\\tau$。\n- 所有降水值的单位均为$\\mathrm{mm}/\\mathrm{h}$；输出为无量纲的技巧差异。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3]$），其中每个$result_i$是测试用例$i$的$\\Delta \\mathrm{QSS}_\\tau$值，四舍五入到六位小数。",
            "solution": "我们从概率预报中$\\tau$-分位数估计量的定义出发，该定义基于最小化期望弹球损失。对于给定的$\\tau \\in (0,1)$和预报的$\\tau$-分位数$q$，单个观测值$y$的弹球损失由以下函数定义\n$$\n\\ell_\\tau(y,q) = \\left(\\tau - \\mathbb{I}\\{y  q\\}\\right)\\,(y - q).\n$$\n该损失是非负的，因为当$y \\ge q$时，该项为$\\tau (y - q) \\ge 0$；当$y  q$时，该项变为$(1-\\tau)(q - y) \\ge 0$。对$n$个验证点进行汇总，得到分位数评分（QS），\n$$\n\\mathrm{QS}_\\tau(y,q) = \\frac{1}{n}\\sum_{i=1}^{n} \\ell_\\tau(y_i,q_i) = \\frac{1}{n}\\sum_{i=1}^{n}\\left(\\tau - \\mathbb{I}\\{y_i  q_i\\}\\right)\\,(y_i - q_i).\n$$\n$\\mathrm{QS}_\\tau$的值越低越好，因为它表示更小的弹球损失。\n\n为了获得相对于固定参考预报$q^{\\mathrm{ref}}$的技巧度量，我们将分位数评分技巧（QSS）定义为\n$$\n\\mathrm{QSS}_\\tau(y,q; q^{\\mathrm{ref}}) = 1 - \\frac{\\mathrm{QS}_\\tau(y,q)}{\\mathrm{QS}_\\tau(y,q^{\\mathrm{ref}})}.\n$$\n这种构造方式与传统技巧评分类似：如果$\\mathrm{QS}_\\tau(y,q)$远小于$\\mathrm{QS}_\\tau(y,q^{\\mathrm{ref}})$，那么$\\mathrm{QSS}_\\tau$接近$1$；如果模型比参考预报差，那么$\\mathrm{QSS}_\\tau$将为负值。\n\n子模型和父模型之间的技巧差异为\n$$\n\\Delta \\mathrm{QSS}_\\tau = \\mathrm{QSS}_\\tau(y,q^{\\mathrm{child}}; q^{\\mathrm{ref}}) - \\mathrm{QSS}_\\tau(y,q^{\\mathrm{parent}}; q^{\\mathrm{ref}})\n= \\left(1 - \\frac{\\mathrm{QS}_\\tau(y,q^{\\mathrm{child}})}{\\mathrm{QS}_\\tau(y,q^{\\mathrm{ref}})}\\right) - \\left(1 - \\frac{\\mathrm{QS}_\\tau(y,q^{\\mathrm{parent}})}{\\mathrm{QS}_\\tau(y,q^{\\mathrm{ref}})}\\right),\n$$\n简化后得到\n$$\n\\Delta \\mathrm{QSS}_\\tau = \\frac{\\mathrm{QS}_\\tau(y,q^{\\mathrm{parent}}) - \\mathrm{QS}_\\tau(y,q^{\\mathrm{child}})}{\\mathrm{QS}_\\tau(y,q^{\\mathrm{ref}})}.\n$$\n这表明$\\Delta \\mathrm{QSS}_\\tau$的符号和大小取决于父模型和子模型之间的弹球损失差异，并由参考损失进行缩放。正的$\\Delta \\mathrm{QSS}_\\tau$意味着子模型的弹球损失低于父模型，因此相对于同一参考预报具有更高的技巧。\n\n为了解释附加价值，我们还定义\n$$\n\\mathrm{AV}_\\tau = \\frac{\\mathrm{QS}_\\tau(y,q^{\\mathrm{parent}}) - \\mathrm{QS}_\\tau(y,q^{\\mathrm{child}})}{\\mathrm{QS}_\\tau(y,q^{\\mathrm{parent}})}.\n$$\n这是一个分数改进度量：$\\mathrm{AV}_\\tau  0$表示子模型相对于父模型减少了损失，其大小表示父模型损失中被消除的比例。\n\n算法步骤：\n1. 对所有测试用例，固定$\\tau = 0.98$。\n2. 对每个测试用例，读取数组$y$、$q^{\\mathrm{parent}}$、$q^{\\mathrm{child}}$和$q^{\\mathrm{ref}}$。\n3. 通过$\\ell_\\tau(y_i,q_i)$的公式并对所有点取平均，计算$q \\in \\{q^{\\mathrm{parent}}, q^{\\mathrm{child}}, q^{\\mathrm{ref}}\\}$的$\\mathrm{QS}_\\tau(y,q)$。\n4. 使用参考预报计算父模型和子模型的$\\mathrm{QSS}_\\tau$。\n5. 计算子模型和父模型技巧的差值$\\Delta \\mathrm{QSS}_\\tau$。\n6. 将每个$\\Delta \\mathrm{QSS}_\\tau$四舍五入到六位小数，并按规定将三个结果输出到单个列表中。\n\n测试用例1的解析验证（以确认量级）：\n- 使用$\\tau = 0.98$，计算每一点的弹球损失并取平均值，得到$\\mathrm{QS}_\\tau(y,q^{\\mathrm{parent}}) \\approx 3.341667$，$\\mathrm{QS}_\\tau(y,q^{\\mathrm{child}}) \\approx 0.925000$，以及$\\mathrm{QS}_\\tau(y,q^{\\mathrm{ref}}) \\approx 24.075000$。\n- 然后，$\\mathrm{QSS}_\\tau(y,q^{\\mathrm{parent}}; q^{\\mathrm{ref}}) \\approx 1 - 3.341667/24.075 \\approx 0.8613$，$\\mathrm{QSS}_\\tau(y,q^{\\mathrm{child}}; q^{\\mathrm{ref}}) \\approx 1 - 0.925/24.075 \\approx 0.9616$，得出$\\Delta \\mathrm{QSS}_\\tau \\approx 0.1003  0$，表明子模型具有更高的技巧和正的附加价值。\n\n对于测试用例2，由于$q^{\\mathrm{child}} = q^{\\mathrm{parent}}$，两个技巧评分相等，因此$\\Delta \\mathrm{QSS}_\\tau = 0$，意味着没有附加价值。\n\n对于测试用例3，子模型相对于父模型显著减少了弹球损失，而参考预报在强降水点上异常接近观测值，导致$\\mathrm{QS}_\\tau(y,q^{\\mathrm{ref}})$很小，从而得到一个大的正值$\\Delta \\mathrm{QSS}_\\tau$。这对应于子模型在表示极端情况方面具有很强的附加价值。\n\n程序实现了这些步骤以生成所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef quantile_score(y: np.ndarray, q: np.ndarray, tau: float) - float:\n    \"\"\"\n    Compute the Quantile Score (pinball loss) for quantile level tau.\n    QS_tau(y,q) = mean( (tau - I[y  q]) * (y - q) )\n    \"\"\"\n    indicator = (y  q).astype(float)\n    loss = (tau - indicator) * (y - q)\n    return float(np.mean(loss))\n\ndef compute_delta_qss(y: np.ndarray, q_parent: np.ndarray, q_child: np.ndarray,\n                      q_ref: np.ndarray, tau: float) - float:\n    \"\"\"\n    Compute ΔQSS_tau = QSS_child - QSS_parent using a common reference.\n    \"\"\"\n    qs_parent = quantile_score(y, q_parent, tau)\n    qs_child = quantile_score(y, q_child, tau)\n    qs_ref = quantile_score(y, q_ref, tau)\n    # To avoid division by zero (should not occur with provided test cases),\n    # add a minimal epsilon safeguard if qs_ref is extremely small.\n    eps = 1e-12\n    denom = qs_ref if qs_ref > eps else eps\n    qss_parent = 1.0 - (qs_parent / denom)\n    qss_child = 1.0 - (qs_child / denom)\n    delta_qss = qss_child - qss_parent\n    return delta_qss\n\ndef solve():\n    tau = 0.98\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        (\n            np.array([0.0, 12.0, 35.0, 0.5, 60.0, 80.0]),\n            np.array([5.0, 20.0, 40.0, 5.0, 50.0, 70.0]),\n            np.array([3.0, 25.0, 45.0, 2.0, 55.0, 85.0]),\n            np.array([10.0, 10.0, 10.0, 10.0, 10.0, 10.0]),\n        ),\n        # Test Case 2\n        (\n            np.array([10.0, 10.0, 10.0, 10.0]),\n            np.array([12.0, 12.0, 12.0, 12.0]),\n            np.array([12.0, 12.0, 12.0, 12.0]),\n            np.array([15.0, 15.0, 15.0, 15.0]),\n        ),\n        # Test Case 3\n        (\n            np.array([0.0, 0.0, 0.0, 40.0, 100.0]),\n            np.array([5.0, 5.0, 5.0, 50.0, 90.0]),\n            np.array([1.0, 1.0, 1.0, 60.0, 110.0]),\n            np.array([8.0, 8.0, 8.0, 40.0, 100.0]),\n        ),\n    ]\n\n    results = []\n    for (y, q_parent, q_child, q_ref) in test_cases:\n        delta_qss = compute_delta_qss(y, q_parent, q_child, q_ref, tau)\n        # Round to six decimal places as required\n        results.append(round(delta_qss, 6))\n\n    # Final print statement in the exact required format (no spaces).\n    print(\"[\" + \",\".join(f\"{r:.6f}\" for r in results) + \"]\")\n\nsolve()\n```"
        }
    ]
}