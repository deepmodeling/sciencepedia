{
    "hands_on_practices": [
        {
            "introduction": "数值天气预报和气候模型对极端事件的准确模拟，在很大程度上取决于其核心的数值方案能否精确地捕捉和维持物理量（如水汽）的陡峭梯度。本实践练习  将通过一个一维平流-凝结模型，让您亲手实现并对比两种差异显著的数值平流方案：一种是简单但具有强数值耗散的一阶迎风方案，另一种是能更好地保持梯度的非线性高分辨率方案。通过这项练习，您将直观地理解数值方法的选择如何直接影响模拟的降水极值强度，这是理解和评估模型性能的关键一步。",
            "id": "4065906",
            "problem": "考虑一个长度为 $L$ 的一维周期性域，该域被离散化为 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀网格。设 $q(x,t)$ 表示水汽比湿（混合比），单位为 $\\mathrm{kg}\\,\\mathrm{kg}^{-1}$，由一个恒定的风速 $u$（单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$）输送。$q$ 的演变由带有凝结汇的守恒律控制\n$$\n\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = -S(q),\n$$\n其中凝结汇 $S(q)$ 表示水汽向降水的转化，其表达式为\n$$\nS(q) = \\max\\left(0, \\frac{q - q_s}{\\tau_c}\\right),\n$$\n其中 $q_s$ 是饱和比湿，单位为 $\\mathrm{kg}\\,\\mathrm{kg}^{-1}$，$\\tau_c$ 是凝结时间尺度，单位为 $\\mathrm{s}$。假设大气为单层，深度为 $H$（单位为 $\\mathrm{m}$），空气密度为 $\\rho_{\\mathrm{air}}$（单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$）。单位面积的瞬时降水率是垂直积分的凝结质量通量，\n$$\nP(x,t) = \\rho_{\\mathrm{air}}\\,H\\,S(q(x,t)),\n$$\n单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$。为了以 $\\mathrm{mm}\\,\\mathrm{hr}^{-1}$ 为单位报告降水强度，使用 $1\\,\\mathrm{mm}$ 的降雨量对应于 $1\\,\\mathrm{kg}\\,\\mathrm{m}^{-2}$ 的水量这一恒等关系，因此转换公式为\n$$\nP_{\\mathrm{mm/hr}}(x,t) = 3600\\,P(x,t).\n$$\n\n您的任务是为周期性域上的平流-汇方程实现两种显式有限体积数值格式：\n\n1.  一种一阶迎风格式（表示为 U1），它根据 $u$ 的符号使用迎风偏置的数值通量进行平流计算，并对汇项使用前向欧拉时间步。\n\n2.  一种高分辨率总变差递减 (TVD) 的守恒律单调上游中心格式 (MUSCL)，使用 Van Leer 通量限制器。必须使用依赖于连续离散梯度之比 $r$ 的限制器函数 $\\phi(r)$ 来构造分段线性重构，以在平滑区域达到二阶空间精度的同时保持单调性。\n\n两种格式都必须强制执行周期性边界条件。在显式格式中，使用不超过 $0.45$ 的库朗数 $\\nu = |u|\\Delta t/\\Delta x$ 以保证稳定性，并对汇项使用前向欧拉更新。在每个时间步之后，通过将 $q$ 裁剪到区间 $[0, q_{\\max}]$ 内来强制执行物理边界，其中 $q_{\\max}$ 是一个预设的水汽上限。\n\n初始条件是一个均匀的背景值 $q_{\\mathrm{bg}}$ 加上一个宽度为 $W$ 的矩形水汽斑块，其值较高，为 $q_{\\mathrm{patch}}$：\n- 当 $x \\in [x_0, x_0 + W]$（考虑周期性）时，$q(x,0) = q_{\\mathrm{patch}}$，\n- 其他地方，$q(x,0) = q_{\\mathrm{bg}}$。\n\n对于下面的每个测试用例，使用两种格式模拟直到指定的最终时间 $T_{\\mathrm{end}}$，在每个时间步使用当前的 $q$ 计算瞬时降水 $P_{\\mathrm{mm/hr}}(x,t)$，并记录所有空间和时间上的最大值，对于一阶迎风格式记为 $P_{\\max}^{\\mathrm{U1}}$，对于高分辨率格式记为 $P_{\\max}^{\\mathrm{HR}}$。对于每个测试用例，报告比率 $R = P_{\\max}^{\\mathrm{HR}} / P_{\\max}^{\\mathrm{U1}}$，结果为十进制数（无单位）。\n\n必须遵守指定的物理单位：\n- $L$ 单位为 $\\mathrm{m}$，\n- $u$ 单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$，\n- $q_s$、$q_{\\mathrm{bg}}$、$q_{\\mathrm{patch}}$、$q_{\\max}$ 单位为 $\\mathrm{kg}\\,\\mathrm{kg}^{-1}$，\n- $\\tau_c$ 单位为 $\\mathrm{s}$，\n- $H$ 单位为 $\\mathrm{m}$，\n- $\\rho_{\\mathrm{air}}$ 单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$，\n- $T_{\\mathrm{end}}$ 单位为 $\\mathrm{s}$，\n- $W$ 单位为 $\\mathrm{m}$。\n\n测试套件：\n- 案例 1 (一般情况): $L = 200000$, $N = 256$, $u = 10$, $q_s = 0.015$, $q_{\\mathrm{bg}} = 0.005$, $q_{\\mathrm{patch}} = 0.025$, $W = 50000$, $x_0 = 50000$, $\\tau_c = 900$, $H = 1000$, $\\rho_{\\mathrm{air}} = 1.2$, $q_{\\max} = 0.03$, $T_{\\mathrm{end}} = 7200$, 目标库朗数 $\\nu = 0.45$。\n- 案例 2 (粗分辨率): 与案例 1 相同，但 $N = 64$。\n- 案例 3 (接近库朗极限且风速更快): 与案例 1 相同，但 $u = 40$ 且 $T_{\\mathrm{end}} = 3600$。\n- 案例 4 (弱过饱和边界情况): 与案例 1 相同，但 $q_{\\mathrm{patch}} = 0.016$。\n\n您的程序必须生成单行输出，其中包含四个测试用例的比率 $R$，格式为用方括号括起来的逗号分隔列表。每个比率必须四舍五入到六位小数。例如：\n\"[R1,R2,R3,R4]\".\n不允许有其他输出。",
            "solution": "用户在计算流体动力学领域，特别是其在大气建模中的应用方面，提供了一个定义明确的问题。该问题要求实现并比较两种数值格式，以求解一个带源/汇项的一维平流方程。问题陈述的验证证实了它在科学上是合理的，在数学上是适定的，是客观的，并且包含了唯一解所需的所有必要信息。因此，我将着手开发解决方案。\n\n水汽比湿 $q(x,t)$ 的控制偏微分方程 (PDE) 是一个带汇项的守恒律：\n$$\n\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = -S(q)\n$$\n其中 $u$ 是一个恒定的正风速，$S(q)$ 是凝结汇项。该方程描述了量 $q$ 如何被风输送（平流）并同时因凝结而减少。我们将在一个长度为 $L$ 的一维周期性域上求解此方程，该域被离散为 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀网格。网格 $i$ 中的网格平均值记为 $q_i(t)$。\n\n控制偏微分方程的有限体积离散化形式为：\n$$\n\\frac{d q_i}{dt} = -\\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x} - S(q_i)\n$$\n在这里，$F_{i+1/2}$ 表示穿过网格 $i$ 和网格 $i+1$ 之间界面的 $q$ 的数值通量。汇项被视为网格 $i$ 内的局部源项。我们使用前向欧拉法进行时间积分：\n$$\nq_i^{n+1} = q_i^n + \\Delta t \\left( -\\frac{F_{i+1/2}^n - F_{i-1/2}^n}{\\Delta x} - S(q_i^n) \\right)\n$$\n其中 $q_i^n$ 是时间步 $n$ 的值。所要求的两种格式在数值通量 $F$ 的构造上有所不同。\n\n汇项 $S(q)$ 和由此产生的降水率 $P_{\\mathrm{mm/hr}}$ 计算如下：\n$$\nS(q_i^n) = \\max\\left(0, \\frac{q_i^n - q_s}{\\tau_c}\\right)\n$$\n$$\nP_{\\mathrm{mm/hr}}(x_i, t^n) = 3600 \\cdot \\rho_{\\mathrm{air}} \\cdot H \\cdot S(q_i^n)\n$$\n在所有网格 $i$ 和所有时间步 $n$ 上，此降水率的最大值是我们关心的量。\n\n时间步 $\\Delta t$ 由 Courant-Friedrichs-Lewy (CFL) 条件确定。给定库朗数 $\\nu = |u|\\Delta t/\\Delta x$，时间步为 $\\Delta t = \\nu \\Delta x / |u|$。对于所有测试用例，$u0$。\n\n初始条件是一个分段常数函数：\n$$\nq_i(0) = \\begin{cases} q_{\\mathrm{patch}}  \\text{若 } x_0 \\le x_i \\le x_0 + W \\\\ q_{\\mathrm{bg}}  \\text{其他情况} \\end{cases}\n$$\n其中 $x_i = (i+0.5)\\Delta x$ 是网格 $i$ 的中心。\n\n在每个时间步之后，解 $q_i^{n+1}$ 被裁剪到物理边界 $[0, q_{\\max}]$ 内。强制执行周期性边界条件，这意味着对于一个索引为 $0, \\dots, N-1$ 的 $N$ 个网格的网格系统，网格 0 的左邻居是网格 $N-1$，网格 $N-1$ 的右邻居是网格 $0$。\n\n**1. 一阶迎风格式 (U1)**\n\n这种格式简单且稳健，但具有数值耗散性。对于正风速 $u  0$，“迎风”方向来自左侧。进入界面 $i+1/2$ 的流体状态就是迎风网格 $i$ 中的状态。因此，数值通量为：\n$$\nF_{i+1/2}^{\\mathrm{U1}} = u \\cdot q_i\n$$\n将此代入有限体积更新方程，得到平流项的趋势：\n$$\n-\\frac{F_{i+1/2}^n - F_{i-1/2}^n}{\\Delta x} = -\\frac{u q_i^n - u q_{i-1}^n}{\\Delta x} = -u \\frac{q_i^n - q_{i-1}^n}{\\Delta x}\n$$\nU1 格式的完整更新方程为：\n$$\nq_i^{n+1} = q_i^n - \\frac{u \\Delta t}{\\Delta x} (q_i^n - q_{i-1}^n) - \\Delta t \\cdot \\max\\left(0, \\frac{q_i^n - q_s}{\\tau_c}\\right)\n$$\n项 $u \\Delta t / \\Delta x$ 是库朗数 $\\nu$。\n\n**2. 高分辨率 TVD MUSCL 格式 (HR)**\n\n守恒律的单调上游中心格式 (MUSCL) 通过在每个网格中重构数据的分段线性表示来获得更高的空间精度。关键在于限制重构的斜率以避免引入新的振荡，这一特性称为总变差递减 (TVD)。\n\n步骤如下：\na. **斜率计算:** 对于每个网格 $i$，我们估计一个斜率。确保单调性的一种常用方法是使用受限斜率。我们首先计算后向差分 $\\Delta_i^b = q_i - q_{i-1}$ 和前向差分 $\\Delta_i^f = q_{i+1} - q_i$。指定的 Van Leer 限制器将它们组合起来，为网格 $i$ 生成一个受限斜率 $\\sigma_i$：\n$$\n\\sigma_i = \\begin{cases} \\frac{2 \\Delta_i^b \\Delta_i^f}{\\Delta_i^b + \\Delta_i^f}  \\text{若 } \\Delta_i^b \\Delta_i^f  0 \\\\ 0  \\text{若 } \\Delta_i^b \\Delta_i^f \\le 0 \\end{cases}\n$$\n该限制器在极值区域（单侧差分符号不同）为零，并在单调区域提供斜率的调和平均值，这比简单地选择最小量值更不具侵略性。\n\nb. **数据重构:** 受限斜率 $\\sigma_i$ 用于将 $q$ 的值从网格中心 $x_i$ 外插到其边界。由于风速 $u$ 为正，我们只需要网格 $i$ 右边界（即界面 $i+1/2$ 的左边界）的值，记为 $q_{i+1/2}^L$：\n$$\nq_{i+1/2}^L = q_i + \\frac{1}{2}\\sigma_i\n$$\n因子 $1/2$ 来自于在半个网格宽度 $(\\Delta x / 2)$ 上的外插。斜率被定义为网格之间的差值，而不是单位长度的差值，因此 $\\Delta x$ 项相互抵消。\n\nc. **通量计算:** 穿过界面 $i+1/2$ 的通量由迎风值决定，对于 $u0$ 来说，迎风值是 $q_{i+1/2}^L$。\n$$\nF_{i+1/2}^{\\mathrm{HR}} = u \\cdot q_{i+1/2}^L = u \\left(q_i + \\frac{1}{2}\\sigma_i\\right)\n$$\nd. **有限体积更新:** HR 格式的完整更新方程为：\n$$\n\\frac{dq_i}{dt} = -\\frac{1}{\\Delta x} \\left( F_{i+1/2}^{\\mathrm{HR}} - F_{i-1/2}^{\\mathrm{HR}} \\right) - S(q_i) = -\\frac{u}{\\Delta x} \\left( \\left(q_i + \\frac{\\sigma_i}{2}\\right) - \\left(q_{i-1} + \\frac{\\sigma_{i-1}}{2}\\right) \\right) - S(q_i)\n$$\n时间积分像之前一样使用前向欧拉法进行。\n\n这两种格式的根本区别在于它们解析陡峭梯度的能力。U1 格式的数值耗散会抹平初始的矩形斑块，降低其峰值，从而降低计算出的最大降水量。HR 格式在平滑区域具有二阶精度且保持单调性，将为斑块维持一个更陡峭的廓线，从而产生更高的峰值湿度值，并因此产生更高的最大降水率。比率 $R = P_{\\max}^{\\mathrm{HR}} / P_{\\max}^{\\mathrm{U1}}$ 预期将大于 $1$，量化了数值耗散对预测此极端事件的影响。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (general case)\n        {\n            \"L\": 200000.0, \"N\": 256, \"u\": 10.0, \"q_s\": 0.015, \"q_bg\": 0.005,\n            \"q_patch\": 0.025, \"W\": 50000.0, \"x_0\": 50000.0, \"tau_c\": 900.0,\n            \"H\": 1000.0, \"rho_air\": 1.2, \"q_max\": 0.03, \"T_end\": 7200.0, \"nu\": 0.45,\n        },\n        # Case 2 (coarse resolution)\n        {\n            \"L\": 200000.0, \"N\": 64, \"u\": 10.0, \"q_s\": 0.015, \"q_bg\": 0.005,\n            \"q_patch\": 0.025, \"W\": 50000.0, \"x_0\": 50000.0, \"tau_c\": 900.0,\n            \"H\": 1000.0, \"rho_air\": 1.2, \"q_max\": 0.03, \"T_end\": 7200.0, \"nu\": 0.45,\n        },\n        # Case 3 (near Courant limit with faster wind)\n        {\n            \"L\": 200000.0, \"N\": 256, \"u\": 40.0, \"q_s\": 0.015, \"q_bg\": 0.005,\n            \"q_patch\": 0.025, \"W\": 50000.0, \"x_0\": 50000.0, \"tau_c\": 900.0,\n            \"H\": 1000.0, \"rho_air\": 1.2, \"q_max\": 0.03, \"T_end\": 3600.0, \"nu\": 0.45,\n        },\n        # Case 4 (weak supersaturation edge case)\n        {\n            \"L\": 200000.0, \"N\": 256, \"u\": 10.0, \"q_s\": 0.015, \"q_bg\": 0.005,\n            \"q_patch\": 0.016, \"W\": 50000.0, \"x_0\": 50000.0, \"tau_c\": 900.0,\n            \"H\": 1000.0, \"rho_air\": 1.2, \"q_max\": 0.03, \"T_end\": 7200.0, \"nu\": 0.45,\n        }\n    ]\n\n    ratios = []\n    for params in test_cases:\n        ratio = run_simulation(**params)\n        ratios.append(ratio)\n\n    # Format the final output string\n    output_str = f\"[{','.join(f'{r:.6f}' for r in ratios)}]\"\n    print(output_str)\n\n\ndef run_simulation(L, N, u, q_s, q_bg, q_patch, W, x_0, tau_c, H, rho_air, q_max, T_end, nu):\n    \"\"\"\n    Runs one simulation case for both U1 and HR schemes and returns the ratio of max precipitation.\n    \"\"\"\n    # Grid and time step setup\n    dx = L / N\n    dt = nu * dx / abs(u)\n    \n    # Grid cell centers\n    x = (np.arange(N) + 0.5) * dx\n\n    # Initial condition\n    q_initial = np.full(N, q_bg)\n    # Determine indices for the patch based on cell centers\n    # i = x0/dx - 0.5  and i = (x0+W)/dx - 0.5\n    start_idx = int(np.ceil(x_0 / dx - 0.5))\n    end_idx = int(np.floor((x_0 + W) / dx - 0.5))\n    if end_idx = start_idx:\n        q_initial[start_idx : end_idx + 1] = q_patch\n\n    # --- Run simulation for both schemes ---\n    p_max_u1 = simulate_scheme(q_initial.copy(), 'U1', N, u, q_s, tau_c, H, rho_air, q_max, T_end, dx, dt, nu)\n    p_max_hr = simulate_scheme(q_initial.copy(), 'HR', N, u, q_s, tau_c, H, rho_air, q_max, T_end, dx, dt, nu)\n\n    if p_max_u1  0:\n        return p_max_hr / p_max_u1\n    elif p_max_hr  0:\n        return np.inf # Should not happen with problem constraints, but for robustness\n    else:\n        return 1.0 # If both are zero, their ratio is 1\n\ndef simulate_scheme(q, scheme_type, N, u, q_s, tau_c, H, rho_air, q_max, T_end, dx, dt, nu):\n    \"\"\"\n    Core simulation loop for a single numerical scheme.\n    \"\"\"\n    \n    def calculate_max_p(current_q):\n        s = np.maximum(0, (current_q - q_s) / tau_c)\n        p_kg_m2_s = rho_air * H * s\n        p_mm_hr = 3600 * p_kg_m2_s\n        return np.max(p_mm_hr) if p_mm_hr.size  0 else 0.0\n\n    max_p = calculate_max_p(q)\n    \n    time = 0.0\n    while time  T_end:\n        q_old = q.copy()\n\n        # Advection term\n        if scheme_type == 'U1':\n            q_prev = np.roll(q_old, 1) # upwind for u  0\n            advection_tendency = -nu * (q_old - q_prev)\n        elif scheme_type == 'HR':\n            q_prev = np.roll(q_old, 1)\n            q_next = np.roll(q_old, -1)\n\n            # Van Leer limiter implementation\n            delta_b = q_old - q_prev\n            delta_f = q_next - q_old\n            \n            # Use a small epsilon to avoid division by zero in theory, though with floats it's unlikely\n            # if product is  0.\n            product = delta_b * delta_f\n            slopes = np.zeros(N)\n            mask = product  1e-12 # Threshold for numerical stability\n            \n            denominator = delta_b[mask] + delta_f[mask]\n            \n            # Avoid division by zero when denominator is close to zero\n            den_mask = np.abs(denominator)  1e-12\n            \n            numerator = 2 * product[mask]\n            \n            # Allocate a temporary slopes array for the masked operation\n            masked_slopes = np.zeros_like(denominator)\n            masked_slopes[den_mask] = numerator[den_mask] / denominator[den_mask]\n            \n            slopes[mask] = masked_slopes\n\n            # Reconstruct fluxes\n            # F_{i+1/2} = u * (q_i + 0.5 * sigma_i)\n            flux_iph = u * (q_old + 0.5 * slopes)\n            # F_{i-1/2} = u * (q_{i-1} + 0.5 * sigma_{i-1})\n            flux_imh = np.roll(flux_iph, 1)\n            \n            advection_tendency = -(dt / dx) * (flux_iph - flux_imh)\n        else:\n            raise ValueError(\"Unknown scheme type\")\n            \n        # Sink term\n        sink_tendency = -dt * np.maximum(0, (q_old - q_s) / tau_c)\n        \n        # Update q\n        q = q_old + advection_tendency + sink_tendency\n        \n        # Enforce physical bounds\n        q = np.clip(q, 0.0, q_max)\n        \n        # Update max precipitation\n        max_p = max(max_p, calculate_max_p(q))\n        \n        time += dt\n        \n    return max_p\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在获得了极端现象（如日降水量）的时间序列后，超阈值峰值 (Peaks-Over-Threshold, POT) 方法是进行统计分析的有力工具，但其有效性严重依赖于一个关键步骤：选择一个合适的阈值 $u$。一个过低或过高的阈值都可能导致模型失配和结果偏差。本实践练习  聚焦于这一核心问题，引导您运用极值理论中的关键诊断工具——平均剩余寿命图，并结合赤池信息准则 (AIC) 构建一个综合目标函数，从而系统性地确定最优阈值。这项练习旨在培养您在应用统计模型前进行严谨预处理和诊断评估的能力。",
            "id": "4065951",
            "problem": "一个区域对流可分辨数值天气预报模式提供了一个以复合降水-风极端事件而闻名的沿海网格点上 $T$ 天的每日总降水量。为了使用超出阈值峰值 (POT) 方法对日降水量的尾部分布进行建模，必须选择一个阈值 $u$，使得超过 $u$ 的超出量能被广义帕累托分布 (GPD) 很好地描述。根据 Pickands–Balkema–de Haan 提出的极值理论 (EVT) 的一个基础性结果，在广泛的条件下，对于足够高的阈值 $u$，阈值超出量的条件分布会收敛于一个形状参数为 $\\xi$、尺度参数为 $\\sigma$ 的广义帕累托分布 (GPD)。\n\n从这一基础出发，推导当 $t \\ge u$ 时的平均剩余寿命函数 $e(t)$，并解释其在极端降水的 POT 建模中对于阈值稳定性的意义。然后，使用一个信息论和诊断框架，构建并应用一个复合目标函数 $C(u)$，该函数对 GPD 拟合的不足以及对平均剩余寿命线性度的偏离进行惩罚，定义如下：\n$$\nC(u) = \\mathrm{赤池信息准则\\ (AIC)}(u) + \\lambda \\,\\mathrm{SSE}(u),\n$$\n其中 AIC$(u) = 2k - 2\\hat{\\ell}(u)$， $k$ 等于 GPD 参数的数量，$\\hat{\\ell}(u)$ 是对超过 $u$ 的超出量进行 GPD 拟合所得的最大化对数似然，$\\mathrm{SSE}(u)$ 是经验平均剩余寿命 $\\hat{e}(t)$ 在窗口 $t \\in [u, u + 20]$ 内对 $t$ 进行最小二乘线性回归的残差平方和，$\\lambda$ 是一个固定的正常数权重。\n\n对于候选阈值 $u \\in \\{30, 35, 40, 45, 50\\}$ $\\mathrm{mm/day}$，从模型输出中计算出以下诊断量：\n- 最大化对数似然：$\\hat{\\ell}(30) = -1670$, $\\hat{\\ell}(35) = -1389$, $\\hat{\\ell}(40) = -1190$, $\\hat{\\ell}(45) = -1012$, $\\hat{\\ell}(50) = -890$。\n- 在 $t \\in [u, u+20]$ 范围内的平均剩余寿命回归残差平方和：$\\mathrm{SSE}(30) = 41.0$, $\\mathrm{SSE}(35) = 22.8$, $\\mathrm{SSE}(40) = 11.6$, $\\mathrm{SSE}(45) = 11.2$, $\\mathrm{SSE}(50) = 18.0$。\n- 广义帕累托形状参数估计值：$\\hat{\\xi}(30) = 0.22$, $\\hat{\\xi}(35) = 0.24$, $\\hat{\\xi}(40) = 0.25$, $\\hat{\\xi}(45) = 0.25$, $\\hat{\\xi}(50) = 0.26$。\n\n取 $k = 2$ 和 $\\lambda = 50$。利用 $e(t)$ 的推导和阈值稳定性的概念，为每个候选阈值计算 $C(u)$，并选择使 $C(u)$ 最小化的最优阈值 $u^{\\star}$。基于复合准则以及从估计的形状参数和平均剩余寿命线性度推断出的阈值稳定性诊断准则，来证明你的选择是合理的。\n\n将最终的数值阈值四舍五入到三位有效数字，并以 $\\mathrm{mm/day}$ 为单位表示。最终答案必须是一个数字。",
            "solution": "该问题被评估为有效，因为它在科学上基于极值理论，提法恰当，客观，并为其解答提供了完整且一致的数据和定义。\n\n解答按要求分三部分进行：首先，推导广义帕累托分布 (GPD) 的平均剩余寿命函数及其意义；其次，计算候选阈值的复合目标函数；第三，选择最优阈值并进行论证。\n\n**1. GPD的平均剩余寿命函数**\n\n平均剩余寿命函数 $e(t)$ 定义为在随机变量 $X$ 超过水平 $t$ 的条件下，其超出量 $X-t$ 的期望值。数学上表示为：\n$$e(t) = E[X - t | X  t]$$\n在超出阈值峰值 (POT) 框架中，对于一个高阈值 $u$，在 $X  u$ 的条件下，超出量 $Y = X - u$ 的分布近似于一个 GPD。对于 $y \\ge 0$，GPD 的累积分布函数 (CDF) 由下式给出：\n$$G(y; \\xi, \\sigma) = 1 - \\left(1 + \\frac{\\xi y}{\\sigma}\\right)^{-1/\\xi} \\quad \\text{for } \\xi \\neq 0$$\n其中 $\\sigma  0$ 是尺度参数，$\\xi$ 是形状参数。因此，生存函数为：\n$$S_Y(y) = P(Y  y) = 1 - G(y; \\xi, \\sigma) = \\left(1 + \\frac{\\xi y}{\\sigma}\\right)^{-1/\\xi}$$\n为了推导 $e(t)$，我们考虑一个水平 $t \\ge u$。令 $d = t - u \\ge 0$。平均剩余寿命函数可以用超出量变量 $Y$ 来表示：\n$$e(t) = e(u+d) = E[(X-u) - (t-u) | X-u  t-u] = E[Y - d | Y  d]$$\n对于一个非负随机变量，这个条件期望可以计算为：\n$$E[Y - d | Y  d] = \\frac{\\int_d^{\\infty} S_Y(y) \\, dy}{S_Y(d)}$$\n我们首先计算分子中的积分，假设均值存在（这要求 $\\xi  1$）：\n$$\\int_d^{\\infty} \\left(1 + \\frac{\\xi y}{\\sigma}\\right)^{-1/\\xi} dy$$\n使用换元法 $v = 1 + \\frac{\\xi y}{\\sigma}$，这意味着 $dy = \\frac{\\sigma}{\\xi} dv$，积分变为：\n$$\\int_{1+\\frac{\\xi d}{\\sigma}}^{\\infty} v^{-1/\\xi} \\frac{\\sigma}{\\xi} dv = \\frac{\\sigma}{\\xi} \\left[ \\frac{v^{1-1/\\xi}}{1-1/\\xi} \\right]_{1+\\frac{\\xi d}{\\sigma}}^{\\infty}$$\n由于 $\\xi  1$，指数 $1 - 1/\\xi$ 为负，因此该表达式在积分上限处的值为 0。结果是：\n$$\\frac{\\sigma}{\\xi} \\left( 0 - \\frac{(1+\\frac{\\xi d}{\\sigma})^{1-1/\\xi}}{1-1/\\xi} \\right) = \\frac{\\sigma}{1-\\xi} \\left(1+\\frac{\\xi d}{\\sigma}\\right)^{1-1/\\xi}$$\n现在，我们除以生存函数 $S_Y(d) = (1 + \\frac{\\xi d}{\\sigma})^{-1/\\xi}$：\n$$e(u+d) = \\frac{\\frac{\\sigma}{1-\\xi} (1+\\frac{\\xi d}{\\sigma})^{1-1/\\xi}}{(1 + \\frac{\\xi d}{\\sigma})^{-1/\\xi}} = \\frac{\\sigma}{1-\\xi} \\left(1+\\frac{\\xi d}{\\sigma}\\right) = \\frac{\\sigma + \\xi d}{1-\\xi}$$\n将 $d = t-u$ 代回：\n$$e(t) = \\frac{\\sigma + \\xi(t-u)}{1-\\xi} = \\left(\\frac{\\sigma - \\xi u}{1-\\xi}\\right) + \\left(\\frac{\\xi}{1-\\xi}\\right)t$$\n这个结果表明，对于一个尾部分布服从 GPD 的变量，其平均剩余寿命函数 $e(t)$ 对于所有高于阈值 $u$ 的 $t$ 都是 $t$ 的线性函数。\n\n这种线性关系是用于选择阈值的一个关键性质。一个标准的诊断方法是绘制经验平均剩余寿命函数相对于阈值的图，并找出图中开始呈现线性的最低阈值 $u$。目标函数中的 $\\mathrm{SSE}(u)$ 项直接惩罚对这种线性关系的偏离，从而将这种目视诊断方法形式化。\n\n**2. 复合目标函数的计算**\n\n需要最小化的复合目标函数是 $C(u) = \\mathrm{AIC}(u) + \\lambda \\cdot \\mathrm{SSE}(u)$。\n给定 $k=2$（对应参数 $\\xi$ 和 $\\sigma$）和 $\\lambda = 50$。\n赤池信息准则为 $\\mathrm{AIC}(u) = 2k - 2\\hat{\\ell}(u) = 2(2) - 2\\hat{\\ell}(u) = 4 - 2\\hat{\\ell}(u)$。\n因此，$C(u) = 4 - 2\\hat{\\ell}(u) + 50 \\cdot \\mathrm{SSE}(u)$。\n\n我们使用提供的数据为每个候选阈值 $u \\in \\{30, 35, 40, 45, 50\\}$ 计算 $C(u)$。\n\n- 对于 $u=30$：\n  $C(30) = 4 - 2(-1670) + 50(41.0) = 4 + 3340 + 2050 = 5394$。\n\n- 对于 $u=35$：\n  $C(35) = 4 - 2(-1389) + 50(22.8) = 4 + 2778 + 1140 = 3922$。\n\n- 对于 $u=40$：\n  $C(40) = 4 - 2(-1190) + 50(11.6) = 4 + 2380 + 580 = 2964$。\n\n- 对于 $u=45$：\n  $C(45) = 4 - 2(-1012) + 50(11.2) = 4 + 2024 + 560 = 2588$。\n\n- 对于 $u=50$：\n  $C(50) = 4 - 2(-890) + 50(18.0) = 4 + 1780 + 900 = 2684$。\n\n**3. 最优阈值的选择与论证**\n\n复合目标函数的计算值如下：\n- $C(30) = 5394$\n- $C(35) = 3922$\n- $C(40) = 2964$\n- $C(45) = 2588$\n- $C(50) = 2684$\n\n$C(u)$ 的最小值为 $2588$，出现在 $u=45$ 处。因此，最优阈值为 $u^{\\star} = 45 \\, \\mathrm{mm/day}$。\n\n通过考察目标函数的组成部分以及作为阈值稳定性标准诊断方法的估计形状参数的行为，这一选择是合理的。\n\n- **复合准则**：$C(u)$ 的最小化本身就直接指向 $u^{\\star}=45$ 作为最优选择，因为它代表了模型拟合度（由 AIC 衡量）与 GPD 理论性质（由平均剩余寿命的线性度衡量）的遵循之间的最佳权衡。\n\n- **平均剩余寿命线性度**：残差平方和 $\\mathrm{SSE}(u)$ 量化了与线性度的偏离。其值分别为 $41.0, 22.8, 11.6, 11.2, 18.0$。最小的 $\\mathrm{SSE}$ 出现在 $u=45$ 处，表明该阈值下的经验平均剩余寿命图最接近线性。从 $u=30$ 到 $u=40$，SSE 的急剧下降证实了较低的阈值是不合适的。在 $u=50$ 时 SSE 的增加表明超出量的数量变得过少，导致抽样变异性增加和估计值稳定性下降。\n\n- **形状参数稳定性**：一个有效的阈值应该位于估计的形状参数 $\\hat{\\xi}$ 保持稳定的区域。提供的数据为 $\\hat{\\xi}(30) = 0.22$, $\\hat{\\xi}(35) = 0.24$, $\\hat{\\xi}(40) = 0.25$, $\\hat{\\xi}(45) = 0.25$, 以及 $\\hat{\\xi}(50) = 0.26$。当 $u40$ 时，参数估计值在变化，但在 $u=40$ 和 $u=45$ 时，参数估计值在 $\\hat{\\xi}=0.25$ 处表现出显著的稳定性。这种稳定性提供了强有力的证据，表明渐近的 GPD 尾部行为大约在 $u=40$ 附近开始。选择 $u^{\\star}=45$ 正好落在这个稳定区域内。\n\n总之，所有诊断准则都一致支持选择 $u^{\\star} = 45 \\, \\mathrm{mm/day}$。它最小化了复合惩罚函数，对应于最线性的平均剩余寿命图，并且位于形状参数最稳定的区域内。问题要求将答案四舍五入到三位有效数字，即 $45.0$。",
            "answer": "$$\\boxed{45.0}$$"
        },
        {
            "introduction": "作为极值理论的两大基石之一，块最大值 (Block Maxima) 方法通过对每年（或其他周期）的最大值进行建模，为评估极端事件的长期风险提供了经典框架。本实践练习  提供了一个完整的端到端工作流程，您将基于给定的年最大日降水量数据集，运用最大似然估计 (Maximum Likelihood Estimation, MLE) 方法来拟合广义极值 (Generalized Extreme Value, GEV) 分布的参数。最终，您将利用拟合好的模型计算一个关键的风险度量——百年一遇的重现水平 ($100$-year return level)，从而将抽象的统计模型转化为具有实际意义的风险评估结果。",
            "id": "4065983",
            "problem": "您的任务是开发一个程序，用于估计日降水量年区组最大值的广义极值（GEV）分布参数，并计算$100$年重现水平。该问题的背景是，在数值天气预报和气候模拟中对极端天气事件进行建模。该问题的科学基础是，经过适当归一化的区组最大值会收敛于广义极值（GEV）分布，这是一个公认的结论。对于区组最大值，GEV的累积分布函数的标准形式由位置参数$\\mu$、尺度参数$\\sigma$和形状参数$\\xi$定义，适用于满足定义域约束 $1 + \\xi \\frac{x - \\mu}{\\sigma}  0$ 的值$x$。\n\n从这个定义以及各年份年区组最大值相互独立的假设出发，您必须推导出似然函数，并使用最大似然估计（MLE）来为每个数据集估计$(\\mu,\\sigma,\\xi)$。利用$T$年重现水平的定义，即年区组最大值以概率 $p = \\frac{1}{T}$ 超过的分位数，推导出重现水平$z_T$的表达式，并为每个数据集计算$z_{100}$。如果形状参数满足$\\xi \\rightarrow 0$，您应在实现中使用相应的极限形式。\n\n物理单位与报告要求：\n- 区组最大值为日降水量的年最大值，单位为毫米/天（mm/day）。\n- 重现水平$z_{100}$必须以毫米/天（mm/day）为单位表示。\n- 您的程序必须将每个报告的数值结果四舍五入到$3$位小数。\n\n测试套件与数据集：\n提供给您三个跨度为$50$年（各$50$个值）的年区组最大值数据集，它们代表了与极端降水相关的不同尾部行为。\n- 数据集A（重尾候选，可能的热带极端情况）： \n[$91.2$, $104.5$, $97.8$, $112.3$, $85.7$, $123.4$, $146.1$, $132.7$, $108.9$, $119.5$, $140.2$, $88.6$, $101.3$, $125.9$, $167.4$, $154.3$, $173.2$, $189.8$, $205.1$, $221.7$, $236.8$, $249.5$, $263.4$, $278.9$, $294.1$, $313.5$, $295.6$, $271.4$, $242.1$, $210.4$, $195.7$, $176.5$, $158.4$, $149.2$, $133.8$, $121.6$, $111.1$, $102.5$, $95.3$, $89.7$, $84.1$, $79.9$, $76.4$, $74.0$, $71.8$, $69.7$, $68.1$, $67.2$, $66.5$, $65.9$]\n- 数据集B（接近Gumbel分布候选，中纬度极端情况的典型中等离散度）： \n[$82.3$, $95.6$, $110.2$, $120.7$, $135.3$, $98.4$, $112.1$, $126.8$, $141.5$, $155.9$, $168.3$, $180.5$, $92.7$, $105.4$, $117.9$, $130.6$, $143.2$, $156.7$, $170.1$, $183.4$, $97.8$, $109.6$, $123.3$, $136.9$, $149.7$, $162.4$, $175.8$, $188.6$, $101.2$, $114.5$, $127.1$, $139.8$, $152.6$, $165.4$, $178.2$, $190.9$, $106.3$, $118.9$, $131.5$, $144.2$, $156.8$, $169.4$, $181.9$, $194.6$, $89.4$, $102.1$, $115.7$, $128.3$, $141.0$, $154.6$]\n- 数据集C（有界尾候选，上支撑约束与某些水文状况一致）： \n[$92.1$, $104.3$, $116.5$, $128.2$, $139.8$, $151.1$, $162.4$, $173.6$, $98.7$, $110.5$, $122.3$, $134.0$, $145.6$, $157.3$, $168.9$, $179.5$, $95.4$, $107.2$, $118.9$, $130.7$, $142.5$, $154.1$, $165.8$, $176.4$, $100.2$, $112.0$, $123.7$, $135.3$, $146.9$, $158.6$, $169.3$, $179.1$, $96.9$, $108.6$, $120.3$, $132.0$, $143.7$, $155.4$, $167.1$, $178.8$, $91.5$, $103.2$, $114.9$, $126.6$, $138.3$, $149.9$, $161.6$, $173.3$, $85.7$, $97.4$]\n\n计算任务与约束：\n- 对每个数据集，从标准的GEV累积分布函数和年最大值独立分布的假设出发，推导似然函数及相应的最大似然估计量。\n- 实现参数估计，需满足所有数据点的定义域约束 $1 + \\xi \\frac{x - \\mu}{\\sigma}  0$ 和尺度约束 $\\sigma  0$。\n- 使用为 $p = \\frac{1}{100}$ 推导出的分位数表达式计算$100$年重现水平，并正确处理$\\xi \\to 0$的极限情况。\n- 以毫米/天（mm/day）为单位表示$z_{100}$，并四舍五入到$3$位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个数据集的结果列表，每个数据集的结果是一个列表 $[\\hat{\\mu},\\hat{\\sigma},\\hat{\\xi},z_{100}]$，其中每个条目都四舍五入到$3$位小数。总输出必须是包含这三个数据集列表的单个列表，例如： \n\"[[m1,s1,x1,z1],[m2,s2,x2,z2],[m3,s3,x3,z3]]\"。\n\n程序必须是自包含的，不得读取输入，并且必须能直接运行。本问题不涉及角度。所有量均以毫米/天（mm/day）为单位给出，并四舍五入到$3$位小数。",
            "solution": "本问题要求为代表日降水量年最大值的三个数据集估计广义极值（GEV）分布的参数。估计过程需采用最大似然估计（MLE）方法。随后，必须为每个数据集计算$100$年重现水平。整个过程基于极值理论和统计推断的原理。\n\n分析始于GEV分布的正式定义和所需统计工具的推导。随机变量$X$的GEV累积分布函数（CDF）由下式给出：\n$$\nF(x; \\mu, \\sigma, \\xi) = \n\\begin{cases} \n\\exp\\left( -\\left[1 + \\xi \\left(\\frac{x - \\mu}{\\sigma}\\right)\\right]^{-1/\\xi} \\right)  \\text{for } \\xi \\neq 0 \\\\\n\\exp\\left( -\\exp\\left(-\\frac{x - \\mu}{\\sigma}\\right) \\right)  \\text{for } \\xi = 0 \n\\end{cases}\n$$\n其中，$\\mu$是位置参数，$\\sigma$是尺度参数，$\\xi$是形状参数。该分布定义于满足约束 $1 + \\xi \\frac{x - \\mu}{\\sigma}  0$ 的值$x$。尺度参数必须为正，即$\\sigma  0$。$\\xi = 0$的情况对应于Gumbel分布（I型），$\\xi  0$对应于Fréchet分布（II型，重尾），$\\xi  0$对应于反向Weibull分布（III型，有界上尾）。\n\n为了执行最大似然估计，我们首先需要概率密度函数（PDF），即 $f(x; \\mu, \\sigma, \\xi) = \\frac{d}{dx}F(x; \\mu, \\sigma, \\xi)$。对CDF求导可得：\n对于 $\\xi \\neq 0$:\n$$ f(x; \\mu, \\sigma, \\xi) = \\frac{1}{\\sigma} \\left[1 + \\xi \\left(\\frac{x - \\mu}{\\sigma}\\right)\\right]^{-\\left(1 + \\frac{1}{\\xi}\\right)} \\exp\\left(-\\left[1 + \\xi \\left(\\frac{x - \\mu}{\\sigma}\\right)\\right]^{-1/\\xi}\\right) $$\n对于 $\\xi = 0$:\n$$ f(x; \\mu, \\sigma, 0) = \\frac{1}{\\sigma} \\exp\\left(-\\frac{x - \\mu}{\\sigma}\\right) \\exp\\left(-\\exp\\left(-\\frac{x - \\mu}{\\sigma}\\right)\\right) $$\n给定一个包含$n$个独立年最大值的样本 $x_1, x_2, \\ldots, x_n$，似然函数是各样本密度的乘积：$L(\\mu, \\sigma, \\xi | \\mathbf{x}) = \\prod_{i=1}^n f(x_i; \\mu, \\sigma, \\xi)$。在计算上，处理对数似然函数 $\\ell = \\ln L$ 更为方便。对于 $\\xi \\neq 0$，对数似然函数为：\n$$ \\ell(\\mu, \\sigma, \\xi) = -n \\ln \\sigma - \\sum_{i=1}^{n} \\left(1 + \\frac{1}{\\xi}\\right) \\ln\\left[1 + \\xi \\left(\\frac{x_i - \\mu}{\\sigma}\\right)\\right] - \\sum_{i=1}^{n} \\left[1 + \\xi \\left(\\frac{x_i - \\mu}{\\sigma}\\right)\\right]^{-1/\\xi} $$\n对于 $\\xi = 0$:\n$$ \\ell(\\mu, \\sigma, 0) = -n \\ln \\sigma - \\sum_{i=1}^{n} \\left(\\frac{x_i - \\mu}{\\sigma}\\right) - \\sum_{i=1}^{n} \\exp\\left(-\\left(\\frac{x_i - \\mu}{\\sigma}\\right)\\right) $$\nMLE参数估计值 $(\\hat{\\mu}, \\hat{\\sigma}, \\hat{\\xi})$ 是使$\\ell$最大化的值。这是一个数值优化问题，通常通过最小化负对数似然函数 $-\\ell(\\mu, \\sigma, \\xi)$ 来解决。优化必须在满足约束条件 $\\sigma  0$ 和对于所有数据点 $x_i, i=1, \\dots, n$ 均有 $1 + \\xi (x_i - \\mu)/\\sigma  0$ 的情况下进行。\n\n第二个任务是计算$T$年重现水平$z_T$。这是预期每$T$年平均被超过一次的值。其在任意一年的超越概率为 $p = 1/T$。因此，$z_T$ 是由 $F(z_T) = 1-p = 1 - 1/T$ 定义的分布分位数。为了求$z_T$，我们对CDF进行反演：\n对于 $\\xi \\neq 0$，解 $F(z_T) = 1 - 1/T$ 可得$z_T$：\n$$ z_T = \\mu + \\frac{\\sigma}{\\xi} \\left[ \\left(-\\ln\\left(1 - \\frac{1}{T}\\right)\\right)^{-\\xi} - 1 \\right] $$\n对于$\\xi \\to 0$的情况，我们可以对上述表达式取极限，或直接对Gumbel CDF进行反演。两种方法得出相同的结果：\n$$ z_T = \\mu - \\sigma \\ln\\left(-\\ln\\left(1 - \\frac{1}{T}\\right)\\right) $$\n对于本问题，我们关心的是$100$年重现水平，因此我们设$T=100$。\n\n实施策略包括创建一个Python函数，该函数为给定的参数集和数据计算负对数似然。该函数包含对参数约束的检查，如果违反约束，则返回一个大值（惩罚）。然后我们使用一个数值优化程序，特别是使用无导数Nelder-Mead方法的`scipy.optimize.minimize`，来找到最小化该函数的参数 $(\\hat{\\mu}, \\hat{\\sigma}, \\hat{\\xi})$。为了提高优化的稳健性，初始参数猜测值通过Gumbel分布的矩方法推导得出。一旦估计出最优参数，就根据估计的形状参数$\\hat{\\xi}$是否接近于零，使用上面推导出的相应公式计算$100$年重现水平$z_{100}$。最后，按要求将所有结果四舍五入到$3$位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Estimates GEV parameters and computes the 100-year return level for three datasets.\n    \"\"\"\n    \n    # Define the datasets of annual block maxima\n    datasets = {\n        'A': np.array([91.2, 104.5, 97.8, 112.3, 85.7, 123.4, 146.1, 132.7, 108.9, 119.5, 140.2, 88.6, 101.3, 125.9, 167.4, 154.3, 173.2, 189.8, 205.1, 221.7, 236.8, 249.5, 263.4, 278.9, 294.1, 313.5, 295.6, 271.4, 242.1, 210.4, 195.7, 176.5, 158.4, 149.2, 133.8, 121.6, 111.1, 102.5, 95.3, 89.7, 84.1, 79.9, 76.4, 74.0, 71.8, 69.7, 68.1, 67.2, 66.5, 65.9]),\n        'B': np.array([82.3, 95.6, 110.2, 120.7, 135.3, 98.4, 112.1, 126.8, 141.5, 155.9, 168.3, 180.5, 92.7, 105.4, 117.9, 130.6, 143.2, 156.7, 170.1, 183.4, 97.8, 109.6, 123.3, 136.9, 149.7, 162.4, 175.8, 188.6, 101.2, 114.5, 127.1, 139.8, 152.6, 165.4, 178.2, 190.9, 106.3, 118.9, 131.5, 144.2, 156.8, 169.4, 181.9, 194.6, 89.4, 102.1, 115.7, 128.3, 141.0, 154.6]),\n        'C': np.array([92.1, 104.3, 116.5, 128.2, 139.8, 151.1, 162.4, 173.6, 98.7, 110.5, 122.3, 134.0, 145.6, 157.3, 168.9, 179.5, 95.4, 107.2, 118.9, 130.7, 142.5, 154.1, 165.8, 176.4, 100.2, 112.0, 123.7, 135.3, 146.9, 158.6, 169.3, 179.1, 96.9, 108.6, 120.3, 132.0, 143.7, 155.4, 167.1, 178.8, 91.5, 103.2, 114.9, 126.6, 138.3, 149.9, 161.6, 173.3, 85.7, 97.4])\n    }\n\n    def neg_log_likelihood(params, data):\n        \"\"\"\n        Calculates the negative log-likelihood of the GEV distribution.\n        \"\"\"\n        mu, sigma, xi = params\n        n = len(data)\n        \n        # Constraint: sigma > 0\n        if sigma = 0:\n            return np.inf\n\n        # Scaled variable and GEV argument\n        y = (data - mu) / sigma\n        s = 1 + xi * y\n\n        # Constraint: 1 + xi * y > 0\n        if np.any(s = 0):\n            return np.inf\n\n        # Handle Gumbel case (xi -> 0)\n        if np.abs(xi)  1e-6:\n            log_likelihood = -n * np.log(sigma) - np.sum(y) - np.sum(np.exp(-y))\n        else: # General GEV case\n            log_likelihood = -n * np.log(sigma) - (1 + 1/xi) * np.sum(np.log(s)) - np.sum(s**(-1/xi))\n        \n        if np.isnan(log_likelihood) or not np.isfinite(log_likelihood):\n            return np.inf\n            \n        return -log_likelihood\n\n    def calculate_return_level(mu, sigma, xi, T):\n        \"\"\"\n        Calculates the T-year return level.\n        \"\"\"\n        p = 1.0 / T\n        y_p = -np.log(1 - p)\n        \n        if np.abs(xi)  1e-6:\n            z_T = mu - sigma * np.log(y_p)\n        else:\n            z_T = mu + (sigma / xi) * (np.power(y_p, -xi) - 1)\n        return z_T\n\n    results_for_print = []\n    \n    # Process each dataset\n    for key in ['A', 'B', 'C']:\n        data = datasets[key]\n        \n        # Initial parameter guess using method of moments for Gumbel\n        sample_mean = np.mean(data)\n        sample_std = np.std(data, ddof=1)\n        sigma0 = sample_std * np.sqrt(6) / np.pi\n        mu0 = sample_mean - 0.5772156649 * sigma0  # Euler-Mascheroni constant\n        xi0 = 0.1\n        initial_params = [mu0, sigma0, xi0]\n        \n        # Perform minimization\n        res = minimize(\n            neg_log_likelihood, \n            initial_params, \n            args=(data,), \n            method='Nelder-Mead',\n            options={'maxiter': 5000, 'xatol': 1e-8, 'fatol': 1e-8}\n        )\n        \n        mu_hat, sigma_hat, xi_hat = res.x\n        \n        # Calculate 100-year return level\n        z100 = calculate_return_level(mu_hat, sigma_hat, xi_hat, T=100)\n        \n        # Round results to 3 decimal places\n        mu_r = round(mu_hat, 3)\n        sigma_r = round(sigma_hat, 3)\n        xi_r = round(xi_hat, 3)\n        z100_r = round(z100, 3)\n        \n        # Format for final output string. str(list) adds spaces which we remove.\n        result_list_str = str([mu_r, sigma_r, xi_r, z100_r]).replace(\" \", \"\")\n        results_for_print.append(result_list_str)\n\n    # Print the final result in the exact required format\n    print(f\"[{','.join(results_for_print)}]\")\n\nsolve()\n```"
        }
    ]
}