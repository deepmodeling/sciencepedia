{
    "hands_on_practices": [
        {
            "introduction": "极端天气事件的数值模拟不仅取决于模式的物理参数化方案，还深刻地受到求解大气流体动力学方程的数值方法的影响。本练习旨在揭示数值平流方案的选择如何直接影响对极端降水等现象的模拟。通过比较一种具有数值耗散效应的一阶方案和一种能更精确保持梯度的高分辨率方案，您将亲手量化数值精度对模拟极端事件强度的影响，从而理解为何在极端事件建模中追求高保真度的数值方法至关重要。",
            "id": "4065906",
            "problem": "考虑一个长度为 $L$ 的一维周期性区域，该区域被离散化为 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀单元格。设 $q(x,t)$ 表示水汽比湿（混合比），单位为 $\\mathrm{kg}\\,\\mathrm{kg}^{-1}$，由恒定风速 $u$（单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$）输送。$q$ 的演变由带有凝结汇的守恒定律控制\n$$\n\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = -S(q),\n$$\n其中凝结汇 $S(q)$ 代表水汽向降水的转化，其表达式为\n$$\nS(q) = \\max\\left(0, \\frac{q - q_s}{\\tau_c}\\right),\n$$\n其中 $q_s$ 为饱和比湿，单位为 $\\mathrm{kg}\\,\\mathrm{kg}^{-1}$，$\\tau_c$ 为凝结时间尺度，单位为 $\\mathrm{s}$。假设一个单层大气，其厚度为 $H$（单位为 $\\mathrm{m}$），空气密度为 $\\rho_{\\mathrm{air}}$（单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$）。单位面积的瞬时降水率是垂直积分的凝结质量通量，\n$$\nP(x,t) = \\rho_{\\mathrm{air}}\\,H\\,S(q(x,t)),\n$$\n单位为 $\\mathrm{kg}\\,\\mathrm{m}^{-2}\\,\\mathrm{s}^{-1}$。为报告以 $\\mathrm{mm}\\,\\mathrm{hr}^{-1}$ 为单位的降水强度，使用 $1\\,\\mathrm{mm}$ 的降雨对应于 $1\\,\\mathrm{kg}\\,\\mathrm{m}^{-2}$ 的水的恒等关系，因此通过以下方式转换\n$$\nP_{\\mathrm{mm/hr}}(x,t) = 3600\\,P(x,t).\n$$\n\n您的任务是为周期性区域上的平流-汇方程实现两种显式有限体积数值格式：\n\n1. 一阶迎风格式（表示为 U1），它根据 $u$ 的符号使用迎风偏置的数值通量进行平流计算，并对汇项使用前向欧拉时间步。\n\n2. 带有 Van Leer 通量限制器的高分辨率总变差递减（TVD）单调上游中心守恒律格式（MUSCL）。必须使用依赖于连续离散梯度之比 $r$ 的限制器函数 $\\phi(r)$ 来构建分段线性重构，以在保持单调性的同时，在平滑区域达到二阶空间精度。\n\n两种格式都必须强制执行周期性边界条件。为保证显式格式的稳定性，使用的库朗数 $\\nu = |u|\\Delta t/\\Delta x$ 不超过 $0.45$，并对汇项使用前向欧拉更新。在每个时间步之后，通过将 $q$ 裁剪到区间 $[0, q_{\\max}]$ 来强制执行物理边界，其中 $q_{\\max}$ 是给定的水汽上限。\n\n初始条件为一个均匀背景 $q_{\\mathrm{bg}}$ 加上一个宽度为 $W$、值较高的矩形湿区 $q_{\\mathrm{patch}}$：\n- 当 $x \\in [x_0, x_0 + W]$（周期性取模）时，$q(x,0) = q_{\\mathrm{patch}}$，\n- 其他情况下 $q(x,0) = q_{\\mathrm{bg}}$。\n\n对于下面的每个测试用例，模拟两种格式直至指定的最终时间 $T_{\\mathrm{end}}$，在每个时间步使用当前的 $q$ 计算瞬时降水量 $P_{\\mathrm{mm/hr}}(x,t)$，并记录在所有空间和时间上的最大值，一阶迎风格式的最大值表示为 $P_{\\max}^{\\mathrm{U1}}$，高分辨率格式的最大值表示为 $P_{\\max}^{\\mathrm{HR}}$。对于每个测试用例，报告比率 $R = P_{\\max}^{\\mathrm{HR}} / P_{\\max}^{\\mathrm{U1}}$，以十进制小数形式表示（无单位）。\n\n必须遵守指定的物理单位：\n- $L$ 的单位是 $\\mathrm{m}$，\n- $u$ 的单位是 $\\mathrm{m}\\,\\mathrm{s}^{-1}$，\n- $q_s$、$q_{\\mathrm{bg}}$、$q_{\\mathrm{patch}}$、$q_{\\max}$ 的单位是 $\\mathrm{kg}\\,\\mathrm{kg}^{-1}$，\n- $\\tau_c$ 的单位是 $\\mathrm{s}$，\n- $H$ 的单位是 $\\mathrm{m}$，\n- $\\rho_{\\mathrm{air}}$ 的单位是 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$，\n- $T_{\\mathrm{end}}$ 的单位是 $\\mathrm{s}$，\n- $W$ 的单位是 $\\mathrm{m}$。\n\n测试套件：\n- 用例 1（通用情况）：$L = 200000$，$N = 256$，$u = 10$，$q_s = 0.015$，$q_{\\mathrm{bg}} = 0.005$，$q_{\\mathrm{patch}} = 0.025$，$W = 50000$，$x_0 = 50000$，$\\tau_c = 900$，$H = 1000$，$\\rho_{\\mathrm{air}} = 1.2$，$q_{\\max} = 0.03$，$T_{\\mathrm{end}} = 7200$，目标库朗数 $\\nu = 0.45$。\n- 用例 2（粗分辨率）：与用例 1 相同，但 $N = 64$。\n- 用例 3（接近库朗极限的更快风速）：与用例 1 相同，但 $u = 40$ 且 $T_{\\mathrm{end}} = 3600$。\n- 用例 4（弱过饱和边界情况）：与用例 1 相同，但 $q_{\\mathrm{patch}} = 0.016$。\n\n您的程序必须产生单行输出，其中包含四个测试用例的比率 $R$，格式为用方括号括起来的逗号分隔列表。每个比率必须四舍五入到六位小数。例如：\n`[R1,R2,R3,R4]`。\n不允许有其他输出。",
            "solution": "用户在计算流体动力学领域提供了一个定义明确的问题，具体应用于大气建模。该问题要求实现并比较两种数值格式，用于求解带源/汇项的一维平流方程。对问题陈述的验证证实了其科学基础扎实、数学上适定、客观，并包含唯一解所需的所有必要信息。因此，我将着手开发解决方案。\n\n水汽比湿 $q(x,t)$ 的控制偏微分方程（PDE）是一个带汇项的守恒定律：\n$$\n\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = -S(q)\n$$\n其中 $u$ 是一个恒定的正风速，$S(q)$ 是凝结汇项。该方程描述了量 $q$ 如何被风输送（平流）并同时因凝结而减少。我们将在一个长度为 $L$ 的一维周期性区域上求解该方程，该区域被离散化为 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀单元格。单元格 $i$ 中的单元格平均值表示为 $q_i(t)$。\n\n控制偏微分方程的有限体积离散化形式为：\n$$\n\\frac{d q_i}{dt} = -\\frac{F_{i+1/2} - F_{i-1/2}}{\\Delta x} - S(q_i)\n$$\n此处，$F_{i+1/2}$ 表示 $q$ 穿过单元格 $i$ 和单元格 $i+1$ 之间界面的数值通量。汇项被视为单元格 $i$ 内的局部源项。我们使用前向欧拉方法进行时间积分：\n$$\nq_i^{n+1} = q_i^n + \\Delta t \\left( -\\frac{F_{i+1/2}^n - F_{i-1/2}^n}{\\Delta x} - S(q_i^n) \\right)\n$$\n其中 $q_i^n$ 是时间步 $n$ 的值。两种要求的格式在数值通量 $F$ 的表述上有所不同。\n\n汇项 $S(q)$ 和由此产生的降水率 $P_{\\mathrm{mm/hr}}$ 计算如下：\n$$\nS(q_i^n) = \\max\\left(0, \\frac{q_i^n - q_s}{\\tau_c}\\right)\n$$\n$$\nP_{\\mathrm{mm/hr}}(x_i, t^n) = 3600 \\cdot \\rho_{\\mathrm{air}} \\cdot H \\cdot S(q_i^n)\n$$\n在所有单元格 $i$ 和所有时间步 $n$ 上，此降水率的最大值是关注的量。\n\n时间步长 $\\Delta t$ 由 Courant-Friedrichs-Lewy (CFL) 条件确定。给定库朗数 $\\nu = |u|\\Delta t/\\Delta x$，时间步长为 $\\Delta t = \\nu \\Delta x / |u|$。对于所有测试用例，$u>0$。\n\n初始条件是一个分段常数函数：\n$$\nq_i(0) = \\begin{cases} q_{\\mathrm{patch}}  \\text{if } x_0 \\le x_i \\le x_0 + W \\\\ q_{\\mathrm{bg}}  \\text{otherwise} \\end{cases}\n$$\n其中 $x_i = (i+0.5)\\Delta x$ 是单元格 $i$ 的中心。\n\n在每个时间步之后，解 $q_i^{n+1}$ 被裁剪到物理边界 $[0, q_{\\max}]$ 之内。强制执行周期性边界条件，意味着对于一个索引为 $0, \\dots, N-1$ 的 $N$ 个单元格的网格，单元格 0 的左邻居是单元格 $N-1$，单元格 $N-1$ 的右邻居是单元格 0。\n\n**1. 一阶迎风格式 (U1)**\n\n这种格式简单且稳健，但具有数值耗散性。对于正风速 $u > 0$，“迎风”方向来自左侧。进入界面 $i+1/2$ 的流体状态就是迎风单元格 $i$ 中的状态。因此，数值通量为：\n$$\nF_{i+1/2}^{\\mathrm{U1}} = u \\cdot q_i\n$$\n将此代入有限体积更新方程，得到平流项的趋势：\n$$\n-\\frac{F_{i+1/2}^n - F_{i-1/2}^n}{\\Delta x} = -\\frac{u q_i^n - u q_{i-1}^n}{\\Delta x} = -u \\frac{q_i^n - q_{i-1}^n}{\\Delta x}\n$$\nU1 格式的完整更新方程为：\n$$\nq_i^{n+1} = q_i^n - \\frac{u \\Delta t}{\\Delta x} (q_i^n - q_{i-1}^n) - \\Delta t \\cdot \\max\\left(0, \\frac{q_i^n - q_s}{\\tau_c}\\right)\n$$\n项 $u \\Delta t / \\Delta x$ 是库朗数 $\\nu$。\n\n**2. 高分辨率 TVD MUSCL 格式 (HR)**\n\n单调上游中心守恒律格式（MUSCL）通过在每个单元格中重构数据的分段线性表示来实现更高的空间精度。关键在于限制重构的斜率以避免引入新的振荡，这一特性被称为总变差递减（TVD）。\n\n步骤如下：\na. **斜率计算：** 对于每个单元格 $i$，我们估计一个斜率。确保单调性的常用方法是使用限制斜率。我们首先计算后向差分 $\\Delta_i^b = q_i - q_{i-1}$ 和前向差分 $\\Delta_i^f = q_{i+1} - q_i$。指定的 Van Leer 限制器将它们组合起来，为单元格 $i$ 生成一个限制斜率 $\\sigma_i$：\n$$\n\\sigma_i = \\begin{cases} \\frac{2 \\Delta_i^b \\Delta_i^f}{\\Delta_i^b + \\Delta_i^f}  \\text{if } \\Delta_i^b \\Delta_i^f > 0 \\\\ 0  \\text{if } \\Delta_i^b \\Delta_i^f \\le 0 \\end{cases}\n$$\n该限制器在极值区域（单侧差分符号不同处）为零，并在单调区域提供斜率的调和平均值，这比简单地选择最小幅度的方法更为温和。\n\nb. **数据重构：** 限制斜率 $\\sigma_i$ 用于将 $q$ 的值从单元格中心 $x_i$ 外插到其边界。由于风速 $u$ 为正，我们只需要单元格 $i$ 右边界（即界面 $i+1/2$ 的左边界）的值，记为 $q_{i+1/2}^L$：\n$$\nq_{i+1/2}^L = q_i + \\frac{1}{2}\\sigma_i\n$$\n因子 $1/2$ 来自于在半个单元格宽度 $(\\Delta x / 2)$ 上的外插。斜率被定义为单元格之间的差值，而不是单位长度的差值，因此 $\\Delta x$ 项相互抵消。\n\nc. **通量计算：** 穿过界面 $i+1/2$ 的通量由迎风值决定，对于 $u>0$，该值为 $q_{i+1/2}^L$。\n$$\nF_{i+1/2}^{\\mathrm{HR}} = u \\cdot q_{i+1/2}^L = u \\left(q_i + \\frac{1}{2}\\sigma_i\\right)\n$$\nd. **有限体积更新：** HR 格式的完整更新方程为：\n$$\n\\frac{dq_i}{dt} = -\\frac{1}{\\Delta x} \\left( F_{i+1/2}^{\\mathrm{HR}} - F_{i-1/2}^{\\mathrm{HR}} \\right) - S(q_i) = -\\frac{u}{\\Delta x} \\left( \\left(q_i + \\frac{\\sigma_i}{2}\\right) - \\left(q_{i-1} + \\frac{\\sigma_{i-1}}{2}\\right) \\right) - S(q_i)\n$$\n时间积分像之前一样使用前向欧拉法进行。\n\n这两种格式的根本区别在于它们解析陡峭梯度的能力。U1 格式的数值耗散会使初始的矩形湿区变得模糊，从而降低其峰值，进而降低计算出的最大降水量。而 HR 格式在平滑区域具有二阶精度并能保持单调性，因此将为湿区维持一个更清晰的轮廓，从而产生更高的比湿峰值，并因此带来更高的最大降水率。比率 $R = P_{\\max}^{\\mathrm{HR}} / P_{\\max}^{\\mathrm{U1}}$ 预计将大于 1，它量化了数值耗散对这一极端事件预测的影响。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (general case)\n        {\n            \"L\": 200000.0, \"N\": 256, \"u\": 10.0, \"q_s\": 0.015, \"q_bg\": 0.005,\n            \"q_patch\": 0.025, \"W\": 50000.0, \"x_0\": 50000.0, \"tau_c\": 900.0,\n            \"H\": 1000.0, \"rho_air\": 1.2, \"q_max\": 0.03, \"T_end\": 7200.0, \"nu\": 0.45,\n        },\n        # Case 2 (coarse resolution)\n        {\n            \"L\": 200000.0, \"N\": 64, \"u\": 10.0, \"q_s\": 0.015, \"q_bg\": 0.005,\n            \"q_patch\": 0.025, \"W\": 50000.0, \"x_0\": 50000.0, \"tau_c\": 900.0,\n            \"H\": 1000.0, \"rho_air\": 1.2, \"q_max\": 0.03, \"T_end\": 7200.0, \"nu\": 0.45,\n        },\n        # Case 3 (near Courant limit with faster wind)\n        {\n            \"L\": 200000.0, \"N\": 256, \"u\": 40.0, \"q_s\": 0.015, \"q_bg\": 0.005,\n            \"q_patch\": 0.025, \"W\": 50000.0, \"x_0\": 50000.0, \"tau_c\": 900.0,\n            \"H\": 1000.0, \"rho_air\": 1.2, \"q_max\": 0.03, \"T_end\": 3600.0, \"nu\": 0.45,\n        },\n        # Case 4 (weak supersaturation edge case)\n        {\n            \"L\": 200000.0, \"N\": 256, \"u\": 10.0, \"q_s\": 0.015, \"q_bg\": 0.005,\n            \"q_patch\": 0.016, \"W\": 50000.0, \"x_0\": 50000.0, \"tau_c\": 900.0,\n            \"H\": 1000.0, \"rho_air\": 1.2, \"q_max\": 0.03, \"T_end\": 7200.0, \"nu\": 0.45,\n        }\n    ]\n\n    ratios = []\n    for params in test_cases:\n        ratio = run_simulation(**params)\n        ratios.append(ratio)\n\n    # Format the final output string\n    output_str = f\"[{','.join(f'{r:.6f}' for r in ratios)}]\"\n    print(output_str)\n\n\ndef run_simulation(L, N, u, q_s, q_bg, q_patch, W, x_0, tau_c, H, rho_air, q_max, T_end, nu):\n    \"\"\"\n    Runs one simulation case for both U1 and HR schemes and returns the ratio of max precipitation.\n    \"\"\"\n    # Grid and time step setup\n    dx = L / N\n    dt = nu * dx / abs(u)\n    \n    # Grid cell centers\n    x = (np.arange(N) + 0.5) * dx\n\n    # Initial condition\n    q_initial = np.full(N, q_bg)\n    # Determine indices for the patch based on cell centers\n    # i >= x0/dx - 0.5  and i = (x0+W)/dx - 0.5\n    start_idx = int(np.ceil(x_0 / dx - 0.5))\n    end_idx = int(np.floor((x_0 + W) / dx - 0.5))\n    if end_idx >= start_idx:\n        q_initial[start_idx : end_idx + 1] = q_patch\n\n    # --- Run simulation for both schemes ---\n    p_max_u1 = simulate_scheme(q_initial.copy(), 'U1', N, u, q_s, tau_c, H, rho_air, q_max, T_end, dx, dt, nu)\n    p_max_hr = simulate_scheme(q_initial.copy(), 'HR', N, u, q_s, tau_c, H, rho_air, q_max, T_end, dx, dt, nu)\n\n    if p_max_u1 > 0:\n        return p_max_hr / p_max_u1\n    elif p_max_hr > 0:\n        return np.inf # Should not happen with problem constraints, but for robustness\n    else:\n        return 1.0 # If both are zero, their ratio is 1\n\ndef simulate_scheme(q, scheme_type, N, u, q_s, tau_c, H, rho_air, q_max, T_end, dx, dt, nu):\n    \"\"\"\n    Core simulation loop for a single numerical scheme.\n    \"\"\"\n    \n    def calculate_max_p(current_q):\n        s = np.maximum(0, (current_q - q_s) / tau_c)\n        p_kg_m2_s = rho_air * H * s\n        p_mm_hr = 3600 * p_kg_m2_s\n        return np.max(p_mm_hr) if p_mm_hr.size > 0 else 0.0\n\n    max_p = calculate_max_p(q)\n    \n    time = 0.0\n    while time  T_end:\n        q_old = q.copy()\n\n        # Advection term\n        if scheme_type == 'U1':\n            q_prev = np.roll(q_old, 1) # upwind for u > 0\n            advection_tendency = -nu * (q_old - q_prev)\n        elif scheme_type == 'HR':\n            q_prev = np.roll(q_old, 1)\n            q_next = np.roll(q_old, -1)\n\n            # Van Leer limiter implementation\n            delta_b = q_old - q_prev\n            delta_f = q_next - q_old\n            \n            # Use a small epsilon to avoid division by zero in theory, though with floats it's unlikely\n            # if product is > 0.\n            product = delta_b * delta_f\n            slopes = np.zeros(N)\n            mask = product > 1e-12 # Threshold for numerical stability\n            \n            denominator = delta_b[mask] + delta_f[mask]\n            \n            # Avoid division by zero when denominator is close to zero\n            den_mask = np.abs(denominator) > 1e-12\n            \n            numerator = 2 * product[mask]\n            \n            # Allocate a temporary slopes array for the masked operation\n            masked_slopes = np.zeros_like(denominator)\n            masked_slopes[den_mask] = numerator[den_mask] / denominator[den_mask]\n            \n            slopes[mask] = masked_slopes\n\n            # Reconstruct fluxes\n            # F_{i+1/2} = u * (q_i + 0.5 * sigma_i)\n            flux_iph = u * (q_old + 0.5 * slopes)\n            # F_{i-1/2} = u * (q_{i-1} + 0.5 * sigma_{i-1})\n            flux_imh = np.roll(flux_iph, 1)\n            \n            advection_tendency = -(dt / dx) * (flux_iph - flux_imh)\n        else:\n            raise ValueError(\"Unknown scheme type\")\n            \n        # Sink term\n        sink_tendency = -dt * np.maximum(0, (q_old - q_s) / tau_c)\n        \n        # Update q\n        q = q_old + advection_tendency + sink_tendency\n        \n        # Enforce physical bounds\n        q = np.clip(q, 0.0, q_max)\n        \n        # Update max precipitation\n        max_p = max(max_p, calculate_max_p(q))\n        \n        time += dt\n        \n    return max_p\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在利用数值模式输出进行极端事件统计分析时，“超阈值峰值”（Peaks-Over-Threshold, POT）是一种高效且常用的方法。该方法的基石在于正确选择一个阈值 $u$——只有高于此阈值的数据才被用于建模。本练习将引导您探索阈值选择的理论基础和诊断工具，特别是平均剩余寿命图的概念，并通过构建一个结合了模型拟合优度与理论一致性的复合目标函数，来确定最佳阈值。",
            "id": "4065951",
            "problem": "一个区域对流可分辨数值天气预报模式提供了一个以复合型降水-风极端事件闻名的海岸格点上 $T$ 天的每日总降水量数据。为了使用超阈值峰值 (POT) 方法对日降水量的尾部进行建模，必须选择一个阈值 $u$，使得超过 $u$ 的超出量能够被广义帕累托分布 (GPD) 很好地描述。根据 Pickands–Balkema–de Haan 的极值理论 (EVT) 基础性结果，在广泛的条件下，对于足够高的阈值 $u$，阈值超出量的条件分布会收敛于一个形状参数为 $\\xi$、尺度参数为 $\\sigma$ 的 GPD。\n\n从这一基础出发，推导当 $t \\ge u$ 时的平均剩余寿命函数 $e(t)$，并解释它对极端降水 POT 建模中阈值稳定性的意义。然后，使用一个信息论和诊断框架，构建并应用一个复合目标 $C(u)$，该目标对 GPD 拟合不足以及对平均剩余寿命线性的偏离进行惩罚，其定义为\n$$\nC(u) = \\mathrm{Akaike\\ Information\\ Criterion\\ (AIC)}(u) + \\lambda \\,\\mathrm{SSE}(u),\n$$\n其中 AIC$(u) = 2k - 2\\hat{\\ell}(u)$，$k$ 等于 GPD 参数的数量，$\\hat{\\ell}(u)$ 是对超过 $u$ 的超出量进行 GPD 拟合得到的最大化对数似然，$\\mathrm{SSE}(u)$ 是经验平均剩余寿命 $\\hat{e}(t)$ 在窗口 $t \\in [u, u + 20]$ 内对 $t$ 进行最小二乘线性回归所得的残差平方和，$\\lambda$ 是一个固定的正权重。\n\n对于候选阈值 $u \\in \\{30, 35, 40, 45, 50\\}$ $\\mathrm{mm/day}$，已从模型输出中计算出以下诊断量：\n- 最大化对数似然：$\\hat{\\ell}(30) = -1670$, $\\hat{\\ell}(35) = -1389$, $\\hat{\\ell}(40) = -1190$, $\\hat{\\ell}(45) = -1012$, $\\hat{\\ell}(50) = -890$。\n- 在 $t \\in [u, u+20]$ 上的平均剩余寿命回归残差平方和：$\\mathrm{SSE}(30) = 41.0$, $\\mathrm{SSE}(35) = 22.8$, $\\mathrm{SSE}(40) = 11.6$, $\\mathrm{SSE}(45) = 11.2$, $\\mathrm{SSE}(50) = 18.0$。\n- 广义帕累托形状参数估计值：$\\hat{\\xi}(30) = 0.22$, $\\hat{\\xi}(35) = 0.24$, $\\hat{\\xi}(40) = 0.25$, $\\hat{\\xi}(45) = 0.25$, $\\hat{\\xi}(50) = 0.26$。\n\n取 $k = 2$ 和 $\\lambda = 50$。利用 $e(t)$ 的推导和阈值稳定性的概念，计算每个候选阈值的 $C(u)$，并选择使 $C(u)$ 最小化的最优阈值 $u^{\\star}$。根据复合准则以及从估计的形状参数和平均剩余寿命线性推断出的阈值稳定性诊断标准，阐述您选择的理由。\n\n将最终的数值阈值四舍五入到三位有效数字，并以 $\\mathrm{mm/day}$ 为单位表示。最终答案必须是一个数字。",
            "solution": "该问题经评估是有效的，因为它以极值理论为科学基础，提法明确、客观，并为其解决提供了完整且一致的数据和定义集。\n\n解答按要求分三部分进行：首先，推导广义帕累托分布 (GPD) 的平均剩余寿命函数及其意义；其次，计算候选阈值的复合目标函数；第三，选择最优阈值并阐述理由。\n\n**1. GPD 的平均剩余寿命函数**\n\n平均剩余寿命函数 $e(t)$ 定义为，在随机变量 $X$ 超过水平 $t$ 的条件下，其超过 $t$ 的量的期望值。数学上表示为：\n$$e(t) = E[X - t | X > t]$$\n在超阈值峰值 (POT) 框架中，对于一个高阈值 $u$，在 $X > u$ 的条件下，超出量 $Y = X - u$ 的分布近似于 GPD。对于 $y \\ge 0$，GPD 的累积分布函数 (CDF) 由下式给出：\n$$G(y; \\xi, \\sigma) = 1 - \\left(1 + \\frac{\\xi y}{\\sigma}\\right)^{-1/\\xi} \\quad \\text{for } \\xi \\neq 0$$\n其中 $\\sigma > 0$ 是尺度参数，$\\xi$ 是形状参数。因此，生存函数为：\n$$S_Y(y) = P(Y > y) = 1 - G(y; \\xi, \\sigma) = \\left(1 + \\frac{\\xi y}{\\sigma}\\right)^{-1/\\xi}$$\n为推导 $e(t)$，我们考虑一个水平 $t \\ge u$。令 $d = t - u \\ge 0$。平均剩余寿命函数可以用超出量变量 $Y$ 表示：\n$$e(t) = e(u+d) = E[(X-u) - (t-u) | X-u > t-u] = E[Y - d | Y > d]$$\n对于一个非负随机变量，这个条件期望可以计算为：\n$$E[Y - d | Y > d] = \\frac{\\int_d^{\\infty} S_Y(y) \\, dy}{S_Y(d)}$$\n我们首先计算分子中的积分，假设均值存在（这要求 $\\xi  1$）：\n$$\\int_d^{\\infty} \\left(1 + \\frac{\\xi y}{\\sigma}\\right)^{-1/\\xi} dy$$\n使用换元法，令 $v = 1 + \\frac{\\xi y}{\\sigma}$，这意味着 $dy = \\frac{\\sigma}{\\xi} dv$，积分变为：\n$$\\int_{1+\\frac{\\xi d}{\\sigma}}^{\\infty} v^{-1/\\xi} \\frac{\\sigma}{\\xi} dv = \\frac{\\sigma}{\\xi} \\left[ \\frac{v^{1-1/\\xi}}{1-1/\\xi} \\right]_{1+\\frac{\\xi d}{\\sigma}}^{\\infty}$$\n由于 $\\xi  1$，指数 $1 - 1/\\xi$ 为负，因此表达式在积分上限处的值为 $0$。结果是：\n$$\\frac{\\sigma}{\\xi} \\left( 0 - \\frac{(1+\\frac{\\xi d}{\\sigma})^{1-1/\\xi}}{1-1/\\xi} \\right) = \\frac{\\sigma}{1-\\xi} \\left(1+\\frac{\\xi d}{\\sigma}\\right)^{1-1/\\xi}$$\n现在，我们除以生存函数 $S_Y(d) = (1 + \\frac{\\xi d}{\\sigma})^{-1/\\xi}$：\n$$e(u+d) = \\frac{\\frac{\\sigma}{1-\\xi} (1+\\frac{\\xi d}{\\sigma})^{1-1/\\xi}}{(1 + \\frac{\\xi d}{\\sigma})^{-1/\\xi}} = \\frac{\\sigma}{1-\\xi} \\left(1+\\frac{\\xi d}{\\sigma}\\right) = \\frac{\\sigma + \\xi d}{1-\\xi}$$\n将 $d = t-u$ 代回：\n$$e(t) = \\frac{\\sigma + \\xi(t-u)}{1-\\xi} = \\left(\\frac{\\sigma - \\xi u}{1-\\xi}\\right) + \\left(\\frac{\\xi}{1-\\xi}\\right)t$$\n这个结果表明，对于尾部服从 GPD 的变量，其平均剩余寿命函数 $e(t)$ 在阈值 $u$ 之上的所有 $t$ 处都是 $t$ 的线性函数。\n\n这种线性是用于阈值选择的一个关键性质。一个标准的诊断方法是绘制经验平均剩余寿命函数对阈值的图，并找出图中开始呈现线性的最低阈值 $u$。目标函数中的 $\\mathrm{SSE}(u)$ 项直接惩罚对这种线性的偏离，从而将这种视觉诊断方法形式化。\n\n**2. 复合目标函数的计算**\n\n需要最小化的复合目标函数是 $C(u) = \\mathrm{AIC}(u) + \\lambda \\cdot \\mathrm{SSE}(u)$。\n给定 $k=2$（对应参数 $\\xi$ 和 $\\sigma$）和 $\\lambda=50$。赤池信息准则为 $\\mathrm{AIC}(u) = 2k - 2\\hat{\\ell}(u) = 2(2) - 2\\hat{\\ell}(u) = 4 - 2\\hat{\\ell}(u)$。因此，$C(u) = 4 - 2\\hat{\\ell}(u) + 50 \\cdot \\mathrm{SSE}(u)$。\n\n我们使用提供的数据为每个候选阈值 $u \\in \\{30, 35, 40, 45, 50\\}$ 计算 $C(u)$。\n\n- 对于 $u=30$：\n  $C(30) = 4 - 2(-1670) + 50(41.0) = 4 + 3340 + 2050 = 5394$。\n\n- 对于 $u=35$：\n  $C(35) = 4 - 2(-1389) + 50(22.8) = 4 + 2778 + 1140 = 3922$。\n\n- 对于 $u=40$：\n  $C(40) = 4 - 2(-1190) + 50(11.6) = 4 + 2380 + 580 = 2964$。\n\n- 对于 $u=45$：\n  $C(45) = 4 - 2(-1012) + 50(11.2) = 4 + 2024 + 560 = 2588$。\n\n- 对于 $u=50$：\n  $C(50) = 4 - 2(-890) + 50(18.0) = 4 + 1780 + 900 = 2684$。\n\n**3. 最优阈值的选择与理由阐述**\n\n复合目标函数的计算值如下：\n- $C(30) = 5394$\n- $C(35) = 3922$\n- $C(40) = 2964$\n- $C(45) = 2588$\n- $C(50) = 2684$\n\n$C(u)$ 的最小值为 $2588$，出现在 $u=45$ 处。因此，最优阈值为 $u^{\\star} = 45 \\, \\mathrm{mm/day}$。\n\n这一选择的理由可通过考察目标函数的组成部分以及估计形状参数的行为来阐述，这些都是阈值稳定性的标准诊断方法。\n\n- **复合准则**：$C(u)$ 的最小化本身直接指向 $u^{\\star}=45$ 为最优选择，因为它代表了模型拟合度（由 AIC 衡量）与对 GPD 理论性质（由平均剩余寿命的线性度衡量）的遵循之间的最佳权衡。\n\n- **平均剩余寿命线性**：残差平方和 $\\mathrm{SSE}(u)$ 量化了对线性的偏离。其值为 $41.0, 22.8, 11.6, 11.2, 18.0$。最小的 $\\mathrm{SSE}$ 出现在 $u=45$ 处，表明经验平均剩余寿命图在该阈值下最具线性。从 $u=30$ 到 $u=40$，SSE 的急剧下降证实了较低的阈值是不合适的。在 $u=50$ 时 SSE 的增加表明超出量的数量变得过少，导致抽样变异性增加和估计值稳定性下降。\n\n- **形状参数稳定性**：一个有效的阈值应该位于估计形状参数 $\\hat{\\xi}$ 稳定的区域内。所提供的估计值为 $\\hat{\\xi}(30) = 0.22$, $\\hat{\\xi}(35) = 0.24$, $\\hat{\\xi}(40) = 0.25$, $\\hat{\\xi}(45) = 0.25$ 和 $\\hat{\\xi}(50) = 0.26$。当 $u < 40$ 时，参数估计值在变化，但在 $u=40$ 和 $u=45$ 时，它们在 $\\hat{\\xi}=0.25$ 处非常稳定。这种稳定性提供了强有力的证据，表明渐近的 GPD 尾部行为在 $u=40$ 附近开始出现。$u^{\\star}=45$ 的选择落在了这个稳定区域内。\n\n总之，所有诊断标准都汇集支持选择 $u^{\\star} = 45 \\, \\mathrm{mm/day}$。它最小化了复合惩罚函数，对应于最线性的平均剩余寿命图，并位于形状参数的最大稳定区域内。题目要求答案四舍五入到三位有效数字，即 $45.0$。",
            "answer": "$$\\boxed{45.0}$$"
        },
        {
            "introduction": "选择了合适的阈值后，POT 分析的下一步是对超出该阈值的极值数据进行拟合。根据极值理论，这些超阈值数据可以用广义帕累托分布（Generalized Pareto Distribution, GPD）来描述。本练习将指导您完成 POT 分析流程的最后一步：使用 L-矩方法估计 GPD 的参数，并结合泊松过程模型来计算指定重现期的风速回归水平。这个练习不仅巩固了您对 GPD 模型的理解，还介绍了一种相比极大似然估计更为稳健的参数估计技术。",
            "id": "4066104",
            "problem": "您的任务是实现一个适用于数值天气预报和气候建模中极值分析的数值程序，以基于极值理论（EVT）的超阈值峰值（Peaks-Over-Threshold）方法，根据超出高阈值的超阈值量来估计风速的重现水平。\n\n核心建模假设必须从第一性原理推导得出：在超阈值峰值极限下，阈值超阈值量服从广义帕累托分布（GPD），并且超阈值量随时间的出现由齐次泊松过程建模。\n\n基于这些基础，您必须设计一个算法，该算法能够：\n- 使用概率加权矩（PWMs），特别是其被称为L-矩的线性组合，从超阈值数据中估计GPD的形状参数 $\\xi$ 和尺度参数 $\\beta$。\n- 使用单位时间内超阈值的泊松率，将参数估计值转换为指定重现期的重现水平。\n- 在 $\\xi$ 接近于零时，为指数分布实现一个特殊情况下的极限处理。\n\n您的实现不能依赖预打包的估计例程，并且必须根据顺序统计量明确计算样本L-矩。请使用以下定义和要求。\n\n定义和要求：\n- 设超阈值量为 $y_i = x_i - u$，其中 $x_i$ 是超过固定阈值 $u$ 的观测风速，且 $y_i \\ge 0$。\n- 假设超阈值时间服从一个齐次泊松过程，其率为 $\\lambda$（单位：次/年）。如果在 $T$ 年内观测到 $N$ 次超阈值，则 $\\lambda = N/T$。\n- 对于GPD，用 $F(y)$ 表示 $y \\ge 0$ 时的累积分布函数，用 $Q(p)$ 表示 $p \\in (0,1)$ 时的分位数函数。\n- 使用样本L-矩进行估计：\n  - 一阶L-矩 $\\ell_1$ 等于超阈值量的样本均值：$\\ell_1 = \\frac{1}{n}\\sum_{i=1}^{n} y_{i:n}$，其中 $y_{i:n}$ 是按升序排列的顺序统计量。\n  - 二阶L-矩 $\\ell_2$ 是使用移位的勒让德权重 $L_1(p)=2p-1$ 从顺序统计量计算得出的，其无偏样本估计量为\n    $$\\ell_2 = \\frac{1}{n(n-1)} \\sum_{i=1}^{n} \\left(2i - n - 1\\right) y_{i:n}.$$\n- 从L-矩的积分定义出发，利用GPD的分位数表示，推导出GPD参数 $(\\xi,\\beta)$ 的估计量。\n- 将重现水平 $z_P$ 定义为在泊松-GPD模型下，长度为 $P$ 年的时期内平均被超过一次的预期风速水平（单位：米/秒），并从第一性原理推导出相应公式。明确地实现当 $\\xi \\to 0$ 时的适当极限。\n\n单位和数值规范：\n- 所有风速量必须以米/秒（m/s）表示。最终的重现水平必须以米/秒打印，并四舍五入到三位小数。\n- 此问题不涉及角度。\n- 不允许使用百分比；任何与概率相关的量都必须以小数表示。\n\n测试套件和数据生成：\n为确保不含随机性的可复现性，请使用在均匀间隔概率 $p_i = \\frac{i - 0.5}{n}$（其中 $i = 1,\\dots,n$）上求值的适当分位数函数，来确定性地生成超阈值样本。使用以下三个测试用例：\n\n- 测试用例1（重尾，理想路径）：\n  - 阈值：$u = 20$ 米/秒。\n  - 用于合成生成的真实参数：$\\xi_{\\text{true}} = 0.2$，$\\beta_{\\text{true}} = 5$ 米/秒。\n  - 样本量：$n = 60$。\n  - 观测期：$T = 12$ 年。\n  - 通过GPD分位数函数 $Q(p)$ 生成超阈值量。\n  - 重现期：$P = 50$ 年。\n\n- 测试用例2（近指数，边界行为）：\n  - 阈值：$u = 25$ 米/秒。\n  - 用于合成生成的真实参数：$\\xi_{\\text{true}} = 0$（使用指数极限），$\\beta_{\\text{true}} = 8$ 米/秒。\n  - 样本量：$n = 80$。\n  - 观测期：$T = 16$ 年。\n  - 通过GPD分位数的指数极限生成超阈值量：$Q(p) = -\\beta_{\\text{true}} \\ln(1 - p)$。\n  - 重现期：$P = 100$ 年。\n\n- 测试用例3（有界尾，负形状）：\n  - 阈值：$u = 18$ 米/秒。\n  - 用于合成生成的真实参数：$\\xi_{\\text{true}} = -0.2$，$\\beta_{\\text{true}} = 6$ 米/秒。\n  - 样本量：$n = 40$。\n  - 观测期：$T = 8$ 年。\n  - 通过带有负 $\\xi_{\\text{true}}$ 的GPD分位数函数 $Q(p)$ 生成超阈值量。\n  - 重现期：$P = 200$ 年。\n\n您的程序应产生单行输出，其中包含三个测试用例的重现水平（单位：m/s，四舍五入到三位小数），汇总成一个用方括号括起来的逗号分隔列表。例如：“[z1,z2,z3]”。输出必须仅为一行，不含任何额外文本。",
            "solution": "该问题是有效的，因为它在科学上以极值理论（EVT）为基础，是一个具有明确目标的适定问题，并为获得唯一的、确定性的解提供了所有必要信息。任务是实现一个超阈值峰值（POT）分析，以估计风速的重现水平。解决方案按要求从第一性原理出发进行开发。\n\n该分析基于一个复合模型，其中超过高阈值 $u$ 的超阈值量服从广义帕累托分布（GPD），而这些超阈值量的出现由齐次泊松过程描述。\n\n对于一个超阈值量 $y \\geq 0$，GPD的累积分布函数（CDF）由下式给出：\n$$ F(y; \\xi, \\beta) = \\begin{cases} 1 - \\left(1 + \\frac{\\xi y}{\\beta}\\right)^{-1/\\xi}  \\text{if } \\xi \\neq 0 \\\\ 1 - \\exp\\left(-\\frac{y}{\\beta}\\right)  \\text{if } \\xi = 0 \\end{cases} $$\n其中 $\\xi$ 是形状参数，$\\beta > 0$ 是尺度参数。当 $\\xi \\geq 0$ 时，分布的支撑集为 $y \\geq 0$；当 $\\xi  0$ 时，支撑集为 $0 \\leq y \\leq -\\beta/\\xi$。\n\n相应的分位数函数 $Q(p)$ 给出满足 $F(y)=p$ 的值 $y$，它通过对CDF求逆得到：\n$$ Q(p; \\xi, \\beta) = \\begin{cases} \\frac{\\beta}{\\xi}\\left((1-p)^{-\\xi} - 1\\right)  \\text{if } \\xi \\neq 0 \\\\ -\\beta\\ln(1-p)  \\text{if } \\xi = 0 \\end{cases} $$\n其中 $p \\in (0,1)$。该函数用于从一组均匀概率 $p_i = (i-0.5)/n$ 中生成确定性的超阈值样本 $y_i$。\n\n参数 $(\\xi, \\beta)$ 使用L-矩法进行估计。前两个理论L-矩 $L_1$ 和 $L_2$ 是概率加权矩的线性组合，由分位数函数的积分定义：\n$$ L_1 = \\int_0^1 Q(p) \\, dp $$\n$$ L_2 = \\int_0^1 Q(p) (2p-1) \\, dp $$\n对于GPD，当 $\\xi  1$ 时，这些积分可以被解析地计算。代入 $\\xi \\neq 0$ 时的GPD分位数函数 $Q(p)$ 并执行积分，可得：\n$$ L_1 = \\frac{\\beta}{1-\\xi} $$\n$$ L_2 = \\frac{\\beta}{(1-\\xi)(2-\\xi)} $$\n前两个L-矩的比率 $\\tau_2 = L_2/L_1$ 提供了与形状参数 $\\xi$ 的直接关系：\n$$ \\tau_2 = \\frac{L_2}{L_1} = \\frac{\\beta/((1-\\xi)(2-\\xi))}{\\beta/(1-\\xi)} = \\frac{1}{2-\\xi} $$\n解出 $\\xi$ 可得 $\\xi = 2 - 1/\\tau_2$。随后，使用 $L_1$ 的表达式解出 $\\beta$ 可得 $\\beta = L_1(1-\\xi)$。\n\nL-矩法通过用其样本对应物 $(\\ell_1, \\ell_2)$ 替换理论L-矩 $(L_1, L_2)$ 来估计参数。\n样本L-矩是根据有序的超阈值数据 $y_{1:n} \\le y_{2:n} \\le \\dots \\le y_{n:n}$ 计算的：\n- 一阶样本L-矩 $\\ell_1$ 是样本均值：$\\ell_1 = \\frac{1}{n} \\sum_{i=1}^n y_{i:n}$。\n- 二阶样本L-矩 $\\ell_2$ 的估计公式为：$\\ell_2 = \\frac{1}{n(n-1)} \\sum_{i=1}^n (2i - n - 1) y_{i:n}$。\n\n因此，GPD参数的L-矩估计量为：\n$$ \\hat{\\tau}_2 = \\frac{\\ell_2}{\\ell_1} $$\n$$ \\hat{\\xi} = 2 - \\frac{1}{\\hat{\\tau}_2} = 2 - \\frac{\\ell_1}{\\ell_2} $$\n$$ \\hat{\\beta} = \\ell_1 (1-\\hat{\\xi}) $$\n这些估计量在算法中被直接实现。\n\n最后一步是计算 $P$ 年重现水平 $z_P$。这是预计每 $P$ 年平均被超过一次的风速。阈值超阈值的发生率被建模为泊松过程，其率为每年 $\\lambda_u = N/T$ 次事件，其中 $N$ 是在 $T$ 年内观测到的超阈值次数。在我们的案例中， $N=n$。任意一个超阈值量 $y$ 大于某个值 $y_p$ 的概率由GPD生存函数给出，$S(y_p) = 1 - F(y_p)$。\n\n超过水平 $z_P = u + y_P$ 的超阈值率由泊松过程的稀疏化给出：$\\lambda_{z_P} = \\lambda_u S(y_P)$。对于一个 $P$ 年的重现期，这个率必须是 $1/P$。因此，我们有条件：\n$$ S(y_P) = \\frac{1}{\\lambda_u P} $$\n代入 $\\xi \\neq 0$ 时的GPD生存函数：\n$$ \\left(1 + \\frac{\\xi y_P}{\\beta}\\right)^{-1/\\xi} = \\frac{1}{\\lambda_u P} $$\n解出 $y_P$ 可得：\n$$ y_P = \\frac{\\beta}{\\xi} \\left[ (\\lambda_u P)^{\\xi} - 1 \\right] $$\n那么重现水平为 $z_P = u + y_P$：\n$$ z_P = u + \\frac{\\beta}{\\xi} \\left[ (\\lambda_u P)^{\\xi} - 1 \\right] $$\n对于 $\\xi \\to 0$ 的特殊情况（指数分布），我们对 $y_P$ 的表达式取极限。使用极限定义 $\\lim_{h \\to 0} (a^h - 1)/h = \\ln(a)$：\n$$ \\lim_{\\xi \\to 0} y_P = \\lim_{\\xi \\to 0} \\beta \\frac{(\\lambda_u P)^{\\xi} - 1}{\\xi} = \\beta \\ln(\\lambda_u P) $$\n这导出了指数情况下的重现水平公式：\n$$ z_P = u + \\beta \\ln(\\lambda_u P) $$\n算法在这些公式中使用估计参数 $(\\hat{\\xi}, \\hat{\\beta})$。为了稳定性，使用一个数值容差 $|\\hat{\\xi}|  10^{-8}$ 来切换到对数公式。为了在 $\\xi$ 很小但非零时进行稳健计算，项 $(m^{\\xi} - 1)$ 被计算为 $\\text{expm1}(\\xi \\ln m)$，其中 $m = \\lambda_u P$。这避免了精度损失。最终的算法为每个测试用例系统地实现了这些推导出的步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the extreme value analysis problem by deriving and implementing\n    a Peaks-Over-Threshold procedure using L-moment estimation.\n    \"\"\"\n\n    def calculate_return_level(u, xi_true, beta_true, n, T, P):\n        \"\"\"\n        Performs the complete Peaks-Over-Threshold analysis for a single test case.\n\n        Args:\n            u (float): The threshold for exceedances in m/s.\n            xi_true (float): The true shape parameter for data generation.\n            beta_true (float): The true scale parameter for data generation.\n            n (int): The number of exceedances (sample size).\n            T (int): The observation period in years.\n            P (int): The return period in years.\n\n        Returns:\n            float: The estimated return level z_P in m/s.\n        \"\"\"\n        # Step 1: Generate deterministic exceedance data based on GPD quantiles.\n        # The probabilities p_i = (i - 0.5) / n for i = 1, ..., n are used.\n        p_values = (np.arange(1, n + 1) - 0.5) / n\n        \n        if xi_true == 0:\n            # Case for exponential distribution (xi -> 0 limit of GPD)\n            # Q(p) = -beta * log(1-p)\n            # Using np.log1p for numerical stability as p -> 1.\n            y_samples = -beta_true * np.log1p(-p_values)\n        else:\n            # Case for GPD with xi != 0\n            # Q(p) = beta/xi * ((1-p)^(-xi) - 1)\n            # Using np.expm1 and np.log1p for stability.\n            y_samples = (beta_true / xi_true) * np.expm1(-xi_true * np.log1p(-p_values))\n            \n        # The generated samples are already sorted and represent the order statistics y_{i:n}.\n\n        # Step 2: Estimate GPD parameters using the method of L-moments.\n        # The first sample L-moment (l1) is the sample mean.\n        l1 = np.mean(y_samples)\n        \n        # The second sample L-moment (l2) is calculated from order statistics.\n        # The formula is l2 = 1/(n*(n-1)) * sum_{i=1 to n} (2i - n - 1) * y_{i:n}.\n        # For 0-based index j=i-1, the coefficient is (2(j+1) - n - 1) = (2j - n + 1).\n        if n > 1:\n            j_indices = np.arange(n)\n            l2_coeffs = 2 * j_indices - n + 1\n            l2_sum = np.sum(l2_coeffs * y_samples)\n            l2 = l2_sum / (n * (n - 1))\n        else: # Edge case for n=1, where l2 is undefined.\n            l2 = 0.0\n\n        # Now, derive parameter estimates from l1 and l2.\n        # An l2 near zero would make xi estimation unstable; this case is unlikely here.\n        if abs(l2)  1e-15:\n            xi_hat = 0.0  # Treat as exponential if l2 is effectively zero.\n        else:\n            # Estimator for xi from the L-moment ratio: xi = 2 - l1/l2\n            xi_hat = 2.0 - l1 / l2\n            \n        # Estimator for beta from l1 and xi_hat: beta = l1 * (1 - xi)\n        beta_hat = l1 * (1.0 - xi_hat)\n\n        # Step 3: Calculate the return level z_P.\n        # Poisson rate of threshold exceedances (events per year).\n        lambda_u = n / T\n        \n        # Mean number of exceedances over the return period P.\n        m = lambda_u * P\n        \n        # Use a small tolerance to select the appropriate formula for z_P\n        # to ensure numerical stability when xi_hat is close to zero.\n        if abs(xi_hat)  1e-8:\n            # Formula for the xi -> 0 limit (exponential case): y_P = beta * log(m)\n            y_p = beta_hat * np.log(m)\n        else:\n            # General GPD formula: y_P = beta/xi * (m^xi - 1)\n            # Implemented with np.expm1 for better precision.\n            y_p = (beta_hat / xi_hat) * np.expm1(xi_hat * np.log(m))\n            \n        z_p = u + y_p\n        \n        return z_p\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (u, xi_true, beta_true, n, T, P)\n        (20.0, 0.2, 5.0, 60, 12, 50),\n        (25.0,  0.0, 8.0, 80, 16, 100),\n        (18.0, -0.2, 6.0, 40, 8, 200),\n    ]\n\n    results = []\n    for case in test_cases:\n        u, xi_true, beta_true, n, T, P = case\n        z_p = calculate_return_level(u, xi_true, beta_true, n, T, P)\n        results.append(f\"{z_p:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}