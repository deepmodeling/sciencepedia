{
    "hands_on_practices": [
        {
            "introduction": "SAL（结构-振幅-位置）方法是基于对象的预报检验的基石，它将总预报误差分解为三个直观的分量：结构（形状和大小）、振幅（平均强度）和降水对象的位置误差。通过一个理想化高斯函数的解析示例，你将对每个SAL分量的定义及其如何响应特定类型的预报误差建立起基本的理解。在处理更复杂的真实世界数据之前，这个练习为你提供了坚实的理论基础。",
            "id": "4090731",
            "problem": "考虑定义在半径为 $R$ 的圆形域 $\\Omega = \\{\\mathbf{x} \\in \\mathbb{R}^{2}:\\ \\|\\mathbf{x}\\| \\leq R\\}$ 上的连续二维降水强度场，其中预报场由 $F(\\mathbf{x}) = H_{f} \\exp\\!\\big(-\\|\\mathbf{x} - \\mathbf{x}_{f}\\|^{2}/(2\\sigma_{f}^{2})\\big)$ 给出，观测场由 $O(\\mathbf{x}) = H_{o} \\exp\\!\\big(-\\|\\mathbf{x} - \\mathbf{x}_{o}\\|^{2}/(2\\sigma_{o}^{2})\\big)$ 给出。两个场的中心均位于原点，即 $\\mathbf{x}_{f} = \\mathbf{x}_{o} = \\mathbf{0}$。假设场是各向同性的，并且域半径 $R$ 相对于 $\\sigma_{f}$ 和 $\\sigma_{o}$ 足够大，以至于在 $r=R$ 处对高斯尾部的截断在四位有效数字的精度下可以忽略不计。\n\n使用结构-振幅-位置（SAL）检验三元组，为以下参数选择计算分量 $S$、$A$ 和 $L$：\n- $H_{o} = 20$，单位为 $\\mathrm{mm\\,h^{-1}}$，$\\sigma_{o} = 15$，单位为 $\\mathrm{km}$，\n- $H_{f} = 12$，单位为 $\\mathrm{mm\\,h^{-1}}$，$\\sigma_{f} = 30$，单位为 $\\mathrm{km}$，\n- $R = 200$，单位为 $\\mathrm{km}$。\n\n使用以下定义：\n- 振幅分量：区域平均值为 $\\overline{F} = \\frac{1}{\\pi R^{2}} \\int_{\\Omega} F(\\mathbf{x})\\, d\\mathbf{x}$ 和 $\\overline{O} = \\frac{1}{\\pi R^{2}} \\int_{\\Omega} O(\\mathbf{x})\\, d\\mathbf{x}$，且\n$$A = \\frac{2\\big(\\overline{F} - \\overline{O}\\big)}{\\overline{F} + \\overline{O}}。$$\n- 位置分量：$L = L_{1} + L_{2}$，其中 $L_{1} = \\frac{\\|\\mathbf{x}_{f} - \\mathbf{x}_{o}\\|}{2R}$，以及基于离散度的项\n$$r(F) = \\frac{\\int_{\\Omega} \\|\\mathbf{x} - \\mathbf{x}_{f}\\|\\, F(\\mathbf{x})\\, d\\mathbf{x}}{\\int_{\\Omega} F(\\mathbf{x})\\, d\\mathbf{x}}, \\quad r(O) = \\frac{\\int_{\\Omega} \\|\\mathbf{x} - \\mathbf{x}_{o}\\|\\, O(\\mathbf{x})\\, d\\mathbf{x}}{\\int_{\\Omega} O(\\mathbf{x})\\, d\\mathbf{x}}, \\quad L_{2} = \\frac{|r(F) - r(O)|}{2R}。$$\n- 结构分量：将每个场的高强度核心定义在半峰值处，\n$$C(F) = \\left\\{\\mathbf{x} \\in \\Omega:\\ F(\\mathbf{x}) \\geq \\frac{H_{f}}{2}\\right\\}, \\quad C(O) = \\left\\{\\mathbf{x} \\in \\Omega:\\ O(\\mathbf{x}) \\geq \\frac{H_{o}}{2}\\right\\},$$\n以及归一化的核心面积分数\n$$s(F) = \\frac{\\mathrm{area}\\big(C(F)\\big)}{\\pi R^{2}}, \\quad s(O) = \\frac{\\mathrm{area}\\big(C(O)\\big)}{\\pi R^{2}}, \\quad S = \\frac{2\\big(s(F) - s(O)\\big)}{s(F) + s(O)}。$$\n\n在上述大域近似下计算 $S$、$A$ 和 $L$，并将最终的 SAL 三元组以无量纲数的形式给出。将每个分量四舍五入至四位有效数字。使用 LaTeX 的 $\\mathrm{pmatrix}$ 环境将最终答案表示为单个行向量。",
            "solution": "用户提供了一个通过所有验证标准的问题。该问题在气象预报检验领域具有科学依据，在数学上是适定的、客观的，并包含获得唯一解所需的全部信息。因此，我将对结构-振幅-位置（SAL）的各个分量进行完整推导。\n\n该问题要求计算二维高斯降水场的 SAL 三元组 $(S, A, L)$。预报场为 $F(\\mathbf{x}) = H_{f} \\exp(-\\|\\mathbf{x} - \\mathbf{x}_{f}\\|^{2}/(2\\sigma_{f}^{2}))$，观测场为 $O(\\mathbf{x}) = H_{o} \\exp(-\\|\\mathbf{x} - \\mathbf{x}_{o}\\|^{2}/(2\\sigma_{o}^{2}))$。两个场的中心都位于原点，因此 $\\mathbf{x}_{f} = \\mathbf{x}_{o} = \\mathbf{0}$。这些场定义在半径为 $R$ 的圆形域 $\\Omega$ 上。大域近似表明，来自 $\\Omega$ 外部场的贡献可以忽略不计，这使我们能够用在整个平面 $\\mathbb{R}^{2}$ 上的积分来近似在 $\\Omega$ 上的积分。\n\n给定的参数是：\n$H_{o} = 20$，$\\sigma_{o} = 15$\n$H_{f} = 12$，$\\sigma_{f} = 30$\n$R = 200$\n所有单位都是一致的（强度单位为 mm/h，长度单位为 km）。\n\n我们将依次计算 SAL 三元组的每个分量。\n\n### 1. 振幅分量 ($A$)\n\n振幅分量 $A$ 定义为\n$$A = \\frac{2\\big(\\overline{F} - \\overline{O}\\big)}{\\overline{F} + \\overline{O}}$$\n其中 $\\overline{F}$ 和 $\\overline{O}$ 是区域平均降水强度。\n$\\overline{F} = \\frac{1}{\\pi R^{2}} \\int_{\\Omega} F(\\mathbf{x})\\, d\\mathbf{x}$ 且 $\\overline{O} = \\frac{1}{\\pi R^{2}} \\int_{\\Omega} O(\\mathbf{x})\\, d\\mathbf{x}$。\n\n让我们首先计算总降水量，即强度场在整个域上的积分。对于预报场，当 $\\mathbf{x}_{f} = \\mathbf{0}$ 时：\n$$V_{f} = \\int_{\\Omega} F(\\mathbf{x})\\, d\\mathbf{x} = \\int_{\\Omega} H_{f} \\exp\\left(\\frac{-\\|\\mathbf{x}\\|^{2}}{2\\sigma_{f}^{2}}\\right)\\, d\\mathbf{x}$$\n使用大域近似，我们可以将积分扩展到整个平面 $\\mathbb{R}^{2}$。我们转换到极坐标 $(r, \\theta)$，其中 $\\|\\mathbf{x}\\| = r$ 且 $d\\mathbf{x} = r\\,dr\\,d\\theta$。\n$$V_{f} \\approx \\int_{0}^{2\\pi} \\int_{0}^{\\infty} H_{f} \\exp\\left(\\frac{-r^{2}}{2\\sigma_{f}^{2}}\\right) r\\,dr\\,d\\theta$$\n积分可以分解为一个角向部分和一个径向部分：\n$$V_{f} = 2\\pi H_{f} \\int_{0}^{\\infty} r \\exp\\left(\\frac{-r^{2}}{2\\sigma_{f}^{2}}\\right) dr$$\n令 $u = r^{2}/(2\\sigma_{f}^{2})$，则 $du = r/\\sigma_{f}^{2} \\,dr$，得到 $r\\,dr = \\sigma_{f}^{2}\\,du$。\n$$V_{f} = 2\\pi H_{f} \\int_{0}^{\\infty} \\exp(-u) \\sigma_{f}^{2}\\,du = 2\\pi H_{f} \\sigma_{f}^{2} [-\\exp(-u)]_{0}^{\\infty} = 2\\pi H_{f} \\sigma_{f}^{2}$$\n完全类似地，总观测体积为 $V_{o} = 2\\pi H_{o} \\sigma_{o}^{2}$。\n\n现在我们可以计算区域平均强度：\n$$\\overline{F} = \\frac{V_{f}}{\\pi R^{2}} = \\frac{2\\pi H_{f} \\sigma_{f}^{2}}{\\pi R^{2}} = \\frac{2 H_{f} \\sigma_{f}^{2}}{R^{2}}$$\n$$\\overline{O} = \\frac{V_{o}}{\\pi R^{2}} = \\frac{2\\pi H_{o} \\sigma_{o}^{2}}{\\pi R^{2}} = \\frac{2 H_{o} \\sigma_{o}^{2}}{R^{2}}$$\n代入给定值：\n$\\overline{F} = \\frac{2(12)(30)^{2}}{200^{2}} = \\frac{24 \\cdot 900}{40000} = \\frac{21600}{40000} = 0.54$。\n$\\overline{O} = \\frac{2(20)(15)^{2}}{200^{2}} = \\frac{40 \\cdot 225}{40000} = \\frac{9000}{40000} = 0.225$。\n\n最后，我们计算 $A$：\n$$A = \\frac{2(0.54 - 0.225)}{0.54 + 0.225} = \\frac{2(0.315)}{0.765} = \\frac{0.63}{0.765} \\approx 0.823529...$$\n四舍五入到四位有效数字，$A = 0.8235$。\n\n### 2. 位置分量 ($L$)\n\n位置分量为 $L = L_{1} + L_{2}$。\n$L_{1}$ 项与质心的位移有关：\n$$L_{1} = \\frac{\\|\\mathbf{x}_{f} - \\mathbf{x}_{o}\\|}{2R}$$\n由于给定中心是共位的，$\\mathbf{x}_{f} = \\mathbf{x}_{o} = \\mathbf{0}$，我们有 $L_{1} = 0$。\n\n$L_{2}$ 项与降水距各自中心的平均距离之差有关：\n$$L_{2} = \\frac{|r(F) - r(O)|}{2R}$$\n其中 $r(F) = \\frac{\\int_{\\Omega} \\|\\mathbf{x} - \\mathbf{x}_{f}\\|\\, F(\\mathbf{x})\\, d\\mathbf{x}}{\\int_{\\Omega} F(\\mathbf{x})\\, d\\mathbf{x}}$。\n当 $\\mathbf{x}_{f} = \\mathbf{0}$ 时，分母是 $V_{f} = 2\\pi H_{f} \\sigma_{f}^{2}$。分子是：\n$$N_{f} = \\int_{\\Omega} \\|\\mathbf{x}\\| F(\\mathbf{x})\\, d\\mathbf{x} = \\int_{\\Omega} \\|\\mathbf{x}\\| H_{f} \\exp\\left(\\frac{-\\|\\mathbf{x}\\|^{2}}{2\\sigma_{f}^{2}}\\right)\\, d\\mathbf{x}$$\n再次使用极坐标和大域近似：\n$$N_{f} \\approx \\int_{0}^{2\\pi} \\int_{0}^{\\infty} r H_{f} \\exp\\left(\\frac{-r^{2}}{2\\sigma_{f}^{2}}\\right) r\\,dr\\,d\\theta = 2\\pi H_{f} \\int_{0}^{\\infty} r^{2} \\exp\\left(\\frac{-r^{2}}{2\\sigma_{f}^{2}}\\right) dr$$\n这是一个标准的高斯积分，形式为 $\\int_{0}^{\\infty} x^{2} \\exp(-ax^{2})dx = \\frac{\\sqrt{\\pi}}{4a^{3/2}}$。此处，$a=1/(2\\sigma_{f}^{2})$。\n$$\\int_{0}^{\\infty} r^{2} \\exp\\left(\\frac{-r^{2}}{2\\sigma_{f}^{2}}\\right) dr = \\frac{\\sqrt{\\pi}}{4(1/(2\\sigma_{f}^{2}))^{3/2}} = \\frac{\\sqrt{\\pi}}{4/(2\\sigma_{f}^{2}\\sqrt{2\\sigma_{f}^{2}})} = \\frac{\\sqrt{\\pi} \\cdot 2\\sqrt{2} \\sigma_{f}^{3}}{4} = \\frac{\\sqrt{2\\pi}}{2}\\sigma_{f}^{3}$$\n所以，分子是 $N_{f} = 2\\pi H_{f} \\left(\\frac{\\sqrt{2\\pi}}{2}\\sigma_{f}^{3}\\right) = \\pi\\sqrt{2\\pi}H_{f}\\sigma_{f}^{3}$。\n那么，$r(F)$ 是分子与分母的比值：\n$$r(F) = \\frac{N_{f}}{V_{f}} = \\frac{\\pi\\sqrt{2\\pi}H_{f}\\sigma_{f}^{3}}{2\\pi H_{f}\\sigma_{f}^{2}} = \\frac{\\sqrt{2\\pi}}{2}\\sigma_{f}$$\n类似地，对于观测场，$r(O) = \\frac{\\sqrt{2\\pi}}{2}\\sigma_{o}$。\n\n现在我们代入数值：\n$r(F) = \\frac{\\sqrt{2\\pi}}{2}(30) = 15\\sqrt{2\\pi}$ km。\n$r(O) = \\frac{\\sqrt{2\\pi}}{2}(15) = 7.5\\sqrt{2\\pi}$ km。\n\n$L_{2} = \\frac{|15\\sqrt{2\\pi} - 7.5\\sqrt{2\\pi}|}{2(200)} = \\frac{7.5\\sqrt{2\\pi}}{400}$。\n$L_{2} \\approx \\frac{7.5(2.506628)}{400} \\approx \\frac{18.79971}{400} \\approx 0.046999...$\n因此，$L = L_{1} + L_{2} = 0 + L_{2} \\approx 0.046999...$。\n四舍五入到四位有效数字，$L = 0.04700$。\n\n### 3. 结构分量 ($S$)\n\n结构分量 $S$ 定义为\n$$S = \\frac{2\\big(s(F) - s(O)\\big)}{s(F) + s(O)}$$\n其中 $s(F)$ 和 $s(O)$ 是归一化的核心面积分数。核心 $C(F)$ 定义为强度至少为其最大值一半的区域：\n$C(F) = \\{\\mathbf{x} \\in \\Omega:\\ F(\\mathbf{x}) \\geq H_{f}/2\\}$。\n$$H_{f} \\exp\\left(\\frac{-\\|\\mathbf{x}\\|^{2}}{2\\sigma_{f}^{2}}\\right) \\geq \\frac{H_{f}}{2} \\implies \\exp\\left(\\frac{-\\|\\mathbf{x}\\|^{2}}{2\\sigma_{f}^{2}}\\right) \\geq \\frac{1}{2}$$\n对两边取自然对数：\n$$\\frac{-\\|\\mathbf{x}\\|^{2}}{2\\sigma_{f}^{2}} \\geq \\ln\\left(\\frac{1}{2}\\right) = -\\ln(2)$$\n$$\\|\\mathbf{x}\\|^{2} \\leq 2\\sigma_{f}^{2}\\ln(2) \\implies \\|\\mathbf{x}\\| \\leq \\sigma_{f}\\sqrt{2\\ln(2)}$$\n这描述了一个以原点为中心的圆盘。该核心的半径为 $R_{f} = \\sigma_{f}\\sqrt{2\\ln(2)}$。核心的面积为 $\\mathrm{area}(C(F)) = \\pi R_{f}^{2} = 2\\pi\\sigma_{f}^{2}\\ln(2)$。\n归一化的核心面积分数为：\n$$s(F) = \\frac{\\mathrm{area}(C(F))}{\\pi R^{2}} = \\frac{2\\pi\\sigma_{f}^{2}\\ln(2)}{\\pi R^{2}} = \\frac{2\\sigma_{f}^{2}\\ln(2)}{R^{2}}$$\n类似地，$s(O) = \\frac{2\\sigma_{o}^{2}\\ln(2)}{R^{2}}$。\n\n现在我们计算 $S$：\n$$S = \\frac{2\\left(\\frac{2\\sigma_{f}^{2}\\ln(2)}{R^{2}} - \\frac{2\\sigma_{o}^{2}\\ln(2)}{R^{2}}\\right)}{\\frac{2\\sigma_{f}^{2}\\ln(2)}{R^{2}} + \\frac{2\\sigma_{o}^{2}\\ln(2)}{R^{2}}}$$\n公共项 $2\\ln(2)/R^{2}$ 从分子和分母中约去：\n$$S = \\frac{2(\\sigma_{f}^{2} - \\sigma_{o}^{2})}{\\sigma_{f}^{2} + \\sigma_{o}^{2}}$$\n代入 $\\sigma_{f}$ 和 $\\sigma_{o}$ 的给定值：\n$\\sigma_{f}^{2} = 30^{2} = 900$。\n$\\sigma_{o}^{2} = 15^{2} = 225$。\n$$S = \\frac{2(900 - 225)}{900 + 225} = \\frac{2(675)}{1125} = \\frac{1350}{1125} = 1.2$$\n保留四位有效数字，$S = 1.200$。\n\n### 总结\n\n计算出的 SAL 三元组分量为：\n- 结构 $S = 1.200$\n- 振幅 $A = 0.8235$\n- 位置 $L = 0.04700$\n\n最终的 SAL 三元组，按 $(S, A, L)$ 顺序排列，为 $(1.200, 0.8235, 0.04700)$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 1.200  0.8235  0.04700 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在理解了SAL的理论组成部分后，下一步是将其应用于来自数值模型的离散网格数据。位置误差可以通过计算预报和观测对象的“质心”之间的距离来量化，这需要将质心的连续概念转化为对网格单元的离散求和。本编程练习将理论与实践相结合，你将学会为网格上的任意形状对象计算质量加权质心，这是任何基于对象的分析中的一项基本技能。",
            "id": "4090762",
            "problem": "给定一个离散的二维网格域，它代表了数值天气预报和气候模拟中使用的大气的一个平面子集。在空间和基于对象的检验中，结构-振幅-位置 (SAL) 度量用于比较一个预报对象和一个观测对象。在本任务中，重点关注位置分量。在先进的基于对象的检验中，该分量由质量加权质心构建，并按域大小进行归一化。您的目标是：从第一性原理出发，推导一种计算一对不重叠对象的无量纲位置度量 $L$ 的方法，将其实现为一个完整的、可运行的程序，并在指定的测试集上进行评估。\n\n从以下基本原理开始：\n- 一个离散对象的质量中心（质量加权质心）由一阶矩与质量之比给出。给定一个在有限离散网格坐标集上的非负强度场 $w(x,y)$，离散质量是所有强度之和。\n- 平面上两点之间的欧几里得距离定义为坐标差平方和的平方根。\n- 为了形成一个无量纲度量，归一化使用了一个特征域尺寸，域中任意两个质心之间的距离都不能超过该尺寸。\n\n在一个使用从零开始的整数坐标的笛卡爾网格中进行操作。设域有 $N_x$ 列（沿 $x$ 轴）和 $N_y$ 行（沿 $y$ 轴），有效的 $x$ 索引为 $x \\in \\{0,1,\\dots,N_x-1\\}$，有效的 $y$ 索引为 $y \\in \\{0,1,\\dots,N_y-1\\}$。对于每个测试用例，指定了两个不重叠的对象，它们是网格单元的子集，在这些单元上具有严格为正的强度，而在其他地方强度为零。强度场代表一个具有物理意义的量（例如累积降水量），在质心计算中必须被视为质量密度。归一化必须使用域内的最大质心间距，该间距定义为坐标 $(0,0)$ 和 $(N_x-1,N_y-1)$ 处两个对角之间的欧几里得距离。最终的位置度量 $L$ 必须以无量纲十进制浮点数的形式返回。\n\n推导并实现以下方法：\n- 从强度场计算每个对象的质量加权质心 $(\\bar{x},\\bar{y})$。\n- 计算两个质心之间的欧几里得距离。\n- 用最大质心间距对此距离进行归一化，以获得 $L$。\n- 将此方法应用于下面的每个测试用例，为每个用例生成一个四舍五入到 $6$ 位小数的浮点数。\n\n测试集包含以下五个用例，每个用例都有域维度和精确的对象规格。在所有用例中，两个对象都是不重叠的；在指定的单元格上强度严格为正，在其他地方为零。\n\n- 用例 $1$：$N_x=21$，$N_y=21$。\n  - 对象 $\\mathcal{A}$：在 $x \\in \\{0,1,2\\}$ 且 $y \\in \\{0,1,2\\}$ 的 $3 \\times 3$ 块上，强度为 $1$。\n  - 对象 $\\mathcal{B}$：在 $x \\in \\{18,19,20\\}$ 且 $y \\in \\{18,19,20\\}$ 的 $3 \\times 3$ 块上，强度为 $1$。\n\n- 用例 $2$：$N_x=21$，$N_y=21$。\n  - 对象 $\\mathcal{A}$：在 $x=5$ 且 $y \\in \\{10,11,12,13,14\\}$ 的垂直线上，强度为 $2$。\n  - 对象 $\\mathcal{B}$：在 $x=6$ 且 $y \\in \\{10,11,12,13,14\\}$ 的垂直线上，强度为 $1$。\n\n- 用例 $3$：$N_x=31$，$N_y=31$。\n  - 对象 $\\mathcal{A}$：在 $x \\in \\{2,3,4\\}$ 且 $y \\in \\{3,4,5\\}$ 的 $3 \\times 3$ 块上，强度为 $1$，并在 $(x=4,y=5)$ 处有一个额外的重单元，其额外强度为 $9$（因此该单元格的总强度为 $10$）。\n  - 对象 $\\mathcal{B}$：在 $x \\in \\{25,26,27\\}$ 且 $y \\in \\{20,21,22\\}$ 的 $3 \\times 3$ 块上，强度为 $1$。\n\n- 用例 $4$：$N_x=50$，$N_y=50$。\n  - 对象 $\\mathcal{A}$：两个不相交的圆形盘，在有限支撑集内具有高斯形状的强度：\n    - 盘 $1$：中心 $(x=10,y=10)$，半径为 $4$，对于与中心欧几里得距离 $r$ 严格小于 $4$ 的网格点，其强度为 $e^{-\\frac{1}{2}\\left(\\frac{r}{2}\\right)^2}$，其他地方强度为 $0$。\n    - 盘 $2$：中心 $(x=17,y=12)$，半径为 $3$，对于与中心欧几里得距离 $r$ 严格小于 $3$ 的网格点，其强度为 $e^{-\\frac{1}{2}\\left(\\frac{r}{1.5}\\right)^2}$，其他地方强度为 $0$。\n  - 对象 $\\mathcal{B}$：一个圆形盘：\n    - 盘 $3$：中心 $(x=42,y=44)$，半径为 $5$，对于与中心欧几里得距离 $r$ 严格小于 $5$ 的网格点，其强度为 $e^{-\\frac{1}{2}\\left(\\frac{r}{2}\\right)^2}$，其他地方强度为 $0$。\n\n- 用例 $5$：$N_x=30$，$N_y=10$。\n  - 对象 $\\mathcal{A}$：在 $x \\in \\{0,1,2\\}$ 且 $y \\in \\{0,1,2\\}$ 的 $3 \\times 3$ 块上，强度为 $3$。\n  - 对象 $\\mathcal{B}$：在 $x \\in \\{27,28,29\\}$ 且 $y \\in \\{7,8,9\\}$ 的 $3 \\times 3$ 块上，强度为 $3$。\n\n要求：\n- 在一个单独的程序中实现计算，该程序使用从零开始的索引在内部构建指定的场，并使用上述方法。\n- 对于每个测试用例，生成位置度量 $L$，作为一个四舍五入到 $6$ 位小数的十进制浮点数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按用例 $1$ 到 $5$ 的顺序排列结果（例如，`\"[0.123456,0.234567,0.345678,0.456789,0.567890]\"`）。输出无单位，必须是无量纲的小数。\n\n您的推导和实现必须严格遵守上述基本原理，不得依赖定义之外的任何快捷公式，并且必须在科学上和数值上都是可靠的。",
            "solution": "问题陈述是有效的。它在科学上根植于力学和几何学原理，问题定义良好，提供了所有必要信息，并且其表述是客观的。我们将继续进行推导和求解。\n\n目标是推导并实现一种方法，用于计算无量纲位置度量 $L$，该度量用于量化二维离散网格上两个对象 $\\mathcal{A}$ 和 $\\mathcal{B}$ 之间的空间位移。此度量是气象学中使用的结构-振幅-位置 (SAL) 检验度量的一个组成部分。\n\n**1. 位置度量 $L$ 的推导**\n\n该方法基于比较两个对象的质量加权质心。推导过程遵循三个步骤：计算每个对象的质心，计算它们之间的距离，以及用域的特征长度对此距离进行归一化。\n\n**1.1. 质量加权质心**\n\n离散网格上的一个对象 $\\mathcal{O}$ 由一组网格单元上的非负强度场 $w(x,y)$ 定义。网格坐标是整数，其中 $x \\in \\{0, 1, \\dots, N_x-1\\}$ 且 $y \\in \\{0, 1, \\dots, N_y-1\\}$。对象的总质量 $M$ 是其强度的总和（一个离散积分）：\n$$\nM = \\sum_{(x,y) \\in \\mathcal{O}} w(x,y)\n$$\n对象的位置由其质量中心（或质量加权质心）$(\\bar{x}, \\bar{y})$ 表示。质心的坐标是强度分布的一阶矩除以总质量。一阶矩 $M_x$ 和 $M_y$ 计算如下：\n$$\nM_x = \\sum_{(x,y) \\in \\mathcal{O}} x \\cdot w(x,y)\n$$\n$$\nM_y = \\sum_{(x,y) \\in \\mathcal{O}} y \\cdot w(x,y)\n$$\n质心坐标则由下式给出：\n$$\n\\bar{x} = \\frac{M_x}{M} = \\frac{\\sum x \\cdot w(x,y)}{\\sum w(x,y)}\n$$\n$$\n\\bar{y} = \\frac{M_y}{M} = \\frac{\\sum y \\cdot w(x,y)}{\\sum w(x,y)}\n$$\n其中求和遍及属于该对象的所有网格点 $(x,y)$。\n\n**1.2. 质心之间的距离**\n\n给定两个感兴趣的对象 $\\mathcal{A}$ 和 $\\mathcal{B}$，我们首先应用上述公式计算它们各自的质心 $(\\bar{x}_{\\mathcal{A}}, \\bar{y}_{\\mathcal{A}})$ 和 $(\\bar{x}_{\\mathcal{B}}, \\bar{y}_{\\mathcal{B}})$。然后，使用平面上的标准欧几里得距离公式计算两个对象质量中心之间的物理间隔。设此距离为 $d$：\n$$\nd = \\sqrt{(\\bar{x}_{\\mathcal{A}} - \\bar{x}_{\\mathcal{B}})^2 + (\\bar{y}_{\\mathcal{A}} - \\bar{y}_{\\mathcal{B}})^2}\n$$\n\n**1.3. 归一化与位置度量 $L$**\n\n为了获得一个与域大小无关的无量纲度量，距离 $d$ 需要通过一个特征长度尺度进行归一化。问题指定该尺度为域中任意两个质心之间可能的最大距离。对于矩形域，这个最大间隔 $d_{\\text{max}}$ 是连接角落 $(0,0)$ 和 $(N_x-1, N_y-1)$ 的主对角线的长度：\n$$\nd_{\\text{max}} = \\sqrt{((N_x-1) - 0)^2 + ((N_y-1) - 0)^2} = \\sqrt{(N_x-1)^2 + (N_y-1)^2}\n$$\n最终的无量纲位置度量 $L$ 是质心间隔距离与此最大可能距离之比：\n$$\nL = \\frac{d}{d_{\\text{max}}}\n$$\n$L$ 的值通常在 $[0, 1]$ 范围内，其中 $L=0$ 表示对象的质心相同，而接近 $1$ 的值表示对象的间隔距离与整个域的大小相当。\n\n**2. 算法实现**\n\n推导出的方法被实现为一个数值算法，用于处理给定的测试用例。每个用例的流程如下：\n\n1.  **网格与场构建**：对于一个大小为 $N_x \\times N_y$ 的域，初始化两个用零填充的 $N_y \\times N_x$ 数组，用于存储强度场 $w_{\\mathcal{A}}(x,y)$ 和 $w_{\\mathcal{B}}(x,y)$。然后根据每个测试用例中对象的定义填充这些数组。\n2.  **质心计算**：实现一个可重用的函数，用于从对象的强度场数组计算其质心。该函数通过在网格上执行加权求和来计算总质量 $M$ 以及一阶矩 $M_x$ 和 $M_y$，然后返回质心坐标 $(\\bar{x}, \\bar{y})$。\n3.  **位置度量计算**：对对象场 $w_{\\mathcal{A}}$ 和 $w_{\\mathcal{B}}$ 调用质心函数。使用得到的质心计算距离 $d$。根据域维度 $N_x$ 和 $N_y$ 计算最大距离 $d_{\\text{max}}$。最后，计算它们的比值得到位置度量 $L$。\n4.  **格式化**：将每个测试用例计算出的 $L$ 值格式化为具有精确 $6$ 位小数的浮点数。所有用例的结果汇总到一个逗号分隔的列表中。",
            "answer": "```python\nimport numpy as np\n\ndef _calculate_centroid(intensity_field, xx, yy):\n    \"\"\"Computes the mass-weighted centroid of an object on a grid.\"\"\"\n    mass = np.sum(intensity_field)\n    if mass == 0:\n        # Should not happen based on problem description but included for robustness\n        return 0.0, 0.0\n\n    # Calculate first moments\n    moment_x = np.sum(xx * intensity_field)\n    moment_y = np.sum(yy * intensity_field)\n    \n    # Calculate centroid coordinates\n    centroid_x = moment_x / mass\n    centroid_y = moment_y / mass\n    \n    return centroid_x, centroid_y\n\ndef _get_case_fields():\n    \"\"\"A generator function that yields the parameters for each test case.\"\"\"\n    \n    # Case 1\n    Nx, Ny = 21, 21\n    w_A = np.zeros((Ny, Nx), dtype=float)\n    w_B = np.zeros((Ny, Nx), dtype=float)\n    w_A[0:3, 0:3] = 1.0  # y in {0,1,2}, x in {0,1,2}\n    w_B[18:21, 18:21] = 1.0 # y in {18,19,20}, x in {18,19,20}\n    yield Nx, Ny, w_A, w_B\n\n    # Case 2\n    Nx, Ny = 21, 21\n    w_A = np.zeros((Ny, Nx), dtype=float)\n    w_B = np.zeros((Ny, Nx), dtype=float)\n    w_A[10:15, 5] = 2.0  # y in {10..14}, x = 5\n    w_B[10:15, 6] = 1.0  # y in {10..14}, x = 6\n    yield Nx, Ny, w_A, w_B\n\n    # Case 3\n    Nx, Ny = 31, 31\n    w_A = np.zeros((Ny, Nx), dtype=float)\n    w_B = np.zeros((Ny, Nx), dtype=float)\n    w_A[3:6, 2:5] = 1.0  # y in {3,4,5}, x in {2,3,4}\n    w_A[5, 4] += 9.0  # Extra intensity 9 at (x=4, y=5)\n    w_B[20:23, 25:28] = 1.0 # y in {20,21,22}, x in {25,26,27}\n    yield Nx, Ny, w_A, w_B\n    \n    # Case 4\n    Nx, Ny = 50, 50\n    x_coords = np.arange(Nx)\n    y_coords = np.arange(Ny)\n    xx, yy = np.meshgrid(x_coords, y_coords)\n    \n    # Object A: two disjoint discs\n    w_A = np.zeros((Ny, Nx), dtype=float)\n    # Disc 1: center (10,10), r=4\n    r1 = np.sqrt((xx - 10)**2 + (yy - 10)**2)\n    mask1 = r1  4\n    w_A[mask1] += np.exp(-0.5 * (r1[mask1] / 2.0)**2)\n    # Disc 2: center (17,12), r=3\n    r2 = np.sqrt((xx - 17)**2 + (yy - 12)**2)\n    mask2 = r2  3\n    w_A[mask2] += np.exp(-0.5 * (r2[mask2] / 1.5)**2)\n    \n    # Object B: one disc\n    w_B = np.zeros((Ny, Nx), dtype=float)\n    # Disc 3: center (42,44), r=5\n    r3 = np.sqrt((xx - 42)**2 + (yy - 44)**2)\n    mask3 = r3  5\n    w_B[mask3] = np.exp(-0.5 * (r3[mask3] / 2.0)**2)\n    yield Nx, Ny, w_A, w_B\n\n    # Case 5\n    Nx, Ny = 30, 10\n    w_A = np.zeros((Ny, Nx), dtype=float)\n    w_B = np.zeros((Ny, Nx), dtype=float)\n    w_A[0:3, 0:3] = 3.0\n    w_B[7:10, 27:30] = 3.0\n    yield Nx, Ny, w_A, w_B\n\n\ndef solve():\n    \"\"\"\n    Main function to compute the location measure L for all test cases.\n    \"\"\"\n    results = []\n    case_generator = _get_case_fields()\n\n    for i in range(5): # There are 5 test cases\n        Nx, Ny, w_A, w_B = next(case_generator)\n\n        # In Case 4, xx and yy are already computed. For others, they are not.\n        # It's cleaner to compute them for each case inside the loop.\n        x_coords = np.arange(Nx)\n        y_coords = np.arange(Ny)\n        xx, yy = np.meshgrid(x_coords, y_coords)\n        \n        # Calculate centroids\n        cx_A, cy_A = _calculate_centroid(w_A, xx, yy)\n        cx_B, cy_B = _calculate_centroid(w_B, xx, yy)\n        \n        # Calculate distance between centroids\n        d = np.sqrt((cx_A - cx_B)**2 + (cy_A - cy_B)**2)\n        \n        # Calculate maximum possible distance in the domain\n        if Nx > 1 or Ny > 1:\n            d_max = np.sqrt((Nx - 1)**2 + (Ny - 1)**2)\n        else:\n            d_max = 0.0\n\n        # Calculate dimensionless location measure L\n        L = d / d_max if d_max > 0 else 0.0\n        \n        # Format the result to 6 decimal places\n        results.append(f\"{L:.6f}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个完整的基于对象的检验系统不仅涉及计算单个指标，还需要一个从识别对象到匹配对象并评估结果的完整流程。这个练习综合了几个关键阶段：（1）使用阈值和连通性分析从原始场中识别出不同的对象；（2）用一套属性（如面积、偏心率）来表征每个对象；（3）使用成本函数和优化算法来寻找预报和观测对象之间最合理的配对。通过构建这个迷你检验系统，你将获得对OBV过程的整体认识，并巩固你在图像处理、特征提取和优化方面的技能，从而理解这些组件如何协同工作，以提供细致而全面的预报评估。",
            "id": "4090773",
            "problem": "给定一个用于评估数值天气预报 (NWP) 和气候建模中空间和基于对象的检验的综合设置。具体来说，您将计算二维网格场中经过二值化阈值处理的连通对象的属性，然后使用严格定义的代价函数和线性总和分配 (LSA) 准则，在预报对象和观测对象之间执行最优匹配。\n\n基本基础：\n- 基于对象的检验 (OBV) 对从网格强度定义的阈值化二值场进行操作，并根据指定的邻域规则将场划分为连通分量。每个对象的面积、形状描述符和强度统计等属性都会被计算。\n- 对于一个二维 (2D) 网格场，对象边界由一个阈值 $T$ 应用于由行 $r$ 和列 $c$ 索引的离散网格上的强度 $I_{r,c}$ 而产生。\n- 连通性通过 $8$-连通性定义：如果两个网格单元的行索引最多相差 $1$ 且列索引最多相差 $1$，则它们是邻居，这包括对角相邻。\n\n待使用的定义：\n- 阈值处理：对于每个具有强度 $I_{r,c}$ 的网格单元 $(r,c)$，如果 $I_{r,c} \\ge T$，则定义一个二值掩码 $M_{r,c} = 1$，否则 $M_{r,c} = 0$。\n- 连通对象：在 $8$-连通性下，所有 $M_{r,c} = 1$ 的单元格构成的最大连通集合。\n- 面积：对象的面积是其网格单元的数量。将面积表示为网格单元的整数计数。\n- 最大强度：对象中所有单元格的 $I_{r,c}$ 的最大值。将其表示为实数。\n- 偏心率：对于一个在坐标 $(x_i,y_i)$ 处有 $n$ 个单元格的对象，其中 $x_i$ 是列索引，$y_i$ 是行索引，计算质心 $(\\bar{x},\\bar{y})$：\n$$\n\\bar{x} = \\frac{1}{n}\\sum_{i=1}^{n} x_i, \\quad \\bar{y} = \\frac{1}{n}\\sum_{i=1}^{n} y_i.\n$$\n定义二阶中心矩（协方差）矩阵\n$$\n\\mathbf{C} = \\begin{pmatrix}\n\\frac{1}{n}\\sum_{i=1}^{n}(x_i-\\bar{x})^2  \\frac{1}{n}\\sum_{i=1}^{n}(x_i-\\bar{x})(y_i-\\bar{y})\\\\\n\\frac{1}{n}\\sum_{i=1}^{n}(x_i-\\bar{x})(y_i-\\bar{y})  \\frac{1}{n}\\sum_{i=1}^{n}(y_i-\\bar{y})^2\n\\end{pmatrix}.\n$$\n设 $\\lambda_{\\max}$ 和 $\\lambda_{\\min}$ 是 $\\mathbf{C}$ 的特征值，且 $\\lambda_{\\max} \\ge \\lambda_{\\min} \\ge 0$。定义对象偏心率\n$$\ne = \\sqrt{1 - \\frac{\\lambda_{\\min}}{\\lambda_{\\max}}}\n$$\n当 $\\lambda_{\\max} > 0$ 时，如果 $\\lambda_{\\max} = 0$ 则设 $e = 0$。将偏心率表示为 $[0,1]$ 区间内的实数。\n\n成对属性差异归一化：\n- 设预报对象属性为 $(A_f, e_f, M_f)$，观测对象属性为 $(A_o, e_o, M_o)$。定义归一化属性差异\n$$\nd_A = \\frac{|A_f - A_o|}{\\max(A_f, A_o)}, \\quad d_E = |e_f - e_o|, \\quad d_M = \\frac{|M_f - M_o|}{\\max(M_f, M_o)}.\n$$\n所有差异都是无量纲的，且界于 $[0,1]$。\n\n匹配代价函数：\n- 给定权重 $(w_A, w_E, w_M)$，定义成对代价\n$$\nc = w_A d_A + w_E d_E + w_M d_M.\n$$\n- 对于一个有 $N_f$ 个预报对象和 $N_o$ 个观测对象的矩形预报-观测配对，最优分配旨在最小化一个大小为 $\\min(N_f, N_o)$ 的一对一匹配中所选配对的代价总和，再加上对每个未匹配的预报对象施加的惩罚 $p_u$：\n$$\nJ = \\sum_{(i,j)\\in \\mathcal{M}} c_{ij} + p_u \\cdot (N_f - |\\mathcal{M}|),\n$$\n其中 $\\mathcal{M}$ 是已匹配索引对的集合，且 $|\\mathcal{M}| = \\min(N_f, N_o)$。\n\n数据规格：\n- 网格维度为 $8 \\times 8$；索引 $r$ 和 $c$ 的范围是从 $0$ 到 $7$。\n- 预报场强度 $I^{(f)}_{r,c}$：所有未指定的单元格强度均为 $0$。非零强度位于以下坐标，每对以 $((r,c), I)$ 的形式列出：\n    - $((1,1), 2.0)$, $((1,2), 1.6)$, $((2,1), 1.4)$, $((2,2), 1.2)$,\n    - $((3,4), 1.1)$, $((3,5), 1.4)$, $((3,6), 1.6)$, $((4,4), 1.0)$, $((4,5), 1.2)$, $((4,6), 1.3)$,\n    - $((5,1), 0.95)$, $((5,2), 1.0)$, $((6,1), 1.2)$, $((6,2), 1.3)$, $((7,1), 2.2)$, $((7,2), 2.0)$。\n- 观测场强度 $I^{(o)}_{r,c}$：所有未指定的单元格强度均为 $0$。非零强度位于以下坐标：\n    - $((3,2), 1.0)$, $((3,3), 1.3)$, $((3,4), 1.5)$, $((4,2), 0.95)$, $((4,3), 1.1)$, $((4,4), 1.2)$,\n    - $((4,6), 1.1)$, $((4,7), 1.2)$, $((5,6), 1.4)$, $((5,7), 1.6)$, $((6,6), 1.7)$, $((6,7), 1.8)$。\n- 对于所有测试用例，阈值固定为 $T = 1.0$。\n\n连通性规则：\n- 使用 $8$-连通性来识别阈值化二值掩码中的连通分量。\n\n测试套件：\n对于每种情况，计算预报和观测对象，推导出每个对象的 $(A,e,M)$，使用给定的权重形成成对代价矩阵，解决最优分配问题，并计算包括未匹配惩罚在内的总目标值 $J$。以浮点数形式返回四舍五入到 $4$ 位小数的 $J$。\n- 情况 1：$(w_A, w_E, w_M) = (1.0, 1.0, 1.0)$，$p_u = 0.25$。\n- 情况 2：$(w_A, w_E, w_M) = (0.5, 2.0, 1.0)$，$p_u = 0.25$。\n- 情况 3：$(w_A, w_E, w_M) = (1.5, 0.0, 1.0)$，$p_u = 0.40$。\n- 情况 4：$(w_A, w_E, w_M) = (0.2, 1.0, 3.0)$，$p_u = 0.10$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含案例 $1$ 到 $4$ 的结果，格式为方括号括起来的逗号分隔列表，每个浮点数四舍五入到 $4$ 位小数（例如，$[j_1,j_2,j_3,j_4]$）。",
            "solution": "该问题被评估为有效。它在科学上基于数值天气预报检验的原理，算法上定义明确，内部一致，并包含所有必要信息以获得唯一解。\n\n该解决方案通过以下四个主要步骤进行：\n1.  对象识别：根据给定的强度阈值，在预报场和观测场中分离出连通对象。\n2.  属性计算：为每个已识别的对象计算指定的属性（面积、最大强度、偏心率）。\n3.  代价矩阵构建：对于每个测试用例，使用特定用例的权重计算每个预报对象与每个观测对象之间的成对代价。\n4.  最优分配与总代价：解决线性总和分配问题以找到最优匹配，并计算包括未匹配预报对象惩罚在内的总目标函数 $J$。\n\n所有数学实体均按要求使用 LaTeX 排版。\n\n**第 1 步：对象识别**\n\n首先，填充 $8 \\times 8$ 的预报 ($I^{(f)}$) 和观测 ($I^{(o)}$) 强度网格。然后，通过识别强度 $I_{r,c}$ 大于或等于阈值 $T=1.0$ 的单元格，为每个网格生成一个二值掩码。\n\n$M_{r,c} = 1 \\text{ if } I_{r,c} \\ge T, \\text{ and } M_{r,c} = 0 \\text{ otherwise.}$\n\n使用 $8$-连通性连通分量标记算法（例如，对二值掩码进行广度优先搜索），识别出对象。\n\n对于**预报场**，以下单元格高于阈值：\n- $\\{(1,1), (1,2), (2,1), (2,2)\\}$\n- $\\{(3,4), (3,5), (3,6), (4,4), (4,5), (4,6)\\}$\n- $\\{(5,2), (6,1), (6,2), (7,1), (7,2)\\}$\n\n此过程产生 $N_f = 3$ 个不同的预报对象：\n- $F_1$：位于左上角的一个 $2 \\times 2$ 的单元格块。\n- $F_2$：位于网格中部的一个包含 $6$ 个单元格的集合。\n- $F_3$：位于左下角的一个包含 $5$ 个单元格的群组。\n\n对于**观测场**，以下单元格高于阈值：\n- $\\{(3,2), (3,3), (3,4), (4,3), (4,4)\\}$\n- $\\{(4,6), (4,7), (5,6), (5,7), (6,6), (6,7)\\}$\n\n此过程产生 $N_o = 2$ 个不同的观测对象：\n- $O_1$：一个包含 $5$ 个单元格的群组。\n- $O_2$：一个 $3 \\times 2$ 的包含 $6$ 个单元格的块。\n\n**第 2 步：属性计算**\n\n对于 $N_f=3$ 个预报对象和 $N_o=2$ 个观测对象中的每一个，我们计算一组三个属性：面积 ($A$)、最大强度 ($M$) 和偏心率 ($e$)。坐标 $(x,y)$ 定义为 (列索引, 行索引)。\n\n**预报对象 $F_2$ 的计算示例：**\n- **单元格**：$\\{(3,4), (3,5), (3,6), (4,4), (4,5), (4,6)\\}$\n- **面积 ($A_{F2}$)**：该对象由 $n=6$ 个单元格组成，所以 $A_{F2} = 6$。\n- **最大强度 ($M_{F2}$)**：强度为 $\\{1.1, 1.4, 1.6, 1.0, 1.2, 1.3\\}$。最大值为 $M_{F2} = 1.6$。\n- **偏心率 ($e_{F2}$)**：\n    - 坐标 $(x_i, y_i)$：$\\{(4,3), (5,3), (6,3), (4,4), (5,4), (6,4)\\}$。\n    - 质心：$(\\bar{x}, \\bar{y}) = (\\frac{1}{6}\\sum x_i, \\frac{1}{6}\\sum y_i) = (5.0, 3.5)$。\n    - 协方差矩阵 $\\mathbf{C}$：\n    $$ \\mathbf{C} = \\begin{pmatrix} \\frac{1}{n}\\sum(x_i-\\bar{x})^2  \\frac{1}{n}\\sum(x_i-\\bar{x})(y_i-\\bar{y})\\\\ \\frac{1}{n}\\sum(x_i-\\bar{x})(y_i-\\bar{y})  \\frac{1}{n}\\sum(y_i-\\bar{y})^2 \\end{pmatrix} = \\begin{pmatrix} 0.666...  0.0 \\\\ 0.0  0.25 \\end{pmatrix} $$\n    - 特征值：此对角矩阵的特征值为 $\\lambda_{\\max} = 2/3$ 和 $\\lambda_{\\min} = 0.25$。\n    - 偏心率：$e_{F2} = \\sqrt{1 - \\frac{\\lambda_{\\min}}{\\lambda_{\\max}}} = \\sqrt{1 - \\frac{0.25}{2/3}} = \\sqrt{1 - 0.375} = \\sqrt{0.625} \\approx 0.79057$。\n    \n对所有对象执行此过程，得到以下属性：\n\n| 对象 | 面积 ($A$) | 最大强度 ($M$) | 偏心率 ($e$) |\n|:------:|:----------:|:-------------------:|:------------------:|\n| $F_1$  |     $4$    |        $2.0$        |     $0.0$          |\n| $F_2$  |     $6$    |        $1.6$        |  $\\approx 0.79057$ |\n| $F_3$  |     $5$    |        $2.2$        |  $\\approx 0.81650$ |\n| $O_1$  |     $5$    |        $1.5$        |  $\\approx 0.81650$ |\n| $O_2$  |     $6$    |        $1.8$        |  $\\approx 0.79057$ |\n\n**第 3 步：代价矩阵和最优匹配**\n\n对于每个测试用例，我们构建一个 $3 \\times 2$ 的代价矩阵，其中条目 $c_{ij}$ 是将预报对象 $F_i$ 与观测对象 $O_j$ 匹配的代价。代价为 $c_{ij} = w_A d_A + w_E d_E + w_M d_M$。\n\n**情况 1 示例**：$(w_A, w_E, w_M) = (1.0, 1.0, 1.0)$。\n让我们计算将 $F_2$ 与 $O_2$ 匹配的代价 $c_{22}$。\n- 属性：$F_2(A=6, M=1.6, e\\approx0.79057)$ 和 $O_2(A=6, M=1.8, e\\approx0.79057)$。\n- $d_A = \\frac{|6-6|}{\\max(6,6)} = 0$。\n- $d_E = |0.79057 - 0.79057| = 0$。\n- $d_M = \\frac{|1.6-1.8|}{\\max(1.6, 1.8)} = \\frac{0.2}{1.8} \\approx 0.11111$。\n- $c_{22} = 1.0 \\cdot (0) + 1.0 \\cdot (0) + 1.0 \\cdot (0.11111) = 0.11111$。\n\n填充情况 1 的整个代价矩阵：\n$$ \\mathbf{C}_{\\text{cost}} = \\begin{pmatrix}\n1.2665  1.2239 \\\\\n0.2551  0.1111 \\\\\n0.3182  0.3744\n\\end{pmatrix} $$\n我们对此矩阵应用线性总和分配算法。由于 $N_f > N_o$，算法会为 $N_o=2$ 个观测对象找到最佳匹配。对于情况 1，最优分配是匹配 $(F_2, O_2)$ 和 $(F_3, O_1)$，使 $F_1$ 未匹配。\n\n**第 4 步：总目标计算**\n\n总目标函数为 $J = \\sum_{(i,j)\\in \\mathcal{M}} c_{ij} + p_u \\cdot (N_f - |\\mathcal{M}|)$，其中 $\\mathcal{M}$ 是最优代价对的集合。\n\n**情况 1 示例**：\n- 权重：$(w_A, w_E, w_M) = (1.0, 1.0, 1.0)$。\n- 惩罚：$p_u = 0.25$。\n- 最优配对：$(F_2, O_2)$ 的代价为 $c_{22} \\approx 0.1111$，$(F_3, O_1)$ 的代价为 $c_{31} \\approx 0.3182$。\n- 匹配代价总和：$0.11111 + 0.31818 \\approx 0.4293$。\n- 未匹配的预报对象数：$N_f - |\\mathcal{M}| = 3 - 2 = 1$。\n- 惩罚代价：$p_u \\cdot 1 = 0.25$。\n- 总目标值：$J_1 = 0.4293 + 0.25 = 0.6793$。\n\n对四个测试用例重复整个过程，每个用例使用不同的权重和惩罚，以产生最终的结果向量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef solve():\n    \"\"\"\n    Computes an object-based verification metric for synthetic forecast and observation fields.\n    \n    The process involves:\n    1. Identifying connected objects in both fields via thresholding.\n    2. Calculating area, max intensity, and eccentricity for each object.\n    3. For each test case, building a pairwise cost matrix based on attribute differences.\n    4. Solving the linear sum assignment problem to find the optimal matching.\n    5. Calculating the total objective J, including a penalty for unmatched forecast objects.\n    \"\"\"\n\n    # --- Data Specification ---\n    GRID_DIM = 8\n    THRESHOLD = 1.0\n    \n    forecast_intensities_spec = {\n        ((1, 1), 2.0), ((1, 2), 1.6), ((2, 1), 1.4), ((2, 2), 1.2),\n        ((3, 4), 1.1), ((3, 5), 1.4), ((3, 6), 1.6), ((4, 4), 1.0), ((4, 5), 1.2), ((4, 6), 1.3),\n        ((5, 1), 0.95), ((5, 2), 1.0), ((6, 1), 1.2), ((6, 2), 1.3), ((7, 1), 2.2), ((7, 2), 2.0)\n    }\n    \n    observed_intensities_spec = {\n        ((3, 2), 1.0), ((3, 3), 1.3), ((3, 4), 1.5), ((4, 2), 0.95), ((4, 3), 1.1), ((4, 4), 1.2),\n        ((4, 6), 1.1), ((4, 7), 1.2), ((5, 6), 1.4), ((5, 7), 1.6), ((6, 6), 1.7), ((6, 7), 1.8)\n    }\n\n    # --- Test Suite ---\n    test_cases = [\n        # (w_A, w_E, w_M), p_u\n        ((1.0, 1.0, 1.0), 0.25),\n        ((0.5, 2.0, 1.0), 0.25),\n        ((1.5, 0.0, 1.0), 0.40),\n        ((0.2, 1.0, 3.0), 0.10),\n    ]\n\n    def create_grid(spec, dim):\n        grid = np.zeros((dim, dim), dtype=float)\n        for (r, c), intensity in spec:\n            grid[r, c] = intensity\n        return grid\n\n    def find_objects(intensity_grid, threshold):\n        mask = intensity_grid >= threshold\n        labels = np.zeros_like(mask, dtype=int)\n        current_label = 0\n        rows, cols = mask.shape\n        \n        for r in range(rows):\n            for c in range(cols):\n                if mask[r, c] and labels[r, c] == 0:\n                    current_label += 1\n                    q = [(r, c)]\n                    labels[r, c] = current_label\n                    head = 0\n                    while head  len(q):\n                        row, col = q[head]\n                        head += 1\n                        \n                        for dr in [-1, 0, 1]:\n                            for dc in [-1, 0, 1]:\n                                if dr == 0 and dc == 0:\n                                    continue\n                                nr, nc = row + dr, col + dc\n                                \n                                if 0 = nr  rows and 0 = nc  cols and \\\n                                   mask[nr, nc] and labels[nr, nc] == 0:\n                                    labels[nr, nc] = current_label\n                                    q.append((nr, nc))\n                                    \n        return labels, current_label\n\n    def calculate_attributes(labeled_grid, intensity_grid, num_objects):\n        attributes = []\n        for label in range(1, num_objects + 1):\n            # Coordinates are (row, col)\n            coords_r, coords_c = np.where(labeled_grid == label)\n            \n            # Area\n            area = len(coords_r)\n            \n            # Max Intensity\n            max_intensity = np.max(intensity_grid[coords_r, coords_c])\n            \n            # Eccentricity\n            if area = 1:\n                eccentricity = 0.0\n            else:\n                # Per problem spec, x is col, y is row\n                x_coords = coords_c.astype(float)\n                y_coords = coords_r.astype(float)\n                \n                # Covariance matrix with 1/n normalization (bias=True)\n                # np.cov expects variables as rows, observations as columns\n                cov_matrix = np.cov(np.vstack((x_coords, y_coords)), bias=True)\n\n                if cov_matrix.ndim  2:\n                    # Occurs if e.g. all x or all y are identical\n                    lambda_max = cov_matrix.item()\n                    lambda_min = 0.0\n                else: \n                    eigenvalues = np.linalg.eigvalsh(cov_matrix)\n                    lambda_min, lambda_max = eigenvalues[0], eigenvalues[1]\n\n                if lambda_max > 0:\n                    # Clip argument to sqrt to avoid small negative values from float precision\n                    eccentricity = np.sqrt(max(0, 1 - lambda_min / lambda_max))\n                else:\n                    eccentricity = 0.0\n\n            attributes.append({'A': area, 'e': eccentricity, 'M': max_intensity})\n        return attributes\n\n    # --- Step 1  2: Identify objects and calculate base attributes (once) ---\n    I_f = create_grid(forecast_intensities_spec, GRID_DIM)\n    I_o = create_grid(observed_intensities_spec, GRID_DIM)\n\n    labels_f, n_f = find_objects(I_f, THRESHOLD)\n    labels_o, n_o = find_objects(I_o, THRESHOLD)\n\n    attrs_f = calculate_attributes(labels_f, I_f, n_f)\n    attrs_o = calculate_attributes(labels_o, I_o, n_o)\n\n    results = []\n    # --- Loop through test cases ---\n    for (w_A, w_E, w_M), p_u in test_cases:\n        \n        # --- Step 3: Cost Matrix Construction ---\n        cost_matrix = np.zeros((n_f, n_o))\n        for i in range(n_f):\n            for j in range(n_o):\n                f_obj = attrs_f[i]\n                o_obj = attrs_o[j]\n                \n                d_A = abs(f_obj['A'] - o_obj['A']) / max(f_obj['A'], o_obj['A'])\n                d_E = abs(f_obj['e'] - o_obj['e'])\n                d_M = abs(f_obj['M'] - o_obj['M']) / max(f_obj['M'], o_obj['M'])\n                \n                cost = w_A * d_A + w_E * d_E + w_M * d_M\n                cost_matrix[i, j] = cost\n\n        # --- Step 4: Optimal Assignment and Total Cost ---\n        row_ind, col_ind = linear_sum_assignment(cost_matrix)\n        \n        matched_cost_sum = cost_matrix[row_ind, col_ind].sum()\n        \n        num_matched = len(row_ind)\n        num_unmatched_f = n_f - num_matched\n        \n        unmatched_penalty = p_u * num_unmatched_f\n        \n        total_objective_J = matched_cost_sum + unmatched_penalty\n        results.append(round(total_objective_J, 4))\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}