{
    "hands_on_practices": [
        {
            "introduction": "在深入研究奇异向量等高级集合预报生成技术之前，我们必须确保其基础——切线性模型（TLM）——是准确无误的。TLM 描述了微小扰动如何沿非线性模式的轨迹线性演化，其正确性是计算精确奇异向量的前提。本实践练习将指导您完成一个核心验证任务：通过将非线性模式中有限扰动的实际演化与 TLM 的预测进行比较，来验证您编写的 Lorenz 96 模式的切线性模型的正确性 。这是一个在数值天气预报开发中验证模型代码的标准步骤。",
            "id": "4018800",
            "problem": "考虑受迫洛伦兹96（Lorenz 96）系统，这是一个在数值天气预报和气候建模中使用的标准概念模型，其为维度 $K \\in \\mathbb{N}$ 定义的常微分方程组为\n$$\n\\frac{d x_i}{d t} = \\left(x_{i+1} - x_{i-2}\\right) x_{i-1} - x_i + F, \\quad i = 1, \\dots, K,\n$$\n使用循环索引，使得 $x_{0} \\equiv x_{K}$，$x_{-1} \\equiv x_{K-1}$，$x_{K+1} \\equiv x_{1}$，以此类推。这里 $F \\in \\mathbb{R}$ 是一个常数强迫项。在状态 $\\mathbf{x} \\in \\mathbb{R}^K$ 处评估的向量场的相应雅可比矩阵是一个 $K \\times K$ 的矩阵 $\\mathbf{J}(\\mathbf{x})$，其元素由下式给出\n$$\n\\frac{\\partial}{\\partial x_j}\\left[\\left(x_{i+1} - x_{i-2}\\right) x_{i-1} - x_i + F\\right] = \n\\begin{cases}\nx_{i+1} - x_{i-2},  j = i-1, \\\\\nx_{i-1},  j = i+1, \\\\\n- x_{i-1},  j = i-2, \\\\\n-1,  j = i, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n使用循环索引。\n\n定义非线性流映射 $\\mathcal{M}_T : \\mathbb{R}^K \\to \\mathbb{R}^K$ 作为从初始条件 $\\mathbf{x}_0$ 到通过对洛伦兹96系统进行数值积分而在时间 $T > 0$ 获得的状态的映射。定义切线性模型 (TLM) 为一个线性时变系统\n$$\n\\frac{d \\mathbf{z}}{d t} = \\mathbf{J}(\\mathbf{x}(t)) \\, \\mathbf{z},\n$$\n其中 $\\mathbf{x}(t)$ 是从 $\\mathbf{x}_0$ 开始的非线性轨迹，$\\mathbf{z}(t)$ 从初始扰动 $\\mathbf{z}(0) = \\mathbf{p}_0$ 演变而来。在时间 $T$ 的 TLM 解记为 $\\mathbf{z}(T)$，它近似于沿非线性轨迹的微小扰动的演化。\n\n您必须构建一个数值测试来验证编码的 TLM，方法是在振幅缩放下比较非线性扰动差异与 TLM 预测。具体来说，对于一组给定的振幅 $\\alpha \\in \\mathcal{A}$，将在时间 $T$ 的非线性扰动差异定义为\n$$\n\\delta_{\\text{nl}}(\\alpha) = \\mathcal{M}_T\\big(\\mathbf{x}_0 + \\alpha \\mathbf{p}_0\\big) - \\mathcal{M}_T(\\mathbf{x}_0).\n$$\n对于振幅 $\\alpha$ 的 TLM 预测是\n$$\n\\delta_{\\text{tl}}(\\alpha) = \\alpha \\, \\mathbf{z}(T),\n$$\n其中 $\\mathbf{z}(T)$ 是通过沿基准轨迹 $\\mathbf{x}(t)$ 从 $\\mathbf{z}(0) = \\mathbf{p}_0$ 开始积分 TLM 计算得出的。\n\n您的程序必须：\n- 实现洛伦兹96模型及其雅可比矩阵。\n- 使用固定时间步长 $\\Delta t$ 的四阶龙格－库塔方法对非线性系统和 TLM 进行积分。\n- 对于每个测试用例，使用固定的随机种子生成基准状态 $\\mathbf{x}_0$ 和初始扰动方向 $\\mathbf{p}_0$，将 $\\mathbf{p}_0$ 归一化以满足 $\\lVert \\mathbf{p}_0 \\rVert_2 = 1$，沿基准轨迹计算 $\\mathbf{z}(T)$，然后计算所有 $\\alpha \\in \\mathcal{A}$ 的非线性差异 $\\delta_{\\text{nl}}(\\alpha)$。\n- 对于每个测试用例，计算整个振幅集合中的最大相对差异\n$$\nE_{\\max} = \\max_{\\alpha \\in \\mathcal{A}} \\frac{\\left\\lVert \\delta_{\\text{nl}}(\\alpha) - \\delta_{\\text{tl}}(\\alpha) \\right\\rVert_2}{\\left\\lVert \\delta_{\\text{tl}}(\\alpha) \\right\\rVert_2}.\n$$\n\n所有变量都是无量纲的；不涉及物理单位。\n\n测试套件和参数：\n- 用例1（正常路径）：$K = 10$, $F = 8$, $T = 1.0$, $\\Delta t = 0.01$, $\\mathcal{A} = \\{10^{-6}, 5 \\cdot 10^{-6}, 10^{-5}\\}$, 随机种子 $0$。\n- 用例2（更长的时间窗口）：$K = 10$, $F = 8$, $T = 5.0$, $\\Delta t = 0.01$, $\\mathcal{A} = \\{10^{-6}, 5 \\cdot 10^{-6}, 10^{-5}\\}$, 随机种子 $1$。\n- 用例3（大振幅，崩溃检查）：$K = 10$, $F = 8$, $T = 1.0$, $\\Delta t = 0.01$, $\\mathcal{A} = \\{10^{-3}, 5 \\cdot 10^{-3}, 10^{-2}\\}$, 随机种子 $2$。\n- 用例4（边缘情况：小维度和微小振幅）：$K = 5$, $F = 8$, $T = 1.0$, $\\Delta t = 0.01$, $\\mathcal{A} = \\{10^{-8}, 5 \\cdot 10^{-8}, 10^{-7}\\}$, 随机种子 $3$。\n\n基准和扰动生成：\n- 对于每个测试用例，通过采样独立标准正态分量来抽取 $\\mathbf{x}_0$，并设置 $\\mathbf{x}_0 = F \\cdot \\mathbf{1} + 0.01 \\, \\boldsymbol{\\eta}$，其中 $\\boldsymbol{\\eta}$ 是标准正态向量，$\\mathbf{1}$ 是全一向量。\n- 将 $\\mathbf{p}_0$ 抽取为独立的标准正态向量，然后归一化为单位欧几里得范数。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，每个测试用例一个条目，按上面列出的顺序排列。每个条目必须是该用例的 $E_{\\max}$ 的浮点值。例如，输出格式必须是\n$$\n[\\text{E}_{\\max}^{(1)},\\text{E}_{\\max}^{(2)},\\text{E}_{\\max}^{(3)},\\text{E}_{\\max}^{(4)}].\n$$",
            "solution": "用户提供了一个问题，要求为洛伦兹96（Lorenz 96）动力系统实现并验证切线性模型（TLM）。\n\n### 第1步：问题验证\n\n首先，我将提取给定信息并验证问题陈述。\n\n#### 提取的已知条件：\n1.  **洛伦兹96模型**:\n    $$\n    \\frac{d x_i}{d t} = \\left(x_{i+1} - x_{i-2}\\right) x_{i-1} - x_i + F, \\quad i = 1, \\dots, K\n    $$\n    使用循环索引（$x_0 \\equiv x_K$ 等）和常数强迫项 $F$。\n\n2.  **雅可比矩阵 $\\mathbf{J}(\\mathbf{x})$**:\n    $$\n    J_{ij} = \\frac{\\partial}{\\partial x_j}\\left(\\frac{dx_i}{dt}\\right) = \n    \\begin{cases}\n    x_{i+1} - x_{i-2},  j = i-1, \\\\\n    x_{i-1},  j = i+1, \\\\\n    - x_{i-1},  j = i-2, \\\\\n    -1,  j = i, \\\\\n    0,  \\text{otherwise},\n    \\end{cases}\n    $$\n    使用循环索引。\n\n3.  **流映射与切线性模型 (TLM)**:\n    -   非线性流映射：$\\mathcal{M}_T: \\mathbb{R}^K \\to \\mathbb{R}^K$，将 $\\mathbf{x}_0$ 演化到 $\\mathbf{x}(T)$。\n    -   TLM 方程：$\\frac{d \\mathbf{z}}{d t} = \\mathbf{J}(\\mathbf{x}(t)) \\, \\mathbf{z}$，其中 $\\mathbf{x}(t)$ 是从 $\\mathbf{x}_0$ 开始的基准轨迹。$\\mathbf{z}(T)$ 是从初始扰动 $\\mathbf{z}(0) = \\mathbf{p}_0$ 开始在时间 $T$ 的解。\n\n4.  **验证量**:\n    -   非线性扰动差异：$\\delta_{\\text{nl}}(\\alpha) = \\mathcal{M}_T\\big(\\mathbf{x}_0 + \\alpha \\mathbf{p}_0\\big) - \\mathcal{M}_T(\\mathbf{x}_0)$。\n    -   TLM 预测：$\\delta_{\\text{tl}}(\\alpha) = \\alpha \\, \\mathbf{z}(T)$。\n    -   最大相对差异：$E_{\\max} = \\max_{\\alpha \\in \\mathcal{A}} \\frac{\\left\\lVert \\delta_{\\text{nl}}(\\alpha) - \\delta_{\\text{tl}}(\\alpha) \\right\\rVert_2}{\\left\\lVert \\delta_{\\text{tl}}(\\alpha) \\right\\rVert_2}$。\n\n5.  **数值方法**:\n    -   积分器：四阶龙格－库塔 (RK4)。\n    -   时间步长：$\\Delta t$。\n\n6.  **初始条件生成**:\n    -   每个测试用例使用固定的随机种子。\n    -   基准状态：$\\mathbf{x}_0 = F \\cdot \\mathbf{1} + 0.01 \\, \\boldsymbol{\\eta}$，其中 $\\boldsymbol{\\eta} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{I})$。\n    -   初始扰动：从 $\\mathcal{N}(\\mathbf{0}, \\mathbf{I})$ 中抽取 $\\mathbf{p}_0$，然后归一化使其 $\\lVert \\mathbf{p}_0 \\rVert_2 = 1$。\n\n7.  **测试用例**:\n    -   用例1：$K = 10$, $F = 8$, $T = 1.0$, $\\Delta t = 0.01$, $\\mathcal{A} = \\{10^{-6}, 5 \\cdot 10^{-6}, 10^{-5}\\}$, 种子 $0$。\n    -   用例2：$K = 10$, $F = 8$, $T = 5.0$, $\\Delta t = 0.01$, $\\mathcal{A} = \\{10^{-6}, 5 \\cdot 10^{-6}, 10^{-5}\\}$, 种子 $1$。\n    -   用例3：$K = 10$, $F = 8$, $T = 1.0$, $\\Delta t = 0.01$, $\\mathcal{A} = \\{10^{-3}, 5 \\cdot 10^{-3}, 10^{-2}\\}$, 种子 $2$。\n    -   用例4：$K = 5$, $F = 8$, $T = 1.0$, $\\Delta t = 0.01$, $\\mathcal{A} = \\{10^{-8}, 5 \\cdot 10^{-8}, 10^{-7}\\}$, 种子 $3$。\n\n8.  **输出格式**: 单行输出，包含一个逗号分隔的 $E_{\\max}$ 值列表，用方括号括起：$[\\text{E}_{\\max}^{(1)},\\text{E}_{\\max}^{(2)},\\text{E}_{\\max}^{(3)},\\text{E}_{\\max}^{(4)}]$。\n\n#### 结论：\n问题是**有效的**。\n-   它**有科学依据**：洛伦兹96系统、其雅可比矩阵、切线性模型的概念以及RK4积分方案在动力系统数值建模领域都是标准且成熟的。验证测试本身通过比较非线性模型中小的有限扰动的演化与线性化模型的预测，是验证TLM实现的基本技术。预期的结果是差异应为 $\\alpha$ 的量级，而该测试正是衡量这一点。\n-   它是**适定的**：所有必要的参数、初始条件和数值方法都已指定，确保可以计算出唯一的数值解。给定随机种子，过程是确定性的。\n-   它是**客观的**：问题以精确的数学和算法术语陈述，没有歧义或主观解释。\n-   该问题没有显示任何无效标志。它是在指定领域内一个明确定义的计算任务。\n\n### 第2步：解决方案设计\n\n解决方案的核心是为非线性洛伦兹96模型及其相关的切线性模型实现数值积分。\n\n#### 算法：\n\n1.  **实现洛伦兹96系统**：\n    一个函数 `lorenz96_rhs(x, F)` 将计算洛伦兹96方程的右端项（时间导数）。这可以使用 `numpy.roll` 来高效实现循环边界条件。对于大小为 $K$ 的状态向量 `x`，导数计算如下：\n    `dxdt = (np.roll(x, -1) - np.roll(x, 2)) * np.roll(x, 1) - x + F`。\n\n2.  **实现雅可比矩阵**：\n    一个函数 `lorenz96_jacobian(x)` 将构建 $K \\times K$ 的雅可比矩阵 $\\mathbf{J}(\\mathbf{x})$。该矩阵是稀疏的，有四个非零对角线（包括主对角线），并具有循环包裹特性。对于给定的状态 `x`，矩阵元素将根据提供的公式填充。\n\n3.  **实现积分器**：\n    将实现一个通用的四阶龙格－库塔步进函数 `rk4_step(rhs_func, y, dt, *args)`。此函数将使用由 `rhs_func` 定义的动力学，将状态向量 `y` 向前推进一个时间步长 `dt`。\n\n4.  **积分耦合系统**：\n    为了精确地积分依赖于每个瞬间非线性轨迹状态的TLM，我们积分一个大小为 $2K$ 的组合状态向量 $\\mathbf{y} = [\\mathbf{x}, \\mathbf{z}]^T$。这个增广系统的右端项是：\n    $$\n    \\frac{d\\mathbf{y}}{dt} = \\begin{bmatrix} d\\mathbf{x}/dt \\\\ d\\mathbf{z}/dt \\end{bmatrix} = \\begin{bmatrix} \\text{lorenz96\\_rhs}(\\mathbf{x}, F) \\\\ \\mathbf{J}(\\mathbf{x})\\mathbf{z} \\end{bmatrix}\n    $$\n    将为此目的创建一个 `augmented_rhs` 函数。从初始状态 $\\mathbf{y}_0 = [\\mathbf{x}_0, \\mathbf{p}_0]^T$ 开始对该系统积分一段时间 $T$，得到最终状态 $[\\mathbf{x}(T), \\mathbf{z}(T)]^T$。分量 $\\mathbf{x}(T)$ 是参考最终状态 $\\mathcal{M}_T(\\mathbf{x}_0)$，而 $\\mathbf{z}(T)$ 是演化后的初始扰动。\n\n5.  **计算差异**：\n    对于每个测试用例：\n    a.  设置参数（$K, F, T, \\Delta t, \\mathcal{A}$, 种子）。\n    b.  按规定生成初始条件 $\\mathbf{x}_0$ 和 $\\mathbf{p}_0$。\n    c.  从 $[\\mathbf{x}_0, \\mathbf{p}_0]^T$ 开始积分增广系统，以获得参考最终状态 $\\mathbf{x}_{\\text{ref}}(T) = \\mathcal{M}_T(\\mathbf{x}_0)$ 和演化后的扰动 $\\mathbf{z}(T)$。\n    d.  对于每个振幅 $\\alpha \\in \\mathcal{A}$：\n        i.   计算TLM预测：$\\delta_{\\text{tl}}(\\alpha) = \\alpha \\, \\mathbf{z}(T)$。\n        ii.  创建扰动后的初始条件 $\\mathbf{x}_0^{\\text{pert}} = \\mathbf{x}_0 + \\alpha \\mathbf{p}_0$。\n        iii. 从 $\\mathbf{x}_0^{\\text{pert}}$ 开始对*非线性*洛伦兹96系统积分一段时间 $T$，得到 $\\mathbf{x}_{\\text{pert}}(T) = \\mathcal{M}_T(\\mathbf{x}_0^{\\text{pert}})$。\n        iv.  计算非线性差异：$\\delta_{\\text{nl}}(\\alpha) = \\mathbf{x}_{\\text{pert}}(T) - \\mathbf{x}_{\\text{ref}}(T)$。\n        v.   计算相对差异：$\\frac{\\left\\lVert \\delta_{\\text{nl}}(\\alpha) - \\delta_{\\text{tl}}(\\alpha) \\right\\rVert_2}{\\left\\lVert \\delta_{\\text{tl}}(\\alpha) \\right\\rVert_2}$。\n    e.  测试用例的结果 $E_{\\max}$ 是这些差异在所有 $\\alpha$ 上的最大值。\n\n6.  **最终输出**：\n    来自所有测试用例的 $E_{\\max}$ 值将被收集到一个列表中，并以指定格式打印。积分步数将计算为 `int(round(T / dt))` 来处理潜在的浮点不精确性。",
            "answer": "```python\nimport numpy as np\n\ndef lorenz96_rhs(x, F):\n    \"\"\"Computes the right-hand side of the Lorenz 96 system.\"\"\"\n    K = len(x)\n    dxdt = np.zeros(K)\n    \n    # Vectorized computation using np.roll for cyclic boundary conditions\n    x_p1 = np.roll(x, -1)  # x_{i+1}\n    x_m1 = np.roll(x, 1)   # x_{i-1}\n    x_m2 = np.roll(x, 2)   # x_{i-2}\n    \n    dxdt = (x_p1 - x_m2) * x_m1 - x + F\n    return dxdt\n\ndef lorenz96_jacobian(x):\n    \"\"\"Computes the Jacobian matrix of the Lorenz 96 system.\"\"\"\n    K = len(x)\n    J = np.zeros((K, K))\n    \n    x_p1 = np.roll(x, -1) # x_{i+1} at index i\n    x_m1 = np.roll(x, 1)  # x_{i-1} at index i\n    x_m2 = np.roll(x, 2)  # x_{i-2} at index i\n\n    # Populate the Jacobian matrix row by row\n    # This explicit loop is clear and efficient enough for K values used.\n    for i in range(K):\n        # j = i\n        J[i, i] = -1.0\n        # j = i+1\n        J[i, (i + 1) % K] = x_m1[i]\n        # j = i-1\n        J[i, (i - 1 + K) % K] = x_p1[i] - x_m2[i]\n        # j = i-2\n        J[i, (i - 2 + K) % K] = -x_m1[i]\n        \n    return J\n\ndef rk4_step(rhs_func, y, dt, *args):\n    \"\"\"Performs a single fourth-order Runge-Kutta step.\"\"\"\n    k1 = rhs_func(y, *args)\n    k2 = rhs_func(y + dt / 2.0 * k1, *args)\n    k3 = rhs_func(y + dt / 2.0 * k2, *args)\n    k4 = rhs_func(y + dt * k3, *args)\n    return y + dt / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\ndef solve():\n    \"\"\"\n    Main solver function to run the test suite and compute maximum relative discrepancies.\n    \"\"\"\n    test_cases = [\n        # Case 1: happy path\n        {'K': 10, 'F': 8.0, 'T': 1.0, 'dt': 0.01, 'A': [1e-6, 5e-6, 1e-5], 'seed': 0},\n        # Case 2: longer window\n        {'K': 10, 'F': 8.0, 'T': 5.0, 'dt': 0.01, 'A': [1e-6, 5e-6, 1e-5], 'seed': 1},\n        # Case 3: large amplitudes, breakdown check\n        {'K': 10, 'F': 8.0, 'T': 1.0, 'dt': 0.01, 'A': [1e-3, 5e-3, 1e-2], 'seed': 2},\n        # Case 4: edge case with small dimension and tiny amplitudes\n        {'K': 5, 'F': 8.0, 'T': 1.0, 'dt': 0.01, 'A': [1e-8, 5e-8, 1e-7], 'seed': 3},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        K, F, T, dt, A, seed = case['K'], case['F'], case['T'], case['dt'], case['A'], case['seed']\n        \n        # --- Setup Initial Conditions ---\n        rng = np.random.default_rng(seed)\n        eta = rng.standard_normal(K)\n        x0 = F * np.ones(K) + 0.01 * eta\n        \n        p0 = rng.standard_normal(K)\n        p0 /= np.linalg.norm(p0)\n        \n        num_steps = int(round(T / dt))\n\n        # --- Define RHS for augmented (Nonlinear + TLM) system ---\n        def augmented_rhs(y, F_val):\n            K_val = len(y) // 2\n            x = y[:K_val]\n            z = y[K_val:]\n            \n            dxdt = lorenz96_rhs(x, F_val)\n            J = lorenz96_jacobian(x)\n            dzdt = J @ z\n            \n            return np.concatenate([dxdt, dzdt])\n\n        # --- Integrate to find reference trajectory and z(T) ---\n        y_augmented = np.concatenate([x0, p0])\n        for _ in range(num_steps):\n            y_augmented = rk4_step(augmented_rhs, y_augmented, dt, F)\n            \n        x_T_ref = y_augmented[:K]\n        z_T = y_augmented[K:]\n\n        # --- Compute TLM vs Nonlinear Discrepancy ---\n        discrepancies = []\n        for alpha in A:\n            # TLM prediction\n            delta_tl = alpha * z_T\n            \n            # Full nonlinear integration of perturbed state\n            x0_pert = x0 + alpha * p0\n            x_pert_current = x0_pert\n            for _ in range(num_steps):\n                x_pert_current = rk4_step(lorenz96_rhs, x_pert_current, dt, F)\n            x_T_pert = x_pert_current\n            \n            # Nonlinear difference\n            delta_nl = x_T_pert - x_T_ref\n            \n            # Relative discrepancy\n            norm_tl = np.linalg.norm(delta_tl)\n            if norm_tl > 0:\n                discrepancy = np.linalg.norm(delta_nl - delta_tl) / norm_tl\n                discrepancies.append(discrepancy)\n        \n        E_max = max(discrepancies) if discrepancies else 0.0\n        results.append(E_max)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "奇异向量不仅仅是抽象的数学构造；它们是揭示系统中最快增长不稳定性的强大物理探针。这个练习将理论与实践相结合，让您在一个简化的湿热力学模型中计算主导奇异向量。通过比较饱和和非饱和基态下的结果，您将亲身体验到增长最快的扰动结构是如何随关键物理过程（如湿耦合）的存在而改变的，从而加深对大气可预报性背后物理机制的理解 。",
            "id": "4018774",
            "problem": "考虑一个围绕固定基态线性化的简化单柱湿热力学模型。扰动状态向量定义为 $\\mathbf{x}(t) = [T'(t),\\, q'(t)]^\\top$，其中 $T'$ 是温度扰动，$q'$ 是比湿扰动。线性化趋势被建模为一个时不变线性常微分方程\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\,\\mathbf{x},\n$$\n其中\n$$\n\\mathbf{A} = \\begin{bmatrix}\n-a  \\lambda \\\\\n-\\mu  -b\n\\end{bmatrix}.\n$$\n参数 $a$ 和 $b$（单位均为 $\\mathrm{hr}^{-1}$）表示由辐射冷却和湿弛豫等过程产生的线性阻尼率，参数 $\\lambda$ 和 $\\mu$（单位均为 $\\mathrm{hr}^{-1}$）捕捉了线性化湿耦合：当 $q'$ 为正时，凝结产生的潜热加热使气柱变暖（由 $\\lambda > 0$ 建模），而在饱和状态下，随着 $T'$ 变暖，饱和水汽压增加会降低 $q'$（由 $\\mu > 0$ 建模）。在非饱和基态中，对于小扰动，$\\lambda$ 和 $\\mu$ 都可以理想化为零。对于一个有限的时间范围 $\\tau$（单位为小时），线性传播算子为\n$$\n\\mathbf{M}(\\tau) = \\exp(\\mathbf{A}\\,\\tau),\n$$\n因此 $\\mathbf{x}(\\tau) = \\mathbf{M}(\\tau)\\,\\mathbf{x}(0)$。\n\n为了量化扰动的增长和方向，使用由对称正定矩阵 $\\mathbf{W} = \\mathrm{diag}(c_T, c_q)$ 定义的加权能量范数，其中 $c_T > 0$ 且 $c_q > 0$。其诱导范数为 $\\|\\mathbf{x}\\|_{\\mathbf{W}} = \\|\\mathbf{W}^{1/2}\\mathbf{x}\\|_2$。领先奇异向量（即在时间 $\\tau$ 内使范数增长最大化的初始扰动方向）被定义为以下表达式的最大化者：\n$$\n\\max_{\\mathbf{x}(0) \\neq \\mathbf{0}} \\frac{\\|\\mathbf{W}^{1/2}\\,\\mathbf{M}(\\tau)\\,\\mathbf{x}(0)\\|_2}{\\|\\mathbf{W}^{1/2}\\,\\mathbf{x}(0)\\|_2}.\n$$\n等价地，令 $\\widetilde{\\mathbf{M}} = \\mathbf{W}^{1/2}\\,\\mathbf{M}(\\tau)\\,\\mathbf{W}^{-1/2}$，则 $\\widetilde{\\mathbf{M}}$ 的领先右奇异向量决定了加权空间中的最优初始方向；映射回物理空间可得到领先奇异向量 $\\mathbf{v}_0 = \\mathbf{W}^{-1/2}\\,\\mathbf{v}$，其中 $\\mathbf{v}$ 是 $\\widetilde{\\mathbf{M}}$ 的领先右奇异向量。\n\n定义领先奇异向量 $\\mathbf{v}_0 = [v_T, v_q]^\\top$ 相对于温度轴的方向角 $\\theta$（单位为度）为 $\\mathbf{v}_0$ 与单位向量 $\\mathbf{e}_T = [1, 0]^\\top$ 之间的无符号角：\n$$\n\\theta = \\arccos\\left(\\frac{|v_T|}{\\sqrt{v_T^2 + v_q^2}}\\right)\\cdot \\frac{180}{\\pi}.\n$$\n此定义确保 $\\theta \\in [0, 90]$ 度。定义有限时间增长因子 $\\sigma_1$ 为 $\\widetilde{\\mathbf{M}}$ 的最大奇异值，相应的增长率 $g$（单位为 $\\mathrm{hr}^{-1}$）为\n$$\ng = \\frac{1}{\\tau}\\,\\ln(\\sigma_1).\n$$\n\n您的任务是编写一个程序，对下面列出的参数集，计算领先奇异向量方向 $\\theta$（单位为度）和增长率 $g$（单位为 $\\mathrm{hr}^{-1}$）。使用矩阵指数计算 $\\mathbf{M}(\\tau)$。对于每种情况，权重矩阵为 $\\mathbf{W} = \\mathrm{diag}(1, w_q)$，其中 $w_q$ 为指定值。报告 $\\theta$（四舍五入到三位小数，单位为度）和 $g$（四舍五入到六位小数，单位为 $\\mathrm{hr}^{-1}$）。\n\n测试套件（每种情况的参数为 $(a, b, \\lambda, \\mu, \\tau, w_q)$，单位分别为 $\\mathrm{hr}^{-1}$, $\\mathrm{hr}^{-1}$, $\\mathrm{hr}^{-1}$, $\\mathrm{hr}^{-1}$, $\\mathrm{hr}$ 和无单位）：\n- 情况 1（非饱和基态，正常路径）：$(0.1, 0.2, 0.0, 0.0, 6.0, 1.0)$。\n- 情况 2（饱和基态，中等耦合）：$(0.1, 1.5, 0.8, 0.6, 6.0, 1.0)$。\n- 情况 3（饱和基态，强耦合）：$(0.1, 1.5, 1.2, 1.0, 6.0, 1.0)$。\n- 情况 4（非饱和基态，弱阻尼和更长时间范围）：$(0.05, 0.06, 0.0, 0.0, 12.0, 1.0)$。\n- 情况 5（饱和基态，中等耦合，湿度主导度量）：$(0.1, 1.5, 0.8, 0.6, 6.0, 9.0)$。\n\n要求：\n- 所有速率 $a$、 $b$、 $\\lambda$、 $\\mu$ 必须解释为 $\\mathrm{hr}^{-1}$，时间范围 $\\tau$ 解释为 $\\mathrm{hr}$，输出增长率 $g$ 解释为 $\\mathrm{hr}^{-1}$。角度必须以度为单位。\n- 通过矩阵指数计算 $\\mathbf{M}(\\tau) = \\exp(\\mathbf{A}\\,\\tau)$，并通过在加权空间中进行奇异值分解来获得 $\\sigma_1$ 和 $\\mathbf{v}_0$。\n- 对于每种情况，输出包含 $[\\theta, g]$ 的数对，并按指定的精度进行四舍五入。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应情况的双元素列表，顺序与给定顺序一致。例如：$[[\\theta_1, g_1],[\\theta_2, g_2],\\dots]$。",
            "solution": "该问题被评估为有效。它在科学上基于大气动力学和可预报性理论的原理，问题设定良好，具有完整且一致的定义和参数集，并以客观、正式的语言表述。通过标准的矩阵分析可以得出一个唯一的、有意义的解。\n\n任务是为一个简化的湿热力学模型计算领先奇异向量的方向角 $\\theta$ 和增长率 $g$。该过程涉及构建系统矩阵，将系统随时间向前传播，并在加权范数下执行奇异值分解。对每个指定的参数集重复此过程。\n\n系统状态由扰动向量 $\\mathbf{x}(t) = [T'(t), q'(t)]^\\top$ 描述，其中 $T'$ 是温度扰动，$q'$ 是比湿扰动。其演化由线性常微分方程控制：\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\,\\mathbf{x}\n$$\n系统矩阵 $\\mathbf{A}$ 由下式给出：\n$$\n\\mathbf{A} = \\begin{bmatrix}\n-a  \\lambda \\\\\n-\\mu  -b\n\\end{bmatrix}\n$$\n其中参数 $a$、 $b$、 $\\lambda$ 和 $\\mu$ 已为每种情况提供。所有速率的单位均为 $\\mathrm{hr}^{-1}$。\n\n在时间间隔 $\\tau$（单位为小时）后，$\\mathbf{x}(t)$ 的解通过线性传播算子矩阵 $\\mathbf{M}(\\tau)$ 求得，该矩阵是 $\\mathbf{A}\\tau$ 的矩阵指数：\n$$\n\\mathbf{x}(\\tau) = \\mathbf{M}(\\tau)\\,\\mathbf{x}(0) \\quad \\text{其中} \\quad \\mathbf{M}(\\tau) = \\exp(\\mathbf{A}\\,\\tau)\n$$\n\n我们感兴趣的是在时间间隔 $\\tau$ 内经历最大增长的初始扰动 $\\mathbf{x}(0)$，该增长以加权能量范数衡量。此范数由对称正定矩阵 $\\mathbf{W} = \\mathrm{diag}(1, w_q)$ 定义：\n$$\n\\|\\mathbf{x}\\|_{\\mathbf{W}} = \\sqrt{\\mathbf{x}^\\top \\mathbf{W} \\mathbf{x}} = \\|\\mathbf{W}^{1/2}\\mathbf{x}\\|_2\n$$\n初始扰动 $\\mathbf{x}(0)$ 的增长因子是最终范数与初始范数之比：\n$$\n\\frac{\\|\\mathbf{x}(\\tau)\\|_{\\mathbf{W}}}{\\|\\mathbf{x}(0)\\|_{\\mathbf{W}}} = \\frac{\\|\\mathbf{W}^{1/2}\\,\\mathbf{M}(\\tau)\\,\\mathbf{x}(0)\\|_2}{\\|\\mathbf{W}^{1/2}\\,\\mathbf{x}(0)\\|_2}\n$$\n为简化此表达式，我们定义一个变换后的初始状态 $\\mathbf{y}(0) = \\mathbf{W}^{1/2}\\,\\mathbf{x}(0)$，这意味着 $\\mathbf{x}(0) = \\mathbf{W}^{-1/2}\\,\\mathbf{y}(0)$。将此代入增长因子表达式中得到：\n$$\n\\frac{\\|\\mathbf{W}^{1/2}\\,\\mathbf{M}(\\tau)\\,\\mathbf{W}^{-1/2}\\,\\mathbf{y}(0)\\|_2}{\\|\\mathbf{y}(0)\\|_2} = \\frac{\\|\\widetilde{\\mathbf{M}}\\,\\mathbf{y}(0)\\|_2}{\\|\\mathbf{y}(0)\\|_2}\n$$\n其中 $\\widetilde{\\mathbf{M}} = \\mathbf{W}^{1/2}\\,\\mathbf{M}(\\tau)\\,\\mathbf{W}^{-1/2}$ 是在加权坐标系中的传播算子。\n\n根据定义，此比率的最大值是 $\\widetilde{\\mathbf{M}}$ 的最大奇异值，记为 $\\sigma_1$。实现此最大值的初始扰动 $\\mathbf{y}(0)$ 是 $\\widetilde{\\mathbf{M}}$ 对应的领先右奇异向量，我们将其表示为 $\\mathbf{v}$。\n\n针对每个测试用例的算法如下：\n\n1.  **构建矩阵**：给定参数 $(a, b, \\lambda, \\mu, \\tau, w_q)$，构建矩阵 $\\mathbf{A}$。权重矩阵为 $\\mathbf{W} = \\mathrm{diag}(1, w_q)$。其平方根和逆平方根分别为 $\\mathbf{W}^{1/2} = \\mathrm{diag}(1, \\sqrt{w_q})$ 和 $\\mathbf{W}^{-1/2} = \\mathrm{diag}(1, 1/\\sqrt{w_q})$。\n\n2.  **计算传播算子**：使用数值矩阵指数函数计算传播算子矩阵 $\\mathbf{M}(\\tau) = \\exp(\\mathbf{A}\\,\\tau)$。\n\n3.  **变换传播算子**：计算加权传播算子 $\\widetilde{\\mathbf{M}} = \\mathbf{W}^{1/2}\\,\\mathbf{M}(\\tau)\\,\\mathbf{W}^{-1/2}$。\n\n4.  **奇异值分解 (SVD)**：对 $\\widetilde{\\mathbf{M}}$ 进行 SVD，以找到其最大奇异值 $\\sigma_1$ 和相应的右奇异向量 $\\mathbf{v}$。SVD 由 $\\widetilde{\\mathbf{M}} = \\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$ 给出。值 $\\sigma_1$ 是 $\\mathbf{\\Sigma}$ 对角线上的第一个元素，而 $\\mathbf{v}$ 是矩阵 $\\mathbf{V}$ 的第一列。\n\n5.  **计算增长率 ($g$)**：有限时间增长率 $g$ 从 $\\sigma_1$ 和 $\\tau$ 导出：\n    $$\n    g = \\frac{1}{\\tau}\\,\\ln(\\sigma_1)\n    $$\n    结果以 $\\mathrm{hr}^{-1}$ 为单位，并四舍五入到六位小数。\n\n6.  **寻找物理奇异向量 ($\\mathbf{v}_0$)**：物理空间中的最优初始扰动 $\\mathbf{v}_0 = [v_T, v_q]^\\top$ 是通过将 $\\mathbf{v}$ 从加权空间变换回来得到的：\n    $$\n    \\mathbf{v}_0 = \\mathbf{W}^{-1/2}\\,\\mathbf{v}\n    $$\n\n7.  **计算方向角 ($\\theta$)**：$\\mathbf{v}_0$ 相对于温度轴的方向角 $\\theta$ 是无符号角，确保 $\\theta \\in [0, 90]$ 度：\n    $$\n    \\theta = \\arccos\\left(\\frac{|v_T|}{\\|\\mathbf{v}_0\\|_2}\\right) \\cdot \\frac{180}{\\pi} = \\arccos\\left(\\frac{|v_T|}{\\sqrt{v_T^2 + v_q^2}}\\right) \\cdot \\frac{180}{\\pi}\n    $$\n    结果以度为单位，并四舍五入到三位小数。\n\n此过程系统地应用于所提供的五个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the leading singular vector orientation and growth rate for a\n    linearized moist thermodynamic model for several parameter sets.\n    \"\"\"\n    # Test suite: each tuple is (a, b, lambda, mu, tau, w_q)\n    # The parameters from the problem statement use commas for decimals, which are\n    # interpreted as dots for standard float representation.\n    test_cases = [\n        # Case 1 (unsaturated base, happy path)\n        (0.1, 0.2, 0.0, 0.0, 6.0, 1.0),\n        # Case 2 (saturated base, moderate coupling)\n        (0.1, 1.5, 0.8, 0.6, 6.0, 1.0),\n        # Case 3 (saturated base, strong coupling)\n        (0.1, 1.5, 1.2, 1.0, 6.0, 1.0),\n        # Case 4 (unsaturated base, weak damping and longer horizon)\n        (0.05, 0.06, 0.0, 0.0, 12.0, 1.0),\n        # Case 5 (saturated base, moderate coupling with moisture-dominant metric)\n        (0.1, 1.5, 0.8, 0.6, 6.0, 9.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, b, lam, mu, tau, w_q = case\n        \n        # Step 1: Construct the system matrix A\n        A = np.array([\n            [-a, lam],\n            [-mu, -b]\n        ])\n\n        # Step 2: Compute the propagator M(tau)\n        M_tau = expm(A * tau)\n\n        # Step 3: Construct weight matrices and transform the propagator\n        # W = diag(1, w_q)\n        # W_sqrt = diag(1, sqrt(w_q))\n        # W_inv_sqrt = diag(1, 1/sqrt(w_q))\n        sqrt_w_q = np.sqrt(w_q)\n        W_sqrt = np.diag([1.0, sqrt_w_q])\n        W_inv_sqrt = np.diag([1.0, 1.0 / sqrt_w_q])\n        \n        # M_tilde = W_sqrt * M_tau * W_inv_sqrt\n        M_tilde = W_sqrt @ M_tau @ W_inv_sqrt\n\n        # Step 4: Perform Singular Value Decomposition (SVD) of M_tilde\n        # U, s, Vh = svd(M_tilde), where Vh is V.T\n        _, s, Vh = np.linalg.svd(M_tilde)\n        \n        # The largest singular value is the first element of s\n        sigma_1 = s[0]\n        \n        # The leading right singular vector is the first column of V (or first row of Vh)\n        v = Vh[0, :]\n\n        # Step 5: Calculate the growth rate g\n        g = np.log(sigma_1) / tau\n\n        # Step 6: Find the physical singular vector v0\n        # v0 = W_inv_sqrt * v\n        v0 = W_inv_sqrt @ v\n        vT, vq = v0[0], v0[1]\n\n        # Step 7: Calculate the orientation angle theta\n        norm_v0 = np.linalg.norm(v0)\n        # Handle case where v0 might be a zero vector, though unlikely\n        if norm_v0 == 0:\n            theta = 0.0\n        else:\n            # arccos is in radians, convert to degrees\n            theta = np.arccos(np.abs(vT) / norm_v0) * (180.0 / np.pi)\n\n        # Format results as specified\n        result = [round(theta, 3), round(g, 6)]\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "生成像奇异向量这样的特定扰动的最终目的是为了提高预报技巧和更准确地量化预报不确定性。但是，奇异向量在实践中真的比简单的随机扰动更有效吗？这个高级实践将引导您设计并实施一个严谨的蒙特卡罗实验，以统计学方式回答这个问题 。您将构建基于奇异向量和随机扰动的两个集合，并使用假设检验来量化奇异向量在增强对特定预报指标的敏感性方面的优势，这是评估任何集合生成方案有效性的关键技能。",
            "id": "4018795",
            "problem": "考虑一个线性切线模型，它代表一个维度为 $n$ 的状态向量的短期预报，其定义为 $x(T) = M x(0)$，其中 $M \\in \\mathbb{R}^{n \\times n}$ 是从初始时间 $0$ 到预报验证时间 $T$ 的线性传播算子。设初始条件范数由对称正定矩阵 $V \\succ 0$ 通过 $\\|x\\|_{V} = \\|V^{1/2} x\\|_{2}$ 定义，并设所选的预报度量是由对称正定矩阵 $W \\succ 0$ 通过 $\\|y\\|_{W} = \\|W^{1/2} y\\|_{2}$ 定义的加权范数。扰动 $\\delta x$ 的预报度量振幅为 $A(\\delta x) = \\|W^{1/2} M \\delta x\\|_{2}^{2}$。\n\n奇异向量被定义为在固定的初始范数约束下，使时间 $T$ 的预报度量振幅最大化的初始扰动 $\\delta x$ 的方向。形式上，领头奇异向量求解\n$$\n\\max_{\\delta x \\in \\mathbb{R}^{n}} \\|W^{1/2} M \\delta x\\|_{2} \\quad \\text{subject to} \\quad \\|V^{1/2} \\delta x\\|_{2} = 1.\n$$\n这可以通过奇异值分解（SVD）计算，如果 $A = W^{1/2} M V^{-1/2}$ 的 SVD 为 $A = U \\Sigma Q^{\\top}$，其中 $\\Sigma = \\operatorname{diag}(\\sigma_{1}, \\sigma_{2}, \\dots)$ 且 $Q$ 是正交的，那么领头的右奇异向量 $q_{1}$ 给出领头的初始条件奇异向量 $\\delta x^{\\ast} = V^{-1/2} q_{1}$，其经过归一化以满足 $\\|V^{1/2} \\delta x^{\\ast}\\|_{2} = 1$。\n\n设计并实现一个实验，以评估相对于随机扰动，奇异向量扰动是否能提高对所选度量的预报敏感性。使用蒙特卡洛设置生成：\n- 一个包含 $N$ 个扰动的随机集合，通过在由初始范数 $\\|\\cdot\\|_{V}$ 诱导的单位球面上均匀采样方向，并将每个采样到的扰动归一化，使其满足 $\\|V^{1/2} \\delta x\\|_{2} = 1$。\n- 一个包含 $N$ 个扰动的奇异向量集合，通过在领头奇异向量周围的一个小邻域内采样方向，并将每个扰动重新归一化，使其满足 $\\|V^{1/2} \\delta x\\|_{2} = 1$。具体来说，将每个奇异向量集合成员生成为 $\\delta x_{i}^{\\text{sv}} = \\operatorname{normalize}_{V}(\\delta x^{\\ast} + \\varepsilon \\,\\eta_{i})$，其中 $\\eta_{i}$ 是在 $V$-范数单位球面上均匀抽取的随机方向，$\\varepsilon > 0$ 是一个小的离散参数。\n\n对于每个集合，计算预报度量振幅 $A(\\delta x)$ 的样本，并进行统计检验，以评估奇异向量集合的平均预报度量振幅是否严格大于随机集合的。使用 Welch's $t$-检验处理不等方差的情况，其单侧零假设为 $H_{0}: \\mu_{\\text{sv}} \\le \\mu_{\\text{rand}}$，备择假设为 $H_{1}: \\mu_{\\text{sv}} > \\mu_{\\text{rand}}$，其中 $\\mu_{\\text{sv}}$ 和 $\\mu_{\\text{rand}}$ 分别表示在奇异向量集合和随机集合下 $A(\\delta x)$ 的总体均值。每个测试用例报告一个布尔结果，如果奇异向量集合下的样本均值超过随机集合下的样本均值，并且单侧 Welch's $t$-检验的 $p$-值严格小于规定的显著性水平 $\\alpha$，则结果为 true，否则为 false。\n\n从以下基本依据和定义开始：\n- 小扰动通过切线模型的线性传播：$x(T) = M x(0)$。\n- 由对称正定矩阵诱导的加权范数：$\\|x\\|_{V}^{2} = x^{\\top} V x$ 和 $\\|y\\|_{W}^{2} = y^{\\top} W y$。\n- 通过变换 $A = W^{1/2} M V^{-1/2}$ 计算加权范数下奇异向量的奇异值分解（SVD）。\n- 用于在不等方差下比较均值的 Welch's $t$-检验。\n\n您的程序必须实现：\n- 通过 Cholesky 分解构造 $V^{1/2}$ 和 $V^{-1/2}$，以及类似的 $W^{1/2}$。\n- 通过对 $A = W^{1/2} M V^{-1/2}$ 进行 SVD 计算领头奇异向量。\n- 使用各向同性高斯采样和归一化，在由 $\\|\\cdot\\|_{V}$ 诱导的单位球面上均匀生成随机扰动。\n- 通过向领头奇异向量添加小的 $V$-各向同性噪声并重新归一化，来生成奇异向量集合扰动。\n- 计算预报度量振幅 $A(\\delta x) = \\|W^{1/2} M \\delta x\\|_{2}^{2}$。\n- 在给定的显著性水平 $\\alpha$ 下，执行单侧 Welch's $t$-检验和决策逻辑。\n\n不涉及角度单位；不需要物理单位。\n\n使用以下测试套件。对于每个案例，都指定了维度 $n$、传播算子 $M$、初始范数矩阵 $V$、度量矩阵 $W$、集合大小 $N$、奇异向量集合离散度 $\\varepsilon$、显著性水平 $\\alpha$ 和一个伪随机种子。这些选择在科学上是合理的，并测试了该方法的不同方面。\n\n- 案例1（各向异性增长，单位范数，预期有改进）：\n  - $n = 2$, $M = \\begin{bmatrix} 1.6  0.1 \\\\ 0.0  0.7 \\end{bmatrix}$, $V = I_{2}$, $W = I_{2}$, $N = 1000$, $\\varepsilon = 0.05$, $\\alpha = 0.05$, seed $= 123$。\n- 案例2（各向同性增长，单位范数，无预期改进）：\n  - $n = 2$, $M = s R(\\theta)$，其中 $s = 1.2$ 且 $R(\\theta) = \\begin{bmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{bmatrix}$，设 $\\theta = 0.7$ 弧度, $V = I_{2}$, $W = I_{2}$, $N = 1000$, $\\varepsilon = 0.05$, $\\alpha = 0.05$, seed $= 456$。\n- 案例3（各向异性增长，小样本量，临界显著性）：\n  - $n = 2$, $M = \\begin{bmatrix} 1.4  0.0 \\\\ 0.0  0.6 \\end{bmatrix}$, $V = I_{2}$, $W = I_{2}$, $N = 30$, $\\varepsilon = 0.10$, $\\alpha = 0.05$, seed $= 789$。\n- 案例4（三维，非平凡度量权重）：\n  - $n = 3$, $M = \\begin{bmatrix} 1.7  0.2  0.0 \\\\ 0.0  0.9  0.1 \\\\ 0.0  0.0  0.6 \\end{bmatrix}$, $V = \\operatorname{diag}(1.0, 2.0, 0.5)$, $W = \\operatorname{diag}(2.0, 0.5, 3.0)$, $N = 800$, $\\varepsilon = 0.05$, $\\alpha = 0.05$, seed $= 101112$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4]”），每个结果都是一个布尔值，按上面列出的顺序对应每个测试用例。如果奇异向量集合的 $A(\\delta x)$ 样本均值严格大于随机集合的样本均值，并且单侧 Welch's $t$-检验的 $p$-值严格小于给定的 $\\alpha$，则结果为 true，否则为 false。",
            "solution": "该问题要求进行一个计算实验，以验证一个理论前提：与随机扰动相比，与线性预报模型的领头奇异向量对齐的初始扰动会在选定的预报度量中导致更大的放大。这是可预报性研究和集合预报中的一个基石概念，其中识别最快误差增长的方向对于量化预报不确定性至关重要。该实验将通过蒙特卡洛模拟进行，比较两个初始扰动集合，并使用统计假设检验来形式化这种比较。\n\n解决方案分为几个阶段：首先，建立加权范数背景下奇异向量的数学框架；其次，定义生成两个扰动集合的程序；第三，指定评估扰动增长的度量；最后，概述用于比较集合的统计检验。\n\n**1. 数学公式和奇异向量计算**\n\n系统动力学由一个线性切线模型描述，其中初始状态扰动 $\\delta x(0)$ 演变为最终扰动 $\\delta x(T) = M \\delta x(0)$，其中 $M \\in \\mathbb{R}^{n \\times n}$ 是传播矩阵。\n\n初始扰动的大小由加权范数 $\\| \\delta x \\|_{V} = ( \\delta x^{\\top} V \\delta x )^{1/2}$ 衡量，其中 $V$ 是一个定义了能量内积的对称正定（$V \\succ 0$）矩阵。类似地，最终扰动的大小由预报度量范数 $\\| \\delta x(T) \\|_{W} = ( \\delta x(T)^{\\top} W \\delta x(T) )^{1/2}$ 衡量，其中 $W \\succ 0$。\n\n目标是找到在单位初始范数约束 $\\|\\delta x\\|_{V} = 1$ 下，能使最终时刻振幅最大化的初始扰动 $\\delta x$，该振幅定义为 $A(\\delta x) = \\| \\delta x(T) \\|_{W}^{2} = \\| M \\delta x \\|_{W}^{2}$。该优化问题是：\n$$\n\\max_{\\delta x \\in \\mathbb{R}^{n}} \\| M \\delta x \\|_{W} \\quad \\text{subject to} \\quad \\|\\delta x\\|_{V} = 1\n$$\n这是一个广义奇异值问题。它可以被转换成一个标准的奇异值问题。由于 $V$ 和 $W$ 是对称正定的，它们有矩阵平方根 $V^{1/2}$ 和 $W^{1/2}$。这些范数可以用标准的欧几里得 2-范数表示：$\\| \\delta x \\|_{V} = \\|V^{1/2} \\delta x\\|_{2}$ 和 $\\| M \\delta x \\|_{W} = \\|W^{1/2} M \\delta x\\|_{2}$。\n\n我们引入变量替换：$u = V^{1/2} \\delta x$。那么 $\\delta x = V^{-1/2} u$。约束条件 $\\|\\delta x\\|_{V} = 1$ 变为 $\\|u\\|_{2} = 1$。目标函数变为：\n$$\n\\|W^{1/2} M \\delta x\\|_{2} = \\|W^{1/2} M V^{-1/2} u\\|_{2}\n$$\n定义矩阵 $A = W^{1/2} M V^{-1/2}$，问题就转换为：\n$$\n\\max_{u \\in \\mathbb{R}^{n}} \\| A u \\|_{2} \\quad \\text{subject to} \\quad \\|u\\|_{2} = 1\n$$\n这个标准问题的解由 $A$ 的奇异值分解（SVD）给出。设 $A$ 的 SVD 为 $A = U \\Sigma Q^{\\top}$，其中 $U$ 和 $Q$ 是正交矩阵，$\\Sigma$ 是由奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge 0$ 构成的对角矩阵。$\\|Au\\|_2$ 的最大值是最大的奇异值 $\\sigma_1$，当 $u$ 是对应的领头右奇异向量 $q_1$（$Q$ 的第一列）时取到。\n\n转换回原始变量 $\\delta x$，最优的初始扰动，即领头奇异向量，是 $\\delta x^{\\ast} = V^{-1/2} q_1$。产生的最大振幅为 $A(\\delta x^*) = \\|W^{1/2} M \\delta x^*\\|_2^2 = \\| A q_1 \\|_2^2 = \\sigma_1^2$。\n\n在实践中，矩阵平方根及其逆是使用 Cholesky 分解计算的。如果 $V = L_V L_V^{\\top}$ 是 $V$ 的 Cholesky 分解，那么 $V^{1/2}$ 的一个有效选择是 $L_V^{\\top}$。因此，$V^{-1/2} = (L_V^{\\top})^{-1} = L_V^{-\\top}$。这同样适用于 $W$。\n\n**2. 集合生成**\n\n为了检验该假设，我们生成两个各包含 $N$ 个扰动的集合。\n\n**随机集合：** 扰动必须从由 $V$-范数定义的 $n$ 维球面上的均匀分布中抽取。实现这一目标的标准程序是：\n1. 生成一个向量 $g_i \\in \\mathbb{R}^n$，其分量从标准正态分布中抽取，即 $g_i \\sim \\mathcal{N}(0, I_n)$。\n2. 在欧几里得范数下对 $g_i$ 进行归一化，得到一个在标准欧几里得单位球面上均匀分布的向量 $u_i = g_i / \\|g_i\\|_2$。\n3. 将 $u_i$ 变换到 $V$-范数单位球面：$\\delta x^{\\text{rand}}_i = V^{-1/2} u_i$。这确保了 $\\|V^{1/2} \\delta x^{\\text{rand}}_i\\|_2 = \\|V^{1/2} V^{-1/2} u_i\\|_2 = \\|u_i\\|_2 = 1$。\n\n**奇异向量集合：** 该集合旨在对领头奇异向量 $\\delta x^{\\ast}$ 周围的一个小邻域内的扰动进行采样。每个成员按如下方式生成：\n$$\n\\delta x_{i}^{\\text{sv}} = \\frac{\\delta x^{\\ast} + \\varepsilon \\,\\eta_{i}}{\\|V^{1/2} (\\delta x^{\\ast} + \\varepsilon \\,\\eta_{i})\\|_{2}}\n$$\n其中 $\\delta x^{\\ast}$ 是领头奇异向量，$\\varepsilon > 0$ 是一个小的离散参数，$\\eta_i$ 是从 $V$-范数单位球面上均匀抽取的随机扰动，其生成方法与随机集合相同。分母确保每个成员 $\\delta x_{i}^{\\text{sv}}$ 都被正确归一化，使其具有单位 $V$-范数。\n\n**3. 统计比较**\n\n对于两个集合中的每个扰动 $\\delta x_i$，我们计算预报度量振幅：\n$$\nA(\\delta x_i) = \\|W^{1/2} M \\delta x_i\\|_{2}^{2}\n$$\n这将产生两组标量值：$\\{A(\\delta x^{\\text{rand}}_i)\\}_{i=1}^N$ 和 $\\{A(\\delta x^{\\text{sv}}_i)\\}_{i=1}^N$。我们想要检验奇异向量集合的平均振幅是否显著大于随机集合的平均振幅。设 $\\mu_{\\text{sv}}$ 和 $\\mu_{\\text{rand}}$ 分别是相应集合振幅的真实总体均值。假设检验公式如下：\n- 零假设 $H_0: \\mu_{\\text{sv}} \\le \\mu_{\\text{rand}}$\n- 备择假设 $H_1: \\mu_{\\text{sv}} > \\mu_{\\text{rand}}$\n\n由于生成方法不保证两个振幅分布之间的方差相等，因此处理不等方差的 Welch's $t$-检验是合适的统计工具。$t$-统计量计算如下：\n$$\nt = \\frac{\\bar{A}_{\\text{sv}} - \\bar{A}_{\\text{rand}}}{\\sqrt{\\frac{s_{\\text{sv}}^2}{N} + \\frac{s_{\\text{rand}}^2}{N}}}\n$$\n其中 $\\bar{A}$ 和 $s^2$ 分别是每个集合振幅的样本均值和方差。自由度使用 Welch-Satterthwaite 方程进行估计。\n\n根据 $t$-统计量和自由度，计算出一个单侧 $p$-值。这个 $p$-值表示在零假设为真的前提下，观察到样本均值之差等于或大于计算值的概率。\n\n最终的决策规则是：当且仅当同时满足以下两个条件时，测试用例的结果为 `true`：\n1. 奇异向量集合的样本均值严格大于随机集合的样本均值（$\\bar{A}_{\\text{sv}} > \\bar{A}_{\\text{rand}}$）。\n2. 计算出的单侧 $p$-值严格小于规定的显著性水平 $\\alpha$。\n否则，结果为 `false`。\n\n此过程被系统地应用于提供的每个测试用例，使用指定的参数和随机种子以确保可复现性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import ttest_ind\n\ndef solve():\n    \"\"\"\n    Solves the problem by running a Monte Carlo experiment for each test case\n    to compare singular vector and random perturbation ensembles.\n    \"\"\"\n    \n    # Case 1: Anisotropic growth, identity norms\n    M1 = np.array([[1.6, 0.1], [0.0, 0.7]])\n    V1 = np.eye(2)\n    W1 = np.eye(2)\n    case1 = (2, M1, V1, W1, 1000, 0.05, 0.05, 123)\n\n    # Case 2: Isotropic growth, identity norms\n    s2 = 1.2\n    theta2 = 0.7\n    R2 = np.array([[np.cos(theta2), -np.sin(theta2)], [np.sin(theta2), np.cos(theta2)]])\n    M2 = s2 * R2\n    V2 = np.eye(2)\n    W2 = np.eye(2)\n    case2 = (2, M2, V2, W2, 1000, 0.05, 0.05, 456)\n\n    # Case 3: Anisotropic growth, small sample size\n    M3 = np.array([[1.4, 0.0], [0.0, 0.6]])\n    V3 = np.eye(2)\n    W3 = np.eye(2)\n    case3 = (2, M3, V3, W3, 30, 0.10, 0.05, 789)\n\n    # Case 4: Three-dimensional, nontrivial metric weights\n    M4 = np.array([[1.7, 0.2, 0.0], [0.0, 0.9, 0.1], [0.0, 0.0, 0.6]])\n    V4 = np.diag([1.0, 2.0, 0.5])\n    W4 = np.diag([2.0, 0.5, 3.0])\n    case4 = (3, M4, V4, W4, 800, 0.05, 0.05, 101112)\n\n    test_cases = [case1, case2, case3, case4]\n    results = []\n\n    for n, M, V, W, N, epsilon, alpha, seed in test_cases:\n        rng = np.random.default_rng(seed)\n\n        # Step 1: Compute matrix square roots and their inverses via Cholesky\n        L_V = np.linalg.cholesky(V)\n        V_sqrt = L_V.T\n        V_inv_sqrt = np.linalg.inv(V_sqrt)\n\n        L_W = np.linalg.cholesky(W)\n        W_sqrt = L_W.T\n\n        # Step 2: Compute the leading singular vector\n        A = W_sqrt @ M @ V_inv_sqrt\n        # np.linalg.svd returns U, s, Vt where Vt is V.T in U*S*V.T\n        # The rows of Vt are the right singular vectors.\n        _, _, Vt = np.linalg.svd(A)\n        q1 = Vt[0, :]  # Leading right singular vector\n        sv_leading = V_inv_sqrt @ q1\n        \n        # Helper function to generate perturbations on the V-norm unit sphere\n        def generate_v_norm_sphere_samples(num_samples):\n            gaussians = rng.standard_normal(size=(num_samples, n))\n            norms = np.linalg.norm(gaussians, axis=1, keepdims=True)\n            unit_euclidean = gaussians / norms\n            # Each row is a sample vector\n            v_norm_samples = (V_inv_sqrt @ unit_euclidean.T).T\n            return v_norm_samples\n\n        # Step 3: Generate the two ensembles\n        # Random ensemble\n        random_ensemble = generate_v_norm_sphere_samples(N)\n\n        # Singular vector ensemble\n        sv_ensemble_list = []\n        random_directions = generate_v_norm_sphere_samples(N)\n        for i in range(N):\n            eta_i = random_directions[i, :]\n            # Create perturbed SV\n            z = sv_leading + epsilon * eta_i\n            # Renormalize in the V-norm\n            norm_z_v = np.linalg.norm(V_sqrt @ z)\n            sv_ensemble_list.append(z / norm_z_v)\n        sv_ensemble = np.array(sv_ensemble_list)\n\n        # Step 4: Compute forecast metric amplitudes for both ensembles\n        def compute_amplitudes(ensemble):\n            # Propagate perturbations\n            evolved_ensemble = (M @ ensemble.T).T\n            # Compute W-norm of propagated perturbations\n            w_normed_evolved = (W_sqrt @ evolved_ensemble.T).T\n            # Amplitudes are the squared norms\n            amplitudes = np.linalg.norm(w_normed_evolved, axis=1)**2\n            return amplitudes\n\n        amplitudes_rand = compute_amplitudes(random_ensemble)\n        amplitudes_sv = compute_amplitudes(sv_ensemble)\n\n        # Step 5: Perform statistical test and check conditions\n        mean_rand = np.mean(amplitudes_rand)\n        mean_sv = np.mean(amplitudes_sv)\n\n        # Use Welch's t-test for a one-sided hypothesis H1: mean_sv > mean_rand\n        _, p_value = ttest_ind(\n            amplitudes_sv, amplitudes_rand, \n            equal_var=False, alternative='greater'\n        )\n\n        # The result is true if mean of SV is strictly larger AND p-value is significant\n        is_improvement = (mean_sv > mean_rand) and (p_value  alpha)\n        results.append(is_improvement)\n    \n    # Format boolean results to be lowercase strings for the join map.\n    # The problem description's example output shows \"True\", \"False\" which str() does.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}