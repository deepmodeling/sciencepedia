{
    "hands_on_practices": [
        {
            "introduction": "切线性模型（Tangent Linear Model, TLM）是计算奇异向量和分析误差增长的基石。因此，在信赖任何基于它的结果之前，我们必须严格验证我们的TLM代码是否正确。本练习提供了一种标准的验证方法，通过将TLM的线性近似与完整非线性模型对小扰动的行为进行比较，来检验其准确性 。",
            "id": "4018800",
            "problem": "考虑受力 Lorenz $96$ 系统，这是数值天气预报和气候建模中的一个标准概念模型，对于维度 $K \\in \\mathbb{N}$，由以下常微分方程定义：\n$$\n\\frac{d x_i}{d t} = \\left(x_{i+1} - x_{i-2}\\right) x_{i-1} - x_i + F, \\quad i = 1, \\dots, K,\n$$\n采用循环索引，使得 $x_{0} \\equiv x_{K}$，$x_{-1} \\equiv x_{K-1}$，$x_{K+1} \\equiv x_{1}$，以此类推。此处 $F \\in \\mathbb{R}$ 是一个常数强迫项。在状态 $\\mathbf{x} \\in \\mathbb{R}^K$ 处评估的向量场的相应雅可比矩阵是一个 $K \\times K$ 矩阵 $\\mathbf{J}(\\mathbf{x})$，其元素由下式给出：\n$$\n\\frac{\\partial}{\\partial x_j}\\left[\\left(x_{i+1} - x_{i-2}\\right) x_{i-1} - x_i + F\\right] = \n\\begin{cases}\nx_{i+1} - x_{i-2},  j = i-1, \\\\\nx_{i-1},  j = i+1, \\\\\n- x_{i-1},  j = i-2, \\\\\n-1,  j = i, \\\\\n0,  \\text{其他情况},\n\\end{cases}\n$$\n采用循环索引。\n\n定义非线性流映射 $\\mathcal{M}_T : \\mathbb{R}^K \\to \\mathbb{R}^K$，该映射将初始条件 $\\mathbf{x}_0$ 映射到通过对 Lorenz $96$ 系统进行数值积分在时间 $T > 0$ 得到的状态。定义切线性模型 (Tangent Linear Model, TLM) 为线性时变系统：\n$$\n\\frac{d \\mathbf{z}}{d t} = \\mathbf{J}(\\mathbf{x}(t)) \\, \\mathbf{z},\n$$\n其中 $\\mathbf{x}(t)$ 是从 $\\mathbf{x}_0$ 开始的非线性轨迹，而 $\\mathbf{z}(t)$ 从初始扰动 $\\mathbf{z}(0) = \\mathbf{p}_0$ 演化而来。在时间 $T$ 的 TLM 解记为 $\\mathbf{z}(T)$，它近似了沿非线性轨迹的小扰动的演化。\n\n你必须构建一个数值测试，通过在不同振幅缩放情况下比较非线性扰动差异与 TLM 预测，来验证一个已编码的 TLM。具体而言，对于给定的振幅集合 $\\alpha \\in \\mathcal{A}$，定义在时间 $T$ 的非线性扰动差异为：\n$$\n\\delta_{\\text{nl}}(\\alpha) = \\mathcal{M}_T\\big(\\mathbf{x}_0 + \\alpha \\mathbf{p}_0\\big) - \\mathcal{M}_T(\\mathbf{x}_0).\n$$\n对于振幅 $\\alpha$ 的 TLM 预测为：\n$$\n\\delta_{\\text{tl}}(\\alpha) = \\alpha \\, \\mathbf{z}(T),\n$$\n其中 $\\mathbf{z}(T)$ 是通过沿基准轨迹 $\\mathbf{x}(t)$ 从 $\\mathbf{z}(0) = \\mathbf{p}_0$ 开始积分 TLM 计算得到的。\n\n你的程序必须：\n- 实现 Lorenz $96$ 模型及其雅可比矩阵。\n- 使用具有固定时间步长 $\\Delta t$ 的四阶 Runge–Kutta 方法对非线性系统和 TLM 进行积分。\n- 对于每个测试用例，使用固定的随机种子生成一个基准状态 $\\mathbf{x}_0$ 和一个初始扰动方向 $\\mathbf{p}_0$，将 $\\mathbf{p}_0$ 归一化以满足 $\\lVert \\mathbf{p}_0 \\rVert_2 = 1$，沿基准轨迹计算 $\\mathbf{z}(T)$，然后为所有 $\\alpha \\in \\mathcal{A}$ 计算非线性差异 $\\delta_{\\text{nl}}(\\alpha)$。\n- 对于每个测试用例，计算在整个振幅集合上的最大相对差异：\n$$\nE_{\\max} = \\max_{\\alpha \\in \\mathcal{A}} \\frac{\\left\\lVert \\delta_{\\text{nl}}(\\alpha) - \\delta_{\\text{tl}}(\\alpha) \\right\\rVert_2}{\\left\\lVert \\delta_{\\text{tl}}(\\alpha) \\right\\rVert_2}.\n$$\n\n所有变量都是无量纲的；不涉及物理单位。\n\n测试套件和参数：\n- 案例 1 (正常路径)：$K = 10$，$F = 8$，$T = 1.0$，$\\Delta t = 0.01$，$\\mathcal{A} = \\{10^{-6}, 5 \\cdot 10^{-6}, 10^{-5}\\}$，随机种子 $0$。\n- 案例 2 (更长的时间窗口)：$K = 10$，$F = 8$，$T = 5.0$，$\\Delta t = 0.01$，$\\mathcal{A} = \\{10^{-6}, 5 \\cdot 10^{-6}, 10^{-5}\\}$，随机种子 $1$。\n- 案例 3 (大振幅，线性近似失效检验)：$K = 10$，$F = 8$，$T = 1.0$，$\\Delta t = 0.01$，$\\mathcal{A} = \\{10^{-3}, 5 \\cdot 10^{-3}, 10^{-2}\\}$，随机种子 $2$。\n- 案例 4 (边缘情况：小维度和微小振幅)：$K = 5$，$F = 8$，$T = 1.0$，$\\Delta t = 0.01$，$\\mathcal{A} = \\{10^{-8}, 5 \\cdot 10^{-8}, 10^{-7}\\}$，随机种子 $3$。\n\n基准和扰动生成：\n- 对于每个测试用例，通过采样独立的标准正态分量来抽取 $\\mathbf{x}_0$，并设置 $\\mathbf{x}_0 = F \\cdot \\mathbf{1} + 0.01 \\, \\boldsymbol{\\eta}$，其中 $\\boldsymbol{\\eta}$ 是标准正态向量，$\\mathbf{1}$ 是全一向量。\n- 将 $\\mathbf{p}_0$ 抽取为一个独立的标准正态向量，然后归一化为单位欧几里得范数。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个条目，并按上述顺序列出。每个条目必须是该案例的 $E_{\\max}$ 的浮点值。例如，输出格式必须为：\n$$\n[\\text{E}_{\\max}^{(1)},\\text{E}_{\\max}^{(2)},\\text{E}_{\\max}^{(3)},\\text{E}_{\\max}^{(4)}].\n$$",
            "solution": "用户提供了一个问题，要求为 Lorenz $96$ 动力系统实现并验证一个切线性模型 (TLM)。\n\n### 第 1 步：问题验证\n\n首先，我将提取给定信息并验证问题陈述。\n\n#### 提取的已知条件：\n1.  **Lorenz 96 模型**：\n    $$\n    \\frac{d x_i}{d t} = \\left(x_{i+1} - x_{i-2}\\right) x_{i-1} - x_i + F, \\quad i = 1, \\dots, K\n    $$\n    采用循环索引（$x_0 \\equiv x_K$ 等）和常数强迫项 $F$。\n\n2.  **雅可比矩阵 $\\mathbf{J}(\\mathbf{x})$**：\n    $$\n    J_{ij} = \\frac{\\partial}{\\partial x_j}\\left(\\frac{dx_i}{dt}\\right) = \n    \\begin{cases}\n    x_{i+1} - x_{i-2},  j = i-1, \\\\\n    x_{i-1},  j = i+1, \\\\\n    - x_{i-1},  j = i-2, \\\\\n    -1,  j = i, \\\\\n    0,  \\text{其他情况},\n    \\end{cases}\n    $$\n    采用循环索引。\n\n3.  **流映射和切线性模型 (TLM)**：\n    -   非线性流映射：$\\mathcal{M}_T: \\mathbb{R}^K \\to \\mathbb{R}^K$，将 $\\mathbf{x}_0$ 演化到 $\\mathbf{x}(T)$。\n    -   TLM 方程：$\\frac{d \\mathbf{z}}{d t} = \\mathbf{J}(\\mathbf{x}(t)) \\, \\mathbf{z}$，其中 $\\mathbf{x}(t)$ 是从 $\\mathbf{x}_0$ 开始的基准轨迹。$\\mathbf{z}(T)$ 是从初始扰动 $\\mathbf{z}(0) = \\mathbf{p}_0$ 在时间 $T$ 的解。\n\n4.  **验证量**：\n    -   非线性扰动差异：$\\delta_{\\text{nl}}(\\alpha) = \\mathcal{M}_T\\big(\\mathbf{x}_0 + \\alpha \\mathbf{p}_0\\big) - \\mathcal{M}_T(\\mathbf{x}_0)$。\n    -   TLM 预测：$\\delta_{\\text{tl}}(\\alpha) = \\alpha \\, \\mathbf{z}(T)$。\n    -   最大相对差异：$E_{\\max} = \\max_{\\alpha \\in \\mathcal{A}} \\frac{\\left\\lVert \\delta_{\\text{nl}}(\\alpha) - \\delta_{\\text{tl}}(\\alpha) \\right\\rVert_2}{\\left\\lVert \\delta_{\\text{tl}}(\\alpha) \\right\\rVert_2}$。\n\n5.  **数值方法**：\n    -   积分器：四阶 Runge-Kutta (RK4)。\n    -   时间步长：$\\Delta t$。\n\n6.  **初始条件生成**：\n    -   每个测试用例使用固定的随机种子。\n    -   基准状态：$\\mathbf{x}_0 = F \\cdot \\mathbf{1} + 0.01 \\, \\boldsymbol{\\eta}$，其中 $\\boldsymbol{\\eta} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{I})$。\n    -   初始扰动：从 $\\mathcal{N}(\\mathbf{0}, \\mathbf{I})$ 中抽取 $\\mathbf{p}_0$，然后归一化使其满足 $\\lVert \\mathbf{p}_0 \\rVert_2 = 1$。\n\n7.  **测试用例**：\n    -   案例 1：$K = 10$，$F = 8$，$T = 1.0$，$\\Delta t = 0.01$，$\\mathcal{A} = \\{10^{-6}, 5 \\cdot 10^{-6}, 10^{-5}\\}$，种子 $0$。\n    -   案例 2：$K = 10$，$F = 8$，$T = 5.0$，$\\Delta t = 0.01$，$\\mathcal{A} = \\{10^{-6}, 5 \\cdot 10^{-6}, 10^{-5}\\}$，种子 $1$。\n    -   案例 3：$K = 10$，$F = 8$，$T = 1.0$，$\\Delta t = 0.01$，$\\mathcal{A} = \\{10^{-3}, 5 \\cdot 10^{-3}, 10^{-2}\\}$，种子 $2$。\n    -   案例 4：$K = 5$，$F = 8$，$T = 1.0$，$\\Delta t = 0.01$，$\\mathcal{A} = \\{10^{-8}, 5 \\cdot 10^{-8}, 10^{-7}\\}$，种子 $3$。\n\n8.  **输出格式**：单行输出，包含一个用方括号括起来的逗号分隔的 $E_{\\max}$ 值列表，每个用例一个：$[\\text{E}_{\\max}^{(1)},\\text{E}_{\\max}^{(2)},\\text{E}_{\\max}^{(3)},\\text{E}_{\\max}^{(4)}]$。\n\n#### 结论：\n该问题是**有效的**。\n-   它**具有科学依据**：Lorenz $96$ 系统、其雅可比矩阵、切线性模型的概念以及 RK4 积分方案都是动力系统数值模拟领域的标准和成熟方法。验证测试本身，即比较非线性模型中小幅度有限扰动的演化与线性化模型的预测，是验证 TLM 实现的基本技术。预期的结果是差异应为 $\\alpha$ 的量级，该测试正是衡量这一点。\n-   它是**适定的**：所有必要的参数、初始条件和数值方法都已指定，确保可以计算出唯一的数值解。给定随机种子，该过程是确定性的。\n-   它是**客观的**：问题以精确的数学和算法术语陈述，没有歧义或主观解释。\n-   该问题没有表现出任何无效性标志。它是在指定领域内一个定义明确的计算任务。\n\n### 第 2 步：解决方案设计\n\n解决方案的核心是为非线性 Lorenz $96$ 模型及其相关的切线性模型实现数值积分。\n\n#### 算法：\n\n1.  **实现 Lorenz 96 系统**：\n    一个函数 `lorenz96_rhs(x, F)` 将计算 Lorenz $96$ 方程的右侧（时间导数）。这可以使用 `numpy.roll` 高效实现循环边界条件。对于大小为 $K$ 的状态向量 `x`，导数计算如下：\n    `dxdt = (np.roll(x, -1) - np.roll(x, 2)) * np.roll(x, 1) - x + F`。\n\n2.  **实现雅可比矩阵**：\n    一个函数 `lorenz96_jacobian(x)` 将构建 $K \\times K$ 的雅可比矩阵 $\\mathbf{J}(\\mathbf{x})$。该矩阵是稀疏的，有四个非零对角线（包括主对角线），并带有循环包裹。对于给定的状态 `x`，将根据提供的公式填充矩阵元素。\n\n3.  **实现积分器**：\n    将实现一个通用的四阶 Runge-Kutta 步进函数 `rk4_step(rhs_func, y, dt, *args)`。此函数将使用由 `rhs_func` 定义的动力学将状态向量 `y` 向前推进一个时间步长 `dt`。\n\n4.  **对耦合系统进行积分**：\n    为了精确地积分依赖于每个时刻非线性轨迹状态的 TLM，我们积分一个大小为 $2K$ 的组合状态向量 $\\mathbf{y} = [\\mathbf{x}, \\mathbf{z}]^T$。这个增广系统的右侧是：\n    $$\n    \\frac{d\\mathbf{y}}{dt} = \\begin{bmatrix} d\\mathbf{x}/dt \\\\ d\\mathbf{z}/dt \\end{bmatrix} = \\begin{bmatrix} \\text{lorenz96\\_rhs}(\\mathbf{x}, F) \\\\ \\mathbf{J}(\\mathbf{x})\\mathbf{z} \\end{bmatrix}\n    $$\n    为此目的将创建一个 `augmented_rhs` 函数。从初始状态 $\\mathbf{y}_0 = [\\mathbf{x}_0, \\mathbf{p}_0]^T$ 开始积分该系统，持续时间 $T$，得到最终状态 $[\\mathbf{x}(T), \\mathbf{z}(T)]^T$。分量 $\\mathbf{x}(T)$ 是参考最终状态 $\\mathcal{M}_T(\\mathbf{x}_0)$，而 $\\mathbf{z}(T)$ 是演化后的初始扰动。\n\n5.  **计算差异**：\n    对于每个测试用例：\n    a.  设置参数（$K, F, T, \\Delta t, \\mathcal{A}$, 种子）。\n    b.  按规定生成初始条件 $\\mathbf{x}_0$ 和 $\\mathbf{p}_0$。\n    c.  从 $[\\mathbf{x}_0, \\mathbf{p}_0]^T$ 开始积分增广系统，以获得参考最终状态 $\\mathbf{x}_{\\text{ref}}(T) = \\mathcal{M}_T(\\mathbf{x}_0)$ 和演化后的扰动 $\\mathbf{z}(T)$。\n    d.  对于每个振幅 $\\alpha \\in \\mathcal{A}$：\n        i.   计算 TLM 预测：$\\delta_{\\text{tl}}(\\alpha) = \\alpha \\, \\mathbf{z}(T)$。\n        ii.  创建扰动后的初始条件 $\\mathbf{x}_0^{\\text{pert}} = \\mathbf{x}_0 + \\alpha \\mathbf{p}_0$。\n        iii. 从 $\\mathbf{x}_0^{\\text{pert}}$ 开始对*非线性* Lorenz $96$ 系统积分，持续时间 $T$，得到 $\\mathbf{x}_{\\text{pert}}(T) = \\mathcal{M}_T(\\mathbf{x}_0^{\\text{pert}})$。\n        iv.  计算非线性差异：$\\delta_{\\text{nl}}(\\alpha) = \\mathbf{x}_{\\text{pert}}(T) - \\mathbf{x}_{\\text{ref}}(T)$。\n        v.   计算相对差异：$\\frac{\\left\\lVert \\delta_{\\text{nl}}(\\alpha) - \\delta_{\\text{tl}}(\\alpha) \\right\\rVert_2}{\\left\\lVert \\delta_{\\text{tl}}(\\alpha) \\right\\rVert_2}$。\n    e.  该测试用例的结果 $E_{\\max}$ 是这些差异在所有 $\\alpha$ 上的最大值。\n\n6.  **最终输出**：\n    将所有测试用例的 $E_{\\max}$ 值收集到一个列表中，并以指定格式打印。积分步数将计算为 `int(round(T / dt))`，以处理潜在的浮点不精确性。",
            "answer": "```python\nimport numpy as np\n\ndef lorenz96_rhs(x, F):\n    \"\"\"Computes the right-hand side of the Lorenz 96 system.\"\"\"\n    K = len(x)\n    dxdt = np.zeros(K)\n    \n    # Vectorized computation using np.roll for cyclic boundary conditions\n    x_p1 = np.roll(x, -1)  # x_{i+1}\n    x_m1 = np.roll(x, 1)   # x_{i-1}\n    x_m2 = np.roll(x, 2)   # x_{i-2}\n    \n    dxdt = (x_p1 - x_m2) * x_m1 - x + F\n    return dxdt\n\ndef lorenz96_jacobian(x):\n    \"\"\"Computes the Jacobian matrix of the Lorenz 96 system.\"\"\"\n    K = len(x)\n    J = np.zeros((K, K))\n    \n    x_p1 = np.roll(x, -1) # x_{i+1} at index i\n    x_m1 = np.roll(x, 1)  # x_{i-1} at index i\n    x_m2 = np.roll(x, 2)  # x_{i-2} at index i\n\n    # Populate the Jacobian matrix row by row\n    # This explicit loop is clear and efficient enough for K values used.\n    for i in range(K):\n        # j = i\n        J[i, i] = -1.0\n        # j = i+1\n        J[i, (i + 1) % K] = x_m1[i]\n        # j = i-1\n        J[i, (i - 1 + K) % K] = x_p1[i] - x_m2[i]\n        # j = i-2\n        J[i, (i - 2 + K) % K] = -x_m1[i]\n        \n    return J\n\ndef rk4_step(rhs_func, y, dt, *args):\n    \"\"\"Performs a single fourth-order Runge-Kutta step.\"\"\"\n    k1 = rhs_func(y, *args)\n    k2 = rhs_func(y + dt / 2.0 * k1, *args)\n    k3 = rhs_func(y + dt / 2.0 * k2, *args)\n    k4 = rhs_func(y + dt * k3, *args)\n    return y + dt / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\ndef solve():\n    \"\"\"\n    Main solver function to run the test suite and compute maximum relative discrepancies.\n    \"\"\"\n    test_cases = [\n        # Case 1: happy path\n        {'K': 10, 'F': 8.0, 'T': 1.0, 'dt': 0.01, 'A': [1e-6, 5e-6, 1e-5], 'seed': 0},\n        # Case 2: longer window\n        {'K': 10, 'F': 8.0, 'T': 5.0, 'dt': 0.01, 'A': [1e-6, 5e-6, 1e-5], 'seed': 1},\n        # Case 3: large amplitudes, breakdown check\n        {'K': 10, 'F': 8.0, 'T': 1.0, 'dt': 0.01, 'A': [1e-3, 5e-3, 1e-2], 'seed': 2},\n        # Case 4: edge case with small dimension and tiny amplitudes\n        {'K': 5, 'F': 8.0, 'T': 1.0, 'dt': 0.01, 'A': [1e-8, 5e-8, 1e-7], 'seed': 3},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        K, F, T, dt, A, seed = case['K'], case['F'], case['T'], case['dt'], case['A'], case['seed']\n        \n        # --- Setup Initial Conditions ---\n        rng = np.random.default_rng(seed)\n        eta = rng.standard_normal(K)\n        x0 = F * np.ones(K) + 0.01 * eta\n        \n        p0 = rng.standard_normal(K)\n        p0 /= np.linalg.norm(p0)\n        \n        num_steps = int(round(T / dt))\n\n        # --- Define RHS for augmented (Nonlinear + TLM) system ---\n        def augmented_rhs(y, F_val):\n            K_val = len(y) // 2\n            x = y[:K_val]\n            z = y[K_val:]\n            \n            dxdt = lorenz96_rhs(x, F_val)\n            J = lorenz96_jacobian(x)\n            dzdt = J @ z\n            \n            return np.concatenate([dxdt, dzdt])\n\n        # --- Integrate to find reference trajectory and z(T) ---\n        y_augmented = np.concatenate([x0, p0])\n        for _ in range(num_steps):\n            y_augmented = rk4_step(augmented_rhs, y_augmented, dt, F)\n            \n        x_T_ref = y_augmented[:K]\n        z_T = y_augmented[K:]\n\n        # --- Compute TLM vs Nonlinear Discrepancy ---\n        discrepancies = []\n        for alpha in A:\n            # TLM prediction\n            delta_tl = alpha * z_T\n            \n            # Full nonlinear integration of perturbed state\n            x0_pert = x0 + alpha * p0\n            x_pert_current = x0_pert\n            for _ in range(num_steps):\n                x_pert_current = rk4_step(lorenz96_rhs, x_pert_current, dt, F)\n            x_T_pert = x_pert_current\n            \n            # Nonlinear difference\n            delta_nl = x_T_pert - x_T_ref\n            \n            # Relative discrepancy\n            norm_tl = np.linalg.norm(delta_tl)\n            if norm_tl > 0:\n                discrepancy = np.linalg.norm(delta_nl - delta_tl) / norm_tl\n                discrepancies.append(discrepancy)\n        \n        E_max = max(discrepancies) if discrepancies else 0.0\n        results.append(E_max)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一旦我们拥有了可靠的切线性模型，我们就可以计算奇异向量（Singular Vectors, SVs）来识别最大误差增长的方向。这个动手实践将您从抽象理论带入一个具体的物理系统——一个简化的湿热力学大气模型。通过计算领先奇异向量，您将直接观察其结构和增长率如何受到大气饱和等关键物理过程的影响，从而将数学工具与现实世界现象联系起来 。",
            "id": "4018774",
            "problem": "考虑一个围绕固定基态线性化的简化单柱湿热力学模型。扰动状态向量定义为 $\\mathbf{x}(t) = [T'(t),\\, q'(t)]^\\top$，其中 $T'$ 是温度扰动，$q'$ 是比湿扰动。线性化趋势被建模为时不变线性常微分方程\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\,\\mathbf{x},\n$$\n其中\n$$\n\\mathbf{A} = \\begin{bmatrix}\n-a  \\lambda \\\\\n-\\mu  -b\n\\end{bmatrix}.\n$$\n参数 $a$ 和 $b$（单位均为 $\\mathrm{hr}^{-1}$）表示由辐射冷却和湿弛豫等过程产生的线性阻尼率，参数 $\\lambda$ 和 $\\mu$（单位均为 $\\mathrm{hr}^{-1}$）捕捉了线性化湿耦合：当 $q'$ 为正时，凝结产生的潜热使气柱增温（由 $\\lambda > 0$ 建模）；当 $T'$ 较高时，饱和水汽压增加，在饱和条件下导致 $q'$ 减小（由 $\\mu > 0$ 建模）。在非饱和基态中，对于小扰动，$\\lambda$ 和 $\\mu$ 都可以理想化为零。对于有限时间范围 $\\tau$（单位为小时），线性传播算子为\n$$\n\\mathbf{M}(\\tau) = \\exp(\\mathbf{A}\\,\\tau),\n$$\n因此 $\\mathbf{x}(\\tau) = \\mathbf{M}(\\tau)\\,\\mathbf{x}(0)$。\n\n为了量化扰动的增长和方向，使用由对称正定矩阵 $\\mathbf{W} = \\mathrm{diag}(c_T, c_q)$ 定义的加权能量范数，其中 $c_T > 0$ 且 $c_q > 0$。其诱导范数为 $\\|\\mathbf{x}\\|_{\\mathbf{W}} = \\|\\mathbf{W}^{1/2}\\mathbf{x}\\|_2$。主奇异向量（在时间 $\\tau$ 内使范数增长最大化的初始扰动方向）定义为以下表达式的最大化者：\n$$\n\\max_{\\mathbf{x}(0) \\neq \\mathbf{0}} \\frac{\\|\\mathbf{W}^{1/2}\\,\\mathbf{M}(\\tau)\\,\\mathbf{x}(0)\\|_2}{\\|\\mathbf{W}^{1/2}\\,\\mathbf{x}(0)\\|_2}.\n$$\n等价地，令 $\\widetilde{\\mathbf{M}} = \\mathbf{W}^{1/2}\\,\\mathbf{M}(\\tau)\\,\\mathbf{W}^{-1/2}$，$\\widetilde{\\mathbf{M}}$ 的主右奇异向量决定了加权空间中的最优初始方向；映射回物理空间可得到主奇异向量 $\\mathbf{v}_0 = \\mathbf{W}^{-1/2}\\,\\mathbf{v}$，其中 $\\mathbf{v}$ 是 $\\widetilde{\\mathbf{M}}$ 的主右奇异向量。\n\n将主奇异向量 $\\mathbf{v}_0 = [v_T, v_q]^\\top$ 相对于温度轴的方向角 $\\theta$（单位为度）定义为 $\\mathbf{v}_0$ 与单位向量 $\\mathbf{e}_T = [1, 0]^\\top$ 之间的无符号角：\n$$\n\\theta = \\arccos\\left(\\frac{|v_T|}{\\sqrt{v_T^2 + v_q^2}}\\right)\\cdot \\frac{180}{\\pi}.\n$$\n该定义确保 $\\theta \\in [0, 90]$ 度。将有限时间增长因子 $\\sigma_1$ 定义为 $\\widetilde{\\mathbf{M}}$ 的最大奇异值，相应的增长率 $g$（单位为 $\\mathrm{hr}^{-1}$）定义为\n$$\ng = \\frac{1}{\\tau}\\,\\ln(\\sigma_1).\n$$\n\n你的任务是编写一个程序，针对下面列出的参数集，计算主奇异向量的方向角 $\\theta$（单位为度）和增长率 $g$（单位为 $\\mathrm{hr}^{-1}$）。使用矩阵指数计算 $\\mathbf{M}(\\tau)$。对于每种情况，权重矩阵为 $\\mathbf{W} = \\mathrm{diag}(1, w_q)$，其中 $w_q$ 为指定值。报告 $\\theta$（四舍五入到三位小数，单位为度）和 $g$（四舍五入到六位小数，单位为 $\\mathrm{hr}^{-1}$）。\n\n测试套件（每种情况分别为 $(a, b, \\lambda, \\mu, \\tau, w_q)$，单位依次为 $\\mathrm{hr}^{-1}$、$\\mathrm{hr}^{-1}$、$\\mathrm{hr}^{-1}$、$\\mathrm{hr}^{-1}$、$\\mathrm{hr}$ 和无量纲）：\n- 情况 1（非饱和基态，理想情况）：$(0.1, 0.2, 0.0, 0.0, 6.0, 1.0)$。\n- 情况 2（饱和基态，中等耦合）：$(0.1, 1.5, 0.8, 0.6, 6.0, 1.0)$。\n- 情况 3（饱和基态，强耦合）：$(0.1, 1.5, 1.2, 1.0, 6.0, 1.0)$。\n- 情况 4（非饱和基态，弱阻尼和更长时间范围）：$(0.05, 0.06, 0.0, 0.0, 12.0, 1.0)$。\n- 情况 5（饱和基态，湿气主导度量的中等耦合）：$(0.1, 1.5, 0.8, 0.6, 6.0, 9.0)$。\n\n要求：\n- 所有速率 $a$、$b$、$\\lambda$、$\\mu$ 的单位必须解释为 $\\mathrm{hr}^{-1}$，时间范围 $\\tau$ 的单位为 $\\mathrm{hr}$，输出增长率 $g$ 的单位为 $\\mathrm{hr}^{-1}$。角度必须以度为单位。\n- 通过矩阵指数计算 $\\mathbf{M}(\\tau) = \\exp(\\mathbf{A}\\,\\tau)$，并通过在加权空间中进行奇异值分解来获得 $\\sigma_1$ 和 $\\mathbf{v}_0$。\n- 对于每种情况，输出配对 $[\\theta, g]$，并按指定要求进行四舍五入。\n- 最终输出格式：你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的每个元素是对应各情况的双元素列表，顺序与给定顺序一致。例如：$[[\\theta_1, g_1],[\\theta_2, g_2],\\dots]$。",
            "solution": "该问题被评估为有效。它在科学上基于大气动力学和可预报性理论的原理，问题设定良好，具有完整且一致的定义和参数集，并以客观、正式的语言表达。通过标准的矩阵分析可以推导出一个唯一且有意义的解。\n\n任务是计算一个简化的湿热力学模型的主奇异向量的方向角 $\\theta$ 和增长率 $g$。该过程包括构建系统矩阵，随时间向前传播系统，以及在加权范数下执行奇异值分解。对每组指定的参数重复此过程。\n\n系统的状态由扰动向量 $\\mathbf{x}(t) = [T'(t), q'(t)]^\\top$ 描述，其中 $T'$ 是温度扰动，$q'$ 是比湿扰动。其演化由线性常微分方程控制：\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\,\\mathbf{x}\n$$\n系统矩阵 $\\mathbf{A}$ 由下式给出：\n$$\n\\mathbf{A} = \\begin{bmatrix}\n-a  \\lambda \\\\\n-\\mu  -b\n\\end{bmatrix}\n$$\n其中参数 $a$、 $b$、 $\\lambda$ 和 $\\mu$ 针对每种情况提供。所有速率的单位均为 $\\mathrm{hr}^{-1}$。\n\n经过时间间隔 $\\tau$（单位为小时）后，$\\mathbf{x}(t)$ 的解可通过线性传播算子矩阵 $\\mathbf{M}(\\tau)$ 求得，该矩阵是 $\\mathbf{A}\\tau$ 的矩阵指数：\n$$\n\\mathbf{x}(\\tau) = \\mathbf{M}(\\tau)\\,\\mathbf{x}(0) \\quad \\text{其中} \\quad \\mathbf{M}(\\tau) = \\exp(\\mathbf{A}\\,\\tau)\n$$\n\n我们感兴趣的是在时间间隔 $\\tau$ 内经历最大增长的初始扰动 $\\mathbf{x}(0)$，该增长以加权能量范数衡量。该范数由对称正定矩阵 $\\mathbf{W} = \\mathrm{diag}(1, w_q)$ 定义：\n$$\n\\|\\mathbf{x}\\|_{\\mathbf{W}} = \\sqrt{\\mathbf{x}^\\top \\mathbf{W} \\mathbf{x}} = \\|\\mathbf{W}^{1/2}\\mathbf{x}\\|_2\n$$\n初始扰动 $\\mathbf{x}(0)$ 的增长因子是最终范数与初始范数之比：\n$$\n\\frac{\\|\\mathbf{x}(\\tau)\\|_{\\mathbf{W}}}{\\|\\mathbf{x}(0)\\|_{\\mathbf{W}}} = \\frac{\\|\\mathbf{W}^{1/2}\\,\\mathbf{M}(\\tau)\\,\\mathbf{x}(0)\\|_2}{\\|\\mathbf{W}^{1/2}\\,\\mathbf{x}(0)\\|_2}\n$$\n为简化此表达式，我们定义一个变换后的初始状态 $\\mathbf{y}(0) = \\mathbf{W}^{1/2}\\,\\mathbf{x}(0)$，这意味着 $\\mathbf{x}(0) = \\mathbf{W}^{-1/2}\\,\\mathbf{y}(0)$。将此代入增长因子表达式可得：\n$$\n\\frac{\\|\\mathbf{W}^{1/2}\\,\\mathbf{M}(\\tau)\\,\\mathbf{W}^{-1/2}\\,\\mathbf{y}(0)\\|_2}{\\|\\mathbf{y}(0)\\|_2} = \\frac{\\|\\widetilde{\\mathbf{M}}\\,\\mathbf{y}(0)\\|_2}{\\|\\mathbf{y}(0)\\|_2}\n$$\n其中 $\\widetilde{\\mathbf{M}} = \\mathbf{W}^{1/2}\\,\\mathbf{M}(\\tau)\\,\\mathbf{W}^{-1/2}$ 是加权坐标系中的传播算子。\n\n根据定义，该比率的最大值是 $\\widetilde{\\mathbf{M}}$ 的最大奇异值，记为 $\\sigma_1$。实现此最大值的初始扰动 $\\mathbf{y}(0)$ 是 $\\widetilde{\\mathbf{M}}$ 相应的主右奇异向量，我们将其记为 $\\mathbf{v}$。\n\n每个测试用例的算法如下：\n\n1.  **构建矩阵**：给定参数 $(a, b, \\lambda, \\mu, \\tau, w_q)$，构建矩阵 $\\mathbf{A}$。权重矩阵为 $\\mathbf{W} = \\mathrm{diag}(1, w_q)$。其平方根和平方根倒数分别为 $\\mathbf{W}^{1/2} = \\mathrm{diag}(1, \\sqrt{w_q})$ 和 $\\mathbf{W}^{-1/2} = \\mathrm{diag}(1, 1/\\sqrt{w_q})$。\n\n2.  **计算传播算子**：使用数值矩阵指数函数计算传播算子矩阵 $\\mathbf{M}(\\tau) = \\exp(\\mathbf{A}\\,\\tau)$。\n\n3.  **变换传播算子**：计算加权传播算子 $\\widetilde{\\mathbf{M}} = \\mathbf{W}^{1/2}\\,\\mathbf{M}(\\tau)\\,\\mathbf{W}^{-1/2}$。\n\n4.  **奇异值分解 (SVD)**：对 $\\widetilde{\\mathbf{M}}$ 执行 SVD，以找到其最大奇异值 $\\sigma_1$ 和相应的右奇异向量 $\\mathbf{v}$。SVD 由 $\\widetilde{\\mathbf{M}} = \\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$ 给出。值 $\\sigma_1$ 是 $\\mathbf{\\Sigma}$ 对角线上的第一个条目，$\\mathbf{v}$ 是矩阵 $\\mathbf{V}$ 的第一列。\n\n5.  **计算增长率 ($g$)**：有限时间增长率 $g$ 从 $\\sigma_1$ 和 $\\tau$ 推导得出：\n    $$\n    g = \\frac{1}{\\tau}\\,\\ln(\\sigma_1)\n    $$\n    结果以 $\\mathrm{hr}^{-1}$ 为单位，并四舍五入到六位小数。\n\n6.  **寻找物理奇异向量 ($\\mathbf{v}_0$)**：物理空间中的最优初始扰动 $\\mathbf{v}_0 = [v_T, v_q]^\\top$ 是通过将 $\\mathbf{v}$ 从加权空间变换回来得到的：\n    $$\n    \\mathbf{v}_0 = \\mathbf{W}^{-1/2}\\,\\mathbf{v}\n    $$\n\n7.  **计算方向角 ($\\theta$)**：$\\mathbf{v}_0$ 相对于温度轴的方向角 $\\theta$ 是无符号角，确保 $\\theta \\in [0, 90]$ 度：\n    $$\n    \\theta = \\arccos\\left(\\frac{|v_T|}{\\|\\mathbf{v}_0\\|_2}\\right) \\cdot \\frac{180}{\\pi} = \\arccos\\left(\\frac{|v_T|}{\\sqrt{v_T^2 + v_q^2}}\\right) \\cdot \\frac{180}{\\pi}\n    $$\n    结果以度为单位，并四舍五入到三位小数。\n\n将此过程系统地应用于所提供的五个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the leading singular vector orientation and growth rate for a\n    linearized moist thermodynamic model for several parameter sets.\n    \"\"\"\n    # Test suite: each tuple is (a, b, lambda, mu, tau, w_q)\n    # The parameters from the problem statement use commas for decimals, which are\n    # interpreted as dots for standard float representation.\n    test_cases = [\n        # Case 1 (unsaturated base, happy path)\n        (0.1, 0.2, 0.0, 0.0, 6.0, 1.0),\n        # Case 2 (saturated base, moderate coupling)\n        (0.1, 1.5, 0.8, 0.6, 6.0, 1.0),\n        # Case 3 (saturated base, strong coupling)\n        (0.1, 1.5, 1.2, 1.0, 6.0, 1.0),\n        # Case 4 (unsaturated base, weak damping and longer horizon)\n        (0.05, 0.06, 0.0, 0.0, 12.0, 1.0),\n        # Case 5 (saturated base, moderate coupling with moisture-dominant metric)\n        (0.1, 1.5, 0.8, 0.6, 6.0, 9.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, b, lam, mu, tau, w_q = case\n        \n        # Step 1: Construct the system matrix A\n        A = np.array([\n            [-a, lam],\n            [-mu, -b]\n        ])\n\n        # Step 2: Compute the propagator M(tau)\n        M_tau = expm(A * tau)\n\n        # Step 3: Construct weight matrices and transform the propagator\n        # W = diag(1, w_q)\n        # W_sqrt = diag(1, sqrt(w_q))\n        # W_inv_sqrt = diag(1, 1/sqrt(w_q))\n        sqrt_w_q = np.sqrt(w_q)\n        W_sqrt = np.diag([1.0, sqrt_w_q])\n        W_inv_sqrt = np.diag([1.0, 1.0 / sqrt_w_q])\n        \n        # M_tilde = W_sqrt * M_tau * W_inv_sqrt\n        M_tilde = W_sqrt @ M_tau @ W_inv_sqrt\n\n        # Step 4: Perform Singular Value Decomposition (SVD) of M_tilde\n        # U, s, Vh = svd(M_tilde), where Vh is V.T\n        _, s, Vh = np.linalg.svd(M_tilde)\n        \n        # The largest singular value is the first element of s\n        sigma_1 = s[0]\n        \n        # The leading right singular vector is the first column of V (or first row of Vh)\n        v = Vh[0, :]\n\n        # Step 5: Calculate the growth rate g\n        g = np.log(sigma_1) / tau\n\n        # Step 6: Find the physical singular vector v0\n        # v0 = W_inv_sqrt * v\n        v0 = W_inv_sqrt @ v\n        vT, vq = v0[0], v0[1]\n\n        # Step 7: Calculate the orientation angle theta\n        norm_v0 = np.linalg.norm(v0)\n        # Handle case where v0 might be a zero vector, though unlikely\n        if norm_v0 == 0:\n            theta = 0.0\n        else:\n            # arccos is in radians, convert to degrees\n            theta = np.arccos(np.abs(vT) / norm_v0) * (180.0 / np.pi)\n\n        # Format results as specified\n        result = [round(theta, 3), round(g, 6)]\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论表明，奇异向量是生成集合扰动的最优选择，但在实践中我们如何证实这一点呢？本练习将指导您设计并实施一个计算实验来回答这个问题。通过使用蒙特卡洛模拟和正式的统计检验，您将严谨地比较基于奇异向量的扰动与随机选择的扰动对预报的影响，从而学习到科学验证中的一项宝贵技能 。",
            "id": "4018795",
            "problem": "考虑一个线性切线模型，它代表了维度为 $n$ 的状态向量的短期预报，定义为 $x(T) = M x(0)$，其中 $M \\in \\mathbb{R}^{n \\times n}$ 是从初始时间 $0$ 到预报验证时间 $T$ 的线性传播算子。设初始条件范数由对称正定矩阵 $V \\succ 0$ 通过 $\\|x\\|_{V} = \\|V^{1/2} x\\|_{2}$ 定义，并设所选的预报度量是由对称正定矩阵 $W \\succ 0$ 通过 $\\|y\\|_{W} = \\|W^{1/2} y\\|_{2}$ 定义的加权范数。扰动 $\\delta x$ 的预报度量振幅为 $A(\\delta x) = \\|W^{1/2} M \\delta x\\|_{2}^{2}$。\n\n奇异向量被定义为在固定的初始范数约束下，使时间 $T$ 的预报度量振幅最大化的初始扰动 $\\delta x$ 的方向。形式上，主奇异向量求解\n$$\n\\max_{\\delta x \\in \\mathbb{R}^{n}} \\|W^{1/2} M \\delta x\\|_{2} \\quad \\text{约束条件为} \\quad \\|V^{1/2} \\delta x\\|_{2} = 1.\n$$\n这可以通过奇异值分解（SVD）计算，其中如果 $A = W^{1/2} M V^{-1/2}$ 的 SVD 为 $A = U \\Sigma Q^{\\top}$，其中 $\\Sigma = \\operatorname{diag}(\\sigma_{1}, \\sigma_{2}, \\dots)$ 且 $Q$ 为正交矩阵，则主右奇异向量 $q_{1}$ 给出主初始条件奇异向量 $\\delta x^{\\ast} = V^{-1/2} q_{1}$，并将其归一化以满足 $\\|V^{1/2} \\delta x^{\\ast}\\|_{2} = 1$。\n\n设计并实现一个实验，以评估相对于随机扰动，奇异向量扰动是否能提高对所选度量的预报敏感性。使用蒙特卡洛设置生成：\n- 一个包含 $N$ 个扰动的随机集合，通过在由初始范数 $\\|\\cdot\\|_{V}$ 导出的单位球面上均匀采样方向，并将每个采样到的扰动归一化以使其满足 $\\|V^{1/2} \\delta x\\|_{2} = 1$。\n- 一个包含 $N$ 个扰动的奇异向量集合，通过在主奇异向量的一个小邻域内采样方向，并将每个扰动重新归一化以使其满足 $\\|V^{1/2} \\delta x\\|_{2} = 1$。具体来说，将每个奇异向量集合成员生成为 $\\delta x_{i}^{\\text{sv}} = \\operatorname{normalize}_{V}(\\delta x^{\\ast} + \\varepsilon \\,\\eta_{i})$，其中 $\\eta_{i}$ 是在 $V$-范数单位球面上均匀抽取的随机方向，$\\varepsilon > 0$ 是一个小的离散参数。\n\n对于每个集合，计算预报度量振幅 $A(\\delta x)$ 的样本，并进行统计检验，以评估奇异向量集合的平均预报度量振幅是否严格大于随机集合的平均预报度量振幅。使用方差不等的 Welch's $t$ 检验，其单侧零假设为 $H_{0}: \\mu_{\\text{sv}} \\le \\mu_{\\text{rand}}$，备择假设为 $H_{1}: \\mu_{\\text{sv}} > \\mu_{\\text{rand}}$，其中 $\\mu_{\\text{sv}}$ 和 $\\mu_{\\text{rand}}$ 分别表示奇异向量集合和随机集合下 $A(\\delta x)$ 的总体均值。报告每个测试用例的布尔结果，如果奇异向量集合下的样本均值超过随机集合下的样本均值，并且单侧 Welch's $t$ 检验的 $p$ 值严格小于预设的显著性水平 $\\alpha$，则结果为真，否则为假。\n\n从以下基本基础和定义开始：\n- 小扰动通过切线模型的线性传播：$x(T) = M x(0)$。\n- 由对称正定矩阵导出的加权范数：$\\|x\\|_{V}^{2} = x^{\\top} V x$ 和 $\\|y\\|_{W}^{2} = y^{\\top} W y$。\n- 通过变换 $A = W^{1/2} M V^{-1/2}$ 计算加权范数下的奇异向量的奇异值分解（SVD）。\n- 用于比较方差不等的均值的 Welch's $t$ 检验。\n\n您的程序必须实现：\n- 通过 Cholesky 分解构造 $V^{1/2}$ 和 $V^{-1/2}$，以及类似地构造 $W^{1/2}$。\n- 通过对 $A = W^{1/2} M V^{-1/2}$ 进行 SVD 来计算主奇异向量。\n- 使用各向同性高斯采样和归一化，在由 $\\|\\cdot\\|_{V}$ 导出的单位球面上均匀生成随机扰动。\n- 通过向主奇异向量添加小的 $V$-各向同性噪声并重新归一化，生成奇异向量集合扰动。\n- 计算预报度量振幅 $A(\\delta x) = \\|W^{1/2} M \\delta x\\|_{2}^{2}$。\n- 在给定的显著性水平 $\\alpha$ 下执行单侧 Welch's $t$ 检验和决策逻辑。\n\n不涉及角度单位；不需要物理单位。\n\n使用以下测试套件。对于每个案例，指定了维度 $n$、传播算子 $M$、初始范数矩阵 $V$、度量矩阵 $W$、集合大小 $N$、奇异向量集合离散度 $\\varepsilon$、显著性水平 $\\alpha$ 和一个伪随机种子。这些选择在科学上是合理的，并测试了该方法的不同方面。\n\n- 案例1（各向异性增长，单位范数，预期改进）：\n  - $n = 2$，$M = \\begin{bmatrix} 1.6  0.1 \\\\ 0.0  0.7 \\end{bmatrix}$，$V = I_{2}$，$W = I_{2}$，$N = 1000$，$\\varepsilon = 0.05$，$\\alpha = 0.05$，种子 $= 123$。\n- 案例2（各向同性增长，单位范数，无预期改进）：\n  - $n = 2$，$M = s R(\\theta)$，其中 $s = 1.2$，$R(\\theta) = \\begin{bmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{bmatrix}$，设 $\\theta = 0.7$ 弧度，$V = I_{2}$，$W = I_{2}$，$N = 1000$，$\\varepsilon = 0.05$，$\\alpha = 0.05$，种子 $= 456$。\n- 案例3（各向异性增长，小样本量，临界显著性）：\n  - $n = 2$，$M = \\begin{bmatrix} 1.4  0.0 \\\\ 0.0  0.6 \\end{bmatrix}$，$V = I_{2}$，$W = I_{2}$，$N = 30$，$\\varepsilon = 0.10$，$\\alpha = 0.05$，种子 $= 789$。\n- 案例4（三维，非平凡的度量权重）：\n  - $n = 3$，$M = \\begin{bmatrix} 1.7  0.2  0.0 \\\\ 0.0  0.9  0.1 \\\\ 0.0  0.0  0.6 \\end{bmatrix}$，$V = \\operatorname{diag}(1.0, 2.0, 0.5)$，$W = \\operatorname{diag}(2.0, 0.5, 3.0)$，$N = 800$，$\\varepsilon = 0.05$，$\\alpha = 0.05$，种子 $= 101112$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），每个结果对应于上面列出的每个测试用例的布尔值。如果奇异向量集合的 $A(\\delta x)$ 样本均值严格大于随机集合的样本均值，并且单侧 Welch's $t$ 检验的 $p$ 值严格小于给定的 $\\alpha$，则结果为真，否则为假。",
            "solution": "该问题要求进行一个计算实验，以验证一个理论前提，即与随机扰动相比，与线性预报模型的主奇异向量对齐的初始扰动会在选定的预报度量中导致更大的放大。这是可预报性研究和集合预报中的一个基石概念，其中识别最快误差增长的方向对于量化预报不确定性至关重要。该实验将通过蒙特卡洛模拟进行，比较两组初始扰动集合，并使用统计假设检验来形式化比较。\n\n解决方案分几个阶段进行：首先，建立加权范数背景下的奇异向量的数学框架；其次，定义生成两个扰动集合的程序；第三，指定评估扰动增长的度量；最后，概述用于比较集合的统计检验。\n\n**1. 数学公式和奇异向量计算**\n\n系统动力学由一个线性切线模型描述，其中初始状态扰动 $\\delta x(0)$ 演变为最终扰动 $\\delta x(T) = M \\delta x(0)$，其中 $M \\in \\mathbb{R}^{n \\times n}$ 是传播算子矩阵。\n\n初始扰动的大小由加权范数 $\\| \\delta x \\|_{V} = ( \\delta x^{\\top} V \\delta x )^{1/2}$ 衡量，其中 $V$ 是一个定义了能量内积的对称正定（$V \\succ 0$）矩阵。类似地，最终扰动的大小由预报度量范数 $\\| \\delta x(T) \\|_{W} = ( \\delta x(T)^{\\top} W \\delta x(T) )^{1/2}$ 衡量，其中 $W \\succ 0$。\n\n目标是找到在单位初始范数约束 $\\|\\delta x\\|_{V} = 1$ 下，使最终时刻振幅 $A(\\delta x) = \\| \\delta x(T) \\|_{W}^{2} = \\| M \\delta x \\|_{W}^{2}$ 最大化的初始扰动 $\\delta x$。这个优化问题是：\n$$\n\\max_{\\delta x \\in \\mathbb{R}^{n}} \\| M \\delta x \\|_{W} \\quad \\text{约束条件为} \\quad \\|\\delta x\\|_{V} = 1\n$$\n这是一个广义奇异值问题。它可以被转换成一个标准的奇异值问题。由于 $V$ 和 $W$ 是对称正定的，它们存在矩阵平方根 $V^{1/2}$ 和 $W^{1/2}$。范数可以用标准的欧几里得 2-范数表示：$\\| \\delta x \\|_{V} = \\|V^{1/2} \\delta x\\|_{2}$ 和 $\\| M \\delta x \\|_{W} = \\|W^{1/2} M \\delta x\\|_{2}$。\n\n让我们引入变量替换：$u = V^{1/2} \\delta x$。那么 $\\delta x = V^{-1/2} u$。约束条件 $\\|\\delta x\\|_{V} = 1$ 变为 $\\|u\\|_{2} = 1$。目标函数变为：\n$$\n\\|W^{1/2} M \\delta x\\|_{2} = \\|W^{1/2} M V^{-1/2} u\\|_{2}\n$$\n定义矩阵 $A = W^{1/2} M V^{-1/2}$，问题就转换为：\n$$\n\\max_{u \\in \\mathbb{R}^{n}} \\| A u \\|_{2} \\quad \\text{约束条件为} \\quad \\|u\\|_{2} = 1\n$$\n这个标准问题的解由 $A$ 的奇异值分解（SVD）给出。设 $A$ 的 SVD 为 $A = U \\Sigma Q^{\\top}$，其中 $U$ 和 $Q$ 是正交矩阵，$\\Sigma$ 是奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge 0$ 的对角矩阵。$\\|Au\\|_2$ 的最大值是最大的奇异值 $\\sigma_1$，当 $u$ 是对应的主右奇异向量 $q_1$（$Q$ 的第一列）时取得。\n\n转换回原始变量 $\\delta x$，最优初始扰动，即主奇异向量，是 $\\delta x^{\\ast} = V^{-1/2} q_1$。产生的最大振幅是 $A(\\delta x^*) = \\|W^{1/2} M \\delta x^*\\|_2^2 = \\| A q_1 \\|_2^2 = \\sigma_1^2$。\n\n在实践中，矩阵平方根及其逆矩阵是使用 Cholesky 分解计算的。如果 $V = L_V L_V^{\\top}$ 是 $V$ 的 Cholesky 分解，那么 $V^{1/2}$ 的一个有效选择是 $L_V^{\\top}$。因此，$V^{-1/2} = (L_V^{\\top})^{-1} = L_V^{-\\top}$。同样的方法适用于 $W$。\n\n**2. 集合生成**\n\n为了检验假设，我们生成两个各含 $N$ 个扰动的集合。\n\n**随机集合：** 扰动必须从由 $V$-范数定义的 $n$ 维球面上的均匀分布中抽取。实现这一目标的标准程序是：\n1. 生成一个向量 $g_i \\in \\mathbb{R}^n$，其分量从标准正态分布中抽取，即 $g_i \\sim \\mathcal{N}(0, I_n)$。\n2. 在欧几里得范数下将 $g_i$ 归一化，得到一个在标准欧几里得单位球面上均匀分布的向量 $u_i = g_i / \\|g_i\\|_2$。\n3. 将 $u_i$ 变换到 $V$-范数单位球面：$\\delta x^{\\text{rand}}_i = V^{-1/2} u_i$。这确保了 $\\|V^{1/2} \\delta x^{\\text{rand}}_i\\|_2 = \\|V^{1/2} V^{-1/2} u_i\\|_2 = \\|u_i\\|_2 = 1$。\n\n**奇异向量集合：** 这个集合旨在采样主奇异向量 $\\delta x^{\\ast}$ 周围一个小邻域内的扰动。每个成员生成如下：\n$$\n\\delta x_{i}^{\\text{sv}} = \\frac{\\delta x^{\\ast} + \\varepsilon \\,\\eta_{i}}{\\|V^{1/2} (\\delta x^{\\ast} + \\varepsilon \\,\\eta_{i})\\|_{2}}\n$$\n其中 $\\delta x^{\\ast}$ 是主奇异向量，$\\varepsilon > 0$ 是一个小的离散参数，$\\eta_i$ 是一个从 $V$-范数单位球面上均匀抽取的随机扰动，使用与随机集合相同的方法生成。分母确保每个成员 $\\delta x_{i}^{\\text{sv}}$ 都被正确归一化，具有单位 $V$-范数。\n\n**3. 统计比较**\n\n对于两个集合中的每个扰动 $\\delta x_i$，我们计算预报度量振幅：\n$$\nA(\\delta x_i) = \\|W^{1/2} M \\delta x_i\\|_{2}^{2}\n$$\n这会产生两组标量值：$\\{A(\\delta x^{\\text{rand}}_i)\\}_{i=1}^N$ 和 $\\{A(\\delta x^{\\text{sv}}_i)\\}_{i=1}^N$。我们想检验奇异向量集合的平均振幅是否显著大于随机集合的平均振幅。设 $\\mu_{\\text{sv}}$ 和 $\\mu_{\\text{rand}}$ 分别为这两个集合振幅的真实总体均值。假设检验公式如下：\n- 零假设 $H_0: \\mu_{\\text{sv}} \\le \\mu_{\\text{rand}}$\n- 备择假设 $H_1: \\mu_{\\text{sv}} > \\mu_{\\text{rand}}$\n\n由于生成方法不保证两个振幅分布之间的方差相等，所以 Welch's $t$ 检验（用于方差不相等的情况）是合适的统计工具。$t$-统计量的计算公式为：\n$$\nt = \\frac{\\bar{A}_{\\text{sv}} - \\bar{A}_{\\text{rand}}}{\\sqrt{\\frac{s_{\\text{sv}}^2}{N} + \\frac{s_{\\text{rand}}^2}{N}}}\n$$\n其中 $\\bar{A}$ 和 $s^2$ 分别是每个集合振幅的样本均值和方差。自由度使用 Welch-Satterthwaite 方程进行估计。\n\n从 $t$-统计量和自由度可以计算出单侧 $p$ 值。这个 $p$ 值表示在零假设为真的情况下，观察到样本均值之差等于或大于已计算出的差值的概率。\n\n最终的决策规则是：当且仅当同时满足以下两个条件时，一个测试用例的结果为 `true`：\n1. 奇异向量集合的样本均值严格大于随机集合的样本均值（$\\bar{A}_{\\text{sv}} > \\bar{A}_{\\text{rand}}$）。\n2. 计算出的单侧 $p$ 值严格小于预设的显著性水平 $\\alpha$。\n否则，结果为 `false`。\n\n该程序将系统地应用于提供的每个测试用例，使用指定的参数和随机种子以确保可复现性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import ttest_ind\n\ndef solve():\n    \"\"\"\n    Solves the problem by running a Monte Carlo experiment for each test case\n    to compare singular vector and random perturbation ensembles.\n    \"\"\"\n    \n    # Case 1: Anisotropic growth, identity norms\n    M1 = np.array([[1.6, 0.1], [0.0, 0.7]])\n    V1 = np.eye(2)\n    W1 = np.eye(2)\n    case1 = (2, M1, V1, W1, 1000, 0.05, 0.05, 123)\n\n    # Case 2: Isotropic growth, identity norms\n    s2 = 1.2\n    theta2 = 0.7\n    R2 = np.array([[np.cos(theta2), -np.sin(theta2)], [np.sin(theta2), np.cos(theta2)]])\n    M2 = s2 * R2\n    V2 = np.eye(2)\n    W2 = np.eye(2)\n    case2 = (2, M2, V2, W2, 1000, 0.05, 0.05, 456)\n\n    # Case 3: Anisotropic growth, small sample size\n    M3 = np.array([[1.4, 0.0], [0.0, 0.6]])\n    V3 = np.eye(2)\n    W3 = np.eye(2)\n    case3 = (2, M3, V3, W3, 30, 0.10, 0.05, 789)\n\n    # Case 4: Three-dimensional, nontrivial metric weights\n    M4 = np.array([[1.7, 0.2, 0.0], [0.0, 0.9, 0.1], [0.0, 0.0, 0.6]])\n    V4 = np.diag([1.0, 2.0, 0.5])\n    W4 = np.diag([2.0, 0.5, 3.0])\n    case4 = (3, M4, V4, W4, 800, 0.05, 0.05, 101112)\n\n    test_cases = [case1, case2, case3, case4]\n    results = []\n\n    for n, M, V, W, N, epsilon, alpha, seed in test_cases:\n        np.random.seed(seed)\n\n        # Step 1: Compute matrix square roots and their inverses via Cholesky\n        L_V = np.linalg.cholesky(V)\n        V_sqrt = L_V.T\n        V_inv_sqrt = np.linalg.inv(V_sqrt)\n\n        L_W = np.linalg.cholesky(W)\n        W_sqrt = L_W.T\n\n        # Step 2: Compute the leading singular vector\n        A = W_sqrt @ M @ V_inv_sqrt\n        # np.linalg.svd returns U, s, Vt where Vt is V.T in U*S*V.T\n        # The rows of Vt are the right singular vectors.\n        _, _, Vt = np.linalg.svd(A)\n        q1 = Vt[0, :]  # Leading right singular vector\n        sv_leading = V_inv_sqrt @ q1\n        \n        # Helper function to generate perturbations on the V-norm unit sphere\n        def generate_v_norm_sphere_samples(num_samples):\n            gaussians = np.random.standard_normal(size=(num_samples, n))\n            norms = np.linalg.norm(gaussians, axis=1, keepdims=True)\n            unit_euclidean = gaussians / norms\n            # Each row is a sample vector\n            v_norm_samples = (V_inv_sqrt @ unit_euclidean.T).T\n            return v_norm_samples\n\n        # Step 3: Generate the two ensembles\n        # Random ensemble\n        random_ensemble = generate_v_norm_sphere_samples(N)\n\n        # Singular vector ensemble\n        sv_ensemble_list = []\n        random_directions = generate_v_norm_sphere_samples(N)\n        for i in range(N):\n            eta_i = random_directions[i, :]\n            # Create perturbed SV\n            z = sv_leading + epsilon * eta_i\n            # Renormalize in the V-norm\n            norm_z_v = np.linalg.norm(V_sqrt @ z)\n            sv_ensemble_list.append(z / norm_z_v)\n        sv_ensemble = np.array(sv_ensemble_list)\n\n        # Step 4: Compute forecast metric amplitudes for both ensembles\n        def compute_amplitudes(ensemble):\n            # Propagate perturbations\n            evolved_ensemble = (M @ ensemble.T).T\n            # Compute W-norm of propagated perturbations\n            w_normed_evolved = (W_sqrt @ evolved_ensemble.T).T\n            # Amplitudes are the squared norms\n            amplitudes = np.linalg.norm(w_normed_evolved, axis=1)**2\n            return amplitudes\n\n        amplitudes_rand = compute_amplitudes(random_ensemble)\n        amplitudes_sv = compute_amplitudes(sv_ensemble)\n\n        # Step 5: Perform statistical test and check conditions\n        mean_rand = np.mean(amplitudes_rand)\n        mean_sv = np.mean(amplitudes_sv)\n\n        # Use Welch's t-test for a one-sided hypothesis H1: mean_sv > mean_rand\n        _, p_value = ttest_ind(\n            amplitudes_sv, amplitudes_rand, \n            equal_var=False, alternative='greater'\n        )\n\n        # The result is true if mean of SV is strictly larger AND p-value is significant\n        is_improvement = (mean_sv > mean_rand) and (p_value  alpha)\n        results.append(is_improvement)\n    \n    # Format boolean results to be lowercase strings for the join map.\n    # The problem description's example output shows \"True\", \"False\" which str() does.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}