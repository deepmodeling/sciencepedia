{
    "hands_on_practices": [
        {
            "introduction": "布里尔分数（Brier score）是评估概率预报准确性的基石。然而，其总体值并不能完全揭示预报系统的具体优缺点。通过将其分解，我们可以独立评估预报的可靠性（reliability）、分辨率（resolution）和不确定性（uncertainty）。本练习  将指导您计算布里尔分数的可靠性分量，它量化了预报概率与观测到的事件频率之间的一致性，是衡量预报系统是否“诚实”的关键指标。",
            "id": "4079061",
            "problem": "一个研究小组正在评估一个对流解析数值天气预报（NWP）集合对某一流域的二元事件“六小时累积降水量超过 $10$ mm”的概率预报。设 $Y \\in \\{0,1\\}$ 表示该事件发生的验证指标，设 $F \\in [0,1]$ 表示集合发布的预报概率。Brier 评分定义为 $BS = \\mathbb{E}[(F - Y)^{2}]$，其中期望是关于由预报系统和验证实况所导出的 $(F,Y)$ 的联合分布。\n\n利用全期望定律和条件期望的性质，将 Brier 评分分解为可靠性、分辨率和不确定性分量，请从第一性原理推导可靠性分量，将其表示为一个包含 $F$ 和条件事件频率 $\\mathbb{E}[Y \\mid F]$ 的期望。然后，在一个将预报空间划分为 $K$ 个离散的箱（bin），每个箱具有代表性概率 $q_{k}$、经验计数 $n_{k}$ 和观测相对频率 $\\bar{y}_{k}$ 的可靠性图分箱方案下，利用这些分箱摘要得出一个可靠性分量的相合有限样本估计量。\n\n为期一年的评估为 $K=5$ 个箱生成了以下可靠性图摘要：\n- 箱 $k=1$：$q_{1} = 0.05$， $n_{1} = 40$， $\\bar{y}_{1} = 0.10$。\n- 箱 $k=2$：$q_{2} = 0.15$， $n_{2} = 60$， $\\bar{y}_{2} = 0.12$。\n- 箱 $k=3$：$q_{3} = 0.35$， $n_{3} = 80$， $\\bar{y}_{3} = 0.30$。\n- 箱 $k=4$：$q_{4} = 0.65$， $n_{4} = 50$， $\\bar{y}_{4} = 0.60$。\n- 箱 $k=5$：$q_{5} = 0.85$， $n_{5} = 70$， $\\bar{y}_{5} = 0.90$。\n\n设 $N = \\sum_{k=1}^{K} n_{k}$ 表示预报-验证对的总数。使用您推导出的估计量，计算此数据集的可靠性分量。将最终答案表示为一个精确的既约分数（无量纲）。不要使用百分号。",
            "solution": "问题陈述已经过分析，被认为是有效的。它在科学上基于概率预报检验的原理，问题良定，具有足够的数据以得到唯一解，并以客观、明确的语言表达。我们可以开始求解。\n\n该问题要求完成两项主要任务：首先，从第一性原理推导 Brier 评分的可靠性分量；其次，为其推导一个有限样本估计量，并使用该估计量计算给定数据集的可靠性分量值。\n\n设 $Y \\in \\{0, 1\\}$ 为事件发生的二元变量， $F \\in [0, 1]$ 为预报概率。Brier 评分（$BS$）定义为预报的均方误差：\n$$\nBS = \\mathbb{E}[(F - Y)^{2}]\n$$\n期望 $\\mathbb{E}[\\cdot]$ 是对预报和观测的联合分布取的。\n\n**第一部分：可靠性分量的推导**\n\n我们可以使用全期望定律来分解 Brier 评分。我们以预报值 $F$ 为条件。\n$$\nBS = \\mathbb{E}_{F} \\left[ \\mathbb{E}_{Y \\mid F} [(F - Y)^{2} \\mid F] \\right]\n$$\n我们来分析内层期望 $\\mathbb{E}[(F-Y)^2 \\mid F]$。给定一个特定的预报值 $F=f$， $f$ 是一个常数。\n$$\n\\mathbb{E}[(f - Y)^{2} \\mid F=f] = \\mathbb{E}[f^2 - 2fY + Y^2 \\mid F=f]\n$$\n根据期望的线性性质：\n$$\n= f^2 - 2f \\mathbb{E}[Y \\mid F=f] + \\mathbb{E}[Y^2 \\mid F=f]\n$$\n由于 $Y$ 是一个指示变量， $Y \\in \\{0, 1\\}$，因此有 $Y^2 = Y$。所以，$\\mathbb{E}[Y^2 \\mid F=f] = \\mathbb{E}[Y \\mid F=f]$。我们定义条件事件频率，即给定预报下事件的真实概率，为 $\\bar{y}(f) \\equiv \\mathbb{E}[Y \\mid F=f]$。将此代入表达式可得：\n$$\n\\mathbb{E}[(f - Y)^{2} \\mid F=f] = f^2 - 2f \\bar{y}(f) + \\bar{y}(f)\n$$\n我们可以加上并减去 $(\\bar{y}(f))^2$ 来配方：\n$$\n= f^2 - 2f \\bar{y}(f) + (\\bar{y}(f))^2 - (\\bar{y}(f))^2 + \\bar{y}(f)\n$$\n$$\n= (f - \\bar{y}(f))^2 + (\\bar{y}(f) - (\\bar{y}(f))^2)\n$$\n现在，我们对 $F$ 取外层期望，以得到 Brier 评分：\n$$\nBS = \\mathbb{E}_{F} \\left[ (F - \\bar{y}(F))^2 + (\\bar{y}(F) - (\\bar{y}(F))^2) \\right]\n$$\n$$\nBS = \\mathbb{E} \\left[ (F - \\mathbb{E}[Y \\mid F])^2 \\right] + \\mathbb{E} \\left[ \\mathbb{E}[Y \\mid F] (1 - \\mathbb{E}[Y \\mid F]) \\right]\n$$\n该表达式将 Brier 评分分解为两项。第一项 $\\mathbb{E}[(F - \\mathbb{E}[Y \\mid F])^2]$ 是**可靠性分量**。它衡量的是预报概率与相应观测值的条件均值之间的加权均方差。一个完全可靠的预报系统对于所有 $f$ 都会有 $\\mathbb{E}[Y \\mid F=f] = f$，使得该分量为零。推导的第一部分到此结束。\n\n第二项可以进一步分解为分辨率和不确定性，得到完整的分解 $BS = REL - RES + UNC$，但这超出了当前问题的范围。可靠性分量是：\n$$\nREL = \\mathbb{E} \\left[ (F - \\mathbb{E}[Y \\mid F])^2 \\right]\n$$\n\n**第二部分：有限样本估计量与计算**\n\n为了从一组 $N$ 个预报-验证对中获得有限样本估计量，我们通常使用问题中所述的分箱方法。预报概率空间 $[0,1]$ 被划分为 $K$ 个箱。对于每个箱 $k \\in \\{1, \\dots, K\\}$，我们有：\n- $n_k$：落入第 $k$ 箱的预报数量。\n- $q_k$：第 $k$ 箱的代表性预报概率（例如，箱的中点或箱内预报的平均值）。这是 $F$ 的经验对应物。\n- $\\bar{y}_k$：第 $k$ 箱中预报的事件观测相对频率。这是条件期望 $\\mathbb{E}[Y \\mid F \\in \\text{bin } k]$ 的经验估计。\n\n总体期望 $\\mathbb{E}[\\cdot]$ 被估计为所有 $N$ 个样本的平均值，这可以转化为对 $K$ 个箱的加权平均。每个箱 $k$ 的权重是其样本频率 $n_k/N$。期望内的项 $(F - \\mathbb{E}[Y \\mid F])^2$ 对于每个箱 $k$ 由 $(q_k - \\bar{y}_k)^2$ 来估计。\n\n综合这些，可靠性分量的有限样本估计量（我们将其记为 $\\widehat{REL}$）是：\n$$\n\\widehat{REL} = \\sum_{k=1}^{K} \\frac{n_k}{N} (q_k - \\bar{y}_k)^2\n$$\n其中 $N = \\sum_{k=1}^{K} n_k$。\n\n现在，我们使用给定的数据计算 $\\widehat{REL}$：\n- 箱 $k=1$：$q_{1} = 0.05$， $n_{1} = 40$， $\\bar{y}_{1} = 0.10$。\n- 箱 $k=2$：$q_{2} = 0.15$， $n_{2} = 60$， $\\bar{y}_{2} = 0.12$。\n- 箱 $k=3$：$q_{3} = 0.35$， $n_{3} = 80$， $\\bar{y}_{3} = 0.30$。\n- 箱 $k=4$：$q_{4} = 0.65$， $n_{4} = 50$， $\\bar{y}_{4} = 0.60$。\n- 箱 $k=5$：$q_{5} = 0.85$， $n_{5} = 70$， $\\bar{y}_{5} = 0.90$。\n\n首先，我们计算预报-验证对的总数 $N$：\n$$\nN = n_1 + n_2 + n_3 + n_4 + n_5 = 40 + 60 + 80 + 50 + 70 = 300\n$$\n现在，我们计算每个箱的项：\n- 第1箱：$\\frac{40}{300} (0.05 - 0.10)^2 = \\frac{4}{30} (-0.05)^2 = \\frac{2}{15} (0.0025) = \\frac{2}{15} \\left(\\frac{1}{400}\\right) = \\frac{2}{6000} = \\frac{1}{3000}$。\n- 第2箱：$\\frac{60}{300} (0.15 - 0.12)^2 = \\frac{6}{30} (0.03)^2 = \\frac{1}{5} (0.0009) = \\frac{1}{5} \\left(\\frac{9}{10000}\\right) = \\frac{9}{50000}$。\n- 第3箱：$\\frac{80}{300} (0.35 - 0.30)^2 = \\frac{8}{30} (0.05)^2 = \\frac{4}{15} (0.0025) = \\frac{4}{15} \\left(\\frac{1}{400}\\right) = \\frac{4}{6000} = \\frac{1}{1500}$。\n- 第4箱：$\\frac{50}{300} (0.65 - 0.60)^2 = \\frac{5}{30} (0.05)^2 = \\frac{1}{6} (0.0025) = \\frac{1}{6} \\left(\\frac{1}{400}\\right) = \\frac{1}{2400}$。\n- 第5箱：$\\frac{70}{300} (0.85 - 0.90)^2 = \\frac{7}{30} (-0.05)^2 = \\frac{7}{30} (0.0025) = \\frac{7}{30} \\left(\\frac{1}{400}\\right) = \\frac{7}{12000}$。\n\n现在我们将这些贡献相加：\n$$\n\\widehat{REL} = \\frac{1}{3000} + \\frac{9}{50000} + \\frac{1}{1500} + \\frac{1}{2400} + \\frac{7}{12000}\n$$\n为了将这些分数相加，我们找到一个公分母。分母是 $3000=3\\times10^3$, $50000=5\\times10^4$, $1500=1.5\\times10^3$, $2400=2.4\\times10^3$ 和 $12000=1.2\\times10^4$。分母 $(3000, 50000, 1500, 2400, 12000)$ 的最小公倍数是 $300000$。\n将每个分数转换为以这个数为分母：\n$$\n\\frac{1}{3000} = \\frac{100}{300000}\n$$\n$$\n\\frac{9}{50000} = \\frac{9 \\times 6}{50000 \\times 6} = \\frac{54}{300000}\n$$\n$$\n\\frac{1}{1500} = \\frac{200}{300000}\n$$\n$$\n\\frac{1}{2400} = \\frac{125}{300000}\n$$\n$$\n\\frac{7}{12000} = \\frac{7 \\times 25}{12000 \\times 25} = \\frac{175}{300000}\n$$\n将分子相加：\n$$\n100 + 54 + 200 + 125 + 175 = 654\n$$\n所以，可靠性分量是：\n$$\n\\widehat{REL} = \\frac{654}{300000}\n$$\n最后，我们将分数约分至最简形式。分子和分母都可以被 $6$ 整除：\n$$\n\\widehat{REL} = \\frac{654 \\div 6}{300000 \\div 6} = \\frac{109}{50000}\n$$\n由于 $109$ 是一个质数，这个分数是完全约分的。",
            "answer": "$$\n\\boxed{\\frac{109}{50000}}\n$$"
        },
        {
            "introduction": "概率预报的最终价值往往体现在其对决策的支持上，例如是否发布极端天气警报。将概率转化为二元决策需要一个关键步骤：选择一个概率阈值。本练习  探讨了皮尔斯技巧评分（Peirce Skill Score, TSS），这是一个通过权衡命中率（true positive rate）和误报率（false positive rate）来评估决策质量的指标。通过求解 $TSS$ 的最大值，您可以找到最优决策阈值，从而将预报验证与实际应用价值直接联系起来。",
            "id": "4079041",
            "problem": "一个全球集合预报系统发布针对一个罕见的二元极端事件的概率预报，该事件定义为在给定位置的每日最大风速超过一个固定阈值。对于每个检验日，该系统输出事件概率预报 $\\hat{p}$，可解释为预报该事件发生的集合成员的比例。考虑以下对预报-结果行为的程式化但科学上合理的参数化表征，以检验结果为条件：\n- 在事件发生的条件下，预报概率 $\\hat{p}$ 在 $[0,1]$ 上的密度 $f_{1}(p)$ 由参数为 $(\\alpha_{1},\\beta_{1})=(3,1)$ 的贝塔分布给出，即对于 $p \\in [0,1]$ 有 $f_{1}(p)=3\\,p^{2}$。\n- 在事件未发生的条件下，预报概率 $\\hat{p}$ 在 $[0,1]$ 上的密度 $f_{0}(p)$ 由参数为 $(\\alpha_{0},\\beta_{0})=(1,3)$ 的贝塔分布给出，即对于 $p \\in [0,1]$ 有 $f_{0}(p)=3\\,(1-p)^{2}$。\n\n通过在水平 $\\tau \\in [0,1]$ 对概率进行阈值处理来获得一个确定性决策：如果 $\\hat{p} \\ge \\tau$，则预报“事件发生”，否则预报“事件未发生”。令 $\\text{TPR}(\\tau)$ 表示真正率（TPR），定义为在事件发生的条件下预报“事件发生”的条件概率；令 $\\text{FPR}(\\tau)$ 表示假正率（FPR），定义为在事件未发生的条件下预报“事件发生”的条件概率。在阈值 $\\tau$ 下的皮尔斯技巧评分（也称为真实技巧统计量（TSS））定义为 $\\text{TSS}(\\tau)=\\text{TPR}(\\tau)-\\text{FPR}(\\tau)$。\n\n仅从这些定义以及所提供的密度 $f_{1}$ 和 $f_{0}$ 出发：\n- 用 $f_{1}$ 和 $f_{0}$ 的积分形式推导 $\\text{TPR}(\\tau)$ 和 $\\text{FPR}(\\tau)$，然后获得 $\\text{TSS}(\\tau)$ 作为 $\\tau$ 的函数的显式闭式表达式。\n- 计算阈值 $\\tau \\in \\{0,\\tfrac{1}{4},\\tfrac{1}{2},\\tfrac{3}{4},1\\}$ 对应的 $\\text{TSS}(\\tau)$。\n- 找出使 $\\text{TSS}(\\tau)$ 最大化的唯一阈值 $\\tau^{\\star} \\in [0,1]$。\n\n最终答案只提供 $\\tau^{\\star}$ 的精确值，以无单位的最简分数形式表示。无需四舍五入；请精确地表达最终答案。",
            "solution": "首先根据要求标准对问题进行验证。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- **事件定义**：一个罕见的二元极端事件。\n- **预报概率**：$\\hat{p} \\in [0,1]$，预报该事件发生的集合成员的比例。\n- **条件密度（事件发生）**：对于事件发生的结果，预报概率 $\\hat{p}$ 是一个随机变量 $p$，其在 $[0,1]$ 上的概率密度函数 $f_{1}(p)$ 由参数为 $(\\alpha_{1},\\beta_{1})=(3,1)$ 的贝塔分布给出。该密度为 $f_{1}(p)=3\\,p^{2}$，对于 $p \\in [0,1]$。\n- **条件密度（事件未发生）**：对于事件未发生的结果，预报概率 $\\hat{p}$ 是一个随机变量 $p$，其在 $[0,1]$ 上的概率密度函数 $f_{0}(p)$ 由参数为 $(\\alpha_{0},\\beta_{0})=(1,3)$ 的贝塔分布给出。该密度为 $f_{0}(p)=3\\,(1-p)^{2}$，对于 $p \\in [0,1]$。\n- **决策规则**：通过在水平 $\\tau \\in [0,1]$ 对概率 $\\hat{p}$ 进行阈值处理来做出确定性预报。\n    - 如果 $\\hat{p} \\ge \\tau$，则预报“事件发生”。\n    - 如果 $\\hat{p}  \\tau$，则预报“事件未发生”。\n- **真正率 (TPR)**：$\\text{TPR}(\\tau)$ 是在事件发生的条件下预报“事件发生”的条件概率。\n- **假正率 (FPR)**：$\\text{FPR}(\\tau)$ 是在事件未发生的条件下预报“事件发生”的条件概率。\n- **皮尔斯技巧评分 (TSS)**：$\\text{TSS}(\\tau) = \\text{TPR}(\\tau) - \\text{FPR}(\\tau)$。\n- **任务**：\n    1. 推导 $\\text{TPR}(\\tau)$、$\\text{FPR}(\\tau)$ 和 $\\text{TSS}(\\tau)$ 的显式闭式表达式。\n    2. 计算 $\\tau \\in \\{0, \\frac{1}{4}, \\frac{1}{2}, \\frac{3}{4}, 1\\}$ 对应的 $\\text{TSS}(\\tau)$。\n    3. 找出使 $\\text{TSS}(\\tau)$ 最大化的唯一阈值 $\\tau^{\\star} \\in [0,1]$。\n\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在概率预报检验理论中有充分的依据，这是数值天气预报和气候建模中的一个标准课题。使用贝塔分布对预报概率进行建模，以及TPR、FPR和TSS的定义都是标准的、科学合理的。\n- **适定性**：该问题是自洽的，提供了所有必要的定义和函数。目标清晰且在数学上是可处理的。预期存在唯一解。\n- **客观性**：该问题使用精确的数学语言陈述，没有任何主观性或歧义。\n\n**步骤3：结论与行动**\n问题被判定为**有效**。将提供完整解答。\n\n### 解答\n\n第一个任务是推导真正率 $\\text{TPR}(\\tau)$ 和假正率 $\\text{FPR}(\\tau)$ 的表达式。\n\n$\\text{TPR}(\\tau)$ 是在事件实际发生的条件下，预报为“事件发生”（即 $\\hat{p} \\ge \\tau$）的条件概率。在这种情况下，预报 $\\hat{p}$ 的概率分布由密度 $f_{1}(p)$ 给出。因此，$\\text{TPR}(\\tau)$ 是 $f_{1}(p)$ 在区间 $[\\tau, 1]$ 上的积分。\n$$\n\\text{TPR}(\\tau) = P(\\hat{p} \\ge \\tau | \\text{event occurs}) = \\int_{\\tau}^{1} f_{1}(p) \\, dp\n$$\n代入给定的表达式 $f_{1}(p) = 3p^2$：\n$$\n\\text{TPR}(\\tau) = \\int_{\\tau}^{1} 3p^{2} \\, dp = \\left[p^{3}\\right]_{\\tau}^{1} = 1^{3} - \\tau^{3} = 1 - \\tau^{3}\n$$\n\n$\\text{FPR}(\\tau)$ 是在事件未发生的条件下，预报为“事件发生”（即 $\\hat{p} \\ge \\tau$）的条件概率。在这种情况下，预报 $\\hat{p}$ 的概率分布由密度 $f_{0}(p)$ 给出。因此，$\\text{FPR}(\\tau)$ 是 $f_{0}(p)$ 在区间 $[\\tau, 1]$ 上的积分。\n$$\n\\text{FPR}(\\tau) = P(\\hat{p} \\ge \\tau | \\text{event does not occur}) = \\int_{\\tau}^{1} f_{0}(p) \\, dp\n$$\n代入给定的表达式 $f_{0}(p) = 3(1-p)^2$：\n$$\n\\text{FPR}(\\tau) = \\int_{\\tau}^{1} 3(1-p)^{2} \\, dp\n$$\n为了计算这个积分，我们可以使用换元法，令 $u = 1-p$，这意味着 $du = -dp$。当 $p=\\tau$ 时，$u=1-\\tau$。当 $p=1$ 时，$u=0$。\n$$\n\\text{FPR}(\\tau) = \\int_{1-\\tau}^{0} 3u^{2} (-du) = \\int_{0}^{1-\\tau} 3u^{2} \\, du = \\left[u^{3}\\right]_{0}^{1-\\tau} = (1-\\tau)^{3} - 0^{3} = (1-\\tau)^{3}\n$$\n\n现在，我们推导皮尔斯技巧评分 $\\text{TSS}(\\tau)$ 的表达式。\n$$\n\\text{TSS}(\\tau) = \\text{TPR}(\\tau) - \\text{FPR}(\\tau) = (1 - \\tau^{3}) - (1-\\tau)^{3}\n$$\n展开 $(1-\\tau)^{3}$ 项：\n$$\n(1-\\tau)^{3} = 1^{3} - 3(1)^{2}\\tau + 3(1)\\tau^{2} - \\tau^{3} = 1 - 3\\tau + 3\\tau^{2} - \\tau^{3}\n$$\n将此代回 $\\text{TSS}(\\tau)$ 的表达式中：\n$$\n\\text{TSS}(\\tau) = (1 - \\tau^{3}) - (1 - 3\\tau + 3\\tau^{2} - \\tau^{3}) = 1 - \\tau^{3} - 1 + 3\\tau - 3\\tau^{2} + \\tau^{3}\n$$\n$$\n\\text{TSS}(\\tau) = 3\\tau - 3\\tau^{2} = 3\\tau(1-\\tau)\n$$\n\n第二个任务是计算给定阈值下的 $\\text{TSS}(\\tau)$。\n- 对于 $\\tau = 0$：$\\text{TSS}(0) = 3(0)(1-0) = 0$。\n- 对于 $\\tau = \\frac{1}{4}$：$\\text{TSS}(\\frac{1}{4}) = 3(\\frac{1}{4})(1-\\frac{1}{4}) = 3(\\frac{1}{4})(\\frac{3}{4}) = \\frac{9}{16}$。\n- 对于 $\\tau = \\frac{1}{2}$：$\\text{TSS}(\\frac{1}{2}) = 3(\\frac{1}{2})(1-\\frac{1}{2}) = 3(\\frac{1}{2})(\\frac{1}{2}) = \\frac{3}{4}$。\n- 对于 $\\tau = \\frac{3}{4}$：$\\text{TSS}(\\frac{3}{4}) = 3(\\frac{3}{4})(1-\\frac{3}{4}) = 3(\\frac{3}{4})(\\frac{1}{4}) = \\frac{9}{16}$。\n- 对于 $\\tau = 1$：$\\text{TSS}(1) = 3(1)(1-1) = 0$。\n\n最后一个任务是找出在区间 $[0,1]$ 上使 $\\text{TSS}(\\tau)$ 最大化的阈值 $\\tau^{\\star}$。我们需要找到函数 $S(\\tau) = 3\\tau - 3\\tau^{2}$ 的最大值。这是一个关于 $\\tau$ 的二次函数，表示一个开口向下的抛物线。最大值出现在其顶点处。为了找到这一点，我们计算其关于 $\\tau$ 的导数并令其为零。\n$$\n\\frac{d}{d\\tau} \\text{TSS}(\\tau) = \\frac{d}{d\\tau}(3\\tau - 3\\tau^{2}) = 3 - 6\\tau\n$$\n将导数设为零以找到临界点：\n$$\n3 - 6\\tau = 0 \\implies 6\\tau = 3 \\implies \\tau = \\frac{3}{6} = \\frac{1}{2}\n$$\n为确认这是一个最大值，我们检查二阶导数：\n$$\n\\frac{d^{2}}{d\\tau^{2}} \\text{TSS}(\\tau) = \\frac{d}{d\\tau}(3 - 6\\tau) = -6\n$$\n由于二阶导数为负，临界点 $\\tau = \\frac{1}{2}$ 是一个局部最大值。由于这是区间 $[0,1]$ 中唯一的临界点，并且函数在端点处的值（$\\text{TSS}(0)=0$，$\\text{TSS}(1)=0$）小于在临界点处的值（$\\text{TSS}(\\frac{1}{2}) = \\frac{3}{4}$），因此 $\\tau^{\\star} = \\frac{1}{2}$ 是使皮尔斯技巧评分最大化的唯一阈值。\n\n找到 $\\text{TSS}(\\tau)$ 最大值的另一种更通用的方法是注意到 $\\text{TSS}(\\tau)$ 关于 $\\tau$ 的导数是：\n$$\n\\frac{d}{d\\tau} \\text{TSS}(\\tau) = \\frac{d}{d\\tau} \\left( \\int_{\\tau}^{1} f_{1}(p) \\, dp - \\int_{\\tau}^{1} f_{0}(p) \\, dp \\right)\n$$\n使用微积分基本定理（特别是莱布尼茨积分法则）：\n$$\n\\frac{d}{d\\tau} \\text{TSS}(\\tau) = -f_{1}(\\tau) - (-f_{0}(\\tau)) = f_{0}(\\tau) - f_{1}(\\tau)\n$$\n将导数设为零意味着 $f_{0}(\\tau^{\\star}) = f_{1}(\\tau^{\\star})$。最优阈值是两个条件密度相等的地方。\n$$\n3(1-\\tau^{\\star})^{2} = 3(\\tau^{\\star})^{2}\n$$\n$$\n(1-\\tau^{\\star})^{2} = (\\tau^{\\star})^{2}\n$$\n两边取平方根：\n$$\n1-\\tau^{\\star} = \\pm \\tau^{\\star}\n$$\n由于 $\\tau^{\\star}$ 必须在 $[0,1]$ 内，我们取正根 $1-\\tau^{\\star} = \\tau^{\\star}$（负根 $1-\\tau^{\\star} = -\\tau^{\\star}$ 得出 $1=0$，这是一个矛盾）。\n$$\n1 = 2\\tau^{\\star} \\implies \\tau^{\\star} = \\frac{1}{2}\n$$\n这证实了之前的结果。使皮尔斯技巧评分最大化的唯一阈值是 $\\tau^{\\star} = \\frac{1}{2}$。",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "秩直方图（rank histogram）是评估集合预报系统可靠性的强大图形工具，理想情况下它应呈均匀分布。然而，在实践中，我们依赖统计检验来判断其均匀性，而这些检验本身也存在局限性。本高级模拟练习  深入探讨了应用这些检验时的实际挑战，特别是有限的集合成员数如何对检验结果产生系统性偏差。完成此练习将使您对集合预报诊断工具在真实世界中的复杂性有更深刻的理解。",
            "id": "4079028",
            "problem": "您的任务是通过等级直方图和标准均匀性检验，量化集合大小对概率预报可靠性评估的影响，并重点关注由有限、离散的箱体引起的离散化偏差。考虑一个包含 $M$ 个成员的集合预报，每个预报案例对应一个验证观测值。在预报可靠（观测值和集合成员独立地从同一分布中抽样）的条件下，观测值在排序后的集合成员中的等级在集合 $\\{0,1,\\dots,M\\}$ 上是离散均匀分布的。因此，在 $N$ 个预报案例中收集的等级直方图具有 $M+1$ 个箱体，每个箱体 $i$ 的期望概率相等，为 $p_i = 1/(M+1)$。一个常用的均匀性检验是皮尔逊卡方（Pearson $\\chi^2$）检验，它将观测到的箱体计数与均匀性原假设下的期望计数进行比较。在实践中，该检验使用渐近卡方分布作为其参考分布。当期望箱体计数很小时，等级的离散性（取决于 $M$）和有限的 $N$ 会导致检验统计量的真实有限样本分布与其渐近参考分布之间产生差异；这种差异表现为名义显著性水平与经验I类错误拒绝率之间的差值。我们将这个差值定义为在给定集合大小下均匀性检验的离散化偏差。\n\n从以下基本基础出发：\n\n- 在可靠性条件下，观测值 $y$ 和每个集合成员 $e_m$ 都是从一个共同的连续分布（例如标准正态分布）中独立同分布地抽取的。$y$ 在 $M$ 个集合成员中的等级 $R$ 由 $R = \\sum_{m=1}^{M} \\mathbf{1}\\{e_m  y\\}$ 给出，当分布是连续且出现平局的概率为零时，它在 $\\{0,\\dots,M\\}$上是离散均匀的。\n\n- 对于 $N$ 个独立的预报案例，产生的等级为 $R_j$（其中 $j=1,\\dots,N$），在可靠性条件下，箱体计数 $(O_0,\\dots,O_M)$ 是一个参数为 $N$ 和类别概率 $p_i = 1/(M+1)$ 的多项式随机向量。\n\n- 皮尔逊卡方统计量定义为\n$$\nX^2 = \\sum_{i=0}^{M} \\frac{(O_i - E_i)^2}{E_i},\n$$\n其中 $E_i = N p_i = N/(M+1)$ 是期望箱体计数。在具有相等类别概率的多项式模型下，$X^2$ 的精确期望为 $\\mathbb{E}[X^2] = M$，但当期望计数很小时，其有限样本分布与具有 $M$ 个自由度的渐近卡方分布不同。\n\n编写一个完整的程序，完成以下任务：\n\n- 对于每个指定的测试案例，模拟 $R$ 次独立的蒙特卡洛重复实验。在每次重复实验中，生成 $N$ 个预报案例，集合大小为 $M$，其中集合成员 $e_m$ 和验证观测值 $y$ 是标准正态分布 $\\mathcal{N}(0,1)$ 的独立抽样。对于每个案例，计算等级 $R_j = \\sum_{m=1}^{M} \\mathbf{1}\\{e_{j,m}  y_j\\}$，其中 $j=1,\\dots,N$。在 $N$ 个案例中累积一个等级直方图 $(O_0,\\dots,O_M)$，然后使用对所有箱体 $i$ 均为 $E_i = N/(M+1)$ 的期望计数来计算皮尔逊 $X^2$ 统计量，并使用具有 $M$ 个自由度的渐近卡方阈值 $q_{1-\\alpha}$ 在显著性水平 $\\alpha$ 下做出拒绝决策。在 $R$ 次重复实验中，估计经验I类错误拒绝率 $\\hat{\\rho}$，并将离散化偏差 $\\hat{b} = \\hat{\\rho} - \\alpha$ 报告为小数（而非百分比）。\n\n- 使用固定的随机种子以确保可复现性。\n\n- 将所有结果表示为小数，并将所有测试案例的输出聚合到指定格式的单行中。\n\n测试套件：\n\n- 对整个模拟使用固定的随机种子 $42$。\n\n- 每个测试案例使用 $R = 500$ 次蒙特卡洛重复实验。\n\n- 使用以下测试案例，均在可靠性假设下（观测值和集合成员独立地从 $\\mathcal{N}(0,1)$ 抽样），名义显著性水平 $\\alpha = 0.1$：\n\n    1. $(M, N, \\alpha) = (1, 200, 0.1)$\n\n    2. $(M, N, \\alpha) = (2, 200, 0.1)$\n\n    3. $(M, N, \\alpha) = (10, 200, 0.1)$\n\n    4. $(M, N, \\alpha) = (50, 200, 0.1)$\n\n    5. $(M, N, \\alpha) = (50, 100, 0.1)$\n\n要求的最终输出格式：\n\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按上述顺序列出每个测试案例的离散化偏差 $\\hat{b}$，每个值四舍五入到 $4$ 位小数，例如 $[\\hat{b}_1,\\hat{b}_2,\\hat{b}_3,\\hat{b}_4,\\hat{b}_5]$。\n\n科学真实性与自洽性：\n\n- 使用连续分布（标准正态分布 $\\mathcal{N}(0,1)$），使得平局概率为零，确保在可靠性条件下等级分布是精确的离散均匀分布。\n\n- 基于模拟的离散化偏差估计是合理的，因为在多项式模型下，$X^2$ 的有限样本分布与渐近卡方分布不同，尤其是在期望计数 $E_i$ 很小的情况下（当 $M$ 大或 $N$ 小时发生）。\n\n您的任务是准确地实现此模拟，遵守指定的参数和输出格式。此问题不适用任何物理单位或角度单位。",
            "solution": "该问题是有效的。它在科学上基于统计假设检验和集合预报验证的原理，问题阐述清晰，所有必要的参数和方法都已指定，并且其表述是客观的。我们将继续提供解决方案。\n\n目标是量化皮尔遜 $\\chi^2$ 均匀性检验在应用于集合预报等级直方图时的离散化偏差。这个偏差表示为 $\\hat{b}$，是经验I类错误率 $\\hat{\\rho}$ 与名义显著性水平 $\\alpha$ 之间的差异。它产生的原因是，检验统计量的有限样本分布偏离了其假定的渐近 $\\chi^2$ 分布，特别是在期望箱体计数较低时。该分析通过蒙特卡洛模拟进行。\n\n该方法的核心是在完美预报可靠性的原假设下模拟生成等级直方图的过程，然后执行 $\\chi^2$ 检验。这个过程重复多次以估计真实的拒绝率。\n\n对于由特定集合大小 $M$、预报案例数 $N$ 和显著性水平 $\\alpha$ 定义的每个测试案例，模拟过程如下：\n\n1.  **初始化**：我们执行 $R = 500$ 次独立的蒙特卡洛重复实验。假设检验的名义显著性水平固定为 $\\alpha = 0.1$。用于记录拒绝次数的计数器初始化为 $0$。\n\n2.  **确定临界值**：使用皮尔逊 $\\chi^2$ 统计量来检验均匀性的原假设。此统计量的渐近参考分布是具有 $M$ 个自由度的卡方分布，即 $\\chi^2_M$。自由度的计算方法是箱体数（$M+1$）减 $1$，因为箱体概率是由原假设预先指定的，而不是从数据中估计的。如果计算出的统计量 $X^2$ 超过临界值 $q_{1-\\alpha}$，即 $\\chi^2_M$ 分布的 $(1-\\alpha)$-分位数，则拒绝原假设。此值是为每个测试案例预先计算的。\n\n3.  **蒙特卡洛重复实验**：对于 $R$ 次重复实验中的每一次：\n    a. **数据生成**：我们模拟 $N$ 个预报-验证对。对于每对 $j=1, \\dots, N$，我们生成 $M$ 个集合成员 $\\{e_{j,m}\\}_{m=1}^M$ 和一个验证观测值 $y_j$。根据问题的可靠性假设，所有 $M+1$ 个值都是从标准正态分布 $\\mathcal{N}(0, 1)$ 中独立抽取的。这种设置完美满足原假设。\n\n    b. **等级计算**：对于 $N$ 个对中的每一个，计算观测值 $y_j$ 相对于其对应集合成员的等级。等级 $R_j$ 是小于观测值的集合成员的数量：$R_j = \\sum_{m=1}^{M} \\mathbf{1}\\{e_{j,m}  y_j\\}$。由于底层分布是连续的，平局的概率为零，等级 $R_j$ 是集合 $\\{0, 1, \\dots, M\\}$ 中的一个整数。\n\n    c. **等级直方图**：将 $N$ 个计算出的等级聚合成一个等级直方图，该直方图包含 $M+1$ 个计数 $(O_0, O_1, \\dots, O_M)$，其中每个 $O_i$ 是等级等于 $i$ 的次数。\n\n    d. **卡方检验**：使用以下公式计算皮尔逊 $\\chi^2$ 统计量：\n    $$\n    X^2 = \\sum_{i=0}^{M} \\frac{(O_i - E_i)^2}{E_i}\n    $$\n    在这里，$O_i$ 是等级直方图中的观测计数。在均匀性的原假设下，每个箱体 $i$ 的期望计数是相同的：$E_i = N \\times p_i = N/(M+1)$。\n\n    e. **假设判定**：将计算出的 $X^2$ 值与预先确定的临界值 $q_{1-\\alpha}$进行比较。如果 $X^2 > q_{1-\\alpha}$，则在此次重复实验中拒绝原假设，并将拒绝计数器加一。\n\n4.  **偏差计算**：完成所有 $R$ 次重复实验后，经验I类错误拒绝率 $\\hat{\\rho}$ 被估计为总拒绝次数除以 $R$。然后，离散化偏差计算为该经验率与名义率的偏差：\n    $$\n    \\hat{b} = \\hat{\\rho} - \\alpha\n    $$\n\n整个过程在提供的Python程序中实现。使用固定的随机种子确保了模拟结果的可复现性。程序遍历指定的测试案例，为每个案例计算 $\\hat{b}$，并按要求格式化输出。为了提高计算效率，模拟是向量化的，允许在单次重复实验中同时计算所有 $N$ 个等级。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef run_simulation_vectorized(M, N, R, alpha, rng):\n    \"\"\"\n    Runs the vectorized Monte Carlo simulation for a single test case.\n\n    Args:\n        M (int): The ensemble size.\n        N (int): The number of forecast cases.\n        R (int): The number of Monte Carlo replicates.\n        alpha (float): The nominal significance level.\n        rng (numpy.random.Generator): The random number generator instance.\n\n    Returns:\n        float: The calculated discretization bias.\n    \"\"\"\n    num_bins = M + 1\n    rejection_count = 0\n    \n    # Degrees of freedom for the chi-squared test is M.\n    df = M\n    \n    # The chi-squared test is not defined for df=0, but problem constraints (M >= 1) prevent this.\n    if df == 0:\n        return -alpha\n\n    # Critical value from the asymptotic chi-squared distribution\n    critical_value = chi2.ppf(1 - alpha, df)\n    \n    expected_counts = N / num_bins\n    \n    for _ in range(R):\n        # Generate all random numbers for N forecast cases at once\n        ensemble_members = rng.standard_normal(size=(N, M))\n        observations = rng.standard_normal(size=(N, 1))\n        \n        # Calculate N ranks using vectorization and broadcasting.\n        # np.sum counts the number of ensemble members less than the observation for each case.\n        ranks = np.sum(ensemble_members  observations, axis=1)\n        \n        # Create the rank histogram (observed counts) using np.bincount.\n        # minlength ensures the array has M+1 bins even if high ranks don't occur.\n        observed_counts = np.bincount(ranks, minlength=num_bins)\n        \n        # Calculate Pearson's chi-squared statistic\n        if expected_counts > 0:\n            chi_sq_stat = np.sum((observed_counts - expected_counts)**2 / expected_counts)\n        else: # This case will not be reached given N>0.\n            chi_sq_stat = 0.0\n\n        # Perform the hypothesis test by comparing with the critical value\n        if chi_sq_stat > critical_value:\n            rejection_count += 1\n            \n    # Estimate the empirical Type I rejection rate\n    empirical_rejection_rate = rejection_count / R\n    \n    # Calculate the discretization bias\n    discretization_bias = empirical_rejection_rate - alpha\n    \n    return discretization_bias\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    Initializes parameters, iterates through test cases, and prints the final result.\n    \"\"\"\n    # Define fixed parameters from the problem statement\n    random_seed = 42\n    num_replicates = 500\n    \n    # Initialize the random number generator with a fixed seed for reproducibility\n    rng = np.random.default_rng(random_seed)\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (M, N, alpha)\n    test_cases = [\n        (1, 200, 0.1),\n        (2, 200, 0.1),\n        (10, 200, 0.1),\n        (50, 200, 0.1),\n        (50, 100, 0.1),\n    ]\n\n    results = []\n    for m_val, n_val, alpha_val in test_cases:\n        # Run the simulation for the current test case.\n        bias = run_simulation_vectorized(m_val, n_val, num_replicates, alpha_val, rng)\n        results.append(bias)\n\n    # Format the final output as a comma-separated list in brackets,\n    # with each result rounded to 4 decimal places.\n    formatted_results = [f'{res:.4f}' for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the main solver function.\nsolve()\n```"
        }
    ]
}