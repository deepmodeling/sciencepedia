{
    "hands_on_practices": [
        {
            "introduction": "要理解为什么需要尺度感知的参数化，我们首先必须量化能量在不同尺度间的传递。本练习通过构建一个二维湍流场的谱能量通量，来实践这一诊断过程。你将计算出在不同模式分辨率（由截断波数 $k_{\\Delta}$ 代表）下，有多少能量从可解尺度流向不可解的次网格尺度，从而直观地理解为什么一个有效的参数化方案必须能够根据其分辨率调整其耗散强度 。",
            "id": "4085750",
            "problem": "你的任务是构建一个科学上一致且可计算检验的度量，用于衡量模拟湍流中的谱能量通量，并利用它来评估参数化设计中的灰区尺度感知能力。考虑一个在边长为 $L = 2\\pi$（无量纲单位）的方形域上的不可压缩、均匀、各向同性、周期性的二维流。速度场 $\\mathbf{u}(x,y)$ 是无散度的，并由流函数 $\\psi(x,y)$ 通过关系式 $\\mathbf{u} = (\\partial \\psi / \\partial y,\\,-\\partial \\psi / \\partial x)$ 导出。无外力和粘性时的不可压缩Navier–Stokes方程为\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p,\n$$\n其中 $\\nabla\\cdot\\mathbf{u} = 0$。动能密度为 $E = \\tfrac{1}{2}\\,\\mathbf{u}\\cdot\\mathbf{u}$。谱能量收支可通过傅里叶变换到波数空间 $(k_x,k_y)$ 并投影到螺线（无散度）子空间以消除压力项来得到。波数大小为 $k = \\sqrt{k_x^2 + k_y^2}$ 处的非线性传递函数可以从平流加速度的螺线部分定义。在周期域上使用快速傅里叶变换（FFT）进行离散化后，每个模式的标量能量传递贡献通过速度模式与投影后的非线性模式的内积的实部获得，而按壳积分的传递则通过对所有径向波数落在整数壳层内的模式进行求和来计算。通过截断波数 $k_0$ 的谱能量通量 $\\Pi(k_0)$ 定义为波数大小大于 $k_0$ 的模式所接收到的累积非线性能量传递，即对所有 $k  k_0$ 的壳层进行离散求和。正的 $\\Pi(k_0)$ 表示净能量向未解析的小尺度正向传递，而负的 $\\Pi(k_0)$ 表示净能量向大尺度的逆向传递。\n\n你的程序必须：\n\n- 在一个 $N \\times N$（其中 $N = 256$，$L = 2\\pi$，无量纲单位）的网格上构建一个单一的高分辨率无散度速度场。这通过构建一个流函数 $\\psi(x,y)$ 来实现，该流函数是一组有限傅里叶模式的和，这些模式的波数大小在带 $k \\in [3,6]$ 内，具有随机相位，且振幅随 $k$ 的增加而衰减，以确保物理真实性和数值稳定性。\n- 通过 $\\psi$ 的谱导数计算速度场 $\\mathbf{u}$。\n- 使用谱导数计算 $\\nabla\\mathbf{u}$ 并在物理空间中进行逐点乘积，从而计算平流加速度 $\\mathbf{A} = (\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$。为减轻混叠，对非线性项应用三分之二截断规则：移除 $\\mathbf{A}$ 中所有 $|k_x|$ 或 $|k_y|$ 超过 $N/3$ 的傅里叶分量。\n- 使用投影算子 $\\mathbf{P}(\\mathbf{k}) = \\mathbf{I} - \\mathbf{k}\\mathbf{k}^{\\top} / |\\mathbf{k}|^2$（其中 $\\mathbf{k} = (k_x,k_y)$ 且 $|\\mathbf{k}|^2 = k_x^2 + k_y^2$），将 $\\mathbf{A}$ 的傅里叶变换对每个波数投影到螺线子空间上，并将零模式的贡献视为零。将用于能量传递的非线性项定义为 $\\widehat{\\mathbf{N}}(\\mathbf{k}) = -\\mathbf{P}(\\mathbf{k})\\,\\widehat{\\mathbf{A}}(\\mathbf{k})$。\n- 计算每个模式的谱能量传递 $T(\\mathbf{k})$，其值为内积 $T(\\mathbf{k}) = \\Re\\left[\\widehat{\\mathbf{u}}(\\mathbf{k})^* \\cdot \\widehat{\\mathbf{N}}(\\mathbf{k})\\right]$ 的实部。然后将 $T(\\mathbf{k})$ 分箱到整数壳层 $k_s = \\mathrm{round}(\\sqrt{k_x^2 + k_y^2}) \\in \\mathbb{N}$ 中，以获得对于 $k_s \\ge 1$ 的壳层求和传递 $T_s(k_s)$。\n- 对于给定的粗网格间距 $\\Delta = L / N_\\Delta$（其中 $N_\\Delta$ 为偶数整数分辨率），定义截断波数 $k_\\Delta = \\pi / \\Delta = N_\\Delta / 2$。使用刚刚构建的单一高分辨率场，计算谱能量通量 $\\Pi(k_\\Delta)$，其值为所有 $k_s  k_\\Delta$ 壳层的累积和，即 $\\Pi(k_\\Delta) = \\sum_{k_s  k_\\Delta} T_s(k_s)$（也就是说，总是通过对相应的高分辨率壳层求和，从同一个高分辨率 $N=256$ 场计算 $\\Pi(k_\\Delta)$）。\n- 所有输出均以无量纲单位表示，并四舍五入到六位小数。\n\n测试套件和输出规范：\n\n- 使用以下粗分辨率集合 $N_\\Delta$: $\\{16, 32, 64, 96, 128, 256\\}$。对于每个 $N_\\Delta$，计算 $k_\\Delta = N_\\Delta / 2$，然后根据上述定义从高分辨率场计算 $\\Pi(k_\\Delta)$。\n- 你的程序应生成单行输出，其中包含六个结果，格式为方括号内由逗号分隔的列表，顺序与提供的测试套件分辨率相同。例如，输出必须具有形式 $[\\pi_{16},\\pi_{32},\\pi_{64},\\pi_{96},\\pi_{128},\\pi_{256}]$，其中每个 $\\pi_{N_\\Delta}$ 是一个四舍五入到六位小数的十进制浮点数。\n\n解释要求（需在你的算法选择和注释中体现）：结果应在灰区中尺度感知参数化的背景下进行解释，其中 $k_\\Delta$ 随 $\\Delta$ 变化。当 $\\Delta$ 减小时，如果 $|\\Pi(k_\\Delta)|$ 减小，表明跨越到未解析尺度的净传递减少，这意味着一个尺度感知的闭合方案应随分辨率的提高而逐渐减小其贡献。相反，在粗分辨率下较大的 $|\\Pi(k_\\Delta)|$ 表示存在更强的未解析尺度传递，需要更强的参数化耗散。你的代码必须仅使用高分辨率场来执行指定的计算，并且不得执行任何时间积分。\n\n角度单位是弧度。所有量均为无量纲。最终输出必须是四舍五入到六位小数的浮点数。",
            "solution": "我们从周期域上的无量纲形式的不可压缩Navier–Stokes方程开始，\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p,\\quad \\nabla\\cdot\\mathbf{u}=0,\n$$\n动能密度为 $E = \\tfrac{1}{2}\\mathbf{u}\\cdot\\mathbf{u}$。进行傅里叶变换，我们定义波数向量 $\\mathbf{k} = (k_x,k_y)$，当物理域长度为 $L=2\\pi$ 时，其两个分量均为整数，因为当采样间距为 $d=L/N$ 时，使用快速傅里叶变换（FFT）得到的 $\\widehat{f}(\\mathbf{k})$ 是由整数波数索引的。由非线性平流引起的能量传递源于 $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$ 项，该项不是螺线项；压力梯度通过移除无旋分量来强制执行不可压缩性。因此，为了在每个波数上保持能量收支一致性，必须使用投影算子将平流加速度投影到螺线子空间上\n$$\n\\mathbf{P}(\\mathbf{k}) = \\mathbf{I} - \\frac{\\mathbf{k}\\mathbf{k}^{\\top}}{|\\mathbf{k}|^2},\\quad |\\mathbf{k}|^2 = k_x^2 + k_y^2,\n$$\n对于 $\\mathbf{k}\\neq\\mathbf{0}$，并将零模式对能量传递的贡献视为零。\n\n定义平流加速度 $\\mathbf{A} = (\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$。在谱空间中，这是通过伪谱法计算的：我们通过FFT评估空间导数（这使得谱导数变为与 $\\mathrm{i}k_x$ 和 $\\mathrm{i}k_y$ 的乘法），在物理空间中形成乘积，然后变换回去。为了减轻离散非线性乘积固有的混叠误差，我们应用三分之二截断规则，该规则将非线性项中 $|k_x|$ 或 $|k_y|$ 超过 $N/3$ 的傅里叶分量置零；这消除了会混叠回解析范围内的三元相互作用。\n\n进入谱能量传递的投影非线性项是\n$$\n\\widehat{\\mathbf{N}}(\\mathbf{k}) = -\\mathbf{P}(\\mathbf{k})\\,\\widehat{\\mathbf{A}}(\\mathbf{k}),\\quad \\mathbf{k}\\neq\\mathbf{0},\n$$\n其中 $\\widehat{\\mathbf{N}}(\\mathbf{0})$ 取为零。每个模式的瞬时谱能量传递为\n$$\nT(\\mathbf{k}) = \\Re\\left[\\widehat{\\mathbf{u}}(\\mathbf{k})^*\\cdot \\widehat{\\mathbf{N}}(\\mathbf{k})\\right],\n$$\n其中点乘是速度分量上的欧几里得内积，星号表示复共轭。因为非线性项在不同尺度间重新分配能量而不产生或消灭能量，我们期望所有模式的总和满足 $\\sum_{\\mathbf{k}} T(\\mathbf{k}) \\approx 0$（在数值截断和混叠减轻的精度内）。\n\n然后我们通过整数径向波数定义各向同性壳层\n$$\nk_s = \\mathrm{round}\\left(\\sqrt{k_x^2+k_y^2}\\right),\\quad k_s\\in\\mathbb{N}.\n$$\n按壳积分的传递为\n$$\nT_s(k_s) = \\sum_{\\mathbf{k}: \\mathrm{round}(|\\mathbf{k}|)=k_s} T(\\mathbf{k}),\\quad k_s\\ge 1.\n$$\n给定一个粗分辨率 $N_\\Delta$，其格距为 $\\Delta = L/N_\\Delta$，截断波数为\n$$\nk_\\Delta = \\frac{\\pi}{\\Delta} = \\frac{N_\\Delta}{2},\n$$\n通过 $k_\\Delta$ 的谱能量通量是进入截断波数之外模式的累积传递：\n$$\n\\Pi(k_\\Delta) = \\sum_{k_sk_\\Delta} T_s(k_s).\n$$\n这个定义与正向通量约定一致：正的 $\\Pi(k_\\Delta)$ 表示向未解析的小尺度（$kk_\\Delta$）的净传递，而负的 $\\Pi(k_\\Delta)$ 表示向更大尺度（逆向传递）的净传递。在二维湍流中，能量串级通常是逆向的（朝向小 $k$），而拟能串级是正向的（朝向大 $k$），因此根据瞬时流场的具体实现，获得 $\\Pi(k_\\Delta)0$ 是可能且物理上合理的。\n\n算法步骤：\n\n$1.$ 在一个 $N\\times N$（其中 $N=256$，$L=2\\pi$）的网格上构建一个单一的高分辨率流函数 $\\psi(x,y)$。选择一组整数波数对 $(k_x,k_y)$，其大小在 $[3,6]$ 范围内，并赋以随机相位。为确保物理真实性，选择随波数大小衰减的振幅，例如与 $1/(k_x^2+k_y^2)$ 成正比。将 $\\psi$ 构建为余弦模式的和\n$$\n\\psi(x,y) = \\sum_{m=1}^{M} a_m \\cos(k_{x,m} x + k_{y,m} y + \\phi_m),\n$$\n其中 $M$ 为有限值。这种构造确保 $\\psi$ 是实数且光滑的。\n\n$2.$ 使用 $\\widehat{u}_x = \\mathrm{i}k_y\\widehat{\\psi}$ 和 $\\widehat{u}_y = -\\mathrm{i}k_x\\widehat{\\psi}$ 在谱空间中计算速度，然后进行逆FFT以获得 $u_x(x,y)$ 和 $u_y(x,y)$。\n\n$3.$ 使用谱微分法计算 $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$ 所需的空间导数：变换 $\\widehat{u}_x$ 和 $\\widehat{u}_y$ 并乘以 $\\mathrm{i}k_x$ 或 $\\mathrm{i}k_y$ 以获得 $\\partial u_x/\\partial x$、$\\partial u_x/\\partial y$、$\\partial u_y/\\partial x$ 和 $\\partial u_y/\\partial y$，然后进行逆FFT到物理空间。\n\n$4.$ 在物理空间中构建非线性平流项：\n$$\nA_x = u_x \\frac{\\partial u_x}{\\partial x} + u_y \\frac{\\partial u_x}{\\partial y},\\quad\nA_y = u_x \\frac{\\partial u_y}{\\partial x} + u_y \\frac{\\partial u_y}{\\partial y}.\n$$\n对这些项进行FFT以获得 $\\widehat{A}_x$ 和 $\\widehat{A}_y$。通过将 $|k_x|N/3$ 或 $|k_y|N/3$ 处的 $\\widehat{A}$ 置零来应用三分之二规则。\n\n$5.$ 投影到螺线子空间：\n$$\n\\widehat{\\mathbf{N}}(\\mathbf{k}) = -\\left(\\widehat{\\mathbf{A}}(\\mathbf{k}) - \\frac{\\mathbf{k}(\\mathbf{k}\\cdot \\widehat{\\mathbf{A}}(\\mathbf{k}))}{|\\mathbf{k}|^2}\\right),\\quad \\mathbf{k}\\neq \\mathbf{0},\n$$\n并设置 $\\widehat{\\mathbf{N}}(\\mathbf{0})=\\mathbf{0}$。\n\n$6.$ 计算每个模式的传递\n$$\nT(\\mathbf{k}) = \\Re\\left[\\widehat{u}_x(\\mathbf{k})^*\\,\\widehat{N}_x(\\mathbf{k}) + \\widehat{u}_y(\\mathbf{k})^*\\,\\widehat{N}_y(\\mathbf{k})\\right],\n$$\n并分箱到壳层 $k_s=\\mathrm{round}(|\\mathbf{k}|)$ 以形成对于 $k_s\\ge 1$ 的 $T_s(k_s)$。\n\n$7.$ 对于测试套件中的每个 $N_\\Delta$，设置 $k_\\Delta = N_\\Delta/2$，并计算\n$$\n\\Pi(k_\\Delta) = \\sum_{k_sk_\\Delta} T_s(k_s).\n$$\n\n灰区尺度感知的基于原理的解释：在数值天气预报和气候模拟中，尺度感知参数化方案应随分辨率的变化而调节其效果。在这里，$k_\\Delta$ 标记了给定分辨率下已解析尺度和未解析尺度之间的过渡。如果随着 $\\Delta$ 减小（等效于 $N_\\Delta$ 增大），$|\\Pi(k_\\Delta)|$ 也减小，那么非线性项向未解析范围传递的能量就更少，这表明模拟次网格耗散的参数化方案应随着分辨率的提高而强度减弱。相反，在粗分辨率下较大的 $|\\Pi(k_\\Delta)|$ 表示需要更强的参数化阻尼。符号传达了串级方向：负的 $\\Pi(k_\\Delta)$ 表明存在逆向能量传递（在二维流中很典型），因此一个朴素的正向能量耗散闭合方案可能不合适；相反，人们可能需要以移除拟能为目标，同时保持大尺度能量。该算法从单个高分辨率流场快照计算 $\\Pi(k_\\Delta)$，这足以说明对灰区参数化设计至关重要的分辨率依赖性。\n\n数值方面：使用FFT确保了与周期性边界一致的精确谱导数。三分之二规则限制了混叠，从而在计算传递时保持了保真度。通过整数半径进行壳层分箱可产生各向同性谱。输出是无量纲的，并四舍五入到六位小数。最终程序计算并打印对应于 $N_\\Delta \\in \\{16,32,64,96,128,256\\}$ 的 $[\\Pi(8), \\Pi(16), \\Pi(32), \\Pi(48), \\Pi(64), \\Pi(128)]$，其中每个 $\\Pi(k_\\Delta)$ 都是从相同的高分辨率场计算得出的。",
            "answer": "```python\nimport numpy as np\n\ndef construct_streamfunction(N, L, seed=42, num_modes=20, kmin=3, kmax=6, amp0=1.0):\n    \"\"\"\n    Construct a real-valued streamfunction psi(x,y) on an N x N grid over [0,L)^2,\n    as a sum of cosine modes with wavenumbers in [kmin, kmax] and random phases.\n    Amplitude decays with k^2 for smoothness.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    x = np.linspace(0.0, L, N, endpoint=False)\n    y = np.linspace(0.0, L, N, endpoint=False)\n    X, Y = np.meshgrid(x, y, indexing='xy')\n\n    # Select unique integer wavenumber pairs in the annulus k in [kmin, kmax]\n    modes = set()\n    # Enumerate all candidate integer pairs in the range and sample until num_modes\n    candidates = []\n    for kx in range(-kmax, kmax + 1):\n        for ky in range(-kmax, kmax + 1):\n            if kx == 0 and ky == 0:\n                continue\n            kmag = np.sqrt(kx**2 + ky**2)\n            if kmin = kmag = kmax:\n                candidates.append((kx, ky))\n    rng.shuffle(candidates)\n    idx = 0\n    while len(modes)  num_modes and idx  len(candidates):\n        modes.add(candidates[idx])\n        idx += 1\n    if len(modes)  num_modes:\n        # If not enough unique modes, reuse random picks with possible duplicates (harmless)\n        while len(modes)  num_modes:\n            kx, ky = rng.choice(candidates)\n            modes.add((kx, ky))\n\n    psi = np.zeros((N, N), dtype=np.float64)\n    for (kx, ky) in list(modes)[:num_modes]:\n        phase = rng.uniform(0.0, 2.0 * np.pi)\n        kmag2 = kx**2 + ky**2\n        amplitude = amp0 / (kmag2 if kmag2 > 0 else 1.0)\n        psi += amplitude * np.cos(kx * X + ky * Y + phase)\n\n    return psi\n\ndef fft_wavenumbers(N, L):\n    \"\"\"\n    Compute FFT wavenumbers for domain length L. Returns kx, ky grids and 1D vectors.\n    For L=2*pi and d=L/N, the radian wavenumbers are integers.\n    \"\"\"\n    dx = L / N\n    k1d = 2.0 * np.pi * np.fft.fftfreq(N, d=dx)  # radian wavenumbers\n    kx = k1d.reshape(N, 1) * np.ones((1, N))\n    ky = k1d.reshape(1, N) * np.ones((N, 1))\n    return kx, ky, k1d\n\ndef spectral_derivative(field_hat, kx, ky, comp='x'):\n    \"\"\"\n    Compute spectral derivative of a Fourier-transformed field w.r.t. x or y.\n    comp: 'x' or 'y'\n    \"\"\"\n    if comp == 'x':\n        return 1j * kx * field_hat\n    elif comp == 'y':\n        return 1j * ky * field_hat\n    else:\n        raise ValueError(\"comp must be 'x' or 'y'\")\n\ndef project_solenoidal(Ax_hat, Ay_hat, kx, ky):\n    \"\"\"\n    Project the vector Fourier field A_hat onto the solenoidal subspace:\n    N_hat = -(A_hat - k (k·A_hat)/|k|^2)\n    with zero mode handled specially.\n    \"\"\"\n    ksq = kx**2 + ky**2\n    kdotA = kx * Ax_hat + ky * Ay_hat\n    with np.errstate(divide='ignore', invalid='ignore'):\n        coeff = np.where(ksq != 0.0, kdotA / ksq, 0.0)\n    PxAx = Ax_hat - kx * coeff\n    PxAy = Ay_hat - ky * coeff\n    Nx_hat = -PxAx\n    Ny_hat = -PxAy\n    # Ensure zero mode is zero\n    zero_mask = (ksq == 0.0)\n    Nx_hat[zero_mask] = 0.0 + 0.0j\n    Ny_hat[zero_mask] = 0.0 + 0.0j\n    return Nx_hat, Ny_hat\n\ndef two_thirds_dealias_mask(kx, ky, N):\n    \"\"\"\n    Two-thirds rule mask: keep modes where both |kx| = kc and |ky| = kc, with kc = N/3 in integer units\n    since kx, ky are integers when L=2*pi.\n    \"\"\"\n    kc = N / 3.0\n    return (np.abs(kx) = kc)  (np.abs(ky) = kc)\n\ndef compute_transfer_shells(psi, N, L):\n    \"\"\"\n    Compute shell-integrated nonlinear energy transfer T_s(k_s) from a streamfunction psi.\n    Returns T_shell (1D array), shell_indices (array of integer shell numbers), and k magnitude grid.\n    \"\"\"\n    # Wavenumbers\n    kx, ky, k1d = fft_wavenumbers(N, L)\n    # FFT of psi\n    psi_hat = np.fft.fft2(psi)\n    # Velocity in spectral space\n    ux_hat = 1j * ky * psi_hat\n    uy_hat = -1j * kx * psi_hat\n    # Physical velocity fields\n    ux = np.fft.ifft2(ux_hat).real\n    uy = np.fft.ifft2(uy_hat).real\n    # Derivatives of velocity components via spectral differentiation\n    dux_dx_hat = spectral_derivative(ux_hat, kx, ky, comp='x')\n    dux_dy_hat = spectral_derivative(ux_hat, kx, ky, comp='y')\n    duy_dx_hat = spectral_derivative(uy_hat, kx, ky, comp='x')\n    duy_dy_hat = spectral_derivative(uy_hat, kx, ky, comp='y')\n    dux_dx = np.fft.ifft2(dux_dx_hat).real\n    dux_dy = np.fft.ifft2(dux_dy_hat).real\n    duy_dx = np.fft.ifft2(duy_dx_hat).real\n    duy_dy = np.fft.ifft2(duy_dy_hat).real\n    # Advective term in physical space\n    Ax = ux * dux_dx + uy * dux_dy\n    Ay = ux * duy_dx + uy * duy_dy\n    # Transform to spectral space\n    Ax_hat = np.fft.fft2(Ax)\n    Ay_hat = np.fft.fft2(Ay)\n    # Two-thirds dealiasing on nonlinear term\n    mask = two_thirds_dealias_mask(kx, ky, N)\n    Ax_hat = Ax_hat * mask\n    Ay_hat = Ay_hat * mask\n    # Project onto solenoidal subspace and negate\n    Nx_hat, Ny_hat = project_solenoidal(Ax_hat, Ay_hat, kx, ky)\n    # Energy transfer per mode: Re(u_hat* · N_hat)\n    T_mode = np.real(np.conj(ux_hat) * Nx_hat + np.conj(uy_hat) * Ny_hat)\n    # Shell binning by integer-rounded radial wavenumber\n    kr = np.sqrt(kx**2 + ky**2)\n    k_shell = np.rint(kr).astype(int)\n    # Exclude shell 0\n    valid = (k_shell >= 1)\n    k_shell_flat = k_shell[valid].flatten()\n    T_mode_flat = T_mode[valid].flatten()\n    # Maximum shell index present\n    kmax_shell = k_shell_flat.max() if k_shell_flat.size > 0 else 0\n    # Bin transfers into shells\n    T_shell = np.bincount(k_shell_flat, weights=T_mode_flat, minlength=kmax_shell + 1)\n    return T_shell\n\ndef compute_fluxes_for_resolutions(T_shell, resolutions):\n    \"\"\"\n    Given shell-integrated transfers T_shell and a list of N_delta resolutions,\n    compute Pi(k_delta) = sum_{k > k_delta} T_shell[k].\n    \"\"\"\n    kmax = len(T_shell) - 1\n    fluxes = []\n    for N_delta in resolutions:\n        k_delta = N_delta // 2  # since N_delta is even\n        # Sum over shells greater than k_delta, ensure within bounds\n        start = min(kmax + 1, k_delta + 1)\n        flux = float(np.sum(T_shell[start:]))\n        fluxes.append(flux)\n    return fluxes\n\ndef solve():\n    # Domain and base resolution\n    N = 256\n    L = 2.0 * np.pi\n\n    # Construct a single high-resolution streamfunction and velocity field\n    psi = construct_streamfunction(N=N, L=L, seed=42, num_modes=20, kmin=3, kmax=6, amp0=1.0)\n\n    # Compute shell-integrated transfer from the nonlinear term\n    T_shell = compute_transfer_shells(psi, N, L)\n\n    # Test suite resolutions and corresponding k_delta\n    test_resolutions = [16, 32, 64, 96, 128, 256]\n\n    # Compute fluxes Pi(k_delta) for each resolution using the same high-resolution field\n    fluxes = compute_fluxes_for_resolutions(T_shell, test_resolutions)\n\n    # Format output: floats rounded to six decimal places\n    formatted = [f\"{f:.6f}\" for f in fluxes]\n    print(f\"[{','.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "当数值模式的分辨率进入“灰色地带”时，一个常见的陷阱是“双重计算”：模式自身开始解析一部分湍流输送，而参数化方案可能仍在模拟同一部分的输送。本练习旨在通过构建一个“双重计算指数”（DCI）来诊断垂直动量输送中的这一问题。你将实现一个诊断工具，用于比较一个简化的解析输送项和一个传统的参数化倾向项，并量化它们在不同水平网格间距 $\\Delta x$ 下的重叠程度 。",
            "id": "4085719",
            "problem": "您的任务是构建并实现一种诊断工具，通过在不同水平网格间距下比较解析通量散度与参数化趋势项，来检测大气“灰色地带”中垂直动量输送的重复计算问题。灰色地带指的是这样的尺度范围：一部分湍流输送由模式动力过程解析，而另一部分仍由参数化方案表示，这可能导致重复计算。您的程序必须计算一个用于衡量此重复计算的定量指数，并针对指定的测试套件报告该指数。\n\n基本原理：\n- 从 Reynolds平均Navier-Stokes (RANS) 动量方程出发，其中水平动量的垂直输送项涉及垂直湍流通量的散度。对于水平风分量的一维垂直形式，一个解析趋势项与解析的垂直动量通量的散度相关联。\n- 常见的参数化方案使用涡粘性（一阶闭合）来表示未解析的垂直动量输送，从而产生一个与动量垂直扩散通量散度成正比的参数化趋势项。\n\n定义与设置：\n- 考虑一个一维垂直气柱，其垂直坐标为 $z$，总深度为 $H$，离散为 $N$ 个等距层次 $z_i$（其中 $i = 0, 1, \\dots, N-1$），间距为 $\\Delta z = H/(N-1)$。\n- 设 $F_{\\text{res}}(z; \\Delta x)$ 表示在尺度 $\\Delta x$ 下模拟的水平动量解析垂直通量（垂直和水平速度脉动的协方差）。假设该通量具有以下形式\n$$\nF_{\\text{res}}(z; \\Delta x) = S(\\Delta x)\\, F_0 \\exp\\!\\left(-\\frac{z}{H_e}\\right),\n$$\n其中 $F_0$ 是一个单位为 $\\mathrm{m^2\\,s^{-2}}$ 的地面层通量尺度，$H_e$ 是一个单位为 $\\mathrm{m}$ 的垂直e-折叠尺度，$S(\\Delta x)$ 是一个尺度划分函数，用于表征在水平网格间距 $\\Delta x$ 下湍流输送的解析部分。使用\n$$\nS(\\Delta x) = \\frac{1}{1 + \\left(\\frac{\\Delta x}{L_t}\\right)^p},\n$$\n其中 $L_t$ 是一个单位为 $\\mathrm{m}$ 的湍流长度尺度，$p$ 是一个正指数。\n- 设 $K_m(z)$ 表示涡粘性廓线，单位为 $\\mathrm{m^2\\,s^{-1}}$：\n$$\nK_m(z) = K_0 \\left(\\frac{z}{H}\\right) \\exp\\!\\left(-\\frac{z}{H_k}\\right),\n$$\n其中 $K_0$ 是一个尺度振幅，$H_k$ 是一个垂直衰减尺度。\n- 设平均水平风廓线为\n$$\nu(z) = U_0 \\left(1 - \\exp\\!\\left(-\\frac{z}{z_0}\\right)\\right),\n$$\n其中 $U_0$ 是一个单位为 $\\mathrm{m\\,s^{-1}}$ 的速度尺度，$z_0$ 是一个单位为 $\\mathrm{m}$ 的切变尺度。\n\n诊断量：\n- 将由解析的垂直动量输送引起的解析趋势项定义为\n$$\nT_{\\text{res}}(z) = -\\frac{\\partial F_{\\text{res}}(z; \\Delta x)}{\\partial z}.\n$$\n- 使用涡粘性闭合，将参数化趋势项（未经调整，即没有任何尺度感知划分）定义为\n$$\nT_{\\text{param}}(z) = -\\frac{\\partial}{\\partial z}\\left( K_m(z)\\, \\frac{\\partial u}{\\partial z} \\right).\n$$\n- 构建一个重复计算指数 (DCI)，该指数衡量两个趋势项在符号相同（相互加强）时的重叠程度，并用它们的总量级进行归一化：\n$$\n\\mathrm{DCI} = \\frac{\\sum_{i=0}^{N-1} \\left[ \\mathcal{H}\\!\\left(T_{\\text{res},i}\\, T_{\\text{param},i}\\right) \\cdot \\min\\!\\left(\\left|T_{\\text{res},i}\\right|, \\left|T_{\\text{param},i}\\right|\\right) \\right]}{\\sum_{i=0}^{N-1} \\left( \\left|T_{\\text{res},i}\\right| + \\left|T_{\\text{param},i}\\right| \\right)},\n$$\n其中 $\\mathcal{H}(\\cdot)$ 是Heaviside阶跃函数，当其参数严格为正时取值为1，否则为0。如果分母为零，按照约定定义 $\\mathrm{DCI} = 0$。DCI 是一个在 $[0, 0.5]$ 区间内的无量纲小数。\n\n数值计算要求：\n- 使用二阶精度有限差分来近似所有需要的垂直导数，在边界 $z=0$ 和 $z=H$ 处使用单侧差分。对于内部点 $z_i$（其中 $i=1$ 到 $i=N-2$），使用中心差分。在边界处，使用与网格间距 $\\Delta z$ 相符的一阶单侧差分。\n- 不要对 $T_{\\text{param}}(z)$ 应用任何尺度划分；该诊断工具的目的是检测由于朴素的参数化趋势项随着 $\\Delta x$ 变化而与解析趋势项重叠所产生的重复计算。\n- 所有物理单位必须保持一致：$z$、$H$、$H_e$、$H_k$、$L_t$ 和 $z_0$ 的单位为 $\\mathrm{m}$；$U_0$ 的单位为 $\\mathrm{m\\,s^{-1}}$；$K_0$ 的单位为 $\\mathrm{m^2\\,s^{-1}}$；$F_0$ 的单位为 $\\mathrm{m^2\\,s^{-2}}$；趋势项 $T_{\\text{res}}$ 和 $T_{\\text{param}}$ 的单位为 $\\mathrm{m\\,s^{-2}}$。最终的 DCI 是无量纲的，并且必须表示为小数。\n\n参数值：\n- 使用 $H = 2000\\,\\mathrm{m}$，$N = 64$，$F_0 = 0.3\\,\\mathrm{m^2\\,s^{-2}}$，$H_e = 600\\,\\mathrm{m}$，$K_0 = 10\\,\\mathrm{m^2\\,s^{-1}}$，$H_k = 500\\,\\mathrm{m}$，$U_0 = 15\\,\\mathrm{m\\,s^{-1}}$，$z_0 = 100\\,\\mathrm{m}$，$L_t = 400\\,\\mathrm{m}$，以及 $p = 1.5$。对于一个对流边界层情景，这些值在科学上是合理的。\n\n测试套件：\n实现该诊断工具并为以下四种情况计算 $\\mathrm{DCI}$：\n- 情况A（理想路径）：$\\Delta x = 1000\\,\\mathrm{m}$，使用上述指定的基线参数。\n- 情况B（细网格灰色地带）：$\\Delta x = 250\\,\\mathrm{m}$，使用上述指定的基线参数。\n- 情况C（粗网格极限）：$\\Delta x = 8000\\,\\mathrm{m}$，使用上述指定的基线参数。\n- 情况D（边界情况：无输送）：$\\Delta x = 1000\\,\\mathrm{m}$，但设置 $F_0 = 0.0\\,\\mathrm{m^2\\,s^{-2}}$ 和 $U_0 = 0.0\\,\\mathrm{m\\,s^{-1}}$；所有其他参数与基线相同。根据给定的约定，这种情况应得出诊断值为 $0.0$。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含情况 A-D 的四个 $\\mathrm{DCI}$ 值，格式为用方括号括起来的逗号分隔列表，每个值四舍五入到六位小数（例如，$[0.123456,0.234567,0.000000,0.456789]$）。DCI 必须表示为不带百分号的小数。",
            "solution": "此任务基于 Reynolds平均Navier-Stokes (RANS) 动量方程，其中水平风分量的垂直动量输送由垂直湍流通量的散度表示。在一维垂直气柱中，与湍流输送相关的解析趋势项由 $-\\partial F_{\\text{res}}/\\partial z$ 给出，其中 $F_{\\text{res}}$ 是解析的垂直动量通量。同时，参数化方案通过涡粘性闭合来近似未解析的湍流输送，得出的参数化趋势项为 $-\\partial/\\partial z(K_m\\, \\partial u/\\partial z)$。\n\n在灰色地带，随着水平网格间距 $\\Delta x$ 的减小，湍流输送的解析部分会增加，而参数化方案通常会继续施加一个相当大的趋势项。如果在给定层次中，解析趋势项和参数化趋势项作用方向相同（即符号相同），它们的综合效应可能会重复计算输送。所提出的重复计算指数 (DCI) 仅在两个趋势项相互加强时量化其重叠的量级，并用它们的总量级进行归一化。这产生了一个无量纲小数，当没有重叠加强时为零，当两个趋势项完全相同且作用方向一致时，该值趋向上限 $0.5$。\n\n分步推导与算法：\n\n1) 垂直离散化：\n- 定义 $N$ 个等距层次 $z_i$，其中 $z_0 = 0$，$z_{N-1} = H$，间距为 $\\Delta z = H/(N-1)$。\n\n2) 解析通量模型：\n- 使用尺度划分函数 $S(\\Delta x) = 1/(1 + (\\Delta x/L_t)^p)$ 来表示在给定水平网格间距 $\\Delta x$、湍流长度尺度 $L_t$ 和指数 $p$ 的情况下，被解析的湍流输送部分。\n- 定义解析的垂直动量通量：\n$$\nF_{\\text{res}}(z_i; \\Delta x) = S(\\Delta x)\\, F_0 \\exp\\!\\left(-\\frac{z_i}{H_e}\\right).\n$$\n这捕捉了一个近地层增强、随高度衰减并与解析部分成比例变化的通量。\n\n3) 涡粘性参数化与平均风廓线：\n- 定义 $K_m(z_i) = K_0 (z_i/H)\\exp(-z_i/H_k)$，表示从地表开始增长然后在高空衰减的混合作用。\n- 定义平均风 $u(z_i) = U_0 (1 - \\exp(-z_i/z_0))$，该风速从地表附近的零值开始增加，趋向于由 $U_0$ 设定的渐近值。\n\n4) 数值微分：\n- 使用二阶精度有限差分计算 $\\partial F_{\\text{res}}/\\partial z$：\n  - 对于内部点 $i = 1, \\dots, N-2$，使用中心差分\n  $$\n  \\left.\\frac{\\partial F_{\\text{res}}}{\\partial z}\\right|_{z_i} \\approx \\frac{F_{\\text{res}}(z_{i+1}) - F_{\\text{res}}(z_{i-1})}{2\\Delta z}.\n  $$\n  - 对于边界，使用单侧差分：\n  $$\n  \\left.\\frac{\\partial F_{\\text{res}}}{\\partial z}\\right|_{z_0} \\approx \\frac{F_{\\text{res}}(z_{1}) - F_{\\text{res}}(z_{0})}{\\Delta z}, \\quad\n  \\left.\\frac{\\partial F_{\\text{res}}}{\\partial z}\\right|_{z_{N-1}} \\approx \\frac{F_{\\text{res}}(z_{N-1}) - F_{\\text{res}}(z_{N-2})}{\\Delta z}.\n  $$\n- 类似地，通过在内部点使用中心差分和在边界使用单侧差分来计算 $\\partial u/\\partial z$。\n- 在每个层次上形成动量扩散通量 $K_m\\, \\partial u/\\partial z$，然后使用相同的有限差分格式计算其垂直导数 $\\partial/\\partial z(K_m\\, \\partial u/\\partial z)$。\n\n5) 趋势项：\n- 解析趋势项为\n$$\nT_{\\text{res}}(z_i) = -\\left.\\frac{\\partial F_{\\text{res}}}{\\partial z}\\right|_{z_i}.\n$$\n- 参数化趋势项（朴素、未经调整）为\n$$\nT_{\\text{param}}(z_i) = -\\left.\\frac{\\partial}{\\partial z}\\left( K_m\\, \\frac{\\partial u}{\\partial z} \\right)\\right|_{z_i}.\n$$\n\n6) 重复计算指数 (DCI)：\n- 将Heaviside函数 $\\mathcal{H}(x)$ 定义为：如果 $x  0$，则为1，否则为0。\n- 计算\n$$\n\\mathrm{DCI} = \\frac{\\sum_{i=0}^{N-1} \\left[ \\mathcal{H}\\!\\left(T_{\\text{res},i}\\, T_{\\text{param},i}\\right) \\cdot \\min\\!\\left(\\left|T_{\\text{res},i}\\right|, \\left|T_{\\text{param},i}\\right|\\right) \\right]}{\\sum_{i=0}^{N-1} \\left( \\left|T_{\\text{res},i}\\right| + \\left|T_{\\text{param},i}\\right| \\right)}.\n$$\n- 如果分母为零（即两个趋势项在所有地方都为零），则设置 $\\mathrm{DCI} = 0$。\n\n7) 解释：\n- $\\mathrm{DCI} \\in [0, 0.5]$，因为在每个层次上，重叠贡献的上界是两个量级中的较小者，而分母是两个量级之和。\n- 较大的 $\\mathrm{DCI}$ 表示由同向作用的重叠趋势项引起的潜在重复计算更严重。\n- 随着 $\\Delta x$ 减小，$S(\\Delta x)$ 增大，从而增强了 $F_{\\text{res}}$ 和 $T_{\\text{res}}$，因此朴素的 $T_{\\text{param}}$ 更可能发生重叠并导致 $\\mathrm{DCI}$ 增大。\n- 随着 $\\Delta x$ 增大（网格更粗），$S(\\Delta x)$ 减小，从而减小了 $T_{\\text{res}}$，导致重叠减小和 $\\mathrm{DCI}$ 减小。\n\n8) 测试套件执行：\n- 对于情况 A-C，使用指定的基线参数 $H = 2000\\,\\mathrm{m}$，$N = 64$，$F_0 = 0.3\\,\\mathrm{m^2\\,s^{-2}}$，$H_e = 600\\,\\mathrm{m}$，$K_0 = 10\\,\\mathrm{m^2\\,s^{-1}}$，$H_k = 500\\,\\mathrm{m}$，$U_0 = 15\\,\\mathrm{m\\,s^{-1}}$，$z_0 = 100\\,\\mathrm{m}$，$L_t = 400\\,\\mathrm{m}$，$p = 1.5$，并将 $\\Delta x$ 分别设置为 $1000\\,\\mathrm{m}$、$250\\,\\mathrm{m}$ 和 $8000\\,\\mathrm{m}$。对于情况 D，设置 $F_0 = 0.0\\,\\mathrm{m^2\\,s^{-2}}$ 和 $U_0 = 0.0\\,\\mathrm{m\\,s^{-1}}$，同时保持 $\\Delta x = 1000\\,\\mathrm{m}$ 和其他参数不变。\n- 计算每个 $\\mathrm{DCI}$ 并四舍五入到六位小数。\n\n9) 输出：\n- 打印单行，其中包含列表 $[\\mathrm{DCI}_A, \\mathrm{DCI}_B, \\mathrm{DCI}_C, \\mathrm{DCI}_D]$，作为用方括号括起来的逗号分隔小数，每个都四舍五入到六位小数，并符合指定的单位和格式要求。\n\n该算法将来自Reynolds平均表述的垂直动量输送基本物理原理与一个实用的、尺度感知的诊断工具相结合，该诊断工具通过二阶有限差分在数值上是稳健的，并能为不同 $\\Delta x$ 下的重复计算提供一个可量化的、无量纲的度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef finite_difference_first_derivative(y, dz):\n    \"\"\"\n    Compute first derivative dy/dz using second-order accurate scheme\n    with centered differences in the interior and one-sided at boundaries.\n    y: array of length N\n    dz: scalar grid spacing\n    Returns dy_dz: array of length N\n    \"\"\"\n    N = y.size\n    dy_dz = np.empty_like(y)\n\n    if N  2:\n        # Degenerate case; no derivative possible\n        dy_dz[:] = 0.0\n        return dy_dz\n\n    # One-sided difference at bottom boundary\n    dy_dz[0] = (y[1] - y[0]) / dz\n    # Centered differences in the interior\n    if N > 2:\n        dy_dz[1:-1] = (y[2:] - y[:-2]) / (2.0 * dz)\n    else:\n        # If N == 2, we only have boundaries\n        pass\n    # One-sided difference at top boundary\n    dy_dz[-1] = (y[-1] - y[-2]) / dz\n\n    return dy_dz\n\ndef compute_profiles(H, N, F0, He, K0, Hk, U0, z0, Lt, p, dx):\n    \"\"\"\n    Compute vertical profiles for z, Fres(z; dx), Km(z), u(z).\n    \"\"\"\n    z = np.linspace(0.0, H, N)\n    dz = z[1] - z[0] if N > 1 else 1.0\n\n    # Scale-partition function S(dx)\n    S = 1.0 / (1.0 + (dx / Lt) ** p)\n\n    # Resolved vertical momentum flux Fres(z; dx)\n    Fres = S * F0 * np.exp(-z / He)\n\n    # Eddy viscosity profile Km(z)\n    Km = K0 * (z / H) * np.exp(-z / Hk)\n\n    # Mean wind profile u(z)\n    u = U0 * (1.0 - np.exp(-z / z0))\n\n    return z, dz, Fres, Km, u\n\ndef compute_tendencies(z, dz, Fres, Km, u):\n    \"\"\"\n    Compute Tres(z) = - dFres/dz and Tparam(z) = - d/dz ( Km * du/dz ).\n    \"\"\"\n    # dFres/dz\n    dF_dz = finite_difference_first_derivative(Fres, dz)\n    Tres = -dF_dz\n\n    # du/dz\n    du_dz = finite_difference_first_derivative(u, dz)\n    # Diffusive flux of momentum: Km * du/dz\n    diff_flux = Km * du_dz\n    # d/dz of diffusive flux\n    d_diff_flux_dz = finite_difference_first_derivative(diff_flux, dz)\n    Tparam = -d_diff_flux_dz\n\n    return Tres, Tparam\n\ndef double_counting_index(Tres, Tparam):\n    \"\"\"\n    Compute DCI as sum(H(Tres*Tparam) * min(|Tres|, |Tparam|)) / sum(|Tres| + |Tparam|)\n    If denominator is zero, return 0.0\n    \"\"\"\n    overlap_mask = (Tres * Tparam) > 0.0\n    overlap_contrib = np.minimum(np.abs(Tres), np.abs(Tparam))\n    numerator = np.sum(overlap_contrib[overlap_mask])\n    denominator = np.sum(np.abs(Tres) + np.abs(Tparam))\n    if denominator == 0.0:\n        return 0.0\n    return numerator / denominator\n\ndef run_case(H, N, F0, He, K0, Hk, U0, z0, Lt, p, dx):\n    z, dz, Fres, Km, u = compute_profiles(H, N, F0, He, K0, Hk, U0, z0, Lt, p, dx)\n    Tres, Tparam = compute_tendencies(z, dz, Fres, Km, u)\n    dci = double_counting_index(Tres, Tparam)\n    return dci\n\ndef solve():\n    # Baseline parameters\n    H = 2000.0      # m\n    N = 64\n    F0 = 0.3        # m^2/s^2\n    He = 600.0      # m\n    K0 = 10.0       # m^2/s\n    Hk = 500.0      # m\n    U0 = 15.0       # m/s\n    z0 = 100.0      # m\n    Lt = 400.0      # m\n    p = 1.5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: dx=1000 m, baseline\n        {\"H\": H, \"N\": N, \"F0\": F0, \"He\": He, \"K0\": K0, \"Hk\": Hk, \"U0\": U0, \"z0\": z0, \"Lt\": Lt, \"p\": p, \"dx\": 1000.0},\n        # Case B: dx=250 m, baseline\n        {\"H\": H, \"N\": N, \"F0\": F0, \"He\": He, \"K0\": K0, \"Hk\": Hk, \"U0\": U0, \"z0\": z0, \"Lt\": Lt, \"p\": p, \"dx\": 250.0},\n        # Case C: dx=8000 m, baseline\n        {\"H\": H, \"N\": N, \"F0\": F0, \"He\": He, \"K0\": K0, \"Hk\": Hk, \"U0\": U0, \"z0\": z0, \"Lt\": Lt, \"p\": p, \"dx\": 8000.0},\n        # Case D: dx=1000 m, no transport (F0=0, U0=0)\n        {\"H\": H, \"N\": N, \"F0\": 0.0, \"He\": He, \"K0\": K0, \"Hk\": Hk, \"U0\": 0.0, \"z0\": z0, \"Lt\": Lt, \"p\": p, \"dx\": 1000.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        dci = run_case(**case)\n        results.append(dci)\n\n    # Final print statement in the exact required format, rounded to six decimals.\n    formatted = \",\".join(f\"{r:.6f}\" for r in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在诊断了灰色地带中的能量串级和双重计算问题后，最后的实践是将这些见解应用于参数化方案的设计中。本练习要求你为一个对流质量通量方案设计一个尺度感知的系数 $k$。你将基于给定的物理约束，提出并实现一个函数形式，该函数能根据已解析的对流部分 $f_{\\mathrm{res}}$ 和模式分辨率 $\\Delta$ 动态调整其强度，这正是现代参数化方案的核心思想 。",
            "id": "4085754",
            "problem": "给定一个用于数值天气预报（NWP）和气候模拟的模拟垂直速度扰动场的离散表示。目标是基于一个严格的阈值从上升气流掩码中计算出解析的上升气流分数，然后设计一个尺度感知的质量通量系数，该系数取决于此分数以及模式网格间距与对流长度尺度之比。请在纯数学术语下工作，遵循以下与深对流灰色地带的既定实践相符的基本定义和约束。在指定时使用标准物理单位。\n\n基本基础和定义：\n- 设垂直速度分解为 $w = \\overline{w} + w'$，其中 $w'$ 是垂直速度扰动，$\\overline{w}$ 是一个缓变的平均值。您将获得每个网格框中 $w'$ 的离散样本。\n- 通过指示函数定义一个严格的上升气流掩码：如果 $w'  w_0$，则 $I = 1$；否则 $I = 0$。阈值 $w_0$ 以米/秒（$\\mathrm{m}\\,\\mathrm{s}^{-1}$）表示。\n- 在一个具有 $N$ 个样本的等权重离散网格上，将解析的上升气流分数 $f_{\\mathrm{res}}$ 定义为掩码激活的样本所占的比例。\n- 定义一个尺度感知的参数化方案，旨在提供一个以秒的倒数（$\\mathrm{s}^{-1}$）为单位的质量通量系数 $k$，该系数通过仅作用于上升气流面积的未解析部分来补充解析的贡献。该设计必须满足以下所有约束：\n  1. $k$ 必须有界，使得 $0 \\le k \\le C_0$，其中 $C_0$ 是一个单位为 $\\mathrm{s}^{-1}$ 的基准系数。\n  2. $k$ 必须是 $f_{\\mathrm{res}}$ 的单调非增函数，并且必须满足极限行为：当 $f_{\\mathrm{res}} \\to 0$ 时，$k \\to C_0$；当 $f_{\\mathrm{res}} \\to 1$ 时，$k \\to 0$。\n  3. $k$ 必须平滑地依赖于无量纲的网格与对流尺度之比 $r = \\Delta / L_c$，其中 $\\Delta$ 是以米（$\\mathrm{m}$）为单位的网格间距，而 $L_c$ 是以米（$\\mathrm{m}$）为单位的对流长度尺度。这种依赖关系必须使得参数化贡献随着网格解析更多对流运动而减小，即对于任何固定的 $f_{\\mathrm{res}} \\in (0,1)$，当 $\\Delta / L_c \\to 0$ 时，$k \\to 0$；当 $\\Delta / L_c \\to +\\infty$ 时，$k \\to C_0 (1 - f_{\\mathrm{res}})$。\n  4. 该设计应由一个正的敏感度指数 $p$（无量纲）来表征，该指数控制 $k$ 随尺度变化的转换速度。\n\n您的任务：\n- 对每个测试用例，使用严格阈值 $w'  w_0$ 计算 $f_{\\mathrm{res}}$。\n- 提出并实现一个与上述约束一致的平滑函数形式 $k = \\mathcal{K}(f_{\\mathrm{res}}, \\Delta, L_c, C_0, p)$，确保其量纲正确，为 $\\mathrm{s}^{-1}$。\n- 对每个测试用例，输出一个包含两个浮点数的列表：首先是 $f_{\\mathrm{res}}$（无量纲），然后是 $k$（单位为 $\\mathrm{s}^{-1}$）。\n\n物理单位：\n- 垂直速度扰动 $w'$ 和阈值 $w_0$ 的单位是 $\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n- 网格间距 $\\Delta$ 和对流长度 $L_c$ 的单位是 $\\mathrm{m}$。\n- 基准系数 $C_0$ 和设计的系数 $k$ 的单位是 $\\mathrm{s}^{-1}$。\n\n角度单位不适用。\n\n测试套件：\n使用以下一组测试用例来覆盖一般行为、极限情况和边界条件。在每个用例中，$w'$ 值的列表单位是 $\\mathrm{m}\\,\\mathrm{s}^{-1}$，阈值 $w_0$ 的单位是 $\\mathrm{m}\\,\\mathrm{s}^{-1}$，$\\Delta$ 和 $L_c$ 的单位是 $\\mathrm{m}$，$C_0$ 的单位是 $\\mathrm{s}^{-1}$，而 $p$ 是无量纲的：\n- 用例 1（一般混合场，灰色地带尺度）：$w' = [-0.2, 0.3, 0.7, 1.2, -0.1, 0.5, 0.0, -0.4, 0.8, -0.3]$, $w_0 = 0.5$, $\\Delta = 1000$, $L_c = 1000$, $C_0 = 0.005$, $p = 1$。\n- 用例 2（粗网格，无解析的上升气流）：$w' = [-0.1, 0.4, 0.5, -0.2, 0.49]$, $w_0 = 0.5$, $\\Delta = 10000$, $L_c = 2000$, $C_0 = 0.006$, $p = 1$。\n- 用例 3（所有上升气流均被解析）：$w' = [0.6, 0.7, 0.8, 1.0]$, $w_0 = 0.5$, $\\Delta = 5000$, $L_c = 1000$, $C_0 = 0.004$, $p = 1$。\n- 用例 4（阈值相等边界情况）：$w' = [0.5, 0.5, 0.5, 0.49, 0.51]$, $w_0 = 0.5$, $\\Delta = 1000$, $L_c = 1500$, $C_0 = 0.005$, $p = 1$。\n- 用例 5（细网格，强尺度感知性）：$w' = [0.1, 0.6, 0.7, -0.1, 1.2, 0.4, 0.55, -0.2]$, $w_0 = 0.5$, $\\Delta = 200$, $L_c = 1000$, $C_0 = 0.01$, $p = 2$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是一个包含 $[f_{\\mathrm{res}}, k]$ 的双元素列表。例如，您的输出应类似于 $[[f_1,k_1],[f_2,k_2],\\dots]$，所有数值均表示为标准浮点数。",
            "solution": "该问题陈述已经过严格验证，被认为具有科学依据、良态且客观。它提出了大气模拟领域内一个标准但具有挑战性的设计任务，具体涉及对流灰色地带中次网格尺度过程的参数化。为质量通量系数的设计所提供的约束条件在很大程度上是一致的，仅在极限行为的相互作用中存在轻微的模糊性，这可以通过符合物理的解释来解决。因此，我们可以着手提供一个完整的解决方案。\n\n解决方案分为两部分：首先，计算解析的上升气流分数 $f_{\\mathrm{res}}$；其次，设计并实现尺度感知质量通量系数 $k$ 的函数形式。\n\n**第一部分：计算解析的上升气流分数 ($f_{\\mathrm{res}}$)**\n\n问题将解析的上升气流分数 $f_{\\mathrm{res}}$ 定义为垂直速度扰动 $w'$ 超过给定阈值 $w_0$ 的网格点所占的比例。在一个具有 $N$ 个等权重 $w'$ 样本的离散网格上，这可以通过首先定义一个上升气流掩码的指示函数 $I_i$ 来计算：\n$$\nI_i =\n\\begin{cases}\n1  \\text{如果 } w'_i  w_0 \\\\\n0  \\text{否则}\n\\end{cases}\n$$\n其中 $w'_i$ 是垂直速度扰动的第 $i$ 个样本。解析的上升气流分数则是该指示函数在所有 $N$ 个样本上的算术平均值：\n$$\nf_{\\mathrm{res}} = \\frac{1}{N} \\sum_{i=1}^{N} I_i\n$$\n对每个测试用例，使用提供的 $w'$ 值列表和相应的 $w_0$ 阈值执行此计算。\n\n**第二部分：设计尺度感知质量通量系数 ($k$)**\n\n主要任务是设计一个平滑函数 $k = \\mathcal{K}(f_{\\mathrm{res}}, \\Delta, L_c, C_0, p)$，使其满足一组特定约束。让我们分析这些约束以指导设计。我们将无量纲尺度比定义为 $r = \\Delta / L_c$。\n\n约束条件如下：\n1.  **有界性**：$0 \\le k \\le C_0$。\n2.  **对 $f_{\\mathrm{res}}$ 的依赖性**：$k$ 是 $f_{\\mathrm{res}}$ 的单调非增函数。它必须满足极限：当 $f_{\\mathrm{res}} \\to 0$ 时，$k \\to C_0$；当 $f_{\\mathrm{res}} \\to 1$ 时，$k \\to 0$。\n3.  **对 $r$ 的依赖性**：$k$ 是 $r$ 的平滑函数。它必须满足极限：当 $r \\to 0$ 时（细分辨率极限），$k \\to 0$；当 $r \\to +\\infty$ 时（粗分辨率极限），$k \\to C_0 (1 - f_{\\mathrm{res}})$。\n4.  **敏感度**：一个正指数 $p$ 控制随尺度变化的转换速率。\n\n在点 $(r, f_{\\mathrm{res}}) = (0, 0)$ 处，约束 2（当 $f_{\\mathrm{res}} \\to 0$ 时，$k \\to C_0$）与约束 3（当 $r \\to 0$ 时，$k \\to 0$）之间存在潜在冲突，因为极限取决于所取的路径。在物理建模中，一个标准的解释是，一般性约束（如约束 2）描述了参数化完全激活时的行为，即在粗网格极限 ($r \\to \\infty$) 下的行为。约束 3 的粗网格极限，即当 $r \\to \\infty$ 时，$k \\to C_0 (1 - f_{\\mathrm{res}})$，在 $f_{\\mathrm{res}} \\to 0$ 时正确地得到 $k \\to C_0$。因此，我们可以通过设计一个能在细网格行为（$k=0$）和粗网格行为之间正确插值的函数来综合这些约束。\n\n让我们将粗网格行为定义为 $k_{\\mathrm{coarse}}(f_{\\mathrm{res}}) = C_0 (1 - f_{\\mathrm{res}})$。这种形式已经满足了粗网格极限下对 $f_{\\mathrm{res}}$ 的单调性和极限行为要求。\n\n现在，我们引入一个依赖于尺度的混合函数 $S(r, p)$，它调节这种粗网格行为。函数 $S(r, p)$ 必须包含尺度感知性。它必须满足：\n- 当 $r \\to 0$ 时，$S(r, p) \\to 0$。\n- 当 $r \\to +\\infty$ 时，$S(r, p) \\to 1$。\n- 对于 $r \\ge 0$，$S(r, p)$ 必须是 $r$ 的平滑单调递增函数。\n- 指数 $p$ 应控制转换的陡峭程度。\n\n我们为 $k$ 提出以下函数形式：\n$$\nk = k_{\\mathrm{coarse}}(f_{\\mathrm{res}}) \\cdot S(r, p) = C_0 (1 - f_{\\mathrm{res}}) \\cdot S(r, p)\n$$\n对于满足所有要求的混合函数 $S(r, p)$，一个常见且合适的选择是希尔-朗缪尔类型的有理函数：\n$$\nS(r, p) = \\frac{r^p}{1 + r^p}\n$$\n该函数对于 $r \\ge 0$（对于整数 $p \\ge 1$）是平滑的，当 $r$ 从 $0$ 变为 $\\infty$ 时，函数值从 $0$ 过渡到 $1$，并且指数 $p$ 控制了在 $r=1$ 附近的转换锐度。\n\n因此，我们最终提出的函数形式是：\n$$\nk(f_{\\mathrm{res}}, r, C_0, p) = C_0 (1 - f_{\\mathrm{res}}) \\frac{r^p}{1 + r^p}\n$$\n其中 $r = \\Delta / L_c$。在所讨论的物理一致性解释下，该函数满足所有约束。由于 $0 \\le f_{\\mathrm{res}} \\le 1$ 且 $0 \\le S(r,p)  1$，边界 $0 \\le k  C_0$ 得到保证。\n\n每个测试用例的步骤是：\n1.  根据给定的 $w'$ 数组和 $w_0$ 阈值计算 $f_{\\mathrm{res}}$。\n2.  计算尺度比 $r = \\Delta / L_c$。\n3.  将 $f_{\\mathrm{res}}$、$r$、$C_0$ 和 $p$ 代入导出的 $k$ 的公式中，计算其值。\n4.  返回数对 $[f_{\\mathrm{res}}, k]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the resolved updraft fraction and a scale-aware mass-flux coefficient\n    for a series of test cases based on a derived functional form.\n    \"\"\"\n    test_cases = [\n        {'w_prime': [-0.2, 0.3, 0.7, 1.2, -0.1, 0.5, 0.0, -0.4, 0.8, -0.3], 'w0': 0.5, 'Delta': 1000, 'Lc': 1000, 'C0': 0.005, 'p': 1},\n        {'w_prime': [-0.1, 0.4, 0.5, -0.2, 0.49], 'w0': 0.5, 'Delta': 10000, 'Lc': 2000, 'C0': 0.006, 'p': 1},\n        {'w_prime': [0.6, 0.7, 0.8, 1.0], 'w0': 0.5, 'Delta': 5000, 'Lc': 1000, 'C0': 0.004, 'p': 1},\n        {'w_prime': [0.5, 0.5, 0.5, 0.49, 0.51], 'w0': 0.5, 'Delta': 1000, 'Lc': 1500, 'C0': 0.005, 'p': 1},\n        {'w_prime': [0.1, 0.6, 0.7, -0.1, 1.2, 0.4, 0.55, -0.2], 'w0': 0.5, 'Delta': 200, 'Lc': 1000, 'C0': 0.01, 'p': 2},\n    ]\n\n    results = []\n    \n    def mass_flux_coefficient(f_res, r, C0, p):\n        \"\"\"\n        Calculates the scale-aware mass-flux coefficient k based on the derived model.\n        k(f_res, r, C0, p) = C0 * (1 - f_res) * (r^p / (1 + r^p))\n        \"\"\"\n        # Handle the edge case r = 0 to avoid potential 0/0 or inf/inf with large p\n        if r == 0:\n            return 0.0\n            \n        scale_function = (r**p) / (1 + r**p)\n        k = C0 * (1 - f_res) * scale_function\n        return k\n\n    for case in test_cases:\n        w_prime = np.array(case['w_prime'])\n        w0 = case['w0']\n        Delta = case['Delta']\n        Lc = case['Lc']\n        C0 = case['C0']\n        p = case['p']\n\n        # Part 1: Compute the resolved updraft fraction (f_res)\n        num_samples = len(w_prime)\n        if num_samples == 0:\n            f_res = 0.0\n        else:\n            # Count samples where w' > w0 (strict inequality)\n            updraft_mask = w_prime > w0\n            num_updrafts = np.sum(updraft_mask)\n            f_res = num_updrafts / num_samples\n\n        # Part 2: Compute the mass-flux coefficient (k)\n        scale_ratio = Delta / Lc\n        k = mass_flux_coefficient(f_res, scale_ratio, C0, p)\n\n        # Format each result pair as [f_res, k]\n        results.append(f\"[{f_res},{k}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}