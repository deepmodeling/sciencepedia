{
    "hands_on_practices": [
        {
            "introduction": "为了构建有效的尺度感知参数化方案，我们必须首先理解能量如何在不同尺度的运动之间传递。本实践将指导您通过计算谱能量通量，来量化从已解析尺度流向未解析尺度的能量。通过分析该通量如何随模式分辨率的变化而变化，您将亲手揭示为何参数化方案必须具备“尺度感知”能力，以适应在“灰色地带”中不断移动的已解析与未解析尺度之间的界限。",
            "id": "4085750",
            "problem": "您的任务是构建一个科学上一致且可通过计算检验的、用于模拟湍流的谱能量通量度量，然后用它来评估用于参数化设计的灰色区域尺度感知能力。考虑在一个边长为 $L = 2\\pi$（无量纲单位）的方形区域上，一个不可压缩、均匀、各向同性、周期性的二维流场。速度场 $\\mathbf{u}(x,y)$ 是无散的，并由流函数 $\\psi(x,y)$ 通过关系式 $\\mathbf{u} = (\\partial \\psi / \\partial y,\\,-\\partial \\psi / \\partial x)$ 导出。无外力、无粘性的不可压缩纳维-斯托克斯方程为\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p,\n$$\n其中 $\\nabla\\cdot\\mathbf{u} = 0$。动能密度为 $E = \\tfrac{1}{2}\\,\\mathbf{u}\\cdot\\mathbf{u}$。谱能量收支通过傅里叶变换到波数空间 $(k_x,k_y)$ 并投影到无散（散度为零）子空间以消除压力来得出。波数大小 $k = \\sqrt{k_x^2 + k_y^2}$ 处的非线性输运函数可以从平流加速度的无散部分定义。在周期域上的快速傅里叶变换（FFT）离散化下，每个模式的标量能量输运贡献是通过速度模式与投影后的非线性模式的内积的实部获得的，而壳层积分输运则通过对径向波数落在整数壳层内的所有模式求和来计算。通过截止波数 $k_0$ 的谱能量通量 $\\Pi(k_0)$ 定义为波数大小大于 $k_0$ 的模式所接收的累积非线性能量输运，即对所有 $k > k_0$ 的壳层进行离散壳层求和。正的 $\\Pi(k_0)$ 表示向未解析小尺度的净正向输运，而负的 $\\Pi(k_0)$ 表示向较大尺度的净逆向输运。\n\n您的程序必须：\n\n- 在一个 $N \\times N$ 网格（其中 $N = 256$，$L = 2\\pi$，无量纲单位）上构建一个单一的高分辨率无散速度场，方法是：将流函数 $\\psi(x,y)$ 构建为一组有限傅里叶模式的和，这些模式的波数大小在带 $k \\in [3,6]$ 内，具有随机相位，且振幅随 $k$ 增大而衰减，以确保物理真实性和数值稳定性。\n- 通过 $\\psi$ 的谱导数计算速度场 $\\mathbf{u}$。\n- 计算平流加速度 $\\mathbf{A} = (\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$，其中 $\\nabla\\mathbf{u}$ 使用谱导数，并在物理空间中进行逐点乘积。为减轻混叠，对非线性项应用三分之二截断规则：移除 $\\mathbf{A}$ 中所有 $|k_x|$ 或 $|k_y|$ 超过 $N/3$ 的傅里叶分量。\n- 对每个波数，使用投影算子 $\\mathbf{P}(\\mathbf{k}) = \\mathbf{I} - \\mathbf{k}\\mathbf{k}^\\top / |\\mathbf{k}|^2$（其中 $\\mathbf{k} = (k_x,k_y)$ 且 $|\\mathbf{k}|^2 = k_x^2 + k_y^2$）将 $\\mathbf{A}$ 的傅里叶变换投影到无散子空间，其中零模式被视为无贡献。将用于能量输运的非线性项定义为 $\\widehat{\\mathbf{N}}(\\mathbf{k}) = -\\mathbf{P}(\\mathbf{k})\\,\\widehat{\\mathbf{A}}(\\mathbf{k})$。\n- 计算每个模式的谱能量输运 $T(\\mathbf{k})$，其值为内积 $T(\\mathbf{k}) = \\Re\\left[\\widehat{\\mathbf{u}}(\\mathbf{k})^* \\cdot \\widehat{\\mathbf{N}}(\\mathbf{k})\\right]$ 的实部，并将 $T(\\mathbf{k})$ 分箱到整数壳层 $k_s = \\mathrm{round}(\\sqrt{k_x^2 + k_y^2}) \\in \\mathbb{N}$ 中，以获得壳层求和输运 $T_s(k_s)$（对于 $k_s \\ge 1$）。\n- 对于给定的粗网格间距 $\\Delta = L / N_\\Delta$（其中 $N_\\Delta$ 为偶数分辨率），定义截止波数 $k_\\Delta = \\pi / \\Delta = N_\\Delta / 2$。计算谱能量通量 $\\Pi(k_\\Delta)$，其值为对所有 $k_s > k_\\Delta$ 的壳层进行的累积壳层求和，即 $\\Pi(k_\\Delta) = \\sum_{k_s > k_\\Delta} T_s(k_s)$，并使用刚刚构建的单一高分辨率场（即，始终通过对相应的高分辨率壳层求和，从同一个高分辨率 $N=256$ 场计算 $\\Pi(k_\\Delta)$）。\n- 所有输出均以无量纲单位表示，并四舍五入到六位小数。\n\n测试套件和输出规范：\n\n- 使用以下这组粗分辨率 $N_\\Delta$：$\\{16, 32, 64, 96, 128, 256\\}$。对于每个 $N_\\Delta$，计算 $k_\\Delta = N_\\Delta / 2$，然后如上所述从高分辨率场计算 $\\Pi(k_\\Delta)$。\n- 您的程序应生成单行输出，其中包含六个结果，格式为用方括号括起来的逗号分隔列表，顺序与提供的测试套件分辨率一致。例如，输出必须具有 $[\\pi_{16},\\pi_{32},\\pi_{64},\\pi_{96},\\pi_{128},\\pi_{256}]$ 的形式，其中每个 $\\pi_{N_\\Delta}$ 是一个四舍五入到六位小数的十进制浮点数。\n\n解释要求（应在您的算法选择和注释中反映）：结果应在灰色区域中尺度感知参数化的背景下进行解释，其中 $k_\\Delta$ 随 $\\Delta$ 变化。当 $\\Delta$ 减小时，$|\\Pi(k_\\Delta)|$ 的减小表明进入未解析尺度的净输运减少，这意味着尺度感知闭合方案应随分辨率的提高而减弱其贡献。反之，在粗分辨率下较大的 $|\\Pi(k_\\Delta)|$ 表明存在更强的未解析输运，需要更强的参数化耗散。您的代码必须仅使用高分辨率场按规定实现计算，并且不得执行任何时间积分。\n\n角度单位为弧度。所有量均为无量纲。最终输出必须是四舍五入到六位小数的浮点数。",
            "solution": "我们从周期域上无量纲形式的不可压缩纳维-斯托克斯方程开始，\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p,\\quad \\nabla\\cdot\\mathbf{u}=0,\n$$\n其动能密度为 $E = \\tfrac{1}{2}\\mathbf{u}\\cdot\\mathbf{u}$。进行傅里叶变换，我们定义波数向量 $\\mathbf{k} = (k_x,k_y)$。当物理域长度为 $L=2\\pi$ 时，其两个分量均为整数，因为当采样间距为 $d=L/N$ 时，快速傅里叶变换（FFT）得到的 $\\widehat{f}(\\mathbf{k})$ 是由整数波数索引的。由非线性平流引起的能量输运源于 $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$ 项，该项不是无散的；压力梯度通过移除无旋分量来强制实现不可压缩性。因此，为了在每个波数上保持能量收支一致，必须使用投影算子将平流加速度投影到无散子空间：\n$$\n\\mathbf{P}(\\mathbf{k}) = \\mathbf{I} - \\frac{\\mathbf{k}\\mathbf{k}^\\top}{|\\mathbf{k}|^2},\\quad |\\mathbf{k}|^2 = k_x^2 + k_y^2,\n$$\n此式对 $\\mathbf{k}\\neq\\mathbf{0}$ 成立，且零模式对能量输运无贡献。\n\n定义平流加速度 $\\mathbf{A} = (\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$。在谱空间中，这是通过伪谱法计算的：我们通过FFT评估空间导数（这使得谱导数表现为乘以 $\\mathrm{i}k_x$ 和 $\\mathrm{i}k_y$），在物理空间中形成乘积，然后变换回来。为减轻离散非线性乘积固有的混叠误差，我们应用三分之二截断规则，该规则将非线性项中 $|k_x|$ 或 $|k_y|$ 超过 $N/3$ 的傅里叶分量置零；这消除了会混叠回已解析范围的三波相互作用。\n\n进入谱能量输运的投影非线性项是\n$$\n\\widehat{\\mathbf{N}}(\\mathbf{k}) = -\\mathbf{P}(\\mathbf{k})\\,\\widehat{\\mathbf{A}}(\\mathbf{k}),\\quad \\mathbf{k}\\neq\\mathbf{0},\n$$\n其中 $\\widehat{\\mathbf{N}}(\\mathbf{0})$ 取为零。每个模式的瞬时谱能量输运为\n$$\nT(\\mathbf{k}) = \\Re\\left[\\widehat{\\mathbf{u}}(\\mathbf{k})^*\\cdot \\widehat{\\mathbf{N}}(\\mathbf{k})\\right],\n$$\n其中点表示速度分量上的欧几里得内积，星号表示复共轭。由于非线性项在不同尺度间重新分配能量而不产生或消灭能量，我们期望所有模式的总和满足 $\\sum_{\\mathbf{k}} T(\\mathbf{k}) \\approx 0$（在数值截断和混叠减轻的误差范围内）。\n\n然后我们通过整数径向波数定义各向同性壳层\n$$\nk_s = \\mathrm{round}\\left(\\sqrt{k_x^2+k_y^2}\\right),\\quad k_s\\in\\mathbb{N}.\n$$\n壳层积分输运为\n$$\nT_s(k_s) = \\sum_{\\mathbf{k}: \\mathrm{round}(|\\mathbf{k}|)=k_s} T(\\mathbf{k}),\\quad k_s\\ge 1.\n$$\n给定一个粗分辨率 $N_\\Delta$，其间距为 $\\Delta = L/N_\\Delta$，截止波数为\n$$\nk_\\Delta = \\frac{\\pi}{\\Delta} = \\frac{N_\\Delta}{2},\n$$\n通过 $k_\\Delta$ 的谱能量通量是进入截止波数以外模式的累积输运：\n$$\n\\Pi(k_\\Delta) = \\sum_{k_s>k_\\Delta} T_s(k_s).\n$$\n这个定义与正向通量约定一致：正的 $\\Pi(k_\\Delta)$ 表示向未解析小尺度（$k>k_\\Delta$）的净输运，而负的 $\\Pi(k_\\Delta)$ 表示向较大尺度（逆向输运）的净输运。在二维湍流中，能量级串通常是逆向的（朝向小 $k$），而拟能级串是正向的（朝向大 $k$），因此根据瞬时流场的实现，获得 $\\Pi(k_\\Delta) < 0$ 是可能且物理上合理的。\n\n算法步骤：\n\n$1.$ 在一个 $N\\times N$ 网格（$N=256$, $L=2\\pi$）上构建一个单一的高分辨率流函数 $\\psi(x,y)$。选择一组整数波数对 $(k_x,k_y)$，其大小位于 $[3,6]$ 区间内，并分配随机相位。为确保物理真实性，选择随波数大小衰减的振幅，例如与 $1/(k_x^2+k_y^2)$ 成正比。将 $\\psi$ 构建为余弦模式的和\n$$\n\\psi(x,y) = \\sum_{m=1}^{M} a_m \\cos(k_{x,m} x + k_{y,m} y + \\phi_m),\n$$\n其中 $M$ 是有限的。这种构造确保了 $\\psi$ 是实数且光滑的。\n\n$2.$ 在谱空间中使用 $\\widehat{u}_x = \\mathrm{i}k_y\\widehat{\\psi}$ 和 $\\widehat{u}_y = -\\mathrm{i}k_x\\widehat{\\psi}$ 计算速度，然后进行逆FFT以获得 $u_x(x,y)$ 和 $u_y(x,y)$。\n\n$3.$ 使用谱微分法计算 $(\\mathbf{u}\\cdot\\nabla)\\mathbf{u}$ 所需的空间导数：变换 $\\widehat{u}_x$ 和 $\\widehat{u}_y$ 并乘以 $\\mathrm{i}k_x$ 或 $\\mathrm{i}k_y$ 以获得 $\\partial u_x/\\partial x$、$\\partial u_x/\\partial y$、$\\partial u_y/\\partial x$ 和 $\\partial u_y/\\partial y$，然后进行逆FFT回到物理空间。\n\n$4.$ 在物理空间中形成非线性平流项：\n$$\nA_x = u_x \\frac{\\partial u_x}{\\partial x} + u_y \\frac{\\partial u_x}{\\partial y},\\quad\nA_y = u_x \\frac{\\partial u_y}{\\partial x} + u_y \\frac{\\partial u_y}{\\partial y}.\n$$\n对它们进行FFT以获得 $\\widehat{A}_x$ 和 $\\widehat{A}_y$。通过将 $|k_x|>N/3$ 或 $|k_y|>N/3$ 处的 $\\widehat{A}$ 置零来应用三分之二规则。\n\n$5.$ 投影到无散子空间：\n$$\n\\widehat{\\mathbf{N}}(\\mathbf{k}) = -\\left(\\widehat{\\mathbf{A}}(\\mathbf{k}) - \\frac{\\mathbf{k}(\\mathbf{k}\\cdot \\widehat{\\mathbf{A}}(\\mathbf{k}))}{|\\mathbf{k}|^2}\\right),\\quad \\mathbf{k}\\neq \\mathbf{0},\n$$\n并设置 $\\widehat{\\mathbf{N}}(\\mathbf{0})=\\mathbf{0}$。\n\n$6.$ 计算每个模式的输运\n$$\nT(\\mathbf{k}) = \\Re\\left[\\widehat{u}_x(\\mathbf{k})^*\\,\\widehat{N}_x(\\mathbf{k}) + \\widehat{u}_y(\\mathbf{k})^*\\,\\widehat{N}_y(\\mathbf{k})\\right],\n$$\n并分箱到壳层 $k_s=\\mathrm{round}(|\\mathbf{k}|)$ 中以形成 $T_s(k_s)$（对于 $k_s\\ge 1$）。\n\n$7.$ 对于测试套件中的每个 $N_\\Delta$，设置 $k_\\Delta = N_\\Delta/2$，并计算\n$$\n\\Pi(k_\\Delta) = \\sum_{k_s>k_\\Delta} T_s(k_s).\n$$\n\n基于原理的灰色区域尺度感知解释：在数值天气预报和气候模拟中，尺度感知参数化方案应随着分辨率的变化而调整其效果。在这里，$k_\\Delta$ 标志着给定分辨率下已解析尺度和未解析尺度之间的过渡。如果随着 $\\Delta$ 减小（等效于 $N_\\Delta$ 增大），$|\\Pi(k_\\Delta)|$ 减小，那么非线性项向未解析范围输运的能量就更少，这表明模拟次网格耗散的参数化方案的强度应随分辨率的提高而减弱。反之，在粗分辨率下较大的 $|\\Pi(k_\\Delta)|$ 表明需要更强的参数化阻尼。符号传达了级串方向：负的 $\\Pi(k_\\Delta)$ 表明逆向能量输运（在二维流中很典型），因此一个简单的正向能量耗散闭合方案可能不适用；相反，可以以移除拟能为目标，同时保留大尺度能量。该算法从单个高分辨率流场快照计算 $\\Pi(k_\\Delta)$，这足以说明对灰色区域参数化设计至关重要的分辨率依赖性。\n\n数值方面：使用FFT可确保谱导数的准确性，并与周期性边界条件一致。三分之二规则限制了混叠，保持了所计算输运的保真度。按整数半径进行壳层分箱可产生各向同性谱。输出为无量纲，并四舍五入到六位小数。最终程序计算并打印 $[\\Pi(8), \\Pi(16), \\Pi(32), \\Pi(48), \\Pi(64), \\Pi(128)]$，对应于 $N_\\Delta \\in \\{16,32,64,96,128,256\\}$，其中每个 $\\Pi(k_\\Delta)$ 都是从相同的高分辨率场计算得出的。",
            "answer": "```python\nimport numpy as np\n\ndef construct_streamfunction(N, L, seed=42, num_modes=20, kmin=3, kmax=6, amp0=1.0):\n    \"\"\"\n    Construct a real-valued streamfunction psi(x,y) on an N x N grid over [0,L)^2,\n    as a sum of cosine modes with wavenumbers in [kmin, kmax] and random phases.\n    Amplitude decays with k^2 for smoothness.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    x = np.linspace(0.0, L, N, endpoint=False)\n    y = np.linspace(0.0, L, N, endpoint=False)\n    X, Y = np.meshgrid(x, y, indexing='xy')\n\n    # Select unique integer wavenumber pairs in the annulus k in [kmin, kmax]\n    modes = set()\n    # Enumerate all candidate integer pairs in the range and sample until num_modes\n    candidates = []\n    for kx in range(-kmax, kmax + 1):\n        for ky in range(-kmax, kmax + 1):\n            if kx == 0 and ky == 0:\n                continue\n            kmag = np.sqrt(kx**2 + ky**2)\n            if kmin = kmag = kmax:\n                candidates.append((kx, ky))\n    rng.shuffle(candidates)\n    idx = 0\n    while len(modes)  num_modes and idx  len(candidates):\n        modes.add(candidates[idx])\n        idx += 1\n    if len(modes)  num_modes:\n        # If not enough unique modes, reuse random picks with possible duplicates (harmless)\n        while len(modes)  num_modes:\n            kx, ky = rng.choice(candidates)\n            modes.add((kx, ky))\n\n    psi = np.zeros((N, N), dtype=np.float64)\n    for (kx, ky) in list(modes)[:num_modes]:\n        phase = rng.uniform(0.0, 2.0 * np.pi)\n        kmag2 = kx**2 + ky**2\n        amplitude = amp0 / (kmag2 if kmag2 > 0 else 1.0)\n        psi += amplitude * np.cos(kx * X + ky * Y + phase)\n\n    return psi\n\ndef fft_wavenumbers(N, L):\n    \"\"\"\n    Compute FFT wavenumbers for domain length L. Returns kx, ky grids and 1D vectors.\n    For L=2*pi and d=L/N, the radian wavenumbers are integers.\n    \"\"\"\n    dx = L / N\n    k1d = 2.0 * np.pi * np.fft.fftfreq(N, d=dx)  # radian wavenumbers\n    kx = k1d.reshape(N, 1) * np.ones((1, N))\n    ky = k1d.reshape(1, N) * np.ones((N, 1))\n    return kx, ky, k1d\n\ndef spectral_derivative(field_hat, kx, ky, comp='x'):\n    \"\"\"\n    Compute spectral derivative of a Fourier-transformed field w.r.t. x or y.\n    comp: 'x' or 'y'\n    \"\"\"\n    if comp == 'x':\n        return 1j * kx * field_hat\n    elif comp == 'y':\n        return 1j * ky * field_hat\n    else:\n        raise ValueError(\"comp must be 'x' or 'y'\")\n\ndef project_solenoidal(Ax_hat, Ay_hat, kx, ky):\n    \"\"\"\n    Project the vector Fourier field A_hat onto the solenoidal subspace:\n    N_hat = -(A_hat - k (k·A_hat)/|k|^2)\n    with zero mode handled specially.\n    \"\"\"\n    ksq = kx**2 + ky**2\n    kdotA = kx * Ax_hat + ky * Ay_hat\n    with np.errstate(divide='ignore', invalid='ignore'):\n        coeff = np.where(ksq != 0.0, kdotA / ksq, 0.0)\n    PxAx = Ax_hat - kx * coeff\n    PxAy = Ay_hat - ky * coeff\n    Nx_hat = -PxAx\n    Ny_hat = -PxAy\n    # Ensure zero mode is zero\n    zero_mask = (ksq == 0.0)\n    Nx_hat[zero_mask] = 0.0 + 0.0j\n    Ny_hat[zero_mask] = 0.0 + 0.0j\n    return Nx_hat, Ny_hat\n\ndef two_thirds_dealias_mask(kx, ky, N):\n    \"\"\"\n    Two-thirds rule mask: keep modes where both |kx| = kc and |ky| = kc, with kc = N/3 in integer units\n    since kx, ky are integers when L=2*pi.\n    \"\"\"\n    kc = N / 3.0\n    return (np.abs(kx) = kc)  (np.abs(ky) = kc)\n\ndef compute_transfer_shells(psi, N, L):\n    \"\"\"\n    Compute shell-integrated nonlinear energy transfer T_s(k_s) from a streamfunction psi.\n    Returns T_shell (1D array), shell_indices (array of integer shell numbers), and k magnitude grid.\n    \"\"\"\n    # Wavenumbers\n    kx, ky, k1d = fft_wavenumbers(N, L)\n    # FFT of psi\n    psi_hat = np.fft.fft2(psi)\n    # Velocity in spectral space\n    ux_hat = 1j * ky * psi_hat\n    uy_hat = -1j * kx * psi_hat\n    # Physical velocity fields\n    ux = np.fft.ifft2(ux_hat).real\n    uy = np.fft.ifft2(uy_hat).real\n    # Derivatives of velocity components via spectral differentiation\n    dux_dx_hat = spectral_derivative(ux_hat, kx, ky, comp='x')\n    dux_dy_hat = spectral_derivative(ux_hat, kx, ky, comp='y')\n    duy_dx_hat = spectral_derivative(uy_hat, kx, ky, comp='x')\n    duy_dy_hat = spectral_derivative(uy_hat, kx, ky, comp='y')\n    dux_dx = np.fft.ifft2(dux_dx_hat).real\n    dux_dy = np.fft.ifft2(dux_dy_hat).real\n    duy_dx = np.fft.ifft2(duy_dx_hat).real\n    duy_dy = np.fft.ifft2(duy_dy_hat).real\n    # Advective term in physical space\n    Ax = ux * dux_dx + uy * dux_dy\n    Ay = ux * duy_dx + uy * duy_dy\n    # Transform to spectral space\n    Ax_hat = np.fft.fft2(Ax)\n    Ay_hat = np.fft.fft2(Ay)\n    # Two-thirds dealiasing on nonlinear term\n    mask = two_thirds_dealias_mask(kx, ky, N)\n    Ax_hat = Ax_hat * mask\n    Ay_hat = Ay_hat * mask\n    # Project onto solenoidal subspace and negate\n    Nx_hat, Ny_hat = project_solenoidal(Ax_hat, Ay_hat, kx, ky)\n    # Energy transfer per mode: Re(u_hat* · N_hat)\n    T_mode = np.real(np.conj(ux_hat) * Nx_hat + np.conj(uy_hat) * Ny_hat)\n    # Shell binning by integer-rounded radial wavenumber\n    kr = np.sqrt(kx**2 + ky**2)\n    k_shell = np.rint(kr).astype(int)\n    # Exclude shell 0\n    valid = (k_shell >= 1)\n    k_shell_flat = k_shell[valid].flatten()\n    T_mode_flat = T_mode[valid].flatten()\n    # Maximum shell index present\n    kmax_shell = k_shell_flat.max() if k_shell_flat.size > 0 else 0\n    # Bin transfers into shells\n    T_shell = np.bincount(k_shell_flat, weights=T_mode_flat, minlength=kmax_shell + 1)\n    return T_shell\n\ndef compute_fluxes_for_resolutions(T_shell, resolutions):\n    \"\"\"\n    Given shell-integrated transfers T_shell and a list of N_delta resolutions,\n    compute Pi(k_delta) = sum_{k > k_delta} T_shell[k].\n    \"\"\"\n    kmax = len(T_shell) - 1\n    fluxes = []\n    for N_delta in resolutions:\n        k_delta = N_delta // 2  # since N_delta is even\n        # Sum over shells greater than k_delta, ensure within bounds\n        start = min(kmax + 1, k_delta + 1)\n        flux = float(np.sum(T_shell[start:]))\n        fluxes.append(flux)\n    return fluxes\n\ndef solve():\n    # Domain and base resolution\n    N = 256\n    L = 2.0 * np.pi\n\n    # Construct a single high-resolution streamfunction and velocity field\n    psi = construct_streamfunction(N=N, L=L, seed=42, num_modes=20, kmin=3, kmax=6, amp0=1.0)\n\n    # Compute shell-integrated transfer from the nonlinear term\n    T_shell = compute_transfer_shells(psi, N, L)\n\n    # Test suite resolutions and corresponding k_delta\n    test_resolutions = [16, 32, 64, 96, 128, 256]\n\n    # Compute fluxes Pi(k_delta) for each resolution using the same high-resolution field\n    fluxes = compute_fluxes_for_resolutions(T_shell, test_resolutions)\n\n    # Format output: floats rounded to six decimal places\n    formatted = [f\"{f:.6f}\" for f in fluxes]\n    print(f\"[{','.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在灰色地带建模的一个核心挑战是避免“双重计算”问题，即模式的动力学核心和参数化方案同时模拟了部分相同的物理过程。本练习将引导您构建一个诊断指数，用于量化动量垂直输送中已解析贡献与参数化贡献之间的重叠。通过实施此诊断，您将学会一种识别和评估双重计算风险的实用方法，这对于验证和改进灰色地带的参数化方案至关重要。",
            "id": "4085719",
            "problem": "您的任务是构建并实现一个诊断工具，通过在不同的水平网格间距下比较解析通量散度与参数化趋势，来检测大气“灰区”中垂直动量输送的双重计算问题。灰区指的是模型动力学解析了部分湍流输送，而另一部分仍由参数化方案表示的尺度，这可能导致双重计算。您的程序必须计算此双重计算的定量指数，并为指定的测试套件报告该指数。\n\n基本原理：\n- 从雷诺平均纳维-斯托克斯 (RANS) 动量方程出发，其水平动量的垂直输送项涉及垂直湍流通量的散度。对于水平风分量的一维垂直形式，解析趋势与解析的垂直动量通量的散度相关联。\n- 常见的参数化方案使用涡黏性（一阶闭合）来表示未解析的垂直动量输送，从而产生一个与动量垂直扩散通量的散度成正比的参数化趋势。\n\n定义与设置：\n- 考虑一个一维垂直气柱，垂直坐标为 $z$，深度为 $H$，离散为 $N$ 个等间距层级 $z_i$（$i = 0, 1, \\dots, N-1$），间距为 $\\Delta z = H/(N-1)$。\n- 设 $F_{\\text{res}}(z; \\Delta x)$ 表示在尺度 $\\Delta x$ 下模拟的水平动量的解析垂直通量（垂直速度和水平速度脉动的协方差）。假设该通量形式为\n$$\nF_{\\text{res}}(z; \\Delta x) = S(\\Delta x)\\, F_0 \\exp\\!\\left(-\\frac{z}{H_e}\\right),\n$$\n其中 $F_0$ 是一个单位为 $\\mathrm{m^2\\,s^{-2}}$ 的地表通量尺度，$H_e$ 是一个单位为 $\\mathrm{m}$ 的垂直e-折叠尺度，$S(\\Delta x)$ 是一个尺度划分函数，表征在水平网格间距 $\\Delta x$ 下湍流输送的解析部分。使用\n$$\nS(\\Delta x) = \\frac{1}{1 + \\left(\\frac{\\Delta x}{L_t}\\right)^p},\n$$\n其中 $L_t$ 是一个单位为 $\\mathrm{m}$ 的湍流长度尺度，$p$ 是一个正指数。\n- 设 $K_m(z)$ 表示一个单位为 $\\mathrm{m^2\\,s^{-1}}$ 的涡黏性廓线：\n$$\nK_m(z) = K_0 \\left(\\frac{z}{H}\\right) \\exp\\!\\left(-\\frac{z}{H_k}\\right),\n$$\n其中 $K_0$ 是一个尺度振幅，$H_k$ 是一个垂直衰减尺度。\n- 设平均水平风廓线为\n$$\nu(z) = U_0 \\left(1 - \\exp\\!\\left(-\\frac{z}{z_0}\\right)\\right),\n$$\n其中 $U_0$ 是一个单位为 $\\mathrm{m\\,s^{-1}}$ 的速度尺度，$z_0$ 是一个单位为 $\\mathrm{m}$ 的切变尺度。\n\n诊断量：\n- 定义由解析的垂直动量输送引起的解析趋势为\n$$\nT_{\\text{res}}(z) = -\\frac{\\partial F_{\\text{res}}(z; \\Delta x)}{\\partial z}.\n$$\n- 定义使用涡黏性闭合的参数化趋势（未调整，即没有任何尺度感知划分）为\n$$\nT_{\\text{param}}(z) = -\\frac{\\partial}{\\partial z}\\left( K_m(z)\\, \\frac{\\partial u}{\\partial z} \\right).\n$$\n- 构建一个双重计算指数 (DCI)，用于衡量当两个趋势符号相同（相互加强）时的重叠程度，并按它们的总量级进行归一化：\n$$\n\\mathrm{DCI} = \\frac{\\sum_{i=0}^{N-1} \\left[ \\mathcal{H}\\!\\left(T_{\\text{res},i}\\, T_{\\text{param},i}\\right) \\cdot \\min\\!\\left(\\left|T_{\\text{res},i}\\right|, \\left|T_{\\text{param},i}\\right|\\right) \\right]}{\\sum_{i=0}^{N-1} \\left( \\left|T_{\\text{res},i}\\right| + \\left|T_{\\text{param},i}\\right| \\right)},\n$$\n其中 $\\mathcal{H}(\\cdot)$ 是亥维赛阶跃函数，若其参数为严格正数则取值为1，否则为0。如果分母为零，按惯例定义 $\\mathrm{DCI} = 0$。DCI 是一个在 $[0, 0.5]$ 范围内的无量纲小数。\n\n数值要求：\n- 使用二阶精度的有限差分来近似所有需要的垂直导数，在边界 $z=0$ 和 $z=H$ 处使用单边差分。在内部点 $z_i$（$i=1$ 到 $i=N-2$），使用中心差分。在边界处，使用与网格间距 $\\Delta z$ 一致的一阶单边差分。\n- 不要对 $T_{\\text{param}}(z)$ 应用任何尺度划分；该诊断工具的目的是检测随着 $\\Delta x$ 变化，由朴素的参数化趋势与解析趋势重叠而产生的双重计算。\n- 所有物理单位必须一致：$z$、$H$、$H_e$、$H_k$、$L_t$ 和 $z_0$ 的单位为 $\\mathrm{m}$；$U_0$ 的单位为 $\\mathrm{m\\,s^{-1}}$；$K_0$ 的单位为 $\\mathrm{m^2\\,s^{-1}}$；$F_0$ 的单位为 $\\mathrm{m^2\\,s^{-2}}$；趋势 $T_{\\text{res}}$ 和 $T_{\\text{param}}$ 的单位为 $\\mathrm{m\\,s^{-2}}$。最终的 DCI 是无单位的，必须表示为小数。\n\n参数值：\n- 使用 $H = 2000\\,\\mathrm{m}$，$N = 64$，$F_0 = 0.3\\,\\mathrm{m^2\\,s^{-2}}$，$H_e = 600\\,\\mathrm{m}$，$K_0 = 10\\,\\mathrm{m^2\\,s^{-1}}$，$H_k = 500\\,\\mathrm{m}$，$U_0 = 15\\,\\mathrm{m\\,s^{-1}}$，$z_0 = 100\\,\\mathrm{m}$，$L_t = 400\\,\\mathrm{m}$，以及 $p = 1.5$。这些值对于对流边界层情景是科学上合理的。\n\n测试套件：\n为以下四种情况实施该诊断并计算 $\\mathrm{DCI}$：\n- 案例 A (理想情况)：$\\Delta x = 1000\\,\\mathrm{m}$，使用上述基准参数。\n- 案例 B (细网格灰区)：$\\Delta x = 250\\,\\mathrm{m}$，使用上述基准参数。\n- 案例 C (粗网格极限)：$\\Delta x = 8000\\,\\mathrm{m}$，使用上述基准参数。\n- 案例 D (边缘情况：无输送)：$\\Delta x = 1000\\,\\mathrm{m}$，但设置 $F_0 = 0.0\\,\\mathrm{m^2\\,s^{-2}}$ 和 $U_0 = 0.0\\,\\mathrm{m\\,s^{-1}}$；所有其他参数与基准相同。根据给定的惯例，此案例应产生诊断值 $0.0$。\n\n输出规范：\n- 您的程序应生成单行输出，包含案例 A–D 的四个 $\\mathrm{DCI}$ 值，格式为用方括号括起来的逗号分隔列表，每个值四舍五入到六位小数（例如，$[0.123456,0.234567,0.000000,0.456789]$）。DCI 必须表示为不带百分号的小数。",
            "solution": "该任务基于雷诺平均纳维-斯托克斯 (RANS) 动量方程，其中水平风分量的垂直动量输送由垂直湍流通量的散度表示。在一维垂直气柱中，与湍流输送相关的解析趋势由 $-\\partial F_{\\text{res}}/\\partial z$ 给出，其中 $F_{\\text{res}}$ 是解析的垂直动量通量。同时，参数化方案通过涡黏性闭合来近似未解析的湍流输送，产生一个参数化趋势 $-\\partial/\\partial z(K_m\\, \\partial u/\\partial z)$。\n\n在灰区中，随着水平网格间距 $\\Delta x$ 的减小，湍流输送的解析部分增加，而参数化方案通常仍会施加一个显著的趋势。如果在某个层中，解析趋势和参数化趋势都朝同一方向作用（即符号相同），它们的综合效应可能会双重计算该输送。所提出的双重计算指数 (DCI) 仅在这些趋势相互加强时量化它们的重叠量级，并按其总量级进行归一化。这创建了一个无量纲的小数，当没有重叠加强时为零，当两个趋势完全相同且方向一致时，趋向于上限0.5。\n\n分步推导与算法：\n\n1) 垂直离散化：\n- 定义 $N$ 个等间距层级 $z_i$，其中 $z_0 = 0$，$z_{N-1} = H$，间距为 $\\Delta z = H/(N-1)$。\n\n2) 解析通量模型：\n- 使用尺度划分函数 $S(\\Delta x) = 1/(1 + (\\Delta x/L_t)^p)$ 来表示在给定水平网格间距 $\\Delta x$、湍流长度尺度 $L_t$ 和指数 $p$ 的情况下，被解析的湍流输送部分。\n- 定义解析的垂直动量通量：\n$$\nF_{\\text{res}}(z_i; \\Delta x) = S(\\Delta x)\\, F_0 \\exp\\!\\left(-\\frac{z_i}{H_e}\\right).\n$$\n这捕捉了一个在地表最强、随高度衰减并与解析部分成比例的通量。\n\n3) 涡黏性参数化与平均风廓线：\n- 定义 $K_m(z_i) = K_0 (z_i/H)\\exp(-z_i/H_k)$，表示从地表开始增长然后随高度衰减的混合。\n- 定义平均风 $u(z_i) = U_0 (1 - \\exp(-z_i/z_0))$，它从地表附近的零值向由 $U_0$ 设定的渐近值增加。\n\n4) 数值微分：\n- 使用二阶精度的有限差分计算 $\\partial F_{\\text{res}}/\\partial z$：\n  - 对于内部点 $i = 1, \\dots, N-2$，使用中心差分\n  $$\n  \\left.\\frac{\\partial F_{\\text{res}}}{\\partial z}\\right|_{z_i} \\approx \\frac{F_{\\text{res}}(z_{i+1}) - F_{\\text{res}}(z_{i-1})}{2\\Delta z}.\n  $$\n  - 对于边界，使用单边差分：\n  $$\n  \\left.\\frac{\\partial F_{\\text{res}}}{\\partial z}\\right|_{z_0} \\approx \\frac{F_{\\text{res}}(z_{1}) - F_{\\text{res}}(z_{0})}{\\Delta z}, \\quad\n  \\left.\\frac{\\partial F_{\\text{res}}}{\\partial z}\\right|_{z_{N-1}} \\approx \\frac{F_{\\text{res}}(z_{N-1}) - F_{\\text{res}}(z_{N-2})}{\\Delta z}.\n  $$\n- 类似地，通过内部点的中心差分和边界的单边差分计算 $\\partial u/\\partial z$。\n- 在每个层级上形成动量的扩散通量 $K_m\\, \\partial u/\\partial z$，然后用相同的有限差分方案计算其垂直导数 $\\partial/\\partial z(K_m\\, \\partial u/\\partial z)$。\n\n5) 趋势：\n- 解析趋势为\n$$\nT_{\\text{res}}(z_i) = -\\left.\\frac{\\partial F_{\\text{res}}}{\\partial z}\\right|_{z_i}.\n$$\n- 参数化趋势（朴素的、未调整的）为\n$$\nT_{\\text{param}}(z_i) = -\\left.\\frac{\\partial}{\\partial z}\\left( K_m\\, \\frac{\\partial u}{\\partial z} \\right)\\right|_{z_i}.\n$$\n\n6) 双重计算指数 (DCI)：\n- 定义亥维赛函数 $\\mathcal{H}(x)$，当 $x  0$ 时为1，否则为0。\n- 计算\n$$\n\\mathrm{DCI} = \\frac{\\sum_{i=0}^{N-1} \\left[ \\mathcal{H}\\!\\left(T_{\\text{res},i}\\, T_{\\text{param},i}\\right) \\cdot \\min\\!\\left(\\left|T_{\\text{res},i}\\right|, \\left|T_{\\text{param},i}\\right|\\right) \\right]}{\\sum_{i=0}^{N-1} \\left( \\left|T_{\\text{res},i}\\right| + \\left|T_{\\text{param},i}\\right| \\right)}.\n$$\n- 如果分母为零（即两个趋势在所有地方都为零），则设置 $\\mathrm{DCI} = 0$。\n\n7) 解释：\n- $\\mathrm{DCI} \\in [0, 0.5]$，因为在每个层级，重叠贡献的上限是两个量级中的较小者，而分母计算的是量级的总和。\n- 较大的 $\\mathrm{DCI}$ 表示由方向相同的重叠趋势引起的潜在双重计算问题更严重。随着 $\\Delta x$ 减小，$S(\\Delta x)$ 增加，从而增强 $F_{\\text{res}}$ 和 $T_{\\text{res}}$，因此朴素的 $T_{\\text{param}}$ 更可能发生重叠并增加 $\\mathrm{DCI}$。\n- 随着 $\\Delta x$ 增加（网格变粗），$S(\\Delta x)$ 减小，从而减小 $T_{\\text{res}}$，导致较小的重叠和 $\\mathrm{DCI}$。\n\n8) 测试套件执行：\n- 对案例 A–C 使用指定的基准参数 $H = 2000\\,\\mathrm{m}$，$N = 64$，$F_0 = 0.3\\,\\mathrm{m^2\\,s^{-2}}$，$H_e = 600\\,\\mathrm{m}$，$K_0 = 10\\,\\mathrm{m^2\\,s^{-1}}$，$H_k = 500\\,\\mathrm{m}$，$U_0 = 15\\,\\mathrm{m\\,s^{-1}}$，$z_0 = 100\\,\\mathrm{m}$，$L_t = 400\\,\\mathrm{m}$，$p = 1.5$，并将 $\\Delta x$ 分别设置为 $1000\\,\\mathrm{m}$、$250\\,\\mathrm{m}$ 和 $8000\\,\\mathrm{m}$。对于案例 D，设置 $F_0 = 0.0\\,\\mathrm{m^2\\,s^{-2}}$ 和 $U_0 = 0.0\\,\\mathrm{m\\,s^{-1}}$，同时保持 $\\Delta x = 1000\\,\\mathrm{m}$ 和其他参数不变。\n- 计算每个 $\\mathrm{DCI}$ 并四舍五入到六位小数。\n\n9) 输出：\n- 打印单行，其中包含列表 $[\\mathrm{DCI}_A, \\mathrm{DCI}_B, \\mathrm{DCI}_C, \\mathrm{DCI}_D]$，格式为用方括号括起来的逗号分隔小数，每个小数四舍五入到六位小数，符合指定的单位和格式要求。\n\n该算法将雷诺平均公式中垂直动量输送的基本物理原理与一个实用的、尺度感知的诊断工具相结合，该工具通过二阶有限差分在数值上是稳健的，并能得出一个可量化的、无单位的、跨越不同 $\\Delta x$ 的双重计算度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef finite_difference_first_derivative(y, dz):\n    \"\"\"\n    Compute first derivative dy/dz using second-order accurate scheme\n    with centered differences in the interior and one-sided at boundaries.\n    y: array of length N\n    dz: scalar grid spacing\n    Returns dy_dz: array of length N\n    \"\"\"\n    N = y.size\n    dy_dz = np.empty_like(y)\n\n    if N  2:\n        # Degenerate case; no derivative possible\n        dy_dz[:] = 0.0\n        return dy_dz\n\n    # One-sided difference at bottom boundary\n    dy_dz[0] = (y[1] - y[0]) / dz\n    # Centered differences in the interior\n    if N > 2:\n        dy_dz[1:-1] = (y[2:] - y[:-2]) / (2.0 * dz)\n    else:\n        # If N == 2, we only have boundaries\n        pass\n    # One-sided difference at top boundary\n    dy_dz[-1] = (y[-1] - y[-2]) / dz\n\n    return dy_dz\n\ndef compute_profiles(H, N, F0, He, K0, Hk, U0, z0, Lt, p, dx):\n    \"\"\"\n    Compute vertical profiles for z, Fres(z; dx), Km(z), u(z).\n    \"\"\"\n    z = np.linspace(0.0, H, N)\n    dz = z[1] - z[0] if N > 1 else 1.0\n\n    # Scale-partition function S(dx)\n    S = 1.0 / (1.0 + (dx / Lt) ** p)\n\n    # Resolved vertical momentum flux Fres(z; dx)\n    Fres = S * F0 * np.exp(-z / He)\n\n    # Eddy viscosity profile Km(z)\n    Km = K0 * (z / H) * np.exp(-z / Hk)\n\n    # Mean wind profile u(z)\n    u = U0 * (1.0 - np.exp(-z / z0))\n\n    return z, dz, Fres, Km, u\n\ndef compute_tendencies(z, dz, Fres, Km, u):\n    \"\"\"\n    Compute Tres(z) = - dFres/dz and Tparam(z) = - d/dz ( Km * du/dz ).\n    \"\"\"\n    # dFres/dz\n    dF_dz = finite_difference_first_derivative(Fres, dz)\n    Tres = -dF_dz\n\n    # du/dz\n    du_dz = finite_difference_first_derivative(u, dz)\n    # Diffusive flux of momentum: Km * du/dz\n    diff_flux = Km * du_dz\n    # d/dz of diffusive flux\n    d_diff_flux_dz = finite_difference_first_derivative(diff_flux, dz)\n    Tparam = -d_diff_flux_dz\n\n    return Tres, Tparam\n\ndef double_counting_index(Tres, Tparam):\n    \"\"\"\n    Compute DCI as sum(H(Tres*Tparam) * min(|Tres|, |Tparam|)) / sum(|Tres| + |Tparam|)\n    If denominator is zero, return 0.0\n    \"\"\"\n    overlap_mask = (Tres * Tparam) > 0.0\n    overlap_contrib = np.minimum(np.abs(Tres), np.abs(Tparam))\n    numerator = np.sum(overlap_contrib[overlap_mask])\n    denominator = np.sum(np.abs(Tres) + np.abs(Tparam))\n    if denominator == 0.0:\n        return 0.0\n    return numerator / denominator\n\ndef run_case(H, N, F0, He, K0, Hk, U0, z0, Lt, p, dx):\n    z, dz, Fres, Km, u = compute_profiles(H, N, F0, He, K0, Hk, U0, z0, Lt, p, dx)\n    Tres, Tparam = compute_tendencies(z, dz, Fres, Km, u)\n    dci = double_counting_index(Tres, Tparam)\n    return dci\n\ndef solve():\n    # Baseline parameters\n    H = 2000.0      # m\n    N = 64\n    F0 = 0.3        # m^2/s^2\n    He = 600.0      # m\n    K0 = 10.0       # m^2/s\n    Hk = 500.0      # m\n    U0 = 15.0       # m/s\n    z0 = 100.0      # m\n    Lt = 400.0      # m\n    p = 1.5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: dx=1000 m, baseline\n        {\"H\": H, \"N\": N, \"F0\": F0, \"He\": He, \"K0\": K0, \"Hk\": Hk, \"U0\": U0, \"z0\": z0, \"Lt\": Lt, \"p\": p, \"dx\": 1000.0},\n        # Case B: dx=250 m, baseline\n        {\"H\": H, \"N\": N, \"F0\": F0, \"He\": He, \"K0\": K0, \"Hk\": Hk, \"U0\": U0, \"z0\": z0, \"Lt\": Lt, \"p\": p, \"dx\": 250.0},\n        # Case C: dx=8000 m, baseline\n        {\"H\": H, \"N\": N, \"F0\": F0, \"He\": He, \"K0\": K0, \"Hk\": Hk, \"U0\": U0, \"z0\": z0, \"Lt\": Lt, \"p\": p, \"dx\": 8000.0},\n        # Case D: dx=1000 m, no transport (F0=0, U0=0)\n        {\"H\": H, \"N\": N, \"F0\": 0.0, \"He\": He, \"K0\": K0, \"Hk\": Hk, \"U0\": 0.0, \"z0\": z0, \"Lt\": Lt, \"p\": p, \"dx\": 1000.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        dci = run_case(**case)\n        results.append(dci)\n\n    # Final print statement in the exact required format, rounded to six decimals.\n    formatted = \",\".join(f\"{r:.6f}\" for r in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在诊断出灰色地带的潜在问题后，下一步是设计能够智能适应模式分辨率的参数化方案。本实践模拟了参数化开发的核心任务：利用模式输出的诊断信息（如此处的上升气流面积分数）来构建一个尺度感知的系数。您将设计并实现一个质量通量系数的函数形式，该函数能随着模式对对流的解析能力增强而平滑地减弱其影响，从而确保物理过程在从完全参数化到完全解析的过渡中得到一致的表示。",
            "id": "4085754",
            "problem": "您将获得一个用于数值天气预报 (NWP) 和气候模拟的模拟垂直速度扰动场的离散表示。目标是基于一个严格阈值，从一个上升气流掩码中计算出解析的上升气流分数，然后设计一个尺度感知的质量通量系数，该系数取决于此分数以及模式网格间距与对流长度尺度之比。请使用纯数学术语，并遵循与深对流灰色地带的既定惯例一致的以下基本定义和约束。在指定时，请使用标准物理单位。\n\n基本依据和定义：\n- 设垂直速度分解为 $w = \\overline{w} + w'$，其中 $w'$ 是垂直速度扰动，$\\overline{w}$ 是一个缓慢变化的平均值。您将获得每个网格单元中 $w'$ 的离散样本。\n- 通过指示函数定义一个严格上升气流掩码，$I = 1$ 如果 $w'  w_0$，$I = 0$ 否则，其中阈值 $w_0$ 的单位为米每秒 $\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n- 在一个具有 $N$ 个样本的等权重离散网格上，将解析的上升气流分数 $f_{\\mathrm{res}}$ 定义为掩码被激活的样本所占的比例。\n- 定义一个尺度感知参数化方案，旨在提供一个单位为秒的倒数 $\\mathrm{s}^{-1}$ 的质量通量系数 $k$，该系数仅作用于上升气流区域的未解析部分，从而补充解析的贡献。该设计必须满足以下所有约束条件：\n  1. $k$ 必须有界，满足 $0 \\le k \\le C_0$，其中 $C_0$ 是一个基本系数，单位为 $\\mathrm{s}^{-1}$。\n  2. $k$ 必须是 $f_{\\mathrm{res}}$ 的单调非增函数，并且必须满足极限行为：当 $f_{\\mathrm{res}} \\to 0$ 时，$k \\to C_0$；当 $f_{\\mathrm{res}} \\to 1$ 时，$k \\to 0$。\n  3. $k$ 必须平滑地依赖于无量纲的网格与对流尺度之比 $r = \\Delta / L_c$，其中 $\\Delta$ 是网格间距（单位为米 $\\mathrm{m}$），$L_c$ 是对流长度尺度（单位为米 $\\mathrm{m}$）。这种依赖关系必须使得当网格能解析更多的对流运动时，参数化的贡献减小，即对于任何固定的 $f_{\\mathrm{res}} \\in (0,1)$，当 $\\Delta / L_c \\to 0$ 时，$k \\to 0$；当 $\\Delta / L_c \\to +\\infty$ 时，$k \\to C_0 (1 - f_{\\mathrm{res}})$。\n  4. 该设计应由一个正的敏感度指数 $p$（无量纲）来表征，该指数控制 $k$ 随尺度变化的快慢。\n\n您的任务：\n- 对于每个测试用例，使用严格阈值 $w'  w_0$ 计算 $f_{\\mathrm{res}}$。\n- 提出并实现一个与上述约束条件一致的平滑函数形式 $k = \\mathcal{K}(f_{\\mathrm{res}}, \\Delta, L_c, C_0, p)$，确保其量纲正确，为 $\\mathrm{s}^{-1}$。\n- 对于每个测试用例，输出一个包含两个浮点数的列表：首先是 $f_{\\mathrm{res}}$（无量纲），然后是 $k$（单位为 $\\mathrm{s}^{-1}$）。\n\n物理单位：\n- 垂直速度扰动 $w'$ 和阈值 $w_0$ 的单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n- 网格间距 $\\Delta$ 和对流长度 $L_c$ 的单位为 $\\mathrm{m}$。\n- 基本系数 $C_0$ 和设计系数 $k$ 的单位为 $\\mathrm{s}^{-1}$。\n\n角度单位不适用。\n\n测试套件：\n使用以下测试用例集来覆盖一般行为、极限情况和边界条件。在每个用例中，$w'$ 值的列表单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$，阈值 $w_0$ 的单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$，$\\Delta$ 和 $L_c$ 的单位为 $\\mathrm{m}$，$C_0$ 的单位为 $\\mathrm{s}^{-1}$，而 $p$ 是无量纲的：\n- 用例 1 (一般混合场，灰色地带尺度): $w' = [-0.2, 0.3, 0.7, 1.2, -0.1, 0.5, 0.0, -0.4, 0.8, -0.3]$, $w_0 = 0.5$, $\\Delta = 1000$, $L_c = 1000$, $C_0 = 0.005$, $p = 1$。\n- 用例 2 (粗网格，无解析的上升气流): $w' = [-0.1, 0.4, 0.5, -0.2, 0.49]$, $w_0 = 0.5$, $\\Delta = 10000$, $L_c = 2000$, $C_0 = 0.006$, $p = 1$。\n- 用例 3 (所有上升气流均被解析): $w' = [0.6, 0.7, 0.8, 1.0]$, $w_0 = 0.5$, $\\Delta = 5000$, $L_c = 1000$, $C_0 = 0.004$, $p = 1$。\n- 用例 4 (阈值相等边界): $w' = [0.5, 0.5, 0.5, 0.49, 0.51]$, $w_0 = 0.5$, $\\Delta = 1000$, $L_c = 1500$, $C_0 = 0.005$, $p = 1$。\n- 用例 5 (细网格，强尺度感知): $w' = [0.1, 0.6, 0.7, -0.1, 1.2, 0.4, 0.55, -0.2]$, $w_0 = 0.5$, $\\Delta = 200$, $L_c = 1000$, $C_0 = 0.01$, $p = 2$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且本身是一个包含 $[f_{\\mathrm{res}}, k]$ 的双元素列表。例如，您的输出应类似于 $[[f_1,k_1],[f_2,k_2],\\dots]$，所有数值均表示为标准浮点数。",
            "solution": "问题陈述已经过严格验证，被认为是具有科学依据、适定且客观的。它提出了大气模拟领域内一个标准的、尽管具有挑战性的设计任务，特别涉及对流灰色地带中次网格尺度过程的参数化。为质量通量系数设计所提供的约束条件大体上是一致的，仅在极限行为的相互作用中存在轻微的模糊性，这可以通过符合物理原理的解释来解决。因此，我们可以继续进行完整的求解。\n\n解决方案分为两部分：首先，计算解析的上升气流分数 $f_{\\mathrm{res}}$；其次，设计并实现尺度感知质量通量系数 $k$ 的函数形式。\n\n**第 1 部分：解析的上升气流分数 ($f_{\\mathrm{res}}$) 的计算**\n\n问题将解析的上升气流分数 $f_{\\mathrm{res}}$ 定义为垂直速度扰动 $w'$ 超过给定阈值 $w_0$ 的网格点所占的比例。在一个具有 $N$ 个等权重 $w'$ 样本的离散网格上，这通过首先用指示函数 $I_i$ 定义一个上升气流掩码来计算：\n$$\nI_i =\n\\begin{cases}\n1  \\text{如果 } w'_i  w_0 \\\\\n0  \\text{否则}\n\\end{cases}\n$$\n其中 $w'_i$ 是垂直速度扰动的第 $i$ 个样本。解析的上升气流分数则是所有 $N$ 个样本上指示函数的算术平均值：\n$$\nf_{\\mathrm{res}} = \\frac{1}{N} \\sum_{i=1}^{N} I_i\n$$\n对每个测试用例，使用所提供的 $w'$ 值列表和相应的 $w_0$ 阈值来执行此计算。\n\n**第 2 部分：尺度感知质量通量系数 ($k$) 的设计**\n\n主要任务是设计一个平滑函数 $k = \\mathcal{K}(f_{\\mathrm{res}}, \\Delta, L_c, C_0, p)$，使其满足一系列特定的约束条件。让我们分析这些约束来指导设计。我们将无量纲尺度比定义为 $r = \\Delta / L_c$。\n\n约束条件如下：\n1.  **有界性**: $0 \\le k \\le C_0$。\n2.  **对 $f_{\\mathrm{res}}$ 的依赖性**: $k$ 是 $f_{\\mathrm{res}}$ 的单调非增函数。它必须满足极限：当 $f_{\\mathrm{res}} \\to 0$ 时 $k \\to C_0$，当 $f_{\\mathrm{res}} \\to 1$ 时 $k \\to 0$。\n3.  **对 $r$ 的依赖性**: $k$ 是 $r$ 的平滑函数。它必须满足极限：当 $r \\to 0$ 时 $k \\to 0$（高分辨率极限），当 $r \\to +\\infty$ 时 $k \\to C_0 (1 - f_{\\mathrm{res}})$（粗分辨率极限）。\n4.  **敏感度**: 一个正指数 $p$ 控制随尺度变化的速率。\n\n在点 $(r, f_{\\mathrm{res}}) = (0, 0)$ 处，约束 2 ($f_{\\mathrm{res}} \\to 0$ 时 $k \\to C_0$) 和约束 3 ($r \\to 0$ 时 $k \\to 0$) 之间存在一个潜在的冲突，因为极限值取决于所采用的路径。在物理建模中的一种标准解释是，一般性约束（如约束 2）描述的是参数化方案完全激活时的行为，即粗网格极限 ($r \\to \\infty$)。来自约束 3 的粗网格极限，即当 $r \\to \\infty$ 时 $k \\to C_0 (1 - f_{\\mathrm{res}})$，在 $f_{\\mathrm{res}} \\to 0$ 时正确地得到 $k \\to C_0$。因此，我们可以通过设计一个能在高分辨率网格行为 ($k=0$) 和粗分辨率网格行为之间正确插值的函数来综合这些约束。\n\n让我们将粗网格行为定义为 $k_{\\mathrm{coarse}}(f_{\\mathrm{res}}) = C_0 (1 - f_{\\mathrm{res}})$。这种形式已经满足了粗网格极限下对 $f_{\\mathrm{res}}$ 的单调性和极限行为的要求。\n\n现在，我们引入一个尺度依赖的混合函数 $S(r, p)$，它调节这种粗网格行为。函数 $S(r, p)$ 必须封装尺度感知特性。它必须满足：\n- 当 $r \\to 0$ 时，$S(r, p) \\to 0$。\n- 当 $r \\to +\\infty$ 时，$S(r, p) \\to 1$。\n- 对于 $r \\ge 0$，$S(r, p)$ 必须是 $r$ 的平滑、单调递增函数。\n- 指数 $p$ 应控制过渡的陡峭程度。\n\n我们为 $k$ 提出以下函数形式：\n$$\nk = k_{\\mathrm{coarse}}(f_{\\mathrm{res}}) \\cdot S(r, p) = C_0 (1 - f_{\\mathrm{res}}) \\cdot S(r, p)\n$$\n满足其所有要求的混合函数 $S(r, p)$ 的一个常见且合适的选择是 Hill-Langmuir 型的有理函数：\n$$\nS(r, p) = \\frac{r^p}{1 + r^p}\n$$\n该函数在 $r \\ge 0$ 时是平滑的（对于整数 $p \\ge 1$），当 $r$ 从 $0$ 变到 $\\infty$ 时，函数值从 $0$ 过渡到 $1$，并且指数 $p$ 控制着 $r=1$ 附近过渡的锐度。\n\n因此，我们最终提出的函数形式是：\n$$\nk(f_{\\mathrm{res}}, r, C_0, p) = C_0 (1 - f_{\\mathrm{res}}) \\frac{r^p}{1 + r^p}\n$$\n其中 $r = \\Delta / L_c$。该函数在前面讨论的符合物理原理的一致解释下满足所有约束条件。由于 $0 \\le f_{\\mathrm{res}} \\le 1$ 且 $0 \\le S(r,p)  1$，界限 $0 \\le k  C_0$ 得到保证。\n\n每个测试用例的步骤如下：\n1.  根据给定的 $w'$ 数组和 $w_0$ 阈值计算 $f_{\\mathrm{res}}$。\n2.  计算尺度比 $r = \\Delta / L_c$。\n3.  将 $f_{\\mathrm{res}}$、$r$、$C_0$ 和 $p$ 代入导出的 $k$ 公式中以计算其值。\n4.  返回数对 $[f_{\\mathrm{res}}, k]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the resolved updraft fraction and a scale-aware mass-flux coefficient\n    for a series of test cases based on a derived functional form.\n    \"\"\"\n    test_cases = [\n        {'w_prime': [-0.2, 0.3, 0.7, 1.2, -0.1, 0.5, 0.0, -0.4, 0.8, -0.3], 'w0': 0.5, 'Delta': 1000, 'Lc': 1000, 'C0': 0.005, 'p': 1},\n        {'w_prime': [-0.1, 0.4, 0.5, -0.2, 0.49], 'w0': 0.5, 'Delta': 10000, 'Lc': 2000, 'C0': 0.006, 'p': 1},\n        {'w_prime': [0.6, 0.7, 0.8, 1.0], 'w0': 0.5, 'Delta': 5000, 'Lc': 1000, 'C0': 0.004, 'p': 1},\n        {'w_prime': [0.5, 0.5, 0.5, 0.49, 0.51], 'w0': 0.5, 'Delta': 1000, 'Lc': 1500, 'C0': 0.005, 'p': 1},\n        {'w_prime': [0.1, 0.6, 0.7, -0.1, 1.2, 0.4, 0.55, -0.2], 'w0': 0.5, 'Delta': 200, 'Lc': 1000, 'C0': 0.01, 'p': 2},\n    ]\n\n    results = []\n    \n    def mass_flux_coefficient(f_res, r, C0, p):\n        \"\"\"\n        Calculates the scale-aware mass-flux coefficient k based on the derived model.\n        k(f_res, r, C0, p) = C0 * (1 - f_res) * (r^p / (1 + r^p))\n        \"\"\"\n        # Handle the edge case r = 0 to avoid potential 0/0 or inf/inf with large p\n        if r == 0:\n            return 0.0\n            \n        scale_function = (r**p) / (1 + r**p)\n        k = C0 * (1 - f_res) * scale_function\n        return k\n\n    for case in test_cases:\n        w_prime = np.array(case['w_prime'])\n        w0 = case['w0']\n        Delta = case['Delta']\n        Lc = case['Lc']\n        C0 = case['C0']\n        p = case['p']\n\n        # Part 1: Compute the resolved updraft fraction (f_res)\n        num_samples = len(w_prime)\n        if num_samples == 0:\n            f_res = 0.0\n        else:\n            # Count samples where w' > w0 (strict inequality)\n            updraft_mask = w_prime > w0\n            num_updrafts = np.sum(updraft_mask)\n            f_res = num_updrafts / num_samples\n\n        # Part 2: Compute the mass-flux coefficient (k)\n        scale_ratio = Delta / Lc\n        k = mass_flux_coefficient(f_res, scale_ratio, C0, p)\n\n        # Format each result pair as [f_res, k]\n        results.append(f\"[{f_res},{k}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}