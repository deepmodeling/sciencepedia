{
    "hands_on_practices": [
        {
            "introduction": "次季节到季节（S2S）预测的一个核心挑战是识别预报技巧的来源。这项练习  将指导你设计一个受控数值实验，以区分气候系统中两个关键的缓慢变化分量——土壤湿度和海表温度——的影响。通过将系统简化为一个线性模型，你将推导出可预报性（以距平相关系数衡量）如何直接取决于来自每个来源的信噪比。",
            "id": "4096547",
            "problem": "考虑一个简化的周平均近地表温度异常模型，该模型适用于数值天气预报（NWP）和气候模拟中的次季节到季节（S2S）预测。目标是通过设计采用固定气候学边界场的受控实验，来分离土壤湿度（SM）与海表温度（SST）对周温度可预报性的影响。令周平均$2$米温度异常表示为$T$，土壤湿度异常表示为$W$，海表温度异常表示为$S$。假设在第$1$周预报时效，温度异常对同期陆地和海洋异常以及快速大气噪声呈线性响应，且受控初始条件满足$T_0 = 0$（气候态）。该响应由下式描述：\n$$\nT_1 = b_w W_0 + b_s S_0 + \\eta_0,\n$$\n其中$b_w$和$b_s$是线性敏感度系数（单位分别为单位$W$和$S$异常对应的温度异常），$W_0$和$S_0$是方差分别为$\\sigma_w^2$和$\\sigma_s^2$的零均值随机初始异常，$\\eta_0$是方差为$\\sigma_\\eta^2$的零均值快速大气噪声，且与$W_0$和$S_0$相互独立。为符合科学真实性，所有方差均为严格非负实数，且$\\sigma_\\eta^2 > 0$。\n\n设计两个受控实验：\n$1.$ 仅土壤实验：将SST边界场固定为气候态，即设置$S_0 = 0$，同时允许$W_0$根据其分布变化。使用线性模型和受控初始条件预报周平均温度异常。\n$2.$ 仅海洋实验：将SM边界场固定为气候态，即设置$W_0 = 0$，同时允许$S_0$根据其分布变化。使用线性模型和受控初始条件预报周平均温度异常。\n\n定义周平均预报异常与验证真值异常之间的异常相关系数（ACC），即作为协方差除以标准差之积计算出的异常间的Pearson相关系数。在两个实验中，将预报视为在$T_0 = 0$条件下对保留的异常（SM或SST）的确定性模式响应，并将验证真值视为包含随机噪声的模式响应。ACC是无量纲的。\n\n实现一个程序，给定多组参数$(b_w, \\sigma_w, b_s, \\sigma_s, \\sigma_\\eta)$，为每个测试用例计算：\n$1.$ 仅土壤实验下的ACC，记为$\\mathrm{ACC}_{\\text{soil}}$。\n$2.$ 仅海洋实验下的ACC，记为$\\mathrm{ACC}_{\\text{ocean}}$。\n\n为保证科学一致性，假设$W_0 \\sim \\mathcal{N}(0,\\sigma_w^2)$、$S_0 \\sim \\mathcal{N}(0,\\sigma_s^2)$和$\\eta_0 \\sim \\mathcal{N}(0,\\sigma_\\eta^2)$，三者相互独立，并使用标准相关性定义。尽管$b_w$和$b_s$可能通过线性敏感度隐式地带有物理单位，但输出$\\mathrm{ACC}_{\\text{soil}}$和$\\mathrm{ACC}_{\\text{ocean}}$是无量纲的浮点数。输出不涉及角度或百分比。\n\n使用以下参数集测试套件来评估设计：\n$1.$ $(b_w, \\sigma_w, b_s, \\sigma_s, \\sigma_\\eta) = (0.6, 1.2, 0.4, 1.0, 1.0)$。\n$2.$ $(b_w, \\sigma_w, b_s, \\sigma_s, \\sigma_\\eta) = (0.0, 1.0, 0.6, 1.2, 1.0)$。\n$3.$ $(b_w, \\sigma_w, b_s, \\sigma_s, \\sigma_\\eta) = (0.5, 1.0, 0.5, 1.0, 3.0)$。\n$4.$ $(b_w, \\sigma_w, b_s, \\sigma_s, \\sigma_\\eta) = (0.2, 1.0, 1.0, 1.5, 0.8)$。\n$5.$ $(b_w, \\sigma_w, b_s, \\sigma_s, \\sigma_\\eta) = (0.5, 1.0, 0.5, 1.0, 1.5)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，按$\\mathrm{ACC}_{\\text{soil}}, \\mathrm{ACC}_{\\text{ocean}}$的顺序输出两个浮点数，保留三位小数，并将所有测试用例的结果连接起来，最终输出形式为$[\\mathrm{ACC}_{\\text{soil},1},\\mathrm{ACC}_{\\text{ocean},1},\\mathrm{ACC}_{\\text{soil},2},\\mathrm{ACC}_{\\text{ocean},2},\\dots]$。所有输出均为无量綱浮点数。",
            "solution": "指导原则是将周平均温度异常的可预报性表示为一种相关性，该相关性源于线性确定性信号分量和随机天气噪声，并通过固定的气候学边界场来受控地分离土壤湿度（SM）和海表温度（SST）的影响。我们从一个线性响应模型开始，该模型植根于地表能量平衡的线性化以及经过充分检验的周异常行为，其中陆地和海洋异常对近地表温度产生一阶线性影响：\n$$\nT_1 = b_w W_0 + b_s S_0 + \\eta_0,\n$$\n强制$T_0 = 0$以消除大气持續性的混淆，并实施仅关注陆地和海洋边界异常影响的受控初始条件。此处，$W_0$和$S_0$分别表示方差为$\\sigma_w^2$和$\\sigma_s^2$的零均值随机初始异常，$\\eta_0$表示方差为$\\sigma_\\eta^2$的零均值快速大气噪声。假设$W_0$、$S_0$和$\\eta_0$相互独立，这是推导可预报性度量时一个标准且易于处理的理想化假设。\n\n我们通过进行两个将另一边界场固定为气候态（零异常）的实验来分离SM和SST的影响：\n$1.$ 仅土壤实验：设置$S_0 = 0$。验证真值为\n$$\nT_1^{(\\text{soil})} = b_w W_0 + \\eta_0,\n$$\n基于受控初始条件和线性模型的确定性预报为\n$$\nF^{(\\text{soil})} = b_w W_0.\n$$\n$2.$ 仅海洋实验：设置$W_0 = 0$。验证真值为\n$$\nT_1^{(\\text{ocean})} = b_s S_0 + \\eta_0,\n$$\n确定性预报为\n$$\nF^{(\\text{ocean})} = b_s S_0.\n$$\n\n为量化可预报性，我们使用异常相关系数（ACC），其定义为预报与验证真值异常之间的Pearson相关系数。对于任意一对具有有限方差的随机变量$X$和$Y$，其相关性为\n$$\n\\rho(X,Y) = \\frac{\\mathrm{Cov}(X,Y)}{\\sqrt{\\mathrm{Var}(X)\\,\\mathrm{Var}(Y)}}.\n$$\n这是一个经过充分检验的统计公式，适用于通过相关性评估预报技巧。\n\n现在我们计算$\\mathrm{ACC}_{\\text{soil}}$。在独立性假设和零均值条件下：\n$1.$ 计算$\\mathrm{Cov}(F^{(\\text{soil})}, T_1^{(\\text{soil})})$。由于$F^{(\\text{soil})} = b_w W_0$且$T_1^{(\\text{soil})} = b_w W_0 + \\eta_0$，并且$\\eta_0$与$W_0$独立且均值为零，我们有\n$$\n\\mathrm{Cov}(F^{(\\text{soil})}, T_1^{(\\text{soil})}) = \\mathrm{Cov}(b_w W_0, b_w W_0 + \\eta_0) = b_w^2 \\mathrm{Var}(W_0) = b_w^2 \\sigma_w^2.\n$$\n$2.$ 计算$\\mathrm{Var}(F^{(\\text{soil})})$。因为$F^{(\\text{soil})} = b_w W_0$且$W_0$的均值为零，我们得到\n$$\n\\mathrm{Var}(F^{(\\text{soil})}) = b_w^2 \\mathrm{Var}(W_0) = b_w^2 \\sigma_w^2.\n$$\n$3.$ 计算$\\mathrm{Var}(T_1^{(\\text{soil})})$。利用独立性，\n$$\n\\mathrm{Var}(T_1^{(\\text{soil})}) = \\mathrm{Var}(b_w W_0 + \\eta_0) = b_w^2 \\sigma_w^2 + \\sigma_\\eta^2.\n$$\n$4.$ 结合这些可得\n$$\n\\mathrm{ACC}_{\\text{soil}} = \\frac{b_w^2 \\sigma_w^2}{\\sqrt{(b_w^2 \\sigma_w^2)\\,(b_w^2 \\sigma_w^2 + \\sigma_\\eta^2)}} = \\sqrt{\\frac{b_w^2 \\sigma_w^2}{b_w^2 \\sigma_w^2 + \\sigma_\\eta^2}}.\n$$\n\n根据对称性，仅海洋的情况得出\n$1.$ $\\mathrm{Cov}(F^{(\\text{ocean})}, T_1^{(\\text{ocean})}) = b_s^2 \\sigma_s^2$，\n$2.$ $\\mathrm{Var}(F^{(\\text{ocean})}) = b_s^2 \\sigma_s^2$，\n$3.$ $\\mathrm{Var}(T_1^{(\\text{ocean})}) = b_s^2 \\sigma_s^2 + \\sigma_\\eta^2$，\n因此\n$$\n\\mathrm{ACC}_{\\text{ocean}} = \\sqrt{\\frac{b_s^2 \\sigma_s^2}{b_s^2 \\sigma_s^2 + \\sigma_\\eta^2}}.\n$$\n\n这些表达式是无量纲的，反映了通过将边界异常固定为气候态和使用受控初始条件所实现的分离效果。它们通过直接比较每个受控实验中预报与真值相关性内嵌的信噪比，来量化SM和SST对周温度可预报性的影响。\n\n程序的算法设计：\n$1.$ 将测试套件编码为参数元组列表$(b_w, \\sigma_w, b_s, \\sigma_s, \\sigma_\\eta)$。\n$2.$ 对每个元组，使用下式计算$\\mathrm{ACC}_{\\text{soil}}$\n$$\n\\mathrm{ACC}_{\\text{soil}} = \\sqrt{\\frac{b_w^2 \\sigma_w^2}{b_w^2 \\sigma_w^2 + \\sigma_\\eta^2}}.\n$$\n$3.$ 使用下式计算$\\mathrm{ACC}_{\\text{ocean}}$\n$$\n\\mathrm{ACC}_{\\text{ocean}} = \\sqrt{\\frac{b_s^2 \\sigma_s^2}{b_s^2 \\sigma_s^2 + \\sigma_\\eta^2}}.\n$$\n$4.$ 将每个ACC四舍五入到$3$位小数，并按照每个测试用例的$\\mathrm{ACC}_{\\text{soil}}, \\mathrm{ACC}_{\\text{ocean}}$顺序将它们附加到一个扁平列表中。\n$5.$ 按照规定，将最终列表打印在单行上，条目以逗号分隔并用方括号括起来。\n\n科学真实性与边界情况：\n$1.$ 如果$b_w = 0$，则$\\mathrm{ACC}_{\\text{soil}} = 0$，因为预报中没有信号；类似地，如果$b_s = 0$，则$\\mathrm{ACC}_{\\text{ocean}} = 0$。\n$2.$ 更大的$\\sigma_\\eta^2$会降低两个ACC，反映出更大的天气噪声降低了周可预报性。\n$3.$ 更大的$b_w^2 \\sigma_w^2$或$b_s^2 \\sigma_s^2$会增加ACC，反映出更强的陆地或海洋信号和/或更大的初始异常方差对可预报信号的贡献。\n\n所提供的测试套件涵盖了一般情况、无土壤耦合的边界情况、噪声主导的情况、强海洋耦合的情况以及敏感度相等的平衡情况，从而确保了在不同机制下对逻辑的全面验证。输出中不需要物理单位，因为ACC在构造上是无量纲的，并且所有计算都局限于受控边界条件下预报时效为1周的可预报性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef acc_linear(b: float, sigma_source: float, sigma_eta: float) -> float:\n    \"\"\"\n    Compute the Anomaly Correlation Coefficient (ACC) for a linear forecast:\n        F = b * X\n        T = b * X + eta\n    where X ~ N(0, sigma_source^2), eta ~ N(0, sigma_eta^2), independent.\n\n    ACC = sqrt( (b^2 * sigma_source^2) / (b^2 * sigma_source^2 + sigma_eta^2) )\n\n    Parameters\n    ----------\n    b : float\n        Linear sensitivity coefficient.\n    sigma_source : float\n        Standard deviation of the source anomaly (soil moisture or SST).\n    sigma_eta : float\n        Standard deviation of the atmospheric noise.\n\n    Returns\n    -------\n    float\n        Dimensionless ACC in [0, 1].\n    \"\"\"\n    signal_var = (b ** 2) * (sigma_source ** 2)\n    total_var = signal_var + (sigma_eta ** 2)\n    # Guard against numerical issues; total_var > 0 by construction in test suite.\n    if total_var == 0.0:\n        return 0.0\n    return float(np.sqrt(signal_var / total_var))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (b_w, sigma_w, b_s, sigma_s, sigma_eta)\n    test_cases = [\n        (0.6, 1.2, 0.4, 1.0, 1.0),\n        (0.0, 1.0, 0.6, 1.2, 1.0),\n        (0.5, 1.0, 0.5, 1.0, 3.0),\n        (0.2, 1.0, 1.0, 1.5, 0.8),\n        (0.5, 1.0, 0.5, 1.0, 1.5),\n    ]\n\n    results = []\n    for (b_w, sigma_w, b_s, sigma_s, sigma_eta) in test_cases:\n        acc_soil = acc_linear(b_w, sigma_w, sigma_eta)\n        acc_ocean = acc_linear(b_s, sigma_s, sigma_eta)\n        # Round to three decimal places as specified\n        results.append(round(acc_soil, 3))\n        results.append(round(acc_ocean, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "数值模型的原始输出通常包含系统性误差或偏差。这个实践性的编码练习  介绍了一种基本的后处理技术——均值-方差校准——利用历史预报数据（回报）来纠正这些偏差。你将实施这种校准并评估其对关键检验指标的影响，亲眼见证统计调整如何提高预报质量。",
            "id": "4096533",
            "problem": "一个每周的次季节至季节预报系统会生成一个跨越多个过去年份（后向预测期）的固定日历周的预报温度时间序列，以及一个针对当前验证期的独立时间序列。设后向预测预报为以摄氏度为单位的实数列表，后向预测观测为相同日历周和年份的以摄氏度为单位的实数列表。验证期包括一个后续年份中相同日历周的实值周预报列表和一个实值周观测列表。您需要设计并实现一个程序，该程序执行从第一性原理推导出的均值-方差校准，然后使用两个指标评估其效果：异常相关系数和均方根误差。\n\n从以下基本依据出发：\n- 支配线性变换和矩的统计定律：如果一个随机变量 $X$ 的均值为 $\\mu_X$ 且标准差为 $\\sigma_X$（总体定义），并且 $Y = aX + b$，那么 $Y$ 的均值为 $a \\mu_X + b$，$Y$ 的标准差为 $\\lvert a \\rvert \\sigma_X$。\n- 对于一个有限列表 $\\{x_i\\}_{i=1}^N$，总体均值和总体标准差分别定义为 $\\mu = \\frac{1}{N} \\sum_{i=1}^N x_i$ 和 $\\sigma = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N (x_i - \\mu)^2}$。\n- 两个等长的有限列表 $\\{p_i\\}_{i=1}^N$ 和 $\\{q_i\\}_{i=1}^N$ 之间的均方根误差 (RMSE) 定义为 $\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N (p_i - q_i)^2}$。\n- 相对于气候基线的值的异常是其与参考均值的差值。对于每周异常验证，使用该日历周的后向预测观测均值作为气候基线。\n- 两个有限列表 $\\{x_i\\}_{i=1}^N$ 和 $\\{y_i\\}_{i=1}^N$ 之间的 Pearson 相关系数定义为 $\\rho = \\frac{\\sum_{i=1}^N (x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum_{i=1}^N (x_i - \\bar{x})^2} \\sqrt{\\sum_{i=1}^N (y_i - \\bar{y})^2}}$，其中 $\\bar{x}$ 和 $\\bar{y}$ 是被相关计算的 $N$ 个值的样本均值。在本问题中，将其应用于相对于后向预测观测均值计算的异常。如果有效对少于 $2$ 对，或者任一异常序列的方差为零，则将异常相关系数定义为 $0$。\n\n您的程序必须：\n- 使用后向预测预报列表，根据总体定义估算后向预测预报均值 $\\mu_f$ 和后向预测预报标准差 $\\sigma_f$。\n- 使用后向预测观测列表，根据总体定义估算后向预测观测均值 $\\mu_o$ 和后向预测观测标准差 $\\sigma_o$。\n- 推导验证预报的线性变换，使其与后向预测观测的均值和标准差相匹配（即，产生一个均值为 $\\mu_o$、标准差为 $\\sigma_o$ 的校正后预报序列）。实现由此产生的校正，并用它来生成一个校正后的验证预报序列。如果 $\\sigma_f = 0$（或在数值公差范围内实际为零），则将所有验证时间的校正后预报定义为等于 $\\mu_o$。\n- 计算校正前（使用原始验证预报）和校正后（使用校正后的验证预报）的异常相关系数和 RMSE。对于异常，从预报和观测中都减去 $\\mu_o$。以摄氏度表示 RMSE。如果任何验证预报-观测对包含非有限值，则从所有指标计算中省略该对。如果有效对为零，则将两个指标都定义为 $0$。\n\n使用以下测试套件，其中所有温度都以摄氏度为单位：\n- 情况 $1$ (常规成功路径):\n    - 后向预测预报: $[10,12,14,16]$\n    - 后向预测观测: $[11,12,15,17]$\n    - 验证预报: $[13,15,17]$\n    - 验证观测: $[12,16,18]$\n- 情况 $2$ (边界条件 $\\sigma_f = 0$):\n    - 后向预测预报: $[14,14,14,14]$\n    - 后向预测观测: $[13,14,15,16]$\n    - 验证预报: $[14,14,14]$\n    - 验证观测: $[13,16,15]$\n- 情况 $3$ (验证中边界条件 $N = 1$):\n    - 后向预测预报: $[8,9,10,11]$\n    - 后向预测观测: $[7,9,11,13]$\n    - 验证预报: $[10]$\n    - 验证观测: $[12]$\n- 情况 $4$ (负协方差场景):\n    - 后向预测预报: $[20,18,16,14,12]$\n    - 后向预测观测: $[15,16,17,18,19]$\n    - 验证预报: $[13,17,15,19]$\n    - 验证观测: $[19,15,17,13]$\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、针对四种情况的逗号分隔结果列表。每种情况的结果必须是按 $[\\text{AC}_{\\text{raw}}, \\text{RMSE}_{\\text{raw}}, \\text{AC}_{\\text{corr}}, \\text{RMSE}_{\\text{corr}}]$ 顺序排列的四个浮点数列表，其中 $\\text{AC}$ 是异常相关系数（无单位），$\\text{RMSE}$ 以摄氏度为单位。例如，格式为 $[[x_{1,1},x_{1,2},x_{1,3},x_{1,4}],[x_{2,1},x_{2,2},x_{2,3},x_{2,4}],[x_{3,1},x_{3,2},x_{3,3},x_{3,4}],[x_{4,1},x_{4,2},x_{4,3},x_{4,4}]]$，不含多余的空格或文本。",
            "solution": "本问题的核心是推导并应用一个线性变换来对预报进行均值-方差校准。我们寻求一个校正后的预报 $f_{\\text{corr}} = a \\cdot f_{\\text{raw}} + b$，使其统计矩（均值和标准差）与后向预测期间的观测气候分布相匹配。我们从后向预测数据中估算预报的均值 $\\mu_f$ 和标准差 $\\sigma_f$，以及观测的均值 $\\mu_o$ 和标准差 $\\sigma_o$。\n\n根据随机变量线性变换的定律，我们要求：\n1.  均值匹配：$\\mathbb{E}[f_{\\text{corr}}] = a \\cdot \\mu_f + b = \\mu_o$\n2.  标准差匹配：$\\mathrm{StdDev}[f_{\\text{corr}}] = |a| \\cdot \\sigma_f = \\sigma_o$\n\n假设一个正的缩放因子 $a$ 以保持异常的符号（即 $a>0$），我们从标准差方程解出 $a$：\n$$ a = \\frac{\\sigma_o}{\\sigma_f} $$\n这仅在 $\\sigma_f > 0$ 时有效。如果 $\\sigma_f = 0$，则校正后的预报为常数 $\\mu_o$。\n\n将 $a$ 代入均值方程，我们解出偏移量 $b$：\n$$ b = \\mu_o - a \\mu_f = \\mu_o - \\left(\\frac{\\sigma_o}{\\sigma_f}\\right) \\mu_f $$\n\n将 $a$ 和 $b$ 结合，完整的线性变换公式为：\n$$ f_{\\text{corr}} = \\left(\\frac{\\sigma_o}{\\sigma_f}\\right) f_{\\text{raw}} + \\left(\\mu_o - \\frac{\\sigma_o}{\\sigma_f} \\mu_f\\right) $$\n该公式可以重新排列成一个更直观的形式，即标准化原始预报异常后，再根据观测分布进行缩放和平移：\n$$ f_{\\text{corr}} = \\mu_o + \\frac{\\sigma_o}{\\sigma_f} (f_{\\text{raw}} - \\mu_f) $$\n\n该程序首先计算后向预测期间的这些统计量，然后将此变换应用于验证预报。最后，计算校准前后预报的异常相关系数（AC）和均方根误差（RMSE）以评估校准的效果。由于AC对线性变换是不变的，因此理论上校准前后的AC值应保持不变（假设 $\\sigma_f > 0$），而RMSE则有望通过消除均值和方差偏差而得到改善。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n\n    def process_case(h_forecasts, h_observations, v_forecasts, v_observations):\n        \"\"\"\n        Processes a single test case for forecast calibration and verification.\n        \n        Args:\n            h_forecasts (list): Hindcast forecast values.\n            h_observations (list): Hindcast observation values.\n            v_forecasts (list): Validation forecast values.\n            v_observations (list): Validation observation values.\n\n        Returns:\n            list: A list of four floats [AC_raw, RMSE_raw, AC_corr, RMSE_corr].\n        \"\"\"\n        # Convert all inputs to numpy arrays for vectorized operations\n        h_forecasts_np = np.array(h_forecasts, dtype=float)\n        h_observations_np = np.array(h_observations, dtype=float)\n        v_forecasts_np = np.array(v_forecasts, dtype=float)\n        v_observations_np = np.array(v_observations, dtype=float)\n\n        # Filter validation data for finite pairs\n        valid_mask = np.isfinite(v_forecasts_np) & np.isfinite(v_observations_np)\n        valid_v_forecasts = v_forecasts_np[valid_mask]\n        valid_v_observations = v_observations_np[valid_mask]\n\n        # Handle edge case: zero valid pairs\n        if valid_v_forecasts.size == 0:\n            return [0.0, 0.0, 0.0, 0.0]\n\n        # --- Step 1: Calculate Hindcast Statistics ---\n        # Population mean and standard deviation for hindcast period\n        mu_f = np.mean(h_forecasts_np)\n        sigma_f = np.std(h_forecasts_np) # np.std computes population std dev by default\n        mu_o = np.mean(h_observations_np)\n        sigma_o = np.std(h_observations_np)\n\n        # The climatological baseline for anomalies is the hindcast observed mean\n        climatology = mu_o\n\n        # --- Helper function to compute metrics ---\n        def calculate_metrics(forecasts, observations):\n            \"\"\"Computes Anomaly Correlation and RMSE.\"\"\"\n            # RMSE\n            rmse = np.sqrt(np.mean((forecasts - observations)**2))\n            \n            # Anomaly Correlation (AC)\n            # Conditions for AC to be 0\n            if forecasts.size < 2:\n                ac = 0.0\n            else:\n                anom_f = forecasts - climatology\n                anom_o = observations - climatology\n                \n                # Check for zero variance in anomaly series\n                if np.isclose(np.var(anom_f), 0) or np.isclose(np.var(anom_o), 0):\n                    ac = 0.0\n                else:\n                    # np.corrcoef returns a 2x2 matrix\n                    ac = np.corrcoef(anom_f, anom_o)[0, 1]\n            return ac, rmse\n\n        # --- Step 2: Calculate Raw Metrics ---\n        ac_raw, rmse_raw = calculate_metrics(valid_v_forecasts, valid_v_observations)\n\n        # --- Step 3: Apply Correction to Validation Forecasts ---\n        # Check for the special case of zero forecast standard deviation\n        if np.isclose(sigma_f, 0):\n            # Corrected forecast is a constant series of the observed mean\n            corrected_v_forecasts = np.full_like(valid_v_forecasts, mu_o)\n        else:\n            # Apply the mean-variance calibration formula\n            # f_corr = mu_o + (sigma_o / sigma_f) * (f_raw - mu_f)\n            corrected_v_forecasts = mu_o + (sigma_o / sigma_f) * (valid_v_forecasts - mu_f)\n\n        # --- Step 4: Calculate Corrected Metrics ---\n        ac_corr, rmse_corr = calculate_metrics(corrected_v_forecasts, valid_v_observations)\n        \n        return [ac_raw, rmse_raw, ac_corr, rmse_corr]\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            \"h_forecasts\": [10, 12, 14, 16],\n            \"h_observations\": [11, 12, 15, 17],\n            \"v_forecasts\": [13, 15, 17],\n            \"v_observations\": [12, 16, 18],\n        },\n        {\n            \"h_forecasts\": [14, 14, 14, 14],\n            \"h_observations\": [13, 14, 15, 16],\n            \"v_forecasts\": [14, 14, 14],\n            \"v_observations\": [13, 16, 15],\n        },\n        {\n            \"h_forecasts\": [8, 9, 10, 11],\n            \"h_observations\": [7, 9, 11, 13],\n            \"v_forecasts\": [10],\n            \"v_observations\": [12],\n        },\n        {\n            \"h_forecasts\": [20, 18, 16, 14, 12],\n            \"h_observations\": [15, 16, 17, 18, 19],\n            \"v_forecasts\": [13, 17, 15, 19],\n            \"v_observations\": [19, 15, 17, 13],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(**case)\n        results.append(result)\n        \n    # Format the final output string according to the spec (no spaces)\n    case_strings = []\n    for res_list in results:\n        # Format each inner list: [float1,float2,...]\n        inner_str = f\"[{','.join(f'{x:.10g}' for x in res_list)}]\"\n        case_strings.append(inner_str)\n    \n    # Join the case strings and enclose in brackets: [[...],[...]]\n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "S2S预报本质上是概率性的，因此评估它们需要专门的工具。本练习  深入探讨了布里尔分数（Brier score），这是一个概率性检验的基石指标，及其在可靠性、分辨率和不确定性方面的分解。通过实现这种分解，你将对如何诊断概率预报系统的优缺点获得更深刻的理解，而不仅仅是看一个单一的分数。",
            "id": "4096511",
            "problem": "请考虑在数值天气预报和气候模拟中对次季节到季节（S2S）预测进行概率性检验。设一个二元事件表示在给定的预报时效和地点，一个气候变量出现上三分位类别的情况，其预报概率和检验结果通过一个包含 $N$ 个独立的预报-观测对的样本收集。预报概率表示为 $p_i \\in [0,1]$，结果表示为 $o_i \\in \\{0,1\\}$，其中 $i=1,\\dots,N$。此二元事件的Brier评分（BS）定义为预报概率与结果之间的均方误差，其分解为可靠性、解析度和不确定性是基于按预报类别进行条件化和全方差公式。可靠性量化了跨预报类别的校准偏差，解析度量化了预报将样本划分为具有不同事件频率的子集的程度，而不确定性仅取决于气候学事件频率。\n\n从概率、期望、方差和条件化的定义，以及Brier评分作为二元事件均方误差的定义出发，通过将预报划分为固定的概率区间（分箱），推导Brier评分的分箱分解。在这种分箱方法中，对于一组具有边界 $0=e_1 < e_2 < \\dots < e_{K+1}=1$ 的 $K$ 个分箱，将第 $k$ 个分箱定义为满足 $e_k \\le p_i < e_{k+1}$（对于 $k=1,\\dots,K-1$）的索引集合，对于最后一个分箱，则为 $e_K \\le p_i \\le e_{K+1}$。令 $n_k$ 表示分箱 $k$ 中的点数，令 $\\bar{p}_k$ 表示分箱 $k$ 内的平均预报概率，令 $\\bar{o}_k$ 表示分箱 $k$ 内的平均观测频率。令 $\\bar{o}$ 表示整个样本的总体气候学事件频率。使用这些分箱统计数据，计算：\n- Brier评分 $BS$，\n- 可靠性分量，\n- 解析度分量，\n- 以及不确定性分量。\n\n您必须使用下面指定的固定分箱来实现分箱分解。$n_k=0$ 的分箱对可靠性和解析度总和的贡献必须为零。所有量都是无量纲的，必须以小数表示。本问题不涉及角度。\n\n测试套件：\n对于每个测试用例，程序应接收所提供的预报概率数组和检验二元结果数组，并使用固定的分箱边界 $E=[0,0.2,0.4,0.6,0.8,1.0]$（最后一个分箱包含 $p=1.0$）来计算所要求的量。\n\n- 测试用例1（完美的确定性正确预报）：\n  - $N=12$\n  - $p=[0,0,0,0,0,0,1,1,1,0,0,1]$\n  - $o=[0,0,0,0,0,0,1,1,1,0,0,1]$\n\n- 测试用例2（无信息量的气候学预报）：\n  - $N=10$\n  - $p=[0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3]$\n  - $o=[1,0,0,0,1,0,1,0,0,0]$\n\n- 测试用例3（严重校准偏差的双类别预报）：\n  - $N=12$\n  - $p=[0.8,0.8,0.8,0.8,0.8,0.8,0.2,0.2,0.2,0.2,0.2,0.2]$\n  - $o=[0,0,0,0,0,0,1,0,1,0,1,0]$\n\n- 测试用例4（包含极值和中间值的混合概率）：\n  - $N=8$\n  - $p=[0.0,0.0,1.0,1.0,0.5,0.5,0.1,0.9]$\n  - $o=[0,0,1,1,0,1,0,1]$\n\n- 测试用例5（单个预报-观测对；边缘情况）：\n  - $N=1$\n  - $p=[0.7]$\n  - $o=[1]$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来，其中每个测试用例产生一个包含四个小数的列表，顺序为 $[BS,\\text{Reliability},\\text{Resolution},\\text{Uncertainty}]$。每个小数必须四舍五入到六位。总体输出应该是这些按测试用例排列的列表的列表；例如，一个语法上有效的输出将类似于 $[[0.123456,0.010000,0.050000,0.163456],[\\dots],\\dots]$。",
            "solution": "我们从二元事件 Brier 评分的基本定义开始。给定预报 $p_i \\in [0,1]$ 和结果 $o_i \\in \\{0,1\\}$（其中 $i=1,\\dots,N$），Brier 评分是均方误差\n$$\nBS \\equiv \\frac{1}{N} \\sum_{i=1}^{N} (p_i - o_i)^2 = \\mathbb{E}\\left[ (p - o)^2 \\right],\n$$\n其中 $\\mathbb{E}[\\cdot]$ 表示样本均值。\n\n为了将 $BS$ 分解为可靠性、解析度和不确定性，我们调用基于预报类别的条件期望和适用于二元结果的全方差公式。通过将单位区间划分为具有边界 $0=e_1 < e_2 < \\dots < e_{K+1}=1$ 的固定分箱来定义预报类别。如果一个预报值为 $p$，当 $e_k \\le p < e_{k+1}$（对于 $k=1,\\dots,K-1$）时，它被分配到分箱 $k$；对于最后一个分箱，则为 $e_{K} \\le p \\le e_{K+1}$。令随机变量 $C$ 表示一个预报的分箱索引。令 $n_k$ 为分箱 $k$ 中的预报数量，并定义分箱权重 $w_k \\equiv n_k/N$。定义分箱内平均值\n$$\n\\bar{p}_k \\equiv \\frac{1}{n_k} \\sum_{i \\in \\mathcal{I}_k} p_i, \\quad \\bar{o}_k \\equiv \\frac{1}{n_k} \\sum_{i \\in \\mathcal{I}_k} o_i, \\quad \\text{for } n_k>0,\n$$\n其中 $\\mathcal{I}_k$ 是属于分箱 $k$ 的索引。定义总体气候学频率\n$$\n\\bar{o} \\equiv \\frac{1}{N} \\sum_{i=1}^{N} o_i.\n$$\n\n分箱分解通过对 $C$ 进行条件化并在期望内展开平方项来进行。对于给定的分箱 $k$，我们写出\n$$\n\\mathbb{E}\\left[ (p - o)^2 \\mid C=k \\right] = \\mathbb{E}\\left[ \\left( (p - \\bar{p}_k) + (\\bar{p}_k - \\bar{o}_k) + (\\bar{o}_k - o) \\right)^2 \\mid C=k \\right].\n$$\n展开平方项并取条件期望，由于每个分箱内中心化变量的零均值特性，交叉项会消失，剩下可以分组为校准（分箱平均预报与分箱平均结果之差）、分层（分箱平均结果与气候学频率之差）和结果变率（相对于气候学频率的二元不确定性）的分量。用权重 $w_k$ 对所有分箱进行聚合，得到\n$$\nBS = \\sum_{k=1}^{K} w_k (\\bar{p}_k - \\bar{o}_k)^2 - \\sum_{k=1}^{K} w_k (\\bar{o}_k - \\bar{o})^2 + \\bar{o}(1 - \\bar{o}) + \\Delta_{\\text{bin}},\n$$\n其中 $\\Delta_{\\text{bin}}$ 收集了当分箱包含异构预报值时，与 $p$ 围绕 $\\bar{p}_k$ 的分箱内变异相关的项。在类别对应唯一预报概率（即一个类别中所有 $p_i$ 都等于一个共同值）的特殊情况下，$\\Delta_{\\text{bin}}=0$ 精确成立，且分解恒等式\n$$\nBS = \\text{Reliability} - \\text{Resolution} + \\text{Uncertainty}\n$$\n精确成立，其中\n$$\n\\text{Reliability} \\equiv \\sum_{k=1}^{K} w_k (\\bar{p}_k - \\bar{o}_k)^2, \\quad\n\\text{Resolution} \\equiv \\sum_{k=1}^{K} w_k (\\bar{o}_k - \\bar{o})^2, \\quad\n\\text{Uncertainty} \\equiv \\bar{o}(1 - \\bar{o}).\n$$\n当固定分箱对异构预报值进行分组时，此分解仍然是一种标准且科学上合理的近似，等式在 $\\Delta_{\\text{bin}}$ 的范围内成立，对于足够精细的分箱或较弱的分箱内变率，$\\Delta_{\\text{bin}}$ 趋于较小。\n\n算法设计：\n1. 接受一个测试用例的数组 $p_1,\\dots,p_N$ 和 $o_1,\\dots,o_N$。计算\n   $$\n   BS = \\frac{1}{N} \\sum_{i=1}^{N} (p_i - o_i)^2, \\quad \\bar{o} = \\frac{1}{N} \\sum_{i=1}^{N} o_i, \\quad \\text{Uncertainty} = \\bar{o}(1-\\bar{o}).\n   $$\n2. 使用固定的分箱边界 $E=[0,0.2,0.4,0.6,0.8,1.0]$，根据 $e_k \\le p_i < e_{k+1}$（对于 $k=1,\\dots,K-1$）和 $e_K \\le p_i \\le e_{K+1}$（对于最后一个分箱），将每个预报 $p_i$ 分配到一个分箱索引 $k$。\n3. 对于每个 $n_k>0$ 的分箱 $k$，计算 $w_k = n_k/N$、$\\bar{p}_k$ 和 $\\bar{o}_k$ 作为该分箱内索引的简单平均值。如果 $n_k=0$，则跳过该分箱（它对总和的贡献为零）。\n4. 通过以下公式计算可靠性和解析度\n   $\n   \\text{Reliability} = \\sum_{k: n_k>0} w_k (\\bar{p}_k - \\bar{o}_k)^2\n   $\n   和\n   $\n   \\text{Resolution} = \\sum_{k: n_k>0} w_k (\\bar{o}_k - \\bar{o})^2.\n   $\n5. 返回该测试用例的元组 $[BS,\\text{Reliability},\\text{Resolution},\\text{Uncertainty}]$。\n6. 对套件中的每个测试用例重复此过程，并打印一行，其中包含这些元组的列表，每个小数四舍五入到六位小数。\n\n科学真实性和边缘情况处理：\n- 事件是一个以二元变量表示的三分位类别出现，这是S2S检验中的标准构造。\n- 跨越 $[0,1]$ 的固定分箱被广泛用于分箱可靠性图和分解；计数为零的分箱贡献为零。\n- 单一观测的边缘情况（$N=1$）可由定义自然处理；当 $\\bar{o} \\in \\{0,1\\}$ 时，可靠性简化为 $(p - o)^2$，解析度为零，不确定性为 $\\bar{o}(1-\\bar{o})=0$。\n- 确定性的完美预报（$p_i \\in \\{0,1\\}$ 且 $p_i=o_i$）产生 $BS=0$，可靠性 $=0$，解析度 $=\\text{Uncertainty}$，这与分解一致。\n\n最终输出是一个包含五个按测试用例排列的列表 $[BS,\\text{Reliability},\\text{Resolution},\\text{Uncertainty}]$ 的单一列表，每个值四舍五入到六位小数，按规定打印在一行上。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef brier_decomposition(p, o, edges):\n    \"\"\"\n    Compute Brier score and its bin-wise decomposition into reliability,\n    resolution, and uncertainty components using fixed bin edges.\n\n    Parameters:\n        p (list or np.ndarray): Forecast probabilities in [0,1].\n        o (list or np.ndarray): Binary outcomes in {0,1}.\n        edges (list or np.ndarray): Bin edges, ascending, covering [0,1],\n                                    last bin inclusive of right edge.\n\n    Returns:\n        tuple: (BS, REL, RES, UNC) as floats.\n    \"\"\"\n    p = np.asarray(p, dtype=float)\n    o = np.asarray(o, dtype=float)\n    N = p.size\n    if N == 0:\n        raise ValueError(\"Empty input arrays are not allowed.\")\n\n    # Core quantities\n    BS = float(np.mean((p - o) ** 2))\n    o_bar = float(np.mean(o))\n    UNC = o_bar * (1.0 - o_bar)\n\n    # Bin-wise stats\n    edges = np.asarray(edges, dtype=float)\n    K = edges.size - 1\n    REL = 0.0\n    RES = 0.0\n\n    for k in range(K):\n        left = edges[k]\n        right = edges[k + 1]\n        if k < K - 1:\n            idx = np.where((p >= left) & (p < right))[0]\n        else:\n            # Last bin includes right edge\n            idx = np.where((p >= left) & (p <= right))[0]\n        n_k = idx.size\n        if n_k == 0:\n            continue\n        w_k = n_k / N\n        p_k = float(np.mean(p[idx]))\n        o_k = float(np.mean(o[idx]))\n        REL += w_k * (p_k - o_k) ** 2\n        RES += w_k * (o_k - o_bar) ** 2\n\n    return BS, REL, RES, UNC\n\ndef solve():\n    # Define fixed bin edges as specified: last bin includes 1.0\n    edges = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: perfect deterministic, correct forecasts\n        ( [0,0,0,0,0,0,1,1,1,0,0,1],\n          [0,0,0,0,0,0,1,1,1,0,0,1] ),\n        # Test case 2: uninformative climatology forecasts\n        ( [0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3],\n          [1,0,0,0,1,0,1,0,0,0] ),\n        # Test case 3: strongly miscalibrated, two-category forecasts\n        ( [0.8,0.8,0.8,0.8,0.8,0.8,0.2,0.2,0.2,0.2,0.2,0.2],\n          [0,0,0,0,0,0,1,0,1,0,1,0] ),\n        # Test case 4: mixed probabilities with extremes and mid-values\n        ( [0.0,0.0,1.0,1.0,0.5,0.5,0.1,0.9],\n          [0,0,1,1,0,1,0,1] ),\n        # Test case 5: single forecast-observation pair; edge case\n        ( [0.7],\n          [1] ),\n    ]\n\n    results = []\n    for p, o in test_cases:\n        BS, REL, RES, UNC = brier_decomposition(p, o, edges)\n        results.append([BS, REL, RES, UNC])\n\n    # Format each float to six decimal places and print the nested list\n    formatted_cases = []\n    for case in results:\n        formatted_values = [f\"{v:.6f}\" for v in case]\n        formatted_cases.append(\"[\" + \",\".join(formatted_values) + \"]\")\n    print(\"[\" + \",\".join(formatted_cases) + \"]\")\n\nsolve()\n```"
        }
    ]
}