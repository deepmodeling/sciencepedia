{
    "hands_on_practices": [
        {
            "introduction": "S2S（次季节到季节）尺度上的可预报性主要来源于气候系统中缓慢变化的组成部分，其中马登-朱利安振荡（Madden-Julian Oscillation, MJO）是一个典型的例子。为了监测MJO的实时活动，Wheeler-Hendon RMM指数已成为标准工具。本练习将指导您完成该指数的核心计算步骤，通过从第一性原理推导主成分、振幅和相位，从而加深您对主成分分析在气候科学中具体应用的理解。",
            "id": "4096582",
            "problem": "一个预报中心遵循 Wheeler–Hendon 方法，构建实时多元马登-朱利安振荡（RMM）指数，用于在次季节到季节时间尺度上监测马登-朱利安振荡（MJO）。输入数据为向外长波辐射（OLR）、$850$ hPa 纬向风（记为 $u_{850}$）和 $200$ hPa 纬向风（记为 $u_{200}$）的带通滤波后异常的每日场。异常的计算方法是，首先移除长期的每日气候态和前几个年谐波，然后应用一个带通滤波器，保留 $20$ 至 $96$ 天之间的方差。组合状态是通过对这三个场沿赤道带进行面积加权拼接而构建的，并且每个场都通过其气候态空间标准差进行单独标准化，从而使这三个分量无量纲且可比较。\n\n设 $x(t)$ 表示在时间 $t$ 三个滤波后异常场的拼接、面积加权的向量，设 $\\mu$ 表示相应的气候态平均值（对于异常场为零）。设 $W$ 为面积加权算子，$B$ 为带通滤波算子，$S$ 为一个块对角缩放算子，其对角块上包含 OLR、$u_{850}$ 和 $u_{200}$ 的空间标准差，因此 $S^{-1}$ 可生成无量纲的标准化异常。假设前两个经验正交函数（EOF）模态 $e_{1}$ 和 $e_{2}$（列向量）已经通过一个长期历史记录，使用 $S^{-1} B (x-\\mu)$ 相对于由 $W$ 导出的内积的协方差预先计算得出。\n\n任务：\n1) 从这些定义和线性算子出发，推导两个主成分 $PC_{1}(t)$ 和 $PC_{2}(t)$ 的表达式，它们是标准化的、滤波后的异常向量在 EOF 模态上的投影。然后，从表示二维振荡信号的第一性原理出发，推导瞬时振幅 $A(t)$ 和瞬时相位角 $\\phi(t)$ 关于 $PC_{1}(t)$ 和 $PC_{2}(t)$ 的解析公式，其中 $\\phi(t)$ 使用双参数反正切函数定义，并以弧度为单位度量。\n\n2) 为了进行周评估，定义周平均主成分\n$$\n\\overline{PC}_{i} = \\frac{1}{7} \\sum_{d=1}^{7} PC_{i}(t_{d}), \\quad i \\in \\{1,2\\},\n$$\n对于给定的一周，其日期为 $t_{1},\\dots,t_{7}$。利用线性和你在第1部分的推导，推导周平均振幅 $A_{\\mathrm{wk}}$ 和周平均相位 $\\phi_{\\mathrm{wk}}$ 关于 $\\overline{PC}_{1}$ 和 $\\overline{PC}_{2}$ 的公式。\n\n3) 对于某个特定周，通过将滤波后的、标准化的场投影到预先计算的EOF上，已计算出以下每日主成分：\n- 第 $1$ 天：$PC_{1}(t_{1}) = 1.2$， $PC_{2}(t_{1}) = 0.8$。\n- 第 $2$ 天：$PC_{1}(t_{2}) = 1.4$， $PC_{2}(t_{2}) = 0.7$。\n- 第 $3$ 天：$PC_{1}(t_{3}) = 1.3$， $PC_{2}(t_{3}) = 0.9$。\n- 第 $4$ 天：$PC_{1}(t_{4}) = 1.1$， $PC_{2}(t_{4}) = 0.6$。\n- 第 $5$ 天：$PC_{1}(t_{5}) = 1.0$， $PC_{2}(t_{5}) = 0.5$。\n- 第 $6$ 天：$PC_{1}(t_{6}) = 0.9$， $PC_{2}(t_{6}) = 0.4$。\n- 第 $7$ 天：$PC_{1}(t_{7}) = 1.2$， $PC_{2}(t_{7}) = 0.8$。\n\n计算这些每日主成分所蕴含的周平均振幅 $A_{\\mathrm{wk}}$。将最终振幅表示为一个无量纲的数，并将你的答案四舍五入到四位有效数字。",
            "solution": "该问题是有效的，因为它在科学上基于气候指数计算的标准方法（RMM 指数），是适定的，有通往唯一解的清晰路径，并且使用标准的科学术语进行了客观的表述。\n\n该问题分三部分解决：第一部分，推导主成分、振幅和相位的基本表达式；第二部分，将这些概念推广到周平均值；第三部分，使用所提供的数据进行数值计算。\n\n**第1部分：瞬时量的推导**\n\n问题陈述，经验正交函数（EOF），记为 $e_{1}$ 和 $e_{2}$，是从标准化的、滤波后的异常场的协方差中导出的。设原始状态向量为 $x(t)$。异常是相对于气候态平均值 $\\mu$ 计算的，对于异常场，$\\mu$ 为零，因此我们考虑 $x(t)$。该向量随后由带通滤波算子 $B$ 和标准化算子 $S^{-1}$ 处理。得到的我们称之为 $z(t)$ 的状态向量由下式给出：\n$$\nz(t) = S^{-1} B x(t)\n$$\n问题指明 EOF 是关于由面积加权算子 $W$ 导出的内积计算的。两个状态向量 $u$ 和 $v$ 之间的这个内积是 $\\langle u, v \\rangle_{W} = u^T W v$。根据构造，EOF 模态 $e_{i}$ 关于这个加权内积是标准正交的，即 $\\langle e_{i}, e_{j} \\rangle_{W} = \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克 δ。\n\n主成分 $PC_{i}(t)$ 是状态向量 $z(t)$ 在相应 EOF 模态 $e_{i}$ 上的投影。该投影使用定义的加权内积计算：\n$$\nPC_{i}(t) = \\langle z(t), e_{i} \\rangle_{W}\n$$\n代入 $z(t)$ 的表达式，我们得到用初始场 $x(t)$ 和算子表示的主成分公式：\n$$\nPC_{1}(t) = (S^{-1} B x(t))^T W e_{1}\n$$\n$$\nPC_{2}(t) = (S^{-1} B x(t))^T W e_{2}\n$$\n对 $(PC_{1}(t), PC_{2}(t))$ 表示系统在时间 $t$ 位于由两个主导 EOF 张成的二维相空间中的状态。这种表示方法对于像马登-朱利安振荡这样的振荡现象特别有用，其状态可以用一个振幅和一个相位来描述。\n\n瞬时振幅 $A(t)$ 是该相空间中状态向量的模。它被计算为向量 $(PC_{1}(t), PC_{2}(t))$ 的欧几里得范数：\n$$\nA(t) = \\sqrt{PC_{1}(t)^2 + PC_{2}(t)^2}\n$$\n瞬时相位角 $\\phi(t)$ 是状态向量相对于 $PC_1$ 轴的角度。为了唯一地确定跨越所有四个象限的角度，使用了双参数反正切函数，通常记为 $\\mathrm{atan2}(y, x)$。因此，相位角为：\n$$\n\\phi(t) = \\arctan(PC_{2}(t), PC_{1}(t))\n$$\n\n**第2部分：周平均量的推导**\n\n问题将周平均主成分定义为 7 天周期内每日值的算术平均：\n$$\n\\overline{PC}_{i} = \\frac{1}{7} \\sum_{d=1}^{7} PC_{i}(t_{d}), \\quad i \\in \\{1,2\\}\n$$\n问题要求推导周平均振幅 $A_{\\mathrm{wk}}$ 和相位 $\\phi_{\\mathrm{wk}}$ 以 $\\overline{PC}_{1}$ 和 $\\overline{PC}_{2}$ 表示。这意味着我们要找到周平均状态向量 $(\\overline{PC}_{1}, \\overline{PC}_{2})$ 的振幅和相位，而不是每日振幅和相位的平均值。\n\n平均主成分的计算是线性运算。可以看出，$\\overline{PC}_{i}$ 是周平均滤波场在 $e_i$ 上的投影。然而，振幅 $A(t)$ 的计算涉及平方根，这是一个非线性函数。因此，平均状态的振幅不等于每日振幅的平均值：\n$$\nA_{\\mathrm{wk}} = \\sqrt{\\overline{PC}_{1}^2 + \\overline{PC}_{2}^2} \\neq \\frac{1}{7} \\sum_{d=1}^{7} A(t_d)\n$$\n遵循问题的指示，我们将第1部分的相同逻辑应用于周平均主成分，来定义周平均振幅 $A_{\\mathrm{wk}}$ 和相位 $\\phi_{\\mathrm{wk}}$：\n$$\nA_{\\mathrm{wk}} = \\sqrt{\\overline{PC}_{1}^2 + \\overline{PC}_{2}^2}\n$$\n$$\n\\phi_{\\mathrm{wk}} = \\arctan(\\overline{PC}_{2}, \\overline{PC}_{1})\n$$\n\n**第3部分：数值计算**\n\n给定一周 7 天的每日主成分：\n- 第 $1$ 天：$PC_{1}(t_{1}) = 1.2$， $PC_{2}(t_{1}) = 0.8$。\n- 第 $2$ 天：$PC_{1}(t_{2}) = 1.4$， $PC_{2}(t_{2}) = 0.7$。\n- 第 $3$ 天：$PC_{1}(t_{3}) = 1.3$， $PC_{2}(t_{3}) = 0.9$。\n- 第 $4$ 天：$PC_{1}(t_{4}) = 1.1$， $PC_{2}(t_{4}) = 0.6$。\n- 第 $5$ 天：$PC_{1}(t_{5}) = 1.0$， $PC_{2}(t_{5}) = 0.5$。\n- 第 $6$ 天：$PC_{1}(t_{6}) = 0.9$， $PC_{2}(t_{6}) = 0.4$。\n- 第 $7$ 天：$PC_{1}(t_{7}) = 1.2$， $PC_{2}(t_{7}) = 0.8$。\n\n首先，我们计算周平均主成分 $\\overline{PC}_{1}$ 和 $\\overline{PC}_{2}$。\n\n对于 $\\overline{PC}_{1}$：\n$$\n\\overline{PC}_{1} = \\frac{1}{7} (1.2 + 1.4 + 1.3 + 1.1 + 1.0 + 0.9 + 1.2) = \\frac{8.1}{7}\n$$\n对于 $\\overline{PC}_{2}$：\n$$\n\\overline{PC}_{2} = \\frac{1}{7} (0.8 + 0.7 + 0.9 + 0.6 + 0.5 + 0.4 + 0.8) = \\frac{4.7}{7}\n$$\n现在，我们使用这些平均值，并利用在第2部分推导出的公式来计算周平均振幅 $A_{\\mathrm{wk}}$：\n$$\nA_{\\mathrm{wk}} = \\sqrt{\\overline{PC}_{1}^2 + \\overline{PC}_{2}^2} = \\sqrt{\\left(\\frac{8.1}{7}\\right)^2 + \\left(\\frac{4.7}{7}\\right)^2}\n$$\n$$\nA_{\\mathrm{wk}} = \\sqrt{\\frac{8.1^2}{7^2} + \\frac{4.7^2}{7^2}} = \\frac{1}{7} \\sqrt{8.1^2 + 4.7^2}\n$$\n我们计算平方值：\n$$\n8.1^2 = 65.61\n$$\n$$\n4.7^2 = 22.09\n$$\n将这些值代回 $A_{\\mathrm{wk}}$ 的表达式中：\n$$\nA_{\\mathrm{wk}} = \\frac{1}{7} \\sqrt{65.61 + 22.09} = \\frac{1}{7} \\sqrt{87.7}\n$$\n现在，我们计算数值：\n$$\nA_{\\mathrm{wk}} \\approx \\frac{9.364828}{7} \\approx 1.33783259\n$$\n问题要求将答案四舍五入到四位有效数字。\n$$\nA_{\\mathrm{wk}} \\approx 1.338\n$$",
            "answer": "$$\n\\boxed{1.338}\n$$"
        },
        {
            "introduction": "原始的数值模式输出往往包含系统性偏差，这限制了其在实际应用中的价值。因此，对预报产品进行后处理是提高其准确性和可靠性的关键步骤。本练习介绍了一种基础而有效的偏差订正方法——均值-方差校准，并指导您通过一个具体的编程任务，来量化这种校准对预报技巧（如距平相关系数和均方根误差）的实际影响。",
            "id": "4096533",
            "problem": "一个每周一次的次季节到季节预报系统，会为过去几年（后报期）中一个固定的日历周生成一个预报温度的时间序列，并为当前的验证期生成一个单独的时间序列。设后报预报值为一个以摄氏度为单位的实数列表，后报观测值为相同日历周和年份的以摄氏度为单位的实数列表。验证期包含一个实数值的周预报列表和一个实数值的周观测列表，它们对应于后续年份中相同的日历周。您需要设计并实现一个程序，该程序执行从第一性原理推导出的均值-方差校准，然后使用两个指标评估其效果：距平相关和均方根误差。\n\n从以下基本原理开始：\n- 控制线性变换和矩的统计定律：如果一个随机变量 $X$ 的均值为 $\\mu_X$，标准差为 $\\sigma_X$（总体定义），并且 $Y = aX + b$，那么 $Y$ 的均值为 $a \\mu_X + b$，$Y$ 的标准差为 $\\lvert a \\rvert \\sigma_X$。\n- 对于一个有限列表 $\\{x_i\\}_{i=1}^N$，其总体均值和总体标准差分别定义为 $\\mu = \\frac{1}{N} \\sum_{i=1}^N x_i$ 和 $\\sigma = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N (x_i - \\mu)^2}$。\n- 两个等长的有限列表 $\\{p_i\\}_{i=1}^N$ 和 $\\{q_i\\}_{i=1}^N$ 之间的均方根误差 (RMSE) 定义为 $\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N (p_i - q_i)^2}$。\n- 一个值相对于气候基线的距平是其与参考均值的差。对于周距平验证，使用该日历周的后报观测均值作为气候基线。\n- 两个有限列表 $\\{x_i\\}_{i=1}^N$ 和 $\\{y_i\\}_{i=1}^N$ 之间的 Pearson 相关系数定义为 $\\rho = \\frac{\\sum_{i=1}^N (x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum_{i=1}^N (x_i - \\bar{x})^2} \\sqrt{\\sum_{i=1}^N (y_i - \\bar{y})^2}}$，其中 $\\bar{x}$ 和 $\\bar{y}$ 是被相关计算的 $N$ 个值的样本均值。在本问题中，将此公式应用于相对于后报观测均值计算的距平。如果有效数据对少于 $2$ 对，或者任一距平序列的方差为零，则将距平相关定义为 $0$。\n\n您的程序必须：\n- 使用总体定义，从后报预报列表中估算后报预报均值 $\\mu_f$ 和后报预报标准差 $\\sigma_f$。\n- 使用总体定义，从后报观测列表中估算后报观测均值 $\\mu_o$ 和后报观测标准差 $\\sigma_o$。\n- 推导一个对验证预报的线性变换，使其均值和标准差与后报观测的均值和标准差相匹配（即，生成一个均值为 $\\mu_o$、标准差为 $\\sigma_o$ 的校正后预报序列）。实现由此产生的校正，并用它来生成一个校正后的验证预报序列。如果 $\\sigma_f = 0$（或在数值容差内有效为零），则将所有验证时间的校正预报定义为等于 $\\mu_o$。\n- 计算校正前（使用原始验证预报）和校正后（使用校正后验证预报）的距平相关和 RMSE。对于距平，从预报和观测中都减去 $\\mu_o$。RMSE 以摄氏度表示。如果任何验证预报-观测数据对包含非有限值，则在所有指标计算中省略该数据对。如果有效数据对为零，则将两个指标都定义为 $0$。\n\n使用以下测试套件，其中所有温度都以摄氏度为单位：\n- 案例 $1$（常规理想路径）：\n    - 后报预报：$[10,12,14,16]$\n    - 后报观测：$[11,12,15,17]$\n    - 验证预报：$[13,15,17]$\n    - 验证观测：$[12,16,18]$\n- 案例 $2$（边界条件 $\\sigma_f = 0$）：\n    - 后报预报：$[14,14,14,14]$\n    - 后报观测：$[13,14,15,16]$\n    - 验证预报：$[14,14,14]$\n    - 验证观测：$[13,16,15]$\n- 案例 $3$（验证中边界条件 $N = 1$）：\n    - 后报预报：$[8,9,10,11]$\n    - 后报观测：$[7,9,11,13]$\n    - 验证预报：$[10]$\n    - 验证观测：$[12]$\n- 案例 $4$（负协方差场景）：\n    - 后报预报：$[20,18,16,14,12]$\n    - 后报观测：$[15,16,17,18,19]$\n    - 验证预报：$[13,17,15,19]$\n    - 验证观测：$[19,15,17,13]$\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、针对四个案例的逗号分隔结果列表。每个案例的结果必须是按 $[\\text{AC}_{\\text{raw}}, \\text{RMSE}_{\\text{raw}}, \\text{AC}_{\\text{corr}}, \\text{RMSE}_{\\text{corr}}]$ 顺序排列的四个浮点数列表，其中 $\\text{AC}$ 是距平相关（无单位），$\\text{RMSE}$ 以摄氏度为单位。例如，格式为 $[[x_{1,1},x_{1,2},x_{1,3},x_{1,4}],[x_{2,1},x_{2,2},x_{2,3},x_{2,4}],[x_{3,1},x_{3,2},x_{3,3},x_{3,4}],[x_{4,1},x_{4,2},x_{4,3},x_{4,4}]]$，不含多余的空格或文本。",
            "solution": "用户希望我扮演一名 STEM 教授。我的任务是首先验证问题陈述，如果问题陈述有效，则提供一个详细、合理的解决方案，并附上完整的 Python 程序。\n\n### 问题验证\n\n首先，我将把问题陈述分解为其基本组成部分，以进行严格的验证。\n\n#### 步骤 1：提取已知条件\n\n问题提供了以下数据、定义和程序：\n*   **输入**：每个测试案例包含四个以摄氏度为单位的实数值温度列表：\n    1.  `hindcast_forecasts`：过去一段时期内某个固定日历周的预报。\n    2.  `hindcast_observations`：同一时期的相应观测值。\n    3.  `validation_forecasts`：后续验证期内同一日历周的预报。\n    4.  `validation_observations`：验证期的相应观测值。\n*   **统计原理**：\n    *   **随机变量的线性变换**：给定一个均值为 $\\mu_X$、标准差为 $\\sigma_X$ 的随机变量 $X$，以及一个新变量 $Y = aX + b$，则 $Y$ 的均值为 $\\mu_Y = a \\mu_X + b$，标准差为 $\\sigma_Y = \\lvert a \\rvert \\sigma_X$。\n    *   **总体均值**：对于列表 $\\{x_i\\}_{i=1}^N$，其均值为 $\\mu = \\frac{1}{N} \\sum_{i=1}^N x_i$。\n    *   **总体标准差**：对于列表 $\\{x_i\\}_{i=1}^N$，其标准差为 $\\sigma = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N (x_i - \\mu)^2}$。\n    *   **均方根误差 (RMSE)**：对于两个列表 $\\{p_i\\}_{i=1}^N$ 和 $\\{q_i\\}_{i=1}^N$，$\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^N (p_i - q_i)^2}$。\n    *   **距平相关 (AC)**：定义为距平序列之间的 Pearson 相关系数。\n        *   距平是相对于后报观测均值 $\\mu_o$ 计算的。\n        *   Pearson 相关公式为 $\\rho = \\frac{\\sum_{i=1}^N (x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum_{i=1}^N (x_i - \\bar{x})^2} \\sqrt{\\sum_{i=1}^N (y_i - \\bar{y})^2}}$。\n*   **程序要求**：\n    1.  从后报预报中估算均值 $\\mu_f$ 和标准差 $\\sigma_f$。\n    2.  从后报观测中估算均值 $\\mu_o$ 和标准差 $\\sigma_o$。\n    3.  推导并应用一个线性变换到验证预报上，以生成一个其均值和标准差分别与 $\\mu_o$ 和 $\\sigma_o$ 相匹配的校正后序列。\n    4.  针对验证观测值，计算原始和校正后验证预报的 AC 和 RMSE。\n*   **边界情况处理**：\n    *   **非有限值**：如果验证集中的预报-观测对包含非有限值，必须在所有指标计算中省略它。\n    *   **零有效对**：如果筛选后没有剩余的有效对，则 AC 和 RMSE 都定义为 $0$。\n    *   **零预报方差 ($\\sigma_f = 0$)**：校正后的预报是一个常数序列，其中每个值都是 $\\mu_o$。\n    *   **AC 计算**：如果有效对少于 $2$ 对，或者任一距平序列的方差为零，则 AC 定义为 $0$。\n*   **测试套件**：提供了四个具体的测试案例，包含所有必需的输入列表。\n*   **输出格式**：单行文本：`[[ac_raw1,rmse_raw1,ac_corr1,rmse_corr1],[...],...]`。\n\n#### 步骤 2：使用提取的已知条件进行验证\n我现在将根据指定的标准评估问题的有效性。\n\n*   **科学依据**：该问题是气象学和气候科学中使用的预报检验技术的一个真实（尽管简化了）的应用。均值-方差校准方法（模式输出统计或 MOS 的一种形式）是校正系统性模式偏差的标准实践。RMSE 和距平相关这两个指标是评估预报质量的基本工具。所有的统计定义都是正确和标准的。该问题牢固地建立在公认的科学和统计原理之上。\n*   **适定性**：该问题被精心指定。它为所有必需的计算（总体均值/标准差、RMSE、AC）提供了明确的定义。它清晰地概述了推导校准参数和应用校正的程序。关键是，它为所有相关的边界情况（非有限数据、零方差、数据点不足）定义了行为，这确保了对于任何有效输入都可以确定一个唯一且稳定的解。\n*   **客观性**：该问题以精确、定量和无偏的语言陈述。它要求实现一个基于数学公式的确定性算法，没有主观解释的余地。\n*   **缺陷检查表**：\n    1.  **科学/事实不健全**：无。所有原理都健全。\n    2.  **不可形式化/不相关**：该问题可以直接形式化为一个计算算法，并且与指定的数值天气预报领域高度相关。\n    3.  **不完整/矛盾的设置**：设置是完整且自洽的。所有必要的数据和定义都已提供。\n    4.  **不现实/不可行**：数据值和场景是周温度预报的现实表示。\n    5.  **不适定/结构不良**：由于对边界情况的明确处理，该问题结构良好且非不适定。\n    6.  **伪深刻/琐碎**：该问题需要一个涉及统计计算和特定规则实现的多步逻辑过程。这是一项实质性任务，既不琐碎也不伪深刻。\n    7.  **超出科学可验证性范围**：结果可通过独立重新计算完全验证。\n\n#### 步骤 3：结论与行动\n该问题是**有效的**。它是一个定义明确、科学合理且客观的计算任务。我将着手开发解决方案。\n\n### 解决方案设计\n\n问题的核心是实现一个统计校准方案并评估其性能。该过程可以分解为一系列清晰、基于原理的步骤。\n\n**1. 推导校准变换**\n设原始预报值为 $f_{raw}$。我们寻求一个校正后的预报 $f_{corr} = a \\cdot f_{raw} + b$。目标是校准预报分布，使其与后报期的观测气候分布相匹配。我们假设预报系统的统计特性是平稳的，这意味着原始验证预报具有一个潜在的均值 $\\mu_f$ 和标准差 $\\sigma_f$，我们从后报预报数据中估算这些值。目标分布是后报观测的分布，其均值为 $\\mu_o$，标准差为 $\\sigma_o$。\n\n使用给定的随机变量线性变换定律：\n*   校正后预报的均值必须为 $\\mu_o$：$\\mathbb{E}[f_{corr}] = a \\cdot \\mathbb{E}[f_{raw}] + b \\implies \\mu_o = a \\mu_f + b$。\n*   校正后预报的标准差必须为 $\\sigma_o$：$\\mathrm{StdDev}[f_{corr}] = |a| \\cdot \\mathrm{StdDev}[f_{raw}] \\implies \\sigma_o = |a| \\sigma_f$。\n\n从标准差方程出发，假设一个正的缩放因子 $a$ 以保留距平的符号，我们求解 $a$：\n$$ a = \\frac{\\sigma_o}{\\sigma_f} $$\n这仅在 $\\sigma_f > 0$ 时有效。根据问题陈述，$\\sigma_f = 0$ 的情况需要单独处理。\n\n将 $a$ 代入均值方程，我们求解偏移量 $b$：\n$$ b = \\mu_o - a \\mu_f = \\mu_o - \\frac{\\sigma_o}{\\sigma_f} \\mu_f $$\n\n结合这些，完整的线性变换是：\n$$ f_{corr} = \\left(\\frac{\\sigma_o}{\\sigma_f}\\right) f_{raw} + \\left(\\mu_o - \\frac{\\sigma_o}{\\sigma_f} \\mu_f\\right) $$\n这可以重新整理成一个更直观的形式，显示标准化和重新缩放的过程：\n$$ f_{corr} = \\mu_o + \\frac{\\sigma_o}{\\sigma_f} (f_{raw} - \\mu_f) $$\n这个方程表明，我们取原始预报与其自身气候均值的偏差 ($f_{raw} - \\mu_f$)，将此偏差按观测与预报标准差的比率进行缩放，然后将其加到观测气候均值 $\\mu_o$ 上。\n\n**2. 算法实现步骤**\n对于每个测试案例：\n1.  **数据准备**：为进行高效计算，将输入列表转换为 NumPy 数组。筛选验证数据（`validation_forecasts`、`validation_observations`），只保留两个值都为有限值的配对。如果没有有效的配对剩下，所有四个输出指标均为 $0.0$。\n2.  **后报统计**：计算后报预报 ($\\mu_f, \\sigma_f$) 和后报观测 ($\\mu_o, \\sigma_o$) 的总体均值和标准差。\n3.  **原始指标计算**：\n    *   **RMSE_raw**：计算（筛选后的）原始验证预报和观测之间的均方根误差。\n    *   **AC_raw**：通过减去气候均值 $\\mu_o$ 来计算原始预报和观测的距平。然后，计算这两个距平序列之间的 Pearson 相关系数，同时遵守边界情况（长度  2 或零方差）。\n4.  **预报校准**：\n    *   检查 $\\sigma_f$ 是否有效为零（使用一个小的容差）。如果是，则校正后的预报序列是一个值为 $\\mu_o$ 的常数数组。\n    *   否则，将推导出的线性变换 $f_{corr} = \\mu_o + (\\sigma_o/\\sigma_f) \\cdot (f_{raw} - \\mu_f)$ 应用于原始验证预报序列的每个元素。\n5.  **校正后指标计算**：\n    *   **RMSE_corr**：计算新的校正后验证预报与观测之间的 RMSE。\n    *   **AC_corr**：通过减去 $\\mu_o$ 来计算校正后预报的距平。计算与观测距平的 Pearson 相关。同样的边界情况适用。请注意，由于校准变换是线性的且具有正的缩放因子 ($a = \\sigma_o/\\sigma_f  0$)，除非舍入或边界情况干扰，否则距平相关在数学上预期与原始 AC 相同。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n\n    def process_case(h_forecasts, h_observations, v_forecasts, v_observations):\n        \"\"\"\n        Processes a single test case for forecast calibration and verification.\n        \n        Args:\n            h_forecasts (list): Hindcast forecast values.\n            h_observations (list): Hindcast observation values.\n            v_forecasts (list): Validation forecast values.\n            v_observations (list): Validation observation values.\n\n        Returns:\n            list: A list of four floats [AC_raw, RMSE_raw, AC_corr, RMSE_corr].\n        \"\"\"\n        # Convert all inputs to numpy arrays for vectorized operations\n        h_forecasts_np = np.array(h_forecasts, dtype=float)\n        h_observations_np = np.array(h_observations, dtype=float)\n        v_forecasts_np = np.array(v_forecasts, dtype=float)\n        v_observations_np = np.array(v_observations, dtype=float)\n\n        # Filter validation data for finite pairs\n        valid_mask = np.isfinite(v_forecasts_np)  np.isfinite(v_observations_np)\n        valid_v_forecasts = v_forecasts_np[valid_mask]\n        valid_v_observations = v_observations_np[valid_mask]\n\n        # Handle edge case: zero valid pairs\n        if valid_v_forecasts.size == 0:\n            return [0.0, 0.0, 0.0, 0.0]\n\n        # --- Step 1: Calculate Hindcast Statistics ---\n        # Population mean and standard deviation for hindcast period\n        mu_f = np.mean(h_forecasts_np)\n        sigma_f = np.std(h_forecasts_np) # np.std computes population std dev by default\n        mu_o = np.mean(h_observations_np)\n        sigma_o = np.std(h_observations_np)\n\n        # The climatological baseline for anomalies is the hindcast observed mean\n        climatology = mu_o\n\n        # --- Helper function to compute metrics ---\n        def calculate_metrics(forecasts, observations):\n            \"\"\"Computes Anomaly Correlation and RMSE.\"\"\"\n            # RMSE\n            rmse = np.sqrt(np.mean((forecasts - observations)**2))\n            \n            # Anomaly Correlation (AC)\n            # Conditions for AC to be 0\n            if forecasts.size  2:\n                ac = 0.0\n            else:\n                anom_f = forecasts - climatology\n                anom_o = observations - climatology\n                \n                # Check for zero variance in anomaly series\n                if np.isclose(np.var(anom_f), 0) or np.isclose(np.var(anom_o), 0):\n                    ac = 0.0\n                else:\n                    # np.corrcoef returns a 2x2 matrix\n                    ac = np.corrcoef(anom_f, anom_o)[0, 1]\n            return ac, rmse\n\n        # --- Step 2: Calculate Raw Metrics ---\n        ac_raw, rmse_raw = calculate_metrics(valid_v_forecasts, valid_v_observations)\n\n        # --- Step 3: Apply Correction to Validation Forecasts ---\n        # Check for the special case of zero forecast standard deviation\n        if np.isclose(sigma_f, 0):\n            # Corrected forecast is a constant series of the observed mean\n            corrected_v_forecasts = np.full_like(valid_v_forecasts, mu_o)\n        else:\n            # Apply the mean-variance calibration formula\n            # f_corr = mu_o + (sigma_o / sigma_f) * (f_raw - mu_f)\n            corrected_v_forecasts = mu_o + (sigma_o / sigma_f) * (valid_v_forecasts - mu_f)\n\n        # --- Step 4: Calculate Corrected Metrics ---\n        ac_corr, rmse_corr = calculate_metrics(corrected_v_forecasts, valid_v_observations)\n        \n        return [ac_raw, rmse_raw, ac_corr, rmse_corr]\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            \"h_forecasts\": [10, 12, 14, 16],\n            \"h_observations\": [11, 12, 15, 17],\n            \"v_forecasts\": [13, 15, 17],\n            \"v_observations\": [12, 16, 18],\n        },\n        {\n            \"h_forecasts\": [14, 14, 14, 14],\n            \"h_observations\": [13, 14, 15, 16],\n            \"v_forecasts\": [14, 14, 14],\n            \"v_observations\": [13, 16, 15],\n        },\n        {\n            \"h_forecasts\": [8, 9, 10, 11],\n            \"h_observations\": [7, 9, 11, 13],\n            \"v_forecasts\": [10],\n            \"v_observations\": [12],\n        },\n        {\n            \"h_forecasts\": [20, 18, 16, 14, 12],\n            \"h_observations\": [15, 16, 17, 18, 19],\n            \"v_forecasts\": [13, 17, 15, 19],\n            \"v_observations\": [19, 15, 17, 13],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(**case)\n        results.append(result)\n        \n    # Format the final output string according to the spec (no spaces)\n    case_strings = []\n    for res_list in results:\n        # Format each inner list: [float1,float2,...]\n        inner_str = f\"[{','.join(f'{x:.10g}' for x in res_list)}]\"\n        case_strings.append(inner_str)\n    \n    # Join the case strings and enclose in brackets: [[...],[...]]\n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "S2S预报本质上是概率性的，因此评估其质量不能仅仅依赖于确定性指标。我们需要专门的工具来衡量概率预报本身的优劣。布莱尔分数（Brier Score）及其分解是评估概率预报性能的强大诊断工具，它能够将预报技巧分解为可靠性、分辨率和不确定性三个部分。本练习将让您亲手计算这些指标，从而超越单一的准确度数字，更深入地洞察预报系统的性能。",
            "id": "4096511",
            "problem": "考虑数值天气预报和气候模型中的次季节到季节（S2S）预测的概率性检验。设一个二元事件表示在给定的预报时效和地点，一个气候变量出现上三分位的情形，其预报概率和检验结果是从一个包含 $N$ 个独立预报-观测对的样本中收集的。预报概率记为 $p_i \\in [0,1]$，观测结果记为 $o_i \\in \\{0,1\\}$，其中 $i=1,\\dots,N$。此二元事件的Brier评分（BS）定义为预报概率与观测结果之间的均方误差，其分解为可靠性（Reliability）、分辨率（Resolution）和不确定性（Uncertainty）是基于按预报类别进行条件化以及全方差公式。可靠性量化了预报类别间的校准误差，分辨率量化了预报将样本划分为具有不同事件频率的子集的程度，而不确定性仅取决于气候学上的事件频率。\n\n从概率、期望、方差和条件化的定义，以及Brier评分作为二元事件均方误差的定义出发，通过将预报划分到固定的概率分箱中，推导Brier评分的分箱分解。在这种分箱方法中，对于一组边界为 $0=e_1  e_2  \\dots  e_{K+1}=1$ 的 $K$ 个分箱，将第 $k$ 个分箱定义为满足 $e_k \\le p_i  e_{k+1}$ 的索引集合（对于 $k=1,\\dots,K-1$），以及满足 $e_K \\le p_i \\le e_{K+1}$ 的最后一个分箱。令 $n_k$ 表示第 $k$ 个分箱中的数据点数量，$\\bar{p}_k$ 表示第 $k$ 个分箱内的平均预报概率，$\\bar{o}_k$ 表示第 $k$ 个分箱内的平均观测频率。令 $\\bar{o}$ 表示整个样本的总体气候学事件频率。使用这些分箱统计量，计算：\n- Brier评分 $BS$，\n- 可靠性分量，\n- 分辨率分量，\n- 以及不确定性分量。\n\n您必须使用下面指定的固定分箱来实现分箱分解。$n_k=0$ 的分箱对可靠性和分辨率的总和贡献为零。所有量均为无量纲，且必须以小数表示。本问题不涉及角度。\n\n测试套件：\n对于每个测试用例，程序应接收所提供的预报概率数组和二元检验结果数组，并使用固定的分箱边界 $E=[0,0.2,0.4,0.6,0.8,1.0]$（最后一个分箱包含 $p=1.0$）来计算所要求的量。\n\n- 测试用例1（完美的确定性正确预报）：\n  - $N=12$\n  - $p=[0,0,0,0,0,0,1,1,1,0,0,1]$\n  - $o=[0,0,0,0,0,0,1,1,1,0,0,1]$\n\n- 测试用例2（无信息量的气候学预报）：\n  - $N=10$\n  - $p=[0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3]$\n  - $o=[1,0,0,0,1,0,1,0,0,0]$\n\n- 测试用例3（严重未校准的两类预报）：\n  - $N=12$\n  - $p=[0.8,0.8,0.8,0.8,0.8,0.8,0.2,0.2,0.2,0.2,0.2,0.2]$\n  - $o=[0,0,0,0,0,0,1,0,1,0,1,0]$\n\n- 测试用例4（混合极端值和中间值的概率）：\n  - $N=8$\n  - $p=[0.0,0.0,1.0,1.0,0.5,0.5,0.1,0.9]$\n  - $o=[0,0,1,1,0,1,0,1]$\n\n- 测试用例5（单个预报-观测对；边界情况）：\n  - $N=1$\n  - $p=[0.7]$\n  - $o=[1]$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例产生一个包含四个小数的列表，顺序为 $[BS,\\text{Reliability},\\text{Resolution},\\text{Uncertainty}]$。每个小数必须四舍五入到六位。总体输出应为这些按测试用例排列的列表的列表；例如，一个语法上有效的输出将类似于 $[[0.123456,0.010000,0.050000,0.163456],[\\dots],\\dots]$。",
            "solution": "我们从二元事件Brier评分的基本定义开始。给定预报 $p_i \\in [0,1]$ 和观测结果 $o_i \\in \\{0,1\\}$（其中 $i=1,\\dots,N$），Brier评分是均方误差\n$$\nBS \\equiv \\frac{1}{N} \\sum_{i=1}^{N} (p_i - o_i)^2 = \\mathbb{E}\\left[ (p - o)^2 \\right],\n$$\n其中 $\\mathbb{E}[\\cdot]$ 表示样本均值。\n\n为了将 $BS$ 分解为可靠性、分辨率和不确定性，我们调用基于预报类别的条件期望和适用于二元结果的全方差公式。通过将单位区间划分为具有边界 $0=e_1  e_2  \\dots  e_{K+1}=1$ 的固定分箱来定义预报类别。如果一个值为 $p$ 的预报满足 $e_k \\le p  e_{k+1}$（对于 $k=1,\\dots,K-1$），它被分配到第 $k$ 个分箱；如果满足 $e_{K} \\le p \\le e_{K+1}$，则被分配到最后一个分箱。令随机变量 $C$ 表示预报的分箱索引。令 $n_k$ 为第 $k$ 个分箱中的预报数量，并定义分箱权重 $w_k \\equiv n_k/N$。定义分箱内平均值\n$$\n\\bar{p}_k \\equiv \\frac{1}{n_k} \\sum_{i \\in \\mathcal{I}_k} p_i, \\quad \\bar{o}_k \\equiv \\frac{1}{n_k} \\sum_{i \\in \\mathcal{I}_k} o_i, \\quad \\text{for } n_k0,\n$$\n其中 $\\mathcal{I}_k$ 是属于第 $k$ 个分箱的索引。定义总体气候学\n$$\n\\bar{o} \\equiv \\frac{1}{N} \\sum_{i=1}^{N} o_i.\n$$\n\n分箱分解通过对 $C$ 进行条件化并在期望内展开平方项来进行。对于给定的分箱 $k$，我们写作\n$$\n\\mathbb{E}\\left[ (p - o)^2 \\mid C=k \\right] = \\mathbb{E}\\left[ \\left( (p - \\bar{p}_k) + (\\bar{p}_k - \\bar{o}_k) + (\\bar{o}_k - o) \\right)^2 \\mid C=k \\right].\n$$\n展开平方并取条件期望，会得到一些交叉项，这些交叉项由于每个分箱内中心化变量的零均值特性而消失，剩下的分量可以分为校准（分箱平均预报与分箱平均观测结果之差）、分层（分箱平均观测结果与气候学之差）和结果变率（相对于气候学的二元不确定性）。用权重 $w_k$ 对所有分箱进行聚合，得到\n$$\nBS = \\sum_{k=1}^{K} w_k (\\bar{p}_k - \\bar{o}_k)^2 - \\sum_{k=1}^{K} w_k (\\bar{o}_k - \\bar{o})^2 + \\bar{o}(1 - \\bar{o}) + \\Delta_{\\text{bin}},\n$$\n其中 $\\Delta_{\\text{bin}}$ 收集了当分箱包含异构预报值时，与分箱内 $p$ 围绕 $\\bar{p}_k$ 的变异相关的项。在类别对应于唯一预报概率（即，一个类别中所有的 $p_i$ 都等于一个公共值）的特殊情况下，$\\Delta_{\\text{bin}}=0$ 精确成立，并且分解恒等式\n$$\nBS = \\text{Reliability} - \\text{Resolution} + \\text{Uncertainty}\n$$\n精确成立，其中\n$$\n\\text{Reliability} \\equiv \\sum_{k=1}^{K} w_k (\\bar{p}_k - \\bar{o}_k)^2, \\quad\n\\text{Resolution} \\equiv \\sum_{k=1}^{K} w_k (\\bar{o}_k - \\bar{o})^2, \\quad\n\\text{Uncertainty} \\equiv \\bar{o}(1 - \\bar{o}).\n$$\n当固定分箱对异构预报值进行分组时，该分解仍然是一个标准且科学上合理的近似，其等式在 $\\Delta_{\\text{bin}}$ 的精度内成立，对于足够精细的分箱或较弱的分箱内变率，该项往往很小。\n\n算法设计：\n1. 对一个测试用例，接收数组 $p_1,\\dots,p_N$ 和 $o_1,\\dots,o_N$。计算\n   $$\n   BS = \\frac{1}{N} \\sum_{i=1}^{N} (p_i - o_i)^2, \\quad \\bar{o} = \\frac{1}{N} \\sum_{i=1}^{N} o_i, \\quad \\text{Uncertainty} = \\bar{o}(1-\\bar{o}).\n   $$\n2. 使用固定的分箱边界 $E=[0,0.2,0.4,0.6,0.8,1.0]$，根据 $e_k \\le p_i  e_{k+1}$（对于 $k=1,\\dots,K-1$）和 $e_K \\le p_i \\le e_{K+1}$（对于最后一个分箱），将每个预报 $p_i$ 分配到一个分箱索引 $k$。\n3. 对于每个 $n_k0$ 的分箱 $k$，计算 $w_k = n_k/N$、$\\bar{p}_k$ 和 $\\bar{o}_k$ 作为该分箱内索引的简单平均值。如果 $n_k=0$，则跳过该分箱（它对总和的贡献为零）。\n4. 通过以下公式计算可靠性和分辨率\n   $\n   \\text{Reliability} = \\sum_{k: n_k0} w_k (\\bar{p}_k - \\bar{o}_k)^2\n   $\n   和\n   $\n   \\text{Resolution} = \\sum_{k: n_k0} w_k (\\bar{o}_k - \\bar{o})^2.\n   $\n5. 返回该测试用例的元组 $[BS,\\text{Reliability},\\text{Resolution},\\text{Uncertainty}]$。\n6. 对套件中的每个测试用例重复此过程，并打印一行包含这些元组列表的输出，每个小数四舍五入到六位。\n\n科学真实性和边界情况处理：\n- 事件是表示为二元变量的三分位类别出现，这是S2S检验中的标准构造。\n- 跨越 $[0,1]$ 的固定分箱被广泛用于分箱可靠性图和分解；计数为零的分箱贡献为零。\n- 单一观测的边界情况 ($N=1$) 由定义自然处理；当 $\\bar{o} \\in \\{0,1\\}$ 时，可靠性简化为 $(p - o)^2$，分辨率为零，不确定性为 $\\bar{o}(1-\\bar{o})=0$。\n- 确定性的完美预报（$p_i \\in \\{0,1\\}$ 且 $p_i=o_i$）得出 $BS=0$，可靠性 $=0$，分辨率 $=\\text{Uncertainty}$，这与分解是一致的。\n\n最终输出是一个包含五个按测试用例排列的列表 $[BS,\\text{Reliability},\\text{Resolution},\\text{Uncertainty}]$ 的单一列表，每个值四舍五入到六位小数，按规定打印在一行上。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef brier_decomposition(p, o, edges):\n    \"\"\"\n    Compute Brier score and its bin-wise decomposition into reliability,\n    resolution, and uncertainty components using fixed bin edges.\n\n    Parameters:\n        p (list or np.ndarray): Forecast probabilities in [0,1].\n        o (list or np.ndarray): Binary outcomes in {0,1}.\n        edges (list or np.ndarray): Bin edges, ascending, covering [0,1],\n                                    last bin inclusive of right edge.\n\n    Returns:\n        tuple: (BS, REL, RES, UNC) as floats.\n    \"\"\"\n    p = np.asarray(p, dtype=float)\n    o = np.asarray(o, dtype=float)\n    N = p.size\n    if N == 0:\n        raise ValueError(\"Empty input arrays are not allowed.\")\n\n    # Core quantities\n    BS = float(np.mean((p - o) ** 2))\n    o_bar = float(np.mean(o))\n    UNC = o_bar * (1.0 - o_bar)\n\n    # Bin-wise stats\n    edges = np.asarray(edges, dtype=float)\n    K = edges.size - 1\n    REL = 0.0\n    RES = 0.0\n\n    for k in range(K):\n        left = edges[k]\n        right = edges[k + 1]\n        if k  K - 1:\n            idx = np.where((p >= left)  (p  right))[0]\n        else:\n            # Last bin includes right edge\n            idx = np.where((p >= left)  (p = right))[0]\n        n_k = idx.size\n        if n_k == 0:\n            continue\n        w_k = n_k / N\n        p_k = float(np.mean(p[idx]))\n        o_k = float(np.mean(o[idx]))\n        REL += w_k * (p_k - o_k) ** 2\n        RES += w_k * (o_k - o_bar) ** 2\n\n    return BS, REL, RES, UNC\n\ndef solve():\n    # Define fixed bin edges as specified: last bin includes 1.0\n    edges = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: perfect deterministic, correct forecasts\n        ( [0,0,0,0,0,0,1,1,1,0,0,1],\n          [0,0,0,0,0,0,1,1,1,0,0,1] ),\n        # Test case 2: uninformative climatology forecasts\n        ( [0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3,0.3],\n          [1,0,0,0,1,0,1,0,0,0] ),\n        # Test case 3: strongly miscalibrated, two-category forecasts\n        ( [0.8,0.8,0.8,0.8,0.8,0.8,0.2,0.2,0.2,0.2,0.2,0.2],\n          [0,0,0,0,0,0,1,0,1,0,1,0] ),\n        # Test case 4: mixed probabilities with extremes and mid-values\n        ( [0.0,0.0,1.0,1.0,0.5,0.5,0.1,0.9],\n          [0,0,1,1,0,1,0,1] ),\n        # Test case 5: single forecast-observation pair; edge case\n        ( [0.7],\n          [1] ),\n    ]\n\n    results = []\n    for p, o in test_cases:\n        BS, REL, RES, UNC = brier_decomposition(p, o, edges)\n        results.append([BS, REL, RES, UNC])\n\n    # Format each float to six decimal places and print the nested list\n    formatted_cases = []\n    for case in results:\n        formatted_values = [f\"{v:.6f}\" for v in case]\n        formatted_cases.append(\"[\" + \",\".join(formatted_values) + \"]\")\n    print(\"[\" + \",\".join(formatted_cases) + \"]\")\n\nsolve()\n```"
        }
    ]
}