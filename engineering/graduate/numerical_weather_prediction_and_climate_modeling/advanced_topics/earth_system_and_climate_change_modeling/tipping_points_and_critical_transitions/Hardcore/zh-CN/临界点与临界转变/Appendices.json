{
    "hands_on_practices": [
        {
            "introduction": "临界转变的早期预警信号植根于系统恢复力的丧失，即所谓的“临界慢化”现象。该练习将引导您通过分析一个随机系统线性化的核心模型——Ornstein-Uhlenbeck过程，来从第一性原理推导出方差和自相关这两个关键统计指标。通过这个理论实践，您将深刻理解为什么当系统接近临界点时，其状态波动会加剧且“记忆”会变长。",
            "id": "4105519",
            "problem": "考虑一个受随机强迫的线性化一维气候子系统，该系统由奥恩斯坦-乌伦贝克 (OU) 过程建模，也称为均值回归随机微分方程，其表达式为 $dx(t) = -\\lambda\\,x(t)\\,dt + \\sigma\\,dW_t$，其中 $W_t$ 是标准维纳过程（布朗运动），$\\lambda>0$ 是稳定不动点附近线性化漂移项的局部稳定性参数，$\\sigma>0$ 是噪声振幅。假设系统是平稳的，并以固定的时间间隔 $\\Delta t>0$ 进行采样。从维纳过程和伊藤积分的性质出发，且不使用任何预先推导的OU公式，推导 $x(t)$ 的平稳方差以及离散采样序列 $x_n \\equiv x(n\\,\\Delta t)$ 的滞后-1自相关，用 $\\lambda$、$\\sigma$ 和 $\\Delta t$ 表示。然后，在数值天气预报和气候模型的背景下，利用你推导出的表达式解释当系统接近以 $\\lambda\\to 0^{+}$（临界慢化）为特征的临界点时，这些量如何变化。将你的最终答案表示为平稳方差和滞后-1自相关的闭式解析表达式。不需要进行数值计算，最终答案中也不需要报告单位。",
            "solution": "问题陈述经核实具有科学依据、提法恰当、客观且自洽。它提出了一个随机过程理论中的标准问题，该问题在气候科学临界点的研究中有直接且重要的应用。所有必要的参数和条件都已提供，任务是进行严谨的数学推导，然后进行物理解释。\n\n该系统由奥恩斯坦-乌伦贝克随机微分方程 (SDE) 描述：\n$$\ndx(t) = -\\lambda\\,x(t)\\,dt + \\sigma\\,dW_t\n$$\n其中 $x(t)$ 是状态变量，$\\lambda > 0$ 是稳定性参数，$\\sigma > 0$ 是噪声振幅，$W_t$ 是标准维纳过程。我们的任务是从伊藤积分的基本原理出发，推导平稳方差和滞后-1自相关。\n\n首先，我们求解 $x(t)$ 的线性SDE。我们使用积分因子法，这与求解一阶线性常微分方程的方法类似。设积分因子为 $e^{\\lambda t}$。我们考虑乘积 $e^{\\lambda t} x(t)$ 的微分。对确定性函数 $f(t)$ 和随机过程 $X_t$ 使用伊藤乘积法则 $d(f(t)X_t) = f'(t)X_t dt + f(t)dX_t$，我们得到：\n$$\nd(e^{\\lambda t} x(t)) = (\\lambda e^{\\lambda t} dt)x(t) + e^{\\lambda t} dx(t)\n$$\n将 $dx(t)$ 的SDE代入：\n$$\nd(e^{\\lambda t} x(t)) = \\lambda e^{\\lambda t} x(t) dt + e^{\\lambda t} (-\\lambda x(t) dt + \\sigma dW_t)\n$$\n漂移项相互抵消：\n$$\nd(e^{\\lambda t} x(t)) = \\lambda e^{\\lambda t} x(t) dt - \\lambda e^{\\lambda t} x(t) dt + \\sigma e^{\\lambda t} dW_t\n$$\n$$\nd(e^{\\lambda t} x(t)) = \\sigma e^{\\lambda t} dW_t\n$$\n将其从时间 $s$ 积分到 $t > s$：\n$$\n\\int_s^t d(e^{\\lambda \\tau} x(\\tau)) = \\int_s^t \\sigma e^{\\lambda \\tau} dW_\\tau\n$$\n$$\ne^{\\lambda t} x(t) - e^{\\lambda s} x(s) = \\sigma \\int_s^t e^{\\lambda \\tau} dW_\\tau\n$$\n求解 $x(t)$，我们得到通解：\n$$\nx(t) = e^{-\\lambda(t-s)} x(s) + \\sigma \\int_s^t e^{-\\lambda(t-\\tau)} dW_\\tau\n$$\n问题指出该过程是平稳的。这意味着其统计特性不随时间变化。为了满足这一条件，我们可以认为该过程是从 $s \\to -\\infty$ 开始的。由于 $\\lambda > 0$，当 $s \\to -\\infty$ 时，项 $e^{-\\lambda(t-s)}x(s)$ 消失，前提是假设 $x(s)$ 不会指数增长，这对平稳过程是成立的。因此，平稳解可以表示为对无限远过去的伊藤积分：\n$$\nx(t) = \\sigma \\int_{-\\infty}^t e^{-\\lambda(t-\\tau)} dW_\\tau\n$$\n\n现在，我们推导平稳方差 $\\text{Var}(x(t))$。首先，我们计算均值 $E[x(t)]$：\n$$\nE[x(t)] = E\\left[ \\sigma \\int_{-\\infty}^t e^{-\\lambda(t-\\tau)} dW_\\tau \\right]\n$$\n对于确定性被积函数的伊藤积分，其期望为零，因为 $E[dW_\\tau] = 0$。\n$$\nE[x(t)] = \\sigma \\int_{-\\infty}^t e^{-\\lambda(t-\\tau)} E[dW_\\tau] = 0\n$$\n由于均值为零，方差等于二阶矩，即 $\\text{Var}(x(t)) = E[x(t)^2]$。\n$$\nE[x(t)^2] = E\\left[ \\left( \\sigma \\int_{-\\infty}^t e^{-\\lambda(t-\\tau)} dW_\\tau \\right)^2 \\right] = \\sigma^2 E\\left[ \\left( \\int_{-\\infty}^t e^{-\\lambda(t-\\tau)} dW_\\tau \\right)^2 \\right]\n$$\n我们应用伊藤等距性质，该性质指出，对于确定性函数 $f(\\tau)$，有 $E\\left[ \\left(\\int_a^b f(\\tau) dW_\\tau\\right)^2 \\right] = \\int_a^b f(\\tau)^2 d\\tau$。\n$$\nE[x(t)^2] = \\sigma^2 \\int_{-\\infty}^t \\left( e^{-\\lambda(t-\\tau)} \\right)^2 d\\tau = \\sigma^2 \\int_{-\\infty}^t e^{-2\\lambda(t-\\tau)} d\\tau\n$$\n为了计算该积分，我们使用换元法，令 $u = t-\\tau$，则 $du = -d\\tau$。积分限从 $\\tau \\in (-\\infty, t]$ 变为 $u \\in [0, \\infty)$。\n$$\n\\int_{-\\infty}^t e^{-2\\lambda(t-\\tau)} d\\tau = \\int_{\\infty}^0 e^{-2\\lambda u} (-du) = \\int_0^{\\infty} e^{-2\\lambda u} du = \\left[ -\\frac{1}{2\\lambda}e^{-2\\lambda u} \\right]_0^{\\infty} = 0 - \\left(-\\frac{1}{2\\lambda}\\right) = \\frac{1}{2\\lambda}\n$$\n因此，平稳方差为：\n$$\n\\text{Var}(x(t)) = \\frac{\\sigma^2}{2\\lambda}\n$$\n\n接下来，我们推导离散采样序列 $x_n = x(n\\Delta t)$ 的滞后-1自相关。自相关定义为 $\\rho(\\Delta t) = \\frac{\\text{Cov}(x(t+\\Delta t), x(t))}{\\text{Var}(x(t))}$。由于平稳性，该值与 $t$ 无关，并且等于序列 $x_n$ 的滞后-1自相关 $\\rho(1)$。\n协方差为 $\\text{Cov}(x(t+\\Delta t), x(t)) = E[x(t+\\Delta t)x(t)] - E[x(t+\\Delta t)]E[x(t)]$。由于均值为零，这简化为 $E[x(t+\\Delta t)x(t)]$。\n使用 $x(t)$ 的通解，令 $s=t$ 和时间步长为 $\\Delta t$：\n$$\nx(t+\\Delta t) = e^{-\\lambda \\Delta t} x(t) + \\sigma \\int_t^{t+\\Delta t} e^{-\\lambda(t+\\Delta t - \\tau)} dW_\\tau\n$$\n现在我们计算乘积 $x(t+\\Delta t)x(t)$ 的期望：\n$$\nE[x(t+\\Delta t)x(t)] = E\\left[ \\left( e^{-\\lambda \\Delta t} x(t) + \\sigma \\int_t^{t+\\Delta t} e^{-\\lambda(t+\\Delta t - \\tau)} dW_\\tau \\right) x(t) \\right]\n$$\n根据期望的线性性质：\n$$\nE[x(t+\\Delta t)x(t)] = E[e^{-\\lambda \\Delta t} x(t)^2] + E\\left[ x(t) \\cdot \\sigma \\int_t^{t+\\Delta t} e^{-\\lambda(t+\\Delta t - \\tau)} dW_\\tau \\right]\n$$\n第一项是 $e^{-\\lambda \\Delta t} E[x(t)^2] = e^{-\\lambda \\Delta t} \\text{Var}(x(t)) = e^{-\\lambda \\Delta t} \\frac{\\sigma^2}{2\\lambda}$。\n第二项涉及 $x(t)$ 与一个在未来时间区间 $[t, t+\\Delta t]$ 上的随机积分的乘积。过程 $x(t)$ 是 $\\tau \\le t$ 时维纳过程 $W_\\tau$ 的函数。对于 $\\tau > t$，维纳过程的增量 $dW_\\tau$ 独立于截至时间 $t$ 的过程历史（即独立于信息流 $\\mathcal{F}_t$）。状态 $x(t)$ 是 $\\mathcal{F}_t$-可测的。积分 $\\int_t^{t+\\Delta t} f(\\tau) dW_\\tau$ 的期望为零，且其值独立于 $x(t)$。\n$$\nE\\left[ x(t) \\cdot \\sigma \\int_t^{t+\\Delta t} e^{-\\lambda(t+\\Delta t - \\tau)} dW_\\tau \\right] = \\sigma E[x(t)] \\cdot E\\left[ \\int_t^{t+\\Delta t} e^{-\\lambda(t+\\Delta t - \\tau)} dW_\\tau \\right] = \\sigma \\cdot 0 \\cdot 0 = 0\n$$\n一个更严谨的论证是使用条件期望：$E[ x(t) \\int... ] = E[E[x(t) \\int... | \\mathcal{F}_t]] = E[x(t) E[\\int... | \\mathcal{F}_t]] = E[x(t) \\cdot 0] = 0$。\n因此，自协方差为：\n$$\n\\text{Cov}(x(t+\\Delta t), x(t)) = e^{-\\lambda \\Delta t} \\frac{\\sigma^2}{2\\lambda}\n$$\n那么，滞后-1自相关为：\n$$\n\\rho(1) = \\frac{\\text{Cov}(x(t+\\Delta t), x(t))}{\\text{Var}(x(t))} = \\frac{e^{-\\lambda \\Delta t} \\frac{\\sigma^2}{2\\lambda}}{\\frac{\\sigma^2}{2\\lambda}} = e^{-\\lambda \\Delta t}\n$$\n\n最后，我们在以“临界慢化”为特征的临界点背景下分析这些量，这对应于极限 $\\lambda \\to 0^+$。参数 $\\lambda$ 代表恢复力或向均值回归的速率。当 $\\lambda$ 趋近于零时，这个恢复力减弱，系统从扰动中恢复所需的时间变长。\n\n当 $\\lambda \\to 0^+$ 时，方差的行为是：\n$$\n\\lim_{\\lambda \\to 0^+} \\text{Var}(x(t)) = \\lim_{\\lambda \\to 0^+} \\frac{\\sigma^2}{2\\lambda} = \\infty\n$$\n这意味着当系统接近临界点时，其围绕稳定状态的波动幅度会无限增大。在气候模型的背景下，这将表现为模型变量（例如温度、冰体积）的波动越来越大且越来越不规律，这是即将发生临界转变的一个关键早期预警信号。\n\n当 $\\lambda \\to 0^+$ 时，滞后-1自相关的行为是：\n$$\n\\lim_{\\lambda \\to 0^+} \\rho(1) = \\lim_{\\lambda \\to 0^+} e^{-\\lambda \\Delta t} = e^0 = 1\n$$\n这表明，当系统接近临界点时，系统在连续时间步长上的状态变得几乎完全相关。这是“慢化”的直接结果；系统的记忆性增强，变得更加迟滞。一个扰动会持续更长的时间。这种增强的“记忆性”或时间相关性是气候科学中用于检测临界点邻近性的另一个关键早期预警信号。\n\n这两个推导出的表达式是平稳方差和滞后-1自相关。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{\\sigma^2}{2\\lambda}  \\exp(-\\lambda \\Delta t) \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "理论概念需要通过具体的模型来加深理解。本练习提供了一个研究临界点的典型非线性动力学模型，您将通过数值方法分析其平衡点的分支结构和稳定性。通过模拟控制参数的缓慢变化，您将亲手构建一个完整的迟滞回线，直观地揭示多稳态、突变和系统记忆等核心现象。",
            "id": "4105512",
            "problem": "考虑一维常微分方程 (ODE) $dx/dt=\\mu - x^3 + x$，其中 $x$ 是一个标量状态变量，$\\mu$ 是一个实值控制参数。在分析临界点和临界转变，特别是导致滞后现象的折叠（鞍-节）分岔结构时，这种范式（canonical form）会作为数值天气预报和气候模型中快慢分量的简化模型表示而出现。您的任务是确定平衡分支，评估其线性稳定性，并从第一性原理出发，在参数缓慢变化的情况下计算滞后回线。\n\n从基本定义开始：\n- 对于固定的 $\\mu$ 值，平衡点 $x^\\star$ 满足 $dx/dt=0$。\n- 平衡点的线性稳定性由方程右侧关于 $x$ 在 $x^\\star$ 处的导数的符号确定。负导数意味着局部渐近稳定；正导数意味着线性不稳定；零导数表示在分岔点处为中性稳定。\n\n设计并实现一个算法，该算法能够：\n1. 对于任意给定的 $\\mu$，确定所有满足平衡条件的实平衡点 $x^\\star$，并通过关于 $x$ 的导数对其进行线性稳定性分类（负为稳定，正为不稳定，零为中性稳定）。使用数值上可靠的程序来找到三次方程的实根，并使用一个小的容差来去重近似重合的根。\n2. 通过将 $\\mu$ 从最小值 $\\mu_{\\min}$ 扫掠到最大值 $\\mu_{\\max}$ 再返回，计算一个准静态滞后回线。对于 $\\mu$ 的每个增量步，假定系统状态绝热地跟踪最近的可用稳定平衡分支。当当前跟踪的稳定分支由于鞍-节分岔而消失时，状态应跳跃到最近的剩余稳定分支。这种选择规则模拟了表现出多重稳定状态的气候子系统中典型的慢驱动和快弛豫过程。\n\n使用以下参数值和要求的测试套件：\n- 对于平衡分析，在五个参数值 $\\mu \\in \\{-0.5,\\,-\\frac{2}{3\\sqrt{3}},\\,0,\\,\\frac{2}{3\\sqrt{3}},\\,0.5\\}$ 处进行评估。对于每个 $\\mu$ 值：\n  - 计算（去重后）不同实平衡点的数量。\n  - 以浮点数形式返回排序后的实平衡点 $x^\\star$ 列表。\n  - 以相同顺序返回这些平衡点的稳定性代码列表，其中稳定性代码为整数：$-1$ 表示线性稳定，$+1$ 表示线性不稳定， $0$ 表示中性稳定（导数为零）。\n- 对于滞后回线，对向上和向下扫掠均使用 $\\mu_{\\min}=-0.5$、$\\mu_{\\max}=0.5$ 和均匀步长 $\\Delta\\mu=0.01$。从 $\\mu_{\\min}$ 处的最低稳定平衡点初始化向上扫掠，从 $\\mu_{\\max}$ 处的最高稳定平衡点初始化向下扫掠。以两个浮点数列表的形式，报告在向上扫掠和向下扫掠过程中，三个采样点 $\\mu \\in \\{-0.3,\\,0.0,\\,0.3\\}$ 处的跟踪状态 $x$。\n- 此外，通过检查在 $\\mu=0.3$ 时向上扫掠状态和向下扫掠状态之间的绝对差值是否至少为 $10^{-6}$，包含一个布尔结果来指示是否存在滞后现象（如果差值大于或等于 $10^{-6}$ 则返回布尔值 $True$，否则返回 $False$）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。具体来说，输出必须是一个包含三项的列表：\n  - 第一项是一个列表，其中包含五个测试 $\\mu$ 值各自的结果，每个结果是一个包含四个条目的列表：浮点数 $\\mu$、实平衡点的整数数量、排序后的实平衡点列表，以及相应的稳定性代码列表。\n  - 第二项是一个包含两个条目的列表：向上扫掠时三个采样点的跟踪状态列表，以及向下扫掠时对应的列表。\n  - 第三项是在 $\\mu=0.3$ 处的布尔滞后指示符。\n此问题不涉及物理单位，也没有角度或百分比。最终输出必须严格按照指定格式打印为单行。",
            "solution": "经评估，该问题有效。它在科学上是合理的、提法恰当，并包含推导唯一、可验证解所需的所有必要信息。基础模型 $dx/dt = \\mu - x^3 + x$ 代表了鞍-节分岔的范式（normal form），这是研究临界点和临界转变的一个典范模型，在气候科学和其他非线性动力系统中尤其重要。该任务要求对平衡点进行系统性分析和对滞后现象进行数值模拟，这两者都是该领域的标准程序。\n\n解决方案将分两个主要部分展开：首先，分析系统平衡点及其稳定性与参数 $\\mu$ 的函数关系；其次，基于稳定态的准静态跟踪，对滞后回线进行数值模拟。\n\n**第一部分：平衡与稳定性分析**\n\n平衡态，记为 $x^\\star$，是指系统状态变量不随时间变化的那个点。这在数学上表示为条件 $dx/dt = 0$。对于给定的常微分方程（ODE），这导出了平衡方程：\n$$\n\\mu - (x^\\star)^3 + x^\\star = 0\n$$\n这可以重排为一个标准形式的降次三次方程：\n$$\n(x^\\star)^3 - x^\\star - \\mu = 0\n$$\n对于控制参数 $\\mu$ 的任何给定值，该多项式的实根就是系统的平衡点。一个三次多项式可以有一个或三个实根，我们将通过数值方法找到它们。\n\n一个平衡点 $x^\\star$ 的线性稳定性决定了对其的微小扰动是会衰减（稳定）还是会增长（不稳定）。这取决于常微分方程右侧（我们称之为 $f(x, \\mu) = \\mu - x^3 + x$）关于 $x$ 在平衡点 $x^\\star$ 处求导的符号。该导数为：\n$$\nf_x(x) = \\frac{\\partial f}{\\partial x} = 1 - 3x^2\n$$\n稳定性判据如下：\n- 如果 $f_x(x^\\star) = 1 - 3(x^\\star)^2  0$，则平衡点是局部渐近稳定的。我们分配一个稳定性代码 $-1$。\n- 如果 $f_x(x^\\star) = 1 - 3(x^\\star)^2 > 0$，则平衡点是不稳定的。我们分配一个稳定性代码 $+1$。\n- 如果 $f_x(x^\\star) = 1 - 3(x^\\star)^2 = 0$，则平衡点是中性稳定的，这指示了一个分岔点。我们分配一个稳定性代码 $0$。\n\n中性稳定条件 $1 - 3(x^\\star)^2 = 0$ 发生在 $x^\\star = \\pm 1/\\sqrt{3}$ 处。将这些值代回平衡方程 $\\mu = (x^\\star)^3 - x^\\star$ 可以得到发生鞍-节分岔的临界参数值 $\\mu_c$：\n- 对于 $x^\\star = 1/\\sqrt{3}$，$\\mu_c = (1/\\sqrt{3})^3 - (1/\\sqrt{3}) = \\frac{1}{3\\sqrt{3}} - \\frac{1}{\\sqrt{3}} = -\\frac{2}{3\\sqrt{3}}$。\n- 对于 $x^\\star = -1/\\sqrt{3}$，$\\mu_c = (-1/\\sqrt{3})^3 - (-1/\\sqrt{3}) = -\\frac{1}{3\\sqrt{3}} + \\frac{1}{\\sqrt{3}} = \\frac{2}{3\\sqrt{3}}$。\n\n在数值实现中，我们将使用一个鲁棒的多项式求根算法（`numpy.roots`）来为每个给定的 $\\mu$ 求解平衡点 $x^\\star$。然后，算法将筛选出实根，对其进行排序，并使用一个小的容差去除近似重复的根。随后，对于每个唯一的实平衡点，通过计算 $1 - 3(x^\\star)^2$ 并应用上述符号判据来确定其稳定性。\n\n**第二部分：滞后回线模拟**\n\n滞后现象是指系统状态依赖于其历史路径的现象。在此背景下，它的出现是由于在参数 $\\mu$ 的某个范围内（具体来说是 $|\\mu|  2/(3\\sqrt{3})$）存在多个稳定态。\n\n算法流程如下：\n1.  **参数扫掠离散化**：参数 $\\mu$ 以小的均匀步长 $\\Delta\\mu = 0.01$ 从最小值 $\\mu_{\\min} = -0.5$ 变化到最大值 $\\mu_{\\max} = 0.5$（向上扫掠），然后再从 $\\mu_{\\max}$ 返回到 $\\mu_{\\min}$（向下扫掠）。\n2.  **初始化轨迹**：\n    - 对于向上扫掠，初始状态是在 $\\mu_{\\min} = -0.5$ 处的数值最小的稳定平衡点。\n    - 对于向下扫掠，初始状态是在 $\\mu_{\\max} = 0.5$ 处的数值最大的稳定平衡点。\n3.  **路径跟踪（绝热跟踪）**：在参数扫掠的每一步（例如，从 $\\mu_i$ 到 $\\mu_{i+1}$），系统被假定为弛豫到“最近的”可用稳定平衡点。算法通过以下方式实现：\n    a.  计算新参数值 $\\mu_{i+1}$ 处的所有稳定平衡点。\n    b.  选择在数值上与前一个参数值 $x(\\mu_i)$ 处的系统状态最接近的那个平衡点。\n4.  **分岔点处的跳跃**：这种路径跟踪逻辑自然地捕捉了临界点特有的突变。当一个稳定分支在鞍-节分岔点处不复存在时，前一步的状态 $x(\\mu_i)$ 接近该分岔点。在 $\\mu_{i+1}$ 处，该分支已经消失。算法在寻找最近的可用稳定平衡点时，会发现唯一剩下的选项位于另一个遥远的稳定分支上。这种选择最近的剩余稳定态的过程构成了“跳跃”。\n\n通过记录向上和向下扫掠过程中的状态变量 $x$，我们可以观察到滞后回线。在双稳区域内，对于同一个 $\\mu$ 值，系统将占据不同的稳定态，具体取决于 $\\mu$ 是从较低值还是从较高值接近的。这种差异是滞后现象的直接度量。在 $\\mu=0.3$ 处的滞后测试涉及比较在该特定参数值下两次扫掠的状态值。\n\n该实现将收集五个指定 $\\mu$ 值的平衡分析结果、从向上和向下滞后扫掠中采样的状态，以及滞后检查的布尔结果，并将它们汇总到单一数据结构中以供最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bifurcation and hysteresis problem for the ODE dx/dt = mu - x^3 + x.\n    \"\"\"\n\n    # --- Part 1: Equilibrium and Stability Analysis ---\n\n    def analyze_equilibria(mu, tol=1e-9):\n        \"\"\"\n        For a given mu, finds all real equilibria, sorts them, and determines their stability.\n        \n        Args:\n            mu (float): The control parameter.\n            tol (float): Tolerance for numerical comparisons (real roots, duplicates, zero derivative).\n\n        Returns:\n            tuple: (number_of_equilibria, list_of_equilibria, list_of_stability_codes)\n        \"\"\"\n        # Equilibrium equation is x^3 - x - mu = 0\n        coeffs = [1, 0, -1, -mu]\n        roots = np.roots(coeffs)\n\n        # Filter for real roots\n        real_roots = roots[np.abs(roots.imag)  tol].real\n        \n        # Sort and deduplicate real roots\n        real_roots = np.sort(real_roots)\n        unique_roots = []\n        if len(real_roots) > 0:\n            unique_roots.append(real_roots[0])\n            for i in range(1, len(real_roots)):\n                if np.abs(real_roots[i] - real_roots[i - 1]) > tol:\n                    unique_roots.append(real_roots[i])\n    \n        unique_roots = np.array(unique_roots)\n        num_equilibria = len(unique_roots)\n\n        # Determine stability for each unique root\n        stability_codes = []\n        for x_star in unique_roots:\n            # Derivative is 1 - 3*x^2\n            deriv = 1 - 3 * x_star**2\n            if np.abs(deriv)  tol:\n                stability_codes.append(0)  # Neutral stability\n            elif deriv  0:\n                stability_codes.append(-1) # Stable\n            else:\n                stability_codes.append(1)  # Unstable\n        \n        return num_equilibria, list(unique_roots), stability_codes\n\n    mu_test_values = [-0.5, -2 / (3 * np.sqrt(3)), 0, 2 / (3 * np.sqrt(3)), 0.5]\n    equilibrium_results = []\n    for mu_val in mu_test_values:\n        num_eq, eqs, stabs = analyze_equilibria(mu_val)\n        equilibrium_results.append([mu_val, num_eq, eqs, stabs])\n\n    # --- Part 2: Hysteresis Loop Calculation ---\n\n    mu_min, mu_max, d_mu = -0.5, 0.5, 0.01\n\n    def get_stable_equilibria(mu):\n        \"\"\"Helper to return only stable equilibria for a given mu.\"\"\"\n        _, eqs, stabilities = analyze_equilibria(mu)\n        return np.array([eq for eq, stab in zip(eqs, stabilities) if stab == -1])\n\n    # Upward sweep\n    mu_up = np.arange(mu_min, mu_max + d_mu / 2, d_mu)\n    x_up_trajectory = []\n    \n    # Initialize: start at the lowest stable equilibrium at mu_min\n    initial_stable_eqs_up = get_stable_equilibria(mu_up[0])\n    x_current = np.min(initial_stable_eqs_up)\n\n    for mu in mu_up:\n        stable_eqs = get_stable_equilibria(mu)\n        if len(stable_eqs) > 0:\n            # Find the stable equilibrium closest to the previous state\n            distances = np.abs(stable_eqs - x_current)\n            x_current = stable_eqs[np.argmin(distances)]\n        else:\n            # This handles the moment of jump, where no stable root is found.\n            # a robust solver may look at unstable roots but per problem \"track stable\"\n            # this case should not be hit with small steps as the jump happens 'after' the bifurcation\n            # For this problem, we will assume at least one stable branch exists.\n            pass\n        x_up_trajectory.append(x_current)\n\n    # Downward sweep\n    mu_down = np.arange(mu_max, mu_min - d_mu / 2, -d_mu)\n    x_down_trajectory = []\n    \n    # Initialize: start at the highest stable equilibrium at mu_max\n    initial_stable_eqs_down = get_stable_equilibria(mu_down[0])\n    x_current = np.max(initial_stable_eqs_down)\n\n    for mu in mu_down:\n        stable_eqs = get_stable_equilibria(mu)\n        if len(stable_eqs) > 0:\n            distances = np.abs(stable_eqs - x_current)\n            x_current = stable_eqs[np.argmin(distances)]\n        x_down_trajectory.append(x_current)\n\n    # Sample the trajectories\n    sample_mus = [-0.3, 0.0, 0.3]\n    up_samples = []\n    down_samples = []\n\n    for s_mu in sample_mus:\n        idx_up = np.where(np.isclose(mu_up, s_mu))[0][0]\n        up_samples.append(x_up_trajectory[idx_up])\n        \n        idx_down = np.where(np.isclose(mu_down, s_mu))[0][0]\n        down_samples.append(x_down_trajectory[idx_down])\n\n    hysteresis_results = [up_samples, down_samples]\n\n    # --- Part 3: Hysteresis Presence Check ---\n    \n    x_up_at_0_3 = up_samples[2]\n    x_down_at_0_3 = down_samples[2]\n    is_hysteresis_present = bool(np.abs(x_up_at_0_3 - x_down_at_0_3) >= 1e-6)\n\n    # --- Final Output Assembly ---\n\n    final_result = [equilibrium_results, hysteresis_results, is_hysteresis_present]\n    \n    # Python's default string representation for lists matches the required bracketed format.\n    print(str(final_result))\n\nsolve()\n```"
        },
        {
            "introduction": "在真实世界的应用中，从充满噪声和强周期性（如季节性）的数据中提取早期预警信号是一项重大挑战。本练习模拟了一个完整的数据分析工作流，要求您处理一个合成的、但具有现实特征的时间序列。您将学习如何通过谐波回归去除季节性，并在滑动窗口中计算预警指标，最终使用非参数检验来判断临界慢化趋势的统计显著性。",
            "id": "4105489",
            "problem": "考虑一项任务：评估合成甲烷通量异常记录中的临界点早期预警信号（EWS）。这些记录表现出强烈的季节性周期和外部噪声。目标是确定记录中的滚动方差和滞后-1自相关是否都显示出统计上显著的增长趋势，这是与临界转变前的临界慢化相关的经典EWS。您必须构建信号，使用谐波回归去除季节性，计算滚动窗口诊断指标，并执行非参数趋势检验。三角函数中使用的所有角度都必须以弧度为单位。\n\n基本依据和假设：\n- 一个单变量时间序列被构建为一个季节性周期、一个随机自回归分量和独立高斯测量噪声的总和。季节性周期表示为在已知季节性角频率下正弦和余弦的有限和。随机分量遵循一个带有随时间变化的自回归系数的1阶非平稳自回归过程（AR(1)），测量噪声是独立同分布的。\n- AR(1) 过程由 $x_{t} = \\phi_{t}\\,x_{t-1} + \\eta_{t}$ 定义，其中 $t \\in \\{1,2,\\dots,N-1\\}$，$x_{0} = 0$，$\\{\\eta_{t}\\}$ 是均值为零、方差为 $\\sigma_{\\eta}^{2}$ 的独立高斯随机变量，而 $\\phi_{t}$ 随时间从初始值 $\\phi_{0}$ 平滑变化到最终值 $\\phi_{1}$。\n- 观测序列为 $y_{t} = s(t) + x_{t} + \\epsilon_{t}$，其中 $s(t)$ 是季节性分量，$\\{\\epsilon_{t}\\}$ 是均值为零、方差为 $\\sigma_{\\epsilon}^{2}$ 的独立高斯随机变量。\n- 季节性分量通过谐波回归进行建模并移除，使用一个设计矩阵，其列由一个截距项、$\\sin(\\omega t)$、$\\cos(\\omega t)$、$\\sin(2\\omega t)$ 和 $\\cos(2\\omega t)$ 组成，其中 $\\omega = 2\\pi/T$，$T$ 是以样本数计量的季节周期。将拟合的季节性周期从 $y_{t}$ 中减去，得到残差 $r_{t}$。\n- 滚动窗口诊断是在 $r_{t}$ 上使用大小为 $W$ 的窗口计算的。第 $i$ 个窗口的滚动方差为 $v_{i} = \\frac{1}{W-1}\\sum_{j=0}^{W-1}(r_{i+j} - \\bar{r}_{i})^{2}$，其中 $\\bar{r}_{i} = \\frac{1}{W}\\sum_{j=0}^{W-1} r_{i+j}$。同一窗口内的滞后-1自相关为 $a_{i} = \\frac{\\sum_{j=1}^{W-1} (r_{i+j}-\\bar{r}_{i})(r_{i+j-1}-\\bar{r}_{i})}{\\sum_{j=0}^{W-1} (r_{i+j}-\\bar{r}_{i})^{2}}$，前提是分母为正；否则，$a_{i}$ 被视为不可用。\n- 为评估 $\\{v_{i}\\}$ 和 $\\{a_{i}\\}$ 相对于索引 $i$ 的单调趋势，使用窗口索引与诊断序列之间的 Kendall’s tau 相关系数。设 $\\tau_{v}$ 和 $p_{v}$ 为 $\\{v_{i}\\}$ 的 Kendall tau 系数及其相关的 p 值，$\\tau_{a}$ 和 $p_{a}$ 为 $\\{a_{i}\\}$ 的相应值。如果 $\\tau_{v} > 0$ 且 $p_{v}  \\alpha$ 以及 $\\tau_{a} > 0$ 且 $p_{a}  \\alpha$ 两者同时成立，则将 EWS 检测决策定义为真，其中 $\\alpha$ 是显著性水平；否则决策为假。\n\n您的程序必须：\n- 对每个测试用例，使用指定的参数合成时间序列 $\\{y_{t}\\}_{t=0}^{N-1}$。为保证可复现性，每个测试用例使用一个固定的随机种子。\n- 使用指定的基函数，通过最小二乘谐波回归移除季节性周期，得到残差 $\\{r_{t}\\}$。\n- 计算残差序列的滚动窗口方差和滞后-1自相关，然后使用 Kendall's tau 及其 p 值评估每个诊断指标的单调趋势。\n- 根据上述规则，为每个测试用例生成布尔型的 EWS 检测决策。\n\n程序中的所有量都是无量纲的；没有需要报告的物理单位。$\\sin(\\cdot)$ 和 $\\cos(\\cdot)$ 中使用的角度以弧度为单位。最终输出必须是单行文本，包含所有测试用例的布尔结果列表，形式为方括号内以逗号分隔的列表（例如，`[True,False]`）。\n\n测试套件：\n- 测试用例 1（正常路径，强季节性，自回归系数递增）：\n  - $N = 2048$, $T = 365$, $A_{1} = 4.0$, $A_{2} = 2.0$, $\\phi_{0} = 0.30$, $\\phi_{1} = 0.97$, $\\sigma_{\\eta} = 0.50$, $\\sigma_{\\epsilon} = 0.70$, $W = 128$, $\\alpha = 0.01$, ${\\rm seed} = 11$。\n- 测试用例 2（边界条件，自回归系数恒定）：\n  - $N = 2048$, $T = 365$, $A_{1} = 4.0$, $A_{2} = 2.0$, $\\phi_{0} = 0.30$, $\\phi_{1} = 0.30$, $\\sigma_{\\eta} = 0.50$, $\\sigma_{\\epsilon} = 0.70$, $W = 128$, $\\alpha = 0.01$, ${\\rm seed} = 22$。\n- 测试用例 3（强季节性压力测试，自回归系数递增）：\n  - $N = 2048$, $T = 365$, $A_{1} = 12.0$, $A_{2} = 6.0$, $\\phi_{0} = 0.20$, $\\phi_{1} = 0.98$, $\\sigma_{\\eta} = 0.40$, $\\sigma_{\\epsilon} = 0.50$, $W = 128$, $\\alpha = 0.01$, ${\\rm seed} = 33$。\n- 测试用例 4（边缘情况，记录长度短，窗口大）：\n  - $N = 512$, $T = 365$, $A_{1} = 4.0$, $A_{2} = 2.0$, $\\phi_{0} = 0.20$, $\\phi_{1} = 0.95$, $\\sigma_{\\eta} = 0.50$, $\\sigma_{\\epsilon} = 0.70$, $W = 256$, $\\alpha = 0.05$, ${\\rm seed} = 44$。\n- 测试用例 5（外部噪声压力测试，自回归系数递增）：\n  - $N = 2048$, $T = 365$, $A_{1} = 4.0$, $A_{2} = 2.0$, $\\phi_{0} = 0.40$, $\\phi_{1} = 0.99$, $\\sigma_{\\eta} = 0.50$, $\\sigma_{\\epsilon} = 2.50$, $W = 128$, $\\alpha = 0.05$, ${\\rm seed} = 55$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，`[True,False,True,False,True]`）。",
            "solution": "用户提供了一个在时间序列分析领域定义明确的计算问题，具体涉及临界转变的早期预警信号（EWS）检测。该问题在科学上是合理的，内部是一致的，并且在计算上是可行的。因此，我将提供一个完整的解决方案。\n\n我的方法遵循问题陈述中概述的逻辑，分为四个主要阶段：\n1.  **时间序列合成**：为每个测试用例生成合成数据记录 $y_t$，包含季节性、自回归和噪声分量。\n2.  **谐波去季节化**：使用线性最小二乘回归从 $y_t$ 中移除季节性周期，以获得残差序列 $r_t$。\n3.  **滚动窗口诊断**：在残差序列 $r_t$ 上计算滚动窗口方差 $v_i$ 和滞后-1自相关 $a_i$。\n4.  **趋势分析与决策**：使用 Kendall's tau 相关性检验评估诊断序列中的单调趋势，并应用指定的决策规则来确定是否存在 EWS。\n\n在继续之前，我将明确说明为解决问题陈述中轻微的未指定问题而做出的两个次要假设，以确保一个完全确定和可复现的程序。\n-   假设时变自回归系数 $\\phi_t$ 随时间从其初始值 $\\phi_0$ 线性变化到其最终值 $\\phi_1$。这是“平滑”变化的最简单形式。\n    $$ \\phi_t = \\phi_0 + (\\phi_1 - \\phi_0) \\frac{t}{N-1} \\quad \\text{for } t = 0, 1, \\dots, N-1 $$\n-   季节性分量 $s(t)$ 是使用零相位的正弦函数生成的，其第一和第二谐波的振幅（$A_1$ 和 $A_2$）已给出。\n    $$ s(t) = A_1 \\sin(\\omega t) + A_2 \\sin(2\\omega t) \\quad \\text{where } \\omega = 2\\pi/T $$\n这个生成的信号位于谐波回归所用基函数张成的向量空间内，从而确保了去季节化步骤的有效性。\n\n在做出这些澄清之后，我现在将详细说明解决方案的每个步骤。\n\n**步骤 1：时间序列合成**\n对于每个测试用例，我们合成一个长度为 $N$ 的时间序列 $\\{y_t\\}_{t=0}^{N-1}$。使用指定的种子初始化随机数生成器以保证可复现性。\n\n-   **时间向量和角频率**：创建一个时间向量 $t = [0, 1, \\dots, N-1]$。基本季节性角频率为 $\\omega = 2\\pi/T$。\n\n-   **季节性分量 $s_t$**：季节性信号生成为 $s_t = A_1 \\sin(\\omega t) + A_2 \\sin(2\\omega t)$。\n\n-   **AR(1) 分量 $x_t$**：随机自回归过程是迭代生成的。首先，使用上面指定的线性斜坡计算自回归系数向量 $\\{\\phi_t\\}_{t=0}^{N-1}$。然后，从高斯分布 $N(0, \\sigma_\\eta^2)$ 中抽取一个新息向量 $\\{\\eta_t\\}_{t=0}^{N-1}$。根据问题要求，AR(1) 序列 $\\{x_t\\}$ 以 $x_0 = 0$ 初始化，后续值通过以下递推关系计算：\n    $$ x_t = \\phi_t x_{t-1} + \\eta_t \\quad \\text{for } t=1, 2, \\dots, N-1 $$\n\n-   **测量噪声 $\\epsilon_t$**：从高斯分布 $N(0, \\sigma_\\epsilon^2)$ 中抽取一个独立的测量噪声向量 $\\{\\epsilon_t\\}_{t=0}^{N-1}$。\n\n-   **观测序列 $y_t$**：最终的观测时间序列是三个分量的总和：\n    $$ y_t = s_t + x_t + \\epsilon_t $$\n\n**步骤 2：谐波回归与去季节化**\n为了分离出随机动态，必须移除强季节性分量。这通过普通最小二乘（OLS）回归实现。\n\n-   **设计矩阵**：我们构建一个 $N \\times 5$ 的设计矩阵 $\\mathbf{X}$，其中每一行对应一个时间点 $t$。$\\mathbf{X}$ 的列是在每个时间点上评估的基函数：\n    $$ \\mathbf{X} = \\begin{bmatrix} 1  \\sin(\\omega \\cdot 0)  \\cos(\\omega \\cdot 0)  \\sin(2\\omega \\cdot 0)  \\cos(2\\omega \\cdot 0) \\\\ 1  \\sin(\\omega \\cdot 1)  \\cos(\\omega \\cdot 1)  \\sin(2\\omega \\cdot 1)  \\cos(2\\omega \\cdot 1) \\\\ \\vdots  \\vdots  \\vdots  \\vdots  \\vdots \\\\ 1  \\sin(\\omega(N-1))  \\cos(\\omega(N-1))  \\sin(2\\omega(N-1))  \\cos(2\\omega(N-1)) \\end{bmatrix} $$\n\n-   **最小二乘拟合**：我们求解线性系统 $\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\beta} + \\boldsymbol{\\epsilon'}$ 以获得系数向量 $\\boldsymbol{\\beta} = [\\beta_0, \\beta_1, \\beta_2, \\beta_3, \\beta_4]^T$。OLS 解为 $\\hat{\\boldsymbol{\\beta}} = (\\mathbf{X}^T\\mathbf{X})^{-1}\\mathbf{X}^T\\mathbf{y}$。\n\n-   **残差**：拟合的季节性周期为 $\\hat{\\mathbf{s}} = \\mathbf{X}\\hat{\\boldsymbol{\\beta}}$。然后计算代表非季节性动态的残差序列为 $\\mathbf{r} = \\mathbf{y} - \\hat{\\mathbf{s}}$。\n\n**步骤 3：滚动窗口诊断**\n我们使用大小为 $W$ 的滑动窗口，在残差序列 $\\{r_t\\}$ 上计算 EWS 诊断指标，即滚动方差和滞后-1自相关。这将产生 $N - W + 1$ 个诊断值。\n\n-   **滚动方差**：对于从 $i=0$ 到 $N-W$ 的每个窗口 $i$，计算样本方差：\n    $$ v_i = \\frac{1}{W-1} \\sum_{j=0}^{W-1} (r_{i+j} - \\bar{r}_i)^2 $$\n    其中 $\\bar{r}_i$ 是第 $i$ 个窗口 $\\{r_k\\}_{k=i}^{i+W-1}$ 中数据的均值。这是无偏样本方差。\n\n-   **滚动滞后-1自相关**：对于同一个窗口 $i$，滞后-1自相关为：\n    $$ a_i = \\frac{\\sum_{j=1}^{W-1} (r_{i+j} - \\bar{r}_i)(r_{i+j-1} - \\bar{r}_i)}{\\sum_{j=0}^{W-1} (r_{i+j} - \\bar{r}_i)^2} $$\n    如果分母为零（当窗口中所有值都相同时发生），则自相关未定义，并被视为“非数值”（NaN）。\n\n**步骤 4：趋势分析与 EWS 决策**\n最后一步是检验两个诊断序列中是否存在统计上显著的正向单调趋势。\n\n-   **趋势检验**：我们使用 Kendall's tau 相关系数来衡量窗口索引 $i \\in \\{0, 1, ..., N-W\\}$ 与相应诊断值 $\\{v_i\\}$ 和 $\\{a_i\\}$ 之间的关联。对两个序列都进行此检验。我们关注的是正向趋势，因此单边假设检验是合适的（备择假设：$\\tau > 0$）。使用 `scipy.stats.kendalltau` 函数并设置 `alternative='greater'`。这将产生系数 $\\tau_v, \\tau_a$ 及其单边 p 值 $p_v, p_a$。诊断序列中的任何 NaN 值都将从检验中排除。\n\n-   **决策规则**：当且仅当两个诊断趋势均为正向且在显著性水平 $\\alpha$ 下具有统计显著性时，EWS 检测才记录为 `True`。正式条件是：\n    $$ \\text{EWS} = (\\tau_v > 0 \\text{ and } p_v  \\alpha) \\quad \\text{AND} \\quad (\\tau_a > 0 \\text{ and } p_a  \\alpha) $$\n    否则，决策为 `False`。将此完整过程应用于每个测试用例，以生成最终的布尔结果列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import kendalltau\n\ndef run_ews_analysis(N, T, A1, A2, phi0, phi1, sigma_eta, sigma_eps, W, alpha, seed):\n    \"\"\"\n    Performs the entire EWS analysis for a single test case.\n\n    Args:\n        N (int): Time series length.\n        T (int): Seasonal period in samples.\n        A1 (float): Amplitude of the first seasonal harmonic.\n        A2 (float): Amplitude of the second seasonal harmonic.\n        phi0 (float): Initial AR(1) coefficient.\n        phi1 (float): Final AR(1) coefficient.\n        sigma_eta (float): Standard deviation of AR(1) innovations.\n        sigma_eps (float): Standard deviation of measurement noise.\n        W (int): Rolling window size.\n        alpha (float): Significance level for trend tests.\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        bool: True if EWS are detected, False otherwise.\n    \"\"\"\n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # === Step 1: Time Series Synthesis ===\n    t = np.arange(N)\n    \n    # Seasonal component\n    omega = 2 * np.pi / T\n    s_t = A1 * np.sin(omega * t) + A2 * np.sin(2 * omega * t) # Explicit assumption\n\n    # AR(1) component\n    phi_t = np.linspace(phi0, phi1, N) # Explicit assumption of linear trend\n    eta_t = rng.normal(loc=0, scale=sigma_eta, size=N)\n    x_t = np.zeros(N)\n    # Per problem: x_0 = 0, and process is for t in {1, ..., N-1}\n    for i in range(1, N):\n        x_t[i] = phi_t[i] * x_t[i-1] + eta_t[i]\n        \n    # Measurement noise\n    epsilon_t = rng.normal(loc=0, scale=sigma_eps, size=N)\n\n    # Observed series\n    y_t = s_t + x_t + epsilon_t\n\n    # === Step 2: Harmonic Regression and Deseasonalization ===\n    # Construct design matrix X for harmonic regression\n    design_matrix = np.vstack([\n        np.ones(N),\n        np.sin(omega * t),\n        np.cos(omega * t),\n        np.sin(2 * omega * t),\n        np.cos(2 * omega * t)\n    ]).T\n\n    # Solve for regression coefficients using least squares\n    coeffs, _, _, _ = np.linalg.lstsq(design_matrix, y_t, rcond=None)\n\n    # Calculate fitted seasonal cycle and residuals\n    s_fit = design_matrix @ coeffs\n    r_t = y_t - s_fit\n\n    # === Step 3: Rolling Window Diagnostics ===\n    num_windows = N - W + 1\n    if num_windows = 1:\n        # Not enough data to compute a trend\n        return False\n        \n    rolling_var = np.empty(num_windows)\n    rolling_ac1 = np.empty(num_windows)\n\n    for i in range(num_windows):\n        window = r_t[i : i + W]\n        \n        # Rolling variance (unbiased estimator)\n        rolling_var[i] = np.var(window, ddof=1)\n        \n        # Rolling lag-1 autocorrelation\n        mean_win = np.mean(window)\n        centered_win = window - mean_win\n        \n        # Denominator corresponds to (W-1)*variance\n        denom = np.sum(centered_win**2)\n\n        if denom > 1e-12: # Check for non-zero variance\n            # Numerator is lag-1 autocovariance\n            num = np.sum(centered_win[1:] * centered_win[:-1])\n            rolling_ac1[i] = num / denom\n        else:\n            rolling_ac1[i] = np.nan\n\n    # === Step 4: Trend Analysis and EWS Decision ===\n    window_indices = np.arange(num_windows)\n\n    # Kendall's tau for variance\n    # Use 'greater' for one-sided test (H1: tau > 0)\n    tau_v, p_v = kendalltau(window_indices, rolling_var, nan_policy='omit', alternative='greater')\n    \n    # Kendall's tau for autocorrelation\n    tau_a, p_a = kendalltau(window_indices, rolling_ac1, nan_policy='omit', alternative='greater')\n\n    # EWS decision rule\n    # The condition tau > 0 is implicit if p  0.5 for a one-sided 'greater' test,\n    # but we include it for pedantic correctness as per the problem statement.\n    var_trend_detected = (tau_v > 0 and p_v  alpha)\n    ac1_trend_detected = (tau_a > 0 and p_a  alpha)\n    \n    is_ews_detected = var_trend_detected and ac1_trend_detected\n\n    return is_ews_detected\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1: Happy path\n        {'N': 2048, 'T': 365, 'A1': 4.0, 'A2': 2.0, 'phi0': 0.30, 'phi1': 0.97, 'sigma_eta': 0.50, 'sigma_eps': 0.70, 'W': 128, 'alpha': 0.01, 'seed': 11},\n        # Test case 2: Constant phi (no trend expected)\n        {'N': 2048, 'T': 365, 'A1': 4.0, 'A2': 2.0, 'phi0': 0.30, 'phi1': 0.30, 'sigma_eta': 0.50, 'sigma_eps': 0.70, 'W': 128, 'alpha': 0.01, 'seed': 22},\n        # Test case 3: Strong seasonality stress test\n        {'N': 2048, 'T': 365, 'A1': 12.0, 'A2': 6.0, 'phi0': 0.20, 'phi1': 0.98, 'sigma_eta': 0.40, 'sigma_eps': 0.50, 'W': 128, 'alpha': 0.01, 'seed': 33},\n        # Test case 4: Short record, large window\n        {'N': 512, 'T': 365, 'A1': 4.0, 'A2': 2.0, 'phi0': 0.20, 'phi1': 0.95, 'sigma_eta': 0.50, 'sigma_eps': 0.70, 'W': 256, 'alpha': 0.05, 'seed': 44},\n        # Test case 5: High measurement noise\n        {'N': 2048, 'T': 365, 'A1': 4.0, 'A2': 2.0, 'phi0': 0.40, 'phi1': 0.99, 'sigma_eta': 0.50, 'sigma_eps': 2.50, 'W': 128, 'alpha': 0.05, 'seed': 55},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_ews_analysis(**params)\n        results.append(result)\n\n    # Format output as a comma-separated list of booleans in square brackets\n    # e.g., [True,False,True,False,True]\n    result_str = f\"[{','.join(str(r) for r in results)}]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}