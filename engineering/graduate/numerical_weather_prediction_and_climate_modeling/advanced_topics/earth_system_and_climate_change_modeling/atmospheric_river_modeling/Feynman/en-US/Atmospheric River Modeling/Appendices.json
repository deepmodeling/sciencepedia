{
    "hands_on_practices": [
        {
            "introduction": "While Integrated Vapor Transport (IVT) is the primary metric for identifying atmospheric rivers, their true climatic importance lies in the total energy they convey. This exercise takes you from first principles to compute the Moist Static Energy (MSE) transport, allowing you to quantify and compare the contributions of latent energy ($L_v q$), specific enthalpy ($c_p T$), and gravitational potential energy ($gz$) within an AR's core . By dissecting the energy budget, you will gain a deeper physical intuition for what makes these events so impactful.",
            "id": "4014352",
            "problem": "You are tasked with designing and implementing a numerical algorithm to compute axis-parallel transport of Moist Static Energy (MSE) through an Atmospheric River (AR) cross-section, and to compare this transport to Integrated Vapor Transport (IVT). The algorithm must start from fundamental principles applicable to numerical weather prediction and climate modeling, without using shortcut formulas. Specifically, you must begin from the hydrostatic balance and the definition of Moist Static Energy per unit mass. You will treat the atmosphere in pressure coordinates and compute vertical integrals of transport using a scientifically sound discretization.\n\nFundamental base to use:\n- Hydrostatic balance: $\\mathrm{d}p = -\\rho g \\, \\mathrm{d}z$, where $p$ is pressure, $\\rho$ is air density, $g$ is gravitational acceleration, and $z$ is geometric height.\n- Hypsometric relationship to relate height to pressure via virtual temperature: use $T_v$ defined from temperature $T$ and specific humidity $q$ through a first-order approximation with a constant factor, and integrate thickness consistently with the hydrostatic base.\n- Moist Static Energy per unit mass is the sum of specific enthalpy, latent energy, and gravitational potential energy. Use the core definitions of these terms to derive the transport expressions.\n- Axis-parallel transport per unit width must be derived from the mass-flux-weighted integral of the appropriate quantity in pressure coordinates.\n\nConstants to use (express everything in International System of Units):\n- Specific heat at constant pressure for dry air $c_p = 1004.0 \\ \\mathrm{J\\,kg^{-1}\\,K^{-1}}$.\n- Latent heat of vaporization of water $L_v = 2.5 \\times 10^{6} \\ \\mathrm{J\\,kg^{-1}}$.\n- Gravitational acceleration $g = 9.81 \\ \\mathrm{m\\,s^{-2}}$.\n- Gas constant for dry air $R_d = 287.0 \\ \\mathrm{J\\,kg^{-1}\\,K^{-1}}$.\n- Virtual temperature factor $\\epsilon = 0.61$ for $T_v = T (1 + \\epsilon q)$.\n\nProgram requirements:\n- Derive, implement, and compute the vertically integrated axis-parallel MSE transport per unit width using the above base, split into its components associated with specific enthalpy, latent energy, and gravitational potential energy, and compute the total MSE transport as their sum.\n- Derive, implement, and compute the Integrated Vapor Transport (IVT) using the same base in pressure coordinates.\n- Use a trapezoidal discretization in pressure coordinates for all vertical integrals.\n- Compute geometric height as a function of pressure using the hypsometric relationship with virtual temperature. Take the lowest level height to be $z = 0$.\n- Treat transport as signed along the specified axis-parallel wind; when assessing dominance between the enthalpy and latent energy components, compare their magnitudes via absolute values.\n\nUnits and outputs:\n- Express the MSE transport per unit width in watts per meter ($\\mathrm{W\\,m^{-1}}$).\n- Express the Integrated Vapor Transport in kilograms per meter per second ($\\mathrm{kg\\,m^{-1}\\,s^{-1}}$).\n- For each test case, output six values in this exact order: total MSE transport, latent energy transport component, enthalpy transport component, gravitational potential energy transport component, IVT, and a boolean indicating whether the magnitude of the latent energy transport component exceeds the magnitude of the enthalpy transport component. All floating-point outputs must be in the units specified above. The boolean must be computed from absolute values of the two energy components.\n\nTest suite:\nProvide computations for the following four scientifically plausible AR cross-sections. Each case consists of arrays of pressure levels $p$ in pascals, axis-parallel wind speed $u$ in meters per second, temperature $T$ in kelvin, and specific humidity $q$ in kilograms per kilogram. Within each case, the pressure levels are ordered from near-surface to higher altitude.\n\n- Case $1$ (warm, moist, strong low-level winds):\n  - $p = [100000, 92500, 85000, 70000] \\ \\mathrm{Pa}$\n  - $u = [25, 30, 28, 20] \\ \\mathrm{m\\,s^{-1}}$\n  - $T = [290, 285, 280, 270] \\ \\mathrm{K}$\n  - $q = [0.015, 0.012, 0.009, 0.006] \\ \\mathrm{kg\\,kg^{-1}}$\n- Case $2$ (cool, drier, weakening winds with height):\n  - $p = [100000, 90000, 80000, 70000] \\ \\mathrm{Pa}$\n  - $u = [20, 18, 15, 12] \\ \\mathrm{m\\,s^{-1}}$\n  - $T = [275, 270, 265, 260] \\ \\mathrm{K}$\n  - $q = [0.006, 0.004, 0.003, 0.002] \\ \\mathrm{kg\\,kg^{-1}}$\n- Case $3$ (very strong low- to mid-level winds, moderate humidity):\n  - $p = [100000, 95000, 90000, 85000] \\ \\mathrm{Pa}$\n  - $u = [35, 40, 45, 50] \\ \\mathrm{m\\,s^{-1}}$\n  - $T = [288, 286, 284, 282] \\ \\mathrm{K}$\n  - $q = [0.010, 0.009, 0.008, 0.007] \\ \\mathrm{kg\\,kg^{-1}}$\n- Case $4$ (counterflow aloft reducing net transport):\n  - $p = [100000, 92500, 85000, 80000] \\ \\mathrm{Pa}$\n  - $u = [2, 1, 0, -1] \\ \\mathrm{m\\,s^{-1}}$\n  - $T = [285, 282, 279, 276] \\ \\mathrm{K}$\n  - $q = [0.012, 0.010, 0.008, 0.005] \\ \\mathrm{kg\\,kg^{-1}}$\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must concatenate the six outputs for Case $1$, followed by the six outputs for Case $2$, Case $3$, and Case $4$, in that order. For example, the output must look like $[x_1,x_2,x_3,x_4,x_5,x_6,y_1,y_2,\\dots]$, where each $x_i$ and $y_i$ is a float or a boolean as specified above.",
            "solution": "The problem is to compute the vertically integrated, axis-parallel transport of Moist Static Energy (MSE) and Integrated Vapor Transport (IVT) through a cross-section of an atmospheric river. The computation must be derived from fundamental principles, specifically the hydrostatic balance and the definitions of the physical quantities involved. The solution is developed in four parts: derivation of the general transport integral, application to IVT and MSE, calculation of geopotential height, and numerical implementation.\n\nThe fundamental expression for the horizontal transport of a generic intensive quantity $\\phi$ (quantity per unit mass) per unit width, parallel to an axis with wind component $u$, is the vertical integral of the mass flux ($\\rho u$) weighted by $\\phi$. In geometric height ($z$) coordinates, this is:\n$$ T_{\\phi} = \\int_{z_{sfc}}^{z_{top}} \\rho u \\phi \\, \\mathrm{d}z $$\nwhere $\\rho$ is the air density, $z_{sfc}$ is the surface height, and $z_{top}$ is the top of the atmospheric column under consideration.\n\nFor atmospheric calculations, it is standard to use pressure ($p$) as the vertical coordinate. The coordinate transformation is based on the hydrostatic balance equation:\n$$ \\mathrm{d}p = -\\rho g \\, \\mathrm{d}z $$\nwhere $g$ is the acceleration due to gravity. An element of mass per unit area, $dm = \\rho \\mathrm{d}z$, can thus be expressed as $dm = -\\mathrm{d}p/g$. Substituting this into the transport integral, we transform it into pressure coordinates:\n$$ T_{\\phi} = \\int_{p(z_{sfc})}^{p(z_{top})} u \\phi \\left(-\\frac{\\mathrm{d}p}{g}\\right) = \\frac{1}{g} \\int_{p_{top}}^{p_{sfc}} u \\phi \\, \\mathrm{d}p $$\nHere, $p_{sfc}$ and $p_{top}$ are the pressures at the surface and the top of the integration domain, respectively. This general formula is the foundation for all subsequent calculations.\n\n**1. Integrated Vapor Transport (IVT)**\nIntegrated Vapor Transport is the vertically integrated transport of water vapor. In this context, the specific quantity $\\phi$ is the specific humidity $q$. Substituting $\\phi = q$ into the general transport formula yields the expression for IVT:\n$$ IVT = \\frac{1}{g} \\int_{p_{top}}^{p_{sfc}} u q \\, \\mathrm{d}p $$\nThe units of IVT are derived from the components: $[g]^{-1} [u] [q] [p]$, which in SI units is $(\\mathrm{m\\,s^{-2}})^{-1} (\\mathrm{m\\,s^{-1}}) (1) (\\mathrm{Pa}) = (\\mathrm{s^2\\,m^{-1}})(\\mathrm{m\\,s^{-1}})(\\mathrm{N\\,m^{-2}}) = \\mathrm{s\\,N\\,m^{-2}} = \\mathrm{s\\,(kg\\,m\\,s^{-2})\\,m^{-2}} = \\mathrm{kg\\,m^{-1}\\,s^{-1}}$. This matches the required units.\n\n**2. Moist Static Energy (MSE) Transport**\nMoist Static Energy per unit mass, $m$, is the sum of specific enthalpy ($h$), latent energy ($L_v q$), and gravitational potential energy ($gz$):\n$$ m = h + L_v q + gz $$\nFor moist air, the specific enthalpy is well-approximated by $h \\approx c_p T$, where $c_p$ is the specific heat of dry air at constant pressure and $T$ is the temperature. Thus, the MSE is:\n$$ m = c_p T + L_v q + gz $$\nThe total vertically integrated MSE transport, $T_m$, is obtained by setting $\\phi=m$ in the general formula:\n$$ T_m = \\frac{1}{g} \\int_{p_{top}}^{p_{sfc}} u (c_p T + L_v q + gz) \\, \\mathrm{d}p $$\nThe units of MSE transport are $(\\mathrm{kg\\,m^{-1}\\,s^{-1}}) \\times (\\mathrm{J\\,kg^{-1}}) = \\mathrm{J\\,m^{-1}\\,s^{-1}} = \\mathrm{W\\,m^{-1}}$, as required. By the linearity of the integral, this total transport can be decomposed into three components:\n-   Enthalpy Transport ($T_h$):\n    $$ T_h = \\frac{1}{g} \\int_{p_{top}}^{p_{sfc}} u (c_p T) \\, \\mathrm{d}p $$\n-   Latent Energy Transport ($T_L$):\n    $$ T_L = \\frac{1}{g} \\int_{p_{top}}^{p_{sfc}} u (L_v q) \\, \\mathrm{d}p $$\n-   Gravitational Potential Energy Transport ($T_z$):\n    $$ T_z = \\frac{1}{g} \\int_{p_{top}}^{p_{sfc}} u (gz) \\, \\mathrm{d}p = \\int_{p_{top}}^{p_{sfc}} u z \\, \\mathrm{d}p $$\n\n**3. Calculation of Geometric Height ($z$)**\nThe potential energy transport component $T_z$ requires the geometric height $z$ as a function of pressure $p$. This relationship is derived from the hydrostatic equation and the ideal gas law for moist air, $p = \\rho R_d T_v$, where $R_d$ is the gas constant for dry air and $T_v$ is the virtual temperature. The virtual temperature is given by the first-order approximation $T_v = T(1 + \\epsilon q)$, with $\\epsilon = 0.61$.\nFrom the hydrostatic equation, $\\mathrm{d}z = -\\mathrm{d}p/(\\rho g)$. Substituting $\\rho = p/(R_d T_v)$ gives the differential form of the hypsometric equation:\n$$ \\mathrm{d}z = -\\frac{R_d T_v}{g} \\frac{\\mathrm{d}p}{p} $$\nTo find the height $z_i$ at a pressure level $p_i$ relative to a lower level $p_{i-1}$ (where $p_{i-1} > p_i$), we integrate this expression. The thickness of the layer $\\Delta z = z_i - z_{i-1}$ is:\n$$ \\Delta z = \\int_{p_{i-1}}^{p_i} -\\frac{R_d T_v}{g} \\frac{\\mathrm{d}p}{p} = \\frac{R_d}{g} \\int_{p_i}^{p_{i-1}} \\frac{T_v}{p} \\mathrm{d}p $$\nAssuming a constant layer-mean virtual temperature $\\bar{T}_{v,i} = \\frac{1}{2}(T_{v,i} + T_{v,i-1})$, the integral yields:\n$$ \\Delta z = \\frac{R_d \\bar{T}_{v,i}}{g} \\ln\\left(\\frac{p_{i-1}}{p_i}\\right) $$\nThe problem specifies that the lowest pressure level (highest pressure, index $i=0$) is at $z_0 = 0$. The heights of all other levels are calculated iteratively: $z_i = z_{i-1} + \\Delta z_i$.\n\n**4. Numerical Discretization and Algorithm**\nThe derived integrals are computed numerically using the trapezoidal rule. The input data are provided at discrete pressure levels $p_0, p_1, \\dots, p_{N-1}$, ordered from near-surface to higher altitude ($p_0 > p_1 > \\dots > p_{N-1}$). The integral of a function $F(p)$ from $p_{top}=p_{N-1}$ to $p_{sfc}=p_0$ is approximated by:\n$$ \\int_{p_{N-1}}^{p_0} F(p) \\, \\mathrm{d}p \\approx \\sum_{i=1}^{N-1} \\frac{F(p_i) + F(p_{i-1})}{2} (p_{i-1} - p_i) $$\nThis sum can be computed efficiently. For an array of function values `F` and coordinates `p` (where `p` is decreasing), the integral $\\int_{p_0}^{p_{N-1}} F(p) \\, \\mathrm{d}p$ is computed by `numpy.trapz(F, x=p)`. Since our integral is in the opposite direction, from $p_{N-1}$ to $p_0$, the result is obtained by negating this value.\n\nThe complete algorithm for each test case is as follows:\n1.  Establish constants: $c_p = 1004.0 \\ \\mathrm{J\\,kg^{-1}\\,K^{-1}}$, $L_v = 2.5 \\times 10^6 \\ \\mathrm{J\\,kg^{-1}}$, $g = 9.81 \\ \\mathrm{m\\,s^{-2}}$, $R_d = 287.0 \\ \\mathrm{J\\,kg^{-1}\\,K^{-1}}$, and $\\epsilon = 0.61$.\n2.  For the given arrays of $p, u, T, q$, first compute the geometric height $z$ at each pressure level.\n    a. Calculate virtual temperature $T_v$ at each level: $T_{v,i} = T_i (1 + \\epsilon q_i)$.\n    b. Initialize $z_0=0$.\n    c. For $i$ from $1$ to $N-1$, compute layer thickness $\\Delta z_i = \\frac{R_d}{g} \\frac{T_{v,i}+T_{v,i-1}}{2} \\ln(p_{i-1}/p_i)$ and set $z_i = z_{i-1} + \\Delta z_i$.\n3.  Define the integrands for each transport calculation at each pressure level:\n    -   IVT integrand: $F_{IVT} = uq$\n    -   Enthalpy transport integrand: $F_h = u c_p T$\n    -   Latent energy transport integrand: $F_L = u L_v q$\n    -   Potential energy transport integrand: $F_{z_g} = u g z$\n4.  Compute each vertically integrated transport using the trapezoidal rule:\n    -   $IVT = \\frac{1}{g} \\left( -\\int_{p_0}^{p_{N-1}} F_{IVT} \\,\\mathrm{d}p \\right)$\n    -   $T_h = \\frac{1}{g} \\left( -\\int_{p_0}^{p_{N-1}} F_{h} \\,\\mathrm{d}p \\right)$\n    -   $T_L = \\frac{1}{g} \\left( -\\int_{p_0}^{p_{N-1}} F_L \\,\\mathrm{d}p \\right)$\n    -   $T_z = \\frac{1}{g} \\left( -\\int_{p_0}^{p_{N-1}} F_{z_g} \\,\\mathrm{d}p \\right)$\n5.  Calculate the total MSE transport: $T_m = T_h + T_L + T_z$.\n6.  Determine if the magnitude of latent energy transport exceeds that of enthalpy transport: $|T_L| > |T_h|$.\n7.  Collect the six required output values in order: $T_m, T_L, T_h, T_z, IVT$, and the boolean result.\nThis procedure is applied to all provided test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes axis-parallel transport of Moist Static Energy (MSE) and\n    Integrated Vapor Transport (IVT) for given atmospheric profiles.\n    \"\"\"\n\n    # Define physical constants in SI units\n    c_p = 1004.0  # Specific heat at constant pressure for dry air (J/kg/K)\n    L_v = 2.5e6   # Latent heat of vaporization of water (J/kg)\n    g = 9.81      # Gravitational acceleration (m/s^2)\n    R_d = 287.0   # Gas constant for dry air (J/kg/K)\n    epsilon = 0.61  # Factor for virtual temperature calculation\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # Case 1 (warm, moist, strong low-level winds)\n        (\n            [100000, 92500, 85000, 70000],  # p (Pa)\n            [25, 30, 28, 20],  # u (m/s)\n            [290, 285, 280, 270],  # T (K)\n            [0.015, 0.012, 0.009, 0.006]  # q (kg/kg)\n        ),\n        # Case 2 (cool, drier, weakening winds with height)\n        (\n            [100000, 90000, 80000, 70000],  # p (Pa)\n            [20, 18, 15, 12],  # u (m/s)\n            [275, 270, 265, 260],  # T (K)\n            [0.006, 0.004, 0.003, 0.002]  # q (kg/kg)\n        ),\n        # Case 3 (very strong low- to mid-level winds, moderate humidity)\n        (\n            [100000, 95000, 90000, 85000],  # p (Pa)\n            [35, 40, 45, 50],  # u (m/s)\n            [288, 286, 284, 282],  # T (K)\n            [0.010, 0.009, 0.008, 0.007]  # q (kg/kg)\n        ),\n        # Case 4 (counterflow aloft reducing net transport)\n        (\n            [100000, 92500, 85000, 80000],  # p (Pa)\n            [2, 1, 0, -1],  # u (m/s)\n            [285, 282, 279, 276],  # T (K)\n            [0.012, 0.010, 0.008, 0.005]  # q (kg/kg)\n        )\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        p_list, u_list, T_list, q_list = case\n        p = np.array(p_list, dtype=float)\n        u = np.array(u_list, dtype=float)\n        T = np.array(T_list, dtype=float)\n        q = np.array(q_list, dtype=float)\n\n        # 1. Calculate geometric height z(p) using the hypsometric equation.\n        # The arrays are ordered from surface to top, so p is decreasing.\n        # z=0 at the first level (highest pressure).\n        N = len(p)\n        z = np.zeros_like(p)\n        T_v = T * (1 + epsilon * q)\n\n        for i in range(1, N):\n            # Layer is between levels i-1 and i\n            T_v_mean = (T_v[i-1] + T_v[i]) / 2.0\n            # Hypsometric formula for layer thickness\n            delta_z = (R_d * T_v_mean / g) * np.log(p[i-1] / p[i])\n            z[i] = z[i-1] + delta_z\n\n        # 2. Define integrands for transport calculations\n        integrand_ivt = u * q\n        integrand_h = u * c_p * T\n        integrand_L = u * L_v * q\n        integrand_z = u * g * z\n\n        # 3. Perform vertical integration using the trapezoidal rule\n        # The integral is (1/g) * Integral[F(p) dp] from p_top to p_sfc.\n        # np.trapz(F, x=p) integrates from p_sfc to p_top (as p is decreasing)\n        # so we must negate the result to get the desired integral direction.\n        \n        ivt = (1.0 / g) * (-np.trapz(integrand_ivt, x=p))\n        \n        transport_h = (1.0 / g) * (-np.trapz(integrand_h, x=p))\n        transport_L = (1.0 / g) * (-np.trapz(integrand_L, x=p))\n        transport_z = (1.0 / g) * (-np.trapz(integrand_z, x=p))\n\n        # 4. Calculate total MSE transport and the boolean comparison\n        total_mse_transport = transport_h + transport_L + transport_z\n        is_latent_dominant = np.abs(transport_L) > np.abs(transport_h)\n\n        # 5. Append the six results for this case\n        all_results.extend([\n            total_mse_transport,\n            transport_L,\n            transport_h,\n            transport_z,\n            ivt,\n            is_latent_dominant\n        ])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Identifying atmospheric rivers in complex datasets is not a trivial task, as other meteorological features like tropical cyclones and stationary fronts can also exhibit high moisture content. This practice challenges you to design a classification algorithm that uses a combination of dynamical criteria, such as relative vorticity ($\\zeta$) and frontogenesis ($F$), with geometrical properties to create a more reliable AR catalog . This skill is essential for developing accurate climate statistics and understanding long-term AR trends.",
            "id": "4014390",
            "problem": "You are tasked with formalizing an exclusion algorithm for Atmospheric River (AR) catalogs that removes features associated with tropical cyclones and stationary fronts by combining Integrated Vapor Transport (IVT) with vorticity, frontogenesis, and translation speed filters. Your program must implement the decision logic from first principles using well-established dynamical definitions and produce a boolean decision for each test case: retain in the AR catalog or exclude. The problem is expressed in purely mathematical terms and all inputs are provided as precomputed feature scalars for candidate objects.\n\nFundamental base:\n- Define the vertically integrated vapor transport vector $\\mathbf{I}$ by the hydrostatic integral\n$$\n\\mathbf{I} = \\frac{1}{g} \\int_{p_t}^{p_s} q(p) \\, \\mathbf{v}(p) \\, \\mathrm{d}p,\n$$\nwith magnitude $I = \\|\\mathbf{I}\\|$, where $g$ is gravitational acceleration, $p_s$ is surface pressure, $p_t$ is top pressure, $q$ is specific humidity, and $\\mathbf{v}$ is the horizontal wind vector. In practice, $I$ is supplied as a scalar magnitude in $\\mathrm{kg \\, m^{-1} \\, s^{-1}}$.\n- Define horizontal relative vorticity $\\zeta$ in Cartesian coordinates as\n$$\n\\zeta = \\frac{\\partial v}{\\partial x} - \\frac{\\partial u}{\\partial y},\n$$\nwith units $\\mathrm{s^{-1}}$, where $u$ and $v$ are the zonal and meridional wind components.\n- Define frontogenesis $F$ as the material rate of change of the magnitude of the potential temperature gradient,\n$$\nF = \\frac{D}{Dt} \\left\\| \\nabla \\theta \\right\\|,\n$$\nwhich is positive when a front strengthens. Here $F$ is provided as a scalar in $\\mathrm{K \\, m^{-1} \\, s^{-1}}$.\n- Define translation speed $U_t$ of an object’s centroid as\n$$\nU_t = \\frac{\\left\\| \\Delta \\mathbf{x} \\right\\|}{\\Delta t},\n$$\nwith units $\\mathrm{m \\, s^{-1}}$.\n- Define a dimensionless vorticity-core compactness $\\chi \\in [0,1]$ derived from a closed $\\zeta$ contour as\n$$\n\\chi = \\frac{4 \\pi A}{P^2},\n$$\nwhere $A$ is the enclosed area and $P$ is its perimeter. Values near $1$ indicate compact, circular cores, while values near $0$ indicate elongated or filamentary structures.\n\nDesign requirements:\n- A candidate AR object must first satisfy an IVT and geometry screening grounded in the elongated-corridor definition: large $I$, large aspect ratio, and sufficient length. Use thresholds $I_0$, $A_0$, and $L_0$.\n- Exclude tropical cyclone contamination where a compact, intense cyclonic core is present. Use a simultaneous threshold on relative vorticity and vorticity-core compactness.\n- Exclude stationary fronts using a simultaneous threshold on frontogenesis and low translation speed.\n\nImplement the following logical algorithm for each candidate object $k$ described by the tuple $\\left(I_k, A_k, L_k, \\zeta_k, \\chi_k, F_k, U_{t,k}\\right)$:\n- Candidate AR screening:\n  - Accept as candidate if $I_k \\ge I_0$, $A_k \\ge A_0$, and $L_k \\ge L_0$.\n- Tropical cyclone exclusion:\n  - Exclude if $\\zeta_k \\ge \\zeta_0$ and $\\chi_k \\ge \\chi_0$.\n- Stationary front exclusion:\n  - Exclude if $F_k \\ge F_0$ and $U_{t,k} \\le U_0$.\n- Final keep decision:\n  - Keep in AR catalog if and only if the candidate screening passes and neither exclusion applies.\n\nUse the following physically plausible thresholds expressed in the International System of Units (SI):\n- $I_0 = 250 \\, \\mathrm{kg \\, m^{-1} \\, s^{-1}}$,\n- $A_0 = 2.0$,\n- $L_0 = 1.5 \\times 10^{6} \\, \\mathrm{m}$,\n- $\\zeta_0 = 7.0 \\times 10^{-4} \\, \\mathrm{s^{-1}}$,\n- $\\chi_0 = 0.6$,\n- $F_0 = 1.8 \\times 10^{-9} \\, \\mathrm{K \\, m^{-1} \\, s^{-1}}$,\n- $U_0 = 2.0 \\, \\mathrm{m \\, s^{-1}}$.\n\nInput for your program:\n- Hard-code the following test suite as a list of tuples $(I, A, L, \\zeta, \\chi, F, U_t)$ with SI units:\n  - Test $1$: $(500.0, 4.0, 3.0 \\times 10^{6}, 2.0 \\times 10^{-4}, 0.2, 5.0 \\times 10^{-10}, 10.0)$.\n  - Test $2$: $(600.0, 3.0, 2.0 \\times 10^{6}, 1.1 \\times 10^{-3}, 0.8, 1.0 \\times 10^{-9}, 6.0)$.\n  - Test $3$: $(400.0, 4.0, 2.5 \\times 10^{6}, 3.0 \\times 10^{-4}, 0.3, 2.2 \\times 10^{-9}, 0.5)$.\n  - Test $4$: $(250.0, 2.0, 1.5 \\times 10^{6}, 6.5 \\times 10^{-4}, 0.7, 1.6 \\times 10^{-9}, 3.0)$.\n  - Test $5$: $(550.0, 3.5, 2.0 \\times 10^{6}, 8.0 \\times 10^{-4}, 0.4, 1.0 \\times 10^{-9}, 8.0)$.\n  - Test $6$: $(200.0, 2.5, 2.0 \\times 10^{6}, 2.0 \\times 10^{-4}, 0.3, 1.0 \\times 10^{-9}, 5.0)$.\n  - Test $7$: $(450.0, 2.1, 1.6 \\times 10^{6}, 2.0 \\times 10^{-4}, 0.5, 1.8 \\times 10^{-9}, 2.0)$.\n  - Test $8$: $(520.0, 3.2, 2.2 \\times 10^{6}, 3.0 \\times 10^{-4}, 0.35, 2.5 \\times 10^{-9}, 2.1)$.\n\nOutput specification:\n- For each test case, compute a boolean keep decision according to the algorithm above, where a value of true means “retain in AR catalog” and a value of false means “exclude”.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces, for example `[True,False,...]`.\n\nPhysical and numerical units:\n- All inputs use SI units as specified.\n- No angles or percentages are involved in the output.\n- The output is a list of booleans and is therefore unitless.\n\nDeliverable:\n- Provide a complete, runnable program that implements this logic and prints the single-line output for the test suite exactly as specified.",
            "solution": "The problem is valid. It presents a clear, self-contained, and scientifically-grounded task to implement a classification algorithm for atmospheric phenomena. The provided physical definitions, logical rules, and numerical data are consistent and sufficient to derive a unique solution for each test case.\n\nThe objective is to create an algorithm that decides whether to retain or exclude a given atmospheric feature from an Atmospheric River (AR) catalog. An AR is a long, narrow corridor of concentrated water vapor transport. The algorithm must filter out features that, while potentially having high moisture content, are dynamically different, specifically tropical cyclones (TCs) and stationary fronts (SFs). The decision process for each candidate feature $k$, described by a tuple of scalar properties $(I_k, A_k, L_k, \\zeta_k, \\chi_k, F_k, U_{t,k})$, is structured as a three-stage logical process.\n\nFirst, the candidate feature must pass a screening to determine if it meets the basic definition of an AR. This screening is based on the vertically integrated vapor transport magnitude ($I_k$), aspect ratio ($A_k$), and length ($L_k$). An AR is characterized by strong moisture transport ($I_k$), an elongated shape (high aspect ratio $A_k$), and significant length ($L_k$). The boolean condition `is_candidate` is true if and only if all three of the following inequalities are met:\n$$I_k \\ge I_0$$\n$$A_k \\ge A_0$$\n$$L_k \\ge L_0$$\nThe thresholds are given as $I_0 = 250 \\, \\mathrm{kg \\, m^{-1} \\, s^{-1}}$, $A_0 = 2.0$ (dimensionless), and $L_0 = 1.5 \\times 10^{6} \\, \\mathrm{m}$. If a candidate fails this screening, it is immediately excluded.\n\nSecond, if a feature passes the initial screening, it is checked against a tropical cyclone exclusion filter. TCs are characterized by very strong, compact cyclonic rotation. The algorithm identifies such features using thresholds on relative vorticity ($\\zeta_k$) and a dimensionless vorticity-core compactness metric ($\\chi_k$). A high value of $\\zeta_k$ indicates strong rotation, and a high value of $\\chi_k$ (approaching $1$) indicates a circular, compact core, both of which are hallmarks of a TC. The boolean condition `is_tc` is true if and only if both of the following inequalities are met simultaneously:\n$$\\zeta_k \\ge \\zeta_0$$\n$$\\chi_k \\ge \\chi_0$$\nThe thresholds are given as $\\zeta_0 = 7.0 \\times 10^{-4} \\, \\mathrm{s^{-1}}$ and $\\chi_0 = 0.6$.\n\nThird, the feature is checked against a stationary front exclusion filter. Stationary or quasi-stationary fronts can exhibit strong moisture convergence but lack the rapid, coherent advection characteristic of ARs. This filter identifies such features by combining a measure of front-strengthening (frontogenesis, $F_k$) with the feature's translation speed ($U_{t,k}$). A feature is flagged as a stationary front if it exhibits significant frontogenesis while moving very slowly. The boolean condition `is_sf` is true if and only if both of the following inequalities are met simultaneously:\n$$F_k \\ge F_0$$\n$$U_{t,k} \\le U_0$$\nThe thresholds are given as $F_0 = 1.8 \\times 10^{-9} \\, \\mathrm{K \\, m^{-1} \\, s^{-1}}$ and $U_0 = 2.0 \\, \\mathrm{m \\, s^{-1}}$.\n\nFinally, the decision to retain the feature in the AR catalog is made. A feature is kept if and only if it passes the initial candidate screening and is not excluded by either the TC or the SF filter. This logic is expressed by the compound boolean expression:\n$$\\text{keep} = \\text{is\\_candidate} \\land (\\neg \\text{is\\_tc}) \\land (\\neg \\text{is\\_sf})$$\nwhere $\\land$ represents the logical AND operator and $\\neg$ represents the logical NOT operator.\n\nThis complete logical framework is applied to each test case provided. The program will iterate through the list of input tuples, evaluate these three conditions, compute the final `keep` decision as a boolean value, and collect these booleans into an output list.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a decision algorithm to classify atmospheric features\n    for inclusion in or exclusion from an Atmospheric River (AR) catalog.\n    \"\"\"\n\n    # Define the physical thresholds in SI units as specified in the problem.\n    I_0 = 250.0  # kg m^-1 s^-1\n    A_0 = 2.0  # dimensionless aspect ratio\n    L_0 = 1.5e6  # m\n    ZETA_0 = 7.0e-4  # s^-1\n    CHI_0 = 0.6  # dimensionless compactness\n    F_0 = 1.8e-9  # K m^-1 s^-1\n    U_0 = 2.0  # m s^-1\n\n    # Define the test cases as a list of tuples:\n    # (I, A, L, zeta, chi, F, U_t)\n    test_cases = [\n        (500.0, 4.0, 3.0e6, 2.0e-4, 0.2, 5.0e-10, 10.0),   # Test 1\n        (600.0, 3.0, 2.0e6, 1.1e-3, 0.8, 1.0e-9, 6.0),    # Test 2\n        (400.0, 4.0, 2.5e6, 3.0e-4, 0.3, 2.2e-9, 0.5),    # Test 3\n        (250.0, 2.0, 1.5e6, 6.5e-4, 0.7, 1.6e-9, 3.0),    # Test 4\n        (550.0, 3.5, 2.0e6, 8.0e-4, 0.4, 1.0e-9, 8.0),    # Test 5\n        (200.0, 2.5, 2.0e6, 2.0e-4, 0.3, 1.0e-9, 5.0),    # Test 6\n        (450.0, 2.1, 1.6e6, 2.0e-4, 0.5, 1.8e-9, 2.0),    # Test 7\n        (520.0, 3.2, 2.2e6, 3.0e-4, 0.35, 2.5e-9, 2.1),   # Test 8\n    ]\n\n    results = []\n    for case in test_cases:\n        I_k, A_k, L_k, zeta_k, chi_k, F_k, U_t_k = case\n\n        # Stage 1: Candidate AR screening\n        # Checks for high IVT, large aspect ratio, and sufficient length.\n        is_candidate = (I_k >= I_0) and (A_k >= A_0) and (L_k >= L_0)\n\n        # Stage 2: Tropical cyclone exclusion\n        # Checks for a compact, intense cyclonic core.\n        is_tc = (zeta_k >= ZETA_0) and (chi_k >= CHI_0)\n\n        # Stage 3: Stationary front exclusion\n        # Checks for a strong, slow-moving frontal feature.\n        is_sf = (F_k >= F_0) and (U_t_k <= U_0)\n\n        # Final Decision: Keep if it's a candidate and not excluded.\n        keep_decision = is_candidate and not is_tc and not is_sf\n        \n        results.append(keep_decision)\n\n    # Format the output as a single-line string: [True,False,...]\n    # The boolean values are converted to strings \"True\" and \"False\".\n    output_string = f\"[{','.join(map(str, results))}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "A crucial part of atmospheric river modeling is assessing the skill of our forecasts. This exercise introduces the Equitable Threat Score (ETS), a robust metric for verifying predictions of binary events like AR landfalls . By implementing the ETS calculation from scratch, you will learn how to quantify a model's performance beyond simple accuracy by correctly normalizing hits ($H$) against those expected from a random forecast ($H_{\\text{random}}$).",
            "id": "4014349",
            "problem": "You are given a binary verification task for Atmospheric River (AR) landfall events within the domain of numerical weather prediction and climate modeling. An AR is diagnosed in observations by a separate, vetted method, and your forecast provides magnitudes of Integrated Vapor Transport (IVT). The verification goal is to quantify forecast skill using the Equitable Threat Score (ETS) across multiple thresholds of the absolute IVT magnitude $\\left| \\mathrm{IVT} \\right|$. Work from first principles of binary event verification and probability, and derive an algorithm that computes ETS from counts in a confusion matrix. The derivation must start from the definitions of hits, misses, false alarms, correct negatives, and the assumption that random forecasts have an expected number of hits equal to the product of marginal event frequencies.\n\nDefinitions and setup:\n- Atmospheric River (AR) landfall event: an observed binary event at a coastal grid point and valid time, denoted by $o_i \\in \\{0,1\\}$.\n- Forecast magnitude: $\\left| \\mathrm{IVT} \\right|_i \\ge 0$ in $\\mathrm{kg}\\ \\mathrm{m}^{-1}\\ \\mathrm{s}^{-1}$ at the same locations and times.\n- Event decision rule: For a chosen threshold $T$ in $\\mathrm{kg}\\ \\mathrm{m}^{-1}\\ \\mathrm{s}^{-1}$, the forecast declares an event if $\\left| \\mathrm{IVT} \\right|_i \\ge T$, otherwise declares no event.\n- Binary counts for a given $T$ over $N$ samples: hits $H$, misses $M$, false alarms $F$, correct negatives $C$. Use these to compute ETS based on the expected number of random hits under independence of forecast and observation.\n\nConventions:\n- If $H+F+M=0$ for a given threshold (no forecasted or observed events), define $\\mathrm{ETS}=0$ for that threshold.\n- Express every ETS value as a decimal rounded to $3$ decimals, not as a percentage.\n\nYour program must compute ETS for the test suite below. For each test case, apply all listed thresholds $T$, compute ETS per threshold, and return the list of ETS values for that case. Aggregate all cases in order into a single line of output containing a comma-separated list of lists, enclosed in square brackets, with no spaces.\n\nTest suite (all magnitudes are in $\\mathrm{kg}\\ \\mathrm{m}^{-1}\\ \\mathrm{s}^{-1}$):\n1. Mixed-skill case (happy path):\n   - Observed events $o^{(1)}$: $[0,1,0,1,0,0,1,1,0,1,0,0,1,0,0,1,0,0,1,0]$.\n   - Forecast magnitudes $\\left| \\mathrm{IVT} \\right|^{(1)}$: $[250,600,150,520,200,310,800,900,220,700,280,260,650,240,350,480,270,290,1000,180]$.\n   - Thresholds $T^{(1)}$: $[300,500,800]$.\n2. Perfect forecast at a single threshold:\n   - Observed events $o^{(2)}$: $[0,1,0,1,0,0,0,1,0,0]$.\n   - Forecast magnitudes $\\left| \\mathrm{IVT} \\right|^{(2)}$: $[200,550,300,600,400,450,100,700,350,250]$.\n   - Thresholds $T^{(2)}$: $[500]$.\n3. No observed events, some forecasted events:\n   - Observed events $o^{(3)}$: $[0,0,0,0,0,0,0,0,0,0,0,0]$.\n   - Forecast magnitudes $\\left| \\mathrm{IVT} \\right|^{(3)}$: $[100,200,450,350,250,300,150,400,50,280,320,180]$.\n   - Thresholds $T^{(3)}$: $[300]$.\n4. No observed events and no forecasted events at a very high threshold:\n   - Observed events $o^{(4)}$: $[0,0,0,0,0,0,0,0]$.\n   - Forecast magnitudes $\\left| \\mathrm{IVT} \\right|^{(4)}$: $[100,200,250,220,180,150,90,160]$.\n   - Thresholds $T^{(4)}$: $[1200]$.\n5. Poor overlap leading to negative ETS (edge case):\n   - Observed events $o^{(5)}$: $[1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0]$.\n   - Forecast magnitudes $\\left| \\mathrm{IVT} \\right|^{(5)}$: $[200,250,300,350,400,450,500,550,650,700,650,700,650,700,650,700,650,700,200,250]$.\n   - Thresholds $T^{(5)}$: $[600]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of lists enclosed in square brackets, with no spaces. For example, if there were two cases each with two thresholds, the output format would be $[[x_1,x_2],[y_1,y_2]]$. For the provided test suite, return $5$ inner lists, one per case, preserving the order above. All ETS values must be rounded to $3$ decimals and expressed as decimals.",
            "solution": "The user-provided problem has been rigorously validated against the specified criteria and is determined to be a valid, well-posed scientific problem.\n\nThe problem requires the derivation and implementation of an algorithm to compute the Equitable Threat Score (ETS) for binary event verification in the context of atmospheric river (AR) landfall forecasting.\n\nThe derivation and subsequent algorithm design will proceed from first principles as stipulated. We begin with the fundamental definitions used in binary event verification. For a set of $N$ forecast-observation pairs, we construct a $2 \\times 2$ contingency table with the following counts:\n- $H$ (Hits): The number of times an event was both forecast and observed. ($f_i=1, o_i=1$)\n- $M$ (Misses): The number of times an event was observed but not forecast. ($f_i=0, o_i=1$)\n- $F$ (False Alarms): The number of times an event was forecast but not observed. ($f_i=1, o_i=0$)\n- $C$ (Correct Negatives): The number of times an event was neither forecast nor observed. ($f_i=0, o_i=0$)\n\nThe total number of samples is $N = H + M + F + C$.\nThe total number of observed events is $H+M$.\nThe total number of forecast events is $H+F$.\n\nThe problem states that the expected number of hits for a random forecast, denoted $H_{\\text{random}}$, is based on the assumption of independence between the forecast and observed events. The empirical probability of observing an event is $P(\\text{obs}=1) = (H+M)/N$. The empirical probability of forecasting an event is $P(\\text{fcst}=1) = (H+F)/N$.\n\nUnder the assumption of independence, the probability of a hit (forecasting an event and observing an event) is the product of the marginal probabilities:\n$$ P(\\text{hit}) = P(\\text{fcst}=1 \\text{ and } \\text{obs}=1) = P(\\text{fcst}=1) \\times P(\\text{obs}=1) = \\frac{H+F}{N} \\times \\frac{H+M}{N} $$\nThe expected number of hits in $N$ trials for a random forecast is therefore:\n$$ H_{\\text{random}} = N \\times P(\\text{hit}) = N \\times \\frac{(H+F)(H+M)}{N^2} = \\frac{(H+M)(H+F)}{N} $$\n\nThe Equitable Threat Score (ETS), also known as the Gilbert Skill Score (GSS), is a skill score that measures the performance of a forecast relative to a random forecast. It is an adjustment of the Threat Score (TS), also called the Critical Success Index (CSI). The TS is defined as the fraction of correctly forecast events out of the union of all forecast and observed events:\n$$ \\mathrm{TS} = \\frac{H}{H+M+F} $$\nThe ETS corrects this score for hits that would occur purely by chance. Its general form is derived by normalizing the number of hits achieved above random chance by the total possible hits above random chance. The canonical formula for ETS is:\n$$ \\mathrm{ETS} = \\frac{H - H_{\\text{random}}}{H + M + F - H_{\\text{random}}} $$\nThe numerator, $H - H_{\\text{random}}$, represents the number of hits achieved by the forecast beyond what is expected from random chance. The denominator, $H + M + F - H_{\\text{random}}$, represents the total number of events in the union set (forecast or observed), adjusted by the number of random hits. For a perfect forecast ($M=0, F=0$), $H$ becomes the total number of observed events, and the formula correctly yields $\\mathrm{ETS}=1$. For a forecast that is no better than random ($H = H_{\\text{random}}$), $\\mathrm{ETS}=0$. For a forecast that is worse than random ($H < H_{\\text{random}}$), $\\mathrm{ETS} < 0$.\n\nThe problem specifies a convention for the case where no events are forecast and no events are observed at a given threshold. In this scenario, $H=0$, $M=0$, and $F=0$. The formula for ETS becomes $\\frac{0-0}{0-0}$, which is indeterminate. The specified convention, $\\mathrm{ETS}=0$, is a standard and sensible resolution for this case.\n\nThe algorithm to compute ETS is as follows:\n1.  For each test case and for each specified threshold $T$:\n2.  Convert the continuous forecast magnitudes $|\\mathrm{IVT}|_i$ into a binary forecast vector $f_i$ using the rule: $f_i=1$ if $|\\mathrm{IVT}|_i \\ge T$, and $f_i=0$ otherwise.\n3.  Compare the binary forecast vector $f_i$ to the binary observation vector $o_i$ to compute the contingency table counts: $H$, $M$, $F$, and $C$.\n4.  Calculate the total number of samples, $N=H+M+F+C$.\n5.  Check for the special case: If $H+M+F = 0$, the ETS is $0$ by definition.\n6.  Otherwise, calculate the number of hits expected by chance: $H_{\\text{random}} = \\frac{(H+M)(H+F)}{N}$.\n7.  Calculate the ETS using the derived formula: $\\mathrm{ETS} = \\frac{H - H_{\\text{random}}}{H + M + F - H_{\\text{random}}}$.\n8.  Round the final ETS value to $3$ decimal places.\n9.  Aggregate the results for all thresholds within a case into a list, and aggregate the lists for all cases into a final list of lists.",
            "answer": "```python\nimport numpy as np\n\ndef compute_ets_for_case(obs_events, fcst_magnitudes, thresholds):\n    \"\"\"\n    Computes the Equitable Threat Score (ETS) for a single test case across multiple thresholds.\n\n    Args:\n        obs_events (np.ndarray): Array of observed binary events (0 or 1).\n        fcst_magnitudes (np.ndarray): Array of forecast IVT magnitudes.\n        thresholds (list): List of thresholds to apply.\n\n    Returns:\n        list: A list of ETS values, one for each threshold, rounded to 3 decimals.\n    \"\"\"\n    results_for_case = []\n    \n    for T in thresholds:\n        # Step 2: Create binary forecast array\n        fcst_events = (fcst_magnitudes >= T).astype(int)\n        \n        # Step 3: Compute contingency table counts\n        H = np.sum((fcst_events == 1) & (obs_events == 1)) # Hits\n        M = np.sum((fcst_events == 0) & (obs_events == 1)) # Misses\n        F = np.sum((fcst_events == 1) & (obs_events == 0)) # False Alarms\n        C = np.sum((fcst_events == 0) & (obs_events == 0)) # Correct Negatives\n        \n        # Step 4: Total number of samples\n        N = H + M + F + C\n        if N == 0:\n            results_for_case.append(0.0)\n            continue\n            \n        # Step 5: Handle special case where no events are forecast or observed\n        if (H + M + F) == 0:\n            ets = 0.0\n        else:\n            # Step 6: Calculate random hits\n            # Ensure floating point division\n            H_random = ((H + M) * (H + F)) / N\n            \n            # Step 7: Calculate ETS\n            denominator = H + M + F - H_random\n            if denominator == 0:\n                # This case implies H = H_random, resulting in ETS = 0,\n                # or is an undefined state. Given the problem structure,\n                # ETS = 0 is a reasonable assignment if H = H_random.\n                ets = 0.0\n            else:\n                ets = (H - H_random) / denominator\n        \n        # Step 8: Round and append result\n        results_for_case.append(ets)\n        \n    return results_for_case\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"obs\": np.array([0,1,0,1,0,0,1,1,0,1,0,0,1,0,0,1,0,0,1,0]),\n            \"fcst\": np.array([250,600,150,520,200,310,800,900,220,700,280,260,650,240,350,480,270,290,1000,180]),\n            \"thresholds\": [300, 500, 800]\n        },\n        {\n            \"obs\": np.array([0,1,0,1,0,0,0,1,0,0]),\n            \"fcst\": np.array([200,550,300,600,400,450,100,700,350,250]),\n            \"thresholds\": [500]\n        },\n        {\n            \"obs\": np.array([0,0,0,0,0,0,0,0,0,0,0,0]),\n            \"fcst\": np.array([100,200,450,350,250,300,150,400,50,280,320,180]),\n            \"thresholds\": [300]\n        },\n        {\n            \"obs\": np.array([0,0,0,0,0,0,0,0]),\n            \"fcst\": np.array([100,200,250,220,180,150,90,160]),\n            \"thresholds\": [1200]\n        },\n        {\n            \"obs\": np.array([1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0]),\n            \"fcst\": np.array([200,250,300,350,400,450,500,550,650,700,650,700,650,700,650,700,650,700,200,250]),\n            \"thresholds\": [600]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        ets_values = compute_ets_for_case(case[\"obs\"], case[\"fcst\"], case[\"thresholds\"])\n        all_results.append(ets_values)\n        \n    # Format the output string as a comma-separated list of lists with no spaces\n    outer_list_str = []\n    for inner_list in all_results:\n        inner_list_str = [f\"{val:.3f}\" for val in inner_list]\n        outer_list_str.append(f\"[{','.join(inner_list_str)}]\")\n    \n    final_output = f\"[{','.join(outer_list_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}