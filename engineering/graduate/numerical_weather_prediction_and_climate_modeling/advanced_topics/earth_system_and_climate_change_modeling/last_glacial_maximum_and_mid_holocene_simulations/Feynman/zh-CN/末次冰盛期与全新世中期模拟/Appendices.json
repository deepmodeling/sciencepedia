{
    "hands_on_practices": [
        {
            "introduction": "任何气候模型的基石都是对地球能量平衡的准确表述。当全球温度发生变化时，地球向太空辐射的热量（出射长波辐射）也会相应改变，这构成了气候系统中最基本、最强有力的稳定（负）反馈，即普朗克反馈。这项练习将通过对斯特藩-玻尔兹曼定律进行线性化，来量化在末次盛冰期（LGM）的寒冷条件下普朗克反馈的强度，从而帮助您掌握气候反馈分析的核心技能，并理解气候敏感度的基本物理原理。",
            "id": "4058873",
            "problem": "在一个适用于古气候模拟的理想化全球平均大气层顶（TOA）能量平衡框架中，假设出射长波辐射由斯特藩-玻尔兹曼定律表征的黑体辐射决定。考虑相对于前工业化基线的末次冰盛期（LGM），并遵循以下假设：\n\n- 唯一有效的反馈是黑体辐射的温度依赖性（普朗克反馈），大气成分、云或递减率没有变化。\n- 有效发射温度的扰动等于地表温度的扰动，因此 $\\Delta T_{e} = \\Delta T_{s}$。\n- 用于线性化的有效发射温度是前工业化时期的值 $T_{e0} = 255\\,\\mathrm{K}$。\n- 相对于前工业化时期，末次冰盛期的全球平均地表气温异常为 $\\Delta T_{s} = -4.5\\,\\mathrm{K}$。\n- 斯特藩-玻尔兹曼常数为 $\\sigma = 5.670374419 \\times 10^{-8}\\,\\mathrm{W\\,m^{-2}\\,K^{-4}}$。\n\n从第一性原理出发，使用斯特藩-玻尔兹曼定律 $R = \\sigma T^{4}$ 在 $T_{e0}$ 附近的一阶泰勒展开来推导普朗克反馈参数，并计算与末次冰盛期温度扰动相关的、由此产生的大气层顶出射长波辐射的变化量 $\\Delta R_{\\mathrm{OLR}}$。将最终答案以 $\\mathrm{W\\,m^{-2}}$ 为单位表示，并四舍五入到四位有效数字。",
            "solution": "用户希望我解决一个热力学问题。我现在开始验证和解决过程。\n该问题是有效的。它在科学上是合理的、适定的和客观的。所有必要的信息都已提供，该任务是微积分在气候物理学中的一个标准应用。\n\n该问题要求计算从前工业化时代到末次冰盛期（LGM）的温度变化所对应的大气层顶（TOA）出射长波辐射的变化量 $\\Delta R_{\\mathrm{OLR}}$。此计算需使用斯特藩-玻尔兹曼定律的一阶泰勒展开来执行。\n\n根据问题陈述，出射长波辐射 $R$ 由黑体的斯特藩-玻尔兹曼定律决定：\n$$R(T_e) = \\sigma T_e^4$$\n其中 $\\sigma$ 是斯特藩-玻尔兹曼常数，$T_e$ 是地球的有效发射温度。\n\n我们被要求围绕一个由有效发射温度 $T_{e0}$ 表征的前工业化参考状态来线性化这个关系。函数 $R(T_e)$ 在点 $T_{e0}$ 附近的一阶泰勒展开由下式给出：\n$$R(T_e) \\approx R(T_{e0}) + \\frac{dR}{dT_e}\\bigg|_{T_{e0}} (T_e - T_{e0})$$\n出射长波辐射的变化量 $\\Delta R_{\\mathrm{OLR}}$ 是在扰动温度 $T_e$ 下的辐射与在参考温度 $T_{e0}$ 下的辐射之差：\n$$\\Delta R_{\\mathrm{OLR}} = R(T_e) - R(T_{e0})$$\n代入泰勒展开，我们发现，在一阶近似下，这个变化量为：\n$$\\Delta R_{\\mathrm{OLR}} \\approx \\frac{dR}{dT_e}\\bigg|_{T_{e0}} (T_e - T_{e0})$$\n令 $\\Delta T_e = T_e - T_{e0}$ 为有效发射温度的扰动。则表达式变为：\n$$\\Delta R_{\\mathrm{OLR}} \\approx \\frac{dR}{dT_e}\\bigg|_{T_{e0}} \\Delta T_e$$\n项 $\\frac{dR}{dT_e}\\big|_{T_{e0}}$ 表示在参考状态下评估的出射长波辐射对发射温度变化的敏感度。这就是普朗克反馈参数。为了求得它，我们首先计算 $R(T_e)$ 相对于 $T_e$ 的导数：\n$$\\frac{dR}{dT_e} = \\frac{d}{dT_e}(\\sigma T_e^4) = 4\\sigma T_e^3$$\n在参考温度 $T_{e0}$ 处计算此导数，得到普朗克反馈参数，我们可以将其表示为 $\\lambda_P$。在这个简化模型中，假设 $\\Delta T_e = \\Delta T_s$，该参数也表示单位地表温度变化所对应的出射长波辐射（OLR）变化。\n$$\\lambda_P = \\frac{dR}{dT_e}\\bigg|_{T_{e0}} = 4\\sigma T_{e0}^3$$\n现在，我们可以代入给定的值来计算 $\\lambda_P$。问题提供了：\n- 前工业化有效发射温度, $T_{e0} = 255\\,\\mathrm{K}$。\n- 斯特藩-玻尔兹曼常数, $\\sigma = 5.670374419 \\times 10^{-8}\\,\\mathrm{W\\,m^{-2}\\,K^{-4}}$。\n\n将这些值代入 $\\lambda_P$ 的表达式中：\n$$\\lambda_P = 4 \\times (5.670374419 \\times 10^{-8}\\,\\mathrm{W\\,m^{-2}\\,K^{-4}}) \\times (255\\,\\mathrm{K})^3$$\n$$\\lambda_P = 4 \\times (5.670374419 \\times 10^{-8}) \\times (16581375)\\,\\mathrm{W\\,m^{-2}\\,K^{-1}}$$\n$$\\lambda_P \\approx 3.7610486\\,\\mathrm{W\\,m^{-2}\\,K^{-1}}$$\n这就是普朗克反馈参数。它量化了温度每升高一开尔文，出射长波辐射增加的量，从而为气候系统提供了一个稳定的（负）反馈。\n\n接下来，我们计算出射长波辐射的变化量 $\\Delta R_{\\mathrm{OLR}}$。公式是：\n$$\\Delta R_{\\mathrm{OLR}} \\approx \\lambda_P \\Delta T_e$$\n问题陈述，有效发射温度的扰动等于地表温度的扰动，即 $\\Delta T_e = \\Delta T_s$。给定的末次冰盛期地表温度异常是 $\\Delta T_s = -4.5\\,\\mathrm{K}$。\n因此，$\\Delta T_e = -4.5\\,\\mathrm{K}$。\n\n代入 $\\lambda_P$ 和 $\\Delta T_e$ 的值：\n$$\\Delta R_{\\mathrm{OLR}} \\approx (3.7610486\\,\\mathrm{W\\,m^{-2}\\,K^{-1}}) \\times (-4.5\\,\\mathrm{K})$$\n$$\\Delta R_{\\mathrm{OLR}} \\approx -16.9247187\\,\\mathrm{W\\,m^{-2}}$$\n负号表示在更冷的末次冰盛期期间，出射长波辐射较低，这在物理上是一致的。\n\n问题要求最终答案以 $\\mathrm{W\\,m^{-2}}$ 为单位表示，并四舍五入到四位有效数字。将 $-16.9247187$ 四舍五入到四位有效数字得到 $-16.92$。",
            "answer": "$$ \\boxed{-16.92} $$"
        },
        {
            "introduction": "在进行古气候模拟时，一个核心的实际挑战是确定模型需要运行多长时间才能达到平衡状态，即“渐进平衡”（spin-up）。气候系统的不同组成部分具有迥异的响应时间尺度，其中深海的千年尺度调整过程往往是决定性因素。本练习旨在通过量纲分析，从一维扩散方程推导出深海示踪剂（如温度和盐度）的平衡时间尺度的估算方法，阐明为何古气候模拟需要进行长达数千年的积分才能使深层海洋达到稳定。",
            "id": "4058786",
            "problem": "在末次冰盛期（LGM）的瞬变古气候模拟中，深海被动示踪剂的平衡过程常受限于平均翻转环流在长时标上较弱区域的垂直扩散。考虑一个几何深度尺度为 $H$、垂直扩散率为 $\\kappa$ 的深海水柱，且 $\\kappa$ 在深度和时间上近似均匀。从示踪剂守恒和菲克扩散定律出发，推导深海中被动示踪剂异常的特征平衡时间尺度 $\\tau$ 的标度估计，用 $H$ 和 $\\kappa$ 表示。然后，为一个合理的 LGM 深渊配置评估此时间尺度，该配置的特点是海平面较低、内潮汐耗散增强，我们假设这会产生一个代表性的均匀垂直扩散率 $\\kappa = 1.0 \\times 10^{-4}\\ \\mathrm{m^{2}\\ s^{-1}}$，作用于 $H = 4.0 \\times 10^{3}\\ \\mathrm{m}$ 的深度尺度。使用换算关系 $1\\ \\mathrm{yr} = 3.1536 \\times 10^{7}\\ \\mathrm{s}$。将你最终的 $\\tau$ 数值答案四舍五入至三位有效数字，并以年为单位表示。",
            "solution": "出发点是示踪剂质量守恒与菲克扩散定律的结合。设 $C(z,t)$ 表示一维垂直水柱中被动示踪剂的浓度，其中垂直坐标 $z$ 向上增加，且 $z=0$ 位于底部。在没有源和汇的情况下，具有垂直扩散通量的示踪剂守恒方程为\n$$\n\\frac{\\partial C}{\\partial t} + \\frac{\\partial J}{\\partial z} = 0,\n$$\n其中垂直扩散通量 $J$ 遵循菲克定律，\n$$\nJ = -\\kappa \\frac{\\partial C}{\\partial z}.\n$$\n假设 $\\kappa$ 在 $z$ 和 $t$ 上是均匀的，代入可得一维扩散方程\n$$\n\\frac{\\partial C}{\\partial t} = \\kappa \\frac{\\partial^{2} C}{\\partial z^{2}}.\n$$\n为了获得平衡时间尺度 $\\tau$ 的标度估计，我们使用特征垂直长度尺度 $H$（深海深度）和一个用于描述初始示踪剂异常衰减的未知时间尺度 $\\tau$ 来对该方程进行无量纲化。定义无量纲变量 $\\hat{z} = z/H$ 和 $\\hat{t} = t/\\tau$。导数变换如下：\n$$\n\\frac{\\partial}{\\partial t} = \\frac{1}{\\tau} \\frac{\\partial}{\\partial \\hat{t}}, \\quad \\frac{\\partial}{\\partial z} = \\frac{1}{H} \\frac{\\partial}{\\partial \\hat{z}}, \\quad \\frac{\\partial^{2}}{\\partial z^{2}} = \\frac{1}{H^{2}} \\frac{\\partial^{2}}{\\partial \\hat{z}^{2}}.\n$$\n将这些代入扩散方程，得到\n$$\n\\frac{1}{\\tau} \\frac{\\partial C}{\\partial \\hat{t}} = \\kappa \\frac{1}{H^{2}} \\frac{\\partial^{2} C}{\\partial \\hat{z}^{2}}.\n$$\n对于一个在 $\\hat{z}$ 上具有量级为1的无量纲梯度和曲率，并在 $\\hat{t}$ 上具有量级为1的时间衰减的特征异常，其前置因子必须在主导阶上平衡，这意味着\n$$\n\\frac{1}{\\tau} \\sim \\frac{\\kappa}{H^{2}} \\quad \\Longrightarrow \\quad \\tau \\sim \\frac{H^{2}}{\\kappa}.\n$$\n该标度关系不依赖于具体的边界条件，只要它们在物理上是合理的（例如，底部无通量，顶部为无通量或固定浓度），因为在深度 $H$ 上的扩散模态的主导阶平衡速率与拉普拉斯算子最小非零特征值的倒数成标度关系，而该特征值与 $H^{-2}$ 成正比。\n\n我们现在为指定的 LGM 参数评估该时间尺度。当 $H = 4.0 \\times 10^{3}\\ \\mathrm{m}$ 且 $\\kappa = 1.0 \\times 10^{-4}\\ \\mathrm{m^{2}\\ s^{-1}}$ 时，\n$$\n\\tau = \\frac{H^{2}}{\\kappa} = \\frac{\\left(4.0 \\times 10^{3}\\ \\mathrm{m}\\right)^{2}}{1.0 \\times 10^{-4}\\ \\mathrm{m^{2}\\ s^{-1}}}.\n$$\n计算分子：\n$$\n\\left(4.0 \\times 10^{3}\\ \\mathrm{m}\\right)^{2} = 1.6 \\times 10^{7}\\ \\mathrm{m^{2}}.\n$$\n除以 $\\kappa$:\n$$\n\\tau = \\frac{1.6 \\times 10^{7}\\ \\mathrm{m^{2}}}{1.0 \\times 10^{-4}\\ \\mathrm{m^{2}\\ s^{-1}}} = 1.6 \\times 10^{11}\\ \\mathrm{s}.\n$$\n使用 $1\\ \\mathrm{yr} = 3.1536 \\times 10^{7}\\ \\mathrm{s}$ 将秒转换为年：\n$$\n\\tau_{\\mathrm{yr}} = \\frac{1.6 \\times 10^{11}\\ \\mathrm{s}}{3.1536 \\times 10^{7}\\ \\mathrm{s\\ yr^{-1}}} = \\left(\\frac{1.6}{3.1536}\\right) \\times 10^{4}\\ \\mathrm{yr}.\n$$\n计算前置因子：\n$$\n\\frac{1.6}{3.1536} \\approx 0.50736.\n$$\n因此，\n$$\n\\tau_{\\mathrm{yr}} \\approx 0.50736 \\times 10^{4}\\ \\mathrm{yr} = 5.0736 \\times 10^{3}\\ \\mathrm{yr}.\n$$\n四舍五入到三位有效数字，平衡时间尺度为\n$$\n\\tau_{\\mathrm{yr}} \\approx 5.07 \\times 10^{3}\\ \\mathrm{yr}.\n$$",
            "answer": "$$\\boxed{5.07 \\times 10^{3}}$$"
        },
        {
            "introduction": "将气候模型应用于末次盛冰期等古气候情景时，必须精确处理与现代气候差异巨大的边界条件，其中最重要的变化之一就是海平面下降导致的海岸线变迁。这项高级练习将引导您设计并实现一个算法，用于在有限体积海洋模型中更新海陆分布，同时确保示踪剂质量的严格守恒，并处理因陆桥出现而形成的“孤立”内湖。此练习将理论物理原则（质量守恒）与计算实践（图论连通性分析、质量重新分配）相结合，为您提供了解决气候建模中常见但复杂的数值挑战的宝贵经验。",
            "id": "4058831",
            "problem": "您的任务是设计并实现一个算法，在末次冰盛期（LGM）海平面情景下，更新有限体积海洋网格上的海岸掩码，同时确保离散示踪剂守恒并消除孤立海洋单元（与开放海洋不连通的内陆湖）。该网格的水平单元面积是均匀的。推导的基本依据必须始于示踪剂守恒定律的有限体积形式以及结构化网格上的图连通性。\n\n假设以下基本设置和定义：\n- 一个有限体积网格由 $(i,j)$ 索引，具有均匀的单元面积 $A$ (单位为 $\\mathrm{m}^2$) 。\n- 每个单元具有初始（现今）海洋深度 $h_{ij}$ (单位为 $\\mathrm{m}$) 和初始示踪剂浓度 $C_{ij}^0$ (单位为 示踪剂单位/$\\mathrm{m}^3$)。\n- 每个单元的初始控制体积为 $V_{ij}^0 = A \\, h_{ij}$ (单位为 $\\mathrm{m}^3$)，初始示踪剂质量为 $m_{ij}^0 = C_{ij}^0 \\, V_{ij}^0$ (单位为 示踪剂单位)。\n- 在 LGM 海平面下降 $S$ (单位为 $\\mathrm{m}$) 的情况下，变化后的名义水柱厚度为 $h_{ij}' = \\max(h_{ij} - S, 0)$。\n- 海平面变化后的候选海洋单元是那些满足 $h_{ij}' > 0$ 的单元。\n- 开放海洋边界定义为西边界上的候选海洋单元集合（所有满足 $h_{ij}'>0$ 的列索引为 $j=0$ 的单元）。如果两个单元共享一个面（四邻域连通性），则它们是相邻的。\n- 孤立海洋单元是指那些没有通过面相邻路径连接到任何开放海洋边界单元的候选海洋单元。为避免出现孤立单元，所有此类不连通的候选海洋单元必须在最终掩码中被重新分类为陆地。\n\n您的算法必须满足以下离散守恒和掩码要求：\n1. 对于最终海洋掩码中保留的每个单元（即，与开放海洋边界相连的候选海洋单元），其最终体积为 $V_{ij}^1 = A \\, h_{ij}'$。\n2. 对于每个这样的保留海洋单元，其最终示踪剂质量 $m_{ij}^{\\mathrm{final}}$ 必须等于其初始示踪剂质量 $m_{ij}^0$ 加上从变为陆地的单元（由于干涸或孤立）接收到的任何再分配质量。\n3. 所有最终海洋单元的最终示踪剂浓度必须计算为 $C_{ij}^{\\mathrm{final}} = m_{ij}^{\\mathrm{final}} / V_{ij}^1$。\n4. 对于任何变为陆地的单元（$h_{ij}'=0$ 或被孤立），其全部初始示踪剂质量 $m_{ij}^0$ 必须使用网格上面相邻邻居定义的路径，重新分配给最近的最终海洋单元。如果在最小路径距离（以跨面相邻的单元中心之间的步数衡量）处有 $k$ 个最近的最终海洋单元，则质量必须平均分配，即每个单元接收 $m_{ij}^0 / k$。如果整个域中没有最终海洋单元（这在测试套件中不应发生），则未定义如何重新分配。\n5. 所有最终海洋单元的总示踪剂质量必须在数值精度范围内等于所有初始湿润单元的总初始示踪剂质量。\n\n从无源汇的被动示踪剂在每个控制体积上积分的有限体积守恒原理出发，论证上述更新规则。特别是，推导当 $V_{ij}$ 变为 $V_{ij}'$ 但控制体积仍为海洋时，为何守恒 $m_{ij}$ 意味着将 $C_{ij}$ 更新为 $C_{ij}' = m_{ij}/V_{ij}'$，并论证为何移除一个控制体积（干涸或孤立）需要重新分配其积分质量以保持全域积分示踪剂质量。\n\n您的程序必须实现上述方法，并将其应用于以下测试套件。每个测试用例指定了 $h_{ij}$ 网格（单位为 $\\mathrm{m}$）、均匀单元面积 $A$（单位为 $\\mathrm{m}^2$）、LGM 海平面下降 $S$（单位为 $\\mathrm{m}$）和初始示踪剂浓度场 $C_{ij}^0$（单位为 示踪剂单位/$\\mathrm{m}^3$）。\n\n对于每个测试用例，您的程序必须计算并返回一个包含以下三个条目的列表：\n- 标量质量守恒误差，计算公式为\n$$\n\\varepsilon = \\left| \\frac{\\sum_{(i,j)} m_{ij}^{\\mathrm{final}} - \\sum_{(i,j)} m_{ij}^0}{\\sum_{(i,j)} m_{ij}^0} \\right|,\n$$\n表示为十进制数（无量纲）。\n- 一个布尔值，指示所有最终海洋单元是否通过面相邻路径连接到开放海洋边界（此项必须计算得出，而非假设）。\n- 一个整数，等于被重新分类为陆地的孤立候选海洋单元的数量。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result1,result2,result3]$），其中每个 $result$ 本身就是针对一个测试用例的、按以下顺序提供的、如上所述的三元素列表。\n\n测试套件（所有深度 $h_{ij}$ 单位为 $\\mathrm{m}$，所有面积 $A$ 单位为 $\\mathrm{m}^2$，所有海平面下降 $S$ 单位为 $\\mathrm{m}$，所有 $C_{ij}^0$ 单位为 示踪剂单位/$\\mathrm{m}^3$）：\n\n- 测试用例 $1$（陆架干涸，海岸连通）：\n  - 网格大小：$4 \\times 4$。\n  - $h_{ij}$:\n    - 第 $0$ 行：$[200,200,150,50]$\n    - 第 $1$ 行：$[200,100,80,20]$\n    - 第 $2$ 行：$[200,150,90,10]$\n    - 第 $3$ 行：$[300,250,200,100]$\n  - $A = 10^6$。\n  - $S = 80$。\n  - $C_{ij}^0 = 35$（处处相等）。\n\n- 测试用例 $2$（因海槛显露而形成的孤立内陆盆地）：\n  - 网格大小：$5 \\times 5$。\n  - $h_{ij}$:\n    - 第 $0$ 行：$[300,300,300,300,300]$\n    - 第 $1$ 行：$[300,50,50,50,300]$\n    - 第 $2$ 行：$[300,50,200,50,300]$\n    - 第 $3$ 行：$[300,50,50,50,300]$\n    - 第 $4$ 行：$[300,300,300,300,300]$\n  - $A = 10^6$。\n  - $S = 120$。\n  - $C_{ij}^0 = 35$（处处相等）。\n\n- 测试用例 $3$（无变化）：\n  - 网格大小：$3 \\times 3$。\n  - $h_{ij}$:\n    - 第 $0$ 行：$[100,150,120]$\n    - 第 $1$ 行：$[130,140,110]$\n    - 第 $2$ 行：$[90,80,70]$\n  - $A = 10^6$。\n  - $S = 0$。\n  - $C_{ij}^0 = 35$（处处相等）。\n\n- 测试用例 $4$（强海平面下降，狭窄的连通残留体）：\n  - 网格大小：$3 \\times 5$。\n  - $h_{ij}$:\n    - 第 $0$ 行：$[300,200,100,50,20]$\n    - 第 $1$ 行：$[400,300,200,100,80]$\n    - 第 $2$ 行：$[350,250,150,90,60]$\n  - $A = 10^6$。\n  - $S = 90$。\n  - $C_{ij}^0 = 35$（处处相等）。\n\n所有带有物理单位的量都已指明单位。您的程序必须实现该算法以：\n- 使用 $h_{ij}' = \\max(h_{ij} - S, 0)$ 计算候选海洋掩码。\n- 使用与西边界的面相邻连通性识别并移除孤立的候选海洋单元。\n- 将被移除单元的质量重新分配给最近的最终海洋单元，并在所有最小图距离处的接收者之间平均分配。\n- 使用 $C_{ij}^{\\mathrm{final}} = m_{ij}^{\\mathrm{final}} / (A \\, h_{ij}')$ 计算最终海洋单元上的 $C_{ij}^{\\mathrm{final}}$。\n- 报告每个测试用例的三元组 $[\\varepsilon, \\text{is\\_connected}, \\text{orphan\\_count}]$。\n\n您的程序应生成单行输出，其中包含这 $4$ 个测试用例的三元组列表，按顺序排列，使用 Python 列表表示法，例如 `[[\\dots],[\\dots],[\\dots],[\\dots]]`。不应产生其他输出。",
            "solution": "该问题是有效的。它提出了一个在海洋和气候建模中常见的、适定的、有科学依据的任务：更新模型的陆海掩码以反映海平面变化，同时保持被动示踪剂的守恒。规则是完整的、一致的，并且在计算上是可行的。\n\n### 基于有限体积守恒原理的论证\n\n更新示踪剂质量和浓度的算法规则源于被动示踪剂质量守恒的基本原理，并应用于离散的有限体积框架中。\n\n对于浓度为 $C$（单位为 示踪剂单位/$\\mathrm{m}^3$）的被动示踪剂，在控制体积 $V$（单位为 $\\mathrm{m}^3$）内，若无源汇，其守恒定律指出，总示踪剂质量 $m = \\int_V C \\, dV$ 的变化率等于穿过该体积边界的净通量。当将整个模型域视为一个封闭系统时，总示踪剂质量是守恒的。\n\n在有限体积离散化中，域被划分为一组单元，此处用 $(i,j)$ 索引。每个单元中的示踪剂质量为 $m_{ij} = C_{ij} V_{ij}$。初始海洋单元域 $\\Omega_0$ 中的总质量为 $M_0 = \\sum_{(i,j) \\in \\Omega_0} m_{ij}^0 = \\sum_{(i,j) \\in \\Omega_0} C_{ij}^0 V_{ij}^0$。\n\n该问题描述了由于海平面下降 $S$ 导致模型几何结构发生瞬时、离散的变化。这不是一个时间演化问题，而是在新域 $\\Omega_1$ 上对模型状态的重新初始化。核心科学要求是在此过渡过程中总示踪剂质量守恒：$M_1 = M_0$。\n\n初始海洋单元集合 $\\Omega_0$ 被划分为两个不相交的子集：\n1.  在最终配置中仍为海洋的单元，构成最终海洋域 $\\Omega_1$。\n2.  变为陆地的单元，$\\Omega_L = \\Omega_0 \\setminus \\Omega_1$。这些单元要么干涸（即它们的新深度 $h_{ij}' = \\max(h_{ij} - S, 0)$ 变为 $0$），要么被识别为“孤立的”（即与主要海洋体不连通）。\n\n为了强制执行全局质量守恒，必须将 $\\Omega_L$ 中单元的总质量重新分配给 $\\Omega_1$ 中的单元。单元 $(k,l) \\in \\Omega_1$ 中的最终质量，表示为 $m_{kl}^{\\mathrm{final}}$，是其初始质量 $m_{kl}^0$ 加上它从 $\\Omega_L$ 中的单元接收到的任何质量。\n$$\nm_{kl}^{\\mathrm{final}} = m_{kl}^0 + \\sum_{(i,j) \\in \\Omega_L} \\delta m_{(i,j) \\to (k,l)}\n$$\n其中 $\\delta m_{(i,j) \\to (k,l)}$ 是从单元 $(i,j) \\in \\Omega_L$ 转移到单元 $(k,l) \\in \\Omega_1$ 的质量。\n\n问题为这种重新分配指定了一个严格的规则：一个新陆地单元 $(i,j)$ 的全部质量 $m_{ij}^0$ 被平均分配给 $\\Omega_1$ 中 $k$ 个最近邻的单元。这确保了对于每个 $(i,j) \\in \\Omega_L$，其初始总质量都被计入：$\\sum_{(k,l) \\in \\Omega_1} \\delta m_{(i,j) \\to (k,l)} = m_{ij}^0$。\n\n最终总质量 $M_1$ 是所有最终海洋单元的总和：\n$$\nM_1 = \\sum_{(k,l) \\in \\Omega_1} m_{kl}^{\\mathrm{final}} = \\sum_{(k,l) \\in \\Omega_1} \\left( m_{kl}^0 + \\sum_{(i,j) \\in \\Omega_L} \\delta m_{(i,j) \\to (k,l)} \\right)\n$$\n通过交换求和顺序：\n$$\nM_1 = \\sum_{(k,l) \\in \\Omega_1} m_{kl}^0 + \\sum_{(i,j) \\in \\Omega_L} \\left( \\sum_{(k,l) \\in \\Omega_1} \\delta m_{(i,j) \\to (k,l)} \\right)\n$$\n使用重新分配规则，这简化为：\n$$\nM_1 = \\sum_{(k,l) \\in \\Omega_1} m_{kl}^0 + \\sum_{(i,j) \\in \\Omega_L} m_{ij}^0 = \\sum_{(i,j) \\in \\Omega_0} m_{ij}^0 = M_0\n$$\n这证明了指定的重新分配算法正确地守恒了整个域的总示踪剂质量。\n\n最后，浓度的更新规则 $C_{ij}^{\\mathrm{final}} = m_{ij}^{\\mathrm{final}} / V_{ij}^1$ 是浓度定义的直接应用。对于最终海洋域 $\\Omega_1$ 中的每个单元，其最终体积为 $V_{ij}^1 = A \\, h_{ij}'$，其最终质量为 $m_{ij}^{\\mathrm{final}}$。浓度是这两个广延性质的比值，确保了局部的物理一致性。\n\n### 算法设计\n\n实现遵循了从上述原理派生出的一系列明确定义的步骤。\n\n1.  **初始状态计算**：对于给定的初始深度 $h_{ij}$ 和浓度 $C_{ij}^0$ 的网格，以及单元面积 $A$，计算每个单元的初始体积 $V_{ij}^0 = A \\, h_{ij}$ 和质量 $m_{ij}^0 = C_{ij}^0 V_{ij}^0$。对所有湿润单元的初始总质量进行求和。\n\n2.  **候选海洋掩码**：计算变化后的水深 $h_{ij}' = \\max(h_{ij} - S, 0)$。所有满足 $h_{ij}' > 0$ 的单元构成 `candidate_ocean_mask`。\n\n3.  **连通性分析 (BFS #1)**：为了识别最终的、连通的海洋域，在网格上执行广度优先搜索（BFS）。\n    -   搜索从西边界（$j=0$）上所有定义了“开放海洋”的候选海洋单元开始。\n    -   BFS 探索所有面相邻的邻居，仅限于 `candidate_ocean_mask` 内的单元。\n    -   所有可从开放海洋边界到达的单元构成 `final_ocean_mask`。\n    -   此搜索未到达的候选海洋单元被归类为 `orphaned_cells`。记录这些单元的数量。\n\n4.  **质量重新分配 (BFS #2)**：必须重新分配所有变为陆地的单元（包括干涸和孤立的）的总质量。\n    -   最终质量网格 $m^{\\mathrm{final}}$ 通过复制 `final_ocean_mask` 中所有单元的初始质量 $m_{ij}^0$ 来初始化。\n    -   对于每个变为陆地的单元 $(i,j)$，从 $(i,j)$ 开始第二次逐层 BFS，以找到 `final_ocean_mask` 中最近的单元。\n    -   此 BFS 以递增距离的同心层方式探索网格。搜索在完成包含一个或多个 `final_ocean_mask` 单元的第一层后终止。该层代表最小路径距离。\n    -   识别出此最小距离处的所有最终海洋单元。如果存在 $k$ 个这样的单元，则将质量 $m_{ij}^0$ 除以 $k$，并将此数量加到这 $k$ 个单元中每个单元的最终质量上。\n\n5.  **最终计算与验证**：\n    -   对 `final_ocean_mask` 上的最终总质量进行求和。\n    -   计算相对质量守恒误差 $\\varepsilon = \\left| (\\sum m^{\\mathrm{final}} - \\sum m^0) / \\sum m^0 \\right|$。\n    -   对 `final_ocean_mask` 执行连通性检查以生成所需的布尔值输出。这是通过从 `final_ocean_mask` 内的单个边界单元开始新的遍历（BFS #3）并验证它是否到达 `final_ocean_mask` 中的所有其他单元来完成的。通过 BFS #1 的 `final_ocean_mask` 构造方式，此条件必须成立，这可作为内部一致性检查。如果最终海洋是附着于边界的单个连通分量，则结果为 `True`。\n\n为每个测试用例收集三个所需的输出（$\\varepsilon$、连通性布尔值、孤立单元计数）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        {\n            \"h\": np.array([\n                [200, 200, 150, 50],\n                [200, 100, 80, 20],\n                [200, 150, 90, 10],\n                [300, 250, 200, 100],\n            ]),\n            \"A\": 1e6,\n            \"S\": 80,\n            \"C0\": 35.0,\n        },\n        {\n            \"h\": np.array([\n                [300, 300, 300, 300, 300],\n                [300, 50, 50, 50, 300],\n                [300, 50, 200, 50, 300],\n                [300, 50, 50, 50, 300],\n                [300, 300, 300, 300, 300],\n            ]),\n            \"A\": 1e6,\n            \"S\": 120,\n            \"C0\": 35.0,\n        },\n        {\n            \"h\": np.array([\n                [100, 150, 120],\n                [130, 140, 110],\n                [90, 80, 70],\n            ]),\n            \"A\": 1e6,\n            \"S\": 0,\n            \"C0\": 35.0,\n        },\n        {\n            \"h\": np.array([\n                [300, 200, 100, 50, 20],\n                [400, 300, 200, 100, 80],\n                [350, 250, 150, 90, 60],\n            ]),\n            \"A\": 1e6,\n            \"S\": 90,\n            \"C0\": 35.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case[\"h\"], case[\"A\"], case[\"S\"], case[\"C0\"])\n        results.append(result)\n\n    # Format the output string exactly as requested\n    formatted_results = []\n    for res_list in results:\n        res_str = f\"[{res_list[0]},{res_list[1]},{res_list[2]}]\"\n        formatted_results.append(res_str)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef process_case(h, A, S, C0_scalar):\n    \"\"\"\n    Applies the coastal mask update algorithm for a single test case.\n    \"\"\"\n    N, M = h.shape\n    C0 = np.full_like(h, C0_scalar, dtype=float)\n\n    # Step 1: Initial state\n    initial_wet_mask = h > 0\n    m0 = C0 * (A * h)\n    total_initial_mass = np.sum(m0[initial_wet_mask])\n\n    # Step 2: Candidate ocean mask\n    h_prime = np.maximum(h - S, 0)\n    candidate_ocean_mask = h_prime > 0\n\n    # Step 3: Connectivity Analysis (BFS #1) to find final ocean mask\n    final_ocean_mask = np.zeros_like(h, dtype=bool)\n    queue = collections.deque()\n    for i in range(N):\n        if candidate_ocean_mask[i, 0]:\n            if not final_ocean_mask[i, 0]:\n                queue.append((i, 0))\n                final_ocean_mask[i, 0] = True\n    \n    head = 0\n    while head  len(queue):\n        i, j = queue[head]; head+=1\n        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ni, nj = i + di, j + dj\n            if 0 = ni  N and 0 = nj  M and \\\n               candidate_ocean_mask[ni, nj] and not final_ocean_mask[ni, nj]:\n                final_ocean_mask[ni, nj] = True\n                queue.append((ni, nj))\n\n    # Identify cells to be removed and count orphans\n    orphaned_mask = candidate_ocean_mask  ~final_ocean_mask\n    orphan_count = int(np.sum(orphaned_mask))\n    \n    # Dried cells are those that were initially wet but now have zero depth\n    dried_mask = (h > 0)  (h_prime == 0)\n    cells_to_redistribute_mask = dried_mask | orphaned_mask\n\n    # Step 4: Mass Redistribution\n    m_final = np.zeros_like(h, dtype=float)\n    m_final[final_ocean_mask] = m0[final_ocean_mask]\n\n    indices_to_redistribute = list(zip(*np.where(cells_to_redistribute_mask)))\n    \n    for i, j in indices_to_redistribute:\n        mass_to_add = m0[i, j]\n        if mass_to_add == 0:\n            continue\n\n        # Find nearest final ocean cells (BFS #2, level-by-level)\n        q_bfs2 = collections.deque([(i, j)])\n        visited_bfs2 = set([(i,j)])\n        nearest_cells = []\n        \n        found = False\n        if np.any(final_ocean_mask): # Only search if there's an ocean to redistribute to\n            while q_bfs2 and not found:\n                level_size = len(q_bfs2)\n                level_found_cells = []\n                for _ in range(level_size):\n                    r, c = q_bfs2.popleft()\n                    if final_ocean_mask[r, c]:\n                        level_found_cells.append((r, c))\n                    \n                    if not level_found_cells: # Don't expand if target found on this level\n                        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                            nr, nc = r + dr, c + dc\n                            if 0 = nr  N and 0 = nc  M and (nr, nc) not in visited_bfs2:\n                                visited_bfs2.add((nr, nc))\n                                q_bfs2.append((nr, nc))\n                \n                if level_found_cells:\n                    nearest_cells = level_found_cells\n                    found = True\n\n        if nearest_cells:\n            k = len(nearest_cells)\n            mass_per_cell = mass_to_add / k\n            for ni, nj in nearest_cells:\n                m_final[ni, nj] += mass_per_cell\n\n    # Step 5: Final computations\n    total_final_mass = np.sum(m_final[final_ocean_mask])\n    \n    if total_initial_mass == 0:\n        error = 0.0\n    else:\n        error = abs((total_final_mass - total_initial_mass) / total_initial_mass)\n\n    # Connectivity Check (BFS #3)\n    is_connected = True\n    num_final_ocean_cells = np.sum(final_ocean_mask)\n    if num_final_ocean_cells > 0:\n        q_check = collections.deque()\n        visited_check = np.zeros_like(h, dtype=bool)\n        \n        # Start traversal from one arbitrary boundary cell in the final mask\n        found_start = False\n        for i in range(N):\n            if final_ocean_mask[i,0]:\n                q_check.append((i,0))\n                visited_check[i,0] = True\n                found_start = True\n                break\n        \n        # If no boundary cells, but there are ocean cells, it's not connected to boundary\n        if not found_start:\n             is_connected = False\n        else:\n            count_visited = 0\n            while q_check:\n                r, c = q_check.popleft()\n                count_visited += 1\n                for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    nr, nc = r + dr, c + dc\n                    if 0 = nr  N and 0 = nc  M and \\\n                       final_ocean_mask[nr, nc] and not visited_check[nr, nc]:\n                        visited_check[nr, nc] = True\n                        q_check.append((nr, nc))\n            \n            if count_visited != num_final_ocean_cells:\n                is_connected = False\n\n    return [error, is_connected, orphan_count]\n\nsolve()\n```"
        }
    ]
}