{
    "hands_on_practices": [
        {
            "introduction": "我们实践的第一步是将大气阻塞的物理定义转化为具体的计算算法。本练习将指导您从头开始实现经典的大气阻塞指数之一——Tibaldi-Molteni (TM) 指数。通过处理一个合成但科学上一致的位势高度数据集，您将学习如何计算经向梯度、应用持续性准则，并最终生成阻塞频率的气候学分布，这些都是阻塞评估中的核心技能。",
            "id": "4013020",
            "problem": "给定一个北半球500百帕位势高度（Z500）的概念性每日数据集。缩写Z500代表500百帕位势高度。任务是使用一个合成但科学上一致的数据集，实现用于大气阻塞检测的 Tibaldi–Molteni (TM) 指数，并按经度和季节计算阻塞频率气候学。所有角度必须以度为单位处理，所有位势高度必须以米为单位处理。频率必须表示为小数分数。\n\n基本原理和定义：\n- 中纬度地区的大气阻塞与500百帕位势高度的经向梯度的反转有关，这意味着大尺度地转风的反转。根据地转平衡，纬向地转风 $u_g$ 近似正比于位势高度的经向梯度，即 $u_g \\propto -\\partial Z / \\partial \\phi$，其中 $\\phi$ 是纬度，$Z$ 是位势高度。因此，$\\partial Z / \\partial \\phi$ 在一个纬度带上的符号反转是阻塞的标志。\n- Tibaldi–Molteni (TM) 指数通过计算固定经度 $\\lambda$ 上三个纬度（南边纬度 $\\phi_S$、中心纬度 $\\phi_0$ 和北边纬度 $\\phi_N$）之间 $Z$ 的有限差分来检测阻塞。定义南梯度\n$$\n\\mathrm{GHGS}(\\lambda, t) = \\frac{Z(\\phi_0,\\lambda,t) - Z(\\phi_S,\\lambda,t)}{\\phi_0 - \\phi_S} \\quad \\text{[米/度]},\n$$\n和北梯度\n$$\n\\mathrm{GHGN}(\\lambda, t) = \\frac{Z(\\phi_N,\\lambda,t) - Z(\\phi_0,\\lambda,t)}{\\phi_N - \\phi_0} \\quad \\text{[米/度]}。\n$$\n如果 $\\mathrm{GHGS}(\\lambda, t) > 0$ 且 $\\mathrm{GHGN}(\\lambda, t)  -10$ [米/度]，则经度 $\\lambda$ 的日期 $t$ 被 TM 指数分类为阻塞，这些是 TM 指数中使用的标准阈值。\n- 持续性要求：仅当 TM 阻塞条件在某个经度上连续持续至少5天时，该经度才被认为是阻塞的。也就是说，如果上述 TM 条件连续满足 $L \\geq 5$ 天，则所有这 $L$ 天都被标记为阻塞；孤立的较短持续期将被忽略。\n- 按季节划分的阻塞频率气候学：对于每个季节 $S$ 和经度 $\\lambda$，定义阻塞频率\n$$\nf_S(\\lambda) = \\frac{B_S(\\lambda)}{N_S},\n$$\n其中 $B_S(\\lambda)$ 是在季节 $S$ 中，经度 $\\lambda$ 处满足持续性限定的 TM 阻塞条件的天数，$N_S$ 是季节 $S$ 的总天数。季节按日历月定义：北半球冬季十二月-一月-二月（DJF），春季三月-四月-五月（MAM），夏季六月-七月-八月（JJA），以及秋季九月-十月-十一月（SON）。使用一个平年，其一月至十二月的每月天数分别为 $\\{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\\}$，因此 $N_{\\mathrm{DJF}} = 90$, $N_{\\mathrm{MAM}} = 92$, $N_{\\mathrm{JJA}} = 92$, $N_{\\mathrm{SON}} = 91$。\n\n网格和数据规范：\n- 纬度网格：$\\phi \\in \\{20^\\circ, 22.5^\\circ, \\dots, 80^\\circ\\}$，间距为 $2.5^\\circ$。经度网格：$\\lambda \\in \\{0^\\circ, 2.5^\\circ, \\dots, 357.5^\\circ\\}$，间距为 $2.5^\\circ$。一个平年（365天）的每日时间轴。\n- TM 指数纬度：使用 $\\phi_S = 40^\\circ$, $\\phi_0 = 60^\\circ$, 和 $\\phi_N = 80^\\circ$。\n- 基底场：构建一个随纬度递减的纬向平均位势高度剖面，\n$$\nZ_0(\\phi) = Z_{\\mathrm{ref}} - \\alpha \\, \\phi,\n$$\n其中 $Z_{\\mathrm{ref}} = 5800$ [米]，$\\alpha = 6$ [米/度]。初始时，对所有 $\\lambda$ 和 $t$（无噪声），完整场由 $Z(\\phi,\\lambda,t) = Z_0(\\phi)$ 定义。这将在中纬度地区产生约为-6 [米/度]的背景经向梯度，与典型的中纬度（非阻塞）条件一致。\n\n用于定义测试套件的 TM 异常：\n您必须叠加局部异常来创建和测试阻塞检测。以下异常仅在指定的纬度、经度和日期范围内添加到 $Z(\\phi,\\lambda,t)$ 中，所有其他值保持不变。\n\n- 测试用例1（理想路径，DJF，强阻塞）：在经度 $\\lambda = 0^\\circ$，从1月15日到1月21日（含，即连续7天），在纬度 $\\phi_0 = 60^\\circ$ 处为 $Z(\\phi_0,\\lambda,t)$ 添加+300 [米]。无其他更改。预期效果：$\\mathrm{GHGS} > 0$ 且 $\\mathrm{GHGN} \\ll -10$ [米/度]。\n- 测试用例2（边界阈值情况，MAM，不应阻塞）：在经度 $\\lambda = 30^\\circ$，从4月10日到4月14日（含，即连续5天），在纬度 $\\phi_0 = 60^\\circ$ 处为 $Z(\\phi_0,\\lambda,t)$ 添加+80 [米]，在纬度 $\\phi_S = 40^\\circ$ 处为 $Z(\\phi_S,\\lambda,t)$ 添加-100 [米]。无其他更改。预期效果：$\\mathrm{GHGS} > 0$ 且 $\\mathrm{GHGN} = -10$ [米/度]，这不满足严格不等式 $\\mathrm{GHGN}  -10$，因此即使持续时间为5天，也不应记录为阻塞。\n- 测试用例3（非持续性情况，JJA，不应阻塞）：在经度 $\\lambda = 90^\\circ$，从7月5日到7月8日（含，即连续4天），在纬度 $\\phi_0 = 60^\\circ$ 处为 $Z(\\phi_0,\\lambda,t)$ 添加+300 [米]。无其他更改。预期效果：TM 条件满足，但持续性条件不满足，因为 $L = 4  5$，所以没有阻塞。\n- 测试用例4（持续性临界情况，SON，恰好5天，应阻塞）：在经度 $\\lambda = 180^\\circ$，从10月1日到10月5日（含，即连续5天），在纬度 $\\phi_0 = 60^\\circ$ 处为 $Z(\\phi_0,\\lambda,t)$ 添加+300 [米]。无其他更改。预期效果：TM 条件满足且恰好满足持续性阈值。\n\n计算要求：\n- 使用上述 $\\phi_S$、$\\phi_0$ 和 $\\phi_N$ 精确实现所述的 TM 指数条件，梯度单位理解为米/度。角度以度为单位处理。\n- 对每个经度独立应用至少连续5天的持续性规则。\n- 计算四个季节中每个季节的 $f_S(\\lambda)$。\n- 提取以下四个标量结果：\n  1. $f_{\\mathrm{DJF}}(0^\\circ)$，\n  2. $f_{\\mathrm{MAM}}(30^\\circ)$，\n  3. $f_{\\mathrm{JJA}}(90^\\circ)$，\n  4. $f_{\\mathrm{SON}}(180^\\circ)$。\n- 将每个频率表示为小数分数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，四个频率按上面列出的顺序排列。例如，格式的语法示例如下：\n$[x_1,x_2,x_3,x_4]$。",
            "solution": "用户的要求是实现 Tibaldi–Molteni (TM) 大气阻塞指数，应用持续性准则，并使用合成的位势高度数据集为一组指定的测试用例计算季节性阻塞频率。\n\n### 第1步：问题验证\n\n问题陈述为任务提供了全面且科学上合理的描述。\n\n- **已知条件**：\n    - **物理概念**：基于500 hPa位势高度（$Z$）的经向梯度，使用 Tibaldi–Molteni (TM) 指数进行大气阻塞检测。\n    - **TM 指数公式**：\n        - 南梯度：$\\mathrm{GHGS}(\\lambda, t) = \\frac{Z(\\phi_0,\\lambda,t) - Z(\\phi_S,\\lambda,t)}{\\phi_0 - \\phi_S}$。\n        - 北梯度：$\\mathrm{GHGN}(\\lambda, t) = \\frac{Z(\\phi_N,\\lambda,t) - Z(\\phi_0,\\lambda,t)}{\\phi_N - \\phi_0}$。\n    - **TM 阻塞条件**：$\\mathrm{GHGS}(\\lambda, t) > 0$ 且 $\\mathrm{GHGN}(\\lambda, t)  -10$ 米/度。\n    - **持续性**：条件必须持续至少连续5天。\n    - **频率计算**：$f_S(\\lambda) = B_S(\\lambda) / N_S$，其中 $B_S(\\lambda)$ 是阻塞天数，$N_S$ 是季节 $S$ 的总天数。\n    - **季节与年份**：DJF（$N_{\\mathrm{DJF}}=90$）、MAM（$N_{\\mathrm{MAM}}=92$）、JJA（$N_{\\mathrm{JJA}}=92$）、SON（$N_{\\mathrm{SON}}=91$），针对一个平年（365天）。\n    - **网格**：纬度 $\\phi \\in \\{20^\\circ, 22.5^\\circ, \\dots, 80^\\circ\\}$；经度 $\\lambda \\in \\{0^\\circ, 2.5^\\circ, \\dots, 357.5^\\circ\\}$；每日时间步长。\n    - **TM 纬度**：$\\phi_S = 40^\\circ, \\phi_0 = 60^\\circ, \\phi_N = 80^\\circ$。\n    - **基底场**：$Z_0(\\phi) = Z_{\\mathrm{ref}} - \\alpha \\, \\phi$，其中 $Z_{\\mathrm{ref}} = 5800$ 米，$\\alpha = 6$ 米/度。\n    - **测试用例**：定义了四个具有特定位置、时间和强度的异常。\n    - **要求输出**：四个特定的季节频率：$f_{\\mathrm{DJF}}(0^\\circ)$, $f_{\\mathrm{MAM}}(30^\\circ)$, $f_{\\mathrm{JJA}}(90^\\circ)$, $f_{\\mathrm{SON}}(180^\\circ)$。\n\n- **验证结论**：\n    - 问题具有**科学依据**，基于一种标准的气象指数。其物理前提和参数值是现实的。\n    - 问题是**适定的**，提供了所有必要的数据、公式和约束，以得出一个唯一的、确定性的解。\n    - 语言**客观而精确**。\n    - 设置是**完整且一致的**。不存在矛盾或含糊之处。\n\n该问题被视为**有效**。我们继续进行求解。\n\n### 第2步：算法设计与计算\n\n解决方案遵循一种结构化的、基于原则的方法。\n\n**2.1. 网格和数据结构初始化**\n首先，我们建立计算域。我们为时间、纬度和经度创建网格。时间网格从日期索引 $0$ 到 $364$。空间网格由其起始值、结束值和步长定义。\n- 纬度网格 $\\phi$：从 $20^\\circ$ 到 $80^\\circ$，步长为 $2.5^\\circ$。\n- 经度网格 $\\lambda$：从 $0^\\circ$ 到 $357.5^\\circ$，步长为 $2.5^\\circ$。\n\n位势高度场 $Z$ 是一个大小为（时间，纬度，经度）的三维数组。我们用纬向平均基态 $Z(\\phi,\\lambda,t) = Z_0(\\phi) = 5800 - 6\\phi$ 来初始化该场。这是通过创建一个一维的纬度相关剖面，并将其广播到时间和经度维度来实现的。\n\n**2.2. 应用测试用例异常**\n将四个指定的测试用例叠加到基底场上。这需要将日历日期映射到年积日索引，并将空间坐标映射到网格索引。设 $t_{idx}$、$\\phi_{idx}$ 和 $\\lambda_{idx}$ 分别为日期、纬度和经度的索引。\n\n- **年积日映射**：日期索引从 $0$（1月1日）到 $364$（12月31日）。\n    - 用例1：1月15-21日对应于日期索引 $14$ 到 $20$。\n    - 用例2：4月10-14日对应于日期索引 $99$ 到 $103$。\n    - 用例3：7月5-8日对应于日期索引 $185$ 到 $188$。\n    - 用例4：10月1-5日对应于日期索引 $273$ 到 $277$。\n\n- **网格索引**：我们找到对应所需纬度（$\\phi_S=40^\\circ, \\phi_0=60^\\circ, \\phi_N=80^\\circ$）和经度（$\\lambda = 0^\\circ, 30^\\circ, 90^\\circ, 180^\\circ$）的数组索引。\n\n- **异常叠加**：对于每个测试用例，将指定的位势高度异常添加到 $Z$ 数组的相应切片上。\n\n**2.3. 计算 TM 梯度**\nTM 指数的核心在于两个经向位势高度梯度，$\\mathrm{GHGS}$ 和 $\\mathrm{GHGN}$。\n我们提取三个关键纬度上的时间-经度数据切片：$Z_S(t, \\lambda) = Z(\\phi_S, t, \\lambda)$，$Z_0(t, \\lambda) = Z(\\phi_0, t, \\lambda)$ 和 $Z_N(t, \\lambda) = Z(\\phi_N, t, \\lambda)$。\n\n然后使用矢量化操作同时为所有经度和日期计算梯度：\n$$\n\\mathrm{GHGS} = \\frac{Z_0 - Z_S}{\\phi_0 - \\phi_S} = \\frac{Z_0 - Z_S}{20}\n$$\n$$\n\\mathrm{GHGN} = \\frac{Z_N - Z_0}{\\phi_N - \\phi_0} = \\frac{Z_N - Z_0}{20}\n$$\n结果是两个二维数组，$\\mathrm{GHGS}(t, \\lambda)$ 和 $\\mathrm{GHGN}(t, \\lambda)$。\n\n**2.4. 瞬时阻塞检测**\n通过应用 TM 指数条件，创建一个形状为（时间，经度）的布尔掩码 `is_blocked_instantaneous`：\n$$\n\\text{is\\_blocked\\_instantaneous}(t, \\lambda) = (\\mathrm{GHGS}(t, \\lambda) > 0) \\land (\\mathrm{GHGN}(t, \\lambda)  -10)\n$$\n\n**2.5. 应用持续性准则**\n为了满足持续性要求，一个经度必须瞬时阻塞达到 $L \\ge 5$ 个连续天。我们逐个经度处理 `is_blocked_instantaneous` 掩码。对于每个经度的时间序列，我们识别出连续的 `True` 值块。如果一个块的长度为5天或更长，则该块内的所有天都在一个新的布尔掩码 `is_blocked_persistent` 中被标记为持续性阻塞。这可以通过使用 `scipy.ndimage.label` 来识别连续块，并使用 `scipy.ndimage.sum_labels` 来找到它们的长度来高效实现。\n\n**2.6. 测试用例的手动验证**\n让我们根据我们的算法验证每个用例的结果。基态梯度为 $\\mathrm{GHGS} = \\mathrm{GHGN} = -6$ 米/度。\n\n- **用例1**：$\\lambda = 0^\\circ$，日期14-20（7天）。异常：$\\Delta Z(\\phi_0) = +300$ 米。\n    - $\\mathrm{GHGS} = ( (5440+300) - 5560 ) / 20 = 180/20 = 9 > 0$。\n    - $\\mathrm{GHGN} = ( 5320 - (5440+300) ) / 20 = -420/20 = -21  -10$。\n    - 该条件持续7天。由于 $7 \\ge 5$，所有7天都为持续性阻塞。这些天属于DJF季节。\n    - $B_{\\mathrm{DJF}}(0^\\circ) = 7$，所以 $f_{\\mathrm{DJF}}(0^\\circ) = 7 / 90$。\n\n- **用例2**：$\\lambda = 30^\\circ$，日期99-103（5天）。异常：$\\Delta Z(\\phi_0) = +80$ 米，$\\Delta Z(\\phi_S) = -100$ 米。\n    - $\\mathrm{GHGS} = ( (5440+80) - (5560-100) ) / 20 = 60/20 = 3 > 0$。\n    - $\\mathrm{GHGN} = ( 5320 - (5440+80) ) / 20 = -200/20 = -10$。\n    - 条件 $\\mathrm{GHGN}  -10$ 未满足。没有瞬时阻塞的天。\n    - $B_{\\mathrm{MAM}}(30^\\circ) = 0$，所以 $f_{\\mathrm{MAM}}(30^\\circ) = 0 / 92 = 0$。\n\n- **用例3**：$\\lambda = 90^\\circ$，日期185-188（4天）。异常：$\\Delta Z(\\phi_0) = +300$ 米。\n    - 如同用例1，瞬时条件满足。\n    - 持续时间为4天。由于 $4  5$，不满足持续性准则。\n    - $B_{\\mathrm{JJA}}(90^\\circ) = 0$，所以 $f_{\\mathrm{JJA}}(90^\\circ) = 0 / 92 = 0$。\n\n- **用例4**：$\\lambda = 180^\\circ$，日期273-277（5天）。异常：$\\Delta Z(\\phi_0) = +300$ 米。\n    - 瞬时条件满足。\n    - 持续时间为5天。由于 $5 \\ge 5$，满足持续性准则。所有5天都为持续性阻塞。这些天属于SON季节。\n    - $B_{\\mathrm{SON}}(180^\\circ) = 5$，所以 $f_{\\mathrm{SON}}(180^\\circ) = 5 / 91$。\n\n**2.7. 最终频率计算**\n最后一步是通过计算 `is_blocked_persistent` 掩码在适当的季节性日期范围和指定经度内的 `True` 值的数量，然后除以该季节的总天数，来计算所需的频率。\n- 季节性日期索引：\n    - DJF：第 $0-58$ 天（一月、二月）和第 $334-364$ 天（十二月）。\n    - MAM：第 $59-150$ 天。\n    - JJA：第 $151-242$ 天。\n    - SON：第 $243-333$ 天。\n- 最终结果：\n    1. $f_{\\mathrm{DJF}}(0^\\circ) = 7/90$。\n    2. $f_{\\mathrm{MAM}}(30^\\circ) = 0.0$。\n    3. $f_{\\mathrm{JJA}}(90^\\circ) = 0.0$。\n    4. $f_{\\mathrm{SON}}(180^\\circ) = 5/91$。\n然后将这些值计算为浮点数并按要求格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import ndimage\n\ndef solve():\n    \"\"\"\n    Implements the Tibaldi-Molteni blocking index and calculates seasonal blocking frequencies.\n    \"\"\"\n    # 1. Foundational base and definitions\n    Z_REF = 5800.0  # meters\n    ALPHA = 6.0  # m per degree\n    PHI_S, PHI_0, PHI_N = 40.0, 60.0, 80.0  # degrees\n    GHGN_THRESHOLD = -10.0  # m per degree\n    PERSISTENCE_DAYS = 5\n    \n    # Seasonal day counts\n    N_DAYS_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    N_DAYS_YEAR = sum(N_DAYS_MONTH)\n    N_DJF, N_MAM, N_JJA, N_SON = 90, 92, 92, 91\n\n    # 2. Grid and data specification\n    lat_grid = np.arange(20.0, 80.1, 2.5)\n    lon_grid = np.arange(0.0, 357.6, 2.5)\n    time_grid = np.arange(N_DAYS_YEAR)\n\n    n_time, n_lat, n_lon = len(time_grid), len(lat_grid), len(lon_grid)\n\n    # 3. Construct the base Z500 field\n    z500 = np.zeros((n_time, n_lat, n_lon))\n    z0_profile = Z_REF - ALPHA * lat_grid\n    z500[:, :, :] = z0_profile[np.newaxis, :, np.newaxis]\n\n    # Helper to find grid indices\n    def get_idx(grid, value):\n        return np.where(grid == value)[0][0]\n\n    lat_idx_S = get_idx(lat_grid, PHI_S)\n    lat_idx_0 = get_idx(lat_grid, PHI_0)\n    lat_idx_N = get_idx(lat_grid, PHI_N)\n\n    # 4. Apply test case anomalies\n    cum_days = np.cumsum([0] + N_DAYS_MONTH[:-1])\n\n    # Case 1: DJF, strong blocking\n    lon_idx_1 = get_idx(lon_grid, 0.0)\n    day_start_1 = cum_days[0] + 15 - 1\n    day_end_1 = cum_days[0] + 21 - 1\n    z500[day_start_1 : day_end_1 + 1, lat_idx_0, lon_idx_1] += 300.0\n\n    # Case 2: MAM, boundary threshold\n    lon_idx_2 = get_idx(lon_grid, 30.0)\n    day_start_2 = cum_days[3] + 10 - 1\n    day_end_2 = cum_days[3] + 14 - 1\n    z500[day_start_2 : day_end_2 + 1, lat_idx_0, lon_idx_2] += 80.0\n    z500[day_start_2 : day_end_2 + 1, lat_idx_S, lon_idx_2] -= 100.0\n\n    # Case 3: JJA, non-persistence\n    lon_idx_3 = get_idx(lon_grid, 90.0)\n    day_start_3 = cum_days[6] + 5 - 1\n    day_end_3 = cum_days[6] + 8 - 1\n    z500[day_start_3 : day_end_3 + 1, lat_idx_0, lon_idx_3] += 300.0\n\n    # Case 4: SON, persistence edge\n    lon_idx_4 = get_idx(lon_grid, 180.0)\n    day_start_4 = cum_days[9] + 1 - 1\n    day_end_4 = cum_days[9] + 5 - 1\n    z500[day_start_4 : day_end_4 + 1, lat_idx_0, lon_idx_4] += 300.0\n\n    # 5. Compute TM gradients and instantaneous blocking\n    z_S = z500[:, lat_idx_S, :]\n    z_0 = z500[:, lat_idx_0, :]\n    z_N = z500[:, lat_idx_N, :]\n    \n    ghgs = (z_0 - z_S) / (PHI_0 - PHI_S)\n    ghgn = (z_N - z_0) / (PHI_N - PHI_0)\n\n    is_blocked_instantaneous = (ghgs > 0)  (ghgn  GHGN_THRESHOLD)\n\n    # 6. Apply persistence requirement\n    is_blocked_persistent = np.full_like(is_blocked_instantaneous, False, dtype=bool)\n\n    for j in range(n_lon):\n        # Identify contiguous runs of True\n        labeled_array, num_features = ndimage.label(is_blocked_instantaneous[:, j])\n        if num_features > 0:\n            # Find the length of each run\n            run_indices = np.arange(1, num_features + 1)\n            run_lengths = ndimage.sum_labels(is_blocked_instantaneous[:, j], labeled_array, index=run_indices)\n            \n            # Find runs that meet the persistence criterion\n            persistent_runs = run_indices[run_lengths >= PERSISTENCE_DAYS]\n            \n            if persistent_runs.size > 0:\n                # Mark all days in those runs as persistently blocked\n                mask = np.isin(labeled_array, persistent_runs)\n                is_blocked_persistent[:, j] = mask\n\n    # 7. Compute seasonal frequencies for the required longitudes\n    # Seasonal day index ranges\n    # DJF: Jan, Feb, Dec\n    day_idx_jan_end = cum_days[1]\n    day_idx_feb_end = cum_days[2]\n    day_idx_dec_start = cum_days[11]\n    \n    # MAM: Mar, Apr, May\n    day_idx_mar_start = cum_days[2]\n    day_idx_may_end = cum_days[5]\n\n    # JJA: Jun, Jul, Aug\n    day_idx_jun_start = cum_days[5]\n    day_idx_aug_end = cum_days[8]\n    \n    # SON: Sep, Oct, Nov\n    day_idx_sep_start = cum_days[8]\n    day_idx_nov_end = cum_days[11]\n\n    # Result 1: f_DJF(0°)\n    blocked_days_djf_1 = np.sum(is_blocked_persistent[0:day_idx_feb_end, lon_idx_1])\n    blocked_days_djf_2 = np.sum(is_blocked_persistent[day_idx_dec_start:, lon_idx_1])\n    f_djf = (blocked_days_djf_1 + blocked_days_djf_2) / N_DJF\n    \n    # Result 2: f_MAM(30°)\n    blocked_days_mam = np.sum(is_blocked_persistent[day_idx_mar_start:day_idx_may_end, lon_idx_2])\n    f_mam = blocked_days_mam / N_MAM\n\n    # Result 3: f_JJA(90°)\n    blocked_days_jja = np.sum(is_blocked_persistent[day_idx_jun_start:day_idx_aug_end, lon_idx_3])\n    f_jja = blocked_days_jja / N_JJA\n\n    # Result 4: f_SON(180°)\n    blocked_days_son = np.sum(is_blocked_persistent[day_idx_sep_start:day_idx_nov_end, lon_idx_4])\n    f_son = blocked_days_son / N_SON\n\n    results = [f_djf, f_mam, f_jja, f_son]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "任何诊断指数的性能都对其定义中的阈值选择非常敏感。在实现了阻塞指数之后，下一步关键是量化这种敏感性。本练习将引导您通过参数扫描，系统地评估Tibaldi-Molteni (TM) 指数在不同阈值组合下的表现，并引入接收者操作特征 (ROC) 曲线这一强大的统计工具来评估其在识别真实事件和避免虚假警报之间的权衡。",
            "id": "4013005",
            "problem": "您的任务是评估 Tibaldi–Molteni 方法中检测到的大气阻塞对阈值选择的敏感性，具体方法是使用参数扫描并根据独立定义的手动阻塞目录计算受试者工作特征 (ROC) 曲线。目标是在一个受控的合成环境中构建一个完全指定的数值实验，从基本动力学原理出发，直至得到可量化的检测指标。\n\n从恒压面上大尺度中纬度流动的地转平衡开始，其中地转风与位势高度的梯度相关。设 $Z(\\phi,\\lambda,t)$ 表示 500 百帕的位势高度，是纬度 $\\phi$（单位：度）、经度 $\\lambda$（单位：度）和时间 $t$（单位：天）的函数。在地转平衡条件下，给定纬度的纬向地转风 $u_g$ 满足\n$$\nu_g = -\\frac{g}{f}\\frac{\\partial Z}{\\partial y},\n$$\n其中 $g$ 是重力加速度，$f$ 是科里奥利参数。北纬 $60^\\circ$ 以北的 $Z$ 的经向梯度反转表明 $u_g$ 的反转，这是大气阻塞的一个标志。Tibaldi–Molteni 方法通过跨纬度带的 $Z$ 的有限差分将此操作化。对于以北纬 $60^\\circ$ 为中心的纬度带，定义经向有限差分代理\n$$\nG_N(\\lambda,t) = \\frac{Z(60^\\circ\\mathrm{N},\\lambda,t) - Z(80^\\circ\\mathrm{N},\\lambda,t)}{20^\\circ}, \\quad\nG_S(\\lambda,t) = \\frac{Z(40^\\circ\\mathrm{N},\\lambda,t) - Z(60^\\circ\\mathrm{N},\\lambda,t)}{20^\\circ},\n$$\n其中 $20^\\circ$ 是纬度间隔。在时间 $t$ 的一个经度 $\\lambda$ 被分类为阻塞，如果同时存在北部梯度反转和足够的南部西风流，表示为\n$$\nG_N(\\lambda,t) \\le -T_N, \\quad G_S(\\lambda,t) \\ge T_S,\n$$\n其中 $T_N \\ge 0$ 和 $T_S \\ge 0$ 是阈值（单位：$\\mathrm{m\\,deg^{-1}}$）。如果满足两个不等式的经度比例等于或超过规定的比例 $q$，则一天 $t$ 被分类为阻塞，即\n$$\n\\frac{1}{L}\\sum_{\\lambda} \\mathbb{I}\\left(G_N(\\lambda,t) \\le -T_N \\ \\wedge \\ G_S(\\lambda,t) \\ge T_S\\right) \\ge q,\n$$\n其中 $L$ 是经度数，$\\mathbb{I}$ 是指示函数。\n\n在纬度 $\\phi \\in \\{40^\\circ\\mathrm{N},60^\\circ\\mathrm{N},80^\\circ\\mathrm{N}\\}$ 上，构建一组跨越 $L=36$ 个经度和 $D=100$ 天的合成但科学上合理的 500 百帕位势高度场。使用一个向极地递减的纬向均匀基态，并叠加一个局部的行星尺度异常，该异常在北纬 $60^\\circ$ 以北产生间歇性的梯度反转。具体来说：\n\n- 设基态为\n$$\nZ_{\\text{base}}(\\phi) = 5800\\,\\mathrm{m} - 10\\,\\mathrm{m\\,deg^{-1}}\\times(\\phi - 40^\\circ).\n$$\n- 设异常为\n$$\nA(\\phi,\\lambda,t) = \\alpha(\\phi)\\,a(t)\\,\\max\\left[\\cos\\left(k\\,\\lambda\\right),\\,0\\right],\n$$\n其中 $k=2$，纬度权重为 $\\alpha(40^\\circ)=100\\,\\mathrm{m}$，$\\alpha(60^\\circ)=-200\\,\\mathrm{m}$，$\\alpha(80^\\circ)=400\\,\\mathrm{m}$。振幅 $a(t)$ 仅在三个阻塞事件期间非零，即 $t\\in\\{20,21,22,23,24\\}$，$t\\in\\{50,51,52,53,54\\}$ 和 $t\\in\\{75,76,77,78,79\\}$，其值 $a(t)$ 分别设为 $[0.2,0.4,0.6,0.4,0.2]$，$[0.3,0.6,0.9,0.6,0.3]$ 和 $[0.1,0.2,0.3,0.2,0.1]$。在这些事件之外，$a(t)=0$。\n- 完整的 $Z$ 场为\n$$\nZ(\\phi,\\lambda,t) = Z_{\\text{base}}(\\phi) + A(\\phi,\\lambda,t).\n$$\n\n根据这些 $Z(\\phi,\\lambda,t)$ 场，计算 $G_N(\\lambda,t)$ 和 $G_S(\\lambda,t)$，单位为 $\\mathrm{m\\,deg^{-1}}$。通过对相同的梯度应用固定但更严格的标准来定义一个独立的手动阻塞目录：如果满足以下条件，则一天 $t$ 被手动标记为阻塞\n$$\n\\frac{1}{L}\\sum_{\\lambda} \\mathbb{I}\\left(G_N(\\lambda,t) \\le -T_N^{\\mathrm{man}} \\ \\wedge \\ G_S(\\lambda,t) \\ge T_S^{\\mathrm{man}}\\right) \\ge q_{\\mathrm{man}},\n$$\n其中 $T_N^{\\mathrm{man}}=5\\,\\mathrm{m\\,deg^{-1}}$，$T_S^{\\mathrm{man}}=10\\,\\mathrm{m\\,deg^{-1}}$，$q_{\\mathrm{man}}=0.4$。操作性检测将使用相同的经度比例方法，其中 $q=0.3$，但阈值 $(T_N,T_S)$ 在一个网格上变化。\n\n针对一个阈值参数扫描，计算相对于手动目录的真阳性率和假阳性率：\n- $T_N \\in \\{0,5,10,15,20,25,30\\}$，单位为 $\\mathrm{m\\,deg^{-1}}$，\n- $T_S \\in \\{5,10,12,15,20,25\\}$，单位为 $\\mathrm{m\\,deg^{-1}}$。\n对于每对 $(T_N,T_S)$，计算\n$$\n\\mathrm{TPR} = \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}}, \\quad \\mathrm{FPR} = \\frac{\\mathrm{FP}}{\\mathrm{FP}+\\mathrm{TN}},\n$$\n其中 $\\mathrm{TP}$、$\\mathrm{FP}$、$\\mathrm{TN}$ 和 $\\mathrm{FN}$ 是 $D$ 天内的标准混淆矩阵计数。使用这些 $(\\mathrm{FPR},\\mathrm{TPR})$ 点，沿递增的 $\\mathrm{FPR}$ 轴使用梯形法则计算 ROC 的曲线下面积 (AUC)。为确保覆盖范围从 0 到 1，用平凡分类器点 $(0,0)$ 和 $(1,1)$ 扩充该集合；当多个点共享相同的 $\\mathrm{FPR}$ 时，保留具有最大 $\\mathrm{TPR}$ 的点。\n\n必须小心处理物理单位：\n- 位势高度以米 ($\\mathrm{m}$) 表示。\n- 经向梯度以米每纬度 ($\\mathrm{m\\,deg^{-1}}$) 表示。\n- 异常定义中的角度必须以度为单位。\n\n您的程序必须实现以上内容，并为了验证，报告以下测试套件结果：\n- 将整个扫描网格上的 ROC AUC 计算为单个浮点数。\n- 计算五个指定阈值对的 $\\mathrm{TPR}$ 和 $\\mathrm{FPR}$：\n  1. $(T_N,T_S) = (0,5)$,\n  2. $(T_N,T_S) = (5,10)$,\n  3. $(T_N,T_S) = (10,10)$,\n  4. $(T_N,T_S) = (15,12)$,\n  5. $(T_N,T_S) = (25,20)$,\n所有阈值的单位均为 $\\mathrm{m\\,deg^{-1}}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序完全如下：\n$$\n[\\mathrm{AUC}, \\mathrm{TPR}_{(0,5)}, \\mathrm{FPR}_{(0,5)}, \\mathrm{TPR}_{(5,10)}, \\mathrm{FPR}_{(5,10)}, \\mathrm{TPR}_{(10,10)}, \\mathrm{FPR}_{(10,10)}, \\mathrm{TPR}_{(15,12)}, \\mathrm{FPR}_{(15,12)}, \\mathrm{TPR}_{(25,20)}, \\mathrm{FPR}_{(25,20)}].\n$$\n所有数值输出必须是没有任何百分号的纯小数。最终输出中没有单位，因为这些指标是无量纲的。代码必须是完全自包含的，不接受任何输入，并且确定性地运行。",
            "solution": "问题陈述经评估有效。它在科学上基于大气动力学原理（地转平衡），采用了既定的诊断方法（Tibaldi–Molteni 指数），并提出了一个定义明确、确定性的数值实验。该设置是自包含的，所有必要的参数、方程和程序都已清晰定义，用于构建合成数据集和使用标准度量（ROC分析）评估检测算法的性能。该问题是客观的，没有矛盾或歧义。\n\n解决方案通过逐步实现指定的数值实验来进行。\n\n**第 1 步：生成合成位势高度数据**\n\n问题的核心是生成一个在离散网格上的合成 500 百帕（$500\\,\\mathrm{hPa}$）位势高度场 $Z(\\phi,\\lambda,t)$。该网格包括 $D=100$ 天，$L=36$ 个经度，以及 3 个指定的纬度。\n- 纬度：$\\phi \\in \\{40^\\circ\\mathrm{N}, 60^\\circ\\mathrm{N}, 80^\\circ\\mathrm{N}\\}$。\n- 经度：假设一个由 $L=36$ 个点组成的规则网格，间距为 $10^\\circ$。我们将其定义为 $\\lambda \\in \\{0^\\circ, 10^\\circ, \\dots, 350^\\circ\\}$。\n- 时间：$t \\in \\{0, 1, \\dots, 99\\}$ 代表 $D=100$ 天。\n\n场 $Z(\\phi,\\lambda,t)$ 是一个基态 $Z_{\\text{base}}(\\phi)$ 和一个时空变化的异常 $A(\\phi,\\lambda,t)$ 的和。\n\n基态 $Z_{\\text{base}}(\\phi)$ 是一个仅依赖于纬度的纬向均匀场：\n$$\nZ_{\\text{base}}(\\phi) = 5800\\,\\mathrm{m} - 10\\,\\mathrm{m\\,deg^{-1}}\\times(\\phi - 40^\\circ)\n$$\n对于指定的纬度，这得出：\n- $Z_{\\text{base}}(40^\\circ\\mathrm{N}) = 5800\\,\\mathrm{m}$\n- $Z_{\\text{base}}(60^\\circ\\mathrm{N}) = 5800 - 10 \\times (60-40) = 5600\\,\\mathrm{m}$\n- $Z_{\\text{base}}(80^\\circ\\mathrm{N}) = 5800 - 10 \\times (80-40) = 5400\\,\\mathrm{m}$\n\n异常 $A(\\phi,\\lambda,t)$ 引入了一个局部的、波状的扰动：\n$$\nA(\\phi,\\lambda,t) = \\alpha(\\phi)\\,a(t)\\,\\max\\left[\\cos\\left(k\\,\\lambda\\right),\\,0\\right]\n$$\n参数如下：\n- 波数 $k=2$。\n- 依赖于纬度的权重：$\\alpha(40^\\circ)=100\\,\\mathrm{m}$，$\\alpha(60^\\circ)=-200\\,\\mathrm{m}$，$\\alpha(80^\\circ)=400\\,\\mathrm{m}$。\n- 依赖于时间的振幅 $a(t)$：它仅在三个事件期间非零。\n  - 对于 $t \\in \\{20, \\dots, 24\\}$: $a(t) = [0.2, 0.4, 0.6, 0.4, 0.2]$\n  - 对于 $t \\in \\{50, \\dots, 54\\}$: $a(t) = [0.3, 0.6, 0.9, 0.6, 0.3]$\n  - 对于 $t \\in \\{75, \\dots, 79\\}$: $a(t) = [0.1, 0.2, 0.3, 0.2, 0.1]$\n  - 否则，$a(t)=0$。\n角度 $\\lambda$ 以度为单位；余弦的数值计算需要转换为弧度。`max` 函数确保异常是正定的，代表一个高压脊。\n\n完整的场是 $Z(\\phi,\\lambda,t) = Z_{\\text{base}}(\\phi) + A(\\phi,\\lambda,t)$。这将作为一个形状为 $(3, 36, 100)$ 的 3 维 NumPy 数组来实现，分别对应纬度、经度和时间。\n\n**第 2 步：计算经向梯度代理**\n\nTibaldi–Molteni 指数基于经向位势高度梯度的有限差分近似。我们为每个经度 $\\lambda$ 和时间 $t$ 计算北部梯度 $G_N$ 和南部梯度 $G_S$：\n$$\nG_N(\\lambda,t) = \\frac{Z(60^\\circ\\mathrm{N},\\lambda,t) - Z(80^\\circ\\mathrm{N},\\lambda,t)}{20^\\circ}\n$$\n$$\nG_S(\\lambda,t) = \\frac{Z(40^\\circ\\mathrm{N},\\lambda,t) - Z(60^\\circ\\mathrm{N},\\lambda,t)}{20^\\circ}\n$$\n单位被正确地给出为 $\\mathrm{m\\,deg^{-1}}$。这些将被计算为两个形状为 $(36, 100)$ 的 2 维 NumPy 数组。\n\n**第 3 步：为手动和操作目录进行日期分类**\n\n如果一天 $t$ 中有足够比例的经度被阻塞，则该天被分类为阻塞。一个经度 $\\lambda$ 在 $G_N(\\lambda,t) \\le -T_N$ 和 $G_S(\\lambda,t) \\ge T_S$ 时被阻塞。\n\n一天 $t$ 的分类使用指示函数 $\\mathbb{I}$ 进行：\n$$\n\\text{is_blocked}(t) = \\left[ \\frac{1}{L}\\sum_{\\lambda=1}^{L} \\mathbb{I}\\left(G_N(\\lambda,t) \\le -T_N \\ \\wedge \\ G_S(\\lambda,t) \\ge T_S\\right) \\ge q \\right]\n$$\n\n我们生成两个目录（长度为 $D=100$ 的布尔数组）：\n1.  **手动目录（地面实况）：** 使用固定的、严格的标准：$T_N^{\\mathrm{man}}=5\\,\\mathrm{m\\,deg^{-1}}$，$T_S^{\\mathrm{man}}=10\\,\\mathrm{m\\,deg^{-1}}$，和 $q_{\\mathrm{man}}=0.4$。此目录作为“真实”分类，用于测试操作方法的性能。\n2.  **操作目录：** 使用固定的经度比例 $q=0.3$，但在指定的网格上变化阈值 $(T_N, T_S)$。\n    - $T_N \\in \\{0,5,10,15,20,25,30\\}\\,\\mathrm{m\\,deg^{-1}}$\n    - $T_S \\in \\{5,10,12,15,20,25\\}\\,\\mathrm{m\\,deg^{-1}}$\n\n**第 4 步：ROC 曲线构建和度量计算**\n\n对于每对操作阈值 $(T_N, T_S)$，我们为所有 100 天生成一个分类，并将其与手动目录进行比较以构建一个混淆矩阵：\n- **真阳性 (TP):** 在操作和手动目录中都被阻塞的天数。\n- **假阳性 (FP):** 在操作目录中被阻塞但在手动目录中未被阻塞的天数。\n- **真阴性 (TN):** 在两个目录中都未被阻塞的天数。\n- **假阴性 (FN):** 在操作目录中未被阻塞但在手动目录中被阻塞的天数。\n\n从这些计数中，计算真阳性率 (TPR) 和假阳性率 (FPR)：\n$$\n\\mathrm{TPR} = \\frac{\\mathrm{TP}}{\\mathrm{P}} = \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}}, \\quad \\mathrm{FPR} = \\frac{\\mathrm{FP}}{\\mathrm{N}} = \\frac{\\mathrm{FP}}{\\mathrm{FP}+\\mathrm{TN}}\n$$\n其中 $\\mathrm{P}$ 是手动目录中的总阳性数（阻塞天数），$\\mathrm{N}$ 是总阴性数（非阻塞天数）。如果分母为零，则相应的比率取为零。\n\n从参数扫描中收集的 $(\\mathrm{FPR}, \\mathrm{TPR})$ 对集合构成了受试者工作特征 (ROC) 曲线的基础。\n\n**第 5 步：曲线下面积 (AUC) 计算**\n\n为了计算 AUC，对计算出的 $(\\mathrm{FPR}, \\mathrm{TPR})$ 点集进行如下处理：\n1.  **增补：** 用平凡点 $(0,0)$（从不分类为阳性）和 $(1,1)$（总是分类为阳性）来扩充该集合，以确保曲线跨越整个单位正方形。\n2.  **唯一性：** 对于任何共享相同 $\\mathrm{FPR}$ 值的点集，只保留具有最大 $\\mathrm{TPR}$ 的点。这确保了 ROC 曲线是一个单调非递减函数。\n3.  **排序：** 将得到的唯一点按其 $\\mathrm{FPR}$ 值的升序排序。\n4.  **积分：** 通过对排序后的点应用梯形法则来计算曲线下面积 (AUC)。这可以很容易地使用 `numpy.trapz` 来完成。\n\n最后，将计算出的 AUC 和五个要求的阈值对的特定 $(\\mathrm{TPR}, \\mathrm{FPR})$ 值收集起来，并格式化为所需的输出字符串。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a numerical experiment to assess atmospheric blocking detection sensitivity.\n    \"\"\"\n    # === Step 0: Define constants and grids ===\n    D = 100  # Number of days\n    L = 36   # Number of longitudes\n    \n    # Define spatial and temporal grids\n    t_vals = np.arange(D)\n    phi_vals = np.array([40, 60, 80])\n    lambda_vals = np.arange(0, 360, 10) # 0, 10, ..., 350\n\n    # === Step 1: Generate Synthetic Geopotential Height Data ===\n    \n    # Base state Z_base(phi)\n    Z_base = 5800 - 10 * (phi_vals - 40)\n\n    # Anomaly field A(phi, lambda, t)\n    # Time-dependent amplitude a(t)\n    a_t = np.zeros(D)\n    blocking_episodes = {\n        (20, 25): [0.2, 0.4, 0.6, 0.4, 0.2],\n        (50, 55): [0.3, 0.6, 0.9, 0.6, 0.3],\n        (75, 80): [0.1, 0.2, 0.3, 0.2, 0.1]\n    }\n    for (start, end), values in blocking_episodes.items():\n        a_t[start:end] = values\n\n    # Latitude weights alpha(phi)\n    alpha_vals = np.array([100, -200, 400])\n\n    # Wavenumber k\n    k = 2\n\n    # Assemble the full field Z = Z_base + A\n    # Reshape arrays for broadcasting: (phi, lambda, time)\n    Z_base_3d = Z_base.reshape(3, 1, 1)\n    alpha_3d = alpha_vals.reshape(3, 1, 1)\n    a_t_3d = a_t.reshape(1, 1, D)\n    \n    # Convert lambda from degrees to radians for numpy's cos function\n    lambda_rad = np.deg2rad(lambda_vals)\n    cos_term = np.maximum(np.cos(k * lambda_rad), 0).reshape(1, L, 1)\n    \n    A = alpha_3d * a_t_3d * cos_term\n    Z = Z_base_3d + A\n\n    # === Step 2: Compute Gradients G_N and G_S ===\n    # Z has shape (3, 36, 100) corresponding to (phi, lambda, t)\n    Z_40N = Z[0, :, :]\n    Z_60N = Z[1, :, :]\n    Z_80N = Z[2, :, :]\n    \n    G_N = (Z_60N - Z_80N) / 20.0\n    G_S = (Z_40N - Z_60N) / 20.0\n\n    # === Step 3: Define Manual Catalog (Ground Truth) ===\n    T_N_man, T_S_man, q_man = 5.0, 10.0, 0.4\n    \n    manual_cond = (G_N = -T_N_man)  (G_S >= T_S_man)\n    manual_frac_blocked = np.mean(manual_cond, axis=0) # Fraction over longitudes for each day\n    manual_catalog = manual_frac_blocked >= q_man\n\n    P = np.sum(manual_catalog)  # Total positives\n    N = D - P                   # Total negatives\n\n    # === Step 4: Parameter Sweep and Metric Calculation ===\n    T_N_sweep = [0, 5, 10, 15, 20, 25, 30]\n    T_S_sweep = [5, 10, 12, 15, 20, 25]\n    q_op = 0.3\n\n    roc_points = []\n    specific_results = {}\n    test_cases = [(0, 5), (5, 10), (10, 10), (15, 12), (25, 20)]\n\n    for T_N in T_N_sweep:\n        for T_S in T_S_sweep:\n            # Generate operational catalog for this (T_N, T_S) pair\n            op_cond = (G_N = -T_N)  (G_S >= T_S)\n            op_frac_blocked = np.mean(op_cond, axis=0)\n            op_catalog = op_frac_blocked >= q_op\n\n            # Compute confusion matrix elements\n            TP = np.sum(op_catalog  manual_catalog)\n            FP = np.sum(op_catalog  ~manual_catalog)\n            # FN is not explicitly needed for TPR if P is pre-calculated\n            # TN is not explicitly needed for FPR if N is pre-calculated\n\n            TPR = TP / P if P > 0 else 0.0\n            FPR = FP / N if N > 0 else 0.0\n            \n            roc_points.append((FPR, TPR))\n            \n            if (T_N, T_S) in test_cases:\n                specific_results[(T_N, T_S)] = (TPR, FPR)\n\n    # === Step 5: AUC Calculation ===\n    # Augment with trivial classifiers\n    roc_points.extend([(0.0, 0.0), (1.0, 1.0)])\n\n    # Retain maximal TPR for each unique FPR\n    fpr_tpr_map = {}\n    for fpr, tpr in roc_points:\n        fpr_tpr_map[fpr] = max(fpr_tpr_map.get(fpr, -1.0), tpr)\n\n    # Sort points by FPR\n    sorted_roc_points = sorted(fpr_tpr_map.items())\n    \n    final_fprs = [p[0] for p in sorted_roc_points]\n    final_tprs = [p[1] for p in sorted_roc_points]\n    \n    # Compute AUC using trapezoidal rule\n    AUC = np.trapz(final_tprs, final_fprs)\n\n    # === Step 6: Format and Print Output ===\n    final_output = [AUC]\n    for case in test_cases:\n        tpr, fpr = specific_results.get(case, (float('nan'), float('nan')))\n        final_output.extend([tpr, fpr])\n        \n    print(f\"[{','.join(map(str, final_output))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "对阻塞的评估最终需要从逐日的分类指标（“命中”或“漏报”）转向更符合物理实际的基于“事件”的验证。本练习介绍了一种先进的验证方法，用于将自动检测到的阻塞事件与专家手动编制的参考目录进行比较。您将学习如何使用Jaccard相似度来量化事件在时空上的重叠，并通过解决指派问题来建立事件之间的一一对应关系，从而计算出如精确率、召回率和事件起止时间误差等更为精细的性能指标。",
            "id": "4013038",
            "problem": "您会获得一个经过整理的大气阻塞事件人工目录以及一个自动化检测算法的输出。每个事件表示为一个时空对象，位于一个周长为 $360^{\\circ}$ 的周期性经度圈上和一个以天为单位的离散时间轴上。单个事件由一个四元组 $(\\ell, w, t_s, t_e)$ 完全描述，其中 $\\ell$ 是以度为单位的经度中心，$w$ 是以度为单位的经度宽度（$0  w \\le 360$），$t_s$ 是开始日索引，$t_e$ 是结束日索引（$t_s \\le t_e$）。事件所占据的经度弧是经度的集合\n$$\nA(\\ell,w) = \\{ \\lambda \\in [0,360) : \\text{the shortest arc centered at } \\ell \\text{ of length } w \\text{ contains } \\lambda \\},\n$$\n在周期为 $360^{\\circ}$ 的圆上进行解释。事件的时间支持是包含端点的日期集合\n$$\nI(t_s,t_e) = \\{ t \\in \\mathbb{Z} : t_s \\le t \\le t_e \\}.\n$$\n\n您的任务是通过以下方式，对照人工目录验证该检测器：\n- 使用基于集合论的相似性准则，建立人工事件和检测事件之间的一对一匹配，\n- 计算技能分数（精确率、召回率和 F1 分数），\n- 量化事件在开始和结束方面的计时准确性（以天为单位），以及\n- 通过统计假正例和假负例的数量来报告失败特征。\n\n使用的基本原理和定义：\n- 对于公共域上具有有限非负度量的任意两个集合 $X$ 和 $Y$，Jaccard 相似度定义为比率 $J(X,Y) = \\frac{|X \\cap Y|}{|X \\cup Y|}$，其中 $|\\cdot|$ 表示度量（对于经度弧是圆上的长度，单位为度；对于离散日期间隔是基数，采用包含日的计数方式）。\n- 设 $r_s$ 表示一个人工事件和一个检测事件的空间 Jaccard 相似度 $J(A(\\ell_m,w_m),A(\\ell_d,w_d))$，设 $r_t$ 表示它们的时间 Jaccard 相似度 $J(I(t_{s,m},t_{e,m}), I(t_{s,d},t_{e,d}))$。一个候选匹配是可接受的，当且仅当对于给定的阈值 $\\tau_s, \\tau_t \\in [0,1]$，满足 $r_s \\ge \\tau_s$ 且 $r_t \\ge \\tau_t$。\n- 为可接受的配对定义一个组合相似性得分 $S = r_s \\times r_t$，对于不可接受的配对 $S = 0$。通过在每个事件最多使用一次的约束下，最大化匹配对的 $S$ 值总和，来建立人工事件和检测事件之间的一对一匹配。\n- 设 $TP$ 为具有可接受相似度的匹配对数量，$FN$ 为未匹配的人工事件数量，$FP$ 为未匹配的检测事件数量。精确率是 $P = \\frac{TP}{TP+FP}$，约定当 $TP+FP = 0$ 时 $P = 0$。召回率是 $R = \\frac{TP}{TP+FN}$，约定当 $TP+FN = 0$ 时 $R = 0$。F1 分数是 $F1 = \\frac{2PR}{P+R}$，约定当 $P+R = 0$ 时 $F1 = 0$。\n- 对于每个匹配的人工-检测对，定义开始时间误差 $e_s = t_{s,d} - t_{s,m}$ 和结束时间误差 $e_e = t_{e,d} - t_{e,m}$。需要报告的事件计时准确性度量是平均绝对开始误差 $\\overline{|e_s|}$ 和平均绝对结束误差 $\\overline{|e_e|}$，均以天为单位。如果没有匹配对，则报告两个计时准确性度量均为 $0$ 天。\n\n重要的实现细节：\n- 经度几何是周期性的，周期为 $360^{\\circ}$。弧的并集和交集的长度必须在圆上计算，并遵守在 $0^{\\circ}$ 和 $360^{\\circ}$ 处的环绕处理。将经度弧按其几何长度（以度为单位）处理。将时间间隔视为在整数日上包含端点，因此 $I(t_s,t_e)$ 的长度为 $t_e - t_s + 1$ 天。\n- 一对一匹配必须最大化组合相似性得分 $S$ 的总和，并遵守由阈值定义的可接受性。如果多个配对方案获得相同的最大分数，只要符合可接受性约束，任何一个这样的最优配对方案都是可以接受的。\n\n在所有情况下使用以下阈值：$\\tau_s = 0.5$ 和 $\\tau_t = 0.5$。\n\n测试套件：\n每个测试用例都是一对列表。第一个列表是人工目录，第二个列表是检测结果，两者都以元组 $(\\ell, w, t_s, t_e)$ 的列表形式给出，其中 $\\ell$ 以度为单位， $w$ 以度为单位，$t_s,t_e$ 以天为单位。\n\n- Case 1 (一般良好匹配): manual $=[(30, 60, 2, 10),(200, 50, 15, 22)]$; detections $=[(35, 70, 3, 11),(205, 40, 16, 20)]$.\n- Case 2 (周期性环绕和一个伪影): manual $=[(350, 40, 5, 12)]$; detections $=[(355, 50, 6, 13),(150, 30, 7, 10)]$.\n- Case 3 (一个人工事件对应多个重复的检测结果): manual $=[(100, 60, 0, 9)]$; detections $=[(102, 70, 0, 9),(98, 50, 2, 8)]$.\n- Case 4 (时间碎片化和一次漏检): manual $=[(250, 80, 10, 25),(300, 50, 5, 8)]$; detections $=[(252, 70, 10, 17),(252, 70, 18, 25),(30, 40, 0, 3)]$.\n- Case 5 (无检测结果): manual $=[(180, 100, 0, 10)]$; detections $=[]$.\n\n每个测试用例的必需输出：\n- 精确率 $P$，保留三位小数的实数。\n- 召回率 $R$，保留三位小数的实数。\n- F1 分数 $F1$，保留三位小数的实数。\n- 平均绝对开始误差 $\\overline{|e_s|}$，以天为单位，保留两位小数的实数（单位：天）。\n- 平均绝对结束误差 $\\overline{|e_e|}$，以天为单位，保留两位小数的实数（单位：天）。\n- 整数计数的 $FP$。\n- 整数计数的 $FN$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表由每个案例的结果列表组成，不含空格。例如，输出必须如下所示\n$[ [P_1,R_1,F1_1,\\overline{|e_s|}_1,\\overline{|e_e|}_1,FP_1,FN_1], [P_2,R_2,F1_2,\\overline{|e_s|}_2,\\overline{|e_e|}_2,FP_2,FN_2], \\dots ]$\n但无空格。具体来说，您的程序应以以下确切格式打印单行：\n\"[case1_list,case2_list,case3_list,case4_list,case5_list]\".",
            "solution": "该问题要求对照人工参考目录，验证一个自动化大气阻塞检测算法。验证过程涉及多个步骤：量化单个事件的相似性，建立人工事件和检测事件之间的最优一对一匹配，最后计算一套标准性能指标。整个过程基于集合论和组合优化。\n\n基本算法流程如下：\n1.  对于每一对可能的人工事件和检测事件，计算它们的空间和时间相似度。\n2.  使用这些相似度计算一个组合得分，该得分仅对满足预定义可接受性阈值的配对为非零。\n3.  解决指派问题，找到人工事件和检测事件之间的一对一匹配，以最大化总组合相似性得分。\n4.  基于此最优匹配，将事件分类为真正例、假正例和假负例。\n5.  计算最终的技能分数（精确率、召回率、F1）和计时准确性度量（平均绝对开始和结束误差）。\n\n设一个人工事件为 $m_i = (\\ell_{m,i}, w_{m,i}, t_{s,m,i}, t_{e,m,i})$，一个检测事件为 $d_j = (\\ell_{d,j}, w_{d,j}, t_{s,d,j}, t_{e,d,j})$。\n\n**步骤 1：空间 Jaccard 相似度 ($r_s$)**\n\n事件的经度范围是周长为 $C = 360^{\\circ}$ 的圆上的一个弧。两个弧 $A_m = A(\\ell_m, w_m)$ 和 $A_d = A(\\ell_d, w_d)$ 之间的相似度由 Jaccard 指数给出：$r_s = J(A_m, A_d) = \\frac{|A_m \\cap A_d|}{|A_m \\cup A_d|}$。度量 $|\\cdot|$ 对应于弧的长度，单位为度。\n\n并集的长度由 $|A_m \\cup A_d| = |A_m| + |A_d| - |A_m \\cap A_d| = w_m + w_d - |A_m \\cap A_d|$ 给出。\n主要挑战是在周期性域上计算交集长度 $|A_m \\cap A_d|$。对于由中心和宽度定义的两个弧，可以巧妙地计算交集长度。设 $\\Delta\\ell = |\\ell_m - \\ell_d|$ 为其经度中心的绝对差。圆上中心之间的最短距离为 $\\Delta\\ell_{\\text{circ}} = \\min(\\Delta\\ell, 360 - \\Delta\\ell)$。两个弧重叠当且仅当此距离小于其宽度平均值，即 $\\Delta\\ell_{\\text{circ}}  (w_m + w_d)/2$。它们的交集长度是此重叠的范围：\n$$\n|A_m \\cap A_d| = \\max\\left(0, \\frac{w_m + w_d}{2} - \\Delta\\ell_{\\text{circ}}\\right)\n$$\n由此，空间 Jaccard 相似度为：\n$$\nr_s = \\frac{|A_m \\cap A_d|}{w_m + w_d - |A_m \\cap A_d|}\n$$\n如果分母为零（仅当 $w_m=w_d=0$ 时发生，此处不可能），$r_s$ 将无定义，但该情况已被 $w > 0$ 排除。\n\n**步骤 2：时间 Jaccard 相似度 ($r_t$)**\n\n时间支持是一个包含端点的整数（天）区间。设 $I_m = I(t_{s,m}, t_{e,m})$ 和 $I_d = I(t_{s,d}, t_{e,d})$。度量是基数。一个区间 $I(t_s, t_e)$ 的长度是 $|I| = t_e - t_s + 1$。两个区间的交集是 $I_m \\cap I_d = [\\max(t_{s,m}, t_{s,d}), \\min(t_{e,m}, t_{e,d})]$。其长度为：\n$$\n|I_m \\cap I_d| = \\max\\left(0, \\min(t_{e,m}, t_{e,d}) - \\max(t_{s,m}, t_{s,d}) + 1\\right)\n$$\n则时间 Jaccard 相似度为：\n$$\nr_t = \\frac{|I_m \\cap I_d|}{|I_m| + |I_d| - |I_m \\cap I_d|}\n$$\n如果分母为零（即两个区间的长度都为零，由于 $t_s \\le t_e$ 这不会发生），则 $r_t$ 取为 $0$。\n\n**步骤 3：组合相似度与最优匹配**\n\n对于每一对 $(m_i, d_j)$，我们计算 $r_{s,ij}$ 和 $r_{t,ij}$。如果 $r_{s,ij} \\ge \\tau_s$ 且 $r_{t,ij} \\ge \\tau_t$，则该配对是可接受的，问题指定 $\\tau_s = 0.5$ 和 $\\tau_t = 0.5$。组合相似性得分 $S_{ij}$ 定义为：\n$$\nS_{ij} = \\begin{cases} r_{s,ij} \\times r_{t,ij}  \\text{if } r_{s,ij} \\ge \\tau_s \\text{ and } r_{t,ij} \\ge \\tau_t \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n这构成了一个大小为 $N_m \\times N_d$ 的相似度矩阵 $S$，其中 $N_m$ 和 $N_d$ 分别是人工事件和检测事件的数量。目标是找到一组一对一的配对 $(i, j)$，以最大化总和 $\\sum S_{ij}$。这是一个经典的指派问题，也称为最大权二分图匹配。可以通过定义一个成本矩阵 $C_{ij} = -S_{ij}$ 将其转化为一个最小化问题。然后，标准算法（如匈牙利算法）可以找到最小化总成本的指派，这等同于最大化总相似度。这在 `scipy.optimize.linear_sum_assignment` 中有实现。\n\n**步骤 4：性能指标的计算**\n\n指派问题的解提供了一组匹配对。来自此最优匹配的一对 $(m_i, d_j)$ 仅当其相似性得分 $S_{ij}$ 大于 $0$ 时，才被视为一个真正例（$TP$）。这内在地强制执行了可接受性准则。\n- **真正例 ($TP$)**: $S_{ij} > 0$ 的匹配对数量。\n- **假负例 ($FN$)**: 不属于真正例对的人工事件数量。$FN = N_m - TP$。\n- **假正例 ($FP$)**: 不属于真正例对的检测事件数量。$FP = N_d - TP$。\n\n有了这些计数，就可以计算技能分数：\n- **精确率 ($P$)**: $P = \\frac{TP}{TP+FP}$。如果 $TP+FP=0$，$P=0$。\n- **召回率 ($R$)**: $R = \\frac{TP}{TP+FN}$。如果 $TP+FN=0$，$R=0$。\n- **F1 分数 ($F1$)**: $F1 = \\frac{2PR}{P+R}$。如果 $P+R=0$，$F1=0$。\n\n对于每个真正例对 $(m_i, d_j)$，计算开始和结束时间误差：\n- 开始误差: $e_{s,ij} = t_{s,d,j} - t_{s,m,i}$\n- 结束误差: $e_{e,ij} = t_{e,d,j} - t_{e,m,i}$\n\n最终的计时准确性度量是所有 $TP$ 对的平均绝对误差：\n- 平均绝对开始误差: $\\overline{|e_s|} = \\frac{1}{TP} \\sum_{k=1}^{TP} |e_{s,k}|$\n- 平均绝对结束误差: $\\overline{|e_e|} = \\frac{1}{TP} \\sum_{k=1}^{TP} |e_{e,k}|$\n如果 $TP=0$，则两个平均绝对误差都报告为 $0$。最终的数值结果按问题陈述中的要求进行四舍五入。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        (\n            [(30, 60, 2, 10), (200, 50, 15, 22)],\n            [(35, 70, 3, 11), (205, 40, 16, 20)],\n        ),\n        # Case 2\n        (\n            [(350, 40, 5, 12)],\n            [(355, 50, 6, 13), (150, 30, 7, 10)],\n        ),\n        # Case 3\n        (\n            [(100, 60, 0, 9)],\n            [(102, 70, 0, 9), (98, 50, 2, 8)],\n        ),\n        # Case 4\n        (\n            [(250, 80, 10, 25), (300, 50, 5, 8)],\n            [(252, 70, 10, 17), (252, 70, 18, 25), (30, 40, 0, 3)],\n        ),\n        # Case 5\n        (\n            [(180, 100, 0, 10)],\n            [],\n        ),\n    ]\n\n    # Thresholds as defined in the problem\n    tau_s = 0.5\n    tau_t = 0.5\n\n    all_results = []\n    for manual_catalog, detected_events in test_cases:\n        result = _solve_single_case(manual_catalog, detected_events, tau_s, tau_t)\n        all_results.append(result)\n\n    # Format the final output string exactly as required\n    formatted_results = [\n        f\"[{res[0]:.3f},{res[1]:.3f},{res[2]:.3f},{res[3]:.2f},{res[4]:.2f},{res[5]},{res[6]}]\"\n        for res in all_results\n    ]\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _solve_single_case(manual_catalog, detected_events, tau_s, tau_t):\n    \"\"\"\n    Solves a single validation case.\n    \"\"\"\n    num_manual = len(manual_catalog)\n    num_detected = len(detected_events)\n\n    if num_manual == 0 or num_detected == 0:\n        tp = 0\n        fp = num_detected\n        fn = num_manual\n        p = 0.0 if (tp + fp) == 0 else tp / (tp + fp)\n        r = 0.0 if (tp + fn) == 0 else tp / (tp + fn)\n        f1 = 0.0 if (p + r) == 0 else 2 * p * r / (p + r)\n        mean_abs_onset_err = 0.0\n        mean_abs_cessation_err = 0.0\n        return [p, r, f1, mean_abs_onset_err, mean_abs_cessation_err, fp, fn]\n\n    similarity_matrix = np.zeros((num_manual, num_detected))\n\n    for i, m_event in enumerate(manual_catalog):\n        for j, d_event in enumerate(detected_events):\n            # Decompose events\n            l_m, w_m, ts_m, te_m = m_event\n            l_d, w_d, ts_d, te_d = d_event\n\n            # Spatial Jaccard\n            delta_l = abs(l_m - l_d)\n            delta_l_circ = min(delta_l, 360.0 - delta_l)\n            intersection_s = max(0.0, (w_m + w_d) / 2.0 - delta_l_circ)\n            union_s = w_m + w_d - intersection_s\n            r_s = intersection_s / union_s if union_s > 0 else 0.0\n            \n            # Temporal Jaccard\n            len_m = te_m - ts_m + 1\n            len_d = te_d - ts_d + 1\n            intersection_t = max(0, min(te_m, te_d) - max(ts_m, ts_d) + 1)\n            union_t = len_m + len_d - intersection_t\n            r_t = intersection_t / union_t if union_t > 0 else 0.0\n\n            # Combined score with admissibility\n            if r_s >= tau_s and r_t >= tau_t:\n                similarity_matrix[i, j] = r_s * r_t\n            else:\n                similarity_matrix[i, j] = 0.0\n\n    # Solve assignment problem (maximize similarity = minimize negative similarity)\n    cost_matrix = -similarity_matrix\n    row_ind, col_ind = linear_sum_assignment(cost_matrix)\n\n    # Calculate metrics from matching\n    tp = 0\n    onset_errors = []\n    cessation_errors = []\n\n    for i, j in zip(row_ind, col_ind):\n        if similarity_matrix[i, j] > 0:\n            tp += 1\n            m_event = manual_catalog[i]\n            d_event = detected_events[j]\n            \n            onset_error = d_event[2] - m_event[2]\n            cessation_error = d_event[3] - m_event[3]\n            onset_errors.append(abs(onset_error))\n            cessation_errors.append(abs(cessation_error))\n\n    fp = num_detected - tp\n    fn = num_manual - tp\n\n    # Skill scores with conventions for zero denominators\n    p = 0.0 if (tp + fp) == 0 else tp / (tp + fp)\n    r = 0.0 if (tp + fn) == 0 else tp / (tp + fn)\n    f1 = 0.0 if (p + r) == 0 else 2 * p * r / (p + r)\n\n    # Timing accuracy with convention for no matches\n    mean_abs_onset_err = np.mean(onset_errors) if tp > 0 else 0.0\n    mean_abs_cessation_err = np.mean(cessation_errors) if tp > 0 else 0.0\n    \n    return [p, r, f1, mean_abs_onset_err, mean_abs_cessation_err, fp, fn]\n\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}