{
    "hands_on_practices": [
        {
            "introduction": "古气候重建的第一步通常是“校准”：将代用指标的测量值与已知的气候变量（如仪器观测的温度）建立定量关系。然而，一个常见的陷阱是忽略了代用指标本身也存在测量误差。该练习将引导您运用“变量含误差”（Errors-in-Variables, EIV）模型，这是一种重要的统计框架，用于纠正当预测变量含有噪声时产生的系统性偏差，即“衰减偏误”。通过完成这个实践 ，您将亲手量化这种偏误，并掌握获得更准确、更可靠校准关系的关键技术。",
            "id": "4073673",
            "problem": "一项古气候校准研究旨在利用变量误差（EIV）框架，将海洋沉积物地球化学代用指标与仪器测量的海表温度联系起来。设 $Y_t$ 表示仪器测量的温度（单位为摄氏度），$X_t$ 表示潜在的、真实的代用指标状态（无量纲代用指标单位）。代用指标的观测值受到分析测量误差的污染，因此观测到的代用指标为 $X_t^{\\ast} = X_t + u_t$，其中 $u_t$ 是一个均值为零、方差恒定的独立测量误差。连接温度和真实代用指标的物理校准模型为 $Y_t = \\alpha + \\beta X_t + \\varepsilon_t$，其中 $\\varepsilon_t$ 是一个均值为零的独立噪声项，且 $(u_t)$ 独立于 $(\\varepsilon_t)$ 和 $(X_t)$。在一个现代校准区间上，从配对观测值 $\\{(Y_t, X_t^{\\ast})\\}_{t=1}^{n}$ 计算出以下汇总统计量：\n- 温度与观测代用指标之间的样本协方差为 $C_{Y X^{\\ast}} = 0.84$（摄氏度·代用指标单位）。\n- 观测代用指标的样本方差为 $V_{X^{\\ast}} = 1.50$（代用指标单位的平方）。\n- 独立的重复分析提供了一个测量误差方差的估计值，$\\sigma_u^2 = 0.60$（代用指标单位的平方）。\n\n在上述模型假设下，使用基于基本原理的变量误差方法来估计校准斜率 $\\beta$，并计算在将 $Y_t$ 对 $X_t^{\\ast}$ 进行回归时，如果忽略 $X_t^{\\ast}$ 中的测量误差将会产生的衰减偏差。请将斜率和偏差以“摄氏度/代用指标单位”表示。将两个数字都四舍五入到四位有效数字。请以一个行矩阵的形式提供最终答案，其第一个元素是EIV斜率估计值，第二个元素是忽略测量误差时的衰减偏差。",
            "solution": "首先验证问题，以确保其自洽、科学上合理且定义明确。\n\n### 步骤1：提取已知信息\n-   连接真实温度 $Y_t$ 与真实潜在代用指标状态 $X_t$ 的物理模型是：$Y_t = \\alpha + \\beta X_t + \\varepsilon_t$。\n-   观测代用指标 $X_t^{\\ast}$ 的测量模型是：$X_t^{\\ast} = X_t + u_t$。\n-   $\\varepsilon_t$ 是一个均值为零的独立噪声项。\n-   $u_t$ 是一个均值为零、方差恒为 $\\sigma_u^2$ 的独立测量误差。\n-   误差序列 $(\\varepsilon_t)$ 和 $(u_t)$ 相互独立，并且也独立于真实代用指标状态序列 $(X_t)$。\n-   温度与观测代用指标之间的样本协方差：$C_{Y X^{\\ast}} = 0.84$。\n-   观测代用指标的样本方差：$V_{X^{\\ast}} = 1.50$。\n-   测量误差的方差：$\\sigma_u^2 = 0.60$。\n\n### 步骤2：使用提取的已知信息进行验证\n-   **科学依据：** 该问题描述了一个标准的变量误差（EIV）回归模型。这是一个基本的统计框架，广泛应用于科学和工程领域中预测变量带测量误差的校准问题。该模型在数学上和科学上都是合理的。\n-   **定义明确：** 该问题提供了所有必要的模型假设和汇总统计量（$C_{Y X^{\\ast}}$, $V_{X^{\\ast}}$, $\\sigma_u^2$），足以推导出斜率参数 $\\beta$ 及其相关衰减偏差的唯一估计值。\n-   **客观性：** 该问题使用统计学和回归分析中精确、标准的术语进行陈述。没有歧义或主观性语言。\n\n### 步骤3：结论与行动\n-   该问题被判定为**有效**。将提供解答。\n\n### 解答推导\n\n目标是从模型 $Y_t = \\alpha + \\beta X_t + \\varepsilon_t$ 中估计真实的校准斜率 $\\beta$，而已知我们只能观测到 $Y_t$ 和带噪声的预测变量 $X_t^{\\ast} = X_t + u_t$。\n\n我们首先建立观测变量的总体矩（方差和协方差）与底层模型参数之间的关系。我们将真实代用指标状态的方差记为 $\\sigma_X^2 = \\text{Var}(X_t)$。\n\n观测温度 $Y_t$ 和观测代用指标 $X_t^{\\ast}$ 之间的总体协方差为：\n$$ \\text{Cov}(Y_t, X_t^{\\ast}) = \\text{Cov}(\\alpha + \\beta X_t + \\varepsilon_t, X_t + u_t) $$\n利用协方差算子的双线性和独立性假设（$X_t$、$\\varepsilon_t$ 和 $u_t$ 相互独立），上式可简化为：\n$$ \\text{Cov}(Y_t, X_t^{\\ast}) = \\text{Cov}(\\beta X_t, X_t) + \\text{Cov}(\\beta X_t, u_t) + \\text{Cov}(\\varepsilon_t, X_t) + \\text{Cov}(\\varepsilon_t, u_t) $$\n$$ \\text{Cov}(Y_t, X_t^{\\ast}) = \\beta \\text{Var}(X_t) + \\beta \\text{Cov}(X_t, u_t) + \\text{Cov}(\\varepsilon_t, X_t) + \\text{Cov}(\\varepsilon_t, u_t) $$\n由于 $\\text{Cov}(X_t, u_t)=0$、$\\text{Cov}(\\varepsilon_t, X_t)=0$ 和 $\\text{Cov}(\\varepsilon_t, u_t)=0$，我们得到：\n$$ \\text{Cov}(Y_t, X_t^{\\ast}) = \\beta \\text{Var}(X_t) = \\beta \\sigma_X^2 $$\n\n观测代用指标 $X_t^{\\ast}$ 的方差为：\n$$ \\text{Var}(X_t^{\\ast}) = \\text{Var}(X_t + u_t) $$\n由于 $X_t$ 和 $u_t$ 是独立的，它们的和的方差等于它们各自方差的和：\n$$ \\text{Var}(X_t^{\\ast}) = \\text{Var}(X_t) + \\text{Var}(u_t) = \\sigma_X^2 + \\sigma_u^2 $$\n\n如果忽略测量误差 $u_t$ 并对 $Y_t$ 关于 $X_t^{\\ast}$ 进行普通最小二乘（OLS）回归，斜率估计量（我们记为 $\\hat{\\beta}_{OLS}$）将被计算为：\n$$ \\hat{\\beta}_{OLS} = \\frac{C_{Y X^{\\ast}}}{V_{X^{\\ast}}} $$\n在大样本极限下，该估计量收敛于：\n$$ \\beta_{OLS} = \\frac{\\text{Cov}(Y_t, X_t^{\\ast})}{\\text{Var}(X_t^{\\ast})} = \\frac{\\beta \\sigma_X^2}{\\sigma_X^2 + \\sigma_u^2} = \\beta \\left( \\frac{\\sigma_X^2}{\\sigma_X^2 + \\sigma_u^2} \\right) $$\n由于 $\\sigma_X^2 > 0$ 和 $\\sigma_u^2 > 0$，因子 $\\frac{\\sigma_X^2}{\\sigma_X^2 + \\sigma_u^2}$ 总是小于1。这表明OLS估计值偏向于零，这种现象被称为衰减偏差。\n\n为了获得 $\\beta$ 的无偏估计，我们必须校正这种效应。EIV方法利用了测量误差方差 $\\sigma_u^2$ 的信息。从 $X_t^{\\ast}$ 的方差方程中，我们可以将真实代用指标的未知方差表示为：\n$$ \\sigma_X^2 = \\text{Var}(X_t^{\\ast}) - \\sigma_u^2 $$\n将此代入协方差方程：\n$$ \\text{Cov}(Y_t, X_t^{\\ast}) = \\beta (\\text{Var}(X_t^{\\ast}) - \\sigma_u^2) $$\n通过用样本估计值替换总体矩，求解真实斜率 $\\beta$ 得到EIV估计量 $\\hat{\\beta}_{EIV}$：\n$$ \\hat{\\beta}_{EIV} = \\frac{C_{Y X^{\\ast}}}{V_{X^{\\ast}} - \\sigma_u^2} $$\n使用提供的数值：\n$$ C_{Y X^{\\ast}} = 0.84 $$\n$$ V_{X^{\\ast}} = 1.50 $$\n$$ \\sigma_u^2 = 0.60 $$\nEIV斜率估计值为：\n$$ \\hat{\\beta}_{EIV} = \\frac{0.84}{1.50 - 0.60} = \\frac{0.84}{0.90} = \\frac{14}{15} \\approx 0.933333... $$\n四舍五入到四位有效数字，$\\hat{\\beta}_{EIV} = 0.9333$ 摄氏度/代用指标单位。\n\n接下来，我们计算使用朴素OLS方法所产生的衰减偏差。该偏差是OLS斜率估计值与真实斜率（我们使用其最佳估计值 $\\hat{\\beta}_{EIV}$）之间的差值。OLS斜率估计值为：\n$$ \\hat{\\beta}_{OLS} = \\frac{C_{Y X^{\\ast}}}{V_{X^{\\ast}}} = \\frac{0.84}{1.50} = 0.56 $$\n衰减偏差计算如下：\n$$ \\text{Bias} = \\hat{\\beta}_{OLS} - \\hat{\\beta}_{EIV} $$\n$$ \\text{Bias} = 0.56 - \\frac{14}{15} = \\frac{14}{25} - \\frac{14}{15} = 14 \\left( \\frac{1}{25} - \\frac{1}{15} \\right) = 14 \\left( \\frac{3 - 5}{75} \\right) = 14 \\left( \\frac{-2}{75} \\right) = -\\frac{28}{75} \\approx -0.373333... $$\n四舍五入到四位有效数字，衰减偏差为 $-0.3733$ 摄氏度/代用指标单位。负号表示朴素的OLS回归低估了斜率的真实大小。\n\n最终答案要求以行矩阵形式呈现EIV斜率估计值和衰减偏差。\n第一个元素：$\\hat{\\beta}_{EIV} = 0.9333$。\n第二个元素：$\\text{Bias} = -0.3733$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.9333  -0.3733\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "气候信号在被代用指标记录并保存下来的过程中，会受到各种物理和生物过程的改造。一个典型的例子是海洋沉积物中的“生物扰动”——底栖生物的活动会混合沉积层，从而模糊了原始的气候记录。这个练习将生物扰动过程数学化，将其模拟为一个卷积平滑滤波器。通过运用傅里叶分析和卷积定理 ，您将能够从频域的角度，定量分析这种平滑效应对海表温度（SST）记录中高频变化的衰减作用，深刻理解沉积物档案保真度的极限。",
            "id": "4073731",
            "problem": "在沉积物中由有孔虫记录的连续海面温度（SST）信号会因生物混合（生物扰动）而被平滑。在一个简单且广泛使用的理想化模型中，生物扰动对所记录的SST时间序列的影响，在时域上表示为原始信号与一个混合核之间的卷积。假设在深度域中的混合核是高斯分布的，其标准差为 $\\sigma_z$（单位：$\\mathrm{cm}$），并且沉积速率是恒定的，其值为 $r_{\\mathrm{sed}}$（单位：$\\mathrm{cm}\\,\\mathrm{ka}^{-1}$）。在这些假设下，在年代（时间）域中的平滑可以表示为与一个高斯混合核的卷积，该核的时间标准差为 $\\sigma_t = \\sigma_z / r_{\\mathrm{sed}}$（单位：$\\mathrm{ka}$）。\n\n使用以下基本原理：\n- 卷积定理：卷积的傅里叶变换等于傅里叶变换的乘积。\n- 时域上标准差为 $\\sigma_t$ 的归一化高斯函数的傅里叶变换是角频率域上的一个高斯函数，其宽度与 $\\sigma_t$ 成反比。\n- 白噪声过程在所有频率上具有恒定的功率谱密度。\n\n任务：\n- 从上述陈述出发，根据第一性原理推导出一个公式，用于计算经过时间标准差为 $\\sigma_t$ 的高斯平滑后，正弦SST分量在频率 $f_0$（单位：$\\mathrm{ka}^{-1}$）处的振幅衰减因子。\n- 假设未平滑的SST过程在指定的频带 $[f_{\\mathrm{low}}, f_{\\mathrm{high}}]$（单位：$\\mathrm{ka}^{-1}$）内具有白功率谱密度。根据第一性原理推导一个公式，用于计算在该频带内平滑后保留的方差分数，该分数表示为平滑后功率的频带平均值与平滑前功率的频带平均值之比。\n- 实现一个程序，为下方的每个测试用例计算：\n  $1$) 在 $f_0$ 处的振幅衰减因子，以及\n  $2$) 在频带 $[f_{\\mathrm{low}}, f_{\\mathrm{high}}]$ 内保留的方差分数。\n- 所有输出必须是无量纲比率，以小数十进制形式表示。不涉及角度。不应使用百分比；所有比率必须以小数十进制形式报告。\n\n测试套件（每项指定 $\\sigma_z$（单位：$\\mathrm{cm}$）、$r_{\\mathrm{sed}}$（单位：$\\mathrm{cm}\\,\\mathrm{ka}^{-1}$）、$f_0$（单位：$\\mathrm{ka}^{-1}$）、$f_{\\mathrm{low}}$（单位：$\\mathrm{ka}^{-1}$）和 $f_{\\mathrm{high}}$（单位：$\\mathrm{ka}^{-1}$））：\n- 测试用例 1：$\\sigma_z = 0.0$， $r_{\\mathrm{sed}} = 1.0$， $f_0 = 3.0$， $f_{\\mathrm{low}} = 1.0$， $f_{\\mathrm{high}} = 10.0$。\n- 测试用例 2：$\\sigma_z = 5.0$， $r_{\\mathrm{sed}} = 1.0$， $f_0 = 2.0$， $f_{\\mathrm{low}} = 1.0$， $f_{\\mathrm{high}} = 5.0$。\n- 测试用例 3：$\\sigma_z = 2.0$， $r_{\\mathrm{sed}} = 50.0$， $f_0 = 2.0$， $f_{\\mathrm{low}} = 1.0$， $f_{\\mathrm{high}} = 5.0$。\n- 测试用例 4：$\\sigma_z = 10.0$， $r_{\\mathrm{sed}} = 0.5$， $f_0 = 0.1$， $f_{\\mathrm{low}} = 0.05$， $f_{\\mathrm{high}} = 0.5$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是一个双元素列表，按顺序包含在 $f_0$ 处的振幅衰减因子和频带内保留的方差分数。例如：$[[a_1, r_1],[a_2, r_2],\\dots]$，其中每个 $a_i$ 和 $r_i$ 都是小数十进制数。\n\n假设与约束：\n- 将时域中的高斯核视为已归一化至单位面积。\n- 频带内保留的方差分数必须在假设平滑前频谱在整个频带内为白噪声谱的前提下，计算为平滑后与平滑前频带平均功率之比。\n- 使用上文指定的相干单位表示所有中间物理量，并以无量纲小数十进制数报告最终比率。",
            "solution": "该问题被评估为有效，因为它在科学上基于信号处理理论，问题设定良好、目标明确，且内部逻辑一致。\n\n该解答按要求从第一性原理推导得出。\n\n### 第1部分：振幅衰减因子\n\n生物扰动过程被建模为一个线性时不变系统，其中平滑后的海面温度（SST）信号 $s_{\\text{smooth}}(t)$ 是原始信号 $s(t)$ 与高斯混合核 $g(t)$ 的卷积。\n$$s_{\\text{smooth}}(t) = (s * g)(t) = \\int_{-\\infty}^{\\infty} s(\\tau) g(t - \\tau) d\\tau$$\n问题指明高斯核 $g(t)$ 被归一化至单位面积，且标准差为 $\\sigma_t$。其函数形式为：\n$$g(t) = \\frac{1}{\\sigma_t\\sqrt{2\\pi}} e^{-t^2 / (2\\sigma_t^2)}$$\n时间标准差 $\\sigma_t$（单位：$\\mathrm{ka}$）、混合深度标准差 $\\sigma_z$（单位：$\\mathrm{cm}$）与沉积速率 $r_{\\mathrm{sed}}$（单位：$\\mathrm{cm}\\,\\mathrm{ka}^{-1}$）之间的关系由下式给出：\n$$\\sigma_t = \\frac{\\sigma_z}{r_{\\mathrm{sed}}}$$\n根据卷积定理，卷积的傅里叶变换是各个傅里叶变换的乘积。令 $\\mathcal{F}$ 表示傅里叶变换算子，并令 $S(f) = \\mathcal{F}\\{s(t)\\}$ 和 $G(f) = \\mathcal{F}\\{g(t)\\}$，其中 $f$ 是频率（单位：$\\mathrm{ka}^{-1}$）。那么，平滑信号的傅里叶变换为：\n$$S_{\\text{smooth}}(f) = S(f) \\cdot G(f)$$\n$G(f)$ 是平滑滤波器的传递函数。它通过对高斯核 $g(t)$ 进行傅里叶变换得到。使用标准傅里叶变换定义 $\\mathcal{F}\\{x(t)\\}(f) = \\int_{-\\infty}^{\\infty} x(t) e^{-i2\\pi ft} dt$，归一化高斯函数的变换结果仍为高斯函数：\n$$G(f) = \\mathcal{F}\\left\\{ \\frac{1}{\\sigma_t\\sqrt{2\\pi}} e^{-t^2/(2\\sigma_t^2)} \\right\\} = e^{-2\\pi^2 f^2 \\sigma_t^2}$$\n对于信号在特定频率 $f_0$ 处的一个正弦分量，其振幅会乘以该频率处传递函数的大小 $|G(f_0)|$。由于 $G(f)$ 对所有 $f$ 都是实数且为正，振幅衰减因子就是 $G(f_0)$。\n$$\\text{Amplitude Attenuation}(f_0) = G(f_0) = e^{-2\\pi^2 f_0^2 \\sigma_t^2}$$\n代入 $\\sigma_t$ 的表达式，我们得到频率 $f_0$ 处振幅衰减因子的最终公式：\n$$A(f_0) = \\exp\\left(-2\\pi^2 f_0^2 \\left(\\frac{\\sigma_z}{r_{\\mathrm{sed}}}\\right)^2\\right)$$\n在没有混合的情况下，$\\sigma_z = 0$，这意味着 $\\sigma_t = 0$。衰减因子变为 $e^0 = 1$，对应于振幅没有变化，这与预期相符。\n\n### 第2部分：保留的方差分数\n\n平滑后信号的功率谱密度（PSD）$P_{\\text{out}}(f)$ 与原始信号的PSD $P_{\\text{in}}(f)$ 通过传递函数的幅值平方相关联：\n$$P_{\\text{out}}(f) = P_{\\text{in}}(f) \\cdot |G(f)|^2$$\n功率传递函数为：\n$$|G(f)|^2 = \\left(e^{-2\\pi^2 f^2 \\sigma_t^2}\\right)^2 = e^{-4\\pi^2 f^2 \\sigma_t^2}$$\n问题指出，原始未平滑信号在频带 $[f_{\\mathrm{low}}, f_{\\mathrm{high}}]$ 内具有白功率谱密度。这意味着其PSD在该频带内是恒定的：当 $f \\in [f_{\\mathrm{low}}, f_{\\mathrm{high}}]$ 时，$P_{\\text{in}}(f) = C$，其中 $C$ 为某个正常数。\n\n原始信号的频带平均功率为：\n$$\\overline{P}_{\\text{in}} = \\frac{1}{f_{\\mathrm{high}} - f_{\\mathrm{low}}} \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} P_{\\text{in}}(f) df = \\frac{1}{f_{\\mathrm{high}} - f_{\\mathrm{low}}} \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} C \\, df = C$$\n平滑信号的频带平均功率为：\n$$\\overline{P}_{\\text{out}} = \\frac{1}{f_{\\mathrm{high}} - f_{\\mathrm{low}}} \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} P_{\\text{out}}(f) df = \\frac{1}{f_{\\mathrm{high}} - f_{\\mathrm{low}}} \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} C \\cdot e^{-4\\pi^2 f^2 \\sigma_t^2} df$$\n保留的方差分数 $R$ 是平滑后频带平均功率与平滑前频带平均功率之比：\n$$R = \\frac{\\overline{P}_{\\text{out}}}{\\overline{P}_{\\text{in}}} = \\frac{1}{f_{\\mathrm{high}} - f_{\\mathrm{low}}} \\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} e^{-4\\pi^2 f^2 \\sigma_t^2} df$$\n这个定积分没有初等反导函数。它可以用误差函数 $\\mathrm{erf}(x)$ 表示，其定义为：\n$$\\mathrm{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{-u^2} du$$\n为了求解我们的积分，我们使用换元法，令 $u = 2\\pi\\sigma_t f$，这意味着 $du = 2\\pi\\sigma_t df$。积分变为：\n$$\\int_{f_{\\mathrm{low}}}^{f_{\\mathrm{high}}} e^{-(2\\pi\\sigma_t f)^2} df = \\frac{1}{2\\pi\\sigma_t} \\int_{2\\pi\\sigma_t f_{\\mathrm{low}}}^{2\\pi\\sigma_t f_{\\mathrm{high}}} e^{-u^2} du$$\n利用属性 $\\int_a^b e^{-u^2}du = \\frac{\\sqrt{\\pi}}{2}(\\mathrm{erf}(b) - \\mathrm{erf}(a))$，该积分的计算结果为：\n$$\\frac{1}{2\\pi\\sigma_t} \\cdot \\frac{\\sqrt{\\pi}}{2} \\left[ \\mathrm{erf}(2\\pi\\sigma_t f_{\\mathrm{high}}) - \\mathrm{erf}(2\\pi\\sigma_t f_{\\mathrm{low}}) \\right] = \\frac{\\sqrt{\\pi}}{4\\pi\\sigma_t} \\left[ \\mathrm{erf}(2\\pi\\sigma_t f_{\\mathrm{high}}) - \\mathrm{erf}(2\\pi\\sigma_t f_{\\mathrm{low}}) \\right]$$\n将此结果代回 $R$ 的公式，我们得到保留的方差分数的最终表达式，该表达式在 $\\sigma_t > 0$ 时有效：\n$$R = \\frac{\\sqrt{\\pi}}{4\\pi\\sigma_t(f_{\\mathrm{high}} - f_{\\mathrm{low}})} \\left[ \\mathrm{erf}(2\\pi\\sigma_t f_{\\mathrm{high}}) - \\mathrm{erf}(2\\pi\\sigma_t f_{\\mathrm{low}}) \\right]$$\n对于 $\\sigma_t = 0$ 的特殊情况，被积函数 $e^{-4\\pi^2 f^2 \\sigma_t^2}$ 变为 $1$。积分为 $f_{\\mathrm{high}} - f_{\\mathrm{low}}$，因此保留的方差分数 $R$ 为 $1$。\n\n这些推导出的公式在以下程序中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Computes the amplitude attenuation factor and fraction of variance retained\n    for several test cases of signal smoothing by bioturbation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains: sigma_z (cm), r_sed (cm/ka), f0 (1/ka), flow (1/ka), fhigh (1/ka)\n    test_cases = [\n        (0.0, 1.0, 3.0, 1.0, 10.0),\n        (5.0, 1.0, 2.0, 1.0, 5.0),\n        (2.0, 50.0, 2.0, 1.0, 5.0),\n        (10.0, 0.5, 0.1, 0.05, 0.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        sigma_z, r_sed, f0, f_low, f_high = case\n\n        # Calculate temporal standard deviation sigma_t in ka\n        # Handle potential division by zero, although not in test cases\n        if r_sed == 0:\n            # Infinite smoothing, only DC component remains\n            sigma_t = float('inf')\n        else:\n            sigma_t = sigma_z / r_sed\n\n        # --- Part 1: Amplitude Attenuation Factor ---\n        if sigma_t == 0:\n            # No smoothing, so no attenuation\n            attenuation_factor = 1.0\n        else:\n            # Formula: exp(-2 * pi^2 * f0^2 * sigma_t^2)\n            exponent = -2 * (np.pi**2) * (f0**2) * (sigma_t**2)\n            attenuation_factor = np.exp(exponent)\n\n        # --- Part 2: Fraction of Variance Retained ---\n        if sigma_t == 0:\n            # No smoothing, so 100% of variance is retained\n            variance_fraction = 1.0\n        else:\n            # The band must have a non-zero width\n            if f_high == f_low:\n                # In the limit of a zero-width band, the fraction is just the power attenuation at that frequency\n                power_atten = np.exp(-4 * (np.pi**2) * (f_low**2) * (sigma_t**2))\n                variance_fraction = power_atten\n            else:\n                # Formula uses the error function (erf)\n                # Fraction = (sqrt(pi) / (4*pi*sigma_t*(f_high-f_low))) * [erf(2*pi*sigma_t*f_high) - erf(2*pi*sigma_t*f_low)]\n                # Let const = 2 * pi * sigma_t\n                const = 2 * np.pi * sigma_t\n                \n                numerator = np.sqrt(np.pi) * (erf(const * f_high) - erf(const * f_low))\n                denominator = 2 * const * (f_high - f_low)\n\n                if denominator == 0:\n                    # Should be handled by f_high == f_low case, but as a safeguard\n                    variance_fraction = 1.0\n                else:\n                    variance_fraction = numerator / denominator\n        \n        results.append([attenuation_factor, variance_fraction])\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) will convert each sublist like [0.1, 0.2] to its string representation '[0.1, 0.2]'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "古气候重建的核心挑战在于如何利用稀疏、不均匀且充满噪声的代用指标数据，来“反演”出一个时空连续的完整气候场。这本质上是一个数学上的“不适定反问题”，直接求解往往会导致结果极不稳定且被噪声淹没。本练习将指导您动手实现“吉洪诺夫正则化”（Tikhonov regularization），这是一种解决此类反问题的经典且强大的方法。通过编写代码并调整正则化参数 $\\lambda$ ，您将直观地体验到在“忠于数据”与“解的平滑性”之间进行权衡的艺术，这是所有现代气候重建方法的基石。",
            "id": "4073786",
            "problem": "考虑一个线性古气候代用指标正演模型，其中潜在气候状态 $x \\in \\mathbb{R}^{n}$（无量纲温度异常）通过一个已知的平滑算子 $H \\in \\mathbb{R}^{m \\times n}$ 被映射到代用指标观测值 $y \\in \\mathbb{R}^{m}$（无量纲代用指标异常），并带有加性确定性噪声 $\\epsilon \\in \\mathbb{R}^{m}$。所有量均为无量纲。出现在三角函数内的角度必须以弧度解释。正演模型定义为 $y = H x + \\epsilon$。您的任务是针对正则化参数 $\\lambda$ 的指定值计算正则化重建 $\\hat{x}$，然后评估重建误差指标。重建应通过最小化二次吉洪诺夫泛函 $J(x) = \\lVert H x - y \\rVert_2^2 + \\lambda^2 \\lVert L x \\rVert_2^2$ 来获得，其中 $L$ 是一个一阶差分算子，用于惩罚 $x$ 的粗糙度。\n\n使用以下具有科学依据且完全指定的设置：\n\n- 状态维度：$n = 64$。观测维度：$m = 48$。\n- 状态的离散时间索引：$t_j = j$，其中 $j = 0, 1, \\dots, n-1$。\n- 代用指标的离散时间索引：$p_i = i \\cdot \\frac{n}{m}$，其中 $i = 0, 1, \\dots, m-1$。\n- 平滑尺度（高斯核标准差）：$\\ell = 3.0$。\n- 正演算子 $H$ 的条目为\n$$\nH_{i j} = \\frac{\\exp\\!\\left(-\\frac{(p_i - t_j)^2}{2 \\ell^2}\\right)}{\\sum_{k=0}^{n-1} \\exp\\!\\left(-\\frac{(p_i - t_k)^2}{2 \\ell^2}\\right)} \\quad \\text{for } i = 0, \\dots, m-1,\\; j = 0, \\dots, n-1,\n$$\n即，$H$ 的每一行对以 $p_i$ 为中心的 $x$ 应用一个归一化的高斯加权平均。\n- 一阶差分正则化算子 $L \\in \\mathbb{R}^{(n-1) \\times n}$ 由以下公式给出\n$$\n(L x)_k = x_{k+1} - x_k \\quad \\text{for } k = 0, 1, \\dots, n-2.\n$$\n等价地，$L_{k,k} = -1$，$L_{k,k+1} = 1$，所有其他条目均为 $0$。\n- 真实状态 $x^{\\star} \\in \\mathbb{R}^n$ 由正弦和余弦函数的和定义：\n$$\nx^{\\star}_j = \\sin\\!\\left(\\frac{2 \\pi \\cdot 3 \\cdot j}{n}\\right) + 0.6 \\cos\\!\\left(\\frac{2 \\pi \\cdot 9 \\cdot j}{n}\\right) + 0.3 \\sin\\!\\left(\\frac{2 \\pi \\cdot 15 \\cdot j}{n}\\right), \\quad j = 0, 1, \\dots, n-1.\n$$\n- 确定性观测噪声为\n$$\n\\epsilon_i = 0.03 \\left[\\sin\\!\\left(0.37 \\cdot i \\right) + 0.5 \\cos\\!\\left(0.13 \\cdot i \\right)\\right], \\quad i = 0, 1, \\dots, m-1.\n$$\n- 观测值由 $y = H x^{\\star} + \\epsilon$ 给出。\n\n对于每个指定的正则化强度 $\\lambda$，计算最小化 $J(x)$ 的正则化解 $\\hat{x}$，然后评估以下误差指标：\n- 相对重建误差\n$$\nE_{\\mathrm{rel}}(\\hat{x}) = \\frac{\\lVert \\hat{x} - x^{\\star} \\rVert_2}{\\lVert x^{\\star} \\rVert_2}.\n$$\n- 归一化均方根误差（NRMSE），定义为\n$$\nE_{\\mathrm{nrmse}}(\\hat{x}) = \\frac{\\sqrt{\\frac{1}{n} \\sum_{j=0}^{n-1} \\left( \\hat{x}_j - x^{\\star}_j \\right)^2}}{\\sqrt{\\frac{1}{n} \\sum_{j=0}^{n-1} \\left( x^{\\star}_j - \\bar{x}^{\\star} \\right)^2}},\n$$\n其中 $\\bar{x}^{\\star} = \\frac{1}{n} \\sum_{j=0}^{n-1} x^{\\star}_j$ 是 $x^{\\star}$ 的平均值。\n- 每个观测的数据失配度\n$$\nE_{\\mathrm{misfit}}(\\hat{x}) = \\frac{\\lVert H \\hat{x} - y \\rVert_2}{\\sqrt{m}}.\n$$\n- 粗糙度比率\n$$\nE_{\\mathrm{rough}}(\\hat{x}) = \\frac{\\lVert L \\hat{x} \\rVert_2}{\\lVert L x^{\\star} \\rVert_2}.\n$$\n\n测试套件：\n- 案例1：$\\lambda = 10^{-6}$。\n- 案例2：$\\lambda = 10^{-2}$。\n- 案例3：$\\lambda = 5 \\cdot 10^{-1}$。\n\n您的程序必须：\n- 完全按照上述定义构造 $H$、$L$、$x^{\\star}$、$\\epsilon$ 和 $y$。\n- 对于每个测试案例，根据定义计算 $J(x)$ 的一个数值上精确的最小化子 $\\hat{x}$。\n- 按顺序 $\\left[E_{\\mathrm{rel}}, E_{\\mathrm{nrmse}}, E_{\\mathrm{misfit}}, E_{\\mathrm{rough}}\\right]$ 计算每个案例的四个指标。\n- 生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个元素对应一个测试案例，并且本身是一个包含四个指标（四舍五入到六位小数）的列表。最终输出格式必须严格为\n$$\n\\left[ [e_{11}, e_{12}, e_{13}, e_{14}], [e_{21}, e_{22}, e_{23}, e_{24}], [e_{31}, e_{32}, e_{33}, e_{34}] \\right]\n$$\n打印为单行，不含空格，例如\n$$\n\\left[[0.123456,0.234567,0.345678,0.456789],[\\dots],[\\dots]\\right].\n$$",
            "solution": "问题陈述经评估有效。它具有科学依据、数学上适定、客观且自成体系。它提出了一个针对线性反演模型的标准吉洪诺夫正则化问题，这是科学计算和数据分析中的一个常见任务，其中所有参数、算子和函数都有明确定义。不存在矛盾、歧义或谬误。\n\n任务是找到状态向量 $\\hat{x} \\in \\mathbb{R}^n$，以最小化吉洪诺夫泛函 $J(x)$：\n$$\nJ(x) = \\lVert H x - y \\rVert_2^2 + \\lambda^2 \\lVert L x \\rVert_2^2\n$$\n其中 $H \\in \\mathbb{R}^{m \\times n}$ 是正演算子，$y \\in \\mathbb{R}^m$ 是观测向量，$L \\in \\mathbb{R}^{(n-1) \\times n}$ 是正则化算子，$\\lambda$ 是正则化参数。所有量均在问题描述中提供。\n\n泛函 $J(x)$ 是 $x$ 的二次函数。存在唯一的最小化子 $\\hat{x}$，可通过计算 $J(x)$ 相对于 $x$ 的梯度并将其设为零来找到。首先，我们使用转置展开欧几里得范数的平方：\n$$\nJ(x) = (H x - y)^T (H x - y) + \\lambda^2 (L x)^T (L x)\n$$\n展开乘积得到：\n$$\nJ(x) = (x^T H^T - y^T)(H x - y) + \\lambda^2 x^T L^T L x\n$$\n$$\nJ(x) = x^T H^T H x - x^T H^T y - y^T H x + y^T y + \\lambda^2 x^T L^T L x\n$$\n由于 $y^T H x$ 是一个标量，它等于其转置，即 $(y^T H x)^T = x^T H^T y$。因此，我们可以合并交叉项：\n$$\nJ(x) = x^T (H^T H + \\lambda^2 L^T L) x - 2 y^T H x + y^T y\n$$\n$J(x)$ 相对于向量 $x$ 的梯度是：\n$$\n\\nabla_x J(x) = \\frac{\\partial}{\\partial x} \\left( x^T (H^T H + \\lambda^2 L^T L) x - 2 (H^T y)^T x + y^T y \\right)\n$$\n使用向量微积分的标准法则，特别是对于对称矩阵 $A$，有 $\\nabla_x(x^T A x) = 2Ax$ 和 $\\nabla_x(b^T x) = b$，我们得到：\n$$\n\\nabla_x J(x) = 2 (H^T H + \\lambda^2 L^T L) x - 2 H^T y\n$$\n将梯度设为零向量，$\\nabla_x J(\\hat{x}) = 0$，得到称为正则化问题的正规方程的线性方程组：\n$$\n(H^T H + \\lambda^2 L^T L) \\hat{x} = H^T y\n$$\n这是一个形式为 $A\\hat{x} = b$ 的线性系统，其中矩阵 $A = H^T H + \\lambda^2 L^T L$ 是一个 $n \\times n$ 矩阵，向量 $b = H^T y$ 的大小为 $n \\times 1$。对于任何 $\\lambda > 0$，矩阵 $A$ 都是对称正定的，这保证了唯一且稳定的解 $\\hat{x}$ 的存在。该解可以通过数值求解线性系统来找到。\n\n计算过程如下：\n1. 按照规定构造向量和矩阵：状态时间索引 $t_j$、代用指标时间索引 $p_i$、真实状态 $x^{\\star}$、噪声向量 $\\epsilon$、正演算子 $H$ 和正则化算子 $L$。\n2. 计算观测向量 $y = H x^{\\star} + \\epsilon$。\n3. 对于测试套件中给定的每个正则化参数 $\\lambda$ 值：\n    a. 构成 $n \\times n$ 矩阵 $A = H^T H + \\lambda^2 L^T L$。\n    b. 构成 $n \\times 1$ 向量 $b = H^T y$。\n    c. 求解线性系统 $A\\hat{x} = b$ 以获得重建状态 $\\hat{x}$。\n    d. 使用计算出的 $\\hat{x}$ 和已知的真实状态 $x^{\\star}$，计算四个指定的误差指标：相对重建误差 $E_{\\mathrm{rel}}(\\hat{x})$、归一化均方根误差 $E_{\\mathrm{nrmse}}(\\hat{x})$、每个观测的数据失配度 $E_{\\mathrm{misfit}}(\\hat{x})$ 和粗糙度比率 $E_{\\mathrm{rough}}(\\hat{x})$。\n4. 收集每个测试案例的最终结果，并按规定格式化。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Tikhonov-regularized paleoclimate reconstruction problem\n    and computes the specified error metrics for different regularization strengths.\n    \"\"\"\n    \n    # Define the test cases (regularization parameters) from the problem statement.\n    test_cases = [1e-6, 1e-2, 5e-1]\n\n    # --- Step 1: Construct all specified model components ---\n\n    # Define dimensions and parameters\n    n = 64  # State dimension\n    m = 48  # Observation dimension\n    l_scale = 3.0  # Smoothing scale\n\n    # Define discrete time indices\n    t = np.arange(n, dtype=np.float64)\n    p = np.arange(m, dtype=np.float64) * (n / m)\n\n    # Construct the forward operator H\n    # Using broadcasting: p[:, None] is (m, 1), t[None, :] is (1, n)\n    h_numerator = np.exp(-(p[:, None] - t[None, :])**2 / (2 * l_scale**2))\n    h_denominator = np.sum(h_numerator, axis=1, keepdims=True)\n    H = h_numerator / h_denominator\n\n    # Construct the first-difference regularization operator L\n    L = np.zeros((n - 1, n), dtype=np.float64)\n    rows = np.arange(n - 1)\n    L[rows, rows] = -1.0\n    L[rows, rows + 1] = 1.0\n\n    # Construct the true state x_star\n    j_indices = np.arange(n, dtype=np.float64)\n    x_star = (np.sin(2 * np.pi * 3 * j_indices / n) +\n              0.6 * np.cos(2 * np.pi * 9 * j_indices / n) +\n              0.3 * np.sin(2 * np.pi * 15 * j_indices / n))\n\n    # Construct the deterministic observation noise epsilon\n    i_indices = np.arange(m, dtype=np.float64)\n    epsilon = 0.03 * (np.sin(0.37 * i_indices) + 0.5 * np.cos(0.13 * i_indices))\n\n    # Construct the observations y\n    y = H @ x_star + epsilon\n\n    # --- Step 2: Pre-compute components for efficiency ---\n\n    # Pre-calculate norms of true state components for metric calculations\n    norm_x_star = np.linalg.norm(x_star)\n    # Denominator for NRMSE: ||x* - mean(x*)||_2\n    norm_x_star_centered = np.linalg.norm(x_star - np.mean(x_star))\n    norm_Lx_star = np.linalg.norm(L @ x_star)\n    \n    # Pre-compute matrix products for the normal equations\n    HTH = H.T @ H\n    LTL = L.T @ L\n    HTy = H.T @ y\n\n    all_case_results = []\n    \n    # --- Step 3: Loop through test cases, solve, and evaluate metrics ---\n\n    for lam in test_cases:\n        # Form the system matrix for the normal equations\n        A = HTH + lam**2 * LTL\n        \n        # Solve the linear system A * x_hat = HTy for x_hat\n        x_hat = np.linalg.solve(A, HTy)\n\n        # Calculate the four error metrics\n        # 1. Relative reconstruction error\n        E_rel = np.linalg.norm(x_hat - x_star) / norm_x_star\n\n        # 2. Normalized root-mean-square error (NRMSE)\n        # NRMSE = RMSE(x_hat, x_star) / std(x_star)\n        # This is equivalent to norm(x_hat - x_star) / norm(x_star - mean(x_star))\n        E_nrmse = np.linalg.norm(x_hat - x_star) / norm_x_star_centered\n        \n        # 3. Data misfit per observation\n        E_misfit = np.linalg.norm(H @ x_hat - y) / np.sqrt(m)\n        \n        # 4. Roughness ratio\n        E_rough = np.linalg.norm(L @ x_hat) / norm_Lx_star\n\n        all_case_results.append([E_rel, E_nrmse, E_misfit, E_rough])\n\n    # --- Step 4: Format and print the final output ---\n\n    # Format each list of metrics into a comma-separated string rounded to 6 decimal places\n    case_strings = [f\"[{','.join(f'{value:.6f}' for value in metrics)}]\" for metrics in all_case_results]\n    \n    # Join all case strings into the final required format\n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}