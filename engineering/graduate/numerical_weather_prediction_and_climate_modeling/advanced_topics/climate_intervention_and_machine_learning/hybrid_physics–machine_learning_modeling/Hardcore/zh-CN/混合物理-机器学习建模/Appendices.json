{
    "hands_on_practices": [
        {
            "introduction": "将物理定律作为软约束整合到机器学习模型的训练过程中，是一种强大而灵活的混合建模策略。这种方法通过在损失函数中加入一个惩罚项来实现，该惩罚项用于惩罚对物理守恒律的违反。本练习将指导您构建一个复合损失函数，该函数不仅衡量模型预测与“真实”数据之间的监督误差，还量化模型对热力学第一定律（以湿静力能量收支形式体现）的遵守程度，从而引导模型在学习数据模式的同时发现符合物理原理的解。",
            "id": "4052750",
            "problem": "您正在为用于数值天气预报 (NWP) 和气候模拟的单柱模式 (SCM) 设计一种混合物理-机器学习 (ML) 参数化方案。该 ML 组件预测温度和比湿的逐层倾向，并且必须通过闭合湿静力能量收支来遵守湿空气的热力学第一定律。您的任务是推导、实现并评估一个复合损失函数，该函数同时惩罚监督误差和对湿静力能量闭合的违背。\n\n从以下基本原理开始。考虑应用于具有恒定重力加速度的湿空气的固定高度欧拉控制体积的热力学第一定律。定义湿静力能为 $$s = c_p T + g z + L_v q,$$，其中 $T$ 是温度，$z$ 是几何高度，$q$ 是比湿，$c_p$ 是空气定压比热容，$g$ 是重力加速度，$L_v$ 是蒸发潜热。在 $z$ 不随时间变化的固定高度层中，局地湿静力能倾向简化为 $$\\frac{\\partial s}{\\partial t} = c_p \\frac{\\partial T}{\\partial t} + L_v \\frac{\\partial q}{\\partial t}.$$ 在不考虑平流，而专注于 ML 模型学习的次网格和辐射过程时，局地收支的闭合要求单位质量的非绝热源（记为 $H$，单位为 $\\mathrm{W\\,kg^{-1}}$）满足 $$c_p \\frac{\\partial T}{\\partial t} + L_v \\frac{\\partial q}{\\partial t} = H.$$\n\n您将构建一个由两部分组成的复合损失：监督数据损失和物理闭合正则化。监督数据损失将 ML 预测的倾向 $\\widehat{\\partial T/\\partial t}$ 和 $\\widehat{\\partial q/\\partial t}$ 与每层的观测目标倾向 $y_T$ 和 $y_q$ 进行比较。物理损失使用残差 $$r = c_p \\widehat{\\frac{\\partial T}{\\partial t}} + L_v \\widehat{\\frac{\\partial q}{\\partial t}} - H.$$ 来惩罚湿静力能量收支的不闭合。该残差必须在各层上进行质量加权，以表示一个整层积分的惩罚项。对于一个离散为由索引 $i$ 标记的多个层的气柱，层密度为 $\\rho_i$，厚度为 $\\Delta z_i$，单位面积质量为 $w_i = \\rho_i \\Delta z_i$，整层平均平方残差应按 $w_i$ 加权。\n\n定义您的程序必须为每个测试用例计算的以下复合损失：\n- 监督数据损失为\n$$L_{\\text{data}} = \\frac{1}{N} \\sum_{i=1}^{N} \\left[ \\left( \\frac{\\widehat{T}_i - y_{T,i}}{S_T} \\right)^2 + \\beta \\left( \\frac{\\widehat{q}_i - y_{q,i}}{S_q} \\right)^2 \\right],$$\n其中 $N$ 是层数，$\\widehat{T}_i = \\widehat{\\partial T/\\partial t}$ 是第 $i$ 层的温度倾向（单位为 $\\mathrm{K\\,s^{-1}}$），$\\widehat{q}_i = \\widehat{\\partial q/\\partial t}$ 是第 $i$ 层的比湿倾向（单位为 $\\mathrm{s^{-1}}$，因为 $q$ 是无量纲的，单位为 $\\mathrm{kg\\,kg^{-1}}$），$y_{T,i}$ 和 $y_{q,i}$ 是相应的观测目标，$S_T$ 和 $S_q$ 是用于使各项无量纲化的缩放参数，$\\beta$ 是一个相对权重参数。\n- 物理闭合损失为\n$$L_{\\text{phys}} = \\frac{\\sum_{i=1}^{N} w_i \\, r_i^2}{\\left(\\sum_{i=1}^{N} w_i\\right) \\, H_{\\text{scale}}^2},$$\n其中 $r_i = c_p \\widehat{T}_i + L_v \\widehat{q}_i - H_i$，$w_i = \\rho_i \\Delta z_i$，$H_{\\text{scale}}$ 是用于无量纲化的固定缩放常数。\n- 总损失为\n$$L_{\\text{total}} = L_{\\text{data}} + \\lambda \\, L_{\\text{phys}},$$\n其中 $\\lambda$ 是一个非负调谐参数。\n\n在所有计算中使用以下常数（以国际单位制表示）：\n- $c_p = 1004 \\ \\mathrm{J\\,kg^{-1}\\,K^{-1}}$,\n- $L_v = 2.5 \\times 10^6 \\ \\mathrm{J\\,kg^{-1}}$,\n- $g = 9.81 \\ \\mathrm{m\\,s^{-2}}$ (注意，由于 $z$ 是固定的，因此不会直接使用 $g$),\n- $S_T = 1.0 \\times 10^{-5} \\ \\mathrm{K\\,s^{-1}}$,\n- $S_q = 1.0 \\times 10^{-8} \\ \\mathrm{s^{-1}}$,\n- $\\beta = 1$,\n- $H_{\\text{scale}} = 5.0 \\times 10^{-2} \\ \\mathrm{W\\,kg^{-1}}$,\n- $\\lambda = 10$.\n\n实现一个程序，为以下每个测试用例计算 $L_{\\text{total}}$。所有数组都按层索引 $i$ 的递增顺序列出，每个条目都是一个层的值。单位必须严格按照规定使用。\n\n测试用例 A（理想情况，精确闭合但有非零监督误差）：\n- 层数 $N = 3$。\n- 层厚度 $\\Delta z = [1000, 1000, 1000] \\ \\mathrm{m}$。\n- 层密度 $\\rho = [1.2, 0.9, 0.7] \\ \\mathrm{kg\\,m^{-3}}$。\n- ML预测的温度倾向 $\\widehat{T} = [1.0 \\times 10^{-5}, 1.2 \\times 10^{-5}, 0.8 \\times 10^{-5}] \\ \\mathrm{K\\,s^{-1}}$。\n- ML预测的比湿倾向 $\\widehat{q} = [1.0 \\times 10^{-8}, 0.5 \\times 10^{-8}, 0.0 \\times 10^{-8}] \\ \\mathrm{s^{-1}}$。\n- 为满足逐层精确闭合而构造的已知非绝热源 $H$：\n  - $H = [0.03504, 0.024548, 0.008032] \\ \\mathrm{W\\,kg^{-1}}$。\n- 观测的目标倾向 $y_T = [1.1 \\times 10^{-5}, 1.1 \\times 10^{-5}, 0.9 \\times 10^{-5}] \\ \\mathrm{K\\,s^{-1}}$，$y_q = [0.8 \\times 10^{-8}, 0.6 \\times 10^{-8}, 0.1 \\times 10^{-8}] \\ \\mathrm{s^{-1}}$。\n\n测试用例 B（强烈的物理违背和监督差异）：\n- 层数 $N = 3$。\n- 层厚度 $\\Delta z = [800, 1200, 1500] \\ \\mathrm{m}$。\n- 层密度 $\\rho = [1.0, 0.8, 0.6] \\ \\mathrm{kg\\,m^{-3}}$。\n- ML预测的温度倾向 $\\widehat{T} = [2.0 \\times 10^{-5}, -0.5 \\times 10^{-5}, 0.0 \\times 10^{-5}] \\ \\mathrm{K\\,s^{-1}}$。\n- ML预测的比湿倾向 $\\widehat{q} = [2.0 \\times 10^{-8}, -1.0 \\times 10^{-8}, 0.5 \\times 10^{-8}] \\ \\mathrm{s^{-1}}$。\n- 已知非绝热源 $H = [0.005, 0.0, -0.002] \\ \\mathrm{W\\,kg^{-1}}$。\n- 观测的目标倾向 $y_T = [1.5 \\times 10^{-5}, -0.4 \\times 10^{-5}, 0.2 \\times 10^{-5}] \\ \\mathrm{K\\,s^{-1}}$，$y_q = [1.5 \\times 10^{-8}, -1.2 \\times 10^{-8}, 0.4 \\times 10^{-8}] \\ \\mathrm{s^{-1}}$。\n\n测试用例 C（边界情况：单干燥层，平凡的闭合和监督）：\n- 层数 $N = 1$。\n- 层厚度 $\\Delta z = [500] \\ \\mathrm{m}$。\n- 层密度 $\\rho = [1.1] \\ \\mathrm{kg\\,m^{-3}}$。\n- ML预测的温度倾向 $\\widehat{T} = [0.0] \\ \\mathrm{K\\,s^{-1}}$。\n- ML预测的比湿倾向 $\\widehat{q} = [0.0] \\ \\mathrm{s^{-1}}$。\n- 已知非绝热源 $H = [0.0] \\ \\mathrm{W\\,kg^{-1}}$。\n- 观测的目标倾向 $y_T = [0.0] \\ \\mathrm{K\\,s^{-1}}$，$y_q = [0.0] \\ \\mathrm{s^{-1}}$。\n\n测试用例 D（边界情况：完美的监督和精确的闭合）：\n- 层数 $N = 2$。\n- 层厚度 $\\Delta z = [1000, 1000] \\ \\mathrm{m}$。\n- 层密度 $\\rho = [1.1, 0.9] \\ \\mathrm{kg\\,m^{-3}}$。\n- ML预测的温度倾向 $\\widehat{T} = [1.0 \\times 10^{-5}, -1.0 \\times 10^{-5}] \\ \\mathrm{K\\,s^{-1}}$。\n- ML预测的比湿倾向 $\\widehat{q} = [1.0 \\times 10^{-8}, 2.0 \\times 10^{-8}] \\ \\mathrm{s^{-1}}$。\n- 已知非绝热源 $H = [0.03504, 0.03996] \\ \\mathrm{W\\,kg^{-1}}$。\n- 观测的目标倾向 $y_T = [1.0 \\times 10^{-5}, -1.0 \\times 10^{-5}] \\ \\mathrm{K\\,s^{-1}}$，$y_q = [1.0 \\times 10^{-8}, 2.0 \\times 10^{-8}] \\ \\mathrm{s^{-1}}$。\n\n您的程序必须为每个测试用例计算 $L_{\\text{total}}$，并生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[ \\ell_A, \\ell_B, \\ell_C, \\ell_D ]$，其中每个 $\\ell$ 是一个浮点值。不允许有其他输出。所有计算都必须以国际单位制进行，并且输出应严格按照此处描述的单行格式打印。",
            "solution": "该问题在科学和数学上是有效的。它定义明确、自成体系，并基于大气热力学和物理学启发的机器学习原理。所有常数、变量和函数形式都已明确定义，提供的测试用例包含了唯一解所需的所有数据。我们将进行计算。\n\n目标是为四个不同的测试用例计算总损失函数 $L_{\\text{total}}$。该损失函数是监督数据损失分量 $L_{\\text{data}}$ 和基于物理的闭合损失分量 $L_{\\text{phys}}$ 的复合。总损失定义为加权和：\n$$L_{\\text{total}} = L_{\\text{data}} + \\lambda \\, L_{\\text{phys}}$$\n\n监督数据损失 $L_{\\text{data}}$ 量化了 ML 预测倾向与观测目标倾向之间的均方误差，并由缩放因子进行归一化。对于具有 $N$ 层的气柱，其公式为：\n$$L_{\\text{data}} = \\frac{1}{N} \\sum_{i=1}^{N} \\left[ \\left( \\frac{\\widehat{T}_i - y_{T,i}}{S_T} \\right)^2 + \\beta \\left( \\frac{\\widehat{q}_i - y_{q,i}}{S_q} \\right)^2 \\right]$$\n其中 $\\widehat{T}_i$ 和 $\\widehat{q}_i$ 是第 $i$ 层温度和比湿的预测倾向，$y_{T,i}$ 和 $y_{q,i}$ 是相应的观测目标，$S_T$ 和 $S_q$ 是归一化尺度，$\\beta$ 是相对权重因子。\n\n物理闭合损失 $L_{\\text{phys}}$ 惩罚对湿静力能量收支的违背。它被表述为能量守恒方程的质量加权、归一化的均方残差：\n$$L_{\\text{phys}} = \\frac{\\sum_{i=1}^{N} w_i \\, r_i^2}{\\left(\\sum_{i=1}^{N} w_i\\right) \\, H_{\\text{scale}}^2}$$\n每层的物理残差为 $r_i = c_p \\widehat{T}_i + L_v \\widehat{q}_i - H_i$，其中 $H_i$ 是已知的非绝热源。每层的质量权重为 $w_i = \\rho_i \\Delta z_i$，其中 $\\rho_i$ 是层密度，$\\Delta z_i$ 是层厚度。$H_{\\text{scale}}$ 是用于无量纲化的常数。\n\n计算将使用指定的以下国际单位制常数：\n- 空气定压比热容，$c_p = 1004 \\ \\mathrm{J\\,kg^{-1}\\,K^{-1}}$\n- 蒸发潜热，$L_v = 2.5 \\times 10^6 \\ \\mathrm{J\\,kg^{-1}}$\n- 温度倾向尺度，$S_T = 1.0 \\times 10^{-5} \\ \\mathrm{K\\,s^{-1}}$\n- 比湿倾向尺度，$S_q = 1.0 \\times 10^{-8} \\ \\mathrm{s^{-1}}$\n- 数据损失湿度权重，$\\beta = 1$\n- 物理损失尺度，$H_{\\text{scale}} = 5.0 \\times 10^{-2} \\ \\mathrm{W\\,kg^{-1}}$\n- 物理损失权重，$\\lambda = 10$\n\n我们现在为每个测试用例计算 $L_{\\text{total}}$。\n\n**测试用例 A**\n模型有 $N=3$ 层。问题陈述指出，非绝热源 $H_i$ 是为精确闭合而构造的，这意味着对所有 $i$ 都有物理残差 $r_i=0$。\n首先，我们验证层 $i=1$ 的这个属性：\n$r_1 = c_p \\widehat{T}_1 + L_v \\widehat{q}_1 - H_1 = (1004)(1.0 \\times 10^{-5}) + (2.5 \\times 10^6)(1.0 \\times 10^{-8}) - 0.03504 = 0.01004 + 0.025 - 0.03504 = 0$。\n根据构造，层 $i=2$ 和 $i=3$ 的残差也为 $0$。因此，$L_{\\text{phys}} = 0$。\n\n接下来，我们计算 $L_{\\text{data}}$：\n温度的逐层归一化平方误差为：\n$\\left( \\frac{(1.0 - 1.1) \\times 10^{-5}}{1.0 \\times 10^{-5}} \\right)^2 = (-0.1)^2 = 0.01$\n$\\left( \\frac{(1.2 - 1.1) \\times 10^{-5}}{1.0 \\times 10^{-5}} \\right)^2 = (0.1)^2 = 0.01$\n$\\left( \\frac{(0.8 - 0.9) \\times 10^{-5}}{1.0 \\times 10^{-5}} \\right)^2 = (-0.1)^2 = 0.01$\n比湿的逐层归一化平方误差为：\n$\\left( \\frac{(1.0 - 0.8) \\times 10^{-8}}{1.0 \\times 10^{-8}} \\right)^2 = (0.2)^2 = 0.04$\n$\\left( \\frac{(0.5 - 0.6) \\times 10^{-8}}{1.0 \\times 10^{-8}} \\right)^2 = (-0.1)^2 = 0.01$\n$\\left( \\frac{(0.0 - 0.1) \\times 10^{-8}}{1.0 \\times 10^{-8}} \\right)^2 = (-0.1)^2 = 0.01$\n当 $\\beta=1$ 时，逐层损失项的总和为 $(0.01 + 0.04) + (0.01 + 0.01) + (0.01 + 0.01) = 0.05 + 0.02 + 0.02 = 0.09$。\n$L_{\\text{data}} = \\frac{1}{3} \\times 0.09 = 0.03$。\n$L_{\\text{total, A}} = L_{\\text{data}} + \\lambda L_{\\text{phys}} = 0.03 + (10)(0) = 0.03$。\n\n**测试用例 B**\n模型有 $N=3$ 层。\n首先，我们计算 $L_{\\text{data}}$：\n逐层归一化平方误差为：\n$i=1: \\left(\\frac{(2.0 - 1.5) \\times 10^{-5}}{1.0 \\times 10^{-5}}\\right)^2 + 1 \\cdot \\left(\\frac{(2.0 - 1.5) \\times 10^{-8}}{1.0 \\times 10^{-8}}\\right)^2 = (0.5)^2 + (0.5)^2 = 0.25 + 0.25 = 0.5$。\n$i=2: \\left(\\frac{(-0.5 - (-0.4)) \\times 10^{-5}}{1.0 \\times 10^{-5}}\\right)^2 + 1 \\cdot \\left(\\frac{(-1.0 - (-1.2)) \\times 10^{-8}}{1.0 \\times 10^{-8}}\\right)^2 = (-0.1)^2 + (0.2)^2 = 0.01 + 0.04 = 0.05$。\n$i=3: \\left(\\frac{(0.0 - 0.2) \\times 10^{-5}}{1.0 \\times 10^{-5}}\\right)^2 + 1 \\cdot \\left(\\frac{(0.5 - 0.4) \\times 10^{-8}}{1.0 \\times 10^{-8}}\\right)^2 = (-0.2)^2 + (0.1)^2 = 0.04 + 0.01 = 0.05$。\n$L_{\\text{data}} = \\frac{1}{3} (0.5 + 0.05 + 0.05) = \\frac{0.6}{3} = 0.2$。\n\n接下来，我们计算 $L_{\\text{phys}}$：\n层质量权重 $w_i = \\rho_i \\Delta z_i$：\n$w_1 = (1.0)(800) = 800 \\ \\mathrm{kg\\,m^{-2}}$。\n$w_2 = (0.8)(1200) = 960 \\ \\mathrm{kg\\,m^{-2}}$。\n$w_3 = (0.6)(1500) = 900 \\ \\mathrm{kg\\,m^{-2}}$。\n总质量 $\\sum w_i = 800 + 960 + 900 = 2660 \\ \\mathrm{kg\\,m^{-2}}$。\n物理残差 $r_i = c_p \\widehat{T}_i + L_v \\widehat{q}_i - H_i$：\n$r_1 = (1004)(2.0 \\times 10^{-5}) + (2.5 \\times 10^6)(2.0 \\times 10^{-8}) - 0.005 = 0.02008 + 0.05 - 0.005 = 0.06508$。\n$r_2 = (1004)(-0.5 \\times 10^{-5}) + (2.5 \\times 10^6)(-1.0 \\times 10^{-8}) - 0.0 = -0.00502 - 0.025 = -0.03002$。\n$r_3 = (1004)(0.0) + (2.5 \\times 10^6)(0.5 \\times 10^{-8}) - (-0.002) = 0 + 0.0125 + 0.002 = 0.0145$。\n$L_{\\text{phys}}$ 的分子：$\\sum w_i r_i^2 = 800(0.06508)^2 + 960(-0.03002)^2 + 900(0.0145)^2 \\approx 3.38833 + 0.86515 + 0.189225 = 4.4427$。\n$L_{\\text{phys}}$ 的分母：$(\\sum w_i) H_{\\text{scale}}^2 = (2660)(5.0 \\times 10^{-2})^2 = 2660 \\times 0.0025 = 6.65$。\n$L_{\\text{phys}} \\approx 4.4427 / 6.65 \\approx 0.6680756$。\n$L_{\\text{total, B}} = L_{\\text{data}} + \\lambda L_{\\text{phys}} = 0.2 + 10(0.6680756) = 0.2 + 6.680756 = 6.880756$。\n\n**测试用例 C**\n这是一个单层情况 ($N=1$)，其中所有预测倾向、目标倾向和非绝热源都为零。\n$L_{\\text{data}}$：差值 $\\widehat{T}_1 - y_{T,1}$ 和 $\\widehat{q}_1 - y_{q,1}$ 均为 $0$。因此，$L_{\\text{data}} = 0$。\n$L_{\\text{phys}}$：残差 $r_1 = c_p(0) + L_v(0) - 0 = 0$。因此，$L_{\\text{phys}} = 0$。\n$L_{\\text{total, C}} = L_{\\text{data}} + \\lambda L_{\\text{phys}} = 0 + (10)(0) = 0$。\n\n**测试用例 D**\n这是一个 $N=2$ 层的情况，具有完美的监督（$\\widehat{T}_i = y_{T,i}$，$\\widehat{q}_i = y_{q,i}$）和精确的物理闭合。\n$L_{\\text{data}}$：由于所有层的预测倾向和目标倾向都相同，误差全为 $0$。因此，$L_{\\text{data}} = 0$。\n$L_{\\text{phys}}$：根据构造，闭合是精确的，意味着所有层的 $r_i=0$。我们可以验证层 $i=2$：\n$r_2 = (1004)(-1.0 \\times 10^{-5}) + (2.5 \\times 10^6)(2.0 \\times 10^{-8}) - 0.03996 = -0.01004 + 0.05 - 0.03996 = 0$。\n由于所有残差均为 $0$，$L_{\\text{phys}} = 0$。\n$L_{\\text{total, D}} = L_{\\text{data}} + \\lambda L_{\\text{phys}} = 0 + (10)(0) = 0$。\n\n结果摘要：\n- 测试用例 A: $L_{\\text{total}} = 0.03$\n- 测试用例 B: $L_{\\text{total}} \\approx 6.880756$\n- 测试用例 C: $L_{\\text{total}} = 0.0$\n- 测试用例 D: $L_{\\text{total}} = 0.0$\n这些值将通过编程计算到机器精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the total loss for a hybrid physics-ML model for given test cases.\n    \"\"\"\n    # Define physical and model constants\n    c_p = 1004.0         # J kg^-1 K^-1\n    L_v = 2.5e6          # J kg^-1\n    S_T = 1.0e-5         # K s^-1\n    S_q = 1.0e-8         # s^-1\n    beta = 1.0           # dimensionless\n    H_scale = 5.0e-2     # W kg^-1\n    lambda_ = 10.0       # dimensionless\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {\n            \"N\": 3,\n            \"delta_z\": np.array([1000, 1000, 1000]),\n            \"rho\": np.array([1.2, 0.9, 0.7]),\n            \"T_hat\": np.array([1.0e-5, 1.2e-5, 0.8e-5]),\n            \"q_hat\": np.array([1.0e-8, 0.5e-8, 0.0e-8]),\n            \"H\": np.array([0.03504, 0.024548, 0.008032]),\n            \"y_T\": np.array([1.1e-5, 1.1e-5, 0.9e-5]),\n            \"y_q\": np.array([0.8e-8, 0.6e-8, 0.1e-8]),\n        },\n        # Test Case B\n        {\n            \"N\": 3,\n            \"delta_z\": np.array([800, 1200, 1500]),\n            \"rho\": np.array([1.0, 0.8, 0.6]),\n            \"T_hat\": np.array([2.0e-5, -0.5e-5, 0.0e-5]),\n            \"q_hat\": np.array([2.0e-8, -1.0e-8, 0.5e-8]),\n            \"H\": np.array([0.005, 0.0, -0.002]),\n            \"y_T\": np.array([1.5e-5, -0.4e-5, 0.2e-5]),\n            \"y_q\": np.array([1.5e-8, -1.2e-8, 0.4e-8]),\n        },\n        # Test Case C\n        {\n            \"N\": 1,\n            \"delta_z\": np.array([500]),\n            \"rho\": np.array([1.1]),\n            \"T_hat\": np.array([0.0]),\n            \"q_hat\": np.array([0.0]),\n            \"H\": np.array([0.0]),\n            \"y_T\": np.array([0.0]),\n            \"y_q\": np.array([0.0]),\n        },\n        # Test Case D\n        {\n            \"N\": 2,\n            \"delta_z\": np.array([1000, 1000]),\n            \"rho\": np.array([1.1, 0.9]),\n            \"T_hat\": np.array([1.0e-5, -1.0e-5]),\n            \"q_hat\": np.array([1.0e-8, 2.0e-8]),\n            \"H\": np.array([0.03504, 0.03996]),\n            \"y_T\": np.array([1.0e-5, -1.0e-5]),\n            \"y_q\": np.array([1.0e-8, 2.0e-8]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        T_hat = case[\"T_hat\"]\n        q_hat = case[\"q_hat\"]\n        y_T = case[\"y_T\"]\n        y_q = case[\"y_q\"]\n        delta_z = case[\"delta_z\"]\n        rho = case[\"rho\"]\n        H = case[\"H\"]\n\n        # 1. Compute L_data\n        term_T = ((T_hat - y_T) / S_T)**2\n        term_q = ((q_hat - y_q) / S_q)**2\n        L_data = (1.0 / N) * np.sum(term_T + beta * term_q)\n\n        # 2. Compute L_phys\n        # Physical residual for each layer\n        r = c_p * T_hat + L_v * q_hat - H\n        \n        # Mass weight for each layer\n        w = rho * delta_z\n        \n        # Mass-weighted squared residual sum (numerator)\n        numerator = np.sum(w * r**2)\n        \n        # Total mass and scaling (denominator)\n        denominator = np.sum(w) * (H_scale**2)\n        \n        # Handle case of zero denominator to avoid division by zero\n        if denominator == 0:\n            if numerator == 0:\n                L_phys = 0.0\n            else:\n                # This case implies non-zero residual with zero mass,\n                # which is physically ill-defined, but for numerical\n                # stability we can treat it as infinite penalty.\n                L_phys = np.inf\n        else:\n            L_phys = numerator / denominator\n\n        # 3. Compute L_total\n        L_total = L_data + lambda_ * L_phys\n        results.append(L_total)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了在训练中施加软约束，另一种更强的策略是将物理原理直接嵌入到模型的架构设计中，从而创造出“天生”满足某些物理属性的模型。这种方法可以提供硬约束，确保模型在任何情况下都不会产生物理上不合理的预测。本练习将探讨如何为湍流闭合方案构建一个保证正半定（PSD）的涡粘性张量，通过巧妙的参数化，确保模型预测的动能耗散率始终是非负的，这对于模拟的长期稳定性至关重要。",
            "id": "4052738",
            "problem": "考虑由不可压、滤波的Navier-Stokes方程控制的解析动力学，其中亚网格应力在二维空间中采用涡粘性封闭。设解析速度表示为 $\\mathbf{u}(\\mathbf{x},t)$，解析压力表示为 $p(\\mathbf{x},t)$，解析的对称应变率张量定义为 $S = (\\nabla \\mathbf{u} + \\nabla \\mathbf{u}^{\\top})/2$，其分量为 $S_{ij}$，$i,j \\in \\{x,y\\}$。解析动能密度为 $K = (1/2)\\,\\mathbf{u}\\cdot\\mathbf{u}$。需要构建一个混合物理-机器学习（ML）涡粘性封闭，以保证非负的能量耗散。该封闭在对称2阶张量空间上线性作用。为表示此线性作用，采用一种类Voigt向量化方法将 $S$ 表示为 $s \\in \\mathbb{R}^{3}$，即 $s = [S_{xx}, \\sqrt{2}\\,S_{xy}, S_{yy}]^{\\top}$，从而使得Frobenius内积 $S:S$ 等于 $s^{\\top}s$。\n\n涡粘性算子表示为一个作用于 $s$ 的对称矩阵 $A(\\mathbf{x}) \\in \\mathbb{R}^{3\\times 3}$。目标是设计 $A(\\mathbf{x})$ 使其为半正定（PSD），从而确保非负的动能耗散。\n\n第一部分（推导）：从不可压动量方程和解析动能密度 $K$ 的定义出发，推导由作用于 $s$ 上的线性对称涡粘性算子 $A$ 引起的逐点耗散密度表达式，并证明如果 $A$ 是半正定（PSD），则耗散密度为非负。您的推导必须从基本定律开始，特别是滤波后的不可压Navier-Stokes动量方程和 $K$ 的定义，并贯穿动能收支的分析。清晰地陈述为消除边界通量所需的任何边界条件假设。最后以一个陈述结束，说明为什么 $A$ 的半正定性质意味着非负的耗散密度。\n\n第二部分（参数化）：提出一种 $A$ 的参数化方法，保证对于任何无约束的机器学习输出，$A$ 都是半正定的。使用一个下三角矩阵 $L \\in \\mathbb{R}^{3\\times 3}$，其对角线元素通过光滑非线性函数约束为非负，并设\n$$\nA = L\\,L^{\\top} + \\nu_{0}\\,I,\n$$\n其中 $I$ 是 $3\\times 3$ 的单位矩阵，$\\nu_{0}\\ge 0$ 是一个来自物理的标量基准涡粘性。请具体说明如何从一个无约束向量 $z \\in \\mathbb{R}^{6}$ 构建 $L$，以及如何从特征 $x \\in \\mathbb{R}^{p}$ 构建 $\\nu_{0}$，从而使 $A$ 是半正定的。您的参数化必须包括：\n- 根据 $z$ 的分量定义 $L$，其中对角线元素使用如SoftPlus非线性函数（定义为 $\\mathrm{softplus}(a)=\\log(1+\\exp(a))$）等光滑函数强制为非负。\n- 根据通过 $\\mathrm{softplus}$ 函数的 $x$ 的线性映射来定义 $\\nu_{0}$。\n- 在对角线元素上添加一个小的正常数 $\\varepsilon$ 以确保数值稳定性。\n\n第三部分（实现）：实现一个程序，为几个测试用例构建 $A$，并使用第一部分推导的表达式验证非负耗散。对机器学习和物理组件使用以下规范：\n- 维度为二维，因此 $s\\in\\mathbb{R}^{3}$ 且 $A\\in\\mathbb{R}^{3\\times 3}$。\n- 给定特征 $x\\in\\mathbb{R}^{5}$，构建 $z = W\\,x + b \\in \\mathbb{R}^{6}$，其中\n$$\nW = \\begin{bmatrix}\n0.5  -0.3  0.1  0.0  0.2 \\\\\n-0.4  0.6  -0.2  0.1  -0.1 \\\\\n0.3  -0.5  0.2  -0.1  0.0 \\\\\n0.2  0.1  -0.3  0.5  -0.4 \\\\\n-0.1  0.4  0.2  -0.2  0.3 \\\\\n0.6  -0.2  0.0  0.1  -0.3\n\\end{bmatrix},\\quad\nb = \\begin{bmatrix}-1.0 \\\\ -1.5 \\\\ -2.0 \\\\ 0.0 \\\\ 0.5 \\\\ -0.3\\end{bmatrix}.\n$$\n- 从 $z$ 构建 $L$ 如下\n$$\nL = \\begin{bmatrix}\nd_{1}  0  0 \\\\\n\\ell_{21}  d_{2}  0 \\\\\n\\ell_{31}  \\ell_{32}  d_{3}\n\\end{bmatrix},\n\\quad\n\\text{with}\\quad\n\\begin{aligned}\nd_{1} = \\mathrm{softplus}(z_{1}) + \\varepsilon,\\\\\nd_{2} = \\mathrm{softplus}(z_{2}) + \\varepsilon,\\\\\nd_{3} = \\mathrm{softplus}(z_{3}) + \\varepsilon,\\\\\n\\ell_{21} = z_{4},\\ \\ell_{31} = z_{5},\\ \\ell_{32} = z_{6}.\n\\end{aligned}\n$$\n- 定义基准标量涡粘性为\n$$\n\\nu_{0} = \\mathrm{softplus}(\\gamma^{\\top} x + \\gamma_{0}),\n\\quad\n\\gamma = \\begin{bmatrix}0.2\\\\ -0.1\\\\ 0.4\\\\ 0.0\\\\ 0.3\\end{bmatrix},\\quad\n\\gamma_{0} = -0.2.\n$$\n- 使用 $\\varepsilon = 10^{-9}$。\n\n给定一个对称应变率矩阵\n$$\nS = \\begin{bmatrix} S_{xx}  S_{xy} \\\\ S_{xy}  S_{yy} \\end{bmatrix},\n$$\n构建 $s = [S_{xx}, \\sqrt{2}\\,S_{xy}, S_{yy}]^{\\top}$，并根据您在第一部分的推导计算耗散密度。\n\n使用以下特征向量 $x^{(k)}$ 和应变矩阵 $S^{(k)}$ 的测试套件：\n- 案例1：$x^{(1)} = [0.8, 0.1, 0.5, 0.0, 0.2]^{\\top}$，$S^{(1)} = \\begin{bmatrix}0.01  0.02 \\\\ 0.02  -0.01\\end{bmatrix}$。\n- 案例2：$x^{(2)} = [0.0, 0.0, 0.0, 0.0, 0.0]^{\\top}$，$S^{(2)} = \\begin{bmatrix}0.0  0.0 \\\\ 0.0  0.0\\end{bmatrix}$。\n- 案例3：$x^{(3)} = [2.0, -1.0, 3.0, 0.5, -0.5]^{\\top}$，$S^{(3)} = \\begin{bmatrix}0.5  -0.8 \\\\ -0.8  0.3\\end{bmatrix}$。\n- 案例4：$x^{(4)} = [-10.0, -10.0, -10.0, -10.0, -10.0]^{\\top}$，$S^{(4)} = \\begin{bmatrix}0.1  -0.05 \\\\ -0.05  0.2\\end{bmatrix}$。\n\n验证和数值容差：对于每个案例，计算耗散密度，并以 $\\delta = 10^{-12}$ 的数值容差检查其非负性，将大于或等于 $-\\delta$ 的值解释为非负。此外，计算 $A$ 的最小特征值，并检查它在相同容差内是否为非负。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为\n$$\n[\\text{B}_{1}, \\text{B}_{2}, \\text{B}_{3}, \\text{B}_{4}],\n$$\n其中 $\\text{B}_{k}$ 是一个布尔值，指示对于案例 $k$，耗散密度和 $A$ 的最小特征值是否都为非负（在容差范围内）。由于所有量都以一致的无量纲形式表示，因此不需要物理单位。",
            "solution": "该问题要求为一个混合物理-机器学习模型推导能量耗散条件，构建满足此条件的特定参数化方案，并实现该模型以对测试用例进行验证。解决方案按要求分为三个部分呈现。\n\n### 第一部分：耗散密度的推导\n\n分析始于二维空间（$i,j \\in \\{x,y\\}$）中的滤波、不可压Navier-Stokes方程。解析速度场 $\\mathbf{u}(\\mathbf{x},t)$ 的动量方程可以写为：\n$$\n\\frac{\\partial u_i}{\\partial t} + u_j \\frac{\\partial u_i}{\\partial x_j} = - \\frac{\\partial p}{\\partial x_i} - \\frac{\\partial \\tau_{ij}}{\\partial x_j}\n$$\n此处，$p$ 是解析压力（由常数密度 $\\rho=1$ 归一化），$\\tau_{ij}$ 是亚网格尺度（SGS）应力张量，它代表了未解析运动对解析流的影响。分子粘性已被忽略，这在高雷诺数湍流模型中是常见的做法，因为在这些模型中亚网格尺度的效应占主导地位。流体是不可压的，满足 $\\nabla \\cdot \\mathbf{u} = 0$，即 $\\partial u_k / \\partial x_k = 0$。\n\n解析动能密度定义为 $K = (1/2) \\mathbf{u}\\cdot\\mathbf{u} = (1/2) u_i u_i$。为推导其演化方程，我们对 $K$ 求时间导数，并代入动量方程：\n$$\n\\frac{\\partial K}{\\partial t} = u_i \\frac{\\partial u_i}{\\partial t} = u_i \\left( - u_j \\frac{\\partial u_i}{\\partial x_j} - \\frac{\\partial p}{\\partial x_i} - \\frac{\\partial \\tau_{ij}}{\\partial x_j} \\right)\n$$\n我们分析右侧的每一项：\n1. **平流项：** 使用乘积法则和不可压条件，此项代表动能的输运：\n$$\n- u_i u_j \\frac{\\partial u_i}{\\partial x_j} = - u_j \\frac{\\partial}{\\partial x_j} \\left(\\frac{1}{2} u_i u_i\\right) = - \\mathbf{u} \\cdot \\nabla K = -\\nabla \\cdot (K\\mathbf{u})\n$$\n2. **压力项：** 此项代表由压力引起的能量输运：\n$$\n- u_i \\frac{\\partial p}{\\partial x_i} = - \\frac{\\partial (u_i p)}{\\partial x_i} + p \\frac{\\partial u_i}{\\partial x_i} = -\\nabla \\cdot (p \\mathbf{u}) \\quad (\\text{since } \\nabla \\cdot \\mathbf{u} = 0)\n$$\n3. **SGS应力项：** 此项描述了解析尺度和未解析尺度之间的能量交换：\n$$\n- u_i \\frac{\\partial \\tau_{ij}}{\\partial x_j} = - \\frac{\\partial (u_i \\tau_{ij})}{\\partial x_j} + \\tau_{ij} \\frac{\\partial u_i}{\\partial x_j}\n$$\n第二部分 $\\tau_{ij} (\\partial u_i / \\partial x_j)$ 是SGS应力对解析速度场做功的速率。由于SGS张量 $\\tau_{ij}$ 是对称的，它与速度梯度张量的乘积可以通过将梯度分解为其对称和反对称部分来简化：\n$$\n\\tau_{ij} \\frac{\\partial u_i}{\\partial x_j} = \\tau_{ij} \\left( \\frac{1}{2}\\left(\\frac{\\partial u_i}{\\partial x_j} + \\frac{\\partial u_j}{\\partial x_i}\\right) \\right) + \\tau_{ij} \\left( \\frac{1}{2}\\left(\\frac{\\partial u_i}{\\partial x_j} - \\frac{\\partial u_j}{\\partial x_i}\\right) \\right)\n$$\n右边的第二项消失了，因为它是对称张量（$\\boldsymbol{\\tau}$）和反对称张量的内积。第一项涉及对称应变率张量 $S_{ij} = (1/2)(\\partial u_i / \\partial x_j + \\partial u_j / \\partial x_i)$。因此，做功速率为 $\\boldsymbol{\\tau}:S$。\n\n综合所有项，逐点动能收支为：\n$$\n\\frac{\\partial K}{\\partial t} = -\\nabla \\cdot (K\\mathbf{u}) - \\nabla \\cdot (p\\mathbf{u}) - \\nabla \\cdot (\\mathbf{u} \\cdot \\boldsymbol{\\tau}) + \\boldsymbol{\\tau}:S\n$$\n最后一项 $\\boldsymbol{\\tau}:S$ 代表从解析尺度产生（如果为正）或移除（如果为负）动能。逐点耗散密度 $\\mathcal{D}$ 定义为从解析尺度到亚网格尺度的能量传递速率，这对应于能量收支中的一个损失项。因此，$\\mathcal{D} = -\\boldsymbol{\\tau}:S$。为使模型具有物理耗散性，我们要求 $\\mathcal{D} \\ge 0$。\n\n问题陈述涡粘性封闭是一个作用在对称2阶张量空间上的线性算子，在Voigt表示法中由矩阵 $A$ 表示。一个广义的线性各向异性涡粘性模型，是对标量模型 $\\boldsymbol{\\tau}=-2\\nu_t S$ 的扩展，其公式为：\n$$\nt_v = -2 A s\n$$\n其中 $t_v$ 和 $s$ 分别是 $\\boldsymbol{\\tau}$ 和 $S$ 的Voigt向量化表示。问题指定了Voigt映射，使得Frobenius内积 $S:S$ 等于 $s^\\top s$。此性质可推广到两个不同张量的内积，即 $\\boldsymbol{\\tau}:S = t_v^\\top s$。\n\n将模型代入耗散密度表达式：\n$$\n\\mathcal{D} = -\\boldsymbol{\\tau}:S = -t_v^\\top s = -(-2As)^\\top s = 2(As)^\\top s = 2 s^\\top A^\\top s\n$$\n由于问题指定 $A$ 是一个对称矩阵（$A^\\top = A$），因此逐点耗散密度的最终表达式为：\n$$\n\\mathcal{D} = 2 s^\\top A s\n$$\n为了保证对于任何可能的流动状态（即对于任何对称应变率张量 $S$ 及其对应的向量 $s$），耗散都为非负（$\\mathcal{D} \\ge 0$），条件 $s^\\top A s \\ge 0$ 必须对所有 $s \\in \\mathbb{R}^3$ 成立。这是半正定（PSD）矩阵的定义。因此，如果矩阵 $A$ 是半正定的，该封闭模型就能保证非负的能量耗散。\n\n对于域 $\\Omega$ 上的总动能收支，需要对逐点方程进行积分。通过散度定理，散度项可以转换为面积分。为了分离出总耗散，必须假设边界条件（例如，周期性边界），使得这些面积分为零。\n\n### 第二部分：保证半正定的参数化\n\n目标是对称矩阵 $A \\in \\mathbb{R}^{3\\times 3}$ 进行参数化，使其保证为半正定，而不管机器学习模型的无约束输出如何。一种构建半正定矩阵的稳健方法是通过类Cholesky分解。我们提出以下形式：\n$$\nA = L L^\\top + \\nu_0 I\n$$\n其中 $L \\in \\mathbb{R}^{3\\times 3}$ 是一个下三角矩阵，$I$ 是 $3\\times 3$ 单位矩阵，$\\nu_0 \\ge 0$ 是一个标量基准粘性。\n\n这种构造保证了 $A$ 是半正定的。要理解这一点，考虑对于任何向量 $s \\in \\mathbb{R}^3$ 的二次型 $s^\\top A s$：\n$$\ns^\\top A s = s^\\top (L L^\\top + \\nu_0 I) s = s^\\top L L^\\top s + \\nu_0 s^\\top I s = (L^\\top s)^\\top (L^\\top s) + \\nu_0 s^\\top s = \\|L^\\top s\\|_2^2 + \\nu_0 \\|s\\|_2^2\n$$\n由于任何向量的欧几里得范数的平方都是非负的，并且我们强制 $\\nu_0 \\ge 0$，因此右边的两项都是非负的。所以，$s^\\top A s \\ge 0$，这证明了 $A$ 是半正定的。\n\n从无约束的机器学习输出向量 $z \\in \\mathbb{R}^6$ 和特征向量 $x \\in \\mathbb{R}^p$ 进行的具体参数化如下：\n1. 下三角矩阵 $L$ 由 $z$ 构建：\n$$\nL = \\begin{bmatrix} d_1  0  0 \\\\ \\ell_{21}  d_2  0 \\\\ \\ell_{31}  \\ell_{32}  d_3 \\end{bmatrix}\n$$\n非对角线元素是无约束的，可以直接从 $z$ 中取值：$\\ell_{21} = z_4$，$\\ell_{31} = z_5$，$\\ell_{32} = z_6$。\n对角线元素必须为非负。这通过使用SoftPlus函数 $\\mathrm{softplus}(a) = \\log(1+\\exp(a))$ 来强制实现，该函数将任何实数映射到一个正实数。为了数值稳定性，添加一个小的正常数 $\\varepsilon > 0$，以确保对角线项是严格为正的。\n$$\n\\begin{aligned}\nd_1 = \\mathrm{softplus}(z_1) + \\varepsilon \\\\\nd_2 = \\mathrm{softplus}(z_2) + \\varepsilon \\\\\nd_3 = \\mathrm{softplus}(z_3) + \\varepsilon\n\\end{aligned}\n$$\n2. 基准标量涡粘性 $\\nu_0$ 也必须为非负。它是通过对特征向量 $x$ 进行线性变换，然后应用SoftPlus函数来构建的：\n$$\n\\nu_0 = \\mathrm{softplus}(\\gamma^\\top x + \\gamma_0)\n$$\n其中 $\\gamma$ 是一个权重向量，$\\gamma_0$ 是一个偏置。这确保了 $\\nu_0 > 0$。\n\n这种参数化不仅保证了 $A$ 是半正定（PSD）的，而且是严格正定（PD）的，因为对于任何 $s \\ne 0$ 都有 $\\|s\\|_2^2 > 0$，并且 $\\nu_0 > 0$。\n\n### 第三部分：实现逻辑\n\n实现将遵循第二部分的参数化和第一部分的耗散公式，以在提供的测试用例上验证模型。对于由特征向量 $x^{(k)}$ 和应变率矩阵 $S^{(k)}$ 定义的每个用例，执行以下步骤：\n1. **计算机器学习输出：** 使用给定的仿射变换从特征 $x$ 计算无约束向量 $z$：$z = Wx + b$。\n2. **构建L：** 按照第二部分的规定，使用 $z$ 的元素组装下三角矩阵 $L$。对角线元素使用SoftPlus函数并加上 $\\varepsilon = 10^{-9}$ 来计算。\n3. **计算$\\nu_0$：** 使用指定的线性模型和SoftPlus函数从 $x$ 计算基准粘性 $\\nu_0$。\n4. **构建A：** 半正定矩阵 $A$ 构建为 $A = L L^\\top + \\nu_0 I$。\n5. **计算A的特征值：** 计算对称矩阵 $A$ 的特征值。找出最小特征值 $\\lambda_{\\min}$。根据理论，$\\lambda_{\\min}$ 必须为非负。我们检查是否 $\\lambda_{\\min} \\ge -\\delta$，容差为 $\\delta = 10^{-12}$。\n6. **计算耗散：** 将应变率矩阵 $S$ 转换为其Voigt向量形式 $s = [S_{xx}, \\sqrt{2}S_{xy}, S_{yy}]^\\top$。然后计算耗散密度为 $\\mathcal{D} = 2 s^\\top A s$。\n7. **验证耗散：** 计算出的耗散 $\\mathcal{D}$ 必须为非负。我们检查是否 $\\mathcal{D} \\ge -\\delta$。\n8. **确定结果：** 当且仅当最小特征值和耗散密度在指定容差内均为非负时，该用例的布尔结果 $\\text{B}_k$ 为 `True`。\n对所有四个测试用例重复这些步骤。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by constructing a PSD eddy-viscosity matrix A\n    and verifying non-negative dissipation for several test cases.\n    \"\"\"\n\n    # --- Problem Constants and Definitions ---\n\n    # Part III: ML model parameters\n    W = np.array([\n        [0.5, -0.3, 0.1, 0.0, 0.2],\n        [-0.4, 0.6, -0.2, 0.1, -0.1],\n        [0.3, -0.5, 0.2, -0.1, 0.0],\n        [0.2, 0.1, -0.3, 0.5, -0.4],\n        [-0.1, 0.4, 0.2, -0.2, 0.3],\n        [0.6, -0.2, 0.0, 0.1, -0.3]\n    ])\n    b = np.array([-1.0, -1.5, -2.0, 0.0, 0.5, -0.3])\n\n    gamma = np.array([0.2, -0.1, 0.4, 0.0, 0.3])\n    gamma_0 = -0.2\n\n    epsilon = 1e-9\n    delta = 1e-12\n\n    # Part II: Smooth nonlinearity\n    def softplus(a):\n        \"\"\"Computes the softplus function log(1 + exp(a)).\"\"\"\n        # Clip 'a' to avoid overflow in exp(a) for large positive values.\n        # For large a, softplus(a) approaches a.\n        # For large negative a, softplus(a) approaches 0.\n        clipped_a = np.clip(a, -np.inf, 50)\n        return np.log(1.0 + np.exp(clipped_a))\n\n    # --- Test Cases ---\n    test_cases = [\n        {\n            \"x\": np.array([0.8, 0.1, 0.5, 0.0, 0.2]),\n            \"S\": np.array([[0.01, 0.02], [0.02, -0.01]])\n        },\n        {\n            \"x\": np.array([0.0, 0.0, 0.0, 0.0, 0.0]),\n            \"S\": np.array([[0.0, 0.0], [0.0, 0.0]])\n        },\n        {\n            \"x\": np.array([2.0, -1.0, 3.0, 0.5, -0.5]),\n            \"S\": np.array([[0.5, -0.8], [-0.8, 0.3]])\n        },\n        {\n            \"x\": np.array([-10.0, -10.0, -10.0, -10.0, -10.0]),\n            \"S\": np.array([[0.1, -0.05], [-0.05, 0.2]])\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        x = case[\"x\"]\n        S = case[\"S\"]\n\n        # 1. Compute ML outputs (z and nu_0)\n        z = W @ x + b\n        nu_0 = softplus(gamma.T @ x + gamma_0)\n\n        # 2. Construct the lower-triangular matrix L\n        L = np.zeros((3, 3))\n        # Diagonals with softplus and epsilon\n        L[0, 0] = softplus(z[0]) + epsilon\n        L[1, 1] = softplus(z[1]) + epsilon\n        L[2, 2] = softplus(z[2]) + epsilon\n        # Off-diagonals\n        L[1, 0] = z[3]  # l_21\n        L[2, 0] = z[4]  # l_31\n        L[2, 1] = z[5]  # l_32\n\n        # 3. Construct the PSD matrix A\n        A = L @ L.T + nu_0 * np.eye(3)\n\n        # 4. Check if A is PSD by computing its smallest eigenvalue\n        # Use eigvalsh for symmetric matrices for efficiency and numerical stability\n        eigenvalues = np.linalg.eigvalsh(A)\n        min_eigenvalue = np.min(eigenvalues)\n        is_psd = min_eigenvalue >= -delta\n\n        # 5. Form strain-rate vector s\n        S_xx, S_xy, S_yy = S[0, 0], S[0, 1], S[1, 1]\n        s = np.array([S_xx, np.sqrt(2) * S_xy, S_yy])\n\n        # 6. Compute dissipation density D = 2 * s^T * A * s\n        dissipation = 2 * s.T @ A @ s\n        is_dissipation_nonnegative = dissipation >= -delta\n        \n        # 7. Final check for the case\n        results.append(is_psd and is_dissipation_nonnegative)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在某些应用中，我们可能需要在模型预测后严格执行守恒律，这被称为后处理或推理时校正。当物理定律可以表示为代数约束时，该方法尤其有效。本练习将带您实现一个针对浅水方程模拟器的后处理校正步骤，通过最小化地调整模型输出的流体深度场，来精确地强制执行位势涡度（PV）守恒——这是地球物理流体动力学中的一个核心不变量。",
            "id": "4052695",
            "problem": "考虑一个在双周期方形域上的无粘、绝热的二维浅水系统。设该方形域的边长为 $L$ 米，通过一个在 $x$ 方向有 $N_x$ 个点、在 $y$ 方向有 $N_y$ 个点的均匀网格进行离散化。层深为 $h(x,y,t)$（单位：米），水平速度为 $\\boldsymbol{u}(x,y,t) = (u(x,y,t), v(x,y,t))$（单位：米/秒），科里奥利参数为常数 $f$（单位：1/秒）。定义相对涡度为 $\\zeta = \\partial_x v - \\partial_y u$（其中 $\\partial_x$ 和 $\\partial_y$ 均为空间导数），Ertel 位涡（PV）为 $q = (\\zeta + f)/h$（单位：1/（米·秒））。在浅水方程下，且无外部强迫和耗散的情况下，$q$ 跟随流体质点被物质守恒。\n\n在一个混合物理-机器学习（ML）模拟器中，一个数值时间步进格式可能在时间 $t^{n+1}$ 产生预测场，记为 $\\tilde{u}^{n+1}(x,y)$、$\\tilde{v}^{n+1}(x,y)$ 和 $\\tilde{h}^{n+1}(x,y)$。这些场近似地求解了控制方程，但并不精确地保持 $q$ 守恒。您的任务是通过仅最小程度地修改层深并保持预测速度不变，计算一个修正量，以在到达网格点上强制实现位涡的精确守恒至机器精度。具体来说，您必须计算一个修正量 $\\delta h(x,y)$（单位：米），使得修正后的深度 $h^{n+1}_{\\text{corr}}(x,y) = \\tilde{h}^{n+1}(x,y) + \\delta h(x,y)$ 满足\n$$\n\\frac{\\zeta^{n+1}_{\\text{pred}}(x,y) + f}{h^{n+1}_{\\text{corr}}(x,y)} = q^{n+1}_{\\text{ref}}(x,y),\n$$\n其中 $\\zeta^{n+1}_{\\text{pred}}(x,y)$ 是根据预测速度 $\\tilde{u}^{n+1}, \\tilde{v}^{n+1}$ 使用周期性网格上的中心有限差分计算出的相对涡度，而 $q^{n+1}_{\\text{ref}}(x,y)$ 是通过使用时间 $t^n$ 的速度对 $q^n(x,y) = (\\zeta^n(x,y) + f)/h^n(x,y)$ 进行半拉格朗日平流而得到的时间推进后的 PV。\n\n您必须为每个测试用例实施以下定义明确、完全指定的程序：\n\n1. 在周期性网格上构建时间 $t^n$ 的场 $u^n(x,y)$、$v^n(x,y)$ 和 $h^n(x,y)$，网格间距为 $\\Delta x = L / N_x$ 和 $\\Delta y = L / N_y$：\n   - $u^n$、$v^n$ 和 $h^n$ 的具体函数形式在下文的测试套件部分给出。\n2. 使用带周期性边界条件的中心有限差分计算 $\\zeta^n$：\n   $$\n   \\zeta^n_{i,j} = \\frac{v^n_{i+1,j} - v^n_{i-1,j}}{2\\,\\Delta x} - \\frac{u^n_{i,j+1} - u^n_{i,j-1}}{2\\,\\Delta y}.\n   $$\n3. 计算 $q^n = (\\zeta^n + f)/h^n$。\n4. 预测 $t^{n+1}$ 时的到达场：\n   - 设置 $\\tilde{u}^{n+1} = u^n$ 和 $\\tilde{v}^{n+1} = v^n$。\n   - 使用显式前向欧拉质量平流步（中心差分和周期性边界）来推进深度：\n     $$\n     \\tilde{h}^{n+1} = h^n - \\Delta t \\left[\\partial_x (h^n u^n) + \\partial_y (h^n v^n)\\right],\n     $$\n     其中\n     $$\n     \\partial_x (h^n u^n)\\big|_{i,j} = \\frac{(h^n u^n)_{i+1,j} - (h^n u^n)_{i-1,j}}{2\\,\\Delta x}, \\quad\n     \\partial_y (h^n v^n)\\big|_{i,j} = \\frac{(h^n v^n)_{i,j+1} - (h^n v^n)_{i,j-1}}{2\\,\\Delta y}.\n     $$\n   - 通过向 $\\tilde{h}^{n+1}$ 添加一个确定性残差 $r(x,y)$ 来模拟机器学习（ML）闭合项：\n     $$\n     r(x,y) = \\varepsilon \\cos\\!\\left(\\frac{6\\pi x}{L}\\right)\\cos\\!\\left(\\frac{4\\pi y}{L}\\right), \\quad \\tilde{h}^{n+1} \\leftarrow \\tilde{h}^{n+1} + r(x,y).\n     $$\n5. 使用与步骤2中相同的中心差分公式，从 $\\tilde{u}^{n+1}$ 和 $\\tilde{v}^{n+1}$ 计算 $\\zeta^{n+1}_{\\text{pred}}$。\n6. 通过从每个到达网格点 $(x_i,y_j)$ 使用时间 $t^n$ 的速度和时间步长 $\\Delta t$ 向后追踪流体质点，并进行双周期环绕处理，来计算半拉格朗日 PV 参考值 $q^{n+1}_{\\text{ref}}$：\n   - 出发点：\n     $$\n     x_d = x_i - u^n_{i,j}\\,\\Delta t \\quad (\\text{mod } L), \\qquad y_d = y_j - v^n_{i,j}\\,\\Delta t \\quad (\\text{mod } L).\n     $$\n   - 使用周期性网格上的双线性插值在 $(x_d,y_d)$ 处评估 $q^n$，以获得 $q^{n+1}_{\\text{ref}}(x_i,y_j)$。\n7. 计算深度修正量 $\\delta h$，使得修正后的 PV 在每个网格点上精确等于 $q^{n+1}_{\\text{ref}}$，同时保持 $\\tilde{u}^{n+1}$ 和 $\\tilde{v}^{n+1}$ 不变。应用该修正量得到 $h^{n+1}_{\\text{corr}} = \\tilde{h}^{n+1} + \\delta h$。\n8. 计算修正后的 PV $q^{n+1}_{\\text{corr}} = (\\zeta^{n+1}_{\\text{pred}} + f)/h^{n+1}_{\\text{corr}}$ 并报告最大绝对 PV 误差\n   $$\n   E = \\max_{i,j} \\left|q^{n+1}_{\\text{corr}}(x_i,y_j) - q^{n+1}_{\\text{ref}}(x_i,y_j)\\right|.\n   $$\n   将 $E$ 表示为一个浮点数，单位为 1/（米·秒）。\n\n您的程序必须为以下三个测试用例中的每一个计算 $E$，并生成单行输出，其中包含用方括号括起来的逗号分隔结果列表（例如，“[e1,e2,e3]”），其中每个 $e_k$ 是计算出的浮点值：\n\n测试套件：\n\n- 测试用例 1（非平凡旋转流）：\n  - $N_x = 32$，$N_y = 32$，$L = 10^6$ 米，$\\Delta t = 600$ 秒，$f = 10^{-4}$ 1/秒，$H_0 = 1000$ 米，$U_{\\text{amp}} = 10$ 米/秒，$B = 5$ 米，$\\varepsilon = 0.1$ 米。\n  - 定义流函数 $\\psi(x,y) = A \\cos\\!\\left(\\frac{2\\pi x}{L}\\right)\\cos\\!\\left(\\frac{2\\pi y}{L}\\right)$，其中 $A = \\frac{U_{\\text{amp}}\\,L}{2\\pi}$，并设置 $u^n = -\\partial_y \\psi$，$v^n = \\partial_x \\psi$。定义 $h^n(x,y) = H_0 + B \\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\sin\\!\\left(\\frac{2\\pi y}{L}\\right)$。\n- 测试用例 2（均匀纬向流）：\n  - $N_x = 24$，$N_y = 24$，$L = 5\\times 10^5$ 米，$\\Delta t = 300$ 秒，$f = 10^{-4}$ 1/秒，$H_0 = 800$ 米，$U_0 = 20$ 米/秒，$B = 2$ 米，$\\varepsilon = 0.05$ 米。\n  - 设置 $u^n(x,y) = U_0$，$v^n(x,y) = 0$，以及 $h^n(x,y) = H_0 + B \\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\sin\\!\\left(\\frac{2\\pi y}{L}\\right)$。\n- 测试用例 3（弱科里奥利参数下的缓和旋转流）：\n  - $N_x = 40$，$N_y = 40$，$L = 2\\times 10^6$ 米，$\\Delta t = 900$ 秒，$f = 10^{-5}$ 1/秒，$H_0 = 1200$ 米，$U_{\\text{amp}} = 5$ 米/秒，$B = 1$ 米，$\\varepsilon = 0.2$ 米。\n  - 定义流函数 $\\psi(x,y) = A \\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\sin\\!\\left(\\frac{2\\pi y}{L}\\right)$，其中 $A = \\frac{U_{\\text{amp}}\\,L}{2\\pi}$，并设置 $u^n = -\\partial_y \\psi$，$v^n = \\partial_x \\psi$。定义 $h^n(x,y) = H_0 + B \\cos\\!\\left(\\frac{2\\pi x}{L}\\right)\\cos\\!\\left(\\frac{2\\pi y}{L}\\right)$。\n\n在所有三角函数表达式中，角度单位均为弧度。您程序的最终输出必须是包含三个结果的单行，格式必须为“[e1,e2,e3]”。每个 $e_k$ 必须是表示相应测试用例的最大绝对 PV 误差 $E$ 的浮点数，单位为 1/（米·秒），是在应用您的修正后计算得出的。",
            "solution": "其基础是 $f$ 平面上的浅水系统，其中 Ertel 位涡（PV）$q = (\\zeta + f)/h$ 对于无粘、绝热流是物质守恒的。物质守恒意味着沿着流体质点轨迹，$Dq/Dt = 0$，这表明到达点的 $q$ 值等于相应出发点的 $q$ 值。离散化方法和混合物理-机器学习（ML）模拟器可能会破坏精确的 PV 守恒，因此我们寻求一种基于原则的约束投影来恢复精确的 PV 不变性。\n\n原则和定义：\n- 相对涡度是 $\\zeta = \\partial_x v - \\partial_y u$，此处通过带周期性边界的中心差分计算。在间距为 $\\Delta x$ 和 $\\Delta y$ 的均匀网格上，离散公式为\n  $$\n  \\zeta_{i,j} = \\frac{v_{i+1,j} - v_{i-1,j}}{2\\,\\Delta x} - \\frac{u_{i,j+1} - u_{i,j-1}}{2\\,\\Delta y}。\n  $$\n- 位涡是 $q = (\\zeta + f)/h$，单位是 1/（米·秒）。在无粘绝热条件下，浅水方程意味着 $Dq/Dt = \\partial_t q + u \\,\\partial_x q + v \\,\\partial_y q = 0$。\n- PV 的半拉格朗日平流遵循质点输运：在到达网格点 $(x_i,y_j)$ 处，通过沿时间 $t^n$ 的速度在 $\\Delta t$ 时间内向后追踪来定义一个出发点 $(x_d,y_d)$，并进行周期性环绕处理，即\n  $$\n  x_d = x_i - u^n_{i,j}\\,\\Delta t \\quad (\\text{mod } L), \\qquad y_d = y_j - v^n_{i,j}\\,\\Delta t \\quad (\\text{mod } L)。\n  $$\n  时间 $t^{n+1}$ 的参考 PV 是 $q^{n+1}_{\\text{ref}}(x_i,y_j) = q^n(x_d,y_d)$，通过在周期性网格上对 $q^n$ 进行双线性插值得到。\n\n约束投影设计：\n- 我们寻求修正后的深度 $h^{n+1}_{\\text{corr}} = \\tilde{h}^{n+1} + \\delta h$，使得修正后的 PV 等于半拉格朗日参考值，\n  $$\n  \\frac{\\zeta^{n+1}_{\\text{pred}} + f}{h^{n+1}_{\\text{corr}}} = q^{n+1}_{\\text{ref}},\n  $$\n  在每个网格点上都成立，同时保持预测速度不变以避免改变动量。这是在每个网格位置上的局部、逐点的约束。\n- 求解 $\\delta h$ 的约束仅需代数运算。将约束重写为\n  $$\n  \\zeta^{n+1}_{\\text{pred}} + f = q^{n+1}_{\\text{ref}}\\,(\\tilde{h}^{n+1} + \\delta h)。\n  $$\n  解出 $\\delta h$ 得到\n  $$\n  \\delta h = \\frac{\\zeta^{n+1}_{\\text{pred}} + f}{q^{n+1}_{\\text{ref}}} - \\tilde{h}^{n+1}。\n  $$\n  这是对 $h$ 的唯一逐点修正，能在机器精度下强制实现精确的 PV 相等，前提是 $q^{n+1}_{\\text{ref}} \\neq 0$。在测试套件中，所选的科里奥利参数和深度确保 $q^{n+1}_{\\text{ref}}$ 有界且不为零。\n- 这种修正只调整深度，保持速度不变，这与在满足 PV 约束的同时最小程度地改变模拟器状态是一致的。这是一个到由 $q^{n+1}_{\\text{ref}}$ 定义的 PV 守恒流形上的直接代数投影。\n\n算法步骤：\n1. 根据每个测试用例的规定，在周期性坐标 $x \\in [0,L)$ 和 $y \\in [0,L)$ 的网格上，使用给定的解析表达式构建 $u^n$、$v^n$ 和 $h^n$。\n2. 使用中心差分和周期性环绕计算 $\\zeta^n$，然后计算 $q^n = (\\zeta^n + f)/h^n$。\n3. 通过复制 $u^n$ 和 $v^n$ 来预测 $\\tilde{u}^{n+1}$ 和 $\\tilde{v}^{n+1}$。使用前向欧拉质量平流预测 $\\tilde{h}^{n+1}$：\n   $$\n   \\tilde{h}^{n+1} = h^n - \\Delta t \\left[\\partial_x (h^n u^n) + \\partial_y (h^n v^n)\\right],\n   $$\n   使用中心差分和周期性环绕计算。将确定性 ML 残差 $r(x,y)$ 添加到 $\\tilde{h}^{n+1}$。\n4. 从 $\\tilde{u}^{n+1}$ 和 $\\tilde{v}^{n+1}$ 通过中心差分计算 $\\zeta^{n+1}_{\\text{pred}}$。\n5. 通过对 $q^n$ 进行半拉格朗日平流来计算 $q^{n+1}_{\\text{ref}}$，在出发点 $(x_d,y_d)$ 处使用双线性插值，并对坐标和索引进行周期性环绕处理。\n6. 计算深度修正量\n   $$\n   \\delta h = \\frac{\\zeta^{n+1}_{\\text{pred}} + f}{q^{n+1}_{\\text{ref}}} - \\tilde{h}^{n+1}。\n   $$\n   应用它以获得 $h^{n+1}_{\\text{corr}} = \\tilde{h}^{n+1} + \\delta h$。\n7. 通过计算\n   $$\n   q^{n+1}_{\\text{corr}} = \\frac{\\zeta^{n+1}_{\\text{pred}} + f}{h^{n+1}_{\\text{corr}}},\n   $$\n   来验证，并测量网格上的最大绝对 PV 误差，\n   $$\n   E = \\max_{i,j} \\left|q^{n+1}_{\\text{corr}}(x_i,y_j) - q^{n+1}_{\\text{ref}}(x_i,y_j)\\right|。\n   $$\n   由于修正是通过代数推导以强制相等，所以 $E$ 将达到或接近机器精度，误差来自于计算涡度、插值和算术运算中的浮点舍入。\n\n数值细节：\n- 中心差分使用周期性环绕索引：\n  $$\n  f_{i+1,j} \\equiv f_{(i+1)\\bmod N_x,j}, \\quad f_{i-1,j} \\equiv f_{(i-1)\\bmod N_x,j}, \\quad f_{i,j+1} \\equiv f_{i,(j+1)\\bmod N_y}, \\quad f_{i,j-1} \\equiv f_{i,(j-1)\\bmod N_y}。\n  $$\n- 在 $(x_d,y_d)$ 处对 $q^n$ 进行双线性插值，需要从 $x_d/\\Delta x$ 和 $y_d/\\Delta y$ 计算分数索引坐标 $(\\alpha,\\beta)$，然后组合四个环绕整数索引处的相邻网格点值。\n- 测试所选的参数使得库朗数 $U\\,\\Delta t/\\Delta x$ 保持在数值合理性的适度范围内，深度为正，且 $q^{n+1}_{\\text{ref}}$ 有界且不为零。\n\n程序为三个测试用例实现了上述步骤，计算了每个用例的 $E$，并以要求的单行格式打印结果。每个报告的 $E$ 的单位是 1/（米·秒），其值应接近浮点舍入误差（量级在 $10^{-15}$ 到 $10^{-12}$ 之间），这表明在设计的修正下，PV 守恒达到了机器精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef periodic_centered_diff_x(f, dx):\n    \"\"\"Centered difference in x with periodic boundaries.\"\"\"\n    return (np.roll(f, -1, axis=0) - np.roll(f, 1, axis=0)) / (2.0 * dx)\n\ndef periodic_centered_diff_y(f, dy):\n    \"\"\"Centered difference in y with periodic boundaries.\"\"\"\n    return (np.roll(f, -1, axis=1) - np.roll(f, 1, axis=1)) / (2.0 * dy)\n\ndef compute_vorticity(u, v, dx, dy):\n    \"\"\"Relative vorticity zeta = dv/dx - du/dy using centered differences.\"\"\"\n    dv_dx = periodic_centered_diff_x(v, dx)\n    du_dy = periodic_centered_diff_y(u, dy)\n    return dv_dx - du_dy\n\ndef bilinear_interpolate_periodic(field, x, y, Lx, Ly):\n    \"\"\"\n    Bilinear interpolation of a 2D field defined on a periodic grid at real coordinates (x, y).\n    field shape: (Nx, Ny), grid spacing dx=Lx/Nx, dy=Ly/Ny, grid points at (i*dx, j*dy).\n    \"\"\"\n    Nx, Ny = field.shape\n    dx = Lx / Nx\n    dy = Ly / Ny\n    # Map x, y into [0, L)\n    x = np.mod(x, Lx)\n    y = np.mod(y, Ly)\n    # Continuous indices\n    xi = x / dx\n    yi = y / dy\n    i0 = np.floor(xi).astype(int)\n    j0 = np.floor(yi).astype(int)\n    # fractional parts\n    fx = xi - i0\n    fy = yi - j0\n    # wrapped neighbor indices\n    i1 = (i0 + 1) % Nx\n    j1 = (j0 + 1) % Ny\n    # Gather corner values\n    f00 = field[i0, j0]\n    f10 = field[i1, j0]\n    f01 = field[i0, j1]\n    f11 = field[i1, j1]\n    # Bilinear interpolation: (1-fx)(1-fy) f00 + fx(1-fy) f10 + (1-fx)fy f01 + fx fy f11\n    return (1 - fx) * (1 - fy) * f00 + fx * (1 - fy) * f10 + (1 - fx) * fy * f01 + fx * fy * f11\n\ndef construct_case_fields(case):\n    \"\"\"\n    Construct initial fields u^n, v^n, h^n on periodic grid for a given test case specification.\n    Returns x, y grids (2D), u, v, h, and parameters.\n    \"\"\"\n    Nx = case['Nx']\n    Ny = case['Ny']\n    L = case['L']\n    H0 = case['H0']\n    B = case['B']\n    f = case['f']\n    dt = case['dt']\n    eps = case['eps']\n    dx = L / Nx\n    dy = L / Ny\n\n    # Grid coordinates: 2D arrays\n    x_coords = (np.arange(Nx) + 0.0) * dx\n    y_coords = (np.arange(Ny) + 0.0) * dy\n    X, Y = np.meshgrid(x_coords, y_coords, indexing='ij')\n\n    # Build velocity and depth based on case type:\n    if case['type'] == 'rotational_cos':\n        Uamp = case['Uamp']\n        A = Uamp * L / (2.0 * np.pi)\n        # psi = A cos(2π x/L) cos(2π y/L)\n        # u = -∂ψ/∂y, v = ∂ψ/∂x\n        u = -(-A * (2.0 * np.pi / L) * np.sin(2.0 * np.pi * Y / L) * np.cos(2.0 * np.pi * X / L))\n        v = -(A * (2.0 * np.pi / L) * np.sin(2.0 * np.pi * X / L) * np.cos(2.0 * np.pi * Y / L))\n        h = H0 + B * np.sin(2.0 * np.pi * X / L) * np.sin(2.0 * np.pi * Y / L)\n    elif case['type'] == 'uniform_zonal':\n        U0 = case['U0']\n        u = U0 * np.ones_like(X)\n        v = np.zeros_like(X)\n        h = H0 + B * np.sin(2.0 * np.pi * X / L) * np.sin(2.0 * np.pi * Y / L)\n    elif case['type'] == 'rotational_sin':\n        Uamp = case['Uamp']\n        A = Uamp * L / (2.0 * np.pi)\n        # psi = A sin(2π x/L) sin(2π y/L)\n        u = - (A * (2.0 * np.pi / L) * np.sin(2.0 * np.pi * Y / L) * np.cos(2.0 * np.pi * X / L))\n        v =   (A * (2.0 * np.pi / L) * np.sin(2.0 * np.pi * X / L) * np.cos(2.0 * np.pi * Y / L))\n        h = H0 + B * np.cos(2.0 * np.pi * X / L) * np.cos(2.0 * np.pi * Y / L)\n    else:\n        raise ValueError(\"Unknown case type.\")\n\n    return X, Y, u, v, h, dx, dy, f, dt, eps, L\n\ndef advance_emulator(u, v, h, dx, dy, dt, eps, L):\n    \"\"\"\n    Emulator step:\n      - Predicted velocities: tilde u = u, tilde v = v\n      - Predicted depth: tilde h = h - dt * div(h*u, h*v) + residual r(x,y)\n    \"\"\"\n    # Compute fluxes\n    hu = h * u\n    hv = h * v\n    div = periodic_centered_diff_x(hu, dx) + periodic_centered_diff_y(hv, dy)\n    h_tilde = h - dt * div\n    # Deterministic ML residual\n    # r(x,y) = eps * cos(6π x / L) * cos(4π y / L)\n    Nx, Ny = h.shape\n    x_coords = (np.arange(Nx)) * (L / Nx)\n    y_coords = (np.arange(Ny)) * (L / Ny)\n    X, Y = np.meshgrid(x_coords, y_coords, indexing='ij')\n    residual = eps * np.cos(6.0 * np.pi * X / L) * np.cos(4.0 * np.pi * Y / L)\n    h_tilde = h_tilde + residual\n    # Velocities unchanged\n    u_tilde = u.copy()\n    v_tilde = v.copy()\n    return u_tilde, v_tilde, h_tilde\n\ndef semi_lagrangian_qref(qn, u, v, X, Y, dt, L):\n    \"\"\"\n    Semi-Lagrangian advection of q using velocity at time n.\n    Returns q_ref at arrival grid points.\n    \"\"\"\n    # Departure points, with periodic wrap\n    Xd = np.mod(X - u * dt, L)\n    Yd = np.mod(Y - v * dt, L)\n    # Bilinear interpolation\n    q_ref = bilinear_interpolate_periodic(qn, Xd, Yd, L, L)\n    return q_ref\n\ndef compute_pv_error_after_correction(case):\n    \"\"\"\n    For a given case, compute the PV correction and return the maximum absolute PV error after correction.\n    \"\"\"\n    # Construct fields and parameters\n    X, Y, u, v, h, dx, dy, f, dt, eps, L = construct_case_fields(case)\n    # Compute zeta^n and q^n\n    zeta_n = compute_vorticity(u, v, dx, dy)\n    q_n = (zeta_n + f) / h\n    # Emulator predicted fields\n    u_tilde, v_tilde, h_tilde = advance_emulator(u, v, h, dx, dy, dt, eps, L)\n    # Predicted zeta at n+1 from predicted velocities (unchanged from n here)\n    zeta_pred = compute_vorticity(u_tilde, v_tilde, dx, dy)\n    # Semi-Lagrangian PV reference at n+1\n    q_ref = semi_lagrangian_qref(q_n, u, v, X, Y, dt, L)\n    # Compute correction delta h = (zeta_pred + f)/q_ref - h_tilde\n    # Ensure no division by zero by tiny floor (though q_ref should be nonzero by design)\n    tiny = 1e-30\n    q_ref_safe = np.where(np.abs(q_ref)  tiny, np.sign(q_ref) * tiny + (q_ref == 0.0) * tiny, q_ref)\n    delta_h = (zeta_pred + f) / q_ref_safe - h_tilde\n    h_corr = h_tilde + delta_h\n    # Corrected PV\n    q_corr = (zeta_pred + f) / h_corr\n    # Max absolute error\n    err = np.max(np.abs(q_corr - q_ref))\n    return float(err)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: nontrivial rotational flow\n        {\n            'type': 'rotational_cos',\n            'Nx': 32, 'Ny': 32,\n            'L': 1_000_000.0,\n            'dt': 600.0,\n            'f': 1.0e-4,\n            'H0': 1000.0,\n            'Uamp': 10.0,\n            'B': 5.0,\n            'eps': 0.1\n        },\n        # Test Case 2: uniform zonal flow\n        {\n            'type': 'uniform_zonal',\n            'Nx': 24, 'Ny': 24,\n            'L': 500_000.0,\n            'dt': 300.0,\n            'f': 1.0e-4,\n            'H0': 800.0,\n            'U0': 20.0,\n            'B': 2.0,\n            'eps': 0.05\n        },\n        # Test Case 3: weak Coriolis with gentle rotational flow\n        {\n            'type': 'rotational_sin',\n            'Nx': 40, 'Ny': 40,\n            'L': 2_000_000.0,\n            'dt': 900.0,\n            'f': 1.0e-5,\n            'H0': 1200.0,\n            'Uamp': 5.0,\n            'B': 1.0,\n            'eps': 0.2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_pv_error_after_correction(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}