{
    "hands_on_practices": [
        {
            "introduction": "平流层气溶胶注入（SAI）的主要目标是改变地球的辐射平衡。为了量化这一效应，我们必须首先理解气溶胶层如何与太阳光相互作用，而光学厚度是衡量这种相互作用的关键物理量。这个实践将指导你计算光学厚度，它直接关联到气溶胶的辐射效应。通过这个练习 ，你将掌握如何从气溶胶的微观物理特性（如粒径分布和复折射率）出发，通过数值积分来计算其宏观光学性质，这是任何SAI辐射效应评估的基础。",
            "id": "4096168",
            "problem": "一个平流层气溶胶注入模拟需要计算穿过一个水平均匀气溶胶层的直线路径上的整体光学深度，该气溶胶层中的粒子半径遵循对数正态数分布。从比尔-朗伯定律出发，光学深度定义为消光系数的路径积分，而消光系数本身是消光截面与粒子数分布相乘后对粒子尺寸的积分。推导一个可实现的算法，该算法在给定复折射率和对数正态数分布的情况下，计算指定路径长度上的整体光学深度。\n\n使用以下基本和核心定义：\n- 比尔-朗伯定律：微分形式为 $dI/dz = -\\beta_{\\mathrm{ext}} I$，长度为 $L$ 的路径上的光学深度为 $\\tau = \\int_0^L \\beta_{\\mathrm{ext}}(z)\\,dz$。对于垂直均匀的层，取 $\\beta_{\\mathrm{ext}}$ 为常数，则 $\\tau = \\beta_{\\mathrm{ext}} L$。\n- 多分散球形气溶胶的消光系数：\n$$\\beta_{\\mathrm{ext}} = \\int_0^\\infty Q_{\\mathrm{ext}}(x(r), m)\\,\\pi r^2\\,n(r)\\,dr,$$\n其中 $Q_{\\mathrm{ext}}$ 是消光效率，$r$ 是以米为单位的粒子半径，$m = m_r + i m_i$ 是复折射率（无量纲），$x(r) = \\dfrac{2\\pi r}{\\lambda}$ 是在波长 $\\lambda$（单位为米）下的尺寸参数，$n(r)$ 是数分布，单位为 $\\mathrm{m}^{-4}$，因此 $n(r)\\,dr$ 的单位为 $\\mathrm{m}^{-3}$。\n- 单位半径自然对数的对数正态数分布：总数浓度为 $N_0$（单位 $\\mathrm{m}^{-3}$），几何平均半径为 $r_g$（单位米），几何标准差为 $\\sigma_g$（无量纲），\n$$n_{\\ln}(u) = \\frac{N_0}{\\sqrt{2\\pi}\\,\\ln \\sigma_g}\\,\\exp\\!\\left(-\\frac{(u - \\ln r_g)^2}{2\\,\\ln^2 \\sigma_g}\\right), \\quad u = \\ln r.$$\n这意味着单位半径的分布为 \n$$n(r) = \\frac{N_0}{\\sqrt{2\\pi}\\,\\ln \\sigma_g}\\,\\frac{1}{r}\\,\\exp\\!\\left(-\\frac{(\\ln r - \\ln r_g)^2}{2\\,\\ln^2 \\sigma_g}\\right)。$$\n\n为确保在相关尺寸参数范围内的科学真实性，通过渐近极限和一个尊重瑞利极限和几何光学饱和的单调桥接函数来定义 $Q_{\\mathrm{ext}}(x,m)$：\n- 定义 $R(m) = \\dfrac{m^2 - 1}{m^2 + 2}$，$K(m) = \\dfrac{8}{3}\\,\\lvert R(m)\\rvert^2$（无量纲），以及 $D(m) = \\max\\{0,\\,4\\,\\Im(R(m))\\}$（无量纲）。在瑞利极限（$x \\ll 1$）下，散射效率为 $Q_{\\mathrm{sca}} \\approx K(m)\\,x^4$，吸收效率为 $Q_{\\mathrm{abs}} \\approx D(m)\\,x$。\n- 使用以下饱和形式来桥接到几何光学区：\n$$Q_{\\mathrm{sca}}(x,m) = 2\\left[1 - \\exp\\!\\left(-\\frac{K(m)}{2}\\,x^4\\right)\\right], \\quad Q_{\\mathrm{abs}}(x,m) = 2\\left[1 - \\exp\\!\\left(-\\frac{D(m)}{2}\\,x\\right)\\right],$$\n并将消光效率设置为\n$$Q_{\\mathrm{ext}}(x,m) = \\min\\left\\{2,\\;Q_{\\mathrm{sca}}(x,m) + Q_{\\mathrm{abs}}(x,m)\\right\\}。$$\n这种构造再现了小 $x$ 渐近线，并遵循了大 $x$ 饱和条件 $Q_{\\mathrm{ext}} \\le 2$。\n\n算法要求：\n- 通过替换 $u = \\ln r$ 来实现 $\\beta_{\\mathrm{ext}}$ 的积分，得到\n$$\\beta_{\\mathrm{ext}} = \\int_{-\\infty}^{\\infty} Q_{\\mathrm{ext}}(x(e^u), m)\\,\\pi\\,e^{2u}\\,n_{\\ln}(u)\\,du,$$\n然后计算 $\\tau = \\beta_{\\mathrm{ext}}\\,L$。在数值上，将 $u$ 的定义域截断为围绕 $\\ln r_g$ 的对称区间，跨度至少为六个几何标准差，即 $u \\in [\\ln r_g - 6\\ln\\sigma_g,\\; \\ln r_g + 6\\ln\\sigma_g]$，并在足够精细的网格上积分以确保收敛。\n- 所有物理量必须使用国际单位制（SI units）：半径 $r$（米）、波长 $\\lambda$（米）、路径长度 $L$（米）和数浓度 $N_0$（$\\mathrm{m}^{-3}$）。光学深度 $\\tau$ 是无量纲的。将每个测试用例的答案表示为四舍五入到六位小数的十进制浮点数。\n\n测试套件：\n将以下六个测试用例作为程序的输入，每个用例由元组 $(L, N_0, r_g, \\sigma_g, \\lambda, m_r, m_i)$ 定义，其中 $m = m_r + i m_i$：\n1. $(5000,\\;5.0\\times 10^{7},\\;1.0\\times 10^{-7},\\;1.6,\\;5.50\\times 10^{-7},\\;1.45,\\;0.0)$。\n2. $(500,\\;2.0\\times 10^{7},\\;2.0\\times 10^{-8},\\;1.4,\\;1.00\\times 10^{-6},\\;1.45,\\;0.0)$。\n3. $(10000,\\;1.0\\times 10^{8},\\;2.0\\times 10^{-7},\\;2.0,\\;5.50\\times 10^{-7},\\;1.50,\\;2.0\\times 10^{-2})$。\n4. $(10000,\\;1.0\\times 10^{6},\\;1.0\\times 10^{-6},\\;1.5,\\;5.50\\times 10^{-7},\\;1.45,\\;0.0)$。\n5. $(0,\\;5.0\\times 10^{7},\\;1.0\\times 10^{-7},\\;1.6,\\;5.50\\times 10^{-7},\\;1.45,\\;0.0)$。\n6. $(5000,\\;5.0\\times 10^{7},\\;1.0\\times 10^{-7},\\;1.01,\\;5.50\\times 10^{-7},\\;1.45,\\;0.0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按测试套件顺序排列的六个光学深度结果，四舍五入到六位小数，格式为用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5,result6]”）。",
            "solution": "该问题是有效的。它在计算大气物理学领域提出了一个有科学依据、定义明确且自洽的任务。没有发现不一致、模糊或事实错误。所提供的模型虽然是一个近似，但具有物理动机，适合实现。\n\n解决方案是遵循所提供的物理原理和数学定义而制定的。主要目标是计算路径长度为 $L$ 的均匀气溶胶层的光学深度 $\\tau$，其由 $\\tau = \\beta_{\\mathrm{ext}} L$ 给出。问题的核心是计算整体消光系数 $\\beta_{\\mathrm{ext}}$。\n\n根据所提供的定义，多分散气溶胶的 $\\beta_{\\mathrm{ext}}$ 是单粒子消光截面对粒子尺寸分布的积分：\n$$\n\\beta_{\\mathrm{ext}} = \\int_0^\\infty \\sigma_{\\mathrm{ext}}(r,m) \\, n(r) \\, dr = \\int_0^\\infty \\left( Q_{\\mathrm{ext}}(x(r), m) \\pi r^2 \\right) n(r) \\, dr\n$$\n这里，$n(r)$ 是粒子数分布函数，$Q_{\\mathrm{ext}}$ 是消光效率，它依赖于尺寸参数 $x(r) = 2\\pi r/\\lambda$ 和复折射率 $m$。\n\n问题指定了对数正态数分布 $n(r)$，并通过将积分变量从半径 $r$ 更改为其自然对数 $u = \\ln r$，提供了一个方便的积分公式。通过这种替换，我们有 $r = e^u$ 和 $dr = e^u du$。单位半径的数分布 $n(r)$ 与单位对数半径的分布 $n_{\\ln}(u)$ 的关系为 $n(r) = n_{\\ln}(u)/r = n_{\\ln}(u) e^{-u}$。将这些代入 $\\beta_{\\mathrm{ext}}$ 的积分中得到：\n$$\n\\beta_{\\mathrm{ext}} = \\int_{-\\infty}^{\\infty} Q_{\\mathrm{ext}}(x(e^u), m) \\, \\pi (e^u)^2 \\, \\left( n_{\\ln}(u) e^{-u} \\right) \\, (e^u du) = \\int_{-\\infty}^{\\infty} Q_{\\mathrm{ext}}(x(e^u), m) \\, \\pi e^{2u} \\, n_{\\ln}(u) \\, du\n$$\n这就是需要实现的积分，其中 $n_{\\ln}(u)$ 是高斯函数：\n$$\nn_{\\ln}(u) = \\frac{N_0}{\\sqrt{2\\pi}\\,\\ln \\sigma_g}\\,\\exp\\!\\left(-\\frac{(u - \\ln r_g)^2}{2\\,(\\ln \\sigma_g)^2}\\right)\n$$\n\n消光效率 $Q_{\\mathrm{ext}}(x,m)$ 由一个特定的桥接模型定义。这需要几个中间计算。首先，我们计算仅依赖于折射率 $m = m_r + i m_i$ 的复数和实数常量：\n1.  复数量 $R(m) = \\frac{m^2 - 1}{m^2 + 2}$。我们计算 $m^2 = (m_r + im_i)^2 = (m_r^2 - m_i^2) + i(2m_r m_i)$，然后执行复数除法。\n2.  实数常量 $K(m) = \\frac{8}{3} |R(m)|^2$，与瑞利散射相关。\n3.  实数常量 $D(m) = \\max\\{0, 4\\,\\Im(R(m))\\}$，与瑞利吸收相关。\n\n使用这些常量，散射和吸收效率被建模为：\n$$\nQ_{\\mathrm{sca}}(x,m) = 2\\left[1 - \\exp\\!\\left(-\\frac{K(m)}{2}\\,x^4\\right)\\right]\n$$\n$$\nQ_{\\mathrm{abs}}(x,m) = 2\\left[1 - \\exp\\!\\left(-\\frac{D(m)}{2}\\,x\\right)\\right]\n$$\n这些形式正确地再现了小 $x$（瑞利）渐近行为（$Q_{\\mathrm{sca}} \\propto x^4$，$Q_{\\mathrm{abs}} \\propto x$），并在 $x \\to \\infty$ 时向 $2$ 饱和。总消光效率是它们的和，上限为几何光学的极限值 $2$：\n$$\nQ_{\\mathrm{ext}}(x,m) = \\min\\left\\{2, \\; Q_{\\mathrm{sca}}(x,m) + Q_{\\mathrm{abs}}(x,m)\\right\\}\n$$\n\n算法实现过程如下：\n首先，对于给定的一组参数 $(L, N_0, r_g, \\sigma_g, \\lambda, m_r, m_i)$，我们检查平凡情况：如果 $L=0$，则 $\\tau=0$。否则，我们继续。\n常量 $K(m)$ 和 $D(m)$ 是预先计算的。然后我们定义一个表示被积函数的 Python 函数，$f(u) = Q_{\\mathrm{ext}}(x(e^u), m) \\, \\pi e^{2u} \\, n_{\\ln}(u)$。该函数接受单个参数 $u$，并使用预先计算的常量和输入参数计算完整表达式。\n\n$\\beta_{\\mathrm{ext}}$ 的积分是数值计算的。问题指定将 $u$ 的无限域截断为 $[\\ln r_g - 6\\ln\\sigma_g, \\ln r_g + 6\\ln\\sigma_g]$。这是一个有效的近似，因为 $n_{\\ln}(u)$ 中的高斯项使得被积函数在该范围外的值可以忽略不计，该范围覆盖了对数空间中分布的 $\\pm 6$ 个标准差。我们使用稳健的 `scipy.integrate.quad` 函数对 $f(u)$ 在此有限区间上执行数值积分。这将得出 $\\beta_{\\mathrm{ext}}$ 的值。\n\n最后，光学深度计算为 $\\tau = \\beta_{\\mathrm{ext}} \\times L$。对每个测试用例重复此过程，并按指定格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases defined by the tuple:\n    # (L, N0, rg, sigma_g, lam, mr, mi)\n    # L: path length (m)\n    # N0: total number concentration (m^-3)\n    # rg: geometric mean radius (m)\n    # sigma_g: geometric standard deviation (dimensionless)\n    # lam: wavelength (m)\n    # mr: real part of refractive index\n    # mi: imaginary part of refractive index\n    test_cases = [\n        (5000, 5.0e7, 1.0e-7, 1.6, 5.50e-7, 1.45, 0.0),\n        (500, 2.0e7, 2.0e-8, 1.4, 1.00e-6, 1.45, 0.0),\n        (10000, 1.0e8, 2.0e-7, 2.0, 5.50e-7, 1.50, 2.0e-2),\n        (10000, 1.0e6, 1.0e-6, 1.5, 5.50e-7, 1.45, 0.0),\n        (0, 5.0e7, 1.0e-7, 1.6, 5.50e-7, 1.45, 0.0),\n        (5000, 5.0e7, 1.0e-7, 1.01, 5.50e-7, 1.45, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        tau = calculate_optical_depth(*case)\n        # Format the result to six decimal places as a string.\n        results.append(f\"{tau:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_optical_depth(L, N0, rg, sigma_g, lam, mr, mi):\n    \"\"\"\n    Calculates the bulk optical depth for a given set of aerosol and path parameters.\n    \"\"\"\n    # Trivial case: zero path length means zero optical depth.\n    if L == 0.0:\n        return 0.0\n\n    # Construct the complex refractive index.\n    m = complex(mr, mi)\n\n    # 1. Pre-calculate constants based on the refractive index m.\n    m2 = m * m\n    R_m = (m2 - 1.0) / (m2 + 2.0)\n    K_m = (8.0 / 3.0) * (abs(R_m)**2)\n    D_m = max(0.0, 4.0 * R_m.imag)\n\n    # 2. Define the extinction efficiency function Q_ext.\n    def q_ext(r):\n        \"\"\"Calculates extinction efficiency for a given radius.\"\"\"\n        if r == 0:\n            return 0.0\n        # Size parameter x = 2*pi*r / lambda\n        x = (2.0 * np.pi * r) / lam\n        \n        # Saturating forms for Q_sca and Q_abs\n        q_sca = 2.0 * (1.0 - np.exp(-0.5 * K_m * x**4))\n        q_abs = 2.0 * (1.0 - np.exp(-0.5 * D_m * x))\n        \n        # Total extinction efficiency is the sum, capped at 2.\n        return min(2.0, q_sca + q_abs)\n\n    # 3. Define the integrand for the beta_ext integral.\n    # The integration variable is u = ln(r).\n    # Handle the case where sigma_g is very close to 1.\n    # The problem has sigma_g >= 1.01, so ln(sigma_g) is safe.\n    ln_rg = np.log(rg)\n    ln_sigma_g = np.log(sigma_g)\n    \n    # Pre-calculate normalization constant for n_ln(u)\n    n_ln_norm = N0 / (np.sqrt(2.0 * np.pi) * ln_sigma_g)\n    \n    def integrand(u):\n        \"\"\"\n        Defines the function to be integrated to find beta_ext.\n        Integrand = Q_ext(x(e^u), m) * pi * e^(2u) * n_ln(u)\n        \"\"\"\n        # Lognormal distribution part\n        exponent = -((u - ln_rg)**2) / (2.0 * ln_sigma_g**2)\n        n_ln_u = n_ln_norm * np.exp(exponent)\n        \n        # Radius from integration variable u\n        r = np.exp(u)\n        \n        # extinction efficiency at this radius\n        q_ext_val = q_ext(r)\n        \n        # Full expression for the integrand\n        return q_ext_val * np.pi * np.exp(2.0 * u) * n_ln_u\n\n    # 4. Perform the numerical integration.\n    # Integration limits are +/- 6 geometric standard deviations around the mean in log-space.\n    u_min = ln_rg - 6.0 * ln_sigma_g\n    u_max = ln_rg + 6.0 * ln_sigma_g\n\n    # Use scipy.integrate.quad for robust numerical integration.\n    beta_ext, _ = quad(integrand, u_min, u_max)\n\n    # 5. Calculate the final optical depth.\n    tau = beta_ext * L\n\n    return tau\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "注入平流层后，气溶胶群体并非静止不变。粒子会通过碰撞合并（即“碰并”过程），这会不断重塑其粒径分布，而气溶胶的辐射效率和大气存留时间又极大地依赖于其尺寸。这个实践要求你对比两种模拟方案：一种是忽略碰并的简化“体相”（bulk）模型，另一种是求解斯莫鲁霍夫斯基（Smoluchowski）碰并方程的更精确“分段”（sectional）模型 。通过实现这两种方案，你将能够量化忽略这一关键微物理过程所引入的误差，从而深刻理解为何精确的气溶胶模拟必须包含复杂的微物理动力学。",
            "id": "4096126",
            "problem": "考虑一个用于平流层气溶胶注入的零维箱式模型，该模型设定在温度 $T=220\\,\\mathrm{K}$、动力粘度 $\\mu=1.5\\times 10^{-5}\\,\\mathrm{Pa\\cdot s}$ 的低平流层中，充满了密度为 $\\rho=1760\\,\\mathrm{kg/m^3}$ 的硫酸气溶胶。箱体体积为 $V_{\\mathrm{box}}=10^{12}\\,\\mathrm{m^3}$。气溶胶粒子为球形，半径为 $r$。在时间 $t=0$ 时，一次瞬时注入质量为 $M_{\\mathrm{inj}}$ 的硫酸盐，形成一个初始粒子半径为 $r_{\\mathrm{inj}}$ 的单分散粒子群。由此产生的添加到箱体中的数浓度 $N_0$ 满足质量守恒：注入的硫酸盐体积为 $V_{\\mathrm{inj}} = M_{\\mathrm{inj}}/\\rho$，注入的粒子数量为 $N_{\\mathrm{inj}} = V_{\\mathrm{inj}} / v(r_{\\mathrm{inj}})$，其中 $v(r) = \\frac{4}{3}\\pi r^3$ 是粒子体积。添加到箱体中的数浓度为 $N_0 = N_{\\mathrm{inj}}/V_{\\mathrm{box}}$。\n\n我们考虑在时间范围 $t \\in [0, T_{\\mathrm{end}}]$（其中 $T_{\\mathrm{end}} = 2.592\\times 10^6\\,\\mathrm{s}$，即30天）内的两种模拟方案：\n\n1. 一种整体方案，忽略注入后的碰并过程。在此方案中，尺寸分布固定在其注入后的初始状态；因此，数浓度和分布不随时间变化。\n\n2. 一种分段参考方案，使用离散化的半径空间求解 Smoluchowski 碰并方程。设离散化的枢轴半径 $\\{r_k\\}_{k=1}^{N_b}$ 在区间 $[r_{\\min}, r_{\\max}]$ 内对数等距分布，其中 $r_{\\min}=2.0\\times 10^{-8}\\,\\mathrm{m}$，$r_{\\max}=5.0\\times 10^{-6}\\,\\mathrm{m}$，以及 $N_b=30$ 个粒径档。设 $n_k(t)$ 为时间 $t$ 时第 $k$ 个粒径档中的数浓度，与枢轴体积 $v_k = \\frac{4}{3}\\pi r_k^3$ 相关联。Smoluchowski 碰并方程控制着 $\\{n_k\\}$ 的演化：\n$$\n\\frac{dn_k}{dt} = \\frac{1}{2}\\sum_{i=1}^{N_b}\\sum_{j=1}^{N_b} K_{ij}\\,n_i\\,n_j\\,b_k(v_i+v_j) \\;-\\; n_k \\sum_{j=1}^{N_b} K_{kj} \\, n_j,\n$$\n其中 $K_{ij}$ 是布朗碰并核，$b_k(\\cdot)$ 是当体积为 $v_i+v_j$ 的粒子形成时保持体积守恒的粒径档分配权重。布朗扩散系数由斯托克斯-爱因斯坦关系式 $D_k = \\frac{k_B T}{6\\pi \\mu r_k}$ 给出，其中 $k_B=1.380649\\times 10^{-23}\\,\\mathrm{J/K}$ 是玻尔兹曼常数。连续区中的布朗碰并核为\n$$\nK_{ij} = 4\\pi\\left(D_i + D_j\\right)\\left(r_i + r_j\\right).\n$$\n对于粒径档分配，当一个体积为 $v=v_i+v_j$ 的新粒子落在相邻的枢轴体积 $v_k$ 和 $v_{k+1}$ 之间时，将数浓度贡献分配给第 $k$ 和第 $k+1$ 个粒径档，其权重为\n$$\nw_k = \\frac{v_{k+1} - v}{v_{k+1} - v_k}, \\quad w_{k+1} = \\frac{v - v_k}{v_{k+1} - v_k},\n$$\n且 $b_k(v)=w_k$，$b_{k+1}(v)=w_{k+1}$，确保 $w_k+w_{k+1}=1$ 和 $w_k v_k + w_{k+1} v_{k+1} = v$。如果 $v \\le v_1$，则完全分配给第 1 个粒径档；如果 $v \\ge v_{N_b}$，则完全分配给第 $N_b$ 个粒径档。使用常数时间步长 $\\Delta t = 3600\\,\\mathrm{s}$ 的显式时间步进法，并将 $n_k(t)$ 限制为非负值以保持物理真实性。\n\n定义时间 $t$ 时分布的有效半径 $r_{\\mathrm{eff}}(t)$ 为矩比\n$$\nr_{\\mathrm{eff}}(t) = \\frac{\\sum_{k=1}^{N_b} n_k(t)\\,r_k^3}{\\sum_{k=1}^{N_b} n_k(t)\\,r_k^2},\n$$\n以及总数浓度 $N(t) = \\sum_{k=1}^{N_b} n_k(t)$。对于整体方案，$n_k(t)$ 不随时间变化，等于注入后的初始值。\n\n您的任务是实现这两种方案，并为每个指定的测试用例，在 $t=T_{\\mathrm{end}}$ 时计算整体方案与分段参考方案相比，因忽略碰并而引入的误差：\n- 数浓度偏差 $E_N = \\frac{N_{\\mathrm{bulk}}(T_{\\mathrm{end}}) - N_{\\mathrm{sect}}(T_{\\mathrm{end}})}{N_{\\mathrm{sect}}(T_{\\mathrm{end}})}$（无量纲，以十进制数表示）。\n- 有效半径偏差 $E_r = \\frac{r_{\\mathrm{eff,bulk}}(T_{\\mathrm{end}}) - r_{\\mathrm{eff,sect}}(T_{\\mathrm{end}})}{r_{\\mathrm{eff,sect}}(T_{\\mathrm{end}})}$（无量纲，以十进制数表示）。\n\n通过使用上述体积守恒权重，将单分散的 $N_0$ 在 $r_{\\mathrm{inj}}$ 处分配到枢轴粒径档中来初始化注入后的分布，使得初始的 $n_k(0)$ 在数量和体积上都与注入保持一致。\n\n测试套件：\n对于所有情况，使用 $T=220\\,\\mathrm{K}$，$\\mu=1.5\\times 10^{-5}\\,\\mathrm{Pa\\cdot s}$，$\\rho=1760\\,\\mathrm{kg/m^3}$，$V_{\\mathrm{box}}=10^{12}\\,\\mathrm{m^3}$，$N_b=30$，$r_{\\min}=2.0\\times 10^{-8}\\,\\mathrm{m}$，$r_{\\max}=5.0\\times 10^{-6}\\,\\mathrm{m}$，$\\Delta t=3600\\,\\mathrm{s}$，$T_{\\mathrm{end}}=2.592\\times 10^6\\,\\mathrm{s}$。注入场景如下：\n- 情况 A（基准）：$M_{\\mathrm{inj}} = 1000\\,\\mathrm{kg}$，$r_{\\mathrm{inj}} = 1.0\\times 10^{-7}\\,\\mathrm{m}$。\n- 情况 B（较小粒子）：$M_{\\mathrm{inj}} = 1000\\,\\mathrm{kg}$，$r_{\\mathrm{inj}} = 5.0\\times 10^{-8}\\,\\mathrm{m}$。\n- 情况 C（较大粒子）：$M_{\\mathrm{inj}} = 1000\\,\\mathrm{kg}$，$r_{\\mathrm{inj}} = 2.0\\times 10^{-7}\\,\\mathrm{m}$。\n- 情况 D（低质量）：$M_{\\mathrm{inj}} = 10\\,\\mathrm{kg}$，$r_{\\mathrm{inj}} = 1.0\\times 10^{-7}\\,\\mathrm{m}$。\n- 情况 E（高质量，小粒子）：$M_{\\mathrm{inj}} = 10000\\,\\mathrm{kg}$，$r_{\\mathrm{inj}} = 5.0\\times 10^{-8}\\,\\mathrm{m}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个双元素列表 [$E_N$, $E_r$]，两者均以保留小数点后六位的十进制数提供。例如，输出格式必须为：[[eN_A,eR_A],[eN_B,eR_B],[eN_C,eR_C],[eN_D,eR_D],[eN_E,eR_E]]。",
            "solution": "### 问题验证\n\n#### 步骤 1：提取已知条件\n\n问题为平流层气溶胶碰并的零维箱式模型提供了以下数据和定义：\n\n**常量和模型参数：**\n- 低平流层温度：$T=220\\,\\mathrm{K}$\n- 动力粘度：$\\mu=1.5\\times 10^{-5}\\,\\mathrm{Pa\\cdot s}$\n- 硫酸气溶胶密度：$\\rho=1760\\,\\mathrm{kg/m^3}$\n- 箱式模型体积：$V_{\\mathrm{box}}=10^{12}\\,\\mathrm{m^3}$\n- 玻尔兹曼常数：$k_B=1.380649\\times 10^{-23}\\,\\mathrm{J/K}$\n- 模拟时间范围：$T_{\\mathrm{end}} = 2.592\\times 10^6\\,\\mathrm{s}$ (30天)\n- 模拟时间步长：$\\Delta t = 3600\\,\\mathrm{s}$\n\n**分段方案参数：**\n- 半径粒径档数量：$N_b=30$\n- 最小枢轴半径：$r_{\\min}=2.0\\times 10^{-8}\\,\\mathrm{m}$\n- 最大枢轴半径：$r_{\\max}=5.0\\times 10^{-6}\\,\\mathrm{m}$\n- 枢轴半径 $\\{r_k\\}_{k=1}^{N_b}$ 在 $[r_{\\min}, r_{\\max}]$ 区间内呈对数等距分布。\n\n**方程和定义：**\n- 粒子体积：$v(r) = \\frac{4}{3}\\pi r^3$\n- 注入后数浓度：$N_0 = (M_{\\mathrm{inj}}/\\rho) / v(r_{\\mathrm{inj}}) / V_{\\mathrm{box}}$\n- 布朗扩散系数：$D_k = \\frac{k_B T}{6\\pi \\mu r_k}$\n- 布朗碰并核：$K_{ij} = 4\\pi\\left(D_i + D_j\\right)\\left(r_i + r_j\\right)$\n- 分段方案的 Smoluchowski 碰并方程：\n$$ \\frac{dn_k}{dt} = \\frac{1}{2}\\sum_{i=1}^{N_b}\\sum_{j=1}^{N_b} K_{ij}\\,n_i\\,n_j\\,b_k(v_i+v_j) \\;-\\; n_k \\sum_{j=1}^{N_b} K_{kj} \\, n_j $$\n- 对于一个体积为 $v$ 且介于 $v_k$ 和 $v_{k+1}$ 之间的新粒子，其体积守恒的粒径档分配权重为：\n$$ w_k = \\frac{v_{k+1} - v}{v_{k+1} - v_k}, \\quad w_{k+1} = \\frac{v - v_k}{v_{k+1} - v_k} $$\n- 有效半径：$r_{\\mathrm{eff}}(t) = \\frac{\\sum_{k=1}^{N_b} n_k(t)\\,r_k^3}{\\sum_{k=1}^{N_b} n_k(t)\\,r_k^2}$\n- 总数浓度：$N(t) = \\sum_{k=1}^{N_b} n_k(t)$\n- 数浓度偏差：$E_N = \\frac{N_{\\mathrm{bulk}}(T_{\\mathrm{end}}) - N_{\\mathrm{sect}}(T_{\\mathrm{end}})}{N_{\\mathrm{sect}}(T_{\\mathrm{end}})}$\n- 有效半径偏差：$E_r = \\frac{r_{\\mathrm{eff,bulk}}(T_{\\mathrm{end}}) - r_{\\mathrm{eff,sect}}(T_{\\mathrm{end}})}{r_{\\mathrm{eff,sect}}(T_{\\mathrm{end}})}$\n\n**测试套件：**\n- 情况 A：$M_{\\mathrm{inj}} = 1000\\,\\mathrm{kg}$，$r_{\\mathrm{inj}} = 1.0\\times 10^{-7}\\,\\mathrm{m}$\n- 情况 B：$M_{\\mathrm{inj}} = 1000\\,\\mathrm{kg}$，$r_{\\mathrm{inj}} = 5.0\\times 10^{-8}\\,\\mathrm{m}$\n- 情况 C：$M_{\\mathrm{inj}} = 1000\\,\\mathrm{kg}$，$r_{\\mathrm{inj}} = 2.0\\times 10^{-7}\\,\\mathrm{m}$\n- 情况 D：$M_{\\mathrm{inj}} = 10\\,\\mathrm{kg}$，$r_{\\mathrm{inj}} = 1.0\\times 10^{-7}\\,\\mathrm{m}$\n- 情况 E：$M_{\\mathrm{inj}} = 10000\\,\\mathrm{kg}$，$r_{\\mathrm{inj}} = 5.0\\times 10^{-8}\\,\\mathrm{m}$\n\n#### 步骤 2：使用提取的已知条件进行验证\n\n根据验证标准对问题进行审查：\n- **科学依据**：该问题牢固地植根于大气气溶胶科学。箱式模型是一种标准的简化方法，而用于求解 Smoluchowski 碰并方程的分段法是一种成熟的数值技术。布朗扩散（斯托克斯-爱因斯坦关系）和碰并核的方程是基础性的，并且对所指定的粒子尺寸和大气条件下的连续区是正确陈述的。物理常数和参数对于低平流层是现实的。\n- **适定性**：该问题是一个定义明确的常微分方程组初值问题。所有必要的参数、初始条件、离散化方案（对数网格）、数值方法（显式时间步进）和边界条件（限制浓度、对小/大碰并产物进行分档）都已明确提供。任务是计算唯一定义的误差度量。\n- **客观性**：问题以精确、定量和无偏见的数学和物理语言陈述。没有主观因素。\n- **完整性和一致性**：问题是自洽的。所有常数、方程、每个测试用例的初始条件以及数值参数（$N_b$、$\\Delta t$、$T_{\\mathrm{end}}$）都已给出。设置中没有明显的矛盾。体积守恒的分档方案有明确的定义且一致。\n- **可行性**：指定的条件在物理上是合理的。使用给定的参数（$N_b=30$，$T_{\\mathrm{end}}/\\Delta t = 720$ 步），数值模拟在计算上是可行的。\n\n#### 步骤 3：结论与行动\n\n问题陈述是**有效**的。这是一个在数值气溶胶物理学中适定、有科学依据且计算上可处理的问题。可以继续进行求解。\n\n### 求解设计\n\n求解过程需要实现气溶胶碰并的数值模拟。核心是实现分段方案来求解 Smoluchowski 碰并方程，并将其结果与简化的整体方案进行比较。\n\n**1. 模型设置和预计算：**\n首先，定义所有物理常数（$k_B$、$T$、$\\mu$、$\\rho$、$V_{\\mathrm{box}}$）和数值参数（$N_b$、$r_{\\min}$、$r_{\\max}$、$\\Delta t$、$T_{\\mathrm{end}}$）。\n在区间 $[r_{\\min}, r_{\\max}]$ 上创建一个由 $N_b$ 个枢轴半径 $\\{r_k\\}$ 组成的对数等分网格。同时计算相应的枢轴粒子体积 $\\{v_k = \\frac{4}{3}\\pi r_k^3\\}$。\n为了优化模拟，预先计算不随时间变化的量：\n- 使用斯托克斯-爱因斯坦关系式计算布朗扩散系数向量 $\\{D_k\\}$。\n- 使用布朗碰并核的公式计算 $N_b \\times N_b$ 的对称碰并核矩阵 $\\{K_{ij}\\}$。这可以通过向量化操作高效计算。\n\n**2. 初始条件：**\n对于由注入质量 $M_{\\mathrm{inj}}$ 和半径 $r_{\\mathrm{inj}}$ 定义的每个测试用例，必须计算初始数浓度分布 $\\{n_k(0)\\}$。\n- 总注入体积为 $V_{\\mathrm{inj}} = M_{\\mathrm{inj}} / \\rho$。\n- 单个注入粒子的体积为 $v_{\\mathrm{inj}} = \\frac{4}{3}\\pi r_{\\mathrm{inj}}^3$。\n- 总注入粒子数为 $N_{\\mathrm{inj}} = V_{\\mathrm{inj}} / v_{\\mathrm{inj}}$。\n- 箱体中的初始总数浓度为 $N_0 = N_{\\mathrm{inj}} / V_{\\mathrm{box}}$。\n然后，将这个单分散粒子的初始浓度 $N_0$ 分配到离散的粒径档中。使用指定的体积守恒线性插值方案。如果 $v_{\\mathrm{inj}}$ 落在枢轴体积 $v_k$ 和 $v_{k+1}$ 之间，则将数浓度 $N_0$ 分配到第 $k$ 和第 $k+1$ 档，以同时保持总数和总体积守恒。对于 $v_{\\mathrm{inj}}$ 落在枢轴体积范围 $[v_1, v_{N_b}]$ 之外的情况，需要特殊处理。\n\n**3. 模拟方案：**\n\n**a. 整体方案：**\n这个方案非常简单。它假设注入后不发生碰并。因此，数浓度分布 $\\{n_k(t)\\}$ 和所有派生量（$N(t)$、$r_{\\mathrm{eff}}(t)$）都保持恒定，等于它们在 $t=0$ 时的初始值。最终状态与初始状态相同。\n\n**b. 分段方案：**\n该方案使用常数时间步长 $\\Delta t$ 的显式欧拉法，将 Smoluchowski 碰并方程从 $t=0$ 到 $t=T_{\\mathrm{end}}$ 进行数值积分。\n每个粒径档 $k$ 中数浓度的变化率 $\\frac{dn_k}{dt}$ 由一个增益项和一个损失项组成。\n- **损失项 ($L_k$)**：这表示第 $k$ 档的粒子因与任何其他粒径档 $j$ 的粒子发生碰并而被移除。其计算公式为 $L_k = n_k \\sum_{j=1}^{N_b} K_{kj} n_j$。在矩阵形式中，这是一个通过 `n * (K @ n)` 计算的向量。\n- **增益项 ($G_k$)**：这表示形成并落入第 $k$ 档的新粒子。它通过对所有可能的碰并对 $(i, j)$ 进行求和来计算：$G_k = \\frac{1}{2}\\sum_{i=1}^{N_b}\\sum_{j=1}^{N_b} K_{ij}\\,n_i\\,n_j\\,b_k(v_i+v_j)$。这通过对所有粒径档对 $(i, j)$ 的嵌套循环实现。对于每一对，计算新形成粒子的体积 $v_{\\mathrm{new}} = v_i + v_j$。然后，使用与初始化步骤中相同的体积守恒加权方案，将形成速率 $\\frac{1}{2} K_{ij} n_i n_j$ 分配到适当的粒径档中。\n\n时间步进过程为：$n_k(t+\\Delta t) = n_k(t) + (G_k(t) - L_k(t))\\,\\Delta t$。每一步之后，将任何产生的负浓度限制为 0，以保持物理真实性。这个过程重复总步数 $T_{\\mathrm{end}}/\\Delta t$ 次。\n\n**4. 度量和偏差的计算：**\n在给定测试用例的模拟完成后，我们得到整体方案的最终数分布 $\\{n_{k, \\mathrm{bulk}}(T_{\\mathrm{end}})\\}$ 和分段方案的最终数分布 $\\{n_{k, \\mathrm{sect}}(T_{\\mathrm{end}})\\}$。\n- 通过对所有粒径档的浓度求和，计算总数浓度 $N_{\\mathrm{bulk}}$ 和 $N_{\\mathrm{sect}}$。\n- 使用提供的矩比公式计算有效半径 $r_{\\mathrm{eff, bulk}}$ 和 $r_{\\mathrm{eff, sect}}$。\n最后，根据问题陈述中定义的公式计算相对偏差 $E_N$ 和 $E_r$。对五个测试用例中的每一个重复此整个过程。然后将收集到的结果格式化为所需的输出字符串。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the aerosol coagulation problem by implementing and comparing\n    a bulk scheme and a sectional reference scheme.\n    \"\"\"\n\n    # --- 1. Constants and Model Parameters ---\n    T = 220.0  # Temperature [K]\n    MU = 1.5e-5  # Dynamic viscosity [Pa*s]\n    RHO = 1760.0  # Aerosol density [kg/m^3]\n    V_BOX = 1.0e12  # Box volume [m^3]\n    KB = 1.380649e-23  # Boltzmann constant [J/K]\n    T_END = 2.592e6  # Simulation end time [s] (30 days)\n    DT = 3600.0  # Time step [s]\n\n    # Sectional scheme parameters\n    N_B = 30  # Number of bins\n    R_MIN = 2.0e-8  # Min radius [m]\n    R_MAX = 5.0e-6  # Max radius [m]\n\n    # Test suite\n    test_cases = [\n        # M_inj [kg], r_inj [m]\n        (1000.0, 1.0e-7),  # Case A\n        (1000.0, 5.0e-8),  # Case B\n        (1000.0, 2.0e-7),  # Case C\n        (10.0, 1.0e-7),    # Case D\n        (10000.0, 5.0e-8), # Case E\n    ]\n\n    # --- 2. Pre-computation ---\n    # Logarithmically spaced radius and volume grids\n    radii = np.logspace(np.log10(R_MIN), np.log10(R_MAX), N_B, dtype=np.float64)\n    volumes = (4.0 / 3.0) * np.pi * radii**3\n\n    # Diffusion coefficients\n    D = KB * T / (6.0 * np.pi * MU * radii)\n\n    # Coagulation kernel matrix K[i, j]\n    radii_i, radii_j = np.meshgrid(radii, radii, indexing='ij')\n    D_i, D_j = np.meshgrid(D, D, indexing='ij')\n    K = 4.0 * np.pi * (D_i + D_j) * (radii_i + radii_j)\n    \n    # --- Helper Functions ---\n    def initialize_distribution(m_inj, r_inj):\n        v_inj = (4.0 / 3.0) * np.pi * r_inj**3\n        n_inj_total = (m_inj / RHO) / v_inj\n        n0_conc = n_inj_total / V_BOX\n\n        n_initial = np.zeros(N_B, dtype=np.float64)\n        \n        # Find bin index for injection volume\n        # np.searchsorted finds insertion point to maintain order\n        idx = np.searchsorted(volumes, v_inj)\n\n        if idx == 0:\n            # smaller than or equal to the smallest pivot volume\n            n_initial[0] = n0_conc\n        elif idx == N_B:\n            # larger than the largest pivot volume\n            n_initial[N_B - 1] = n0_conc\n        else:\n            # Falls between volumes[idx-1] and volumes[idx]\n            v_k = volumes[idx - 1]\n            v_k_plus_1 = volumes[idx]\n            \n            # Volume-conserving weights\n            w_k = (v_k_plus_1 - v_inj) / (v_k_plus_1 - v_k)\n            w_k_plus_1 = 1.0 - w_k\n\n            # Apportion concentration to bins to conserve number and volume\n            n_initial[idx - 1] = n0_conc * w_k\n            n_initial[idx] = n0_conc * w_k_plus_1\n            \n        return n_initial\n\n    def calculate_metrics(n_dist):\n        if np.sum(n_dist) == 0:\n            return 0.0, 0.0\n        \n        total_number = np.sum(n_dist)\n        \n        sum_r2 = np.sum(n_dist * radii**2)\n        if sum_r2 == 0:\n            r_eff = 0.0\n        else:\n            sum_r3 = np.sum(n_dist * radii**3)\n            r_eff = sum_r3 / sum_r2\n            \n        return total_number, r_eff\n        \n    def calculate_dndt(n):\n        dndt = np.zeros(N_B, dtype=np.float64)\n\n        # Loss term: n_k * sum_j(K_kj * n_j)\n        loss = n * (K @ n)\n        dndt -= loss\n        \n        # Gain term: 0.5 * sum_i,j(K_ij * n_i * n_j * b_k(v_i+v_j))\n        # Note: The factor of 0.5 is because we sum over all (i, j) pairs.\n        for i in range(N_B):\n            for j in range(N_B):\n                if n[i] == 0 or n[j] == 0:\n                    continue\n                \n                coag_rate = 0.5 * K[i, j] * n[i] * n[j]\n                \n                v_new = volumes[i] + volumes[j]\n                \n                idx = np.searchsorted(volumes, v_new)\n\n                if idx == 0:\n                    dndt[0] += coag_rate\n                elif idx >= N_B:\n                    dndt[N_B - 1] += coag_rate\n                else:\n                    v_k = volumes[idx - 1]\n                    v_k_plus_1 = volumes[idx]\n                    \n                    w_k = (v_k_plus_1 - v_new) / (v_k_plus_1 - v_k)\n                    \n                    dndt[idx - 1] += coag_rate * w_k\n                    dndt[idx] += coag_rate * (1.0 - w_k)\n        \n        return dndt\n\n    # --- Main Simulation Loop ---\n    results = []\n    num_steps = int(T_END / DT)\n\n    for m_inj, r_inj in test_cases:\n        # Initial distribution\n        n_initial = initialize_distribution(m_inj, r_inj)\n\n        # --- Bulk Scheme ---\n        # No evolution, final state is initial state\n        n_bulk_final = n_initial\n        N_bulk, r_eff_bulk = calculate_metrics(n_bulk_final)\n\n        # --- Sectional Scheme ---\n        n_sect = n_initial.copy()\n        for _ in range(num_steps):\n            dndt = calculate_dndt(n_sect)\n            n_sect += dndt * DT\n            n_sect = np.maximum(0.0, n_sect) # Clamp to non-negative\n\n        N_sect, r_eff_sect = calculate_metrics(n_sect)\n\n        # Calculate biases\n        E_N = (N_bulk - N_sect) / N_sect if N_sect != 0 else np.nan\n        E_r = (r_eff_bulk - r_eff_sect) / r_eff_sect if r_eff_sect != 0 else np.nan\n        \n        results.append([round(E_N, 6), round(E_r, 6)])\n\n    # --- Final Output Formatting ---\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "真实的SAI模拟不是孤立物理过程的简单集合，而是一个紧密耦合的系统。气溶胶影响辐射和温度，温度变化驱动风场，而风场又反过来影响气溶胶的分布。准确地捕捉这些反馈是数值模拟中的一个核心挑战。这个实践专注于双向耦合的数值实现 。你将实现一个迭代式的求解器（类似于高斯-赛德尔方法），在一个模式时间步内，为辐射、微物理和动力学过程寻找一个自洽的解。这项高级练习将让你一窥复杂气候模式的“引擎室”，对于开发稳定且物理上一致的耦合模型至关重要。",
            "id": "4096183",
            "problem": "您的任务是在一个简化的单层平流层柱状模型中，评估辐射、微物理和动力学之间的双向耦合。该模型与数值天气预报（NWP）和气候模拟中的平流层气溶胶注入（SAI）模拟相关。目标是构建一个程序，在单个时间步内执行迭代耦合更新，该更新使用高斯-赛德尔（Gauss–Seidel）式序列和欠松弛方法，并验证耦合状态的收敛性。\n\n从大气模拟中常见的物理基础出发：\n- 辐射加热被模拟为牛顿冷却加上直接的气溶胶扰动。\n- 气溶胶质量混合比守恒，其源项和汇项代表注入、碰并、沉降和动力稀释。\n- 线性化的动量趋势，其中温度异常驱动风的变化，拖曳力则削弱流速。\n\n定义预报状态向量为 $(T, q, u)$，其中 $T$ 是温度（单位：开尔文），$q$ 是气溶胶质量混合比（单位：$\\mathrm{kg}/\\mathrm{kg}$），$u$ 是水平风速（单位：$\\mathrm{m}/\\mathrm{s}$）。在一个长度为 $\\Delta t$（单位：秒）的时间步内，定义以下趋势，每个趋势都使用迭代中最新的变量子集进行评估：\n\n- 温度的辐射趋势：\n$$\\dot{T}_{\\mathrm{rad}}(T, q) = -k_r\\,(T - T_{\\mathrm{eq}}) - \\chi\\,q,$$\n其中 $k_r$ 是牛顿冷却率（单位：$\\mathrm{s}^{-1}$），$T_{\\mathrm{eq}}$ 是平衡温度（单位：开尔文），$\\chi$ 是一个将气溶胶负载转换为净辐射冷却率的系数（单位：$\\mathrm{K}\\,\\mathrm{s}^{-1}\\,(\\mathrm{kg}/\\mathrm{kg})^{-1}$）。\n\n- 气溶胶质量混合比的微物理趋势：\n$$\\dot{q}_{\\mathrm{mic}}(q, u) = S - k_c\\,q^2 - k_{\\mathrm{sed}}\\,q - \\frac{|u|}{L_{\\mathrm{dil}}}\\,q,$$\n其中 $S$ 是注入源率（单位：$\\mathrm{kg}/\\mathrm{kg}/\\mathrm{s}$），$k_c$ 是碰并系数（单位：$\\mathrm{s}^{-1}\\,(\\mathrm{kg}/\\mathrm{kg})^{-1}$），$k_{\\mathrm{sed}}$ 是沉降率（单位：$\\mathrm{s}^{-1}$），$L_{\\mathrm{dil}}$ 是稀释长度尺度（单位：$\\mathrm{m}$）。\n\n- 风速的动力趋势：\n$$\\dot{u}_{\\mathrm{dyn}}(T, u) = -k_p\\,(T - T_{\\mathrm{eq}}) - k_d\\,u,$$\n其中 $k_p$ 是耦合系数（单位：$\\mathrm{m}\\,\\mathrm{s}^{-2}\\,\\mathrm{K}^{-1}$），$k_d$ 是线性拖曳系数（单位：$\\mathrm{s}^{-1}$）。\n\n在每个内部耦合迭代中，使用高斯-赛德尔（Gauss–Seidel）排序和欠松弛因子 $\\alpha \\in (0, 1)$ 应用顺序更新算子 $\\mathcal{G}$：\n1. 使用辐射计算临时温度：\n$$T^{\\ast} = T + \\Delta t\\,\\dot{T}_{\\mathrm{rad}}(T, q).$$\n2. 使用当前风速，通过微物理计算临时气溶胶：\n$$q^{\\ast} = q + \\Delta t\\,\\dot{q}_{\\mathrm{mic}}(q, u).$$\n3. 使用更新后的温度强迫，通过动力学计算临时风速：\n$$u^{\\ast} = u + \\Delta t\\,\\dot{u}_{\\mathrm{dyn}}(T^{\\ast}, u).$$\n4. 进行欠松弛以形成下一个迭代值：\n$$T_{\\mathrm{new}} = T + \\alpha\\,(T^{\\ast} - T), \\quad q_{\\mathrm{new}} = \\max\\bigl(0,\\, q + \\alpha\\,(q^{\\ast} - q)\\bigr), \\quad u_{\\mathrm{new}} = u + \\alpha\\,(u^{\\ast} - u).$$\n这里，通过以 $0$ 为下限来强制气溶胶的非负性。\n\n收敛要求：如果绝对变化满足以下条件，则迭代收敛：\n$$|T_{\\mathrm{new}} - T| \\le \\varepsilon_T,\\quad |q_{\\mathrm{new}} - q| \\le \\varepsilon_q,\\quad |u_{\\mathrm{new}} - u| \\le \\varepsilon_u,$$\n其中 $\\varepsilon_T$ 的单位是开尔文，$\\varepsilon_q$ 的单位是 $\\mathrm{kg}/\\mathrm{kg}$，$\\varepsilon_u$ 的单位是 $\\mathrm{m}/\\mathrm{s}$，均为指定的容差。此外，计算一个无量纲残差\n$$r = \\max\\left(\\frac{|T_{\\mathrm{new}} - T|}{S_T},\\,\\frac{|q_{\\mathrm{new}} - q|}{S_q},\\,\\frac{|u_{\\mathrm{new}} - u|}{S_u}\\right),$$\n使用归一化尺度 $S_T$（单位：开尔文）、$S_q$（单位：$\\mathrm{kg}/\\mathrm{kg}$）和 $S_u$（单位：$\\mathrm{m}/\\mathrm{s}$），并报告 $r$ 值，无论是否达到收敛。在收敛或达到最大迭代次数后终止迭代。\n\n在所有测试用例中，使用以下科学上合理的通用参数值：\n- $k_r = \\dfrac{1}{5 \\times 24 \\times 3600}\\ \\mathrm{s}^{-1}$，对应于 $5$ 天的牛顿冷却时间尺度。\n- $T_{\\mathrm{eq}} = 230\\ \\mathrm{K}$。\n- $\\chi = 2.0\\ \\mathrm{K}\\,\\mathrm{s}^{-1}\\,(\\mathrm{kg}/\\mathrm{kg})^{-1}$。\n- $k_c = 10^{4}\\ \\mathrm{s}^{-1}\\,(\\mathrm{kg}/\\mathrm{kg})^{-1}$。\n- $k_{\\mathrm{sed}} = 10^{-6}\\ \\mathrm{s}^{-1}$。\n- $L_{\\mathrm{dil}} = 10^{6}\\ \\mathrm{m}$。\n- $k_p = 10^{-4}\\ \\mathrm{m}\\,\\mathrm{s}^{-2}\\,\\mathrm{K}^{-1}$。\n- $k_d = 10^{-5}\\ \\mathrm{s}^{-1}$。\n- 欠松弛因子 $\\alpha = 0.3$。\n- 收敛容差 $\\varepsilon_T = 10^{-6}\\ \\mathrm{K}$，$\\varepsilon_q = 10^{-12}\\ \\mathrm{kg}/\\mathrm{kg}$，$\\varepsilon_u = 10^{-6}\\ \\mathrm{m}/\\mathrm{s}$。\n- 残差归一化尺度 $S_T = 1.0\\ \\mathrm{K}$，$S_q = 10^{-9}\\ \\mathrm{kg}/\\mathrm{kg}$，$S_u = 1.0\\ \\mathrm{m}/\\mathrm{s}$。\n- 最大内部迭代次数 $N_{\\max} = 200$。\n\n在以下五个测试用例上实现并测试您的程序（每个用例是一个元组 $(\\Delta t, S, T_0, q_0, u_0)$，单位如前所述）：\n- 用例 A（常规正常路径）：$(600,\\ 5\\times 10^{-11},\\ 230,\\ 1\\times 10^{-7},\\ 10)$。\n- 用例 B（边界情况，短时间步，无注入）：$(60,\\ 0,\\ 230,\\ 1\\times 10^{-8},\\ 5)$。\n- 用例 C（强注入，可能存在刚性微物理）：$(600,\\ 5\\times 10^{-10},\\ 228,\\ 5\\times 10^{-8},\\ 2)$。\n- 用例 D（导致强稀释的大风）：$(600,\\ 2\\times 10^{-10},\\ 232,\\ 2\\times 10^{-7},\\ 45)$。\n- 用例 E（接近稳定性极限的大时间步）：$(1800,\\ 5\\times 10^{-10},\\ 235,\\ 1\\times 10^{-7},\\ 10)$。\n\n对于每个测试用例，程序必须：\n- 迭代应用带有欠松弛的耦合算子，直到收敛或达到最大迭代次数。\n- 报告一个结果列表，包含：收敛布尔值、总迭代次数整数、无量纲残差 $r$ 浮点数、最终温度 $T$（单位：开尔文）、最终气溶胶混合比 $q$（单位：$\\mathrm{kg}/\\mathrm{kg}$）和最终风速 $u$（单位：$\\mathrm{m}/\\mathrm{s}$）。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的每个元素是对应测试用例（按 A、B、C、D、E 的顺序）的结果列表。例如，格式必须严格为\n$$[\\,[\\mathrm{bool},\\,\\mathrm{int},\\,\\mathrm{float},\\,\\mathrm{float},\\,\\mathrm{float},\\,\\mathrm{float}],\\,[\\mathrm{bool},\\,\\mathrm{int},\\,\\mathrm{float},\\,\\mathrm{float},\\,\\mathrm{float},\\,\\mathrm{float}],\\,\\dots\\,]$$\n所有浮点数都以其原生的数值表示，其中 $T$ 的单位是开尔文，$q$ 的单位是 $\\mathrm{kg}/\\mathrm{kg}$，$u$ 的单位是 $\\mathrm{m}/\\mathrm{s}$。不应打印任何其他文本。",
            "solution": "该问题陈述经过了严格验证，被确定为一个有效的、适定的、且具有科学依据的计算问题。它描述了一个简化的、但在物理上具有代表性的用于平流层气溶胶注入（SAI）建模的耦合系统，并要求实现一个数值求解器。其参数、方程和数值方案都得到了充分详细和清晰的说明，从而能够得到唯一且可验证的解。\n\n问题的核心是在单个时间步长 $\\Delta t$ 结束时，求解一个简化大气柱状模型的状态。该状态由向量 $(T, q, u)$ 定义，其中 $T$ 是温度，$q$ 是气溶胶质量混合比，$u$ 是水平风速。这些变量的演化由一个耦合的非线性常微分方程组控制。每个变量的趋势（时间导数）如下：\n\n- 温度趋势（辐射）：\n$$ \\dot{T}_{\\mathrm{rad}}(T, q) = -k_r\\,(T - T_{\\mathrm{eq}}) - \\chi\\,q $$\n该方程模拟了牛顿冷却，其中温度 $T$ 以速率 $k_r$ 向平衡温度 $T_{\\mathrm{eq}}$ 弛豫，外加一个由气溶胶混合比 $q$ 产生的直接冷却效应，该效应由系数 $\\chi$ 控制。这展示了辐射依赖于气溶胶状态的耦合关系。\n\n- 气溶胶趋势（微物理）：\n$$ \\dot{q}_{\\mathrm{mic}}(q, u) = S - k_c\\,q^2 - k_{\\mathrm{sed}}\\,q - \\frac{|u|}{L_{\\mathrm{dil}}}\\,q $$\n该方程平衡了气溶胶质量混合比 $q$。它包括一个源项 $S$（注入），一个来自碰并的汇项 ($k_c\\,q^2$)，一个来自沉降的汇项 ($k_{\\mathrm{sed}}\\,q$)，以及一个来自动力稀释的汇项，后者被参数化为与风速 $|u|$ 成正比，并除以一个长度尺度 $L_{\\mathrm{dil}}$。这显示了微物理依赖于动力状态（风）的耦合关系。\n\n- 风速趋势（动力学）：\n$$ \\dot{u}_{\\mathrm{dyn}}(T, u) = -k_p\\,(T - T_{\\mathrm{eq}}) - k_d\\,u $$\n该方程代表了一个简化的动量平衡。相对于平衡温度的温度异常 $T - T_{\\mathrm{eq}}$ 会产生驱动风变化的压力梯度，由系数 $k_p$ 表示。风受到一个线性拖曳项的阻力，其系数为 $k_d$。这完成了耦合循环，因为动力学依赖于热力状态（温度）。\n\n由于循环耦合 ($T \\rightarrow u \\rightarrow q \\rightarrow T$) 的存在，对系统进行直接的前向欧拉更新将是不准确的，且可能不稳定。一种更稳健的方法，如题目所指定，是在时间步内迭代求解该耦合系统。问题规定了一种带有欠松弛的高斯-赛德尔（Gauss–Seidel）式迭代方法。在单个时间步内的每次迭代中，状态变量被顺序更新，并在序列中使用其他变量的最新计算值。\n\n将状态从 $(T, q, u)$ 更新到 $(T_{\\mathrm{new}}, q_{\\mathrm{new}}, u_{\\mathrm{new}})$ 的迭代过程如下：\n\n1.  使用上一次迭代的状态 $(T, q, u)$ 计算一个临时温度 $T^{\\ast}$：\n    $$ T^{\\ast} = T + \\Delta t\\,\\dot{T}_{\\mathrm{rad}}(T, q) $$\n2.  同样使用上一次迭代的状态 $(q, u)$ 计算一个临时气溶胶混合比 $q^{\\ast}$：\n    $$ q^{\\ast} = q + \\Delta t\\,\\dot{q}_{\\mathrm{mic}}(q, u) $$\n3.  计算一个临时风速 $u^{\\ast}$。至关重要的是，根据高斯-赛德尔方法，这一步使用新计算的临时温度 $T^{\\ast}$ 而不是旧温度 $T$，同时使用旧风速 $u$：\n    $$ u^{\\ast} = u + \\Delta t\\,\\dot{u}_{\\mathrm{dyn}}(T^{\\ast}, u) $$\n4.  当前迭代的最终状态 $(T_{\\mathrm{new}}, q_{\\mathrm{new}}, u_{\\mathrm{new}})$ 是通过应用带有因子 $\\alpha$ 的欠松弛得到的。这是旧状态和临时新状态的加权平均，有助于稳定迭代并防止超调，尤其是在刚性或紧耦合系统中。\n    $$ T_{\\mathrm{new}} = T + \\alpha\\,(T^{\\ast} - T) $$\n    $$ q_{\\mathrm{new}} = \\max\\bigl(0,\\, q + \\alpha\\,(q^{\\ast} - q)\\bigr) $$\n    $$ u_{\\mathrm{new}} = u + \\alpha\\,(u^{\\ast} - u) $$\n    对气溶胶混合比 $q$ 强制施加了物理非负性约束。\n\n重复此迭代过程，直到连续迭代中所有状态变量的绝对变化量都低于指定的容差 $(\\varepsilon_T, \\varepsilon_q, \\varepsilon_u)$，或者直到达到最大迭代次数 $N_{\\max}$。\n\n最后，计算一个无量纲残差 $r$，以提供一个归一化的最终变化度量，无论是否达到收敛。它定义为每个变量的绝对变化量（由其各自的特征尺度 $(S_T, S_q, S_u)$ 归一化）中的最大值：\n$$ r = \\max\\left(\\frac{|T_{\\mathrm{new}} - T|}{S_T},\\,\\frac{|q_{\\mathrm{new}} - q|}{S_q},\\,\\frac{|u_{\\mathrm{new}} - u|}{S_u}\\right) $$\n\n实现将包含一个封装了这种迭代逻辑的函数。该函数将对五个指定的测试用例中的每一个进行调用，并将结果（收敛状态、迭代次数、最终残差和最终状态向量）收集并格式化为指定的精确输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the result.\n    \"\"\"\n    \n    # Define common physical and numerical parameters\n    params = {\n        'k_r': 1.0 / (5.0 * 24.0 * 3600.0),\n        'T_eq': 230.0,\n        'chi': 2.0,\n        'k_c': 1.0e4,\n        'k_sed': 1.0e-6,\n        'L_dil': 1.0e6,\n        'k_p': 1.0e-4,\n        'k_d': 1.0e-5,\n        'alpha': 0.3,\n        'eps_T': 1.0e-6,\n        'eps_q': 1.0e-12,\n        'eps_u': 1.0e-6,\n        'S_T': 1.0,\n        'S_q': 1.0e-9,\n        'S_u': 1.0,\n        'N_max': 200,\n    }\n\n    # Define the test cases: (Delta_t, S, T_0, q_0, u_0)\n    test_cases = [\n        # Case A: general happy path\n        (600.0, 5.0e-11, 230.0, 1.0e-7, 10.0),\n        # Case B: boundary, short timestep, no injection\n        (60.0, 0.0, 230.0, 1.0e-8, 5.0),\n        # Case C: strong injection, potentially stiff microphysics\n        (600.0, 5.0e-10, 228.0, 5.0e-8, 2.0),\n        # Case D: high wind causing strong dilution\n        (600.0, 2.0e-10, 232.0, 2.0e-7, 45.0),\n        # Case E: large timestep near stability limit\n        (1800.0, 5.0e-10, 235.0, 1.0e-7, 10.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        Dt, S, T0, q0, u0 = case\n        result = run_coupled_iteration(Dt, S, T0, q0, u0, params)\n        results.append(result)\n\n    # Format the final output string exactly as required\n    formatted_results = []\n    for res in results:\n        # res is a list like [True, 5, 1.23e-07, 230.0, 1e-07, 10.0]\n        # map(str, res) creates an iterator of strings: 'True', '5', '1.23e-07', ...\n        # ','.join(...) creates 'True,5,1.23e-07,...'\n        formatted_results.append(f\"[{','.join(map(str, res))}]\")\n    \n    # final_output is then '[ [True,5,...], [False,200,...] ]'\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\ndef run_coupled_iteration(Delta_t, S, T0, q0, u0, p):\n    \"\"\"\n    Performs the iterative coupled update for a single test case.\n\n    Args:\n        Delta_t (float): Timestep in seconds.\n        S (float): Aerosol source rate in kg/kg/s.\n        T0, q0, u0 (float): Initial state variables.\n        p (dict): Dictionary of common parameters.\n\n    Returns:\n        list: [converged, num_iters, residual, T_final, q_final, u_final]\n    \"\"\"\n    T, q, u = T0, q0, u0\n    converged = False\n    num_iters = 0\n\n    change_T, change_q, change_u = 0.0, 0.0, 0.0\n\n    for i in range(1, p['N_max'] + 1):\n        num_iters = i\n        T_prev, q_prev, u_prev = T, q, u\n\n        # 1. Compute provisional temperature using radiation\n        T_dot = -p['k_r'] * (T_prev - p['T_eq']) - p['chi'] * q_prev\n        T_star = T_prev + Delta_t * T_dot\n\n        # 2. Compute provisional aerosol using microphysics\n        q_dot = S - p['k_c'] * q_prev**2 - p['k_sed'] * q_prev - (abs(u_prev) / p['L_dil']) * q_prev\n        q_star = q_prev + Delta_t * q_dot\n\n        # 3. Compute provisional wind using dynamics forced by the updated temperature\n        u_dot = -p['k_p'] * (T_star - p['T_eq']) - p['k_d'] * u_prev\n        u_star = u_prev + Delta_t * u_dot\n\n        # 4. Under-relax to form the next iterate\n        T = T_prev + p['alpha'] * (T_star - T_prev)\n        q = q_prev + p['alpha'] * (q_star - q_prev)\n        q = max(0.0, q)  # Enforce non-negativity\n        u = u_prev + p['alpha'] * (u_star - u_prev)\n        \n        # Calculate absolute changes for convergence check\n        change_T = abs(T - T_prev)\n        change_q = abs(q - q_prev)\n        change_u = abs(u - u_prev)\n\n        if change_T = p['eps_T'] and change_q = p['eps_q'] and change_u = p['eps_u']:\n            converged = True\n            break\n    \n    # Compute dimensionless residual r based on the last iteration's changes\n    r = max(change_T / p['S_T'], change_q / p['S_q'], change_u / p['S_u'])\n\n    return [converged, num_iters, r, T, q, u]\n\n# Execute the main function\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}