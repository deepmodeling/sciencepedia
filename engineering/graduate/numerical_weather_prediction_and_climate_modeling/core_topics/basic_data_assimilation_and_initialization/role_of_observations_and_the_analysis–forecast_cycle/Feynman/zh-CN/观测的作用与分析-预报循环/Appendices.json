{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导你完成一个简化的标量卡尔曼滤波器分析-预报循环。通过逐步计算，你将亲身体验信息是如何从观测中融入模式状态，并量化不确定性（方差）的减少。此实践旨在巩固对数据同化基本机制的理解，特别是揭示模式误差如何在预报阶段重新引入不确定性，并导致后续观测信息收益递减的现象 ()。",
            "id": "4083286",
            "problem": "在数值天气预报 (NWP) 中，分析-预报循环将观测与短期预报相融合，以形成对大气状态的最佳估计。考虑一个标量状态变量 $x_k$，它表示在离散分析时间 $t_k$ 的天气尺度近地面温度异常（单位：开尔文）。该标量动力学和测量模型如下：\n- 模型（带模型误差的持续性模型）：$x_{k+1} = x_k + \\eta_k$，其中 $\\eta_k \\sim \\mathcal{N}(0,\\sigma_m^2)$ 是独立的高斯模型误差。\n- 观测（带误差的直接测量）：$y_k = x_k + \\epsilon_k$，其中 $\\epsilon_k \\sim \\mathcal{N}(0,\\sigma_o^2)$ 是独立的高斯观测误差。\n\n假设在时间 $t_1$ 有一个背景场（短期预报），其均值为 $\\mu_1^b$，方差为 $P_1^b$；并且在 $t_1$ 和 $t_2$ 有两个连续的观测值 $y_1$ 和 $y_2$。具体数值如下：\n- $\\mu_1^b = 0.0$ K, $P_1^b = 4.0$ K²,\n- $\\sigma_o^2 = 1.0$ K²,\n- $\\sigma_m^2 = 0.25$ K²,\n- $y_1 = 0.8$ K, $y_2 = 0.3$ K.\n\n使用贝叶斯定理和高斯分布的性质，完成以下任务：\n1) 从背景场 $(\\mu_1^b,P_1^b)$ 和观测值 $y_1$ 出发，推导在 $t_1$ 时刻的标量后验（分析）均值 $\\mu_1^a$ 和方差 $P_1^a$。\n2) 使用线性模型将分析场 $(\\mu_1^a,P_1^a)$ 传播到 $t_2$ 时刻，得到该时刻的背景场 $(\\mu_2^b,P_2^b)$，然后使用观测值 $y_2$ 推导在 $t_2$ 时刻的标量后验（分析）均值 $\\mu_2^a$ 和方差 $P_2^a$。\n3) 定义方差减小量 $\\Delta_1 = P_1^b - P_1^a$ 和 $\\Delta_2 = P_2^b - P_2^a$。计算比率 $\\rho = \\Delta_2 / \\Delta_1$，以量化在存在模型误差的情况下，第二次观测的递减回报。\n\n答案规格：\n- 你最终报告的答案必须是纯小数形式的单个数字 $\\rho$。\n- 将你的答案四舍五入到四位有效数字。\n- 最终报告的数字不应包含任何单位（该比率为无量纲）。",
            "solution": "首先对用户提供的问题进行科学合理性、一致性和完整性验证。\n\n### 步骤1：提取已知条件\n- 标量状态变量：$x_k$ 在时间 $t_k$。\n- 状态动力学模型：$x_{k+1} = x_k + \\eta_k$，其中 $\\eta_k$ 是独立的高斯模型误差，$\\eta_k \\sim \\mathcal{N}(0, \\sigma_m^2)$。\n- 观测模型：$y_k = x_k + \\epsilon_k$，其中 $\\epsilon_k$ 是独立的高斯观测误差，$\\epsilon_k \\sim \\mathcal{N}(0, \\sigma_o^2)$。\n- 在 $t_1$ 的背景场状态：均值 $\\mu_1^b = 0.0$ K，方差 $P_1^b = 4.0$ K²。\n- 观测误差方差：$\\sigma_o^2 = 1.0$ K²。\n- 模型误差方差：$\\sigma_m^2 = 0.25$ K²。\n- 观测值：在 $t_1$ 时为 $y_1 = 0.8$ K，在 $t_2$ 时为 $y_2 = 0.3$ K。\n- 任务1：推导在 $t_1$ 时的分析均值 $\\mu_1^a$ 和方差 $P_1^a$。\n- 任务2：传播 $(\\mu_1^a, P_1^a)$ 以找到在 $t_2$ 时的背景场 $(\\mu_2^b, P_2^b)$，然后推导在 $t_2$ 时的分析场 $(\\mu_2^a, P_2^a)$。\n- 任务3：计算方差减小量 $\\Delta_1 = P_1^b - P_1^a$ 和 $\\Delta_2 = P_2^b - P_2^a$，以及它们的比率 $\\rho = \\Delta_2 / \\Delta_1$。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题描述了一个一维离散时间卡尔曼滤波器。这是数据同化、统计信号处理和控制理论中的一个基本标准算法。动力学模型（随机游走）和观测模型（带加性高斯噪声的直接测量）是教学示例中使用的规范且科学合理的简化。\n- **适定性**：所有必要的数值和模型方程都已提供，可以唯一地确定所要求的量。该问题被构建为一个标准的分析-预报循环。\n- **客观性**：该问题用精确的数学语言表述，没有任何主观或模棱两可的术语。\n- **结论**：该问题是有效的。它是在数值天气预报和数据同化领域中一个适定的、有科学依据的问题。\n\n### 步骤3：推导\n求解过程通过应用标量情况下的卡尔曼滤波器标准方程来进行。该过程涉及两个分析（更新）和预报（预测）的循环。\n\n**1) 在时间 $t_1$ 的分析**\n\n分析状态（后验）是通过将背景场状态（先验）与观测相结合得到的。背景场为 $x_1 \\sim \\mathcal{N}(\\mu_1^b, P_1^b)$，观测模型给出的似然为 $p(y_1|x_1) \\sim \\mathcal{N}(y_1; x_1, \\sigma_o^2)$。由于先验和似然都是高斯分布，后验也是一个高斯分布，$x_1|y_1 \\sim \\mathcal{N}(\\mu_1^a, P_1^a)$，其方差 $P_1^a$ 和均值 $\\mu_1^a$ 由以下公式给出：\n$$P_1^a = \\left( \\frac{1}{P_1^b} + \\frac{1}{\\sigma_o^2} \\right)^{-1} = \\frac{P_1^b \\sigma_o^2}{P_1^b + \\sigma_o^2}$$\n$$\\mu_1^a = P_1^a \\left( \\frac{\\mu_1^b}{P_1^b} + \\frac{y_1}{\\sigma_o^2} \\right)$$\n\n代入给定值：\n$P_1^b = 4.0$, $\\sigma_o^2 = 1.0$, $\\mu_1^b = 0.0$, $y_1 = 0.8$.\n\n在 $t_1$ 时的分析方差为：\n$$P_1^a = \\frac{4.0 \\times 1.0}{4.0 + 1.0} = \\frac{4.0}{5.0} = 0.8$$\n在 $t_1$ 时的分析均值为：\n$$\\mu_1^a = 0.8 \\left( \\frac{0.0}{4.0} + \\frac{0.8}{1.0} \\right) = 0.8 \\times 0.8 = 0.64$$\n因此，在 $t_1$ 时的分析状态为 $(\\mu_1^a, P_1^a) = (0.64, 0.8)$。\n\n**2) 向 $t_2$ 预报及在 $t_2$ 的分析**\n\n首先，我们使用模型动力学 $x_{k+1} = x_k + \\eta_k$ 将分析状态从 $t_1$ 传播到 $t_2$。这得出了下一次在 $t_2$ 分析的背景场状态。\n均值按如下方式传播：\n$$\\mu_2^b = E[x_1 + \\eta_1] = E[x_1] + E[\\eta_1] = \\mu_1^a + 0 = 0.64$$\n方差按如下方式传播（因为 $x_1$ 和 $\\eta_1$ 是独立的）：\n$$P_2^b = \\text{Var}(x_1 + \\eta_1) = \\text{Var}(x_1) + \\text{Var}(\\eta_1) = P_1^a + \\sigma_m^2$$\n代入数值 $P_1^a = 0.8$ 和 $\\sigma_m^2 = 0.25$：\n$$P_2^b = 0.8 + 0.25 = 1.05$$\n因此，在 $t_2$ 时的背景场状态为 $(\\mu_2^b, P_2^b) = (0.64, 1.05)$。\n\n接下来，我们使用新的背景场 $(\\mu_2^b, P_2^b)$ 和新的观测值 $y_2 = 0.3$ 在 $t_2$ 进行分析。这些方程在形式上与第一步分析中的方程相同。\n在 $t_2$ 时的分析方差为：\n$$P_2^a = \\frac{P_2^b \\sigma_o^2}{P_2^b + \\sigma_o^2} = \\frac{1.05 \\times 1.0}{1.05 + 1.0} = \\frac{1.05}{2.05}$$\n在 $t_2$ 时的分析均值为：\n$$\\mu_2^a = P_2^a \\left( \\frac{\\mu_2^b}{P_2^b} + \\frac{y_2}{\\sigma_o^2} \\right) = \\frac{1.05}{2.05} \\left( \\frac{0.64}{1.05} + \\frac{0.3}{1.0} \\right) = \\frac{1.05}{2.05} \\left( \\frac{0.64 + 0.3 \\times 1.05}{1.05} \\right) = \\frac{0.64 + 0.315}{2.05} = \\frac{0.955}{2.05}$$\n问题不需要 $\\mu_2^a$ 和 $P_2^a$ 的数值作为最终答案，因此我们暂时可以将它们保留为精确分数。\n\n**3) 方差减小量和比率**\n\n每一步的方差减小量是背景场（预报）方差和分析方差之间的差值。\n对于 $t_1$：\n$$\\Delta_1 = P_1^b - P_1^a = 4.0 - 0.8 = 3.2$$\n对于 $t_2$：\n$$\\Delta_2 = P_2^b - P_2^a = 1.05 - \\frac{1.05}{2.05} = 1.05 \\left( 1 - \\frac{1}{2.05} \\right) = 1.05 \\left( \\frac{2.05 - 1.0}{2.05} \\right) = 1.05 \\left( \\frac{1.05}{2.05} \\right) = \\frac{1.1025}{2.05}$$\n现在，我们计算比率 $\\rho = \\Delta_2 / \\Delta_1$：\n$$\\rho = \\frac{\\Delta_2}{\\Delta_1} = \\frac{1.1025 / 2.05}{3.2} = \\frac{1.1025}{2.05 \\times 3.2} = \\frac{1.1025}{6.56}$$\n进行最后的除法运算：\n$$\\rho \\approx 0.168064024...$$\n按照要求，四舍五入到四位有效数字：\n$$\\rho \\approx 0.1681$$\n该结果量化了当模型误差在两次观测之间增大了不确定性时，连续观测所带来的递减信息增益。第二次观测减少的方差仅约为第一次的 $16.8\\%$。",
            "answer": "$$\\boxed{0.1681}$$"
        },
        {
            "introduction": "在实践中，集合卡尔曼滤波器（EnKF）由于有限的集合成员数量，往往会低估预报误差方差，导致“集合离散度不足”问题。本练习将通过编码实践，探讨两种关键的方差订正技术：乘性膨胀和加性膨胀。你将推导并实现这些方案，直观地看到它们如何调整预报误差协方差，从而对分析结果产生至关重要的影响 ()。",
            "id": "4083294",
            "problem": "给定一个标量线性高斯数据同化设置，它代表了数值天气预报中分析-预报循环的一个步骤。真实状态 $x$被建模为一个标量随机变量，其预报（先验）分布为$x \\sim \\mathcal{N}(m_f, P_f)$。观测值 $y$通过一个带加性噪声的线性观测算子与 $x$相关联，$y = H x + \\varepsilon$，其中$H = 1$且$\\varepsilon \\sim \\mathcal{N}(0, R)$。在集合卡尔曼滤波器（EnKF）中，使用集合膨胀来校正预报集合的离散度不足问题。考虑两种膨胀方案：\n\n- 乘性膨胀：将每个集合成员相对于预报均值的偏差乘以$\\sqrt{\\alpha}$，其中$\\alpha \\ge 0$。\n- 加性膨胀：向每个集合成员添加方差为$\\beta \\ge 0$的独立高斯噪声，其中加性噪声独立于$x$和$\\varepsilon$。\n\n任务：\n\n1. 从标准贝叶斯线性更新和线性高斯系统的卡尔曼滤波器方程出发，推导此设置下的标量分析方差 $P_a$ 作为预报方差 $P_f$ 和观测误差方差 $R$ 的函数。\n2. 展示这两种膨胀方案如何改变同化前的有效预报方差，并推导膨胀后相应的分析方差。令膨胀后的预报方差为 $P_f'$，其中乘性膨胀得到 $P_f' = \\alpha P_f$，加性膨胀得到 $P_f' = P_f + \\beta$。如果两种膨胀方案依次应用（先乘性后加性），则 $P_f' = \\alpha P_f + \\beta$。推导 $P_a'$ 关于 $P_f'$ 和 $R$ 的表达式。\n3. 对于下面组中的每个测试用例，计算：\n   - 膨胀后的预报方差 $P_f'$。\n   - 使用膨胀后的预报方差同化一个方差为 $R$ 的观测后的分析方差 $P_a'$。\n4. 在本问题中，将集合离散度定义为集合方差。对于标量情况，在给定的膨胀假设下，分析前的期望集合离散度等于 $P_f'$。为每个测试用例报告集合离散度 $P_f'$ 和分析方差 $P_a'$。\n\n在你的推导中使用的基本假设：\n\n- 预报分布是高斯的，$x \\sim \\mathcal{N}(m_f, P_f)$，观测模型为 $y = H x + \\varepsilon$，其中 $H = 1$ 且 $\\varepsilon \\sim \\mathcal{N}(0, R)$。\n- 在线性高斯假设下，分析（后验）分布是高斯的，其均值 $m_a$ 和方差 $P_a$ 从卡尔曼滤波器获得。\n- 膨胀操作在分析步骤之前修改预报集合，并且与观测噪声在统计上是独立的。\n\n实现一个程序，对于每个测试用例，输出如上定义的双元素列表 $[P_f', P_a']$。\n\n测试组：\n\n- 用例 1：$P_f = 1.0$, $R = 0.25$, $\\alpha = 1.2$, $\\beta = 0.0$。\n- 用例 2：$P_f = 1.0$, $R = 0.25$, $\\alpha = 1.0$, $\\beta = 0.5$。\n- 用例 3：$P_f = 0.5$, $R = 1.0$, $\\alpha = 1.1$, $\\beta = 0.2$。\n- 用例 4：$P_f = 2.0$, $R = 0.000001$, $\\alpha = 1.0$, $\\beta = 0.0$。\n- 用例 5：$P_f = 0.000001$, $R = 0.5$, $\\alpha = 2.0$, $\\beta = 0.0$。\n- 用例 6：$P_f = 1.5$, $R = 0.3$, $\\alpha = 0.0$, $\\beta = 0.0$。\n- 用例 7：$P_f = 1.5$, $R = 0.3$, $\\alpha = 1.0$, $\\beta = 0.0$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个元素对应一个测试用例，并且本身是一个没有空格的双元素列表 $[P_f', P_a']$。例如：$[[P_{f,1}',P_{a,1}'],[P_{f,2}',P_{a,2}'],\\dots]$。所有计算值必须在输出中表示为十进制浮点数。",
            "solution": "问题陈述已经过分析，并被确定为有效。它在科学上基于贝叶斯推断和卡尔曼滤波器的原理，这些是数值天气预报中数据同化的基础。该问题是适定的、客观的和自包含的，为得到唯一且有意义的解提供了所有必要的参数和定义。\n\n在此，我们推导所需的公式并计算给定测试用例的结果。\n\n### 1. 标量分析方差（$P_a$）的推导\n\n给定一个标量系统。关于状态 $x$ 的先验信念由预报分布给出，这是一个均值为 $m_f$、方差为 $P_f$ 的高斯分布，记为 $x \\sim \\mathcal{N}(m_f, P_f)$。其概率密度函数为：\n$$\np(x) \\propto \\exp\\left(-\\frac{1}{2} \\frac{(x - m_f)^2}{P_f}\\right)\n$$\n我们进行了一次观测 $y$，它通过线性观测模型 $y = Hx + \\varepsilon$与状态 $x$ 相关。给定 $H=1$ 且观测误差 $\\varepsilon$ 服从高斯分布 $\\varepsilon \\sim \\mathcal{N}(0, R)$。这定义了似然函数，即给定状态 $x$ 时观测到 $y$ 的概率：\n$$\np(y|x) = \\mathcal{N}(y; Hx, R) = \\mathcal{N}(y; x, R) \\propto \\exp\\left(-\\frac{1}{2} \\frac{(y - x)^2}{R}\\right)\n$$\n根据贝叶斯定理，给定观测 $y$ 的状态 $x$ 的后验分布，即分析分布 $p(x|y)$，与似然函数和先验分布的乘积成正比：\n$$\np(x|y) \\propto p(y|x) p(x)\n$$\n由于两个高斯分布的乘积是另一个高斯分布，因此分析分布也是高斯的，$x|y \\sim \\mathcal{N}(m_a, P_a)$。其概率密度正比于：\n$$\n\\exp\\left(-\\frac{1}{2} \\frac{(x - m_f)^2}{P_f}\\right) \\exp\\left(-\\frac{1}{2} \\frac{(y - x)^2}{R}\\right) = \\exp\\left(-\\frac{1}{2} \\left[ \\frac{(x - m_f)^2}{P_f} + \\frac{(x - y)^2}{R} \\right]\\right)\n$$\n为了求得分析方差 $P_a$，我们可以考察指数中关于 $x$ 的二次项。高斯分布 $\\mathcal{N}(m_a, P_a)$ 的指数中包含一项 $-\\frac{1}{2}\\frac{x^2}{P_a}$。展开上述表达式中的二次项得到：\n$$\n-\\frac{1}{2} \\left( \\frac{x^2}{P_f} + \\frac{x^2}{R} + \\dots \\right) = -\\frac{1}{2} x^2 \\left( \\frac{1}{P_f} + \\frac{1}{R} \\right) + \\dots\n$$\n通过比较 $x^2$ 项的系数，我们发现分析方差的倒数是预报方差和观测误差方差的倒数之和：\n$$\n\\frac{1}{P_a} = \\frac{1}{P_f} + \\frac{1}{R}\n$$\n这个基本关系表明，在线性高斯系统中，精度（方差的倒数）是相加的。求解分析方差 $P_a$ 可得：\n$$\nP_a = \\left( \\frac{R + P_f}{P_f R} \\right)^{-1} = \\frac{P_f R}{P_f + R}\n$$\n这是标量卡尔曼滤波器更新中分析方差的标准公式。\n\n### 2. 膨胀的影响及膨胀后分析方差（$P_a'$）的推导\n\n集合膨胀方案旨在同化步骤之前修改预报集合的统计量。设原始预报集合成员为 $\\{x_f^{(i)}\\}$，其样本方差近似为 $P_f$。\n\n**乘性膨胀：** 每个成员与均值的偏差乘以 $\\sqrt{\\alpha}$ 进行缩放。一个成员 $x_f^{(i)}$ 变换为 $x_f'^{(i)}$：\n$$\nx_f'^{(i)} = m_f + \\sqrt{\\alpha}(x_f^{(i)} - m_f)\n$$\n这个新集合的方差 $P_f'$ 为：\n$$\nP_f' = \\text{Var}(x_f'^{(i)}) = \\text{Var}(m_f + \\sqrt{\\alpha}(x_f^{(i)} - m_f)) = (\\sqrt{\\alpha})^2 \\text{Var}(x_f^{(i)}) = \\alpha P_f\n$$\n这证实了问题中对乘性膨胀的定义。\n\n**加性膨胀：** 向每个集合成员添加独立的随机噪声 $\\delta^{(i)} \\sim \\mathcal{N}(0, \\beta)$：\n$$\nx_f'^{(i)} = x_f^{(i)} + \\delta^{(i)}\n$$\n由于添加的噪声独立于预报状态，方差相加。新集合的方差 $P_f'$ 为：\n$$\nP_f' = \\text{Var}(x_f'^{(i)}) = \\text{Var}(x_f^{(i)} + \\delta^{(i)}) = \\text{Var}(x_f^{(i)}) + \\text{Var}(\\delta^{(i)}) = P_f + \\beta\n$$\n这证实了问题中对加性膨胀的定义。\n\n**顺序膨胀：** 当乘性膨胀（参数为 $\\alpha$）之后进行加性膨胀（参数为 $\\beta$）时，变换是复合的。第一步后的方差是 $\\alpha P_f$。第二步将 $\\beta$ 加到该方差上。因此，最终膨胀后的预报方差为：\n$$\nP_f' = \\alpha P_f + \\beta\n$$\n分析步骤接着使用这个膨胀后的预报方差 $P_f'$ 作为先验方差。膨胀后的分析方差 $P_a'$ 是通过将上一节推导出的公式中的 $P_f$ 替换为 $P_f'$ 得到的：\n$$\n\\frac{1}{P_a'} = \\frac{1}{P_f'} + \\frac{1}{R}\n$$\n或等价地，\n$$\nP_a' = \\frac{P_f' R}{P_f' + R}\n$$\n这是将用于所有测试用例的通用公式。\n\n### 3. 测试用例的计算\n\n我们将推导出的公式应用于每个测试用例。\n- 膨胀后的预报方差（集合离散度）：$P_f' = \\alpha P_f + \\beta$\n- 膨胀后的分析方差：$P_a' = \\frac{P_f' R}{P_f' + R}$\n\n**用例 1：** $P_f = 1.0$, $R = 0.25$, $\\alpha = 1.2$, $\\beta = 0.0$.\n$P_f' = 1.2 \\times 1.0 + 0.0 = 1.2$\n$P_a' = \\frac{1.2 \\times 0.25}{1.2 + 0.25} = \\frac{0.3}{1.45} \\approx 0.20689655$\n\n**用例 2：** $P_f = 1.0$, $R = 0.25$, $\\alpha = 1.0$, $\\beta = 0.5$.\n$P_f' = 1.0 \\times 1.0 + 0.5 = 1.5$\n$P_a' = \\frac{1.5 \\times 0.25}{1.5 + 0.25} = \\frac{0.375}{1.75} \\approx 0.21428571$\n\n**用例 3：** $P_f = 0.5$, $R = 1.0$, $\\alpha = 1.1$, $\\beta = 0.2$.\n$P_f' = 1.1 \\times 0.5 + 0.2 = 0.55 + 0.2 = 0.75$\n$P_a' = \\frac{0.75 \\times 1.0}{0.75 + 1.0} = \\frac{0.75}{1.75} \\approx 0.42857143$\n\n**用例 4：** $P_f = 2.0$, $R = 0.000001$, $\\alpha = 1.0$, $\\beta = 0.0$.\n$P_f' = 1.0 \\times 2.0 + 0.0 = 2.0$\n$P_a' = \\frac{2.0 \\times 10^{-6}}{2.0 + 10^{-6}} = \\frac{2 \\times 10^{-6}}{2.000001} \\approx 0.9999995 \\times 10^{-6}$\n\n**用例 5：** $P_f = 0.000001$, $R = 0.5$, $\\alpha = 2.0$, $\\beta = 0.0$.\n$P_f' = 2.0 \\times 10^{-6} + 0.0 = 2 \\times 10^{-6}$\n$P_a' = \\frac{2 \\times 10^{-6} \\times 0.5}{2 \\times 10^{-6} + 0.5} = \\frac{10^{-6}}{0.500002} \\approx 1.999992 \\times 10^{-6}$\n\n**用例 6：** $P_f = 1.5$, $R = 0.3$, $\\alpha = 0.0$, $\\beta = 0.0$.\n$P_f' = 0.0 \\times 1.5 + 0.0 = 0.0$\n$P_a' = \\frac{0.0 \\times 0.3}{0.0 + 0.3} = \\frac{0.0}{0.3} = 0.0$\n\n**用例 7：** $P_f = 1.5$, $R = 0.3$, $\\alpha = 1.0$, $\\beta = 0.0$.\n$P_f' = 1.0 \\times 1.5 + 0.0 = 1.5$\n$P_a' = \\frac{1.5 \\times 0.3}{1.5 + 0.3} = \\frac{0.45}{1.8} = 0.25$\n\n这些计算将在提供的Python程序中实现。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes inflated forecast and analysis variances for a series of test cases\n    in a scalar linear Gaussian data assimilation setting.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (Pf, R, alpha, beta)\n    test_cases = [\n        (1.0, 0.25, 1.2, 0.0),       # Case 1\n        (1.0, 0.25, 1.0, 0.5),       # Case 2\n        (0.5, 1.0, 1.1, 0.2),       # Case 3\n        (2.0, 0.000001, 1.0, 0.0),   # Case 4\n        (0.000001, 0.5, 2.0, 0.0),   # Case 5\n        (1.5, 0.3, 0.0, 0.0),       # Case 6\n        (1.5, 0.3, 1.0, 0.0),       # Case 7\n    ]\n\n    results = []\n    for case in test_cases:\n        Pf, R, alpha, beta = case\n\n        # Task 3: Compute the inflated forecast variance (ensemble spread), P_f'.\n        # The formula for sequential inflation (multiplicative then additive) is:\n        # P_f' = alpha * P_f + beta\n        Pf_prime = alpha * Pf + beta\n\n        # Task 3: Compute the analysis variance, P_a', using the inflated forecast variance.\n        # The formula for the analysis variance is:\n        # P_a' = (P_f' * R) / (P_f' + R)\n        # This formula can also be expressed as 1/P_a' = 1/P_f' + 1/R.\n        # We must handle the case where the denominator might be zero.\n        # Given P_f >= 0, R > 0, alpha >= 0, beta >= 0, the denominator\n        # P_f' + R = (alpha * P_f + beta) + R can only be zero if all terms are zero.\n        # In Case 6, Pf_prime is 0.0, but R is 0.3, so the denominator is 0.3.\n        denominator = Pf_prime + R\n        if denominator == 0.0:\n            # This case happens if P_f'=0 and R=0, implying perfect prior and perfect observation.\n            # The posterior would also be perfect, so Pa_prime is 0.\n            Pa_prime = 0.0\n        else:\n            Pa_prime = (Pf_prime * R) / denominator\n        \n        # Task 4: Report the results as a two-element list [P_f', P_a'].\n        results.append([Pf_prime, Pa_prime])\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists is '[[el1, el2], [el3, el4]]'.\n    # Removing spaces gives the required format '[[el1,el2],[el3,el4]]'.\n    print(str(results).replace(' ', ''))\n\nsolve()\n```"
        },
        {
            "introduction": "评估观测资料对预报的实际影响是数值天气预报中的一个核心问题。本练习介绍了一种强大的诊断工具——基于伴随方法的观测敏感性分析（FSO）。通过推导和计算预报指标对观测的梯度，你将学习如何量化每一次观测对最终预报技巧的贡献，这对于优化观测网络和理解预报误差的来源至关重要 ()。",
            "id": "4083300",
            "problem": "考虑数值天气预报（NWP）中一个简化的线性分析-预报循环，其中大气状态由向量 $x \\in \\mathbb{R}^n$ 表示，瞬时观测由 $y \\in \\mathbb{R}^m$ 表示。背景（或初猜）状态为 $x_b \\in \\mathbb{R}^n$，预报模型通过线性算子 $M \\in \\mathbb{R}^{n \\times n}$ 将分析 $x_a \\in \\mathbb{R}^n$ 传播到预报时刻，观测算子为 $H \\in \\mathbb{R}^{m \\times n}$。背景误差协方差为 $B \\in \\mathbb{R}^{n \\times n}$（对称正定），观测误差协方差为 $R \\in \\mathbb{R}^{m \\times m}$（对称正定）。假设一个三维变分（3D-Var）分析，其中分析 $x_a$ 最小化一个二次代价函数，该函数根据各自的协方差惩罚与背景和观测的偏差。检验时刻的预报 $x_f$ 计算为 $x_f = M x_a$。设标量预报度量为\n$$\nJ_f(x_f) = \\tfrac{1}{2} (x_f - x_t)^\\mathrm{T} W (x_f - x_t),\n$$\n其中 $x_t \\in \\mathbb{R}^n$ 是一个目标（例如，真值或检验分析），$W \\in \\mathbb{R}^{n \\times n}$ 是一个对称半正定权重矩阵。将所有变量视为仅由其索引确定维度，无需物理单位。\n\n任务：从线性高斯估计的原理和应用于分析-预报映射的链式法则出发，推导 $J_f$ 相对于观测 $y$ 的伴随梯度，并将其表示为 $B$、$R$、$H$、$M$、$x_b$、$y$、$x_t$ 和 $W$ 的函数。然后实现一个程序，对于以下测试用例集，计算梯度向量 $\\nabla_y J_f \\in \\mathbb{R}^m$ 并以指定格式在单行上输出所有结果。\n\n使用以下测试集。在所有情况下，$n = 3$ 且 $m = 2$。每个矩阵和向量都已明确给出。\n\n测试用例1（一般信息性观测，非平凡动力学和权重）：\n$$\nB = \\begin{bmatrix}\n1.0  0.3  0.0 \\\\\n0.3  1.5  0.2 \\\\\n0.0  0.2  0.5\n\\end{bmatrix},\\quad\nR = \\begin{bmatrix}\n0.2  0.0 \\\\\n0.0  0.1\n\\end{bmatrix},\\quad\nH = \\begin{bmatrix}\n1.0  0.0  0.0 \\\\\n0.0  1.0  0.0\n\\end{bmatrix},\n$$\n$$\nM = \\begin{bmatrix}\n1.0  0.1  0.0 \\\\\n0.0  1.0  0.2 \\\\\n0.0  0.0  0.9\n\\end{bmatrix},\\quad\nx_b = \\begin{bmatrix} 0.5 \\\\ -0.3 \\\\ 0.1 \\end{bmatrix},\\quad\ny = \\begin{bmatrix} 0.6 \\\\ -0.2 \\end{bmatrix},\\quad\nx_t = \\begin{bmatrix} 0.7 \\\\ -0.25 \\\\ 0.08 \\end{bmatrix},\\quad\nW = \\begin{bmatrix}\n1.0  0.0  0.0 \\\\\n0.0  2.0  0.0 \\\\\n0.0  0.0  0.5\n\\end{bmatrix}.\n$$\n\n测试用例2（近乎无信息的观测；大的观测误差）：\n$$\nB = \\begin{bmatrix}\n1.0  0.3  0.0 \\\\\n0.3  1.5  0.2 \\\\\n0.0  0.2  0.5\n\\end{bmatrix},\\quad\nR = \\begin{bmatrix}\n100.0  0.0 \\\\\n0.0  100.0\n\\end{bmatrix},\\quad\nH = \\begin{bmatrix}\n1.0  0.0  0.0 \\\\\n0.0  1.0  0.0\n\\end{bmatrix},\n$$\n$$\nM = \\begin{bmatrix}\n1.0  0.1  0.0 \\\\\n0.0  1.0  0.2 \\\\\n0.0  0.0  0.9\n\\end{bmatrix},\\quad\nx_b = \\begin{bmatrix} 0.5 \\\\ -0.3 \\\\ 0.1 \\end{bmatrix},\\quad\ny = \\begin{bmatrix} 0.6 \\\\ -0.2 \\end{bmatrix},\\quad\nx_t = \\begin{bmatrix} 0.7 \\\\ -0.25 \\\\ 0.08 \\end{bmatrix},\\quad\nW = \\begin{bmatrix}\n1.0  0.0  0.0 \\\\\n0.0  2.0  0.0 \\\\\n0.0  0.0  0.5\n\\end{bmatrix}.\n$$\n\n测试用例3（近乎完美的观测；极小的观测误差）：\n$$\nB = \\begin{bmatrix}\n1.0  0.3  0.0 \\\\\n0.3  1.5  0.2 \\\\\n0.0  0.2  0.5\n\\end{bmatrix},\\quad\nR = \\begin{bmatrix}\n10^{-6}  0.0 \\\\\n0.0  10^{-6}\n\\end{bmatrix},\\quad\nH = \\begin{bmatrix}\n1.0  0.0  0.0 \\\\\n0.0  1.0  0.0\n\\end{bmatrix},\n$$\n$$\nM = \\begin{bmatrix}\n1.0  0.1  0.0 \\\\\n0.0  1.0  0.2 \\\\\n0.0  0.0  0.9\n\\end{bmatrix},\\quad\nx_b = \\begin{bmatrix} 0.5 \\\\ -0.3 \\\\ 0.1 \\end{bmatrix},\\quad\ny = \\begin{bmatrix} 0.6 \\\\ -0.2 \\end{bmatrix},\\quad\nx_t = \\begin{bmatrix} 0.7 \\\\ -0.25 \\\\ 0.08 \\end{bmatrix},\\quad\nW = \\begin{bmatrix}\n1.0  0.0  0.0 \\\\\n0.0  2.0  0.0 \\\\\n0.0  0.0  0.5\n\\end{bmatrix}.\n$$\n\n测试用例4（单位动力学和权重；对不同状态分量的观测）：\n$$\nB = \\begin{bmatrix}\n1.0  0.0  0.0 \\\\\n0.0  1.0  0.0 \\\\\n0.0  0.0  1.0\n\\end{bmatrix},\\quad\nR = \\begin{bmatrix}\n0.5  0.0 \\\\\n0.0  0.5\n\\end{bmatrix},\\quad\nH = \\begin{bmatrix}\n1.0  0.0  0.0 \\\\\n0.0  0.0  1.0\n\\end{bmatrix},\n$$\n$$\nM = \\begin{bmatrix}\n1.0  0.0  0.0 \\\\\n0.0  1.0  0.0 \\\\\n0.0  0.0  1.0\n\\end{bmatrix},\\quad\nx_b = \\begin{bmatrix} 0.0 \\\\ 0.2 \\\\ -0.1 \\end{bmatrix},\\quad\ny = \\begin{bmatrix} 0.05 \\\\ -0.12 \\end{bmatrix},\\quad\nx_t = \\begin{bmatrix} 0.1 \\\\ 0.15 \\\\ -0.08 \\end{bmatrix},\\quad\nW = \\begin{bmatrix}\n1.0  0.0  0.0 \\\\\n0.0  1.0  0.0 \\\\\n0.0  0.0  1.0\n\\end{bmatrix}.\n$$\n\n测试用例5（零预报度量权重；敏感度应精确为零）：\n$$\nB = \\begin{bmatrix}\n1.0  0.3  0.0 \\\\\n0.3  1.5  0.2 \\\\\n0.0  0.2  0.5\n\\end{bmatrix},\\quad\nR = \\begin{bmatrix}\n0.2  0.0 \\\\\n0.0  0.1\n\\end{bmatrix},\\quad\nH = \\begin{bmatrix}\n1.0  0.0  0.0 \\\\\n0.0  1.0  0.0\n\\end{bmatrix},\n$$\n$$\nM = \\begin{bmatrix}\n1.0  0.1  0.0 \\\\\n0.0  1.0  0.2 \\\\\n0.0  0.0  0.9\n\\end{bmatrix},\\quad\nx_b = \\begin{bmatrix} 0.5 \\\\ -0.3 \\\\ 0.1 \\end{bmatrix},\\quad\ny = \\begin{bmatrix} 0.6 \\\\ -0.2 \\end{bmatrix},\\quad\nx_t = \\begin{bmatrix} 0.7 \\\\ -0.25 \\\\ 0.08 \\end{bmatrix},\\quad\nW = \\begin{bmatrix}\n0.0  0.0  0.0 \\\\\n0.0  0.0  0.0 \\\\\n0.0  0.0  0.0\n\\end{bmatrix}.\n$$\n\n你的程序应为每个测试用例计算梯度向量 $\\nabla_y J_f$，并将其每个分量四舍五入到六位小数。最终输出必须是单行，包含所有测试用例的梯度向量的逗号分隔列表，每个梯度向量格式化为包含两个浮点数的列表，整个序列用方括号括起来。例如，格式必须类似于“[list1,list2,list3,list4,list5]”，其中每个“list$k$”是“[a$k$,b$k$]”。不应打印任何附加文本。",
            "solution": "我们从线性高斯假设下的分析-预报循环开始。分析 $x_a \\in \\mathbb{R}^n$ 是通过最小化三维变分（3D-Var）代价函数得到的\n$$\nJ_a(x) = \\tfrac{1}{2}(x - x_b)^\\mathrm{T} B^{-1} (x - x_b) + \\tfrac{1}{2}(y - H x)^\\mathrm{T} R^{-1} (y - H x),\n$$\n其中 $x_b \\in \\mathbb{R}^n$ 是背景场，$B \\in \\mathbb{R}^{n \\times n}$ 是背景误差协方差，$y \\in \\mathbb{R}^m$ 是观测，$H \\in \\mathbb{R}^{m \\times n}$ 是（线性）观测算子，$R \\in \\mathbb{R}^{m \\times m}$ 是观测误差协方差。一阶最优性条件 $\\nabla_x J_a(x) = 0$ 产生正规方程\n$$\nB^{-1}(x - x_b) - H^\\top R^{-1} (y - H x) = 0,\n$$\n可以重新整理为\n$$\n\\left(B^{-1} + H^\\top R^{-1} H\\right)x = B^{-1} x_b + H^\\top R^{-1} y.\n$$\n对 $x$ 求解可得分析 $x_a$。对于线性高斯系统，可以等价地使用由下式定义的 Kalman 增益 $K \\in \\mathbb{R}^{n \\times m}$ 来表示解\n$$\nK = B H^\\top \\left(H B H^\\top + R\\right)^{-1},\n$$\n并且分析具有仿射形式\n$$\nx_a = x_b + K\\left(y - H x_b\\right).\n$$\n这可以通过代入增益并验证其满足正规方程得到；矩阵 $S = H B H^\\top + R$ 是对称正定的，确保了逆矩阵的良定义性。\n\n检验时刻的预报 $x_f$ 是通过作用于分析的线性模型 $M \\in \\mathbb{R}^{n \\times n}$ 计算的：\n$$\nx_f = M x_a.\n$$\n我们用一个标量度量来量化预报质量\n$$\nJ_f(x_f) = \\tfrac{1}{2} (x_f - x_t)^\\mathrm{T} W (x_f - x_t),\n$$\n其中 $x_t \\in \\mathbb{R}^n$ 是目标（例如，真值），而 $W \\in \\mathbb{R}^{n \\times n}$ 是对称半正定的。$J_f$ 相对于 $x_f$ 的梯度是\n$$\n\\nabla_{x_f} J_f = W (x_f - x_t),\n$$\n利用了 $W$ 的对称性。为了找到相对于观测 $y$ 的梯度，我们通过分析-预报映射应用链式法则。分析通过 $x_a = x_b + K(y - H x_b)$ 依赖于 $y$，因此 $x_a$ 相对于 $y$ 的雅可比矩阵是\n$$\n\\frac{\\partial x_a}{\\partial y} = K.\n$$\n预报通过 $x_f = M x_a$ 依赖于分析，因此 $x_f$ 相对于 $x_a$ 的雅可比矩阵是\n$$\n\\frac{\\partial x_f}{\\partial x_a} = M.\n$$\n根据通过线性映射的梯度链式法则，$J_f$ 相对于 $y$ 的梯度是复合雅可比矩阵的伴随（转置）作用于 $\\nabla_{x_f} J_f$：\n$$\n\\nabla_y J_f = \\left(\\frac{\\partial x_a}{\\partial y}\\right)^\\top \\left(\\frac{\\partial x_f}{\\partial x_a}\\right)^\\top \\nabla_{x_f} J_f = K^\\top M^\\top W (x_f - x_t).\n$$\n这个表达式是基于伴随的对观测的预报敏感性（FSO）：它将预报空间的梯度映射回观测空间。它在计算上是高效的，因为它涉及转置算子，并避免了在观测空间中进行显式扰动。\n\n每个测试用例的算法步骤：\n1. 计算 Kalman 增益 $K = B H^\\top (H B H^\\top + R)^{-1}$。令 $S = H B H^\\top + R$；由于 $S$ 是对称正定的，$S^{-1}$ 存在且可以稳定计算。\n2. 计算分析 $x_a = x_b + K (y - H x_b)$。\n3. 传播得到预报 $x_f = M x_a$。\n4. 形成预报空间梯度 $\\nabla_{x_f} J_f = W (x_f - x_t)$。\n5. 通过伴随反向传播到观测空间，得到 $\\nabla_y J_f = K^\\top M^\\top \\nabla_{x_f} J_f$。\n6. 将 $\\nabla_y J_f$ 的两个分量四舍五入到六位小数，并将其作为该测试用例的输出进行收集。\n\n对 $\\nabla_y J_f$ 的符号和大小的解释：\n- 如果 $\\nabla_y J_f$ 的第 $i$ 个分量为正，对第 $i$ 个观测的正扰动倾向于增加 $J_f$，在给定的 $W$ 下使预报度量变差；负梯度意味着增加第 $i$ 个观测会减小 $J_f$，改善度量。\n- 每个分量的大小表示敏感性强度：较大的绝对值意味着相应观测的微小变化会在 $J_f$ 中产生较大的变化。\n- 增加观测误差方差（$R$ 中较大的条目）会减小增益 $K$，从而减小敏感性的大小；相反，非常小的 $R$ 会增加敏感性的大小。\n- 如果 $W$ 是零矩阵，那么 $\\nabla_y J_f = 0$，这反映了预报度量不惩罚任何预报偏差。\n\n程序将为五个指定的测试用例实现这些步骤，并按要求生成单行输出。",
            "answer": "```python\nimport numpy as np\n\ndef kalman_gain(B, H, R):\n    # Compute S = H B H^T + R and its inverse\n    S = H @ B @ H.T + R\n    S_inv = np.linalg.inv(S)\n    K = B @ H.T @ S_inv\n    return K\n\ndef compute_gradient(B, R, H, M, xb, y, xt, W):\n    # Kalman gain\n    K = kalman_gain(B, H, R)\n    # Analysis\n    innovation = y - H @ xb\n    xa = xb + K @ innovation\n    # Forecast\n    xf = M @ xa\n    # Forecast-space gradient\n    grad_xf = W @ (xf - xt)\n    # Adjoint to observation space\n    grad_y = K.T @ M.T @ grad_xf\n    return grad_y\n\ndef format_vector(vec):\n    return \"[\" + \",\".join(f\"{v:.6f}\" for v in vec) + \"]\"\n\ndef solve():\n    # Define test cases\n    test_cases = []\n\n    # Test Case 1\n    B1 = np.array([[1.0, 0.3, 0.0],\n                   [0.3, 1.5, 0.2],\n                   [0.0, 0.2, 0.5]])\n    R1 = np.array([[0.2, 0.0],\n                   [0.0, 0.1]])\n    H1 = np.array([[1.0, 0.0, 0.0],\n                   [0.0, 1.0, 0.0]])\n    M1 = np.array([[1.0, 0.1, 0.0],\n                   [0.0, 1.0, 0.2],\n                   [0.0, 0.0, 0.9]])\n    xb1 = np.array([0.5, -0.3, 0.1])\n    y1 = np.array([0.6, -0.2])\n    xt1 = np.array([0.7, -0.25, 0.08])\n    W1 = np.array([[1.0, 0.0, 0.0],\n                   [0.0, 2.0, 0.0],\n                   [0.0, 0.0, 0.5]])\n    test_cases.append((B1, R1, H1, M1, xb1, y1, xt1, W1))\n\n    # Test Case 2 (large observation errors)\n    R2 = np.array([[100.0, 0.0],\n                   [0.0, 100.0]])\n    test_cases.append((B1, R2, H1, M1, xb1, y1, xt1, W1))\n\n    # Test Case 3 (tiny observation errors)\n    R3 = np.array([[1e-6, 0.0],\n                   [0.0, 1e-6]])\n    test_cases.append((B1, R3, H1, M1, xb1, y1, xt1, W1))\n\n    # Test Case 4 (identity dynamics and weights, distinct observed components)\n    B4 = np.eye(3)\n    R4 = np.array([[0.5, 0.0],\n                   [0.0, 0.5]])\n    H4 = np.array([[1.0, 0.0, 0.0],\n                   [0.0, 0.0, 1.0]])\n    M4 = np.eye(3)\n    xb4 = np.array([0.0, 0.2, -0.1])\n    y4 = np.array([0.05, -0.12])\n    xt4 = np.array([0.1, 0.15, -0.08])\n    W4 = np.eye(3)\n    test_cases.append((B4, R4, H4, M4, xb4, y4, xt4, W4))\n\n    # Test Case 5 (zero weights -> zero sensitivity)\n    W5 = np.zeros((3,3))\n    test_cases.append((B1, R1, H1, M1, xb1, y1, xt1, W5))\n\n    results = []\n    for B, R, H, M, xb, y, xt, W in test_cases:\n        grad_y = compute_gradient(B, R, H, M, xb, y, xt, W)\n        results.append(format_vector(grad_y))\n\n    print(\"[\" + \",\".join(results) + \"]\")\n\nsolve()\n```"
        }
    ]
}