{
    "hands_on_practices": [
        {
            "introduction": "这个实践练习将引导你运用正规模态分解这一核心方法来诊断动力不平衡。通过将初始状态投影到模型的本征模上，我们可以将其明确地分离为缓慢演变的平衡部分（如准地转流）和快速传播的不平衡部分（如惯性重力波）。计算不平衡模态中所包含的动能，为我们提供了一个直接量化初始场不平衡程度的指标，这种不平衡正是驱动模式“自转启动”现象的根源。",
            "id": "4064940",
            "problem": "在一个恒定科里奥利参数平面（$f$平面）上的旋转浅水线性模型，为量化数值天气预报和气候模拟中模式初始化和启动控制期间的动力不平衡提供了一个基本基础。考虑围绕静止状态线性化的旋转浅水方程，其平均流体深度为 $H$，表面高度扰动为 $\\eta$：\n$$\n\\frac{\\partial u}{\\partial t} - f v = - g \\frac{\\partial \\eta}{\\partial x}, \\quad\n\\frac{\\partial v}{\\partial t} + f u = - g \\frac{\\partial \\eta}{\\partial y}, \\quad\n\\frac{\\partial \\eta}{\\partial t} + H \\left( \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y} \\right) = 0,\n$$\n其中 $u$ 和 $v$ 是水平速度分量，$g$ 是重力加速度，$f$ 是科里奥利参数。对于具有波矢 $\\mathbf{k} = (k_x, k_y)$ 的单个空间傅里叶分量，将状态写为复傅里叶振幅 $\\hat{u}$、$\\hat{v}$ 和 $\\hat{\\eta}$，使得空间导数的作用相当于乘以 $i k_x$ 和 $i k_y$。该演化可以写成一个线性系统 $\\frac{d}{dt} \\mathbf{s} = A \\mathbf{s}$，其中 $\\mathbf{s} = [\\hat{u}, \\hat{v}, \\hat{\\eta}]^\\top$ 且\n$$\nA =\n\\begin{bmatrix}\n0  & f  & - g i k_x \\\\\n- f  & 0  & - g i k_y \\\\\n- H i k_x  & - H i k_y  & 0\n\\end{bmatrix}.\n$$\n简正模分解可将该系统对角化。平衡子空间对应于零频率本征模，而不平衡快子空间对应于惯性重力本征模。位于快子空间中的动能分数是使用单个傅里叶分量的单位质量空间平均动能来定义的，\n$$\nE_k = \\frac{1}{4}\\left( |\\hat{u}|^2 + |\\hat{v}|^2 \\right),\n$$\n并且快模贡献是通过将初始状态投影到快本征子空间上并保留其速度分量来计算的。\n\n任务：实现一个程序，对于每个指定的测试用例，构造矩阵 $A$，计算其右本征分解，形成到快子空间（非零频率本征空间）的投影算子，将此投影应用于初始傅里叶状态 $\\mathbf{s}_0$，并返回定义为快模中的动能分数\n$$\n\\phi = \\frac{E_{k,\\text{fast}}}{E_{k,\\text{total}}},\n$$\n其中 $E_{k,\\text{fast}}$ 是快模投影状态的动能，$E_{k,\\text{total}}$ 是初始状态的动能。如果 $E_{k,\\text{total}} = 0$，则返回 $0$。\n\n所有量必须使用以下单位处理：速度分量 $u$ 和 $v$ 的单位为 $\\text{m s}^{-1}$，表面高度扰动 $\\eta$ 的单位为 $\\text{m}$，重力加速度 $g$ 的单位为 $\\text{m s}^{-2}$，科里奥利参数 $f$ 的单位为 $\\text{s}^{-1}$，波数 $k_x$ 和 $k_y$ 的单位为 $\\text{m}^{-1}$。输入可能包含代表复傅里叶振幅的 $\\hat{u}$、$\\hat{v}$ 和 $\\hat{\\eta}$ 的复数项。\n\n使用以下测试套件。每个测试用例是一个元组 $(g, H, f, k_x, k_y, \\hat{u}, \\hat{v}, \\hat{\\eta})$：\n\n$1.$ 一般中纬度尺度，包含平衡和不平衡分量：\n$$\n(g, H, f, k_x, k_y, \\hat{u}, \\hat{v}, \\hat{\\eta}) = (9.81, 10000, 10^{-4}, 4\\times 10^{-6}, 3\\times 10^{-6}, 1.5, -0.5, 0.8).\n$$\n\n$2.$ 为满足给定波数下的地转关系而构建的纯平衡初始状态：\n$$\ng = 9.81, \\quad H = 10000, \\quad f = 10^{-4}, \\quad k_x = 4\\times 10^{-6}, \\quad k_y = 3\\times 10^{-6},\n$$\n与\n$$\n\\hat{\\eta} = 1.2, \\quad \\hat{u} = - i \\frac{g k_y}{f} \\hat{\\eta}, \\quad \\hat{v} = i \\frac{g k_x}{f} \\hat{\\eta}.\n$$\n\n$3.$ 零波数边界情况：\n$$\n(g, H, f, k_x, k_y, \\hat{u}, \\hat{v}, \\hat{\\eta}) = (9.81, 10000, 10^{-4}, 0, 0, 0.7, 0.9, 2.0).\n$$\n\n$4.$ 高波数重力波主导的情况：\n$$\n(g, H, f, k_x, k_y, \\hat{u}, \\hat{v}, \\hat{\\eta}) = (9.81, 10000, 10^{-4}, 2\\times 10^{-5}, 2\\times 10^{-5}, 0.2, -0.3, 0.05).\n$$\n\n$5.$ 波数极小且高度扰动可忽略的近惯性情况：\n$$\n(g, H, f, k_x, k_y, \\hat{u}, \\hat{v}, \\hat{\\eta}) = (9.81, 10000, 10^{-4}, 10^{-7}, 0, 0.4, 0.4, 0.0).\n$$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\phi_1,\\phi_2,\\phi_3,\\phi_4,\\phi_5]$），其中每个 $\\phi_j$ 是第 $j$ 个测试用例的快模中的动能分数，表示为小数。",
            "solution": "该问题要求计算线性化旋转浅水系统中不平衡的快速传播模（惯性重力波）所包含的动能分数。这是数据同化和模式初始化中的一个基本过程，旨在滤除可能污染数值预报的高频振荡。解决方案涉及将初始状态分解为其在系统简正模上的投影。\n\n傅里叶域中的控制线性系统由 $\\frac{d\\mathbf{s}}{dt} = A \\mathbf{s}$ 给出，其中状态向量为 $\\mathbf{s} = [\\hat{u}, \\hat{v}, \\hat{\\eta}]^\\top$，动力学矩阵为：\n$$\nA =\n\\begin{bmatrix}\n0  & f  & - g i k_x \\\\\n- f  & 0  & - g i k_y \\\\\n- H i k_x  & - H i k_y  & 0\n\\end{bmatrix}\n$$\n此处，$\\hat{u}$ 和 $\\hat{v}$ 是速度分量的复傅里叶振幅，$\\hat{\\eta}$ 是表面高度扰动的振幅，$f$ 是科里奥利参数，$g$ 是重力加速度，$H$ 是平均流体深度，$\\mathbf{k} = (k_x, k_y)$ 是波矢。数字 $i$ 是虚数单位。\n\n系统的简正模是矩阵 $A$ 的本征向量。相关的本征值 $\\lambda$ 决定了这些模态的时间行为。特征方程 $\\det(A - \\lambda I) = 0$ 为：\n$$\n-\\lambda \\left( \\lambda^2 + f^2 + gH(k_x^2 + k_y^2) \\right) = 0\n$$\n这会产生三个不同的本征值，它们代表了标度化的频率：\n$$\n\\lambda_1 = 0 \\quad \\text{(地转模或慢模)}\n$$\n$$\n\\lambda_{2,3} = \\pm i \\sqrt{f^2 + gHk^2} \\quad \\text{(惯性重力模或快模)}\n$$\n其中 $k = \\sqrt{k_x^2 + k_y^2}$ 是总波数。与 $\\lambda_1 = 0$ 相关联的本征向量张成了平衡子空间（或称慢子空间）。与 $\\lambda_{2,3} \\neq 0$（对于非平凡的 $f$ 或 $k$）相关联的两个本征向量张成了不平衡子空间（或称快子空间）。\n\n为确定快模中的能量分数，我们必须将初始状态向量 $\\mathbf{s}_0$ 投影到快子空间上。$A$ 的右本征向量集合，记为 $\\{\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3\\}$，构成了状态空间 $\\mathbb{C}^3$ 的一个基。任何初始状态 $\\mathbf{s}_0$ 都可以唯一地表示为这些本征向量的线性组合：\n$$\n\\mathbf{s}_0 = c_1 \\mathbf{r}_1 + c_2 \\mathbf{r}_2 + c_3 \\mathbf{r}_3\n$$\n$\\mathbf{s}_0$ 在快子空间上的投影 $\\mathbf{s}_{\\text{fast}}$ 是总和中对应于快模的部分：\n$$\n\\mathbf{s}_{\\text{fast}} = c_2 \\mathbf{r}_2 + c_3 \\mathbf{r}_3\n$$\n系数 $c_j$ 是使用 $A$ 的左本征向量集合 $\\{\\mathbf{l}_j\\}$ 求得的，该集合与右本征向量是双正交的。如果归一化使得 $\\mathbf{l}_j^\\dagger \\mathbf{r}_k = \\delta_{jk}$（其中 $\\dagger$ 表示共轭转置，$\\delta_{jk}$ 是克罗内克δ函数），则系数由投影 $c_j = \\mathbf{l}_j^\\dagger \\mathbf{s}_0$ 给出。\n\n在计算上，这个投影可以使用矩阵代数来实现。设 $R$ 是以右本征向量 $\\mathbf{r}_j$ 为列的矩阵。则系数向量 $\\mathbf{c} = [c_1, c_2, c_3]^\\top$ 可以通过 $\\mathbf{c} = R^{-1} \\mathbf{s}_0$ 求得。$R^{-1}$ 的行是共轭转置后的左本征向量 $\\mathbf{l}_j^\\dagger$。\n\n找到 $\\mathbf{s}_{\\text{fast}}$ 的算法步骤如下：\n1.  对于给定的参数集 $(g, H, f, k_x, k_y)$，构造矩阵 $A$。\n2.  数值计算 $A$ 的本征值 $\\lambda_j$ 和右本征向量矩阵 $R$。\n3.  计算左本征向量矩阵 $L = R^{-1}$。\n4.  给定初始状态 $\\mathbf{s}_0 = [\\hat{u}_0, \\hat{v}_0, \\hat{\\eta}_0]^\\top$，计算系数向量 $\\mathbf{c} = L \\mathbf{s}_0$。\n5.  识别与快模对应的系数（即满足 $|\\lambda_j| > \\epsilon$ 的系数，其中 $\\epsilon$ 是一个小的数值容差）。构造一个新的系数向量 $\\mathbf{c}_{\\text{fast}}$，其中慢模的系数被设置为零。\n6.  重构快模投影状态向量：$\\mathbf{s}_{\\text{fast}} = R \\mathbf{c}_{\\text{fast}}$。设此向量为 $\\mathbf{s}_{\\text{fast}} = [\\hat{u}_{\\text{fast}}, \\hat{v}_{\\text{fast}}, \\hat{\\eta}_{\\text{fast}}]^\\top$。\n\n最后，我们计算所需的动能分数 $\\phi$。总初始动能为：\n$$\nE_{k,\\text{total}} = \\frac{1}{4}\\left( |\\hat{u}_0|^2 + |\\hat{v}_0|^2 \\right)\n$$\n投影的快模分量的动能为：\n$$\nE_{k,\\text{fast}} = \\frac{1}{4}\\left( |\\hat{u}_{\\text{fast}}|^2 + |\\hat{v}_{\\text{fast}}|^2 \\right)\n$$\n快模中的动能分数则为：\n$$\n\\phi = \\frac{E_{k,\\text{fast}}}{E_{k,\\text{total}}}\n$$\n如果 $E_{k,\\text{total}} = 0$，问题规定 $\\phi$ 应返回为 $0$。此过程应用于每个测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n\n    def calculate_phi(params):\n        \"\"\"\n        Calculates the fraction of kinetic energy in the fast modes for a single test case.\n\n        Args:\n            params: A tuple containing the physical parameters and initial state:\n                    (g, H, f, kx, ky, u_hat, v_hat, eta_hat)\n\n        Returns:\n            The fraction phi as a float.\n        \"\"\"\n        g, H, f, kx, ky = params[:5]\n        u_hat, v_hat, eta_hat = params[5:]\n\n        # For Test Case 2, u_hat and v_hat are defined by geostrophic balance\n        if isinstance(u_hat, str) and u_hat == 'geostrophic':\n            # Note: f cannot be zero for this case, which is true for the test suite.\n            u_hat = -1j * g * ky * eta_hat / f\n            v_hat = 1j * g * kx * eta_hat / f\n\n        u_hat, v_hat, eta_hat = complex(u_hat), complex(v_hat), complex(eta_hat)\n\n        s0 = np.array([u_hat, v_hat, eta_hat], dtype=complex)\n\n        # Calculate total initial kinetic energy\n        # The 1/4 factor cancels in the ratio, so we can omit it.\n        E_k_total = np.abs(u_hat)**2 + np.abs(v_hat)**2\n\n        # If total kinetic energy is zero, the fraction is zero.\n        if E_k_total  1e-12:\n            return 0.0\n\n        # Construct the matrix A\n        A = np.array([\n            [0, f, -1j * g * kx],\n            [-f, 0, -1j * g * ky],\n            [-1j * H * kx, -1j * H * ky, 0]\n        ], dtype=complex)\n\n        # Compute eigen-decomposition of A\n        # eigvals: eigenvalues\n        # R: right eigenvectors (as columns)\n        try:\n            eigvals, R = np.linalg.eig(A)\n        except np.linalg.LinAlgError:\n            # Handle cases where eigendecomposition might fail, though unlikely for this matrix.\n            return np.nan\n\n        # Compute the inverse of R to get the left eigenvectors\n        # The rows of L are the (conjugate transpose of) the left eigenvectors.\n        try:\n            L = np.linalg.inv(R)\n        except np.linalg.LinAlgError:\n            # Handle non-invertible R (degenerate eigenvectors), also unlikely.\n            return np.nan\n\n        # Project the initial state onto the eigenvectors to get the mode coefficients\n        # c = L @ s0\n        c = np.dot(L, s0)\n\n        # Identify fast modes (those with non-zero eigenvalues)\n        # and create a new coefficient vector for only the fast modes.\n        c_fast = np.zeros_like(c, dtype=complex)\n        # Use a small tolerance to identify the zero eigenvalue\n        fast_mode_indices = np.where(np.abs(eigvals) > 1e-9)[0]\n        c_fast[fast_mode_indices] = c[fast_mode_indices]\n\n        # Reconstruct the state vector component in the fast subspace\n        # s_fast = R @ c_fast\n        s_fast = np.dot(R, c_fast)\n        \n        u_fast, v_fast = s_fast[0], s_fast[1]\n\n        # Calculate the kinetic energy in the fast modes\n        E_k_fast = np.abs(u_fast)**2 + np.abs(v_fast)**2\n\n        # Return the fraction\n        phi = E_k_fast / E_k_total\n        return phi\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General midlatitude scales\n        (9.81, 10000, 1e-4, 4e-6, 3e-6, 1.5, -0.5, 0.8),\n        # Case 2: Purely balanced initial state\n        (9.81, 10000, 1e-4, 4e-6, 3e-6, 'geostrophic', 'geostrophic', 1.2),\n        # Case 3: Zero wavenumber\n        (9.81, 10000, 1e-4, 0, 0, 0.7, 0.9, 2.0),\n        # Case 4: High-wavenumber gravity-wave-dominated\n        (9.81, 10000, 1e-4, 2e-5, 2e-5, 0.2, -0.3, 0.05),\n        # Case 5: Near-inertial regime\n        (9.81, 10000, 1e-4, 1e-7, 0, 0.4, 0.4, 0.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_phi(case)\n        results.append(f\"{result:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在诊断出不平衡之后，下一步关键任务便是构建一个平衡的初始状态。本练习将带领你实践一种经典且强大的技术：线性平衡方程。你将通过求解一个泊松方程，为一个给定的风场增量推导出与之动力协调的质量场（位势高度）增量，这正是许多业务化资料同化系统中的核心平衡约束之一。通过在纯旋转、纯辐散和混合型流场上测试该方法，你将深刻理解流场中哪些分量是可被平衡的，而哪些分量是造成不平衡的源头。",
            "id": "4064908",
            "problem": "考虑一个二维、正压的浅水模型，该模型建立在一个常数科里奥利参数平面（通常称为$f$平面）上，具有边长为$L$的方形周期性区域和$N \\times N$点的均匀网格。设水平风分量为$u(x,y)$和$v(x,y)$，质量场为高度$h(x,y)$。地转平衡用位势 $\\Phi(x,y) = g h(x,y)$ 表示为 $f \\,\\hat{\\mathbf{k}} \\times \\mathbf{v}_g = - \\nabla \\Phi$，其中 $g$ 是重力加速度，$f$ 是常数科里奥利参数，$\\hat{\\mathbf{k}}$ 是垂直单位向量，$\\mathbf{v}_g = (u_g, v_g)$ 是地转风。假设两个水平方向上均为周期性边界条件，并忽略任何外部强迫或摩擦。\n\n给定一个分析的风增量 $(\\delta u, \\delta v)$，定义相对涡度增量为 $\\delta \\zeta = \\partial_x \\delta v - \\partial_y \\delta u$。证明由地转平衡所蕴含的平衡质量场增量 $\\delta h$ 满足泊松方程\n$$\n\\nabla^2 \\delta h = \\frac{f}{g} \\, \\delta \\zeta,\n$$\n并且从 $\\delta h$ 重建的相应地转风增量为\n$$\n\\delta \\mathbf{v}_g = \\frac{g}{f} \\, \\hat{\\mathbf{k}} \\times \\nabla \\delta h = \\left( -\\frac{g}{f} \\, \\partial_y \\delta h \\,,\\, \\frac{g}{f} \\, \\partial_x \\delta h \\right).\n$$\n那么，非地转残差增量为 $\\delta \\mathbf{v}_a = (\\delta u, \\delta v) - \\delta \\mathbf{v}_g$。为量化与模式初始化和启动（spin-up）控制相关的不平衡，定义无量纲比率\n$$\nR = \\frac{\\sqrt{\\langle \\lvert \\delta \\mathbf{v}_a \\rvert^2 \\rangle}}{\\sqrt{\\langle \\lvert \\delta \\mathbf{v} \\rvert^2 \\rangle}},\n$$\n其中 $\\langle \\cdot \\rangle$ 表示在周期性区域上的空间平均，且 $\\lvert \\delta \\mathbf{v} \\rvert^2 = (\\delta u)^2 + (\\delta v)^2$。\n\n实现一个程序，对于指定的测试案例，构建 $(\\delta u, \\delta v)$，使用快速傅里叶变换 (FFT) 在周期性区域上求解 $\\delta h$ 的泊松方程，重建 $\\delta \\mathbf{v}_g$，计算残差 $\\delta \\mathbf{v}_a$，并输出每个案例的比率 $R$。使用与周期性区域一致的波数进行离散傅里叶变换，并将 $\\delta h$ 的零波数模态设置为零（强制高度增量为零均值）。将 $R$ 表示为十进制浮点数。\n\n所有测试案例使用以下参数值：\n- 网格大小：每个维度 $N = 64$ 个点。\n- 区域大小：$L = 10^6$ 米。\n- 科里奥利参数：$f = 10^{-4}$ s$^{-1}$。\n- 重力加速度：$g = 9.81$ m s$^{-2}$。\n\n构建三个测试案例，涵盖平衡、辐散和混合增量：\n1.  平衡的、无辐散的增量，源于流函数 $\\psi(x,y) = \\psi_0 \\cos(k_x x) \\cos(k_y y)$，振幅为 $\\psi_0 = 5000$ m$^2$ s$^{-1}$，其中 $k_x = 2\\pi m_x / L$ 和 $k_y = 2\\pi m_y / L$，且 $m_x = 2$ 和 $m_y = 3$。定义 $\\delta u = -\\partial_y \\psi$ 和 $\\delta v = \\partial_x \\psi$。\n2.  纯辐散的、无旋的增量，源于速度势 $\\chi(x,y) = \\chi_0 \\cos(k_x x) \\cos(k_y y)$，振幅为 $\\chi_0 = 5000$ m$^2$ s$^{-1}$，其中 $m_x = 4$ 和 $m_y = 1$。定义 $\\delta u = \\partial_x \\chi$ 和 $\\delta v = \\partial_y \\chi$。\n3.  混合增量，结合了流函数 $\\psi(x,y) = \\psi_0 \\cos(k_x x) \\cos(k_y y)$（$\\psi_0 = 3000$ m$^2$ s$^{-1}$ 且 $(m_x,m_y) = (3,2)$）和速度势 $\\chi(x,y) = \\chi_0 \\cos(k_x x) \\cos(k_y y)$（$\\chi_0 = 2000$ m$^2$ s$^{-1}$ 且 $(m_x,m_y) = (1,5)$）。定义 $(\\delta u, \\delta v)$ 为无辐散和无旋分量的和。\n\n要求：\n- 在周期性区域上，使用FFT对导数进行离散化并以谱方法求解泊松方程。使用由FFT频率向量乘以$2\\pi$计算出的角波数$k_x$和$k_y$。对于泊松方程 $\\nabla^2 \\delta h = \\frac{f}{g} \\delta \\zeta$，在谱空间中对非零波数求解为 $\\widehat{\\delta h}(\\mathbf{k}) = - \\widehat{F}(\\mathbf{k}) / \\lvert \\mathbf{k} \\rvert^2$，其中 $F = \\frac{f}{g} \\delta \\zeta$ 且 $\\lvert \\mathbf{k} \\rvert^2 = k_x^2 + k_y^2$，并设置 $\\widehat{\\delta h}(\\mathbf{0}) = 0$。\n- 使用FFT计算用于涡度和从$\\delta h$重建地转风的空间导数，确保与周期性边界条件的一致性。\n- 对每个测试案例，计算并报告比率 $R$，形式为十进制浮点数（无量纲）。\n- 你的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，`[result1,result2,result3]`）。\n\n无需外部输入；按上述规定硬编码参数和测试案例。最终输出量是无量纲比率；无需为输出值附加物理单位。",
            "solution": "所给出的问题是地球物理流体动力学中一个有效且适定的练习，具体涉及地转平衡的概念及其在数值模式初始化中的应用。我们的任务是在一个简化的模式框架中，量化给定风场增量的地转不平衡。问题的核心在于推导并数值求解一个泊松方程，以找到与给定风场相对应的平衡质量场。\n\n首先，我们将提供控制方程的理论推导。随后，我们将概述使用基于快速傅里叶变换（FFT）的谱方法的数值实现，该方法适用于指定的周期性区域。\n\n**理论推导**\n\n这个问题的基础是地转平衡，它描述了科里奥利力与气压梯度力完全平衡的状态。对于场的增量变化，这种平衡用位势增量 $\\delta \\Phi = g \\delta h$ 和地转风增量 $\\delta \\mathbf{v}_g = (\\delta u_g, \\delta v_g)$ 表示：\n$$\nf \\,\\hat{\\mathbf{k}} \\times \\delta \\mathbf{v}_g = - \\nabla \\delta \\Phi\n$$\n其中 $f$ 是科里奥利参数，$g$ 是重力加速度，$\\delta h$ 是高度增量，$\\hat{\\mathbf{k}}$ 是垂直方向的单位向量。展开叉积可得到分量形式的关系式：\n$$\n-f \\delta v_g = - \\partial_x (g \\delta h)\n$$\n$$\nf \\delta u_g = - \\partial_y (g \\delta h)\n$$\n求解地转风增量的分量可得：\n$$\n\\delta u_g = -\\frac{g}{f} \\partial_y \\delta h \\quad \\text{和} \\quad \\delta v_g = \\frac{g}{f} \\partial_x \\delta h\n$$\n这可以紧凑地写为 $\\delta \\mathbf{v}_g = \\frac{g}{f} \\hat{\\mathbf{k}} \\times \\nabla \\delta h$，这证实了问题描述中给出的重建地转风增量的表达式。\n\n接下来，我们推导高度增量 $\\delta h$ 的泊松方程。这种“线性平衡”过程的基本假设是，由地转风 $\\delta \\mathbf{v}_g$ 代表的平衡流的涡度必须等于给定的总风场增量 $\\delta \\mathbf{v} = (\\delta u, \\delta v)$ 的涡度。\n\n总风场增量的涡度定义为 $\\delta \\zeta = \\partial_x \\delta v - \\partial_y \\delta u$。\n地转风增量的涡度，记为 $\\delta \\zeta_g$，通过代入 $\\delta u_g$ 和 $\\delta v_g$ 的表达式计算得出：\n$$\n\\delta \\zeta_g = \\partial_x (\\delta v_g) - \\partial_y (\\delta u_g) = \\partial_x \\left(\\frac{g}{f} \\partial_x \\delta h\\right) - \\partial_y \\left(-\\frac{g}{f} \\partial_y \\delta h\\right)\n$$\n由于 $f$ 和 $g$ 是常数，我们有：\n$$\n\\delta \\zeta_g = \\frac{g}{f} \\left(\\frac{\\partial^2 \\delta h}{\\partial x^2} + \\frac{\\partial^2 \\delta h}{\\partial y^2}\\right) = \\frac{g}{f} \\nabla^2 \\delta h\n$$\n通过令地转涡度等于总涡度，即 $\\delta \\zeta_g = \\delta \\zeta$，我们建立了定义平衡高度场的关系：\n$$\n\\frac{g}{f} \\nabla^2 \\delta h = \\delta \\zeta\n$$\n重新整理此方程得到所需的平衡质量场增量 $\\delta h$ 的泊松方程：\n$$\n\\nabla^2 \\delta h = \\frac{f}{g} \\delta \\zeta\n$$\n\n**数值方法**\n\n该问题设定在一个方形、双周期区域上，这使得基于二维快速傅里叶变换（FFT）的谱方法成为数值求解的理想选择。它们在计算上高效，并且对于微分和求解泊松方程具有谱精度。\n\n网格上的连续场 $A(x,y)$ 由一个离散的 $N \\times N$ 数组表示。其二维离散傅里叶变换记为 $\\hat{A}(k_x, k_y)$。傅里叶变换的关键性质是空间导数在谱空间中变成了代数乘法：\n$$\n\\widehat{\\frac{\\partial A}{\\partial x}} = i k_x \\hat{A} \\quad \\text{和} \\quad \\widehat{\\frac{\\partial A}{\\partial y}} = i k_y \\hat{A}\n$$\n其中 $k_x$ 和 $k_y$ 是角波数。它们由 `numpy.fft.fftfreq` 提供的离散频率构建。\n\n对每个测试案例，求解算法按以下步骤进行：\n1.  **构建输入场**：使用给定的流函数和/或速度势，在 $N \\times N$ 离散网格上解析地定义风增量 $(\\delta u, \\delta v)$。\n2.  **计算涡度**：以谱方法计算涡度增量 $\\delta \\zeta = \\partial_x \\delta v - \\partial_y \\delta u$。我们首先计算 $\\delta u$ 和 $\\delta v$ 的二维FFT得到 $\\widehat{\\delta u}$ 和 $\\widehat{\\delta v}$。然后，涡度的变换 $\\widehat{\\delta \\zeta}$ 计算如下：\n    $$\n    \\widehat{\\delta \\zeta}(k_x, k_y) = i k_x \\widehat{\\delta v}(k_x, k_y) - i k_y \\widehat{\\delta u}(k_x, k_y)\n    $$\n3.  **求解泊松方程**：泊松方程 $\\nabla^2 \\delta h = \\frac{f}{g} \\delta \\zeta$ 在谱域中转化为一个代数方程：\n    $$\n    -(k_x^2 + k_y^2) \\widehat{\\delta h} = \\frac{f}{g} \\widehat{\\delta \\zeta}\n    $$\n    我们求解高度增量的谱系数 $\\widehat{\\delta h}$：\n    $$\n    \\widehat{\\delta h}(k_x, k_y) = - \\frac{f}{g} \\frac{\\widehat{\\delta \\zeta}(k_x, k_y)}{k_x^2 + k_y^2}\n    $$\n    对于零波数模态 $(k_x, k_y) = (0,0)$，分母为零。按照规定，我们设置 $\\widehat{\\delta h}(0,0) = 0$，这强制高度增量的空间平均值为零，即 $\\langle \\delta h \\rangle = 0$。这个条件确保了唯一解，并且是有效的，因为在周期性区域上，右侧项的空间平均值 $\\langle \\delta \\zeta \\rangle$ 保证为零。\n4.  **重建地转风**：从计算出的 $\\delta h$ 重建平衡地转风增量 $\\delta \\mathbf{v}_g$。为保持一致性，这也以谱方法完成。我们首先通过求解泊松方程计算出 $\\widehat{\\delta h}$，然后找到其谱分量：\n    $$\n    \\widehat{\\delta u_g} = -\\frac{g}{f} (i k_y \\widehat{\\delta h}) \\quad \\text{和} \\quad \\widehat{\\delta v_g} = \\frac{g}{f} (i k_x \\widehat{\\delta h})\n    $$\n    对 $\\widehat{\\delta u_g}$ 和 $\\widehat{\\delta v_g}$ 进行逆二维FFT，得到实空间场 $(\\delta u_g, \\delta v_g)$。\n5.  **计算不平衡比率**：非地转残差增量为 $\\delta \\mathbf{v}_a = \\delta \\mathbf{v} - \\delta \\mathbf{v}_g$。不平衡比率 $R$ 随后计算为非地转风增量和总风增量的均方根大小之比：\n    $$\n    R = \\frac{\\sqrt{\\langle (\\delta u_a)^2 + (\\delta v_a)^2 \\rangle}}{\\sqrt{\\langle (\\delta u)^2 + (\\delta v)^2 \\rangle}}\n    $$\n    其中 $\\langle \\cdot \\rangle$ 表示所有网格点上的平均值。\n\n**测试案例的预期结果**\n*   **案例1（平衡）**：输入风场是纯旋转的（无辐散），由流函数 $\\psi$ 导出。如在验证思路中所述，线性平衡方程通过 $\\delta h = (f/g)\\psi$ 完美地将 $\\delta h$ 与 $\\psi$ 联系起来。重建的地转风 $\\delta \\mathbf{v}_g$ 将与输入风 $\\delta \\mathbf{v}$ 完全相同。因此，非地转残差 $\\delta \\mathbf{v}_a$ 将为零，我们预期 $R \\approx 0$（在数值精度范围内）。\n*   **案例2（辐散）**：输入风场是纯辐散的（无旋），由速度势 $\\chi$ 导出。其涡度 $\\delta \\zeta$ 恒为零。均值为零的 $\\nabla^2 \\delta h = 0$ 的解是 $\\delta h = 0$。因此，重建的地转风 $\\delta \\mathbf{v}_g$ 为零。非地转残差即为整个输入风，$\\delta \\mathbf{v}_a = \\delta \\mathbf{v}$。因此，我们预期 $R=1$。\n*   **案例3（混合）**：输入风是旋转分量和辐散分量的和，$\\delta \\mathbf{v} = \\mathbf{v}_\\psi + \\mathbf{v}_\\chi$。平衡过程只“看到”来自旋转部分 $\\mathbf{v}_\\psi$ 的涡度。它将重建出 $\\delta \\mathbf{v}_g = \\mathbf{v}_\\psi$。非地转残差将是纯辐散部分 $\\mathbf{v}_\\chi$。因此，比率 $R$ 将是辐散分量的能量与总风场能量之比，其值介于0和1之间。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the geostrophic imbalance ratio R for three test cases\n    of wind increments in a shallow-water model on a periodic f-plane.\n    \"\"\"\n    # Define physical and numerical-grid constants\n    N = 64\n    L = 1.0e6  # meters\n    f = 1.0e-4  # s^-1\n    g = 9.81  # m/s^2\n\n    # Set up the computational grid and wavenumbers\n    # The grid spacing dx is the same for both dimensions.\n    dx = L / N\n    # Create a 1D coordinate array.\n    x = np.arange(N) * dx\n    # Create 2D coordinate grids. The 'xy' indexing is the default and standard for\n    # ensuring that axis 0 corresponds to the y-dimension and axis 1 to the x-dimension.\n    # xx[i, j] = x[j], yy[i, j] = x[i]\n    xx, yy = np.meshgrid(x, x, indexing='xy')\n\n    # Create 1D array of angular wavenumbers.\n    k_freq = np.fft.fftfreq(N, d=dx)\n    k = 2 * np.pi * k_freq\n    # Create 2D wavenumber grids corresponding to the coordinate grids.\n    # kxx corresponds to differentiation along axis 1 (x).\n    # kyy corresponds to differentiation along axis 0 (y).\n    kxx, kyy = np.meshgrid(k, k, indexing='xy')\n    \n    # Squared total wavenumber.\n    ksq = kxx**2 + kyy**2\n\n    # Define the parameters for the three test cases.\n    test_cases = [\n        # Case 1: Purely balanced (nondivergent) flow.\n        {'psi_params': {'amp': 5000.0, 'mx': 2, 'my': 3}, 'chi_params': None},\n        # Case 2: Purely divergent (irrotational) flow.\n        {'psi_params': None, 'chi_params': {'amp': 5000.0, 'mx': 4, 'my': 1}},\n        # Case 3: Mixed flow with both rotational and divergent components.\n        {\n            'psi_params': {'amp': 3000.0, 'mx': 3, 'my': 2},\n            'chi_params': {'amp': 2000.0, 'mx': 1, 'my': 5}\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Initialize wind increments to zero.\n        du = np.zeros((N, N), dtype=float)\n        dv = np.zeros((N, N), dtype=float)\n\n        # Construct the total wind increment (du, dv) by summing components.\n        # Rotational (nondivergent) component from streamfunction psi.\n        if case['psi_params']:\n            p = case['psi_params']\n            psi0, mx, my = p['amp'], p['mx'], p['my']\n            kx_an = 2 * np.pi * mx / L\n            ky_an = 2 * np.pi * my / L\n            # du = -d/dy(psi)\n            du += psi0 * ky_an * np.cos(kx_an * xx) * np.sin(ky_an * yy)\n            # dv = d/dx(psi)\n            dv -= psi0 * kx_an * np.sin(kx_an * xx) * np.cos(ky_an * yy)\n        \n        # Divergent (irrotational) component from velocity potential chi.\n        if case['chi_params']:\n            c = case['chi_params']\n            chi0, mx, my = c['amp'], c['mx'], c['my']\n            kx_an = 2 * np.pi * mx / L\n            ky_an = 2 * np.pi * my / L\n            # du = d/dx(chi)\n            du -= chi0 * kx_an * np.sin(kx_an * xx) * np.cos(ky_an * yy)\n            # dv = d/dy(chi)\n            dv -= chi0 * ky_an * np.cos(kx_an * xx) * np.sin(ky_an * yy)\n\n        # Compute vorticity spectrally\n        du_hat = np.fft.fft2(du)\n        dv_hat = np.fft.fft2(dv)\n        dzeta_hat = 1j * kxx * dv_hat - 1j * kyy * du_hat\n        \n        # Solve the Poisson equation for the height increment in spectral space.\n        # Equation: -(kxx^2 + kyy^2) * dh_hat = (f/g) * dzeta_hat\n        dh_hat = np.zeros_like(dzeta_hat)\n        # Avoid division by zero at k=0 by using a mask.\n        non_zero_k = ksq != 0\n        dh_hat[non_zero_k] = (f / g) * dzeta_hat[non_zero_k] / (-ksq[non_zero_k])\n        # The mean height is set to zero by ensuring dh_hat[0, 0] = 0.\n\n        # Reconstruct the geostrophic wind increment in spectral space.\n        # dug_hat = -(g/f) * 1j * kyy * dh_hat\n        # dvg_hat = (g/f) * 1j * kxx * dh_hat\n        dug_hat = (-g / f) * 1j * kyy * dh_hat\n        dvg_hat = (g / f) * 1j * kxx * dh_hat\n        \n        # Transform geostrophic winds back to real space.\n        du_g = np.real(np.fft.ifft2(dug_hat))\n        dv_g = np.real(np.fft.ifft2(dvg_hat))\n        \n        # Compute the ageostrophic residual increment.\n        du_a = du - du_g\n        dv_a = dv - dv_g\n        \n        # Calculate the imbalance ratio R.\n        # Mean squared magnitude of the ageostrophic wind.\n        mean_sq_va = np.mean(du_a**2 + dv_a**2)\n        # Mean squared magnitude of the total wind.\n        mean_sq_v = np.mean(du**2 + dv**2)\n        \n        if mean_sq_v  1e-16: # Avoid division by zero for null fields\n            R = 0.0\n        else:\n            R = np.sqrt(mean_sq_va / mean_sq_v)\n            \n        results.append(R)\n\n    # Format and print the final results as specified.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了静态地构造平衡场，我们还可以通过牛顿弛豫（或称“ nudging ”）等动力学方法，在积分过程中逐步引导模式状态趋于平衡。然而，这种看似温和的调整方法若使用不当，也会带来风险。本练习将深入探讨“过度 nudging ”的潜在危害：即当弛豫项过强时，它会扭曲模式自身的物理过程。通过分析一个传播中的斜压波在 nudging 作用下产生的相位误差，你将定量地理解该方法如何可能无意中改变模式的内蕴动力学特性，这对于维护模拟的物理真实性至关重要。",
            "id": "4064894",
            "problem": "考虑一个数值天气预报 (NWP) 模式中的单个纬向波数的斜压模，该模式通过向外部提供的分析场进行弛豫（牛顿逼近）来初始化。对于单个傅里叶分量，将其复振幅建模为 $A(t)$，其内在的线性化动力学由常微分方程 $dA/dt = (\\sigma + i \\,\\omega)\\,A$ 给出，其中 $\\sigma$ 是实值的内在增长率（单位为 $\\mathrm{s}^{-1}$），$\\omega$ 是实值的内在角频率（单位为 $\\mathrm{s}^{-1}$），$i$ 是虚数单位。向分析场 $A_{\\mathrm{ref}}(t)$ 的弛豫（牛顿逼近）被建模为一个速率为 $\\alpha$（单位为 $\\mathrm{s}^{-1}$）的线性弛豫项，从而得到受迫线性动力学\n$$\n\\frac{dA}{dt} = (\\sigma + i\\,\\omega)\\,A - \\alpha\\,(A - A_{\\mathrm{ref}}(t)).\n$$\n假设分析场具有形式 $A_{\\mathrm{ref}}(t) = a_{\\mathrm{ref}}\\,\\exp\\big((\\sigma_{\\mathrm{r}} + i\\,\\omega_{\\mathrm{r}})\\,t + i\\,\\phi_{\\mathrm{ref},0}\\big)$，其中 $a_{\\mathrm{ref}}  0$ 是一个实常数振幅，$\\sigma_{\\mathrm{r}}$ 是分析场增长率（单位为 $\\mathrm{s}^{-1}$），$\\omega_{\\mathrm{r}}$ 是分析场角频率（单位为 $\\mathrm{s}^{-1}$），$\\phi_{\\mathrm{ref},0}$ 是初始分析场相位（单位为弧度）。设模式初始条件为 $A(0) = a_0\\,\\exp(i\\,\\phi_0)$，其中 $a_0  0$ 且初始相位为 $\\phi_0$（单位为弧度）。将自由（无牛顿逼近）模式解定义为 $A_{\\mathrm{free}}(t) = a_0\\,\\exp\\big(\\sigma\\,t + i\\,(\\omega\\,t + \\phi_0)\\big)$。\n\n您的任务是计算在指定的检验时间 $T$（单位为秒）时，由弛豫引入的相位误差。该误差定义为经过牛顿逼近的解 $A(T)$ 的相位与自由解 $A_{\\mathrm{free}}(T)$ 的相位之间的缠绕差（到主分支），\n$$\n\\Delta\\phi(T) = \\mathrm{wrap}_{[-\\pi,\\pi]}\\Big(\\arg\\big(A(T)\\big) - \\arg\\big(A_{\\mathrm{free}}(T)\\big)\\Big),\n$$\n其中 $\\arg(\\cdot)$ 表示复数辐角，$\\mathrm{wrap}_{[-\\pi,\\pi]}(\\cdot)$ 将任意角度缠绕到区间 $[-\\pi,\\pi]$ 弧度。\n\n从上述线性弛豫公式和线性常系数常微分方程的基本性质出发，推导一个表达式或算法来计算给定参数下的 $A(T)$，然后计算 $\\Delta\\phi(T)$。该解必须是通用的，并且能够处理当复数强迫频率与齐次指数匹配时的特殊共振情况（即，当 $(\\sigma_{\\mathrm{r}} + i\\,\\omega_{\\mathrm{r}}) = (\\sigma + i\\,\\omega - \\alpha)$ 时）。\n\n使用以下参数集测试套件。在所有情况下，设置 $a_0 = 1$, $\\phi_0 = 0$, $a_{\\mathrm{ref}} = 1$ 和 $\\phi_{\\mathrm{ref},0} = 0$。角度必须以弧度为单位。所有速率的单位均为 $\\mathrm{s}^{-1}$，时间的单位均为秒。检验时间为 $T = 10 \\times 86400$。\n\n- 情况 $1$ (理想情况，弱牛顿逼近，频率匹配): $\\sigma = 8\\times 10^{-6}$, $\\omega = \\frac{2\\pi}{5\\times 86400}$, $\\alpha = 2\\times 10^{-6}$, $\\sigma_{\\mathrm{r}} = 0$, $\\omega_{\\mathrm{r}} = \\frac{2\\pi}{5\\times 86400}$。\n- 情况 $2$ (边界情况，无牛顿逼近): $\\sigma = 8\\times 10^{-6}$, $\\omega = \\frac{2\\pi}{5\\times 86400}$, $\\alpha = 0$, $\\sigma_{\\mathrm{r}} = 0$, $\\omega_{\\mathrm{r}} = \\frac{2\\pi}{5\\times 86400}$。\n- 情况 $3$ (过度牛顿逼近，频率匹配): $\\sigma = 8\\times 10^{-6}$, $\\omega = \\frac{2\\pi}{5\\times 86400}$, $\\alpha = 4\\times 10^{-5}$, $\\sigma_{\\mathrm{r}} = 0$, $\\omega_{\\mathrm{r}} = \\frac{2\\pi}{5\\times 86400}$。\n- 情况 $4$ (频率失配，中等牛顿逼近): $\\sigma = 8\\times 10^{-6}$, $\\omega = \\frac{2\\pi}{5\\times 86400}$, $\\alpha = 1\\times 10^{-5}$, $\\sigma_{\\mathrm{r}} = 0$, $\\omega_{\\mathrm{r}} = 1.2\\,\\frac{2\\pi}{5\\times 86400}$。\n- 情况 $5$ (共振强迫，牛顿逼近平衡内在增长): $\\sigma = 1\\times 10^{-5}$, $\\omega = \\frac{2\\pi}{5\\times 86400}$, $\\alpha = 1\\times 10^{-5}$, $\\sigma_{\\mathrm{r}} = 0$, $\\omega_{\\mathrm{r}} = \\frac{2\\pi}{5\\times 86400}$。\n\n将最终输出表示为单行，其中包含五个案例的相位误差的逗号分隔列表，并用方括号括起来，每个值都四舍五入到六位小数，单位为弧度。例如，输出格式必须与 $[x_1,x_2,x_3,x_4,x_5]$ 完全一样，其中每个 $x_j$ 是一个四舍五入到六位小数的浮点数（单位为弧度）。",
            "solution": "### 步骤 1：提取已知条件\n- **控制方程：** 复振幅 $A(t)$ 的常微分方程 (ODE) 由以下公式给出：\n$$ \\frac{dA}{dt} = (\\sigma + i\\,\\omega)\\,A - \\alpha\\,(A - A_{\\mathrm{ref}}(t)) $$\n- **参数：**\n  - $A(t)$：时间 $t$ 时的复振幅。\n  - $\\sigma$：内在增长率 ($\\mathrm{s}^{-1}$)。\n  - $\\omega$：内在角频率 ($\\mathrm{s}^{-1}$)。\n  - $\\alpha$：弛豫（牛顿逼近）速率 ($\\mathrm{s}^{-1}$)。\n  - $i$：虚数单位。\n- **分析场：** 参考场 $A_{\\mathrm{ref}}(t)$ 定义为：\n$$ A_{\\mathrm{ref}}(t) = a_{\\mathrm{ref}}\\,\\exp\\big((\\sigma_{\\mathrm{r}} + i\\,\\omega_{\\mathrm{r}})\\,t + i\\,\\phi_{\\mathrm{ref},0}\\big) $$\n  - $a_{\\mathrm{ref}}$：常实数振幅 ($0$)。\n  - $\\sigma_{\\mathrm{r}}$：分析场增长率 ($\\mathrm{s}^{-1}$)。\n  - $\\omega_{\\mathrm{r}}$：分析场角频率 ($\\mathrm{s}^{-1}$)。\n  - $\\phi_{\\mathrm{ref},0}$：初始分析场相位 (弧度)。\n- **初始条件：** 模式在 $t=0$ 时的初始化条件为：\n$$ A(0) = a_0\\,\\exp(i\\,\\phi_0) $$\n  - $a_0$：初始振幅 ($0$)。\n  - $\\phi_0$：初始相位 (弧度)。\n- **自由解：** 为进行比较，定义无牛顿逼近的解：\n$$ A_{\\mathrm{free}}(t) = a_0\\,\\exp\\big(\\sigma\\,t + i\\,(\\omega\\,t + \\phi_0)\\big) $$\n- **目标量：** 检验时间 $T$ 时的相位误差 $\\Delta\\phi(T)$ 为：\n$$ \\Delta\\phi(T) = \\mathrm{wrap}_{[-\\pi,\\pi]}\\Big(\\arg\\big(A(T)\\big) - \\arg\\big(A_{\\mathrm{free}}(T)\\big)\\Big) $$\n- **特殊条件：** 解必须能正确处理当 $(\\sigma_{\\mathrm{r}} + i\\,\\omega_{\\mathrm{r}}) = (\\sigma + i\\,\\omega - \\alpha)$ 时的共振情况。\n- **测试用例参数：** 对于所有情况，$a_0 = 1$, $\\phi_0 = 0$, $a_{\\mathrm{ref}} = 1$, $\\phi_{\\mathrm{ref},0} = 0$，检验时间为 $T = 10 \\times 86400$ 秒。\n  - 情况 $1$：$\\sigma = 8\\times 10^{-6}$，$\\omega = \\frac{2\\pi}{5\\times 86400}$，$\\alpha = 2\\times 10^{-6}$，$\\sigma_{\\mathrm{r}} = 0$，$\\omega_{\\mathrm{r}} = \\frac{2\\pi}{5\\times 86400}$。\n  - 情况 $2$：$\\sigma = 8\\times 10^{-6}$，$\\omega = \\frac{2\\pi}{5\\times 86400}$，$\\alpha = 0$，$\\sigma_{\\mathrm{r}} = 0$，$\\omega_{\\mathrm{r}} = \\frac{2\\pi}{5\\times 86400}$。\n  - 情况 $3$：$\\sigma = 8\\times 10^{-6}$，$\\omega = \\frac{2\\pi}{5\\times 86400}$，$\\alpha = 4\\times 10^{-5}$，$\\sigma_{\\mathrm{r}} = 0$，$\\omega_{\\mathrm{r}} = \\frac{2\\pi}{5\\times 86400}$。\n  - 情况 $4$：$\\sigma = 8\\times 10^{-6}$，$\\omega = \\frac{2\\pi}{5\\times 86400}$，$\\alpha = 1\\times 10^{-5}$，$\\sigma_{\\mathrm{r}} = 0$，$\\omega_{\\mathrm{r}} = 1.2\\,\\frac{2\\pi}{5\\times 86400}$。\n  - 情况 $5$：$\\sigma = 1\\times 10^{-5}$，$\\omega = \\frac{2\\pi}{5\\times 86400}$，$\\alpha = 1\\times 10^{-5}$，$\\sigma_{\\mathrm{r}} = 0$，$\\omega_{\\mathrm{r}} = \\frac{2\\pi}{5\\times 86400}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题是一个定义明确的一阶线性非齐次常微分方程的初值问题。这是数学和物理学中的一个标准课题。其物理背景是地球物理流体动力学中的数据同化，参数值代表了大尺度大气波。该问题是自洽的，有科学依据，且在数学上是适定的。处理共振情况的要求展示了一个完整的理论框架。不存在不一致、歧义或事实错误。\n\n### 步骤 3：结论与行动\n该问题被认为是**有效的**。将推导求解过程。\n\n### 解的推导\n控制常微分方程为：\n$$ \\frac{dA}{dt} = (\\sigma + i\\,\\omega)\\,A - \\alpha\\,(A - A_{\\mathrm{ref}}(t)) $$\n这可以重排成一阶线性常微分方程的标准形式 $\\frac{dy}{dt} + p(t)y = q(t)$。\n$$ \\frac{dA}{dt} - (\\sigma - \\alpha + i\\,\\omega)A = \\alpha A_{\\mathrm{ref}}(t) $$\n为清晰起见，我们定义两个复常数。设 $\\lambda$ 为齐次部分的复系数：\n$$ \\lambda = (\\sigma - \\alpha) + i\\,\\omega $$\n右侧的强迫项与 $A_{\\mathrm{ref}}(t)$ 成正比，后者具有复指数时间依赖性。设 $\\gamma$ 为强迫项的复指数：\n$$ \\gamma = \\sigma_{\\mathrm{r}} + i\\,\\omega_{\\mathrm{r}} $$\n现在常微分方程可以写成：\n$$ \\frac{dA}{dt} - \\lambda A = \\alpha a_{\\mathrm{ref}} e^{i\\phi_{\\mathrm{ref},0}} e^{\\gamma t} $$\n设 $F_0 = \\alpha a_{\\mathrm{ref}} e^{i\\phi_{\\mathrm{ref},0}}$。方程为 $\\frac{dA}{dt} - \\lambda A = F_0 e^{\\gamma t}$。这是一个线性、一阶、常系数的非齐次常微分方程。我们可以用积分因子法求解，积分因子为 $I(t) = \\exp\\left(\\int -\\lambda dt\\right) = e^{-\\lambda t}$。\n将常微分方程乘以 $I(t)$ 得到：\n$$ e^{-\\lambda t} \\frac{dA}{dt} - \\lambda e^{-\\lambda t} A = F_0 e^{(\\gamma - \\lambda) t} $$\n左边是一个乘积的导数：\n$$ \\frac{d}{dt}\\left(A(t) e^{-\\lambda t}\\right) = F_0 e^{(\\gamma - \\lambda) t} $$\n我们将此方程从 $t=0$ 积分到一个通用时间 $t$：\n$$ \\int_{0}^{t} \\frac{d}{d\\tau}\\left(A(\\tau) e^{-\\lambda \\tau}\\right) d\\tau = \\int_{0}^{t} F_0 e^{(\\gamma - \\lambda) \\tau} d\\tau $$\n$$ A(t)e^{-\\lambda t} - A(0)e^{0} = F_0 \\int_{0}^{t} e^{(\\gamma - \\lambda) \\tau} d\\tau $$\n解取决于积分的计算，根据指数是否为零，有两种情况。\n\n**情况 A：非共振情况 ($\\gamma \\neq \\lambda$)**\n在这种情况下，积分为：\n$$ \\int_{0}^{t} e^{(\\gamma - \\lambda) \\tau} d\\tau = \\left[ \\frac{e^{(\\gamma - \\lambda) \\tau}}{\\gamma - \\lambda} \\right]_0^t = \\frac{e^{(\\gamma - \\lambda) t} - 1}{\\gamma - \\lambda} $$\n将其代回得到：\n$$ A(t)e^{-\\lambda t} = A(0) + F_0 \\frac{e^{(\\gamma - \\lambda) t} - 1}{\\gamma - \\lambda} $$\n求解 $A(t)$:\n$$ A(t) = A(0)e^{\\lambda t} + \\frac{F_0}{\\gamma - \\lambda} \\left( e^{\\gamma t} - e^{\\lambda t} \\right) $$\n$$ A(t) = \\left(A(0) - \\frac{F_0}{\\gamma - \\lambda}\\right) e^{\\lambda t} + \\left(\\frac{F_0}{\\gamma - \\lambda}\\right) e^{\\gamma t} $$\n\n**情况 B：共振情况 ($\\gamma = \\lambda$)**\n在这种情况下，项 $(\\gamma - \\lambda)$ 为零，被积函数变为 $e^0 = 1$。积分为：\n$$ \\int_{0}^{t} d\\tau = t $$\n将其代回得到：\n$$ A(t)e^{-\\lambda t} = A(0) + F_0 t $$\n求解 $A(t)$:\n$$ A(t) = (A(0) + F_0 t) e^{\\lambda t} $$\n该解表现出随时间线性增长（$t$ 项），再乘以振荡指数项，这是共振的特征。\n\n**相位误差 $\\Delta\\phi(T)$ 的计算**\n相位误差定义为 $\\Delta\\phi(T) = \\mathrm{wrap}_{[-\\pi,\\pi]}(\\arg(A(T)) - \\arg(A_{\\mathrm{free}}(T)))$。\n我们首先计算自由解的辐角 $\\arg(A_{\\mathrm{free}}(T))$。\n$$ A_{\\mathrm{free}}(T) = a_0\\,\\exp\\big(\\sigma\\,T + i\\,(\\omega\\,T + \\phi_0)\\big) $$\n其辐角为 $\\mathrm{wrap}_{[-\\pi,\\pi]}(\\omega T + \\phi_0)$。\n对于给定的测试用例，$\\phi_0 = 0$。内在频率是 $\\omega = \\frac{2\\pi}{5 \\times 86400}\\,\\mathrm{s}^{-1}$，检验时间是 $T = 10 \\times 86400\\,\\mathrm{s}$。\n因此，项 $\\omega T$ 为：\n$$ \\omega T = \\left(\\frac{2\\pi}{5 \\times 86400}\\right) \\times (10 \\times 86400) = 4\\pi $$\n由于 $4\\pi$ 是 $2\\pi$ 的整数倍，其主值为 $0$。因此，对于所有测试用例：\n$$ \\arg(A_{\\mathrm{free}}(T)) = \\mathrm{wrap}_{[-\\pi,\\pi]}(4\\pi + 0) = 0 $$\n相位误差简化为时间 $T$ 时牛顿逼近解的辐角：\n$$ \\Delta\\phi(T) = \\mathrm{wrap}_{[-\\pi,\\pi]}(\\arg(A(T)) - 0) = \\arg(A(T)) $$\n现在的任务是使用适当的公式（共振或非共振）为每种情况计算 $A(T)$，然后使用 `atan2` 函数找到其复数辐角，该函数能正确地将角度置于 $(-\\pi, \\pi]$ 区间内。\n\n对于所有测试用例，初始条件被简化为：$a_0 = 1$, $\\phi_0 = 0$, $a_{\\mathrm{ref}} = 1$, $\\phi_{\\mathrm{ref},0} = 0$。这意味着 $A(0) = 1$ 和 $F_0 = \\alpha$。共振条件 $\\gamma = \\lambda$ 变为 $\\sigma_{\\mathrm{r}} + i\\omega_{\\mathrm{r}} = \\sigma - \\alpha + i\\omega$，这等价于两个实数条件：$\\sigma_{\\mathrm{r}} = \\sigma - \\alpha$ 和 $\\omega_{\\mathrm{r}} = \\omega$。\n\n算法如下：\n1.  对于每个测试用例，定义参数 $\\sigma, \\omega, \\alpha, \\sigma_r, \\omega_r$。\n2.  构建复数值 $\\lambda = (\\sigma - \\alpha) + i\\omega$ 和 $\\gamma = \\sigma_r + i\\omega_r$。\n3.  通过比较 $\\lambda$ 和 $\\gamma$ 来检查共振。对于此浮点比较，使用数值公差。\n4.  如果共振 ($\\gamma \\approx \\lambda$)，则计算 $A(T) = (1 + \\alpha T) e^{\\lambda T}$。\n5.  如果非共振 ($\\gamma \\not\\approx \\lambda$)，则计算 $A(T) = \\left(1 - \\frac{\\alpha}{\\gamma - \\lambda}\\right) e^{\\lambda T} + \\left(\\frac{\\alpha}{\\gamma - \\lambda}\\right) e^{\\gamma T}$。\n6.  相位误差 $\\Delta\\phi(T)$ 是所得 $A(T)$ 的复数辐角。\n7.  最终结果四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    为一系列测试用例计算由牛顿逼近引入的相位误差。\n    该问题由一个一阶线性非齐次常微分方程建模，并针对共振和非共振强迫情况进行了分析求解。\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (sigma, omega, alpha, sigma_r, omega_r)\n    # The base frequency is omega_val = 2*pi / (5 days)\n    omega_val = 2. * np.pi / (5. * 86400.)\n    test_cases = [\n        # Case 1 (happy path, weak nudging, matched frequency)\n        (8e-6, omega_val, 2e-6, 0., omega_val),\n        # Case 2 (boundary, no nudging)\n        (8e-6, omega_val, 0., 0., omega_val),\n        # Case 3 (over-nudging, matched frequency)\n        (8e-6, omega_val, 4e-5, 0., omega_val),\n        # Case 4 (frequency mismatch, moderate nudging)\n        (8e-6, omega_val, 1e-5, 0., 1.2 * omega_val),\n        # Case 5 (resonant forcing, nudging balances intrinsic growth)\n        (1e-5, omega_val, 1e-5, 0., omega_val),\n    ]\n\n    # Common parameters for all test cases\n    T = 10. * 86400.  # Verification time in seconds (10 days)\n    a0 = 1.0           # Initial amplitude\n    phi0 = 0.0         # Initial phase\n    a_ref = 1.0        # Reference amplitude\n    phi_ref_0 = 0.0    # Initial reference phase\n\n    A0 = a0 * np.exp(1j * phi0)\n\n    results = []\n    for case in test_cases:\n        sigma, omega, alpha, sigma_r, omega_r = case\n\n        # Define complex coefficients from the ODE\n        # d/dt A - lambda A = F0 exp(gamma t)\n        lmbda = (sigma - alpha) + 1j * omega\n        gamma = sigma_r + 1j * omega_r\n        \n        # F0 is the amplitude of the forcing term\n        F0 = alpha * a_ref * np.exp(1j * phi_ref_0)\n\n        # Check for resonance: gamma is close to lambda\n        is_resonant = np.isclose(gamma, lmbda)\n\n        if is_resonant:\n            # Solution for the resonant case: A(t) = (A(0) + F0*t) * exp(lambda*t)\n            A_T = (A0 + F0 * T) * np.exp(lmbda * T)\n        else:\n            # Solution for the non-resonant case:\n            # A(t) = (A(0) - F0/(gamma-lambda)) * exp(lambda*t) + (F0/(gamma-lambda)) * exp(gamma*t)\n            term = F0 / (gamma - lmbda)\n            C = A0 - term\n            A_T = C * np.exp(lmbda * T) + term * np.exp(gamma * T)\n            \n        # The phase error is defined as Delta_phi(T) = arg(A(T)) - arg(A_free(T)).\n        # As derived in the solution, arg(A_free(T)) = wrap(omega*T + phi0).\n        # omega*T = (2*pi / (5 * 86400)) * (10 * 86400) = 4*pi.\n        # Since phi0=0, arg(A_free(T)) = wrap(4*pi) = 0.\n        # Therefore, the phase error is simply the argument of the nudged solution A(T).\n        delta_phi = np.angle(A_T)\n        results.append(delta_phi)\n\n    # Format the output as a comma-separated list of strings,\n    # with each value rounded to six decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}