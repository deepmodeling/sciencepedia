{
    "hands_on_practices": [
        {
            "introduction": "预报检验中最基础的任务是评估对二元（“是/否”）事件的预报表现。本练习将介绍 $2 \\times 2$ 列联表，它是几乎所有分类预报检验指标的基石 。通过根据给定的预报-观测数据对，亲手构建列联表并计算皮尔斯技巧评分（Peirce Skill Score），您将具体理解我们如何量化模型正确预报事件发生与不发生的能力。",
            "id": "4044107",
            "problem": "对一个确定性数值天气预报（NWP）模式进行了为期 $N=24$ 天的单站日降水量检验研究。对于每一天 $i$，都有一个模式预报的24小时累积降水量（单位：毫米）和一个用于检验的观测值（单位：毫米）。考虑一个由10毫米降水阈值定义的二元事件：当且仅当24小时累积降水量大于或等于10毫米时，该事件发生。\n\n第 $i=1,\\dots,24$ 天的预报-观测对 $(f_i, o_i)$ 如下所示（所有数值单位均为毫米）：\n- 第1天：$f_1=12$, $o_1=13$\n- 第2天：$f_2=8$, $o_2=0$\n- 第3天：$f_3=15$, $o_3=5$\n- 第4天：$f_4=4$, $o_4=11$\n- 第5天：$f_5=20$, $o_5=22$\n- 第6天：$f_6=9$, $o_6=7$\n- 第7天：$f_7=11$, $o_7=9$\n- 第8天：$f_8=6$, $o_8=12$\n- 第9天：$f_9=14$, $o_9=16$\n- 第10天：$f_{10}=7$, $o_{10}=0$\n- 第11天：$f_{11}=10$, $o_{11}=9$\n- 第12天：$f_{12}=3$, $o_{12}=2$\n- 第13天：$f_{13}=13$, $o_{13}=4$\n- 第14天：$f_{14}=2$, $o_{14}=0$\n- 第15天：$f_{15}=18$, $o_{15}=19$\n- 第16天：$f_{16}=0$, $o_{16}=0$\n- 第17天：$f_{17}=16$, $o_{17}=14$\n- 第18天：$f_{18}=5$, $o_{18}=6$\n- 第19天：$f_{19}=9$, $o_{19}=15$\n- 第20天：$f_{20}=10$, $o_{20}=10$\n- 第21天：$f_{21}=11$, $o_{21}=8$\n- 第22天：$f_{22}=1$, $o_{22}=0$\n- 第23天：$f_{23}=7$, $o_{23}=13$\n- 第24天：$f_{24}=13$, $o_{24}=11$\n\n任务：\n1. 应用条件概率的基本原理于二元预报和观测指标，使用 $2\\times 2$ 列联表的计数和样本量 $N$ 为命中率、空报率、基础率和精确率提供精确定义。\n2. 以10毫米为阈值对预报和观测数据进行二元分类，构建包含命中、空报、漏报和正确否定计数的 $2\\times 2$ 列联表。\n3. 根据您所定义的量，计算该预报系统的Peirce技巧评分（也称为真实技巧统计量）。\n\n将Peirce技巧评分的最终数值答案表示为四舍五入到四位有效数字的小数。",
            "solution": "该问题经确认为具有科学依据、提法明确、客观且完整。它代表了气象预报检验中的一个标准练习。我们开始解题。\n\n解题过程按题目要求分为三个部分。\n\n### 第1步：检验指标的定义\n\n设二元事件用 $E$ 表示。当24小时累积降水量大于或等于10毫米阈值时，事件发生。对于每个预报-观测对 $(f_i, o_i)$，我们定义二元指示变量：\n- $I_{f,i} = 1$ 如果事件被预报 ($f_i \\ge 10$)，否则 $I_{f,i} = 0$ ($f_i  10$)。\n- $I_{o,i} = 1$ 如果事件被观测到 ($o_i \\ge 10$)，否则 $I_{o,i} = 0$ ($o_i  10$)。\n\n检验基于 $N$ 天样本中每对预报-观测的四种可能结果，这些结果汇总在一个 $2 \\times 2$ 列联表中。每个类别的计数如下：\n- **命中 ($a$)**: 事件被正确预报的次数。$a = \\sum_{i=1}^{N} I_{f,i} I_{o,i}$。\n- **空报 ($b$)**: 事件被预报但未发生的次数。$b = \\sum_{i=1}^{N} I_{f,i} (1 - I_{o,i})$。\n- **漏报 ($c$)**: 事件发生但未被预报的次数。$c = \\sum_{i=1}^{N} (1 - I_{f,i}) I_{o,i}$。\n- **正确否定 ($d$)**: 事件未发生且被正确预报为不发生的次数。$d = \\sum_{i=1}^{N} (1 - I_{f,i}) (1 - I_{o,i})$。\n\n总个案数为 $N = a + b + c + d$。\n\n使用这些基本计数，我们可以根据条件概率原理定义所要求的检验指标：\n\n1.  **命中率 ($H$)**: 也称为探测概率（POD），是在事件发生的条件下，预报为“是”的条件概率。它是被正确预报的观测事件所占的比例。\n    $$H = P(\\text{预报是} | \\text{观测是}) = \\frac{P(\\text{预报是} \\cap \\text{观测是})}{P(\\text{观测是})} = \\frac{a/N}{(a+c)/N} = \\frac{a}{a+c}$$\n\n2.  **空报率 ($F$)**: 也称为虚警概率（POFD），是在事件未发生的条件下，预报为“是”的条件概率。它是被错误预报为事件的非事件所占的比例。\n    $$F = P(\\text{预报是} | \\text{观测否}) = \\frac{P(\\text{预报是} \\cap \\text{观测否})}{P(\\text{观测否})} = \\frac{b/N}{(b+d)/N} = \\frac{b}{b+d}$$\n\n3.  **基础率 ($S$)**: 也称为样本气候频率，是事件在样本中发生的无条件概率。它是观测到事件的个案占总个案的比例。\n    $$S = P(\\text{观测是}) = \\frac{a+c}{N}$$\n\n4.  **精确率**: 也称为成功率，是在预报事件发生的条件下，事件确实发生的条件概率。它是正确的“是”预报所占的比例。\n    $$\\text{精确率} = P(\\text{观测是} | \\text{预报是}) = \\frac{P(\\text{观测是} \\cap \\text{预报是})}{P(\\text{预报是})} = \\frac{a/N}{(a+b)/N} = \\frac{a}{a+b}$$\n\n### 第2步：构建列联表\n\n降水阈值为10毫米。我们将 $N=24$ 个预报-观测对 $(f_i, o_i)$ 中的每一个分类到四个类别之一：命中、空报、漏报或正确否定。\n\n- 第1天：($12, 13$) $\\implies f_1 \\ge 10, o_1 \\ge 10 \\implies$ **命中**\n- 第2天：($8, 0$) $\\implies f_2  10, o_2  10 \\implies$ **正确否定**\n- 第3天：($15, 5$) $\\implies f_3 \\ge 10, o_3  10 \\implies$ **空报**\n- 第4天：($4, 11$) $\\implies f_4  10, o_4 \\ge 10 \\implies$ **漏报**\n- 第5天：($20, 22$) $\\implies f_5 \\ge 10, o_5 \\ge 10 \\implies$ **命中**\n- 第6天：($9, 7$) $\\implies f_6  10, o_6  10 \\implies$ **正确否定**\n- 第7天：($11, 9$) $\\implies f_7 \\ge 10, o_7  10 \\implies$ **空报**\n- 第8天：($6, 12$) $\\implies f_8  10, o_8 \\ge 10 \\implies$ **漏报**\n- 第9天：($14, 16$) $\\implies f_9 \\ge 10, o_9 \\ge 10 \\implies$ **命中**\n- 第10天：($7, 0$) $\\implies f_{10}  10, o_{10}  10 \\implies$ **正确否定**\n- 第11天：($10, 9$) $\\implies f_{11} \\ge 10, o_{11}  10 \\implies$ **空报**\n- 第12天：($3, 2$) $\\implies f_{12}  10, o_{12}  10 \\implies$ **正确否定**\n- 第13天：($13, 4$) $\\implies f_{13} \\ge 10, o_{13}  10 \\implies$ **空报**\n- 第14天：($2, 0$) $\\implies f_{14}  10, o_{14}  10 \\implies$ **正确否定**\n- 第15天：($18, 19$) $\\implies f_{15} \\ge 10, o_{15} \\ge 10 \\implies$ **命中**\n- 第16天：($0, 0$) $\\implies f_{16}  10, o_{16}  10 \\implies$ **正确否定**\n- 第17天：($16, 14$) $\\implies f_{17} \\ge 10, o_{17} \\ge 10 \\implies$ **命中**\n- 第18天：($5, 6$) $\\implies f_{18}  10, o_{18}  10 \\implies$ **正确否定**\n- 第19天：($9, 15$) $\\implies f_{19}  10, o_{19} \\ge 10 \\implies$ **漏报**\n- 第20天：($10, 10$) $\\implies f_{20} \\ge 10, o_{20} \\ge 10 \\implies$ **命中**\n- 第21天：($11, 8$) $\\implies f_{21} \\ge 10, o_{21}  10 \\implies$ **空报**\n- 第22天：($1, 0$) $\\implies f_{22}  10, o_{22}  10 \\implies$ **正确否定**\n- 第23天：($7, 13$) $\\implies f_{23}  10, o_{23} \\ge 10 \\implies$ **漏报**\n- 第24天：($13, 11$) $\\implies f_{24} \\ge 10, o_{24} \\ge 10 \\implies$ **命中**\n\n统计这些结果：\n- 命中 ($a$) = $7$\n- 空报 ($b$) = $5$\n- 漏报 ($c$) = $4$\n- 正确否定 ($d$) = $8$\n\n总计数为 $a+b+c+d = 7+5+4+8 = 24$，与样本量 $N$ 相符。得到的 $2 \\times 2$ 列联表如下：\n$$\n\\begin{array}{c|cc|c}\n\\multicolumn{2}{c}{}  \\multicolumn{2}{c}{\\text{观测}} \\\\\n\\multicolumn{2}{c}{}  \\text{是 (事件)}  \\text{否 (非事件)} \\\\\n\\cline{2-4}\n\\text{预报}  \\text{是}  a=7  b=5 \\\\\n  \\text{否}  c=4  d=8 \\\\\n\\hline\n\\end{array}\n$$\n\n### 第3步：计算Peirce技巧评分\n\nPeirce技巧评分（PSS），也称为真实技巧统计量（TSS），定义为命中率（$H$）与空报率（$F$）之差：\n$$ \\text{PSS} = H - F $$\n使用第1步中的定义和第2步中的列联表计数：\n$$ \\text{PSS} = \\frac{a}{a+c} - \\frac{b}{b+d} $$\n代入数值 $a=7$, $b=5$, $c=4$ 和 $d=8$：\n$$ H = \\frac{7}{7+4} = \\frac{7}{11} $$\n$$ F = \\frac{5}{5+8} = \\frac{5}{13} $$\n因此，Peirce技巧评分为：\n$$ \\text{PSS} = \\frac{7}{11} - \\frac{5}{13} $$\n为了计算精确值，我们找到公分母，即 $11 \\times 13 = 143$：\n$$ \\text{PSS} = \\frac{7 \\times 13}{143} - \\frac{5 \\times 11}{143} = \\frac{91 - 55}{143} = \\frac{36}{143} $$\n为了得到最终的数值答案，我们计算这个分数的小数值：\n$$ \\text{PSS} = \\frac{36}{143} \\approx 0.25174825... $$\n题目要求答案四舍五入到四位有效数字。前四位有效数字是 $2, 5, 1, 7$。第五位数字是 $4$，所以我们不向上取整。\n$$ \\text{PSS} \\approx 0.2517 $$",
            "answer": "$$\\boxed{0.2517}$$"
        },
        {
            "introduction": "现代天气预报已经从单一的确定性预报转向了集合概率预报。评估这些概率预报需要专门的度量指标，而连续分级概率评分（Continuous Ranked Probability Score, CRPS）是其中评估连续变量集合预报总体质量的核心工具 。在本练习中，您将从 CRPS 的理论定义出发，推导并实现一个计算效率高的算法。这项实践将同时提升您在检验理论和计算科学方面的技能。",
            "id": "4044072",
            "problem": "给定一个单一连续气象变量的集合预报，它被建模为一个包含 $M$ 个等可能集合成员的有限集合 $\\{x_1,\\ldots,x_M\\}$，以及一个验证观测值 $y \\in \\mathbb{R}$。该集合预报引出一个经验分布函数（EDF）$F_M(z)$，其定义为 $F_M(z) = \\frac{1}{M}\\sum_{i=1}^M \\mathbf{1}\\{x_i \\le z\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 表示指示函数。对于一个累积分布函数为 $F$ 的预报和一个观测值 $y$，连续分级概率评分（CRPS）从第一性原理定义为\n$$\n\\mathrm{CRPS}(F,y) = \\int_{-\\infty}^{\\infty} \\left(F(z) - \\mathbf{1}\\{z \\ge y\\}\\right)^2 \\, \\mathrm{d}z.\n$$\n请仅从上述定义以及关于指示函数、积分和求和的基本事实出发，推导出一个在集合成员排序后能以 $O(M)$ 时间复杂度计算 $\\mathrm{CRPS}(F_M,y)$ 的算法。您可以将集合成员 $\\{x_i\\}$ 按升序排序作为预处理步骤，且只需将排序后的计算部分计入 $O(M)$ 复杂度要求。您的算法必须能接受任何实值集合和任何实值观测，包括 $M=1$、集合中存在重复值以及观测值在集合范围之外等边界情况。\n\n您的程序必须实现所推导的算法，并为以下每个测试用例计算 CRPS。变量代表风速，因此所有 CRPS 输出必须以米/秒（m/s）为单位，表示为十进制浮点数。为最终输出，将每个 CRPS 四舍五入到六位小数。\n\n测试套件：\n- 用例 A（通用、未排序输入）：$M=7$，集合 $\\{12.3, 10.1, 15.7, 9.8, 14.2, 13.0, 11.5\\}$，观测值 $y=12.0$。\n- 用例 B（退化集合）：$M=1$，集合 $\\{10.0\\}$，观测值 $y=12.0$。\n- 用例 C（观测值低于集合范围）：$M=4$，集合 $\\{3.0, 4.5, 5.1, 6.2\\}$，观测值 $y=1.0$。\n- 用例 D（观测值高于集合范围）：$M=4$，集合 $\\{3.0, 4.5, 5.1, 6.2\\}$，观测值 $y=8.0$。\n- 用例 E（集合中存在重复值）：$M=5$，集合 $\\{5.0, 5.0, 5.0, 7.0, 9.0\\}$，观测值 $y=6.0$。\n- 用例 F（较大集合，显式确定性构造）：$M=100$，集合成员由 $x_i = 0.5\\,i + \\sin(i)$ 定义，其中 $i=1,2,\\ldots,100$，观测值 $y=30.0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用例 A–F 的六个 CRPS 值，四舍五入到六位小数，形式为用方括号括起来的逗号分隔列表（例如，“[v_A,v_B,v_C,v_D,v_E,v_F]”）。这些值必须以米/秒（m/s）为单位，并表示为十进制浮点数。",
            "solution": "我们从集合预报的经验分布函数（EDF）和连续分级概率评分（CRPS）的基础定义开始。设集合成员为 $\\{x_1,\\ldots,x_M\\}$，观测值为 $y$。EDF 定义为 $F_M(z) = \\frac{1}{M} \\sum_{i=1}^M \\mathbf{1}\\{x_i \\le z\\}$。对于一个累积分布函数 $F$ 和一个观测值 $y$，CRPS定义为\n$$\n\\mathrm{CRPS}(F,y) = \\int_{-\\infty}^{\\infty} \\left(F(z) - \\mathbf{1}\\{z \\ge y\\}\\right)^2 \\, \\mathrm{d}z.\n$$\n我们的目标是：推导出一个计算效率高的 $\\mathrm{CRPS}(F_M,y)$ 公式，并设计一个在对集合排序后能以 $O(M)$ 时间执行的算法。\n\n**基于原理的推导**\n\n1.  一个在验证理论中标准且更易于处理的方法是，利用以下恒等式将CRPS表示为期望绝对差：\n    $$\n    \\mathrm{CRPS}(F,y) = \\mathbb{E}|X - y| - \\tfrac{1}{2}\\,\\mathbb{E}|X - X'|,\n    $$\n    其中 $X$ 和 $X'$ 是服从累积分布函数 $F$ 的独立同分布随机变量。\n\n2.  将此恒等式应用于由集合预报定义的经验分布函数 $F_M$，其中的期望值是在集合成员 $\\{x_1,\\ldots,x_M\\}$ 上的平均值（每点权重为 $1/M$）。因此：\n    $$\n    \\mathbb{E}|X - y| = \\frac{1}{M}\\sum_{i=1}^M |x_i - y|,\n    $$\n    以及\n    $$\n    \\mathbb{E}|X - X'| = \\frac{1}{M^2}\\sum_{i=1}^M\\sum_{j=1}^M |x_i - x_j|.\n    $$\n    于是，\n    $$\n    \\mathrm{CRPS}(F_M,y) = \\frac{1}{M}\\sum_{i=1}^M |x_i - y| - \\frac{1}{2M^2}\\sum_{i=1}^M\\sum_{j=1}^M |x_i - x_j|.\n    $$\n    这个公式是精确的。直接计算双重求和项需要 $O(M^2)$ 的时间复杂度，对于大的 $M$ 来说效率低下。\n\n3.  为了实现 $O(M)$ 的计算效率，我们需要简化双重求和项。首先，对集合成员进行升序排序，得到 $x_{(1)} \\le x_{(2)} \\le \\cdots \\le x_{(M)}$。然后，利用排序后的顺序，双重求和可以被展开和重新组合：\n    $$\n    \\sum_{i=1}^M\\sum_{j=1}^M |x_{(i)} - x_{(j)}| = 2 \\sum_{i=1}^M \\sum_{j=1}^{i-1} (x_{(i)} - x_{(j)})\n    $$\n    通过巧妙地重新排列求和，可以证明：\n    $$\n    \\sum_{i=1}^M \\sum_{j=1}^{i-1} (x_{(i)} - x_{(j)}) = \\sum_{i=1}^M (i-1)x_{(i)} - \\sum_{i=1}^M (M-i)x_{(i)} = \\sum_{i=1}^M (2i - M - 1)x_{(i)}\n    $$\n    将此结果代回，我们得到：\n    $$\n    \\frac{1}{2M^2}\\sum_{i=1}^M\\sum_{j=1}^M |x_i - x_j| = \\frac{1}{M^2}\\sum_{i=1}^M (2i - M - 1)x_{(i)}\n    $$\n\n4.  最终，我们得到了计算效率高的CRPS公式：\n    $$\n    \\mathrm{CRPS}(F_M, y) = \\frac{1}{M}\\sum_{i=1}^M |x_i - y| - \\frac{1}{M^2}\\sum_{i=1}^M (2i - M - 1)x_{(i)}\n    $$\n    这个公式的计算流程如下：\n    -   **预处理**：对集合成员进行排序，得到 $x_{(1)}, \\ldots, x_{(M)}$。这是一个 $O(M \\log M)$ 的步骤。\n    -   **第一项**：计算每个集合成员与观测值 $y$ 的绝对差之和，然后除以 $M$。这是一个 $O(M)$ 的步骤。\n    -   **第二项**：计算排序后的集合成员的加权和，其中第 $i$ 个成员的权重为 $2i - M - 1$。这也是一个 $O(M)$ 的步骤。\n    -   **最终结果**：将第一项减去第二项得到最终的CRPS值。\n\n    因此，在排序之后，CRPS的计算复杂度为 $O(M)$。提供的Python代码正是实现了这一高效算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef crps_ensemble(x, y):\n    \"\"\"\n    Compute CRPS for an equally weighted ensemble forecast with members x and observation y.\n    The algorithm is O(M) after sorting:\n    CRPS = (1/M) * sum |x_i - y| - (1/M^2) * sum_{k=1}^M (2k - M - 1) * x_(k),\n    where x_(k) are the sorted ensemble members.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    M = x.size\n    if M == 0:\n        raise ValueError(\"Ensemble must contain at least one member.\")\n    # Sort the ensemble for the second term\n    x_sorted = np.sort(x)\n    # First term: average absolute difference to the observation (no need to be sorted)\n    sum_abs_y = np.sum(np.abs(x - y))\n    term1 = sum_abs_y / M\n    # Second term: use sorted order statistics coefficients\n    k = np.arange(1, M + 1, dtype=float)\n    coeffs = 2 * k - M - 1  # (2k - M - 1)\n    sum_weighted_sorted = np.dot(coeffs, x_sorted)\n    term2 = sum_weighted_sorted / (M ** 2)\n    crps = term1 - term2\n    return crps\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # All outputs are in meters per second (m/s), rounded to six decimals.\n    test_cases = [\n        # Case A: general, unsorted input\n        ([12.3, 10.1, 15.7, 9.8, 14.2, 13.0, 11.5], 12.0),\n        # Case B: degenerate ensemble M=1\n        ([10.0], 12.0),\n        # Case C: observation below ensemble range\n        ([3.0, 4.5, 5.1, 6.2], 1.0),\n        # Case D: observation above ensemble range\n        ([3.0, 4.5, 5.1, 6.2], 8.0),\n        # Case E: duplicates in ensemble\n        ([5.0, 5.0, 5.0, 7.0, 9.0], 6.0),\n        # Case F: larger deterministic ensemble\n        ([(0.5 * i) + np.sin(i) for i in range(1, 101)], 30.0),\n    ]\n\n    results = []\n    for x, y in test_cases:\n        val = crps_ensemble(x, y)\n        # Round to six decimal places\n        results.append(f\"{val:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "检验诸如降水场之类的空间预报带来了独特的挑战，像均方根误差（RMSE）这样简单的逐点比较指标往往无法充分应对，甚至会导致“双重惩罚”问题。本练习将介绍一种先进的、基于对象的检验方法——结构-振幅-位置（Structure-Amplitude-Location, SAL）法 。通过分别评估预报特征在结构、振幅和位置上的误差，SAL 提供了一种更具物理意义的评估方式。通过在合成的降水场上实现 SAL 并与 RMSE 进行对比，您将学会诊断不同类型的预报误差，并体会传统检验方法与基于特征的检验方法在认知论上的差异。",
            "id": "4044117",
            "problem": "考虑代表数值天气预报的预报场和用于验证的分析场的二维网格化降水场。设预报场用 $F:\\Omega \\to \\mathbb{R}_{\\ge 0}$ 表示，观测/分析场用 $O:\\Omega \\to \\mathbb{R}_{\\ge 0}$ 表示，其中 $\\Omega = \\{0,1,\\ldots,n_x-1\\} \\times \\{0,1,\\ldots,n_y-1\\}$ 为网格单元中心的索引。所有降水强度都必须视为单位为毫米/小时（mm/h）的非负标量。目标是计算两个验证指标，并用它们来推断误差的性质：\n\n1. 逐像素的均方根误差（RMSE），根据函数空间中欧几里得距离的第一性原理定义。\n2. 基于对象的结构–振幅–位置（SAL）三元组，旨在通过质量和矩的构造来评估降水场的空间和结构特征。\n\n基本基础和定义：\n\n- 在 $\\Omega$ 上，场 $X$ 的经验平均值为 $\\bar{X} = \\frac{1}{|\\Omega|} \\sum_{(i,j)\\in\\Omega} X_{i,j}$。\n- 逐像素的均方根误差源于 $L^2$ 距离：$\\mathrm{RMSE}(F,O) = \\sqrt{\\frac{1}{|\\Omega|} \\sum_{(i,j)\\in\\Omega} \\left(F_{i,j} - O_{i,j}\\right)^2}$。RMSE 必须以毫米/小时（mm/h）为单位报告，并四舍五入到三位小数。\n- 相对于 $\\Omega$，场 $X$ 的质心为 $\\mathbf{x}_X = \\left(\\frac{\\sum_{(i,j)\\in\\Omega} X_{i,j} \\, i}{\\sum_{(i,j)\\in\\Omega} X_{i,j}}, \\frac{\\sum_{(i,j)\\in\\Omega} X_{i,j} \\, j}{\\sum_{(i,j)\\in\\Omega} X_{i,j}}\\right)$，前提是 $\\sum_{(i,j)\\in\\Omega} X_{i,j}  0$。如果 $\\sum_{(i,j)\\in\\Omega} X_{i,j} = 0$，则质心未定义，必须按照下述方式明确处理。\n- 用于归一化位置距离的区域直径为 $D = \\sqrt{(n_x - 1)^2 + (n_y - 1)^2}$。\n\n对象识别与缩放体积：\n\n- 为识别场 $X$ 中的连续降水对象，定义一个阈值 $t$ 为 $t = \\max\\left(0.1, \\, 0.15 \\cdot q_{95}\\right)$，其中 $q_{95}$ 是来自 $F$ 和 $O$ 两个场中所有强度值的并集的第 $95$ 百分位数。然后构造二元掩码 $M_X = \\{(i,j)\\in\\Omega : X_{i,j} \\ge t\\}$。\n- $X$ 中的一个降水对象是 $M_X$ 中的一个最大连通分量，使用 $4$ 邻域连通性（上、下、左、右相邻）。\n- 对于 $X$ 中的每个对象 $j$，定义其最大强度 $R_{j,\\max} = \\max_{(i,j)\\in\\text{obj}_j} X_{i,j}$ 和其对象总和 $V_j = \\sum_{(i,j)\\in\\text{obj}_j} X_{i,j}$。对象 $j$ 的缩放体积为 $v_j = \\frac{V_j}{R_{j,\\max}}$。该场的缩放体积总和为 $S_X^\\star = \\sum_j v_j$。如果没有对象（即 $M_X$ 为空），则 $S_X^\\star = 0$。\n\n需要计算的 SAL 分量：\n\n- 振幅 $A$ 是由经验平均值构造的归一化平均差：如果 $\\bar{F} + \\bar{O}  0$，则 $A = \\frac{\\bar{F} - \\bar{O}}{\\frac{1}{2}(\\bar{F} + \\bar{O})}$；如果 $\\bar{F} = \\bar{O} = 0$，则 $A = 0$。\n- 位置 $L$ 是两项之和 $L = L_1 + L_2$：\n  - 如果两个质心都存在，则 $L_1 = \\frac{\\|\\mathbf{x}_F - \\mathbf{x}_O\\|_2}{D}$；如果两个场都为空（总质量均为零），则 $L_1 = 0$；如果只有一个场为空，则设 $L_1 = 1$。\n  - $L_2 = \\left| r_F - r_O \\right|$，其中 $r_X = \\left(\\frac{\\sum_{(i,j)\\in\\Omega} X_{i,j} \\, \\|\\mathbf{x}_{i,j} - \\mathbf{x}_X\\|_2}{\\sum_{(i,j)\\in\\Omega} X_{i,j}}\\right)\\big/ D$ 是 $X$ 围绕其质心的归一化一阶径向矩（离散度），且 $\\mathbf{x}_{i,j} = (i,j)$。如果两个场都为空，则设 $r_F = r_O = 0$。如果只有一个场为空，则将空场的离散度设为 $0$，非空场的离散度按上述公式计算。\n- 结构 $S$ 是缩放体积总和的归一化差异：如果 $S_F^\\star + S_O^\\star  0$，则 $S = \\frac{S_F^\\star - S_O^\\star}{\\frac{1}{2}(S_F^\\star + S_O^\\star)}$；如果 $S_F^\\star = S_O^\\star = 0$，则 $S = 0$。\n\n基于 SAL 与 RMSE 的认知分类：\n\n- 定义阈值 $a_{\\mathrm{th}} = 0.5$、$s_{\\mathrm{th}} = 0.5$ 和 $l_{\\mathrm{th}} = 0.3$（均为无量纲）。\n- 对每个测试用例，计算三个布尔指标：\n  - 位移主导误差：$\\mathrm{disp} = \\left(|A|  a_{\\mathrm{th}}\\right) \\wedge \\left(|S|  s_{\\mathrm{th}}\\right) \\wedge \\left(L  l_{\\mathrm{th}}\\right)$。\n  - 振幅偏差主导误差：$\\mathrm{amp} = \\left(|A|  a_{\\mathrm{th}}\\right) \\wedge \\left(L  l_{\\mathrm{th}}\\right)$。\n  - 结构差异主导误差：$\\mathrm{struc} = \\left(|S|  s_{\\mathrm{th}}\\right) \\wedge \\left(L  l_{\\mathrm{th}}\\right) \\wedge \\left(|A|  a_{\\mathrm{th}}\\right)$。\n\n测试套件与要求输出：\n\n在 $n_x = n_y = 5$ 的 $\\Omega$ 上使用以下 $(F,O)$ 对的测试套件。所有条目单位均为毫米/小时（mm/h）。\n\n- 测试用例 1（理想情况，近乎完美匹配）：\n  - $O_1 =$ \n    $\\begin{bmatrix}\n    0  0  1  0  0 \\\\\n    0  2  3  2  0 \\\\\n    1  3  5  3  1 \\\\\n    0  2  3  2  0 \\\\\n    0  0  1  0  0\n    \\end{bmatrix}$,\n  - $F_1 = O_1$。\n- 测试用例 2（均匀振幅偏差，结构和位置相同）：\n  - $O_2 = O_1$,\n  - $F_2 = 1.5 \\cdot O_1$。\n- 测试用例 3（纯位移，振幅和结构相似）：\n  - $O_3 = O_1$,\n  - $F_3$ 是 $O_1$ 向右平移一个网格单元并以零填充：\n    $\\begin{bmatrix}\n    0  0  0  1  0 \\\\\n    0  0  2  3  2 \\\\\n    0  1  3  5  3 \\\\\n    0  0  2  3  2 \\\\\n    0  0  0  1  0\n    \\end{bmatrix}$。\n- 测试用例 4（结构差异：一个细长对象对两个紧凑对象；振幅相等）：\n  - $O_4 =$ \n    $\\begin{bmatrix}\n    0  0  0  0  0 \\\\\n    0  0  4  0  0 \\\\\n    0  0  4  0  0 \\\\\n    0  0  4  0  0 \\\\\n    0  0  0  0  0\n    \\end{bmatrix}$,\n  - $F_4 =$ \n    $\\begin{bmatrix}\n    0  0  0  0  0 \\\\\n    0  3  0  3  0 \\\\\n    0  3  0  3  0 \\\\\n    0  0  0  0  0 \\\\\n    0  0  0  0  0\n    \\end{bmatrix}$。\n- 测试用例 5（边界条件：两者均为空）：\n  - $O_5 =$ 零 $5\\times 5$ 矩阵，\n  - $F_5 =$ 零 $5\\times 5$ 矩阵。\n- 测试用例 6（边界条件：预报非空，观测为空）：\n  - $O_6 =$ 零 $5\\times 5$ 矩阵，\n  - $F_6 = O_1$。\n\n最终输出格式：\n\n您的程序应生成单行输出，按顺序为每个测试用例包含一个含有七个条目的列表：$[A,S,L,\\mathrm{RMSE},\\mathrm{disp},\\mathrm{amp},\\mathrm{struc}]$，其中 $A$、$S$ 和 $L$ 是四舍五入到三位小数的无量纲浮点数，$\\mathrm{RMSE}$ 是以毫米/小时（mm/h）为单位并四舍五入到三位小数的浮点数，三个布尔值是上面定义的认知分类。将六个测试用例的结果聚合到一个顶级列表中，以逗号分隔并用方括号括起来打印；例如，格式应严格为 $[[A_1,S_1,L_1,\\mathrm{RMSE}_1,\\mathrm{disp}_1,\\mathrm{amp}_1,\\mathrm{struc}_1],[A_2,\\ldots],\\ldots]$，不含任何附加文本。",
            "solution": "本问题的解决方案在于根据问题中提供的详细定义，系统地实现均方根误差（RMSE）和结构-振幅-位置（SAL）指标的计算。下面的步骤概述了实施该解决方案的逻辑，该逻辑与提供的Python代码中的实现相对应。\n\n### 步骤1：计算均方根误差 (RMSE)\n这是最直接的计算。根据定义，RMSE是预报场 $F$ 和观测场 $O$ 之间逐个网格点差值平方的均值的平方根。\n$$\n\\mathrm{RMSE}(F,O) = \\sqrt{\\frac{1}{N} \\sum_{i,j} (F_{i,j} - O_{i,j})^2}\n$$\n其中 $N$ 是网格点的总数。这可以通过对差值矩阵进行元素级操作来高效计算。\n\n### 步骤2：计算振幅分量 (A)\n振幅分量 $A$ 衡量的是整个区域内总降水量的系统性偏差。它被定义为预报和观测场平均值之间的归一化差异。\n$$\nA = \\frac{\\bar{F} - \\bar{O}}{\\frac{1}{2}(\\bar{F} + \\bar{O})}\n$$\n计算时需要注意分母为零的边缘情况（即两个场都为空），此时 $A=0$。\n\n### 步骤3：计算位置分量 (L)\n位置分量 $L$ 评估预报和观测降水模式在空间上的错位和分布范围的差异。它由两部分组成：$L = L_1 + L_2$。\n1.  **$L_1$ - 质心距离**：首先，需要计算每个场的质心（一阶矩），即降水强度的加权平均位置。然后，$L_1$ 是两个质心之间欧几里得距离相对于区域对角线长度 $D$ 的归一化值。这衡量了降水质量中心的整体位移。对于空场等边缘情况，需要遵循问题中定义的特定规则（例如，一个场为空时，$L_1=1$）。\n2.  **$L_2$ - 离散度差异**：其次，计算每个场围绕其质心的归一化加权平均距离（离散度，$r_X$）。这衡量了降水模式的“伸展”或“紧凑”程度。$L_2$ 是两个场离散度之差的绝对值。空场的离散度定义为0。\n\n### 步骤4：计算结构分量 (S)\n结构分量 $S$ 通过比较降水“对象”的形状和大小来评估结构相似性。\n1.  **对象识别**：首先，根据预报场和观测场中所有非零值的第95百分位数确定一个阈值 $t$。所有值大于或等于 $t$ 的相连网格点（使用4邻域连通性）被识别为一个“对象”。\n2.  **缩放体积**：对于每个识别出的对象，计算其“缩放体积” $v_j = V_j / R_{j,\\max}$，其中 $V_j$ 是对象内降水的总和，$R_{j,\\max}$ 是该对象的最大降水强度。这个量可以衡量对象的“平坦度”（一个又大又平的对象会有较大的缩放体积）。\n3.  **S的计算**：计算每个场中所有对象的缩放体积之和（$S_F^\\star$ 和 $S_O^\\star$）。结构分量 $S$ 是这两个总和的归一化差异。\n$$\nS = \\frac{S_F^\\star - S_O^\\star}{\\frac{1}{2}(S_F^\\star + S_O^\\star)}\n$$\n这可以判断预报的降水结构总体上是比观测更“平坦”还是更“尖锐”。\n\n### 步骤5：认知分类\n最后，根据计算出的 $A, S, L$ 值和问题中给定的阈值（$a_{\\mathrm{th}}, s_{\\mathrm{th}}, l_{\\mathrm{th}}$），应用布尔逻辑来判断误差主要是由位移、振幅还是结构差异主导。例如，一个位移主导的误差（`disp=True`）通常具有较小的 $A$ 和 $S$ 值，但较大的 $L$ 值。\n\n通过执行这些步骤，我们可以为每个测试用例生成包含七个度量值的列表，从而对预报误差的性质进行全面的诊断。",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label, find_objects, maximum, sum as nd_sum\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    # Test case definitions\n    O1 = np.array([\n        [0, 0, 1, 0, 0],\n        [0, 2, 3, 2, 0],\n        [1, 3, 5, 3, 1],\n        [0, 2, 3, 2, 0],\n        [0, 0, 1, 0, 0]\n    ], dtype=float)\n    \n    F1 = O1.copy()\n    \n    O2 = O1.copy()\n    F2 = 1.5 * O1\n    \n    O3 = O1.copy()\n    F3 = np.array([\n        [0, 0, 0, 1, 0],\n        [0, 0, 2, 3, 2],\n        [0, 1, 3, 5, 3],\n        [0, 0, 2, 3, 2],\n        [0, 0, 0, 1, 0]\n    ], dtype=float)\n    \n    O4 = np.array([\n        [0, 0, 0, 0, 0],\n        [0, 0, 4, 0, 0],\n        [0, 0, 4, 0, 0],\n        [0, 0, 4, 0, 0],\n        [0, 0, 0, 0, 0]\n    ], dtype=float)\n    F4 = np.array([\n        [0, 0, 0, 0, 0],\n        [0, 3, 0, 3, 0],\n        [0, 3, 0, 3, 0],\n        [0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0]\n    ], dtype=float)\n    \n    O5 = np.zeros((5, 5), dtype=float)\n    F5 = np.zeros((5, 5), dtype=float)\n    \n    O6 = np.zeros((5, 5), dtype=float)\n    F6 = O1.copy()\n\n    test_cases = [\n        (F1, O1),\n        (F2, O2),\n        (F3, O3),\n        (F4, O4),\n        (F5, O5),\n        (F6, O6),\n    ]\n\n    results = []\n    for F, O in test_cases:\n        case_result = compute_all_metrics(F, O)\n        results.append(case_result)\n\n    # Formatting the output string\n    output_str = \"[\" + \",\".join([str(res) for res in results]) + \"]\"\n    print(output_str)\n\ndef compute_all_metrics(F, O):\n    \"\"\"\n    Computes all specified metrics for a given Forecast (F) and Observation (O) pair.\n    \"\"\"\n    nx, ny = F.shape\n    D = np.sqrt((nx - 1)**2 + (ny - 1)**2)\n    \n    # Grid coordinates for moment calculations\n    j_grid, i_grid = np.meshgrid(np.arange(ny), np.arange(nx))\n\n    # Calculate individual metrics\n    rmse = np.sqrt(np.mean((F - O)**2))\n    A = compute_A(F, O)\n    L = compute_L(F, O, i_grid, j_grid, D)\n    S = compute_S(F, O)\n    \n    # Epistemic classification\n    a_th, s_th, l_th = 0.5, 0.5, 0.3\n    disp = (abs(A)  a_th) and (abs(S)  s_th) and (L > l_th)\n    amp = (abs(A) > a_th) and (L  l_th)\n    struc = (abs(S) > s_th) and (L  l_th) and (abs(A)  a_th)\n    \n    return [\n        round(A, 3), \n        round(S, 3), \n        round(L, 3), \n        round(rmse, 3), \n        disp, \n        amp, \n        struc\n    ]\n\ndef compute_A(F, O):\n    \"\"\"Computes the Amplitude component A.\"\"\"\n    mean_F = np.mean(F)\n    mean_O = np.mean(O)\n    denominator = 0.5 * (mean_F + mean_O)\n    if denominator > 0:\n        return (mean_F - mean_O) / denominator\n    return 0.0\n\ndef get_com(X, i_grid, j_grid):\n    \"\"\"Computes the center of mass for a field.\"\"\"\n    total_mass = np.sum(X)\n    if total_mass == 0:\n        return None\n    com_i = np.sum(X * i_grid) / total_mass\n    com_j = np.sum(X * j_grid) / total_mass\n    return np.array([com_i, com_j])\n\ndef get_dispersion(X, com, i_grid, j_grid, D):\n    \"\"\"Computes the normalized dispersion r_X.\"\"\"\n    total_mass = np.sum(X)\n    if total_mass == 0:\n        return 0.0\n    distances = np.sqrt((i_grid - com[0])**2 + (j_grid - com[1])**2)\n    radial_moment = np.sum(X * distances)\n    return (radial_moment / total_mass) / D\n\ndef compute_L(F, O, i_grid, j_grid, D):\n    \"\"\"Computes the Location component L.\"\"\"\n    total_mass_F = np.sum(F)\n    total_mass_O = np.sum(O)\n    \n    com_F = get_com(F, i_grid, j_grid)\n    com_O = get_com(O, i_grid, j_grid)\n    \n    # Calculate L1\n    if total_mass_F == 0 and total_mass_O == 0:\n        L1 = 0.0\n    elif total_mass_F == 0 or total_mass_O == 0:\n        L1 = 1.0\n    else:\n        L1 = np.linalg.norm(com_F - com_O) / D\n        \n    # Calculate L2\n    # The problem specifies that an empty field's dispersion is 0.\n    # get_dispersion already handles this.\n    # If a field is non-empty but the other is, we need to compute dispersion\n    # relative to its own CoM.\n    \n    # Effective CoM for dispersion calculation: if a field is empty,\n    # its CoM doesn't matter as its dispersion is 0.\n    r_F = get_dispersion(F, com_F if com_F is not None else np.array([0,0]), i_grid, j_grid, D)\n    r_O = get_dispersion(O, com_O if com_O is not None else np.array([0,0]), i_grid, j_grid, D)\n    L2 = abs(r_F - r_O)\n    \n    return L1 + L2\n\ndef compute_S_star(X, t):\n    \"\"\"Computes the scaled volume summary S* for a field.\"\"\"\n    mask = X >= t\n    if not np.any(mask):\n        return 0.0\n        \n    # 4-connectivity structure\n    connectivity_structure = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n    labeled_array, num_features = label(mask, structure=connectivity_structure)\n    \n    if num_features == 0:\n        return 0.0\n        \n    object_slices = find_objects(labeled_array)\n    object_sums = nd_sum(X, labeled_array, index=np.arange(1, num_features + 1))\n    object_maxima = maximum(X, labeled_array, index=np.arange(1, num_features + 1))\n\n    # Avoid division by zero if an object's max is somehow zero (should not happen with t > 0)\n    scaled_volumes = np.divide(object_sums, object_maxima, \n                              out=np.zeros_like(object_sums, dtype=float), \n                              where=object_maxima!=0)\n\n    return np.sum(scaled_volumes)\n\ndef compute_S(F, O):\n    \"\"\"Computes the Structure component S.\"\"\"\n    combined_values = np.concatenate((F.flatten(), O.flatten()))\n    # Handle empty fields for percentile calculation\n    if combined_values.size == 0 or np.all(combined_values == 0):\n        q95 = 0.0\n    else:\n        q95 = np.percentile(combined_values[combined_values > 0], 95) if np.any(combined_values > 0) else 0.0\n\n    t = max(0.1, 0.15 * q95)\n\n    S_F_star = compute_S_star(F, t)\n    S_O_star = compute_S_star(O, t)\n\n    denominator = 0.5 * (S_F_star + S_O_star)\n    if denominator > 0:\n        return (S_F_star - S_O_star) / denominator\n    return 0.0\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}