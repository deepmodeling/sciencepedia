{
    "hands_on_practices": [
        {
            "introduction": "深入理解一个检验评分（verification score）的行为，通常始于分析其在理想化情景下的表现。本练习  使用经典的棋盘格图案作为检验空间方法的测试案例，旨在推导分数技巧评分（FSS）的精确解析表达式。通过此过程，您将揭示 FSS 如何依赖于邻域尺度，并建立关于 FSS 如何在不同尺度上捕捉空间位移误差的直观认识。",
            "id": "4045627",
            "problem": "考虑一个无限的二维周期性方形网格，其网格间距为单位长度，并在网格点中心定义了二值场。设观测二值场 $O(i,j)$ 是一个完美的棋盘格，对于所有整数 $i$ 和 $j$，当 $i+j$ 为偶数时 $O(i,j) = 1$，当 $i+j$ 为奇数时 $O(i,j) = 0$。预报二值场是观测场在 $x$ 方向上平移一个网格点的结果，即 $F(i,j) = O(i+1,j)$。您将使用邻域法和方形窗口来评估分数技巧评分 (FSS)。\n\n将邻域分数 $o_{s}(i,j)$ 和 $f_{s}(i,j)$ 分别定义为 $O$ 和 $F$ 在以 $(i,j)$ 为中心的 $s \\times s$ 网格点方形区域内的平均值，其中 $s \\in \\mathbb{N}$ 是以网格点数计量的窗口边长。假设具有周期性，因此在每个 $(i,j)$ 处的窗口和都是良定义的。将窗口大小为 $s$ 的分数技巧评分 (FSS) 定义为\n$$\n\\mathrm{FSS}(s) \\equiv 1 - \\frac{\\mathrm{MSE}(s)}{\\mathrm{MSE}_{\\mathrm{ref}}(s)},\n$$\n其中\n$$\n\\mathrm{MSE}(s) \\equiv \\lim_{N \\to \\infty} \\frac{1}{N^{2}} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\left(f_{s}(i,j) - o_{s}(i,j)\\right)^{2},\n$$\n并且\n$$\n\\mathrm{MSE}_{\\mathrm{ref}}(s) \\equiv \\lim_{N \\to \\infty} \\frac{1}{N^{2}} \\sum_{i=1}^{N} \\sum_{j=1}^{N} \\left(f_{s}(i,j)^{2} + o_{s}(i,j)^{2}\\right).\n$$\n\n从这些定义出发，仅使用平均和周期性的基本性质，推导出一个对所有整数 $s \\geq 1$ 都有效的 $\\mathrm{FSS}(s)$ 的闭式解析表达式。然后，采用“有用尺度”的广泛使用的操作性定义，即满足 $\\mathrm{FSS}(s)$ 超过依赖于基础率的阈值\n$$\nT \\equiv \\frac{1}{2} + \\frac{f}{2},\n$$\n的最小 $s$，确定此配置下的有用尺度 $s^{\\ast}$，其中 $f$ 是 $O$ 在原始网格尺度上的区域平均值。\n\n提供两个输出：(i) 对所有整数 $s \\geq 1$ 有效的 $\\mathrm{FSS}(s)$ 的解析表达式，以及 (ii) 满足上述阈值标准的最小整数 $s^{\\ast}$。无需四舍五入。最终答案必须按规定以一个两元行矩阵的形式呈现。",
            "solution": "问题要求我们针对观测场和预报场的特定配置，给出一个分数技巧评分 $\\mathrm{FSS}(s)$ 的解析表达式，并由此推导出“有用尺度”$s^{\\ast}$。\n\n观测场是一个棋盘格图案，$O(i,j) = 1$ 如果 $i+j$ 是偶数，$O(i,j) = 0$ 如果 $i+j$ 是奇数。预报场是平移一个网格点的结果，$F(i,j) = O(i+1,j)$。\n\n首先，我们建立场 $O(i,j)$ 和 $F(i,j)$ 之间的关系。\n$O(i,j)$ 的值取决于 $i+j$ 的奇偶性。\n$F(i,j) = O(i+1,j)$ 的值取决于 $(i+1)+j = (i+j)+1$ 的奇偶性。\n如果 $i+j$ 是偶数，则 $O(i,j)=1$。那么 $(i+j)+1$ 是奇数，所以 $F(i,j)=O(i+1,j)=0$。\n如果 $i+j$ 是奇数，则 $O(i,j)=0$。那么 $(i+j)+1$ 是偶数，所以 $F(i,j)=O(i+1,j)=1$。\n在这两种情况下，都有 $F(i,j) = 1 - O(i,j)$。预报场是观测场的补集。\n\n邻域分数 $o_{s}(i,j)$ 和 $f_{s}(i,j)$ 是 $O$ 和 $F$ 在一个 $s \\times s$ 窗口内的平均值。由于平均算子的线性特性，分数之间也存在类似的关系：\n$$f_{s}(i,j) = \\frac{1}{s^2} \\sum_{\\text{window}} F(k,l) = \\frac{1}{s^2} \\sum_{\\text{window}} (1 - O(k,l)) = 1 - \\frac{1}{s^2} \\sum_{\\text{window}} O(k,l) = 1 - o_{s}(i,j)$$\n\n现在我们可以重写均方误差 (MSE) 项。我们将使用记号 $\\langle \\cdot \\rangle$ 表示空间平均 $\\lim_{N \\to \\infty} \\frac{1}{N^{2}} \\sum_{i=1}^{N} \\sum_{j=1}^{N} (\\cdot)$。\n$$\\mathrm{MSE}(s) = \\langle (f_{s}(i,j) - o_{s}(i,j))^2 \\rangle = \\langle (1 - o_{s}(i,j) - o_{s}(i,j))^2 \\rangle = \\langle (1 - 2o_{s}(i,j))^2 \\rangle$$\n$$\\mathrm{MSE}_{\\mathrm{ref}}(s) = \\langle f_{s}(i,j)^2 + o_{s}(i,j)^2 \\rangle = \\langle (1 - o_{s}(i,j))^2 + o_{s}(i,j)^2 \\rangle$$\n\n展开这些表达式：\n$$\\mathrm{MSE}(s) = \\langle 1 - 4o_{s}(i,j) + 4o_{s}(i,j)^2 \\rangle = 1 - 4 \\langle o_{s} \\rangle + 4 \\langle o_{s}^2 \\rangle$$\n$$\\mathrm{MSE}_{\\mathrm{ref}}(s) = \\langle 1 - 2o_{s}(i,j) + 2o_{s}(i,j)^2 \\rangle = 1 - 2 \\langle o_{s} \\rangle + 2 \\langle o_{s}^2 \\rangle$$\n为了继续计算，我们需要计算空间平均 $\\langle o_s \\rangle$ 和 $\\langle o_s^2 \\rangle$。\n\n卷积场 $o_s$ 的平均值等于原始场 $O$ 的平均值。场 $O$ 由等量的 $1$ 和 $0$ 组成。因此，其空间平均值为 $\\frac{1}{2}$。\n$$\\langle O \\rangle = \\frac{1}{2} \\implies \\langle o_s \\rangle = \\frac{1}{2} \\text{ for any } s \\ge 1$$\n\n$\\langle o_s^2 \\rangle$ 的计算取决于窗口大小 $s$ 的奇偶性。\n\n情况1：$s$ 为偶数。\n令 $s=2k$，其中 $k \\ge 1$ 为整数。一个 $s \\times s$ 的窗口可以被 $k^2$ 个不重叠的 $2 \\times 2$ 块完美平铺。在棋盘格网格中，任何 $2 \\times 2$ 的网格点块都精确包含两个 $O=1$ 的点和两个 $O=0$ 的点。因此，$O$ 在一个 $2 \\times 2$ 块上的和为 $2$。$O$ 在一个 $s \\times s$ 窗口上的和为 $k^2 \\times 2 = (s/2)^2 \\times 2 = s^2/2$。\n在任何 $s \\times s$ 窗口中，$1$ 的比例是恒定的：\n$$o_{s}(i,j) = \\frac{s^2/2}{s^2} = \\frac{1}{2} \\quad (\\text{对于偶数 } s)$$\n由于 $o_s(i,j)$ 是一个常数，其平均值为 $\\langle o_s \\rangle = \\frac{1}{2}$，其均方值为 $\\langle o_s^2 \\rangle = (\\frac{1}{2})^2 = \\frac{1}{4}$。\n现在我们求解偶数 $s$ 的 MSE 项：\n$$\\mathrm{MSE}(s) = 1 - 4(\\frac{1}{2}) + 4(\\frac{1}{4}) = 1 - 2 + 1 = 0$$\n$$\\mathrm{MSE}_{\\mathrm{ref}}(s) = 1 - 2(\\frac{1}{2}) + 2(\\frac{1}{4}) = 1 - 1 + \\frac{1}{2} = \\frac{1}{2}$$\n偶数 $s$ 的 FSS 为：\n$$\\mathrm{FSS}(s) = 1 - \\frac{\\mathrm{MSE}(s)}{\\mathrm{MSE}_{\\mathrm{ref}}(s)} = 1 - \\frac{0}{1/2} = 1$$\n\n情况2：$s$ 为奇数。\n令 $s=2k+1$，其中 $k \\ge 0$ 为整数。窗口中的总点数为 $s^2$。在这种情况下，$1$ 和 $0$ 的数量不相等。\n对于一个以 $(i,j)$ 为中心的窗口，如果 $O(i,j)=1$（即 $i+j$ 为偶数），则该窗口包含 $\\frac{s^2+1}{2}$ 个值为 $1$ 的点。如果 $O(i,j)=0$（即 $i+j$ 为奇数），则它包含 $\\frac{s^2-1}{2}$ 个值为 $1$ 的点。\n所以，$o_s(i,j)$ 有两个可能的值：\n$$o_s(i,j) = \\frac{s^2+1}{2s^2} \\quad \\text{如果 } i+j \\text{ 是偶数}$$\n$$o_s(i,j) = \\frac{s^2-1}{2s^2} \\quad \\text{如果 } i+j \\text{ 是奇数}$$\n由于一半的网格点满足 $i+j$ 为偶数，另一半满足 $i+j$ 为奇数，因此空间平均 $\\langle o_s^2 \\rangle$ 为：\n$$\\langle o_s^2 \\rangle = \\frac{1}{2} \\left( \\frac{s^2+1}{2s^2} \\right)^2 + \\frac{1}{2} \\left( \\frac{s^2-1}{2s^2} \\right)^2$$\n$$\\langle o_s^2 \\rangle = \\frac{1}{2 \\cdot 4s^4} \\left[ (s^4+2s^2+1) + (s^4-2s^2+1) \\right] = \\frac{1}{8s^4} (2s^4+2) = \\frac{s^4+1}{4s^4}$$\n现在我们求解奇数 $s$ 的 MSE 项：\n$$\\mathrm{MSE}(s) = 1 - 4(\\frac{1}{2}) + 4\\left(\\frac{s^4+1}{4s^4}\\right) = 1 - 2 + \\frac{s^4+1}{s^4} = -1 + 1 + \\frac{1}{s^4} = \\frac{1}{s^4}$$\n$$\\mathrm{MSE}_{\\mathrm{ref}}(s) = 1 - 2(\\frac{1}{2}) + 2\\left(\\frac{s^4+1}{4s^4}\\right) = 1 - 1 + \\frac{s^4+1}{2s^4} = \\frac{s^4+1}{2s^4}$$\n奇数 $s$ 的 FSS 为：\n$$\\mathrm{FSS}(s) = 1 - \\frac{1/s^4}{(s^4+1)/(2s^4)} = 1 - \\frac{2s^4}{s^4(s^4+1)} = 1 - \\frac{2}{s^4+1} = \\frac{s^4+1-2}{s^4+1} = \\frac{s^4-1}{s^4+1}$$\n\n为了给出一个对所有整数 $s \\ge 1$ 都有效的单一解析表达式：\n$$ \\mathrm{FSS}(s) = \\begin{cases} \\frac{s^4-1}{s^4+1}  \\text{如果 } s \\text{ 是奇数} \\\\ 1  \\text{如果 } s \\text{ 是偶数} \\end{cases} $$\n这可以使用项 $(-1)^s$ 进行统一：\n$$\\mathrm{FSS}(s) = \\frac{1-(-1)^s}{2} \\left(\\frac{s^4-1}{s^4+1}\\right) + \\frac{1+(-1)^s}{2} (1) = \\frac{(1-(-1)^s)(s^4-1) + (1+(-1)^s)(s^4+1)}{2(s^4+1)}$$\n$$= \\frac{s^4-1 - (-1)^s s^4 + (-1)^s + s^4+1 + (-1)^s s^4 + (-1)^s}{2(s^4+1)} = \\frac{2s^4 + 2(-1)^s}{2(s^4+1)} = \\frac{s^4+(-1)^s}{s^4+1}$$\n该表达式对于偶数 $s$ 正确地得到 $1$，对于奇数 $s$ 正确地得到 $\\frac{s^4-1}{s^4+1}$。\n\n接下来，我们确定有用尺度 $s^{\\ast}$。这是满足 $\\mathrm{FSS}(s) > T$ 的最小整数 $s$，其中 $T = \\frac{1}{2} + \\frac{f}{2}$。\n基础率 $f$ 是 $O$ 在原始尺度上的区域平均值，即 $f = \\langle O \\rangle = \\frac{1}{2}$。\n阈值为 $T = \\frac{1}{2} + \\frac{1/2}{2} = \\frac{1}{2} + \\frac{1}{4} = \\frac{3}{4}$。\n\n我们寻找满足 $\\mathrm{FSS}(s) > \\frac{3}{4}$ 的最小整数 $s \\ge 1$。\n我们测试较小的整数 $s$ 值：\n对于 $s=1$ (奇数):\n$$\\mathrm{FSS}(1) = \\frac{1^4-1}{1^4+1} = 0$$\n$0 \\ngtr \\frac{3}{4}$，所以 $s=1$ 不是有用尺度。\n对于 $s=2$ (偶数):\n$$\\mathrm{FSS}(2) = 1$$\n$1 > \\frac{3}{4}$，所以 $s=2$ 满足标准。\n因为我们在寻找最小的整数 $s$，并且我们发现 $s=2$ 满足条件而 $s=1$ 不满足，所以有用尺度是 $s^{\\ast}=2$。\n\n所需的两个输出是 $\\mathrm{FSS}(s)$ 的表达式和 $s^{\\ast}$ 的值。\n(i) $\\mathrm{FSS}(s) = \\frac{s^4+(-1)^s}{s^4+1}$\n(ii) $s^{\\ast}=2$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{s^4+(-1)^s}{s^4+1}  2\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "将分数技巧评分（FSS）的数学定义转化为实用的计算算法，需要解决一系列数值计算上的挑战。本练习  专注于构建一个稳健的 FSS 计算器，该计算器能够处理真实世界的数据，特别是那些可能导致分母过小和结果不稳定的稀有事件。此练习引入了诸如有效性门控和分母正则化等关键概念，以确保评分的计算既稳定又有意义。",
            "id": "4045673",
            "problem": "给定代表数值天气预报（预报）和验证分析（观测）的二维二元超限场。对于每个格点，邻域法通过在方形窗口内对二元场进行平均来计算局部超限分数。分数技巧评分 (Fractions Skill Score, FSS) 通过比较这些邻域分数来量化空间预报技巧。设 $X \\in \\{0,1\\}^{M \\times N}$ 表示预报二元场，$Y \\in \\{0,1\\}^{M \\times N}$ 表示观测二元场。对于以格点 $(i,j)$ 为中心、半径为 $r$（因此窗口宽度为 $2r+1$）的方形窗口，定义预报和观测的邻域分数为\n$$\nf_{ij} = \\frac{1}{A_{ij}} \\sum_{(p,q) \\in W_{ij}} X_{pq}, \\quad o_{ij} = \\frac{1}{A_{ij}} \\sum_{(p,q) \\in W_{ij}} Y_{pq},\n$$\n其中 $W_{ij}$ 是以 $(i,j)$ 为中心的方形窗口内的域内索引集合，而 $A_{ij}$ 是 $W_{ij}$ 中域内点的数量。全域级的分数技巧评分通过对所有格点进行聚合来定义：\n$$\n\\mathrm{FSS} = \\frac{2 \\sum_{i,j} f_{ij} \\, o_{ij}}{\\sum_{i,j} f_{ij}^2 + \\sum_{i,j} o_{ij}^2}.\n$$\n在实践中，当分母很小（例如，对于非常罕见的事件），由于有限精度和噪声，可能会出现数值不稳定性和评分的伪性膨胀。你的任务是实现一种数值稳定的 $\\mathrm{FSS}$ 计算方法，该方法包括防止伪性膨胀的保障措施。\n\n从上述基本定义出发，设计并实现一个算法，该算法：\n- 使用带有边界截斷的方形窗口计算邻域分数 $f_{ij}$ 和 $o_{ij}$（即，$A_{ij}$ 等于窗口中域内点的实际数量）。\n- 将 $\\mathrm{FSS}$ 聚合为如上所示的和的比率，而不是局部比率的平均值。\n- 应用以下保障措施：\n  1. 有效性门控：对于用户指定的阈值 $\\theta$，排除满足 $f_{ij} + o_{ij}  \\theta$ 的格点，以移除事件量可忽略的非信息性窗口。\n  2. 分母正则化：将分母 $D = \\sum_{i,j} f_{ij}^2 + \\sum_{i,j} o_{ij}^2$ 替换为 $D_{\\mathrm{reg}} = D + \\varepsilon_{\\mathrm{reg}}$，其中 $\\varepsilon_{\\mathrm{reg}}$ 是一个根据机器精度和经验性最小非零分数导出的自适应正常数。具体地，设置\n     $$\n     \\varepsilon_{\\mathrm{reg}} = \\lambda \\, \\max\\!\\big( N_{\\mathrm{eff}} \\, \\epsilon_{\\mathrm{mach}}, \\, N_{\\mathrm{eff}} \\, p_{\\min}^2 \\big),\n     $$\n     其中 $N_{\\mathrm{eff}}$ 是有效性门控后包含的格点数，$\\epsilon_{\\mathrm{mach}}$ 是双精度算术的机器ε，$p_{\\min}$ 是在包含的点上 $\\{f_{ij}, o_{ij}\\}$ 中的最小严格正值，而 $\\lambda$ 是用户指定的缩放常数。\n  3. 零信息情况的约定：如果 $N_{\\mathrm{eff}} = 0$，则返回 $\\mathrm{FSS} = 1$（在门控阈值下，预报和观测在所有地方都有效地是“无事件”），而不是产生未定义的结果。\n  4. 范围强制：将最终评分裁剪至 $[0,1]$ 范围内。\n  \n你的程序必须实现上述要求，并为提供的测试套件计算稳定的 $\\mathrm{FSS}$。所有输入都是无量纲的，输出必须是无量纲的实数。将所有输出表示为四舍五入到 $6$ 位小数的十进制浮点数。\n\n测试套件：\n使用以下五个测试用例。每个用例指定 $(X, Y, r, \\theta, \\lambda)$，其中 $M = N = 8$。在所有情况下，索引都是从零开始的，并且对于切片表示法包含端点。请完全按照指定的方式定义 $X$ 和 $Y$。\n\n- 用例 $1$（中度事件，小位移，典型分母）：\n  - $r = 1$, $\\theta = 0.05$, $\\lambda = 1.0$。\n  - $X$ 在行 $[3:6]$ 和列 $[3:6]$ 中为1（一个居中的 $3 \\times 3$ 块），其余为0。\n  - $Y$ 在行 $[4:7]$ 和列 $[3:6]$ 中为1（相同的块向下移动一个单位），其余为0。\n- 用例 $2$（罕见事件，小分母，轻微不匹配）：\n  - $r = 1$, $\\theta = 0.05$, $\\lambda = 1.0$。\n  - $X$ 在坐标 $(0,0)$ 和 $(1,2)$ 处为1，其余为0。\n  - $Y$ 在 $(0,1)$ 处为1，其余为0。\n- 用例 $3$（无事件，零分母）：\n  - $r = 1$, $\\theta = 0.05$, $\\lambda = 1.0$。\n  - $X$ 全部为0。\n  - $Y$ 全部为0。\n- 用例 $4$（完全不匹配的聚类，正常分母）：\n  - $r = 1$, $\\theta = 0.05$, $\\lambda = 1.0$。\n  - $X$ 在行 $[0:3]$ 和列 $[0:3]$ 中为1（左上角 $3 \\times 3$ 块），其余为0。\n  - $Y$ 在行 $[5:8]$ 和列 $[5:8]$ 中为1（右下角 $3 \\times 3$ 块），其余为0。\n- 用例 $5$（完美的单点匹配，极其罕见）：\n  - $r = 2$, $\\theta = 0.05$, $\\lambda = 1.0$。\n  - $X$ 在 $(4,4)$ 处为1，其余为0。\n  - $Y$ 在 $(4,4)$ 处为1，其余为0。\n\n输出规范：\n你的程序应产生一行输出，其中包含五个案例的稳定 $\\mathrm{FSS}$ 结果，格式为逗号分隔的列表并用方括号括起来，四舍五入到 $6$ 位小数，例如 $[0.123456,0.234567,0.345678,0.456789,0.567890]$。不得打印任何额外文本。",
            "solution": "该问题要求实现一种数值稳定的分数技巧评分（FSS）计算，用于比较二元预报场与观测场。FSS 是一种基于邻域的检验指标，广泛应用于气象学。核心任务包括计算局部超限分数，将它们聚合成一个技巧评分，并应用特定的数值保障措施来处理常见的失效模式，例如在罕见事件情况下除以接近零的分母。\n\n该算法主要分四个阶段进行：\n1.  计算邻域分数。\n2.  应用有效性门控以过滤非信息性格点。\n3.  从有效点中聚合评分的分量（分子和分母）。\n4.  应用数值正则化并进行最终评分计算与裁剪。\n\n设 $X$ 和 $Y$ 分别是 $M \\times N$ 的二元预报场和观测场。窗口半径为 $r$。\n\n**步骤1：邻域分数计算**\n\n邻域分数 $f_{ij}$（预报）和 $o_{ij}$（观测）在每个格点 $(i,j)$ 上计算。该分数表示在以 $(i,j)$ 为中心的宽度为 $W = 2r+1$ 的方形窗口内“事件”点（值为1）的密度。定义如下：\n$$\nf_{ij} = \\frac{1}{A_{ij}} \\sum_{(p,q) \\in W_{ij}} X_{pq}, \\quad o_{ij} = \\frac{1}{A_{ij}} \\sum_{(p,q) \\in W_{ij}} Y_{pq}\n$$\n这里，$W_{ij}$ 是以 $(i,j)$ 为中心的窗口内的格点索引集合，$A_{ij}$ 是此窗口内位于域边界内的点的数量（即边界截断）。\n\n此操作可以使用二维卷积高效实现。设 $K$ 是一个大小为 $(2r+1) \\times (2r+1)$ 且所有元素都为 $1$ 的核。和 $\\sum X_{pq}$ 与 $\\sum Y_{pq}$ 可以通过将 $X$ 和 $Y$ 与 $K$ 进行卷积来计算。\n$$\n\\text{Sum}_{X} = X * K, \\quad \\text{Sum}_{Y} = Y * K\n$$\n卷积必须通过假定域外值为 $0$ 来处理边界，这对应于 `scipy.ndimage.convolve` 中的 `mode='constant', cval=0` 设置。\n\n归一化因子 $A_{ij}$（它考虑了边界附近的截断窗口）可以通过将一个全为1的场 $I$（其中对所有 $p,q$，$I_{pq}=1$）与同一个核 $K$ 进行卷积来計算。\n$$\nA = I * K\n$$\n然后通过逐元素相除获得分数场：\n$$\nf = \\frac{\\text{Sum}_{X}}{A}, \\quad o = \\frac{\\text{Sum}_{Y}}{A}\n$$\n\n**步骤2：有效性门控**\n\n为了防止非信息性区域（即预报和观测的事件分数都接近零的区域）影响评分，应用了有效性门控。一个格点 $(i,j)$ 仅在其分数之和达到或超过阈值 $\\theta$ 时才被视为有效：\n$$\nf_{ij} + o_{ij} \\geq \\theta\n$$\n这会创建一个有效格点的布尔掩码。有效点数 $N_{\\mathrm{eff}}$ 是此类点的总数。\n\n如果 $N_{\\mathrm{eff}} = 0$，则会出现一种特殊情况。这表示对于所选的窗口大小和阈值，预报和观测中都没有显著事件。根据问题规范，这被认为是“完美”预报了一个无事件场，并且 FSS 定义为 $1$。\n\n**步骤3：评分分量的聚合**\n\n如果 $N_{\\mathrm{eff}} > 0$，我们继续仅在有效格点集合上计算 FSS 公式的基本组成部分。设 $V$ 为有效点的索引集。FSS 的分子 $N_{\\mathrm{FSS}}$ 和分母 $D_{\\mathrm{FSS}}$ 为：\n$$\nN_{\\mathrm{FSS}} = 2 \\sum_{(i,j) \\in V} f_{ij} \\, o_{ij}\n$$\n$$\nD_{\\mathrm{FSS}} = \\sum_{(i,j) \\in V} \\left( f_{ij}^2 + o_{ij}^2 \\right)\n$$\n标准的 FSS 将是比率 $N_{\\mathrm{FSS}} / D_{\\mathrm{FSS}}$。\n\n**步骤4：分母正则化与最终评分计算**\n\n对于罕见事件，分母 $D_{\\mathrm{FSS}}$ 可能非常小，导致数值不稳定和潜在的评分膨胀。为缓解此问题，向分母添加了一个正则化项 $\\varepsilon_{\\mathrm{reg}}$。该项自适应地定义为：\n$$\n\\varepsilon_{\\mathrm{reg}} = \\lambda \\, \\max\\!\\big( N_{\\mathrm{eff}} \\, \\epsilon_{\\mathrm{mach}}, \\, N_{\\mathrm{eff}} \\, p_{\\min}^2 \\big)\n$$\n其中：\n- $\\lambda$ 是用户指定的缩放因子。\n- $\\epsilon_{\\mathrm{mach}}$ 是双精度浮点数的机器ε，代表满足 $1.0 + \\epsilon_{\\mathrm{mach}} \\neq 1.0$ 的最小数。\n- $p_{\\min}$ 是在有效点集 $V$ 上所有分数 $\\{f_{ij}, o_{ij}\\}$ 中的最小严格正值。如果 $N_{\\mathrm{eff}} > 0$ 且 $\\theta > 0$，则必须存在至少一个这样的正分数。\n\n正则化后的分母为 $D_{\\mathrm{reg}} = D_{\\mathrm{FSS}} + \\varepsilon_{\\mathrm{reg}}$。然后原始 FSS 计算如下：\n$$\n\\mathrm{FSS}_{\\mathrm{raw}} = \\frac{N_{\\mathrm{FSS}}}{D_{\\mathrm{reg}}}\n$$\n这种正则化确保分母有界，远离零，从而提供稳定性。\n\n最后，将评分裁剪到 $[0,1]$ 范围内，以强制其作为技巧评分的定义，其中 $1$ 为完美，$0$ 表示无技巧。\n$$\n\\mathrm{FSS} = \\mathrm{clip}(\\mathrm{FSS}_{\\mathrm{raw}}, 0, 1)\n$$\n这个最终值就是数值稳定的分数技巧评分。",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import convolve\n\ndef compute_stabilized_fss(X, Y, r, theta, lambd):\n    \"\"\"\n    Computes the numerically stabilized Fractions Skill Score (FSS).\n\n    Args:\n        X (np.ndarray): The M x N binary forecast field.\n        Y (np.ndarray): The M x N binary observation field.\n        r (int): The radius for the square neighborhood window.\n        theta (float): The validity gating threshold.\n        lambd (float): The regularization scaling constant.\n\n    Returns:\n        float: The stabilized FSS value.\n    \"\"\"\n    if X.shape != Y.shape:\n        raise ValueError(\"Input fields X and Y must have the same shape.\")\n\n    M, N = X.shape\n    width = 2 * r + 1\n    kernel = np.ones((width, width))\n\n    # Step 1: Compute neighborhood fractions\n    # Use convolution to get sums in the sliding window.\n    # mode='constant', cval=0 handles boundaries correctly for this problem.\n    sum_X = convolve(X.astype(float), kernel, mode='constant', cval=0)\n    sum_Y = convolve(Y.astype(float), kernel, mode='constant', cval=0)\n\n    # To get the normalization factor A_ij (number of in-domain points),\n    # convolve a field of ones with the same kernel.\n    A = convolve(np.ones((M, N), dtype=float), kernel, mode='constant', cval=0)\n    \n    # Avoid division by zero, although A should be > 0 for r >= 0.\n    A[A == 0] = 1.0 \n    \n    f = sum_X / A\n    o = sum_Y / A\n\n    # Step 2: Apply validity gating\n    valid_mask = (f + o) >= theta\n    N_eff = np.sum(valid_mask)\n\n    # Step 3 (rule 3): Handle zero-information case\n    if N_eff == 0:\n        return 1.0\n\n    # Filter fractions to include only valid points\n    f_valid = f[valid_mask]\n    o_valid = o[valid_mask]\n\n    # Step 4: Aggregate score components\n    numerator_fss = 2.0 * np.sum(f_valid * o_valid)\n    denominator_fss = np.sum(f_valid**2) + np.sum(o_valid**2)\n    \n    if denominator_fss == 0:\n        # If numerator is also zero, it's a perfect no-event case\n        # (already covered by N_eff=0). If num > 0, it's an issue not\n        # expected by problem statement. A safe return for N=0, D=0 would be 1.\n        return 1.0 if numerator_fss == 0 else 0.0\n\n    # Step 5: Compute regularization term\n    positive_fractions = np.concatenate((f_valid[f_valid > 0], o_valid[o_valid > 0]))\n    \n    if positive_fractions.size == 0:\n        # This case should ideally not be reached if N_eff > 0 and theta > 0.\n        # If it is, it means all valid fractions were zero, so D=0, handled above.\n        # We can treat this as having no regularization.\n        p_min_sq = 0.0\n    else:\n        p_min = np.min(positive_fractions)\n        p_min_sq = p_min**2\n\n    eps_mach = np.finfo(np.float64).eps\n    eps_reg = lambd * max(N_eff * eps_mach, N_eff * p_min_sq)\n\n    # Step 6: Compute regularized FSS and clip\n    denominator_reg = denominator_fss + eps_reg\n    \n    # Final division, protected against zero denominator\n    fss_raw = numerator_fss / denominator_reg if denominator_reg != 0 else 0.0\n    \n    fss_final = np.clip(fss_raw, 0.0, 1.0)\n\n    return fss_final\n\ndef solve():\n    \"\"\"\n    Runs the test suite for the stabilized FSS computation.\n    \"\"\"\n    \n    M, N = 8, 8\n\n    # Case 1\n    X1 = np.zeros((M, N))\n    X1[3:6, 3:6] = 1\n    Y1 = np.zeros((M, N))\n    Y1[4:7, 3:6] = 1\n    case1 = (X1, Y1, 1, 0.05, 1.0)\n    \n    # Case 2\n    X2 = np.zeros((M, N))\n    X2[0, 0] = 1\n    X2[1, 2] = 1\n    Y2 = np.zeros((M, N))\n    Y2[0, 1] = 1\n    case2 = (X2, Y2, 1, 0.05, 1.0)\n\n    # Case 3\n    X3 = np.zeros((M, N))\n    Y3 = np.zeros((M, N))\n    case3 = (X3, Y3, 1, 0.05, 1.0)\n\n    # Case 4\n    X4 = np.zeros((M, N))\n    X4[0:3, 0:3] = 1\n    Y4 = np.zeros((M, N))\n    Y4[5:8, 5:8] = 1\n    case4 = (X4, Y4, 1, 0.05, 1.0)\n\n    # Case 5\n    X5 = np.zeros((M, N))\n    X5[4, 4] = 1\n    Y5 = np.zeros((M, N))\n    Y5[4, 4] = 1\n    case5 = (X5, Y5, 2, 0.05, 1.0)\n\n    test_cases = [case1, case2, case3, case4, case5]\n    \n    results = []\n    for params in test_cases:\n        X, Y, r, theta, lambd = params\n        fss = compute_stabilized_fss(X, Y, r, theta, lambd)\n        results.append(round(fss, 6))\n\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "分数技巧评分（FSS）最强大的应用之一是评估集合预报系统。本练习  要求您计算每个集合成员以及集合平均的“有用尺度”——即预报开始变得有技巧的最小尺度。通过这项实践，您将能够定量比较不同预报的性能，并评估集合预报的整体质量。",
            "id": "4045696",
            "problem": "给定一个表示气象现象（例如，阈值化的降水“有/无”）发生的网格化事件场，以及一个预报场的集合（系综），每个预报场都表示为一个二元数组，其中值 $1$ 表示事件发生，值 $0$ 表示未发生。您的任务是构建一个方法，使用基于邻域的评估和分数技巧评分（Fraction Skill Score, FSS）来计算每个系综成员和系综平均的“有用尺度”，并比较不同系综成员的有用尺度分布。\n\n此设置的基础包括以下定义和经过充分检验的公式：\n\n1. 设预报场为二元数组 $F \\in \\{0,1\\}^{N_x \\times N_y}$，观测场为二元数组 $O \\in \\{0,1\\}^{N_x \\times N_y}$。\n\n2. 对于给定的邻域尺度 $s$（单位为公里）和网格间距 $\\Delta x$（单位为公里），通过选择最接近 $s/\\Delta x$ 的奇数来定义一个以网格单元为单位的奇数窗口宽度 $w(s)$。给定一个方形平均核 $K_s$，其中对于 $-r \\le i,j \\le r$ 有 $K_s(i,j) = 1$，且 $w(s) = 2r+1$，通过离散卷积定义邻域分数场 $f_s$ 和 $o_s$：\n   $$\n   f_s = \\frac{1}{w(s)^2} \\left( K_s * F \\right), \\quad o_s = \\frac{1}{w(s)^2} \\left( K_s * O \\right),\n   $$\n   其中 $*$ 表示二维离散卷积，并使用反射边界条件，以便通过对称反射处理边缘值。\n\n3. 尺度 $s$ 下的分数技巧评分（Fraction Skill Score, FSS）由归一化均方误差公式定义：\n   $$\n   \\mathrm{FSS}(s) = 1 - \\frac{\\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\left( f_s(i,j) - o_s(i,j) \\right)^2}{\\sum_{i=1}^{N_x} \\sum_{j=1}^{N_y} \\left( f_s(i,j)^2 + o_s(i,j)^2 \\right)}.\n   $$\n   如果分母为零（这仅当 $f_s$ 和 $o_s$ 均恒为零时发生），则定义 $\\mathrm{FSS}(s) = 1$。\n\n4. 对于一个包含 $M$ 个成员的系综 $\\{F^{(m)}\\}_{m=1}^M$，定义系综平均场 $E$ 为：\n   $$\n   E = \\frac{1}{M} \\sum_{m=1}^M F^{(m)},\n   $$\n   这是一个在 $[0,1]^{N_x \\times N_y}$ 中的实值场。在尺度 $s$ 下，通过以下方式计算平滑后的系综平均分数场 $e_s$：\n   $$\n   e_s = \\frac{1}{w(s)^2} \\left( K_s * E \\right),\n   $$\n   并在分数技巧评分公式中用 $e_s$ 替换 $f_s$ 来计算 $\\mathrm{FSS}_{\\text{mean}}(s)$。\n\n5. 给定一个临界技巧阈值 $q \\in (0,1)$，将预报（单个成员或系综平均）的有用尺度 $s^\\ast$ 定义为：\n   $$\n   s^\\ast = \\min \\{ s \\in \\mathcal{S} : \\mathrm{FSS}(s) \\ge q \\},\n   $$\n   其中 $\\mathcal{S}$ 是测试尺度的集合。如果没有测试尺度达到或超过该阈值，则设 $s^\\ast = \\max(\\mathcal{S})$。\n\n实现一个程序，应用这些定义并为每个提供的测试用例计算：\n- 系综平均的有用尺度，以公里表示。\n- 各系综成员有用尺度的中位数，以公里表示。\n- 各系综成员有用尺度的方差，以平方公里表示。\n\n使用上文定义的邻域方法和分数技巧评分（FSS）来计算有用尺度。在卷积过程中必须使用反射边界条件。所有输出必须以公里（方差以平方公里）表示，不带百分号。不涉及角度。程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，将所有测试用例的结果聚合成一个列表的列表，格式为：\n\"[ [case1_mean,case1_median,case1_variance], [case2_mean,case2_median,case2_variance], [case3_mean,case3_median,case3_variance] ]\"\n所有条目均为浮点数。\n\n测试套件：\n\n所有测试用例均使用大小为 $N_x = N_y = 64$、网格间距 $\\Delta x = 2$ 公里的网格。观测和系综成员是由网格索引中的中心点 $(c_x,c_y)$ 和网格单元中的半径 $R$ 定义的圆盘（实心圆）。半径为 $R$ 个单元的圆盘意味着所有满足 $(i - c_x)^2 + (j - c_y)^2 \\le R^2$ 的网格点 $(i,j)$ 被赋值为 $1$，否则为 $0$。\n\n- 测试用例 1（具有不同成员误差的一般情况）：\n  - 观测：中心点 $(32,32)$，半径 $R_O = 8$。\n  - 系综成员（每个指定为 $(c_x,c_y,R)$）：\n    $$\n    \\{(27,28,8), (29,34,9), (34,31,7), (36,35,9), (30,37,8), (38,26,10), (32,32,8), (33,33,8), (31,30,8), (35,28,7), (26,37,11), (37,38,10)\\}.\n    $$\n  - 测试尺度（公里）：$\\mathcal{S} = [2, 6, 10, 14, 18, 22, 26]$。\n  - 临界阈值：$q = 0.5$。\n\n- 测试用例 2（完美预报）：\n  - 观测：中心点 $(30,30)$，半径 $R_O = 6$。\n  - 系综成员：六个与观测 $(30,30,6)$ 完全相同的副本。\n  - 测试尺度（公里）：$\\mathcal{S} = [2, 4, 6, 8, 10]$。\n  - 临界阈值：$q = 0.7$。\n\n- 测试用例 3（远离观测的差预报）：\n  - 观测：中心点 $(28,35)$，半径 $R_O = 10$。\n  - 系综成员：\n    $$\n    \\{(5,5,4), (55,55,4), (5,55,4), (55,5,4), (10,50,3), (50,10,3), (20,20,3), (44,44,3)\\}.\n    $$\n  - 测试尺度（公里）：$\\mathcal{S} = [2, 10, 18, 26, 34]$。\n  - 临界阈值：$q = 0.5$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[[result1_case1,result2_case1,result3_case1],[result1_case2,result2_case2,result3_case2],[result1_case3,result2_case3,result3_case3]]\"），其中每个“result”是如上定义的浮点数，每个用例中的前两个条目以公里为单位，第三个条目以平方公里为单位。",
            "solution": "问题陈述在形式上被验证为具有科学依据、定义明确且客观。它基于气象预报检验中的既定原则，特别是分数技巧评分（FSS）和用于集合预报的邻域方法，提出了一个清晰、自洽的任务。所有定义、公式和数据都明确提供且相互一致，从而能够得出一个唯一且有意义的解。\n\n解决此问题的方法论遵循一系列明确定义的步骤，并严格遵守所提供的定义。\n\n首先，对于每个测试用例，我们必须为观测和每个系综成员构建二元网格场。网格维度为 $N_x = 64, N_y = 64$，网格间距为 $\\Delta x = 2$ 公里。一个事件，表示为实心圆（圆盘），由其中心 $(c_x, c_y)$ 和半径 $R$ 定义。如果整数坐标 $(j, i)$（列，行）处的网格单元满足条件 $(j-c_x)^2 + (i-c_y)^2 \\le R^2$，则其值被赋为 $1$，否则为 $0$。我们将给定的中心坐标 $(c_x, c_y)$ 解释为对应于（列，行）的从0开始索引的网格坐标。\n\n其次，我们为一组指定的邻域尺度 $\\mathcal{S}$ 计算分数技巧评分 $\\mathrm{FSS}(s)$。对于每个尺度 $s \\in \\mathcal{S}$，这需要几个子步骤：\n\n1.  确定邻域窗口宽度 $w(s)$，其定义为最接近比率 $s/\\Delta x$ 的奇数。在 $s/\\Delta x$ 与两个奇数等距的情况下（例如，如果 $s/\\Delta x$ 是一个偶数），我们采用选择较大奇数的约定。\n2.  生成邻域分数场。对于一个观测场 $O$ 和一个预报场 $F$（可以是单个系综成员 $F^{(m)}$ 或系综平均 $E$），我们计算分数场 $o_s$ 和 $f_s$（对于系综平均则为 $e_s$）。这是通过与一个大小为 $w(s) \\times w(s)$、完全由1组成的方形核 $K_s$ 进行二维离散卷积来完成的。卷积必须使用反射边界条件。结果场通过除以核的面积 $w(s)^2$ 进行归一化。\n    $$\n    o_s = \\frac{1}{w(s)^2} (K_s * O), \\quad f_s = \\frac{1}{w(s)^2} (K_s * F^{(m)}), \\quad e_s = \\frac{1}{w(s)^2} (K_s * E)\n    $$\n3.  使用提供的公式计算 $\\mathrm{FSS}(s)$：\n    $$\n    \\mathrm{FSS}(s) = 1 - \\frac{\\mathrm{MSE}(s)}{\\mathrm{MSE}_{\\mathrm{ref}}(s)} = 1 - \\frac{\\sum_{j=1}^{N_x} \\sum_{i=1}^{N_y} ( f_s(j,i) - o_s(j,i) )^2}{\\sum_{j=1}^{N_x} \\sum_{i=1}^{N_y} ( f_s(j,i)^2 + o_s(j,i)^2 )}\n    $$\n    如果分母 $\\mathrm{MSE}_{\\mathrm{ref}}(s)$ 为零，这仅在场 $F$ 和 $O$ 都恒为零时发生，我们设置 $\\mathrm{FSS}(s) = 1$。\n\n第三，我们确定每个预报的“有用尺度” $s^\\ast$。给定一个临界技巧阈值 $q$，有用尺度被定义为评分达到或超过该阈值的最小尺度 $s \\in \\mathcal{S}$：\n$$\ns^\\ast = \\min \\{ s \\in \\mathcal{S} : \\mathrm{FSS}(s) \\ge q \\}\n$$\n如果 $\\mathcal{S}$ 中没有尺度达到阈值 $q$，则有用尺度被设置为测试的最大尺度 $\\max(\\mathcal{S})$。此过程应用于 $M$ 个系综成员中的每一个，以获得一组有用尺度 $\\{s^\\ast_m\\}_{m=1}^M$，并应用于系综平均预报 $E$，以获得其有用尺度 $s^\\ast_{\\text{mean}}$。\n\n最后，我们为每个测试用例计算所需的输出统计数据：\n1.  系综平均的有用尺度 $s^\\ast_{\\text{mean}}$。\n2.  各个系综成员有用尺度的中位数 $\\mathrm{median}(\\{s^\\ast_m\\})$。\n3.  各个系综成员有用尺度的方差 $\\mathrm{var}(\\{s^\\ast_m\\})$。\n\n整个过程通过一个程序实现，该程序使用 `NumPy` 库进行高效的数组操作，使用 `SciPy` 库进行卷积运算，并遵循指定的执行环境。",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import convolve\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"grid_size\": (64, 64),\n            \"dx_km\": 2.0,\n            \"obs_params\": {\"center\": (32, 32), \"radius\": 8},\n            \"ensemble_params\": [\n                {\"center\": (27, 28), \"radius\": 8}, {\"center\": (29, 34), \"radius\": 9},\n                {\"center\": (34, 31), \"radius\": 7}, {\"center\": (36, 35), \"radius\": 9},\n                {\"center\": (30, 37), \"radius\": 8}, {\"center\": (38, 26), \"radius\": 10},\n                {\"center\": (32, 32), \"radius\": 8}, {\"center\": (33, 33), \"radius\": 8},\n                {\"center\": (31, 30), \"radius\": 8}, {\"center\": (35, 28), \"radius\": 7},\n                {\"center\": (26, 37), \"radius\": 11}, {\"center\": (37, 38), \"radius\": 10},\n            ],\n            \"scales_km\": np.array([2.0, 6.0, 10.0, 14.0, 18.0, 22.0, 26.0]),\n            \"q\": 0.5,\n        },\n        {\n            \"grid_size\": (64, 64),\n            \"dx_km\": 2.0,\n            \"obs_params\": {\"center\": (30, 30), \"radius\": 6},\n            \"ensemble_params\": [\n                {\"center\": (30, 30), \"radius\": 6} for _ in range(6)\n            ],\n            \"scales_km\": np.array([2.0, 4.0, 6.0, 8.0, 10.0]),\n            \"q\": 0.7,\n        },\n        {\n            \"grid_size\": (64, 64),\n            \"dx_km\": 2.0,\n            \"obs_params\": {\"center\": (28, 35), \"radius\": 10},\n            \"ensemble_params\": [\n                {\"center\": (5, 5), \"radius\": 4}, {\"center\": (55, 55), \"radius\": 4},\n                {\"center\": (5, 55), \"radius\": 4}, {\"center\": (55, 5), \"radius\": 4},\n                {\"center\": (10, 50), \"radius\": 3}, {\"center\": (50, 10), \"radius\": 3},\n                {\"center\": (20, 20), \"radius\": 3}, {\"center\": (44, 44), \"radius\": 3},\n            ],\n            \"scales_km\": np.array([2.0, 10.0, 18.0, 26.0, 34.0]),\n            \"q\": 0.5,\n        }\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        all_results.append(solve_case(case))\n        \n    # Format the final output string exactly as required\n    inner_parts = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    final_output = f\"[{','.join(inner_parts)}]\"\n    print(final_output)\n\ndef create_disk_field(grid_size, center, radius):\n    \"\"\"\n    Creates a binary grid with a filled circle (disk).\n    \n    Args:\n        grid_size (tuple): (Ny, Nx) dimensions of the grid.\n        center (tuple): (cx, cy) 0-indexed center coordinates (column, row).\n        radius (int): Radius of the disk in grid cells.\n        \n    Returns:\n        np.ndarray: A 2D binary grid.\n    \"\"\"\n    ny, nx = grid_size\n    cx, cy = center\n    radius_sq = radius**2\n    \n    y_indices, x_indices = np.ogrid[:ny, :nx]\n    \n    dist_sq = (x_indices - cx)**2 + (y_indices - cy)**2\n    \n    return (dist_sq = radius_sq).astype(float)\n\ndef get_window_width(s, dx):\n    \"\"\"\n    Calculates the odd integer window width closest to s/dx.\n    Tie-breaking rule: choose the larger odd integer.\n    \"\"\"\n    val = s / dx\n    w = int(round(val))\n    if w == 0:\n        return 1\n    if w % 2 == 0:\n        if val  w:\n            w = w - 1\n        else:\n            w = w + 1\n    return w\n\ndef calculate_fss_over_scales(forecast_field, obs_field, scales_km, dx):\n    \"\"\"\n    Computes the Fraction Skill Score (FSS) over a range of scales.\n    \n    Args:\n        forecast_field, obs_field (np.ndarray): The 2D fields.\n        scales_km (np.ndarray): Array of scales in kilometers.\n        dx (float): Grid spacing in kilometers.\n        \n    Returns:\n        np.ndarray: Array of FSS values for each scale.\n    \"\"\"\n    fss_values = []\n    for s in scales_km:\n        w = get_window_width(s, dx)\n        kernel = np.ones((w, w))\n        \n        o_s = convolve(obs_field, kernel, mode='reflect') / (w**2)\n        f_s = convolve(forecast_field, kernel, mode='reflect') / (w**2)\n        \n        mse = np.sum((f_s - o_s)**2)\n        mse_ref = np.sum(f_s**2 + o_s**2)\n        \n        if mse_ref == 0:\n            fss = 1.0\n        else:\n            fss = 1.0 - (mse / mse_ref)\n        fss_values.append(fss)\n        \n    return np.array(fss_values)\n\ndef find_useful_scale(fss_values, scales_km, q):\n    \"\"\"\n    Determines the useful scale from a set of FSS values.\n    \"\"\"\n    above_threshold = np.where(fss_values >= q)[0]\n    \n    if len(above_threshold) > 0:\n        return scales_km[above_threshold[0]]\n    else:\n        return np.max(scales_km)\n\ndef solve_case(case_params):\n    \"\"\"\n    Solves a single test case.\n    \"\"\"\n    grid_size = case_params[\"grid_size\"]\n    dx_km = case_params[\"dx_km\"]\n    obs_params = case_params[\"obs_params\"]\n    ensemble_params = case_params[\"ensemble_params\"]\n    scales_km = case_params[\"scales_km\"]\n    q = case_params[\"q\"]\n\n    # Create observation field\n    obs_field = create_disk_field(grid_size, obs_params[\"center\"], obs_params[\"radius\"])\n\n    # Process each ensemble member\n    ensemble_fields = []\n    member_useful_scales = []\n    for params in ensemble_params:\n        member_field = create_disk_field(grid_size, params[\"center\"], params[\"radius\"])\n        ensemble_fields.append(member_field)\n        \n        fss_values = calculate_fss_over_scales(member_field, obs_field, scales_km, dx_km)\n        s_star = find_useful_scale(fss_values, scales_km, q)\n        member_useful_scales.append(s_star)\n\n    member_useful_scales = np.array(member_useful_scales)\n\n    # Calculate statistics for members\n    median_s_star = np.median(member_useful_scales)\n    variance_s_star = np.var(member_useful_scales)\n    \n    # Process ensemble mean\n    ensemble_mean_field = np.mean(ensemble_fields, axis=0)\n    mean_fss_values = calculate_fss_over_scales(ensemble_mean_field, obs_field, scales_km, dx_km)\n    mean_s_star = find_useful_scale(mean_fss_values, scales_km, q)\n    \n    return [mean_s_star, median_s_star, variance_s_star]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}