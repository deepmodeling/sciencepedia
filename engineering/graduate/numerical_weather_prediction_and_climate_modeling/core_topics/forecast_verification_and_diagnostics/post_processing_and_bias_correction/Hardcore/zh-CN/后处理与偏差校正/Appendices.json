{
    "hands_on_practices": [
        {
            "introduction": "线性回归是偏差校正工具箱中的基石，尤其是在模型输出统计（MOS）方法中。通过将观测值与模式预报值进行线性拟合，我们可以校正系统性的平均误差。然而，一个模型的价值不仅在于其拟合能力，更在于我们对其局限性的理解；因此，本练习不仅要求你推导并应用线性校正，还引导你通过残差分析来诊断模型假设的有效性，这是评估任何统计后处理方法是否适当的关键一步 。",
            "id": "4076566",
            "problem": "在数值天气预报（NWP）的后处理中，预报-观测偏差订正通常被建模为一个形式为 $y \\approx a + b f$ 的线性映射，其中 $f$ 表示原始模式预报，$y$ 表示检验观测值。在模式输出统计（MOS）中，参数 $a$ 和 $b$ 通过最小二乘法进行估计。从最小化误差平方和的原则出发，用样本统计量推导出最小二乘估计量，然后对以下数据集进行计算。在计算出线性拟合后，通过量化残差 $r_i$ 与平方的中心化预报值 $s_i = (f_i - \\bar{f})^{2}$ 之间的线性关联来检查残差结构，以诊断非线性。\n\n使用以下关于2米温度的 $n = 10$ 组配对值 $\\{(f_i, y_i)\\}_{i=1}^{10}$ 的数据集，其中 $f_i$ 是以开尔文为单位的预报值，$y_i$ 是以开尔文为单位的检验观测值：\n$\\{(f_i, y_i)\\}_{i=1}^{10} = \\{(275, 274), (280, 277.5), (285, 282), (290, 287.5), (295, 294), (275, 274), (280, 277.5), (285, 282), (290, 287.5), (295, 294)\\}$.\n\n你的任务是：\n1. 从最小二乘准则以及样本均值、样本方差和样本协方差的核心定义出发，推导用样本统计量表示的估计量 $\\hat{a}$ 和 $\\hat{b}$，并为给定数据集计算它们的数值。将 $\\hat{a}$ 以开尔文表示，$\\hat{b}$ 为无量纲量。\n2. 计算残差 $r_i = y_i - (\\hat{a} + \\hat{b} f_i)$ 与平方的中心化预报值 $s_i = (f_i - \\bar{f})^{2}$ 之间的皮尔逊相关系数 $D$。在诊断偏差订正中的非线性的背景下，解释 $D$ 的大小和符号。\n\n如果数值答案需要四舍五入，则保留四位有效数字。将 $\\hat{a}$ 以开尔文表示，$\\hat{b}$ 和 $D$ 为无量纲量。提供 $\\hat{a}$、$\\hat{b}$ 和 $D$ 的最终数值。",
            "solution": "该问题要求针对给定的气象预报和观测数据集，推导和计算线性回归参数，然后进行残差分析以诊断非线性。该过程将按要求分两部分进行。\n\n### 第1部分：最小二乘估计量的推导与计算\n\n线性模型为 $y \\approx a + b f$。参数 $a$ 和 $b$ 是通过最小化误差平方和（SSE）$S(a, b)$ 来估计的。\n\n**1. 估计量的推导**\n\nSSE 定义为：\n$$S(a,b) = \\sum_{i=1}^{n} (y_i - (a + b f_i))^2$$\n为了找到使 $S$ 最小化的 $a$ 和 $b$ 的值，我们对 $S$ 分别求关于 $a$ 和 $b$ 的偏导数，并令它们等于零。得到的估计量记为 $\\hat{a}$ 和 $\\hat{b}$。\n\n关于 $a$ 的一阶偏导数为：\n$$\\frac{\\partial S}{\\partial a} = \\sum_{i=1}^{n} 2(y_i - a - b f_i)(-1) = -2 \\sum_{i=1}^{n} (y_i - a - b f_i)$$\n令 $\\frac{\\partial S}{\\partial a} = 0$：\n$$\\sum_{i=1}^{n} (y_i - \\hat{a} - \\hat{b} f_i) = 0$$\n$$\\sum y_i - n\\hat{a} - \\hat{b}\\sum f_i = 0$$\n除以样本大小 $n$ 并使用样本均值的定义 $\\bar{y} = \\frac{1}{n}\\sum y_i$ 和 $\\bar{f} = \\frac{1}{n}\\sum f_i$：\n$$\\bar{y} - \\hat{a} - \\hat{b}\\bar{f} = 0$$\n这就得到了用斜率估计量 $\\hat{b}$ 表示的截距估计量 $\\hat{a}$：\n$$\\hat{a} = \\bar{y} - \\hat{b}\\bar{f}$$\n\n关于 $b$ 的一阶偏导数为：\n$$\\frac{\\partial S}{\\partial b} = \\sum_{i=1}^{n} 2(y_i - a - b f_i)(-f_i) = -2 \\sum_{i=1}^{n} f_i(y_i - a - b f_i)$$\n令 $\\frac{\\partial S}{\\partial b} = 0$：\n$$\\sum_{i=1}^{n} f_i(y_i - \\hat{a} - \\hat{b} f_i) = 0$$\n代入 $\\hat{a}$ 的表达式：\n$$\\sum_{i=1}^{n} f_i(y_i - (\\bar{y} - \\hat{b}\\bar{f}) - \\hat{b} f_i) = 0$$\n$$\\sum_{i=1}^{n} f_i((y_i - \\bar{y}) - \\hat{b}(f_i - \\bar{f})) = 0$$\n$$\\sum_{i=1}^{n} f_i(y_i - \\bar{y}) - \\hat{b}\\sum_{i=1}^{n} f_i(f_i - \\bar{f}) = 0$$\n解出 $\\hat{b}$：\n$$\\hat{b} = \\frac{\\sum f_i(y_i - \\bar{y})}{\\sum f_i(f_i - \\bar{f})}$$\n分子和分母可以简化为用中心化变量表示的更标准的形式：\n$\\sum (f_i - \\bar{f})(y_i - \\bar{y}) = \\sum (f_iy_i - f_i\\bar{y} - \\bar{f}y_i + \\bar{f}\\bar{y}) = \\sum f_iy_i - \\bar{y}\\sum f_i - \\bar{f}\\sum y_i + n\\bar{f}\\bar{y} = \\sum f_iy_i - n\\bar{f}\\bar{y} - n\\bar{f}\\bar{y} + n\\bar{f}\\bar{y} = \\sum f_iy_i - n\\bar{f}\\bar{y}$。\n并且，$\\sum f_i(y_i - \\bar{y}) = \\sum f_iy_i - \\bar{y}\\sum f_i = \\sum f_iy_i - n\\bar{f}\\bar{y}$。\n因此，$\\sum_i (f_i - \\bar{f})(y_i - \\bar{y}) = \\sum_i f_i(y_i - \\bar{y})$。类似地，$\\sum_i (f_i - \\bar{f})^2 = \\sum_i f_i(f_i - \\bar{f})$。\n这给出了 $\\hat{b}$ 的标准表达式：\n$$\\hat{b} = \\frac{\\sum_{i=1}^{n}(f_i - \\bar{f})(y_i - \\bar{y})}{\\sum_{i=1}^{n}(f_i - \\bar{f})^2}$$\n这将 $\\hat{b}$ 表示为 $f$ 和 $y$ 的样本协方差（与分子成正比）和 $f$ 的样本方差（与分母成正比）的形式。具体来说，如果 $s_{fy} = \\frac{1}{n-1}\\sum(f_i - \\bar{f})(y_i - \\bar{y})$ 且 $s_f^2 = \\frac{1}{n-1}\\sum(f_i - \\bar{f})^2$，那么 $\\hat{b} = \\frac{s_{fy}}{s_f^2}$。推导到此完成。\n\n**2. 针对给定数据集的计算**\n\n数据集为 $\\{(275, 274), (280, 277.5), (285, 282), (290, 287.5), (295, 294)\\}$，其中5组配对值各重复一次，总共有 $n=10$ 个数据点。\n\n首先，我们计算样本均值 $\\bar{f}$ 和 $\\bar{y}$：\n$$\\sum_{i=1}^{10} f_i = 2 \\times (275 + 280 + 285 + 290 + 295) = 2 \\times 1425 = 2850$$\n$$\\bar{f} = \\frac{2850}{10} = 285 \\, \\text{K}$$\n$$\\sum_{i=1}^{10} y_i = 2 \\times (274 + 277.5 + 282 + 287.5 + 294) = 2 \\times 1415 = 2830$$\n$$\\bar{y} = \\frac{2830}{10} = 283 \\, \\text{K}$$\n\n接下来，我们计算 $\\hat{b}$ 所需的平方和与交叉乘积和。\n对于不重复的点，中心化预报值 $(f_i - \\bar{f})$ 为：\n$275 - 285 = -10$, $280 - 285 = -5$, $285 - 285 = 0$, $290 - 285 = 5$, $295 - 285 = 10$。\n对于不重复的点，中心化观测值 $(y_i - \\bar{y})$ 为：\n$274 - 283 = -9$, $277.5 - 283 = -5.5$, $282 - 283 = -1$, $287.5 - 283 = 4.5$, $294 - 283 = 11$。\n\n$\\hat{b}$ 的分母：\n$$\\sum_{i=1}^{10}(f_i - \\bar{f})^2 = 2 \\times [(-10)^2 + (-5)^2 + 0^2 + 5^2 + 10^2] = 2 \\times [100 + 25 + 0 + 25 + 100] = 2 \\times 250 = 500$$\n\n$\\hat{b}$ 的分子：\n$$\\sum_{i=1}^{10}(f_i - \\bar{f})(y_i - \\bar{y}) = 2 \\times [(-10)(-9) + (-5)(-5.5) + (0)(-1) + (5)(4.5) + (10)(11)]$$\n$$= 2 \\times [90 + 27.5 + 0 + 22.5 + 110] = 2 \\times 250 = 500$$\n\n现在，我们计算 $\\hat{b}$：\n$$\\hat{b} = \\frac{500}{500} = 1$$\n这是一个无量纲量。保留四位有效数字，$\\hat{b} = 1.000$。\n\n最后，我们计算 $\\hat{a}$：\n$$\\hat{a} = \\bar{y} - \\hat{b}\\bar{f} = 283 - (1)(285) = -2$$\n$\\hat{a}$ 的单位是开尔文。保留四位有效数字，$\\hat{a} = -2.000 \\, \\text{K}$。\n拟合的线性模型是 $\\hat{y} = -2 + 1 \\cdot f$。\n\n### 第2部分：用于非线性诊断的残差分析\n\n我们现在计算残差 $r_i = y_i - (\\hat{a} + \\hat{b} f_i)$ 和平方的中心化预报值 $s_i = (f_i - \\bar{f})^2$ 之间的皮尔逊相关系数 $D$。\n\n**1. $r_i$ 和 $s_i$ 的计算**\n\n对于不重复的配对，残差 $r_i$ 为：\n对于 $(275, 274)$: $r_i = 274 - (-2 + 275) = 274 - 273 = 1$。\n对于 $(280, 277.5)$: $r_i = 277.5 - (-2 + 280) = 277.5 - 278 = -0.5$。\n对于 $(285, 282)$: $r_i = 282 - (-2 + 285) = 282 - 283 = -1$。\n对于 $(290, 287.5)$: $r_i = 287.5 - (-2 + 290) = 287.5 - 288 = -0.5$。\n对于 $(295, 294)$: $r_i = 294 - (-2 + 295) = 294 - 293 = 1$。\n全部10个残差的集合是 $\\{1, -0.5, -1, -0.5, 1, 1, -0.5, -1, -0.5, 1\\}$。\n残差的均值为 $\\bar{r} = \\frac{1}{10} \\sum r_i = \\frac{2 \\times (1 - 0.5 - 1 - 0.5 + 1)}{10} = 0$。\n\n对于不重复的配对，$s_i = (f_i - \\bar{f})^2$ 的值为：\n$s_1 = (-10)^2 = 100$。\n$s_2 = (-5)^2 = 25$。\n$s_3 = 0^2 = 0$。\n$s_4 = 5^2 = 25$。\n$s_5 = 10^2 = 100$。\n全部10个值的集合是 $\\{100, 25, 0, 25, 100, 100, 25, 0, 25, 100\\}$。\n均值为 $\\bar{s} = \\frac{1}{10}\\sum s_i = \\frac{500}{10} = 50$。\n\n**2. 相关系数 $D$ 的计算**\n\n皮尔逊相关系数 $D = \\text{corr}(r, s)$ 由下式给出：\n$$D = \\frac{\\sum_{i=1}^{n} (r_i - \\bar{r})(s_i - \\bar{s})}{\\sqrt{\\sum_{i=1}^{n} (r_i - \\bar{r})^2 \\sum_{i=1}^{n} (s_i - \\bar{s})^2}}$$\n因为 $\\bar{r}=0$，公式简化为：\n$$D = \\frac{\\sum_{i=1}^{n} r_i(s_i - \\bar{s})}{\\sqrt{\\sum_{i=1}^{n} r_i^2 \\sum_{i=1}^{n} (s_i - \\bar{s})^2}}$$\n\n我们计算各项：\n分子：$\\sum r_i(s_i - \\bar{s}) = 2 \\times [1(100-50) + (-0.5)(25-50) + (-1)(0-50) + (-0.5)(25-50) + 1(100-50)]$。\n$$= 2 \\times [1(50) + (-0.5)(-25) + (-1)(-50) + (-0.5)(-25) + 1(50)]$$\n$$= 2 \\times [50 + 12.5 + 50 + 12.5 + 50] = 2 \\times 175 = 350$$\n\n分母第1项：残差平方和。\n$$\\sum r_i^2 = 2 \\times [1^2 + (-0.5)^2 + (-1)^2 + (-0.5)^2 + 1^2] = 2 \\times [1 + 0.25 + 1 + 0.25 + 1] = 2 \\times 3.5 = 7$$\n\n分母第2项：中心化 $s_i$ 的平方和。\n$$\\sum (s_i - \\bar{s})^2 = 2 \\times [(100-50)^2 + (25-50)^2 + (0-50)^2 + (25-50)^2 + (100-50)^2]$$\n$$= 2 \\times [50^2 + (-25)^2 + (-50)^2 + (-25)^2 + 50^2]$$\n$$= 2 \\times [2500 + 625 + 2500 + 625 + 2500] = 2 \\times 8750 = 17500$$\n\n现在我们计算 $D$：\n$$D = \\frac{350}{\\sqrt{7 \\times 17500}} = \\frac{350}{\\sqrt{122500}} = \\frac{350}{350} = 1$$\n保留四位有效数字，$D = 1.000$。\n\n**3. $D$ 的解释**\n\n系数 $D$ 衡量了线性模型的残差 $r_i$ 与平方的中心化预报值 $s_i = (f_i - \\bar{f})^2$ 之间的线性关联。$D$ 的非零值表明残差中存在与预测变量的二次函数相关的系统性模式，这是非线性和模型设定错误的强烈信号。\n\n在本例中，$D=1.000$。这个值代表完全正线性相关。它表明来自线性拟合 $y_i = \\hat{a} + \\hat{b} f_i$ 的残差不是随机噪声，而是与预报值存在一种确定性关系。具体来说，残差是 $(f_i - \\bar{f})^2$ 的一个精确的正线性函数。\n\n$D$ 的正号意味着 $y$ 和 $f$ 之间的真实关系是凸的（U形）。对于远离平均预报值 $\\bar{f}$ 的预报 $f_i$（此时 $(f_i - \\bar{f})^2$ 较大，残差为正），线性模型系统性地低估了观测值 $y_i$；而对于接近平均值的预报（此时 $(f_i - \\bar{f})^2$ 较小，残差为负），则会高估 $y_i$。这一点由我们计算出的残差所证实：在 $f_i=\\bar{f}=285$ 时 $r_i$ 为 $-1$，而在极端的预报值 $275$ 和 $295$ 处 $r_i$ 为 $+1$。\n\n因此，$D=1$ 的结果明确地诊断出存在未建模的二次非线性，这表明形式为 $y \\approx \\beta_0 + \\beta_1 f + \\beta_2 f^2$ 的模型将能更准确地拟合数据。\n\n保留四位有效数字的最终数值是：\n$\\hat{a} = -2.000 \\, \\text{K}$\n$\\hat{b} = 1.000$\n$D = 1.000$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-2.000  1.000  1.000\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "虽然单一的线性模型能够校正整体的平均偏差，但模式的误差往往不是一成不变的，它会随着天气“环流形势”（regime）的改变而变化。本练习将引导你超越“一刀切”的校正方法，探索一种更高级的概率性技术。你将使用高斯混合模型，根据不同的天气环流形势应用特定的偏差校正方案，从而学习如何构建能够捕捉偏差状态依赖性的后处理模型 。",
            "id": "4076604",
            "problem": "考虑一个数值天气预报 (NWP) 中的后处理和偏差订正任务。设 $Y$ 表示用于验证的近地面气温（单位：开尔文），设 $F$ 表示一个确定性模式预报（单位：开尔文），并设 $R \\in \\{1,\\dots,K\\}$ 表示一个离散的模态指数，该指数捕捉了天气尺度环流或其他结构性条件。假设特定模态的校准模型由给定 $R=r$ 和 $F=f$ 时 $Y$ 的条件分布定义，该分布为高斯分布，其均值为 $a_r + c_r f$，方差为 $\\sigma_r^2$。其中，$a_r$ 是一个加性偏移量（单位：开尔文），$c_r$ 是一个乘性校准系数（无量纲），$\\sigma_r$ 是特定模态残差的标准差（单位：开尔文）。模态概率以软分配的形式给出，$w_r = \\mathbb{P}(R=r \\mid \\mathbf{x})$，对于每个 $r$ 都有 $w_r \\in [0,1]$ 且 $\\sum_{r=1}^{K} w_r \\approx 1$，其中 $\\mathbf{x}$ 是一个预测因子向量。因此，在给定 $\\mathbf{x}$ 和 $F=f$ 的条件下，$Y$ 的预测分布是一个由 $\\{w_r\\}_{r=1}^K$ 加权的、按模态划分的高斯分布的有限混合。\n\n从以下基本依据出发：\n- 全期望定律，即 $\\mathbb{E}[Y \\mid \\mathbf{x}, F=f] = \\mathbb{E}\\big[\\mathbb{E}[Y \\mid R, \\mathbf{x}, F=f] \\mid \\mathbf{x}, F=f\\big]$。\n- 全方差定律，即 $\\mathrm{Var}(Y \\mid \\mathbf{x}, F=f) = \\mathbb{E}\\big[\\mathrm{Var}(Y \\mid R, \\mathbf{x}, F=f) \\mid \\mathbf{x}, F=f\\big] + \\mathrm{Var}\\big(\\mathbb{E}[Y \\mid R, \\mathbf{x}, F=f] \\mid \\mathbf{x}, F=f\\big)$。\n- 上文定义的按模态划分的高斯校准模型。\n\n您的任务是实现一个程序，对于一组给定的模态参数 $\\{(a_r,c_r,\\sigma_r)\\}_{r=1}^K$、一个预报值 $f$ 以及软分配权重 $\\{w_r\\}_{r=1}^K$，计算：\n1. 每个 $r \\in \\{1,\\dots,K\\}$ 的特定模态偏差订正均值 $\\mu_r = a_r + c_r f$。\n2. 混合预测均值 $m = \\mathbb{E}[Y \\mid \\mathbf{x}, F=f]$。\n3. 混合预测方差 $v = \\mathrm{Var}(Y \\mid \\mathbf{x}, F=f)$。\n\n如果由于舍入或微小的数值误差，所提供的权重满足 $\\sum_{r=1}^{K} w_r \\neq 1$，则在计算任何量之前，通过将每个权重除以 $\\sum_{r=1}^{K} w_r$ 来对其进行重新归一化。假设所有给定的 $\\sigma_r \\ge 0$，其中 $\\sigma_r = 0$ 代表一个确定性的特定模态订正。所有计算中，均值必须以开尔文（K）为单位，方差必须以开尔文的平方（$\\mathrm{K}^2$）为单位。将最终的混合均值以开尔文（K）表示，最终的混合方差以开尔文的平方（$\\mathrm{K}^2$）表示，每个值都四舍五入到六位小数。\n\n测试套件：\n为下列每组参数计算 $[m,v]$。在每种情况下，$F=f$ 是以开尔文为单位的给定预报值，模态参数和权重如列表所示。\n\n- 案例 1 (理想情况)：\n  - $K=2$,\n  - $f = 280.0$,\n  - $w = (0.7, 0.3)$,\n  - $a = (-2.0, 1.0)$,\n  - $c = (1.05, 0.95)$,\n  - $\\sigma = (1.5, 2.0)$.\n\n- 案例 2 (边界权重)：\n  - $K=2$,\n  - $f = 285.0$,\n  - $w = (1.0, 0.0)$,\n  - $a = (-1.0, 0.5)$,\n  - $c = (1.00, 0.90)$,\n  - $\\sigma = (1.0, 2.5)$.\n\n- 案例 3 (零方差模态)：\n  - $K=3$,\n  - $f = 300.0$,\n  - $w = (0.2, 0.5, 0.3)$,\n  - $a = (0.0, -3.0, 2.0)$,\n  - $c = (1.00, 1.02, 0.98)$,\n  - $\\sigma = (1.2, 0.0, 3.0)$.\n\n- 案例 4 (权重重新归一化)：\n  - $K=3$,\n  - $f = 260.0$,\n  - $w = (0.5005, 0.2002, 0.3004)$,\n  - $a = (-0.5, 1.5, -2.0)$,\n  - $c = (1.10, 0.97, 1.03)$,\n  - $\\sigma = (0.8, 1.1, 2.2)$.\n\n- 案例 5 (近简并权重分配)：\n  - $K=2$,\n  - $f = 310.0$,\n  - $w = (0.00001, 0.99999)$,\n  - $a = (-4.0, 0.0)$,\n  - $c = (1.05, 0.99)$,\n  - $\\sigma = (4.0, 1.5)$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含结果，格式为逗号分隔的方括号对列表。每个方括号对列出混合均值和方差，两者均四舍五入到六位小数，并按上述案例的顺序排列。例如：\n$[[m_1,v_1],[m_2,v_2],[m_3,v_3],[m_4,v_4],[m_5,v_5]]$",
            "solution": "该问题是有效的。这是一个适定且具有科学依据的练习，旨在将基本统计原理应用于数值天气预报模型后处理中的一个常见问题。该模型，一个用于偏差订正的高斯混合模型，是该领域的标准技术。所有参数和条件都已明确指定。\n\n本解答将首先根据给定的全期望定律和全方差定律推导混合预测均值和方差的表达式。然后，将使用这些推导出的公式来求解测试套件中的值。\n\n设 $Y$ 是表示真实近地面气温的随机变量，$F=f$ 是确定性模式预报，$\\mathbf{x}$ 是用于确定天气模态的预测因子向量。问题陈述指出 $Y$ 的预测分布是 $K$ 个高斯分布的有限混合。\n\n给定模态 $R=r$ 的特定模态模型为：\n$$\nY \\mid (R=r, \\mathbf{x}, F=f) \\sim \\mathcal{N}(\\mu_r, \\sigma_r^2)\n$$\n其中，特定模态的条件均值为 $\\mu_r = \\mathbb{E}[Y \\mid R=r, \\mathbf{x}, F=f] = a_r + c_r f$，特定模态的条件方差为 $\\mathrm{Var}(Y \\mid R=r, \\mathbf{x}, F=f) = \\sigma_r^2$。\n\n模态概率，或称混合权重，由 $w_r = \\mathbb{P}(R=r \\mid \\mathbf{x})$ 给出。为了评估总期望和总方差，我们将使用这些给定的权重，并假设它们代表条件概率 $\\mathbb{P}(R=r \\mid \\mathbf{x}, F=f)$。根据问题陈述，如果这些权重的总和不等于 $1$，则必须对其进行归一化，以确保它们构成一个有效的概率分布。设归一化后的权重为 $w'_r = w_r / \\sum_{j=1}^K w_j$。\n\n### 1. 混合预测均值 ($m$) 的推导\n\n混合预测均值 $m$ 是在给定预报 $f$ 和预测因子 $\\mathbf{x}$ 的条件下 $Y$ 的条件期望。我们应用全期望定律：\n$$\nm = \\mathbb{E}[Y \\mid \\mathbf{x}, F=f] = \\mathbb{E}\\big[\\mathbb{E}[Y \\mid R, \\mathbf{x}, F=f] \\mid \\mathbf{x}, F=f\\big]\n$$\n内部期望 $\\mathbb{E}[Y \\mid R, \\mathbf{x}, F=f]$ 是一个随机变量，当模态为 $r$ 时，其值为 $\\mu_r$。外部期望是关于模态指数 $R$ 的分布计算的，该分布由权重 $\\{w'_r\\}$ 给出。\n因此，外部期望是所有可能模态的加权和：\n$$\nm = \\sum_{r=1}^{K} \\mathbb{E}[Y \\mid R=r, \\mathbf{x}, F=f] \\cdot \\mathbb{P}(R=r \\mid \\mathbf{x}, F=f)\n$$\n代入已知量：\n$$\nm = \\sum_{r=1}^{K} \\mu_r w'_r = \\sum_{r=1}^{K} (a_r + c_r f) w'_r\n$$\n\n### 2. 混合预测方差 ($v$) 的推导\n\n混合预测方差 $v$ 是在给定 $f$ 和 $\\mathbf{x}$ 的条件下 $Y$ 的条件方差。我们应用全方差定律：\n$$\nv = \\mathrm{Var}(Y \\mid \\mathbf{x}, F=f) = \\mathbb{E}\\big[\\mathrm{Var}(Y \\mid R, \\mathbf{x}, F=f) \\mid \\mathbf{x}, F=f\\big] + \\mathrm{Var}\\big(\\mathbb{E}[Y \\mid R, \\mathbf{x}, F=f] \\mid \\mathbf{x}, F=f\\big)\n$$\n该公式由两部分组成：条件方差的期望和条件期望的方差。\n\n**第一部分：条件方差的期望**\n第一项是特定模态方差的期望。内部项 $\\mathrm{Var}(Y \\mid R, \\mathbf{x}, F=f)$ 是一个随机变量，当模态为 $r$ 时，其值为 $\\sigma_r^2$。其期望为：\n$$\n\\mathbb{E}\\big[\\mathrm{Var}(Y \\mid R, \\mathbf{x}, F=f) \\mid \\mathbf{x}, F=f\\big] = \\sum_{r=1}^{K} \\mathrm{Var}(Y \\mid R=r, \\mathbf{x}, F=f) \\cdot \\mathbb{P}(R=r \\mid \\mathbf{x}, F=f) = \\sum_{r=1}^{K} \\sigma_r^2 w'_r\n$$\n\n**第二部分：条件期望的方差**\n第二项是特定模态均值的方差。内部项 $\\mathbb{E}[Y \\mid R, \\mathbf{x}, F=f]$ 是一个随机变量，以概率 $w'_r$ 取值 $\\mu_r$。这个离散随机变量的方差由公式 $\\mathrm{Var}(X) = \\mathbb{E}[X^2] - (\\mathbb{E}[X])^2$ 给出。\n这里，$X = \\mathbb{E}[Y \\mid R, \\mathbf{x}, F=f]$。我们已经确定 $\\mathbb{E}[X] = m$。\n项 $\\mathbb{E}[X^2]$ 是：\n$$\n\\mathbb{E}\\big[ (\\mathbb{E}[Y \\mid R, \\mathbf{x}, F=f])^2 \\mid \\mathbf{x}, F=f \\big] = \\sum_{r=1}^{K} \\mu_r^2 w'_r\n$$\n因此，条件期望的方差是：\n$$\n\\mathrm{Var}\\big(\\mathbb{E}[Y \\mid R, \\mathbf{x}, F=f] \\mid \\mathbf{x}, F=f\\big) = \\left(\\sum_{r=1}^{K} \\mu_r^2 w'_r\\right) - m^2\n$$\n\n**组合各部分**\n将这两个部分相加得到总的混合方差 $v$：\n$$\nv = \\left(\\sum_{r=1}^{K} \\sigma_r^2 w'_r\\right) + \\left(\\left(\\sum_{r=1}^{K} \\mu_r^2 w'_r\\right) - m^2\\right)\n$$\n为了便于计算，可以将其方便地重新排列为：\n$$\nv = \\sum_{r=1}^{K} w'_r (\\sigma_r^2 + \\mu_r^2) - m^2\n$$\n\n### 算法摘要\n对于每个测试案例，执行以下步骤：\n1. 将输入权重 $\\{w_r\\}$ 归一化为 $\\{w'_r\\}$，使得 $\\sum_{r=1}^K w'_r = 1$。\n2. 计算特定模态均值 $\\{\\mu_r\\}$，公式为 $\\mu_r = a_r + c_r f$。\n3. 计算混合均值 $m$，作为特定模态均值的加权平均：$m = \\sum_r w'_r \\mu_r$。\n4. 使用推导出的公式计算混合方差 $v$：$v = \\sum_r w'_r (\\sigma_r^2 + \\mu_r^2) - m^2$。\n5. 将 $m$（单位：开尔文）和 $v$（单位：开尔文的平方）的最终结果四舍五入到六位小数。\n\n现在将实施此过程来处理提供的测试案例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates the mixture mean and variance for each case and prints the\n    results in the specified format.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"f\": 280.0,\n            \"w\": np.array([0.7, 0.3]),\n            \"a\": np.array([-2.0, 1.0]),\n            \"c\": np.array([1.05, 0.95]),\n            \"sigma\": np.array([1.5, 2.0]),\n        },\n        # Case 2 (boundary weights)\n        {\n            \"f\": 285.0,\n            \"w\": np.array([1.0, 0.0]),\n            \"a\": np.array([-1.0, 0.5]),\n            \"c\": np.array([1.00, 0.90]),\n            \"sigma\": np.array([1.0, 2.5]),\n        },\n        # Case 3 (zero-variance regime)\n        {\n            \"f\": 300.0,\n            \"w\": np.array([0.2, 0.5, 0.3]),\n            \"a\": np.array([0.0, -3.0, 2.0]),\n            \"c\": np.array([1.00, 1.02, 0.98]),\n            \"sigma\": np.array([1.2, 0.0, 3.0]),\n        },\n        # Case 4 (renormalization of weights)\n        {\n            \"f\": 260.0,\n            \"w\": np.array([0.5005, 0.2002, 0.3004]),\n            \"a\": np.array([-0.5, 1.5, -2.0]),\n            \"c\": np.array([1.10, 0.97, 1.03]),\n            \"sigma\": np.array([0.8, 1.1, 2.2]),\n        },\n        # Case 5 (near-degenerate weight allocation)\n        {\n            \"f\": 310.0,\n            \"w\": np.array([0.00001, 0.99999]),\n            \"a\": np.array([-4.0, 0.0]),\n            \"c\": np.array([1.05, 0.99]),\n            \"sigma\": np.array([4.0, 1.5]),\n        },\n    ]\n\n    def calculate_mixture_properties(f, w, a, c, sigma):\n        \"\"\"\n        Computes the mixture predictive mean and variance.\n\n        Args:\n            f (float): The deterministic model forecast value.\n            w (np.ndarray): Array of soft assignment weights for each regime.\n            a (np.ndarray): Array of additive offset parameters for each regime.\n            c (np.ndarray): Array of multiplicative calibration coefficients.\n            sigma (np.ndarray): Array of standard deviations for each regime.\n\n        Returns:\n            tuple[float, float]: A tuple containing the mixture mean and variance.\n        \"\"\"\n        # Step 1: Normalize weights if their sum is not 1.\n        w_sum = np.sum(w)\n        if not np.isclose(w_sum, 1.0):\n            w_norm = w / w_sum\n        else:\n            w_norm = w\n        \n        # Step 2: Calculate regime-specific means.\n        # mu_r = a_r + c_r * f\n        mu_r = a + c * f\n\n        # Step 3: Calculate the mixture predictive mean (m).\n        # m = sum(w_r' * mu_r)\n        m = np.sum(w_norm * mu_r)\n\n        # Step 4: Calculate the mixture predictive variance (v).\n        # v = E[Var(Y|R)] + Var(E[Y|R])\n        # v = sum(w_r' * sigma_r^2) + { sum(w_r' * mu_r^2) - m^2 }\n        # v = sum(w_r' * (sigma_r^2 + mu_r^2)) - m^2\n        regime_vars = sigma**2\n        v = np.sum(w_norm * (regime_vars + mu_r**2)) - m**2\n\n        return m, v\n\n    results_list = []\n    for case in test_cases:\n        m, v = calculate_mixture_properties(case[\"f\"], case[\"w\"], case[\"a\"], case[\"c\"], case[\"sigma\"])\n        \n        # Format the result pair as a string, rounding to six decimal places.\n        results_list.append(f\"[{m:.6f},{v:.6f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "统计模型的复杂性并不能保证其输出结果的物理真实性。无论采用何种偏差校正技术，其最终产物都必须遵循基本的物理守恒定律，例如能量守恒。本练习将焦点从统计拟合转向物理约束，要求你检验经过校正的地表能量通量分量是否仍然满足地表能量平衡（Surface Energy Balance, SEB）方程，确保后处理结果在物理上是合理且自洽的 。",
            "id": "4076541",
            "problem": "考虑一个在数值天气预报（NWP）和气候建模中的后处理和偏差校正验证问题。校准后，调整后的地表能量通量分量必须保持物理上的合理性，并且必须满足由地表能量平衡（SEB）所编码的能量守恒定律。陆地-大气界面的地表能量平衡由以下基本守恒定律给出\n$$\nR_n = H + L + G + S,\n$$\n其中，$R_n$ 是净辐射，$H$ 是感热通量，$L$ 是潜热通量，$G$ 是地表热通量，$S$ 是能量储存或余项，每个分量的单位都是瓦特/平方米（W m$^{-2}$）。在每个时间步长，该等式必须在指定的容差范围内成立。\n\n假设原始模型输出为单个网格单元提供了 $R_n$、$H$、$L$、$G$ 和 $S$ 的时间序列。后处理对每个分量应用仿射校正：\n$$\nX^{\\mathrm{corr}} = s_X \\left( X^{\\mathrm{raw}} + b_X \\right),\n$$\n其中 $X \\in \\{R_n, H, L, G, S\\}$，$s_X$ 是一个无量纲的乘法缩放因子，$b_X$ 是一个以瓦特/平方米（W m$^{-2}$）为单位的加性偏差。根据能量守恒定律，物理上一致的校正必须在每个时间步长 $t$ 满足：\n$$\n\\epsilon_t \\equiv R_n^{\\mathrm{corr}}(t) - \\left[H^{\\mathrm{corr}}(t) + L^{\\mathrm{corr}}(t) + G^{\\mathrm{corr}}(t) + S^{\\mathrm{corr}}(t)\\right],\n$$\n且 $|\\epsilon_t| \\le \\tau$，其中 $\\tau$ 是一个以瓦特/平方米（W m$^{-2}$）为单位的非负容差参数。此外，物理上合理的通量大小必须对所有分量 $X$ 和所有时间步长 $t$ 满足绝对值边界 $|X^{\\mathrm{corr}}(t)| \\le M$。除非测试用例另有规定，否则使用 $M = 1500$ W m$^{-2}$。\n\n您的任务是实现一个程序，为每个提供的测试用例，计算最大绝对能量收支余项\n$$\n\\max_t |\\epsilon_t|\n$$\n并确定一个布尔违规标志，该标志为真的条件是当且仅当以下任一情况成立：\n- 存在时间步长 $t$ 使得 $|\\epsilon_t|  \\tau$。\n- 存在分量 $X$ 和时间步长 $t$ 使得 $|X^{\\mathrm{corr}}(t)|  M$。\n\n输出必须遵守以下规范：\n- 最大绝对余项必须以浮点数形式报告，单位为瓦特/平方米（W m$^{-2}$），并精确到 $3$ 位小数。\n- 违规标志必须是布尔值。\n- 对于每个测试用例，输出必须是 $[\\text{max\\_abs\\_residual}, \\text{violation\\_flag}]$ 形式的列表。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[[0.123,\\mathrm{True}],[0.000,\\mathrm{False}]]$）。\n\n使用以下测试套件，其中包含一系列现实场景：\n\n- 测试用例 $1$（理想情况，保守校正，物理上合理的量值）：\n  - 原始通量 (W m$^{-2}$):\n    - $R_n$: $[400, 300, 100, 50]$\n    - $H$: $[150, 120, 50, 20]$\n    - $L$: $[200, 150, 40, 20]$\n    - $G$: $[30, 20, 5, 5]$\n    - $S$: $[20, 10, 5, 5]$\n  - 校正:\n    - $s_{R_n} = 1.05$, $b_{R_n} = 2.0$\n    - $s_H = 1.05$, $b_H = 0.5$\n    - $s_L = 1.05$, $b_L = 0.5$\n    - $s_G = 1.05$, $b_G = 0.5$\n    - $s_S = 1.05$, $b_S = 0.5$\n  - 容差: $\\tau = 0.5$ W m$^{-2}$，边界: $M = 1500$ W m$^{-2}$。\n\n- 测试用例 $2$（非保守加性偏差，微小的闭合违规）：\n  - 原始通量 (W m$^{-2}$) 与测试用例 $1$ 相同。\n  - 校正:\n    - $s_{R_n} = 1.0$, $b_{R_n} = 1.0$\n    - $s_H = 1.0$, $b_H = 0.1$\n    - $s_L = 1.0, b_L = 0.2$\n    - $s_G = 1.0, b_G = 0.3$\n    - $s_S = 1.0, b_S = 0.3$\n  - 容差: $\\tau = 0.05$ W m$^{-2}$，边界: $M = 1500$ W m$^{-2}$。\n\n- 测试用例 $3$（夜间条件，因结露导致负潜热，保守校正）：\n  - 原始通量 (W m$^{-2}$):\n    - $R_n$: $[-50, -20]$\n    - $H$: $[-20, -10]$\n    - $L$: $[-25, -5]$\n    - $G$: $[0, -3]$\n    - $S$: $[-5, -2]$\n  - 校正:\n    - $s_{R_n} = 1.0$, $b_{R_n} = -1.0$\n    - $s_H = 1.0, b_H = -0.25$\n    - $s_L = 1.0, b_L = -0.25$\n    - $s_G = 1.0, b_G = 0.0$\n    - $s_S = 1.0, b_S = -0.5$\n  - 容差: $\\tau = 0.5$ W m$^{-2}$，边界: $M = 1500$ W m$^{-2}$。\n\n- 测试用例 $4$（缩放后物理上不合理的量值，闭合成立但边界违规）：\n  - 原始通量 (W m$^{-2}$):\n    - $R_n$: $[1000]$\n    - $H$: $[600]$\n    - $L$: $[350]$\n    - $G$: $[30]$\n    - $S$: $[20]$\n  - 校正:\n    - $s_{R_n} = 2.8, b_{R_n} = 0.0$\n    - $s_H = 2.8, b_H = 0.0$\n    - $s_L = 2.8, b_L = 0.0$\n    - $s_G = 2.8, b_G = 0.0$\n    - $s_S = 2.8, b_S = 0.0$\n  - 容差: $\\tau = 1.0$ W m$^{-2}$，边界: $M = 1500$ W m$^{-2}$。\n\n- 测试用例 $5$（边界情况，原始通量为零，余项等于容差）：\n  - 原始通量 (W m$^{-2}$):\n    - $R_n$: $[0, 0, 0]$\n    - $H$: $[0, 0, 0]$\n    - $L$: $[0, 0, 0]$\n    - $G$: $[0, 0, 0]$\n    - $S$: $[0, 0, 0]$\n  - 校正:\n    - $s_{R_n} = 1.0, b_{R_n} = 0.2$\n    - $s_H = 1.0, b_H = 0.05$\n    - $s_L = 1.0, b_L = 0.05$\n    - $s_G = 1.0, b_G = 0.0$\n    - $s_S = 1.0, b_S = 0.0$\n  - 容差: $\\tau = 0.1$ W m$^{-2}$，边界: $M = 1500$ W m$^{-2}$。\n\n实现程序以：\n- 对每个通量分量时间序列应用指定的校正。\n- 计算余项时间序列 $\\epsilon_t$。\n- 计算 $\\max_t |\\epsilon_t|$ 并将其四舍五入到恰好 $3$ 位小数，单位为瓦特/平方米（W m$^{-2}$）。\n- 根据上述规则计算违规标志。\n- 打印单行内容，其中包含 $5$ 个测试用例的结果列表，格式严格为 $[[\\text{float},\\text{bool}],\\ldots]$。",
            "solution": "该问题陈述已经过验证，被认为是具有科学依据、定义明确且客观的。它提出了一个清晰且可形式化的任务，该任务植根于地表能量守恒这一基本物理原理，这是气候学和数值天气预报的基石。该问题是自包含的，为获得唯一且可验证的解提供了所有必要的数据和约束。\n\n任务是根据两个主要标准验证后处理的地表能量通量时间序列：能量守恒和通量量值的物理合理性。为完成每个测试用例的算法流程如下：\n\n1.  **数据提取与表示**：每个通量分量 $X \\in \\{R_n, H, L, G, S\\}$ 的原始时间序列表示为一维数值数组，记作 $X^{\\mathrm{raw}}$。校正参数 $s_X$ 和 $b_X$ 以及验证阈值 $\\tau$ 和 $M$ 作为标量值存储。\n\n2.  **应用仿射校正**：对于每个通量分量 $X$，通过对原始时间序列的每个元素应用仿射变换来计算校正后的时间序列 $X^{\\mathrm{corr}}$。该变换由以下方程给出：\n    $$\n    X^{\\mathrm{corr}}(t) = s_X \\left( X^{\\mathrm{raw}}(t) + b_X \\right)\n    $$\n    对五个通量分量中的每一个，在所有时间步长 $t$ 上执行此操作。\n\n3.  **物理量值验证**：第一个验证检查是物理合理性。如果在任何时间步长，任何校正后的通量分量的绝对值超过了预定义的边界 $M$，则发生违规。在数学上，如果满足以下条件，则会标记违规：\n    $$\n    \\exists X \\in \\{R_n, H, L, G, S\\}, \\exists t \\quad \\text{such that} \\quad |X^{\\mathrm{corr}}(t)| > M\n    $$\n    为了实现这一点，我们找到所有校正后通量分量和所有时间步长的最大绝对值。如果该最大值超过 $M$，则将 `magnitude_violation` 标志设置为真。\n\n4.  **能量闭合验证**：第二个验证检查确保校正后的通量在给定容差 $\\tau$ 内遵循能量守恒原理，正如地表能量平衡（SEB）方程所表达的那样。能量收支余项 $\\epsilon_t$ 在每个时间步长 $t$ 计算如下：\n    $$\n    \\epsilon_t = R_n^{\\mathrm{corr}}(t) - \\left( H^{\\mathrm{corr}}(t) + L^{\\mathrm{corr}}(t) + G^{\\mathrm{corr}}(t) + S^{\\mathrm{corr}}(t) \\right)\n    $$\n    这将产生一个余项的时间序列 $\\epsilon$。\n\n5.  **余项分析**：从余项时间序列 $\\epsilon$ 中，判断能量闭合的主要度量是整个时段内的最大绝对余项：\n    $$\n    \\max_t |\\epsilon_t|\n    $$\n    计算该值，并作为输出的第一部分报告，精确到 $3$ 位小数。\n\n6.  **闭合违规检查**：将最大绝对余项与容差 $\\tau$ 进行比较。如果此余项超过容差，则发生闭合违规。如果满足以下条件，则 `closure_violation` 标志设置为真：\n    $$\n    \\max_t |\\epsilon_t| > \\tau\n    $$\n\n7.  **最终违规判定**：测试用例的总体违规标志由两个独立违规标志的逻辑或确定。`violation_flag` 为真的条件是量值约束或能量闭合约束任一被违反：\n    $$\n    \\text{violation\\_flag} = (\\text{magnitude\\_violation}) \\lor (\\text{closure\\_violation})\n    $$\n\n8.  **输出格式化**：单个测试用例的最终结果是一个包含两个元素的列表，其中包括计算出的最大绝对余项（作为浮点数）和最终的布尔违规标志。完整的程序将为所有指定的测试用例返回一个包含这些结果的列表。实现将利用 `numpy` 库对通量时间序列数据进行高效的向量化操作。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the surface energy balance validation problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (happy path, conservative corrections)\n        {\n            \"raw_fluxes\": {\n                \"Rn\": np.array([400, 300, 100, 50]),\n                \"H\": np.array([150, 120, 50, 20]),\n                \"L\": np.array([200, 150, 40, 20]),\n                \"G\": np.array([30, 20, 5, 5]),\n                \"S\": np.array([20, 10, 5, 5]),\n            },\n            \"corrections\": {\n                \"s\": {\"Rn\": 1.05, \"H\": 1.05, \"L\": 1.05, \"G\": 1.05, \"S\": 1.05},\n                \"b\": {\"Rn\": 2.0, \"H\": 0.5, \"L\": 0.5, \"G\": 0.5, \"S\": 0.5},\n            },\n            \"params\": {\"tau\": 0.5, \"M\": 1500.0},\n        },\n        # Test Case 2 (non-conservative additive biases)\n        {\n            \"raw_fluxes\": {\n                \"Rn\": np.array([400, 300, 100, 50]),\n                \"H\": np.array([150, 120, 50, 20]),\n                \"L\": np.array([200, 150, 40, 20]),\n                \"G\": np.array([30, 20, 5, 5]),\n                \"S\": np.array([20, 10, 5, 5]),\n            },\n            \"corrections\": {\n                \"s\": {\"Rn\": 1.0, \"H\": 1.0, \"L\": 1.0, \"G\": 1.0, \"S\": 1.0},\n                \"b\": {\"Rn\": 1.0, \"H\": 0.1, \"L\": 0.2, \"G\": 0.3, \"S\": 0.3},\n            },\n            \"params\": {\"tau\": 0.05, \"M\": 1500.0},\n        },\n        # Test Case 3 (nighttime conditions, conservative corrections)\n        {\n            \"raw_fluxes\": {\n                \"Rn\": np.array([-50, -20]),\n                \"H\": np.array([-20, -10]),\n                \"L\": np.array([-25, -5]),\n                \"G\": np.array([0, -3]),\n                \"S\": np.array([-5, -2]),\n            },\n            \"corrections\": {\n                \"s\": {\"Rn\": 1.0, \"H\": 1.0, \"L\": 1.0, \"G\": 1.0, \"S\": 1.0},\n                \"b\": {\"Rn\": -1.0, \"H\": -0.25, \"L\": -0.25, \"G\": 0.0, \"S\": -0.5},\n            },\n            \"params\": {\"tau\": 0.5, \"M\": 1500.0},\n        },\n        # Test Case 4 (implausible magnitudes, bound violation)\n        {\n            \"raw_fluxes\": {\n                \"Rn\": np.array([1000]),\n                \"H\": np.array([600]),\n                \"L\": np.array([350]),\n                \"G\": np.array([30]),\n                \"S\": np.array([20]),\n            },\n            \"corrections\": {\n                \"s\": {\"Rn\": 2.8, \"H\": 2.8, \"L\": 2.8, \"G\": 2.8, \"S\": 2.8},\n                \"b\": {\"Rn\": 0.0, \"H\": 0.0, \"L\": 0.0, \"G\": 0.0, \"S\": 0.0},\n            },\n            \"params\": {\"tau\": 1.0, \"M\": 1500.0},\n        },\n        # Test Case 5 (boundary case, residual equals tolerance)\n        {\n            \"raw_fluxes\": {\n                \"Rn\": np.array([0, 0, 0]),\n                \"H\": np.array([0, 0, 0]),\n                \"L\": np.array([0, 0, 0]),\n                \"G\": np.array([0, 0, 0]),\n                \"S\": np.array([0, 0, 0]),\n            },\n            \"corrections\": {\n                \"s\": {\"Rn\": 1.0, \"H\": 1.0, \"L\": 1.0, \"G\": 1.0, \"S\": 1.0},\n                \"b\": {\"Rn\": 0.2, \"H\": 0.05, \"L\": 0.05, \"G\": 0.0, \"S\": 0.0},\n            },\n            \"params\": {\"tau\": 0.1, \"M\": 1500.0},\n        },\n    ]\n\n    results = []\n    flux_components = [\"Rn\", \"H\", \"L\", \"G\", \"S\"]\n    \n    for case in test_cases:\n        raw_fluxes = case[\"raw_fluxes\"]\n        corrections = case[\"corrections\"]\n        params = case[\"params\"]\n        tau = params[\"tau\"]\n        M = params[\"M\"]\n\n        # Apply affine corrections\n        corr_fluxes = {}\n        for comp in flux_components:\n            s_X = corrections[\"s\"][comp]\n            b_X = corrections[\"b\"][comp]\n            X_raw = raw_fluxes[comp]\n            corr_fluxes[comp] = s_X * (X_raw + b_X)\n\n        # Check for physical magnitude violation\n        max_abs_magnitude = 0.0\n        for comp in flux_components:\n            component_max_abs = np.max(np.abs(corr_fluxes[comp]))\n            if component_max_abs > max_abs_magnitude:\n                max_abs_magnitude = component_max_abs\n        \n        magnitude_violation = max_abs_magnitude > M\n\n        # Calculate energy budget residual\n        outgoing_flux_sum = (corr_fluxes[\"H\"] + corr_fluxes[\"L\"] + \n                             corr_fluxes[\"G\"] + corr_fluxes[\"S\"])\n        epsilon = corr_fluxes[\"Rn\"] - outgoing_flux_sum\n        \n        # Calculate max absolute residual\n        max_abs_residual = np.max(np.abs(epsilon))\n\n        # Check for energy closure violation\n        closure_violation = max_abs_residual > tau\n\n        # Determine final violation flag\n        violation_flag = magnitude_violation or closure_violation\n\n        results.append([max_abs_residual, violation_flag])\n\n    # Format the final output string exactly as specified\n    result_strings = []\n    for res in results:\n        max_res_val, flag_val = res\n        # Format float to 3 decimal places and boolean to string 'True'/'False'\n        res_str = f\"[{max_res_val:.3f},{str(flag_val)}]\"\n        result_strings.append(res_str)\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n\n```"
        }
    ]
}