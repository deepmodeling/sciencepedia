{
    "hands_on_practices": [
        {
            "introduction": "在模拟城市物理过程之前，我们首先需要量化城市的物理结构。本练习将指导您如何将原始的建筑数据（例如来自地理信息系统GIS的数据）转换为城市冠层模型所需的基本形态学参数，如平面面积分数 $\\lambda_p$、迎风面积指数 $\\lambda_f$ 和平均建筑高度 $H$。此练习还通过数据插补解决了现实世界中数据不完整的问题，这对于实际建模工作至关重要。",
            "id": "4107937",
            "problem": "您的任务是为城市冠层参数化 (UCP) 网格单元推导、实现和测试一个算法，用以计算建筑平面面积分数 $\\lambda_p$、迎风面积指数 $\\lambda_f$（针对指定风向）以及平面面积加权平均建筑高度 $H$。该算法必须从基本的几何和物理定义出发，并必须指定稳健的程序来处理网格单元内不完整的建筑属性数据和混合土地利用情况。所有角度必须以弧度表示。所有类似长度的量必须以米表示，所有面积必须以平方米表示。每个测试用例的最终结果必须是浮点数。程序必须输出一行，其中包含为所提供的测试套件计算出的量，其格式必须严格为列表的列表，每个内部列表包含一个测试用例的 $[\\lambda_p,\\lambda_f,H]$。每个浮点数必须四舍五入到六位小数。\n\n基本定义：\n- 建筑平面面积分数 $\\lambda_p$ 定义为总建筑平面面积与网格单元总土地面积之比：$$\\lambda_p = \\frac{\\sum_{i=1}^{N} A_i}{A_{\\text{cell}}},$$ 其中 $A_i$ 是建筑占地面积，$A_{\\text{cell}}$ 是网格单元的总土地面积。单位：$\\lambda_p$ 是无量纲的。\n- 风向为 $\\phi$ 时的迎风面积指数 $\\lambda_f$ 定义为垂直于风矢量的建筑迎风面积总和与网格单元总土地面积之比：$$\\lambda_f(\\phi) = \\frac{\\sum_{i=1}^{N} F_i(\\phi)}{A_{\\text{cell}}},$$ 其中 $F_i(\\phi)$ 是建筑物 $i$ 投射到垂直于风矢量平面上的迎风面积。单位：$\\lambda_f$ 是无量纲的。\n- 平面面积加权平均建筑高度定义为 $$H = \\frac{\\sum_{i=1}^{N} h_i A_i}{\\sum_{i=1}^{N} A_i},$$ 其中 $h_i$ 是建筑高度。单位：$H$ 以米为单位。如果 $\\sum_{i} A_i = 0$，则定义 $H = 0$。\n\n算法中使用的几何基础：\n- 每个建筑占地面积近似为一个矩形，其特征为宽度 $w_i$、长度 $l_i$ 和一个从 $x$ 轴顺时针测量的方向角 $\\alpha_i$。网格单元的风向角 $\\phi$ 是从 $x$ 轴顺时针测量的。所有角度均以弧度为单位。\n- 对于矩形占地面积，垂直于风向的建筑迎风宽度计算如下 $$b_i(\\phi) = \\left|w_i \\cos(\\alpha_i - \\phi)\\right| + \\left|l_i \\sin(\\alpha_i - \\phi)\\right|.$$ 迎风面积则为 $$F_i(\\phi) = h_i\\, b_i(\\phi).$$\n- 如果建筑方向 $\\alpha_i$ 不可用，则使用柯西投影结果，即凸形在所有方向上的平均投影宽度。对于矩形，角度平均投影宽度为 $$\\overline{b_i} = \\frac{2\\,(w_i + l_i)}{\\pi},$$ 该值与 $\\phi$ 无关，并在 $\\alpha_i$ 未知时提供一个保守估计。\n\n不完整数据和混合土地利用的补全规则：\n- 土地利用类别 $c_i$ 可以是 residential、commercial 或 industrial 中的一种，由集合 $\\{{\\text{residential}}, {\\text{commercial}}, {\\text{industrial}}\\}$ 表示。该算法必须通过在属性缺失时应用特定类别的默认值，并在 $\\lambda_p$、$\\lambda_f$ 和 $H$ 的定义中汇总所有类别的所有建筑物，来处理网格单元中的混合土地利用。\n- 缺失的建筑高度 $h_i$：\n  1. 计算当前网格单元内 $c_i$ 类别可用高度的中位数。如果当前网格单元中至少有一个 $c_i$ 类的高度是已知的，则使用此中位数作为补全的 $h_i$。\n  2. 如果当前网格单元中没有已知的 $c_i$ 类高度，则使用类别典型高度 $h^{\\text{typ}}_{c}$：\n     - Residential: $h^{\\text{typ}}_{\\text{residential}} = 9$ 米。\n     - Commercial: $h^{\\text{typ}}_{\\text{commercial}} = 18$ 米。\n     - Industrial: $h^{\\text{typ}}_{\\text{industrial}} = 12$ 米。\n- 缺失的占地面积边长 $w_i$ 和 $l_i$ 但占地面积 $A_i$ 已知：\n  1. 使用特定类别的典型长宽比 $r_c = \\frac{w}{l}$ 重建 $w_i$ 和 $l_i$：\n     - Residential: $r_{\\text{residential}} = 0.5$。\n     - Commercial: $r_{\\text{commercial}} = 1.0$。\n     - Industrial: $r_{\\text{industrial}} = 0.25$。\n  2. 使用 $A_i = w_i\\, l_i$ 和 $r_c = \\frac{w_i}{l_i}$，推导出 $$w_i = \\sqrt{A_i\\, r_c}, \\quad l_i = \\sqrt{\\frac{A_i}{r_c}}.$$\n- 缺失的方向角 $\\alpha_i$：\n  - 使用角度平均投影宽度 $\\overline{b_i} = \\frac{2\\,(w_i + l_i)}{\\pi}$ 并设置 $F_i(\\phi) = h_i\\, \\overline{b_i}$。\n- 当任何属性缺失时，按以下顺序应用上述补全规则：如果需要，重建 $w_i$ 和 $l_i$；补全 $h_i$；然后使用已知的 $\\alpha_i$ 或角度平均的 $\\overline{b_i}$ 计算 $b_i(\\phi)$。如果建筑占地面积 $A_i$ 缺失或非正数，则该建筑应从所有总和中排除。\n\n数值和物理单位：\n- 输入和输出高度 $h_i$ 和 $H$ 必须以米为单位。\n- 输入宽度 $w_i$ 和长度 $l_i$ 必须以米为单位。\n- 占地面积 $A_i$ 和网格单元面积 $A_{\\text{cell}}$ 必须以平方米为单位。\n- 角度 $\\alpha_i$ 和 $\\phi$ 必须以弧度为单位。\n- 建筑平面面积分数 $\\lambda_p$ 和迎风面积指数 $\\lambda_f$ 是无量纲的。\n\n测试套件（五个网格单元）：\n对于每个网格单元 $j$，给定 $A_{\\text{cell}}$、$\\phi$ 以及一个包含建筑物属性 $(A_i, w_i, l_i, \\alpha_i, h_i, c_i)$ 的列表；缺失值已标出，必须按上述方法进行补全。\n\n- 测试用例 1（数据完整的通用情况）：\n  - $A_{\\text{cell}} = 250000$。\n  - $\\phi = \\frac{\\pi}{6}$。\n  - 建筑物：\n    1. $(A_1 = 1200,\\; w_1 = 30,\\; l_1 = 40,\\; \\alpha_1 = \\frac{\\pi}{4},\\; h_1 = 20,\\; c_1 = \\text{commercial})$。\n    2. $(A_2 = 800,\\; w_2 = 20,\\; l_2 = 40,\\; \\alpha_2 = \\frac{\\pi}{3},\\; h_2 = 12,\\; c_2 = \\text{residential})$。\n- 测试用例 2（缺失高度由同类别中位数补全）：\n  - $A_{\\text{cell}} = 250000$。\n  - $\\phi = \\frac{\\pi}{3}$。\n  - 建筑物：\n    1. $(A_1 = 600,\\; w_1 = 15,\\; l_1 = 40,\\; \\alpha_1 = \\frac{\\pi}{8},\\; h_1 = \\text{missing},\\; c_1 = \\text{residential})$。\n    2. $(A_2 = 500,\\; w_2 = 10,\\; l_2 = 50,\\; \\alpha_2 = \\frac{\\pi}{5},\\; h_2 = 10,\\; c_2 = \\text{residential})$。\n    3. $(A_3 = 900,\\; w_3 = 30,\\; l_3 = 30,\\; \\alpha_3 = \\frac{\\pi}{6},\\; h_3 = 18,\\; c_3 = \\text{commercial})$。\n- 测试用例 3（缺失方向角和缺失高度由类别典型值补全）：\n  - $A_{\\text{cell}} = 250000$。\n  - $\\phi = \\frac{\\pi}{2}$。\n  - 建筑物：\n    1. $(A_1 = 2000,\\; w_1 = 25,\\; l_1 = 80,\\; \\alpha_1 = \\text{missing},\\; h_1 = 15,\\; c_1 = \\text{industrial})$。\n    2. $(A_2 = 600,\\; w_2 = 12,\\; l_2 = 50,\\; \\alpha_2 = \\text{missing},\\; h_2 = \\text{missing},\\; c_2 = \\text{residential})$。\n- 测试用例 4（缺失的宽度和长度根据面积和类别长宽比重建，方向角可用性混合，缺失高度由类别典型值补全）：\n  - $A_{\\text{cell}} = 250000$。\n  - $\\phi = 0$。\n  - 建筑物：\n    1. $(A_1 = 1000,\\; w_1 = \\text{missing},\\; l_1 = \\text{missing},\\; \\alpha_1 = \\frac{\\pi}{4},\\; h_1 = 20,\\; c_1 = \\text{commercial})$。\n    2. $(A_2 = 1500,\\; w_2 = \\text{missing},\\; l_2 = \\text{missing},\\; \\alpha_2 = \\text{missing},\\; h_2 = \\text{missing},\\; c_2 = \\text{industrial})$。\n- 测试用例 5（边缘情况：网格单元内没有建筑物）：\n  - $A_{\\text{cell}} = 250000$。\n  - $\\phi = \\frac{\\pi}{2}$。\n  - 建筑物：无。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含结果，格式为列表的列表，每个内部列表为对应测试用例的 $[\\lambda_p,\\lambda_f,H]$，每个浮点数四舍五入至六位小数。例如：$$[[x_{11},x_{12},x_{13}],[x_{21},x_{22},x_{23}],\\dots],$$ 其中 $x_{j1}=\\lambda_p$，$x_{j2}=\\lambda_f$，$x_{j3}=H$ 是测试用例 $j$ 的结果。",
            "solution": "我们从城市冠层参数化 (UCP) 关于建筑平面面积分数、迎风面积指数和平均建筑高度的基本定义开始。建筑平面面积分数 $\\lambda_p$ 定义为比率 $\\lambda_p = \\frac{\\sum_{i=1}^{N} A_i}{A_{\\text{cell}}}$，它汇总了网格单元内所有的建筑占地面积 $A_i$，并用网格单元面积 $A_{\\text{cell}}$ 进行归一化。它是无量纲的，用于衡量建筑物的面积覆盖率。\n\n迎风面积指数 $\\lambda_f(\\phi)$ 衡量垂直于风向 $\\phi$ 投射的总建筑迎风面积，并按网格单元面积进行归一化。对于一个由宽度 $w_i$、长度 $l_i$、方向角 $\\alpha_i$ 和高度 $h_i$ 表示的矩形建筑物，其垂直于风向的投影宽度是通过将矩形几何投影到垂直于风矢量的直线上得到的。如果矩形边缘与 $\\alpha_i$ 对齐，且风向为 $\\phi$，则投影宽度可写为 $b_i(\\phi) = \\left|w_i \\cos(\\alpha_i - \\phi)\\right| + \\left|l_i \\sin(\\alpha_i - \\phi)\\right|$。这是通过将矩形范围在垂直于风的轴上的投影进行分解得出的：沿矩形宽度方向的贡献由 $\\cos(\\alpha_i - \\phi)$ 调节，而沿矩形长度方向的贡献由 $\\sin(\\alpha_i - \\phi)$ 调节，绝对值确保了非负性，因为宽度是几何度量。建筑物的迎风面积则为 $F_i(\\phi) = h_i\\, b_i(\\phi)$，从而得到 $\\lambda_f(\\phi) = \\frac{\\sum_i F_i(\\phi)}{A_{\\text{cell}}}$，这也是无量纲的。\n\n当方向角 $\\alpha_i$ 缺失时，我们无法直接计算 $b_i(\\phi)$。一种稳健的替代方法是使用针对凸形的柯西投影定理，该定理指出，凸曲线到一条直线上的正交投影的平均长度（在所有角度上平均）等于周长除以 $\\pi$。对于宽度为 $w_i$、长度为 $l_i$ 的矩形，其周长为 $2(w_i + l_i)$，因此角度平均投影宽度为 $\\overline{b_i} = \\frac{2(w_i + l_i)}{\\pi}$。此估计值与 $\\phi$ 无关，并在 $\\alpha_i$ 未知时提供了一个保守且物理上一致的替代值。然后我们取 $F_i(\\phi) = h_i\\, \\overline{b_i}$。\n\n平均建筑高度 $H$ 以平面面积加权的方式计算：$H = \\frac{\\sum_i h_i A_i}{\\sum_i A_i}$。这种加权在城市参数化中很常见，用以反映较大建筑物对城市冠层属性的贡献。如果没有建筑物（即 $\\sum_i A_i = 0$），我们定义 $H = 0$ 以避免除以零，并表示没有冠层存在。\n\n处理不完整数据遵循以下补全逻辑：\n- 缺失的高度 $h_i$ 首先尝试使用当前网格单元中已知高度计算的同类别中位数进行补全。中位数是稳健的，可以避免异常值偏差。如果该类别在网格单元中没有已知高度，我们则使用根据典型城市形态得出的类别典型高度：residential $h^{\\text{typ}}_{\\text{residential}} = 9$ 米（约三层楼），commercial $h^{\\text{typ}}_{\\text{commercial}} = 18$ 米（中层办公室），以及 industrial $h^{\\text{typ}}_{\\text{industrial}} = 12$ 米（仓库式结构）。这些值是合理的，并与城市气候学设置一致。\n- 缺失宽度和长度但占地面积 $A_i$ 已知时，使用该类别的 $r_c = \\frac{w}{l}$ 进行重建。通过 $A_i = w_i l_i$ 和 $r_c = \\frac{w_i}{l_i}$，我们求解得到 $w_i = \\sqrt{A_i r_c}$ 和 $l_i = \\sqrt{\\frac{A_i}{r_c}}$。典型的长宽比反映了不同类别建筑占地的伸长程度：residential $r_{\\text{residential}} = 0.5$（细长的排屋或公寓楼），commercial $r_{\\text{commercial}} = 1.0$（大致方形的占地），以及 industrial $r_{\\text{industrial}} = 0.25$（细长的棚屋）。\n- 缺失的方向角 $\\alpha_i$ 会调用基于柯西投影定理的角度平均投影宽度 $\\overline{b_i} = \\frac{2(w_i + l_i)}{\\pi}$。\n\n单个网格单元的算法步骤：\n1. 验证 $A_{\\text{cell}} > 0$。\n2. 过滤掉任何 $A_i$ 缺失或非正数的建筑物。计算所有被包含建筑物的 $\\sum_i A_i$。\n3. 计算 $\\lambda_p = \\frac{\\sum_i A_i}{A_{\\text{cell}}}$。\n4. 对每个建筑物：\n   a. 如果 $w_i$ 和 $l_i$ 都缺失，使用类别长宽比 $r_c$ 和建筑物面积 $A_i$ 通过公式 $w_i = \\sqrt{A_i r_c}$ 和 $l_i = \\sqrt{\\frac{A_i}{r_c}}$ 重建它们。\n   b. 如果 $h_i$ 缺失，使用当前网格单元内已知 $h_i$ 的同类别中位数进行补全；如果不存在，则使用 $h^{\\text{typ}}_{c_i}$。\n   c. 计算投影宽度：如果 $\\alpha_i$ 已知，则 $b_i(\\phi) = \\left|w_i \\cos(\\alpha_i - \\phi)\\right| + \\left|l_i \\sin(\\alpha_i - \\phi)\\right|$；否则，使用 $\\overline{b_i} = \\frac{2(w_i + l_i)}{\\pi}$。\n   d. 计算 $F_i(\\phi) = h_i\\, b_i(\\phi)$。\n5. 计算 $\\lambda_f(\\phi) = \\frac{\\sum_i F_i(\\phi)}{A_{\\text{cell}}}$。\n6. 如果 $\\sum_i A_i > 0$，计算 $H = \\frac{\\sum_i h_i A_i}{\\sum_i A_i}$；否则设置 $H = 0$。\n7. 将 $\\lambda_p$、$\\lambda_f$ 和 $H$ 四舍五入到六位小数以供输出。\n\n测试套件包含五个旨在检验算法的案例：\n- 一个数据完整的案例，用于验证基线计算。\n- 一个缺失高度由同类别中位数补全的案例。\n- 一个缺失方向角依赖于角度平均投影以及缺失高度由类别典型值补全的案例。\n- 一个缺失宽度和长度根据占地面积和类别长宽比重建，并混合了缺失方向角和高度的案例。\n- 一个没有建筑物的边缘案例，用于验证对零和以及基线输出的处理。\n\n程序将为每个测试用例实现这些步骤，并生成一个单行，其中包含一个列表的列表，每个内部列表按顺序持有 $[\\lambda_p,\\lambda_f,H]$，四舍五入到六位小数，确保严格遵守指定的格式和单位。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef reconstruct_dimensions(area, aspect_ratio):\n    \"\"\"\n    Reconstruct width and length from area and class-specific aspect ratio r = w / l.\n    Returns (w, l).\n    \"\"\"\n    w = np.sqrt(area * aspect_ratio)\n    l = np.sqrt(area / aspect_ratio)\n    return w, l\n\ndef mean_projected_width(w, l):\n    \"\"\"\n    Angle-averaged projected width (Cauchy projection): perimeter/pi for rectangles.\n    For a rectangle, perimeter = 2*(w + l), so mean width = 2*(w + l)/pi.\n    \"\"\"\n    return 2.0 * (w + l) / np.pi\n\ndef projected_width(w, l, alpha, phi):\n    \"\"\"\n    Projected width perpendicular to wind direction for a rectangle with orientation alpha.\n    b = |w * cos(alpha - phi)| + |l * sin(alpha - phi)|.\n    \"\"\"\n    d = alpha - phi\n    return abs(w * np.cos(d)) + abs(l * np.sin(d))\n\ndef impute_height(h, cls, class_heights_in_cell, typical_heights):\n    \"\"\"\n    Impute missing height:\n    - If h is not None, return h.\n    - Else, if there are known heights in this class in the grid, return their median.\n    - Else, return the class-typical height.\n    \"\"\"\n    if h is not None:\n        return h\n    known = class_heights_in_cell.get(cls, [])\n    if len(known) > 0:\n        return float(np.median(known))\n    return typical_heights[cls]\n\ndef compute_metrics_for_cell(cell):\n    \"\"\"\n    Compute lambda_p, lambda_f, H for a single grid cell.\n    cell: dict with keys:\n        - 'A_cell': float (grid cell area, m^2)\n        - 'phi': float (wind direction, radians)\n        - 'buildings': list of building dicts with keys:\n            'A', 'w', 'l', 'alpha', 'h', 'cls'\n    Returns (lambda_p, lambda_f, H).\n    \"\"\"\n    A_cell = cell['A_cell']\n    phi = cell['phi']\n    buildings = cell['buildings']\n\n    # Class-specific typical heights (m) and aspect ratios r = w/l\n    typical_heights = {\n        'residential': 9.0,\n        'commercial': 18.0,\n        'industrial': 12.0,\n    }\n    class_aspect_ratio = {\n        'residential': 0.5,\n        'commercial': 1.0,\n        'industrial': 0.25,\n    }\n\n    # Filter buildings with valid area\n    valid_buildings = []\n    for b in buildings:\n        A_i = b['A']\n        if A_i is None or A_i = 0.0:\n            continue\n        valid_buildings.append(b)\n\n    # Pre-collect known heights by class for within-cell median imputation\n    class_heights_in_cell = {'residential': [], 'commercial': [], 'industrial': []}\n    for b in valid_buildings:\n        if b['h'] is not None:\n            class_heights_in_cell[b['cls']].append(b['h'])\n\n    # Sum of plan areas\n    sum_Ai = sum(b['A'] for b in valid_buildings)\n    lambda_p = (sum_Ai / A_cell) if A_cell > 0.0 else 0.0\n\n    # Compute frontal areas and weighted height sum\n    sum_F = 0.0\n    sum_hA = 0.0\n\n    for b in valid_buildings:\n        A_i = b['A']\n        w_i = b['w']\n        l_i = b['l']\n        alpha_i = b['alpha']\n        h_i = b['h']\n        cls = b['cls']\n\n        # Reconstruct dimensions if missing\n        if (w_i is None or l_i is None) and A_i is not None:\n            r_c = class_aspect_ratio[cls]\n            w_i, l_i = reconstruct_dimensions(A_i, r_c)\n\n        # Impute height if missing\n        h_i = impute_height(h_i, cls, class_heights_in_cell, typical_heights)\n\n        # Compute projected width\n        if alpha_i is None:\n            b_width = mean_projected_width(w_i, l_i)\n        else:\n            b_width = projected_width(w_i, l_i, alpha_i, phi)\n\n        F_i = h_i * b_width\n        sum_F += F_i\n        sum_hA += h_i * A_i\n\n    lambda_f = (sum_F / A_cell) if A_cell > 0.0 else 0.0\n    H = (sum_hA / sum_Ai) if sum_Ai > 0.0 else 0.0\n\n    return lambda_p, lambda_f, H\n\ndef format_triplet(triplet):\n    return \"[\" + \",\".join(f\"{x:.6f}\" for x in triplet) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            'A_cell': 250000.0,\n            'phi': np.pi / 6.0,\n            'buildings': [\n                {'A': 1200.0, 'w': 30.0, 'l': 40.0, 'alpha': np.pi / 4.0, 'h': 20.0, 'cls': 'commercial'},\n                {'A': 800.0,  'w': 20.0, 'l': 40.0, 'alpha': np.pi / 3.0, 'h': 12.0, 'cls': 'residential'},\n            ],\n        },\n        # Test case 2\n        {\n            'A_cell': 250000.0,\n            'phi': np.pi / 3.0,\n            'buildings': [\n                {'A': 600.0, 'w': 15.0, 'l': 40.0, 'alpha': np.pi / 8.0, 'h': None, 'cls': 'residential'},\n                {'A': 500.0, 'w': 10.0, 'l': 50.0, 'alpha': np.pi / 5.0, 'h': 10.0, 'cls': 'residential'},\n                {'A': 900.0, 'w': 30.0, 'l': 30.0, 'alpha': np.pi / 6.0, 'h': 18.0, 'cls': 'commercial'},\n            ],\n        },\n        # Test case 3\n        {\n            'A_cell': 250000.0,\n            'phi': np.pi / 2.0,\n            'buildings': [\n                {'A': 2000.0, 'w': 25.0, 'l': 80.0, 'alpha': None, 'h': 15.0, 'cls': 'industrial'},\n                {'A': 600.0,  'w': 12.0, 'l': 50.0, 'alpha': None, 'h': None, 'cls': 'residential'},\n            ],\n        },\n        # Test case 4\n        {\n            'A_cell': 250000.0,\n            'phi': 0.0,\n            'buildings': [\n                {'A': 1000.0, 'w': None, 'l': None, 'alpha': np.pi / 4.0, 'h': 20.0, 'cls': 'commercial'},\n                {'A': 1500.0, 'w': None, 'l': None, 'alpha': None, 'h': None, 'cls': 'industrial'},\n            ],\n        },\n        # Test case 5\n        {\n            'A_cell': 250000.0,\n            'phi': np.pi / 2.0,\n            'buildings': [\n                # No buildings\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        lp, lf, H = compute_metrics_for_cell(case)\n        results.append([lp, lf, H])\n\n    # Final print statement in the exact required format.\n    formatted = \"[\" + \",\".join(format_triplet(r) for r in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        },
        {
            "introduction": "定义了城市结构后，我们转向构成其表面的材料的物理特性。本练习将通过计算一种常见城市表面——沥青的热扩散率 $\\alpha$ 和日变化皮厚 $\\delta$，来探究其热力学行为。这项实践对于理解城市如何储存和释放热量至关重要，而这正是驱动城市热岛效应的关键机制。",
            "id": "4107888",
            "problem": "在数值天气预报 (NWP) 模型中，城市冠层参数化 (UCP) 用于表示次网格尺度的城市表面（道路、屋顶和墙壁）及其能量交换。考虑一个由沥青构成的路面，其热导率 $k=0.75\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}$，体积热容 $C=1.8\\times 10^{6}\\,\\mathrm{J\\,m^{-3}\\,K^{-1}}$。地表温度的日循环近似为一个角频率为 $\\omega=7.3\\times 10^{-5}\\,\\mathrm{s^{-1}}$ 的正弦强迫。从半无限半空间的一维热扩散方程和基本能量守恒出发，推导沥青基底在这种周期性强迫下的热扩散率 $\\alpha$ 和日循环趋肤深度 $\\delta$。然后，计算 $\\alpha$ 和 $\\delta$ 的数值。最后，评估 UCP 中常用的单层基底方案（该方案将蓄热能力表示为厚度为 $L_{s}=0.10\\,\\mathrm{m}$ 的均匀平板）是否能捕捉到日蓄存热通量的大小。你的评估应基于 $L_{s}$ 和 $\\delta$ 之间物理推导出的关系，并提供定量论证。\n\n将 $\\alpha$ 以 $\\mathrm{m^{2}\\,s^{-1}}$ 为单位表示，$\\delta$ 以 $\\mathrm{m}$ 为单位表示。将你的数值结果四舍五入到三位有效数字。最终答案必须仅包含 $\\alpha$ 和 $\\delta$ 的数值，并按此顺序排列。",
            "solution": "该问题要求推导和计算沥青基底的热扩散率 $\\alpha$ 和日循环趋肤深度 $\\delta$，然后评估一个单层数值方案。\n\n首先，我们讨论热扩散率 $\\alpha$。热扩散率是一种材料属性，衡量热量从材料热端传递到冷端的速率。它被定义为热导率 $k$ 与体积热容 $C$ 的比值。体积热容是密度 $\\rho$ 和比热容 $c_p$ 的乘积，因此 $C = \\rho c_p$。其定义为：\n$$ \\alpha = \\frac{k}{C} $$\n给定沥青的数值：热导率 $k=0.75\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}$ 和体积热容 $C=1.8\\times 10^{6}\\,\\mathrm{J\\,m^{-3}\\,K^{-1}}$。\n我们可以计算 $\\alpha$ 的数值：\n$$ \\alpha = \\frac{0.75\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}}{1.8\\times 10^{6}\\,\\mathrm{J\\,m^{-3}\\,K^{-1}}} \\approx 4.1667 \\times 10^{-7}\\,\\mathrm{m^{2}\\,s^{-1}} $$\n四舍五入到三位有效数字，我们得到 $\\alpha = 4.17 \\times 10^{-7}\\,\\mathrm{m^{2}\\,s^{-1}}$。\n\n接下来，我们推导日循环趋肤深度 $\\delta$。这需要求解半无限固体在表面具有周期性边界条件的一维热扩散方程。设 $z$ 为深度坐标，向下为正，表面位于 $z=0$。热方程为：\n$$ \\frac{\\partial T(z, t)}{\\partial t} = \\alpha \\frac{\\partial^2 T(z, t)}{\\partial z^2} $$\n表面温度受角频率为 $\\omega$ 的正弦函数强迫。设温度表示为 $T(z, t) = \\bar{T} + \\theta(z,t)$，其中 $\\bar{T}$ 是平均温度，$\\theta(z,t)$ 是温度扰动。表面的边界条件是 $\\theta(0, t) = \\Delta T \\cos(\\omega t)$，其中 $\\Delta T$ 是温度振荡的振幅。我们寻找一个随深度衰减的周期解。使用复数表示法，我们可以将边界条件写为 $\\theta(0, t) = \\Re\\{\\Delta T \\exp(i\\omega t)\\}$。\n我们寻找形式为 $\\theta(z, t) = \\Re\\{\\hat{\\theta}(z) \\exp(i\\omega t)\\}$ 的解。将此代入热方程，得到关于复振幅 $\\hat{\\theta}(z)$ 的常微分方程：\n$$ i\\omega \\hat{\\theta}(z) = \\alpha \\frac{d^2 \\hat{\\theta}(z)}{dz^2} \\implies \\frac{d^2 \\hat{\\theta}}{dz^2} - \\frac{i\\omega}{\\alpha} \\hat{\\theta} = 0 $$\n通解为 $\\hat{\\theta}(z) = A\\exp(\\lambda z) + B\\exp(-\\lambda z)$，其中 $\\lambda^2 = \\frac{i\\omega}{\\alpha}$。\n我们可以解出 $\\lambda$：\n$$ \\lambda = \\sqrt{\\frac{i\\omega}{\\alpha}} = \\sqrt{\\frac{\\omega}{\\alpha}}\\sqrt{i} = \\sqrt{\\frac{\\omega}{\\alpha}} \\left(\\frac{1+i}{\\sqrt{2}}\\right) = (1+i)\\sqrt{\\frac{\\omega}{2\\alpha}} $$\n物理域是半无限半空间，因此当 $z \\rightarrow \\infty$ 时，温度扰动必须保持有界。$\\exp(\\lambda z)$ 项随 $z$ 指数增长，因此其系数 $A$ 必须为 $0$。因此解为 $\\hat{\\theta}(z) = B\\exp(-\\lambda z)$。\n应用表面边界条件 $\\hat{\\theta}(0) = \\Delta T$，我们得到 $B = \\Delta T$。复振幅的解是：\n$$ \\hat{\\theta}(z) = \\Delta T \\exp\\left(-(1+i)\\sqrt{\\frac{\\omega}{2\\alpha}} z\\right) = \\Delta T \\exp\\left(-\\sqrt{\\frac{\\omega}{2\\alpha}} z\\right) \\exp\\left(-i\\sqrt{\\frac{\\omega}{2\\alpha}} z\\right) $$\n实际的温度扰动是：\n$$ \\theta(z,t) = \\Re\\{\\hat{\\theta}(z)\\exp(i\\omega t)\\} = \\Delta T \\exp\\left(-\\sqrt{\\frac{\\omega}{2\\alpha}} z\\right) \\cos\\left(\\omega t - \\sqrt{\\frac{\\omega}{2\\alpha}}z\\right) $$\n温度波的振幅 $\\Delta T \\exp\\left(-\\sqrt{\\frac{\\omega}{2\\alpha}} z\\right)$ 随深度指数衰减。日循环趋肤深度 $\\delta$ 定义为温度振荡的振幅衰减到其表面值的 $1/e$ 时的深度。这发生在指数衰减项的参数等于 $-1$ 时：\n$$ -\\sqrt{\\frac{\\omega}{2\\alpha}} \\delta = -1 \\implies \\delta = \\sqrt{\\frac{2\\alpha}{\\omega}} $$\n现在我们使用给定的角频率 $\\omega=7.3\\times 10^{-5}\\,\\mathrm{s^{-1}}$ 和我们计算出的 $\\alpha$ 值来计算 $\\delta$ 的数值。\n$$ \\delta = \\sqrt{\\frac{2 \\times (4.1667 \\times 10^{-7}\\,\\mathrm{m^{2}\\,s^{-1}})}{7.3\\times 10^{-5}\\,\\mathrm{s^{-1}}}} = \\sqrt{\\frac{8.3334 \\times 10^{-7}}{7.3\\times 10^{-5}}}\\,\\mathrm{m} \\approx \\sqrt{1.1416 \\times 10^{-2}}\\,\\mathrm{m} \\approx 0.1068\\,\\mathrm{m} $$\n四舍五入到三位有效数字，得到 $\\delta = 0.107\\,\\mathrm{m}$。\n\n最后，我们必须评估厚度为 $L_{s}=0.10\\,\\mathrm{m}$ 的单层基底方案是否能捕捉到日蓄存热通量的大小。趋肤深度 $\\delta$ 代表了在一个日循环中主动参与热交换的材料层的特征深度。为了让模型能准确地表示热惯性以及由此产生的蓄存热通量 ($G$)，其有效深度应与热波的物理穿透深度相当。\n蓄存热通量由被表面强迫“热激活”的热质量决定。如果模型的层厚 $L_s$ 远小于 $\\delta$ ($L_s \\ll \\delta$)，模型将低估热质量，导致热惯性降低，表面温度范围被夸大，并且蓄存热通量的大小和相位不正确。相反，如果 $L_s \\gg \\delta$，模型将通过包含没有经历显著温度变化的材料来高估热质量，导致对表面温度波的过度阻尼。\n因此，为了在捕捉日循环方面获得最佳性能，平板厚度 $L_s$ 应与趋肤深度 $\\delta$ 在同一数量级。\n让我们进行定量比较：\n- 计算出的日循环趋肤深度：$\\delta \\approx 0.107\\,\\mathrm{m}$。\n- 模型单层厚度：$L_{s} = 0.10\\,\\mathrm{m}$。\n模型厚度与物理趋肤深度的比值为：\n$$ \\frac{L_s}{\\delta} = \\frac{0.10\\,\\mathrm{m}}{0.107\\,\\mathrm{m}} \\approx 0.935 $$\n由于 $L_s$ 约为 $\\delta$ 的 $93.5\\%$，模型平板的厚度非常接近日热量穿透的特征深度。这表明对于这个特定的频率和材料，该单层方案的参数化是很好的。可以预期它能为可用的热质量提供一个很好的近似，从而以合理的精度捕捉到日蓄存热通量的大小。",
            "answer": "[4.17e-7, 0.107]"
        },
        {
            "introduction": "最后，我们来考虑整个城市冠层如何与太阳辐射相互作用，以及在粗糙的模型网格中表示这一过程所面临的挑战。本练习使用比尔-朗伯定律的类比来模拟辐射衰减，并要求您量化因平均异质区域的城市几何形状而引入的误差（偏差）。这突显了所有环境建模中的一个基本挑战：次网格尺度变率对网格平均过程的影响。",
            "id": "4107953",
            "problem": "考虑一个数值天气预报 (NWP) 模型中的城市网格单元，该单元具有一组非均质的城市峡谷，其特征由迎风面积指数 (FAI) $\\lambda_f$ 描述。迎风面积指数 $\\lambda_f$ 定义为单位水平地面面积上障碍物的总垂直迎风面积。在许多城市冠层参数化方案 (UCP) 中，直接短波辐射的辐射传输被类比为冠层辐射传输来处理，其中平行光束穿过介质时的衰减遵循比尔-朗伯定律。设冠层顶部的向下直接短波辐照度为 $S_{\\mathrm{in}}$ (单位为 $\\mathrm{W\\,m^{-2}}$)，太阳天顶角 (SZA) 为 $\\theta_0$ (单位为度)。定义 $\\mu_0 = \\cos(\\theta_0)$，在计算余弦值之前，$\\theta_0$ 必须转换为弧度。设 $k_{\\mathrm{ext}}$ 是一个消光系数，它将光学深度与 $\\lambda_f$ 进行缩放；设 $\\alpha_{\\mathrm{eff}}$ 是城市表面的有效短波吸收率（无量纲，介于 $0$ 和 $1$ 之间）。\n\n基本原理：\n- 关于平行光束的比尔-朗伯定律指出，穿过光学深度 $\\tau$ 后的透射辐照度 $I$ 为 $I = I_0 \\exp(-\\tau)$，其中 $I_0$ 是入射辐照度。\n- 在一个垂直方向的障碍物场中，随着太阳光束变得更加倾斜，其穿过障碍物的投影路径长度会增加，因此光学深度与 $\\mu_0$ 成反比缩放。在参数化的城市冠层中，通常将光学深度通过与 $\\lambda_f$ 成正比的关系与迎风面积指数关联起来。\n\n任务：\n1. 从比尔-朗伯定律以及光学深度与 $\\lambda_f$ 成正比且通过 $\\mu_0$ 进行几何缩放的关系出发，推导峡谷尺度的吸收短波通量 $A(\\lambda_f)$ (单位为 $\\mathrm{W\\,m^{-2}}$) 关于 $S_{\\mathrm{in}}$, $\\alpha_{\\mathrm{eff}}$, $k_{\\mathrm{ext}}$, $\\mu_0$ 和 $\\lambda_f$ 的表达式。假设为不考虑多次反射的一次吸收，并将 $\\alpha_{\\mathrm{eff}}$ 视为被障碍物移除的光束中被吸收的部分。\n2. 对于一个次网格分布 $\\{\\lambda_{f,i}, w_i\\}_{i=1}^N$，其权重 $w_i$ 之和为 $1$，定义平均迎风面积指数 $\\overline{\\lambda_f} = \\sum_{i=1}^N w_i \\lambda_{f,i}$ 和平均吸收通量 $\\overline{A} = \\sum_{i=1}^N w_i A(\\lambda_{f,i})$。令 $A_{\\mathrm{mean}} = A(\\overline{\\lambda_f})$。使用网格平均值 $\\lambda_f$ 代替其分布所引起的偏差为 $\\Delta = A_{\\mathrm{mean}} - \\overline{A}$。\n3. 实现一个程序，该程序针对下面的测试套件，计算每个测试用例的偏差 $\\Delta$ (单位为 $\\mathrm{W\\,m^{-2}}$)。角度必须以度为单位进行解释，但在计算 $\\cos(\\theta_0)$ 以获得 $\\mu_0$ 之前，必须将其转换为弧度。如果 $\\mu_0$ 极小，则使用一个小的正数下限以避免除以零。将每个偏差以 $\\mathrm{W\\,m^{-2}}$ 为单位表示，并四舍五入到三位小数。\n\n测试套件 (每个用例指定了 $S_{\\mathrm{in}}$ (单位 $\\mathrm{W\\,m^{-2}}$), $\\alpha_{\\mathrm{eff}}$, $k_{\\mathrm{ext}}$, $\\theta_0$ (单位 度)，$\\lambda_{f,i}$ 值列表以及对应的权重 $w_i$):\n- 用例 1：$S_{\\mathrm{in}} = 850$, $\\alpha_{\\mathrm{eff}} = 0.7$, $k_{\\mathrm{ext}} = 1.0$, $\\theta_0 = 40$, $\\lambda_{f}$ 值 $[0.3, 0.6, 1.0]$, 权重 $[0.5, 0.3, 0.2]$。\n- 用例 2：$S_{\\mathrm{in}} = 1000$, $\\alpha_{\\mathrm{eff}} = 0.8$, $k_{\\mathrm{ext}} = 1.2$, $\\theta_0 = 0$, $\\lambda_{f}$ 值 $[0.0, 1.5]$, 权重 $[0.5, 0.5]$。\n- 用例 3：$S_{\\mathrm{in}} = 600$, $\\alpha_{\\mathrm{eff}} = 0.7$, $k_{\\mathrm{ext}} = 1.0$, $\\theta_0 = 80$, $\\lambda_{f}$ 值 $[0.2, 0.8, 1.6, 2.4]$, 权重 $[0.4, 0.3, 0.2, 0.1]$。\n- 用例 4：$S_{\\mathrm{in}} = 900$, $\\alpha_{\\mathrm{eff}} = 0.75$, $k_{\\mathrm{ext}} = 0.9$, $\\theta_0 = 30$, $\\lambda_{f}$ 值 $[0.7, 0.7, 0.7]$, 权重 $[0.2, 0.3, 0.5]$。\n- 用例 5：$S_{\\mathrm{in}} = 750$, $\\alpha_{\\mathrm{eff}} = 0.65$, $k_{\\mathrm{ext}} = 1.4$, $\\theta_0 = 60$, $\\lambda_{f}$ 值 $[0.1, 0.5, 1.0, 1.8]$, 权重 $[0.25, 0.25, 0.25, 0.25]$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含所有五个测试用例的偏差，形式为方括号括起来的逗号分隔列表（例如 $[b_1,b_2,b_3,b_4,b_5]$），其中每个 $b_i$ 是对应测试用例的偏差 $\\Delta$，以 $\\mathrm{W\\,m^{-2}}$ 为单位表示并四舍五入到三位小数。",
            "solution": "该问题要求推导城市冠层中吸收短波辐射的表达式，并用它来计算因使用网格平均参数而非次网格分布而产生的偏差。\n\n### 第 1 部分：吸收短波通量 $A(\\lambda_f)$ 的推导\n\n推导过程基于所提供的基本原理。\n\n1.  **比尔-朗伯定律**：平行辐射光束穿过介质的透射过程由比尔-朗伯定律描述。穿过城市冠层的透射辐照度 $S_{\\mathrm{trans}}$ 由下式给出：\n    $$S_{\\mathrm{trans}} = S_{\\mathrm{in}} \\exp(-\\tau)$$\n    其中 $S_{\\mathrm{in}}$ 是冠层顶部的入射直接短波辐照度，$\\tau$ 是冠层的光学深度。\n\n2.  **光学深度 ($\\tau$) 的公式**：问题指出，光学深度 $\\tau$ 与迎风面积指数 $\\lambda_f$ 成正比，比例常数为 $k_{\\mathrm{ext}}$ (消光系数)。它还包含一个几何缩放因子，该因子考虑了太阳光束穿过垂直方向障碍物的路径长度。此路径长度与 $\\mu_0 = \\cos(\\theta_0)$ 成反比，其中 $\\theta_0$ 是太阳天顶角。较小的 $\\mu_0$ (太阳在天空中位置较低) 对应于穿过障碍物的更长路径，因此光学深度更大。结合这些效应，光学深度表示为：\n    $$\\tau(\\lambda_f, \\mu_0) = \\frac{k_{\\mathrm{ext}} \\lambda_f}{\\mu_0}$$\n\n3.  **衰减 (被移除) 的通量**：被衰减 (即被障碍物拦截) 的那部分入射通量是入射通量与透射通量之差：\n    $$S_{\\mathrm{removed}} = S_{\\mathrm{in}} - S_{\\mathrm{trans}} = S_{\\mathrm{in}} - S_{\\mathrm{in}} \\exp(-\\tau) = S_{\\mathrm{in}} (1 - \\exp(-\\tau))$$\n\n4.  **吸收的通量**：问题明确指出，有效吸收率 $\\alpha_{\\mathrm{eff}}$ 是被*移除*的光束中被吸收的比例。因此，总吸收通量 $A$ 是 $\\alpha_{\\mathrm{eff}}$ 乘以被移除的通量 $S_{\\mathrm{removed}}$。这模拟了一个一次吸收过程，忽略了表面之间的多次反射。\n    $$A(\\lambda_f) = \\alpha_{\\mathrm{eff}} \\cdot S_{\\mathrm{removed}} = \\alpha_{\\mathrm{eff}} S_{\\mathrm{in}} (1 - \\exp(-\\tau))$$\n    代入 $\\tau$ 的表达式，我们得到峡谷尺度吸收短波通量作为 $\\lambda_f$ 和其他参数的函数的最终表达式：\n    $$A(\\lambda_f) = \\alpha_{\\mathrm{eff}} S_{\\mathrm{in}} \\left( 1 - \\exp\\left(-\\frac{k_{\\mathrm{ext}} \\lambda_f}{\\mu_0}\\right) \\right)$$\n\n### 第 2 部分：偏差 $\\Delta$ 的计算\n\n偏差 $\\Delta$ 源于函数 $A(\\lambda_f)$ 的非线性。函数 $A(\\lambda_f)$ 是关于 $\\lambda_f$ 的凹函数，这可以通过检查其关于 $\\lambda_f$ 的二阶导数来验证：\n$$\\frac{\\partial A}{\\partial \\lambda_f} = \\alpha_{\\mathrm{eff}} S_{\\mathrm{in}} \\left(\\frac{k_{\\mathrm{ext}}}{\\mu_0}\\right) \\exp\\left(-\\frac{k_{\\mathrm{ext}} \\lambda_f}{\\mu_0}\\right)$$\n$$\\frac{\\partial^2 A}{\\partial \\lambda_f^2} = -\\alpha_{\\mathrm{eff}} S_{\\mathrm{in}} \\left(\\frac{k_{\\mathrm{ext}}}{\\mu_0}\\right)^2 \\exp\\left(-\\frac{k_{\\mathrm{ext}} \\lambda_f}{\\mu_0}\\right)$$\n由于所有参数 ($S_{\\mathrm{in}}$, $\\alpha_{\\mathrm{eff}}$, $k_{\\mathrm{ext}}$) 均为正，且对于 $\\theta_0 \\in [0, 90^\\circ)$，$\\mu_0$ 为正，因此二阶导数严格为负。这证实了 $A(\\lambda_f)$ 是一个凹函数。\n\n对于任何凹函数 $f(x)$，琴生不等式指出 $E[f(x)] \\le f(E[x])$，其中 $E[\\cdot]$ 表示期望值。在我们的情境中，这可以转化为：\n$$ \\sum_{i=1}^N w_i A(\\lambda_{f,i}) \\le A\\left(\\sum_{i=1}^N w_i \\lambda_{f,i}\\right) $$\n左边的项被定义为真实的平均吸收通量 $\\overline{A}$，右边的项是根据平均迎风面积指数计算出的吸收通量 $A_{\\mathrm{mean}} = A(\\overline{\\lambda_f})$。\n$$\\overline{A} \\le A_{\\mathrm{mean}}$$\n偏差 $\\Delta$ 定义为 $\\Delta = A_{\\mathrm{mean}} - \\overline{A}$。由于函数 $A(\\lambda_f)$ 的凹性，该偏差将始终为非负值，即 $\\Delta \\ge 0$。只有当 $\\lambda_f$ 的分布方差为零 (即所有 $\\lambda_{f,i}$ 都相同) 或函数 $A(\\lambda_f)$ 在 $\\lambda_{f,i}$ 值的范围内是线性的情况下，偏差才为零，而这里并非如此。\n\n每个测试用例的计算步骤如下：\n1.  计算 $\\mu_0 = \\cos(\\theta_0)$，确保将 $\\theta_0$ 从度转换为弧度。为 $\\mu_0$ 使用一个下限值以防止在近掠射角时出现除以零的情况，尽管对于给定的测试用例来说这并非绝对必要。\n2.  计算平均迎风面积指数 $\\overline{\\lambda_f} = \\sum_{i=1}^N w_i \\lambda_{f,i}$。\n3.  将推导出的函数 $A$ 应用于平均 FAI 来计算 $A_{\\mathrm{mean}}$：$A_{\\mathrm{mean}} = A(\\overline{\\lambda_f})$。\n4.  通过为次网格分布的每个元素计算 $A(\\lambda_{f,i})$，并用 $w_i$ 对其进行加权，然后将结果求和，来计算真实的平均吸收通量 $\\overline{A}$：$\\overline{A} = \\sum_{i=1}^N w_i A(\\lambda_{f,i})$。\n5.  计算偏差：$\\Delta = A_{\\mathrm{mean}} - \\overline{A}$。\n6.  将最终结果四舍五入到三位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the bias in absorbed shortwave flux due to averaging the Frontal Area Index.\n    \"\"\"\n    test_cases = [\n        {'S_in': 850, 'alpha_eff': 0.7, 'k_ext': 1.0, 'theta_0': 40, 'lambda_f': [0.3, 0.6, 1.0], 'weights': [0.5, 0.3, 0.2]},\n        {'S_in': 1000, 'alpha_eff': 0.8, 'k_ext': 1.2, 'theta_0': 0, 'lambda_f': [0.0, 1.5], 'weights': [0.5, 0.5]},\n        {'S_in': 600, 'alpha_eff': 0.7, 'k_ext': 1.0, 'theta_0': 80, 'lambda_f': [0.2, 0.8, 1.6, 2.4], 'weights': [0.4, 0.3, 0.2, 0.1]},\n        {'S_in': 900, 'alpha_eff': 0.75, 'k_ext': 0.9, 'theta_0': 30, 'lambda_f': [0.7, 0.7, 0.7], 'weights': [0.2, 0.3, 0.5]},\n        {'S_in': 750, 'alpha_eff': 0.65, 'k_ext': 1.4, 'theta_0': 60, 'lambda_f': [0.1, 0.5, 1.0, 1.8], 'weights': [0.25, 0.25, 0.25, 0.25]},\n    ]\n\n    results = []\n\n    def calculate_absorbed_flux(lambda_f, S_in, alpha_eff, k_ext, mu_0):\n        \"\"\"\n        Calculates the canyon-level absorbed shortwave flux A(lambda_f).\n        \n        Args:\n            lambda_f (float or np.ndarray): Frontal Area Index.\n            S_in (float): Incoming shortwave radiation.\n            alpha_eff (float): Effective absorptivity.\n            k_ext (float): Extinction coefficient.\n            mu_0 (float): Cosine of the solar zenith angle.\n        \n        Returns:\n            float or np.ndarray: Absorbed shortwave flux.\n        \"\"\"\n        exponent = -k_ext * lambda_f / mu_0\n        return alpha_eff * S_in * (1.0 - np.exp(exponent))\n\n    for case in test_cases:\n        S_in = case['S_in']\n        alpha_eff = case['alpha_eff']\n        k_ext = case['k_ext']\n        theta_0 = case['theta_0']\n        lambda_f_values = np.array(case['lambda_f'])\n        weights = np.array(case['weights'])\n\n        # Calculate mu_0 = cos(theta_0), with floor for stability\n        mu_0 = np.cos(np.deg2rad(theta_0))\n        mu_0 = np.maximum(mu_0, 1e-6) # Use a small positive floor as per problem description\n\n        # Calculate the mean Frontal Area Index\n        lambda_f_bar = np.dot(lambda_f_values, weights)\n        \n        # Calculate A_mean = A(lambda_f_bar)\n        A_mean = calculate_absorbed_flux(lambda_f_bar, S_in, alpha_eff, k_ext, mu_0)\n        \n        # Calculate A_bar = sum(w_i * A(lambda_f_i))\n        A_values = calculate_absorbed_flux(lambda_f_values, S_in, alpha_eff, k_ext, mu_0)\n        A_bar = np.dot(A_values, weights)\n        \n        # Calculate the bias\n        bias = A_mean - A_bar\n        \n        results.append(round(bias, 3))\n\n    # Format and print the final output\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}