{
    "hands_on_practices": [
        {
            "introduction": "理解积雪的热状态是进行任何热力学建模的基础。这个练习的核心是“冷含量”——积雪在开始融化前能够吸收的能量的量度。通过这个实践，您将基于热力学第一定律，推导并计算一个分层雪堆的冷含量，并确定它可以重新冻结多少融水。这个计算是评估积雪对升温和融化事件响应能力的关键第一步。",
            "id": "4089665",
            "problem": "在一个数值天气预报和气候模拟框架中，一个一维分层雪层的厚度为 $H$，其密度随深度 $z$（从雪面向下测量）线性变化，并且具有一个严格低于熔点的线性温度剖面。具体来说，对于 $0 \\leq z \\leq H$，密度为 $\\rho(z) = \\rho_{0} + \\gamma z$，温度为 $T(z) = T_{0} + \\beta z$，其中 $T(z)$ 以摄氏度为单位， $z$ 以米为单位。假设密度和温度剖面由 $\\rho_{0} = 250\\,\\mathrm{kg\\,m^{-3}}$，$\\gamma = 300\\,\\mathrm{kg\\,m^{-4}}$，$T_{0} = -10\\,^{\\circ}\\mathrm{C}$，$\\beta = 12\\,^{\\circ}\\mathrm{C\\,m^{-1}}$ 和 $H = 0.5\\,\\mathrm{m}$ 给出。一股温度为 $0\\,^{\\circ}\\mathrm{C}$、单位面积总质量为 $M_{\\mathrm{in}} = 9.0\\,\\mathrm{kg\\,m^{-2}}$ 的融水渗入雪中。假设冰的比热容为常数 $c_{i} = 2.10 \\times 10^{3}\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}$，水的熔化潜热为 $L_{f} = 3.34 \\times 10^{5}\\,\\mathrm{J\\,kg^{-1}}$。忽略除雪层的感热增温和融水再冻结释放的潜热之外的所有能量交换；假设没有做功，也没有与大气或地面的水汽通量、辐射或传导交换。\n\n从热力学第一定律以及感热和潜热的核心定义出发，推导冷含量 $Q_{\\mathrm{cc}}$（将整个雪层温度提升至 $0\\,^{\\circ}\\mathrm{C}$ 所需的单位面积能量）的表达式。然后，在给定的融水输入下，确定在雪层温度达到 $0\\,^{\\circ}\\mathrm{C}$ 之前可以再冻结的融水的最大单位面积质量。将你最终的再冻结融水单位面积质量的数值答案以 $\\mathrm{kg\\,m^{-2}}$ 为单位表示，并四舍五入到四位有效数字。",
            "solution": "根据热力学第一定律，对于一个可忽略机械功的封闭系统，其内能的变化等于净加入的热量。将一个初始温度低于 $0\\,^{\\circ}\\mathrm{C}$ 的雪层加热到熔点所需的能量（冷含量，$Q_{\\mathrm{cc}}$）是感热在整个体积上的积分：\n$$\nQ_{\\mathrm{cc}} = \\int_{V} \\rho(\\mathbf{x})\\, c_{i}\\, \\Delta T(\\mathbf{x})\\, dV,\n$$\n其中 $\\Delta T(\\mathbf{x})$ 是升温到 $0\\,^{\\circ}\\mathrm{C}$ 的温升，$\\rho$ 是密度，$c_{i}$ 是冰的比热容。在一个单位水平面积的一维柱体中，$dV = dz$，温升为 $\\Delta T(z) = 0 - T(z) = -T(z)$。因此，\n$$\nQ_{\\mathrm{cc}} = \\int_{0}^{H} \\rho(z)\\, c_{i}\\, \\left(-T(z)\\right)\\, dz.\n$$\n代入给定的线性和温度剖面 $\\rho(z) = \\rho_{0} + \\gamma z$ 和 $T(z) = T_{0} + \\beta z$：\n$$\nQ_{\\mathrm{cc}} = c_{i} \\int_{0}^{H} (\\rho_{0} + \\gamma z)(-(T_{0} + \\beta z))\\, dz.\n$$\n使用给定的参数：$\\rho_{0} = 250\\,\\mathrm{kg\\,m^{-3}}$，$\\gamma = 300\\,\\mathrm{kg\\,m^{-4}}$，$T_{0} = -10\\,^{\\circ}\\mathrm{C}$，$\\beta = 12\\,^{\\circ}\\mathrm{C\\,m^{-1}}$ 和 $H=0.5\\,\\mathrm{m}$。\n被积函数中的温度项为 $-T(z) = -(-10 + 12z) = 10 - 12z$。\n被积函数（不含 $c_i$）为：\n$$\n(\\rho_{0} + \\gamma z)(10 - 12 z) = (250 + 300z)(10 - 12z) = 2500 - 3000z + 3000z - 3600z^2 = 2500 - 3600z^2.\n$$\n现在计算积分：\n$$\n\\int_{0}^{0.5} (2500 - 3600 z^{2})\\, dz = \\left[2500 z - 1200 z^{3}\\right]_{0}^{0.5} = (2500 \\times 0.5) - (1200 \\times 0.5^{3}) = 1250 - (1200 \\times 0.125) = 1250 - 150 = 1100\\,\\mathrm{kg\\,K\\,m^{-2}}.\n$$\n冷含量 $Q_{\\mathrm{cc}}$ 是这个积分乘以比热容 $c_{i}$：\n$$\nQ_{\\mathrm{cc}} = c_{i} \\times 1100 = (2.10 \\times 10^{3}\\,\\mathrm{J\\,kg^{-1}\\,K^{-1}}) \\times 1100\\,\\mathrm{kg\\,K\\,m^{-2}} = 2.31 \\times 10^{6}\\,\\mathrm{J\\,m^{-2}}.\n$$\n当 $0\\,^{\\circ}\\mathrm{C}$ 的融水再冻结时，会释放单位质量的潜热 $L_f$。可再冻结的融水的最大单位面积质量 $m_{\\mathrm{ref,max}}$ 是指其释放的潜热恰好等于冷含量：\n$$\nm_{\\mathrm{ref,max}} = \\frac{Q_{\\mathrm{cc}}}{L_{f}}.\n$$\n代入数值：\n$$\nm_{\\mathrm{ref,max}} = \\frac{2.31 \\times 10^{6}\\,\\mathrm{J\\,m^{-2}}}{3.34 \\times 10^{5}\\,\\mathrm{J\\,kg^{-1}}} \\approx 6.916167\\ldots\\,\\mathrm{kg\\,m^{-2}}.\n$$\n由于可用的融水输入为 $M_{\\mathrm{in}} = 9.0\\,\\mathrm{kg\\,m^{-2}}$，而雪层在达到 $0\\,^{\\circ}\\mathrm{C}$ 之前最多只能冻结 $m_{\\mathrm{ref,max}}$，因此实际再冻结的质量是两者中的较小值：\n$$\nm_{\\mathrm{ref}} = \\min(M_{\\mathrm{in}}, m_{\\mathrm{ref,max}}) = \\min(9.0, 6.916167\\ldots) = 6.916167\\ldots\\,\\mathrm{kg\\,m^{-2}}.\n$$\n四舍五入到四位有效数字，最终结果是 $6.916\\,\\mathrm{kg\\,m^{-2}}$。",
            "answer": "$$\\boxed{6.916}$$"
        },
        {
            "introduction": "将物理原理转化为可靠的计算机模拟是数值建模的核心挑战。在掌握了积雪热量平衡的基本物理学之后，我们必须面对数值实现的限制。本练习通过对雪中热传导方程进行 von Neumann 稳定性分析，引导您推导显式时间步进格式的最大允许时间步长 $\\Delta t$。理解这一限制对于构建既高效又不会因数值不稳定性而失败的积雪模型至关重要。",
            "id": "4089704",
            "problem": "在数值天气预报（NWP）和气候建模的背景下，经历温度梯度变质的分层积雪的热力学演变，在层级尺度上，通常通过一维垂直热传导来近似。从能量守恒和傅里叶热传导定律出发，假设一个均匀的干雪层，其导热系数 $k$、密度 $\\rho$ 和比热容 $c$ 均为常数，并忽略源项和汇项（例如，相变引起的潜热）。在这些假设下，雪的热方程简化为关于温度 $T(z,t)$ 的线性扩散方程，\n$$\n\\frac{\\partial T}{\\partial t} = \\kappa \\frac{\\partial^{2} T}{\\partial z^{2}},\n$$\n其中热扩散率为 $\\kappa = \\frac{k}{\\rho c}$。考虑一个显式前向欧拉时间步进格式，其垂直网格间距 $\\Delta z$ 和时间步长 $\\Delta t$ 均匀，并对二阶导数使用中心差分。\n\n使用冯·诺依曼（傅里叶）稳定性分析，从第一性原理推导制约 $\\Delta t$（用 $\\Delta z$ 和 $\\kappa$ 表示）的稳定性条件。然后，使用推导出的条件，计算在一个垂直网格间距 $\\Delta z = 0.01$ $\\text{m}$ 的均匀网格上，对于具有属性 $k = 0.2$ $\\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$、$\\rho = 300$ $\\text{kg}\\,\\text{m}^{-3}$ 和 $c = 2100$ $\\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$ 的干雪层，其最大允许时间步长 $\\Delta t_{\\text{max}}$（以秒为单位）。将最终数值答案四舍五入到三位有效数字，并以秒为单位表示。",
            "solution": "为了推导稳定性条件，我们首先将一维热方程离散化。设 $T_j^n$ 表示在空间节点 $j$ 和时间步 $n$ 的温度，即 $T_j^n \\approx T(j\\Delta z, n\\Delta t)$。\n\n使用显式前向欧拉格式对时间导数进行近似，使用中心差分格式对二阶空间导数进行近似，得到有限差分方程：\n$$\n\\frac{T_j^{n+1} - T_j^n}{\\Delta t} = \\kappa \\frac{T_{j+1}^n - 2T_j^n + T_{j-1}^n}{(\\Delta z)^2}\n$$\n求解 $T_j^{n+1}$，并定义无量纲扩散数 $s = \\frac{\\kappa \\Delta t}{(\\Delta z)^2}$，更新规则简化为：\n$$\nT_j^{n+1} = T_j^n + s(T_{j+1}^n - 2T_j^n + T_{j-1}^n)\n$$\n为了进行冯·诺依曼稳定性分析，我们假设解的单个傅里叶模式的形式为 $T_j^n = G^n e^{i k_w j \\Delta z}$，其中 $k_w$ 是波数，$G^n$ 是模式振幅。为使格式稳定，放大因子 $g = \\frac{G^{n+1}}{G^n}$ 必须对所有波数满足 $|g| \\le 1$。\n\n将傅里叶模式代入差分方程并除以 $G^n e^{i k_w j \\Delta z}$，得到放大因子 $g$ 的表达式：\n$$\ng = 1 + s(e^{i k_w \\Delta z} - 2 + e^{-i k_w \\Delta z})\n$$\n使用欧拉公式 $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$ 简化：\n$$\ng = 1 + s(2\\cos(k_w \\Delta z) - 2) = 1 - 2s(1 - \\cos(k_w \\Delta z))\n$$\n再使用三角半角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\frac{\\theta}{2})$：\n$$\ng = 1 - 4s \\sin^2\\left(\\frac{k_w \\Delta z}{2}\\right)\n$$\n稳定性条件 $|g| \\le 1$ 要求：\n$$\n-1 \\le 1 - 4s \\sin^2\\left(\\frac{k_w \\Delta z}{2}\\right) \\le 1\n$$\n右侧不等式 $1 - 4s \\sin^2(\\dots) \\le 1$ 总是成立，因为 $s \\ge 0$。左侧不等式给出：\n$$\n-2 \\le -4s \\sin^2\\left(\\frac{k_w \\Delta z}{2}\\right) \\implies s \\le \\frac{1}{2\\sin^2\\left(\\frac{k_w \\Delta z}{2}\\right)}\n$$\n此条件必须对所有波数成立。最严格的条件发生在 $\\sin^2(\\dots)$ 达到其最大值 1 时，因此稳定性条件为：\n$$\ns \\le \\frac{1}{2}\n$$\n将 $s$ 的定义代回，得到最终的稳定性条件：\n$$\n\\frac{\\kappa \\Delta t}{(\\Delta z)^2} \\le \\frac{1}{2}\n$$\n**最大时间步长的计算**\n\n最大允许时间步长 $\\Delta t_{\\text{max}}$ 发生在上述条件达到其极限时：\n$$\n\\Delta t_{\\text{max}} = \\frac{(\\Delta z)^2}{2\\kappa}\n$$\n首先，根据给定的属性计算热扩散率 $\\kappa$：\n$$\n\\kappa = \\frac{k}{\\rho c} = \\frac{0.2~\\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}}{(300~\\text{kg}\\,\\text{m}^{-3}) (2100~\\text{J}\\,\\text{kg}^{-1}\\,\\text{K}^{-1})} = \\frac{0.2}{630000}~\\text{m}^2\\,\\text{s}^{-1}\n$$\n将 $\\kappa$ 和 $\\Delta z = 0.01$ $\\text{m}$ 的值代入表达式：\n$$\n\\Delta t_{\\text{max}} = \\frac{(0.01~\\text{m})^2}{2 \\left(\\frac{0.2}{630000}~\\text{m}^2\\,\\text{s}^{-1}\\right)} = \\frac{0.0001 \\times 630000}{0.4}~\\text{s} = 157.5~\\text{s}\n$$\n将最终答案四舍五入到三位有效数字，得到：\n$$\n\\Delta t_{\\text{max}} \\approx 158~\\text{s}\n$$",
            "answer": "$$\n\\boxed{158}\n$$"
        },
        {
            "introduction": "真实的积雪模型必须处理融化和冻结过程中发生的剧烈能量交换，这是一个典型的“刚性”数值问题。简单的显式方法（如前一个练习中分析的方法）在面对相变时会变得不稳定，除非使用极小的时间步长。这个高级练习将阐释为什么需要使用隐式格式，并指导您为包含潜热效应的能量平衡方程构建一个牛顿法求解器。掌握这种技术对于开发能够准确模拟融雪过程的先进模型是必不可少的。",
            "id": "4089698",
            "problem": "一维雪柱中的单个控制体积在热扩散和相变作用下随时间更新。雪被视为一种多孔介质，具有冰基质和因融化而可能存在的少量液态水。能量守恒定律和傅里叶热传导定律是出发点。假设控制体积的温度为 $T$，密度为 $\\rho$，冰的比热容为常数 $c_i$，热导率为 $k$，并通过一个特征长度尺度 $h$ 与温度为 $T_b$ 的边界耦合。熔点为 $T_m$，熔化潜热为 $L$。一个平滑的液相分数函数 $\\phi(T)$ 在一个狭窄的温度宽度 $\\delta$ 内对熔点 $T_m$ 附近的相变进行正则化，使得当 $T$ 升高超过 $T_m$ 时，$\\phi(T)$ 从 $0$（完全冻结）过渡到 $1$（完全融化）。可能存在一个外部体积热源 $Q_{\\mathrm{ext}}$。单位体积的焓为 $E(T) = \\rho\\,c_i\\,T + \\rho\\,L\\,\\phi(T)$。\n\n从能量守恒方程出发，时间演化遵循\n$$\n\\frac{\\partial E(T)}{\\partial t} = \\nabla\\cdot\\left(k\\,\\nabla T\\right) + Q_{\\mathrm{ext}}.\n$$\n对于一个与温度为 $T_b$ 的单个邻居或边界耦合的控制体积，使用二阶中心差分量级 $k\\,(T_b - T)/h^2$ 的线性交换来近似传导项，从而得到一个体积源。考虑在时间步长 $\\Delta t$ 上的全隐式时间离散化，从已知的 $T^n$ 更新到未知的 $T^{n+1}$。\n\n任务：\n1. 使用焓公式和全隐式时间离散化，推导 $T^{n+1}$ 必须满足的非线性标量方程。不要使用临时的简化公式；从给定的守恒定律和本构关系进行推导。\n2. 请为使用全隐式格式处理熔点 $T_m$ 附近的刚性潜热问题提供理论依据。您的解释应基于由相变正则化产生的表观热容的尺度分析，并说明刚性是如何产生的，以及为什么隐式更新在稳定性和允许的时间步长方面具有优势。\n3. 定义一个关于温度的平滑正则化液相分数函数，\n$$\n\\phi(T) = \\tfrac{1}{2}\\left(1 + \\tanh\\left(\\frac{T - T_m}{\\delta}\\right)\\right),\n$$\n并推导求解 $T^{n+1}$ 非线性方程所需的牛顿迭代法，包括残差 $F(T^{n+1})$ 及其导数 $F'(T^{n+1})$。陈述基于温度和残差容差的停止准则，提出一个基于忽略潜热效应的显式步长的初始猜测，并描述一种确保稳健收敛的阻尼策略。\n4. 实现一个程序，通过使用带线搜索阻尼的牛顿法求解导出的非线性方程，来计算给定参数下的 $T^{n+1}$。最终温度以摄氏度表示，四舍五入到四位小数。除非在测试用例中明确覆盖，否则请使用以下常量：$\\rho = 300\\,\\mathrm{kg/m^3}$， $c_i = 2100\\,\\mathrm{J/(kg\\cdot K)}$， $k = 0.2\\,\\mathrm{W/(m\\cdot K)}$， $h = 0.1\\,\\mathrm{m}$， $T_m = 0.0\\,^{\\circ}\\mathrm{C}$，以及 $L = 334000\\,\\mathrm{J/kg}$。函数 $\\phi(T)$ 必须使用指定的 $\\tanh$ 正则化，其宽度 $\\delta$ 以开尔文为单位（等效于摄氏度温差）。\n5. 设计并运行以下测试套件。对于每个案例，根据给定的 $\\Delta t$、 $T_b$、 $\\delta$ 和 $Q_{\\mathrm{ext}}$，从 $T^n$ 计算 $T^{n+1}$。当省略某个参数时，使用上述默认常量。所有温度单位为摄氏度，时间单位为秒，热源单位为 $\\mathrm{W/m^3}$。\n   - 案例 A（理想路径，近熔点刚性）：$\\Delta t = 3600$， $T^n = -2.0$， $T_b = +1.0$， $\\delta = 0.2$， $Q_{\\mathrm{ext}} = 0$。\n   - 案例 B（强刚性，非常窄的相变区间）：$\\Delta t = 600$， $T^n = -0.01$， $T_b = +2.0$， $\\delta = 0.05$， $Q_{\\mathrm{ext}} = 0$。\n   - 案例 C（在寒冷边界条件下因外部加热而穿越熔点）：$\\Delta t = 3600$， $T^n = -1.0$， $T_b = -5.0$， $\\delta = 0.2$， $Q_{\\mathrm{ext}} = 300$。\n   - 案例 D（非刚性，远低于熔点）：$\\Delta t = 1800$， $T^n = -10.0$， $T_b = -5.0$， $\\delta = 0.2$， $Q_{\\mathrm{ext}} = 0$。\n   - 案例 E（无潜热，线性响应）：$\\Delta t = 3600$， $T^n = -0.5$， $T_b = +0.5$， $\\delta = 0.2$, $Q_{\\mathrm{ext}} = 0$，覆盖 $L = 0$。\n6. 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与测试套件相同：例如，“[resultA,resultB,resultC,resultD,resultE]”。每个结果都必须是一个浮点数，表示以摄氏度为单位的 $T^{n+1}$，并四舍五入到四位小数。\n\n以摄氏度为单位作答。",
            "solution": "此问题的解决方案涉及推导并数值求解单个雪控制体积中温度演化的非线性方程。推导从能量守恒原理开始，并采用全隐式时间离散化来处理与相变潜热相关的刚性问题。\n\n### 任务1：推导 $T^{n+1}$ 的非线性方程\n\n能量守恒的控制偏微分方程如下：\n$$\n\\frac{\\partial E(T)}{\\partial t} = \\nabla\\cdot(k\\,\\nabla T) + Q_{\\mathrm{ext}}\n$$\n其中体积焓为 $E(T) = \\rho\\,c_i\\,T + \\rho\\,L\\,\\phi(T)$。\n\n我们对该方程进行时间和空间上的离散化。对于时间，使用全隐式（一阶后向差分）格式，在新的时间步 n+1 处计算所有项：\n$$\n\\frac{\\partial E(T)}{\\partial t} \\approx \\frac{E(T^{n+1}) - E(T^n)}{\\Delta t}\n$$\n对于单个控制体积中的空间导数，热通量（传导）的散度通过与温度为 $T_b$ 的边界进行线性交换来近似：\n$$\n\\nabla\\cdot(k\\,\\nabla T) \\approx \\frac{k(T_b - T^{n+1})}{h^2}\n$$\n将这些离散近似代入守恒定律，得到未知温度 $T^{n+1}$ 的代数方程：\n$$\n\\frac{E(T^{n+1}) - E(T^n)}{\\Delta t} = \\frac{k(T_b - T^{n+1})}{h^2} + Q_{\\mathrm{ext}}\n$$\n为简化符号，令 $T = T^{n+1}$ 为我们要求解的未知数。我们将方程重新排列成标准的求根形式 $F(T) = 0$：\n$$\nE(T) - E(T^n) - \\Delta t \\left( \\frac{k(T_b - T)}{h^2} + Q_{\\mathrm{ext}} \\right) = 0\n$$\n现在，代入焓的定义 $E(T) = \\rho\\,c_i\\,T + \\rho\\,L\\,\\phi(T)$，并展开：\n$$\n(\\rho\\,c_i\\,T + \\rho\\,L\\,\\phi(T)) - (\\rho\\,c_i\\,T^n + \\rho\\,L\\,\\phi(T^n)) - \\frac{\\Delta t\\,k}{h^2}(T_b - T) - \\Delta t\\,Q_{\\mathrm{ext}} = 0\n$$\n这就是所求的关于 $T = T^{n+1}$ 的非线性标量方程。为了便于实现，将包含未知数 $T$ 的项组合在一起会很有用：\n$$\nF(T) = \\left(\\rho\\,c_i + \\frac{\\Delta t\\,k}{h^2}\\right)T + \\rho\\,L\\,\\phi(T) - \\left[ E(T^n) + \\frac{\\Delta t\\,k\\,T_b}{h^2} + \\Delta t\\,Q_{\\mathrm{ext}} \\right] = 0\n$$\n\n### 任务2：使用全隐式格式的理由\n\n使用全隐式格式的理由是为了克服由相变引入的数值刚性。当一个系统中存在发生在迥然不同的时间尺度上的过程时，就会出现刚性问题。\n\n*表观热容*，$C_{\\mathrm{app}}(T) = dE/dT$，量化了改变温度所需的能量。根据焓的定义，我们有：\n$$\nC_{\\mathrm{app}}(T) = \\frac{d}{dT} \\left( \\rho\\,c_i\\,T + \\rho\\,L\\,\\phi(T) \\right) = \\rho\\,c_i + \\rho\\,L\\,\\phi'(T)\n$$\n给定正则化函数 $\\phi(T) = \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{T - T_m}{\\delta}\\right)\\right)$ 的导数是：\n$$\n\\phi'(T) = \\frac{1}{2\\delta} \\mathrm{sech}^2\\left(\\frac{T - T_m}{\\delta}\\right)\n$$\n双曲正割平方函数 $\\mathrm{sech}^2(x)$ 在 $x=0$ 处有一个高度为 $1$ 的尖峰。因此，在熔点 $T_m$ 附近，$\\phi'(T)$ 会变得非常大，特别是当 $\\delta$ 很小时。这导致峰值表观热容为 $C_{\\mathrm{app}}(T_m) = \\rho\\,c_i + \\rho\\,L/(2\\delta)$，其可能比显热容 $\\rho\\,c_i$ 大几个数量级。\n\n热扩散的特征时间尺度约为 $\\tau \\sim C_{\\mathrm{app}} h^2 / k$。在相变期间，大的 $C_{\\mathrm{app}}$ 会导致一个非常小的时间尺度 $\\tau$。显式时间积分格式（例如，前向欧拉法）仅当时间步长 $\\Delta t$ 小于这个最快的时间尺度时才是稳定的，即 $\\Delta t \\sim \\mathcal{O}(\\tau)$。这将迫使我们使用不切实际的小时间步长，使得模拟的计算成本过高。\n\n全隐式格式对于大得多的时间步长是数值稳定的，其步长通常受限于精度而非稳定性。通过在未来时间 $T^{n+1}$ 处评估所有项，即使对于大的 $\\Delta t$，它也能正确处理温度和焓之间的强反馈。代价是在每一步都需要求解一个非线性代数方程，但对于像这样的刚性系统，这远比执行数百万个微小的显式步骤要高效得多。\n\n### 任务3：牛顿法公式\n\n为了求解非线性方程 $F(T)=0$，我们使用牛顿法，这需要函数 $F(T)$ 及其导数 $F'(T)$。\n\n**残差和导数：**\n残差函数为：\n$$\nF(T) = \\left(\\rho\\,c_i + \\frac{\\Delta t\\,k}{h^2}\\right)T + \\rho\\,L\\,\\phi(T) - \\text{常数}\n$$\n其中常数项包含了前一时间步和边界条件的所有值。关于 T 的导数是：\n$$\nF'(T) = \\frac{dF}{dT} = \\left(\\rho\\,c_i + \\frac{\\Delta t\\,k}{h^2}\\right) + \\rho\\,L\\,\\phi'(T)\n$$\n代入 $\\phi'(T)$ 的表达式：\n$$\nF'(T) = \\left(\\rho\\,c_i + \\frac{\\Delta t\\,k}{h^2}\\right) + \\frac{\\rho\\,L}{2\\delta} \\mathrm{sech}^2\\left(\\frac{T - T_m}{\\delta}\\right)\n$$\n牛顿迭代通过将猜测值 $T_k$ 更新为 $T_{k+1}$ 来进行：\n$$\nT_{k+1} = T_k - \\frac{F(T_k)}{F'(T_k)}\n$$\n\n**初始猜测：**\n一个合适的初始猜测是基于一个忽略潜热效应的显式步骤（即将问题视为简单的热扩散）。这可以从 $\\rho\\,c_i \\frac{T_0 - T^n}{\\Delta t} = \\frac{k(T_b - T^n)}{h^2} + Q_{\\mathrm{ext}}$ 推导得出，得到：\n$$\nT_0 = T^n + \\frac{\\Delta t}{\\rho\\,c_i} \\left( \\frac{k(T_b - T^n)}{h^2} + Q_{\\mathrm{ext}} \\right)\n$$\n\n**阻尼策略：**\n为提高稳健性，特别是对于较差的初始猜测或在相变的高度非线性区域附近，牛顿步通过回溯线搜索进行阻尼。更新公式变为 $T_{k+1} = T_k + \\alpha \\Delta T_k$，其中 $\\Delta T_k = -F(T_k)/F'(T_k)$ 且 $\\alpha \\in (0, 1]$。我们从 $\\alpha = 1$ 开始。如果新点的残差的绝对值不小于当前残差的绝对值（即 $|F(T_k + \\alpha \\Delta T_k)| \\ge |F(T_k)|$），则重复将 $\\alpha$ 减半，直到实现足够的下降或 $\\alpha$ 达到一个最小阈值。\n\n**停止准则：**\n当解收敛时，迭代停止，这由两个条件确定：\n1.  更新步长变得可以忽略不计： $|T_{k+1} - T_k|  \\tau_T$\n2.  残差足够接近于零： $|F(T_{k+1})|  \\tau_F$\n其中 $\\tau_T$ 和 $\\tau_F$ 是很小的容差值（例如，$10^{-8}$）。同时也会设置最大迭代次数以防止无限循环。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the snowpack metamorphism problem.\n    It computes the temperature T^{n+1} for a series of test cases using\n    an implicit solver with Newton's method.\n    \"\"\"\n\n    # Default physical constants\n    DEFAULT_RHO = 300.0  # kg/m^3\n    DEFAULT_C_I = 2100.0  # J/(kg.K)\n    DEFAULT_K = 0.2  # W/(m.K)\n    DEFAULT_H = 0.1  # m\n    DEFAULT_T_M = 0.0  # degrees C\n    DEFAULT_L = 334000.0  # J/kg\n\n    # Newton's method solver parameters\n    MAX_ITER = 50\n    TOL_T = 1e-8  # Tolerance for temperature change\n    TOL_F = 1e-8  # Tolerance for residual magnitude\n    MIN_ALPHA = 1e-8 # Minimum damping factor for line search\n\n    def solve_for_t_next(\n        dt, tn, tb, delta, q_ext,\n        rho=DEFAULT_RHO, c_i=DEFAULT_C_I, k=DEFAULT_K, h=DEFAULT_H,\n        tm=DEFAULT_T_M, l=DEFAULT_L\n    ):\n        \"\"\"\n        Solves for the temperature T^{n+1} of a snow control volume using\n        a fully implicit scheme and Newton's method with line-search damping.\n        All temperatures are in degrees Celsius.\n        \"\"\"\n\n        # --- Define helper functions based on current case parameters ---\n        def phi(T):\n            \"\"\"Smooth liquid fraction function phi(T).\"\"\"\n            if l == 0:\n                return 0.0\n            # Avoid overflow in tanh for large arguments by clamping\n            arg = (T - tm) / delta\n            if arg > 30: return 1.0\n            if arg  -30: return 0.0\n            return 0.5 * (1.0 + np.tanh(arg))\n\n        def phi_prime(T):\n            \"\"\"Derivative of the liquid fraction function, phi'(T).\"\"\"\n            if l == 0:\n                return 0.0\n            arg = (T - tm) / delta\n            # sech(x) = 1/cosh(x)\n            cosh_arg = np.cosh(arg)\n            # Avoid overflow if cosh is very large (sech^2 will be ~0)\n            if cosh_arg > 1e15:\n                return 0.0\n            sech_sq = 1.0 / (cosh_arg**2)\n            return 0.5 / delta * sech_sq\n\n        # --- Pre-compute constant terms for the iteration ---\n        E_n = rho * c_i * tn + rho * l * phi(tn)\n        k_term = k / (h**2)\n        \n        # Constant part 'C' of the residual function F(T) = ... - C\n        C = E_n + dt * (k_term * tb + q_ext)\n\n        # --- Define Residual F(T) and its Derivative F'(T) ---\n        def F(T):\n            \"\"\"Residual function F(T) = 0.\"\"\"\n            return (rho * c_i + dt * k_term) * T + rho * l * phi(T) - C\n\n        def F_prime(T):\n            \"\"\"Derivative F'(T).\"\"\"\n            return (rho * c_i + dt * k_term) + rho * l * phi_prime(T)\n\n        # --- Newton-Raphson Iteration ---\n        # Initial guess based on an explicit step ignoring latent heat\n        t_k = tn + (dt / (rho * c_i)) * (k_term * (tb - tn) + q_ext)\n\n        for _ in range(MAX_ITER):\n            f_val = F(t_k)\n            \n            # Check for convergence on residual\n            if abs(f_val)  TOL_F:\n                return t_k\n\n            f_prime_val = F_prime(t_k)\n\n            if abs(f_prime_val)  1e-12:\n                # Derivative is zero, Newton step is not possible.\n                # This is unlikely with the given problem formulation but is a safe check.\n                break\n\n            delta_t = -f_val / f_prime_val\n\n            # Backtracking line search for damping\n            alpha = 1.0\n            while alpha > MIN_ALPHA:\n                t_new_trial = t_k + alpha * delta_t\n                f_new_val = F(t_new_trial)\n                if abs(f_new_val)  abs(f_val):\n                    # Step accepted\n                    break\n                alpha /= 2.0\n            \n            t_new = t_k + alpha * delta_t\n            \n            # Check for convergence on temperature step size\n            if abs(t_new - t_k)  TOL_T:\n                return t_new\n\n            t_k = t_new\n\n        return t_k # Return best guess if max iterations reached without converging\n\n    # Definition of the test suite from the problem statement.\n    test_cases = [\n        # Case A (happy path, near-melting stiffness)\n        {'dt': 3600, 'tn': -2.0, 'tb': 1.0, 'delta': 0.2, 'q_ext': 0},\n        # Case B (strong stiffness, very narrow transition)\n        {'dt': 600, 'tn': -0.01, 'tb': 2.0, 'delta': 0.05, 'q_ext': 0},\n        # Case C (crossing the melting point due to external heating against a cold boundary)\n        {'dt': 3600, 'tn': -1.0, 'tb': -5.0, 'delta': 0.2, 'q_ext': 300},\n        # Case D (non-stiff, far below melting)\n        {'dt': 1800, 'tn': -10.0, 'tb': -5.0, 'delta': 0.2, 'q_ext': 0},\n        # Case E (no latent heat, linear response)\n        {'dt': 3600, 'tn': -0.5, 'tb': 0.5, 'delta': 0.2, 'q_ext': 0, 'l': 0.0},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        # The 'l' parameter is handled by .get(), which uses the default if not present.\n        t_next = solve_for_t_next(\n            dt=case_params['dt'], tn=case_params['tn'], tb=case_params['tb'], \n            delta=case_params['delta'], q_ext=case_params['q_ext'],\n            l=case_params.get('l', DEFAULT_L)\n        )\n        results.append(t_next)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.4f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}