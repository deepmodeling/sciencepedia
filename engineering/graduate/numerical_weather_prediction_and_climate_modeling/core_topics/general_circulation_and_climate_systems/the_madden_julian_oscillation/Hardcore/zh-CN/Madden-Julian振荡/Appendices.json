{
    "hands_on_practices": [
        {
            "introduction": "实时多变量MJO（RMM）指数是监测和预测MJO状态和强度的标准工具。本练习旨在揭示这些指数背后的计算过程，通过将多变量大气异常场（如风场和向外长波辐射）投影到经验正交函数（EOF）上来实现。通过这个实践，你将掌握如何将复杂的高维数据降维为简洁而有物理意义的指数，这是气候科学中一项至关重要的技能。",
            "id": "4101233",
            "problem": "给你与 Madden–Julian 振荡 (MJO) 的季节内信号相关的、在一组固定经度上的向外长波辐射 (OLR) 以及 $850$ hPa 和 $200$ hPa 纬向风的每日距平。你的任务是通过将一个组合的标准化距平状态投影到提供的经验正交函数 (EOF) 模态上，然后通过季节方差进行标准化，来为每一天计算两个实时多变量 MJO (RMM) 指数，$RMM1$ 和 $RMM2$。\n\n从经验正交函数分析的第一性原理基础出发，假设如下：\n\n- 对每个场而言，第 $t$ 天的距平状态是一个在经度上长度为 $L$ 的向量。设 $x_{\\mathrm{OLR}}(t) \\in \\mathbb{R}^{L}$ 为每日 OLR 距平，单位为 $\\mathrm{W\\, m^{-2}}$；$x_{u850}(t) \\in \\mathbb{R}^{L}$ 为 850 hPa 的每日纬向风距平，单位为 $\\mathrm{m\\, s^{-1}}$；$x_{u200}(t) \\in \\mathbb{R}^{L}$ 为 200 hPa 的每日纬向风距平，单位为 $\\mathrm{m\\, s^{-1}}$。\n- 为形成一个使每个场的方差贡献相等的无量纲组合状态，定义缩放系数 $\\alpha_{\\mathrm{OLR}}$、$\\alpha_{u850}$ 和 $\\alpha_{u200}$。通过按 OLR、$u850$、$u200$ 的顺序串联三个缩放后的距平向量，构造标准化的组合状态\n$$\ny(t) = \\left[\\alpha_{\\mathrm{OLR}}\\, x_{\\mathrm{OLR}}(t),\\ \\alpha_{u850}\\, x_{u850}(t),\\ \\alpha_{u200}\\, x_{u200}(t)\\right] \\in \\mathbb{R}^{3L},\n$$\n。\n- 提供的两个 EOF 模态 $e_{1}$ 和 $e_{2}$ 均为 $\\mathbb{R}^{3L}$ 中的向量，与标准化组合状态的协方差算子的前两个模态相关联。在标准化空间中，这两个 EOF 模态必须是标准正交的。如果给定的模态不是标准正交的，你必须首先在 $\\mathbb{R}^{3L}$ 中使用 Gram–Schmidt 过程将它们标准正交化，然后将它们归一化为单位范数。\n- 第 $t$ 天的主成分振幅是通过将 $y(t)$ 正交投影到每个 EOF 上得到的，\n$$\na_{1}(t) = \\langle y(t), e_{1} \\rangle,\\quad a_{2}(t) = \\langle y(t), e_{2} \\rangle,\n$$\n其中 $\\langle \\cdot, \\cdot \\rangle$ 表示 $\\mathbb{R}^{3L}$ 中的欧几里得内积。\n- 为了考虑方差的季节性调制，设 $\\sigma_{1}(t)  0$ 和 $\\sigma_{2}(t)  0$ 表示与第 $t$ 天的第一和第二 EOF 模态相关的季节性方差尺度。定义标准化指数\n$$\nRMM1(t) = \\frac{a_{1}(t)}{\\sigma_{1}(t)},\\quad RMM2(t) = \\frac{a_{2}(t)}{\\sigma_{2}(t)}.\n$$\n指数 $RMM1(t)$ 和 $RMM2(t)$ 是没有物理单位的无量纲数。\n\n实现一个程序，为以下科学上合理且自洽的测试套件执行上述计算。使用 $L = 4$ 个经度。使用缩放系数 $\\alpha_{\\mathrm{OLR}} = 1/40$、$\\alpha_{u850} = 1/5$ 和 $\\alpha_{u200} = 1/10$。\n\n为标准化空间提供的原始 EOF 模态以按变量划分的块的形式给出，每个块的长度为 $L$，并按 OLR、$u850$、$u200$ 的顺序串联。设\n- 对于第一个 EOF，$e_{1}^{\\mathrm{raw}} \\in \\mathbb{R}^{12}$，\n$$\ne_{1,\\mathrm{OLR}} = [0.5,\\ 0.5,\\ -0.5,\\ -0.5],\\quad\ne_{1,u850} = [0.5,\\ -0.5,\\ 0.5,\\ -0.5],\\quad\ne_{1,u200} = [0.25,\\ 0.25,\\ 0.25,\\ 0.25],\n$$\n并取 $e_{1}^{\\mathrm{raw}}$ 为这三个 $L$-向量的串联。\n- 对于第二个 EOF，$e_{2}^{\\mathrm{raw}} \\in \\mathbb{R}^{12}$，\n$$\ne_{2,\\mathrm{OLR}} = [0.5,\\ -0.5,\\ 0.5,\\ -0.5],\\quad\ne_{2,u850} = [-0.5,\\ -0.5,\\ 0.5,\\ 0.5],\\quad\ne_{2,u200} = [-0.25,\\ 0.25,\\ -0.25,\\ 0.25],\n$$\n并取 $e_{2}^{\\mathrm{raw}}$ 为这三个 $L$-向量的串联。\n\n在投影之前，对 $\\mathbb{R}^{12}$ 中的 $\\{e_{1}^{\\mathrm{raw}}, e_{2}^{\\mathrm{raw}}\\}$ 应用 Gram–Schmidt 标准正交化，以产生一个标准正交集 $\\{e_{1}, e_{2}\\}$，满足 $\\lVert e_{i} \\rVert_{2} = 1$ 和 $\\langle e_{1}, e_{2} \\rangle = 0$。\n\n为以下 4 个测试用例计算 $RMM1$ 和 $RMM2$（每个用例提供 OLR（单位 $\\mathrm{W\\, m^{-2}}$）、$u850$（单位 $\\mathrm{m\\, s^{-1}}$）、$u200$（单位 $\\mathrm{m\\, s^{-1}}$）的每日距平，以及季节性方差尺度，所有数据均在相同的 $L = 4$ 个经度上）：\n\n- 案例 1（通用平衡投影）：\n  - $x_{\\mathrm{OLR}} = [-20,\\ -15,\\ 15,\\ 20]$,\n  - $x_{u850} = [4,\\ -4,\\ 4,\\ -4]$,\n  - $x_{u200} = [-8,\\ -8,\\ -8,\\ -8]$,\n  - $\\sigma_{1} = 1.0$, $\\sigma_{2} = 1.2$。\n- 案例 2（第二模态主导对齐）：\n  - $x_{\\mathrm{OLR}} = [-20,\\ 20,\\ -20,\\ 20]$,\n  - $x_{u850} = [-4,\\ -4,\\ 4,\\ 4]$,\n  - $x_{u200} = [-8,\\ 8,\\ -8,\\ 8]$,\n  - $\\sigma_{1} = 1.4$, $\\sigma_{2} = 0.9$。\n- 案例 3（零距平，边界检查）：\n  - $x_{\\mathrm{OLR}} = [0,\\ 0,\\ 0,\\ 0]$,\n  - $x_{u850} = [0,\\ 0,\\ 0,\\ 0]$,\n  - $x_{u200} = [0,\\ 0,\\ 0,\\ 0]$,\n  - $\\sigma_{1} = 1.0$, $\\sigma_{2} = 1.0$。\n- 案例 4（第一模态的反相）：\n  - $x_{\\mathrm{OLR}} = [20,\\ 15,\\ -15,\\ -20]$,\n  - $x_{u850} = [-4,\\ 4,\\ -4,\\ 4]$,\n  - $x_{u200} = [8,\\ 8,\\ 8,\\ 8]$,\n  - $\\sigma_{1} = 0.8$, $\\sigma_{2} = 1.6$。\n\n所有输出必须是无量纲的（无单位）。你的程序应生成单行输出，其中包含一个由 4 个双元素列表组成的逗号分隔列表，每个双元素列表为对应案例的 $[RMM1,RMM2]$，四舍五入到六位小数。输出中不得有空格。例如，格式必须与\n$$\n[[r_{11},r_{12}],[r_{21},r_{22}],[r_{31},r_{32}],[r_{41},r_{42}]],\n$$\n完全一样，其中 $r_{i1}$ 和 $r_{i2}$ 是案例 $i$ 的四舍五入后的浮点数。\n\n本问题旨在评估你从经验正交函数分析的基本定义中推导投影和归一化的能力，以及构建标准化组合状态、强制给定模态的标准正交性并正确生成无量纲指数的能力。在没有任何外部输入的情况下实现计算；所有数据均已在本问题陈述中提供。通过在输入中保留物理单位，并使用指定的缩放来在投影和季节性标准化之前获得无量纲组合状态，以确保科学真实性。最终输出必须是浮点数。",
            "solution": "这个问题是有效的，因为它在科学上基于气候科学和统计分析的原理，特别是应用于 Madden-Julian 振荡 (MJO) 的经验正交函数 (EOF) 分析。该问题是适定的，提供了所有必要的数据、常数和用于计算实时多变量 MJO (RMM) 指数的清晰、序贯的数学过程。定义和数据是自洽、客观且物理上合理的。\n\n对于给定的某天 $t$，RMM 指数 $RMM1$ 和 $RMM2$ 的计算遵循一个结构化的、基于原理的过程。这包括构建一个标准化的距平状态向量，将其投影到一个标准正交的 EOF 模态集上，然后用季节方差对得到的主成分振幅进行缩放。\n\n首先，我们根据提供的信息定义参数和输入向量。经度数为 $L=4$。第 $t$ 天的距平状态由三个场组成：向外长波辐射 ($x_{\\mathrm{OLR}}(t) \\in \\mathbb{R}^{4}$) 、850 hPa 的纬向风 ($x_{u850}(t) \\in \\mathbb{R}^{4}$) 和 200 hPa 的纬向风 ($x_{u200}(t) \\in \\mathbb{R}^{4}$)。\n\n第一步是构建标准化组合状态向量 $y(t) \\in \\mathbb{R}^{12}$。这是通过用各自的系数缩放每个距平向量并将结果串联起来实现的。给出的缩放系数为 $\\alpha_{\\mathrm{OLR}} = 1/40$、$\\alpha_{u850} = 1/5$ 和 $\\alpha_{u200} = 1/10$。组合状态形成如下：\n$$\ny(t) = \\left[\\alpha_{\\mathrm{OLR}}\\, x_{\\mathrm{OLR}}(t),\\ \\alpha_{u850}\\, x_{u850}(t),\\ \\alpha_{u200}\\, x_{u200}(t)\\right]\n$$\n\n第二步是确保状态向量将投影其上的 EOF 模态形成一个标准正交基。提供的原始模态是 $e_{1}^{\\mathrm{raw}}$ 和 $e_{2}^{\\mathrm{raw}}$，两者都在 $\\mathbb{R}^{12}$ 中。\n$e_{1}^{\\mathrm{raw}} = [0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, 0.25, 0.25, 0.25, 0.25]$\n$e_{2}^{\\mathrm{raw}} = [0.5, -0.5, 0.5, -0.5, -0.5, -0.5, 0.5, 0.5, -0.25, 0.25, -0.25, 0.25]$\n\n我们必须使用 Gram-Schmidt 过程对这些向量进行标准正交化。设 $v_1 = e_{1}^{\\mathrm{raw}}$ 和 $v_2 = e_{2}^{\\mathrm{raw}}$。标准正交基 $\\{e_1, e_2\\}$ 的计算如下：\n$u_1 = v_1$\n$e_1 = \\frac{u_1}{\\lVert u_1 \\rVert_2}$\n$u_2 = v_2 - \\langle v_2, e_1 \\rangle e_1$\n$e_2 = \\frac{u_2}{\\lVert u_2 \\rVert_2}$\n其中 $\\langle \\cdot, \\cdot \\rangle$ 是欧几里得内积。\n\n首先，我们计算 $v_1$ 的范数平方：\n$$\n\\lVert v_1 \\rVert_2^2 = (4 \\times 0.5^2) + (4 \\times 0.5^2) + (4 \\times 0.25^2) = 1 + 1 + 0.25 = 2.25\n$$\n因此，$\\lVert v_1 \\rVert_2 = \\sqrt{2.25} = 1.5$。\n接下来，我们计算 $v_1$ 和 $v_2$ 的内积：\n$$\n\\langle v_1, v_2 \\rangle = (0.5 \\cdot 0.5 + 0.5 \\cdot (-0.5) + \\dots) + (0.5 \\cdot (-0.5) + \\dots) + (0.25 \\cdot (-0.25) + \\dots) = 0 + 0 + 0 = 0\n$$\n由于原始向量已经正交，Gram-Schmidt 过程简化为归一化。\n$e_1 = \\frac{v_1}{\\lVert v_1 \\rVert_2} = \\frac{1}{1.5} e_{1}^{\\mathrm{raw}}$。\n对于 $e_2$，我们有 $u_2 = v_2 - \\langle v_2, e_1 \\rangle e_1 = v_2 - 0 = v_2$。我们只需要对 $v_2$ 进行归一化。\n$$\n\\lVert v_2 \\rVert_2^2 = (4 \\times 0.5^2) + (4 \\times (-0.5)^2) + (4 \\times (-0.25)^2) = 1 + 1 + 0.25 = 2.25\n$$\n所以，$\\lVert v_2 \\rVert_2 = \\sqrt{2.25} = 1.5$。\n$e_2 = \\frac{v_2}{\\lVert v_2 \\rVert_2} = \\frac{1}{1.5} e_{2}^{\\mathrm{raw}}$。\n标准正交的 EOF 是 $e_1 = (2/3) e_{1}^{\\mathrm{raw}}$ 和 $e_2 = (2/3) e_{2}^{\\mathrm{raw}}$。\n\n第三步是通过将标准化状态向量 $y(t)$ 投影到标准正交的 EOF 上来计算主成分振幅 $a_1(t)$ 和 $a_2(t)$：\n$$\na_{1}(t) = \\langle y(t), e_{1} \\rangle, \\quad a_{2}(t) = \\langle y(t), e_{2} \\rangle\n$$\n\n最后一步是使用给定的季节性方差尺度 $\\sigma_1(t)$ 和 $\\sigma_2(t)$ 对这些振幅进行标准化，以获得无量纲的 RMM 指数：\n$$\nRMM1(t) = \\frac{a_{1}(t)}{\\sigma_{1}(t)}, \\quad RMM2(t) = \\frac{a_{2}(t)}{\\sigma_{2}(t)}\n$$\n\n现在我们将此过程应用于每个测试用例。\n\n案例 1：\n- $x_{\\mathrm{OLR}} = [-20, -15, 15, 20]$, $x_{u850} = [4, -4, 4, -4]$, $x_{u200} = [-8, -8, -8, -8]$。\n- $\\sigma_{1} = 1.0$, $\\sigma_{2} = 1.2$。\n缩放后的距平向量是：\n$\\alpha_{\\mathrm{OLR}} x_{\\mathrm{OLR}} = [-0.5, -0.375, 0.375, 0.5]$\n$\\alpha_{u850} x_{u850} = [0.8, -0.8, 0.8, -0.8]$\n$\\alpha_{u200} x_{u200} = [-0.8, -0.8, -0.8, -0.8]$\n$y_1 = [-0.5, -0.375, 0.375, 0.5, 0.8, -0.8, 0.8, -0.8, -0.8, -0.8, -0.8, -0.8]$。\n主成分是：\n$a_1(1) = \\langle y_1, e_1 \\rangle = \\frac{1}{1.5} \\langle y_1, e_{1}^{\\mathrm{raw}} \\rangle = \\frac{1}{1.5}(-0.875 + 1.6 - 0.8) = \\frac{-0.075}{1.5} = -0.05$。\n$a_2(1) = \\langle y_1, e_2 \\rangle = \\frac{1}{1.5} \\langle y_1, e_{2}^{\\mathrm{raw}} \\rangle = \\frac{1}{1.5}(-0.125 + 0.0 + 0.0) = \\frac{-0.125}{1.5} = -\\frac{1}{12} \\approx -0.083333$。\nRMM 指数是：\n$RMM1(1) = \\frac{-0.05}{1.0} = -0.05$。\n$RMM2(1) = \\frac{-1/12}{1.2} = \\frac{-1/12}{6/5} = -\\frac{5}{72} \\approx -0.069444$。\n\n案例 2：\n- $x_{\\mathrm{OLR}} = [-20, 20, -20, 20]$, $x_{u850} = [-4, -4, 4, 4]$, $x_{u200} = [-8, 8, -8, 8]$。\n- $\\sigma_{1} = 1.4$, $\\sigma_{2} = 0.9$。\n缩放后的距平向量是：\n$\\alpha_{\\mathrm{OLR}} x_{\\mathrm{OLR}} = [-0.5, 0.5, -0.5, 0.5]$\n$\\alpha_{u850} x_{u850} = [-0.8, -0.8, 0.8, 0.8]$\n$\\alpha_{u200} x_{u200} = [-0.8, 0.8, -0.8, 0.8]$\n$y_2 = [-0.5, 0.5, -0.5, 0.5, -0.8, -0.8, 0.8, 0.8, -0.8, 0.8, -0.8, 0.8]$。\n$a_1(2) = \\frac{1}{1.5} \\langle y_2, e_{1}^{\\mathrm{raw}} \\rangle = \\frac{1}{1.5}(0.0 + 0.0 + 0.0) = 0.0$。\n$a_2(2) = \\frac{1}{1.5} \\langle y_2, e_{2}^{\\mathrm{raw}} \\rangle = \\frac{1}{1.5}(-1.0 + 1.6 + 0.8) = \\frac{1.4}{1.5} = \\frac{14}{15} \\approx 0.933333$。\nRMM 指数是：\n$RMM1(2) = \\frac{0.0}{1.4} = 0.0$。\n$RMM2(2) = \\frac{14/15}{0.9} = \\frac{14/15}{9/10} = \\frac{14 \\times 10}{15 \\times 9} = \\frac{28}{27} \\approx 1.037037$。\n\n案例 3：\n- $x_{\\mathrm{OLR}} = [0, 0, 0, 0]$, $x_{u850} = [0, 0, 0, 0]$, $x_{u200} = [0, 0, 0, 0]$。\n- $\\sigma_{1} = 1.0$, $\\sigma_{2} = 1.0$。\n组合状态向量 $y_3$ 是零向量。零向量与任何向量的内积均为 $0$。\n$a_1(3) = 0.0$, $a_2(3) = 0.0$。\nRMM 指数是：\n$RMM1(3) = \\frac{0.0}{1.0} = 0.0$。\n$RMM2(3) = \\frac{0.0}{1.0} = 0.0$。\n\n案例 4：\n- $x_{\\mathrm{OLR}} = [20, 15, -15, -20]$, $x_{u850} = [-4, 4, -4, 4]$, $x_{u200} = [8, 8, 8, 8]$。\n- $\\sigma_{1} = 0.8$, $\\sigma_{2} = 1.6$。\n输入距平向量是案例 1 中向量的负值。因此，组合状态向量 $y_4 = -y_1$。根据内积的线性性质，$a_1(4) = \\langle -y_1, e_1 \\rangle = -a_1(1) = 0.05$ 且 $a_2(4) = \\langle -y_1, e_2 \\rangle = -a_2(1) = 1/12$。\nRMM 指数是：\n$RMM1(4) = \\frac{0.05}{0.8} = \\frac{1/20}{4/5} = \\frac{5}{80} = \\frac{1}{16} = 0.0625$。\n$RMM2(4) = \\frac{1/12}{1.6} = \\frac{1/12}{8/5} = \\frac{5}{96} \\approx 0.052083$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Real-time Multivariate MJO (RMM) indices for a set of test cases.\n    \"\"\"\n    # Define problem constants and raw EOF patterns\n    L = 4\n    alpha_olr = 1 / 40\n    alpha_u850 = 1 / 5\n    alpha_u200 = 1 / 10\n\n    e1_raw_olr = np.array([0.5, 0.5, -0.5, -0.5])\n    e1_raw_u850 = np.array([0.5, -0.5, 0.5, -0.5])\n    e1_raw_u200 = np.array([0.25, 0.25, 0.25, 0.25])\n    e1_raw = np.concatenate([e1_raw_olr, e1_raw_u850, e1_raw_u200])\n\n    e2_raw_olr = np.array([0.5, -0.5, 0.5, -0.5])\n    e2_raw_u850 = np.array([-0.5, -0.5, 0.5, 0.5])\n    e2_raw_u200 = np.array([-0.25, 0.25, -0.25, 0.25])\n    e2_raw = np.concatenate([e2_raw_olr, e2_raw_u850, e2_raw_u200])\n\n    raw_eofs = [e1_raw, e2_raw]\n\n    # Perform Gram-Schmidt orthonormalization on the raw EOF patterns.\n    # The process is required by the problem statement, even if vectors might be\n    # already orthogonal.\n    orthonormal_eofs = []\n    for v in raw_eofs:\n        u = np.copy(v)\n        for e in orthonormal_eofs:\n            # Project u onto the basis vector e and subtract\n            proj = np.dot(u, e) * e\n            u -= proj\n        \n        # Normalize the resulting vector\n        norm = np.linalg.norm(u)\n        if norm > 1e-12:  # Tolerance for floating point precision\n            orthonormal_eofs.append(u / norm)\n    \n    e1, e2 = orthonormal_eofs[0], orthonormal_eofs[1]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"x_olr\": np.array([-20, -15, 15, 20]),\n            \"x_u850\": np.array([4, -4, 4, -4]),\n            \"x_u200\": np.array([-8, -8, -8, -8]),\n            \"sigma1\": 1.0,\n            \"sigma2\": 1.2\n        },\n        {\n            \"x_olr\": np.array([-20, 20, -20, 20]),\n            \"x_u850\": np.array([-4, -4, 4, 4]),\n            \"x_u200\": np.array([-8, 8, -8, 8]),\n            \"sigma1\": 1.4,\n            \"sigma2\": 0.9\n        },\n        {\n            \"x_olr\": np.array([0, 0, 0, 0]),\n            \"x_u850\": np.array([0, 0, 0, 0]),\n            \"x_u200\": np.array([0, 0, 0, 0]),\n            \"sigma1\": 1.0,\n            \"sigma2\": 1.0\n        },\n        {\n            \"x_olr\": np.array([20, 15, -15, -20]),\n            \"x_u850\": np.array([-4, 4, -4, 4]),\n            \"x_u200\": np.array([8, 8, 8, 8]),\n            \"sigma1\": 0.8,\n            \"sigma2\": 1.6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Construct the standardized combined state vector y(t)\n        y_olr = alpha_olr * case[\"x_olr\"]\n        y_u850 = alpha_u850 * case[\"x_u850\"]\n        y_u200 = alpha_u200 * case[\"x_u200\"]\n        \n        y = np.concatenate([y_olr, y_u850, y_u200])\n\n        # Step 2: Compute principal component amplitudes a1 and a2\n        a1 = np.dot(y, e1)\n        a2 = np.dot(y, e2)\n\n        # Step 3: Compute the standardized RMM indices\n        rmm1 = a1 / case[\"sigma1\"]\n        rmm2 = a2 / case[\"sigma2\"]\n        \n        results.append([rmm1, rmm2])\n\n    # Final print statement in the exact required format.\n    # The format must be [[r11,r12],[r21,r22],...] with no spaces.\n    inner_strings = [f\"[{round(r[0], 6)},{round(r[1], 6)}]\" for r in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在学会如何追踪MJO之后，我们进一步探究其传播的物理机制。湿静力能量（Moist Static Energy, MSE）收支是理解MJO东传机理的核心理论框架。这项练习提供了一个具体的方法，用于计算MSE收支中的关键项（如水平水汽平流），从而定量地检验关于对流预处理（preconditioning）过程的科学假说。",
            "id": "4101301",
            "problem": "给定一个一维纬向剖面，该剖面代表了马登-朱利安振荡（MJO）活跃期印度洋暖池的典型状况。目标是计算观测到的对流包前方区域的整层积分湿静力能（MSE）趋势，并使用一个数学定义的判据来检验水平水汽平流是否在深对流的气柱预处理过程中占主导地位。\n\n从基本热力学原理和核心定义出发。设湿静力能定义为 $h = c_p T + L_v q + g z$，其中 $c_p$ 是干空气定压比热容，$T$ 是温度，$L_v$ 是蒸发潜热，$q$ 是比湿，$g$ 是重力加速度，$z$ 是高度。考虑从热力学第一定律和能量守恒定律为静力平衡大气推导出的单位面积整层积分MSE收支，其中包括水平MSE通量散度、垂直MSE通量辐合、辐射加热和地表湍流焓通量的贡献。在对流包前方的对流前区域，使用适用于MJO数值天气预报和气候模拟的、经过充分检验的近似方法，分离出可以从再分析资料中可靠估算的项：水平水汽平流、整层净辐射和地表湍流焓通量。\n\n你的程序必须：\n- 计算单位面积的气柱质量 $m = \\Delta p / g$，其中 $\\Delta p$ 是气层的气压厚度（单位：$\\mathrm{Pa}$），$g$ 是重力加速度（单位：$\\mathrm{m}\\,\\mathrm{s}^{-2}$）。\n- 使用有限差分格式，根据给定的比湿剖面 $q(x)$（单位：$\\mathrm{kg}\\,\\mathrm{kg}^{-1}$）和网格间距 $\\Delta x$（单位：$\\mathrm{m}$），近似计算评估点处的局地纬向水汽梯度。在内部点使用中心差分，在边界使用单边差分。\n- 使用评估点处的纬向风速 $u$（单位：$\\mathrm{m}\\,\\mathrm{s}^{-1}$）计算水平水汽平流对单位面积整层MSE趋势的贡献。假设主要的水平MSE平流贡献来自水汽分量。使用下面提供的物理上一致的常数 $L_v$ 和 $g$。\n- 将水平水汽平流趋势与给定的整层净辐射加热率 $R$（单位：$\\mathrm{W}\\,\\mathrm{m}^{-2}$）和地表湍流焓通量（即潜热通量 $F_{\\mathrm{lat}}$ 和感热通量 $F_{\\mathrm{sen}}$ 之和，$E = F_{\\mathrm{lat}} + F_{\\mathrm{sen}}$，单位均为 $\\mathrm{W}\\,\\mathrm{m}^{-2}$）相结合，得到单位面积的总对流前MSE趋势 $T$。\n- 评估水平水汽平流是否主导预处理过程，其判据为：水平水汽平流的绝对贡献至少占三项贡献绝对值之和的一半，并且总趋势为正。形式上，定义主导分数 $f = \\lvert A_h \\rvert / (\\lvert A_h \\rvert + \\lvert R \\rvert + \\lvert E \\rvert)$，其中 $A_h$ 是水平水汽平流的贡献。如果 $T > 0$ 且 $f \\ge 0.5$，则判定为占主导地位。\n\n使用的常数：\n- $L_v = 2.5 \\times 10^6\\,\\mathrm{J}\\,\\mathrm{kg}^{-1}$。\n- $g = 9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$。\n- $c_p$ 和 $z$ 仅在概念基础上需要时使用；本任务的数值计算中不需要它们。\n\n单位和输出：\n- 以 $\\mathrm{W}\\,\\mathrm{m}^{-2}$ 表示总MSE趋势 $T$，四舍五入到三位小数。\n- 以小数形式表示主导分数 $f$，四舍五入到三位小数。\n- 主导决策必须是一个布尔值。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个形式为 $[T, f, \\text{dominance}]$ 的列表。例如，输出格式必须类似于 $[[T_1,f_1,\\text{True}],[T_2,f_2,\\text{False}],\\dots]$，占一行。\n\n测试套件和参数说明：\n对于每个测试用例，将为您提供：\n- 比湿剖面 $q$，以 $\\mathrm{kg}\\,\\mathrm{kg}^{-1}$ 为单位的值列表。\n- 评估点处的纬向风速 $u$，单位为 $\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n- 网格间距 $\\Delta x$，单位为 $\\mathrm{m}$。\n- 气层的气压厚度 $\\Delta p$，单位为 $\\mathrm{Pa}$。\n- 整层净辐射加热率 $R$，单位为 $\\mathrm{W}\\,\\mathrm{m}^{-2}$。\n- 地表通量分量 $F_{\\mathrm{lat}}$（潜热）和 $F_{\\mathrm{sen}}$（感热），单位均为 $\\mathrm{W}\\,\\mathrm{m}^{-2}$。\n- 对流包中心的索引 $i_c$ 和一个前方偏移量 $o$，它们定义了评估索引 $i = i_c + o$（中心以东）。在边界处使用单边差分。\n\n使用以下测试套件：\n1. 普遍的预处理情况，伴有强烈的自西向东的水汽减少和西风：\n   - $q = [0.0200, 0.0195, 0.0190, 0.0185, 0.0180]$,\n   - $u = 5.0\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$,\n   - $\\Delta x = 250000\\,\\mathrm{m}$,\n   - $\\Delta p = 70000\\,\\mathrm{Pa}$,\n   - $R = -30.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $F_{\\mathrm{lat}} = 20.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $F_{\\mathrm{sen}} = 10.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $i_c = 2$, $o = 1$.\n2. 边界条件，水汽梯度可忽略不计：\n   - $q = [0.0185, 0.0185, 0.0185, 0.0185, 0.0185]$,\n   - $u = 4.0\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$,\n   - $\\Delta x = 250000\\,\\mathrm{m}$,\n   - $\\Delta p = 70000\\,\\mathrm{Pa}$,\n   - $R = -20.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $F_{\\mathrm{lat}} = 15.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $F_{\\mathrm{sen}} = 10.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $i_c = 2$, $o = 1$.\n3. 强烈的辐射冷却压倒了平流作用：\n   - $q = [0.0198, 0.0194, 0.0190, 0.0186, 0.0182]$,\n   - $u = 3.0\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$,\n   - $\\Delta x = 250000\\,\\mathrm{m}$,\n   - $\\Delta p = 70000\\,\\mathrm{Pa}$,\n   - $R = -150.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $F_{\\mathrm{lat}} = 40.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $F_{\\mathrm{sen}} = 10.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $i_c = 2$, $o = 1$.\n4. 评估点位于区域边界，水汽向东增加：\n   - $q = [0.0180, 0.0185, 0.0190, 0.0195, 0.0200]$,\n   - $u = 5.0\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$,\n   - $\\Delta x = 250000\\,\\mathrm{m}$,\n   - $\\Delta p = 70000\\,\\mathrm{Pa}$,\n   - $R = -20.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $F_{\\mathrm{lat}} = 60.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $F_{\\mathrm{sen}} = 20.0\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$,\n   - $i_c = 3$, $o = 1$.\n\n你的任务是实现一个完整的程序，为每个测试用例计算总MSE趋势 $T$（单位：$\\mathrm{W}\\,\\mathrm{m}^{-2}$）、主导分数 $f$（小数形式）以及布尔类型的主导决策。程序必须生成单行输出，包含一个形式为 $[[T_1,f_1,\\text{dom}_1],[T_2,f_2,\\text{dom}_2],[T_3,f_3,\\text{dom}_3],[T_4,f_4,\\text{dom}_4]]$ 的列表。",
            "solution": "该问题要求在马登-朱利安振荡（MJO）的背景下，计算对流包前方的整层积分湿静力能（MSE）趋势。我们需要根据一个特定的数学判据，判断水平水汽平流是否是主导的预处理机制。\n\n分析始于单位质量湿静力能 $h$ 的定义：\n$$h = c_p T + L_v q + g z$$\n其中 $c_p$ 是干空气定压比热容，$T$ 是温度，$L_v$ 是蒸发潜热，$q$ 是比湿，$g$ 是重力加速度，$z$ 是高度。\n\n整层积分MSE的局地时间趋势，记为 $\\langle h \\rangle = \\frac{1}{g} \\int_{p_t}^{p_s} h \\, dp$，由大气能量收支决定。根据问题陈述，我们考虑一个对流前环境的简化收支方程，该方程分离了水平平流、辐射和地表通量的贡献：\n$$\\frac{\\partial \\langle h \\rangle}{\\partial t} = A_h + R + E$$\n在此，$\\frac{\\partial \\langle h \\rangle}{\\partial t}$ 是总MSE趋势 $T$，单位为 $\\mathrm{W}\\,\\mathrm{m}^{-2}$。$A_h$ 代表由水平平流引起的整层积分MSE趋势。$R$ 是整层净辐射加热率，$E$ 是总地表湍流焓通量，由潜热通量 $F_{\\mathrm{lat}}$ 和感热通量 $F_{\\mathrm{sen}}$ 之和给出，即 $E = F_{\\mathrm{lat}} + F_{\\mathrm{sen}}$。\n\n一个关键步骤是构建水平平流项 $A_h$。整层积分的MSE水平平流的完整项是 $-\\langle \\mathbf{v}_h \\cdot \\nabla_h h \\rangle$，其中 $\\mathbf{v}_h$ 是水平风矢量，$\\nabla_h$ 是水平梯度算子。问题指定通过只考虑纬向（东西）分量并假设水汽平流是MSE平流的主要贡献者来简化此项。这是一个在湿度梯度较大的湿热带地区常见且合理的近似。因此，该项变为：\n$$A_h \\approx - \\left\\langle u \\frac{\\partial (L_v q)}{\\partial x} \\right\\rangle$$\n其中 $u$ 是纬向风，$x$ 是纬向坐标。由于 $L_v$ 是常数，我们有：\n$$A_h = -L_v \\left\\langle u \\frac{\\partial q}{\\partial x} \\right\\rangle$$\n整层积分 $\\langle \\cdot \\rangle$ 是对一个气压厚度为 $\\Delta p$ 的单一大气层进行的。假设 $u$ 和 $\\frac{\\partial q}{\\partial x}$ 在整个层中是恒定的，积分简化为乘以单位面积的气柱质量 $m = \\frac{\\Delta p}{g}$：\n$$A_h = -L_v u \\left( \\frac{\\partial q}{\\partial x} \\right) \\frac{\\Delta p}{g}$$\n提供的常数为 $L_v = 2.5 \\times 10^6\\,\\mathrm{J}\\,\\mathrm{kg}^{-1}$ 和 $g = 9.81\\,\\mathrm{m}\\,\\mathrm{s}^{-2}$。\n\n为了计算 $A_h$，必须根据在间距为 $\\Delta x$ 的网格点上提供的离散比湿剖面 $q(x)$ 来近似计算纬向水汽梯度 $\\frac{\\partial q}{\\partial x}$。问题指定了一个基于长度为 $N$ 的剖面内评估索引 $i$（索引从 $0$ 到 $N-1$）的有限差分格式：\n- 对于内部点（$0  i  N-1$），使用二阶中心差分：\n$$\\frac{\\partial q}{\\partial x} \\bigg\\rvert_{i} \\approx \\frac{q_{i+1} - q_{i-1}}{2 \\Delta x}$$\n- 对于边界点，使用一阶单边差分。在右边界（$i=N-1$），这是一个后向差分：\n$$\\frac{\\partial q}{\\partial x} \\bigg\\rvert_{i} \\approx \\frac{q_i - q_{i-1}}{\\Delta x}$$\n- 问题不要求在左边界（$i=0$）进行评估，但为完整起见，前向差分为 $\\frac{q_{i+1} - q_i}{\\Delta x}$。\n\n在所有分量都定义好之后，总的对流前MSE趋势计算如下：\n$$T = A_h + R + E$$\n为了评估水平水汽平流是否是主导的预处理因子，计算主导分数 $f$。该分数是水汽平流趋势的绝对值与所有贡献趋势的绝对值之和的比率：\n$$f = \\frac{\\lvert A_h \\rvert}{\\lvert A_h \\rvert + \\lvert R \\rvert + \\lvert E \\rvert}$$\n主导地位的判据是双重的：总趋势必须为正（表示气柱增湿或增暖，有利于对流），并且主导分数必须至少为 $0.5$。\n1. $T > 0$\n2. $f \\ge 0.5$\n必须同时满足这两个条件，主导决策才为真。算法接着将这些计算应用于每个测试用例，并将 $T$ 和 $f$ 的最终数值结果四舍五入到三位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the MJO preconditioning problem for a suite of test cases.\n    \"\"\"\n    \n    # Define physical constants\n    L_v = 2.5e6  # Latent heat of vaporization (J/kg)\n    g = 9.81     # Gravitational acceleration (m/s^2)\n\n    # Test suite as provided in the problem description\n    test_cases = [\n        # Case 1: General preconditioning\n        {\n            \"q\": [0.0200, 0.0195, 0.0190, 0.0185, 0.0180],\n            \"u\": 5.0, \"delta_x\": 250000.0, \"delta_p\": 70000.0,\n            \"R\": -30.0, \"F_lat\": 20.0, \"F_sen\": 10.0,\n            \"i_c\": 2, \"o\": 1\n        },\n        # Case 2: Negligible moisture gradient\n        {\n            \"q\": [0.0185, 0.0185, 0.0185, 0.0185, 0.0185],\n            \"u\": 4.0, \"delta_x\": 250000.0, \"delta_p\": 70000.0,\n            \"R\": -20.0, \"F_lat\": 15.0, \"F_sen\": 10.0,\n            \"i_c\": 2, \"o\": 1\n        },\n        # Case 3: Strong radiative cooling\n        {\n            \"q\": [0.0198, 0.0194, 0.0190, 0.0186, 0.0182],\n            \"u\": 3.0, \"delta_x\": 250000.0, \"delta_p\": 70000.0,\n            \"R\": -150.0, \"F_lat\": 40.0, \"F_sen\": 10.0,\n            \"i_c\": 2, \"o\": 1\n        },\n        # Case 4: Boundary condition\n        {\n            \"q\": [0.0180, 0.0185, 0.0190, 0.0195, 0.0200],\n            \"u\": 5.0, \"delta_x\": 250000.0, \"delta_p\": 70000.0,\n            \"R\": -20.0, \"F_lat\": 60.0, \"F_sen\": 20.0,\n            \"i_c\": 3, \"o\": 1\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current case\n        q_transect = case[\"q\"]\n        u = case[\"u\"]\n        delta_x = case[\"delta_x\"]\n        delta_p = case[\"delta_p\"]\n        R = case[\"R\"]\n        F_lat = case[\"F_lat\"]\n        F_sen = case[\"F_sen\"]\n        i_c = case[\"i_c\"]\n        o = case[\"o\"]\n        \n        # 1. Determine the evaluation index\n        i = i_c + o\n        n_points = len(q_transect)\n        \n        # 2. Calculate the zonal moisture gradient (dq/dx) using finite differences\n        dq_dx = 0.0\n        if 0  i  n_points - 1:\n            # Centered difference for interior points\n            dq_dx = (q_transect[i+1] - q_transect[i-1]) / (2 * delta_x)\n        elif i == 0 and n_points > 1:\n            # Forward difference for the first point (not used in test cases but included for completeness)\n            dq_dx = (q_transect[i+1] - q_transect[i]) / delta_x\n        elif i == n_points - 1 and n_points > 1:\n            # Backward difference for the last point\n            dq_dx = (q_transect[i] - q_transect[i-1]) / delta_x\n        \n        # 3. Compute horizontal moisture advection contribution (A_h)\n        # A_h = -L_v * u * (dq/dx) * (column_mass_per_unit_area)\n        # column_mass_per_unit_area = delta_p / g\n        A_h = -L_v * u * dq_dx * (delta_p / g)\n        \n        # 4. Compute surface turbulent enthalpy flux (E)\n        E = F_lat + F_sen\n        \n        # 5. Compute total preconvective MSE tendency (T)\n        T = A_h + R + E\n        \n        # 6. Evaluate the dominance criterion\n        abs_Ah = abs(A_h)\n        abs_R = abs(R)\n        abs_E = abs(E)\n        \n        denominator = abs_Ah + abs_R + abs_E\n        f = abs_Ah / denominator if denominator != 0 else 0.0\n        \n        # Dominance is true if total tendency is positive AND fraction is >= 0.5\n        is_dominant = (T > 0) and (f >= 0.5)\n        \n        # 7. Format results and append to the list\n        T_rounded = round(T, 3)\n        f_rounded = round(f, 3)\n        \n        # Handle -0.0 for display consistency, though rounding usually handles this.\n        if T_rounded == -0.0: T_rounded = 0.0\n        \n        results.append([T_rounded, f_rounded, is_dominant])\n\n    # 8. Print the final results in the specified format\n    # The str() of a list automatically includes spaces after commas, \n    # which we remove to exactly match a dense list format if needed,\n    # though the problem example does not specify this level of detail.\n    # The default str() is generally acceptable.\n    # For example: str([1.2, 3.4, True]) -> '[1.2, 3.4, True]'\n    results_str = \",\".join(map(str, results))\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "准确预报MJO是数值天气预报和气候建模领域的一大挑战。本练习介绍了一种标准的模型诊断技术——使用霍夫穆勒图（Hovmöller diagram）来量化模型预报误差。通过追踪合成的“观测”与“预报”数据中对流信号的传播过程，你将学习如何计算如位相速度偏差和系统性经度漂移这类基本误差度量，这对于评估和改进模型性能至关重要。",
            "id": "4101298",
            "problem": "您的任务是通过比较对流包络的预报和观测 Hovmöller 图，来量化 Madden-Julian 振荡 (MJO) 预报中的相速偏差和系统性经向漂移。该任务必须通过实现一个完整的、可运行的程序来完成。该程序需要构建合成但科学上真实的数据集，从第一性原理估计传播特性，并报告量化后的偏差。\n\n本问题的基本原理是相干对流包络沿赤道的平流。考虑一个标量对流代理场 $q(\\lambda,t)$，它沿着经度 $\\lambda$ (单位：度) 和时间 $t$ (单位：天) 满足线性平流方程 $\\partial_t q + c \\,\\partial_\\lambda q = 0$，其中 $c$ 是以度/天为单位的东传相速。一个相干的包络在平移时形状不变；因此，最大对流脊线遵循 $\\lambda_r(t) = a + c \\, t$，其中 $a$ 是截距。在 Hovmöller 图（经度-时间图）中，这条脊线是一条直线，其斜率即为相速。我们假设经度是一个周期为 $360^{\\circ}$ 的周期性域。为了避免跨越本初子午线时的模糊性，在进行线性趋势估计之前，必须将脊线经度展开成一个连续序列。\n\n您的程序必须：\n- 生成合成的观测和预报 Hovmöller 场，用于一个被建模为包裹高斯分布的对流包络，其形式为 $q(\\lambda,t) = A \\exp\\!\\left(-\\frac{d(\\lambda,\\lambda_c(t))^2}{2\\sigma^2}\\right) + \\eta$。其中 $A$ 是振幅，$\\sigma$ 是以度为单位的经向标准差，$d(\\cdot,\\cdot)$ 是圆上以度为单位的最短有符号角距离，$\\lambda_c(t) = \\lambda_0 + c\\,t \\;\\bmod\\; 360$ 是对流包络的中心经度，$\\eta$ 是零均值高斯噪声。所有经度单位为度，所有时间单位为天。\n- 对于每个场，通过在每个时间点取 $q(\\lambda,t)$ 在 $\\lambda \\in [0,360)$ 上的最大值对应的经度，来估计脊线经度时间序列 $\\lambda_r(t)$。然后将 $\\lambda_r(t)$ 展开成一个连续的时间函数。\n- 通过对展开后的脊线应用模型 $\\lambda_r(t) = a + c\\, t + \\epsilon(t)$ 进行普通最小二乘拟合，来估计相速 $c$ 和截距 $a$，其中 $\\epsilon(t)$ 是残差。\n- 计算模式和观测之间的相速偏差 $b_c = \\left(c_{\\text{mod}} - c_{\\text{obs}}\\right)\\,\\gamma$（单位：米/秒），其中 $\\gamma = \\frac{2\\pi R_e}{360 \\times 86400}$，地球赤道半径 $R_e = 6{,}378{,}137\\,\\text{m}$，因此 $1\\,\\text{deg day}^{-1}$ 的速度约对应于 $1.29\\,\\text{m s}^{-1}$。以米/秒 (m/s) 表示相速偏差，并四舍五入到两位小数。\n- 计算系统性经向漂移，即截距的包裹差 $d_a = \\mathrm{wrap}_{[-180,180)}\\!\\left(a_{\\text{mod}} - a_{\\text{obs}}\\right)$（单位：度），并四舍五入到两位小数，其中 $\\mathrm{wrap}_{[-180,180)}(x)$ 将任意实数角度 $x$（单位：度）映射到 $[-180,180)$ 区间内的等效值。\n\n对所有测试用例使用以下固定配置：\n- 经度网格：$N_x = 144$ 个等距点，网格经度为 $\\lambda_i = i \\times 2.5^{\\circ}$，其中 $i=0,\\dots,N_x-1$ 在 $[0,360)$ 上。\n- 时间步长：$\\Delta t = 1\\,\\text{day}$。\n- 包络振幅：$A = 1$。\n- 包络宽度：$\\sigma = 20^{\\circ}$。\n- 噪声是加性的、独立的，具有零均值和为每个测试用例指定的标准差。\n\n实现一个包含以下四个案例的测试套件，每个案例由 $(T, c_{\\text{obs}}, c_{\\text{mod}}, \\Delta a, \\lambda_0, \\sigma_{\\eta})$ 指定，其中 $T$ 是总天数，$c_{\\text{obs}}$ 和 $c_{\\text{mod}}$ 是观测和模式的相速（单位：度/天），$\\Delta a$ 是模式减去观测的截距偏移（一种系统性漂移，单位：度），$\\lambda_0$ 是观测在 $t=0$ 时的初始中心经度（单位：度），$\\sigma_{\\eta}$ 是噪声标准差：\n- 案例 1：$(T = 80, c_{\\text{obs}} = 4.0, c_{\\text{mod}} = 5.0, \\Delta a = 10.0, \\lambda_0 = 30.0, \\sigma_{\\eta} = 0.10)$。\n- 案例 2：$(T = 90, c_{\\text{obs}} = 3.5, c_{\\text{mod}} = 3.5, \\Delta a = -30.0, \\lambda_0 = 350.0, \\sigma_{\\eta} = 0.15)$。\n- 案例 3：$(T = 70, c_{\\text{obs}} = 4.5, c_{\\text{mod}} = 2.5, \\Delta a = 0.0, \\lambda_0 = 120.0, \\sigma_{\\eta} = 0.30)$。\n- 案例 4：$(T = 20, c_{\\text{obs}} = 6.0, c_{\\text{mod}} = 6.5, \\Delta a = 15.0, \\lambda_0 = 260.0, \\sigma_{\\eta} = 0.10)$。\n\n对于每个案例，使用 $(T, c_{\\text{obs}}, \\Delta a = 0, \\lambda_0, \\sigma_{\\eta})$ 生成一个观测 Hovmöller 场，并使用 $(T, c_{\\text{mod}}, \\Delta a, \\lambda_0, \\sigma_{\\eta})$ 生成一个模式 Hovmöller 场。使用固定的随机种子，以确保噪声在不同运行中是可复现的。\n\n角度单位：所有角度均以度为单位。最终偏差的速度单位：米/秒 (m/s)。程序必须按顺序为四个测试用例输出一个浮点数列表，格式为 $[b_{c,1}, d_{a,1}, b_{c,2}, d_{a,2}, b_{c,3}, d_{a,3}, b_{c,4}, d_{a,4}]$，其中 $b_{c,i}$ 是以米/秒为单位的相速偏差，$d_{a,i}$ 是以度为单位的系统性漂移。每个值都必须四舍五入到两位小数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[x_1,x_2,\\dots]$），不含任何附加文本。",
            "solution": "所提出的问题是有效的。这是一个来自气候模式诊断领域（具体涉及 Madden-Julian 振荡 (MJO)）的、有科学依据、适定且完整的问题陈述。问题提供了全面的参数、物理常数和程序步骤，以构建一个可复现的数值实验。任务是通过模拟和分析合成的 Hovmöller 图来量化 MJO 预报偏差，这是大气科学中的一种标准技术。\n\n解决方案的步骤是：首先生成代表“观测”场和“模式预报”场的合成数据，然后系统地处理这些数据以估计传播特性，最后计算指定的偏差度量。整个过程被封装在一个严格遵循所述原则的程序中。\n\n首先，我们建立数据生成的框架。对流代理场 $q(\\lambda,t)$ 定义在经度 $\\lambda$ 和时间 $t$ 的二维网格上。经度域是一个周期为 $360^\\circ$ 的圆，被离散化为 $N_x = 144$ 个网格点，分辨率为 $2.5^\\circ$。时间以 $\\Delta t = 1$ 天的步长离散化。对流包络被建模为一个包裹高斯函数：\n$$\nq(\\lambda,t) = A \\exp\\!\\left(-\\frac{d(\\lambda, \\lambda_c(t))^2}{2\\sigma^2}\\right) + \\eta\n$$\n这里，振幅固定为 $A=1$，经向标准差（宽度）为 $\\sigma = 20^\\circ$，代表一个大尺度的热带对流异常。项 $\\eta$ 代表具有指定标准差 $\\sigma_\\eta$ 的零均值高斯噪声，用以模拟大气数据中固有的不可预测性和随机性。函数 $d(\\lambda, \\lambda_c)$ 计算圆上的最短有符号角距离，确保高斯分布正确居中。包络的中心 $\\lambda_c(t)$ 根据线性平流模型进行传播：\n$$\n\\lambda_c(t) = (\\lambda_0 + c \\cdot t) \\pmod{360}\n$$\n其中 $\\lambda_0$ 是 $t=0$ 时的初始经度，$c$ 是以度/天为单位的东传相速。对于每个测试用例，我们生成两个这样的场：\n1.  一个“观测”场，使用真实的观测相速 $c_{\\text{obs}}$ 和初始经度 $\\lambda_0$。\n2.  一个“模式”场，使用预报模式的相速 $c_{\\text{mod}}$ 和一个被系统性漂移偏移的初始经度 $\\lambda_0 + \\Delta a$。\n\n其次，我们设计分析流程，从生成的 $q(\\lambda,t)$ 场中估计传播特性。这个过程模仿了科学家分析真实世界数据的方式。\n1.  **脊线检测**：对于每个时间步 $t$，我们识别出最大对流的经度。这是通过找到 $q(\\lambda,t)$ 沿经度轴的最大值的索引，并检索相应的经度值来实现的。这个过程产生一个脊线经度的时间序列 $\\lambda_r(t)$，其值被限制在 $[0, 360)$ 范围内。\n2.  **经度展开**：由于脊线会跨越本初子午线（或任何 $0^\\circ/360^\\circ$ 边界），原始的 $\\lambda_r(t)$ 序列会包含约 $360^\\circ$ 的跳跃。为了执行线性回归，必须移除这些不连续点。我们通过在每个跳跃点加上或减去 $360^\\circ$ 的倍数来“展开”时间序列，从而创建一个总东行距离的连续表示。\n3.  **参数估计**：利用展开后的连续经度序列，我们使用普通最小二乘 (OLS) 回归来拟合线性模型 $\\lambda_r(t) = a + ct + \\epsilon(t)$。所得直线的斜率是估计的相速 $c_{\\text{est}}$，y 轴截距是估计的初始经度 $a_{\\text{est}}$。\n\n第三，我们通过比较从模式场和观测场中估计出的参数来量化预报偏差。\n1.  **相速偏差 ($b_c$)**：估计相速的差异 $c_{\\text{mod}} - c_{\\text{obs}}$ 从度/天转换为米/秒。这是通过转换因子 $\\gamma = \\frac{2\\pi R_e}{360 \\times 86400}$ 完成的，其中 $R_e = 6{,}378{,}137\\,\\text{m}$ 是地球的赤道半径。最终偏差为 $b_c = (c_{\\text{mod, est}} - c_{\\text{obs, est}})\\,\\gamma$。正值表示预报的 MJO 东传速度过快。\n2.  **系统性漂移 ($d_a$)**：估计截距的差异 $a_{\\text{mod, est}} - a_{\\text{obs, est}}$ 代表了预报初始位置的系统性经度误差。此差异被包裹到区间 $[-180, 180)$ 内，以提供最短的角位移。\n\n实现将利用 `NumPy` 库进行高效的数组计算。关键函数包括用于噪声生成的 `numpy.random.normal`、用于脊线检测的 `numpy.argmax`、用于处理周期性的 `numpy.unwrap` 以及用于 OLS 回归的 `numpy.polyfit`。使用固定的随机种子来确保每次运行的噪声实现都相同，从而使结果可复现和可验证。程序会遍历四个指定的测试用例，为每个用例计算两个偏差度量，并将输出格式化为单个四舍五入的浮点数列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_hovmoller(T, c, lambda0_initial, sigma_eta, A, sigma_envelope, lons, times, rng):\n    \"\"\"\n    Generates a synthetic Hovmöller diagram for a propagating convective envelope.\n    \n    Args:\n        T (int): Total number of days.\n        c (float): Phase speed in degrees/day.\n        lambda0_initial (float): Initial center longitude at t=0 in degrees.\n        sigma_eta (float): Standard deviation of the additive Gaussian noise.\n        A (float): Amplitude of the Gaussian envelope.\n        sigma_envelope (float): Standard deviation (width) of the Gaussian envelope in degrees.\n        lons (np.ndarray): Array of longitudes.\n        times (np.ndarray): Array of times.\n        rng (np.random.Generator): NumPy random number generator instance.\n        \n    Returns:\n        np.ndarray: The generated Hovmöller field q(t, lon).\n    \"\"\"\n    # Calculate the center longitude evolução at each time step\n    lambda_c = (lambda0_initial + c * times) % 360\n    \n    # Create broadcastable arrays for vectorized computation\n    # lons: (1, Nx), lambda_c: (T, 1)\n    lons_grid = lons.reshape(1, -1)\n    lambda_c_grid = lambda_c.reshape(-1, 1)\n    \n    # Calculate the shortest signed angular distance d(lambda, lambda_c)\n    # The formula (x + 180) % 360 - 180 works for NumPy's % operator\n    delta = lons_grid - lambda_c_grid\n    dist = (delta + 180) % 360 - 180\n    \n    # Calculate the wrapped Gaussian field\n    gaussian_field = A * np.exp(-dist**2 / (2 * sigma_envelope**2))\n    \n    # Generate additive Gaussian noise\n    noise = rng.normal(loc=0.0, scale=sigma_eta, size=gaussian_field.shape)\n    \n    return gaussian_field + noise\n\ndef analyze_hovmoller(q, lons, times):\n    \"\"\"\n    Estimates phase speed and intercept from a Hovmöller diagram.\n    \n    Args:\n        q (np.ndarray): The Hovmöller field.\n        lons (np.ndarray): Array of longitudes.\n        times (np.ndarray): Array of times.\n        \n    Returns:\n        tuple[float, float]: Estimated phase speed (c_est) and intercept (a_est).\n    \"\"\"\n    # Find the longitude of maximum convection at each time step\n    max_indices = np.argmax(q, axis=1)\n    wrapped_lons = lons[max_indices]\n    \n    # Unwrap longitudes to handle periodicity for linear regression\n    # The period is 360 degrees.\n    unwrapped_lons = np.unwrap(wrapped_lons, period=360)\n    \n    # Perform ordinary least squares regression to find c (slope) and a (intercept)\n    # np.polyfit returns [slope, intercept] for degree 1\n    c_est, a_est = np.polyfit(times, unwrapped_lons, 1)\n    \n    return c_est, a_est\n\ndef wrap_to_180(angle):\n    \"\"\"Wraps an angle in degrees to the interval [-180, 180).\"\"\"\n    return (angle + 180) % 360 - 180\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute biases.\n    \"\"\"\n    # Use a fixed random seed for reproducibility\n    rng = np.random.default_rng(seed=42)\n\n    # Fixed configuration parameters\n    N_x = 144\n    A = 1.0\n    sigma_envelope = 20.0\n    R_e = 6378137.0  # Earth's equatorial radius in meters\n\n    # Conversion factor from degrees/day to m/s\n    gamma = (2 * np.pi * R_e) / (360 * 86400)\n\n    # Longitudinal grid\n    lons = np.linspace(0, 360, N_x, endpoint=False) # Grid on [0, 360)\n\n    # Test cases: (T, c_obs, c_mod, delta_a, lambda0, sigma_eta)\n    test_cases = [\n        (80, 4.0, 5.0, 10.0, 30.0, 0.10),\n        (90, 3.5, 3.5, -30.0, 350.0, 0.15),\n        (70, 4.5, 2.5, 0.0, 120.0, 0.30),\n        (20, 6.0, 6.5, 15.0, 260.0, 0.10),\n    ]\n\n    results = []\n    for T, c_obs, c_mod, delta_a, lambda0, sigma_eta in test_cases:\n        times = np.arange(T)\n\n        # --- Observational Run ---\n        # Initial longitude for observation is lambda0\n        q_obs = generate_hovmoller(T, c_obs, lambda0, sigma_eta, A, sigma_envelope, lons, times, rng)\n        c_obs_est, a_obs_est = analyze_hovmoller(q_obs, lons, times)\n\n        # --- Model Forecast Run ---\n        # Initial longitude for model is offset by delta_a\n        lambda0_mod_initial = lambda0 + delta_a\n        q_mod = generate_hovmoller(T, c_mod, lambda0_mod_initial, sigma_eta, A, sigma_envelope, lons, times, rng)\n        c_mod_est, a_mod_est = analyze_hovmoller(q_mod, lons, times)\n        \n        # --- Compute Biases ---\n        # Phase speed bias in m/s\n        b_c = (c_mod_est - c_obs_est) * gamma\n        \n        # Systematic longitudinal drift in degrees\n        d_a = wrap_to_180(a_mod_est - a_obs_est)\n\n        # Append rounded results to the list\n        results.append(round(b_c, 2))\n        results.append(round(d_a, 2))\n\n    # Print the final list in the specified format\n    print(f\"[{','.join(f'{r:.2f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}