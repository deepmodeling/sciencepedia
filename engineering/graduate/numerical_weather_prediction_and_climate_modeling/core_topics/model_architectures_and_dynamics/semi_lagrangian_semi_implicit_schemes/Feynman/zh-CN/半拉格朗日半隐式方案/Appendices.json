{
    "hands_on_practices": [
        {
            "introduction": "本次练习将作为概念的基石，它将半拉格朗日方法与经典的半隐式通量形式方案进行对比。通过分析它们在稳定性、守恒性和计算结构方面的独特属性，您将更深刻地理解选择特定数值方法背后的动机。这项练习  对于领会流体动力学稳健数值模型设计中所涉及的权衡至关重要。",
            "id": "4087345",
            "problem": "考虑一维线性平流方程 $u_t + c\\,u_x = 0$，它描述了一个在周期性域 $x \\in [0,L]$ 上以恒定速度 $c>0$ 运动的被动示踪剂 $u(x,t)$。其精确解沿着由 $dx/dt = c$ 和 $du/dt = 0$ 定义的特征线平移初始条件。考虑一个具体的线性测试案例，其中 $L=1$，$c=1$，均匀网格间距 $\\Delta x = 1/50$，时间步长 $\\Delta t = 3\\,\\Delta x$，并采用周期性边界条件。初始条件为 $u(x,0) = \\cos(2\\pi x/L)$。定义库朗数 $\\mu = c\\,\\Delta t/\\Delta x$，因此在此设置下 $\\mu = 3$。\n\n考虑两种数值时间步进方法：\n\n(1) 一种半拉格朗日方法：在网格点 $x_i$ 处，计算一个出发点 $x_d = x_i - c\\,\\Delta t$，并通过使用一种保形的、在 $x_d$ 周围使用局部化插值模板的单调三次插值，在 $x_d$ 处对 $u^n$ 进行插值，从而计算出 $u^{n+1}(x_i)$。\n\n(2) 一种半隐式通量形式方法：从通量形式 $u_t + (c\\,u)_x = 0$ 出发，对通量散度使用梯形时间离散（也称为Crank–Nicolson方法），并在均匀网格上使用中心空间差分，这导致在每个时间步都需要求解一个线性系统。假设采用周期性边界条件。\n\n仅使用特征平流的基本原理、与通量散度相关的离散守恒，以及在均匀网格上通过傅里叶（正规模态）分析进行的标准线性稳定性分析，判断对于这个测试案例，关于稳定性、守恒性和计算模板的哪些陈述是正确的：\n\nA. 对于给定网格上的 $\\mu=3$，采用单调三次插值的半拉格朗日方法对于任何 $\\mu$ 都是线性稳定的，但通常不精确守恒离散域积分 $\\sum_i u_i\\,\\Delta x$，除非通过守恒重映进行增强。\n\nB. 采用中心空间通量的半隐式通量形式Crank–Nicolson格式是无条件线性稳定的，并且在周期性边界条件下精确守恒离散域积分 $\\sum_i u_i\\,\\Delta x$。\n\nC. 为了在 $\\mu>1$ 时实现稳定性，半拉格朗日方法需要在每个步骤求解一个全局三对角线性系统，而半隐式通量形式方法可以在没有线性求解的情况下进行局部推进。\n\nD. 在一维均匀网格上，采用单调三次插值的半拉格朗日更新在出发点周围使用一个四点插值模板，而通量形式Crank–Nicolson算子在空间上仅耦合最近邻，从而在每个步骤中导出一个三对角线性系统。\n\nE. 在此测试案例中，对于余弦初始条件，两种方法对任何 $\\mu$ 值都能精确保持波幅。",
            "solution": "在进行求解之前，首先对问题陈述的科学性和逻辑一致性进行验证。\n\n### 步骤 1：提取已知条件\n\n-   **控制方程**：一维线性平流方程，$u_t + c\\,u_x = 0$。\n-   **域**：周期性，$x \\in [0,L]$。\n-   **速度**：恒定，$c > 0$。\n-   **精确解性质**：沿着由 $dx/dt = c$ 和 $du/dt = 0$ 定义的特征线平移初始条件。\n-   **测试案例参数**：\n    -   $L=1$。\n    -   $c=1$。\n    -   网格间距：$\\Delta x = 1/50$。\n    -   时间步长：$\\Delta t = 3\\,\\Delta x$。\n    -   边界条件：周期性。\n-   **初始条件**：$u(x,0) = \\cos(2\\pi x/L)$。\n-   **库朗数**：$\\mu = c\\,\\Delta t/\\Delta x = 1 \\cdot (3\\,\\Delta x) / \\Delta x = 3$。\n-   **方法 (1)**：半拉格朗日 (SL) 方法。\n    -   更新：在网格点 $x_i$ 处，计算出发点 $x_d = x_i - c\\,\\Delta t$。通过在 $x_d$ 位置对前一时间步的解 $u^n$ 进行插值来计算 $u^{n+1}(x_i)$。\n    -   插值器：单调三次插值，保形，局部化模板。\n-   **方法 (2)**：半隐式通量形式方法 (Crank-Nicolson, CN)。\n    -   方程形式：$u_t + (c\\,u)_x = 0$。\n    -   离散化：对通量散度采用梯形法则进行时间积分；在均匀网格上采用中心空间差分。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n问题陈述描述了求解线性平流方程的两种标准且成熟的数值方法，这是数值偏微分方程领域的基石。所给参数定义明确且内部一致。\n\n-   **科学基础**：该问题基于应用于一个典型偏微分方程的数值分析基本原理。所涉及的方法（半拉格朗日，Crank-Nicolson）和概念（稳定性，守恒性，模板）是该领域的核心内容。\n-   **适定的**：问题要求对两种明确定义的数值格式的定性性质进行分析。这种分析是确定性的，会得出一组唯一的正确陈述。\n-   **客观性**：语言精确且数学化，没有主观性。\n-   **完整性与一致性**：提供了分析这些格式所需的所有信息。库朗数 $\\mu=3$ 的计算与给定参数一致。在高库朗数（$\\mu > 1$）下比较格式是一种标准且有意义的练习，因为它突显了隐式和半拉格朗日方法相对于简单显式格式的优势。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。这是一个数值分析领域中适定且具有科学依据的问题。下面将推导解答。\n\n### 推导与分析\n\n分析将基于基本原理，检验每种数值方法的性质。\n\n#### 方法 1：半拉格朗日 (SL) 格式\n\n半拉格朗日方法基于特征线法。$u_t + c u_x = 0$ 的解沿着特征曲线 $x(t) = x_0 + ct$ 是常数。这意味着 $u(x, t) = u(x - c\\Delta t, t - \\Delta t)$。数值格式近似了这种关系：\n$$u^{n+1}(x_i) = u^n(x_d)$$\n其中 $x_d = x_i - c\\Delta t$ 是出发点。由于 $x_d$ 通常不是一个网格点，因此需要使用一个插值算子 $I$：\n$$u^{n+1}_i = I(u^n)(x_d)$$\n\n-   **稳定性**：格式的稳定性由插值算子 $I$ 的性质决定。对于线性平流方程，如果插值器是稳定的（例如，不放大输入数据），则SL格式相对于库朗数是无条件稳定的。单调三次插值器被设计为保形和非振荡的，这些性质有助于稳定性。它不受许多显式格式所具有的严格CFL条件（$\\mu \\le 1$）的限制。因此，该格式被认为是对于任何 $\\mu$ 都线性稳定的。\n\n-   **守恒性**：守恒性指的是量的离散积分 $\\sum_i u_i \\Delta x$ 是否随时间保持不变。插值是一种局部的重网格化操作。在网格点处插值后的值的总和 $\\sum_i u^{n+1}_i$ 通常不等于原始数据点的总和 $\\sum_i u^n_i$。因此，插值型半拉格朗日格式通常是不守恒的。守恒的SL格式确实存在，但它们更为复杂，通常在通量形式或重映框架下构建。\n\n-   **计算模板**：一个三次多项式需要四个系数来定义。为了在局部确定这些系数，需要来自四个网格点的信息。对于位于网格点 $x_j$ 和 $x_{j+1}$ 之间的出发点 $x_d$，插值模板的常见选择是四个点的集合 $\\{x_{j-1}, x_j, x_{j+1}, x_{j+2}\\}$。因此，它使用一个四点模板。每个网格点 $x_i$ 的计算仅依赖于出发点 $x_d$ 附近 $u^n$ 的值，这使得更新过程是显式的和局部的。\n\n#### 方法 2：半隐式通量形式 (Crank-Nicolson) 格式\n\n该格式离散化了方程的守恒形式 $u_t + \\nabla \\cdot (c u) = 0$。对通量散度的时间导数使用梯形法则（Crank-Nicolson），并对空间导数使用中心有限差分 $(\\delta_x F)_i = (F_{i+1/2} - F_{i-1/2})/\\Delta x$，对于中心通量，这变为 $(F_{i+1} - F_{i-1})/(2\\Delta x)$，我们得到：\n$$ \\frac{u_i^{n+1} - u_i^n}{\\Delta t} + \\frac{1}{2} \\left[ \\left(\\frac{c u_{i+1}^n - c u_{i-1}^n}{2\\Delta x}\\right) + \\left(\\frac{c u_{i+1}^{n+1} - c u_{i-1}^{n+1}}{2\\Delta x}\\right) \\right] = 0 $$\n乘以 $\\Delta t$ 并重新整理，将已知量（$n$ 时刻）与未知量（$n+1$ 时刻）分开：\n$$ u_i^{n+1} + \\frac{c\\Delta t}{4\\Delta x} (u_{i+1}^{n+1} - u_{i-1}^{n+1}) = u_i^n - \\frac{c\\Delta t}{4\\Delta x} (u_{i+1}^n - u_{i-1}^n) $$\n令 $\\mu = c\\Delta t/\\Delta x$，我们有：\n$$ u_i^{n+1} + \\frac{\\mu}{4} (u_{i+1}^{n+1} - u_{i-1}^{n+1}) = u_i^n - \\frac{\\mu}{4} (u_{i+1}^n - u_{i-1}^n) $$\n\n-   **稳定性**：我们进行冯·诺依曼稳定性分析。令 $u_j^n = g^n e^{ikx_j}$，其中 $x_j = j\\Delta x$，$k$ 是波数。将此代入格式中并除以 $g^n e^{ikj\\Delta x}$，得到放大因子 $g$ 的方程：\n$$ g \\left( 1 + \\frac{\\mu}{4} (e^{ik\\Delta x} - e^{-ik\\Delta x}) \\right) = 1 - \\frac{\\mu}{4} (e^{ik\\Delta x} - e^{-ik\\Delta x}) $$\n使用欧拉公式 $e^{i\\theta} - e^{-i\\theta} = 2i\\sin\\theta$，其中 $\\theta = k\\Delta x$：\n$$ g \\left( 1 + i\\frac{\\mu}{2} \\sin(k\\Delta x) \\right) = 1 - i\\frac{\\mu}{2} \\sin(k\\Delta x) $$\n$$ g = \\frac{1 - i\\frac{\\mu}{2} \\sin(k\\Delta x)}{1 + i\\frac{\\mu}{2} \\sin(k\\Delta x)} $$\n放大因子的模是分子和分母模的比值，而分子和分母是复共轭的。对于任意实数值 $Z = \\frac{\\mu}{2}\\sin(k\\Delta x)$，我们有 $|1-iZ| = \\sqrt{1^2 + (-Z)^2}$ 和 $|1+iZ| = \\sqrt{1^2 + Z^2}$。\n$$ |g| = \\frac{\\sqrt{1 + \\left(\\frac{\\mu}{2}\\sin(k\\Delta x)\\right)^2}}{\\sqrt{1 + \\left(\\frac{\\mu}{2}\\sin(k\\Delta x)\\right)^2}} = 1 $$\n由于对于所有波数 $k$ 和任何 $\\mu$ 值，都有 $|g|=1$，因此该格式是无条件线性稳定的。\n\n-   **守恒性**：为了检查离散积分 $\\sum_i u_i\\Delta x$ 的守恒性，我们将离散方程对所有网格点 $i$（从 $0$ 到 $N-1$）求和：\n$$ \\sum_i (u_i^{n+1} - u_i^n) = -\\frac{\\mu\\Delta x}{4\\Delta x} \\sum_i \\left[ (u_{i+1}^n - u_{i-1}^n) + (u_{i+1}^{n+1} - u_{i-1}^{n+1}) \\right] $$\n右侧空间差分项的和是一个伸缩求和。对于周期性边界条件（$u_{N} = u_0$, $u_{-1}=u_{N-1}$），这个和精确为零：$\\sum_{i=0}^{N-1} (F_{i+1} - F_{i-1}) = \\sum_{i=0}^{N-1} F_{i+1} - \\sum_{i=0}^{N-1} F_{i-1} = 0$。因此，$\\sum_i u_i^{n+1} = \\sum_i u_i^n$。该格式精确守恒离散域积分。\n\n-   **计算模板与系统**：更新方程将新值 $u_i^{n+1}$ 与其最近邻 $u_{i-1}^{n+1}$ 和 $u_{i+1}^{n+1}$ 联系起来。这就为未知向量 $\\mathbf{u}^{n+1}$ 创建了一个线性方程组。该系统的矩阵仅在主对角线和相邻的两条对角线上有非零元素，这意味着它是一个三对角系统。对于周期性边界条件，在右上角和左下角有额外的非零元素，从而形成一个循环三对角矩阵。求解这个系统是一个“全局”操作，因为每个点的值都依赖于所有其他点。\n\n### 选项评估\n\n**A. 对于给定网格上的 $\\mu=3$，采用单调三次插值的半拉格朗日方法对于任何 $\\mu$ 都是线性稳定的，但通常不精确守恒离散域积分 $\\sum_i u_i\\,\\Delta x$，除非通过守恒重映进行增强。**\n-   如前分析，带有稳定插值器的SL格式对任何库朗数 $\\mu$ 都是稳定的。\n-   如前分析，插值型SL格式通常不守恒。\n-   该陈述正确总结了此方法的基本性质。\n-   结论：**正确**。\n\n**B. 采用中心空间通量的半隐式通量形式Crank–Nicolson格式是无条件线性稳定的，并且在周期性边界条件下精确守恒离散域积分 $\\sum_i u_i\\,\\Delta x$。**\n-   通过傅里叶分析推导，该格式的放大因子模为1，证实了其无条件稳定性。\n-   通过在周期域上求和表明，该格式建立在精确守恒离散积分的通量形式离散化之上。\n-   该陈述正确总结了此方法的基本性质。\n-   结论：**正确**。\n\n**C. 为了在 $\\mu>1$ 时实现稳定性，半拉格朗日方法需要在每个步骤求解一个全局三对角线性系统，而半隐式通量形式方法可以在没有线性求解的情况下进行局部推进。**\n-   半拉格朗日更新是局部的和显式的：$u^{n+1}_i$ 是通过使用已知的 $u^n$ 值进行插值来计算的。它不需要求解线性系统。\n-   Crank-Nicolson方法是隐式的，需要在每个步骤为 $u^{n+1}$ 值求解一个全局（循环）三对角线性系统。\n-   该陈述颠倒了两种方法的计算性质。\n-   结论：**不正确**。\n\n**D. 在一维均匀网格上，采用单调三次插值的半拉格朗日更新在出发点周围使用一个四点插值模板，而通量形式Crank–Nicolson算子在空间上仅耦合最近邻，从而在每个步骤中导出一个三对角线性系统。**\n-   如前分析，三次插值需要一个四点模板。\n-   如前分析，CN格式将点 $i$ 与其最近邻 $i-1$ 和 $i+1$ 耦合，这是一种三点空间耦合，导致一个三对角（或循环三对角）系统。\n-   该陈述准确描述了两种方法的计算模板和由此产生的代数结构。\n-   结论：**正确**。\n\n**E. 在此测试案例中，对于余弦初始条件，两种方法对任何 $\\mu$ 值都能精确保持波幅。**\n-   Crank-Nicolson格式对于任何 $\\mu$ 都有 $|g|=1$，因此它能精确保持每个傅里叶模的振幅。\n-   半拉格朗日格式的行为取决于 $\\mu$。如果 $\\mu$ 是一个整数（如此处的设置，$\\mu=3$），出发点就是另一个网格点，插值是精确的（仅是数据平移），振幅得以保持。然而，对于一般的非整数 $\\mu$，任何实际的插值器（包括三次插值）都会引入一些数值耗散，导致振幅衰减。该陈述中“对于任何 $\\mu$”的说法对半拉格朗日方法是错误的。由于该陈述必须对两种方法都成立，因此它是错误的。\n-   结论：**不正确**。",
            "answer": "$$\\boxed{ABD}$$"
        },
        {
            "introduction": "现在，让我们从理论转向实践，为一个二维连续性方程实现一个半拉格朗日平流方案。这项动手练习  侧重于“拉格朗日”部分的核心机制：计算粒子轨迹和插值被平流的场。此外，它直接探讨了质量守恒这一关键问题，并要求您量化速度场散度的数值误差（在耦合模型中常见的现象）如何影响这一基本物理原理。",
            "id": "4062303",
            "problem": "考虑一个二维周期性域，其边长为 $L_x$ 和 $L_y$（单位：米），由一个 $N_x \\times N_y$ 的均匀网格离散化，网格单元中心的坐标为 $x_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta x$ 和 $y_j = \\left(j+\\tfrac{1}{2}\\right)\\Delta y$，其中 $i \\in \\{0,\\dots,N_x-1\\}$，$j \\in \\{0,\\dots,N_y-1\\}$，$\\Delta x = L_x/N_x$，$\\Delta y = L_y/N_y$。预报变量是质量密度 $ \\rho(x,y,t) $（单位：$\\mathrm{kg/m^2}$，将模型解释为垂直积分的），它被一个水平速度场 $ \\boldsymbol{u}(x,y,t) = (u_x(x,y,t), u_y(x,y,t)) $（单位：$\\mathrm{m/s}$）平流。控制定律是连续性方程\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\boldsymbol{u}) = 0,\n$$\n在 $x$ 和 $y$ 方向上均采用周期性边界条件。数值方法是一个单步半拉格朗日更新，它在一个时间步长 $ \\Delta t $（单位：秒）内，使用中点后向轨迹和一个从连续性方程导出的局部可压缩性因子，沿特征线移动质量密度。记时间 $ t^{n+1} = t^n + \\Delta t $ 时的到达位置为 $ (x,y) $，相应的出发位置为 $ (x_d, y_d) $。后向轨迹的中点位置 $ (x_m, y_m) $ 由一次预测-校正中点迭代定义：\n1. 预测 $ \\boldsymbol{u}^n(x,y) $ 并计算 $ (x_{m}^{(0)}, y_{m}^{(0)}) = \\left(x - \\tfrac{\\Delta t}{2} u_x^n(x,y),\\; y - \\tfrac{\\Delta t}{2} u_y^n(x,y)\\right) $，并进行周期性环绕处理。\n2. 计算 $ \\boldsymbol{u}^n(x_{m}^{(0)}, y_{m}^{(0)}) $，设置 $ (x_m,y_m) = (x_{m}^{(0)}, y_{m}^{(0)}) $，并计算出发位置 $ (x_d, y_d) = \\left(x - \\Delta t\\, u_x^n(x_m,y_m),\\; y - \\Delta t\\, u_y^n(x_m,y_m)\\right) $，并进行周期性环绕处理。\n\n沿特征线，连续性方程意味着 $ \\mathrm{D}\\rho/\\mathrm{D}t = -\\rho \\, (\\nabla \\cdot \\boldsymbol{u}) $，因此局部地 $ \\rho $ 的变化为 $ \\rho^{n+1}(x,y) \\approx \\rho^n(x_d,y_d)\\, \\exp\\!\\left(-\\Delta t \\, \\widetilde{\\nabla \\cdot \\boldsymbol{u}}(x_m,y_m)\\right) $，其中 $ \\widetilde{\\nabla \\cdot \\boldsymbol{u}} $ 是动力学耦合所使用的半隐式散度。在本问题中，我们将半隐式散度建模为\n$$\n\\widetilde{\\nabla \\cdot \\boldsymbol{u}}(x,y) = \\nabla \\cdot \\boldsymbol{u}(x,y) + \\varepsilon(x,y),\n$$\n其中 $ \\varepsilon(x,y) $（单位：$\\mathrm{s^{-1}}$）表示一个由半隐式动力学耦合产生的散度误差场。\n\n时间 $ t^n $ 的初始质量密度由下式给出\n$$\n\\rho^n(x,y) = \\rho_0 \\left[ 1 + a_{\\rho}\\, \\sin\\!\\left(\\frac{2\\pi x}{L_x}\\right)\\cos\\!\\left(\\frac{2\\pi y}{L_y}\\right) \\right],\n$$\n其中 $ \\rho_0 = 1.0\\,\\mathrm{kg/m^2} $，$ a_{\\rho} = 0.1 $（无量纲）。速度场是一个无散分量和一个有势（可压缩）分量之和，\n$$\n\\boldsymbol{u}(x,y) = \\boldsymbol{u}_{\\mathrm{df}}(x,y) + \\boldsymbol{u}_{\\mathrm{c}}(x,y).\n$$\n无散分量定义为\n$$\nu_{\\mathrm{df},x}(x,y) = U_0 \\cos\\!\\left(\\frac{2\\pi y}{L_y}\\right), \\quad\nu_{\\mathrm{df},y}(x,y) = V_0 \\cos\\!\\left(\\frac{2\\pi x}{L_x}\\right),\n$$\n它满足 $ \\nabla \\cdot \\boldsymbol{u}_{\\mathrm{df}} = 0 $。可压缩分量由周期性势 $ \\phi(x,y) = \\phi_0 \\sin\\!\\left(\\frac{2\\pi x}{L_x}\\right)\\sin\\!\\left(\\frac{2\\pi y}{L_y}\\right) $ 的梯度定义，\n$$\n\\boldsymbol{u}_{\\mathrm{c}}(x,y) = \\nabla \\phi(x,y),\n$$\n因此\n$$\nu_{\\mathrm{c},x}(x,y) = \\frac{2\\pi \\phi_0}{L_x} \\cos\\!\\left(\\frac{2\\pi x}{L_x}\\right)\\sin\\!\\left(\\frac{2\\pi y}{L_y}\\right), \\quad\nu_{\\mathrm{c},y}(x,y) = \\frac{2\\pi \\phi_0}{L_y} \\sin\\!\\left(\\frac{2\\pi x}{L_x}\\right)\\cos\\!\\left(\\frac{2\\pi y}{L_y}\\right),\n$$\n其真实散度为\n$$\n\\nabla \\cdot \\boldsymbol{u}_{\\mathrm{c}}(x,y) = -\\left[\\left(\\frac{2\\pi}{L_x}\\right)^2 + \\left(\\frac{2\\pi}{L_y}\\right)^2\\right] \\phi_0 \\sin\\!\\left(\\frac{2\\pi x}{L_x}\\right)\\sin\\!\\left(\\frac{2\\pi y}{L_y}\\right).\n$$\n为了给 $ \\boldsymbol{u}_{\\mathrm{c}} $ 设置一个有物理意义的振幅，我们参数化可压缩速度尺度 $ c_{\\mathrm{amp}} $（单位：$\\mathrm{m/s}$），并选择 $ \\phi_0 = \\frac{c_{\\mathrm{amp}} \\, L_{\\mathrm{ref}}}{2\\pi} $，其中 $ L_{\\mathrm{ref}} = \\min(L_x, L_y) $，这样当 $ L_x = L_y $ 时，$ \\nabla \\phi $ 的峰值大小为 $ \\mathcal{O}(c_{\\mathrm{amp}}) $。散度误差场建模为\n$$\n\\varepsilon(x,y) = A_{\\varepsilon} \\sin\\!\\left(\\frac{4\\pi x}{L_x}\\right)\\sin\\!\\left(\\frac{4\\pi y}{L_y}\\right),\n$$\n其振幅为 $ A_{\\varepsilon} $（单位：$\\mathrm{s^{-1}}$）。\n\n半拉格朗日重映使用对规则网格上的离散场 $ \\rho^n $ 进行插值。对于插值，在两个方向上都使用周期性环绕处理，并采用一阶（线性）或三阶（三次样条）插值。时间 $ t $ 的总质量由黎曼和近似：\n$$\nM(t) = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\rho(x_i,y_j,t)\\, \\Delta x\\, \\Delta y,\n$$\n每个测试用例需要报告的诊断量是经过一个时间步长后的无量纲相对质量误差，\n$$\nE = \\frac{M(t^{n+1}) - M(t^{n})}{M(t^{n})}.\n$$\n\n实现上述单步半拉格朗日方法（一个用于中点的预测器和一个用于出发点的校正器），并为下面的每个测试用例计算 $ E $。所有物理量必须遵守指定的单位：位置以米为单位，速度以米/秒为单位，散度以秒分之一为单位，时间以秒为单位，质量以千克/平方米为单位。最终输出表示为十进制浮点数。所有三角函数中的角度单位是弧度。\n\n除非另有说明，所有测试用例使用以下通用参数值：\n- 域大小: $ L_x = L_y = 1.0 \\times 10^5\\,\\mathrm{m} $。\n- 初始质量密度参数: $ \\rho_0 = 1.0\\,\\mathrm{kg/m^2} $, $ a_{\\rho} = 0.1 $。\n- 网格是方形的: $ N_x = N_y = N $。\n- 插值阶数: $1$ (线性) 或 $3$ (三次样条)。\n- 散度误差场振幅: $ A_{\\varepsilon} $ 根据每个案例给出。\n\n测试套件：\n1. 基准无散流，无散度误差：\n   - $ N = 64 $, $ \\Delta t = 60\\,\\mathrm{s} $, $ U_0 = 5\\,\\mathrm{m/s} $, $ V_0 = 5\\,\\mathrm{m/s} $, $ c_{\\mathrm{amp}} = 0\\,\\mathrm{m/s} $, $ A_{\\varepsilon} = 0\\,\\mathrm{s^{-1}} $，插值阶数 $1$。\n2. 带有小的半隐式散度误差的无散流：\n   - $ N = 64 $, $ \\Delta t = 60\\,\\mathrm{s} $, $ U_0 = 5\\,\\mathrm{m/s} $, $ V_0 = 5\\,\\mathrm{m/s} $, $ c_{\\mathrm{amp}} = 0\\,\\mathrm{m/s} $, $ A_{\\varepsilon} = 1.0 \\times 10^{-4}\\,\\mathrm{s^{-1}} $，插值阶数 $1$。\n3. 混合流，具有轻微可压缩性，无散度误差：\n   - $ N = 64 $, $ \\Delta t = 300\\,\\mathrm{s} $, $ U_0 = 2\\,\\mathrm{m/s} $, $ V_0 = 2\\,\\mathrm{m/s} $, $ c_{\\mathrm{amp}} = 1\\,\\mathrm{m/s} $, $ A_{\\varepsilon} = 0\\,\\mathrm{s^{-1}} $，插值阶数 $1$。\n4. 混合流，具有轻微可压缩性和小的散度误差；高阶插值：\n   - $ N = 64 $, $ \\Delta t = 300\\,\\mathrm{s} $, $ U_0 = 2\\,\\mathrm{m/s} $, $ V_0 = 2\\,\\mathrm{m/s} $, $ c_{\\mathrm{amp}} = 1\\,\\mathrm{m/s} $, $ A_{\\varepsilon} = 2.0 \\times 10^{-4}\\,\\mathrm{s^{-1}} $，插值阶数 $3$。\n5. 较粗的网格，较大的时间步长；具有中等散度误差的混合流：\n   - $ N = 32 $, $ \\Delta t = 900\\,\\mathrm{s} $, $ U_0 = 8\\,\\mathrm{m/s} $, $ V_0 = 8\\,\\mathrm{m/s} $, $ c_{\\mathrm{amp}} = 2\\,\\mathrm{m/s} $, $ A_{\\varepsilon} = 5.0 \\times 10^{-4}\\,\\mathrm{s^{-1}} $，插值阶数 $1$。\n\n你的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表（例如，$[E_1,E_2,E_3,E_4,E_5]$），其中每个 $E_k$ 是相应测试用例的无量纲浮点数。",
            "solution": "问题陈述经评估有效。其科学基础在于流体动力学和数值方法的原理，特别是连续性方程和半拉格朗日平流方案。该问题定义明确，提供了所有必要的方程、参数和边界条件，以便为每个测试用例计算出唯一解。语言客观而精确。所有组成部分，包括速度场和数值误差的模型，都在数学上进行了规定并且是一致的。因此，将提供一个合理的解决方案。\n\n问题的核心是为一个质量密度场 $ \\rho $ 实现一个单步半拉格朗日平流方案，并量化该方法在各种条件下的质量守恒误差。控制方程是二维连续性方程：\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\boldsymbol{u}) = 0\n$$\n将按照指定的数值算法实现解决方案。从 $t^n$ 到 $t^{n+1} = t^n + \\Delta t$ 的单个时间步长的过程如下：\n\n1.  **网格和初始状态定义**：我们首先建立计算域。一个具有 $N_x \\times N_y$ 个单元的均匀笛卡尔网格覆盖了大小为 $L_x \\times L_y$ 的周期性域。存储 $\\rho$ 离散值的单元中心位于 $(x_i, y_j) = \\left((i+0.5)\\Delta x, (j+0.5)\\Delta y\\right)$，其中 $i \\in \\{0, ..., N_x-1\\}$，$j \\in \\{0, ..., N_y-1\\}$，$\\Delta x = L_x/N_x$ 且 $\\Delta y = L_y/N_y$。初始密度场 $\\rho^n(x,y)$ 在此网格上计算和存储。通过对所有网格单元上的密度值求和并乘以单元面积 $\\Delta x \\Delta y$ 来计算初始总质量 $M(t^n)$：\n    $$\n    M(t^n) = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\rho^n(x_i,y_j) \\Delta x \\Delta y\n    $$\n\n2.  **矢量场定义**：速度场 $\\boldsymbol{u}(x,y)$ 和半隐式散度场 $\\widetilde{\\nabla \\cdot \\boldsymbol{u}}(x,y)$ 根据提供的解析公式定义为连续函数。这些函数被实现为对坐标数组进行操作，从而实现高效的矢量化计算。总速度 $\\boldsymbol{u}$ 是无散分量 $\\boldsymbol{u}_{\\mathrm{df}}$ 和可压缩分量 $\\boldsymbol{u}_{\\mathrm{c}} = \\nabla\\phi$ 的和。半隐式散度是真实散度 $\\nabla \\cdot \\boldsymbol{u}$（由于 $\\nabla \\cdot \\boldsymbol{u}_{\\mathrm{df}} = 0$ 等于 $\\nabla \\cdot \\boldsymbol{u}_{\\mathrm{c}}$）和指定误差场 $\\varepsilon(x,y)$ 的和。\n\n3.  **半拉格朗日平流步骤**：在新时间层级的密度 $\\rho^{n+1}$ 在每个网格点 $(x_i, y_j)$ 处计算，该点被视为一个到达点。对每个点的程序如下：\n    a.  **后向轨迹计算**：为了找到新时间步长的 $\\rho$ 值，我们从到达点 $(x, y)$ 沿特征线向后追溯时间，以找到时间 $t^n$ 的出发点 $(x_d, y_d)$。问题指定了一个带一次预测-校正迭代的中点法。\n        i.  *预测*：使用到达点的速度 $\\boldsymbol{u}^n(x,y)$ 来找到轨迹中点的初步猜测 $(x_m^{(0)}, y_m^{(0)})$：\n            $$\n            (x_{m}^{(0)}, y_{m}^{(0)}) = \\left(x - \\frac{\\Delta t}{2} u_x^n(x,y),\\; y - \\frac{\\Delta t}{2} u_y^n(x,y)\\right)\n            $$\n        ii. *校正*：然后使用这个预测中点的速度 $\\boldsymbol{u}^n(x_m^{(0)}, y_m^{(0)})$ 来计算最终的出发点 $(x_d, y_d)$：\n            $$\n            (x_d, y_d) = \\left(x - \\Delta t\\, u_x^n(x_m^{(0)},y_m^{(0)}),\\; y - \\Delta t\\, u_y^n(x_m^{(0)},y_m^{(0)})\\right)\n            $$\n        问题还指定用于散度评估的中点是 $(x_m,y_m)=(x_m^{(0)},y_m^{(0)})$。通过将坐标对域长度 $L_x$ 和 $L_y$ 取模来应用周期性边界条件。这整个计算对所有网格点进行矢量化。\n\n    b.  **插值**：出发点的密度 $\\rho^n(x_d, y_d)$ 通常不在网格点上。其值必须从已知的 $\\rho^n$ 网格值中插值得到。我们使用指定的线性（阶数1）或三次样条（阶数3）插值。为了处理周期性域，我们使用 `scipy.ndimage.map_coordinates`，其中 `mode='wrap'`。该函数需要将物理坐标 $(x_d, y_d)$ 转换为网格索引坐标，即 $(i_d, j_d) = (x_d/\\Delta x - 0.5, y_d/\\Delta y - 0.5)$。\n\n    c.  **质量更新**：拉格朗日框架下的连续性方程 $\\mathrm{D}\\rho/\\mathrm{D}t = -\\rho \\nabla \\cdot \\boldsymbol{u}$ 在一个时间步长上积分以更新密度。问题提供了具体的数值近似：\n        $$\n        \\rho^{n+1}(x,y) = \\rho^n(x_d,y_d) \\exp\\left(-\\Delta t \\, \\widetilde{\\nabla \\cdot \\boldsymbol{u}}(x_m,y_m)\\right)\n        $$\n        其中 $\\rho^n(x_d,y_d)$ 是插值得到的值，$\\widetilde{\\nabla \\cdot \\boldsymbol{u}}(x_m,y_m)$ 是在轨迹中点评估的半隐式散度。这个计算也对所有网格点进行矢量化。\n\n4.  **最终诊断计算**：在为所有网格点计算更新后的密度场 $\\rho^{n+1}(x_i, y_j)$ 之后，通过在网格上求和来计算新时间层级的总质量 $M(t^{n+1})$：\n    $$\n    M(t^{n+1}) = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\rho^{n+1}(x_i,y_j) \\Delta x \\Delta y\n    $$\n    每个测试用例的最终诊断量是无量纲相对质量误差 $E$：\n    $$\n    E = \\frac{M(t^{n+1}) - M(t^{n})}{M(t^{n})}\n    $$\n    对提供的五个测试用例中的每一个重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import map_coordinates\n\ndef solve():\n    \"\"\"\n    Implements the single-step semi-Lagrangian method described in the problem\n    and computes the relative mass error for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {'N': 64, 'dt': 60.0, 'U0': 5.0, 'V0': 5.0, 'c_amp': 0.0, 'A_eps': 0.0, 'order': 1},\n        {'N': 64, 'dt': 60.0, 'U0': 5.0, 'V0': 5.0, 'c_amp': 0.0, 'A_eps': 1.0e-4, 'order': 1},\n        {'N': 64, 'dt': 300.0, 'U0': 2.0, 'V0': 2.0, 'c_amp': 1.0, 'A_eps': 0.0, 'order': 1},\n        {'N': 64, 'dt': 300.0, 'U0': 2.0, 'V0': 2.0, 'c_amp': 1.0, 'A_eps': 2.0e-4, 'order': 3},\n        {'N': 32, 'dt': 900.0, 'U0': 8.0, 'V0': 8.0, 'c_amp': 2.0, 'A_eps': 5.0e-4, 'order': 1},\n    ]\n\n    results = []\n\n    # Common parameters\n    Lx = 1.0e5  # meters\n    Ly = 1.0e5  # meters\n    rho0 = 1.0   # kg/m^2\n    a_rho = 0.1  # dimensionless\n    L_ref = min(Lx, Ly)\n\n    for case in test_cases:\n        N = case['N']\n        dt = case['dt']\n        U0 = case['U0']\n        V0 = case['V0']\n        c_amp = case['c_amp']\n        A_eps = case['A_eps']\n        interp_order = case['order']\n\n        Nx, Ny = N, N\n        dx, dy = Lx / Nx, Ly / Ny\n\n        # Create grid cell-center coordinates\n        x_coords = (np.arange(Nx) + 0.5) * dx\n        y_coords = (np.arange(Ny) + 0.5) * dy\n        XX, YY = np.meshgrid(x_coords, y_coords)\n\n        # Potential amplitude for compressible velocity component\n        phi0 = (c_amp * L_ref) / (2.0 * np.pi) if c_amp != 0.0 else 0.0\n\n        def get_velocity(x, y):\n            # Divergence-free component\n            ux_df = U0 * np.cos(2.0 * np.pi * y / Ly)\n            uy_df = V0 * np.cos(2.0 * np.pi * x / Lx)\n            \n            # Compressible component\n            k_x = 2.0 * np.pi / Lx\n            k_y = 2.0 * np.pi / Ly\n            ux_c = phi0 * k_x * np.cos(k_x * x) * np.sin(k_y * y)\n            uy_c = phi0 * k_y * np.sin(k_x * x) * np.cos(k_y * y)\n            \n            return ux_df + ux_c, uy_df + uy_c\n\n        def get_semi_implicit_divergence(x, y):\n            # True divergence (from u_c only)\n            k_x_sq = (2.0 * np.pi / Lx)**2\n            k_y_sq = (2.0 * np.pi / Ly)**2\n            div_uc = -phi0 * (k_x_sq + k_y_sq) * np.sin(2.0 * np.pi * x / Lx) * np.sin(2.0 * np.pi * y / Ly)\n            \n            # Divergence error field\n            epsilon = A_eps * np.sin(4.0 * np.pi * x / Lx) * np.sin(4.0 * np.pi * y / Ly)\n            \n            return div_uc + epsilon\n\n        # Initial mass density field at t^n\n        rho_n = rho0 * (1.0 + a_rho * np.sin(2.0 * np.pi * XX / Lx) * np.cos(2.0 * np.pi * YY / Ly))\n        M_n = np.sum(rho_n) * dx * dy\n\n        # --- Semi-Lagrangian Step ---\n        \n        # 1. Back-trajectory calculation\n        # Arrival points are the grid points (XX, YY)\n        ux_arr, uy_arr = get_velocity(XX, YY)\n        \n        # Predictor for midpoint\n        Xm = (XX - 0.5 * dt * ux_arr) % Lx\n        Ym = (YY - 0.5 * dt * uy_arr) % Ly\n        \n        # Get velocity at midpoint\n        ux_mid, uy_mid = get_velocity(Xm, Ym)\n        \n        # Corrector for departure point\n        Xd = (XX - dt * ux_mid) % Lx\n        Yd = (YY - dt * uy_mid) % Ly\n\n        # 2. Interpolate rho^n at departure points (Xd, Yd)\n        # Convert physical coordinates to grid index coordinates for map_coordinates\n        coords_x = Xd / dx - 0.5\n        coords_y = Yd / dy - 0.5\n        # The coordinates must be in a (2, Ny, Nx) array for map_coordinates\n        # with order (dim0, dim1) -> (y, x)\n        coords = np.stack([coords_y, coords_x])\n        \n        # Spline pre-filtering is recommended for order > 1 for better accuracy\n        prefilter_flag = (interp_order > 1)\n        rho_d = map_coordinates(rho_n, coords, order=interp_order, \n                                mode='wrap', prefilter=prefilter_flag)\n        \n        # 3. Mass update\n        # Get semi-implicit divergence at midpoint (Xm, Ym)\n        div_mid = get_semi_implicit_divergence(Xm, Ym)\n        rho_np1 = rho_d * np.exp(-dt * div_mid)\n\n        # --- Calculate Final Diagnostic ---\n        M_np1 = np.sum(rho_np1) * dx * dy\n        relative_mass_error = (M_np1 - M_n) / M_n\n        results.append(relative_mass_error)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这最后一个练习将半拉格朗日和半隐式的概念整合到一个完整的 SLSI 求解器中。您将构建一个皮卡（Picard）迭代方案来求解一个耦合的速度-压力系统，这是大气模型中处理快速传播的声波或重力波的典型方法。这项练习  是一个综合性的顶点任务，它展示了如何处理出发点计算与波动动力学隐式解之间的非线性相互依赖关系，这是现代数值天气预报中的一个核心挑战。",
            "id": "4087334",
            "problem": "给定一个一维周期性域，要求您为代表线性化可压缩流的速度-压力耦合系统设计并实现一个半拉格朗日、半隐式的 Picard 迭代方案。该迭代必须在更新出发点（使用临时风场）和求解隐式压力修正之间交替进行，直到满足指定的收敛准则。对于每个测试用例，最终程序必须返回达到规定收敛容差所需的迭代次数。\n\n基本原理。考虑在一个长度为 $L$ 的一维周期性域中，速度 $u(x,t)$ 和压力 $p(x,t)$ 的小扰动，其中均匀参考密度为 $\\rho_0$，声速为常数 $c$。控制线性化方程为动量方程\n$$\n\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = -\\frac{1}{\\rho_0}\\frac{\\partial p}{\\partial x},\n$$\n和可压缩性（线性化连续性）方程\n$$\n\\frac{\\partial p}{\\partial t} + \\rho_0 c^2 \\frac{\\partial u}{\\partial x} = 0.\n$$\n半拉格朗日时间步进范式通过将特征线追溯到出发点来更新到达网格点上的场。在一个时间步 $\\Delta t$ 内，与到达点 $x_i$ 对应的出发点由特征关系定义\n$$\nd_i = x_i - \\Delta t \\, u^{(k)}(x_i),\n$$\n其中 $u^{(k)}$ 是迭代索引为 $k$ 时的临时风场。我们假设使用周期性边界条件，并使用周期性插值算子来评估任意出发点上的场。\n\n半隐式离散化。对于从时间 $t^n$ 到 $t^{n+1}$ 的半隐式步骤，使用半拉格朗日更新处理平流，并隐式处理压力梯度。在迭代 $k$ 时，平流场的半拉格朗日近似为\n$$\nu^{n}(d_i) \\approx \\mathcal{I}[u^{n}](d_i), \\quad p^{n}(d_i) \\approx \\mathcal{I}[p^{n}](d_i),\n$$\n其中 $\\mathcal{I}[\\cdot]$ 表示从常规网格到出发点 $d_i$ 的周期性插值。使用一阶隐式处理压力梯度和可压缩性，到达网格点 $x_i$ 处的离散方程为\n$$\nu^{n+1}(x_i) = u^{n}(d_i) - \\frac{\\Delta t}{\\rho_0}\\left.\\frac{\\partial p^{n+1}}{\\partial x}\\right|_{x_i},\n$$\n$$\np^{n+1}(x_i) = p^{n}(d_i) - \\rho_0 c^2 \\Delta t \\left.\\frac{\\partial u^{n+1}}{\\partial x}\\right|_{x_i}.\n$$\n消去 $u^{n+1}$ 后，得到一个关于隐式压力修正的 Helmholtz 方程，\n$$\n\\left[I - c^2 (\\Delta t)^2 \\frac{\\partial^2}{\\partial x^2}\\right] p^{n+1}(x_i) = p^{n}(d_i) - \\rho_0 c^2 \\Delta t \\left.\\frac{\\partial}{\\partial x} u^{n}(d_i)\\right|_{x_i},\n$$\n对于周期性边界条件，该方程可以在傅里叶空间中高效求解。一旦求得 $p^{n+1}$，便可通过动量方程更新 $u^{n+1}$。\n\nPicard 迭代。定义 Picard 不动点迭代，该迭代交替执行以下步骤：\n- 使用当前临时风场 $u^{(k)}$ 更新出发点 $d_i$。\n- 插值计算平流场 $u^n(d_i)$ 和 $p^n(d_i)$。\n- 求解 Helmholtz 问题以得到 $p^{(k+1)}$。\n- 使用隐式压力梯度更新 $u^{(k+1)}$。\n\n收敛性评估。记更新差异为\n$$\n\\delta u^{(k)} = u^{(k+1)} - u^{(k)}, \\quad \\delta p^{(k)} = p^{(k+1)} - p^{(k)}.\n$$\n使用逐次迭代的变化来评估收敛性。令\n$$\n\\Delta^{(k)} = \\max\\left(\\|\\delta u^{(k)}\\|_{\\infty}, \\|\\delta p^{(k)}\\|_{\\infty}\\right),\n$$\n并定义一个相对于首次非平凡更新 $\\Delta^{(1)}$ 的相对收敛容差。当满足以下条件时终止迭代\n$$\n\\Delta^{(k)} \\le \\varepsilon_{\\mathrm{rel}} \\, \\Delta^{(1)} \\quad \\text{或} \\quad \\Delta^{(k)} \\le \\varepsilon_{\\mathrm{abs}},\n$$\n其中 $\\varepsilon_{\\mathrm{rel}}$ 和 $\\varepsilon_{\\mathrm{abs}}$ 为预设容差，或者当达到最大迭代次数 $k_{\\max}$ 时终止。\n\n数值离散化。使用具有 $N$ 个点、间距为 $\\Delta x = L/N$ 的均匀网格和周期性边界条件。实现：\n- 用于计算出发点 $d_i$ 处值的周期性线性插值 $\\mathcal{I}[\\cdot]$。\n- 通过快速傅里叶变换计算 $\\partial/\\partial x$ 和 $\\partial^2/\\partial x^2$ 的谱方法求导。\n- 用于算子 $I - c^2 (\\Delta t)^2 \\partial_{xx}$ 的傅里叶空间 Helmholtz 求解器。\n\n初始条件。在时间 $t^n$，初始化\n$$\nu^{n}(x) = U_0 \\sin\\left(2\\pi M \\frac{x}{L}\\right), \\quad p^{n}(x) = P_0 \\cos\\left(2\\pi M \\frac{x}{L}\\right),\n$$\n其中 $M$ 为正整数模态指数，$U_0$ 为振幅（单位：米/秒），$P_0$ 为振幅（单位：帕斯卡）。物理单位：$L$ 单位为米， $c$ 单位为米/秒，$\\rho_0$ 单位为千克/立方米，$\\Delta t$ 单位为秒。\n\n测试套件。对以下参数集运行迭代：\n- 情况 1（理想情况）：$N=256$, $L=1$ 米, $c=340$ 米/秒, $\\rho_0=1$ 千克/立方米, $\\Delta t=0.001$ 秒, $U_0=10$ 米/秒, $P_0=100$ 帕斯卡, $M=1$。\n- 情况 2（大隐式效应）：$N=256$, $L=1$ 米, $c=340$ 米/秒, $\\rho_0=1$ 千克/立方米, $\\Delta t=0.01$ 秒, $U_0=10$ 米/秒, $P_0=100$ 帕斯卡, $M=2$。\n- 情况 3（零风场情况）：$N=256$, $L=1$ 米, $c=340$ 米/秒, $\\rho_0=1$ 千克/立方米, $\\Delta t=0.005$ 秒, $U_0=0$ 米/秒, $P_0=100$ 帕斯卡, $M=3$。\n\n容差和限制。使用 $\\varepsilon_{\\mathrm{rel}}=10^{-6}$，$\\varepsilon_{\\mathrm{abs}}=10^{-10}$，以及 $k_{\\max}=50$。\n\n输出规范。对于每个测试用例，输出达到收敛准则所需的整数迭代次数（如果未达到，则输出 $k_{\\max}$）。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3]\"）。",
            "solution": "该问题要求设计并实现一个带 Picard 迭代方案的半拉格朗日半隐式（SLSI）方法，用于求解周期性域上一维线性化可压缩流方程组。解决方案涉及开发一个数值算法，该算法结合了用于空间导数的谱方法、用于隐式 Helmholtz 方程的傅里叶空间求解器、用于半拉格朗日平流步骤的周期性插值，以及一个处理基于特征线的平流所带来的非线性的迭代过程。\n\n**1. 控制系统与离散化策略**\n\n物理系统由速度 $u(x,t)$ 和压力 $p(x,t)$ 的动量和可压缩性方程描述：\n$$\n\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = -\\frac{1}{\\rho_0}\\frac{\\partial p}{\\partial x}\n$$\n$$\n\\frac{\\partial p}{\\partial t} + \\rho_0 c^2 \\frac{\\partial u}{\\partial x} = 0\n$$\n这里，$\\rho_0$ 是参考密度，$c$ 是声速。域是长度为 $L$ 的周期性域。\n\n采用半拉格朗日半隐式（SLSI）方法将解从时间 $t^n$推进到 $t^{n+1}=t^n+\\Delta t$。物质导数结合了时间导数和平流项（例如 $\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} \\equiv \\frac{Du}{Dt}$），通过在时间 $t^n$ 的出发点 $d_i$ 处评估场来近似。控制快速传播声波的压力梯度和散度项被隐式处理，以确保大时间步下的数值稳定性。在到达网格点 $x_i$ 处的离散方程为：\n$$\n\\frac{u^{n+1}(x_i) - u^{n}(d_i)}{\\Delta t} = -\\frac{1}{\\rho_0}\\left.\\frac{\\partial p^{n+1}}{\\partial x}\\right|_{x_i}\n$$\n$$\n\\frac{p^{n+1}(x_i) - p^{n}(d_i)}{\\Delta t} = -\\rho_0 c^2 \\left.\\frac{\\partial u^{n+1}}{\\partial x}\\right|_{x_i}\n$$\n出发点 $d_i$ 是在时间 $t^{n+1}$ 到达 $x_i$ 的流体质点在时间 $t^n$ 的起始位置。它通过将速度场向后积分时间来确定：$d_i = x_i - \\Delta t \\, u(x_i, t^{n+1})$。由于 $u^{n+1}$ 未知，这引入了非线性，我们使用 Picard 迭代来解决。\n\n**2. Picard 迭代方案**\n\n时间 $t^{n+1}$ 的状态通过迭代直到达到不动点来找到。设 $u^{(k)}$ 和 $p^{(k)}$ 分别是 $u^{n+1}$ 和 $p^{n+1}$ 的第 $k$ 次迭代值。迭代过程如下：\n\n1.  **初始化 ($k=0$)**：从时间 $t^{n+1}$ 的速度场和压力场的初始猜测开始。一个常见的选择是前一个时间步的解：$u^{(0)} = u^n$ 和 $p^{(0)} = p^n$。\n\n2.  **迭代步骤 (对 $k=0, 1, 2, \\dots$)**：\n    a. **出发点**：使用临时速度场 $u^{(k)}$ 计算出发点 $d_i^{(k)}$：\n    $$\n    d_i^{(k)} = x_i - \\Delta t \\, u^{(k)}(x_i)\n    $$\n    b. **插值**：使用周期性插值算子 $\\mathcal{I}[\\cdot]$ 在这些出发点评估时间 $t^n$ 的场：\n    $$\n    u^{n}(d_i^{(k)}) \\equiv \\mathcal{I}[u^n](d_i^{(k)}), \\quad p^{n}(d_i^{(k)}) \\equiv \\mathcal{I}[p^n](d_i^{(k)})\n    $$\n    c. **Helmholtz 方程**：将离散化的动量方程代入压力方程，我们得到下一个压力迭代值 $p^{(k+1)}$ 的 Helmholtz 方程：\n    $$\n    \\left[I - c^2 (\\Delta t)^2 \\frac{\\partial^2}{\\partial x^2}\\right] p^{(k+1)}(x_i) = p^{n}(d_i^{(k)}) - \\rho_0 c^2 \\Delta t \\frac{\\partial}{\\partial x} \\left( u^{n}(d_i^{(k)}) \\right)\n    $$\n    项 $\\frac{\\partial}{\\partial x} ( u^{n}(d_i^{(k)}) )$ 被解释为将导数算子应用于在网格点 $x_i$ 上定义的插值场。\n    d. **速度更新**：一旦找到 $p^{(k+1)}$，使用离散化的动量方程更新速度场 $u^{(k+1)}$：\n    $$\n    u^{(k+1)}(x_i) = u^{n}(d_i^{(k)}) - \\frac{\\Delta t}{\\rho_0}\\frac{\\partial p^{(k+1)}}{\\partial x}\n    $$\n\n3.  **收敛**：当连续迭代之间的变化足够小时，迭代终止。我们定义更新范数 $\\Delta^{(k)} = \\max\\left(\\|\\delta u^{(k)}\\|_{\\infty}, \\|\\delta p^{(k)}\\|_{\\infty}\\right)$，其中 $\\delta u^{(k)} = u^{(k+1)} - u^{(k)}$ 且 $\\delta p^{(k)} = p^{(k+1)} - p^{(k)}$。当 $\\Delta^{(k)} \\le \\varepsilon_{\\mathrm{rel}} \\, \\Delta^{(1)}$ 或 $\\Delta^{(k)} \\le \\varepsilon_{\\mathrm{abs}}$ 时，或在最多 $k_{\\max}$ 次迭代后，循环终止。参考范数 $\\Delta^{(1)}$ 是第一次完整迭代的更新范数。\n\n**3. 数值实现细节**\n\n该算法在一个具有 $N$ 个点 $x_j = j \\Delta x$（其中 $j=0, \\dots, N-1$ 且 $\\Delta x = L/N$）的均匀周期性网格上实现。\n\n- **谱方法求导**：对于周期函数 $f(x)$，其空间导数 $f'(x)$ 在傅里叶空间中计算。过程如下：\n    1. 计算场的离散傅里叶变换（DFT），$\\hat{f}_m = \\mathcal{F}[f](k_m)$。\n    2. 乘以谱导数算子 $i k_m$，其中 $k_m = 2\\pi m/L$ 是波数。\n    3. 计算结果的逆离散傅里叶变换，$f'(x) = \\mathcal{F}^{-1}[i k_m \\hat{f}_m]$。\n    二阶导数 $\\partial^2/\\partial x^2$ 类似地通过将傅里叶系数乘以 $(i k_m)^2 = -k_m^2$ 来计算。\n\n- **傅里叶空间 Helmholtz 求解器**：Helmholtz 方程 $[I - \\gamma \\partial_{xx}] p = R$（其中 $\\gamma = c^2 (\\Delta t)^2$）在傅里叶空间中可以高效求解。应用 DFT 得到：\n$$\n(1 - \\gamma (-k_m^2)) \\hat{p}_m = \\hat{R}_m \\implies \\hat{p}_m = \\frac{\\hat{R}_m}{1 + \\gamma k_m^2}\n$$\n解 $p(x)$ 通过对计算出的 $\\hat{p}_m$ 应用逆 DFT 来恢复。\n\n- **周期性线性插值**：为了在任意出发点 $d$ 处找到场 $f$ 的值，我们使用周期性线性插值。坐标 $d$ 首先通过模运算映射到域 $[0, L)$ 中。然后将其归一化为网格单位，$d_{\\text{norm}} = d/\\Delta x$。该值在两个最近的网格点 $j_0 = \\lfloor d_{\\text{norm}} \\rfloor$ 和 $j_1 = (j_0+1) \\pmod N$ 之间进行插值：\n$$\nf(d) \\approx (1 - w) f(x_{j_0}) + w f(x_{j_1})\n$$\n其中 $w = d_{\\text{norm}} - j_0$ 是插值权重。此过程对所有出发点同时进行向量化操作。\n\n时间 $t^n$ 的初始场根据问题规范设置：\n$$\nu^{n}(x) = U_0 \\sin\\left(\\frac{2\\pi M x}{L}\\right), \\quad p^{n}(x) = P_0 \\cos\\left(\\frac{2\\pi M x}{L}\\right)\n$$\n实现封装了此逻辑，遍历所提供的测试用例，并报告每个用例收敛所需的 Picard 迭代次数。",
            "answer": "```python\nimport numpy as np\n\ndef run_single_case(N, L, c, rho0, dt, U0, P0, M, eps_rel, eps_abs, k_max):\n    \"\"\"\n    Runs a single test case for the semi-Lagrangian semi-implicit Picard iteration.\n    \n    Returns the number of iterations required for convergence.\n    \"\"\"\n    # 1. Grid setup\n    dx = L / N\n    x = np.arange(N) * dx\n    wavenumbers = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n\n    # 2. Initial conditions at time t^n\n    u_n = U0 * np.sin(2 * np.pi * M * x / L)\n    p_n = P0 * np.cos(2 * np.pi * M * x / L)\n\n    # 3. Utility functions\n    def spectral_derivative(field, k):\n        return np.fft.ifft(1j * k * np.fft.fft(field)).real\n\n    def periodic_linear_interp(field, coords, length):\n        num_points = len(field)\n        dx_val = length / num_points\n        # Normalize coordinates to grid indices, handling periodicity\n        norm_coords = (coords % length) / dx_val\n        # Find bracketing grid indices\n        i0 = np.floor(norm_coords).astype(int)\n        i1 = (i0 + 1) % num_points\n        # Interpolation weights\n        w = norm_coords - i0\n        # Perform interpolation\n        return (1.0 - w) * field[i0] + w * field[i1]\n        \n    def solve_helmholtz(rhs, gamma, k):\n        rhs_hat = np.fft.fft(rhs)\n        # Denominator can be pre-calculated\n        helmholtz_op_fourier = 1 + gamma * k**2\n        # Handle k=0 case to avoid division by zero if gamma is large, although not an issue here\n        p_hat = rhs_hat / helmholtz_op_fourier\n        return np.fft.ifft(p_hat).real\n\n    # 4. Picard Iteration\n    # Initialize iterates for t^{n+1}, i.e., u^(0), p^(0)\n    u_k = u_n.copy()\n    p_k = p_n.copy()\n    \n    delta_ref = 0.0\n    gamma = c**2 * dt**2\n\n    for k_iter in range(1, k_max + 1):\n        # a. Update departure points using provisional wind u_k = u^(k-1)\n        d_k = x - dt * u_k\n\n        # b. Interpolate source fields from time t^n\n        u_n_d = periodic_linear_interp(u_n, d_k, L)\n        p_n_d = periodic_linear_interp(p_n, d_k, L)\n\n        # c. Solve Helmholtz equation for p_kp1 = p^(k)\n        deriv_u_n_d = spectral_derivative(u_n_d, wavenumbers)\n        rhs_helmholtz = p_n_d - rho0 * c**2 * dt * deriv_u_n_d\n        p_kp1 = solve_helmholtz(rhs_helmholtz, gamma, wavenumbers)\n        \n        # d. Update velocity u_kp1 = u^(k)\n        deriv_p_kp1 = spectral_derivative(p_kp1, wavenumbers)\n        u_kp1 = u_n_d - (dt / rho0) * deriv_p_kp1\n\n        # e. Assess convergence\n        delta_u_norm = np.max(np.abs(u_kp1 - u_k))\n        delta_p_norm = np.max(np.abs(p_kp1 - p_k))\n        delta_k_norm = max(delta_u_norm, delta_p_norm)\n\n        if k_iter == 1:\n            delta_ref = delta_k_norm\n            if delta_ref = eps_abs:\n                return k_iter\n        else:\n            if delta_k_norm = eps_rel * delta_ref or delta_k_norm = eps_abs:\n                return k_iter\n        \n        # f. Update provisional fields for next iteration\n        u_k = u_kp1\n        p_k = p_kp1\n\n    return k_max\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: (N, L, c, rho0, dt, U0, P0, M)\n        (256, 1.0, 340.0, 1.0, 0.001, 10.0, 100.0, 1),\n        # Case 2:\n        (256, 1.0, 340.0, 1.0, 0.01, 10.0, 100.0, 2),\n        # Case 3:\n        (256, 1.0, 340.0, 1.0, 0.005, 0.0, 100.0, 3),\n    ]\n\n    tolerances = {\n        'eps_rel': 1e-6,\n        'eps_abs': 1e-10,\n        'k_max': 50\n    }\n    \n    results = []\n    for params in test_cases:\n        N, L, c, rho0, dt, U0, P0, M = params\n        n_iters = run_single_case(\n            N, L, c, rho0, dt, U0, P0, M, **tolerances\n        )\n        results.append(n_iters)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}