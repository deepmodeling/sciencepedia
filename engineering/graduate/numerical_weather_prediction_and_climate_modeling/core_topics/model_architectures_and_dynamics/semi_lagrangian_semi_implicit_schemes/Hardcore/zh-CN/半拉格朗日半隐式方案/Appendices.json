{
    "hands_on_practices": [
        {
            "introduction": "这个首个练习是一项概念性实践，旨在建立对半拉格朗日半隐式（SLSI）方案核心思想的直观理解。在深入复杂的编程实现之前，理解不同数值方法之间的基本权衡至关重要。通过分析一个简单的一维平流问题，我们将对比半拉格朗日方法与半隐式（Crank-Nicolson）方法的核心属性——稳定性、守恒性和计算结构。这项练习将阐明，当需要采用大时间步长时，为何半拉格朗日方案在处理平流项上更受青睐。",
            "id": "4087345",
            "problem": "考虑一维线性平流方程 $u_t + c\\,u_x = 0$，其中 $u(x,t)$ 是一个被动示踪剂，定义在周期性域 $x \\in [0,L]$ 上，并具有恒定速度 $c0$。其精确解将初始条件沿着由 $dx/dt = c$ 和 $du/dt = 0$ 定义的特征线进行平移。考虑一个特定的线性测试案例，其中 $L=1$, $c=1$，均匀网格间距 $\\Delta x = 1/50$，时间步长 $\\Delta t = 3\\,\\Delta x$，并采用周期性边界条件。初始条件为 $u(x,0) = \\cos(2\\pi x/L)$。定义库朗数 $\\mu = c\\,\\Delta t/\\Delta x$，因此在此设置下 $\\mu = 3$。\n\n考虑两种数值时间步进方法：\n\n(1) 半拉格朗日方法：在网格点 $x_i$ 处，计算出发点 $x_d = x_i - c\\,\\Delta t$，并通过在 $x_d$ 处对 $u^n$ 进行插值来计算 $u^{n+1}(x_i)$。插值使用单调三次插值，该方法是保形的，并使用 $x_d$ 周围的局域插值模板。\n\n(2) 半隐式通量形式方法：从通量形式 $u_t + (c\\,u)_x = 0$ 开始，对通量散度使用梯形时间离散（也称为 Crank–Nicolson 方法），并在均匀网格上使用中心空间差分，这导致在每个步骤中都需要求解一个线性系统。假设采用周期性边界条件。\n\n仅使用特征平流的第一性原理、与通量散度相关的离散守恒性以及在均匀网格上通过傅里叶（正规模态）分析进行的标准线性稳定性分析，判断对于此测试案例，关于稳定性、守恒性和计算模板的哪些陈述是正确的：\n\nA. 对于给定网格上 $\\mu=3$ 的情况，带有单调三次插值的半拉格朗日方法对任何 $\\mu$ 都是线性稳定的，但除非通过守恒重映进行增强，否则通常不精确守恒离散域积分 $\\sum_i u_i\\,\\Delta x$。\n\nB. 采用中心空间通量的半隐式通量形式 Crank-Nicolson 格式是无条件线性稳定的，并且在周期性边界条件下精确守恒离散域积分 $\\sum_i u_i\\,\\Delta x$。\n\nC. 为了在 $\\mu1$ 时实现稳定性，半拉格朗日方法需要在每一步求解一个全局三对角线性系统，而半隐式通量形式方法可以在没有线性求解的情况下进行局部推进。\n\nD. 在一维均匀网格上，带有单调三次插值的半拉格朗日更新使用出发点周围的四点插值模板，而通量形式的 Crank-Nicolson 算子仅耦合空间上的最近邻点，导致在每一步产生一个三对角线性系统。\n\nE. 对于余弦初始条件，在此测试案例中，两种方法对任何 $\\mu$ 都能精确保持波幅。",
            "solution": "在进行求解之前，首先对问题陈述的科学性和逻辑一致性进行验证。\n\n### 步骤 1：提取已知条件\n\n-   **控制方程**：一维线性平流方程，$u_t + c\\,u_x = 0$。\n-   **域**：周期性，$x \\in [0,L]$。\n-   **速度**：恒定，$c  0$。\n-   **精确解性质**：将初始条件沿着由 $dx/dt = c$ 和 $du/dt = 0$ 定义的特征线进行平移。\n-   **测试案例参数**：\n    -   $L=1$。\n    -   $c=1$。\n    -   网格间距：$\\Delta x = 1/50$。\n    -   时间步长：$\\Delta t = 3\\,\\Delta x$。\n    -   边界条件：周期性。\n-   **初始条件**：$u(x,0) = \\cos(2\\pi x/L)$。\n-   **库朗数**：$\\mu = c\\,\\Delta t/\\Delta x = 1 \\cdot (3\\,\\Delta x) / \\Delta x = 3$。\n-   **方法 (1)**：半拉格朗日（SL）方法。\n    -   更新：在网格点 $x_i$ 处，计算出发点 $x_d = x_i - c\\,\\Delta t$。通过在 $x_d$ 处对前一时间步的解 $u^n$ 进行插值来计算 $u^{n+1}(x_i)$。\n    -   插值器：单调三次插值，保形，局域模板。\n-   **方法 (2)**：半隐式通量形式方法 (Crank-Nicolson, CN)。\n    -   方程形式：$u_t + (c\\,u)_x = 0$。\n    -   离散化：对通量散度的时间积分使用梯形法则；在均匀网格上使用中心空间差分。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n问题陈述描述了两种用于线性平流方程的标准且成熟的数值方法，这是数值偏微分方程的基石。参数定义明确且内部一致。\n\n-   **科学性**：该问题基于应用于典范偏微分方程的数值分析基本原理。所涉及的方法（半拉格朗日法、Crank-Nicolson 法）和概念（稳定性、守恒性、模板）是该领域的核心。\n-   **适定性**：该问题要求对两种明确定义的数值格式的定性性质进行分析。这种分析是确定性的，并会得出一组唯一的正确陈述。\n-   **客观性**：语言精确且数学化，没有主观性。\n-   **完整性与一致性**：提供了分析这些格式所需的所有必要信息。库朗数 $\\mu=3$ 的计算与给定参数一致。在高库朗数（$\\mu  1$）下比较格式是一个标准且有意义的练习，因为它突出了隐式方法和半拉格朗日方法相对于简单显式格式的优势。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。这是一个适定的、科学上合理的数值分析问题。将推导出解答。\n\n### 推导与分析\n\n分析将通过基于第一性原理检验每种数值方法的性质来进行。\n\n#### 方法 1：半拉格朗日（SL）格式\n\n半拉格朗日方法基于特征线法。$u_t + c u_x = 0$ 的解沿着特征曲线 $x(t) = x_0 + ct$ 是常数。这意味着 $u(x, t) = u(x - c\\Delta t, t - \\Delta t)$。数值格式近似了这种关系：\n$$u^{n+1}(x_i) = u^n(x_d)$$\n其中 $x_d = x_i - c\\Delta t$ 是出发点。由于 $x_d$ 通常不是一个网格点，因此使用插值算子 $I$：\n$$u^{n+1}_i = I(u^n)(x_d)$$\n\n-   **稳定性**：格式的稳定性由插值算子 $I$ 的性质决定。对于线性平流方程，如果插值器是稳定的（例如，不放大输入数据），则 SL 格式相对于库朗数是无条件稳定的。单调三次插值器被设计为保形和无振荡的，这些性质有利于稳定性。它不受许多显式格式所具有的严格 CFL 条件（$\\mu \\le 1$）的限制。因此，该格式被认为对任何 $\\mu$ 都是线性稳定的。\n\n-   **守恒性**：守恒性指的是量的离散积分 $\\sum_i u_i \\Delta x$ 是否随时间保持不变。插值是一种局部重网格化操作。网格点上插值后值的总和 $\\sum_i u^{n+1}_i$ 通常不等于原始数据点的总和 $\\sum_i u^n_i$。因此，插值型半拉格朗日格式通常是不守恒的。存在守恒的 SL 格式，但它们更复杂，通常在通量形式或重映框架中构建。\n\n-   **计算模板**：一个三次多项式需要四个系数来定义。为了在局部确定这些系数，需要来自四个网格点的信息。对于位于网格点 $x_j$ 和 $x_{j+1}$ 之间的出发点 $x_d$，插值模板的常见选择是四个点的集合 $\\{x_{j-1}, x_j, x_{j+1}, x_{j+2}\\}$。因此，它使用一个四点模板。每个网格点 $x_i$ 处的计算仅依赖于出发点 $x_d$ 附近的 $u^n$ 值，使得更新过程是显式且局部的。\n\n#### 方法 2：半隐式通量形式（Crank-Nicolson）格式\n\n该格式离散化了方程的守恒形式 $u_t + \\nabla \\cdot (c u) = 0$。对通量散度的时间导数使用梯形法则（Crank-Nicolson），对空间导数使用中心有限差分 $(\\delta_x F)_i = (F_{i+1/2} - F_{i-1/2})/\\Delta x$，对于中心通量，这变为 $(F_{i+1} - F_{i-1})/(2\\Delta x)$，我们得到：\n$$ \\frac{u_i^{n+1} - u_i^n}{\\Delta t} + \\frac{1}{2} \\left[ \\left(\\frac{c u_{i+1}^n - c u_{i-1}^n}{2\\Delta x}\\right) + \\left(\\frac{c u_{i+1}^{n+1} - c u_{i-1}^{n+1}}{2\\Delta x}\\right) \\right] = 0 $$\n乘以 $\\Delta t$ 并重新整理，将已知项（$n$）与未知项（$n+1$）分开：\n$$ u_i^{n+1} + \\frac{c\\Delta t}{4\\Delta x} (u_{i+1}^{n+1} - u_{i-1}^{n+1}) = u_i^n - \\frac{c\\Delta t}{4\\Delta x} (u_{i+1}^n - u_{i-1}^n) $$\n令 $\\mu = c\\Delta t/\\Delta x$，我们有：\n$$ u_i^{n+1} + \\frac{\\mu}{4} (u_{i+1}^{n+1} - u_{i-1}^{n+1}) = u_i^n - \\frac{\\mu}{4} (u_{i+1}^n - u_{i-1}^n) $$\n\n-   **稳定性**：我们进行 von Neumann 稳定性分析。设 $u_j^n = g^n e^{ikx_j}$，其中 $x_j = j\\Delta x$，$k$ 是波数。将此代入格式并除以 $g^n e^{ikj\\Delta x}$，得到放大因子 $g$ 的方程：\n$$ g \\left( 1 + \\frac{\\mu}{4} (e^{ik\\Delta x} - e^{-ik\\Delta x}) \\right) = 1 - \\frac{\\mu}{4} (e^{ik\\Delta x} - e^{-ik\\Delta x}) $$\n使用欧拉公式 $e^{i\\theta} - e^{-i\\theta} = 2i\\sin\\theta$，其中 $\\theta = k\\Delta x$：\n$$ g \\left( 1 + i\\frac{\\mu}{2} \\sin(k\\Delta x) \\right) = 1 - i\\frac{\\mu}{2} \\sin(k\\Delta x) $$\n$$ g = \\frac{1 - i\\frac{\\mu}{2} \\sin(k\\Delta x)}{1 + i\\frac{\\mu}{2} \\sin(k\\Delta x)} $$\n放大因子的模是分子和分母的模之比，它们是复共轭。对于任意实数值 $Z = \\frac{\\mu}{2}\\sin(k\\Delta x)$，有 $|1-iZ| = \\sqrt{1^2 + (-Z)^2}$ 和 $|1+iZ| = \\sqrt{1^2 + Z^2}$。\n$$ |g| = \\frac{\\sqrt{1 + \\left(\\frac{\\mu}{2}\\sin(k\\Delta x)\\right)^2}}{\\sqrt{1 + \\left(\\frac{\\mu}{2}\\sin(k\\Delta x)\\right)^2}} = 1 $$\n由于对于所有波数 $k$ 和任何 $\\mu$ 值，都有 $|g|=1$，因此该格式是无条件线性稳定的。\n\n-   **守恒性**：为了检查离散积分 $\\sum_i u_i\\Delta x$ 的守恒性，我们对所有网格点 $i$（从 $0$ 到 $N-1$）对离散方程求和：\n$$ \\sum_i (u_i^{n+1} - u_i^n) = -\\frac{\\mu\\Delta x}{4\\Delta x} \\sum_i \\left[ (u_{i+1}^n - u_{i-1}^n) + (u_{i+1}^{n+1} - u_{i-1}^{n+1}) \\right] $$\n右侧空间差分项的和是一个伸缩求和。对于周期性边界条件（$u_{N} = u_0$, $u_{-1}=u_{N-1}$），这个和恰好为零：$\\sum_{i=0}^{N-1} (F_{i+1} - F_{i-1}) = \\sum_{i=0}^{N-1} F_{i+1} - \\sum_{i=0}^{N-1} F_{i-1} = 0$。因此，$\\sum_i u_i^{n+1} = \\sum_i u_i^n$。该格式精确守恒离散域积分。\n\n-   **计算模板与系统**：更新方程将新值 $u_i^{n+1}$ 与其最近邻点 $u_{i-1}^{n+1}$ 和 $u_{i+1}^{n+1}$ 联系起来。这就为未知向量 $\\mathbf{u}^{n+1}$ 创建了一个线性方程组。该系统的矩阵仅在主对角线和两个相邻的对角线上有非零元素，这意味着它是一个三对角系统。对于周期性边界条件，在右上角和左下角还有额外的非零元素，从而形成一个循环三对角矩阵。求解这个系统是一个“全局”操作，因为每个点的值都依赖于所有其他点。\n\n### 选项评估\n\n**A. 对于给定网格上 $\\mu=3$ 的情况，带有单调三次插值的半拉格朗日方法对任何 $\\mu$ 都是线性稳定的，但除非通过守恒重映进行增强，否则通常不精确守恒离散域积分 $\\sum_i u_i\\,\\Delta x$。**\n-   如前所述，带有稳定插值器的 SL 格式对任何库朗数 $\\mu$ 都是稳定的。\n-   如前所述，插值型 SL 格式通常不守恒。\n-   该陈述正确地总结了此方法的基本性质。\n-   结论：**正确**。\n\n**B. 采用中心空间通量的半隐式通量形式 Crank-Nicolson 格式是无条件线性稳定的，并且在周期性边界条件下精确守恒离散域积分 $\\sum_i u_i\\,\\Delta x$。**\n-   通过傅里叶分析推导，该格式的放大因子模为 1，证实了其无条件稳定性。\n-   通过在周期域上求和表明，该格式建立在一种能够精确守恒离散积分的通量形式离散化之上。\n-   该陈述正确地总结了此方法的基本性质。\n-   结论：**正确**。\n\n**C. 为了在 $\\mu1$ 时实现稳定性，半拉格朗日方法需要在每一步求解一个全局三对角线性系统，而半隐式通量形式方法可以在没有线性求解的情况下进行局部推进。**\n-   半拉格朗日更新是局部和显式的：$u^{n+1}_i$ 是通过使用已知的 $u^n$ 值进行插值计算的。它不需要求解线性系统。\n-   Crank-Nicolson 方法是隐式的，需要在每个步骤中为 $u^{n+1}$ 值求解一个全局（循环）三对角线性系统。\n-   该陈述颠倒了两种方法的计算性质。\n-   结论：**不正确**。\n\n**D. 在一维均匀网格上，带有单调三次插值的半拉格朗日更新使用出发点周围的四点插值模板，而通量形式的 Crank-Nicolson 算子仅耦合空间上的最近邻点，导致在每一步产生一个三对角线性系统。**\n-   如前所述，三次插值需要一个四点模板。\n-   如前所述，CN 格式将点 $i$ 与其最近邻点 $i-1$ 和 $i+1$ 耦合，这是一种三点空间耦合，导致一个三对角（或循环三对角）系统。\n-   该陈述准确地描述了两种方法的计算模板和由此产生的代数结构。\n-   结论：**正确**。\n\n**E. 对于余弦初始条件，在此测试案例中，两种方法对任何 $\\mu$ 都能精确保持波幅。**\n-   Crank-Nicolson 格式对任何 $\\mu$ 都有 $|g|=1$，因此它精确地保持每个傅里叶模的振幅。\n-   半拉格朗日格式的行为取决于 $\\mu$。如果 $\\mu$ 是整数（如此特定设置中，$\\mu=3$），则出发点是另一个网格点，插值是精确的（它只是一个数据平移），振幅得以保持。然而，对于一般的非整数 $\\mu$，任何实际的插值器（包括三次插值）都会引入一些数值耗散，导致振幅衰减。该陈述中“对任何 $\\mu$”的说法对于半拉格朗日方法是错误的。由于该陈述必须对两种方法都成立，所以它是错误的。\n-   结论：**不正确**。",
            "answer": "$$\\boxed{ABD}$$"
        },
        {
            "introduction": "在建立了概念性理解的基础上，本练习将转向一个实际的编程任务。您将为一个二维质量密度场编写一个半拉格朗日平流方案。练习的重点是半拉格朗日方法中的一个关键挑战：其本身不保证质量守恒。通过模拟一个包含散度的速度场并引入误差，您将定量地分析这些因素如何影响全局质量守恒，这是评估任何输送方案有效性的重要指标。",
            "id": "4062303",
            "problem": "考虑一个二维周期性区域，其边长为 $L_x$ 和 $L_y$（单位：米），由一个 $N_x \\times N_y$ 单元的均匀网格离散化，单元中心位于 $x_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta x$ 和 $y_j = \\left(j+\\tfrac{1}{2}\\right)\\Delta y$，其中 $i \\in \\{0,\\dots,N_x-1\\}$，$j \\in \\{0,\\dots,N_y-1\\}$，$\\Delta x = L_x/N_x$ 且 $\\Delta y = L_y/N_y$。预报变量是质量密度 $ \\rho(x,y,t) $（单位：$\\mathrm{kg/m^2}$，将模型解释为垂直积分的），由水平速度场 $ \\boldsymbol{u}(x,y,t) = (u_x(x,y,t), u_y(x,y,t)) $（单位：$\\mathrm{m/s}$）平流。其控制定律是连续性方程\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\boldsymbol{u}) = 0,\n$$\n在 $x$ 和 $y$ 方向上均采用周期性边界条件。数值方法是一种单步半拉格朗日更新，它在一个时间步长 $ \\Delta t $（单位：秒）内，使用中点后向轨迹和从连续性方程导出的局部可压缩性因子，沿特征线移动质量密度。记时间 $ t^{n+1} = t^n + \\Delta t $ 的到达位置为 $ (x,y) $，相应的出发位置为 $ (x_d, y_d) $。用于后向轨迹的中点位置 $ (x_m, y_m) $ 由单次预测-校正中点迭代定义：\n1. 预测 $ \\boldsymbol{u}^n(x,y) $ 并计算 $ (x_{m}^{(0)}, y_{m}^{(0)}) = \\left(x - \\tfrac{\\Delta t}{2} u_x^n(x,y),\\; y - \\tfrac{\\Delta t}{2} u_y^n(x,y)\\right) $，采用周期性环绕处理。\n2. 计算 $ \\boldsymbol{u}^n(x_{m}^{(0)}, y_{m}^{(0)}) $，设置 $ (x_m,y_m) = (x_{m}^{(0)}, y_{m}^{(0)}) $，并计算出发位置 $ (x_d, y_d) = \\left(x - \\Delta t\\, u_x^n(x_m,y_m),\\; y - \\Delta t\\, u_y^n(x_m,y_m)\\right) $，采用周期性环绕处理。\n\n沿特征线，连续性方程意味着 $ \\mathrm{D}\\rho/\\mathrm{D}t = -\\rho \\, (\\nabla \\cdot \\boldsymbol{u}) $，因此局部 $ \\rho $ 的变化为 $ \\rho^{n+1}(x,y) \\approx \\rho^n(x_d,y_d)\\, \\exp\\!\\left(-\\Delta t \\, \\widetilde{\\nabla \\cdot \\boldsymbol{u}}(x_m,y_m)\\right) $，其中 $ \\widetilde{\\nabla \\cdot \\boldsymbol{u}} $ 是动力学耦合使用的半隐式散度。在本问题中，我们将半隐式散度建模为\n$$\n\\widetilde{\\nabla \\cdot \\boldsymbol{u}}(x,y) = \\nabla \\cdot \\boldsymbol{u}(x,y) + \\varepsilon(x,y),\n$$\n其中 $ \\varepsilon(x,y) $（单位：$\\mathrm{s^{-1}}$）表示由半隐式动力学耦合产生的散度误差场。\n\n时间 $ t^n $ 的初始质量密度由下式给出\n$$\n\\rho^n(x,y) = \\rho_0 \\left[ 1 + a_{\\rho}\\, \\sin\\!\\left(\\frac{2\\pi x}{L_x}\\right)\\cos\\!\\left(\\frac{2\\pi y}{L_y}\\right) \\right],\n$$\n其中 $ \\rho_0 = 1.0\\,\\mathrm{kg/m^2} $，$ a_{\\rho} = 0.1 $（无量纲）。速度场是一个无散分量和一个有势（可压缩）分量之和，\n$$\n\\boldsymbol{u}(x,y) = \\boldsymbol{u}_{\\mathrm{df}}(x,y) + \\boldsymbol{u}_{\\mathrm{c}}(x,y).\n$$\n无散分量定义为\n$$\nu_{\\mathrm{df},x}(x,y) = U_0 \\cos\\!\\left(\\frac{2\\pi y}{L_y}\\right), \\quad\nu_{\\mathrm{df},y}(x,y) = V_0 \\cos\\!\\left(\\frac{2\\pi x}{L_x}\\right),\n$$\n满足 $ \\nabla \\cdot \\boldsymbol{u}_{\\mathrm{df}} = 0 $。可压缩分量由周期性势 $ \\phi(x,y) = \\phi_0 \\sin\\!\\left(\\frac{2\\pi x}{L_x}\\right)\\sin\\!\\left(\\frac{2\\pi y}{L_y}\\right) $ 的梯度定义，\n$$\n\\boldsymbol{u}_{\\mathrm{c}}(x,y) = \\nabla \\phi(x,y),\n$$\n因此\n$$\nu_{\\mathrm{c},x}(x,y) = \\frac{2\\pi \\phi_0}{L_x} \\cos\\!\\left(\\frac{2\\pi x}{L_x}\\right)\\sin\\!\\left(\\frac{2\\pi y}{L_y}\\right), \\quad\nu_{\\mathrm{c},y}(x,y) = \\frac{2\\pi \\phi_0}{L_y} \\sin\\!\\left(\\frac{2\\pi x}{L_x}\\right)\\cos\\!\\left(\\frac{2\\pi y}{L_y}\\right),\n$$\n其真实散度为\n$$\n\\nabla \\cdot \\boldsymbol{u}_{\\mathrm{c}}(x,y) = -\\left[\\left(\\frac{2\\pi}{L_x}\\right)^2 + \\left(\\frac{2\\pi}{L_y}\\right)^2\\right] \\phi_0 \\sin\\!\\left(\\frac{2\\pi x}{L_x}\\right)\\sin\\!\\left(\\frac{2\\pi y}{L_y}\\right).\n$$\n为了给 $ \\boldsymbol{u}_{\\mathrm{c}} $ 设置一个物理上有意义的振幅，我们参数化可压缩速度尺度 $ c_{\\mathrm{amp}} $（单位：$\\mathrm{m/s}$）并选择 $ \\phi_0 = \\frac{c_{\\mathrm{amp}} \\, L_{\\mathrm{ref}}}{2\\pi} $，其中 $ L_{\\mathrm{ref}} = \\min(L_x, L_y) $，这样当 $ L_x = L_y $ 时 $ \\nabla \\phi $ 的峰值大小为 $ \\mathcal{O}(c_{\\mathrm{amp}}) $。散度误差场建模为\n$$\n\\varepsilon(x,y) = A_{\\varepsilon} \\sin\\!\\left(\\frac{4\\pi x}{L_x}\\right)\\sin\\!\\left(\\frac{4\\pi y}{L_y}\\right),\n$$\n振幅为 $ A_{\\varepsilon} $（单位：$\\mathrm{s^{-1}}$）。\n\n半拉格朗日重映使用来自规则网格上离散场 $ \\rho^n $ 的插值。插值时，在两个方向上都使用周期性环绕，并采用一阶（线性）或三阶（三次样条）插值。时间 $ t $ 的全局质量由 Riemann 和近似\n$$\nM(t) = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\rho(x_i,y_j,t)\\, \\Delta x\\, \\Delta y,\n$$\n并且每个测试用例要报告的诊断量是一个时间步长后的无量纲相对质量误差，\n$$\nE = \\frac{M(t^{n+1}) - M(t^{n})}{M(t^{n})}.\n$$\n\n实现上述单步半拉格朗日方法（一个用于中点的预测器和一个用于出发点的校正器），并为下面的每个测试用例计算 $ E $。所有物理量必须遵守指定的单位：位置单位为米，速度单位为米每秒，散度单位为每秒，时间单位为秒，质量单位为千克每平方米。将最终输出表示为十进制浮点数。所有三角函数中的角度单位均为弧度。\n\n除非另有说明，否则所有测试用例均使用以下通用参数值：\n- 区域大小：$ L_x = L_y = 1.0 \\times 10^5\\,\\mathrm{m} $。\n- 初始质量密度参数：$ \\rho_0 = 1.0\\,\\mathrm{kg/m^2} $，$ a_{\\rho} = 0.1 $。\n- 网格为方形：$ N_x = N_y = N $。\n- 插值阶数：$1$（线性）或 $3$（三次样条）。\n- 散度误差场振幅：$ A_{\\varepsilon} $ 根据每个用例给定。\n\n测试套件：\n1. 基准无散流，无散度误差：\n   - $ N = 64 $，$ \\Delta t = 60\\,\\mathrm{s} $，$ U_0 = 5\\,\\mathrm{m/s} $，$ V_0 = 5\\,\\mathrm{m/s} $，$ c_{\\mathrm{amp}} = 0\\,\\mathrm{m/s} $，$ A_{\\varepsilon} = 0\\,\\mathrm{s^{-1}} $，插值阶数 $1$。\n2. 带有微小半隐式散度误差的无散流：\n   - $ N = 64 $，$ \\Delta t = 60\\,\\mathrm{s} $，$ U_0 = 5\\,\\mathrm{m/s} $，$ V_0 = 5\\,\\mathrm{m/s} $，$ c_{\\mathrm{amp}} = 0\\,\\mathrm{m/s} $，$ A_{\\varepsilon} = 1.0 \\times 10^{-4}\\,\\mathrm{s^{-1}} $，插值阶数 $1$。\n3. 具有中等可压缩性的混合流，无散度误差：\n   - $ N = 64 $，$ \\Delta t = 300\\,\\mathrm{s} $，$ U_0 = 2\\,\\mathrm{m/s} $，$ V_0 = 2\\,\\mathrm{m/s} $，$ c_{\\mathrm{amp}} = 1\\,\\mathrm{m/s} $，$ A_{\\varepsilon} = 0\\,\\mathrm{s^{-1}} $，插值阶数 $1$。\n4. 具有中等可压缩性和微小散度误差的混合流；高阶插值：\n   - $ N = 64 $，$ \\Delta t = 300\\,\\mathrm{s} $，$ U_0 = 2\\,\\mathrm{m/s} $，$ V_0 = 2\\,\\mathrm{m/s} $，$ c_{\\mathrm{amp}} = 1\\,\\mathrm{m/s} $，$ A_{\\varepsilon} = 2.0 \\times 10^{-4}\\,\\mathrm{s^{-1}} $，插值阶数 $3$。\n5. 更粗的网格，更大的时间步长；具有中等散度误差的混合流：\n   - $ N = 32 $，$ \\Delta t = 900\\,\\mathrm{s} $，$ U_0 = 8\\,\\mathrm{m/s} $，$ V_0 = 8\\,\\mathrm{m/s} $，$ c_{\\mathrm{amp}} = 2\\,\\mathrm{m/s} $，$ A_{\\varepsilon} = 5.0 \\times 10^{-4}\\,\\mathrm{s^{-1}} $，插值阶数 $1$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[E_1,E_2,E_3,E_4,E_5]$），其中每个 $E_k$ 是相应测试用例的无量纲浮点数。",
            "solution": "问题陈述经评估有效。它在科学上基于流体动力学和数值方法的原理，特别是连续性方程和半拉格朗日平流方案。该问题是适定的，提供了所有必要的方程、参数和边界条件，以便为每个测试用例计算出唯一的解。语言客观而精确。所有组成部分，包括速度场和数值误差的模型，都在数学上进行了明确规定并且是一致的。因此，将提供一个合理的解决方案。\n\n问题的核心是为质量密度场 $ \\rho $ 实现一个单步半拉格朗日平流方案，并量化该方法在各种条件下的质量守恒误差。控制方程是二维连续性方程：\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla \\cdot (\\rho \\boldsymbol{u}) = 0\n$$\n将遵循指定的数值算法来实现解决方案。从 $t^n$到 $t^{n+1} = t^n + \\Delta t$ 的单个时间步长的过程如下：\n\n1.  **网格和初始状态定义**：我们首先建立计算域。一个具有 $N_x \\times N_y$ 个单元的均匀笛卡尔网格覆盖了大小为 $L_x \\times L_y$ 的周期性区域。单元中心，即存储 $\\rho$ 离散值的位置，位于 $(x_i, y_j) = \\left((i+0.5)\\Delta x, (j+0.5)\\Delta y\\right)$，其中 $i \\in \\{0, ..., N_x-1\\}$，$j \\in \\{0, ..., N_y-1\\}$，且 $\\Delta x = L_x/N_x$，$\\Delta y = L_y/N_y$。初始密度场 $\\rho^n(x,y)$ 在该网格上计算和存储。初始总质量 $M(t^n)$ 通过将所有网格单元上的密度值求和并乘以单元面积 $\\Delta x \\Delta y$ 来计算：\n    $$\n    M(t^n) = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\rho^n(x_i,y_j) \\Delta x \\Delta y\n    $$\n\n2.  **矢量场定义**：速度场 $\\boldsymbol{u}(x,y)$ 和半隐式散度场 $\\widetilde{\\nabla \\cdot \\boldsymbol{u}}(x,y)$ 根据提供的解析公式定义为连续函数。这些函数被实现为对坐标数组进行操作，从而实现高效的矢量化计算。总速度 $\\boldsymbol{u}$ 是无散分量 $\\boldsymbol{u}_{\\mathrm{df}}$ 和可压缩分量 $\\boldsymbol{u}_{\\mathrm{c}} = \\nabla\\phi$ 之和。半隐式散度是真实散度 $\\nabla \\cdot \\boldsymbol{u}$（由于 $\\nabla \\cdot \\boldsymbol{u}_{\\mathrm{df}} = 0$ 等于 $\\nabla \\cdot \\boldsymbol{u}_{\\mathrm{c}}$）和指定的误差场 $\\varepsilon(x,y)$ 之和。\n\n3.  **半拉格朗日平流步骤**：新时间层的密度 $\\rho^{n+1}$ 在每个网格点 $(x_i, y_j)$ 上计算，该点被视为到达点。每个点的过程如下：\n    a.  **后向轨迹计算**：为了在新时间步找到 $\\rho$ 的值，我们从到达点 $(x, y)$ 沿特征线向后追溯时间，以找到时间 $t^n$ 的出发点 $(x_d, y_d)$。问题指定了一种带一次预测-校正迭代的中点法。\n        i.  *预测器*：使用到达点的速度 $\\boldsymbol{u}^n(x,y)$ 找到轨迹中点的初始猜测值 $(x_m^{(0)}, y_m^{(0)})$：\n            $$\n            (x_{m}^{(0)}, y_{m}^{(0)}) = \\left(x - \\frac{\\Delta t}{2} u_x^n(x,y),\\; y - \\frac{\\Delta t}{2} u_y^n(x,y)\\right)\n            $$\n        ii. *校正器*：然后使用这个预测中点的速度 $\\boldsymbol{u}^n(x_m^{(0)}, y_m^{(0)})$ 来计算最终的出发点 $(x_d, y_d)$：\n            $$\n            (x_d, y_d) = \\left(x - \\Delta t\\, u_x^n(x_m^{(0)},y_m^{(0)}),\\; y - \\Delta t\\, u_y^n(x_m^{(0)},y_m^{(0)})\\right)\n            $$\n        问题还指定用于散度评估的中点是 $(x_m,y_m)=(x_m^{(0)},y_m^{(0)})$。通过对坐标取模域长度 $L_x$ 和 $L_y$ 来应用周期性边界条件。整个计算过程对所有网格点进行了矢量化处理。\n\n    b.  **插值**：出发点处的密度 $\\rho^n(x_d, y_d)$ 通常不在网格点上。它的值必须从已知的 $\\rho^n$ 网格值中插值得到。我们按照指定使用线性（1阶）或三次样条（3阶）插值。为了处理周期性域，我们使用 `scipy.ndimage.map_coordinates` 并设置 `mode='wrap'`。该函数需要将物理坐标 $(x_d, y_d)$ 转换为网格索引坐标，转换公式为 $(i_d, j_d) = (x_d/\\Delta x - 0.5, y_d/\\Delta y - 0.5)$。\n\n    c.  **质量更新**：拉格朗日框架下的连续性方程 $\\mathrm{D}\\rho/\\mathrm{D}t = -\\rho \\nabla \\cdot \\boldsymbol{u}$ 在一个时间步长上进行积分以更新密度。问题提供了具体的数值近似：\n        $$\n        \\rho^{n+1}(x,y) = \\rho^n(x_d,y_d) \\exp\\left(-\\Delta t \\, \\widetilde{\\nabla \\cdot \\boldsymbol{u}}(x_m,y_m)\\right)\n        $$\n        其中 $\\rho^n(x_d,y_d)$ 是插值得到的值，$\\widetilde{\\nabla \\cdot \\boldsymbol{u}}(x_m,y_m)$ 是在轨迹中点计算的半隐式散度。此计算也对所有网格点进行了矢量化处理。\n\n4.  **最终诊断量计算**：在为所有网格点计算更新后的密度场 $\\rho^{n+1}(x_i, y_j)$ 之后，通过对网格求和来计算新时间层的总质量 $M(t^{n+1})$：\n    $$\n    M(t^{n+1}) = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\rho^{n+1}(x_i,y_j) \\Delta x \\Delta y\n    $$\n    每个测试用例的最终诊断量是无量纲相对质量误差 $E$：\n    $$\n    E = \\frac{M(t^{n+1}) - M(t^{n})}{M(t^{n})}\n    $$\n    对所提供的五个测试用例中的每一个重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import map_coordinates\n\ndef solve():\n    \"\"\"\n    Implements the single-step semi-Lagrangian method described in the problem\n    and computes the relative mass error for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {'N': 64, 'dt': 60.0, 'U0': 5.0, 'V0': 5.0, 'c_amp': 0.0, 'A_eps': 0.0, 'order': 1},\n        {'N': 64, 'dt': 60.0, 'U0': 5.0, 'V0': 5.0, 'c_amp': 0.0, 'A_eps': 1.0e-4, 'order': 1},\n        {'N': 64, 'dt': 300.0, 'U0': 2.0, 'V0': 2.0, 'c_amp': 1.0, 'A_eps': 0.0, 'order': 1},\n        {'N': 64, 'dt': 300.0, 'U0': 2.0, 'V0': 2.0, 'c_amp': 1.0, 'A_eps': 2.0e-4, 'order': 3},\n        {'N': 32, 'dt': 900.0, 'U0': 8.0, 'V0': 8.0, 'c_amp': 2.0, 'A_eps': 5.0e-4, 'order': 1},\n    ]\n\n    results = []\n\n    # Common parameters\n    Lx = 1.0e5  # meters\n    Ly = 1.0e5  # meters\n    rho0 = 1.0   # kg/m^2\n    a_rho = 0.1  # dimensionless\n    L_ref = min(Lx, Ly)\n\n    for case in test_cases:\n        N = case['N']\n        dt = case['dt']\n        U0 = case['U0']\n        V0 = case['V0']\n        c_amp = case['c_amp']\n        A_eps = case['A_eps']\n        interp_order = case['order']\n\n        Nx, Ny = N, N\n        dx, dy = Lx / Nx, Ly / Ny\n\n        # Create grid cell-center coordinates, using 'xy' indexing for meshgrid\n        x_coords = (np.arange(Nx) + 0.5) * dx\n        y_coords = (np.arange(Ny) + 0.5) * dy\n        XX, YY = np.meshgrid(x_coords, y_coords)\n\n        # Potential amplitude for compressible velocity component\n        phi0 = (c_amp * L_ref) / (2.0 * np.pi) if c_amp != 0.0 else 0.0\n\n        def get_velocity(x, y):\n            # Divergence-free component\n            ux_df = U0 * np.cos(2.0 * np.pi * y / Ly)\n            uy_df = V0 * np.cos(2.0 * np.pi * x / Lx)\n            \n            # Compressible component\n            k_x = 2.0 * np.pi / Lx\n            k_y = 2.0 * np.pi / Ly\n            ux_c = phi0 * k_x * np.cos(k_x * x) * np.sin(k_y * y)\n            uy_c = phi0 * k_y * np.sin(k_x * x) * np.cos(k_y * y)\n            \n            return ux_df + ux_c, uy_df + uy_c\n\n        def get_semi_implicit_divergence(x, y):\n            # True divergence (from u_c only)\n            k_x_sq = (2.0 * np.pi / Lx)**2\n            k_y_sq = (2.0 * np.pi / Ly)**2\n            div_uc = -phi0 * (k_x_sq + k_y_sq) * np.sin(2.0 * np.pi * x / Lx) * np.sin(2.0 * np.pi * y / Ly)\n            \n            # Divergence error field\n            epsilon = A_eps * np.sin(4.0 * np.pi * x / Lx) * np.sin(4.0 * np.pi * y / Ly)\n            \n            return div_uc + epsilon\n\n        # Initial mass density field at t^n\n        rho_n = rho0 * (1.0 + a_rho * np.sin(2.0 * np.pi * XX / Lx) * np.cos(2.0 * np.pi * YY / Ly))\n        M_n = np.sum(rho_n) * dx * dy\n\n        # --- Semi-Lagrangian Step ---\n        \n        # 1. Back-trajectory calculation\n        # Arrival points are the grid points (XX, YY)\n        ux_arr, uy_arr = get_velocity(XX, YY)\n        \n        # Predictor for midpoint, with periodic wrapping\n        Xm = (XX - 0.5 * dt * ux_arr) % Lx\n        Ym = (YY - 0.5 * dt * uy_arr) % Ly\n        \n        # Get velocity at midpoint\n        ux_mid, uy_mid = get_velocity(Xm, Ym)\n        \n        # Corrector for departure point, with periodic wrapping\n        Xd = (XX - dt * ux_mid) % Lx\n        Yd = (YY - dt * uy_mid) % Ly\n\n        # 2. Interpolate rho^n at departure points (Xd, Yd)\n        # Convert physical coordinates to grid index coordinates for map_coordinates\n        coords_x = Xd / dx - 0.5\n        coords_y = Yd / dy - 0.5\n        coords = np.stack([coords_y, coords_x]) # (y, x) order\n        \n        rho_d = map_coordinates(rho_n, coords, order=interp_order, \n                                mode='wrap', prefilter=(interp_order > 1))\n        \n        # 3. Mass update\n        # Get semi-implicit divergence at midpoint (Xm, Ym)\n        div_mid = get_semi_implicit_divergence(Xm, Ym)\n        rho_np1 = rho_d * np.exp(-dt * div_mid)\n\n        # --- Calculate Final Diagnostic ---\n        M_np1 = np.sum(rho_np1) * dx * dy\n        relative_mass_error = (M_np1 - M_n) / M_n\n        results.append(relative_mass_error)\n\n    # Print results in the required format\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这最后一个练习将半拉格朗日和半隐式两部分结合起来，处理一个耦合系统，这是大气模型的典型特征。您将实现一个皮卡（Picard）迭代法来求解线性化的可压缩流动方程组。这个动手练习将向您展示如何处理因出发点依赖于未来未知速度场而产生的非线性问题，这需要一个在更新轨迹和求解压力场的隐式亥姆霍兹（Helmholtz）方程之间交替进行的迭代过程。",
            "id": "4087334",
            "problem": "给定一个一维周期性域，要求您设计并实现一个半拉格朗日、半隐式的 Picard 迭代法，用于求解一个表示线性化可压缩流的速度-压力耦合系统。该迭代必须在“使用临时风场更新出发点”和“求解隐式压力修正”之间交替进行，直到满足指定的收敛准则。对于每个测试用例，最终的程序必须返回达到规定收敛容差所需的迭代次数。\n\n基本原理。考虑在一个长度为 $L$ 的一维周期性域中，速度 $u(x,t)$ 和压力 $p(x,t)$ 的小扰动，该域具有均匀的参考密度 $\\rho_0$ 和恒定的声速 $c$。控制线性化方程为动量方程\n$$\n\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = -\\frac{1}{\\rho_0}\\frac{\\partial p}{\\partial x},\n$$\n以及可压缩性（线性化连续性）方程\n$$\n\\frac{\\partial p}{\\partial t} + \\rho_0 c^2 \\frac{\\partial u}{\\partial x} = 0.\n$$\n半拉格朗日时间步进范式通过将特征线追溯到出发点来更新到达网格点上的场。在一个时间步 $\\Delta t$ 内，与到达点 $x_i$ 相应的出发点由特征线关系定义\n$$\nd_i = x_i - \\Delta t \\, u^{(k)}(x_i),\n$$\n其中 $u^{(k)}$ 是迭代指数为 $k$ 时的临时风场。我们假设采用周期性边界条件，并使用周期性插值算子来评估任意出发点上的场。\n\n半隐式离散化。对于从时间 $t^n$ 到 $t^{n+1}$ 的半隐式步骤，使用半拉格朗日更新处理平流项，并隐式处理压力梯度。在迭代 $k$ 时，平流场的半拉格朗日近似为\n$$\nu^{n}(d_i) \\approx \\mathcal{I}[u^{n}](d_i), \\quad p^{n}(d_i) \\approx \\mathcal{I}[p^{n}](d_i),\n$$\n其中 $\\mathcal{I}[\\cdot]$ 表示从常规网格到出发点 $d_i$ 的周期性插值。对压力梯度和可压缩性采用一阶隐式处理，到达网格点 $x_i$ 处的离散方程为\n$$\nu^{n+1}(x_i) = u^{n}(d_i) - \\frac{\\Delta t}{\\rho_0}\\left.\\frac{\\partial p^{n+1}}{\\partial x}\\right|_{x_i},\n$$\n$$\np^{n+1}(x_i) = p^{n}(d_i) - \\rho_0 c^2 \\Delta t \\left.\\frac{\\partial u^{n+1}}{\\partial x}\\right|_{x_i}.\n$$\n消去 $u^{n+1}$ 可得到一个关于隐式压力修正的 Helmholtz 方程，\n$$\n\\left[I - c^2 (\\Delta t)^2 \\frac{\\partial^2}{\\partial x^2}\\right] p^{n+1}(x_i) = p^{n}(d_i) - \\rho_0 c^2 \\Delta t \\left.\\frac{\\partial}{\\partial x} u^{n}(d_i)\\right|_{x_i},\n$$\n对于周期性边界条件，该方程可以在傅里叶空间中高效求解。一旦求得 $p^{n+1}$，就通过动量方程更新 $u^{n+1}$。\n\nPicard 迭代。定义 Picard 不动点迭代，该迭代在以下步骤之间交替进行：\n- 使用当前的临时风场 $u^{(k)}$ 更新出发点 $d_i$。\n- 插值计算平流场 $u^n(d_i)$ 和 $p^n(d_i)$。\n- 求解 Helmholtz 问题以得到 $p^{(k+1)}$。\n- 使用隐式压力梯度更新 $u^{(k+1)}$。\n\n收敛性评估。记更新差异为\n$$\n\\delta u^{(k)} = u^{(k+1)} - u^{(k)}, \\quad \\delta p^{(k)} = p^{(k+1)} - p^{(k)}.\n$$\n使用迭代间的变化来评估收敛性。令\n$$\n\\Delta^{(k)} = \\max\\left(\\|\\delta u^{(k)}\\|_{\\infty}, \\|\\delta p^{(k)}\\|_{\\infty}\\right),\n$$\n并定义一个相对于第一次非平凡更新 $\\Delta^{(1)}$ 的相对收敛容差。当\n$$\n\\Delta^{(k)} \\le \\varepsilon_{\\mathrm{rel}} \\, \\Delta^{(1)} \\quad \\text{或} \\quad \\Delta^{(k)} \\le \\varepsilon_{\\mathrm{abs}},\n$$\n对于规定的容差 $\\varepsilon_{\\mathrm{rel}}$ 和 $\\varepsilon_{\\mathrm{abs}}$ 成立时，或当达到最大迭代次数 $k_{\\max}$ 时，终止迭代。\n\n数值离散化。使用一个包含 $N$ 个点、间距为 $\\Delta x = L/N$ 的均匀网格，并采用周期性边界条件。实现：\n- 对出发点 $d_i$ 处的 $\\mathcal{I}[\\cdot]$ 实现周期性线性插值。\n- 通过快速傅里叶变换（Fast Fourier Transform）计算谱导数 $\\partial/\\partial x$ 和 $\\partial^2/\\partial x^2$。\n- 为算子 $I - c^2 (\\Delta t)^2 \\partial_{xx}$ 实现一个傅里叶空间 Helmholtz 求解器。\n\n初始条件。在时间 $t^n$ 时，初始化\n$$\nu^{n}(x) = U_0 \\sin\\left(2\\pi M \\frac{x}{L}\\right), \\quad p^{n}(x) = P_0 \\cos\\left(2\\pi M \\frac{x}{L}\\right),\n$$\n其中 $M$ 为正整数模态指数，$U_0$ 为以米/秒为单位的振幅，$P_0$ 为以帕斯卡为单位的振幅。物理单位：$L$ 单位为米， $c$ 单位为米/秒，$\\rho_0$ 单位为千克/立方米，$\\Delta t$ 单位为秒。\n\n测试套件。对以下参数集运行迭代：\n- 情况 1（理想情况）：$N=256$， $L=1$ 米， $c=340$ 米/秒， $\\rho_0=1$ 千克/立方米， $\\Delta t=0.001$ 秒， $U_0=10$ 米/秒， $P_0=100$ 帕斯卡， $M=1$。\n- 情况 2（大隐式效应）：$N=256$， $L=1$ 米， $c=340$ 米/秒， $\\rho_0=1$ 千克/立方米， $\\Delta t=0.01$ 秒， $U_0=10$ 米/秒， $P_0=100$ 帕斯卡， $M=2$。\n- 情况 3（零风边界情况）：$N=256$， $L=1$ 米， $c=340$ 米/秒， $\\rho_0=1$ 千克/立方米， $\\Delta t=0.005$ 秒， $U_0=0$ 米/秒， $P_0=100$ 帕斯卡， $M=3$。\n\n容差和限制。使用 $\\varepsilon_{\\mathrm{rel}}=10^{-6}$，$\\varepsilon_{\\mathrm{abs}}=10^{-10}$ 和 $k_{\\max}=50$。\n\n输出规格。对于每个测试用例，输出达到收敛准则所需的整数迭代次数（如果未达到，则输出 $k_{\\max}$）。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，\"[result1,result2,result3]\"）。",
            "solution": "该问题要求设计并实现一种带有 Picard 迭代方案的半拉格朗日半隐式（SLSI）方法，用于在周期性域上求解一维线性化可压缩流方程组。解决方案涉及开发一种数值算法，该算法结合了用于空间导数的谱方法、用于隐式 Helmholtz 方程的傅里叶空间求解器、用于半拉格朗日平流步骤的周期性插值，以及一个用于处理基于特征线的平流的非线性的迭代过程。\n\n**1. 控制系统与离散化策略**\n\n该物理系统由速度 $u(x,t)$ 和压力 $p(x,t)$ 的动量方程和可压缩性方程描述：\n$$\n\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = -\\frac{1}{\\rho_0}\\frac{\\partial p}{\\partial x}\n$$\n$$\n\\frac{\\partial p}{\\partial t} + \\rho_0 c^2 \\frac{\\partial u}{\\partial x} = 0\n$$\n此处，$\\rho_0$ 是参考密度，$c$ 是声速。该域是周期性的，长度为 $L$。\n\n采用半拉格朗日半隐式（SLSI）方法将解从时间 $t^n$ 推进到 $t^{n+1}=t^n+\\Delta t$。物质导数（它结合了时间导数和平流项，例如 $\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} \\equiv \\frac{Du}{Dt}$）通过在出发点 $d_i$ 处评估时间 $t^n$ 的场来近似。控制快速传播声波的压力梯度和散度项被隐式处理，以确保大时间步长的数值稳定性。在到达网格点 $x_i$ 处的离散方程为：\n$$\n\\frac{u^{n+1}(x_i) - u^{n}(d_i)}{\\Delta t} = -\\frac{1}{\\rho_0}\\left.\\frac{\\partial p^{n+1}}{\\partial x}\\right|_{x_i}\n$$\n$$\n\\frac{p^{n+1}(x_i) - p^{n}(d_i)}{\\Delta t} = -\\rho_0 c^2 \\left.\\frac{\\partial u^{n+1}}{\\partial x}\\right|_{x_i}\n$$\n出发点 $d_i$ 是指在时间 $t^{n+1}$ 到达 $x_i$ 的流体质点在时间 $t^n$ 的起始位置。它通过对速度场进行时间上的向后积分来确定：$d_i = x_i - \\Delta t \\, u(x_i, t^{n+1})$。由于 $u^{n+1}$ 是未知的，这引入了一个非线性，我们使用 Picard 迭代来解决。\n\n**2. Picard 迭代方案**\n\n时间 $t^{n+1}$ 的状态是通过迭代直到达到不动点来找到的。设 $u^{(k)}$ 和 $p^{(k)}$ 分别是 $u^{n+1}$ 和 $p^{n+1}$ 的第 $k$ 次迭代结果。迭代过程如下：\n\n1.  **初始化 ($k=0$)**：从时间 $t^{n+1}$ 时的速度场和压力场的初始猜测开始。一个常见的选择是前一个时间步的解：$u^{(0)} = u^n$ 和 $p^{(0)} = p^n$。\n\n2.  **迭代步骤 (对于 $k=0, 1, 2, \\dots$)**：\n    a. **出发点**：使用临时速度场 $u^{(k)}$ 计算出发点 $d_i^{(k)}$：\n    $$\n    d_i^{(k)} = x_i - \\Delta t \\, u^{(k)}(x_i)\n    $$\n    b. **插值**：使用周期性插值算子 $\\mathcal{I}[\\cdot]$ 在这些出发点上评估时间 $t^n$ 的场：\n    $$\n    u^{n}(d_i^{(k)}) \\equiv \\mathcal{I}[u^n](d_i^{(k)}), \\quad p^{n}(d_i^{(k)}) \\equiv \\mathcal{I}[p^n](d_i^{(k)})\n    $$\n    c. **Helmholtz 方程**：通过将离散化的动量方程代入压力方程，我们得到关于下一个压力迭代值 $p^{(k+1)}$ 的 Helmholtz 方程：\n    $$\n    \\left[I - c^2 (\\Delta t)^2 \\frac{\\partial^2}{\\partial x^2}\\right] p^{(k+1)}(x_i) = p^{n}(d_i^{(k)}) - \\rho_0 c^2 \\Delta t \\frac{\\partial}{\\partial x} \\left( u^{n}(d_i^{(k)}) \\right)\n    $$\n    项 $\\frac{\\partial}{\\partial x} ( u^{n}(d_i^{(k)}) )$ 被解释为将导数算子应用于在网格点 $x_i$ 上定义的插值场。\n    d. **速度更新**：一旦找到 $p^{(k+1)}$，使用离散化的动量方程更新速度场 $u^{(k+1)}$：\n    $$\n    u^{(k+1)}(x_i) = u^{n}(d_i^{(k)}) - \\frac{\\Delta t}{\\rho_0}\\frac{\\partial p^{(k+1)}}{\\partial x}\n    $$\n\n3.  **收敛性**：当连续迭代之间的变化足够小时，迭代终止。我们定义更新范数 $\\Delta^{(k)} = \\max\\left(\\|\\delta u^{(k)}\\|_{\\infty}, \\|\\delta p^{(k)}\\|_{\\infty}\\right)$，其中 $\\delta u^{(k)} = u^{(k+1)} - u^{(k)}$ 和 $\\delta p^{(k)} = p^{(k+1)} - p^{(k)}$。当 $\\Delta^{(k)} \\le \\varepsilon_{\\mathrm{rel}} \\, \\Delta^{(1)}$ 或 $\\Delta^{(k)} \\le \\varepsilon_{\\mathrm{abs}}$ 时，或者在达到最大迭代次数 $k_{\\max}$ 后，循环终止。参考范数 $\\Delta^{(1)}$ 是第一次完整迭代的更新范数。\n\n**3. 数值实现细节**\n\n该算法在具有 $N$ 个点 $x_j = j \\Delta x$（$j=0, \\dots, N-1$）的均匀周期性网格上实现，其中 $\\Delta x = L/N$。\n\n- **谱导数**：对于周期函数 $f(x)$，其空间导数 $f'(x)$ 在傅里叶空间中计算。过程如下：\n    1. 计算场的离散傅里叶变换（DFT），$\\hat{f}_m = \\mathcal{F}[f](k_m)$。\n    2. 乘以谱导数算子 $i k_m$，其中 $k_m = 2\\pi m/L$ 是波数。\n    3. 计算结果的逆 DFT，$f'(x) = \\mathcal{F}^{-1}[i k_m \\hat{f}_m]$。\n    二阶导数 $\\partial^2/\\partial x^2$ 的计算方式类似，即傅里叶系数乘以 $(i k_m)^2 = -k_m^2$。\n\n- **傅里叶空间 Helmholtz 求解器**：Helmholtz 方程 $[I - \\gamma \\partial_{xx}] p = R$（其中 $\\gamma = c^2 (\\Delta t)^2$）在傅里叶空间中可以高效求解。应用 DFT 可得：\n$$\n(1 - \\gamma (-k_m^2)) \\hat{p}_m = \\hat{R}_m \\implies \\hat{p}_m = \\frac{\\hat{R}_m}{1 + \\gamma k_m^2}\n$$\n解 $p(x)$ 通过对计算出的 $\\hat{p}_m$ 应用逆 DFT 来恢复。\n\n- **周期性线性插值**：为了找到场 $f$ 在任意出发点 $d$ 的值，我们使用周期性线性插值。坐标 $d$ 首先通过模运算符映射到域 $[0, L)$ 中。然后将其归一化为网格单位，$d_{\\text{norm}} = d/\\Delta x$。该值在两个最近的网格点 $j_0 = \\lfloor d_{\\text{norm}} \\rfloor$ 和 $j_1 = (j_0+1) \\pmod N$ 之间进行插值：\n$$\nf(d) \\approx (1 - w) f(x_{j_0}) + w f(x_{j_1})\n$$\n其中 $w = d_{\\text{norm}} - j_0$ 是插值权重。此过程对所有出发点同时进行向量化处理。\n\n时间 $t^n$ 时的初始场根据问题说明进行设置：\n$$\nu^{n}(x) = U_0 \\sin\\left(\\frac{2\\pi M x}{L}\\right), \\quad p^{n}(x) = P_0 \\cos\\left(\\frac{2\\pi M x}{L}\\right)\n$$\n实现部分封装了这一逻辑，遍历所提供的测试用例，并报告每个用例达到收敛所需的 Picard 迭代次数。",
            "answer": "```python\nimport numpy as np\n\ndef run_single_case(N, L, c, rho0, dt, U0, P0, M, eps_rel, eps_abs, k_max):\n    \"\"\"\n    Runs a single test case for the semi-Lagrangian semi-implicit Picard iteration.\n    \n    Returns the number of iterations required for convergence.\n    \"\"\"\n    # 1. Grid setup\n    dx = L / N\n    x = np.arange(N) * dx\n    wavenumbers = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n\n    # 2. Initial conditions at time t^n\n    u_n = U0 * np.sin(2 * np.pi * M * x / L)\n    p_n = P0 * np.cos(2 * np.pi * M * x / L)\n\n    # 3. Utility functions\n    def spectral_derivative(field, k):\n        return np.fft.ifft(1j * k * np.fft.fft(field)).real\n\n    def periodic_linear_interp(field, coords, length):\n        num_points = len(field)\n        dx_val = length / num_points\n        norm_coords = (coords % length) / dx_val\n        i0 = np.floor(norm_coords).astype(int)\n        i1 = (i0 + 1) % num_points\n        w = norm_coords - i0\n        return (1.0 - w) * field[i0] + w * field[i1]\n        \n    def solve_helmholtz(rhs, gamma, k):\n        rhs_hat = np.fft.fft(rhs)\n        helmholtz_op_fourier = 1 + gamma * k**2\n        p_hat = rhs_hat / helmholtz_op_fourier\n        return np.fft.ifft(p_hat).real\n\n    # 4. Picard Iteration\n    # Initialize iterates for t^{n+1}, i.e., u^(0), p^(0)\n    u_k = u_n.copy()\n    p_k = p_n.copy()\n    \n    delta_ref = 0.0\n    gamma = c**2 * dt**2\n\n    for k_iter in range(1, k_max + 1):\n        # a. Update departure points using provisional wind u_k from previous iter\n        d_k = x - dt * u_k\n\n        # b. Interpolate source fields from time t^n\n        u_n_d = periodic_linear_interp(u_n, d_k, L)\n        p_n_d = periodic_linear_interp(p_n, d_k, L)\n\n        # c. Solve Helmholtz equation for p_kp1 = p^(k)\n        deriv_u_n_d = spectral_derivative(u_n_d, wavenumbers)\n        rhs_helmholtz = p_n_d - rho0 * c**2 * dt * deriv_u_n_d\n        p_kp1 = solve_helmholtz(rhs_helmholtz, gamma, wavenumbers)\n        \n        # d. Update velocity u_kp1 = u^(k)\n        deriv_p_kp1 = spectral_derivative(p_kp1, wavenumbers)\n        u_kp1 = u_n_d - (dt / rho0) * deriv_p_kp1\n\n        # e. Assess convergence\n        delta_u_norm = np.max(np.abs(u_kp1 - u_k))\n        delta_p_norm = np.max(np.abs(p_kp1 - p_k))\n        delta_k_norm = max(delta_u_norm, delta_p_norm)\n\n        if k_iter == 1:\n            delta_ref = delta_k_norm\n            if delta_ref = eps_abs:\n                return k_iter\n        else:\n            if delta_k_norm = eps_rel * delta_ref or delta_k_norm = eps_abs:\n                return k_iter\n        \n        # f. Update provisional fields for next iteration\n        u_k = u_kp1\n        p_k = p_kp1\n\n    return k_max\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1: (N, L, c, rho0, dt, U0, P0, M)\n        (256, 1.0, 340.0, 1.0, 0.001, 10.0, 100.0, 1),\n        # Case 2:\n        (256, 1.0, 340.0, 1.0, 0.01, 10.0, 100.0, 2),\n        # Case 3:\n        (256, 1.0, 340.0, 1.0, 0.005, 0.0, 100.0, 3),\n    ]\n\n    tolerances = {\n        'eps_rel': 1e-6,\n        'eps_abs': 1e-10,\n        'k_max': 50\n    }\n    \n    results = []\n    for params in test_cases:\n        N, L, c, rho0, dt, U0, P0, M = params\n        n_iters = run_single_case(\n            N, L, c, rho0, dt, U0, P0, M, **tolerances\n        )\n        results.append(n_iters)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}