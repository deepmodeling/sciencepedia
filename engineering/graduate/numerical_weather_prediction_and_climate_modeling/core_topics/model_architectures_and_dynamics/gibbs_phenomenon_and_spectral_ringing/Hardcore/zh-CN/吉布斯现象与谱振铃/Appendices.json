{
    "hands_on_practices": [
        {
            "introduction": "为了在数值模型中研究和减轻吉布斯振荡这样的数值伪影，我们首先需要一种稳健的方法来量化它。这个练习将挑战你从第一性原理出发，开发一个诊断工具，用于衡量急剧梯度附近吉布斯振荡的“能量”。通过构建这个诊断量，你将能够客观地评估谱截断和滤波方案对模型场中振铃现象的影响。",
            "id": "4049063",
            "problem": "考虑一个长度为 $L$（单位为米）的一维周期性域，该域被均匀离散为 $N$ 个网格点，网格间距为 $dx = L/N$。设一个单位为开尔文的标量预报场 $f(x)$ 在此网格上采样为 $\\{ f_n \\}_{n=0}^{N-1}$，其中 $f_n = f(x_n)$ 且 $x_n = n \\, dx$。在谱表示中，当谱被截断时，Gibbs 现象会在不连续点附近产生振荡性的过冲和下冲。本任务是定义并实现一个诊断量，通过测量检测到的梯度最大值周围的局部振荡能量来量化 Gibbs 振荡，然后为由谱截断数据重建的合成阶跃场计算该诊断量的值。\n\n您必须使用以下第一性原理推导该诊断量：\n- 周期性、均匀间隔网格上的离散傅里叶变换 (DFT) 及其逆变换的定义。\n- 高频模式截断与尖锐梯度附近振荡伪影之间的关系。\n- 网格上差分和梯度的离散微积分定义。\n\n按如下方式定义合成阶跃场。对于给定的振幅 $A$（单位为开尔文），选择索引 $n_0 = \\lfloor N/2 \\rfloor$ 并设置\n$$\nf_n = \\begin{cases}\n0  \\text{for } n < n_0, \\\\\nA  \\text{for } n \\ge n_0.\n\\end{cases}\n$$\n从 $f_n$ 出发，通过计算 $f_n$ 的 DFT 并将波数索引严格大于指定截止值 $K_{\\mathrm{cut}}$ 的所有模式置零，来构造一个谱截断重构 $g_n$。对于实值数据，您可以使用实值快速傅里叶变换 (FFT) 的实现，但数学要求是在进行逆变换以获得 $g_n$ 之前，仅保留非负波数索引 $k \\in \\{0,1,2,\\dots, K_{\\mathrm{cut}}\\}$ 并将所有更高的索引置零。\n\n在重构场 $g_n$ 上，计算中心离散梯度\n$$\n(\\nabla g)_n = \\frac{g_{n+1} - g_{n-1}}{2 \\, dx},\n$$\n并使用周期性索引。将梯度最大值的位置集合 $\\mathcal{I}$ 定义为 $(\\nabla g)_n$ 的量值是局部最大值，且其量值超过场中最大梯度量值的一个分数 $\\gamma$ 的条件：\n$$\n\\mathcal{I} = \\left\\{ n \\in \\{0,\\dots,N-1\\} \\;\\middle|\\; \\left|(\\nabla g)_n\\right| \\ge \\left|(\\nabla g)_{n-1}\\right|, \\; \\left|(\\nabla g)_n\\right| \\ge \\left|(\\nabla g)_{n+1}\\right|, \\; \\left|(\\nabla g)_n\\right| \\ge \\gamma \\, \\max_m \\left|(\\nabla g)_m\\right| \\right\\}.\n$$\n\n对于每个 $i \\in \\mathcal{I}$，定义一个半径为 $r$ 个网格点的邻域，\n$$\n\\mathcal{S}_i = \\{ n \\;\\mid\\; \\text{$n$ 在周期性环绕下与 $i$ 的索引距离在 $r$ 以内} \\},\n$$\n并在此邻域内计算一个用于分离振荡波纹的局部振荡能量。使用一阶差分\n$$\n\\delta_n = g_n - g_{n-1},\n$$\n和二阶差分\n$$\n\\Delta^2 g_n = g_{n+1} - 2 g_n + g_{n-1}.\n$$\n通过下式定义索引 $n$ 处的振荡指示器\n$$\ns_n = \\begin{cases}\n1  \\text{if } \\delta_n \\cdot \\delta_{n+1} < 0, \\\\\n0  \\text{otherwise},\n\\end{cases}\n$$\n它会标记连续一阶差分的局部符号变化（即一个过冲后跟一个下冲，反之亦然）。$i$ 周围的局部振荡能量则为\n$$\nE_i = \\sum_{n \\in \\mathcal{S}_i} \\left( \\Delta^2 g_n \\right)^2 \\, s_n,\n$$\n单位为开尔文的平方。将总的 Gibbs 振荡诊断量定义为\n$$\nD = \\sum_{i \\in \\mathcal{I}} E_i,\n$$\n以开尔文的平方报告。\n\n实现一个程序，该程序：\n- 为指定的 $(N, L, A)$ 构造合成阶跃场。\n- 使用 Nyquist 波数的指定分数 $s$ 执行谱截断，意味着 $K_{\\mathrm{cut}} = \\lfloor s \\cdot (N/2) \\rfloor$ 且重构保留非负波数 $k \\le K_{\\mathrm{cut}}$。\n- 使用上述定义以及梯度最大值阈值分数 $\\gamma$ 和邻域半径 $r$ 计算诊断量 $D$。\n\n所有输出均以开尔文的平方（$\\mathrm{K}^2$）为单位。本问题不涉及角度。程序必须生成单行输出，包含一个用方括号括起来的逗号分隔列表，每个测试用例对应一个浮点数。\n\n使用以下参数集测试套件来检验算法，涵盖典型波纹、重度截断、无截断、恒定场边缘情况以及小网格边界情况：\n- 测试 1：$N = 256$，$L = 1.0$ 米，$A = 1.0$ 开尔文，$s = 0.20$，$\\gamma = 0.50$，$r = 10$。\n- 测试 2：$N = 256$，$L = 1.0$ 米，$A = 1.0$ 开尔文，$s = 0.05$，$\\gamma = 0.50$，$r = 10$。\n- 测试 3：$N = 256$，$L = 1.0$ 米，$A = 1.0$ 开尔文，$s = 1.00$，$\\gamma = 0.50$，$r = 10$。\n- 测试 4：$N = 256$，$L = 1.0$ 米，$A = 0.0$ 开尔文，$s = 0.20$，$\\gamma = 0.50$，$r = 10$。\n- 测试 5：$N = 33$，$L = 1.0$ 米，$A = 1.0$ 开尔文，$s = 0.20$，$\\gamma = 0.80$，$r = 1$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[d_1,d_2,d_3,d_4,d_5]$），其中每个 $d_j$ 是为相应测试用例计算的诊断量 $D$。",
            "solution": "该问题要求定义并实现一个诊断量 $D$，用以量化谱截断场中的 Gibbs 振荡。推导和实现过程基于数值分析、傅里叶分析和离散微积分的基本原理。\n\n首先，我们建立域和初始场。物理域是一维周期性的，长度为 $L$。它被离散为 $N$ 个均匀间隔的网格点 $\\{x_n\\}_{n=0}^{N-1}$，网格间距为 $dx = L/N$，其中 $x_n = n \\, dx$。在此网格上，我们定义一个振幅为 $A$（单位为开尔文）的合成阶跃场 $f_n$。不连续点放置在网格索引 $n_0 = \\lfloor N/2 \\rfloor$ 处：\n$$\nf_n = \\begin{cases}\n0  \\text{for } n < n_0, \\\\\nA  \\text{for } n \\ge n_0.\n\\end{cases}\n$$\n该场 $f_n$ 代表了一个理想化的尖锐梯度，当其谱表示被截断时，容易产生 Gibbs 振荡。\n\nGibbs 现象的核心在于使用截断的傅里叶级数来近似一个不连续函数。为模拟此现象，我们对场 $f_n$ 执行谱截断。我们首先计算其离散傅里叶变换 (DFT)，它将函数分解为不同波数的复正弦波之和。DFT 系数（或称谱）$\\hat{f}_k$ 由下式给出：\n$$\n\\hat{f}_k = \\sum_{n=0}^{N-1} f_n \\, e^{-2\\pi i k n / N} \\quad \\text{for } k = 0, 1, \\dots, N-1.\n$$\n由于输入场 $f_n$ 是实值的，其谱表现出共轭对称性 $\\hat{f}_{N-k} = \\overline{\\hat{f}_k}$。此性质允许使用实数快速傅里叶变换 (RFFT) 算法，该算法计算效率更高，因为它只计算非负波数的唯一谱系数，通常是 $k=0, 1, \\dots, \\lfloor N/2 \\rfloor$。\n\n谱截断涉及通过将 $\\hat{f}_k$ 的高波数系数置零来创建一个新的谱 $\\hat{g}_k$。问题指定了一个截止波数索引 $K_{\\mathrm{cut}} = \\lfloor s \\cdot (N/2) \\rfloor$，其中 $s$ 是给定的截断分数。截断谱 $\\hat{g}_k$ 定义为：\n$$\n\\hat{g}_k = \\begin{cases}\n\\hat{f}_k  \\text{for non-negative } k \\le K_{\\mathrm{cut}}, \\\\\n0        \\text{for non-negative } k > K_{\\mathrm{cut}}.\n\\end{cases}\n$$\n当使用完整的复数 DFT 时，必须对负波数进行镜像截断，以确保结果场是实数。当使用 RFFT 时，这对应于在输出数组中将索引大于 $K_{\\mathrm{cut}}$ 的系数置零。然后，通过对截断谱 $\\hat{g}_k$ 应用逆 DFT（或逆 RFFT）获得重构场 $g_n$：\n$$\ng_n = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{g}_k \\, e^{2\\pi i k n / N}.\n$$\n该场 $g_n$ 是 $f_n$ 的一个平滑近似，并将在不连续点 $n_0$ 附近表现出 Gibbs 现象特有的振荡性过冲和下冲。\n\n接下来，我们构建诊断量 $D$ 来量化这些振荡。该诊断量旨在专门测量尖锐梯度附近的振荡能量。我们首先通过计算重构场 $g_n$ 的中心离散梯度来定位这些区域：\n$$\n(\\nabla g)_n = \\frac{g_{n+1} - g_{n-1}}{2 \\, dx}.\n$$\n索引 $n-1$ 和 $n+1$ 使用周期性边界条件处理，即 $g_{-1} = g_{N-1}$ 和 $g_N = g_0$。然后，我们识别出对应于梯度量值为局部最大值且相对于场中整体最大梯度而言是显著的索引集合 $\\mathcal{I}$：\n$$\n\\mathcal{I} = \\left\\{ n \\in \\{0,\\dots,N-1\\} \\;\\middle|\\; \\left|(\\nabla g)_n\\right| \\ge \\left|(\\nabla g)_{n-1}\\right|, \\; \\left|(\\nabla g)_n\\right| \\ge \\left|(\\nabla g)_{n+1}\\right|, \\; \\left|(\\nabla g)_n\\right| \\ge \\gamma \\, \\max_m \\left|(\\nabla g)_m\\right| \\right\\}.\n$$\n这里，$\\gamma$ 是一个指定的阈值分数。该定义有效地确定了 Gibbs 振荡的中心位置。\n\n对于每个已识别的梯度峰值 $i \\in \\mathcal{I}$，我们定义一个半径为 $r$ 个网格点的局部邻域 $\\mathcal{S}_i$：\n$$\n\\mathcal{S}_i = \\{ n \\;\\mid\\; (n - i) \\pmod N \\text{ is in } [-r, r] \\}.\n$$\n该集合包含以 $i$ 为中心的 $2r+1$ 个网格点，并在域边界处进行周期性环绕。\n\n在这些邻域内，我们测量振荡内容。该诊断量使用两个关键的离散差分算子。一阶差分，\n$$\n\\delta_n = g_n - g_{n-1},\n$$\n近似局部斜率。斜率符号的变化表示一个极值点（振荡的波峰或波谷）。这由振荡指示器 $s_n$ 捕获：\n$$\ns_n = \\begin{cases}\n1  \\text{if } \\delta_n \\cdot \\delta_{n+1} < 0, \\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\n该指示器 $s_n$ 仅在代表局部极值点的网格点上非零。振荡的幅度使用二阶差分进行量化，它近似场的曲率：\n$$\n\\Delta^2 g_n = g_{n+1} - 2 g_n + g_{n-1}.\n$$\n每个梯度峰值 $i$ 的局部振荡能量 $E_i$ 定义为在邻域 $\\mathcal{S}_i$ 内，由振荡指示器 $s_n$ 加权的二阶差分平方之和：\n$$\nE_i = \\sum_{n \\in \\mathcal{S}_i} \\left( \\Delta^2 g_n \\right)^2 \\, s_n.\n$$\n$E_i$ 的单位是开尔文的平方（$\\mathrm{K}^2$）。该度量仅在高梯度区域内的振荡点上对“摆动程度”（曲率的平方）进行求和。\n\n最后，总的 Gibbs 振荡诊断量 $D$ 是在所有已识别的高梯度区域上的局部振荡能量之和：\n$$\nD = \\sum_{i \\in \\mathcal{I}} E_i.\n$$\n更大的 $D$ 值表示场中更显著的 Gibbs 振荡。\n\n计算算法如下：\n1. 对于给定的参数集 $(N, L, A, s, \\gamma, r)$，构造初始阶跃场 $f_n$。\n2. 计算 $f_n$ 的 RFFT 以获得谱 $\\hat{f}_{\\mathrm{rfft}}$。\n3. 确定截止索引 $K_{\\mathrm{cut}} = \\lfloor s \\cdot (N/2) \\rfloor$。\n4. 通过将 $\\hat{f}_{\\mathrm{rfft}}$ 中索引大于 $K_{\\mathrm{cut}}$ 的所有元素置零来创建截断谱 $\\hat{g}_{\\mathrm{rfft}}$。\n5. 通过 $\\hat{g}_{\\mathrm{rfft}}$ 的逆 RFFT 计算重构场 $g_n$。\n6. 使用周期性边界计算离散梯度 $(\\nabla g)_n$。\n7. 基于局部最大值和阈值条件识别梯度最大值索引集 $\\mathcal{I}$。如果该集合为空，则 $D=0$。\n8. 对于每个索引 $i \\in \\mathcal{I}$，通过在邻域 $\\mathcal{S}_i$ 上对 $(\\Delta^2 g_n)^2 s_n$ 求和来计算局部振荡能量 $E_i$。\n9. 将所有 $E_i$ 求和得到最终诊断量 $D$。\n将此过程应用于每个测试用例以生成所需的结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    test_cases = [\n        # (N, L, A, s, gamma, r)\n        (256, 1.0, 1.0, 0.20, 0.50, 10),  # Test 1: Typical ringing\n        (256, 1.0, 1.0, 0.05, 0.50, 10),  # Test 2: Heavy truncation\n        (256, 1.0, 1.0, 1.00, 0.50, 10),  # Test 3: No truncation\n        (256, 1.0, 0.0, 0.20, 0.50, 10),  # Test 4: Constant field\n        (33, 1.0, 1.0, 0.20, 0.80, 1),   # Test 5: Small-grid boundary case\n    ]\n\n    results = []\n    for case in test_cases:\n        diagnostic = compute_diagnostic(*case)\n        results.append(diagnostic)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_diagnostic(N, L, A, s, gamma, r):\n    \"\"\"\n    Computes the Gibbs oscillation diagnostic D for a given set of parameters.\n\n    Args:\n        N (int): Number of grid points.\n        L (float): Length of the periodic domain in meters.\n        A (float): Amplitude of the step field in Kelvin.\n        s (float): Truncation fraction of the Nyquist wavenumber.\n        gamma (float): Gradient-maxima threshold fraction.\n        r (int): Neighborhood radius in grid points.\n\n    Returns:\n        float: The computed diagnostic D in Kelvin^2.\n    \"\"\"\n    # 1. Grid and Initial Field Setup\n    dx = L / N\n    n_0 = int(np.floor(N / 2))\n    \n    f_n = np.zeros(N)\n    if A != 0:\n        f_n[n_0:] = A\n\n    # 2. Spectral Truncation\n    # Using scipy.fft which is a newer and recommended API over numpy.fft\n    f_hat = fft.rfft(f_n)\n    K_cut = int(np.floor(s * (N / 2)))\n    \n    g_hat = f_hat.copy()\n    # Zero out modes with wavenumber index > K_cut\n    g_hat[K_cut + 1:] = 0\n    \n    g_n = fft.irfft(g_hat, n=N)\n\n    # 3. Compute Centered Discrete Gradient\n    g_plus_1 = np.roll(g_n, -1)\n    g_minus_1 = np.roll(g_n, 1)\n    grad_g = (g_plus_1 - g_minus_1) / (2 * dx)\n\n    # 4. Identify Gradient Maxima Locations\n    abs_grad_g = np.abs(grad_g)\n    max_grad_mag = np.max(abs_grad_g)\n\n    # Handle edge case of a constant field (e.g., A=0)\n    if max_grad_mag == 0:\n        return 0.0\n\n    grad_mag_plus_1 = np.roll(abs_grad_g, -1)\n    grad_mag_minus_1 = np.roll(abs_grad_g, 1)\n\n    is_local_max = (abs_grad_g >= grad_mag_minus_1) & (abs_grad_g >= grad_mag_plus_1)\n    is_above_thresh = (abs_grad_g >= gamma * max_grad_mag)\n    \n    I_indices = np.where(is_local_max & is_above_thresh)[0]\n    \n    if len(I_indices) == 0:\n        return 0.0\n\n    # 5. Compute Oscillation Indicator and Second Difference\n    # First difference: delta_n = g_n - g_{n-1}\n    delta_g = g_n - g_minus_1\n    # First difference at n+1: delta_{n+1}\n    delta_g_plus_1 = np.roll(delta_g, -1)\n    \n    # Oscillation indicator: s_n = 1 if delta_n * delta_{n+1} < 0\n    s_n = (delta_g * delta_g_plus_1) < 0\n\n    # Second difference: Delta^2 g_n = g_{n+1} - 2*g_n + g_{n-1}\n    delta2_g = g_plus_1 - 2 * g_n + g_minus_1\n    \n    # Term to be summed: (Delta^2 g_n)^2 * s_n\n    summand = (delta2_g ** 2) * s_n.astype(int)\n\n    # 6. Compute Total Diagnostic D\n    total_D = 0.0\n    for i in I_indices:\n        # Define neighborhood S_i: indices from i-r to i+r (periodic)\n        neighborhood_indices = (np.arange(i - r, i + r + 1)) % N\n        \n        # Compute local energy E_i\n        E_i = np.sum(summand[neighborhood_indices])\n        total_D += E_i\n        \n    return total_D\n\nsolve()\n```"
        },
        {
            "introduction": "在能够量化振铃之后，下一步自然是探索如何减轻它。本练习将吉布斯现象的概念应用到一个物理上真实的斜压急流模型中，并引入一种在数值天气预报中至关重要的技术——超扩散。你的任务是量化一个核心权衡：在抑制数值噪音和保留对天气和气候至关重要的物理梯度保真度之间的平衡。",
            "id": "4049043",
            "problem": "考虑一个理想化斜压急流的周期性经向切片，该切片由定义域 $y \\in [0, 2\\pi)$ 上的纬向风速场 $u(y)$ 表示，其中 $y$ 以弧度为单位。该急流有一个风速近乎恒定的平台区，两侧是两个陡峭的锋面。本练习旨在演示由傅里叶截断引起的谱振铃（吉布斯现象）如何通过超扩散得到缓解，并在一个与数值天气预报和气候模拟实践相一致的受控数值实验中，量化振铃缓解与梯度保真度之间的权衡。\n\n从以下基本依据出发：\n\n- 离散傅里叶变换 (DFT) 及其逆变换提供了周期函数与其谱系数之间的双射变换。DFT 将空间变化映射到波数空间，并通过与波数相乘来支持精确微分。\n- 快速傅里叶变换 (FFT) 是一种高效计算 DFT 的算法。\n- 谱大气模式可以理想化为使用截断的傅里叶表示，仅保留波数 $|k| \\le k_c$，这会因吉布斯现象而在陡峭梯度附近引入谱振铃。\n- 超扩散在连续时间内由线性偏微分方程 $u_t = -\\nu \\left(-\\partial_y^2\\right)^p u$ 建模，其中超扩散阶数 $p \\in \\mathbb{N}$，系数 $\\nu > 0$。该算子优先衰减高波数分量以缓解振铃。\n\n使用以下公式在 $N$ 个等距点上定义理想化急流廓线：\n$$\nu_{\\text{true}}(y) = \\frac{U_0}{2}\\left[1+\\tanh\\left(\\frac{y-y_1}{w}\\right)\\right] - \\frac{U_0}{2}\\left[1+\\tanh\\left(\\frac{y-y_2}{w}\\right)\\right],\n$$\n其中 $U_0$ 是急流平台区速度（单位：米/秒），$y_1 = y_0 - \\Delta$，$y_2 = y_0 + \\Delta$，$y_0=\\pi$，$\\Delta$ 是急流的半宽（单位：弧度），$w$ 是决定锋面陡峭度的陡峭度参数（单位：弧度）。离散网格为 $y_j = 2\\pi j/N$，其中 $j=0,\\dots,N-1$。\n\n设 $\\widehat{u}(k)$ 表示该网格上 $u(y)$ 的 DFT，波数 $k$ 表示为与 $2\\pi$ 周期性一致的整数倍。截断谱表示将 $|k|>k_c$ 的谱系数设为 $\\widehat{u}(k)=0$，其中 $k_c$ 是分辨率截断波数。超扩散应根据上述连续时间模型，在谱空间中对截断表示作用一个单位无量纲时间步长，这可解释为对保留模态的谱阻尼。您不得使用本问题中陈述的任何公式来绕过推导；所有步骤必须从给定的基本依据逻辑推导得出。\n\n定义两个定量指标：\n\n1. 振铃振幅 $R$：重建场在物理上合理的范围 $\\left[0, U_0\\right]$ 之外的最大偏移，并用 $U_0$ 进行归一化，\n$$\nR = \\frac{1}{U_0}\\max\\left\\{\\max_{y}\\left(u(y)-U_0\\right)_+, \\max_{y}\\left(-u(y)\\right)_+\\right\\},\n$$\n其中 $(x)_+ = \\max(x,0)$，$u(y)$ 是经过截断和超扩散后的重建场。该指标是无量纲的。\n\n2. 梯度保真度误差 $E$：经向梯度的相对 $\\ell^2$ 误差（与真实场相比），\n$$\nE = \\frac{\\left\\|\\partial_y u(y) - \\partial_y u_{\\text{true}}(y)\\right\\|_2}{\\left\\|\\partial_y u_{\\text{true}}(y)\\right\\|_2},\n$$\n其中导数在谱空间中计算，$\\ell^2$ 范数在离散网格上计算。该指标是无量纲的。\n\n您的程序必须：\n\n- 使用以下参数在周期性网格上构建 $u_{\\text{true}}(y)$。\n- 计算其 DFT，在 $|k| \\le k_c$ 处执行截断，然后根据 $u_t = -\\nu \\left(-\\partial_y^2\\right)^p u$ 在谱空间中应用超扩散，作用一个单位无量纲时间步长。\n- 通过逆 DFT 重建场，并计算如上定义的 $R$ 和 $E$。\n\n使用以下科学上真实的参数值创建一个测试套件，以检验这种权衡关系：\n\n- 网格大小：$N = 2048$。\n- 平台区速度：$U_0 = 40$ 米/秒。\n- 急流参数：$\\Delta = 0.7$ 弧度，$w = 0.02$ 弧度，$y_0 = \\pi$。\n- 谱截断波数：$k_c = 128$。\n- 超扩散测试案例，表示为数对 $(\\alpha, p)$，其中 $\\alpha$ 是无量纲强度参数，$p$ 是超扩散阶数：\n  1. 案例 1（边界情况，无超扩散）：$(\\alpha, p) = (0.0, 4)$。\n  2. 案例 2（中等缓解）：$(\\alpha, p) = (0.4, 4)$。\n  3. 案例 3（强超扩散）：$(\\alpha, p) = (3.0, 4)$。\n  4. 案例 4（高阶超扩散）：$(\\alpha, p) = (1.0, 8)$。\n\n所有角度必须以弧度为单位。所有速度单位为米/秒，但输出是无量纲的，不需要单位换算。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$$\n\\left[R_1, E_1, R_2, E_2, R_3, E_3, R_4, E_4\\right],\n$$\n其中 $R_i$ 和 $E_i$ 对应于案例 $i$。\n\n程序必须是完整且可直接运行的，无需用户输入，且只能使用 Python 标准库和指定的数值库。输出值必须为 $\\text{float}$ 类型。设计应确保科学真实性和内部一致性，并且每个测试案例都必须产生确定性的数值结果。",
            "solution": "该问题要求通过数值模拟来量化在理想化大气急流的谱模式中使用超扩散时，在缓解谱振铃（吉布斯现象）和保持梯度保真度之间的权衡。解决方案包括对急流廓线进行离散化，使用快速傅里叶变换 (FFT) 将其转换到谱空间，应用谱截断和超扩散算子，再转换回物理空间，最后计算两个指定的指标：振铃振幅 $R$ 和梯度保真度误差 $E$。\n\n首先，我们建立计算域和真实状态。理想化急流廓线 $u_{\\text{true}}(y)$ 定义在周期性定义域 $y \\in [0, 2\\pi)$ 上。我们使用 $N=2048$ 个等距点 $y_j = 2\\pi j/N$（其中 $j = 0, \\dots, N-1$）对该定义域进行离散化。该网格上的真实速度场使用给定公式计算：\n$$\nu_{\\text{true}}(y_j) = \\frac{U_0}{2}\\left[1+\\tanh\\left(\\frac{y_j-y_1}{w}\\right)\\right] - \\frac{U_0}{2}\\left[1+\\tanh\\left(\\frac{y_j-y_2}{w}\\right)\\right]\n$$\n参数为 $U_0=40$，$y_0=\\pi$，$\\Delta=0.7$，$w=0.02$，$y_1=y_0-\\Delta$，$y_2=y_0+\\Delta$。陡峭度参数 $w$ 很小，这会产生陡峭的梯度，在谱截断时将引发强烈的吉布斯振铃。\n\n该方法的核心在于谱空间。我们使用通过 FFT 算法计算的离散傅里叶变换 (DFT) 来获得离散场 $u_{\\text{true}}(y_j)$ 的谱系数 $\\widehat{u}_{\\text{true}}(k)$。对于 $2\\pi$ 域上的 $N$ 点网格，可以获得相应的整数波数 $k$。物理空间中的微分算子 $\\partial_y$ 对应于谱空间中乘以 $ik$，其中 $i = \\sqrt{-1}$。此性质用于计算所有空间导数。\n\n每个测试案例 $(\\alpha, p)$ 的数值模拟遵循一个精确的步骤序列：\n\n1.  **谱截断**：通过将波数绝对值 $|k|$ 超过截断波数 $k_c=128$ 的所有系数置零，来截断真实谱 $\\widehat{u}_{\\text{true}}(k)$。这模拟了一个有限分辨率的谱模式。设得到的截断谱为 $\\widehat{u}_{\\text{trunc}}(k)$：\n    $$\n    \\widehat{u}_{\\text{trunc}}(k) = \\begin{cases} \\widehat{u}_{\\text{true}}(k)  \\text{if } |k| \\le k_c \\\\ 0  \\text{if } |k| > k_c \\end{cases}\n    $$\n    这种突兀的截断是吉布斯现象的根源。案例 1 中没有超扩散（$\\alpha=0$），它单独分离出截断本身的影响。\n\n2.  **超扩散阻尼**：将超扩散应用于截断谱，以阻尼高波数振荡。其控制连续方程为 $u_t = -\\nu(-\\partial_y^2)^p u$。在谱空间中，这成为每个谱系数 $\\widehat{u}(k)$ 的常微分方程：\n    $$\n    \\frac{d\\widehat{u}(k, t)}{dt} = -\\nu (k^2)^p \\widehat{u}(k, t) = -\\nu k^{2p} \\widehat{u}(k, t)\n    $$\n    在一个单位无量纲时间步长（$t=1$）内的解为 $\\widehat{u}(k, 1) = \\widehat{u}(k, 0) \\exp(-\\nu k^{2p})$。问题提供的是无量纲强度参数 $\\alpha$ 而不是系数 $\\nu$。遵循数值天气预报的标准实践，我们将 $\\alpha$ 与截断波数 $k_c$ 处的阻尼强度相关联。我们将 $|k|=k_c$ 处阻尼因子的指数设为 $-\\alpha$。这得出了关系式 $\\nu k_c^{2p} = \\alpha$，因此 $\\nu = \\alpha/k_c^{2p}$。因此，应用于任何保留模态（$|k| \\le k_c$）的阻尼因子 $D(k)$ 为：\n    $$\n    D(k) = \\exp\\left(-\\frac{\\alpha}{k_c^{2p}} k^{2p}\\right) = \\exp\\left[-\\alpha \\left(\\frac{|k|}{k_c}\\right)^{2p}\\right]\n    $$\n    将该因子乘以截断谱系数，得到最终谱 $\\widehat{u}_{\\text{final}}(k) = \\widehat{u}_{\\text{trunc}}(k) D(k)$。当 $\\alpha=0$ 时，$D(k)=1$，对应于无扩散。\n\n3.  **重建**：通过对 $\\widehat{u}_{\\text{final}}(k)$ 应用逆 DFT（通过 IFFT 算法）来重建最终物理场 $u(y)$。由于初始场是实数，我们取结果的实部，以舍弃由浮点误差产生的微小虚部。\n\n对于给定的测试案例，在获得最终场 $u(y)$ 后，我们计算两个指标：\n\n1.  **振铃振幅 ($R$)**：该指标量化了非物理振荡。它是计算场 $u(y)$ 在物理预期范围 $[0, U_0]$ 之外的最大偏差，并用急流速度 $U_0$ 进行归一化。在离散网格上，其计算方式如下：\n    $$\n    R = \\frac{1}{U_0} \\max\\left\\{ \\max_j\\left( \\max(u(y_j)-U_0, 0) \\right), \\max_j\\left( \\max(-u(y_j), 0) \\right) \\right\\}\n    $$\n\n2.  **梯度保真度误差 ($E$)**：该指标衡量了物理上重要的陡峭锋面的退化程度。它是最终场的梯度相对于真实场梯度的相对 $\\ell^2$ 误差。为保证一致性和准确性，两个梯度都在谱空间中计算。真实场的梯度 $\\partial_y u_{\\text{true}}(y)$ 是通过对 $ik\\widehat{u}_{\\text{true}}(k)$ 进行逆 DFT 得到的。类似地，最终场的梯度 $\\partial_y u(y)$ 是对 $ik\\widehat{u}_{\\text{final}}(k)$ 进行逆 DFT 的结果。于是，误差 $E$ 为：\n    $$\n    E = \\frac{\\sqrt{\\sum_{j=0}^{N-1} |\\partial_y u(y_j) - \\partial_y u_{\\text{true}}(y_j)|^2}}{\\sqrt{\\sum_{j=0}^{N-1} |\\partial_y u_{\\text{true}}(y_j)|^2}} = \\frac{\\|\\partial_y u - \\partial_y u_{\\text{true}}\\|_2}{\\|\\partial_y u_{\\text{true}}\\|_2}\n    $$\n分母 $\\|\\partial_y u_{\\text{true}}\\|_2$ 从完整的、未截断的真实谱计算一次，作为恒定的参考基准。分子则对每个测试案例分别计算。此过程被系统地应用于所有四个测试案例，以生成所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes ringing and gradient error metrics for a spectral model\n    of an idealized jet with hyperdiffusion.\n    \"\"\"\n    # Define physical and numerical parameters\n    N = 2048\n    U0 = 40.0\n    delta = 0.7\n    w = 0.02\n    y0 = np.pi\n    kc = 128\n\n    # Define the hyperdiffusion test cases (alpha, p)\n    test_cases = [\n        (0.0, 4),  # Case 1: No hyperdiffusion\n        (0.4, 4),  # Case 2: Moderate hyperdiffusion\n        (3.0, 4),  # Case 3: Strong hyperdiffusion\n        (1.0, 8),  # Case 4: High-order hyperdiffusion\n    ]\n\n    # Create the spatial grid\n    y = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n    # Define the true jet profile\n    y1 = y0 - delta\n    y2 = y0 + delta\n    u_true = (U0 / 2.0) * (1.0 + np.tanh((y - y1) / w)) - \\\n             (U0 / 2.0) * (1.0 + np.tanh((y - y2) / w))\n\n    # Compute spectral representation of the true field and its gradient\n    # Wavenumbers k for a 2*pi periodic domain\n    k = np.fft.fftfreq(N) * N\n    u_true_hat = np.fft.fft(u_true)\n\n    # Compute the true gradient spectrally for the error metric denominator\n    grad_u_true_hat = 1j * k * u_true_hat\n    grad_u_true = np.real(np.fft.ifft(grad_u_true_hat))\n    norm_grad_u_true = np.linalg.norm(grad_u_true)\n\n    results = []\n\n    # Process each test case\n    for alpha, p in test_cases:\n        # Step 1: Spectral Truncation\n        # Create a copy to modify\n        u_final_hat = u_true_hat.copy()\n        # Apply sharp cutoff by zeroing out coefficients where |k| > kc\n        u_final_hat[np.abs(k) > kc] = 0.0\n\n        # Step 2: Apply Hyperdiffusion\n        if alpha > 0.0:\n            # We only need to compute and apply damping to the retained modes |k| <= kc\n            # Find indices of modes to be damped\n            indices_to_damp = np.where(np.abs(k) <= kc)[0]\n            k_to_damp = k[indices_to_damp]\n\n            # Calculate damping factor for these modes\n            # ratios = |k|/kc\n            ratios = np.abs(k_to_damp) / kc\n            # D(k) = exp(-alpha * (|k|/kc)^(2p))\n            dampers = np.exp(-alpha * (ratios**(2 * p)))\n            \n            # Apply the damping factor to the truncated spectrum\n            u_final_hat[indices_to_damp] *= dampers\n\n        # Step 3: Reconstruct the physical field\n        u_final = np.real(np.fft.ifft(u_final_hat))\n\n        # --- Compute Metrics ---\n\n        # Metric 1: Ringing amplitude (R)\n        overshoot = np.maximum(u_final - U0, 0)\n        undershoot = np.maximum(-u_final, 0)\n        R = np.maximum(np.max(overshoot), np.max(undershoot)) / U0\n        results.append(R)\n\n        # Metric 2: Gradient fidelity error (E)\n        # Gradient of the final field is computed from its spectrum u_final_hat\n        grad_u_final_hat = 1j * k * u_final_hat\n        grad_u_final = np.real(np.fft.ifft(grad_u_final_hat))\n        \n        # Calculate L2 norm of the gradient difference\n        grad_diff = grad_u_final - grad_u_true\n        norm_grad_diff = np.linalg.norm(grad_diff)\n        \n        # Calculate relative error E\n        E = norm_grad_diff / norm_grad_u_true\n        results.append(E)\n\n    # Format and print final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将我们的分析从一维领域扩展到全球尺度的球体几何。在全球气候和天气模型中，物理场通常使用球谐函数来表示。这个最终的实践练习要求你设计一个谱滤波器，它不仅能减少像海岸线这样的特征周围的振铃，同时还要遵循一个基本的物理约束：总质量守恒。",
            "id": "4049060",
            "problem": "您的任务是设计并评估一个球面上的谱滤波器，该滤波器能减少全球场中的吉布斯现象（谱振铃），同时保持总质量守恒。背景为数值天气预报（NWP）和气候模拟，在这些领域中，全球场通常使用球谐函数在球面上表示。您的程序必须实现对一个具有类海岸线不连续性的合成全球场的自包含球谐分析与合成，应用一个保持质量守恒的高阶抑制滤波器，并量化振铃的减少程度。\n\n您必须从以下纯数学术语表述的基本原理开始：\n\n- 球谐函数 $Y_{\\ell}^{m}(\\theta,\\phi)$ 在单位球面上构成了相对于曲面元 $d\\Omega = \\sin\\theta\\, d\\theta\\, d\\phi$ 的一个标准正交基，其中 $\\theta \\in [0,\\pi]$ 是以弧度为单位的余纬，$\\phi \\in [0,2\\pi)$ 是以弧度为单位的经度。标准正交性意味着\n$$\n\\int_{0}^{\\pi}\\int_{0}^{2\\pi} Y_{\\ell}^{m}(\\theta,\\phi)\\, Y_{\\ell'}^{m'}(\\theta,\\phi)^*\\, \\sin\\theta\\, d\\theta\\, d\\phi \\;=\\; \\delta_{\\ell\\ell'}\\,\\delta_{mm'}.\n$$\n- 球面上的任何平方可积标量场 $f(\\theta,\\phi)$ 都可以展开为\n$$\nf(\\theta,\\phi) \\;=\\; \\sum_{\\ell=0}^{\\infty}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi),\n$$\n其球谐系数为\n$$\nc_{\\ell,m} \\;=\\; \\int_{0}^{\\pi}\\int_{0}^{2\\pi} f(\\theta,\\phi)\\, Y_{\\ell}^{m}(\\theta,\\phi)^*\\, \\sin\\theta\\, d\\theta\\, d\\phi.\n$$\n- 当通过截断谱展开来表示不连续函数时，会出现吉布斯现象；高阶模会在不连续点附近产生振荡过冲，这种过冲不会随着截断而消失，但可以通过对高阶模进行适当滤波来减轻。\n\n设计目标与约束：\n\n1. 提出一个作用于球谐系数 $c_{\\ell,m}$ 的滤波器，该滤波器能抑制高階模，同时保持总质量守恒。$f(\\theta,\\phi)$在单位球面上的总质量与0阶0次系数 $c_{0,0}$ 成正比，因为 $Y_{0}^{0}(\\theta,\\phi) = \\sqrt{1/(4\\pi)}$。您的滤波器必须满足 $G(0) = 1$，以使 $c_{0,0}$ 不被修改。\n2. 使用权重为 $w(\\theta,\\phi) = \\sin\\theta\\, \\Delta\\theta\\, \\Delta\\phi$ 的离散求积，在等距经纬度网格上实现数值球谐分析与合成。角度必须以弧度为单位。\n3. 通过定义一个陆海掩码 $f(\\theta,\\phi)$ 来构建一个具有类海岸线不连续性的合成全球气候场，该掩码在经度 $\\phi \\in [0,\\pi)$（“陆地”半球）上等于 $1$，在 $\\phi \\in [\\pi,2\\pi)$（“海洋”半球）上等于 $0$。该场在 $\\phi = \\pi$ 处呈现一条沿经线的海岸线。\n4. 通过计算一个狭窄海岸带内的最大边界违例来量化海岸线周围的振铃。该违例定义为在该带 {$(\\theta,\\phi): |\\phi-\\pi| \\le 3\\Delta\\phi$} 内，重构场高于 $1$ 的正过冲与低于 $0$ 的负下冲的绝对值中的最大值，其中 $\\Delta\\phi = 2\\pi/N_{\\text{lon}}$。该度量是一个非负浮点数。\n5. 通过计算绝对差 $|c_{0,0}^{\\text{filtered}} - c_{0,0}^{\\text{original}}|$ 来展示质量守恒。此量必须以浮点数形式报告，并且如果强制执行 $G(0)=1$，其数值应非常小（理想情况下为零）。\n\n您必须实现以下滤波器规格和重构协议：\n\n- 定义滤波器传递函数 $G(\\ell) = \\exp\\left(-\\alpha\\, \\ell(\\ell+1)\\right)$，其中无量纲参数 $\\alpha \\ge 0$。该函数满足 $G(0)=1$ 且随 $\\ell$ 单调递减，从而强力衰减高阶模，同时保持总质量不变。\n- 对于给定的截断阶数 $L_{\\text{trunc}}$，使用离散求积和计算 $0 \\le \\ell \\le L_{\\text{trunc}}$, $-\\ell \\le m \\le \\ell$ 的 $c_{\\ell,m}$\n$$\nc_{\\ell,m} \\;\\approx\\; \\sum_{i=1}^{N_{\\text{lat}}}\\sum_{j=1}^{N_{\\text{lon}}} f(\\theta_i,\\phi_j)\\, Y_{\\ell}^{m}(\\theta_i,\\phi_j)^*\\, \\sin\\theta_i\\, \\Delta\\theta\\, \\Delta\\phi,\n$$\n其中网格为 $\\theta_i = \\left(i+\\tfrac{1}{2}\\right)\\,\\Delta\\theta$（对于 $i = 0,\\ldots,N_{\\text{lat}}-1$）和 $\\phi_j = j\\, \\Delta\\phi$（对于 $j = 0,\\ldots,N_{\\text{lon}}-1$），且 $\\Delta\\theta = \\pi/N_{\\text{lat}}$，$\\Delta\\phi = 2\\pi/N_{\\text{lon}}$。\n- 重构基准截断场\n$$\n\\hat{f}_{\\text{base}}(\\theta,\\phi) \\;=\\; \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi),\n$$\n和滤波后的场\n$$\n\\hat{f}_{\\text{filt}}(\\theta,\\phi) \\;=\\; \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} \\left[G(\\ell)\\, c_{\\ell,m}\\right]\\, Y_{\\ell}^{m}(\\theta,\\phi).\n$$\n\n物理和数值单位：\n\n- 所有角度 $\\theta$ 和 $\\phi$ 必须以弧度为单位。\n- 场 $f(\\theta,\\phi)$ 是无量纲的。\n\n测试套件：\n\n使用 $N_{\\text{lat}} = 73$ 和 $N_{\\text{lon}} = 144$ 的等距网格。评估以下五个参数集，每个参数集由一对 $(L_{\\text{trunc}}, \\alpha)$ 定义：\n\n- 情况1：$(L_{\\text{trunc}}, \\alpha) = (20, 0.0)$，无滤波的基准情况。\n- 情况2：$(L_{\\text{trunc}}, \\alpha) = (20, 0.005)$，中度平滑。\n- 情况3：$(L_{\\text{trunc}}, \\alpha) = (20, 0.02)$，强平滑。\n- 情况4：$(L_{\\text{trunc}}, \\alpha) = (12, 0.02)$，较低截断并带平滑。\n- 情况5：$(L_{\\text{trunc}}, \\alpha) = (20, 2.0)$，极端平滑，近似于仅保留0阶模。\n\n对于每种情况，计算三个浮点数：\n- 使用相同的 $L_{\\text{trunc}}$ 但 $\\alpha = 0$（即无滤波）的基准边界违例振幅。\n- 使用指定的 $\\alpha$ 的滤波后边界违例振幅。\n- 绝对质量差 $|c_{0,0}^{\\text{filtered}} - c_{0,0}^{\\text{original}}|$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个逗号分隔列表的结果，该列表包含五个内部列表，每个内部列表的形式为 $[b,f,m]$，其中 $b$ 是基准边界违例振幅，$f$ 是滤波后边界违例振幅，$m$ 是绝对质量差。数字必须四舍五入到六位小数。最终打印的行不得包含空格，例如：\n\"[[b1,f1,m1],[b2,f2,m2],[b3,f3,m3],[b4,f4,m4],[b5,f5,m5]]\"。",
            "solution": "我们从球谐函数 $Y_{\\ell}^{m}(\\theta,\\phi)$ 在单位球面上相对于曲面元 $d\\Omega = \\sin\\theta\\, d\\theta\\, d\\phi$ 的标准正交性开始。对于任何平方可积场 $f(\\theta,\\phi)$，其球谐系数为\n$$\nc_{\\ell,m} = \\int_{0}^{\\pi}\\int_{0}^{2\\pi} f(\\theta,\\phi)\\, Y_{\\ell}^{m}(\\theta,\\phi)^*\\, \\sin\\theta\\, d\\theta\\, d\\phi,\n$$\n谱重构为\n$$\nf(\\theta,\\phi) = \\sum_{\\ell=0}^{\\infty}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi).\n$$\n在数值天气预报和气候模拟中，标准做法是在阶数 $L_{\\text{trunc}}$ 处进行截断：\n$$\n\\hat{f}_{\\text{base}}(\\theta,\\phi) = \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi).\n$$\n然而，仅靠截断会保留直到 $\\ell=L_{\\text{trunc}}$ 的高阶贡献，这会导致在海岸线等不连续点附近出现吉布斯现象，表现为超出物理边界的振荡过冲。一种缓解方法是对高阶模进行谱滤波。\n\n我们提出基于拉普拉斯算子的指数滤波器\n$$\nG(\\ell) = \\exp\\left(-\\alpha\\, \\ell(\\ell+1)\\right),\n$$\n其中 $\\alpha \\ge 0$ 是无量纲的。该滤波器满足 $G(0) = 1$，从而保留了0阶模。因为 $Y_{0}^{0}(\\theta,\\phi) = \\sqrt{1/(4\\pi)}$ 是常数，球谐系数 $c_{0,0}$ 与 $f$ 的全球质量（积分）成正比：\n$$\nc_{0,0} = \\int_{0}^{\\pi}\\int_{0}^{2\\pi} f(\\theta,\\phi)\\, Y_{0}^{0}(\\theta,\\phi)^*\\, \\sin\\theta\\, d\\theta\\, d\\phi\n= \\sqrt{\\frac{1}{4\\pi}} \\int_{0}^{\\pi}\\int_{0}^{2\\pi} f(\\theta,\\phi)\\, \\sin\\theta\\, d\\theta\\, d\\phi.\n$$\n由于 $G(0) = 1$，滤波后的系数 $c_{0,0}^{\\text{filtered}} = G(0)\\, c_{0,0} = c_{0,0}$，因此总质量在谱空间中得到精确守恒。\n\n为了数值化计算系数，我们在一个等距网格上离散化球面：\n- 余纬 $\\theta_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta\\theta$，其中 $\\Delta\\theta = \\pi/N_{\\text{lat}}$ 且 $i = 0,\\ldots,N_{\\text{lat}}-1$。\n- 经度 $\\phi_j = j\\,\\Delta\\phi$，其中 $\\Delta\\phi = 2\\pi/N_{\\text{lon}}$ 且 $j = 0,\\ldots,N_{\\text{lon}}-1$。\n\n在此网格上，我们使用复合中点法则和面积权重 $w(\\theta_i,\\phi_j) = \\sin\\theta_i\\, \\Delta\\theta\\, \\Delta\\phi$ 来近似积分：\n$$\nc_{\\ell,m} \\approx \\sum_{i=0}^{N_{\\text{lat}}-1}\\sum_{j=0}^{N_{\\text{lon}}-1}\nf(\\theta_i,\\phi_j)\\, Y_{\\ell}^{m}(\\theta_i,\\phi_j)^*\\, \\sin\\theta_i\\, \\Delta\\theta\\, \\Delta\\phi.\n$$\n这种求积方法与球面度量一致，对于中等 $L_{\\text{trunc}}$ 的演示是足够的。\n\n我们将基准截断场重构为\n$$\n\\hat{f}_{\\text{base}}(\\theta,\\phi) = \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} c_{\\ell,m}\\, Y_{\\ell}^{m}(\\theta,\\phi),\n$$\n并将滤波后的场重构为\n$$\n\\hat{f}_{\\text{filt}}(\\theta,\\phi) = \\sum_{\\ell=0}^{L_{\\text{trunc}}}\\sum_{m=-\\ell}^{\\ell} \\left[G(\\ell)\\, c_{\\ell,m}\\right]\\, Y_{\\ell}^{m}(\\theta,\\phi).\n$$\n因为原始场 $f$ 是实值的，所以数值重构取复值和的实部。\n\n为了量化位于 $\\phi = \\pi$ 的海岸线周围的振铃，我们定义一个半宽为 $3\\Delta\\phi$ 的狭窄海岸带：\n$$\n\\mathcal{B} = \\left\\{(\\theta,\\phi): |\\phi - \\pi| \\le 3\\Delta\\phi\\right\\}.\n$$\n在 $\\mathcal{B}$ 内，我们测量边界违例振幅\n$$\n\\text{viol}(g) = \\max\\left( \\max_{\\mathcal{B}} \\left[g(\\theta,\\phi) - 1\\right]_{+},\\; \\max_{\\mathcal{B}} \\left[-g(\\theta,\\phi)\\right]_{+} \\right),\n$$\n其中 $[x]_{+} = \\max(x,0)$，对于 $g = \\hat{f}_{\\text{base}}$（基准）和 $g = \\hat{f}_{\\text{filt}}$（滤波后）。该度量报告了重构场在海岸线附近超出上界 $1$ 或低于下界 $0$ 的程度。\n\n算法步骤：\n\n1. 用 $N_{\\text{lat}} = 73$, $N_{\\text{lon}} = 144$ 构建网格，角度以弧度为单位，并预计算 $\\sin\\theta_i$, $\\Delta\\theta$, $\\Delta\\phi$。\n2. 定义合成海岸场 $f(\\theta,\\phi) = 1$（对于 $\\phi \\in [0,\\pi)$）和 $f(\\theta,\\phi) = 0$（对于 $\\phi \\in [\\pi,2\\pi)$）。\n3. 对于每个测试用例 $(L_{\\text{trunc}}, \\alpha)$：\n   - 通过求积计算直到阶数 $L_{\\text{trunc}}$ 的球谐系数 $c_{\\ell,m}$。\n   - 使用 $c_{\\ell,m}$ 重构 $\\hat{f}_{\\text{base}}$。\n   - 计算基准违例 $\\text{viol}(\\hat{f}_{\\text{base}})$。\n   - 应用滤波器 $G(\\ell) = \\exp(-\\alpha \\ell(\\ell+1))$ 以获得滤波后的系数 $G(\\ell)c_{\\ell,m}$。\n   - 重构 $\\hat{f}_{\\text{filt}}$ 并计算滤波后的违例 $\\text{viol}(\\hat{f}_{\\text{filt}})$。\n   - 计算质量差 $|c_{0,0}^{\\text{filtered}} - c_{0,0}|$。因为 $G(0) = 1$，这个值在数值上应为零，表明总质量守恒。\n4. 将每个度量四舍五入到六位小数，并按规定格式输出结果。\n\n科学真实性与预期结果：\n\n- 海岸线的阶跃引入了一个不连续性，这在截断的球谐重构中产生了吉布斯振铃。指数滤波器减少了导致振荡的高阶贡献，从而降低了海岸线附近的过冲和下冲。$\\alpha = 0$ 的基准情况通常会表现出非零的违例，而增加 $\\alpha$ 会减小违例振幅。使用大的 $\\alpha$ 进行极端平滑会趋近于一个常数场（0阶模），消除了边界违例，但也移除了空间结构。该滤波器保持了总质量守恒，因为它保持 $c_{0,0}$ 不变。\n\n最终程序实现了上述计算步骤，使用 $Y_{\\ell}^{m}(\\theta,\\phi)$ 的矢量化求值和求和来获得 $c_{\\ell,m}$ 及重构场，遵循以弧度为单位的角度约定，并为指定的测试套件输出单行、格式正确的结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import sph_harm\n\ndef make_grid(nlat: int, nlon: int):\n    # Midpoint rule in theta to avoid poles\n    dtheta = np.pi / nlat\n    dphi = 2.0 * np.pi / nlon\n    theta = (np.arange(nlat) + 0.5) * dtheta\n    phi = np.arange(nlon) * dphi\n    TH, PH = np.meshgrid(theta, phi, indexing='ij')\n    sinTH = np.sin(TH)\n    return TH, PH, sinTH, dtheta, dphi\n\ndef synthetic_coast_field(PH):\n    # Half-sphere land-sea mask: land for phi in [0, pi), sea otherwise.\n    # Field is dimensionless: 1 for land, 0 for sea.\n    return (PH < np.pi).astype(np.float64)\n\ndef analyze_sph(f, TH, PH, sinTH, dtheta, dphi, L):\n    # Compute spherical harmonic coefficients c_{l,m} via quadrature\n    # c_{l,m} ~ sum f * conj(Y_{l,m}) * sin(theta) * dtheta * dphi\n    coeffs = {}\n    weights = sinTH * dtheta * dphi\n    for l in range(L + 1):\n        for m in range(-l, l + 1):\n            Y = sph_harm(m, l, PH, TH)  # complex-valued\n            integrand = f * np.conj(Y) * weights\n            c = np.sum(integrand)\n            coeffs[(l, m)] = c\n    return coeffs\n\ndef reconstruct_field(coeffs, TH, PH, L):\n    # Sum c_{l,m} * Y_{l,m} over l,m to reconstruct field; take real part.\n    f_rec = np.zeros_like(TH, dtype=np.complex128)\n    for l in range(L + 1):\n        for m in range(-l, l + 1):\n            Y = sph_harm(m, l, PH, TH)\n            f_rec += coeffs[(l, m)] * Y\n    return np.real(f_rec)\n\ndef apply_filter(coeffs, alpha):\n    # Exponential Laplacian filter: G(l) = exp(-alpha * l * (l+1)), preserves l=0 exactly.\n    filtered = {}\n    for (l, m), c in coeffs.items():\n        g = np.exp(-alpha * l * (l + 1))\n        filtered[(l, m)] = c * g\n    return filtered\n\ndef coastal_band_violation(f_rec, PH, nlon, band_center=np.pi, steps=3):\n    # Band around coastline at phi = band_center with half-width steps * dphi\n    dphi = 2.0 * np.pi / nlon\n    halfwidth = steps * dphi\n    # minimal angular distance on circle\n    delta = np.abs((PH - band_center + np.pi) % (2.0 * np.pi) - np.pi)\n    mask = delta <= halfwidth\n    vals = f_rec[mask]\n    if vals.size == 0:\n        return 0.0\n    above1 = np.max(vals - 1.0) if vals.size else 0.0\n    below0 = np.max(-vals) if vals.size else 0.0\n    violation = max(above1 if above1 > 0.0 else 0.0, below0 if below0 > 0.0 else 0.0)\n    return float(violation)\n\ndef format_results(results):\n    # Format as [[b1,f1,m1],[b2,f2,m2],...] with no spaces and six decimals\n    def fmt(x): return f\"{x:.6f}\"\n    inner = []\n    for r in results:\n        inner.append(\"[\" + \",\".join(fmt(v) for v in r) + \"]\")\n    return \"[\" + \",\".join(inner) + \"]\"\n\ndef solve():\n    # Define grid\n    Nlat = 73\n    Nlon = 144\n    TH, PH, sinTH, dtheta, dphi = make_grid(Nlat, Nlon)\n    f = synthetic_coast_field(PH)\n\n    # Test cases: (L_trunc, alpha)\n    test_cases = [\n        (20, 0.0),    # baseline\n        (20, 0.005),  # moderate smoothing\n        (20, 0.02),   # strong smoothing\n        (12, 0.02),   # lower truncation with smoothing\n        (20, 2.0),    # extreme smoothing\n    ]\n\n    # Cache analyses for each distinct L\n    coeffs_cache = {}\n    baseline_violation_cache = {}\n\n    results = []\n    for L, alpha in test_cases:\n        # Analyze coefficients for this L (cached)\n        if L not in coeffs_cache:\n            coeffs = analyze_sph(f, TH, PH, sinTH, dtheta, dphi, L)\n            coeffs_cache[L] = coeffs\n        else:\n            coeffs = coeffs_cache[L]\n\n        # Baseline reconstruction (alpha = 0)\n        if L not in baseline_violation_cache:\n            f_base = reconstruct_field(coeffs, TH, PH, L)\n            bviol = coastal_band_violation(f_base, PH, Nlon)\n            baseline_violation_cache[L] = (f_base, bviol)\n        else:\n            f_base, bviol = baseline_violation_cache[L]\n\n        # Apply filter\n        filt_coeffs = apply_filter(coeffs, alpha)\n        # Mass difference via c_{0,0}\n        c00_orig = coeffs[(0, 0)]\n        c00_filt = filt_coeffs[(0, 0)]\n        mass_diff = float(np.abs(c00_filt - c00_orig))\n\n        # Filtered reconstruction\n        f_filt = reconstruct_field(filt_coeffs, TH, PH, L)\n        fviol = coastal_band_violation(f_filt, PH, Nlon)\n\n        results.append((bviol, fviol, mass_diff))\n\n    print(format_results(results))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}