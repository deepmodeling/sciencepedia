{
    "hands_on_practices": [
        {
            "introduction": "Understanding the behavior of a numerical scheme begins with analyzing its performance on the simplest relevant problem. This practice guides you through a von Neumann stability analysis of the fifth-order WENO scheme for the linear advection equation . By linearizing the scheme and deriving its amplification factor, you will gain fundamental insights into its inherent numerical dissipation and dispersion, which are critical for predicting its performance in more complex simulations.",
            "id": "4051122",
            "problem": "Consider the one-dimensional linear advection equation $u_{t} + a\\,u_{x} = 0$ with constant speed $a > 0$ on a uniform grid of spacing $\\Delta x$, solved by a conservative finite-volume method for the cell averages $\\bar{u}_{j}(t)$, where $j \\in \\mathbb{Z}$. The semi-discrete update is given by\n$$\n\\frac{d \\bar{u}_{j}}{dt} = -\\frac{1}{\\Delta x}\\left( f_{j+\\frac{1}{2}} - f_{j-\\frac{1}{2}} \\right),\n$$\nwhere $f(u)=a\\,u$ and positive upwinding is used (i.e., $f_{j+\\frac{1}{2}} = a\\,u^{-}_{j+\\frac{1}{2}}$ with the left-biased state $u^{-}_{j+\\frac{1}{2}}$ reconstructed from cell averages via a fifth-order Weighted Essentially Non-Oscillatory (WENO) scheme in the Jiang–Shu framework). The WENO reconstruction uses three third-order candidate polynomials $v_{0}$, $v_{1}$, $v_{2}$ built on stencils $\\{j-2,j-1,j\\}$, $\\{j-1,j,j+1\\}$, and $\\{j,j+1,j+2\\}$, respectively. The nonlinear convex weights $\\omega_{k}$, $k \\in \\{0,1,2\\}$, are defined by\n$$\n\\alpha_{k} = \\frac{d_{k}}{ \\left( \\varepsilon_{s} + \\beta_{k} \\right)^{p} }, \n\\quad\n\\omega_{k} = \\frac{\\alpha_{k}}{\\alpha_{0} + \\alpha_{1} + \\alpha_{2}},\n$$\nwhere $d_{0} = \\frac{1}{10}$, $d_{1} = \\frac{3}{5}$, $d_{2} = \\frac{3}{10}$ are the linear weights, $\\varepsilon_{s} > 0$ is a small smoothness parameter, $p \\geq 1$, and $\\beta_{k}$ are the Jiang–Shu smoothness indicators. The left-biased interface value at $x_{j+\\frac{1}{2}}$ is given by $u^{-}_{j+\\frac{1}{2}} = \\omega_{0} v_{0} + \\omega_{1} v_{1} + \\omega_{2} v_{2}$. The third-order candidate interface values are constructed from the neighboring cell averages $\\bar{u}_{j+m}$ as\n$$\nv_{0} = \\frac{1}{3}\\,\\bar{u}_{j-2} - \\frac{7}{6}\\,\\bar{u}_{j-1} + \\frac{11}{6}\\,\\bar{u}_{j}, \n\\quad\nv_{1} = -\\frac{1}{6}\\,\\bar{u}_{j-1} + \\frac{5}{6}\\,\\bar{u}_{j} + \\frac{1}{3}\\,\\bar{u}_{j+1},\n\\quad\nv_{2} = \\frac{1}{3}\\,\\bar{u}_{j} + \\frac{5}{6}\\,\\bar{u}_{j+1} - \\frac{1}{6}\\,\\bar{u}_{j+2}.\n$$\nAssume a small-amplitude Fourier perturbation about a constant state of the form $\\bar{u}_{j}(t) = \\bar{u} + \\eta\\,\\exp\\!\\big(i\\,\\theta\\,j\\big)$ with $0 < \\eta \\ll 1$ and phase $\\theta \\in \\mathbb{R}$ expressed in radians. Linearize the WENO weights about the constant state and perform a von Neumann Fourier analysis to obtain the fully discrete one-step amplification factor for the Strong Stability Preserving Runge–Kutta of order three (SSPRK(3,3)) time integrator with time step $\\Delta t$ and Courant number $\\nu = a\\,\\Delta t / \\Delta x$.\n\nDerive the closed-form analytical expression for the numerical amplification factor $G(\\theta,\\nu)$ of the linearized WENO5 finite-volume scheme advanced by SSPRK(3,3), expressed in terms of $\\exp(i\\,\\theta)$ and rational coefficients. Provide your final answer as a single analytic expression in terms of $\\theta$ (in radians) and $\\nu$. No units should be included in the final answer.",
            "solution": "### Step 1: Extract Givens\n-   **Equation**: One-dimensional linear advection equation, $u_{t} + a\\,u_{x} = 0$, with constant speed $a > 0$.\n-   **Discretization**: Finite-volume method on a uniform grid with spacing $\\Delta x$.\n-   **Semi-discrete form**: $\\frac{d \\bar{u}_{j}}{dt} = -\\frac{1}{\\Delta x}\\left( f_{j+\\frac{1}{2}} - f_{j-\\frac{1}{2}} \\right)$, for cell averages $\\bar{u}_{j}$.\n-   **Flux function**: $f(u) = a\\,u$.\n-   **Numerical flux**: Positive upwinding is used, $f_{j+\\frac{1}{2}} = a\\,u^{-}_{j+\\frac{1}{2}}$.\n-   **Reconstruction**: Fifth-order WENO scheme (Jiang-Shu) for the left-biased state $u^{-}_{j+\\frac{1}{2}}$.\n-   **Candidate polynomials**: Three third-order polynomials $v_{0}, v_{1}, v_{2}$ on stencils $S_0 = \\{j-2,j-1,j\\}$, $S_1 = \\{j-1,j,j+1\\}$, and $S_2 = \\{j,j+1,j+2\\}$. Their explicit expressions for the interface value at $x_{j+\\frac{1}{2}}$ are:\n    $$v_{0} = \\frac{1}{3}\\,\\bar{u}_{j-2} - \\frac{7}{6}\\,\\bar{u}_{j-1} + \\frac{11}{6}\\,\\bar{u}_{j}$$\n    $$v_{1} = -\\frac{1}{6}\\,\\bar{u}_{j-1} + \\frac{5}{6}\\,\\bar{u}_{j} + \\frac{1}{3}\\,\\bar{u}_{j+1}$$\n    $$v_{2} = \\frac{1}{3}\\,\\bar{u}_{j} + \\frac{5}{6}\\,\\bar{u}_{j+1} - \\frac{1}{6}\\,\\bar{u}_{j+2}$$\n-   **Nonlinear weights**: $\\omega_{k} = \\frac{\\alpha_{k}}{\\sum_{l=0}^2 \\alpha_{l}}$ with $\\alpha_{k} = \\frac{d_{k}}{ ( \\varepsilon_{s} + \\beta_{k} )^{p} }$.\n-   **Parameters for weights**: Linear weights $d_{0} = \\frac{1}{10}$, $d_{1} = \\frac{3}{5}$, $d_{2} = \\frac{3}{10}$. Smoothness parameter $\\varepsilon_{s} > 0$, exponent $p \\geq 1$. $\\beta_{k}$ are the Jiang-Shu smoothness indicators.\n-   **Reconstructed value**: $u^{-}_{j+\\frac{1}{2}} = \\omega_{0} v_{0} + \\omega_{1} v_{1} + \\omega_{2} v_{2}$.\n-   **Analysis setup**: Linearization around a constant state $\\bar{u}$ using a small-amplitude Fourier perturbation $\\bar{u}_{j}(t) = \\bar{u} + \\eta\\,\\exp(i\\,\\theta\\,j)$ with $0 < \\eta \\ll 1$.\n-   **Time integration**: Strong Stability Preserving Runge–Kutta of order three, SSPRK(3,3), with time step $\\Delta t$.\n-   **Courant number**: $\\nu = a\\,\\Delta t / \\Delta x$.\n-   **Goal**: Derive the closed-form analytical expression for the numerical amplification factor $G(\\theta,\\nu)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is a standard exercise in the field of numerical methods for partial differential equations, specifically for hyperbolic conservation laws.\n-   **Scientifically Grounded**: The problem is based on established principles of numerical analysis. The WENO5-JS scheme and SSPRK(3,3) integrator are widely used and well-documented methods. The von Neumann stability analysis is a standard technique for analyzing linear, constant-coefficient finite-difference/volume schemes.\n-   **Well-Posed**: The problem is clearly stated and contains all necessary information to perform the derivation. The request for a closed-form amplification factor is unambiguous. A unique solution exists.\n-   **Objective**: The language is precise and devoid of subjective claims. All components of the numerical scheme are explicitly defined.\n-   **Completeness**: All required formulas, constants, and the form of the perturbation are provided. The problem is self-contained.\n-   **Consistency**: There are no contradictions in the provided information. The components describe a functional and recognized numerical method.\n\nThe problem does not violate any of the invalidity criteria. It is a valid, well-posed problem in computational mathematics.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\n### Derivation of the Amplification Factor\n\nThe derivation proceeds in three main stages:\n1.  Linearization of the WENO scheme.\n2.  Fourier analysis of the linearized semi-discrete spatial operator.\n3.  Application of the SSPRK(3,3) time integrator's stability function.\n\n**1. Linearization of the WENO Scheme**\n\nThe von Neumann analysis is performed on the linearized version of the scheme. We consider a small perturbation $\\delta \\bar{u}_j = \\eta\\,\\exp(i\\,\\theta\\,j)$ around a constant state $\\bar{u}$. The cell averages are $\\bar{u}_j = \\bar{u} + \\delta \\bar{u}_j$.\n\nThe Jiang-Shu smoothness indicators $\\beta_k$ are defined as sums of squares of scaled derivatives of the candidate polynomials. For a constant state $\\bar{u}$, all differences of cell averages are zero, hence $\\beta_k = 0$ for $k \\in \\{0,1,2\\}$. For the perturbed state, the differences are of order $\\eta$, making the smoothness indicators $\\beta_k$ of order $\\eta^2$.\n\nThe nonlinear weights are given by $\\omega_k = \\frac{\\alpha_k}{\\sum_l \\alpha_l}$ where $\\alpha_k = d_k / (\\varepsilon_s + \\beta_k)^p$.\nFor a constant state, $\\beta_k = 0$, leading to $\\alpha_k = d_k/\\varepsilon_s^p$. The weights become $\\omega_k = \\frac{d_k/\\varepsilon_s^p}{\\sum_l d_l/\\varepsilon_s^p} = \\frac{d_k}{\\sum_l d_l}$. The linear weights are designed to sum to one: $d_0+d_1+d_2 = \\frac{1}{10} + \\frac{6}{10} + \\frac{3}{10} = 1$. Thus, for the constant state, $\\omega_k = d_k$.\n\nWhen we linearize the scheme, we consider terms of first order in $\\eta$. The reconstruction is $u^{-}_{j+1/2} = \\sum_k \\omega_k v_k$. The candidate polynomials $v_k$ are linear in $\\bar{u}_j$. We can write $v_k = v_k(\\bar{u}) + v_k(\\delta \\bar{u}) = \\bar{u} + \\delta v_k$. The weights $\\omega_k = d_k + O(\\eta^2)$.\nThen $u^{-}_{j+1/2} = \\sum_k (d_k + O(\\eta^2))(\\bar{u} + \\delta v_k) = \\bar{u}\\sum_k d_k + \\sum_k d_k \\delta v_k + O(\\eta^2) = \\bar{u} + \\sum_k d_k \\delta v_k + O(\\eta^2)$.\nTo first order in $\\eta$, the reconstruction of the perturbation is $\\delta u^{-}_{j+1/2} = \\sum_k d_k \\delta v_k$. This means the linearized scheme is equivalent to the underlying 5th-order linear upwind scheme obtained by using the linear weights $d_k$ directly.\n\n**2. Fourier Analysis of the Semi-Discrete Scheme**\n\nThe linearized reconstruction for $u^-_{j+1/2}$ is $u^-_{j+1/2} = d_0 v_0 + d_1 v_1 + d_2 v_2$. Substituting the expressions for $v_k$ and $d_k$:\n$$\nu^-_{j+1/2} = \\frac{1}{10}\\left(\\frac{1}{3}\\bar{u}_{j-2} - \\frac{7}{6}\\bar{u}_{j-1} + \\frac{11}{6}\\bar{u}_{j}\\right) + \\frac{6}{10}\\left(-\\frac{1}{6}\\bar{u}_{j-1} + \\frac{5}{6}\\bar{u}_{j} + \\frac{1}{3}\\bar{u}_{j+1}\\right) + \\frac{3}{10}\\left(\\frac{1}{3}\\bar{u}_{j} + \\frac{5}{6}\\bar{u}_{j+1} - \\frac{1}{6}\\bar{u}_{j+2}\\right)\n$$\nCollecting coefficients for each $\\bar{u}_{j+m}$:\n$$\nu^-_{j+1/2} = \\left(\\frac{2}{60}\\right)\\bar{u}_{j-2} + \\left(-\\frac{7}{60}-\\frac{6}{60}\\right)\\bar{u}_{j-1} + \\left(\\frac{11}{60}+\\frac{30}{60}+\\frac{6}{60}\\right)\\bar{u}_{j} + \\left(\\frac{12}{60}+\\frac{15}{60}\\right)\\bar{u}_{j+1} + \\left(-\\frac{3}{60}\\right)\\bar{u}_{j+2}\n$$\n$$\nu^-_{j+1/2} = \\frac{1}{60}\\left(2\\bar{u}_{j-2} - 13\\bar{u}_{j-1} + 47\\bar{u}_{j} + 27\\bar{u}_{j+1} - 3\\bar{u}_{j+2}\\right)\n$$\nThe semi-discrete equation considers the flux difference $f_{j+1/2} - f_{j-1/2} = a(u^-_{j+1/2} - u^-_{j-1/2})$.\nLet's substitute the Fourier mode $\\bar{u}_j(t) = \\hat{u}(t)e^{i\\theta j}$ into the expression for the spatial operator. The discrete spatial operator is $\\mathcal{L}_h[\\bar{u}]_j = -\\frac{a}{\\Delta x}(u^-_{j+1/2} - u^-_{j-1/2})$.\nThe Fourier symbol of the operator that maps cell averages $\\{\\bar{u}_j\\}$ to the flux difference $\\{u^-_{j+1/2} - u^-_{j-1/2}\\}$ is $S(\\theta)$.\n$u^-_{j+1/2} - u^-_{j-1/2} = \\frac{1}{60}(-2\\bar{u}_{j-3} + 15\\bar{u}_{j-2} - 60\\bar{u}_{j-1} + 20\\bar{u}_j + 30\\bar{u}_{j+1} - 3\\bar{u}_{j+2})$\nThe symbol of this difference operator is thus:\n$$\nS(\\theta) = \\frac{1}{60}\\left(-2e^{-3i\\theta} + 15e^{-2i\\theta} - 60e^{-i\\theta} + 20 + 30e^{i\\theta} - 3e^{2i\\theta}\\right)\n$$\nThe semi-discrete equation in Fourier space is $\\frac{d\\hat{u}}{dt} = -\\frac{a}{\\Delta x} S(\\theta) \\hat{u}$.\n\n**3. Application of the SSPRK(3,3) Integrator**\n\nThe SSPRK(3,3) method for an ODE $y' = \\mathcal{L}(y)$ is given by:\n$$ u^{(1)} = u^n + \\Delta t \\mathcal{L}(u^n) $$\n$$ u^{(2)} = \\frac{3}{4} u^n + \\frac{1}{4} u^{(1)} + \\frac{1}{4} \\Delta t \\mathcal{L}(u^{(1)}) $$\n$$ u^{n+1} = \\frac{1}{3} u^n + \\frac{2}{3} u^{(2)} + \\frac{2}{3} \\Delta t \\mathcal{L}(u^{(2)}) $$\nFor our linear operator, its symbol is $\\hat{\\mathcal{L}}(\\theta) = -\\frac{a}{\\Delta x}S(\\theta)$. Let $w = \\Delta t \\hat{\\mathcal{L}}(\\theta) = -\\frac{a\\Delta t}{\\Delta x} S(\\theta) = -\\nu S(\\theta)$.\nApplying the scheme in Fourier space yields the amplification factor $G(\\theta, \\nu) = \\hat{u}^{n+1}/\\hat{u}^n$.\nThe amplification factor for SSPRK(3,3) applied to a linear operator is given by its stability function $G(w)$:\n$$ G(w) = 1 + w + \\frac{1}{2}w^2 + \\frac{1}{6}w^3 $$\nThe final amplification factor is obtained by substituting $w = -\\nu S(\\theta)$:\n$$ G(\\theta, \\nu) = 1 - \\nu S(\\theta) + \\frac{1}{2}(-\\nu S(\\theta))^2 + \\frac{1}{6}(-\\nu S(\\theta))^3 $$\n$$ G(\\theta, \\nu) = 1 - \\nu S(\\theta) + \\frac{1}{2}\\nu^2 S(\\theta)^2 - \\frac{1}{6}\\nu^3 S(\\theta)^3 $$\nSubstituting the expression for $S(\\theta)$:\n$$\nS(\\theta) = \\frac{1}{60}\\left(-3e^{2i\\theta} + 30e^{i\\theta} + 20 - 60e^{-i\\theta} + 15e^{-2i\\theta} - 2e^{-3i\\theta}\\right)\n$$\nThe complete expression for the amplification factor is:\n$$\nG(\\theta, \\nu) = 1 - \\frac{\\nu}{60}\\left(-3e^{2i\\theta} + 30e^{i\\theta} + 20 - 60e^{-i\\theta} + 15e^{-2i\\theta} - 2e^{-3i\\theta}\\right)\n+ \\frac{\\nu^2}{2}\\left(\\frac{1}{60}\\left(-3e^{2i\\theta} + 30e^{i\\theta} + 20 - 60e^{-i\\theta} + 15e^{-2i\\theta} - 2e^{-3i\\theta}\\right)\\right)^2\n- \\frac{\\nu^3}{6}\\left(\\frac{1}{60}\\left(-3e^{2i\\theta} + 30e^{i\\theta} + 20 - 60e^{-i\\theta} + 15e^{-2i\\theta} - 2e^{-3i\\theta}\\right)\\right)^3\n$$\nThis simplifies to:\n$$\nG(\\theta, \\nu) = 1 - \\frac{\\nu}{60}H(\\theta) + \\frac{\\nu^2}{7200}H(\\theta)^2 - \\frac{\\nu^3}{1296000}H(\\theta)^3\n$$\nwhere $H(\\theta) = -3e^{2i\\theta} + 30e^{i\\theta} + 20 - 60e^{-i\\theta} + 15e^{-2i\\theta} - 2e^{-3i\\theta}$.\nThis is the closed-form analytical expression for the amplification factor.",
            "answer": "$$\n\\boxed{\n1 - \\frac{\\nu}{60}\\left( -3e^{2i\\theta} + 30e^{i\\theta} + 20 - 60e^{-i\\theta} + 15e^{-2i\\theta} - 2e^{-3i\\theta} \\right) + \\frac{\\nu^2}{7200}\\left( -3e^{2i\\theta} + 30e^{i\\theta} + 20 - 60e^{-i\\theta} + 15e^{-2i\\theta} - 2e^{-3i\\theta} \\right)^2 - \\frac{\\nu^3}{1296000}\\left( -3e^{2i\\theta} + 30e^{i\\theta} + 20 - 60e^{-i\\theta} + 15e^{-2i\\theta} - 2e^{-3i\\theta} \\right)^3\n}\n$$"
        },
        {
            "introduction": "Moving from linear advection to the nonlinear Euler equations requires a method to handle complex wave structures like shocks and contact discontinuities. This exercise focuses on the heart of modern finite-volume methods: the approximate Riemann solver . You will derive, implement, and compare the Harten-Lax-van Leer (HLL) and Harten-Lax-van Leer Contact (HLLC) solvers, quantifying their ability to resolve key features of atmospheric flows and highlighting the trade-offs between computational cost and physical fidelity.",
            "id": "4051161",
            "problem": "Consider one-dimensional compressible atmospheric flow governed by the conservation form of the Euler equations (neglecting viscosity and Coriolis force) with an ideal-gas closure and a gravitational source that is handled separately from the intercell flux. Let the conserved vector be $U = [\\rho, \\rho u, E]^\\top$, where $\\rho$ is mass density in $\\mathrm{kg/m^3}$, $u$ is velocity in $\\mathrm{m/s}$, and $E$ is total energy density in $\\mathrm{J/m^3}$. Let the flux be $F(U) = [\\rho u, \\rho u^2 + p, u(E + p)]^\\top$ with pressure $p$ related to the conserved variables by $p = (\\gamma - 1)\\left(E - \\tfrac{1}{2}\\rho u^2\\right)$ under an ideal-gas equation of state with ratio of specific heats $\\gamma$. In high-order finite-volume methods with Weighted Essentially Non-Oscillatory (WENO) reconstruction, the reconstructed left and right states at a cell interface define a local Riemann problem whose numerical flux determines the interface contribution. Two widely used approximate Riemann solvers are the Harten-Lax-van Leer (HLL) and the Harten-Lax-van Leer Contact (HLLC) fluxes.\n\nYour task is to derive the HLL and HLLC intercell numerical fluxes starting from the Rankine–Hugoniot jump conditions and the self-similar structure of solutions to the Riemann problem for the Euler equations, and then to implement both fluxes. The derivation must begin from the conservation form of the Euler equations and use wave-speed estimates that are consistent with physically admissible states. You must then quantify their ability to resolve contact discontinuities and shocks in stratified atmospheric configurations by comparing each solver’s predicted interface mass flux against the interface mass flux from the exact Riemann solution at the self-similar coordinate $x/t = 0$.\n\nUse the following definitions and constraints:\n- The base equations are the compressible Euler equations for an ideal gas with gravitational force, but the gravitational source term is treated by a separate operator splitting and does not enter the intercell flux derivation. Thus, for the flux derivation and comparisons, only the homogeneous Euler equations are used.\n- The ratio of specific heats is constant and given by $\\gamma = 1.4$.\n- The speed of sound is $a = \\sqrt{\\gamma p / \\rho}$.\n\nStarting from these fundamentals, derive:\n- The Harten-Lax-van Leer (HLL) flux by assuming two waves with speeds $S_L$ and $S_R$ bounding a single constant intermediate state, enforcing the Rankine–Hugoniot jump conditions across each wave, and solving for the intercell flux $F_{\\mathrm{HLL}}$.\n- The Harten-Lax-van Leer Contact (HLLC) flux by extending the HLL structure to include the contact wave with speed $S_M$ and enforcing consistent pressure and normal velocity across the contact to obtain the intermediate “star” states and flux $F_{\\mathrm{HLLC}}$.\n\nThen implement a program that:\n1. For each test case, constructs left and right primitive states $(\\rho_L, u_L, p_L)$ and $(\\rho_R, u_R, p_R)$ in International System of Units (SI) and converts them to conserved variables.\n2. Computes the HLL flux and the HLLC flux at the interface using Davis-type signal-speed estimates $S_L = \\min(u_L - a_L, u_R - a_R)$ and $S_R = \\max(u_L + a_L, u_R + a_R)$, where $a_L$ and $a_R$ are the speeds of sound for the left and right states.\n3. Computes the exact Riemann solution for the Euler equations at $x/t = 0$ using the ideal-gas law and the standard shock/rarefaction relations to obtain the intermediate pressure $p^\\star$, velocity $u^\\star$, and left/right star densities $\\rho_L^\\star$ and $\\rho_R^\\star$. Take the exact interface mass flux to be $f_{\\mathrm{exact}} = \\rho^\\star u^\\star$ with $\\rho^\\star = \\rho_L^\\star$ if $u^\\star > 0$ and $\\rho^\\star = \\rho_R^\\star$ if $u^\\star < 0$. If $u^\\star = 0$, take $\\rho^\\star = (\\rho_L^\\star + \\rho_R^\\star)/2$.\n4. For each solver (HLL and HLLC), reports the absolute error in interface mass flux (first component of the flux vector) compared to the exact interface mass flux, namely $|f_{\\mathrm{solver}} - f_{\\mathrm{exact}}|$.\n\nUse the following test suite of three atmospheric Riemann problems designed to probe contact and shock resolution under variable stratification. All inputs are in SI units:\n- Case $1$ (advected contact in a stratified atmosphere): $\\rho_L = 1.2$, $u_L = 50.0$, $p_L = 100000.0$; $\\rho_R = 0.6$, $u_R = 50.0$, $p_R = 100000.0$.\n- Case $2$ (classical shock tube with strong shock): $\\rho_L = 1.0$, $u_L = 0.0$, $p_L = 100000.0$; $\\rho_R = 0.125$, $u_R = 0.0$, $p_R = 10000.0$.\n- Case $3$ (sea-level to upper-atmosphere rarefaction): $\\rho_L = 1.0$, $u_L = 0.0$, $p_L = 100000.0$; $\\rho_R = 0.02$, $u_R = 0.0$, $p_R = 2000.0$.\n\nFor this problem, velocity must be in $\\mathrm{m/s}$, density in $\\mathrm{kg/m^3}$, and pressure in $\\mathrm{Pa}$. The program must compute the absolute error in interface mass flux for both HLL and HLLC for each case. The final program output must be a single line containing a flat list of six floating-point numbers corresponding to:\n$[e_{\\mathrm{HLL},1}, e_{\\mathrm{HLLC},1}, e_{\\mathrm{HLL},2}, e_{\\mathrm{HLLC},2}, e_{\\mathrm{HLL},3}, e_{\\mathrm{HLLC},3}]$,\nwhere $e_{\\mathrm{HLL},i}$ and $e_{\\mathrm{HLLC},i}$ are the absolute mass-flux errors for case $i$ computed as described above. Express the floating-point numbers in standard decimal notation. The program must be entirely self-contained, take no input, and produce exactly one line as specified.",
            "solution": "The problem requires the derivation and implementation of the Harten-Lax-van Leer (HLL) and Harten-Lax-van Leer Contact (HLLC) approximate Riemann solvers for the one-dimensional compressible Euler equations. Subsequently, these solvers are to be evaluated against an exact Riemann solver for three specific test cases by comparing the computed interface mass flux.\n\nThe one-dimensional Euler equations in conservation form are given by:\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0\n$$\nwhere $U$ is the vector of conserved variables and $F(U)$ is the flux vector:\n$$\nU = \\begin{pmatrix} \\rho \\\\ \\rho u \\\\ E \\end{pmatrix}, \\quad F(U) = \\begin{pmatrix} \\rho u \\\\ \\rho u^2 + p \\\\ u(E + p) \\end{pmatrix}\n$$\nHere, $\\rho$ is the mass density, $u$ is the velocity, and $E$ is the total energy density. The system is closed with the ideal gas equation of state, which relates pressure $p$ to the conserved variables:\n$$\np = (\\gamma - 1) \\left( E - \\frac{1}{2}\\rho u^2 \\right)\n$$\nwhere $\\gamma$ is the ratio of specific heats, given as $\\gamma = 1.4$.\n\nThe numerical solution of these equations via a finite-volume method involves computing the numerical flux $F_{i+1/2}$ at the interface between two cells, $i$ and $i+1$. This is accomplished by solving a Riemann problem with initial states $U_L = U_i$ and $U_R = U_{i+1}$.\n\n**1. Harten-Lax-van Leer (HLL) Flux Derivation**\n\nThe HLL solver is based on a two-wave approximation of the Riemann problem solution. It assumes that the initial states $U_L$ and $U_R$ are separated by a central, constant state $U_{HLL}$, bounded by the fastest left-going wave with speed $S_L$ and the fastest right-going wave with speed $S_R$.\n\nApplying the integral form of the conservation law, $\\oint (U dx - F dt) = 0$, over a control volume in the $x-t$ plane defined by the lines $x=S_L t$, $x=S_R t$, $t=0$, and $t=T$, we get:\n$$\n\\int_{S_L T}^{S_R T} U(x,T) dx - \\int_{-\\infty}^{\\infty} U(x,0) dx_{relevant} = \\int_0^T (F(U_L) - F(U_R)) dt\n$$\nConsidering the piecewise constant initial condition and the assumed constant state $U_{HLL}$ between the waves, the equation for a time interval $\\Delta t$ becomes:\n$$\n(S_R \\Delta t - S_L \\Delta t) U_{HLL} - (S_R \\Delta t U_R - S_L \\Delta t U_L) = (F_L - F_R) \\Delta t\n$$\nSolving for the intermediate state $U_{HLL}$ yields:\n$$\nU_{HLL} = \\frac{S_R U_R - S_L U_L - (F_R - F_L)}{S_R - S_L}\n$$\nThe HLL numerical flux $F_{HLL}$ at the interface ($x/t=0$) is determined by the state prevalent at that location. The Rankine-Hugoniot conditions must be satisfied across the waves $S_L$ and $S_R$. The flux across a line of slope $1/S$ is $F - SU$. To ensure consistency, the interface flux must be such that it satisfies the jump conditions. This leads to a single expression for the HLL flux, which can be derived by considering the case $S_L \\le 0 \\le S_R$, where the interface resides within the averaged state region. The flux $F_{HLL}$ must satisfy $F_{HLL} - F_L = S_L (U_{HLL} - U_L)$ and $F_{HLL} - F_R = S_R (U_{HLL} - U_R)$. Solving either for $F_{HLL}$ and substituting the expression for $U_{HLL}$ gives:\n$$\nF_{HLL} = \\frac{S_R F_L - S_L F_R + S_L S_R (U_R - U_L)}{S_R - S_L}\n$$\nThis formula correctly reduces to $F_L$ if $S_L > 0$ and $F_R$ if $S_R < 0$, thereby covering all cases. The wave speeds $S_L$ and $S_R$ are estimated using the Davis formulation:\n$$\nS_L = \\min(u_L - a_L, u_R - a_R), \\quad S_R = \\max(u_L + a_L, u_R + a_R)\n$$\nwhere $a_K = \\sqrt{\\gamma p_K / \\rho_K}$ for $K \\in \\{L, R\\}$.\n\n**2. Harten-Lax-van Leer Contact (HLLC) Flux Derivation**\n\nThe HLLC solver refines the HLL model by reintroducing the contact discontinuity, which HLL averages out. The wave structure is assumed to be composed of three waves: a leftmost wave ($S_L$), a contact wave ($S_M$), and a rightmost wave ($S_R$). This partitions the solution into four constant states: $U_L$, $U_L^*$, $U_R^*$, and $U_R$.\n\nAcross the contact wave, pressure and velocity are continuous: $p_L^* = p_R^* = p^*$ and $u_L^* = u_R^* = u^* = S_M$. The star states $U_K^*$ ($K \\in \\{L, R\\}$) are related to the outer states $U_K$ by the jump conditions across $S_L$ and $S_R$.\n$$\nF_K^* - F_K = S_K(U_K^* - U_K) \\implies S_K U_K^* - F_K^* = S_K U_K - F_K\n$$\nWriting this equation in components and using $u^* = S_M$ allows us to solve for the properties of the star states. The density in the star region is found to be:\n$$\n\\rho_K^* = \\rho_K \\frac{S_K - u_K}{S_K - S_M}\n$$\nThe pressure in the star region $p^*$ is derived from the momentum equation jump condition, which gives two expressions that must be equal:\n$$\np^* = p_L + \\rho_L(u_L - S_L)(u_L - S_M) = p_R + \\rho_R(u_R - S_R)(u_R - S_M)\n$$\nThis equality is solved for the contact wave speed $S_M$:\n$$\nS_M = \\frac{p_R - p_L + \\rho_L u_L(S_L - u_L) - \\rho_R u_R(S_R - u_R)}{\\rho_L(S_L - u_L) - \\rho_R(S_R - u_R)}\n$$\nWith $S_M$ known, $p^*$ can be calculated, and the star state densities $\\rho_L^*$ and $\\rho_R^*$ are determined. The star state energy densities are $E_K^* = \\frac{p^*}{\\gamma-1} + \\frac{1}{2}\\rho_K^*(S_M)^2$. This fully defines the states $U_L^*$ and $U_R^*$.\n\nThe HLLC flux at the interface is then selected based on its position relative to the waves:\n$$\nF_{HLLC} =\n\\begin{cases}\n    F_L & \\text{if } S_L > 0 \\\\\n    F_L^* = F_L + S_L(U_L^* - U_L) & \\text{if } S_L \\le 0 < S_M \\\\\n    F_R^* = F_R + S_R(U_R^* - U_R) & \\text{if } S_M \\le 0 \\le S_R \\\\\n    F_R & \\text{if } S_R < 0\n\\end{cases}\n$$\n\n**3. Exact Riemann Solver**\n\nThe exact solution of the Riemann problem for the Euler equations is used as the reference. Its structure is similar to the HLLC model, but the outer waves can be either shocks or smooth rarefaction fans. The core of the method is to find the pressure $p^*$ and velocity $u^*$ in the star region. These are found by solving the nonlinear algebraic equation $g(p) = 0$, where:\n$$\ng(p) = f_L(p) + f_R(p) + u_R - u_L\n$$\nThe functions $f_K(p)$ depend on whether the wave is a shock ($p > p_K$) or a rarefaction ($p \\le p_K$):\n- Shock: $f_K(p) = (p - p_K) \\sqrt{\\frac{A_K}{p + B_K}}$ with $A_K = \\frac{2}{(\\gamma+1)\\rho_K}$ and $B_K = \\frac{\\gamma-1}{\\gamma+1}p_K$.\n- Rarefaction: $f_K(p) = \\frac{2 a_K}{\\gamma - 1} \\left[ \\left(\\frac{p}{p_K}\\right)^{\\frac{\\gamma-1}{2\\gamma}} - 1 \\right]$.\n\nThis equation is solved for $p^*$ using a numerical root-finding algorithm. Once $p^*$ is found, $u^*$ is calculated as $u^* = \\frac{1}{2}(u_L + u_R) + \\frac{1}{2}(f_R(p^*) - f_L(p^*))$. The state at the interface $x/t=0$ is determined by the sign of $u^*$:\n- If $u^* > 0$, the state is $U_L^*$.\n- If $u^* < 0$, the state is $U_R^*$.\n- If $u^* = 0$, the contact discontinuity is stationary at the interface.\n\nThe densities $\\rho_L^*$ and $\\rho_R^*$ are calculated based on $p^*$ and the wave type (isentropic relations for rarefactions, Rankine-Hugoniot relations for shocks). The exact interface mass flux is $f_{\\mathrm{exact}} = \\rho^* u^*$, where $\\rho^* = \\rho_L^*$ if $u^* > 0$ and $\\rho^* = \\rho_R^*$ if $u^* < 0$. If $u^*=0$, the mass flux is $0$.\n\n**4. Implementation and Comparison**\n\nThe program implements these three solvers (HLL, HLLC, Exact) for the provided test cases. For each case, it computes the mass flux component of $F_{HLL}$, $F_{HLLC}$, and the exact flux $f_{\\mathrm{exact}}$. The absolute error $|f_{\\mathrm{solver}} - f_{\\mathrm{exact}}|$ is then calculated for both HLL and HLLC solvers. The test cases are designed to highlight the different capabilities of the solvers: Case 1 is an isolated contact discontinuity, for which HLLC should be exact while HLL is diffusive. Case 2 is a classic shock tube problem, testing shock and contact resolution. Case 3 involves two rarefaction waves, testing behavior in situations with large pressure and density gradients but no shocks.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the HLL and HLLC flux errors against an exact Riemann solver.\n    \"\"\"\n    gamma = 1.4\n\n    test_cases = [\n        # Case 1: Advected contact\n        # rho_L, u_L, p_L, rho_R, u_R, p_R\n        (1.2, 50.0, 100000.0, 0.6, 50.0, 100000.0),\n        # Case 2: Sod shock tube\n        (1.0, 0.0, 100000.0, 0.125, 0.0, 10000.0),\n        # Case 3: Two-rarefaction problem\n        (1.0, 0.0, 100000.0, 0.02, 0.0, 2000.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        e_hll, e_hllc = compute_flux_errors(case, gamma)\n        results.extend([e_hll, e_hllc])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef prim_to_cons(rho, u, p, gamma):\n    \"\"\"Converts primitive variables to conserved variables.\"\"\"\n    E = p / (gamma - 1.0) + 0.5 * rho * u**2\n    return np.array([rho, rho * u, E])\n\ndef get_flux(rho, u, p, E):\n    \"\"\"Computes the flux vector from primitive and conserved variables.\"\"\"\n    return np.array([rho * u, rho * u**2 + p, u * (E + p)])\n\ndef compute_flux_errors(case, gamma):\n    \"\"\"\n    Computes absolute mass flux errors for HLL and HLLC solvers for a single case.\n    \"\"\"\n    rho_L, u_L, p_L, rho_R, u_R, p_R = case\n\n    # --- Exact Solver ---\n    exact_mass_flux = calc_exact_flux(rho_L, u_L, p_L, rho_R, u_R, p_R, gamma)\n\n    # --- Approximate Solvers ---\n    # Derived quantities and initial state vectors\n    a_L = np.sqrt(gamma * p_L / rho_L)\n    a_R = np.sqrt(gamma * p_R / rho_R)\n    \n    U_L = prim_to_cons(rho_L, u_L, p_L, gamma)\n    U_R = prim_to_cons(rho_R, u_R, p_R, gamma)\n    \n    F_L = get_flux(rho_L, u_L, p_L, U_L[2])\n    F_R = get_flux(rho_R, u_R, p_R, U_R[2])\n\n    # Davis wave speed estimates\n    S_L = min(u_L - a_L, u_R - a_R)\n    S_R = max(u_L + a_L, u_R + a_R)\n    \n    # --- HLL Flux ---\n    if S_L > 0:\n        F_HLL = F_L\n    elif S_R  0:\n        F_HLL = F_R\n    else:\n        F_HLL = (S_R * F_L - S_L * F_R + S_L * S_R * (U_R - U_L)) / (S_R - S_L)\n    hll_mass_flux = F_HLL[0]\n\n    # --- HLLC Flux ---\n    # Calculate contact wave speed S_M\n    num = p_R - p_L + rho_L * u_L * (S_L - u_L) - rho_R * u_R * (S_R - u_R)\n    den = rho_L * (S_L - u_L) - rho_R * (S_R - u_R)\n    S_M = num / den\n\n    if S_L > 0:\n        F_HLLC = F_L\n    elif S_R  0:\n        F_HLLC = F_R\n    else:\n        if S_M >= 0:\n            p_star = p_L + rho_L * (u_L - S_L) * (u_L - S_M)\n            rho_star_L = rho_L * (S_L - u_L) / (S_L - S_M)\n            E_star_L = p_star / (gamma - 1.0) + 0.5 * rho_star_L * S_M**2\n            U_star_L = np.array([rho_star_L, rho_star_L * S_M, E_star_L])\n            F_HLLC = F_L + S_L * (U_star_L - U_L)\n        else: # S_M  0\n            p_star = p_R + rho_R * (u_R - S_R) * (u_R - S_M)\n            rho_star_R = rho_R * (S_R - u_R) / (S_R - S_M)\n            E_star_R = p_star / (gamma - 1.0) + 0.5 * rho_star_R * S_M**2\n            U_star_R = np.array([rho_star_R, rho_star_R * S_M, E_star_R])\n            F_HLLC = F_R + S_R * (U_star_R - U_R)\n    hllc_mass_flux = F_HLLC[0]\n\n    # Calculate absolute errors\n    e_hll = abs(hll_mass_flux - exact_mass_flux)\n    e_hllc = abs(hllc_mass_flux - exact_mass_flux)\n\n    return e_hll, e_hllc\n\ndef calc_exact_flux(rho_L, u_L, p_L, rho_R, u_R, p_R, gamma):\n    \"\"\"\n    Computes the exact mass flux at the interface x/t=0 for the Euler equations.\n    \"\"\"\n    \n    def pressure_func(p_star, rho_K, p_K, a_K):\n        \"\"\"Pressure function for a single state (left or right).\"\"\"\n        if p_star > p_K:  # Shock\n            A_K = 2.0 / ((gamma + 1.0) * rho_K)\n            B_K = p_K * (gamma - 1.0) / (gamma + 1.0)\n            return (p_star - p_K) * np.sqrt(A_K / (p_star + B_K))\n        else:  # Rarefaction\n            return (2.0 * a_K / (gamma - 1.0)) * ((p_star / p_K)**((gamma - 1.0) / (2.0 * gamma)) - 1.0)\n\n    def root_func(p_star):\n        \"\"\"Function whose root is the star pressure.\"\"\"\n        a_L = np.sqrt(gamma * p_L / rho_L)\n        a_R = np.sqrt(gamma * p_R / rho_R)\n        f_L = pressure_func(p_star, rho_L, p_L, a_L)\n        f_R = pressure_func(p_star, rho_R, p_R, a_R)\n        return f_L + f_R + u_R - u_L\n\n    # Solve for p_star using a bracketing root-finder\n    p_min = 1e-6\n    p_max = max(p_L, p_R) * 10 if max(p_L, p_R) > 1 else max(p_L,p_R)*100\n    if root_func(p_min)*root_func(p_max) > 0: # find better bracket\n         p_max = p_max*100\n         \n    p_star = brentq(root_func, p_min, p_max)\n    \n    # Calculate u_star\n    a_L = np.sqrt(gamma * p_L / rho_L)\n    a_R = np.sqrt(gamma * p_R / rho_R)\n    f_L = pressure_func(p_star, rho_L, p_L, a_L)\n    f_R = pressure_func(p_star, rho_R, p_R, a_R)\n    u_star = 0.5 * (u_L + u_R) + 0.5 * (f_R - f_L)\n\n    if u_star == 0.0:\n        return 0.0\n\n    if u_star > 0.0:\n        # State at interface is from left state\n        if p_star > p_L:  # Shock\n            rho_star = rho_L * ((p_star / p_L + (gamma - 1.0) / (gamma + 1.0)) /\n                                (((gamma - 1.0) / (gamma + 1.0)) * (p_star / p_L) + 1.0))\n        else:  # Rarefaction\n            rho_star = rho_L * (p_star / p_L)**(1.0 / gamma)\n    else:  # u_star  0.0\n        # State at interface is from right state\n        if p_star > p_R:  # Shock\n            rho_star = rho_R * ((p_star / p_R + (gamma - 1.0) / (gamma + 1.0)) /\n                                (((gamma - 1.0) / (gamma + 1.0)) * (p_star / p_R) + 1.0))\n        else:  # Rarefaction\n            rho_star = rho_R * (p_star / p_R)**(1.0 / gamma)\n            \n    return rho_star * u_star\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Many geophysical flows are characterized by a near-perfect balance between flux gradients and physical source terms, such as the hydrostatic balance in an atmosphere at rest. This final practice explores the advanced concept of well-balancing, investigating how the choice of time integration and source term treatment can impact a scheme's ability to preserve these delicate equilibria . Through a hands-on implementation, you will measure how different strategies for coupling the dynamics and source terms affect the numerical preservation of a lake-at-rest state, a crucial capability for stable and accurate long-term climate simulations.",
            "id": "4051119",
            "problem": "Consider the one-dimensional balance law that models hydrostatic pressure balance under gravity as an isolated scalar subsystem arising from the momentum balance of the shallow-water equations, in a periodic domain $[0,L]$ with $L=1$:\n$$\n\\frac{\\partial h(x,t)}{\\partial t} + \\frac{\\partial}{\\partial x}\\left( \\tfrac{1}{2} g h(x,t)^2 \\right) = - g \\, h(x,t) \\, \\frac{\\partial b(x)}{\\partial x}.\n$$\nHere, $h(x,t)$ is the water column height, $b(x)$ is the bottom topography, and $g$ is gravitational acceleration. The hydrostatic lake-at-rest equilibrium satisfies $u(x,t)=0$ and the free-surface elevation $\\eta(x,t) = h(x,t) + b(x)$ is constant in space and time. Under this equilibrium, the spatial derivative of the pressure flux exactly cancels the gravitational source, i.e.,\n$$\n\\frac{\\partial}{\\partial x}\\left( \\tfrac{1}{2} g h^2 \\right) + g \\, h \\, \\frac{\\partial b}{\\partial x} = 0\n$$\nwhen $\\eta$ is constant.\n\nYou are asked to implement a high-order finite-volume spatial discretization with Weighted Essentially Non-Oscillatory (WENO) reconstruction and Strong-Stability-Preserving Runge-Kutta (SSP RK) time integration for the scalar balance law above. The goal is to quantitatively evaluate how the stage order behavior of SSP RK time-steppers interacts with gravitational source discretization and influences hydrostatic well-balancing, measured as deviation from the lake-at-rest state after a single time step.\n\nUse the following scientifically grounded and self-consistent setup:\n- Periodic domain $[0,1]$ with $N$ uniform cells of width $\\Delta x = 1/N$.\n- Smooth bottom topography\n$$\nb(x) = A \\sin(2\\pi x) + 0.05 \\cos(4\\pi x),\n$$\nwith amplitude $A=0.2$.\n- Gravitational acceleration $g = 9.81$.\n- Hydrostatic initial condition $u(x,0)=0$ and\n$$\n\\eta(x,0) = H, \\quad h(x,0)=H-b(x),\n$$\nwith $H=1.0$, ensuring $h(x,0)  0$ for all $x$.\n\nSpatial discretization requirements:\n- Finite-volume form for cell-average updates. Reconstruct left and right interface values of $h$ using fifth-order WENO-Jiang-Shu reconstruction. Compute numerical flux for $f(h)=\\tfrac{1}{2} g h^2$ at interfaces using the Lax-Friedrichs (Rusanov) flux with wavespeed $a=\\max\\{ |f'(h^-)|, |f'(h^+)| \\} = g \\max\\{h^-, h^+\\}$ at each interface. The flux divergence is approximated by the interface flux differences divided by $\\Delta x$.\n- The gravitational source term at cell centers uses a fifth-order accurate periodic central finite difference approximation for $\\partial b/\\partial x$:\n$$\n\\left( \\frac{\\partial b}{\\partial x} \\right)_i \\approx \\frac{1}{60\\,\\Delta x}\\left( b_{i-3} - 9 b_{i-2} + 45 b_{i-1} - 45 b_{i+1} + 9 b_{i+2} - b_{i+3} \\right),\n$$\nwith periodic indexing.\n\nTime discretization requirements:\n- Implement two Strong-Stability-Preserving Runge-Kutta schemes: second-order SSP RK (two stages) and third-order SSP RK (three stages). In each case, the semi-discrete right-hand side is\n$$\n\\mathcal{L}(h) = - \\left( \\frac{\\partial}{\\partial x}\\left( \\tfrac{1}{2} g h^2 \\right) \\right) + \\mathcal{S}(h),\n$$\nwhere the discrete source term is\n$$\n\\mathcal{S}(h)_i = - g \\, h_i \\left( \\frac{\\partial b}{\\partial x} \\right)_i.\n$$\nYou must evaluate two distinct source term policies:\n1. Stage-aware source: at every Runge-Kutta stage, compute $\\mathcal{S}(h)$ using the current stage state $h$.\n2. Frozen-source: at every Runge-Kutta stage, compute $\\mathcal{S}(h)$ using the initial state $h^n$ from the beginning of the time step, i.e., $\\mathcal{S}(h^n)$ held fixed across stages.\n\nQuantitative metric:\n- After one time step $\\Delta t$, compute the free-surface elevation $\\eta^{n+1}_i = h^{n+1}_i + b_i$ and measure the deviation from the hydrostatic equilibrium as the discrete root-mean-square (RMS) norm:\n$$\nE = \\sqrt{ \\frac{1}{N} \\sum_{i=0}^{N-1} \\left( \\eta^{n+1}_i - H \\right)^2 }.\n$$\nThis metric is dimensionless; report it as a floating-point number.\n\nTest suite:\n- Use $N=256$.\n- Consider the following one-step experiments, each specified by the pair $(\\text{scheme}, \\text{policy}, \\Delta t)$:\n    1. $(\\text{SSP RK2}, \\text{stage-aware}, \\Delta t = 1.0\\times 10^{-4})$.\n    2. $(\\text{SSP RK2}, \\text{frozen-source}, \\Delta t = 1.0\\times 10^{-4})$.\n    3. $(\\text{SSP RK3}, \\text{stage-aware}, \\Delta t = 2.0\\times 10^{-4})$.\n    4. $(\\text{SSP RK3}, \\text{frozen-source}, \\Delta t = 2.0\\times 10^{-4})$.\n    5. $(\\text{SSP RK3}, \\text{stage-aware}, \\Delta t = 2.5\\times 10^{-4})$.\n    6. $(\\text{SSP RK3}, \\text{frozen-source}, \\Delta t = 2.5\\times 10^{-4})$.\n\nYour program should produce a single line of output containing the results for the six experiments as a comma-separated list enclosed in square brackets, in the order listed above. For example:\n\"[E1,E2,E3,E4,E5,E6]\".\nAll numerical values in the output must be floating-point numbers.\n\nImplement the program in any modern language, but the final answer must be a complete, runnable program. No user input is allowed; all parameters are defined above. Ensure all numerical steps are self-consistent and scientifically sound within the stated discretization framework. The evaluation focuses on reasoning from first principles about flux-source balance, discretization consistency, and the influence of Runge-Kutta stage behavior on hydrostatic well-balancing.",
            "solution": "The problem presented requires the numerical solution of a one-dimensional scalar balance law, which models hydrostatic equilibrium in the shallow-water equations. The primary objective is to investigate the impact of different Strong-Stability-Preserving Runge-Kutta (SSP RK) time integration strategies on the well-balancing property of a high-order finite-volume scheme. A well-balanced scheme is one that can exactly preserve a known steady-state solution, in this case, the \"lake-at-rest\" condition, at the discrete level.\n\nThe governing equation is given by:\n$$\n\\frac{\\partial h}{\\partial t} + \\frac{\\partial f(h)}{\\partial x} = S(h,x)\n$$\nwhere $h(x,t)$ is the fluid depth, the flux is $f(h) = \\frac{1}{2} g h^2$, and the source term due to bottom topography $b(x)$ is $S(h,x) = -g h \\frac{\\partial b}{\\partial x}$. The constant $g$ is the acceleration due to gravity.\n\nThe lake-at-rest steady state is characterized by a constant free-surface elevation $\\eta(x) = h(x) + b(x) = H$, where $H$ is a constant. At this equilibrium, the flux gradient and the source term are in perfect balance:\n$$\n\\frac{\\partial f(h)}{\\partial x} = \\frac{\\partial}{\\partial x}\\left( \\frac{1}{2} g (H-b(x))^2 \\right) = -g(H-b(x))\\frac{\\partial b}{\\partial x} = -g h \\frac{\\partial b}{\\partial x} = S(h,x)\n$$\nThus, $\\frac{\\partial h}{\\partial t} = 0$, and the state is stationary. Numerical schemes may fail to preserve this balance, introducing spurious oscillations. This investigation quantifies such deviations.\n\nWe employ the method of lines, where we first discretize in space to obtain a system of ordinary differential equations (ODEs), and then solve this system using an appropriate time integrator.\n\n**Spatial Discretization: Finite Volume Method**\nThe domain $[0,L]$ is divided into $N$ uniform cells $I_i = [x_{i-1/2}, x_{i+1/2}]$ of width $\\Delta x = L/N$. We consider the cell-averaged quantity $\\bar{h}_i(t) = \\frac{1}{\\Delta x} \\int_{I_i} h(x,t) dx$. Integrating the PDE over cell $I_i$ yields the exact evolution for the cell average:\n$$\n\\frac{d\\bar{h}_i}{dt} + \\frac{1}{\\Delta x} \\left( f(h(x_{i+1/2},t)) - f(h(x_{i-1/2},t)) \\right) = \\frac{1}{\\Delta x} \\int_{I_i} S(h,x) dx\n$$\nThis is approximated by a semi-discrete system:\n$$\n\\frac{d\\bar{h}_i}{dt} = - \\frac{1}{\\Delta x} \\left( \\hat{f}_{i+1/2} - \\hat{f}_{i-1/2} \\right) + \\bar{S}_i = \\mathcal{L}(\\bar{h})_i\n$$\nwhere $\\hat{f}_{i+1/2}$ is the numerical flux at the cell interface $x_{i+1/2}$ and $\\bar{S}_i$ is the approximation of the cell-averaged source term.\n\n**1. Interface Reconstruction: Fifth-Order WENO**\nTo compute the numerical flux, we need the values of $h$ at the left and right sides of each cell interface, denoted $h_{i+1/2}^-$ and $h_{i+1/2}^+$. These are obtained from the cell averages $\\bar{h}_i$ using a fifth-order accurate Weighted Essentially Non-Oscillatory (WENO-JS) reconstruction. This method uses a convex combination of three candidate third-order polynomial reconstructions on overlapping stencils to achieve high accuracy in smooth regions while avoiding spurious oscillations near discontinuities.\n\nFor a left-biased reconstruction of $h_{i+1/2}^-$, we use the stencil of cell averages $\\{\\bar{h}_{i-2}, \\bar{h}_{i-1}, \\bar{h}_i, \\bar{h}_{i+1}, \\bar{h}_{i+2}\\}$. The reconstruction is a weighted sum of three third-order polynomial interpolants, $\\hat{h}^{(k)}_{i+1/2}$, evaluated at the interface:\n$$\nh_{i+1/2}^- = \\omega_0 \\hat{h}^{(0)}_{i+1/2} + \\omega_1 \\hat{h}^{(1)}_{i+1/2} + \\omega_2 \\hat{h}^{(2)}_{i+1/2}\n$$\nThe nonlinear weights $\\omega_k$ depend on smoothness indicators $\\beta_k$, which measure the variation of the solution on each sub-stencil. In smooth regions, the weights approach the optimal linear weights $\\{d_0, d_1, d_2\\} = \\{0.1, 0.6, 0.3\\}$ to achieve fifth-order accuracy. The right-biased reconstruction $h_{i+1/2}^+$ is computed analogously using a symmetric stencil shifted to the right.\n\n**2. Numerical Flux: Lax-Friedrichs (Rusanov)**\nThe numerical flux $\\hat{f}_{i+1/2}$ is computed using the local Lax-Friedrichs (or Rusanov) flux, which is simple and robust:\n$$\n\\hat{f}_{i+1/2} = \\frac{1}{2} \\left( f(h_{i+1/2}^-) + f(h_{i+1/2}^+) \\right) - \\frac{a_{i+1/2}}{2} \\left( h_{i+1/2}^+ - h_{i+1/2}^- \\right)\n$$\nThe local wave speed $a_{i+1/2}$ is an upper bound for the characteristic speeds at the interface. For the flux $f(h)=\\frac{1}{2}gh^2$, the characteristic speed is $f'(h)=gh$. Therefore, we use $a_{i+1/2} = g \\max(|h_{i+1/2}^-|, |h_{i+1/2}^+|)$.\n\n**3. Source Term Discretization**\nThe cell-averaged source term is approximated as $\\bar{S}_i \\approx S(\\bar{h}_i, x_i) = -g \\bar{h}_i (\\frac{\\partial b}{\\partial x})_i$. The topographic derivative $(\\frac{\\partial b}{\\partial x})_i$ at the cell center $x_i$ is computed using the specified fifth-order accurate central finite difference stencil on the point values $b_j = b(x_j)$:\n$$\n\\left( \\frac{\\partial b}{\\partial x} \\right)_i \\approx \\frac{1}{60\\,\\Delta x}\\left( b_{i-3} - 9 b_{i-2} + 45 b_{i-1} - 45 b_{i+1} + 9 b_{i+2} - b_{i+3} \\right)\n$$\nPeriodic boundary conditions are applied for indices outside the valid range.\n\n**Temporal Discretization: SSP Runge-Kutta Methods**\nThe semi-discrete system $\\frac{d\\bar{h}}{dt} = \\mathcal{L}(\\bar{h})$ is integrated in time using SSP RK methods, which are designed to preserve the stability properties (e.g., total variation diminishing) of the forward Euler method. We test two schemes, SSP RK2 and SSP RK3.\n\n- **SSP RK2 (Heun's Method, 2 stages, 2nd order):**\n  $$\n  \\begin{aligned}\n  \\bar{h}^{(1)} = \\bar{h}^n + \\Delta t \\, \\mathcal{L}(\\bar{h}^n) \\\\\n  \\bar{h}^{n+1} = \\frac{1}{2}\\bar{h}^n + \\frac{1}{2}\\left(\\bar{h}^{(1)} + \\Delta t \\, \\mathcal{L}(\\bar{h}^{(1)})\\right)\n  \\end{aligned}\n  $$\n\n- **SSP RK3 (Shu-Osher, 3 stages, 3rd order):**\n  $$\n  \\begin{aligned}\n  \\bar{h}^{(1)} = \\bar{h}^n + \\Delta t \\, \\mathcal{L}(\\bar{h}^n) \\\\\n  \\bar{h}^{(2)} = \\frac{3}{4}\\bar{h}^n + \\frac{1}{4}\\left(\\bar{h}^{(1)} + \\Delta t \\, \\mathcal{L}(\\bar{h}^{(1)})\\right) \\\\\n  \\bar{h}^{n+1} = \\frac{1}{3}\\bar{h}^n + \\frac{2}{3}\\left(\\bar{h}^{(2)} + \\Delta t \\, \\mathcal{L}(\\bar{h}^{(2)})\\right)\n  \\end{aligned}\n  $$\n\n**Source Term Policies and Well-Balancing**\nThe critical part of this investigation is the treatment of the source term within the RK stages. The discrete balance between the flux divergence and the source term may not hold, i.e., $-\\frac{1}{\\Delta x}(\\hat{f}_{i+1/2} - \\hat{f}_{i-1/2}) + \\bar{S}_i \\neq 0$, even for the exact hydrostatic initial data. This imbalance acts as a perturbation that the time-stepping scheme propagates.\n\nWe analyze two policies for computing the source term within the operator $\\mathcal{L}(\\bar{h})$ at each RK stage:\n1.  **Stage-aware source:** $\\mathcal{L}(\\bar{h}^{(\\text{stage})})$ uses the source term $\\bar{S}(\\bar{h}^{(\\text{stage})})$ computed from the current stage values. This is the standard approach for a general ODE.\n2.  **Frozen-source:** $\\mathcal{L}(\\bar{h}^{(\\text{stage})})$ uses the source term $\\bar{S}(\\bar{h}^n)$ computed from the solution at the beginning of the time step, $\\bar{h}^n$, and keeps it constant across all stages. This is motivated by the fact that for a true steady state, the source term should not change. If the discrete operator nearly balances, freezing the source can prevent the intermediate, non-physical stage values from corrupting the source term computation and exacerbating the imbalance.\n\n**Implementation and Evaluation**\nThe algorithm is implemented in Python using NumPy for vectorized computations. The periodic nature of the domain is handled efficiently using `numpy.roll`. The WENO-5 reconstruction for both left and right interface states and the finite difference for topography gradient are implemented as vectorized functions. The main loop iterates through the six specified test cases, each defined by an RK scheme, a source policy, and a time step $\\Delta t$. For each case, we perform a single time step starting from the hydrostatic initial condition $\\bar{h}_i^0 = H - b(x_i)$. The deviation from equilibrium is measured by the RMS norm of the error in the free surface elevation:\n$$\nE = \\sqrt{ \\frac{1}{N} \\sum_{i=0}^{N-1} \\left( (h^{n+1}_i + b_i) - H \\right)^2 }\n$$\nThis quantitative metric allows us to compare the well-balancing properties of the different numerical strategies.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D hydrostatic balance law problem and evaluates well-balancing errors.\n    \"\"\"\n    # Define problem parameters\n    N = 256\n    L = 1.0\n    g = 9.81\n    A = 0.2\n    H = 1.0\n    dx = L / N\n    x = np.linspace(0.5 * dx, L - 0.5 * dx, N)\n\n    # Define bottom topography and its derivative\n    b = A * np.sin(2 * np.pi * x) + 0.05 * np.cos(4 * np.pi * x)\n    \n    # Pre-compute the 5th-order finite difference of the topography\n    # (Db/Dx)_i approx (1/60dx) * (b_{i-3} - 9b_{i-2} + 45b_{i-1} - 45b_{i+1} + 9b_{i+2} - b_{i+3})\n    dbdx = (\n        np.roll(b, 3) - 9 * np.roll(b, 2) + 45 * np.roll(b, 1) -\n        45 * np.roll(b, -1) + 9 * np.roll(b, -2) - np.roll(b, -3)\n    ) / (60.0 * dx)\n\n    # Initial condition (hydrostatic equilibrium)\n    h0 = H - b\n\n    # --- WENO-5 Reconstruction ---\n    def weno5_reconstruct(h):\n        \"\"\"\n        Computes the 5th-order WENO reconstruction for left and right states\n        at all cell interfaces in a vectorized manner.\n        \n        Returns:\n            h_minus (np.ndarray): Left-reconstructed values at i+1/2\n            h_plus (np.ndarray): Right-reconstructed values at i+1/2\n        \"\"\"\n        epsilon = 1e-6\n\n        # --- Left-biased reconstruction for h_{i+1/2}^{-} ---\n        v0 = np.roll(h, 2)\n        v1 = np.roll(h, 1)\n        v2 = h\n        v3 = np.roll(h, -1)\n        v4 = np.roll(h, -2)\n\n        beta0 = 13./12. * (v0 - 2*v1 + v2)**2 + 1./4. * (v0 - 4*v1 + 3*v2)**2\n        beta1 = 13./12. * (v1 - 2*v2 + v3)**2 + 1./4. * (v1 - v3)**2\n        beta2 = 13./12. * (v2 - 2*v3 + v4)**2 + 1./4. * (3*v2 - 4*v3 + v4)**2\n\n        d0, d1, d2 = 0.1, 0.6, 0.3\n\n        alpha0 = d0 / (epsilon + beta0)**2\n        alpha1 = d1 / (epsilon + beta1)**2\n        alpha2 = d2 / (epsilon + beta2)**2\n        alpha_sum = alpha0 + alpha1 + alpha2\n\n        w0 = alpha0 / alpha_sum\n        w1 = alpha1 / alpha_sum\n        w2 = alpha2 / alpha_sum\n        \n        h_recon0 = 2./6.*v0 - 7./6.*v1 + 11./6.*v2\n        h_recon1 = -1./6.*v1 + 5./6.*v2 + 2./6.*v3\n        h_recon2 = 2./6.*v2 + 5./6.*v3 - 1./6.*v4\n\n        h_minus = w0 * h_recon0 + w1 * h_recon1 + w2 * h_recon2\n\n        # --- Right-biased reconstruction for h_{i+1/2}^{+} ---\n        # This is equivalent to a left-biased reconstruction on a reversed stencil.\n        v0_r = np.roll(h, -3)\n        v1_r = np.roll(h, -2)\n        v2_r = np.roll(h, -1)\n        v3_r = h\n        v4_r = np.roll(h, 1)\n\n        beta0_r = 13./12. * (v0_r - 2*v1_r + v2_r)**2 + 1./4. * (v0_r - 4*v1_r + 3*v2_r)**2\n        beta1_r = 13./12. * (v1_r - 2*v2_r + v3_r)**2 + 1./4. * (v1_r - v3_r)**2\n        beta2_r = 13./12. * (v2_r - 2*v3_r + v4_r)**2 + 1./4. * (3*v2_r - 4*v3_r + v4_r)**2\n\n        # Linear weights are reversed for right-biased reconstruction\n        d0_r, d1_r, d2_r = 0.3, 0.6, 0.1\n        \n        alpha0_r = d0_r / (epsilon + beta0_r)**2\n        alpha1_r = d1_r / (epsilon + beta1_r)**2\n        alpha2_r = d2_r / (epsilon + beta2_r)**2\n        alpha_sum_r = alpha0_r + alpha1_r + alpha2_r\n\n        w0_r = alpha0_r / alpha_sum_r\n        w1_r = alpha1_r / alpha_sum_r\n        w2_r = alpha2_r / alpha_sum_r\n\n        h_recon0_r = 2./6.*v0_r - 7./6.*v1_r + 11./6.*v2_r\n        h_recon1_r = -1./6.*v1_r + 5./6.*v2_r + 2./6.*v3_r\n        h_recon2_r = 2./6.*v2_r + 5./6.*v3_r - 1./6.*v4_r\n\n        h_plus = w0_r * h_recon0_r + w1_r * h_recon1_r + w2_r * h_recon2_r\n\n        return h_minus, h_plus\n    \n    # --- RHS Operator ---\n    def L_operator(h, h_initial, policy):\n        \"\"\"\n        Computes the semi-discrete RHS L(h) = -div(f) + S.\n        \"\"\"\n        # --- Flux divergence part ---\n        h_minus, h_plus = weno5_reconstruct(h)\n\n        f_minus = 0.5 * g * h_minus**2\n        f_plus = 0.5 * g * h_plus**2\n        \n        # Local Lax-Friedrichs (Rusanov) wavespeed\n        alpha = g * np.maximum(np.abs(h_minus), np.abs(h_plus))\n        \n        # Numerical flux at i+1/2\n        flux_iph = 0.5 * (f_minus + f_plus) - 0.5 * alpha * (h_plus - h_minus)\n        \n        # Flux at i-1/2\n        flux_imh = np.roll(flux_iph, 1)\n\n        flux_divergence = (flux_iph - flux_imh) / dx\n        \n        # --- Source term part ---\n        source_h = h if policy == 'stage-aware' else h_initial\n        source_term = -g * source_h * dbdx\n\n        return -flux_divergence + source_term\n\n    # Define test cases\n    test_cases = [\n        ('SSP RK2', 'stage-aware', 1.0e-4),\n        ('SSP RK2', 'frozen-source', 1.0e-4),\n        ('SSP RK3', 'stage-aware', 2.0e-4),\n        ('SSP RK3', 'frozen-source', 2.0e-4),\n        ('SSP RK3', 'stage-aware', 2.5e-4),\n        ('SSP RK3', 'frozen-source', 2.5e-4),\n    ]\n\n    results = []\n\n    for scheme, policy, dt in test_cases:\n        h_n = h0.copy()\n\n        if scheme == 'SSP RK2':\n            # Stage 1\n            L_n = L_operator(h_n, h_n, policy)\n            h_1 = h_n + dt * L_n\n            # Stage 2\n            L_1 = L_operator(h_1, h_n, policy)\n            h_final = 0.5 * h_n + 0.5 * (h_1 + dt * L_1)\n        elif scheme == 'SSP RK3':\n            # Stage 1\n            L_n = L_operator(h_n, h_n, policy)\n            h_1 = h_n + dt * L_n\n            # Stage 2\n            L_1 = L_operator(h_1, h_n, policy)\n            h_2 = 0.75 * h_n + 0.25 * (h_1 + dt * L_1)\n            # Stage 3\n            L_2 = L_operator(h_2, h_n, policy)\n            h_final = (1./3.) * h_n + (2./3.) * (h_2 + dt * L_2)\n        else:\n            raise ValueError(f\"Unknown scheme: {scheme}\")\n\n        # Compute the free-surface elevation and the RMS error\n        eta_final = h_final + b\n        error = np.sqrt(np.mean((eta_final - H)**2))\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}