{
    "hands_on_practices": [
        {
            "introduction": "分裂显式方法通过为不同物理过程使用不同大小的时间步长来提高计算效率。本练习将通过一个具体场景，训练您一项核心技能：如何在满足所有相关波动模式（包括平流、重力波和声波）的稳定性约束（CFL条件）下，确定模型允许的最大“慢”时间步长。掌握这一计算是成功实现并运行这类数值模型的关键第一步 。",
            "id": "4087035",
            "problem": "考虑一个用于可压缩大气的、构建在一维均匀水平网格上的分裂显式、水平显式-垂直隐式 (HEVI) 动力核心。快声波模态在每个大小为 $\\Delta t_{o}$ 的外部慢模态步长内，使用 $M$ 个大小为 $\\Delta t_{f}$ 的内部子步进行时间推进，因此 $\\Delta t_{o} = M \\Delta t_{f}$，其中 $M$ 为正整数。快声波模态的声速为 $c_{s}$，而慢水平模态受到最大风速为 $U_{\\max}$ 的平流运动以及在重力加速度 $g$ 下深度为 $H$ 的单层等效深度大气的外部正压重力波模态的共同约束。水平网格间距为 $\\Delta x$。\n\n给定参数如下：\n- $\\Delta x = 10{,}000 \\ \\mathrm{m}$，\n- $U_{\\max} = 45 \\ \\mathrm{m} \\ \\mathrm{s}^{-1}$，\n- $H = 10{,}000 \\ \\mathrm{m}$，\n- $g = 9.81 \\ \\mathrm{m} \\ \\mathrm{s}^{-2}$，\n- $c_{s} = 330 \\ \\mathrm{m} \\ \\mathrm{s}^{-1}$，\n- $\\Delta t_{f} = 0.4 \\ \\mathrm{s}$。\n\n假设所选水平显式格式的线性稳定性分析得出以下柯朗-弗里德里希-列维 (CFL) 限制：\n- 对于快声波子步：$C_{\\text{fast}}^{\\max} = 1.0$，\n- 对于慢平流模态：$C_{\\text{adv}}^{\\max} = 0.9$，\n- 对于慢外部重力波模态：$C_{\\text{gw}}^{\\max} = 0.45$。\n\n请确定允许的最大外部时间步长 $\\Delta t_{o}$，该步长需为 $\\Delta t_{f}$ 的整数倍，同时满足所有快慢模态的 CFL 约束。请以秒为单位表示最终答案，并将其四舍五入到四位有效数字。",
            "solution": "该问题要求确定用于大气模式的分裂显式数值格式所允许的最大外部时间步长 $\\Delta t_{o}$。此确定过程受制于针对不同物理模态的一组柯朗-弗里德里希-列维 (CFL) 稳定性条件，以及 $\\Delta t_{o}$ 必须是指定的快模态时间步长 $\\Delta t_{f}$ 的整数倍这一结构性约束。\n\n首先，我们分析不同模态对时间步长施加的约束。该模式是分裂显式的，意味着快模态和慢模态分别用不同的时间步长 $\\Delta t_{f}$ 和 $\\Delta t_{o}$ 进行处理。给定参数如下：\n- 水平网格间距：$\\Delta x = 10,000 \\ \\mathrm{m}$\n- 最大平流风速：$U_{\\max} = 45 \\ \\mathrm{m} \\ \\mathrm{s}^{-1}$\n- 外部重力波的等效深度：$H = 10,000 \\ \\mathrm{m}$\n- 重力加速度：$g = 9.81 \\ \\mathrm{m} \\ \\mathrm{s}^{-2}$\n- 声速：$c_{s} = 330 \\ \\mathrm{m} \\ \\mathrm{s}^{-1}$\n- 快模态时间步长：$\\Delta t_{f} = 0.4 \\ \\mathrm{s}$\n- 最大CFL数：$C_{\\text{fast}}^{\\max} = 1.0$, $C_{\\text{adv}}^{\\max} = 0.9$, $C_{\\text{gw}}^{\\max} = 0.45$。\n\n外部和内部时间步长之间的关系由 $\\Delta t_{o} = M \\Delta t_{f}$ 给出，其中 $M$ 是一个正整数。\n\n我们将评估每种模态的稳定性约束。\n\n1.  快声波模态约束：\n    对于使用短时间步长 $\\Delta t_{f}$ 推进的快声波模态，其 CFL 条件由 $C_{\\text{fast}} = \\frac{c_{s} \\Delta t_{f}}{\\Delta x} \\le C_{\\text{fast}}^{\\max}$ 给出。我们可以验证给定的 $\\Delta t_{f}$ 是否满足此条件：\n    $$C_{\\text{fast}} = \\frac{(330 \\ \\mathrm{m} \\ \\mathrm{s}^{-1}) \\times (0.4 \\ \\mathrm{s})}{10,000 \\ \\mathrm{m}} = \\frac{132}{10,000} = 0.0132$$\n    由于 $0.0132 \\le 1.0$，给定的快模态时间步长 $\\Delta t_{f} = 0.4 \\ \\mathrm{s}$ 是稳定的，问题设置是一致的。此条件不直接约束 $\\Delta t_o$，但验证了参数的合理性。\n\n2.  慢平流模态约束：\n    对于使用外部时间步长 $\\Delta t_{o}$ 推进的慢平流模态，其 CFL 条件为 $C_{\\text{adv}} = \\frac{U_{\\max} \\Delta t_{o}}{\\Delta x} \\le C_{\\text{adv}}^{\\max}$。这为 $\\Delta t_{o}$ 提供了一个上限：\n    $$\\Delta t_{o} \\le \\frac{C_{\\text{adv}}^{\\max} \\Delta x}{U_{\\max}}$$\n    代入给定值：\n    $$\\Delta t_{o} \\le \\frac{0.9 \\times 10,000 \\ \\mathrm{m}}{45 \\ \\mathrm{m} \\ \\mathrm{s}^{-1}} = \\frac{9,000}{45} \\ \\mathrm{s} = 200 \\ \\mathrm{s}$$\n    我们将此最大值记为 $\\Delta t_{o, \\text{adv}}^{\\max} = 200 \\ \\mathrm{s}$。\n\n3.  慢外部重力波模态约束：\n    慢外部重力波模态的 CFL 条件也取决于 $\\Delta t_{o}$。外部重力波的相速度 $c_{g}$ 由 $c_{g} = \\sqrt{gH}$ 给出。\n    $$c_{g} = \\sqrt{(9.81 \\ \\mathrm{m} \\ \\mathrm{s}^{-2}) \\times (10,000 \\ \\mathrm{m})} = \\sqrt{98,100} \\ \\mathrm{m} \\ \\mathrm{s}^{-1} \\approx 313.209 \\ \\mathrm{m} \\ \\mathrm{s}^{-1}$$\n    其 CFL 条件为 $C_{\\text{gw}} = \\frac{c_{g} \\Delta t_{o}}{\\Delta x} \\le C_{\\text{gw}}^{\\max}$。这为 $\\Delta t_{o}$ 提供了另一个上限：\n    $$\\Delta t_{o} \\le \\frac{C_{\\text{gw}}^{\\max} \\Delta x}{c_{g}} = \\frac{C_{\\text{gw}}^{\\max} \\Delta x}{\\sqrt{gH}}$$\n    代入给定值：\n    $$\\Delta t_{o} \\le \\frac{0.45 \\times 10,000 \\ \\mathrm{m}}{\\sqrt{98,100} \\ \\mathrm{m} \\ \\mathrm{s}^{-1}} = \\frac{4,500}{\\sqrt{98,100}} \\ \\mathrm{s} \\approx 14.36726 \\ \\mathrm{s}$$\n    我们将此最大值记为 $\\Delta t_{o, \\text{gw}}^{\\max} \\approx 14.36726 \\ \\mathrm{s}$。\n\n为确保稳定性，外部时间步长 $\\Delta t_{o}$ 必须同时满足所有约束。因此，$\\Delta t_{o}$ 必须小于或等于慢模态的最大允许时间步长的最小值：\n$$\\Delta t_{o} \\le \\min(\\Delta t_{o, \\text{adv}}^{\\max}, \\Delta t_{o, \\text{gw}}^{\\max})$$\n$$\\Delta t_{o} \\le \\min(200 \\ \\mathrm{s}, 14.36726 \\ \\mathrm{s})$$\n$$\\Delta t_{o} \\le 14.36726 \\ \\mathrm{s}$$\n外部重力波模态是外部时间步长的限制因素。\n\n最后，我们应用 $\\Delta t_{o}$ 必须是 $\\Delta t_{f}$ 的整数倍这一约束。即 $\\Delta t_{o} = M \\Delta t_{f}$，其中 $M$ 是正整数且 $\\Delta t_{f} = 0.4 \\ \\mathrm{s}$。\n$$M \\times \\Delta t_{f} \\le 14.36726 \\ \\mathrm{s}$$\n$$M \\times 0.4 \\ \\mathrm{s} \\le 14.36726 \\ \\mathrm{s}$$\n$$M \\le \\frac{14.36726}{0.4} \\approx 35.91815$$\n由于 $M$ 必须是整数，因此 $M$ 的最大可能值为 $35$。\n\n因此，允许的最大外部时间步长 $\\Delta t_{o}$ 为：\n$$\\Delta t_{o} = 35 \\times \\Delta t_{f} = 35 \\times 0.4 \\ \\mathrm{s} = 14 \\ \\mathrm{s}$$\n问题要求答案四舍五入到四位有效数字。精确答案是 $14$，可以表示为 $14.00$。",
            "answer": "$$\\boxed{14.00}$$"
        },
        {
            "introduction": "半隐式方法通过对快波进行隐式处理，从而允许使用更大的时间步长。这种稳定性并非没有代价，它通常通过引入数值阻尼来实现。本练习将引导您运用冯·诺依曼稳定性分析，推导出一个偏心半隐式格式的放大因子，从而精确理解偏心参数是如何引入可控的阻尼以稳定模型的 。这种分析能力对于评估和设计稳健的时间积分方案至关重要。",
            "id": "4087006",
            "problem": "考虑可压缩欧拉方程关于空间均匀参考态的线性化快波子系统，该参考态具有恒定的密度 $\\bar{\\rho}$、压强 $\\bar{p}$ 和声速 $c$，其中 $c^{2} = \\left(\\partial p / \\partial \\rho\\right)_{s}$，且背景速度为零。仅保留声学项，使得扰动速度 $u(x,t)$ 和压强扰动 $p'(x,t)$ 满足\n$$\n\\partial_{t} u + \\frac{1}{\\bar{\\rho}}\\,\\partial_{x} p' = 0, \n\\qquad\n\\partial_{t} p' + \\bar{\\rho} c^{2}\\,\\partial_{x} u = 0.\n$$\n在用于数值天气预报的分裂显式格式中，以及在关注垂直传播快模态的水平显式垂直隐式 (HEVI) 方法中，该快波子系统代表了在内时间步长上推进的分量。\n\n使用关于参考态的偏中心半隐式格式进行时间离散化，偏心参数为 $\\alpha \\in [0,1]$，时间步长均匀为 $\\Delta t$。在间距为 $\\Delta x$ 的均匀网格上，使用中心二阶差分对 $\\partial_{x}$ 进行离散化。将中心差分算子记为 $D_{x}$。从时间层 $n$ 推进到 $n+1$ 的时间离散格式为\n$$\nu^{n+1} = u^{n} - \\Delta t\\left[(1-\\alpha)\\frac{1}{\\bar{\\rho}} D_{x} p'^{\\,n} + \\alpha \\frac{1}{\\bar{\\rho}} D_{x} p'^{\\,n+1}\\right],\n$$\n$$\np'^{\\,n+1} = p'^{\\,n} - \\Delta t\\left[(1-\\alpha)\\bar{\\rho} c^{2} D_{x} u^{n} + \\alpha \\bar{\\rho} c^{2} D_{x} u^{n+1}\\right].\n$$\n\n通过代入傅里叶模态 $u_{j}^{n} = U\\,G^{n}\\,\\exp(i j \\kappa)$ 和 $p'^{\\,n}_{j} = P\\,G^{n}\\,\\exp(i j \\kappa)$ 进行 von Neumann 分析，其中 $j$ 是网格点的索引，$\\kappa = k \\Delta x$ 是无量纲波数，$G$ 是单步放大因子。$D_{x}$ 的傅里叶符号是 $i \\tilde{k}$，其中 $\\tilde{k} = \\sin(\\kappa)/\\Delta x$。定义库朗数 $\\lambda = c \\Delta t / \\Delta x$。\n\n仅使用以上定义和控制方程，推导单步放大因子大小 $|G|$ 关于 $\\alpha$、$\\lambda$ 和 $\\kappa$ 的闭式表达式。您的最终答案必须是单个闭式解析表达式。无需取整。根据您的表达式，简要解释关于参考态的偏心（即选择 $\\alpha > 1/2$）如何为快波引入数值阻尼。",
            "solution": "该问题陈述在科学上是合理的、适定的且客观的。它提出了对一个线性双曲系统的半隐式数值格式进行的标准 von Neumann 稳定性分析，这是流体动力学和大气建模数值方法分析中的一项基本任务。所有必要的方程、定义和参数都已提供，没有矛盾或含糊之处。\n\n从时间层 $n$ 推进到 $n+1$ 的离散方程组由下式给出：\n$$\nu^{n+1} = u^{n} - \\Delta t\\left[(1-\\alpha)\\frac{1}{\\bar{\\rho}} D_{x} p'^{\\,n} + \\alpha \\frac{1}{\\bar{\\rho}} D_{x} p'^{\\,n+1}\\right]\n$$\n$$\np'^{\\,n+1} = p'^{\\,n} - \\Delta t\\left[(1-\\alpha)\\bar{\\rho} c^{2} D_{x} u^{n} + \\alpha \\bar{\\rho} c^{2} D_{x} u^{n+1}\\right]\n$$\n为进行 von Neumann 分析，我们将傅里叶试探解 $u_{j}^{n} = U\\,G^{n}\\,\\exp(i j \\kappa)$ 和 $p'^{\\,n}_{j} = P\\,G^{n}\\,\\exp(i j \\kappa)$ 代入离散方程。中心差分算子 $D_x$ 作用于傅里叶模态 $\\exp(i j \\kappa)$ 的效果是乘以其傅里叶符号，该符号为 $i \\tilde{k}$，其中 $\\tilde{k} = \\frac{\\sin(\\kappa)}{\\Delta x}$。从时间层 $n$ 到 $n+1$ 的推进对应于乘以放大因子 $G$。\n\n将试探解代入第一个方程可得：\n$$\nG U G^{n} e^{i j \\kappa} = U G^{n} e^{i j \\kappa} - \\frac{\\Delta t}{\\bar{\\rho}} \\left[ (1-\\alpha) (i \\tilde{k}) P G^{n} e^{i j \\kappa} + \\alpha (i \\tilde{k}) P G^{n+1} e^{i j \\kappa} \\right]\n$$\n两边同除以 $G^{n} e^{i j \\kappa}$ 并注意到 $G^{n+1}=G \\cdot G^n$，我们得到一个关于振幅 $U$ 和 $P$ 的代数方程：\n$$\nG U = U - \\frac{i \\tilde{k} \\Delta t}{\\bar{\\rho}} \\left[ (1-\\alpha) P + \\alpha G P \\right]\n$$\n整理可得：\n$$\n(G-1)U + \\frac{i \\tilde{k} \\Delta t}{\\bar{\\rho}} \\left[ (1-\\alpha) + \\alpha G \\right] P = 0\n$$\n\n类似地，将试探解代入第二个方程可得：\n$$\nG P G^{n} e^{i j \\kappa} = P G^{n} e^{i j \\kappa} - \\bar{\\rho} c^{2} \\Delta t \\left[ (1-\\alpha) (i \\tilde{k}) U G^{n} e^{i j \\kappa} + \\alpha (i \\tilde{k}) U G^{n+1} e^{i j \\kappa} \\right]\n$$\n两边同除以 $G^{n} e^{i j \\kappa}$ 可得：\n$$\nG P = P - i \\tilde{k} \\bar{\\rho} c^{2} \\Delta t \\left[ (1-\\alpha) U + \\alpha G U \\right]\n$$\n整理可得：\n$$\ni \\tilde{k} \\bar{\\rho} c^{2} \\Delta t \\left[ (1-\\alpha) + \\alpha G \\right] U + (G-1)P = 0\n$$\n\n这两个方程构成了一个关于振幅 $U$ 和 $P$ 的齐次线性系统：\n$$\n\\begin{pmatrix}\nG-1 & \\frac{i \\tilde{k} \\Delta t}{\\bar{\\rho}} \\left[ (1-\\alpha) + \\alpha G \\right] \\\\\ni \\tilde{k} \\bar{\\rho} c^{2} \\Delta t \\left[ (1-\\alpha) + \\alpha G \\right] & G-1\n\\end{pmatrix}\n\\begin{pmatrix}\nU \\\\\nP\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n0\n\\end{pmatrix}\n$$\n为了存在非平凡解 $(U, P) \\neq (0, 0)$，系数矩阵的行列式必须为零：\n$$\n(G-1)^2 - \\left( \\frac{i \\tilde{k} \\Delta t}{\\bar{\\rho}} \\left[ (1-\\alpha) + \\alpha G \\right] \\right) \\left( i \\tilde{k} \\bar{\\rho} c^{2} \\Delta t \\left[ (1-\\alpha) + \\alpha G \\right] \\right) = 0\n$$\n$$\n(G-1)^2 - i^2 (\\tilde{k} c \\Delta t)^2 \\left[ (1-\\alpha) + \\alpha G \\right]^2 = 0\n$$\n由于 $i^2 = -1$，上式可简化为：\n$$\n(G-1)^2 + (\\tilde{k} c \\Delta t)^2 \\left[ (1-\\alpha) + \\alpha G \\right]^2 = 0\n$$\n我们定义无量纲参数 $\\sigma = \\tilde{k} c \\Delta t$。使用给定的定义 $\\tilde{k} = \\frac{\\sin(\\kappa)}{\\Delta x}$ 和库朗数 $\\lambda = \\frac{c \\Delta t}{\\Delta x}$，我们有 $\\sigma = \\frac{\\sin(\\kappa)}{\\Delta x} c \\Delta t = \\left(\\frac{c \\Delta t}{\\Delta x}\\right) \\sin(\\kappa) = \\lambda \\sin(\\kappa)$。方程变为：\n$$\n(G-1)^2 + \\sigma^2 \\left( 1 - \\alpha + \\alpha G \\right)^2 = 0\n$$\n由此可以解出 $G$：\n$$\n(G-1)^2 = - \\sigma^2 \\left( 1 - \\alpha + \\alpha G \\right)^2\n$$\n$$\nG-1 = \\pm i \\sigma (1 - \\alpha + \\alpha G)\n$$\n$$\nG - 1 = \\pm i \\sigma (1-\\alpha) \\pm i \\sigma \\alpha G\n$$\n$$\nG(1 \\mp i \\sigma \\alpha) = 1 \\pm i \\sigma (1-\\alpha)\n$$\n$$\nG = \\frac{1 \\pm i \\sigma (1-\\alpha)}{1 \\mp i \\sigma \\alpha}\n$$\n$G$ 的两个解互为复共轭。为了求出其大小 $|G|$，我们可以分析其中一个解，因为它们的模长相同。我们取正号：\n$$\nG = \\frac{1 + i \\sigma (1-\\alpha)}{1 - i \\sigma \\alpha}\n$$\n$G$ 的大小是分子大小与分母大小的比值：\n$$\n|G| = \\frac{|1 + i \\sigma (1-\\alpha)|}{|1 - i \\sigma \\alpha|} = \\frac{\\sqrt{1^2 + (\\sigma (1-\\alpha))^2}}{\\sqrt{1^2 + (-\\sigma \\alpha)^2}} = \\frac{\\sqrt{1 + \\sigma^2 (1-\\alpha)^2}}{\\sqrt{1 + \\sigma^2 \\alpha^2}}\n$$\n将 $\\sigma = \\lambda \\sin(\\kappa)$ 代回表达式，我们得到单步放大因子大小的最终闭式表达式：\n$$\n|G| = \\sqrt{\\frac{1 + (\\lambda \\sin(\\kappa))^2 (1-\\alpha)^2}{1 + (\\lambda \\sin(\\kappa))^2 \\alpha^2}}\n$$\n为解释偏心参数 $\\alpha > 1/2$ 如何引入数值阻尼，我们考察 $|G| < 1$ 的条件。当一个波模态的振幅随每个时间步减小时，就发生了数值阻尼。\n$$\n|G| < 1 \\implies |G|^2 < 1\n$$\n$$\n\\frac{1 + (\\lambda \\sin(\\kappa))^2 (1-\\alpha)^2}{1 + (\\lambda \\sin(\\kappa))^2 \\alpha^2} < 1\n$$\n对于任何非平凡波模态 ($\\sin(\\kappa) \\neq 0$)，分母为正。我们可以将不等式两边同乘以分母：\n$$\n1 + (\\lambda \\sin(\\kappa))^2 (1-\\alpha)^2 < 1 + (\\lambda \\sin(\\kappa))^2 \\alpha^2\n$$\n$$\n(\\lambda \\sin(\\kappa))^2 (1-\\alpha)^2 < (\\lambda \\sin(\\kappa))^2 \\alpha^2\n$$\n两边同除以正项 $(\\lambda \\sin(\\kappa))^2$ 可得：\n$$\n(1-\\alpha)^2 < \\alpha^2\n$$\n因为问题陈述中 $\\alpha \\in [0, 1]$，所以 $1-\\alpha$ 和 $\\alpha$ 均为非负。我们可以对两边取平方根：\n$$\n1-\\alpha < \\alpha\n$$\n$$\n1 < 2\\alpha \\implies \\alpha > \\frac{1}{2}\n$$\n因此，当且仅当 $\\alpha > 1/2$ 时，放大因子的大小 $|G|$ 小于 1。这表明，选择偏心参数 $\\alpha > 1/2$ 会引入数值阻尼，导致快波模态的振幅随时间衰减。这种阻尼是对时间步的隐式部分（$n+1$ 项）赋予更大权重的直接结果，这是一种在数值模型中控制高频数值振荡并确保稳定性的常用技术。反之，对于 $\\alpha < 1/2$，格式是放大的（$|G| > 1$）且不稳定的。对于 $\\alpha = 1/2$（Crank-Nicolson 方法），$|G|=1$，格式是中性稳定的，保持每个模态的能量。",
            "answer": "$$\\boxed{\\sqrt{\\frac{1 + (\\lambda \\sin(\\kappa))^{2} (1-\\alpha)^{2}}{1 + (\\lambda \\sin(\\kappa))^{2} \\alpha^{2}}}}$$"
        },
        {
            "introduction": "从理论走向实践，最后的这项练习要求您为可压缩欧拉方程构建一个完整的分裂显式求解器。您将亲手实现通量分裂，为平流和声波过程应用不同时间步长的守恒有限体积法更新，并验证该方案的守恒性和稳定性等基本属性。这个综合性的编程任务将本章的关键概念融合成一个具体的数值工具，从而巩固您对这些高级格式在实践中如何构建的理解 。",
            "id": "4086980",
            "problem": "设计并实现一个用于一维无量纲形式可压缩欧拉方程的分裂显式有限体积算法，该算法需适用于数值天气预报和气候模拟。该分裂显式方法必须通过内部显式子步处理压力和速度的快速声波传播，同时通过外部显式步处理平流通量的慢速平流输运。该格式必须在每个控制体积上满足离散通量差分的守恒性。\n\n从状态向量 $U = [\\rho, \\rho u, E]^{\\top}$ 的一维可压缩欧拉方程的守恒形式出发，其中 $\\rho$ 是密度， $u$ 是速度， $E$ 是总能量：\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0,\n$$\n其通量为\n$$\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\nu (E + p)\n\\end{bmatrix},\n$$\n理想气体的状态方程为 $p = (\\gamma - 1)\\left(E - \\frac{1}{2}\\rho u^2\\right)$ ，其中 $\\gamma$ 是比热比。所有变量均为无量纲（没有单位）。\n\n分裂显式设计必须将通量分解为平流分量和声波分量，\n$$\nF(U) = F_{\\mathrm{adv}}(U) + F_{\\mathrm{ac}}(U),\n$$\n其中\n$$\nF_{\\mathrm{adv}}(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 \\\\\nu E\n\\end{bmatrix}, \\quad\nF_{\\mathrm{ac}}(U) = \\begin{bmatrix}\n0 \\\\\np \\\\\nu p\n\\end{bmatrix}.\n$$\n外部步使用 $F_{\\mathrm{adv}}$ 在一个大的时间步长 $\\Delta t_{\\mathrm{adv}}$ 上推进 $U$，该步长受基于 $|u|$ 的平流 Courant–Friedrichs–Lewy (CFL) 条件的约束；而内部步则使用 $F_{\\mathrm{ac}}$ 在 $M$ 个大小为 $\\delta t = \\Delta t_{\\mathrm{adv}} / M$ 的小子步上推进 $U$，这些子步受基于声速 $c = \\sqrt{\\gamma p/\\rho}$ 的声波 CFL 条件的约束。时间分裂必须覆盖相同的外部步长持续时间，以使组合更新保持一致：\n$$\nU^{n+1} = \\Phi_{\\mathrm{ac}}^{M}\\left(\\Phi_{\\mathrm{adv}}^{1}\\left(U^n; \\Delta t_{\\mathrm{adv}}\\right); \\delta t\\right),\n$$\n其中 $\\Phi_{\\mathrm{adv}}^{1}$ 是在 $\\Delta t_{\\mathrm{adv}}$ 上使用 $F_{\\mathrm{adv}}$ 进行的一次守恒有限体积更新，而 $\\Phi_{\\mathrm{ac}}^{M}$ 是 $M$ 次守恒有限体积更新，每次在 $\\delta t$ 上使用 $F_{\\mathrm{ac}}$。使用周期性边界条件。\n\n在区间 $x \\in [0,1]$ 上使用包含 $N$ 个单元的均匀网格进行空间离散化，间距为 $\\Delta x = 1/N$。每次通量更新必须以守恒通量差分形式进行，在网格单元界面处使用一阶局部 Lax–Friedrichs (Rusanov) 数值通量。对于平流通量，使用基于 $|u|$ 的最大信号速度。对于声波通量，使用基于声速 $c$ 的最大信号速度。内部步使用声波通量更新动量和能量；质量更新仅由外部平流通量承担，这与连续性方程的结构一致，并确保了在分裂更新中的守恒性。\n\n按照以下规范，用 Python 实现该算法：\n- 定义域：周期性，$x \\in [0,1]$，$N$ 个单元。\n- 气体常数比：$\\gamma = 1.4$。\n- 基态：$\\rho_0 = 1$, $p_0 = 1$。\n- 声速：$c_0 = \\sqrt{\\gamma p_0/\\rho_0}$。\n- 初始扰动：在基态上叠加一个振幅为 $\\varepsilon$ 的小正弦压力扰动，并可选择性地加入一个均匀平均流 $u_0$。\n\n您必须构建一个包含三个案例的测试套件，以共同评估守恒性、准确性和稳定性/正定性。所有变量和参数都是无量纲的。\n\n案例 A (快速模式下的守恒性):\n- 网格大小 $N = 200$。\n- 初始状态: $\\rho(x,0) = \\rho_0$, $u(x,0) = 0$, $p(x,0) = p_0 \\left(1 + \\varepsilon \\sin(2\\pi x)\\right)$，其中 $\\varepsilon = 10^{-4}$。\n- CFL 数: $\\mathrm{CFL}_{\\mathrm{adv}} = 0.9$, $\\mathrm{CFL}_{\\mathrm{ac}} = 0.3$。\n- 最终时间 $T = 0.02$，通过重复的外部步达到；每个外部步被分裂为内部声波子步。\n- 输出：计算初始和最终总质量 $\\sum_i \\rho_i \\Delta x$、总动量 $\\sum_i (\\rho u)_i \\Delta x$ 和总能量 $\\sum_i E_i \\Delta x$ 之间的绝对守恒误差。报告三个浮点数：绝对质量误差、绝对动量误差和绝对能量误差。\n\n案例 B (与非分裂参考方案的准确性对比):\n- 网格大小 $N = 200$。\n- 初始状态: $\\rho(x,0) = \\rho_0$, $u(x,0) = u_0$, $p(x,0) = p_0 \\left(1 + \\varepsilon \\sin(2\\pi x)\\right)$，其中 $\\varepsilon = 10^{-4}$ 且 $u_0 = 0.5$。\n- 分裂显式 CFL 数: $\\mathrm{CFL}_{\\mathrm{adv}} = 0.9$, $\\mathrm{CFL}_{\\mathrm{ac}} = 0.3$。\n- 参考的非分裂格式：对完整通量 $F(U)$ 使用一阶 Rusanov 格式，其小时间步长由 $\\mathrm{CFL}_{\\mathrm{ref}} = 0.3$ 和最大值 $|u|+c$ 确定。\n- 两种格式都计算到最终时间 $T = 0.02$。\n- 输出：计算分裂显式解与参考非分裂解在密度和速度上的离散 $\\ell^2$ 差异：$\\left(\\sum_i (\\rho^{\\mathrm{split}}_i - \\rho^{\\mathrm{ref}}_i)^2 \\Delta x\\right)^{1/2}$ 和 $\\left(\\sum_i (u^{\\mathrm{split}}_i - u^{\\mathrm{ref}}_i)^2 \\Delta x\\right)^{1/2}$。报告两个浮点数：密度误差和速度误差。\n\n案例 C (大外部时间步长下的稳定性和正定性):\n- 网格大小 $N = 200$。\n- 初始状态: $\\rho(x,0) = \\rho_0$, $u(x,0) = 0.2$, $p(x,0) = p_0$。\n- 分裂显式 CFL 数: $\\mathrm{CFL}_{\\mathrm{adv}} = 0.95$, $\\mathrm{CFL}_{\\mathrm{ac}} = 0.3$。\n- 最终时间 $T = 0.02$。\n- 输出：测试最终时间的密度和压力的正定性。如果所有单元的 $\\rho_i > 0$ 且 $p_i > 0$，则报告一个布尔值 true，否则报告 false。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，`[result1,result2,result3,...]`）。对于上述三个案例，按以下顺序汇总输出：案例 A 的三个浮点数，案例 B 的两个浮点数，案例 C 的一个布尔值。所有计算都是无量纲和无单位的；报告的输出中不需要物理单位。不出现角度；不使用百分比。通过使用守恒通量差分形式和稳定的 CFL 选择来确保科学真实性，并从提供的基本原理出发设计算法，而不使用快捷公式。该算法必须是自包含的，并且不得要求任何用户输入。",
            "solution": "我们从以守恒形式写出的一维可压缩欧拉方程开始，\n$$\n\\frac{\\partial U}{\\partial t} + \\frac{\\partial F(U)}{\\partial x} = 0,\n$$\n其中守恒变量为 $U = [\\rho, \\rho u, E]^{\\top}$，通量为\n$$\nF(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\nu (E + p)\n\\end{bmatrix}.\n$$\n状态方程为 $p = (\\gamma - 1)\\left(E - \\frac{1}{2}\\rho u^2\\right)$，其中 $\\gamma$ 是比热比。这些方程表达了可压缩理想气体的质量、动量和能量守恒。定义域是周期性的，并使用 $N$ 个单元进行均匀离散化，间距为 $\\Delta x = 1/N$，状态量 $U_i$ 定义在单元中心。\n\n分裂显式方法的基于原理的设计：\n- 快速声波传播源于可压缩性和压力梯度；这些与以速度 $c = \\sqrt{\\gamma p/\\rho}$ 传播的快速波相关联。\n- 慢速平流输运源于以速度 $u$ 进行的物质平流。\n- 分裂显式方法将这些过程的更新分离开，以允许一个受平流速度约束的较大外部时间步长和受声速约束的较小内部子步，从而在保持稳定性的同时降低计算成本。\n\n通量分裂：\n我们将通量分解为平流分量和声波分量，\n$$\nF(U) = F_{\\mathrm{adv}}(U) + F_{\\mathrm{ac}}(U),\n$$\n其中\n$$\nF_{\\mathrm{adv}}(U) = \\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 \\\\\nu E\n\\end{bmatrix}, \\quad\nF_{\\mathrm{ac}}(U) = \\begin{bmatrix}\n0 \\\\\np \\\\\nu p\n\\end{bmatrix}.\n$$\n这种分离将与压力相关的贡献 $(p, up)$ 从对流输运贡献 $(\\rho u, \\rho u^2, u E)$ 中隔离出来。注意，在连续性方程中，通量是 $\\rho u$，它完全包含在 $F_{\\mathrm{adv}}$ 中。因此，内部声波更新不直接改变质量；通过以通量差分形式执行所有更新，并将整个步长上的守恒贡献求和来确保守恒性。\n\n有限体积离散化：\n对于具有周期性边界的均匀网格，一个分量 $U$ 在一个时间步长 $\\Delta t$ 内的守恒更新为\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left(\\hat{F}_{i+\\frac{1}{2}} - \\hat{F}_{i-\\frac{1}{2}}\\right),\n$$\n其中 $\\hat{F}_{i+\\frac{1}{2}}$ 是单元 $i$ 和 $i+1$ 之间界面上的数值通量。我们使用局部 Lax–Friedrichs (Rusanov) 通量，该通量包含一个与界面处最大特征速度成正比的稳定耗散项。对于界面处的两个状态 $U_L$ 和 $U_R$，\n$$\n\\hat{F}(U_L, U_R; s) = \\frac{1}{2}\\left(F(U_L) + F(U_R)\\right) - \\frac{1}{2} s (U_R - U_L),\n$$\n其中 $s$ 是界面处的最大信号速度。对于完整的欧拉通量，一个典型的选择是 $s = \\max\\left(|u_L| + c_L, |u_R| + c_R\\right)$。对于平流通量，相关速度是 $|u|$，因此我们设置 $s_{\\mathrm{adv}} = \\max\\left(|u_L|, |u_R|\\right)$。对于声波通量，相关速度是 $c$，因此我们设置 $s_{\\mathrm{ac}} = \\max\\left(c_L, c_R\\right)$。由于 $F_{\\mathrm{ac}}$ 的质量分量为零，我们仅将声波 Rusanov 通量应用于动量和能量分量，以确保质量不会因声波内部步而被人为耗散。\n\n时间分裂：\n令外部时间步长满足平流 CFL 条件，\n$$\n\\Delta t_{\\mathrm{adv}} = \\mathrm{CFL}_{\\mathrm{adv}} \\frac{\\Delta x}{\\max_i |u_i| + \\epsilon},\n$$\n带有一个小的正则化项 $\\epsilon$ 以避免除以零。令声波子步长满足\n$$\n\\delta t_{\\mathrm{ac}}^{\\star} = \\mathrm{CFL}_{\\mathrm{ac}} \\frac{\\Delta x}{\\max_i c_i},\n$$\n并选择子步数\n$$\nM = \\left\\lceil \\frac{\\Delta t_{\\mathrm{adv}}}{\\delta t_{\\mathrm{ac}}^{\\star}} \\right\\rceil, \\quad \\delta t = \\frac{\\Delta t_{\\mathrm{adv}}}{M}.\n$$\n因此，$M$ 个大小为 $\\delta t$ 的子步覆盖了外部步长 $\\Delta t_{\\mathrm{adv}}$ 的持续时间。\n\n每个外部步的算法：\n1. 平流更新：\n$$\nU^{\\star}_i = U^n_i - \\frac{\\Delta t_{\\mathrm{adv}}}{\\Delta x}\\left(\\hat{F}_{\\mathrm{adv},\\,i+\\frac{1}{2}} - \\hat{F}_{\\mathrm{adv},\\,i-\\frac{1}{2}}\\right),\n$$\n其中 $\\hat{F}_{\\mathrm{adv}}$ 是使用 $F_{\\mathrm{adv}}$ 和 $s_{\\mathrm{adv}}$ 的 Rusanov 通量。\n2. 声波内部子步，对于 $m = 1, \\dots, M$：\n$$\nU^{\\star}_i \\leftarrow U^{\\star}_i - \\frac{\\delta t}{\\Delta x}\\left(\\hat{F}_{\\mathrm{ac},\\,i+\\frac{1}{2}} - \\hat{F}_{\\mathrm{ac},\\,i-\\frac{1}{2}}\\right),\n$$\n其中 $\\hat{F}_{\\mathrm{ac}}$ 使用 $F_{\\mathrm{ac}}$ 和 $s_{\\mathrm{ac}}$，仅应用于动量和能量分量； $U^{\\star}_i$ 的质量分量在这些内部步骤中保持不变。\n3. 设置 $U^{n+1}_i \\leftarrow U^{\\star}_i$。\n\n守恒性：\n每次更新都以通量差分的形式执行。对于周期性边界，整个定义域上的通量差分的伸缩求和对于平流步和声波步都为零。因此，每个子更新都能在浮点舍入误差范围内保持区域积分的守恒量。分裂显式组合通过构造是守恒的，因为它是由守恒更新组合而成的。\n\n稳定性：\n- 平流 CFL 条件根据 $|u|$ 控制外部步。\n- 声波 CFL 条件根据 $c$ 控制内部子步。\n使用具有适当信号速度的 Rusanov 通量可确保单调性并抑制伪振荡。对于足够小的 CFL 数和光滑数据，可以保持正定性。\n\n与非分裂参考方案的准确性对比：\n我们将分裂显式解与使用完整欧拉通量的非分裂一阶 Rusanov 格式进行比较，后者的一个小时间步长受限于 $\\max(|u|+c)$。密度和速度在 $\\ell^2$ 范数上的差异量化了由分裂引起的精度下降。\n\n实现细节：\n- 初始化基态 $\\rho_0 = 1$, $p_0 = 1$，带有振幅为 $\\varepsilon$ 的压力扰动和可选的均匀平均速度 $u_0$。\n- 计算 $E = \\frac{p}{\\gamma - 1} + \\frac{1}{2}\\rho u^2$。\n- 对界面通量使用周期性索引。\n- 通过迭代外部步来累积时间，直到达到 $T$；在每个外部步中，根据当前的 $c$ 重新计算 $M$。\n\n输出和测试套件：\n我们构建三个案例：\n- 案例 A：快速模式下的守恒性，报告三个浮点数：质量、动量和能量的绝对误差。\n- 案例 B：与具有非零平均流的非分裂参考方案的准确性对比，报告两个浮点数：密度和速度的 $\\ell^2$ 误差。\n- 案例 C：大外部步长下的稳定性和正定性，报告一个布尔值：如果最终时间所有密度和压力保持为正，则为 true。\n\n最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，顺序为：案例 A（三个浮点数），案例 B（两个浮点数），案例 C（一个布尔值）。所有计算都是无量纲和无单位的；不涉及角度和百分比。\n\n这种设计体现了大气模型中使用的分裂显式哲理，并通过在内部步中隔离快速声波物理过程，与半隐式和水平显式垂直隐式 (HEVI) 的思想相联系，尽管在这里我们是显式而非隐式地处理声波部分。守恒通量差分方法确保了科学真实性，并尊重了从欧拉方程导出的基本守恒定律。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Constants (nondimensional)\nGAMMA = 1.4\n\ndef primitive(U):\n    \"\"\"Convert conservative variables U=[rho, mom, E] to primitive [rho, u, p].\"\"\"\n    rho = U[0]\n    mom = U[1]\n    E = U[2]\n    u = mom / rho\n    kinetic = 0.5 * rho * u * u\n    p = (GAMMA - 1.0) * (E - kinetic)\n    return rho, u, p\n\ndef sound_speed(rho, p):\n    \"\"\"Compute sound speed c = sqrt(gamma * p / rho).\"\"\"\n    return np.sqrt(GAMMA * np.maximum(p, 0.0) / np.maximum(rho, 1e-15))\n\ndef flux_full(U):\n    \"\"\"Full Euler flux F(U).\"\"\"\n    rho, u, p = primitive(U)\n    F = np.zeros_like(U)\n    F[0] = rho * u\n    F[1] = rho * u * u + p\n    F[2] = u * (E(U) + p)\n    return F\n\ndef E(U):\n    \"\"\"Return energy E from conservative state U.\"\"\"\n    return U[2]\n\ndef flux_adv(U):\n    \"\"\"Advective flux F_adv(U) = [rho u, rho u^2, u E].\"\"\"\n    rho, u, p = primitive(U)\n    F = np.zeros_like(U)\n    F[0] = rho * u\n    F[1] = rho * u * u\n    F[2] = u * E(U)\n    return F\n\ndef flux_acoustic(U):\n    \"\"\"Acoustic flux F_ac(U) = [0, p, u p].\"\"\"\n    rho, u, p = primitive(U)\n    F = np.zeros_like(U)\n    F[0] = 0.0\n    F[1] = p\n    F[2] = u * p\n    return F\n\ndef rusanov_flux_adv(UL, UR):\n    \"\"\"Rusanov flux for advective part with speed based on |u|.\"\"\"\n    # Flux average\n    FaL = flux_adv(UL)\n    FaR = flux_adv(UR)\n    rhoL, uL, pL = primitive(UL)\n    rhoR, uR, pR = primitive(UR)\n    s = max(abs(uL), abs(uR))\n    return 0.5 * (FaL + FaR) - 0.5 * s * (UR - UL)\n\ndef rusanov_flux_acoustic(UL, UR):\n    \"\"\"Rusanov flux for acoustic part with speed based on c.\n    Apply diffusion only to momentum and energy components; mass component is zero.\"\"\"\n    FaL = flux_acoustic(UL)\n    FaR = flux_acoustic(UR)\n    rhoL, uL, pL = primitive(UL)\n    rhoR, uR, pR = primitive(UR)\n    cL = np.sqrt(GAMMA * max(pL, 0.0) / max(rhoL, 1e-15))\n    cR = np.sqrt(GAMMA * max(pR, 0.0) / max(rhoR, 1e-15))\n    s = max(cL, cR)\n    flux = 0.5 * (FaL + FaR)\n    # Add Rusanov dissipation only to momentum and energy components\n    diff = 0.5 * s * (UR - UL)\n    flux[1] -= diff[1]\n    flux[2] -= diff[2]\n    # flux[0] remains zero for acoustic part\n    return flux\n\ndef compute_dt_adv(U, dx, cfl_adv):\n    \"\"\"Compute advective outer time step based on max |u|.\"\"\"\n    rho = U[:, 0]\n    mom = U[:, 1]\n    u = mom / rho\n    umax = np.max(np.abs(u))\n    # Regularization to avoid dt -> inf when umax == 0\n    return cfl_adv * dx / max(umax, 1e-12)\n\ndef compute_dt_acoustic(U, dx, cfl_ac):\n    \"\"\"Compute acoustic dt based on max sound speed.\"\"\"\n    rho = U[:, 0]\n    mom = U[:, 1]\n    E_ = U[:, 2]\n    u = mom / rho\n    kinetic = 0.5 * rho * u * u\n    p = (GAMMA - 1.0) * (E_ - kinetic)\n    c = np.sqrt(GAMMA * np.maximum(p, 0.0) / np.maximum(rho, 1e-15))\n    cmax = np.max(c)\n    return cfl_ac * dx / max(cmax, 1e-12)\n\ndef advective_update(U, dx, dt):\n    \"\"\"One conservative advective update using Rusanov flux for F_adv.\"\"\"\n    N = U.shape[0]\n    # Periodic extension for interfaces\n    UL = U\n    UR = np.roll(U, -1, axis=0)\n    F = np.zeros_like(U)\n    # Compute interface fluxes\n    F_interfaces = np.array([rusanov_flux_adv(UL[i], UR[i]) for i in range(N)])\n    # Flux divergence\n    F_right = F_interfaces\n    F_left = np.roll(F_interfaces, 1, axis=0)\n    dU = -(dt / dx) * (F_right - F_left)\n    return U + dU\n\ndef acoustic_update(U, dx, dt):\n    \"\"\"One conservative acoustic update using Rusanov flux for F_ac.\n    Only momentum and energy are updated; mass is not modified.\"\"\"\n    N = U.shape[0]\n    UL = U\n    UR = np.roll(U, -1, axis=0)\n    F_interfaces = np.array([rusanov_flux_acoustic(UL[i], UR[i]) for i in range(N)])\n    F_right = F_interfaces\n    F_left = np.roll(F_interfaces, 1, axis=0)\n    dU = -(dt / dx) * (F_right - F_left)\n    # Ensure mass component is unchanged (since acoustic flux mass component is zero)\n    dU[:, 0] = 0.0\n    return U + dU\n\ndef full_rusanov_update(U, dx, dt):\n    \"\"\"One unsplit full Euler update using Rusanov flux with s = |u| + c.\"\"\"\n    N = U.shape[0]\n    UL = U\n    UR = np.roll(U, -1, axis=0)\n    F_interfaces = np.zeros_like(U)\n    for i in range(N):\n        rhoL, uL, pL = primitive(UL[i])\n        rhoR, uR, pR = primitive(UR[i])\n        cL = np.sqrt(GAMMA * max(pL, 0.0) / max(rhoL, 1e-15))\n        cR = np.sqrt(GAMMA * max(pR, 0.0) / max(rhoR, 1e-15))\n        s = max(abs(uL) + cL, abs(uR) + cR)\n        FL = flux_full(UL[i])\n        FR = flux_full(UR[i])\n        F_interfaces[i] = 0.5 * (FL + FR) - 0.5 * s * (UR[i] - UL[i])\n    F_right = F_interfaces\n    F_left = np.roll(F_interfaces, 1, axis=0)\n    dU = -(dt / dx) * (F_right - F_left)\n    return U + dU\n\ndef initialize_state(N, eps, u0, perturb_pressure=True):\n    \"\"\"Initialize U on x in [0,1] with base rho0=1, p0=1 and sinusoidal pressure perturbation.\"\"\"\n    x = (np.arange(N) + 0.5) / N\n    rho0 = 1.0\n    p0 = 1.0\n    if perturb_pressure:\n        p = p0 * (1.0 + eps * np.sin(2.0 * np.pi * x))\n    else:\n        p = p0 * np.ones_like(x)\n    rho = rho0 * np.ones_like(x)\n    u = u0 * np.ones_like(x)\n    E = p / (GAMMA - 1.0) + 0.5 * rho * u * u\n    U = np.stack([rho, rho * u, E], axis=1)\n    return U\n\ndef totals(U, dx):\n    \"\"\"Compute domain-integrated totals for mass, momentum, energy.\"\"\"\n    mass = np.sum(U[:, 0]) * dx\n    mom = np.sum(U[:, 1]) * dx\n    energy = np.sum(U[:, 2]) * dx\n    return mass, mom, energy\n\ndef split_explicit_integrate(U0, Nsteps_outer, dx, cfl_adv, cfl_ac):\n    \"\"\"Integrate using split-explicit scheme for Nsteps_outer outer steps.\"\"\"\n    U = U0.copy()\n    for _ in range(Nsteps_outer):\n        # Advective step\n        dt_adv = compute_dt_adv(U, dx, cfl_adv)\n        U = advective_update(U, dx, dt_adv)\n        # Acoustic inner steps\n        dt_ac_star = compute_dt_acoustic(U, dx, cfl_ac)\n        M = int(np.ceil(dt_adv / max(dt_ac_star, 1e-15)))\n        dt_sub = dt_adv / max(M, 1)\n        for _m in range(M):\n            U = acoustic_update(U, dx, dt_sub)\n    return U\n\ndef integrate_to_time_split(U0, T, dx, cfl_adv, cfl_ac):\n    \"\"\"Integrate split-explicit scheme until time T by repeated outer steps.\"\"\"\n    U = U0.copy()\n    t = 0.0\n    # Use at least one outer step; loop until reaching or exceeding T\n    while t  T - 1e-14:\n        dt_adv = compute_dt_adv(U, dx, cfl_adv)\n        # Cap to not overshoot T significantly\n        if t + dt_adv > T:\n            dt_adv = T - t\n        # Perform advective update\n        U = advective_update(U, dx, dt_adv)\n        # Acoustic inner steps over dt_adv\n        dt_ac_star = compute_dt_acoustic(U, dx, cfl_ac)\n        M = int(np.ceil(dt_adv / max(dt_ac_star, 1e-15)))\n        dt_sub = dt_adv / max(M, 1)\n        for _ in range(M):\n            U = acoustic_update(U, dx, dt_sub)\n        t += dt_adv\n    return U\n\ndef integrate_to_time_unsplit(U0, T, dx, cfl_ref):\n    \"\"\"Integrate full Rusanov scheme until time T.\"\"\"\n    U = U0.copy()\n    t = 0.0\n    while t  T - 1e-14:\n        # dt based on max(|u| + c)\n        rho = U[:, 0]\n        u = U[:, 1] / rho\n        p = (GAMMA - 1.0) * (U[:, 2] - 0.5 * rho * u * u)\n        c = np.sqrt(GAMMA * np.maximum(p, 0.0) / np.maximum(rho, 1e-15))\n        smax = np.max(np.abs(u) + c)\n        dt = cfl_ref * dx / max(smax, 1e-12)\n        if t + dt > T:\n            dt = T - t\n        U = full_rusanov_update(U, dx, dt)\n        t += dt\n    return U\n\ndef case_A():\n    \"\"\"Case A: conservation under fast modes.\"\"\"\n    N = 200\n    dx = 1.0 / N\n    eps = 1e-4\n    u0 = 0.0\n    cfl_adv = 0.9\n    cfl_ac = 0.3\n    T = 0.02\n    U0 = initialize_state(N, eps, u0, perturb_pressure=True)\n    mass0, mom0, energy0 = totals(U0, dx)\n    Uf = integrate_to_time_split(U0, T, dx, cfl_adv, cfl_ac)\n    massf, momf, energyf = totals(Uf, dx)\n    err_mass = abs(massf - mass0)\n    err_mom = abs(momf - mom0)\n    err_energy = abs(energyf - energy0)\n    return err_mass, err_mom, err_energy\n\ndef case_B():\n    \"\"\"Case B: accuracy versus unsplit reference with nonzero mean flow.\"\"\"\n    N = 200\n    dx = 1.0 / N\n    eps = 1e-4\n    u0 = 0.5\n    cfl_adv = 0.9\n    cfl_ac = 0.3\n    cfl_ref = 0.3\n    T = 0.02\n    U0 = initialize_state(N, eps, u0, perturb_pressure=True)\n    U_split = integrate_to_time_split(U0, T, dx, cfl_adv, cfl_ac)\n    U_ref = integrate_to_time_unsplit(U0, T, dx, cfl_ref)\n    # Compute L2 errors for rho and u\n    rho_split = U_split[:, 0]\n    u_split = U_split[:, 1] / rho_split\n    rho_ref = U_ref[:, 0]\n    u_ref = U_ref[:, 1] / rho_ref\n    err_rho = np.sqrt(np.sum((rho_split - rho_ref) ** 2) * dx)\n    err_u = np.sqrt(np.sum((u_split - u_ref) ** 2) * dx)\n    return err_rho, err_u\n\ndef case_C():\n    \"\"\"Case C: stability and positivity under large outer time step.\"\"\"\n    N = 200\n    dx = 1.0 / N\n    eps = 0.0\n    u0 = 0.2\n    cfl_adv = 0.95\n    cfl_ac = 0.3\n    T = 0.02\n    U0 = initialize_state(N, eps, u0, perturb_pressure=False)\n    Uf = integrate_to_time_split(U0, T, dx, cfl_adv, cfl_ac)\n    rho = Uf[:, 0]\n    u = Uf[:, 1] / rho\n    p = (GAMMA - 1.0) * (Uf[:, 2] - 0.5 * rho * u * u)\n    positivity = bool(np.all(rho > 0.0) and np.all(p > 0.0))\n    return positivity\n\ndef solve():\n    # Define the test cases from the problem statement.\n    results = []\n    # Case A: three floats\n    err_mass, err_mom, err_energy = case_A()\n    results.extend([err_mass, err_mom, err_energy])\n    # Case B: two floats\n    err_rho, err_u = case_B()\n    results.extend([err_rho, err_u])\n    # Case C: one boolean\n    pos_ok = case_C()\n    # Convert boolean to 'True'/'False' string in final print via str()\n    results.append(pos_ok)\n    # Final print statement in the exact required format.\n    # Ensure consistent formatting: floats and booleans printed as str()\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}