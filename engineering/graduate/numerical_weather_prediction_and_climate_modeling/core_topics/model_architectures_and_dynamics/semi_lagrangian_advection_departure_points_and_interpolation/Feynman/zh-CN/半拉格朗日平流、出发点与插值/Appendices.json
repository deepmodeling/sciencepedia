{
    "hands_on_practices": [
        {
            "introduction": "半拉格朗日方法的核心在于插值过程，而插值方案的选择直接决定了数值模拟的准确性。本练习旨在为理解插值误差奠定定量基础，通过分析不同阶数的插值方案在平流输送一个简单的正弦波时，如何影响波的两个关键特性——振幅（对应数值耗散）和相位（对应数值频散）。通过这个练习，您将亲手量化这些误差，从而对不同插值方案的性能有更直观的认识。",
            "id": "4087321",
            "problem": "考虑周期性域上的被动标量场 $q(x,t)$ 的一维（$1$D）线性平流方程，\n$$\n\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = 0,\n$$\n其中速度 $u$ 为常数。特征线法表明，解沿着满足 $dx/dt = u$ 的轨迹线是恒定的。在半拉格朗日（SL）时间步进法中，时间 $t^{n+1}$ 时到达（Eulerian）网格点 $x_i$ 处的值，是从时间 $t^n$ 时相应出发点 $x_d$ 处的值获得的，即：\n$$\nq^{n+1}(x_i) \\approx \\mathcal{I}\\left[q^n\\right](x_d),\n$$\n其中 $\\mathcal{I}$ 表示应用于 $x_d$ 处离散场 $q^n$ 的插值算子。对于恒定的 $u$，精确的出发点是\n$$\nx_d = x_i - u \\,\\Delta t,\n$$\n并假设采用周期性边界条件。将无量纲的库朗数定义为\n$$\nC = \\frac{u \\,\\Delta t}{\\Delta x},\n$$\n其中 $\\Delta x$ 是均匀的网格间距。初始条件是单个正弦傅里叶模态，\n$$\nq(x,0) = \\sin\\left(k x\\right), \\quad k = \\frac{2\\pi m}{L},\n$$\n在一个长度为 $L$ 的周期性域上，该域被离散化为 $M$ 个等距点 $x_i = i\\,\\Delta x$，其中 $\\Delta x = L/M$ 且 $i \\in \\{0,1,\\dots,M-1\\}$。在时间 $\\Delta t$ 时的精确解是一个纯粹的平移 $q_{\\text{exact}}(x,\\Delta t) = \\sin\\left(k\\left(x - u \\Delta t\\right)\\right)$，它保持振幅不变，并引入精确的相移 $-k\\,u\\,\\Delta t$。\n\n你的任务是为恒定速度 $u$ 实现一个单步半拉格朗日输运，并对单个时间步 $\\Delta t$ 进行量化：\n- 振幅误差（无量纲），定义为 SL 步长后数值测量的模态振幅与初始模态单位振幅之差。\n- 相位误差（以弧度为单位），定义为平流后模态的数值测量相位与精确相移 $-k\\,u\\,\\Delta t$ 之差，并将结果折叠到区间 $[-\\pi,\\pi]$ 内。\n\n使用以下插值阶数 $p$：\n- $p=0$：最近邻插值（选择离 $x_d$ 最近的网格点）。\n- $p=1$：线性插值，使用 $x_d$ 周围的两个相邻网格点。\n- $p=2$：二次 Lagrange 插值，使用 $x_d$ 周围的三个点 $\\{i_0-1,i_0,i_0+1\\}$，其中 $i_0 = \\lfloor x_d/\\Delta x \\rfloor$，小数位置为 $\\alpha = x_d/\\Delta x - i_0$。\n- $p=3$：三次 Lagrange 插值，使用 $x_d$ 周围的四个点 $\\{i_0-1,i_0,i_0+1,i_0+2\\}$。\n\n为了在网格点上测量数值输运模态 $q_{\\text{num}}(x_i)$ 的振幅和相位，请使用与基函数 $\\sin(k x_i)$ 和 $\\cos(k x_i)$ 的离散内积：\n$$\nA_{\\text{num}} = \\frac{2}{M} \\sum_{i=0}^{M-1} q_{\\text{num}}(x_i) \\sin(k x_i), \\quad\nB_{\\text{num}} = \\frac{2}{M} \\sum_{i=0}^{M-1} q_{\\text{num}}(x_i) \\cos(k x_i).\n$$\n将数值测量的振幅和相位定义为\n$$\nR_{\\text{num}} = \\sqrt{A_{\\text{num}}^2 + B_{\\text{num}}^2}, \\quad\n\\phi_{\\text{num}} = \\operatorname{atan2}\\left(B_{\\text{num}}, A_{\\text{num}}\\right),\n$$\n并将精确相移定义为\n$$\n\\phi_{\\text{exact}} = -k\\,u\\,\\Delta t.\n$$\n报告振幅误差为 $R_{\\text{num}} - 1$（无量纲），并将相位误差（以弧度为单位）报告为折叠后的差值\n$$\n\\Delta \\phi = \\left(\\phi_{\\text{num}} - \\phi_{\\text{exact}}\\right) \\text{ wrapped to } [-\\pi,\\pi].\n$$\n\n物理和数值参数：\n- 域长度 $L = 1000$ 米。\n- 网格点数 $M = 512$（均匀网格）。\n- 模态数 $m = 5$（因此 $k = 2\\pi m/L$）。\n- 恒定速度 $u = 10$ 米/秒。\n- 每个测试案例规定库朗数 $C$，且 $\\Delta t = C\\,\\Delta x / u$。\n- 用于索引和插值的周期性边界条件。\n\n角度单位：以弧度报告相位误差。振幅误差是无量纲的。所有数值输出均表示为四舍五入到 $8$ 位小数的浮点小数。\n\n测试套件：\n计算以下 $(p,C)$ 案例的（振幅误差, 相位误差）对，每个案例都进行单个 SL 步长：\n- 案例 1：$(p=1, C=0.25)$。\n- 案例 2：$(p=3, C=0.50)$。\n- 案例 3：$(p=0, C=0.95)$。\n- 案例 4：$(p=2, C=1.00)$。\n- 案例 5：$(p=1, C=0.00)$。\n- 案例 6：$(p=3, C=0.75)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个测试案例的结果本身就是一个按 $[\\text{振幅误差},\\text{相位误差}]$ 顺序排列的双元素列表。例如，\n$$\n\\text{\"[[e_{1,a},e_{1,\\phi}],[e_{2,a},e_{2,\\phi}],\\dots,[e_{6,a},e_{6,\\phi}]]\"}\n$$\n所有浮点值都四舍五入到 $8$ 位小数。",
            "solution": "经评估，用户提供的问题是有效的，因为它具有科学依据、数学上适定，并且没有内部矛盾或歧义。它提出了一个涉及半拉格朗日平流方案的标准数值分析任务。我们现在将着手提供一个完整的解决方案。\n\n该问题要求为线性平流方程实现和分析一个一维半拉格朗日（SL）平流方案，\n$$\n\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = 0,\n$$\n在一个长度为 $L = 1000$ 米、速度恒为 $u = 10$ 米/秒的周期性域上。初始条件是单个正弦模态：\n$$\nq(x,0) = \\sin(kx), \\quad \\text{where } k = \\frac{2\\pi m}{L} \\text{ with } m=5.\n$$\n\n该域被离散化为 $M = 512$ 个网格点 $x_i = i \\Delta x$，$i \\in \\{0, 1, \\dots, M-1\\}$，其中网格间距为 $\\Delta x = L/M$。因此，初始离散场为 $q^0_i = \\sin(k x_i)$。\n\n半拉格朗日方法的核心原理是，通过将特征线在时间上向后追溯到时间 $t^n$ 时的出发点 $x_d$，来找到新时间 $t^{n+1} = t^n + \\Delta t$ 时网格点 $x_i$ 处的值。对于恒定速度 $u$，该出发点由以下公式给出：\n$$\nx_d = x_i - u \\Delta t.\n$$\n使用库朗数 $C = u \\Delta t / \\Delta x$，这可以用网格间距表示为：\n$$\nx_d = x_i - C \\Delta x.\n$$\n解的值沿着特征线是恒定的，因此 $q(x_i, t^{n+1}) = q(x_d, t^n)$。由于 $x_d$ 通常不是网格点，其值必须通过对已知的 $q^n$ 的网格点值进行插值来获得。因此，数值方案是：\n$$\nq^{n+1}_i = \\mathcal{I}[q^n](x_d),\n$$\n其中 $\\mathcal{I}$ 是一个插值算子。我们从 $q^0$ 开始，为单个时间步长实现此方案。\n\n为了执行插值，我们首先对出发点的坐标进行归一化，$s_d = x_d / \\Delta x$。令 $i_0 = \\lfloor s_d \\rfloor$ 为紧邻 $x_d$ 左侧（或位于 $x_d$）的网格点的索引，并令 $\\alpha = s_d - i_0$ 为距 $x_{i_0}$ 的小数距离。根据构造，$0 \\le \\alpha  1$。值 $q_i^{1}$ 使用四种指定的插值方案之一进行计算，所有这些方案在访问网格数据时都必须遵守域的周期性（即，索引对 $M$ 取模）。\n\n1.  **最近邻插值（$p=0$）：** 此方案取空间上最接近的网格点的值。插值结果为 $q^0_j$，其中 $j$ 是离 $x_d$ 最近的网格点的索引。这是通过将归一化坐标 $s_d$ 四舍五入到最近的整数来实现的：$j = \\text{round}(s_d)$。\n2.  **线性插值（$p=1$）：** 此方案使用包围 $x_d$ 的两个网格点，即 $x_{i_0}$ 和 $x_{i_0+1}$。插值结果是一个加权平均值：\n    $$\n    \\mathcal{I}[q^0](x_d) = (1-\\alpha) q^0_{i_0} + \\alpha q^0_{i_0+1}.\n    $$\n3.  **二次 Lagrange 插值（$p=2$）：** 此方案使用一个三点模板，指定为 $\\{i_0-1, i_0, i_0+1\\}$。插值结果由通过 $(x_{i_0-1}, q^0_{i_0-1})$、$(x_{i_0}, q^0_{i_0})$ 和 $(x_{i_0+1}, q^0_{i_0+1})$ 的 Lagrange 多项式在 $x_d$ 处求值得到。这等价于：\n    $$\n    \\mathcal{I}[q^0](x_d) = L_{-1}(\\alpha)q^0_{i_0-1} + L_0(\\alpha)q^0_{i_0} + L_1(\\alpha)q^0_{i_0+1},\n    $$\n    其中，对于由 $\\{-1, 0, 1\\}$ 进行局部索引的模板点，Lagrange 基多项式为：\n    $$\n    L_{-1}(\\alpha) = \\frac{\\alpha(\\alpha-1)}{2}, \\quad L_0(\\alpha) = 1 - \\alpha^2, \\quad L_1(\\alpha) = \\frac{\\alpha(\\alpha+1)}{2}.\n    $$\n4.  **三次 Lagrange 插值（$p=3$）：** 此方案使用一个四点模板，指定为 $\\{i_0-1, i_0, i_0+1, i_0+2\\}$。插值结果为：\n    $$\n    \\mathcal{I}[q^0](x_d) = L_{-1}(\\alpha)q^0_{i_0-1} + L_0(\\alpha)q^0_{i_0} + L_1(\\alpha)q^0_{i_0+1} + L_2(\\alpha)q^0_{i_0+2},\n    $$\n    其中，对于局部模板 $\\{-1, 0, 1, 2\\}$，基多项式为：\n    $$\n    L_{-1}(\\alpha) = -\\frac{\\alpha(\\alpha-1)(\\alpha-2)}{6}, \\quad L_0(\\alpha) = \\frac{(\\alpha+1)(\\alpha-1)(\\alpha-2)}{2},\n    $$\n    $$\n    L_1(\\alpha) = -\\frac{\\alpha(\\alpha+1)(\\alpha-2)}{2}, \\quad L_2(\\alpha) = \\frac{\\alpha(\\alpha+1)(\\alpha-1)}{6}.\n    $$\n\n在计算出所有 $i \\in \\{0, \\dots, M-1\\}$ 的数值解 $q^1_{\\text{num}}(x_i)$ 后，我们分析其精度。时间 $\\Delta t$ 后的精确解是初始波的一个简单相移：$q_{\\text{exact}}(x, \\Delta t) = \\sin(k(x-u\\Delta t)) = \\sin(kx - \\phi_{\\text{exact}})$，其中精确相移为 $\\phi_{\\text{exact}} = k u \\Delta t$。请注意，问题将精确相移定义为 $\\phi_{\\text{exact}} = -k u \\Delta t$，这是应用于正弦函数参数的相移。我们将遵循此定义。由于插值误差，数值解可以写为 $q^1_{\\text{num}} \\approx R_{\\text{num}} \\sin(kx - \\phi_{\\text{num}})$。为了找到数值振幅 $R_{\\text{num}}$ 和相位 $\\phi_{\\text{num}}$，我们使用离散傅里叶和将数值解投影到正交基函数 $\\sin(kx)$ 和 $\\cos(kx)$ 上：\n$$\nA_{\\text{num}} = \\frac{2}{M} \\sum_{i=0}^{M-1} q^1_{\\text{num}}(x_i) \\sin(k x_i), \\quad\nB_{\\text{num}} = \\frac{2}{M} \\sum_{i=0}^{M-1} q^1_{\\text{num}}(x_i) \\cos(k x_i).\n$$\n根据这些系数，我们找到数值振幅和相位：\n$$\nR_{\\text{num}} = \\sqrt{A_{\\text{num}}^2 + B_{\\text{num}}^2}, \\quad\n\\phi_{\\text{num}} = \\operatorname{atan2}\\left(B_{\\text{num}}, A_{\\text{num}}\\right).\n$$\n问题将精确相位指定为 $\\phi_{\\text{exact}} = -k u \\Delta t$。通过 atan2 计算得出的数值相位对应于波的相位，因此波 $\\sin(kx - \\phi_n)$ 将被检测为具有相位 $\\phi_n = \\text{atan2}(-\\text{cos 的系数}, \\text{sin 的系数})$。此处使用定义可得 $\\sin(kx+\\phi_{num}) = \\sin(kx)\\cos(\\phi_{num}) + \\cos(kx)\\sin(\\phi_{num})$，并将 $A_{num} \\approx R_{num}\\cos(\\phi_{num})$ 和 $B_{num} \\approx R_{num}\\sin(\\phi_{num})$ 关联起来，因此 $\\phi_{num} = \\operatorname{atan2}(B_{num}, A_{num})$ 是正确的。振幅误差是与初始单位振幅的偏差，即 $R_{\\text{num}} - 1$。相位误差是数值相移与精确相移之差，即 $\\Delta \\phi = \\phi_{\\text{num}} - \\phi_{\\text{exact}}$。此差值使用操作 $\\Delta\\phi_{\\text{wrapped}} = (\\Delta\\phi + \\pi) \\pmod{2\\pi} - \\pi$ 折叠到区间 $[-\\pi, \\pi]$ 内。\n\n该算法通过遍历每个测试案例 $(p, C)$ 来进行，通过指定的插值计算数值解 $q^1_{\\text{num}}$，然后如上所述计算振幅和相位误差。最终结果四舍五入到 $8$ 位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    # Final answer code as per problem specification.\n    \n    # Physical and numerical parameters\n    L = 1000.0  # Domain length in meters\n    M = 512     # Number of grid points\n    m = 5       # Mode number\n    u = 10.0    # Constant velocity in meters per second\n\n    # Derived parameters\n    dx = L / M\n    k = 2.0 * np.pi * m / L\n    x_grid = np.arange(M) * dx\n    q_initial = np.sin(k * x_grid)\n\n    # Test suite\n    test_cases = [\n        # (p, C) where p is interpolation order and C is Courant number\n        (1, 0.25),\n        (3, 0.50),\n        (0, 0.95),\n        (2, 1.00),\n        (1, 0.00),\n        (3, 0.75),\n    ]\n\n    results = []\n\n    for p, C in test_cases:\n        dt = C * dx / u\n        q_numerical = np.zeros(M)\n        \n        # --- Semi-Lagrangian Advection Step ---\n        # This loop calculates the advected field q_numerical.\n        for i in range(M):\n            # Calculate departure point for arrival grid point x_grid[i]\n            x_d = x_grid[i] - u * dt\n            \n            # Normalize departure point and find stencil base index/fractional part\n            s_d = x_d / dx\n            i0 = int(np.floor(s_d))\n            alpha = s_d - i0\n\n            # --- Interpolation ---\n            # Indices are taken modulo M to enforce periodic boundary conditions.\n            if p == 0:  # Nearest-neighbor interpolation\n                idx = int(np.floor(s_d + 0.5))\n                q_numerical[i] = q_initial[idx % M]\n            elif p == 1:  # Linear interpolation\n                q0 = q_initial[i0 % M]\n                q1 = q_initial[(i0 + 1) % M]\n                q_numerical[i] = (1.0 - alpha) * q0 + alpha * q1\n            elif p == 2:  # Quadratic Lagrange interpolation\n                q_m1 = q_initial[(i0 - 1) % M]\n                q_0 = q_initial[i0 % M]\n                q_1 = q_initial[(i0 + 1) % M]\n\n                L_m1 = alpha * (alpha - 1.0) / 2.0\n                L_0 = 1.0 - alpha**2\n                L_1 = alpha * (alpha + 1.0) / 2.0\n                \n                q_numerical[i] = L_m1 * q_m1 + L_0 * q_0 + L_1 * q_1\n            elif p == 3:  # Cubic Lagrange interpolation\n                q_m1 = q_initial[(i0 - 1) % M]\n                q_0 = q_initial[i0 % M]\n                q_1 = q_initial[(i0 + 1) % M]\n                q_2 = q_initial[(i0 + 2) % M]\n\n                L_m1 = -alpha * (alpha - 1.0) * (alpha - 2.0) / 6.0\n                L_0 = (alpha + 1.0) * (alpha - 1.0) * (alpha - 2.0) / 2.0\n                L_1 = -(alpha + 1.0) * alpha * (alpha - 2.0) / 2.0\n                L_2 = (alpha + 1.0) * alpha * (alpha - 1.0) / 6.0\n                \n                q_numerical[i] = L_m1 * q_m1 + L_0 * q_0 + L_1 * q_1 + L_2 * q_2\n\n        # --- Error Analysis ---\n        # Project numerical solution onto sin/cos basis to find amplitude and phase\n        sin_basis = np.sin(k * x_grid)\n        cos_basis = np.cos(k * x_grid)\n        \n        A_num = (2.0 / M) * np.dot(q_numerical, sin_basis)\n        B_num = (2.0 / M) * np.dot(q_numerical, cos_basis)\n        \n        R_num = np.sqrt(A_num**2 + B_num**2)\n        phi_num = np.arctan2(B_num, A_num)\n\n        # Calculate exact phase shift\n        phi_exact = -k * u * dt\n\n        # Calculate amplitude and phase errors\n        amp_error = R_num - 1.0\n        phase_error = phi_num - phi_exact\n        \n        # Wrap phase error to the interval [-pi, pi]\n        phase_error = (phase_error + np.pi) % (2.0 * np.pi) - np.pi\n        \n        # Append rounded results for this test case\n        results.append([round(amp_error, 8), round(phase_error, 8)])\n\n    # Format the final output string as a list of lists.\n    # e.g., [[err_a1,err_p1],[err_a2,err_p2],...]\n    formatted_results = [f\"[{res[0]:.8f},{res[1]:.8f}]\" for res in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "尽管高阶多项式插值对于光滑场的模拟非常精确，但在处理陡峭梯度或不连续性时，它会产生被称为“吉布斯现象”的非物理解振荡。本练习将理论转向一个更具挑战性的实际问题，展示高阶方案在平流一个阶梯函数时的失效模式。您的任务是设计并实现一种混合方案，它能自动检测场的不光滑区域，并在这些区域切换到更稳定、虽阶数较低但能保持单调性的插值方法。",
            "id": "4087372",
            "problem": "考虑在数值天气预报 (NWP) 和气候模拟背景下的一维半拉格朗日平流。半拉格朗日 (SL) 方法通过随时间反向追踪流体质点的轨迹来推进标量示踪剂。设示踪剂为函数 $q(x,t)$，速度为常数 $u$。控制平流方程为\n$$\n\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = 0,\n$$\n在长度为 $L$ 的周期性域上。在均匀网格 $x_i = i\\,\\Delta x$（其中整数 $i \\in \\{0,\\dots,N-1\\}$）上，从时间 $t^n$ 到 $t^{n+1}=t^n+\\Delta t$ 的单个 SL 时间步长中，到达点 $x_i$ 从位于以下位置的出发点获得示踪剂 $q_i^{n+1}$\n$$\nx_d = x_i - u \\Delta t \\quad \\text{通过周期性处理映射到 } [0,L)。\n$$\n为评估 $q^n(x_d)$，在均匀网格上使用多项式插值。在非光滑区域进行高阶多项式插值可能会在不连续点附近表现出类似 Gibbs 的振荡。您的任务是在 SL 设置中实现并分析此现象，并设计一个准则，在检测到的非光滑区域附近切换到低阶模板。\n\n从由 $\\frac{dx}{dt} = u$ 控制的轨迹的基本定义和均匀网格上多项式近似的插值定义出发，执行以下操作：\n\n- 在周期性域上实现一个单步半拉格朗日方案，该方案对于每个到达网格索引 $i$，计算出发位置 $x_d$，选择一个中心基准索引 $i_0 = \\lfloor x_d / \\Delta x \\rfloor$，并通过以下方式评估 $q^n(x_d)$：\n  - 使用在节点 $\\{i_0-2, i_0-1, i_0, i_0+1, i_0+2\\}$ 上的 $5$ 点 Lagrange 多项式进行高阶插值。\n  - 使用在节点 $\\{i_0, i_0+1\\}$ 上的 $2$ 点线性模板进行低阶插值。\n- 设计并实现一个检测准则，仅使用 $q^n$ 的网格点值来标记出发索引 $i_0$ 附近的局部非光滑性。使用归一化的二阶差分指示器\n$$\nS(i_0) = \\frac{\\left| q^n_{i_0+1} - 2 q^n_{i_0} + q^n_{i_0-1} \\right|}{\\left| q^n_{i_0+1} - q^n_{i_0} \\right| + \\left| q^n_{i_0} - q^n_{i_0-1} \\right| + \\varepsilon},\n$$\n其中 $\\varepsilon$ 是一个小的正数，以避免除以零。当 $S(i_0)$ 超过阈值 $\\tau$ 时，将该到达点的插值切换到低阶模板；否则，使用 $5$ 点 Lagrange 模板。\n- 对所有索引操作使用周期性边界条件，即，将 $q^n_{i}$ 按模 $N$ 解释。\n\n使用过冲度量来量化振荡，对于单个 SL 步长，其定义为\n$$\n\\text{overshoot}(q^{n+1}; q^n) = \\max\\left( \\max_i q^{n+1}_i - \\max_j q^n_j, \\ \\min_j q^n_j - \\min_i q^{n+1}_i, \\ 0 \\right),\n$$\n该度量衡量到达场超出出发场全局范围的幅度。\n\n实现两个变体：\n- 一个仅使用高阶插值且不切换的变体。\n- 一个使用上述检测准则和阈值 $\\tau$ 的切换变体。\n\n对于下方的每个测试用例，计算：\n- 仅高阶变体的过冲值。\n- 切换变体的过冲值。\n- 被检测准则标记的到达网格点数（即，在切换变体中 $S(i_0)  \\tau$ 的点）。\n\n使用具有 $N$ 个网格点和均匀间距 $\\Delta x$ 的周期性域，因此 $L = N \\Delta x$。使用单个恒定速度 $u$ 和单个时间步长 $\\Delta t$。所有物理量必须使用以下单位处理：\n- 速度 $u$ 单位为 $\\mathrm{m/s}$。\n- 网格间距 $\\Delta x$ 单位为 $\\mathrm{m}$。\n- 时间步长 $\\Delta t$ 单位为 $\\mathrm{s}$。\n将过冲值表示为十进制小数。\n\n测试套件：\n- 案例 1 (理想路径, 光滑): $N = 128$, $\\Delta x = 1000\\,\\mathrm{m}$, $L = N \\Delta x$, $u = 50\\,\\mathrm{m/s}$, $\\Delta t = 300\\,\\mathrm{s}$, 示踪剂 $q^n(x) = \\sin\\left(2\\pi x / L\\right)$, 检测参数 $\\varepsilon = 10^{-12}$, $\\tau = 0.3$。\n- 案例 2 (不连续): $N = 128$, $\\Delta x = 1000\\,\\mathrm{m}$, $L = N \\Delta x$, $u = 50\\,\\mathrm{m/s}$, $\\Delta t = 300\\,\\mathrm{s}$, 示踪剂 $q^n(x) = 1$ (当 $x \\in [0.25 L, 0.75 L)$ 时) 其余为 $q^n(x) = 0$, 检测参数 $\\varepsilon = 10^{-12}$, $\\tau = 0.3$。\n- 案例 3 (恒定场边界情况): $N = 128$, $\\Delta x = 1000\\,\\mathrm{m}$, $L = N \\Delta x$, $u = 50\\,\\mathrm{m/s}$, $\\Delta t = 300\\,\\mathrm{s}$, 示踪剂 $q^n(x) = 0.5$ (对所有 $x$), 检测参数 $\\varepsilon = 10^{-12}$, $\\tau = 0.3$。\n- 案例 4 (边界不连续): $N = 128$, $\\Delta x = 1000\\,\\mathrm{m}$, $L = N \\Delta x$, $u = 50\\,\\mathrm{m/s}$, $\\Delta t = 300\\,\\mathrm{s}$, 示踪剂 $q^n(x) = 1$ (当 $x \\in [0, 0.1 L)$ 时) 其余为 $q^n(x) = 0$, 检测参数 $\\varepsilon = 10^{-12}$, $\\tau = 0.3$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个案例，输出列表 $[\\text{overshoot\\_high}, \\text{overshoot\\_switch}, \\text{flagged\\_count}]$。汇总所有案例的最终输出必须采用以下形式\n$$\n\\big[ [o_{1,h}, o_{1,s}, f_1], [o_{2,h}, o_{2,s}, f_2], [o_{3,h}, o_{3,s}, f_3], [o_{4,h}, o_{4,s}, f_4] \\big],\n$$\n其中每个 $o_{\\cdot,\\cdot}$ 是一个十进制数，每个 $f_{\\cdot}$ 是一个整数。",
            "solution": "该问题要求实现和分析一个一维半拉格朗日平流方案，重点关注对非光滑数据进行高阶插值时出现的数值伪影 (Gibbs 振荡)，以及使用混合插值策略来减轻这些伪影。\n\n控制方程是具有恒定速度 $u$ 的标量示踪剂场 $q(x,t)$ 的线性平流方程：\n$$\n\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = 0\n$$\n该方程表明，示踪剂 $q$ 沿着由 $\\frac{dx}{dt} = u$ 定义的特征线守恒。这些特征线在 $x-t$ 平面中是直线：$x(t) = x_0 + ut$。\n\n半拉格朗日方法利用了这一原理。为了找到新时间 $t^{n+1} = t^n + \\Delta t$ 时网格点 $x_i$ 处的示踪剂值，我们将特征线沿时间向后追溯一个时长 $\\Delta t$。前一时间 $t^n$ 的位置称为出发点 $x_d$。其位置通过向后积分速度得到：\n$$\nx_d = x_i - \\int_{t^n}^{t^{n+1}} u \\, dt = x_i - u \\Delta t\n$$\n示踪剂的值沿此轨迹守恒，因此到达点 $x_i$ 处的新值就是旧时间 $t^n$ 的示踪剂场在出发点 $x_d$ 处评估的值：\n$$\nq(x_i, t^{n+1}) = q(x_d, t^n)\n$$\n由于出发点 $x_d$ 通常不与网格点重合，其值 $q(x_d, t^n)$ 必须通过对已知的 $q^n$ 网格点值进行插值来确定。插值方法的选择对方案的准确性和稳定性至关重要。\n\n计算域是周期性的，长度为 $L = N \\Delta x$，其中 $N$ 是网格点数，$\\Delta x$ 是均匀的网格间距。任何计算出的出发点 $x_d$ 都必须使用模运算映射回域 $[0, L)$ 中。如果我们使用网格索引，出发位置 $x_d$ 对应一个非整数网格坐标 $x'_d = x_d / \\Delta x$。基准整数索引是 $i_0 = \\lfloor x'_d \\rfloor$，小数位移是 $\\alpha = x'_d - i_0$，其中 $\\alpha \\in [0, 1)$。所有用于获取数据的网格索引都必须按模 $N$ 计算，以强制执行周期性。\n\n指定了两种插值方法：\n\n1.  **高阶 5 点 Lagrange 插值**：此方法使用一个四次多项式，该多项式穿过以出发点基准索引 $i_0$ 为中心的五个网格点。点模板为 $\\{i_0-2, i_0-1, i_0, i_0+1, i_0+2\\}$。相对于 $i_0$ 的小数位置 $\\alpha$ 处的插值由 Lagrange 公式给出：\n    $$\n    q(x_d) \\approx \\sum_{j=-2}^{2} q^n_{i_0+j} L_j(\\alpha)\n    $$\n    其中 $q^n_{i_0+j}$ 是模板点处的示踪剂值（索引按模 $N$ 计算），$L_j(\\alpha)$ 是整数节点 $\\{-2, -1, 0, 1, 2\\}$ 的 Lagrange 基多项式：\n    $$\n    L_j(\\alpha) = \\prod_{k=-2, k \\neq j}^{2} \\frac{\\alpha - k}{j - k}\n    $$\n    尽管此方法对光滑函数非常准确，但在对不连续点进行插值时，容易产生虚假振荡 (Gibbs 现象)。\n\n2.  **低阶 2 点线性插值**：此方法使用连接出发点两侧两个网格点 $\\{i_0, i_0+1\\}$ 的线段。公式为：\n    $$\n    q(x_d) \\approx (1-\\alpha) q^n_{i_0} + \\alpha q^n_{i_0+1}\n    $$\n    此方法对光滑函数不太准确，但是“保单调性”的，即它不会创建新的局部最大值或最小值，从而避免振荡。\n\n为了结合两种方法的优点，设计了一种混合或切换方案。该方案默认使用高阶方法，但在怀疑存在非光滑的区域切换到低阶方法。检测使用归一化的二阶差分指示器 $S(i_0)$ 来执行：\n$$\nS(i_0) = \\frac{|q^n_{i_0+1} - 2 q^n_{i_0} + q^n_{i_0-1}|}{|q^n_{i_0+1} - q^n_{i_0}| + |q^n_{i_0} - q^n_{i_0-1}| + \\varepsilon}\n$$\n分子是二阶导数的离散近似，对高曲率和不连续性敏感。分母是总变差的离散度量，它对指示器进行归一化，使其对特征的“锐度”敏感。一个小的常数 $\\varepsilon$ 可防止在恒定场区域中出现除以零的情况。如果 $S(i_0)$ 超过预定义阈值 $\\tau$，则认为场在 $i_0$ 处非光滑，并将相应到达点的插值切换为线性方法。\n\n方案的性能通过过冲度量来量化，该度量衡量新场 $q^{n+1}$ 超出旧场 $q^n$ 全局边界的程度：\n$$\n\\text{overshoot}(q^{n+1}; q^n) = \\max\\left( \\max_i q^{n+1}_i - \\max_j q^n_j, \\ \\min_j q^n_j - \\min_i q^{n+1}_i, \\ 0 \\right)\n$$\n非零的过冲值表示存在数值振荡。\n\n每个测试用例的总体算法如下：\n1.  定义网格和参数 $N, \\Delta x, u, \\Delta t$。\n2.  在网格上生成初始示踪剂场 $q^n$。\n3.  计算 $q^n$ 的全局最大值和最小值。\n4.  为单个时间步长实现两个子变体：\n    a.  **仅高阶**：对于每个到达网格点 $i=0, \\dots, N-1$，计算出发点 $x_d$，找到基准索引 $i_0$ 和小数部分 $\\alpha$，并使用 5 点 Lagrange 插值计算 $q^{n+1}_i$。\n    b.  **切换**：对于每个到达点 $i$，执行相同的出发点计算。然后，计算光滑度指示器 $S(i_0)$。如果 $S(i_0)  \\tau$，则使用 2 点线性插值并为标记点增加计数器。否则，使用 5 点 Lagrange 插值。\n5.  对于每个变体，计算所得场 $q^{n+1}$ 相对于初始场 $q^n$ 的过冲值。\n6.  报告两个变体的过冲值以及切换方案中标记点的数量。",
            "answer": "```python\nimport numpy as np\n\ndef lagrange_5pt(q_stencil, alpha):\n    \"\"\"\n    Performs 5-point Lagrange interpolation on a stencil of 5 points.\n    Stencil points are assumed to be at local coordinates {-2, -1, 0, 1, 2}.\n    alpha is the fractional coordinate in [0, 1) relative to the center point (coord 0).\n    \n    Args:\n        q_stencil (list or np.ndarray): Tracer values at the 5 stencil points.\n        alpha (float): Fractional position for interpolation.\n    \n    Returns:\n        float: The interpolated value.\n    \"\"\"\n    # Pre-calculated Lagrange basis polynomial coefficients for nodes at -2, -1, 0, 1, 2\n    # L_j(alpha) = product_{k!=j} (alpha-k)/(j-k)\n    L_m2 = (alpha + 1) * alpha * (alpha - 1) * (alpha - 2) / 24.0\n    L_m1 = (alpha + 2) * alpha * (alpha - 1) * (alpha - 2) / -6.0\n    L_0  = (alpha + 2) * (alpha + 1) * (alpha - 1) * (alpha - 2) / 4.0\n    L_1  = (alpha + 2) * (alpha + 1) * alpha * (alpha - 2) / -6.0\n    L_2  = (alpha + 2) * (alpha + 1) * alpha * (alpha - 1) / 24.0\n    \n    return (q_stencil[0] * L_m2 + \n            q_stencil[1] * L_m1 + \n            q_stencil[2] * L_0 + \n            q_stencil[3] * L_1 + \n            q_stencil[4] * L_2)\n\ndef linear_2pt(q_stencil, alpha):\n    \"\"\"\n    Performs 2-point linear interpolation.\n    Stencil points are at local coordinates {0, 1}.\n    alpha is the fractional coordinate in [0, 1).\n\n    Args:\n        q_stencil (list or np.ndarray): Tracer values at the 2 stencil points.\n        alpha (float): Fractional position for interpolation.\n\n    Returns:\n        float: The interpolated value.\n    \"\"\"\n    return (1.0 - alpha) * q_stencil[0] + alpha * q_stencil[1]\n\ndef calculate_smoothness(q, i0, N, epsilon):\n    \"\"\"\n    Calculates the normalized second-difference indicator S(i0).\n    \"\"\"\n    q_im1 = q[(i0 - 1) % N]\n    q_i0  = q[i0 % N]\n    q_ip1 = q[(i0 + 1) % N]\n    \n    numerator = abs(q_ip1 - 2 * q_i0 + q_im1)\n    denominator = abs(q_ip1 - q_i0) + abs(q_i0 - q_im1) + epsilon\n    \n    if denominator  1e-20: # Practically zero\n        return 0.0\n    return numerator / denominator\n\ndef calculate_overshoot(q_new, q_old):\n    \"\"\"\n    Calculates the overshoot/undershoot metric.\n    \"\"\"\n    max_old = np.max(q_old)\n    min_old = np.min(q_old)\n    max_new = np.max(q_new)\n    min_new = np.min(q_new)\n\n    overshoot = max(0.0, max_new - max_old)\n    undershoot = max(0.0, min_old - min_new)\n    \n    return max(overshoot, undershoot)\n\ndef run_semi_lagrangian_step(params, q_n, mode):\n    \"\"\"\n    Performs one semi-Lagrangian time step.\n    \n    Args:\n        params (dict): Dictionary of simulation parameters.\n        q_n (np.ndarray): Tracer field at time t^n.\n        mode (str): 'high_order' or 'switching'.\n\n    Returns:\n        If mode is 'high_order': np.ndarray (the new tracer field q_n+1).\n        If mode is 'switching': tuple(np.ndarray, int) (q_n+1, number of flagged points).\n    \"\"\"\n    N = params['N']\n    dx = params['dx']\n    u = params['u']\n    dt = params['dt']\n    tau = params['tau']\n    epsilon = params['epsilon']\n    L = N * dx\n\n    q_np1 = np.zeros(N)\n    flagged_count = 0\n    x_grid = np.arange(N) * dx\n    \n    advection_dist = u * dt\n\n    for i in range(N):\n        x_i = x_grid[i]\n        \n        # Calculate departure point coordinate\n        x_d = x_i - advection_dist\n        \n        # Apply periodic boundary condition\n        x_d_periodic = x_d % L\n        \n        # Calculate base index and fractional part\n        xd_grid_coord = x_d_periodic / dx\n        i0 = int(np.floor(xd_grid_coord))\n        alpha = xd_grid_coord - i0\n        \n        use_linear = False\n        if mode == 'switching':\n            smoothness = calculate_smoothness(q_n, i0, N, epsilon)\n            if smoothness  tau:\n                use_linear = True\n                flagged_count += 1\n        \n        if use_linear:\n            # Low-order linear interpolation\n            stencil_indices = [(i0 + j) % N for j in range(2)]\n            q_stencil = q_n[stencil_indices]\n            q_np1[i] = linear_2pt(q_stencil, alpha)\n        else:\n            # High-order Lagrange interpolation\n            stencil_indices = [(i0 + j) % N for j in range(-2, 3)]\n            q_stencil = q_n[stencil_indices]\n            q_np1[i] = lagrange_5pt(q_stencil, alpha - 0.0) # alpha is already relative to i0\n\n    if mode == 'switching':\n        return q_np1, flagged_count\n    else:\n        return q_np1\n\ndef solve():\n    test_cases = [\n        {\n            'name': 'smooth', 'N': 128, 'dx': 1000.0, 'u': 50.0, 'dt': 300.0, \n            'epsilon': 1e-12, 'tau': 0.3,\n            'init_q': lambda x, L: np.sin(2 * np.pi * x / L)\n        },\n        {\n            'name': 'discontinuity', 'N': 128, 'dx': 1000.0, 'u': 50.0, 'dt': 300.0,\n            'epsilon': 1e-12, 'tau': 0.3,\n            'init_q': lambda x, L: np.where((x = 0.25 * L)  (x  0.75 * L), 1.0, 0.0)\n        },\n        {\n            'name': 'constant', 'N': 128, 'dx': 1000.0, 'u': 50.0, 'dt': 300.0,\n            'epsilon': 1e-12, 'tau': 0.3,\n            'init_q': lambda x, L: np.full_like(x, 0.5)\n        },\n        {\n            'name': 'boundary_discontinuity', 'N': 128, 'dx': 1000.0, 'u': 50.0, 'dt': 300.0,\n            'epsilon': 1e-12, 'tau': 0.3,\n            'init_q': lambda x, L: np.where(x  0.1 * L, 1.0, 0.0)\n        }\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        N = params['N']\n        dx = params['dx']\n        L = N * dx\n        x_grid = np.arange(N) * dx\n        q_n = params['init_q'](x_grid, L)\n\n        # High-order only variant\n        q_np1_ho = run_semi_lagrangian_step(params, q_n, 'high_order')\n        overshoot_ho = calculate_overshoot(q_np1_ho, q_n)\n\n        # Switching variant\n        q_np1_sw, flagged_count = run_semi_lagrangian_step(params, q_n, 'switching')\n        overshoot_sw = calculate_overshoot(q_np1_sw, q_n)\n\n        result_list = [overshoot_ho, overshoot_sw, flagged_count]\n        all_results.append(result_list)\n        \n    # Format the output string as per requirements\n    result_strings = []\n    for res in all_results:\n        result_strings.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了防止非物理解振荡而强制执行单调性等物理约束并非没有代价，它会降低方案的理论精度，即便是在光滑场中也是如此，尤其是在梯度改变符号的极值点附近。本练习旨在探讨在保持物理真实性（单调性）与追求高阶形式精度之间的微妙权衡。通过对比一个标准高阶方案和一个单调性保持方案在平流光滑高斯廓线时的表现，您将量化由于斜率限制器在光滑峰值处“削平”场而导致的精度损失，从而深刻理解数值方案设计中固有的复杂妥协。",
            "id": "4087342",
            "problem": "考虑在一个周期性域内，标量示踪场的一维线性平流问题，其控制方程为平流方程 $\\partial_t q + u \\, \\partial_x q = 0$。半拉格朗日（SL）方法通过追踪特征线来更新示踪场：对于时间 $t^{n+1}$ 的每个到达网格点 $x_i$，示踪场的值被设为时间 $t^n$ 对应出发点处的值，即 $q^{n+1}(x_i) = q^n(x_i - u \\Delta t)$，位置采用周期性处理。在数值天气预报（NWP）和气候模拟中，用于评估离网格出发点上 $q^n$ 值的插值方法的选择，会引起在强制单调性（以防止伪振荡）和形式精度阶（控制光滑场的截断误差）之间的权衡。您的任务是为一个具有单个极值点的光滑廓线量化这种权衡。\n\n从平流方程和特征线定义 $dx/dt = u$ 出发，在均匀周期性网格上实现一个单步半拉格朗日更新，以比较出发点上的两种插值策略：\n- 一种形式三阶、无限制的立方插值。\n- 一种带斜率限制的、保持单调性的立方Hermite插值，该插值强制局部单调性（当相邻割线斜率变号时，将节点斜率设为零；否则使用相邻割线斜率的调和平均值），从而降低了光滑极值点附近的局部阶。\n\n使用恒定速度 $u = 1 \\, \\mathrm{m/s}$，周期域长度 $L = 1 \\, \\mathrm{m}$，以及一个包含 $N$ 个点、网格间距为 $\\Delta x = L/N$ 的均匀网格。对于给定的库朗数 $c = u \\Delta t / \\Delta x$，选择 $\\Delta t = c \\, \\Delta x / u$，单位为 $\\mathrm{s}$。初始条件是一个具有单个极值点的光滑高斯函数，\n$$\nq_0(x) = \\exp\\!\\left(-\\frac{\\delta(x,x_0)^2}{2 \\sigma^2}\\right),\n$$\n其中 $x_0 = L/2$，$\\sigma = 0.1\\,L$，而 $\\delta(x,x_0)$ 是在周长为 $L$ 的圆上的有符号最短周期距离，即 $\\delta(x,x_0) = \\left((x-x_0) + L/2 \\ \\bmod\\ L\\right) - L/2$。单步之后的精确解是平移后的初始条件 $q_{\\mathrm{exact}}(x_i) = q_0\\!\\left((x_i - u \\Delta t) \\ \\bmod\\ L\\right)$。\n\n对于每个测试用例，从 $q_0$ 执行一个半拉格朗日步骤以获得：\n- $q_{\\mathrm{cubic}}^{n+1}$：使用形式三阶的立方插值（当出发点位于单元格 $[x_j,x_{j+1})$ 内时，在模板 $\\{x_{j-1},x_j,x_{j+1},x_{j+2}\\}$ 上使用局部四点均匀网格立方插值，如 Catmull–Rom 插值）。\n- $q_{\\mathrm{mono}}^{n+1}$：使用保持单调性的立方Hermite插值，其斜率限制根据均匀网格上（采用周期性环绕）的相邻割线斜率计算。对于每个节点索引 $i$，定义割线斜率 $d_i = (q_{i+1}-q_i)/\\Delta x$（使用周期性索引）。如果 $d_{i-1} d_i \\le 0$，则设置节点斜率 $m_i = 0$。否则，设置 $m_i = \\dfrac{2 d_{i-1} d_i}{d_{i-1}+d_i}$（调和平均值）。在区间 $[x_j,x_{j+1}]$ 上，使用局部坐标 $s = (x - x_j)/\\Delta x \\in [0,1]$，并通过 $y_0 = q_j$、$y_1 = q_{j+1}$、$m_0 = m_j$、$m_1 = m_{j+1}$ 和标准基函数来评估立方Hermite插值。\n\n为每种插值计算均方根误差\n$$\nE_{\\ast} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(q_{\\ast}^{n+1}(x_i) - q_{\\mathrm{exact}}(x_i)\\right)^2},\n$$\n其中 $\\ast \\in \\{\\mathrm{cubic}, \\mathrm{mono}\\}$，由于 $q$ 是无量纲的，该误差也是无量纲的。通过比率 $R = E_{\\mathrm{mono}} / E_{\\mathrm{cubic}}$ 来量化因强制单调性而导致的精度退化，结果以无单位的浮点数形式报告。\n\n在一个完整的、可运行的程序中实现以上内容，并评估以下旨在检验典型和边缘条件的测试套件：\n- 案例1：$N = 64$，$c = 0.30$。\n- 案例2：$N = 64$，$c = 0.95$。\n- 案例3：$N = 32$，$c = 0.50$。\n- 案例4：$N = 128$，$c = 0.50$。\n- 案例5：$N = 64$，$c = 0.05$。\n- 案例6：$N = 64$，$c = 1.60$。\n\n您的程序应生成单行输出，其中包含六个案例的比率 $R$，按顺序排列，形式为方括号内以逗号分隔的列表（例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$）。所有涉及长度的中间量单位必须是 $\\mathrm{m}$，时间单位必须是 $\\mathrm{s}$，但最终打印的比率 $R$ 必须是无单位的浮点数。",
            "solution": "该问题要求在一个一维半拉格朗日（SL）平流框架内，对两种插值方案进行定量比较。这两种方案分别是形式三阶的立方插值和保持单调性的立方Hermite插值。比较的依据是，在单个时间步后，针对光滑高斯廓线计算的与精确解之间的均方根误差。\n\n控制偏微分方程是标量场 $q(x,t)$ 的线性平流方程：\n$$\n\\partial_t q + u \\, \\partial_x q = 0\n$$\n其中 $u$ 是一个恒定速度。该方程的解表明，$q$ 的值沿着由 $dx/dt = u$ 定义的特征线保持不变。其解为 $q(x,t) = q_0(x - ut)$，其中 $q_0(x) = q(x, t=0)$ 是初始条件。\n\n半拉格朗日方法将此关系离散化。为了找到新时间 $t^{n+1} = t^n + \\Delta t$ 时网格点 $x_i$ 上的场 $q$ 的值，我们从 $(x_i, t^{n+1})$ 沿特征线向后追溯时间，以找到前一时间 $t^n$ 的出发点 $x_d$。然后将新值设为出发点处的场值：\n$$\nq^{n+1}(x_i) = q^n(x_d) = q^n(x_i - u \\Delta t)\n$$\n由于出发点 $x_d$ 通常不与时间 $t^n$ 网格上的网格点重合，其值 $q^n(x_d)$ 必须通过对时间 $t^n$ 场在网格点上的已知值进行插值来估计。\n\n首先，我们建立计算域和初始状态。\n域是周期性的，长度为 $L = 1 \\, \\mathrm{m}$。它由一个包含 $N$ 个点的均匀网格离散化，$x_i = i \\Delta x$，$i = 0, 1, \\dots, N-1$，其中网格间距为 $\\Delta x = L/N$。速度恒为 $u = 1 \\, \\mathrm{m/s}$。时间步长 $\\Delta t$ 由库朗数 $c$ 通过 $\\Delta t = c \\Delta x / u$ 决定。\n\n在 $t^n=t_0=0$ 时的初始条件是一个光滑的高斯廓线：\n$$\nq^n(x) = q_0(x) = \\exp\\!\\left(-\\frac{\\delta(x,x_0)^2}{2 \\sigma^2}\\right)\n$$\n其中心位于 $x_0 = L/2 = 0.5 \\, \\mathrm{m}$，宽度为 $\\sigma = 0.1 L = 0.1 \\, \\mathrm{m}$。函数 $\\delta(x, x_0)$ 表示周期域上的最短有符号距离：$\\delta(x,x_0) = \\left((x-x_0) + L/2 \\right) \\bmod L - L/2$。此函数确保了跨越周期性边界的距离计算正确，结果值在 $[-L/2, L/2]$ 范围内。\n\n经过一个持续时间为 $\\Delta t$ 的时间步后，网格点 $x_i$ 上的精确解是初始廓线平移了距离 $u \\Delta t$：\n$$\nq_{\\mathrm{exact}}(x_i) = q_0((x_i - u \\Delta t) \\bmod L)\n$$\n这是通过将高斯函数应用于周期性环绕的出发点来计算的。\n\n对于每个网格点 $x_i$，出发点是 $x_{d,i} = x_i - u \\Delta t$。其在周期域 $[0, L)$ 内的位置是 $x_{d,i}^{\\mathrm{p}} = x_{d,i} \\bmod L$。然后我们找到包含 $x_{d,i}^{\\mathrm{p}}$ 的网格区间 $[x_j, x_{j+1})$。索引 $j$ 通过 $j = \\lfloor x_{d,i}^{\\mathrm{p}} / \\Delta x \\rfloor$ 找到，该区间内的归一化坐标是 $s = (x_{d,i}^{\\mathrm{p}} / \\Delta x) - j \\in [0, 1)$。然后使用两种不同的插值方法计算 $q^{n+1}(x_i)$ 的值。\n\n**1. 三阶（Catmull-Rom）立方插值**\n这是一种无限制、形式上三阶精确的方案。对于位于区间 $[x_j, x_{j+1})$ 内的出发点，它使用初始场中已知值的四点模板：$\\{q^n_j, q^n_{j-1}, q^n_{j+1}, q^n_{j+2}\\}$。索引采用周期性处理（例如，$q^n_{-1} = q^n_{N-1}$）。插值 $q_{\\mathrm{cubic}}^{n+1}(x_i)$ 由以下多项式给出：\n$$\nP(s) = q^n_j + \\frac{1}{2}s(-q^n_{j-1} + q^n_{j+1}) + \\frac{1}{2}s^2(2q^n_{j-1} - 5q^n_j + 4q^n_{j+1} - q^n_{j+2}) + \\frac{1}{2}s^3(-q^n_{j-1} + 3q^n_j - 3q^n_{j+1} + q^n_{j+2})\n$$\n其中 $s \\in [0,1)$ 是局部坐标。该方案对于光滑场是精确的，但在陡峭梯度或极值点附近会引入伪振荡（过冲和下冲）。\n\n**2. 保持单调性的立方Hermite插值**\n该方案旨在防止伪振荡。它是一种立方Hermite插值形式，其中区间端点的斜率受到限制。在 $[x_j, x_{j+1}]$ 上的插值函数由值 $q^n_j, q^n_{j+1}$ 和节点斜率 $m_j, m_{j+1}$ 定义。首先计算斜率，然后对其进行限制以强制单调性。\n\n首先，对于每个网格节点 $k$，我们计算割线斜率 $d_k = (q^n_{k+1} - q^n_k)/\\Delta x$，采用周期性索引。\n接下来，我们应用斜率限制器来确定节点斜率 $m_k$：\n- 如果 $d_{k-1} d_k \\le 0$，则节点 $k$ 周围的数据不是单调的。为防止振荡，该节点的斜率设为零：$m_k = 0$。这种平坦化发生在相邻割线斜率变号的高斯函数峰值处。\n- 如果 $d_{k-1} d_k  0$，则数据是单调的。斜率被设为相邻割线的调和平均值：$m_k = \\frac{2 d_{k-1} d_k}{d_{k-1} + d_k}$。这种选择确保了插值斜率保持在相邻割线斜率的界限内。\n\n利用限制后的斜率 $\\{m_k\\}$，对于位于 $[x_j, x_{j+1}]$ 内（局部坐标为 $s$）的出发点，使用Hermite基函数构造立方Hermite插值函数：\n$$\nq_{\\mathrm{mono}}^{n+1}(x_i) = h_{00}(s)q^n_j + h_{01}(s)q^n_{j+1} + h_{10}(s)(m_j \\Delta x) + h_{11}(s)(m_{j+1} \\Delta x)\n$$\n其中基函数为：\n$h_{00}(s) = 2s^3 - 3s^2 + 1$\n$h_{01}(s) = -2s^3 + 3s^2$\n$h_{10}(s) = s^3 - 2s^2 + s$\n$h_{11}(s) = s^3 - s^2$\n因子 $\\Delta x$ 将物理斜率 $m_j$ 和 $m_{j+1}$ 缩放为相对于局部坐标 $s$ 所需的导数。该方案通过构造是单调的，但在斜率限制器激活的地方（即 $m_k=0$ 的地方），其形式精度阶会局部降低到一阶。\n\n**误差量化**\n对于每种方案（用 $\\ast$ 表示），根据精确解计算均方根误差 $E_{\\ast}$：\n$$\nE_{\\ast} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(q_{\\ast}^{n+1}(x_i) - q_{\\mathrm{exact}}(x_i)\\right)^2}\n$$\n精度和单调性之间的权衡由比率 $R = E_{\\mathrm{mono}} / E_{\\mathrm{cubic}}$ 来量化。比率 $R1$ 表明，与形式上更高阶、无限制的方案相比，强制单调性导致了更大的均方根误差。这是预期的，因为斜率限制会降低精度，尤其是在高斯廓线的光滑峰值处。这些测试用例在不同的网格分辨率（$N$）和库朗数（$c$）下探讨了这种权衡。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the semi-Lagrangian advection problem for multiple test cases.\n    \"\"\"\n    test_cases = [\n        (64, 0.30),  # Case 1: N, c\n        (64, 0.95),  # Case 2\n        (32, 0.50),  # Case 3\n        (128, 0.50), # Case 4\n        (64, 0.05),  # Case 5\n        (64, 1.60),  # Case 6\n    ]\n\n    results = []\n    for N, c in test_cases:\n        # 1. Setup grid, parameters, and initial condition\n        L = 1.0\n        u = 1.0\n        x0 = L / 2.0\n        sigma = 0.1 * L\n\n        dx = L / N\n        dt = c * dx / u\n        grid_points = np.linspace(0.0, L, N, endpoint=False)\n\n        def periodic_distance(x, center, length):\n            \"\"\"Calculates the shortest signed distance on a periodic domain.\"\"\"\n            return ((x - center + length / 2.0) % length) - length / 2.0\n\n        q0 = np.exp(-periodic_distance(grid_points, x0, L)**2 / (2.0 * sigma**2))\n\n        # 2. Calculate departure points and exact solution\n        departure_points = grid_points - u * dt\n        q_exact = np.exp(-periodic_distance(departure_points, x0, L)**2 / (2.0 * sigma**2))\n\n        # 3. Perform interpolation for both schemes\n        q_cubic_next = interpolate(q0, departure_points, dx, L, scheme='cubic')\n        q_mono_next = interpolate(q0, departure_points, dx, L, scheme='mono')\n\n        # 4. Calculate RMS errors and the ratio\n        e_cubic = np.sqrt(np.mean((q_cubic_next - q_exact)**2))\n        e_mono = np.sqrt(np.mean((q_mono_next - q_exact)**2))\n        \n        ratio = e_mono / e_cubic\n        results.append(ratio)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef interpolate(q_field, dep_points, dx, L, scheme):\n    \"\"\"\n    Interpolates a field q_field at given departure points using the specified scheme.\n    \n    Args:\n        q_field (np.ndarray): The 1D array of scalar values on the uniform grid.\n        dep_points (np.ndarray): The 1D array of departure point coordinates.\n        dx (float): Grid spacing.\n        L (float): Domain length.\n        scheme (str): 'cubic' for Catmull-Rom or 'mono' for monotone Hermite.\n        \n    Returns:\n        np.ndarray: The interpolated values at the departure points.\n    \"\"\"\n    N = len(q_field)\n    # Wrap departure points into the periodic domain [0, L)\n    dep_points_periodic = dep_points % L\n    \n    # Find the left grid index j and the local coordinate s for each departure point\n    j = np.floor(dep_points_periodic / dx).astype(int)\n    s = (dep_points_periodic / dx) - j\n\n    # Get indices for stencil points with periodic wrapping\n    j_m1 = (j - 1) % N\n    j_p1 = (j + 1) % N\n    j_p2 = (j + 2) % N\n\n    if scheme == 'cubic':\n        # Catmull-Rom interpolation\n        q_jm1 = q_field[j_m1]\n        q_j = q_field[j]\n        q_jp1 = q_field[j_p1]\n        q_jp2 = q_field[j_p2]\n\n        # Polynomial form derived from the Catmull-Rom matrix\n        a = -0.5 * q_jm1 + 1.5 * q_j - 1.5 * q_jp1 + 0.5 * q_jp2\n        b = q_jm1 - 2.5 * q_j + 2.0 * q_jp1 - 0.5 * q_jp2\n        c = -0.5 * q_jm1 + 0.5 * q_jp1\n        d = q_j\n        \n        return ((a * s + b) * s + c) * s + d\n\n    elif scheme == 'mono':\n        # Monotone cubic Hermite interpolation\n        \n        # a) Calculate limited slopes\n        # Secant slopes d_i = (q_{i+1} - q_i) / dx\n        d = (np.roll(q_field, -1) - q_field) / dx\n        # Previous secant slopes d_{i-1}\n        d_prev = np.roll(d, 1)\n\n        m = np.zeros_like(q_field)\n        \n        # Mask where slopes have the same sign (monotonic region)\n        mono_mask = (d * d_prev)  0.0\n        \n        # Harmonic mean for slopes in monotonic regions\n        # np.divide handles potential division by zero, although logic prevents it here\n        m[mono_mask] = np.divide(2.0 * d[mono_mask] * d_prev[mono_mask], \n                                 d[mono_mask] + d_prev[mono_mask])\n        \n        # b) Fetch values and slopes for interpolation\n        y0 = q_field[j]\n        y1 = q_field[j_p1]\n        m0 = m[j] * dx  # Scale slope for local s-coordinate derivative\n        m1 = m[j_p1] * dx\n\n        # c) Apply Hermite basis functions\n        s2 = s * s\n        s3 = s2 * s\n        \n        h00 = 2.0 * s3 - 3.0 * s2 + 1.0\n        h10 = s3 - 2.0 * s2 + s\n        h01 = -2.0 * s3 + 3.0 * s2\n        h11 = s3 - s2\n\n        return h00 * y0 + h10 * m0 + h01 * y1 + h11 * m1\n        \n    else:\n        raise ValueError(\"Unknown interpolation scheme specified.\")\n\n# Execute the main function\nsolve()\n```"
        }
    ]
}