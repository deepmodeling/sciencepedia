{
    "hands_on_practices": [
        {
            "introduction": "This first practice serves as a fundamental building block for understanding the performance of semi-Lagrangian schemes. You will implement a basic 1D advection model to explore how the choice of interpolation directly impacts numerical accuracy. By analyzing the transport of a simple sinusoidal wave, this exercise allows you to precisely measure amplitude and phase errors, which correspond to numerical diffusion and dispersion, respectively. This provides a quantitative foundation for appreciating why higher-order interpolation is often preferred for resolving smooth features in atmospheric models. ",
            "id": "4087321",
            "problem": "Consider the one-dimensional ($1$D) linear advection equation for a passive scalar field $q(x,t)$ on a periodic domain,\n$$\n\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = 0,\n$$\nwith constant velocity $u$. The method of characteristics states that the solution is constant along trajectories satisfying $dx/dt = u$. In a Semi-Lagrangian (SL) time-stepping method, the value at an arrival (Eulerian) grid point $x_i$ at time $t^{n+1}$ is obtained from the value at the corresponding departure point $x_d$ at time $t^n$, i.e.,\n$$\nq^{n+1}(x_i) \\approx \\mathcal{I}\\left[q^n\\right](x_d),\n$$\nwhere $\\mathcal{I}$ denotes an interpolation operator applied to the discrete field $q^n$ at $x_d$. For constant $u$, the exact departure point is\n$$\nx_d = x_i - u \\,\\Delta t,\n$$\nand periodic boundary conditions are assumed. Define the Courant number (dimensionless) as\n$$\nC = \\frac{u \\,\\Delta t}{\\Delta x},\n$$\nwhere $\\Delta x$ is the uniform grid spacing. The initial condition is a single sinusoidal Fourier mode,\n$$\nq(x,0) = \\sin\\left(k x\\right), \\quad k = \\frac{2\\pi m}{L},\n$$\non a periodic domain of length $L$, discretized on $M$ equally spaced points $x_i = i\\,\\Delta x$, with $\\Delta x = L/M$ and $i \\in \\{0,1,\\dots,M-1\\}$. The exact solution at time $\\Delta t$ is a pure shift $q_{\\text{exact}}(x,\\Delta t) = \\sin\\left(k\\left(x - u \\Delta t\\right)\\right)$, which preserves amplitude and introduces the exact phase shift $-k\\,u\\,\\Delta t$.\n\nYour task is to implement a one-step Semi-Lagrangian transport for a constant velocity $u$ and quantify, for a single time step $\\Delta t$:\n- The amplitude error (dimensionless), defined as the difference between the numerically measured modal amplitude after the SL step and the unit amplitude of the initial mode.\n- The phase error (in radians), defined as the difference between the numerically measured phase of the advected mode and the exact phase shift $-k\\,u\\,\\Delta t$, wrapped to the interval $[-\\pi,\\pi]$.\n\nUse the following interpolation orders $p$:\n- $p=0$: nearest-neighbor interpolation (choose the closest grid point to $x_d$).\n- $p=1$: linear interpolation using the two neighboring grid points around $x_d$.\n- $p=2$: quadratic Lagrange interpolation using three points $\\{i_0-1,i_0,i_0+1\\}$ around $x_d$, where $i_0 = \\lfloor x_d/\\Delta x \\rfloor$ and the fractional position is $\\alpha = x_d/\\Delta x - i_0$.\n- $p=3$: cubic Lagrange interpolation using four points $\\{i_0-1,i_0,i_0+1,i_0+2\\}$ around $x_d$.\n\nTo measure amplitude and phase of the numerically transported mode $q_{\\text{num}}(x_i)$ at the grid points, use discrete inner products with the basis functions $\\sin(k x_i)$ and $\\cos(k x_i)$:\n$$\nA_{\\text{num}} = \\frac{2}{M} \\sum_{i=0}^{M-1} q_{\\text{num}}(x_i) \\sin(k x_i), \\quad\nB_{\\text{num}} = \\frac{2}{M} \\sum_{i=0}^{M-1} q_{\\text{num}}(x_i) \\cos(k x_i).\n$$\nDefine the numerically measured amplitude and phase as\n$$\nR_{\\text{num}} = \\sqrt{A_{\\text{num}}^2 + B_{\\text{num}}^2}, \\quad\n\\phi_{\\text{num}} = \\operatorname{atan2}\\left(B_{\\text{num}}, A_{\\text{num}}\\right),\n$$\nand the exact phase shift as\n$$\n\\phi_{\\text{exact}} = -k\\,u\\,\\Delta t.\n$$\nReport the amplitude error as $R_{\\text{num}} - 1$ (dimensionless), and report the phase error (in radians) as the wrapped difference\n$$\n\\Delta \\phi = \\left(\\phi_{\\text{num}} - \\phi_{\\text{exact}}\\right) \\text{ wrapped to } [-\\pi,\\pi].\n$$\n\nPhysical and numerical parameters:\n- Domain length $L = 1000$ meters.\n- Number of grid points $M = 512$ (uniform grid).\n- Mode number $m = 5$ (so $k = 2\\pi m/L$).\n- Constant velocity $u = 10$ meters per second.\n- Courant number $C$ prescribed per test case, and $\\Delta t = C\\,\\Delta x / u$.\n- Periodic boundary conditions for indexing and interpolation.\n\nAngle unit: report phase error in radians. Amplitude error is dimensionless. Express all numeric outputs as floating-point decimals rounded to $8$ decimal places.\n\nTest suite:\nCompute the pair $(\\text{amplitude error}, \\text{phase error})$ for the following $(p,C)$ cases, each for a single SL step:\n- Case $1$: $(p=1, C=0.25)$.\n- Case $2$: $(p=3, C=0.50)$.\n- Case $3$: $(p=0, C=0.95)$.\n- Case $4$: $(p=2, C=1.00)$.\n- Case $5$: $(p=1, C=0.00)$.\n- Case $6$: $(p=3, C=0.75)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a two-element list in the order $[\\text{amplitude\\_error},\\text{phase\\_error}]$. For example,\n$$\n\\text{\"[[e_{1,a},e_{1,\\phi}],[e_{2,a},e_{2,\\phi}],\\dots,[e_{6,a},e_{6,\\phi}]]\"}\n$$\nwith all floating-point values rounded to $8$ decimal places.",
            "solution": "The user-provided problem is assessed to be valid as it is scientifically grounded, mathematically well-posed, and free from internal contradictions or ambiguities. It presents a standard numerical analysis task involving the semi-Lagrangian advection scheme. We will now proceed with a complete solution.\n\nThe problem requires the implementation and analysis of a one-dimensional semi-Lagrangian (SL) advection scheme for the linear advection equation,\n$$\n\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = 0,\n$$\non a periodic domain of length $L = 1000$ meters with a constant velocity $u = 10$ m/s. The initial condition is a single sinusoidal mode:\n$$\nq(x,0) = \\sin(kx), \\quad \\text{where } k = \\frac{2\\pi m}{L} \\text{ with } m=5.\n$$\n\nThe domain is discretized into $M = 512$ grid points $x_i = i \\Delta x$ for $i \\in \\{0, 1, \\dots, M-1\\}$, where the grid spacing is $\\Delta x = L/M$. The initial discrete field is thus $q^0_i = \\sin(k x_i)$.\n\nThe core principle of the semi-Lagrangian method is to find the value at a grid point $x_i$ at the new time $t^{n+1} = t^n + \\Delta t$ by tracing the characteristic line backward in time to its departure point $x_d$ at time $t^n$. For a constant velocity $u$, this departure point is given by:\n$$\nx_d = x_i - u \\Delta t.\n$$\nUsing the Courant number $C = u \\Delta t / \\Delta x$, this can be expressed in terms of grid spacing as:\n$$\nx_d = x_i - C \\Delta x.\n$$\nThe solution value is constant along characteristics, so $q(x_i, t^{n+1}) = q(x_d, t^n)$. Since $x_d$ is generally not a grid point, its value must be obtained by interpolating the known grid point values of $q^n$. Thus, the numerical scheme is:\n$$\nq^{n+1}_i = \\mathcal{I}[q^n](x_d),\n$$\nwhere $\\mathcal{I}$ is an interpolation operator. We implement this for a single time step, starting from $q^0$.\n\nTo perform the interpolation, we first normalize the departure point's coordinate, $s_d = x_d / \\Delta x$. Let $i_0 = \\lfloor s_d \\rfloor$ be the index of the grid point immediately to the left of (or at) $x_d$, and let $\\alpha = s_d - i_0$ be the fractional distance from $x_{i_0}$. By construction, $0 \\le \\alpha < 1$. The value $q_i^{1}$ is computed using one of four specified interpolation schemes, all of which must respect the domain's periodicity when accessing grid data (i.e., indices are taken modulo $M$).\n\n1.  **Nearest-Neighbor Interpolation ($p=0$):** This scheme assigns the value of the spatially closest grid point. The interpolated value is $q^0_j$, where $j$ is the index of the grid point nearest to $x_d$. This is implemented by rounding the normalized coordinate $s_d$ to the nearest integer: $j = \\text{round}(s_d)$.\n2.  **Linear Interpolation ($p=1$):** This scheme uses the two grid points bracketing $x_d$, namely $x_{i_0}$ and $x_{i_0+1}$. The interpolated value is a weighted average:\n    $$\n    \\mathcal{I}[q^0](x_d) = (1-\\alpha) q^0_{i_0} + \\alpha q^0_{i_0+1}.\n    $$\n3.  **Quadratic Lagrange Interpolation ($p=2$):** This uses a stencil of three points, specified as $\\{i_0-1, i_0, i_0+1\\}$. The interpolated value is given by the Lagrange polynomial passing through $(x_{i_0-1}, q^0_{i_0-1})$, $(x_{i_0}, q^0_{i_0})$, and $(x_{i_0+1}, q^0_{i_0+1})$, evaluated at $x_d$. This is equivalent to:\n    $$\n    \\mathcal{I}[q^0](x_d) = L_{-1}(\\alpha)q^0_{i_0-1} + L_0(\\alpha)q^0_{i_0} + L_1(\\alpha)q^0_{i_0+1},\n    $$\n    where the Lagrange basis polynomials for stencil points indexed locally by $\\{-1, 0, 1\\}$ are:\n    $$\n    L_{-1}(\\alpha) = \\frac{\\alpha(\\alpha-1)}{2}, \\quad L_0(\\alpha) = 1 - \\alpha^2, \\quad L_1(\\alpha) = \\frac{\\alpha(\\alpha+1)}{2}.\n    $$\n4.  **Cubic Lagrange Interpolation ($p=3$):** This uses a four-point stencil, specified as $\\{i_0-1, i_0, i_0+1, i_0+2\\}$. The interpolated value is:\n    $$\n    \\mathcal{I}[q^0](x_d) = L_{-1}(\\alpha)q^0_{i_0-1} + L_0(\\alpha)q^0_{i_0} + L_1(\\alpha)q^0_{i_0+1} + L_2(\\alpha)q^0_{i_0+2},\n    $$\n    where the basis polynomials for the local stencil $\\{-1, 0, 1, 2\\}$ are:\n    $$\n    L_{-1}(\\alpha) = -\\frac{\\alpha(\\alpha-1)(\\alpha-2)}{6}, \\quad L_0(\\alpha) = \\frac{(\\alpha+1)(\\alpha-1)(\\alpha-2)}{2},\n    $$\n    $$\n    L_1(\\alpha) = -\\frac{\\alpha(\\alpha+1)(\\alpha-2)}{2}, \\quad L_2(\\alpha) = \\frac{\\alpha(\\alpha+1)(\\alpha-1)}{6}.\n    $$\n\nAfter computing the numerical solution $q^1_{\\text{num}}(x_i)$ for all $i \\in \\{0, \\dots, M-1\\}$, we analyze its accuracy. The exact solution after time $\\Delta t$ is a simple phase shift of the initial wave: $q_{\\text{exact}}(x, \\Delta t) = \\sin(k(x-u\\Delta t)) = \\sin(kx - \\phi_{\\text{exact}})$, where the exact phase shift is $\\phi_{\\text{exact}} = k u \\Delta t$. Note the problem defines $\\phi_{\\text{exact}} = -k u \\Delta t$, which is the shift applied to the argument of the sine function. We will adhere to this definition. The numerical solution, due to interpolation errors, may be written as $q^1_{\\text{num}} \\approx R_{\\text{num}} \\sin(kx - \\phi_{\\text{num}})$. To find the numerical amplitude $R_{\\text{num}}$ and phase $\\phi_{\\text{num}}$, we project the numerical solution onto the orthogonal basis functions $\\sin(kx)$ and $\\cos(kx)$ using discrete Fourier sums:\n$$\nA_{\\text{num}} = \\frac{2}{M} \\sum_{i=0}^{M-1} q^1_{\\text{num}}(x_i) \\sin(k x_i), \\quad\nB_{\\text{num}} = \\frac{2}{M} \\sum_{i=0}^{M-1} q^1_{\\text{num}}(x_i) \\cos(k x_i).\n$$\nFrom these coefficients, we find the numerical amplitude and phase:\n$$\nR_{\\text{num}} = \\sqrt{A_{\\text{num}}^2 + B_{\\text{num}}^2}, \\quad\n\\phi_{\\text{num}} = \\operatorname{atan2}\\left(B_{\\text{num}}, A_{\\text{num}}\\right).\n$$\nThe problem specifies the exact phase as $\\phi_{\\text{exact}} = -k u \\Delta t$. The numerical phase from the atan2 calculation corresponds to the phase of the wave, so a wave $\\sin(kx - \\phi_n)$ will be detected as having phase $\\phi_n = \\text{atan2}(-\\text{coeffs of cos}, \\text{coeffs of sin})$. Here using the definitions gives $\\sin(kx+\\phi_{num}) = \\sin(kx)\\cos(\\phi_{num}) + \\cos(kx)\\sin(\\phi_{num})$, and associating $A_{num} \\approx R_{num}\\cos(\\phi_{num})$ and $B_{num} \\approx R_{num}\\sin(\\phi_{num})$, so $\\phi_{num} = \\operatorname{atan2}(B_{num}, A_{num})$ is correct.\nThe amplitude error is the deviation from the initial unit amplitude, $R_{\\text{num}} - 1$. The phase error is the difference between the numerical and exact phase shifts, $\\Delta \\phi = \\phi_{\\text{num}} - \\phi_{\\text{exact}}$. This difference is wrapped to the interval $[-\\pi, \\pi]$ using the operation $\\Delta\\phi_{\\text{wrapped}} = (\\Delta\\phi + \\pi) \\pmod{2\\pi} - \\pi$.\n\nThe algorithm proceeds by iterating through each test case $(p, C)$, calculating the numerical solution $q^1_{\\text{num}}$ via the specified interpolation, and then computing the amplitude and phase errors as described. The final results are rounded to $8$ decimal places.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    # Final answer code as per problem specification.\n    \n    # Physical and numerical parameters\n    L = 1000.0  # Domain length in meters\n    M = 512     # Number of grid points\n    m = 5       # Mode number\n    u = 10.0    # Constant velocity in meters per second\n\n    # Derived parameters\n    dx = L / M\n    k = 2.0 * np.pi * m / L\n    x_grid = np.arange(M) * dx\n    q_initial = np.sin(k * x_grid)\n\n    # Test suite\n    test_cases = [\n        # (p, C) where p is interpolation order and C is Courant number\n        (1, 0.25),\n        (3, 0.50),\n        (0, 0.95),\n        (2, 1.00),\n        (1, 0.00),\n        (3, 0.75),\n    ]\n\n    results = []\n\n    for p, C in test_cases:\n        dt = C * dx / u\n        q_numerical = np.zeros(M)\n        \n        # --- Semi-Lagrangian Advection Step ---\n        # This loop calculates the advected field q_numerical.\n        for i in range(M):\n            # Calculate departure point for arrival grid point x_grid[i]\n            x_d = x_grid[i] - u * dt\n            \n            # Normalize departure point and find stencil base index/fractional part\n            s_d = x_d / dx\n            i0 = int(np.floor(s_d))\n            alpha = s_d - i0\n\n            # --- Interpolation ---\n            # Indices are taken modulo M to enforce periodic boundary conditions.\n            if p == 0:  # Nearest-neighbor interpolation\n                idx = int(np.floor(s_d + 0.5))\n                q_numerical[i] = q_initial[idx % M]\n            elif p == 1:  # Linear interpolation\n                q0 = q_initial[i0 % M]\n                q1 = q_initial[(i0 + 1) % M]\n                q_numerical[i] = (1.0 - alpha) * q0 + alpha * q1\n            elif p == 2:  # Quadratic Lagrange interpolation\n                q_m1 = q_initial[(i0 - 1) % M]\n                q_0 = q_initial[i0 % M]\n                q_1 = q_initial[(i0 + 1) % M]\n\n                L_m1 = alpha * (alpha - 1.0) / 2.0\n                L_0 = 1.0 - alpha**2\n                L_1 = alpha * (alpha + 1.0) / 2.0\n                \n                q_numerical[i] = L_m1 * q_m1 + L_0 * q_0 + L_1 * q_1\n            elif p == 3:  # Cubic Lagrange interpolation\n                q_m1 = q_initial[(i0 - 1) % M]\n                q_0 = q_initial[i0 % M]\n                q_1 = q_initial[(i0 + 1) % M]\n                q_2 = q_initial[(i0 + 2) % M]\n\n                L_m1 = -alpha * (alpha - 1.0) * (alpha - 2.0) / 6.0\n                L_0 = (alpha + 1.0) * (alpha - 1.0) * (alpha - 2.0) / 2.0\n                L_1 = -(alpha + 1.0) * alpha * (alpha - 2.0) / 2.0\n                L_2 = (alpha + 1.0) * alpha * (alpha - 1.0) / 6.0\n                \n                q_numerical[i] = L_m1 * q_m1 + L_0 * q_0 + L_1 * q_1 + L_2 * q_2\n\n        # --- Error Analysis ---\n        # Project numerical solution onto sin/cos basis to find amplitude and phase\n        sin_basis = np.sin(k * x_grid)\n        cos_basis = np.cos(k * x_grid)\n        \n        A_num = (2.0 / M) * np.dot(q_numerical, sin_basis)\n        B_num = (2.0 / M) * np.dot(q_numerical, cos_basis)\n        \n        R_num = np.sqrt(A_num**2 + B_num**2)\n        phi_num = np.arctan2(B_num, A_num)\n\n        # Calculate exact phase shift\n        phi_exact = -k * u * dt\n\n        # Calculate amplitude and phase errors\n        amp_error = R_num - 1.0\n        phase_error = phi_num - phi_exact\n        \n        # Wrap phase error to the interval [-pi, pi]\n        phase_error = (phase_error + np.pi) % (2.0 * np.pi) - np.pi\n        \n        # Append rounded results for this test case\n        results.append([round(amp_error, 8), round(phase_error, 8)])\n\n    # Format the final output string as a list of lists.\n    # e.g., [[err_a1,err_p1],[err_a2,err_p2],...]\n    formatted_results = [f\"[{res[0]:.8f},{res[1]:.8f}]\" for res in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "While high-order interpolation schemes excel with smooth data, they often fail dramatically near sharp gradients, a common feature in atmospheric fronts or tracer boundaries. This exercise confronts this challenge by demonstrating how high-order polynomials can introduce unphysical oscillations, a behavior related to the Gibbs phenomenon. You will then implement a practical and widely used solution: a hybrid scheme that uses a simple smoothness detector to dynamically switch to a more stable, lower-order interpolator where needed, thereby improving the overall robustness of the advection algorithm. ",
            "id": "4087372",
            "problem": "Consider one-dimensional semi-Lagrangian advection in the context of Numerical Weather Prediction (NWP) and climate modeling. The Semi-Lagrangian (SL) method advances a scalar tracer by following the trajectory of fluid parcels backward in time. Let the tracer be a function $q(x,t)$ and the velocity be a constant $u$. The governing advection equation is\n$$\n\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = 0,\n$$\non a periodic domain of length $L$. In a single SL time step from time $t^n$ to $t^{n+1}=t^n+\\Delta t$ on a uniform grid $x_i = i\\,\\Delta x$ for integer $i \\in \\{0,\\dots,N-1\\}$, the arrival point $x_i$ acquires tracer $q_i^{n+1}$ from the departure point located at\n$$\nx_d = x_i - u \\Delta t \\quad \\text{with periodic wrapping to } [0,L).\n$$\nTo evaluate $q^n(x_d)$, use polynomial interpolation on a uniform grid. High-order polynomial interpolation across non-smooth regions can exhibit Gibbs-like oscillations near discontinuities. Your task is to implement and analyze this phenomenon in the SL setting, and to design a criterion to switch to a lower-order stencil near detected non-smoothness.\n\nStarting from the fundamental definition of a trajectory governed by $\\frac{dx}{dt} = u$ and the interpolation definition for polynomial approximations on a uniform grid, do the following:\n\n- Implement a one-step semi-Lagrangian scheme on a periodic domain that, for each arrival grid index $i$, computes the departure location $x_d$, chooses a central base index $i_0 = \\lfloor x_d / \\Delta x \\rfloor$, and evaluates $q^n(x_d)$ by:\n  - A high-order interpolation using a $5$-point Lagrange polynomial over nodes $\\{i_0-2, i_0-1, i_0, i_0+1, i_0+2\\}$.\n  - A lower-order interpolation using a $2$-point linear stencil over nodes $\\{i_0, i_0+1\\}$.\n- Design and implement a detection criterion that flags local non-smoothness near the departure index $i_0$ using only gridpoint values of $q^n$. Use the normalized second-difference indicator\n$$\nS(i_0) = \\frac{\\left| q^n_{i_0+1} - 2 q^n_{i_0} + q^n_{i_0-1} \\right|}{\\left| q^n_{i_0+1} - q^n_{i_0} \\right| + \\left| q^n_{i_0} - q^n_{i_0-1} \\right| + \\varepsilon},\n$$\nwith a small positive $\\varepsilon$ to avoid division by zero. When $S(i_0)$ exceeds a threshold $\\tau$, switch the interpolation to the lower-order stencil for that arrival point; otherwise, use the $5$-point Lagrange stencil.\n- Use periodic boundary conditions for all indexing operations, i.e., interpret $q^n_{i}$ modulo $N$.\n\nQuantify oscillations using the overshoot metric, defined for a single SL step as\n$$\n\\text{overshoot}(q^{n+1}; q^n) = \\max\\left( \\max_i q^{n+1}_i - \\max_j q^n_j, \\ \\min_j q^n_j - \\min_i q^{n+1}_i, \\ 0 \\right),\n$$\nwhich measures the magnitude by which the arrival field exceeds the global range of the departure field.\n\nImplement two variants:\n- A high-order-only variant with no switching.\n- A switching variant using the above detection criterion and threshold $\\tau$.\n\nFor each test case below, compute:\n- The overshoot for the high-order-only variant.\n- The overshoot for the switching variant.\n- The number of arrival grid points that were flagged by the detection criterion (i.e., where $S(i_0) > \\tau$ in the switching variant).\n\nUse a periodic domain with $N$ grid points and uniform spacing $\\Delta x$, so $L = N \\Delta x$. Use a single constant velocity $u$ and a single time step $\\Delta t$. All physical quantities must be treated with the following units:\n- Velocity $u$ in $\\mathrm{m/s}$.\n- Grid spacing $\\Delta x$ in $\\mathrm{m}$.\n- Time step $\\Delta t$ in $\\mathrm{s}$.\nExpress overshoot values as decimals.\n\nTest suite:\n- Case $1$ (happy path, smooth): $N = 128$, $\\Delta x = 1000\\,\\mathrm{m}$, $L = N \\Delta x$, $u = 50\\,\\mathrm{m/s}$, $\\Delta t = 300\\,\\mathrm{s}$, tracer $q^n(x) = \\sin\\left(2\\pi x / L\\right)$, detection parameters $\\varepsilon = 10^{-12}$, $\\tau = 0.3$.\n- Case $2$ (discontinuity): $N = 128$, $\\Delta x = 1000\\,\\mathrm{m}$, $L = N \\Delta x$, $u = 50\\,\\mathrm{m/s}$, $\\Delta t = 300\\,\\mathrm{s}$, tracer $q^n(x) = 1$ for $x \\in [0.25 L, 0.75 L)$ and $q^n(x) = 0$ otherwise, detection parameters $\\varepsilon = 10^{-12}$, $\\tau = 0.3$.\n- Case $3$ (constant field edge case): $N = 128$, $\\Delta x = 1000\\,\\mathrm{m}$, $L = N \\Delta x$, $u = 50\\,\\mathrm{m/s}$, $\\Delta t = 300\\,\\mathrm{s}$, tracer $q^n(x) = 0.5$ for all $x$, detection parameters $\\varepsilon = 10^{-12}$, $\\tau = 0.3$.\n- Case $4$ (boundary discontinuity): $N = 128$, $\\Delta x = 1000\\,\\mathrm{m}$, $L = N \\Delta x$, $u = 50\\,\\mathrm{m/s}$, $\\Delta t = 300\\,\\mathrm{s}$, tracer $q^n(x) = 1$ for $x \\in [0, 0.1 L)$ and $q^n(x) = 0$ otherwise, detection parameters $\\varepsilon = 10^{-12}$, $\\tau = 0.3$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, output the list $[\\text{overshoot\\_high}, \\text{overshoot\\_switch}, \\text{flagged\\_count}]$. The final output, aggregating all cases, must be of the form\n$$\n\\big[ [o_{1,h}, o_{1,s}, f_1], [o_{2,h}, o_{2,s}, f_2], [o_{3,h}, o_{3,s}, f_3], [o_{4,h}, o_{4,s}, f_4] \\big],\n$$\nwhere each $o_{\\cdot,\\cdot}$ is a decimal and each $f_{\\cdot}$ is an integer.",
            "solution": "The problem requires the implementation and analysis of a one-dimensional semi-Lagrangian advection scheme, focusing on the numerical artifacts (Gibbs oscillations) that arise from high-order interpolation of non-smooth data, and the mitigation of these artifacts using a hybrid interpolation strategy.\n\nThe governing equation is the linear advection equation for a scalar tracer field $q(x,t)$ with a constant velocity $u$:\n$$\n\\frac{\\partial q}{\\partial t} + u \\frac{\\partial q}{\\partial x} = 0\n$$\nThis equation states that the tracer $q$ is conserved along characteristic curves defined by $\\frac{dx}{dt} = u$. These characteristics are straight lines in the $x-t$ plane: $x(t) = x_0 + ut$.\n\nThe semi-Lagrangian method exploits this principle. To find the value of the tracer at a grid point $x_i$ at the new time $t^{n+1} = t^n + \\Delta t$, we trace the characteristic curve backward in time by a duration $\\Delta t$. The location at the previous time $t^n$ is called the departure point, $x_d$. Its position is given by integrating the velocity backward:\n$$\nx_d = x_i - \\int_{t^n}^{t^{n+1}} u \\, dt = x_i - u \\Delta t\n$$\nThe value of the tracer is conserved along this trajectory, so the new value at the arrival point $x_i$ is simply the value of the tracer field at the old time $t^n$ evaluated at the departure point $x_d$:\n$$\nq(x_i, t^{n+1}) = q(x_d, t^n)\n$$\nSince the departure point $x_d$ does not generally coincide with a grid point, its value $q(x_d, t^n)$ must be determined by interpolating from the known grid-point values of $q^n$. The choice of interpolation method is crucial for the accuracy and stability of the scheme.\n\nThe computational domain is periodic with length $L = N \\Delta x$, where $N$ is the number of grid points and $\\Delta x$ is the uniform grid spacing. Any departure point $x_d$ calculated must be mapped back into the domain $[0, L)$ using a modulo operation. If we work with grid indices, a departure location $x_d$ corresponds to a non-integer grid coordinate $x'_d = x_d / \\Delta x$. The base integer index is $i_0 = \\lfloor x'_d \\rfloor$ and the fractional displacement is $\\alpha = x'_d - i_0$, where $\\alpha \\in [0, 1)$. All grid indices used for fetching data must be computed modulo $N$ to enforce periodicity.\n\nTwo interpolation methods are specified:\n\n1.  **High-Order 5-Point Lagrange Interpolation**: This method uses a quintic polynomial that passes through the five grid points centered around the departure point's base index $i_0$. The stencil of points is $\\{i_0-2, i_0-1, i_0, i_0+1, i_0+2\\}$. The interpolated value at a fractional position $\\alpha$ relative to $i_0$ is given by the Lagrange formula:\n    $$\n    q(x_d) \\approx \\sum_{j=-2}^{2} q^n_{i_0+j} L_j(\\alpha)\n    $$\n    where $q^n_{i_0+j}$ are the tracer values at the stencil points (with indices taken modulo $N$) and $L_j(\\alpha)$ are the Lagrange basis polynomials for integer nodes $\\{-2, -1, 0, 1, 2\\}$:\n    $$\n    L_j(\\alpha) = \\prod_{k=-2, k \\neq j}^{2} \\frac{\\alpha - k}{j - k}\n    $$\n    While highly accurate for smooth functions, this method is prone to generating spurious oscillations (Gibbs phenomenon) when interpolating across discontinuities.\n\n2.  **Low-Order 2-Point Linear Interpolation**: This method uses a line segment connecting the two grid points bracketing the departure point, $\\{i_0, i_0+1\\}$. The formula is:\n    $$\n    q(x_d) \\approx (1-\\alpha) q^n_{i_0} + \\alpha q^n_{i_0+1}\n    $$\n    This method is less accurate for smooth functions but is 'monotonicity-preserving' in the sense that it does not create new local maxima or minima, thus avoiding oscillations.\n\nTo combine the benefits of both methods, a hybrid or switching scheme is designed. This scheme uses the high-order method by default but switches to the low-order one in regions of suspected non-smoothness. The detection is performed using the normalized second-difference indicator, $S(i_0)$:\n$$\nS(i_0) = \\frac{|q^n_{i_0+1} - 2 q^n_{i_0} + q^n_{i_0-1}|}{|q^n_{i_0+1} - q^n_{i_0}| + |q^n_{i_0} - q^n_{i_0-1}| + \\varepsilon}\n$$\nThe numerator is a discrete approximation of the second derivative, sensitive to high curvature and discontinuities. The denominator is a discrete measure of the total variation, which normalizes the indicator and makes it sensitive to the 'sharpness' of features. A small constant $\\varepsilon$ prevents division by zero in constant-field regions. If $S(i_0)$ exceeds a predefined threshold $\\tau$, the field is considered non-smooth at $i_0$, and the interpolation is switched to the linear method for the corresponding arrival point.\n\nThe performance of the schemes is quantified by the overshoot metric, which measures the extent to which the new field $q^{n+1}$ violates the global bounds of the old field $q^n$:\n$$\n\\text{overshoot}(q^{n+1}; q^n) = \\max\\left( \\max_i q^{n+1}_i - \\max_j q^n_j, \\ \\min_j q^n_j - \\min_i q^{n+1}_i, \\ 0 \\right)\n$$\nA non-zero overshoot is indicative of numerical oscillations.\n\nThe overall algorithm proceeds as follows for each test case:\n1.  Define the grid and parameters $N, \\Delta x, u, \\Delta t$.\n2.  Generate the initial tracer field $q^n$ on the grid.\n3.  Calculate the global maximum and minimum of $q^n$.\n4.  Implement two sub-variants for a single time step:\n    a.  **High-order-only**: For each arrival grid point $i=0, \\dots, N-1$, calculate the departure point $x_d$, find the base index $i_0$ and fractional part $\\alpha$, and compute $q^{n+1}_i$ using the 5-point Lagrange interpolation.\n    b.  **Switching**: For each arrival point $i$, perform the same departure point calculation. Then, compute the smoothness indicator $S(i_0)$. If $S(i_0) > \\tau$, use 2-point linear interpolation and increment a counter for flagged points. Otherwise, use 5-point Lagrange interpolation.\n5.  For each variant, compute the overshoot of the resulting field $q^{n+1}$ with respect to the initial field $q^n$.\n6.  Report the overshoot for both variants and the number of flagged points in the switching scheme.",
            "answer": "```python\nimport numpy as np\n\ndef lagrange_5pt(q_stencil, alpha):\n    \"\"\"\n    Performs 5-point Lagrange interpolation on a stencil of 5 points.\n    Stencil points are assumed to be at local coordinates {-2, -1, 0, 1, 2}.\n    alpha is the fractional coordinate in [0, 1) relative to the center point (coord 0).\n    \n    Args:\n        q_stencil (list or np.ndarray): Tracer values at the 5 stencil points.\n        alpha (float): Fractional position for interpolation.\n    \n    Returns:\n        float: The interpolated value.\n    \"\"\"\n    # Pre-calculated Lagrange basis polynomial coefficients for nodes at -2, -1, 0, 1, 2\n    # L_j(alpha) = product_{k!=j} (alpha-k)/(j-k)\n    L_m2 = (alpha + 1) * alpha * (alpha - 1) * (alpha - 2) / 24.0\n    L_m1 = (alpha + 2) * alpha * (alpha - 1) * (alpha - 2) / -6.0\n    L_0  = (alpha + 2) * (alpha + 1) * (alpha - 1) * (alpha - 2) / 4.0\n    L_1  = (alpha + 2) * (alpha + 1) * alpha * (alpha - 2) / -6.0\n    L_2  = (alpha + 2) * (alpha + 1) * alpha * (alpha - 1) / 24.0\n    \n    return (q_stencil[0] * L_m2 + \n            q_stencil[1] * L_m1 + \n            q_stencil[2] * L_0 + \n            q_stencil[3] * L_1 + \n            q_stencil[4] * L_2)\n\ndef linear_2pt(q_stencil, alpha):\n    \"\"\"\n    Performs 2-point linear interpolation.\n    Stencil points are at local coordinates {0, 1}.\n    alpha is the fractional coordinate in [0, 1).\n\n    Args:\n        q_stencil (list or np.ndarray): Tracer values at the 2 stencil points.\n        alpha (float): Fractional position for interpolation.\n\n    Returns:\n        float: The interpolated value.\n    \"\"\"\n    return (1.0 - alpha) * q_stencil[0] + alpha * q_stencil[1]\n\ndef calculate_smoothness(q, i0, N, epsilon):\n    \"\"\"\n    Calculates the normalized second-difference indicator S(i0).\n    \"\"\"\n    q_im1 = q[(i0 - 1) % N]\n    q_i0  = q[i0 % N]\n    q_ip1 = q[(i0 + 1) % N]\n    \n    numerator = abs(q_ip1 - 2 * q_i0 + q_im1)\n    denominator = abs(q_ip1 - q_i0) + abs(q_i0 - q_im1) + epsilon\n    \n    if denominator  1e-20: # Practically zero\n        return 0.0\n    return numerator / denominator\n\ndef calculate_overshoot(q_new, q_old):\n    \"\"\"\n    Calculates the overshoot/undershoot metric.\n    \"\"\"\n    max_old = np.max(q_old)\n    min_old = np.min(q_old)\n    max_new = np.max(q_new)\n    min_new = np.min(q_new)\n\n    overshoot = max(0.0, max_new - max_old)\n    undershoot = max(0.0, min_old - min_new)\n    \n    return max(overshoot, undershoot)\n\ndef run_semi_lagrangian_step(params, q_n, mode):\n    \"\"\"\n    Performs one semi-Lagrangian time step.\n    \n    Args:\n        params (dict): Dictionary of simulation parameters.\n        q_n (np.ndarray): Tracer field at time t^n.\n        mode (str): 'high_order' or 'switching'.\n\n    Returns:\n        If mode is 'high_order': np.ndarray (the new tracer field q_n+1).\n        If mode is 'switching': tuple(np.ndarray, int) (q_n+1, number of flagged points).\n    \"\"\"\n    N = params['N']\n    dx = params['dx']\n    u = params['u']\n    dt = params['dt']\n    tau = params['tau']\n    epsilon = params['epsilon']\n    L = N * dx\n\n    q_np1 = np.zeros(N)\n    flagged_count = 0\n    x_grid = np.arange(N) * dx\n    \n    advection_dist = u * dt\n\n    for i in range(N):\n        x_i = x_grid[i]\n        \n        # Calculate departure point coordinate\n        x_d = x_i - advection_dist\n        \n        # Apply periodic boundary condition\n        x_d_periodic = x_d % L\n        \n        # Calculate base index and fractional part\n        xd_grid_coord = x_d_periodic / dx\n        i0 = int(np.floor(xd_grid_coord))\n        alpha = xd_grid_coord - i0\n        \n        use_linear = False\n        if mode == 'switching':\n            smoothness = calculate_smoothness(q_n, i0, N, epsilon)\n            if smoothness > tau:\n                use_linear = True\n                flagged_count += 1\n        \n        if use_linear:\n            # Low-order linear interpolation\n            stencil_indices = [(i0 + j) % N for j in range(2)]\n            q_stencil = q_n[stencil_indices]\n            q_np1[i] = linear_2pt(q_stencil, alpha)\n        else:\n            # High-order Lagrange interpolation\n            stencil_indices = [(i0 + j) % N for j in range(-2, 3)]\n            q_stencil = q_n[stencil_indices]\n            q_np1[i] = lagrange_5pt(q_stencil, alpha - 0.0) # alpha is already relative to i0\n\n    if mode == 'switching':\n        return q_np1, flagged_count\n    else:\n        return q_np1\n\ndef solve():\n    test_cases = [\n        {\n            'name': 'smooth', 'N': 128, 'dx': 1000.0, 'u': 50.0, 'dt': 300.0, \n            'epsilon': 1e-12, 'tau': 0.3,\n            'init_q': lambda x, L: np.sin(2 * np.pi * x / L)\n        },\n        {\n            'name': 'discontinuity', 'N': 128, 'dx': 1000.0, 'u': 50.0, 'dt': 300.0,\n            'epsilon': 1e-12, 'tau': 0.3,\n            'init_q': lambda x, L: np.where((x >= 0.25 * L)  (x  0.75 * L), 1.0, 0.0)\n        },\n        {\n            'name': 'constant', 'N': 128, 'dx': 1000.0, 'u': 50.0, 'dt': 300.0,\n            'epsilon': 1e-12, 'tau': 0.3,\n            'init_q': lambda x, L: np.full_like(x, 0.5)\n        },\n        {\n            'name': 'boundary_discontinuity', 'N': 128, 'dx': 1000.0, 'u': 50.0, 'dt': 300.0,\n            'epsilon': 1e-12, 'tau': 0.3,\n            'init_q': lambda x, L: np.where(x  0.1 * L, 1.0, 0.0)\n        }\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        N = params['N']\n        dx = params['dx']\n        L = N * dx\n        x_grid = np.arange(N) * dx\n        q_n = params['init_q'](x_grid, L)\n\n        # High-order only variant\n        q_np1_ho = run_semi_lagrangian_step(params, q_n, 'high_order')\n        overshoot_ho = calculate_overshoot(q_np1_ho, q_n)\n\n        # Switching variant\n        q_np1_sw, flagged_count = run_semi_lagrangian_step(params, q_n, 'switching')\n        overshoot_sw = calculate_overshoot(q_np1_sw, q_n)\n\n        result_list = [overshoot_ho, overshoot_sw, flagged_count]\n        all_results.append(result_list)\n        \n    # Format the output string as per requirements\n    result_strings = []\n    for res in all_results:\n        result_strings.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The previous practice highlighted the need for shape-preserving techniques to handle non-smooth data. This final exercise delves deeper, revealing the inherent trade-offs in such methods. By comparing a standard high-order scheme with a formally *monotonicity-preserving* one, you will quantify a crucial concept: enforcing desirable properties like monotonicity is not a \"free lunch\" and can degrade accuracy, especially at smooth extrema where limiters might be unnecessarily activated. Understanding this balance between formal accuracy and robustness is a cornerstone of designing sophisticated numerical models for weather and climate. ",
            "id": "4087342",
            "problem": "Consider the one-dimensional linear advection of a scalar tracer field in a periodic domain, where the governing equation is the advection equation $\\partial_t q + u \\, \\partial_x q = 0$. The Semi-Lagrangian (SL) method updates the tracer by following characteristics: for each arrival grid point $x_i$ at time $t^{n+1}$, the tracer is set equal to its value at the corresponding departure point at time $t^n$, namely $q^{n+1}(x_i) = q^n(x_i - u \\Delta t)$, with periodic wrapping of positions. In Numerical Weather Prediction (NWP) and climate modeling, the choice of interpolation used to evaluate $q^n$ at off-grid departure points induces a trade-off between monotonicity enforcement (to prevent spurious oscillations) and formal order of accuracy (which controls truncation error for smooth fields). Your task is to quantify this trade-off for a smooth profile with a single extremum.\n\nStarting from the advection equation and the characteristic definition $dx/dt = u$, implement a one-step SL update on a uniform periodic grid to compare two interpolation strategies at the departure points:\n- A formally third-order, non-limited cubic interpolation.\n- A monotonicity-preserving cubic Hermite interpolation with slope limiting that enforces local monotonicity (set nodal slopes to zero when neighboring secant slopes change sign, and otherwise use a harmonic mean of adjacent secant slopes), thereby reducing local order near smooth extrema.\n\nUse a constant velocity $u = 1 \\, \\mathrm{m/s}$, a periodic domain of length $L = 1 \\, \\mathrm{m}$, and a uniform grid with $N$ points and spacing $\\Delta x = L/N$. For a given Courant number $c = u \\Delta t / \\Delta x$, choose $\\Delta t = c \\, \\Delta x / u$ expressed in $\\mathrm{s}$. The initial condition is a smooth Gaussian with a single extremum,\n$$\nq_0(x) = \\exp\\!\\left(-\\frac{\\delta(x,x_0)^2}{2 \\sigma^2}\\right),\n$$\nwhere $x_0 = L/2$, $\\sigma = 0.1\\,L$, and $\\delta(x,x_0)$ is the signed shortest periodic distance on the circle of circumference $L$, i.e., $\\delta(x,x_0) = \\left((x-x_0) + L/2 \\ \\bmod\\ L\\right) - L/2$. The exact solution after one step is the shifted initial condition $q_{\\mathrm{exact}}(x_i) = q_0\\!\\left((x_i - u \\Delta t) \\ \\bmod\\ L\\right)$.\n\nFor each test case, perform one SL step from $q_0$ to obtain:\n- $q_{\\mathrm{cubic}}^{n+1}$ using the formally third-order cubic interpolation (use a local four-point, uniform-grid cubic such as Catmullâ€“Rom on stencil $\\{x_{j-1},x_j,x_{j+1},x_{j+2}\\}$ when the departure lies in cell $[x_j,x_{j+1})$).\n- $q_{\\mathrm{mono}}^{n+1}$ using monotone cubic Hermite interpolation with slope limiting computed from adjacent secant slopes on the uniform grid with periodic wrap. For each node index $i$, define the secant slopes $d_i = (q_{i+1}-q_i)/\\Delta x$ (with periodic indexing). If $d_{i-1} d_i \\le 0$, set the nodal slope $m_i = 0$. Otherwise set $m_i = \\frac{2 d_{i-1} d_i}{d_{i-1}+d_i}$ (harmonic mean). On interval $[x_j,x_{j+1}]$ with local coordinate $s = (x - x_j)/\\Delta x \\in [0,1]$, evaluate the cubic Hermite using $y_0 = q_j$, $y_1 = q_{j+1}$, $m_0 = m_j$, $m_1 = m_{j+1}$ and the standard basis functions.\n\nCompute for each interpolation the root-mean-square error\n$$\nE_{\\ast} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(q_{\\ast}^{n+1}(x_i) - q_{\\mathrm{exact}}(x_i)\\right)^2},\n$$\nwith $\\ast \\in \\{\\mathrm{cubic}, \\mathrm{mono}\\}$, which is dimensionless because $q$ is dimensionless. Quantify the accuracy degradation due to monotonicity enforcement by the ratio $R = E_{\\mathrm{mono}} / E_{\\mathrm{cubic}}$, reported as a floating-point number without units.\n\nImplement the above in a complete, runnable program and evaluate the following test suite, designed to exercise typical and edge conditions:\n- Case $1$: $N = 64$, $c = 0.30$.\n- Case $2$: $N = 64$, $c = 0.95$.\n- Case $3$: $N = 32$, $c = 0.50$.\n- Case $4$: $N = 128$, $c = 0.50$.\n- Case $5$: $N = 64$, $c = 0.05$.\n- Case $6$: $N = 64$, $c = 1.60$.\n\nYour program should produce a single line of output containing the ratios $R$ for the six cases, in order, as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5,r_6]$). All intermediate quantities involving length must be in $\\mathrm{m}$ and time in $\\mathrm{s}$, but the final printed ratios $R$ must be unitless floating-point numbers.",
            "solution": "The problem requires a quantitative comparison of two interpolation schemes within a one-dimensional semi-Lagrangian (SL) advection framework. The schemes are a formally third-order cubic interpolation and a monotonicity-preserving cubic Hermite interpolation. The comparison is based on the root-mean-square error against the exact solution for a smooth Gaussian profile after a single time step.\n\nThe governing partial differential equation is the linear advection equation for a scalar field $q(x,t)$:\n$$\n\\partial_t q + u \\, \\partial_x q = 0\n$$\nwhere $u$ is a constant velocity. The solution to this equation states that the value of $q$ is constant along characteristic curves defined by $dx/dt = u$. The solution is $q(x,t) = q_0(x - ut)$, where $q_0(x) = q(x, t=0)$ is the initial condition.\n\nThe semi-Lagrangian method discretizes this relationship. To find the value of the field $q$ at a grid point $x_i$ at the new time $t^{n+1} = t^n + \\Delta t$, we trace the characteristic curve backward in time from $(x_i, t^{n+1})$ to find the departure point $x_d$ at the previous time $t^n$. The new value is then set to the value of the field at the departure point:\n$$\nq^{n+1}(x_i) = q^n(x_d) = q^n(x_i - u \\Delta t)\n$$\nSince the departure point $x_d$ does not typically coincide with a grid point from the grid at time $t^n$, its value $q^n(x_d)$ must be estimated by interpolating from the known values at the grid points of the $t^n$ field.\n\nFirst, we establish the computational domain and initial state.\nThe domain is periodic with length $L = 1 \\, \\mathrm{m}$. It is discretized by a uniform grid of $N$ points, $x_i = i \\Delta x$ for $i = 0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L/N$. The velocity is constant at $u = 1 \\, \\mathrm{m/s}$. The time step $\\Delta t$ is determined by the Courant number $c$ via $\\Delta t = c \\Delta x / u$.\n\nThe initial condition at $t^n=t_0=0$ is a smooth Gaussian profile:\n$$\nq^n(x) = q_0(x) = \\exp\\!\\left(-\\frac{\\delta(x,x_0)^2}{2 \\sigma^2}\\right)\n$$\nwith its center at $x_0 = L/2 = 0.5 \\, \\mathrm{m}$ and width $\\sigma = 0.1 L = 0.1 \\, \\mathrm{m}$. The function $\\delta(x, x_0)$ represents the shortest signed distance on the periodic domain: $\\delta(x,x_0) = \\left((x-x_0) + L/2 \\right) \\bmod L - L/2$. This function ensures that the distance is correctly calculated across the periodic boundary, resulting in a value in the range $[-L/2, L/2]$.\n\nAfter one time step of duration $\\Delta t$, the exact solution at the grid points $x_i$ is the initial profile translated by a distance $u \\Delta t$:\n$$\nq_{\\mathrm{exact}}(x_i) = q_0((x_i - u \\Delta t) \\bmod L)\n$$\nThis is evaluated by applying the Gaussian function to the periodically-wrapped departure points.\n\nFor each grid point $x_i$, the departure point is $x_{d,i} = x_i - u \\Delta t$. Its position within the periodic domain $[0, L)$ is $x_{d,i}^{\\mathrm{p}} = x_{d,i} \\bmod L$. We then find the grid interval $[x_j, x_{j+1})$ that contains $x_{d,i}^{\\mathrm{p}}$. The index $j$ is found by $j = \\lfloor x_{d,i}^{\\mathrm{p}} / \\Delta x \\rfloor$, and the normalized coordinate within this interval is $s = (x_{d,i}^{\\mathrm{p}} / \\Delta x) - j \\in [0, 1)$. The values $q^{n+1}(x_i)$ are then calculated using two different interpolation methods.\n\n**1. Third-Order (Catmull-Rom) Cubic Interpolation**\nThis is a non-limited, formally third-order accurate scheme. For a departure point lying in the interval $[x_j, x_{j+1})$, it uses a four-point stencil of known values from the initial field: $\\{q^n_j, q^n_{j-1}, q^n_{j+1}, q^n_{j+2}\\}$. The indices are handled periodically (e.g., $q^n_{-1} = q^n_{N-1}$). The interpolated value $q_{\\mathrm{cubic}}^{n+1}(x_i)$ is given by the polynomial:\n$$\nP(s) = q^n_j + \\frac{1}{2}s(-q^n_{j-1} + q^n_{j+1}) + \\frac{1}{2}s^2(2q^n_{j-1} - 5q^n_j + 4q^n_{j+1} - q^n_{j+2}) + \\frac{1}{2}s^3(-q^n_{j-1} + 3q^n_j - 3q^n_{j+1} + q^n_{j+2})\n$$\nwhere $s \\in [0,1)$ is the local coordinate. This scheme is accurate for smooth fields but can introduce spurious oscillations (overshoots and undershoots) near sharp gradients or extrema.\n\n**2. Monotonicity-Preserving Cubic Hermite Interpolation**\nThis scheme is designed to prevent spurious oscillations. It is a form of cubic Hermite interpolation where the slopes at the interval endpoints are limited. The interpolant on $[x_j, x_{j+1}]$ is defined by the values $q^n_j, q^n_{j+1}$ and the nodal slopes $m_j, m_{j+1}$. The slopes are first calculated and then limited to enforce monotonicity.\n\nFirst, for each grid node $k$, we compute the secant slope $d_k = (q^n_{k+1} - q^n_k)/\\Delta x$, with periodic indexing.\nNext, we apply the slope limiter to determine the nodal slope $m_k$:\n- If $d_{k-1} d_k \\le 0$, the data is not monotonic around node $k$. To prevent oscillations, the slope at the node is set to zero: $m_k = 0$. This flattening occurs at the peak of the Gaussian where the adjacent secant slopes change sign.\n- If $d_{k-1} d_k  0$, the data is monotonic. The slope is set to the harmonic mean of the adjacent secants: $m_k = \\frac{2 d_{k-1} d_k}{d_{k-1} + d_k}$. This choice ensures that the interpolated slope remains bounded by the neighboring secant slopes.\n\nWith the limited slopes $\\{m_k\\}$, the cubic Hermite interpolant for a departure point in $[x_j, x_{j+1}]$ (with local coordinate $s$) is constructed using the Hermite basis functions:\n$$\nq_{\\mathrm{mono}}^{n+1}(x_i) = h_{00}(s)q^n_j + h_{01}(s)q^n_{j+1} + h_{10}(s)(m_j \\Delta x) + h_{11}(s)(m_{j+1} \\Delta x)\n$$\nwhere the basis functions are:\n$h_{00}(s) = 2s^3 - 3s^2 + 1$\n$h_{01}(s) = -2s^3 + 3s^2$\n$h_{10}(s) = s^3 - 2s^2 + s$\n$h_{11}(s) = s^3 - s^2$\nThe factors of $\\Delta x$ scale the physical slopes $m_j$ and $m_{j+1}$ to the required derivatives with respect to the local coordinate $s$. This scheme is monotonic by construction but its formal order of accuracy is locally reduced to first order where the slope limiter is active (i.e., where $m_k=0$).\n\n**Error Quantification**\nFor each scheme (denoted by $\\ast$), the root-mean-square error $E_{\\ast}$ is calculated against the exact solution:\n$$\nE_{\\ast} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(q_{\\ast}^{n+1}(x_i) - q_{\\mathrm{exact}}(x_i)\\right)^2}\n$$\nThe trade-off between accuracy and monotonicity is quantified by the ratio $R = E_{\\mathrm{mono}} / E_{\\mathrm{cubic}}$. A ratio $R1$ indicates that the enforcement of monotonicity has resulted in a larger RMS error compared to the formally higher-order, non-limited scheme. This is expected, as the slope limiting degrades accuracy, particularly at the smooth peak of the Gaussian profile. The test cases explore this trade-off under different grid resolutions ($N$) and Courant numbers ($c$).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the semi-Lagrangian advection problem for multiple test cases.\n    \"\"\"\n    test_cases = [\n        (64, 0.30),  # Case 1: N, c\n        (64, 0.95),  # Case 2\n        (32, 0.50),  # Case 3\n        (128, 0.50), # Case 4\n        (64, 0.05),  # Case 5\n        (64, 1.60),  # Case 6\n    ]\n\n    results = []\n    for N, c in test_cases:\n        # 1. Setup grid, parameters, and initial condition\n        L = 1.0\n        u = 1.0\n        x0 = L / 2.0\n        sigma = 0.1 * L\n\n        dx = L / N\n        dt = c * dx / u\n        grid_points = np.linspace(0.0, L, N, endpoint=False)\n\n        def periodic_distance(x, center, length):\n            \"\"\"Calculates the shortest signed distance on a periodic domain.\"\"\"\n            return ((x - center + length / 2.0) % length) - length / 2.0\n\n        q0 = np.exp(-periodic_distance(grid_points, x0, L)**2 / (2.0 * sigma**2))\n\n        # 2. Calculate departure points and exact solution\n        departure_points = grid_points - u * dt\n        q_exact = np.exp(-periodic_distance(departure_points, x0, L)**2 / (2.0 * sigma**2))\n\n        # 3. Perform interpolation for both schemes\n        q_cubic_next = interpolate(q0, departure_points, dx, L, scheme='cubic')\n        q_mono_next = interpolate(q0, departure_points, dx, L, scheme='mono')\n\n        # 4. Calculate RMS errors and the ratio\n        e_cubic = np.sqrt(np.mean((q_cubic_next - q_exact)**2))\n        e_mono = np.sqrt(np.mean((q_mono_next - q_exact)**2))\n        \n        ratio = e_mono / e_cubic\n        results.append(ratio)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef interpolate(q_field, dep_points, dx, L, scheme):\n    \"\"\"\n    Interpolates a field q_field at given departure points using the specified scheme.\n    \n    Args:\n        q_field (np.ndarray): The 1D array of scalar values on the uniform grid.\n        dep_points (np.ndarray): The 1D array of departure point coordinates.\n        dx (float): Grid spacing.\n        L (float): Domain length.\n        scheme (str): 'cubic' for Catmull-Rom or 'mono' for monotone Hermite.\n        \n    Returns:\n        np.ndarray: The interpolated values at the departure points.\n    \"\"\"\n    N = len(q_field)\n    # Wrap departure points into the periodic domain [0, L)\n    dep_points_periodic = dep_points % L\n    \n    # Find the left grid index j and the local coordinate s for each departure point\n    j = np.floor(dep_points_periodic / dx).astype(int)\n    s = (dep_points_periodic / dx) - j\n\n    # Get indices for stencil points with periodic wrapping\n    j_m1 = (j - 1) % N\n    j_p1 = (j + 1) % N\n    j_p2 = (j + 2) % N\n\n    if scheme == 'cubic':\n        # Catmull-Rom interpolation\n        q_jm1 = q_field[j_m1]\n        q_j = q_field[j]\n        q_jp1 = q_field[j_p1]\n        q_jp2 = q_field[j_p2]\n\n        # Polynomial form derived from the Catmull-Rom matrix\n        a = -0.5 * q_jm1 + 1.5 * q_j - 1.5 * q_jp1 + 0.5 * q_jp2\n        b = q_jm1 - 2.5 * q_j + 2.0 * q_jp1 - 0.5 * q_jp2\n        c = -0.5 * q_jm1 + 0.5 * q_jp1\n        d = q_j\n        \n        return ((a * s + b) * s + c) * s + d\n\n    elif scheme == 'mono':\n        # Monotone cubic Hermite interpolation\n        \n        # a) Calculate limited slopes\n        # Secant slopes d_i = (q_{i+1} - q_i) / dx\n        d = (np.roll(q_field, -1) - q_field) / dx\n        # Previous secant slopes d_{i-1}\n        d_prev = np.roll(d, 1)\n\n        m = np.zeros_like(q_field)\n        \n        # Mask where slopes have the same sign (monotonic region)\n        mono_mask = (d * d_prev) > 0.0\n        \n        # Harmonic mean for slopes in monotonic regions\n        # np.divide handles potential division by zero, although logic prevents it here\n        m[mono_mask] = np.divide(2.0 * d[mono_mask] * d_prev[mono_mask], \n                                 d[mono_mask] + d_prev[mono_mask])\n        \n        # b) Fetch values and slopes for interpolation\n        y0 = q_field[j]\n        y1 = q_field[j_p1]\n        m0 = m[j] * dx  # Scale slope for local s-coordinate derivative\n        m1 = m[j_p1] * dx\n\n        # c) Apply Hermite basis functions\n        s2 = s * s\n        s3 = s2 * s\n        \n        h00 = 2.0 * s3 - 3.0 * s2 + 1.0\n        h10 = s3 - 2.0 * s2 + s\n        h01 = -2.0 * s3 + 3.0 * s2\n        h11 = s3 - s2\n\n        return h00 * y0 + h10 * m0 + h01 * y1 + h11 * m1\n        \n    else:\n        raise ValueError(\"Unknown interpolation scheme specified.\")\n\n# Execute the main function\nsolve()\n```"
        }
    ]
}