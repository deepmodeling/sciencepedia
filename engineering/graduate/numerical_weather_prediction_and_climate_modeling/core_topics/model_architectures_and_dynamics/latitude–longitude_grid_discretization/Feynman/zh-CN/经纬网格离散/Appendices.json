{
    "hands_on_practices": [
        {
            "introduction": "数值模拟的稳定性至关重要。对于经纬度网格，由于经线向两极汇聚，Courant-Friedrichs-Lewy (CFL) 条件在高纬度地区变得尤为严苛。本练习将通过具体计算来确定最大稳定时间步长，让您从时间步长的角度直接、动手地理解“极点问题”。",
            "id": "4059983",
            "problem": "在一个数值天气预报模型中，一个被动标量在球形地球上使用结构化的经纬度网格进行平流计算。考虑一个位于纬度$\\phi=60^\\circ$ 的点，该点所在网格的经度角间距$\\Delta\\lambda=0.5^\\circ$和纬度角间距$\\Delta\\phi=0.5^\\circ$均是均匀的。地球半径为$R=6.371\\times 10^{6}\\ \\mathrm{m}$。该标量满足线性平流方程，该方程在物理（度量）网格的每个水平方向上使用一阶迎风格式进行空间离散，并采用时间显式格式。该格式的 Courant–Friedrichs–Lewy (CFL) 稳定性要求是，在每个一维方向上，Courant 数不超过一个给定的界限$C$，此处取$C=1$。假设在关心点有一个速度为$u=30\\ \\mathrm{m\\,s^{-1}}$的纯纬向均匀风，且经向分量为零。将物理单位下的纬向和经向局地网格间距视为球面上的弧长。从球面弧长和一维 CFL 条件的定义出发，推导该纬度上纬向所隐含的最大稳定时间步长$\\Delta t_{\\max}$。然后，使用相同的原理，确定如果经向风分量的大小与纬向分量相当，哪个水平方向将是限制性方向。使用$R=6.371\\times 10^{6}\\ \\mathrm{m}$和$C=1$计算$\\Delta t_{\\max}$的一个数值（以秒为单位）。需要时将角间距从度转换为弧度。将最终数值答案四舍五入到四位有效数字。以秒为单位表示最终时间。",
            "solution": "一维空间中的被动标量平流遵循线性平流方程\n$$\n\\frac{\\partial \\psi}{\\partial t} + u \\frac{\\partial \\psi}{\\partial x} = 0,\n$$\n其中$u$是沿坐标方向$x$的平流速度分量。对于采用一阶迎风空间格式的显式时间离散，经过充分检验的 Courant–Friedrichs–Lewy (CFL) 一维稳定性要求是 Courant 数\n$$\n\\mathcal{C} \\equiv \\frac{|u|\\,\\Delta t}{\\Delta x}\n$$\n满足\n$$\n\\mathcal{C} \\le C,\n$$\n对于此离散格式，$C=1$。\n\n在半径为$R$的球体上，纬度$\\phi$处对应于经度角度增量$\\Delta\\lambda$（以弧度为单位）的物理弧长（纬向）为\n$$\n\\Delta x_{\\lambda} = R\\cos\\phi\\,\\Delta\\lambda,\n$$\n对应于纬度角度增量$\\Delta\\phi$（以弧度为单位）的物理弧长（经向）为\n$$\n\\Delta x_{\\phi} = R\\,\\Delta\\phi.\n$$\n这些都源于球面上弧长的定义：沿大圆的弧长$ds = R\\,d\\theta$，而在固定纬度$\\phi$上的纬向弧长则因度量因子$\\cos\\phi$而减小。\n\n对于速度为$u$且经向分量为零的纯纬向风，只有纬向会施加稳定性约束。因此，由纬向决定的最大稳定时间步长为\n$$\n\\Delta t_{\\max} = \\frac{C\\,\\Delta x_{\\lambda}}{|u|} = \\frac{C\\,R\\cos\\phi\\,\\Delta\\lambda}{|u|}.\n$$\n现在我们代入给定值。首先将角间距转换为弧度。$0.5^\\circ$的角度增量等于\n$$\n\\Delta\\lambda = \\Delta\\phi = 0.5^\\circ \\times \\frac{\\pi}{180^\\circ} = \\frac{\\pi}{360}\\ \\text{radians}.\n$$\n在纬度$\\phi=60^\\circ$处，我们有\n$$\n\\cos\\phi = \\cos 60^\\circ = \\frac{1}{2}.\n$$\n因此，\n$$\n\\Delta x_{\\lambda} = R\\cos\\phi\\,\\Delta\\lambda = R \\left(\\frac{1}{2}\\right)\\left(\\frac{\\pi}{360}\\right) = \\frac{\\pi R}{720}.\n$$\n当$C=1$且$|u|=30\\ \\mathrm{m\\,s^{-1}}$时，最大稳定时间步长为\n$$\n\\Delta t_{\\max} = \\frac{C\\,\\Delta x_{\\lambda}}{|u|} = \\frac{1}{30}\\left(\\frac{\\pi R}{720}\\right) = \\frac{\\pi R}{21600}.\n$$\n代入$R=6.371\\times 10^{6}\\ \\mathrm{m}$可得数值\n$$\n\\Delta t_{\\max} = \\frac{\\pi\\,(6.371\\times 10^{6})}{21600}\\ \\mathrm{s}.\n$$\n计算得，\n$$\n\\Delta t_{\\max} \\approx 926.6243887\\ \\mathrm{s}.\n$$\n四舍五入到四位有效数字，结果为$926.6\\ \\mathrm{s}$。\n\n关于限制性方向：如果经向风分量的大小与纬向分量相当，则经向 CFL 约束为\n$$\n\\Delta t \\le \\frac{C\\,\\Delta x_{\\phi}}{|v|} = \\frac{C\\,R\\,\\Delta\\phi}{|v|}.\n$$\n在$\\phi=60^\\circ$且$\\Delta\\phi=\\Delta\\lambda=\\pi/360$时，我们有$\\Delta x_{\\phi} = R\\,\\pi/360$，而$\\Delta x_{\\lambda} = R\\,\\pi/720$。因此$\\Delta x_{\\lambda}$小了 2 倍，使得纬向更具限制性。因此，对于大小相当的$|u|$和$|v|$，在此纬度上，纬向设定了更严格的时间步长限制。\n\n所要求的最大稳定时间步长的单个数值结果（以秒为单位，并四舍五入到四位有效数字）报告如下。",
            "answer": "$$\\boxed{926.6}$$"
        },
        {
            "introduction": "除了稳定性，数值精度对于气候和天气模型也至关重要，尤其是在使用球谐函数表示场时。本练习聚焦于数值积分——即积分的数值近似——并比较了简单的均匀纬度网格与高斯-勒让德网格的精度。通过实现和比较这些方法，您将获得关于为何先进的谱模型偏爱特定网格结构的实践性见解。",
            "id": "4060072",
            "problem": "考虑一个单位半径球面，由经度$\\lambda \\in [0,2\\pi)$和纬度$\\phi \\in [-\\pi/2,\\pi/2]$参数化，其球面面积元为$dA = \\cos\\phi\\,d\\phi\\,d\\lambda$。在数值天气预报 (NWP) 和气候模拟中，纬向离散化对球谐函数的求积精度有很大影响。定义测试函数$\\psi(\\lambda,\\phi) = \\cos(m\\lambda)\\,P_n(\\sin\\phi)$，其中$P_n$是$n$次勒让德多项式，$m$和$n$为非负整数。$\\psi$在单位球面上的精确球面积分为\n$$\nI_{\\text{exact}} = \\int_{0}^{2\\pi}\\int_{-\\pi/2}^{\\pi/2} \\psi(\\lambda,\\phi)\\,\\cos\\phi\\,d\\phi\\,d\\lambda.\n$$\n使用变量替换$\\mu = \\sin\\phi$（因此$d\\mu = \\cos\\phi\\,d\\phi$且$\\mu\\in[-1,1]$），该积分可以写为\n$$\nI_{\\text{exact}} = \\int_{0}^{2\\pi}\\int_{-1}^{1} \\cos(m\\lambda)\\,P_n(\\mu)\\,d\\mu\\,d\\lambda.\n$$\n您的任务是使用两种经纬度网格离散化方法计算并比较$I_{\\text{exact}}$的离散近似值，然后通过报告绝对误差来评估它们的求积精度。角度必须以弧度处理。\n\n1. 均匀经纬度矩形法则：\n   - 经度：$L$个等距点$\\lambda_k = \\frac{2\\pi k}{L}$（$k=0,1,\\dots,L-1$），权重为$\\Delta\\lambda = \\frac{2\\pi}{L}$。\n   - 纬度：$J$个中点$\\phi_j = -\\frac{\\pi}{2} + \\left(j+\\frac{1}{2}\\right)\\Delta\\phi$（$j=0,1,\\dots,J-1$），其中$\\Delta\\phi = \\frac{\\pi}{J}$，矩形权重为$\\Delta\\phi$，度量因子为$\\cos\\phi_j$。\n   - 近似值：\n     $$\n     I_{\\text{uni}} = \\sum_{k=0}^{L-1} \\sum_{j=0}^{J-1} \\cos(m\\lambda_k)\\,P_n(\\sin\\phi_j)\\,\\cos\\phi_j\\,\\Delta\\lambda\\,\\Delta\\phi.\n     $$\n\n2. 在$\\mu$（纬度方向）上使用高斯-勒让德求积的高斯纬度网格和等距经度：\n   - 经度：$L$个等距点$\\lambda_k = \\frac{2\\pi k}{L}$（$k=0,1,\\dots,L-1$），权重为$\\Delta\\lambda = \\frac{2\\pi}{L}$。\n   - 纬度：$[-1,1]$上的$J$个高斯-勒让德节点和权重$\\{\\mu_j,w_j\\}$。\n   - 近似值：\n     $$\n     I_{\\text{gau}} = \\sum_{k=0}^{L-1} \\sum_{j=0}^{J-1} \\cos(m\\lambda_k)\\,P_n(\\mu_j)\\,w_j\\,\\Delta\\lambda.\n     $$\n\n使用的基本原理：\n- 单位球面的球面面积元为$dA = \\cos\\phi\\,d\\phi\\,d\\lambda$。\n- 变量替换$\\mu=\\sin\\phi$，因此$d\\mu=\\cos\\phi\\,d\\phi$。\n- 勒让德多项式在$[-1,1]$上关于权重$1$的正交性，意味着$\\int_{-1}^{1}P_n(\\mu)\\,d\\mu = 2$（当$n=0$）和$0$（当$n\\ge 1$）。\n- 精确的周期积分$\\int_0^{2\\pi}\\cos(m\\lambda)\\,d\\lambda = 2\\pi$（当$m=0$）和$0$（当$m\\ge 1$）。\n- 具有$J$个节点的高斯-勒让德求积对于在$[-1,1]$上次数至多为$2J-1$的多项式是精确的这一性质。\n\n基于这些，精确积分满足\n$$\nI_{\\text{exact}} = \n\\begin{cases}\n4\\pi,  \\text{若 } m=0 \\text{ 且 } n=0,\\\\\n0,  \\text{其他情况}。\n\\end{cases}\n$$\n\n实现一个程序，对每个测试用例计算$I_{\\text{uni}}$和$I_{\\text{gau}}$，并返回它们相对于$I_{\\text{exact}}$的绝对误差。使用以下测试套件，它涵盖了一般情况、高斯求积在纬度方向上精确的情况、均匀经纬度在纬度方向上表现不佳的情况以及一个经度混叠的边界情况：\n\n- 测试用例 1：$(L,J,m,n) = (64,32,3,5)$。\n- 测试用例 2：$(L,J,m,n) = (64,32,0,0)$。\n- 测试用例 3：$(L,J,m,n) = (64,32,0,7)$。\n- 测试用例 4：$(L,J,m,n) = (16,8,16,0)$。\n- 测试用例 5：$(L,J,m,n) = (32,3,0,7)$。\n\n对于每个测试用例，您的程序必须计算两个浮点数：绝对误差$|I_{\\text{uni}}-I_{\\text{exact}}|$和绝对误差$|I_{\\text{gau}}-I_{\\text{exact}}|$。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有测试用例结果的逗号分隔列表。每个结果本身是方括号内的双元素逗号分隔浮点数列表，整个序列也由方括号括起。例如：$[[e_{1,\\text{uni}},e_{1,\\text{gau}}],[e_{2,\\text{uni}},e_{2,\\text{gau}}],\\dots]$。角度必须以弧度解释。不应打印任何额外文本。",
            "solution": "我们从单位球面的参数化开始，其经度为$\\lambda \\in [0,2\\pi)$，纬度为$\\phi \\in [-\\pi/2,\\pi/2]$。单位半径球面的面积元为$dA=\\cos\\phi\\,d\\phi\\,d\\lambda$。测试函数为$\\psi(\\lambda,\\phi)=\\cos(m\\lambda)\\,P_n(\\sin\\phi)$，其中$P_n$是$n$次勒让德多项式。\n\n精确积分为\n$$\nI_{\\text{exact}} = \\int_{0}^{2\\pi}\\int_{-\\pi/2}^{\\pi/2} \\cos(m\\lambda)\\,P_n(\\sin\\phi)\\,\\cos\\phi\\,d\\phi\\,d\\lambda.\n$$\n使用$\\mu=\\sin\\phi$，其中$d\\mu=\\cos\\phi\\,d\\phi$且$\\mu\\in[-1,1]$，我们得到\n$$\nI_{\\text{exact}} = \\int_{0}^{2\\pi} \\cos(m\\lambda)\\,d\\lambda \\;\\times\\; \\int_{-1}^{1} P_n(\\mu)\\,d\\mu.\n$$\n通过对余弦的傅里叶分析和勒让德多项式的正交性，我们得到\n$$\n\\int_{0}^{2\\pi} \\cos(m\\lambda)\\,d\\lambda =\n\\begin{cases}\n2\\pi,  m=0,\\\\\n0,  m\\ge 1,\n\\end{cases}\n\\qquad\n\\int_{-1}^{1} P_n(\\mu)\\,d\\mu =\n\\begin{cases}\n2,  n=0,\\\\\n0,  n\\ge 1.\n\\end{cases}\n$$\n因此\n$$\nI_{\\text{exact}}=\n\\begin{cases}\n4\\pi,  m=0,\\,n=0,\\\\\n0,  \\text{其他情况}。\n\\end{cases}\n$$\n\n我们考虑两种离散求积方案。\n\n1. 均匀经纬度矩形法则。经度为$L$个等距点$\\lambda_k=\\frac{2\\pi k}{L}$，权重为$\\Delta\\lambda=\\frac{2\\pi}{L}$（$k=0,1,\\dots,L-1$）。纬度为$J$个中点$\\phi_j=-\\frac{\\pi}{2}+\\left(j+\\frac{1}{2}\\right)\\Delta\\phi$，其中$\\Delta\\phi=\\frac{\\pi}{J}$（$j=0,1,\\dots,J-1$），度量因子$\\cos\\phi_j$必须包含在面积元中。离散积分公式为\n$$\nI_{\\text{uni}} = \\sum_{k=0}^{L-1}\\sum_{j=0}^{J-1}\n\\cos(m\\lambda_k)\\,P_n(\\sin\\phi_j)\\,\\cos\\phi_j\\,\\Delta\\lambda\\,\\Delta\\phi.\n$$\n根据可分离性，我们可以将其解释为离散经向和与离散纬向和的乘积：\n$$\nI_{\\text{uni}}=\\left(\\Delta\\lambda \\sum_{k=0}^{L-1}\\cos(m\\lambda_k)\\right)\\left(\\Delta\\phi\\sum_{j=0}^{J-1}P_n(\\sin\\phi_j)\\cos\\phi_j\\right).\n$$\n在经度圆上，对于所有不是$L$倍数的整数$m$，等距和可以精确地积分$\\cos(m\\lambda)$（在这种情况下，结果恒为$0$），当$m=0$时等于$2\\pi$；如果$m$是$L$的正倍数，离散和会混叠到零频率分量上，结果等于$2\\pi$。因此，当$m$是$L$的倍数时，可能会发生经度混叠。\n\n2. 在$\\mu$方向上使用高斯-勒让德求积的高斯纬度网格和等距经度。设$\\{\\mu_j,w_j\\}_{j=0}^{J-1}$为区间$[-1,1]$上的$J$点高斯-勒让德求积节点和权重，经度如上所述。使用$\\mu$作为纬度坐标可以从被积函数中移除度量因子。离散积分公式为\n$$\nI_{\\text{gau}}=\\sum_{k=0}^{L-1}\\sum_{j=0}^{J-1}\\cos(m\\lambda_k)\\,P_n(\\mu_j)\\,w_j\\,\\Delta\\lambda\n= \\left(\\Delta\\lambda \\sum_{k=0}^{L-1}\\cos(m\\lambda_k)\\right)\\left(\\sum_{j=0}^{J-1}P_n(\\mu_j)\\,w_j\\right).\n$$\n根据高斯-勒让德性质，$\\sum_{j=0}^{J-1}P_n(\\mu_j)\\,w_j$对于任何$n\\le 2J-1$都精确等于$\\int_{-1}^{1}P_n(\\mu)\\,d\\mu$，特别地，当$n=0$时精确等于$2$。对于$n>2J-1$，求积会引入误差。与均匀方案一样，如果$m$是$L$的倍数，会发生经度混叠，导致离散经向和不为零，即使$\\cos(m\\lambda)$的精确积分为零。\n\n每个测试用例$(L,J,m,n)$的算法步骤：\n- 计算$\\Delta\\lambda=\\frac{2\\pi}{L}$和$\\lambda_k=\\frac{2\\pi k}{L}$（$k=0,\\dots,L-1$）。\n- 均匀经纬度：\n  - 计算$\\Delta\\phi=\\frac{\\pi}{J}$和$\\phi_j=-\\frac{\\pi}{2}+\\left(j+\\frac{1}{2}\\right)\\Delta\\phi$（$j=0,\\dots,J-1$）。\n  - 计算$P_n(\\sin\\phi_j)$和$\\cos\\phi_j$。\n  - 构建经向和$S_\\lambda^{\\text{uni}}=\\Delta\\lambda\\sum_{k=0}^{L-1}\\cos(m\\lambda_k)$。\n  - 构建纬向和$S_\\phi^{\\text{uni}}=\\Delta\\phi\\sum_{j=0}^{J-1}P_n(\\sin\\phi_j)\\cos\\phi_j$。\n  - 计算$I_{\\text{uni}}=S_\\lambda^{\\text{uni}}\\,S_\\phi^{\\text{uni}}$。\n- 高斯纬度：\n  - 获取高斯-勒让德节点和权重$\\{\\mu_j,w_j\\}$（$j=0,\\dots,J-1$）。\n  - 计算$P_n(\\mu_j)$。\n  - 构建经向和$S_\\lambda^{\\text{gau}}=\\Delta\\lambda\\sum_{k=0}^{L-1}\\cos(m\\lambda_k)$（与均匀经度相同）。\n  - 构建高斯-勒让德纬向和$S_\\mu^{\\text{gau}}=\\sum_{j=0}^{J-1}P_n(\\mu_j)\\,w_j$。\n  - 计算$I_{\\text{gau}}=S_\\lambda^{\\text{gau}}\\,S_\\mu^{\\text{gau}}$。\n- 计算精确积分$I_{\\text{exact}}=4\\pi$（如果$m=0$且$n=0$），否则$I_{\\text{exact}}=0$。\n- 报告绝对误差$|I_{\\text{uni}}-I_{\\text{exact}}|$和$|I_{\\text{gau}}-I_{\\text{exact}}|$。\n\n测试套件的解释：\n- 对于测试用例 1 $(L,J,m,n)=(64,32,3,5)$，精确积分为$0$。由于$m$不为$0$且不是$L$的倍数，经向和精确为$0$，这使得两种方案无论纬度处理如何都是精确的。\n- 对于测试用例 2 $(L,J,m,n)=(64,32,0,0)$，精确积分为$4\\pi$。高斯纬度求积是精确的，经向和也是精确的，因此$I_{\\text{gau}}=4\\pi$。均匀经纬度矩形法则近似计算纬向积分，产生一个小的误差。\n- 对于测试用例 3 $(L,J,m,n)=(64,32,0,7)$，精确积分为$0$。因为$n\\le 2J-1$，所以高斯纬度求积是精确的，因此$I_{\\text{gau}}=0$。均匀经纬度矩形法则会产生纬向求积误差。\n- 对于测试用例 4 $(L,J,m,n)=(16,8,16,0)$，精确积分为$0$，但$m$是$L$的倍数，导致经度混叠。两种方案都产生一个等于$2\\pi$的非零经向和，而高斯纬度对于$n=0$是精确的，从而产生一个大小为$4\\pi$的巨大误差；均匀经纬度方案的值与此相近，纬度误差很小。\n- 对于测试用例 5 $(L,J,m,n)=(32,3,0,7)$，精确积分为$0$，但高斯纬度的（精确）阶数为$2J-1=5$，小于$n=7$，因此引入了纬向求积误差；均匀经纬度方案也表现出纬向误差。\n\n程序应完全按照描述实现这些计算，并打印一行格式为$[[e_{1,\\text{uni}},e_{1,\\text{gau}}],[e_{2,\\text{uni}},e_{2,\\text{gau}}],[e_{3,\\text{uni}},e_{3,\\text{gau}}],[e_{4,\\text{uni}},e_{4,\\text{gau}}],[e_{5,\\text{uni}},e_{5,\\text{gau}}]]]$的内容，其中每个$e_{\\cdot,\\cdot}$是一个浮点数。所有角度都必须以弧度解释。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\nfrom scipy.special import eval_legendre\n\ndef spherical_integral_errors(L, J, m, n):\n    # Constants\n    two_pi = 2.0 * np.pi\n\n    # Longitudes: endpoints (equispaced)\n    k = np.arange(L)\n    lam = two_pi * k / L\n    dlam = two_pi / L\n\n    # Longitudinal sum (same for both schemes)\n    S_lambda = dlam * np.sum(np.cos(m * lam))\n\n    # Uniform latitude: midpoints in phi\n    dphi = np.pi / J\n    j = np.arange(J)\n    phi = -np.pi / 2.0 + (j + 0.5) * dphi\n    mu_uniform = np.sin(phi)\n    cosphi = np.cos(phi)\n\n    Pn_uniform = eval_legendre(n, mu_uniform)\n    S_phi_uniform = dphi * np.sum(Pn_uniform * cosphi)\n    I_uni = S_lambda * S_phi_uniform\n\n    # Gaussian latitude: Gauss-Legendre nodes and weights in mu\n    mu_gau, w_gau = leggauss(J)\n    Pn_gau = eval_legendre(n, mu_gau)\n    S_mu_gau = np.sum(Pn_gau * w_gau)\n    I_gau = S_lambda * S_mu_gau\n\n    # Exact integral: 4*pi if m=0 and n=0; else 0\n    I_exact = (4.0 * np.pi) if (m == 0 and n == 0) else 0.0\n\n    # Absolute errors\n    err_uni = abs(I_uni - I_exact)\n    err_gau = abs(I_gau - I_exact)\n    return err_uni, err_gau\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple (L, J, m, n)\n    test_cases = [\n        (64, 32, 3, 5),   # General case: exact 0, longitudinal sum zero\n        (64, 32, 0, 0),   # Non-zero exact integral (4*pi), Gaussian exact\n        (64, 32, 0, 7),   # Exact 0, Gaussian exact, uniform latitude error\n        (16, 8, 16, 0),   # Longitudinal aliasing: m multiple of L\n        (32, 3, 0, 7),    # Gaussian latitude inexact: 2J-1=5  n=7\n    ]\n\n    results = []\n    for L, J, m, n in test_cases:\n        err_uni, err_gau = spherical_integral_errors(L, J, m, n)\n        results.append([err_uni, err_gau])\n\n    # Format output: single line, list of lists with comma-separated floats, no extra spaces\n    def format_float(x):\n        # Use a concise representation with up to 12 significant digits\n        return f\"{x:.12g}\"\n\n    formatted = \"[\" + \",\".join(\"[\" + \",\".join(format_float(x) for x in pair) + \"]\" for pair in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        },
        {
            "introduction": "这项综合性练习将网格结构和数值方案的概念整合到一个完整的示踪剂平流实验中。您将比较标准均匀网格和等面积网格在质量守恒和最小化数值耗散方面的性能。这类比较实验是现代环流模型中动力核心开发和验证的基础。",
            "id": "4060101",
            "problem": "要求您设计并实现一个数值实验，比较在两种球体经纬度离散化方案上的全局示踪剂平流：一种是均匀经纬度网格，另一种是等面积经纬度网格。该实验必须在两种网格上使用相同的预设速度场，并量化两个诊断量：总示踪剂质量的守恒性和一次完整旋转后的数值扩散（平方振幅损失）。实现必须是一个完整的、可运行的程序。\n\n推导的基础是在半径为$R$的球体上，用地理坐标$(\\lambda,\\phi)$（其中$\\lambda$是经度，$\\phi$是纬度）表示的被动示踪剂的球面平流方程，以及物理速度和坐标平流速率之间的运动学关系。示踪剂$q(\\lambda,\\phi,t)$满足\n$$\n\\frac{\\partial q}{\\partial t} + \\frac{u(\\lambda,\\phi,t)}{R\\cos\\phi}\\frac{\\partial q}{\\partial \\lambda} + \\frac{v(\\lambda,\\phi,t)}{R}\\frac{\\partial q}{\\partial \\phi} = 0,\n$$\n其中$u$是纬向速度（东西向），$v$是经向速度（南北向），$R$以米为单位。考虑一个围绕地理轴的刚体旋转，其速度由下式给出\n$$\nu(\\phi) = \\Omega R \\cos\\phi, \\quad v(\\phi) = 0,\n$$\n其中$\\Omega$是以弧度/秒为单位的恒定角速度。在这种刚体旋转下，沿经度的坐标平流速度在纬度上是恒定的：\n$$\nc \\equiv \\frac{u(\\phi)}{R\\cos\\phi} = \\Omega.\n$$\n\n网格定义：\n- 均匀经纬度网格：定义$N_\\lambda$条经线和$N_\\phi$条纬线，其边界为\n$$\n\\lambda_i^{e} = -\\pi + i\\,\\Delta\\lambda,\\quad \\Delta\\lambda = \\frac{2\\pi}{N_\\lambda},\\quad i = 0,1,\\dots,N_\\lambda,\n$$\n$$\n\\phi_j^{e} = -\\frac{\\pi}{2} + j\\,\\Delta\\phi,\\quad \\Delta\\phi = \\frac{\\pi}{N_\\phi},\\quad j = 0,1,\\dots,N_\\phi,\n$$\n中心点为$\\lambda_i = \\frac{1}{2}(\\lambda_i^{e}+\\lambda_{i+1}^{e})$，$\\phi_j = \\frac{1}{2}(\\phi_j^{e}+\\phi_{j+1}^{e})$。在纬度带$j$中的网格单元面积为\n$$\nA_j = R^2\\,\\Delta\\lambda\\,\\left(\\sin\\phi_{j+1}^{e} - \\sin\\phi_{j}^{e}\\right),\n$$\n在同一纬度带内，该面积沿经度是恒定的。\n\n- 等面积经纬度网格：保持经线与均匀网格相同，但选择纬度边界，使得对于给定的$\\Delta\\lambda$，所有纬度带的单元面积相等。定义\n$$\ns_j = -1 + \\frac{2j}{N_\\phi},\\quad \\phi_j^{e} = \\arcsin(s_j),\\quad j = 0,1,\\dots,N_\\phi,\n$$\n中心点由$s_{j+\\frac{1}{2}} = -1 + \\frac{2(j+\\frac{1}{2})}{N_\\phi}$和$\\phi_j = \\arcsin\\left(s_{j+\\frac{1}{2}}\\right)$给出。在纬度带$j$中，每个经度的单元面积同样为\n$$\nA_j = R^2\\,\\Delta\\lambda\\,\\left(\\sin\\phi_{j+1}^{e} - \\sin\\phi_{j}^{e}\\right),\n$$\n根据构造，该面积对所有$j$都是相等的。\n\n示踪剂初始化：在时间$t=0$时，通过对一个连续函数进行采样来初始化一个平滑的示踪剂\n$$\nq_0(\\lambda,\\phi) = \\exp\\left(-\\frac{1}{2}\\left[\\left(\\frac{\\phi-\\phi_0}{\\sigma_\\phi}\\right)^2 + \\left(\\frac{\\Delta\\lambda_p(\\lambda-\\lambda_0)}{\\sigma_\\lambda}\\right)^2\\right]\\right),\n$$\n其中$\\Delta\\lambda_p(\\cdot)$表示映射到$[-\\pi,\\pi]$区间内的$2\\pi$周期性环绕差值，$\\phi_0$、$\\lambda_0$是以弧度为单位的中心位置，宽度$\\sigma_\\phi$和$\\sigma_\\lambda$也以弧度为单位。对于每个网格，在网格单元中心$(\\lambda_i,\\phi_j)$处对示踪剂值进行采样。\n\n时间步进和离散化：基于恒定的坐标速度$c=\\Omega$，为每个纬度带推导一个沿经度的一维一阶迎风格式。设$\\mathrm{CFL} \\equiv \\frac{c\\,\\Delta t}{\\Delta\\lambda}$，其中$\\Delta t$是以秒为单位的时间步长。在经度方向使用周期性边界条件和东向流的情况下，每一步的迎风更新应与沿每个纬度圈的离散质量守恒相一致。积分一个完整的旋转周期$T = \\frac{2\\pi}{\\Omega}$，使用一个恒定的$\\Delta t$，该$\\Delta t$的选择是为了达到一个指定的$\\mathrm{CFL}$值。\n\n诊断量：\n- 任何时刻的总质量由面积加权和近似得出\n$$\nM(t) = \\sum_{j=0}^{N_\\phi-1}\\sum_{i=0}^{N_\\lambda-1} q_{i,j}(t)\\,A_j.\n$$\n计算一次旋转后的相对质量误差，\n$$\n\\epsilon_M = \\frac{M(T)-M(0)}{M(0)}.\n$$\n分别为均匀网格和等面积网格报告$\\epsilon_M$。\n\n- 数值扩散通过面积加权的平方振幅损失来量化，\n$$\nE(t) = \\sum_{j=0}^{N_\\phi-1}\\sum_{i=0}^{N_\\lambda-1} q_{i,j}^2(t)\\,A_j,\n$$\n以及扩散度量\n$$\n\\delta_E = 1 - \\frac{E(T)}{E(0)}.\n$$\n分别为每个网格报告$\\delta_E$，并报告一个布尔值，指示在相同测试用例下，等面积网格是否表现出比均匀网格严格更小的扩散。\n\n角度单位必须是弧度。物理单位必须一致：$R$以米为单位， $u$和$v$以米/秒为单位，$t$以秒为单位。使用$R = 6.371\\times 10^6$米和$\\Omega = \\frac{2\\pi}{T}$，其中一个旋转周期$T = 86400$秒。\n\n测试套件：为以下四组参数集实现该实验，将其作为一组用例列表，每个用例是一个元组$(N_\\lambda, N_\\phi, \\mathrm{CFL}, \\phi_0, \\lambda_0, \\sigma_\\phi, \\sigma_\\lambda)$：\n- 用例 1：$(256, 128, 0.3, 0.3, 1.0, 0.25, 0.3)$。\n- 用例 2：$(256, 128, 0.3, 1.3, -2.0, 0.15, 0.2)$。\n- 用例 3：$(64, 32, 0.7, -0.5, 0.0, 0.35, 0.8)$。\n- 用例 4：$(360, 181, 0.95, 0.0, 2.5, 0.2, 0.2)$。\n\n对于每个用例，您的程序应生成一个结果列表，其中包含按顺序排列的$5$个条目：$[\\epsilon_M^{\\mathrm{uni}}, \\epsilon_M^{\\mathrm{ea}}, \\delta_E^{\\mathrm{uni}}, \\delta_E^{\\mathrm{ea}}, \\mathrm{ea\\_less\\_diff}]$，其中$\\epsilon_M^{\\mathrm{uni}}$和$\\epsilon_M^{\\mathrm{ea}}$是浮点数，$\\delta_E^{\\mathrm{uni}}$和$\\delta_E^{\\mathrm{ea}}$是浮点数，而$\\mathrm{ea\\_less\\_diff}$是一个布尔值。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有四个用例的结果，格式为一个以逗号分隔、用方括号括起来的 Python 风格列表的列表，例如$[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]]$。",
            "solution": "在半径为$R$的球体上，被动示踪剂$q(\\lambda,\\phi,t)$的球面平流方程将示踪剂的变化趋势与坐标空间中平流通量的散度联系起来。经度$\\lambda$和纬度$\\phi$是以弧度为单位的角度坐标，物理速度分量$(u,v)$与坐标速度之间的转换分别涉及到沿经度和纬度的度量因子$R\\cos\\phi$和$R$。控制方程为\n$$\n\\frac{\\partial q}{\\partial t} + \\frac{u(\\lambda,\\phi,t)}{R\\cos\\phi}\\frac{\\partial q}{\\partial \\lambda} + \\frac{v(\\lambda,\\phi,t)}{R}\\frac{\\partial q}{\\partial \\phi} = 0.\n$$\n对于围绕地理轴的刚体旋转，$u(\\phi) = \\Omega R \\cos\\phi$且$v(\\phi) = 0$，其中$\\Omega$是以弧度/秒为单位的恒定角速度。代入平流方程可得\n$$\n\\frac{\\partial q}{\\partial t} + \\Omega \\frac{\\partial q}{\\partial \\lambda} = 0,\n$$\n这是一个沿经度的一维平流方程，其速度为恒定的$\\Omega$，且与$\\phi$无关。这种简化消除了两极的坐标奇点（$\\cos\\phi$因子被消掉），并确保每个纬度圈在经向平流速率方面表现一致。\n\n球体的离散化使用两种网格：\n\n$1.$均匀经纬度网格：经度将$[-\\pi,\\pi)$划分为$N_\\lambda$个大小为$\\Delta\\lambda = \\frac{2\\pi}{N_\\lambda}$的相等区间，纬度将$[-\\frac{\\pi}{2},\\frac{\\pi}{2}]$划分为$N_\\phi$个大小为$\\Delta\\phi=\\frac{\\pi}{N_\\phi}$的相等区间。单元中心位于这些边界的中点。在纬度带$j$中，每个经度的单元面积为\n$$\nA_j = R^2\\,\\Delta\\lambda\\,\\left(\\sin\\phi_{j+1}^{e} - \\sin\\phi_{j}^{e}\\right),\n$$\n这是由球面表面积元$R^2\\cos\\phi\\,d\\phi\\,d\\lambda$在该纬度带上积分得到的。\n\n$2.$等面积经纬度网格：经线相同，但选择纬度边界，使得每个纬度带每经度的面积相同。从南极到纬度$\\phi$的累积面积与$\\sin\\phi$成正比，因此等面积纬度带对应于均匀间隔的$\\sin\\phi$值。定义$s_j = -1 + \\frac{2j}{N_\\phi}$和$\\phi_j^e = \\arcsin(s_j)$可得到等面积纬度带，并且再次\n$$\nA_j = R^2\\,\\Delta\\lambda\\,\\left(\\sin\\phi_{j+1}^{e} - \\sin\\phi_{j}^{e}\\right)\n$$\n根据构造，该面积对于$j$是恒定的。中心点通过在$s$空间中的中点计算：$s_{j+\\frac{1}{2}} = -1 + \\frac{2(j+\\frac{1}{2})}{N_\\phi}$和$\\phi_j = \\arcsin\\left(s_{j+\\frac{1}{2}}\\right)$。\n\n示踪剂初始化在单元中心对一个在经纬度上均为平滑高斯分布的函数进行采样：\n$$\nq_0(\\lambda,\\phi) = \\exp\\left(-\\frac{1}{2}\\left[\\left(\\frac{\\phi-\\phi_0}{\\sigma_\\phi}\\right)^2 + \\left(\\frac{\\Delta\\lambda_p(\\lambda-\\lambda_0)}{\\sigma_\\lambda}\\right)^2\\right]\\right),\n$$\n其中$\\Delta\\lambda_p(\\cdot)$将经度差值环绕到$[-\\pi,\\pi]$区间以保持周期性。\n\n我们使用一阶迎风法在每个纬度圈上对经度方向的一维平流进行离散化，该方法与运动方向（东向）和周期性边界条件一致。设$q_{i,j}^n$为时间层$n$、经度索引$i$和纬度索引$j$处的示踪剂。定义 Courant–Friedrichs–Lewy (CFL) 数\n$$\n\\mathrm{CFL} = \\frac{c\\,\\Delta t}{\\Delta\\lambda} = \\frac{\\Omega\\,\\Delta t}{\\Delta\\lambda},\n$$\n其中$c=\\Omega$。用于东向平流的迎风格式更新为\n$$\nq_{i,j}^{n+1} = q_{i,j}^{n} - \\mathrm{CFL}\\,\\left(q_{i,j}^{n} - q_{i-1,j}^{n}\\right),\n$$\n其中$i$使用周期性索引。该格式可以从经度方向的通量差分形式推导出来，并且在每个纬度圈上是守恒的：对$i$求和会使差分项对消，从而为每个$j$保持$\\sum_i q_{i,j}$不变。由于对于两种网格，每个圈内的单元面积$A_j$沿经度都是恒定的，因此每个圈内的质量是守恒的，从而全局总质量\n$$\nM^n = \\sum_{j=0}^{N_\\phi-1}\\sum_{i=0}^{N_\\lambda-1} q_{i,j}^{n} A_j\n$$\n在舍入误差范围内是守恒的。数值扩散源于迎风格式的耗散性质，可通过面积加权的平方振幅来量化\n$$\nE^n = \\sum_{j=0}^{N_\\phi-1}\\sum_{i=0}^{N_\\lambda-1} \\left(q_{i,j}^{n}\\right)^2 A_j.\n$$\n在一个旋转周期$T = \\frac{2\\pi}{\\Omega}$内，精确解会将示踪剂沿经度移动，而其形状或$E$值不变，但离散格式会减小$E$值，其减小方式取决于$\\mathrm{CFL}$和$q$沿经度的谱含量。\n\n实现细节：\n- 使用$R = 6.371\\times 10^6$米和$T = 86400$秒，因此$\\Omega = \\frac{2\\pi}{T}$弧度/秒。\n- 对于每个测试用例，构建两种网格，在中心点采样$q_0$，通过$\\Delta t = \\mathrm{CFL}\\,\\frac{\\Delta\\lambda}{\\Omega}$从给定的$\\mathrm{CFL}$计算$\\Delta t$，并选择步数$N_{\\mathrm{steps}}$为最接近$\\frac{T}{\\Delta t}$的整数以近似一次旋转。应用迎风更新$N_{\\mathrm{steps}}$次。\n- 计算相对质量误差\n$$\n\\epsilon_M = \\frac{M(T)-M(0)}{M(0)}\n$$\n对于两种网格，以及扩散度量\n$$\n\\delta_E = 1 - \\frac{E(T)}{E(0)}\n$$\n对于两种网格。\n- 报告一个布尔值$\\mathrm{ea\\_less\\_diff}$，指示等面积网格的$\\delta_E$是否严格小于均匀网格的$\\delta_E$。\n\n测试覆盖理由：\n- 用例 1 是一个通用的‘理想路径’，具有中等分辨率和$\\mathrm{CFL}$值，示踪剂位于中纬度。\n- 用例 2 将示踪剂放置在极地附近，以探测网格的面积变化和采样行为。\n- 用例 3 使用粗分辨率和较大的$\\mathrm{CFL}$值，挑战数值扩散和稳定性边界。\n- 用例 4 使用接近一度的分辨率和接近$1$的$\\mathrm{CFL}$值，探测迎风格式稳定性的边界。\n\n最终输出将每个用例的结果聚合为单行打印的 Python 列表的列表，以便于自动评估。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_uniform_grid(n_lon, n_lat, R):\n    # Longitude edges and centers\n    dlon = 2.0 * np.pi / n_lon\n    lon_edges = -np.pi + np.arange(n_lon + 1) * dlon\n    lon_centers = 0.5 * (lon_edges[:-1] + lon_edges[1:])\n    # Latitude edges and centers\n    dlat = np.pi / n_lat\n    lat_edges = -0.5 * np.pi + np.arange(n_lat + 1) * dlat\n    lat_centers = 0.5 * (lat_edges[:-1] + lat_edges[1:])\n    # Cell area per longitude in each latitude band\n    band_areas = (R**2) * dlon * (np.sin(lat_edges[1:]) - np.sin(lat_edges[:-1]))\n    return lon_centers, lat_centers, band_areas, dlon\n\ndef build_equal_area_grid(n_lon, n_lat, R):\n    # Longitude edges and centers\n    dlon = 2.0 * np.pi / n_lon\n    lon_edges = -np.pi + np.arange(n_lon + 1) * dlon\n    lon_centers = 0.5 * (lon_edges[:-1] + lon_edges[1:])\n    # Equal-area latitude edges via uniform spacing in sin(phi)\n    s_edges = -1.0 + 2.0 * (np.arange(n_lat + 1) / n_lat)\n    lat_edges = np.arcsin(s_edges)\n    # Centers via midpoints in s-space\n    s_centers = -1.0 + 2.0 * ((np.arange(n_lat) + 0.5) / n_lat)\n    lat_centers = np.arcsin(s_centers)\n    # Cell area per longitude in each latitude band\n    band_areas = (R**2) * dlon * (np.sin(lat_edges[1:]) - np.sin(lat_edges[:-1]))\n    return lon_centers, lat_centers, band_areas, dlon\n\ndef periodic_delta_lambda(lon_minus_center):\n    # Map longitudinal difference to [-pi, pi]\n    x = (lon_minus_center + np.pi) % (2.0 * np.pi) - np.pi\n    return x\n\ndef initialize_tracer(lon_centers, lat_centers, phi0, lam0, sigma_phi, sigma_lam):\n    # Create 2D grids of centers\n    lon2d, lat2d = np.meshgrid(lon_centers, lat_centers)\n    dlam = periodic_delta_lambda(lon2d - lam0)\n    dphi = lat2d - phi0\n    q0 = np.exp(-0.5 * ((dphi / sigma_phi) ** 2 + (dlam / sigma_lam) ** 2))\n    return q0\n\ndef advect_upwind_zonal(q, CFL, n_steps):\n    # First-order upwind scheme for eastward advection along longitude (axis=1)\n    for _ in range(n_steps):\n        q = q - CFL * (q - np.roll(q, shift=1, axis=1))\n    return q\n\ndef mass_and_energy(q, band_areas):\n    # Area-weighted mass and squared amplitude\n    # band_areas shape: (n_lat,), q shape: (n_lat, n_lon)\n    area2d = band_areas[:, None]\n    mass = np.sum(q * area2d)\n    energy = np.sum((q ** 2) * area2d)\n    return mass, energy\n\ndef run_case(case, R, T):\n    n_lon, n_lat, CFL_target, phi0, lam0, sigma_phi, sigma_lam = case\n    # Angular speed Omega and dt for target CFL\n    Omega = 2.0 * np.pi / T\n\n    # Build grids\n    lon_u, lat_u, areas_u, dlon_u = build_uniform_grid(n_lon, n_lat, R)\n    lon_e, lat_e, areas_e, dlon_e = build_equal_area_grid(n_lon, n_lat, R)\n\n    # Initialize tracer\n    q0_u = initialize_tracer(lon_u, lat_u, phi0, lam0, sigma_phi, sigma_lam)\n    q0_e = initialize_tracer(lon_e, lat_e, phi0, lam0, sigma_phi, sigma_lam)\n\n    # Choose dt based on target CFL and longitudinal spacing (Omega is coordinate speed)\n    dt_u = CFL_target * dlon_u / Omega\n    dt_e = CFL_target * dlon_e / Omega\n\n    # Steps to approximate one full rotation\n    n_steps_u = max(1, int(np.round(T / dt_u)))\n    n_steps_e = max(1, int(np.round(T / dt_e)))\n\n    # Actual CFL used (may differ slightly due to rounding of steps if one adjusts dt,\n    # but we keep dt fixed per target and use integer steps)\n    CFL_u = Omega * dt_u / dlon_u\n    CFL_e = Omega * dt_e / dlon_e\n\n    # Mass and energy at t=0\n    m0_u, e0_u = mass_and_energy(q0_u, areas_u)\n    m0_e, e0_e = mass_and_energy(q0_e, areas_e)\n\n    # Advect\n    qT_u = advect_upwind_zonal(q0_u.copy(), CFL_u, n_steps_u)\n    qT_e = advect_upwind_zonal(q0_e.copy(), CFL_e, n_steps_e)\n\n    # Mass and energy at t=T (approximate)\n    mT_u, eT_u = mass_and_energy(qT_u, areas_u)\n    mT_e, eT_e = mass_and_energy(qT_e, areas_e)\n\n    # Diagnostics\n    mass_err_u = (mT_u - m0_u) / m0_u\n    mass_err_e = (mT_e - m0_e) / m0_e\n\n    diff_u = 1.0 - (eT_u / e0_u)\n    diff_e = 1.0 - (eT_e / e0_e)\n\n    ea_less_diff = bool(diff_e  diff_u)\n\n    return [mass_err_u, mass_err_e, diff_u, diff_e, ea_less_diff]\n\ndef solve():\n    # Constants: Earth radius and rotation period\n    R = 6.371e6  # meters\n    T = 86400.0  # seconds\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (256, 128, 0.3, 0.3, 1.0, 0.25, 0.3),\n        (256, 128, 0.3, 1.3, -2.0, 0.15, 0.2),\n        (64, 32, 0.7, -0.5, 0.0, 0.35, 0.8),\n        (360, 181, 0.95, 0.0, 2.5, 0.2, 0.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case, R, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"{results}\")\n\nsolve()\n```"
        }
    ]
}