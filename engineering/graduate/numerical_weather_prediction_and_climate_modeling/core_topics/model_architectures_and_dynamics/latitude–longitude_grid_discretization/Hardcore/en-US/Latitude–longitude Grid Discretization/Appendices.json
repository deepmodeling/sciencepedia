{
    "hands_on_practices": [
        {
            "introduction": "The latitude-longitude grid's primary drawback is the convergence of meridians at the poles, which severely constrains the time step in models using explicit time integration. This exercise provides a fundamental hands-on calculation of the Courant-Friedrichs-Lewy (CFL) stability limit, forcing you to connect the grid geometry directly to the maximum permissible time step. By working through this calculation , you will gain a concrete appreciation for the \"pole problem\" and why it necessitates special numerical techniques or alternative grids in global modeling.",
            "id": "4059983",
            "problem": "A passive scalar is advected on a spherical Earth using a structured latitude–longitude grid in a numerical weather prediction model. Consider a point at latitude $\\phi=60^\\circ$ on a grid with uniform angular spacings $\\Delta\\lambda=0.5^\\circ$ in longitude and $\\Delta\\phi=0.5^\\circ$ in latitude. The Earth’s radius is $R=6.371\\times 10^{6}\\ \\mathrm{m}$. The scalar satisfies the linear advection equation, discretized explicitly in time with a first-order upwind scheme in each horizontal direction on the physical (metric) grid. The Courant–Friedrichs–Lewy (CFL) stability requirement for this scheme is that, in each one-dimensional direction, the Courant number not exceed a prescribed bound $C$, taken here to be $C=1$.\n\nAssume a purely zonal, uniform wind with speed $u=30\\ \\mathrm{m\\,s^{-1}}$ and zero meridional component at the point of interest. Treat the local grid spacings in physical units along longitude and latitude as arc lengths on the sphere. Start from the definitions of arc length on a sphere and the one-dimensional CFL condition, and derive the maximum stable time step $\\Delta t_{\\max}$ implied by the longitudinal direction at this latitude. Then, using the same principles, determine which horizontal direction would be the limiting one if the meridional wind component had magnitude comparable to the zonal component.\n\nCompute a single numerical value for $\\Delta t_{\\max}$ in seconds, using $R=6.371\\times 10^{6}\\ \\mathrm{m}$ and $C=1$. Convert angular spacings from degrees to radians where needed. Round your final numerical answer to four significant figures. Express the final time in seconds.",
            "solution": "The passive scalar advection in one spatial dimension obeys the linear advection equation\n$$\n\\frac{\\partial \\psi}{\\partial t} + u \\frac{\\partial \\psi}{\\partial x} = 0,\n$$\nwhere $u$ is the advecting velocity component along the coordinate direction $x$. For an explicit time discretization with a first-order upwind spatial scheme, the well-tested Courant–Friedrichs–Lewy (CFL) stability requirement in one dimension is that the Courant number\n$$\n\\mathcal{C} \\equiv \\frac{|u|\\,\\Delta t}{\\Delta x}\n$$\nsatisfy\n$$\n\\mathcal{C} \\le C,\n$$\nwith $C=1$ for this discretization.\n\nOn a sphere of radius $R$, the physical arc length along longitude at latitude $\\phi$ corresponding to an angular increment $\\Delta\\lambda$ (in radians) is\n$$\n\\Delta x_{\\lambda} = R\\cos\\phi\\,\\Delta\\lambda,\n$$\nand the physical arc length along latitude corresponding to an angular increment $\\Delta\\phi$ (in radians) is\n$$\n\\Delta x_{\\phi} = R\\,\\Delta\\phi.\n$$\nThese follow from the definition of arc length on a sphere: $ds = R\\,d\\theta$ along a great circle, and the longitudinal arc at fixed $\\phi$ is reduced by the metric factor $\\cos\\phi$.\n\nWith a purely zonal wind of speed $u$ and zero meridional component, only the longitudinal direction imposes a stability constraint. The maximum stable time step from the longitudinal direction is therefore\n$$\n\\Delta t_{\\max} = \\frac{C\\,\\Delta x_{\\lambda}}{|u|} = \\frac{C\\,R\\cos\\phi\\,\\Delta\\lambda}{|u|}.\n$$\nWe now substitute the given values. First convert the angular spacings to radians. An angular increment of $0.5^\\circ$ equals\n$$\n\\Delta\\lambda = \\Delta\\phi = 0.5^\\circ \\times \\frac{\\pi}{180^\\circ} = \\frac{\\pi}{360}\\ \\text{radians}.\n$$\nAt latitude $\\phi=60^\\circ$, we have\n$$\n\\cos\\phi = \\cos 60^\\circ = \\frac{1}{2}.\n$$\nThus,\n$$\n\\Delta x_{\\lambda} = R\\cos\\phi\\,\\Delta\\lambda = R \\left(\\frac{1}{2}\\right)\\left(\\frac{\\pi}{360}\\right) = \\frac{\\pi R}{720}.\n$$\nWith $C=1$ and $|u|=30\\ \\mathrm{m\\,s^{-1}}$, the maximum stable time step is\n$$\n\\Delta t_{\\max} = \\frac{C\\,\\Delta x_{\\lambda}}{|u|} = \\frac{1}{30}\\left(\\frac{\\pi R}{720}\\right) = \\frac{\\pi R}{21600}.\n$$\nSubstituting $R=6.371\\times 10^{6}\\ \\mathrm{m}$ yields the numerical value\n$$\n\\Delta t_{\\max} = \\frac{\\pi\\,(6.371\\times 10^{6})}{21600}\\ \\mathrm{s}.\n$$\nEvaluating,\n$$\n\\Delta t_{\\max} \\approx 926.6243887\\ \\mathrm{s}.\n$$\nRounded to four significant figures, this is $926.6\\ \\mathrm{s}$.\n\nRegarding the limiting direction: if the meridional wind component had magnitude comparable to the zonal component, then the meridional CFL constraint would be\n$$\n\\Delta t \\le \\frac{C\\,\\Delta x_{\\phi}}{|v|} = \\frac{C\\,R\\,\\Delta\\phi}{|v|}.\n$$\nAt $\\phi=60^\\circ$ with $\\Delta\\phi=\\Delta\\lambda=\\pi/360$, we have $\\Delta x_{\\phi} = R\\,\\pi/360$ while $\\Delta x_{\\lambda} = R\\,\\pi/720$. Therefore $\\Delta x_{\\lambda}$ is smaller by a factor of $2$, making the longitudinal direction more restrictive. Consequently, for comparable $|u|$ and $|v|$, the longitudinal direction sets the stricter time step bound at this latitude.\n\nThe requested single numerical result for the maximum stable time step, in seconds and rounded to four significant figures, is reported below.",
            "answer": "$$\\boxed{926.6}$$"
        },
        {
            "introduction": "Beyond stability, the accuracy of a grid in representing global fields and performing spatial integrals is paramount, especially for models that use spectral methods where fields are represented by spherical harmonics. This coding practice  challenges you to compare the quadrature accuracy of a standard uniform latitude-longitude grid against a grid using Gaussian latitudes, which are specifically designed to exactly integrate Legendre polynomials up to a certain degree. The results will offer a clear, practical demonstration of why Gaussian grids are a cornerstone of spectral atmospheric models.",
            "id": "4060072",
            "problem": "Consider a unit-radius sphere parameterized by longitude $\\lambda \\in [0,2\\pi)$ and latitude $\\phi \\in [-\\pi/2,\\pi/2]$, with the spherical surface-area element $dA = \\cos\\phi\\,d\\phi\\,d\\lambda$. In numerical weather prediction (NWP) and climate modeling, latitudinal discretization strongly influences quadrature accuracy for spherical harmonics. Define the test function $\\psi(\\lambda,\\phi) = \\cos(m\\lambda)\\,P_n(\\sin\\phi)$, where $P_n$ is the Legendre polynomial of degree $n$, and $m$ and $n$ are nonnegative integers. The exact spherical integral of $\\psi$ over the unit sphere is\n$$\nI_{\\text{exact}} = \\int_{0}^{2\\pi}\\int_{-\\pi/2}^{\\pi/2} \\psi(\\lambda,\\phi)\\,\\cos\\phi\\,d\\phi\\,d\\lambda.\n$$\nUsing the change of variables $\\mu = \\sin\\phi$ (so $d\\mu = \\cos\\phi\\,d\\phi$ and $\\mu\\in[-1,1]$), this integral can be written as\n$$\nI_{\\text{exact}} = \\int_{0}^{2\\pi}\\int_{-1}^{1} \\cos(m\\lambda)\\,P_n(\\mu)\\,d\\mu\\,d\\lambda.\n$$\nYour task is to compute and compare discrete approximations of $I_{\\text{exact}}$ using two latitude–longitude grid discretizations, and then assess their quadrature accuracy by reporting absolute errors. Angles must be treated in radians.\n\n1. Uniform latitude–longitude rectangle rule:\n   - Longitudes: $L$ equispaced points $\\lambda_k = \\frac{2\\pi k}{L}$ for $k=0,1,\\dots,L-1$ with weight $\\Delta\\lambda = \\frac{2\\pi}{L}$.\n   - Latitudes: $J$ midpoints $\\phi_j = -\\frac{\\pi}{2} + \\left(j+\\frac{1}{2}\\right)\\Delta\\phi$ for $j=0,1,\\dots,J-1$, where $\\Delta\\phi = \\frac{\\pi}{J}$, with rectangle weight $\\Delta\\phi$ and metric factor $\\cos\\phi_j$.\n   - Approximation:\n     $$\n     I_{\\text{uni}} = \\sum_{k=0}^{L-1} \\sum_{j=0}^{J-1} \\cos(m\\lambda_k)\\,P_n(\\sin\\phi_j)\\,\\cos\\phi_j\\,\\Delta\\lambda\\,\\Delta\\phi.\n     $$\n\n2. Gaussian latitude grid with Gauss–Legendre quadrature in $\\mu$ (latitude direction) and equispaced longitudes:\n   - Longitudes: $L$ equispaced points $\\lambda_k = \\frac{2\\pi k}{L}$ for $k=0,1,\\dots,L-1$ with weight $\\Delta\\lambda = \\frac{2\\pi}{L}$.\n   - Latitudes: $J$ Gauss–Legendre nodes and weights $\\{\\mu_j,w_j\\}$ on $[-1,1]$.\n   - Approximation:\n     $$\n     I_{\\text{gau}} = \\sum_{k=0}^{L-1} \\sum_{j=0}^{J-1} \\cos(m\\lambda_k)\\,P_n(\\mu_j)\\,w_j\\,\\Delta\\lambda.\n     $$\n\nFundamental bases to be used:\n- The spherical surface-area element $dA = \\cos\\phi\\,d\\phi\\,d\\lambda$ for a unit sphere.\n- The change of variables $\\mu=\\sin\\phi$ so that $d\\mu=\\cos\\phi\\,d\\phi$.\n- The orthogonality of Legendre polynomials with respect to the weight $1$ on $[-1,1]$, implying $\\int_{-1}^{1}P_n(\\mu)\\,d\\mu = 2$ for $n=0$ and $0$ for $n\\ge 1$.\n- The exact periodic integral $\\int_0^{2\\pi}\\cos(m\\lambda)\\,d\\lambda = 2\\pi$ for $m=0$ and $0$ for $m\\ge 1$.\n- The property that Gauss–Legendre quadrature with $J$ nodes is exact for polynomials of degree at most $2J-1$ on $[-1,1]$.\n\nBased on these, the exact integral satisfies\n$$\nI_{\\text{exact}} = \n\\begin{cases}\n4\\pi, & \\text{if } m=0 \\text{ and } n=0,\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\n\nImplement a program that, for each test case, computes $I_{\\text{uni}}$ and $I_{\\text{gau}}$, and returns their absolute errors relative to $I_{\\text{exact}}$. Use the following test suite, which exercises a general case, cases where Gaussian quadrature is exact in latitude, cases where uniform latitude–longitude struggles in latitude, and a longitudinal aliasing edge case:\n\n- Test case $1$: $(L,J,m,n) = (64,32,3,5)$.\n- Test case $2$: $(L,J,m,n) = (64,32,0,0)$.\n- Test case $3$: $(L,J,m,n) = (64,32,0,7)$.\n- Test case $4$: $(L,J,m,n) = (16,8,16,0)$.\n- Test case $5$: $(L,J,m,n) = (32,3,0,7)$.\n\nFor each test case, your program must compute two floats: the absolute error $|I_{\\text{uni}}-I_{\\text{exact}}|$ and the absolute error $|I_{\\text{gau}}-I_{\\text{exact}}|$.\n\nFinal output format: Your program should produce a single line of output containing a comma-separated list of the results for all test cases, where each result itself is a two-element comma-separated list of floats in square brackets, and the whole sequence is enclosed in square brackets. For example: $[[e_{1,\\text{uni}},e_{1,\\text{gau}}],[e_{2,\\text{uni}},e_{2,\\text{gau}}],\\dots]$. Angles must be interpreted in radians. No additional text should be printed.",
            "solution": "We start from the unit sphere parameterization with longitude $\\lambda \\in [0,2\\pi)$ and latitude $\\phi \\in [-\\pi/2,\\pi/2]$. The spherical surface-area element is $dA=\\cos\\phi\\,d\\phi\\,d\\lambda$ for unit radius. The test function is $\\psi(\\lambda,\\phi)=\\cos(m\\lambda)\\,P_n(\\sin\\phi)$, where $P_n$ is the Legendre polynomial of degree $n$.\n\nThe exact integral is\n$$\nI_{\\text{exact}} = \\int_{0}^{2\\pi}\\int_{-\\pi/2}^{\\pi/2} \\cos(m\\lambda)\\,P_n(\\sin\\phi)\\,\\cos\\phi\\,d\\phi\\,d\\lambda.\n$$\nUsing $\\mu=\\sin\\phi$, with $d\\mu=\\cos\\phi\\,d\\phi$ and $\\mu\\in[-1,1]$, we have\n$$\nI_{\\text{exact}} = \\int_{0}^{2\\pi} \\cos(m\\lambda)\\,d\\lambda \\;\\times\\; \\int_{-1}^{1} P_n(\\mu)\\,d\\mu.\n$$\nBy Fourier analysis of the cosine and the orthogonality of Legendre polynomials, we obtain\n$$\n\\int_{0}^{2\\pi} \\cos(m\\lambda)\\,d\\lambda =\n\\begin{cases}\n2\\pi, & m=0,\\\\\n0, & m\\ge 1,\n\\end{cases}\n\\qquad\n\\int_{-1}^{1} P_n(\\mu)\\,d\\mu =\n\\begin{cases}\n2, & n=0,\\\\\n0, & n\\ge 1.\n\\end{cases}\n$$\nHence\n$$\nI_{\\text{exact}}=\n\\begin{cases}\n4\\pi, & m=0,\\,n=0,\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\n\nWe consider two discrete quadrature schemes.\n\n1. Uniform latitude–longitude rectangle rule. Longitudes are $L$ equispaced points $\\lambda_k=\\frac{2\\pi k}{L}$ with weight $\\Delta\\lambda=\\frac{2\\pi}{L}$ for $k=0,1,\\dots,L-1$. Latitudes are $J$ midpoints $\\phi_j=-\\frac{\\pi}{2}+\\left(j+\\frac{1}{2}\\right)\\Delta\\phi$, with $\\Delta\\phi=\\frac{\\pi}{J}$ for $j=0,1,\\dots,J-1$, and the metric factor $\\cos\\phi_j$ must be included in the area element. The discrete integral reads\n$$\nI_{\\text{uni}} = \\sum_{k=0}^{L-1}\\sum_{j=0}^{J-1}\n\\cos(m\\lambda_k)\\,P_n(\\sin\\phi_j)\\,\\cos\\phi_j\\,\\Delta\\lambda\\,\\Delta\\phi.\n$$\nBy separability, we may interpret it as the product of the discrete longitudinal sum and the discrete latitudinal sum:\n$$\nI_{\\text{uni}}=\\left(\\Delta\\lambda \\sum_{k=0}^{L-1}\\cos(m\\lambda_k)\\right)\\left(\\Delta\\phi\\sum_{j=0}^{J-1}P_n(\\sin\\phi_j)\\cos\\phi_j\\right).\n$$\nOn the longitude circle, the equispaced sum integrates $\\cos(m\\lambda)$ exactly for all integers $m$ that are not multiples of $L$ (it is identically $0$ in that case), and equals $2\\pi$ when $m=0$; if $m$ is a positive multiple of $L$, the discrete sum aliases to the zero-frequency component and equals $2\\pi$. Thus, longitudinal aliasing can occur when $m$ is a multiple of $L$.\n\n2. Gaussian latitude grid with Gauss–Legendre quadrature in $\\mu$ and equispaced longitudes. Let $\\{\\mu_j,w_j\\}_{j=0}^{J-1}$ be the $J$-point Gauss–Legendre quadrature nodes and weights on $[-1,1]$, and let longitudes be as above. Using $\\mu$ as the latitudinal coordinate removes the metric factor from the integrand. The discrete integral reads\n$$\nI_{\\text{gau}}=\\sum_{k=0}^{L-1}\\sum_{j=0}^{J-1}\\cos(m\\lambda_k)\\,P_n(\\mu_j)\\,w_j\\,\\Delta\\lambda\n= \\left(\\Delta\\lambda \\sum_{k=0}^{L-1}\\cos(m\\lambda_k)\\right)\\left(\\sum_{j=0}^{J-1}P_n(\\mu_j)\\,w_j\\right).\n$$\nBy the Gauss–Legendre property, $\\sum_{j=0}^{J-1}P_n(\\mu_j)\\,w_j$ equals $\\int_{-1}^{1}P_n(\\mu)\\,d\\mu$ exactly for any $n\\le 2J-1$, and in particular is exactly $2$ for $n=0$. For $n>2J-1$, the quadrature introduces error. As in the uniform scheme, longitudinal aliasing occurs if $m$ is a multiple of $L$, leading to a nonzero discrete longitudinal sum even when the exact integral of $\\cos(m\\lambda)$ is zero.\n\nAlgorithmic steps for each test case $(L,J,m,n)$:\n- Compute $\\Delta\\lambda=\\frac{2\\pi}{L}$ and $\\lambda_k=\\frac{2\\pi k}{L}$ for $k=0,\\dots,L-1$.\n- Uniform latitude–longitude:\n  - Compute $\\Delta\\phi=\\frac{\\pi}{J}$ and $\\phi_j=-\\frac{\\pi}{2}+\\left(j+\\frac{1}{2}\\right)\\Delta\\phi$ for $j=0,\\dots,J-1$.\n  - Evaluate $P_n(\\sin\\phi_j)$ and $\\cos\\phi_j$.\n  - Form the longitudinal sum $S_\\lambda^{\\text{uni}}=\\Delta\\lambda\\sum_{k=0}^{L-1}\\cos(m\\lambda_k)$.\n  - Form the latitudinal sum $S_\\phi^{\\text{uni}}=\\Delta\\phi\\sum_{j=0}^{J-1}P_n(\\sin\\phi_j)\\cos\\phi_j$.\n  - Compute $I_{\\text{uni}}=S_\\lambda^{\\text{uni}}\\,S_\\phi^{\\text{uni}}$.\n- Gaussian latitude:\n  - Obtain Gauss–Legendre nodes and weights $\\{\\mu_j,w_j\\}$ for $j=0,\\dots,J-1$.\n  - Evaluate $P_n(\\mu_j)$.\n  - Form the longitudinal sum $S_\\lambda^{\\text{gau}}=\\Delta\\lambda\\sum_{k=0}^{L-1}\\cos(m\\lambda_k)$ (identical to uniform longitude).\n  - Form the Gauss–Legendre latitudinal sum $S_\\mu^{\\text{gau}}=\\sum_{j=0}^{J-1}P_n(\\mu_j)\\,w_j$.\n  - Compute $I_{\\text{gau}}=S_\\lambda^{\\text{gau}}\\,S_\\mu^{\\text{gau}}$.\n- Compute the exact integral $I_{\\text{exact}}=4\\pi$ if $m=0$ and $n=0$, else $I_{\\text{exact}}=0$.\n- Report the absolute errors $|I_{\\text{uni}}-I_{\\text{exact}}|$ and $|I_{\\text{gau}}-I_{\\text{exact}}|$.\n\nInterpretation across the test suite:\n- For test case $1$ with $(L,J,m,n)=(64,32,3,5)$, the exact integral is $0$. The longitudinal sum is exactly $0$ because $m$ is not $0$ and not a multiple of $L$, making both schemes exact regardless of latitude treatment.\n- For test case $2$ with $(L,J,m,n)=(64,32,0,0)$, the exact integral is $4\\pi$. The Gaussian latitude quadrature is exact, and the longitudinal sum is exact, so $I_{\\text{gau}}=4\\pi$. The uniform latitude–longitude rectangle rule approximates the latitudinal integral, yielding a small error.\n- For test case $3$ with $(L,J,m,n)=(64,32,0,7)$, the exact integral is $0$. The Gaussian latitude quadrature is exact because $n\\le 2J-1$, so $I_{\\text{gau}}=0$. The uniform latitude–longitude rectangle rule incurs latitudinal quadrature error.\n- For test case $4$ with $(L,J,m,n)=(16,8,16,0)$, the exact integral is $0$, but $m$ is a multiple of $L$, causing longitudinal aliasing. Both schemes produce a nonzero longitudinal sum equal to $2\\pi$, and Gaussian latitude is exact for $n=0$, yielding a large error magnitude $4\\pi$; the uniform latitude–longitude scheme is close to that value with small latitude error.\n- For test case $5$ with $(L,J,m,n)=(32,3,0,7)$, the exact integral is $0$, but Gaussian latitude has degree $2J-1=5$, which is less than $n=7$, introducing latitudinal quadrature error; uniform latitude–longitude also exhibits latitudinal error.\n\nThe program should implement these computations exactly as described and print a single line of the form $[[e_{1,\\text{uni}},e_{1,\\text{gau}}],[e_{2,\\text{uni}},e_{2,\\text{gau}}],[e_{3,\\text{uni}},e_{3,\\text{gau}}],[e_{4,\\text{uni}},e_{4,\\text{gau}}],[e_{5,\\text{uni}},e_{5,\\text{gau}}]]$, where each $e_{\\cdot,\\cdot}$ is a float. Angles must be interpreted in radians throughout.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\nfrom scipy.special import eval_legendre\n\ndef spherical_integral_errors(L, J, m, n):\n    # Constants\n    two_pi = 2.0 * np.pi\n\n    # Longitudes: endpoints (equispaced)\n    k = np.arange(L)\n    lam = two_pi * k / L\n    dlam = two_pi / L\n\n    # Longitudinal sum (same for both schemes)\n    S_lambda = dlam * np.sum(np.cos(m * lam))\n\n    # Uniform latitude: midpoints in phi\n    dphi = np.pi / J\n    j = np.arange(J)\n    phi = -np.pi / 2.0 + (j + 0.5) * dphi\n    mu_uniform = np.sin(phi)\n    cosphi = np.cos(phi)\n\n    Pn_uniform = eval_legendre(n, mu_uniform)\n    S_phi_uniform = dphi * np.sum(Pn_uniform * cosphi)\n    I_uni = S_lambda * S_phi_uniform\n\n    # Gaussian latitude: Gauss-Legendre nodes and weights in mu\n    mu_gau, w_gau = leggauss(J)\n    Pn_gau = eval_legendre(n, mu_gau)\n    S_mu_gau = np.sum(Pn_gau * w_gau)\n    I_gau = S_lambda * S_mu_gau\n\n    # Exact integral: 4*pi if m=0 and n=0; else 0\n    I_exact = (4.0 * np.pi) if (m == 0 and n == 0) else 0.0\n\n    # Absolute errors\n    err_uni = abs(I_uni - I_exact)\n    err_gau = abs(I_gau - I_exact)\n    return err_uni, err_gau\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple (L, J, m, n)\n    test_cases = [\n        (64, 32, 3, 5),   # General case: exact 0, longitudinal sum zero\n        (64, 32, 0, 0),   # Non-zero exact integral (4*pi), Gaussian exact\n        (64, 32, 0, 7),   # Exact 0, Gaussian exact, uniform latitude error\n        (16, 8, 16, 0),   # Longitudinal aliasing: m multiple of L\n        (32, 3, 0, 7),    # Gaussian latitude inexact: 2J-1=5 < n=7\n    ]\n\n    results = []\n    for L, J, m, n in test_cases:\n        err_uni, err_gau = spherical_integral_errors(L, J, m, n)\n        results.append([err_uni, err_gau])\n\n    # Format output: single line, list of lists with comma-separated floats, no extra spaces\n    def format_float(x):\n        # Use a concise representation with up to 12 significant digits\n        return f\"{x:.12g}\"\n\n    formatted = \"[\" + \",\".join(\"[\" + \",\".join(format_float(x) for x in pair) + \"]\" for pair in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        },
        {
            "introduction": "Ultimately, the choice of a grid discretization is judged by its performance in realistic simulations. This practice  moves from static analysis to a dynamic advection experiment, a core component of any atmospheric model. You will implement a simulation of passive tracer transport under solid-body rotation, comparing the performance of a uniform grid with an equal-area grid, another design aimed at improving global grid properties. By measuring key diagnostics like mass conservation and numerical diffusion, you will gain direct experience in evaluating and contrasting the practical consequences of different grid choices.",
            "id": "4060101",
            "problem": "You are asked to design and implement a numerical experiment comparing global tracer advection on two latitude–longitude discretizations of the sphere: a uniform latitude–longitude grid and an equal-area latitude–longitude grid. The experiment must use the same prescribed velocity field on both grids and quantify two diagnostics: conservation of total tracer mass and numerical diffusion (loss of squared amplitude) after one complete rotation. The implementation must be a complete, runnable program.\n\nThe fundamental base for the derivation is the spherical advection equation for a passive tracer on a sphere of radius $R$, written in geographic coordinates $(\\lambda,\\phi)$, where $\\lambda$ is longitude and $\\phi$ is latitude, and the kinematic relation between physical velocities and coordinate advection rates. The tracer $q(\\lambda,\\phi,t)$ satisfies\n$$\n\\frac{\\partial q}{\\partial t} + \\frac{u(\\lambda,\\phi,t)}{R\\cos\\phi}\\frac{\\partial q}{\\partial \\lambda} + \\frac{v(\\lambda,\\phi,t)}{R}\\frac{\\partial q}{\\partial \\phi} = 0,\n$$\nwhere $u$ is the zonal velocity (east–west) and $v$ is the meridional velocity (north–south), with $R$ expressed in meters. Consider a solid-body rotation about the geographic axis given by\n$$\nu(\\phi) = \\Omega R \\cos\\phi, \\quad v(\\phi) = 0,\n$$\nwith constant angular speed $\\Omega$ in radians per second. Under this solid-body rotation, the coordinate advection speed along longitude is constant in latitude:\n$$\nc \\equiv \\frac{u(\\phi)}{R\\cos\\phi} = \\Omega.\n$$\n\nGrid definitions:\n- Uniform latitude–longitude grid: define $N_\\lambda$ longitudes and $N_\\phi$ latitudes with edges\n$$\n\\lambda_i^{e} = -\\pi + i\\,\\Delta\\lambda,\\quad \\Delta\\lambda = \\frac{2\\pi}{N_\\lambda},\\quad i = 0,1,\\dots,N_\\lambda,\n$$\n$$\n\\phi_j^{e} = -\\frac{\\pi}{2} + j\\,\\Delta\\phi,\\quad \\Delta\\phi = \\frac{\\pi}{N_\\phi},\\quad j = 0,1,\\dots,N_\\phi,\n$$\nand centers $\\lambda_i = \\frac{1}{2}(\\lambda_i^{e}+\\lambda_{i+1}^{e})$, $\\phi_j = \\frac{1}{2}(\\phi_j^{e}+\\phi_{j+1}^{e})$. The area of a grid cell in latitude band $j$ is\n$$\nA_j = R^2\\,\\Delta\\lambda\\,\\left(\\sin\\phi_{j+1}^{e} - \\sin\\phi_{j}^{e}\\right),\n$$\nconstant along longitude within the band.\n\n- Equal-area latitude–longitude grid: keep longitudes identical to the uniform grid, but choose latitude edges such that all latitude bands have equal cell area for a given $\\Delta\\lambda$. Define\n$$\ns_j = -1 + \\frac{2j}{N_\\phi},\\quad \\phi_j^{e} = \\arcsin(s_j),\\quad j = 0,1,\\dots,N_\\phi,\n$$\nwith centers given by $s_{j+\\frac{1}{2}} = -1 + \\frac{2(j+\\frac{1}{2})}{N_\\phi}$ and $\\phi_j = \\arcsin\\left(s_{j+\\frac{1}{2}}\\right)$. The cell area per longitude in band $j$ is again\n$$\nA_j = R^2\\,\\Delta\\lambda\\,\\left(\\sin\\phi_{j+1}^{e} - \\sin\\phi_{j}^{e}\\right),\n$$\nwhich is equal for all $j$ by construction.\n\nTracer initialization: initialize a smooth tracer at time $t=0$ by sampling a continuous function\n$$\nq_0(\\lambda,\\phi) = \\exp\\left(-\\frac{1}{2}\\left[\\left(\\frac{\\phi-\\phi_0}{\\sigma_\\phi}\\right)^2 + \\left(\\frac{\\Delta\\lambda_p(\\lambda-\\lambda_0)}{\\sigma_\\lambda}\\right)^2\\right]\\right),\n$$\nwhere $\\Delta\\lambda_p(\\cdot)$ denotes the $2\\pi$-periodic wrapped difference mapped into $[-\\pi,\\pi]$, and $\\phi_0$, $\\lambda_0$ are the center location in radians, with widths $\\sigma_\\phi$ and $\\sigma_\\lambda$ in radians. Tracer values are sampled at grid-cell centers $(\\lambda_i,\\phi_j)$ for each grid.\n\nTime stepping and discretization: derive a one-dimensional first-order upwind scheme along longitude for each latitude band based on the constant coordinate speed $c=\\Omega$. Let $\\mathrm{CFL} \\equiv \\frac{c\\,\\Delta t}{\\Delta\\lambda}$, where $\\Delta t$ is the time step in seconds. With periodic boundary conditions in longitude and eastward flow, the upwind update at each step should be consistent with discrete mass conservation along each latitude ring. Integrate for one full rotation period $T = \\frac{2\\pi}{\\Omega}$, using a constant $\\Delta t$ chosen to achieve a specified $\\mathrm{CFL}$ value.\n\nDiagnostics:\n- Total mass at any time is approximated by the area-weighted sum\n$$\nM(t) = \\sum_{j=0}^{N_\\phi-1}\\sum_{i=0}^{N_\\lambda-1} q_{i,j}(t)\\,A_j.\n$$\nCompute the relative mass error after one rotation,\n$$\n\\epsilon_M = \\frac{M(T)-M(0)}{M(0)}.\n$$\nReport $\\epsilon_M$ separately for the uniform grid and the equal-area grid.\n\n- Numerical diffusion is quantified by the loss of area-weighted squared amplitude,\n$$\nE(t) = \\sum_{j=0}^{N_\\phi-1}\\sum_{i=0}^{N_\\lambda-1} q_{i,j}^2(t)\\,A_j,\n$$\nand the diffusion metric\n$$\n\\delta_E = 1 - \\frac{E(T)}{E(0)}.\n$$\nReport $\\delta_E$ separately for each grid and also a boolean indicating whether the equal-area grid exhibits strictly less diffusion than the uniform grid for the same test case.\n\nAngle units must be in radians. Physical units must be consistent: $R$ in meters, $u$ and $v$ in meters per second, $t$ in seconds. Use $R = 6.371\\times 10^6$ meters and $\\Omega = \\frac{2\\pi}{T}$ with one rotation period $T = 86400$ seconds.\n\nTest suite: implement the experiment for the following four parameter sets as a list of cases, each case being a tuple $(N_\\lambda, N_\\phi, \\mathrm{CFL}, \\phi_0, \\lambda_0, \\sigma_\\phi, \\sigma_\\lambda)$:\n- Case $1$: $(256, 128, 0.3, 0.3, 1.0, 0.25, 0.3)$.\n- Case $2$: $(256, 128, 0.3, 1.3, -2.0, 0.15, 0.2)$.\n- Case $3$: $(64, 32, 0.7, -0.5, 0.0, 0.35, 0.8)$.\n- Case $4$: $(360, 181, 0.95, 0.0, 2.5, 0.2, 0.2)$.\n\nFor each case, your program should produce a result list containing $5$ entries in the order $[\\epsilon_M^{\\mathrm{uni}}, \\epsilon_M^{\\mathrm{ea}}, \\delta_E^{\\mathrm{uni}}, \\delta_E^{\\mathrm{ea}}, \\mathrm{ea\\_less\\_diff}]$, where $\\epsilon_M^{\\mathrm{uni}}$ and $\\epsilon_M^{\\mathrm{ea}}$ are floats, $\\delta_E^{\\mathrm{uni}}$ and $\\delta_E^{\\mathrm{ea}}$ are floats, and $\\mathrm{ea\\_less\\_diff}$ is a boolean.\n\nFinal output format: your program should produce a single line of output containing the results for all four cases as a comma-separated Python-style list of lists enclosed in square brackets, for example $[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]]$.",
            "solution": "The spherical advection equation for a passive tracer $q(\\lambda,\\phi,t)$ on a sphere of radius $R$ connects the tracer tendency to the divergence of the advective fluxes in coordinate space. Longitude $\\lambda$ and latitude $\\phi$ are angular coordinates in radians, and the conversion between physical velocity components $(u,v)$ and coordinate speeds involves the metric factors $R\\cos\\phi$ and $R$ along longitude and latitude, respectively. The governing equation is\n$$\n\\frac{\\partial q}{\\partial t} + \\frac{u(\\lambda,\\phi,t)}{R\\cos\\phi}\\frac{\\partial q}{\\partial \\lambda} + \\frac{v(\\lambda,\\phi,t)}{R}\\frac{\\partial q}{\\partial \\phi} = 0.\n$$\nFor solid-body rotation about the geographic axis, $u(\\phi) = \\Omega R \\cos\\phi$ and $v(\\phi) = 0$ with constant angular speed $\\Omega$ in radians per second. Substituting into the advection equation yields\n$$\n\\frac{\\partial q}{\\partial t} + \\Omega \\frac{\\partial q}{\\partial \\lambda} = 0,\n$$\nwhich is a one-dimensional advection equation along longitude with constant speed $\\Omega$, independent of $\\phi$. This simplification eliminates the coordinate singularity at the poles (the factor $\\cos\\phi$ cancels), and ensures that each latitude ring behaves identically in terms of the longitudinal advection rate.\n\nDiscretization of the sphere uses two grids:\n\n$1.$ Uniform latitude–longitude grid: the longitudes partition $[-\\pi,\\pi)$ into $N_\\lambda$ equal intervals of size $\\Delta\\lambda = \\frac{2\\pi}{N_\\lambda}$, and the latitudes partition $[-\\frac{\\pi}{2},\\frac{\\pi}{2}]$ into $N_\\phi$ equal intervals of size $\\Delta\\phi=\\frac{\\pi}{N_\\phi}$. The cell centers are at midpoints of these edges. The cell area per longitude in latitude band $j$ is\n$$\nA_j = R^2\\,\\Delta\\lambda\\,\\left(\\sin\\phi_{j+1}^{e} - \\sin\\phi_{j}^{e}\\right),\n$$\nwhich follows from the spherical surface area element $R^2\\cos\\phi\\,d\\phi\\,d\\lambda$ integrated over the band.\n\n$2.$ Equal-area latitude–longitude grid: the longitudes are identical, but the latitude edges are chosen such that each band has the same area per longitude. The cumulative area from the South Pole to latitude $\\phi$ is proportional to $\\sin\\phi$, so equal-area bands correspond to evenly spaced values of $\\sin\\phi$. Defining $s_j = -1 + \\frac{2j}{N_\\phi}$ and $\\phi_j^e = \\arcsin(s_j)$ yields equal-area bands, and again\n$$\nA_j = R^2\\,\\Delta\\lambda\\,\\left(\\sin\\phi_{j+1}^{e} - \\sin\\phi_{j}^{e}\\right)\n$$\nis constant in $j$ by construction. The centers are computed by midpoints in $s$-space: $s_{j+\\frac{1}{2}} = -1 + \\frac{2(j+\\frac{1}{2})}{N_\\phi}$ and $\\phi_j = \\arcsin\\left(s_{j+\\frac{1}{2}}\\right)$.\n\nThe tracer initialization samples a smooth Gaussian in both latitude and longitude at cell centers:\n$$\nq_0(\\lambda,\\phi) = \\exp\\left(-\\frac{1}{2}\\left[\\left(\\frac{\\phi-\\phi_0}{\\sigma_\\phi}\\right)^2 + \\left(\\frac{\\Delta\\lambda_p(\\lambda-\\lambda_0)}{\\sigma_\\lambda}\\right)^2\\right]\\right),\n$$\nwhere $\\Delta\\lambda_p(\\cdot)$ wraps the longitudinal difference into $[-\\pi,\\pi]$ to preserve periodicity.\n\nWe discretize the one-dimensional advection in longitude at each latitude ring using a first-order upwind method, consistent with the direction of motion (eastward) and with periodic boundary conditions. Let $q_{i,j}^n$ be the tracer at longitude index $i$ and latitude index $j$ at time level $n$. Define the Courant–Friedrichs–Lewy (CFL) number\n$$\n\\mathrm{CFL} = \\frac{c\\,\\Delta t}{\\Delta\\lambda} = \\frac{\\Omega\\,\\Delta t}{\\Delta\\lambda},\n$$\nwith $c=\\Omega$. The upwind scheme for eastward advection updates\n$$\nq_{i,j}^{n+1} = q_{i,j}^{n} - \\mathrm{CFL}\\,\\left(q_{i,j}^{n} - q_{i-1,j}^{n}\\right),\n$$\nwith periodic indexing in $i$. This scheme can be derived from a flux difference form in longitude and is conservative along each latitude ring: summing over $i$ telescopes the differences, preserving $\\sum_i q_{i,j}$ for each $j$. Since the cell area $A_j$ is constant along longitude in each ring for both grids, the mass in each ring is conserved, and thus the global mass\n$$\nM^n = \\sum_{j=0}^{N_\\phi-1}\\sum_{i=0}^{N_\\lambda-1} q_{i,j}^{n} A_j\n$$\nis conserved up to roundoff. Numerical diffusion arises from the dissipative nature of the upwind scheme, quantified by the area-weighted squared amplitude\n$$\nE^n = \\sum_{j=0}^{N_\\phi-1}\\sum_{i=0}^{N_\\lambda-1} \\left(q_{i,j}^{n}\\right)^2 A_j.\n$$\nOver one rotation period $T = \\frac{2\\pi}{\\Omega}$, the exact solution would shift the tracer around longitude with no change in its shape or $E$, but the discrete scheme reduces $E$ in a manner that depends on $\\mathrm{CFL}$ and the spectral content of $q$ along longitude.\n\nImplementation details:\n- Use $R = 6.371\\times 10^6$ meters and $T = 86400$ seconds, so $\\Omega = \\frac{2\\pi}{T}$ radians per second.\n- For each test case, construct both grids, sample $q_0$ at centers, compute $\\Delta t$ from the prescribed $\\mathrm{CFL}$ via $\\Delta t = \\mathrm{CFL}\\,\\frac{\\Delta\\lambda}{\\Omega}$, and choose the number of steps $N_{\\mathrm{steps}}$ as the nearest integer to $\\frac{T}{\\Delta t}$ to approximate one rotation. Apply the upwind update $N_{\\mathrm{steps}}$ times.\n- Compute the relative mass error\n$$\n\\epsilon_M = \\frac{M(T)-M(0)}{M(0)}\n$$\nfor both grids, and the diffusion metric\n$$\n\\delta_E = 1 - \\frac{E(T)}{E(0)}\n$$\nfor both grids.\n- Report a boolean $\\mathrm{ea\\_less\\_diff}$ indicating whether the equal-area grid has strictly smaller $\\delta_E$ than the uniform grid.\n\nTest coverage rationale:\n- Case $1$ is a general \"happy path\" with moderate resolution and $\\mathrm{CFL}$, mid-latitude tracer.\n- Case $2$ places the tracer near the pole, probing the grid’s area variation and sampling behavior.\n- Case $3$ uses coarse resolution and larger $\\mathrm{CFL}$, challenging numerical diffusion and stability margins.\n- Case $4$ uses near-degree resolution and $\\mathrm{CFL}$ close to $1$, probing the boundary of upwind stability.\n\nThe final output aggregates the per-case results into a single Python list of lists printed on one line, enabling automated evaluation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_uniform_grid(n_lon, n_lat, R):\n    # Longitude edges and centers\n    dlon = 2.0 * np.pi / n_lon\n    lon_edges = -np.pi + np.arange(n_lon + 1) * dlon\n    lon_centers = 0.5 * (lon_edges[:-1] + lon_edges[1:])\n    # Latitude edges and centers\n    dlat = np.pi / n_lat\n    lat_edges = -0.5 * np.pi + np.arange(n_lat + 1) * dlat\n    lat_centers = 0.5 * (lat_edges[:-1] + lat_edges[1:])\n    # Cell area per longitude in each latitude band\n    band_areas = (R**2) * dlon * (np.sin(lat_edges[1:]) - np.sin(lat_edges[:-1]))\n    return lon_centers, lat_centers, band_areas, dlon\n\ndef build_equal_area_grid(n_lon, n_lat, R):\n    # Longitude edges and centers\n    dlon = 2.0 * np.pi / n_lon\n    lon_edges = -np.pi + np.arange(n_lon + 1) * dlon\n    lon_centers = 0.5 * (lon_edges[:-1] + lon_edges[1:])\n    # Equal-area latitude edges via uniform spacing in sin(phi)\n    s_edges = -1.0 + 2.0 * (np.arange(n_lat + 1) / n_lat)\n    lat_edges = np.arcsin(s_edges)\n    # Centers via midpoints in s-space\n    s_centers = -1.0 + 2.0 * ((np.arange(n_lat) + 0.5) / n_lat)\n    lat_centers = np.arcsin(s_centers)\n    # Cell area per longitude in each latitude band\n    band_areas = (R**2) * dlon * (np.sin(lat_edges[1:]) - np.sin(lat_edges[:-1]))\n    return lon_centers, lat_centers, band_areas, dlon\n\ndef periodic_delta_lambda(lon_minus_center):\n    # Map longitudinal difference to [-pi, pi]\n    x = (lon_minus_center + np.pi) % (2.0 * np.pi) - np.pi\n    return x\n\ndef initialize_tracer(lon_centers, lat_centers, phi0, lam0, sigma_phi, sigma_lam):\n    # Create 2D grids of centers\n    lon2d, lat2d = np.meshgrid(lon_centers, lat_centers)\n    dlam = periodic_delta_lambda(lon2d - lam0)\n    dphi = lat2d - phi0\n    q0 = np.exp(-0.5 * ((dphi / sigma_phi) ** 2 + (dlam / sigma_lam) ** 2))\n    return q0\n\ndef advect_upwind_zonal(q, CFL, n_steps):\n    # First-order upwind scheme for eastward advection along longitude (axis=1)\n    for _ in range(n_steps):\n        q = q - CFL * (q - np.roll(q, shift=1, axis=1))\n    return q\n\ndef mass_and_energy(q, band_areas):\n    # Area-weighted mass and squared amplitude\n    # band_areas shape: (n_lat,), q shape: (n_lat, n_lon)\n    area2d = band_areas[:, None]\n    mass = np.sum(q * area2d)\n    energy = np.sum((q ** 2) * area2d)\n    return mass, energy\n\ndef run_case(case, R, T):\n    n_lon, n_lat, CFL_target, phi0, lam0, sigma_phi, sigma_lam = case\n    # Angular speed Omega and dt for target CFL\n    Omega = 2.0 * np.pi / T\n\n    # Build grids\n    lon_u, lat_u, areas_u, dlon_u = build_uniform_grid(n_lon, n_lat, R)\n    lon_e, lat_e, areas_e, dlon_e = build_equal_area_grid(n_lon, n_lat, R)\n\n    # Initialize tracer\n    q0_u = initialize_tracer(lon_u, lat_u, phi0, lam0, sigma_phi, sigma_lam)\n    q0_e = initialize_tracer(lon_e, lat_e, phi0, lam0, sigma_phi, sigma_lam)\n\n    # Choose dt based on target CFL and longitudinal spacing (Omega is coordinate speed)\n    dt_u = CFL_target * dlon_u / Omega\n    dt_e = CFL_target * dlon_e / Omega\n\n    # Steps to approximate one full rotation\n    n_steps_u = max(1, int(np.round(T / dt_u)))\n    n_steps_e = max(1, int(np.round(T / dt_e)))\n\n    # Actual CFL used (may differ slightly due to rounding of steps if one adjusts dt,\n    # but we keep dt fixed per target and use integer steps)\n    CFL_u = Omega * dt_u / dlon_u\n    CFL_e = Omega * dt_e / dlon_e\n\n    # Mass and energy at t=0\n    m0_u, e0_u = mass_and_energy(q0_u, areas_u)\n    m0_e, e0_e = mass_and_energy(q0_e, areas_e)\n\n    # Advect\n    qT_u = advect_upwind_zonal(q0_u.copy(), CFL_u, n_steps_u)\n    qT_e = advect_upwind_zonal(q0_e.copy(), CFL_e, n_steps_e)\n\n    # Mass and energy at t=T (approximate)\n    mT_u, eT_u = mass_and_energy(qT_u, areas_u)\n    mT_e, eT_e = mass_and_energy(qT_e, areas_e)\n\n    # Diagnostics\n    mass_err_u = (mT_u - m0_u) / m0_u\n    mass_err_e = (mT_e - m0_e) / m0_e\n\n    diff_u = 1.0 - (eT_u / e0_u)\n    diff_e = 1.0 - (eT_e / e0_e)\n\n    ea_less_diff = bool(diff_e < diff_u)\n\n    return [mass_err_u, mass_err_e, diff_u, diff_e, ea_less_diff]\n\ndef solve():\n    # Constants: Earth radius and rotation period\n    R = 6.371e6  # meters\n    T = 86400.0  # seconds\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (256, 128, 0.3, 0.3, 1.0, 0.25, 0.3),\n        (256, 128, 0.3, 1.3, -2.0, 0.15, 0.2),\n        (64, 32, 0.7, -0.5, 0.0, 0.35, 0.8),\n        (360, 181, 0.95, 0.0, 2.5, 0.2, 0.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case, R, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"{results}\")\n\nsolve()\n```"
        }
    ]
}