{
    "hands_on_practices": [
        {
            "introduction": "对流的驱动力是浮力，它本质上由气块与周围环境之间的密度差决定。在潮湿大气中，水汽通过虚温 $T_v$ 的概念影响空气密度，从而对浮力产生关键作用。这项练习将引导你从第一性原理出发，推导浮力表达式，并定量分析在计算对流有效位能（CAPE）时，忽略水汽效应会引入的系统性偏差 。这对于准确评估真实大气中的对流潜势至关重要。",
            "id": "4026572",
            "problem": "在数值天气预报和气候模拟中，一个核心诊断量是对流有效位能（CAPE）。从水汽质量混合比为 $q_v$ 的湿空气混合物的理想气体定律出发，并忽略凝结物，湿空气的密度可以通过引入虚温 $T_v$ 来表示，其定义为 $p = \\rho R_d T_v$，其中 $p$ 是气压，$\\rho$ 是密度，$R_d$ 是干空气的比气体常数。虚温满足 $T_v \\approx T \\left(1 + \\alpha q_v\\right)$，其中 $\\alpha \\equiv \\frac{1}{\\epsilon} - 1$，$\\epsilon \\equiv R_d/R_v \\approx 0.622$，$R_v$ 是水汽的比气体常数。假设为不饱和条件，没有凝结物，因此处处有 $q_l = q_i = 0$。气块的浮力加速度定义为 $B \\equiv g \\frac{\\rho_{\\mathrm{env}} - \\rho_{\\mathrm{par}}}{\\rho_{\\mathrm{env}}}$，其中 $g$ 是重力加速度。\n\n考虑一个环境，其温度廓线为 $T_{\\mathrm{env}}(z) = T_0 - \\Gamma z$，$z \\in [0,H]$，其中 $T_0 = 300\\,\\mathrm{K}$，$\\Gamma = 6.5\\,\\mathrm{K\\,km^{-1}}$，$H = 3000\\,\\mathrm{m}$。在同一层中，一个被抬升的气块具有恒定的超温 $\\Delta T \\equiv T_{\\mathrm{par}} - T_{\\mathrm{env}} = 2\\,\\mathrm{K}$ 和恒定的比湿超量 $\\Delta q_v \\equiv q_{v,\\mathrm{par}} - q_{v,\\mathrm{env}} = 0.004$。取 $g = 9.81\\,\\mathrm{m\\,s^{-2}}$ 和 $\\alpha = 0.61$。假设偏差很小，因此关于环境在 $(\\Delta T, \\Delta q_v)$ 上的线性化是有效的。\n\n任务：\n1) 从理想气体定律和浮力定义出发，推导一个关于 $(\\Delta T, \\Delta q_v)$ 精确到一阶的 $B(z)$ 表达式，该表达式分离了温度和水汽的贡献，并用 $T_{\\mathrm{env}}(z)$、$\\Delta T$ 和 $\\Delta q_v$ 表示。\n2) 使用你的结果，计算在 $[0,H]$ 上的两个 CAPE 值：\n- $ \\mathrm{CAPE}[T] \\equiv \\int_{0}^{H} B_T(z)\\,dz$，其中在浮力计算中忽略水汽（即，处处用 $T$ 代替 $T_v$）。\n- $ \\mathrm{CAPE}[T_v] \\equiv \\int_{0}^{H} B_{T_v}(z)\\,dz$，包括一阶水汽贡献。\n3) 将忽略水汽引入的偏差定义为 $ \\mathrm{bias} \\equiv \\mathrm{CAPE}[T] - \\mathrm{CAPE}[T_v]$。对指定的廓线，数值计算此偏差。\n\n以 $\\mathrm{J\\,kg^{-1}}$ 为单位表示最终偏差，并将你的答案四舍五入到四位有效数字。",
            "solution": "首先验证该问题，以确保其科学基础扎实、提法恰当且客观。\n\n### 步骤 1: 提取已知条件\n- 湿空气的理想气体定律：$p = \\rho R_d T_v$\n- 虚温近似：$T_v \\approx T \\left(1 + \\alpha q_v\\right)$\n- 参数定义：$\\alpha \\equiv \\frac{1}{\\epsilon} - 1$ 其中 $\\epsilon \\equiv R_d/R_v \\approx 0.622$\n- 凝结物假设：$q_l = q_i = 0$\n- 浮力加速度定义：$B \\equiv g \\frac{\\rho_{\\mathrm{env}} - \\rho_{\\mathrm{par}}}{\\rho_{\\mathrm{env}}}$\n- 环境温度廓线：$T_{\\mathrm{env}}(z) = T_0 - \\Gamma z$，$z \\in [0,H]$\n- 常数和参数：\n  - $T_0 = 300\\,\\mathrm{K}$\n  - $\\Gamma = 6.5\\,\\mathrm{K\\,km^{-1}}$\n  - $H = 3000\\,\\mathrm{m}$\n  - $\\Delta T \\equiv T_{\\mathrm{par}} - T_{\\mathrm{env}} = 2\\,\\mathrm{K}$ (恒定)\n  - $\\Delta q_v \\equiv q_{v,\\mathrm{par}} - q_{v,\\mathrm{env}} = 0.004$ (恒定)\n  - $g = 9.81\\,\\mathrm{m\\,s^{-2}}$\n  - $\\alpha = 0.61$\n- 假设：偏差小，在 $(\\Delta T, \\Delta q_v)$ 上的线性化有效。\n\n### 步骤 2: 使用提取的已知条件进行验证\n- **科学基础扎实**：该问题基于大气热力学的基本原理，包括理想气体定律、虚温概念和浮力。所用方程和参数值为该领域的标准。\n- **提法恰当**：问题陈述清晰，包含三个明确的任务，最终得出一个数值答案。恒定温差和水汽超量等假设创建了一个简化但可解的问题。\n- **客观**：问题以精确的定量语言表述，没有主观性。\n\n### 步骤 3: 结论与行动\n该问题被认为是有效的，因为其一致、科学上合理且提法恰当。将制定解决方案。\n\n### 任务 1: 推导一阶浮力表达式\n\n浮力加速度 $B$ 定义为：\n$$B \\equiv g \\frac{\\rho_{\\mathrm{env}} - \\rho_{\\mathrm{par}}}{\\rho_{\\mathrm{env}}} = g \\left(1 - \\frac{\\rho_{\\mathrm{par}}}{\\rho_{\\mathrm{env}}}\\right)$$\n使用湿空气的理想气体定律 $p = \\rho R_d T_v$，我们可以将密度表示为 $\\rho = \\frac{p}{R_d T_v}$。气块理论的一个基本假设是，在任意给定高度 $z$，气块的压力与其环境相同，即 $p_{\\mathrm{par}}(z) = p_{\\mathrm{env}}(z) = p(z)$。将密度表达式代入浮力方程得到：\n$$B = g \\left(1 - \\frac{p / (R_d T_{v,\\mathrm{par}})}{p / (R_d T_{v,\\mathrm{env}})}\\right) = g \\left(1 - \\frac{T_{v,\\mathrm{env}}}{T_{v,\\mathrm{par}}}\\right) = g \\frac{T_{v,\\mathrm{par}} - T_{v,\\mathrm{env}}}{T_{v,\\mathrm{par}}}$$\n令虚温差为 $\\Delta T_v = T_{v,\\mathrm{par}} - T_{v,\\mathrm{env}}$。由于问题陈述偏差很小，我们可以通过近似分母 $T_{v,\\mathrm{par}} \\approx T_{v,\\mathrm{env}}$ 来线性化此表达式，得到：\n$$B \\approx g \\frac{\\Delta T_v}{T_{v,\\mathrm{env}}}$$\n接下来，我们用给定的温差 $\\Delta T$ 和比湿超量 $\\Delta q_v$ 来表示 $\\Delta T_v$。使用定义 $T_v \\approx T(1 + \\alpha q_v)$:\n$$T_{v,\\mathrm{par}} \\approx T_{\\mathrm{par}}(1 + \\alpha q_{v,\\mathrm{par}})$$\n$$T_{v,\\mathrm{env}} \\approx T_{\\mathrm{env}}(1 + \\alpha q_{v,\\mathrm{env}})$$\n代入 $T_{\\mathrm{par}} = T_{\\mathrm{env}} + \\Delta T$ 和 $q_{v,\\mathrm{par}} = q_{v,\\mathrm{env}} + \\Delta q_v$:\n$$\\Delta T_v = T_{v,\\mathrm{par}} - T_{v,\\mathrm{env}} \\approx (T_{\\mathrm{env}} + \\Delta T)(1 + \\alpha (q_{v,\\mathrm{env}} + \\Delta q_v)) - T_{\\mathrm{env}}(1 + \\alpha q_{v,\\mathrm{env}})$$\n展开乘积：\n$$\\Delta T_v \\approx (T_{\\mathrm{env}} + \\alpha T_{\\mathrm{env}}q_{v,\\mathrm{env}} + \\alpha T_{\\mathrm{env}}\\Delta q_v + \\Delta T + \\alpha \\Delta T q_{v,\\mathrm{env}} + \\alpha \\Delta T \\Delta q_v) - (T_{\\mathrm{env}} + \\alpha T_{\\mathrm{env}}q_{v,\\mathrm{env}})$$\n对于 $(\\Delta T, \\Delta q_v)$ 的一阶近似，我们忽略像 $\\alpha \\Delta T q_{v,\\mathrm{env}}$ 和 $\\alpha \\Delta T \\Delta q_v$ 这样的二阶项。这简化为：\n$$\\Delta T_v \\approx \\Delta T + \\alpha T_{\\mathrm{env}} \\Delta q_v$$\n将此式代入线性化的浮力方程，并在分母中近似 $T_{v,\\mathrm{env}} = T_{\\mathrm{env}}(1 + \\alpha q_{v,\\mathrm{env}}) \\approx T_{\\mathrm{env}}$（因为 $q_{v,\\mathrm{env}}$ 很小），我们得到所需的浮力表达式，记为 $B_{T_v}(z)$:\n$$B_{T_v}(z) \\approx g \\frac{\\Delta T + \\alpha T_{\\mathrm{env}}(z) \\Delta q_v}{T_{\\mathrm{env}}(z)} = g \\left(\\frac{\\Delta T}{T_{\\mathrm{env}}(z)} + \\alpha \\Delta q_v\\right)$$\n这个表达式分离了来自温差 $(\\Delta T)$ 和水汽超量 $(\\Delta q_v)$ 的贡献。\n\n### 任务 2: 计算 CAPE 值\n\n首先，我们定义两个浮力项。包含水汽的完整浮力 $B_{T_v}$ 是上面推导的表达式。忽略水汽的浮力 $B_T$ 是通过将虚温 $T_v$ 设置为实际温度 $T$ 得到的，这等同于在虚温定义中设置 $\\alpha=0$。结果是：\n$$B_T(z) = g \\frac{\\Delta T}{T_{\\mathrm{env}}(z)}$$\n$$B_{T_v}(z) = g \\left(\\frac{\\Delta T}{T_{\\mathrm{env}}(z)} + \\alpha \\Delta q_v\\right)$$\n现在我们通过在垂直域 $z \\in [0, H]$ 上积分来计算相应的 CAPE 值。\n\n仅由温度引起的 CAPE 为：\n$$\\mathrm{CAPE}[T] = \\int_{0}^{H} B_T(z)\\,dz = \\int_{0}^{H} g \\frac{\\Delta T}{T_{\\mathrm{env}}(z)}\\,dz$$\n代入 $T_{\\mathrm{env}}(z) = T_0 - \\Gamma z$:\n$$\\mathrm{CAPE}[T] = g \\Delta T \\int_{0}^{H} \\frac{1}{T_0 - \\Gamma z}\\,dz$$\n积分为：\n$$\\int_{0}^{H} \\frac{1}{T_0 - \\Gamma z}\\,dz = \\left[-\\frac{1}{\\Gamma} \\ln(T_0 - \\Gamma z)\\right]_{0}^{H} = -\\frac{1}{\\Gamma} \\left( \\ln(T_0 - \\Gamma H) - \\ln(T_0) \\right) = \\frac{1}{\\Gamma} \\ln\\left(\\frac{T_0}{T_0 - \\Gamma H}\\right)$$\n所以，$\\mathrm{CAPE}[T]$ 的解析表达式为：\n$$\\mathrm{CAPE}[T] = \\frac{g \\Delta T}{\\Gamma} \\ln\\left(\\frac{T_0}{T_0 - \\Gamma H}\\right)$$\n包括虚温效应的 CAPE 为：\n$$\\mathrm{CAPE}[T_v] = \\int_{0}^{H} B_{T_v}(z)\\,dz = \\int_{0}^{H} \\left( g \\frac{\\Delta T}{T_{\\mathrm{env}}(z)} + g \\alpha \\Delta q_v \\right)\\,dz$$\n利用积分的线性性质：\n$$\\mathrm{CAPE}[T_v] = \\int_{0}^{H} g \\frac{\\Delta T}{T_{\\mathrm{env}}(z)}\\,dz + \\int_{0}^{H} g \\alpha \\Delta q_v\\,dz$$\n第一项是 $\\mathrm{CAPE}[T]$。第二项是常数的积分：\n$$\\int_{0}^{H} g \\alpha \\Delta q_v\\,dz = g \\alpha \\Delta q_v [z]_{0}^{H} = g \\alpha \\Delta q_v H$$\n因此，$\\mathrm{CAPE}[T_v]$ 的表达式为：\n$$\\mathrm{CAPE}[T_v] = \\mathrm{CAPE}[T] + g \\alpha \\Delta q_v H$$\n\n### 任务 3: 计算偏差\n\n偏差定义为 $\\mathrm{bias} \\equiv \\mathrm{CAPE}[T] - \\mathrm{CAPE}[T_v]$。使用任务2中推导的表达式：\n$$\\mathrm{bias} = \\mathrm{CAPE}[T] - (\\mathrm{CAPE}[T] + g \\alpha \\Delta q_v H) = -g \\alpha \\Delta q_v H$$\n这个非常简洁的结果表明，在给定的假设下，因忽略水汽对浮力的影响而引入的偏差与温度廓线无关。我们现在可以使用给定的常数计算其数值。重要的是要确保所有单位都是国际单位制（SI）。给定的值为：\n$g = 9.81\\,\\mathrm{m\\,s^{-2}}$\n$\\alpha = 0.61$ (无量纲)\n$\\Delta q_v = 0.004$ (无量纲, kg/kg)\n$H = 3000\\,\\mathrm{m}$\n\n将这些值代入偏差表达式：\n$$\\mathrm{bias} = -(9.81\\,\\mathrm{m\\,s^{-2}}) \\times (0.61) \\times (0.004) \\times (3000\\,\\mathrm{m})$$\n$$\\mathrm{bias} = -71.8092\\,\\mathrm{m^2\\,s^{-2}}$$\n单位 $\\mathrm{m^2\\,s^{-2}}$ 等效于焦耳每千克 ($\\mathrm{J\\,kg^{-1}}$)。\n问题要求答案四舍五入到四位有效数字。\n$$\\mathrm{bias} \\approx -71.81\\,\\mathrm{J\\,kg^{-1}}$$\n负号表示忽略水汽会导致对 CAPE 的低估，因为在相同温度下，湿气块比干气块更具浮力。",
            "answer": "$$\\boxed{-71.81}$$"
        },
        {
            "introduction": "在数值模型中，大气廓线以离散数据点的形式存在，而非连续函数。因此，我们需要一个稳健的算法来从这些数据中计算CAPE和对流抑制（CIN）。这项练习将指导你构建一个完整且实用的算法 ，包括通过数值积分计算CAPE和CIN，并处理诸如自由对流高度（LFC）和平衡高度（EL）等关键层级的定位。特别地，你将学习如何处理当上升气块在模式顶层仍然保持正浮力时的常见复杂情况。",
            "id": "4026532",
            "problem": "考虑一个垂直大气柱，由几何高度 $z$（单位：米）的离散层级以及相应的环境和气块虚温 $T_{ve}(z)$ 和 $T_{vp}(z)$（单位：开尔文）表示。在数值天气预报 (NWP) 中，对流有效位能 (CAPE; Convective Available Potential Energy) 和对流抑制 (CIN; Convective Inhibition) 用于量化浮力的积分效应。气块浮力加速度 $b(z)$ 使用虚温近似定义为 $b(z) = g \\, \\frac{T_{vp}(z) - T_{ve}(z)}{T_{ve}(z)}$，其中 $g$ 是重力加速度。自由对流高度 (LFC; Level of Free Convection) 是气块从负浮力转变为正浮力的最低高度，而平衡高度 (EL; Equilibrium Level) 是正浮力气块恢复到中性浮力的高度。CAPE 是 $b(z)$ 在气块为正浮力区间的垂直积分，而 CIN 是从地表到 LFC 的 $b(z)$ 负积分的绝对值。CAPE 和 CIN 的单位均为焦耳/千克。在模式顶内不存在 $z_{EL}$ 的廓线中，处理方法需要定义一个截断规则，并评估对所选顶部边界的敏感性。\n\n从理想气体定律和湿空气的虚温概念出发，并将 $b(z)$ 视为在离散层级之间进行线性插值的连续函数，任务是实现一个算法，该算法能够：\n1. 通过定位 $b(z)$ 从负到正的第一个过零点，并线性插值到 $b(z)=0$ 的精确 $z$ 值，来确定 $z_{LFC}$。\n2. 通过定位 $z_{LFC}$ 上方 $b(z)$ 从正到非正的第一个过零点来确定 $z_{EL}$；如果在预设的模式顶 $z_{top}$ 以下不存在这样的过零点，则应用一个 $\\epsilon$-中性阈值：使用线性插值，在 $b(z) \\le \\epsilon$ 的第一个高度处声明 $z_{EL}$。如果在 $z_{top}$ 以下既没有发生过零，也没有达到 $\\epsilon$ 阈值，则在 $z_{top}$ 处截断 CAPE 积分，从而定义一个截断高度 $z_{cut} = z_{top}$。\n3. 将 CAPE 计算为 $b(z)$ 从 $z_{LFC}$ 到 $\\min(z_{EL}, z_{top})$ 的积分，在边界处使用梯形积分法和线性插值。将 CIN 计算为从地表 ($z=0$) 到 $z_{LFC}$ 的负 $b(z)$ 积分的绝对值，同样在边界处使用梯形积分法和线性插值。\n4. 通过对同一廓线在两个不同的 $z_{top}$ 值下计算 CAPE，并报告其差值和比率，来评估对 $z_{top}$ 的敏感性。\n\n所有 CAPE 和 CIN 值均以焦耳/千克（$\\mathrm{J\\,kg^{-1}}$）表示。使用 $g = 9.81 \\, \\mathrm{m\\,s^{-2}}$。不涉及角度。$\\epsilon$ 阈值必须以 $\\mathrm{m\\,s^{-2}}$ 为单位提供。\n\n您的程序必须实现此算法并将其应用于以下测试套件。对于每个测试用例，输入是一个由 $z$（米）、$T_{ve}$（开尔文）和气块-环境虚温差 $\\Delta T_v(z) = T_{vp}(z) - T_{ve}(z)$（开尔文）的数组定义的离散廓线。气块虚温为 $T_{vp}(z) = T_{ve}(z) + \\Delta T_v(z)$。程序必须使用上面定义的 $b(z)$ 计算 CAPE 和 CIN。对于每个测试用例，计算：\n- 第一个 $z_{top}$ 的 CAPE，\n- 第二个 $z_{top}$ 的 CAPE，\n- 差值（第二个减第一个），单位为 $\\mathrm{J\\,kg^{-1}}$，\n- 比率（第二个除以第一个），为小数（无量纲），\n- 并将 CIN 作为该测试用例输出列表的第一个元素。\n\n测试套件：\n- 测试用例 1（具有明确定义的 $z_{EL}$ 的理想路径）：\n  - $z$（米）：$[0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000]$。\n  - $T_{ve}$（开尔文）：$[300.0, 293.5, 287.0, 280.5, 274.0, 267.5, 261.0, 254.5, 248.0, 241.5, 235.0, 228.5, 222.0, 215.5, 209.0]$。\n  - $\\Delta T_v$（开尔文）：$[-1.0, 0.0, 2.0, 5.0, 7.0, 8.0, 8.0, 7.0, 5.0, 3.0, 1.0, 0.0, -1.0, -2.0, -3.0]$。\n  - $z_{top}$ 值（米）：$[12000, 14000]$。\n  - $\\epsilon$（$\\mathrm{m\\,s^{-2}}$）：$0.02$。\n- 测试用例 2（模式顶以下无 $z_{EL}$，气块一直保持正浮力直到顶部）：\n  - $z$（米）：$[0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000]$。\n  - $T_{ve}$（开尔文）：$[300.0, 293.5, 287.0, 280.5, 274.0, 267.5, 261.0, 254.5, 248.0, 241.5, 235.0, 228.5, 222.0, 215.5, 209.0, 202.5, 196.0]$。\n  - $\\Delta T_v$（开尔文）：$[-1.0, 0.0, 2.0, 5.0, 7.0, 8.0, 9.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0]$。\n  - $z_{top}$ 值（米）：$[12000, 16000]$。\n  - $\\epsilon$（$\\mathrm{m\\,s^{-2}}$）：$0.02$。\n- 测试用例 3（近中性平台；如果没有发生过零，则使用 $\\epsilon$ 截断）：\n  - $z$（米）：$[0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000]$。\n  - $T_{ve}$（开尔文）：$[300.0, 293.5, 287.0, 280.5, 274.0, 267.5, 261.0, 254.5, 248.0, 241.5, 235.0, 228.5, 222.0, 215.5, 209.0]$。\n  - $\\Delta T_v$（开尔文）：$[-1.0, 0.0, 2.0, 5.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0, 1.0, 0.5, 0.2, 0.05, 0.02]$。\n  - $z_{top}$ 值（米）：$[12000, 14000]$。\n  - $\\epsilon$（$\\mathrm{m\\,s^{-2}}$）：$0.02$。\n\n对于每个测试用例，您的程序必须生成一个包含五个浮点数的列表 $[\\mathrm{CIN}, \\mathrm{CAPE}(z_{top,1}), \\mathrm{CAPE}(z_{top,2}), \\mathrm{CAPE}(z_{top,2}) - \\mathrm{CAPE}(z_{top,1}), \\mathrm{CAPE}(z_{top,2}) / \\mathrm{CAPE}(z_{top,1})]$，并按指定单位和顺序排列。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[[x_1,x_2,x_3,x_4,x_5],[y_1,y_2,y_3,y_4,y_5],[z_1,z_2,z_3,z_4,z_5]]$），每个内部列表对应于上述顺序的一个测试用例。",
            "solution": "该问题要求实现一种算法，用于从离散的大气廓线数据中计算对流有效位能 (CAPE) 和对流抑制 (CIN)，并评估 CAPE 对模式顶高度 $z_{top}$ 的敏感性。该解决方案基于大气热力学原理，特别是气块浮力的概念。\n\n首先，我们定义气块浮力加速度 $b(z)$，这是计算 CAPE 和 CIN 的基本量。基于湿空气的虚温近似，浮力由下式给出：\n$$\nb(z) = g \\, \\frac{T_{vp}(z) - T_{ve}(z)}{T_{ve}(z)} = g \\, \\frac{\\Delta T_v(z)}{T_{ve}(z)}\n$$\n其中 $g$ 是重力加速度（$9.81 \\, \\mathrm{m\\,s^{-2}}$），$T_{ve}(z)$ 是环境虚温，$T_{vp}(z)$ 是气块虚温，$\\Delta T_v(z)$ 是它们在几何高度 $z$ 处的差值。我们通过假设在给定的离散数据点之间进行线性插值，将 $b(z)$ 视为一个连续函数。\n\n该算法主要分三个阶段进行：确定关键大气层级、执行数值积分以及进行敏感性分析。\n\n**1. 确定关键层级**\n\n两个关键层级是自由对流高度 ($z_{LFC}$) 和平衡高度 ($z_{EL}$)。\n\n*   **自由对流高度 ($z_{LFC}$):** 这是负浮力气块变为正浮力的最低高度。我们必须找到第一个高度 $z$，使得 $b(z)$ 从非正值变为正值。为此，我们遍历由高度 $[z_i, z_{i+1}]$ 定义的离散大气层，并找到第一个满足 $b(z_i) \\le 0$ 和 $b(z_{i+1})  0$ 的实例。然后通过线性插值找到 $b(z_{LFC}) = 0$ 的根，从而确定确切的高度 $z_{LFC}$。插值公式为：\n    $$\n    z_{LFC} = z_i + (0 - b(z_i)) \\frac{z_{i+1} - z_i}{b(z_{i+1}) - b(z_i)}\n    $$\n\n*   **平衡高度 ($z_{EL}$):** 这是 $z_{LFC}$ 以上，气块浮力恢复到中性或负值的高度。寻找 $z_{EL}$ 遵循一个多步骤规则：\n    a. 首先，我们搜索 $z_{LFC}$ 以上 $b(z)$ 从正值变为非正值的最低高度。如果找到了一个区间 $[z_j, z_{j+1}]$ 满足 $b(z_j)  0$ 且 $b(z_{j+1}) \\le 0$，则通过线性插值计算 $z_{EL}$ 以找到根 $b(z_{EL})=0$。\n    b. 如果在廓线数据内没有出现这样的过零点，我们接着搜索浮力降至一个小的正阈值 $\\epsilon$ 以下的最低高度。如果在 $z_{LFC}$ 上方找到一个区间 $[z_k, z_{k+1}]$ 满足 $b(z_k)  \\epsilon$ 且 $b(z_{k+1}) \\le \\epsilon$，则通过插值找到 $b(z_{EL}) = \\epsilon$ 的高度来确定 $z_{EL}$。\n    c. 如果在数据的垂直范围内既没有找到过零点也没有找到 $\\epsilon$-过零点，这意味着气块直到最高数据层都保持强烈的正浮力。在这种情况下，$z_{EL}$ 在概念上位于模式顶或其上方。\n\n**2. CIN 和 CAPE 的数值积分**\n\nCIN 和 CAPE 都被定义为浮力 $b(z)$ 的垂直积分。单位是单位质量的能量，$\\mathrm{J\\,kg^{-1}}$。积分使用梯形法则执行，并进行推广以处理可能与离散高度层级不对齐的积分限。\n\n对于任意积分区间 $[z_a, z_b]$，我们构建一个新的积分点集合，包括起始点 $z_a$、在 $z_a$ 和 $z_b$ 之间的所有原始网格点，以及结束点 $z_b$。$z_a$ 和 $z_b$ 处的浮力值通过线性插值得到。然后对这个新的点集应用标准梯形法则。\n\n*   **对流抑制 (CIN):** CIN 量化了对流启动前必须克服的能量障碍。它计算为从地表 ($z=0$) 到 $z_{LFC}$ 的浮力积分的绝对值，在该区域浮力为负。\n    $$\n    \\mathrm{CIN} = \\left| \\int_{0}^{z_{LFC}} b(z) \\, dz \\right| = - \\int_{0}^{z_{LFC}} b(z) \\, dz\n    $$\n\n*   **对流有效位能 (CAPE):** CAPE 代表了正浮力气块可以对环境做的总功。它是从 $z_{LFC}$ 开始在正浮力区域上的浮力积分。积分上限，我们可以称之为 $z_{cut}$，由确定的平衡高度 $z_{EL}$ 和指定的模式顶 $z_{top}$ 的最小值定义。\n    $$\n    \\mathrm{CAPE} = \\int_{z_{LFC}}^{z_{cut}} b(z) \\, dz, \\quad \\text{其中} \\quad z_{cut} = \\min(z_{EL}, z_{top})\n    $$\n    如果在 $z_{top}$ 以下没有找到 $z_{EL}$，则积分在 $z_{top}$ 处被截断，即 $z_{cut} = z_{top}$。\n\n**3. 敏感性分析**\n\n最后一步是评估计算出的 CAPE 值对模式顶 $z_{top}$ 选择的敏感性。这在 $z_{EL}$ 接近或高于 $z_{top}$ 的情况下尤其重要。该算法为两个不同的值 $z_{top,1}$ 和 $z_{top,2}$ 计算 CAPE。然后通过计算绝对差值 $\\mathrm{CAPE}(z_{top,2}) - \\mathrm{CAPE}(z_{top,1})$ 和相对比率 $\\mathrm{CAPE}(z_{top,2}) / \\mathrm{CAPE}(z_{top,1})$ 来量化敏感性。\n\n将此完整过程应用于每个测试用例，产生一个包含 $[\\mathrm{CIN}, \\mathrm{CAPE}(z_{top,1}), \\mathrm{CAPE}(z_{top,2}), \\text{差值}, \\text{比率}]$ 的五元素列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    # Gravitational acceleration in m/s^2\n    G = 9.81\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"z\": np.array([0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000], dtype=float),\n            \"T_ve\": np.array([300.0, 293.5, 287.0, 280.5, 274.0, 267.5, 261.0, 254.5, 248.0, 241.5, 235.0, 228.5, 222.0, 215.5, 209.0], dtype=float),\n            \"delta_Tv\": np.array([-1.0, 0.0, 2.0, 5.0, 7.0, 8.0, 8.0, 7.0, 5.0, 3.0, 1.0, 0.0, -1.0, -2.0, -3.0], dtype=float),\n            \"z_tops\": [12000.0, 14000.0],\n            \"epsilon\": 0.02\n        },\n        {\n            \"z\": np.array([0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000, 15000, 16000], dtype=float),\n            \"T_ve\": np.array([300.0, 293.5, 287.0, 280.5, 274.0, 267.5, 261.0, 254.5, 248.0, 241.5, 235.0, 228.5, 222.0, 215.5, 209.0, 202.5, 196.0], dtype=float),\n            \"delta_Tv\": np.array([-1.0, 0.0, 2.0, 5.0, 7.0, 8.0, 9.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0], dtype=float),\n            \"z_tops\": [12000.0, 16000.0],\n            \"epsilon\": 0.02\n        },\n        {\n            \"z\": np.array([0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000, 11000, 12000, 13000, 14000], dtype=float),\n            \"T_ve\": np.array([300.0, 293.5, 287.0, 280.5, 274.0, 267.5, 261.0, 254.5, 248.0, 241.5, 235.0, 228.5, 222.0, 215.5, 209.0], dtype=float),\n            \"delta_Tv\": np.array([-1.0, 0.0, 2.0, 5.0, 7.0, 6.0, 5.0, 4.0, 3.0, 2.0, 1.0, 0.5, 0.2, 0.05, 0.02], dtype=float),\n            \"z_tops\": [12000.0, 14000.0],\n            \"epsilon\": 0.02\n        }\n    ]\n\n    def find_crossing(z, y, target_y, start_idx, condition):\n        \"\"\"\n        Finds the first height z where y(z) crosses a target value, based on a condition.\n        condition is a lambda function: e.g., lambda y1, y2: y1 = 0 and y2 > 0.\n        \"\"\"\n        for i in range(start_idx, len(z) - 1):\n            if condition(y[i], y[i+1]):\n                # Linear interpolation to find the exact crossing point.\n                if np.isclose(y[i+1], y[i]):\n                    return z[i] if np.isclose(y[i], target_y) else None\n                z_cross = z[i] + (target_y - y[i]) * (z[i+1] - z[i]) / (y[i+1] - y[i])\n                return z_cross\n        return None\n\n    def integrate_buoyancy(z, b, z_start, z_end):\n        \"\"\"\n        Integrates buoyancy 'b' from z_start to z_end using the trapezoidal rule.\n        Handles integration limits that are not on the grid points.\n        \"\"\"\n        if z_start >= z_end:\n            return 0.0\n\n        # Find indices of the grid points that bracket the integration interval\n        start_idx = np.searchsorted(z, z_start, side='right')\n        end_idx = np.searchsorted(z, z_end, side='left')\n        \n        # Create a combined array of z-points for integration\n        z_integration_points = np.concatenate(([z_start], z[start_idx:end_idx], [z_end]))\n        z_integration_points = np.unique(z_integration_points) # Ensure no duplicate points\n\n        # Interpolate buoyancy values at these points\n        b_integration_points = np.interp(z_integration_points, z, b)\n        \n        # Perform trapezoidal integration\n        return np.trapz(b_integration_points, z_integration_points)\n\n    def calculate_cape_cin(case_data):\n        \"\"\"\n        Calculates CIN, CAPE, and sensitivity for a single test case.\n        \"\"\"\n        z, T_ve, delta_Tv = case_data[\"z\"], case_data[\"T_ve\"], case_data[\"delta_Tv\"]\n        z_top1, z_top2 = case_data[\"z_tops\"]\n        epsilon = case_data[\"epsilon\"]\n\n        # 1. Calculate buoyancy profile\n        buoyancy = G * delta_Tv / T_ve\n\n        # 2. Find LFC (Level of Free Convection)\n        z_lfc = find_crossing(z, buoyancy, 0.0, 0, lambda b1, b2: b1 = 0 and b2 > 0)\n        if z_lfc is None: # No positive buoyancy region\n            return [0.0, 0.0, 0.0, 0.0, np.nan]\n\n        # 3. Calculate CIN (Convective Inhibition)\n        cin = -integrate_buoyancy(z, buoyancy, z[0], z_lfc)\n\n        # 4. Find EL (Equilibrium Level)\n        lfc_idx = np.searchsorted(z, z_lfc, side='left')\n        \n        # Search for zero crossing\n        z_el = find_crossing(z, buoyancy, 0.0, lfc_idx, lambda b1, b2: b1 > 0 and b2 = 0)\n        \n        # If no zero crossing, search for epsilon crossing\n        if z_el is None:\n            z_el = find_crossing(z, buoyancy, epsilon, lfc_idx, lambda b1, b2: b1 > epsilon and b2 = epsilon)\n\n        # 5. Calculate CAPE for both z_top values\n        cape_values = []\n        for z_top in [z_top1, z_top2]:\n            z_cut = z_top\n            if z_el is not None:\n                z_cut = min(z_el, z_top)\n            \n            cape = integrate_buoyancy(z, buoyancy, z_lfc, z_cut)\n            cape_values.append(cape)\n        \n        cape1, cape2 = cape_values[0], cape_values[1]\n        \n        diff = cape2 - cape1\n        ratio = cape2 / cape1 if cape1 != 0 else np.nan\n        \n        return [cin, cape1, cape2, diff, ratio]\n\n    results = []\n    for case in test_cases:\n        result = calculate_cape_cin(case)\n        results.append(result)\n\n    # Format output string exactly as specified\n    output_str = '[' + ','.join([str(r).replace(' ', '') for r in results]) + ']'\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "当我们将离散的大气廓线数据内插为连续函数以进行积分时，内插方法的选择至关重要。一些看似简单的内插方法（如高阶多项式）可能会产生非物理性的振荡，从而导致对CAPE的错误估计。这项高级实践  挑战你实现一种能够避免引入虚假极值的保形内插方案。掌握这项技能，对于在天气和气候模型中开发可靠的诊断工具，防止对CAPE的人为“创造”，是至关重要的一步。",
            "id": "4026587",
            "problem": "给定环境虚温和抬升气块虚温随几何高度变化的离散垂直廓线。根据基本原理，在高度 $z$ 处，单位质量气块所受的比浮力（即浮力加速度）定义为：\n$$\nB(z) \\equiv g \\,\\frac{T_{v,p}(z) - T_{v,e}(z)}{T_{v,e}(z)},\n$$\n其中 $g$ 是重力加速度，$T_{v,e}(z)$ 是环境虚温，$T_{v,p}(z)$ 是气块虚温。对流有效位能（CAPE）和对流抑制（CIN）是浮力加速度在垂直方向上的路径积分，定义为：\n$$\n\\text{CAPE} \\equiv \\int_{z_{\\text{min}}}^{z_{\\text{max}}} \\max\\{B(z),\\,0\\}\\,dz, \\qquad\n\\text{CIN} \\equiv -\\int_{z_{\\text{min}}}^{z_{\\text{max}}} \\min\\{B(z),\\,0\\}\\,dz.\n$$\n在数值天气预报和气候模拟中，由于振荡插值可能在 $B(z)$ 中产生虚假的正面积，这会破坏 $\\text{CAPE}$ 的估算值。您必须设计并实现一个稳健的插值方案，用于 $T_{v,e}(z)$ 和气块 $T_{v,p}(z)$，该方案应能保持 $B(z)$ 的符号结构，避免产生虚假的 $\\text{CAPE}$。此方案应基于以下科学依据：\n- 理想气体定律和虚温的定义表明，在给定的气压层上，浮力的符号由 $T_{v,p}(z) - T_{v,e}(z)$ 的符号决定。\n- 对于分层流体，Archimedes 原理和静力平衡将 $B(z)$ 的物理意义阐释为由密度（或虚温）差异引起的垂直加速度。\n\n您的任务是使用一种插值和积分方法，根据离散数据计算 $\\text{CAPE}$ 和 $\\text{CIN}$，该方法需满足：\n- 使用保形分段三次 Hermite 插值来表示 $T_{v,e}(z)$，以避免在网格区间内出现过冲。\n- 使用直接根据节点差值构建的保形分段三次 Hermite 插值来表示差值 $D(z) \\equiv T_{v,p}(z) - T_{v,e}(z)$，从而精确保持 $D$ 在节点上的所有零点，并且不在节点之间引入振荡性的符号变化。\n- 使用上述插值函数计算 $B(z) = g \\, D(z) / T_{v,e}(z)$ 来定义 $B(z)$。\n- 通过稳健的区间限定和求根方法定位 $D(z)$ 在节点之间的零点，以检测 $B(z)$ 的所有符号变化。将节点上的零点明确地作为积分断点。不要假设数据点是均匀间隔的。\n- 将垂直域 $[z_{\\text{min}}, z_{\\text{max}}]$ 划分为由连续的零点和节点界定的子区间，以确保在每个子区间上 $B(z)$ 的符号恒定，然后使用数值上精确的求积法则在每个子区间上对 $B(z)$ 进行积分。按照上述定义，将正贡献累加到 $\\text{CAPE}$ 中，将负贡献累加到 $\\text{CIN}$ 中。\n\n科学和数值要求：\n- 使用重力加速度 $g = 9.80665$ $\\text{m}/\\text{s}^2$。\n- 高度 $z$ 的单位是米，虚温的单位是开尔文。\n- 将 $\\text{CAPE}$ 和 $\\text{CIN}$ 以 $\\text{J}/\\text{kg}$（等效于 $\\text{m}^2/\\text{s}^2$）为单位表示，并四舍五入到一位小数。\n\n测试套件：\n对于以下每个案例，$z$ 都是严格递增的，且为两种廓线共用。所有温度均为虚温。\n\n- 案例 A（理想路径：近地表为负，然后为正，再为负）：\n  - $z = [\\,0,\\,500,\\,1000,\\,1500,\\,2000,\\,3000\\,]$，单位：米。\n  - $T_{v,e}(z) = [\\,300.0,\\,296.0,\\,292.0,\\,288.5,\\,285.0,\\,281.0\\,]$，单位：开尔文。\n  - $T_{v,p}(z) = [\\,300.0,\\,295.5,\\,292.5,\\,290.5,\\,289.0,\\,280.0\\,]$，单位：开尔文。\n\n- 案例 B（零浮力平台被精确保持，然后为正，再为负）：\n  - $z = [\\,0,\\,200,\\,800,\\,1500,\\,2200\\,]$，单位：米。\n  - $T_{v,e}(z) = [\\,302.0,\\,300.5,\\,296.0,\\,292.0,\\,288.0\\,]$，单位：开尔文。\n  - $T_{v,p}(z) = [\\,302.0,\\,300.5,\\,296.5,\\,294.0,\\,287.0\\,]$，单位：开尔文。\n\n- 案例 C（近中性层附近的急剧曲率；避免虚假的振荡正面积）：\n  - $z = [\\,0,\\,1000,\\,1200,\\,2000,\\,4000\\,]$，单位：米。\n  - $T_{v,e}(z) = [\\,305.0,\\,297.0,\\,296.8,\\,294.0,\\,289.0\\,]$，单位：开尔文。\n  - $T_{v,p}(z) = [\\,305.0,\\,296.0,\\,296.7,\\,295.0,\\,292.0\\,]$，单位：开尔文。\n\n您的程序必须：\n- 实现上述插值和零点保持策略。\n- 稳健地检测所有零点交叉，并对符号恒定的子区间进行积分。\n- 为每个案例生成两个实数：$\\text{CAPE}$ 和 $\\text{CIN}$，单位为 $\\text{J}/\\text{kg}$，四舍五入到一位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\,\\text{CAPE}_A,\\,\\text{CIN}_A,\\,\\text{CAPE}_B,\\,\\text{CIN}_B,\\,\\text{CAPE}_C,\\,\\text{CIN}_C\\,]$。例如，一个语法上有效的输出看起来像“[12.3,4.5,67.8,9.0,1.2,3.4]”，但数值应为针对给定输入计算出的正确值。",
            "solution": "该问题是有效的。它在大气数值模拟领域提出了一个清晰、自洽且有科学依据的任务。问题中提供的浮力、对流有效位能（CAPE）和对流抑制（CIN）的定义是气象学中的标准定义。该问题解决了一个真实的数值挑战：标准插值方法可能引入虚假振荡，导致对大气稳定度参数的错误估算。所提出的解决方案，即使用保形分段三次 Hermite 插值，是缓解此问题的一种行之有效且适当的技术。测试案例中提供的数据在物理上是合理的，并且数值计算步骤的说明是具体且内部一致的。\n\n为每个给定的大气廓线计算 CAPE 和 CIN 的方法如下：\n\n首先，我们确定必要的物理常数和输入数据。重力加速度给定为 $g = 9.80665 \\, \\text{m}/\\text{s}^2$。对于每个测试案例，我们都得到了离散的垂直廓线，包括高度 $z$（单位：米）、环境虚温 $T_{v,e}(z)$（单位：开尔文）和抬升气块虚温 $T_{v,p}(z)$（单位：开尔文）。\n\n该方法的核心是根据离散数据点精确地表示连续函数。问题要求采用保形方法以避免数值伪影。\n1.  环境虚温廓线 $T_{v,e}(z)$ 由一个保形分段三次 Hermite 插值多项式表示。这类插值是单调的，意味着它不会在给定的数据点之间创建新的局部极值。这对于保持温度廓线的物理特性至关重要。我们根据给定的 $(z_i, T_{v,e,i})$ 数据对构建此插值函数。\n\n2.  虚温差的垂直廓线 $D(z) \\equiv T_{v,p}(z) - T_{v,e}(z)$ 是浮力符号的直接决定因素。为确保浮力的符号结构在节点之间被完美地保持，我们首先计算每个高度 $z_i$ 处的节点差值 $D_i = T_{v,p,i} - T_{v,e,i}$。然后，我们直接根据 $(z_i, D_i)$ 数据对为 $D(z)$ 构建一个保形分段三次 Hermite 插值多项式。这保证了如果在一个节点上 $D_i = 0$，插值函数在该节点处也将为零。此外，如果 $D_i$ 和 $D_{i+1}$ 符号相同（或其中一个为零），插值函数 $D(z)$ 在区间 $(z_i, z_{i+1})$ 内不会改变符号。\n\n通过这些连续表示，比浮力 $B(z)$ 在廓线定义域内的任何高度 $z$ 处定义为：\n$$\nB(z) = g \\frac{D(z)}{T_{v,e}(z)}\n$$\n其中 $D(z)$ 和 $T_{v,e}(z)$ 是从它们各自的插值函数获得的值。由于 $T_{v,e}(z)$ 始终为正值（单位为开尔文），$B(z)$ 的符号与 $D(z)$ 的符号完全相同。\n\n为了计算 CAPE 和 CIN 的积分，必须将垂直域 $[z_{\\text{min}}, z_{\\text{max}}]$ 划分为 $B(z)$ 符号恒定的子区间。这些子区间的边界，即积分断点，是 $B(z) = 0$ 的点。这些点发生在 $D(z) = 0$ 处。因此，积分断点的集合包括所有原始节点 $z_i$ 以及严格位于节点之间的 $D(z)=0$ 的任何附加根。\n为了找到这些根，我们检查每个区间 $[z_i, z_{i+1}]$。如果节点值 $D_i$ 和 $D_{i+1}$ 的符号相反（即 $D_i \\cdot D_{i+1}  0$），则在 $(z_i, z_{i+1})$ 内必定存在一个根。在此已括定的区间内，对插值函数 $D(z)$ 使用一个稳健的数值求根算法（如 Brent 方法），以找到零点交叉的精确高度。对所有区间重复此过程。所有唯一的节点和根组成的完整、排序后的集合构成了最终的积分断点列表。\n\n最后，我们执行积分。我们遍历由连续积分断点 $[z_j, z_{j+1}]$ 定义的每个子区间。在每个这样的子区间内，$B(z)$ 保证为非负或非正。我们使用高精度自适应求积方法计算 $B(z)$ 在此子区间上的定积分。\n$$\nI_j = \\int_{z_j}^{z_{j+1}} B(z) \\, dz\n$$\n根据 CAPE 和 CIN 的定义：\n- 如果 $I_j > 0$，其值被加到总 CAPE 中。\n- 如果 $I_j  0$，其值取反后加到总 CIN 中（因为 $\\text{CIN} = -\\int \\min(B,0) dz$）。\n- 如果 $I_j = 0$，则没有贡献。\n\n此过程应用于整个垂直域。然后将最终累积的 CAPE 和 CIN 值四舍五入到一位小数，以得出单位为 $\\text{J}/\\text{kg}$ 的结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq\nimport warnings\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final results.\n    \"\"\"\n\n    # Gravitational acceleration in m/s^2\n    G = 9.80665\n\n    def calculate_cape_cin(z_nodes, tve_nodes, tvp_nodes):\n        \"\"\"\n        Calculates CAPE and CIN for a single atmospheric profile.\n\n        Args:\n            z_nodes (np.array): Heights in meters.\n            tve_nodes (np.array): Environmental virtual temperatures in Kelvin.\n            tvp_nodes (np.array): Parcel virtual temperatures in Kelvin.\n\n        Returns:\n            tuple: A tuple containing (CAPE, CIN) in J/kg, rounded to one decimal place.\n        \"\"\"\n        # Ensure inputs are numpy arrays for vector operations\n        z_nodes = np.array(z_nodes, dtype=float)\n        tve_nodes = np.array(tve_nodes, dtype=float)\n        tvp_nodes = np.array(tvp_nodes, dtype=float)\n\n        # 1. Create shape-preserving piecewise cubic Hermite interpolators.\n        # Interpolator for environmental virtual temperature T_ve(z).\n        tve_interp = PchipInterpolator(z_nodes, tve_nodes)\n\n        # Calculate nodal differences D = T_vp - T_ve.\n        d_nodes = tvp_nodes - tve_nodes\n        # Interpolator for the difference D(z), preserving sign structure.\n        d_interp = PchipInterpolator(z_nodes, d_nodes)\n\n        # 2. Define the continuous buoyancy function B(z).\n        def buoyancy(z):\n            # Since T_ve is always positive, sign of B(z) depends only on D(z).\n            return G * d_interp(z) / tve_interp(z)\n\n        # 3. Find all integration breakpoints (original nodes + roots of D(z)).\n        breakpoints = set(z_nodes)\n        for i in range(len(z_nodes) - 1):\n            z_start, z_end = z_nodes[i], z_nodes[i+1]\n            d_start, d_end = d_nodes[i], d_nodes[i+1]\n\n            # A root exists between nodes if their signs are opposite.\n            if d_start * d_end  0:\n                try:\n                    # Brent's method is robust for finding a root in a bracketed interval.\n                    root = brentq(d_interp, z_start, z_end)\n                    breakpoints.add(root)\n                except ValueError:\n                    # This should not be reached if signs are truly opposite,\n                    # but included for robustness.\n                    pass\n        \n        sorted_breakpoints = sorted(list(breakpoints))\n\n        # 4. Integrate over subintervals of constant sign and accumulate CAPE/CIN.\n        cape = 0.0\n        cin = 0.0\n\n        for i in range(len(sorted_breakpoints) - 1):\n            z_a, z_b = sorted_breakpoints[i], sorted_breakpoints[i+1]\n            \n            # Avoid integrating over zero-width intervals if duplicates exist\n            if z_a >= z_b:\n                continue\n            \n            # Use adaptive quadrature for high accuracy.\n            # Suppress integration warnings which may occur in complex cases\n            # but are handled by the robust algorithm.\n            with warnings.catch_warnings():\n                warnings.filterwarnings('ignore', category=UserWarning)\n                integral, _ = quad(buoyancy, z_a, z_b, limit=100)\n\n            # Accumulate based on the sign of the integral.\n            if integral > 0:\n                cape += integral\n            else:\n                # CIN = - integral(min(B,0) dz), so we add the absolute value\n                # of the negative integral.\n                cin -= integral\n        \n        # 5. Round to one decimal place as required.\n        return round(cape, 1), round(cin, 1)\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # Case A\n        (\n            [0, 500, 1000, 1500, 2000, 3000],\n            [300.0, 296.0, 292.0, 288.5, 285.0, 281.0],\n            [300.0, 295.5, 292.5, 290.5, 289.0, 280.0]\n        ),\n        # Case B\n        (\n            [0, 200, 800, 1500, 2200],\n            [302.0, 300.5, 296.0, 292.0, 288.0],\n            [302.0, 300.5, 296.5, 294.0, 287.0]\n        ),\n        # Case C\n        (\n            [0, 1000, 1200, 2000, 4000],\n            [305.0, 297.0, 296.8, 294.0, 289.0],\n            [305.0, 296.0, 296.7, 295.0, 292.0]\n        )\n    ]\n\n    results = []\n    for z, tve, tvp in test_cases:\n        cape, cin = calculate_cape_cin(z, tve, tvp)\n        results.extend([cape, cin])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}