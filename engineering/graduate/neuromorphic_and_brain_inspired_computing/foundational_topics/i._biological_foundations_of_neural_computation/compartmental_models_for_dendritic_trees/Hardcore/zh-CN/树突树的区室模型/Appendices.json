{
    "hands_on_practices": [
        {
            "introduction": "模拟树突动力学的核心在于求解描述各区室电活动的微分方程组。本练习将这一过程具体化，要求您为一个简单的三区室模型手动构建并求解线性系统，从而计算出单个时间步内的电压演化 。通过实践这个基于隐式欧拉法的核心计算，您将深入理解仿真算法如何将物理定律转化为可解的代数问题。",
            "id": "4039542",
            "problem": "考虑一个由三个串联的等电位房室近似的无源树突电缆，该模型将在神经形态和脑启发计算环境中使用房室模型进行模拟。每个房室都具有膜电容 $C_{\\mathrm{m}}$、漏电导 $g_{\\mathrm{L}}$（对应反转电位 $E_{\\mathrm{L}}$），并通过轴向电导 $g_{\\mathrm{a}}$ 与其最近的邻居耦合。两端是封闭的，因此第一个和第三个房室之外没有轴向耦合。给定以下参数和状态：$C_{\\mathrm{m}} = 0.2~\\mathrm{nF}$，$g_{\\mathrm{L}} = 0.5~\\mathrm{\\mu S}$，$E_{\\mathrm{L}} = 0~\\mathrm{mV}$，$g_{\\mathrm{a}} = 1.0~\\mathrm{\\mu S}$（在房室 $1$–$2$ 和 $2$–$3$ 之间），时间步长 $\\Delta t = 0.1~\\mathrm{ms}$，以及在时间 $t_n$ 的膜电压由 $\\mathbf{V}^n = \\begin{pmatrix} -65 \\\\ -60 \\\\ -70 \\end{pmatrix}~\\mathrm{mV}$ 给出。假设外部注入电流（每个房室）在时间步结束时施加，即 $\\mathbf{I}(t_{n+1}) = \\begin{pmatrix} 0.5 \\\\ 0.0 \\\\ 0.2 \\end{pmatrix}~\\mathrm{nA}$。\n\n从基尔霍夫电流定律（KCL）以及电容电流、漏电流和轴向电流的无源电缆定义出发，推导将后向（隐式）欧拉法应用于从 $t_n$ 到 $t_{n+1}$ 的一个时间步所产生的线性系统，显式地构建所得的 $3 \\times 3$ 系统矩阵，并求解下一步的电压 $\\mathbf{V}^{n+1}$。以 $\\mathrm{mV}$ 为单位表示 $\\mathbf{V}^{n+1}$ 的每个分量，并将最终数值结果四舍五入到四位有效数字。最终答案必须以单行矩阵的形式给出。",
            "solution": "本题要求使用后向（隐式）欧拉法，为一个三房室树突模型的膜电压推导并求解一个线性系统。\n\n首先，我们根据基尔霍夫电流定律（KCL）为每个房室的膜电压建立控制方程。对于每个房室 $i$，电容电流、漏电流以及流向相邻房室的轴向电流之和必须等于外部注入电流。\n各项电流定义如下：\n- 电容电流：$I_{\\mathrm{cap}, i} = C_{\\mathrm{m}} \\frac{dV_i}{dt}$\n- 漏电流：$I_{\\mathrm{leak}, i} = g_{\\mathrm{L}} (V_i - E_{\\mathrm{L}})$\n- 从房室 $i$到 $j$ 的轴向电流：$I_{\\mathrm{axial}, ij} = g_{\\mathrm{a}} (V_i - V_j)$\n- 注入电流：$I_{i}(t)$\n\n树突电缆被建模为三个串联的房室，两端封闭。这意味着房室 1 仅与房室 2 耦合，房室 2 与房室 1 和 3 耦合，而房室 3 仅与房室 2 耦合。这三个房室的 KCL 方程为：\n\n对于房室 1：\n$$C_{\\mathrm{m}} \\frac{dV_1}{dt} + g_{\\mathrm{L}} (V_1 - E_{\\mathrm{L}}) + g_{\\mathrm{a}} (V_1 - V_2) = I_1(t)$$\n\n对于房室 2：\n$$C_{\\mathrm{m}} \\frac{dV_2}{dt} + g_{\\mathrm{L}} (V_2 - E_{\\mathrm{L}}) + g_{\\mathrm{a}} (V_2 - V_1) + g_{\\mathrm{a}} (V_2 - V_3) = I_2(t)$$\n\n对于房室 3：\n$$C_{\\mathrm{m}} \\frac{dV_3}{dt} + g_{\\mathrm{L}} (V_3 - E_{\\mathrm{L}}) + g_{\\mathrm{a}} (V_3 - V_2) = I_3(t)$$\n\n接下来，我们应用后向（隐式）欧拉法来离散化这些微分方程。时间导数近似为 $\\frac{dV_i}{dt} \\approx \\frac{V_i^{n+1} - V_i^n}{\\Delta t}$，所有其他项都在未来的时间步 $t_{n+1}$ 进行计算。令 $\\mathbf{V}^{n+1} = (V_1^{n+1}, V_2^{n+1}, V_3^{n+1})^T$ 为时间 $t_{n+1}$ 的未知电压向量。当 $E_{\\mathrm{L}} = 0~\\mathrm{mV}$ 时，离散化后的方程为：\n\n对于房室 1：\n$$C_{\\mathrm{m}} \\frac{V_1^{n+1} - V_1^n}{\\Delta t} + g_{\\mathrm{L}} V_1^{n+1} + g_{\\mathrm{a}} (V_1^{n+1} - V_2^{n+1}) = I_1^{n+1}$$\n\n对于房室 2：\n$$C_{\\mathrm{m}} \\frac{V_2^{n+1} - V_2^n}{\\Delta t} + g_{\\mathrm{L}} V_2^{n+1} + g_{\\mathrm{a}} (V_2^{n+1} - V_1^{n+1}) + g_{\\mathrm{a}} (V_2^{n+1} - V_3^{n+1}) = I_2^{n+1}$$\n\n对于房室 3：\n$$C_{\\mathrm{m}} \\frac{V_3^{n+1} - V_3^n}{\\Delta t} + g_{\\mathrm{L}} V_3^{n+1} + g_{\\mathrm{a}} (V_3^{n+1} - V_2^{n+1}) = I_3^{n+1}$$\n\n为了形成 $A \\mathbf{V}^{n+1} = \\mathbf{b}$ 形式的线性系统，我们重排这些方程，将所有包含 $\\mathbf{V}^{n+1}$ 的项归到左侧（LHS），将所有已知量归到右侧（RHS）。\n\n对 $V_1^{n+1}$、$V_2^{n+1}$ 和 $V_3^{n+1}$ 进行重排：\n$$ \\left(\\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + g_{\\mathrm{a}}\\right) V_1^{n+1} - g_{\\mathrm{a}} V_2^{n+1} = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_1^n + I_1^{n+1} $$\n$$ -g_{\\mathrm{a}} V_1^{n+1} + \\left(\\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + 2g_{\\mathrm{a}}\\right) V_2^{n+1} - g_{\\mathrm{a}} V_3^{n+1} = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_2^n + I_2^{n+1} $$\n$$ -g_{\\mathrm{a}} V_2^{n+1} + \\left(\\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + g_{\\mathrm{a}}\\right) V_3^{n+1} = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_3^n + I_3^{n+1} $$\n\n线性系统 $A \\mathbf{V}^{n+1} = \\mathbf{b}$ 的系统矩阵 $A$ 和向量 $\\mathbf{b}$ 定义如下：\n$$ A = \\begin{pmatrix}\n\\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + g_{\\mathrm{a}}  -g_{\\mathrm{a}}  0 \\\\\n-g_{\\mathrm{a}}  \\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + 2g_{\\mathrm{a}}  -g_{\\mathrm{a}} \\\\\n0  -g_{\\mathrm{a}}  \\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + g_{\\mathrm{a}}\n\\end{pmatrix} $$\n$$ \\mathbf{b} = \\begin{pmatrix}\n\\frac{C_{\\mathrm{m}}}{\\Delta t} V_1^n + I_1^{n+1} \\\\\n\\frac{C_{\\mathrm{m}}}{\\Delta t} V_2^n + I_2^{n+1} \\\\\n\\frac{C_{\\mathrm{m}}}{\\Delta t} V_3^n + I_3^{n+1}\n\\end{pmatrix} $$\n\n现在，我们代入给定的数值。如果我们使用单位：$C_{\\mathrm{m}}$ 为 $\\mathrm{nF}$，$g_{\\mathrm{L}}$ 和 $g_{\\mathrm{a}}$ 为 $\\mathrm{\\mu S}$，$V$ 为 $\\mathrm{mV}$，$\\Delta t$ 为 $\\mathrm{ms}$，$I$ 为 $\\mathrm{nA}$，那么单位是自洽的。\n参数为：$C_{\\mathrm{m}} = 0.2~\\mathrm{nF}$，$g_{\\mathrm{L}} = 0.5~\\mathrm{\\mu S}$，$g_{\\mathrm{a}} = 1.0~\\mathrm{\\mu S}$，$\\Delta t = 0.1~\\mathrm{ms}$。\n项 $\\frac{C_{\\mathrm{m}}}{\\Delta t} = \\frac{0.2~\\mathrm{nF}}{0.1~\\mathrm{ms}} = 2.0~\\frac{\\mathrm{nF}}{\\mathrm{ms}} = 2.0~\\mathrm{\\mu S}$。\n\n现在我们可以显式地构建 $3 \\times 3$ 系统矩阵 $A$：\n对角线元素为：\n$A_{11} = A_{33} = \\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + g_{\\mathrm{a}} = 2.0 + 0.5 + 1.0 = 3.5~\\mathrm{\\mu S}$\n$A_{22} = \\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + 2g_{\\mathrm{a}} = 2.0 + 0.5 + 2(1.0) = 4.5~\\mathrm{\\mu S}$\n非对角线元素为：\n$A_{12} = A_{21} = A_{23} = A_{32} = -g_{\\mathrm{a}} = -1.0~\\mathrm{\\mu S}$\n所以，系统矩阵为：\n$$ A = \\begin{pmatrix} 3.5  -1.0  0 \\\\ -1.0  4.5  -1.0 \\\\ 0  -1.0  3.5 \\end{pmatrix}~\\mathrm{\\mu S} $$\n\n接下来，我们使用 $\\mathbf{V}^n = \\begin{pmatrix} -65 \\\\ -60 \\\\ -70 \\end{pmatrix}~\\mathrm{mV}$ 和 $\\mathbf{I}^{n+1} = \\begin{pmatrix} 0.5 \\\\ 0.0 \\\\ 0.2 \\end{pmatrix}~\\mathrm{nA}$ 构建向量 $\\mathbf{b}$。\n$b_1 = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_1^n + I_1^{n+1} = (2.0)(-65) + 0.5 = -130 + 0.5 = -129.5~\\mathrm{nA}$\n$b_2 = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_2^n + I_2^{n+1} = (2.0)(-60) + 0.0 = -120 + 0.0 = -120.0~\\mathrm{nA}$\n$b_3 = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_3^n + I_3^{n+1} = (2.0)(-70) + 0.2 = -140 + 0.2 = -139.8~\\mathrm{nA}$\n所以，右侧向量为：\n$$ \\mathbf{b} = \\begin{pmatrix} -129.5 \\\\ -120.0 \\\\ -139.8 \\end{pmatrix}~\\mathrm{nA} $$\n\n我们现在求解线性系统 $A \\mathbf{V}^{n+1} = \\mathbf{b}$ 以得到 $\\mathbf{V}^{n+1}$：\n$$ \\begin{pmatrix} 3.5  -1.0  0 \\\\ -1.0  4.5  -1.0 \\\\ 0  -1.0  3.5 \\end{pmatrix} \\begin{pmatrix} V_1^{n+1} \\\\ V_2^{n+1} \\\\ V_3^{n+1} \\end{pmatrix} = \\begin{pmatrix} -129.5 \\\\ -120.0 \\\\ -139.8 \\end{pmatrix} $$\n这对应于以下方程组：\n1) $3.5 V_1^{n+1} - V_2^{n+1} = -129.5$\n2) $-V_1^{n+1} + 4.5 V_2^{n+1} - V_3^{n+1} = -120.0$\n3) $-V_2^{n+1} + 3.5 V_3^{n+1} = -139.8$\n\n根据方程(1)，我们将 $V_1^{n+1}$ 用 $V_2^{n+1}$ 表示：$V_1^{n+1} = \\frac{V_2^{n+1} - 129.5}{3.5}$。\n根据方程(3)，我们将 $V_3^{n+1}$ 用 $V_2^{n+1}$ 表示：$V_3^{n+1} = \\frac{V_2^{n+1} - 139.8}{3.5}$。\n将这些代入方程(2)：\n$$ -\\left(\\frac{V_2^{n+1} - 129.5}{3.5}\\right) + 4.5 V_2^{n+1} - \\left(\\frac{V_2^{n+1} - 139.8}{3.5}\\right) = -120.0 $$\n整个方程乘以 3.5：\n$$ -(V_2^{n+1} - 129.5) + (4.5 \\times 3.5) V_2^{n+1} - (V_2^{n+1} - 139.8) = -120.0 \\times 3.5 $$\n$$ -V_2^{n+1} + 129.5 + 15.75 V_2^{n+1} - V_2^{n+1} + 139.8 = -420 $$\n$$ (15.75 - 1 - 1) V_2^{n+1} + (129.5 + 139.8) = -420 $$\n$$ 13.75 V_2^{n+1} + 269.3 = -420 $$\n$$ 13.75 V_2^{n+1} = -420 - 269.3 = -689.3 $$\n$$ V_2^{n+1} = \\frac{-689.3}{13.75} \\approx -50.130909~\\mathrm{mV} $$\n现在我们求解 $V_1^{n+1}$ 和 $V_3^{n+1}$：\n$$ V_1^{n+1} = \\frac{-50.130909 - 129.5}{3.5} = \\frac{-179.630909}{3.5} \\approx -51.323117~\\mathrm{mV} $$\n$$ V_3^{n+1} = \\frac{-50.130909 - 139.8}{3.5} = \\frac{-189.930909}{3.5} \\approx -54.265974~\\mathrm{mV} $$\n\n最后，我们按要求将数值四舍五入到四位有效数字。\n$V_1^{n+1} \\approx -51.32~\\mathrm{mV}$\n$V_2^{n+1} \\approx -50.13~\\mathrm{mV}$\n$V_3^{n+1} \\approx -54.27~\\mathrm{mV}$\n\n下一步的电压解为 $\\mathbf{V}^{n+1} = \\begin{pmatrix} -51.32 \\\\ -50.13 \\\\ -54.27 \\end{pmatrix}~\\mathrm{mV}$。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} -51.32  -50.13  -54.27 \\end{pmatrix} } $$"
        },
        {
            "introduction": "拉尔法则为树突分支的电学特性提供了一个优雅的理论框架，但生物神经元的形态真的遵循这个理想规则吗？本练习将理论与实际数据分析相结合，要求您编写一个程序来检验从形态学重建中获得的树突分支是否符合 $d^{3/2}$ 法则 。通过这个实践，您将学会如何处理和分析神经形态数据，这是计算神经科学中的一项基本功。",
            "id": "3974766",
            "problem": "给定一组有根树，它们代表了树突丛的形态学重建。每个节点对应一个短的圆柱形区段，其直径以微米为单位指定。这些树表示为元组 $(\\text{node\\_id}, \\text{parent\\_id}, d)$ 的列表，其中 $d$ 是区段的直径（单位为 $\\mu\\text{m}$），$\\text{parent\\_id}=-1$ 表示根节点，且每个非根节点有且仅有一个父节点。分叉点（bifurcation）是任何具有两个或更多子节点的节点。\n\n目标是通过计算每个分叉点处父区段的 $d^{3/2}$ 与所有子区段的 $d^{3/2}$ 之和之间的偏差，来检验 Rall 法则在每棵树上的适用性。具体来说，对于一个父节点直径为 $d_p$、子节点直径为 $\\{d_k\\}_{k=1}^m$ 的分叉点，定义其和为 $S_{\\text{parent}} = d_p^{3/2}$ 和 $S_{\\text{kids}} = \\sum_{k=1}^m d_k^{3/2}$，以及相对偏差\n$$\n\\delta = \\frac{S_{\\text{kids}} - S_{\\text{parent}}}{S_{\\text{parent}}}.\n$$\n对于给定树中的所有分叉点，计算三个指标：平均绝对相对偏差 $\\overline{|\\delta|}$，最大绝对相对偏差 $\\max|\\delta|$，以及绝对相对偏差小于等于容差 $\\tau$ 的分叉点所占的比例 $f_\\tau$。容差为 $\\tau=0.05$（一个小数），所有偏差指标均为无量纲。如果一棵树没有分叉点，则定义 $\\overline{|\\delta|}=0$，$\\max|\\delta|=0$ 且 $f_\\tau=1$。\n\n此问题的理论基础是准静态条件下神经元树突的线性电缆理论，以及一个经过充分检验的观察结果：半无限长圆柱形电缆的输入电导与 $d^{3/2}$ 成正比，这导出了节点处的分支电导匹配条件。解答中需要给出此比例关系的推导及其应用。\n\n您的任务是实现一个程序，为提供的包含五棵树的测试套件计算每棵树的上述三个指标，并将它们以单一的聚合格式输出。直径以 $\\mu\\text{m}$ 为单位提供；偏差是无量纲的。不使用角度，也不使用百分号。\n\n测试套件（每棵树是一个 $(\\text{node\\_id}, \\text{parent\\_id}, d)$ 元组的列表；直径 $d$ 的单位是 $\\mu\\text{m}$）：\n\n- 树 A（平衡二叉树，在两个分叉点处均近似符合 Rall 法则）：\n    - $(0,-1,2.0736)$\n    - $(1,0,1.2)$\n    - $(2,0,1.4)$\n    - $(3,1,0.7)$\n    - $(4,1,0.81)$\n\n- 树 B（拓扑结构与树 A 相同，其中一个分支处有故意设置的偏差）：\n    - $(0,-1,2.0736)$\n    - $(1,0,1.2)$\n    - $(2,0,1.4)$\n    - $(3,1,0.7)$\n    - $(4,1,0.9)$\n\n- 树 C（根部为三叉分点且近似符合 Rall 法则，更深处的一个分叉点存在偏差）：\n    - $(0,-1,2.0850)$\n    - $(1,0,1.1)$\n    - $(2,0,1.0)$\n    - $(3,0,0.9)$\n    - $(4,1,0.7)$\n    - $(5,1,0.5)$\n\n- 树 D（单链，无分叉点）：\n    - $(0,-1,1.2)$\n    - $(1,0,1.1)$\n    - $(2,1,1.0)$\n    - $(3,2,0.9)$\n\n- 树 E（根部为二叉分点，其中一个子节点非常小以测试数值稳定性，更深处的一个分叉点存在偏差）：\n    - $(0,-1,1.0)$\n    - $(1,0,0.2)$\n    - $(2,0,0.945)$\n    - $(3,2,0.4)$\n    - $(4,2,0.5)$\n\n您的程序应生成单行输出，其中包含五棵树的结果，格式为一个逗号分隔的列表的列表，每个内部列表按 $[\\overline{|\\delta|}, \\max|\\delta|, f_\\tau]$ 的顺序列出三个指标。例如，输出应类似于 $[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3],[x_4,y_4,z_4],[x_5,y_5,z_5]]$，其中每个 $x_i$、$y_i$ 和 $z_i$ 都是浮点数。不允许有其他输出文本。",
            "solution": "该问题要求基于 Rall 分支法则对树突树形态进行分析，该法则是从线性电缆理论推导出来的。在介绍计算方法之前，必须按要求先建立理论基础。\n\n**理论基础：Rall 的 $3/2$ 次幂法则的推导**\n\nRall 法则的基础是在稳态（DC）条件下，电流在被动树突电缆中的行为。我们将一段树突建模为一个均匀的圆柱体。沿该电缆长度 $x$ 的电压 $V(x)$ 由稳态电缆方程描述：\n$$\n\\lambda^2 \\frac{d^2V}{dx^2} - V = 0\n$$\n这里，$\\lambda$ 是电缆的空间常数，定义为 $\\lambda = \\sqrt{r_m/r_a}$，其中 $r_m$ 是单位长度圆柱体的膜电阻，$r_a$ 是单位长度的轴向电阻。\n\n这些电阻取决于圆柱体的几何形状和神经元的内在特性。设 $d$ 为圆柱形区段的直径，$R_m$ 为比膜电阻（单位为 $\\Omega \\cdot \\text{m}^2$），$R_i$ 为比胞内（轴向）电阻率（单位为 $\\Omega \\cdot \\text{m}$）。\n\n单位长度的膜电阻 $r_m$ 与单位长度的膜表面积（周长 $\\pi d$）成反比：\n$$\nr_m = \\frac{R_m}{\\pi d}\n$$\n单位长度的轴向电阻 $r_a$ 与圆柱体的横截面积（$A = \\pi(d/2)^2$）成反比：\n$$\nr_a = \\frac{R_i}{A} = \\frac{R_i}{\\pi (d/2)^2} = \\frac{4 R_i}{\\pi d^2}\n$$\n将这些代入空间常数 $\\lambda$ 的定义中：\n$$\n\\lambda = \\sqrt{\\frac{r_m}{r_a}} = \\sqrt{\\frac{R_m / (\\pi d)}{4 R_i / (\\pi d^2)}} = \\sqrt{\\frac{R_m d}{4 R_i}}\n$$\n假设材料特性均匀（$R_m$ 和 $R_i$ 是常数），空间常数与直径的平方根成正比：$\\lambda \\propto \\sqrt{d}$。\n\n接下来，我们考虑树突分支的输入电导 $G_{in}$。对于半无限长电缆（对于电学上长的分支是一个有效的近似），其输入电阻为 $R_{in} = \\sqrt{r_m r_a}$。输入电导是其倒数：\n$$\nG_{in} = \\frac{1}{R_{in}} = \\frac{1}{\\sqrt{r_m r_a}}\n$$\n我们也可以用 $\\lambda$ 和 $r_a$ 将 $R_{in}$ 表示为 $R_{in} = \\lambda r_a$。因此：\n$$\nG_{in} = \\frac{1}{\\lambda r_a}\n$$\n现在，我们来研究 $G_{in}$ 如何随直径 $d$ 变化。我们已经确定 $\\lambda \\propto \\sqrt{d}$ 并且 $r_a \\propto 1/d^2$。因此：\n$$\nG_{in} \\propto \\frac{1}{(\\sqrt{d}) (1/d^2)} = \\frac{d^2}{\\sqrt{d}} = d^{3/2}\n$$\n这个推导确定了半无限长电缆的输入电导与其直径的 $3/2$ 次幂成正比。\n\nWilfrid Rall 的洞见是，为了实现无阻抗失配的高效信号传播，从父分支看进去的电导应等于其所有子分支电导的总和。在一个父节点直径为 $d_p$、m 个子分支直径为 $\\{d_k\\}_{k=1}^m$ 的分叉点，此条件为：\n$$\nG_{in, \\text{parent}} = \\sum_{k=1}^m G_{in, \\text{child}_k}\n$$\n使用推导出的比例关系，并设 $C$ 为比例常数，我们得到：\n$$\nC \\cdot d_p^{3/2} = \\sum_{k=1}^m C \\cdot d_k^{3/2}\n$$\n常数 $C$ 被消去，从而得到 Rall 著名的分支法则：\n$$\nd_p^{3/2} = \\sum_{k=1}^m d_k^{3/2}\n$$\n**计算策略**\n\n问题要求我们为一组给定的树突树量化其与此理想法则的偏差。对每棵树实现此目标的算法如下：\n\n1.  **数据结构化**：输入格式是一个由 $(\\text{node\\_id}, \\text{parent\\_id}, d)$ 元组组成的列表，这是一个边列表。需要将其解析为更便于计算的结构。使用两个字典是最佳选择：\n    *   一个将每个 `node_id` 映射到其直径 $d$ 的字典。\n    *   一个将每个父 `node_id` 映射到其子 `node_id` 列表的字典。这直接表示了树的层次结构。\n\n2.  **识别分叉点**：分叉点被定义为具有两个或更多子节点的节点。通过遍历上一步创建的父-子字典，所有作为长度 $\\ge 2$ 的列表的键的节点都被识别为分叉点。\n\n3.  **偏差计算**：对于每个识别出的分叉点 $p$：\n    *   获取父节点直径 $d_p$ 和子节点直径集合 $\\{d_k\\}$。\n    *   计算父节点之和 $S_{\\text{parent}} = d_p^{3/2}$。\n    *   计算子节点之和 $S_{\\text{kids}} = \\sum_{k} d_k^{3/2}$。\n    *   计算相对偏差 $\\delta = (S_{\\text{kids}} - S_{\\text{parent}}) / S_{\\text{parent}}$。请注意，对于任何 $d_p  0$，$S_{\\text{parent}}$ 也大于 0，从而避免了除以零。测试套件中的所有直径均为正数。\n    *   将树的所有计算出的 $\\delta$ 值收集到一个列表中。\n\n4.  **指标计算**：\n    *   如果树不包含分叉点，偏差列表将为空。根据问题定义，指标定义为 $\\overline{|\\delta|} = 0$，$\\max|\\delta| = 0$ 且 $f_\\tau = 1$。\n    *   如果存在分叉点，则根据 $\\delta$ 值的列表计算以下指标：\n        *   **平均绝对相对偏差, $\\overline{|\\delta|}$**：所有计算出的偏差的绝对值的算术平均值。\n        *   **最大绝对相对偏差, $\\max|\\delta|$**：所有计算出的偏差的绝对值中的最大值。\n        *   **合规分支的比例, $f_\\tau$**：满足 $|\\delta| \\le \\tau$ 的分叉点所占的比例，其中容差 $\\tau$ 给定为 $0.05$。其计算方式为（满足 $|\\delta| \\le \\tau$ 的分支数）/（总分支数）。\n\n将此过程独立应用于提供的五个测试树中的每一个，以生成最终结果。实现将使用 `numpy` 库进行高效的数值运算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates dendritic trees against Rall's rule and computes deviation metrics.\n    \"\"\"\n    # Test suite of five dendritic trees.\n    # Each tree is a list of (node_id, parent_id, diameter) tuples.\n    test_cases = [\n        # Tree A (balanced binary, near-Rall compliance)\n        [\n            (0, -1, 2.0736), (1, 0, 1.2), (2, 0, 1.4), (3, 1, 0.7), (4, 1, 0.81)\n        ],\n        # Tree B (same as A, one branch deviating)\n        [\n            (0, -1, 2.0736), (1, 0, 1.2), (2, 0, 1.4), (3, 1, 0.7), (4, 1, 0.9)\n        ],\n        # Tree C (trifurcation, deeper bifurcation deviating)\n        [\n            (0, -1, 2.0850), (1, 0, 1.1), (2, 0, 1.0), (3, 0, 0.9), (4, 1, 0.7), (5, 1, 0.5)\n        ],\n        # Tree D (single chain, no branching points)\n        [\n            (0, -1, 1.2), (1, 0, 1.1), (2, 1, 1.0), (3, 2, 0.9)\n        ],\n        # Tree E (binary root, deeper bifurcation deviating)\n        [\n            (0, -1, 1.0), (1, 0, 0.2), (2, 0, 0.945), (3, 2, 0.4), (4, 2, 0.5)\n        ]\n    ]\n\n    # Tolerance for calculating the fraction of compliant branches.\n    tau = 0.05\n    all_results = []\n\n    for tree_data in test_cases:\n        if not tree_data:\n            # Handle empty tree case if necessary, though not in test suite.\n            all_results.append([0.0, 0.0, 1.0])\n            continue\n            \n        diameters = {node_id: d for node_id, _, d in tree_data}\n        children = {}\n        for node_id, parent_id, _ in tree_data:\n            if parent_id != -1:\n                if parent_id not in children:\n                    children[parent_id] = []\n                children[parent_id].append(node_id)\n        \n        branching_points = [\n            node_id for node_id, child_list in children.items()\n            if len(child_list) = 2\n        ]\n\n        if not branching_points:\n            # Per problem spec, if no branching points, define metrics as follows.\n            mean_abs_dev = 0.0\n            max_abs_dev = 0.0\n            f_tau = 1.0\n            all_results.append([mean_abs_dev, max_abs_dev, f_tau])\n            continue\n\n        deviations = []\n        for bp_id in branching_points:\n            # Get parent diameter and calculate S_parent = d_p^(3/2)\n            d_p = diameters[bp_id]\n            # Handle d_p=0 case to prevent division by zero, though not in test data.\n            if d_p == 0:\n                # If parent diameter is 0, deviation is ill-defined.\n                # A sum of positive child diams would yield infinite deviation.\n                # Assuming d_p  0 based on context. Let's formalize a behavior if needed.\n                # If child diameters are also 0, deviation could be 0. We'll assume d_p  0.\n                s_parent = 0.0\n            else:\n                s_parent = np.power(d_p, 1.5)\n\n            # Get child diameters and calculate S_kids = sum(d_k^(3/2))\n            child_ids = children[bp_id]\n            child_diams = [diameters[cid] for cid in child_ids]\n            s_kids = np.sum(np.power(child_diams, 1.5))\n            \n            # Calculate relative deviation\n            if s_parent == 0:\n                # Can't compute relative deviation if parent sum is zero.\n                # If kids_sum is also 0, dev is 0. If kids_sum  0, dev is inf.\n                # This case is not expected in the problem.\n                delta = np.inf if s_kids  0 else 0.0\n            else:\n                delta = (s_kids - s_parent) / s_parent\n            \n            deviations.append(delta)\n\n        # Calculate metrics from the list of deviations\n        abs_deviations = np.abs(np.array(deviations))\n        mean_abs_dev = np.mean(abs_deviations)\n        max_abs_dev = np.max(abs_deviations)\n        \n        compliant_branches = np.sum(abs_deviations = tau)\n        f_tau = compliant_branches / len(branching_points)\n        \n        all_results.append([mean_abs_dev, max_abs_dev, f_tau])\n\n    # Format output to match specification: [[x1,y1,z1],[x2,y2,z2],...]\n    # without spaces inside the inner lists.\n    output_str = f\"[{','.join(['[' + ','.join(map(str, res)) + ']' for res in all_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "复杂的神经元模型在计算上可能非常昂贵，因此构建精确的简化模型至关重要。但是，如何确定简化模型的最佳结构呢？本项高级练习探讨了模型降阶中的一个核心问题：如何通过优化区室的划分来最小化模型的误差 。您将实现一个算法，以系统性的方式确定最佳的区室边界，从而在保持计算效率的同时最大化模型的保真度。",
            "id": "4039533",
            "problem": "您的任务是设计并实现一个程序，在一个简化的被动树突电缆模型中，优化隔室边界的位置，以在固定的隔室数量下最小化一个误差标准。该树突被建模为一个长度为 $L$、半径为 $r$ 的直圆柱体，其轴向电阻率为 $r_a$，膜漏电导密度为 $g_m(x)$。该模型在直流（DC）稳态条件下运行，一个恒定电流 $I_0$ 在近端（$x=0$）注入。远端在 $x=L$ 处是封闭的（没有轴向电流流过边界）。该程序的目的是优化简化模型的边界布局，使得简化模型能尽可能接近高分辨率参考模型，再现沿电缆的稳态电压分布。\n\n该模型的基础是电流守恒和欧姆定律。令 $V(x)$ 表示沿圆柱体的膜电压。对于一个横截面积为 $A=\\pi r^2$、单位长度膜表面积为 $S=2\\pi r$ 的圆柱形电缆，在直流条件下且膜电导密度 $g_m(x)$ 空间可变时，根据轴向电流守恒和膜向地的漏电，可得稳态一维电缆方程：\n$$\n\\frac{A}{r_a}\\frac{d^2 V(x)}{dx^2} - S\\,g_m(x)\\,V(x) = 0,\n$$\n该方程受限于 $x=L$ 处的边界条件（表示封闭末端，$\\frac{dV}{dx}(L)=0$）以及在 $x=0$ 处的电流注入（表示为施加到近端隔室的电流源）。\n\n一个简化的隔室模型使用 $N$ 个长度为 $\\{\\ell_i\\}_{i=1}^N$（使得 $\\sum_{i=1}^N \\ell_i = L$）的隔室来表示电缆，其中每个隔室 $i$ 都有一个位于中心位置 $x_i$ 的单一电压变量 $V_i$。相邻隔室通过轴向电导耦合，该电导由轴向电阻率和隔室中心之间的距离导出。每个隔室通过其膜向地漏电，其电导等于局部膜密度 $g_m(x_i)$ 与该隔室膜表面积 $S\\,\\ell_i$ 的乘积。近端隔室接收注入电流 $I_0$。高分辨率参考模型是在一个由 $M$ 个隔室（$M$ 很大）组成的精细均匀网格上，使用相同的离散化逻辑构建的，它在本次练习的层面上以可忽略的误差逼近连续电缆。\n\n优化目标定义为简化模型电压分布（表示为一个分段常数函数，其中每个隔室内的电压等于其隔室电压）与高分辨率参考电压分布之间差异的平方沿电缆的积分。具体来说，如果 $\\tilde{V}(x)$ 表示分段常数简化分布，$V_{\\mathrm{ref}}(x)$ 表示参考分布，则目标函数为\n$$\nJ(\\{\\ell_i\\}_{i=1}^N) = \\int_{0}^{L} \\left(\\tilde{V}(x) - V_{\\mathrm{ref}}(x)\\right)^2\\,dx.\n$$\n您必须通过将其根植于底层的线性被动电缆理论，并解释为什么该误差适用于直流响应，来证明选择此目标函数的合理性。在您的实现中，请使用参考模型所用的精细网格上的黎曼和来近似该积分。\n\n程序要求：\n- 使用以下有限体积布局实现轴向耦合和膜漏电的隔室离散化。对于长度为 $\\ell_i$、中心位于 $x_i$ 的隔室 $i$，膜电导为 $G_{m,i} = S \\, g_m(x_i)\\,\\ell_i$。相邻隔室 $i$ 和 $i+1$ 之间的轴向电导为 $G_{a,i} = \\frac{A}{r_a\\,d_{i,i+1}}$，其中 $d_{i,i+1} = \\frac{\\ell_i+\\ell_{i+1}}{2}$ 是中心到中心的距离。封闭的远端对应于最后一个隔室之后没有轴向电导。电流注入 $I_0$ 仅施加于隔室 1，节点电压 $\\{V_i\\}$ 通过求解得到的线性系统获得。\n- 使用一个包含 $M$ 个隔室的均匀离散化作为高分辨率参考，其中 $M$ 的选择要足够大（您的程序必须在内部设置 $M$）。\n- 通过一个无约束向量对长度 $\\{\\ell_i\\}_{i=1}^N$ 进行参数化，该向量被映射为总和为 $L$ 的正长度，从而优化边界布局。\n- 最终答案必须以指定的输出格式报告最小化 $J$ 的内部边界位置（即不包括 $0$ 和 $L$），单位为米。\n\n输入处理：\n- 程序必须是自包含的，并且不得读取任何输入。它必须使用下面指定的测试套件值，并直接产生输出。\n\n单位：\n- 所有物理量都必须使用其标准的国际单位制（SI）单位。最终输出必须以米为单位表示边界位置。\n\n测试套件：\n- 情况 1（一般情况）：$L=500\\times 10^{-6}$ 米，$r=0.75\\times 10^{-6}$ 米，$r_a=1.5$ 欧姆·米，$g_m(x)=0.01$ 西门子/平方米（常数），$I_0=1\\times 10^{-12}$ 安培，$N=5$ 个隔室。\n- 情况 2（使用最小模型的边界条件覆盖）：$L=500\\times 10^{-6}$ 米，$r=0.75\\times 10^{-6}$ 米，$r_a=1.5$ 欧姆·米，$g_m(x)=0.01$ 西门子/平方米（常数），$I_0=1\\times 10^{-12}$ 安培，$N=1$ 个隔室。\n- 情况 3（非均匀膜）：$L=500\\times 10^{-6}$ 米，$r=0.75\\times 10^{-6}$ 米，$r_a=1.5$ 欧姆·米，$g_m(x)=g_0 + (g_1-g_0)\\frac{x}{L}$ 其中 $g_0=0.005$ 西门子/平方米，$g_1=0.02$ 西门子/平方米（沿电缆线性增加），$I_0=1\\times 10^{-12}$ 安培，$N=8$ 个隔室。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，其本身是一个按从近端到远端排序的内部边界位置（单位：米）列表。例如，三个测试用例的输出应如下所示：$[ [b_{1,1},b_{1,2},\\dots], [\\ ], [b_{3,1},b_{3,2},\\dots] ]$，但您的程序必须输出不带空格的列表。具体来说：“您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，[result1,result2,result3]）。”",
            "solution": "问题陈述已经过分析并被确定为**有效**。它在科学上基于被动电缆理论和计算神经科学的原理，作为一个优化问题是适定的，并且使用了客观、明确的语言和参数进行规定。\n\n### 1. 建模与离散化原理\n\n问题的核心是使用一个包含少量隔室的简化模型来近似由稳态电缆方程控制的树突电缆上的连续电压分布 $V(x)$。连续模型由下式给出：\n$$\n\\frac{A}{r_a}\\frac{d^2 V(x)}{dx^2} - S\\,g_m(x)\\,V(x) = 0\n$$\n其中 $A = \\pi r^2$ 是横截面积，$S = 2\\pi r$ 是单位长度的表面积，$r_a$ 是轴向电阻率，$g_m(x)$ 是膜电导密度。边界条件是在 $x=0$ 处注入电流和在 $x=L$ 处为封闭末端，这在连续模型中分别转化为 $-\\frac{A}{r_a}\\frac{dV}{dx}(0) = I_0$ 和 $\\frac{dV}{dx}(L)=0$。\n\n隔室模型使用有限体积法来近似这个连续系统。电缆被划分为 $N$ 个长度为 $\\{\\ell_i\\}_{i=1}^N$ 的段（隔室）。每个隔室 $i$ 由其中心 $x_i$ 处的一个单一节点表示，电压为 $V_i$。连续属性被集总为离散电导。\n\n- **膜电导（$G_m$）：** 隔室 $i$ 的总膜电导是其中心处的膜电导密度与其表面积的乘积：\n  $$\n  G_{m,i} = g_m(x_i) \\cdot (S \\ell_i)\n  $$\n- **轴向电导（$G_a$）：** 轴向电导连接相邻隔室 $i$ 和 $i+1$ 的中心。它是它们之间轴向电阻的倒数。电阻为 $R_{axial} = r_a \\frac{d}{A}$，其中 $d = (\\ell_i + \\ell_{i+1})/2$ 是中心之间的距离。因此，电导为：\n  $$\n  G_{a,i} = \\frac{A}{r_a \\left(\\frac{\\ell_i+\\ell_{i+1}}{2}\\right)}\n  $$\n\n通过在每个节点 $i$ 应用基尔霍夫电流定律（KCL），该定律指出流出节点的电流总和为零，我们得到一个线性方程组。对于一个普通的内部隔室 $i$（其中 $1  i  N$）：\n$$\n(V_i - V_{i-1})G_{a,i-1} + (V_i - V_{i+1})G_{a,i} + V_i G_{m,i} = 0\n$$\n对于边界隔室：\n- **隔室 1（近端，电流注入）：** 根据规定，注入电流 $I_0$ 被视为流入节点 1 的外部源：\n  $$\n  (V_1 - V_2)G_{a,1} + V_1 G_{m,1} = I_0\n  $$\n- **隔室 N（远端，封闭末端）：** 由于没有隔室 $N+1$，轴向路径被阻断，从而正确地模拟了封闭末端：\n  $$\n  (V_N - V_{N-1})G_{a,N-1} + V_N G_{m,N} = 0\n  $$\n\n这 $N$ 个方程构成一个线性系统 $\\mathbf{G}\\mathbf{V} = \\mathbf{I}$，其中 $\\mathbf{G}$ 是一个 $N \\times N$ 的对称三对角电导矩阵，$\\mathbf{V}$ 是未知隔室电压的向量，$\\mathbf{I}$ 是电流注入向量（其中 $I_1 = I_0$，所有其他元素为 $0$）。这个系统可以被高效地求解以找到电压 $\\{V_i\\}$。\n\n### 2. 优化目标的合理性\n\n目标是最小化以下函数：\n$$\nJ(\\{\\ell_i\\}_{i=1}^N) = \\int_{0}^{L} \\left(\\tilde{V}(x) - V_{\\mathrm{ref}}(x)\\right)^2\\,dx\n$$\n其中 $\\tilde{V}(x)$ 是来自 $N$ 隔室简化模型的分段常数电压分布，而 $V_{\\mathrm{ref}}(x)$ 是来自具有大量隔室（$M \\gg N$）的参考模型的高精度电压分布。\n\n这个目标函数，即积分平方误差，是一个标准且稳健的选择，原因有几点：\n- **$L^2$ 范数：** 它表示误差函数 $\\epsilon(x) = \\tilde{V}(x) - V_{\\mathrm{ref}}(x)$ 的 $L^2$ 范数的平方。最小化此范数是函数逼近理论中一个公认的目标，确保近似函数在整个定义域上“平均地”接近真实函数。\n- **物理相关性：** 对于线性被动系统，电压的平方与功率成正比。最小化积分平方误差类似于最小化系统响应中的总误差能量。对于直流稳态，它确保了静态电压分布（为神经元整合设定基线）被高保真地捕获。\n- **数学性质：** 函数的二次性质会严重惩罚大的偏差，从而迫使优化过程寻找能够避免显著局部不准确性的隔室长度。\n- **可微性：** 目标函数相对于隔室长度（以及优化变量）是光滑且可微的，这使其适用于高效的基于梯度的优化算法。\n\n该积分使用参考模型精细网格上的黎曼和进行数值近似。如果参考模型使用 $M$ 个长度为 $\\Delta x = L/M$ 的均匀隔室，则该积分变为：\n$$\nJ \\approx \\sum_{j=1}^{M} \\left(\\tilde{V}(x_j) - V_{\\mathrm{ref},j}\\right)^2 \\Delta x\n$$\n\n### 3. 优化策略\n\n目标是找到最小化 $J$ 的隔室长度集合 $\\{\\ell_i\\}$，约束条件为对所有 $i$ 都有 $\\ell_i  0$ 且 $\\sum_{i=1}^N \\ell_i = L$。这类约束优化问题可以通过适当的重新参数化转化为无约束问题。\n\n我们引入一个无约束的变量向量 $\\mathbf{y} = \\{y_i\\}_{i=1}^N \\in \\mathbb{R}^N$。然后，我们可以使用 **softmax 函数** 将此向量映射到一组有效的长度 $\\{\\ell_i\\}$：\n$$\n\\ell_i(\\mathbf{y}) = L \\cdot \\frac{e^{y_i}}{\\sum_{j=1}^N e^{y_j}}\n$$\n这种变换巧妙地自动满足了两个约束条件：$\\ell_i$ 总是正数，并且它们的和总是 $L$。现在的优化问题是找到最小化目标函数 $J(\\mathbf{y})$ 的向量 $\\mathbf{y}$。\n\n总体算法如下：\n1.  **生成参考解：** 对于每个测试用例，首先构建并求解一个具有 $M$ 个均匀隔室（例如 $M=1000$）的高分辨率参考模型。这将产生参考电压向量 $\\mathbf{V}_{\\mathrm{ref}}$。\n2.  **定义目标函数：** 创建一个接受无约束向量 $\\mathbf{y}$ 作为输入的 Python 函数。在此函数内部：\n    a. 使用 softmax 变换将 $\\mathbf{y}$ 转换为隔室长度 $\\{\\ell_i\\}$。\n    b. 使用这些长度构建并求解 $N$ 隔室简化模型以获得电压 $\\{V_i\\}$。\n    c. 在与参考模型相同的精细网格上生成分段常数电压分布 $\\tilde{V}(x)$。\n    d. 通过对 $\\tilde{V}$ 和 $V_{\\mathrm{ref}}$ 之间的差值平方求和来计算并返回误差 $J$。\n3.  **执行优化：** 使用数值优化程序，例如 `scipy.optimize.minimize` 提供的 BFGS 算法，找到最小化目标函数的最优参数向量 $\\mathbf{y}_{\\mathrm{opt}}$。使用 $\\mathbf{y}_0 = \\mathbf{0}$ 的初始猜测，这对应于均匀隔室长度的初始配置。\n4.  **提取最终边界：** 找到 $\\mathbf{y}_{\\mathrm{opt}}$ 后，将其转换回最优隔室长度 $\\{\\ell_{i, \\mathrm{opt}}\\}$。然后通过计算这些长度的累积和来计算内部边界位置 $\\{b_k\\}$：\n    $$\n    b_k = \\sum_{i=1}^{k} \\ell_{i, \\mathrm{opt}} \\quad \\text{for } k = 1, \\dots, N-1.\n    $$\n此过程根据指定的误差度量，找到使简化模型最佳地再现详细电压分布的边界布局。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.linalg import solve_banded\nimport math\n\n# Use a high number of compartments for the reference model to approximate the continuous case.\nM_REF = 1000\n\ndef solve_model(lengths, L, r, ra, gm_func, I0):\n    \"\"\"\n    Builds and solves the linear system for a compartmental model.\n\n    Args:\n        lengths (np.ndarray): Array of compartment lengths.\n        L, r, ra, I0 (float): Physical parameters of the cable.\n        gm_func (callable): Function gm(x) for membrane conductance density.\n\n    Returns:\n        np.ndarray: Array of compartment voltages.\n    \"\"\"\n    N = len(lengths)\n    if N == 0:\n        return np.array([])\n    \n    A = math.pi * r**2\n    S = 2 * math.pi * r\n\n    # Calculate compartment centers from lengths\n    boundaries = np.cumsum(lengths)\n    centers = boundaries - lengths / 2.0\n\n    # Membrane conductances\n    Gm = S * gm_func(centers) * lengths\n\n    # Axial conductances\n    if N  1:\n        # Center-to-center distances\n        d_centers = (lengths[:-1] + lengths[1:]) / 2.0\n        Ga = A / (ra * d_centers)\n    else:\n        Ga = np.array([])\n\n    # Construct the tridiagonal conductance matrix G for solve_banded\n    # ab is a 3xN matrix: [upper_diag, main_diag, lower_diag]\n    ab = np.zeros((3, N))\n\n    # Main diagonal\n    if N == 1:\n        ab[1, 0] = Gm[0]\n    else:\n        ab[1, 0] = Ga[0] + Gm[0]\n        ab[1, -1] = Ga[-1] + Gm[-1]\n        ab[1, 1:-1] = Ga[:-1] + Ga[1:] + Gm[1:-1]\n\n    # Off-diagonals\n    if N  1:\n        ab[0, 1:] = -Ga\n        ab[2, :-1] = -Ga\n\n    # Current vector I\n    I = np.zeros(N)\n    I[0] = I0\n\n    # Solve the linear system G*V = I\n    voltages = solve_banded((1, 1), ab, I)\n    return voltages\n\ndef create_objective_function(V_ref, L, r, ra, gm_func, I0, N):\n    \"\"\"\n    Creates the objective function for the optimization.\n    \"\"\"\n    ref_dx = L / M_REF\n    ref_centers = (np.arange(M_REF) + 0.5) * ref_dx\n\n    def objective(y):\n        \"\"\"\n        The function to be minimized.\n        y is the unconstrained parameter vector.\n        \"\"\"\n        # 1. Convert unconstrained y to constrained lengths l via softmax\n        exp_y = np.exp(y - np.max(y)) # a trick for numerical stability\n        lengths = L * exp_y / np.sum(exp_y)\n\n        # 2. Solve the reduced model with these lengths\n        V_reduced = solve_model(lengths, L, r, ra, gm_func, I0)\n\n        # 3. Create the piecewise-constant voltage profile on the fine grid\n        boundaries = np.cumsum(lengths)\n        # Find which compartment each fine grid point belongs to\n        compartment_indices = np.searchsorted(boundaries, ref_centers, side='right')\n        V_tilde = V_reduced[compartment_indices]\n\n        # 4. Calculate the integral squared error\n        error = np.sum((V_tilde - V_ref)**2) * ref_dx\n        return error\n\n    return objective\n\ndef run_case(case_params):\n    \"\"\"\n    Runs a full optimization case.\n    \"\"\"\n    L, r, ra, gm_func, I0, N = case_params\n\n    # Case N=1 has no interior boundaries to optimize\n    if N = 1:\n        return []\n\n    # 1. Generate the high-resolution reference solution\n    ref_lengths = np.full(M_REF, L / M_REF)\n    V_ref = solve_model(ref_lengths, L, r, ra, gm_func, I0)\n\n    # 2. Create the objective function\n    obj_func = create_objective_function(V_ref, L, r, ra, gm_func, I0, N)\n\n    # 3. Run the optimization\n    # Initial guess: uniform lengths (y=0 vector)\n    y0 = np.zeros(N)\n    res = minimize(obj_func, y0, method='BFGS')\n    y_opt = res.x\n\n    # 4. Convert optimal parameters to boundary positions\n    exp_y_opt = np.exp(y_opt - np.max(y_opt))\n    l_opt = L * exp_y_opt / np.sum(exp_y_opt)\n    boundaries = np.cumsum(l_opt)[:-1]\n\n    return boundaries.tolist()\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Constant gm, N=5\n        (500e-6, 0.75e-6, 1.5, lambda x: 0.01, 1e-12, 5),\n        # Case 2: Constant gm, N=1\n        (500e-6, 0.75e-6, 1.5, lambda x: 0.01, 1e-12, 1),\n        # Case 3: Linearly increasing gm, N=8\n        (500e-6, 0.75e-6, 1.5, lambda x: 0.005 + (0.02 - 0.005) * x / 500e-6, 1e-12, 8),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(result)\n\n    # Format output string to be a list of lists, without spaces.\n    str_results = []\n    for r in results:\n        # Use a compact string representation for each list of boundaries.\n        list_str = str(r).replace(\" \", \"\")\n        str_results.append(list_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        }
    ]
}