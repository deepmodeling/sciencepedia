{
    "hands_on_practices": [
        {
            "introduction": "To build and simulate complex dendritic trees, we must first master the fundamental numerical methods that power these models. This practice provides a concrete, step-by-step walkthrough of the core calculation in a compartmental simulation: advancing the system by a single time step using the implicit Euler method. By manually setting up and solving the linear system for a simple three-compartment model, you will gain a foundational understanding of how membrane voltage evolves in response to currents and neighbor interactions. ",
            "id": "4039542",
            "problem": "Consider a passive dendritic cable approximated by three isopotential compartments connected in series, to be simulated in a neuromorphic and brain-inspired computing setting using compartmental modeling. Each compartment has membrane capacitance $C_{\\mathrm{m}}$, leak conductance $g_{\\mathrm{L}}$ to a reversal potential $E_{\\mathrm{L}}$, and is coupled to its nearest neighbor(s) by axial conductance $g_{\\mathrm{a}}$. The ends are sealed, so there are no axial couplings beyond the first and third compartments. Let the following parameters and states be given: $C_{\\mathrm{m}} = 0.2~\\mathrm{nF}$, $g_{\\mathrm{L}} = 0.5~\\mathrm{\\mu S}$, $E_{\\mathrm{L}} = 0~\\mathrm{mV}$, $g_{\\mathrm{a}} = 1.0~\\mathrm{\\mu S}$ (between compartments $1$–$2$ and $2$–$3$), time step $\\Delta t = 0.1~\\mathrm{ms}$, and the membrane voltages at time $t_n$ given by $\\mathbf{V}^n = \\begin{pmatrix} -65 \\\\ -60 \\\\ -70 \\end{pmatrix}~\\mathrm{mV}$. Suppose the externally injected current (per compartment) is applied at the end of the step, i.e., $\\mathbf{I}(t_{n+1}) = \\begin{pmatrix} 0.5 \\\\ 0.0 \\\\ 0.2 \\end{pmatrix}~\\mathrm{nA}$. \n\nStarting from Kirchhoff's current law (KCL) and the passive cable definitions for capacitive, leak, and axial currents, derive the linear system that results from applying the backward (implicit) Euler method to one time step from $t_n$ to $t_{n+1}$, assemble the resulting $3 \\times 3$ system matrix explicitly, and solve for the next-step voltages $\\mathbf{V}^{n+1}$. Express each component of $\\mathbf{V}^{n+1}$ in $\\mathrm{mV}$ and round your final numerical values to four significant figures. The final answer must be given as a single row matrix.",
            "solution": "The problem requires the derivation and solution of a linear system for the membrane voltages of a three-compartment dendritic model using the backward (implicit) Euler method.\n\nFirst, we establish the governing equations for the membrane voltage in each compartment based on Kirchhoff's current law (KCL). For each compartment $i$, the sum of the capacitive current, leak current, and axial currents to neighboring compartments must equal the externally injected current.\nThe current terms are defined as follows:\n- Capacitive current: $I_{\\mathrm{cap}, i} = C_{\\mathrm{m}} \\frac{dV_i}{dt}$\n- Leak current: $I_{\\mathrm{leak}, i} = g_{\\mathrm{L}} (V_i - E_{\\mathrm{L}})$\n- Axial current from compartment $i$ to $j$: $I_{\\mathrm{axial}, ij} = g_{\\mathrm{a}} (V_i - V_j)$\n- Injected current: $I_{i}(t)$\n\nThe dendritic cable is modeled as three compartments in series, with sealed ends. This implies compartment $1$ is only coupled to compartment $2$, compartment $2$ is coupled to $1$ and $3$, and compartment $3$ is only coupled to $2$. The KCL equations for the three compartments are:\n\nFor compartment $1$:\n$$C_{\\mathrm{m}} \\frac{dV_1}{dt} + g_{\\mathrm{L}} (V_1 - E_{\\mathrm{L}}) + g_{\\mathrm{a}} (V_1 - V_2) = I_1(t)$$\n\nFor compartment $2$:\n$$C_{\\mathrm{m}} \\frac{dV_2}{dt} + g_{\\mathrm{L}} (V_2 - E_{\\mathrm{L}}) + g_{\\mathrm{a}} (V_2 - V_1) + g_{\\mathrm{a}} (V_2 - V_3) = I_2(t)$$\n\nFor compartment $3$:\n$$C_{\\mathrm{m}} \\frac{dV_3}{dt} + g_{\\mathrm{L}} (V_3 - E_{\\mathrm{L}}) + g_{\\mathrm{a}} (V_3 - V_2) = I_3(t)$$\n\nNext, we apply the backward (implicit) Euler method to discretize these differential equations. The time derivative is approximated as $\\frac{dV_i}{dt} \\approx \\frac{V_i^{n+1} - V_i^n}{\\Delta t}$, and all other terms are evaluated at the future time step $t_{n+1}$. Let $\\mathbf{V}^{n+1} = (V_1^{n+1}, V_2^{n+1}, V_3^{n+1})^T$ be the vector of unknown voltages at time $t_{n+1}$. With $E_{\\mathrm{L}} = 0~\\mathrm{mV}$, the discretized equations are:\n\nFor compartment $1$:\n$$C_{\\mathrm{m}} \\frac{V_1^{n+1} - V_1^n}{\\Delta t} + g_{\\mathrm{L}} V_1^{n+1} + g_{\\mathrm{a}} (V_1^{n+1} - V_2^{n+1}) = I_1^{n+1}$$\n\nFor compartment $2$:\n$$C_{\\mathrm{m}} \\frac{V_2^{n+1} - V_2^n}{\\Delta t} + g_{\\mathrm{L}} V_2^{n+1} + g_{\\mathrm{a}} (V_2^{n+1} - V_1^{n+1}) + g_{\\mathrm{a}} (V_2^{n+1} - V_3^{n+1}) = I_2^{n+1}$$\n\nFor compartment $3$:\n$$C_{\\mathrm{m}} \\frac{V_3^{n+1} - V_3^n}{\\Delta t} + g_{\\mathrm{L}} V_3^{n+1} + g_{\\mathrm{a}} (V_3^{n+1} - V_2^{n+1}) = I_3^{n+1}$$\n\nTo form a linear system of the form $A \\mathbf{V}^{n+1} = \\mathbf{b}$, we rearrange the equations, grouping all terms containing $\\mathbf{V}^{n+1}$ on the left-hand side (LHS) and all known quantities on the right-hand side (RHS).\n\nRearranging for $V_1^{n+1}$, $V_2^{n+1}$, and $V_3^{n+1}$:\n$$ \\left(\\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + g_{\\mathrm{a}}\\right) V_1^{n+1} - g_{\\mathrm{a}} V_2^{n+1} = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_1^n + I_1^{n+1} $$\n$$ -g_{\\mathrm{a}} V_1^{n+1} + \\left(\\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + 2g_{\\mathrm{a}}\\right) V_2^{n+1} - g_{\\mathrm{a}} V_3^{n+1} = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_2^n + I_2^{n+1} $$\n$$ -g_{\\mathrm{a}} V_2^{n+1} + \\left(\\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + g_{\\mathrm{a}}\\right) V_3^{n+1} = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_3^n + I_3^{n+1} $$\n\nThe linear system $A \\mathbf{V}^{n+1} = \\mathbf{b}$ has the system matrix $A$ and vector $\\mathbf{b}$ defined as:\n$$ A = \\begin{pmatrix}\n\\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + g_{\\mathrm{a}} & -g_{\\mathrm{a}} & 0 \\\\\n-g_{\\mathrm{a}} & \\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + 2g_{\\mathrm{a}} & -g_{\\mathrm{a}} \\\\\n0 & -g_{\\mathrm{a}} & \\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + g_{\\mathrm{a}}\n\\end{pmatrix} $$\n$$ \\mathbf{b} = \\begin{pmatrix}\n\\frac{C_{\\mathrm{m}}}{\\Delta t} V_1^n + I_1^{n+1} \\\\\n\\frac{C_{\\mathrm{m}}}{\\Delta t} V_2^n + I_2^{n+1} \\\\\n\\frac{C_{\\mathrm{m}}}{\\Delta t} V_3^n + I_3^{n+1}\n\\end{pmatrix} $$\n\nNow, we substitute the given numerical values. The units are consistent if we use $C_{\\mathrm{m}}$ in $\\mathrm{nF}$, $g_{\\mathrm{L}}$ and $g_{\\mathrm{a}}$ in $\\mathrm{\\mu S}$, $V$ in $\\mathrm{mV}$, $\\Delta t$ in $\\mathrm{ms}$, and $I$ in $\\mathrm{nA}$.\nThe parameters are: $C_{\\mathrm{m}} = 0.2~\\mathrm{nF}$, $g_{\\mathrm{L}} = 0.5~\\mathrm{\\mu S}$, $g_{\\mathrm{a}} = 1.0~\\mathrm{\\mu S}$, $\\Delta t = 0.1~\\mathrm{ms}$.\nThe term $\\frac{C_{\\mathrm{m}}}{\\Delta t} = \\frac{0.2~\\mathrm{nF}}{0.1~\\mathrm{ms}} = 2.0~\\frac{\\mathrm{nF}}{\\mathrm{ms}} = 2.0~\\mathrm{\\mu S}$.\n\nWe can now assemble the $3 \\times 3$ system matrix $A$ explicitly:\nThe diagonal entries are:\n$A_{11} = A_{33} = \\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + g_{\\mathrm{a}} = 2.0 + 0.5 + 1.0 = 3.5~\\mathrm{\\mu S}$\n$A_{22} = \\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + 2g_{\\mathrm{a}} = 2.0 + 0.5 + 2(1.0) = 4.5~\\mathrm{\\mu S}$\nThe off-diagonal entries are:\n$A_{12} = A_{21} = A_{23} = A_{32} = -g_{\\mathrm{a}} = -1.0~\\mathrm{\\mu S}$\nSo, the system matrix is:\n$$ A = \\begin{pmatrix} 3.5 & -1.0 & 0 \\\\ -1.0 & 4.5 & -1.0 \\\\ 0 & -1.0 & 3.5 \\end{pmatrix}~\\mathrm{\\mu S} $$\n\nNext, we assemble the vector $\\mathbf{b}$ using $\\mathbf{V}^n = \\begin{pmatrix} -65 \\\\ -60 \\\\ -70 \\end{pmatrix}~\\mathrm{mV}$ and $\\mathbf{I}^{n+1} = \\begin{pmatrix} 0.5 \\\\ 0.0 \\\\ 0.2 \\end{pmatrix}~\\mathrm{nA}$.\n$b_1 = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_1^n + I_1^{n+1} = (2.0)(-65) + 0.5 = -130 + 0.5 = -129.5~\\mathrm{nA}$\n$b_2 = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_2^n + I_2^{n+1} = (2.0)(-60) + 0.0 = -120 + 0.0 = -120.0~\\mathrm{nA}$\n$b_3 = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_3^n + I_3^{n+1} = (2.0)(-70) + 0.2 = -140 + 0.2 = -139.8~\\mathrm{nA}$\nSo, the RHS vector is:\n$$ \\mathbf{b} = \\begin{pmatrix} -129.5 \\\\ -120.0 \\\\ -139.8 \\end{pmatrix}~\\mathrm{nA} $$\n\nWe now solve the linear system $A \\mathbf{V}^{n+1} = \\mathbf{b}$ for $\\mathbf{V}^{n+1}$:\n$$ \\begin{pmatrix} 3.5 & -1.0 & 0 \\\\ -1.0 & 4.5 & -1.0 \\\\ 0 & -1.0 & 3.5 \\end{pmatrix} \\begin{pmatrix} V_1^{n+1} \\\\ V_2^{n+1} \\\\ V_3^{n+1} \\end{pmatrix} = \\begin{pmatrix} -129.5 \\\\ -120.0 \\\\ -139.8 \\end{pmatrix} $$\nThis corresponds to the following set of equations:\n1) $3.5 V_1^{n+1} - V_2^{n+1} = -129.5$\n2) $-V_1^{n+1} + 4.5 V_2^{n+1} - V_3^{n+1} = -120.0$\n3) $-V_2^{n+1} + 3.5 V_3^{n+1} = -139.8$\n\nFrom equation (1), we express $V_1^{n+1}$ in terms of $V_2^{n+1}$: $V_1^{n+1} = \\frac{V_2^{n+1} - 129.5}{3.5}$.\nFrom equation (3), we express $V_3^{n+1}$ in terms of $V_2^{n+1}$: $V_3^{n+1} = \\frac{V_2^{n+1} - 139.8}{3.5}$.\nSubstituting these into equation (2):\n$$ -\\left(\\frac{V_2^{n+1} - 129.5}{3.5}\\right) + 4.5 V_2^{n+1} - \\left(\\frac{V_2^{n+1} - 139.8}{3.5}\\right) = -120.0 $$\nMultiplying the entire equation by $3.5$:\n$$ -(V_2^{n+1} - 129.5) + (4.5 \\times 3.5) V_2^{n+1} - (V_2^{n+1} - 139.8) = -120.0 \\times 3.5 $$\n$$ -V_2^{n+1} + 129.5 + 15.75 V_2^{n+1} - V_2^{n+1} + 139.8 = -420 $$\n$$ (15.75 - 1 - 1) V_2^{n+1} + (129.5 + 139.8) = -420 $$\n$$ 13.75 V_2^{n+1} + 269.3 = -420 $$\n$$ 13.75 V_2^{n+1} = -420 - 269.3 = -689.3 $$\n$$ V_2^{n+1} = \\frac{-689.3}{13.75} \\approx -50.130909~\\mathrm{mV} $$\nNow we find $V_1^{n+1}$ and $V_3^{n+1}$:\n$$ V_1^{n+1} = \\frac{-50.130909 - 129.5}{3.5} = \\frac{-179.630909}{3.5} \\approx -51.323117~\\mathrm{mV} $$\n$$ V_3^{n+1} = \\frac{-50.130909 - 139.8}{3.5} = \\frac{-189.930909}{3.5} \\approx -54.265974~\\mathrm{mV} $$\n\nFinally, we round the numerical values to four significant figures as required.\n$V_1^{n+1} \\approx -51.32~\\mathrm{mV}$\n$V_2^{n+1} \\approx -50.13~\\mathrm{mV}$\n$V_3^{n+1} \\approx -54.27~\\mathrm{mV}$",
            "answer": "$$ \\boxed{ \\begin{pmatrix} -51.32 & -50.13 & -54.27 \\end{pmatrix} } $$"
        },
        {
            "introduction": "A key goal of compartmental modeling is to create structures that are not only anatomically plausible but also functionally efficient. This hands-on exercise connects the abstract structure of a model to a foundational principle of dendritic design, Rall's $d^{3/2}$ power rule, which governs efficient current flow at bifurcations. You will write a program to analyze dendritic morphologies and quantify their adherence to this rule, learning how to validate a model's structure against established biophysical theory. ",
            "id": "3974766",
            "problem": "You are given a set of rooted trees representing morphological reconstructions of dendritic arbors. Each node corresponds to a short cylindrical compartment with a specified diameter measured in micrometers. The trees are represented as lists of tuples $(\\text{node\\_id}, \\text{parent\\_id}, d)$, where $d$ is the compartment diameter in $\\mu\\text{m}$, $\\text{parent\\_id}=-1$ denotes the root, and each non-root node has exactly one parent. A branching point (bifurcation) is any node with two or more children.\n\nThe aim is to test the applicability of Rall’s rule across each tree by computing, for every branching point, the deviation between the parent compartment’s $d^{3/2}$ and the sum of the children compartments’ $d^{3/2}$. Specifically, define for a branching point with parent diameter $d_p$ and child diameters $\\{d_k\\}_{k=1}^m$ the sums $S_{\\text{parent}} = d_p^{3/2}$ and $S_{\\text{kids}} = \\sum_{k=1}^m d_k^{3/2}$, and the relative deviation\n$$\n\\delta = \\frac{S_{\\text{kids}} - S_{\\text{parent}}}{S_{\\text{parent}}}.\n$$\nAcross all branching points in a given tree, compute three metrics: the mean absolute relative deviation $\\overline{|\\delta|}$, the maximum absolute relative deviation $\\max|\\delta|$, and the fraction $f_\\tau$ of branching points whose absolute relative deviation is at most a tolerance $\\tau$. The tolerance is $\\tau=0.05$ (a decimal), and all deviation metrics are dimensionless. If a tree has no branching points, define $\\overline{|\\delta|}=0$, $\\max|\\delta|=0$, and $f_\\tau=1$.\n\nThe foundational base for this problem is linear cable theory for neuronal dendrites under quasi-static conditions, with the well-tested observation that the input conductance of a semi-infinite cylindrical cable scales with $d^{3/2}$, leading to the branching conductance matching condition at a node. The derivation of this scaling and its application are requested in the solution.\n\nYour task is to implement a program that, for the provided test suite of five trees, computes the three metrics described above for each tree and outputs them in a single aggregate format. Diameters are provided in $\\mu\\text{m}$; the deviations are dimensionless. There are no angles and no percentage signs are to be used.\n\nTest suite (each tree is a list of $(\\text{node\\_id}, \\text{parent\\_id}, d)$ tuples; diameters $d$ are in $\\mu\\text{m}$):\n\n- Tree A (balanced binary with near-Rall compliance at both branching points):\n    - $(0,-1,2.0736)$\n    - $(1,0,1.2)$\n    - $(2,0,1.4)$\n    - $(3,1,0.7)$\n    - $(4,1,0.81)$\n\n- Tree B (same topology as Tree A, with a deliberate deviation at one branch):\n    - $(0,-1,2.0736)$\n    - $(1,0,1.2)$\n    - $(2,0,1.4)$\n    - $(3,1,0.7)$\n    - $(4,1,0.9)$\n\n- Tree C (root trifurcation with near-Rall compliance, and a deeper bifurcation deviating):\n    - $(0,-1,2.0850)$\n    - $(1,0,1.1)$\n    - $(2,0,1.0)$\n    - $(3,0,0.9)$\n    - $(4,1,0.7)$\n    - $(5,1,0.5)$\n\n- Tree D (single chain, no branching points):\n    - $(0,-1,1.2)$\n    - $(1,0,1.1)$\n    - $(2,1,1.0)$\n    - $(3,2,0.9)$\n\n- Tree E (binary root with one very small child to test numerical stability, deeper bifurcation deviating):\n    - $(0,-1,1.0)$\n    - $(1,0,0.2)$\n    - $(2,0,0.945)$\n    - $(3,2,0.4)$\n    - $(4,2,0.5)$\n\nYour program should produce a single line of output containing the results for the five trees as a comma-separated list of lists, where each inner list has the three metrics in the order $[\\overline{|\\delta|}, \\max|\\delta|, f_\\tau]$. For example, the output should look like $[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3],[x_4,y_4,z_4],[x_5,y_5,z_5]]$, with each $x_i$, $y_i$, and $z_i$ a floating-point number. No other output text is permitted.",
            "solution": "The problem requires an analysis of dendritic tree morphology based on Rall's branching rule, a principle derived from linear cable theory. Before presenting the computational method, it is imperative to first establish the theoretical foundation, as requested.\n\n**Theoretical Foundation: Derivation of Rall's $3/2$ Power Rule**\n\nThe basis for Rall's rule is found in the behavior of electrical current in passive dendritic cables under steady-state (DC) conditions. We model a segment of a dendrite as a uniform cylinder. The voltage $V(x)$ along the length $x$ of this cable is described by the steady-state cable equation:\n$$\n\\lambda^2 \\frac{d^2V}{dx^2} - V = 0\n$$\nHere, $\\lambda$ is the space constant of the cable, defined as $\\lambda = \\sqrt{r_m/r_a}$, where $r_m$ is the membrane resistance for a unit length of the cylinder and $r_a$ is the axial resistance per unit length.\n\nThese resistances depend on the geometry of the cylinder and the intrinsic properties of the neuron. Let $d$ be the diameter of the cylindrical compartment, $R_m$ be the specific membrane resistance (in $\\Omega \\cdot \\text{m}^2$), and $R_i$ be the specific intracellular (axial) resistivity (in $\\Omega \\cdot \\text{m}$).\n\nThe membrane resistance per unit length, $r_m$, is inversely proportional to the membrane surface area per unit length (the perimeter, $\\pi d$):\n$$\nr_m = \\frac{R_m}{\\pi d}\n$$\nThe axial resistance per unit length, $r_a$, is inversely proportional to the cross-sectional area of the cylinder ($A = \\pi(d/2)^2$):\n$$\nr_a = \\frac{R_i}{A} = \\frac{R_i}{\\pi (d/2)^2} = \\frac{4 R_i}{\\pi d^2}\n$$\nSubstituting these into the definition of the space constant $\\lambda$:\n$$\n\\lambda = \\sqrt{\\frac{r_m}{r_a}} = \\sqrt{\\frac{R_m / (\\pi d)}{4 R_i / (\\pi d^2)}} = \\sqrt{\\frac{R_m d}{4 R_i}}\n$$\nAssuming uniform material properties ($R_m$ and $R_i$ are constant), the space constant scales with the square root of the diameter: $\\lambda \\propto \\sqrt{d}$.\n\nNext, we consider the input conductance, $G_{in}$, of a dendritic branch. For a semi-infinite cable (a valid approximation for electrically long branches), the input resistance is $R_{in} = \\sqrt{r_m r_a}$. The input conductance is its reciprocal:\n$$\nG_{in} = \\frac{1}{R_{in}} = \\frac{1}{\\sqrt{r_m r_a}}\n$$\nWe can also express $R_{in}$ using $\\lambda$ and $r_a$ as $R_{in} = \\lambda r_a$. Thus:\n$$\nG_{in} = \\frac{1}{\\lambda r_a}\n$$\nNow, we examine how $G_{in}$ scales with diameter $d$. We have established that $\\lambda \\propto \\sqrt{d}$ and $r_a \\propto 1/d^2$. Therefore:\n$$\nG_{in} \\propto \\frac{1}{(\\sqrt{d}) (1/d^2)} = \\frac{d^2}{\\sqrt{d}} = d^{3/2}\n$$\nThis derivation establishes that the input conductance of a semi-infinite cable scales with its diameter to the power of $3/2$.\n\nWilfrid Rall's insight was that for efficient signal propagation without impedance mismatch, the conductance looking into a parent branch should be equal to the sum of the conductances of its daughter branches. At a branching point with parent diameter $d_p$ and $m$ child branches with diameters $\\{d_k\\}_{k=1}^m$, this condition is:\n$$\nG_{in, \\text{parent}} = \\sum_{k=1}^m G_{in, \\text{child}_k}\n$$\nUsing the derived scaling relationship, and letting $C$ be the constant of proportionality, we get:\n$$\nC \\cdot d_p^{3/2} = \\sum_{k=1}^m C \\cdot d_k^{3/2}\n$$\nThe constant $C$ cancels, yielding Rall's celebrated branching rule:\n$$\nd_p^{3/2} = \\sum_{k=1}^m d_k^{3/2}\n$$\n**Computational Strategy**\n\nThe problem requires us to quantify the deviation from this ideal rule for a set of given dendritic trees. The algorithm to achieve this for each tree is as follows:\n\n1.  **Data Structuring**: The input format, a list of $(\\text{node\\_id}, \\text{parent\\_id}, d)$ tuples, is an edge list. This needs to be parsed into a more computationally convenient structure. Two dictionaries are optimal:\n    *   A dictionary mapping each `node_id` to its diameter $d$.\n    *   A dictionary mapping each parent `node_id` to a list of its children's `node_id`s. This directly represents the tree hierarchy.\n\n2.  **Identification of Branching Points**: A branching point is defined as a node with two or more children. By iterating through the parent-to-children dictionary created in the previous step, all nodes that are keys to lists of length $\\ge 2$ are identified as branching points.\n\n3.  **Deviation Calculation**: For each identified branching point $p$:\n    *   Retrieve the parent diameter $d_p$ and the set of child diameters $\\{d_k\\}$.\n    *   Calculate the parent sum $S_{\\text{parent}} = d_p^{3/2}$.\n    *   Calculate the children sum $S_{\\text{kids}} = \\sum_{k} d_k^{3/2}$.\n    *   Compute the relative deviation $\\delta = (S_{\\text{kids}} - S_{\\text{parent}}) / S_{\\text{parent}}$. Note that for any $d_p > 0$, $S_{\\text{parent}}$ is also greater than $0$, precluding division by zero. All diameters in the test suite are positive.\n    *   Collect all computed $\\delta$ values for the tree into a list.\n\n4.  **Metric Computation**:\n    *   If the tree contains no branching points, the list of deviations will be empty. As per the problem definition, the metrics are defined as $\\overline{|\\delta|} = 0$, $\\max|\\delta| = 0$, and $f_\\tau = 1$.\n    *   If branching points exist, the following metrics are computed from the list of $\\delta$ values:\n        *   **Mean Absolute Relative Deviation, $\\overline{|\\delta|}$**: The arithmetic mean of the absolute values of all computed deviations.\n        *   **Maximum Absolute Relative Deviation, $\\max|\\delta|$**: The maximum value among the absolute values of all computed deviations.\n        *   **Fraction of Compliant Branches, $f_\\tau$**: The fraction of branching points for which $|\\delta| \\le \\tau$, where the tolerance $\\tau$ is given as $0.05$. This is calculated as (number of branches with $|\\delta| \\le \\tau$) / (total number of branches).\n\nThis procedure is applied independently to each of the five provided test trees to generate the final results. The implementation will use the `numpy` library for efficient numerical operations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates dendritic trees against Rall's rule and computes deviation metrics.\n    \"\"\"\n    # Test suite of five dendritic trees.\n    # Each tree is a list of (node_id, parent_id, diameter) tuples.\n    test_cases = [\n        # Tree A (balanced binary, near-Rall compliance)\n        [\n            (0, -1, 2.0736), (1, 0, 1.2), (2, 0, 1.4), (3, 1, 0.7), (4, 1, 0.81)\n        ],\n        # Tree B (same as A, one branch deviating)\n        [\n            (0, -1, 2.0736), (1, 0, 1.2), (2, 0, 1.4), (3, 1, 0.7), (4, 1, 0.9)\n        ],\n        # Tree C (trifurcation, deeper bifurcation deviating)\n        [\n            (0, -1, 2.0850), (1, 0, 1.1), (2, 0, 1.0), (3, 0, 0.9), (4, 1, 0.7), (5, 1, 0.5)\n        ],\n        # Tree D (single chain, no branching points)\n        [\n            (0, -1, 1.2), (1, 0, 1.1), (2, 1, 1.0), (3, 2, 0.9)\n        ],\n        # Tree E (binary root, deeper bifurcation deviating)\n        [\n            (0, -1, 1.0), (1, 0, 0.2), (2, 0, 0.945), (3, 2, 0.4), (4, 2, 0.5)\n        ]\n    ]\n\n    # Tolerance for calculating the fraction of compliant branches.\n    tau = 0.05\n    all_results = []\n\n    for tree_data in test_cases:\n        if not tree_data:\n            # Handle empty tree case if necessary, though not in test suite.\n            all_results.append([0.0, 0.0, 1.0])\n            continue\n            \n        diameters = {node_id: d for node_id, _, d in tree_data}\n        children = {}\n        for node_id, parent_id, _ in tree_data:\n            if parent_id != -1:\n                if parent_id not in children:\n                    children[parent_id] = []\n                children[parent_id].append(node_id)\n        \n        branching_points = [\n            node_id for node_id, child_list in children.items()\n            if len(child_list) >= 2\n        ]\n\n        if not branching_points:\n            # Per problem spec, if no branching points, define metrics as follows.\n            mean_abs_dev = 0.0\n            max_abs_dev = 0.0\n            f_tau = 1.0\n            all_results.append([mean_abs_dev, max_abs_dev, f_tau])\n            continue\n\n        deviations = []\n        for bp_id in branching_points:\n            # Get parent diameter and calculate S_parent = d_p^(3/2)\n            d_p = diameters[bp_id]\n            # Handle d_p=0 case to prevent division by zero, though not in test data.\n            if d_p == 0:\n                # If parent diameter is 0, deviation is ill-defined.\n                # A sum of positive child diams would yield infinite deviation.\n                # Assuming d_p > 0 based on context. Let's formalize a behavior if needed.\n                # If child diameters are also 0, deviation could be 0. We'll assume d_p > 0.\n                s_parent = 0.0\n            else:\n                s_parent = np.power(d_p, 1.5)\n\n            # Get child diameters and calculate S_kids = sum(d_k^(3/2))\n            child_ids = children[bp_id]\n            child_diams = [diameters[cid] for cid in child_ids]\n            s_kids = np.sum(np.power(child_diams, 1.5))\n            \n            # Calculate relative deviation\n            if s_parent == 0:\n                # Can't compute relative deviation if parent sum is zero.\n                # If kids_sum is also 0, dev is 0. If kids_sum > 0, dev is inf.\n                # This case is not expected in the problem.\n                delta = np.inf if s_kids > 0 else 0.0\n            else:\n                delta = (s_kids - s_parent) / s_parent\n            \n            deviations.append(delta)\n\n        # Calculate metrics from the list of deviations\n        abs_deviations = np.abs(np.array(deviations))\n        mean_abs_dev = np.mean(abs_deviations)\n        max_abs_dev = np.max(abs_deviations)\n        \n        compliant_branches = np.sum(abs_deviations <= tau)\n        f_tau = compliant_branches / len(branching_points)\n        \n        all_results.append([mean_abs_dev, max_abs_dev, f_tau])\n\n    # Format output to match specification: [[x1,y1,z1],[x2,y2,z2],...]\n    # without spaces inside the inner lists.\n    output_str = f\"[{','.join(['[' + ','.join(map(str, res)) + ']' for res in all_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "While passive models provide an essential baseline, the true computational power of dendrites lies in their rich repertoire of active, nonlinear properties. This exercise challenges you to move beyond linear approximations and explore the conditions under which they fail, such as the generation of local dendritic spikes or plateau potentials. By learning to identify these nonlinear regimes and the diagnostics to detect them, you will develop a more sophisticated and realistic view of dendritic integration. ",
            "id": "4039537",
            "problem": "Consider a dendritic tree modeled by a multi-compartment approximation to the one-dimensional cable equation with distributed active conductances. Let the membrane voltage be $V(x,t)$ along a branch coordinate $x$, with specific membrane capacitance $c_m$, axial resistivity $r_a$, and passive leak conductance $g_L$ with reversal potential $E_L$. The governing equation for a branch with additional voltage-gated conductances $\\{g_k(V,t)\\}$ is\n$$\nc_m \\frac{\\partial V}{\\partial t} \\;=\\; \\frac{\\partial}{\\partial x}\\!\\left(\\frac{1}{r_a}\\frac{\\partial V}{\\partial x}\\right) \\;-\\; g_L \\big(V - E_L\\big) \\;-\\; \\sum_k g_k(V,t)\\,\\big(V - E_k\\big) \\;+\\; I_{\\mathrm{ext}}(x,t),\n$$\nwith gating variables obeying kinetics of the form\n$$\n\\frac{\\mathrm{d}m_k}{\\mathrm{d}t} \\;=\\; \\alpha_k(V)\\,\\big(1 - m_k\\big) \\;-\\; \\beta_k(V)\\,m_k,\n$$\nand $g_k(V,t)$ being functions of $\\{m_k\\}$ and $V$. In model reduction, one replaces a fine-grained discretization by a coarser set of compartments or by an equivalent cable that preserves key transfer properties. A common justification is linearization near a baseline voltage $V_0$, which yields a linear time-invariant (LTI) operator with impulse response or Green’s function $G(x,y,t)$ and transfer impedance $Z_{ij}(\\omega)$ between sites $x_i$ and $x_j$. Under this LTI approximation, superposition and homogeneity hold: if $I_{\\mathrm{ext}}$ is scaled by a factor $\\alpha$, then $V$ scales by $\\alpha$, and responses to multiple inputs add.\n\nHowever, in the presence of strong nonlinearities such as local regenerative events (e.g., dendritic spikes), the above linearization may cease to be valid, and reduced models that assume linearity or weak nonlinearity can fail to reproduce the true dynamics. Identify conditions under which such model reduction fails due to strong nonlinearities, and propose diagnostics that can detect these cases empirically or in simulation.\n\nSelect all options that correctly identify both (i) a condition that leads to failure of linear-reduction assumptions for dendritic trees and (ii) a scientifically sound diagnostic that can reveal the breakdown.\n\nA. Condition: A distal branch contains a high density of voltage-gated sodium conductance that supports all-or-none local spikes once the local voltage crosses a threshold, creating a regenerative current source that is largely confined to that branch. Diagnostic: Apply sinusoidal current at the branch at frequency $\\omega$ with amplitude $I_0$ and test the output at the soma across amplitudes; the appearance of significant second harmonic components at $2\\omega$ and amplitude-dependent transfer impedance $Z(\\omega)$ indicates nonlinearity inconsistent with linear reduction.\n\nB. Condition: Active conductances are heterogeneously clustered at a branch point, creating a state-dependent impedance mismatch that violates equivalent-cylinder assumptions and breaks approximate reciprocity at higher amplitudes. Diagnostic: Measure transfer impedance $Z_{ij}(\\omega)$ from site $i$ to $j$ and $Z_{ji}(\\omega)$ from $j$ to $i$ at low versus high stimulus amplitudes; amplitude-dependent asymmetry in $Z_{ij}$ versus $Z_{ji}$ reveals nonlinearity that invalidates linear reduction.\n\nC. Condition: Strong N-methyl-D-aspartate (NMDA) receptor activation produces voltage-dependent conductance with slow kinetics and magnesium block relief, yielding local plateau potentials and bistability in some dendritic segments. Diagnostic: Use a current ramp protocol at the affected branch and measure local $V$ versus injected current $I$ during increasing and decreasing ramps; hysteresis (different trajectories for up- and down-ramps) demonstrates bistability incompatible with linear-reduction assumptions.\n\nD. Condition: The dendritic tree is purely passive with small electrotonic length and homogeneous parameters. Diagnostic: Construct Bode plots of the soma response to sinusoidal inputs at small and large amplitudes; identical magnitude and phase across amplitudes indicate failure of the reduction due to hidden nonlinearity.\n\nE. Condition: Local high-threshold calcium channels in a thin branch support localized calcium spikes that weakly backpropagate to the soma and produce sharp local changes in effective input impedance. Diagnostic: Perform a superposition test by measuring soma voltage for two synaptic inputs delivered separately, $V(I_1)$ and $V(I_2)$, and together, $V(I_1 + I_2)$; non-additivity, i.e., $V(I_1 + I_2) \\neq V(I_1) + V(I_2)$, reveals nonlinear interaction that invalidates linear-reduction assumptions.",
            "solution": "The problem asks to identify pairs of (i) a condition leading to the failure of linear model reduction for dendritic trees and (ii) a scientifically sound diagnostic for detecting this failure. A linear time-invariant (LTI) model reduction is typically based on linearization of the neuron's dynamics around a steady-state or baseline voltage. The validity of such a reduction rests on the principles of linearity, namely superposition and homogeneity. The response of an LTI system to a sum of inputs is the sum of the individual responses (superposition), and scaling the input by a factor scales the output by the same factor (homogeneity). Strong nonlinearities, such as those introduced by voltage-gated ion channels, violate these principles, making LTI approximations invalid. We will evaluate each option based on whether the stated condition represents a genuine source of strong nonlinearity and whether the proposed diagnostic is a valid method for its detection.\n\nThe governing equation for the membrane voltage $V(x,t)$ is given as:\n$$\nc_m \\frac{\\partial V}{\\partial t} \\;=\\; \\frac{\\partial}{\\partial x}\\!\\left(\\frac{1}{r_a}\\frac{\\partial V}{\\partial x}\\right) \\;-\\; g_L \\big(V - E_L\\big) \\;-\\; \\sum_k g_k(V,t)\\,\\big(V - E_k\\big) \\;+\\; I_{\\mathrm{ext}}(x,t)\n$$\nLinearization is performed for small perturbations around a steady voltage $V_0$. The nonlinearities arise primarily from the voltage-dependent terms $g_k(V,t)$, which are functions of gating variables $\\{m_k\\}$ that themselves depend on voltage $V$. Strong nonlinearities occur when the voltage deviations are large enough to significantly engage these conductances, leading to phenomena like spikes, plateaus, or bistability.\n\n**A. Option-by-Option Analysis**\n\n**Option A:**\n*   **Condition:** A high density of voltage-gated sodium channels supporting all-or-none local spikes. This describes a classic threshold phenomenon. Below the threshold, the response is small. Above the threshold, a large, stereotyped regenerative event (a sodium spike) is triggered. This response is not proportional to the input stimulus magnitude, which is a direct violation of the homogeneity principle of linear systems ($f(\\alpha x) \\neq \\alpha f(x)$). Therefore, this is a valid condition for the failure of a linear model.\n*   **Diagnostic:** Applying a sinusoidal input current $I(t) = I_0 \\sin(\\omega t)$ to a linear system will produce a sinusoidal voltage output $V(t)$ at the same frequency $\\omega$, expressible as $V(\\omega) = Z(\\omega) I(\\omega)$, where the transfer impedance $Z(\\omega)$ is independent of the input amplitude $I_0$. If the system is nonlinear, the output may contain power at harmonic frequencies ($2\\omega$, $3\\omega$, etc.). The appearance of a significant second harmonic component at $2\\omega$ is a clear signature of nonlinearity. Furthermore, if the system's response properties, such as the calculated transfer impedance $Z(\\omega) = V(\\omega)/I(\\omega)$, change with the input amplitude $I_0$, it also proves that the system is not linear. Both proposed diagnostics are standard and robust methods for detecting nonlinearity in system identification.\n*   **Verdict:** Both the condition and the diagnostic are scientifically sound and correctly linked. This option is **Correct**.\n\n**Option B:**\n*   **Condition:** Heterogeneous clustering of active conductances at a branch point creating a state-dependent (voltage-dependent) impedance. This means the electrical properties of the branch point change depending on the local voltage, a hallmark of nonlinearity. For a linear passive network, the reciprocity theorem states that the transfer impedance is symmetric: $Z_{ij}(\\omega) = Z_{ji}(\\omega)$, where $Z_{ij}$ is the voltage response at location $j$ to a current injection at location $i$. Active, voltage-dependent conductances can break this symmetry. A large stimulus at site $i$ may activate channels at the branch point differently than a large stimulus at site $j$, making the signal transfer non-reciprocal.\n*   **Diagnostic:** Measuring $Z_{ij}(\\omega)$ and $Z_{ji}(\\omega)$ is the direct way to test reciprocity. In the linear regime (low stimulus amplitudes), one would expect $Z_{ij}(\\omega) \\approx Z_{ji}(\\omega)$. If, at high stimulus amplitudes, a significant, amplitude-dependent asymmetry develops such that $Z_{ij}(\\omega) \\neq Z_{ji}(\\omega)$, it demonstrates the engagement of nonlinear elements in the circuit. This is a valid and sophisticated diagnostic for amplitude-dependent nonlinearity.\n*   **Verdict:** The condition identifies a valid source of nonlinearity, and the diagnostic is a sound method for its detection. This option is **Correct**.\n\n**Option C:**\n*   **Condition:** NMDA receptor activation leading to plateau potentials and bistability. The voltage-dependent Mg$^{2+}$ block of NMDA receptors can create a region of negative slope resistance in the current-voltage ($I-V$) relationship of a dendrite. This can support bistability, where for a given range of input currents, the membrane can exist in two different stable voltage states (a \"down\" state and a plateau \"up\" state). A system with multiple stable states for the same input is fundamentally nonlinear; a linear system has only one unique steady-state solution for a given constant input.\n*   **Diagnostic:** Hysteresis is the defining characteristic of bistability. It is tested by applying a slowly changing input (like a current ramp) that increases and then decreases. In a bistable system, the output (voltage $V$) will follow one path as the input ($I$) increases and a different path as the input decreases, tracing a loop in the $V-I$ plane. The existence of such a hysteresis loop is irrefutable proof of bistability and, therefore, of strong nonlinearity that invalidates a simple LTI model.\n*   **Verdict:** The condition is a well-known mechanism for strong dendritic nonlinearity, and the diagnostic is the canonical experimental/computational test for it. This option is **Correct**.\n\n**Option D:**\n*   **Condition:** A purely passive dendritic tree with small electrotonic length and homogeneous parameters. A purely passive system, by definition, lacks voltage-gated conductances (the sum over $k$ in the governing equation is zero). The resulting equation is linear. A system described by a linear equation is the ideal case where a linear model is accurate and reduction based on linearization is perfectly valid, not where it fails. The condition is, therefore, contradictory to the premise of the question.\n*   **Diagnostic:** The diagnostic suggests that if Bode plots (magnitude and phase responses) are identical for small and large amplitudes, it indicates a *failure* of the reduction due to *hidden nonlinearity*. This logic is flawed. In a linear system, the transfer function, and thus the Bode plot, is independent of the input signal's amplitude. Identical plots across amplitudes are evidence *for* linearity, confirming that a linear model is appropriate. The interpretation of the diagnostic result is incorrect.\n*   **Verdict:** The condition describes a linear system, not one where linear reduction fails. The diagnostic's conclusion is factually incorrect. This option is **Incorrect**.\n\n**Option E:**\n*   **Condition:** Localized calcium spikes supported by high-threshold calcium channels. Similar to the sodium spikes in option A, calcium spikes are regenerative, all-or-none events that are triggered when the voltage crosses a high threshold. This represents a strong nonlinearity, violating the homogeneity principle.\n*   **Diagnostic:** The proposed test is a direct verification of the superposition principle, which is a definitional property of linear systems. The principle states that for any two inputs $I_1$ and $I_2$, the response to their sum must be the sum of their individual responses: $V(I_1 + I_2) = V(I_1) + V(I_2)$. If one measures the responses to $I_1$ and $I_2$ separately and then measures the response to them applied together, any deviation from simple addition ($V(I_1 + I_2) \\neq V(I_1) + V(I_2)$) is a direct demonstration of nonlinearity. This is a common occurrence in neurons, where two subthreshold inputs can sum to cross a threshold and elicit a spike (supralinear summation), a classic example of nonlinear integration.\n*   **Verdict:** The condition is a valid source of strong nonlinearity, and the proposed superposition test is a fundamental and direct method for detecting it. This option is **Correct**.\n\nIn summary, options A, B, C, and E each correctly pair a condition causing strong nonlinearity with a scientifically sound diagnostic method to reveal it. Option D is incorrect as it describes a linear system and misinterprets the evidence for linearity as evidence for failure.",
            "answer": "$$\\boxed{ABCE}$$"
        }
    ]
}