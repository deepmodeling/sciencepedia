{
    "hands_on_practices": [
        {
            "introduction": "At the heart of simulating a neuron's electrical behavior is the numerical solution of the cable equation. This foundational exercise guides you through the core mechanics of compartmental modeling using the robust implicit Euler method . By manually setting up and solving the linear system for a small, three-compartment cable, you will gain a concrete understanding of how membrane voltages evolve over a single time step and interact through axial conductances.",
            "id": "4039542",
            "problem": "Consider a passive dendritic cable approximated by three isopotential compartments connected in series, to be simulated in a neuromorphic and brain-inspired computing setting using compartmental modeling. Each compartment has membrane capacitance $C_{\\mathrm{m}}$, leak conductance $g_{\\mathrm{L}}$ to a reversal potential $E_{\\mathrm{L}}$, and is coupled to its nearest neighbor(s) by axial conductance $g_{\\mathrm{a}}$. The ends are sealed, so there are no axial couplings beyond the first and third compartments. Let the following parameters and states be given: $C_{\\mathrm{m}} = 0.2~\\mathrm{nF}$, $g_{\\mathrm{L}} = 0.5~\\mathrm{\\mu S}$, $E_{\\mathrm{L}} = 0~\\mathrm{mV}$, $g_{\\mathrm{a}} = 1.0~\\mathrm{\\mu S}$ (between compartments $1$–$2$ and $2$–$3$), time step $\\Delta t = 0.1~\\mathrm{ms}$, and the membrane voltages at time $t_n$ given by $\\mathbf{V}^n = \\begin{pmatrix} -65 \\\\ -60 \\\\ -70 \\end{pmatrix}~\\mathrm{mV}$. Suppose the externally injected current (per compartment) is applied at the end of the step, i.e., $\\mathbf{I}(t_{n+1}) = \\begin{pmatrix} 0.5 \\\\ 0.0 \\\\ 0.2 \\end{pmatrix}~\\mathrm{nA}$. \n\nStarting from Kirchhoff's current law (KCL) and the passive cable definitions for capacitive, leak, and axial currents, derive the linear system that results from applying the backward (implicit) Euler method to one time step from $t_n$ to $t_{n+1}$, assemble the resulting $3 \\times 3$ system matrix explicitly, and solve for the next-step voltages $\\mathbf{V}^{n+1}$. Express each component of $\\mathbf{V}^{n+1}$ in $\\mathrm{mV}$ and round your final numerical values to four significant figures. The final answer must be given as a single row matrix.",
            "solution": "The problem requires the derivation and solution of a linear system for the membrane voltages of a three-compartment dendritic model using the backward (implicit) Euler method.\n\nFirst, we establish the governing equations for the membrane voltage in each compartment based on Kirchhoff's current law (KCL). For each compartment $i$, the sum of the capacitive current, leak current, and axial currents to neighboring compartments must equal the externally injected current.\nThe current terms are defined as follows:\n- Capacitive current: $I_{\\mathrm{cap}, i} = C_{\\mathrm{m}} \\frac{dV_i}{dt}$\n- Leak current: $I_{\\mathrm{leak}, i} = g_{\\mathrm{L}} (V_i - E_{\\mathrm{L}})$\n- Axial current from compartment $i$ to $j$: $I_{\\mathrm{axial}, ij} = g_{\\mathrm{a}} (V_i - V_j)$\n- Injected current: $I_{i}(t)$\n\nThe dendritic cable is modeled as three compartments in series, with sealed ends. This implies compartment $1$ is only coupled to compartment $2$, compartment $2$ is coupled to $1$ and $3$, and compartment $3$ is only coupled to $2$. The KCL equations for the three compartments are:\n\nFor compartment $1$:\n$$C_{\\mathrm{m}} \\frac{dV_1}{dt} + g_{\\mathrm{L}} (V_1 - E_{\\mathrm{L}}) + g_{\\mathrm{a}} (V_1 - V_2) = I_1(t)$$\n\nFor compartment $2$:\n$$C_{\\mathrm{m}} \\frac{dV_2}{dt} + g_{\\mathrm{L}} (V_2 - E_{\\mathrm{L}}) + g_{\\mathrm{a}} (V_2 - V_1) + g_{\\mathrm{a}} (V_2 - V_3) = I_2(t)$$\n\nFor compartment $3$:\n$$C_{\\mathrm{m}} \\frac{dV_3}{dt} + g_{\\mathrm{L}} (V_3 - E_{\\mathrm{L}}) + g_{\\mathrm{a}} (V_3 - V_2) = I_3(t)$$\n\nNext, we apply the backward (implicit) Euler method to discretize these differential equations. The time derivative is approximated as $\\frac{dV_i}{dt} \\approx \\frac{V_i^{n+1} - V_i^n}{\\Delta t}$, and all other terms are evaluated at the future time step $t_{n+1}$. Let $\\mathbf{V}^{n+1} = (V_1^{n+1}, V_2^{n+1}, V_3^{n+1})^T$ be the vector of unknown voltages at time $t_{n+1}$. With $E_{\\mathrm{L}} = 0~\\mathrm{mV}$, the discretized equations are:\n\nFor compartment $1$:\n$$C_{\\mathrm{m}} \\frac{V_1^{n+1} - V_1^n}{\\Delta t} + g_{\\mathrm{L}} V_1^{n+1} + g_{\\mathrm{a}} (V_1^{n+1} - V_2^{n+1}) = I_1^{n+1}$$\n\nFor compartment $2$:\n$$C_{\\mathrm{m}} \\frac{V_2^{n+1} - V_2^n}{\\Delta t} + g_{\\mathrm{L}} V_2^{n+1} + g_{\\mathrm{a}} (V_2^{n+1} - V_1^{n+1}) + g_{\\mathrm{a}} (V_2^{n+1} - V_3^{n+1}) = I_2^{n+1}$$\n\nFor compartment $3$:\n$$C_{\\mathrm{m}} \\frac{V_3^{n+1} - V_3^n}{\\Delta t} + g_{\\mathrm{L}} V_3^{n+1} + g_{\\mathrm{a}} (V_3^{n+1} - V_2^{n+1}) = I_3^{n+1}$$\n\nTo form a linear system of the form $A \\mathbf{V}^{n+1} = \\mathbf{b}$, we rearrange the equations, grouping all terms containing $\\mathbf{V}^{n+1}$ on the left-hand side (LHS) and all known quantities on the right-hand side (RHS).\n\nRearranging for $V_1^{n+1}$, $V_2^{n+1}$, and $V_3^{n+1}$:\n$$ \\left(\\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + g_{\\mathrm{a}}\\right) V_1^{n+1} - g_{\\mathrm{a}} V_2^{n+1} = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_1^n + I_1^{n+1} $$\n$$ -g_{\\mathrm{a}} V_1^{n+1} + \\left(\\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + 2g_{\\mathrm{a}}\\right) V_2^{n+1} - g_{\\mathrm{a}} V_3^{n+1} = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_2^n + I_2^{n+1} $$\n$$ -g_{\\mathrm{a}} V_2^{n+1} + \\left(\\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + g_{\\mathrm{a}}\\right) V_3^{n+1} = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_3^n + I_3^{n+1} $$\n\nThe linear system $A \\mathbf{V}^{n+1} = \\mathbf{b}$ has the system matrix $A$ and vector $\\mathbf{b}$ defined as:\n$$ A = \\begin{pmatrix}\n\\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + g_{\\mathrm{a}} & -g_{\\mathrm{a}} & 0 \\\\\n-g_{\\mathrm{a}} & \\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + 2g_{\\mathrm{a}} & -g_{\\mathrm{a}} \\\\\n0 & -g_{\\mathrm{a}} & \\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + g_{\\mathrm{a}}\n\\end{pmatrix} $$\n$$ \\mathbf{b} = \\begin{pmatrix}\n\\frac{C_{\\mathrm{m}}}{\\Delta t} V_1^n + I_1^{n+1} \\\\\n\\frac{C_{\\mathrm{m}}}{\\Delta t} V_2^n + I_2^{n+1} \\\\\n\\frac{C_{\\mathrm{m}}}{\\Delta t} V_3^n + I_3^{n+1}\n\\end{pmatrix} $$\n\nNow, we substitute the given numerical values. The units are consistent if we use $C_{\\mathrm{m}}$ in $\\mathrm{nF}$, $g_{\\mathrm{L}}$ and $g_{\\mathrm{a}}$ in $\\mathrm{\\mu S}$, $V$ in $\\mathrm{mV}$, $\\Delta t$ in $\\mathrm{ms}$, and $I$ in $\\mathrm{nA}$.\nThe parameters are: $C_{\\mathrm{m}} = 0.2~\\mathrm{nF}$, $g_{\\mathrm{L}} = 0.5~\\mathrm{\\mu S}$, $g_{\\mathrm{a}} = 1.0~\\mathrm{\\mu S}$, $\\Delta t = 0.1~\\mathrm{ms}$.\nThe term $\\frac{C_{\\mathrm{m}}}{\\Delta t} = \\frac{0.2~\\mathrm{nF}}{0.1~\\mathrm{ms}} = 2.0~\\frac{\\mathrm{nF}}{\\mathrm{ms}} = 2.0~\\mathrm{\\mu S}$.\n\nWe can now assemble the $3 \\times 3$ system matrix $A$ explicitly:\nThe diagonal entries are:\n$A_{11} = A_{33} = \\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + g_{\\mathrm{a}} = 2.0 + 0.5 + 1.0 = 3.5~\\mathrm{\\mu S}$\n$A_{22} = \\frac{C_{\\mathrm{m}}}{\\Delta t} + g_{\\mathrm{L}} + 2g_{\\mathrm{a}} = 2.0 + 0.5 + 2(1.0) = 4.5~\\mathrm{\\mu S}$\nThe off-diagonal entries are:\n$A_{12} = A_{21} = A_{23} = A_{32} = -g_{\\mathrm{a}} = -1.0~\\mathrm{\\mu S}$\nSo, the system matrix is:\n$$ A = \\begin{pmatrix} 3.5 & -1.0 & 0 \\\\ -1.0 & 4.5 & -1.0 \\\\ 0 & -1.0 & 3.5 \\end{pmatrix}~\\mathrm{\\mu S} $$\n\nNext, we assemble the vector $\\mathbf{b}$ using $\\mathbf{V}^n = \\begin{pmatrix} -65 \\\\ -60 \\\\ -70 \\end{pmatrix}~\\mathrm{mV}$ and $\\mathbf{I}^{n+1} = \\begin{pmatrix} 0.5 \\\\ 0.0 \\\\ 0.2 \\end{pmatrix}~\\mathrm{nA}$.\n$b_1 = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_1^n + I_1^{n+1} = (2.0)(-65) + 0.5 = -130 + 0.5 = -129.5~\\mathrm{nA}$\n$b_2 = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_2^n + I_2^{n+1} = (2.0)(-60) + 0.0 = -120 + 0.0 = -120.0~\\mathrm{nA}$\n$b_3 = \\frac{C_{\\mathrm{m}}}{\\Delta t} V_3^n + I_3^{n+1} = (2.0)(-70) + 0.2 = -140 + 0.2 = -139.8~\\mathrm{nA}$\nSo, the RHS vector is:\n$$ \\mathbf{b} = \\begin{pmatrix} -129.5 \\\\ -120.0 \\\\ -139.8 \\end{pmatrix}~\\mathrm{nA} $$\n\nWe now solve the linear system $A \\mathbf{V}^{n+1} = \\mathbf{b}$ for $\\mathbf{V}^{n+1}$:\n$$ \\begin{pmatrix} 3.5 & -1.0 & 0 \\\\ -1.0 & 4.5 & -1.0 \\\\ 0 & -1.0 & 3.5 \\end{pmatrix} \\begin{pmatrix} V_1^{n+1} \\\\ V_2^{n+1} \\\\ V_3^{n+1} \\end{pmatrix} = \\begin{pmatrix} -129.5 \\\\ -120.0 \\\\ -139.8 \\end{pmatrix} $$\nThis corresponds to the following set of equations:\n1) $3.5 V_1^{n+1} - V_2^{n+1} = -129.5$\n2) $-V_1^{n+1} + 4.5 V_2^{n+1} - V_3^{n+1} = -120.0$\n3) $-V_2^{n+1} + 3.5 V_3^{n+1} = -139.8$\n\nFrom equation (1), we express $V_1^{n+1}$ in terms of $V_2^{n+1}$: $V_1^{n+1} = \\frac{V_2^{n+1} - 129.5}{3.5}$.\nFrom equation (3), we express $V_3^{n+1}$ in terms of $V_2^{n+1}$: $V_3^{n+1} = \\frac{V_2^{n+1} - 139.8}{3.5}$.\nSubstituting these into equation (2):\n$$ -\\left(\\frac{V_2^{n+1} - 129.5}{3.5}\\right) + 4.5 V_2^{n+1} - \\left(\\frac{V_2^{n+1} - 139.8}{3.5}\\right) = -120.0 $$\nMultiplying the entire equation by $3.5$:\n$$ -(V_2^{n+1} - 129.5) + (4.5 \\times 3.5) V_2^{n+1} - (V_2^{n+1} - 139.8) = -120.0 \\times 3.5 $$\n$$ -V_2^{n+1} + 129.5 + 15.75 V_2^{n+1} - V_2^{n+1} + 139.8 = -420 $$\n$$ (15.75 - 1 - 1) V_2^{n+1} + (129.5 + 139.8) = -420 $$\n$$ 13.75 V_2^{n+1} + 269.3 = -420 $$\n$$ 13.75 V_2^{n+1} = -420 - 269.3 = -689.3 $$\n$$ V_2^{n+1} = \\frac{-689.3}{13.75} \\approx -50.130909~\\mathrm{mV} $$\nNow we find $V_1^{n+1}$ and $V_3^{n+1}$:\n$$ V_1^{n+1} = \\frac{-50.130909 - 129.5}{3.5} = \\frac{-179.630909}{3.5} \\approx -51.323117~\\mathrm{mV} $$\n$$ V_3^{n+1} = \\frac{-50.130909 - 139.8}{3.5} = \\frac{-189.930909}{3.5} \\approx -54.265974~\\mathrm{mV} $$\n\nFinally, we round the numerical values to four significant figures as required.\n$V_1^{n+1} \\approx -51.32~\\mathrm{mV}$\n$V_2^{n+1} \\approx -50.13~\\mathrm{mV}$\n$V_3^{n+1} \\approx -54.27~\\mathrm{mV}$\n\nThe solution for the next-step voltages is $\\mathbf{V}^{n+1} = \\begin{pmatrix} -51.32 \\\\ -50.13 \\\\ -54.27 \\end{pmatrix}~\\mathrm{mV}$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} -51.32 & -50.13 & -54.27 \\end{pmatrix} } $$"
        },
        {
            "introduction": "The complex branching pattern of a dendrite is not arbitrary; it often follows biophysical principles that optimize signal propagation. This practice allows you to test one such principle, Rall's branching rule, which relates a parent branch's diameter $d_p$ to its children's diameters $\\{d_k\\}$ through the relationship $d_p^{3/2} = \\sum_k d_k^{3/2}$ . By writing a program to analyze morphological data, you will bridge the gap between abstract cable theory and the tangible geometry of neuronal structures.",
            "id": "3974766",
            "problem": "You are given a set of rooted trees representing morphological reconstructions of dendritic arbors. Each node corresponds to a short cylindrical compartment with a specified diameter measured in micrometers. The trees are represented as lists of tuples $(\\text{node\\_id}, \\text{parent\\_id}, d)$, where $d$ is the compartment diameter in $\\mu\\text{m}$, $\\text{parent\\_id}=-1$ denotes the root, and each non-root node has exactly one parent. A branching point (bifurcation) is any node with two or more children.\n\nThe aim is to test the applicability of Rall’s rule across each tree by computing, for every branching point, the deviation between the parent compartment’s $d^{3/2}$ and the sum of the children compartments’ $d^{3/2}$. Specifically, define for a branching point with parent diameter $d_p$ and child diameters $\\{d_k\\}_{k=1}^m$ the sums $S_{\\text{parent}} = d_p^{3/2}$ and $S_{\\text{kids}} = \\sum_{k=1}^m d_k^{3/2}$, and the relative deviation\n$$\n\\delta = \\frac{S_{\\text{kids}} - S_{\\text{parent}}}{S_{\\text{parent}}}.\n$$\nAcross all branching points in a given tree, compute three metrics: the mean absolute relative deviation $\\overline{|\\delta|}$, the maximum absolute relative deviation $\\max|\\delta|$, and the fraction $f_\\tau$ of branching points whose absolute relative deviation is at most a tolerance $\\tau$. The tolerance is $\\tau=0.05$ (a decimal), and all deviation metrics are dimensionless. If a tree has no branching points, define $\\overline{|\\delta|}=0$, $\\max|\\delta|=0$, and $f_\\tau=1$.\n\nThe foundational base for this problem is linear cable theory for neuronal dendrites under quasi-static conditions, with the well-tested observation that the input conductance of a semi-infinite cylindrical cable scales with $d^{3/2}$, leading to the branching conductance matching condition at a node. The derivation of this scaling and its application are requested in the solution.\n\nYour task is to implement a program that, for the provided test suite of five trees, computes the three metrics described above for each tree and outputs them in a single aggregate format. Diameters are provided in $\\mu\\text{m}$; the deviations are dimensionless. There are no angles and no percentage signs are to be used.\n\nTest suite (each tree is a list of $(\\text{node\\_id}, \\text{parent\\_id}, d)$ tuples; diameters $d$ are in $\\mu\\text{m}$):\n\n- Tree A (balanced binary with near-Rall compliance at both branching points):\n    - $(0,-1,2.0736)$\n    - $(1,0,1.2)$\n    - $(2,0,1.4)$\n    - $(3,1,0.7)$\n    - $(4,1,0.81)$\n\n- Tree B (same topology as Tree A, with a deliberate deviation at one branch):\n    - $(0,-1,2.0736)$\n    - $(1,0,1.2)$\n    - $(2,0,1.4)$\n    - $(3,1,0.7)$\n    - $(4,1,0.9)$\n\n- Tree C (root trifurcation with near-Rall compliance, and a deeper bifurcation deviating):\n    - $(0,-1,2.0850)$\n    - $(1,0,1.1)$\n    - $(2,0,1.0)$\n    - $(3,0,0.9)$\n    - $(4,1,0.7)$\n    - $(5,1,0.5)$\n\n- Tree D (single chain, no branching points):\n    - $(0,-1,1.2)$\n    - $(1,0,1.1)$\n    - $(2,1,1.0)$\n    - $(3,2,0.9)$\n\n- Tree E (binary root with one very small child to test numerical stability, deeper bifurcation deviating):\n    - $(0,-1,1.0)$\n    - $(1,0,0.2)$\n    - $(2,0,0.945)$\n    - $(3,2,0.4)$\n    - $(4,2,0.5)$\n\nYour program should produce a single line of output containing the results for the five trees as a comma-separated list of lists, where each inner list has the three metrics in the order $[\\overline{|\\delta|}, \\max|\\delta|, f_\\tau]$. For example, the output should look like $[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3],[x_4,y_4,z_4],[x_5,y_5,z_5]]$, with each $x_i$, $y_i$, and $z_i$ a floating-point number. No other output text is permitted.",
            "solution": "The problem requires an analysis of dendritic tree morphology based on Rall's branching rule, a principle derived from linear cable theory. Before presenting the computational method, it is imperative to first establish the theoretical foundation, as requested.\n\n**Theoretical Foundation: Derivation of Rall's $3/2$ Power Rule**\n\nThe basis for Rall's rule is found in the behavior of electrical current in passive dendritic cables under steady-state (DC) conditions. We model a segment of a dendrite as a uniform cylinder. The voltage $V(x)$ along the length $x$ of this cable is described by the steady-state cable equation:\n$$\n\\lambda^2 \\frac{d^2V}{dx^2} - V = 0\n$$\nHere, $\\lambda$ is the space constant of the cable, defined as $\\lambda = \\sqrt{r_m/r_a}$, where $r_m$ is the membrane resistance for a unit length of the cylinder and $r_a$ is the axial resistance per unit length.\n\nThese resistances depend on the geometry of the cylinder and the intrinsic properties of the neuron. Let $d$ be the diameter of the cylindrical compartment, $R_m$ be the specific membrane resistance (in $\\Omega \\cdot \\text{m}^2$), and $R_i$ be the specific intracellular (axial) resistivity (in $\\Omega \\cdot \\text{m}$).\n\nThe membrane resistance per unit length, $r_m$, is inversely proportional to the membrane surface area per unit length (the perimeter, $\\pi d$):\n$$\nr_m = \\frac{R_m}{\\pi d}\n$$\nThe axial resistance per unit length, $r_a$, is inversely proportional to the cross-sectional area of the cylinder ($A = \\pi(d/2)^2$):\n$$\nr_a = \\frac{R_i}{A} = \\frac{R_i}{\\pi (d/2)^2} = \\frac{4 R_i}{\\pi d^2}\n$$\nSubstituting these into the definition of the space constant $\\lambda$:\n$$\n\\lambda = \\sqrt{\\frac{r_m}{r_a}} = \\sqrt{\\frac{R_m / (\\pi d)}{4 R_i / (\\pi d^2)}} = \\sqrt{\\frac{R_m d}{4 R_i}}\n$$\nAssuming uniform material properties ($R_m$ and $R_i$ are constant), the space constant scales with the square root of the diameter: $\\lambda \\propto \\sqrt{d}$.\n\nNext, we consider the input conductance, $G_{in}$, of a dendritic branch. For a semi-infinite cable (a valid approximation for electrically long branches), the input resistance is $R_{in} = \\sqrt{r_m r_a}$. The input conductance is its reciprocal:\n$$\nG_{in} = \\frac{1}{R_{in}} = \\frac{1}{\\sqrt{r_m r_a}}\n$$\nWe can also express $R_{in}$ using $\\lambda$ and $r_a$ as $R_{in} = \\lambda r_a$. Thus:\n$$\nG_{in} = \\frac{1}{\\lambda r_a}\n$$\nNow, we examine how $G_{in}$ scales with diameter $d$. We have established that $\\lambda \\propto \\sqrt{d}$ and $r_a \\propto 1/d^2$. Therefore:\n$$\nG_{in} \\propto \\frac{1}{(\\sqrt{d}) (1/d^2)} = \\frac{d^2}{\\sqrt{d}} = d^{3/2}\n$$\nThis derivation establishes that the input conductance of a semi-infinite cable scales with its diameter to the power of $3/2$.\n\nWilfrid Rall's insight was that for efficient signal propagation without impedance mismatch, the conductance looking into a parent branch should be equal to the sum of the conductances of its daughter branches. At a branching point with parent diameter $d_p$ and $m$ child branches with diameters $\\{d_k\\}_{k=1}^m$, this condition is:\n$$\nG_{in, \\text{parent}} = \\sum_{k=1}^m G_{in, \\text{child}_k}\n$$\nUsing the derived scaling relationship, and letting $C$ be the constant of proportionality, we get:\n$$\nC \\cdot d_p^{3/2} = \\sum_{k=1}^m C \\cdot d_k^{3/2}\n$$\nThe constant $C$ cancels, yielding Rall's celebrated branching rule:\n$$\nd_p^{3/2} = \\sum_{k=1}^m d_k^{3/2}\n$$\n**Computational Strategy**\n\nThe problem requires us to quantify the deviation from this ideal rule for a set of given dendritic trees. The algorithm to achieve this for each tree is as follows:\n\n1.  **Data Structuring**: The input format, a list of $(\\text{node\\_id}, \\text{parent\\_id}, d)$ tuples, is an edge list. This needs to be parsed into a more computationally convenient structure. Two dictionaries are optimal:\n    *   A dictionary mapping each `node_id` to its diameter $d$.\n    *   A dictionary mapping each parent `node_id` to a list of its children's `node_id`s. This directly represents the tree hierarchy.\n\n2.  **Identification of Branching Points**: A branching point is defined as a node with two or more children. By iterating through the parent-to-children dictionary created in the previous step, all nodes that are keys to lists of length $\\ge 2$ are identified as branching points.\n\n3.  **Deviation Calculation**: For each identified branching point $p$:\n    *   Retrieve the parent diameter $d_p$ and the set of child diameters $\\{d_k\\}$.\n    *   Calculate the parent sum $S_{\\text{parent}} = d_p^{3/2}$.\n    *   Calculate the children sum $S_{\\text{kids}} = \\sum_{k} d_k^{3/2}$.\n    *   Compute the relative deviation $\\delta = (S_{\\text{kids}} - S_{\\text{parent}}) / S_{\\text{parent}}$. Note that for any $d_p > 0$, $S_{\\text{parent}}$ is also greater than $0$, precluding division by zero. All diameters in the test suite are positive.\n    *   Collect all computed $\\delta$ values for the tree into a list.\n\n4.  **Metric Computation**:\n    *   If the tree contains no branching points, the list of deviations will be empty. As per the problem definition, the metrics are defined as $\\overline{|\\delta|} = 0$, $\\max|\\delta| = 0$, and $f_\\tau = 1$.\n    *   If branching points exist, the following metrics are computed from the list of $\\delta$ values:\n        *   **Mean Absolute Relative Deviation, $\\overline{|\\delta|}$**: The arithmetic mean of the absolute values of all computed deviations.\n        *   **Maximum Absolute Relative Deviation, $\\max|\\delta|$**: The maximum value among the absolute values of all computed deviations.\n        *   **Fraction of Compliant Branches, $f_\\tau$**: The fraction of branching points for which $|\\delta| \\le \\tau$, where the tolerance $\\tau$ is given as $0.05$. This is calculated as (number of branches with $|\\delta| \\le \\tau$) / (total number of branches).\n\nThis procedure is applied independently to each of the five provided test trees to generate the final results. The implementation will use the `numpy` library for efficient numerical operations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates dendritic trees against Rall's rule and computes deviation metrics.\n    \"\"\"\n    # Test suite of five dendritic trees.\n    # Each tree is a list of (node_id, parent_id, diameter) tuples.\n    test_cases = [\n        # Tree A (balanced binary, near-Rall compliance)\n        [\n            (0, -1, 2.0736), (1, 0, 1.2), (2, 0, 1.4), (3, 1, 0.7), (4, 1, 0.81)\n        ],\n        # Tree B (same as A, one branch deviating)\n        [\n            (0, -1, 2.0736), (1, 0, 1.2), (2, 0, 1.4), (3, 1, 0.7), (4, 1, 0.9)\n        ],\n        # Tree C (trifurcation, deeper bifurcation deviating)\n        [\n            (0, -1, 2.0850), (1, 0, 1.1), (2, 0, 1.0), (3, 0, 0.9), (4, 1, 0.7), (5, 1, 0.5)\n        ],\n        # Tree D (single chain, no branching points)\n        [\n            (0, -1, 1.2), (1, 0, 1.1), (2, 1, 1.0), (3, 2, 0.9)\n        ],\n        # Tree E (binary root, deeper bifurcation deviating)\n        [\n            (0, -1, 1.0), (1, 0, 0.2), (2, 0, 0.945), (3, 2, 0.4), (4, 2, 0.5)\n        ]\n    ]\n\n    # Tolerance for calculating the fraction of compliant branches.\n    tau = 0.05\n    all_results = []\n\n    for tree_data in test_cases:\n        if not tree_data:\n            # Handle empty tree case if necessary, though not in test suite.\n            all_results.append([0.0, 0.0, 1.0])\n            continue\n            \n        diameters = {node_id: d for node_id, _, d in tree_data}\n        children = {}\n        for node_id, parent_id, _ in tree_data:\n            if parent_id != -1:\n                if parent_id not in children:\n                    children[parent_id] = []\n                children[parent_id].append(node_id)\n        \n        branching_points = [\n            node_id for node_id, child_list in children.items()\n            if len(child_list) >= 2\n        ]\n\n        if not branching_points:\n            # Per problem spec, if no branching points, define metrics as follows.\n            mean_abs_dev = 0.0\n            max_abs_dev = 0.0\n            f_tau = 1.0\n            all_results.append([mean_abs_dev, max_abs_dev, f_tau])\n            continue\n\n        deviations = []\n        for bp_id in branching_points:\n            # Get parent diameter and calculate S_parent = d_p^(3/2)\n            d_p = diameters[bp_id]\n            # Handle d_p=0 case to prevent division by zero, though not in test data.\n            if d_p == 0:\n                # If parent diameter is 0, deviation is ill-defined.\n                # A sum of positive child diams would yield infinite deviation.\n                # Assuming d_p > 0 based on context. Let's formalize a behavior if needed.\n                # If child diameters are also 0, deviation could be 0. We'll assume d_p > 0.\n                s_parent = 0.0\n            else:\n                s_parent = np.power(d_p, 1.5)\n\n            # Get child diameters and calculate S_kids = sum(d_k^(3/2))\n            child_ids = children[bp_id]\n            child_diams = [diameters[cid] for cid in child_ids]\n            s_kids = np.sum(np.power(child_diams, 1.5))\n            \n            # Calculate relative deviation\n            if s_parent == 0:\n                # Can't compute relative deviation if parent sum is zero.\n                # If kids_sum is also 0, dev is 0. If kids_sum > 0, dev is inf.\n                # This case is not expected in the problem.\n                delta = np.inf if s_kids > 0 else 0.0\n            else:\n                delta = (s_kids - s_parent) / s_parent\n            \n            deviations.append(delta)\n\n        # Calculate metrics from the list of deviations\n        abs_deviations = np.abs(np.array(deviations))\n        mean_abs_dev = np.mean(abs_deviations)\n        max_abs_dev = np.max(abs_deviations)\n        \n        compliant_branches = np.sum(abs_deviations = tau)\n        f_tau = compliant_branches / len(branching_points)\n        \n        all_results.append([mean_abs_dev, max_abs_dev, f_tau])\n\n    # Format output to match specification: [[x1,y1,z1],[x2,y2,z2],...]\n    # without spaces inside the inner lists.\n    output_str = f\"[{','.join(['[' + ','.join(map(str, res)) + ']' for res in all_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "While highly-detailed compartmental models offer great accuracy, their computational cost can be prohibitive for large-scale simulations or efficient neuromorphic hardware. This advanced practice moves beyond simple simulation to the sophisticated task of model reduction and design . You will implement an optimization routine to discover the ideal non-uniform placement of compartment boundaries, a process that minimizes the error between a computationally lean model and a high-fidelity reference.",
            "id": "4039533",
            "problem": "You are tasked with designing and implementing a program that optimizes the placement of compartment boundaries in a reduced passive dendritic cable model to minimize an error criterion under a fixed number of compartments. The dendrite is modeled as a straight cylinder of length $L$ and radius $r$, with axial resistivity $r_a$ and membrane leak conductance density $g_m(x)$. The model operates under direct current (DC) steady-state conditions, where a constant current $I_0$ is injected at the proximal end ($x=0$). The distal end at $x=L$ is sealed (no axial current flow through the boundary). The purpose of the program is to optimize the reduced model boundary placement so that the reduced model reproduces the steady-state voltage profile along the cable as closely as possible relative to a high-resolution reference.\n\nThe fundamental base for the model is conservation of current and Ohm's law. Let $V(x)$ denote the membrane voltage along the cylinder. For a cylindrical cable with cross-sectional area $A=\\pi r^2$ and membrane surface area per unit length $S=2\\pi r$, the steady-state one-dimensional cable equation under DC conditions and spatially varying membrane conductance density $g_m(x)$ follows from axial current conservation and membrane leak to ground:\n$$\n\\frac{A}{r_a}\\frac{d^2 V(x)}{dx^2} - S\\,g_m(x)\\,V(x) = 0,\n$$\nsubject to a boundary condition at $x=L$ expressing a sealed end ($\\frac{dV}{dx}(L)=0$) and a current injection at $x=0$ represented by an applied source into the proximal compartment.\n\nA reduced compartmental model represents the cable using $N$ compartments of lengths $\\{\\ell_i\\}_{i=1}^N$ such that $\\sum_{i=1}^N \\ell_i = L$, with each compartment $i$ having a single voltage variable $V_i$ located at the center position $x_i$. Adjacent compartments are coupled by axial conductances derived from the axial resistivity and the distance between compartment centers. Each compartment leaks to ground through its membrane, with a conductance equal to the product of the local membrane density $g_m(x_i)$ and the membrane surface area of that compartment, $S\\,\\ell_i$. The proximal compartment receives the injected current $I_0$. The high-resolution reference model is built using the same discretization logic on a fine uniform grid of $M$ compartments ($M$ large) that approximates the continuous cable to negligible error at the level of this exercise.\n\nThe optimization objective is defined as the integral along the cable of the squared difference between the reduced model voltage profile (represented as a piecewise-constant function where the voltage within each compartment equals its compartment voltage) and the high-resolution reference voltage profile. Explicitly, if $\\tilde{V}(x)$ denotes the piecewise-constant reduced profile and $V_{\\mathrm{ref}}(x)$ denotes the reference profile, the objective is\n$$\nJ(\\{\\ell_i\\}_{i=1}^N) = \\int_{0}^{L} \\left(\\tilde{V}(x) - V_{\\mathrm{ref}}(x)\\right)^2\\,dx.\n$$\nYou must justify the choice of this objective function by grounding it in the underlying linear passive cable theory and by explaining why this error is appropriate for DC responses. In your implementation, approximate the integral using a Riemann sum on the fine grid used by the reference model.\n\nProgram requirements:\n- Implement the compartmental discretization using the following finite-volume layout for axial couplings and membrane leaks. For compartment $i$ of length $\\ell_i$ centered at $x_i$, the membrane conductance is $G_{m,i} = S \\, g_m(x_i)\\,\\ell_i$. The axial conductance between adjacent compartments $i$ and $i+1$ is $G_{a,i} = \\frac{A}{r_a\\,d_{i,i+1}}$, where $d_{i,i+1} = \\frac{\\ell_i+\\ell_{i+1}}{2}$ is the center-to-center distance. The sealed distal end corresponds to having no axial conductance past the last compartment. The current injection $I_0$ is applied to compartment $1$ only, and the nodal voltages $\\{V_i\\}$ are obtained by solving the resulting linear system.\n- Use the high-resolution reference to be a uniform discretization of $M$ compartments, with $M$ chosen sufficiently large (your program must set $M$ internally).\n- Optimize the boundary placement by parameterizing lengths $\\{\\ell_i\\}_{i=1}^N$ through an unconstrained vector that is mapped to positive lengths summing to $L$.\n- The final answer must report the interior boundary positions (i.e., excluding $0$ and $L$) that minimize $J$, expressed in meters, in the specified output format.\n\nInput handling:\n- The program must be self-contained and must not read any input. It must use the test suite values specified below and produce the output directly.\n\nUnits:\n- All physical quantities must be treated with their standard International System of Units (SI). The final output must express boundary positions in meters.\n\nTest suite:\n- Case $1$ (general case): $L=500\\times 10^{-6}$ meters, $r=0.75\\times 10^{-6}$ meters, $r_a=1.5$ ohm meters, $g_m(x)=0.01$ siemens per square meter (constant), $I_0=1\\times 10^{-12}$ amperes, $N=5$ compartments.\n- Case $2$ (boundary condition coverage with minimal model): $L=500\\times 10^{-6}$ meters, $r=0.75\\times 10^{-6}$ meters, $r_a=1.5$ ohm meters, $g_m(x)=0.01$ siemens per square meter (constant), $I_0=1\\times 10^{-12}$ amperes, $N=1$ compartment.\n- Case $3$ (nonuniform membrane): $L=500\\times 10^{-6}$ meters, $r=0.75\\times 10^{-6}$ meters, $r_a=1.5$ ohm meters, $g_m(x)=g_0 + (g_1-g_0)\\frac{x}{L}$ with $g_0=0.005$ siemens per square meter and $g_1=0.02$ siemens per square meter (linearly increasing along the cable), $I_0=1\\times 10^{-12}$ amperes, $N=8$ compartments.\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of interior boundary positions in meters, ordered from proximal to distal. For example, an output for three cases should look like: $[ [b_{1,1},b_{1,2},\\dots], [\\ ], [b_{3,1},b_{3,2},\\dots] ]$, but your program must output the lists without spaces. Concretely: \"Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., [result1,result2,result3]).\"",
            "solution": "The problem statement has been analyzed and is determined to be **valid**. It is scientifically grounded in the principles of passive cable theory and computational neuroscience, is well-posed as an optimization problem, and is specified with objective, unambiguous language and parameters.\n\n### 1. Modeling and Discretization Principle\n\nThe core of the problem is to approximate the continuous voltage profile $V(x)$ along a dendritic cable, governed by the steady-state cable equation, using a reduced model with a small number of compartments. The continuous model is given by:\n$$\n\\frac{A}{r_a}\\frac{d^2 V(x)}{dx^2} - S\\,g_m(x)\\,V(x) = 0\n$$\nwhere $A = \\pi r^2$ is the cross-sectional area, $S = 2\\pi r$ is the surface area per unit length, $r_a$ is the axial resistivity, and $g_m(x)$ is the membrane conductance density. The boundary conditions are current injection at $x=0$ and a sealed end at $x=L$, which in the continuous model translate to $-\\frac{A}{r_a}\\frac{dV}{dx}(0) = I_0$ and $\\frac{dV}{dx}(L)=0$, respectively.\n\nThe compartmental model approximates this continuous system using a finite volume method. The cable is divided into $N$ segments (compartments) of lengths $\\{\\ell_i\\}_{i=1}^N$. Each compartment $i$ is represented by a single node at its center, $x_i$, with voltage $V_i$. The continuous properties are lumped into discrete conductances.\n\n- **Membrane Conductance ($G_m$):** The total membrane conductance for compartment $i$ is the product of the membrane conductance density at its center and its surface area:\n  $$\n  G_{m,i} = g_m(x_i) \\cdot (S \\ell_i)\n  $$\n- **Axial Conductance ($G_a$):** The axial conductance connects the centers of adjacent compartments $i$ and $i+1$. It is the inverse of the axial resistance between them. The resistance is $R_{axial} = r_a \\frac{d}{A}$, where $d = (\\ell_i + \\ell_{i+1})/2$ is the distance between the centers. Thus, the conductance is:\n  $$\n  G_{a,i} = \\frac{A}{r_a \\left(\\frac{\\ell_i+\\ell_{i+1}}{2}\\right)}\n  $$\n\nBy applying Kirchhoff's Current Law (KCL) at each node $i$, which states that the sum of currents flowing out of the node is zero, we obtain a system of linear equations. For a generic internal compartment $i$ (where $1  i  N$):\n$$\n(V_i - V_{i-1})G_{a,i-1} + (V_i - V_{i+1})G_{a,i} + V_i G_{m,i} = 0\n$$\nFor the boundary compartments:\n- **Compartment 1 (proximal, current injection):** As specified, the injected current $I_0$ is treated as an external source into node $1$:\n  $$\n  (V_1 - V_2)G_{a,1} + V_1 G_{m,1} = I_0\n  $$\n- **Compartment N (distal, sealed end):** There is no compartment $N+1$, so the axial path is blocked, correctly modeling the sealed end:\n  $$\n  (V_N - V_{N-1})G_{a,N-1} + V_N G_{m,N} = 0\n  $$\n\nThese $N$ equations form a linear system $\\mathbf{G}\\mathbf{V} = \\mathbf{I}$, where $\\mathbf{G}$ is an $N \\times N$ symmetric, tridiagonal conductance matrix, $\\mathbf{V}$ is the vector of unknown compartment voltages, and $\\mathbf{I}$ is the current injection vector (with $I_1 = I_0$ and all other elements being $0$). This system can be efficiently solved to find the voltages $\\{V_i\\}$.\n\n### 2. Justification of the Optimization Objective\n\nThe objective is to minimize the function:\n$$\nJ(\\{\\ell_i\\}_{i=1}^N) = \\int_{0}^{L} \\left(\\tilde{V}(x) - V_{\\mathrm{ref}}(x)\\right)^2\\,dx\n$$\nwhere $\\tilde{V}(x)$ is the piecewise-constant voltage profile from the $N$-compartment reduced model and $V_{\\mathrm{ref}}(x)$ is the high-accuracy voltage profile from a reference model with a large number of compartments ($M \\gg N$).\n\nThis objective function, the integrated squared error, is a standard and robust choice for several reasons:\n- **$L^2$ Norm:** It represents the square of the $L^2$ norm of the error function $\\epsilon(x) = \\tilde{V}(x) - V_{\\mathrm{ref}}(x)$. Minimizing this norm is a well-established goal in function approximation theory, ensuring that the approximation is close to the true function \"on average\" over the entire domain.\n- **Physical Relevance:** For linear passive systems, the squared voltage is proportional to power. Minimizing the integrated squared error is analogous to minimizing the total error energy in the system's response. For DC steady-state, it ensures the static voltage landscape, which sets the baseline for neuronal integration, is captured with high fidelity.\n- **Mathematical Properties:** The quadratic nature of the function heavily penalizes large deviations, forcing the optimization to find compartment lengths that avoid significant local inaccuracies.\n- **Differentiability:** The objective function is smooth and differentiable with respect to the compartment lengths (and thus the optimization variables), which makes it suitable for efficient gradient-based optimization algorithms.\n\nThe integral is numerically approximated using a Riemann sum over the fine grid of the reference model. If the reference model uses $M$ uniform compartments of length $\\Delta x = L/M$, the integral becomes:\n$$\nJ \\approx \\sum_{j=1}^{M} \\left(\\tilde{V}(x_j) - V_{\\mathrm{ref},j}\\right)^2 \\Delta x\n$$\n\n### 3. Optimization Strategy\n\nThe goal is to find the set of compartment lengths $\\{\\ell_i\\}$ that minimizes $J$, subject to the constraints $\\ell_i  0$ for all $i$ and $\\sum_{i=1}^N \\ell_i = L$. Such constrained optimization problems can be transformed into unconstrained problems through a suitable reparameterization.\n\nWe introduce an unconstrained vector of variables $\\mathbf{y} = \\{y_i\\}_{i=1}^N \\in \\mathbb{R}^N$. We can then map this vector to a valid set of lengths $\\{\\ell_i\\}$ using the **softmax function**:\n$$\n\\ell_i(\\mathbf{y}) = L \\cdot \\frac{e^{y_i}}{\\sum_{j=1}^N e^{y_j}}\n$$\nThis transformation elegantly satisfies both constraints automatically: $\\ell_i$ is always positive, and their sum is always $L$. The optimization problem is now to find the vector $\\mathbf{y}$ that minimizes the objective function $J(\\mathbf{y})$.\n\nThe overall algorithm is as follows:\n1.  **Generate Reference Solution:** For each test case, first construct and solve a high-resolution reference model with $M$ uniform compartments (e.g., $M=1000$). This yields the reference voltage vector $\\mathbf{V}_{\\mathrm{ref}}$.\n2.  **Define Objective Function:** Create a Python function that accepts the unconstrained vector $\\mathbf{y}$ as input. Inside this function:\n    a. Convert $\\mathbf{y}$ to compartment lengths $\\{\\ell_i\\}$ using the softmax transformation.\n    b. Construct and solve the $N$-compartment reduced model using these lengths to obtain voltages $\\{V_i\\}$.\n    c. Generate the piecewise-constant voltage profile $\\tilde{V}(x)$ on the same fine grid as the reference model.\n    d. Calculate and return the error $J$ by summing the squared differences between $\\tilde{V}$ and $V_{\\mathrm{ref}}$.\n3.  **Perform Optimization:** Use a numerical optimization routine, such as the BFGS algorithm provided by `scipy.optimize.minimize`, to find the optimal parameter vector $\\mathbf{y}_{\\mathrm{opt}}$ that minimizes the objective function. An initial guess of $\\mathbf{y}_0 = \\mathbf{0}$ is used, which corresponds to an initial configuration of uniform compartment lengths.\n4.  **Extract Final Boundaries:** Once $\\mathbf{y}_{\\mathrm{opt}}$ is found, convert it back to the optimal compartment lengths $\\{\\ell_{i, \\mathrm{opt}}\\}$. The interior boundary positions $\\{b_k\\}$ are then calculated by taking the cumulative sum of these lengths:\n    $$\n    b_k = \\sum_{i=1}^{k} \\ell_{i, \\mathrm{opt}} \\quad \\text{for } k = 1, \\dots, N-1.\n    $$\nThis procedure finds the boundary placements that make the simplified model best reproduce the detailed voltage profile, according to the specified error metric.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.linalg import solve_banded\nimport math\n\n# Use a high number of compartments for the reference model to approximate the continuous case.\nM_REF = 1000\n\ndef solve_model(lengths, L, r, ra, gm_func, I0):\n    \"\"\"\n    Builds and solves the linear system for a compartmental model.\n\n    Args:\n        lengths (np.ndarray): Array of compartment lengths.\n        L, r, ra, I0 (float): Physical parameters of the cable.\n        gm_func (callable): Function gm(x) for membrane conductance density.\n\n    Returns:\n        np.ndarray: Array of compartment voltages.\n    \"\"\"\n    N = len(lengths)\n    if N == 0:\n        return np.array([])\n    \n    A = math.pi * r**2\n    S = 2 * math.pi * r\n\n    # Calculate compartment centers from lengths\n    boundaries = np.cumsum(lengths)\n    centers = boundaries - lengths / 2.0\n\n    # Membrane conductances\n    Gm = S * gm_func(centers) * lengths\n\n    # Axial conductances\n    if N > 1:\n        # Center-to-center distances\n        d_centers = (lengths[:-1] + lengths[1:]) / 2.0\n        Ga = A / (ra * d_centers)\n    else:\n        Ga = np.array([])\n\n    # Construct the tridiagonal conductance matrix G for solve_banded\n    # ab is a 3xN matrix: [upper_diag, main_diag, lower_diag]\n    ab = np.zeros((3, N))\n\n    # Main diagonal\n    if N == 1:\n        ab[1, 0] = Gm[0]\n    else:\n        ab[1, 0] = Ga[0] + Gm[0]\n        ab[1, -1] = Ga[-1] + Gm[-1]\n        ab[1, 1:-1] = Ga[:-1] + Ga[1:] + Gm[1:-1]\n\n    # Off-diagonals\n    if N > 1:\n        ab[0, 1:] = -Ga\n        ab[2, :-1] = -Ga\n\n    # Current vector I\n    I = np.zeros(N)\n    I[0] = I0\n\n    # Solve the linear system G*V = I\n    voltages = solve_banded((1, 1), ab, I)\n    return voltages\n\ndef create_objective_function(V_ref, L, r, ra, gm_func, I0, N):\n    \"\"\"\n    Creates the objective function for the optimization.\n    \"\"\"\n    ref_dx = L / M_REF\n    ref_centers = (np.arange(M_REF) + 0.5) * ref_dx\n\n    def objective(y):\n        \"\"\"\n        The function to be minimized.\n        y is the unconstrained parameter vector.\n        \"\"\"\n        # 1. Convert unconstrained y to constrained lengths l via softmax\n        exp_y = np.exp(y - np.max(y)) # a trick for numerical stability\n        lengths = L * exp_y / np.sum(exp_y)\n\n        # 2. Solve the reduced model with these lengths\n        V_reduced = solve_model(lengths, L, r, ra, gm_func, I0)\n\n        # 3. Create the piecewise-constant voltage profile on the fine grid\n        boundaries = np.cumsum(lengths)\n        # Find which compartment each fine grid point belongs to\n        compartment_indices = np.searchsorted(boundaries, ref_centers, side='right')\n        V_tilde = V_reduced[compartment_indices]\n\n        # 4. Calculate the integral squared error\n        error = np.sum((V_tilde - V_ref)**2) * ref_dx\n        return error\n\n    return objective\n\ndef run_case(case_params):\n    \"\"\"\n    Runs a full optimization case.\n    \"\"\"\n    L, r, ra, gm_func, I0, N = case_params\n\n    # Case N=1 has no interior boundaries to optimize\n    if N == 1:\n        return []\n\n    # 1. Generate the high-resolution reference solution\n    ref_lengths = np.full(M_REF, L / M_REF)\n    V_ref = solve_model(ref_lengths, L, r, ra, gm_func, I0)\n\n    # 2. Create the objective function\n    obj_func = create_objective_function(V_ref, L, r, ra, gm_func, I0, N)\n\n    # 3. Run the optimization\n    # Initial guess: uniform lengths (y=0 vector)\n    y0 = np.zeros(N)\n    res = minimize(obj_func, y0, method='BFGS')\n    y_opt = res.x\n\n    # 4. Convert optimal parameters to boundary positions\n    exp_y_opt = np.exp(y_opt - np.max(y_opt))\n    l_opt = L * exp_y_opt / np.sum(exp_y_opt)\n    boundaries = np.cumsum(l_opt)[:-1]\n\n    return boundaries.tolist()\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Constant gm, N=5\n        (500e-6, 0.75e-6, 1.5, lambda x: 0.01, 1e-12, 5),\n        # Case 2: Constant gm, N=1\n        (500e-6, 0.75e-6, 1.5, lambda x: 0.01, 1e-12, 1),\n        # Case 3: Linearly increasing gm, N=8\n        (500e-6, 0.75e-6, 1.5, lambda x: 0.005 + (0.02 - 0.005) * x / 500e-6, 1e-12, 8),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(result)\n\n    # Format output string to be a list of lists, without spaces.\n    str_results = []\n    for r in results:\n        # Use a compact string representation for each list of boundaries.\n        list_str = str(r).replace(\" \", \"\")\n        str_results.append(list_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        }
    ]
}