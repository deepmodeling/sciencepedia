{
    "hands_on_practices": [
        {
            "introduction": "神经递质的释放是一个内在的随机过程。这个基础练习将引导你应用经典的突触传递二项式模型，该模型是理解神经元通讯量子化本质的基石。通过计算特定数量的囊泡释放概率和预期的突触后电流，你将亲身体会到独立的、概率性的微观事件（囊泡融合）如何汇集成一个可变的、模拟的宏观信号 。",
            "id": "4053670",
            "problem": "一个神经形态突触电路被设计用于通过一个相同释放位点的阵列来模拟概率性的神经递质释放。对于每个突触前脉冲，每个位点以概率 $p$ 独立释放，并且每次成功释放都贡献一个固定的量子化突触后电流幅值 $q$，该电流在所有位点上线性叠加，没有饱和或相互作用。设位点数为 $N$，随机变量 $K$ 表示由单个脉冲触发的释放次数。假设不同位点的释放是独立同分布的伯努利试验，并且突触后电流幅值为 $I = q K$。仅使用这些假设以及独立性、组合计数和期望的定义，对于 $N = 5$，$p = 0.3$ 和 $q = 10\\ \\mathrm{pA}$，确定：\n1. 观察到恰好两个量子的概率，即 $\\mathbb{P}(K = 2)$。\n2. 期望的突触后电流幅值 $\\mathbb{E}[I]$。\n将期望幅值以皮安 ($\\mathrm{pA}$) 表示。将两个数值结果四舍五入到四位有效数字。按所列顺序以两个条目的形式提供最终答案。",
            "solution": "首先验证问题以确保其科学性、适定性和客观性。\n\n**第1步：提取已知条件**\n- 相同释放位点的数量：$N = 5$。\n- 每个脉冲下单个位点的释放概率（独立）：$p = 0.3$。\n- 每次释放的量子化突触后电流幅值：$q = 10\\ \\mathrm{pA}$。\n- 释放次数 $K$ 是一个随机变量，表示 $N$ 个位点中成功释放的次数。\n- 释放是独立同分布的伯努利试验。\n- 总突触后电流为 $I = qK$。\n- 关系是线性的，无饱和或相互作用。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学性基础：** 问题描述了突触传递的二项式模型，这是神经科学和生物物理学中一个基础且成熟的概念。参数在物理上是合理的。该问题是科学的。\n- **适定性：** 所有必要参数（$N$、$p$、$q$）均已提供。问题明确且定量。存在唯一解。\n- **客观性：** 问题使用概率论和神经科学的精确、正式语言陈述。它不含主观性断言。\n\n**第3步：结论与行动**\n问题有效。将提供完整解法。\n\n**解题推导**\n\n问题陈述有 $N$ 个独立的释放位点，每个位点在响应突触前脉冲时有概率 $p$ 释放神经递质。随机变量 $K$ 表示释放的总位点数。这种情况是 $N$ 次独立伯努利试验的经典序列，其中试验的“成功”是一次释放事件。因此，随机变量 $K$ 服从二项分布，记为 $K \\sim B(N, p)$。\n\n二项分布的概率质量函数 (PMF) 给出在 $N$ 次试验中观察到恰好 $k$ 次成功的概率，其定义为：\n$$\n\\mathbb{P}(K=k) = \\binom{N}{k} p^k (1-p)^{N-k}\n$$\n其中 $\\binom{N}{k} = \\frac{N!}{k!(N-k)!}$ 是二项式系数，表示从总共 $N$ 个位点中选择 $k$ 个成功位点的方式数量。\n\n**第1部分：观察到恰好两个量子的概率**\n\n我们需要求观察到恰好两个量子的概率，这对应于 $K=2$。给定 $N=5$ 和 $p=0.3$。我们将这些值代入 $k=2$ 的 PMF 中：\n$$\n\\mathbb{P}(K=2) = \\binom{5}{2} (0.3)^2 (1-0.3)^{5-2}\n$$\n首先，我们计算二项式系数：\n$$\n\\binom{5}{2} = \\frac{5!}{2!(5-2)!} = \\frac{5!}{2!3!} = \\frac{5 \\times 4 \\times 3 \\times 2 \\times 1}{(2 \\times 1)(3 \\times 2 \\times 1)} = \\frac{120}{12} = 10\n$$\n接下来，我们计算概率项：\n$$\np^2 = (0.3)^2 = 0.09\n$$\n$$\n(1-p)^{N-k} = (1-0.3)^{5-2} = (0.7)^3 = 0.343\n$$\n现在，我们将这些部分相乘以求得概率：\n$$\n\\mathbb{P}(K=2) = 10 \\times 0.09 \\times 0.343 = 0.3087\n$$\n题目要求四舍五入到四位有效数字。数值 $0.3087$ 已经符合此格式。\n\n**第2部分：期望的突触后电流幅值**\n\n我们需要求期望的突触后电流幅值 $\\mathbb{E}[I]$。电流 $I$ 定义为 $I = qK$，其中 $q$ 是一个常数，$K$ 是一个随机变量。\n根据期望的线性性质，我们有：\n$$\n\\mathbb{E}[I] = \\mathbb{E}[qK]\n$$\n由于 $q$ 是常数，可以从期望中提出：\n$$\n\\mathbb{E}[I] = q \\mathbb{E}[K]\n$$\n要求 $\\mathbb{E}[I]$，我们首先需要确定 $K$ 的期望值 $\\mathbb{E}[K]$。对于服从二项分布的随机变量 $K \\sim B(N, p)$，其期望值由试验次数与成功概率的乘积给出：\n$$\n\\mathbb{E}[K] = Np\n$$\n这可以从第一性原理出发，通过将 $K$ 定义为 $N$ 个独立的伯努利随机变量 $X_i$ 的和来证明，其中 $X_i=1$ 的概率为 $p$，$X_i=0$ 的概率为 $1-p$。\n$$\nK = \\sum_{i=1}^{N} X_i\n$$\n每个 $X_i$ 的期望是 $\\mathbb{E}[X_i] = 1 \\cdot p + 0 \\cdot (1-p) = p$。根据期望的线性性质：\n$$\n\\mathbb{E}[K] = \\mathbb{E}\\left[\\sum_{i=1}^{N} X_i\\right] = \\sum_{i=1}^{N} \\mathbb{E}[X_i] = \\sum_{i=1}^{N} p = Np\n$$\n代入给定值 $N=5$ 和 $p=0.3$：\n$$\n\\mathbb{E}[K] = 5 \\times 0.3 = 1.5\n$$\n这表示每个脉冲平均释放的量子数量。现在，我们可以使用给定的量子幅值 $q = 10\\ \\mathrm{pA}$ 来计算期望电流 $\\mathbb{E}[I]$：\n$$\n\\mathbb{E}[I] = q \\mathbb{E}[K] = (10\\ \\mathrm{pA}) \\times 1.5 = 15\\ \\mathrm{pA}\n$$\n题目要求此结果以皮安表示，并四舍五入到四位有效数字。该值为 $15$，写成 $15.00$ 以表示四位有效数字。\n\n最终答案是：\n1. $\\mathbb{P}(K=2) = 0.3087$\n2. $\\mathbb{E}[I] = 15.00\\ \\mathrm{pA}$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.3087 & 15.00\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "真实的突触并非一成不变的静态元件，其响应强度会随着神经活动的模式而动态变化。本实践将带你探索短期突触可塑性中的一个关键机制——突触抑制，通过模拟“可立即释放囊泡池”的耗竭过程来实现 。解决这个问题需要将突触视为一个资源有限的动态系统，这对于理解神经计算和构建更逼真的神经形态电路至关重要。",
            "id": "1722622",
            "problem": "一位神经科学家正在研究一种遗传病小鼠模型中的特定谷氨酸能突触。在这个模型中，突触蛋白 synapsin 没有功能，这完全阻止了突触囊泡从较大的“储备池”动员到“即时释放池”（RRP）。在静息状态下，该突触的 RRP 包含一个稳定的囊泡群体，数量为 $N_0 = 150$。每个囊泡填充有 $Q = 5000$ 个谷氨酸分子的量子。当一个动作电位到达突触前末梢时，当前在 RRP 中的每个囊泡都有一个固定的释放概率，$p = 0.2$。由于遗传缺陷，已释放的囊泡不会在 RRP 中得到补充。该突触受到包含 5 个连续动作电位的高频刺激序列的作用，刺激间隔非常短，以至于没有其他补充机制可以发生。计算在所有 5 次刺激中从该末梢释放的谷氨酸分子的**期望**总数。以科学记数法报告你的最终答案，并四舍五入到三位有效数字。",
            "solution": "我们将问题理解为，在概率性释放、无补充且每个囊泡最多释放一次的条件下，求释放的谷氨酸分子的期望总数。\n\n设 $N_{0}$ 是即时释放池中囊泡的初始数量，$p$ 是一个囊泡在一次动作电位下释放的概率，$Q$ 是每个囊泡中的谷氨酸分子数量，$k$ 是刺激次数。对于每个囊泡，在 $k$ 次独立的机会中它从未释放的概率是 $(1-p)^{k}$。因此，一个给定的囊泡至少释放一次的概率是 $1-(1-p)^{k}$，而释放的囊泡的期望总数是\n$$\nN_{\\text{rel}}=N_{0}\\left[1-(1-p)^{k}\\right].\n$$\n等价地，对每次脉冲的期望释放量求和，\n$$\nN_{\\text{rel}}=\\sum_{i=0}^{k-1}N_{0}p(1-p)^{i}\n= N_{0}p\\,\\frac{1-(1-p)^{k}}{1-(1-p)}=N_{0}\\left[1-(1-p)^{k}\\right],\n$$\n结果是一致的。\n\n那么，释放的谷氨酸分子的期望总数是\n$$\nM=Q\\,N_{\\text{rel}}=Q\\,N_{0}\\left[1-(1-p)^{k}\\right].\n$$\n代入 $N_{0}=150$，$Q=5000$，$p=0.2$ 和 $k=5$，\n$$\nM=5000\\times 150\\left[1-(1-0.2)^{5}\\right]\n=5000\\times 150\\left[1-0.8^{5}\\right].\n$$\n计算 $0.8^{5}=0.32768$，因此\n$$\nM=5000\\times 150\\times (1-0.32768)\n=5000\\times 150\\times 0.67232\n=5000\\times 100.848\n=504240.\n$$\n用科学记数法表示并四舍五入到三位有效数字，\n$$\nM=5.04\\times 10^{5}.\n$$",
            "answer": "$$\\boxed{5.04 \\times 10^{5}}$$"
        },
        {
            "introduction": "这项高级实践模拟了计算神经科学家和神经形态工程师的核心工作流程：将理论模型与实验数据进行拟合。本练习引入了释放延迟（或抖动）的概念，并将其建模为连续时间马尔可夫过程，你将需要使用最大似然估计从包含缺失信息（右删失）的数据中推断模型参数 。这个练习为你提供了宝贵的实践经验，让你掌握创建和验证脑启发模型所必需的统计与计算技术。",
            "id": "4053605",
            "problem": "您正在使用隐马尔可夫模型 (HMM) 对神经形态突触中的随机神经递质释放进行建模。该 HMM 有两个状态，代表囊泡停泊状态：$S=\\{\\text{primed},\\ \\text{fused}\\}$。状态 $\\text{primed}$ 是准备释放状态，状态 $\\text{fused}$ 是与释放事件同时发生的吸收态。假设从 $\\text{primed}$ 到 $\\text{fused}$ 的跃迁是无记忆的，那么从刺激开始到融合的等待时间是连续时间马尔可夫链中具有恒定风险率的首达时间。您获得了一系列试验中的释放事件时间。在某些试验中，在观测窗口内未检测到融合，这应被视为右删失。您的任务是，在无记忆假设下，估计最能拟合观测到的事件时间的从 $\\text{primed}$ 到 $\\text{fused}$ 的连续时间跃迁率，然后将该率映射到一个适合以固定模拟时间步长实现的离散时间 HMM 参数。\n\n使用的基本原理：\n- 无记忆过程的定义意味着由恒定风险率决定的指数等待时间分布。\n- 右删失对似然函数贡献了生存项。\n- 以步长 $dt$ 对连续时间马尔可夫过程进行离散时间采样，会产生与连续率相关的每步跃迁概率。\n\n定义和要求：\n- 令 $t_i$ 表示在检测到释放事件的试验 $i$ 中观测到的融合时间（单位：毫秒）。如果在观测窗口 $T_{\\mathrm{obs}}$ 内未观测到事件，则试验 $i$ 在 $T_{\\mathrm{obs}}$ 处被右删失。\n- 令 $\\lambda$ 表示从 $\\text{primed}$ 到 $\\text{fused}$ 的连续时间跃迁率，单位为 $\\mathrm{ms}^{-1}$。\n- 令 $p$ 表示使用固定时间步长 $dt$（单位：毫秒）的离散时间 HMM 中的每步跃迁概率。\n- 将连续时间抖动定义为在指数等待时间假设下释放时间的标准差，以 $\\mathrm{ms}$ 表示。\n- 将离散时间抖动定义为以离散步长测量的释放时间的标准差，然后乘以 $dt$ 换算为 $\\mathrm{ms}$。\n\n从第一性原理出发，不使用快捷公式，推导在无记忆假设下带有右删失的观测数据的似然函数。由此，获得 $\\lambda$ 的最大似然估计，然后对于给定的 $dt$，将 $\\lambda$ 映射到 $p$。对于下方的每个测试用例，计算：\n- 估计的 $\\lambda$，单位为 $\\mathrm{ms}^{-1}$。\n- 针对所提供 $dt$ 的相应 $p$。\n- 预测的连续时间抖动，单位为 $\\mathrm{ms}$。\n- 预测的离散时间抖动，单位为 $\\mathrm{ms}$。\n- 一个布尔值，指示预测的连续时间抖动是否在 $[0.2, 0.5]$ 毫秒（含）的目标范围内。\n\n输入数据（嵌入到您的程序中）：\n每个测试用例是一个元组 $(\\text{event\\_times}, T_{\\mathrm{obs}}, dt)$，其中 $\\text{event\\_times}$ 是一个融合时间的列表（单位：毫秒），$\\text{None}$ 表示在 $T_{\\mathrm{obs}}$ 处的一个右删失试验。使用以下测试套件：\n- Case A: $\\text{event\\_times}=(0.12, 0.29, 0.31, 0.27, 0.42, 0.33, 0.24, 0.36)$, $T_{\\mathrm{obs}}=1.0\\ \\mathrm{ms}$, $dt=0.01\\ \\mathrm{ms}$。\n- Case B: $\\text{event\\_times}=(0.42, 0.58, 0.59, 0.50, 0.41)$, $T_{\\mathrm{obs}}=1.0\\ \\mathrm{ms}$, $dt=0.01\\ \\mathrm{ms}$。\n- Case C: $\\text{event\\_times}=(0.18, \\text{None}, 0.23, \\text{None}, \\text{None}, 0.19)$, $T_{\\mathrm{obs}}=0.3\\ \\mathrm{ms}$, $dt=0.05\\ \\mathrm{ms}$。\n- Case D: $\\text{event\\_times}=(0.18, 0.16, 0.22, 0.20, 0.19, 0.21, 0.17, 0.23, 0.18, 0.19)$, $T_{\\mathrm{obs}}=1.0\\ \\mathrm{ms}$, $dt=0.005\\ \\mathrm{ms}$。\n- Case E: $\\text{event\\_times}=(0.21)$, $T_{\\mathrm{obs}}=1.0\\ \\mathrm{ms}$, $dt=0.01\\ \\mathrm{ms}$。\n\n角度单位不适用。$\\lambda$ 以 $\\mathrm{ms}^{-1}$ 表示，所有抖动值以 $\\mathrm{ms}$ 表示。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表用方括号括起来，每个测试用例的结果是一个形如 $[\\lambda, p, J_{\\mathrm{cont}}, J_{\\mathrm{disc}}, \\text{ok}]$ 的列表，其中 $\\lambda$ 和 $p$ 为浮点数，$J_{\\mathrm{cont}}$ 和 $J_{\\mathrm{disc}}$ 为浮点数，$\\text{ok}$ 为布尔值。例如：$[[\\lambda_1,p_1,J_{\\mathrm{cont},1},J_{\\mathrm{disc},1},\\text{ok}_1],[\\lambda_2,p_2,J_{\\mathrm{cont},2},J_{\\mathrm{disc},2},\\text{ok}_2],\\dots]$。",
            "solution": "问题陈述已分析并确认有效。它在科学上是合理的、适定的、客观且自洽的，没有明显的矛盾或歧义。其中涉及的连续时间马尔可夫链、指数等待时间分布、带删失数据的最大似然估计以及连续过程的离散化等基本原理都是标准的，并且应用正确。因此，我们可以进行形式化的求解。\n\n任务是从一组包含右删失数据的事件时间中估计一个连续时间跃迁率 $\\lambda$，然后推导出一个离散时间模型的相关参数。\n\n### 1. 带删失数据的似然函数\n\n问题陈述指出，从“已准备”(primed)状态到“已融合”(fused)状态的跃迁是一个无记忆过程。一个无记忆的连续时间过程意味着事件（融合）的等待时间 $T$ 服从指数分布。该分布的概率密度函数 (PDF) 为：\n$$ f(t; \\lambda) = \\lambda e^{-\\lambda t} \\quad \\text{for } t \\ge 0 $$\n其中 $\\lambda$ 是恒定的风险率，在此情境下，是从“已准备”到“已融合”的跃迁率，单位为 $\\mathrm{ms}^{-1}$。\n\n相应的累积分布函数 (CDF)，它给出事件在时间 $t$ 之前发生的概率，是：\n$$ F(t; \\lambda) = \\int_0^t \\lambda e^{-\\lambda \\tau} d\\tau = \\left[ -e^{-\\lambda \\tau} \\right]_0^t = 1 - e^{-\\lambda t} $$\n生存函数 $S(t; \\lambda)$，它给出事件在时间 $t$ 之前*没有*发生的概率，是：\n$$ S(t; \\lambda) = 1 - F(t; \\lambda) = e^{-\\lambda t} $$\n给定数据由一组试验组成。对于每个试验，我们或者有一个检测到的融合时间 $t_i$，或者在观测窗口时间 $T_{\\mathrm{obs}}$ 处有一次右删失。设观测到的融合时间集合为 $D = \\{t_1, t_2, \\dots, t_{N_D}\\}$，右删失试验的数量为 $N_C$。\n\n- 对于在时间 $t_i$ 观测到融合的试验，其对参数 $\\lambda$ 的总似然的贡献是 PDF 在 $t_i$ 处的值，即 $f(t_i; \\lambda)$。\n- 对于在 $T_{\\mathrm{obs}}$ 处右删失的试验，我们只知道融合时间大于 $T_{\\mathrm{obs}}$。此事件的概率由生存函数在 $T_{\\mathrm{obs}}$ 处的值给出，即 $S(T_{\\mathrm{obs}}; \\lambda)$。\n\n假设试验之间相互独立，总似然函数 $L(\\lambda)$ 是这些单个概率的乘积：\n$$ L(\\lambda) = \\left( \\prod_{i=1}^{N_D} f(t_i; \\lambda) \\right) \\cdot \\left( S(T_{\\mathrm{obs}}; \\lambda) \\right)^{N_C} $$\n代入 PDF 和生存函数的表达式：\n$$ L(\\lambda) = \\left( \\prod_{i=1}^{N_D} \\lambda e^{-\\lambda t_i} \\right) \\cdot \\left( e^{-\\lambda T_{\\mathrm{obs}}} \\right)^{N_C} $$\n$$ L(\\lambda) = \\lambda^{N_D} \\left( \\prod_{i=1}^{N_D} e^{-\\lambda t_i} \\right) \\cdot e^{-\\lambda N_C T_{\\mathrm{obs}}} $$\n$$ L(\\lambda) = \\lambda^{N_D} \\exp\\left(-\\lambda \\sum_{i=1}^{N_D} t_i\\right) \\exp\\left(-\\lambda N_C T_{\\mathrm{obs}}\\right) $$\n$$ L(\\lambda) = \\lambda^{N_D} \\exp\\left(-\\lambda \\left( \\sum_{i=1}^{N_D} t_i + N_C T_{\\mathrm{obs}} \\right)\\right) $$\n\n### 2. $\\lambda$ 的最大似然估计\n\n为了找到使似然函数最大化的 $\\lambda$ 值，数学上更方便的是最大化对数似然 $\\mathcal{L}(\\lambda) = \\ln L(\\lambda)$。\n$$ \\mathcal{L}(\\lambda) = \\ln\\left( \\lambda^{N_D} \\exp\\left(-\\lambda \\left( \\sum_{i=1}^{N_D} t_i + N_C T_{\\mathrm{obs}} \\right)\\right) \\right) $$\n$$ \\mathcal{L}(\\lambda) = N_D \\ln \\lambda - \\lambda \\left( \\sum_{i=1}^{N_D} t_i + N_C T_{\\mathrm{obs}} \\right) $$\n我们通过对 $\\mathcal{L}(\\lambda)$ 关于 $\\lambda$ 求导并令其为零来找到最大值：\n$$ \\frac{d\\mathcal{L}}{d\\lambda} = \\frac{N_D}{\\lambda} - \\left( \\sum_{i=1}^{N_D} t_i + N_C T_{\\mathrm{obs}} \\right) = 0 $$\n求解最大似然估计 $\\hat{\\lambda}$：\n$$ \\frac{N_D}{\\hat{\\lambda}} = \\sum_{i=1}^{N_D} t_i + N_C T_{\\mathrm{obs}} $$\n$$ \\hat{\\lambda} = \\frac{N_D}{\\sum_{i=1}^{N_D} t_i + N_C T_{\\mathrm{obs}}} $$\n这个估计量可以直观地解释为观测到的事件数除以观测到系统处于“已准备”状态的总时间。\n\n### 3. 映射到离散时间概率 $p$\n\n连续时间过程将由一个时间步长为 $dt$ 的离散时间 HMM 来近似。在连续模型中，在“已准备”状态下保持至少 $dt$ 时长的概率由生存函数 $S(dt) = e^{-\\lambda dt}$ 给出。这对应于在离散模型中，在单个时间步内不跃迁到“已融合”状态的概率。设 $p$ 为从“已准备”跃迁到“已融合”的每步概率。那么保持在“已准备”状态的概率是 $1-p$。将两者相等：\n$$ 1 - p = e^{-\\lambda dt} $$\n求解 $p$ 得到映射关系：\n$$ p = 1 - e^{-\\lambda dt} $$\n我们将使用估计的率 $\\hat{\\lambda}$ 来计算估计的概率 $\\hat{p}$。\n\n### 4. 连续和离散抖动的计算\n\n**连续时间抖动 ($J_{\\mathrm{cont}}$):**\n问题将连续时间抖动定义为在指数等待时间假设下释放时间的标准差。等待时间 $T$ 是一个服从率参数为 $\\lambda$ 的指数分布的随机变量。这种分布的方差是 $\\mathrm{Var}(T) = 1/\\lambda^2$。标准差是方差的平方根。\n$$ J_{\\mathrm{cont}} = \\sigma_T = \\sqrt{\\frac{1}{\\lambda^2}} = \\frac{1}{\\lambda} $$\n\n**离散时间抖动 ($J_{\\mathrm{disc}}$):**\n在离散时间模型中，直到发生融合事件的步数 $K$ 服从成功概率为 $p$ 的几何分布。其概率质量函数为 $P(K=k) = (1-p)^{k-1}p$，其中 $k=1, 2, 3, \\dots$。\n几何分布的方差由下式给出：\n$$ \\mathrm{Var}(K) = \\frac{1-p}{p^2} $$\n步数的标准差是 $\\sigma_K = \\sqrt{\\mathrm{Var}(K)} = \\frac{\\sqrt{1-p}}{p}$。离散时间抖动 $J_{\\mathrm{disc}}$ 是这个标准差按时间步长 $dt$ 缩放，以将其转换为时间单位 (ms)。\n$$ J_{\\mathrm{disc}} = \\sigma_K \\cdot dt = \\frac{\\sqrt{1-p}}{p} dt $$\n使用关系式 $1-p = e^{-\\lambda dt}$，这也可以用 $\\lambda$ 来表示：\n$$ J_{\\mathrm{disc}} = \\frac{\\sqrt{e^{-\\lambda dt}}}{1 - e^{-\\lambda dt}} dt = \\frac{e^{-\\lambda dt/2}}{1 - e^{-\\lambda dt}} dt $$\n当 $dt \\to 0$ 时，$J_{\\mathrm{disc}}$ 趋近于 $1/\\lambda$，即 $J_{\\mathrm{cont}}$。\n\n### 5. 最终计算\n\n对于每个测试用例，将按顺序计算以下量：\n1.  使用推导出的 MLE 公式计算估计率 $\\hat{\\lambda}$。\n2.  相应的离散概率 $\\hat{p} = 1 - e^{-\\hat{\\lambda} dt}$。\n3.  预测的连续时间抖动 $J_{\\mathrm{cont}} = 1/\\hat{\\lambda}$。如果 $\\hat{\\lambda}=0$，$J_{\\mathrm{cont}}$ 为无穷大。\n4.  预测的离散时间抖动 $J_{\\mathrm{disc}} = \\frac{\\sqrt{1-\\hat{p}}}{\\hat{p}} dt$。如果 $\\hat{p}=0$，$J_{\\mathrm{disc}}$ 为无穷大。\n5.  一个布尔标志，指示 $J_{\\mathrm{cont}}$ 是否在 $[0.2, 0.5]$（含）范围内。\n\n这些计算在提供的 Python 代码中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating parameters for a neuromorphic synapse model\n    based on stochastic neurotransmitter release, modeled as a continuous-time\n    Markov process with right-censored data.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        (\n            [0.12, 0.29, 0.31, 0.27, 0.42, 0.33, 0.24, 0.36],\n            1.0,  # T_obs in ms\n            0.01  # dt in ms\n        ),\n        # Case B\n        (\n            [0.42, 0.58, 0.59, 0.50, 0.41],\n            1.0,\n            0.01\n        ),\n        # Case C\n        (\n            [0.18, None, 0.23, None, None, 0.19],\n            0.3,\n            0.05\n        ),\n        # Case D\n        (\n            [0.18, 0.16, 0.22, 0.20, 0.19, 0.21, 0.17, 0.23, 0.18, 0.19],\n            1.0,\n            0.005\n        ),\n        # Case E\n        (\n            [0.21],\n            1.0,\n            0.01\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        event_times, T_obs, dt = case\n\n        # Separate observed events from censored trials\n        observed_times = [t for t in event_times if t is not None]\n        \n        # Count number of observed (N_D) and censored (N_C) trials\n        N_D = len(observed_times)\n        N_C = len(event_times) - N_D\n\n        # Sum of observed event times\n        sum_t = sum(observed_times)\n        \n        # Calculate the denominator for the MLE of lambda\n        # This is the total observed time\n        total_time = sum_t + N_C * T_obs\n\n        # Step 1: Compute the Maximum Likelihood Estimate (MLE) of lambda\n        # lambda_hat = N_D / (sum of observed times + sum of censoring times)\n        if N_D == 0:\n            # If no events are observed, the MLE of lambda is 0.\n            # The likelihood function is monotonically decreasing.\n            lambda_est = 0.0\n        elif total_time == 0:\n            # This case (events at time 0, no censoring) leads to infinite rate.\n            # Not present in test data, but handled for robustness.\n            lambda_est = float('inf')\n        else:\n            lambda_est = N_D / total_time\n\n        # Step 2: Map lambda to the discrete-time probability p\n        # p = 1 - exp(-lambda * dt)\n        if np.isinf(lambda_est):\n            p_est = 1.0\n        else:\n            p_est = 1.0 - np.exp(-lambda_est * dt)\n\n        # Step 3: Compute the continuous-time jitter J_cont\n        # J_cont = 1 / lambda\n        if lambda_est == 0:\n            J_cont = float('inf')\n        else:\n            J_cont = 1.0 / lambda_est\n            \n        # Step 4: Compute the discrete-time jitter J_disc\n        # J_disc = std_dev(Geometric(p)) * dt = (sqrt(1-p)/p) * dt\n        if p_est == 0:\n            J_disc = float('inf')\n        elif p_est == 1:\n            J_disc = 0.0\n        else:\n            J_disc = (np.sqrt(1.0 - p_est) / p_est) * dt\n\n        # Step 5: Check if continuous-time jitter is within the target range\n        jitter_target_min = 0.2\n        jitter_target_max = 0.5\n        ok = (jitter_target_min = J_cont = jitter_target_max)\n\n        # Append the list of results for this case\n        results.append([lambda_est, p_est, J_cont, J_disc, ok])\n\n    # Final print statement in the exact required format.\n    # The str() conversion of the inner lists handles the formatting correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}