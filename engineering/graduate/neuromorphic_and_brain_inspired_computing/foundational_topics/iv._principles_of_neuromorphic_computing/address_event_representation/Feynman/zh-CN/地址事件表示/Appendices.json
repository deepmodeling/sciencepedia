{
    "hands_on_practices": [
        {
            "introduction": "本练习将从基于事件的数据的核心——时间精度——入手。一个地址事件表示（AER）事件代表了“何时”与“何地”。本练习旨在探索“何时”这一信息精度的基本限制。通过对连续时间脉冲转换为离散数字时间戳的过程进行建模，你将推导出该过程中固有的量化误差 。这项分析对于理解任何神经形态系统的时间分辨率，以及时钟频率如何直接影响其表示时间的能力至关重要。",
            "id": "4034506",
            "problem": "考虑一个地址事件表示 (AER) 系统，其中地址事件表示 (AER) 是一种异步通信协议，它将神经脉冲作为事件进行传输，每个事件都标记有其源地址和关联的时间。在该系统中，每个发生在真实连续时间 $t$ 的脉冲都被分配一个时间戳，该时间戳由一个时钟频率为 $f_c$ 的自由运行数字计数器生成，该计数器使用一个 $B_t$ 位的寄存器来保存其状态。计数器状态在每个时钟滴答时递增，并以 $2^{B_t}$ 为模进行回绕。解码器通过将记录的整数计数器状态（在经过理想展开以正确处理回绕后）除以时钟频率，来以秒为单位重建脉冲时间。\n\n假设如下：\n- 对于时间 $t$ 发生的脉冲，其记录的整数时间戳是不超过 $f_c t$ 的最大整数计数值。\n- 以秒为单位的重建时间是记录的计数值除以 $f_c$。\n- 脉冲序列是平稳的，相对于时钟的脉冲时间分布由 $f_c t$ 的小数部分 $\\phi \\in [0,1)$ 的概率密度 $p_{\\phi}(\\phi)$ 表征。\n\n从这些定义出发，推导重建脉冲时间中的量化误差，并将整个脉冲分布上的平均绝对误差表示为以 $f_c$ 和 $p_{\\phi}(\\phi)$ 表示的闭式解析表达式。清楚地说明在何种假设下，$B_t$ 会或不会影响量化误差。将最终的以秒为单位的平均绝对误差表示为一个精确表达式；不要提供任何数值近似，也不要进行四舍五入。",
            "solution": "该问题要求推导地址事件表示 (AER) 系统中的平均绝对量化误差。验证过程确认了该问题具有科学依据、是适定的、客观的，并包含了推导解决方案所需的所有必要信息。\n\n设 $t$ 为脉冲事件的真实连续时间。系统使用一个时钟频率为 $f_c$ 的数字计数器。为脉冲记录的整数时间戳（记为 $C(t)$）被定义为不超过 $f_c t$ 的最大整数计数值。这可以用向下取整函数（floor function）表示：\n$$ C(t) = \\lfloor f_c t \\rfloor $$\n重建时间 $t_{rec}$ 是通过将此整数计数值除以时钟频率得到的。问题指明这是在对计数器进行理想展开后完成的，这意味着我们可以使用完整的、未经回绕的整数计数值 $C(t)$。\n$$ t_{rec} = \\frac{C(t)}{f_c} = \\frac{\\lfloor f_c t \\rfloor}{f_c} $$\n量化误差 $\\epsilon$ 是重建时间与真实时间之差：\n$$ \\epsilon(t) = t_{rec} - t = \\frac{\\lfloor f_c t \\rfloor}{f_c} - t $$\n为了分析这个误差，我们使用为 $f_c t$ 的小数部分提供的定义。设 $\\phi$ 为此小数部分，使得 $\\phi \\in [0, 1)$。任何实数都可以表示为其整数部分和小数部分之和。因此，我们有：\n$$ f_c t = \\lfloor f_c t \\rfloor + \\phi $$\n我们可以重新整理这个方程，用相对于时钟周期的整数和分数分量来表示真实时间 $t$：\n$$ t = \\frac{\\lfloor f_c t \\rfloor + \\phi}{f_c} $$\n将这个 $t$ 的表达式代入误差 $\\epsilon(t)$ 的方程中：\n$$ \\epsilon(t) = \\frac{\\lfloor f_c t \\rfloor}{f_c} - \\left( \\frac{\\lfloor f_c t \\rfloor + \\phi}{f_c} \\right) = \\frac{\\lfloor f_c t \\rfloor - \\lfloor f_c t \\rfloor - \\phi}{f_c} = -\\frac{\\phi}{f_c} $$\n这个结果表明量化误差总是负数或零，其大小与 $f_c t$ 的小数部分 $\\phi$ 成正比。这是符合直觉的：重建时间对应于事件发生前的最后一个离散时钟滴答，因此真实时间总是领先于重建时间，领先的量对应于时钟周期 $1/f_c$ 内的相位 $\\phi$。\n\n问题要求的是平均绝对误差，记为 $\\langle |\\epsilon| \\rangle$。绝对误差为：\n$$ |\\epsilon| = \\left| -\\frac{\\phi}{f_c} \\right| = \\frac{\\phi}{f_c} $$\n绝对误差的平均值（或期望值）是通过在脉冲时间的分布上进行平均来计算的。问题指出，这个分布由小数部分 $\\phi$ 的概率密度函数 $p_{\\phi}(\\phi)$ 来表征。因此，平均绝对误差是 $|\\epsilon|$ 关于此分布的期望值：\n$$ \\langle |\\epsilon| \\rangle = E\\left[\\frac{\\phi}{f_c}\\right] = \\int_{0}^{1} \\frac{\\phi}{f_c} p_{\\phi}(\\phi) \\,d\\phi $$\n由于时钟频率 $f_c$ 是一个常数，它可以从积分中提出来：\n$$ \\langle |\\epsilon| \\rangle = \\frac{1}{f_c} \\int_{0}^{1} \\phi \\, p_{\\phi}(\\phi) \\,d\\phi $$\n这个表达式用给定的量 $f_c$ 和 $p_{\\phi}(\\phi)$ 表示了平均绝对量化误差。根据定义，积分 $\\int_{0}^{1} \\phi \\, p_{\\phi}(\\phi) \\,d\\phi$ 是随机变量 $\\phi$ 的平均值，我们可以将其记为 $\\langle \\phi \\rangle$。因此，平均绝对误差也可以写成 $\\frac{\\langle \\phi \\rangle}{f_c}$。该积分形式就是所要求的完整解析表达式。\n\n关于计数器位宽 $B_t$ 的影响，问题陈述中包含了一个关键假设，即“理想展开以正确处理回绕”。当计数值 $\\lfloor f_c t \\rfloor$ 超过 $B_t$ 位可表示的最大值 $2^{B_t}-1$ 时，计数器会发生回绕。理想展开意味着真实的连续计数值 $\\lfloor f_c t \\rfloor$ 总是可以从回绕的时间戳序列中恢复。如果连续事件之间的时间间隔小于计数器的回绕周期 $T_{wrap} = 2^{B_t} / f_c$，这一点是可以实现的。\n由于我们对量化误差 $\\epsilon = - \\phi / f_c$ 的推导仅依赖于（通过 $\\phi$ 的定义得出的）展开后的计数值 $\\lfloor f_c t \\rfloor$，因此*在理想展开的假设下*，寄存器的大小 $B_t$ 不会影响量化误差。量化误差是时间离散化（由 $f_c$ 决定）的结果，而不是计数器寄存器有限范围的结果。如果展开不是理想的，那么回绕可能会在 $t_{rec}$ 中引入巨大的灾难性误差，在这种情况下，$B_t$ 将成为决定此类故障频率的关键参数。",
            "answer": "$$\\boxed{\\frac{1}{f_c} \\int_{0}^{1} \\phi \\, p_{\\phi}(\\phi) \\,d\\phi}$$"
        },
        {
            "introduction": "在理解了事件如何编码之后，我们转向其传输所面临的挑战。AER系统依赖异步握手协议来高效地通信事件。本练习将深入物理层，要求你分析普遍使用的四相握手协议，并推导出理论上的最大事件吞吐量 。掌握这一计算方法，将为你深入理解AER硬件的带宽限制以及决定其性能的关键参数奠定坚实基础。",
            "id": "4034508",
            "problem": "考虑一个地址事件表示（AER）互连，它使用异步的四相归零握手协议，在单个事件源和单个事件接收器之间通过承载$W$位宽度地址的单通道总线传输事件。这四个握手阶段由来自源的请求（REQ）信号和来自接收器的确认（ACK）信号驱动。在一次完整的事件传输中，会发生以下序列：REQ 变为高电平，然后 ACK 变为高电平，然后 REQ 变为低电平，然后 ACK 变为低电平，此后下一个事件才可以开始。假设所有事件都是原子的且不重叠，并且不需要仲裁。\n\n存在以下物理约束：\n- 每个握手转换及其相应的端到端传播、采样和稳定都需要一个固定的最小时间 $d$，以确保两端的正确性和无风险操作，由于适当的缓冲和锁存，这个时间与 $W$ 无关。\n- $W$位的地址仅在适当的握手窗口期间呈现和锁存，数据路径不会引入超出所述的每阶段延迟 $d$ 的额外时间。\n- 不允许流水线操作或阶段重叠；一个事件的四个握手阶段必须顺序完成后，下一个事件才能开始。\n\n从吞吐量的基本定义（单位时间内的事件数）和四相归零握手协议的语义出发，推导以 $d$ 表示的理论最大事件吞吐量，并论证 $W$ 是否以及如何影响此上限。以每秒事件数为单位表示最大事件吞吐量的最终答案。没有提供数值；您的答案必须是单个封闭形式的表达式。不要四舍五入。以每秒事件数为单位陈述您对吞吐量的最终表达式。",
            "solution": "该问题要求推导使用四相归零握手协议的地址事件表示（AER）互连的理论最大事件吞吐量。\n\n首先，我们建立基本定义。吞吐量，表示为 $R$，是单位时间内传输的事件数量。理论最大吞吐量 $R_{max}$，在每次事件传输所需时间为最小值时达到。如果 $T_{event}$ 是完成一次完整事件传输所需的时间，那么最大吞吐量是可能的最短传输时间 $T_{min}$ 的倒数。\n\n$$R_{max} = \\frac{1}{T_{min}}$$\n\n问题陈述，每个事件都通过异步的四相归零握手协议传输。对于单个、完整、不重叠的事件传输，其序列如下：\n1.  源断言请求信号（REQ 变为高电平）。\n2.  接收器在收到高电平的 REQ 后，断言确认信号（ACK 变为高电平）。\n3.  源在收到高电平的 ACK 后，撤销请求信号（REQ 变为低电平）。\n4.  接收器在收到低电平的 REQ 后，撤销确认信号（ACK 变为低电平）。\n\n系统只有在所有四个阶段完成后才能开始下一次事件传输。一个事件的总时间 $T_{event}$ 是这四个顺序阶段持续时间的总和。\n\n我们来分析每个阶段的时间。问题提供了一个关键约束：“每个握手转换及其相应的端到端传播、采样和稳定都需要一个固定的最小时间 $d$，以确保两端的正确性和无风险操作”。这意味着握手序列中的四个步骤中的每一步都会引入至少 $d$ 的延迟。\n\n-   **阶段1持续时间 ($T_1$)**: 源断言 REQ。信号传播到接收器。这需要最短时间 $d$。\n-   **阶段2持续时间 ($T_2$)**: 接收器通过断言 ACK 来响应。此信号传播回源。这也需要最短时间 $d$。\n-   **阶段3持续时间 ($T_3$)**: 源撤销 REQ。信号传播到接收器。这需要最短时间 $d$。\n-   **阶段4持续时间 ($T_4$)**: 接收器通过撤销 ACK 来响应。此信号传播回源，完成循环。这也需要最短时间 $d$。\n\n由于问题陈述不允许流水线操作或阶段重叠，一次事件传输的最短总时间 $T_{min}$ 是四个阶段各自最短时间的总和：\n$$T_{min} = T_1 + T_2 + T_3 + T_4 = d + d + d + d = 4d$$\n\n现在，我们可以将这个最短事件时间代入最大吞吐量的表达式中：\n$$R_{max} = \\frac{1}{T_{min}} = \\frac{1}{4d}$$\n\n$d$ 的单位是时间，因此 $R_{max}$ 的单位是单位时间内的事件数，或按要求为每秒事件数。\n\n问题的第二部分要求论证地址宽度 $W$ 是否以及如何影响此上限。问题陈述提供了直接回答这个问题的明确约束：\n1.  “……一个固定的最小时间 $d$ ……由于适当的缓冲和锁存，**与 $W$ 无关**。”\n2.  “……数据路径不会引入**超出所述的每阶段延迟 $d$ 的额外时间**。”\n\n这些陈述定义了模型的假设。它们要求我们将每阶段延迟 $d$ 视为系统时序的基本常数，所有其他时序效应，包括任何与宽度为 $W$ 的并行数据路径相关的效应，都已包含在其中。根据问题中提供的严格定义，$W$ 的值在时序计算中不作为独立变量出现。因此，在此模型的限制内，理论最大事件吞吐量与地址宽度 $W$ 无关。吞吐量仅由基本握手延迟 $d$ 决定。\n\n因此，最大事件吞吐量的最终表达式仅是 $d$ 的函数。",
            "answer": "$$\\boxed{\\frac{1}{4d}}$$"
        },
        {
            "introduction": "传输事件的最终目的是在更宏大的系统中驱动计算和通信。这最后一个练习将搭建起AER数据流与其在脉冲神经网络模型中应用之间的桥梁。你将通过实现一个回放机制，从AER日志中重建泄漏整合神经元的动态状态 。这个动手编程练习将巩固你对离散事件序列如何转化为连续时间动态的理解，而这正是受脑启发计算的一个核心原则。",
            "id": "4034548",
            "problem": "您面临一个在地址-事件表示法（Address-Event Representation，AER）背景下的事件驱动状态重构问题。任务是实现一个重放机制，从 AER 日志中重构一组地址索引的泄漏累加器的最终状态，并根据平均事件率和每事件记录大小计算实时重放所需的内存吞吐量。重放必须基于线性时不变动力学和量纲分析的第一性原理。\n\n定义和假设：\n\n- 每个事件是一个元组 $(t_k, a_k, p_k)$，其中 $t_k$ 是事件时间（秒），$a_k \\in \\{0,1,\\dots,N-1\\}$ 是整数地址，$p_k \\in \\{-1,+1\\}$ 是极性。\n- 地址 $i$ 处的状态表示为 $x_i(t)$，并根据带有冲激输入的泄漏积分器动力学演化。在事件之间，演化遵循 $dx_i(t)/dt=-x_i(t)/\\tau$，其中 $\\tau>0$ 是一个固定的时间常数（秒）。在该地址的事件发生时，状态会受到一个幅度为 $\\alpha\\,p_k$ 的瞬时跳变，其中 $\\alpha>0$ 是一个固定的标量增益。\n- 初始条件为对所有地址 $i$，都有 $x_i(0)=0$。只有时间 $t_k$ 满足 $0\\le t_k\\le T_{\\text{end}}$ 的事件才会对 $t=T_{\\text{end}}$ 时的最终状态有贡献。\n- 每个事件的事件记录大小是一个固定常数 $S$（字节/事件），平均事件率为 $\\bar{\\lambda}$（事件/秒）。实时重放所需的内存吞吐量定义为系统为以平均速率处理事件而无积压所必须维持的最小数据速率（字节/秒）。\n\n您的程序必须：\n\n1. 使用 AER 日志和上述泄漏积分器模型，重构最终状态向量 $x(T_{\\text{end}})=[x_0(T_{\\text{end}}),\\dots,x_{N-1}(T_{\\text{end}})]$，并纯粹用给定的事件来表示。\n2. 基于量纲分析和无排队的实时重放假设，计算所需内存吞吐量作为平均事件率和每事件记录大小的函数，单位为字节/秒。\n\n内存吞吐量以字节/秒表示，所有时间以秒表示。角度不适用。结果必须是数值，并四舍五入到六位小数。最终输出必须是单行，形式为一个用方括号括起来的逗号分隔列表，其中每个元素本身是一个双元素列表 $[B, \\|x(T_{\\text{end}})\\|_2]$，包含：\n- $B$：内存吞吐量，单位为字节/秒（四舍五入到六位小数），\n- $\\|x(T_{\\text{end}})\\|_2$：最终状态向量的欧几里得范数（四舍五入到六位小数）。\n\n测试套件（每个案例指定 $(N,\\tau,\\alpha,T_{\\text{end}},\\text{events},\\bar{\\lambda},S)$）：\n\n- 案例 A（通用正常路径）：\n  - $N=4$, $\\tau=0.05$, $\\alpha=0.5$, $T_{\\text{end}}=0.10$,\n  - events $[(0.01,0,+1),(0.02,1,+1),(0.04,0,-1),(0.08,3,+1)]$,\n  - $\\bar{\\lambda}=3000$ (事件/秒), $S=12$ (字节/事件)。\n\n- 案例 B（零事件和零平均率的边界情况）：\n  - $N=5$, $\\tau=0.10$, $\\alpha=1.0$, $T_{\\text{end}}=1.00$,\n  - events $[\\ ]$,\n  - $\\bar{\\lambda}=0$ (事件/秒), $S=16$ (字节/事件)。\n\n- 案例 C（包含重复地址的未排序事件时间）：\n  - $N=3$, $\\tau=0.20$, $\\alpha=1.0$, $T_{\\text{end}}=0.30$,\n  - events $[(0.25,2,+1),(0.05,2,+1),(0.10,2,-1),(0.15,1,+1),(0.18,1,+1)]$,\n  - $\\bar{\\lambda}=10000$ (事件/秒), $S=20$ (字节/事件)。\n\n- 案例 D（记录大小为零但事件集非零的边界情况）：\n  - $N=2$, $\\tau=0.05$, $\\alpha=2.0$, $T_{\\text{end}}=0.05$,\n  - events $[(0.01,0,+1),(0.02,0,+1),(0.03,1,-1)]$,\n  - $\\bar{\\lambda}=5000$ (事件/秒), $S=0$ (字节/事件)。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果，其中每个元素是对应测试案例的双元素列表 $[B,\\|x(T_{\\text{end}})\\|_2]$，例如 $[[B_A,\\|x_A\\|_2],[B_B,\\|x_B\\|_2],[B_C,\\|x_C\\|_2],[B_D,\\|x_D\\|_2]]$。输出中的所有数值必须四舍五入到六位小数。",
            "solution": "问题陈述经评估有效。它在科学上基于线性时不变 (LTI) 系统和量纲分析的原理，问题设定适定，为获得唯一解提供了所有必要信息，并且其语言和定义是客观的。\n\n解决方案分为两部分：内存吞吐量的计算和最终状态向量的重构。\n\n**1. 内存吞吐量计算**\n\n所需的内存吞吐量 $B$ 定义为系统为实时处理事件而无积压所必须维持的最小数据速率。这由数据到达的平均速率决定。问题提供了两个关键参数：\n- 平均事件率 $\\bar{\\lambda}$，单位为事件/秒。\n- 每事件记录大小 $S$，单位为字节/事件。\n\n使用量纲分析，我们可以确定内存吞吐量。我们寻求一个单位为字节/秒的量。\n$\\bar{\\lambda}$ 的单位是 $[\\bar{\\lambda}] = \\frac{\\text{事件}}{\\text{秒}}$。\n$S$ 的单位是 $[S] = \\frac{\\text{字节}}{\\text{事件}}$。\n\n为了得到以字节/秒为单位的结果，我们将这两个量相乘：\n$$ B = \\bar{\\lambda} \\times S $$\n单位也相乘：\n$$ [B] = \\left(\\frac{\\text{事件}}{\\text{秒}}\\right) \\times \\left(\\frac{\\text{字节}}{\\text{事件}}\\right) = \\frac{\\text{字节}}{\\text{秒}} $$\n这证实了内存吞吐量 $B$ 是平均事件率和每事件记录大小的简单乘积。\n\n**2. 最终状态重构**\n\n每个地址 $i$ 的累加器状态 $x_i(t)$ 由一个泄漏积分器模型控制。这是一个描述事件之间动力学的一阶线性常微分方程：\n$$ \\frac{dx_i(t)}{dt} = -\\frac{x_i(t)}{\\tau} $$\n其中 $\\tau$ 是时间常数。给定时间 $t_a$ 时的状态 $x_i(t_a)$，在稍后的时间 $t_b > t_a$，状态将根据以下公式指数衰减至 $x_i(t_b)$：\n$$ x_i(t_b) = x_i(t_a) e^{-(t_b - t_a)/\\tau} $$\n在地址 $a_k=i$ 的事件时间 $t_k$，状态受到一个冲激输入，导致一个瞬时跳变：\n$$ x_i(t_k^+) = x_i(t_k^-) + \\alpha p_k $$\n其中 $x_i(t_k^-)$ 和 $x_i(t_k^+)$ 分别是事件发生前后的状态，$\\alpha$ 是增益，$p_k$ 是事件极性。\n\n该系统是一个线性时不变 (LTI) 系统。因此，叠加原理适用。在时间 $T_{\\text{end}}$ 的最终状态是初始条件 $x_i(0)=0$ 下对每个独立事件冲激的响应之和。\n\n考虑一个单一事件 $(t_k, a_k, p_k)$，其中 $a_k = i$。该事件在时间 $t_k$ 对状态 $x_i$ 引入一个 $\\alpha p_k$ 的瞬时变化。这个注入的“电荷”随后会指数衰减，直到最终时间 $T_{\\text{end}}$。此单个事件对最终状态 $x_i(T_{\\text{end}})$ 的贡献由下式给出：\n$$ \\Delta x_i(T_{\\text{end}}) \\leftarrow (t_k, a_k, p_k) = (\\alpha p_k) e^{-(T_{\\text{end}} - t_k)/\\tau} $$\n此表达式对于时间 $t_k$ 满足 $0 \\le t_k \\le T_{\\text{end}}$ 的事件有效。\n\n根据叠加原理，总的最终状态 $x_i(T_{\\text{end}})$ 是在时间窗口内发生在地址 $i$ 的所有事件的贡献之和。设 $\\mathcal{K}_i$ 为所有满足 $a_k = i$ 和 $0 \\le t_k \\le T_{\\text{end}}$ 的事件 $(t_k, a_k, p_k)$ 的索引集合。最终状态为：\n$$ x_i(T_{\\text{end}}) = \\sum_{k \\in \\mathcal{K}_i} \\alpha p_k e^{-(T_{\\text{end}} - t_k)/\\tau} $$\n这个公式允许直接计算最终状态，而无需按时间顺序模拟系统。所有相关事件的贡献可以独立计算，然后对每个地址求和。\n\n总体算法如下：\n1. 对于每个测试案例，计算内存吞吐量 $B = \\bar{\\lambda} S$。\n2. 初始化一个大小为 $N$ 的状态向量 $x(T_{\\text{end}})$，所有元素设为 $0$。\n3. 对于所提供列表中的每个事件 $(t_k, a_k, p_k)$，如果 $0 \\le t_k \\le T_{\\text{end}}$，计算其衰减后的贡献 $\\Delta x = \\alpha p_k e^{-(T_{\\text{end}} - t_k)/\\tau}$。\n4. 将此贡献加到状态向量的相应元素上：$x_{a_k}(T_{\\text{end}}) \\leftarrow x_{a_k}(T_{\\text{end}}) + \\Delta x$。\n5. 处理完所有事件后，计算最终状态向量的欧几里得范数，$\\|x(T_{\\text{end}})\\|_2 = \\sqrt{\\sum_{i=0}^{N-1} (x_i(T_{\\text{end}}))^2}$。\n6. 按规定将结果 $[B, \\|x(T_{\\text{end}})\\|_2]$ 格式化为六位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the AER state reconstruction and memory throughput problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case A (general happy path)\n        {\n            \"N\": 4, \"tau\": 0.05, \"alpha\": 0.5, \"T_end\": 0.10,\n            \"events\": [(0.01, 0, +1), (0.02, 1, +1), (0.04, 0, -1), (0.08, 3, +1)],\n            \"avg_lambda\": 3000, \"S\": 12\n        },\n        # Case B (boundary with zero events and zero average rate)\n        {\n            \"N\": 5, \"tau\": 0.10, \"alpha\": 1.0, \"T_end\": 1.00,\n            \"events\": [],\n            \"avg_lambda\": 0, \"S\": 16\n        },\n        # Case C (unsorted event times with repeated addresses)\n        {\n            \"N\": 3, \"tau\": 0.20, \"alpha\": 1.0, \"T_end\": 0.30,\n            \"events\": [(0.25, 2, +1), (0.05, 2, +1), (0.10, 2, -1), (0.15, 1, +1), (0.18, 1, +1)],\n            \"avg_lambda\": 10000, \"S\": 20\n        },\n        # Case D (boundary with zero record size but nonzero event set)\n        {\n            \"N\": 2, \"tau\": 0.05, \"alpha\": 2.0, \"T_end\": 0.05,\n            \"events\": [(0.01, 0, +1), (0.02, 0, +1), (0.03, 1, -1)],\n            \"avg_lambda\": 5000, \"S\": 0\n        }\n    ]\n\n    formatted_results = []\n    \n    for case in test_cases:\n        # Unpack parameters\n        N = case[\"N\"]\n        tau = case[\"tau\"]\n        alpha = case[\"alpha\"]\n        T_end = case[\"T_end\"]\n        events = case[\"events\"]\n        avg_lambda = case[\"avg_lambda\"]\n        S = case[\"S\"]\n        \n        # 1. Calculate memory throughput B\n        # B = average event rate * size per event\n        B = float(avg_lambda * S)\n\n        # 2. Reconstruct the final state vector x(T_end)\n        x_final = np.zeros(N, dtype=np.float64)\n        \n        # Filter events that are within the valid time window [0, T_end]\n        valid_events = [e for e in events if 0 = e[0] = T_end]\n\n        for t_k, a_k, p_k in valid_events:\n            # Calculate the contribution of the event, decayed to T_end\n            contribution = alpha * p_k * np.exp(-(T_end - t_k) / tau)\n            x_final[a_k] += contribution\n            \n        # 3. Calculate the Euclidean norm of the final state vector\n        norm_x = np.linalg.norm(x_final)\n        \n        # Format the result for this case as a string \"[B,norm]\" with no spaces\n        formatted_results.append(f\"[{B:.6f},{norm_x:.6f}]\")\n        \n    # Join all formatted results into a single line string\n    # e.g., [[B1,norm1],[B2,norm2],...]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}