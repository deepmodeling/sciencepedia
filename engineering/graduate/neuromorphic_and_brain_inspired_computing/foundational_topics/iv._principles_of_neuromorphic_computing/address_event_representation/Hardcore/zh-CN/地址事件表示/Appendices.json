{
    "hands_on_practices": [
        {
            "introduction": "地址事件表示（AER）是一种通信协议，其性能从根本上受限于底层硬件的握手延迟。这项练习将引导您推导一种常见的四相握手协议的理论最大吞吐量，从而具体理解事件流在物理层面所受到的约束。通过分析握手信号的顺序交互，我们将揭示限制AER链路速度的基本时间常数 。",
            "id": "4034508",
            "problem": "考虑一个地址-事件表示（AER）互连，它使用异步的四相归零握手协议，在单个事件源和单个事件接收器之间通过承载$W$位宽度地址的单通道总线传输事件。四个握手阶段由源发出的请求（REQ）信号和接收器发出的确认（ACK）信号驱动。在一个完整的事件事务中，会发生以下序列：REQ 变为高电平，然后 ACK 变为高电平，然后 REQ 变为低电平，然后 ACK 变为低电平，此后下一个事件才可以开始。假设所有事件都是原子的、非重叠的，并且不需要仲裁。\n\n存在以下物理约束：\n- 每个握手转换及其相应的端到端传播、采样和稳定都需要一个固定的最小时间 $d$，以确保两端操作的正确性和无风险性。由于适当的缓冲和锁存，该时间与 $W$ 无关。\n- $W$位地址仅在适当的握手窗口期间呈现和锁存，并且数据路径不会引入超出所述的每阶段延迟 $d$ 的额外时间。\n- 不允许流水线操作或阶段重叠；一个事件的四个握手阶段必须按顺序完成后，下一个事件才能开始。\n\n从吞吐量的基本定义（单位时间内的事件数）和四相归零握手协议的语义出发，推导出以 $d$ 表示的理论最大事件吞吐量，并论证 $W$ 是否以及如何影响此上限。以每秒事件数为单位表示最大事件吞吐量的最终答案。没有提供数值；您的答案必须是单个封闭形式的表达式。不要四舍五入。以每秒事件数为单位陈述吞吐量的最终表达式。",
            "solution": "题目要求推导使用四相归零握手协议的地址-事件表示（AER）互连的理论最大事件吞吐量。\n\n首先，我们建立基本定义。吞吐量，记为 $R$，是单位时间内传输的事件数。当每个事件事务所花费的时间最小时，达到理论最大吞吐量 $R_{max}$。如果 $T_{event}$ 是完成一个完整事件事务所需要的时间，那么最大吞吐量是可能的最短事务时间 $T_{min}$ 的倒数。\n\n$$R_{max} = \\frac{1}{T_{min}}$$\n\n题目指出，每个事件都是通过异步的四相归零握手协议传输的。单个、完整、非重叠的事件事务序列如下：\n1.  源断言请求信号（REQ 变为高电平）。\n2.  接收器在收到高电平的 REQ 后，断言确认信号（ACK 变为高电平）。\n3.  源在收到高电平的 ACK 后，撤销请求信号（REQ 变为低电平）。\n4.  接收器在收到低电平的 REQ 后，撤销确认信号（ACK 变为低电平）。\n\n系统只有在所有四个阶段完成后才能开始下一个事件事务。一个事件的总时间 $T_{event}$ 是这四个顺序阶段的持续时间之和。\n\n让我们分析每个阶段的时间。题目提供了一个关键约束：“每个握手转换及其相应的端到端传播、采样和稳定都需要一个固定的最小时间 $d$，以确保两端操作的正确性和无风险性”。这意味着握手序列中的四个步骤中的每一步都至少引入 $d$ 的延迟。\n\n-   **阶段1持续时间（$T_1$）**：源断言 REQ。信号传播到接收器。这需要最小时间 $d$。\n-   **阶段2持续时间（$T_2$）**：接收器通过断言 ACK 来响应。该信号传播回源。这也需要最小时间 $d$。\n-   **阶段3持续时间（$T_3$）**：源撤销 REQ。信号传播到接收器。这需要最小时间 $d$。\n-   **阶段4持续时间（$T_4$）**：接收器通过撤销 ACK 来响应。该信号传播回源，完成整个周期。这也需要最小时间 $d$。\n\n由于题目声明不允许流水线操作或阶段重叠，因此一次事件事务的最小总时间 $T_{min}$ 是四个阶段中每个阶段最小时间之和：\n$$T_{min} = T_1 + T_2 + T_3 + T_4 = d + d + d + d = 4d$$\n\n现在，我们可以将这个最小事件时间代入最大吞吐量的表达式中：\n$$R_{max} = \\frac{1}{T_{min}} = \\frac{1}{4d}$$\n\n$d$ 的单位是时间，因此 $R_{max}$ 的单位是单位时间内的事件数，或按要求为每秒事件数。\n\n问题的第二部分要求论证地址宽度 $W$ 是否以及如何影响此上限。问题陈述提供了直接回答此问题的明确约束：\n1.  “……一个固定的最小时间 $d$ ……由于适当的缓冲和锁存，**与 $W$ 无关**。”\n2.  “……数据路径不会引入**超出所述的每阶段延迟 $d$** 的额外时间。”\n\n这些陈述定义了模型的假设。它们要求我们将每阶段延迟 $d$ 视为系统时序的基本常数，所有其他时序效应，包括任何与宽度为 $W$ 的并行数据路径相关的效应，都已包含在其中。根据问题中提供的严格定义，$W$ 的值在时序计算中不作为自变量出现。因此，在该模型的限制内，理论最大事件吞吐量与地址宽度 $W$ 无关。吞吐量仅由基本握手延迟 $d$ 决定。\n\n因此，最大事件吞吐量的最终表达式仅是 $d$ 的函数。",
            "answer": "$$\\boxed{\\frac{1}{4d}}$$"
        },
        {
            "introduction": "在了解了事件传输的速率限制之后，我们必须考虑所传输信息的时间精度。这项练习聚焦于AER系统中的时间量化问题，探讨如何将连续时间的神经脉冲转换为离散的数字时间戳。通过推导量化误差的表达式，您将深入理解神经形态系统中时钟频率与时间分辨率之间的基本权衡 。",
            "id": "4034506",
            "problem": "考虑一个地址-事件表示法（AER）系统，其中地址-事件表示法（AER）是一种异步通信协议，它将神经脉冲作为事件进行传输，每个事件都标记有其来源地址和相关的时间。在该系统中，每个发生在真实连续时间 $t$ 的脉冲都会被分配一个时间戳，该时间戳由一个以频率 $f_c$ 计时的自由运行数字计数器生成，该计数器有一个 $B_t$ 位的寄存器来保存计数器状态。计数器状态在每个时钟周期递增，并以 $2^{B_t}$ 为模进行回绕。解码器通过将记录的整数计数器状态（在经过理想的解回绕以正确处理回绕后）除以时钟频率来重建以秒为单位的脉冲时间。\n\n假设如下：\n- 对于时间 $t$ 发生的脉冲，记录的整数时间戳是不超过 $f_c t$ 的最大整数计数值。\n- 重建的以秒为单位的时间是记录的计数值除以 $f_c$。\n- 脉冲序列是平稳的，且相对于时钟的脉冲时间分布由 $f_c t$ 的小数部分 $\\phi \\in [0,1)$ 的概率密度 $p_{\\phi}(\\phi)$ 来表征。\n\n从这些定义出发，推导重建脉冲时间中的量化误差，并将脉冲分布上的平均绝对误差表示为关于 $f_c$ 和 $p_{\\phi}(\\phi)$ 的闭式解析表达式。明确说明在何种假设下，$B_t$ 会或不会影响量化误差。将最终的平均绝对误差以秒为单位表示为精确表达式；不要提供任何数值近似，也不要四舍五入。",
            "solution": "该问题要求推导地址-事件表示法（AER）系统中的平均绝对量化误差。验证过程确认了该问题具有科学依据、问题设定良好、客观，并包含了推导解决方案所需的所有必要信息。\n\n设 $t$ 为脉冲事件的真实连续时间。该系统使用一个以频率 $f_c$ 计时的数字计数器。为脉冲记录的整数时间戳，记为 $C(t)$，被定义为不超过 $f_c t$ 的最大整数计数值。这可以用向下取整函数表示：\n$$ C(t) = \\lfloor f_c t \\rfloor $$\n重建时间 $t_{rec}$ 是通过将此整数计数值除以时钟频率得到的。问题指明这是在对计数器进行理想解回绕之后完成的，这意味着我们可以使用完整的、未回绕的整数计数值 $C(t)$。\n$$ t_{rec} = \\frac{C(t)}{f_c} = \\frac{\\lfloor f_c t \\rfloor}{f_c} $$\n量化误差 $\\epsilon$ 是重建时间与真实时间之差：\n$$ \\epsilon(t) = t_{rec} - t = \\frac{\\lfloor f_c t \\rfloor}{f_c} - t $$\n为了分析这个误差，我们使用问题中为 $f_c t$ 的小数部分提供的定义。设 $\\phi$ 为这个小数部分，使得 $\\phi \\in [0, 1)$。任何实数都可以表示为其整数部分与小数部分之和。因此，我们有：\n$$ f_c t = \\lfloor f_c t \\rfloor + \\phi $$\n我们可以重新整理这个方程，用相对于时钟周期的整数和分数分量来表示真实时间 $t$：\n$$ t = \\frac{\\lfloor f_c t \\rfloor + \\phi}{f_c} $$\n将这个 $t$ 的表达式代入误差 $\\epsilon(t)$ 的方程中：\n$$ \\epsilon(t) = \\frac{\\lfloor f_c t \\rfloor}{f_c} - \\left( \\frac{\\lfloor f_c t \\rfloor + \\phi}{f_c} \\right) = \\frac{\\lfloor f_c t \\rfloor - \\lfloor f_c t \\rfloor - \\phi}{f_c} = -\\frac{\\phi}{f_c} $$\n这个结果表明，量化误差总是负数或零，其大小与 $f_c t$ 的小数部分 $\\phi$ 成正比。这是很直观的：重建的时间对应于事件发生前的最后一个离散时钟滴答，因此真实时间总是领先于它，领先的量对应于时钟周期 $1/f_c$ 内的相位 $\\phi$。\n\n问题要求的是平均绝对误差，记为 $\\langle |\\epsilon| \\rangle$。绝对误差是：\n$$ |\\epsilon| = \\left| -\\frac{\\phi}{f_c} \\right| = \\frac{\\phi}{f_c} $$\n绝对误差的平均值（或期望值）是通过在脉冲时间的分布上求平均得到的。问题指出，这个分布由小数部分 $\\phi$ 的概率密度函数 $p_{\\phi}(\\phi)$ 来表征。因此，平均绝对误差是 $|\\epsilon|$ 关于此分布的期望值：\n$$ \\langle |\\epsilon| \\rangle = E\\left[\\frac{\\phi}{f_c}\\right] = \\int_{0}^{1} \\frac{\\phi}{f_c} p_{\\phi}(\\phi) \\,d\\phi $$\n由于时钟频率 $f_c$ 是一个常数，可以将其从积分中提出：\n$$ \\langle |\\epsilon| \\rangle = \\frac{1}{f_c} \\int_{0}^{1} \\phi \\, p_{\\phi}(\\phi) \\,d\\phi $$\n这个表达式表示了用给定物理量 $f_c$ 和 $p_{\\phi}(\\phi)$ 表示的平均绝对量化误差。根据定义，积分 $\\int_{0}^{1} \\phi \\, p_{\\phi}(\\phi) \\,d\\phi$ 是随机变量 $\\phi$ 的平均值，我们可以将其记为 $\\langle \\phi \\rangle$。所以，平均绝对误差也可以写成 $\\frac{\\langle \\phi \\rangle}{f_c}$。积分形式是所要求的完整解析表达式。\n\n关于计数器位宽 $B_t$ 的影响，问题陈述中包含了一个关键假设，即“理想的解回绕以正确处理回绕”。当数值 $\\lfloor f_c t \\rfloor$ 超过 $B_t$ 位所能表示的最大值 $2^{B_t}-1$ 时，计数器会发生回绕。理想的解回绕意味着真实的、连续的计数值 $\\lfloor f_c t \\rfloor$ 总是可以从一系列回绕的时间戳中恢复出来。如果连续事件之间的时间间隔小于计数器的回绕周期 $T_{wrap} = 2^{B_t} / f_c$，这是可能实现的。\n因为我们推导出的量化误差 $\\epsilon = - \\phi / f_c$ 仅依赖于解回绕后的计数值 $\\lfloor f_c t \\rfloor$（通过 $\\phi$ 的定义），所以*在理想解回绕的假设下*，寄存器的大小 $B_t$ 不影响量化误差。量化误差是时间离散化（由 $f_c$ 决定）的结果，而不是计数器寄存器有限范围的结果。如果解回绕不是理想的，那么回绕可能会在 $t_{rec}$ 中引入巨大的、灾难性的误差，在这种情况下，$B_t$ 将是决定此类故障频率的关键参数。",
            "answer": "$$\\boxed{\\frac{1}{f_c} \\int_{0}^{1} \\phi \\, p_{\\phi}(\\phi) \\,d\\phi}$$"
        },
        {
            "introduction": "最后，在掌握了传输速率和数据保真度的概念后，这项练习将触及最终目标：利用AER事件流来重建或模拟神经系统的动态。该问题要求您基于AER日志实现一个由事件驱动的“漏积分”神经元模型，从而将抽象的通信协议与其在类脑计算中的实际应用联系起来。这项实践将理论与编程相结合，帮助您理解如何从事件数据中还原出有意义的系统状态 。",
            "id": "4034548",
            "problem": "给定一个在地址-事件表示法（AER）背景下的事件驱动状态重构问题。任务是实现一个重放机制，该机制从 AER 日志中重构一组地址索引的泄露累加器的最终状态，并根据平均事件率和每事件记录大小计算实时重放所需的内存吞吐量。重放必须基于线性时不变动力学和量纲分析的第一性原理。\n\n定义和假设：\n\n- 每个事件是一个元组 $(t_k, a_k, p_k)$，其中 $t_k$ 是事件时间（秒），$a_k \\in \\{0,1,\\dots,N-1\\}$ 是整数地址，$p_k \\in \\{-1,+1\\}$ 是极性。\n- 地址 $i$ 的状态表示为 $x_i(t)$，并根据带冲激输入的泄露积分器动力学演化。在事件之间，演化遵循 $dx_i(t)/dt=-x_i(t)/\\tau$，其中 $\\tau>0$ 是一个固定的时间常数（秒）。在该地址的事件发生时，状态会接收到一个幅度为 $\\alpha\\,p_k$ 的瞬时跳变，其中 $\\alpha>0$ 是一个固定的标量增益。\n- 初始条件为对所有地址 $i$，都有 $x_i(0)=0$。只有时间 $t_k$ 满足 $0\\le t_k\\le T_{\\text{end}}$ 的事件才会对 $t=T_{\\text{end}}$ 时的最终状态有贡献。\n- 每个事件的事件记录大小是一个固定常数 $S$（字节/事件），平均事件率为 $\\bar{\\lambda}$（事件/秒）。实时重放所需的内存吞吐量定义为系统为在无积压的情况下以平均速率处理事件所必须维持的最小数据速率（字节/秒）。\n\n您的程序必须：\n\n1. 使用 AER 日志和上述泄露积分器模型，重构最终状态向量 $x(T_{\\text{end}})=[x_0(T_{\\text{end}}),\\dots,x_{N-1}(T_{\\text{end}})]$，并纯粹用给定的事件来表示。\n2. 基于量纲分析和实时重放无排队的假设，计算所需的内存吞吐量，作为平均事件率和每事件记录大小的函数，单位为字节/秒。\n\n内存吞吐量以字节/秒表示，所有时间以秒为单位。角度不适用。结果必须是数值，并四舍五入到六位小数。最终输出必须是单行，形式为一个用方括号括起来的逗号分隔列表，其中每个元素本身是一个双元素列表 $[B, \\|x(T_{\\text{end}})\\|_2]$，包含：\n- $B$：内存吞吐量（字节/秒，四舍五入到六位小数），\n- $\\|x(T_{\\text{end}})\\|_2$：最终状态向量的欧几里得范数（四舍五入到六位小数）。\n\n测试套件（每个案例指定 $(N,\\tau,\\alpha,T_{\\text{end}},\\text{events},\\bar{\\lambda},S)$）：\n\n- 案例 A（一般正常路径）：\n  - $N=4$, $\\tau=0.05$, $\\alpha=0.5$, $T_{\\text{end}}=0.10$,\n  - 事件 $[(0.01,0,+1),(0.02,1,+1),(0.04,0,-1),(0.08,3,+1)]$,\n  - $\\bar{\\lambda}=3000$ (事件/秒), $S=12$ (字节/事件)。\n\n- 案例 B（零事件和零平均速率的边界情况）：\n  - $N=5$, $\\tau=0.10$, $\\alpha=1.0$, $T_{\\text{end}}=1.00$,\n  - 事件 $[\\ ]$,\n  - $\\bar{\\lambda}=0$ (事件/秒), $S=16$ (字节/事件)。\n\n- 案例 C（事件时间未排序且地址重复的情况）：\n  - $N=3$, $\\tau=0.20$, $\\alpha=1.0$, $T_{\\text{end}}=0.30$,\n  - 事件 $[(0.25,2,+1),(0.05,2,+1),(0.10,2,-1),(0.15,1,+1),(0.18,1,+1)]$,\n  - $\\bar{\\lambda}=10000$ (事件/秒), $S=20$ (字节/事件)。\n\n- 案例 D（记录大小为零但事件集非空的边界情况）：\n  - $N=2$, $\\tau=0.05$, $\\alpha=2.0$, $T_{\\text{end}}=0.05$,\n  - 事件 $[(0.01,0,+1),(0.02,0,+1),(0.03,1,-1)]$,\n  - $\\bar{\\lambda}=5000$ (事件/秒), $S=0$ (字节/事件)。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果，其中每个元素是对应测试案例的双元素列表 $[B,\\|x(T_{\\text{end}})\\|_2]$，例如 $[[B_A,\\|x_A\\|_2],[B_B,\\|x_B\\|_2],[B_C,\\|x_C\\|_2],[B_D,\\|x_D\\|_2]]$。输出中的所有数值必须四舍五入到六位小数。",
            "solution": "经评估，问题陈述是有效的。它在科学上基于线性时不变 (LTI) 系统和量纲分析的原理，定义明确，为获得唯一解提供了所有必要信息，并且其语言和定义是客观的。\n\n解决方案分为两部分：内存吞吐量的计算和最终状态向量的重构。\n\n**1. 内存吞吐量计算**\n\n所需的内存吞吐量 $B$ 定义为系统为实时处理事件而无积压所必须维持的最小数据速率。这由数据到达的平均速率决定。问题提供了两个关键参数：\n- 平均事件率 $\\bar{\\lambda}$，单位为 事件/秒。\n- 每事件记录大小 $S$，单位为 字节/事件。\n\n使用量纲分析，我们可以确定内存吞吐量。我们寻求一个单位为 字节/秒 的量。\n$\\bar{\\lambda}$ 的单位是 $[\\bar{\\lambda}] = \\frac{\\text{事件}}{\\text{秒}}$。\n$S$ 的单位是 $[S] = \\frac{\\text{字节}}{\\text{事件}}$。\n\n为了得到以 字节/秒 为单位的结果，我们将这两个量相乘：\n$$ B = \\bar{\\lambda} \\times S $$\n单位也相乘：\n$$ [B] = \\left(\\frac{\\text{事件}}{\\text{秒}}\\right) \\times \\left(\\frac{\\text{字节}}{\\text{事件}}\\right) = \\frac{\\text{字节}}{\\text{秒}} $$\n这证实了内存吞吐量 $B$ 是平均事件率和每事件记录大小的简单乘积。\n\n**2. 最终状态重构**\n\n每个地址 $i$ 的累加器状态 $x_i(t)$ 受泄露积分器模型控制。这是一个描述事件之间动力学的一阶线性常微分方程：\n$$ \\frac{dx_i(t)}{dt} = -\\frac{x_i(t)}{\\tau} $$\n其中 $\\tau$ 是时间常数。给定在时间 $t_a$ 的状态 $x_i(t_a)$，在稍后的时间 $t_b > t_a$，状态将指数衰减到 $x_i(t_b)$：\n$$ x_i(t_b) = x_i(t_a) e^{-(t_b - t_a)/\\tau} $$\n在地址 $a_k=i$ 的事件时间 $t_k$，状态受到一个冲激输入，导致一个瞬时跳变：\n$$ x_i(t_k^+) = x_i(t_k^-) + \\alpha p_k $$\n其中 $x_i(t_k^-)$ 和 $x_i(t_k^+)$ 分别是事件发生前后的状态，$\\alpha$ 是增益，$p_k$ 是事件极性。\n\n该系统是一个线性时不变 (LTI) 系统。因此，叠加原理适用。在时间 $T_{\\text{end}}$ 的最终状态是，从初始条件 $x_i(0)=0$ 开始，对每个独立事件冲激的响应之和。\n\n考虑一个单一事件 $(t_k, a_k, p_k)$，其中 $a_k = i$。该事件在时间 $t_k$ 对状态 $x_i$ 引入一个瞬时变化 $\\alpha p_k$。这个注入的“电荷”随后指数衰减，直到最终时间 $T_{\\text{end}}$。这个单一事件对最终状态 $x_i(T_{\\text{end}})$ 的贡献由下式给出：\n$$ \\Delta x_i(T_{\\text{end}}) \\leftarrow (t_k, a_k, p_k) = (\\alpha p_k) e^{-(T_{\\text{end}} - t_k)/\\tau} $$\n此表达式对于时间 $t_k$ 满足 $0 \\le t_k \\le T_{\\text{end}}$ 的事件有效。\n\n根据叠加原理，总的最终状态 $x_i(T_{\\text{end}})$ 是在时间窗口内发生在地址 $i$ 的所有事件的贡献之和。设 $\\mathcal{K}_i$ 为所有事件 $(t_k, a_k, p_k)$ 的索引集合，其中 $a_k = i$ 且 $0 \\le t_k \\le T_{\\text{end}}$。最终状态为：\n$$ x_i(T_{\\text{end}}) = \\sum_{k \\in \\mathcal{K}_i} \\alpha p_k e^{-(T_{\\text{end}} - t_k)/\\tau} $$\n这个公式允许直接计算最终状态，而无需按时间顺序模拟系统。所有相关事件的贡献可以独立计算，然后对每个地址进行求和。\n\n总体算法如下：\n1. 对于每个测试案例，计算内存吞吐量 $B = \\bar{\\lambda} S$。\n2. 初始化一个大小为 $N$ 的状态向量 $x(T_{\\text{end}})$，所有元素设置为 $0$。\n3. 对于所提供列表中的每个事件 $(t_k, a_k, p_k)$，如果 $0 \\le t_k \\le T_{\\text{end}}$，计算其衰减后的贡献 $\\Delta x = \\alpha p_k e^{-(T_{\\text{end}} - t_k)/\\tau}$。\n4. 将此贡献加到状态向量的相应元素上：$x_{a_k}(T_{\\text{end}}) \\leftarrow x_{a_k}(T_{\\text{end}}) + \\Delta x$。\n5. 处理完所有事件后，计算最终状态向量的欧几里得范数 $\\|x(T_{\\text{end}})\\|_2 = \\sqrt{\\sum_{i=0}^{N-1} (x_i(T_{\\text{end}}))^2}$。\n6. 按照规定将结果 $[B, \\|x(T_{\\text{end}})\\|_2]$ 格式化为六位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the AER state reconstruction and memory throughput problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case A (general happy path)\n        {\n            \"N\": 4, \"tau\": 0.05, \"alpha\": 0.5, \"T_end\": 0.10,\n            \"events\": [(0.01, 0, +1), (0.02, 1, +1), (0.04, 0, -1), (0.08, 3, +1)],\n            \"avg_lambda\": 3000, \"S\": 12\n        },\n        # Case B (boundary with zero events and zero average rate)\n        {\n            \"N\": 5, \"tau\": 0.10, \"alpha\": 1.0, \"T_end\": 1.00,\n            \"events\": [],\n            \"avg_lambda\": 0, \"S\": 16\n        },\n        # Case C (unsorted event times with repeated addresses)\n        {\n            \"N\": 3, \"tau\": 0.20, \"alpha\": 1.0, \"T_end\": 0.30,\n            \"events\": [(0.25, 2, +1), (0.05, 2, +1), (0.10, 2, -1), (0.15, 1, +1), (0.18, 1, +1)],\n            \"avg_lambda\": 10000, \"S\": 20\n        },\n        # Case D (boundary with zero record size but nonzero event set)\n        {\n            \"N\": 2, \"tau\": 0.05, \"alpha\": 2.0, \"T_end\": 0.05,\n            \"events\": [(0.01, 0, +1), (0.02, 0, +1), (0.03, 1, -1)],\n            \"avg_lambda\": 5000, \"S\": 0\n        }\n    ]\n\n    formatted_results = []\n    \n    for case in test_cases:\n        # Unpack parameters\n        N = case[\"N\"]\n        tau = case[\"tau\"]\n        alpha = case[\"alpha\"]\n        T_end = case[\"T_end\"]\n        events = case[\"events\"]\n        avg_lambda = case[\"avg_lambda\"]\n        S = case[\"S\"]\n        \n        # 1. Calculate memory throughput B\n        # B = average event rate * size per event\n        B = float(avg_lambda * S)\n\n        # 2. Reconstruct the final state vector x(T_end)\n        x_final = np.zeros(N, dtype=np.float64)\n        \n        # Filter events that are within the valid time window [0, T_end]\n        valid_events = [e for e in events if 0 = e[0] = T_end]\n\n        for t_k, a_k, p_k in valid_events:\n            # Calculate the contribution of the event, decayed to T_end\n            contribution = alpha * p_k * np.exp(-(T_end - t_k) / tau)\n            x_final[a_k] += contribution\n            \n        # 3. Calculate the Euclidean norm of the final state vector\n        norm_x = np.linalg.norm(x_final)\n        \n        # Format the result for this case as a string \"[B,norm]\" with no spaces\n        formatted_results.append(f\"[{B:.6f},{norm_x:.6f}]\")\n        \n    # Join all formatted results into a single line string\n    # e.g., [[B1,norm1],[B2,norm2],...]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}