{
    "hands_on_practices": [
        {
            "introduction": "To build a robust understanding of any communication system, we begin with its fundamental limits. The performance of an Address-Event Representation (AER) system is ultimately constrained by the speed of its underlying hardware and protocol. This first practice invites you to derive the theoretical maximum throughput of an AER interconnect from the first principles of its asynchronous four-phase handshake protocol . By analyzing the sequence of communication signals, you will establish a hard upper bound on the event rate, providing a critical baseline for all further system analysis.",
            "id": "4034508",
            "problem": "Consider an Address-Event Representation (AER) interconnect that uses an asynchronous, four-phase return-to-zero handshake between a single event source and a single event sink to transmit events over a single-lane bus carrying an address of width $W$ bits. The four handshake phases are driven by a Request (REQ) signal from the source and an Acknowledge (ACK) signal from the sink. In one complete event transaction, the following sequence occurs: REQ transitions high, then ACK transitions high, then REQ transitions low, then ACK transitions low, after which the next event may begin. Assume all events are atomic and non-overlapped, and that arbitration is not required.\n\nThe following physical constraints hold:\n- Each handshake transition and its corresponding end-to-end propagation, sampling, and settling requires a fixed minimum time $d$ for correctness and hazard-free operation at both endpoints, independent of $W$ due to appropriate buffering and latching.\n- The $W$-bit address is presented and latched only during the appropriate handshake window, and the data path does not introduce additional timing beyond the stated per-phase delay $d$.\n- No pipelining or phase overlap is permitted; the four handshake phases for an event must complete sequentially before the next event begins.\n\nStarting from the fundamental definitions of throughput as events per unit time and the semantics of a four-phase return-to-zero handshake, derive the theoretical maximum event throughput in terms of $d$ and justify whether and how $W$ affects this bound. Express the final answer for the maximum event throughput in events per second. No numerical values are provided; your answer must be a single closed-form expression. Do not round. State your final expression for the throughput in events per second.",
            "solution": "The problem requires the derivation of the theoretical maximum event throughput for an Address-Event Representation (AER) interconnect using a four-phase return-to-zero handshake protocol.\n\nFirst, we establish the fundamental definitions. Throughput, denoted as $R$, is the number of events transmitted per unit time. The maximum theoretical throughput, $R_{max}$, is achieved when the time required for each event transaction is at its minimum. If $T_{event}$ is the time required to complete one full event transaction, then the maximum throughput is the reciprocal of the minimum possible transaction time, $T_{min}$.\n\n$$R_{max} = \\frac{1}{T_{min}}$$\n\nThe problem states that each event is transmitted via an asynchronous, four-phase return-to-zero handshake. The sequence for a single, complete, non-overlapped event transaction is as follows:\n1.  The source asserts the Request signal (REQ goes high).\n2.  The sink, upon receiving the high REQ, asserts the Acknowledge signal (ACK goes high).\n3.  The source, upon receiving the high ACK, de-asserts the Request signal (REQ goes low).\n4.  The sink, upon receiving the low REQ, de-asserts the Acknowledge signal (ACK goes low).\n\nThe system can only begin the next event transaction after the completion of all four phases. The total time for one event, $T_{event}$, is the sum of the durations of these four sequential phases.\n\nLet's analyze the timing for each phase. The problem provides a critical constraint: \"Each handshake transition and its corresponding end-to-end propagation, sampling, and settling requires a fixed minimum time $d$ for correctness and hazard-free operation at both endpoints\". This means that each of the four steps in the handshake sequence introduces a delay of at least $d$.\n\n-   **Phase 1 duration ($T_1$)**: The source asserts REQ. The signal propagates to the sink. This takes a minimum time of $d$.\n-   **Phase 2 duration ($T_2$)**: The sink responds by asserting ACK. This signal propagates back to the source. This also takes a minimum time of $d$.\n-   **Phase 3 duration ($T_3$)**: The source de-asserts REQ. The signal propagates to the sink. This takes a minimum time of $d$.\n-   **Phase 4 duration ($T_4$)**: The sink responds by de-asserting ACK. This signal propagates back to the source, completing the cycle. This also takes a minimum time of $d$.\n\nSince the problem states that no pipelining or phase overlap is permitted, the minimum total time for one event transaction, $T_{min}$, is the sum of the minimum times for each of the four phases:\n$$T_{min} = T_1 + T_2 + T_3 + T_4 = d + d + d + d = 4d$$\n\nNow, we can substitute this minimum event time into the expression for maximum throughput:\n$$R_{max} = \\frac{1}{T_{min}} = \\frac{1}{4d}$$\n\nThe unit of $d$ is time, so the unit for $R_{max}$ is events per unit time, or events per second as requested.\n\nThe second part of the problem asks to justify whether and how the address width, $W$, affects this bound. The problem statement provides explicit constraints that directly answer this question:\n1.  \"...a fixed minimum time $d$ ... **independent of $W$** due to appropriate buffering and latching.\"\n2.  \"...the data path does not introduce additional timing **beyond the stated per-phase delay $d$**.\"\n\nThese statements define the model's assumptions. They require us to treat the per-phase delay $d$ as a fundamental constant of the system's timing, into which all other timing effects, including any related to the parallel data path of width $W$, are already subsumed. According to the strict definitions provided in the problem, the value of $W$ does not appear as an independent variable in the timing calculation. Therefore, within the confines of this model, the theoretical maximum event throughput is independent of the address width $W$. The throughput is determined solely by the fundamental handshake delay $d$.\n\nThus, the final expression for the maximum event throughput is a function of $d$ only.",
            "answer": "$$\\boxed{\\frac{1}{4d}}$$"
        },
        {
            "introduction": "While maximum throughput defines a system's capacity, real-world performance is governed by how it handles random, bursty traffic. When events arrive faster than they can be immediately serviced, they form a queue, introducing latency. This practice applies the formal tools of queueing theory to an AER link, allowing you to quantify the expected event delay under stochastic arrivals . You will analyze a crucial design tradeoff: the impact of adding a data payload to each event, which increases the information content but also the service time and, consequently, the overall system latency.",
            "id": "4034493",
            "problem": "An Address-Event Representation (AER) link serializes event information onto a single shared bus. Each event carries an address of width $A$ bits and, in a more expressive variant, an additional payload of width $P$ bits. Frames are serialized at a bit rate $f_b$ and include a fixed framing overhead of $F$ bits. The link uses a four-phase handshake and centralized arbitration; all non-data overheads per event (handshake transitions, arbitration winner notification, and clock-domain retiming) contribute a fixed service overhead $t_0$ that is independent of $A$ and $P$. Events arrive to the bus as a Poisson process of rate $\\lambda$, and the serialization and overhead together yield a deterministic service time per event.\n\nStarting from first principles about serialization and queueing, derive the expected per-event latency for both address-only AER (where the payload is absent) and address-plus-payload AER, treating the bus as a single-server $M/D/1$ queue. Then compute the ratio $R$ of the expected latency with payload to the expected latency without payload under the following parameters:\n- Address width $A = 16$ bits,\n- Payload width $P = 12$ bits,\n- Framing overhead $F = 2$ bits,\n- Bit rate $f_b = 200 \\times 10^{6}$ bits per second,\n- Fixed per-event overhead $t_0 = 25 \\times 10^{-9}$ seconds,\n- Event arrival rate $\\lambda = 5 \\times 10^{6}$ events per second.\n\nExpress your final answer as the dimensionless ratio $R$. Round your answer to four significant figures.",
            "solution": "The problem asks for the ratio of expected event latencies for an Address-Event Representation (AER) link operating with and without a data payload. The system is to be modeled as an M/D/1 queue, which is appropriate for Poisson arrivals (M), a deterministic service time (D), and a single shared bus (1).\n\nFirst, we establish the formula for the expected total time an event spends in an M/D/1 system (latency), denoted by $W$. This is the sum of the time spent waiting in the queue, $W_q$, and the service time, $T_s$.\n$$W = W_q + T_s$$\nThe expected waiting time in the queue for a general M/G/1 system is given by the Pollaczek-Khinchine formula:\n$$W_q = \\frac{\\lambda E[T_s^2]}{2(1-\\rho)}$$\nwhere $\\lambda$ is the arrival rate, $\\rho = \\lambda E[T_s]$ is the server utilization, and $E[T_s]$ and $E[T_s^2]$ are the first and second moments of the service time distribution, respectively.\n\nFor a deterministic service time $T_s$, the distribution is a Dirac delta function. Therefore, the expected service time is $E[T_s] = T_s$, and the second moment is $E[T_s^2] = T_s^2$. The utilization becomes $\\rho = \\lambda T_s$.\nSubstituting these into the formula for $W_q$:\n$$W_q = \\frac{\\lambda T_s^2}{2(1 - \\lambda T_s)}$$\nThe total expected latency $W$ for an M/D/1 queue is then:\n$$W = T_s + W_q = T_s + \\frac{\\lambda T_s^2}{2(1 - \\lambda T_s)} = T_s \\left( 1 + \\frac{\\lambda T_s}{2(1 - \\lambda T_s)} \\right)$$\n$$W = T_s \\left( \\frac{2(1 - \\lambda T_s) + \\lambda T_s}{2(1 - \\lambda T_s)} \\right) = T_s \\left( \\frac{2 - \\lambda T_s}{2(1 - \\lambda T_s)} \\right)$$\nThis is the general formula for the expected latency we will use. The system is stable only if $\\rho  1$, i.e., $\\lambda T_s  1$.\n\nNext, we determine the service time $T_s$. An event service consists of two parts: a fixed overhead $t_0$ and a serialization time. The serialization time is the total number of bits in a frame divided by the bit rate $f_b$.\n$$T_s = \\frac{\\text{Number of bits}}{f_b} + t_0$$\n\nWe now analyze the two specified cases: address-only AER and address-plus-payload AER.\n\nCase 1: Address-only AER (without payload)\nLet us denote the service time and latency for this case with the subscript 'ao'. The payload width $P$ is effectively $0$. The total number of bits per frame, $N_{\\text{bits, ao}}$, is the sum of the address width $A$ and the framing overhead $F$.\n$$N_{\\text{bits, ao}} = A + F$$\nThe service time $T_{s, \\text{ao}}$ is:\n$$T_{s, \\text{ao}} = \\frac{A+F}{f_b} + t_0$$\nSubstituting the given values: $A=16$, $F=2$, $f_b = 200 \\times 10^{6} \\, \\text{s}^{-1}$, and $t_0 = 25 \\times 10^{-9} \\, \\text{s}$.\n$$T_{s, \\text{ao}} = \\frac{16+2}{200 \\times 10^{6}} + 25 \\times 10^{-9} = \\frac{18}{200 \\times 10^{6}} + 25 \\times 10^{-9}$$\n$$T_{s, \\text{ao}} = 90 \\times 10^{-9} \\, \\text{s} + 25 \\times 10^{-9} \\, \\text{s} = 115 \\times 10^{-9} \\, \\text{s}$$\nThe bus utilization for this case, $\\rho_{\\text{ao}}$, with an arrival rate $\\lambda = 5 \\times 10^{6} \\, \\text{s}^{-1}$ is:\n$$\\rho_{\\text{ao}} = \\lambda T_{s, \\text{ao}} = (5 \\times 10^{6}) \\times (115 \\times 10^{-9}) = 0.575$$\nSince $\\rho_{\\text{ao}}  1$, the queue is stable. The expected latency, $W_{\\text{ao}}$, is:\n$$W_{\\text{ao}} = T_{s, \\text{ao}} \\left( \\frac{2 - \\rho_{\\text{ao}}}{2(1 - \\rho_{\\text{ao}})} \\right) = (115 \\times 10^{-9}) \\left( \\frac{2 - 0.575}{2(1 - 0.575)} \\right)$$\n$$W_{\\text{ao}} = (115 \\times 10^{-9}) \\left( \\frac{1.425}{2(0.425)} \\right) = (115 \\times 10^{-9}) \\left( \\frac{1.425}{0.85} \\right)$$\n$$W_{\\text{ao}} \\approx (115 \\times 10^{-9}) \\times 1.67647... = 192.794... \\times 10^{-9} \\, \\text{s}$$\n\nCase 2: Address-plus-payload AER\nLet us denote the variables for this case with the subscript 'ap'. The total number of bits per frame, $N_{\\text{bits, ap}}$, includes the address $A$, payload $P$, and framing $F$.\n$$N_{\\text{bits, ap}} = A + P + F$$\nThe service time $T_{s, \\text{ap}}$ is:\n$$T_{s, \\text{ap}} = \\frac{A+P+F}{f_b} + t_0$$\nSubstituting the given values: $A=16$, $P=12$, $F=2$, $f_b = 200 \\times 10^{6} \\, \\text{s}^{-1}$, and $t_0 = 25 \\times 10^{-9} \\, \\text{s}$.\n$$T_{s, \\text{ap}} = \\frac{16+12+2}{200 \\times 10^{6}} + 25 \\times 10^{-9} = \\frac{30}{200 \\times 10^{6}} + 25 \\times 10^{-9}$$\n$$T_{s, \\text{ap}} = 150 \\times 10^{-9} \\, \\text{s} + 25 \\times 10^{-9} \\, \\text{s} = 175 \\times 10^{-9} \\, \\text{s}$$\nThe bus utilization for this case, $\\rho_{\\text{ap}}$, is:\n$$\\rho_{\\text{ap}} = \\lambda T_{s, \\text{ap}} = (5 \\times 10^{6}) \\times (175 \\times 10^{-9}) = 0.875$$\nSince $\\rho_{\\text{ap}}  1$, this queue is also stable. The expected latency, $W_{\\text{ap}}$, is:\n$$W_{\\text{ap}} = T_{s, \\text{ap}} \\left( \\frac{2 - \\rho_{\\text{ap}}}{2(1 - \\rho_{\\text{ap}})} \\right) = (175 \\times 10^{-9}) \\left( \\frac{2 - 0.875}{2(1 - 0.875)} \\right)$$\n$$W_{\\text{ap}} = (175 \\times 10^{-9}) \\left( \\frac{1.125}{2(0.125)} \\right) = (175 \\times 10^{-9}) \\left( \\frac{1.125}{0.25} \\right)$$\n$$W_{\\text{ap}} = (175 \\times 10^{-9}) \\times 4.5 = 787.5 \\times 10^{-9} \\, \\text{s}$$\n\nFinally, we compute the ratio $R$ of the expected latency with payload to the expected latency without payload.\n$$R = \\frac{W_{\\text{ap}}}{W_{\\text{ao}}} = \\frac{787.5 \\times 10^{-9}}{192.794... \\times 10^{-9}} \\approx 4.084659...$$\nRounding the result to four significant figures gives:\n$$R \\approx 4.085$$",
            "answer": "$$\\boxed{4.085}$$"
        },
        {
            "introduction": "The ultimate goal of Address-Event Representation is to drive computation by efficiently communicating meaningful state changes. This final practice brings the concept full circle, challenging you to translate a sparse stream of events back into the continuous-time dynamics of a neural model. You will develop a method to reconstruct the state of a leaky integrator—a fundamental building block in computational neuroscience—from a log of discrete events . This exercise not only demonstrates the core purpose of AER but also highlights a critical system-level constraint: the memory bandwidth required to process event data in real time.",
            "id": "4034548",
            "problem": "You are given an event-driven state reconstruction problem in the context of Address-Event Representation (AER). The task is to implement a replay mechanism that reconstructs the final state of a set of address-indexed leaky accumulators from an AER log and to compute the required memory throughput for real-time replay given an average event rate and a per-event record size. The replay must be based on first principles of linear time-invariant dynamics and dimensional analysis.\n\nDefinitions and assumptions:\n\n- Each event is a tuple $(t_k, a_k, p_k)$ where $t_k$ is the event time in seconds, $a_k \\in \\{0,1,\\dots,N-1\\}$ is the integer address, and $p_k \\in \\{-1,+1\\}$ is the polarity.\n- The state at address $i$ is denoted $x_i(t)$ and evolves according to the leaky integrator dynamics with impulsive inputs. Between events, the evolution obeys $dx_i(t)/dt=-x_i(t)/\\tau$, where $\\tau0$ is a fixed time constant (in seconds). At event times for that address, the state receives an instantaneous jump of amplitude $\\alpha\\,p_k$, where $\\alpha0$ is a fixed scalar gain.\n- The initial condition is $x_i(0)=0$ for all addresses $i$. Only events with times $t_k$ satisfying $0\\le t_k\\le T_{\\text{end}}$ contribute to the final state at $t=T_{\\text{end}}$.\n- The event record size per event is a fixed constant $S$ in bytes per event, and the average event rate is $\\bar{\\lambda}$ in events per second. The required memory throughput for real-time replay is defined as the minimum data rate, in bytes per second, that the system must sustain to process events at the average rate without backlog.\n\nYour program must:\n\n1. Reconstruct the final state vector $x(T_{\\text{end}})=[x_0(T_{\\text{end}}),\\dots,x_{N-1}(T_{\\text{end}})]$ using the AER log and the leaky integrator model described above, expressed purely in terms of the given events.\n2. Compute the required memory throughput as a function of the average event rate and per-event record size, expressed in bytes per second, based on dimensional analysis and the assumption of real-time replay without queuing.\n\nExpress the memory throughput in bytes per second, and all times are in seconds. Angles are not applicable. Results must be numerical and rounded to six decimal places. The final output must be a single line with a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a two-element list $[B, \\|x(T_{\\text{end}})\\|_2]$ containing:\n- $B$: the memory throughput in bytes per second (rounded to six decimal places),\n- $\\|x(T_{\\text{end}})\\|_2$: the Euclidean norm of the final state vector (rounded to six decimal places).\n\nTest suite (each case specifies $(N,\\tau,\\alpha,T_{\\text{end}},\\text{events},\\bar{\\lambda},S)$):\n\n- Case A (general happy path):\n  - $N=4$, $\\tau=0.05$, $\\alpha=0.5$, $T_{\\text{end}}=0.10$,\n  - events $[(0.01,0,+1),(0.02,1,+1),(0.04,0,-1),(0.08,3,+1)]$,\n  - $\\bar{\\lambda}=3000$ (events per second), $S=12$ (bytes per event).\n\n- Case B (boundary with zero events and zero average rate):\n  - $N=5$, $\\tau=0.10$, $\\alpha=1.0$, $T_{\\text{end}}=1.00$,\n  - events $[\\ ]$,\n  - $\\bar{\\lambda}=0$ (events per second), $S=16$ (bytes per event).\n\n- Case C (unsorted event times with repeated addresses):\n  - $N=3$, $\\tau=0.20$, $\\alpha=1.0$, $T_{\\text{end}}=0.30$,\n  - events $[(0.25,2,+1),(0.05,2,+1),(0.10,2,-1),(0.15,1,+1),(0.18,1,+1)]$,\n  - $\\bar{\\lambda}=10000$ (events per second), $S=20$ (bytes per event).\n\n- Case D (boundary with zero record size but nonzero event set):\n  - $N=2$, $\\tau=0.05$, $\\alpha=2.0$, $T_{\\text{end}}=0.05$,\n  - events $[(0.01,0,+1),(0.02,0,+1),(0.03,1,-1)]$,\n  - $\\bar{\\lambda}=5000$ (events per second), $S=0$ (bytes per event).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the two-element list $[B,\\|x(T_{\\text{end}})\\|_2]$ for the corresponding test case, for example $[[B_A,\\|x_A\\|_2],[B_B,\\|x_B\\|_2],[B_C,\\|x_C\\|_2],[B_D,\\|x_D\\|_2]]$. All numeric quantities in the output must be rounded to six decimal places.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of linear time-invariant (LTI) systems and dimensional analysis, well-posed with all necessary information provided for a unique solution, and objective in its language and definitions.\n\nThe solution is divided into two parts: the computation of memory throughput and the reconstruction of the final state vector.\n\n**1. Memory Throughput Calculation**\n\nThe required memory throughput, $B$, is defined as the minimum data rate the system must sustain to process events in real-time without backlog. This is determined by the average rate at which data arrives. The problem provides two key parameters:\n- The average event rate, $\\bar{\\lambda}$, with units of events per second.\n- The per-event record size, $S$, with units of bytes per event.\n\nUsing dimensional analysis, we can determine the memory throughput. We are seeking a quantity with units of bytes per second.\nThe unit of $\\bar{\\lambda}$ is $[\\bar{\\lambda}] = \\frac{\\text{events}}{\\text{second}}$.\nThe unit of $S$ is $[S] = \\frac{\\text{bytes}}{\\text{event}}$.\n\nTo obtain a result in bytes per second, we multiply these two quantities:\n$$ B = \\bar{\\lambda} \\times S $$\nThe units multiply as well:\n$$ [B] = \\left(\\frac{\\text{events}}{\\text{second}}\\right) \\times \\left(\\frac{\\text{bytes}}{\\text{event}}\\right) = \\frac{\\text{bytes}}{\\text{second}} $$\nThis confirms that the memory throughput $B$ is the simple product of the average event rate and the per-event record size.\n\n**2. Final State Reconstruction**\n\nThe state $x_i(t)$ of each accumulator at address $i$ is governed by a leaky integrator model. This is a first-order linear ordinary differential equation for the dynamics between events:\n$$ \\frac{dx_i(t)}{dt} = -\\frac{x_i(t)}{\\tau} $$\nwhere $\\tau$ is the time constant. Given a state $x_i(t_a)$ at time $t_a$, the state will decay exponentially to $x_i(t_b)$ at a later time $t_b  t_a$ according to:\n$$ x_i(t_b) = x_i(t_a) e^{-(t_b - t_a)/\\tau} $$\nAt an event time $t_k$ for address $a_k=i$, the state receives an impulsive input, causing an instantaneous jump:\n$$ x_i(t_k^+) = x_i(t_k^-) + \\alpha p_k $$\nwhere $x_i(t_k^-)$ and $x_i(t_k^+)$ are the states just before and after the event, respectively, $\\alpha$ is the gain, and $p_k$ is the event polarity.\n\nThe system is a linear time-invariant (LTI) system. Therefore, the principle of superposition applies. The final state at time $T_{\\text{end}}$ is the sum of the responses to each individual event impulse, starting from the initial condition $x_i(0)=0$.\n\nConsider a single event $(t_k, a_k, p_k)$ where $a_k = i$. This event introduces an instantaneous change of $\\alpha p_k$ to the state $x_i$ at time $t_k$. This injected \"charge\" then decays exponentially until the final time $T_{\\text{end}}$. The contribution of this single event to the final state $x_i(T_{\\text{end}})$ is given by:\n$$ \\Delta x_i(T_{\\text{end}}) \\leftarrow (t_k, a_k, p_k) = (\\alpha p_k) e^{-(T_{\\text{end}} - t_k)/\\tau} $$\nThis expression is valid for events with time $t_k$ such that $0 \\le t_k \\le T_{\\text{end}}$.\n\nBy superposition, the total final state $x_i(T_{\\text{end}})$ is the sum of the contributions from all events that occurred at address $i$ within the time window. Let $\\mathcal{K}_i$ be the set of indices for all events $(t_k, a_k, p_k)$ where $a_k = i$ and $0 \\le t_k \\le T_{\\text{end}}$. The final state is:\n$$ x_i(T_{\\text{end}}) = \\sum_{k \\in \\mathcal{K}_i} \\alpha p_k e^{-(T_{\\text{end}} - t_k)/\\tau} $$\nThis formulation allows for a direct computation of the final state without needing to simulate the system chronologically. The contributions of all relevant events can be calculated independently and summed for each address.\n\nThe overall algorithm is as follows:\n1. For each test case, calculate the memory throughput $B = \\bar{\\lambda} S$.\n2. Initialize a state vector $x(T_{\\text{end}})$ of size $N$ with all elements set to $0$.\n3. For each event $(t_k, a_k, p_k)$ in the provided list, if $0 \\le t_k \\le T_{\\text{end}}$, calculate its decayed contribution $\\Delta x = \\alpha p_k e^{-(T_{\\text{end}} - t_k)/\\tau}$.\n4. Add this contribution to the corresponding element of the state vector: $x_{a_k}(T_{\\text{end}}) \\leftarrow x_{a_k}(T_{\\text{end}}) + \\Delta x$.\n5. After processing all events, compute the Euclidean norm of the final state vector, $\\|x(T_{\\text{end}})\\|_2 = \\sqrt{\\sum_{i=0}^{N-1} (x_i(T_{\\text{end}}))^2}$.\n6. Format the results $[B, \\|x(T_{\\text{end}})\\|_2]$ to six decimal places as specified.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the AER state reconstruction and memory throughput problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case A (general happy path)\n        {\n            \"N\": 4, \"tau\": 0.05, \"alpha\": 0.5, \"T_end\": 0.10,\n            \"events\": [(0.01, 0, +1), (0.02, 1, +1), (0.04, 0, -1), (0.08, 3, +1)],\n            \"avg_lambda\": 3000, \"S\": 12\n        },\n        # Case B (boundary with zero events and zero average rate)\n        {\n            \"N\": 5, \"tau\": 0.10, \"alpha\": 1.0, \"T_end\": 1.00,\n            \"events\": [],\n            \"avg_lambda\": 0, \"S\": 16\n        },\n        # Case C (unsorted event times with repeated addresses)\n        {\n            \"N\": 3, \"tau\": 0.20, \"alpha\": 1.0, \"T_end\": 0.30,\n            \"events\": [(0.25, 2, +1), (0.05, 2, +1), (0.10, 2, -1), (0.15, 1, +1), (0.18, 1, +1)],\n            \"avg_lambda\": 10000, \"S\": 20\n        },\n        # Case D (boundary with zero record size but nonzero event set)\n        {\n            \"N\": 2, \"tau\": 0.05, \"alpha\": 2.0, \"T_end\": 0.05,\n            \"events\": [(0.01, 0, +1), (0.02, 0, +1), (0.03, 1, -1)],\n            \"avg_lambda\": 5000, \"S\": 0\n        }\n    ]\n\n    formatted_results = []\n    \n    for case in test_cases:\n        # Unpack parameters\n        N = case[\"N\"]\n        tau = case[\"tau\"]\n        alpha = case[\"alpha\"]\n        T_end = case[\"T_end\"]\n        events = case[\"events\"]\n        avg_lambda = case[\"avg_lambda\"]\n        S = case[\"S\"]\n        \n        # 1. Calculate memory throughput B\n        # B = average event rate * size per event\n        B = float(avg_lambda * S)\n\n        # 2. Reconstruct the final state vector x(T_end)\n        x_final = np.zeros(N, dtype=np.float64)\n        \n        # Filter events that are within the valid time window [0, T_end]\n        valid_events = [e for e in events if 0 = e[0] = T_end]\n\n        for t_k, a_k, p_k in valid_events:\n            # Calculate the contribution of the event, decayed to T_end\n            contribution = alpha * p_k * np.exp(-(T_end - t_k) / tau)\n            x_final[a_k] += contribution\n            \n        # 3. Calculate the Euclidean norm of the final state vector\n        norm_x = np.linalg.norm(x_final)\n        \n        # Format the result for this case as a string \"[B,norm]\" with no spaces\n        formatted_results.append(f\"[{B:.6f},{norm_x:.6f}]\")\n        \n    # Join all formatted results into a single line string\n    # e.g., [[B1,norm1],[B2,norm2],...]\n    print(f\"[[{','.join(formatted_results)}]]\")\n\nsolve()\n```"
        }
    ]
}