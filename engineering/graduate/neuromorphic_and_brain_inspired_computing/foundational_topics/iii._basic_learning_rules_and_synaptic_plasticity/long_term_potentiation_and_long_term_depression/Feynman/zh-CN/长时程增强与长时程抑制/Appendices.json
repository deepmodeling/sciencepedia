{
    "hands_on_practices": [
        {
            "introduction": "在神经科学中，确定可塑性是在突触前（影响神经递质释放）还是在突触后（影响受体响应）表达是一个基本问题。配对脉冲比（Paired-Pulse Ratio, PPR）是解决这一问题的经典实验和计算工具。这项实践  要求你推导PPR与关键突触参数之间的数学关系，从而深入理解如何解释关于LTP和LTD的实验数据，并辨别其生物物理表达位点。",
            "id": "4050543",
            "problem": "一个神经形态突触电路被设计用来模拟具有随机囊泡释放和短期动力学的皮层兴奋性突触。可测量的兴奋性突触后电流振幅通过量子分析建模为 $A = n q$，其中 $n$ 是释放的囊泡数量，$q$ 是突触后量子大小（每个囊泡的突触后效能），$n$ 从参数为 $(N, p)$ 的二项分布中抽取，其中 $N$ 是易释放池（RRP）中待释放位点的数量，$p$ 是每个位点的囊泡释放概率。双脉冲协议发出两个由固定时间间隔 $\\Delta t$ 分隔的突触前脉冲，该间隔与囊泡补充时间常数相比很短，因此脉冲之间的补充可以忽略不计。残余钙离子通过一个固定的易化因子增强第二次脉冲的释放概率，该因子与基线 $p$ 的微小变化无关，因此第二次脉冲的 $p$ 满足 $p_{2} = p (1 + \\alpha)$，在选定的 $\\Delta t$ 下 $\\alpha > 0$ 为常数。在工作范围内，突触后响应是线性的（在 $\\Delta t$ 的时间尺度上没有饱和或脱敏）。双脉冲比率（PPR）定义为 $\\mathrm{PPR} = \\frac{\\mathbb{E}[A_{2}]}{\\mathbb{E}[A_{1}]}$，其中 $\\mathbb{E}[A_{1}]$ 和 $\\mathbb{E}[A_{2}]$ 分别是第一次和第二次响应的期望振幅。\n\n从这些定义和假设出发，分析突触前释放概率 $p$ 和囊泡池大小 $N$ 的变化与突触后量子大小 $q$ 的变化在塑造 $\\mathrm{PPR}$ 方面的比较，并利用此来推断哪些长时程增强（LTP）和长时程抑制（LTD）的模式在表达上是突触前的还是突触后的。\n\n在所述模型和假设下，以下哪些陈述必然为真？\n\nA. 在脉冲对间隔期间补充可忽略且易化作用固定的情况下，突触前释放概率 $p$ 的增加必然会降低双脉冲比率，而易释放池大小 $N$ 或量子大小 $q$ 的变化不会改变双脉冲比率。\n\nB. 在固定的 $p$ 下增加 $N$ 会增加双脉冲比率，因为有更多的囊泡留给第二次脉冲；因此，在长时程增强（LTP）期间测得的双脉冲比率增加表明突触前囊泡池的增长。\n\nC. 纯粹增加 $q$ 的突触后长时程增强（LTP）会降低双脉冲比率，因为在相同的量子大小下，第二次响应比第一次更容易发生受体饱和。\n\nD. 减少 $p$ 的突触前长时程抑制（LTD）会通过减少第一次脉冲期间的耗竭来增加双脉冲比率，即使 $N$ 保持不变。",
            "solution": "首先对问题陈述进行验证。\n\n### 第一步：提取已知条件\n- 兴奋性突触后电流振幅模型：$A = nq$。\n- $n$：释放的囊泡数量，服从二项分布 $B(N, p)$。\n- $q$：突触后量子大小（单个囊泡的突触后效能）。\n- $N$：易释放池（RRP）中待释放位点的数量。\n- $p$：第一次脉冲时每个位点的囊泡释放概率。\n- 协议：双脉冲，两个突触前脉冲间隔为 $\\Delta t$。\n- 假设：脉冲间的补充可忽略不计。\n- 易化模型：第二次脉冲的释放概率 $p_2$ 由 $p_{2} = p (1 + \\alpha)$ 给出，其中 $\\alpha > 0$ 是常数。\n- 假设：突触后响应是线性的（无饱和或脱敏）。\n- 双脉冲比率（PPR）定义：$\\mathrm{PPR} = \\frac{\\mathbb{E}[A_{2}]}{\\mathbb{E}[A_{1}]}$，其中 $\\mathbb{E}[A_{1}]$ 和 $\\mathbb{E}[A_{2}]$ 分别是第一次和第二次响应的期望振幅。\n\n### 第二步：使用提取的已知条件进行验证\n该问题描述了一个简化但标准的短期突触可塑性生物物理模型。\n- **科学依据：** 该模型基于神经递质释放的量子假说（$A=nq$）、释放的二项统计特性，以及易释放池（$N$）、释放概率（$p$）、短期易化（$\\alpha > 0$）和短期抑制（通过囊泡耗竭）等概念。这些是突触生理学和计算神经科学中的基石原理。该模型是一个广为接受的简化模型。\n- **良定性：** 问题提供了足够的定义和假设，可以推导出双脉冲比率（PPR）关于模型参数的唯一数学表达式。问题要求基于此推导进行分析，这是一个定义明确的任务。\n- **客观性：** 语言是定量的和精确的。所有术语都在模型内部进行了定义。\n\n我们来检查内部一致性。模型同时包含易化（$p$ 的增加）和抑制（$N$ 的耗竭）。这两者并不矛盾；它们的相互作用是短期可塑性的核心。 “补充可忽略不计”的假设意味着第二次脉冲可用的待释放位点数量减少了第一次脉冲释放的囊泡数量。这是推导中必须使用的关键约束。“线性突触后响应”的假设简化了问题，它允许期望振幅是期望囊泡数和量子大小的乘积，并使量子大小 $q$ 成为一个简单的缩放因子。所有组成部分都是自洽的。\n\n### 第三步：结论与行动\n问题陈述在科学上是合理的、良定的、客观的且内部一致。这是一个有效的问题。我们可以继续进行求解。\n\n### 双脉冲比率（PPR）的推导\n\n对于第一个突触前脉冲，释放的囊泡数 $n_1$ 服从参数为 $N$ 和 $p$ 的二项分布。\n$$n_1 \\sim B(N, p)$$\n释放囊泡的期望数量是该分布的均值：\n$$\\mathbb{E}[n_1] = Np$$\n第一次突触后响应的期望振幅 $\\mathbb{E}[A_1]$ 是：\n$$\\mathbb{E}[A_1] = \\mathbb{E}[n_1 q] = q \\mathbb{E}[n_1] = qNp$$\n\n对于第二个突触前脉冲，有两个效应在起作用：\n1.  **耗竭：** 由于补充可忽略不计，可用于第二次脉冲的待释放位点数量因第一次脉冲中释放了囊泡的位点而减少。如果释放了 $n_1$ 个囊泡，可用位点的数量变为 $N - n_1$。\n2.  **易化：** 每个剩余位点的释放概率增加到 $p_2 = p(1+\\alpha)$。\n\n在第一次脉冲结果（$n_1$）的条件下，第二次脉冲释放的囊泡数 $n_2$ 服从参数为 $(N - n_1, p_2)$ 的二项分布。\n$$n_2 | n_1 \\sim B(N - n_1, p_2)$$\n在 $n_1$ 条件下 $n_2$ 的期望值是：\n$$\\mathbb{E}[n_2 | n_1] = (N - n_1) p_2$$\n为了求得无条件期望 $\\mathbb{E}[n_2]$，我们使用全期望定律：$\\mathbb{E}[n_2] = \\mathbb{E}[\\mathbb{E}[n_2|n_1]]$。\n$$\\mathbb{E}[n_2] = \\mathbb{E}[(N - n_1)p_2] = p_2 \\mathbb{E}[N - n_1] = p_2 (N - \\mathbb{E}[n_1])$$\n代入 $\\mathbb{E}[n_1] = Np$：\n$$\\mathbb{E}[n_2] = p_2 (N - Np) = p_2 N(1-p)$$\n现在，代入 $p_2 = p(1+\\alpha)$：\n$$\\mathbb{E}[n_2] = p(1+\\alpha)N(1-p)$$\n第二次突触后响应的期望振幅 $\\mathbb{E}[A_2]$ 是：\n$$\\mathbb{E}[A_2] = \\mathbb{E}[n_2 q] = q \\mathbb{E}[n_2] = q N p (1+\\alpha)(1-p)$$\n\n最后，我们根据其定义计算双脉冲比率（PPR）：\n$$\\mathrm{PPR} = \\frac{\\mathbb{E}[A_2]}{\\mathbb{E}[A_1]} = \\frac{q N p (1+\\alpha)(1-p)}{q N p}$$\n假设 $q, N, p$ 均不为零，我们可以消去公因子，得到 PPR 的最终表达式：\n$$\\mathrm{PPR} = (1+\\alpha)(1-p)$$\n这个表达式揭示了 PPR 如何依赖于突触前参数 $p$ 和 $\\alpha$，并且重要的是，它与突触前参数 $N$ 和突触后参数 $q$ 无关。\n\n### 评估选项\n\n**A. 在脉冲对间隔期间补充可忽略且易化作用固定的情况下，突触前释放概率 $p$ 的增加必然会降低双脉冲比率，而易释放池大小 $N$ 或量子大小 $q$ 的变化不会改变双脉冲比率。**\n\n-   **$p$ 的影响：** 我们考察 PPR 相对于 $p$ 的导数：$\\frac{\\partial(\\mathrm{PPR})}{\\partial p} = \\frac{\\partial}{\\partial p}[(1+\\alpha)(1-p)] = -(1+\\alpha)$。由于问题陈述 $\\alpha > 0$，该导数恒为负。因此，$p$ 的增加必然导致 PPR 的降低。\n-   **$N$ 的影响：** 推导出的表达式 $\\mathrm{PPR} = (1+\\alpha)(1-p)$ 与 $N$ 无关。因此，$N$ 的变化不改变 PPR。\n-   **$q$ 的影响：** 推导出的 PPR 表达式也与 $q$ 无关。因此，$q$ 的变化不改变 PPR。\n-   这个陈述与我们的推导完全一致。\n-   结论：**正确**。\n\n**B. 在固定的 $p$ 下增加 $N$ 会增加双脉冲比率，因为有更多的囊泡留给第二次脉冲；因此，在长时程增强（LTP）期间测得的双脉冲比率增加表明突触前囊泡池的增长。**\n\n-   陈述的第一部分声称增加 $N$ 会增加 PPR。我们的推导表明 $\\mathrm{PPR} = (1+\\alpha)(1-p)$，这与 $N$ 无关。虽然增加 $N$ 会增加两次脉冲的绝对期望囊泡数，但它不改变它们的比率。所以，这个说法是错误的。\n-   PPR 增加表明 $N$ 增长的结论是基于这个错误的前提。在我们的模型中，PPR 的增加是由 $p$ 的*减少*引起的。$N$ 的增加会导致 LTP（即增加 $\\mathbb{E}[A_1] = qNp$），但使 PPR 保持不变。\n-   结论：**不正确**。\n\n**C. 纯粹增加 $q$ 的突触后长时程增强（LTP）会降低双脉冲比率，因为在相同的量子大小下，第二次响应比第一次更容易发生受体饱和。**\n\n-   所提供的理由（“因为在相同的量子大小下，第二次响应比第一次更容易发生受体饱和”）直接与问题陈述中的一个关键假设相矛盾：“在工作范围内，突触后响应是线性的（在 $\\Delta t$ 的时间尺度上没有饱和或脱敏）”。\n-   在所述模型中，纯粹的突触后 LTP 对应于 $q$ 的增加。我们的推导表明 PPR 与 $q$ 无关。因此，$q$ 的变化不改变 PPR。该陈述声称它会降低 PPR，在给定的假设下是错误的。\n-   结论：**不正确**。\n\n**D. 减少 $p$ 的突触前长时程抑制（LTD）会通过减少第一次脉冲期间的耗竭来增加双脉冲比率，即使 $N$ 保持不变。**\n\n-   该陈述涉及表现为 $p$ 减少的突触前 LTD。\n-   我们分析减少 $p$ 对 $\\mathrm{PPR} = (1+\\alpha)(1-p)$ 的影响。正如在选项 A 的分析中确立的，PPR 与 $p$ 成反比关系。因此，减少 $p$ 将导致 PPR 的增加。\n-   所提供的理由是“通过减少第一次脉冲期间的耗竭”。耗竭是 RRP 中囊泡的消耗。第一次脉冲中释放的期望囊泡数是 $\\mathbb{E}[n_1] = Np$。较小的 $p$ 导致较小的期望释放量，因此耗竭较少。PPR 公式表明，该比率取决于池中*未*耗竭的部分，即 $(1-p)$。较小的 $p$ 使这个因子变大，从而增加 PPR。这个理由在生物物理上和数学上都是合理的。\n-   “即使 $N$ 保持不变”的条件与仅分析 $p$ 的变化是一致的。\n-   结论：**正确**。",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "理解了可塑性的*表达位置*后，一个关键的理论问题是突触权重$w$如何随时间演化以及它们是否保持稳定。这项实践  探讨了两大类尖峰时序依赖可塑性（STDP）模型：加性模型和乘性模型。通过推导这些系统的平衡点，你将发现它们根本不同的稳定性特性，并理解为什么类似乘性的规则对于创建不会在边界饱和的稳定突触至关重要。",
            "id": "4050550",
            "problem": "考虑一个神经形态电路中的单个突触，其效能由一个无量纲的权重 $w$ 表示，该权重被约束在闭区间 $[w_{\\min}, w_{\\max}]$ 内。该突触受脉冲时间依赖可塑性（STDP）的影响，其中长时程增强（LTP）由突触前-突触后脉冲对引起，长时程抑制（LTD）由突触后-突触前脉冲对引起。基于脉冲对的STDP核分别由因果窗口 $W_{+}(\\Delta t)$ 和反因果窗口 $W_{-}(\\Delta t)$ 定义，具体如下：\n$$\nW_{+}(\\Delta t) = \\exp\\!\\left(-\\frac{\\Delta t}{\\tau_{+}}\\right) H(\\Delta t), \\quad W_{-}(\\Delta t) = \\exp\\!\\left(\\frac{\\Delta t}{\\tau_{-}}\\right) H(-\\Delta t),\n$$\n其中 $H(\\cdot)$ 是赫维赛德阶跃函数，$\\tau_{+} > 0$ 是LTP窗口常数，$\\tau_{-} > 0$ 是LTD窗口常数。假设突触前/后脉冲统计量是平稳的，其滞后相关的脉冲对密度与互相关核成正比：\n$$\n\\kappa(\\Delta t) = \\beta \\exp\\!\\left(-\\frac{\\Delta t}{\\tau_{c}}\\right) H(\\Delta t) + \\gamma \\exp\\!\\left(\\frac{\\Delta t}{\\tau_{c}}\\right) H(-\\Delta t),\n$$\n其中 $\\tau_{c} > 0$ 控制相关性衰减，$\\beta, \\gamma > 0$ 调节因果与反因果配对的不对称性。\n\n定义有效因果和反因果配对泛函：\n$$\nS_{+} \\equiv \\int_{-\\infty}^{\\infty} \\kappa(\\Delta t)\\, W_{+}(\\Delta t)\\, \\mathrm{d}\\Delta t, \\quad S_{-} \\equiv \\int_{-\\infty}^{\\infty} \\kappa(\\Delta t)\\, W_{-}(\\Delta t)\\, \\mathrm{d}\\Delta t,\n$$\n并假设一个小的学习率 $\\eta > 0$ 和振幅参数 $A_{+} > 0$ (LTP) 和 $A_{-} > 0$ (LTD)。\n\n考虑两种受突触饱和影响的不同STDP更新模型：\n- 加性STDP：瞬时漂移与 $w$ 无关（在裁剪之前），其表达式为\n$$\n\\frac{\\mathrm{d}w}{\\mathrm{d}t} = \\eta \\Big( A_{+} S_{+} - A_{-} S_{-} \\Big),\n$$\n饱和通过硬裁剪到 $[w_{\\min}, w_{\\max}]$ 来实现。\n- 乘性STDP：瞬时漂移与权重相关并遵循软饱和，其表达式为\n$$\n\\frac{\\mathrm{d}w}{\\mathrm{d}t} = \\eta \\left[ A_{+} \\left(1 - \\frac{w}{w_{\\max}}\\right) S_{+} - A_{-} \\left(\\frac{w}{w_{\\max}}\\right) S_{-} \\right],\n$$\n同时具有相同的硬边界 $[w_{\\min}, w_{\\max}]$。\n\n仅从以上定义和平稳性假设出发，推导出对每个更新模型满足 $\\mathrm{d}w/\\mathrm{d}t = 0$ 的不动点 $w^{\\star}$。然后，对于特定的参数值\n$$\n\\beta = 4, \\quad \\gamma = 4, \\quad \\tau_{c} = 1, \\quad \\tau_{+} = 3, \\quad \\tau_{-} = 1, \\quad A_{+} = 1, \\quad A_{-} = 1, \\quad w_{\\min} = 0, \\quad w_{\\max} = 1,\n$$\n计算相应的不动点 $w_{\\text{add}}^{\\star}$ 和 $w_{\\text{mult}}^{\\star}$。\n\n使用LaTeX的 $\\mathrm{pmatrix}$ 环境，按 $\\big[w_{\\text{add}}^{\\star},\\, w_{\\text{mult}}^{\\star}\\big]$ 的顺序将最终答案表示为行矩阵。无需四舍五入，也不涉及物理单位。",
            "solution": "该问题已经过验证并被确定为有效。它在科学上基于已建立的突触可塑性（STDP）模型，是适定的、客观的、自洽的，并且可以数学形式化。所有必要的参数和模型定义都已提供且无矛盾。因此，我们可以开始求解。\n\n主要任务是通过将突触权重的时间导数 $\\frac{\\mathrm{d}w}{\\mathrm{d}t}$ 设为零，来找到两种不同STDP模型的不动点 $w^{\\star}$。一个关键的预备步骤是计算有效配对泛函 $S_{+}$ 和 $S_{-}$。\n\n首先，我们计算泛函 $S_{+}$，它代表了引起增强的突触前-突触后脉冲对的总速率。\n$$\nS_{+} = \\int_{-\\infty}^{\\infty} \\kappa(\\Delta t)\\, W_{+}(\\Delta t)\\, \\mathrm{d}\\Delta t\n$$\n函数 $W_{+}(\\Delta t) = \\exp(-\\frac{\\Delta t}{\\tau_{+}}) H(\\Delta t)$ 仅在 $\\Delta t > 0$ 时非零。对于 $\\Delta t > 0$，互相关核为 $\\kappa(\\Delta t) = \\beta \\exp(-\\frac{\\Delta t}{\\tau_{c}})$。因此，积分简化为：\n$$\nS_{+} = \\int_{0}^{\\infty} \\left[ \\beta \\exp\\left(-\\frac{\\Delta t}{\\tau_{c}}\\right) \\right] \\left[ \\exp\\left(-\\frac{\\Delta t}{\\tau_{+}}\\right) \\right] \\mathrm{d}\\Delta t\n$$\n$$\nS_{+} = \\beta \\int_{0}^{\\infty} \\exp\\left(-\\Delta t \\left(\\frac{1}{\\tau_{c}} + \\frac{1}{\\tau_{+}}\\right)\\right) \\mathrm{d}\\Delta t\n$$\n这是一个标准的指数积分。计算它，我们得到：\n$$\nS_{+} = \\beta \\left[ -\\frac{1}{\\frac{1}{\\tau_{c}} + \\frac{1}{\\tau_{+}}} \\exp\\left(-\\Delta t \\left(\\frac{1}{\\tau_{c}} + \\frac{1}{\\tau_{+}}\\right)\\right) \\right]_{0}^{\\infty} = \\beta \\left( 0 - \\left( -\\frac{1}{\\frac{1}{\\tau_{c}} + \\frac{1}{\\tau_{+}}} \\right) \\right)\n$$\n$$\nS_{+} = \\frac{\\beta}{\\frac{1}{\\tau_{c}} + \\frac{1}{\\tau_{+}}} = \\beta \\frac{\\tau_{c}\\tau_{+}}{\\tau_{c} + \\tau_{+}}\n$$\n接下来，我们计算泛函 $S_{-}$，它代表了引起抑制的突触后-突触前脉冲对的总速率。\n$$\nS_{-} = \\int_{-\\infty}^{\\infty} \\kappa(\\Delta t)\\, W_{-}(\\Delta t)\\, \\mathrm{d}\\Delta t\n$$\n函数 $W_{-}(\\Delta t) = \\exp(\\frac{\\Delta t}{\\tau_{-}}) H(-\\Delta t)$ 仅在 $\\Delta t  0$ 时非零。对于 $\\Delta t  0$，互相关核为 $\\kappa(\\Delta t) = \\gamma \\exp(\\frac{\\Delta t}{\\tau_{c}})$。积分变为：\n$$\nS_{-} = \\int_{-\\infty}^{0} \\left[ \\gamma \\exp\\left(\\frac{\\Delta t}{\\tau_{c}}\\right) \\right] \\left[ \\exp\\left(\\frac{\\Delta t}{\\tau_{-}}\\right) \\right] \\mathrm{d}\\Delta t\n$$\n$$\nS_{-} = \\gamma \\int_{-\\infty}^{0} \\exp\\left(\\Delta t \\left(\\frac{1}{\\tau_{c}} + \\frac{1}{\\tau_{-}}\\right)\\right) \\mathrm{d}\\Delta t\n$$\n计算该积分：\n$$\nS_{-} = \\gamma \\left[ \\frac{1}{\\frac{1}{\\tau_{c}} + \\frac{1}{\\tau_{-}}} \\exp\\left(\\Delta t \\left(\\frac{1}{\\tau_{c}} + \\frac{1}{\\tau_{-}}\\right)\\right) \\right]_{-\\infty}^{0} = \\gamma \\left( \\frac{1}{\\frac{1}{\\tau_{c}} + \\frac{1}{\\tau_{-}}} - 0 \\right)\n$$\n$$\nS_{-} = \\frac{\\gamma}{\\frac{1}{\\tau_{c}} + \\frac{1}{\\tau_{-}}} = \\gamma \\frac{\\tau_{c}\\tau_{-}}{\\tau_{c} + \\tau_{-}}\n$$\n在建立了 $S_{+}$ 和 $S_{-}$ 的表达式之后，我们可以分析每个模型的不动点。\n\n**1. 加性STDP模型**\n\n权重动态由下式给出：\n$$\n\\frac{\\mathrm{d}w}{\\mathrm{d}t} = \\eta \\left( A_{+} S_{+} - A_{-} S_{-} \\right)\n$$\n并在边界 $[w_{\\min}, w_{\\max}]$ 处进行硬裁剪。漂移项 $\\eta ( A_{+} S_{+} - A_{-} S_{-} )$ 与权重 $w$ 无关。\n一个不动点 $w^{\\star}$ 满足 $\\frac{\\mathrm{d}w}{\\mathrm{d}t} = 0$。在这个模型中，除非漂移恰好为零，否则在开区间 $(w_{\\min}, w_{\\max})$ 内没有不动点。权重会一直漂移，直到达到其中一个边界，在那里它被裁剪并保持固定。\n- 如果 $A_{+} S_{+} - A_{-} S_{-} > 0$，漂移为正，$w(t)$ 增加直到达到上边界。稳定不动点是 $w_{\\text{add}}^{\\star} = w_{\\max}$。\n- 如果 $A_{+} S_{+} - A_{-} S_{-}  0$，漂移为负，$w(t)$ 减少直到达到下边界。稳定不动点是 $w_{\\text{add}}^{\\star} = w_{\\min}$。\n- 如果 $A_{+} S_{+} - A_{-} S_{-} = 0$，漂移为零。任何权重 $w \\in [w_{\\min}, w_{\\max}]$ 都是一个不动点。这是一个非泛化的中性稳定情况。\n\n**2. 乘性STDP模型**\n\n权重动态由下式给出：\n$$\n\\frac{\\mathrm{d}w}{\\mathrm{d}t} = \\eta \\left[ A_{+} \\left(1 - \\frac{w}{w_{\\max}}\\right) S_{+} - A_{-} \\left(\\frac{w}{w_{\\max}}\\right) S_{-} \\right]\n$$\n为了找到不动点 $w_{\\text{mult}}^{\\star}$，我们将 $\\frac{\\mathrm{d}w}{\\mathrm{d}t}$ 设为 0。由于 $\\eta > 0$，这要求方括号内的项为零：\n$$\nA_{+} S_{+} - A_{+} S_{+} \\frac{w_{\\text{mult}}^{\\star}}{w_{\\max}} - A_{-} S_{-} \\frac{w_{\\text{mult}}^{\\star}}{w_{\\max}} = 0\n$$\n$$\nA_{+} S_{+} = \\frac{w_{\\text{mult}}^{\\star}}{w_{\\max}} (A_{+} S_{+} + A_{-} S_{-})\n$$\n解出 $w_{\\text{mult}}^{\\star}$：\n$$\nw_{\\text{mult}}^{\\star} = w_{\\max} \\frac{A_{+} S_{+}}{A_{+} S_{+} + A_{-} S_{-}}\n$$\n由于所有参数 $A_{+}, A_{-}, \\tau_{+}, \\tau_{-}, \\tau_{c}, \\beta, \\gamma, w_{\\max}$ 均为正，所以 $S_{+}$ 和 $S_{-}$ 都是正的。因此，$0  \\frac{A_{+} S_{+}}{A_{+} S_{+} + A_{-} S_{-}}  1$。给定 $w_{\\min} \\ge 0$，如果 $w_{\\min}=0$，这个不动点保证位于区间 $(w_{\\min}, w_{\\max})$ 内，因此代表一个稳定的内部不动点。\n\n**数值计算**\n\n我们现在代入给定的参数值：\n$\\beta = 4$, $\\gamma = 4$, $\\tau_{c} = 1$, $\\tau_{+} = 3$, $\\tau_{-} = 1$, $A_{+} = 1$, $A_{-} = 1$, $w_{\\min} = 0$, $w_{\\max} = 1$。\n\n首先，计算 $S_{+}$ 和 $S_{-}$：\n$$\nS_{+} = 4 \\times \\frac{1 \\times 3}{1 + 3} = 4 \\times \\frac{3}{4} = 3\n$$\n$$\nS_{-} = 4 \\times \\frac{1 \\times 1}{1 + 1} = 4 \\times \\frac{1}{2} = 2\n$$\n现在，我们为每个模型找到不动点。\n\n对于加性模型，我们评估漂移项的符号：\n$$\nA_{+} S_{+} - A_{-} S_{-} = (1)(3) - (1)(2) = 3 - 2 = 1\n$$\n由于结果为正 ($1 > 0$)，权重漂移至上边界。\n$$\nw_{\\text{add}}^{\\star} = w_{\\max} = 1\n$$\n对于乘性模型，我们使用推导出的内部不动点公式：\n$$\nw_{\\text{mult}}^{\\star} = w_{\\max} \\frac{A_{+} S_{+}}{A_{+} S_{+} + A_{-} S_{-}} = 1 \\times \\frac{(1)(3)}{(1)(3) + (1)(2)} = \\frac{3}{3 + 2} = \\frac{3}{5}\n$$\n该值位于区间 $[0, 1]$ 内，符合预期。\n\n计算出的不动点是 $w_{\\text{add}}^{\\star} = 1$ 和 $w_{\\text{mult}}^{\\star} = \\frac{3}{5}$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1  \\frac{3}{5} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "基于可塑性机制和稳定性的概念，这最后一个实践将我们引向功能自适应。这项编码练习  使用Bienenstock-Cooper-Munro（BCM）规则——一种经典的元可塑性模型——来模拟神经元的感受野$\\mathbf{w}(t)$如何动态追踪变化的输入统计特性。通过亲手实现该模型并观察其结果，你将对稳态和赫布原理如何协同工作以在非平稳世界中实现持续学习获得实践性的理解。",
            "id": "4050530",
            "problem": "一个单一速率神经元接收一个确定性的、时变的二维输入，该输入捕捉了漂移的输入统计特性。该神经元拥有一个由权重向量 $\\mathbf{w}(t) \\in \\mathbb{R}^2$ 表示的感受野，并产生一个瞬时标量输出 $y(t) = \\mathbf{w}(t)^\\top \\mathbf{x}(t)$。突触可塑性遵循 Bienenstock–Cooper–Munro (BCM) 规则，通过一个滑动的修正阈值实现元可塑性。元可塑性阈值 $\\theta_M(t)$ 跟踪输出平方的移动平均值。该系统由以下定义学习动力学的常微分方程组控制：\n- 输出：$y(t) = \\mathbf{w}(t)^\\top \\mathbf{x}(t)$。\n- 元可塑性阈值动力学：$\\dfrac{d \\theta_M}{dt} = \\dfrac{1}{\\tau}\\left(y(t)^2 - \\theta_M(t)\\right)$，其中 $\\tau > 0$ 是元可塑性时间常数。\n- 突触可塑性：$\\dfrac{d \\mathbf{w}}{dt} = \\eta \\, y(t)\\, \\mathbf{x}(t)\\,\\big(y(t) - \\theta_M(t)\\big) - \\lambda \\, \\mathbf{w}(t)$，其中 $\\eta > 0$ 是学习率，$\\lambda > 0$ 是一个小的稳态衰减项。\n\n输入是一个漂移刺激分布的确定性均值，被选为一个以角速度 $\\omega$ （弧度/秒）旋转的恒定模长向量。具体来说，$\\mathbf{x}(t) = \\boldsymbol{\\mu}(t)$，其中\n$$\n\\boldsymbol{\\mu}(t) = m \\begin{bmatrix} \\cos(\\omega t) \\\\ \\sin(\\omega t) \\end{bmatrix},\n$$\n其中 $m > 0$ 是输入模长。感受野方向定义为权重向量的极角，$\\phi_w(t) = \\mathrm{atan2}(w_2(t), w_1(t))$（以弧度为单位），输入方向为 $\\phi_\\mu(t) = \\mathrm{atan2}(\\mu_2(t), \\mu_1(t)) = \\omega t$（以弧度为单位）。将瞬时带符号角度偏移量 $\\Delta(t)$（以度为单位）定义为主值差：\n$$\n\\Delta(t) = \\mathrm{wrap}_{(-180,180]}\\left( \\dfrac{180}{\\pi}\\left(\\phi_w(t) - \\phi_\\mu(t)\\right) \\right),\n$$\n其中 $\\mathrm{wrap}_{(-180,180]}(\\cdot)$ 通过加或减 $360$ 的整数倍，将任意实数角度（以度为单位）映射到其在区间 $(-180, 180]$ 内的等效值。量 $\\Delta(t)$ 量化了在 BCM 规则下，由于元可塑性导致的神经元感受野与当前输入方向之间的偏移。\n\n从初始条件 $\\mathbf{w}(0) = \\begin{bmatrix} w_0 \\\\ 0 \\end{bmatrix}$ 和 $\\theta_M(0) = \\theta_0$ 开始，使用适用于一阶常微分方程的固定步长显式格式，在有限时间域 $t \\in [0, T]$ 上对该系统进行积分。在整个过程中使用以下固定常量：\n- 输入模长 $m = 1.0$。\n- 学习率 $\\eta = 0.02$。\n- 权重衰减 $\\lambda = 0.01$。\n- 初始权重分量 $w_0 = 0.1$。\n- 初始阈值 $\\theta_0 = 0.1$。\n- 总模拟时间 $T = 200.0$ 秒。\n- 积分时间步长 $\\Delta t = 0.001$ 秒。\n- 时间平均窗口 $W = 20.0$ 秒。\n\n对于每组参数，计算在最终窗口 $[T - W, T]$ 上的带符号角度偏移量的时间平均值：\n$$\n\\overline{\\Delta} = \\dfrac{1}{N_W} \\sum_{k = N - N_W}^{N - 1} \\Delta(k \\,\\Delta t),\n$$\n其中 $N = \\lfloor T / \\Delta t \\rfloor$ 且 $N_W = \\lfloor W / \\Delta t \\rfloor$。以度为单位报告 $\\overline{\\Delta}$。\n\n您的程序必须实现该动力学系统，并为以下每个测试用例输出平均偏移量 $\\overline{\\Delta}$。这些测试用例改变了漂移速率 $\\omega$ 和元可塑性时间常数 $\\tau$：\n- 测试用例 1：$\\omega = 0.0$，$\\tau = 10.0$。\n- 测试用例 2：$\\omega = 0.05$，$\\tau = 10.0$。\n- 测试用例 3：$\\omega = 0.05$，$\\tau = 200.0$。\n- 测试用例 4：$\\omega = 0.2$，$\\tau = 10.0$。\n- 测试用例 5：$\\omega = 1.0$，$\\tau = 100.0$。\n\n角度单位说明：所有用于平均和输出的角度都必须以度为单位。最终答案必须是四舍五入到三位小数的浮点数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是相应测试用例的 $\\overline{\\Delta}$ 值，四舍五入到三位小数。",
            "solution": "该问题已经过验证，被认为是科学上可靠、适定且客观的。它展示了一个来自计算神经科学的标准模型，特别是带有元可塑性的 Bienenstock–Cooper–Munro (BCM) 学习规则，应用于一个追踪旋转输入刺激的神经元。所有参数、方程和初始条件都已提供，构成了一个完整且可解的问题。\n\n问题的核心是求解一个耦合一阶常微分方程（ODEs）组，该方程组描述了神经元突触权重向量 $\\mathbf{w}(t)$ 及其元可塑性修正阈值 $\\theta_M(t)$ 的时间演化。该系统由以下方程给出：\n$$\n\\dfrac{d \\theta_M}{dt} = \\dfrac{1}{\\tau}\\left(y(t)^2 - \\theta_M(t)\\right)\n$$\n$$\n\\dfrac{d \\mathbf{w}}{dt} = \\eta \\, y(t)\\, \\mathbf{x}(t)\\,\\big(y(t) - \\theta_M(t)\\big) - \\lambda \\, \\mathbf{w}(t)\n$$\n其中神经元的输出是 $y(t) = \\mathbf{w}(t)^\\top \\mathbf{x}(t)$，输入是一个确定性旋转向量 $\\mathbf{x}(t) = \\boldsymbol{\\mu}(t) = m [\\cos(\\omega t), \\sin(\\omega t)]^\\top$。\n\n我们将在时间区间 $t \\in [0, T]$ 上使用前向欧拉法对该系统进行数值求解。鉴于积分时间步长 $\\Delta t = 0.001$ 秒很小，这是一个简单且合适的固定步长显式格式。\n\n设 $k$ 为离散时间索引，使得 $t_k = k \\Delta t$。系统在时间 $t_k$ 的状态由权重向量 $\\mathbf{w}_k = \\mathbf{w}(t_k)$ 和阈值 $\\theta_{M,k} = \\theta_M(t_k)$ 描述。初始条件为 $\\mathbf{w}_0 = [w_0, 0]^\\top$ 和 $\\theta_{M,0} = \\theta_0$。\n\n积分过程是迭代进行的。在每个步骤 $k$，我们首先计算输入向量和神经元的输出：\n$$\n\\mathbf{x}_k = m \\begin{bmatrix} \\cos(\\omega t_k) \\\\ \\sin(\\omega t_k) \\end{bmatrix}\n$$\n$$\ny_k = \\mathbf{w}_k^\\top \\mathbf{x}_k\n$$\n然后，我们计算在时间 $t_k$ 的导数（即常微分方程的右侧）：\n$$\n\\left(\\dfrac{d \\mathbf{w}}{dt}\\right)_k = \\eta \\, y_k\\, \\mathbf{x}_k\\,\\big(y_k - \\theta_{M,k}\\big) - \\lambda \\, \\mathbf{w}_k\n$$\n$$\n\\left(\\dfrac{d \\theta_M}{dt}\\right)_k = \\dfrac{1}{\\tau}\\left(y_k^2 - \\theta_{M,k}\\right)\n$$\n使用这些导数，我们更新状态变量，以找到它们在下一个时间步 $t_{k+1} = (k+1)\\Delta t$ 的值：\n$$\n\\mathbf{w}_{k+1} = \\mathbf{w}_k + \\Delta t \\cdot \\left(\\dfrac{d \\mathbf{w}}{dt}\\right)_k\n$$\n$$\n\\theta_{M,k+1} = \\theta_{M,k} + \\Delta t \\cdot \\left(\\dfrac{d \\theta_M}{dt}\\right)_k\n$$\n对 $k = 0, 1, \\dots, N-1$ 重复此过程，其中 $N = \\lfloor T / \\Delta t \\rfloor$ 是总模拟步数。\n\n在积分的同时，我们在每一步计算瞬时带符号角度偏移量 $\\Delta(t_k)$。这需要找到权重向量的方向 $\\phi_{w,k}$ 和输入向量的方向 $\\phi_{\\mu,k}$：\n$$\n\\phi_{w,k} = \\mathrm{atan2}(w_{2,k}, w_{1,k})\n$$\n$$\n\\phi_{\\mu,k} = \\omega t_k\n$$\n其中 $w_{1,k}$ 和 $w_{2,k}$ 是 $\\mathbf{w}_k$ 的分量。然后将角度差转换为度，并按规定包装到区间 $(-180^\\circ, 180^\\circ]$ 内：\n$$\n\\Delta_k = \\Delta(t_k) = \\mathrm{wrap}_{(-180,180]}\\left( \\dfrac{180}{\\pi}\\left(\\phi_{w,k} - \\phi_{\\mu,k}\\right) \\right)\n$$\n在整个模拟过程中，会存储 $\\Delta_k$ 值的历史记录。\n\n最后，在模拟完成后，我们在持续时间为 $W$ 的最终时间窗口上计算带符号角度偏移量的时间平均值 $\\overline{\\Delta}$。此窗口中的步数是 $N_W = \\lfloor W / \\Delta t \\rfloor$。平均值是根据存储的最后 $N_W$ 个偏移量值计算的：\n$$\n\\overline{\\Delta} = \\dfrac{1}{N_W} \\sum_{k = N - N_W}^{N-1} \\Delta_k\n$$\n对五个测试用例中的每一个都执行这整个过程，这些测试用例的输入角速度 $\\omega$ 和元可塑性时间常数 $\\tau$ 的值不同。然后报告每种情况下得到的平均偏移量 $\\overline{\\Delta}$。",
            "answer": "```python\nimport numpy as np\n\n# from scipy import ... # Scipy is available but not used in this solution.\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print the results.\n    \"\"\"\n\n    # --- Fixed constants from the problem statement ---\n    m = 1.0         # Input magnitude\n    eta = 0.02      # Learning rate\n    lambda_ = 0.01  # Weight decay (using lambda_ to avoid keyword conflict)\n    w0 = 0.1        # Initial weight component\n    theta0 = 0.1    # Initial threshold\n    T = 200.0       # Total simulation time in seconds\n    dt = 0.001      # Integration time step in seconds\n    W = 20.0        # Time-averaging window in seconds\n\n    # --- Test cases ---\n    # Each tuple is (omega, tau)\n    test_cases = [\n        (0.0, 10.0),\n        (0.05, 10.0),\n        (0.05, 200.0),\n        (0.2, 10.0),\n        (1.0, 100.0),\n    ]\n\n    results = []\n    for omega, tau in test_cases:\n        avg_delta = run_simulation(omega, tau, m, eta, lambda_, w0, theta0, T, dt, W)\n        results.append(avg_delta)\n\n    # Format the results to three decimal places\n    formatted_results = [f\"{res:.3f}\" for res in results]\n\n    # Print the final output in the required format\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef wrap_angle(angle_deg):\n    \"\"\"\n    Wraps an angle in degrees to the interval (-180, 180].\n\n    Args:\n        angle_deg (float): The angle in degrees.\n\n    Returns:\n        float: The wrapped angle in degrees.\n    \"\"\"\n    # This formula correctly implements the wrap to (-180, 180]\n    return angle_deg - 360.0 * np.ceil((angle_deg - 180.0) / 360.0)\n\ndef run_simulation(omega, tau, m, eta, lambda_, w0, theta0, T, dt, W):\n    \"\"\"\n    Integrates the neuron's dynamics and computes the average angular offset.\n    \n    Args:\n        omega (float): Input angular velocity (rad/s).\n        tau (float): Metaplasticity time constant (s).\n        All other parameters are the fixed constants.\n\n    Returns:\n        float: The time-averaged signed angular offset in degrees.\n    \"\"\"\n    # --- Simulation setup ---\n    n_steps = int(np.floor(T / dt))\n    n_window = int(np.floor(W / dt))\n\n    # --- Initialization ---\n    w = np.array([w0, 0.0])\n    theta_m = theta0\n    delta_history = np.zeros(n_steps)\n\n    # --- Integration loop ---\n    for k in range(n_steps):\n        t = k * dt\n\n        # 1. Calculate angular offset at current time t\n        phi_w = np.arctan2(w[1], w[0])\n        phi_mu = omega * t\n        diff_deg = np.rad2deg(phi_w - phi_mu)\n        delta_k = wrap_angle(diff_deg)\n        delta_history[k] = delta_k\n\n        # 2. Calculate intermediates for state update\n        x = m * np.array([np.cos(omega * t), np.sin(omega * t)])\n        y = np.dot(w, x)\n\n        # 3. Calculate derivatives at time t\n        dw_dt = eta * y * x * (y - theta_m) - lambda_ * w\n        dtheta_m_dt = (1.0 / tau) * (y**2 - theta_m)\n\n        # 4. Update state variables using Forward Euler method\n        w = w + dw_dt * dt\n        theta_m = theta_m + dtheta_m_dt * dt\n\n    # --- Post-processing: Calculate average over the final window ---\n    final_deltas = delta_history[-n_window:]\n    avg_delta = np.mean(final_deltas)\n\n    return avg_delta\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}