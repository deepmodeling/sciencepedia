{
    "hands_on_practices": [
        {
            "introduction": "脉冲触发平均 ($STA$) 提供了神经元线性感受野的直接估计。然而，原始的 $STA$ 轨迹只是一串数字，为了获得神经科学上的洞见，我们必须从中提取有意义的量化特征。本练习专注于从 $STA$ 中表征时间感受野这一基本任务。你将通过实现一个算法来计算关键指标，如延迟和持续时间，这些指标对应于神经元在时间上整合信息的基本方面。这项练习将锻炼你将理论定义转化为实用分析代码的能力。 ",
            "id": "4060247",
            "problem": "给定跨时间延迟的离散脉冲触发平均 (STA) 轨迹，你需要通过定位 STA 中的峰值来计算主导时间感受野波瓣的时间延迟和持续时间，并将这些量与突触整合特性联系起来。请严格在离散时间下工作。设离散时间延迟定义为 $ \\tau_i = (i - i_0)\\,\\Delta t $，其中 $ i \\in \\{0,1,\\dots,N-1\\} $，$ i_0 $ 是零延迟索引，$ \\Delta t $ 是以毫秒为单位的均匀采样间隔。设 STA 样本由长度为 $ N $ 的实值序列 $ s[i] $ 给出。请使用以下定义和要求计算所请求的量。\n\n基本依据和定义：\n- 脉冲触发平均 (STA) 是在给定刺激 $ x(t) $ 的情况下，脉冲发放前刺激的条件期望，$ \\mathrm{STA}(\\tau) = \\mathbb{E}[x(t-\\tau)\\,|\\,\\text{spike at }t] $。在线性滤波器、加性噪声和单调静态非线性模型下，当刺激是时间白噪声时，STA 与线性时间滤波器（时间感受野）成正比，因此其主瓣编码了最能驱动脉冲发放的时间敏感性分布。\n- 主瓣的时间延迟是 STA 幅值达到其最大绝对值时的时间延迟，$ t_{\\mathrm{lat}} = \\tau_{i_{\\max}} $，其中 $ i_{\\max} = \\arg\\max_i |s[i]| $。\n- 主瓣的持续时间通过该波瓣的半峰全宽 (FWHM) 来量化。设 $ \\sigma = \\mathrm{sign}(s[i_{\\max}]) \\in \\{-1,+1\\} $，并设主瓣为包含 $ i_{\\max} $ 的最大连续索引集 $ \\mathcal{L} = \\{ \\ell,\\ell+1,\\dots,r \\} $，使得对所有 $ j \\in \\mathcal{L} $ 都有 $ s[j]\\cdot\\sigma  0 $，其两侧由第一个过零点或数组边界界定。在 $ \\mathcal{L} $ 上，令 $ a[j] = \\sigma\\, s[j] \\ge 0 $，并令 $ h = \\tfrac{1}{2}\\,a[i_{\\max}] $ 为半峰值。如果存在，则通过在离散网格上进行线性插值来定义左、右半峰值交叉时间：\n  - 找到最小的 $ k \\in \\{\\ell+1,\\dots,i_{\\max}\\} $ 使得 $ a[k-1]  h \\le a[k] $，则\n    $$ \\tau_{\\mathrm{L}} = \\tau_{k-1} + \\frac{h - a[k-1]}{a[k] - a[k-1]}\\,\\Delta t. $$\n  - 找到最大的 $ k \\in \\{ i_{\\max},\\dots,r-1 \\} $ 使得 $ a[k] \\ge h  a[k+1] $，则\n    $$ \\tau_{\\mathrm{R}} = \\tau_{k} + \\frac{h - a[k]}{a[k+1] - a[k]}\\,\\Delta t. $$\n  如果两个交叉点都存在，则 FWHM 持续时间为 $ t_{\\mathrm{dur}} = \\tau_{\\mathrm{R}} - \\tau_{\\mathrm{L}} $。如果只存在一侧的交叉点（左侧或右侧），则定义 $ t_{\\mathrm{dur}} $ 为峰值周围单侧半宽的两倍。如果两侧都不存在，则定义 $ t_{\\mathrm{dur}} = (r-\\ell+1)\\,\\Delta t $。\n- 有效突触整合窗口通过主瓣上的面积与峰值之比来量化，\n  $$ T_{\\mathrm{eff}} = \\frac{\\Delta t \\sum_{j=\\ell}^{r} a[j]}{a[i_{\\max}]}, $$\n  其单位为毫秒，等于输入相对于峰值响应贡献的有效时间尺度，且与波瓣的确切形状无关。这个度量的由来是，对于一个非负核 $ k(t) $，比率 $ \\int k(t)\\,dt / \\max_t k(t) $ 是一个反映整合的类宽度尺度。\n- 主瓣的符号编码了在线性区域内，脉冲前刺激的增加是类兴奋性还是类抑制性：输出一个整数标志 $ u \\in \\{-1,+1\\} $，其中如果 $ \\sigma=+1 $ 则 $ u=+1 $，如果 $ \\sigma=-1 $ 则 $ u=-1 $。\n\n计算任务：\n给定以毫秒为单位的 $ \\Delta t $、零延迟索引 $ i_0 $ 和 STA 样本 $ s[i] $，根据上述定义计算四元组 $ [t_{\\mathrm{lat}},\\, t_{\\mathrm{dur}},\\, T_{\\mathrm{eff}},\\, u] $。所有时间量必须以毫秒表示，并四舍五入到三位小数。符号标志 $ u $ 必须是整数。\n\n测试套件：\n实现你的程序，为以下四种情况计算结果。在每种情况下，定义 $ \\tau_i = (i - i_0)\\,\\Delta t $ 并按规定构造 $ s[i] $。\n\n- 情况 A (单峰高斯瓣):\n  - $ N = 201 $，$ \\Delta t = 1.0 $，$ i_0 = 100 $。\n  - $ s[i] = \\exp\\!\\left( -\\tfrac{1}{2}\\,\\big(\\tfrac{\\tau_i - 25.0}{5.0}\\big)^2 \\right) $。\n\n- 情况 B (双相高斯差分，主导负瓣):\n  - $ N = 181 $，$ \\Delta t = 1.0 $，$ i_0 = 90 $。\n  - $ s[i] = 0.8\\,\\exp\\!\\left( -\\tfrac{1}{2}\\,\\big(\\tfrac{\\tau_i - 35.0}{6.0}\\big)^2 \\right) - 1.2\\,\\exp\\!\\left( -\\tfrac{1}{2}\\,\\big(\\tfrac{\\tau_i - 10.0}{4.0}\\big)^2 \\right) $。\n\n- 情况 C (带延迟的alpha函数突触核):\n  - $ N = 151 $，$ \\Delta t = 1.0 $，$ i_0 = 50 $。\n  - 定义 $ d = 30.0 $ 和 $ \\tau_s = 8.0 $。令\n    $$ s[i] =\n      \\begin{cases}\n        \\left(\\dfrac{\\tau_i - d}{\\tau_s}\\right)\\exp\\!\\left(1 - \\dfrac{\\tau_i - d}{\\tau_s}\\right),  \\text{if } \\tau_i \\ge d,\\\\\n        0,  \\text{if } \\tau_i  d.\n      \\end{cases}\n    $$\n\n- 情况 D (边界情况：单样本瓣):\n  - $ N = 51 $，$ \\Delta t = 1.0 $，$ i_0 = 25 $。\n  - 对所有 $ i $，$ s[i] = 0 $，除了 $ s[i_0 + 5] = 1.0 $。\n\n最终输出格式：\n你的程序应产生单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个元素按 A、B、C、D 的顺序对应一个测试用例，并且其本身是一个四元列表 $ [t_{\\mathrm{lat}}, t_{\\mathrm{dur}}, T_{\\mathrm{eff}}, u] $。例如，打印的结构必须类似于 $ [[\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot],\\dots] $，所有时间量四舍五入到三位小数，且 $ u $ 为整数。不应打印任何额外文本。",
            "solution": "该问题在科学上是有效的、定义明确且自成体系的。它提出了计算神经科学中的一个标准任务：使用通用指标来表征由脉冲触发平均 (STA) 近似的时间感受野。延迟、持续时间和整合时间的定义精确且计算上易于处理。提供的测试用例基于神经响应核的经典模型（高斯、高斯差分、alpha函数），并包括一个边界情况以测试算法的鲁棒性。我们将着手提供一个解决方案。\n\n核心任务是实现一个计算过程，对于给定的离散 STA 轨迹 $s[i]$，提取一组四个特征：延迟 $t_{\\mathrm{lat}}$、持续时间 $t_{\\mathrm{dur}}$、有效整合时间 $T_{\\mathrm{eff}}$ 以及主瓣的符号 $u$。整个过程可以分解为以下几个步骤，这些步骤直接遵循所提供的定义。\n\n**步骤 1：STA 信号生成**\n对于每个测试用例，我们都给定了样本数 $N$、采样间隔 $\\Delta t$ 和零延迟索引 $i_0$。第一步是构建离散时间延迟数组 $\\tau$ 和相应的 STA 信号 $s$。\n时间延迟定义为：\n$$ \\tau_i = (i - i_0)\\,\\Delta t \\quad \\text{for } i \\in \\{0, 1, \\dots, N-1\\} $$\n使用这些时间延迟，根据每种情况提供的特定函数（高斯、高斯差分等）生成 STA 信号 $s[i]$。\n\n**步骤 2：主瓣峰值和符号识别**\n主瓣由 STA 绝对幅值的峰值定义。首先，我们找到 $|s[i]|$ 达到最大值的索引 $i_{\\max}$：\n$$ i_{\\max} = \\arg\\max_i |s[i]| $$\n时间延迟 $t_{\\mathrm{lat}}$ 是对应于此峰值的时间延迟：\n$$ t_{\\mathrm{lat}} = \\tau_{i_{\\max}} = (i_{\\max} - i_0)\\,\\Delta t $$\n主瓣的符号 $\\sigma$ 表示它是类兴奋性（正）还是类抑制性（负）。它由 STA 在峰值处的符号确定，并相应地设置输出标志 $u$：\n$$ \\sigma = \\mathrm{sign}(s[i_{\\max}]) $$\n$$ u = \\sigma $$\n\n**步骤 3：主瓣边界检测**\n主瓣是围绕峰值 $i_{\\max}$ 的连续区域，该区域内所有点的符号与峰值相同。我们必须找到包含 $i_{\\max}$ 的最大连续索引集 $\\mathcal{L} = \\{\\ell, \\ell+1, \\dots, r\\}$，使得对所有 $j \\in \\mathcal{L}$ 都有 $s[j] \\cdot \\sigma  0$。左边界 $\\ell$ 的查找方法是：从 $i_{\\max}$ 开始向后（减小索引 $j$）搜索，找到第一个满足 $s[j] \\cdot \\sigma \\le 0$ 的索引，或者到达数组边界 $j=0$。波瓣内第一个点的索引即为 $\\ell$。类似地，右边界 $r$ 的查找方法是：从 $i_{\\max}$ 开始向前（增加索引 $j$）搜索，找到第一个满足 $s[j] \\cdot \\sigma \\le 0$ 的索引，或者到达数组边界 $j=N-1$。波瓣内最后一个点的索引即为 $r$。\n\n**步骤 4：有效整合时间 ($T_{\\mathrm{eff}}$)**\n该指标量化了整合窗口的有效持续时间。它被计算为波瓣面积与其峰值高度之比。为计算此值，我们首先定义波瓣的正值版本，$a[j] = \\sigma \\cdot s[j]$ 对于 $j \\in \\mathcal{L}$。这个整流后波瓣的峰值为 $a[i_{\\max}] = |s[i_{\\max}]|$。\n波瓣下的面积通过离散求和来近似：\n$$ A_{\\mathrm{lobe}} = \\Delta t \\sum_{j=\\ell}^{r} a[j] = \\Delta t \\sum_{j=\\ell}^{r} \\sigma \\cdot s[j] $$\n那么有效整合时间为：\n$$ T_{\\mathrm{eff}} = \\frac{A_{\\mathrm{lobe}}}{a[i_{\\max}]} = \\frac{\\Delta t \\sum_{j=\\ell}^{r} a[j]}{a[i_{\\max}]} $$\n\n**步骤 5：通过半峰全宽 (FWHM) 计算波瓣持续时间 ($t_{\\mathrm{dur}}$)**\nFWHM 测量波瓣在其最大幅值一半处的宽度。首先，我们计算半峰高：\n$$ h = \\frac{1}{2} a[i_{\\max}] $$\n接下来，我们找到整流后的波瓣 $a[j]$ 穿过此高度 $h$ 的时间点 $\\tau_{\\mathrm{L}}$ 和 $\\tau_{\\mathrm{R}}$。由于信号是离散的，这些点通过在相邻样本之间进行线性插值来找到。\n\n为找到左交叉时间 $\\tau_{\\mathrm{L}}$，我们搜索最小的索引 $k \\in \\{\\ell+1, \\dots, i_{\\max}\\}$ 使得 $a[k-1]  h \\le a[k]$。如果找到这样的 $k$，$\\tau_{\\mathrm{L}}$ 通过插值计算为：\n$$ \\tau_{\\mathrm{L}} = \\tau_{k-1} + \\frac{h - a[k-1]}{a[k] - a[k-1]}\\,\\Delta t $$\n为找到右交叉时间 $\\tau_{\\mathrm{R}}$，我们搜索最大的索引 $k \\in \\{i_{\\max}, \\dots, r-1\\}$ 使得 $a[k] \\ge h  a[k+1]$。如果找到这样的 $k$，$\\tau_{\\mathrm{R}}$ 通过插值计算为：\n$$ \\tau_{\\mathrm{R}} = \\tau_{k} + \\frac{h - a[k]}{a[k+1] - a[k]}\\,\\Delta t $$\n\n然后根据找到的交叉点情况确定持续时间 $t_{\\mathrm{dur}}$：\n1.  如果 $\\tau_{\\mathrm{L}}$ 和 $\\tau_{\\mathrm{R}}$ 都存在，$t_{\\mathrm{dur}} = \\tau_{\\mathrm{R}} - \\tau_{\\mathrm{L}}$。\n2.  如果只有 $\\tau_{\\mathrm{L}}$ 存在，$t_{\\mathrm{dur}} = 2 \\cdot (\\tau_{i_{\\max}} - \\tau_{\\mathrm{L}})$。\n3.  如果只有 $\\tau_{\\mathrm{R}}$ 存在，$t_{\\mathrm{dur}} = 2 \\cdot (\\tau_{\\mathrm{R}} - \\tau_{i_{\\max}})$。\n4.  如果两个交叉点都不存在（例如，一个非常窄的单样本峰），$t_{\\mathrm{dur}} = (r - \\ell + 1) \\cdot \\Delta t$。\n\n这个综合过程为任何给定的 STA 轨迹计算所需的四个量。它针对指定的四个测试用例中的每一个进行实现。所得的基于时间的量（$t_{\\mathrm{lat}}, t_{\\mathrm{dur}}, T_{\\mathrm{eff}}$）按要求四舍五入到三位小数。",
            "answer": "```python\nimport numpy as np\n\ndef compute_sta_features(N, dt, i0, s_func):\n    \"\"\"\n    Computes temporal features of a spike-triggered average (STA) trace.\n    \"\"\"\n    # Step 1: STA Signal Generation\n    indices = np.arange(N)\n    tau = (indices - i0) * dt\n    s = s_func(tau)\n\n    # Handle all-zero STA gracefully, though not expected in tests.\n    if not np.any(s):\n        return [0.0, 0.0, 0.0, 1]\n\n    # Step 2: Dominant Lobe Peak and Sign Identification\n    i_max = np.argmax(np.abs(s))\n    t_lat = (i_max - i0) * dt\n    s_peak = s[i_max]\n    sigma = np.sign(s_peak)\n    if sigma == 0: sigma = 1  # Convention for zero-peak case\n    u = int(sigma)\n\n    # Step 3: Dominant Lobe Boundary Detection\n    l, r = i_max, i_max\n    # Find left boundary\n    if l > 0:\n        for i in range(i_max - 1, -1, -1):\n            if s[i] * sigma > 0:\n                l = i\n            else:\n                break\n    # Find right boundary\n    if r  N - 1:\n        for i in range(i_max + 1, N):\n            if s[i] * sigma > 0:\n                r = i\n            else:\n                break\n\n    # Step 4: Effective Integration Time (T_eff)\n    lobe_indices = np.arange(l, r + 1)\n    a_lobe_values = s[lobe_indices] * sigma\n    a_max = s_peak * sigma\n    \n    if a_max == 0:\n        T_eff = 0.0\n    else:\n        T_eff = dt * np.sum(a_lobe_values) / a_max\n    \n    # Step 5: Lobe Duration (t_dur) via FWHM\n    h = 0.5 * a_max\n    \n    a_full = s * sigma  # Rectified full signal\n    tau_L, tau_R = None, None\n\n    # Find left crossing (search from lobe start up to the peak)\n    for k in range(l + 1, i_max + 1):\n        if a_full[k-1]  h = a_full[k]:\n            if a_full[k] - a_full[k-1] != 0:\n                tau_L = tau[k-1] + (h - a_full[k-1]) / (a_full[k] - a_full[k-1]) * dt\n            else:  # Flat region at half-max\n                tau_L = tau[k]\n            break\n\n    # Find right crossing (search from lobe end down to the peak)\n    # The problem asks for the largest k, so searching backwards and stopping works.\n    for k in range(r - 1, i_max - 1, -1):\n        if a_full[k] >= h > a_full[k+1]:\n            if a_full[k+1] - a_full[k] != 0:\n                tau_R = tau[k] + (h - a_full[k]) / (a_full[k+1] - a_full[k]) * dt\n            else:\n                tau_R = tau[k]\n            break\n\n    # Determine t_dur based on which crossings were found\n    t_peak = tau[i_max]\n    if tau_L is not None and tau_R is not None:\n        t_dur = tau_R - tau_L\n    elif tau_L is not None:\n        t_dur = 2 * (t_peak - tau_L)\n    elif tau_R is not None:\n        t_dur = 2 * (tau_R - t_peak)\n    else: # Neither crossing exists (e.g., single-point lobe)\n        t_dur = (r - l + 1) * dt\n\n    return [\n        round(t_lat, 3),\n        round(t_dur, 3),\n        round(T_eff, 3),\n        u\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A: unimodal Gaussian lobe\n        {\n            \"N\": 201, \"dt\": 1.0, \"i0\": 100,\n            \"s_func\": lambda tau: np.exp(-0.5 * ((tau - 25.0) / 5.0)**2)\n        },\n        # Case B: biphasic difference of Gaussians, dominant negative lobe\n        {\n            \"N\": 181, \"dt\": 1.0, \"i0\": 90,\n            \"s_func\": lambda tau: 0.8 * np.exp(-0.5 * ((tau - 35.0) / 6.0)**2) - 1.2 * np.exp(-0.5 * ((tau - 10.0) / 4.0)**2)\n        },\n        # Case C: alpha-function synaptic kernel with delay\n        {\n            \"N\": 151, \"dt\": 1.0, \"i0\": 50,\n            \"s_func\": lambda tau, d=30.0, tau_s=8.0: np.piecewise(\n                tau, [tau  d], [0.0, lambda t: ((t - d) / tau_s) * np.exp(1 - (t - d) / tau_s)]\n            )\n        },\n        # Case D: boundary case: single-sample lobe\n        {\n            \"N\": 51, \"dt\": 1.0, \"i0\": 25,\n            \"s_func\": lambda tau: np.where(tau == 5.0, 1.0, 0.0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_sta_features(case[\"N\"], case[\"dt\"], case[\"i0\"], case[\"s_func\"])\n        results.append(result)\n\n    # Format the output string as specified in the problem\n    result_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in results]) + \"]\"\n\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "计算出 $STA$ 后，一个关键问题随之而来：观测到的特征是否具有统计显著性，还是可能仅仅由偶然产生？回答这个问题需要一个稳健的假设检验，尤其是在处理具有内部相关性的时间序列数据时。本练习将挑战你对感受野的统计验证进行批判性思考。通过从第一性原理出发进行推理，你将识别出正确的非参数检验程序——一种置换检验——它能同时保留刺激和脉冲序列的时间结构。掌握这一概念对于从神经数据分析中得出有效结论至关重要。 ",
            "id": "4060229",
            "problem": "在呈现时变刺激的同时，记录单个感觉神经元的活动。刺激是一个离散时间序列 $\\{x_t\\}_{t=1}^{T}$，其中 $x_t \\in \\mathbb{R}^d$，假设其为弱平稳且均值为零；脉冲序列为 $\\{n_t\\}_{t=1}^{T}$，其中 $n_t \\in \\{0,1\\}$ 表示在时间窗 $t$ 内是否发生了一个脉冲。脉冲触发平均 (Spike-Triggered Average, STA) 定义为在 $L$ 个延迟范围内，脉冲发生前刺激片段的平均值，从而产生一个以延迟为索引的向量序列。你希望检验脉冲独立于刺激的原假设，且检验必须满足以下约束条件：必须保持 $\\{x_t\\}$ 的时间自相关性和 $\\{n_t\\}$ 的序列结构，并且必须在不依赖高斯假设的情况下，将 I 类错误控制在水平 $\\alpha$。\n\n根据假设检验和置换检验的基本原理，考虑原假设下的可交换性，以及在保持序列内部结构的同时打破 $\\{x_t\\}$ 和 $\\{n_t\\}$ 之间对齐关系的必要性。你的目标是通过对脉冲和刺激进行随机重对齐，构建一个 STA 幅度统计量的零分布，从而推导出一个有效的、用于检验 STA 显著性的非参数检验。\n\n在此情景下，哪个选项正确地阐述了一个能够得出有效的 STA 显著性置换检验的程序和假设，包括如何构建零分布以及如何为一个幅度统计量计算双侧 $p$ 值？\n\nA. 从 $\\{0,1,\\ldots,T-1\\}$ 中均匀抽取一个随机循环时间平移量 $K$，并在保持刺激 $\\{x_t\\}$ 不变的情况下，构建一个置换后的脉冲序列 $n^{(K)}_t = n_{(t-K) \\bmod T}$；对 $B$ 次独立的 $K$ 抽样，每次都重新计算 STA 及其幅度。在 $\\{n_t\\}$ 和 $\\{x_t\\}$ 独立且联合平稳的原假设下，循环平移使得脉冲和刺激之间的对齐关系变得可交换，同时保持了 $\\{x_t\\}$ 的自相关性和 $\\{n_t\\}$ 的序列结构。用这 $B$ 个幅度值形成零分布，并将置换后的幅度值中不小于观测幅度的比例计算为双侧 $p$ 值，同时使用加一平滑来避免 $p$ 值为零。\n\nB. 通过在 $\\{1,\\ldots,T\\}$ 上抽取一个均匀随机置换 $\\pi$ 来随机置换刺激样本，并设置 $x^{(\\pi)}_t = x_{\\pi(t)}$，同时保持 $\\{n_t\\}$ 不变；对此类置换重复 $B$ 次，每次重新计算 STA 幅度以形成零分布，并使用相同的 $p$ 值计算方法。这种置换在原假设下打破了任何刺激-脉冲的依赖关系，因为时间索引被随机地重新分配了。\n\nC. 为每个脉冲时间添加独立的高斯抖动：对于每个在时间 $t_k$ 的脉冲，抽取 $\\varepsilon_k \\sim \\mathcal{N}(0,\\sigma^2)$ 并将脉冲重新定位到 $\\tilde{t}_k = \\lfloor t_k + \\varepsilon_k \\rceil$（裁剪到 $\\{1,\\ldots,T\\}$ 范围内），同时保持 $\\{x_t\\}$ 不变；对 $B$ 次独立的抖动实现，每次都重新计算 STA 幅度，并计算 $p$ 值。这保持了近似的发放率，并且只轻微地扰动了对齐关系，因此它应该能近似零假设下的情况。\n\nD. 将 $\\{x_t\\}$ 和 $\\{n_t\\}$ 都分割成长度为 $L$ 的连续块，并对刺激和脉冲同步地随机置换这些块的顺序；对 $B$ 次块置换，每次都重新计算 STA 幅度，并计算 $p$ 值。这种方法保持了块内的局部自相关性和脉冲的经验不应期结构，同时破坏了全局的对齐关系。",
            "solution": "用户希望我根据特定约束条件，找出一种正确的、用于检验脉冲触发平均 (STA) 显著性的非参数置换检验程序。\n\n这个问题是有效的。所有术语在计算神经科学和统计学中都是标准术语，问题设置在科学上是合理的，并且约束条件定义明确，对于为时间序列数据构建有效的检验至关重要。我将着手提供一个解决方案。\n\n**从基本原理推导**\n\n目标是检验原假设 $H_0$：脉冲序列 $\\{n_t\\}_{t=1}^{T}$ 在统计上独立于刺激序列 $\\{x_t\\}_{t=1}^{T}$。我们需要一个基于置换的非参数检验，该检验需满足两个关键约束：\n1.  保持刺激 $\\{x_t\\}$ 的时间自相关性。\n2.  保持脉冲序列 $\\{n_t\\}$ 的序列结构。\n\n设观测数据为时间序列对 $(\\{x_t\\}, \\{n_t\\})$。置换检验的核心原理是通过创建与原假设 $H_0$ 一致，同时保留原始数据其他统计特性的代理数据集，来为检验统计量生成一个零分布。在 $H_0$ 下，任何由 $\\{x_t\\}$ 和 $\\{n_t\\}$ 的特定时间对齐所产生的属性都纯属巧合。有效的置换集合是在 $H_0$ 下数据可交换的重排集合。\n\n检验统计量是 STA 幅度的某个度量，我们称之为 $A_{obs}$。例如，$A = \\max_{\\tau} \\| \\text{STA}(\\tau) \\|_2$。\n\n这些约束决定了有效的置换策略：\n-   **保持刺激的自相关性：**刺激 $\\{x_t\\}$ 不能进行内部重排。对其值进行简单的置换，即对于一个随机置换 $\\pi$，令 $x'_t = x_{\\pi(t)}$，会破坏其自相关结构。因此，序列 $\\{x_t\\}$ 必须保持完整。\n-   **保持脉冲序列的序列结构：**$\\{n_t\\}$ 的序列结构包括精确的脉冲间期 (ISI) 序列，这反映了如不应性和簇发放动力学等生物物理特性。对 $\\{n_t\\}$ 中的二元值进行简单置换会破坏此结构，并将其替换为伯努利过程的结构，这是不正确的。因此，ISI 序列必须被保留。\n\n为了同时满足这两个约束，我们必须找到一种变换，既能打破两个序列之间的对齐关系，又能使每个序列的内部结构保持不变。\n\n关键的见解来自于刺激 $\\{x_t\\}$ 是弱平稳的这一假设。在独立性的原假设下，联合过程 $(\\{x_t\\}, \\{n_t\\})$ 可被假定为联合平稳。对于一个平稳过程，其统计特性对时间平移是不变的。这意味着如果 $\\{x_t\\}$ 和 $\\{n_t\\}$ 是独立的，那么对齐对 $(x_t, n_t)$ 的联合概率分布与任何平移量 $K$ 下的平移对 $(x_t, n_{t-K})$ 的分布是相同的。因此，对齐关系在平移操作下是可交换的。\n\n这就引出了**循环时间平移程序**：\n1.  保持刺激序列 $\\{x_t\\}$ 不变。\n2.  通过对原始脉冲序列应用一个随机循环时间平移 $K$ 来创建一个代理脉冲序列 $\\{n_t^{(K)}\\}$：$n_t^{(K)} = n_{(t-K-1 \\pmod T) + 1}$（使用问题中基于 1 的索引），或者如果使用基于 0 的索引，则为 $n_t^{(K)} = n_{(t-K) \\pmod T}$。平移量 $K$ 从 $\\{0, 1, \\ldots, T-1\\}$ 中均匀抽取。\n3.  此操作完全保持刺激 $\\{x_t\\}$ 及其自相关性不变。\n4.  它也保留了脉冲序列 $\\{n_t\\}$ 的完整序列结构，因为所有的脉冲间期都得以维持——整个脉冲序列只是带着回环(wrap-around)进行了刚性平移。\n5.  然而，这个程序打破了脉冲和刺激之间的原始对齐关系，从而生成一个来自零分布的新实现，在这个实现中，脉冲与其新的、平移后的时间点的刺激特征是独立的。\n\n通过对许多随机平移量 $K$ 重复此过程，我们可以为每个代理数据计算一个 STA 及其幅度统计量 $A^{(K)}$，从而形成一个经验零分布。然后，$p$ 值就是代理幅度中至少与观测幅度 $A_{obs}$ 一样极端的比例。对于一个非负的幅度统计量，这表示为 $p = \\frac{1}{B} \\sum_{i=1}^{B} \\mathbb{I}(A^{(i)} \\ge A_{obs})$，其中 $B$ 是置换次数。使用像 $p = (1 + \\sum_{i=1}^{B} \\mathbb{I}(A^{(i)} \\ge A_{obs})) / (B+1)$ 这样的平滑版本是避免 $p$ 值为 0 的标准做法。\n\n**逐项分析**\n\n**A. 从 $\\{0,1,\\ldots,T-1\\}$ 中均匀抽取一个随机循环时间平移量 $K$，并在保持刺激 $\\{x_t\\}$ 不变的情况下，构建一个置换后的脉冲序列 $n^{(K)}_t = n_{(t-K) \\bmod T}$；对 $B$ 次独立的 $K$ 抽样，每次都重新计算 STA 及其幅度。在 $\\{n_t\\}$ 和 $\\{x_t\\}$ 独立且联合平稳的原假设下，循环平移使得脉冲和刺激之间的对齐关系变得可交换，同时保持了 $\\{x_t\\}$ 的自相关性和 $\\{n_t\\}$ 的序列结构。用这 $B$ 个幅度值形成零分布，并将置换后的幅度值中不小于观测幅度的比例计算为双侧 $p$ 值，同时使用加一平滑来避免 $p$ 值为零。**\n\n这个选项精确地描述了从基本原理推导出的循环时间平移程序。它正确地指出，该方法在打破序列间相对对齐关系的同时，保留了所需的序列内部结构。它提供了正确的理论依据：在独立性和联合平稳性的原假设下的可交换性。对于幅度统计量，$p$ 值的计算描述也是正确的（将“双侧”解释为对显著量值的检验）。\n**结论：正确。**\n\n**B. 通过在 $\\{1,\\ldots,T\\}$ 上抽取一个均匀随机置换 $\\pi$ 来随机置换刺激样本，并设置 $x^{(\\pi)}_t = x_{\\pi(t)}$，同时保持 $\\{n_t\\}$ 不变；对此类置换重复 $B$ 次，每次重新计算 STA 幅度以形成零分布，并使用相同的 $p$ 值计算方法。这种置换在原假设下打破了任何刺激-脉冲的依赖关系，因为时间索引被随机地重新分配了。**\n\n这个程序是无效的，因为它违反了保持 $\\{x_t\\}$ 时间自相关性的约束。随机打乱一个时间序列的时间索引会破坏其时间依赖性，实际上是将其从其边际分布中转换为一个独立同分布 (i.i.d.) 的样本。典型刺激的自相关性是一个关键特征，必须在零分布中予以保持。\n**结论：不正确。**\n\n**C. 为每个脉冲时间添加独立的高斯抖动：对于每个在时间 $t_k$ 的脉冲，抽取 $\\varepsilon_k \\sim \\mathcal{N}(0,\\sigma^2)$ 并将脉冲重新定位到 $\\tilde{t}_k = \\lfloor t_k + \\varepsilon_k \\rceil$（裁剪到 $\\{1,\\ldots,T\\}$ 范围内），同时保持 $\\{x_t\\}$ 不变；对 $B$ 次独立的抖动实现，每次都重新计算 STA 幅度，并计算 $p$ 值。这保持了近似的发放率，并且只轻微地扰动了对齐关系，因此它应该能近似零假设下的情况。**\n\n这个程序是无效的，因为它违反了保持 $\\{n_t\\}$ 序列结构的约束。通过为每个脉冲时间添加独立的抖动 $\\varepsilon_k$，脉冲间期被改变了。这破坏了脉冲的精确时间模式（例如，不应性和簇发放）。该方法检验的是一个不同的原假设，一个与脉冲时间的精确度相关的假设，而不是整个脉冲序列的独立性。此外，它引入了一个任意参数 $\\sigma^2$，即抖动方差，使得检验依赖于这个选择，而不是在置换意义上完全非参数的。\n**结论：不正确。**\n\n**D. 将 $\\{x_t\\}$ 和 $\\{n_t\\}$ 都分割成长度为 $L$ 的连续块，并对刺激和脉冲同步地随机置换这些块的顺序；对 $B$ 次块置换，每次都重新计算 STA 幅度，并计算 $p$ 值。这种方法保持了块内的局部自相关性和脉冲的经验不应期结构，同时破坏了全局的对齐关系。**\n\n这个程序是无效的，因为它未能恰当地打破被检验的关系。STA 是根据每个脉冲前长度最大为 $L$ 的刺激片段计算的。通过将数据分割成长度为 $L$ 的块并*同步地*置换它们，每个块*内部*的刺激和脉冲之间的对齐关系被完美地保留了下来。由于 STA 是一个在 $L$ 尺度上的局部度量，这种方法在很大程度上未能创建出与原假设一致的代理数据。它破坏了长程依赖性，但保留了 STA 设计用来测量的极短程依赖性。一个有效的检验必须在相关的时间尺度上打破对齐关系。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "脉冲触发分析是外部观察者理解神经元的工具。但是，它与神经元自身的内部过程之间是否存在联系？神经元能否通过局部规则学习其自身的感受野？这最后一个练习通过探索生物学上合理的突触学习规则如何产生感受野，从而在分析和综合之间架起一座桥梁。你将推导并模拟一个简单的相关性学习规则如何使神经元的权重收敛到其输入的脉冲触发平均值。这为我们理解神经回路如何自组织以学习我们用 $STA$ 测量的那些特征提供了深刻的见解。 ",
            "id": "4060251",
            "problem": "考虑一个神经形态和类脑计算中的离散时间突触学习场景，其中突触前和突触后脉冲序列在小时间窗内均被建模为泊松过程。设时间索引 $t$ 处的突触前输入为一个 $d$ 维非负整数向量 $x_t \\in \\mathbb{N}^d$，其中每个坐标 $x_{t,i}$ 是从速率为 $\\lambda_i  0$ 的泊松分布中独立抽取的。定义中心化的突触前活动为 $z_t = x_t - \\lambda$，其中 $\\lambda \\in \\mathbb{R}^d$ 是速率向量。设突触后脉冲指示符为 $s_t \\in \\{0,1\\}$，其中 $s_t = 1$ 表示在时间窗 $t$ 内有一次脉冲，其伯努利概率 $p_t$ 由一个logistic非线性函数给出：\n$$\np_t = \\sigma\\!\\left(b + g\\, w_\\ast^\\top z_t \\right),\n$$\n其中 $w_\\ast \\in \\mathbb{R}^d$ 是一个固定但未知的目标滤波器方向，$b \\in \\mathbb{R}$ 是一个偏置，$g0$ 是一个增益，而 $\\sigma(u) = \\frac{1}{1 + e^{-u}}$ 是logistic函数。这种在小时间窗内的伯努利脉冲发放与用于突触后脉冲发放的非齐次泊松过程模型是一致的。\n\n突触权重向量 $w_t \\in \\mathbb{R}^d$ 根据一个带有稳态衰减的、基于相关的更新规则进行演化：\n$$\nw_{t+1} = w_t + \\eta \\left( s_t z_t - \\delta\\, w_t \\right),\n$$\n其中 $\\eta  0$ 是学习率，$\\delta  0$ 是衰减系数。将中心化输入的脉冲触发平均值 (STM) 定义为：\n$$\nm = \\mathbb{E}\\left[ z_t \\mid s_t = 1 \\right],\n$$\n及其经验估计量：\n$$\n\\hat{m} = \\frac{1}{N_{\\text{spike}}} \\sum_{t: s_t = 1} z_t,\n$$\n其中 $N_{\\text{spike}}$ 是 $s_t=1$ 的时间窗数量。\n\n从泊松过程和伯努利过程的基本定义以及指定的学习规则出发，从第一性原理推导为什么期望更新会使突触权重方向与脉冲触发平均值 $\\hat{m}$ 对齐，其比例常数由衰减 $\\delta$ 设定。然后，实现一个模拟，在大量时间步 $T$ 上估计 $w_T$ 和 $\\hat{m}$，并通过余弦相似度来量化其收敛性：\n$$\n\\mathrm{cos\\_sim}(w_T, \\hat{m}) = \\frac{w_T^\\top \\hat{m}}{\\|w_T\\|_2 \\, \\|\\hat{m}\\|_2},\n$$\n每当两个范数都不为零时。在 $\\|\\hat{m}\\|_2 = 0$ 的情况下，STM 的方向是未明确定义的；在这种情况下，改用最终范数 $\\|w_T\\|_2$ 来量化收敛性。\n\n您的程序必须为以下三个测试用例实现模拟，使用指定的随机种子以保证可复现性，并生成一个单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。每个测试用例的结果是按规定计算的单个浮点数。\n\n用于推导和程序中的定义与假设：\n- 突触前输入 $x_{t,i}$ 在维度和时间上是独立的，且 $x_{t,i} \\sim \\mathrm{Poisson}(\\lambda_i)$。\n- 中心化输入为 $z_t = x_t - \\lambda$，因此 $\\mathbb{E}[z_t] = 0$。\n- 突触后脉冲 $s_t \\sim \\mathrm{Bernoulli}(p_t)$，其中 $p_t = \\sigma(b + g\\, w_\\ast^\\top z_t)$。\n- 学习规则是 $w_{t+1} = w_t + \\eta ( s_t z_t - \\delta w_t )$。\n\n测试套件：\n1. 一般情况（理想路径）：$d = 32$，$T = 120{,}000$，对所有 $i$ 有 $\\lambda_i = 5$，$b = -0.75$，$g = 0.15$，$\\eta = 0.01$，$\\delta = 0.01$，随机种子为 $123$，以及 $w_\\ast$ 是一个从标准正态分布中抽取并归一化为单位长度的随机单位范数向量。输出余弦相似度 $\\mathrm{cos\\_sim}(w_T, \\hat{m})$ 作为浮点数。\n2. 独立性边界情况：$d = 32$，$T = 120{,}000$，对所有 $i$ 有 $\\lambda_i = 5$，$b = -0.75$，$g = 0.0$（使得突触后脉冲独立于 $z_t$），$\\eta = 0.01$，$\\delta = 0.01$，随机种子为 $456$，以及 $w_\\ast = 0$（零向量）。输出最终权重范数 $\\|w_T\\|_2$ 作为浮点数。\n3. 低速率边界情况：$d = 32$，$T = 200{,}000$，对所有 $i$ 有 $\\lambda_i = 5$，$b = -3.0$，$g = 0.5$，$\\eta = 0.005$，$\\delta = 0.01$，随机种子为 $789$，以及 $w_\\ast$ 是一个从标准正态分布中抽取并归一化为单位长度的随机单位范数向量。输出余弦相似度 $\\mathrm{cos\\_sim}(w_T, \\hat{m})$ 作为浮点数。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，“[result1,result2,result3]”），结果的顺序与上面列出的三个测试用例的顺序一致。",
            "solution": "该问题陈述经验证具有科学依据、是适定的、客观且完整的。它描述了计算神经科学和神经形态工程中的一个标准场景。所有参数和条件都已指定，既可以进行理论推导，也可以进行可复现的数值模拟。\n\n### 理论推导\n\n目标是从第一性原理证明，该学习规则使突触权重向量 $w_t$ 与中心化输入的脉冲触发平均值 (STM) $m = \\mathbb{E}[ z_t \\mid s_t = 1 ]$ 对齐。STM的经验估计量是 $\\hat{m}$，对于足够大的时间步数 $T$，我们预期 $\\hat{m} \\approx m$。因此，证明与 $m$ 对齐意味着最终会与 $\\hat{m}$ 对齐。\n\n突触权重向量 $w_t \\in \\mathbb{R}^d$ 根据带有稳态衰减项的、基于相关的更新规则演化：\n$$\nw_{t+1} = w_t + \\eta \\left( s_t z_t - \\delta\\, w_t \\right)\n$$\n其中 $\\eta  0$ 是学习率，$\\delta  0$ 是衰减系数，$s_t \\in \\{0, 1\\}$ 是突触后脉冲指示符，$z_t \\in \\mathbb{R}^d$ 是中心化的突触前活动。\n\n为了理解 $w_t$ 的长期行为，我们分析在一个时间步内权重的期望变化。我们对更新量 $\\Delta w_t = w_{t+1} - w_t$ 关于随机变量 $z_t$ 和 $s_t$ 的分布取期望。该期望以当前权重状态 $w_t$ 为条件。\n$$\n\\mathbb{E}[\\Delta w_t \\mid w_t] = \\mathbb{E}[w_{t+1} - w_t \\mid w_t] = \\mathbb{E}\\left[ \\eta (s_t z_t - \\delta w_t) \\mid w_t \\right]\n$$\n根据期望的线性性质，并注意到在时间 $t$ 的期望计算中 $w_t$ 是一个常数：\n$$\n\\mathbb{E}[\\Delta w_t \\mid w_t] = \\eta \\left( \\mathbb{E}[s_t z_t] - \\delta \\mathbb{E}[w_t] \\right) = \\eta \\left( \\mathbb{E}[s_t z_t] - \\delta w_t \\right)\n$$\n$s_t$ 和 $z_t$ 的分布对 $w_t$ 的依赖性不存在，因为 $p_t$ 依赖于 $w_\\ast$，而不是 $w_t$。\n\n分析的核心在于计算相关项 $\\mathbb{E}[s_t z_t]$。我们可以使用全期望定律，通过以脉冲指示符 $s_t$ 的值为条件来计算它：\n$$\n\\mathbb{E}[s_t z_t] = \\mathbb{E}[s_t z_t \\mid s_t=1] P(s_t=1) + \\mathbb{E}[s_t z_t \\mid s_t=0] P(s_t=0)\n$$\n当 $s_t=1$ 时，表达式变为 $\\mathbb{E}[1 \\cdot z_t \\mid s_t=1] P(s_t=1)$。根据定义，项 $\\mathbb{E}[z_t \\mid s_t=1]$ 就是脉冲触发平均值 $m$。\n当 $s_t=0$ 时，表达式变为 $\\mathbb{E}[0 \\cdot z_t \\mid s_t=0] P(s_t=0) = 0$。\n\n令 $P_{\\text{spike}} = P(s_t=1)$ 表示突触后脉冲的平均概率。将这些代入 $\\mathbb{E}[s_t z_t]$ 的方程中，得到：\n$$\n\\mathbb{E}[s_t z_t] = m \\cdot P_{\\text{spike}} + 0 = P_{\\text{spike}} \\, m\n$$\n这个结果表明，脉冲与中心化输入之间的期望相关性就是脉冲触发平均值，并按平均发放率进行了缩放。\n\n现在，我们将此结果代回期望权重更新的方程中：\n$$\n\\mathbb{E}[\\Delta w_t \\mid w_t] = \\eta \\left( P_{\\text{spike}} \\, m - \\delta w_t \\right)\n$$\n当权重的期望变化为零时，即 $\\mathbb{E}[\\Delta w_t \\mid w_t] = 0$，系统达到一个稳定点，或称平衡点。设 $w_{\\text{eq}}$ 为此平衡点处的权重向量。\n$$\n\\eta \\left( P_{\\text{spike}} \\, m - \\delta w_{\\text{eq}} \\right) = 0\n$$\n由于 $\\eta  0$ 且 $\\delta  0$，我们可以解出 $w_{\\text{eq}}$：\n$$\n\\delta w_{\\text{eq}} = P_{\\text{spike}} \\, m\n$$\n$$\nw_{\\text{eq}} = \\frac{P_{\\text{spike}}}{\\delta} m\n$$\n此推导表明，学习规则期望的不动点 $w_{\\text{eq}}$ 与真实的脉冲触发平均值 $m$ 直接成正比。比例常数由平均发放率 $P_{\\text{spike}}$ 与衰减系数 $\\delta$ 的比值给出。\n\n该学习规则实际上是在一个潜在的目标函数上执行随机梯度上升，该目标函数的最大值位于 $w_{\\text{eq}}$。经过许多时间步后，突触权重向量 $w_t$ 将围绕这个期望平衡值波动。经验脉冲触发平均值 $\\hat{m} = \\frac{1}{N_{\\text{spike}}} \\sum_{t: s_t = 1} z_t$ 是真实STM $m$ 的一个统计估计量。对于大量的时间步 $T$ 和足够数量的脉冲 $N_{\\text{spike}}$，大数定律确保 $\\hat{m}$ 收敛于 $m$。因此，最终的权重向量 $w_T$ 预期将与 $\\hat{m}$ 对齐，因为两者都是根植于神经活动统计特性的同一潜在方向量的估计量（相差一个缩放因子）。\n\n### 模拟实现\n\n所提供的Python代码将为给定的三个测试用例模拟所述过程。它实现了突触前泊松输入、概率性突触后脉冲发放以及突触权重更新的离散时间模拟。在运行模拟 $T$ 个时间步后，它会计算最终的权重向量 $w_T$ 和经验STM $\\hat{m}$。最后，它为每个测试用例计算指定的指标——余弦相似度或向量范数——并以要求的格式打印结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by running three distinct simulations of a synaptic learning rule\n    and computes the specified metric for each case.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (d, T, lam_val, b, g, eta, delta, seed, w_star_mode, metric)\n        (32, 120_000, 5.0, -0.75, 0.15, 0.01, 0.01, 123, 'random', 'cos_sim'),\n        (32, 120_000, 5.0, -0.75, 0.0, 0.01, 0.01, 456, 'zero', 'norm_wT'),\n        (32, 200_000, 5.0, -3.0, 0.5, 0.005, 0.01, 789, 'random', 'cos_sim'),\n    ]\n\n    results = []\n\n    def sigma(u):\n        \"\"\"\n        Computes the logistic sigmoid function with clipping to prevent overflow.\n        \"\"\"\n        # Clip input to a safe range for np.exp to avoid overflow.\n        u_clipped = np.clip(u, -700, 700)\n        return 1.0 / (1.0 + np.exp(-u_clipped))\n\n    for case in test_cases:\n        d, T, lam_val, b, g, eta, delta, seed, w_star_mode, metric = case\n        \n        rng = np.random.default_rng(seed)\n\n        if w_star_mode == 'random':\n            w_star_raw = rng.standard_normal(d)\n            norm_w_star = np.linalg.norm(w_star_raw)\n            # Normalize to unit length, handling the unlikely case of a zero vector.\n            w_star = w_star_raw if norm_w_star == 0 else w_star_raw / norm_w_star\n        elif w_star_mode == 'zero':\n            w_star = np.zeros(d)\n\n        lam_vec = np.full(d, lam_val)\n        w = np.zeros(d)\n        \n        z_sum_spiked = np.zeros(d)\n        n_spike = 0\n        \n        # Pre-compute the decay factor for the weight update\n        decay_factor = 1.0 - eta * delta\n        \n        for _ in range(T):\n            # 1. Generate pre-synaptic Poisson spikes\n            x_t = rng.poisson(lam_vec)\n            \n            # 2. Compute centered input\n            z_t = x_t - lam_vec\n            \n            # 3. Compute post-synaptic spiking probability\n            p_t = sigma(b + g * np.dot(w_star, z_t))\n            \n            # 4. Generate post-synaptic spike\n            s_t = 1 if rng.random()  p_t else 0\n            \n            # 5. Accumulate spike-triggered inputs\n            if s_t == 1:\n                z_sum_spiked += z_t\n                n_spike += 1\n            \n            # 6. Apply learning rule\n            w = decay_factor * w + eta * s_t * z_t\n\n        w_T = w\n        \n        if n_spike > 0:\n            m_hat = z_sum_spiked / n_spike\n        else:\n            m_hat = np.zeros(d)\n\n        # Calculate the result based on the specified metric for the test case\n        if metric == 'cos_sim':\n            norm_wT = np.linalg.norm(w_T)\n            norm_m_hat = np.linalg.norm(m_hat)\n            \n            # Per problem instructions, if m_hat is a zero vector, use norm of w_T.\n            if norm_m_hat == 0:\n                result = norm_wT\n            # Otherwise, if w_T is zero, the similarity is zero.\n            elif norm_wT == 0:\n                result = 0.0\n            # Standard cosine similarity calculation\n            else:\n                result = np.dot(w_T, m_hat) / (norm_wT * norm_m_hat)\n        \n        elif metric == 'norm_wT':\n            # This metric is explicitly requested for Test Case 2\n            result = np.linalg.norm(w_T)\n        \n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}