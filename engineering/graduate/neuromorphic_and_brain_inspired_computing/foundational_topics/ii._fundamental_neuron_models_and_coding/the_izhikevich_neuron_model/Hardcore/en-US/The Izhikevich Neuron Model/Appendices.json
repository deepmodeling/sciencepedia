{
    "hands_on_practices": [
        {
            "introduction": "Before a neuron fires a spike, it typically rests at a stable membrane potential. This exercise guides you through the fundamental process of finding this resting state by treating it as a fixed point of the underlying dynamical system. By calculating the Jacobian matrix and its eigenvalues, you will perform a linear stability analysis to mathematically confirm the stability of this crucial state .",
            "id": "4029541",
            "problem": "Consider the Izhikevich neuron model, which describes the membrane voltage and recovery variable dynamics via the coupled Ordinary Differential Equations (ODEs)\n$$\n\\frac{dv}{dt} = 0.04\\,v^{2} + 5\\,v + 140 - u + I, \\qquad \\frac{du}{dt} = a\\,(b\\,v - u),\n$$\nwith the usual spike-reset mechanism (not engaged at a fixed point). Use the following parameter values, typical of a regular-spiking cortical pyramidal neuron: $a = 0.02$, $b = 0.2$, and a constant external input $I = 3$. A fixed point is defined by the intersection of the voltage and recovery nullclines, given by $dv/dt = 0$ and $du/dt = 0$ respectively. Among the fixed points, focus on the lower-voltage intersection (the more hyperpolarized one).\n\nStarting from the fundamental definitions of a fixed point, nullclines, Jacobian of a dynamical system, and linear stability (real parts of eigenvalues), perform the following:\n\n- Determine the fixed point $(v^{\\ast}, u^{\\ast})$ as the intersection of the nullclines.\n- Compute the Jacobian matrix at $(v^{\\ast}, u^{\\ast})$ and derive its eigenvalues to assess local linear stability.\n- Report the maximum real part of the eigenvalues at $(v^{\\ast}, u^{\\ast})$ as a single closed-form analytic expression. Use the model’s native time unit and express the value in inverse milliseconds. Do not round your final expression.",
            "solution": "The problem requires an analysis of a fixed point of the Izhikevich neuron model. The process involves identifying the fixed point, linearizing the system dynamics around this point by computing the Jacobian matrix, and then determining the local stability by calculating the eigenvalues of the Jacobian. The final requested quantity is the maximum of the real parts of these eigenvalues.\n\nThe dynamical system is described by the coupled ordinary differential equations:\n$$\n\\frac{dv}{dt} = 0.04\\,v^{2} + 5\\,v + 140 - u + I\n$$\n$$\n\\frac{du}{dt} = a\\,(b\\,v - u)\n$$\nThe provided parameters are $a = 0.02$, $b = 0.2$, and the external input current is $I = 3$. The units of the variables and parameters are such that time $t$ is in milliseconds ($ms$) and voltage $v$ is in millivolts ($mV$).\n\nFirst, we find the fixed point $(v^{\\ast}, u^{\\ast})$ of the system by setting the time derivatives to zero.\nThe nullclines are given by:\n1.  Voltage nullcline ($\\frac{dv}{dt} = 0$): $0.04\\,v^{2} + 5\\,v + 140 - u + I = 0$\n2.  Recovery nullcline ($\\frac{du}{dt} = 0$): $a\\,(b\\,v - u) = 0$\n\nFrom the recovery nullcline, since $a = 0.02 \\ne 0$, we must have $b\\,v - u = 0$. This gives a linear relationship between $u$ and $v$ at the fixed point:\n$$\nu = b\\,v\n$$\nWe substitute this expression for $u$ into the voltage nullcline equation:\n$$\n0.04\\,v^{2} + 5\\,v + 140 - (b\\,v) + I = 0\n$$\n$$\n0.04\\,v^{2} + (5 - b)v + (140 + I) = 0\n$$\nNow, we substitute the given values for the parameters $b = 0.2$ and $I = 3$:\n$$\n0.04\\,v^{2} + (5 - 0.2)v + (140 + 3) = 0\n$$\n$$\n0.04\\,v^{2} + 4.8\\,v + 143 = 0\n$$\nThis is a quadratic equation for the voltage $v$ at the fixed point(s). We solve for $v$ using the quadratic formula, $v = \\frac{-B \\pm \\sqrt{B^2 - 4AC}}{2A}$, with $A=0.04$, $B=4.8$, and $C=143$:\n$$\nv = \\frac{-4.8 \\pm \\sqrt{(4.8)^{2} - 4(0.04)(143)}}{2(0.04)}\n$$\n$$\nv = \\frac{-4.8 \\pm \\sqrt{23.04 - 22.88}}{0.08}\n$$\n$$\nv = \\frac{-4.8 \\pm \\sqrt{0.16}}{0.08}\n$$\n$$\nv = \\frac{-4.8 \\pm 0.4}{0.08}\n$$\nThis yields two possible values for $v$:\n$$\nv_{1} = \\frac{-4.8 + 0.4}{0.08} = \\frac{-4.4}{0.08} = -55\n$$\n$$\nv_{2} = \\frac{-4.8 - 0.4}{0.08} = \\frac{-5.2}{0.08} = -65\n$$\nThe problem specifies to use the \"lower-voltage intersection (the more hyperpolarized one)\", which corresponds to the more negative value. Thus, we select $v^{\\ast} = -65$.\n\nNow, we find the corresponding value of the recovery variable $u^{\\ast}$ using the relation $u = b\\,v$:\n$$\nu^{\\ast} = b\\,v^{\\ast} = 0.2 \\times (-65) = -13\n$$\nThe relevant fixed point is $(v^{\\ast}, u^{\\ast}) = (-65, -13)$.\n\nNext, we compute the Jacobian matrix of the system to analyze its stability. The system can be written as $\\frac{d\\mathbf{x}}{dt} = \\mathbf{F}(\\mathbf{x})$, where $\\mathbf{x} = [v, u]^T$ and $\\mathbf{F}(\\mathbf{x}) = [f(v,u), g(v,u)]^T$ with:\n$$\nf(v, u) = 0.04\\,v^{2} + 5\\,v + 140 - u + I\n$$\n$$\ng(v, u) = a\\,(b\\,v - u) = ab\\,v - au\n$$\nThe Jacobian matrix $J$ is given by:\n$$\nJ = \\begin{pmatrix} \\frac{\\partial f}{\\partial v} & \\frac{\\partial f}{\\partial u} \\\\ \\frac{\\partial g}{\\partial v} & \\frac{\\partial g}{\\partial u} \\end{pmatrix} = \\begin{pmatrix} 0.08\\,v + 5 & -1 \\\\ ab & -a \\end{pmatrix}\n$$\nWe evaluate this matrix at the fixed point $(v^{\\ast}, u^{\\ast}) = (-65, -13)$, substituting the parameter values $a = 0.02$ and $b = 0.2$:\n$$\nJ^{\\ast} = J(-65, -13) = \\begin{pmatrix} 0.08(-65) + 5 & -1 \\\\ (0.02)(0.2) & -0.02 \\end{pmatrix}\n$$\n$$\nJ^{\\ast} = \\begin{pmatrix} -5.2 + 5 & -1 \\\\ 0.004 & -0.02 \\end{pmatrix} = \\begin{pmatrix} -0.2 & -1 \\\\ 0.004 & -0.02 \\end{pmatrix}\n$$\nThe eigenvalues $\\lambda$ of the Jacobian matrix $J^{\\ast}$ determine the local stability. They are the roots of the characteristic equation $\\det(J^{\\ast} - \\lambda I) = 0$, where $I$ is the identity matrix. The characteristic equation for a $2 \\times 2$ matrix is $\\lambda^{2} - \\text{Tr}(J^{\\ast})\\lambda + \\det(J^{\\ast}) = 0$.\n\nThe trace of $J^{\\ast}$ is:\n$$\n\\text{Tr}(J^{\\ast}) = -0.2 + (-0.02) = -0.22\n$$\nThe determinant of $J^{\\ast}$ is:\n$$\n\\det(J^{\\ast}) = (-0.2)(-0.02) - (-1)(0.004) = 0.004 + 0.004 = 0.008\n$$\nThe characteristic equation is therefore:\n$$\n\\lambda^{2} - (-0.22)\\lambda + 0.008 = 0\n$$\n$$\n\\lambda^{2} + 0.22\\lambda + 0.008 = 0\n$$\nWe solve for the eigenvalues $\\lambda$ using the quadratic formula:\n$$\n\\lambda = \\frac{-0.22 \\pm \\sqrt{(0.22)^{2} - 4(1)(0.008)}}{2(1)}\n$$\n$$\n\\lambda = \\frac{-0.22 \\pm \\sqrt{0.0484 - 0.032}}{2}\n$$\n$$\n\\lambda = \\frac{-0.22 \\pm \\sqrt{0.0164}}{2}\n$$\nThe discriminant $0.0164$ is positive, so the two eigenvalues are real. The real parts of the eigenvalues are the eigenvalues themselves. The two eigenvalues are:\n$$\n\\lambda_{1} = \\frac{-0.22 + \\sqrt{0.0164}}{2} \\quad \\text{and} \\quad \\lambda_{2} = \\frac{-0.22 - \\sqrt{0.0164}}{2}\n$$\nThe problem asks for the maximum real part of the eigenvalues. This is clearly $\\lambda_{1}$. To provide a closed-form analytic expression, we simplify the term under the square root:\n$$\n\\sqrt{0.0164} = \\sqrt{\\frac{164}{10000}} = \\frac{\\sqrt{4 \\times 41}}{100} = \\frac{2\\sqrt{41}}{100} = \\frac{\\sqrt{41}}{50}\n$$\nSubstituting this back into the expression for $\\lambda_1$:\n$$\n\\lambda_{\\max} = \\frac{1}{2}\\left(-0.22 + \\frac{\\sqrt{41}}{50}\\right) = \\frac{1}{2}\\left(-\\frac{22}{100} + \\frac{2\\sqrt{41}}{100}\\right) = \\frac{1}{2}\\left(\\frac{-22 + 2\\sqrt{41}}{100}\\right) = \\frac{-11 + \\sqrt{41}}{100}\n$$\nThe value of $\\sqrt{41}$ is approximately $6.4$, so $-11 + \\sqrt{41}$ is negative. This confirms that the fixed point is a stable node, as expected for the resting state of a neuron model. The maximum real part of the eigenvalues is $\\frac{-11 + \\sqrt{41}}{100}$. The time unit of the model is milliseconds ($ms$), so the eigenvalue has units of $ms^{-1}$.",
            "answer": "$$\\boxed{\\frac{-11 + \\sqrt{41}}{100}}$$"
        },
        {
            "introduction": "The true power of the Izhikevich model lies in its ability to reproduce complex spiking patterns with computational efficiency. This practice moves from static analysis to dynamic simulation, where you will implement the model to generate spike trains in response to an input current. You will then quantify spike-frequency adaptation, a key feature of many biological neurons, by measuring how the time between spikes changes over the course of a simulation .",
            "id": "4064812",
            "problem": "Design and implement a program that simulates the Izhikevich spiking neuron in the regular spiking (RS) regime and computes inter-spike intervals (ISIs) and an adaptation ratio. Use the following definitions, which are the foundation for the Izhikevich model. The membrane potential is denoted by $v$ (in $\\mathrm{mV}$), the recovery variable by $u$, and the externally applied current by $I$ (in model-consistent current units that yield $v$ in $\\mathrm{mV}$ and time in $\\mathrm{ms}$). The Izhikevich model is governed by the system of ordinary differential equations (ODEs): \n$$\n\\frac{dv}{dt} = 0.04v^2 + 5v + 140 - u + I, \\quad \\frac{du}{dt} = a(bv - u),\n$$\nwith an after-spike reset condition applied when the membrane potential reaches the spike threshold:\n$$\n\\text{if } v \\ge 30 \\text{ (in } \\mathrm{mV}\\text{)}, \\text{ then set } v \\leftarrow c \\text{ and } u \\leftarrow u + d.\n$$\nAssume initial conditions $v(0)=c$ and $u(0)=bv(0)$. Simulate using a fixed-step explicit Euler method with a time step $\\Delta t$ (in $\\mathrm{ms}$), and implement spike event detection by linear interpolation within each time step: if $v$ crosses the spike threshold from below within a step, estimate the spike time $t_{\\text{spike}}$ in $\\mathrm{ms}$ by linearly interpolating between the pre-step and post-step values of $v$. Use the first crossing per step, and immediately apply the reset rule at that step.\n\nDefine the inter-spike intervals (ISIs) as the differences between successive spike times, in milliseconds. The adaptation ratio is defined as the ratio $\\text{ISI}_1/\\text{ISI}_5$, where $\\text{ISI}_k$ denotes the $k$-th ISI (in order of occurrence). If fewer than $6$ spikes occur within the simulation window, define the adaptation ratio as $\\mathrm{nan}$ (not-a-number).\n\nAll times must be expressed in $\\mathrm{ms}$, voltages in $\\mathrm{mV}$, and the adaptation ratio is dimensionless. Your program must compute results for the test suite below and produce a single line of output containing the adaptation ratios for each test case as a comma-separated list enclosed in square brackets, e.g., \n$[\\text{ratio}_1,\\text{ratio}_2,\\text{ratio}_3]$. Round each ratio to $6$ decimal places. If a ratio is undefined, output $\\mathrm{nan}$ in its position.\n\nTest suite (all cases use the RS parameters):\n- Regular spiking (RS) parameters: $(a,b,c,d) = (0.02,0.2,-65,8)$.\n- Spike threshold: $30 \\,\\mathrm{mV}$.\n\nCases:\n- Case A (happy path): constant current $I=14$, total simulation time $T=1000 \\,\\mathrm{ms}$, time step $\\Delta t = 0.1 \\,\\mathrm{ms}$.\n- Case B (low-current boundary): constant current $I=5$, total simulation time $T=1000 \\,\\mathrm{ms}$, time step $\\Delta t = 0.1 \\,\\mathrm{ms}$.\n- Case C (high-current and smaller step): constant current $I=30$, total simulation time $T=500 \\,\\mathrm{ms}$, time step $\\Delta t = 0.05 \\,\\mathrm{ms}$.\n\nFor each case, compute the first five inter-spike intervals in $\\mathrm{ms}$, then compute the adaptation ratio $\\text{ISI}_1/\\text{ISI}_5$. The required final output format is a single line:\n$[\\text{ratio}_A,\\text{ratio}_B,\\text{ratio}_C]$\nwith each numeric value rounded to $6$ decimals and with $\\mathrm{nan}$ where fewer than $6$ spikes occurred within the window. No other text should be printed.",
            "solution": "The user wants to simulate the Izhikevich neuron model, specifically for the regular spiking (RS) regime, and compute a spike adaptation ratio from the resulting spike train.\n\n### Step 1: Problem Validation\n\nFirst, I will validate the problem statement according to the specified criteria.\n\n#### Givens Extraction\n\n-   **Model Equations**:\n    $$\n    \\frac{dv}{dt} = 0.04v^2 + 5v + 140 - u + I\n    $$\n    $$\n    \\frac{du}{dt} = a(bv - u)\n    $$\n-   **State Variables**: $v$ (membrane potential, $\\mathrm{mV}$), $u$ (recovery variable, with units of $\\mathrm{mV/ms}$).\n-   **Input Current**: $I$.\n-   **Spike Reset Condition**: If $v \\ge 30 \\, \\mathrm{mV}$, then $v \\leftarrow c$ and $u \\leftarrow u + d$.\n-   **Initial Conditions**: $v(0)=c$, $u(0)=bv(0)$.\n-   **Simulation Method**: Fixed-step explicit Euler method with time step $\\Delta t$.\n-   **Spike Detection**: Linear interpolation for spike time $t_{\\text{spike}}$ when $v$ crosses the threshold of $30 \\, \\mathrm{mV}$ from below within a time step. The reset is to be applied \"at that step\".\n-   **Definitions**:\n    -   Inter-Spike Interval (ISI): Time difference between successive spikes.\n    -   Adaptation Ratio: $\\text{ISI}_1/\\text{ISI}_5$. Value is $\\mathrm{nan}$ if fewer than $6$ spikes occur.\n-   **Parameters**:\n    -   Regular Spiking (RS): $(a,b,c,d) = (0.02, 0.2, -65, 8)$.\n    -   Spike Threshold: $30 \\, \\mathrm{mV}$.\n-   **Test Cases**:\n    -   Case A: $I=14$, $T=1000 \\, \\mathrm{ms}$, $\\Delta t = 0.1 \\, \\mathrm{ms}$.\n    -   Case B: $I=5$, $T=1000 \\, \\mathrm{ms}$, $\\Delta t = 0.1 \\, \\mathrm{ms}$.\n    -   Case C: $I=30$, $T=500 \\, \\mathrm{ms}$, $\\Delta t = 0.05 \\, \\mathrm{ms}$.\n-   **Output Format**: A single line `[ratio_A,ratio_B,ratio_C]`, with ratios rounded to $6$ decimal places and including `nan` where appropriate.\n\n#### Validation Analysis\n\n1.  **Scientifically Grounded**: The problem is based on the Izhikevich neuron model, a cornerstone of computational neuroscience published in a highly-cited 2003 paper. The parameters and behavior (regular spiking) are standard and well-documented. The problem is scientifically sound.\n2.  **Well-Posed**: The problem provides a complete set of differential equations, initial conditions, parameters, and a specified numerical method (explicit Euler). This ensures that a unique numerical solution can be computed. The required outputs are unambiguously defined based on the simulation results.\n3.  **Objective**: The problem is stated using precise mathematical and computational language. All parameters and conditions are given as objective numerical values.\n4.  **Completeness and Consistency**: All necessary information is provided. Variables, parameters, and units ($\\mathrm{mV}$, $\\mathrm{ms}$) are consistent throughout the problem description.\n5.  **No Other Flaws**: The problem is not trivial, metaphorical, or outside the scope of scientific verifiability. It is a standard numerical simulation task in a scientific domain.\n\n#### Verdict\n\nThe problem is **valid**. It is a well-defined task in computational neuroscience that requires the implementation of a standard numerical method to simulate a well-known model.\n\n### Step 2: Solution Design and Implementation\n\nThe solution involves numerically integrating the given system of two ordinary differential equations (ODEs) using the explicit Euler method, while handling the specified spike-and-reset condition.\n\n#### Numerical Method: Explicit Euler\n\nThe explicit Euler method approximates the state of the system at time $t + \\Delta t$ based on the state and its rate of change at time $t$. For our system $(v, u)$, the update rules for a single time step $\\Delta t$ are:\n$$\nv_{n+1} = v_n + \\Delta t \\cdot \\left( \\frac{dv}{dt} \\right)\\bigg|_{t_n} = v_n + \\Delta t \\cdot (0.04v_n^2 + 5v_n + 140 - u_n + I)\n$$\n$$\nu_{n+1} = u_n + \\Delta t \\cdot \\left( \\frac{du}{dt} \\right)\\bigg|_{t_n} = u_n + \\Delta t \\cdot a(bv_n - u_n)\n$$\nHere, $(v_n, u_n)$ represents the state at the beginning of the step (time $t_n$), and $(v_{n+1}, u_{n+1})$ is the tentative state at the end of the step (time $t_{n+1} = t_n + \\Delta t$).\n\n#### Simulation Algorithm\n\nFor each test case, the simulation proceeds as follows:\n1.  **Initialization**:\n    -   Set the parameters $(a,b,c,d,I,T,\\Delta t)$ for the specific case.\n    -   Initialize the state variables at time $t=0$: $v \\leftarrow c$ and $u \\leftarrow b \\cdot c$.\n    -   Initialize an empty list, `spike_times`, to store the times at which spikes occur.\n\n2.  **Time-Stepping Loop**: The simulation iterates for a total time $T$, with a fixed time step $\\Delta t$. In each step, from current time $t$ and state $(v, u)$:\n    -   Store the current voltage as $v_{\\text{old}} \\leftarrow v$.\n    -   Compute the tentative next state $(v_{\\text{next}}, u_{\\text{next}})$ at time $t+\\Delta t$ using the explicit Euler formulas described above.\n    -   **Spike Detection**: Check if the membrane potential has crossed the spike threshold $v_{\\text{thresh}} = 30 \\, \\mathrm{mV}$ from below. This condition is $v_{\\text{old}} < v_{\\text{thresh}}$ and $v_{\\text{next}} \\ge v_{\\text{thresh}}$.\n    -   **State Update**:\n        -   **If a spike is detected**:\n            1.  The precise spike time, $t_{\\text{spike}}$, is estimated using linear interpolation between the points $(t, v_{\\text{old}})$ and $(t+\\Delta t, v_{\\text{next}})$:\n                $$\n                t_{\\text{spike}} = t + \\Delta t \\frac{v_{\\text{thresh}} - v_{\\text{old}}}{v_{\\text{next}} - v_{\\text{old}}}\n                $$\n            2.  This $t_{\\text{spike}}$ is appended to the `spike_times` list.\n            3.  The after-spike reset rule is applied to determine the state for the next time step. The problem specifies a fixed-step method and an immediate reset \"at that step\". This is interpreted to mean the state at time $t+\\Delta t$ becomes the reset state. The voltage is reset to $c$, and the recovery variable $u$ is incremented by $d$. The value of $u$ to be incremented is the one calculated for the end of the step, $u_{\\text{next}}$, as this reflects the accumulation of the recovery process during the action potential's upstroke. Thus, for the next step, we set:\n                $$\n                v \\leftarrow c\n                $$\n                $$\n                u \\leftarrow u_{\\text{next}} + d\n                $$\n        -   **If no spike is detected**: The state for the next step is simply the Euler-approximated state:\n            $$\n            v \\leftarrow v_{\\text{next}}\n            $$\n            $$\n            u \\leftarrow u_{\\text{next}}\n            $$\n\n3.  **Post-Simulation Analysis**:\n    -   After the simulation loop completes, check the number of recorded spikes.\n    -   If fewer than $6$ spikes were recorded, it's not possible to compute five ISIs. In this case, the adaptation ratio is defined as not-a-number ($\\mathrm{nan}$).\n    -   If $6$ or more spikes were recorded, the Inter-Spike Intervals (ISIs) are calculated as the differences between consecutive spike times: $\\text{ISI}_k = t_{\\text{spike}, k+1} - t_{\\text{spike}, k}$.\n    -   The adaptation ratio is then computed as the ratio of the first ISI to the fifth ISI:\n        $$\n        \\text{Ratio} = \\frac{\\text{ISI}_1}{\\text{ISI}_5}\n        $$\n\n4.  **Final Output**: The computed ratio is rounded to $6$ decimal places. The results for all test cases are collected and formatted into the required string `[ratio_A,ratio_B,ratio_C]`.\n\nThis entire procedure is encapsulated in a Python script. A function `simulate_neuron` implements the simulation and analysis for a single test case, and a `solve` function iterates through the given test suite, calling the simulation function and printing the final formatted result.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_neuron(params):\n    \"\"\"\n    Simulates the Izhikevich neuron model for a given set of parameters.\n\n    Args:\n        params (tuple): A tuple containing (a, b, c, d, I, T, dt).\n\n    Returns:\n        float: The computed adaptation ratio, or np.nan if undefined.\n    \"\"\"\n    # Unpack parameters\n    a, b, c, d, I, T, dt = params\n    v_thresh = 30.0\n\n    # Initial conditions\n    v = c\n    u = b * c\n    \n    spike_times = []\n    \n    # Use a precise number of steps to avoid floating point issues with the loop range\n    num_steps = int(round(T / dt))\n\n    for i in range(num_steps):\n        current_t = i * dt\n        v_old = v\n        \n        # Explicit Euler step: calculate derivatives at the current state (v, u)\n        dv_dt = 0.04 * v**2 + 5 * v + 140 - u + I\n        du_dt = a * (b * v - u)\n        \n        # Calculate tentative state for the next time step\n        v_next = v + dv_dt * dt\n        u_next = u + du_dt * dt\n        \n        # Spike detection: check for threshold crossing from below\n        if v_old < v_thresh and v_next >= v_thresh:\n            # Estimate spike time using linear interpolation\n            if v_next - v_old > 0: # Avoid division by zero\n                t_spike = current_t + dt * (v_thresh - v_old) / (v_next - v_old)\n                spike_times.append(t_spike)\n            else: # Should not happen on upstroke, but as a safeguard\n                spike_times.append(current_t + dt)\n\n            # Apply reset rule for the state at the beginning of the next step.\n            # This is the standard way to handle resets in fixed-step methods.\n            v = c\n            u = u_next + d\n        else:\n            # No spike, so the state for the next step is the Euler-updated state\n            v = v_next\n            u = u_next\n            \n    # Calculate adaptation ratio after the simulation is complete\n    # At least 6 spikes are needed to compute 5 ISIs.\n    if len(spike_times) < 6:\n        return np.nan\n        \n    isis = np.diff(spike_times)\n    \n    # The length of isis is len(spike_times) - 1. We need at least 5 ISIs.\n    if len(isis) < 5:\n        return np.nan\n        \n    adaptation_ratio = isis[0] / isis[4]\n    \n    return adaptation_ratio\n\ndef solve():\n    \"\"\"\n    Runs the Izhikevich neuron simulation for all test cases and prints the result.\n    \"\"\"\n    # Define the regular spiking (RS) parameters\n    # (a, b, c, d)\n    rs_params = (0.02, 0.2, -65.0, 8.0)\n    \n    # Define the test cases from the problem statement\n    # Each case is a tuple: (*rs_params, I, T, dt)\n    test_cases = [\n        # Case A: happy path\n        (*rs_params, 14.0, 1000.0, 0.1),\n        # Case B: low-current boundary\n        (*rs_params, 5.0, 1000.0, 0.1),\n        # Case C: high-current and smaller step\n        (*rs_params, 30.0, 500.0, 0.05)\n    ]\n\n    results = []\n    for case in test_cases:\n        ratio = simulate_neuron(case)\n        if np.isnan(ratio):\n            results.append(\"nan\")\n        else:\n            # Round the result to 6 decimal places as required\n            results.append(f\"{ratio:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solution\nsolve()\n```"
        },
        {
            "introduction": "How a neuron begins to fire as input current increases is a defining characteristic of its computational function, a property captured by its frequency-current ($f$-$I$) curve. This advanced practice involves numerically determining the rheobase current—the threshold for sustained firing—and characterizing the neuron's Type I excitability. You will verify the theoretical prediction that for this class of neuron, the firing rate near threshold grows with the square root of the excess current, linking your simulation to the deep mathematical concept of a saddle-node on invariant circle (SNIC) bifurcation .",
            "id": "4064849",
            "problem": "You are tasked with numerically investigating Type I excitability in the Izhikevich neuron model and assessing the onset of repetitive firing near rheobase for a saddle-node on invariant circle scenario. Use a two-dimensional dynamical system based on a well-tested point-neuron model with a reset mechanism. The membrane potential $v$ and recovery variable $u$ obey ordinary differential equations with a constant direct-current stimulus $I$:\n$$\n\\frac{dv}{dt} = 0.04\\,v^2 + 5\\,v + 140 - u + I,\\quad \n\\frac{du}{dt} = a\\,(b\\,v - u),\n$$\nwith an after-spike reset rule applied whenever the membrane potential reaches a threshold, taken here as $v \\ge 30$ millivolts:\n$$\n\\text{if } v \\ge 30\\ \\text{then}\\ \\begin{cases}\nv \\leftarrow c,\\\\\nu \\leftarrow u + d.\n\\end{cases}\n$$\nAdopt the Type I excitability parameter set that exhibits a saddle-node on invariant circle onset and an arbitrarily low firing rate at threshold (an integrator-type neuron), specifically $a = 0.02$, $b = -0.1$, $c = -55$, $d = 6$. Use initial conditions $v(0) = -65$ millivolts and $u(0) = b\\,v(0)$, a fixed time step of $\\Delta t = 0.1$ milliseconds (i.e., numerical integration with a first-order explicit scheme), and measure firing rates in Hertz, computed as the number of spikes divided by the observation window length in seconds. The constant stimulus $I$ is in units of $\\mathrm{mV/ms}$ in this model, and all time is in milliseconds; convert to Hertz as $1/\\text{second}$ by dividing the spike count by the observation duration in seconds.\n\nYour program must:\n- Determine the rheobase current $I_{rh}$ numerically via a monotone search (for example, bracket followed by bisection), where sustained repetitive firing (after an initial transient) begins. Define sustained firing as the presence of at least two spikes during an observation window following a warm-up transient.\n- Estimate the exponent $p$ of the relationship between the steady firing rate $f$ and the current offset $(I - I_{rh})$ near the onset, by performing a least-squares linear fit of $\\log f$ against $\\log (I - I_{rh})$ using a small set of currents just above $I_{rh}$. The expected behavior for Type I excitability with a saddle-node on invariant circle is that $p$ is approximately $1/2$.\n- Verify that the firing rate at $I = I_{rh}$ is zero when measured after the warm-up transient.\n- Verify that the firing rate is strictly increasing with $I$ for a set of currents sufficiently above $I_{rh}$.\n\nUnits and computational specifications:\n- Use $\\Delta t = 0.1$ milliseconds.\n- For rheobase detection, simulate for $T = 12000$ milliseconds with a warm-up of $2000$ milliseconds; classify a stimulus $I$ as eliciting sustained firing if there are at least $2$ spikes in the interval $(2000, 12000)$ milliseconds.\n- For frequency measurement, use $T = 20000$ milliseconds with a warm-up of $5000$ milliseconds, and compute the firing rate in Hertz as spikes divided by observation duration in seconds.\n- The spike threshold detection is performed via $v \\ge 30$ millivolts, immediately applying the reset rule.\n\nTest suite:\n- Case 1 (near-onset exponent): Use three offsets above rheobase, specifically $\\Delta I \\in \\{0.05, 0.1, 0.2\\}$, compute the firing rates at $I = I_{rh} + \\Delta I$, and report the fitted exponent $p$ as a float.\n- Case 2 (boundary at onset): Compute the firing rate at $I = I_{rh}$ and report it as a float in Hertz.\n- Case 3 (monotonicity above onset): Use currents $I \\in \\{I_{rh} + 0.2,\\, I_{rh} + 0.4,\\, I_{rh} + 0.8\\}$, compute firing rates, and report whether the sequence is strictly increasing as a boolean.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order [result1,result2,result3], where result1 is the exponent $p$ from Case 1 (float), result2 is the firing rate at $I_{rh}$ from Case 2 (float, in Hertz), and result3 is the monotonicity result from Case 3 (boolean). For example: \"[0.5032,0.0,True]\".",
            "solution": "The problem requires a numerical investigation of Type I neural excitability as described by the Izhikevich neuron model. The central tasks are to determine the rheobase current ($I_{rh}$), analyze the firing rate ($f$) a function of the stimulus current ($I$) near the onset of firing, and verify key properties characteristic of a saddle-node on invariant circle (SNIC) bifurcation.\n\nThe dynamics of the neuron are governed by a two-dimensional system of ordinary differential equations for the membrane potential, $v(t)$, and a recovery variable, $u(t)$:\n$$\n\\frac{dv}{dt} = 0.04v^2 + 5v + 140 - u + I\n$$\n$$\n\\frac{du}{dt} = a(bv - u)\n$$\nWhen the membrane potential reaches a peak, a spike is registered, and the state variables are reset according to the rule:\n$$\n\\text{if } v \\ge v_{thresh} \\quad \\text{then} \\quad \\begin{cases} v \\leftarrow c \\\\ u \\leftarrow u + d \\end{cases}\n$$\nThe parameters specified correspond to a Type I neuron (an integrator with an arbitrarily low firing rate at threshold):\n- $a = 0.02$\n- $b = -0.1$\n- $c = -55 \\, \\text{mV}$\n- $d = 6$\n- Spike threshold $v_{thresh} = 30 \\, \\text{mV}$\n\nThe initial conditions are set to a resting state: $v(0) = -65 \\, \\text{mV}$ and $u(0) = b \\cdot v(0) = (-0.1) \\cdot (-65) = 6.5$.\n\nTo solve the system, we employ a numerical integration scheme. A first-order explicit (Forward Euler) method with a fixed time step of $\\Delta t = 0.1 \\, \\text{ms}$ is specified. The discrete update rules for the state variables $(v_n, u_n)$ at time step $n$ are:\n$$\nv_{n+1} = v_n + \\Delta t \\left( 0.04 v_n^2 + 5 v_n + 140 - u_n + I \\right)\n$$\n$$\nu_{n+1} = u_n + \\Delta t \\cdot a (b v_n - u_n)\n$$\nThe spike detection and reset mechanism is integrated into the simulation loop. At the beginning of each time step, before calculating the derivatives, the membrane potential $v_n$ is checked against the threshold $v_{thresh}$. If $v_n \\ge v_{thresh}$, a spike is recorded at time $t_n = n \\cdot \\Delta t$, and the variables are instantaneously reset: $v_n \\leftarrow c$ and $u_n \\leftarrow u_n + d$. The simulation then proceeds to calculate the next state $(v_{n+1}, u_{n+1})$ using these reset values.\n\nThe solution proceeds in three main stages corresponding to the test cases.\n\n**1. Numerical Determination of the Rheobase Current ($I_{rh}$)**\nThe rheobase, $I_{rh}$, is the minimum input current required to induce sustained repetitive firing. To find it, we perform a numerical bisection search.\n- A search interval $[I_{low}, I_{high}]$ is established. Based on a preliminary stability analysis of the subthreshold fixed points, a safe and robust interval is $[0, 30]$. For $I=0$, the system has a stable resting state, so no sustained firing occurs. For $I=30$, firing is expected.\n- A boolean function, `check_firing(I)`, determines if a given current $I$ produces sustained firing. This function simulates the neuron for $12000 \\, \\text{ms}$ and counts the number of spikes within the observation window $(2000, 12000) \\, \\text{ms}$. If this count is at least $2$, the function returns true.\n- The bisection algorithm repeatedly halves the search interval, converging on the value of $I_{rh}$ that marks the boundary between no sustained firing and sustained firing. The search terminates when the interval width is below a small tolerance (e.g., $10^{-8}$). The upper bound of the final interval is taken as $I_{rh}$.\n\n**2. Case 1: Fitting the Firing Rate Exponent ($p$)**\nType I excitability via a SNIC bifurcation predicts that the firing rate $f$ near rheobase follows a square-root relationship with the excess current:\n$$\nf \\propto (I - I_{rh})^{1/2}\n$$\nThis is a specific instance of the more general form $f = k(I - I_{rh})^p$, where the exponent $p$ is expected to be approximately $0.5$. To verify this, we perform a linear regression on the logarithmic form of the equation:\n$$\n\\log(f) = p \\log(I - I_{rh}) + \\log(k)\n$$\nThis is a linear relationship between $y = \\log(f)$ and $x = \\log(I - I_{rh})$, with slope $p$.\n- We select three currents slightly above rheobase: $I_i = I_{rh} + \\Delta I_i$, with $\\Delta I_i \\in \\{0.05, 0.1, 0.2\\}$.\n- For each $I_i$, we simulate the neuron for $T = 20000 \\, \\text{ms}$ and count the spikes in the observation window $(5000, 20000) \\, \\text{ms}$. The firing rate in Hertz is $f_i = \\text{spike count} / (15.0 \\, \\text{s})$.\n- We then compute the slope $p$ of the best-fit line through the data points $(\\log(\\Delta I_i), \\log(f_i))$ using a standard least-squares method.\n\n**3. Case 2 & 3: Boundary and Monotonicity Analysis**\n- **Case 2 (Boundary at Onset):** The theoretical firing rate at the exact point of bifurcation ($I = I_{rh}$) is zero, as the time to fire (the period of the invariant circle) diverges to infinity. We test this by computing the firing rate for $I = I_{rh}$ using the long simulation window ($T=20000$ ms, warm-up $5000$ ms). We expect any initial transient spikes to cease, resulting in a measured steady-state firing rate of $0.0 \\, \\text{Hz}$.\n\n- **Case 3 (Monotonicity Above Onset):** The firing rate of a neuron should be a monotonically increasing function of the input current, provided the system is not in a complex or chaotic regime. We verify this property for our model in the near-threshold region by computing the firing rates for a sequence of increasing currents: $I \\in \\{I_{rh} + 0.2, I_{rh} + 0.4, I_{rh} + 0.8\\}$. We check if the resulting rates, $f_1, f_2, f_3$, satisfy the condition $f_1 < f_2 < f_3$.\n\nA Python script is designed to execute this entire protocol, providing the three required results in the specified format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Numerically investigates Type I excitability in the Izhikevich neuron model.\n    \"\"\"\n    # Model parameters for Type I excitability (integrator)\n    a = 0.02\n    b = -0.1\n    c = -55.0  # mV\n    d = 6.0\n    v_thresh = 30.0  # mV\n\n    # Numerical integration parameters\n    dt = 0.1  # ms\n\n    # Initial conditions\n    v0 = -65.0  # mV\n    u0 = b * v0\n\n    memo_simulation = {}\n\n    def run_simulation(I, T_total_ms):\n        \"\"\"\n        Simulates the Izhikevich neuron for a given current and duration.\n        Caches results to avoid re-computation.\n        \"\"\"\n        sim_key = (I, T_total_ms)\n        if sim_key in memo_simulation:\n            return memo_simulation[sim_key]\n\n        v = v0\n        u = u0\n        \n        num_steps = int(T_total_ms / dt)\n        spike_times = []\n\n        for i in range(num_steps):\n            t = i * dt\n\n            if v >= v_thresh:\n                spike_times.append(t)\n                v = c\n                u = u + d\n\n            dv_dt = 0.04 * v**2 + 5 * v + 140 - u + I\n            du_dt = a * (b * v - u)\n            \n            v += dt * dv_dt\n            u += dt * du_dt\n        \n        # Final check in case the last step crossed the threshold\n        if v >= v_thresh:\n            spike_times.append(T_total_ms)\n\n        result = np.array(spike_times)\n        memo_simulation[sim_key] = result\n        return result\n\n    def check_sustained_firing(I):\n        \"\"\"\n        Checks for sustained firing (>= 2 spikes) for rheobase search.\n        \"\"\"\n        T_sim = 12000  # ms\n        warmup = 2000  # ms\n        min_spikes = 2\n        \n        spike_times = run_simulation(I, T_sim)\n        spikes_in_window = np.sum((spike_times > warmup) & (spike_times <= T_sim))\n        \n        return spikes_in_window >= min_spikes\n\n    def find_rheobase():\n        \"\"\"\n        Finds the rheobase current using bisection search.\n        \"\"\"\n        low_I = 0.0\n        high_I = 30.0\n        tolerance = 1e-8\n\n        # Verify bracket\n        if check_sustained_firing(low_I):\n             raise ValueError(\"Lower bound of rheobase search already fires.\")\n        if not check_sustained_firing(high_I):\n             raise ValueError(\"Upper bound of rheobase search does not fire.\")\n\n        while (high_I - low_I) > tolerance:\n            mid_I = (low_I + high_I) / 2\n            if check_sustained_firing(mid_I):\n                high_I = mid_I\n            else:\n                low_I = mid_I\n        \n        return high_I\n\n    def calculate_firing_rate(I):\n        \"\"\"\n        Calculates the steady-state firing rate in Hz.\n        \"\"\"\n        T_sim = 20000  # ms\n        warmup = 5000  # ms\n        observation_duration_s = (T_sim - warmup) / 1000.0\n        \n        spike_times = run_simulation(I, T_sim)\n        spikes_in_window = np.sum((spike_times > warmup) & (spike_times <= T_sim))\n        \n        if observation_duration_s > 0:\n            return spikes_in_window / observation_duration_s\n        return 0.0\n\n    # Main logic\n    \n    # 1. Determine rheobase\n    I_rh = find_rheobase()\n\n    # 2. Case 1: Calculate exponent p\n    delta_Is = np.array([0.05, 0.1, 0.2])\n    currents_case1 = I_rh + delta_Is\n    rates_case1 = np.array([calculate_firing_rate(I) for I in currents_case1])\n    \n    # Check for non-positive rates before taking log\n    if np.any(rates_case1 <= 0):\n        # This case should not happen with the chosen delta_Is\n        # but as a safeguard:\n        result1 = np.nan\n    else:\n        log_delta_Is = np.log(delta_Is)\n        log_rates = np.log(rates_case1)\n        # Fit a line: log(rates) = p * log(delta_Is) + const\n        p_exponent = np.polyfit(log_delta_Is, log_rates, 1)[0]\n        result1 = p_exponent\n\n    # 3. Case 2: Firing rate at rheobase\n    rate_at_rh = calculate_firing_rate(I_rh)\n    result2 = rate_at_rh\n\n    # 4. Case 3: Monotonicity check\n    currents_case3 = I_rh + np.array([0.2, 0.4, 0.8])\n    rates_case3 = np.array([calculate_firing_rate(I) for I in currents_case3])\n    is_monotonic = (rates_case3[0] < rates_case3[1]) and (rates_case3[1] < rates_case3[2])\n    result3 = bool(is_monotonic)  # Ensure it's a standard Python boolean\n\n    # Final output\n    print(f\"[{result1},{result2},{result3}]\")\n\nsolve()\n```"
        }
    ]
}