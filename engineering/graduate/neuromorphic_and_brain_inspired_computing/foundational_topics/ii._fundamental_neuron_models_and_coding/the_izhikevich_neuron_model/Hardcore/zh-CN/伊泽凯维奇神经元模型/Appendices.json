{
    "hands_on_practices": [
        {
            "introduction": "在神经元放电之前，它通常处于一个稳定的静息电位。本练习将指导您使用动力系统的工具对这个静息态进行数学分析，具体方法是找到模型的不动点并通过线性化来确定其稳定性 。这是理解任何神经元模型行为的基础技能，它揭示了在没有脉冲的情况下系统的内在属性。",
            "id": "4029541",
            "problem": "考虑 Izhikevich 神经元模型，该模型通过以下耦合常微分方程 (ODE) 描述膜电压和恢复变量的动力学\n$$\n\\frac{dv}{dt} = 0.04\\,v^{2} + 5\\,v + 140 - u + I, \\qquad \\frac{du}{dt} = a\\,(b\\,v - u),\n$$\n并带有通常的尖峰重置机制（在不动点处不激活）。使用以下参数值，这些值是典型的规则放电皮层锥体神经元的参数：$a = 0.02$，$b = 0.2$，以及恒定的外部输入 $I = 3$。不动点定义为电压零斜线和恢复零斜线的交点，分别由 $dv/dt = 0$ 和 $du/dt = 0$ 给出。在这些不动点中，关注电压较低的交点（即更超极化的那个）。\n\n从不动点、零斜线、动力学系统的雅可比矩阵和线性稳定性（特征值的实部）的基本定义出发，执行以下操作：\n\n- 确定作为零斜线交点的不动点 $(v^{\\ast}, u^{\\ast})$。\n- 计算在 $(v^{\\ast}, u^{\\ast})$ 处的雅可比矩阵，并推导其特征值以评估局部线性稳定性。\n- 将在 $(v^{\\ast}, u^{\\ast})$ 处的特征值的最大实部以单个解析闭式表达式的形式报告。使用模型的原生时间单位，并以毫秒的倒数表示该值。不要对最终表达式进行四舍五入。",
            "solution": "该问题要求对 Izhikevich 神经元模型的一个不动点进行分析。该过程包括识别不动点，通过计算雅可比矩阵将系统动力学在该点附近线性化，然后通过计算雅可比矩阵的特征值来确定局部稳定性。最终要求的量是这些特征值实部的最大值。\n\n该动力学系统由以下耦合常微分方程描述：\n$$\n\\frac{dv}{dt} = 0.04\\,v^{2} + 5\\,v + 140 - u + I\n$$\n$$\n\\frac{du}{dt} = a\\,(b\\,v - u)\n$$\n提供的参数为 $a = 0.02$，$b = 0.2$，外部输入电流为 $I = 3$。变量和参数的单位使得时间 $t$ 以毫秒（$ms$）为单位，电压 $v$ 以毫伏（$mV$）为单位。\n\n首先，我们通过将时间导数设为零来找到系统的不动点 $(v^{\\ast}, u^{\\ast})$。\n零斜线由以下方程给出：\n1.  电压零斜线 ($\\frac{dv}{dt} = 0$): $0.04\\,v^{2} + 5\\,v + 140 - u + I = 0$\n2.  恢复零斜线 ($\\frac{du}{dt} = 0$): $a\\,(b\\,v - u) = 0$\n\n从恢复零斜线可知，由于 $a = 0.02 \\ne 0$，我们必须有 $b\\,v - u = 0$。这给出了不动点处 $u$ 和 $v$ 之间的线性关系：\n$$\nu = b\\,v\n$$\n我们将这个 $u$ 的表达式代入电压零斜线方程：\n$$\n0.04\\,v^{2} + 5\\,v + 140 - (b\\,v) + I = 0\n$$\n$$\n0.04\\,v^{2} + (5 - b)v + (140 + I) = 0\n$$\n现在，我们代入给定的参数值 $b = 0.2$ 和 $I = 3$：\n$$\n0.04\\,v^{2} + (5 - 0.2)v + (140 + 3) = 0\n$$\n$$\n0.04\\,v^{2} + 4.8\\,v + 143 = 0\n$$\n这是一个关于不动点处电压 $v$ 的二次方程。我们使用二次方程求根公式 $v = \\frac{-B \\pm \\sqrt{B^2 - 4AC}}{2A}$ 来解 $v$，其中 $A=0.04$，$B=4.8$，$C=143$：\n$$\nv = \\frac{-4.8 \\pm \\sqrt{(4.8)^{2} - 4(0.04)(143)}}{2(0.04)}\n$$\n$$\nv = \\frac{-4.8 \\pm \\sqrt{23.04 - 22.88}}{0.08}\n$$\n$$\nv = \\frac{-4.8 \\pm \\sqrt{0.16}}{0.08}\n$$\n$$\nv = \\frac{-4.8 \\pm 0.4}{0.08}\n$$\n这得到了 $v$ 的两个可能值：\n$$\nv_{1} = \\frac{-4.8 + 0.4}{0.08} = \\frac{-4.4}{0.08} = -55\n$$\n$$\nv_{2} = \\frac{-4.8 - 0.4}{0.08} = \\frac{-5.2}{0.08} = -65\n$$\n问题要求使用“电压较低的交点（即更超极化的那个）”，这对应于更负的值。因此，我们选择 $v^{\\ast} = -65$。\n\n现在，我们使用关系式 $u = b\\,v$ 来找到恢复变量 $u^{\\ast}$ 的对应值：\n$$\nu^{\\ast} = b\\,v^{\\ast} = 0.2 \\times (-65) = -13\n$$\n相关的不动点是 $(v^{\\ast}, u^{\\ast}) = (-65, -13)$。\n\n接下来，我们计算系统的雅可比矩阵以分析其稳定性。该系统可以写成 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{F}(\\mathbf{x})$，其中 $\\mathbf{x} = [v, u]^T$ 且 $\\mathbf{F}(\\mathbf{x}) = [f(v,u), g(v,u)]^T$，具体为：\n$$\nf(v, u) = 0.04\\,v^{2} + 5\\,v + 140 - u + I\n$$\n$$\ng(v, u) = a\\,(b\\,v - u) = ab\\,v - au\n$$\n雅可比矩阵 $J$ 由以下公式给出：\n$$\nJ = \\begin{pmatrix} \\frac{\\partial f}{\\partial v} & \\frac{\\partial f}{\\partial u} \\\\ \\frac{\\partial g}{\\partial v} & \\frac{\\partial g}{\\partial u} \\end{pmatrix} = \\begin{pmatrix} 0.08\\,v + 5 & -1 \\\\ ab & -a \\end{pmatrix}\n$$\n我们在不动点 $(v^{\\ast}, u^{\\ast}) = (-65, -13)$ 处评估该矩阵，并代入参数值 $a = 0.02$ 和 $b = 0.2$：\n$$\nJ^{\\ast} = J(-65, -13) = \\begin{pmatrix} 0.08(-65) + 5 & -1 \\\\ (0.02)(0.2) & -0.02 \\end{pmatrix}\n$$\n$$\nJ^{\\ast} = \\begin{pmatrix} -5.2 + 5 & -1 \\\\ 0.004 & -0.02 \\end{pmatrix} = \\begin{pmatrix} -0.2 & -1 \\\\ 0.004 & -0.02 \\end{pmatrix}\n$$\n雅可比矩阵 $J^{\\ast}$ 的特征值 $\\lambda$ 决定了局部稳定性。它们是特征方程 $\\det(J^{\\ast} - \\lambda I) = 0$ 的根，其中 $I$ 是单位矩阵。对于一个 $2 \\times 2$ 矩阵，特征方程为 $\\lambda^{2} - \\text{Tr}(J^{\\ast})\\lambda + \\det(J^{\\ast}) = 0$。\n\n$J^{\\ast}$ 的迹是：\n$$\n\\text{Tr}(J^{\\ast}) = -0.2 + (-0.02) = -0.22\n$$\n$J^{\\ast}$ 的行列式是：\n$$\n\\det(J^{\\ast}) = (-0.2)(-0.02) - (-1)(0.004) = 0.004 + 0.004 = 0.008\n$$\n因此，特征方程是：\n$$\n\\lambda^{2} - (-0.22)\\lambda + 0.008 = 0\n$$\n$$\n\\lambda^{2} + 0.22\\lambda + 0.008 = 0\n$$\n我们使用二次方程求根公式来解特征值 $\\lambda$：\n$$\n\\lambda = \\frac{-0.22 \\pm \\sqrt{(0.22)^{2} - 4(1)(0.008)}}{2(1)}\n$$\n$$\n\\lambda = \\frac{-0.22 \\pm \\sqrt{0.0484 - 0.032}}{2}\n$$\n$$\n\\lambda = \\frac{-0.22 \\pm \\sqrt{0.0164}}{2}\n$$\n判别式 $0.0164$ 是正数，所以两个特征值都是实数。特征值的实部就是特征值本身。这两个特征值是：\n$$\n\\lambda_{1} = \\frac{-0.22 + \\sqrt{0.0164}}{2} \\quad \\text{和} \\quad \\lambda_{2} = \\frac{-0.22 - \\sqrt{0.0164}}{2}\n$$\n问题要求的是特征值的最大实部。这显然是 $\\lambda_{1}$。为了提供一个解析闭式表达式，我们简化平方根下的项：\n$$\n\\sqrt{0.0164} = \\sqrt{\\frac{164}{10000}} = \\frac{\\sqrt{4 \\times 41}}{100} = \\frac{2\\sqrt{41}}{100} = \\frac{\\sqrt{41}}{50}\n$$\n将此结果代回 $\\lambda_1$ 的表达式中：\n$$\n\\lambda_{\\max} = \\frac{1}{2}\\left(-0.22 + \\frac{\\sqrt{41}}{50}\\right) = \\frac{1}{2}\\left(-\\frac{22}{100} + \\frac{2\\sqrt{41}}{100}\\right) = \\frac{1}{2}\\left(\\frac{-22 + 2\\sqrt{41}}{100}\\right) = \\frac{-11 + \\sqrt{41}}{100}\n$$\n$\\sqrt{41}$ 的值约等于 $6.4$，所以 $-11 + \\sqrt{41}$ 是负数。这证实了该不动点是一个稳定节点，这与神经元模型的静息态的预期相符。特征值的最大实部是 $\\frac{-11 + \\sqrt{41}}{100}$。模型的时间单位是毫秒（$ms$），所以特征值的单位是 $ms^{-1}$。",
            "answer": "$$\\boxed{\\frac{-11 + \\sqrt{41}}{100}}$$"
        },
        {
            "introduction": "在分析了静态的静息态之后，下一步是模拟神经元在接收输入并开始放电时的动态行为。本练习涉及编写一个程序来模拟完整的Izhikevich模型，检测脉冲，并量化一个关键的神经生理学现象：脉冲频率适应 。通过这个练习，您将掌握将理论模型转化为可执行代码，并从中提取有意义的生理指标的核心技能。",
            "id": "4064812",
            "problem": "设计并实现一个程序，模拟处于规则发放（RS）模式下的 Izhikevich 脉冲神经元，并计算脉冲间期（ISIs）和适应性比率。请使用以下定义，它们是 Izhikevich 模型的基础。膜电位由 $v$（单位为 $\\mathrm{mV}$）表示，恢复变量由 $u$ 表示，外部施加的电流由 $I$（单位为与模型一致的电流单位，可使 $v$ 以 $\\mathrm{mV}$ 为单位，时间以 $\\mathrm{ms}$ 为单位）表示。Izhikevich 模型由以下常微分方程组（ODEs）控制：\n$$\n\\frac{dv}{dt} = 0.04v^2 + 5v + 140 - u + I, \\quad \\frac{du}{dt} = a(bv - u),\n$$\n当膜电位达到脉冲阈值时，应用脉冲后重置条件：\n$$\n\\text{如果 } v \\ge 30 \\text{ （单位 } \\mathrm{mV}\\text{）}, \\text{ 则设置 } v \\leftarrow c \\text{ 且 } u \\leftarrow u + d.\n$$\n假设初始条件为 $v(0)=c$ 和 $u(0)=bv(0)$。使用固定步长的显式欧拉方法进行模拟，时间步长为 $\\Delta t$（单位为 $\\mathrm{ms}$），并通过在每个时间步内进行线性插值来实现脉冲事件检测：如果 $v$ 在一个步长内从下向上穿过脉冲阈值，则通过在步长前后的 $v$ 值之间进行线性插值来估计脉冲时间 $t_{\\text{spike}}$（单位为 $\\mathrm{ms}$）。使用每个步长内的首次穿越，并立即在该步长应用重置规则。\n\n将脉冲间期（ISIs）定义为连续脉冲时间之差，单位为毫秒。适应性比率定义为 $\\text{ISI}_1/\\text{ISI}_5$ 之比，其中 $\\text{ISI}_k$ 表示第 $k$ 个 ISI（按出现顺序）。如果在模拟窗口内发生的脉冲少于 6 个，则将适应性比率定义为 $\\mathrm{nan}$（非数字）。\n\n所有时间必须以 $\\mathrm{ms}$ 表示，电压以 $\\mathrm{mV}$ 表示，适应性比率为无量纲。您的程序必须计算以下测试套件的结果，并生成单行输出，其中包含每个测试用例的适应性比率，形式为用方括号括起来的逗号分隔列表，例如 $[\\text{ratio}_1,\\text{ratio}_2,\\text{ratio}_3]$。将每个比率四舍五入到小数点后 $6$ 位。如果比率未定义，则在其位置输出 $\\mathrm{nan}$。\n\n测试套件（所有用例均使用 RS 参数）：\n- 规则发放（RS）参数：$(a,b,c,d) = (0.02,0.2,-65,8)$。\n- 脉冲阈值：$30 \\,\\mathrm{mV}$。\n\n用例：\n- 用例 A（正常情况）：恒定电流 $I=14$，总模拟时间 $T=1000 \\,\\mathrm{ms}$，时间步长 $\\Delta t = 0.1 \\,\\mathrm{ms}$。\n- 用例 B（低电流边界）：恒定电流 $I=5$，总模拟时间 $T=1000 \\,\\mathrm{ms}$，时间步长 $\\Delta t = 0.1 \\,\\mathrm{ms}$。\n- 用例 C（高电流与更小步长）：恒定电流 $I=30$，总模拟时间 $T=500 \\,\\mathrm{ms}$，时间步长 $\\Delta t = 0.05 \\,\\mathrm{ms}$。\n\n对于每个用例，计算前五个脉冲间期（单位为 ms），然后计算适应性比率 $\\text{ISI}_1/\\text{ISI}_5$。要求的最终输出格式为单行：\n$[\\text{ratio}_A,\\text{ratio}_B,\\text{ratio}_C]$\n其中每个数值都四舍五入到小数点后 6 位，并且在窗口内脉冲发生次数少于 6 次的地方使用 $\\mathrm{nan}$。不应打印其他任何文本。",
            "solution": "用户希望模拟 Izhikevich 神经元模型，特别是规则发放（RS）模式，并从产生的脉冲序列中计算脉冲适应性比率。\n\n### 步骤 1：问题验证\n\n首先，我将根据指定标准验证问题陈述。\n\n#### 已知条件提取\n\n- **模型方程**：\n    $$\n    \\frac{dv}{dt} = 0.04v^2 + 5v + 140 - u + I\n    $$\n    $$\n    \\frac{du}{dt} = a(bv - u)\n    $$\n- **状态变量**：$v$（膜电位，$\\mathrm{mV}$），$u$（恢复变量）。\n- **输入电流**：$I$。\n- **脉冲重置条件**：如果 $v \\ge 30 \\, \\mathrm{mV}$，则 $v \\leftarrow c$ 且 $u \\leftarrow u + d$。\n- **初始条件**：$v(0)=c$，$u(0)=bv(0)$。\n- **模拟方法**：固定步长的显式欧拉方法，时间步长为 $\\Delta t$。\n- **脉冲检测**：当 $v$ 在一个时间步内从下向上穿过 $30 \\, \\mathrm{mV}$ 的阈值时，使用线性插值计算脉冲时间 $t_{\\text{spike}}$。重置将在“该步长”应用。\n- **定义**：\n    - 脉冲间期 (ISI)：连续脉冲之间的时间差。\n    - 适应性比率：$\\text{ISI}_1/\\text{ISI}_5$。如果发生的脉冲少于 6 个，则值为 $\\mathrm{nan}$。\n- **参数**：\n    - 规则发放 (RS)：$(a,b,c,d) = (0.02, 0.2, -65, 8)$。\n    - 脉冲阈值：$30 \\, \\mathrm{mV}$。\n- **测试用例**：\n    - 用例 A：$I=14$, $T=1000 \\, \\mathrm{ms}$, $\\Delta t = 0.1 \\, \\mathrm{ms}$。\n    - 用例 B：$I=5$, $T=1000 \\, \\mathrm{ms}$, $\\Delta t = 0.1 \\, \\mathrm{ms}$。\n    - 用例 C：$I=30$, $T=500 \\, \\mathrm{ms}$, $\\Delta t = 0.05 \\, \\mathrm{ms}$。\n- **输出格式**：单行 `[ratio_A,ratio_B,ratio_C]`，比率四舍五入到小数点后 6 位，并在适当位置包含 `nan`。\n\n#### 验证分析\n\n1.  **科学依据**：该问题基于 Izhikevich 神经元模型，这是计算神经科学的基石之一，发表于 2003 年一篇高被引论文。其参数和行为（规则发放）是标准且有据可查的。该问题在科学上是合理的。\n2.  **适定性**：该问题提供了一整套微分方程、初始条件、参数和指定的数值方法（显式欧拉法）。这确保了可以计算出唯一的数值解。所需的输出基于模拟结果有明确的定义。\n3.  **客观性**：该问题使用精确的数学和计算语言陈述。所有参数和条件都以客观数值给出。\n4.  **完整性和一致性**：提供了所有必要信息。变量、参数和单位（$\\mathrm{mV}$，$\\mathrm{ms}$）在整个问题描述中保持一致。\n5.  **无其他缺陷**：该问题不属于琐碎、隐喻性或超出科学可验证范围的问题。它是科学领域中的一个标准数值模拟任务。\n\n#### 结论\n\n该问题是**有效的**。它是计算神经科学中一个定义明确的任务，要求实现一种标准的数值方法来模拟一个著名的模型。\n\n### 步骤 2：解法设计与实现\n\n解决方案涉及使用显式欧拉方法对给定的两个常微分方程（ODEs）系统进行数值积分，同时处理指定的脉冲和重置条件。\n\n#### 数值方法：显式欧拉法\n\n显式欧拉法基于系统在时间 $t$ 的状态及其变化率来近似计算时间 $t + \\Delta t$ 的状态。对于我们的系统 $(v, u)$，单个时间步长 $\\Delta t$ 的更新规则是：\n$$\nv_{n+1} = v_n + \\Delta t \\cdot \\left( \\frac{dv}{dt} \\right)\\bigg|_{t_n} = v_n + \\Delta t \\cdot (0.04v_n^2 + 5v_n + 140 - u_n + I)\n$$\n$$\nu_{n+1} = u_n + \\Delta t \\cdot \\left( \\frac{du}{dt} \\right)\\bigg|_{t_n} = u_n + \\Delta t \\cdot a(bv_n - u_n)\n$$\n这里，$(v_n, u_n)$ 表示步长开始时的状态（时间 $t_n$），而 $(v_{n+1}, u_{n+1})$ 是步长结束时的暂定状态（时间 $t_{n+1} = t_n + \\Delta t$）。\n\n#### 模拟算法\n\n对于每个测试用例，模拟过程如下：\n1.  **初始化**：\n    - 为特定用例设置参数 $(a,b,c,d,I,T,\\Delta t)$。\n    - 在时间 $t=0$ 初始化状态变量：$v \\leftarrow c$ 和 $u \\leftarrow b \\cdot c$。\n    - 初始化一个空列表 `spike_times`，用于存储脉冲发生的时间。\n\n2.  **时间步进循环**：模拟在总时间 $T$ 内迭代，固定时间步长为 $\\Delta t$。在每一步中，从当前时间 $t$ 和状态 $(v, u)$ 开始：\n    - 将当前电压存储为 $v_{\\text{old}} \\leftarrow v$。\n    - 使用上述显式欧拉公式计算时间 $t+\\Delta t$ 的暂定下一个状态 $(v_{\\text{next}}, u_{\\text{next}})$。\n    - **脉冲检测**：检查膜电位是否从下向上穿过了脉冲阈值 $v_{\\text{thresh}} = 30 \\, \\mathrm{mV}$。该条件为 $v_{\\text{old}}  v_{\\text{thresh}}$ 且 $v_{\\text{next}} \\ge v_{\\text{thresh}}$。\n    - **状态更新**：\n        - **如果检测到脉冲**：\n            1.  精确的脉冲时间 $t_{\\text{spike}}$ 是通过在点 $(t, v_{\\text{old}})$ 和 $(t+\\Delta t, v_{\\text{next}})$ 之间进行线性插值来估计的：\n                $$\n                t_{\\text{spike}} = t + \\Delta t \\frac{v_{\\text{thresh}} - v_{\\text{old}}}{v_{\\text{next}} - v_{\\text{old}}}\n                $$\n            2.  将此 $t_{\\text{spike}}$ 追加到 `spike_times` 列表中。\n            3.  应用脉冲后重置规则来确定下一个时间步的状态。问题指定了固定步长方法和在“该步长”立即重置。这被解释为时间 $t+\\Delta t$ 的状态成为重置状态。电压被重置为 $c$，恢复变量 $u$ 增加 $d$。要增加的 $u$ 值是在步长结束时计算出的 $u_{\\text{next}}$，因为它反映了在动作电位上升阶段恢复过程的累积。因此，对于下一步，我们设置：\n                $$\n                v \\leftarrow c\n                $$\n                $$\n                u \\leftarrow u_{\\text{next}} + d\n                $$\n        - **如果未检测到脉冲**：下一步的状态就是欧拉近似的状态：\n            $$\n            v \\leftarrow v_{\\text{next}}\n            $$\n            $$\n            u \\leftarrow u_{\\text{next}}\n            $$\n\n3.  **模拟后分析**：\n    - 模拟循环完成后，检查记录的脉冲数量。\n    - 如果记录的脉冲少于 6 个，则无法计算五个 ISI。在这种情况下，适应性比率定义为非数字（$\\mathrm{nan}$）。\n    - 如果记录到 6 个或更多脉冲，则脉冲间期（ISIs）计算为连续脉冲时间之差：$\\text{ISI}_k = t_{\\text{spike}, k+1} - t_{\\text{spike}, k}$。\n    - 然后将适应性比率计算为第一个 ISI 与第五个 ISI 之比：\n        $$\n        \\text{Ratio} = \\frac{\\text{ISI}_1}{\\text{ISI}_5}\n        $$\n\n4.  **最终输出**：计算出的比率四舍五入到小数点后 6 位。收集所有测试用例的结果，并将其格式化为所需的字符串 `[ratio_A,ratio_B,ratio_C]`。\n\n整个过程被封装在一个 Python 脚本中。函数 `simulate_neuron` 实现单个测试用例的模拟和分析，而 `solve` 函数则遍历给定的测试套件，调用模拟函数并打印最终格式化的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_neuron(params):\n    \"\"\"\n    Simulates the Izhikevich neuron model for a given set of parameters.\n\n    Args:\n        params (tuple): A tuple containing (a, b, c, d, I, T, dt).\n\n    Returns:\n        float: The computed adaptation ratio, or np.nan if undefined.\n    \"\"\"\n    # Unpack parameters\n    a, b, c, d, I, T, dt = params\n    v_thresh = 30.0\n\n    # Initial conditions\n    v = c\n    u = b * c\n    \n    spike_times = []\n    \n    # Use a precise number of steps to avoid floating point issues with the loop range\n    num_steps = int(round(T / dt))\n\n    for i in range(num_steps):\n        current_t = i * dt\n        v_old = v\n        \n        # Explicit Euler step: calculate derivatives at the current state (v, u)\n        dv_dt = 0.04 * v**2 + 5 * v + 140 - u + I\n        du_dt = a * (b * v - u)\n        \n        # Calculate tentative state for the next time step\n        v_next = v + dv_dt * dt\n        u_next = u + du_dt * dt\n        \n        # Spike detection: check for threshold crossing from below\n        if v_old  v_thresh and v_next = v_thresh:\n            # Estimate spike time using linear interpolation\n            if v_next - v_old  0: # Avoid division by zero\n                t_spike = current_t + dt * (v_thresh - v_old) / (v_next - v_old)\n                spike_times.append(t_spike)\n            else: # Should not happen on upstroke, but as a safeguard\n                spike_times.append(current_t + dt)\n\n            # Apply reset rule for the state at the beginning of the next step.\n            # This is the standard way to handle resets in fixed-step methods.\n            v = c\n            u = u_next + d\n        else:\n            # No spike, so the state for the next step is the Euler-updated state\n            v = v_next\n            u = u_next\n            \n    # Calculate adaptation ratio after the simulation is complete\n    # At least 6 spikes are needed to compute 5 ISIs.\n    if len(spike_times)  6:\n        return np.nan\n        \n    isis = np.diff(spike_times)\n    \n    # The length of isis is len(spike_times) - 1. We need at least 5 ISIs.\n    if len(isis)  5:\n        return np.nan\n        \n    adaptation_ratio = isis[0] / isis[4]\n    \n    return adaptation_ratio\n\ndef solve():\n    \"\"\"\n    Runs the Izhikevich neuron simulation for all test cases and prints the result.\n    \"\"\"\n    # Define the regular spiking (RS) parameters\n    # (a, b, c, d)\n    rs_params = (0.02, 0.2, -65.0, 8.0)\n    \n    # Define the test cases from the problem statement\n    # Each case is a tuple: (*rs_params, I, T, dt)\n    test_cases = [\n        # Case A: happy path\n        (*rs_params, 14.0, 1000.0, 0.1),\n        # Case B: low-current boundary\n        (*rs_params, 5.0, 1000.0, 0.1),\n        # Case C: high-current and smaller step\n        (*rs_params, 30.0, 500.0, 0.05)\n    ]\n\n    results = []\n    for case in test_cases:\n        ratio = simulate_neuron(case)\n        if np.isnan(ratio):\n            results.append(\"nan\")\n        else:\n            # Round the result to 6 decimal places as required\n            results.append(f\"{ratio:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solution\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本模拟技能的基础上，这个高级练习将深入探讨神经元的放电率如何随输入电流变化（即$f-I$曲线）。本练习将侧重于I型兴奋性，在这种兴奋性下，神经元可以以任意低的频率放电，并涉及数值验证在放电阈值附近放电率与输入电流之间的理论平方根关系，这是鞍结不变圆（SNIC）分岔的一个标志 。",
            "id": "4064849",
            "problem": "您的任务是数值研究 Izhikevich 神经元模型中的 I 型兴奋性，并评估在不变圆上的鞍-结情形下，基底电流附近的重复放电起始。使用一个基于经过充分检验的点神经元模型的二维动力学系统，该系统包含一个重置机制。膜电位 $v$ 和恢复变量 $u$ 遵循带有恒定直流刺激 $I$ 的常微分方程：\n$$\n\\frac{dv}{dt} = 0.04\\,v^2 + 5\\,v + 140 - u + I,\\quad \n\\frac{du}{dt} = a\\,(b\\,v - u),\n$$\n每当膜电位达到阈值（此处设为 $v \\ge 30$ 毫伏）时，应用峰电位后重置规则：\n$$\n\\text{if } v \\ge 30\\ \\text{then}\\ \\begin{cases}\nv \\leftarrow c,\\\\\nu \\leftarrow u + d.\n\\end{cases}\n$$\n采用 I 型兴奋性参数集，该参数集表现出不变圆上的鞍-结起始特性，并在阈值处具有任意低的放电率（一种积分器型神经元），具体为 $a = 0.02$, $b = -0.1$, $c = -55$, $d = 6$。使用初始条件 $v(0) = -65$ 毫伏和 $u(0) = b\\,v(0)$，固定时间步长 $\\Delta t = 0.1$ 毫秒（即，使用一阶显式格式进行数值积分），并以赫兹为单位测量放电率，其计算方法为峰电位数量除以以秒为单位的观测窗口长度。在此模型中，恒定刺激 $I$ 是无量纲的，所有时间单位均为毫秒；通过将峰电位计数除以以秒为单位的观测时长，将其转换为赫兹（$1/\\text{second}$）。\n\n您的程序必须：\n- 通过单调搜索（例如，先确定区间再使用二分法）数值确定基底电流 $I_{rh}$，即持续重复放电（在初始暂态之后）开始的电流值。将持续放电定义为在预热暂态后的一个观测窗口内，至少出现两个峰电位。\n- 通过对一小组略高于 $I_{rh}$ 的电流值，进行 $\\log f$ 对 $\\log (I - I_{rh})$ 的最小二乘线性拟合，来估算起始点附近稳态放电率 $f$ 与电流偏移 $(I - I_{rh})$ 之间关系的指数 $p$。对于不变圆上鞍-结分岔的 I 型兴奋性，其预期行为是 $p$ 约等于 $1/2$。\n- 验证在预热暂态后测量时，$I = I_{rh}$ 处的放电率为零。\n- 对于一组远高于 $I_{rh}$ 的电流值，验证放电率随 $I$ 严格递增。\n\n单位与计算规格：\n- 使用 $\\Delta t = 0.1$ 毫秒。\n- 为检测基底电流，模拟 $T = 12000$ 毫秒，其中预热时间为 $2000$ 毫秒；如果在 $(2000, 12000)$ 毫秒区间内至少有 2 个峰电位，则将刺激 $I$ 归类为引发持续放电。\n- 为测量频率，使用 $T = 20000$ 毫秒，其中预热时间为 $5000$ 毫秒，并将放电率计算为峰电位数量除以以秒为单位的观测时长（单位为赫兹）。\n- 峰电位阈值检测通过 $v \\ge 30$ 毫伏进行，并立即应用重置规则。\n\n测试套件：\n- 案例 1 (起始点附近指数)：使用三个高于基底电流的偏移量，具体为 $\\Delta I \\in \\{0.05, 0.1, 0.2\\}$，计算在 $I = I_{rh} + \\Delta I$ 时的放电率，并以浮点数形式报告拟合得到的指数 $p$。\n- 案例 2 (起始点边界)：计算在 $I = I_{rh}$ 时的放电率，并以浮点数形式报告（单位为赫兹）。\n- 案例 3 (起始点以上单调性)：使用电流 $I \\in \\{I_{rh} + 0.2,\\, I_{rh} + 0.4,\\, I_{rh} + 0.8\\}$，计算放电率，并以布尔值形式报告该序列是否严格递增。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [result1,result2,result3]，其中 result1 是案例 1 的指数 $p$ (浮点数)，result2 是案例 2 在 $I_{rh}$ 处的放电率 (浮点数，单位为赫兹)，result3 是案例 3 的单调性结果 (布尔值)。例如：\"[0.5032,0.0,True]\"。",
            "solution": "该问题要求对 Izhikevich 神经元模型所描述的 I 型神经兴奋性进行数值研究。核心任务是确定基底电流（$I_{rh}$），分析放电起始点附近的放电率（$f$）作为刺激电流（$I$）的函数，并验证不变圆上鞍-结（SNIC）分岔的关键特性。\n\n神经元的动力学由一个关于膜电位 $v(t)$ 和恢复变量 $u(t)$ 的二维常微分方程组控制：\n$$\n\\frac{dv}{dt} = 0.04v^2 + 5v + 140 - u + I\n$$\n$$\n\\frac{du}{dt} = a(bv - u)\n$$\n当膜电位达到峰值时，记录一个峰电位，并根据以下规则重置状态变量：\n$$\n\\text{if } v \\ge v_{thresh} \\quad \\text{then} \\quad \\begin{cases} v \\leftarrow c \\\\ u \\leftarrow u + d \\end{cases}\n$$\n指定的参数对应于一个 I 型神经元（一个在阈值处具有任意低放电率的积分器）：\n- $a = 0.02$\n- $b = -0.1$\n- $c = -55 \\, \\text{mV}$\n- $d = 6$\n- 峰电位阈值 $v_{thresh} = 30 \\, \\text{mV}$\n\n初始条件设定为静息状态：$v(0) = -65 \\, \\text{mV}$ 和 $u(0) = b \\cdot v(0) = (-0.1) \\cdot (-65) = 6.5$。\n\n为求解该系统，我们采用一种数值积分方案。题目指定了使用固定时间步长 $\\Delta t = 0.1 \\, \\text{ms}$ 的一阶显式（前向欧拉）方法。状态变量 $(v_n, u_n)$ 在时间步 $n$ 的离散更新规则为：\n$$\nv_{n+1} = v_n + \\Delta t \\left( 0.04 v_n^2 + 5 v_n + 140 - u_n + I \\right)\n$$\n$$\nu_{n+1} = u_n + \\Delta t \\cdot a (b v_n - u_n)\n$$\n峰电位检测和重置机制被集成到模拟循环中。在每个时间步开始时，计算导数之前，会检查膜电位 $v_n$ 是否达到阈值 $v_{thresh}$。如果 $v_n \\ge v_{thresh}$，则在时间 $t_n = n \\cdot \\Delta t$ 记录一个峰电位，并且变量被瞬时重置：$v_n \\leftarrow c$ 和 $u_n \\leftarrow u_n + d$。然后，模拟过程使用这些重置后的值来计算下一个状态 $(v_{n+1}, u_{n+1})$。\n\n解题过程分为三个主要阶段，分别对应三个测试案例。\n\n**1. 基底电流 ($I_{rh}$) 的数值确定**\n基底电流 $I_{rh}$ 是引发持续重复放电所需的最小输入电流。为找到它，我们进行数值二分搜索。\n- 建立一个搜索区间 $[I_{low}, I_{high}]$。基于对阈下不动点的初步稳定性分析，一个安全且鲁棒的区间是 $[0, 30]$。当 $I=0$ 时，系统处于一个稳定的静息状态，因此不会发生持续放电。当 $I=30$ 时，预期会发生放电。\n- 一个布尔函数 `check_firing(I)` 用于判断给定的电流 $I$ 是否产生持续放电。该函数模拟神经元 $12000 \\, \\text{ms}$，并统计观测窗口 $(2000, 12000) \\, \\text{ms}$ 内的峰电位数量。如果数量至少为 2，函数返回真。\n- 二分算法重复地将搜索区间减半，收敛到标记着无持续放电与持续放电之间边界的 $I_{rh}$ 值。当区间宽度小于一个很小的容差（例如 $10^{-8}$）时，搜索终止。最终区间的上界被取为 $I_{rh}$。\n\n**2. 案例 1：拟合放电率指数 ($p$)**\n通过 SNIC 分岔实现的 I 型兴奋性预测，基底电流附近的放电率 $f$ 与超额电流遵循平方根关系：\n$$\nf \\propto (I - I_{rh})^{1/2}\n$$\n这是更普遍形式 $f = k(I - I_{rh})^p$ 的一个特定实例，其中指数 $p$ 预期约等于 $0.5$。为验证这一点，我们对该方程的对数形式进行线性回归：\n$$\n\\log(f) = p \\log(I - I_{rh}) + \\log(k)\n$$\n这是 $y = \\log(f)$ 和 $x = \\log(I - I_{rh})$ 之间的线性关系，其斜率为 $p$。\n- 我们选择三个略高于基底电流的电流值：$I_i = I_{rh} + \\Delta I_i$，其中 $\\Delta I_i \\in \\{0.05, 0.1, 0.2\\}$。\n- 对于每个 $I_i$，我们模拟神经元 $T = 20000 \\, \\text{ms}$，并统计观测窗口 $(5000, 20000) \\, \\text{ms}$ 内的峰电位。以赫兹为单位的放电率为 $f_i = \\text{峰电位数量} / (15.0 \\, \\text{s})$。\n- 然后我们使用标准最小二乘法，计算通过数据点 $(\\log(\\Delta I_i), \\log(f_i))$ 的最佳拟合线的斜率 $p$。\n\n**3. 案例 2 和 3：边界与单调性分析**\n- **案例 2 (起始点边界)：** 在分岔的确切点 ($I = I_{rh}$)，理论放电率为零，因为放电所需时间（不变圆的周期）会发散至无穷大。我们通过使用长模拟窗口（$T=20000$ 毫秒，预热 $5000$ 毫秒）计算 $I = I_{rh}$ 时的放电率来检验这一点。我们预期任何初始的暂态峰电位都会停止，从而测得的稳态放电率为 $0.0 \\, \\text{Hz}$。\n\n- **案例 3 (起始点以上单调性)：** 只要系统不处于复杂或混沌状态，神经元的放电率应该是输入电流的单调递增函数。我们通过计算一系列递增电流 $I \\in \\{I_{rh} + 0.2, I_{rh} + 0.4, I_{rh} + 0.8\\}$ 的放电率，来验证我们的模型在阈值附近区域的这一特性。我们检查所得的放电率 $f_1, f_2, f_3$ 是否满足条件 $f_1  f_2  f_3$。\n\n设计一个 Python 脚本来执行这整个流程，并以指定的格式提供所需的三个结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Numerically investigates Type I excitability in the Izhikevich neuron model.\n    \"\"\"\n    # Model parameters for Type I excitability (integrator)\n    a = 0.02\n    b = -0.1\n    c = -55.0  # mV\n    d = 6.0\n    v_thresh = 30.0  # mV\n\n    # Numerical integration parameters\n    dt = 0.1  # ms\n\n    # Initial conditions\n    v0 = -65.0  # mV\n    u0 = b * v0\n\n    memo_simulation = {}\n\n    def run_simulation(I, T_total_ms):\n        \"\"\"\n        Simulates the Izhikevich neuron for a given current and duration.\n        Caches results to avoid re-computation.\n        \"\"\"\n        sim_key = (I, T_total_ms)\n        if sim_key in memo_simulation:\n            return memo_simulation[sim_key]\n\n        v = v0\n        u = u0\n        \n        num_steps = int(T_total_ms / dt)\n        spike_times = []\n\n        for i in range(num_steps):\n            t = i * dt\n\n            if v = v_thresh:\n                spike_times.append(t)\n                v = c\n                u = u + d\n\n            dv_dt = 0.04 * v**2 + 5 * v + 140 - u + I\n            du_dt = a * (b * v - u)\n            \n            v += dt * dv_dt\n            u += dt * du_dt\n        \n        # Final check in case the last step crossed the threshold\n        if v = v_thresh:\n            spike_times.append(T_total_ms)\n\n        result = np.array(spike_times)\n        memo_simulation[sim_key] = result\n        return result\n\n    def check_sustained_firing(I):\n        \"\"\"\n        Checks for sustained firing (= 2 spikes) for rheobase search.\n        \"\"\"\n        T_sim = 12000  # ms\n        warmup = 2000  # ms\n        min_spikes = 2\n        \n        spike_times = run_simulation(I, T_sim)\n        spikes_in_window = np.sum((spike_times  warmup)  (spike_times = T_sim))\n        \n        return spikes_in_window = min_spikes\n\n    def find_rheobase():\n        \"\"\"\n        Finds the rheobase current using bisection search.\n        \"\"\"\n        low_I = 0.0\n        high_I = 30.0\n        tolerance = 1e-8\n\n        # Verify bracket\n        if check_sustained_firing(low_I):\n             raise ValueError(\"Lower bound of rheobase search already fires.\")\n        if not check_sustained_firing(high_I):\n             raise ValueError(\"Upper bound of rheobase search does not fire.\")\n\n        while (high_I - low_I)  tolerance:\n            mid_I = (low_I + high_I) / 2\n            if check_sustained_firing(mid_I):\n                high_I = mid_I\n            else:\n                low_I = mid_I\n        \n        return high_I\n\n    def calculate_firing_rate(I):\n        \"\"\"\n        Calculates the steady-state firing rate in Hz.\n        \"\"\"\n        T_sim = 20000  # ms\n        warmup = 5000  # ms\n        observation_duration_s = (T_sim - warmup) / 1000.0\n        \n        spike_times = run_simulation(I, T_sim)\n        spikes_in_window = np.sum((spike_times  warmup)  (spike_times = T_sim))\n        \n        if observation_duration_s  0:\n            return spikes_in_window / observation_duration_s\n        return 0.0\n\n    # Main logic\n    \n    # 1. Determine rheobase\n    I_rh = find_rheobase()\n\n    # 2. Case 1: Calculate exponent p\n    delta_Is = np.array([0.05, 0.1, 0.2])\n    currents_case1 = I_rh + delta_Is\n    rates_case1 = np.array([calculate_firing_rate(I) for I in currents_case1])\n    \n    # Check for non-positive rates before taking log\n    if np.any(rates_case1 = 0):\n        # This case should not happen with the chosen delta_Is\n        # but as a safeguard:\n        result1 = np.nan\n    else:\n        log_delta_Is = np.log(delta_Is)\n        log_rates = np.log(rates_case1)\n        # Fit a line: log(rates) = p * log(delta_Is) + const\n        p_exponent = np.polyfit(log_delta_Is, log_rates, 1)[0]\n        result1 = p_exponent\n\n    # 3. Case 2: Firing rate at rheobase\n    rate_at_rh = calculate_firing_rate(I_rh)\n    result2 = rate_at_rh\n\n    # 4. Case 3: Monotonicity check\n    currents_case3 = I_rh + np.array([0.2, 0.4, 0.8])\n    rates_case3 = np.array([calculate_firing_rate(I) for I in currents_case3])\n    is_monotonic = (rates_case3[0]  rates_case3[1]) and (rates_case3[1]  rates_case3[2])\n    result3 = bool(is_monotonic)  # Ensure it's a standard Python boolean\n\n    # Final output\n    print(f\"[{result1},{result2},{result3}]\")\n\nsolve()\n```"
        }
    ]
}