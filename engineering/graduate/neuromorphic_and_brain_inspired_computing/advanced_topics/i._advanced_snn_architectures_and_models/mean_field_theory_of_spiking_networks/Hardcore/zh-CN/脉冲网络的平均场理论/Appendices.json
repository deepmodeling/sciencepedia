{
    "hands_on_practices": [
        {
            "introduction": "我们从平均场理论的基石开始：将神经元接收到的突触输入视为一个随机过程。本练习将指导您把由泊松过程描述的突触前脉冲序列看作一种“散粒噪声”，并计算由此产生的突触电流的均值和方差。通过这个计算，您将为后续更复杂的扩散近似方法奠定关键的数学基础。",
            "id": "4051240",
            "problem": "考虑一个稳态的突触前脉冲序列，它被建模为一个速率为 $\\nu$（单位时间内的事件数）的均匀泊松点过程。设单个脉冲引起的突触后响应由因果单指数突触核 $\\alpha(t) = \\exp(-t/\\tau_s) H(t)$ 决定，其中 $H(t)$ 是 Heaviside 阶跃函数，$\\tau_s > 0$ 是突触时间常数。考虑两种突触模型：\n\n1. 基于电流的突触，其突触后电流由 $I(t) = J \\sum_{k} \\alpha(t - t_k)$ 给出，其中 $J$ 是每个脉冲引起的恒定电流增量，$\\{t_k\\}$ 是突触前脉冲时间。\n\n2. 基于电导的突触，其突触后电导由 $g(t) = g_0 \\sum_{k} \\alpha(t - t_k)$ 给出，其中 $g_0$ 是每个脉冲引起的恒定电导增量。\n\n仅从以下条件出发：\n- 均匀泊松点过程的定义及其平稳性。\n- 关于泊松点过程求和的成熟性质（例如，对独立点的求和的期望和二阶矩），以及 $\\alpha(t)$ 在 $[0,\\infty)$ 上是可积和平方可积的这一事实。\n\n推导基于电流的突触的突触电流 $I(t)$ 的稳态均值和方差，以及基于电导的突触的突触电导 $g(t)$ 的稳态均值和方差。用 $\\nu$、$\\tau_s$、$J$ 和 $g_0$ 表示您的最终答案的闭式解析表达式。不要代入任何数值。将最终答案表示为一个行矩阵，其条目顺序为 $\\langle I \\rangle$、$\\mathrm{Var}(I)$、$\\langle g \\rangle$、$\\mathrm{Var}(g)$。无需四舍五入。仅以符号形式表示答案。",
            "solution": "该问题要求计算由速率为 $\\nu$ 的均匀泊松脉冲序列驱动的突触电流 $I(t)$ 和突触电导 $g(t)$ 的稳态均值和方差。该问题陈述经证实具有科学依据、问题明确且客观。这是理论和计算神经科学中的一个标准问题。\n\n电流 $I(t)$ 和电导 $g(t)$ 都可以表示为线性滤波泊松过程，也称为散粒噪声。一个通用的散粒噪声过程 $X(t)$ 定义为在随机时间 $\\{t_k\\}$ 发生的事件响应的总和：\n$$X(t) = \\sum_{k} h(t - t_k)$$\n其中 $\\{t_k\\}$ 是速率为 $\\nu$ 的泊松过程的事件时间，$h(t)$ 是响应函数或核函数。\n\n对于一个平稳的、均匀的泊松过程，过程 $X(t)$ 的稳态均值 $\\langle X \\rangle$ 和方差 $\\mathrm{Var}(X)$ 由 Campbell 定理给出。问题陈述允许使用这些成熟的性质。公式如下：\n$$ \\langle X \\rangle = \\nu \\int_{-\\infty}^{\\infty} h(s) ds $$\n$$ \\mathrm{Var}(X) = \\nu \\int_{-\\infty}^{\\infty} h(s)^2 ds $$\n这些公式在积分收敛的条件下有效，此条件在此处得到满足，因为核函数 $\\alpha(t)$ 被陈述为可积和平方可积的。\n\n突触核函数为 $\\alpha(t) = \\exp(-t/\\tau_s) H(t)$，其中 $H(t)$ 是 Heaviside 阶跃函数。该核函数是因果的，意味着当 $t  0$ 时 $\\alpha(t) = 0$。我们将把这些公式应用于基于电流和基于电导的突触模型。\n\n首先，我们计算核函数 $\\alpha(t)$ 的必要积分。\n$\\alpha(t)$ 的积分是：\n$$ \\int_{-\\infty}^{\\infty} \\alpha(s) ds = \\int_0^{\\infty} \\exp(-s/\\tau_s) ds = \\left[ -\\tau_s \\exp(-s/\\tau_s) \\right]_0^{\\infty} = 0 - (-\\tau_s \\exp(0)) = \\tau_s $$\n\n$\\alpha(t)^2$ 的积分是：\n$$ \\int_{-\\infty}^{\\infty} \\alpha(s)^2 ds = \\int_0^{\\infty} \\left( \\exp(-s/\\tau_s) \\right)^2 ds = \\int_0^{\\infty} \\exp(-2s/\\tau_s) ds = \\left[ -\\frac{\\tau_s}{2} \\exp(-2s/\\tau_s) \\right]_0^{\\infty} = 0 - \\left(-\\frac{\\tau_s}{2} \\exp(0)\\right) = \\frac{\\tau_s}{2} $$\n\n现在我们可以继续计算每个模型的矩。\n\n1.  基于电流的突触\n突触后电流由 $I(t) = J \\sum_{k} \\alpha(t - t_k)$ 给出。这是一个散粒噪声过程，其响应核函数为 $h_I(t) = J \\alpha(t)$。\n\n平均电流 $\\langle I \\rangle$ 是：\n$$ \\langle I \\rangle = \\nu \\int_{-\\infty}^{\\infty} h_I(s) ds = \\nu \\int_{-\\infty}^{\\infty} J \\alpha(s) ds $$\n$$ \\langle I \\rangle = \\nu J \\int_{-\\infty}^{\\infty} \\alpha(s) ds = \\nu J \\tau_s $$\n\n电流的方差 $\\mathrm{Var}(I)$ 是：\n$$ \\mathrm{Var}(I) = \\nu \\int_{-\\infty}^{\\infty} h_I(s)^2 ds = \\nu \\int_{-\\infty}^{\\infty} (J \\alpha(s))^2 ds $$\n$$ \\mathrm{Var}(I) = \\nu J^2 \\int_{-\\infty}^{\\infty} \\alpha(s)^2 ds = \\nu J^2 \\left( \\frac{\\tau_s}{2} \\right) = \\frac{\\nu J^2 \\tau_s}{2} $$\n\n2.  基于电导的突触\n突触后电导由 $g(t) = g_0 \\sum_{k} \\alpha(t - t_k)$ 给出。这也是一个散粒噪声过程，但其响应核函数为 $h_g(t) = g_0 \\alpha(t)$。计算的结构与基于电流的情况相同，只是常数 $J$ 被 $g_0$ 替换。\n\n平均电导 $\\langle g \\rangle$ 是：\n$$ \\langle g \\rangle = \\nu \\int_{-\\infty}^{\\infty} h_g(s) ds = \\nu \\int_{-\\infty}^{\\infty} g_0 \\alpha(s) ds $$\n$$ \\langle g \\rangle = \\nu g_0 \\int_{-\\infty}^{\\infty} \\alpha(s) ds = \\nu g_0 \\tau_s $$\n\n电导的方差 $\\mathrm{Var}(g)$ 是：\n$$ \\mathrm{Var}(g) = \\nu \\int_{-\\infty}^{\\infty} h_g(s)^2 ds = \\nu \\int_{-\\infty}^{\\infty} (g_0 \\alpha(s))^2 ds $$\n$$ \\mathrm{Var}(g) = \\nu g_0^2 \\int_{-\\infty}^{\\infty} \\alpha(s)^2 ds = \\nu g_0^2 \\left( \\frac{\\tau_s}{2} \\right) = \\frac{\\nu g_0^2 \\tau_s}{2} $$\n\n所要求的四个量是：\n- 平均电流：$\\langle I \\rangle = \\nu J \\tau_s$\n- 电流方差：$\\mathrm{Var}(I) = \\frac{\\nu J^2 \\tau_s}{2}$\n- 平均电导：$\\langle g \\rangle = \\nu g_0 \\tau_s$\n- 电导方差：$\\mathrm{Var}(g) = \\frac{\\nu g_0^2 \\tau_s}{2}$\n\n最终答案将以包含这四个值的行矩阵形式呈现。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\nu J \\tau_s  \\frac{\\nu J^2 \\tau_s}{2}  \\nu g_0 \\tau_s  \\frac{\\nu g_0^2 \\tau_s}{2}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "扩散近似将复杂的突触输入简化为高斯过程，但这种简化何时才算合理？本练习将深入探讨突触输入的更高阶统计特性，以评估该近似的有效性。通过分析克莱默斯-莫亚尔系数并计算标准化三阶累积量（偏度），您将推导出一个量化标准，用于判断扩散近似在特定条件下（例如，当输入发放率 $\\nu$ 和突触时间常数 $\\tau_s$ 的乘积很大时）的准确性。",
            "id": "4051248",
            "problem": "考虑一个单室神经元，它接收大量统计独立的突触输入，这些输入可以聚合为一个速率为 $\\nu$ 的单一均匀泊松点过程（PPP）。每个突触前脉冲会引起一个幅度为 $J$ 的突触后电流跳变，随后以突触时间常数 $\\tau_s$ 进行指数衰减。总突触电流 $I(t)$ 服从线性散粒噪声动力学\n$$\n\\frac{d I(t)}{dt} \\;=\\; -\\frac{I(t)}{\\tau_s} \\;+\\; J \\sum_k \\delta\\!\\left(t-t_k\\right),\n$$\n其中 $\\{t_k\\}$ 是泊松事件时间。等价地，对于 PPP 的计数过程 $N_t$，其微分形式为\n$$\ndI(t) \\;=\\; -\\frac{I(t)}{\\tau_s}\\,dt \\;+\\; J\\,dN_t,\n$$\n其中 $\\mathbb{E}[dN_t] = \\nu\\,dt$。\n\n从 Kramers–Moyal 展开（KME）的定义出发，第 $n$ 阶 Kramers–Moyal 系数 $a_n(I)$ 为\n$$\na_n(I) \\;=\\; \\lim_{dt\\to 0} \\frac{1}{dt}\\,\\mathbb{E}\\!\\left[ \\big(\\Delta I\\big)^{n} \\,\\big|\\, I(t)=I \\right],\n$$\n其中 $\\Delta I \\equiv I(t+dt)-I(t)$。\n\n1) 仅使用上述动力学和均匀泊松过程在无穷小区间内的性质，推导前三个 Kramers–Moyal 系数 $a_1(I)$、$a_2(I)$ 和 $a_3(I)$。\n\n2) 在平稳状态下，突触电流可以表示为线性叠加\n$$\nI(t) \\;=\\; \\sum_{t_k  t} J \\exp\\!\\left(-\\frac{t-t_k}{\\tau_s}\\right).\n$$\n使用泊松散粒噪声的成熟结果，计算 $I(t)$ 的前三个等时累积量 $\\kappa_1$、$\\kappa_2$ 和 $\\kappa_3$。\n\n3) 扩散近似忽略了三阶及更高阶的 Kramers–Moyal 项，因此一个误差指标是标准化的三阶累积量（偏度大小）\n$$\n\\gamma \\;\\equiv\\; \\frac{|\\kappa_3|}{\\kappa_2^{3/2}}.\n$$\n将 $\\gamma$ 表示为包含 $J$、$\\nu$ 和 $\\tau_s$ 的闭式解析表达式。请以单个符号表达式的形式提供最终答案。不需要进行数值计算或四舍五入，最终表达式中不应包含单位。",
            "solution": "我们从随机微分形式开始\n$$\ndI(t) \\;=\\; -\\frac{I(t)}{\\tau_s}\\,dt \\;+\\; J\\,dN_t,\n$$\n其中 $N_t$ 是速率为 $\\nu$ 的均匀泊松点过程（PPP）的计数过程。在无穷小区间 $[t,t+dt)$ 上，增量为\n$$\n\\Delta I \\;=\\; -\\frac{I}{\\tau_s}\\,dt \\;+\\; J\\,\\Delta N,\n$$\n其中 $\\Delta N \\equiv N_{t+dt}-N_t$。对于均匀 PPP，$\\Delta N$ 的分布为 $\\mathbb{P}(\\Delta N=1)=\\nu\\,dt + o(dt)$、$\\mathbb{P}(\\Delta N=0)=1-\\nu\\,dt+o(dt)$ 和 $\\mathbb{P}(\\Delta N \\ge 2)=o(dt)$。\n\n1) 计算前三个 Kramers–Moyal 系数。\n\n根据定义，\n$$\na_n(I) \\;=\\; \\lim_{dt\\to 0}\\frac{1}{dt}\\,\\mathbb{E}\\!\\left[ \\big(\\Delta I\\big)^n \\,\\big|\\, I(t)=I \\right].\n$$\n我们计算这些项，保留到 $O(dt)$ 阶。\n\n对于 $n=1$，\n$$\n\\mathbb{E}[\\Delta I \\mid I] \\;=\\; -\\frac{I}{\\tau_s}\\,dt \\;+\\; J\\,\\mathbb{E}[\\Delta N] \\;=\\; -\\frac{I}{\\tau_s}\\,dt \\;+\\; J\\,\\nu\\,dt,\n$$\n因此\n$$\na_1(I) \\;=\\; -\\frac{I}{\\tau_s} \\;+\\; J\\,\\nu.\n$$\n\n对于 $n=2$，展开 $\\Delta I = -\\frac{I}{\\tau_s}dt + J \\Delta N$。在期望中，涉及 $dt$ 和 $\\Delta N$ 的乘积项是 $O(dt^2)$ 阶的，在主阶上可以忽略。$O(dt)$ 阶的贡献来自 $(J\\Delta N)^2$，因为在 $dt\\to 0$ 的极限下 $(dt)^2$ 项会消失。由于在 $O(dt)$ 阶下，对于 $\\Delta N \\in \\{0,1\\}$，有 $\\Delta N^2 = \\Delta N$，\n$$\n\\mathbb{E}\\!\\left[(\\Delta I)^2 \\mid I\\right] \\;=\\; J^2\\,\\mathbb{E}[\\Delta N] \\;+\\; o(dt) \\;=\\; J^2 \\nu\\,dt \\;+\\; o(dt),\n$$\n因此\n$$\na_2(I) \\;=\\; J^2 \\nu.\n$$\n\n对于 $n=3$，根据相同的逻辑，主阶 $O(dt)$ 的贡献是 $(J\\Delta N)^3$，并且由于在 $O(dt)$ 阶下，对于 $\\Delta N\\in\\{0,1\\}$，有 $\\Delta N^3=\\Delta N$，\n$$\n\\mathbb{E}\\!\\left[(\\Delta I)^3 \\mid I\\right] \\;=\\; J^3\\,\\mathbb{E}[\\Delta N] \\;+\\; o(dt) \\;=\\; J^3 \\nu\\,dt \\;+\\; o(dt),\n$$\n所以\n$$\na_3(I) \\;=\\; J^3 \\nu.\n$$\n\n因此，到三阶为止，\n$$\na_1(I) \\;=\\; -\\frac{I}{\\tau_s} + J\\nu,\\qquad a_2(I) \\;=\\; J^2 \\nu,\\qquad a_3(I) \\;=\\; J^3 \\nu.\n$$\n\n2) $I(t)$ 的平稳等时累积量。\n\n在稳态下，$I(t)$ 可以写成泊松散粒噪声的形式\n$$\nI(t) \\;=\\; \\sum_{t_k  t} h(t-t_k),\\qquad h(s) \\;=\\; J \\exp\\!\\left(-\\frac{s}{\\tau_s}\\right)\\,\\mathbf{1}_{\\{s\\ge 0\\}}.\n$$\n对于速率为 $\\nu$ 的均匀 PPP 和确定性核 $h$， $I(t)$ 的第 $n$ 阶等时累积量 $\\kappa_n$ 由经过充分检验的泊松散粒噪声累积量的坎贝尔定理给出：\n$$\n\\kappa_n \\;=\\; \\nu \\int_{0}^{\\infty} \\big(h(s)\\big)^n\\,ds.\n$$\n对于指数核，\n$$\n\\int_{0}^{\\infty} \\big(h(s)\\big)^n\\,ds \\;=\\; \\int_{0}^{\\infty} J^n \\exp\\!\\left(-\\frac{n s}{\\tau_s}\\right)\\,ds \\;=\\; J^n \\frac{\\tau_s}{n}.\n$$\n因此，\n$$\n\\kappa_n \\;=\\; \\nu\\,J^n\\,\\frac{\\tau_s}{n}.\n$$\n具体来说，\n$$\n\\kappa_1 \\;=\\; \\nu J \\tau_s,\\qquad \\kappa_2 \\;=\\; \\nu J^2 \\frac{\\tau_s}{2},\\qquad \\kappa_3 \\;=\\; \\nu J^3 \\frac{\\tau_s}{3}.\n$$\n\n3) 作为误差指标的标准化的三阶累积量（偏度大小）。\n\n定义\n$$\n\\gamma \\;\\equiv\\; \\frac{|\\kappa_3|}{\\kappa_2^{3/2}}.\n$$\n代入上述表达式，\n$$\n\\gamma \\;=\\; \\frac{\\left|\\nu J^3 \\frac{\\tau_s}{3}\\right|}{\\left(\\nu J^2 \\frac{\\tau_s}{2}\\right)^{3/2}}\n\\;=\\; \\frac{|J|^3 \\nu \\tau_s / 3}{|J|^3 (\\nu \\tau_s)^{3/2} / 2^{3/2}}\n\\;=\\; \\frac{2^{3/2}}{3}\\,\\frac{1}{\\sqrt{\\nu \\tau_s}}.\n$$\n因此，基于三阶累积量的小性的扩散近似误差指标为\n$$\n\\gamma \\;=\\; \\frac{2^{3/2}}{3}\\,(\\nu \\tau_s)^{-1/2}.\n$$\n值得注意的是，在标准化度量中，对 $J$ 的依赖性被消除了；只有乘积 $\\nu \\tau_s$ 控制其大小，较大的 $\\nu \\tau_s$ 会产生较小的偏度，从而得到更好的扩散近似。",
            "answer": "$$\\boxed{\\frac{2^{3/2}}{3}\\,(\\nu\\,\\tau_s)^{-1/2}}$$"
        },
        {
            "introduction": "现在，我们将所有部分整合起来，对一个包含兴奋性（E）和抑制性（I）神经元的完整网络进行建模。这个综合性练习要求您编写代码，求解连接单个神经元发放率与网络集体活动的自洽方程。这展示了平均场理论在预测网络涌现状态（如兴奋-抑制平衡态）方面的强大能力，是理论神经科学中的一个核心实践。",
            "id": "3996524",
            "problem": "考虑一个由兴奋性群体（标记为 $e$）和抑制性群体（标记为 $i$）组成的大型、随机连接的双群体脉冲神经元网络。每个神经元从群体 $q \\in \\{e,i\\}$ 接收 $K_{pq}$ 个突触前连接，并且来自群体 $q$ 的每个突触前脉冲会在群体 $p \\in \\{e,i\\}$ 中神经元的突触后膜电位上产生一个幅度为 $J_{pq}$ 的瞬时跳变。假设网络在高入度极限下运行，因此传入的脉冲序列可以近似为独立的泊松过程，并且对神经元的总突触输入可以采用扩散近似处理。\n\n从适用于突触散粒噪声的扩散近似和带有加性高斯白噪声的漏积分-发放 (LIF) 模型的第一性原理出发：\n\n- 突触散粒噪声被近似为一个高斯过程，其特征在于漂移（均值）和扩散（方差）是突触前发放率的线性函数。\n- 膜电位根据漏积分-发放 (LIF) 动力学演化，其膜时间常数为 $\\tau_m$，绝对不应期为 $\\tau_{\\mathrm{ref}}$。阈值和重置电位分别表示为 $V_{\\theta,p}$ 和 $V_{r}$。我们假设 $V_{r}$ 在两个群体间共享，并且所有电压量都以阈值标度归一化的单位表示，因此跳变幅度 $J_{pq}$ 在这些单位下是无量纲的。\n- 在具有速率为 $\\nu_e$ 和 $\\nu_i$ 的突触前泊松输入且 $K_{pq}$ 较大时的扩散极限下，群体 $p$ 的有效漂移和扩散为\n$$\n\\mu_p(\\nu_e,\\nu_i) \\;=\\; \\mu_{0,p} \\;+\\; K_{pe}\\,J_{pe}\\,\\nu_e \\;+\\; K_{pi}\\,J_{pi}\\,\\nu_i,\n$$\n$$\n\\sigma_p^2(\\nu_e,\\nu_i) \\;=\\; \\sigma_{0,p}^2 \\;+\\; K_{pe}\\,J_{pe}^2\\,\\nu_e \\;+\\; K_{pi}\\,J_{pi}^2\\,\\nu_i,\n$$\n其中 $(\\mu_{0,p},\\sigma_{0,p})$ 代表独立于网络活动的外部基线均值和标准差贡献。\n\n- 在带有加性白噪声的 LIF 模型下，单个神经元的传递函数由 Siegert 公式给出：\n$$\n\\nu_p \\;=\\; \\left[ \\tau_{\\mathrm{ref}} \\;+\\; \\tau_m \\,\\sqrt{\\pi}\\;\\int_{u_{r,p}}^{u_{\\theta,p}} \\exp(u^2)\\,\\bigl(1+\\mathrm{erf}(u)\\bigr)\\,du \\right]^{-1},\n$$\n其中 $u_{r,p} = \\dfrac{V_r - \\mu_p}{\\sigma_p}$ 且 $u_{\\theta,p} = \\dfrac{V_{\\theta,p} - \\mu_p}{\\sigma_p}$，并且 $\\mathrm{erf}(\\cdot)$ 表示误差函数。为确保数值稳定性，请注意 $\\exp(u^2)\\bigl(1+\\mathrm{erf}(u)\\bigr) = \\mathrm{erfcx}(-u)$，其中 $\\mathrm{erfcx}$ 是标度互补误差函数。\n\n你的任务是：\n1. 通过组合 $\\mu_p(\\nu_e,\\nu_i)$、$\\sigma_p(\\nu_e,\\nu_i)$ 的表达式以及单个神经元传递函数 $\\nu_p = F_p\\bigl(\\mu_p(\\nu_e,\\nu_i),\\sigma_p(\\nu_e,\\nu_i)\\bigr)$（其中 $p \\in \\{e,i\\}$），推导定义不动点发放率 $(\\nu_e,\\nu_i)$ 的自洽平均场方程。\n2. 实现一个程序，使用鲁棒的数值方法求解得到的关于 $(\\nu_e,\\nu_i)$ 的二维不动点问题。\n3. 使用以下参数集测试套件。在所有情况下，$\\tau_m$ 和 $\\tau_{\\mathrm{ref}}$ 以秒表示，发放率以赫兹（每秒脉冲数）报告。与电压相关的量如上所述，在阈值归一化单位下是无量纲的。\n\n测试用例 A (平衡态):\n- $\\tau_m = 0.02$, $\\tau_{\\mathrm{ref}} = 0.002$, $V_r = 0$, $V_{\\theta,e} = 1.0$, $V_{\\theta,i} = 1.0$.\n- $K_{ee} = 800$, $K_{ei} = 200$, $K_{ie} = 800$, $K_{ii} = 200$.\n- $J_{ee} = 0.001$, $J_{ei} = -0.004$, $J_{ie} = 0.001$, $J_{ii} = -0.004$.\n- $\\mu_{0,e} = 0.6$, $\\sigma_{0,e} = 0.3$, $\\mu_{0,i} = 0.6$, $\\sigma_{0,i} = 0.3$.\n\n测试用例 B (弱抑制，较高活动):\n- 与 A 相同，除了 $J_{ei} = -0.001$, $J_{ii} = -0.001$。\n\n测试用例 C (强抑制，低基线；接近静息的边界情况):\n- $\\tau_m = 0.02$, $\\tau_{\\mathrm{ref}} = 0.002$, $V_r = 0$, $V_{\\theta,e} = 1.0$, $V_{\\theta,i} = 1.0$.\n- $K_{ee} = 800$, $K_{ei} = 200$, $K_{ie} = 800$, $K_{ii} = 200$.\n- $J_{ee} = 0.001$, $J_{ei} = -0.008$, $J_{ie} = 0.001$, $J_{ii} = -0.008$.\n- $\\mu_{0,e} = 0.3$, $\\sigma_{0,e} = 0.15$, $\\mu_{0,i} = 0.3$, $\\sigma_{0,i} = 0.15$.\n\n算法要求：\n- 从提供的组件构建不动点方程，不要引入绕过基本定义的简化。\n- 使用一种包含回退策略的方法求解 $(\\nu_e,\\nu_i)$，以防通用求根器未能收敛。\n- 通过在适当情况下使用标度互补误差函数，确保定义传递函数的积分具有数值稳定性。\n\n输出规范：\n- 你的程序应生成单行输出，其中包含一个 Python 风格的列表的列表，每个测试用例一个，按 A、B、C 的顺序排列。\n- 每个内部列表必须是两个浮点数 $[\\nu_e,\\nu_i]$，单位为赫兹，四舍五入到三位小数。\n- 例如，输出格式必须严格为 $[[\\nu_{e,A},\\nu_{i,A}],[\\nu_{e,B},\\nu_{i,B}],[\\nu_{e,C},\\nu_{i,C}]]$ 的形式，位于单行上，无任何附加文本。",
            "solution": "用户提供了一个计算神经科学领域的问题，要求推导并数值求解一个双群体脉冲神经元网络的平均场方程。\n\n### 问题验证\n\n该问题根据指定标准进行评估：\n1.  **给定条件**：明确提供了双群体漏积分-发放 (LIF) 网络在扩散近似下的所有参数、方程和边界条件。这包括突触输入均值 ($\\mu_p$)、输入方差 ($\\sigma_p^2$) 以及通过 Siegert 公式的单个神经元传递函数 ($\\nu_p = F_p(\\mu_p, \\sigma_p)$) 的表达式。给出了三个特定的参数集用于测试。\n2.  **科学依据**：该问题在根本上是合理的。突触电流的扩散近似、LIF 神经元模型以及用于首达时的 Siegert 公式都是计算神经科学中平均场理论的经典组成部分。该设置是一个标准的、被广泛认可的理论模型。\n3.  **良定性与客观性**：问题是寻找一个非线性方程组的不动点。这是一个明确定义的数学任务。问题陈述是客观的，使用了精确、标准的术语。它通过要求一个鲁棒的求解方法来正确预见数值挑战，表明其结构经过深思熟虑。所提供的参数和方程是自洽、一致且足以进行求解的。\n\n该问题被判定为**有效**。我们可以继续进行求解。\n\n### 第一部分：自洽平均场方程的推导\n\n网络在不动点处的状态由兴奋性和抑制性群体的稳态发放率 $(\\nu_e, \\nu_i)$ 描述。一个自洽解是指，当这些发放率反馈回网络时，能够产生完全相同的发放率。这构成了网络动力学映射的一个不动点。\n\n令群体 $p \\in \\{e,i\\}$ 的传递函数表示为 $F_p$。该函数根据总突触输入的均值 $\\mu_p$ 和标准差 $\\sigma_p$ 计算输出发放率 $\\nu_p$。\n$$\n\\nu_p = F_p(\\mu_p, \\sigma_p)\n$$\n函数 $F_p$ 由 Siegert 公式给出：\n$$\nF_p(\\mu_p, \\sigma_p) = \\left[ \\tau_{\\mathrm{ref}} + \\tau_m \\sqrt{\\pi} \\int_{u_{r,p}}^{u_{\\theta,p}} \\exp(u^2)\\bigl(1+\\mathrm{erf}(u)\\bigr)\\,du \\right]^{-1}\n$$\n其中积分的上下限是输入统计量的函数：\n$$\nu_{r,p} = \\frac{V_r - \\mu_p}{\\sigma_p}, \\quad u_{\\theta,p} = \\frac{V_{\\theta,p} - \\mu_p}{\\sigma_p}\n$$\n反过来，输入统计量 $\\mu_p$ 和 $\\sigma_p$ 本身是网络发放率 $(\\nu_e, \\nu_i)$ 的函数，由扩散近似指定：\n$$\n\\mu_p(\\nu_e, \\nu_i) = \\mu_{0,p} + K_{pe} J_{pe} \\nu_e + K_{pi} J_{pi} \\nu_i\n$$\n$$\n\\sigma_p(\\nu_e, \\nu_i) = \\sqrt{\\sigma_{0,p}^2 + K_{pe} J_{pe}^2 \\nu_e + K_{pi} J_{pi}^2 \\nu_i}\n$$\n通过要求输出速率与产生它们的输入速率相匹配，可以得到自洽平均场方程。这是通过将 $\\mu_p(\\nu_e, \\nu_i)$ 和 $\\sigma_p(\\nu_e, \\nu_i)$ 的表达式代入传递函数来实现的，从而得到一个关于两个未知速率 $\\nu_e$ 和 $\\nu_i$ 的耦合非线性方程组：\n$$\n\\begin{cases}\n\\nu_e = F_e\\Big(\\mu_e(\\nu_e, \\nu_i), \\sigma_e(\\nu_e, \\nu_i)\\Big) \\\\\n\\nu_i = F_i\\Big(\\mu_i(\\nu_e, \\nu_i), \\sigma_i(\\nu_e, \\nu_i)\\Big)\n\\end{cases}\n$$\n这些方程定义了系统的不动点。一个解 $(\\nu_e^*, \\nu_i^*)$ 代表了网络在平均场极限下的稳定（或不稳定）发放率。\n\n### 第二和第三部分：数值实现与求解\n\n为了求解该系统，我们寻求向量函数 $\\mathbf{G}(\\boldsymbol{\\nu}) = \\mathbf{F}(\\boldsymbol{\\nu}) - \\boldsymbol{\\nu} = \\mathbf{0}$ 的根，其中 $\\boldsymbol{\\nu} = (\\nu_e, \\nu_i)^T$，$\\mathbf{F}(\\boldsymbol{\\nu})$ 是传递函数的向量。\n\n**数值方法：**\n1.  **传递函数：** Siegert 公式中的积分使用 `scipy.integrate.quad`进行数值计算。为了数值稳定性，如建议所示，被积函数 $\\exp(u^2)(1+\\mathrm{erf}(u))$被替换为标度互补误差函数 $\\mathrm{erfcx}(-u)$。这避免了当 $u$ 为大的正值时可能发生的浮点溢出，这种情况可能在神经元远离其阈值时出现。\n2.  **求根：** 我们将使用 `scipy.optimize.root` 及其 `hybr` 方法，这是一种用于寻找非线性系统根的鲁棒算法。初始猜测值通过仅基于外部输入 $(\\mu_{0,p}, \\sigma_{0,p})$ 计算发放率来生成。\n3.  **回退策略：** 按要求，实现了一个回退方法，以防主求根器失败。使用了一种阻尼不动点迭代方案：\n    $$\n    \\boldsymbol{\\nu}^{(k+1)} = (1-\\alpha)\\boldsymbol{\\nu}^{(k)} + \\alpha \\mathbf{F}(\\boldsymbol{\\nu}^{(k)})\n    $$\n    其中阻尼因子 $\\alpha > 0$ 较小。这种迭代方法对于这类问题通常是稳定的，尽管其收敛速度可能比基于梯度的方法慢。从物理上看，发放率必须是非负的，即 $\\nu_p \\ge 0$。传递函数 $F_p$ 内在地产生正值，因此不动点迭代保留了这一约束。主求解器的解也会检查其正性。\n\n以下 Python 代码实现了此策略，用于求解给定三个测试用例的不动点发放率。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfcx, erf\nfrom scipy.integrate import quad\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Solves the mean-field equations for a two-population spiking network for three test cases.\n    \"\"\"\n\n    def transfer_function(mu, sigma, V_theta, V_r, tau_m, tau_ref):\n        \"\"\"\n        Calculates the firing rate of an LIF neuron given input statistics using the Siegert formula.\n        \n        This is the function F_p(mu_p, sigma_p). The numerically stable form of the integrand is used.\n        \"\"\"\n        # Handle the near-deterministic case where sigma is very small to avoid division by zero.\n        # The diffusion approximation is not valid for sigma -> 0, but this provides numerical stability.\n        if sigma  1e-9:\n            if mu > V_theta:\n                # In the deterministic limit, firing occurs if mu is above threshold.\n                # The inter-spike interval is the time to drift from V_r to V_theta.\n                # This check prevents log(negative) if mu  V_r.\n                if mu > V_r:\n                    t_isi = tau_ref + tau_m * np.log((mu - V_r) / (mu - V_theta))\n                    return 1.0 / t_isi if t_isi > 1e-9 else 1e9\n                else:\n                    return 0.0 # mu is between V_r and V_theta, so it never reaches threshold.\n            else:\n                return 0.0 # Subthreshold drive.\n\n        # Calculate normalized voltage bounds for the integral\n        u_r = (V_r - mu) / sigma\n        u_theta = (V_theta - mu) / sigma\n        \n        # The problem defines the integral of exp(u^2)*(1+erf(u)), which is numerically\n        # unstable. The hint is to use erfcx(-u).\n        # integrand = lambda u: np.exp(u**2) * (1 + erf(u)) is equivalent to\n        integrand = lambda u: erfcx(-u)\n\n        # The integral is guaranteed to be positive as erfcx(-u) > 0 for all u, and u_theta > u_r.\n        integral_val, _ = quad(integrand, u_r, u_theta)\n\n        # Calculate the mean inter-spike interval\n        tau_isi = tau_ref + tau_m * np.sqrt(np.pi) * integral_val\n\n        # Firing rate is the inverse of the mean ISI.\n        # tau_isi is guaranteed to be positive.\n        return 1.0 / tau_isi\n\n    def fixed_point_system(nu, params_case):\n        \"\"\"\n        Calculates the new firing rates F(nu) based on the current rates nu.\n        \n        Args:\n            nu (array-like): A list or array [nu_e, nu_i] of current firing rates in Hz.\n            params_case (dict): Dictionary containing all parameters for the network.\n        \n        Returns:\n            np.array: A numpy array [nu_e_new, nu_i_new] of calculated firing rates.\n        \"\"\"\n        nu_e, nu_i = max(0, nu[0]), max(0, nu[1]) # Rates must be non-negative\n\n        p_e = params_case['e']\n        p_i = params_case['i']\n\n        # Calculate input mean (drift) for each population\n        mu_e = p_e['mu0'] + p_e['K_ee'] * p_e['J_ee'] * nu_e + p_e['K_ei'] * p_e['J_ei'] * nu_i\n        mu_i = p_i['mu0'] + p_i['K_ie'] * p_i['J_ie'] * nu_e + p_i['K_ii'] * p_i['J_ii'] * nu_i\n        \n        # Calculate input variance (diffusion^2) for each population\n        sigma2_e = p_e['sigma0']**2 + p_e['K_ee'] * p_e['J_ee']**2 * nu_e + p_e['K_ei'] * p_e['J_ei']**2 * nu_i\n        sigma2_i = p_i['sigma0']**2 + p_i['K_ie'] * p_i['J_ie']**2 * nu_e + p_i['K_ii'] * p_i['J_ii']**2 * nu_i\n\n        # Variances must be non-negative. A small floor ensures this.\n        sigma_e = np.sqrt(max(1e-12, sigma2_e))\n        sigma_i = np.sqrt(max(1e-12, sigma2_i))\n\n        # Calculate the new firing rates using the transfer functions\n        nu_e_new = transfer_function(mu_e, sigma_e, p_e['V_theta'], p_e['V_r'], p_e['tau_m'], p_e['tau_ref'])\n        nu_i_new = transfer_function(mu_i, sigma_i, p_i['V_theta'], p_i['V_r'], p_i['tau_m'], p_i['tau_ref'])\n\n        return np.array([nu_e_new, nu_i_new])\n\n    def objective_function(nu, params_case):\n        \"\"\"Objective function for the root finder: G(nu) = F(nu) - nu.\"\"\"\n        return fixed_point_system(nu, params_case) - nu\n\n    def solve_for_case(params_case):\n        \"\"\"\n        Solves the fixed-point problem for a single parameter set.\n        Uses a primary root-finder and a fallback iterative method.\n        \"\"\"\n        # --- Initial Guess ---\n        # Calculate rates based on external input only\n        p_e = params_case['e']\n        p_i = params_case['i']\n        nu_e_0 = transfer_function(p_e['mu0'], p_e['sigma0'], p_e['V_theta'], p_e['V_r'], p_e['tau_m'], p_e['tau_ref'])\n        nu_i_0 = transfer_function(p_i['mu0'], p_i['sigma0'], p_i['V_theta'], p_i['V_r'], p_i['tau_m'], p_i['tau_ref'])\n        initial_guess = np.array([nu_e_0, nu_i_0])\n\n        # --- Primary Solver: scipy.optimize.root ---\n        sol = root(objective_function, initial_guess, args=(params_case,), method='hybr', tol=1e-9)\n\n        if sol.success and np.all(sol.x >= 0):\n            return sol.x\n        \n        # --- Fallback Solver: Damped Fixed-Point Iteration ---\n        nu_k = initial_guess\n        max_iter = 1000\n        tolerance = 1e-9\n        alpha = 0.1  # Damping factor for stability\n        for _ in range(max_iter):\n            nu_k_plus_1 = fixed_point_system(nu_k, params_case)\n            change = np.linalg.norm(nu_k_plus_1 - nu_k)\n            nu_k = (1 - alpha) * nu_k + alpha * nu_k_plus_1\n            if change  tolerance:\n                return nu_k\n        \n        # If the primary solver failed but the fallback also failed to converge,\n        # return the result of the primary solver as a last resort, as it might be close.\n        return sol.x\n    \n    # Define test cases from the problem statement.\n    test_cases_params = [\n        # Test Case A: Balanced regime\n        {\n            'e': {'tau_m': 0.02, 'tau_ref': 0.002, 'V_r': 0.0, 'V_theta': 1.0, 'K_ee': 800, 'K_ei': 200, 'J_ee': 0.001, 'J_ei': -0.004, 'mu0': 0.6, 'sigma0': 0.3},\n            'i': {'tau_m': 0.02, 'tau_ref': 0.002, 'V_r': 0.0, 'V_theta': 1.0, 'K_ie': 800, 'K_ii': 200, 'J_ie': 0.001, 'J_ii': -0.004, 'mu0': 0.6, 'sigma0': 0.3}\n        },\n        # Test Case B: Weak inhibition\n        {\n            'e': {'tau_m': 0.02, 'tau_ref': 0.002, 'V_r': 0.0, 'V_theta': 1.0, 'K_ee': 800, 'K_ei': 200, 'J_ee': 0.001, 'J_ei': -0.001, 'mu0': 0.6, 'sigma0': 0.3},\n            'i': {'tau_m': 0.02, 'tau_ref': 0.002, 'V_r': 0.0, 'V_theta': 1.0, 'K_ie': 800, 'K_ii': 200, 'J_ie': 0.001, 'J_ii': -0.001, 'mu0': 0.6, 'sigma0': 0.3}\n        },\n        # Test Case C: Strong inhibition, low baseline\n        {\n            'e': {'tau_m': 0.02, 'tau_ref': 0.002, 'V_r': 0.0, 'V_theta': 1.0, 'K_ee': 800, 'K_ei': 200, 'J_ee': 0.001, 'J_ei': -0.008, 'mu0': 0.3, 'sigma0': 0.15},\n            'i': {'tau_m': 0.02, 'tau_ref': 0.002, 'V_r': 0.0, 'V_theta': 1.0, 'K_ie': 800, 'K_ii': 200, 'J_ie': 0.001, 'J_ii': -0.008, 'mu0': 0.3, 'sigma0': 0.15}\n        }\n    ]\n\n    results = []\n    for params in test_cases_params:\n        solution = solve_for_case(params)\n        results.append(solution)\n\n    # Format the final output string exactly as specified.\n    # Each inner list is [nu_e, nu_i], rounded to three decimal places.\n    # The final string is a list of these lists, with no extra spaces.\n    formatted_results = [f\"[{res[0]:.3f},{res[1]:.3f}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}