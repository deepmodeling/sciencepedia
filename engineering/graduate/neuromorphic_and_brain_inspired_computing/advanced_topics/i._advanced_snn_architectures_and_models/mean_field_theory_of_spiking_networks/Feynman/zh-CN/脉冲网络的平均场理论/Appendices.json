{
    "hands_on_practices": [
        {
            "introduction": "在分析大型神经网络的动力学之前，我们必须首先为单个神经元接收的输入建立一个统计描述。本练习将大量传入的脉冲建模为“散粒噪声”过程。通过应用针对此类过程的基本结果——坎贝尔定理 (Campbell's theorem)，您将推导出突触电流的稳态均值和方差，为平均场模型提供关键参数。",
            "id": "4051240",
            "problem": "考虑一个稳态突触前脉冲序列，该序列被建模为一个速率为 $\\nu$（单位时间内的事件数）的均匀泊松点过程。设单个脉冲引起的突触后响应由因果单指数突触核函数 $\\alpha(t) = \\exp(-t/\\tau_s) H(t)$ 控制，其中 $H(t)$ 是亥维赛阶跃函数，$\\tau_s > 0$ 是突触时间常数。考虑两种突触模型：\n\n1. 基于电流的突触，其突触后电流由 $I(t) = J \\sum_{k} \\alpha(t - t_k)$ 给出，其中 $J$ 是每个脉冲引起的恒定电流增量，$\\{t_k\\}$ 是突触前脉冲时间。\n\n2. 基于电导的突触，其突触后电导由 $g(t) = g_0 \\sum_{k} \\alpha(t - t_k)$ 给出，其中 $g_0$ 是每个脉冲引起的恒定电导增量。\n\n仅从以下几点出发：\n- 均匀泊松点过程的定义及其稳态性。\n- 泊松点过程求和的成熟性质（例如，对独立点的求和期望和二阶矩），以及函数 $\\alpha(t)$ 在 $[0,\\infty)$ 上是可积和平方可积的事实。\n\n推导基于电流的突触的突触电流 $I(t)$ 的稳态均值和方差，以及基于电导的突触的突触电导 $g(t)$ 的稳态均值和方差。请用 $\\nu$、$\\tau_s$、$J$ 和 $g_0$ 来表示你的最终答案的闭式解析表达式。不要代入任何数值。请将最终答案表示为一个行矩阵，其中的条目顺序为 $\\langle I \\rangle$、$\\mathrm{Var}(I)$、$\\langle g \\rangle$、$\\mathrm{Var}(g)$。无需四舍五入。仅以符号形式表示答案。",
            "solution": "问题要求解由速率为 $\\nu$ 的均匀泊松脉冲序列驱动的突触电流 $I(t)$ 和突触电导 $g(t)$ 的稳态均值和方差。该问题陈述经验证具有科学依据、提法恰当且客观。这是理论和计算神经科学中的一个标准问题。\n\n电流 $I(t)$ 和电导 $g(t)$ 都可以表示为线性滤波泊松过程，也称为散粒噪声。一个通用的散粒噪声过程 $X(t)$ 定义为在随机时间 $\\{t_k\\}$ 发生的事件的响应之和：\n$$X(t) = \\sum_{k} h(t - t_k)$$\n其中 $\\{t_k\\}$ 是速率为 $\\nu$ 的泊松过程的事件时间，而 $h(t)$ 是响应函数或核函数。\n\n对于稳态、均匀泊松过程，过程 $X(t)$ 的稳态均值 $\\langle X \\rangle$ 和方差 $\\mathrm{Var}(X)$ 由坎贝尔定理 (Campbell's theorems) 给出。问题陈述允许使用这些成熟的性质。其公式为：\n$$ \\langle X \\rangle = \\nu \\int_{-\\infty}^{\\infty} h(s) ds $$\n$$ \\mathrm{Var}(X) = \\nu \\int_{-\\infty}^{\\infty} h(s)^2 ds $$\n这些公式在积分收敛的条件下有效，而这里这个条件是满足的，因为题目陈述了核函数 $\\alpha(t)$ 是可积和平方可积的。\n\n突触核函数由 $\\alpha(t) = \\exp(-t/\\tau_s) H(t)$ 给出，其中 $H(t)$ 是亥维赛阶跃函数。该核函数是因果的，意味着对于 $t  0$，$\\alpha(t) = 0$。我们将把这些公式应用于基于电流和基于电导的突触模型。\n\n首先，我们计算核函数 $\\alpha(t)$ 的必要积分。\n$\\alpha(t)$ 的积分为：\n$$ \\int_{-\\infty}^{\\infty} \\alpha(s) ds = \\int_0^{\\infty} \\exp(-s/\\tau_s) ds = \\left[ -\\tau_s \\exp(-s/\\tau_s) \\right]_0^{\\infty} = 0 - (-\\tau_s \\exp(0)) = \\tau_s $$\n\n$\\alpha(t)^2$ 的积分为：\n$$ \\int_{-\\infty}^{\\infty} \\alpha(s)^2 ds = \\int_0^{\\infty} \\left( \\exp(-s/\\tau_s) \\right)^2 ds = \\int_0^{\\infty} \\exp(-2s/\\tau_s) ds = \\left[ -\\frac{\\tau_s}{2} \\exp(-2s/\\tau_s) \\right]_0^{\\infty} = 0 - \\left(-\\frac{\\tau_s}{2} \\exp(0)\\right) = \\frac{\\tau_s}{2} $$\n\n现在我们可以继续计算每个模型的矩。\n\n1.  基于电流的突触\n突触后电流由 $I(t) = J \\sum_{k} \\alpha(t - t_k)$ 给出。\n这是一个散粒噪声过程，其响应核函数为 $h_I(t) = J \\alpha(t)$。\n\n平均电流 $\\langle I \\rangle$ 为：\n$$ \\langle I \\rangle = \\nu \\int_{-\\infty}^{\\infty} h_I(s) ds = \\nu \\int_{-\\infty}^{\\infty} J \\alpha(s) ds $$\n$$ \\langle I \\rangle = \\nu J \\int_{-\\infty}^{\\infty} \\alpha(s) ds = \\nu J \\tau_s $$\n\n电流的方差 $\\mathrm{Var}(I)$ 为：\n$$ \\mathrm{Var}(I) = \\nu \\int_{-\\infty}^{\\infty} h_I(s)^2 ds = \\nu \\int_{-\\infty}^{\\infty} (J \\alpha(s))^2 ds $$\n$$ \\mathrm{Var}(I) = \\nu J^2 \\int_{-\\infty}^{\\infty} \\alpha(s)^2 ds = \\nu J^2 \\left( \\frac{\\tau_s}{2} \\right) = \\frac{\\nu J^2 \\tau_s}{2} $$\n\n2.  基于电导的突触\n突触后电导由 $g(t) = g_0 \\sum_{k} \\alpha(t - t_k)$ 给出。\n这也是一个散粒噪声过程，但其响应核函数为 $h_g(t) = g_0 \\alpha(t)$。计算的结构与基于电流的情况相同，只是常数 $J$ 被替换为 $g_0$。\n\n平均电导 $\\langle g \\rangle$ 为：\n$$ \\langle g \\rangle = \\nu \\int_{-\\infty}^{\\infty} h_g(s) ds = \\nu \\int_{-\\infty}^{\\infty} g_0 \\alpha(s) ds $$\n$$ \\langle g \\rangle = \\nu g_0 \\int_{-\\infty}^{\\infty} \\alpha(s) ds = \\nu g_0 \\tau_s $$\n\n电导的方差 $\\mathrm{Var}(g)$ 为：\n$$ \\mathrm{Var}(g) = \\nu \\int_{-\\infty}^{\\infty} h_g(s)^2 ds = \\nu \\int_{-\\infty}^{\\infty} (g_0 \\alpha(s))^2 ds $$\n$$ \\mathrm{Var}(g) = \\nu g_0^2 \\int_{-\\infty}^{\\infty} \\alpha(s)^2 ds = \\nu g_0^2 \\left( \\frac{\\tau_s}{2} \\right) = \\frac{\\nu g_0^2 \\tau_s}{2} $$\n\n所求的四个量是：\n- 平均电流: $\\langle I \\rangle = \\nu J \\tau_s$\n- 电流方差: $\\mathrm{Var}(I) = \\frac{\\nu J^2 \\tau_s}{2}$\n- 平均电导: $\\langle g \\rangle = \\nu g_0 \\tau_s$\n- 电导方差: $\\mathrm{Var}(g) = \\frac{\\nu g_0^2 \\tau_s}{2}$\n\n最终答案将以一个行矩阵的形式呈现，其中包含这四个值并按顺序排列。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\nu J \\tau_s  \\frac{\\nu J^2 \\tau_s}{2}  \\nu g_0 \\tau_s  \\frac{\\nu g_0^2 \\tau_s}{2}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "平均场理论中的一个关键简化是扩散近似，它将离散的突触脉冲轰击处理为连续的、波动的输入（高斯噪声）。本练习让您能够深入探究这一假设的“幕后原理”。通过推导前几个克莱默-莫亚尔 (Kramers-Moyal) 系数，您将量化此近似的误差，并理解其成立的条件——特别是高输入率——从而为使用基于扩散的方法奠定坚实基础。",
            "id": "4051248",
            "problem": "考虑一个单室神经元，它接收大量统计独立的突触输入，这些输入可以汇集成一个速率为 $\\nu$ 的均匀泊松点过程 (PPP)。每个突触前脉冲会引起一个幅度为 $J$ 的突触后电流跃变，随后是随突触时间常数 $\\tau_s$ 的指数衰减。总突触电流 $I(t)$ 服从线性散粒噪声动力学\n$$\n\\frac{d I(t)}{dt} \\;=\\; -\\frac{I(t)}{\\tau_s} \\;+\\; J \\sum_k \\delta\\!\\left(t-t_k\\right),\n$$\n其中 $\\{t_k\\}$ 是泊松事件时间。等价地，相对于 PPP 的计数过程 $N_t$ 的微分形式为\n$$\ndI(t) \\;=\\; -\\frac{I(t)}{\\tau_s}\\,dt \\;+\\; J\\,dN_t,\n$$\n其中 $\\mathbb{E}[dN_t] = \\nu\\,dt$。\n\n从 Kramers–Moyal 展开 (KME) 的定义出发，$n$ 阶 Kramers–Moyal 系数 $a_n(I)$ 为\n$$\na_n(I) \\;=\\; \\lim_{dt\\to 0} \\frac{1}{dt}\\,\\mathbb{E}\\!\\left[ \\big(\\Delta I\\big)^{n} \\,\\big|\\, I(t)=I \\right],\n$$\n其中 $\\Delta I \\equiv I(t+dt)-I(t)$。\n\n1) 仅使用上述动力学和均匀泊松过程在无穷小区间内的性质，推导前三个 Kramers–Moyal 系数 $a_1(I)$、$a_2(I)$ 和 $a_3(I)$。\n\n2) 在稳态下，突触电流可以表示为线性叠加\n$$\nI(t) \\;=\\; \\sum_{t_k  t} J \\exp\\!\\left(-\\frac{t-t_k}{\\tau_s}\\right).\n$$\n使用泊松散粒噪声的已知结论，计算 $I(t)$ 的前三个等时累积量 $\\kappa_1$、$\\kappa_2$ 和 $\\kappa_3$。\n\n3) 扩散近似忽略了三阶及更高阶的 Kramers–Moyal 项，因此一个误差指标是标准化三阶累积量（偏度大小）\n$$\n\\gamma \\;\\equiv\\; \\frac{|\\kappa_3|}{\\kappa_2^{3/2}}.\n$$\n将 $\\gamma$ 表示为以 $J$、$\\nu$ 和 $\\tau_s$ 为变量的闭式解析表达式。以单一符号表达式的形式提供最终答案。无需进行数值计算或四舍五入，且最终表达式中不应包含单位。",
            "solution": "我们从随机微分形式开始\n$$\ndI(t) \\;=\\; -\\frac{I(t)}{\\tau_s}\\,dt \\;+\\; J\\,dN_t,\n$$\n其中 $N_t$ 是速率为 $\\nu$ 的均匀泊松点过程 (PPP) 的计数过程。在无穷小区间 $[t,t+dt)$ 上，增量为\n$$\n\\Delta I \\;=\\; -\\frac{I}{\\tau_s}\\,dt \\;+\\; J\\,\\Delta N,\n$$\n其中 $\\Delta N \\equiv N_{t+dt}-N_t$。对于均匀 PPP，$\\Delta N$ 的分布为 $\\mathbb{P}(\\Delta N=1)=\\nu\\,dt + o(dt)$，$\\mathbb{P}(\\Delta N=0)=1-\\nu\\,dt+o(dt)$，以及 $\\mathbb{P}(\\Delta N \\ge 2)=o(dt)$。\n\n1) 计算前三个 Kramers–Moyal 系数。\n\n根据定义，\n$$\na_n(I) \\;=\\; \\lim_{dt\\to 0}\\frac{1}{dt}\\,\\mathbb{E}\\!\\left[ \\big(\\Delta I\\big)^n \\,\\big|\\, I(t)=I \\right].\n$$\n我们计算这些量，保留到 $O(dt)$ 项。\n\n当 $n=1$ 时，\n$$\n\\mathbb{E}[\\Delta I \\mid I] \\;=\\; -\\frac{I}{\\tau_s}\\,dt \\;+\\; J\\,\\mathbb{E}[\\Delta N] \\;=\\; -\\frac{I}{\\tau_s}\\,dt \\;+\\; J\\,\\nu\\,dt,\n$$\n因此\n$$\na_1(I) \\;=\\; -\\frac{I}{\\tau_s} \\;+\\; J\\,\\nu.\n$$\n\n当 $n=2$ 时，展开 $\\Delta I = -\\frac{I}{\\tau_s}dt + J \\Delta N$。涉及 $dt$ 和 $\\Delta N$ 的乘积项在期望上为 $O(dt^2)$，在主阶上可以忽略。$O(dt)$ 的贡献来自于 $(J\\Delta N)^2$，因为在 $dt\\to 0$ 的极限下，$(dt)^2$ 项会消失。由于在 $O(dt)$ 的精度下，对于 $\\Delta N \\in \\{0,1\\}$，有 $\\Delta N^2 = \\Delta N$，\n$$\n\\mathbb{E}\\!\\left[(\\Delta I)^2 \\mid I\\right] \\;=\\; J^2\\,\\mathbb{E}[\\Delta N] \\;+\\; o(dt) \\;=\\; J^2 \\nu\\,dt \\;+\\; o(dt),\n$$\n所以\n$$\na_2(I) \\;=\\; J^2 \\nu.\n$$\n\n当 $n=3$ 时，同理，主阶 $O(dt)$ 的贡献是 $(J\\Delta N)^3$，并且由于在 $O(dt)$ 的精度下，对于 $\\Delta N\\in\\{0,1\\}$，有 $\\Delta N^3=\\Delta N$，\n$$\n\\mathbb{E}\\!\\left[(\\Delta I)^3 \\mid I\\right] \\;=\\; J^3\\,\\mathbb{E}[\\Delta N] \\;+\\; o(dt) \\;=\\; J^3 \\nu\\,dt \\;+\\; o(dt),\n$$\n所以\n$$\na_3(I) \\;=\\; J^3 \\nu.\n$$\n\n因此，到三阶为止，\n$$\na_1(I) \\;=\\; -\\frac{I}{\\tau_s} + J\\nu,\\qquad a_2(I) \\;=\\; J^2 \\nu,\\qquad a_3(I) \\;=\\; J^3 \\nu.\n$$\n\n2) $I(t)$ 的稳态等时累积量。\n\n在稳态下，$I(t)$ 可以写成一个泊松散粒噪声\n$$\nI(t) \\;=\\; \\sum_{t_k  t} h(t-t_k),\\qquad h(s) \\;=\\; J \\exp\\!\\left(-\\frac{s}{\\tau_s}\\right)\\,\\mathbf{1}_{\\{s\\ge 0\\}}.\n$$\n对于一个速率为 $\\nu$ 且具有确定性核 $h$ 的均匀 PPP，$I(t)$ 的 $n$ 阶等时累积量 $\\kappa_n$ 由经过充分检验的泊松散粒噪声累积量的 Campbell 定理给出：\n$$\n\\kappa_n \\;=\\; \\nu \\int_{0}^{\\infty} \\big(h(s)\\big)^n\\,ds.\n$$\n对于指数核，\n$$\n\\int_{0}^{\\infty} \\big(h(s)\\big)^n\\,ds \\;=\\; \\int_{0}^{\\infty} J^n \\exp\\!\\left(-\\frac{n s}{\\tau_s}\\right)\\,ds \\;=\\; J^n \\frac{\\tau_s}{n}.\n$$\n因此，\n$$\n\\kappa_n \\;=\\; \\nu\\,J^n\\,\\frac{\\tau_s}{n}.\n$$\n特别地，\n$$\n\\kappa_1 \\;=\\; \\nu J \\tau_s,\\qquad \\kappa_2 \\;=\\; \\nu J^2 \\frac{\\tau_s}{2},\\qquad \\kappa_3 \\;=\\; \\nu J^3 \\frac{\\tau_s}{3}.\n$$\n\n3) 作为误差指标的标准化三阶累积量（偏度大小）。\n\n定义\n$$\n\\gamma \\;\\equiv\\; \\frac{|\\kappa_3|}{\\kappa_2^{3/2}}.\n$$\n代入上述表达式，\n$$\n\\gamma \\;=\\; \\frac{\\left|\\nu J^3 \\frac{\\tau_s}{3}\\right|}{\\left(\\nu J^2 \\frac{\\tau_s}{2}\\right)^{3/2}}\n\\;=\\; \\frac{|J|^3 \\nu \\tau_s / 3}{|J|^3 (\\nu \\tau_s)^{3/2} / 2^{3/2}}\n\\;=\\; \\frac{2^{3/2}}{3}\\,\\frac{1}{\\sqrt{\\nu \\tau_s}}.\n$$\n因此，基于三阶累积量微小性的扩散近似误差指标为\n$$\n\\gamma \\;=\\; \\frac{2^{3/2}}{3}\\,(\\nu \\tau_s)^{-1/2}.\n$$\n值得注意的是，在标准化度量中，对 $J$ 的依赖性被消除了；只有乘积 $\\nu \\tau_s$ 控制其大小，较大的 $\\nu \\tau_s$ 会产生较小的偏度，因此得到更好的扩散近似。",
            "answer": "$$\\boxed{\\frac{2^{3/2}}{3}\\,(\\nu\\,\\tau_s)^{-1/2}}$$"
        },
        {
            "introduction": "最后的这个练习将所有概念整合起来，用于分析一个由兴奋性和抑制性群体组成的相互作用网络。您将构建定义网络稳态的自洽方程，在该状态下，神经元群体的发放率所产生的突触输入反过来又维持了同样的发放率。通过数值求解这个不动点，您将能预测大规模神经回路的稳定活动模式，这也是平均场理论的最终目标之一。",
            "id": "3996524",
            "problem": "考虑一个由兴奋性神经元（标记为 $e$）和抑制性神经元（标记为 $i$）组成的大型、随机连接的双种群脉冲神经元网络。每个神经元从种群 $q \\in \\{e,i\\}$ 接收 $K_{pq}$ 个突触前连接，来自种群 $q$ 的每个突触前脉冲会在种群 $p \\in \\{e,i\\}$ 中一个神经元的突触后膜电位上产生一个幅度为 $J_{pq}$ 的瞬时跳变。假设网络在高入度极限下运行，因此传入的脉冲序列可以近似为独立的泊松过程，并且对神经元的总突触输入可以采用扩散近似进行处理。\n\n从适用于突触散粒噪声的扩散近似以及带有加性高斯白噪声的渗漏整合-发放（LIF）模型的第一性原理出发：\n\n- 突触散粒噪声被近似为一个高斯过程，其特征在于漂移（均值）和扩散（方差）是突触前发放率的线性函数。\n- 膜电位根据LIF动力学演化，膜时间常数为 $\\tau_m$，绝对不应期为 $\\tau_{\\mathrm{ref}}$。阈值和重置电位分别表示为 $V_{\\theta,p}$ 和 $V_{r}$。我们假设 $V_{r}$ 在各种群间共享，并且所有电压量都以相对于阈值尺度归一化的单位表示，因此跳变幅度 $J_{pq}$ 在这些单位中是无量纲的。\n- 在大 $K_{pq}$ 的扩散极限下，对于速率为 $\\nu_e$ 和 $\\nu_i$ 的突触前泊松输入，种群 $p$ 的有效漂移和扩散为\n$$\n\\mu_p(\\nu_e,\\nu_i) \\;=\\; \\mu_{0,p} \\;+\\; K_{pe}\\,J_{pe}\\,\\nu_e \\;+\\; K_{pi}\\,J_{pi}\\,\\nu_i,\n$$\n$$\n\\sigma_p^2(\\nu_e,\\nu_i) \\;=\\; \\sigma_{0,p}^2 \\;+\\; K_{pe}\\,J_{pe}^2\\,\\nu_e \\;+\\; K_{pi}\\,J_{pi}^2\\,\\nu_i,\n$$\n其中 $(\\mu_{0,p},\\sigma_{0,p})$ 表示独立于网络活动的外部基线均值和标准差贡献。\n\n- 在带有加性白噪声的LIF模型下，种群 $p$ 的单神经元传递函数由 Siegert 公式给出：\n$$\n\\nu_p \\;=\\; \\left[ \\tau_{\\mathrm{ref}} \\;+\\; \\tau_m \\,\\sqrt{\\pi}\\;\\int_{u_{r,p}}^{u_{\\theta,p}} \\exp(u^2)\\,\\bigl(1+\\mathrm{erf}(u)\\bigr)\\,du \\right]^{-1},\n$$\n其中 $u_{r,p} = \\dfrac{V_r - \\mu_p}{\\sigma_p}$ 和 $u_{\\theta,p} = \\dfrac{V_{\\theta,p} - \\mu_p}{\\sigma_p}$，并且 $\\mathrm{erf}(\\cdot)$ 表示误差函数。为保证数值稳定性，请注意 $\\exp(u^2)\\bigl(1+\\mathrm{erf}(u)\\bigr) = \\mathrm{erfcx}(-u)$，其中 $\\mathrm{erfcx}$ 是缩放互补误差函数。\n\n你的任务是：\n1. 通过组合 $\\mu_p(\\nu_e,\\nu_i)$、$\\sigma_p(\\nu_e,\\nu_i)$ 的表达式以及单神经元传递函数 $\\nu_p = F_p\\bigl(\\mu_p(\\nu_e,\\nu_i),\\sigma_p(\\nu_e,\\nu_i)\\bigr)$ (对于 $p \\in \\{e,i\\}$)，推导出定义不动点发放率 $(\\nu_e,\\nu_i)$ 的自洽平均场方程。\n2. 实现一个程序，使用鲁棒的数值方法求解得到的关于 $(\\nu_e,\\nu_i)$ 的二维不动点问题。\n3. 使用以下参数集测试套件。在所有情况下，$\\tau_m$ 和 $\\tau_{\\mathrm{ref}}$ 以秒为单位，发放率以赫兹（每秒脉冲数）报告。与电压相关的量如上所述，在阈值归一化单位下是无量纲的。\n\n测试用例 A（平衡状态）：\n- $\\tau_m = 0.02$, $\\tau_{\\mathrm{ref}} = 0.002$, $V_r = 0$, $V_{\\theta,e} = 1.0$, $V_{\\theta,i} = 1.0$.\n- $K_{ee} = 800$, $K_{ei} = 200$, $K_{ie} = 800$, $K_{ii} = 200$.\n- $J_{ee} = 0.001$, $J_{ei} = -0.004$, $J_{ie} = 0.001$, $J_{ii} = -0.004$.\n- $\\mu_{0,e} = 0.6$, $\\sigma_{0,e} = 0.3$, $\\mu_{0,i} = 0.6$, $\\sigma_{0,i} = 0.3$.\n\n测试用例 B（弱抑制，较高活动）：\n- 与 A 相同，除了 $J_{ei} = -0.001$, $J_{ii} = -0.001$。\n\n测试用例 C（强抑制，低基线；接近静息的边缘情况）：\n- $\\tau_m = 0.02$, $\\tau_{\\mathrm{ref}} = 0.002$, $V_r = 0$, $V_{\\theta,e} = 1.0$, $V_{\\theta,i} = 1.0$.\n- $K_{ee} = 800$, $K_{ei} = 200$, $K_{ie} = 800$, $K_{ii} = 200$.\n- $J_{ee} = 0.001$, $J_{ei} = -0.008$, $J_{ie} = 0.001$, $J_{ii} = -0.008$.\n- $\\mu_{0,e} = 0.3$, $\\sigma_{0,e} = 0.15$, $\\mu_{0,i} = 0.3$, $\\sigma_{0,i} = 0.15$.\n\n算法要求：\n- 从提供的组件构建不动点方程，不要引入绕过基本定义的简化。\n- 使用一种包含回退策略的方法求解 $(\\nu_e,\\nu_i)$，以防通用求根器无法收敛。\n- 在适当时使用缩放互补误差函数，以确保定义传递函数的积分的数值稳定性。\n\n输出规范：\n- 你的程序应生成单行输出，包含一个以逗号分隔的 Python 风格列表的列表，每个测试用例一个，按 A、B、C 的顺序排列。\n- 每个内部列表必须是两个浮点数 $[\\nu_e,\\nu_i]$，单位为赫兹，四舍五入到三位小数。\n- 例如，输出格式必须严格为 $[[\\nu_{e,A},\\nu_{i,A}],[\\nu_{e,B},\\nu_{i,B}],[\\nu_{e,C},\\nu_{i,C}]]$ 的形式，位于单行，无额外文本。",
            "solution": "用户提供了一个计算神经科学问题，要求推导并数值求解一个双种群脉冲神经元网络的平均场方程。\n\n### 问题验证\n\n该问题根据指定标准进行评估：\n1.  **给定条件**：明确提供了在扩散近似下双种群渗漏整合-发放（LIF）网络的所有参数、方程和边界条件。这包括平均突触输入（$\\mu_p$）、输入方差（$\\sigma_p^2$）以及通过 Siegert 公式的单神经元传递函数（$\\nu_p = F_p(\\mu_p, \\sigma_p)$）的表达式。提供了三个特定的参数集用于测试。\n2.  **科学基础**：该问题在根本上是合理的。突触电流的扩散近似、LIF 神经元模型以及用于首次穿越时间的 Siegert 公式都是计算神经科学中平均场理论的经典组成部分。该设置是一个标准的、成熟的理论模型。\n3.  **适定性与客观性**：问题在于求解一个非线性方程组的不动点。这是一个明确定义的数学任务。问题陈述是客观的，使用了精确、标准的术语。它通过要求使用鲁棒的求解方法正确预见了数值挑战，表明其结构经过深思熟虑。所提供的参数和方程是自洽、一致且足以进行求解的。\n\n该问题被认定为**有效**。我们可以继续进行求解。\n\n### 第1部分：自洽平均场方程的推导\n\n网络在不动点的状态由兴奋性和抑制性种群的稳态发放率 $(\\nu_e, \\nu_i)$ 描述。一个自洽解是指，当这些发放率反馈回网络时，能产生完全相同的发放率。这构成了网络动力学映射的一个不动点。\n\n令种群 $p \\in \\{e,i\\}$ 的传递函数表示为 $F_p$。该函数根据总突触输入的均值 $\\mu_p$ 和标准差 $\\sigma_p$ 计算输出发放率 $\\nu_p$。\n$$\n\\nu_p = F_p(\\mu_p, \\sigma_p)\n$$\n函数 $F_p$ 由 Siegert 公式给出：\n$$\nF_p(\\mu_p, \\sigma_p) = \\left[ \\tau_{\\mathrm{ref}} + \\tau_m \\sqrt{\\pi} \\int_{u_{r,p}}^{u_{\\theta,p}} \\exp(u^2)\\bigl(1+\\mathrm{erf}(u)\\bigr)\\,du \\right]^{-1}\n$$\n其中积分限是输入统计量的函数：\n$$\nu_{r,p} = \\frac{V_r - \\mu_p}{\\sigma_p}, \\quad u_{\\theta,p} = \\frac{V_{\\theta,p} - \\mu_p}{\\sigma_p}\n$$\n反过来，输入统计量 $\\mu_p$ 和 $\\sigma_p$ 本身也是网络发放率 $(\\nu_e, \\nu_i)$ 的函数，由扩散近似指定：\n$$\n\\mu_p(\\nu_e, \\nu_i) = \\mu_{0,p} + K_{pe} J_{pe} \\nu_e + K_{pi} J_{pi} \\nu_i\n$$\n$$\n\\sigma_p(\\nu_e, \\nu_i) = \\sqrt{\\sigma_{0,p}^2 + K_{pe} J_{pe}^2 \\nu_e + K_{pi} J_{pi}^2 \\nu_i}\n$$\n通过要求输出率与产生它们的输入率相匹配，可以得到自洽平均场方程。这是通过将 $\\mu_p(\\nu_e, \\nu_i)$ 和 $\\sigma_p(\\nu_e, \\nu_i)$ 的表达式代入传递函数实现的，从而得到一个关于两个未知率 $\\nu_e$ 和 $\\nu_i$ 的耦合非线性方程组：\n$$\n\\begin{cases}\n\\nu_e = F_e\\Big(\\mu_e(\\nu_e, \\nu_i), \\sigma_e(\\nu_e, \\nu_i)\\Big) \\\\\n\\nu_i = F_i\\Big(\\mu_i(\\nu_e, \\nu_i), \\sigma_i(\\nu_e, \\nu_i)\\Big)\n\\end{cases}\n$$\n这些方程定义了系统的不动点。一个解 $(\\nu_e^*, \\nu_i^*)$ 代表了网络在平均场极限下的稳定（或不稳定）发放率。\n\n### 第2和3部分：数值实现与求解\n\n为了求解该系统，我们寻求向量函数 $\\mathbf{G}(\\boldsymbol{\\nu}) = \\mathbf{F}(\\boldsymbol{\\nu}) - \\boldsymbol{\\nu} = \\mathbf{0}$ 的根，其中 $\\boldsymbol{\\nu} = (\\nu_e, \\nu_i)^T$，$\\mathbf{F}(\\boldsymbol{\\nu})$ 是传递函数的向量。\n\n**数值方法：**\n1.  **传递函数**：Siegert 公式中的积分使用 `scipy.integrate.quad`进行数值计算。为保证数值稳定性，被积函数 $\\exp(u^2)(1+\\mathrm{erf}(u))$ 按建议替换为缩放互补误差函数 $\\mathrm{erfcx}(-u)$。这可以避免当 $u$ 为大的正值时（可能在神经元远离其阈值时发生）出现浮点溢出。\n2.  **求根**：我们将使用 `scipy.optimize.root` 及其 `hybr` 方法，这是一种用于求解非线性系统根的鲁棒算法。通过仅基于外部输入 $(\\mu_{0,p}, \\sigma_{0,p})$ 计算发放率来生成初始猜测值。\n3.  **回退策略**：按照要求，在主求根器失败的情况下，实现了一种回退方法。使用一种阻尼不动点迭代方案：\n    $$\n    \\boldsymbol{\\nu}^{(k+1)} = (1-\\alpha)\\boldsymbol{\\nu}^{(k)} + \\alpha \\mathbf{F}(\\boldsymbol{\\nu}^{(k)})\n    $$\n    其中阻尼因子 $\\alpha  0$ 很小。这种迭代方法对于此类问题通常是稳定的，尽管其收敛速度可能比基于梯度的方法慢。物理上，发放率必须为非负值，即 $\\nu_p \\ge 0$。传递函数 $F_p$ 内在地产生正值，因此不动点迭代保留了此约束。主求解器的解也会检查其正性。\n\n以下 Python 代码实现了此策略，用于求解给定三个测试用例的不动点发放率。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfcx, erf\nfrom scipy.integrate import quad\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Solves the mean-field equations for a two-population spiking network for three test cases.\n    \"\"\"\n\n    def transfer_function(mu, sigma, V_theta, V_r, tau_m, tau_ref):\n        \"\"\"\n        Calculates the firing rate of an LIF neuron given input statistics using the Siegert formula.\n        \n        This is the function F_p(mu_p, sigma_p). The numerically stable form of the integrand is used.\n        \"\"\"\n        # Handle the near-deterministic case where sigma is very small to avoid division by zero.\n        # The diffusion approximation is not valid for sigma -> 0, but this provides numerical stability.\n        if sigma  1e-9:\n            if mu > V_theta:\n                # In the deterministic limit, firing occurs if mu is above threshold.\n                # The inter-spike interval is the time to drift from V_r to V_theta.\n                # This check prevents log(negative) if mu  V_r.\n                if mu > V_r:\n                    t_isi = tau_ref + tau_m * np.log((mu - V_r) / (mu - V_theta))\n                    return 1.0 / t_isi if t_isi > 1e-9 else 1e9\n                else:\n                    return 0.0 # mu is between V_r and V_theta, so it never reaches threshold.\n            else:\n                return 0.0 # Subthreshold drive.\n\n        # Calculate normalized voltage bounds for the integral\n        u_r = (V_r - mu) / sigma\n        u_theta = (V_theta - mu) / sigma\n        \n        # The problem defines the integral of exp(u^2)*(1+erf(u)), which is numerically\n        # unstable. The hint is to use erfcx(-u).\n        # integrand = lambda u: np.exp(u**2) * (1 + erf(u)) is equivalent to\n        integrand = lambda u: erfcx(-u)\n\n        # The integral is guaranteed to be positive as erfcx(-u) > 0 for all u, and u_theta > u_r.\n        integral_val, _ = quad(integrand, u_r, u_theta)\n\n        # Calculate the mean inter-spike interval\n        tau_isi = tau_ref + tau_m * np.sqrt(np.pi) * integral_val\n\n        # Firing rate is the inverse of the mean ISI.\n        # tau_isi is guaranteed to be positive.\n        return 1.0 / tau_isi\n\n    def fixed_point_system(nu, params_case):\n        \"\"\"\n        Calculates the new firing rates F(nu) based on the current rates nu.\n        \n        Args:\n            nu (array-like): A list or array [nu_e, nu_i] of current firing rates in Hz.\n            params_case (dict): Dictionary containing all parameters for the network.\n        \n        Returns:\n            np.array: A numpy array [nu_e_new, nu_i_new] of calculated firing rates.\n        \"\"\"\n        nu_e, nu_i = max(0, nu[0]), max(0, nu[1]) # Rates must be non-negative\n\n        p_e = params_case['e']\n        p_i = params_case['i']\n\n        # Calculate input mean (drift) for each population\n        mu_e = p_e['mu0'] + p_e['K_ee'] * p_e['J_ee'] * nu_e + p_e['K_ei'] * p_e['J_ei'] * nu_i\n        mu_i = p_i['mu0'] + p_i['K_ie'] * p_i['J_ie'] * nu_e + p_i['K_ii'] * p_i['J_ii'] * nu_i\n        \n        # Calculate input variance (diffusion^2) for each population\n        sigma2_e = p_e['sigma0']**2 + p_e['K_ee'] * p_e['J_ee']**2 * nu_e + p_e['K_ei'] * p_e['J_ei']**2 * nu_i\n        sigma2_i = p_i['sigma0']**2 + p_i['K_ie'] * p_i['J_ie']**2 * nu_e + p_i['K_ii'] * p_i['J_ii']**2 * nu_i\n\n        # Variances must be non-negative. A small floor ensures this.\n        sigma_e = np.sqrt(max(1e-12, sigma2_e))\n        sigma_i = np.sqrt(max(1e-12, sigma2_i))\n\n        # Calculate the new firing rates using the transfer functions\n        nu_e_new = transfer_function(mu_e, sigma_e, p_e['V_theta'], p_e['V_r'], p_e['tau_m'], p_e['tau_ref'])\n        nu_i_new = transfer_function(mu_i, sigma_i, p_i['V_theta'], p_i['V_r'], p_i['tau_m'], p_i['tau_ref'])\n\n        return np.array([nu_e_new, nu_i_new])\n\n    def objective_function(nu, params_case):\n        \"\"\"Objective function for the root finder: G(nu) = F(nu) - nu.\"\"\"\n        return fixed_point_system(nu, params_case) - nu\n\n    def solve_for_case(params_case):\n        \"\"\"\n        Solves the fixed-point problem for a single parameter set.\n        Uses a primary root-finder and a fallback iterative method.\n        \"\"\"\n        # --- Initial Guess ---\n        # Calculate rates based on external input only\n        p_e = params_case['e']\n        p_i = params_case['i']\n        nu_e_0 = transfer_function(p_e['mu0'], p_e['sigma0'], p_e['V_theta'], p_e['V_r'], p_e['tau_m'], p_e['tau_ref'])\n        nu_i_0 = transfer_function(p_i['mu0'], p_i['sigma0'], p_i['V_theta'], p_i['V_r'], p_i['tau_m'], p_i['tau_ref'])\n        initial_guess = np.array([nu_e_0, nu_i_0])\n\n        # --- Primary Solver: scipy.optimize.root ---\n        sol = root(objective_function, initial_guess, args=(params_case,), method='hybr', tol=1e-9)\n\n        if sol.success and np.all(sol.x >= 0):\n            return sol.x\n        \n        # --- Fallback Solver: Damped Fixed-Point Iteration ---\n        nu_k = initial_guess\n        max_iter = 1000\n        tolerance = 1e-9\n        alpha = 0.1  # Damping factor for stability\n        for _ in range(max_iter):\n            nu_k_plus_1 = fixed_point_system(nu_k, params_case)\n            change = np.linalg.norm(nu_k_plus_1 - nu_k)\n            nu_k = (1 - alpha) * nu_k + alpha * nu_k_plus_1\n            if change  tolerance:\n                return nu_k\n        \n        # If the primary solver failed but the fallback also failed to converge,\n        # return the result of the primary solver as a last resort, as it might be close.\n        return sol.x\n    \n    # Define test cases from the problem statement.\n    test_cases_params = [\n        # Test Case A: Balanced regime\n        {\n            'e': {'tau_m': 0.02, 'tau_ref': 0.002, 'V_r': 0.0, 'V_theta': 1.0, 'K_ee': 800, 'K_ei': 200, 'J_ee': 0.001, 'J_ei': -0.004, 'mu0': 0.6, 'sigma0': 0.3},\n            'i': {'tau_m': 0.02, 'tau_ref': 0.002, 'V_r': 0.0, 'V_theta': 1.0, 'K_ie': 800, 'K_ii': 200, 'J_ie': 0.001, 'J_ii': -0.004, 'mu0': 0.6, 'sigma0': 0.3}\n        },\n        # Test Case B: Weak inhibition\n        {\n            'e': {'tau_m': 0.02, 'tau_ref': 0.002, 'V_r': 0.0, 'V_theta': 1.0, 'K_ee': 800, 'K_ei': 200, 'J_ee': 0.001, 'J_ei': -0.001, 'mu0': 0.6, 'sigma0': 0.3},\n            'i': {'tau_m': 0.02, 'tau_ref': 0.002, 'V_r': 0.0, 'V_theta': 1.0, 'K_ie': 800, 'K_ii': 200, 'J_ie': 0.001, 'J_ii': -0.001, 'mu0': 0.6, 'sigma0': 0.3}\n        },\n        # Test Case C: Strong inhibition, low baseline\n        {\n            'e': {'tau_m': 0.02, 'tau_ref': 0.002, 'V_r': 0.0, 'V_theta': 1.0, 'K_ee': 800, 'K_ei': 200, 'J_ee': 0.001, 'J_ei': -0.008, 'mu0': 0.3, 'sigma0': 0.15},\n            'i': {'tau_m': 0.02, 'tau_ref': 0.002, 'V_r': 0.0, 'V_theta': 1.0, 'K_ie': 800, 'K_ii': 200, 'J_ie': 0.001, 'J_ii': -0.008, 'mu0': 0.3, 'sigma0': 0.15}\n        }\n    ]\n\n    results = []\n    for params in test_cases_params:\n        solution = solve_for_case(params)\n        results.append(solution)\n\n    # Format the final output string exactly as specified.\n    # Each inner list is [nu_e, nu_i], rounded to three decimal places.\n    # The final string is a list of these lists, with no extra spaces.\n    formatted_results = [f\"[{res[0]:.3f},{res[1]:.3f}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}