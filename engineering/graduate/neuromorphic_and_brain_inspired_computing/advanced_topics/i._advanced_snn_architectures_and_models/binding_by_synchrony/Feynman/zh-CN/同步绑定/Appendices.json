{
    "hands_on_practices": [
        {
            "introduction": "在我们理解同步如何“绑定”信息之前，我们必须首先掌握同步本身是如何产生的。本练习将探讨两个振荡器即使在具有不同固有频率的情况下也能实现锁相的基本条件。通过从第一性原理推导它们的相位差动力学，您将揭示控制同步的关键因素——耦合强度与频率失配之间的关系 。",
            "id": "4037645",
            "problem": "两个弱耦合的神经形态振荡器代表了两个特征编码集合，它们的绑定通过相位同步实现。设这两个集合的相位分别为 $\\,\\theta_{1}(t)\\,$ 和 $\\,\\theta_{2}(t)\\,$，其内禀角频率分别为 $\\,\\omega_{1}\\,$ 和 $\\,\\omega_{2} = \\omega_{1} + \\Delta\\omega\\,$。假设耦合足够弱，以至于相位约化和平均理论适用：每个振荡器的相位遵循\n$$\n\\frac{d\\theta_{i}}{dt} = \\omega_{i} + \\epsilon\\,Z(\\theta_{i})\\,I(\\theta_{j}), \\quad i\\neq j,\n$$\n其中 $\\,\\epsilon>0\\,$ 是一个小耦合参数，$\\,Z(\\theta)\\,$ 是周期为 $2\\pi$ 的无穷小相位响应曲线（PRC），而 $\\,I(\\theta)\\,$ 是由另一个振荡器状态引起的周期为 $2\\pi$ 的相互作用波形。考虑一个生物学上合理的II型PRC和一个由一阶傅里叶谐波主导的兴奋性相互作用，其模型为\n$$\nZ(\\theta) = \\cos\\theta, \\qquad I(\\theta) = \\sin\\theta.\n$$\n定义相位差 $\\,\\phi(t) = \\theta_{2}(t) - \\theta_{1}(t)\\,$。在一个周期上使用平均理论，精确到 $\\,\\epsilon\\,$ 的主导阶，推导 $\\,\\phi(t)\\,$ 的慢动力学，并获得相位锁定发生的条件，该条件是 $\\,\\Delta\\omega\\,$ 和有效耦合强度的函数。然后，对于 $\\,\\Delta\\omega>0\\,$ 和正有效耦合 $\\,K>0\\,$ 的情况，以闭合形式计算稳定的锁相差 $\\,\\phi^{\\ast}\\,$。用弧度表示 $\\,\\phi^{\\ast}\\,$。最终答案必须仅为 $\\,\\phi^{\\ast}\\,$ 的解析表达式。",
            "solution": "题目给出了一个由两个弱耦合神经形态振荡器组成的系统，其相位 $\\theta_{1}(t)$ 和 $\\theta_{2}(t)$ 由以下微分方程决定：\n$$\n\\frac{d\\theta_{i}}{dt} = \\omega_{i} + \\epsilon\\,Z(\\theta_{i})\\,I(\\theta_{j}), \\quad i,j \\in \\{1,2\\}, i\\neq j\n$$\n内禀角频率给定为 $\\omega_{1}$ 和 $\\omega_{2} = \\omega_{1} + \\Delta\\omega$。耦合强度 $\\epsilon$ 是一个小的正参数，$\\epsilon > 0$。相位响应曲线（PRC）为 $Z(\\theta) = \\cos\\theta$，相互作用函数为 $I(\\theta) = \\sin\\theta$。\n\n首先，我们写出两个振荡器的显式方程：\n$$\n\\frac{d\\theta_{1}}{dt} = \\omega_{1} + \\epsilon\\,Z(\\theta_{1})\\,I(\\theta_{2}) = \\omega_{1} + \\epsilon\\,\\cos(\\theta_{1})\\,\\sin(\\theta_{2})\n$$\n$$\n\\frac{d\\theta_{2}}{dt} = \\omega_{2} + \\epsilon\\,Z(\\theta_{2})\\,I(\\theta_{1}) = \\omega_{2} + \\epsilon\\,\\cos(\\theta_{2})\\,\\sin(\\theta_{1})\n$$\n\n我们关心的是相位差 $\\phi(t) = \\theta_{2}(t) - \\theta_{1}(t)$ 的动力学。我们通过对其求时间导数来找到 $\\phi(t)$ 的微分方程：\n$$\n\\frac{d\\phi}{dt} = \\frac{d\\theta_{2}}{dt} - \\frac{d\\theta_{1}}{dt}\n$$\n代入 $\\frac{d\\theta_{1}}{dt}$ 和 $\\frac{d\\theta_{2}}{dt}$ 的表达式：\n$$\n\\frac{d\\phi}{dt} = \\left(\\omega_{2} + \\epsilon\\,\\cos(\\theta_{2})\\,\\sin(\\theta_{1})\\right) - \\left(\\omega_{1} + \\epsilon\\,\\cos(\\theta_{1})\\,\\sin(\\theta_{2})\\right)\n$$\n按 $\\omega$ 和 $\\epsilon$ 对各项进行分组：\n$$\n\\frac{d\\phi}{dt} = (\\omega_{2} - \\omega_{1}) + \\epsilon \\left( \\cos(\\theta_{2})\\,\\sin(\\theta_{1}) - \\cos(\\theta_{1})\\,\\sin(\\theta_{2}) \\right)\n$$\n使用定义 $\\Delta\\omega = \\omega_{2} - \\omega_{1}$ 和差角的正弦三角恒等式 $\\sin(A-B) = \\sin(A)\\cos(B) - \\cos(A)\\sin(B)$：\n$$\n\\frac{d\\phi}{dt} = \\Delta\\omega + \\epsilon \\sin(\\theta_{1} - \\theta_{2})\n$$\n因为 $\\phi = \\theta_{2} - \\theta_{1}$，所以有 $\\theta_{1} - \\theta_{2} = -\\phi$。因此：\n$$\n\\frac{d\\phi}{dt} = \\Delta\\omega + \\epsilon \\sin(-\\phi) = \\Delta\\omega - \\epsilon \\sin(\\phi)\n$$\n\n该方程描述了相位差 $\\phi(t)$ 的精确动力学。在这个特殊情况下，由于PRC和相互作用函数是以一阶傅里叶谐波的形式给出的，相位差的动力学与各个相位完全解耦。按照题目要求，平均理论的应用对于更一般化的 $Z(\\theta)$ 和 $I(\\theta)$ 是形式上必需的，但在本例中，它会得到相同的结果。为了证明这一点，令耦合项为 $G(\\theta_1, \\theta_2) = Z(\\theta_2)I(\\theta_1) - Z(\\theta_1)I(\\theta_2)$。我们通过代入 $\\theta_2 = \\theta_1 + \\phi$，用一个相位（比如 $\\theta_1$）和相位差 $\\phi$ 来表示它：\n$$ G(\\theta_1, \\phi) = \\cos(\\theta_1+\\phi)\\sin(\\theta_1) - \\cos(\\theta_1)\\sin(\\theta_1+\\phi) = \\sin(\\theta_1 - (\\theta_1+\\phi)) = -\\sin(\\phi) $$\n平均理论指出，$\\phi$ 的慢动力学由耦合项对快变量 $\\theta_1$（在一个 $2\\pi$ 区间上）的平均所决定：\n$$ \\langle G(\\phi) \\rangle = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} G(\\theta, \\phi) d\\theta = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} (-\\sin(\\phi)) d\\theta $$\n由于 $-\\sin(\\phi)$ 相对于积分变量 $\\theta$ 是常数，因此平均值即为：\n$$ \\langle G(\\phi) \\rangle = -\\sin(\\phi) $$\n因此，$\\phi$ 的慢动力学的平均化方程为：\n$$\n\\frac{d\\phi}{dt} = \\Delta\\omega + \\epsilon \\langle G(\\phi) \\rangle = \\Delta\\omega - \\epsilon \\sin(\\phi)\n$$\n这证实了先前推导出的方程，该方程被称为阿德勒（Adler）方程。\n\n当相位差达到一个常数值 $\\phi^{\\ast}$ 时，就会发生相位锁定，这个值是动力学的一个稳定不动点。在一个不动点上，$\\frac{d\\phi}{dt} = 0$：\n$$\n\\Delta\\omega - \\epsilon \\sin(\\phi^{\\ast}) = 0 \\implies \\sin(\\phi^{\\ast}) = \\frac{\\Delta\\omega}{\\epsilon}\n$$\n为了使 $\\phi^{\\ast}$ 存在实数解，正弦函数的值必须在其值域 $[-1, 1]$ 内。这给出了相位锁定的条件：\n$$\n\\left| \\frac{\\Delta\\omega}{\\epsilon} \\right| \\le 1 \\implies |\\Delta\\omega| \\le \\epsilon\n$$\n量 $\\epsilon$ 代表了耦合对相位差动力学影响的强度，因此被确定为有效耦合强度。题目要求在最后一部分用 $K$ 来表示这个量。令 $K = \\epsilon$。由于 $\\epsilon > 0$，我们有 $K > 0$。相位锁定的条件是 $|\\Delta\\omega| \\le K$。\n\n为了找到稳定的锁相差，我们必须分析不动点的稳定性。对于方程 $\\frac{d\\phi}{dt} = f(\\phi)$，如果 $f'(\\phi^{\\ast})  0$，则其不动点 $\\phi^{\\ast}$ 是稳定的。这里，$f(\\phi) = \\Delta\\omega - K \\sin(\\phi)$。其导数为：\n$$\nf'(\\phi) = \\frac{d}{d\\phi} (\\Delta\\omega - K \\sin(\\phi)) = -K \\cos(\\phi)\n$$\n因此，稳定性条件是 $-K \\cos(\\phi^{\\ast})  0$。\n\n题目指明了条件 $\\Delta\\omega > 0$ 和 $K > 0$。在这些条件下：\n1.  从不动点方程可知，$\\sin(\\phi^{\\ast}) = \\frac{\\Delta\\omega}{K} > 0$。这意味着 $\\phi^{\\ast}$ 必须在第一或第二象限，即 $0  \\phi^{\\ast}  \\pi$。\n2.  从稳定性条件可知，由于 $K > 0$，我们需要 $-K \\cos(\\phi^{\\ast})  0$，这化简为 $\\cos(\\phi^{\\ast}) > 0$。这意味着 $\\phi^{\\ast}$ 必须在第一或第四象限。\n\n结合这两个要求，稳定的锁相状态 $\\phi^{\\ast}$ 必须位于第一象限，在该象限其正弦和余弦值均为正。方程 $\\sin(\\phi) = \\frac{\\Delta\\omega}{K}$ 在区间 $[0, 2\\pi)$ 上有两个解：\n- $\\phi_{1}^{\\ast} = \\arcsin\\left(\\frac{\\Delta\\omega}{K}\\right)$\n- $\\phi_{2}^{\\ast} = \\pi - \\arcsin\\left(\\frac{\\Delta\\omega}{K}\\right)$\n\n已知 $|\\frac{\\Delta\\omega}{K}| \\le 1$ 且 $\\frac{\\Delta\\omega}{K} > 0$，$\\arcsin\\left(\\frac{\\Delta\\omega}{K}\\right)$ 的值在区间 $(0, \\frac{\\pi}{2}]$ 内。\n- 对于第一个解 $\\phi_{1}^{\\ast}$，我们有 $0  \\phi_{1}^{\\ast} \\le \\frac{\\pi}{2}$。在此区间内，$\\cos(\\phi_{1}^{\\ast}) \\ge 0$。稳定性条件 $\\cos(\\phi^{\\ast})>0$ 得以满足（排除了稳定性为中性的边界情况 $|\\Delta\\omega|=K$）。这是稳定不动点。\n- 对于第二个解 $\\phi_{2}^{\\ast}$，我们有 $\\frac{\\pi}{2} \\le \\phi_{2}^{\\ast}  \\pi$。在此区间内，$\\cos(\\phi_{2}^{\\ast}) \\le 0$。稳定性条件 $\\cos(\\phi^{\\ast})>0$ 不被满足。这是不稳定不动点。\n\n因此，在给定条件下，唯一的稳定锁相差是 $\\phi^{\\ast} = \\arcsin\\left(\\frac{\\Delta\\omega}{K}\\right)$。",
            "answer": "$$\n\\boxed{\\arcsin\\left(\\frac{\\Delta\\omega}{K}\\right)}\n$$"
        },
        {
            "introduction": "在大脑中，信号在不同区域间的传递需要时间，这为维持精确同步带来了巨大挑战。本练习旨在解决这一关键问题，探讨发送神经元如何通过相位预测来预先补偿传导延迟。您将首先推导所需的相位超前量，然后编写程序来验证该策略能够实现功能上的零延迟绑定，从而将理论与实际应用联系起来 。",
            "id": "4037640",
            "problem": "要求您形式化、推导并实现一个延迟补偿机制，该机制通过在存在有限轴突传导延迟的情况下，在两个振荡神经元群体之间实现同步，从而达成功能性零延迟绑定。考虑两个神经元集群，一个发送方和一个接收方，每个集群都以角频率 $\\omega$（其中 $\\omega = 2\\pi f$，$f$ 是以 $\\mathrm{Hz}$ 为单位的频率）进行单频振荡。发送方产生一个标量信号 $x_{\\mathrm{A}}(t)$，接收方有一个局部振荡过程 $x_{\\mathrm{B}}(t)$，它们之间的通信信道引入了 $\\tau$ 秒的纯时间延迟。允许发送方将其传输的信号预先提前一个固定的相位超前量 $\\phi$（以弧度为单位），并且应选择此相位进动或预测性编码策略，以使到达接收方的信号与接收方的局部振荡同步，从而实现功能性零延迟绑定。\n\n需使用的基本定义：\n- 单频振荡信号的形式为 $x(t) = \\sin(\\omega t + \\theta)$，其中 $\\omega$ 是角频率（单位为 $\\mathrm{rad/s}$），$\\theta$ 是相位（单位为弧度）。\n- 纯时间延迟算子 $\\mathcal{D}_{\\tau}$ 作用于信号 $x(t)$ 的方式为 $(\\mathcal{D}_{\\tau} x)(t) = x(t - \\tau)$，其中 $\\tau$ 的单位是秒。\n- 当 $\\tau$ 足够小时，一阶预测性编码可以用一阶泰勒展开来近似：$x(t + \\tau) \\approx x(t) + \\tau \\frac{dx}{dt}(t)$。\n- 功能性零延迟绑定（通过同步实现）意味着在所有时间 $t$，到达的信号和接收方的局部振荡在相差一个常数 $2\\pi$ 相位等价的意义上是相同的。\n\n您的任务：\n1. 从上述定义出发，推导在接收方实现功能性零延迟绑定时，发送方的相位超前量 $\\phi$ 作为延迟 $\\tau$ 和频率 $f$ 的函数的条件。您必须用弧度表示 $\\phi$，并确保它是区间 $[0, 2\\pi)$ 内的最小非负解。\n2. 使用第一性原理，并且不引用任何未引入的快捷公式，证明对于正弦信号 $x_{\\mathrm{A}}(t)$，一阶预测性编码的论证可以得出关于 $\\phi$ 的相同条件，并解释此等价性在何种假设下成立。\n3. 实现一个程序，该程序：\n   - 为每个测试用例计算所需的相位超前量 $\\phi$。\n   - 通过对两个信号进行采样并在有限时间窗口内测量到达信号与接收方局部信号之间的最大绝对差，来数值验证功能性零延迟绑定，如果最大绝对差小于或等于容差 $\\epsilon$，则声明成功。\n   - 对所有相位量使用弧度单位，对所有时间量使用秒单位。频率必须以 $\\mathrm{Hz}$ 为单位。\n   - 验证窗口必须跨越接收方振荡的 $K$ 个完整周期，并使用一个包含 $N$ 个样本的均匀时间网格。您可以选择任何科学上合理的 $K$ 和 $N$，只要验证是稳健的。\n\n测试套件：\n- 用例 1：$f = 10\\,\\mathrm{Hz}$，$\\tau = 0.0\\,\\mathrm{s}$。\n- 用例 2：$f = 10\\,\\mathrm{Hz}$，$\\tau = 0.015\\,\\mathrm{s}$。\n- 用例 3：$f = 10\\,\\mathrm{Hz}$，$\\tau = 0.05\\,\\mathrm{s}$。\n- 用例 4：$f = 10\\,\\mathrm{Hz}$，$\\tau = 0.1\\,\\mathrm{s}$。\n- 用例 5：$f = 8\\,\\mathrm{Hz}$，$\\tau = 0.2\\,\\mathrm{s}$。\n- 用例 6：$f = 80\\,\\mathrm{Hz}$，$\\tau = 0.007\\,\\mathrm{s}$。\n- 用例 7：$f = 10\\,\\mathrm{Hz}$，$\\tau = 1\\times 10^{-6}\\,\\mathrm{s}$。\n\n答案规格和最终输出格式：\n- 对于每个测试用例，您的程序必须输出一个包含两个元素的列表：\n  - 所需的相位超前量 $\\phi$（以弧度为单位，作为浮点数）。\n  - 一个布尔值，指示数值验证是否在容差 $\\epsilon$ 内通过。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，\"[[phi1,True],[phi2,False],...]\"）。角度必须以弧度为单位。对所有时间量使用秒。此问题不使用百分比。布尔值是输出中的基本类型。该单行是唯一的输出。",
            "solution": "此问题被评估为有效，因为它在信号处理和计算神经科学领域有科学依据，定义和目标清晰，问题阐述良好，并且没有矛盾或含糊之处。它提出了一个可以通过既定数学原理解决的可形式化挑战。\n\n解决方案分为三个部分，对应于问题陈述中列出的三个任务。\n\n### 第一部分：相位超前条件的推导\n\n目标是找到发送方的相位超前量 $\\phi$，以确保到达接收方的信号与接收方的局部振荡同步。\n\n让接收方的局部振荡信号 $x_{\\mathrm{B}}(t)$ 作为我们的参考信号。不失一般性，我们可以将其定义为零初始相位：\n$$\nx_{\\mathrm{B}}(t) = \\sin(\\omega t)\n$$\n其中 $\\omega = 2\\pi f$ 是角频率。\n\n发送方生成一个相位超前 $\\phi$ 弧度的信号。这个被传输的信号 $x_{\\mathrm{tx}}(t)$ 由下式给出：\n$$\nx_{\\mathrm{tx}}(t) = \\sin(\\omega t + \\phi)\n$$\n该信号通过一个具有 $\\tau$ 秒纯时间延迟的信道传播。到达接收方的信号 $x_{\\mathrm{arr}}(t)$ 是传输信号的延迟版本：\n$$\nx_{\\mathrm{arr}}(t) = (\\mathcal{D}_{\\tau} x_{\\mathrm{tx}})(t) = x_{\\mathrm{tx}}(t - \\tau)\n$$\n代入 $x_{\\mathrm{tx}}(t)$ 的表达式，我们得到：\n$$\nx_{\\mathrm{arr}}(t) = \\sin(\\omega(t - \\tau) + \\phi) = \\sin(\\omega t - \\omega\\tau + \\phi)\n$$\n功能性零延迟绑定（通过同步实现）要求到达的信号和接收方的局部信号在所有时间 $t$ 都相同。这意味着：\n$$\nx_{\\mathrm{arr}}(t) = x_{\\mathrm{B}}(t)\n$$\n$$\n\\sin(\\omega t - \\omega\\tau + \\phi) = \\sin(\\omega t)\n$$\n为了使这个等式对所有 $t$ 都成立，正弦函数的参数必须相等，或者相差 $2\\pi$ 的整数倍。也就是说，对于某个整数 $k \\in \\mathbb{Z}$：\n$$\n\\omega t - \\omega\\tau + \\phi = \\omega t + 2\\pi k\n$$\n从两边减去 $\\omega t$ 来简化此方程，我们得到关于 $\\phi$ 的条件：\n$$\n\\phi - \\omega\\tau = 2\\pi k \\implies \\phi = \\omega\\tau + 2\\pi k\n$$\n问题要求 $\\phi$ 在区间 $[0, 2\\pi)$ 内的最小非负解。这可以通过计算 $\\omega\\tau$ 对 $2\\pi$ 取模来实现。由于 $\\omega  0$ 且 $\\tau \\ge 0$，乘积 $\\omega\\tau$ 是非负的。因此，所需的相位超前量 $\\phi$ 是：\n$$\n\\phi = (\\omega\\tau) \\pmod{2\\pi}\n$$\n代入 $\\omega = 2\\pi f$，以频率 $f$ 和延迟 $\\tau$ 表示的相位超前量的最终表达式为：\n$$\n\\phi = (2\\pi f \\tau) \\pmod{2\\pi}\n$$\n\n### 第二部分：与一阶预测性编码的等价性\n\n这种预测性编码方案的原理是让发送方传输一个能预见延迟影响的信号。发送方在时间 $t$ 应该传输一个信号，我们称之为 $s(t)$，该信号在经历延迟 $\\tau$ 后到达接收方，并与发送方在时间 $t$ 的自身状态相匹配。这是一个稍微重新解释以使推导更清晰的方法：目标是使到达的信号能够预测发送方的*当前*状态。设发送方的参考状态为 $x_{\\mathrm{A}}(t) = \\sin(\\omega t)$。在时间 $t$ 到达接收方的信号是在时间 $t-\\tau$ 发送的。因此，我们要求 $s(t-\\tau) = x_{\\mathrm{A}}(t)$。通过代换 $t' = t-\\tau$，我们发现在时间 $t'$ 要传输的信号是 $s(t') = x_{\\mathrm{A}}(t'+\\tau)$。\n\n因此，理想的传输信号 $s_{ideal}(t)$ 是发送方的参考信号在时间上提前 $\\tau$：\n$$\ns_{ideal}(t) = x_{\\mathrm{A}}(t+\\tau) = \\sin(\\omega(t+\\tau)) = \\sin(\\omega t + \\omega\\tau)\n$$\n这是一个相位超前为 $\\phi_{ideal} = \\omega\\tau$ 的正弦信号。\n\n一阶预测性编码规则为 $x_{\\mathrm{A}}(t+\\tau)$ 提供了一个近似：\n$$\nx_{\\mathrm{A}}(t+\\tau) \\approx x_{\\mathrm{A}}(t) + \\tau \\frac{dx_{\\mathrm{A}}}{dt}(t)\n$$\n在这种近似下传输的信号 $s_{pred}(t)$ 是：\n$$\ns_{pred}(t) = \\sin(\\omega t) + \\tau \\frac{d}{dt}(\\sin(\\omega t)) = \\sin(\\omega t) + \\tau\\omega\\cos(\\omega t)\n$$\n为了确定此近似实现的有效相位超前量，我们可以将其与一个相位移位的正弦波 $\\sin(\\omega t + \\phi)$ 关于小相位 $\\phi$ 的一阶泰勒级数展开进行比较：\n$$\n\\sin(\\omega t + \\phi) = \\sin(\\omega t)\\cos(\\phi) + \\cos(\\omega t)\\sin(\\phi)\n$$\n对于小 $\\phi$，我们使用近似 $\\cos(\\phi) \\approx 1$ 和 $\\sin(\\phi) \\approx \\phi$。展开式变为：\n$$\n\\sin(\\omega t + \\phi) \\approx \\sin(\\omega t) + \\phi\\cos(\\omega t)\n$$\n通过将预测信号 $s_{pred}(t)$ 的表达式与此展开式进行比较，我们发现它们具有相同的形式。\n$$\ns_{pred}(t) = \\sin(\\omega t) + (\\tau\\omega)\\cos(\\omega t) \\approx \\sin(\\omega t + \\phi)\n$$\n将 $\\cos(\\omega t)$ 项的系数相等，得出条件：\n$$\n\\phi = \\omega\\tau\n$$\n这表明一阶预测性编码的论证得出的相位超前量为 $\\phi = \\omega\\tau$。这个结果与第一部分中推导出的精确解 $\\phi = \\omega\\tau + 2\\pi k$ 的主值（当 $k=0$ 时）相匹配。\n\n此等价性成立的假设是相移 $\\phi = \\omega\\tau$ 足够小，以至于一阶泰勒近似是准确的。具体来说，条件是 $\\omega\\tau \\ll 1$。当此条件不满足时，预测编码器的输出 $s_{pred}(t)$ 将在相位和幅度上都与理想信号 $s_{ideal}(t)$ 不同，因为近似 $s_{pred}(t) = \\sqrt{1+(\\omega\\tau)^2} \\sin(\\omega t + \\arctan(\\omega\\tau))$ 偏离了 $\\sin(\\omega t + \\omega\\tau)$。\n\n### 第三部分：数值验证策略\n\n实现将为每个测试用例计算相位超前量 $\\phi$，然后数值验证此 $\\phi$ 的选择是否实现了功能性零延迟绑定。\n\n对于每个具有参数 $f$ 和 $\\tau$ 的测试用例：\n1.  计算角频率 $\\omega = 2\\pi f$。\n2.  使用第一部分中的公式计算所需的相位超前量：$\\phi = (2\\pi f \\tau) \\pmod{2\\pi}$。\n3.  为了验证，我们将在一个有限的时间窗口内模拟系统。我们选择一个跨越 $K=5$ 个完整振荡周期的窗口，以确保在多个周期内的稳健检查。周期为 $T = 1/f$。时间域将是 $[0, K \\cdot T]$。\n4.  模拟将使用一个包含 $N=1000$ 个点的离散时间网格。这提供了足够的时间分辨率。时间向量为 $t_i = i \\frac{K \\cdot T}{N-1}$，其中 $i=0, ..., N-1$。\n5.  生成接收方的局部信号：$x_{\\mathrm{B}}(t_i) = \\sin(\\omega t_i)$。\n6.  生成到达接收方的信号：$x_{\\mathrm{arr}}(t_i) = \\sin(\\omega(t_i - \\tau) + \\phi)$。\n7.  在每个时间点计算这两个信号之间的差异：$d_i = x_{\\mathrm{arr}}(t_i) - x_{\\mathrm{B}}(t_i)$。\n8.  如果两个信号相同，则功能性零延迟绑定得到验证。由于浮点运算，我们检查最大绝对差是否低于一个小的容差 $\\epsilon$。我们选择 $\\epsilon = 1 \\times 10^{-9}$。\n9.  如果 $\\max_{i}(|d_i|) \\le \\epsilon$，则验证通过。\n10. 测试用例的结果是一个列表，包含计算出的 $\\phi$ 和验证的布尔结果。\n\n对所有测试用例重复此过程，并将最终结果汇总为指定格式的单个列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the required phase lead for zero-lag synchrony and numerically\n    verifies the result for a set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (frequency in Hz, delay in seconds).\n    test_cases = [\n        (10.0, 0.0),          # Case 1\n        (10.0, 0.015),        # Case 2\n        (10.0, 0.05),         # Case 3\n        (10.0, 0.1),          # Case 4\n        (8.0, 0.2),           # Case 5\n        (80.0, 0.007),        # Case 6\n        (10.0, 1e-6),         # Case 7\n    ]\n\n    # Parameters for numerical verification\n    K = 5  # Number of cycles to simulate for verification\n    N = 1000  # Number of samples in the time grid\n    EPSILON = 1e-9  # Tolerance for floating-point comparison\n\n    results = []\n    for f, tau in test_cases:\n        # Task 1: Compute the required phase lead phi.\n        # omega is the angular frequency in rad/s.\n        omega = 2.0 * np.pi * f\n        \n        # phi is the minimal non-negative phase lead in radians [0, 2*pi).\n        # We use the modulo operator to wrap the value 2*pi*f*tau into the correct interval.\n        phi = (omega * tau) % (2.0 * np.pi)\n\n        # Task 2: Numerically verify functional zero-lag binding.\n        # Define the time window for verification, spanning K full cycles.\n        period = 1.0 / f\n        t = np.linspace(0, K * period, N)\n\n        # x_receiver is the local oscillation at the receiver assembly.\n        # We use this as the reference signal with zero initial phase.\n        x_receiver = np.sin(omega * t)\n\n        # x_arriving is the signal from the sender after undergoing the delay tau,\n        # with the computed corrective phase lead phi applied at the source.\n        x_arriving = np.sin(omega * (t - tau) + phi)\n\n        # Calculate the maximum absolute difference between the two signals\n        # over the entire time window.\n        max_diff = np.max(np.abs(x_arriving - x_receiver))\n\n        # The verification passes if the maximum difference is within the\n        # defined numerical tolerance.\n        is_verified = max_diff = EPSILON\n        \n        results.append([phi, is_verified])\n\n    # Format the final output string as a list of lists.\n    # e.g., [[phi1,True],[phi2,False],...]\n    inner_strings = [f\"[{res[0]},{str(res[1])}]\" for res in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    # The boolean needs to be lowercase `true` or `false` for JSON-like formats.\n    # Python's default str(True) is 'True'. We need to adjust.\n    final_output = final_output.replace('True', 'True').replace('False', 'False')\n\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "现在，我们将从振荡器对扩展到一个直接模拟认知过程的网络模型。这个仿真练习要求您构建一个网络，其中不同的神经元组内部同步以表示独立的“对象”，同时避免与其他组同步。通过调整模块内部和模块之间的耦合强度，您将直接观察到簇同步（cluster synchronization）如何为绑定同一对象的特征并区分不同对象提供一个强大的机制 。",
            "id": "4037690",
            "problem": "您需要设计并实现一个仿真，该仿真在一个弱耦合相位振子网络中展示簇同步现象。此网络在 Kuramoto 框架内形式化，旨在模拟通过同步实现的绑定，并使模块间的串扰最小化。核心要求是，模块在内部实现同步，同时避免整个网络的全局同步，从而表示内部已绑定但彼此间保持独立的独立对象。角度必须以弧度处理，时间以秒为单位，固有频率以弧度/秒为单位。程序必须按照末尾指定的精确格式生成单行输出。\n\n使用以下基本原理：\n- Kuramoto 模型由 $N$ 个相位振子组成，其相位为 $\\theta_i(t)$，固有频率为 $\\omega_i$，耦合矩阵为 $K_{ij}$。其动力学方程为\n$$\n\\frac{d\\theta_i}{dt} = \\omega_i + \\sum_{j=1}^{N} K_{ij} \\sin\\big(\\theta_j(t) - \\theta_i(t)\\big).\n$$\n- 在时间 $t$ 的全局 Kuramoto 序参数为\n$$\nR_{\\text{global}}(t) = \\left| \\frac{1}{N} \\sum_{i=1}^{N} e^{\\mathrm{i}\\,\\theta_i(t)} \\right|.\n$$\n- 对于索引集为 $\\mathcal{M}_m$ 的模块 $m$，其在时间 $t$ 的模块序参数为\n$$\nR_m(t) = \\left| \\frac{1}{|\\mathcal{M}_m|} \\sum_{i \\in \\mathcal{M}_m} e^{\\mathrm{i}\\,\\theta_i(t)} \\right|.\n$$\n- 模块平均相位为\n$$\n\\phi_m(t) = \\arg\\left( \\frac{1}{|\\mathcal{M}_m|} \\sum_{i \\in \\mathcal{M}_m} e^{\\mathrm{i}\\,\\theta_i(t)} \\right).\n$$\n- 在时间样本为 $\\{t_k\\}$ 的时间窗口内，模块 $a$ 和 $b$ 之间的模块间锁相值定义为\n$$\n\\mathrm{PLV}_{a,b} = \\left| \\frac{1}{K} \\sum_{k=1}^{K} e^{\\mathrm{i}\\,[\\phi_a(t_k) - \\phi_b(t_k)]} \\right|.\n$$\n\n您的任务是：\n- 使用时间步长 $\\Delta t$，通过前向欧拉法实现一个数值积分器来模拟 Kuramoto 模型。\n- 构建具有块状结构的耦合矩阵：模块内耦合是均匀的，等于 $K_{\\text{intra}}$（不包括自耦合），模块间耦合是均匀的，等于 $K_{\\text{inter}}$。\n- 在 $[0,2\\pi)$ 上均匀随机地初始化相位 $\\theta_i(0)$。\n- 根据指定的均值 $\\mu_m$ 和标准差 $\\sigma_m$，从正态分布中为每个模块的振子分配固有频率 $\\omega_i$。\n- 在模拟持续时间 $T$ 后，使用模拟的后半部分样本（以排除暂态过程）计算时间平均的全局序参数 $\\overline{R}_{\\text{global}}$、模块序参数 $\\overline{R}_m$ 以及最大模块间锁相值 $\\max_{a \\neq b} \\mathrm{PLV}_{a,b}$。\n- 为每个测试用例定义一个二进制决策，如果满足以下所有条件，则表示成功实现了串扰最小的簇同步：\n  1. 每个模块的时间平均序参数满足 $\\overline{R}_m \\geq r_{\\text{intra}}$，\n  2. 时间平均的全局序参数满足 $\\overline{R}_{\\text{global}} \\leq r_{\\text{global}}$，\n  3. 最大模块间锁相值满足 $\\max_{a \\neq b} \\mathrm{PLV}_{a,b} \\leq p_{\\text{max}}$。\n- 使用阈值 $r_{\\text{intra}} = 0.8$，$r_{\\text{global}} = 0.6$ 和 $p_{\\text{max}} = 0.4$。\n\n角度以弧度为单位，时间以秒为单位，固有频率以弧度/秒为单位。数值积分必须使用以秒为单位的 $\\Delta t$。将所有阈值和耦合常数表示为无单位的标量。您的实现必须是确定性的；固定伪随机数生成器的种子以确保可复现性。\n\n测试套件和参数化：\n实现以下 $5$ 个测试用例。每个用例由元组 $(\\text{modules}, K_{\\text{intra}}, K_{\\text{inter}}, \\{\\mu_m\\}, \\{\\sigma_m\\}, \\Delta t, T)$ 指定，其中 $\\text{modules}$ 是模块大小的列表，其总和为 $N$。\n\n- 用例 1（理想情况，两个独立模块，模块间耦合较小）：\n  - $\\text{modules} = [10, 10]$,\n  - $K_{\\text{intra}} = 0.9$,\n  - $K_{\\text{inter}} = 0.05$,\n  - $\\{\\mu_m\\} = [1.5, 2.0]$,\n  - $\\{\\sigma_m\\} = [0.05, 0.05]$,\n  - $\\Delta t = 0.01$,\n  - $T = 20.0$.\n- 用例 2（由于模块间耦合较强而趋向全局同步的边界情况）：\n  - $\\text{modules} = [10, 10]$,\n  - $K_{\\text{intra}} = 0.9$,\n  - $K_{\\text{inter}} = 0.35$,\n  - $\\{\\mu_m\\} = [1.5, 2.0]$,\n  - $\\{\\sigma_m\\} = [0.05, 0.05]$,\n  - $\\Delta t = 0.01$,\n  - $T = 20.0$.\n- 用例 3（模块间耦合为零的边缘情况）：\n  - $\\text{modules} = [10, 10]$,\n  - $K_{\\text{intra}} = 0.9$,\n  - $K_{\\text{inter}} = 0.0$,\n  - $\\{\\mu_m\\} = [1.5, 2.0]$,\n  - $\\{\\sigma_m\\} = [0.05, 0.05]$,\n  - $\\Delta t = 0.01$,\n  - $T = 20.0$.\n- 用例 4（异构模块大小和中等模块间耦合）：\n  - $\\text{modules} = [12, 8]$,\n  - $K_{\\text{intra}} = 0.8$,\n  - $K_{\\text{inter}} = 0.1$,\n  - $\\{\\mu_m\\} = [1.7, 2.2]$,\n  - $\\{\\sigma_m\\} = [0.03, 0.03]$,\n  - $\\Delta t = 0.01$,\n  - $T = 20.0$.\n- 用例 5（三个具有不同平均频率和较小模块间耦合的模块）：\n  - $\\text{modules} = [8, 8, 8]$,\n  - $K_{\\text{intra}} = 0.9$,\n  - $K_{\\text{inter}} = 0.02$,\n  - $\\{\\mu_m\\} = [1.2, 1.6, 2.1]$,\n  - $\\{\\sigma_m\\} = [0.04, 0.04, 0.04]$,\n  - $\\Delta t = 0.01$,\n  - $T = 20.0$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result1},\\text{result2},\\text{result3}]$），其中每个 $\\text{result}$ 是一个布尔值，表示该用例是否在上述标准下实现了串扰最小的簇同步。",
            "solution": "问题陈述经评估有效。它提出了计算神经科学中一个明确定义的任务，该任务基于已建立的耦合振子 Kuramoto 模型。其目标、参数和评估标准都规定得足够精确，可以得出一个唯一且可验证的解。该问题需要对一个常微分方程组进行仿真并进行后续数据分析，这是定量科学研究中的标准程序。\n\n关于耦合常数 $K_{\\text{intra}}$ 和 $K_{\\text{inter}}$ 的单位存在一个微小的不明确之处。其控制微分方程，\n$$\n\\frac{d\\theta_i}{dt} = \\omega_i + \\sum_{j=1}^{N} K_{ij} \\sin\\big(\\theta_j(t) - \\theta_i(t)\\big)\n$$\n为了保持量纲一致性，要求耦合常数 $K_{ij}$ 具有频率单位（例如 rad/s），因为 $\\frac{d\\theta_i}{dt}$ 和固有频率 $\\omega_i$ 的单位都是 rad/s，而正弦函数是无量纲的。然而，问题将这些常数描述为“无单位标量”。这是该领域的常见约定，其中耦合强度被隐含地理解为具有频率单位或已相对于参考频率进行了无量纲化处理。鉴于上下文和为 $\\omega_i$ 指定的值，将 $K$ 的值解释为以 rad/s 为单位是合适的。这种轻微的不精确性并不会使问题无效，因为它可以通过标准解释来解决。问题的所有其他方面都是清晰、一致且科学合理的。\n\n解决方案首先构建模型，然后模拟其动力学，最后根据指定标准分析结果。\n\n**1. 模型构建**\n\n该系统由 $N$ 个振子组成，被划分为不同的模块。振子总数 $N$ 是给定测试用例中指定的所有模块大小的总和。\n\n**固有频率 ($\\omega_i$)：**\n对于属于模块 $m$ 的每个振子 $i$，其固有频率 $\\omega_i$ 从正态分布 $\\mathcal{N}(\\mu_m, \\sigma_m^2)$ 中抽取，其中 $\\mu_m$ 是该模块的平均频率，$\\sigma_m$ 是标准差。模块之间平均频率的差异对于建立不同的同步簇至关重要。\n\n**耦合矩阵 ($K_{ij}$)：**\n振子之间的相互作用由 $N \\times N$ 耦合矩阵 $K$ 定义。该矩阵构建为块状结构，以反映网络的模块化组织。\n- 对于同一模块内的任意两个不同振子 $i$ 和 $j$，耦合强度是均匀的，并设置为 $K_{ij} = K_{\\text{intra}}$。\n- 对于不同模块中的任意两个振子 $i$ 和 $j$，耦合强度是均匀的，并设置为 $K_{ij} = K_{\\text{inter}}$。\n- 不包括自耦合，因此对角线元素为 $K_{ii} = 0$。\n条件 $K_{\\text{intra}} \\gg K_{\\text{inter}}$ 预计将促进模块内的强同步，同时保持它们之间的相对独立性。\n\n**初始条件 ($\\theta_i(0)$)：**\n每个振子的初始相位 $\\theta_i(0)$ 从区间 $[0, 2\\pi)$ 上的均匀随机分布中独立抽取。这对应于整个网络最初的非相干状态。\n\n**2. 数值模拟**\n\n使用前向欧拉法对耦合常微分方程组进行数值求解。给定时间步长 $\\Delta t$，每个振子在时间 $t + \\Delta t$ 的相位由其在时间 $t$ 的状态近似得出：\n$$\n\\theta_i(t+\\Delta t) = \\theta_i(t) + \\Delta t \\cdot \\left( \\omega_i + \\sum_{j=1}^{N} K_{ij} \\sin(\\theta_j(t) - \\theta_i(t)) \\right)\n$$\n在每个更新步骤之后，使用模运算符将相位环绕在 $[0, 2\\pi)$ 区间内，以处理角度的周期性。模拟的总持续时间为 $T$。\n\n**3. 分析与评估**\n\n为确保分析反映系统的稳态行为，所有度量均使用模拟后半部分的数据（从 $t = T/2$ 到 $t = T$）计算，从而丢弃初始暂态过程。\n\n**序参数：**\n同步程度使用 Kuramoto 序参数进行量化。对于一组相位为 $\\{\\psi_k\\}$ 的振子，序参数为 $R = |\\frac{1}{L} \\sum_{k=1}^{L} e^{\\mathrm{i}\\psi_k}|$，其中 $L$ 是该集合中振子的数量。$R \\approx 1$ 的值表示强同步，而 $R \\approx 0$ 表示非相干。我们计算：\n- **全局序参数** $R_{\\text{global}}(t)$，在所有 $N$ 个振子上计算。\n- **模块序参数** $R_m(t)$，为每个模块 $m$ 在其组成振子上计算。\n然后将这些参数在分析窗口内进行时间平均，得到 $\\overline{R}_{\\text{global}}$ 和 $\\overline{R}_m$。\n\n**模块间锁相值 (PLV)：**\n为测量模块*之间*的同步性，我们首先计算分析窗口中每个时间步 $t_k$ 处每个模块 $m$ 的平均相位：\n$$\n\\phi_m(t_k) = \\arg\\left( \\frac{1}{|\\mathcal{M}_m|} \\sum_{i \\in \\mathcal{M}_m} e^{\\mathrm{i}\\,\\theta_i(t_k)} \\right)\n$$\n模块 $a$ 和 $b$ 之间的 PLV 则是时间平均的相位差向量的模：\n$$\n\\mathrm{PLV}_{a,b} = \\left| \\frac{1}{K} \\sum_{k=1}^{K} e^{\\mathrm{i}\\,[\\phi_a(t_k) - \\phi_b(t_k)]} \\right|\n$$\n其中求和遍及分析窗口中的所有 $K$ 个时间样本。我们找出所有不同模块对之间的最大 PLV，即 $\\max_{a \\neq b} \\mathrm{PLV}_{a,b}$。\n\n**决策标准：**\n当且仅当满足以下所有三个条件时，一个测试用例才被分类为成功展示了簇同步：\n1.  _高模块内凝聚力_：对于所有模块 $m$，$\\overline{R}_m \\geq r_{\\text{intra}}$，其中 $r_{\\text{intra}} = 0.8$。\n2.  _低全局凝聚力_：$\\overline{R}_{\\text{global}} \\leq r_{\\text{global}}$，其中 $r_{\\text{global}} = 0.6$。\n3.  _低模块间串扰_：$\\max_{a \\neq b} \\mathrm{PLV}_{a,b} \\leq p_{\\text{max}}$，其中 $p_{\\text{max}} = 0.4$。\n\n该实现将处理五个测试用例中的每一个，应用此逻辑，并为每个用例返回一个布尔结果。伪随机数生成器的固定种子确保了结果的确定性和可复现性。",
            "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for Kuramoto model cluster synchronization.\n    \"\"\"\n    # Fix the pseudo-random generator seed for reproducibility.\n    # This ensures that initial phases and natural frequencies are the same for each run.\n    np.random.seed(0)\n\n    # Define the test cases as specified in the problem statement.\n    # Each case: (modules, K_intra, K_inter, {mu_m}, {sigma_m}, dt, T)\n    test_cases = [\n        # Case 1: Happy path\n        ([10, 10], 0.9, 0.05, [1.5, 2.0], [0.05, 0.05], 0.01, 20.0),\n        # Case 2: Tending to global sync\n        ([10, 10], 0.9, 0.35, [1.5, 2.0], [0.05, 0.05], 0.01, 20.0),\n        # Case 3: Zero inter-coupling\n        ([10, 10], 0.9, 0.0, [1.5, 2.0], [0.05, 0.05], 0.01, 20.0),\n        # Case 4: Heterogeneous modules\n        ([12, 8], 0.8, 0.1, [1.7, 2.2], [0.03, 0.03], 0.01, 20.0),\n        # Case 5: Three modules\n        ([8, 8, 8], 0.9, 0.02, [1.2, 1.6, 2.1], [0.04, 0.04, 0.04], 0.01, 20.0),\n    ]\n\n    # Thresholds for success criteria\n    r_intra = 0.8\n    r_global = 0.6\n    p_max = 0.4\n    \n    results = []\n    for case_params in test_cases:\n        result = run_kuramoto_simulation(case_params, r_intra, r_global, p_max)\n        results.append(result)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\".replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\n\ndef run_kuramoto_simulation(params, r_intra, r_global, p_max):\n    \"\"\"\n    Runs a single simulation of the Kuramoto model and evaluates cluster synchronization.\n    \"\"\"\n    module_sizes, K_intra, K_inter, mus, sigmas, dt, T = params\n    \n    # 1. Initialization\n    num_modules = len(module_sizes)\n    N = sum(module_sizes)\n    \n    # Generate module indices for each oscillator\n    module_indices = []\n    start_idx = 0\n    for size in module_sizes:\n        module_indices.append(list(range(start_idx, start_idx + size)))\n        start_idx += size\n\n    # Natural frequencies (omega)\n    omega = np.zeros(N)\n    for i in range(num_modules):\n        omega[module_indices[i]] = np.random.normal(mus[i], sigmas[i], module_sizes[i])\n        \n    # Initial phases (theta)\n    theta = np.random.uniform(0, 2 * np.pi, N)\n    \n    # Coupling matrix (K)\n    K = np.full((N, N), K_inter)\n    for i in range(num_modules):\n        idx = np.ix_(module_indices[i], module_indices[i])\n        K[idx] = K_intra\n    np.fill_diagonal(K, 0)\n\n    # 2. Simulation\n    num_steps = int(T / dt)\n    analysis_start_step = num_steps // 2\n    \n    # History storage for analysis window\n    history_len = num_steps - analysis_start_step\n    R_global_hist = np.zeros(history_len)\n    R_modules_hist = np.zeros((num_modules, history_len))\n    phi_modules_hist = np.zeros((num_modules, history_len))\n\n    for step in range(num_steps):\n        # Calculate phase differences (theta_j - theta_i) efficiently\n        phase_diffs = theta - theta[:, np.newaxis]\n        \n        # Calculate sum term of the ODE\n        interaction_term = np.sum(K * np.sin(phase_diffs), axis=1)\n        \n        # Update phases using Euler forward method\n        theta = (theta + dt * (omega + interaction_term)) % (2 * np.pi)\n        \n        # Store metrics if in analysis window\n        if step >= analysis_start_step:\n            hist_idx = step - analysis_start_step\n            \n            # Global order parameter\n            R_global_hist[hist_idx] = np.abs(np.mean(np.exp(1j * theta)))\n            \n            # Module-specific order parameters and mean phases\n            for m in range(num_modules):\n                module_theta = theta[module_indices[m]]\n                mean_phasor = np.mean(np.exp(1j * module_theta))\n                R_modules_hist[m, hist_idx] = np.abs(mean_phasor)\n                phi_modules_hist[m, hist_idx] = np.angle(mean_phasor)\n\n    # 3. Analysis and Evaluation\n    \n    # Time-averaged global order parameter\n    avg_R_global = np.mean(R_global_hist)\n    \n    # Time-averaged module order parameters\n    avg_R_modules = np.mean(R_modules_hist, axis=1)\n    \n    # Maximum inter-module Phase-Locking Value (PLV)\n    max_plv = 0.0\n    if num_modules > 1:\n        plv_values = []\n        for m1, m2 in combinations(range(num_modules), 2):\n            phase_diff_hist = phi_modules_hist[m1, :] - phi_modules_hist[m2, :]\n            plv = np.abs(np.mean(np.exp(1j * phase_diff_hist)))\n            plv_values.append(plv)\n        if plv_values:\n            max_plv = np.max(plv_values)\n\n    # 4. Decision Logic\n    cond1 = np.all(avg_R_modules >= r_intra)\n    cond2 = avg_R_global = r_global\n    cond3 = max_plv = p_max\n    \n    return cond1 and cond2 and cond3\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}