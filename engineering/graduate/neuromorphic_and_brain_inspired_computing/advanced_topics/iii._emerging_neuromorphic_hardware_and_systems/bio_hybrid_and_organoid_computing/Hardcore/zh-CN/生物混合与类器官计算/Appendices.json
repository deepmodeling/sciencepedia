{
    "hands_on_practices": [
        {
            "introduction": "要理解类器官网络的集体行为，一个有效的方法是使用数学模型。Wilson-Cowan模型是一个经典的框架，用于描述兴奋性（E）和抑制性（I）神经元种群之间的相互作用。通过分析这个模型，我们可以预测网络层面的涌现特性，例如在多电极阵列（MEA）记录中常见的振荡活动。这个练习将指导您通过线性化分析，从模型的参数中推导出网络产生振荡的条件和频率，从而将理论模型与实验可观测量联系起来 。",
            "id": "4037921",
            "problem": "考虑一个与多电极阵列（MEA）连接构成生物混合系统的皮层类器官网络。其粗粒化的兴奋-抑制群体描述由Wilson-Cowan方程建模\n$$\\tau_{e} \\,\\dot{E}(t) = -E(t) + S\\!\\left(w_{ee}\\,E(t) - w_{ei}\\,I(t) + P\\right)$$\n$$\\tau_{i} \\,\\dot{I}(t) = -I(t) + S\\!\\left(w_{ie}\\,E(t) - w_{ii}\\,I(t)\\right),$$\n其中$E(t)$和$I(t)$是无量纲的群体放电率，$\\tau_{e}$和$\\tau_{i}$是正时间常数，$w_{ee}, w_{ei}, w_{ie}, w_{ii}$是无量纲的有效突触耦合强度，$P$是一个恒定的兴奋性驱动，而$S(x)$是一个可微的S型激活函数，代表群体响应曲线。在类器官表现出稳态活动且在MEA功率谱中可观测到小振幅振荡的工作状态下，S函数在稳态输入处的局部增益（斜率）被经验性地估计为$s_{e} = S'\\!\\left(w_{ee}\\,E^{*} - w_{ei}\\,I^{*} + P\\right)$和$s_{i} = S'\\!\\left(w_{ie}\\,E^{*} - w_{ii}\\,I^{*}\\right)$，其中$E^{*}$和$I^{*}$表示稳态放电率。\n\n从模型方程和基础线性系统分析出发，推导在线性化动力学在$(E^{*}, I^{*})$附近表现出振荡模式的条件，并以线性化参数表示小振荡角频率的表达式。然后，对于给定的参数集\n- $\\tau_{e} = 0.02 \\ \\mathrm{s}$, $\\tau_{i} = 0.01 \\ \\mathrm{s}$,\n- $w_{ee} = 1.5$, $w_{ei} = 2.0$, $w_{ie} = 3.0$, $w_{ii} = 0.5$,\n- $s_{e} = 0.8$, $s_{i} = 0.7$,\n计算在MEA功率谱中观测到的预测振荡频率，假设系统足够接近稳定工作点，以使线性预测有效。将您的答案四舍五入到$4$位有效数字，并以$\\mathrm{Hz}$为单位表示。您可以将$P$和稳态$(E^{*}, I^{*})$视为仅确定$s_{e}$和$s_{i}$的固定量，并且除了这些斜率之外，它们不会显式地进入线性化过程。",
            "solution": "经评估，用户提供的问题是有效的。其科学基础是计算神经科学中的一个标准框架——成熟的Wilson-Cowan神经群体动力学模型。该问题是适定的，为标准的线性稳定性分析提供了完整的方程组和参数。其语言客观精确，设定自洽且内部一致。未发现任何可能导致问题无效的缺陷。因此，我们可以开始求解。\n\n该问题要求推导由Wilson-Cowan方程描述的系统出现振荡行为的条件及相应的振荡频率，然后对给定的参数集进行数值计算。分析始于将系统在其稳态点$(E^{*}, I^{*})$附近进行线性化。\n\n给定的方程组是：\n$$\n\\tau_{e} \\,\\dot{E}(t) = -E(t) + S(u_e(t))\n$$\n$$\n\\tau_{i} \\,\\dot{I}(t) = -I(t) + S(u_i(t))\n$$\n其中 $u_e(t) = w_{ee}\\,E(t) - w_{ei}\\,I(t) + P$ 且 $u_i(t) = w_{ie}\\,E(t) - w_{ii}\\,I(t)$。\n\n在稳态点，记为$(E^{*}, I^{*})$，时间导数为零：\n$$\n0 = -E^{*} + S(u_e^{*})\n$$\n$$\n0 = -I^{*} + S(u_i^{*})\n$$\n其中 $u_e^{*} = w_{ee}\\,E^{*} - w_{ei}\\,I^{*} + P$ 且 $u_i^{*} = w_{ie}\\,E^{*} - w_{ii}\\,I^{*}$。\n\n为了分析该稳态点附近的动力学，我们引入小微扰$\\delta_E(t) = E(t) - E^{*}$和$\\delta_I(t) = I(t) - I^{*}$。通过将$E(t) = E^{*} + \\delta_E(t)$和$I(t) = I^{*} + \\delta_I(t)$代入原方程，并对S型函数$S(x)$在稳态输入$u_e^{*}$和$u_i^{*}$附近进行一阶泰勒展开，可以找到这些微扰的时间演化。\n\n对于兴奋性群体：\n$$\n\\tau_e \\dot{\\delta}_E(t) = -(E^{*} + \\delta_E(t)) + S(u_e^{*} + w_{ee}\\delta_E(t) - w_{ei}\\delta_I(t))\n$$\n使用泰勒展开 $S(x_0 + \\Delta x) \\approx S(x_0) + S'(x_0)\\Delta x$：\n$$\n\\tau_e \\dot{\\delta}_E(t) \\approx -E^{*} - \\delta_E(t) + S(u_e^{*}) + S'(u_e^{*})(w_{ee}\\delta_E(t) - w_{ei}\\delta_I(t))\n$$\n由于在稳态时$-E^{*} + S(u_e^{*}) = 0$，并使用给定的定义$s_e = S'(u_e^{*})$，方程简化为：\n$$\n\\tau_e \\dot{\\delta}_E(t) = -\\delta_E(t) + s_e(w_{ee}\\delta_E(t) - w_{ei}\\delta_I(t))\n$$\n$$\n\\dot{\\delta}_E(t) = \\frac{1}{\\tau_e}[(s_e w_{ee} - 1)\\delta_E(t) - s_e w_{ei}\\delta_I(t)]\n$$\n\n类似地，对于抑制性群体：\n$$\n\\tau_i \\dot{\\delta}_I(t) = -(I^{*} + \\delta_I(t)) + S(u_i^{*} + w_{ie}\\delta_E(t) - w_{ii}\\delta_I(t))\n$$\n展开并使用稳态条件$-I^{*} + S(u_i^{*}) = 0$和定义$s_i = S'(u_i^{*})$：\n$$\n\\tau_i \\dot{\\delta}_I(t) \\approx -\\delta_I(t) + s_i(w_{ie}\\delta_E(t) - w_{ii}\\delta_I(t))\n$$\n$$\n\\dot{\\delta}_I(t) = \\frac{1}{\\tau_i}[s_i w_{ie}\\delta_E(t) - (1 + s_i w_{ii})\\delta_I(t)]\n$$\n\n这个线性化系统可以写成矩阵形式 $\\dot{\\mathbf{x}} = J\\mathbf{x}$，其中 $\\mathbf{x} = \\begin{pmatrix} \\delta_E \\\\ \\delta_I \\end{pmatrix}$，$J$是在稳态点计算的雅可比矩阵：\n$$\nJ = \\begin{pmatrix}\n\\frac{s_e w_{ee} - 1}{\\tau_e}  -\\frac{s_e w_{ei}}{\\tau_e} \\\\\n\\frac{s_i w_{ie}}{\\tau_i}  -\\frac{1 + s_i w_{ii}}{\\tau_i}\n\\end{pmatrix}\n$$\n线性化系统的动力学由$J$的特征值$\\lambda$决定，这些特征值是特征方程$\\det(J - \\lambda I) = 0$的根。该方程为 $\\lambda^2 - \\text{Tr}(J)\\lambda + \\det(J) = 0$，其中$\\text{Tr}(J)$是雅可比矩阵的迹，$\\det(J)$是其行列式。\n\n特征值由以下公式给出：\n$$\n\\lambda = \\frac{\\text{Tr}(J) \\pm \\sqrt{(\\text{Tr}(J))^2 - 4\\det(J)}}{2}\n$$\n当特征值为一对复共轭时，系统表现出振荡模式。这发生在特征方程的判别式为负时。\n振荡模式的条件：\n$$\n(\\text{Tr}(J))^2 - 4\\det(J)  0\n$$\n当满足此条件时，特征值的形式为$\\lambda = \\alpha \\pm i\\omega$，其中实部$\\alpha = \\frac{\\text{Tr}(J)}{2}$决定稳定性（振荡的增长或衰减），虚部$\\omega$代表小振荡的角频率。\n角频率的表达式为：\n$$\n\\omega = \\frac{\\sqrt{4\\det(J) - (\\text{Tr}(J))^2}}{2}\n$$\n至此，问题的推导部分完成。\n\n现在，我们为给定的参数计算数值：\n$\\tau_{e} = 0.02 \\ \\mathrm{s}$, $\\tau_{i} = 0.01 \\ \\mathrm{s}$\n$w_{ee} = 1.5$, $w_{ei} = 2.0$, $w_{ie} = 3.0$, $w_{ii} = 0.5$\n$s_{e} = 0.8$, $s_{i} = 0.7$\n\n首先，计算雅可比矩阵$J$的元素：\n$$\nJ_{11} = \\frac{s_e w_{ee} - 1}{\\tau_e} = \\frac{(0.8)(1.5) - 1}{0.02} = \\frac{1.2 - 1}{0.02} = \\frac{0.2}{0.02} = 10 \\ \\mathrm{s}^{-1}\n$$\n$$\nJ_{12} = -\\frac{s_e w_{ei}}{\\tau_e} = -\\frac{(0.8)(2.0)}{0.02} = -\\frac{1.6}{0.02} = -80 \\ \\mathrm{s}^{-1}\n$$\n$$\nJ_{21} = \\frac{s_i w_{ie}}{\\tau_i} = \\frac{(0.7)(3.0)}{0.01} = \\frac{2.1}{0.01} = 210 \\ \\mathrm{s}^{-1}\n$$\n$$\nJ_{22} = -\\frac{1 + s_i w_{ii}}{\\tau_i} = -\\frac{1 + (0.7)(0.5)}{0.01} = -\\frac{1 + 0.35}{0.01} = -\\frac{1.35}{0.01} = -135 \\ \\mathrm{s}^{-1}\n$$\n雅可比矩阵为 $J = \\begin{pmatrix} 10  -80 \\\\ 210  -135 \\end{pmatrix}$。\n\n接下来，我们计算$J$的迹和行列式：\n$$\n\\text{Tr}(J) = J_{11} + J_{22} = 10 - 135 = -125 \\ \\mathrm{s}^{-1}\n$$\n$$\n\\det(J) = J_{11}J_{22} - J_{12}J_{21} = (10)(-135) - (-80)(210) = -1350 + 16800 = 15450 \\ \\mathrm{s}^{-2}\n$$\n\n现在，我们检查振荡的条件：\n$$\n(\\text{Tr}(J))^2 - 4\\det(J) = (-125)^2 - 4(15450) = 15625 - 61800 = -46175\n$$\n由于判别式为负（$-46175  0$），系统表现出振荡行为。由于$\\text{Tr}(J)  0$，振荡是阻尼的，稳态是一个稳定的螺线点，这与问题描述的“具有小振幅振荡的稳态活动”相符。\n\n最后，我们计算角频率$\\omega$和以赫兹为单位的频率$f$。\n$$\n\\omega = \\frac{\\sqrt{4\\det(J) - (\\text{Tr}(J))^2}}{2} = \\frac{\\sqrt{4(15450) - (-125)^2}}{2} = \\frac{\\sqrt{61800 - 15625}}{2} = \\frac{\\sqrt{46175}}{2} \\ \\mathrm{rad/s}\n$$\n以赫兹为单位的频率是$f = \\frac{\\omega}{2\\pi}$：\n$$\nf = \\frac{\\sqrt{46175}}{4\\pi} \\approx \\frac{214.88369}{4\\pi} \\approx 17.09999 \\ \\mathrm{Hz}\n$$\n四舍五入到$4$位有效数字，预测的振荡频率是$17.10 \\ \\mathrm{Hz}$。",
            "answer": "$$\n\\boxed{17.10}\n$$"
        },
        {
            "introduction": "将生物系统视为计算设备，一个核心问题是量化其处理信息的能力。本练习从动力学转向信息论视角，探讨如何衡量类器官网络的编码效率。您将使用香农信息论中的互信息（mutual information）这一强大工具，来计算类器官的神经响应（以发放率形式）中包含了多少关于外部刺激的信息。通过这个练习，您将学会如何评估一个生物计算系统的输入-输出关系，并理解响应饱和等非线性现象如何限制信息传输的带宽 。",
            "id": "4037904",
            "problem": "一个与微电极阵列（MEA）连接的人类皮层类器官，通过离散的细胞外刺激振幅进行驱动，在短观察窗内产生脉冲计数响应。设离散刺激集为 $S \\in \\{s_{1}, s_{2}, s_{3}\\}$，分别代表低、中、高振幅。在一个长度为 $T = 50\\,\\mathrm{ms}$ 的固定观察窗内，脉冲计数响应被离散化为 $Y \\in \\{0, 1, 2, 3\\}$。假设系统是平稳的，并且在每种刺激下的重复试验产生以下经验观察到的条件响应分布：\n- 对于 $s_{1}$：$p(y \\mid s_{1}) = [0.5, 0.3, 0.15, 0.05]$，对应于 $y = 0, 1, 2, 3$。\n- 对于 $s_{2}$：$p(y \\mid s_{2}) = [0.2, 0.4, 0.3, 0.1]$，对应于 $y = 0, 1, 2, 3$。\n- 对于 $s_{3}$：$p(y \\mid s_{3}) = [0.05, 0.15, 0.35, 0.45]$，对应于 $y = 0, 1, 2, 3$。\n\n假设先验刺激分布是均匀的，即 $p(s_{1}) = p(s_{2}) = p(s_{3}) = 1/3$。使用 Shannon 信息论中互信息的定义，计算刺激 $S$ 和脉冲计数响应 $Y$ 之间的互信息 $I(S;Y)$。你的答案应以比特（bit）为单位（使用以 2 为底的对数），并四舍五入至四位有效数字。此外，根据计算出的值和所提供的分布，简要解释当刺激强度增加超过 $s_3$ 时，高刺激强度下的脉冲计数饱和现象对 $I(S;Y)$ 意味着什么。",
            "solution": "用户提供了一个在计算神经科学和信息论领域中定义明确的问题。该问题具有科学依据，内容完整，并且所有提供的概率分布都是有效的（即，在每种条件下，它们的总和为1）。因此，该问题被认为是有效的，并在此提供解答。\n\n主要任务是计算刺激集 $S = \\{s_1, s_2, s_3\\}$ 和脉冲计数响应集 $Y = \\{0, 1, 2, 3\\}$ 之间的互信息 $I(S;Y)$。互信息量化了通过观察一个随机变量而减少的关于另一个随机变量的不确定性。它有几种等价的定义方式，对于本问题最方便的一种是：\n$$I(S;Y) = H(Y) - H(Y|S)$$\n其中 $H(Y)$ 是响应分布的熵，而 $H(Y|S)$ 是给定刺激下响应的条件熵。计算将使用以2为底的对数，因为答案要求以比特为单位。\n\n首先，我们计算条件熵 $H(Y|S)$。这个量是响应的平均熵，该平均值是对所有可能的刺激进行加权平均得到的。它由以下公式给出：\n$$H(Y|S) = \\sum_{s \\in S} p(s) H(Y|S=s)$$\n其中 $H(Y|S=s)$ 是特定刺激 $s$ 下响应分布的熵：\n$$H(Y|S=s) = -\\sum_{y \\in Y} p(y|s) \\log_2(p(y|s))$$\n问题陈述了刺激的均匀先验分布，所以 $p(s_1) = p(s_2) = p(s_3) = \\frac{1}{3}$。\n\n让我们计算每种刺激下的条件熵：\n对于 $s_1$：\n$H(Y|S=s_1) = -[p(0|s_1)\\log_2(p(0|s_1)) + p(1|s_1)\\log_2(p(1|s_1)) + p(2|s_1)\\log_2(p(2|s_1)) + p(3|s_1)\\log_2(p(3|s_1))]$\n$H(Y|S=s_1) = -[0.5\\log_2(0.5) + 0.3\\log_2(0.3) + 0.15\\log_2(0.15) + 0.05\\log_2(0.05)]$\n$H(Y|S=s_1) \\approx 1.64775$ 比特。\n\n对于 $s_2$：\n$H(Y|S=s_2) = -[0.2\\log_2(0.2) + 0.4\\log_2(0.4) + 0.3\\log_2(0.3) + 0.1\\log_2(0.1)]$\n$H(Y|S=s_2) \\approx 1.84644$ 比特。\n\n对于 $s_3$：\n$H(Y|S=s_3) = -[0.05\\log_2(0.05) + 0.15\\log_2(0.15) + 0.35\\log_2(0.35) + 0.45\\log_2(0.45)]$\n$H(Y|S=s_3) \\approx 1.67517$ 比特。\n\n现在，我们可以计算总条件熵 $H(Y|S)$：\n$H(Y|S) = p(s_1)H(Y|S=s_1) + p(s_2)H(Y|S=s_2) + p(s_3)H(Y|S=s_3)$\n$H(Y|S) = \\frac{1}{3} (1.64775 + 1.84644 + 1.67517) = \\frac{1}{3} (5.16936)$\n$H(Y|S) \\approx 1.72312$ 比特。\n\n接下来，我们计算响应的边缘熵 $H(Y)$。为此，我们首先需要响应的边缘概率分布 $p(y)$，它可以通过全概率定律求得：\n$$p(y) = \\sum_{s \\in S} p(y|s)p(s)$$\n鉴于均匀先验分布 $p(s) = \\frac{1}{3}$：\n$p(y=0) = \\frac{1}{3} (p(0|s_1) + p(0|s_2) + p(0|s_3)) = \\frac{1}{3} (0.5 + 0.2 + 0.05) = \\frac{0.75}{3} = 0.25$\n$p(y=1) = \\frac{1}{3} (p(1|s_1) + p(1|s_2) + p(1|s_3)) = \\frac{1}{3} (0.3 + 0.4 + 0.15) = \\frac{0.85}{3}$\n$p(y=2) = \\frac{1}{3} (p(2|s_1) + p(2|s_2) + p(2|s_3)) = \\frac{1}{3} (0.15 + 0.3 + 0.35) = \\frac{0.80}{3}$\n$p(y=3) = \\frac{1}{3} (p(3|s_1) + p(3|s_2) + p(3|s_3)) = \\frac{1}{3} (0.05 + 0.1 + 0.45) = \\frac{0.60}{3} = 0.20$\n\n现在，我们计算边缘熵 $H(Y)$：\n$$H(Y) = -\\sum_{y \\in Y} p(y)\\log_2(p(y))$$\n$H(Y) = -[p(0)\\log_2(p(0)) + p(1)\\log_2(p(1)) + p(2)\\log_2(p(2)) + p(3)\\log_2(p(3))]$\n$H(Y) \\approx -[0.25(-2) + 0.28333(-1.8193) + 0.26667(-1.9069) + 0.20(-2.3219)]$\n$H(Y) \\approx -[-0.5 - 0.51547 - 0.50851 - 0.46438]$\n$H(Y) \\approx 1.98838$ 比特。\n\n最后，我们计算互信息 $I(S;Y)$：\n$I(S;Y) = H(Y) - H(Y|S) \\approx 1.98838 - 1.72312 = 0.26526$ 比特。\n四舍五入到四位有效数字，我们得到 $0.2653$ 比特。\n\n问题的第二部分要求解释当刺激强度增加超过 $s_3$ 时，脉冲计数的饱和现象对 $I(S;Y)$ 意味着什么。\n神经响应饱和意味着，对于大于某个水平（本例中为超过 $s_3$）的刺激强度 $s$，脉冲计数响应分布 $p(y|s)$ 不再发生显著变化。例如，对于一个刺激 $s_4 > s_3$，我们会有 $p(y|s_4) \\approx p(y|s_3)$。互信息 $I(S;Y)$ 衡量了利用响应 $Y$ 来区分 $S$ 中不同刺激的能力。如果多个不同的高强度刺激（例如 $s_3, s_4, s_5, \\dots$）都产生相同的统计响应，那么基于观察到的脉冲计数 $Y$ 就无法区分它们。虽然增加刺激水平的数量会增加刺激集 $S$ 的总熵 $H(S)$，但传输的信息 $I(S;Y)$ 不会成比例地增加。无法区分这些饱和的刺激意味着，在给定响应的情况下关于刺激的不确定性 $H(S|Y)$ 会与 $H(S)$ 一同增长，导致它们的差值 $I(S;Y)$ 达到一个平台期。由类器官形成的信息通道饱和了，这表明系统能够编码的关于刺激强度的信息量存在一个上限。本质上，不同的输入被映射到统计上无法区分的输出，从而导致了信息传输的瓶颈。",
            "answer": "$$\n\\boxed{0.2653}\n$$"
        },
        {
            "introduction": "在获得了多通道数据（例如来自MEA的记录）之后，下一个关键步骤是从这些观测活动中推断网络的功能连接结构。格兰杰因果（Granger causality）是一种广泛应用的统计方法，用于从时间序列数据中识别有向的功能性连接。本练习将指导您在一个向量自回归（VAR）模型框架下，实现格兰杰因果分析，以推断不同电极通道之间的信息流方向。您还将探讨并处理一个在网络推断中至关重要的问题：如何通过条件格兰杰因果分析来区分直接连接和由共同输入引起的伪连接 。",
            "id": "4037977",
            "problem": "给定一项指令，要求您设计并实现一种算法，该算法在向量自回归（VAR）框架内使用格兰杰因果关系（GC）来推断从生物混合系统（例如，装有多个电极的类器官网络）记录的通道之间的有向连接性。从格兰杰杰因果关系的公认定义开始：如果时间序列 $x_t$ 的过去值包含了关于 $y_t$ 的独特预测信息，而这些信息超出了仅由 $y_t$ 自身过去值所包含的信息，则称时间序列 $x_t$ 格兰杰导致（Granger-cause）时间序列 $y_t$。使用适当阶数的 VAR 模型和通过普通最小二乘法（OLS）进行嵌套假设检验的原则，来推导并实现一个有向连接性的检验。通过计算双变量 GC（忽略共同输入）和条件 GC（包含一个记录的共同输入通道以控制混淆）来明确地处理共同输入的情况。从第一性原理和标准假设出发，论证在存在共同输入的情况下，实现因果可识别性的条件。\n\n您必须生成一个完整的、可运行的程序，该程序能够：\n- 根据指定的测试用例，使用一个稳定的 $p$ 阶向量自回归（VAR）模型来模拟多通道时间序列：\n$$\n\\mathbf{y}_t = \\sum_{k=1}^{p} \\mathbf{A}_k \\mathbf{y}_{t-k} + \\mathbf{e}_t,\n$$\n其中 $\\mathbf{y}_t \\in \\mathbb{R}^n$ 是时间 $t$ 的通道向量，$\\mathbf{A}_k \\in \\mathbb{R}^{n \\times n}$ 是滞后系数矩阵，$\\mathbf{e}_t \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma})$ 是协方差为 $\\boldsymbol{\\Sigma}$ 的零均值高斯新息噪声。必须通过选择系数以使伴随矩阵的谱半径小于 $1$ 来确保稳定性。\n\n- 对于每个有向对 $(x \\to y)$，拟合一个包含所有相关通道滞后项的无约束 OLS 回归，以及一个排除驱动通道滞后项的有约束 OLS 回归。使用嵌套模型框架计算格兰杰因果关系 $F$ 统计量及其在用户定义的显著性阈值 $\\alpha$（以小数表示）下的显著性水平。\n\n- 对于每次检验，从候选阶数中使用贝叶斯信息准则（BIC）来选择 VAR 阶数 $p$。BIC 从目标通道的无约束回归中计算。考虑候选集 $p \\in \\{1, 2\\}$，并选择使 BIC 最小化的 $p$。\n\n- 对于每个测试用例，计算四个布尔值输出，指示在 $\\alpha$ 水平上存在显著的有向连接性：\n    $[\\text{X}\\to\\text{Y (双变量)},\\ \\text{Y}\\to\\text{X (双变量)},\\ \\text{X}\\to\\text{Y (条件)},\\ \\text{Y}\\to\\text{X (条件)}]$。\n\n应使用的科学依据和假设：\n- 时域中的格兰杰因果关系（GC）定义：如果在给定所有其他包含变量的条件下，包含 $x_t$ 的过去值相比于排除 $x_t$ 过去值的模型能减少 $y_t$ 的预测误差方差，则 $x_t$ 格兰杰导致 $y_t$。\n- 在高斯新息假设下，普通最小二乘法（OLS）为线性 VAR 模型提供了最大似然估计量，从而在标准正则性条件下能够进行有效的 $F$ 检验。\n- 用于模型阶数选择的贝叶斯信息准则（BIC）：对于一个具有 $n_{\\text{eff}}$ 个样本、残差平方和为 $\\text{RSS}$ 和 $k$ 个参数的 OLS 回归，BIC 为\n$$\n\\text{BIC} = n_{\\text{eff}} \\cdot \\ln\\left(\\frac{\\text{RSS}}{n_{\\text{eff}}}\\right) + k \\cdot \\ln(n_{\\text{eff}}).\n$$\n\n检验框架和显著性计算：\n- 对于有向检验 $x \\to y$，选择滞后阶数 $p$ 和大小为 $d$ 的通道集，定义无约束回归，其具有 $k_u = d \\cdot p$ 个参数（无截距），用所有包含通道的滞后值预测 $y_t$；以及有约束回归，其从预测变量中移除了 $x_t$ 的 $p$ 个滞后项，从而得到 $k_r = (d-1) \\cdot p$ 个参数。对于 $n_{\\text{eff}} = T - p$ 个有效样本以及残差平方和 $\\text{RSS}_u$ 和 $\\text{RSS}_r$，计算 $F$ 统计量：\n$$\nF = \\frac{\\left(\\text{RSS}_r - \\text{RSS}_u\\right) / m}{\\text{RSS}_u / (n_{\\text{eff}} - k_u)},\n$$\n其中 $m = p$ 是线性约束的数量。在原假设（即 $x_t$ 不格兰杰导致 $y_t$）下，$F$ 服从自由度为 $(m, n_{\\text{eff}} - k_u)$ 的 $F$ 分布。计算 $p$ 值，如果 $p$ 值小于 $\\alpha$ 且 $\\text{RSS}_r > \\text{RSS}_u$，则宣告显著。\n\n存在共同输入时的因果可识别性条件：\n- 为了减轻由同时驱动 $x_t$ 和 $y_t$ 的共同输入 $z_t$ 引起的伪因果关系，条件 GC 必须在 VAR 模型中包含已记录的 $z_t$。如果共同输入被记录并包含在内，并且通道间的新息不相关，则在平稳性和模型阶数正确的情况下，条件 GC 检验能够渐近地识别有向连接性。\n- 如果存在一个潜在的未记录的共同输入，可识别性可能会失败；有助于识别的条件包括：观测变量足以阻断所有后门路径、新息的独立性和白噪声特性、不存在瞬时（零滞后）耦合，以及使用正确的滞后阶数以捕捉真实动态。\n\n使用以下测试套件来模拟数据并评估算法。在所有情况下，将显著性阈值设置为 $\\alpha = 0.01$，候选滞后阶数设置为 $p \\in \\{1, 2\\}$，随机种子设置为 $0$。通道索引为 $X \\equiv 0$, $Y \\equiv 1$, $Z \\equiv 2$。\n\n- 测试用例 1（存在共同输入和真实有向边的理想情况）：$T = 1024$, $n = 3$, $\\mathbf{A}_1$ 和 $\\mathbf{A}_2$ 由下式给出\n$$\n\\mathbf{A}_1 = \\begin{bmatrix}\n0.2  0.0  0.3 \\\\\n0.5  0.2  0.4 \\\\\n0.0  0.0  0.3\n\\end{bmatrix}, \\quad\n\\mathbf{A}_2 = \\begin{bmatrix}\n0.0  0.0  0.0 \\\\\n0.0  0.0  0.0 \\\\\n0.0  0.0  0.0\n\\end{bmatrix},\n$$\n其中 $\\boldsymbol{\\Sigma} = \\sigma^2 \\mathbf{I}$，$\\sigma = 0.5$。\n\n- 测试用例 2（纯共同输入，X 和 Y 之间无直接边）：$T = 1024$, $n = 3$,\n$$\n\\mathbf{A}_1 = \\begin{bmatrix}\n0.2  0.0  0.5 \\\\\n0.0  0.2  0.5 \\\\\n0.0  0.0  0.3\n\\end{bmatrix}, \\quad\n\\mathbf{A}_2 = \\mathbf{0}_{3 \\times 3},\n$$\n其中 $\\sigma = 0.5$。\n\n- 测试用例 3（弱耦合和低信噪比）：$T = 1024$, $n = 3$,\n$$\n\\mathbf{A}_1 = \\begin{bmatrix}\n0.2  0.0  0.0 \\\\\n0.15  0.2  0.0 \\\\\n0.0  0.0  0.3\n\\end{bmatrix}, \\quad\n\\mathbf{A}_2 = \\mathbf{0}_{3 \\times 3},\n$$\n其中 $\\sigma = 1.0$。\n\n- 测试用例 4（无共同输入的双向耦合）：$T = 1024$, $n = 3$,\n$$\n\\mathbf{A}_1 = \\begin{bmatrix}\n0.2  0.25  0.0 \\\\\n0.35  0.2  0.0 \\\\\n0.0  0.0  0.3\n\\end{bmatrix}, \\quad\n\\mathbf{A}_2 = \\mathbf{0}_{3 \\times 3},\n$$\n其中 $\\sigma = 0.5$。\n\n- 测试用例 5（记录长度较短的边界情况）：$T = 64$, $n = 3$,\n$$\n\\mathbf{A}_1 = \\begin{bmatrix}\n0.1  0.0  0.3 \\\\\n0.3  0.1  0.2 \\\\\n0.0  0.0  0.2\n\\end{bmatrix}, \\quad\n\\mathbf{A}_2 = \\mathbf{0}_{3 \\times 3},\n$$\n其中 $\\sigma = 0.5$。\n\n程序要求：\n- 针对每种情况，使用指定的 $\\mathbf{A}_k$ 和 $\\boldsymbol{\\Sigma}$ 实现模拟。\n- 对于每个测试用例，计算四个布尔值 GC 显著性指标：双变量 $X \\to Y$、双变量 $Y \\to X$、包含 $Z$ 的条件 $X \\to Y$、包含 $Z$ 的条件 $Y \\to X$，每个都在 $\\alpha = 0.01$ 水平下进行。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个测试用例的结果以指定顺序的四个布尔值列表报告。例如：\n$[\\,[\\text{true},\\text{false},\\text{true},\\text{false}],\\ldots\\,]$。",
            "solution": "从多通道时间序列中推断有向连接性的问题对于理解复杂系统至关重要，尤其是在神经科学和生物混合计算领域，在这些领域中，电极阵列记录了神经网络或类器官的活动。所提出的任务是实现格兰杰因果关系（GC）分析，这是一种为此目的广泛使用的统计方法，其基础是向量自回归（VAR）框架。该问题在科学上是有效的、定义明确的，并为稳健的计算实现提供了完整的规范。\n\n格兰杰因果关系的核心原则是预测性。如果时间序列 $x_t$ 的过去值包含有助于比仅使用 $y_t$ 的过去值更好地预测 $y_t$ 未来值的信息，则称 $x_t$ 格兰杰导致（Granger-cause）另一个时间序列 $y_t$。这个概念通过比较两个嵌套线性回归模型的假设检验来实现操作化。\n\n系统的动态由一个 $p$ 阶的 VAR 过程建模。对于一个具有时间序列数据 $\\mathbf{y}_t \\in \\mathbb{R}^n$ 的 $n$ 通道系统，模型为：\n$$\n\\mathbf{y}_t = \\sum_{k=1}^{p} \\mathbf{A}_k \\mathbf{y}_{t-k} + \\mathbf{e}_t\n$$\n在这里，$\\mathbf{A}_k \\in \\mathbb{R}^{n \\times n}$ 是滞后 $k$ 的系数矩阵，$\\mathbf{e}_t$ 是一个零均值高斯新息噪声向量，$\\mathbf{e}_t \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma})$。$\\mathbf{A}_k$ 矩阵的非对角元素表示一个通道在那个滞后上对另一个通道的线性影响。一个非零条目 $A_k[i, j]$ 意味着通道 $j$ 在滞后 $k$ 时影响通道 $i$。如果至少有一个系数 $A_k[i, j]$（对于 $k=1, \\dots, p$）非零，则存在从通道 $j$到通道 $i$ 的格兰杰因果关系。\n\n对于待检验的每对有向通道（例如，$X \\to Y$），算法按几个不同的步骤进行。\n\n首先，我们必须为每个测试用例模拟数据。根据指定的方程生成一个稳定的 VAR 过程。我们生成 $T + T_{\\text{burn-in}}$ 个样本，并丢弃前 $T_{\\text{burn-in}}$ 个，以使过程达到其平稳分布，确保所分析数据的统计特性是时不变的。过程的稳定性（通过确保 VAR 伴随矩阵的谱半径小于 1 来保证）是有效 GC 分析的先决条件。\n\n其次，对于每个特定的检验（例如，双变量 $X \\to Y$，或给定 $Z$ 的条件 $X \\to Y$），我们必须选择一个合适的模型阶数 $p$。一个太低的阶数可能无法捕捉到真实的动态，而一个太高的阶数可能会过拟合数据。贝叶斯信息准则（BIC）提供了一种在模型拟合度与简约性之间进行权衡的原则性方法。对于每个候选滞后阶数 $p \\in \\{1, 2\\}$，我们拟合一个*无约束*线性模型，用检验中包含的所有通道的过去 $p$ 个值来预测目标通道。BIC 计算如下：\n$$\n\\text{BIC} = n_{\\text{eff}} \\cdot \\ln\\left(\\frac{\\text{RSS}}{n_{\\text{eff}}}\\right) + k \\cdot \\ln(n_{\\text{eff}})\n$$\n其中 $n_{\\text{eff}} = T - p$ 是有效样本数，$\\text{RSS}$ 是普通最小二乘法（OLS）拟合的残差平方和， $k$ 是模型中的参数数量（对于 $d$ 个包含的通道， $k = d \\cdot p$）。选择产生最小 BIC 的滞后阶数 $p$ 用于假设检验。此选择过程对一个案例中的四个检验（双变量 $X \\to Y$、双变量 $Y \\to X$、条件 $X \\to Y$、条件 $Y \\to X$）是独立执行的，因为包含的变量集合以及因此的 BIC 可能会有所不同。\n\n第三，使用选定的阶数 $p$，我们进行假设检验。为了检验 $X \\to Y$，我们比较两个模型：\n1.  **无约束模型** ($M_u$)，它使用所有包含通道（例如，对于双变量，使用 $X$ 和 $Y$；对于条件，使用 $X, Y, Z$）的 $p$ 个滞后值来预测 $Y_t$。该模型有 $k_u = d \\cdot p$ 个参数，并产生残差平方和 $\\text{RSS}_u$。\n2.  **有约束模型** ($M_r$)，它使用除源通道 $X$ 之外的所有包含通道的 $p$ 个滞后值来预测 $Y_t$。该模型有 $k_r = (d-1) \\cdot p$ 个参数，并产生 $\\text{RSS}_r$。\n\n原假设（$H_0$）是 $X$ 不格兰杰导致 $Y$，这对应于 $X$ 的滞后项的 $p$ 个系数联合为零。如果 $H_0$ 为真，当移除这些预测变量时，RSS 不应有统计上显著的增加，即 $\\text{RSS}_r$ 不应显著大于 $\\text{RSS}_u$。我们用 $F$ 统计量来量化这一点：\n$$\nF = \\frac{\\left(\\text{RSS}_r - \\text{RSS}_u\\right) / m}{\\text{RSS}_u / (n_{\\text{eff}} - k_u)}\n$$\n其中 $m = p$ 是约束的数量（被省略的参数数量）。在 $H_0$ 下，该统计量服从自由度为 $(m, n_{\\text{eff}} - k_u)$ 的 $F$ 分布。我们根据此分布计算 $p$ 值。如果 $p$ 值小于显著性水平 $\\alpha$（且 $\\text{RSS}_r > \\text{RSS}_u$），我们就拒绝 $H_0$，并得出结论，存在显著的格兰杰因果关系。\n\n因果推断的一个关键方面是处理混淆变量。在我们的系统背景下，一个同时驱动 $X$ 和 $Y$ 的共同输入 $Z$ 会引起伪相关，而双变量 GC 检验（仅考虑 $X$ 和 $Y$）可能会错误地将其解释为直接的因果联系。**条件格兰杰因果关系**通过在无约束和有约束模型中都包含潜在的混淆变量 $Z$ 来解决这个问题。这样，我们检验的是在考虑了来自 $Y$ 自身过去和 $Z$ 过去的预测信息*之后*，$X$ 的过去所具有的预测能力。如果通道 $Z$ 确实是唯一的共同驱动因素，并且被成功记录并包含在模型中，那么条件 GC 就可以正确地区分直接因果关系（$X \\to Y$）和由共同驱动因素引起的伪相关。这突显了因果可识别性的一个关键条件：所有重要的共同驱动因素（即创建“后门路径”的混淆变量）都必须被观察到并作为条件。\n\n所提供的实现遵循了这些原则。一个 `simulate_var` 函数生成时间序列。一个辅助函数 `prepare_regression_mats` 为 OLS 模型构建必要的数据矩阵。核心函数 `granger_causality_test` 协调基于 BIC 的模型选择和随后的 F 检验，以得出布尔值的显著性结果。主 `solve` 函数遍历指定的测试用例，应用 GC 检验，并按要求格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import f as f_dist\n\ndef solve():\n    \"\"\"\n    Main function to run the Granger causality analysis on all test cases.\n    \"\"\"\n    # Test cases defined in the problem statement\n    test_cases = [\n        {\n            \"T\": 1024, \"n\": 3, \"sigma\": 0.5,\n            \"A_mats\": [\n                np.array([[0.2, 0.0, 0.3], [0.5, 0.2, 0.4], [0.0, 0.0, 0.3]]),\n                np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n            ]\n        },\n        {\n            \"T\": 1024, \"n\": 3, \"sigma\": 0.5,\n            \"A_mats\": [\n                np.array([[0.2, 0.0, 0.5], [0.0, 0.2, 0.5], [0.0, 0.0, 0.3]]),\n                np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n            ]\n        },\n        {\n            \"T\": 1024, \"n\": 3, \"sigma\": 1.0,\n            \"A_mats\": [\n                np.array([[0.2, 0.0, 0.0], [0.15, 0.2, 0.0], [0.0, 0.0, 0.3]]),\n                np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n            ]\n        },\n        {\n            \"T\": 1024, \"n\": 3, \"sigma\": 0.5,\n            \"A_mats\": [\n                np.array([[0.2, 0.25, 0.0], [0.35, 0.2, 0.0], [0.0, 0.0, 0.3]]),\n                np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n            ]\n        },\n        {\n            \"T\": 64, \"n\": 3, \"sigma\": 0.5,\n            \"A_mats\": [\n                np.array([[0.1, 0.0, 0.3], [0.3, 0.1, 0.2], [0.0, 0.0, 0.2]]),\n                np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]])\n            ]\n        }\n    ]\n\n    alpha = 0.01\n    candidate_lags = [1, 2]\n    np.random.seed(0)\n    \n    all_results = []\n    \n    for case_params in test_cases:\n        data = simulate_var(\n            T=case_params[\"T\"],\n            n=case_params[\"n\"],\n            A_mats=case_params[\"A_mats\"],\n            sigma=case_params[\"sigma\"]\n        )\n        \n        # Channel indices\n        X, Y, Z = 0, 1, 2\n        \n        case_results = []\n        \n        # Bivariate X -> Y\n        res_bv_xy = granger_causality_test(data, X, Y, [], candidate_lags, alpha)\n        case_results.append(res_bv_xy)\n        \n        # Bivariate Y -> X\n        res_bv_yx = granger_causality_test(data, Y, X, [], candidate_lags, alpha)\n        case_results.append(res_bv_yx)\n        \n        # Conditional X -> Y | Z\n        res_cond_xy = granger_causality_test(data, X, Y, [Z], candidate_lags, alpha)\n        case_results.append(res_cond_xy)\n        \n        # Conditional Y -> X | Z\n        res_cond_yx = granger_causality_test(data, Y, X, [Z], candidate_lags, alpha)\n        case_results.append(res_cond_yx)\n        \n        all_results.append(case_results)\n\n    # Format the final output string\n    str_results = [f\"[{','.join(str(b).lower() for b in res)}]\" for res in all_results]\n    final_output = f\"[{','.join(str_results)}]\"\n    print(final_output)\n\ndef simulate_var(T, n, A_mats, sigma):\n    \"\"\"\n    Simulates a stable Vector Autoregressive (VAR) process.\n    \"\"\"\n    burn_in = 100\n    p_gen = len(A_mats)\n    total_T = T + burn_in\n    \n    Y = np.zeros((total_T, n))\n    noise = np.random.randn(total_T, n) * sigma\n    \n    for t in range(p_gen, total_T):\n        y_t = np.zeros(n)\n        for k in range(p_gen):\n            y_t += A_mats[k] @ Y[t - k - 1, :]\n        Y[t, :] = y_t + noise[t, :]\n        \n    return Y[burn_in:, :]\n\ndef prepare_regression_mats(data, p, regressor_indices, target_idx):\n    \"\"\"\n    Constructs the response vector (y_vec) and predictor matrix (X_mat) for OLS.\n    \"\"\"\n    T, _ = data.shape\n    n_eff = T - p\n    \n    y_vec = data[p:, target_idx]\n    \n    num_regressors = len(regressor_indices)\n    X_mat = np.zeros((n_eff, num_regressors * p))\n    \n    col_idx = 0\n    for idx in regressor_indices:\n        for lag in range(1, p + 1):\n            X_mat[:, col_idx] = data[p - lag : T - lag, idx]\n            col_idx += 1\n            \n    return y_vec, X_mat\n\ndef granger_causality_test(data, source_idx, target_idx, conditioning_indices, candidate_lags, alpha):\n    \"\"\"\n    Performs a Granger causality test from a source to a target channel.\n    \"\"\"\n    T = data.shape[0]\n    all_indices = sorted(list(set([source_idx, target_idx] + conditioning_indices)))\n    \n    # 1. Model order selection using BIC on the unrestricted model\n    best_p = -1\n    min_bic = np.inf\n\n    for p in candidate_lags:\n        if T = p: continue\n        \n        y_vec, X_u = prepare_regression_mats(data, p, all_indices, target_idx)\n        n_eff = len(y_vec)\n        k_u = X_u.shape[1]\n\n        if k_u >= n_eff: continue\n\n        # lstsq returns sum of squared residuals in the second element of the tuple\n        residuals = np.linalg.lstsq(X_u, y_vec, rcond=None)[1]\n        \n        if not residuals: # Perfect fit, RSS is 0\n            rss_u = 1e-10 # Use a small number to avoid log(0)\n        else:\n            rss_u = residuals[0]\n\n        bic = n_eff * np.log(rss_u / n_eff) + k_u * np.log(n_eff)\n        \n        if bic  min_bic:\n            min_bic = bic\n            best_p = p\n\n    if best_p == -1:\n        return False # Not enough data to select a model\n\n    # 2. Perform F-test with the selected lag order 'best_p'\n    p = best_p\n    \n    # Unrestricted model\n    y_vec, X_u = prepare_regression_mats(data, p, all_indices, target_idx)\n    \n    # Restricted model (omitting the source channel's lags)\n    restricted_indices = [idx for idx in all_indices if idx != source_idx]\n    _, X_r = prepare_regression_mats(data, p, restricted_indices, target_idx)\n    \n    n_eff = len(y_vec)\n    k_u = X_u.shape[1]\n\n    # Check if the unrestricted model is solvable\n    if k_u >= n_eff:\n        return False\n\n    rss_u_val = np.linalg.lstsq(X_u, y_vec, rcond=None)[1]\n    rss_r_val = np.linalg.lstsq(X_r, y_vec, rcond=None)[1]\n    \n    rss_u = rss_u_val[0] if rss_u_val else 0.0\n    rss_r = rss_r_val[0] if rss_r_val else 0.0\n\n    if rss_r = rss_u or rss_u == 0:\n        # If restriction doesn't worsen the fit or the fit is already perfect, H0 is not rejected.\n        return False\n        \n    m = p  # number of restrictions\n    df1 = m\n    df2 = n_eff - k_u\n\n    if df2 = 0:\n        return False # Cannot compute the F-statistic\n\n    F_stat = ((rss_r - rss_u) / df1) / (rss_u / df2)\n    p_value = f_dist.sf(F_stat, df1, df2)\n\n    return p_value  alpha\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}