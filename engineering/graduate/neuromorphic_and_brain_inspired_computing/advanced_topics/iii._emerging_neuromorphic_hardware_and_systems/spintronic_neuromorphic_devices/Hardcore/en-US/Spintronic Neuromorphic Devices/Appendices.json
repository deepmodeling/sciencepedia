{
    "hands_on_practices": [
        {
            "introduction": "A solid grasp of spintronic devices begins with the fundamental physics of spin transport. In these systems, information is encoded not just by charge, but by the intrinsic angular momentum of electrons—their spin. This practice () takes you back to first principles, challenging you to derive the relationship between a macroscopic, measurable charge current density $J$ and the resulting flux of spin angular momentum. Mastering this foundational calculation is essential for understanding how electrical signals manipulate magnetic states in neuromorphic hardware.",
            "id": "4060763",
            "problem": "A ferromagnetic nanowire is used as a programmable synapse in a neuromorphic crossbar array. When a spin-polarized charge current density $J$ flows along the wire, the transport of spin angular momentum into a downstream functional region modulates local magnetic order and implements synaptic weight updates. Assume the following physically standard definitions:\n- The charge current density $J$ relates to the carrier number flux density through $J = q \\Phi$, where $q$ is the elementary charge magnitude and $\\Phi$ is the total electron number flux density (number per unit area per unit time).\n- The spin polarization $P$ along the magnetization axis is defined by $P = \\frac{\\Phi_{\\uparrow} - \\Phi_{\\downarrow}}{\\Phi_{\\uparrow} + \\Phi_{\\downarrow}}$, where $\\Phi_{\\uparrow}$ and $\\Phi_{\\downarrow}$ are the spin-resolved number flux densities aligned and anti-aligned with the magnetization, respectively.\n- Each electron carries spin angular momentum with projection magnitude $\\hbar/2$ along the quantization axis, where $\\hbar$ is the reduced Planck constant.\n\nStarting only from these definitions and fundamental constants, derive an expression for the magnitude of the spin angular momentum flux density (net spin angular momentum transported per unit area per unit time along the magnetization axis) in terms of $P$, $J$, $\\hbar$, and $e$ (the elementary charge). Then evaluate it numerically for a transport spin polarization $P = 0.72$ and a charge current density $J = 2.50 \\times 10^{10}\\ \\mathrm{A}\\,\\mathrm{m}^{-2}$.\n\nUse the exact International System of Units (SI) defined values $h = 6.62607015 \\times 10^{-34}\\ \\mathrm{J}\\,\\mathrm{s}$ and $e = 1.602176634 \\times 10^{-19}\\ \\mathrm{C}$, and take $\\hbar = \\frac{h}{2\\pi}$. Round your final numerical result to four significant figures. Express the final spin angular momentum flux density magnitude in $\\mathrm{J}\\,\\mathrm{m}^{-2}$.",
            "solution": "The problem has been validated and is found to be scientifically grounded, well-posed, and objective. It contains no inconsistencies or ambiguities. We may therefore proceed with the solution.\n\nThe problem asks for the derivation of an expression for the magnitude of the spin angular momentum flux density, which we shall denote as $J_S$. This quantity represents the net spin angular momentum transported per unit area per unit time. The transport is mediated by spin-polarized electrons.\n\nLet $\\Phi_{\\uparrow}$ be the number flux density of electrons with spin aligned with the magnetization axis (spin-up), and $\\Phi_{\\downarrow}$ be the number flux density of electrons with spin anti-aligned with the axis (spin-down). Each spin-up electron carries a spin angular momentum of $+\\frac{\\hbar}{2}$, and each spin-down electron carries $-\\frac{\\hbar}{2}$, where $\\hbar$ is the reduced Planck constant.\n\nThe spin angular momentum flux density from the spin-up electrons is the product of their number flux density and the angular momentum per electron: $J_{S,\\uparrow} = \\Phi_{\\uparrow} \\left(\\frac{\\hbar}{2}\\right)$.\nSimilarly, the flux density from the spin-down electrons is $J_{S,\\downarrow} = \\Phi_{\\downarrow} \\left(-\\frac{\\hbar}{2}\\right)$.\n\nThe net spin angular momentum flux density, $J_S$, is the sum of these two contributions:\n$$J_S = J_{S,\\uparrow} + J_{S,\\downarrow} = \\Phi_{\\uparrow} \\left(\\frac{\\hbar}{2}\\right) - \\Phi_{\\downarrow} \\left(\\frac{\\hbar}{2}\\right)$$\n$$J_S = \\frac{\\hbar}{2} (\\Phi_{\\uparrow} - \\Phi_{\\downarrow})$$\n\nWe must now express $(\\Phi_{\\uparrow} - \\Phi_{\\downarrow})$ in terms of the given quantities $P$, $J$, and $e$. The problem provides the definition for the spin polarization $P$:\n$$P = \\frac{\\Phi_{\\uparrow} - \\Phi_{\\downarrow}}{\\Phi_{\\uparrow} + \\Phi_{\\downarrow}}$$\nThe denominator, $\\Phi_{\\uparrow} + \\Phi_{\\downarrow}$, is the total electron number flux density, which we denote by $\\Phi$. So, $\\Phi = \\Phi_{\\uparrow} + \\Phi_{\\downarrow}$.\nSubstituting $\\Phi$ into the expression for $P$, we get:\n$$P = \\frac{\\Phi_{\\uparrow} - \\Phi_{\\downarrow}}{\\Phi}$$\nFrom this, we can express the difference in spin-resolved fluxes as:\n$$\\Phi_{\\uparrow} - \\Phi_{\\downarrow} = P \\Phi$$\n\nSubstituting this result into our equation for $J_S$:\n$$J_S = \\frac{\\hbar}{2} (P \\Phi) = \\frac{P \\hbar \\Phi}{2}$$\n\nThe final step is to relate the total electron number flux density $\\Phi$ to the charge current density $J$. The problem states that $J = q \\Phi$, where $q$ is the elementary charge magnitude. The problem also provides the symbol $e$ for the elementary charge. Thus, we have $q = e$.\n$$J = e \\Phi$$\nSolving for $\\Phi$ gives:\n$$\\Phi = \\frac{J}{e}$$\n\nNow we substitute this expression for $\\Phi$ into our equation for $J_S$:\n$$J_S = \\frac{P \\hbar}{2} \\left(\\frac{J}{e}\\right)$$\n$$J_S = \\frac{P \\hbar J}{2e}$$\nThis is the final derived expression for the magnitude of the spin angular momentum flux density.\n\nNext, we must evaluate this expression numerically. The given values are:\n- Spin polarization $P = 0.72$\n- Charge current density $J = 2.50 \\times 10^{10}\\ \\mathrm{A}\\,\\mathrm{m}^{-2}$\n- The elementary charge $e = 1.602176634 \\times 10^{-19}\\ \\mathrm{C}$\n- The Planck constant $h = 6.62607015 \\times 10^{-34}\\ \\mathrm{J}\\,\\mathrm{s}$\n- The reduced Planck constant is defined as $\\hbar = \\frac{h}{2\\pi}$.\n\nLet's substitute these values into the derived formula:\n$$J_S = \\frac{(0.72) \\left(\\frac{6.62607015 \\times 10^{-34}\\ \\mathrm{J}\\,\\mathrm{s}}{2\\pi}\\right) (2.50 \\times 10^{10}\\ \\mathrm{A}\\,\\mathrm{m}^{-2})}{2 (1.602176634 \\times 10^{-19}\\ \\mathrm{C})}$$\nThe units can be verified as correct. Since $1\\ \\mathrm{A} = 1\\ \\mathrm{C}/\\mathrm{s}$, the units become:\n$$\\frac{(\\mathrm{J}\\,\\mathrm{s}) (\\mathrm{C}\\,\\mathrm{s}^{-1}\\,\\mathrm{m}^{-2})}{(\\mathrm{C})} = \\mathrm{J}\\,\\mathrm{m}^{-2}$$\nThis matches the required units for the final answer.\n\nNow we perform the calculation:\nFirst, we calculate the reduced Planck constant $\\hbar$:\n$$\\hbar = \\frac{6.62607015 \\times 10^{-34}}{2\\pi} \\approx 1.054571817 \\times 10^{-34}\\ \\mathrm{J}\\,\\mathrm{s}$$\nThen, we calculate $J_S$:\n$$J_S = \\frac{(0.72) \\times (1.054571817 \\times 10^{-34}\\ \\mathrm{J}\\,\\mathrm{s}) \\times (2.50 \\times 10^{10}\\ \\mathrm{s}^{-1}\\,\\mathrm{m}^{-2} \\cdot e)}{2e}$$\nThe charge unit $e$ is now symbolic, let's use the numerical values:\n$$J_S = \\frac{(0.72) \\times (1.054571817 \\times 10^{-34}) \\times (2.50 \\times 10^{10})}{2 \\times (1.602176634 \\times 10^{-19})}\\ \\mathrm{J}\\,\\mathrm{m}^{-2}$$\n$$J_S = \\frac{1.89822927 \\times 10^{-24}}{3.204353268 \\times 10^{-19}}\\ \\mathrm{J}\\,\\mathrm{m}^{-2}$$\n$$J_S \\approx 5.923983 \\times 10^{-6}\\ \\mathrm{J}\\,\\mathrm{m}^{-2}$$\nThe problem requires the final numerical result to be rounded to four significant figures.\n$$J_S \\approx 5.924 \\times 10^{-6}\\ \\mathrm{J}\\,\\mathrm{m}^{-2}$$",
            "answer": "$$\\boxed{5.924 \\times 10^{-6}}$$"
        },
        {
            "introduction": "Having established the concept of spin current, we now apply it to model the core component of many spintronic systems: the Magnetic Tunnel Junction (MTJ). The functionality of an MTJ as a synapse or neuron relies on quantum mechanical tunneling through a thin insulating barrier, a phenomenon highly sensitive to the magnetic alignment of its layers. This advanced exercise () guides you through developing a quantum transport simulation from the ground up using the powerful Nonequilibrium Green's Function (NEGF) formalism. This provides invaluable hands-on experience in modeling the current-voltage characteristics that underpin device operation.",
            "id": "4060757",
            "problem": "You are tasked with deriving and implementing a Nonequilibrium Green's Function (NEGF) model for the tunneling current through a magnesium oxide (MgO) barrier in a spintronic magnetic tunnel junction, a central building block in spintronic neuromorphic devices. The barrier is modeled using a simple one-dimensional single-orbital tight-binding Hamiltonian with nearest-neighbor hopping and a linear electrostatic potential drop under bias. You must derive the current starting from first principles, implement the resulting model, and compute current–voltage characteristics for specified barrier parameters.\n\nDerivation requirements: Starting from the Landauer formalism and the NEGF definitions, derive the tunneling current expression. Use the following principle-based base:\n- The Landauer-Büttiker current formula for coherent transport: $$I(V) = \\frac{q}{h} \\int T(E,V)\\,\\big[f(E,\\mu_L) - f(E,\\mu_R)\\big]\\,dE,$$ where $q$ is the elementary charge, $h$ is Planck's constant, $T(E,V)$ is the transmission probability, $f(E,\\mu) = \\frac{1}{1+\\exp((E-\\mu)/(k_B T))}$ is the Fermi-Dirac distribution, $k_B$ is Boltzmann's constant, $T$ is temperature, and $\\mu_L$, $\\mu_R$ are electrochemical potentials of the left and right leads respectively.\n- The retarded Green's function definition for a finite device region under the wide-band limit (WBL) for contacts: $$G^r(E) = \\big[E + i\\eta - H(V) - \\Sigma_L - \\Sigma_R\\big]^{-1},$$ where $\\eta$ is a positive infinitesimal, $H(V)$ is the tight-binding Hamiltonian under bias, and $\\Sigma_{L,R}$ are self-energy matrices accounting for coupling to the leads.\n- The transmission in terms of NEGF quantities: $$T(E,V) = \\mathrm{Tr}\\left[\\Gamma_L G^r \\Gamma_R G^a\\right],$$ with $G^a = (G^r)^\\dagger$ and $\\Gamma_{L,R} = i\\left(\\Sigma_{L,R} - \\Sigma_{L,R}^\\dagger\\right)$.\n- Spin-resolved transport assuming two independent spin channels (spin up and spin down) with spin-dependent contact broadenings. The total transmission is the sum of spin-channel transmissions.\n\nDevice model specifics:\n- The device region is an $N$-site one-dimensional tight-binding chain representing the MgO barrier. The Hamiltonian has on-site energies and nearest-neighbor hopping:\n  $$H_{i,i}(V) = E_0 + \\phi_i(V), \\quad H_{i,i+1} = H_{i+1,i} = -t,$$\n  with $i = 1,\\dots,N-1$. The electrostatic potential drop across the barrier under bias $V$ is modeled as linear:\n  $$\\phi_i(V) = -V\\left(\\frac{i-1}{N-1} - \\frac{1}{2}\\right) \\quad \\text{for } N \\ge 2, \\quad \\phi_1(V) = 0 \\text{ if } N=1.$$\n  Here $V$ is in volts and, for electron energy in electronvolts, the electrostatic energy shift in the device equals the applied voltage in electronvolts by the identity $1\\,\\mathrm{V} = 1\\,\\mathrm{eV}/q$.\n- The leads are incorporated via WBL self-energies acting only on the device endpoints:\n  $$\\Sigma_L = -\\frac{i}{2}\\Gamma_L |1\\rangle\\langle 1|, \\quad \\Sigma_R = -\\frac{i}{2}\\Gamma_R |N\\rangle\\langle N|.$$\n- Spin dependence is introduced through spin-polarized lead broadenings with polarization parameter $P \\in [0,1]$ and baseline coupling $\\Gamma_0$:\n  - Parallel alignment (P): $$\\Gamma_{L,\\uparrow} = \\Gamma_0(1+P),\\ \\Gamma_{L,\\downarrow} = \\Gamma_0(1-P),\\ \\Gamma_{R,\\uparrow} = \\Gamma_0(1+P),\\ \\Gamma_{R,\\downarrow} = \\Gamma_0(1-P).$$\n  - Antiparallel alignment (AP): $$\\Gamma_{L,\\uparrow} = \\Gamma_0(1+P),\\ \\Gamma_{L,\\downarrow} = \\Gamma_0(1-P),\\ \\Gamma_{R,\\uparrow} = \\Gamma_0(1-P),\\ \\Gamma_{R,\\downarrow} = \\Gamma_0(1+P).$$\n- The Fermi energy is $E_F = 0\\,\\mathrm{eV}$; the lead electrochemical potentials under bias are $$\\mu_L = E_F + \\frac{V}{2}, \\quad \\mu_R = E_F - \\frac{V}{2}.$$\n- The spin-resolved transmission under WBL at the endpoints reduces to $$T_\\sigma(E,V) = \\Gamma_{L,\\sigma}\\,\\Gamma_{R,\\sigma}\\,\\left|G^r_{1N}(E,V)\\right|^2,$$ and the total transmission is $$T(E,V) = T_\\uparrow(E,V)+T_\\downarrow(E,V).$$\n\nNumerical implementation details:\n- Energy integration is carried out over electron energy in electronvolts. The current should be computed as $$I(V) = \\frac{q^2}{h} \\int T(E,V)\\,\\big[f(E,\\mu_L) - f(E,\\mu_R)\\big]\\,dE_{\\mathrm{eV}},$$ using $k_B$ in $\\mathrm{eV}/\\mathrm{K}$ for numerical stability. Here $dE_{\\mathrm{eV}}$ is integration over energy in electronvolts and the prefactor $q^2/h$ restores SI units (amperes).\n- Use a sufficiently wide and dense energy grid, for example $E \\in [-5,5]\\,\\mathrm{eV}$ with a uniform discretization. Use a small positive $\\eta$ to ensure numerical stability in matrix inversion.\n- Use temperature $T$ in kelvin.\n\nTask:\n1. Derive the NEGF expression for $I(V)$ given the above model, showing how the spin-resolved broadenings enter the transmission and how the tight-binding Hamiltonian is constructed under bias.\n2. Implement a program that, for each test case below, computes the currents at biases $V \\in \\{0.0, 0.1, 0.5\\}\\,\\mathrm{V}$, expresses the currents in amperes, and outputs them in the required format.\n\nPhysical units and output specification:\n- Express all computed currents in amperes (A).\n- The final program output must be a single line containing the results as a comma-separated list enclosed in square brackets, in the order defined by the test suite and voltages. For each test case, list currents at $V=0.0\\,\\mathrm{V}$, then $V=0.1\\,\\mathrm{V}$, then $V=0.5\\,\\mathrm{V}$, before moving to the next test case.\n- Angles are not part of this task.\n- Percentages are represented as decimal numbers, not with a percentage sign.\n\nTest suite:\nCompute currents for the following four test cases. Each test case specifies $(N, a, E_0, t, \\Gamma_0, P, \\text{alignment}, T)$:\n- Case $1$: $N = 5$, $a = 0.21\\,\\mathrm{nm}$, $E_0 = 3.5\\,\\mathrm{eV}$, $t = 0.8\\,\\mathrm{eV}$, $\\Gamma_0 = 0.5\\,\\mathrm{eV}$, $P = 0.6$, alignment $=$ parallel, $T = 300\\,\\mathrm{K}$.\n- Case $2$: $N = 1$, $a = 0.21\\,\\mathrm{nm}$, $E_0 = 1.5\\,\\mathrm{eV}$, $t = 1.0\\,\\mathrm{eV}$, $\\Gamma_0 = 0.5\\,\\mathrm{eV}$, $P = 0.6$, alignment $=$ parallel, $T = 300\\,\\mathrm{K}$.\n- Case $3$: $N = 10$, $a = 0.21\\,\\mathrm{nm}$, $E_0 = 3.5\\,\\mathrm{eV}$, $t = 0.8\\,\\mathrm{eV}$, $\\Gamma_0 = 0.5\\,\\mathrm{eV}$, $P = 0.6$, alignment $=$ antiparallel, $T = 300\\,\\mathrm{K}$.\n- Case $4$: $N = 5$, $a = 0.21\\,\\mathrm{nm}$, $E_0 = 3.5\\,\\mathrm{eV}$, $t = 0.8\\,\\mathrm{eV}$, $\\Gamma_0 = 0.5\\,\\mathrm{eV}$, $P = 0.0$, alignment $=$ parallel, $T = 300\\,\\mathrm{K}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$), ordered as $\\left[ I_{1}(0.0), I_{1}(0.1), I_{1}(0.5), I_{2}(0.0), I_{2}(0.1), I_{2}(0.5), I_{3}(0.0), I_{3}(0.1), I_{3}(0.5), I_{4}(0.0), I_{4}(0.1), I_{4}(0.5) \\right]$, where $I_{k}(V)$ denotes the current for Case $k$ at bias $V$ in amperes.",
            "solution": "The problem requires the derivation and implementation of a Nonequilibrium Green's Function (NEGF) model to calculate the tunneling current through a Magnetic Tunnel Junction (MTJ). The solution proceeds by first deriving the analytical expressions from the provided principles and then detailing the numerical algorithm for computation.\n\n### Preamble: Validation of the Problem Statement\nThe problem statement has been validated against the required criteria.\n1.  **Givens Extraction**: All physical quantities, equations, model parameters, and test cases have been extracted verbatim. The parameter $a$, the inter-site distance, is provided but does not enter the tight-binding model equations, where the hopping parameter $t$ is the relevant quantity. This is a common simplification in such models and does not constitute a contradiction. Similarly, for the $N=1$ case, the hopping parameter $t$ is given but is not used, as a single-site system has no hopping. These do not invalidate the problem.\n2.  **Validation**:\n    *   **Scientific Grounding**: The problem is well-grounded in the standard theoretical framework of quantum transport in mesoscopic systems, specifically the Landauer-Büttiker formalism combined with NEGF. The tight-binding approximation, Wide-Band Limit (WBL), and linear potential drop are standard and valid simplifications for this class of problems.\n    *   **Well-Posedness and Consistency**: The problem is self-contained, with all necessary equations and parameters specified. There are no contradictions. A unique, stable numerical solution can be computed.\n    *   **Objectivity**: The problem is stated in precise, objective, scientific language.\nThus, the problem is deemed **valid**.\n\n### Part 1: Derivation of the Tunneling Current Expression\n\nThe objective is to compute the current $I$ as a function of the applied bias voltage $V$. We start from the provided Landauer-Büttiker formula, which expresses the current in terms of the transmission probability $T(E, V)$ and the Fermi-Dirac distributions of the contacts.\n\nThe current is given by:\n$$I(V) = \\frac{q}{h} \\int_{-\\infty}^{\\infty} T(E,V)\\,\\big[f(E,\\mu_L) - f(E,\\mu_R)\\big]\\,dE$$\nwhere $q$ is the elementary charge, $h$ is Planck's constant, $E$ is the electron energy, and $f(E,\\mu)$ is the Fermi-Dirac distribution.\nThe electrochemical potentials of the left (L) and right (R) leads are symmetrically biased around the Fermi energy $E_F = 0\\,\\mathrm{eV}$:\n$$\\mu_L = E_F + \\frac{V}{2} = \\frac{V}{2} \\quad \\text{and} \\quad \\mu_R = E_F - \\frac{V}{2} = -\\frac{V}{2}$$\nThe Fermi-Dirac distribution is $f(E,\\mu) = \\frac{1}{1+\\exp((E-\\mu)/(k_B T))}$, where $k_B$ is the Boltzmann constant and $T$ is the temperature.\n\nThe problem specifies spin-resolved transport, where the total transmission $T(E,V)$ is the sum of transmissions through the spin-up ($\\uparrow$) and spin-down ($\\downarrow$) channels:\n$$T(E,V) = T_\\uparrow(E,V) + T_\\downarrow(E,V)$$\nThe transmission for each spin channel $\\sigma \\in \\{\\uparrow, \\downarrow\\}$ is given in terms of NEGF quantities. For the specified model where contacts couple only to the endpoints of a 1D chain (sites $1$ and $N$), this simplifies to:\n$$T_\\sigma(E,V) = \\Gamma_{L,\\sigma}\\,\\Gamma_{R,\\sigma}\\,\\left|G^r_{1N,\\sigma}(E,V)\\right|^2$$\nHere, $\\Gamma_{L,\\sigma}$ and $\\Gamma_{R,\\sigma}$ are the broadening functions (escape rates) for spin $\\sigma$ into the left and right leads, respectively. $G^r_{1N,\\sigma}(E,V)$ is the $(1,N)$-th element of the retarded Green's function matrix for the spin channel $\\sigma$.\n\nThe spin-dependent broadenings are defined by the polarization $P$ and the baseline coupling strength $\\Gamma_0$.\nFor **parallel (P) alignment**:\n$$\\Gamma_{L,\\uparrow} = \\Gamma_{R,\\uparrow} = \\Gamma_0(1+P) \\quad \\text{and} \\quad \\Gamma_{L,\\downarrow} = \\Gamma_{R,\\downarrow} = \\Gamma_0(1-P)$$\nFor **antiparallel (AP) alignment**:\n$$\\Gamma_{L,\\uparrow} = \\Gamma_0(1+P), \\quad \\Gamma_{L,\\downarrow} = \\Gamma_0(1-P)$$\n$$\\Gamma_{R,\\uparrow} = \\Gamma_0(1-P), \\quad \\Gamma_{R,\\downarrow} = \\Gamma_0(1+P)$$\n\nThe retarded Green's function $G^r_{\\sigma}$ for each spin channel is obtained by inverting a matrix:\n$$G^r_{\\sigma}(E,V) = \\Big[ (E + i\\eta)\\mathbb{I} - H(V) - \\Sigma_{L,\\sigma} - \\Sigma_{R,\\sigma} \\Big]^{-1}$$\nwhere $\\eta$ is a positive infinitesimal, $\\mathbb{I}$ is the identity matrix, $H(V)$ is the device Hamiltonian, and $\\Sigma_{L/R,\\sigma}$ are the self-energy matrices describing the coupling to the leads. The Hamiltonian $H(V)$ is assumed to be spin-independent in this model.\n\nThe $N \\times N$ tight-binding Hamiltonian matrix $H(V)$ is tridiagonal:\n-   On-site energies (diagonal elements): $H_{ii}(V) = E_0 + \\phi_i(V)$\n-   Nearest-neighbor hopping (off-diagonal elements): $H_{i,i+1} = H_{i+1,i} = -t$\n\nThe electrostatic potential $\\phi_i(V)$ varies linearly across the $N$ sites:\n-   For $N \\ge 2$: $\\phi_i(V) = -V\\left(\\frac{i-1}{N-1} - \\frac{1}{2}\\right)$\n-   For $N=1$: $\\phi_1(V) = 0$\n\nUnder the Wide-Band Limit (WBL), the self-energies are purely imaginary and local:\n$$\\Sigma_{L,\\sigma} = -\\frac{i}{2}\\Gamma_{L,\\sigma} |1\\rangle\\langle 1| \\quad \\text{and} \\quad \\Sigma_{R,\\sigma} = -\\frac{i}{2}\\Gamma_{R,\\sigma} |N\\rangle\\langle N|$$\nThese matrices are zero everywhere except for the $(1,1)$ and $(N,N)$ elements, respectively. Thus, the self-energies modify only the diagonal elements of the full matrix to be inverted.\n\nLet $M_\\sigma(E,V) = (E + i\\eta)\\mathbb{I} - H(V) - \\Sigma_{L,\\sigma} - \\Sigma_{R,\\sigma}$. The elements of this $N\\times N$ matrix are:\n-   Diagonal elements:\n    $$M_{\\sigma, ii} = E - E_0 - \\phi_i(V) + i\\eta, \\quad \\text{for } i \\in \\{2, \\dots, N-1\\}$$\n    $$M_{\\sigma, 11} = E - E_0 - \\phi_1(V) + i\\eta + \\frac{i}{2}\\Gamma_{L,\\sigma}$$\n    $$M_{\\sigma, NN} = E - E_0 - \\phi_N(V) + i\\eta + \\frac{i}{2}\\Gamma_{R,\\sigma}$$\n    Note that for $N=1$, these two endpoint corrections combine on the single diagonal element.\n-   Off-diagonal elements:\n    $$M_{\\sigma, i,i+1} = M_{\\sigma, i+1,i} = -(-t) = t$$\n-   All other elements are zero.\n\nThe computational procedure is to construct and invert this complex-valued tridiagonal matrix $M_\\sigma(E,V)$ to find $G^r_\\sigma(E,V) = M_\\sigma(E,V)^{-1}$. Then, the element $G^r_{1N,\\sigma}$ is extracted to calculate $T_\\sigma(E,V)$.\n\nFor numerical implementation, energies are in electronvolts (eV). The current formula must account for the change of integration variable from Joules to eV. Since $dE\\,[\\mathrm{J}] = q \\cdot dE_{\\mathrm{eV}}\\,[\\mathrm{eV}]$, the integral becomes:\n$$I(V) = \\frac{q}{h} \\int T(E,V)\\,\\big[f(E,\\mu_L) - f(E,\\mu_R)\\big]\\,(q \\cdot dE_{\\mathrm{eV}}) = \\frac{q^2}{h} \\int T(E,V)\\,\\big[f(E,\\mu_L) - f(E,\\mu_R)\\big]\\,dE_{\\mathrm{eV}}$$\nThis matches the formula specified for numerical implementation, where the prefactor $q^2/h$ has units of Amperes/Volt, and the integral has units of eV, resulting in the final current in Amperes.\n\n### Part 2: Numerical Algorithm\nThe algorithm to compute the current for a given set of parameters $(N, E_0, t, \\Gamma_0, P, \\text{alignment}, T)$ and a voltage $V$ is as follows:\n\n1.  **Constants and Grid**: Define the physical constants $q, h, k_B$ and the numerical prefactor $G_0 = q^2/h$. Set up a uniform energy grid $E$ over a suitable range (e.g., $[-5, 5]\\,\\mathrm{eV}$) and an infinitesimal $\\eta$ (e.g., $10^{-9}\\,\\mathrm{eV}$).\n2.  **Outer Loop (Voltage)**: For each required voltage $V$, perform the following steps.\n3.  **Calculate Potentials & Fermi Functions**: Compute $\\mu_L = V/2$, $\\mu_R = -V/2$. Calculate the difference in Fermi-Dirac distributions, $f(E, \\mu_L) - f(E, \\mu_R)$, for all energies on the grid.\n4.  **Spin Loop**: Initialize a total transmission array $T_{total}(E)$ to zero. Iterate over the two spin channels $\\sigma \\in \\{\\uparrow, \\downarrow\\}$.\n    a. **Broadenings**: Determine $\\Gamma_{L,\\sigma}$ and $\\Gamma_{R,\\sigma}$ based on the magnetic alignment.\n    b. **Energy Loop**: For each energy $E_j$ in the grid:\n        i. **Construct Matrix $M_\\sigma$**: Build the $N \\times N$ matrix $M_\\sigma(E_j, V)$ as detailed in the derivation. This matrix is complex and tridiagonal.\n        ii. **Invert Matrix**: Compute the inverse $G^r_\\sigma(E_j, V) = M_\\sigma(E_j, V)^{-1}$.\n        iii. **Extract Element**: Get the element $G^r_{1N,\\sigma} = (G^r_\\sigma)_{1,N}$.\n        iv. **Calculate Transmission**: Compute $T_\\sigma(E_j,V) = \\Gamma_{L,\\sigma}\\Gamma_{R,\\sigma}|G^r_{1N,\\sigma}|^2$.\n    c. **Accumulate Transmission**: Add the calculated transmission array $T_\\sigma(E)$ to the total transmission array $T_{total}(E)$.\n5.  **Integration**: Numerically integrate the product of the total transmission and the Fermi function difference over the energy grid. The trapezoidal rule is suitable for this:\n    $$ \\text{integral} = \\int T_{total}(E)\\,\\big[f(E,\\mu_L) - f(E,\\mu_R)\\big]\\,dE_{\\mathrm{eV}} \\approx \\sum_j \\frac{T_{total,j+1}\\Delta f_{j+1} + T_{total,j}\\Delta f_j}{2} \\Delta E $$\n6.  **Final Current**: Multiply the integral by the prefactor $G_0$ to obtain the current $I(V)$ in Amperes.\n\nThis procedure is repeated for all test cases and specified voltages to produce the final results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and voltages.\n    It computes the tunneling current using the NEGF formalism and prints\n    the results in the specified format.\n    \"\"\"\n\n    # Physical constants\n    Q_E = 1.602176634e-19  # Elementary charge in Coulombs\n    H_PLANCK = 6.62607015e-34  # Planck's constant in J*s\n    K_B = 8.617333262145e-5  # Boltzmann constant in eV/K\n\n    # Prefactor for current calculation (q^2/h) in A/eV\n    # The derivation shows I = (q^2/h) * integral(dE [eV]).\n    # The units of q^2/h are A/V. The integral is in V. Final result I is in Amperes.\n    PREFACTOR_G = Q_E**2 / H_PLANCK\n\n    test_cases = [\n        # Case 1: (N, a, E0, t, Gamma0, P, alignment, T)\n        {'N': 5, 'a': 0.21, 'E0': 3.5, 't': 0.8, 'Gamma0': 0.5, 'P': 0.6, 'alignment': 'parallel', 'T': 300},\n        # Case 2:\n        {'N': 1, 'a': 0.21, 'E0': 1.5, 't': 1.0, 'Gamma0': 0.5, 'P': 0.6, 'alignment': 'parallel', 'T': 300},\n        # Case 3:\n        {'N': 10, 'a': 0.21, 'E0': 3.5, 't': 0.8, 'Gamma0': 0.5, 'P': 0.6, 'alignment': 'antiparallel', 'T': 300},\n        # Case 4:\n        {'N': 5, 'a': 0.21, 'E0': 3.5, 't': 0.8, 'Gamma0': 0.5, 'P': 0.0, 'alignment': 'parallel', 'T': 300},\n    ]\n\n    voltages_V = [0.0, 0.1, 0.5]\n    \n    # Numerical parameters for integration\n    E_min, E_max, n_E = -5.0, 5.0, 4001 # Energy grid in eV\n    E_grid = np.linspace(E_min, E_max, n_E)\n    eta = 1e-9j  # Infinitesimal for Green's function\n\n    results = []\n    \n    for case in test_cases:\n        for V in voltages_V:\n            current = compute_current(case, V, E_grid, eta, PREFACTOR_G, K_B)\n            results.append(f\"{current:.6e}\")\n    \n    print(f\"[{','.join(results)}]\")\n\ndef fermi_dirac(E, mu, T, k_B):\n    \"\"\"Calculates the Fermi-Dirac distribution.\"\"\"\n    if T == 0:\n        return np.where(E = mu, 1.0, 0.0)\n    # Avoid overflow for large positive exponents\n    x = (E - mu) / (k_B * T)\n    return 1.0 / (1.0 + np.exp(np.clip(x, -700, 700)))\n\ndef compute_current(params, V, E_grid, eta, prefactor, k_B):\n    \"\"\"\n    Computes the current for a given set of device parameters and bias voltage.\n    \"\"\"\n    N = params['N']\n    E0 = params['E0']\n    t = params['t']\n    Gamma0 = params['Gamma0']\n    P = params['P']\n    alignment = params['alignment']\n    T = params['T']\n\n    mu_L = V / 2.0\n    mu_R = -V / 2.0\n\n    fd_L = fermi_dirac(E_grid, mu_L, T, k_B)\n    fd_R = fermi_dirac(E_grid, mu_R, T, k_B)\n    fd_diff = fd_L - fd_R\n\n    # If V=0, fL=fR, so current is 0. Avoids numerical integration of zero.\n    if V == 0.0:\n        return 0.0\n        \n    # Calculate spin-dependent broadenings\n    Gammas_sigma = {}\n    if alignment == 'parallel':\n        Gammas_sigma['up'] = (Gamma0 * (1 + P), Gamma0 * (1 + P))\n        Gammas_sigma['down'] = (Gamma0 * (1 - P), Gamma0 * (1 - P))\n    else:  # antiparallel\n        Gammas_sigma['up'] = (Gamma0 * (1 + P), Gamma0 * (1 - P))\n        Gammas_sigma['down'] = (Gamma0 * (1 - P), Gamma0 * (1 + P))\n\n    # Construct base Hamiltonian (independent of E and spin)\n    H_device = np.zeros((N, N), dtype=float)\n    \n    # On-site potential\n    if N >= 2:\n        indices = np.arange(N)\n        phi = -V * (indices / (N - 1) - 0.5)\n        np.fill_diagonal(H_device, E0 + phi)\n    else: # N = 1\n        H_device[0, 0] = E0 # phi_1(V) = 0 as per problem\n\n    # Hopping terms\n    if N > 1:\n        off_diag_val = -t\n        indices = np.arange(N - 1)\n        H_device[indices, indices + 1] = off_diag_val\n        H_device[indices + 1, indices] = off_diag_val\n\n    total_transmission = np.zeros_like(E_grid)\n\n    for spin in ['up', 'down']:\n        Gamma_L_s, Gamma_R_s = Gammas_sigma[spin]\n        \n        spin_transmission = np.zeros_like(E_grid)\n        \n        # Self-energies (imaginary parts)\n        Sigma_L_im = -0.5 * Gamma_L_s\n        Sigma_R_im = -0.5 * Gamma_R_s\n        \n        for i, E in enumerate(E_grid):\n            # M = (E+i*eta)*I - H - Sigma_L - Sigma_R\n            M = (E + eta) * np.identity(N, dtype=complex) - H_device.astype(complex)\n            M[0, 0] -= 1j * Sigma_L_im\n            if N > 0:\n                M[N-1, N-1] -= 1j * Sigma_R_im\n\n            # Invert M to get G^r\n            try:\n                G_r = np.linalg.inv(M)\n                G_r_1N = G_r[0, -1]\n                T_E = Gamma_L_s * Gamma_R_s * np.abs(G_r_1N)**2\n                spin_transmission[i] = T_E\n            except np.linalg.LinAlgError:\n                # If matrix is singular, transmission is zero\n                spin_transmission[i] = 0.0\n\n        total_transmission += spin_transmission\n\n    # Integrate over energy using trapezoidal rule\n    integrand = total_transmission * fd_diff\n    integral_val = np.trapz(integrand, E_grid)\n    \n    current = prefactor * integral_val\n    return current\n\nsolve()\n```"
        },
        {
            "introduction": "The true potential of a neuromorphic device is only realized when it is integrated into a larger computational system. This final practice zooms out from the single-device level to assess the performance of a complete spintronic crossbar array executing a neural network task. In this exercise (), you will construct a system-level model to calculate critical performance metrics like throughput and energy consumption. Furthermore, you will learn to perform bottleneck analysis, a crucial engineering skill for identifying and optimizing the factors that limit the overall efficiency of neuromorphic hardware.",
            "id": "4060770",
            "problem": "A benchmark spiking neural network implemented with spintronic synapses in a resistive crossbar is evaluated for throughput and energy. The device-level behavior is modeled using fundamental electrical relations. The base assumptions are as follows: Ohm’s law $V = I R$, instantaneous power $P = V I$, resistive power under constant applied voltage $P = V^2 / R$, and energy as the time integral of power so that under a constant voltage and resistance over a pulse duration, $E = P \\cdot t = (V^2 / R) \\cdot t$. The total throughput is computed from the total time per spike event and capped by a communication bandwidth.\n\nA crossbar array has $m$ rows and $n$ columns. For a single activated row spike, columns are sensed in batches of $c$ columns per sense cycle, each cycle taking $t_{sense}$ seconds. The spike applies a row pulse of duration $t_{pulse}$. There is an additional routing overhead time $t_{route}$ per spike. The effective compute-limited throughput is $T_{compute} = p_{row} / t_{spike}$, where $p_{row}$ is the number of rows driven in parallel and $t_{spike}$ is the total time per spike event given by\n$$\nt_{spike} = t_{pulse} + t_{sense} \\cdot \\left\\lceil \\frac{n}{c} \\right\\rceil + t_{route}.\n$$\nThe final throughput is\n$$\nT = \\min\\left(T_{compute}, B\\right),\n$$\nwhere $B$ is the interconnect bandwidth cap in spikes per second.\n\nSpintronic synapses are assumed to be non-volatile two-state devices with on-state resistance $R_{on}$ and off-state resistance $R_{off}$. A fraction $p_{on}$ of synapses are in the on-state. Under a constant applied read voltage $V$ for duration $t_{pulse}$, the average synaptic conductance per column is\n$$\nG_{avg} = \\frac{p_{on}}{R_{on}} + \\frac{1 - p_{on}}{R_{off}}.\n$$\nDuring a row activation, the driver sees $n$ parallel synapses, giving total synaptic conduction energy for that spike:\n$$\nE_{row} = V^2 \\, t_{pulse} \\, n \\, G_{avg}.\n$$\nEach column sense operation consumes a constant energy $E_{sa}$ per sensed column. The total sense energy for a single row spike is $E_{sense} = n \\, E_{sa}$. Routing energy per spike is $E_{route}$. Neuron update energy per output spike is $E_{neu}$. For an inference consisting of $N_{in}$ input spikes and $N_{out}$ total output spikes, the total energy is\n$$\nE_{tot} = N_{in} \\left(E_{row} + E_{sense} + E_{route}\\right) + N_{out} E_{neu}.\n$$\n\nPerformance bottlenecks are identified by comparing the contributions to $t_{spike}$:\n- Device conduction (row pulse duration): $t_{conduction} = t_{pulse}$,\n- Sense bandwidth: $t_{sense\\_total} = t_{sense} \\cdot \\left\\lceil \\frac{n}{c} \\right\\rceil$,\n- Routing overhead: $t_{route}$,\n- Interconnect bandwidth cap: if $B  T_{compute}$, then interconnect is the bottleneck.\n\nReturn a bottleneck code determined as follows:\n- If $B  T_{compute}$, bottleneck code is $3$.\n- Otherwise, pick the largest among $t_{conduction}$ (code $0$), $t_{sense\\_total}$ (code $1$), and $t_{route}$ (code $2$). In case of ties, choose the smallest code among the tied components.\n\nImplement a program that computes $T$ (in spikes per second) and $E_{tot}$ (in joules), and returns the bottleneck code for each test case.\n\nUse the following device parameters (identical for all test cases):\n- $R_{on} = 3000 \\,\\Omega$,\n- $R_{off} = 30000 \\,\\Omega$,\n- $p_{on} = 0.5$,\n- $V = 0.1 \\,\\text{V}$,\n- $E_{sa} = 0.5 \\times 10^{-12} \\,\\text{J}$,\n- $E_{route} = 10 \\times 10^{-12} \\,\\text{J}$,\n- $E_{neu} = 2 \\times 10^{-12} \\,\\text{J}$.\n\nTest suite (all times must be treated in seconds):\n- Case $1$ (sense-limited, “happy path”): $m = 256$, $n = 256$, $c = 32$, $t_{pulse} = 5 \\times 10^{-9}$, $t_{sense} = 2 \\times 10^{-9}$, $t_{route} = 3 \\times 10^{-9}$, $p_{row} = 2$, $B = 100 \\times 10^{6}$, $N_{in} = 1000$, $N_{out} = 300$.\n- Case $2$ (device conduction-limited): $m = 128$, $n = 128$, $c = 256$, $t_{pulse} = 50 \\times 10^{-9}$, $t_{sense} = 1 \\times 10^{-9}$, $t_{route} = 1 \\times 10^{-9}$, $p_{row} = 1$, $B = 1000 \\times 10^{6}$, $N_{in} = 2000$, $N_{out} = 150$.\n- Case $3$ (interconnect-limited): $m = 512$, $n = 512$, $c = 64$, $t_{pulse} = 10 \\times 10^{-9}$, $t_{sense} = 2 \\times 10^{-9}$, $t_{route} = 2 \\times 10^{-9}$, $p_{row} = 8$, $B = 10 \\times 10^{6}$, $N_{in} = 4000$, $N_{out} = 600$.\n- Case $4$ (routing-limited): $m = 64$, $n = 64$, $c = 128$, $t_{pulse} = 1 \\times 10^{-9}$, $t_{sense} = 0.5 \\times 10^{-9}$, $t_{route} = 30 \\times 10^{-9}$, $p_{row} = 4$, $B = 500 \\times 10^{6}$, $N_{in} = 500$, $N_{out} = 50$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must be a list of the form $[T, E_{tot}, \\text{bottleneck\\_code}]$, in the specified units, so the final output format is $[[T_1, E_{tot,1}, b_1],[T_2, E_{tot,2}, b_2],[T_3, E_{tot,3}, b_3],[T_4, E_{tot,4}, b_4]]$.",
            "solution": "The problem is subjected to validation before proceeding to a solution.\n\n### Step 1: Extract Givens\nThe provided information is as follows:\n**Model Equations:**\n- Ohm's law: $V = I R$\n- Instantaneous power: $P = V I$\n- Resistive power (constant voltage): $P = V^2 / R$\n- Energy (constant power): $E = P \\cdot t = (V^2 / R) \\cdot t$\n- Total time per spike event: $t_{spike} = t_{pulse} + t_{sense} \\cdot \\left\\lceil \\frac{n}{c} \\right\\rceil + t_{route}$\n- Compute-limited throughput: $T_{compute} = p_{row} / t_{spike}$\n- Final throughput: $T = \\min\\left(T_{compute}, B\\right)$\n- Average synaptic conductance per column: $G_{avg} = \\frac{p_{on}}{R_{on}} + \\frac{1 - p_{on}}{R_{off}}$\n- Row conduction energy per spike: $E_{row} = V^2 \\, t_{pulse} \\, n \\, G_{avg}$\n- Sense energy per spike: $E_{sense} = n \\, E_{sa}$\n- Total energy: $E_{tot} = N_{in} \\left(E_{row} + E_{sense} + E_{route}\\right) + N_{out} E_{neu}$\n\n**Bottleneck Identification:**\n- Time components: $t_{conduction} = t_{pulse}$ (code $0$), $t_{sense\\_total} = t_{sense} \\cdot \\left\\lceil \\frac{n}{c} \\right\\rceil$ (code $1$), $t_{route}$ (code $2$).\n- Logic: If $B  T_{compute}$, the bottleneck code is $3$. Otherwise, the code corresponds to the largest of the three time components, with ties broken by selecting the smallest code.\n\n**Common Device Parameters:**\n- $R_{on} = 3000 \\,\\Omega$\n- $R_{off} = 30000 \\,\\Omega$\n- $p_{on} = 0.5$\n- $V = 0.1 \\,\\text{V}$\n- $E_{sa} = 0.5 \\times 10^{-12} \\,\\text{J}$\n- $E_{route} = 10 \\times 10^{-12} \\,\\text{J}$\n- $E_{neu} = 2 \\times 10^{-12} \\,\\text{J}$\n\n**Test Cases:**\n- Case $1$: $m = 256$, $n = 256$, $c = 32$, $t_{pulse} = 5 \\times 10^{-9}$ s, $t_{sense} = 2 \\times 10^{-9}$ s, $t_{route} = 3 \\times 10^{-9}$ s, $p_{row} = 2$, $B = 100 \\times 10^{6}$ sp/s, $N_{in} = 1000$, $N_{out} = 300$.\n- Case $2$: $m = 128$, $n = 128$, $c = 256$, $t_{pulse} = 50 \\times 10^{-9}$ s, $t_{sense} = 1 \\times 10^{-9}$ s, $t_{route} = 1 \\times 10^{-9}$ s, $p_{row} = 1$, $B = 1000 \\times 10^{6}$ sp/s, $N_{in} = 2000$, $N_{out} = 150$.\n- Case $3$: $m = 512$, $n = 512$, $c = 64$, $t_{pulse} = 10 \\times 10^{-9}$ s, $t_{sense} = 2 \\times 10^{-9}$ s, $t_{route} = 2 \\times 10^{-9}$ s, $p_{row} = 8$, $B = 10 \\times 10^{6}$ sp/s, $N_{in} = 4000$, $N_{out} = 600$.\n- Case $4$: $m = 64$, $n = 64$, $c = 128$, $t_{pulse} = 1 \\times 10^{-9}$ s, $t_{sense} = 0.5 \\times 10^{-9}$ s, $t_{route} = 30 \\times 10^{-9}$ s, $p_{row} = 4$, $B = 500 \\times 10^{6}$ sp/s, $N_{in} = 500$, $N_{out} = 50$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem presents a simplified but physically plausible model of a spintronic neuromorphic system. The governing equations are standard electrical and timing relations. All variables, constants, and conditions required for the calculation are explicitly provided for each test case. The problem is self-contained, objective, and scientifically grounded within the context of a performance estimation model. The parameters, while specific, are not physically unrealistic. The variable $m$ is provided but not used in the specified calculations, which does not constitute an invalidity but merely indicates it is extraneous for the requested outputs. The logic for determining the bottleneck is unambiguous, including a tie-breaking rule. The problem is well-posed and solvable.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A step-by-step solution will be provided.\n\n### Solution Derivation\nThe problem requires the calculation of the final throughput $T$, total energy $E_{tot}$, and a bottleneck code for four distinct cases. The analysis begins by computing parameters that are constant across all cases.\n\n**Common Parameter Calculation:**\nThe average synaptic conductance per column, $G_{avg}$, is constant for all test cases, as it depends only on $R_{on}$, $R_{off}$, and $p_{on}$.\n$$\nG_{avg} = \\frac{p_{on}}{R_{on}} + \\frac{1 - p_{on}}{R_{off}} = \\frac{0.5}{3000 \\,\\Omega} + \\frac{0.5}{30000 \\,\\Omega} = 0.5 \\left( \\frac{1}{3000} + \\frac{1}{30000} \\right) \\text{S}\n$$\n$$\nG_{avg} = 0.5 \\left( \\frac{10 + 1}{30000} \\right) \\text{S} = \\frac{5.5}{30000} \\text{S} = \\frac{11}{60000} \\text{S} \\approx 1.833 \\times 10^{-4} \\,\\text{S}\n$$\nThe remaining values will be calculated for each case individually.\n\n**Case 1 Analysis:**\nGiven: $n = 256$, $c = 32$, $t_{pulse} = 5 \\times 10^{-9}$ s, $t_{sense} = 2 \\times 10^{-9}$ s, $t_{route} = 3 \\times 10^{-9}$ s, $p_{row} = 2$, $B = 100 \\times 10^{6}$ sp/s, $N_{in} = 1000$, $N_{out} = 300$.\n\n1.  **Calculate $t_{spike}$:** The number of sense cycles is $\\lceil n/c \\rceil = \\lceil 256/32 \\rceil = 8$.\n    $$\n    t_{spike} = t_{pulse} + t_{sense} \\cdot \\left\\lceil \\frac{n}{c} \\right\\rceil + t_{route} = 5 \\times 10^{-9} + (2 \\times 10^{-9} \\cdot 8) + 3 \\times 10^{-9} = (5 + 16 + 3) \\times 10^{-9} \\,\\text{s} = 24 \\times 10^{-9} \\,\\text{s}\n    $$\n2.  **Calculate Throughput $T$:**\n    $$\n    T_{compute} = \\frac{p_{row}}{t_{spike}} = \\frac{2}{24 \\times 10^{-9} \\,\\text{s}} = \\frac{1}{12} \\times 10^9 \\,\\text{sp/s} \\approx 83.33 \\times 10^6 \\,\\text{sp/s}\n    $$\n    $$\n    T = \\min(T_{compute}, B) = \\min(83.33 \\times 10^6, 100 \\times 10^6) = 83.33 \\times 10^6 \\,\\text{sp/s}\n    $$\n3.  **Calculate Total Energy $E_{tot}$:**\n    Energy per input spike has three components: $E_{row}$, $E_{sense}$, and $E_{route}$.\n    $$\n    E_{row} = V^2 t_{pulse} n G_{avg} = (0.1 \\,\\text{V})^2 (5 \\times 10^{-9} \\,\\text{s}) (256) \\left(\\frac{11}{60000} \\,\\text{S}\\right) \\approx 2.347 \\times 10^{-12} \\,\\text{J}\n    $$\n    $$\n    E_{sense} = n E_{sa} = 256 \\cdot (0.5 \\times 10^{-12} \\,\\text{J}) = 128 \\times 10^{-12} \\,\\text{J}\n    $$\n    The total energy for the inference is:\n    $$\n    E_{tot} = N_{in} (E_{row} + E_{sense} + E_{route}) + N_{out} E_{neu}\n    $$\n    $$\n    E_{tot} = 1000 \\cdot (2.347 \\times 10^{-12} + 128 \\times 10^{-12} + 10 \\times 10^{-12}) + 300 \\cdot (2 \\times 10^{-12})\n    $$\n    $$\n    E_{tot} = 1000 \\cdot (140.347 \\times 10^{-12}) + 600 \\times 10^{-12} = (140347 + 600) \\times 10^{-12} \\,\\text{J} = 1.40947 \\times 10^{-7} \\,\\text{J}\n    $$\n4.  **Determine Bottleneck Code:** Since $T_{compute}  B$, we compare the time components.\n    - $t_{conduction} = t_{pulse} = 5 \\times 10^{-9}$ s (code $0$)\n    - $t_{sense\\_total} = t_{sense} \\cdot \\lceil n/c \\rceil = 16 \\times 10^{-9}$ s (code $1$)\n    - $t_{route} = 3 \\times 10^{-9}$ s (code $2$)\n    The largest component is $t_{sense\\_total}$. The bottleneck code is $1$.\n\n**Case 2 Analysis:**\nGiven: $n = 128$, $c = 256$, $t_{pulse} = 50 \\times 10^{-9}$ s, $t_{sense} = 1 \\times 10^{-9}$ s, $t_{route} = 1 \\times 10^{-9}$ s, $p_{row} = 1$, $B = 1000 \\times 10^{6}$ sp/s, $N_{in} = 2000$, $N_{out} = 150$.\n\n1.  **Calculate $t_{spike}$:** The number of sense cycles is $\\lceil n/c \\rceil = \\lceil 128/256 \\rceil = 1$.\n    $$\n    t_{spike} = 50 \\times 10^{-9} + (1 \\times 10^{-9} \\cdot 1) + 1 \\times 10^{-9} = 52 \\times 10^{-9} \\,\\text{s}\n    $$\n2.  **Calculate Throughput $T$:**\n    $$\n    T_{compute} = \\frac{1}{52 \\times 10^{-9} \\,\\text{s}} \\approx 19.23 \\times 10^6 \\,\\text{sp/s}\n    $$\n    $$\n    T = \\min(19.23 \\times 10^6, 1000 \\times 10^6) = 19.23 \\times 10^6 \\,\\text{sp/s}\n    $$\n3.  **Calculate Total Energy $E_{tot}$:**\n    $$\n    E_{row} = (0.1)^2 (50 \\times 10^{-9}) (128) \\left(\\frac{11}{60000}\\right) \\approx 11.733 \\times 10^{-12} \\,\\text{J}\n    $$\n    $$\n    E_{sense} = 128 \\cdot (0.5 \\times 10^{-12}) = 64 \\times 10^{-12} \\,\\text{J}\n    $$\n    $$\n    E_{tot} = 2000 \\cdot (11.733 \\times 10^{-12} + 64 \\times 10^{-12} + 10 \\times 10^{-12}) + 150 \\cdot (2 \\times 10^{-12})\n    $$\n    $$\n    E_{tot} = 2000 \\cdot (85.733 \\times 10^{-12}) + 300 \\times 10^{-12} = (171466 + 300) \\times 10^{-12} \\,\\text{J} = 1.71767 \\times 10^{-7} \\,\\text{J}\n    $$\n4.  **Determine Bottleneck Code:** Since $T_{compute}  B$, we compare time components.\n    - $t_{conduction} = 50 \\times 10^{-9}$ s (code $0$)\n    - $t_{sense\\_total} = 1 \\times 10^{-9}$ s (code $1$)\n    - $t_{route} = 1 \\times 10^{-9}$ s (code $2$)\n    The largest component is $t_{conduction}$. The bottleneck code is $0$.\n\n**Case 3 Analysis:**\nGiven: $n = 512$, $c = 64$, $t_{pulse} = 10 \\times 10^{-9}$ s, $t_{sense} = 2 \\times 10^{-9}$ s, $t_{route} = 2 \\times 10^{-9}$ s, $p_{row} = 8$, $B = 10 \\times 10^{6}$ sp/s, $N_{in} = 4000$, $N_{out} = 600$.\n\n1.  **Calculate $t_{spike}$:** The number of sense cycles is $\\lceil n/c \\rceil = \\lceil 512/64 \\rceil = 8$.\n    $$\n    t_{spike} = 10 \\times 10^{-9} + (2 \\times 10^{-9} \\cdot 8) + 2 \\times 10^{-9} = (10 + 16 + 2) \\times 10^{-9} \\,\\text{s} = 28 \\times 10^{-9} \\,\\text{s}\n    $$\n2.  **Calculate Throughput $T$:**\n    $$\n    T_{compute} = \\frac{8}{28 \\times 10^{-9} \\,\\text{s}} \\approx 285.71 \\times 10^6 \\,\\text{sp/s}\n    $$\n    $$\n    T = \\min(285.71 \\times 10^6, 10 \\times 10^6) = 10 \\times 10^6 \\,\\text{sp/s}\n    $$\n3.  **Calculate Total Energy $E_{tot}$:**\n    $$\n    E_{row} = (0.1)^2 (10 \\times 10^{-9}) (512) \\left(\\frac{11}{60000}\\right) \\approx 9.387 \\times 10^{-12} \\,\\text{J}\n    $$\n    $$\n    E_{sense} = 512 \\cdot (0.5 \\times 10^{-12}) = 256 \\times 10^{-12} \\,\\text{J}\n    $$\n    $$\n    E_{tot} = 4000 \\cdot (9.387 \\times 10^{-12} + 256 \\times 10^{-12} + 10 \\times 10^{-12}) + 600 \\cdot (2 \\times 10^{-12})\n    $$\n    $$\n    E_{tot} = 4000 \\cdot (275.387 \\times 10^{-12}) + 1200 \\times 10^{-12} = (1101547 + 1200) \\times 10^{-12} \\,\\text{J} = 1.102747 \\times 10^{-6} \\,\\text{J}\n    $$\n4.  **Determine Bottleneck Code:** Since $B  T_{compute}$ ($10 \\times 10^6  285.71 \\times 10^6$), the bottleneck is the interconnect bandwidth cap. The bottleneck code is $3$.\n\n**Case 4 Analysis:**\nGiven: $n = 64$, $c = 128$, $t_{pulse} = 1 \\times 10^{-9}$ s, $t_{sense} = 0.5 \\times 10^{-9}$ s, $t_{route} = 30 \\times 10^{-9}$ s, $p_{row} = 4$, $B = 500 \\times 10^{6}$ sp/s, $N_{in} = 500$, $N_{out} = 50$.\n\n1.  **Calculate $t_{spike}$:** The number of sense cycles is $\\lceil n/c \\rceil = \\lceil 64/128 \\rceil = 1$.\n    $$\n    t_{spike} = 1 \\times 10^{-9} + (0.5 \\times 10^{-9} \\cdot 1) + 30 \\times 10^{-9} = 31.5 \\times 10^{-9} \\,\\text{s}\n    $$\n2.  **Calculate Throughput $T$:**\n    $$\n    T_{compute} = \\frac{4}{31.5 \\times 10^{-9} \\,\\text{s}} \\approx 126.98 \\times 10^6 \\,\\text{sp/s}\n    $$\n    $$\n    T = \\min(126.98 \\times 10^6, 500 \\times 10^6) = 126.98 \\times 10^6 \\,\\text{sp/s}\n    $$\n3.  **Calculate Total Energy $E_{tot}$:**\n    $$\n    E_{row} = (0.1)^2 (1 \\times 10^{-9}) (64) \\left(\\frac{11}{60000}\\right) \\approx 0.1173 \\times 10^{-12} \\,\\text{J}\n    $$\n    $$\n    E_{sense} = 64 \\cdot (0.5 \\times 10^{-12}) = 32 \\times 10^{-12} \\,\\text{J}\n    $$\n    $$\n    E_{tot} = 500 \\cdot (0.1173 \\times 10^{-12} + 32 \\times 10^{-12} + 10 \\times 10^{-12}) + 50 \\cdot (2 \\times 10^{-12})\n    $$\n    $$\n    E_{tot} = 500 \\cdot (42.1173 \\times 10^{-12}) + 100 \\times 10^{-12} = (21058.65 + 100) \\times 10^{-12} \\,\\text{J} = 2.11587 \\times 10^{-8} \\,\\text{J}\n    $$\n4.  **Determine Bottleneck Code:** Since $T_{compute}  B$, we compare time components.\n    - $t_{conduction} = 1 \\times 10^{-9}$ s (code $0$)\n    - $t_{sense\\_total} = 0.5 \\times 10^{-9}$ s (code $1$)\n    - $t_{route} = 30 \\times 10^{-9}$ s (code $2$)\n    The largest component is $t_{route}$. The bottleneck code is $2$.\n\nThe calculations are complete. The implementation will follow this logic to produce the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates throughput, total energy, and bottleneck code for a spintronic\n    neuromorphic device model based on a series of test cases.\n    \"\"\"\n    # Define common device parameters\n    R_on = 3000.0  # Ohms\n    R_off = 30000.0 # Ohms\n    p_on = 0.5\n    V = 0.1 # Volts\n    E_sa = 0.5e-12 # Joules\n    E_route_const = 10e-12 # Joules (problem name is E_route, but it's a constant energy)\n    E_neu = 2e-12 # Joules\n\n    # Test cases from the problem statement\n    test_cases = [\n        # Case 1: sense-limited\n        {'m': 256, 'n': 256, 'c': 32, 't_pulse': 5e-9, 't_sense': 2e-9, \n         't_route': 3e-9, 'p_row': 2, 'B': 100e6, 'N_in': 1000, 'N_out': 300},\n        # Case 2: device conduction-limited\n        {'m': 128, 'n': 128, 'c': 256, 't_pulse': 50e-9, 't_sense': 1e-9, \n         't_route': 1e-9, 'p_row': 1, 'B': 1000e6, 'N_in': 2000, 'N_out': 150},\n        # Case 3: interconnect-limited\n        {'m': 512, 'n': 512, 'c': 64, 't_pulse': 10e-9, 't_sense': 2e-9, \n         't_route': 2e-9, 'p_row': 8, 'B': 10e6, 'N_in': 4000, 'N_out': 600},\n        # Case 4: routing-limited\n        {'m': 64, 'n': 64, 'c': 128, 't_pulse': 1e-9, 't_sense': 0.5e-9, \n         't_route': 30e-9, 'p_row': 4, 'B': 500e6, 'N_in': 500, 'N_out': 50},\n    ]\n\n    results = []\n\n    # Calculate average synaptic conductance (constant for all cases)\n    G_avg = (p_on / R_on) + ((1 - p_on) / R_off)\n\n    for case in test_cases:\n        # Unpack case parameters\n        n, c = case['n'], case['c']\n        t_pulse, t_sense, t_route = case['t_pulse'], case['t_sense'], case['t_route']\n        p_row, B = case['p_row'], case['B']\n        N_in, N_out = case['N_in'], case['N_out']\n\n        # --- Throughput Calculation ---\n        \n        # Calculate number of sense cycles\n        sense_cycles = np.ceil(n / c)\n        \n        # Calculate total time per spike event\n        t_spike = t_pulse + t_sense * sense_cycles + t_route\n        \n        # Calculate compute-limited throughput\n        T_compute = p_row / t_spike\n        \n        # Calculate final throughput, capped by bandwidth\n        T = min(T_compute, B)\n\n        # --- Energy Calculation ---\n        \n        # Row conduction energy per spike\n        E_row = V**2 * t_pulse * n * G_avg\n        \n        # Sense energy per spike\n        E_sense = n * E_sa\n        \n        # Total energy per input spike (conduction, sensing, routing)\n        E_per_input_spike = E_row + E_sense + E_route_const\n        \n        # Total energy for the inference task\n        E_tot = N_in * E_per_input_spike + N_out * E_neu\n\n        # --- Bottleneck Identification ---\n        \n        bottleneck_code = -1 # Initialize with invalid code\n        \n        if B  T_compute:\n            bottleneck_code = 3 # Interconnect-limited\n        else:\n            # Compare time components\n            t_conduction = t_pulse\n            t_sense_total = t_sense * sense_cycles\n            # Note: t_route is the third time component for the bottleneck analysis\n            \n            time_components = np.array([t_conduction, t_sense_total, t_route])\n            max_time = np.max(time_components)\n            \n            # Find indices of all components that are equal to the max time\n            # The problem states to use the smallest code in case of a tie.\n            # np.where returns a tuple of arrays, we need the first element.\n            tied_indices = np.where(np.isclose(time_components, max_time))[0]\n            bottleneck_code = np.min(tied_indices)\n\n        # Format each result as a list [T, E_tot, bottleneck_code]\n        result_list = [T, E_tot, bottleneck_code]\n        results.append(result_list)\n\n    # Final print statement must produce the single-line format as specified.\n    # The format is a string representing a list of lists.\n    # The outer list is converted to string, then commas are manually joined for the inner lists.\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}