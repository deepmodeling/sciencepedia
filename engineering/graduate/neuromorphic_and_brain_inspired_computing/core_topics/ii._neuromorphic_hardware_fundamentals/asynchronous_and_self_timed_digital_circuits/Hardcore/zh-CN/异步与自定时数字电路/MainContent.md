## 引言
在数字设计的世界里，全局时钟长期以来一直是协调所有操作的至高法则。然而，随着芯片规模的急剧增长和功耗墙的日益逼近，这种同步范式正面临着时钟分配、PVT（工艺、电压、温度）变化敏感性以及在稀疏活动应用中[能效](@entry_id:272127)低下的严峻挑战。作为一种根本性的替代方案，异步和自定时数字电路摒弃了全局时钟的束缚，转而依赖组件间的局部因果关系和事件驱动通信来进行协调，这与生物大脑等自然计算系统的工作方式不谋而合。这种设计哲学不仅为解决传统设计的瓶颈提供了新思路，也为神经形态计算等前沿领域开启了全新的可能性。

本文旨在系统性地剖析异步和[自定时电路](@entry_id:1131422)的世界。我们将带领读者深入探索这一迷人领域的核心，从其根本原理到前沿应用。在“原理与机制”一章中，我们将揭示这些电路如何在没有全局节拍器的情况下正确运行，重点介绍因果性、延迟模型以及核心的握手通信与数据编码机制。接着，在“应用与跨学科连接”一章中，我们将展示这些理论如何在高性能计算和类脑系统中大放异彩，解决真实世界的工程难题。最后，“动手实践”部分将提供具体问题，帮助读者将理论知识转化为实践能力。

让我们首先从构建这一切的基石——异步系统的核心原理与机制——开始探索。

## 原理与机制

在数字系统中，操作的排序和协调至关重要。传统的[同步设计](@entry_id:163344)通过一个全局时钟信号来强制实现一个全局的、离散的时间基准，所有操作都必须在这个统一的节拍下对齐。然而，在自然界和许多复杂的计算系统中，例如生物大脑，协调并非源于一个中央节拍器，而是源于事件之间的局部因果关系。异步和[自定时电路](@entry_id:1131422)的设计理念正是根植于此，旨在构建不依赖于全局时钟，而是通过组件间的直接通信和握手来协调操作的数字系统。本章将深入探讨支撑这些系统的核心原理与关键机制。

### 因果性：时序的基础

异步[系统设计](@entry_id:755777)的核心思想是，正确的操作顺序不一定需要一个全局时钟强制施加的 **[全序](@entry_id:146781)（total order）** 关系，而只需要遵循系统内在的 **[偏序](@entry_id:145467)（partial order）** 关系即可。这个偏[序关系](@entry_id:138937)本质上就是 **因果性（causality）**。

我们可以将电路中的信号跳变（例如，信号`Req`从0变为1）视为 **事件（events）**。如果事件$e_1$的发生是事件$e_2$能够发生的先决条件，我们就说$e_1$在$e_2$之前发生，记作 $e_1 \rightarrow e_2$。这种“先于发生”（happened-before）的关系定义了事件之间的因果依赖。例如，在一个请求-应答握手协议中，接收方只有在观察到请求信号`Req`的上升沿（$Req\uparrow$）后，才能发出应答信号`Ack`的上升沿（$Ack\uparrow$）。因此，我们有 $Req\uparrow \rightarrow Ack\uparrow$。

对于一个完整的[四相握手](@entry_id:165620)（four-phase handshake）事务，其因果链可以描述为：
$$ Req\uparrow \rightarrow Ack\uparrow \rightarrow Req\downarrow \rightarrow Ack\downarrow $$
这个链条可以进一步扩展，连接连续的事务，因为发送方只有在观察到前一个事务的完成（$Ack\downarrow$）后才会发起新的请求。这些因果关系构成了事件的有向无环图（Directed Acyclic Graph, DAG）。只要电路的物理实现——无论其门延迟和线延迟的具体数值如何——能够保证对于任何满足 $e_1 \rightarrow e_2$ 的事件对，它们的物理发生时间 $T(e_1)$ 和 $T(e_2)$ 满足 $T(e_1)  T(e_2)$，那么系统的功能正确性就得到了保障。

由于[电路中的传播延迟](@entry_id:163056)总是正值，因果依赖自然地保证了时间的先后顺序。因此，功能的正确性仅依赖于这种内生的因果[偏序](@entry_id:145467)，而无需一个外部的全局时钟来强制所有事件在整个芯片范围内形成一个[全序](@entry_id:146781)。这正是异步和自定时系统无需全局时钟也能正确运行的根本原因 。

### 延迟模型的层次结构

为了精确地描述和分析[异步电路](@entry_id:169162)对延迟变化的鲁棒性，研究者们建立了一个延迟模型的层次结构。这些模型对电路中[逻辑门延迟](@entry_id:170688) $d_g$ 和互连线延迟 $d_w$ 的行为做出了不同的假设。

*   **有界延迟模型（Bounded-Delay Model）**: 这是最接近传统[同步设计](@entry_id:163344)的模型。它假设门延迟和线延迟虽然不是固定的，但都落在已知的上下界之内，即 $d_g \in [d_g^{\min}, d_g^{\max}]$ 和 $d_w \in [d_w^{\min}, d_w^{\max}]$。电路设计的正确性验证依赖于对这些延迟边界的精确[时序分析](@entry_id:178997)。

*   **速度无关模型（Speed-Independent, SI）**: 该模型做出了更强的假设。它允许门延迟 $d_g$ 是任意的、未知的正有限值，但同时假定所有线延迟 $d_w$ 均为零（$d_w = 0$）。这意味着信号在互连线上传播是瞬时的。这是一个在物理上不现实但在理论上很有用的模型，它将分析的[焦点](@entry_id:174388)完全集中在[逻辑门](@entry_id:178011)的延迟变化上。

*   **延迟不敏感模型（Delay-Insensitive, DI）**: 这是理论上最鲁棒的模型。它假设所有的门延迟 $d_g$ 和线延迟 $d_w$ 都是任意的、未知的正有限值。在该模型下，电路的正确性必须与任何组件的任何有限延迟无关。这种要求极为严苛，以至于只有极少数简单的电路能够真正实现纯粹的延迟不敏感。特别是，该模型通常不允许信号分叉（fork），因为无法对信号到达不同分支的相对时间做出任何假设。

*   **准延迟不敏感模型（Quasi-Delay-Insensitive, QDI）**: QDI模型是DI模型的一个实用性折衷，也是现代高性能[自定时电路](@entry_id:1131422)设计中最广泛使用的模型。它继承了DI模型的基本假设，即门和线延迟都是任意正有限值，但引入了一个关键的例外：**等时[分叉](@entry_id:270606)假设（isochronic fork assumption）**。该假设允许设计者假定在某些特定的、经过精心布局的信号分叉处，信号的跳变可以被视为“同时”到达各个分支。这使得在保持高度鲁棒性的同时，能够构建复杂且功能强大的电路。QDI电路的正确性在除了等时分叉点之外的所有地方都对延迟不敏感 。

### 通信与编码机制

为了构建满足QDI等鲁棒模型的电路，设计者必须采用特定的通信协议和数据编码方案，从而将时序的正确性从依赖精确的延迟值转变为依赖于事件的逻辑顺序。

#### [握手协议](@entry_id:174594)

[握手协议](@entry_id:174594)是异步模块之间进行通信的基石，通过请求（Request, $r$）和应答（Acknowledge, $a$）信号的交换来协调数据传输。

*   **四相返回零协议（4-Phase Return-to-Zero, RTZ）**: 这是一种电平敏感（level-sensitive）协议。一个完整的[数据传输](@entry_id:276754)周期包含四个事件。假设初始状态为 $r=0, a=0$：
    1.  发送方将有效数据放到总线上，并断言请求信号：$r: 0 \rightarrow 1$。
    2.  接收方检测到 $r=1$，在锁存数据后，断言应答信号：$a: 0 \rightarrow 1$。
    3.  发送方检测到 $a=1$，确认数据已被接收，于是撤销请求：$r: 1 \rightarrow 0$。
    4.  接收方检测到 $r=0$，撤销应答，使信道返回初始的“零”状态：$a: 1 \rightarrow 0$。
    这个 $r\uparrow \rightarrow a\uparrow \rightarrow r\downarrow \rightarrow a\downarrow$ 的序列清晰地定义了数据传输的开始和结束。

*   **两相转换信号协议（2-Phase Transition Signaling）**: 这是一种边沿敏感（edge-sensitive）或非返回零（NRZ）协议。在这种协议中，`r`和`a`信号的任何跳变（无论是上升沿还是下降沿）都构成一个事件。一个完整的周期仅需两个事件：
    1.  发送方发出数据后，翻转`r`信号（例如，从0到1）。
    2.  接收方在处理完数据后，翻转`a`信号（例如，从0到1）以示响应。
    信道的状态由`r`和`a`的相对关系定义：$r=a$ 表示空闲，而 $r \neq a$ 表示有待处理的请求。下一次传输将从 $r: 1 \rightarrow 0$ 开始，接着是 $a: 1 \rightarrow 0$。两相协议的每个周期只有两次转换，理论上比四相协议更快、能耗更低，但其控制电路通常更复杂 。

#### 数据编码与[完成检测](@entry_id:1122724)

[异步设计](@entry_id:1121166)的核心挑战之一是如何知道数据何时有效。不同的设计风格采用不同的策略。

*   **捆绑数据（Bundled Data）**: 这是最直接的方法。数据本身使用传统的单轨（single-rail）二进制编码（例如，一个8位的总线使用8根线）。数据的有效性不是由数据本身表示的，而是通过一个独立的`Req`信号来“宣告”。为了确保`Req`信号到达时数据确实已经稳定，`Req`信号的路径上必须插入一个延迟元件，其延迟要大于数据通路在最坏情况下的延迟。这种方法依赖于时序假设，我们将在后续小节详细讨论。

*   **延迟不敏感编码（Delay-Insensitive Codes）**: 与捆绑数据不同，延迟不敏感编码将数据的有效性信息直接编码在数据本身中。这意味着接收方仅通过观察数据线就能判断数据是否到达以及是否完整。
    *   **[双轨编码](@entry_id:167964)（Dual-Rail Encoding）**: 这是最常见的延迟不敏感编码，也称为“1-of-2”码。每个逻辑比特位用两根线（两条“轨道”）表示，例如 `data.0` 和 `data.1`。逻辑'0'可能由 `(data.0, data.1) = (1, 0)` 表示，逻辑'1'由 `(0, 1)` 表示。状态 `(0, 0)` 是一个特殊的“空”或“间隔”（spacer）状态，表示没有数据。在任何有效的[数据传输](@entry_id:276754)中，两根线中必须有且仅有一根为高电平。
    *   **m-of-n 编码**: 这是[双轨编码](@entry_id:167964)的推广。一个符号由`n`根线表示，一个有效的码字是任何具有`m`个'1'的`n`[位向量](@entry_id:746852)。例如，一个2-of-4码使用4根线，共有 $\binom{4}{2}=6$ 个有效码字。全[零向量](@entry_id:156189)通常用作间隔状态。

采用延迟不敏感编码的关键优势在于它内在地支持 **[完成检测](@entry_id:1122724)（completion detection）**。接收方可以构建一个简单的电路来判断数据是否已到达。对于一个多位的[双轨编码](@entry_id:167964)字，每一位的完成（即不再是`(0,0)`状态）可以通过一个`OR`门检测（$v_i = r_{i,0} \lor r_{i,1}$）。然后，可以使用一个 **[穆勒C元件](@entry_id:170454)（Muller C-element）** 树将所有位的完成信号$v_i$汇集起来。C元件是一种有记忆的与门，其输出仅在所有输入都为高时变高，在所有输入都为低时变低，否则保持原状态。这种机制使得电路能够根据实际的、数据相关的计算延迟来调整其运行速度，而不是像捆绑数据那样总是等待最坏情况的延迟 。

### 两种设计风格：捆绑数据与自定时

基于上述通信和编码机制，[异步设计](@entry_id:1121166)领域形成了两种主流风格。

*   **捆绑数据风格（Bundled-Data Style）**: 这种风格将传统的单轨[数据总线](@entry_id:167432)（“数据捆绑包”）与一个独立的握手[控制路径](@entry_id:747840)结合起来。其正确性依赖于一个关键的 **捆绑约束（bundling constraint）**。该约束要求[控制路径](@entry_id:747840)的延迟必须大于或等于数据路径的延迟。具体来说，如果数据路径的[组合逻辑延迟](@entry_id:177382)在一个区间 $[D_{\min}, D_{\max}]$ 内，而匹配延迟线提供的延迟为 $M$，并考虑到互连线引入的[时钟偏斜](@entry_id:177738)和不确定性 $S$，那么为了保证数据在被接收方锁存前稳定，必须满足以下不等式：
    $$ M \ge D_{\max} + S $$
    这种风格的电路不是延迟不敏感的，因为它们的正确性直接依赖于对延迟关系的精确控制。

*   **自定时风格（Self-Timed Style）**: 这种风格通常指采用QDI或DI模型的电路。它们通过使用延迟不敏感编码（如双轨码或m-of-n码）来避免对时序的显式依赖。在[自定时电路](@entry_id:1131422)中，数据本身就携带了有效性信息。[完成检测](@entry_id:1122724)逻辑直接从数据通路中派生出来，使模块能够在计算实际完成后立即发出完成信号。这种方法的正确性是 **[组合性](@entry_id:637804)的（compositional）**，意味着只要每个模块本身是正确的，将它们连接起来构成的系统也是正确的，而无需进行全局[时序分析](@entry_id:178997)或满足像捆绑约束这样的时[序关系](@entry_id:138937)。因此，[自定时电路](@entry_id:1131422)的正确性是“由结构保证的”，而非“由时序保证的”。

### 实践优势与考量

选择不同的[异步设计](@entry_id:1121166)风格会带来显著的实践后果，尤其是在面对物理实现的变化和功耗限制时。

#### 对[PVT变化](@entry_id:1130319)的鲁棒性

**工艺、电压和温度（Process, Voltage, and Temperature, PVT）** 的变化是现代[CMOS技术](@entry_id:265278)中不可避免的挑战。这些变化会显著影响晶体管的性能，从而导致门延迟和线延迟发生漂移。对于[异步电路](@entry_id:169162)而言，不同设计风格对[PVT变化](@entry_id:1130319)的鲁棒性差异巨大。

*   **捆绑数据电路的脆弱性**: 捆绑数据设计的核心——捆绑约束——在[PVT变化](@entry_id:1130319)面前非常脆弱。数据路径和匹配延迟路径上的延迟会受到PVT的不同影响。例如，在一个设计中，标称数据路径延迟 $d_{\mathrm{data},0}=1.0\,\mathrm{ns}$，标称匹配延迟 $d_{\mathrm{match},0}=1.30\,\mathrm{ns}$，并要求 $0.05\,\mathrm{ns}$ 的安全裕量。假设[PVT变化](@entry_id:1130319)导致数据路径延迟的变化范围为标称值的 $\pm 30\%$ ($\gamma_d \in [0.7, 1.3]$)，而匹配延迟路径的变化范围为 $\pm 20\%$ ($\gamma_m \in [0.8, 1.2]$)。
    最严峻的考验发生在匹配延迟路径变得最快（延迟最小），而数据路径变得最慢（延迟最大）时。我们需要检查在所有PVT组合下，是否始终满足 $d_{\mathrm{match}} > d_{\mathrm{data}} + m$。最严峻的考验发生在匹配延迟最快而数据延迟最慢时：
    *   最小匹配延迟：$d'_{\mathrm{match,min}} = (1 - 0.20) \times 1.30\,\mathrm{ns} = 1.04\,\mathrm{ns}$
    *   最大数据延迟加上裕量：$d'_{\mathrm{data,max}} + m = (1 + 0.30) \times 1.0\,\mathrm{ns} + 0.05\,\mathrm{ns} = 1.35\,\mathrm{ns}$
    由于 $1.04\,\mathrm{ns} \ngtr 1.35\,\mathrm{ns}$，该[时序约束](@entry_id:168640)被违反。这意味着在某些PVT条件下，请求信号会过早到达，导致接收方锁存到仍在变化中的、不正确的数据。

*   **QDI电路的内生鲁棒性**: 相比之下，QDI电路的正确性不依赖于任何此类延迟匹配。由于[数据有效性](@entry_id:914312)是通过编码和[完成检测](@entry_id:1122724)来确定的，[PVT变化](@entry_id:1130319)只会影响电路的性能（即运行速度），而不会破坏其功能正确性（只要等时分叉假设仍然成立）。只要信号最终能够稳定下来，无论它花费了多长时间，QDI电路都能正确地处理它。这种内生的鲁棒性是异步方法在可靠性要求极高的应用中备受青睐的关键原因 。

#### 事件驱动操作的功耗效率

在[CMOS](@entry_id:178661)电路中，功耗主要由两部分组成：**[静态功耗](@entry_id:174547)** 和 **动态功耗**。
*   **静态功耗** ($P_{\text{static}}$) 由晶体管的亚阈值漏电流引起，即使在电路空闲时也存在，可建模为 $P_{\text{static}} = I_{\text{leak}} V_{\text{DD}}$。
*   **动态功耗** ($P_{\text{dyn}}$) 主要来源于对负载电容的充放电，其每次从0到1的转换消耗的能量约为 $E = \frac{1}{2} C V_{\text{DD}}^2$。总动态功耗与开关活动频率成正比。

[异步电路](@entry_id:169162)，特别是事件驱动的[自定时电路](@entry_id:1131422)，在功耗方面具有显著优势。考虑一个典型的神经形态应用，其计算活动是稀疏和突发的。
*   **[同步系统](@entry_id:172214)**: 在[同步系统](@entry_id:172214)中，全局时钟网络（具有巨大的电容 $C_{\text{clk}}$）在每个时钟周期都会翻转，无论是否有有用的计算发生。这会产生持续的、巨大的动态功耗。例如，一个工作在 $f = 200\,\mathrm{MHz}$ 的时钟，其电容 $C_{\text{clk}} = 100\,\mathrm{pF}$，在 $V_{\text{DD}} = 0.9\,\text{V}$ 下，仅时钟功耗就高达 $P_{\text{dyn,clk}} = f C_{\text{clk}} V_{\text{DD}}^2 \approx 16.2\,\mathrm{mW}$。
*   **异步系统**: 在异步系统中，不存在全局时钟。电路的任何部分只有在需要处理事件时才会发生状态转换。当没有事件时，除了静态漏电外，几乎没有动态功耗。假设一个事件的平均发生率为 $\lambda = 10^5\,\text{s}^{-1}$，每次事件处理涉及的[开关电容](@entry_id:197049)为 $C_{\text{ev}} + C_{\text{hs}} = 25\,\mathrm{pF}$。其动态功耗仅为 $P_{\text{dyn,async}} = \lambda \times (\frac{1}{2} (C_{\text{ev}} + C_{\text{hs}}) V_{\text{DD}}^2) \approx 1.0\,\mu\text{W}$。

即使两者都有相同的[静态功耗](@entry_id:174547)（例如 $1.8\,\mathrm{mW}$），总功耗的差异也是惊人的：[同步系统](@entry_id:172214)总功耗约为 $18.0\,\mathrm{mW}$，而异步系统仅为 $1.801\,\mathrm{mW}$。[异步电路](@entry_id:169162)“按需工作”的特性使其功耗与实际计算负载成正比，从而在活动稀疏的应用中实现了极高的[能效](@entry_id:272127) 。

### 案例研究：Sutherland的微流水线

**微流水线（Micropipeline）** 是由Ivan Sutherland于1989年提出的一个经典的异步流水线结构，它优雅地展示了如何将上述原理组合成一个实用的系统。微流水线是一种基于捆绑数据风格的事件驱动流水线。

其核心结构是一系列由 **[电平敏感锁存器](@entry_id:165956)（level-sensitive latches）** 分隔的组合逻辑块。每个流水线阶段的控制都由一个本地控制器负责，该控制器通常使用[穆勒C元件](@entry_id:170454)构建。通信采用两相转换信号协议。

每个阶段的控制器执行一个简单的“捕获-传递”（capture-pass）操作。当一个输入事件（来自上游阶段的`Req`信号）到达时，控制器首先会关闭当前阶段的输出[锁存器](@entry_id:167607)，以“捕获”并保持其输入数据稳定。然后，它会打开当前阶段的输入[锁存器](@entry_id:167607)，允许上游阶段的新数据进入。一旦数据处理完成，控制器会向下游阶段传递一个新的事件（发出`Req`信号），并将自身的输入锁存器关闭，等待下游的应答。

由于微流水线采用捆绑数据方法，其正确性严格依赖于捆绑约束。对于每个阶段，从发送方[锁存器](@entry_id:167607)输出到接收方锁存器输入的[组合逻辑](@entry_id:265083)数据路径的最坏情况延迟 $t_{D}^{\max}$，必须小于控制信号从发送方发出请求到接收方执行捕获操作的最小[控制路径](@entry_id:747840)延迟 $t_{\mathrm{ctrl}}^{\min}$。如果自然路径延迟不满足此条件，就必须在[控制路径](@entry_id:747840)中插入一个匹配的延迟元件 $\Delta$。考虑到[锁存器](@entry_id:167607)的[建立时间](@entry_id:167213) $t_{\mathrm{su}}$ 和其他时序不确定性裕量 $t_{\mathrm{skew}}$，约束条件变为：
$$ t_{\mathrm{ctrl}}^{\min} + \Delta \ge t_{D}^{\max} + t_{\mathrm{su}} + t_{\mathrm{skew}} $$
例如，若 $t_{D}^{\max} = 480\,\mathrm{ps}$，$t_{\mathrm{su}} = 20\,\mathrm{ps}$，$t_{\mathrm{skew}} = 15\,\mathrm{ps}$，而固有的最小[控制路径](@entry_id:747840)延迟为 $t_{\mathrm{ctrl}}^{\min} = 80\,\mathrm{ps}$，则所需的最小匹配延迟为：
$$ \Delta_{\min} = (480 + 20 + 15) - 80 = 435\,\mathrm{ps} $$
微流水线作为一个开创性的设计，为构建模块化、弹性的高性能异步系统奠定了基础 。

### 形式化规约与验证

异步系统的并发和[非确定性](@entry_id:273591)使其设计和调试变得异常困难。为了确保其正确性，设计者广泛依赖[形式化方法](@entry_id:1125241)进行规约和验证。

#### 使用信号转换图规约控制逻辑

**信号转换图（Signal Transition Graphs, STGs）** 是一种基于 **[Petri网](@entry_id:269912)（Petri Nets）** 的形式化工具，专门用于规约异步控制电路的行为。

一个[Petri网](@entry_id:269912)由 **库所（places）**（用圆圈表示）、**变迁（transitions）**（用方框或竖线表示）和连接它们的有向弧组成。**托肯（tokens）**（用黑点表示）驻留在库所中，一个[Petri网](@entry_id:269912)的 **标识（marking）** 是指所有库所中托肯的分布，代表了系统的当前状态。一个变迁只有当其所有输入库所中都至少有一个托肯时才被 **使能（enabled）**。使能的变迁可以 **触发（fire）**，触发时会从每个输入库所消耗一个托肯，并在每个输出库所产生一个托肯。

STG是一种解释性的[Petri网](@entry_id:269912)，其中每个变迁都与一个电路信号的特定跳变相关联，例如 $req^+$（`req`信号从0到1）或 $ack^-$（`ack`信号从1到0）。
*   **变迁** 代表事件。
*   **库所** 代表事件之间的状态或条件。一个位于两个变迁之间的库所（$t_1 \rightarrow p \rightarrow t_2$）强制了因果关系（$t_2$ 只能在 $t_1$ 之后发生）。一个作为多个变迁共同输入的库所（$t_1 \leftarrow p \rightarrow t_2$）则表示一个选择或冲突。
*   **托肯** 的流动模拟了控制逻辑的演化。

通过STG，设计者可以精确、无[歧义](@entry_id:276744)地描述复杂的并发行为、因果依赖和资源共享，并可以从STG规约自动综合出无险象的[异步电路](@entry_id:169162) 。

#### 确保正确性：安全性、活性与[死锁](@entry_id:748237)

一旦有了形式化的模型（如STG或其生成的状变系统），就可以使用 **模型检测（model checking）** 等技术来[自动验证](@entry_id:918345)其是否满足某些关键属性。这些属性通常使用 **时序逻辑（temporal logic）** 如线性时序逻辑（LTL）或[计算树逻辑](@entry_id:198041)（CTL）来描述，并主要分为两类：

*   **安全性（Safety）**: 这类属性断言“坏事永远不会发生”。其违例总是可以通过一个有限的执行前缀来证明。例如，一个关键的[握手协议](@entry_id:174594)安全属性是“请求信号和应答信号永远不会同时为高电平”，这可以用LTL公式 $\mathbf{G}\neg(req \land ack)$ 来表达，其中 $\mathbf{G}$ 表示“全局地”或“在所有时间点”。

*   **活性（Liveness）**: 这类属性断言“好事最终会发生”。其违例无法通过任何有限前缀证明，必须观察整个无限的执行过程。例如，“每个请求最终都会得到应答”是一个典型的活性属性。用LTL可以表示为 $\mathbf{G}(req^\uparrow \rightarrow \mathbf{F}\, ack^\uparrow)$，其中 $\mathbf{F}$ 表示“最终地”或“在未来的某个时间点”。验证活性属性通常需要引入 **公平性（fairness）** 假设，以排除调度器恶意地使某个能够执行的事件永远得不到执行的情况。

*   **死锁（Deadlock）**: 死锁是一种特殊的安全属性违例，指系统进入一个没有任何事件被使能的状态，从而无法继续向前演进。在CTL中，一个死锁状态可以被描述为不满足 $\mathbf{EX}\,\mathit{true}$（即不存在一个可以到达的后继状态）。验证系统是否无死锁，等价于验证 $\mathbf{AG}(\mathbf{EX}\,\mathit{true})$（在所有路径的所有状态上，都存在一个后继状态）属性 。

通过这些形式化的原理和机制，异步和[自定时电路](@entry_id:1131422)设计从一门“黑色艺术”演变为一门严谨的科学，为构建下一代高效、鲁棒和高性能的计算系统（尤其是在神经形态计算等领域）提供了坚实的基础。