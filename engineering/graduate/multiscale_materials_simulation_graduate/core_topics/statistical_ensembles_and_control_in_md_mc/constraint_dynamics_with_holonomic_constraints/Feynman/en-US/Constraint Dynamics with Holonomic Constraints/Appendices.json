{
    "hands_on_practices": [
        {
            "introduction": "This first practice lays the foundation for enforcing holonomic constraints in molecular dynamics. You will derive and implement a single correction step of the renowned SHAKE algorithm, which operates at the level of particle positions. This exercise provides a first-principles understanding of how Lagrange multipliers are used to project a system's configuration back onto the valid constraint manifold after an unconstrained integration step .",
            "id": "3797892",
            "problem": "Consider a two-particle subsystem embedded in a larger multiscale materials simulation. The subsystem consists of two point masses with masses $m_1$ and $m_2$, and their trial positions $r_1^{\\mathrm{t}} \\in \\mathbb{R}^3$ and $r_2^{\\mathrm{t}} \\in \\mathbb{R}^3$ produced by an unconstrained integrator step. A holonomic constraint enforces a fixed bond length between the two particles, represented by the constraint function $g(r_1, r_2) = \\|r_2 - r_1\\|^2 - d_0^2 = 0$, where $d_0$ is the prescribed bond length. In a single step of the SHAKE algorithm, the corrected positions $r_1$ and $r_2$ are obtained by applying position corrections that enforce the constraint while minimizing a mass-weighted displacement measure derived from the principles of constrained dynamics.\n\nStarting from fundamental laws and core definitions—Newton's laws, holonomic constraints, the principle of virtual work, and Lagrange multipliers—derive the expression for the scalar multiplier update $\\mu$ associated with the position-level constraint enforcement and compute the corrected positions $r_1$ and $r_2$ that satisfy the constraint in the linearized sense at the trial positions. Your derivation must not assume any shortcut formula; it must rely on first principles appropriate to constrained dynamics and holonomic constraints. You must implement a program that, given $m_1$, $m_2$, $r_1^{\\mathrm{t}}$, $r_2^{\\mathrm{t}}$, and $d_0$, computes $\\mu$ and the corrected positions $r_1$ and $r_2$ for a single SHAKE correction step based on the first-order linearization of $g$ at the trial positions.\n\nScientific realism and units:\n- $m_1$ and $m_2$ are in kilograms (kg).\n- $r_1^{\\mathrm{t}}$, $r_2^{\\mathrm{t}}$, $r_1$, and $r_2$ are in meters (m).\n- $d_0$ is in meters (m).\n- The multiplier update $\\mu$ must be expressed in kilograms (kg).\n\nAngle units are not applicable in this problem. All computed numerical answers must be floats rounded to twelve significant digits. The final output must report $\\mu$ in kilograms and all position components in meters.\n\nTest suite:\nImplement the program to evaluate the following four test cases. Use the atomic mass unit $u = 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$ when constructing $m_1$ and $m_2$.\n\n1. Happy path case with a carbon-hydrogen bond slightly too long:\n   - $m_1 = 12u$, $m_2 = 1u$\n   - $d_0 = 1.09 \\times 10^{-10}\\,\\mathrm{m}$\n   - $r_1^{\\mathrm{t}} = [0.0, 0.0, 0.0]\\,\\mathrm{m}$, $r_2^{\\mathrm{t}} = [1.14 \\times 10^{-10}, 0.0, 0.0]\\,\\mathrm{m}$\n\n2. Boundary case where the trial positions already satisfy the constraint:\n   - $m_1 = 12u$, $m_2 = 1u$\n   - $d_0 = 1.09 \\times 10^{-10}\\,\\mathrm{m}$\n   - $r_1^{\\mathrm{t}} = [2.0 \\times 10^{-10}, -1.0 \\times 10^{-10}, 0.5 \\times 10^{-10}]\\,\\mathrm{m}$\n   - $r_2^{\\mathrm{t}} = r_1^{\\mathrm{t}} + [1.09 \\times 10^{-10}, 0.0, 0.0]\\,\\mathrm{m}$\n\n3. Edge case with diagonal orientation and oxygen-hydrogen masses, bond slightly too short:\n   - $m_1 = 16u$, $m_2 = 1u$\n   - $d_0 = 0.97 \\times 10^{-10}\\,\\mathrm{m}$\n   - $r_1^{\\mathrm{t}} = [0.0, 0.0, 0.0]\\,\\mathrm{m}$\n   - $r_2^{\\mathrm{t}} = \\frac{0.95 \\times 10^{-10}}{\\sqrt{3}} [1, 1, 1]\\,\\mathrm{m}$\n\n4. Near-boundary case with equal masses and a small violation:\n   - $m_1 = 12u$, $m_2 = 12u$\n   - $d_0 = 1.0 \\times 10^{-10}\\,\\mathrm{m}$\n   - $r_1^{\\mathrm{t}} = [0.0, 0.0, 0.0]\\,\\mathrm{m}$\n   - $r_2^{\\mathrm{t}} = [1.0000005 \\times 10^{-10}, 0.0, 0.0]\\,\\mathrm{m}$\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list in the form $[\\mu, r_{1x}, r_{1y}, r_{1z}, r_{2x}, r_{2y}, r_{2z}]$, with each float rounded to twelve significant digits. For example, a line containing four test case results should look like:\n\"[[\\mu_1,r_{1x}^{(1)},r_{1y}^{(1)},r_{1z}^{(1)},r_{2x}^{(1)},r_{2y}^{(1)},r_{2z}^{(1)}],[\\mu_2,\\dots],[\\mu_3,\\dots],[\\mu_4,\\dots]]\".\n\nYour implementation must be self-contained, require no user input, and must compute the scalar $\\mu$ in kilograms and the corrected positions in meters using a single SHAKE linearized correction step based on first principles as stated.",
            "solution": "The derivation of the SHAKE correction step is predicated on the principle of constrained dynamics, specifically minimizing the deviation from an unconstrained trajectory subject to a set of holonomic constraints. For the given two-particle system, we seek to find the corrected positions $r_1$ and $r_2$ that satisfy the distance constraint $g(r_1, r_2) = 0$ while being minimally displaced from the trial positions $r_1^{\\mathrm t}$ and $r_2^{\\mathrm t}$ in a mass-weighted sense.\n\nThe objective is to minimize the function $S$:\n$$S(r_1, r_2) = \\frac{1}{2} m_1 \\|r_1 - r_1^{\\mathrm t}\\|^2 + \\frac{1}{2} m_2 \\|r_2 - r_2^{\\mathrm t}\\|^2$$\nThis function represents the mass-weighted sum of squared displacements from the trial positions. The minimization is subject to the holonomic constraint of a fixed-bond length $d_0$:\n$$g(r_1, r_2) = \\|r_2 - r_1\\|^2 - d_0^2 = 0$$\n\nThis constrained optimization problem is solved using the method of Lagrange multipliers. We define a Lagrangian function $\\mathcal{L}$ that incorporates the objective function $S$ and the constraint $g$ with a scalar Lagrange multiplier, which the problem denotes as $\\mu$. The units of $\\mu$ are specified as kilograms ($\\mathrm{kg}$), which informs the structure of the Lagrangian.\n$$\\mathcal{L}(r_1, r_2, \\mu) = S(r_1, r_2) - \\mu g(r_1, r_2)$$\n$$\\mathcal{L}(r_1, r_2, \\mu) = \\left( \\frac{1}{2} m_1 \\|r_1 - r_1^{\\mathrm t}\\|^2 + \\frac{1}{2} m_2 \\|r_2 - r_2^{\\mathrm t}\\|^2 \\right) - \\mu \\left( \\|r_2 - r_1\\|^2 - d_0^2 \\right)$$\nAt the minimum, the gradient of $\\mathcal{L}$ with respect to each position vector must be zero.\n$$\\nabla_{r_1} \\mathcal{L} = m_1 (r_1 - r_1^{\\mathrm t}) - \\mu \\nabla_{r_1} g = 0$$\n$$\\nabla_{r_2} \\mathcal{L} = m_2 (r_2 - r_2^{\\mathrm t}) - \\mu \\nabla_{r_2} g = 0$$\nThese equations give the form of the position corrections $\\delta r_i = r_i - r_i^{\\mathrm t}$:\n$$\\delta r_1 = r_1 - r_1^{\\mathrm t} = \\frac{\\mu}{m_1} \\nabla_{r_1} g$$\n$$\\delta r_2 = r_2 - r_2^{\\mathrm t} = \\frac{\\mu}{m_2} \\nabla_{r_2} g$$\nLet us compute the gradients of the constraint function $g$. Let the inter-particle vector be $d = r_2 - r_1$. Then $g(d) = d \\cdot d - d_0^2$.\n$$\\nabla_{r_1} g = \\nabla_{r_1} ((r_2 - r_1) \\cdot (r_2 - r_1))) = -2(r_2 - r_1)$$\n$$\\nabla_{r_2} g = \\nabla_{r_2} ((r_2 - r_1) \\cdot (r_2 - r_1))) = 2(r_2 - r_1)$$\n\nThe problem requires a single correction step based on the **linearization** of the constraint function $g$ at the trial positions $r_1^{\\mathrm t}$ and $r_2^{\\mathrm t}$. We expand $g(r_1, r_2)$ in a Taylor series around the trial positions and keep terms up to first order:\n$$g(r_1, r_2) \\approx g(r_1^{\\mathrm t}, r_2^{\\mathrm t}) + (r_1 - r_1^{\\mathrm t}) \\cdot \\nabla_{r_1} g(r_1^{\\mathrm t}, r_2^{\\mathrm t}) + (r_2 - r_2^{\\mathrm t}) \\cdot \\nabla_{r_2} g(r_1^{\\mathrm t}, r_2^{\\mathrm t}) = 0$$\nLet's use the shorthand notation $g^{\\mathrm t} = g(r_1^{\\mathrm t}, r_2^{\\mathrm t})$ and $\\nabla_{r_i} g^{\\mathrm t} = \\nabla_{r_i} g(r_1^{\\mathrm t}, r_2^{\\mathrm t})$. The linearized constraint is:\n$$g^{\\mathrm t} + \\delta r_1 \\cdot \\nabla_{r_1} g^{\\mathrm t} + \\delta r_2 \\cdot \\nabla_{r_2} g^{\\mathrm t} = 0$$\nNow, substitute the expressions for the corrections $\\delta r_1$ and $\\delta r_2$:\n$$g^{\\mathrm t} + \\left(\\frac{\\mu}{m_1} \\nabla_{r_1} g^{\\mathrm t}\\right) \\cdot \\nabla_{r_1} g^{\\mathrm t} + \\left(\\frac{\\mu}{m_2} \\nabla_{r_2} g^{\\mathrm t}\\right) \\cdot \\nabla_{r_2} g^{\\mathrm t} = 0$$\nFactoring out $\\mu$, we get:\n$$g^{\\mathrm t} + \\mu \\left( \\frac{1}{m_1} \\|\\nabla_{r_1} g^{\\mathrm t}\\|^2 + \\frac{1}{m_2} \\|\\nabla_{r_2} g^{\\mathrm t}\\|^2 \\right) = 0$$\nSolving for the Lagrange multiplier $\\mu$:\n$$\\mu = - \\frac{g^{\\mathrm t}}{\\frac{1}{m_1} \\|\\nabla_{r_1} g^{\\mathrm t}\\|^2 + \\frac{1}{m_2} \\|\\nabla_{r_2} g^{\\mathrm t}\\|^2}$$\nLet the trial separation vector be $d^{\\mathrm t} = r_2^{\\mathrm t} - r_1^{\\mathrm t}$. The required terms are:\n$$g^{\\mathrm t} = \\|d^{\\mathrm t}\\|^2 - d_0^2$$\n$$\\nabla_{r_1} g^{\\mathrm t} = -2d^{\\mathrm t}$$\n$$\\nabla_{r_2} g^{\\mathrm t} = 2d^{\\mathrm t}$$\nSubstituting these into the expression for $\\mu$:\n$$\\|\\nabla_{r_1} g^{\\mathrm t}\\|^2 = \\|-2d^{\\mathrm t}\\|^2 = 4\\|d^{\\mathrm t}\\|^2$$\n$$\\|\\nabla_{r_2} g^{\\mathrm t}\\|^2 = \\|2d^{\\mathrm t}\\|^2 = 4\\|d^{\\mathrm t}\\|^2$$\nThe denominator of the expression for $\\mu$ becomes a scalar:\n$$\\frac{1}{m_1} (4\\|d^{\\mathrm t}\\|^2) + \\frac{1}{m_2} (4\\|d^{\\ t}\\|^2) = 4 \\left( \\frac{1}{m_1} + \\frac{1}{m_2} \\right) \\|d^{\\mathrm t}\\|^2$$\nThus, the final expression for the Lagrange multiplier $\\mu$ is:\n$$\\mu = - \\frac{\\|r_2^{\\mathrm t} - r_1^{\\mathrm t}\\|^2 - d_0^2}{4 \\left( \\frac{1}{m_1} + \\frac{1}{m_2} \\right) \\|r_2^{\\mathrm t} - r_1^{\\mathrm t}\\|^2}$$\nThe dimensional consistency check is as follows: the numerator has units of $\\mathrm{m}^2$, and the denominator has units of $(\\mathrm{kg}^{-1}) \\cdot \\mathrmm^2$. The resulting unit for $\\mu$ is $\\mathrm{kg}$, as required by the problem statement.\n\nOnce $\\mu$ is computed, the corrected positions $r_1$ and $r_2$ are found by applying the corrections to the trial positions. We use the gradients evaluated at the trial positions, consistent with the linearization:\n$$r_1 = r_1^{\\mathrm t} + \\frac{\\mu}{m_1} \\nabla_{r_1} g^{\\mathrm t} = r_1^{\\mathrm t} - \\frac{2\\mu}{m_1}(r_2^{\\mathrm t} - r_1^{\\mathrm t})$$\n$$r_2 = r_2^{\\mathrm t} + \\frac{\\mu}{m_2} \\nabla_{r_2} g^{\\mathrm t} = r_2^{\\mathrm t} + \\frac{2\\mu}{m_2}(r_2^{\\mathrm t} - r_1^{\\mathrm t})$$\nThese equations provide the complete algorithm for one linearized SHAKE correction step. The procedure is:\n1.  Given $m_1$, $m_2$, $r_1^{\\mathrm t}$, $r_2^{\\mathrm t}$, and $d_0$.\n2.  Calculate the trial separation vector $d^{\\mathrm t} = r_2^{\\mathrm t} - r_1^{\\mathrm t}$ and its squared magnitude $\\|d^{\\mathrm t}\\|^2$.\n3.  Calculate the constraint violation at the trial positions, $g^{\\mathrm t} = \\|d^{\\mathrm t}\\|^2 - d_0^2$.\n4.  If $g^{\\mathrm t}$ is zero (within tolerance), no correction is needed, so $\\mu=0$ and $r_i = r_i^{\\mathrm t}$.\n5.  Otherwise, calculate $\\mu$ using its derived expression.\n6.  Calculate the final corrected positions $r_1$ and $r_2$ using their derived expressions.\nThis fully specifies the computational procedure to be implemented.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Lagrange multiplier mu and corrected positions for a two-particle\n    system using a single linearized SHAKE correction step.\n    \"\"\"\n    # Universal constant\n    u = 1.66053906660e-27  # Atomic mass unit in kg\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"m1_u\": 12.0, \"m2_u\": 1.0, \"d0\": 1.09e-10,\n            \"r1_t\": np.array([0.0, 0.0, 0.0]),\n            \"r2_t\": np.array([1.14e-10, 0.0, 0.0])\n        },\n        {\n            \"m1_u\": 12.0, \"m2_u\": 1.0, \"d0\": 1.09e-10,\n            \"r1_t\": np.array([2.0e-10, -1.0e-10, 0.5e-10]),\n            \"r2_t\": np.array([2.0e-10 + 1.09e-10, -1.0e-10, 0.5e-10])\n        },\n        {\n            \"m1_u\": 16.0, \"m2_u\": 1.0, \"d0\": 0.97e-10,\n            \"r1_t\": np.array([0.0, 0.0, 0.0]),\n            \"r2_t\": (0.95e-10 / np.sqrt(3)) * np.array([1.0, 1.0, 1.0])\n        },\n        {\n            \"m1_u\": 12.0, \"m2_u\": 12.0, \"d0\": 1.0e-10,\n            \"r1_t\": np.array([0.0, 0.0, 0.0]),\n            \"r2_t\": np.array([1.0000005e-10, 0.0, 0.0])\n        }\n    ]\n\n    all_results_str = []\n\n    for case in test_cases:\n        m1 = case[\"m1_u\"] * u\n        m2 = case[\"m2_u\"] * u\n        d0 = case[\"d0\"]\n        r1_t = case[\"r1_t\"]\n        r2_t = case[\"r2_t\"]\n\n        # Calculate the trial separation vector and its squared magnitude\n        d_t = r2_t - r1_t\n        d_t_sq = np.dot(d_t, d_t)\n\n        # Calculate the constraint violation at the trial position\n        g_t = d_t_sq - d0**2\n\n        # If the trial distance is zero, gradient is undefined.\n        # Physically, r1_t should not equal r2_t. In this case, mu would be zero.\n        if d_t_sq == 0.0:\n            mu = 0.0\n        else:\n            # Calculate the Lagrange multiplier mu\n            mu_denom = 4.0 * (1.0/m1 + 1.0/m2) * d_t_sq\n            mu = -g_t / mu_denom\n\n        # Calculate the corrected positions\n        r1 = r1_t - (2.0 * mu / m1) * d_t\n        r2 = r2_t + (2.0 * mu / m2) * d_t\n\n        # Collect results for this test case\n        current_result = [mu, r1[0], r1[1], r1[2], r2[0], r2[1], r2[2]]\n\n        # Format results to 12 significant digits and prepare string for final output\n        current_result_str = \",\".join([\"{:.12g}\".format(v) for v in current_result])\n        all_results_str.append(f\"[{current_result_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on position-level corrections, this exercise advances to the RATTLE algorithm, which extends constraint enforcement to the velocity domain. By implementing a full RATTLE step within a Velocity Verlet framework, you will learn how to construct a time-reversible, symplectic integrator that correctly conserves the constants of motion for a constrained system. This skill is crucial for generating physically meaningful and stable long-time trajectories in molecular simulations .",
            "id": "3797876",
            "problem": "Consider a diatomic molecule modeled as two point masses with positions $r_1 \\in \\mathbb{R}^3$ and $r_2 \\in \\mathbb{R}^3$, velocities $v_1 \\in \\mathbb{R}^3$ and $v_2 \\in \\mathbb{R}^3$, masses $m_1  0$ and $m_2  0$, and external forces $F_1 \\in \\mathbb{R}^3$ and $F_2 \\in \\mathbb{R}^3$. Let the system be subject to a single holonomic constraint enforcing a fixed bond length $d_0  0$ given by the constraint function $g(q) = \\lVert r_2 - r_1 \\rVert^2 - d_0^2 = 0$, where $q = (r_1, r_2) \\in \\mathbb{R}^6$ and $\\lVert \\cdot \\rVert$ denotes the Euclidean norm. The associated velocity-level constraint requires $\\frac{d}{dt}g(q(t)) = \\nabla g(q(t)) \\cdot \\dot{q}(t) = 0$ at all times, where $\\dot{q} = (v_1, v_2)$ and $\\nabla g$ is the gradient of $g$ with respect to $q$.\n\nStarting from time $t^n$ with known state $(q^n, v^n)$ and a finite time step size $h  0$, implement one step of a time-reversible constraint integrator (RATTLE algorithm) that:\n- advances positions using a half-step velocity update and a position update,\n- corrects positions to satisfy the holonomic constraint $g(q^{n+1}) = 0$,\n- advances velocities to the full step,\n- corrects velocities to satisfy the velocity constraint $\\nabla g(q^{n+1}) \\cdot v^{n+1} = 0$.\n\nUse the following fundamental base in your derivation and implementation: Newton's second law of motion, the definition of holonomic constraints, the mass matrix representation, and Lagrange multipliers for enforcing constraints. You must not assume or use any pre-derived constraint-specific correction formulas in the problem statement; all necessary relations must be derived in the solution.\n\nThe inputs are three test cases specifying $m_1$, $m_2$, $r_1^n$, $r_2^n$, $v_1^n$, $v_2^n$, $F_1^n$, $F_2^n$, $d_0$, and $h$, all in the International System of Units (SI). Masses must be provided in kilograms, positions in meters, velocities in meters per second, forces in newtons, and time in seconds. The program must compute the corrected velocity $\\dot{q}^{n+1} = (v_1^{n+1}, v_2^{n+1})$ that satisfies the velocity constraint after one step. For verification and uniformity of output, your program should report, for each test case, the absolute value of the scalar velocity-constraint residual $\\left|\\nabla g(q^{n+1}) \\cdot \\dot{q}^{n+1}\\right|$ as a single floating-point number expressed in meters squared per second, rounded by the default floating-point representation.\n\nTest Suite:\n- Case 1 (happy path, equal masses, radial violation present):\n  - $m_1 = 12.0 \\times 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$, $m_2 = 12.0 \\times 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$,\n  - $r_1^n = (0.0, 0.0, 0.0)\\,\\mathrm{m}$, $r_2^n = (1.5 \\times 10^{-10}, 0.0, 0.0)\\,\\mathrm{m}$,\n  - $v_1^n = (200.0, 0.0, 0.0)\\,\\mathrm{m/s}$, $v_2^n = (-200.0, 0.0, 0.0)\\,\\mathrm{m/s}$,\n  - $F_1^n = (0.0, 0.0, 0.0)\\,\\mathrm{N}$, $F_2^n = (0.0, 0.0, 0.0)\\,\\mathrm{N}$,\n  - $d_0 = 1.5 \\times 10^{-10}\\,\\mathrm{m}$, $h = 5.0 \\times 10^{-16}\\,\\mathrm{s}$.\n- Case 2 (unequal masses, transverse velocities, external forces introduce radial component):\n  - $m_1 = 12.0 \\times 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$, $m_2 = 1.0 \\times 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$,\n  - $r_1^n = (0.0, 0.0, 0.0)\\,\\mathrm{m}$, $r_2^n = (1.0 \\times 10^{-10}, 0.0, 0.0)\\,\\mathrm{m}$,\n  - $v_1^n = (0.0, 1000.0, 0.0)\\,\\mathrm{m/s}$, $v_2^n = (0.0, -500.0, 0.0)\\,\\mathrm{m/s}$,\n  - $F_1^n = (1.0 \\times 10^{-10}, 0.0, 0.0)\\,\\mathrm{N}$, $F_2^n = (-1.0 \\times 10^{-10}, 0.0, 0.0)\\,\\mathrm{N}$,\n  - $d_0 = 1.0 \\times 10^{-10}\\,\\mathrm{m}$, $h = 1.0 \\times 10^{-15}\\,\\mathrm{s}$.\n- Case 3 (edge case, extremely small time step, mixed velocity components):\n  - $m_1 = 12.0 \\times 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$, $m_2 = 12.0 \\times 1.66053906660 \\times 10^{-27}\\,\\mathrm{kg}$,\n  - $r_1^n = (0.0, 0.0, 0.0)\\,\\mathrm{m}$, $r_2^n = (1.2 \\times 10^{-10}, 0.0, 0.0)\\,\\mathrm{m}$,\n  - $v_1^n = (1000.0, 2000.0, 0.0)\\,\\mathrm{m/s}$, $v_2^n = (-1000.0, -2000.0, 0.0)\\,\\mathrm{m/s}$,\n  - $F_1^n = (5.0 \\times 10^{-11}, -1.0 \\times 10^{-10}, 0.0)\\,\\mathrm{N}$, $F_2^n = (-5.0 \\times 10^{-11}, 1.0 \\times 10^{-10}, 0.0)\\,\\mathrm{N}$,\n  - $d_0 = 1.2 \\times 10^{-10}\\,\\mathrm{m}$, $h = 1.0 \\times 10^{-18}\\,\\mathrm{s}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases as provided. For example, the final output format must be exactly like $[r_1,r_2,r_3]$, where each $r_i$ is the absolute value of the scalar velocity-constraint residual $\\left|\\nabla g(q^{n+1}) \\cdot \\dot{q}^{n+1}\\right|$ expressed in $\\mathrm{m}^2/\\mathrm{s}$.",
            "solution": "The problem requires the derivation and implementation of a single step of the RATTLE algorithm for a diatomic molecule. The algorithm is a time-reversible geometric integrator designed for Hamiltonian systems with holonomic constraints. It is built upon the Velocity Verlet integration scheme. We will derive the necessary equations from first principles as requested.\n\nLet the generalized coordinates be $q = (r_1, r_2) \\in \\mathbb{R}^6$ and velocities be $\\dot{q} = v = (v_1, v_2) \\in \\mathbb{R}^6$. The masses of the two particles are $m_1$ and $m_2$, and the external forces are $F_1$ and $F_2$, collected in a generalized force vector $F = (F_1, F_2)$. The mass matrix $M$ is a $6 \\times 6$ diagonal matrix with entries $(m_1, m_1, m_1, m_2, m_2, m_2)$.\n\nThe dynamics are governed by Newton's second law, modified to include the constraint force, which is derived from a Lagrange multiplier $\\lambda$:\n$$ M \\ddot{q} = F - (\\nabla_q g)^T \\lambda $$\nThe holonomic constraint is given by $g(q) = \\lVert r_2 - r_1 \\rVert^2 - d_0^2 = 0$. The gradient of the constraint function with respect to the generalized coordinates $q$ is:\n$$ \\nabla_q g = \\left( \\frac{\\partial g}{\\partial r_1}, \\frac{\\partial g}{\\partial r_2} \\right) = (-2(r_2 - r_1), 2(r_2 - r_1)) $$\nThe RATTLE algorithm proceeds in discrete time steps of size $h  0$, advancing the system from a state $(q^n, v^n)$ at time $t^n$ to $(q^{n+1}, v^{n+1})$ at time $t^{n+1} = t^n + h$. Both the initial and final states must satisfy the position and velocity constraints, $g(q) = 0$ and $\\nabla_q g(q) \\cdot v = 0$, respectively.\n\nThe derivation follows the steps outlined in the problem statement.\n\n**Step 1: Unconstrained position predictor**\nThis step is the standard Velocity Verlet update. First, we compute an intermediate velocity at time $t^n + h/2$ by applying the external forces for half a time step.\n$$ v^{n+1/2, p} = v^n + \\frac{h}{2} M^{-1} F^n $$\nIn terms of particle velocities and forces:\n$$ v_{1}^{n+1/2, p} = v_1^n + \\frac{h}{2m_1} F_1^n $$\n$$ v_{2}^{n+1/2, p} = v_2^n + \\frac{h}{2m_2} F_2^n $$\nNext, we use this half-step velocity to compute a provisional position update for the full time step $h$:\n$$ q^{n+1, p} = q^n + h v^{n+1/2, p} $$\nIn terms of particle positions:\n$$ r_{1}^{n+1, p} = r_1^n + h v_{1}^{n+1/2, p} $$\n$$ r_{2}^{n+1, p} = r_2^n + h v_{2}^{n+1/2, p} $$\nThe resulting positions $q^{n+1, p}$ are provisional (predictor 'p' step) and will generally not satisfy the constraint $g(q^{n+1, p}) = 0$.\n\n**Step 2: Position correction (SHAKE)**\nThe goal is to find a corrected position $q^{n+1}$ that is close to the predicted position $q^{n+1, p}$ and satisfies the constraint $g(q^{n+1}) = 0$. The correction is performed by adding a displacement proportional to $M^{-1} (\\nabla_q g)^T$, which represents the direction of motion induced by the constraint force. For a single diatomic constraint, this can be solved analytically.\nLet the correction be $\\delta q = q^{n+1} - q^{n+1,p} = (\\delta r_1, \\delta r_2)$. The correction is due to the constraint force, so $\\delta r_i \\propto \\frac{1}{m_i} \\nabla_{r_i} g$.\n$$ \\delta r_1 = \\gamma \\frac{1}{m_1} (-2(r_2^{n+1,p} - r_1^{n+1,p})) $$\n$$ \\delta r_2 = \\gamma \\frac{1}{m_2} (2(r_2^{n+1,p} - r_1^{n+1,p})) $$\nwhere $\\gamma$ is a scalar multiplier to be determined. Let $r_{21}^p = r_2^{n+1,p} - r_1^{n+1,p}$. The new separation vector is $r_{21}^{n+1} = r_{21}^p + \\delta r_2 - \\delta r_1$.\n$$ r_{21}^{n+1} = r_{21}^p + 2\\gamma \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right) r_{21}^p = \\left(1 + 2\\gamma \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)\\right) r_{21}^p $$\nThe constraint is $\\lVert r_{21}^{n+1} \\rVert^2 = d_0^2$. Taking the norm and solving for the term in parenthesis gives:\n$$ \\left|1 + 2\\gamma \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)\\right| = \\frac{d_0}{\\lVert r_{21}^p \\rVert} $$\nAssuming a small correction, we take the positive root. Let $S = \\frac{d_0}{\\lVert r_{21}^p \\rVert} - 1$. Then $2\\gamma(\\frac{1}{m_1} + \\frac{1}{m_2}) = S$. We can now find the individual corrections:\n$$ \\delta r_1 = -\\frac{S}{1/m_1 + 1/m_2} \\frac{1}{m_1} r_{21}^p = -\\frac{m_2}{m_1+m_2} S r_{21}^p $$\n$$ \\delta r_2 = \\frac{S}{1/m_1 + 1/m_2} \\frac{1}{m_2} r_{21}^p = \\frac{m_1}{m_1+m_2} S r_{21}^p $$\nThe corrected positions are $q^{n+1} = q^{n+1,p} + \\delta q$, or:\n$$ r_1^{n+1} = r_1^{n+1, p} - \\frac{m_2}{m_1+m_2} S r_{21}^p $$\n$$ r_2^{n+1} = r_2^{n+1, p} + \\frac{m_1}{m_1+m_2} S r_{21}^p $$\n\n**Step 3: Unconstrained velocity predictor**\nThe RATTLE algorithm defines a corrected half-step velocity $v^{n+1/2}$ consistent with the corrected positions:\n$$ v^{n+1/2} = \\frac{q^{n+1} - q^n}{h} $$\nThe second half of the Velocity Verlet \"kick\" is then applied to this corrected half-step velocity to obtain a provisional velocity at time $t^{n+1}$:\n$$ v^{n+1, p} = v^{n+1/2} + \\frac{h}{2} M^{-1} F^n = \\frac{q^{n+1} - q^n}{h} + \\frac{h}{2} M^{-1} F^n $$\nIn component form:\n$$ v_{1}^{n+1, p} = \\frac{r_1^{n+1} - r_1^n}{h} + \\frac{h}{2m_1} F_1^n $$\n$$ v_{2}^{n+1, p} = \\frac{r_2^{n+1} - r_2^n}{h} + \\frac{h}{2m_2} F_2^n $$\nThis provisional velocity $v^{n+1, p}$ does not yet satisfy the velocity constraint.\n\n**Step 4: Velocity correction (RATTLE)**\nWe must find a final velocity $v^{n+1}$ that satisfies the velocity constraint $\\nabla_q g(q^{n+1}) \\cdot v^{n+1} = 0$. The correction is applied along the constraint gradient at the new positions $q^{n+1}$:\n$$ v^{n+1} = v^{n+1, p} - M^{-1} (\\nabla_q g(q^{n+1}))^T \\lambda_v $$\nHere $\\lambda_v$ is a scalar Lagrange multiplier for the velocity correction. We find $\\lambda_v$ by substituting this into the velocity constraint equation:\n$$ \\nabla_q g(q^{n+1}) \\cdot \\left( v^{n+1, p} - M^{-1} (\\nabla_q g(q^{n+1}))^T \\lambda_v \\right) = 0 $$\n$$ \\nabla_q g(q^{n+1}) \\cdot v^{n+1, p} - \\lambda_v \\left( \\nabla_q g(q^{n+1}) M^{-1} (\\nabla_q g(q^{n+1}))^T \\right) = 0 $$\nSolving for $\\lambda_v$:\n$$ \\lambda_v = \\frac{\\nabla_q g(q^{n+1}) \\cdot v^{n+1, p}}{\\nabla_q g(q^{n+1}) M^{-1} (\\nabla_q g(q^{n+1}))^T} $$\nLet's evaluate the numerator and denominator. Let $r_{21}^{n+1} = r_2^{n+1} - r_1^{n+1}$ and $v_{21}^{n+1,p} = v_2^{n+1,p} - v_1^{n+1,p}$.\nNumerator:\n$$ \\nabla_q g \\cdot v^{p} = (-2r_{21}^{n+1}) \\cdot v_1^{n+1,p} + (2r_{21}^{n+1}) \\cdot v_2^{n+1,p} = 2r_{21}^{n+1} \\cdot v_{21}^{n+1,p} $$\nDenominator:\n$$ \\nabla_q g M^{-1} (\\nabla_q g)^T = \\frac{1}{m_1} \\lVert -2r_{21}^{n+1} \\rVert^2 + \\frac{1}{m_2} \\lVert 2r_{21}^{n+1} \\rVert^2 = 4 \\left( \\frac{1}{m_1} + \\frac{1}{m_2} \\right) \\lVert r_{21}^{n+1} \\rVert^2 $$\nSince $q^{n+1}$ satisfies the position constraint, $\\lVert r_{21}^{n+1} \\rVert^2 = d_0^2$.\n$$ \\lambda_v = \\frac{2r_{21}^{n+1} \\cdot v_{21}^{n+1,p}}{4d_0^2 \\left( \\frac{1}{m_1} + \\frac{1}{m_2} \\right)} = \\frac{r_{21}^{n+1} \\cdot v_{21}^{n+1,p}}{2d_0^2 \\left( \\frac{1}{m_1} + \\frac{1}{m_2} \\right)} $$\nThe final corrected velocities are:\n$$ v_1^{n+1} = v_1^{n+1, p} - \\frac{1}{m_1}(-2r_{21}^{n+1})\\lambda_v = v_1^{n+1, p} + \\frac{2\\lambda_v}{m_1} r_{21}^{n+1} $$\n$$ v_2^{n+1} = v_2^{n+1, p} - \\frac{1}{m_2}(2r_{21}^{n+1})\\lambda_v = v_2^{n+1, p} - \\frac{2\\lambda_v}{m_2} r_{21}^{n+1} $$\nThe final state is $(q^{n+1}, v^{n+1})$. The problem asks to report the residual $|\\nabla_q g(q^{n+1}) \\cdot v^{n+1}|$, which should be zero up to floating-point precision.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RATTLE integrator problem for the given test cases.\n    \"\"\"\n    amu_to_kg = 1.66053906660e-27\n\n    test_cases = [\n        {\n            \"m1\": 12.0 * amu_to_kg, \"m2\": 12.0 * amu_to_kg,\n            \"r1n\": np.array([0.0, 0.0, 0.0]), \"r2n\": np.array([1.5e-10, 0.0, 0.0]),\n            \"v1n\": np.array([200.0, 0.0, 0.0]), \"v2n\": np.array([-200.0, 0.0, 0.0]),\n            \"F1n\": np.array([0.0, 0.0, 0.0]), \"F2n\": np.array([0.0, 0.0, 0.0]),\n            \"d0\": 1.5e-10, \"h\": 5.0e-16\n        },\n        {\n            \"m1\": 12.0 * amu_to_kg, \"m2\": 1.0 * amu_to_kg,\n            \"r1n\": np.array([0.0, 0.0, 0.0]), \"r2n\": np.array([1.0e-10, 0.0, 0.0]),\n            \"v1n\": np.array([0.0, 1000.0, 0.0]), \"v2n\": np.array([0.0, -500.0, 0.0]),\n            \"F1n\": np.array([1.0e-10, 0.0, 0.0]), \"F2n\": np.array([-1.0e-10, 0.0, 0.0]),\n            \"d0\": 1.0e-10, \"h\": 1.0e-15\n        },\n        {\n            \"m1\": 12.0 * amu_to_kg, \"m2\": 12.0 * amu_to_kg,\n            \"r1n\": np.array([0.0, 0.0, 0.0]), \"r2n\": np.array([1.2e-10, 0.0, 0.0]),\n            \"v1n\": np.array([1000.0, 2000.0, 0.0]), \"v2n\": np.array([-1000.0, -2000.0, 0.0]),\n            \"F1n\": np.array([5.0e-11, -1.0e-10, 0.0]), \"F2n\": np.array([-5.0e-11, 1.0e-10, 0.0]),\n            \"d0\": 1.2e-10, \"h\": 1.0e-18\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        m1, m2 = case[\"m1\"], case[\"m2\"]\n        r1n, r2n = case[\"r1n\"], case[\"r2n\"]\n        v1n, v2n = case[\"v1n\"], case[\"v2n\"]\n        F1n, F2n = case[\"F1n\"], case[\"F2n\"]\n        d0, h = case[\"d0\"], case[\"h\"]\n\n        # Step 1: Unconstrained position predictor (Half-kick, full-drift)\n        v1_half_p = v1n + (h / (2 * m1)) * F1n\n        v2_half_p = v2n + (h / (2 * m2)) * F2n\n        \n        r1_np1_p = r1n + h * v1_half_p\n        r2_np1_p = r2n + h * v2_half_p\n\n        # Step 2: Position correction (SHAKE)\n        r21_p = r2_np1_p - r1_np1_p\n        d_p = np.linalg.norm(r21_p)\n        \n        # S factor for correction\n        S = d0 / d_p - 1.0\n        \n        # Position correction displacements\n        dr1 = -(m2 / (m1 + m2)) * S * r21_p\n        dr2 = (m1 / (m1 + m2)) * S * r21_p\n        \n        # Corrected positions\n        r1_np1 = r1_np1_p + dr1\n        r2_np1 = r2_np1_p + dr2\n\n        # Step 3: Unconstrained velocity predictor\n        # Provisional velocities at t^{n+1}\n        v1_np1_p = (r1_np1 - r1n) / h + (h / (2 * m1)) * F1n\n        v2_np1_p = (r2_np1 - r2n) / h + (h / (2 * m2)) * F2n\n\n        # Step 4: Velocity correction (RATTLE)\n        r21_np1 = r2_np1 - r1_np1\n        v21_np1_p = v2_np1_p - v1_np1_p\n\n        # Lagrange multiplier for velocity correction\n        numerator_lambda_v = np.dot(r21_np1, v21_np1_p)\n        denominator_lambda_v = 2 * d0**2 * (1/m1 + 1/m2)\n        lambda_v = numerator_lambda_v / denominator_lambda_v\n\n        # Corrected velocities at t^{n+1}\n        v1_np1 = v1_np1_p + (2 * lambda_v / m1) * r21_np1\n        v2_np1 = v2_np1_p - (2 * lambda_v / m2) * r21_np1\n\n        # Final step: Calculate the velocity-constraint residual\n        # Residual = grad_g(q^{n+1}) . v^{n+1}\n        # grad_g_r1 = -2 * r21_np1, grad_g_r2 = 2 * r21_np1\n        # Residual = (-2 * r21_np1 . v1_np1) + (2 * r21_np1 . v2_np1)\n        #          = 2 * r21_np1 . (v2_np1 - v1_np1)\n        v21_np1 = v2_np1 - v1_np1\n        residual = 2 * np.dot(r21_np1, v21_np1)\n        \n        results.append(str(np.abs(residual)))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Why are projection methods like SHAKE and RATTLE so prevalent? This practice explores the answer by contrasting them with the conceptually simpler penalty method, which enforces constraints using a stiff harmonic potential. You will derive the required penalty stiffness to maintain a desired accuracy and analyze its significant, often detrimental, impact on the maximum stable time step, thereby appreciating the efficiency of augmented Lagrangian and exact projection approaches .",
            "id": "3797874",
            "problem": "Consider two point masses with positions constrained by a single holonomic bond-length constraint. The holonomic constraint is that the distance between the two masses should remain equal to a prescribed bond length. In the penalty method, the constraint is enforced by augmenting the system energy with a quadratic penalty term that penalizes deviations from the constraint. In the augmented Lagrangian method, a Lagrange multiplier enforces the constraint exactly (assuming an exact projection at each time step), while a penalty term is used only to stabilize and accelerate convergence of the multiplier update. Starting from first principles, derive the minimum penalty stiffness required to bound the constraint violation under a specified worst-case tensile load and analyze how the added stiffness affects the explicit time integration stability limit. Assume motion along the bond direction and small deviations from the constraint manifold.\n\nYour derivation must begin from fundamental laws and core definitions such as Newton’s second law of motion, the definition of a holonomic constraint, and the expression for a quadratic penalty energy. You must not use or assume any target formulas for penalty stiffness or time-step restrictions without deriving them from these bases. Treat the relative coordinate along the bond direction as the relevant scalar constraint coordinate, and use the reduced mass of the two-body system for the effective dynamics along this coordinate. Assume the external load acts along the bond direction and is constant over the time scale considered. For the time-step restriction, consider an explicit central-difference or velocity-Verlet scheme applied to the linearized dynamics of the stiff mode induced by the penalty term, and include the effect of a separate physical highest frequency in the system.\n\nFor each test case below, compute and return the following quantities:\n- The minimum penalty stiffness required to ensure that the absolute bond-length violation remains below a given tolerance under the specified worst-case tensile load, in Newtons per meter ($\\mathrm{N}/\\mathrm{m}$).\n- The maximum stable explicit time step in seconds ($\\mathrm{s}$) when using the penalty method, accounting for both the penalty-induced high frequency and a given highest physical frequency by taking the dominant one.\n- The maximum stable explicit time step in seconds ($\\mathrm{s}$) when using an augmented Lagrangian method with exact projection of the constraint at each time step (assume that this removes the penalty-induced stiff mode from the evolution, so the stability limit is governed solely by the given highest physical frequency).\n\nPhysical and numerical units must be respected: express the penalty stiffness in $\\mathrm{N}/\\mathrm{m}$ and the stable time steps in $\\mathrm{s}$. Angles are not involved in this problem. The final program output must be a single line containing a comma-separated list of lists, each inner list corresponding to a test case and containing the three computed floating-point results in the order described above. For example, an output like $[[\\dots],[\\dots],[\\dots]]$.\n\nUse the following test suite, with all quantities provided in International System of Units (SI):\n\n- Test case $1$ (happy path):\n    - $m_1 = 1.0\\times 10^{-26}\\ \\mathrm{kg}$, $m_2 = 2.0\\times 10^{-26}\\ \\mathrm{kg}$,\n    - bond length $l_0 = 1.0\\times 10^{-10}\\ \\mathrm{m}$,\n    - worst-case tensile load along the bond $F_{\\max} = 1.0\\times 10^{-9}\\ \\mathrm{N}$,\n    - allowable absolute violation $\\varepsilon_{\\mathrm{tol}} = 1.0\\times 10^{-13}\\ \\mathrm{m}$,\n    - highest physical frequency $\\omega_{\\mathrm{phys}} = 1.0\\times 10^{13}\\ \\mathrm{s}^{-1}$.\n\n- Test case $2$ (stringent tolerance boundary):\n    - $m_1 = 1.0\\times 10^{-26}\\ \\mathrm{kg}$, $m_2 = 2.0\\times 10^{-26}\\ \\mathrm{kg}$,\n    - $l_0 = 1.0\\times 10^{-10}\\ \\mathrm{m}$,\n    - $F_{\\max} = 1.0\\times 10^{-9}\\ \\mathrm{N}$,\n    - $\\varepsilon_{\\mathrm{tol}} = 1.0\\times 10^{-15}\\ \\mathrm{m}$,\n    - $\\omega_{\\mathrm{phys}} = 1.0\\times 10^{13}\\ \\mathrm{s}^{-1}$.\n\n- Test case $3$ (disparate masses edge case):\n    - $m_1 = 1.0\\times 10^{-25}\\ \\mathrm{kg}$, $m_2 = 1.0\\times 10^{-27}\\ \\mathrm{kg}$,\n    - $l_0 = 1.0\\times 10^{-10}\\ \\mathrm{m}$,\n    - $F_{\\max} = 5.0\\times 10^{-10}\\ \\mathrm{N}$,\n    - $\\varepsilon_{\\mathrm{tol}} = 5.0\\times 10^{-13}\\ \\mathrm{m}$,\n    - $\\omega_{\\mathrm{phys}} = 2.0\\times 10^{13}\\ \\mathrm{s}^{-1}$.\n\n- Test case $4$ (high load scenario):\n    - $m_1 = 1.0\\times 10^{-26}\\ \\mathrm{kg}$, $m_2 = 2.0\\times 10^{-26}\\ \\mathrm{kg}$,\n    - $l_0 = 1.0\\times 10^{-10}\\ \\mathrm{m}$,\n    - $F_{\\max} = 5.0\\times 10^{-9}\\ \\mathrm{N}$,\n    - $\\varepsilon_{\\mathrm{tol}} = 1.0\\times 10^{-12}\\ \\mathrm{m}$,\n    - $\\omega_{\\mathrm{phys}} = 1.0\\times 10^{12}\\ \\mathrm{s}^{-1}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a list of three floating-point numbers in the order: $[\\text{penalty stiffness in }\\mathrm{N}/\\mathrm{m},\\ \\Delta t_{\\max}\\ \\text{with penalty in }\\mathrm{s},\\ \\Delta t_{\\max}\\ \\text{with augmented Lagrangian in }\\mathrm{s}]$.",
            "solution": "The system consists of two point masses, `$m_1$` and `$m_2$`, connected by a holonomic bond-length constraint. We are concerned with the dynamics along the relative coordinate vector, `$\\vec{r} = \\vec{r}_2 - \\vec{r}_1$`. The problem statement simplifies the analysis to motion along the bond direction, allowing us to use a scalar relative coordinate, `$r = |\\vec{r}|$`. The dynamics of this relative motion can be described using the reduced mass of the system, `$\\mu$`, defined as:\n$$\n\\mu = \\frac{m_1 m_2}{m_1 + m_2}\n$$\nThe holonomic constraint dictates that the distance `$r$` should be equal to a prescribed bond length, `$l_0$`. The constraint function is thus `$g(r) = r - l_0 = 0$`.\n\n### Part 1: Minimum Penalty Stiffness ($k_{\\text{min}}$)\n\nThe penalty method enforces the constraint approximately by adding a potential energy term to the system that penalizes deviations from the constraint manifold. For the given bond-length constraint, a quadratic penalty potential `$V_{\\text{penalty}}$` is used:\n$$\nV_{\\text{penalty}}(r) = \\frac{1}{2} k (r - l_0)^2\n$$\nwhere `$k$` is the penalty stiffness, a parameter we need to determine.\n\nThe force resulting from this penalty potential, acting along the relative coordinate `$r$`, is given by the negative gradient of `$V_{\\text{penalty}}$` with respect to `$r$`:\n$$\nF_{\\text{penalty}} = - \\frac{\\partial V_{\\text{penalty}}}{\\partial r} = - \\frac{\\partial}{\\partial r} \\left( \\frac{1}{2} k (r - l_0)^2 \\right) = -k(r - l_0)\n$$\nLet the bond-length violation be `$\\varepsilon = r - l_0$`. The penalty force can be expressed as `$F_{\\text{penalty}} = -k\\varepsilon$`, which is a linear restoring force analogous to Hooke's law.\n\nThe problem requires us to find the minimum stiffness `$k_{\\text{min}}$` that can counteract a worst-case tensile load `$F_{\\max}$` while ensuring the absolute violation `$|\\varepsilon|$` does not exceed a specified tolerance `$\\varepsilon_{\\text{tol}}$`. Under a quasi-static application of the load `$F_{\\max}$`, the system reaches an equilibrium where the internal penalty force balances the external load:\n$$\n|F_{\\text{penalty}}| = F_{\\max}\n$$\nSubstituting the expression for the penalty force, we have:\n$$\n| -k \\varepsilon | = k |\\varepsilon| = F_{\\max}\n$$\nThis gives the violation under maximum load as `$|\\varepsilon| = F_{\\max} / k$`. To satisfy the tolerance requirement, we must have:\n$$\n|\\varepsilon| \\le \\varepsilon_{\\text{tol}}\n$$\nSubstituting the expression for `$|\\varepsilon|$`:\n$$\n\\frac{F_{\\max}}{k} \\le \\varepsilon_{\\text{tol}}\n$$\nTo ensure this inequality holds, the stiffness `$k$` must be sufficiently large. The minimum required stiffness, `$k_{\\text{min}}$`, is found by setting the violation to its maximum allowed value:\n$$\nk_{\\text{min}} = \\frac{F_{\\max}}{\\varepsilon_{\\text{tol}}}\n$$\nThis is the first quantity to be computed.\n\n### Part 2: Maximum Stable Time Step with Penalty Method ($\\Delta t_{\\text{max, penalty}}$)\n\nThe equation of motion for the relative coordinate `$r$` under the influence of the penalty force and other physical forces `$F_{\\text{phys}}$` is given by Newton's second law for the reduced mass:\n$$\n\\mu \\ddot{r} = F_{\\text{phys}} + F_{\\text{penalty}} = F_{\\text{phys}} - k(r-l_0)\n$$\nThe term `$-k(r-l_0)$` introduces a stiff harmonic oscillator into the system's dynamics. To analyze the time-step stability, we consider the linearized dynamics of this stiff mode by ignoring the typically slower-varying `$F_{\\text{phys}}$`. Letting `$\\delta r = r-l_0$` be the deviation from the equilibrium length, we have `$\\ddot{\\delta r} = \\ddot{r}$`, and the equation for the stiff mode becomes:\n$$\n\\mu \\ddot{\\delta r} + k \\delta r = 0 \\quad \\implies \\quad \\ddot{\\delta r} + \\left(\\frac{k}{\\mu}\\right) \\delta r = 0\n$$\nThis is the canonical equation for a simple harmonic oscillator, `$\\ddot{x} + \\omega^2 x = 0$`, with an angular frequency `$\\omega_{\\text{penalty}}$` given by:\n$$\n\\omega_{\\text{penalty}} = \\sqrt{\\frac{k}{\\mu}}\n$$\nFor stable explicit time integration schemes such as velocity-Verlet or central-difference, the time step `$\\Delta t$` must be small enough to resolve the fastest oscillations in the system. The stability limit is given by `$\\omega_{\\max} \\Delta t \\le C$`, where `$\\omega_{\\max}$` is the highest frequency in the system and `$C$` is a constant, typically `$2$`. Thus, the maximum stable time step is `$\\Delta t_{\\max} \\approx 2/\\omega_{\\max}$`.\n\nThe system has two sources of high-frequency motion: the penalty force, with frequency `$\\omega_{\\text{penalty}}$`, and other physical interactions summarized by the given highest physical frequency, `$\\omega_{\\text{phys}}$`. The overall highest frequency is the maximum of these two:\n$$\n\\omega_{\\max} = \\max(\\omega_{\\text{penalty}}, \\omega_{\\text{phys}})\n$$\nUsing the minimum required stiffness `$k_{\\text{min}}$` from Part 1, the maximum stable time step for the penalty method is:\n$$\n\\Delta t_{\\text{max, penalty}} = \\frac{2}{\\omega_{\\max}} = \\frac{2}{\\max\\left(\\sqrt{\\frac{k_{\\text{min}}}{\\mu}}, \\omega_{\\text{phys}}\\right)}\n$$\nThis is the second quantity to be computed.\n\n### Part 3: Maximum Stable Time Step with Augmented Lagrangian ($\\Delta t_{\\text{max, aug-lag}}$)\n\nIn an augmented Lagrangian method with exact projection, the bond-length constraint `$r - l_0 = 0$` is enforced exactly at each time step using an algorithmic projection (e.g., as in the SHAKE or RATTLE algorithms). In this scenario, the stiff vibrational mode associated with the penalty force is effectively removed from the time evolution of the system's coordinates. The penalty term, if present, serves only to guide the iterative convergence of the Lagrange multipliers and does not directly govern the dynamics integrated by the explicit scheme.\n\nAs stated in the problem, this procedure \"removes the penalty-induced stiff mode from the evolution\". Consequently, the stability of the time integration is no longer limited by `$\\omega_{\\text{penalty}}$`. The maximum stable time step is now dictated by the next highest frequency present in the system, which is the given highest physical frequency, `$\\omega_{\\text{phys}}$`. The maximum stable time step is therefore:\n$$\n\\Delta t_{\\text{max, aug-lag}} = \\frac{2}{\\omega_{\\text{phys}}}\n$$\nThis is the third and final quantity to be computed.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes penalty stiffness and stable time steps for a two-mass system\n    with a bond-length constraint, comparing penalty and augmented Lagrangian methods.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case: (m1, m2, l0, F_max, eps_tol, omega_phys) in SI units.\n    test_cases = [\n        (1.0e-26, 2.0e-26, 1.0e-10, 1.0e-9, 1.0e-13, 1.0e13),\n        (1.0e-26, 2.0e-26, 1.0e-10, 1.0e-9, 1.0e-15, 1.0e13),\n        (1.0e-25, 1.0e-27, 1.0e-10, 5.0e-10, 5.0e-13, 2.0e13),\n        (1.0e-26, 2.0e-26, 1.0e-10, 5.0e-9, 1.0e-12, 1.0e12),\n    ]\n\n    results = []\n    for case in test_cases:\n        m1, m2, l0, F_max, eps_tol, omega_phys = case\n\n        # Part 1: Minimum penalty stiffness (k_min)\n        # k_min ensures that under the maximum load F_max, the violation does not exceed eps_tol.\n        # F_max = k_min * eps_tol => k_min = F_max / eps_tol\n        k_min = F_max / eps_tol\n\n        # Part 2: Maximum stable time step with the penalty method (dt_max_penalty)\n        # This is limited by the highest frequency in the system.\n        \n        # Calculate the reduced mass of the two-body system.\n        mu = (m1 * m2) / (m1 + m2)\n        \n        # Calculate the frequency induced by the penalty spring.\n        # omega_penalty^2 = k_min / mu\n        omega_penalty = np.sqrt(k_min / mu)\n        \n        # The stability-limiting frequency is the max of the penalty and physical frequencies.\n        omega_max = max(omega_penalty, omega_phys)\n        \n        # The stability limit for velocity-Verlet is dt = 2 / omega_max.\n        dt_max_penalty = 2.0 / omega_max\n\n        # Part 3: Maximum stable time step with the augmented Lagrangian method (dt_max_aug_lag)\n        # With exact projection, the stiff mode from the penalty is removed.\n        # The stability is determined only by the highest physical frequency.\n        dt_max_aug_lag = 2.0 / omega_phys\n\n        # Store the three results for this test case.\n        results.append([k_min, dt_max_penalty, dt_max_aug_lag])\n\n    # Final print statement in the exact required format.\n    # The map(str, results) will convert each inner list to its string representation.\n    # The join then concatenates them with commas.\n    # The outer f-string adds the enclosing square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}