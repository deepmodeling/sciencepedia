{
    "hands_on_practices": [
        {
            "introduction": "为了在实践中使用 Martyna-Tobias-Klein (MTK) 恒压器，我们需要一个能够随时间演化系统的数值积分器。我们可以运用对称的 Trotter-Strang 分裂方法，将复杂的动力学过程分解为一系列更简单、可解析求解的子步骤。此练习将从第一性原理出发，指导您构建一个时间可逆且具有良好长期稳定性的 NPT 积分器，从而将理论方程转化为可工作的算法 。",
            "id": "3823622",
            "problem": "你的任务是推导、形式化并实现一个用于恒定粒子数、压强、温度（NPT）系综下各向同性 Martyna-Tobias-Klein (MTK) 动力学的一步可逆分裂积分器，该积分器适用于多尺度材料模拟。你必须从第一性原理出发：牛顿第二定律、速度作为位置时间导数的定义，以及通过维里表达式计算的瞬时压强。你不能依赖任何预先给定的积分器公式。相反，你必须将连续时间流识别并分解为可解析求解的子流，并构建一个时间可逆的对称组合。\n\n推导必须针对边长为 $L$ 的立方体盒子的各向同性体积涨落，其体积为 $V = L^3$，并且单个标量控压器变量全局地与位置和速度耦合。设系统包含 $N$ 个质量为 $m$ 的点状粒子，在三维空间中运动。粒子 $i$ 受到的力被建模为一个来自谐振限制势的线性恢复力，$\\mathbf{f}_i(\\mathbf{r}_i) = -k \\mathbf{r}_i$，其中 $k$ 是弹簧常数。瞬时动能为 $K = \\frac{1}{2} \\sum_{i=1}^{N} m \\lVert \\mathbf{v}_i \\rVert^2$，维里项为 $W = \\sum_{i=1}^{N} \\mathbf{r}_i \\cdot \\mathbf{f}_i$。瞬时内压由经过充分检验的维里表达式给出\n$$\nP_{\\mathrm{int}} = \\frac{2 K + W}{3 V}.\n$$\n外部压强为 $P_{\\mathrm{ext}}$。各向同性控压器变量为 $\\eta$，其共轭动量为 $p_\\eta$，质量为 $W_b$（控压器质量）。该耦合必须与模拟单元的各向同性膨胀和收缩一致，并与压强差 $P_{\\mathrm{int}} - P_{\\mathrm{ext}}$ 下的机械功相符。\n\n任务 1 (推导)：从 $d \\mathbf{r}_i/dt = \\mathbf{v}_i$ 和 $d \\mathbf{v}_i/dt = \\mathbf{f}_i/m$ 出发，并使用上述维里压强定义，识别并论证一组子流，使得每个子流对于有限时间增量都有一个闭式解析解。这些子流应包括：\n- 一个因力更新速度的力子流。\n- 一个由压强差驱动更新 $p_\\eta$ 的控压器动量子流。\n- 一个控压器膨胀子流，其中位置、盒子长度和速度在固定的 $\\eta$ 下，根据控压器耦合进行演化。\n- 一个在固定速度下推进位置的自由流子流。\n构建一个在一个时间步长 $\\Delta t$ 内的可逆对称组合（例如，一个回文序列的子流），该组合近似于完整的动力学过程，并为 $\\mathbf{r}_i$、$\\mathbf{v}_i$、$L$、$\\eta$ 和 $p_\\eta$ 指定一个时间步长的精确更新公式。\n\n任务 2 (实现)：根据你推导的对称组合，使用以下约定和单位，在代码中实现一步积分器：\n- 使用约化单位制，基本单位为 $M_0$（质量）、$L_0$（长度）和 $E_0$（能量）。所有量都应以这些约化单位输出。在这些单位中，玻尔兹曼常数设为 $k_B = 1$。\n- 控压器质量为 $W_b$（单位为 $M_0 L_0^2$）。\n- 算法必须从初始的 $\\mathbf{r}_i$、$\\mathbf{v}_i$、$L$、$\\eta = 0$ 和 $p_\\eta = 0$ 开始，精确执行一个大小为 $\\Delta t$ 的完整可逆时间步长。\n\n系统设置：\n- 维度为三，因此自由度数为 $3N$。\n- 所有粒子的质量均为 $m = 1$。\n- 谐振力参数 $k$ 在每个测试案例中指定。\n- 位置 $\\mathbf{r}_i$ 通过在以原点为中心、边长为 $L$ 的立方体内均匀采样来初始化，即每个分量从区间 $[-L/2, L/2]$ 中采样。\n- 速度 $\\mathbf{v}_i$ 从每个分量均值为零、标准差为 $\\sigma_v$ 的正态分布中初始化。\n- 为保证可复现性，使用给定的整数种子进行确定性伪随机初始化。\n\n角度单位：如果使用角度（此处不应需要），则必须以弧度为单位。所需输出中不出现角度。\n\n测试套件：\n实现你的程序以运行以下四个测试案例。每个测试案例定义了 $(N, L, k, W_b, \\Delta t, \\sigma_v, P_{\\mathrm{ext}}, \\text{seed})$：\n1. 案例 A (正常路径)：$N = 8$, $L = 6.0$, $k = 0.5$, $W_b = 50.0$, $\\Delta t = 0.002$, $\\sigma_v = 0.2$, $P_{\\mathrm{ext}} = P_{\\mathrm{int}}$ 在初始状态下计算，$\\text{seed} = 12345$。\n2. 案例 B (时间步边界)：$N = 8$, $L = 6.0$, $k = 0.5$, $W_b = 50.0$, $\\Delta t = 10^{-6}$, $\\sigma_v = 0.2$, $P_{\\mathrm{ext}} = P_{\\mathrm{int}}$ 在初始状态下计算，$\\text{seed} = 23456$。\n3. 案例 C (强控压器响应)：$N = 4$, $L = 4.0$, $k = 1.2$, $W_b = 5.0$, $\\Delta t = 0.005$, $\\sigma_v = 0.5$, $P_{\\mathrm{ext}} = 0.05$, $\\text{seed} = 34567$。\n4. 案例 D (弱控压器响应)：$N = 16$, $L = 10.0$, $k = 0.3$, $W_b = 500.0$, $\\Delta t = 0.002$, $\\sigma_v = 0.1$, $P_{\\mathrm{ext}} = P_{\\mathrm{int}} + 0.02$ 在初始状态下计算，$\\text{seed} = 45678$。\n\n对于每个案例，精确执行一个可逆的 MTK 各向同性步骤。\n\n所需输出：\n对于每个测试案例，计算：\n- 在该步长内的相对体积变化，$\\Delta V / V$，其中 $\\Delta V = V_{\\text{new}} - V_{\\text{old}}$。\n- 在该步长内的动能变化，$\\Delta K = K_{\\text{new}} - K_{\\mathrm{old}}$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含所有测试案例的串联结果，格式为方括号内的逗号分隔列表，顺序如下\n$$\n[\\Delta V/V \\text{ (案例 A)}, \\Delta K \\text{ (案例 A)}, \\Delta V/V \\text{ (案例 B)}, \\Delta K \\text{ (案例 B)}, \\Delta V/V \\text{ (案例 C)}, \\Delta K \\text{ (案例 C)}, \\Delta V/V \\text{ (案例 D)}, \\Delta K \\text{ (案例 D)}].\n$$\n所有值都必须用上面指定的约化单位表示。",
            "solution": "我们从牛顿定律和速度的定义开始。对于粒子 $i$，运动方程为\n$$\n\\frac{d \\mathbf{r}_i}{dt} = \\mathbf{v}_i, \\quad \\frac{d \\mathbf{v}_i}{dt} = \\frac{\\mathbf{f}_i(\\mathbf{r}_i)}{m},\n$$\n其中，对于谐振限制势，$\\mathbf{f}_i(\\mathbf{r}_i) = -k \\mathbf{r}_i$，且 $m = 1$。\n\n为了与压强耦合，我们使用瞬时内压的维里表达式，\n$$\nP_{\\mathrm{int}} = \\frac{2K + W}{3V},\n$$\n其中 $K = \\frac{1}{2}\\sum_{i=1}^{N} m \\lVert \\mathbf{v}_i \\rVert^2$ 且 $W = \\sum_{i=1}^{N} \\mathbf{r}_i \\cdot \\mathbf{f}_i$。这是一个在经典分子动力学中连接微观动力学与宏观压强的经过充分检验的公式，它适用于一般的保守力，而谐振力是其一个特例。\n\n对于各向同性体积动力学，我们引入一个标量控压器坐标 $\\eta$ 及其共轭动量 $p_\\eta$ 和控压器质量 $W_b$。一个物理上一致的选择（源自扩展系统方法）是让 $\\eta$ 产生模拟盒子和位置的各向同性膨胀，并以等值反号的方式作用于速度，以便在适当的测度校正下保持相空间体积元不变。我们规定控压器方程为：\n$$\n\\frac{d \\eta}{dt} = \\frac{p_\\eta}{W_b}, \\quad \\frac{d p_\\eta}{dt} = 3 V \\left( P_{\\mathrm{int}} - P_{\\mathrm{ext}} \\right),\n$$\n这与机械功 $-P\\,dV$ 相匹配，并将压强差与 $p_\\eta$ 的变化率耦合起来。因子 $3V$ 源于三维空间中的 $dV/dt = 3 V \\frac{d \\ln L}{dt}$。\n\n在控压器膨胀子流下，当 $\\eta$ 保持恒定时，由各向同性缩放引起的演化由以下方程表征\n$$\n\\frac{d L}{dt} = \\eta L, \\quad \\frac{d \\mathbf{r}_i}{dt} = \\eta \\mathbf{r}_i, \\quad \\frac{d \\mathbf{v}_i}{dt} = -\\eta \\mathbf{v}_i,\n$$\n这对于有限时间增量 $\\tau$ 具有精确解：\n$$\nL(t+\\tau) = L(t) \\exp(\\eta \\tau), \\quad \\mathbf{r}_i(t+\\tau) = \\mathbf{r}_i(t) \\exp(\\eta \\tau), \\quad \\mathbf{v}_i(t+\\tau) = \\mathbf{v}_i(t) \\exp(-\\eta \\tau).\n$$\n这种选择在膨胀下标定了坐标，并确保了动能和势能的一致性。\n\n为了设计一个可逆和对称的积分器，我们使用 Trotter (Strang) 分裂法，将完整的刘维尔算符分解为可解析求解的子流：\n- 力子流 $\\mathcal{F}$：$\\mathbf{v}_i \\mapsto \\mathbf{v}_i + (\\mathbf{f}_i/m)\\,\\delta t$，位置和控压器变量固定。\n- 控压器动量子流 $\\mathcal{P}$：$p_\\eta \\mapsto p_\\eta + 3 V \\left( P_{\\mathrm{int}} - P_{\\mathrm{ext}} \\right) \\delta t$，在此子步骤中保持 $\\mathbf{r}_i$、$\\mathbf{v}_i$、$L$ 和 $\\eta$ 固定。这里的 $P_{\\mathrm{int}}$ 是根据当前的 $\\mathbf{r}_i$、$\\mathbf{v}_i$ 和 $V$ 计算的。\n- 控压器坐标（膨胀）子流 $\\mathcal{S}$：在时间 $\\delta t$ 内，使用精确的指数更新，在固定的 $\\eta$ 下演化 $L$、$\\mathbf{r}_i$ 和 $\\mathbf{v}_i$，同时保持 $p_\\eta$ 固定。\n- 自由流子流 $\\mathcal{R}$：在时间 $\\delta t$ 内，在固定速度下更新位置，即 $\\mathbf{r}_i \\mapsto \\mathbf{r}_i + \\mathbf{v}_i \\delta t$，同时保持 $L$、$\\eta$ 和 $p_\\eta$ 固定。\n\n一个完整时间步长 $\\Delta t$ 上的可逆对称组合即为\n$$\n\\mathcal{F}\\left(\\frac{\\Delta t}{2}\\right)\n\\circ \\mathcal{P}\\left(\\frac{\\Delta t}{2}\\right)\n\\circ \\mathcal{S}\\left(\\frac{\\Delta t}{2}\\right)\n\\circ \\mathcal{R}\\left(\\Delta t\\right)\n\\circ \\mathcal{S}\\left(\\frac{\\Delta t}{2}\\right)\n\\circ \\mathcal{P}\\left(\\frac{\\Delta t}{2}\\right)\n\\circ \\mathcal{F}\\left(\\frac{\\Delta t}{2}\\right),\n$$\n它是回文式的，因此是时间可逆的。每个子流都用其精确解来实现。\n\n综上所述，具有变量 $(\\mathbf{r}_i, \\mathbf{v}_i, L, \\eta, p_\\eta)$ 的一步算法如下：\n\n- 步骤 $\\mathcal{F}(\\Delta t/2)$：\n  因力更新速度：\n  $$\n  \\mathbf{v}_i \\leftarrow \\mathbf{v}_i + \\frac{\\mathbf{f}_i(\\mathbf{r}_i)}{m} \\frac{\\Delta t}{2}.\n  $$\n\n- 计算 $V = L^3$, $K = \\frac{1}{2} \\sum_i m \\lVert \\mathbf{v}_i \\rVert^2$, $W = \\sum_i \\mathbf{r}_i \\cdot \\mathbf{f}_i(\\mathbf{r}_i)$，以及 $P_{\\mathrm{int}} = \\frac{2K + W}{3V}$。\n\n- 步骤 $\\mathcal{P}(\\Delta t/2)$：\n  $$\n  p_\\eta \\leftarrow p_\\eta + 3 V \\left( P_{\\mathrm{int}} - P_{\\mathrm{ext}} \\right) \\frac{\\Delta t}{2}.\n  $$\n\n- 步骤 $\\mathcal{S}(\\Delta t/2)$：\n  使用控压器质量更新半个步长的 $\\eta$：\n  $$\n  \\eta \\leftarrow \\eta + \\frac{p_\\eta}{W_b} \\frac{\\Delta t}{2}.\n  $$\n  然后在 $\\Delta t/2$ 内应用固定 $\\eta$ 的膨胀：\n  $$\n  s \\leftarrow \\exp\\left(\\eta \\frac{\\Delta t}{2}\\right), \\quad\n  L \\leftarrow L \\, s, \\quad\n  \\mathbf{r}_i \\leftarrow \\mathbf{r}_i \\, s, \\quad\n  \\mathbf{v}_i \\leftarrow \\mathbf{v}_i / s.\n  $$\n\n- 步骤 $\\mathcal{R}(\\Delta t)$：\n  位置的自由流：\n  $$\n  \\mathbf{r}_i \\leftarrow \\mathbf{r}_i + \\mathbf{v}_i \\Delta t.\n  $$\n\n- 步骤 $\\mathcal{S}(\\Delta t/2)$：\n  使用当前的 $\\eta$ 应用后半部分膨胀：\n  $$\n  s \\leftarrow \\exp\\left(\\eta \\frac{\\Delta t}{2}\\right), \\quad\n  L \\leftarrow L \\, s, \\quad\n  \\mathbf{r}_i \\leftarrow \\mathbf{r}_i \\, s, \\quad\n  \\mathbf{v}_i \\leftarrow \\mathbf{v}_i / s.\n  $$\n  然后推进 $\\eta$ 剩下的半个步长：\n  $$\n  \\eta \\leftarrow \\eta + \\frac{p_\\eta}{W_b} \\frac{\\Delta t}{2}.\n  $$\n\n- 使用当前状态重新计算 $V = L^3$, $K$, $W$ 和 $P_{\\mathrm{int}}$。\n\n- 步骤 $\\mathcal{P}(\\Delta t/2)$：\n  $$\n  p_\\eta \\leftarrow p_\\eta + 3 V \\left( P_{\\mathrm{int}} - P_{\\mathrm{ext}} \\right) \\frac{\\Delta t}{2}.\n  $$\n\n- 步骤 $\\mathcal{F}(\\Delta t/2)$：\n  根据在新位置上计算的力来更新速度：\n  $$\n  \\mathbf{v}_i \\leftarrow \\mathbf{v}_i + \\frac{\\mathbf{f}_i(\\mathbf{r}_i)}{m} \\frac{\\Delta t}{2}.\n  $$\n\n这样就完成了一个可逆、对称的 MTK 各向同性时间步长。\n\n测试套件的实现细节：\n\n每个案例的初始化：\n- 对所有粒子设置 $m = 1$。\n- 均匀采样位置：使用指定的种子从 $[-L/2, L/2]$ 中采样 $\\mathbf{r}_i$ 的每个分量。\n- 从正态分布 $\\mathcal{N}(0, \\sigma_v^2)$ 中采样每个分量的速度。\n- 设置 $\\eta = 0$ 和 $p_\\eta = 0$。\n- 按规定计算 $P_{\\mathrm{ext}}$：可以是一个给定的常数，也可以等于初始的 $P_{\\mathrm{int}}$，后者通过初始的 $(\\mathbf{r}_i, \\mathbf{v}_i, L)$ 由 $P_{\\mathrm{int}} = (2K + W)/(3V)$ 计算得出。\n\n每个案例的输出：\n- 在步长前计算 $V_{\\mathrm{old}} = L_{\\mathrm{old}}^3$, $K_{\\mathrm{old}} = \\frac{1}{2} \\sum_i \\lVert \\mathbf{v}_i \\rVert^2$。\n- 在步长后计算 $V_{\\mathrm{new}} = L_{\\mathrm{new}}^3$ 和 $K_{\\mathrm{new}}$。\n- 报告 $\\Delta V / V = (V_{\\mathrm{new}} - V_{\\mathrm{old}})/V_{\\mathrm{old}}$ 和 $\\Delta K = K_{\\mathrm{new}} - K_{\\mathrm{old}}$。\n\n最终程序应按顺序处理四个案例，并打印一行包含八个值的输出：$[\\Delta V/V \\text{ (A)}, \\Delta K \\text{ (A)}, \\Delta V/V \\text{ (B)}, \\Delta K \\text{ (B)}, \\Delta V/V \\text{ (C)}, \\Delta K \\text{ (C)}, \\Delta V/V \\text{ (D)}, \\Delta K \\text{ (D)}]$。\n\n科学真实性和边缘情况覆盖：\n- 案例 A 使用中等参数来检验一般路径。\n- 案例 B 检查当 $\\Delta t \\to 0$ 时的边界行为，预期变化可忽略不计。\n- 案例 C 使用较小的 $W_b$ 和显著的压强不匹配来测试强控压器响应。\n- 案例 D 使用较大的 $W_b$ 和较小的压强不匹配来测试弱响应。\n\n所有计算均在约化单位制下进行，且 $k_B = 1$。不使用角度。该算法严格基于第一性原理和可解析求解的子流，确保了有原则的可逆积分器设计。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_forces(r, k):\n    # Harmonic confining force: f_i = -k * r_i\n    return -k * r\n\ndef kinetic_energy(v, m=1.0):\n    return 0.5 * m * np.sum(v * v)\n\ndef virial(r, f):\n    # W = sum_i r_i · f_i\n    return float(np.sum(r * f))\n\ndef pressure_internal(r, v, L, k, m=1.0):\n    V = L**3\n    f = compute_forces(r, k)\n    K = kinetic_energy(v, m)\n    W = virial(r, f)\n    P_int = (2.0 * K + W) / (3.0 * V)\n    return P_int, V, K, W\n\ndef mtk_isotropic_step(r, v, L, eta, p_eta, dt, k, Wb, P_ext, m=1.0):\n    # One reversible symmetric step: F(dt/2) P(dt/2) S(dt/2) R(dt) S(dt/2) P(dt/2) F(dt/2)\n    # F half-step\n    f = compute_forces(r, k)\n    v = v + (f / m) * (dt * 0.5)\n\n    # Compute pressure for P half-step\n    P_int, V, K, W = pressure_internal(r, v, L, k, m)\n    p_eta = p_eta + 3.0 * V * (P_int - P_ext) * (dt * 0.5)\n\n    # S half-step: advance eta half-step, then apply dilation with fixed eta\n    eta = eta + (p_eta / Wb) * (dt * 0.5)\n    s = np.exp(eta * (dt * 0.5))\n    L = L * s\n    r = r * s\n    v = v / s\n\n    # R full-step: free streaming\n    r = r + v * dt\n\n    # S half-step again\n    s = np.exp(eta * (dt * 0.5))\n    L = L * s\n    r = r * s\n    v = v / s\n    eta = eta + (p_eta / Wb) * (dt * 0.5)\n\n    # Compute pressure for second P half-step\n    P_int, V, K, W = pressure_internal(r, v, L, k, m)\n    p_eta = p_eta + 3.0 * V * (P_int - P_ext) * (dt * 0.5)\n\n    # F half-step again with updated positions\n    f = compute_forces(r, k)\n    v = v + (f / m) * (dt * 0.5)\n\n    return r, v, L, eta, p_eta\n\ndef init_case(N, L, sigma_v, seed):\n    rng = np.random.default_rng(seed)\n    # Positions uniformly in [-L/2, L/2]\n    r = rng.uniform(low=-L/2.0, high=L/2.0, size=(N, 3))\n    # Velocities normal with std sigma_v\n    v = rng.normal(loc=0.0, scale=sigma_v, size=(N, 3))\n    return r, v\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, L, k, Wb, dt, sigma_v, P_ext_mode, seed)\n    # P_ext_mode: 'initial' means P_ext = initial P_int; or a float sets P_ext constant.\n    test_cases = [\n        # Case A\n        {'N': 8, 'L': 6.0, 'k': 0.5, 'Wb': 50.0, 'dt': 0.002, 'sigma_v': 0.2, 'P_ext_mode': 'initial', 'seed': 12345},\n        # Case B\n        {'N': 8, 'L': 6.0, 'k': 0.5, 'Wb': 50.0, 'dt': 1e-6, 'sigma_v': 0.2, 'P_ext_mode': 'initial', 'seed': 23456},\n        # Case C\n        {'N': 4, 'L': 4.0, 'k': 1.2, 'Wb': 5.0, 'dt': 0.005, 'sigma_v': 0.5, 'P_ext_mode': 0.05, 'seed': 34567},\n        # Case D\n        {'N': 16, 'L': 10.0, 'k': 0.3, 'Wb': 500.0, 'dt': 0.002, 'sigma_v': 0.1, 'P_ext_mode': 'initial_plus', 'seed': 45678, 'delta': 0.02},\n    ]\n\n    results = []\n    m = 1.0\n\n    for case in test_cases:\n        N = case['N']\n        L = case['L']\n        k = case['k']\n        Wb = case['Wb']\n        dt = case['dt']\n        sigma_v = case['sigma_v']\n        seed = case['seed']\n\n        # Initialize state\n        r, v = init_case(N, L, sigma_v, seed)\n        eta = 0.0\n        p_eta = 0.0\n\n        # Compute initial pressure for cases requiring it\n        P_int0, V0, K0, W0 = pressure_internal(r, v, L, k, m)\n        if case['P_ext_mode'] == 'initial':\n            P_ext = P_int0\n        elif case['P_ext_mode'] == 'initial_plus':\n            P_ext = P_int0 + case.get('delta', 0.0)\n        else:\n            P_ext = float(case['P_ext_mode'])\n\n        # Perform one MTK isotropic reversible step\n        r_new, v_new, L_new, eta_new, p_eta_new = mtk_isotropic_step(\n            r, v, L, eta, p_eta, dt, k, Wb, P_ext, m\n        )\n\n        # Compute outputs: fractional volume change and kinetic energy change\n        V_new = L_new**3\n        K_new = kinetic_energy(v_new, m)\n        dV_frac = (V_new - V0) / V0\n        dK = K_new - K0\n\n        results.append(dV_frac)\n        results.append(dK)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然精确的扩展哈密顿量在连续时间内是守恒的，但任何离散时间步长的积分器都会引入误差。一个设计良好的对称积分器，其数值轨迹并不精确守恒原始哈密顿量，而是精确守恒一个与其接近的“影子”哈密顿量，这使得能量误差有界，其大小与 $\\Delta t^2$ 成正比。本练习将演示如何通过数值实验验证这一关键特性，从而增强您对所实现算法长期稳定性的信心，并阐明几何积分中的一个深刻概念 。",
            "id": "3823623",
            "problem": "您需要设计并实现一个在无量纲约化单位下的数值实验，该实验用于量化一个与 Martyna-Tobias-Klein (MTK) 恒压器耦合的系统中守恒扩展能量的偏差，并经验性地将此偏差与源于对称时间可逆分裂的一阶影子哈密顿量修正关联起来。考虑一个一维系统，其中包含一个理想粒子、一个各向同性标量恒压器，且无恒温器。物理粒子的位置为 $r$，动量为 $p$，质量为 $m$。标量恒压器使用变量 $\\eta$（对数应变）、动量 $p_{\\eta}$ 和恒压器质量 $W$。模拟盒子的长度记为 $V$，并施加一个恒定的外部压力 $P_{\\mathrm{ext}}$。所有计算均在无量纲约化单位下进行，并以无单位的小数形式报告所有输出。\n\n从基本原理出发：使用扩展哈密顿量的哈密顿力学\n$$\nH_{\\mathrm{ext}}(r,p;\\eta,p_{\\eta};V) = \\frac{p^2}{2 m} + P_{\\mathrm{ext}}\\, V + \\frac{p_{\\eta}^2}{2 W}.\n$$\n对于一维理想粒子，瞬时内压估计量由下式给出\n$$\nP_{\\mathrm{int}} = \\frac{2 K}{d\\, V} = \\frac{p^2}{m\\, V},\n$$\n其中 $K = \\frac{p^2}{2 m}$ 是动能，$d = 1$ 是空间维度。恒压器通过标量应变率 $\\dot{\\eta} = \\frac{p_{\\eta}}{W}$ 将粒子和盒子耦合起来，产生与各向同性形变一致的 $r$ 和 $V$ 的均匀缩放。使用以下用于对称 Strang 分裂（对于可分哈密顿量，也称为速度-Verlet 形式）的精确流，表示为两个子哈密顿量流 $A$ 和 $B$：\n\n- 流 $A$（自由膨胀，包含动能和恒压器动能的贡献）：在子步中，$\\dot{\\eta} = \\frac{p_{\\eta}}{W}$ 保持恒定，演化时间 $\\Delta t$ 如下\n$$\n\\alpha = \\Delta t \\,\\frac{p_{\\eta}}{W}, \\quad\np \\leftarrow p\\, e^{-\\alpha}, \\quad\nV \\leftarrow V\\, e^{\\alpha}, \\quad\n\\eta \\leftarrow \\eta + \\alpha, \\quad\nr \\leftarrow e^{\\alpha} r + \\begin{cases}\n\\frac{p_0}{m}\\,\\frac{\\sinh(\\alpha)}{\\dot{\\eta}},  \\text{if } |\\dot{\\eta}| > 0, \\\\\n\\frac{p_0}{m}\\,\\Delta t,  \\text{if } \\dot{\\eta} = 0,\n\\end{cases}\n$$\n其中 $p_0$ 是 $A$ 流子步开始时 $p$ 的值。\n\n- 流 $B$（压力耦合脉冲）：在保持 $p$、$V$、$r$ 和 $\\eta$ 固定的情况下，使用以下公式演化 $p_{\\eta}$ 时间 $\\Delta t/2$\n$$\np_{\\eta} \\leftarrow p_{\\eta} + \\frac{\\Delta t}{2}\\, \\left( V \\left(P_{\\mathrm{int}} - P_{\\mathrm{ext}} \\right) \\right) = p_{\\eta} + \\frac{\\Delta t}{2}\\, \\left( \\frac{p^2}{m} - V P_{\\mathrm{ext}} \\right).\n$$\n将这些组合成一个持续时间为 $\\Delta t$ 的对称 Strang 分裂步：\n$$\n\\text{踢步 } B\\left(\\frac{\\Delta t}{2}\\right) \\;\\rightarrow\\; \\text{漂移步 } A\\left(\\Delta t\\right) \\;\\rightarrow\\; \\text{踢步 } B\\left(\\frac{\\Delta t}{2}\\right).\n$$\n\n您的程序必须：\n- 用 $m = 1$, $P_{\\mathrm{ext}} = 0.5$, $V_0 = 1$, $\\eta_0 = 0$, $p_0 = 1.25$, $p_{\\eta,0} = 0$ 和 $r_0 = 1$ 初始化系统。\n- 对于每个测试用例，使用上述对称步长，以指定的时间步长 $\\Delta t$ 和恒压器质量 $W$ 运行总物理时间 $T = 50$。\n- 在每个完整步长，使用上述公式计算扩展能量 $H_{\\mathrm{ext}}$。令 $H_0$ 为 $t = 0$ 时的初始值。计算所有记录步数的时间平均值 $\\overline{H}$。将观测到的影子修正代理定义为\n$$\nR = \\frac{\\overline{H} - H_0}{\\Delta t^2}.\n$$\n如果一阶影子哈密顿量修正是 $\\Delta t^2$ 阶，如此量 $R$ 应（对于足够小的 $\\Delta t$）近似为常数，正如对称分裂的后向误差分析所预测的那样。\n\n提供一个测试套件，用于检验不同方面：\n- 顺利路径：$\\Delta t$ 较小，方法稳定且影子修正的标度性可见。\n- 中间情况：中等大小的 $\\Delta t$，以测试标度性的稳健性。\n- 小步长边界情况：非常小的 $\\Delta t$，以探测渐近区域。\n- 接近稳定性边界：较大的 $\\Delta t$，可能会开始破坏渐近标度性。\n\n使用以下测试套件，每个测试用例为一个三元组 $(\\Delta t, W, \\text{steps})$，其中 $\\text{steps} = T / \\Delta t$：\n- 测试 $1$：$(\\Delta t = 0.001, W = 100, \\text{steps} = 50000)$。\n- 测试 $2$：$(\\Delta t = 0.005, W = 100, \\text{steps} = 10000)$。\n- 测试 $3$：$(\\Delta t = 0.010, W = 100, \\text{steps} = 5000)$。\n- 测试 $4$：$(\\Delta t = 0.050, W = 100, \\text{steps} = 1000)$。\n\n对于每个测试用例，计算 $R$，并为评估标度性，计算一个布尔值 $S$，定义如下：计算前三个 $R$ 值的平均值，并检查这前三个 $R$ 值中的每一个是否都在该平均值的 $0.15$ 相对偏差内（即 $\\pm 15\\%$ 内）。如果是，则设置 $S = \\mathrm{True}$；否则设置 $S = \\mathrm{False}$。在计算 $S$ 时不要使用第四个测试用例。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个逗号分隔并用方括号括起来的结果列表，顺序为 $[R_1,R_2,R_3,R_4,S]$，其中每个 $R_i$ 是一个无单位小数，$S$ 是一个布尔值。例如：\"[0.1234,0.5678,0.9101,1.2345,True]\"。",
            "solution": "该问题要求设计并实现一个数值实验，以研究 Martyna-Tobias-Klein (MTK) 恒压器算法的守恒性质。具体来说，我们将量化一个简单一维系统中守恒扩展能量的偏差，并经验性地验证由对称时间可逆分裂积分器产生的一阶误差项的理论 $\\mathcal{O}(\\Delta t^2)$ 标度性。通过后向误差分析，这个误差被理解为数值方法所精确守恒的“影子”哈密顿量中的第一个修正项。\n\n该系统由一个质量为 $m$、位置为 $r$、动量为 $p$ 的单个理想粒子组成，该粒子位于一个长度为 $V$ 的一维盒子中。系统与一个各向同性标量恒压器耦合，该恒压器由对数应变变量 $\\eta$ 及其共轭动量 $p_{\\eta}$ 描述，并具有相关质量 $W$。施加一个恒定的外部压力 $P_{\\mathrm{ext}}$。这个扩展系统的动力学由扩展哈密顿量控制：\n$$\nH_{\\mathrm{ext}}(r,p;\\eta,p_{\\eta};V) = \\frac{p^2}{2 m} + P_{\\mathrm{ext}}\\, V + \\frac{p_{\\eta}^2}{2 W}\n$$\n理想粒子没有内部势能。其动能为 $K = \\frac{p^2}{2m}$。瞬时内压由维里定理在 $d=1$ 空间维度下导出，为 $P_{\\mathrm{int}} = \\frac{2K}{dV} = \\frac{p^2}{mV}$。\n\n为了积分运动方程，我们采用对称 Strang 分裂方案。这涉及将与哈密顿量对应的完整刘维尔算子 $\\mathcal{L}$ 分解为两部分，$\\mathcal{L} = \\mathcal{L}_A + \\mathcal{L}_B$。一个大小为 $\\Delta t$ 的步长的时间演化算子则近似为：\n$$\ne^{\\mathcal{L}\\Delta t} \\approx e^{\\mathcal{L}_B \\Delta t/2} \\, e^{\\mathcal{L}_A \\Delta t} \\, e^{\\mathcal{L}_B \\Delta t/2}\n$$\n这对应于一系列操作：一个半步“踢步”，一个整步“漂移步”，以及另一个半步“踢步”。\n\n该分解基于哈密顿量的分量。\nA 部分，即“漂移步”，包括粒子动能和恒压器动能：$H_A = \\frac{p^2}{2 m} + \\frac{p_{\\eta}^2}{2 W}$。哈密顿量的这部分通过应变率 $\\dot{\\eta} = \\frac{p_{\\eta}}{W}$ 产生以下耦合的运动方程：\n$$\n\\dot{r} = \\frac{p}{m} + \\dot{\\eta} r, \\quad \\dot{p} = -\\dot{\\eta} p, \\quad \\dot{V} = \\dot{\\eta} V, \\quad \\dot{\\eta} = \\frac{p_\\eta}{W}\n$$\n在时间间隔 $\\Delta t$ 内，当 $p_{\\eta}$ 保持恒定（因为它不由 $H_A$ 演化）时，这些方程可以解析地积分。定义 $\\alpha = \\Delta t \\cdot \\dot{\\eta} = \\Delta t \\frac{p_{\\eta}}{W}$，则在 $H_A$ 下演化时间 $\\Delta t$ 的精确解为：\n\\begin{align*}\np(\\Delta t) = p(0)\\, e^{-\\alpha} \\\\\nV(\\Delta t) = V(0)\\, e^{\\alpha} \\\\\n\\eta(\\Delta t) = \\eta(0) + \\alpha \\\\\nr(\\Delta t) = e^{\\alpha} r(0) + \\begin{cases}\n\\frac{p(0)}{m}\\,\\frac{\\sinh(\\alpha)}{\\dot{\\eta}},  \\text{if } |\\dot{\\eta}| > 0 \\\\\n\\frac{p(0)}{m}\\,\\Delta t,  \\text{if } \\dot{\\eta} = 0\n\\end{cases}\n\\end{align*}\n\nB 部分，即“踢步”，包括压力-体积项：$H_B = P_{\\mathrm{ext}}V$。$p_{\\eta}$ 的运动方程由 $\\dot{p}_{\\eta} = -\\frac{\\partial H}{\\partial \\eta} = V(P_{\\mathrm{int}} - P_{\\mathrm{ext}})$ 给出。在保持所有其他变量恒定的情况下，将其积分半步 $\\Delta t/2$ 可得到更新规则：\n$$\np_{\\eta}(\\Delta t/2) = p_{\\eta}(0) + \\frac{\\Delta t}{2} \\left( V \\left(P_{\\mathrm{int}} - P_{\\mathrm{ext}} \\right) \\right) = p_{\\eta}(0) + \\frac{\\Delta t}{2} \\left( \\frac{p^2}{m} - V P_{\\mathrm{ext}} \\right)\n$$\n\n单个时间步长 $\\Delta t$ 的完整模拟过程如下：\n1. 对 $p_{\\eta}$ 应用踢步更新（B 部分），持续时间为 $\\Delta t/2$。\n2. 对 $r, p, V, \\eta$ 应用漂移步更新（A 部分），持续时间为 $\\Delta t$。\n3. 再次对 $p_{\\eta}$ 应用踢步更新（B 部分），持续时间为 $\\Delta t/2$。\n\n数值实验用 $m = 1$、$P_{\\mathrm{ext}} = 0.5$、$V_0 = 1$、$\\eta_0 = 0$、$p_0 = 1.25$、$p_{\\eta,0} = 0$ 和 $r_0 = 1$ 初始化系统。然后，针对几个时间步长 $\\Delta t$ 和恒压器质量 $W$ 的选择，运行总时间 $T=50$。在每个完整步长，计算并记录扩展哈密顿量 $H_{\\mathrm{ext}}$ 的值。\n\n对于对称积分器，数值轨迹精确地守恒一个邻近的影子哈密顿量 $H_{\\mathrm{shadow}} = H_{\\mathrm{ext}} + \\delta H_2 \\Delta t^2 + \\mathcal{O}(\\Delta t^4)$。初始值 $H_0 = H_{\\mathrm{ext}}(t=0)$ 和轨迹上的时间平均值 $\\overline{H}$ 预计相差一个与 $\\Delta t^2$ 成正比的量。因此，我们定义一个领头阶修正项的代理为：\n$$\nR = \\frac{\\overline{H} - H_0}{\\Delta t^2}\n$$\n如果理论成立，对于足够小的 $\\Delta t$，$R$ 应近似为常数。我们通过计算四个 $\\Delta t$ 递减的测试用例的 $R$ 值来检验这一点。然后我们计算一个布尔值 $S$，如果前三个 $R$ 值都在其平均值的 $\\pm 15\\%$ 相对容差内，则 $S$ 为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。这可作为对 $\\mathcal{O}(\\Delta t^2)$ 误差标度性的经验性验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment for the MTK barostat.\n    It sets up test cases, runs the simulation for each, calculates the\n    shadow correction proxy R, and checks for scaling consistency S.\n    \"\"\"\n    \n    # Define constant physical parameters for the simulation\n    initial_params = {\n        'm': 1.0,\n        'P_ext': 0.5,\n        'r': 1.0,\n        'p': 1.25,\n        'V': 1.0,\n        'eta': 0.0,\n        'p_eta': 0.0,\n    }\n    \n    # Total simulation time\n    T = 50.0\n\n    # Test cases as tuples of (time_step, barostat_mass)\n    test_cases = [\n        (0.001, 100.0),\n        (0.005, 100.0),\n        (0.010, 100.0),\n        (0.050, 100.0),\n    ]\n\n    results_R = []\n    for dt, W in test_cases:\n        # Number of steps is total time divided by step size\n        steps = int(round(T / dt))\n        R = run_simulation(dt, W, steps, initial_params)\n        results_R.append(R)\n\n    # Perform the scaling check S using the first three R values\n    R_for_S = results_R[:3]\n    mean_R = np.mean(R_for_S)\n    \n    is_scaling_valid = False\n    # Check for the special case where the mean is close to zero.\n    if np.isclose(mean_R, 0.0):\n        # If all individual R values are also close to zero, they are consistent.\n        is_scaling_valid = all(np.isclose(r, 0.0) for r in R_for_S)\n    else:\n        # Calculate relative deviations from the mean\n        deviations = [abs(r - mean_R) / abs(mean_R) for r in R_for_S]\n        # Check if all deviations are within the 15% tolerance\n        is_scaling_valid = all(dev = 0.15 for dev in deviations)\n    \n    S = is_scaling_valid\n\n    # Format the final output string as specified\n    final_output = f\"[{','.join(map(str, results_R))},{S}]\"\n    print(final_output)\n\ndef calculate_H_ext(p, V, p_eta, m, W, P_ext):\n    \"\"\"\n    Calculates the extended Hamiltonian H_ext.\n    \"\"\"\n    K_particle = p**2 / (2.0 * m)\n    U_pressure = P_ext * V\n    K_barostat = p_eta**2 / (2.0 * W)\n    return K_particle + U_pressure + K_barostat\n\ndef run_simulation(dt, W, steps, initial_params):\n    \"\"\"\n    Runs a single simulation for a given set of parameters.\n\n    Args:\n        dt (float): The time step.\n        W (float): The barostat mass.\n        steps (int): The number of simulation steps.\n        initial_params (dict): Dictionary of initial state variables.\n\n    Returns:\n        float: The calculated shadow correction proxy R.\n    \"\"\"\n    m = initial_params['m']\n    P_ext = initial_params['P_ext']\n    \n    # Initialize state variables from the dictionary\n    r, p, V, eta, p_eta = (\n        initial_params['r'], initial_params['p'], initial_params['V'],\n        initial_params['eta'], initial_params['p_eta']\n    )\n    \n    # Calculate initial extended energy H0\n    H0 = calculate_H_ext(p, V, p_eta, m, W, P_ext)\n    \n    H_history = []\n    \n    for _ in range(steps):\n        # --- B-step: kick for dt/2 ---\n        # p_eta evolves due to pressure mismatch\n        force_eta = (p**2 / m) - V * P_ext\n        p_eta += (dt / 2.0) * force_eta\n        \n        # --- A-step: drift for dt ---\n        p_at_start_of_A = p\n        \n        # Strain rate is constant during this sub-step\n        p_eta_dot = p_eta / W\n        alpha = dt * p_eta_dot\n        \n        exp_alpha = np.exp(alpha)\n        \n        # Update p, V, eta\n        p *= np.exp(-alpha)\n        V *= exp_alpha\n        eta += alpha\n        \n        # Update r, handling the limit case where p_eta_dot is zero\n        if abs(p_eta_dot) > 1e-12: # Numerical tolerance for non-zero check\n            r = exp_alpha * r + (p_at_start_of_A / m) * np.sinh(alpha) / p_eta_dot\n        else: # Case where p_eta_dot is effectively zero\n            # The update rule simplifies in this limit\n            r = exp_alpha * r + (p_at_start_of_A / m) * dt\n            \n        # --- B-step: kick for dt/2 ---\n        force_eta = (p**2 / m) - V * P_ext\n        p_eta += (dt / 2.0) * force_eta\n        \n        # --- Measurement at the end of the full step ---\n        H_current = calculate_H_ext(p, V, p_eta, m, W, P_ext)\n        H_history.append(H_current)\n        \n    # Calculate the time-average of the extended energy\n    H_bar = np.mean(H_history)\n    \n    # Calculate the shadow correction proxy R\n    R = (H_bar - H0) / dt**2\n    \n    return R\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "NPT 模拟的最终目的是正确地对等温等压系综进行抽样，其中一个关键的检验标准是，系统内压的时间平均值 $\\langle P \\rangle$ 必须等于目标外压 $p_{\\text{ext}}$。本练习将教授一项基本技能：如何通过分析瞬时压力的时间序列数据来验证模拟结果。由于时间序列中的数据点是相互关联的，您将学习使用积分自相关时间等统计工具，来正确估计平均值的不确定性，并对模拟的物理正确性进行严格的统计检验 。",
            "id": "3823703",
            "problem": "您的任务是设计并实现一个统计验证程序，该程序能够区分瞬时机械压力 $P_{\\mathrm{int}}$ 与热力学系综平均压力 $\\langle P \\rangle$，并使用此程序测试由 Martyna-Tobias-Klein (MTK) 恒压器控制的模拟在平衡时是否再现了等式 $\\langle P \\rangle = p_{\\text{ext}}$。Martyna-Tobias-Klein (MTK) 方法是一种用于采样等温等压系综的确定性扩展哈密顿方法，其目标是利用压力样本的时间序列，验证机械测量的压力系综平均值是否等于外部施加的压力 $p_{\\text{ext}}$。\n\n出发点和基本依据：\n- 使用牛顿第二定律 $m_i \\,\\mathrm{d}^2 \\mathbf{r}_i/\\mathrm{d}t^2 = \\mathbf{f}_i$ 和在体积为 $V$ 的周期性盒子中机械压力的瞬时维里定义，其中瞬时压力 $P_{\\mathrm{int}}(t)$ 结合了动能项和维里项，并依赖于时间 $t$ 的微观状态。\n- 使用遍历假设将时间平均值与系综平均值联系起来，并利用一个事实：当恒压器正确地对该系综进行采样时，在外部压力为 $p_{\\mathrm{ext}}$ 的等温等压系综在平衡时具有一个与 $\\langle P \\rangle = p_{\\mathrm{ext}}$ 一致的不变测度。\n\n设计一个验证程序，该程序能够：\n1. 给定一个从单个长轨迹中以均匀时间间隔采样的有限时间序列 $\\{P_{\\mathrm{int}}(t_k)\\}_{k=1}^{N}$，使用时间平均法构造一个 $\\langle P \\rangle$ 的估计量。\n2. 通过积分自相关时间来考虑时间相关性，从而量化估计量中的统计不确定性，并为平均压力生成一个置信区间。\n3. 在指定的置信水平下，输出一个布尔决策，判断观测到的平均压力是否与 $p_{\\mathrm{ext}}$ 在统计上一致。\n\n实现要求：\n- 验证必须使用相关可观测量的中心极限定理 (CLT) 和积分自相关时间的估计来执行。定义去均值序列的归一化自相关函数 $\\rho(\\tau)$ 和积分自相关时间为一个有限和 $\\tau_{\\mathrm{int}} = \\frac{1}{2} + \\sum_{\\tau=1}^{W} \\rho(\\tau)$，其中 $W$ 是一个基于 $\\rho(\\tau)$ 的初始正值序列选择的窗口。\n- 平均值的标准误差必须通过有效样本大小来包含时间相关性。使用水平为 $1-\\alpha$ 的双边置信区间和一个正态分位数，其中 $\\alpha = 0.05$，对应的分位数为 $z_{1-\\alpha/2}$。\n- 假设压力以帕斯卡为单位测量，外部压力 $p_{\\mathrm{ext}}$ 也以帕斯卡为单位提供。所有报告和解释的量都必须是帕斯卡。\n\n用于测试的合成数据模型：\n- 为了使测试自洽且可复现，而无需运行实际的分子动力学模拟，使用一阶平稳自回归过程 (Autoregressive (AR))，记为 AR(1)，生成模拟相关波动的合成压力时间序列：\n$$\nX_t = \\mu + \\phi \\left(X_{t-1} - \\mu\\right) + \\eta_t,\n$$\n其中 $\\mu$ 是均值（相对于 $p_{\\mathrm{ext}}$ 设置），$\\phi \\in (-1,1)$ 控制相关性，$\\eta_t$ 是独立的、均值为零的高斯新息，其方差的选择使得 $X_t$ 的平稳标准差为一个指定值。该过程近似于在恒温器和恒压器耦合下 $P_{\\mathrm{int}}(t)$ 的相关性。\n\n验证决策规则：\n- 计算样本均值 $\\bar{P}$，估计 $\\tau_{\\mathrm{int}}$，计算标准误差 $\\sigma_{\\bar{P}}$，并检查是否满足 $|\\bar{P} - p_{\\mathrm{ext}}| \\le z_{1-\\alpha/2} \\,\\sigma_{\\bar{P}}$。如果不等式成立，返回 $True$，否则返回 $False$。使用 $\\alpha = 0.05$，并以小数形式报告 95% 置信水平的决策（不使用百分号）。\n\n角度单位不适用于此任务。物理单位是帕斯卡；所有压力均以帕斯卡报告和解释。\n\n测试套件：\n在以下合成测试案例上实现上述程序，每个案例由元组 $(N, p_{\\mathrm{ext}}, \\text{stationary\\_std}, \\phi, \\text{bias}, \\text{seed})$ 定义，其中 $N$ 是时间序列的长度，$p_{\\mathrm{ext}}$ 是外部压力（帕斯卡），$\\text{stationary\\_std}$ 是目标平稳标准差（帕斯卡），$\\phi$ 是 AR(1) 系数，$\\text{bias}$ 是应用于 $\\mu$ 相对于 $p_{\\mathrm{ext}}$ 的加性偏移，$\\text{seed}$ 是一个整数随机种子：\n- 案例 1：$(N = 20000, p_{\\mathrm{ext}} = 100000, \\text{stationary\\_std} = 50000, \\phi = 0.95, \\text{bias} = 0, \\text{seed} = 42)$；一个典型的相关序列，具有中等波动和正确的均值。\n- 案例 2：$(N = 20000, p_{\\mathrm{ext}} = 100000, \\text{stationary\\_std} = 50000, \\phi = 0.95, \\text{bias} = 20000, \\text{seed} = 43)$；相同的相关性和噪声，但均值有偏差。\n- 案例 3：$(N = 2000, p_{\\mathrm{ext}} = 100000, \\text{stationary\\_std} = 100000, \\phi = 0.99, \\text{bias} = 0, \\text{seed} = 44)$；强相关性和小样本。\n- 案例 4：$(N = 50, p_{\\mathrm{ext}} = 100000, \\text{stationary\\_std} = 50000, \\phi = 0.90, \\text{bias} = 0, \\text{seed} = 45)$；非常小的样本量。\n- 案例 5：$(N = 1000, p_{\\mathrm{ext}} = 100000, \\text{stationary\\_std} = 0, \\phi = 0.50, \\text{bias} = 0, \\text{seed} = 46)$；零波动的恒定信号。\n- 案例 6：$(N = 40000, p_{\\mathrm{ext}} = 100000, \\text{stationary\\_std} = 100000, \\phi = 0.80, \\text{bias} = 6000, \\text{seed} = 47)$；较弱的相关性，较大的样本，以及一个微小但可能可检测的偏差。\n\n您的程序必须：\n- 使用 AR(1) 模型为每个案例生成合成时间序列，并通过选择新息方差来强制实现平稳标准差。\n- 对每个案例应用验证程序以产生布尔决策。\n- 输出一行包含结果的字符串，形式为逗号分隔并用方括号括起来的列表，例如：\"[True,False,True,True,True,False]\"。不允许有多余的空格或文本。\n\n所有物理量均以帕斯卡表示。测试案例的最终布尔输出是无单位的。",
            "solution": "这个问题的核心是设计并实现一个统计假设检验，以验证模拟是否正确地对目标热力学系综进行了采样。具体来说，对于由像 Martyna-Tobias-Klein (MTK) 方法这样的恒压器控制的等温等压 (NPT) 系综模拟，一个基本要求是在平衡状态下，瞬时机械压力的系综平均值 $\\langle P \\rangle$ 必须等于外部施加的压力 $p_{\\mathrm{ext}}$。\n\n**1. 理论基础：从时间序列到系综平均**\n\n瞬时机械压力 $P_{\\mathrm{int}}(t)$ 是时间 $t$ 时微观状态（粒子位置 $\\mathbf{r}_i$ 和动量 $\\mathbf{p}_i$）的函数。它围绕其平衡平均值快速波动。遍历假设断言，对于一个处于平衡状态的系统，沿着足够长的轨迹对某个可观测量的 时间平均值等于其系综平均值。因此，我们可以使用压力测量时间序列 $\\{P_k = P_{\\mathrm{int}}(t_k)\\}_{k=1}^{N}$ 的样本均值来估计 $\\langle P \\rangle$：\n$$\n\\bar{P} = \\frac{1}{N} \\sum_{k=1}^{N} P_k\n$$\n这个 $\\bar{P}$ 是我们对 $\\langle P \\rangle$ 的估计量。我们的目标是检验原假设 $H_0: \\langle P \\rangle = p_{\\mathrm{ext}}$。\n\n**2. 考虑时间相关性**\n\n分子模拟产生的时间序列的一个关键特征是连续样本在统计上不是独立的。系统的状态是连续演化的，因此 $P_k$ 与 $P_{k-1}$ 密切相关。如果天真地应用针对独立样本的中心极限定理 (CLT)——该定理给出平均值的标准误差为 $\\sigma_{\\bar{P}} = \\sigma_P / \\sqrt{N}$（其中 $\\sigma_P^2$ 是 $P$ 的方差）——将会严重低估 $\\bar{P}$ 的真实统计不确定性。\n\n为了纠正这一点，我们必须量化相关性。归一化自相关函数 (ACF) $\\rho(\\tau)$ 测量由时间延迟 $\\tau$ 分隔的样本之间的相关性：\n$$\n\\rho(\\tau) = \\frac{\\langle (P(t) - \\langle P \\rangle)(P(t+\\tau) - \\langle P \\rangle) \\rangle}{\\langle (P(t) - \\langle P \\rangle)^2 \\rangle}\n$$\n$\\rho(\\tau)$ 衰减到零的速率表明系统“忘记”其过去状态的速度有多快。总相关性由积分自相关时间 $\\tau_{\\mathrm{int}}$ 捕获：\n$$\n\\tau_{\\mathrm{int}} = \\int_0^\\infty \\rho(\\tau) \\, \\mathrm{d}\\tau\n$$\n对于离散时间序列，这可估计为：\n$$\n\\tau_{\\mathrm{int}} \\approx \\frac{1}{2} + \\sum_{\\tau=1}^{W} \\rho(\\tau)\n$$\n这里，项 $\\frac{1}{2}$ 解释了连续积分中 $\\tau=0$ 的贡献，而 $W$ 是一个有限的截断窗口。问题指定选择 $W$ 为估计的 ACF 出现第一个负值之前的延迟，这是一种常用的启发式方法，用于从 ACF 的长延迟尾部排除噪声。\n\n相关性的影响是减少了真正独立的样本数量。有效样本量 $N_{\\mathrm{eff}}$ 由下式给出：\n$$\nN_{\\mathrm{eff}} = \\frac{N}{2 \\tau_{\\mathrm{int}}}\n$$\nCLT 可以扩展到相关序列，指出均值的方差为：\n$$\n\\mathrm{Var}(\\bar{P}) = \\frac{\\mathrm{Var}(P)}{N_{\\mathrm{eff}}} = \\frac{2 \\tau_{\\mathrm{int}} \\mathrm{Var}(P)}{N}\n$$\n平均值的标准误差 $\\sigma_{\\bar{P}}$ 是该方差的平方根。在实践中，我们使用样本方差 $s_P^2$ 作为 $\\mathrm{Var}(P)$ 的估计量：\n$$\n\\sigma_{\\bar{P}} = \\sqrt{\\frac{2 \\tau_{\\mathrm{int}} s_P^2}{N}}\n$$\n\n**3. 验证决策规则**\n\n有了均值的有效估计量 $\\bar{P}$ 及其标准误差 $\\sigma_{\\bar{P}}$，我们就可以构建一个置信区间。对于选定的显著性水平 $\\alpha$（这里是 $\\alpha=0.05$），真实均值 $\\langle P \\rangle$ 的 $(1-\\alpha)$ 置信区间近似为 $[\\bar{P} - z_{1-\\alpha/2}\\sigma_{\\bar{P}}, \\bar{P} + z_{1-\\alpha/2}\\sigma_{\\bar{P}}]$。这里，$z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$ 分位数。对于 $\\alpha=0.05$，$z_{0.975} \\approx 1.95996$。\n\n我们通过检验目标外部压力 $p_{\\mathrm{ext}}$ 是否落在此置信区间内来检查统计一致性。这等价于条件：\n$$\n|\\bar{P} - p_{\\mathrm{ext}}| \\le z_{1-\\alpha/2} \\sigma_{\\bar{P}}\n$$\n如果这个不等式成立，我们得出结论，观测到的平均压力与外部压力在统计上是一致的，模拟的行为符合预期。程序返回 `True`。否则，它返回 `False`，表明模拟可能存在问题（例如，不正确的实现、平衡不充分或真实的物理偏差）。\n\n**4. 通过 AR(1) 过程生成合成数据**\n\n为了在不运行完整模拟的情况下测试此验证程序，我们使用一阶平穩自回归过程 AR(1) 生成合成数据。该模型抓住了相关波动的本质：\n$$\nX_t = \\mu + \\phi (X_{t-1} - \\mu) + \\eta_t\n$$\n这里，$X_t$ 代表压力 $P_{\\mathrm{int}}(t_k)$，$\\mu$ 是过程的真实均值，$\\phi \\in (-1, 1)$ 是相关系数，$\\eta_t$ 是一系列独立同分布的高斯随机变量（新息），均值为 0，方差为 $\\sigma_\\eta^2$。\n\nAR(1) 过程的平稳方差 $\\mathrm{Var}(X)$ 与新息方差的关系为 $\\mathrm{Var}(X) = \\sigma_\\eta^2 / (1-\\phi^2)$。问题提供了期望的平稳标准差 $\\sigma_X = \\text{stationary\\_std}$。因此，我们可以确定生成序列所需的新息方差：\n$$\n\\sigma_\\eta^2 = \\sigma_X^2 (1 - \\phi^2)\n$$\n过程的均值设置为 $\\mu = p_{\\mathrm{ext}} + \\text{bias}$，以模拟正确或有偏差的恒压器行为。\n\n**5. 算法实现摘要**\n\n对于每个测试案例 $(N, p_{\\mathrm{ext}}, \\text{stationary\\_std}, \\phi, \\text{bias}, \\text{seed})$：\n1.  **设置参数**：计算均值 $\\mu = p_{\\mathrm{ext}} + \\text{bias}$ 和新息方差 $\\sigma_\\eta^2 = (\\text{stationary\\_std})^2(1-\\phi^2)$。\n2.  **生成序列**：使用给定的 `seed` 初始化随机数生成器。使用 AR(1) 递归生成长度为 $N$ 的时间序列。作为特殊情况，如果 $\\text{stationary\\_std}=0$，则生成一个等于 $\\mu$ 的恒定序列。\n3.  **处理零方差情况**：如果 $\\text{stationary\\_std}=0$，测试简化为检查 $\\bar{P}$ 是否等于 $p_{\\mathrm{ext}}$，这当且仅当 `bias` 为 0 时成立。\n4.  **计算统计量**：对于一般情况，计算生成序列的样本均值 $\\bar{P}$ 和样本方差 $s_P^2$（自由度为 $N-1$）。\n5.  **计算 ACF**：估计延迟 $\\tau=0, 1, \\dots, N-1$ 的归一化自相关函数 $\\rho(\\tau)$。一种有效的方法是使用快速傅里叶变换 (FFT)。\n6.  **计算自相关时间**：通过找到第一个延迟 $\\tau \\ge 1$ 使得 $\\rho(\\tau)  0$ 来确定求和窗口 $W$。然后计算 $\\tau_{\\mathrm{int}} = \\frac{1}{2} + \\sum_{\\tau=1}^{W} \\rho(\\tau)$。如果 $\\rho(1)  0$，则和为空，$\\tau_{\\mathrm{int}}=0.5$。\n7.  **计算标准误差**：使用 $\\sigma_{\\bar{P}} = \\sqrt{s_P^2 \\cdot 2\\tau_{\\mathrm{int}} / N}$ 计算平均值的标准误差。\n8.  **决策**：获取正态分位数 $z_{0.975}$（对于 95% 置信水平）。如果 $|\\bar{P} - p_{\\mathrm{ext}}| \\le z_{0.975} \\sigma_{\\bar{P}}$，则返回 `True`，否则返回 `False`。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef perform_validation(params):\n    \"\"\"\n    Performs statistical validation for a single synthetic pressure time series.\n\n    Args:\n        params (tuple): A tuple containing the parameters for the test case:\n                        (N, p_ext, stationary_std, phi, bias, seed).\n\n    Returns:\n        bool: True if the mean pressure is consistent with p_ext, False otherwise.\n    \"\"\"\n    N, p_ext, stationary_std, phi, bias, seed = params\n    \n    # 1. Set up the AR(1) process parameters\n    mu = p_ext + bias\n    \n    # 2. Generate the synthetic time series\n    np.random.seed(seed)\n    \n    # Handle the special case of zero fluctuations\n    if np.isclose(stationary_std, 0.0):\n        # The series is constant. The test is deterministic.\n        P_int = np.full(N, mu)\n        P_bar = np.mean(P_int)\n        # Check if the constant value equals the target external pressure.\n        return np.isclose(P_bar, p_ext)\n\n    # Calculate innovation variance from target stationary variance\n    # Var(X) = Var(eta) / (1 - phi^2) => Var(eta) = Var(X) * (1 - phi^2)\n    var_eta = (stationary_std**2) * (1 - phi**2)\n    std_eta = np.sqrt(var_eta)\n\n    # Generate innovations from a normal distribution\n    eta = np.random.normal(loc=0.0, scale=std_eta, size=N)\n    \n    # Generate the AR(1) series\n    P_int = np.zeros(N)\n    P_int[0] = mu  # Start the process at its stationary mean\n    for t in range(1, N):\n        P_int[t] = mu + phi * (P_int[t-1] - mu) + eta[t]\n\n    # 4. Calculate sample statistics\n    P_bar = np.mean(P_int)\n    # Use ddof=1 for the sample variance, an unbiased estimator of population variance\n    P_var = np.var(P_int, ddof=1)\n    \n    # 5. Compute the normalized autocorrelation function (ACF) using FFT\n    x_demeaned = P_int - P_bar\n    # Use 2*N for padding to avoid circular correlation issues\n    f = np.fft.fft(x_demeaned, n=2 * N)\n    acf_unnormalized = np.fft.ifft(f * np.conj(f))\n    acf = np.real(acf_unnormalized[:N])\n    acf /= acf[0] # Normalize by variance (acf[0] = sum(x_demeaned**2))\n\n    # 6. Compute the integrated autocorrelation time (tau_int)\n    # Find window W: sum while ACF is positive\n    W = 0\n    for tau in range(1, N):\n        if acf[tau]  0:\n            break\n        W = tau\n    \n    # Sum the ACF over the window [1, W]\n    tau_int_sum = np.sum(acf[1 : W + 1])\n    tau_int = 0.5 + tau_int_sum\n    \n    # 7. Compute the standard error of the mean for correlated data\n    # Var(mean) = Var(P) * 2 * tau_int / N\n    if N = 1:\n        std_err_mean = np.inf\n    else:\n        std_err_mean = np.sqrt(P_var * 2 * tau_int / N)\n\n    # 8. Apply the validation decision rule\n    alpha = 0.05\n    # Two-sided test, so we use alpha/2\n    z_quantile = norm.ppf(1 - alpha / 2)\n    \n    # Check if p_ext is within the 95% confidence interval of the mean\n    if std_err_mean == 0.0: # Can happen if P_var is 0, though handled before\n        is_consistent = np.isclose(P_bar, p_ext)\n    else:\n        is_consistent = np.abs(P_bar - p_ext) = z_quantile * std_err_mean\n        \n    return bool(is_consistent)\n\ndef solve():\n    \"\"\"\n    Main function to run the validation on all specified test cases.\n    \"\"\"\n    # Test cases defined in the problem statement:\n    # (N, p_ext, stationary_std, phi, bias, seed)\n    test_cases = [\n        (20000, 100000, 50000, 0.95, 0, 42),\n        (20000, 100000, 50000, 0.95, 20000, 43),\n        (2000, 100000, 100000, 0.99, 0, 44),\n        (50, 100000, 50000, 0.90, 0, 45),\n        (1000, 100000, 0, 0.50, 0, 46),\n        (40000, 100000, 100000, 0.80, 6000, 47),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = perform_validation(case)\n        results.append(result)\n\n    # Output the results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}