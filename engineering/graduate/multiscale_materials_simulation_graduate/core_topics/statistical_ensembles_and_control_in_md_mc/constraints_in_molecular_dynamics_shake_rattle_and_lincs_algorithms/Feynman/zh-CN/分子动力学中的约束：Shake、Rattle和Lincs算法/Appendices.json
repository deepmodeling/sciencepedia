{
    "hands_on_practices": [
        {
            "introduction": "所有约束算法的核心都是一个被称为“约束耦合矩阵”的数学对象，它通过原子质量将不同约束关联起来。本练习将引导您从第一性原理出发，为键长约束推导并构建该矩阵。掌握其构建方法是理解约束力如何在分子内部传递，以及各种约束算法如何工作的关键第一步。",
            "id": "3798260",
            "problem": "考虑一个包含 $N$ 个原子的经典分子动力学 (MD) 系统，该系统具有在选定原子对之间的固定键长的完整约束。这些约束通过拉格朗日乘子在 SHAKE 和 RATTLE 等位置和速度投影方案中得以强制施加。设约束集由函数 $c_{k}(\\mathbf{q})=0$ 定义，其中 $\\mathbf{q}\\in\\mathbb{R}^{3N}$ 将所有笛卡尔坐标堆叠为 $\\mathbf{q}=\\left(x_{1},y_{1},z_{1},\\dots,x_{N},y_{N},z_{N}\\right)$，每个键长约束的形式为 $c_{ij}(\\mathbf{q})=\\|\\mathbf{r}_{j}-\\mathbf{r}_{i}\\|^{2}-d_{ij}^{2}=0$，适用于目标键长为 $d_{ij}$ 的原子 $i$ 和 $j$。定义约束雅可比矩阵 $G(\\mathbf{q})$，其行为 $G_{k}(\\mathbf{q})=\\nabla_{\\mathbf{q}}c_{k}(\\mathbf{q})$，并令对角质量矩阵为 $M=\\mathrm{diag}(m_{1},m_{1},m_{1},\\dots,m_{N},m_{N},m_{N})$。线性约束求解器 (LINCS) 算法及相关的投影方法通过对称正定矩阵 $A(\\mathbf{q})=G(\\mathbf{q})M^{-1}G(\\mathbf{q})^{\\top}$ 求解拉格朗日乘子。\n\n从牛顿第二定律和完整约束的定义出发，仅使用基本定律和核心定义推导键长约束的 $G(\\mathbf{q})$。解释如何利用键约束的局域性高效地以稀疏形式构建 $A(\\mathbf{q})$，且不使用任何预先推导的实现“捷径”。\n\n然后，考虑一个由 $N=3$ 个原子和两个键长约束组成的特定三原子构型：\n- 原子 $1$ 位于 $\\mathbf{r}_{1}=(0,0,0)$，\n- 原子 $2$ 位于 $\\mathbf{r}_{2}=(a,0,0)$，\n- 原子 $3$ 位于 $\\mathbf{r}_{3}=(a,b,0)$，\n原子 $1$ 和 $2$ 之间的目标键长为 $d_{12}=a$，原子 $2$ 和 $3$ 之间的目标键长为 $d_{23}=b$。设坐标顺序为 $\\mathbf{q}=(x_{1},y_{1},z_{1},x_{2},y_{2},z_{2},x_{3},y_{3},z_{3})$，并选择质量 $m_{1}=12$，$m_{2}=1$，$m_{3}=16$。取 $a=1$ 和 $b=1$。\n\n为这两个约束显式地构建 $G(\\mathbf{q})$，构建 $A(\\mathbf{q})=G(\\mathbf{q})M^{-1}G(\\mathbf{q})^{\\top}$，并计算行列式 $\\det A(\\mathbf{q})$。将行列式的数值以 $\\mathrm{nm}^{4}/\\mathrm{amu}^{2}$ 为单位表示。无需四舍五入；提供精确值。",
            "solution": "基本依据是牛顿第二定律，在笛卡尔坐标系中，其形式为 $m_{i}\\ddot{\\mathbf{r}}_{i}=\\mathbf{F}_{i}+\\mathbf{f}_{i}^{\\mathrm{c}}$，其中 $\\mathbf{f}_{i}^{\\mathrm{c}}$ 是约束力，确保完整约束 $c_{k}(\\mathbf{q})=0$ 保持满足。对于完整约束，约束力是约束梯度的线性组合：$\\mathbf{f}^{\\mathrm{c}}=G(\\mathbf{q})^{\\top}\\boldsymbol{\\lambda}$，其中 $\\boldsymbol{\\lambda}$ 是拉格朗日乘子向量，$G(\\mathbf{q})$ 是雅可比矩阵，其行为 $G_{k}(\\mathbf{q})=\\nabla_{\\mathbf{q}}c_{k}(\\mathbf{q})$。\n\n对于原子 $i$ 和 $j$ 之间的键长约束，定义 $c_{ij}(\\mathbf{q})=\\|\\mathbf{r}_{j}-\\mathbf{r}_{i}\\|^{2}-d_{ij}^{2}$。我们通过链式法则计算梯度。设 $\\mathbf{r}_{i}=(x_{i},y_{i},z_{i})$ 和 $\\mathbf{r}_{j}=(x_{j},y_{j},z_{j})$。则\n$$\nc_{ij}(\\mathbf{q})=(x_{j}-x_{i})^{2}+(y_{j}-y_{i})^{2}+(z_{j}-z_{i})^{2}-d_{ij}^{2}.\n$$\n其偏导数为\n$$\n\\frac{\\partial c_{ij}}{\\partial \\mathbf{r}_{i}}=2(\\mathbf{r}_{i}-\\mathbf{r}_{j}),\\quad \\frac{\\partial c_{ij}}{\\partial \\mathbf{r}_{j}}=2(\\mathbf{r}_{j}-\\mathbf{r}_{i}),\n$$\n并且相对于所有其他原子的坐标为零。因此，行向量 $G_{ij}(\\mathbf{q})=\\nabla_{\\mathbf{q}}c_{ij}(\\mathbf{q})$ 是一个 $1\\times 3N$ 的向量，其 3 分量块为\n$$\n[G_{ij}]_{i}=2(\\mathbf{r}_{i}-\\mathbf{r}_{j}),\\quad [G_{ij}]_{j}=2(\\mathbf{r}_{j}-\\mathbf{r}_{i}),\n$$\n其他位置为零。\n\n为了获得在 SHAKE、RATTLE 和线性约束求解器 (LINCS) 中使用的关于 $\\boldsymbol{\\lambda}$ 的线性系统，我们考虑约束违背的质量加权投影。在一个小的位置校正 $\\delta\\mathbf{q}$ 或速度校正 $\\delta\\dot{\\mathbf{q}}$ 下，约束线性化为 $G(\\mathbf{q})\\,\\delta\\mathbf{q}=\\mathbf{r}$ 或 $G(\\mathbf{q})\\,\\delta\\dot{\\mathbf{q}}=\\mathbf{r}_{v}$，残差为 $\\mathbf{r}$ 或 $\\mathbf{r}_{v}$。由约束力驱动的质量加权校正满足 $M\\,\\delta\\ddot{\\mathbf{q}}=G(\\mathbf{q})^{\\top}\\boldsymbol{\\lambda}$，(在线性化投影中消去 $\\delta\\mathbf{q}$ 或 $\\delta\\dot{\\mathbf{q}}$ 后) 得到对称正定的“约束耦合”矩阵\n$$\nA(\\mathbf{q})=G(\\mathbf{q})M^{-1}G(\\mathbf{q})^{\\top},\n$$\n其 $(k,\\ell)$ 元仅汇集了同时出现在约束 $k$ 和 $\\ell$ 中的原子的贡献：\n$$\nA_{k\\ell}=\\sum_{p=1}^{N}\\frac{1}{m_{p}}\\,[G_{k}]_{p}^{\\top}[G_{\\ell}]_{p}.\n$$\n\n$A(\\mathbf{q})$ 的高效稀疏构建利用了键约束的局域性：每个约束 $c_{ij}$ 只涉及原子 $i$ 和 $j$，因此 $G_{ij}$ 恰好有两个非零的 3 分量块，并且 $A_{k\\ell}$ 仅在约束 $k$ 和 $\\ell$ 共享至少一个原子时才为非零。一个实用的构建策略是：\n1. 对每个约束 $c_{ij}$，预先计算梯度 $[G_{ij}]_{i}=2(\\mathbf{r}_{i}-\\mathbf{r}_{j})$ 和 $[G_{ij}]_{j}=2(\\mathbf{r}_{j}-\\mathbf{r}_{i})$。\n2. 建立从约束到原子以及从原子到相关约束的邻接映射。\n3. 对于每个涉及原子 $i$ 和 $j$ 的约束 $k$，累加对角线贡献\n$$\nA_{kk}\\,\\mathrel{+}=\\,\\frac{[G_{k}]_{i}^{\\top}[G_{k}]_{i}}{m_{i}}+\\frac{[G_{k}]_{j}^{\\top}[G_{k}]_{j}}{m_{j}}.\n$$\n4. 对于约束 $k$ 和 $\\ell$ 共享的每个原子 $p$ (来自原子到约束的邻接关系)，累加非对角线贡献\n$$\nA_{k\\ell}\\,\\mathrel{+}=\\,\\frac{[G_{k}]_{p}^{\\top}[G_{\\ell}]_{p}}{m_{p}},\n$$\n并对称地设置 $A_{\\ell k}=A_{k\\ell}$。\n5. 将 $A$ 存储为压缩稀疏行或压缩稀疏列结构；每个约束的工作量是恒定的 (在三维空间中，每个约束涉及两个原子，最多六个坐标)，从而使得构建时间与约束数量成线性关系，内存与约束图带宽成线性关系。\n\n现在将此应用于 $a=1$ 和 $b=1$ 的指定三原子构型。坐标为\n$$\n\\mathbf{r}_{1}=(0,0,0),\\quad \\mathbf{r}_{2}=(1,0,0),\\quad \\mathbf{r}_{3}=(1,1,0),\n$$\n约束为 $c_{12}$ 和 $c_{23}$，目标长度为 $d_{12}=1$ 和 $d_{23}=1$。使用顺序 $\\mathbf{q}=(x_{1},y_{1},z_{1},x_{2},y_{2},z_{2},x_{3},y_{3},z_{3})$，我们计算约束梯度。\n\n对于 $c_{12}$，\n$$\n[G_{12}]_{1}=2(\\mathbf{r}_{1}-\\mathbf{r}_{2})=2(-1,0,0)=(-2,0,0),\\quad [G_{12}]_{2}=2(\\mathbf{r}_{2}-\\mathbf{r}_{1})=2(1,0,0)=(2,0,0),\n$$\n在原子 3 处为零。因此行向量 $G_{12}$ 为\n$$\nG_{12}=\\big(-2,\\,0,\\,0,\\,2,\\,0,\\,0,\\,0,\\,0,\\,0\\big).\n$$\n对于 $c_{23}$，\n$$\n[G_{23}]_{2}=2(\\mathbf{r}_{2}-\\mathbf{r}_{3})=2(0,-1,0)=(0,-2,0),\\quad [G_{23}]_{3}=2(\\mathbf{r}_{3}-\\mathbf{r}_{2})=2(0,1,0)=(0,2,0),\n$$\n在原子 1 处为零。因此行向量 $G_{23}$ 为\n$$\nG_{23}=\\big(0,\\,0,\\,0,\\,0,\\,-2,\\,0,\\,0,\\,2,\\,0\\big).\n$$\n\n质量矩阵的逆是 $M^{-1}=\\mathrm{diag}\\big(\\frac{1}{12},\\frac{1}{12},\\frac{1}{12},1,1,1,\\frac{1}{16},\\frac{1}{16},\\frac{1}{16}\\big)$，由 $m_{1}=12, m_{2}=1, m_{3}=16$ 得出。\n\n我们现在计算 $A=G M^{-1} G^{\\top}$。因为我们有两个约束，$A$ 是一个 $2\\times 2$ 矩阵，其元素为\n$$\nA_{11}=G_{12}M^{-1}G_{12}^{\\top},\\quad A_{22}=G_{23}M^{-1}G_{23}^{\\top},\\quad A_{12}=G_{12}M^{-1}G_{23}^{\\top}.\n$$\n对于 $A_{11}$，只有 $(x_1, x_2)$ 处的坐标有贡献：\n$$\nA_{11}=(-2)^{2}\\cdot\\frac{1}{12}+(2)^{2}\\cdot 1=\\frac{4}{12}+4=\\frac{1}{3}+4=\\frac{13}{3}.\n$$\n对于 $A_{22}$，只有 $(y_2, y_3)$ 处的坐标有贡献：\n$$\nA_{22}=(-2)^{2}\\cdot 1+(2)^{2}\\cdot\\frac{1}{16}=4+\\frac{4}{16}=4+\\frac{1}{4}=\\frac{17}{4}.\n$$\n对于 $A_{12}$，共享的原子 2 的梯度分量是正交的，因此点积为零：\n$$\nA_{12}=\\frac{1}{m_2}[G_{12}]_2^{\\top}[G_{23}]_2 = \\frac{1}{1}(2,0,0) \\cdot (0,-2,0) = 0.\n$$\n因此，\n$$\nA=\\begin{pmatrix}\\frac{13}{3}  0 \\\\ 0  \\frac{17}{4}\\end{pmatrix}.\n$$\n行列式为\n$$\n\\det A=\\frac{13}{3}\\cdot\\frac{17}{4}=\\frac{221}{12}.\n$$\n将位置解释为纳米，质量解释为原子质量单位，则 $\\det A$ 的单位为 $\\mathrm{nm}^{4}/\\mathrm{amu}^{2}$；精确值为 $\\frac{221}{12}$，无需四舍五入。",
            "answer": "$$\\boxed{\\frac{221}{12}}$$"
        },
        {
            "introduction": "约束算法若要能求出唯一的拉格朗日乘子，一个关键前提是所有约束必须是线性无关的。本练习通过一个简化的例子，探讨当这个条件被违反时（例如，添加了一个冗余约束），系统在数学上会发生什么。通过分析系统矩阵的秩，您将具体地理解为什么冗余约束会导致矩阵奇异，从而使得约束方程无法求得唯一解。",
            "id": "3798275",
            "problem": "考虑一个一维三原子系统，该系统用于阐释分子动力学中通过 SHAKE (Systematic Hunting Algorithm for Constraints on Equilibrium)、RATTLE (Reversible, Integrator, Constraints, and Time-step, Leapfrog) 算法以及线性约束求解器 (LINCS) 进行约束强制的方法。广义坐标为 $q = (x_{1}, x_{2}, x_{3})$，对角质量矩阵为 $M = \\mathrm{diag}(m_{1}, m_{2}, m_{3})$，其中 $m_{1} = 1$, $m_{2} = 2$, $m_{3} = 3$，单位为一致的质量单位。完整约束是位置层级的函数 $\\phi_{k}(q) = 0$。\n\n从牛顿第二定律和由拉格朗日乘子强制的完整约束的定义出发，推导在 SHAKE/RATTLE/LINCS 约束投影中出现的拉格朗日乘子 $\\lambda$ 的线性系统。其中，约束力为 $Q_{c} = J(q)^{\\top}\\lambda$，$J(q)$ 是雅可比矩阵（约束梯度），其元素为 $J_{ka} = \\partial \\phi_{k}/\\partial q_{a}$。然后，对于以下约束：\n- $\\phi_{1}(q) = x_{1} - x_{2}$，\n- $\\phi_{2}(q) = x_{2} - x_{3}$，\n计算由质量矩阵和约束雅可比矩阵构建的相关乘子系统矩阵，并确定其秩。接下来，添加第三个约束，该约束是前两个约束的线性组合：\n- $\\phi_{3}(q) = \\phi_{1}(q) + \\phi_{2}(q) = x_{1} - x_{3}$，\n重建对应于这三个约束的乘子系统矩阵，并确定其秩。最后，评估添加第三个约束对拉格朗日乘子向量的可解性（存在性和唯一性）的影响。\n\n将最终答案表示为添加第三个约束后乘子系统矩阵的秩（一个整数）。无需四舍五入。",
            "solution": "问题要求在约束分子动力学的背景下，推导拉格朗日乘子的线性系统，然后分析线性相关约束对该系统秩和可解性的影响。\n\n首先，我们推导拉格朗日乘子 $\\boldsymbol{\\lambda}$ 的线性系统。对于一个具有广义坐标 $\\mathbf{q}$、质量矩阵 $M$ 和势能 $U(\\mathbf{q})$，且受完整约束 $\\boldsymbol{\\phi}(\\mathbf{q}) = \\mathbf{0}$ 限制的系统，其拉格朗日运动方程为：\n$$\nM \\ddot{\\mathbf{q}} = -\\nabla U(\\mathbf{q}) + \\mathbf{Q}_c\n$$\n此处，$\\mathbf{F}(\\mathbf{q}) = -\\nabla U(\\mathbf{q})$ 表示无约束力，$\\mathbf{Q}_c$ 是为强制执行 $\\boldsymbol{\\phi}(\\mathbf{q})=\\mathbf{0}$ 所需的约束力。该力被定义为与约束曲面正交，这意味着它可以写成约束梯度的线性组合。问题将此力定义为 $\\mathbf{Q}_c = J(\\mathbf{q})^{\\top}\\boldsymbol{\\lambda}$，其中 $J_{ka} = \\frac{\\partial \\phi_k}{\\partial q_a}$ 是约束的雅可比矩阵，$\\boldsymbol{\\lambda}$ 是拉格朗日乘子向量。因此，运动方程为：\n$$\nM \\ddot{\\mathbf{q}} = \\mathbf{F}(\\mathbf{q}) + J(\\mathbf{q})^{\\top}\\boldsymbol{\\lambda}\n$$\n为使约束在任何时候都得到满足，其二阶时间导数必须为零，即 $\\ddot{\\boldsymbol{\\phi}}(\\mathbf{q}(t)) = \\mathbf{0}$。使用链式法则：\n$$\n\\dot{\\boldsymbol{\\phi}} = \\frac{d\\boldsymbol{\\phi}}{dt} = \\frac{\\partial \\boldsymbol{\\phi}}{\\partial \\mathbf{q}} \\frac{d\\mathbf{q}}{dt} = J \\dot{\\mathbf{q}}\n$$\n$$\n\\ddot{\\boldsymbol{\\phi}} = \\frac{d}{dt}(J \\dot{\\mathbf{q}}) = \\dot{J}\\dot{\\mathbf{q}} + J\\ddot{\\mathbf{q}}\n$$\n令 $\\ddot{\\boldsymbol{\\phi}} = \\mathbf{0}$ 可得条件 $J\\ddot{\\mathbf{q}} = -\\dot{J}\\dot{\\mathbf{q}}$。\n根据运动方程，我们可以写出 $\\ddot{\\mathbf{q}} = M^{-1}(\\mathbf{F}(\\mathbf{q}) + J^{\\top}\\boldsymbol{\\lambda})$。将此式代入约束条件，可得：\n$$\nJ M^{-1} (\\mathbf{F}(\\mathbf{q}) + J^{\\top}\\boldsymbol{\\lambda}) = -\\dot{J}\\dot{\\mathbf{q}}\n$$\n重新整理以构成关于 $\\boldsymbol{\\lambda}$ 的线性系统：\n$$\n(J M^{-1} J^{\\top}) \\boldsymbol{\\lambda} = -J M^{-1} \\mathbf{F}(\\mathbf{q}) - \\dot{J}\\dot{\\mathbf{q}}\n$$\n该方程的形式为 $A\\boldsymbol{\\lambda}=\\mathbf{b}$，其中乘子系统矩阵是 $A = J M^{-1} J^{\\top}$。这个矩阵的性质决定了 $\\boldsymbol{\\lambda}$ 的可解性。在诸如 SHAKE 等迭代算法或 LINCS 等投影方法中，对约束方程进行线性化时，也会出现相同的矩阵。\n\n现在，我们将此理论应用于该特定系统。\n坐标为 $\\mathbf{q} = (x_1, x_2, x_3)^{\\top}$。质量矩阵为 $M = \\mathrm{diag}(1, 2, 3)$，因此逆质量矩阵为 $M^{-1} = \\mathrm{diag}(1, 1/2, 1/3)$。\n\n最初，我们有两个约束：\n- $\\phi_1(\\mathbf{q}) = x_1 - x_2 = 0$\n- $\\phi_2(\\mathbf{q}) = x_2 - x_3 = 0$\n\n雅可比矩阵 $J$ 是一个 $2 \\times 3$ 的矩阵，其行是约束的梯度：\n$$\nJ = \\begin{pmatrix} \\frac{\\partial \\phi_1}{\\partial x_1}  \\frac{\\partial \\phi_1}{\\partial x_2}  \\frac{\\partial \\phi_1}{\\partial x_3} \\\\ \\frac{\\partial \\phi_2}{\\partial x_1}  \\frac{\\partial \\phi_2}{\\partial x_2}  \\frac{\\partial \\phi_2}{\\partial x_3} \\end{pmatrix} = \\begin{pmatrix} 1  -1  0 \\\\ 0  1  -1 \\end{pmatrix}\n$$\n雅可比矩阵的转置是：\n$$\nJ^{\\top} = \\begin{pmatrix} 1  0 \\\\ -1  1 \\\\ 0  -1 \\end{pmatrix}\n$$\n我们计算乘子系统矩阵，记为 $A_2$：\n$$\nA_2 = J M^{-1} J^{\\top} = \\begin{pmatrix} 1  -1  0 \\\\ 0  1  -1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  1/2  0 \\\\ 0  0  1/3 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ -1  1 \\\\ 0  -1 \\end{pmatrix}\n$$\n首先，我们计算 $J M^{-1}$：\n$$\nJ M^{-1} = \\begin{pmatrix} 1  -1/2  0 \\\\ 0  1/2  -1/3 \\end{pmatrix}\n$$\n现在乘以 $J^{\\top}$：\n$$\nA_2 = \\begin{pmatrix} 1  -1/2  0 \\\\ 0  1/2  -1/3 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ -1  1 \\\\ 0  -1 \\end{pmatrix} = \\begin{pmatrix} 1 + 1/2  -1/2 \\\\ -1/2  1/2 + 1/3 \\end{pmatrix} = \\begin{pmatrix} 3/2  -1/2 \\\\ -1/2  5/6 \\end{pmatrix}\n$$\n为了求这个 $2 \\times 2$ 矩阵的秩，我们计算其行列式：\n$$\n\\det(A_2) = \\left(\\frac{3}{2}\\right)\\left(\\frac{5}{6}\\right) - \\left(-\\frac{1}{2}\\right)\\left(-\\frac{1}{2}\\right) = \\frac{15}{12} - \\frac{1}{4} = \\frac{5}{4} - \\frac{1}{4} = 1\n$$\n由于 $\\det(A_2) \\neq 0$，矩阵 $A_2$ 是满秩的，即 $\\mathrm{rank}(A_2) = 2$。这意味着对于任意右端向量，$\\boldsymbol{\\lambda} = (\\lambda_1, \\lambda_2)^{\\top}$ 都存在唯一解。\n\n接下来，我们添加第三个约束 $\\phi_3(\\mathbf{q}) = x_1 - x_3$。这个约束是前两个约束的线性组合：$\\phi_3 = \\phi_1 + \\phi_2$。\n新的约束集是：\n- $\\phi_1(\\mathbf{q}) = x_1 - x_2 = 0$\n- $\\phi_2(\\mathbf{q}) = x_2 - x_3 = 0$\n- $\\phi_3(\\mathbf{q}) = x_1 - x_3 = 0$\n\n新的雅可比矩阵 $J'$ 是一个 $3 \\times 3$ 矩阵：\n$$\nJ' = \\begin{pmatrix} 1  -1  0 \\\\ 0  1  -1 \\\\ 1  0  -1 \\end{pmatrix}\n$$\n$J'$ 的第三行是前两行之和，因此 $J'$ 的行向量是线性相关的，且 $\\mathrm{rank}(J') = 2$。\n我们计算新的 $3 \\times 3$ 乘子系统矩阵 $A_3 = J' M^{-1} (J')^{\\top}$。\n$$\nJ' M^{-1} = \\begin{pmatrix} 1  -1  0 \\\\ 0  1  -1 \\\\ 1  0  -1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  1/2  0 \\\\ 0  0  1/3 \\end{pmatrix} = \\begin{pmatrix} 1  -1/2  0 \\\\ 0  1/2  -1/3 \\\\ 1  0  -1/3 \\end{pmatrix}\n$$\n$$\n(J')^{\\top} = \\begin{pmatrix} 1  0  1 \\\\ -1  1  0 \\\\ 0  -1  -1 \\end{pmatrix}\n$$\n现在，我们计算 $A_3 = (J' M^{-1}) (J')^{\\top}$：\n$$\nA_3 = \\begin{pmatrix} 1  -1/2  0 \\\\ 0  1/2  -1/3 \\\\ 1  0  -1/3 \\end{pmatrix} \\begin{pmatrix} 1  0  1 \\\\ -1  1  0 \\\\ 0  -1  -1 \\end{pmatrix}\n$$\n矩阵的元素为：\n$A_{3,11} = (1)(1) + (-1/2)(-1) = 3/2$\n$A_{3,12} = (-1/2)(1) = -1/2$\n$A_{3,13} = (1)(1) = 1$\n$A_{3,21} = (1/2)(-1) = -1/2$\n$A_{3,22} = (1/2)(1) + (-1/3)(-1) = 1/2 + 1/3 = 5/6$\n$A_{3,23} = (1/2)(0) + (-1/3)(-1) = 1/3$\n$A_{3,31} = (1)(1) = 1$\n$A_{3,32} = (-1/3)(-1) = 1/3$\n$A_{3,33} = (1)(1) + (-1/3)(-1) = 1 + 1/3 = 4/3$\n所以矩阵是：\n$$\nA_3 = \\begin{pmatrix} 3/2  -1/2  1 \\\\ -1/2  5/6  1/3 \\\\ 1  1/3  4/3 \\end{pmatrix}\n$$\n为了确定 $A_3$ 的秩，我们检查其行向量之间的线性相关性。设 $R_1, R_2, R_3$ 为 $A_3$ 的行向量。我们检验 $R_3$ 是否为 $R_1$ 和 $R_2$ 的线性组合。雅可比矩阵中的线性相关性 $\\nabla\\phi_3 = \\nabla\\phi_1 + \\nabla\\phi_2$ 会传播到 $A_3$ 的行向量中。$A_3$ 的第 $k$ 行是 $(\\nabla\\phi_k M^{-1}) (J')^{\\top}$。因此，$R_3 = ((\\nabla\\phi_1 + \\nabla\\phi_2) M^{-1}) (J')^{\\top} = (\\nabla\\phi_1 M^{-1})(J')^{\\top} + (\\nabla\\phi_2 M^{-1})(J')^{\\top} = R_1 + R_2$。\n我们来数值验证一下：\n$$\nR_1 + R_2 = \\left(\\frac{3}{2} - \\frac{1}{2}, -\\frac{1}{2} + \\frac{5}{6}, 1 + \\frac{1}{3}\\right) = \\left(1, \\frac{-3+5}{6}, \\frac{4}{3}\\right) = \\left(1, \\frac{2}{6}, \\frac{4}{3}\\right) = \\left(1, \\frac{1}{3}, \\frac{4}{3}\\right)\n$$\n这恰好是 $R_3$。由于第三行是前两行之和，所以行向量是线性相关的。前两行 $R_1 = (3/2, -1/2, 1)$ 和 $R_2 = (-1/2, 5/6, 1/3)$ 并不互为标量倍数，因此它们是线性无关的。所以，$3 \\times 3$ 矩阵 $A_3$ 的秩为 $2$。\n\n这对可解性有显著影响。由于 $\\mathrm{rank}(A_3)=2  3$，该矩阵是奇异的，其行列式为零。这意味着拉格朗日乘子向量 $\\boldsymbol{\\lambda} = (\\lambda_1, \\lambda_2, \\lambda_3)^{\\top}$ 不存在唯一解。线性系统 $A_3\\boldsymbol{\\lambda}=\\mathbf{b}$ 将无解或有无穷多解。在这种物理背景下，可以证明右端项 $\\mathbf{b}$ 总是在 $A_3$ 的列空间中，因此 $\\boldsymbol{\\lambda}$ 有无穷多解。这反映了总约束力如何在各个线性相关的约束之间分配存在不确定性。\n\n最后一个问题是要求添加第三个约束后乘子系统矩阵的秩。如前所定，该秩为 $2$。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "在理解了冗余约束的后果之后，我们从手动分析转向自动化的算法解决方案。由于在复杂的分子拓扑结构中手动检查约束的独立性并不可行，因此开发能够自动检测并处理此问题的程序至关重要。本练习将使用强大的数值工具——奇异值分解（SVD）——来诊断约束矩阵的秩亏，并实现一个策略来识别和移除冗余的约束，以构建更稳健的模拟程序。",
            "id": "3798262",
            "problem": "您的任务是分析在诸如 SHAKE、RATTLE 和线性约束求解器 (Linear Constraint Solver, LINCS) 等约束分子动力学 (MD) 方法中出现的约束耦合矩阵。在这些方法中，通过求解一个线性系统中的拉格朗日乘子来施加完整约束，该线性系统的系数矩阵必须为满秩才能得到唯一解。考虑一个包含 $n$ 个广义坐标和质量的系统，对其施加一组 $m$ 个完整约束。设约束函数为 $c_i(\\mathbf{q}) = 0$，其中 $i \\in \\{1,\\dots,m\\}$，$\\mathbf{q}$ 为坐标。定义雅可比矩阵 $J$，其行向量为 $\\nabla c_i(\\mathbf{q})$，以及一个对角质量矩阵 $M$。质量加权约束雅可比矩阵为 $A = J M^{-1/2}$，约束格拉姆矩阵为 $G = A A^\\top$。在 SHAKE（原始名称，非首字母缩写）、RATTLE（原始名称，非首字母缩写）和线性约束求解器 (LINCS) 的约束更新中，拉格朗日乘子的可解性和数值稳定性依赖于矩阵 $G$ 是满秩的。\n\n您必须实现一个程序，对每个测试用例执行以下操作：\n- 计算 $G$ 的奇异值分解 (Singular Value Decomposition, SVD)，即 $G = U \\Sigma V^\\top$，并使用奇异值和一个相对阈值 $\\tau = r \\cdot s_{\\max}$ 来检测秩亏。其中 $s_{\\max}$ 是 $G$ 的最大奇异值，$r$ 是测试用例中给定的正标量。如果对于任何奇异值 $s_k$ 有 $s_k  \\tau$，则声明 $G$ 为秩亏矩阵。\n- 通过移除一个最小约束集来提出对约束集的修改，以恢复满秩。该约束集通过分析与低于阈值的奇异值相关联的奇异向量来确定。对于每个满足 $s_k  \\tau$ 的奇异值 $s_k$，考虑其对应的左奇异向量 $\\mathbf{u}_k$，并贪心地选择 $\\mathbf{u}_k$ 中具有最大绝对值分量的约束索引进行移除。如果该索引已被选中，则选择下一个最大分量对应的索引。应用这些移除操作，重新计算简化后的 $G$ 的 SVD，并持续此过程，直到简化后的矩阵在相同阈值下为满秩。如果必须移除所有约束才能恢复满秩，则返回所有约束的索引。\n- 每个测试用例报告两项内容：一个布尔值，指示原始 $G$ 是否为满秩；以及一个整数索引列表，表示为恢复满秩需要移除的约束。索引必须是从零开始的。\n\n仅使用纯数学构造，并通过从代表质量加权约束的给定矩阵 $A$ 构造 $G = A A^\\top$ 来确保科学真实性。由于在质量加权坐标中计算是无量纲的，因此不需要物理单位。不涉及角度。\n\n您的程序必须处理以下测试套件，其中每个用例是一对 $(A, r)$：\n- 用例 $1$（独立约束，理想情况）：$A = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$，$r = 10^{-12}$。\n- 用例 $2$（冗余约束，精确相关）：$A = \\begin{bmatrix} 1  0 \\\\ 1  0 \\end{bmatrix}$，$r = 10^{-12}$。\n- 用例 $3$（近相关，病态）：$A = \\begin{bmatrix} 1  0 \\\\ 1  10^{-6} \\end{bmatrix}$，$r = 10^{-5}$。\n- 用例 $4$（超定，一个相关约束）：$A = \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ 1  1 \\end{bmatrix}$，$r = 10^{-12}$。\n- 用例 $5$（退化约束行）：$A = \\begin{bmatrix} 0  0 \\\\ 1  0 \\\\ 0  1 \\end{bmatrix}$，$r = 10^{-12}$。\n\n对于每个用例，计算 $G = A A^\\top$，执行上述检测，并提出要移除的索引。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目是一个双元素列表 `[b, L]`，其中 `b` 是一个布尔值，反映原始 $G$ 是否为满秩（true 表示满秩），`L` 是为恢复满秩而要移除的从零开始的整数索引列表。例如，输出格式必须为 `[[b_1, L_1],[b_2, L_2],...]`，打印行中不含空格。",
            "solution": "该问题要求分析约束格拉姆矩阵，记为 $G$，该矩阵出现在分子动力学模拟中完整约束的数值求解过程中。用于施加约束的拉格朗日乘子的唯一解取决于该矩阵的可逆性，即是否为满秩。我们的任务是诊断 $G$ 的秩亏，并提出一个最小约束集以移除从而恢复其满秩。\n\n这个问题的基础在于线性代数及其在约束力学系统中的应用。一组 $m$ 个完整约束由 $c_i(\\mathbf{q}) = 0$ 给出，其中 $i \\in \\{1, \\dots, m\\}$。在像 SHAKE 和 RATTLE 这样的方法中，这些约束在位置和速度层面上被强制执行。更新方程会导出一个关于拉格朗日乘子 $\\boldsymbol{\\lambda}$ 的线性系统。该系统的系数矩阵就是格拉姆矩阵 $G$。\n\n格拉姆矩阵定义为 $G = A A^\\top$，其中 $A$ 是 $m \\times n$ 的质量加权约束雅可比矩阵。矩阵 $A$ 本身定义为 $A = J M^{-1/2}$，其中 $J$ 是约束函数的 $m \\times n$ 雅可比矩阵（其行是 $\\nabla c_i(\\mathbf{q})$），$M$ 是对角的 $n \\times n$ 质量矩阵。因此，矩阵 $G$ 是一个 $m \\times m$ 的对称半正定矩阵。为了使 $m$ 个拉格朗日乘子存在唯一解，$G$ 必须是可逆的，这要求它是满秩的，即 $\\text{rank}(G) = m$。\n\n$G$ 的秩亏（即 $\\text{rank}(G)  m$）意味着其行（和列）是线性相关的。由于 $G$ 的行是 $A$ 的行的线性组合，这直接对应于由 $A$ 的行所代表的约束梯度之间存在线性相关性。从物理上讲，这意味着至少有一个约束是冗余的，因为它的效果可以由其他约束的组合来重现。\n\n奇异值分解 (SVD) 是确定矩阵秩的最稳健的数值方法。对于我们的 $m \\times m$ 矩阵 $G$，其 SVD 为 $G = U \\Sigma V^\\top$，其中 $U$ 和 $V$ 是 $m \\times m$ 的正交矩阵，$\\Sigma$ 是一个包含奇异值 $s_1 \\ge s_2 \\ge \\dots \\ge s_m \\ge 0$ 的对角矩阵。$G$ 的秩是其非零奇异值的数量。在数值计算中，由于浮点运算的存在，我们通过识别“接近”零的奇异值来检查秩亏。问题指定了一个相对阈值 $\\tau = r \\cdot s_{\\max}$，其中 $s_{\\max} = s_1$ 是最大奇异值，$r$ 是一个给定的很小的正标量。如果任何奇异值 $s_k$ 满足 $s_k  \\tau$，则矩阵 $G$ 被认为是秩亏的。\n\n如果检测到秩亏，我们必须识别并移除导致秩亏的约束。一个很小的奇异值 $s_k \\approx 0$ 意味着 $G$ 的近零空间中存在一个向量。$U$ 的列，记为 $\\mathbf{u}_k$，是左奇异向量。对于像 $G$ 这样的对称矩阵，其左、右奇异向量是相同的（最多差一个符号），它们也是 $G$ 的特征向量。SVD 方程 $G V = U \\Sigma$ 给出 $G \\mathbf{v}_k = s_k \\mathbf{u}_k$。由于 $G$ 是对称的，$U=V$，所以 $G \\mathbf{u}_k = s_k \\mathbf{u}_k$。如果 $s_k \\approx 0$，则 $G \\mathbf{u}_k \\approx \\mathbf{0}$。这个方程 $\\sum_{j=1}^{m} G_{ij} u_{jk} \\approx 0$（对所有 $i$ 成立）表明，向量 $\\mathbf{u}_k$ 定义了 $G$ 的列（和行）的一个近似为零的线性组合。分量的大小 $|u_{ik}|$ 表示第 $i$ 个约束的梯度在这种线性相关性中的权重。一个大的 $|u_{ik}|$ 表明第 $i$ 个约束是造成冗余的主要原因。\n\n规定的算法是一个恢复满秩的贪心迭代过程：\n$1$. 对于给定的活动约束集，构建相应的简化格拉姆矩阵 $G_{red}$。\n$2$. 计算其 SVD 并使用阈值 $\\tau$ 判断其是否秩亏。\n$3$. 如果是满秩，则过程终止。\n$4$. 如果秩亏，则对于每个奇异值 $s_k  \\tau$，分析其对应的左奇异向量 $\\mathbf{u}_k$。\n$5$. 以贪心的方式，确定要移除的约束。对于每个 $\\mathbf{u}_k$，我们找到具有最大绝对值 $|u_{ik}|$ 的分量。索引 $i$ 指向在该特定相关性中最具影响力的约束。此约束被标记为待移除。为避免在同一次迭代中基于不同的近零向量重复移除同一约束，我们确保每个被标记的约束是唯一的。如果首选已被标记，我们则处理同一向量 $\\mathbf{u}_k$ 中下一个最大幅度的分量。\n$6$. 移除被标记的约束，并从步骤 1 开始，用一个更小的活动约束集重复此过程。\n\n我们首先评估原始矩阵 $G$ 的秩以确定初始状态。然后，我们应用迭代移除过程，直到简化后的格拉姆矩阵达到满秩。最终输出是一个布尔值，指示初始状态，以及一个包含所有被移除约束的从零开始的索引的列表。\n\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes constraint coupling matrices for rank deficiency and proposes\n    a minimal set of constraints to remove to restore full rank.\n    \"\"\"\n    test_cases = [\n        (np.array([[1.0, 0.0], [0.0, 1.0]]), 1e-12),\n        (np.array([[1.0, 0.0], [1.0, 0.0]]), 1e-12),\n        (np.array([[1.0, 0.0], [1.0, 1e-6]]), 1e-5),\n        (np.array([[1.0, 0.0], [0.0, 1.0], [1.0, 1.0]]), 1e-12),\n        (np.array([[0.0, 0.0], [1.0, 0.0], [0.0, 1.0]]), 1e-12),\n    ]\n\n    all_results = []\n\n    for A, r in test_cases:\n        m, _ = A.shape\n        original_indices = list(range(m))\n\n        # Step 1: Check if the original G is full rank\n        if m == 0:\n            is_original_full_rank = True\n        else:\n            G_orig = A @ A.T\n            s_orig = np.linalg.svd(G_orig, compute_uv=False)\n            s_max_orig = s_orig[0] if s_orig.size  0 else 0.0\n            tau_orig = r * s_max_orig\n            is_original_full_rank = not np.any(s_orig  tau_orig)\n\n        # Step 2: Iteratively remove constraints to restore full rank\n        removed_indices = set()\n        current_indices = list(original_indices)\n\n        while True:\n            num_current_constraints = len(current_indices)\n            if num_current_constraints == 0:\n                break\n            \n            A_reduced = A[current_indices, :]\n            G_reduced = A_reduced @ A_reduced.T\n            \n            U_red, s_red, _ = np.linalg.svd(G_reduced)\n            \n            s_max_red = s_red[0] if s_red.size  0 else 0.0\n            tau_red = r * s_max_red\n\n            # Find indices of singular values below the threshold\n            small_sv_indices = np.where(s_red  tau_red)[0]\n            \n            if small_sv_indices.size == 0:\n                # Matrix is now full rank\n                break\n            \n            # Identify constraints to remove in this iteration\n            to_remove_this_iteration = set()\n            for k in small_sv_indices:\n                u_k = U_red[:, k]\n                # Sort components of the singular vector by absolute magnitude, in descending order\n                sorted_local_indices = np.argsort(np.abs(u_k))[::-1]\n                \n                # Find the first available constraint to remove\n                for local_idx in sorted_local_indices:\n                    original_idx = current_indices[local_idx]\n                    if original_idx not in removed_indices and original_idx not in to_remove_this_iteration:\n                        to_remove_this_iteration.add(original_idx)\n                        break\n            \n            if not to_remove_this_iteration:\n                break\n\n            removed_indices.update(to_remove_this_iteration)\n            current_indices = [i for i in original_indices if i not in removed_indices]\n\n        final_removed_list = sorted(list(removed_indices))\n        all_results.append((is_original_full_rank, final_removed_list))\n\n    # Format the final output string as per requirements\n    formatted_items = []\n    for b, L in all_results:\n        l_str = f\"[{','.join(map(str, L))}]\"\n        # The problem asks for a boolean b. Python's str(True) is 'True'.\n        formatted_items.append(f\"[{str(b)},{l_str}]\")\n\n    output_str = f\"[{','.join(formatted_items)}]\"\n    print(output_str)\n\n# To generate the answer, one would call solve(), but the answer must be a static string.\n# The expected output string is hardcoded in the answer tag.\n```",
            "answer": "`[[True,[]],[False,[1]],[False,[1]],[False,[2]],[False,[0]]]`"
        }
    ]
}