{
    "hands_on_practices": [
        {
            "introduction": "The foundation of the Density Functional Tight-Binding (DFTB) method lies in its efficient construction of the Hamiltonian matrix. This is achieved using the Slater-Koster two-center approximation, which parameterizes the interactions between atomic orbitals based on their relative orientation and distance. This practice exercise  delves into this core concept, challenging you to derive the geometric prefactors for $p$-orbital couplings, thereby building a crucial connection between atomic-scale geometry and the electronic structure.",
            "id": "3801020",
            "problem": "In Density Functional Tight-Binding (DFTB), the two-center approximation expresses interatomic Hamiltonian matrix elements between atomic orbitals in terms of bond-direction-resolved channel integrals and angular prefactors governed by rotational symmetry. Consider a crystalline lattice in which a pair of atoms is connected by the bond vector $\\boldsymbol{R} = a(2,1,2)$, where $a$ is the lattice constant and the components are given in a Cartesian frame aligned with the orbital axes $\\{p_x, p_y, p_z\\}$. Using the principle that $p$-orbital couplings can be decomposed into $\\sigma$ and $\\pi$ channels defined by the unit bond direction $\\hat{\\boldsymbol{R}} = \\boldsymbol{R}/|\\boldsymbol{R}|$, start from the rotational properties of real $p$ orbitals and the two-center form in which the interatomic coupling depends only on the projection of orbital orientations relative to $\\hat{\\boldsymbol{R}}$ and the radial two-center integrals $V_{pp\\sigma}(|\\boldsymbol{R}|)$ and $V_{pp\\pi}(|\\boldsymbol{R}|)$. Derive the angular prefactors for the $p_x$-$p_x$ and $p_x$-$p_y$ couplings in terms of the direction cosines of $\\hat{\\boldsymbol{R}}$, and then evaluate these prefactors for the specific bond $\\boldsymbol{R} = a(2,1,2)$. Additionally, determine the symmetry conditions on the direction cosines under which the $p_x$-$p_y$ coupling must vanish in the two-center approximation.\n\nExpress your final answer as a single row matrix containing four dimensionless entries in the order\n$(c_{p_xp_x}^{\\sigma},\\, c_{p_xp_x}^{\\pi},\\, c_{p_xp_y}^{\\sigma},\\, c_{p_xp_y}^{\\pi})$,\nwhere $c^{\\sigma}$ and $c^{\\pi}$ denote the angular prefactors multiplying $V_{pp\\sigma}(|\\boldsymbol{R}|)$ and $V_{pp\\pi}(|\\boldsymbol{R}|)$, respectively. Use exact rational values; no rounding is required and no units should be included.",
            "solution": "The problem statement is critically validated and found to be scientifically grounded, well-posed, objective, and self-contained. It presents a standard problem in the application of the Slater-Koster two-center integral formalism, which is a cornerstone of tight-binding and Density Functional Tight-Binding (DFTB) theory. All necessary information is provided, and the problem is free of any physical or mathematical inconsistencies. Therefore, a solution will be provided.\n\nThe core of the problem lies in the two-center approximation for Hamiltonian matrix elements between atomic orbitals. The coupling between two $p$ orbitals on different atoms, separated by a bond vector $\\boldsymbol{R}$, can be decomposed into contributions from $\\sigma$-bonding (head-on overlap) and $\\pi$-bonding (side-on overlap). The strengths of these contributions are modulated by angular prefactors that depend on the orientation of the orbitals relative to the bond axis.\n\nFirst, we define the unit vector along the bond direction. The given bond vector is $\\boldsymbol{R} = a(2,1,2)$. Its magnitude is:\n$$|\\boldsymbol{R}| = \\sqrt{(2a)^2 + (1a)^2 + (2a)^2} = \\sqrt{4a^2 + a^2 + 4a^2} = \\sqrt{9a^2} = 3a$$\nThe unit vector $\\hat{\\boldsymbol{R}}$ is then:\n$$\\hat{\\boldsymbol{R}} = \\frac{\\boldsymbol{R}}{|\\boldsymbol{R}|} = \\frac{a(2,1,2)}{3a} = \\left(\\frac{2}{3}, \\frac{1}{3}, \\frac{2}{3}\\right)$$\nThe components of this unit vector are the direction cosines of the bond axis with respect to the Cartesian frame $\\{x, y, z\\}$:\n$$l = \\hat{R}_x = \\frac{2}{3}$$\n$$m = \\hat{R}_y = \\frac{1}{3}$$\n$$n = \\hat{R}_z = \\frac{2}{3}$$\nAs a check, the sum of their squares is $l^2 + m^2 + n^2 = (\\frac{2}{3})^2 + (\\frac{1}{3})^2 + (\\frac{2}{3})^2 = \\frac{4}{9} + \\frac{1}{9} + \\frac{4}{9} = \\frac{9}{9} = 1$.\n\nThe Hamiltonian matrix element $H_{p_i p_j} = \\langle p_i(\\boldsymbol{r}) | \\hat{H} | p_j(\\boldsymbol{r}-\\boldsymbol{R}) \\rangle$ between a $p_i$ orbital on the origin atom and a $p_j$ orbital on the atom at position $\\boldsymbol{R}$ can be expressed using the Slater-Koster formulation. A real $p_i$ orbital (for $i \\in \\{x,y,z\\}$) has the same angular dependence as the corresponding coordinate, so its orientation can be represented by the unit vector $\\hat{\\boldsymbol{e}}_i$.\n\nThe $\\sigma$-coupling arises from the projection of each orbital's orientation vector onto the bond axis unit vector $\\hat{\\boldsymbol{R}}$. The angular prefactor for the $\\sigma$ channel is the product of these projections:\n$$(\\hat{\\boldsymbol{e}}_i \\cdot \\hat{\\boldsymbol{R}})(\\hat{\\boldsymbol{e}}_j \\cdot \\hat{\\boldsymbol{R}}) = \\hat{R}_i \\hat{R}_j$$\nThe $\\pi$-coupling arises from the overlap of the orbital components perpendicular to the bond axis. The component of $\\hat{\\boldsymbol{e}}_i$ perpendicular to $\\hat{\\boldsymbol{R}}$ is $\\hat{\\boldsymbol{e}}_i - (\\hat{\\boldsymbol{e}}_i \\cdot \\hat{\\boldsymbol{R}})\\hat{\\boldsymbol{R}}$. The dot product of the perpendicular components for orbitals $i$ and $j$ gives the angular prefactor for the $\\pi$ channel:\n$$(\\hat{\\boldsymbol{e}}_i - (\\hat{\\boldsymbol{e}}_i \\cdot \\hat{\\boldsymbol{R}})\\hat{\\boldsymbol{R}}) \\cdot (\\hat{\\boldsymbol{e}}_j - (\\hat{\\boldsymbol{e}}_j \\cdot \\hat{\\boldsymbol{R}})\\hat{\\boldsymbol{R}}) = \\hat{\\boldsymbol{e}}_i \\cdot \\hat{\\boldsymbol{e}}_j - (\\hat{\\boldsymbol{e}}_i \\cdot \\hat{\\boldsymbol{R}})(\\hat{\\boldsymbol{e}}_j \\cdot \\hat{\\boldsymbol{R}}) = \\delta_{ij} - \\hat{R}_i \\hat{R}_j$$\nCombining these, the total matrix element is given by:\n$$H_{p_i p_j}(\\boldsymbol{R}) = (\\hat{R}_i \\hat{R}_j) V_{pp\\sigma}(|\\boldsymbol{R}|) + (\\delta_{ij} - \\hat{R}_i \\hat{R}_j) V_{pp\\pi}(|\\boldsymbol{R}|)$$\nHere, $V_{pp\\sigma}$ and $V_{pp\\pi}$ are the two-center radial integrals. The problem asks for the angular prefactors $c_{p_i p_j}^{\\sigma}$ and $c_{p_i p_j}^{\\pi}$ where $H_{p_i p_j} = c_{p_i p_j}^{\\sigma} V_{pp\\sigma} + c_{p_i p_j}^{\\pi} V_{pp\\pi}$. By comparison, we have:\n$$c_{p_i p_j}^{\\sigma} = \\hat{R}_i \\hat{R}_j$$\n$$c_{p_i p_j}^{\\pi} = \\delta_{ij} - \\hat{R}_i \\hat{R}_j$$\nIn terms of direction cosines $l, m, n$, we have $\\hat{R}_x=l$, $\\hat{R}_y=m$, $\\hat{R}_z=n$.\n\nWe now apply these general formulas to the specific cases required.\n\nCase 1: $p_x$-$p_x$ coupling.\nHere $i=x$ and $j=x$.\nThe prefactors are:\n$$c_{p_xp_x}^{\\sigma} = \\hat{R}_x \\hat{R}_x = l^2$$\n$$c_{p_xp_x}^{\\pi} = \\delta_{xx} - \\hat{R}_x \\hat{R}_x = 1 - l^2$$\nSubstituting the value $l = 2/3$:\n$$c_{p_xp_x}^{\\sigma} = \\left(\\frac{2}{3}\\right)^2 = \\frac{4}{9}$$\n$$c_{p_xp_x}^{\\pi} = 1 - \\left(\\frac{2}{3}\\right)^2 = 1 - \\frac{4}{9} = \\frac{5}{9}$$\n\nCase 2: $p_x$-$p_y$ coupling.\nHere $i=x$ and $j=y$.\nThe prefactors are:\n$$c_{p_xp_y}^{\\sigma} = \\hat{R}_x \\hat{R}_y = lm$$\n$$c_{p_xp_y}^{\\pi} = \\delta_{xy} - \\hat{R}_x \\hat{R}_y = 0 - lm = -lm$$\nSubstituting the values $l = 2/3$ and $m = 1/3$:\n$$c_{p_xp_y}^{\\sigma} = \\left(\\frac{2}{3}\\right)\\left(\\frac{1}{3}\\right) = \\frac{2}{9}$$\n$$c_{p_xp_y}^{\\pi} = -\\left(\\frac{2}{3}\\right)\\left(\\frac{1}{3}\\right) = -\\frac{2}{9}$$\n\nFinally, we address the condition under which the $p_x$-$p_y$ coupling vanishes. The total coupling is:\n$$H_{p_x p_y}(\\boldsymbol{R}) = lm V_{pp\\sigma} - lm V_{pp\\pi} = lm (V_{pp\\sigma} - V_{pp\\pi})$$\nFor this coupling to be zero for arbitrary non-zero radial integrals (where generally $V_{pp\\sigma} \\neq V_{pp\\pi}$), the prefactor product $lm$ must be zero.\n$$lm = \\hat{R}_x \\hat{R}_y = 0$$\nThis condition is satisfied if and only if $l=0$ or $m=0$.\nIf $l = \\hat{R}_x = 0$, the bond vector $\\boldsymbol{R}$ lies in the $yz$-plane.\nIf $m = \\hat{R}_y = 0$, the bond vector $\\boldsymbol{R}$ lies in the $xz$-plane.\nIn either case, the bond vector is contained within a Cartesian coordinate plane that is also a nodal plane for one of the orbitals ($p_x$ has a nodal plane at $x=0$, i.e., the $yz$-plane). This geometric arrangement results in zero net overlap between the $p_x$ and $p_y$ orbitals due to symmetry, causing the Hamiltonian matrix element to vanish.\n\nThe four requested prefactors for the specific bond vector $\\boldsymbol{R} = a(2,1,2)$ are therefore $c_{p_xp_x}^{\\sigma} = 4/9$, $c_{p_xp_x}^{\\pi} = 5/9$, $c_{p_xp_y}^{\\sigma} = 2/9$, and $c_{p_xp_y}^{\\pi} = -2/9$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{4}{9} & \\frac{5}{9} & \\frac{2}{9} & -\\frac{2}{9} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "A central task in computational materials science is to translate the abstract outputs of a quantum simulation into tangible physical and chemical properties. DFTB calculations yield density and overlap matrices, which serve as the basis for calculating observable quantities like adsorption energies and atomic charges. This hands-on exercise  guides you through the implementation of these essential post-processing steps, demonstrating how to quantify charge transfer and electrostatic interactions in a molecule-surface system from first principles.",
            "id": "3800955",
            "problem": "You are asked to design and implement a program that computes adsorption energetics and charge-transfer analysis for a set of model systems using Density Functional Tight-Binding (DFTB), starting strictly from the foundational definitions used in multiscale materials simulation. Density Functional Tight-Binding (DFTB) is a parameterized approximation to Density Functional Theory that uses atom-centered basis functions. The analysis must be based on first-principles definitions of observable quantities in terms of the overlap of basis functions and the density matrix, together with an electrostatic interaction model for self-consistent charges.\n\nYour program must: \n1. Determine the adsorption energy, expressed as the change in total energy between the separated and combined configurations. Energies must be expressed in electronvolts (eV).\n2. Compute atomic charges using Mulliken population analysis from the provided density matrix and overlap matrix, assigning basis-function contributions to atoms via ownership of basis functions. The atomic charge on atom $A$ is the difference between its valence electron count and its Mulliken population.\n3. Compute Self-Consistent Charge (SCC) potentials per atom using a symmetric pair-interaction model, and the total SCC energy as the electrostatic quadratic form in the atomic charges with respect to a reference charge state. SCC potentials must be expressed in electronvolts (eV), and the SCC energy must be expressed in electronvolts (eV).\n4. Report, for each test case, the following four quantities in the specified order and units: adsorption energy in electronvolts, net charge transfer from the adsorbate subsystem (expressed as a decimal number of electrons), total SCC energy in electronvolts, and the maximum absolute SCC potential in electronvolts.\n\nFoundational bases for your derivations:\n- Total energy change is defined as the difference between energies of well-defined thermodynamic states.\n- Mulliken population analysis partitions electronic occupations proportional to basis-function overlaps.\n- Electrostatic interaction energy of a charge distribution modeled via a symmetric interaction kernel (matrix) is given by a quadratic form, and potentials are the linear response of that kernel to the charges.\n\nInput is embedded in the program via the following test suite. In each case, there is one basis function per atom, and each atom owns the basis function with the same index. All matrices are symmetric and all quantities are given in electronvolts (eV) where applicable. All numeric entries are to be treated as exact values for the computation.\n\nTest Suite:\n- Case 1 (happy path, three atoms: two substrate and one adsorbate):\n  - Energies: $E_{\\mathrm{comb}} = -15.750$, $E_{\\mathrm{sub}} = -10.200$, $E_{\\mathrm{adsorb}} = -5.400$.\n  - Overlap matrix $S$:\n  $$\n  S = \\begin{bmatrix}\n  1.0 & 0.18 & 0.12 \\\\\n  0.18 & 1.0 & 0.10 \\\\\n  0.12 & 0.10 & 1.0\n  \\end{bmatrix}\n  $$\n  - Density matrix $P$:\n  $$\n  P = \\begin{bmatrix}\n  1.02 & 0.08 & 0.05 \\\\\n  0.08 & 0.93 & 0.06 \\\\\n  0.05 & 0.06 & 0.9972\n  \\end{bmatrix}\n  $$\n  - Valence electron counts $Z$ (one per atom): $Z = \\begin{bmatrix} 1.0 & 1.0 & 1.0 \\end{bmatrix}$.\n  - SCC interaction matrix $\\gamma$:\n  $$\n  \\gamma = \\begin{bmatrix}\n  12.0 & 3.0 & 2.5 \\\\\n  3.0 & 12.0 & 2.0 \\\\\n  2.5 & 2.0 & 11.0\n  \\end{bmatrix}\n  $$\n  - Reference charges $Q^{0}$ (neutral reference): $Q^{0} = \\begin{bmatrix}0.0 & 0.0 & 0.0\\end{bmatrix}$.\n  - Subsystems: substrate atoms $\\{0,1\\}$; adsorbate atoms $\\{2\\}$.\n- Case 2 (boundary case: no inter-atomic overlap, neutral Mulliken charges):\n  - Energies: $E_{\\mathrm{comb}} = -7.000$, $E_{\\mathrm{sub}} = -4.000$, $E_{\\mathrm{adsorb}} = -3.000$.\n  - Overlap matrix $S$:\n  $$\n  S = \\begin{bmatrix}\n  1.0 & 0.0 \\\\\n  0.0 & 1.0\n  \\end{bmatrix}\n  $$\n  - Density matrix $P$:\n  $$\n  P = \\begin{bmatrix}\n  1.0 & 0.0 \\\\\n  0.0 & 1.0\n  \\end{bmatrix}\n  $$\n  - Valence electron counts $Z$: $Z = \\begin{bmatrix}1.0 & 1.0\\end{bmatrix}$.\n  - SCC interaction matrix $\\gamma$:\n  $$\n  \\gamma = \\begin{bmatrix}\n  10.0 & 0.0 \\\\\n  0.0 & 10.0\n  \\end{bmatrix}\n  $$\n  - Reference charges $Q^{0}$: $Q^{0} = \\begin{bmatrix}0.0 & 0.0\\end{bmatrix}$.\n  - Subsystems: substrate atoms $\\{0\\}$; adsorbate atoms $\\{1\\}$.\n- Case 3 (edge case: four atoms with strong coupling and nontrivial charge redistribution):\n  - Energies: $E_{\\mathrm{comb}} = -22.500$, $E_{\\mathrm{sub}} = -16.800$, $E_{\\mathrm{adsorb}} = -5.500$.\n  - Overlap matrix $S$:\n  $$\n  S = \\begin{bmatrix}\n  1.0 & 0.25 & 0.20 & 0.15 \\\\\n  0.25 & 1.0 & 0.22 & 0.12 \\\\\n  0.20 & 0.22 & 1.0 & 0.18 \\\\\n  0.15 & 0.12 & 0.18 & 1.0\n  \\end{bmatrix}\n  $$\n  - Density matrix $P$:\n  $$\n  P = \\begin{bmatrix}\n  1.05 & 0.12 & 0.10 & 0.08 \\\\\n  0.12 & 1.00 & 0.11 & 0.07 \\\\\n  0.10 & 0.11 & 0.90 & 0.09 \\\\\n  0.08 & 0.07 & 0.09 & 0.8182\n  \\end{bmatrix}\n  $$\n  - Valence electron counts $Z$: $Z = \\begin{bmatrix}1.0 & 1.0 & 1.0 & 1.0\\end{bmatrix}$.\n  - SCC interaction matrix $\\gamma$:\n  $$\n  \\gamma = \\begin{bmatrix}\n  11.0 & 3.5 & 3.0 & 2.0 \\\\\n  3.5 & 12.0 & 2.8 & 1.8 \\\\\n  3.0 & 2.8 & 10.5 & 2.2 \\\\\n  2.0 & 1.8 & 2.2 & 9.5\n  \\end{bmatrix}\n  $$\n  - Reference charges $Q^{0}$: $Q^{0} = \\begin{bmatrix}0.0 & 0.0 & 0.0 & 0.0\\end{bmatrix}$.\n  - Subsystems: substrate atoms $\\{0,1,2\\}$; adsorbate atoms $\\{3\\}$.\n\nAngle units are not applicable. Percentages are not applicable; any fractional quantities must be expressed as decimals.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of four numeric values in the order specified above. For example, the output should look like $[\\,[x_{1},y_{1},z_{1},w_{1}],\\,[x_{2},y_{2},z_{2},w_{2}],\\,[x_{3},y_{3},z_{3},w_{3}]\\,]$ with all numbers printed in decimal form. Ensure that adsorption energy and SCC energy are reported in $\\mathrm{eV}$, SCC potentials in $\\mathrm{eV}$, and charge transfer in electrons (as decimals).",
            "solution": "The problem statement has been meticulously validated and is deemed **valid**. It is scientifically grounded in the principles of computational materials science, specifically within the Density Functional Tight-Binding (DFTB) framework. The problem is well-posed, objective, and provides a complete and consistent set of data and definitions required for a unique solution. All provided numerical values and matrix properties are physically and mathematically plausible for the model systems described. The task adheres to the stipulated topic of DFTB and is formalizable into a computational algorithm.\n\nThe solution is derived directly from the foundational principles and definitions provided. The procedure to compute the four required quantities for each test case—adsorption energy ($E_{\\text{ads}}$), net charge transfer from the adsorbate ($\\Delta Q_{\\text{ads}}$), total Self-Consistent Charge (SCC) energy ($E_{\\text{scc}}$), and maximum absolute SCC potential ($\\max|V_A|$)—is as follows:\n\n1.  **Adsorption Energy ($E_{\\text{ads}}$)**\n    The adsorption energy is defined as the total energy change upon forming the combined system from its constituent, non-interacting subsystems (substrate and adsorbate). This follows the principle that energy change is the difference between final and initial thermodynamic states.\n    Given the total energy of the combined system ($E_{\\mathrm{comb}}$), the isolated substrate ($E_{\\mathrm{sub}}$), and the isolated adsorbate ($E_{\\mathrm{adsorb}}$), the adsorption energy is calculated as:\n    $$\n    E_{\\text{ads}} = E_{\\mathrm{comb}} - (E_{\\mathrm{sub}} + E_{\\mathrm{adsorb}})\n    $$\n    All energies are in units of electronvolts ($\\mathrm{eV}$).\n\n2.  **Mulliken Atomic Charges and Net Charge Transfer ($\\Delta Q_{\\text{ads}}$)**\n    The atomic charges are determined via Mulliken population analysis, which partitions the total electronic charge among the atoms. The population of a basis function is its contribution to the total number of electrons. The problem states that each atom $A$ owns a single basis function, indexed by the same integer.\n\n    The Mulliken population $N_A$ of an atom $A$ (with basis function index $\\mu = A$) is defined as the sum of electron populations associated with its basis function. In a matrix representation, this corresponds to the diagonal element of the product of the density matrix $\\mathbf{P}$ and the overlap matrix $\\mathbf{S}$.\n    $$\n    N_A = (\\mathbf{P} \\mathbf{S})_{AA} = \\sum_{B} P_{AB} S_{BA}\n    $$\n    Here, $A$ and $B$ are indices for the basis functions (and atoms). Summation is over all atoms in the system.\n\n    The atomic charge $Q_A$ is the difference between the atom's core charge (given by its number of valence electrons, $Z_A$) and its calculated Mulliken electron population $N_A$.\n    $$\n    Q_A = Z_A - N_A\n    $$\n    The net charge transfer from the adsorbate subsystem, $\\Delta Q_{\\text{ads}}$, is the sum of the final Mulliken charges on all atoms belonging to the adsorbate.\n    $$\n    \\Delta Q_{\\text{ads}} = \\sum_{A \\in \\text{adsorbate}} Q_A\n    $$\n    A positive value of $\\Delta Q_{\\text{ads}}$ signifies that the adsorbate has lost electrons to the substrate. The unit is elementary charge, $e$.\n\n3.  **Total SCC Energy ($E_{\\text{scc}}$)**\n    The SCC energy is the electrostatic interaction energy of the computed atomic charges. It is given by a quadratic form involving the vector of charge differences from a reference state, $\\Delta\\mathbf{Q} = \\mathbf{Q} - \\mathbf{Q}^0$, and the symmetric SCC interaction matrix $\\gamma$. As the provided reference charges $\\mathbf{Q}^0$ are zero, $\\Delta\\mathbf{Q} = \\mathbf{Q}$.\n    $$\n    E_{\\text{scc}} = \\frac{1}{2} \\sum_{A,B} \\Delta Q_A \\gamma_{AB} \\Delta Q_B = \\frac{1}{2} \\mathbf{Q}^T \\gamma \\mathbf{Q}\n    $$\n    The result is in units of electronvolts ($\\mathrm{eV}$).\n\n4.  **Maximum Absolute SCC Potential ($\\max|V_A|$ )**\n    The SCC potential $V_A$ on atom $A$ is the linear response of the electrostatic energy to a change in charge on that atom. It is calculated by the action of the interaction kernel $\\gamma$ on the charge difference vector $\\Delta\\mathbf{Q}$. Again, with $\\mathbf{Q}^0 = \\mathbf{0}$.\n    $$\n    V_A = \\sum_{B} \\gamma_{AB} \\Delta Q_B\n    $$\n    In matrix notation, the vector of atomic potentials $\\mathbf{V}$ is given by $\\mathbf{V} = \\gamma \\mathbf{Q}$. The quantity to be reported is the maximum absolute value among all atomic potentials.\n    $$\n    \\max|V_A| = \\max_{A} |V_A|\n    $$\n    The potentials are in units of electronvolts ($\\mathrm{eV}$).\n\nThese calculations are implemented for each of the three test cases provided. All matrix and vector operations are performed using the NumPy library.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFTB analysis problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"energies\": {\"comb\": -15.750, \"sub\": -10.200, \"adsorb\": -5.400},\n            \"S\": np.array([\n                [1.0, 0.18, 0.12],\n                [0.18, 1.0, 0.10],\n                [0.12, 0.10, 1.0]\n            ]),\n            \"P\": np.array([\n                [1.02, 0.08, 0.05],\n                [0.08, 0.93, 0.06],\n                [0.05, 0.06, 0.9972]\n            ]),\n            \"Z\": np.array([1.0, 1.0, 1.0]),\n            \"gamma\": np.array([\n                [12.0, 3.0, 2.5],\n                [3.0, 12.0, 2.0],\n                [2.5, 2.0, 11.0]\n            ]),\n            \"Q0\": np.array([0.0, 0.0, 0.0]),\n            \"subsystems\": {\"substrate\": [0, 1], \"adsorbate\": [2]}\n        },\n        {\n            \"name\": \"Case 2\",\n            \"energies\": {\"comb\": -7.000, \"sub\": -4.000, \"adsorb\": -3.000},\n            \"S\": np.array([\n                [1.0, 0.0],\n                [0.0, 1.0]\n            ]),\n            \"P\": np.array([\n                [1.0, 0.0],\n                [0.0, 1.0]\n            ]),\n            \"Z\": np.array([1.0, 1.0]),\n            \"gamma\": np.array([\n                [10.0, 0.0],\n                [0.0, 10.0]\n            ]),\n            \"Q0\": np.array([0.0, 0.0]),\n            \"subsystems\": {\"substrate\": [0], \"adsorbate\": [1]}\n        },\n        {\n            \"name\": \"Case 3\",\n            \"energies\": {\"comb\": -22.500, \"sub\": -16.800, \"adsorb\": -5.500},\n            \"S\": np.array([\n                [1.0, 0.25, 0.20, 0.15],\n                [0.25, 1.0, 0.22, 0.12],\n                [0.20, 0.22, 1.0, 0.18],\n                [0.15, 0.12, 0.18, 1.0]\n            ]),\n            \"P\": np.array([\n                [1.05, 0.12, 0.10, 0.08],\n                [0.12, 1.00, 0.11, 0.07],\n                [0.10, 0.11, 0.90, 0.09],\n                [0.08, 0.07, 0.09, 0.8182]\n            ]),\n            \"Z\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"gamma\": np.array([\n                [11.0, 3.5, 3.0, 2.0],\n                [3.5, 12.0, 2.8, 1.8],\n                [3.0, 2.8, 10.5, 2.2],\n                [2.0, 1.8, 2.2, 9.5]\n            ]),\n            \"Q0\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"subsystems\": {\"substrate\": [0, 1, 2], \"adsorbate\": [3]}\n        }\n    ]\n\n    def calculate_properties(case):\n        \"\"\"\n        Computes the required physical quantities for a single test case.\n        \"\"\"\n        # 1. Adsorption Energy\n        E_ads = case[\"energies\"][\"comb\"] - (case[\"energies\"][\"sub\"] + case[\"energies\"][\"adsorb\"])\n\n        # 2. Atomic Charges and Charge Transfer\n        # Mulliken populations are the diagonal of the P*S matrix product\n        populations = np.diag(case[\"P\"] @ case[\"S\"])\n        \n        # Atomic charges are Z - N\n        charges = case[\"Z\"] - populations\n        \n        # Net charge transfer from adsorbate is the sum of charges on adsorbate atoms\n        adsorbate_indices = case[\"subsystems\"][\"adsorbate\"]\n        charge_transfer = np.sum(charges[adsorbate_indices])\n\n        # 3. SCC Energy and Potentials\n        delta_Q = charges - case[\"Q0\"]\n        \n        # SCC potentials V = gamma * delta_Q\n        potentials_V = case[\"gamma\"] @ delta_Q\n        \n        # SCC energy E_scc = 0.5 * delta_Q^T * gamma * delta_Q = 0.5 * delta_Q^T * V\n        E_scc = 0.5 * np.dot(delta_Q, potentials_V)\n\n        # 4. Maximum Absolute SCC Potential\n        max_abs_V = np.max(np.abs(potentials_V))\n\n        return [E_ads, charge_transfer, E_scc, max_abs_V]\n\n    results = []\n    for case in test_cases:\n        results.append(calculate_properties(case))\n\n    # Format output as a list of lists, with no spaces inside or between lists\n    inner_results_str = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output_str = f\"[{','.join(inner_results_str)}]\"\n\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "The predictive power of simulations for crystalline materials hinges on the careful management of numerical approximations, particularly finite-size effects and Brillouin zone sampling. Calculated properties converge to the true bulk value (the thermodynamic limit) as the supercell size ($N$) and the number of $\\mathbf{k}$-points ($K$) increase. This exercise  offers a practical guide to this crucial process, showing how to fit simulation data to an asymptotic error model, extrapolate to the converged limit, and strategically choose computational parameters to achieve a target accuracy.",
            "id": "3801036",
            "problem": "Consider the computation of elastic constants in Density Functional Tight-Binding (DFTB), which is an approximate form of Density Functional Theory (DFT) using a simplified Hamiltonian and a minimal basis representation. Within linear elasticity, the elastic constants are defined from the Born-Oppenheimer potential energy surface via the stress-strain relation. Specifically, for a homogeneous system under small strain, the elastic stiffness tensor satisfies $C_{\\alpha\\beta\\gamma\\delta} = \\frac{1}{V} \\frac{\\partial^2 E}{\\partial \\epsilon_{\\alpha\\beta} \\partial \\epsilon_{\\gamma\\delta}}$, where $E$ is the electronic ground-state energy, $V$ is the system volume, and $\\epsilon_{\\alpha\\beta}$ is the strain tensor. In atomistic simulations under periodic boundary conditions, two principal numerical approximations influence computed elastic constants: the finite supercell size (represented by the integer replication factor $N$ along each direction for a simple cubic repetition) and discrete Brillouin-zone sampling using $K$ symmetry-reduced $\\mathbf{k}$-points in reciprocal space. For a scalar elastic constant $C$ (e.g., $C_{11}$ for an isotropic or cubic system), well-tested numerical analysis in periodic electronic structure suggests that leading convergence errors are analytic in inverse powers of $N$ and $K$, and mixed terms appear from the coupling of real-space and reciprocal-space discretization. This implies that for sufficiently large $N$ and $K$, the measured elastic constant $C(N,K)$ can be represented by a convergent series in the basis $\\{N^{-1},K^{-1},N^{-2},K^{-2},(NK)^{-1}\\}$, with a constant term corresponding to the thermodynamic limit $C_{\\infty}$.\n\nYour task is to write a program that, for multiple test datasets, fits the coefficients of the asymptotic model, extrapolates the elastic constant to the thermodynamic limit, quantifies the finite-size and $\\mathbf{k}$-point convergence error at a specified $(N_0,K_0)$ pair, and recommends $(N,K)$ values that meet a target tolerance by controlling the leading error contributions. The program must be general and operate purely on the provided numerical data without domain-specific shortcuts.\n\nModel:\nAssume the following parametric model for $C(N,K)$:\n$$\nC(N,K) = C_{\\infty} + a N^{-1} + b K^{-1} + c N^{-2} + d K^{-2} + e (N K)^{-1}.\n$$\nThe goal is to estimate $C_{\\infty}$, $a$, $b$, $c$, $d$, and $e$ by linear least squares for each test dataset.\n\nError at a specified $(N_0,K_0)$:\nFor each test dataset, compute the absolute convergence error at the designated $(N_0,K_0)$ as\n$$\n\\Delta(N_0,K_0) = \\left|C(N_0,K_0) - C_{\\infty}\\right|.\n$$\n\nRecommendation strategy:\nGiven a target tolerance $\\tau$ in gigapascals (GPa), recommend integers $(N_{\\mathrm{req}},K_{\\mathrm{req}})$ that satisfy the following leading-term control criteria:\n- Allocate a per-term tolerance $t = \\tau / 3$ to each of $a N^{-1}$, $b K^{-1}$, and $e (N K)^{-1}$, while neglecting the $N^{-2}$ and $K^{-2}$ contributions in the recommendation step (these are higher order and decrease faster).\n- Enforce $|a| N^{-1} \\le t$ and $|b| K^{-1} \\le t$ via\n$$\nN \\ge \\left\\lceil \\frac{|a|}{t} \\right\\rceil, \\quad K \\ge \\left\\lceil \\frac{|b|}{t} \\right\\rceil.\n$$\n- Enforce $|e| (N K)^{-1} \\le t$ by ensuring\n$$\nN K \\ge \\left\\lceil \\frac{|e|}{t} \\right\\rceil.\n$$\nIf the product constraint is not met after choosing $N$ and $K$ from the first two inequalities, adjust $N$ and $K$ minimally to satisfy the product constraint by increasing one or both values. All recommended values must be integers greater than or equal to $1$.\n\nUnits and numerical output requirements:\n- All elastic constants $C$ and $\\Delta$ must be expressed in gigapascals (GPa).\n- All angles, if any, must be in radians; however, no angles are involved in this problem.\n- All numerical outputs must be rounded to three decimal places where applicable (elastic constants and errors), while recommended $N$ and $K$ must be integers.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The results must be ordered per test case as $[C_{\\infty}, \\Delta(N_0,K_0), N_{\\mathrm{req}}, K_{\\mathrm{req}}]$, concatenated for all test cases in the order presented below.\n\nTest suite:\nProvide solutions for the following three datasets. For each dataset, the data are ordered as tuples $(N, K, C)$, where $C$ is in GPa. Use linear least squares to fit the model and extract $C_{\\infty}$. For the error calculation, use the designated $(N_0,K_0)$ in each dataset. For the recommendation, use $\\tau = 0.5$ GPa.\n\n- Test Case $1$ (general case with mixed contributions):\n  Data points $(N,K,C)$ in GPa:\n  $(2,2,221.25)$,\n  $(3,3,195.0)$,\n  $(4,6,178.8194445)$,\n  $(6,4,175.1389),\n  $(8,12,163.8716),\n  $(12,8,162.1181)$.\n  Use $(N_0,K_0) = (12,8)$.\n\n- Test Case $2$ (boundary-dominant $\\mathbf{k}$-point and $N^{-2}$ behavior):\n  Data points $(N,K,C)$ in GPa:\n  $(2,1,292.5)$,\n  $(3,2,245.5556),\n  $(4,4,223.125),\n  $(8,8,210.78125),\n  $(16,16,205.1953125)$,\n  $(32,32,202.5488281)$.\n  Use $(N_0,K_0) = (32,32)$.\n\n- Test Case $3$ (edge case with strong mixed term):\n  Data points $(N,K,C)$ in GPa:\n  $(2,2,157.5)$,\n  $(2,4,146.25)$,\n  $(4,2,143.75),\n  $(4,4,135.625),\n  $(8,8,127.03125),\n  $(12,12,124.5139)$.\n  Use $(N_0,K_0) = (12,12)$.\n\nFinal output format:\nYour program should produce a single line of output containing the aggregated results across all test cases as a comma-separated list enclosed in square brackets, with the sequence:\n$[C_{\\infty}^{(1)}, \\Delta^{(1)}, N_{\\mathrm{req}}^{(1)}, K_{\\mathrm{req}}^{(1)}, C_{\\infty}^{(2)}, \\Delta^{(2)}, N_{\\mathrm{req}}^{(2)}, K_{\\mathrm{req}}^{(2)}, C_{\\infty}^{(3)}, \\Delta^{(3)}, N_{\\mathrm{req}}^{(3)}, K_{\\mathrm{req}}^{(3)}]$.\nRound each $C_{\\infty}$ and each $\\Delta$ to three decimal places in GPa, and output $N_{\\mathrm{req}}$ and $K_{\\mathrm{req}}$ as integers.",
            "solution": "The problem is first validated and found to be well-posed, scientifically grounded, and programmatically solvable. It falls into the category of numerical analysis, specifically parameter estimation via linear regression, applied to a problem in computational materials science.\n\nThe core of the problem is to fit a set of observed data points $(N_i, K_i, C_i)$ to the given parametric model:\n$$\nC(N,K) = C_{\\infty} + a N^{-1} + b K^{-1} + c N^{-2} + d K^{-2} + e (N K)^{-1}\n$$\nThis model is linear with respect to the coefficients $[C_{\\infty}, a, b, c, d, e]$. Therefore, for a set of $m$ data points, we can construct a system of linear equations. This system can be expressed in matrix form as $\\mathbf{y} = \\mathbf{Xp}$, where:\n- $\\mathbf{p} = [C_{\\infty}, a, b, c, d, e]^T$ is the vector of unknown coefficients.\n- $\\mathbf{y} = [C(N_1, K_1), C(N_2, K_2), \\dots, C(N_m, K_m)]^T$ is the vector of observed elastic constant values.\n- $\\mathbf{X}$ is the $m \\times 6$ design matrix, where each row $i$ corresponds to a data point $(N_i, K_i)$ and is given by:\n$$\n\\mathbf{X}_i = \\begin{bmatrix} 1 & N_i^{-1} & K_i^{-1} & N_i^{-2} & K_i^{-2} & (N_i K_i)^{-1} \\end{bmatrix}\n$$\nThe problem provides $m=6$ data points for each test case to determine the $6$ unknown coefficients. This makes the design matrix $\\mathbf{X}$ a square $6 \\times 6$ matrix. Assuming the basis vectors $\\{1, N^{-1}, K^{-1}, N^{-2}, K^{-2}, (NK)^{-1}\\}$ are linearly independent for the given sets of $(N, K)$ pairs, the matrix $\\mathbf{X}$ is invertible, and the system has a unique solution for the coefficients $\\mathbf{p}$. This solution can be found by solving the linear system directly, e.g., $\\mathbf{p} = \\mathbf{X}^{-1}\\mathbf{y}$. A robust numerical approach, such as the one provided by `numpy.linalg.lstsq`, is employed to solve this system for $\\mathbf{p}$.\n\nOnce the coefficient vector $\\mathbf{p}$ is determined, the required quantities are calculated as follows:\n\n1.  **Extrapolated Elastic Constant, $C_{\\infty}$**: The first element of the solved vector $\\mathbf{p}$ is the desired constant $C_{\\infty}$, representing the value in the thermodynamic limit ($N \\to \\infty, K \\to \\infty$).\n\n2.  **Convergence Error, $\\Delta(N_0, K_0)$**: This is the absolute difference between the measured value $C(N_0, K_0)$ provided in the dataset and the extrapolated value $C_{\\infty}$:\n    $$\n    \\Delta(N_0, K_0) = |C(N_0, K_0) - C_{\\infty}|\n    $$\n\n3.  **Recommended Parameters, $(N_{\\mathrm{req}}, K_{\\mathrm{req}})$**: The recommendation is based on a target tolerance $\\tau = 0.5$ GPa, with the goal of controlling the leading-order error terms. A per-term tolerance $t = \\tau/3$ is allocated to each of the three dominant error contributions.\n    - The individual constraints for $N$ and $K$ are derived from $|a|N^{-1} \\le t$ and $|b|K^{-1} \\le t$. This implies minimum integer values:\n      $$\n      N_{\\mathrm{req},0} = \\max\\left(1, \\left\\lceil \\frac{|a|}{t} \\right\\rceil\\right), \\quad K_{\\mathrm{req},0} = \\max\\left(1, \\left\\lceil \\frac{|b|}{t} \\right\\rceil\\right)\n      $$\n    - The mixed-term constraint is derived from $|e|(NK)^{-1} \\le t$, implying a minimum product:\n      $$\n      (NK)_{\\mathrm{min}} = \\left\\lceil \\frac{|e|}{t} \\right\\rceil\n      $$\n    - The initial pair $(N_{\\mathrm{req},0}, K_{\\mathrm{req},0})$ is checked against the product constraint. If $N_{\\mathrm{req},0} \\cdot K_{\\mathrm{req},0} < (NK)_{\\mathrm{min}}$, the values must be increased. To do this \"minimally,\" we seek to satisfy all constraints while minimizing the resulting product $N_{\\mathrm{req}}K_{\\mathrm{req}}$, which is a proxy for computational effort. The strategy is to compare two options: (A) increasing only $N$ to meet the product requirement, and (B) increasing only $K$.\n       - Option A: $N_A = \\max(N_{\\mathrm{req},0}, \\lceil (NK)_{\\mathrm{min}} / K_{\\mathrm{req},0} \\rceil)$, Pair: $(N_A, K_{\\mathrm{req},0})$\n       - Option B: $K_B = \\max(K_{\\mathrm{req},0}, \\lceil (NK)_{\\mathrm{min}} / N_{\\mathrm{req},0} \\rceil)$, Pair: $(N_{\\mathrm{req},0}, K_B)$\n    - The final recommendation is the pair with the smaller or equal resulting product. If $N_A \\cdot K_{\\mathrm{req},0} \\le N_{\\mathrm{req},0} \\cdot K_B$, we choose $(N_A, K_{\\mathrm{req},0})$; otherwise, we choose $(N_{\\mathrm{req},0}, K_B)$.\n\nThe implementation proceeds by applying this methodology to each of the three test cases, collecting the four output values ($C_{\\infty}$, $\\Delta$, $N_{\\mathrm{req}}$, $K_{\\mathrm{req}}$) from each, and formatting them into a single-line string as specified. All floating-point results ($C_{\\infty}$, $\\Delta$) are rounded to three decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFTB convergence problem for three test cases.\n    It performs a linear least-squares fit to an asymptotic error model,\n    calculates the convergence error at a specified point, and recommends\n    simulation parameters (N, K) to meet a given error tolerance.\n    \"\"\"\n    test_cases = [\n        {\n            \"data\": [\n                (2, 2, 221.25),\n                (3, 3, 195.0),\n                (4, 6, 178.8194445),\n                (6, 4, 175.1389),\n                (8, 12, 163.8716),\n                (12, 8, 162.1181)\n            ],\n            \"N0K0\": (12, 8)\n        },\n        {\n            \"data\": [\n                (2, 1, 292.5),\n                (3, 2, 245.5556),\n                (4, 4, 223.125),\n                (8, 8, 210.78125),\n                (16, 16, 205.1953125),\n                (32, 32, 202.5488281)\n            ],\n            \"N0K0\": (32, 32)\n        },\n        {\n            \"data\": [\n                (2, 2, 157.5),\n                (2, 4, 146.25),\n                (4, 2, 143.75),\n                (4, 4, 135.625),\n                (8, 8, 127.03125),\n                (12, 12, 124.5139)\n            ],\n            \"N0K0\": (12, 12)\n        }\n    ]\n\n    tau = 0.5\n    final_results = []\n\n    for case in test_cases:\n        data = case[\"data\"]\n        N0, K0 = case[\"N0K0\"]\n\n        # 1. Prepare data for linear least-squares fit\n        n_vals = np.array([d[0] for d in data], dtype=float)\n        k_vals = np.array([d[1] for d in data], dtype=float)\n        c_vals = np.array([d[2] for d in data], dtype=float)\n\n        # Construct the design matrix X\n        X = np.vstack([\n            np.ones_like(n_vals),\n            1 / n_vals,\n            1 / k_vals,\n            1 / n_vals**2,\n            1 / k_vals**2,\n            1 / (n_vals * k_vals)\n        ]).T\n\n        # 2. Solve for coefficients C_inf, a, b, c, d, e\n        try:\n            # For a square matrix, solve is more direct, but lstsq is more general\n            coeffs = np.linalg.lstsq(X, c_vals, rcond=None)[0]\n        except np.linalg.LinAlgError:\n            # Handle singular matrix case, though not expected for this problem\n            final_results.extend([\"error\"] * 4)\n            continue\n            \n        C_inf, a, b, c, d, e = coeffs\n\n        # 3. Calculate convergence error Delta\n        C_N0K0 = -1\n        for n, k, val in data:\n            if n == N0 and k == K0:\n                C_N0K0 = val\n                break\n        \n        delta = abs(C_N0K0 - C_inf)\n\n        # 4. Recommendation strategy\n        t = tau / 3.0\n        \n        # Calculate initial N_req and K_req based on individual constraints\n        N_req = max(1, int(np.ceil(abs(a) / t)))\n        K_req = max(1, int(np.ceil(abs(b) / t)))\n        \n        # Calculate the product constraint\n        nk_min_req = int(np.ceil(abs(e) / t))\n\n        # Adjust if product constraint is not met\n        if N_req * K_req  nk_min_req:\n            # Option A: Increase N while keeping K fixed\n            N_A = max(N_req, int(np.ceil(nk_min_req / K_req)))\n            prod_A = N_A * K_req\n            \n            # Option B: Increase K while keeping N fixed\n            K_B = max(K_req, int(np.ceil(nk_min_req / N_req)))\n            prod_B = N_req * K_B\n            \n            # Choose the option with the minimal resulting product NK\n            if prod_A = prod_B:\n                N_req = N_A\n            else:\n                K_req = K_B\n        \n        # Store formatted results\n        final_results.append(f\"{C_inf:.3f}\")\n        final_results.append(f\"{delta:.3f}\")\n        final_results.append(str(N_req))\n        final_results.append(str(K_req))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"
        }
    ]
}