{
    "hands_on_practices": [
        {
            "introduction": "高斯型轨道（GTOs）是分子量子化学计算中构建基函数的基础。与物理上更准确的斯莱特型轨道（STOs）不同，两个高斯函数的乘积是另一个高斯函数，这一特性极大地简化了双电子积分的计算。本练习旨在通过解析计算两个一维高斯函数的重叠积分，来巩固对GTOs数学性质的理解，并揭示高斯积定理这一核心概念。",
            "id": "2450913",
            "problem": "在电子结构计算中使用的Gaussian型轨道（GTO）基函数的背景下，考虑两个一维原始Gaussian函数，\n$$\\phi_{\\mu}(x) = \\exp\\!\\big(-\\alpha_{1}(x - X_{1})^{2}\\big) \\quad \\text{和} \\quad \\phi_{\\nu}(x) = \\exp\\!\\big(-\\alpha_{2}(x - X_{2})^{2}\\big),$$\n其中 $\\alpha_{1} > 0$ 和 $\\alpha_{2} > 0$ 是实数指数，而 $X_{1}$ 和 $X_{2}$ 是沿 $x$ 坐标的实数中心。一维重叠积分定义为\n$$S_{\\mu \\nu} = \\int_{-\\infty}^{\\infty} \\phi_{\\mu}(x)\\,\\phi_{\\nu}(x)\\,dx.$$\n以 $\\alpha_{1}$、$\\alpha_{2}$、$X_{1}$ 和 $X_{2}$ 的形式，计算 $S_{\\mu \\nu}$ 的闭合形式解析表达式。将最终答案表示为无单位的单一简化解析表达式。",
            "solution": "所提出的问题是适定的、有科学依据且客观的。它代表了量子化学中的一个基本计算，特别是两个高斯型轨道之间重叠积分的求值。所有必要的参数都已定义，且条件 $\\alpha_{1} > 0$ 和 $\\alpha_{2} > 0$ 确保了积分是收敛的。因此，可以直接推导出解析解。\n\n一维重叠积分 $S_{\\mu \\nu}$ 由下列表达式定义：\n$$S_{\\mu \\nu} = \\int_{-\\infty}^{\\infty} \\phi_{\\mu}(x)\\,\\phi_{\\nu}(x)\\,dx$$\n代入原始高斯函数 $\\phi_{\\mu}(x) = \\exp(-\\alpha_{1}(x - X_{1})^{2})$ 和 $\\phi_{\\nu}(x) = \\exp(-\\alpha_{2}(x - X_{2})^{2})$ 的给定形式，可得：\n$$S_{\\mu \\nu} = \\int_{-\\infty}^{\\infty} \\exp(-\\alpha_{1}(x - X_{1})^{2}) \\exp(-\\alpha_{2}(x - X_{2})^{2})\\,dx$$\n指数函数的乘积等价于其参数之和的指数。这使得被积函数可以合并成一个单一的指数函数：\n$$S_{\\mu \\nu} = \\int_{-\\infty}^{\\infty} \\exp\\big(-\\alpha_{1}(x - X_{1})^{2} - \\alpha_{2}(x - X_{2})^{2}\\big)\\,dx$$\n指数的参数是一个关于 $x$ 的多项式，必须将其简化。设此参数为 $P(x)$：\n$$P(x) = -\\alpha_{1}(x - X_{1})^{2} - \\alpha_{2}(x - X_{2})^{2}$$\n展开平方项可得：\n$$P(x) = -\\alpha_{1}(x^{2} - 2xX_{1} + X_{1}^{2}) - \\alpha_{2}(x^{2} - 2xX_{2} + X_{2}^{2})$$\n合并 $x$ 的同次幂项：\n$$P(x) = -(\\alpha_{1} + \\alpha_{2})x^{2} + 2(\\alpha_{1}X_{1} + \\alpha_{2}X_{2})x - (\\alpha_{1}X_{1}^{2} + \\alpha_{2}X_{2}^{2})$$\n为了便于积分，必须将此二次表达式重写为标准的平方形式。这个过程称为配方法。所求的一般形式为 $-p(x - X_{p})^{2} - C$。\n\n定义一个新的指数 $p$ 为 $p = \\alpha_{1} + \\alpha_{2}$。由于 $\\alpha_{1} > 0$ 且 $\\alpha_{2} > 0$，可得 $p > 0$。该多项式变为：\n$$P(x) = -p x^{2} + 2(\\alpha_{1}X_{1} + \\alpha_{2}X_{2})x - (\\alpha_{1}X_{1}^{2} + \\alpha_{2}X_{2}^{2})$$\n从与 $x$ 相关的项中提出因子 $-p$：\n$$P(x) = -p\\left(x^{2} - 2\\frac{\\alpha_{1}X_{1} + \\alpha_{2}X_{2}}{p}x\\right) - (\\alpha_{1}X_{1}^{2} + \\alpha_{2}X_{2}^{2})$$\n定义一个新的中心 $X_{p} = \\frac{\\alpha_{1}X_{1} + \\alpha_{2}X_{2}}{p} = \\frac{\\alpha_{1}X_{1} + \\alpha_{2}X_{2}}{\\alpha_{1} + \\alpha_{2}}$。\n在括号内进行配方：\n$$x^{2} - 2X_{p}x = (x - X_{p})^{2} - X_{p}^{2}$$\n将此代回 $P(x)$ 的表达式中：\n$$P(x) = -p\\big((x - X_{p})^{2} - X_{p}^{2}\\big) - (\\alpha_{1}X_{1}^{2} + \\alpha_{2}X_{2}^{2})$$\n$$P(x) = -p(x - X_{p})^{2} + pX_{p}^{2} - (\\alpha_{1}X_{1}^{2} + \\alpha_{2}X_{2}^{2})$$\n项 $pX_{p}^{2} - (\\alpha_{1}X_{1}^{2} + \\alpha_{2}X_{2}^{2})$ 是一个关于 $x$ 的常数。必须简化此常数项：\n$$pX_{p}^{2} - (\\alpha_{1}X_{1}^{2} + \\alpha_{2}X_{2}^{2}) = (\\alpha_{1}+\\alpha_{2})\\left(\\frac{\\alpha_{1}X_{1} + \\alpha_{2}X_{2}}{\\alpha_{1} + \\alpha_{2}}\\right)^{2} - (\\alpha_{1}X_{1}^{2} + \\alpha_{2}X_{2}^{2})$$\n$$= \\frac{(\\alpha_{1}X_{1} + \\alpha_{2}X_{2})^{2}}{\\alpha_{1} + \\alpha_{2}} - \\frac{(\\alpha_{1} + \\alpha_{2})(\\alpha_{1}X_{1}^{2} + \\alpha_{2}X_{2}^{2})}{\\alpha_{1} + \\alpha_{2}}$$\n合并分子：\n$$= \\frac{(\\alpha_{1}^{2}X_{1}^{2} + 2\\alpha_{1}\\alpha_{2}X_{1}X_{2} + \\alpha_{2}^{2}X_{2}^{2}) - (\\alpha_{1}^{2}X_{1}^{2} + \\alpha_{1}\\alpha_{2}X_{2}^{2} + \\alpha_{2}\\alpha_{1}X_{1}^{2} + \\alpha_{2}^{2}X_{2}^{2})}{\\alpha_{1} + \\alpha_{2}}$$\n$$= \\frac{2\\alpha_{1}\\alpha_{2}X_{1}X_{2} - \\alpha_{1}\\alpha_{2}X_{1}^{2} - \\alpha_{1}\\alpha_{2}X_{2}^{2}}{\\alpha_{1} + \\alpha_{2}}$$\n$$= -\\frac{\\alpha_{1}\\alpha_{2}}{\\alpha_{1} + \\alpha_{2}}(X_{1}^{2} - 2X_{1}X_{2} + X_{2}^{2}) = -\\frac{\\alpha_{1}\\alpha_{2}}{\\alpha_{1} + \\alpha_{2}}(X_{1}-X_{2})^{2}$$\n这就建立了高斯乘积定理：两个分别以 $X_{1}$ 和 $X_{2}$ 为中心的高斯函数的乘积，是一个以 $X_{p}$ 为中心、并乘以一个常数因子的新高斯函数。多项式 $P(x)$ 现在为其最终形式：\n$$P(x) = -(\\alpha_{1} + \\alpha_{2})(x - X_{p})^{2} - \\frac{\\alpha_{1}\\alpha_{2}}{\\alpha_{1}+\\alpha_{2}}(X_{1}-X_{2})^{2}$$\n积分 $S_{\\mu \\nu}$ 重写为：\n$$S_{\\mu \\nu} = \\int_{-\\infty}^{\\infty} \\exp\\left(-(\\alpha_{1} + \\alpha_{2})(x - X_{p})^{2} - \\frac{\\alpha_{1}\\alpha_{2}}{\\alpha_{1}+\\alpha_{2}}(X_{1}-X_{2})^{2}\\right) dx$$\n常数项的指数可以从积分中提出来：\n$$S_{\\mu \\nu} = \\exp\\left(-\\frac{\\alpha_{1}\\alpha_{2}}{\\alpha_{1}+\\alpha_{2}}(X_{1}-X_{2})^{2}\\right) \\int_{-\\infty}^{\\infty} \\exp\\big(-(\\alpha_{1}+\\alpha_{2})(x - X_{p})^{2}\\big) dx$$\n剩下的积分是标准的高斯积分，形式为 $\\int_{-\\infty}^{\\infty} \\exp(-ax^{2})dx = \\sqrt{\\pi/a}$。通过变量代换 $u = x - X_{p}$，$du = dx$，积分变为：\n$$\\int_{-\\infty}^{\\infty} \\exp\\big(-(\\alpha_{1}+\\alpha_{2})u^{2}\\big) du = \\sqrt{\\frac{\\pi}{\\alpha_{1}+\\alpha_{2}}}$$\n将常数前因子乘以积分的值，得到重叠积分 $S_{\\mu \\nu}$ 的最终结果：\n$$S_{\\mu \\nu} = \\left(\\frac{\\pi}{\\alpha_{1}+\\alpha_{2}}\\right)^{\\frac{1}{2}} \\exp\\left(-\\frac{\\alpha_{1}\\alpha_{2}}{\\alpha_{1}+\\alpha_{2}}(X_{1}-X_{2})^{2}\\right)$$\n这就是两个一维原始高斯函数之间重叠的闭合形式解析表达式。",
            "answer": "$$\\boxed{\\left(\\frac{\\pi}{\\alpha_{1} + \\alpha_{2}}\\right)^{\\frac{1}{2}} \\exp\\left(-\\frac{\\alpha_{1}\\alpha_{2}}{\\alpha_{1} + \\alpha_{2}}(X_{1} - X_{2})^{2}\\right)}$$"
        },
        {
            "introduction": "在追求更高计算精度的过程中，我们通常会使用包含“弥散函数”的更大、更灵活的基组，以更好地描述分子中远离原子核的电子分布。然而，这种做法有时会引入一个常见的数值问题：基函数之间的线性依赖。本练习探讨了在使用增强型基组（如aug-cc-pVTZ）时导致重叠矩阵近奇异性的物理原因，这对于诊断和解决实际计算中的收敛问题至关重要。",
            "id": "2450947",
            "problem": "你对一个中等大小的中性有机分子，使用增广相关一致极化价三重泽塔（aug-cc-pVTZ）基组，进行了一次从头算电子结构计算（例如，Hartree–Fock (HF) 或密度泛函理论 (DFT)）。程序因错误而中止，错误信息指出由于基函数之间存在近线性相关，导致重叠矩阵近奇异。在不改变分子几何构型的情况下，`aug-cc-pVTZ` 基组中存在的哪一类基函数是造成这种近线性相关的最可能的物理原因，为什么？\n\nA. 重原子上非常紧凑的核心函数，因为它们的强局域性通过过度重叠导致了病态问题。\n\nB. 标准的价三重泽塔函数，因为每个价层拥有多个函数会内在地产生线性相关性。\n\nC. 非氢原子上最弥散的 s 型增广函数，因为它们非常小的指数使其在空间上延展，并与相邻中心上的类似函数高度重叠。\n\nD. 最弥散的 p 型增广函数，因为它们的角向特征使其比 s 型函数更延展，因此重叠更多。\n\nE. 最弥散的 d 型增广函数，因为在大型基组中，更高角动量的函数总是最先变得线性相关的。",
            "solution": "题目已提交验证。\n\n**步骤 1：提取已知条件**\n- 计算类型：从头算电子结构（Hartree–Fock 或密度泛函理论）。\n- 体系：一个中等大小的中性有机分子。\n- 基组：`aug-cc-pVTZ`（增广相关一致极化价三重泽塔）。\n- 观察到的现象：计算因重叠矩阵近奇异而中止，这表明基函数之间存在近线性相关。\n- 约束条件：分子几何构型固定。\n- 问题：在 `aug-cc-pVTZ` 中，确定哪种类型的基函数是造成近线性相关的最可能物理原因。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在科学上是合理的。它描述了在量子化学计算中使用大型弥散基组时遇到的一个常见数值问题。基组、重叠矩阵奇异性和线性相关等概念是该领域的基础。\n- **适定性**：该问题是适定的。它明确了背景（分子类型、基组）和观察到的错误，并要求在给定基组的各组分中找出最可能的原因。可以推导出一个明确的、有物理依据的答案。\n- **客观性**：该问题使用计算化学的标准术语进行客观陈述。\n\n**步骤 3：结论与行动**\n题目有效。这是一个计算化学中标准且适定的问题。我将继续推导解决方案。\n\n核心问题是重叠矩阵 $S$ 的近奇异性。该矩阵的元素由原子轨道基函数对 $\\chi_{\\mu}$ 和 $\\chi_{\\nu}$ 之间的重叠积分定义：\n$$ S_{\\mu\\nu} = \\int \\chi_{\\mu}^*(\\vec{r}) \\chi_{\\nu}(\\vec{r}) \\,d^3\\vec{r} $$\n如果一个矩阵的行列式为零，则该矩阵是奇异的。近奇异矩阵的行列式接近于零，这意味着它的至少一个特征值非常接近于零。重叠矩阵的特征向量代表基函数的线性组合。接近于零的特征值表示基函数的某个线性组合 $\\sum_k c_k \\chi_k$ 在空间中处处近似为零。这个条件，即 $\\sum_k c_k \\chi_k \\approx 0$ 且系数 $c_k$ 不全为零，就是近线性相关的定义。\n\n当两个或多个基函数非常相似，以至于其中一个可以被精确地表示为其他基函数的线性组合时，就会出现这个问题。这通常发生在以不同原子为中心的基函数具有显著的空间重叠时。\n\n让我们分析一下 `aug-cc-pVTZ` 基组的组成部分。\n- `cc-pVTZ`：这是核心部分，一个“相关一致极化价三重泽塔”基组。\n    - `TZ` (三重泽塔)：为每个价原子轨道提供三个函数。对于像碳这样的原子，这包括三套 s 型和 p 型函数来描述 $n=2$ 壳层。这些函数具有不同的指数，以描述离原子核不同距离处的电子密度。\n    - `p` (极化)：添加比基态原子中被占据的轨道角动量更高的函数。对于碳，这会添加 d 型和 f 型函数。对于氢，会添加 p 型和 d 型函数。这些函数允许轨道形状在分子环境中变形。\n- `aug-` (增广)：这个前缀表示该基组补充了一套**弥散**函数。弥散函数的特征是其高斯形式（例如 $e^{-\\alpha r^2}$）中有一个非常小的指数 $\\alpha$。一个小的 $\\alpha$ 会导致空间衰减非常缓慢，意味着该函数在空间上非常延展，远离原子核。对于价基组中的每一种角动量类型，都会添加一个弥散函数。\n\n线性相关的来源是这些以不同（通常是相邻）原子为中心的高度延展的弥散函数之间的显著重叠。对于一个中等大小的有机分子，原子间的距离约为几埃（Ångström）。一个具有小指数的弥散函数在其中心几埃远的地方仍可以有相当大的振幅，从而导致与相邻原子上的另一个弥散函数产生大的重叠积分。\n\n现在，我们来评估每个选项。\n\n**A. 重原子上非常紧凑的核心函数，因为它们的强局域性通过过度重叠导致了病态问题。**\n该陈述**不正确**。紧凑函数的特点是指数 ($\\alpha$) 很大。它们被强烈地局域在非常靠近原子核的地方。由于这种极端的局域性，它们与以*不同*原子为中心的任何函数（紧凑或弥散）的重叠都可以忽略不计。因此，它们不是导致分子计算中重叠矩阵近奇异的原子间线性相关性的主要原因。*同一*原子上紧凑函数之间的过度重叠可能是基组设计中需要考虑的问题，但它不是问题中所述错误的典型原因。\n\n**B. 标准的价三重泽塔函数，因为每个价层拥有多个函数会内在地产生线性相关性。**\n该陈述**不正确**。虽然增加每个壳层中的函数数量（例如，从双重泽塔到三重泽塔）会使线性相关性更有可能发生，但这并非内在或必然的结果。`cc-pVTZ` 基组中价函数的指数经过精心优化，以在描述价层不同空间区域的同时，在很大程度上保持线性无关。线性相关性最重要的来源是那些在空间上比标准价函数中最弥散的函数还要延展得多的函数。\n\n**C. 非氢原子上最弥散的 s 型增广函数，因为它们非常小的指数使其在空间上延展，并与相邻中心上的类似函数高度重叠。**\n该陈述**正确**。根据定义，增广函数是基组中最弥散的函数，具有最小的指数。它们非常缓慢的空间衰减导致它们在很大的体积内都很大，从而与附近原子上的其他弥散函数产生高重叠。`s 型`函数尤其成问题，因为它们是球对称的，并且（对于最低的高斯基元）没有节点。一个原子上的弥散 `s 函数` 在相邻原子的区域内看起来很像一个简单的常数。因此，一个中心上的弥散 s 函数可以很容易地用其邻居上的弥散 s 函数的线性组合来近似，从而导致严重的线性相关性。这是这种特定数值问题的典型和最著名的原因。\n\n**D. 最弥散的 p 型增广函数，因为它们的角向特征使其比 s 型函数更延展，因此重叠更多。**\n该陈述**不正确**。一个具有给定指数 $\\alpha$ 的 `p 函数` 与具有相同指数的 `s 函数` 具有相同的高斯径向衰减项 ($e^{-\\alpha r^2}$)。角向特征（$x$、$y$ 或 $z$）并不会使其内在地“更延展”。事实上，节面（例如 $p_x$ 函数的 $yz$ 平面）的存在使其结构更复杂，并且通常比没有特征的 `s 函数` *更不容易* 产生简单的线性相关。虽然弥散的 `p 函数` 确实会导致线性相关性问题，但问题通常在 `s 函数` 上最为严重。\n\n**E. 最弥散的 d 型增广函数，因为在大型基组中，更高角动量的函数总是最先变得线性相关的。**\n该陈述**不正确**。关于更高角动量的函数*总是*最先变得线性相关的断言在事实上是错误的。随着角动量的增加（从 `s` 到 `p` 到 `d` 等），函数会获得更复杂的节点结构（包括角向和径向）。这种增加的复杂性使它们彼此之间更加不同，与平滑、无节点的 `s 函数` 相比，通常会降低简单线性相关的风险。近线性相关的主要原因是空间上“最平坦”和最延展的函数的重叠，也就是弥散的 s 型函数。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "从分子系统转向周期性固体材料时，平面波基组成为密度泛函理论（DFT）计算的首选。与高斯基组类似，平面波基组也受限于一个有限的截断能（$E_{\\mathrm{cut}}$），因此需要外推到完备基组极限（$E_\\infty$）来获得准确的总能量。这个高级实践要求我们从第一性原理出发，推导总能量随截断能变化的渐近模型，并将其应用于实际的计算数据，通过编程实现一个稳健的外推算法。",
            "id": "3791733",
            "problem": "考虑一个在密度泛函理论（DFT）中常用的平面波基组下建模的周期性固体。在倒易空间中，平面波基组被一个动能截断能（以电子伏特 eV 为单位，记作 $E_{\\mathrm{cut}}$）所截断。这限制了所包含的倒易矢量 $\\mathbf{G}$ 满足 $|\\mathbf{G}| \\leq G_{\\mathrm{c}}$，其中 $G_{\\mathrm{c}}$ 由 $E_{\\mathrm{cut}} = \\hbar^2 G_{\\mathrm{c}}^2 / (2m)$ 隐式定义，m 为电子质量，$\\hbar$ 为约化普朗克常数。当使用有限平面波基组计算时，每个晶胞的总能量与完备基组极限 $E_\\infty$ 不同，因为超出了截断能的高频分量被排除了。对于在倒易空间中呈现特定衰减（傅里叶尾）的局域赝势，其主要的基组不完备性误差可以通过结合倒易空间态密度标度和二阶 Rayleigh-Schrödinger 微扰理论进行分析。\n\n从第一性原理出发，利用倒易空间表示法和局域赝势傅里叶分量的渐近衰减行为，来证明一个关于总能量随 $E_{\\mathrm{cut}}$ 变化的主阶渐近模型，其形式为 $E(E_{\\mathrm{cut}}) = E_\\infty + \\text{(振幅)} \\times E_{\\mathrm{cut}}^{-\\text{(指数)}}$。从傅里叶尾的衰减行为中推导出指数，并论证该模型的合理性。然后，设计一种算法，利用推导出的渐近形式，从带噪声的测量值 $E(E_{\\mathrm{cut}})$ 中估计 $E_\\infty$。你的算法应该数值稳定，并对中等程度的噪声具有鲁棒性。\n\n你的程序必须：\n- 通过对 $E_{\\mathrm{cut}}$ 进行适当的变换，将推导出的渐近模型重构成一个线性回归问题，从而实现对 $E_\\infty$ 的估计器。\n- 通过使用自助重采样（bootstrap resampling）来估计每个测试用例中 $E_\\infty$ 估计量的变异性，以测试其鲁棒性。尽管自助重采样的变异性无需打印，但算法应在内部计算它，并能够评估估计是否稳定。\n- 作为最终输出，生成每个测试用例的估计 $E_\\infty$ 值，格式为一个用方括号括起来的逗号分隔列表。最终值以电子伏特（eV）表示，并四舍五入到六位小数。\n\n使用以下测试套件，其中每个测试用例提供一个截断能 $E_{\\mathrm{cut}}$（单位 eV）列表和相应的测量总能量 $E$（单位 eV）列表。测量值包含小的、符合实际的噪声。你的程序应为每种情况计算 $E_\\infty$ 的估计值。\n\n测试用例1（一般良态情况）：\n- $E_{\\mathrm{cut}}$: $[20.0, 30.0, 40.0, 60.0, 80.0]$ eV\n- $E$: $[-9.943298301, -9.970671, -9.979738, -9.989541, -9.992012]$ eV\n\n测试用例2（低截断能和少量数据点的边界情况）：\n- $E_{\\mathrm{cut}}$: $[10.0, 12.0, 15.0]$ eV\n- $E$: $[-7.2430178, -7.310502, -7.360344]$ eV\n\n测试用例3（较高噪声场景）：\n- $E_{\\mathrm{cut}}$: $[20.0, 30.0, 40.0, 60.0]$ eV\n- $E$: $[-3.14204915, -3.2047855, -3.17512, -3.21962]$ eV\n\n测试用例4（高截断能，良好收敛区域）：\n- $E_{\\mathrm{cut}}$: $[100.0, 150.0, 200.0, 400.0, 800.0]$ eV\n- $E$: $[-21.9875, -21.993867, -21.995556, -21.9986, -21.99917]$ eV\n\n科学真实性要求：\n- 渐近模型的论证必须从倒易空间截断 $|\\mathbf{G}| \\leq G_{\\mathrm{c}}$、平面波动能关系 $E_{\\mathrm{cut}} = \\hbar^2 G_{\\mathrm{c}}^2 / (2m)$、倒易空间态密度标度 $\\propto G^2$ 以及用于因排除分量而产生的能量校正的二阶 Rayleigh-Schrödinger 微扰理论出发。\n- 必须引用局域赝势傅里叶分量 $\\tilde{V}(\\mathbf{G})$ 在大 $|\\mathbf{G}|$ 时的衰减行为来确定渐近模型中的指数。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含四个测试用例的估计 $E_\\infty$ 值，格式为方括号括起来的逗号分隔列表，例如 $[e_1,e_2,e_3,e_4]$，其中每个 $e_i$ 是一个以 eV 为单位、四舍五入到六位小数的浮点数。",
            "solution": "该问题要求推导一个关于周期性固体的总能量随平面波动能截断能 $E_{\\mathrm{cut}}$ 变化的渐近模型，并实现一种算法来估计完备基组极限能量 $E_\\infty$。\n\n**第一部分：渐近能量模型的推导**\n\n使用有限平面波基组计算的总能量 $E(E_{\\mathrm{cut}})$ 是对完备基组极限下真实基态能量 $E_\\infty$ 的近似。该基组包含所有倒易矢量为 $\\mathbf{G}$ 的平面波，其动能小于或等于截断能 $E_{\\mathrm{cut}}$。此条件表示为 $\\frac{\\hbar^2 |\\mathbf{G}|^2}{2m} \\leq E_{\\mathrm{cut}}$，这在倒易空间中定义了一个半径为 $G_{\\mathrm{c}} = \\sqrt{2mE_{\\mathrm{cut}}/\\hbar^2}$ 的球体。总能量的误差 $\\Delta E = E(E_{\\mathrm{cut}}) - E_\\infty$ 源于排除了 $|\\mathbf{G}| > G_{\\mathrm{c}}$ 的平面波。\n\n我们可以使用二阶 Rayleigh-Schrödinger 微扰理论来估计这个误差。未受微扰的系统是在有限基组（$|\\mathbf{G}| \\leq G_{\\mathrm{c}}$ 的平面波）内求解的系统，而微扰是哈密顿量中将此基组内的占据电子态与被排除的高能平面波态耦合的部分。由于与被排除态集合 $\\{|\\phi_m\\rangle\\}$ 的耦合，单个占据态 $|\\psi_n\\rangle$ 的二阶能量校正为：\n$$ \\Delta E_n^{(2)} = \\sum_{m, \\text{excluded}} \\frac{|\\langle \\psi_n | \\hat{V} | \\phi_m \\rangle|^2}{\\epsilon_n - \\epsilon_m} $$\n其中 $\\hat{V}$ 是赝势算符，$\\epsilon_n$、$\\epsilon_m$ 分别是相应态的能量。根据变分原理，该校正必然为负，意味着 $E(E_{\\mathrm{cut}}) \\ge E_\\infty$。\n\n总能量误差 $\\Delta E$ 是对所有占据态的这些校正的总和。对于大的 $|\\mathbf{G}|$，我们可以做几项简化：\n1.  被排除的态 $|\\phi_m\\rangle$ 可以近似为纯平面波 $|\\mathbf{k} + \\mathbf{G}'\\rangle$，其中 $|\\mathbf{G}'| > G_{\\mathrm{c}}$。\n2.  能量分母 $\\epsilon_n - \\epsilon_m$ 主要由被排除态的大动能决定，因此 $\\epsilon_n - \\epsilon_m \\approx -\\frac{\\hbar^2 |\\mathbf{G}'|^2}{2m}$。\n3.  矩阵元 $\\langle \\psi_n | \\hat{V} | \\mathbf{k} + \\mathbf{G}' \\rangle$ 涉及势的傅里叶分量 $\\tilde{V}(\\mathbf{G})$。对于局域赝势，此矩阵元对于某个大的 $\\mathbf{G''}$ 变得与 $\\tilde{V}(\\mathbf{G''})$ 成正比。\n\n对所有被排除的态 $|\\mathbf{G}'|>G_{\\mathrm{c}}$ 和所有占据能带求和，总误差变为：\n$$ \\Delta E \\approx \\sum_{|\\mathbf{G}'| > G_{\\mathrm{c}}} C \\frac{|\\tilde{V}(\\mathbf{G}')|^2}{\\frac{\\hbar^2 |\\mathbf{G}'|^2}{2m}} $$\n其中 $C$ 是一个有效常数，它合并了对占据态求和所产生的所有因子。\n\n为了计算这个和，我们将其近似为在倒易空间中对 $G = |\\mathbf{G}'| > G_{\\mathrm{c}}$ 的积分。在半径为 $G$、厚度为 $dG$ 的球壳中的倒易格点数与该球壳的体积成正比，在三维空间中为 $4\\pi G^2 dG$。这就是倒易空间中的态密度。\n$$ \\Delta E \\approx \\int_{G_{\\mathrm{c}}}^{\\infty} C' \\frac{|\\tilde{V}(G)|^2}{\\frac{\\hbar^2 G^2}{2m}} (4\\pi G^2) dG $$\n来自能量分母和态密度的 $G^2$ 项相互抵消，从而显著简化了表达式：\n$$ \\Delta E \\approx \\int_{G_{\\mathrm{c}}}^{\\infty} C'' |\\tilde{V}(G)|^2 dG $$\n此积分的行为由赝势傅里叶分量 $\\tilde{V}(G)$ 的渐近衰减决定。对于一个设计得平滑但在长程仍保留类库仑行为的局域赝势，其傅里叶分量衰减为 $\\tilde{V}(G) \\sim 1/G^2$。这是相应实空间库仑势 $1/r$ 中奇点所导致的结果。因此，我们有 $|\\tilde{V}(G)|^2 \\sim G^{-4}$。\n将此依赖关系代入积分：\n$$ \\Delta E \\approx \\int_{G_{\\mathrm{c}}}^{\\infty} C''' G^{-4} dG = C''' \\left[ \\frac{G^{-3}}{-3} \\right]_{G_{\\mathrm{c}}}^{\\infty} = C''' \\left( 0 - \\frac{G_{\\mathrm{c}}^{-3}}{-3} \\right) = A' G_{\\mathrm{c}}^{-3} $$\n其中 $A'$ 是一个正常数。因此，主阶误差项为 $\\Delta E \\propto G_{\\mathrm{c}}^{-3}$。\n\n最后，我们使用给定的定义 $E_{\\mathrm{cut}} = \\frac{\\hbar^2 G_{\\mathrm{c}}^2}{2m}$ 将截断半径 $G_{\\mathrm{c}}$ 与截断能 $E_{\\mathrm{cut}}$ 联系起来。这意味着 $G_{\\mathrm{c}} \\propto E_{\\mathrm{cut}}^{1/2}$。将此关系代入我们关于 $\\Delta E$ 的表达式：\n$$ \\Delta E \\propto (E_{\\mathrm{cut}}^{1/2})^{-3} = E_{\\mathrm{cut}}^{-3/2} $$\n因此，我们得到了总能量的渐近模型：\n$$ E(E_{\\mathrm{cut}}) = E_\\infty + \\Delta E = E_\\infty + A \\cdot E_{\\mathrm{cut}}^{-3/2} $$\n其中 $A$ 是一个正振幅常数。推导出的指数为 $-3/2$。\n\n**第二部分：估计 $E_\\infty$ 的算法**\n\n推导出的模型 $E(E_{\\mathrm{cut}}) = E_\\infty + A \\cdot E_{\\mathrm{cut}}^{-3/2}$ 可以转换为一个线性方程。令因变量为 $y = E(E_{\\mathrm{cut}})$，并定义一个新的自变量 $x = E_{\\mathrm{cut}}^{-3/2}$。模型变为：\n$$ y = E_\\infty + A \\cdot x $$\n这是一个直线方程 $y = mx + c$，其斜率为 $m = A$，y 轴截距为 $c = E_\\infty$。\n\n给定一组 $N$ 个带噪声的测量值 $(E_{\\mathrm{cut},i}, E_i)$，我们可以通过对变换后的数据点 $(x_i, y_i)$（其中 $x_i = E_{\\mathrm{cut},i}^{-3/2}$，$y_i = E_i$）进行线性最小二乘回归来估计 $E_\\infty$。目标是找到参数 $(E_\\infty, A)$ 以最小化残差平方和 $\\sum_{i=1}^{N} [y_i - (E_\\infty + A \\cdot x_i)]^2$。\n\n这是一个标准的线性代数问题，可以表示为矩阵形式 $\\mathbf{M}\\mathbf{p} \\approx \\mathbf{y}$，其中：\n$$ \\mathbf{M} = \\begin{pmatrix} 1  x_1 \\\\ 1  x_2 \\\\ \\vdots  \\vdots \\\\ 1  x_N \\end{pmatrix}, \\quad \\mathbf{p} = \\begin{pmatrix} E_\\infty \\\\ A \\end{pmatrix}, \\quad \\mathbf{y} = \\begin{pmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_N \\end{pmatrix} $$\n参数矢量 $\\mathbf{p}$ 的最小二乘解可以使用数值库（如 `numpy.linalg.lstsq`）稳健地求得。所得解矢量 $\\mathbf{p}$ 的第一个分量将是我们对 $E_\\infty$ 的估计。\n\n问题要求使用自助重采样（bootstrap resampling）来测试鲁棒性。这包括从原始数据集中重复进行有放回的抽样，对每个样本执行线性拟合，并分析所得 $E_\\infty$ 估计值的分布。一个窄的分布表明估计是稳定且鲁棒的。所提出的算法结构便于此操作：核心逻辑被封装在一个函数中，该函数可以轻松应用于这类重采样数据集。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required for this solution.\n\ndef estimate_e_inf(e_cut_values: np.ndarray, e_total_values: np.ndarray) -> float:\n    \"\"\"\n    Estimates the complete basis set limit energy (E_inf) by fitting the data\n    to the asymptotic model E(E_cut) = E_inf + A * E_cut^(-3/2).\n\n    The model is recast as a linear equation y = c + m*x, where y = E_total,\n    x = E_cut^(-3/2), the intercept c = E_inf, and the slope m = A.\n    Linear least-squares fitting is used to find the intercept.\n\n    Args:\n        e_cut_values: A NumPy array of kinetic energy cutoffs in eV.\n        e_total_values: A NumPy array of corresponding total energies in eV.\n\n    Returns:\n        The estimated complete basis set limit energy E_inf in eV.\n    \"\"\"\n    if len(e_cut_values) < 2:\n        raise ValueError(\"At least two data points are required for a linear fit.\")\n\n    # The exponent is derived from first-principles as -3/2.\n    exponent = -3.0 / 2.0\n    \n    # Transform the independent variable according to the derived model.\n    # x = E_cut^(-3/2)\n    transformed_x = e_cut_values ** exponent\n\n    # Set up the design matrix M for the linear system Mp = y, where\n    # p = [E_inf, A]^T. The first column corresponds to the intercept (E_inf),\n    # and the second to the slope (A).\n    # M = [[1, x_1], [1, x_2], ...]\n    M = np.c_[np.ones_like(transformed_x), transformed_x]\n\n    # The dependent variable y is the total energy.\n    y = e_total_values\n\n    # Solve the linear least-squares problem for p = [E_inf, A].\n    # `linalg.lstsq` provides a numerically stable way to solve this.\n    # rcond=None ensures the default behavior for matrix rank determination.\n    p, residuals, rank, s = np.linalg.lstsq(M, y, rcond=None)\n\n    # The estimated E_inf is the first parameter (the intercept).\n    e_inf_estimate = p[0]\n    \n    # Note on robustness: To perform bootstrap resampling as mentioned in the\n    # problem description, one would repeatedly call this function.\n    # For each bootstrap iteration, a new sample of (e_cut, e_total) pairs\n    # would be drawn with replacement from the original data, and\n    # estimate_e_inf would be called on that sample. The standard deviation\n    # of the resulting e_inf_estimate values would quantify the estimator's\n    # variability and stability. This structure makes such an analysis straightforward.\n\n    return e_inf_estimate\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis on all test cases provided in the problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"E_cut\": [20.0, 30.0, 40.0, 60.0, 80.0],\n            \"E\": [-9.943298301, -9.970671, -9.979738, -9.989541, -9.992012],\n        },\n        {\n            \"E_cut\": [10.0, 12.0, 15.0],\n            \"E\": [-7.2430178, -7.310502, -7.360344],\n        },\n        {\n            \"E_cut\": [20.0, 30.0, 40.0, 60.0],\n            \"E\": [-3.14204915, -3.2047855, -3.17512, -3.21962],\n        },\n        {\n            \"E_cut\": [100.0, 150.0, 200.0, 400.0, 800.0],\n            \"E\": [-21.9875, -21.993867, -21.995556, -21.9986, -21.99917],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        e_cut = np.array(case[\"E_cut\"])\n        e_total = np.array(case[\"E\"])\n        \n        e_inf = estimate_e_inf(e_cut, e_total)\n        \n        # Round to six decimal places as required for the final output.\n        results.append(f\"{e_inf:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}