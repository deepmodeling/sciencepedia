{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any plane-wave calculation is the basis set itself, which is defined by a kinetic energy cutoff, $E_{\\mathrm{cut}}$. This first exercise provides direct, hands-on experience with this fundamental concept by tasking you with generating the explicit list of reciprocal lattice vectors, $\\mathbf{G}$, that constitute the basis for a given simulation cell and energy cutoff . By implementing this procedure, you will gain a concrete understanding of how the real-space lattice parameters and the chosen $E_{\\mathrm{cut}}$ directly determine the size and structure of your computational basis.",
            "id": "3833123",
            "problem": "Consider an orthorhombic periodic simulation cell with side lengths $(L_x,L_y,L_z)$, where the plane-wave basis is indexed by reciprocal lattice vectors $\\mathbf{G} = \\left(G_x,G_y,G_z\\right)$ associated with integer triplets $(n_x,n_y,n_z)\\in\\mathbb{Z}^3$ via the reciprocal-space definition $G_i = \\frac{2\\pi n_i}{L_i}$ for each Cartesian direction $i\\in\\{x,y,z\\}$. Under Born–von Karman periodic boundary conditions, plane waves $\\exp\\left(i\\,\\mathbf{G}\\cdot \\mathbf{r}\\right)$ are eigenfunctions of the kinetic-energy operator $-\\frac{\\hbar^2}{2m}\\nabla^2$ for a free electron of mass $m$, with eigenvalues depending on $|\\mathbf{G}|^2$, where $\\hbar$ is the reduced Planck constant. The kinetic energy increases monotonically with $|\\mathbf{G}|^2$ and defines a natural ordering of basis functions by increasing kinetic energy.\n\nTask: For each specified test case, generate the complete set of integer triplets $(n_x,n_y,n_z)$ such that the corresponding plane-wave kinetic energy at the $\\Gamma$-point (i.e., with the crystal wavevector $\\mathbf{k}=\\mathbf{0}$) does not exceed a given energy cutoff $E_{\\mathrm{cut}}$. Then order the triplets by increasing kinetic energy; for triplets having exactly equal kinetic energy, break ties by lexicographic ordering of $(n_x,n_y,n_z)$ in ascending order. Count how many triplets satisfy the cutoff, and list them in the specified order.\n\nFundamental base for the derivation and implementation consists of the following well-tested facts:\n- The reciprocal vector components satisfy $G_i=\\frac{2\\pi n_i}{L_i}$ for each $i\\in\\{x,y,z\\}$ and $(n_x,n_y,n_z)\\in\\mathbb{Z}^3$.\n- The kinetic-energy operator for a free electron is $-\\frac{\\hbar^2}{2m}\\nabla^2$.\n- Plane waves are eigenfunctions of the Laplacian and their kinetic energy depends on $|\\mathbf{G}|^2$.\n- The ordering by increasing kinetic energy is equivalent to ordering by increasing $|\\mathbf{G}|^2$.\n\nUnits and constants:\n- Use the International System of Units (SI). Cell lengths must be in meters (m), energy cutoffs in Joules (J).\n- Use the electron rest mass $m = 9.1093837015\\times 10^{-31}$ kg and the reduced Planck constant $\\hbar = 1.054571817\\times 10^{-34}$ J·s.\n\nNumerical inclusivity and robustness:\n- A plane wave is included if its computed kinetic energy is less than or equal to $E_{\\mathrm{cut}}$. To avoid floating-point under-inclusion at equality, implement the comparison as $E \\le E_{\\mathrm{cut}}\\,(1+\\delta_{\\mathrm{rel}}) + \\delta_{\\mathrm{abs}}$, with $\\delta_{\\mathrm{rel}}=10^{-12}$ and $\\delta_{\\mathrm{abs}}=10^{-32}$ J.\n\nYour program must, for each test case, return:\n- The integer count of included triplets.\n- The ordered list of all included triplets as a list of lists $[n_x,n_y,n_z]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is of the form $[\\,\\text{count},\\,\\text{ordered\\_triplets}\\,]$.\n\nTest suite (each tuple is $(L_x,L_y,L_z,E_{\\mathrm{cut}})$, with $L$ in meters and $E_{\\mathrm{cut}}$ in Joules):\n- Case A (general isotropic cell): $(L_x,L_y,L_z,E_{\\mathrm{cut}})=\\left(1.0\\times 10^{-9},\\,1.0\\times 10^{-9},\\,1.0\\times 10^{-9},\\,3.0\\times 10^{-19}\\right)$.\n- Case B (boundary cutoff at zero): $(L_x,L_y,L_z,E_{\\mathrm{cut}})=\\left(1.0\\times 10^{-9},\\,1.0\\times 10^{-9},\\,1.0\\times 10^{-9},\\,0\\right)$.\n- Case C (anisotropic cell): $(L_x,L_y,L_z,E_{\\mathrm{cut}})=\\left(1.0\\times 10^{-9},\\,2.0\\times 10^{-9},\\,3.0\\times 10^{-9},\\,1.0\\times 10^{-19}\\right)$.\n- Case D (degenerate shell inclusion at equality): $(L_x,L_y,L_z,E_{\\mathrm{cut}})=\\left(1.0\\times 10^{-9},\\,1.0\\times 10^{-9},\\,1.0\\times 10^{-9},\\,4.820\\times 10^{-19}\\right)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example: $[[\\text{count}_A,\\text{list}_A],[\\text{count}_B,\\text{list}_B],[\\text{count}_C,\\text{list}_C],[\\text{count}_D,\\text{list}_D]]$.",
            "solution": "The problem is valid. It is scientifically grounded in the principles of quantum mechanics as applied to periodic systems, a cornerstone of computational materials science. The problem is well-posed, providing all necessary physical constants, mathematical definitions, and numerical tolerances to determine a unique, verifiable solution. The language is objective and the requirements are unambiguous.\n\nThe primary objective is to identify the set of plane-wave basis functions, indexed by integer triplets $(n_x, n_y, n_z)$, that satisfy a given kinetic energy cutoff, $E_{\\mathrm{cut}}$. The basis functions are considered at the $\\Gamma$-point of the Brillouin zone, corresponding to a crystal wavevector $\\mathbf{k}=\\mathbf{0}$.\n\nFirst, we establish the relationship between the kinetic energy of a plane wave and its corresponding integer triplet. The time-independent Schrödinger equation for a free electron of mass $m$ is governed by the kinetic-energy operator $\\hat{T} = -\\frac{\\hbar^2}{2m}\\nabla^2$. The plane waves, given as $\\psi_{\\mathbf{G}}(\\mathbf{r}) \\propto \\exp(i\\,\\mathbf{G}\\cdot \\mathbf{r})$, are eigenfunctions of this operator. Here, $\\mathbf{G}$ is a reciprocal lattice vector. Applying the operator yields:\n$$\n\\hat{T} \\psi_{\\mathbf{G}}(\\mathbf{r}) = -\\frac{\\hbar^2}{2m}\\nabla^2 \\exp(i\\,\\mathbf{G}\\cdot \\mathbf{r}) = -\\frac{\\hbar^2}{2m}}(i\\mathbf{G})\\cdot(i\\mathbf{G}) \\exp(i\\,\\mathbf{G}\\cdot \\mathbf{r}) = \\frac{\\hbar^2|\\mathbf{G}|^2}{2m} \\exp(i\\,\\mathbf{G}\\cdot \\mathbf{r})\n$$\nThe kinetic energy eigenvalue $E_{\\mathbf{G}}$ is therefore:\n$$\nE_{\\mathbf{G}} = \\frac{\\hbar^2|\\mathbf{G}|^2}{2m}\n$$\nFor an orthorhombic simulation cell with side lengths $(L_x, L_y, L_z)$, the components of the reciprocal lattice vector $\\mathbf{G} = (G_x, G_y, G_z)$ are defined in terms of the integer triplet $(n_x, n_y, n_z) \\in \\mathbb{Z}^3$ as $G_i = \\frac{2\\pi n_i}{L_i}$ for $i \\in \\{x, y, z\\}$. The squared magnitude $|\\mathbf{G}|^2$ is:\n$$\n|\\mathbf{G}|^2 = G_x^2 + G_y^2 + G_z^2 = \\left(\\frac{2\\pi n_x}{L_x}\\right)^2 + \\left(\\frac{2\\pi n_y}{L_y}\\right)^2 + \\left(\\frac{2\\pi n_z}{L_z}\\right)^2 = 4\\pi^2 \\left(\\frac{n_x^2}{L_x^2} + \\frac{n_y^2}{L_y^2} + \\frac{n_z^2}{L_z^2}\\right)\n$$\nSubstituting this into the energy eigenvalue expression gives the kinetic energy $E_{n_x,n_y,n_z}$ for a specific triplet:\n$$\nE_{n_x,n_y,n_z} = \\frac{\\hbar^2}{2m} \\left[ 4\\pi^2 \\left(\\frac{n_x^2}{L_x^2} + \\frac{n_y^2}{L_y^2} + \\frac{n_z^2}{L_z^2}\\right) \\right] = \\frac{2\\pi^2\\hbar^2}{m} \\left(\\frac{n_x^2}{L_x^2} + \\frac{n_y^2}{L_y^2} + \\frac{n_z^2}{L_z^2}\\right)\n$$\nThe task is to find all integer triplets $(n_x, n_y, n_z)$ such that $E_{n_x,n_y,n_z} \\le E_{\\mathrm{cut}}$. To handle floating-point precision at the boundary, this condition is implemented using a tolerance:\n$$\nE_{n_x,n_y,n_z} \\le E_{\\mathrm{cut,eff}} \\quad \\text{where} \\quad E_{\\mathrm{cut,eff}} = E_{\\mathrm{cut}}(1 + \\delta_{\\mathrm{rel}}) + \\delta_{\\mathrm{abs}}\n$$\nwith $\\delta_{\\mathrm{rel}}=10^{-12}$ and $\\delta_{\\mathrm{abs}}=10^{-32}$ J.\n\nThe algorithmic procedure to solve the problem for each test case is as follows:\n$1$. **Initialization**: For a given test case $(L_x, L_y, L_z, E_{\\mathrm{cut}})$, the effective energy cutoff $E_{\\mathrm{cut,eff}}$ is computed. The constant prefactor $C_{\\text{factor}} = \\frac{2\\pi^2\\hbar^2}{m}$ is also calculated. The condition for including a triplet becomes:\n$$\n\\frac{n_x^2}{L_x^2} + \\frac{n_y^2}{L_y^2} + \\frac{n_z^2}{L_z^2} \\le \\frac{E_{\\mathrm{cut,eff}}}{C_{\\text{factor}}}\n$$\nThis inequality describes an ellipsoid in $(n_x, n_y, n_z)$ space, which bounds the search for valid integer triplets.\n\n$2$. **Ellipsoidal Search**: An efficient search is conducted by iterating through nested loops whose bounds are dynamically constrained by the ellipsoidal condition. This avoids searching a much larger rectangular volume.\n- The maximum possible value for $|n_x|$ is found by setting $n_y=0$ and $n_z=0$: $n_{x,\\max} = \\lfloor L_x \\sqrt{E_{\\mathrm{cut,eff}} / C_{\\text{factor}}} \\rfloor$. We iterate $n_x$ from $-n_{x,\\max}$ to $n_{x,\\max}$.\n- For each $n_x$, the maximum possible value for $|n_y|$ is found by setting $n_z=0$: $n_{y,\\max}(n_x) = \\lfloor L_y \\sqrt{E_{\\mathrm{cut,eff}}/C_{\\text{factor}} - n_x^2/L_x^2} \\rfloor$. We iterate $n_y$ from $-n_{y,\\max}(n_x)$ to $n_{y,\\max}(n_x)$.\n- For each pair $(n_x, n_y)$, the maximum possible value for $|n_z|$ is: $n_{z,\\max}(n_x, n_y) = \\lfloor L_z \\sqrt{E_{\\mathrm{cut,eff}}/C_{\\text{factor}} - n_x^2/L_x^2 - n_y^2/L_y^2} \\rfloor$. We iterate $n_z$ from $-n_{z,\\max}(n_x, n_y)$ to $n_{z,\\max}(n_x, n_y)$.\nEvery triplet $(n_x, n_y, n_z)$ generated by this procedure is guaranteed to satisfy the energy cutoff condition. These valid triplets are collected.\n\n$3$. **Sorting**: The collected triplets must be sorted according to the specified criteria.\n- **Primary key**: The exact kinetic energy $E_{n_x,n_y,n_z}$ (calculated without the tolerance factors), in ascending order.\n- **Secondary key**: For triplets with degenerate (identical) energies, a tie is broken by sorting them in ascending lexicographical order of $(n_x, n_y, n_z)$.\nThis is achieved by creating a list of tuples of the form $(E_{n_x,n_y,n_z}, n_x, n_y, n_z)$ for each valid triplet and then performing a standard sort on this list.\n\n$4$. **Finalization**: After sorting, the ordered list of triplets is extracted. The final result for the test case consists of the total count of the valid triplets and the ordered list of these triplets. This process is repeated for all test cases provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the plane-wave basis set problem for a suite of test cases.\n    For each case, it finds all integer triplets (nx, ny, nz) whose\n    corresponding kinetic energy is below a cutoff, then sorts them\n    by energy and lexicographically.\n    \"\"\"\n\n    # --- Constants and Tolerances ---\n    # Electron rest mass in kg\n    m_e = 9.1093837015e-31\n    # Reduced Planck constant in J·s\n    hbar = 1.054571817e-34\n    # Relative and absolute tolerances for energy comparison\n    delta_rel = 1e-12\n    delta_abs = 1e-32\n\n    # --- Test Suite ---\n    # Each tuple is (Lx, Ly, Lz, E_cut) in SI units (m, J)\n    test_cases = [\n        # Case A (general isotropic cell)\n        (1.0e-9, 1.0e-9, 1.0e-9, 3.0e-19),\n        # Case B (boundary cutoff at zero)\n        (1.0e-9, 1.0e-9, 1.0e-9, 0.0),\n        # Case C (anisotropic cell)\n        (1.0e-9, 2.0e-9, 3.0e-9, 1.0e-19),\n        # Case D (degenerate shell inclusion at equality)\n        (1.0e-9, 1.0e-9, 1.0e-9, 4.820e-19),\n    ]\n\n    # List to store final results for all test cases\n    all_results = []\n\n    # --- Main Logic ---\n    # Pre-calculate the constant factor in the energy equation\n    C_factor = (2 * (np.pi**2) * (hbar**2)) / m_e\n\n    for case in test_cases:\n        Lx, Ly, Lz, E_cut = case\n\n        # Apply numerical tolerance to the energy cutoff\n        E_cut_eff = E_cut * (1 + delta_rel) + delta_abs\n        \n        # A list to store tuples of (energy, nx, ny, nz) for sorting\n        found_triplets_with_energy = []\n        \n        # Handle the E_cut < 0 case explicitly to avoid sqrt of negative\n        if E_cut_eff < 0:\n            all_results.append([0, []])\n            continue\n            \n        # Determine the search range for nx (outermost loop)\n        # We use a try-except block for sqrt(negative) arising from float precision\n        try:\n            nx_max = int(np.floor(Lx * np.sqrt(E_cut_eff / C_factor)))\n        except (ValueError, RuntimeWarning):\n            nx_max = 0\n\n        # Efficiently search the ellipsoid of valid (nx, ny, nz) triplets\n        for nx in range(-nx_max, nx_max + 1):\n            E_rem_y = E_cut_eff - C_factor * ((nx / Lx)**2)\n            if E_rem_y < 0:\n                continue\n            \n            try:\n                ny_max = int(np.floor(Ly * np.sqrt(E_rem_y / C_factor)))\n            except (ValueError, RuntimeWarning):\n                ny_max = 0\n\n            for ny in range(-ny_max, ny_max + 1):\n                E_rem_z = E_cut_eff - C_factor * (((nx / Lx)**2) + ((ny / Ly)**2))\n                if E_rem_z < 0:\n                    continue\n\n                try:\n                    nz_max = int(np.floor(Lz * np.sqrt(E_rem_z / C_factor)))\n                except (ValueError, RuntimeWarning):\n                    nz_max = 0\n                \n                for nz in range(-nz_max, nz_max + 1):\n                    # For a valid triplet, calculate its precise energy for sorting\n                    energy = C_factor * (((nx / Lx)**2) + ((ny / Ly)**2) + ((nz / Lz)**2))\n                    # The search guarantees energy <= E_cut_eff. No re-check needed.\n                    found_triplets_with_energy.append((energy, nx, ny, nz))\n        \n        # Sort the results: primary key is energy, secondary is lexicographical (nx,ny,nz)\n        found_triplets_with_energy.sort(key=lambda item: (item[0], item[1], item[2], item[3]))\n        \n        # Extract the sorted triplets, discarding the energy values\n        sorted_triplets = [[t[1], t[2], t[3]] for t in found_triplets_with_energy]\n        \n        # Get the count of found triplets\n        count = len(sorted_triplets)\n        \n        # Append the result for the current case to the main results list\n        all_results.append([count, sorted_triplets])\n\n    # Format the final output string exactly as required, removing all spaces from the string representation\n    # of the list of lists.\n    final_output = str(all_results).replace(\" \", \"\")\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from constructing a basis to using it, this practice simulates one of the most critical workflows in computational materials science: the convergence study. Using a simplified but physically meaningful model, you will calculate the electronic band gap of a crystal and systematically investigate how the result depends on the two most important numerical parameters: the plane-wave energy cutoff, $E_{\\mathrm{cut}}$, and the density of the k-point sampling mesh . This exercise is essential for learning how to produce reliable and reproducible simulation results.",
            "id": "2460283",
            "problem": "You are asked to study the convergence of the indirect band gap of crystalline silicon with respect to the plane-wave kinetic energy cutoff and the density of the crystal momentum sampling mesh. For computational tractability while retaining key physics of a plane-wave basis and Bragg scattering, use a simplified three-dimensional nearly-free-electron model with a cosine periodic potential on a simple cubic Bravais lattice, which captures an indirect gap via coupling at the Brillouin zone boundary. The task is to implement a complete program that constructs the single-electron Hamiltonian in a plane-wave basis at each crystal momentum point, diagonalizes it to obtain the lowest two energy bands, and estimates the indirect band gap as the difference between the minimum of the second band and the maximum of the first band across sampled crystal momentum points. All energies must be reported in electronvolts, and all lengths in angstroms.\n\nDefinitions and model:\n- Let the lattice parameter be $a = 5.43\\,\\text{\\AA}$. The reciprocal lattice primitive vectors are $\\mathbf{b}_1 = \\frac{2\\pi}{a}\\hat{\\mathbf{x}}$, $\\mathbf{b}_2 = \\frac{2\\pi}{a}\\hat{\\mathbf{y}}$, and $\\mathbf{b}_3 = \\frac{2\\pi}{a}\\hat{\\mathbf{z}}$. The first Brillouin zone is the cube $k_i \\in [-\\pi/a,\\pi/a)$ for $i \\in \\{x,y,z\\}$.\n- The electron kinetic energy is $T(\\mathbf{q}) = \\frac{\\hbar^2 |\\mathbf{q}|^2}{2 m_e}$ with $\\frac{\\hbar^2}{2m_e} = 3.8099819442818976\\,\\text{eV}\\cdot\\text{\\AA}^2$.\n- The periodic potential is $V(\\mathbf{r}) = 2 V_c \\left[\\cos\\left(\\mathbf{b}_1 \\cdot \\mathbf{r}\\right) + \\cos\\left(\\mathbf{b}_2 \\cdot \\mathbf{r}\\right) + \\cos\\left(\\mathbf{b}_3 \\cdot \\mathbf{r}\\right)\\right]$, with Fourier coefficients $V_{\\pm \\mathbf{b}_1} = V_{\\pm \\mathbf{b}_2} = V_{\\pm \\mathbf{b}_3} = V_c$ and all other Fourier coefficients equal to zero. Use $V_c = -1.25\\,\\text{eV}$. The unit-cell average of $V(\\mathbf{r})$ is zero.\n- For each crystal momentum $\\mathbf{k}$, the plane-wave basis consists of the set of states indexed by integer triples $\\mathbf{n} = (n_x,n_y,n_z)$ with wavevectors $\\mathbf{q}_{\\mathbf{n}}(\\mathbf{k}) = \\mathbf{k} + n_x \\mathbf{b}_1 + n_y \\mathbf{b}_2 + n_z \\mathbf{b}_3$ that satisfy the kinetic energy cutoff condition $T\\left(\\mathbf{q}_{\\mathbf{n}}(\\mathbf{k})\\right) \\le E_{\\text{cut}}$, where $E_{\\text{cut}}$ is a positive parameter in electronvolts. The Hamiltonian in this basis has matrix elements\n$$\nH_{\\mathbf{n},\\mathbf{m}}(\\mathbf{k}) =\n\\begin{cases}\nT\\left(\\mathbf{q}_{\\mathbf{n}}(\\mathbf{k})\\right), & \\text{if } \\mathbf{n} = \\mathbf{m},\\\\\nV_c, & \\text{if } \\mathbf{n} - \\mathbf{m} \\in \\{\\pm(1,0,0), \\pm(0,1,0), \\pm(0,0,1)\\},\\\\\n0, & \\text{otherwise.}\n\\end{cases}\n$$\n\nCrystal momentum sampling:\n- For an integer $N_k \\ge 1$, sample the first Brillouin zone on a uniform grid with $N_k$ points per Cartesian direction at\n$$\nk_i(j) = -\\frac{\\pi}{a} + \\frac{2\\pi}{a}\\,\\frac{j}{N_k}, \\quad j \\in \\{0,1,\\dots,N_k-1\\}, \\quad i \\in \\{x,y,z\\}.\n$$\nThis yields $N_k^3$ points $\\mathbf{k}$ to evaluate. For each such $\\mathbf{k}$, construct $H(\\mathbf{k})$ using the basis defined by the cutoff.\n\nBand edges and gap:\n- For each $\\mathbf{k}$ where the basis contains at least one plane wave, let $E_1(\\mathbf{k}) \\le E_2(\\mathbf{k}) \\le \\dots$ be the ascending eigenvalues of $H(\\mathbf{k})$. Across the set of $\\mathbf{k}$ points where at least one eigenvalue exists, define the valence band maximum as $E_v = \\max_{\\mathbf{k}} E_1(\\mathbf{k})$. Across the set of $\\mathbf{k}$ points where at least two eigenvalues exist, define the conduction band minimum as $E_c = \\min_{\\mathbf{k}} E_2(\\mathbf{k})$. The estimated indirect band gap is $E_g = E_c - E_v$ in electronvolts. If no $\\mathbf{k}$ point has at least two eigenvalues, $E_g$ is undefined.\n\nTest suite:\nCompute $E_g$ (in electronvolts) for the following parameter pairs $(E_{\\text{cut}}, N_k)$:\n- Case $1$: $(6.0, 1)$.\n- Case $2$: $(6.0, 4)$.\n- Case $3$: $(8.0, 4)$.\n- Case $4$: $(12.0, 10)$.\n- Case $5$: $(20.0, 12)$.\n\nOutput requirements:\n- Your program must produce a single line of output containing the five results as a comma-separated list enclosed in square brackets, for example $[x_1,x_2,x_3,x_4,x_5]$, with each $x_i$ the floating-point value of $E_g$ in electronvolts for the corresponding case, rounded to $6$ decimal places. If a particular $E_g$ is undefined due to insufficient basis size, output the string representation of a not-a-number value as given by the programming language for that case, but do not change the formatting of the list.",
            "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It is scientifically grounded, well-posed, objective, and contains all necessary information to proceed with a unique and verifiable solution. It represents a standard, albeit simplified, problem in computational solid-state physics, suitable for illustrating the principles of electronic band structure calculation using a plane-wave basis set. We shall now proceed to the solution.\n\nThe fundamental task is to solve the time-independent Schrödinger equation for a single electron in a periodic potential, $\\hat{H}\\psi(\\mathbf{r}) = E\\psi(\\mathbf{r})$, where the Hamiltonian is $\\hat{H} = \\hat{T} + \\hat{V} = -\\frac{\\hbar^2}{2m_e}\\nabla^2 + V(\\mathbf{r})$. The periodicity of the potential, $V(\\mathbf{r}) = V(\\mathbf{r}+\\mathbf{R})$ for any direct lattice vector $\\mathbf{R}$, imposes a specific structure on the eigenstates. According to Bloch's theorem, the solutions can be written in the form $\\psi_{\\mathbf{k}}(\\mathbf{r}) = e^{i\\mathbf{k}\\cdot\\mathbf{r}}u_{\\mathbf{k}}(\\mathbf{r})$, where $\\mathbf{k}$ is a crystal momentum vector in the first Brillouin zone and $u_{\\mathbf{k}}(\\mathbf{r})$ is a cell-periodic function, $u_{\\mathbf{k}}(\\mathbf{r}) = u_{\\mathbf{k}}(\\mathbf{r}+\\mathbf{R})$.\n\nGiven that $u_{\\mathbf{k}}(\\mathbf{r})$ is periodic, it can be expanded in a Fourier series over the reciprocal lattice vectors $\\mathbf{G}$: $u_{\\mathbf{k}}(\\mathbf{r}) = \\sum_{\\mathbf{G}} c_{\\mathbf{k}}(\\mathbf{G}) e^{i\\mathbf{G}\\cdot\\mathbf{r}}$. Substituting this into the Bloch form for the wavefunction gives the plane-wave expansion:\n$$\n\\psi_{\\mathbf{k}}(\\mathbf{r}) = \\sum_{\\mathbf{G}} c_{\\mathbf{k}}(\\mathbf{G}) e^{i(\\mathbf{k}+\\mathbf{G})\\cdot\\mathbf{r}}\n$$\nInserting this expansion into the Schrödinger equation transforms it into an infinite-dimensional matrix eigenvalue problem for the coefficients $c_{\\mathbf{k}}(\\mathbf{G})$ for each $\\mathbf{k}$. The matrix elements of the Hamiltonian in this plane-wave basis $|\\mathbf{k}+\\mathbf{G}\\rangle$ are given by $H_{\\mathbf{G},\\mathbf{G}'}(\\mathbf{k}) = \\langle \\mathbf{k}+\\mathbf{G} | \\hat{H} | \\mathbf{k}+\\mathbf{G}' \\rangle$.\n\nThe kinetic energy operator $\\hat{T}$ is diagonal in this basis:\n$$\n\\langle \\mathbf{k}+\\mathbf{G} | \\hat{T} | \\mathbf{k}+\\mathbf{G}' \\rangle = \\frac{\\hbar^2 |\\mathbf{k}+\\mathbf{G}|^2}{2m_e} \\delta_{\\mathbf{G},\\mathbf{G}'}\n$$\nThe potential energy operator $\\hat{V}$ has matrix elements determined by the Fourier coefficients of the potential, $V(\\mathbf{r}) = \\sum_{\\mathbf{G}} V_{\\mathbf{G}} e^{i\\mathbf{G}\\cdot\\mathbf{r}}$:\n$$\n\\langle \\mathbf{k}+\\mathbf{G} | \\hat{V} | \\mathbf{k}+\\mathbf{G}' \\rangle = V_{\\mathbf{G}-\\mathbf{G}'}\n$$\nCombining these, the full Hamiltonian matrix elements are:\n$$\nH_{\\mathbf{G},\\mathbf{G}'}(\\mathbf{k}) = \\frac{\\hbar^2 |\\mathbf{k}+\\mathbf{G}|^2}{2m_e} \\delta_{\\mathbf{G},\\mathbf{G}'} + V_{\\mathbf{G}-\\mathbf{G}'}\n$$\nThe problem specifies a simple cubic Bravais lattice with lattice parameter $a = 5.43\\,\\text{\\AA}$. The reciprocal lattice is also simple cubic, with primitive vectors $\\mathbf{b}_1 = \\frac{2\\pi}{a}\\hat{\\mathbf{x}}$, $\\mathbf{b}_2 = \\frac{2\\pi}{a}\\hat{\\mathbf{y}}$, and $\\mathbf{b}_3 = \\frac{2\\pi}{a}\\hat{\\mathbf{z}}$. A general reciprocal lattice vector is $\\mathbf{G}_{\\mathbf{n}} = n_x \\mathbf{b}_1 + n_y \\mathbf{b}_2 + n_z \\mathbf{b}_3$ for an integer vector $\\mathbf{n} = (n_x, n_y, n_z)$.\n\nThe periodic potential is $V(\\mathbf{r}) = 2 V_c \\left[\\cos\\left(\\mathbf{b}_1 \\cdot \\mathbf{r}\\right) + \\cos\\left(\\mathbf{b}_2 \\cdot \\mathbf{r}\\right) + \\cos\\left(\\mathbf{b}_3 \\cdot \\mathbf{r}\\right)\\right]$. Using Euler's formula, $\\cos(x) = (e^{ix}+e^{-ix})/2$, we identify its non-zero Fourier coefficients as $V_{\\mathbf{G}} = V_c$ for $\\mathbf{G} \\in \\{\\pm\\mathbf{b}_1, \\pm\\mathbf{b}_2, \\pm\\mathbf{b}_3\\}$ and $V_{\\mathbf{G}} = 0$ for all other $\\mathbf{G} \\ne 0$. The average potential $V_{\\mathbf{G}=0}$ is zero. This implies that the potential couples a plane wave $|\\mathbf{k}+\\mathbf{G}_{\\mathbf{n}}\\rangle$ only to plane waves $|\\mathbf{k}+\\mathbf{G}_{\\mathbf{m}}\\rangle$ where the difference $\\mathbf{G}_{\\mathbf{n}}-\\mathbf{G}_{\\mathbf{m}}$ is one of the six shortest non-zero reciprocal lattice vectors. This corresponds to the condition that $\\mathbf{n}-\\mathbf{m}$ is one of $\\pm(1,0,0)$, $\\pm(0,1,0)$, or $\\pm(0,0,1)$.\n\nIn a practical computation, the infinite basis must be truncated. This is achieved via a kinetic energy cutoff, $E_{\\text{cut}}$. For each crystal momentum $\\mathbf{k}$, we include in our basis only those plane waves $|\\mathbf{k}+\\mathbf{G}_{\\mathbf{n}}\\rangle$ for which the kinetic energy is below the cutoff:\n$$\nT(\\mathbf{k}+\\mathbf{G}_{\\mathbf{n}}) = \\frac{\\hbar^2 |\\mathbf{k}+\\mathbf{G}_{\\mathbf{n}}|^2}{2m_e} \\le E_{\\text{cut}}\n$$\nThis results in a finite-dimensional, $\\mathbf{k}$-dependent Hamiltonian matrix $H(\\mathbf{k})$, whose elements are precisely those specified in the problem statement. The eigenvalues of this matrix, $E_1(\\mathbf{k}) \\le E_2(\\mathbf{k}) \\le \\dots$, constitute the electronic band structure.\n\nThe computational algorithm is as follows:\n1.  For each given pair of parameters $(E_{\\text{cut}}, N_k)$, initialize the calculation. The required physical constants are $a = 5.43\\,\\text{\\AA}$, $\\frac{\\hbar^2}{2m_e} = 3.8099819442818976\\,\\text{eV}\\cdot\\text{\\AA}^2$, and $V_c = -1.25\\,\\text{eV}$.\n2.  Generate the uniform grid of $N_k^3$ crystal momentum vectors $\\mathbf{k}$ sampling the first Brillouin zone according to the rule $k_i(j) = -\\frac{\\pi}{a} + \\frac{2\\pi}{a}\\,\\frac{j}{N_k}$ for $j=0, \\dots, N_k-1$.\n3.  For each $\\mathbf{k}$ vector in the grid:\n    a. Determine the finite set of integer vectors $\\mathbf{n} = (n_x, n_y, n_z)$ that satisfy the kinetic energy cutoff condition. This is done by searching a sufficiently large cubic range of integers $\\mathbf{n}$ and retaining those that satisfy $T(\\mathbf{k}+\\mathbf{G}_{\\mathbf{n}}) \\le E_{\\text{cut}}$.\n    b. If the basis set is empty, no eigenvalues can be computed for this $\\mathbf{k}$. Proceed to the next $\\mathbf{k}$.\n    c. If the basis is non-empty, construct the Hamiltonian matrix $H(\\mathbf{k})$ of size $N_{basis} \\times N_{basis}$. The diagonal elements are $H_{\\mathbf{n},\\mathbf{n}}(\\mathbf{k}) = T(\\mathbf{k}+\\mathbf{G}_{\\mathbf{n}})$. The off-diagonal element $H_{\\mathbf{n},\\mathbf{m}}(\\mathbf{k})$ is $V_c$ if $\\mathbf{n}-\\mathbf{m}$ is a unit vector in one of the six Cartesian directions, and $0$ otherwise.\n    d. The resulting matrix is Hermitian. Diagonalize it to find its real eigenvalues. The eigenvalues are sorted in ascending order: $E_1(\\mathbf{k}) \\le E_2(\\mathbf{k}) \\le \\dots \\le E_{N_{basis}}(\\mathbf{k})$.\n    e. Collect the first eigenvalue $E_1(\\mathbf{k})$ and, if it exists, the second eigenvalue $E_2(\\mathbf{k})$.\n4.  After iterating through all $\\mathbf{k}$ points, determine the valence band maximum, $E_v = \\max_{\\mathbf{k}} E_1(\\mathbf{k})$, where the maximum is taken over all $\\mathbf{k}$ points that yielded at least one eigenvalue.\n5.  Similarly, determine the conduction band minimum, $E_c = \\min_{\\mathbf{k}} E_2(\\mathbf{k})$, where the minimum is taken over all $\\mathbf{k}$ points that yielded at least two eigenvalues.\n6.  If $E_c$ could not be determined (i.e., no $\\mathbf{k}$ point produced a basis of size two or greater), the band gap $E_g$ is undefined. Otherwise, calculate the indirect band gap as $E_g = E_c - E_v$.\n7.  This procedure is repeated for all five test cases, and the results are reported in the specified format. This systematic process ensures a correct and reproducible numerical solution to the problem as stated.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the indirect band gap of a model crystal using a plane-wave basis.\n    \"\"\"\n    # Physical constants and model parameters\n    A_LATTICE = 5.43  # Lattice parameter in Angstroms\n    HBAR_SQ_2ME = 3.8099819442818976  # h-bar^2 / (2*m_e) in eV * Angstrom^2\n    V_C = -1.25  # Potential strength in eV\n\n    # Reciprocal lattice vector magnitude\n    B_SCALAR = 2 * np.pi / A_LATTICE\n\n    # Test cases: (E_cut in eV, N_k)\n    test_cases = [\n        (6.0, 1),\n        (6.0, 4),\n        (8.0, 4),\n        (12.0, 10),\n        (20.0, 12),\n    ]\n\n    results = []\n    for E_cut, N_k in test_cases:\n        e1_all_k = []\n        e2_all_k = []\n\n        # Generate k-point mesh\n        k_coords_1d = -np.pi / A_LATTICE + (2 * np.pi / A_LATTICE) * np.arange(N_k) / N_k\n        kx_grid, ky_grid, kz_grid = np.meshgrid(k_coords_1d, k_coords_1d, k_coords_1d, indexing='ij')\n        k_points = np.stack([kx_grid.ravel(), ky_grid.ravel(), kz_grid.ravel()], axis=-1)\n\n        # Determine search range for integer vectors n = (nx, ny, nz)\n        # Bounding box must account for k-vector shift.\n        # |k_i| <= pi/a. We need C * (k_i + n_i*B)^2 <= E_cut.\n        # |n_i*B| <= sqrt(E_cut/C) + |k_i| <= sqrt(E_cut/C) + pi/a\n        # |n_i| <= (sqrt(E_cut/C) + pi/a) / B = a/(2pi) * sqrt(E_cut/C) + 1/2\n        n_lim = int(np.ceil((np.sqrt(E_cut / HBAR_SQ_2ME) + np.pi / A_LATTICE) / B_SCALAR))\n        n_range = np.arange(-n_lim, n_lim + 1)\n        nx_v, ny_v, nz_v = np.meshgrid(n_range, n_range, n_range, indexing='ij')\n        n_candidates = np.stack([nx_v.ravel(), ny_v.ravel(), nz_v.ravel()], axis=-1)\n\n        for k_vec in k_points:\n            # Generate basis set for the current k-point\n            G_vectors = n_candidates * B_SCALAR\n            q_vectors = k_vec + G_vectors\n            \n            kinetic_energies = HBAR_SQ_2ME * np.sum(q_vectors**2, axis=-1)\n            \n            basis_indices = np.where(kinetic_energies <= E_cut)[0]\n            \n            if basis_indices.size == 0:\n                continue\n            \n            basis_n_vectors = n_candidates[basis_indices]\n            basis_ke = kinetic_energies[basis_indices]\n            N_basis = len(basis_n_vectors)\n            \n            # Construct Hamiltonian\n            H = np.diag(basis_ke)\n            \n            # Map n-vectors to matrix indices for efficient lookup\n            n_to_idx = {tuple(n): i for i, n in enumerate(basis_n_vectors)}\n            \n            # Off-diagonal elements\n            deltas = np.array([[1,0,0], [-1,0,0], [0,1,0], [0,-1,0], [0,0,1], [0,0,-1]])\n            for i, n_i in enumerate(basis_n_vectors):\n                for delta in deltas:\n                    n_j_tuple = tuple(n_i + delta)\n                    if n_j_tuple in n_to_idx:\n                        j = n_to_idx[n_j_tuple]\n                        # Only fill upper triangle for eigh\n                        if i < j:\n                            H[i, j] = V_C\n                            H[j, i] = V_C\n\n            # Diagonalize and collect eigenvalues\n            if N_basis > 0:\n                # eigvalsh is efficient for Hermitian matrices and returns sorted eigenvalues\n                eigenvalues = np.linalg.eigvalsh(H)\n                e1_all_k.append(eigenvalues[0])\n                if N_basis >= 2:\n                    e2_all_k.append(eigenvalues[1])\n\n        # Calculate band gap for the current (E_cut, N_k) pair\n        if not e2_all_k:\n            Eg = np.nan\n        else:\n            E_v = np.max(e1_all_k)\n            E_c = np.min(e2_all_k)\n            Eg = E_c - E_v\n            \n        results.append(Eg)\n\n    # Format output as specified\n    formatted_results = []\n    for r in results:\n        if np.isnan(r):\n            formatted_results.append(\"nan\")\n        else:\n            formatted_results.append(f\"{r:.6f}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Plane-wave methods rely on pseudopotentials to efficiently model the interaction between valence electrons and ion cores, but how well does a pseudopotential perform across different chemical environments? This advanced practice explores the crucial concept of 'transferability' by quantifying how a pseudopotential's construction affects basis set requirements in varied carbon allotropes . By implementing a simplified model, you will gain insight into the trade-offs between pseudopotential 'hardness' and computational cost, a key consideration in designing robust materials simulations.",
            "id": "2460253",
            "problem": "You are given a simplified, first-principles-inspired model to quantify how a pseudopotential’s smoothing radius affects the plane-wave basis completeness across distinct bonding environments. Consider a norm-conserving carbon pseudopotential characterized by a single smoothing radius $r_{c}$ (in bohr). In a plane-wave basis truncated at kinetic energy cutoff $E_{\\mathrm{cut}}$ (in Hartree), only plane waves with wave vector magnitude $k \\leq k_{\\mathrm{cut}}$ are included, where $k_{\\mathrm{cut}} = \\sqrt{2 E_{\\mathrm{cut}}}$ in atomic units. Assume the spherically averaged Fourier-space probability density of a representative valence pseudo-orbital can be modeled as\n$$\nW(k) \\propto k^{2} \\exp\\!\\left(-\\alpha k^{2}\\right),\n$$\nwith $\\alpha = \\sigma_{\\mathrm{eff}}^{2}$ and $\\sigma_{\\mathrm{eff}} = \\sqrt{\\sigma_{\\mathrm{env}}^{2} + r_{c}^{2}}$. Here $\\sigma_{\\mathrm{env}}$ is a given environment-dependent characteristic real-space width (in bohr) representing the spatial extent of the valence orbital features set by bonding. The fraction of spectral weight missing due to the finite plane-wave cutoff is defined by\n$$\nf_{\\mathrm{miss}}(k_{\\mathrm{cut}}, \\alpha) \\equiv \\frac{\\int_{k_{\\mathrm{cut}}}^{\\infty} k^{2} e^{-\\alpha k^{2}} \\, dk}{\\int_{0}^{\\infty} k^{2} e^{-\\alpha k^{2}} \\, dk},\n$$\nwhich is a dimensionless number in the interval $[0,1]$. For three bonding environments,\n- diamond: $\\sigma_{\\mathrm{env}} = \\sigma_{\\mathrm{dia}} = $ $1.2$ bohr,\n- graphene: $\\sigma_{\\mathrm{env}} = \\sigma_{\\mathrm{gra}} = $ $1.8$ bohr,\n- buckminsterfullerene $\\mathrm{C}_{60}$: $\\sigma_{\\mathrm{env}} = \\sigma_{\\mathrm{c60}} = $ $2.2$ bohr,\ndefine the “transferability dispersion” for a given pair $(r_{c}, E_{\\mathrm{cut}})$ as\n$$\n\\Delta_{\\mathrm{tr}}(r_{c}, E_{\\mathrm{cut}}) \\equiv \\max\\!\\big\\{ f_{\\mathrm{miss}}^{(\\mathrm{dia})}, f_{\\mathrm{miss}}^{(\\mathrm{gra})}, f_{\\mathrm{miss}}^{(\\mathrm{c60})} \\big\\} - \\min\\!\\big\\{ f_{\\mathrm{miss}}^{(\\mathrm{dia})}, f_{\\mathrm{miss}}^{(\\mathrm{gra})}, f_{\\mathrm{miss}}^{(\\mathrm{c60})} \\big\\},\n$$\nwhere $f_{\\mathrm{miss}}^{(\\cdot)}$ is computed using the corresponding $\\sigma_{\\mathrm{env}}$.\n\nTask: Write a program that, for the following test suite of $(r_{c}, E_{\\mathrm{cut}})$ values (all in atomic units: $r_{c}$ in bohr, $E_{\\mathrm{cut}}$ in Hartree),\n- Test $1$: $r_{c} = $ $1.3$, $E_{\\mathrm{cut}} = $ $15.0$,\n- Test $2$: $r_{c} = $ $0.8$, $E_{\\mathrm{cut}} = $ $8.0$,\n- Test $3$: $r_{c} = $ $1.8$, $E_{\\mathrm{cut}} = $ $8.0$,\n- Test $4$: $r_{c} = $ $1.3$, $E_{\\mathrm{cut}} = $ $4.0$,\ncomputes $\\Delta_{\\mathrm{tr}}(r_{c}, E_{\\mathrm{cut}})$ for each test. All quantities are to be handled in atomic units; no conversion factors are needed. The required results are real numbers (dimensionless). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_{1},x_{2},x_{3},x_{4}]$), where $x_{i}$ is $\\Delta_{\\mathrm{tr}}$ for Test $i$ in the same order as listed above.",
            "solution": "The problem as stated is valid. It is scientifically grounded in the principles of solid-state physics and computational chemistry, specifically plane-wave density functional theory. The model, while simplified, uses established concepts such as the kinetic energy cutoff $E_{\\mathrm{cut}}$, its relation to the wave vector cutoff $k_{\\mathrm{cut}}$, and the effect of pseudopotential smoothing on basis set convergence. The problem is mathematically well-posed: all parameters and functions are explicitly defined, the constraints are consistent, and a unique numerical solution exists for each test case. The objective is clear and requires no subjective interpretation. We shall proceed to derive the solution.\n\nThe primary task is to compute the transferability dispersion, $\\Delta_{\\mathrm{tr}}(r_{c}, E_{\\mathrm{cut}})$, which is defined in terms of the fraction of missing spectral weight, $f_{\\mathrm{miss}}(k_{\\mathrm{cut}}, \\alpha)$. The expression for $f_{\\mathrm{miss}}$ is a ratio of integrals:\n$$\nf_{\\mathrm{miss}}(k_{\\mathrm{cut}}, \\alpha) = \\frac{\\int_{k_{\\mathrm{cut}}}^{\\infty} k^{2} e^{-\\alpha k^{2}} \\, dk}{\\int_{0}^{\\infty} k^{2} e^{-\\alpha k^{2}} \\, dk}\n$$\nwhere $\\alpha = \\sigma_{\\mathrm{eff}}^{2} = \\sigma_{\\mathrm{env}}^{2} + r_{c}^{2}$ and $k_{\\mathrm{cut}} = \\sqrt{2 E_{\\mathrm{cut}}}$.\n\nTo construct a computational algorithm, we must first find an analytical, closed-form expression for $f_{\\mathrm{miss}}$. Let us evaluate the denominator and numerator integrals separately.\n\nThe denominator is the definite integral $I_{\\mathrm{total}} = \\int_{0}^{\\infty} k^{2} e^{-\\alpha k^{2}} dk$. This is a standard form of a Gaussian integral. Its value is known to be:\n$$\nI_{\\mathrm{total}}(\\alpha) = \\frac{\\sqrt{\\pi}}{4\\alpha^{3/2}}\n$$\n\nThe numerator is the incomplete integral $I_{\\mathrm{num}} = \\int_{k_{\\mathrm{cut}}}^{\\infty} k^{2} e^{-\\alpha k^{2}} dk$. We evaluate this using integration by parts, $\\int u \\, dv = uv - \\int v \\, du$. Let us choose:\n- $u = k$\n- $dv = k e^{-\\alpha k^{2}} dk$\n\nFrom this, we find:\n- $du = dk$\n- $v = \\int k e^{-\\alpha k^{2}} dk = -\\frac{1}{2\\alpha} e^{-\\alpha k^{2}}$\n\nApplying integration by parts to the definite integral gives:\n$$\nI_{\\mathrm{num}}(k_{\\mathrm{cut}}, \\alpha) = \\left[ k \\left( -\\frac{1}{2\\alpha} e^{-\\alpha k^{2}} \\right) \\right]_{k_{\\mathrm{cut}}}^{\\infty} - \\int_{k_{\\mathrm{cut}}}^{\\infty} \\left( -\\frac{1}{2\\alpha} e^{-\\alpha k^{2}} \\right) dk\n$$\nThe first term evaluates to $0$ at the upper limit ($k \\to \\infty$) and to $-\\frac{k_{\\mathrm{cut}}}{2\\alpha}e^{-\\alpha k_{\\mathrm{cut}}^2}$ at the lower limit. Thus, the bracketed term is $\\frac{k_{\\mathrm{cut}}}{2\\alpha}e^{-\\alpha k_{\\mathrm{cut}}^2}$. The second term is:\n$$\n\\frac{1}{2\\alpha} \\int_{k_{\\mathrm{cut}}}^{\\infty} e^{-\\alpha k^{2}} dk\n$$\nThis integral is related to the complementary error function, $\\mathrm{erfc}(z) = \\frac{2}{\\sqrt{\\pi}} \\int_z^\\infty e^{-t^2} dt$. Using the substitution $t = k\\sqrt{\\alpha}$, so $dt = \\sqrt{\\alpha} dk$, we have:\n$$\n\\int_{k_{\\mathrm{cut}}}^{\\infty} e^{-\\alpha k^{2}} dk = \\frac{1}{\\sqrt{\\alpha}} \\int_{k_{\\mathrm{cut}}\\sqrt{\\alpha}}^{\\infty} e^{-t^2} dt = \\frac{1}{\\sqrt{\\alpha}} \\frac{\\sqrt{\\pi}}{2} \\mathrm{erfc}(k_{\\mathrm{cut}}\\sqrt{\\alpha})\n$$\nCombining the terms, the numerator integral is:\n$$\nI_{\\mathrm{num}}(k_{\\mathrm{cut}}, \\alpha) = \\frac{k_{\\mathrm{cut}}}{2\\alpha}e^{-\\alpha k_{\\mathrm{cut}}^2} + \\frac{\\sqrt{\\pi}}{4\\alpha^{3/2}} \\mathrm{erfc}(k_{\\mathrm{cut}}\\sqrt{\\alpha})\n$$\n\nNow, we compute the ratio $f_{\\mathrm{miss}} = I_{\\mathrm{num}} / I_{\\mathrm{total}}$:\n$$\nf_{\\mathrm{miss}}(k_{\\mathrm{cut}}, \\alpha) = \\frac{\\frac{k_{\\mathrm{cut}}}{2\\alpha}e^{-\\alpha k_{\\mathrm{cut}}^2} + \\frac{\\sqrt{\\pi}}{4\\alpha^{3/2}} \\mathrm{erfc}(k_{\\mathrm{cut}}\\sqrt{\\alpha})}{\\frac{\\sqrt{\\pi}}{4\\alpha^{3/2}}}\n$$\nSimplifying this expression yields the final analytical formula for $f_{\\mathrm{miss}}$:\n$$\nf_{\\mathrm{miss}}(k_{\\mathrm{cut}}, \\alpha) = \\frac{2 k_{\\mathrm{cut}}\\sqrt{\\alpha}}{\\sqrt{\\pi}} e^{-\\alpha k_{\\mathrm{cut}}^2} + \\mathrm{erfc}(k_{\\mathrm{cut}}\\sqrt{\\alpha})\n$$\n\nThe computational procedure is as follows:\n1. For each test case, specified by a pair of values $(r_c, E_{\\mathrm{cut}})$, first calculate the wave vector cutoff $k_{\\mathrm{cut}} = \\sqrt{2 E_{\\mathrm{cut}}}$.\n2. For each of the three bonding environments (diamond, graphene, C$_{60}$), characterized by $\\sigma_{\\mathrm{dia}} = 1.2$, $\\sigma_{\\mathrm{gra}} = 1.8$, and $\\sigma_{\\mathrm{c60}} = 2.2$ respectively, perform the following steps:\n   a. Compute the parameter $\\alpha = \\sigma_{\\mathrm{env}}^2 + r_c^2$.\n   b. Use the derived analytical formula to calculate $f_{\\mathrm{miss}}$ for the current environment.\n3. This yields a set of three values: $\\{f_{\\mathrm{miss}}^{(\\mathrm{dia})}, f_{\\mathrm{miss}}^{(\\mathrm{gra})}, f_{\\mathrm{miss}}^{(\\mathrm{c60})}\\}$.\n4. Calculate the transferability dispersion $\\Delta_{\\mathrm{tr}} = \\max\\{f_{\\mathrm{miss}}\\} - \\min\\{f_{\\mathrm{miss}}\\}$ from this set.\n5. This procedure is repeated for all four test cases provided in the problem statement.\n\nThis concludes the theoretical derivation. The implementation will be a straightforward execution of this algorithm.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef solve():\n    \"\"\"\n    Computes the transferability dispersion for a set of test cases based on a\n    simplified pseudopotential model.\n    \"\"\"\n\n    # Define the environment-dependent characteristic widths (in bohr)\n    sigma_envs = {\n        \"dia\": 1.2,\n        \"gra\": 1.8,\n        \"c60\": 2.2,\n    }\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (r_c, E_cut) in atomic units.\n    test_cases = [\n        (1.3, 15.0),  # Test 1\n        (0.8, 8.0),   # Test 2\n        (1.8, 8.0),   # Test 3\n        (1.3, 4.0),   # Test 4\n    ]\n\n    results = []\n    \n    # Pre-calculate constant 2/sqrt(pi)\n    TWO_OVER_SQRT_PI = 2.0 / np.sqrt(np.pi)\n\n    def calculate_f_miss(k_cut, alpha):\n        \"\"\"\n        Calculates the fraction of missing spectral weight, f_miss.\n\n        Args:\n            k_cut (float): The plane-wave cutoff in reciprocal space (bohr^-1).\n            alpha (float): The model parameter alpha = sigma_eff^2 (bohr^2).\n\n        Returns:\n            float: The dimensionless value of f_miss.\n        \"\"\"\n        z = k_cut * np.sqrt(alpha)\n        term1 = TWO_OVER_SQRT_PI * z * np.exp(-z**2)\n        term2 = erfc(z)\n        return term1 + term2\n\n    # Process each test case\n    for r_c, E_cut in test_cases:\n        # 1. Calculate the wave vector cutoff\n        k_cut = np.sqrt(2.0 * E_cut)\n        \n        f_miss_values = []\n        \n        # 2. Iterate through each bonding environment\n        for sigma_env in sigma_envs.values():\n            # 2a. Compute the parameter alpha\n            alpha = sigma_env**2 + r_c**2\n            \n            # 2b. Calculate f_miss for the current environment\n            f_miss = calculate_f_miss(k_cut, alpha)\n            f_miss_values.append(f_miss)\n            \n        # 3. Calculate the transferability dispersion\n        delta_tr = np.max(f_miss_values) - np.min(f_miss_values)\n        results.append(delta_tr)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}