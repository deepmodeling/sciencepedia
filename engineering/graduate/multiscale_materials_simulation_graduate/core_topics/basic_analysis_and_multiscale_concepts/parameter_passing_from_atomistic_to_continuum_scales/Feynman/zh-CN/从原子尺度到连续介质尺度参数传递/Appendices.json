{
    "hands_on_practices": [
        {
            "introduction": "柯西-玻恩（Cauchy-Born）法则是连接原子尺度变形与连续介观应变场的关键假设，是许多多尺度方法（如准连续介质方法）的基石。本练习将指导您如何直接从原子间相互作用势中推导材料的刚度张量，这是将离散原子行为转化为连续介质本构关系的核心实践。通过这个练习，您将掌握如何量化线弹性近似的准确性，并理解其在小应变范围内的适用性。",
            "id": "3829186",
            "problem": "考虑一个二维晶体材料，该材料被建模为三角晶格，晶格参数为 $a$，粒子间通过在截断距离 $r_c$ 处截断并移位的 Lennard-Jones (LJ) 势相互作用。您将使用准连续介质 (QC) 方法中的 Cauchy–Born 假设，执行从原子尺度描述到连续介质描述的参数传递。在此，准连续介质 (QC) 方法简化为：从一个经受均匀变形的代表性局部原子环境中，标定单个连续介质单元的刚度，然后预测在基准应变下的应力。\n\n基本原理：\n- 约化的 Lennard-Jones 单位下的对偶原子间能量：对于相距为 $r$ 的两个原子，其势能为 $U_{\\mathrm{LJ}}(r) = 4 \\varepsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6 \\right]$，其中 $\\varepsilon$ 是能量尺度，$\\sigma$ 是长度尺度。本问题使用截断并移位的版本：当 $r \\le r_c$ 时，$U(r) = U_{\\mathrm{LJ}}(r) - U_{\\mathrm{LJ}}(r_c)$；当 $r > r_c$ 时，$U(r) = 0$。\n- 用于均匀变形的 Cauchy–Born 映射：一个小的对称应变张量 $\\boldsymbol{\\varepsilon}$ 会引起一个变形梯度 $\\mathbf{F} = \\mathbf{I} + \\boldsymbol{\\varepsilon}$，其中 $\\mathbf{I}$ 是单位张量。每个参考邻居矢量 $\\mathbf{r}$ 被映射到一个变形后矢量 $\\mathbf{F}\\mathbf{r}$，其长度变为 $\\|\\mathbf{F}\\mathbf{r}\\|$。\n- 单位参考面积的应变能密度由每个原子的原子能量和参考构型中的原子数密度计算得出。对于三角晶格，每个原子的面积为 $A_{\\text{atom}} = \\frac{\\sqrt{3}}{2} a^2$，因此原子数密度为 $\\rho_{a} = \\frac{1}{A_{\\text{atom}}}$。\n- 应力定义为应变能密度对应变分量的导数，而刚度矩阵是应力对应变的雅可比矩阵在零应变处的值。\n\n您的任务：\n1. 为二维三角晶格构建一个代表性的局部原子环境，方法是枚举中心原子的邻居矢量 $\\mathbf{r}$，直至截断距离 $r_c$。使用基矢方向为 $\\mathbf{e}_1 = (1, 0)$ 和 $\\mathbf{e}_2 = \\left(\\frac{1}{2}, \\frac{\\sqrt{3}}{2}\\right)$ 的三角晶格，因此晶格点的位置为 $a\\,(i\\,\\mathbf{e}_1 + j\\,\\mathbf{e}_2)$，其中 $i, j$ 为整数。排除中心原子，并仅保留满足 $\\|\\mathbf{r}\\| \\le r_c$ 的邻居。选择 $a$ 等于 Lennard-Jones 平衡最近邻距离 $a = 2^{1/6}\\sigma$，并设 $r_c = 2.5\\sigma$，$\\varepsilon = 1$ 及 $\\sigma = 1$。\n2. 定义单位参考面积的应变能密度 $w(\\boldsymbol{\\varepsilon})$。设每个原子的能量为 $E_{\\text{atom}}(\\boldsymbol{\\varepsilon}) = \\frac{1}{2} \\sum_{\\mathbf{r}} U(\\|\\mathbf{F}\\mathbf{r}\\|)$，则 $w(\\boldsymbol{\\varepsilon}) = \\rho_{a} E_{\\text{atom}}(\\boldsymbol{\\varepsilon})$，其中求和遍历任务1中构建的邻居矢量。\n3. 使用中心有限差分法，围绕指定的 $\\boldsymbol{\\varepsilon}$ 对 $w(\\boldsymbol{\\varepsilon})$ 关于应变分量 $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy})$ 进行数值微分，以计算 Voigt 记法下的应力矢量 $\\boldsymbol{\\sigma}(\\boldsymbol{\\varepsilon})$ $(\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy})$。应变中使用的有限差分步长为 $h = 10^{-6}$。\n4. 在零应变下，通过使用中心差分法对 $\\boldsymbol{\\sigma}(\\boldsymbol{0})$ 关于各应变分量进行数值微分，来标定 QC 单元刚度矩阵 $\\mathbf{C}$（一个 Voigt 记法下的 $3 \\times 3$ 矩阵）。形式上，$\\mathbf{C}$ 的每一列是中心差分近似 $\\frac{\\boldsymbol{\\sigma}(h\\mathbf{e}_k) - \\boldsymbol{\\sigma}(-h\\mathbf{e}_k)}{2h}$，其中 $\\mathbf{e}_k$ 是 $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy})$ 空间中的单位矢量。\n5. 对于给定的基准应变 $\\boldsymbol{\\varepsilon}$，计算两种应力预测值：\n   - 通过对 $w(\\boldsymbol{\\varepsilon})$ 关于 $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy})$ 进行数值微分，计算完全原子应力 $\\boldsymbol{\\sigma}_{\\text{full}}(\\boldsymbol{\\varepsilon})$。\n   - QC 应力 $\\boldsymbol{\\sigma}_{\\text{QC}}(\\boldsymbol{\\varepsilon}) = \\mathbf{C}\\,\\mathbf{e}$，其中 $\\mathbf{e}$ 是应变分量的 Voigt 矢量。\n6. 通过相对误差来量化精度，其定义为 $E_{\\text{rel}} = \\frac{\\|\\boldsymbol{\\sigma}_{\\text{QC}} - \\boldsymbol{\\sigma}_{\\text{full}}\\|_2}{\\max(\\|\\boldsymbol{\\sigma}_{\\text{full}}\\|_2, \\delta)}$，其中 $\\|\\cdot\\|_2$ 是欧几里得范数，$\\delta = 10^{-12}$ 是一个小的正则化常数。\n\n单位：\n- 所有量必须以无量纲的约化 Lennard-Jones 单位表示，其中 $\\varepsilon = 1$ 且 $\\sigma = 1$。应变是无量纲的，能量密度的单位是 $\\varepsilon/\\sigma^2$，应力的单位是 $\\varepsilon/\\sigma^2$。\n\n测试套件：\n使用以下基准均匀应变 $\\boldsymbol{\\varepsilon}$ 来评估 $E_{\\text{rel}}$：\n- 情况1（理想情况，单轴小应变）：$(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy}) = (0.01, 0, 0)$。\n- 情况2（纯剪切）：$(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy}) = (0, 0, 0.01)$。\n- 情况3（静水小应变）：$(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy}) = (0.005, 0.005, 0)$。\n- 情况4（边界情况，用于测试数值稳定性的极小单轴应变）：$(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy}) = (10^{-6}, 0, 0)$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的相对误差，格式为方括号内以逗号分隔的十进制数列表（例如，“[0.00123,0.00045,0.00087,0.105]”）。",
            "solution": "该问题要求使用基于 Cauchy-Born 假设的简化准连续介质 (QC) 方法，实现从原子模型到连续介质模型的参数传递过程。我们将从一个二维三角晶体的代表性原子体积中，为一个单一连续介质单元标定一个线性弹性本构模型，然后在几种小应变条件下评估其准确性。所有计算均在约化的 Lennard-Jones 单位下进行，其中能量尺度 $\\varepsilon = 1$，长度尺度 $\\sigma = 1$。\n\n过程步骤如下：\n1.  定义原子参考构型和相互作用势。\n2.  使用 Cauchy-Born 法则构建应变能密度 $w(\\boldsymbol{\\varepsilon})$。\n3.  建立计算应力 $\\boldsymbol{\\sigma}$ 和刚度 $\\mathbf{C}$ 的数值计算流程。\n4.  对于给定的应变，计算完全原子应力和线性化的 QC 应力。\n5.  计算两种应力预测值之间的相对误差。\n\n**步骤1：原子模型构型**\n\n该材料是二维三角晶格。在参考构型中，原子的位置由 $\\mathbf{p}_{i,j} = a\\,(i\\,\\mathbf{e}_1 + j\\,\\mathbf{e}_2)$ 给出，其中 $i,j$ 为整数，$\\mathbf{e}_1 = (1, 0)$ 和 $\\mathbf{e}_2 = \\left(\\frac{1}{2}, \\frac{\\sqrt{3}}{2}\\right)$ 是晶格基矢。晶格参数 $a$ 被设定为孤立原子对的平衡距离，$a = 2^{1/6}\\sigma$。当 $\\sigma=1$ 时，我们有 $a = 2^{1/6} \\approx 1.122$。\n\n我们通过识别从中心原子（位于原点）到截断距离 $r_c = 2.5\\sigma$ 内的所有邻居矢量 $\\mathbf{r}$ 来构建一个代表性的原子环境。这些矢量 $\\mathbf{r}$ 是满足 $(i,j) \\neq (0,0)$ 且 $\\|\\mathbf{p}_{i,j}\\| \\le r_c$ 的 $\\mathbf{p}_{i,j}$。\n\n原子间相互作用由截断并移位的 Lennard-Jones (LJ) 势描述：\n$$\nU(r) = \n\\begin{cases} \nU_{\\mathrm{LJ}}(r) - U_{\\mathrm{LJ}}(r_c)  \\text{ if } r \\le r_c \\\\\n0  \\text{ if } r > r_c \n\\end{cases}\n$$\n其中 $U_{\\mathrm{LJ}}(r) = 4 \\varepsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6 \\right]$。给定 $\\varepsilon=1$ 和 $\\sigma=1$，对于 $r \\leq r_c$，该势简化为 $U(r) = 4(r^{-12} - r^{-6}) - U_{\\mathrm{LJ}}(r_c)$。\n\n**步骤2：通过 Cauchy-Born 法则计算应变能密度**\n\nCauchy-Born 法则假定，由变形梯度 $\\mathbf{F}$ 描述的宏观均匀变形，在原子尺度上是均匀施加的。对于一个小的对称应变张量 $\\boldsymbol{\\varepsilon}$，变形梯度为 $\\mathbf{F} = \\mathbf{I} + \\boldsymbol{\\varepsilon}$，其中 $\\mathbf{I}$ 是 $2 \\times 2$ 单位矩阵。\n\n一个参考邻居矢量 $\\mathbf{r}$ 被映射到变形后矢量 $\\mathbf{r}' = \\mathbf{F}\\mathbf{r}$。在变形状态下，每个原子的能量是其所有原子对势能总和的一半：\n$$\nE_{\\text{atom}}(\\boldsymbol{\\varepsilon}) = \\frac{1}{2} \\sum_{\\mathbf{r}} U(\\|\\mathbf{F}\\mathbf{r}\\|)\n$$\n求和遍历在步骤1中确定的邻居矢量集合 $\\mathbf{r}$。\n\n应变能密度 $w(\\boldsymbol{\\varepsilon})$ 是单位参考面积的能量。对于二维三角晶格，每个原子的面积是 $A_{\\text{atom}} = \\frac{\\sqrt{3}}{2} a^2$。原子数密度是 $\\rho_a = 1/A_{\\text{atom}}$。因此，应变能密度为：\n$$\nw(\\boldsymbol{\\varepsilon}) = \\rho_a E_{\\text{atom}}(\\boldsymbol{\\varepsilon}) = \\frac{1}{A_{\\text{atom}}} \\frac{1}{2} \\sum_{\\mathbf{r}} U(\\|\\mathbf{F}\\mathbf{r}\\|)\n$$\n\n**步骤3：应力和刚度计算**\n\n问题将应变分量定义为一个类 Voigt 矢量 $\\mathbf{e} = (\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy})$。这些分量定义了对称应变张量：\n$$\n\\boldsymbol{\\varepsilon} = \\begin{pmatrix} \\varepsilon_{xx} & \\varepsilon_{xy} \\\\ \\varepsilon_{xy} & \\varepsilon_{yy} \\end{pmatrix}\n$$\n对应的“应力矢量”定义为 $\\boldsymbol{\\sigma} = (\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy})$，其中每个分量是应变能密度对相应应变分量的偏导数：\n$$\n\\sigma_{xx} = \\frac{\\partial w}{\\partial \\varepsilon_{xx}}, \\quad \\sigma_{yy} = \\frac{\\partial w}{\\partial \\varepsilon_{yy}}, \\quad \\sigma_{xy} = \\frac{\\partial w}{\\partial \\varepsilon_{xy}}\n$$\n这些导数使用中心有限差分格式进行数值计算，步长为 $h = 10^{-6}$。例如，对于 $\\sigma_{xx}$：\n$$\n\\sigma_{xx}(\\boldsymbol{\\varepsilon}) \\approx \\frac{w(\\varepsilon_{xx}+h, \\varepsilon_{yy}, \\varepsilon_{xy}) - w(\\varepsilon_{xx}-h, \\varepsilon_{yy}, \\varepsilon_{xy})}{2h}\n$$\n刚度矩阵 $\\mathbf{C}$ 是一个 $3 \\times 3$ 矩阵，表示平衡状态下（$\\boldsymbol{\\varepsilon} = \\mathbf{0}$）应力与应变之间的线性关系。它是应力矢量对应变矢量的雅可比矩阵，在零应变处求值：\n$$\n\\mathbf{C} = \\left. \\frac{\\partial \\boldsymbol{\\sigma}}{\\partial \\mathbf{e}} \\right|_{\\mathbf{e} = \\mathbf{0}}\n$$\n$\\mathbf{C}$ 的每一列 $k$ 是通过对应力矢量函数 $\\boldsymbol{\\sigma}(\\mathbf{e})$ 使用中心差分计算的。设 $\\mathbf{u}_k$ 为三维应变空间中的标准基矢（例如，$\\mathbf{u}_1 = (1,0,0)$）。\n$$\n\\mathbf{C}_{:,k} \\approx \\frac{\\boldsymbol{\\sigma}(h\\mathbf{u}_k) - \\boldsymbol{\\sigma}(-h\\mathbf{u}_k)}{2h}\n$$\n\n**步骤4：完全原子应力 vs. QC 应力预测**\n\n对于给定的基准应变 $\\boldsymbol{\\varepsilon}$（由其 Voigt 矢量 $\\mathbf{e}$ 表示），我们计算两种应力预测值：\n\n1.  **完全原子应力 ($\\boldsymbol{\\sigma}_{\\text{full}}$)**：这是通过在给定应变 $\\mathbf{e}$ 下对应变能密度 $w(\\boldsymbol{\\varepsilon})$ 进行数值微分，从非线性原子模型计算出的“精确”应力，如步骤3所述。\n$$\n\\boldsymbol{\\sigma}_{\\text{full}}(\\mathbf{e}) = \\boldsymbol{\\sigma}(\\mathbf{e})\n$$\n\n2.  **QC 应力 ($\\boldsymbol{\\sigma}_{\\text{QC}}$)**：这是由线性化连续介质模型预测的应力，该模型对小应变有效。它是通过将预先标定的刚度矩阵 $\\mathbf{C}$ 应用于应变矢量 $\\mathbf{e}$ 来计算的。\n$$\n\\boldsymbol{\\sigma}_{\\text{QC}}(\\mathbf{e}) = \\mathbf{C} \\mathbf{e}\n$$\n\n**步骤5：误差量化**\n\nQC 近似的准确性由两种应力预测值之间的相对误差 $E_{\\text{rel}}$ 来量化。该误差定义为差矢量的欧几里得范数，并用完全原子应力矢量的范数进行归一化：\n$$\nE_{\\text{rel}} = \\frac{\\|\\boldsymbol{\\sigma}_{\\text{QC}} - \\boldsymbol{\\sigma}_{\\text{full}}\\|_2}{\\max(\\|\\boldsymbol{\\sigma}_{\\text{full}}\\|_2, \\delta)}\n$$\n分母中使用一个小的正则化常数 $\\delta = 10^{-12}$ 以防止在应力为零时出现除以零的情况。对四个指定的基准应变情况中的每一种都计算此误差。实现过程将这些步骤封装在一个 Python 脚本中以生成最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Solves the quasicontinuum parameter passing problem.\n    \"\"\"\n\n    class QCSimulator:\n        \"\"\"\n        Encapsulates the logic for the QC simulation and parameter passing.\n        \"\"\"\n        def __init__(self, sigma, epsilon, a, rc, h, delta):\n            # Physical and numerical parameters\n            self.sigma = sigma\n            self.epsilon = epsilon\n            self.a = a\n            self.rc = rc\n            self.h = h\n            self.delta = delta\n\n            # Pre-computed constants for efficiency\n            self.rc_sq = self.rc**2\n            # LJ potential value at cutoff\n            self.U_rc = 4 * self.epsilon * (\n                (self.sigma / self.rc)**12 - (self.sigma / self.rc)**6\n            )\n            # Area per atom for a 2D triangular lattice\n            self.A_atom = np.sqrt(3) / 2 * self.a**2\n            self.rho_a = 1 / self.A_atom\n\n            # Core data structures initialized upon creation\n            self.neighbors = self._generate_neighbors()\n            self.C = self._calibrate_stiffness_matrix()\n\n        def _generate_neighbors(self):\n            \"\"\"\n            Construct the list of neighbor vectors r in the reference configuration\n            for a central atom up to the cutoff distance rc.\n            \"\"\"\n            neighbors = []\n            e1 = np.array([1.0, 0.0])\n            e2 = np.array([0.5, np.sqrt(3) / 2])\n            \n            # Estimate a safe search radius for integer indices i, j\n            search_radius = int(np.ceil(self.rc / self.a)) + 1\n            \n            for i in range(-search_radius, search_radius + 1):\n                for j in range(-search_radius, search_radius + 1):\n                    if i == 0 and j == 0:\n                        continue\n                    \n                    r_vec = self.a * (i * e1 + j * e2)\n                    if np.dot(r_vec, r_vec) = self.rc_sq:\n                        neighbors.append(r_vec)\n            return neighbors\n\n        def _potential(self, r_mag):\n            \"\"\"\n            Computes the truncated-and-shifted Lennard-Jones potential for a given distance.\n            \"\"\"\n            if r_mag > self.rc or r_mag  1e-12:\n                return 0.0\n            \n            sr6 = (self.sigma / r_mag)**6\n            return 4 * self.epsilon * (sr6**2 - sr6) - self.U_rc\n\n        def _strain_energy_density(self, strain_voigt):\n            \"\"\"\n            Computes the strain energy density w(epsilon) for a given strain vector.\n            \"\"\"\n            eps_xx, eps_yy, eps_xy = strain_voigt\n            \n            strain_tensor = np.array([[eps_xx, eps_xy], [eps_xy, eps_yy]])\n            F = np.identity(2) + strain_tensor\n            \n            total_pair_energy = 0.0\n            for r_ref in self.neighbors:\n                r_def = F @ r_ref\n                r_mag_def = linalg.norm(r_def)\n                total_pair_energy += self._potential(r_mag_def)\n                \n            # Energy per atom is 1/2 of the sum of pair energies\n            E_atom = total_pair_energy / 2.0\n            w = self.rho_a * E_atom\n            return w\n\n        def compute_full_stress(self, strain_voigt):\n            \"\"\"\n            Computes the full atomistic stress vector by numerically differentiating w.\n            \"\"\"\n            strain_voigt = np.array(strain_voigt, dtype=float)\n            stress = np.zeros(3)\n            \n            for i in range(3):\n                h_vec = np.zeros(3)\n                h_vec[i] = self.h\n                w_plus = self._strain_energy_density(strain_voigt + h_vec)\n                w_minus = self._strain_energy_density(strain_voigt - h_vec)\n                stress[i] = (w_plus - w_minus) / (2 * self.h)\n            \n            return stress\n\n        def _calibrate_stiffness_matrix(self):\n            \"\"\"\n            Computes the 3x3 stiffness matrix C by numerically differentiating stress at zero strain.\n            \"\"\"\n            C = np.zeros((3, 3))\n            \n            for j in range(3):\n                h_vec = np.zeros(3)\n                h_vec[j] = self.h\n                s_plus = self.compute_full_stress(h_vec)\n                s_minus = self.compute_full_stress(-h_vec)\n                C[:, j] = (s_plus - s_minus) / (2 * self.h)\n            \n            return C\n\n        def compute_qc_stress(self, strain_voigt):\n            \"\"\"\n            Computes the linearized QC stress prediction using the calibrated stiffness matrix.\n            \"\"\"\n            return self.C @ np.array(strain_voigt)\n\n        def calculate_error(self, strain_voigt):\n            \"\"\"\n            Calculates the relative error between full atomistic and QC stress.\n            \"\"\"\n            sigma_full = self.compute_full_stress(strain_voigt)\n            sigma_qc = self.compute_qc_stress(strain_voigt)\n            \n            norm_diff = linalg.norm(sigma_qc - sigma_full)\n            norm_full = linalg.norm(sigma_full)\n            \n            denominator = max(norm_full, self.delta)\n            \n            return norm_diff / denominator\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.01, 0, 0),       # Case 1: Uniaxial small strain\n        (0, 0, 0.01),       # Case 2: Pure shear strain\n        (0.005, 0.005, 0),  # Case 3: Biaxial (hydrostatic) small strain\n        (1e-6, 0, 0)        # Case 4: Very small uniaxial strain\n    ]\n\n    # Problem parameters in reduced Lennard-Jones units\n    sigma = 1.0\n    epsilon = 1.0\n    a = 2**(1/6) * sigma\n    rc = 2.5 * sigma\n    h = 1e-6\n    delta = 1e-12\n\n    # Initialize the simulator, which pre-calculates neighbors and calibrates stiffness\n    simulator = QCSimulator(sigma, epsilon, a, rc, h, delta)\n    \n    results = []\n    for case in test_cases:\n        error = simulator.calculate_error(case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "真实材料通常是包含不同层级和界面的复合材料，其宏观性能由各组分的性质及其相互作用共同决定。本练习超越了理想晶体，转向层状复合材料，展示了如何通过均匀化方法计算其等效模量。此过程突出了界面柔度的关键作用——这些界面参数本身通常也需要通过原子模拟获得，从而构成了多尺度参数传递的层级。",
            "id": "3829239",
            "problem": "给定一个总厚度为 $L$ 的一维周期性层状复合材料（单元），其沿厚度方向承受宏观轴向载荷。每层 $i$ 的厚度为 $h_i$，并且是线性弹性的，其杨氏模量为 $E_i$（该值通过对单个晶体层的原子模拟得到）。相邻层通过内聚界面连接，这些界面允许位移跳跃，其具有线性牵引-分离关系，特征为单位面积法向刚度 $k_j$（界面柔度），使得界面牵引力 $t$ 和位移跳跃 $\\llbracket u \\rrbracket$ 满足 $t = k_j \\llbracket u \\rrbracket$。假设小变形和准静态平衡。\n\n基本原理：\n- 一维线性弹性的胡克定律：$\\sigma(z) = E(z)\\,\\varepsilon(z)$，其中 $\\sigma$ 是轴向应力，$\\varepsilon = \\frac{du}{dz}$ 是轴向应变。\n- 在没有体力情况下的\n一维平衡：在每层内部 $\\frac{d\\sigma}{dz} = 0$，这意味着在串联的各层中应力 $\\sigma$ 是均匀的。\n- 内聚界面定律：$t = k_j \\llbracket u \\rrbracket$，以及每个界面上的牵引力连续性：$t = \\sigma$。\n\n通过宏观关系 $\\bar{\\sigma} = E_{\\mathrm{eff}}\\,\\bar{\\varepsilon}$ 定义均质化有效模量 $E_{\\mathrm{eff}}$，其中 $\\bar{\\sigma}$ 是体积平均应力，$\\bar{\\varepsilon}$ 是在施加的宏观轴向应变下的体积平均应变。建立并求解变分单元问题，以获得用 $\\{h_i\\}$、$\\{E_i\\}$ 和 $\\{k_j\\}$ 表示的 $E_{\\mathrm{eff}}$，并将其与完美粘合层（界面处位移跳跃为零的串联排列）的混合律预测进行比较。通过计算分数下降 $(E_{\\mathrm{eff}} - E_{\\mathrm{series}})/E_{\\mathrm{series}}$（以小数表示）来量化界面柔度的作用。\n\n物理和数值单位：\n- $E_i$、$E_{\\mathrm{eff}}$ 和 $E_{\\mathrm{series}}$ 必须以吉帕斯卡（GPa）表示。\n- 层厚度 $h_i$ 必须以米（m）为单位。\n- 界面刚度 $k_j$ 必须以帕斯卡每米（Pa/m）为单位。\n- 不涉及角度；不需要角度单位。\n\n测试套件和答案规范：\n对于下面的每个测试用例，您的程序应计算三个量：$E_{\\mathrm{eff}}$ (GPa)、$E_{\\mathrm{series}}$ (GPa) 和 $(E_{\\mathrm{eff}} - E_{\\mathrm{series}})/E_{\\mathrm{series}}$（小数）。将这三个输出中的每一个四舍五入到 6 位小数。\n\n使用以下测试套件：\n- 测试用例 1（两层，近乎完美的界面）：$\\{h_i\\} = [\\,1.0\\times 10^{-6},\\,1.0\\times 10^{-6}\\,]$ m, $\\{E_i\\} = [\\,100,\\,200\\,]$ GPa, $\\{k_j\\} = [\\,1.0\\times 10^{20}\\,]$ Pa/m。\n- 测试用例 2（两层，有限的界面柔度）：$\\{h_i\\} = [\\,1.0\\times 10^{-6},\\,1.0\\times 10^{-6}\\,]$ m, $\\{E_i\\} = [\\,100,\\,200\\,]$ GPa, $\\{k_j\\} = [\\,1.0\\times 10^{18}\\,]$ Pa/m。\n- 测试用例 3（两层，一层非常软的层和中等柔度）：$\\{h_i\\} = [\\,1.5\\times 10^{-6},\\,0.5\\times 10^{-6}\\,]$ m, $\\{E_i\\} = [\\,5,\\,200\\,]$ GPa, $\\{k_j\\} = [\\,1.0\\times 10^{14}\\,]$ Pa/m。\n- 测试用例 4（三层，混合模量和界面）：$\\{h_i\\} = [\\,1.0\\times 10^{-6},\\,1.0\\times 10^{-6},\\,1.0\\times 10^{-6}\\,]$ m, $\\{E_i\\} = [\\,70,\\,3,\\,150\\,]$ GPa, $\\{k_j\\} = [\\,1.0\\times 10^{13},\\,1.0\\times 10^{20}\\,]$ Pa/m。\n- 测试用例 5（两层，极度柔顺的界面）：$\\{h_i\\} = [\\,1.0\\times 10^{-6},\\,1.0\\times 10^{-6}\\,]$ m, $\\{E_i\\} = [\\,120,\\,120\\,]$ GPa, $\\{k_j\\} = [\\,1.0\\times 10^{9}\\,]$ Pa/m。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例生成一个包含三个四舍五入值的列表，顺序为 $[E_{\\mathrm{eff}},E_{\\mathrm{series}},(E_{\\mathrm{eff}} - E_{\\mathrm{series}})/E_{\\mathrm{series}}]$。例如，整体输出必须类似于 $[[\\cdots],[\\cdots],\\dots]$，全部在同一行上。",
            "solution": "问题陈述被评估为有效。它在科学上基于连续介质力学和复合材料理论，提法恰当，目标明确，数据充分，并且其表述是客观的。任务是推导具有柔性界面的一维层状复合材料的有效杨氏模量，这是多尺度材料建模中的一个标准问题。\n\n有效模量 $E_{\\mathrm{eff}}$ 的推导遵循周期性介质在准静态载荷下的均质化原理。我们考虑一个总厚度为 $L$ 的代表性单元。该单元由 $N$ 层组成，每层的厚度为 $h_i$，杨氏模量为 $E_i$，其中 $i=1, \\dots, N$。这些层之间有 $N-1$ 个界面，第 $j$ 个界面的单位面积刚度为 $k_j$。\n\n**1. 平衡与本构关系**\n\n在施加的宏观轴向载荷下，在没有体力的情况下的平衡方程 $\\frac{d\\sigma}{dz} = 0$ 规定了轴向应力 $\\sigma$ 在每层中是恒定的。界面处的牵引力连续性 ($t = \\sigma$) 将此条件扩展到整个单元。因此，局部应力 $\\sigma(z)$ 是均匀的，并且等于宏观（体积平均）应力 $\\bar{\\sigma}$。\n$$ \\sigma(z) = \\sigma = \\bar{\\sigma} $$\n各层和界面的本构关系为：\n-   **层 $i$ 的胡克定律**：层 $i$ 中的轴向应变 $\\varepsilon_i$ 是均匀的，由 $\\varepsilon_i = \\sigma / E_i$ 给出。\n-   **界面 $j$ 的内聚定律**：跨界面 $j$ 的位移跳跃 $\\llbracket u \\rrbracket_j$ 通过 $\\llbracket u \\rrbracket_j = \\sigma / k_j$ 与牵引力 $t_j = \\sigma$ 相关。\n\n**2. 均质化与有效模量 ($E_{\\mathrm{eff}}$)**\n\n有效模量 $E_{\\mathrm{eff}}$ 由宏观应力-应变关系 $\\bar{\\sigma} = E_{\\mathrm{eff}} \\bar{\\varepsilon}$ 定义。宏观应变 $\\bar{\\varepsilon}$ 是单元的总变形 $\\Delta u_{\\text{total}}$ 除以其总长度 $L$。\n$$ \\bar{\\varepsilon} = \\frac{\\Delta u_{\\text{total}}}{L} $$\n总变形是每层内部变形与每个界面处位移跳跃的总和。\n-   层 $i$ 的变形：$\\Delta u_i = \\varepsilon_i h_i = (\\sigma/E_i) h_i$。\n-   界面 $j$ 处的跳跃：$\\llbracket u \\rrbracket_j = \\sigma/k_j$。\n具有 $N$ 层和 $N-1$ 个界面的单元的总变形为：\n$$ \\Delta u_{\\text{total}} = \\sum_{i=1}^{N} \\Delta u_i + \\sum_{j=1}^{N-1} \\llbracket u \\rrbracket_j = \\sum_{i=1}^{N} \\frac{\\sigma h_i}{E_i} + \\sum_{j=1}^{N-1} \\frac{\\sigma}{k_j} = \\sigma \\left( \\sum_{i=1}^{N} \\frac{h_i}{E_i} + \\sum_{j=1}^{N-1} \\frac{1}{k_j} \\right) $$\n单元的总长度为 $L = \\sum_{i=1}^N h_i$。那么宏观应变为：\n$$ \\bar{\\varepsilon} = \\frac{\\Delta u_{\\text{total}}}{L} = \\frac{\\sigma}{L} \\left( \\sum_{i=1}^{N} \\frac{h_i}{E_i} + \\sum_{j=1}^{N-1} \\frac{1}{k_j} \\right) $$\n将此代入 $E_{\\mathrm{eff}}$ 的定义中：\n$$ \\bar{\\sigma} = E_{\\mathrm{eff}} \\bar{\\varepsilon} \\implies \\sigma = E_{\\mathrm{eff}} \\frac{\\sigma}{L} \\left( \\sum_{i=1}^{N} \\frac{h_i}{E_i} + \\sum_{j=1}^{N-1} \\frac{1}{k_j} \\right) $$\n求解 $E_{\\mathrm{eff}}$ 可得：\n$$ E_{\\mathrm{eff}} = \\frac{L}{\\sum_{i=1}^{N} \\frac{h_i}{E_i} + \\sum_{j=1}^{N-1} \\frac{1}{k_j}} = \\frac{\\sum_{i=1}^{N} h_i}{\\sum_{i=1}^{N} \\frac{h_i}{E_i} + \\sum_{j=1}^{N-1} \\frac{1}{k_j}} $$\n这个结果也可以通过建立和求解单元势能的变分问题来获得，这证实了这种直接方法在一维情况下的有效性。\n\n**3. 串联模型模量 ($E_{\\mathrm{series}}$)**\n\n完美粘合层的混合律预测对应于一个界面无限刚性的模型，这意味着它们的柔度为零。这可以通过对所有界面取极限 $k_j \\to \\infty$ 来实现。在此极限下，界面柔度项 $\\sum_{j=1}^{N-1} (1/k_j)$ 消失。\n$$ \\lim_{k_j \\to \\infty} \\left( \\sum_{j=1}^{N-1} \\frac{1}{k_j} \\right) = 0 $$\n因此，该串联模型的有效模量 $E_{\\mathrm{series}}$ 为：\n$$ E_{\\mathrm{series}} = \\frac{\\sum_{i=1}^{N} h_i}{\\sum_{i=1}^{N} \\frac{h_i}{E_i}} $$\n这是层模量的厚度加权调和平均值，是串联加载的层状复合材料的标准结果。\n\n**4. 由界面柔度引起的分数下降**\n\n由于柔性界面的存在导致的刚度分数下降由比率 $(E_{\\mathrm{eff}} - E_{\\mathrm{series}})/E_{\\mathrm{series}}$ 来量化。\n$$ \\frac{E_{\\mathrm{eff}} - E_{\\mathrm{series}}}{E_{\\mathrm{series}}} = \\frac{E_{\\mathrm{eff}}}{E_{\\mathrm{series}}} - 1 $$\n代入推导出的表达式：\n$$ \\frac{E_{\\mathrm{eff}}}{E_{\\mathrm{series}}} = \\frac{\\left( \\frac{L}{\\sum \\frac{h_i}{E_i} + \\sum \\frac{1}{k_j}} \\right)}{\\left( \\frac{L}{\\sum \\frac{h_i}{E_i}} \\right)} = \\frac{\\sum_{i=1}^{N} \\frac{h_i}{E_i}}{\\sum_{i=1}^{N} \\frac{h_i}{E_i} + \\sum_{j=1}^{N-1} \\frac{1}{k_j}} $$\n因此，分数下降为：\n$$ \\frac{E_{\\mathrm{eff}} - E_{\\mathrm{series}}}{E_{\\mathrm{series}}} = \\frac{\\sum \\frac{h_i}{E_i}}{\\sum \\frac{h_i}{E_i} + \\sum \\frac{1}{k_j}} - 1 = \\frac{\\sum \\frac{h_i}{E_i} - \\left( \\sum \\frac{h_i}{E_i} + \\sum \\frac{1}{k_j} \\right)}{\\sum \\frac{h_i}{E_i} + \\sum \\frac{1}{k_j}} = \\frac{-\\sum_{j=1}^{N-1} \\frac{1}{k_j}}{\\sum_{i=1}^{N} \\frac{h_i}{E_i} + \\sum_{j=1}^{N-1} \\frac{1}{k_j}} $$\n这个表达式正确地表明，下降值总是负的（如果 $k_j \\to \\infty$ 则为零），因为界面为系统增加了柔度，从而降低了其整体刚度。\n\n**5. 计算步骤**\n对于每个测试用例，计算以下量。所有中间计算均使用国际单位制基本单位（m, Pa, Pa/m）进行。\n1.  总长度：$L = \\sum_{i=1}^{N} h_i$。\n2.  总体柔度：$C_{\\text{bulk}} = \\sum_{i=1}^{N} \\frac{h_i}{E_i}$。注意，以 GPa 为单位的 $E_i$ 必须通过乘以 $10^9$ 转换为 Pa。\n3.  总界面柔度：$C_{\\text{iface}} = \\sum_{j=1}^{N-1} \\frac{1}{k_j}$。\n4.  串联模量：$E_{\\mathrm{series}} = L / C_{\\text{bulk}}$。\n5.  有效模量：$E_{\\mathrm{eff}} = L / (C_{\\text{bulk}} + C_{\\text{iface}})$。\n6.  分数下降：$R = (E_{\\mathrm{eff}} - E_{\\mathrm{series}}) / E_{\\mathrm{series}}$。\n$E_{\\mathrm{eff}}$ 和 $E_{\\mathrm{series}}$ 的最终值通过除以 $10^9$ 从 Pa 转换为 GPa，并与 $R$ 一起四舍五入到 6 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the effective modulus of a layered composite with cohesive interfaces.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (two layers, near-perfect interface)\n        {'h': [1.0e-6, 1.0e-6], 'E': [100, 200], 'k': [1.0e20]},\n        # Test case 2 (two layers, finite interface compliance)\n        {'h': [1.0e-6, 1.0e-6], 'E': [100, 200], 'k': [1.0e18]},\n        # Test case 3 (two layers, one very soft layer and moderate compliance)\n        {'h': [1.5e-6, 0.5e-6], 'E': [5, 200], 'k': [1.0e14]},\n        # Test case 4 (three layers, mixed moduli and interfaces)\n        {'h': [1.0e-6, 1.0e-6, 1.0e-6], 'E': [70, 3, 150], 'k': [1.0e13, 1.0e20]},\n        # Test case 5 (two layers, extremely compliant interface)\n        {'h': [1.0e-6, 1.0e-6], 'E': [120, 120], 'k': [1.0e9]}\n    ]\n\n    results = []\n    for case in test_cases:\n        h_i = np.array(case['h'])  # Layer thicknesses in m\n        E_i_gpa = np.array(case['E'])  # Layer moduli in GPa\n        k_j = np.array(case['k'])  # Interfacial stiffnesses in Pa/m\n\n        # Convert moduli to Pa for SI unit consistency\n        E_i_pa = E_i_gpa * 1e9\n\n        # Total length of the unit cell\n        L = np.sum(h_i)\n\n        # Calculate the total compliance from the bulk layers\n        # C_bulk = sum(h / E)\n        bulk_compliance = np.sum(h_i / E_i_pa)\n\n        # Calculate the total compliance from the interfaces\n        # C_iface = sum(1 / k)\n        interface_compliance = np.sum(1.0 / k_j)\n\n        # Calculate E_series (perfectly bonded interfaces) in Pa\n        # E_series = L / C_bulk\n        E_series_pa = L / bulk_compliance\n\n        # Calculate E_eff (with compliant interfaces) in Pa\n        # E_eff = L / (C_bulk + interface_compliance)\n        E_eff_pa = L / (bulk_compliance + interface_compliance)\n        \n        # Convert final moduli back to GPa\n        E_series_gpa = E_series_pa / 1e9\n        E_eff_gpa = E_eff_pa / 1e9\n\n        # Calculate the fractional reduction\n        # This can be calculated directly from moduli to avoid re-calculation\n        # which can introduce small floating point differences.\n        if E_series_gpa == 0:\n            # Avoid division by zero, though not expected in these test cases\n            reduction = -1.0 if E_eff_gpa  E_series_gpa else 0.0\n        else:\n            reduction = (E_eff_gpa - E_series_gpa) / E_series_gpa\n            \n        # Round results to 6 decimal places\n        E_eff_rounded = round(E_eff_gpa, 6)\n        E_series_rounded = round(E_series_gpa, 6)\n        reduction_rounded = round(reduction, 6)\n\n        results.append([E_eff_rounded, E_series_rounded, reduction_rounded])\n\n    # Format the output string as [[val1,val2,val3],[...],...]\n    case_strings = []\n    for res_list in results:\n        # Format each number to 6 decimal places to ensure trailing zeros\n        formatted_list = [f\"{x:.6f}\" for x in res_list]\n        case_strings.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "参数传递的应用范围远不止于静态力学性能。材料的许多重要行为，如扩散、相变和蠕变，都由热激活过程主导。本练习将展示如何利用高级原子模拟技术（如“微动弹性带”方法）来计算阿伦尼乌斯（Arrhenius）速率定律的关键参数——活化能 $E_a$ 和指前因子 $\\nu$。这些参数随后可用于更大尺度的动力学模型中，以预测材料在不同温度和时间尺度下的演化。",
            "id": "3829238",
            "problem": "您的任务是利用原子尺度输入构建一个 Arrhenius 速率定律，以便在多尺度材料模拟中将参数传递给连续介质尺度的模型。具体而言，您必须使用由 Nudged Elastic Band (NEB) 和 Hessian 矩阵正规模分析产生的原子尺度数据，计算一个代表性热激活事件的活化能和谐振过渡态理论指前因子，然后组装出与温度相关的速率常数。\n\n从适用于此背景的基本原理出发：\n- 过渡态理论 (Transition State Theory, TST)：在温度 $T$ 下，一个热激活事件的速率可以表示为 $k(T) = \\nu \\exp\\!\\left(-E_a / (k_B T)\\right)$，其中 $E_a$ 是活化能，$\\nu$ 是由反应物势阱和鞍点（过渡态）之间的振动自由能差决定的指前因子，而 $k_B$ 是 Boltzmann 常数。\n- 经典极限下的谐振近似：频率为 $\\nu_i$ 的谐振子模式的振动配分函数简化为一个与 $k_B T / (h \\nu_i)$ 成正比的因子，其中 $h$ 是 Planck 常数。在经典极限下，谐振 TST 指前因子消除了显式的温度因子，变为正稳定模式频率乘积的比值（在鞍点处已移除平动零模和单个不稳定模式）。\n\n您的程序必须实现以下科学上合理且算法上精确的步骤：\n\n1. 从以电子伏特为单位的值列表形式给出的 NEB 路径点能量中确定活化能 $E_a$。计算 $E_a$ 为 NEB 路径上最大能量与最小能量之差，即：\n   $$E_a = \\max_i E_i - \\min_i E_i,$$\n   其中 $E_i$ 是以电子伏特为单位的 NEB 路径点能量。\n\n2. 使用从反应物和鞍点处的 Hessian 矩阵对角化获得的振动正规模频率（单位为太赫兹）计算谐振 TST 指前因子 $\\nu$。采用以下具有物理依据的筛选规则：\n   - 使用关系式 $1\\,\\mathrm{THz} = 10^{12}\\,\\mathrm{Hz}$ 将所有频率从太赫兹转换为赫兹。\n   - 在鞍点处，排除任何负频率（这代表沿反应坐标的单个不稳定模式）。\n   - 在反应物和鞍点处，通过丢弃非负频率中绝对值最小的三个频率来移除三个平动零模。\n   - 筛选后，令 $\\{\\nu_i^{R}\\}$ 表示反应物处剩余的正频率，$\\{\\nu_j^{\\ddagger}\\}$ 表示鞍点处剩余的正频率。则谐振经典指前因子为\n     $$\\nu = \\frac{\\prod_i \\nu_i^{R}}{\\prod_j \\nu_j^{\\ddagger}},$$\n     其结果的单位为 $\\mathrm{s}^{-1}$。\n\n3. 组装 Arrhenius 形式\n   $$k(T) = \\nu \\exp\\!\\left(-\\frac{E_a}{k_B T}\\right),$$\n   其中指数中的 $k_B$ 必须使用电子伏特/开尔文为单位，以保持与以电子伏特为单位的 $E_a$ 和以开尔文为单位的 $T$ 的单位一致性。您最终的 $k(T)$ 必须以 $\\mathrm{s}^{-1}$ 为单位报告。\n\n4. 您的程序必须实现上述逻辑，并为提供的测试套件计算 $k(T)$。它必须输出一行内容，包含一个用方括号括起来的、逗号分隔的浮点数列表，按顺序对应每个测试用例的 $k(T)$ 值。每个浮点数必须四舍五入到六位有效数字。单位为 $\\mathrm{s}^{-1}$。\n\n测试套件（所有能量单位为电子伏特，所有频率单位为太赫兹，所有温度单位为开尔文）：\n- 案例 A（理想路径）：NEB 能量 $[0.0, 0.35, 0.62, 0.58, 0.61]$，反应物频率 $[3.0, 4.5, 5.1, 0.01, 0.02, 0.03]$，鞍点频率 $[4.8, 5.3, -1.5, 0.01, 0.02, 0.03]$，温度 $T = 1000$，报告 $k(T)$，单位为 $\\mathrm{s}^{-1}$。\n- 案例 B（低温边界）：NEB 能量 $[0.0, 0.40, 0.65, 0.64, 0.60]$，反应物频率 $[3.1, 4.4, 5.0, 0.01, 0.02, 0.03]$，鞍点频率 $[4.7, 5.2, -1.4, 0.01, 0.02, 0.03]$，温度 $T = 200$，报告 $k(T)$，单位为 $\\mathrm{s}^{-1}$。\n- 案例 C（近简并振动模式）：NEB 能量 $[0.0, 0.10, 0.31, 0.29, 0.30]$，反应物频率 $[2.2, 2.3, 2.2, 0.004, 0.005, 0.006]$，鞍点频率 $[1.9, 2.4, -0.8, 0.004, 0.005, 0.006]$，温度 $T = 800$，报告 $k(T)$，单位为 $\\mathrm{s}^{-1}$。\n- 案例 D（高势垒边缘）：NEB 能量 $[0.0, 0.50, 1.20, 1.15, 1.18]$，反应物频率 $[6.0, 6.1, 6.2, 0.01, 0.01, 0.01]$，鞍点频率 $[5.9, 6.0, -1.0, 0.01, 0.01, 0.01]$，温度 $T = 1200$，报告 $k(T)$，单位为 $\\mathrm{s}^{-1}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是对应测试用例的速率常数 $k(T)$，单位为 $\\mathrm{s}^{-1}$，并四舍五入到六位有效数字。",
            "solution": "我们基于过渡态理论 (Transition State Theory, TST)、谐振近似和 NEB 推导的活化能这些有原则的基础，推导并实现了通过从原子尺度到连续介质尺度的参数传递来计算 Arrhenius 速率常数的方法。\n\n1. 基本原理：过渡态理论和 Arrhenius 形式。\n我们从过渡态理论 (TST) 出发，该理论将微观的越垒动力学与宏观的速率常数联系起来。在 TST 中，一个热激活事件的速率由下式给出：\n$$k(T) = \\frac{k_B T}{h} \\frac{Q^{\\ddagger}}{Q^{R}} \\exp\\!\\left(-\\frac{E_a}{k_B T}\\right),$$\n其中 $Q^{R}$ 和 $Q^{\\ddagger}$ 分别是反应物势阱和限制在分割面上的鞍点的配分函数，$E_a$ 是活化能（鞍点和反应物极小值点之间的势能差），$k_B$ 是 Boltzmann 常数，$h$ 是 Planck 常数，$T$ 是以开尔文为单位的绝对温度。\n\n2. 指前因子的谐振经典近似。\n在谐振近似下，反应物和鞍点处的振动模式被建模为具有频率 $\\nu_i^{R}$ 和 $\\nu_j^{\\ddagger}$ 的独立谐振子。在经典高温极限下，频率为 $\\nu$ 的单个模式的振动配分函数变为\n$$q_{\\mathrm{vib}} \\approx \\frac{k_B T}{h \\nu}。$$\n因此，振动配分函数的比值变为\n$$\\frac{Q^{\\ddagger}}{Q^{R}} \\approx \\frac{\\prod_j \\frac{k_B T}{h \\nu_j^{\\ddagger}}}{\\prod_i \\frac{k_B T}{h \\nu_i^{R}}} = \\left(\\frac{h}{k_B T}\\right)^{\\Delta f} \\frac{\\prod_i \\nu_i^{R}}{\\prod_j \\nu_j^{\\ddagger}},$$\n其中 $\\Delta f = f_R - f_{\\ddagger}$ 是在移除不相关模式后，反应物和鞍点之间实数正振动模式数量的差异。对于一个具有 $3N$ 自由度的团簇，反应物和鞍点都拥有必须移除的三个平动零模。鞍点还包含一个沿反应坐标的不稳定方向，由一个被排除的虚（负）频率表示。因此，在典型情况下，$f_R - f_{\\ddagger} = 1$。将此代入 TST 表达式可得\n$$k(T) = \\frac{k_B T}{h} \\left(\\frac{h}{k_B T}\\right) \\frac{\\prod_i \\nu_i^{R}}{\\prod_j \\nu_j^{\\ddagger}} \\exp\\!\\left(-\\frac{E_a}{k_B T}\\right)\n= \\left( \\frac{\\prod_i \\nu_i^{R}}{\\prod_j \\nu_j^{\\ddagger}} \\right) \\exp\\!\\left(-\\frac{E_a}{k_B T}\\right)。$$\n因此，在经典谐振极限下，指前因子变得与温度无关，且等于\n$$\\nu = \\frac{\\prod_i \\nu_i^{R}}{\\prod_j \\nu_j^{\\ddagger}},$$\n其中在进行乘积计算之前，所有平动零模和鞍点处的不稳定模式都已被移除，并且所有剩余频率均为正值。\n\n3. 从 Nudged Elastic Band (NEB) 计算活化能。\nNudged Elastic Band (NEB) 方法用路径点将最小能量路径 (MEP) 离散化，并提供沿路径的能量分布 $E_i$。活化能是沿路径相对于反应物极小值的最大能量增量。在一个稳健的算法形式中，我们计算\n$$E_a = \\max_i E_i - \\min_i E_i。$$\n这种方法会自动考虑给定数据中的反应物基线。\n\n4. 频率筛选的算法设计。\n为了计算 $\\nu$，我们按以下步骤进行：\n- 使用线性关系 $1\\,\\mathrm{THz} = 10^{12}\\,\\mathrm{Hz}$ 将所有提供的频率从太赫兹转换为赫兹，以确保单位一致。\n- 在鞍点处，移除任何负频率，这些频率代表与越垒相关的单个不稳定模式。\n- 在反应物和鞍点处，通过丢弃非负频率中绝对值最小的三个频率来移除三个平动零模。这与三维空间中有限团簇的物理特性一致，该团簇在 Hessian 矩阵正规模分析中具有三个频率接近于零的全局平动。\n- 计算反应物处剩余正频率的乘积 $\\prod_i \\nu_i^{R}$ 和鞍点处剩余正频率的乘积 $\\prod_j \\nu_j^{\\ddagger}$，并计算它们的比值以获得单位为 $\\mathrm{s}^{-1}$ 的 $\\nu$。\n\n5. 组装 Arrhenius 速率定律。\n在确定 $\\nu$ 和 $E_a$ 后，我们计算\n$$k(T) = \\nu \\exp\\!\\left(-\\frac{E_a}{k_B T}\\right),$$\n其中使用单位为电子伏特/开尔文的 $k_B$（这样以电子伏特为单位的 $E_a$ 和以开尔文为单位的 $T$ 会得到一个无量纲的指数）。最终的 $k(T)$ 应以 $\\mathrm{s}^{-1}$ 为单位报告。\n\n6. 单位和数值常数。\n- 在指数中使用 $k_B = 8.617333262145\\times 10^{-5}\\,\\mathrm{eV/K}$ 以保持单位一致性。\n- 通过 $1\\,\\mathrm{THz} = 10^{12}\\,\\mathrm{Hz}$ 将太赫兹转换为赫兹。\n- 计算出的指前因子 $\\nu$ 的单位是 $\\mathrm{s}^{-1}$，最终速率常数 $k(T)$ 的单位是 $\\mathrm{s}^{-1}$。\n\n7. 测试套件覆盖范围的基本原理。\n- 案例 A 是一个典型场景，具有中等势垒和行为良好的振动谱。\n- 案例 B 探讨了指数抑制占主导地位的低温边界，以测试数值稳定性。\n- 案例 C 使用近简并振动模式来检验指前因子对微小谱变化的敏感性。\n- 案例 D 是一个高势垒边缘情况，应产生非常小的速率，用于评估乘积和指数计算的稳定性。\n\n8. 输出规范。\n程序必须为每个案例计算 $k(T)$，并打印一行包含在方括号中的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 都四舍五入到六位有效数字，单位为 $\\mathrm{s}^{-1}$。\n\n此工作流程将原子尺度计算的参数（$E_a$ 和 $\\nu$）传递给连续介质尺度的描述符（$k(T)$），从而使其能够后续用于连续介质输运模型（如扩散），其中速率常数直接为宏观系数提供信息。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Constants\nK_B_EV_PER_K = 8.617333262145e-5  # Boltzmann constant in eV/K\nTHZ_TO_HZ = 1.0e12                # 1 THz = 1e12 Hz\n\ndef compute_activation_energy(neb_energies_ev):\n    \"\"\"\n    Compute activation energy E_a from NEB energies in eV as max - min.\n    \"\"\"\n    energies = np.array(neb_energies_ev, dtype=float)\n    Ea = float(np.max(energies) - np.min(energies))\n    return Ea\n\ndef filter_frequencies(freqs_thz, remove_imaginary=False):\n    \"\"\"\n    Convert THz to Hz, optionally remove negative (imaginary) frequencies,\n    then remove the three smallest-by-magnitude non-negative frequencies (translations).\n    Return the remaining positive frequencies in Hz.\n    \"\"\"\n    freqs_hz = np.array(freqs_thz, dtype=float) * THZ_TO_HZ\n\n    # Remove imaginary (negative) if requested\n    if remove_imaginary:\n        freqs_hz = freqs_hz[freqs_hz >= 0.0]\n\n    # Split into non-negative and negative just in case (negatives shouldn't remain if remove_imaginary=True)\n    nonneg = freqs_hz[freqs_hz >= 0.0]\n\n    # If fewer than or equal to 3 non-negative frequencies, removing translations would empty the set.\n    # We still attempt to remove three smallest by magnitude; cap at available count.\n    if nonneg.size == 0:\n        return np.array([], dtype=float)\n\n    # Identify indices of the three smallest-by-magnitude non-negative frequencies (translations)\n    # Use absolute value for magnitude comparison\n    magnitudes = np.abs(nonneg)\n    # argsort returns indices in ascending order of magnitude\n    sort_idx = np.argsort(magnitudes)\n    # Number to remove: up to 3 or fewer if not enough\n    n_remove = min(3, nonneg.size)\n    remove_idx = sort_idx[:n_remove]\n\n    # Create a mask to keep the rest\n    mask = np.ones(nonneg.shape, dtype=bool)\n    mask[remove_idx] = False\n    remaining = nonneg[mask]\n\n    # Keep only strictly positive frequencies (to avoid zeros or numerical noise)\n    remaining_positive = remaining[remaining > 0.0]\n\n    return remaining_positive\n\ndef compute_prefactor(freqs_reactant_thz, freqs_saddle_thz):\n    \"\"\"\n    Compute harmonic classical TST prefactor nu (s^-1) as product ratio of frequencies\n    after removing translations and the single unstable mode at the saddle.\n    \"\"\"\n    # Filter reactant: remove three translations\n    reactant_filtered_hz = filter_frequencies(freqs_reactant_thz, remove_imaginary=False)\n    # Filter saddle: remove imaginary (negative), then three translations\n    saddle_filtered_hz = filter_frequencies(freqs_saddle_thz, remove_imaginary=True)\n\n    # Safety: if any set becomes empty, prefactor cannot be computed reliably; return 0\n    if reactant_filtered_hz.size == 0 or saddle_filtered_hz.size == 0:\n        return 0.0\n\n    prod_reactant = float(np.prod(reactant_filtered_hz))\n    prod_saddle = float(np.prod(saddle_filtered_hz))\n\n    # Avoid division by zero\n    if prod_saddle == 0.0:\n        return 0.0\n\n    nu = prod_reactant / prod_saddle\n    return nu\n\ndef arrhenius_rate_constant(neb_energies_ev, freqs_reactant_thz, freqs_saddle_thz, temperature_k):\n    \"\"\"\n    Compute k(T) = nu * exp(-Ea / (k_B T))\n    where Ea is from NEB energies (eV), k_B in eV/K, T in K, nu in s^-1 from harmonic TST.\n    \"\"\"\n    Ea_ev = compute_activation_energy(neb_energies_ev)\n    nu_s_inv = compute_prefactor(freqs_reactant_thz, freqs_saddle_thz)\n\n    # Exponential argument using k_B in eV/K\n    exponent = -Ea_ev / (K_B_EV_PER_K * float(temperature_k))\n    k_T = nu_s_inv * np.exp(exponent)\n    return k_T\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (NEB energies eV list, reactant freqs THz list, saddle freqs THz list, T in K)\n    test_cases = [\n        (\n            [0.0, 0.35, 0.62, 0.58, 0.61],\n            [3.0, 4.5, 5.1, 0.01, 0.02, 0.03],\n            [4.8, 5.3, -1.5, 0.01, 0.02, 0.03],\n            1000\n        ),\n        (\n            [0.0, 0.40, 0.65, 0.64, 0.60],\n            [3.1, 4.4, 5.0, 0.01, 0.02, 0.03],\n            [4.7, 5.2, -1.4, 0.01, 0.02, 0.03],\n            200\n        ),\n        (\n            [0.0, 0.10, 0.31, 0.29, 0.30],\n            [2.2, 2.3, 2.2, 0.004, 0.005, 0.006],\n            [1.9, 2.4, -0.8, 0.004, 0.005, 0.006],\n            800\n        ),\n        (\n            [0.0, 0.50, 1.20, 1.15, 1.18],\n            [6.0, 6.1, 6.2, 0.01, 0.01, 0.01],\n            [5.9, 6.0, -1.0, 0.01, 0.01, 0.01],\n            1200\n        )\n    ]\n\n    results = []\n    for neb_energies_ev, freqs_reactant_thz, freqs_saddle_thz, T_K in test_cases:\n        k_T = arrhenius_rate_constant(neb_energies_ev, freqs_reactant_thz, freqs_saddle_thz, T_K)\n        # Round to six significant figures\n        results.append(f\"{k_T:.6g}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}