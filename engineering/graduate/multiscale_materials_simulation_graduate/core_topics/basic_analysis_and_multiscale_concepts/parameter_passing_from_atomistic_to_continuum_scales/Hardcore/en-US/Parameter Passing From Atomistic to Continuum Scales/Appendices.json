{
    "hands_on_practices": [
        {
            "introduction": "A fundamental challenge in multiscale modeling is deriving continuum constitutive laws from the underlying atomic interactions. This practice guides you through this process for a perfect crystal using the Cauchy-Born rule, which forms the basis of methods like the Quasicontinuum (QC) approach . By calculating the strain energy density from an interatomic potential, you will calibrate a linear elastic stiffness matrix and learn how macroscopic elasticity emerges from the microscopic world.",
            "id": "3829186",
            "problem": "Consider a two-dimensional crystalline material modeled as a triangular lattice with lattice parameter $a$ and particles interacting via a Lennard–Jones (LJ) potential truncated and shifted at a cutoff distance $r_c$. You will perform parameter passing from the atomistic description to a continuum description using the Cauchy–Born hypothesis within the Quasicontinuum (QC) method. The Quasicontinuum (QC) method here reduces to calibrating a single continuum element’s stiffness from a representative local atomistic environment subjected to homogeneous deformation, and then predicting stresses under benchmark strains.\n\nFundamental base:\n- Pairwise interatomic energy in reduced Lennard–Jones units: For two atoms separated by distance $r$, the potential energy is $U_{\\mathrm{LJ}}(r) = 4 \\varepsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6 \\right]$ with energy scale $\\varepsilon$ and length scale $\\sigma$. A truncated-and-shifted version is used: $U(r) = U_{\\mathrm{LJ}}(r) - U_{\\mathrm{LJ}}(r_c)$ for $r \\le r_c$ and $U(r) = 0$ for $r > r_c$.\n- Cauchy–Born mapping for homogeneous deformation: A small, symmetric strain tensor $\\boldsymbol{\\varepsilon}$ induces a deformation gradient $\\mathbf{F} = \\mathbf{I} + \\boldsymbol{\\varepsilon}$, where $\\mathbf{I}$ is the identity tensor. Each reference neighbor vector $\\mathbf{r}$ is mapped to a deformed vector $\\mathbf{F}\\mathbf{r}$, and its length becomes $\\|\\mathbf{F}\\mathbf{r}\\|$.\n- Strain energy density per reference area is computed from the atomistic energy per atom and the atomic number density in the reference configuration. For a triangular lattice, the area per atom is $A_{\\text{atom}} = \\frac{\\sqrt{3}}{2} a^2$, so the number density is $\\rho_{a} = \\frac{1}{A_{\\text{atom}}}$.\n- Stress is defined as the derivative of the strain energy density with respect to the strain components, and the stiffness matrix is the Jacobian of stress with respect to strain evaluated at zero strain.\n\nYour tasks:\n1. Construct a representative local atomistic environment for a two-dimensional triangular lattice by enumerating neighbor vectors $\\mathbf{r}$ for the central atom up to the cutoff distance $r_c$. Use a triangular lattice with primitive directions $\\mathbf{e}_1 = (1, 0)$ and $\\mathbf{e}_2 = \\left(\\frac{1}{2}, \\frac{\\sqrt{3}}{2}\\right)$, so that lattice points are at positions $a\\,(i\\,\\mathbf{e}_1 + j\\,\\mathbf{e}_2)$ for integers $i,j$. Exclude the central atom and retain only neighbors with $\\|\\mathbf{r}\\| \\le r_c$. Choose $a$ equal to the Lennard–Jones equilibrium nearest-neighbor distance $a = 2^{1/6}\\sigma$, and $r_c = 2.5\\sigma$ with $\\varepsilon = 1$ and $\\sigma = 1$.\n2. Define the strain energy density $w(\\boldsymbol{\\varepsilon})$ per reference area. Let the energy per atom be $E_{\\text{atom}}(\\boldsymbol{\\varepsilon}) = \\frac{1}{2} \\sum_{\\mathbf{r}} U(\\|\\mathbf{F}\\mathbf{r}\\|)$, and then $w(\\boldsymbol{\\varepsilon}) = \\rho_{a} E_{\\text{atom}}(\\boldsymbol{\\varepsilon})$, where the sum runs over the neighbor vectors constructed in task 1.\n3. Compute the stress vector $\\boldsymbol{\\sigma}(\\boldsymbol{\\varepsilon})$ in Voigt notation $(\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy})$ by numerically differentiating $w(\\boldsymbol{\\varepsilon})$ with respect to the strain components $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy})$ using central finite differences about the specified $\\boldsymbol{\\varepsilon}$. Use a finite-difference step of $h = 10^{-6}$ in strain.\n4. Calibrate the QC element stiffness matrix $\\mathbf{C}$ (a $3 \\times 3$ matrix in Voigt notation) at zero strain by numerically differentiating $\\boldsymbol{\\sigma}(\\boldsymbol{0})$ with respect to each strain component using central differences. Formally, each column of $\\mathbf{C}$ is the central difference approximation $\\frac{\\boldsymbol{\\sigma}(h\\mathbf{e}_k) - \\boldsymbol{\\sigma}(-h\\mathbf{e}_k)}{2h}$, where $\\mathbf{e}_k$ are the unit vectors in the space of $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy})$.\n5. For a given benchmark strain $\\boldsymbol{\\varepsilon}$, compute two stress predictions:\n   - The full atomistic stress $\\boldsymbol{\\sigma}_{\\text{full}}(\\boldsymbol{\\varepsilon})$ by numerically differentiating $w(\\boldsymbol{\\varepsilon})$ with respect to $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy})$.\n   - The QC stress $\\boldsymbol{\\sigma}_{\\text{QC}}(\\boldsymbol{\\varepsilon}) = \\mathbf{C}\\,\\mathbf{e}$, where $\\mathbf{e}$ is the Voigt vector of strain components.\n6. Quantify accuracy by the relative error defined as $E_{\\text{rel}} = \\frac{\\|\\boldsymbol{\\sigma}_{\\text{QC}} - \\boldsymbol{\\sigma}_{\\text{full}}\\|_2}{\\max(\\|\\boldsymbol{\\sigma}_{\\text{full}}\\|_2, \\delta)}$, where $\\|\\cdot\\|_2$ is the Euclidean norm and $\\delta = 10^{-12}$ is a small regularization constant.\n\nUnits:\n- All quantities must be expressed in non-dimensional reduced Lennard–Jones units, with $\\varepsilon = 1$ and $\\sigma = 1$. Strain is dimensionless, energy density is in units of $\\varepsilon/\\sigma^2$, and stress is in units of $\\varepsilon/\\sigma^2$.\n\nTest suite:\nUse the following benchmark homogeneous strains $\\boldsymbol{\\varepsilon}$ to evaluate $E_{\\text{rel}}$:\n- Case 1 (happy path, uniaxial small strain): $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy}) = (0.01, 0, 0)$.\n- Case 2 (pure shear): $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy}) = (0, 0, 0.01)$.\n- Case 3 (hydrostatic small strain): $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy}) = (0.005, 0.005, 0)$.\n- Case 4 (edge case, very small uniaxial strain to test numerical stability): $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy}) = (10^{-6}, 0, 0)$.\n\nRequired final output format:\nYour program should produce a single line of output containing the relative errors for the four test cases as a comma-separated list of decimals enclosed in square brackets (e.g., \"[0.00123,0.00045,0.00087,0.105]\").",
            "solution": "The problem requires a parameter passing procedure from an atomistic model to a continuum model using a simplified Quasicontinuum (QC) approach based on the Cauchy-Born hypothesis. We will calibrate a linear elastic constitutive model for a single continuum element from a representative atomistic volume of a two-dimensional triangular crystal and then evaluate its accuracy under several small strain conditions. All calculations are performed in reduced Lennard-Jones units, where the energy scale $\\varepsilon = 1$ and the length scale $\\sigma = 1$.\n\nThe procedural steps are as follows:\n1.  Define the atomistic reference configuration and interaction potential.\n2.  Formulate the strain energy density $w(\\boldsymbol{\\varepsilon})$ using the Cauchy-Born rule.\n3.  Establish the numerical procedures for computing stress $\\boldsymbol{\\sigma}$ and stiffness $\\mathbf{C}$.\n4.  Compute the full atomistic stress and the linearized QC stress for given strains.\n5.  Calculate the relative error between the two stress predictions.\n\n**Step 1: Atomistic Model Configuration**\n\nThe material is a two-dimensional triangular lattice. The positions of atoms in the reference configuration are given by $\\mathbf{p}_{i,j} = a\\,(i\\,\\mathbf{e}_1 + j\\,\\mathbf{e}_2)$ for integers $i,j$, where $\\mathbf{e}_1 = (1, 0)$ and $\\mathbf{e}_2 = \\left(\\frac{1}{2}, \\frac{\\sqrt{3}}{2}\\right)$ are the primitive lattice vectors. The lattice parameter $a$ is set to the equilibrium distance of an isolated pair of atoms, $a = 2^{1/6}\\sigma$. With $\\sigma=1$, we have $a = 2^{1/6} \\approx 1.122$.\n\nWe construct a representative atomic environment by identifying all neighbor vectors $\\mathbf{r}$ from a central atom (at the origin) up to a cutoff distance $r_c = 2.5\\sigma$. These vectors $\\mathbf{r}$ are the $\\mathbf{p}_{i,j}$ for $(i,j) \\neq (0,0)$ such that $\\|\\mathbf{p}_{i,j}\\| \\le r_c$.\n\nThe interatomic interaction is described by a truncated-and-shifted Lennard-Jones (LJ) potential:\n$$\nU(r) = \n\\begin{cases} \nU_{\\mathrm{LJ}}(r) - U_{\\mathrm{LJ}}(r_c) & \\text{if } r \\le r_c \\\\\n0 & \\text{if } r > r_c \n\\end{cases}\n$$\nwhere $U_{\\mathrm{LJ}}(r) = 4 \\varepsilon \\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6 \\right]$. Given $\\varepsilon=1$ and $\\sigma=1$, this simplifies to $U(r) = 4(r^{-12} - r^{-6}) - U_{\\mathrm{LJ}}(r_c)$ for $r \\leq r_c$.\n\n**Step 2: Strain Energy Density via Cauchy-Born Rule**\n\nThe Cauchy-Born rule postulates that a macroscopic homogeneous deformation, described by the deformation gradient $\\mathbf{F}$, applies uniformly at the atomic scale. For a small, symmetric strain tensor $\\boldsymbol{\\varepsilon}$, the deformation gradient is $\\mathbf{F} = \\mathbf{I} + \\boldsymbol{\\varepsilon}$, where $\\mathbf{I}$ is the $2 \\times 2$ identity matrix.\n\nA reference neighbor vector $\\mathbf{r}$ is mapped to a deformed vector $\\mathbf{r}' = \\mathbf{F}\\mathbf{r}$. The energy per atom in the deformed state is half the sum of potential energies of all its pairs:\n$$\nE_{\\text{atom}}(\\boldsymbol{\\varepsilon}) = \\frac{1}{2} \\sum_{\\mathbf{r}} U(\\|\\mathbf{F}\\mathbf{r}\\|)\n$$\nThe sum is over the set of neighbor vectors $\\mathbf{r}$ determined in Step 1.\n\nThe strain energy density $w(\\boldsymbol{\\varepsilon})$ is the energy per unit reference area. For a 2D triangular lattice, the area per atom is $A_{\\text{atom}} = \\frac{\\sqrt{3}}{2} a^2$. The number density of atoms is $\\rho_a = 1/A_{\\text{atom}}$. Thus, the strain energy density is:\n$$\nw(\\boldsymbol{\\varepsilon}) = \\rho_a E_{\\text{atom}}(\\boldsymbol{\\varepsilon}) = \\frac{1}{A_{\\text{atom}}} \\frac{1}{2} \\sum_{\\mathbf{r}} U(\\|\\mathbf{F}\\mathbf{r}\\|)\n$$\n\n**Step 3: Stress and Stiffness Calculation**\n\nThe problem defines the strain components in a Voigt-like vector as $\\mathbf{e} = (\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy})$. These components define the symmetric strain tensor:\n$$\n\\boldsymbol{\\varepsilon} = \\begin{pmatrix} \\varepsilon_{xx} & \\varepsilon_{xy} \\\\ \\varepsilon_{xy} & \\varepsilon_{yy} \\end{pmatrix}\n$$\nThe corresponding \"stress vector\" is defined as $\\boldsymbol{\\sigma} = (\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy})$, where each component is the partial derivative of the strain energy density with respect to the corresponding strain component:\n$$\n\\sigma_{xx} = \\frac{\\partial w}{\\partial \\varepsilon_{xx}}, \\quad \\sigma_{yy} = \\frac{\\partial w}{\\partial \\varepsilon_{yy}}, \\quad \\sigma_{xy} = \\frac{\\partial w}{\\partial \\varepsilon_{xy}}\n$$\nThese derivatives are computed numerically using a central finite difference scheme with a step size of $h = 10^{-6}$. For example, for $\\sigma_{xx}$:\n$$\n\\sigma_{xx}(\\boldsymbol{\\varepsilon}) \\approx \\frac{w(\\varepsilon_{xx}+h, \\varepsilon_{yy}, \\varepsilon_{xy}) - w(\\varepsilon_{xx}-h, \\varepsilon_{yy}, \\varepsilon_{xy})}{2h}\n$$\nThe stiffness matrix $\\mathbf{C}$ is a $3 \\times 3$ matrix representing the linear relationship between stress and strain at equilibrium ($\\boldsymbol{\\varepsilon} = \\mathbf{0}$). It is the Jacobian matrix of the stress vector with respect to the strain vector, evaluated at zero strain:\n$$\n\\mathbf{C} = \\left. \\frac{\\partial \\boldsymbol{\\sigma}}{\\partial \\mathbf{e}} \\right|_{\\mathbf{e} = \\mathbf{0}}\n$$\nEach column $k$ of $\\mathbf{C}$ is computed using central differences on the stress vector function $\\boldsymbol{\\sigma}(\\mathbf{e})$. Let $\\mathbf{u}_k$ be the standard basis vectors in the $3$-dimensional strain space (e.g., $\\mathbf{u}_1 = (1,0,0)$).\n$$\n\\mathbf{C}_{:,k} \\approx \\frac{\\boldsymbol{\\sigma}(h\\mathbf{u}_k) - \\boldsymbol{\\sigma}(-h\\mathbf{u}_k)}{2h}\n$$\n\n**Step 4: Full Atomistic vs. QC Stress Prediction**\n\nFor a given benchmark strain $\\boldsymbol{\\varepsilon}$ (represented by its Voigt vector $\\mathbf{e}$), we compute two stress predictions:\n\n1.  **Full Atomistic Stress ($\\boldsymbol{\\sigma}_{\\text{full}}$)**: This is the \"exact\" stress calculated from the nonlinear atomistic model by numerically differentiating the strain energy density $w(\\boldsymbol{\\varepsilon})$ at the given strain $\\mathbf{e}$, as described in Step 3.\n$$\n\\boldsymbol{\\sigma}_{\\text{full}}(\\mathbf{e}) = \\boldsymbol{\\sigma}(\\mathbf{e})\n$$\n\n2.  **QC Stress ($\\boldsymbol{\\sigma}_{\\text{QC}}$)**: This is the stress predicted by the linearized continuum model, which is valid for small strains. It is calculated by applying the pre-calibrated stiffness matrix $\\mathbf{C}$ to the strain vector $\\mathbf{e}$.\n$$\n\\boldsymbol{\\sigma}_{\\text{QC}}(\\mathbf{e}) = \\mathbf{C} \\mathbf{e}\n$$\n\n**Step 5: Error Quantification**\n\nThe accuracy of the QC approximation is quantified by the relative error $E_{\\text{rel}}$ between the two stress predictions. This error is defined as the Euclidean norm of the difference vector, normalized by the norm of the full atomistic stress vector:\n$$\nE_{\\text{rel}} = \\frac{\\|\\boldsymbol{\\sigma}_{\\text{QC}} - \\boldsymbol{\\sigma}_{\\text{full}}\\|_2}{\\max(\\|\\boldsymbol{\\sigma}_{\\text{full}}\\|_2, \\delta)}\n$$\nA small regularization constant $\\delta = 10^{-12}$ is used in the denominator to prevent division by zero in the case of zero stress. This error is computed for each of the four specified benchmark strain cases. The implementation encapsulates these steps in a Python script to produce the final results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Solves the quasicontinuum parameter passing problem.\n    \"\"\"\n\n    class QCSimulator:\n        \"\"\"\n        Encapsulates the logic for the QC simulation and parameter passing.\n        \"\"\"\n        def __init__(self, sigma, epsilon, a, rc, h, delta):\n            # Physical and numerical parameters\n            self.sigma = sigma\n            self.epsilon = epsilon\n            self.a = a\n            self.rc = rc\n            self.h = h\n            self.delta = delta\n\n            # Pre-computed constants for efficiency\n            self.rc_sq = self.rc**2\n            # LJ potential value at cutoff\n            self.U_rc = 4 * self.epsilon * (\n                (self.sigma / self.rc)**12 - (self.sigma / self.rc)**6\n            )\n            # Area per atom for a 2D triangular lattice\n            self.A_atom = np.sqrt(3) / 2 * self.a**2\n            self.rho_a = 1 / self.A_atom\n\n            # Core data structures initialized upon creation\n            self.neighbors = self._generate_neighbors()\n            self.C = self._calibrate_stiffness_matrix()\n\n        def _generate_neighbors(self):\n            \"\"\"\n            Construct the list of neighbor vectors r in the reference configuration\n            for a central atom up to the cutoff distance rc.\n            \"\"\"\n            neighbors = []\n            e1 = np.array([1.0, 0.0])\n            e2 = np.array([0.5, np.sqrt(3) / 2])\n            \n            # Estimate a safe search radius for integer indices i, j\n            search_radius = int(np.ceil(self.rc / self.a)) + 1\n            \n            for i in range(-search_radius, search_radius + 1):\n                for j in range(-search_radius, search_radius + 1):\n                    if i == 0 and j == 0:\n                        continue\n                    \n                    r_vec = self.a * (i * e1 + j * e2)\n                    if np.dot(r_vec, r_vec) <= self.rc_sq:\n                        neighbors.append(r_vec)\n            return neighbors\n\n        def _potential(self, r_mag):\n            \"\"\"\n            Computes the truncated-and-shifted Lennard-Jones potential for a given distance.\n            \"\"\"\n            if r_mag > self.rc or r_mag < 1e-12:\n                return 0.0\n            \n            sr6 = (self.sigma / r_mag)**6\n            return 4 * self.epsilon * (sr6**2 - sr6) - self.U_rc\n\n        def _strain_energy_density(self, strain_voigt):\n            \"\"\"\n            Computes the strain energy density w(epsilon) for a given strain vector.\n            \"\"\"\n            eps_xx, eps_yy, eps_xy = strain_voigt\n            \n            strain_tensor = np.array([[eps_xx, eps_xy], [eps_xy, eps_yy]])\n            F = np.identity(2) + strain_tensor\n            \n            total_pair_energy = 0.0\n            for r_ref in self.neighbors:\n                r_def = F @ r_ref\n                r_mag_def = linalg.norm(r_def)\n                total_pair_energy += self._potential(r_mag_def)\n                \n            # Energy per atom is 1/2 of the sum of pair energies\n            E_atom = total_pair_energy / 2.0\n            w = self.rho_a * E_atom\n            return w\n\n        def compute_full_stress(self, strain_voigt):\n            \"\"\"\n            Computes the full atomistic stress vector by numerically differentiating w.\n            \"\"\"\n            strain_voigt = np.array(strain_voigt, dtype=float)\n            stress = np.zeros(3)\n            \n            for i in range(3):\n                h_vec = np.zeros(3)\n                h_vec[i] = self.h\n                w_plus = self._strain_energy_density(strain_voigt + h_vec)\n                w_minus = self._strain_energy_density(strain_voigt - h_vec)\n                stress[i] = (w_plus - w_minus) / (2 * self.h)\n            \n            return stress\n\n        def _calibrate_stiffness_matrix(self):\n            \"\"\"\n            Computes the 3x3 stiffness matrix C by numerically differentiating stress at zero strain.\n            \"\"\"\n            C = np.zeros((3, 3))\n            \n            for j in range(3):\n                h_vec = np.zeros(3)\n                h_vec[j] = self.h\n                s_plus = self.compute_full_stress(h_vec)\n                s_minus = self.compute_full_stress(-h_vec)\n                C[:, j] = (s_plus - s_minus) / (2 * self.h)\n            \n            return C\n\n        def compute_qc_stress(self, strain_voigt):\n            \"\"\"\n            Computes the linearized QC stress prediction using the calibrated stiffness matrix.\n            \"\"\"\n            return self.C @ np.array(strain_voigt)\n\n        def calculate_error(self, strain_voigt):\n            \"\"\"\n            Calculates the relative error between full atomistic and QC stress.\n            \"\"\"\n            sigma_full = self.compute_full_stress(strain_voigt)\n            sigma_qc = self.compute_qc_stress(strain_voigt)\n            \n            norm_diff = linalg.norm(sigma_qc - sigma_full)\n            norm_full = linalg.norm(sigma_full)\n            \n            denominator = max(norm_full, self.delta)\n            \n            return norm_diff / denominator\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.01, 0, 0),       # Case 1: Uniaxial small strain\n        (0, 0, 0.01),       # Case 2: Pure shear strain\n        (0.005, 0.005, 0),  # Case 3: Biaxial (hydrostatic) small strain\n        (1e-6, 0, 0)        # Case 4: Very small uniaxial strain\n    ]\n\n    # Problem parameters in reduced Lennard-Jones units\n    sigma = 1.0\n    epsilon = 1.0\n    a = 2**(1/6) * sigma\n    rc = 2.5 * sigma\n    h = 1e-6\n    delta = 1e-12\n\n    # Initialize the simulator, which pre-calculates neighbors and calibrates stiffness\n    simulator = QCSimulator(sigma, epsilon, a, rc, h, delta)\n    \n    results = []\n    for case in test_cases:\n        error = simulator.calculate_error(case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "Real materials are rarely perfect crystals; they are often composites with complex microstructures. This exercise moves beyond the ideal lattice to a layered composite, a common structure in advanced materials . You will learn to compute an effective elastic modulus by homogenizing the properties of individual layers and, crucially, accounting for the mechanical compliance of the interfaces between them.",
            "id": "3829239",
            "problem": "You are given a one-dimensional periodic layered composite (unit cell) of total thickness $L$ subjected to macroscopic axial loading along its thickness direction. Each layer $i$ has thickness $h_i$ and is linearly elastic with Young’s modulus $E_i$ (passing from atomistic simulations of the individual crystalline layers). Adjacent layers are connected by cohesive interfaces that allow a displacement jump with a linear traction–separation relation characterized by a normal stiffness per unit area $k_j$ (interfacial compliance), so that the interface traction $t$ and the displacement jump $\\llbracket u \\rrbracket$ satisfy $t = k_j \\llbracket u \\rrbracket$. Assume small deformations and quasi-static equilibrium.\n\nFundamental base:\n- Hooke’s law for one-dimensional linear elasticity: $\\sigma(z) = E(z)\\,\\varepsilon(z)$, where $\\sigma$ is the axial stress and $\\varepsilon = \\frac{du}{dz}$ is the axial strain.\n- Equilibrium in the absence of body forces in one dimension: $\\frac{d\\sigma}{dz} = 0$ within each layer, implying uniform stress $\\sigma$ across layers in series.\n- Cohesive interface law: $t = k_j \\llbracket u \\rrbracket$, and traction continuity across each interface: $t = \\sigma$.\n\nDefine the homogenized effective modulus $E_{\\mathrm{eff}}$ via the macroscopic relation $\\bar{\\sigma} = E_{\\mathrm{eff}}\\,\\bar{\\varepsilon}$, where $\\bar{\\sigma}$ is the volume-averaged stress and $\\bar{\\varepsilon}$ is the volume-averaged strain under an imposed macroscopic axial strain. Formulate and solve the variational cell problem to obtain $E_{\\mathrm{eff}}$ in terms of $\\{h_i\\}$, $\\{E_i\\}$, and $\\{k_j\\}$, and compare it to the rule-of-mixtures prediction for perfectly bonded layers (series arrangement with zero displacement jump at interfaces). Quantify the role of interfacial compliance by computing the fractional reduction $(E_{\\mathrm{eff}} - E_{\\mathrm{series}})/E_{\\mathrm{series}}$ as a decimal.\n\nPhysical and numerical units:\n- $E_i$ and $E_{\\mathrm{eff}}$ and $E_{\\mathrm{series}}$ must be expressed in gigapascal (GPa).\n- Layer thicknesses $h_i$ must be in meters (m).\n- Interfacial stiffnesses $k_j$ must be in pascal per meter (Pa/m).\n- Angles are not involved; no angle units are required.\n\nTest suite and answer specification:\nFor each test case below, your program should compute three quantities: $E_{\\mathrm{eff}}$ (GPa), $E_{\\mathrm{series}}$ (GPa), and $(E_{\\mathrm{eff}} - E_{\\mathrm{series}})/E_{\\mathrm{series}}$ (decimal). Round each of these three outputs to $6$ decimal places.\n\nUse the following test suite:\n- Test case 1 (two layers, near-perfect interface): $\\{h_i\\} = [\\,1.0\\times 10^{-6},\\,1.0\\times 10^{-6}\\,]$ m, $\\{E_i\\} = [\\,100,\\,200\\,]$ GPa, $\\{k_j\\} = [\\,1.0\\times 10^{20}\\,]$ Pa/m.\n- Test case 2 (two layers, finite interface compliance): $\\{h_i\\} = [\\,1.0\\times 10^{-6},\\,1.0\\times 10^{-6}\\,]$ m, $\\{E_i\\} = [\\,100,\\,200\\,]$ GPa, $\\{k_j\\} = [\\,1.0\\times 10^{18}\\,]$ Pa/m.\n- Test case 3 (two layers, one very soft layer and moderate compliance): $\\{h_i\\} = [\\,1.5\\times 10^{-6},\\,0.5\\times 10^{-6}\\,]$ m, $\\{E_i\\} = [\\,5,\\,200\\,]$ GPa, $\\{k_j\\} = [\\,1.0\\times 10^{14}\\,]$ Pa/m.\n- Test case 4 (three layers, mixed moduli and interfaces): $\\{h_i\\} = [\\,1.0\\times 10^{-6},\\,1.0\\times 10^{-6},\\,1.0\\times 10^{-6}\\,]$ m, $\\{E_i\\} = [\\,70,\\,3,\\,150\\,]$ GPa, $\\{k_j\\} = [\\,1.0\\times 10^{13},\\,1.0\\times 10^{20}\\,]$ Pa/m.\n- Test case 5 (two layers, extremely compliant interface): $\\{h_i\\} = [\\,1.0\\times 10^{-6},\\,1.0\\times 10^{-6}\\,]$ m, $\\{E_i\\} = [\\,120,\\,120\\,]$ GPa, $\\{k_j\\} = [\\,1.0\\times 10^{9}\\,]$ Pa/m.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case producing a list of the three rounded values in the order $[E_{\\mathrm{eff}},E_{\\mathrm{series}},(E_{\\mathrm{eff}} - E_{\\mathrm{series}})/E_{\\mathrm{series}}]$. For example, the overall output must look like $[[\\cdots],[\\cdots],\\dots]$ all on one line.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in continuum mechanics and composite theory, well-posed with a clear objective and sufficient data, and objective in its formulation. The task is to derive the effective Young's modulus of a 1D layered composite with compliant interfaces, a standard problem in multiscale materials modeling.\n\nThe derivation of the effective modulus, $E_{\\mathrm{eff}}$, follows from the principles of homogenization for a periodic medium under quasi-static loading. We consider a representative unit cell of total thickness $L$. The unit cell consists of $N$ layers, each with thickness $h_i$ and Young's modulus $E_i$, for $i=1, \\dots, N$. There are $N-1$ interfaces between these layers, with the $j$-th interface having a stiffness per unit area $k_j$.\n\n**1. Equilibrium and Constitutive Relations**\n\nUnder an applied macroscopic axial load, the equilibrium equation in the absence of body forces, $\\frac{d\\sigma}{dz} = 0$, dictates that the axial stress $\\sigma$ is constant throughout each layer. Traction continuity at the interfaces ($t = \\sigma$) extends this condition across the entire unit cell. Therefore, the local stress $\\sigma(z)$ is uniform and equal to the macroscopic (volume-averaged) stress, $\\bar{\\sigma}$.\n$$ \\sigma(z) = \\sigma = \\bar{\\sigma} $$\nThe constitutive relations for the layers and interfaces are:\n-   **Hooke's Law for Layer $i$**: The axial strain $\\varepsilon_i$ in layer $i$ is uniform and given by $\\varepsilon_i = \\sigma / E_i$.\n-   **Cohesive Law for Interface $j$**: The displacement jump $\\llbracket u \\rrbracket_j$ across interface $j$ is related to the traction $t_j = \\sigma$ by $\\llbracket u \\rrbracket_j = \\sigma / k_j$.\n\n**2. Homogenization and Effective Modulus ($E_{\\mathrm{eff}}$)**\n\nThe effective modulus $E_{\\mathrm{eff}}$ is defined by the macroscopic stress-strain relation $\\bar{\\sigma} = E_{\\mathrm{eff}} \\bar{\\varepsilon}$. The macroscopic strain $\\bar{\\varepsilon}$ is the total deformation of the unit cell, $\\Delta u_{\\text{total}}$, divided by its total length $L$.\n$$ \\bar{\\varepsilon} = \\frac{\\Delta u_{\\text{total}}}{L} $$\nThe total deformation is the sum of the deformations within each layer and the displacement jumps at each interface.\n-   Deformation of layer $i$: $\\Delta u_i = \\varepsilon_i h_i = (\\sigma/E_i) h_i$.\n-   Jump at interface $j$: $\\llbracket u \\rrbracket_j = \\sigma/k_j$.\nThe total deformation for a unit cell with $N$ layers and $N-1$ interfaces is:\n$$ \\Delta u_{\\text{total}} = \\sum_{i=1}^{N} \\Delta u_i + \\sum_{j=1}^{N-1} \\llbracket u \\rrbracket_j = \\sum_{i=1}^{N} \\frac{\\sigma h_i}{E_i} + \\sum_{j=1}^{N-1} \\frac{\\sigma}{k_j} = \\sigma \\left( \\sum_{i=1}^{N} \\frac{h_i}{E_i} + \\sum_{j=1}^{N-1} \\frac{1}{k_j} \\right) $$\nThe total length of the unit cell is $L = \\sum_{i=1}^N h_i$. The macroscopic strain is then:\n$$ \\bar{\\varepsilon} = \\frac{\\Delta u_{\\text{total}}}{L} = \\frac{\\sigma}{L} \\left( \\sum_{i=1}^{N} \\frac{h_i}{E_i} + \\sum_{j=1}^{N-1} \\frac{1}{k_j} \\right) $$\nSubstituting this into the definition of $E_{\\mathrm{eff}}$:\n$$ \\bar{\\sigma} = E_{\\mathrm{eff}} \\bar{\\varepsilon} \\implies \\sigma = E_{\\mathrm{eff}} \\frac{\\sigma}{L} \\left( \\sum_{i=1}^{N} \\frac{h_i}{E_i} + \\sum_{j=1}^{N-1} \\frac{1}{k_j} \\right) $$\nSolving for $E_{\\mathrm{eff}}$ yields:\n$$ E_{\\mathrm{eff}} = \\frac{L}{\\sum_{i=1}^{N} \\frac{h_i}{E_i} + \\sum_{j=1}^{N-1} \\frac{1}{k_j}} = \\frac{\\sum_{i=1}^{N} h_i}{\\sum_{i=1}^{N} \\frac{h_i}{E_i} + \\sum_{j=1}^{N-1} \\frac{1}{k_j}} $$\nThis result can also be obtained by formulating and solving the variational problem for the unit cell's potential energy, which confirms the validity of this direct approach for the 1D case.\n\n**3. Series Model Modulus ($E_{\\mathrm{series}}$)**\n\nThe rule-of-mixtures prediction for perfectly bonded layers corresponds to a model where the interfaces are infinitely stiff, meaning they have zero compliance. This is achieved by taking the limit $k_j \\to \\infty$ for all interfaces. In this limit, the interface compliance term $\\sum_{j=1}^{N-1} (1/k_j)$ vanishes.\n$$ \\lim_{k_j \\to \\infty} \\left( \\sum_{j=1}^{N-1} \\frac{1}{k_j} \\right) = 0 $$\nThe effective modulus for this series model, $E_{\\mathrm{series}}$, is therefore:\n$$ E_{\\mathrm{series}} = \\frac{\\sum_{i=1}^{N} h_i}{\\sum_{i=1}^{N} \\frac{h_i}{E_i}} $$\nThis is the thickness-weighted harmonic mean of the layer moduli, the standard result for a layered composite loaded in series.\n\n**4. Fractional Reduction due to Interfacial Compliance**\n\nThe fractional reduction in stiffness due to the presence of compliant interfaces is quantified by the ratio $(E_{\\mathrm{eff}} - E_{\\mathrm{series}})/E_{\\mathrm{series}}$.\n$$ \\frac{E_{\\mathrm{eff}} - E_{\\mathrm{series}}}{E_{\\mathrm{series}}} = \\frac{E_{\\mathrm{eff}}}{E_{\\mathrm{series}}} - 1 $$\nSubstituting the derived expressions:\n$$ \\frac{E_{\\mathrm{eff}}}{E_{\\mathrm{series}}} = \\frac{\\left( \\frac{L}{\\sum \\frac{h_i}{E_i} + \\sum \\frac{1}{k_j}} \\right)}{\\left( \\frac{L}{\\sum \\frac{h_i}{E_i}} \\right)} = \\frac{\\sum_{i=1}^{N} \\frac{h_i}{E_i}}{\\sum_{i=1}^{N} \\frac{h_i}{E_i} + \\sum_{j=1}^{N-1} \\frac{1}{k_j}} $$\nThus, the fractional reduction is:\n$$ \\frac{E_{\\mathrm{eff}} - E_{\\mathrm{series}}}{E_{\\mathrm{series}}} = \\frac{\\sum \\frac{h_i}{E_i}}{\\sum \\frac{h_i}{E_i} + \\sum \\frac{1}{k_j}} - 1 = \\frac{\\sum \\frac{h_i}{E_i} - \\left( \\sum \\frac{h_i}{E_i} + \\sum \\frac{1}{k_j} \\right)}{\\sum \\frac{h_i}{E_i} + \\sum \\frac{1}{k_j}} = \\frac{-\\sum_{j=1}^{N-1} \\frac{1}{k_j}}{\\sum_{i=1}^{N} \\frac{h_i}{E_i} + \\sum_{j=1}^{N-1} \\frac{1}{k_j}} $$\nThis expression correctly shows that the reduction is always negative (or zero if $k_j \\to \\infty$), as the interfaces add compliance to the system, thereby reducing its overall stiffness.\n\n**5. Calculation Procedure**\nFor each test case, the following quantities are calculated. All intermediate calculations are performed in base SI units (m, Pa, Pa/m).\n1.  Total length: $L = \\sum_{i=1}^{N} h_i$.\n2.  Total bulk compliance: $C_{\\text{bulk}} = \\sum_{i=1}^{N} \\frac{h_i}{E_i}$. Note that $E_i$ in GPa must be converted to Pa by multiplying by $10^9$.\n3.  Total interface compliance: $C_{\\text{iface}} = \\sum_{j=1}^{N-1} \\frac{1}{k_j}$.\n4.  Series modulus: $E_{\\mathrm{series}} = L / C_{\\text{bulk}}$.\n5.  Effective modulus: $E_{\\mathrm{eff}} = L / (C_{\\text{bulk}} + C_{\\text{iface}})$.\n6.  Fractional reduction: $R = (E_{\\mathrm{eff}} - E_{\\mathrm{series}}) / E_{\\mathrm{series}}$.\nThe final values for $E_{\\mathrm{eff}}$ and $E_{\\mathrm{series}}$ are converted from Pa to GPa by dividing by $10^9$ and, along with $R$, are rounded to $6$ decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the effective modulus of a layered composite with cohesive interfaces.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (two layers, near-perfect interface)\n        {'h': [1.0e-6, 1.0e-6], 'E': [100, 200], 'k': [1.0e20]},\n        # Test case 2 (two layers, finite interface compliance)\n        {'h': [1.0e-6, 1.0e-6], 'E': [100, 200], 'k': [1.0e18]},\n        # Test case 3 (two layers, one very soft layer and moderate compliance)\n        {'h': [1.5e-6, 0.5e-6], 'E': [5, 200], 'k': [1.0e14]},\n        # Test case 4 (three layers, mixed moduli and interfaces)\n        {'h': [1.0e-6, 1.0e-6, 1.0e-6], 'E': [70, 3, 150], 'k': [1.0e13, 1.0e20]},\n        # Test case 5 (two layers, extremely compliant interface)\n        {'h': [1.0e-6, 1.0e-6], 'E': [120, 120], 'k': [1.0e9]}\n    ]\n\n    results = []\n    for case in test_cases:\n        h_i = np.array(case['h'])  # Layer thicknesses in m\n        E_i_gpa = np.array(case['E'])  # Layer moduli in GPa\n        k_j = np.array(case['k'])  # Interfacial stiffnesses in Pa/m\n\n        # Convert moduli to Pa for SI unit consistency\n        E_i_pa = E_i_gpa * 1e9\n\n        # Total length of the unit cell\n        L = np.sum(h_i)\n\n        # Calculate the total compliance from the bulk layers\n        # C_bulk = sum(h / E)\n        bulk_compliance = np.sum(h_i / E_i_pa)\n\n        # Calculate the total compliance from the interfaces\n        # C_iface = sum(1 / k)\n        interface_compliance = np.sum(1.0 / k_j)\n\n        # Calculate E_series (perfectly bonded interfaces) in Pa\n        # E_series = L / C_bulk\n        E_series_pa = L / bulk_compliance\n\n        # Calculate E_eff (with compliant interfaces) in Pa\n        # E_eff = L / (C_bulk + C_iface)\n        E_eff_pa = L / (bulk_compliance + interface_compliance)\n        \n        # Convert final moduli back to GPa\n        E_series_gpa = E_series_pa / 1e9\n        E_eff_gpa = E_eff_pa / 1e9\n\n        # Calculate the fractional reduction\n        # This can be calculated directly from moduli to avoid re-calculation\n        # which can introduce small floating point differences.\n        if E_series_gpa == 0:\n            # Avoid division by zero, though not expected in these test cases\n            reduction = -1.0 if E_eff_gpa < E_series_gpa else 0.0\n        else:\n            reduction = (E_eff_gpa - E_series_gpa) / E_series_gpa\n            \n        # Round results to 6 decimal places\n        E_eff_rounded = round(E_eff_gpa, 6)\n        E_series_rounded = round(E_series_gpa, 6)\n        reduction_rounded = round(reduction, 6)\n\n        results.append([E_eff_rounded, E_series_rounded, reduction_rounded])\n\n    # Format the output string as [[val1,val2,val3],[...],...]\n    case_strings = []\n    for res_list in results:\n        # Format each number to 6 decimal places to ensure trailing zeros\n        formatted_list = [f\"{x:.6f}\" for x in res_list]\n        case_strings.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond static mechanical properties, multiscale modeling must also capture the dynamics of material evolution, such as diffusion or phase transformations. This practice introduces the parameterization of kinetic rates using Transition State Theory (TST) . You will use data from atomistic path-finding methods to compute an activation energy and vibrational prefactor, thereby constructing an Arrhenius rate constant ready for use in continuum-scale simulations.",
            "id": "3829238",
            "problem": "You are tasked with constructing an Arrhenius rate law from atomistic inputs suitable for passing parameters to continuum-scale models in multiscale materials simulation. Specifically, you must compute the activation energy and the harmonic transition state theory prefactor for a representative thermally activated event using atomistic data produced by Nudged Elastic Band (NEB) and Hessian normal mode analysis, and then assemble the temperature-dependent rate constant.\n\nStarting from fundamental bases applicable to this context:\n- Transition State Theory (TST): The rate of a thermally activated event at temperature $T$ can be expressed as $k(T) = \\nu \\exp\\!\\left(-E_a / (k_B T)\\right)$, where $E_a$ is the activation energy, $\\nu$ is a prefactor determined by vibrational free energy differences between the reactant basin and the saddle (transition state), and $k_B$ is the Boltzmann constant.\n- Harmonic approximation in the classical limit: The vibrational partition function of a harmonic oscillator mode with frequency $\\nu_i$ reduces to a factor proportional to $k_B T / (h \\nu_i)$, where $h$ is Planck's constant. The harmonic TST prefactor in the classical limit eliminates the explicit temperature factor and becomes the ratio of products of positive stable-mode frequencies (with translational zero modes and the single unstable mode removed at the saddle).\n\nYour program must implement the following scientifically sound and algorithmically precise steps:\n\n1. Determine the activation energy $E_a$ from NEB image energies given as a list of values in electronvolts. Compute $E_a$ as the difference between the maximum and the minimum energy along the NEB path, i.e.,\n   $$E_a = \\max_i E_i - \\min_i E_i,$$\n   where $E_i$ are the NEB image energies in electronvolts.\n\n2. Compute the harmonic TST prefactor $\\nu$ using vibrational normal mode frequencies (in terahertz) obtained from Hessian diagonalization at the reactant and the saddle point. Adopt the following physically justified filtering rules:\n   - Convert all frequencies from terahertz to hertz using the relation $1\\,\\mathrm{THz} = 10^{12}\\,\\mathrm{Hz}$.\n   - At the saddle, exclude any frequency that is negative (this represents the single unstable mode along the reaction coordinate).\n   - At both the reactant and the saddle, remove the three translational zero modes by discarding the three frequencies with the smallest absolute values among the non-negative frequencies.\n   - After filtering, let $\\{\\nu_i^{R}\\}$ denote the remaining positive frequencies at the reactant and $\\{\\nu_j^{\\ddagger}\\}$ denote the remaining positive frequencies at the saddle. The harmonic classical prefactor is then\n     $$\\nu = \\frac{\\prod_i \\nu_i^{R}}{\\prod_j \\nu_j^{\\ddagger}},$$\n     which yields a quantity in $\\mathrm{s}^{-1}$.\n\n3. Assemble the Arrhenius form\n   $$k(T) = \\nu \\exp\\!\\left(-\\frac{E_a}{k_B T}\\right),$$\n   where $k_B$ in the exponential must be used in electronvolts per kelvin to maintain unit consistency with $E_a$ in electronvolts and $T$ in kelvins. Your final $k(T)$ must be reported in $\\mathrm{s}^{-1}$.\n\n4. Your program must implement the above logic and compute $k(T)$ for the provided test suite. It must output a single line containing a comma-separated list of floats enclosed in square brackets, corresponding to the $k(T)$ values for each test case in order. Each float must be rounded to six significant figures. The unit is $\\mathrm{s}^{-1}$.\n\nTest Suite (all energies are in electronvolts, all frequencies are in terahertz, all temperatures are in kelvins):\n- Case A (happy path): NEB energies $[0.0, 0.35, 0.62, 0.58, 0.61]$, reactant frequencies $[3.0, 4.5, 5.1, 0.01, 0.02, 0.03]$, saddle frequencies $[4.8, 5.3, -1.5, 0.01, 0.02, 0.03]$, temperature $T = 1000$, report $k(T)$ in $\\mathrm{s}^{-1}$.\n- Case B (low-temperature boundary): NEB energies $[0.0, 0.40, 0.65, 0.64, 0.60]$, reactant frequencies $[3.1, 4.4, 5.0, 0.01, 0.02, 0.03]$, saddle frequencies $[4.7, 5.2, -1.4, 0.01, 0.02, 0.03]$, temperature $T = 200$, report $k(T)$ in $\\mathrm{s}^{-1}$.\n- Case C (nearly degenerate vibrational modes): NEB energies $[0.0, 0.10, 0.31, 0.29, 0.30]$, reactant frequencies $[2.2, 2.3, 2.2, 0.004, 0.005, 0.006]$, saddle frequencies $[1.9, 2.4, -0.8, 0.004, 0.005, 0.006]$, temperature $T = 800$, report $k(T)$ in $\\mathrm{s}^{-1}$.\n- Case D (high barrier edge): NEB energies $[0.0, 0.50, 1.20, 1.15, 1.18]$, reactant frequencies $[6.0, 6.1, 6.2, 0.01, 0.01, 0.01]$, saddle frequencies $[5.9, 6.0, -1.0, 0.01, 0.01, 0.01]$, temperature $T = 1200$, report $k(T)$ in $\\mathrm{s}^{-1}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4]$), where each $r_i$ is the rate constant $k(T)$ in $\\mathrm{s}^{-1}$ for the corresponding test case, rounded to six significant figures.",
            "solution": "We derive and implement the computation of the Arrhenius rate constant by parameter passing from atomistic to continuum scales using principled foundations of Transition State Theory (TST), harmonic approximations, and NEB-derived activation barriers.\n\n1. Fundamental base: Transition State Theory and Arrhenius form.\nWe start from Transition State Theory (TST), which connects microscopic barrier crossing dynamics with macroscopic rate constants. In TST, the rate of a thermally activated event is given by\n$$k(T) = \\frac{k_B T}{h} \\frac{Q^{\\ddagger}}{Q^{R}} \\exp\\!\\left(-\\frac{E_a}{k_B T}\\right),$$\nwhere $Q^{R}$ and $Q^{\\ddagger}$ are the partition functions of the reactant basin and the saddle constrained to the dividing surface, respectively, $E_a$ is the activation energy (the difference in potential energy between the saddle and the reactant minima), $k_B$ is Boltzmann’s constant, $h$ is Planck’s constant, and $T$ is the absolute temperature in kelvins.\n\n2. Harmonic classical approximation for the prefactor.\nUnder the harmonic approximation, the vibrational modes at the reactant and saddle are modeled as independent harmonic oscillators with frequencies $\\nu_i^{R}$ and $\\nu_j^{\\ddagger}$. In the classical high-temperature limit, the vibrational partition function of a single mode of frequency $\\nu$ becomes\n$$q_{\\mathrm{vib}} \\approx \\frac{k_B T}{h \\nu}.$$\nTherefore, the ratio of vibrational partition functions becomes\n$$\\frac{Q^{\\ddagger}}{Q^{R}} \\approx \\frac{\\prod_j \\frac{k_B T}{h \\nu_j^{\\ddagger}}}{\\prod_i \\frac{k_B T}{h \\nu_i^{R}}} = \\left(\\frac{h}{k_B T}\\right)^{\\Delta f} \\frac{\\prod_i \\nu_i^{R}}{\\prod_j \\nu_j^{\\ddagger}},$$\nwhere $\\Delta f = f_R - f_{\\ddagger}$ is the difference in the number of real positive vibrational modes between the reactant and the saddle after removing irrelevant modes. For a $3N$-degree-of-freedom cluster, both the reactant and saddle possess three translational zero modes that must be removed. The saddle further contains one unstable direction along the reaction coordinate represented by an imaginary (negative) frequency that is excluded. Consequently, $f_R - f_{\\ddagger} = 1$ in typical cases. Substituting this into the TST expression yields\n$$k(T) = \\frac{k_B T}{h} \\left(\\frac{h}{k_B T}\\right) \\frac{\\prod_i \\nu_i^{R}}{\\prod_j \\nu_j^{\\ddagger}} \\exp\\!\\left(-\\frac{E_a}{k_B T}\\right)\n= \\left( \\frac{\\prod_i \\nu_i^{R}}{\\prod_j \\nu_j^{\\ddagger}} \\right) \\exp\\!\\left(-\\frac{E_a}{k_B T}\\right).$$\nThus, in the classical harmonic limit, the prefactor becomes temperature-independent and equals\n$$\\nu = \\frac{\\prod_i \\nu_i^{R}}{\\prod_j \\nu_j^{\\ddagger}},$$\nwhere all translational zero modes and the unstable mode at the saddle have been removed prior to taking the products, and all remaining frequencies are positive.\n\n3. Activation energy from Nudged Elastic Band (NEB).\nThe Nudged Elastic Band (NEB) method discretizes the minimum energy path (MEP) with images and provides the energy profile $E_i$ along the path. The activation energy is the maximum increase from the reactant minimum along the path. In a robust algorithmic form, we compute\n$$E_a = \\max_i E_i - \\min_i E_i.$$\nThis approach automatically accounts for the reactant baseline within the given data.\n\n4. Algorithmic design for frequency filtering.\nTo compute $\\nu$, we proceed with the following steps:\n- Convert all supplied frequencies from terahertz to hertz using the linear relation $1\\,\\mathrm{THz} = 10^{12}\\,\\mathrm{Hz}$ to ensure consistent units.\n- At the saddle, remove any negative frequencies, which represent the single unstable mode associated with barrier crossing.\n- At both the reactant and saddle, remove three translational zero modes by discarding the three frequencies with the smallest absolute values among the non-negative frequencies. This is consistent with the physics of a finite cluster in three-dimensional space, which has three global translations with near-zero frequencies in Hessian normal mode analysis.\n- Compute the product of the remaining positive frequencies at the reactant, $\\prod_i \\nu_i^{R}$, and at the saddle, $\\prod_j \\nu_j^{\\ddagger}$, and form the ratio to obtain $\\nu$ in $\\mathrm{s}^{-1}$.\n\n5. Assembling the Arrhenius rate law.\nWith $\\nu$ and $E_a$ determined, we compute\n$$k(T) = \\nu \\exp\\!\\left(-\\frac{E_a}{k_B T}\\right),$$\nusing $k_B$ in electronvolts per kelvin (so that $E_a$ in electronvolts and $T$ in kelvins yield a dimensionless exponent). The final $k(T)$ should be reported in $\\mathrm{s}^{-1}$.\n\n6. Units and numerical constants.\n- Use $k_B = 8.617333262145\\times 10^{-5}\\,\\mathrm{eV/K}$ in the exponential to maintain unit consistency.\n- Convert terahertz to hertz via $1\\,\\mathrm{THz} = 10^{12}\\,\\mathrm{Hz}$.\n- The computed prefactor $\\nu$ has units $\\mathrm{s}^{-1}$ and the final rate constant $k(T)$ is in $\\mathrm{s}^{-1}$.\n\n7. Test suite coverage rationale.\n- Case A is a typical scenario with a moderate barrier and well-behaved vibrational spectra.\n- Case B probes the low-temperature boundary where the exponential suppression dominates, testing numerical stability.\n- Case C uses nearly degenerate vibrational modes to examine the sensitivity of the prefactor to small spectral changes.\n- Case D is a high-barrier edge case that should yield very small rates, evaluating stability of the products and exponentials.\n\n8. Output specification.\nThe program must compute $k(T)$ for each case and print a single line with a comma-separated list enclosed in square brackets, e.g., $[r_1,r_2,r_3,r_4]$, where each $r_i$ is rounded to six significant figures and has units $\\mathrm{s}^{-1}$.\n\nThis workflow passes atomistically computed parameters ($E_a$ and $\\nu$) to a continuum-scale descriptor ($k(T)$), enabling subsequent use in continuum transport models such as diffusion, where the rate constant directly informs macroscopic coefficients.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Constants\nK_B_EV_PER_K = 8.617333262145e-5  # Boltzmann constant in eV/K\nTHZ_TO_HZ = 1.0e12                # 1 THz = 1e12 Hz\n\ndef compute_activation_energy(neb_energies_ev):\n    \"\"\"\n    Compute activation energy E_a from NEB energies in eV as max - min.\n    \"\"\"\n    energies = np.array(neb_energies_ev, dtype=float)\n    Ea = float(np.max(energies) - np.min(energies))\n    return Ea\n\ndef filter_frequencies(freqs_thz, remove_imaginary=False):\n    \"\"\"\n    Convert THz to Hz, optionally remove negative (imaginary) frequencies,\n    then remove the three smallest-by-magnitude non-negative frequencies (translations).\n    Return the remaining positive frequencies in Hz.\n    \"\"\"\n    freqs_hz = np.array(freqs_thz, dtype=float) * THZ_TO_HZ\n\n    # Remove imaginary (negative) if requested\n    if remove_imaginary:\n        freqs_hz = freqs_hz[freqs_hz >= 0.0]\n\n    # Split into non-negative and negative just in case (negatives shouldn't remain if remove_imaginary=True)\n    nonneg = freqs_hz[freqs_hz >= 0.0]\n\n    # If fewer than or equal to 3 non-negative frequencies, removing translations would empty the set.\n    # We still attempt to remove three smallest by magnitude; cap at available count.\n    if nonneg.size == 0:\n        return np.array([], dtype=float)\n\n    # Identify indices of the three smallest-by-magnitude non-negative frequencies (translations)\n    # Use absolute value for magnitude comparison\n    magnitudes = np.abs(nonneg)\n    # argsort returns indices in ascending order of magnitude\n    sort_idx = np.argsort(magnitudes)\n    # Number to remove: up to 3 or fewer if not enough\n    n_remove = min(3, nonneg.size)\n    remove_idx = sort_idx[:n_remove]\n\n    # Create a mask to keep the rest\n    mask = np.ones(nonneg.shape, dtype=bool)\n    mask[remove_idx] = False\n    remaining = nonneg[mask]\n\n    # Keep only strictly positive frequencies (to avoid zeros or numerical noise)\n    remaining_positive = remaining[remaining > 0.0]\n\n    return remaining_positive\n\ndef compute_prefactor(freqs_reactant_thz, freqs_saddle_thz):\n    \"\"\"\n    Compute harmonic classical TST prefactor nu (s^-1) as product ratio of frequencies\n    after removing translations and the single unstable mode at the saddle.\n    \"\"\"\n    # Filter reactant: remove three translations\n    reactant_filtered_hz = filter_frequencies(freqs_reactant_thz, remove_imaginary=False)\n    # Filter saddle: remove imaginary (negative), then three translations\n    saddle_filtered_hz = filter_frequencies(freqs_saddle_thz, remove_imaginary=True)\n\n    # Safety: if any set becomes empty, prefactor cannot be computed reliably; return 0\n    if reactant_filtered_hz.size == 0 or saddle_filtered_hz.size == 0:\n        return 0.0\n\n    prod_reactant = float(np.prod(reactant_filtered_hz))\n    prod_saddle = float(np.prod(saddle_filtered_hz))\n\n    # Avoid division by zero\n    if prod_saddle == 0.0:\n        return 0.0\n\n    nu = prod_reactant / prod_saddle\n    return nu\n\ndef arrhenius_rate_constant(neb_energies_ev, freqs_reactant_thz, freqs_saddle_thz, temperature_k):\n    \"\"\"\n    Compute k(T) = nu * exp(-Ea / (k_B T))\n    where Ea is from NEB energies (eV), k_B in eV/K, T in K, nu in s^-1 from harmonic TST.\n    \"\"\"\n    Ea_ev = compute_activation_energy(neb_energies_ev)\n    nu_s_inv = compute_prefactor(freqs_reactant_thz, freqs_saddle_thz)\n\n    # Exponential argument using k_B in eV/K\n    exponent = -Ea_ev / (K_B_EV_PER_K * float(temperature_k))\n    k_T = nu_s_inv * np.exp(exponent)\n    return k_T\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (NEB energies eV list, reactant freqs THz list, saddle freqs THz list, T in K)\n    test_cases = [\n        (\n            [0.0, 0.35, 0.62, 0.58, 0.61],\n            [3.0, 4.5, 5.1, 0.01, 0.02, 0.03],\n            [4.8, 5.3, -1.5, 0.01, 0.02, 0.03],\n            1000\n        ),\n        (\n            [0.0, 0.40, 0.65, 0.64, 0.60],\n            [3.1, 4.4, 5.0, 0.01, 0.02, 0.03],\n            [4.7, 5.2, -1.4, 0.01, 0.02, 0.03],\n            200\n        ),\n        (\n            [0.0, 0.10, 0.31, 0.29, 0.30],\n            [2.2, 2.3, 2.2, 0.004, 0.005, 0.006],\n            [1.9, 2.4, -0.8, 0.004, 0.005, 0.006],\n            800\n        ),\n        (\n            [0.0, 0.50, 1.20, 1.15, 1.18],\n            [6.0, 6.1, 6.2, 0.01, 0.01, 0.01],\n            [5.9, 6.0, -1.0, 0.01, 0.01, 0.01],\n            1200\n        )\n    ]\n\n    results = []\n    for neb_energies_ev, freqs_reactant_thz, freqs_saddle_thz, T_K in test_cases:\n        k_T = arrhenius_rate_constant(neb_energies_ev, freqs_reactant_thz, freqs_saddle_thz, T_K)\n        # Round to six significant figures\n        results.append(f\"{k_T:.6g}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}