{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of calculating diffusion coefficients from molecular dynamics simulations is the Einstein relation, which predicts a linear relationship between Mean Squared Displacement (MSD) and time in the diffusive regime. This first exercise provides a direct, hands-on application of this principle. By performing a linear regression on provided MSD data within a specified time window, you will solidify your understanding of the fundamental formula, $\\text{MSD}(t) = 2dDt$, and practice the essential skill of extracting the scalar diffusion coefficient $D$ .",
            "id": "3794095",
            "problem": "You are given time series of Mean Squared Displacement (MSD) data constructed from atomistic trajectories in different spatial dimensionalities. The goal is to extract the scalar diffusion coefficient $D$ from the slope of the MSD versus time $t$ in a regime where normal diffusion holds. Start from a valid base in multiscale materials simulation: the diffusion equation for a conserved scalar density, its Gaussian fundamental solution, and the definition of MSD. Use these foundations to justify a linear relationship between MSD and time in the diffusive regime and to design a computational procedure that estimates $D$ from MSD data.\n\nYour program must implement the following principle-based tasks:\n- Use the definition of Mean Squared Displacement (MSD) for a random process in $d$ spatial dimensions and the governing diffusion equation to justify that, in the normal diffusion regime, the MSD grows linearly with time and the proportionality constant encodes the diffusion coefficient with a dependence on the spatial dimensionality $d$.\n- Perform a statistically sound linear regression on the MSD versus time data restricted to a specified time window $\\left[t_{\\min}, t_{\\max}\\right]$ in which normal diffusion is expected to hold, avoiding early-time ballistic motion and late-time confinement or caging.\n- Convert the estimated MSD slope to the scalar diffusion coefficient $D$ that is consistent with the $d$-dimensional setting, and report $D$ in nanometer squared per nanosecond ($\\mathrm{nm}^2/\\mathrm{ns}$).\n- Round each reported diffusion coefficient to three decimal places.\n\nPhysical units:\n- Time $t$ is given in nanoseconds ($\\mathrm{ns}$).\n- Mean Squared Displacement (MSD) is given in nanometer squared ($\\mathrm{nm}^2$).\n- Diffusion coefficients must be expressed in $\\mathrm{nm}^2/\\mathrm{ns}$.\n\nYour program must use the provided test suite and produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_1,x_2,x_3,x_4]$), where each $x_i$ is the diffusion coefficient for the $i$-th test case, rounded to three decimal places.\n\nTest suite:\n- Test case $1$ (happy path, three-dimensional isotropic diffusion):\n  - Spatial dimensionality $d = 3$.\n  - Time array $t = [0.5, 1.0, 1.5, 2.0, 2.5]$ in $\\mathrm{ns}$.\n  - MSD array $\\mathrm{MSD}(t) = [1.47, 3.02, 4.49, 6.04, 7.50]$ in $\\mathrm{nm}^2$.\n  - Analysis window $\\left[t_{\\min}, t_{\\max}\\right] = [0.5, 2.5]$ in $\\mathrm{ns}$.\n\n- Test case $2$ (two-dimensional, early-time ballistic regime excluded via window):\n  - Spatial dimensionality $d = 2$.\n  - Time array $t = [0.0, 0.1, 0.2, 0.3, 0.5, 0.6, 0.8, 1.0]$ in $\\mathrm{ns}$.\n  - MSD array $\\mathrm{MSD}(t) = [0.00, 0.09, 0.36, 0.81, 1.80, 2.23, 3.22, 4.13]$ in $\\mathrm{nm}^2$.\n  - Analysis window $\\left[t_{\\min}, t_{\\max}\\right] = [0.5, 1.0]$ in $\\mathrm{ns}$.\n\n- Test case $3$ (three-dimensional anisotropic principal diffusivities aggregated into scalar MSD):\n  - Spatial dimensionality $d = 3$.\n  - Time array $t = [0.2, 0.4, 0.6, 0.8, 1.0, 1.2]$ in $\\mathrm{ns}$.\n  - MSD array $\\mathrm{MSD}(t) = [0.74, 1.43, 2.19, 2.86, 3.60, 4.33]$ in $\\mathrm{nm}^2$.\n  - Analysis window $\\left[t_{\\min}, t_{\\max}\\right] = [0.2, 1.2]$ in $\\mathrm{ns}$.\n\n- Test case $4$ (one-dimensional, confinement causing long-time plateau; extract from early-time window):\n  - Spatial dimensionality $d = 1$.\n  - Time array $t = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6]$ in $\\mathrm{ns}$.\n  - MSD array $\\mathrm{MSD}(t) = [0.00, 0.34, 0.75, 1.07, 1.46, 1.86, 1.95, 1.99, 2.01]$ in $\\mathrm{nm}^2$.\n  - Analysis window $\\left[t_{\\min}, t_{\\max}\\right] = [0.2, 0.8]$ in $\\mathrm{ns}$.\n\nAlgorithmic requirements:\n- For each test case, select all data pairs $(t_i, \\mathrm{MSD}_i)$ with $t_{\\min} \\le t_i \\le t_{\\max}$.\n- Fit a straight line $\\mathrm{MSD}(t) \\approx S \\, t + C$ by least squares on the selected window to estimate the slope $S$.\n- Convert the slope to the scalar diffusion coefficient $D$ consistent with the $d$-dimensional setting.\n- Report each $D$ as a floating-point number in $\\mathrm{nm}^2/\\mathrm{ns}$, rounded to three decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_1,x_2,x_3,x_4]$), where each $x_i$ corresponds to the diffusion coefficient for test case $i$, rounded to three decimal places.",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, objective, and internally consistent. It presents a standard task in computational materials science: the extraction of a transport coefficient from time-series data generated by a simulation. The provided data and parameters are sufficient and physically plausible.\n\nOur procedure is constructed from first principles, beginning with the macroscopic diffusion equation and connecting it to the microscopic statistical definition of mean squared displacement.\n\nA fundamental tenet of statistical mechanics is that macroscopic diffusion, governed by Fick's laws, is the collective result of microscopic random walks of constituent particles. For a conserved quantity with concentration $\\rho(\\mathbf{r}, t)$, its evolution in a homogeneous, isotropic medium is described by the diffusion equation. In $d$ spatial dimensions, this is:\n$$\n\\frac{\\partial \\rho(\\mathbf{r}, t)}{\\partial t} = D \\nabla^2 \\rho(\\mathbf{r}, t)\n$$\nwhere $D$ is the scalar diffusion coefficient, and $\\nabla^2$ is the $d$-dimensional Laplacian operator. For a single particle starting at the origin $\\mathbf{r}(0) = \\mathbf{0}$, the concentration $\\rho$ can be interpreted as the probability density function for the particle's position. The solution to the diffusion equation for an instantaneous point source at the origin (a delta function initial condition $\\rho(\\mathbf{r}, 0) = \\delta(\\mathbf{r})$) is the Gaussian or fundamental solution:\n$$\n\\rho(\\mathbf{r}, t) = \\frac{1}{(4 \\pi D t)^{d/2}} \\exp\\left(-\\frac{|\\mathbf{r}|^2}{4 D t}\\right)\n$$\nThis function describes the probability of finding the particle at position $\\mathbf{r}$ at time $t$.\n\nThe Mean Squared Displacement, $\\mathrm{MSD}(t)$, is defined as the ensemble average of the squared Euclidean distance traveled by a particle from its origin over a time interval $t$. For a particle starting at the origin, this is:\n$$\n\\mathrm{MSD}(t) = \\langle |\\mathbf{r}(t)|^2 \\rangle\n$$\nThis expectation value can be calculated by integrating over all possible positions, weighted by the probability density $\\rho(\\mathbf{r}, t)$:\n$$\n\\mathrm{MSD}(t) = \\int_{\\mathbb{R}^d} |\\mathbf{r}|^2 \\rho(\\mathbf{r}, t) \\, d^d\\mathbf{r}\n$$\nSubstituting the Gaussian solution for $\\rho(\\mathbf{r}, t)$ and recognizing that $|\\mathbf{r}|^2 = \\sum_{i=1}^d x_i^2$, the integral becomes:\n$$\n\\mathrm{MSD}(t) = \\sum_{i=1}^d \\int_{\\mathbb{R}^d} x_i^2 \\frac{1}{(4 \\pi D t)^{d/2}} \\exp\\left(-\\sum_{j=1}^d \\frac{x_j^2}{4 D t}\\right) \\, d x_1 \\dots d x_d\n$$\nThe integral separates into a product of one-dimensional integrals. For each coordinate $x_i$, the term $\\int_{-\\infty}^{\\infty} x_i^2 \\frac{1}{\\sqrt{4 \\pi D t}} \\exp(-\\frac{x_i^2}{4 D t}) \\, dx_i$ is the second moment (variance) of a one-dimensional Gaussian distribution with mean $0$ and variance $\\sigma^2 = 2Dt$. The value of this integral is precisely $2Dt$. Since all other one-dimensional integrals of the form $\\int_{-\\infty}^{\\infty} \\rho(x_j, t) \\, dx_j$ for $j \\neq i$ are equal to $1$, we find that $\\langle x_i^2 \\rangle = 2Dt$ for each dimension $i$. Summing over all $d$ dimensions gives the celebrated Einstein relation for normal diffusion:\n$$\n\\mathrm{MSD}(t) = \\sum_{i=1}^d \\langle x_i(t)^2 \\rangle = \\sum_{i=1}^d 2Dt = 2dDt\n$$\nThis equation establishes a direct linear relationship between the mean squared displacement and time, $\\mathrm{MSD}(t) = S \\cdot t$, where the slope $S$ is given by $S = 2dD$. Consequently, the diffusion coefficient $D$ can be determined from the empirically measured slope of an MSD-versus-time plot via the formula:\n$$\nD = \\frac{S}{2d}\n$$\nThe problem specifies that material simulation data for $\\mathrm{MSD}(t)$ is provided. This data is subject to statistical noise and may exhibit different physical regimes. At very short times (ballistic regime, $t \\to 0$), $\\mathrm{MSD} \\propto t^2$. At very long times, particles might be affected by finite-size effects or confinement (caging), causing the MSD to plateau. The linear, diffusive regime lies between these two extremes. The task is to estimate $D$ by analyzing the data within a specified time window $[t_{\\min}, t_{\\max}]$ where this linear, diffusive behavior is expected to dominate.\n\nThe computational procedure is as follows:\n$1$. For each test case, the provided time array $t$ and $\\mathrm{MSD}$ array are filtered to retain only the data points $(t_i, \\mathrm{MSD}_i)$ that fall within the specified analysis window, i.e., where $t_{\\min} \\le t_i \\le t_{\\max}$. Let the filtered data set be denoted as $\\{(t'_j, y'_j)\\}_{j=1}^N$.\n\n$2$. A linear model, $y'(t') = S t' + C$, is fitted to this filtered data set using the method of ordinary least squares (OLS). The goal is to find the slope $S$ and intercept $C$ that minimize the sum of the squared residuals. The formula for the slope $S$ is:\n$$\nS = \\frac{N \\sum_{j=1}^{N} t'_j y'_j - (\\sum_{j=1}^{N} t'_j)(\\sum_{j=1}^{N} y'_j)}{N \\sum_{j=1}^{N} (t'_j)^2 - (\\sum_{j=1}^{N} t'_j)^2}\n$$\nThis calculation will be performed numerically.\n\n$3$. With the slope $S$ determined from the linear regression, the diffusion coefficient $D$ is calculated using the derived relationship for the appropriate spatial dimensionality $d$:\n$$\nD = \\frac{S}{2d}\n$$\nThe units of $t$ are nanoseconds ($\\mathrm{ns}$) and the units of $\\mathrm{MSD}$ are nanometers squared ($\\mathrm{nm}^2$), so the slope $S$ has units of $\\mathrm{nm}^2/\\mathrm{ns}$. The resulting diffusion coefficient $D$ will also have units of $\\mathrm{nm}^2/\\mathrm{ns}$, as required.\n\n$4$. The final calculated value of $D$ for each test case is rounded to three decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates diffusion coefficients from Mean Squared Displacement (MSD) data\n    for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path, three-dimensional isotropic diffusion)\n        {\n            \"d\": 3,\n            \"t\": np.array([0.5, 1.0, 1.5, 2.0, 2.5]),\n            \"msd\": np.array([1.47, 3.02, 4.49, 6.04, 7.50]),\n            \"window\": (0.5, 2.5)\n        },\n        # Test case 2 (two-dimensional, early-time ballistic regime excluded via window)\n        {\n            \"d\": 2,\n            \"t\": np.array([0.0, 0.1, 0.2, 0.3, 0.5, 0.6, 0.8, 1.0]),\n            \"msd\": np.array([0.00, 0.09, 0.36, 0.81, 1.80, 2.23, 3.22, 4.13]),\n            \"window\": (0.5, 1.0)\n        },\n        # Test case 3 (three-dimensional anisotropic principal diffusivities aggregated into scalar MSD)\n        {\n            \"d\": 3,\n            \"t\": np.array([0.2, 0.4, 0.6, 0.8, 1.0, 1.2]),\n            \"msd\": np.array([0.74, 1.43, 2.19, 2.86, 3.60, 4.33]),\n            \"window\": (0.2, 1.2)\n        },\n        # Test case 4 (one-dimensional, confinement causing long-time plateau; extract from early-time window)\n        {\n            \"d\": 1,\n            \"t\": np.array([0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6]),\n            \"msd\": np.array([0.00, 0.34, 0.75, 1.07, 1.46, 1.86, 1.95, 1.99, 2.01]),\n            \"window\": (0.2, 0.8)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current case\n        d = case[\"d\"]\n        t_full = case[\"t\"]\n        msd_full = case[\"msd\"]\n        t_min, t_max = case[\"window\"]\n\n        # Step 1: Select data within the specified time window\n        # Create a boolean mask for times within the window [t_min, t_max]\n        indices = (t_full = t_min)  (t_full = t_max)\n        t_window = t_full[indices]\n        msd_window = msd_full[indices]\n        \n        # Step 2: Fit a straight line by least squares to estimate the slope S\n        # np.polyfit with degree 1 performs a linear regression and returns [slope, intercept]\n        if len(t_window)  2:\n            # Not enough points for a linear fit, though problem guarantees this won't happen.\n            # Handle this case gracefully if it were a general function.\n            slope = np.nan\n        else:\n            # The model is MSD(t) = S*t + C\n            coeffs = np.polyfit(t_window, msd_window, 1)\n            slope = coeffs[0]\n\n        # Step 3: Convert the slope to the scalar diffusion coefficient D\n        # The Einstein relation is MSD(t) = 2*d*D*t, so slope S = 2*d*D\n        # Therefore, D = S / (2*d)\n        diffusion_coefficient = slope / (2 * d)\n\n        # Step 4: Round the diffusion coefficient to three decimal places\n        # The result must be a float, not a string at this stage\n        rounded_d = round(diffusion_coefficient, 3)\n        results.append(rounded_d)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) is used to format each float as a string before joining.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real simulation data rarely exhibits a single, clean diffusive regime; effects like short-time ballistic motion or intermediate-time caging in amorphous materials are common. Manually selecting an appropriate linear fitting window can be subjective and error-prone. This practice introduces a more sophisticated, data-driven approach to automatically identify the true diffusive regime by analyzing the local scaling exponent, $\\alpha(t) = \\frac{d \\ln(\\text{MSD})}{d \\ln(t)}$, a powerful method for characterizing complex dynamical behavior .",
            "id": "3731737",
            "problem": "You are given time series of mean square displacement as a function of time, denoted by $MSD(t)$, for structurally disordered, amorphous high-entropy alloys. The goal is to estimate the long-time self-diffusion coefficient $D$ while rigorously excluding contributions from the early-time ballistic regime and the intermediate-time caging regime. Your program must implement a principled, data-adaptive approach that identifies the asymptotically linear regime of $MSD(t)$ without using any fixed, hard-coded time cutoffs.\n\nStarting point and physical bases that you may rely on:\n- For very short times $t$, particle motion retains inertia, with displacements dominated by velocity persistence, and $MSD(t)$ grows approximately as a quadratic function of time.\n- Structural disorder in amorphous systems generates transient “cages” that impede motion, often leading to a near-plateau or sublinear growth of $MSD(t)$ over an intermediate time window.\n- At sufficiently long times, the central limit theorem and loss of memory of initial conditions imply that $MSD(t)$ grows linearly with $t$ in the diffusive regime for an isotropic, homogeneous material in three spatial dimensions.\n\nYour method must:\n1. Detect and exclude both the early-time ballistic and the intermediate-time caging regimes in a data-driven manner by analyzing the local scaling behavior of $MSD(t)$ with respect to $t$. The method must not assume any prior knowledge of the exact cutoff times separating regimes.\n2. Identify a stable time window in which $MSD(t)$ is asymptotically linear with $t$. Within this window, perform a robust line fit of $MSD$ versus $t$ in ordinary (not logarithmic) coordinates.\n3. From the fitted long-time linear behavior in three dimensions, infer the self-diffusion coefficient $D$ and report it in the required units.\n\nMathematical and algorithmic requirements:\n- Use a sliding-window analysis of the local scaling exponent defined by $ \\alpha = \\dfrac{d \\log(MSD)}{d \\log(t)} $ to detect the diffusive regime, where $ \\alpha $ is close to $ 1 $. You must design a quantitative criterion of “sufficiently close” and “sufficiently stable” and justify it algorithmically.\n- Use a robust linear regression for $MSD$ versus $t$ in the candidate diffusive window to mitigate the effect of noise and outliers.\n- Implement a decision rule to choose the final fitting window when multiple candidate windows satisfy your criteria. The rule must prefer windows that are longer and more linear by an appropriate quantitative score.\n- Avoid any fixed, hand-tuned cutoff times expressed directly in time units; all exclusions must be discovered from the data through your criteria.\n\nUnits and output:\n- The input time $t$ is given in picoseconds ($ps$), and the input mean square displacement $MSD$ is given in square nanometers ($nm^2$).\n- You must report the final $D$ in meters squared per second ($m^2/s$).\n- Express the final results as scientific-notation decimal numbers with three significant figures (for example, $1.23 \\times 10^{-8}$ should be printed as $1.23e-08$). The printed format must be a single line containing a comma-separated list enclosed in square brackets, such as $[d_1,d_2,d_3,d_4]$, with no spaces, where each $d_i$ is the estimated diffusion coefficient for the corresponding test case in $m^2/s$.\n\nSynthetic test suite:\nYou must generate four synthetic $MSD(t)$ datasets, each of which is a noisy, smooth composition of three physically motivated components: an early ballistic contribution that decays, a caging plateau that emerges and then decays, and a long-time diffusive growth that turns on gradually. For each dataset, generate a time grid $t_i$ and then construct\n$$\nMSD(t) = v_2\\, t^2 \\, e^{-\\left(\\frac{t}{t_b}\\right)^2}\n\\;+\\; a \\left(1 - e^{-\\left(\\frac{t}{t_c}\\right)^2}\\right) e^{-\\left(\\frac{t}{t_d}\\right)^2}\n\\;+\\; 6 D \\, t \\left(1 - e^{-\\left(\\frac{t}{t_d}\\right)^2}\\right)\n\\;+\\; \\eta,\n$$\nwhere:\n- $t$ is in $ps$,\n- $MSD$ is in $nm^2$,\n- $v_2$ has units $nm^2/ps^2$,\n- $a$ has units $nm^2$,\n- $t_b, t_c, t_d$ have units $ps$,\n- $D$ has units $nm^2/ps$,\n- $\\eta$ is additive zero-mean Gaussian noise with standard deviation $\\sigma$ in $nm^2$; if $MSD(t)$ becomes non-positive at any point due to noise, clip it to a small positive floor $10^{-12}\\,nm^2$ to keep logarithms well-defined.\n\nFor each test case use a uniformly spaced time grid $t_i$ with $N$ points from $t_{\\min}$ to $t_{\\max}$ inclusive, with $t_{\\min} = 10^{-3}\\,ps$. Use the following parameter sets and random seeds to generate the datasets:\n\n- Case $1$ (happy path, clear long diffusive tail):\n  - $N = 1200$, $t_{\\max} = 100$, $v_2 = 0.50$, $a = 0.20$, $t_b = 0.20$, $t_c = 1.00$, $t_d = 5.00$, $D = 0.020$, $\\sigma = 5.0 \\times 10^{-3}$, seed $= 12345$.\n- Case $2$ (extended caging, late-onset diffusion, slower $D$):\n  - $N = 1600$, $t_{\\max} = 200$, $v_2 = 0.70$, $a = 0.50$, $t_b = 0.50$, $t_c = 5.00$, $t_d = 30.0$, $D = 0.0050$, $\\sigma = 3.0 \\times 10^{-3}$, seed $= 24680$.\n- Case $3$ (short trajectory, minimal diffusive window, faster $D$):\n  - $N = 900$, $t_{\\max} = 20.0$, $v_2 = 0.60$, $a = 0.30$, $t_b = 0.80$, $t_c = 3.00$, $t_d = 8.00$, $D = 0.0300$, $\\sigma = 1.0 \\times 10^{-2}$, seed $= 13579$.\n- Case $4$ (noisier data, moderate $D$):\n  - $N = 1400$, $t_{\\max} = 120.0$, $v_2 = 0.40$, $a = 0.25$, $t_b = 0.30$, $t_c = 2.50$, $t_d = 10.0$, $D = 0.0150$, $\\sigma = 2.0 \\times 10^{-2}$, seed $= 11223$.\n\nAll numerical values above are in $ps$ and $nm^2$-based units as indicated. You must convert the final estimated diffusion coefficients to $m^2/s$ using the exact conversion factor $1\\,nm^2/ps = 10^{-6}\\,m^2/s$.\n\nProgram requirements:\n- Implement the data generation and the estimation method exactly as specified.\n- Your program should produce a single line of output containing the results as a comma-separated list of the four estimated diffusion coefficients in $m^2/s$, enclosed in square brackets, with each value printed in scientific notation with three significant figures (e.g., $[2.00e-08,5.00e-09,3.00e-08,1.50e-08]$). No additional text may be printed.",
            "solution": "The ensuing discourse provides a complete solution to the problem of estimating the self-diffusion coefficient from mean square displacement data. The process begins with a mandatory critical validation of the problem statement.\n\n### Step 1: Extract Givens\n\n- **Objective**: Estimate the long-time self-diffusion coefficient $D$ from time series data of mean square displacement, $MSD(t)$.\n- **Physical System**: Structurally disordered, amorphous high-entropy alloys.\n- **Physical Model**: Particle motion exhibits three regimes:\n    1. Early-time ballistic: $MSD(t) \\propto t^2$.\n    2. Intermediate-time caging: Sublinear growth of $MSD(t)$.\n    3. Long-time diffusive: $MSD(t)$ is linear with $t$. For three dimensions, $MSD(t) = 6Dt$.\n- **Core Methodological Constraint**: The method must be data-adaptive, identifying the linear diffusive regime without using fixed, hard-coded time cutoffs.\n- **Algorithmic Requirements**:\n    1. Use a sliding-window analysis of the local scaling exponent $\\alpha = \\frac{d \\log(MSD)}{d \\log(t)}$ to find where $\\alpha \\approx 1$.\n    2. Implement quantitative criteria for \"sufficiently close\" and \"sufficiently stable\" for $\\alpha$.\n    3. Use a robust linear regression for $MSD$ versus $t$ in the identified diffusive window.\n    4. Implement a decision rule to select the best window if multiple candidates exist, favoring longer and more linear windows.\n- **Units and Conversions**:\n    - Input time $t$ is in picoseconds ($ps$).\n    - Input $MSD$ is in square nanometers ($nm^2$).\n    - The final reported $D$ must be in meters squared per second ($m^2/s$).\n    - The conversion factor is $1\\,nm^2/ps = 10^{-6}\\,m^2/s$.\n- **Synthetic Data Generation**:\n    - Formula: $MSD(t) = v_2 t^2 e^{-(t/t_b)^2} + a (1 - e^{-(t/t_c)^2}) e^{-(t/t_d)^2} + 6 D t (1 - e^{-(t/t_d)^2}) + \\eta$.\n    - $\\eta$ is zero-mean Gaussian noise with standard deviation $\\sigma$.\n    - Non-positive $MSD(t)$ values are clipped to a floor of $10^{-12}\\,nm^2$.\n    - Time grid: $N$ points, uniformly spaced from $t_{\\min} = 10^{-3}\\,ps$ to $t_{\\max}$.\n- **Test Cases**: Four specific parameter sets (Case 1, Case 2, Case 3, Case 4) are provided, each with values for $N, t_{\\max}, v_2, a, t_b, t_c, t_d, D, \\sigma$, and a random seed.\n- **Output Format**: A single line containing a comma-separated list of the four diffusion coefficients in $m^2/s$, enclosed in square brackets (e.g., `[d1,d2,d3,d4]`), with each value in scientific notation with three significant figures.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is subjected to rigorous validation.\n\n1.  **Scientific or Factual Unsoundness**: The problem is scientifically sound. It is based on the canonical model of diffusion in disordered systems, which correctly describes ballistic, caged, and diffusive regimes. The use of the Einstein relation, $MSD(t) = 2dDt$ (where the dimensionality $d=3$), and the analysis of the local logarithmic derivative $\\alpha(t)$ are standard, well-established methods in condensed matter physics and statistical mechanics. The synthetic data model is a physically plausible representation of these combined effects.\n2.  **Non-Formalizable or Irrelevant**: The problem is highly formalizable as a numerical analysis task grounded in physics. It is directly and unambiguously related to the specified topic of calculating diffusion coefficients from mean square displacement.\n3.  **Incomplete or Contradictory Setup**: The problem is complete. It provides all necessary parameters, equations, and explicit random seeds to generate the test data deterministically. The requirements for the analysis method and output format are specified in detail, leaving no room for ambiguity. There are no contradictions in the givens.\n4.  **Unrealistic or Infeasible**: The physical parameters and time scales are representative of those found in molecular dynamics simulations of amorphous materials and complex liquids. The task is challenging but entirely feasible with standard numerical libraries.\n5.  **Ill-Posed or Poorly Structured**: The problem is well-posed. It requests the estimation of a specific parameter ($D$) using a constrained but sensible methodology. The provision of synthetic data with a known ground-truth $D$ allows for a clear success criterion. The core challenge—designing the data-adaptive windowing logic—is a well-defined algorithmic design task, not an ill-posed problem.\n6.  **Pseudo-Profound, Trivial, or Tautological**: The problem is non-trivial. A simple linear fit across the entire dataset would yield an incorrect result due to the contributions of the ballistic and caging regimes. The problem requires a thoughtful implementation of a filtering and selection algorithm that bypasses these non-diffusive portions of the data, which is a common and substantive challenge in real-world data analysis.\n7.  **Outside Scientific Verifiability**: The problem is perfectly verifiable. Given the fixed seeds and deterministic data generation formula, any correct implementation of the algorithm will produce the same set of input data and should yield highly comparable final results.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. It is scientifically sound, well-posed, and presents a clear, non-trivial challenge that is representative of real-world scientific data analysis. The solution process may proceed.\n\n### Principled Solution Design\n\nThe core objective is to estimate the diffusion coefficient $D$ from the long-time linear regime of the mean square displacement, $MSD(t)$. The relation in three dimensions is given by the Einstein equation:\n$$MSD(t) = 6Dt + C$$\nwhere $C$ is an intercept term. Our task is to isolate the time window where this linear relationship holds and robustly estimate the slope, which is equal to $6D$. The approach must be data-adaptive, avoiding arbitrary time cutoffs.\n\n**Step 1: Local Scaling Exponent Calculation**\n\nTo distinguish the different dynamical regimes, we analyze the local scaling exponent, $\\alpha(t)$, defined as the logarithmic derivative of $MSD(t)$ with respect to $t$:\n$$\\alpha(t) = \\frac{d \\log(MSD(t))}{d \\log(t)}$$\nThis exponent quantifies the power-law relationship $MSD(t) \\sim t^{\\alpha(t)}$ in the vicinity of time $t$. The expected values are $\\alpha \\approx 2$ for the ballistic regime, $\\alpha  1$ (often near $0$) for the caging regime, and $\\alpha \\approx 1$ for the diffusive regime.\n\nDirect numerical differentiation of noisy data is unstable as it amplifies noise. A more robust method is to compute $\\alpha(t_i)$ at each point $t_i$ by performing a linear regression on $\\log(MSD)$ versus $\\log(t)$ within a sliding window of points centered at $t_i$. The slope of this local fit provides a smoothed estimate of $\\alpha_i$. We choose a fixed window size of $51$ points for this calculation, which is large enough to average out noise but small enough to resolve changes in dynamical regimes for the given data density.\n\n**Step 2: Identification of Candidate Diffusive Windows**\n\nThe diffusive regime is characterized by $\\alpha(t) \\approx 1$. We define a quantitative criterion for this condition: we identify all time points $t_i$ where the calculated exponent $\\alpha_i$ falls within a tolerance band around $1$. We set this as:\n$$| \\alpha_i - 1.0 |  \\delta_{\\alpha}$$\nA tolerance of $\\delta_{\\alpha} = 0.1$ is chosen, identifying points where the local scaling is between $t^{0.9}$ and $t^{1.1}$.\n\nTo ensure stability and statistical significance, we are not interested in isolated points that satisfy this criterion but rather in contiguous segments of sufficient length. We find all contiguous blocks of indices where the condition holds and discard any block that is shorter than a minimum length. This minimum length is set to $10\\%$ of the total number of data points, $N$, ensuring any subsequent linear fit is performed on a substantial portion of the trajectory.\n\n**Step 3: Robust Regression and Final Window Selection**\n\nFor each candidate window identified, a linear fit of $MSD$ versus $t$ is performed. As the data contains noise, a robust regression method is superior to standard ordinary least squares. We employ the Theil-Sen estimator, a non-parametric method that is highly robust to outliers. It calculates the slope as the median of the slopes of lines connecting all pairs of points in the dataset. This provides a reliable estimate of the slope $m = 6D$.\n\nThe problem requires a rule to select the best window if multiple candidates are found. The chosen rule is: select the **longest** contiguous window that satisfies the $\\alpha$-criterion. This prioritizes the most stable and extended exhibition of diffusive behavior. In the rare event of a tie in length, the window that occurs latest in time is selected, as this best represents the true asymptotic, long-time behavior of the system.\n\n**Step 4: Diffusion Coefficient Calculation and Unit Conversion**\n\nOnce the optimal window is selected and the robust slope $m$ is estimated using `scipy.stats.theilslopes`:\n1.  The diffusion coefficient in simulation units is calculated as:\n    $$D_{\\text{sim}} = \\frac{m}{6}$$\n    The units of $D_{\\text{sim}}$ are $nm^2/ps$.\n2.  This value is converted to the required SI units of $m^2/s$ using the provided conversion factor:\n    $$D_{\\text{SI}} [m^2/s] = D_{\\text{sim}} [nm^2/ps] \\times 10^{-6}$$\n3.  The final result is formatted to scientific notation with three significant figures.\n\nThis self-contained, data-driven procedure robustly extracts the diffusion coefficient by systematically identifying the physically correct time regime for analysis, fully satisfying the problem's constraints.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import theilslopes\n\ndef solve():\n    \"\"\"\n    Main function to generate data, run the analysis for all test cases,\n    and print the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, clear long diffusive tail)\n        {'N': 1200, 't_max': 100.0, 'v_2': 0.50, 'a': 0.20, 't_b': 0.20,\n         't_c': 1.00, 't_d': 5.00, 'D': 0.020, 'sigma': 5.0e-3, 'seed': 12345},\n\n        # Case 2 (extended caging, late-onset diffusion, slower D)\n        {'N': 1600, 't_max': 200.0, 'v_2': 0.70, 'a': 0.50, 't_b': 0.50,\n         't_c': 5.00, 't_d': 30.0, 'D': 0.0050, 'sigma': 3.0e-3, 'seed': 24680},\n\n        # Case 3 (short trajectory, minimal diffusive window, faster D)\n        {'N': 900, 't_max': 20.0, 'v_2': 0.60, 'a': 0.30, 't_b': 0.80,\n         't_c': 3.00, 't_d': 8.00, 'D': 0.0300, 'sigma': 1.0e-2, 'seed': 13579},\n\n        # Case 4 (noisier data, moderate D)\n        {'N': 1400, 't_max': 120.0, 'v_2': 0.40, 'a': 0.25, 't_b': 0.30,\n         't_c': 2.50, 't_d': 10.0, 'D': 0.0150, 'sigma': 2.0e-2, 'seed': 11223},\n    ]\n\n    results = []\n    for params in test_cases:\n        t, msd = generate_msd_data(**params)\n        D_si = estimate_diffusion_coefficient(t, msd)\n        results.append(D_si)\n\n    # Format and print the final output exactly as required.\n    print(f\"[{','.join(f'{d:.2e}' for d in results)}]\")\n\ndef generate_msd_data(N, t_max, v_2, a, t_b, t_c, t_d, D, sigma, seed, t_min=1e-3):\n    \"\"\"\n    Generates synthetic MSD data based on the provided formula and parameters.\n    \"\"\"\n    np.random.seed(seed)\n    \n    t = np.linspace(t_min, t_max, N)\n    \n    # Ballistic term\n    msd_ballistic = v_2 * t**2 * np.exp(-(t / t_b)**2)\n    \n    # Caging term\n    msd_caging = a * (1 - np.exp(-(t / t_c)**2)) * np.exp(-(t / t_d)**2)\n    \n    # Diffusive term\n    msd_diffusive = 6 * D * t * (1 - np.exp(-(t / t_d)**2))\n    \n    msd_clean = msd_ballistic + msd_caging + msd_diffusive\n    \n    # Add Gaussian noise\n    noise = np.random.normal(0, sigma, N)\n    msd_noisy = msd_clean + noise\n    \n    # Clip non-positive values to prevent log(0) or log(0) issues\n    msd = np.maximum(msd_noisy, 1e-12)\n    \n    return t, msd\n\ndef estimate_diffusion_coefficient(t, msd):\n    \"\"\"\n    Estimates the diffusion coefficient using a data-adaptive windowing method.\n    \"\"\"\n    N = len(t)\n    \n    # --- Step 1: Calculate local scaling exponent alpha(t) ---\n    # Use a sliding window to perform log-log fits for noise robustness.\n    # The chosen window size must be an odd integer.\n    alpha_window_size = 51 \n    half_window = alpha_window_size // 2\n    \n    alphas = np.full(N, np.nan)\n    \n    log_t = np.log(t)\n    log_msd = np.log(msd)\n    \n    for i in range(half_window, N - half_window):\n        # Define the window for the local fit\n        start, end = i - half_window, i + half_window + 1\n        \n        # polyfit(x, y, 1) returns [slope, intercept]\n        slope, _ = np.polyfit(log_t[start:end], log_msd[start:end], 1)\n        alphas[i] = slope\n\n    # --- Step 2: Identify candidate diffusive windows ---\n    alpha_tolerance = 0.1\n    min_window_frac = 0.1\n    min_len = int(min_window_frac * N)\n\n    # Find indices where alpha is close to 1\n    diffusive_indices = np.where(np.abs(alphas - 1.0)  alpha_tolerance)[0]\n\n    if len(diffusive_indices) == 0:\n        # Fallback if no window is found - this shouldn't happen with the test data\n        return np.nan\n\n    # Group consecutive indices into windows\n    candidate_windows = []\n    if len(diffusive_indices)  0:\n        # Split a list of indices into sub-lists of consecutive numbers\n        splits = np.where(np.diff(diffusive_indices) != 1)[0] + 1\n        contiguous_blocks = np.split(diffusive_indices, splits)\n        \n        for block in contiguous_blocks:\n            if len(block) >= min_len:\n                candidate_windows.append(block)\n\n    if not candidate_windows:\n        # If no window meets the minimum length, try relaxing criteria (not done here as it's not needed for the given problem)\n        return np.nan # Or handle error appropriately\n\n    # --- Step 3: Select the best window ---\n    # Rule: Choose the longest window. If tied, choose the one latest in time.\n    best_window = max(candidate_windows, key=lambda w: (len(w), w[-1]))\n    \n    t_window = t[best_window]\n    msd_window = msd[best_window]\n\n    # --- Step 4: Perform robust linear regression ---\n    # Use Theil-Sen estimator on the selected window (MSD vs t)\n    # theilslopes returns (slope, intercept, low_slope, high_slope)\n    slope, _, _, _ = theilslopes(y=msd_window, x=t_window)\n    \n    # --- Step 5: Calculate D and convert units ---\n    # D_sim = slope / (2 * dimensions), here dimensions=3\n    D_sim = slope / 6.0  # units: nm^2 / ps\n    \n    # Conversion factor from nm^2/ps to m^2/s\n    # 1 nm^2/ps = (10^-9 m)^2 / (10^-12 s) = 10^-18 m^2 / 10^-12 s = 10^-6 m^2/s\n    conversion_factor = 1e-6\n    D_si = D_sim * conversion_factor # units: m^2 / s\n    \n    return D_si\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "In many materials, particularly those with crystalline or polymeric structures, diffusion is not isotropic; particles move more easily in certain directions than others. To capture this, the scalar diffusion coefficient $D$ is replaced by a $3 \\times 3$ diffusion tensor $\\mathbf{D}$. This advanced exercise guides you through the process of estimating the full diffusion tensor by analyzing the covariance matrix of particle displacements, correctly accounting for anisotropic diffusion and potential system drift .",
            "id": "3794099",
            "problem": "You are given a task to design a program that, for three-dimensional trajectories generated under stationary increments with possible drift and periodic boundaries, estimates the full diffusion tensor by using the definition of Mean Squared Displacement (MSD). The program must simulate data for a set of specified cases and then perform an estimation procedure that starts from fundamental definitions of displacement, centered second moment, and covariance, and uses their asymptotic time dependence to infer the diffusion tensor. The problem must be solved without relying on shortcuts from pre-stated results; your design should be faithful to first-principles definitions and should separate drift from fluctuations when computing second moments.\n\nFundamental base for the derivation and implementation:\n- Define the displacement as $\\Delta \\mathbf{r}(t;\\tau) = \\mathbf{r}(t+\\tau) - \\mathbf{r}(t)$ for lag time $\\tau$.\n- Define the raw second moment matrix as $\\mathbf{M}(\\tau) = \\mathbb{E}\\left[\\Delta \\mathbf{r}(t;\\tau)\\,\\Delta \\mathbf{r}(t;\\tau)^{\\top}\\right]$.\n- Define the mean displacement as $\\mathbf{m}(\\tau) = \\mathbb{E}\\left[\\Delta \\mathbf{r}(t;\\tau)\\right]$.\n- Define the covariance matrix as $\\mathbf{C}(\\tau) = \\mathbb{E}\\left[\\left(\\Delta \\mathbf{r}(t;\\tau)-\\mathbf{m}(\\tau)\\right)\\left(\\Delta \\mathbf{r}(t;\\tau)-\\mathbf{m}(\\tau)\\right)^{\\top}\\right]$.\n- Use the principle that, for processes with stationary increments encompassing broad classes of Langevin models, the long-time behavior of $\\mathbf{C}(\\tau)$ grows linearly with $\\tau$, and this growth rate defines the diffusion tensor. You must remove drift by appropriate centering so that only the fluctuations contribute to $\\mathbf{C}(\\tau)$.\n\nYour program must implement the following steps for each test case:\n- Simulate a three-dimensional trajectory with $N$ steps and time step $\\Delta t$, where increments are Gaussian with stationary covariance; add a constant drift vector if specified. If periodic boundaries are specified, wrap positions to the box of size $L$ at each step; then reconstruct the unwrapped trajectory for analysis by ensuring continuity.\n- Choose a set of lag indices $k$ corresponding to lag times $\\tau = k\\,\\Delta t$ over a prescribed range that avoids very small $\\tau$ dominated by short-time non-diffusive behavior, and avoids very large $\\tau$ where sample counts become too small.\n- For each lag, compute $\\Delta \\mathbf{r}(t;\\tau)$ across all overlapping windows along the unwrapped trajectory, compute $\\mathbf{m}(\\tau)$ and $\\mathbf{C}(\\tau)$ from their definitions, and then estimate the diffusion tensor components by regressing the $\\tau$-dependence of the entries of $\\mathbf{C}(\\tau)$ to isolate the linear growth rate that defines the tensor entries. Symmetrize the resulting estimate to enforce physical symmetry.\n- Return the final diffusion tensor entries in square meters per second, as floats.\n\nPhysical units must be respected throughout: positions in meters, time in seconds, and diffusion coefficients in square meters per second. Express all outputs in $\\mathrm{m}^2/\\mathrm{s}$ as floats.\n\nTest suite specification:\n- Case $1$ (isotropic, no drift, no boundaries):\n  - Diffusion tensor $\\mathbf{D} = \\operatorname{diag}\\left(1.0\\times 10^{-9},\\,1.0\\times 10^{-9},\\,1.0\\times 10^{-9}\\right)\\ \\mathrm{m}^2/\\mathrm{s}$.\n  - Drift $\\mathbf{v} = \\left(0.0,\\,0.0,\\,0.0\\right)\\ \\mathrm{m}/\\mathrm{s}$.\n  - Time step $\\Delta t = 1.0\\times 10^{-9}\\ \\mathrm{s}$.\n  - Steps $N = 20000$.\n  - No periodic boundaries.\n- Case $2$ (anisotropic diagonal, no drift, no boundaries):\n  - Diffusion tensor $\\mathbf{D} = \\operatorname{diag}\\left(2.0\\times 10^{-9},\\,5.0\\times 10^{-10},\\,1.0\\times 10^{-10}\\right)\\ \\mathrm{m}^2/\\mathrm{s}$.\n  - Drift $\\mathbf{v} = \\left(0.0,\\,0.0,\\,0.0\\right)\\ \\mathrm{m}/\\mathrm{s}$.\n  - Time step $\\Delta t = 5.0\\times 10^{-10}\\ \\mathrm{s}$.\n  - Steps $N = 30000$.\n  - No periodic boundaries.\n- Case $3$ (full tensor with off-diagonal couplings, nonzero drift, periodic boundaries):\n  - Diffusion tensor\n    $$\n    \\mathbf{D} =\n    \\begin{bmatrix}\n    1.2\\times 10^{-9}  3.0\\times 10^{-10}  -1.0\\times 10^{-10} \\\\\n    3.0\\times 10^{-10}  0.9\\times 10^{-9}  2.0\\times 10^{-10} \\\\\n    -1.0\\times 10^{-10}  2.0\\times 10^{-10}  0.7\\times 10^{-9}\n    \\end{bmatrix}\\ \\mathrm{m}^2/\\mathrm{s}\n    $$\n  - Drift $\\mathbf{v} = \\left(1.0\\times 10^{-7},\\,-2.0\\times 10^{-7},\\,1.0\\times 10^{-7}\\right)\\ \\mathrm{m}/\\mathrm{s}$.\n  - Time step $\\Delta t = 2.0\\times 10^{-9}\\ \\mathrm{s}$.\n  - Steps $N = 40000$.\n  - Periodic boundaries with box length $L = 1.0\\times 10^{-6}\\ \\mathrm{m}$ applied to each axis.\n- Case $4$ (nearly immobile axis, boundary condition stress-test):\n  - Diffusion tensor $\\mathbf{D} = \\operatorname{diag}\\left(1.0\\times 10^{-9},\\,1.0\\times 10^{-9},\\,1.0\\times 10^{-12}\\right)\\ \\mathrm{m}^2/\\mathrm{s}$.\n  - Drift $\\mathbf{v} = \\left(0.0,\\,0.0,\\,0.0\\right)\\ \\mathrm{m}/\\mathrm{s}$.\n  - Time step $\\Delta t = 1.0\\times 10^{-9}\\ \\mathrm{s}$.\n  - Steps $N = 30000$.\n  - No periodic boundaries.\n\nLag-time windowing guideline for all cases:\n- Use lag indices $k$ ranging from $k_{\\min} = 10$ up to $k_{\\max} = \\lfloor N/20 \\rfloor$, sampled at $50$ evenly spaced integer values. This corresponds to lag times $\\tau = k\\Delta t$ in the range $[10\\Delta t, (N/20)\\Delta t]$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case’s result must be a list of $9$ floats representing the estimated diffusion tensor in $\\mathrm{m}^2/\\mathrm{s}$, ordered in row-major form $\\left[d_{11},d_{12},d_{13},d_{21},d_{22},d_{23},d_{31},d_{32},d_{33}\\right]$. The overall format is thus a list of lists, for example, $\\left[\\left[d_{11},\\ldots,d_{33}\\right],\\left[\\ldots\\right],\\ldots\\right]$. Express all floats in scientific notation with $6$ significant digits.\n\nYour implementation must be deterministic by fixing random seeds per test case, must not read any external files, and must not require any user input.",
            "solution": "### Problem Validation\n\nThe problem statement is critically evaluated according to the specified criteria.\n\n#### Step 1: Extract Givens\n\nThe problem provides the following data and definitions:\n- **Displacement**: $\\Delta \\mathbf{r}(t;\\tau) = \\mathbf{r}(t+\\tau) - \\mathbf{r}(t)$ for a lag time $\\tau$.\n- **Raw Second Moment Matrix**: $\\mathbf{M}(\\tau) = \\mathbb{E}\\left[\\Delta \\mathbf{r}(t;\\tau)\\,\\Delta \\mathbf{r}(t;\\tau)^{\\top}\\right]$.\n- **Mean Displacement**: $\\mathbf{m}(\\tau) = \\mathbb{E}\\left[\\Delta \\mathbf{r}(t;\\tau)\\right]$.\n- **Covariance Matrix**: $\\mathbf{C}(\\tau) = \\mathbb{E}\\left[\\left(\\Delta \\mathbf{r}(t;\\tau)-\\mathbf{m}(\\tau)\\right)\\left(\\Delta \\mathbf{r}(t;\\tau)-\\mathbf{m}(\\tau)\\right)^{\\top}\\right]$.\n- **Asymptotic Principle**: The long-time behavior of $\\mathbf{C}(\\tau)$ grows linearly with $\\tau$. The slope of this growth defines the diffusion tensor $\\mathbf{D}$.\n- **Lag-time windowing**: For each case, use lag indices $k$ from $k_{\\min} = 10$ to $k_{\\max} = \\left\\lfloor N/20 \\right\\rfloor$, with $50$ evenly spaced integer values.\n- **Physical Units**: Positions in meters (m), time in seconds (s), diffusion coefficients in $\\mathrm{m}^2/\\mathrm{s}$.\n- **Test Cases**:\n    - **Case 1**: $\\mathbf{D} = \\operatorname{diag}\\left(1.0\\times 10^{-9},\\,1.0\\times 10^{-9},\\,1.0\\times 10^{-9}\\right)\\ \\mathrm{m}^2/\\mathrm{s}$, $\\mathbf{v} = \\mathbf{0}\\ \\mathrm{m}/\\mathrm{s}$, $\\Delta t = 1.0\\times 10^{-9}\\ \\mathrm{s}$, $N = 20000$, no PBC.\n    - **Case 2**: $\\mathbf{D} = \\operatorname{diag}\\left(2.0\\times 10^{-9},\\,5.0\\times 10^{-10},\\,1.0\\times 10^{-10}\\right)\\ \\mathrm{m}^2/\\mathrm{s}$, $\\mathbf{v} = \\mathbf{0}\\ \\mathrm{m}/\\mathrm{s}$, $\\Delta t = 5.0\\times 10^{-10}\\ \\mathrm{s}$, $N = 30000$, no PBC.\n    - **Case 3**: $\\mathbf{D} = \\begin{pmatrix} 1.2  0.3  -0.1 \\\\ 0.3  0.9  0.2 \\\\ -0.1  0.2  0.7 \\end{pmatrix} \\times 10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$, $\\mathbf{v} = (1.0, -2.0, 1.0) \\times 10^{-7}\\ \\mathrm{m}/\\mathrm{s}$, $\\Delta t = 2.0\\times 10^{-9}\\ \\mathrm{s}$, $N = 40000$, PBC with $L = 1.0\\times 10^{-6}\\ \\mathrm{m}$.\n    - **Case 4**: $\\mathbf{D} = \\operatorname{diag}\\left(1.0\\times 10^{-9},\\,1.0\\times 10^{-9},\\,1.0\\times 10^{-12}\\right)\\ \\mathrm{m}^2/\\mathrm{s}$, $\\mathbf{v} = \\mathbf{0}\\ \\mathrm{m}/\\mathrm{s}$, $\\Delta t = 1.0\\times 10^{-9}\\ \\mathrm{s}$, $N = 30000$, no PBC.\n- **Output Format**: A single-line string representing a list of lists. Each inner list contains $9$ floats for the diffusion tensor in row-major order, formatted in scientific notation with $6$ significant digits.\n\n#### Step 2: Validate Using Extracted Givens\n\nThe problem is assessed for validity:\n- **Scientifically Grounded**: The problem is founded on the Einstein relation and the broader theory of stochastic processes (specifically, the Wiener process and Langevin dynamics), which are central to statistical mechanics. The relationship between the covariance matrix of displacements and the diffusion tensor, $\\mathbf{C}(\\tau) \\approx 2\\mathbf{D}\\tau$, is a standard result for diffusion processes. The use of this relation to estimate $\\mathbf{D}$ is a well-established method in computational physics and chemistry.\n- **Well-Posed**: The problem is fully specified. All necessary parameters for simulation ($N, \\Delta t, \\mathbf{D}, \\mathbf{v}, L$) and analysis (lag-time range) are provided. The objective is clearly defined. The simulation parameters are physically reasonable and computationally tractable, ensuring a meaningful solution can be obtained.\n- **Objective**: The problem uses precise mathematical and physical terminology, free from ambiguity or subjective assertions.\n\nThe problem exhibits no flaws such as scientific unsoundness, incompleteness, contradiction, or ill-posedness. The requirement to derive the result from fundamental definitions and to handle practical issues like drift and periodic boundaries constitutes a valid and substantive task in computational science.\n\n#### Step 3: Verdict and Action\n\nThe problem is **valid**. A solution will be developed based on the specified principles.\n\n### Principle-Based Design of the Solution\n\nThe solution is architected in two stages: first, simulating the particle trajectory based on the provided physical model; and second, analyzing this trajectory to estimate the diffusion tensor.\n\n#### 1. Trajectory Generation\n\nA discrete-time model is employed to simulate the particle's trajectory $\\mathbf{r}(t)$. The position at step $i+1$ is given by the position at step $i$ plus a small displacement, $\\delta \\mathbf{r}_i$:\n$$\n\\mathbf{r}_{i+1} = \\mathbf{r}_i + \\delta \\mathbf{r}_i\n$$\nThis displacement is composed of a deterministic drift component and a stochastic fluctuation component:\n$$\n\\delta \\mathbf{r}_i = \\mathbf{v}\\Delta t + \\boldsymbol{\\xi}_i\n$$\nwhere $\\mathbf{v}$ is the drift velocity and $\\Delta t$ is the time step. The term $\\boldsymbol{\\xi}_i$ is a random vector drawn from a multivariate normal distribution with a mean of zero and a covariance matrix related to the diffusion tensor $\\mathbf{D}$. For a diffusion process, the covariance of the stochastic step is given by:\n$$\n\\mathbb{E}\\left[\\boldsymbol{\\xi}_i \\boldsymbol{\\xi}_i^{\\top}\\right] = 2\\mathbf{D}\\Delta t\n$$\nTo generate random vectors $\\boldsymbol{\\xi}_i$ with this covariance structure, we perform a Cholesky decomposition of the covariance matrix, yielding a lower triangular matrix $\\mathbf{L}$ such that $\\mathbf{L}\\mathbf{L}^{\\top} = 2\\mathbf{D}\\Delta t$. A random step $\\boldsymbol{\\xi}_i$ is then generated by applying this matrix to a vector $\\mathbf{z}_i$ of three independent standard normal random variables:\n$$\n\\boldsymbol{\\xi}_i = \\mathbf{L} \\mathbf{z}_i\n$$\nThis ensures $\\mathbb{E}\\left[\\boldsymbol{\\xi}_i \\boldsymbol{\\xi}_i^{\\top}\\right] = \\mathbb{E}\\left[(\\mathbf{L}\\mathbf{z}_i)(\\mathbf{L}\\mathbf{z}_i)^{\\top}\\right] = \\mathbf{L}\\mathbb{E}\\left[\\mathbf{z}_i\\mathbf{z}_i^{\\top}\\right]\\mathbf{L}^{\\top} = \\mathbf{L}\\mathbf{I}\\mathbf{L}^{\\top} = 2\\mathbf{D}\\Delta t$, as required.\n\nFor the case involving periodic boundary conditions (PBC), the trajectory is first simulated by wrapping the particle's position into the primary simulation box of side length $L$ at each step. This produces a \"wrapped\" trajectory. For the subsequent analysis of displacements, this wrapped trajectory must be \"unwrapped\" to reflect the true, continuous path of the particle. The unwrapping algorithm proceeds by calculating the step-wise differences in the wrapped trajectory. Any difference with a magnitude greater than $L/2$ is assumed to be a boundary crossing, and an appropriate multiple of $L$ is added or subtracted to correct it. The unwrapped trajectory is then reconstructed by summing these corrected differences.\n\n#### 2. Diffusion Tensor Estimation\n\nThe estimation process begins with the computed (and unwrapped, if necessary) trajectory $\\mathbf{r}(t)$.\n\nFirst, a set of lag times, $\\{\\tau_k = k \\Delta t\\}$, is selected according to the problem specification. For each $\\tau_k$, we compute all possible overlapping displacements $\\Delta\\mathbf{r}(t_j; \\tau_k) = \\mathbf{r}_{j+k} - \\mathbf{r}_j$ along the trajectory, where $j$ ranges from $0$ to $N-k$.\n\nFrom this sample of displacements, we compute the sample covariance matrix $\\hat{\\mathbf{C}}(\\tau_k)$. This is the estimator for the true covariance matrix $\\mathbf{C}(\\tau_k)$. It is calculated as:\n$$\n\\hat{\\mathbf{C}}(\\tau_k) = \\frac{1}{M_k} \\sum_{j=0}^{M_k-1} \\left(\\Delta\\mathbf{r}_j - \\hat{\\mathbf{m}}_k\\right) \\left(\\Delta\\mathbf{r}_j - \\hat{\\mathbf{m}}_k\\right)^{\\top}\n$$\nwhere $M_k = N-k+1$ is the number of samples for lag $k$, and $\\hat{\\mathbf{m}}_k$ is the sample mean displacement $\\hat{\\mathbf{m}}_k = \\frac{1}{M_k} \\sum_{j=0}^{M_k-1} \\Delta\\mathbf{r}_j$. This step correctly separates the mean displacement (drift) from the fluctuations, ensuring that the subsequent analysis isolates the diffusive motion.\n\nAccording to the theory of diffusion, the components of the covariance matrix exhibit a linear relationship with the lag time in the long-time limit:\n$$\nC_{ij}(\\tau) = 2D_{ij}\\tau\n$$\nTherefore, for each tensor component $(i,j)$, we perform a linear regression on the computed data points $\\{(\\tau_k, \\hat{C}_{ij}(\\tau_k))\\}$. We fit this data to the model $y = a_{ij}x + b_{ij}$, where $y = \\hat{C}_{ij}$ and $x = \\tau$. The slope of the best-fit line, $a_{ij}$, provides an estimate for $2D_{ij}$. Thus, the estimated diffusion tensor component is:\n$$\n\\hat{D}_{ij} = \\frac{a_{ij}}{2}\n$$\nThis procedure is repeated for all nine components of the $3 \\times 3$ tensor, yielding an estimated tensor $\\hat{\\mathbf{D}}$.\n\nFinally, since the physical diffusion tensor must be symmetric ($\\mathbf{D} = \\mathbf{D}^{\\top}$), the estimated tensor $\\hat{\\mathbf{D}}$ is symmetrized to remove any small asymmetries arising from statistical noise in the simulation and analysis. The final, symmetric estimate is given by:\n$$\n\\mathbf{D}_{\\text{final}} = \\frac{1}{2}\\left(\\hat{\\mathbf{D}} + \\hat{\\mathbf{D}}^{\\top}\\right)\n$$\nThis symmetrized tensor is then flattened into row-major order and formatted for the final output. This rigorous, principle-based approach ensures a robust estimation of the full diffusion tensor.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\nfrom scipy.linalg import cholesky\n\ndef generate_trajectory(N, dt, D, v, L, seed):\n    \"\"\"\n    Simulates a 3D particle trajectory based on a discrete Langevin model.\n    \n    Args:\n        N (int): Number of time steps.\n        dt (float): Time step duration.\n        D (np.ndarray): 3x3 diffusion tensor.\n        v (np.ndarray): 3x1 drift velocity vector.\n        L (float or None): Box length for periodic boundary conditions. If None, no PBC.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        np.ndarray: The (N+1)x3 unwrapped trajectory.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # Covariance matrix for a single random step: Cov(xi) = 2*D*dt\n    cov_step = 2 * D * dt\n    try:\n        # Use Cholesky decomposition to generate correlated random numbers\n        L_chol = cholesky(cov_step, lower=True)\n    except np.linalg.LinAlgError:\n        # This may happen if D is not positive definite, but all test cases provide\n        # valid positive (semi-)definite symmetric matrices.\n        raise ValueError(\"Diffusion tensor must be positive semi-definite.\")\n\n    # Initialize trajectory array\n    traj = np.zeros((N + 1, 3))\n    \n    if L is None:  # Case with no periodic boundaries\n        # Generate all random steps at once for efficiency\n        random_steps = (L_chol @ rng.standard_normal(size=(N, 3)).T).T\n        drift_per_step = v * dt\n        steps = drift_per_step + random_steps\n        # Trajectory is the cumulative sum of steps\n        traj[1:] = np.cumsum(steps, axis=0)\n    else:  # Case with periodic boundaries\n        # Simulate a wrapped trajectory first\n        wrapped_traj = np.zeros((N + 1, 3))\n        for i in range(N):\n            random_step = L_chol @ rng.standard_normal(size=3)\n            step = v * dt + random_step\n            # Propose the next position and wrap it into the box [0, L)\n            next_pos_unwrapped = wrapped_traj[i] + step\n            wrapped_traj[i+1] = next_pos_unwrapped % L\n            \n        # Reconstruct the unwrapped trajectory from the wrapped one\n        # This is a standard post-processing step in simulations.\n        traj[0] = wrapped_traj[0]\n        diffs = np.diff(wrapped_traj, axis=0)\n        # Correct for jumps across the periodic boundary\n        # This assumes jumps are not larger than L/2 in one step\n        corrections = -L * np.round(diffs / L)\n        unwrapped_diffs = diffs + corrections\n        traj[1:] = traj[0] + np.cumsum(unwrapped_diffs, axis=0)\n\n    return traj\n\ndef estimate_diffusion_tensor(traj, dt, N):\n    \"\"\"\n    Estimates the diffusion tensor from a trajectory using MSD.\n\n    Args:\n        traj (np.ndarray): The (N+1)x3 particle trajectory.\n        dt (float): Time step duration.\n        N (int): Number of time steps in the simulation.\n\n    Returns:\n        np.ndarray: The estimated 3x3 diffusion tensor.\n    \"\"\"\n    # Select lag indices as per problem specification\n    k_min = 10\n    k_max = int(N / 20)\n    lag_indices = np.unique(np.linspace(k_min, k_max, 50, dtype=int))\n    \n    taus = lag_indices * dt\n    cov_matrices = []\n\n    for k in lag_indices:\n        # Collect all displacements for the current lag time\n        displacements = traj[k:] - traj[:-k]\n        \n        # Ensure there are enough samples for covariance calculation\n        if displacements.shape[0]  2:\n            continue\n            \n        # Compute the sample covariance matrix of displacements.\n        # This is the estimate of C(tau). ddof=0 normalizes by N.\n        cov_tau = np.cov(displacements, rowvar=False, ddof=0)\n        cov_matrices.append(cov_tau)\n\n    cov_matrices = np.array(cov_matrices)\n\n    # Perform linear regression for each tensor component\n    D_est = np.zeros((3, 3))\n    for i in range(3):\n        for j in range(3):\n            # Extract the time series for the C_ij component\n            cov_ij_vs_tau = cov_matrices[:, i, j]\n            \n            # Fit C_ij(tau) = slope * tau + intercept\n            # The slope is theoretically 2 * D_ij\n            if len(taus)  1:\n                res = linregress(taus, cov_ij_vs_tau)\n                slope = res.slope\n                D_est[i, j] = slope / 2.0\n            else:\n                D_est[i, j] = 0.0\n\n    # Enforce physical symmetry on the estimated tensor\n    D_final = (D_est + D_est.T) / 2.0\n    \n    return D_final\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: Isotropic, no drift\n        {\n            \"D\": np.diag([1.0e-9, 1.0e-9, 1.0e-9]),\n            \"v\": np.array([0.0, 0.0, 0.0]),\n            \"dt\": 1.0e-9, \"N\": 20000, \"L\": None,\n        },\n        # Case 2: Anisotropic, no drift\n        {\n            \"D\": np.diag([2.0e-9, 5.0e-10, 1.0e-10]),\n            \"v\": np.array([0.0, 0.0, 0.0]),\n            \"dt\": 5.0e-10, \"N\": 30000, \"L\": None,\n        },\n        # Case 3: Full tensor, drift, PBC\n        {\n            \"D\": np.array([\n                [1.2e-9, 3.0e-10, -1.0e-10],\n                [3.0e-10, 0.9e-9, 2.0e-10],\n                [-1.0e-10, 2.0e-10, 0.7e-9]\n            ]),\n            \"v\": np.array([1.0e-7, -2.0e-7, 1.0e-7]),\n            \"dt\": 2.0e-9, \"N\": 40000, \"L\": 1.0e-6,\n        },\n        # Case 4: Nearly immobile axis\n        {\n            \"D\": np.diag([1.0e-9, 1.0e-9, 1.0e-12]),\n            \"v\": np.array([0.0, 0.0, 0.0]),\n            \"dt\": 1.0e-9, \"N\": 30000, \"L\": None,\n        }\n    ]\n\n    all_results_str = []\n    \n    for i, case in enumerate(test_cases):\n        # The seed is fixed for each case to ensure deterministic output\n        traj = generate_trajectory(\n            N=case[\"N\"], dt=case[\"dt\"], D=case[\"D\"], v=case[\"v\"], L=case[\"L\"], seed=i\n        )\n        \n        D_estimated = estimate_diffusion_tensor(\n            traj=traj, dt=case[\"dt\"], N=case[\"N\"]\n        )\n        \n        # Flatten and format the results as required\n        flat_D = D_estimated.flatten().tolist()\n        formatted_D = [f\"{x:.5e}\" for x in flat_D]\n        all_results_str.append(f\"[{','.join(formatted_D)}]\")\n\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        }
    ]
}