{
    "hands_on_practices": [
        {
            "introduction": "从分子动力学模拟中提取输运性质是计算材料科学中的一项基本任务。本练习的核心是从给定的均方位移（MSD）数据中计算标量扩散系数 $D$。通过运用著名的爱因斯坦关系式 $\\text{MSD}(t) = 2dDt$，你将学习如何通过对 MSD-时间曲线的线性部分进行拟合来提取 $D$，并理解空间维度 $d$ 对此关系的影响。这项实践为你掌握从模拟数据中量化原子尺度动力学的基础分析技术奠定了基础 。",
            "id": "3794095",
            "problem": "给定不同空间维度下，从原子轨迹构建的均方位移 (MSD) 数据的时间序列。目标是在正常扩散成立的区间内，从 MSD 与时间 $t$ 的关系曲线的斜率中提取标量扩散系数 $D$。从多尺度材料模拟的一个有效基础出发：一个守恒标量密度的扩散方程、其高斯基本解以及 MSD 的定义。利用这些基础来论证在扩散区间内 MSD 与时间之间的线性关系，并设计一个从 MSD 数据估算 $D$ 的计算程序。\n\n您的程序必须实现以下基于原理的任务：\n- 使用 $d$ 维空间中随机过程的均方位移 (MSD) 定义和主导的扩散方程，论证在正常扩散区间，MSD 随时间线性增长，且比例常数中包含了与空间维度 $d$ 相关的扩散系数。\n- 对限制在指定时间窗口 $\\left[t_{\\min}, t_{\\max}\\right]$ 内的 MSD 与时间数据进行统计上可靠的线性回归，该窗口预期为正常扩散区间，以避免早期的弹道运动和晚期的限制或笼蔽效应。\n- 将估算的 MSD 斜率转换为与 $d$ 维设置一致的标量扩散系数 $D$，并以平方纳米每纳秒 ($\\mathrm{nm}^2/\\mathrm{ns}$) 为单位报告 $D$。\n- 将每个报告的扩散系数四舍五入到三位小数。\n\n物理单位：\n- 时间 $t$ 的单位是纳秒 ($\\mathrm{ns}$)。\n- 均方位移 (MSD) 的单位是平方纳米 ($\\mathrm{nm}^2$)。\n- 扩散系数必须以 $\\mathrm{nm}^2/\\mathrm{ns}$ 表示。\n\n您的程序必须使用提供的测试套件，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[x_1,x_2,x_3,x_4]$），其中每个 $x_i$ 是第 $i$ 个测试用例的扩散系数，四舍五入到三位小数。\n\n测试套件：\n- 测试用例 1（理想情况，三维各向同性扩散）：\n  - 空间维度 $d = 3$。\n  - 时间数组 $t = [0.5, 1.0, 1.5, 2.0, 2.5]$，单位为 $\\mathrm{ns}$。\n  - MSD 数组 $\\mathrm{MSD}(t) = [1.47, 3.02, 4.49, 6.04, 7.50]$，单位为 $\\mathrm{nm}^2$。\n  - 分析窗口 $\\left[t_{\\min}, t_{\\max}\\right] = [0.5, 2.5]$，单位为 $\\mathrm{ns}$。\n\n- 测试用例 2（二维，通过窗口排除早期弹道运动区间）：\n  - 空间维度 $d = 2$。\n  - 时间数组 $t = [0.0, 0.1, 0.2, 0.3, 0.5, 0.6, 0.8, 1.0]$，单位为 $\\mathrm{ns}$。\n  - MSD 数组 $\\mathrm{MSD}(t) = [0.00, 0.09, 0.36, 0.81, 1.80, 2.23, 3.22, 4.13]$，单位为 $\\mathrm{nm}^2$。\n  - 分析窗口 $\\left[t_{\\min}, t_{\\max}\\right] = [0.5, 1.0]$，单位为 $\\mathrm{ns}$。\n\n- 测试用例 3（三维，各向异性主扩散率聚合为标量 MSD）：\n  - 空间维度 $d = 3$。\n  - 时间数组 $t = [0.2, 0.4, 0.6, 0.8, 1.0, 1.2]$，单位为 $\\mathrm{ns}$。\n  - MSD 数组 $\\mathrm{MSD}(t) = [0.74, 1.43, 2.19, 2.86, 3.60, 4.33]$，单位为 $\\mathrm{nm}^2$。\n  - 分析窗口 $\\left[t_{\\min}, t_{\\max}\\right] = [0.2, 1.2]$，单位为 $\\mathrm{ns}$。\n\n- 测试用例 4（一维，限制导致长时间平台区；从早期时间窗口提取）：\n  - 空间维度 $d = 1$。\n  - 时间数组 $t = [0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6]$，单位为 $\\mathrm{ns}$。\n  - MSD 数组 $\\mathrm{MSD}(t) = [0.00, 0.34, 0.75, 1.07, 1.46, 1.86, 1.95, 1.99, 2.01]$，单位为 $\\mathrm{nm}^2$。\n  - 分析窗口 $\\left[t_{\\min}, t_{\\max}\\right] = [0.2, 0.8]$，单位为 $\\mathrm{ns}$。\n\n算法要求：\n- 对于每个测试用例，选择所有满足 $t_{\\min} \\le t_i \\le t_{\\max}$ 的数据点对 $(t_i, \\mathrm{MSD}_i)$。\n- 对所选窗口上的数据通过最小二乘法拟合一条直线 $\\mathrm{MSD}(t) \\approx S \\, t + C$ 来估算斜率 $S$。\n- 将斜率转换为与 $d$ 维设置一致的标量扩散系数 $D$。\n- 将每个 $D$ 报告为浮点数，单位为 $\\mathrm{nm}^2/\\mathrm{ns}$，四舍五入到三位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[x_1,x_2,x_3,x_4]$），其中每个 $x_i$ 对应于测试用例 $i$ 的扩散系数，四舍五入到三位小数。",
            "solution": "该问题是有效的，因为它具有科学依据、定义明确、客观且内部一致。它提出了计算材料科学中的一个标准任务：从模拟生成的时间序列数据中提取输运系数。所提供的数据和参数是充分且物理上合理的。\n\n我们的步骤是从第一性原理构建的，从宏观扩散方程开始，并将其与均方位移的微观统计定义联系起来。\n\n统计力学的一个基本原则是，由菲克定律主导的宏观扩散是组成粒子微观随机游走的集体结果。对于浓度为 $\\rho(\\mathbf{r}, t)$ 的守恒量，其在均匀、各向同性的介质中的演化由扩散方程描述。在 $d$ 维空间中，该方程为：\n$$\n\\frac{\\partial \\rho(\\mathbf{r}, t)}{\\partial t} = D \\nabla^2 \\rho(\\mathbf{r}, t)\n$$\n其中 $D$ 是标量扩散系数，$\\nabla^2$ 是 $d$ 维拉普拉斯算子。对于从原点 $\\mathbf{r}(0) = \\mathbf{0}$ 开始的单个粒子，浓度 $\\rho$ 可以解释为粒子位置的概率密度函数。对于原点的瞬时点源（初始条件为狄拉克δ函数 $\\rho(\\mathbf{r}, 0) = \\delta(\\mathbf{r})$），扩散方程的解是高斯解或基本解：\n$$\n\\rho(\\mathbf{r}, t) = \\frac{1}{(4 \\pi D t)^{d/2}} \\exp\\left(-\\frac{|\\mathbf{r}|^2}{4 D t}\\right)\n$$\n该函数描述了在时间 $t$ 找到粒子位于位置 $\\mathbf{r}$ 的概率。\n\n均方位移 $\\mathrm{MSD}(t)$ 定义为在时间间隔 $t$ 内，粒子从其原点移动的欧几里得距离平方的系综平均值。对于从原点开始的粒子，这表示为：\n$$\n\\mathrm{MSD}(t) = \\langle |\\mathbf{r}(t)|^2 \\rangle\n$$\n该期望值可以通过对所有可能位置进行积分来计算，并由概率密度 $\\rho(\\mathbf{r}, t)$ 加权：\n$$\n\\mathrm{MSD}(t) = \\int_{\\mathbb{R}^d} |\\mathbf{r}|^2 \\rho(\\mathbf{r}, t) \\, d^d\\mathbf{r}\n$$\n代入 $\\rho(\\mathbf{r}, t)$ 的高斯解，并认识到 $|\\mathbf{r}|^2 = \\sum_{i=1}^d x_i^2$，该积分变为：\n$$\n\\mathrm{MSD}(t) = \\sum_{i=1}^d \\int_{\\mathbb{R}^d} x_i^2 \\frac{1}{(4 \\pi D t)^{d/2}} \\exp\\left(-\\sum_{j=1}^d \\frac{x_j^2}{4 D t}\\right) \\, d x_1 \\dots d x_d\n$$\n该积分可分离为一维积分的乘积。对于每个坐标 $x_i$，$\\int_{-\\infty}^{\\infty} x_i^2 \\frac{1}{\\sqrt{4 \\pi D t}} \\exp(-\\frac{x_i^2}{4 D t}) \\, dx_i$ 项是均值为0、方差为 $\\sigma^2 = 2Dt$ 的一维高斯分布的二阶矩（方差）。该积分的值恰好是 $2Dt$。由于所有其他形式为 $\\int_{-\\infty}^{\\infty} \\rho(x_j, t) \\, dx_j$（其中 $j \\neq i$）的一维积分都等于 $1$，我们发现对于每个维度 $i$，$\\langle x_i^2 \\rangle = 2Dt$。对所有 $d$ 个维度求和，得到著名的正常扩散爱因斯坦关系式：\n$$\n\\mathrm{MSD}(t) = \\sum_{i=1}^d \\langle x_i(t)^2 \\rangle = \\sum_{i=1}^d 2Dt = 2dDt\n$$\n这个方程建立了均方位移与时间之间的直接线性关系 $\\mathrm{MSD}(t) = S \\cdot t$，其中斜率 $S$ 由 $S = 2dD$ 给出。因此，扩散系数 $D$ 可以通过经验测量的 MSD-时间图的斜率，由以下公式确定：\n$$\nD = \\frac{S}{2d}\n$$\n问题指定提供了材料模拟的 $\\mathrm{MSD}(t)$ 数据。这些数据会受到统计噪声的影响，并可能表现出不同的物理区间。在极短时间（弹道运动区间，$t \\to 0$）内，$\\mathrm{MSD} \\propto t^2$。在极长时间内，粒子可能会受到有限尺寸效应或限制（笼蔽效应）的影响，导致 MSD 出现平台区。线性的扩散区间位于这两个极端之间。任务是通过分析预期为线性扩散行为主导的指定时间窗口 $[t_{\\min}, t_{\\max}]$ 内的数据来估算 $D$。\n\n计算流程如下：\n1. 对于每个测试用例，提供的 时间数组 $t$ 和 $\\mathrm{MSD}$ 数组被过滤，以仅保留落在指定分析窗口内的数据点 $(t_i, \\mathrm{MSD}_i)$，即满足 $t_{\\min} \\le t_i \\le t_{\\max}$。将过滤后的数据集表示为 $\\{(t'_j, y'_j)\\}_{j=1}^N$。\n\n2. 一个线性模型 $y'(t') = S t' + C$ 使用普通最小二乘法 (OLS) 拟合到该过滤后的数据集。目标是找到最小化残差平方和的斜率 $S$ 和截距 $C$。斜率 $S$ 的公式为：\n$$\nS = \\frac{N \\sum_{j=1}^{N} t'_j y'_j - (\\sum_{j=1}^{N} t'_j)(\\sum_{j=1}^{N} y'_j)}{N \\sum_{j=1}^{N} (t'_j)^2 - (\\sum_{j=1}^{N} t'_j)^2}\n$$\n此计算将以数值方式执行。\n\n3. 根据线性回归确定的斜率 $S$，使用针对相应空间维度 $d$ 推导出的关系式计算扩散系数 $D$：\n$$\nD = \\frac{S}{2d}\n$$\n$t$ 的单位是纳秒 ($\\mathrm{ns}$)，$\\mathrm{MSD}$ 的单位是平方纳米 ($\\mathrm{nm}^2$)，因此斜率 $S$ 的单位是 $\\mathrm{nm}^2/\\mathrm{ns}$。所得的扩散系数 $D$ 也将具有所需的单位 $\\mathrm{nm}^2/\\mathrm{ns}$。\n\n4. 每个测试用例的最终计算出的 $D$ 值四舍五入到三位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates diffusion coefficients from Mean Squared Displacement (MSD) data\n    for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path, three-dimensional isotropic diffusion)\n        {\n            \"d\": 3,\n            \"t\": np.array([0.5, 1.0, 1.5, 2.0, 2.5]),\n            \"msd\": np.array([1.47, 3.02, 4.49, 6.04, 7.50]),\n            \"window\": (0.5, 2.5)\n        },\n        # Test case 2 (two-dimensional, early-time ballistic regime excluded via window)\n        {\n            \"d\": 2,\n            \"t\": np.array([0.0, 0.1, 0.2, 0.3, 0.5, 0.6, 0.8, 1.0]),\n            \"msd\": np.array([0.00, 0.09, 0.36, 0.81, 1.80, 2.23, 3.22, 4.13]),\n            \"window\": (0.5, 1.0)\n        },\n        # Test case 3 (three-dimensional anisotropic principal diffusivities aggregated into scalar MSD)\n        {\n            \"d\": 3,\n            \"t\": np.array([0.2, 0.4, 0.6, 0.8, 1.0, 1.2]),\n            \"msd\": np.array([0.74, 1.43, 2.19, 2.86, 3.60, 4.33]),\n            \"window\": (0.2, 1.2)\n        },\n        # Test case 4 (one-dimensional, confinement causing long-time plateau; extract from early-time window)\n        {\n            \"d\": 1,\n            \"t\": np.array([0.0, 0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6]),\n            \"msd\": np.array([0.00, 0.34, 0.75, 1.07, 1.46, 1.86, 1.95, 1.99, 2.01]),\n            \"window\": (0.2, 0.8)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current case\n        d = case[\"d\"]\n        t_full = case[\"t\"]\n        msd_full = case[\"msd\"]\n        t_min, t_max = case[\"window\"]\n\n        # Step 1: Select data within the specified time window\n        # Create a boolean mask for times within the window [t_min, t_max]\n        indices = (t_full >= t_min)  (t_full = t_max)\n        t_window = t_full[indices]\n        msd_window = msd_full[indices]\n        \n        # Step 2: Fit a straight line by least squares to estimate the slope S\n        # np.polyfit with degree 1 performs a linear regression and returns [slope, intercept]\n        if len(t_window)  2:\n            # Not enough points for a linear fit, though problem guarantees this won't happen.\n            # Handle this case gracefully if it were a general function.\n            slope = np.nan\n        else:\n            # The model is MSD(t) = S*t + C\n            coeffs = np.polyfit(t_window, msd_window, 1)\n            slope = coeffs[0]\n\n        # Step 3: Convert the slope to the scalar diffusion coefficient D\n        # The Einstein relation is MSD(t) = 2*d*D*t, so slope S = 2*d*D\n        # Therefore, D = S / (2*d)\n        diffusion_coefficient = slope / (2 * d)\n\n        # Step 4: Round the diffusion coefficient to three decimal places\n        # The result must be a float, not a string at this stage\n        rounded_d = round(diffusion_coefficient, 3)\n        results.append(rounded_d)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) is used to format each float as a string before joining.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在真实的模拟中，我们处理的是离散且带有噪声的原始原子轨迹，而非理想化的MSD曲线。本练习将引导你构建一个更贴近现实的分析流程，从生成合成轨迹数据开始，这些数据包含了弹道运动、周期性边界条件和测量噪声等典型复杂性。你将通过实践学习如何正确处理这些伪影，例如通过展开轨迹来修正周期性边界的影响，从而从原始数据中稳健地估算扩散系数 。",
            "id": "3794098",
            "problem": "您的任务是设计并实现一个程序，该程序能根据真实多尺度材料模拟条件下离散采样的粒子轨迹来估算扩散系数。该估算必须对有限时间步长效应、短时弹道瞬变、测量噪声和周期性边界条件具有鲁棒性。\n\n您必须从定义随机运动如何随时间累积的基本原理出发，构建一种算法，使用经验计算的均方位移（MSD）来提取扩散系数，而无需依赖任何预先给定的简化公式。您的算法必须与以均匀时间步长获得的离散采样数据兼容。\n\n适用以下准则：\n\n- 为每个测试用例构建离散时间轨迹，作为在维度为 $d$ 的空间中以均匀时间增量 $\\Delta t$ 采样的位置序列 $\\{\\mathbf{r}_0,\\mathbf{r}_1,\\dots,\\mathbf{r}_N\\}$，其中位置可能会因周期性边界条件而被包裹（wrapped）。\n- 如果应用周期性边界，则可观测位置 $\\mathbf{r}_n$ 是每个维度上对盒子长度 $L$ 取模的位置。为了进行估算，您必须仅使用观测数据和已知的 $L$ 来重建一个与周期性一致的展开（unwrapped）轨迹。在展开时，假设采用最小镜像穿越。\n- 使用离散数据上的重叠窗口计算离散延迟指数 $k$ 处的经验均方位移（MSD）。对于每个延迟指数 $k$，构建所有相隔 $k$ 个时间步长的可用位移，并将它们聚合为延迟时间 $\\tau_k = k\\,\\Delta t$ 处的MSD。\n- 为了减轻离散采样和短时瞬变的影响，请将估算限制在指定的延迟指数拟合窗口 $\\{k_{\\min},\\dots,k_{\\max}\\}$ 内。在该窗口内，将MSD作为延迟时间的函数进行直线拟合，以获得一个斜率和一个考虑了任何附加测量噪声的截距。根据斜率和维度 $d$ 推导出扩散系数。\n- 每个测试用例的结果是一个浮点数，等于以 $\\mathrm{m}^2/\\mathrm{s}$ 为单位的估算扩散系数。每个扩散系数都以 $\\mathrm{m}^2/\\mathrm{s}$ 表示，并以六位有效数字打印。\n\n测试套件包含四个合成案例。对于每个案例，您必须首先生成一个与指定物理和参数一致的轨迹，然后根据生成的观测位置估算扩散系数。\n\n所有案例通用的轨迹生成规则：\n\n- 设每个维度的物理扩散常数为 $D_\\alpha$（$\\alpha \\in \\{1,\\dots,d\\}$），每个时间步长的独立高斯增量均值为零，方差为 $2\\,D_\\alpha\\,\\Delta t$。\n- 可选的短时弹道运动：对于指定数量的初始步数 $n_{\\mathrm{ballistic}}$，将一个恒定的速度矢量 $\\mathbf{v}_0$ 叠加到每步的增量上，使早期演化呈弹道式。$\\mathbf{v}_0$ 的方向必须在 $d$ 维空间中均匀随机，其大小如下文规定。\n- 周期性边界条件：如果指定了盒子长度 $L$，则每次更新后将每个维度的位置包裹到 $[0,L)$ 区间内。\n- 测量噪声：生成包裹后的位置后，向观测位置的每个坐标添加标准差为 $\\sigma$ 的独立高斯噪声。如果存在周期性边界，则在添加噪声后再进行一次包裹，以使值保持在 $[0,L)$ 区间内。\n- 在每个案例中都使用固定的随机种子以保证可复现性。\n\n您的程序必须处理以下四个案例：\n\n- 案例 A（各向同性扩散，无周期性边界，轻度噪声）：\n  - 维度：$d = 3$\n  - 各维度扩散常数：对于所有 $\\alpha$，$D_\\alpha = 1.3\\times 10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$\n  - 时间步长：$\\Delta t = 5\\times 10^{-12}\\ \\mathrm{s}$\n  - 步数：$N = 15000$\n  - 弹道步数：$n_{\\mathrm{ballistic}} = 0$ (无弹道运动)\n  - 测量噪声标准差：$\\sigma = 2\\times 10^{-11}\\ \\mathrm{m}$\n  - 周期性盒子长度：无\n  - 拟合窗口：$k_{\\min} = 5$, $k_{\\max} = 800$\n  - 随机种子：$7$\n\n- 案例 B（带短时弹道瞬变的各向同性扩散，无周期性边界）：\n  - 维度：$d = 3$\n  - 各维度扩散常数：对于所有 $\\alpha$，$D_\\alpha = 5\\times 10^{-10}\\ \\mathrm{m}^2/\\mathrm{s}$\n  - 时间步长：$\\Delta t = 1\\times 10^{-12}\\ \\mathrm{s}$\n  - 步数：$N = 12000$\n  - 弹道步数：$n_{\\mathrm{ballistic}} = 50$\n  - 弹道速度大小：$\\|\\mathbf{v}_0\\| = 80\\ \\mathrm{m}/\\mathrm{s}$\n  - 测量噪声标准差：$\\sigma = 1\\times 10^{-11}\\ \\mathrm{m}$\n  - 周期性盒子长度：无\n  - 拟合窗口：$k_{\\min} = 60$, $k_{\\max} = 600$\n  - 随机种子：$21$\n\n- 案例 C（二维各向异性扩散，带周期性边界和轻度噪声）：\n  - 维度：$d = 2$\n  - 各维度扩散常数：$D_1 = 1.0\\times 10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$, $D_2 = 3.0\\times 10^{-9}\\ \\mathrm{m}^2/\\mathrm{s}$\n  - 时间步长：$\\Delta t = 2\\times 10^{-12}\\ \\mathrm{s}$\n  - 步数：$N = 10000$\n  - 弹道步数：$n_{\\mathrm{ballistic}} = 0$\n  - 测量噪声标准差：$\\sigma = 5.0\\times 10^{-12}\\ \\mathrm{m}$\n  - 周期性盒子长度：$L = 1.0\\times 10^{-5}\\ \\mathrm{m}$\n  - 拟合窗口：$k_{\\min} = 10$, $k_{\\max} = 700$\n  - 随机种子：$84$\n\n- 案例 D（一维扩散，采用粗采样和强测量噪声，无周期性边界）：\n  - 维度：$d = 1$\n  - 各维度扩散常数：$D_1 = 1.0\\times 10^{-10}\\ \\mathrm{m}^2/\\mathrm{s}$\n  - 时间步长：$\\Delta t = 1.0\\times 10^{-10}\\ \\mathrm{s}$\n  - 步数：$N = 3000$\n  - 弹道步数：$n_{\\mathrm{ballistic}} = 0$\n  - 测量噪声标准差：$\\sigma = 1.0\\times 10^{-9}\\ \\mathrm{m}$\n  - 周期性盒子长度：无\n  - 拟合窗口：$k_{\\min} = 200$, $k_{\\max} = 800$\n  - 随机种子：$100$\n\n实现和输出要求：\n\n- 对于每个案例，根据上述规则生成观测位置，如果指定了周期性边界，则重建展开位置，计算指定拟合窗口（含边界）内所有延迟指数 $k$ 的经验均方位移（MSD），在窗口内对MSD与延迟时间的关系进行直线拟合，并根据拟合得到的斜率计算扩散系数。在指定窗口内使用普通最小二乘法。\n- 您的程序应生成单行输出，其中包含四个扩散系数，按案例A、案例B、案例C、案例D的顺序排列，格式为用方括号括起来的逗号分隔列表（例如，$[\\mathrm{result}_A,\\mathrm{result}_B,\\mathrm{result}_C,\\mathrm{result}_D]$）。每个结果都必须是一个以 $\\mathrm{m}^2/\\mathrm{s}$ 为单位的浮点数，并以六位有效数字打印。",
            "solution": "从粒子轨迹估算扩散系数是随机过程分析中的一项基本任务，尤其在材料科学和生物物理学领域。所提供的方法论植根于统计力学的原理，特别是爱因斯坦关系，它将宏观扩散系数与粒子的微观随机运动联系起来。\n\n其核心原理是，对于进行布朗运动的粒子，其均方位移（MSD）在扩散区域内随时间线性增长。对于一个 $d$ 维空间，理论上的MSD，记为 $\\langle \\Delta r^2(\\tau) \\rangle$，作为延迟时间 $\\tau$ 的函数由下式给出：\n$$\n\\langle \\Delta r^2(\\tau) \\rangle = \\langle |\\mathbf{r}(t+\\tau) - \\mathbf{r}(t)|^2 \\rangle = 2 D_{total} \\tau\n$$\n其中 $\\mathbf{r}(t)$ 是粒子在时间 $t$ 的位置，$D_{total}$ 是总扩散系数。如果扩散是各向同性的，各维度系数为 $D$，则 $D_{total} = dD$。如果扩散是各向异性的，各维度系数为 $D_\\alpha$（其中 $\\alpha \\in \\{1, 2, \\dots, d\\}$），则 $D_{total} = \\sum_{\\alpha=1}^{d} D_\\alpha$。无论哪种情况，该关系都可以用平均的各维度扩散系数 $D_{avg} = (\\sum_{\\alpha} D_\\alpha) / d$ 来表示：\n$$\n\\langle \\Delta r^2(\\tau) \\rangle = 2d D_{avg} \\tau\n$$\n问题在于如何从一个离散且带噪声的轨迹中估算这个平均扩散系数 $D_{avg}$。该过程包括几个步骤：轨迹生成、轨迹分析以计算经验MSD，以及线性回归以提取系数。\n\n轨迹生成模拟了粒子的路径。该运动被建模为离散时间随机游走。对于每个时间步长 $\\Delta t$，粒子的位置 $\\mathbf{r}_n$ 更新为 $\\mathbf{r}_{n+1}$。每个维度 $\\alpha$ 的位移从均值为0、方差为 $2D_\\alpha\\Delta t$ 的高斯分布中抽取，代表扩散步骤。这是对布朗运动基础上的维纳过程的直接离散化。为了模拟真实的模拟数据，引入了额外的复杂性：\n1. 通过在初始的 $n_{\\mathrm{ballistic}}$ 步中增加一个恒定的速度分量 $\\mathbf{v}_0 \\Delta t$ 来包含短时弹道运动。这导致在非常短的 $\\tau$ 内，MSD随时间呈二次方增长，即 $\\langle \\Delta r^2(\\tau) \\rangle \\propto \\tau^2$。\n2. 周期性边界条件（PBC）将粒子限制在边长为 $L$ 的盒子内。观测到的位置被包裹，$\\mathbf{r}_{obs} = \\mathbf{r}_{true} \\pmod L$。\n3. 通过在每个时间步向观测位置的每个坐标添加一个来自标准差为 $\\sigma$ 的高斯分布的随机位移来模拟测量噪声。\n\n对生成轨迹的分析始于重建一条连续路径。如果存在PBC，必须将包裹的观测轨迹 $\\{\\mathbf{r}^{obs}_n\\}$ “展开”为 $\\{\\mathbf{r}^{unwrapped}_n\\}$。这是通过假设位移遵循最小镜像约定来实现的。第 $n$ 步的展开位置是通过在前一步的基础上加上代表周期空间中最短路径的位移来计算的：\n$$\n\\mathbf{r}^{unwrapped}_n = \\mathbf{r}^{unwrapped}_{n-1} + (\\mathbf{r}^{obs}_n - \\mathbf{r}^{obs}_{n-1}) - L \\cdot \\mathrm{round}\\left(\\frac{\\mathbf{r}^{obs}_n - \\mathbf{r}^{obs}_{n-1}}{L}\\right)\n$$\n其中 $\\mathbf{r}^{unwrapped}_0 = \\mathbf{r}^{obs}_0$。这个修正后的轨迹随后用于MSD的计算。\n\n经验MSD是根据包含 $N+1$ 个点的离散轨迹 $\\{\\mathbf{r}_n\\}$ 计算的。对于每个延迟指数 $k$（对应于延迟时间 $\\tau_k = k\\Delta t$），MSD是所有可能时间起点上的位移平方的平均值：\n$$\n\\mathrm{MSD}(\\tau_k) = \\frac{1}{N-k+1} \\sum_{i=0}^{N-k} |\\mathbf{r}_{i+k} - \\mathbf{r}_i|^2\n$$\n此计算针对指定拟合窗口 $[k_{\\min}, k_{\\max}]$ 内的所有延迟指数 $k$ 执行。\n\n最后一步是参数估计。伪影（artifacts）的存在会导致与理想线性关系的偏离。短时间内的弹道运动和长时间延迟下的统计不确定性（由于样本较少）使得拟合必须在一个中间窗口 $[k_{\\min}, k_{\\max}]$ 内进行，在该窗口内运动被认为是扩散性的。每个坐标方差为 $\\sigma^2$ 的测量噪声会给真实的MSD增加一个恒定的偏移量。两个带噪声的观测值 $\\mathbf{r}' = \\mathbf{r} + \\boldsymbol{\\epsilon}$ 之间的位移平方为 $|\\mathbf{r}'_{i+k} - \\mathbf{r}'_i|^2 = |(\\mathbf{r}_{i+k} - \\mathbf{r}_i) + (\\boldsymbol{\\epsilon}_{i+k} - \\boldsymbol{\\epsilon}_i)|^2$。对许多对进行平均后，交叉项消失，测得的MSD约等于真实的MSD加上噪声差异的方差，即 $\\langle |\\boldsymbol{\\epsilon}_{i+k}|^2 + |\\boldsymbol{\\epsilon}_i|^2 \\rangle = 2d\\sigma^2$。因此，经验MSD可以用以下线性方程建模：\n$$\n\\mathrm{MSD}(\\tau_k) \\approx m \\tau_k + c\n$$\n其中斜率是 $m = 2d D_{avg}$，截距 $c \\approx 2d\\sigma^2$ 用于解释噪声。对 $k \\in [k_{\\min}, k_{\\max}]$ 的数据点 $(\\tau_k, \\mathrm{MSD}(\\tau_k))$ 执行普通最小二乘回归，以找到最佳拟合斜率 $m$。\n\n根据拟合的斜率 $m$，平均的各维度扩散系数估算如下：\n$$\nD_{est} = \\frac{m}{2d}\n$$\n将此过程应用于所有四个指定的案例，从而得到一个能够系统地解释所规定的物理和数值效应的鲁棒的扩散系数估算值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases for diffusion coefficient estimation.\n    \"\"\"\n    \n    test_cases = [\n        # Case A\n        {\n            \"d\": 3, \"D_alpha\": np.array([1.3e-9]), \"dt\": 5e-12, \"N\": 15000,\n            \"n_ballistic\": 0, \"v0_mag\": 0.0, \"sigma\": 2e-11, \"L\": None,\n            \"k_min\": 5, \"k_max\": 800, \"seed\": 7,\n        },\n        # Case B\n        {\n            \"d\": 3, \"D_alpha\": np.array([5e-10]), \"dt\": 1e-12, \"N\": 12000,\n            \"n_ballistic\": 50, \"v0_mag\": 80.0, \"sigma\": 1e-11, \"L\": None,\n            \"k_min\": 60, \"k_max\": 600, \"seed\": 21,\n        },\n        # Case C\n        {\n            \"d\": 2, \"D_alpha\": np.array([1.0e-9, 3.0e-9]), \"dt\": 2e-12, \"N\": 10000,\n            \"n_ballistic\": 0, \"v0_mag\": 0.0, \"sigma\": 5.0e-12, \"L\": 1.0e-5,\n            \"k_min\": 10, \"k_max\": 700, \"seed\": 84,\n        },\n        # Case D\n        {\n            \"d\": 1, \"D_alpha\": np.array([1.0e-10]), \"dt\": 1.0e-10, \"N\": 3000,\n            \"n_ballistic\": 0, \"v0_mag\": 0.0, \"sigma\": 1.0e-9, \"L\": None,\n            \"k_min\": 200, \"k_max\": 800, \"seed\": 100,\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        D_est = estimate_diffusion_coefficient(params)\n        # Format to six significant figures using general format specifier\n        results.append(f\"{D_est:.6g}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef estimate_diffusion_coefficient(params):\n    \"\"\"\n    Generates a trajectory and estimates the diffusion coefficient based on the given parameters.\n    \"\"\"\n    # Unpack parameters\n    d = params[\"d\"]\n    D_alpha = params[\"D_alpha\"]\n    dt = params[\"dt\"]\n    N = params[\"N\"]\n    n_ballistic = params[\"n_ballistic\"]\n    v0_mag = params[\"v0_mag\"]\n    sigma = params[\"sigma\"]\n    L = params[\"L\"]\n    k_min = params[\"k_min\"]\n    k_max = params[\"k_max\"]\n    seed = params[\"seed\"]\n    \n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # If D_alpha is a single value, broadcast it to all dimensions\n    if len(D_alpha) == 1:\n        D_alpha = np.repeat(D_alpha, d)\n\n    # --- 1. Trajectory Generation ---\n    r_true = np.zeros((N + 1, d))\n    \n    # Generate ballistic velocity vector if applicable\n    v0 = np.zeros(d)\n    if n_ballistic > 0 and v0_mag > 0:\n        # Generate a random direction vector on a d-dimensional unit sphere\n        v0_dir = rng.normal(size=d)\n        norm = np.linalg.norm(v0_dir)\n        if norm > 0:\n            v0 = (v0_dir / norm) * v0_mag\n    \n    # Standard deviation for diffusive steps for each dimension\n    std_devs = np.sqrt(2 * D_alpha * dt)\n\n    for n in range(N):\n        # Diffusive step\n        diff_step = rng.normal(loc=0.0, scale=std_devs, size=d)\n        \n        # Ballistic step\n        ballistic_step = v0 * dt if n  n_ballistic else np.zeros(d)\n        \n        # Total step and position update\n        r_true[n+1] = r_true[n] + diff_step + ballistic_step\n    \n    # Apply periodic boundary conditions to the true trajectory if needed\n    r_wrapped = r_true if L is None else r_true % L\n\n    # Add measurement noise\n    noise = rng.normal(loc=0.0, scale=sigma, size=(N + 1, d))\n    r_obs = r_wrapped + noise\n\n    # Apply PBC again after adding noise if needed\n    if L is not None:\n        r_obs = r_obs % L\n\n    # --- 2. Trajectory Analysis ---\n    \n    # Select trajectory for analysis (unwrapped if PBC, observed otherwise)\n    if L is not None:\n        # Unwrap trajectory using minimum image convention\n        r_unwrapped = np.zeros_like(r_obs)\n        r_unwrapped[0] = r_obs[0]\n        for n in range(1, N + 1):\n            delta_obs = r_obs[n] - r_obs[n-1]\n            correction = -L * np.round(delta_obs / L)\n            r_unwrapped[n] = r_unwrapped[n-1] + delta_obs + correction\n        r_analysis = r_unwrapped\n    else:\n        r_analysis = r_obs\n        \n    # --- 3. MSD Calculation and Fitting ---\n    lag_indices = np.arange(k_min, k_max + 1)\n    lag_times = lag_indices * dt\n    msd_values = []\n\n    for k in lag_indices:\n        # Calculate squared displacements using overlapping windows\n        displacements = r_analysis[k:] - r_analysis[:-k]\n        sq_disps = np.sum(displacements**2, axis=1)\n        msd_values.append(np.mean(sq_disps))\n    \n    msd_values = np.array(msd_values)\n\n    # Perform linear regression on MSD vs. lag time\n    # scipy.stats.linregress(x, y)\n    slope, intercept, r_value, p_value, std_err = stats.linregress(lag_times, msd_values)\n\n    # --- 4. Diffusion Coefficient Extraction ---\n    # MSD = 2 * d * D_avg * t, so slope = 2 * d * D_avg\n    D_avg_est = slope / (2 * d)\n    \n    return D_avg_est\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在分析实验或模拟数据时，一个关键挑战是“盲目地”识别出有效的扩散区域，因为弹道运动、陷笼效应和扩散行为之间的界限并非预先可知。本练习要求你设计一种数据驱动的自适应算法，通过分析MSD曲线的局部标度指数 $\\alpha(t) = \\frac{d \\ln(\\text{MSD})}{d \\ln(t)}$ 来自动定位线性扩散区。掌握这种方法使你能够客观地分析具有复杂动力学（如非晶态合金）的系统，而无需依赖任意选择的拟合窗口 。",
            "id": "3731737",
            "problem": "给定结构无序的非晶高熵合金的均方位移（$MSD(t)$）随时间变化的时间序列。您的目标是估算长时自扩散系数 $D$，同时严格排除早期弹道区和中期笼蔽区的贡献。您的程序必须实现一种基于原理、数据自适应的方法，该方法能够在不使用任何固定的、硬编码的时间截断值的情况下，识别出 $MSD(t)$ 的渐近线性区。\n\n您可以依赖的出发点和物理基础：\n- 在极短的时间 $t$ 内，粒子运动保留惯性，位移主要由速度持续性决定，此时 $MSD(t)$ 随时间近似呈二次函数增长。\n- 非晶系统中的结构无序会产生瞬态的“笼”，阻碍粒子运动，这通常导致 $MSD(t)$ 在一个中间时间窗口内呈现近平台或亚线性增长。\n- 在足够长的时间后，对于三维空间中的各向同性均匀材料，中心极限定理和初始条件记忆的丧失意味着 $MSD(t)$ 在扩散区内随 $t$ 线性增长。\n\n您的方法必须：\n1. 通过分析 $MSD(t)$ 相对于 $t$ 的局域标度行为，以数据驱动的方式检测并排除早期弹道区和中期笼蔽区。该方法不得假定任何关于区分不同区域的精确截断时间的先验知识。\n2. 识别出一个稳定的时间窗口，在此窗口内 $MSD(t)$ 与 $t$ 呈渐近线性关系。在此窗口内，对普通（非对数）坐标下的 $MSD$ 与 $t$ 进行稳健的线性拟合。\n3. 根据拟合得到的三维长时线性行为，推断出自扩散系数 $D$，并以要求的单位报告该值。\n\n数学和算法要求：\n- 使用滑动窗口分析局域标度指数 $ \\alpha = \\dfrac{d \\log(MSD)}{d \\log(t)} $ 来检测扩散区，其中 $ \\alpha $ 接近 $ 1 $。您必须设计一个关于“足够接近”和“足够稳定”的量化标准，并从算法上证明其合理性。\n- 在候选扩散窗口内，对 $MSD$ 与 $t$ 使用稳健线性回归，以减轻噪声和异常值的影响。\n- 当多个候选窗口满足您的标准时，实现一个决策规则来选择最终的拟合窗口。该规则必须通过一个适当的量化评分，优先选择更长且线性度更高的窗口。\n- 避免使用任何以时间单位直接表示的、固定的、手动调整的截断时间；所有排除操作都必须通过您的标准从数据中发现。\n\n单位和输出：\n- 输入时间 $t$ 的单位是皮秒（$ps$），输入均方位移 $MSD$ 的单位是平方纳米（$nm^2$）。\n- 您必须以米²/秒（$m^2/s$）为单位报告最终的 $D$。\n- 最终结果需表示为包含三位有效数字的科学记数法小数（例如，$1.23 \\times 10^{-8}$ 应打印为 $1.23e-08$）。打印格式必须为单行，内容是方括号内由逗号分隔的列表，如 $[d_1,d_2,d_3,d_4]$，不含空格，其中每个 $d_i$ 是对应测试用例的估算扩散系数，单位为 $m^2/s$。\n\n综合测试套件：\n您必须生成四个综合 $MSD(t)$ 数据集，每个数据集都是三个具有物理动机的分量的带噪平滑组合：一个衰减的早期弹道贡献，一个出现后又衰减的笼蔽平台，以及一个逐渐启动的长时扩散增长。对于每个数据集，生成一个时间网格 $t_i$，然后构建\n$$\nMSD(t) \\;=\\; v_2\\, t^2 \\, e^{-\\left(\\frac{t}{t_b}\\right)^2}\n\\;+\\; a \\left(1 - e^{-\\left(\\frac{t}{t_c}\\right)^2}\\right) e^{-\\left(\\frac{t}{t_d}\\right)^2}\n\\;+\\; 6 D \\, t \\left(1 - e^{-\\left(\\frac{t}{t_d}\\right)^2}\\right)\n\\;+\\; \\eta,\n$$\n其中：\n- $t$ 的单位是 $ps$，\n- $MSD$ 的单位是 $nm^2$，\n- $v_2$ 的单位是 $nm^2/ps^2$，\n- $a$ 的单位是 $nm^2$，\n- $t_b, t_c, t_d$ 的单位是 $ps$，\n- $D$ 的单位是 $nm^2/ps$，\n- $\\eta$ 是附加的零均值高斯噪声，其标准差为 $\\sigma$，单位为 $nm^2$；如果 $MSD(t)$ 因噪声在任何点变为非正值，则将其裁剪为一个小的正数下限 $10^{-12}\\,nm^2$，以确保对数函数有定义。\n\n对于每个测试用例，使用一个包含 $N$ 个点的均匀间隔时间网格 $t_i$，范围从 $t_{\\min}$ 到 $t_{\\max}$（包含两端），其中 $t_{\\min} = 10^{-3}\\,ps$。使用以下参数集和随机种子生成数据集：\n\n- 情况 1（理想路径，具有清晰的长扩散尾部）：\n  - $N = 1200$, $t_{\\max} = 100$, $v_2 = 0.50$, $a = 0.20$, $t_b = 0.20$, $t_c = 1.00$, $t_d = 5.00$, $D = 0.020$, $\\sigma = 5.0 \\times 10^{-3}$, seed $= 12345$。\n- 情况 2（扩展的笼蔽效应，扩散阶段出现较晚，较慢的 $D$）：\n  - $N = 1600$, $t_{\\max} = 200$, $v_2 = 0.70$, $a = 0.50$, $t_b = 0.50$, $t_c = 5.00$, $t_d = 30.0$, $D = 0.0050$, $\\sigma = 3.0 \\times 10^{-3}$, seed $= 24680$。\n- 情况 3（轨迹较短，扩散窗口极小，较快的 $D$）：\n  - $N = 900$, $t_{\\max} = 20.0$, $v_2 = 0.60$, $a = 0.30$, $t_b = 0.80$, $t_c = 3.00$, $t_d = 8.00$, $D = 0.0300$, $\\sigma = 1.0 \\times 10^{-2}$, seed $= 13579$。\n- 情况 4（数据噪声较大，中等的 $D$）：\n  - $N = 1400$, $t_{\\max} = 120.0$, $v_2 = 0.40$, $a = 0.25$, $t_b = 0.30$, $t_c = 2.50$, $t_d = 10.0$, $D = 0.0150$, $\\sigma = 2.0 \\times 10^{-2}$, seed $= 11223$。\n\n以上所有数值均如指定，使用基于 $ps$ 和 $nm^2$ 的单位。您必须使用精确的转换因子 $1\\,nm^2/ps = 10^{-6}\\,m^2/s$ 将最终估算的扩散系数转换为 $m^2/s$。\n\n程序要求：\n- 严格按照规定实现数据生成和估算方法。\n- 您的程序应生成单行输出，其中包含四个估算的扩散系数（单位为 $m^2/s$），形式为方括号内由逗号分隔的列表，每个值都以三位有效数字的科学记数法打印（例如，$[2.00e-08,5.00e-09,3.00e-08,1.50e-08]$）。不得打印任何额外文本。",
            "solution": "接下来的论述为从均方位移数据估算自扩散系数的问题提供了一个完整的解决方案。该过程始于对问题陈述进行必要的严格验证。\n\n### 步骤 1：提取给定信息\n\n- **目标**：从均方位移 $MSD(t)$ 的时间序列数据中估算长时自扩散系数 $D$。\n- **物理系统**：结构无序的非晶高熵合金。\n- **物理模型**：粒子运动表现出三个区域：\n    1. 早期弹道区：$MSD(t) \\propto t^2$。\n    2. 中期笼蔽区：$MSD(t)$ 的亚线性增长。\n    3. 长时扩散区：$MSD(t)$ 与 $t$ 呈线性关系。对于三维空间，$MSD(t) = 6Dt$。\n- **核心方法论约束**：该方法必须是数据自适应的，能够在不使用固定的、硬编码的时间截断值的情况下识别线性扩散区。\n- **算法要求**：\n    1. 使用滑动窗口分析局域标度指数 $\\alpha = \\frac{d \\log(MSD)}{d \\log(t)}$ 来寻找 $\\alpha \\approx 1$ 的区域。\n    2. 为 $\\alpha$ 实现关于“足够接近”和“足够稳定”的量化标准。\n    3. 在识别出的扩散窗口内，对 $MSD$ 与 $t$ 使用稳健线性回归。\n    4. 如果存在多个候选窗口，实现一个决策规则来选择最佳窗口，偏好更长且线性度更高的窗口。\n- **单位和转换**：\n    - 输入时间 $t$ 的单位是皮秒（$ps$）。\n    - 输入 $MSD$ 的单位是平方纳米（$nm^2$）。\n    - 最终报告的 $D$ 必须以米²/秒（$m^2/s$）为单位。\n    - 转换因子为 $1\\,nm^2/ps = 10^{-6}\\,m^2/s$。\n- **综合数据生成**：\n    - 公式：$MSD(t) = v_2 t^2 e^{-(t/t_b)^2} + a (1 - e^{-(t/t_c)^2}) e^{-(t/t_d)^2} + 6 D t (1 - e^{-(t/t_d)^2}) + \\eta$。\n    - $\\eta$ 是标准差为 $\\sigma$ 的零均值高斯噪声。\n    - 非正值的 $MSD(t)$ 被裁剪为下限 $10^{-12}\\,nm^2$。\n    - 时间网格：从 $t_{\\min} = 10^{-3}\\,ps$ 到 $t_{\\max}$ 的 $N$ 个均匀间隔点。\n- **测试用例**：提供了四个特定的参数集（情况 1、情况 2、情况 3、情况 4），每个都包含 $N, t_{\\max}, v_2, a, t_b, t_c, t_d, D, \\sigma$ 和一个随机种子的值。\n- **输出格式**：单行输出，包含一个由方括号括起来的、逗号分隔的四个扩散系数值（单位为 $m^2/s$）的列表（例如 `[d1,d2,d3,d4]`），每个值都采用三位有效数字的科学记数法。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n对问题陈述进行严格验证。\n\n1.  **科学或事实上的不健全性**：该问题在科学上是健全的。它基于无序系统中扩散的经典模型，该模型正确地描述了弹道、笼蔽和扩散区域。爱因斯坦关系式 $MSD(t) = 2dDt$（其中维度 $d=3$）的使用以及对局域对数导数 $\\alpha(t)$ 的分析，是凝聚态物理和统计力学中标准的、公认的方法。综合数据模型是这些组合效应的物理上合理的表示。\n2.  **无法形式化或不相关**：该问题高度可形式化，是一个基于物理学的数值分析任务。它直接且明确地与从均方位移计算扩散系数的指定主题相关。\n3.  **设置不完整或矛盾**：问题是完整的。它提供了所有必要的参数、方程和明确的随机种子，以确定性地生成测试数据。对分析方法和输出格式的要求规定得很详细，没有留下任何模糊空间。给定信息中没有矛盾之处。\n4.  **不切实际或不可行**：物理参数和时间尺度代表了非晶材料和复杂液体分子动力学模拟中常见的参数和尺度。该任务具有挑战性，但使用标准数值库是完全可行的。\n5.  **不适定或结构不良**：问题是适定的。它要求使用一种受约束但合理的方法来估算特定参数（$D$）。提供具有已知基准 $D$ 的综合数据，为成功标准提供了明确的依据。核心挑战——设计数据自适应的窗口逻辑——是一个明确定义的算法设计任务，而不是一个不适定的问题。\n6.  **伪深刻、琐碎或同义反复**：问题并非琐碎。对整个数据集进行简单的线性拟合会因弹道区和笼蔽区的贡献而产生错误结果。该问题要求精心实现一种过滤和选择算法，以绕过数据的这些非扩散部分，这是现实世界数据分析中常见且实质性的挑战。\n7.  **超出科学可验证性范围**：问题是完全可验证的。给定固定的种子和确定性的数据生成公式，任何正确的算法实现都将产生相同的输入数据集，并应产生高度可比的最终结果。\n\n### 步骤 3：结论与行动\n\n问题是**有效的**。它在科学上是健全的、适定的，并提出了一个清晰、非琐碎的挑战，代表了现实世界中的科学数据分析。可以继续进行求解过程。\n\n### 基于原理的解决方案设计\n\n核心目标是从均方位移 $MSD(t)$ 的长时线性区估算扩散系数 $D$。三维空间中的关系由爱因斯坦方程给出：\n$$MSD(t) = 6Dt + C$$\n其中 $C$ 是一个截距项。我们的任务是分离出这种线性关系成立的时间窗口，并稳健地估计斜率，该斜率等于 $6D$。该方法必须是数据自适应的，避免任意的时间截断。\n\n**步骤 1：局域标度指数计算**\n\n为了区分不同的动力学区域，我们分析局域标度指数 $\\alpha(t)$，其定义为 $MSD(t)$ 相对于 $t$ 的对数导数：\n$$\\alpha(t) = \\frac{d \\log(MSD(t))}{d \\log(t)}$$\n该指数用于量化时间 $t$ 附近的幂律关系 $MSD(t) \\sim t^{\\alpha(t)}$。对于弹道区，期望值为 $\\alpha \\approx 2$；对于笼蔽区，为 $\\alpha  1$（通常接近 $0$）；对于扩散区，为 $\\alpha \\approx 1$。\n\n对含噪数据直接进行数值微分是不稳定的，因为它会放大噪声。一种更稳健的方法是通过在以 $t_i$ 为中心的滑动窗口内对 $\\log(MSD)$ 与 $\\log(t)$ 进行线性回归，来计算每个点 $t_i$ 处的 $\\alpha(t_i)$。这种局部拟合的斜率提供了 $\\alpha_i$ 的平滑估计。我们为此计算选择一个固定大小为 51 个点的窗口，这个大小足以平均掉噪声，同时对于给定的数据密度，又小到足以分辨动力学区域的变化。\n\n**步骤 2：识别候选扩散窗口**\n\n扩散区的特征是 $\\alpha(t) \\approx 1$。我们为此条件定义一个量化标准：我们识别所有计算出的指数 $\\alpha_i$ 落在 $1$ 附近的容差带内的时间点 $t_i$。我们将其设置为：\n$$| \\alpha_i - 1.0 |  \\delta_{\\alpha}$$\n我们选择容差 $\\delta_{\\alpha} = 0.1$，以识别局域标度在 $t^{0.9}$ 和 $t^{1.1}$ 之间的点。\n\n为确保稳定性和统计显著性，我们关注的不是满足此标准的孤立点，而是足够长度的连续段。我们找出所有满足条件的连续索引块，并舍弃任何长度小于最小长度的块。此最小长度设为总数据点数 $N$ 的 $10\\%$，以确保任何后续的线性拟合都是在轨迹的一个重要部分上执行的。\n\n**步骤 3：稳健回归和最终窗口选择**\n\n对于每个识别出的候选窗口，执行 $MSD$ 与 $t$ 的线性拟合。由于数据含有噪声，稳健回归方法优于标准的普通最小二乘法。我们采用 Theil-Sen 估计器，这是一种对异常值高度稳健的非参数方法。它通过计算连接数据集中所有点对的直线的斜率的中位数来计算斜率。这为斜率 $m = 6D$ 提供了一个可靠的估计。\n\n该问题要求在找到多个候选窗口时，有一个规则来选择最佳窗口。所选规则是：选择满足 $\\alpha$ 标准的**最长**连续窗口。这优先考虑了最稳定和最持久的扩散行为表现。在极少数长度相等的情况下，选择时间上最晚出现的窗口，因为这最能代表系统真正的渐近长时行为。\n\n**步骤 4：扩散系数计算和单位转换**\n\n一旦选择了最优窗口并使用 `scipy.stats.theilslopes` 估算出稳健斜率 $m$：\n1.  模拟单位下的扩散系数计算如下：\n    $$D_{\\text{sim}} = \\frac{m}{6}$$\n    $D_{\\text{sim}}$ 的单位是 $nm^2/ps$。\n2.  使用提供的转换因子将该值转换为所需的国际单位制（SI）单位 $m^2/s$：\n    $$D_{\\text{SI}} [m^2/s] = D_{\\text{sim}} [nm^2/ps] \\times 10^{-6}$$\n3.  最终结果格式化为三位有效数字的科学记数法。\n\n这个自包含的、数据驱动的程序通过系统地识别物理上正确的分析时间区域，稳健地提取扩散系数，完全满足了问题的约束条件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import theilslopes\n\ndef solve():\n    \"\"\"\n    Main function to generate data, run the analysis for all test cases,\n    and print the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, clear long diffusive tail)\n        {'N': 1200, 't_max': 100.0, 'v_2': 0.50, 'a': 0.20, 't_b': 0.20,\n         't_c': 1.00, 't_d': 5.00, 'D': 0.020, 'sigma': 5.0e-3, 'seed': 12345},\n\n        # Case 2 (extended caging, late-onset diffusion, slower D)\n        {'N': 1600, 't_max': 200.0, 'v_2': 0.70, 'a': 0.50, 't_b': 0.50,\n         't_c': 5.00, 't_d': 30.0, 'D': 0.0050, 'sigma': 3.0e-3, 'seed': 24680},\n\n        # Case 3 (short trajectory, minimal diffusive window, faster D)\n        {'N': 900, 't_max': 20.0, 'v_2': 0.60, 'a': 0.30, 't_b': 0.80,\n         't_c': 3.00, 't_d': 8.00, 'D': 0.0300, 'sigma': 1.0e-2, 'seed': 13579},\n\n        # Case 4 (noisier data, moderate D)\n        {'N': 1400, 't_max': 120.0, 'v_2': 0.40, 'a': 0.25, 't_b': 0.30,\n         't_c': 2.50, 't_d': 10.0, 'D': 0.0150, 'sigma': 2.0e-2, 'seed': 11223},\n    ]\n\n    results = []\n    for params in test_cases:\n        t, msd = generate_msd_data(**params)\n        D_si = estimate_diffusion_coefficient(t, msd)\n        results.append(D_si)\n\n    # Format and print the final output exactly as required.\n    print(f\"[{','.join(f'{d:.2e}' for d in results)}]\")\n\ndef generate_msd_data(N, t_max, v_2, a, t_b, t_c, t_d, D, sigma, seed, t_min=1e-3):\n    \"\"\"\n    Generates synthetic MSD data based on the provided formula and parameters.\n    \"\"\"\n    np.random.seed(seed)\n    \n    t = np.linspace(t_min, t_max, N)\n    \n    # Ballistic term\n    msd_ballistic = v_2 * t**2 * np.exp(-(t / t_b)**2)\n    \n    # Caging term\n    msd_caging = a * (1 - np.exp(-(t / t_c)**2)) * np.exp(-(t / t_d)**2)\n    \n    # Diffusive term\n    msd_diffusive = 6 * D * t * (1 - np.exp(-(t / t_d)**2))\n    \n    msd_clean = msd_ballistic + msd_caging + msd_diffusive\n    \n    # Add Gaussian noise\n    noise = np.random.normal(0, sigma, N)\n    msd_noisy = msd_clean + noise\n    \n    # Clip non-positive values to prevent log(0) or log(0) issues\n    msd = np.maximum(msd_noisy, 1e-12)\n    \n    return t, msd\n\ndef estimate_diffusion_coefficient(t, msd):\n    \"\"\"\n    Estimates the diffusion coefficient using a data-adaptive windowing method.\n    \"\"\"\n    N = len(t)\n    \n    # --- Step 1: Calculate local scaling exponent alpha(t) ---\n    # Use a sliding window to perform log-log fits for noise robustness.\n    # The chosen window size must be an odd integer.\n    alpha_window_size = 51 \n    half_window = alpha_window_size // 2\n    \n    alphas = np.full(N, np.nan)\n    \n    log_t = np.log(t)\n    log_msd = np.log(msd)\n    \n    for i in range(half_window, N - half_window):\n        # Define the window for the local fit\n        start, end = i - half_window, i + half_window + 1\n        \n        # polyfit(x, y, 1) returns [slope, intercept]\n        slope, _ = np.polyfit(log_t[start:end], log_msd[start:end], 1)\n        alphas[i] = slope\n\n    # --- Step 2: Identify candidate diffusive windows ---\n    alpha_tolerance = 0.1\n    min_window_frac = 0.1\n    min_len = int(min_window_frac * N)\n\n    # Find indices where alpha is close to 1\n    diffusive_indices = np.where(np.abs(alphas - 1.0)  alpha_tolerance)[0]\n\n    if len(diffusive_indices) == 0:\n        # Fallback if no window is found - this shouldn't happen with the test data\n        return np.nan\n\n    # Group consecutive indices into windows\n    candidate_windows = []\n    if len(diffusive_indices) > 0:\n        # Split a list of indices into sub-lists of consecutive numbers\n        splits = np.where(np.diff(diffusive_indices) != 1)[0] + 1\n        contiguous_blocks = np.split(diffusive_indices, splits)\n        \n        for block in contiguous_blocks:\n            if len(block) >= min_len:\n                candidate_windows.append(block)\n\n    if not candidate_windows:\n        # If no window meets the minimum length, try relaxing criteria (not done here as it's not needed for the given problem)\n        return np.nan # Or handle error appropriately\n\n    # --- Step 3: Select the best window ---\n    # Rule: Choose the longest window. If tied, choose the one latest in time.\n    best_window = max(candidate_windows, key=lambda w: (len(w), w[-1]))\n    \n    t_window = t[best_window]\n    msd_window = msd[best_window]\n\n    # --- Step 4: Perform robust linear regression ---\n    # Use Theil-Sen estimator on the selected window (MSD vs t)\n    # theilslopes returns (slope, intercept, low_slope, high_slope)\n    slope, _, _, _ = theilslopes(y=msd_window, x=t_window)\n    \n    # --- Step 5: Calculate D and convert units ---\n    # D_sim = slope / (2 * dimensions), here dimensions=3\n    D_sim = slope / 6.0  # units: nm^2 / ps\n    \n    # Conversion factor from nm^2/ps to m^2/s\n    # 1 nm^2/ps = (10^-9 m)^2 / (10^-12 s) = 10^-18 m^2 / 10^-12 s = 10^-6 m^2/s\n    conversion_factor = 1e-6\n    D_si = D_sim * conversion_factor # units: m^2 / s\n    \n    return D_si\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}