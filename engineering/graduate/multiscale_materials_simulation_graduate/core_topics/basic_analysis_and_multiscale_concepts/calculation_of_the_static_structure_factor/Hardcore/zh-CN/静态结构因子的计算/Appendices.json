{
    "hands_on_practices": [
        {
            "introduction": "在模拟中，周期性边界条件（PBC）是一个基本构件，但它也带来了重要的影响。由于系统的周期性，我们只能在由模拟盒子尺寸决定的离散波矢量（即倒易空间格点）上考察物理量。本练习将引导你从第一性原理出发，推导这些允许的波矢量，并学习如何基于单个粒子构型（“快照”）计算这些格点上的“瞬时”静态结构因子 $S(\\mathbf{k})$ 。",
            "id": "3795202",
            "problem": "具有周期性边界条件（PBC）的立方模拟单元是多尺度材料模拟中的一个基本构造。考虑一个边长为 $L$ 的立方盒子，其中包含 $N$ 个点粒子，其位置为 $\\mathbf{r}_j$，其中 $j \\in \\{1,\\dots,N\\}$。微观数密度由 Dirac delta 分布的总和定义，静态结构因子通过两点密度相关的空间傅里叶变换定义。在 Born–von Kármán 周期性边界条件下，允许的倒易空间采样是离散的，并由盒子的周期性决定。您的任务是从第一性原理推导倒易空间采样规则，并设计一个算法来计算该离散集合上的静态结构因子，包括对位置的周期性环绕进行正确处理。\n\n推导的起点：\n- 微观数密度为 $\\rho(\\mathbf{r}) = \\sum_{j=1}^{N} \\delta(\\mathbf{r} - \\mathbf{r}_j)$。\n- 静态结构因子在倒易空间中定义为 $\\rho(\\mathbf{r})$ 的两点相关函数的空间傅里叶变换。\n- Born–von Kármán 周期性边界条件要求场在沿每个笛卡尔轴按盒子长度平移时是严格周期性的。\n\n您必须：\n1. 推导与边长为 $L$ 的立方盒子上的周期性边界条件兼容的离散倒易向量集。用整数索引三元组 $(n_x,n_y,n_z)$ 表示这些向量。\n2. 展示如何使用单个微观态（一个有限的位置列表）在此离散集上评估静态结构因子，并解释为什么该评估在将位置周期性地环绕到主晶胞内时是不变的。\n3. 实现一个程序，对于下面定义的每个测试用例，计算由三元组 $(n_x,n_y,n_z) \\in \\{-1,0,1\\} \\times \\{-1,0,1\\} \\times \\{-1,0,1\\}$ 索引的离散集上的静态结构因子值，按 $(n_x,n_y,n_z)$ 的字典序排列，其中 $-1  0  1$。在评估结构因子之前，必须将位置周期性地环绕到范围 $[0,L)$ 内。\n\n单位和数值约定：\n- 位置 $\\mathbf{r}_j$ 以纳米（nm）为单位。\n- 盒子长度 $L$ 以纳米（nm）为单位。\n- 波矢量以反纳米（$\\text{nm}^{-1}$）表示。\n- 静态结构因子是无量纲的。将每个计算出的静态结构因子值报告为浮点数。\n- 角度，如果出现在中间步骤（例如，相位），则默认为弧度。\n\n测试套件：\n- 测试用例 1（有序构型，理想情况）：\n  - 盒子长度：$L = 1.0$ nm。\n  - 粒子数：$N = 8$。\n  - 位置：集合 $\\{(x,y,z)\\}$，其中 $x,y,z \\in \\{0, L/2\\}$，即八个点\n    - $(0.0, 0.0, 0.0)$,\n    - $(0.0, 0.0, 0.5)$,\n    - $(0.0, 0.5, 0.0)$,\n    - $(0.0, 0.5, 0.5)$,\n    - $(0.5, 0.0, 0.0)$,\n    - $(0.5, 0.0, 0.5)$,\n    - $(0.5, 0.5, 0.0)$,\n    - $(0.5, 0.5, 0.5)$,\n    其中每个坐标均以纳米为单位，且 $L/2 = 0.5$ nm。\n  - 倒易索引集：$(n_x,n_y,n_z) \\in \\{-1,0,1\\}^3$，按字典序排列。\n\n- 测试用例 2（无序构型）：\n  - 盒子长度：$L = 1.8$ nm。\n  - 粒子数：$N = 10$。\n  - 位置（每个坐标均以纳米为单位）：\n    - $(0.12, 0.45, 1.37)$,\n    - $(1.52, 0.07, 0.93)$,\n    - $(0.81, 1.65, 0.22)$,\n    - $(1.21, 0.98, 1.40)$,\n    - $(0.33, 0.71, 0.58)$,\n    - $(1.77, 1.10, 0.04)$,\n    - $(0.56, 1.23, 1.62)$,\n    - $(1.44, 0.59, 0.31)$,\n    - $(0.09, 1.49, 1.16)$,\n    - $(1.05, 0.15, 0.75)$.\n  - 倒易索引集：$(n_x,n_y,n_z) \\in \\{-1,0,1\\}^3$，按字典序排列。\n\n- 测试用例 3（边界和环绕边缘情况）：\n  - 盒子长度：$L = 1.5$ nm。\n  - 粒子数：$N = 3$。\n  - 位置（每个坐标均以纳米为单位），有意包含 $[0,L)$ 范围之外的值以测试周期性环绕：\n    - $(-0.10, 1.49, 0.75)$,\n    - $(1.60, -0.75, 0.00)$,\n    - $(0.75, 0.75, 0.75)$.\n  - 倒易索引集：$(n_x,n_y,n_z) \\in \\{-1,0,1\\}^3$，按字典序排列。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。\n- 顶层列表必须包含三个嵌套列表，每个测试用例一个，按测试用例 1、测试用例 2、测试用例 3 的顺序排列。\n- 每个嵌套列表必须包含恰好 $27$ 个浮点值，对应于按 $(n_x,n_y,n_z)$ 字典序排列（其中 $-1  0  1$）的结构因子值。\n- 所需格式模式示例（非实际数字）：$[[s_{1,1}, s_{1,2}, \\dots, s_{1,27}], [s_{2,1}, \\dots, s_{2,27}], [s_{3,1}, \\dots, s_{3,27}]]$.",
            "solution": "该问题是有效的，因为它具有科学依据、问题明确且客观。它提出了计算物理学中的一个标准任务：在周期性边界条件下计算粒子系统的静态结构因子。所提供的定义、参数和测试用例是完整的、一致的且物理上是合理的。\n\n解决方案通过一个三步演绎过程得出：1) 从 Born-von Kármán 边界条件推导允许的倒易空间向量，2) 推导单个微观态的静态结构因子 $S(\\mathbf{k})$ 的计算公式，并证明其在周期性环绕下的不变性，以及 3) 规定其数值计算的算法。\n\n**1. 离散倒易向量的推导**\n\nBorn-von Kármán 周期性边界条件规定，边长为 $L$ 的立方模拟单元内的任何物理场 $\\psi(\\mathbf{r})$ 都必须以盒子的周期为周期。对于立方盒子，这转化为以下条件：\n$$\n\\psi(x+L, y, z) = \\psi(x, y, z) \\\\\n\\psi(x, y+L, z) = \\psi(x, y, z) \\\\\n\\psi(x, y, z+L) = \\psi(x, y, z)\n$$\n任何此类周期场都可以用傅里叶级数表示，它是形如 $\\psi(\\mathbf{r}) = e^{i\\mathbf{k} \\cdot \\mathbf{r}}$ 的平面波的叠加。为满足周期性，平面波本身必须与盒子具有相同的周期。沿 $x$ 轴应用该条件：\n$$\ne^{i(k_x(x+L) + k_y y + k_z z)} = e^{i(k_x x + k_y y + k_z z)}\n$$\n这简化为要求 $e^{i k_x L} = 1$。根据 Euler 恒等式 $e^{i\\theta} = \\cos(\\theta) + i\\sin(\\theta)$，此等式成立当且仅当参数 $k_x L$ 是 $2\\pi$ 的整数倍。因此，我们必须有：\n$$\nk_x L = 2\\pi n_x, \\quad \\text{其中 } n_x \\in \\mathbb{Z}\n$$\n这意味着 $k_x = \\frac{2\\pi}{L} n_x$。对 $y$ 轴和 $z$ 轴应用相同的逻辑，可得到 $k_y$ 和 $k_z$ 的类似条件。因此，与周期性边界条件兼容的允许倒易空间向量集 $\\mathbf{k}$ 是一个由下式定义的离散晶格：\n$$\n\\mathbf{k} = (k_x, k_y, k_z) = \\frac{2\\pi}{L}(n_x, n_y, n_z)\n$$\n其中 $n_x$、$n_y$ 和 $n_z$ 是整数。\n\n**2. 静态结构因子公式及其不变性**\n\n对于一个包含 $N$ 个点粒子（位置为 $\\mathbf{r}_j$）的系统，其微观数密度由 $\\rho(\\mathbf{r}) = \\sum_{j=1}^{N} \\delta(\\mathbf{r} - \\mathbf{r}_j)$ 给出。结构因子与此密度的傅里叶变换有关。对于一个允许的波矢 $\\mathbf{k}$，密度的傅里叶分量 $\\hat{\\rho}(\\mathbf{k})$ 是：\n$$\n\\hat{\\rho}(\\mathbf{k}) = \\int_V \\rho(\\mathbf{r}) e^{-i \\mathbf{k} \\cdot \\mathbf{r}} d^3\\mathbf{r} = \\int_V \\left( \\sum_{j=1}^{N} \\delta(\\mathbf{r} - \\mathbf{r}_j) \\right) e^{-i \\mathbf{k} \\cdot \\mathbf{r}} d^3\\mathbf{r}\n$$\n根据 Dirac delta 函数的筛选性质，该积分的计算结果为：\n$$\n\\hat{\\rho}(\\mathbf{k}) = \\sum_{j=1}^{N} e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j}\n$$\n对于单个构型（一个微观态），静态结构因子 $S(\\mathbf{k})$ 定义为 $\\hat{\\rho}(\\mathbf{k})$ 的归一化模长的平方：\n$$\nS(\\mathbf{k}) = \\frac{1}{N} |\\hat{\\rho}(\\mathbf{k})|^2 = \\frac{1}{N} \\left| \\sum_{j=1}^{N} e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j} \\right|^2\n$$\n对于特殊情况 $\\mathbf{k} = \\mathbf{0}$（对应于整数 $n_x=n_y=n_z=0$），指数项为 $e^0 = 1$，所以 $S(\\mathbf{0}) = \\frac{1}{N} |\\sum_{j=1}^{N} 1|^2 = \\frac{1}{N} |N|^2 = N$。\n\n现在，我们必须证明当粒子位置被环绕到主模拟单元（即立方体 $[0, L)^3$）内时，$S(\\mathbf{k})$ 是不变的。设 $\\mathbf{r}_j$ 是一个粒子位置，$\\mathbf{r}_j'$ 是其在主晶胞内的等效位置。它们通过模拟盒子的一个晶格平移向量 $\\mathbf{T} = L(m_x, m_y, m_z)$ 相关联，其中 $m_x, m_y, m_z$ 是整数，使得 $\\mathbf{r}_j = \\mathbf{r}_j' + \\mathbf{T}$。\n我们来分析使用未环绕位置的相位因子 $e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j}$：\n$$\ne^{-i \\mathbf{k} \\cdot \\mathbf{r}_j} = e^{-i \\mathbf{k} \\cdot (\\mathbf{r}_j' + \\mathbf{T})} = e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j'} e^{-i \\mathbf{k} \\cdot \\mathbf{T}}\n$$\n我们计算 $\\mathbf{k} \\cdot \\mathbf{T}$ 项：\n$$\n\\mathbf{k} \\cdot \\mathbf{T} = \\left(\\frac{2\\pi}{L}n_x, \\frac{2\\pi}{L}n_y, \\frac{2\\pi}{L}n_z\\right) \\cdot (L m_x, L m_y, L m_z) = 2\\pi (n_x m_x + n_y m_y + n_z m_z)\n$$\n由于 $n_x, n_y, n_z, m_x, m_y, m_z$ 都是整数，它们的乘积之和也是一个整数，我们可以称之为 $M$。该项变为 $2\\pi M$。因此，指数因子为 $e^{-i 2\\pi M} = \\cos(2\\pi M) - i\\sin(2\\pi M) = 1$。\n这证明了 $e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j} = e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j'}$。无论使用原始位置 $\\mathbf{r}_j$ 还是环绕后的位置 $\\mathbf{r}_j'$ 计算，$\\hat{\\rho}(\\mathbf{k})$ 的求和中的每一项都是相同的。因此，$S(\\mathbf{k})$ 的值在这种周期性环绕下是不变的，这是具有周期性边界条件的系统中任何有物理意义的量的必要属性。\n\n**3. 算法设计**\n\n计算给定测试用例的 $S(\\mathbf{k})$ 的算法如下：\n1.  定义每个测试用例的参数：盒子长度 $L$、粒子数 $N$ 以及粒子位置列表 $\\mathbf{r}_j$。\n2.  对于每个测试用例，首先将所有粒子坐标环绕到主晶胞 $[0, L)$ 内。对于每个坐标分量 $u$，这通过操作 $u' = u \\pmod L$ 来实现。\n3.  通过取笛卡尔积 $\\{-1, 0, 1\\}^3$ 生成所需的 $27$ 个整数索引三元组 $(n_x, n_y, n_z)$。三元组必须按字典序生成，这对应于按指定顺序对 $n_x, n_y, n_z$ 进行嵌套循环。\n4.  遍历每个索引三元组 $(n_x, n_y, n_z)$：\n    a. 构造波矢 $\\mathbf{k} = \\frac{2\\pi}{L}(n_x, n_y, n_z)$。\n    b. 为 $N$ 个粒子中的每一个计算相位因子 $\\mathbf{k} \\cdot \\mathbf{r}_j'$。如果粒子位置存储在一个 $N \\times 3$ 数组中，这可以通过向量-矩阵乘积高效完成。\n    c. 计算傅里叶密度分量 $\\hat{\\rho}(\\mathbf{k}) = \\sum_{j=1}^{N} e^{-i (\\mathbf{k} \\cdot \\mathbf{r}_j')}$。这是一个复数和。\n    d. 计算静态结构因子 $S(\\mathbf{k}) = \\frac{1}{N} |\\hat{\\rho}(\\mathbf{k})|^2$。\n    e. 存储得到的浮点数值。\n5.  将每个测试用例计算出的 $27$ 个 $S(\\mathbf{k})$ 值收集到一个列表中，保持索引三元组的字典序。\n6.  将所有测试用例的列表组合成一个最终的嵌套列表，并根据问题规范将输出格式化为单行字符串。\n\n此过程稳健地实现了所推导的物理原理，正确处理了周期性边界条件和数值计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the static structure factor S(k) for several test cases\n    of particle systems in a cubic box with periodic boundary conditions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 1.0, \n            \"N\": 8, \n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], [0.0, 0.0, 0.5], [0.0, 0.5, 0.0], [0.0, 0.5, 0.5],\n                [0.5, 0.0, 0.0], [0.5, 0.0, 0.5], [0.5, 0.5, 0.0], [0.5, 0.5, 0.5]\n            ])\n        },\n        {\n            \"L\": 1.8, \n            \"N\": 10, \n            \"positions\": np.array([\n                [0.12, 0.45, 1.37], [1.52, 0.07, 0.93], [0.81, 1.65, 0.22],\n                [1.21, 0.98, 1.40], [0.33, 0.71, 0.58], [1.77, 1.10, 0.04],\n                [0.56, 1.23, 1.62], [1.44, 0.59, 0.31], [0.09, 1.49, 1.16],\n                [1.05, 0.15, 0.75]\n            ])\n        },\n        {\n            \"L\": 1.5,\n            \"N\": 3,\n            \"positions\": np.array([\n                [-0.10, 1.49, 0.75],\n                [1.60, -0.75, 0.00],\n                [0.75, 0.75, 0.75]\n            ])\n        }\n    ]\n\n    all_case_results = []\n    \n    # Generate the reciprocal index triples in lexicographical order.\n    # The order of values is specified as -1  0  1.\n    n_values = [-1, 0, 1]\n    index_triples = []\n    for nx in n_values:\n        for ny in n_values:\n            for nz in n_values:\n                index_triples.append((nx, ny, nz))\n\n    for case in test_cases:\n        L = case[\"L\"]\n        N = case[\"N\"]\n        positions = case[\"positions\"]\n        \n        # 1. Periodically wrap positions into the primary simulation cell [0, L)^3.\n        #    Python's % operator correctly handles both positive and negative\n        #    coordinates for this purpose.\n        wrapped_positions = positions % L\n        \n        case_results = []\n        for n_triple in index_triples:\n            # 2. Calculate the wavevector k for the current index triple.\n            k_vec = (2.0 * np.pi / L) * np.array(n_triple)\n            \n            # 3. Calculate rho_k = sum(exp(-i * k . r_j)) for all particles j\n            #    The dot product k . r_j is computed for all particles at once.\n            k_dot_r = wrapped_positions @ k_vec\n            \n            # Sum the complex exponentials\n            rho_k = np.sum(np.exp(-1j * k_dot_r))\n            \n            # 4. Calculate the static structure factor S(k) = (1/N) * |rho_k|^2\n            #    np.abs() on a complex number computes its magnitude.\n            s_k = (1.0 / N) * np.abs(rho_k)**2\n            \n            case_results.append(s_k)\n            \n        all_case_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # Format: [[s_1_1,...,s_1_27],[s_2_1,...,s_2_27],[s_3_1,...,s_3_27]]\n    output_str = '[' + ','.join(f'[{\",\".join(map(str, res))}]' for res in all_case_results) + ']'\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "单个快照计算出的 $S(\\mathbf{k})$ 往往包含大量噪声，不能完全代表系综平均值。为了获得更精确的估计，一种常用方法是利用遍历性假设，即对单个长轨迹的时间平均等价于系综平均。本练习将通过对一系列随时间演化的粒子构型进行平均，教你如何实现一个基于时间平均的 $S(\\mathbf{k})$ 估计器，从而将理论计算与实际的分子动力学轨迹分析联系起来 。",
            "id": "3795189",
            "problem": "您的任务是设计并实现一个程序，该程序使用时间平均法，根据模拟轨迹估算粒子系统的静态结构因子。估算必须与从微观数密度及其空间傅里叶变换推导出的定义一致，并且除了这些定义之外，必须避免使用任何预先指定的公式。\n\n此任务的基础是：\n- 微观数密度场定义为 $\\,\\rho(\\mathbf{r},t) = \\sum_{j=1}^{N}\\delta(\\mathbf{r}-\\mathbf{r}_j(t))\\,$, 其中 $\\,\\delta(\\cdot)\\,$ 是狄拉克δ函数, $\\,\\mathbf{r}_j(t)\\,$ 是粒子在时间 $\\,t\\,$ 的位置, $\\,N\\,$ 是粒子数。\n- 在波矢 $\\,\\mathbf{k}\\,$ 处的数密度空间傅里叶变换为 $\\,\\rho_{\\mathbf{k}}(t) = \\int_{\\Omega} \\rho(\\mathbf{r},t)\\,e^{-\\,\\mathrm{i}\\,\\mathbf{k}\\cdot\\mathbf{r}}\\,\\mathrm{d}\\mathbf{r}\\,$, 其中 $\\,\\Omega\\,$ 是模拟区域的体积，$\\,\\mathrm{i}\\,$ 是虚数单位。\n- 对于非零的 $\\,\\mathbf{k}\\,$, 静态结构因子在物理上定义为在 $\\,\\mathbf{k}\\,$ 处密度涨落强度的度量。您的估算器必须通过结合上述定义与以下假设推导得出：在平稳轨迹上的时间平均近似于系综平均（遍历性），并使用一种归一化方法来消除与 $\\,N\\,$ 相关的平凡标度效应。\n- 模拟区域是周期性的。允许的非零波矢与周期性盒子的大小兼容，即在一维空间中为 $\\,k = 2\\pi m/L\\,$，其中 $\\,m\\,$ 为整数，$\\,L\\,$ 为区域长度；在二维空间中为 $\\,\\mathbf{k} = (2\\pi m_x/L_x,\\,2\\pi m_y/L_y)\\,$，其中 $\\,m_x\\,$ 和 $\\,m_y\\,$ 为整数，$\\,L_x\\,$ 和 $\\,L_y\\,$ 为区域长度。指数参数 $\\,\\mathbf{k}\\cdot\\mathbf{r}\\,$ 必须使用弧度制角度进行计算。\n\n您的程序必须：\n- 在指定的非零波矢处，使用对所提供帧的时间平均和一种不依赖于 $\\,N\\,$ 的归一化方法，实现一个一致的静态结构因子估算器。\n- 使用下面测试套件中给出的粒子轨迹，其中位置以纳米（$\\,\\mathrm{nm}\\,$）表示，波矢以反纳米（$\\,\\mathrm{nm}^{-1}\\,$）表示。\n- 从所有计算中排除 $\\,\\mathbf{k}=\\mathbf{0}\\,$.\n- 为静态结构因子的值生成无量纲的浮点数输出。不允许任何其他单位或文本输出。\n\n测试套件（所有位置单位为 $\\,\\mathrm{nm}\\,$，所有波矢分量单位为 $\\,\\mathrm{nm}^{-1}\\,$，指数中的角度单位为弧度）：\n\n- 情况A（一维，周期性盒子）：\n  - 区域长度 $\\,L = 1\\,\\mathrm{nm}\\,$.\n  - 帧数 $\\,T = 4\\,$；每帧粒子数 $\\,N = 12\\,$.\n  - 粒子位置 $\\,x_j(t)\\,$ 的帧，对于 $\\,t = 1,2,3,4\\,$：\n    - 帧 $\\,1\\,$: $[\\,0.031,\\,0.203,\\,0.567,\\,0.891,\\,0.412,\\,0.754,\\,0.125,\\,0.642,\\,0.379,\\,0.959,\\,0.285,\\,0.498\\,]$.\n    - 帧 $\\,2\\,$: $[\\,0.072,\\,0.229,\\,0.553,\\,0.847,\\,0.438,\\,0.713,\\,0.166,\\,0.619,\\,0.351,\\,0.988,\\,0.306,\\,0.471\\,]$.\n    - 帧 $\\,3\\,$: $[\\,0.015,\\,0.190,\\,0.581,\\,0.873,\\,0.449,\\,0.721,\\,0.142,\\,0.607,\\,0.333,\\,0.971,\\,0.292,\\,0.482\\,]$.\n    - 帧 $\\,4\\,$: $[\\,0.048,\\,0.217,\\,0.564,\\,0.860,\\,0.425,\\,0.730,\\,0.132,\\,0.630,\\,0.345,\\,0.976,\\,0.299,\\,0.495\\,]$.\n  - 目标波矢 $\\,k \\in \\{\\,2\\pi,\\,4\\pi\\,\\}\\,$.\n\n- 情况B（一维边界情况，周期性盒子）：\n  - 区域长度 $\\,L = 1\\,\\mathrm{nm}\\,$.\n  - 帧数 $\\,T = 3\\,$；每帧粒子数 $\\,N = 1\\,$.\n  - 粒子位置的帧：\n    - 帧 $\\,1\\,$: $[\\,0.420\\,]$.\n    - 帧 $\\,2\\,$: $[\\,0.420\\,]$.\n    - 帧 $\\,3\\,$: $[\\,0.420\\,]$.\n  - 目标波矢 $\\,k \\in \\{\\,2\\pi,\\,4\\pi\\,\\}\\,$.\n\n- 情况C（二维方格，周期性盒子）：\n  - 区域长度 $\\,L_x = 1\\,\\mathrm{nm}\\,$ 和 $\\,L_y = 1\\,\\mathrm{nm}\\,$.\n  - 帧数 $\\,T = 1\\,$；每帧粒子数 $\\,N = 9\\,$.\n  - 单帧粒子位置 $\\,\\{(x_j,y_j)\\}\\,$ 形成一个间距为 $\\,1/3\\,\\mathrm{nm}\\,$ 的 $\\,3\\times 3\\,$ 晶格：$\\,\\{\\,(\\,0,\\,0\\,),\\,(\\,0,\\,1/3\\,),\\,(\\,0,\\,2/3\\,),\\,(\\,1/3,\\,0\\,),\\,(\\,1/3,\\,1/3\\,),\\,(\\,1/3,\\,2/3\\,),\\,(\\,2/3,\\,0\\,),\\,(\\,2/3,\\,1/3\\,),\\,(\\,2/3,\\,2/3\\,)\\,\\}\\,$.\n  - 目标波矢 $\\,\\mathbf{k}\\,$:\n    - $\\,\\mathbf{k}_1 = (\\,2\\pi\\cdot 3,\\,0\\,)\\,$.\n    - $\\,\\mathbf{k}_2 = (\\,2\\pi\\cdot 2,\\,0\\,)\\,$.\n    - $\\,\\mathbf{k}_3 = (\\,2\\pi\\cdot 3,\\,2\\pi\\cdot 3\\,)\\,$.\n\n输出规格：\n- 按上述顺序列出，为每个指定的波矢计算静态结构因子：情况 $\\,\\mathrm{A}\\,$ 两个值，情况 $\\,\\mathrm{B}\\,$ 两个值，情况 $\\,\\mathrm{C}\\,$ 三个值。\n- 您的程序应生成单行输出，其中包含七个结果，形式为用方括号括起来的逗号分隔列表，例如 $\\,[\\,r_1,\\,r_2,\\,r_3,\\,r_4,\\,r_5,\\,r_6,\\,r_7\\,]\\,$，其中每个 $\\,r_i\\,$ 是一个无量纲的浮点数。不允许有多余的空格或文本。",
            "solution": "从粒子轨迹数据估算静态结构因子 $S(\\mathbf{k})$ 是分子模拟分析中的一项基础任务。该问题陈述在科学上是合理的、内部一致且适定的，为进行严格求解提供了所有必要的定义和数据。我们将首先从所提供的第一性原理推导 $S(\\mathbf{k})$ 的计算估算器，然后概述其计算算法。\n\n**1. 静态结构因子估算器的推导**\n\n问题提供了以下基本定义：\n- 在位置 $\\mathbf{r}$ 和时间 $t$ 的微观数密度场：\n$$ \\rho(\\mathbf{r},t) = \\sum_{j=1}^{N}\\delta(\\mathbf{r}-\\mathbf{r}_j(t)) $$\n其中 $N$ 是粒子数，$\\mathbf{r}_j(t)$ 是粒子 $j$ 在时间 $t$ 的位置，$\\delta(\\cdot)$ 是狄拉克δ函数。\n\n- 对于波矢 $\\mathbf{k}$ 的数密度空间傅里叶变换：\n$$ \\rho_{\\mathbf{k}}(t) = \\int_{\\Omega} \\rho(\\mathbf{r},t)\\,e^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{r}}\\,\\mathrm{d}\\mathbf{r} $$\n其中 $\\Omega$ 是模拟区域，$\\mathrm{i}$ 是虚数单位。\n\n为了推导 $\\rho_{\\mathbf{k}}(t)$ 的可计算表达式，我们将 $\\rho(\\mathbf{r},t)$ 的定义代入其傅里叶变换：\n$$ \\rho_{\\mathbfk}(t) = \\int_{\\Omega} \\left( \\sum_{j=1}^{N}\\delta(\\mathbf{r}-\\mathbf{r}_j(t)) \\right) e^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{r}}\\,\\mathrm{d}\\mathbf{r} $$\n根据积分的线性性质，我们可以交换积分和求和的顺序。然后，利用狄拉克δ函数的筛选性质，即 $\\int f(x)\\delta(x-a)dx = f(a)$，我们得到密度的微观傅里叶分量：\n$$ \\rho_{\\mathbf{k}}(t) = \\sum_{j=1}^{N} e^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{r}_j(t)} $$\n\n静态结构因子 $S(\\mathbf{k})$ 在物理上定义为密度涨落强度的度量。对于均匀系统和非零波矢（$\\mathbf{k} \\neq \\mathbf{0}$），密度涨落的系综平均 $\\langle \\rho_{\\mathbf{k}} \\rangle$ 为零。因此，强度由方差或模的平方的系综平均 $\\langle |\\rho_{\\mathbf{k}}|^2 \\rangle$ 来表征。$S(\\mathbf{k})$ 的标准定义包含一个归一化因子 $1/N$，以确保其为强度量（即，在热力学极限下，其对于典型流体的值不随系统大小 $N$ 变化），其定义为：\n$$ S(\\mathbf{k}) = \\frac{1}{N} \\langle |\\rho_{\\mathbf{k}}|^2 \\rangle = \\frac{1}{N} \\left\\langle \\left| \\sum_{j=1}^{N} e^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{r}_j} \\right|^2 \\right\\rangle $$\n该问题要求使用对有限数量的模拟帧（$T$ 帧）的时间平均来估计此系综平均 $\\langle \\cdot \\rangle$。这基于遍历性假设，这是统计力学中一个常见的假设，即在足够长的轨迹上的时间平均等价于系综平均。\n\n因此，我们用于静态结构因子的估算器（记为 $\\hat{S}(\\mathbf{k})$）是瞬时归一化值的时间平均：\n$$ \\hat{S}(\\mathbf{k}) = \\frac{1}{T} \\sum_{t=1}^{T} \\left( \\frac{1}{N} |\\rho_{\\mathbf{k}}(t)|^2 \\right) $$\n将其与我们对 $\\rho_{\\mathbf{k}}(t)$ 的表达式结合，得到最终的计算公式：\n$$ \\hat{S}(\\mathbf{k}) = \\frac{1}{NT} \\sum_{t=1}^{T} \\left| \\sum_{j=1}^{N} e^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{r}_j(t)} \\right|^2 $$\n此公式与问题的要求一致，它是从第一性原理推导出来的，并包含了指定的与 $N$ 无关的归一化。指数的参数 $\\mathbf{k}\\cdot\\mathbf{r}_j(t)$ 是一个无量纲标量，按要求使用弧度制角度进行计算。\n\n**2. 算法实现**\n\n为每个测试用例计算 $\\hat{S}(\\mathbf{k})$ 的算法如下：\n1. 对于给定的测试用例，确定粒子数 $N$、帧数 $T$、粒子位置 $\\{\\mathbf{r}_j(t)\\}$（其中 $j=1,\\ldots,N$，$t=1,\\ldots,T$）以及目标波矢集合 $\\{\\mathbf{k}\\}$。\n2. 对每个目标波矢 $\\mathbf{k}$：\n    a. 初始化一个运行总和 `total_squared_magnitude` 为 $0$。\n    b. 从 $t=1$ 到 $T$ 遍历每一帧：\n        i. 获取当前帧的粒子位置 $\\{\\mathbf{r}_j(t)\\}$。\n        ii. 计算复数和 $\\rho_{\\mathbf{k}}(t) = \\sum_{j=1}^{N} e^{-\\mathrm{i}\\mathbf{k}\\cdot\\mathbf{r}_j(t)}$。在数值上，这是通过对所有粒子 $j$ 求和复数 $\\cos(\\mathbf{k}\\cdot\\mathbf{r}_j(t)) - \\mathrm{i}\\sin(\\mathbf{k}\\cdot\\mathbf{r}_j(t))$ 来实现的。\n        iii. 计算此复数和的模的平方 $|\\rho_{\\mathbf{k}}(t)|^2$。如果 $\\rho_{\\mathbf{k}}(t) = A + \\mathrm{i}B$，那么其模的平方为 $A^2 + B^2$。\n        iv. 将此值加到 `total_squared_magnitude`。\n    c. 遍历所有帧后，通过归一化总和来计算最终估计值：$\\hat{S}(\\mathbf{k}) = \\text{total\\_squared\\_magnitude} / (N \\cdot T)$。\n3. 按规定顺序收集所有指定波矢的 $\\hat{S}(\\mathbf{k})$ 计算值。\n\n现在将此有原则的算法应用于所提供的测试用例。\n\n- **情况 A**：一个具有 $N=12$ 个粒子和 $T=4$ 帧的一维系统。位置是 $x_j(t)$，波矢是 $k \\in \\{2\\pi, 4\\pi\\}$。点积 $\\mathbf{k}\\cdot\\mathbf{r}$ 简化为标量积 $k x_j(t)$。将对两个 $k$ 值分别进行计算。\n\n- **情况 B**：一个具有 $N=1$ 个粒子和 $T=3$ 帧的一维系统。粒子静态位于 $x_1 = 0.420$。对于任何 $k$ 和任何帧 $t$，$\\rho_k(t) = e^{-\\mathrm{i}kx_1}$。模的平方为 $|e^{-\\mathrm{i}kx_1}|^2=1$。在 $T=3$ 帧上的总和是 $1+1+1=3$。估算值为 $\\hat{S}(k) = \\frac{1}{NT} \\sum_t |\\rho_k(t)|^2 = \\frac{1}{1 \\cdot 3} \\cdot 3 = 1.0$。对于单粒子系统，这个结果是预期的，并且对于两个目标波矢都将是 $1.0$。\n\n- **情况 C**：一个具有 $N=9$ 个粒子位于完美晶格上且 $T=1$ 帧的二维系统。估算器简化为 $\\hat{S}(\\mathbf{k}) = \\frac{1}{N}|\\rho_{\\mathbf{k}}|^2$。\n    - 对于 $\\mathbf{k}_1 = (6\\pi, 0)$，这是实空间晶格的一个倒格矢。总和 $\\sum_j e^{-\\mathrm{i}\\mathbf{k}_1\\cdot\\mathbf{r}_j}$ 的计算结果为 $N=9$。因此，$|\\rho_{\\mathbf{k}_1}|^2 = 9^2 = 81$，且 $\\hat{S}(\\mathbf{k}_1) = \\frac{81}{9} = 9.0$。\n    - 对于 $\\mathbf{k}_2 = (4\\pi, 0)$，这不是一个倒格矢，总和 $\\sum_j e^{-\\mathrm{i}\\mathbf{k}_2\\cdot\\mathbf{r}_j}$ 的计算结果为 $0$。因此，$\\hat{S}(\\mathbf{k}_2) = 0.0$。\n    - 对于 $\\mathbf{k}_3 = (6\\pi, 6\\pi)$，这是另一个倒格矢，总和的计算结果同样为 $N=9$。因此，$\\hat{S}(\\mathbf{k}_3) = \\frac{81}{9} = 9.0$。\n这些解析性检验确认了所推导公式及其物理诠释的正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the static structure factor problem by implementing a time-averaging\n    estimator derived from first principles.\n    \"\"\"\n\n    def calculate_s_k(positions, wavevectors, N, T):\n        \"\"\"\n        Calculates the static structure factor S(k) for a set of wavevectors.\n\n        Args:\n            positions (np.ndarray): Particle positions. Shape (T, N) for 1D\n                                     or (T, N, D) for D-dimensional systems.\n            wavevectors (np.ndarray): Target wavevectors. Shape (num_k,) for 1D\n                                      or (num_k, D) for D-dimensional systems.\n            N (int): Number of particles.\n            T (int): Number of time frames.\n\n        Returns:\n            list: A list of S(k) values for each target wavevector.\n        \"\"\"\n        results_for_case = []\n        is_1d = (positions.ndim == 2)\n        \n        for k_vec in wavevectors:\n            total_squared_magnitude = 0.0\n            for t in range(T):\n                # positions_t is of shape (N,) or (N, D)\n                positions_t = positions[t]\n                \n                # Calculate the dot product k_vec . r_j for all particles j\n                if is_1d:\n                    # k_vec is a scalar, positions_t has shape (N,)\n                    # dot_products has shape (N,)\n                    dot_products = k_vec * positions_t\n                else:\n                    # k_vec has shape (D,), positions_t has shape (N, D)\n                    # dot_products has shape (N,)\n                    dot_products = np.dot(positions_t, k_vec)\n\n                # Calculate rho_k(t) = sum(exp(-i * k.r_j))\n                rho_k_t = np.sum(np.exp(-1j * dot_products))\n                \n                # Add the squared magnitude to the total\n                total_squared_magnitude += np.abs(rho_k_t)**2\n            \n            # Normalize to get the final S(k) estimate\n            s_k = total_squared_magnitude / (N * T)\n            results_for_case.append(s_k)\n            \n        return results_for_case\n\n    # Test suite definition\n    # Case A\n    case_A_N = 12\n    case_A_T = 4\n    case_A_positions = np.array([\n        [0.031, 0.203, 0.567, 0.891, 0.412, 0.754, 0.125, 0.642, 0.379, 0.959, 0.285, 0.498],\n        [0.072, 0.229, 0.553, 0.847, 0.438, 0.713, 0.166, 0.619, 0.351, 0.988, 0.306, 0.471],\n        [0.015, 0.190, 0.581, 0.873, 0.449, 0.721, 0.142, 0.607, 0.333, 0.971, 0.292, 0.482],\n        [0.048, 0.217, 0.564, 0.860, 0.425, 0.730, 0.132, 0.630, 0.345, 0.976, 0.299, 0.495]\n    ])\n    case_A_wavevectors = np.array([2 * np.pi, 4 * np.pi])\n\n    # Case B\n    case_B_N = 1\n    case_B_T = 3\n    case_B_positions = np.array([\n        [0.420],\n        [0.420],\n        [0.420]\n    ])\n    case_B_wavevectors = np.array([2 * np.pi, 4 * np.pi])\n\n    # Case C\n    case_C_N = 9\n    case_C_T = 1\n    case_C_positions_list = [\n        (0, 0), (0, 1/3), (0, 2/3),\n        (1/3, 0), (1/3, 1/3), (1/3, 2/3),\n        (2/3, 0), (2/3, 1/3), (2/3, 2/3)\n    ]\n    # Reshape to (T, N, D) = (1, 9, 2)\n    case_C_positions = np.array(case_C_positions_list).reshape((1, case_C_N, 2))\n    case_C_wavevectors = np.array([\n        [2 * np.pi * 3, 0],\n        [2 * np.pi * 2, 0],\n        [2 * np.pi * 3, 2 * np.pi * 3]\n    ])\n\n    # Calculate results for all cases\n    results = []\n    \n    # Case A\n    results.extend(calculate_s_k(case_A_positions, case_A_wavevectors, case_A_N, case_A_T))\n\n    # Case B\n    results.extend(calculate_s_k(case_B_positions, case_B_wavevectors, case_B_N, case_B_T))\n\n    # Case C\n    results.extend(calculate_s_k(case_C_positions, case_C_wavevectors, case_C_N, case_C_T))\n\n    # Format and print the final output\n    # Round to a reasonable number of decimal places for consistent output\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在计算物理学中，任何没有误差棒的数值结果其价值都是有限的。本节的最终练习将聚焦于一项至关重要的任务：量化统计不确定性。通过分析一组统计独立的构型，你不仅将计算出结构因子的平均值，还将计算其方差和置信区间，从而为你的计算结果提供一个稳健的精度衡量标准 。",
            "id": "3795201",
            "problem": "考虑一个 $d$ 维空间中的周期性模拟盒子，其边长为 $\\mathbf{L} = (L_1,\\dots,L_d)$，盒子中包含 $N$ 个粒子，其位置为 $\\{\\mathbf{r}_j\\}_{j=1}^N$，其中 $\\mathbf{r}_j \\in [0,L_1) \\times \\cdots \\times [0,L_d)$。微观数密度定义为 $\\rho(\\mathbf{r}) = \\sum_{j=1}^N \\delta(\\mathbf{r} - \\mathbf{r}_j)$，其在波矢 $\\mathbf{k}$ 处的傅里叶分量定义为 $\\rho_{\\mathbf{k}} = \\int_{V} \\rho(\\mathbf{r}) e^{-i \\mathbf{k} \\cdot \\mathbf{r}} \\, d\\mathbf{r}$，其中 $V = L_1 \\cdots L_d$ 是体积，角度以弧度为单位。静态结构因子 $S(\\mathbf{k})$ 量化了平衡态下波矢 $\\mathbf{k}$ 处的密度涨落，并由这些定义构建而成。\n\n给定 $M$ 个统计独立的粒子位置快照，每个快照都包含在同一个周期性盒子中的 $N$ 个粒子。从上述基本定义出发，为单个快照构建一个 $S(\\mathbf{k})$ 的一致估计量，然后将其扩展到 $M$ 个快照。实现一个程序，为每个测试用例计算：\n- 在 $M$ 个快照中瞬时 $S(\\mathbf{k})$ 值的样本均值。\n- 在 $M$ 个快照中瞬时 $S(\\mathbf{k})$ 值的无偏样本方差。\n- 在快照独立假设下，使用适用于 $M-1$ 自由度的学生 t 分位数 (Student's t quantile)，计算 $M$ 个快照中 $S(\\mathbf{k})$ 均值的双侧置信区间，置信水平为 $0.95$。\n\n所有量（$S(\\mathbf{k})$ 及其样本均值、方差和置信区间）都必须报告为无量纲数。粒子位置必须以纳米 (nm) 为单位，波矢以反纳米 (nm$^{-1}$) 为单位，角度以弧度为单位。如果 $M$ 个快照的无偏样本方差为零或 $M=1$，则将置信区间报告为退化区间 $[\\mu,\\mu]$，其中 $\\mu$ 是样本均值。\n\n您的程序必须实现以下测试套件。在以下所有案例中，除非另有说明，快照都是独立的，并且必须使用指定的整数种子确定性地生成伪随机数。\n\n- 测试用例 1（一维均匀流体，“理想情况”(happy path)）：\n  - $d = 1$, $N = 128$, $M = 60$, $L_1 = 12.8$ nm, 种子 $= 1001$。\n  - 每个快照中的粒子位置独立且在 $[0,L_1)$ 上均匀分布。\n  - 波矢 $\\mathbf{k} = (2\\pi \\cdot 3 / L_1)$ nm$^{-1}$。\n\n- 测试用例 2（一维均匀流体，边界在 $\\mathbf{k}=\\mathbf{0}$）：\n  - $d = 1$, $N = 128$, $M = 60$, $L_1 = 12.8$ nm, 种子 $= 1002$。\n  - 每个快照中的粒子位置独立且在 $[0,L_1)$ 上均匀分布。\n  - 波矢 $\\mathbf{k} = (0)$ nm$^{-1}$。\n\n- 测试用例 3（一维完美晶格，布拉格峰 (Bragg peak)）：\n  - $d = 1$, $N = 64$, $M = 20$, $L_1 = 6.4$ nm（因此晶格间距 $a = L_1/N = 0.1$ nm），种子被忽略，因为快照是同一晶格的相同副本。\n  - 每个快照的粒子位置精确位于 $\\{j a\\}_{j=0}^{N-1}$。\n  - 波矢 $\\mathbf{k} = (2\\pi / a)$ nm$^{-1}$。\n\n- 测试用例 4（一维完美晶格，消光条件 (extinction condition)）：\n  - $d = 1$, $N = 64$, $M = 20$, $L_1 = 6.4$ nm（晶格间距 $a = 0.1$ nm），与测试用例 3 中晶格位置相同，种子被忽略。\n  - 波矢 $\\mathbf{k} = (\\pi / a)$ nm$^{-1}$。\n\n- 测试用例 5（二维均匀流体，各向异性盒子）：\n  - $d = 2$, $N = 256$, $M = 50$, $(L_1,L_2) = (10.0, 5.0)$ nm, 种子 $= 1405$。\n  - 每个快照中的粒子位置独立且在 $[0,L_1) \\times [0,L_2)$ 上均匀分布。\n  - 波矢 $\\mathbf{k} = (2\\pi / L_1, 0)$ nm$^{-1}$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，结果的顺序与测试用例（1 到 5）的顺序相同。每个元素必须是对应测试用例的四元列表 $[\\text{均值}, \\text{方差}, \\text{下界}, \\text{上界}]$。例如，输出必须看起来像 $[[\\cdots],[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$，位于单行上，所有数字都是无量纲的，角度以弧度为单位。",
            "solution": "该问题要求根据模拟的粒子构型计算静态结构因子 $S(\\mathbf{k})$，以及其样本均值、方差和置信区间。该过程从提供的基本定义进行形式化推导开始。\n\n### 1. $S(\\mathbf{k})$ 估计量的推导\n\n体积 $V$ 中 $N$ 个粒子在位置 $\\{\\mathbf{r}_j\\}$ 处的微观数密度由下式给出：\n$$ \\rho(\\mathbf{r}) = \\sum_{j=1}^N \\delta(\\mathbf{r} - \\mathbf{r}_j) $$\n该密度在特定波矢 $\\mathbf{k}$ 处的傅里叶分量定义为积分变换：\n$$ \\rho_{\\mathbf{k}} = \\int_{V} \\rho(\\mathbf{r}) e^{-i \\mathbf{k} \\cdot \\mathbf{r}} \\, d\\mathbf{r} $$\n将 $\\rho(\\mathbf{r})$ 的定义代入积分中：\n$$ \\rho_{\\mathbf{k}} = \\int_{V} \\left( \\sum_{j=1}^N \\delta(\\mathbf{r} - \\mathbf{r}_j) \\right) e^{-i \\mathbf{k} \\cdot \\mathbf{r}} \\, d\\mathbf{r} $$\n根据积分的线性性质，我们可以交换求和与积分的顺序：\n$$ \\rho_{\\mathbf{k}} = \\sum_{j=1}^N \\int_{V} \\delta(\\mathbf{r} - \\mathbf{r}_j) e^{-i \\mathbf{k} \\cdot \\mathbf{r}} \\, d\\mathbf{r} $$\n利用狄拉克δ函数 (Dirac delta function) 的筛选性质，即 $\\int f(x) \\delta(x-a) dx = f(a)$，积分计算结果为在粒子位置 $\\mathbf{r}_j$ 处的指数项。假设所有粒子都在积分体积 $V$ 内，这得到：\n$$ \\rho_{\\mathbf{k}} = \\sum_{j=1}^N e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j} $$\n此表达式表示单个瞬时粒子构型的密度傅里叶分量。\n\n在统计力学中，静态结构因子 $S(\\mathbf{k})$ 的基本定义是密度涨落的归一化关联：\n$$ S(\\mathbf{k}) = \\frac{1}{N} \\langle \\rho_{\\mathbf{k}} \\rho_{-\\mathbf{k}} \\rangle $$\n其中 $\\langle \\cdot \\rangle$ 表示在热力学平衡中对所有可能粒子构型的系综平均。项 $\\rho_{-\\mathbf{k}}$ 是在波矢 $-\\mathbf{k}$ 处的傅里叶分量：\n$$ \\rho_{-\\mathbf{k}} = \\sum_{l=1}^N e^{-i (-\\mathbf{k}) \\cdot \\mathbf{r}_l} = \\sum_{l=1}^N e^{i \\mathbf{k} \\cdot \\mathbf{r}_l} = \\left( \\sum_{l=1}^N e^{-i \\mathbf{k} \\cdot \\mathbf{r}_l} \\right)^* = \\rho_{\\mathbf{k}}^* $$\n其中 $^*$ 表示复共轭。因此，乘积 $\\rho_{\\mathbf{k}} \\rho_{-\\mathbf{k}}$ 等价于模的平方 $|\\rho_{\\mathbf{k}}|^2$。$S(\\mathbf{k})$ 的定义变为：\n$$ S(\\mathbf{k}) = \\frac{1}{N} \\langle |\\rho_{\\mathbf{k}}|^2 \\rangle = \\frac{1}{N} \\left\\langle \\left| \\sum_{j=1}^N e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j} \\right|^2 \\right\\rangle $$\n对于单个粒子位置快照，我们无法计算系综平均。从单个快照得到 $S(\\mathbf{k})$ 的最直接估计量是“瞬时”值，通过去掉系综平均得到：\n$$ S_{\\text{inst}}(\\mathbf{k}) = \\frac{1}{N} \\left| \\sum_{j=1}^N e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j} \\right|^2 $$\n这就是问题陈述所要求的一致估计量。\n\n### 2. 多快照的统计分析\n\n给定一组 $M$ 个统计独立的快照，我们可以为每个快照 $m \\in \\{1, \\dots, M\\}$ 计算一个瞬时结构因子 $S_m(\\mathbf{k})$。集合 $\\{S_m(\\mathbf{k})\\}_{m=1}^M$ 构成了 $S_{\\text{inst}}(\\mathbf{k})$ 分布的一个样本。我们可以从这个样本中估计该分布的矩。\n\n样本均值 $\\mu_S$ 用于估计真实的系综平均 $\\langle S(\\mathbf{k}) \\rangle$，其计算公式为：\n$$ \\mu_S = \\frac{1}{M} \\sum_{m=1}^M S_m(\\mathbf{k}) $$\n无偏样本方差 $\\sigma_S^2$ 用于估计 $S_m(\\mathbf{k})$ 值的方差，其计算公式为：\n$$ \\sigma_S^2 = \\frac{1}{M-1} \\sum_{m=1}^M (S_m(\\mathbf{k}) - \\mu_S)^2 $$\n注意分母中使用 $M-1$，这提供了无偏估计。对于 $M=1$ 的情况，无偏方差通常定义为 $0$。\n\n$S(\\mathbf{k})$ 真实均值的双侧置信区间 (CI) 是基于中心极限定理构建的。对于大小为 $M$ 的样本，置信水平为 $1-\\alpha$（这里是 $0.95$，所以 $\\alpha=0.05$）的置信区间是：\n$$ \\text{CI} = \\left[ \\mu_S - t_{1-\\alpha/2, \\nu} \\frac{\\sigma_S}{\\sqrt{M}}, \\, \\mu_S + t_{1-\\alpha/2, \\nu} \\frac{\\sigma_S}{\\sqrt{M}} \\right] $$\n其中 $\\nu = M-1$ 是自由度，$\\sigma_S = \\sqrt{\\sigma_S^2}$ 是样本标准差，而 $t_{1-\\alpha/2, \\nu}$ 是来自学生 t 分布 (Student's t-distribution) 的上侧尾部临界值。对于 $\\alpha=0.05$，这是 $0.975$ 分位数。如果 $M \\le 1$ 或者样本方差 $\\sigma_S^2$ 为零，则均值的标准误为零，置信区间退化为点 $[\\mu_S, \\mu_S]$。\n\n### 3. 实现策略\n\n程序将遍历每个测试用例，执行以下步骤：\n1.  初始化用例参数：维度 ($d$)、粒子数 ($N$)、快照数 ($M$)、盒子长度 ($\\mathbf{L}$)、波矢 ($\\mathbf{k}$) 和随机数生成器的种子。\n2.  生成粒子位置。对于均匀流体情况，使用带种子的 `numpy.random.Generator` 从均匀分布中抽取位置。对于完美晶格情况，所有快照的位置是确定且相同的。\n3.  对于 $M$ 个快照中的每一个：\n    a. 计算所有 $N$ 个粒子的点积数组 $\\mathbf{k} \\cdot \\mathbf{r}_j$。\n    b. 计算复数和 $\\rho_{\\mathbf{k}} = \\sum_j \\exp(-i \\mathbf{k} \\cdot \\mathbf{r}_j)$。\n    c. 计算瞬时值 $S_m(\\mathbf{k}) = \\frac{1}{N} |\\rho_{\\mathbf{k}}|^2$。\n4.  存储所有 $M$ 个 $S_m(\\mathbf{k})$ 的值。\n5.  从存储的值中计算样本均值 $\\mu_S$ 和无偏样本方差 $\\sigma_S^2$。对于 $M \\le 1$ 的情况要特别处理，此时方差设为 $0$。\n6.  使用 `scipy.stats.t.ppf` 函数找到合适的 t 分位数，计算 $95\\%$ 的置信区间。按规定处理退化区间的情况。\n7.  为每个测试用例格式化并收集四个结果数字（$\\mu_S, \\sigma_S^2$, CI 下界, CI 上界）。\n8.  最后，以指定的单行列表的列表格式打印汇总结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import t\n\ndef solve():\n    \"\"\"\n    Computes the static structure factor S(k) and its statistics for several test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"d\": 1, \"N\": 128, \"M\": 60, \"L\": np.array([12.8]),\n            \"k\": np.array([2 * np.pi * 3 / 12.8]), \"seed\": 1001\n        },\n        {\n            \"d\": 1, \"N\": 128, \"M\": 60, \"L\": np.array([12.8]),\n            \"k\": np.array([0.0]), \"seed\": 1002\n        },\n        {\n            \"d\": 1, \"N\": 64, \"M\": 20, \"L\": np.array([6.4]),\n            \"k\": np.array([2 * np.pi / (6.4 / 64)]), \"seed\": None  # Lattice\n        },\n        {\n            \"d\": 1, \"N\": 64, \"M\": 20, \"L\": np.array([6.4]),\n            \"k\": np.array([np.pi / (6.4 / 64)]), \"seed\": None  # Lattice\n        },\n        {\n            \"d\": 2, \"N\": 256, \"M\": 50, \"L\": np.array([10.0, 5.0]),\n            \"k\": np.array([2 * np.pi / 10.0, 0.0]), \"seed\": 1405\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        d = case[\"d\"]\n        N = case[\"N\"]\n        M = case[\"M\"]\n        L = case[\"L\"]\n        k = case[\"k\"]\n        seed = case[\"seed\"]\n\n        s_k_values = np.zeros(M)\n        \n        # Pre-calculate positions for deterministic cases\n        positions_snapshot = None\n        if seed is None:\n            if d == 1:\n                a = L[0] / N\n                positions_snapshot = np.arange(N).reshape(N, 1) * a\n            # Extend for other deterministic cases if needed\n        else:\n            rng = np.random.default_rng(seed)\n\n        for m in range(M):\n            # Generate or retrieve particle positions for the current snapshot\n            if positions_snapshot is not None:\n                positions = positions_snapshot\n            else:\n                # Generate random positions: shape (N, d)\n                # Each coordinate r_i is in [0, L_i)\n                positions = rng.random(size=(N, d)) * L\n\n            # Calculate k . r for all particles. Shape: (N,)\n            k_dot_r = positions @ k\n            \n            # Calculate rho_k = sum_j exp(-i * k.r_j)\n            rho_k = np.sum(np.exp(-1j * k_dot_r))\n            \n            # Calculate instantaneous S(k) = (1/N) * |rho_k|^2\n            s_k_inst = (1.0 / N) * np.abs(rho_k)**2\n            s_k_values[m] = s_k_inst\n\n        # Calculate sample mean\n        mean_s_k = np.mean(s_k_values)\n\n        # Calculate unbiased sample variance\n        if M > 1:\n            var_s_k = np.var(s_k_values, ddof=1)\n        else:\n            var_s_k = 0.0\n\n        # Calculate 95% confidence interval for the mean\n        if M = 1 or var_s_k == 0.0:\n            lower_ci = mean_s_k\n            upper_ci = mean_s_k\n        else:\n            # Degrees of freedom for t-distribution\n            df = M - 1\n            # Standard error of the mean\n            sem = np.sqrt(var_s_k) / np.sqrt(M)\n            # 97.5th percentile for a two-sided 95% CI\n            t_quantile = t.ppf(0.975, df)\n            # Margin of error\n            margin_of_error = t_quantile * sem\n            \n            lower_ci = mean_s_k - margin_of_error\n            upper_ci = mean_s_k + margin_of_error\n            \n        results.append([mean_s_k, var_s_k, lower_ci, upper_ci])\n\n    # Format output as a single-line string representation of a list of lists\n    # e.g., [[val1, val2, ...], [val1, val2, ...]]\n    results_str = ','.join(map(str, results))\n    print(f\"[{results_str}]\")\n\nsolve()\n\n```"
        }
    ]
}