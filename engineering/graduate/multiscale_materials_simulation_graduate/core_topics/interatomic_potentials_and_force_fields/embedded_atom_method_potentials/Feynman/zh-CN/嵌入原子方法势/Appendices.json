{
    "hands_on_practices": [
        {
            "introduction": "理论学习的最终目的是应用于实践。本节将通过一系列动手实践，带你从嵌入原子方法（EAM）势的基本理论走向实际应用。第一个实践将从一个最基本的物理量——内聚能——入手。通过这个练习，你将学会如何将抽象的EAM能量表达式应用于完美的晶体结构，并通过对晶格求和来计算其成对相互作用部分的贡献。这个过程不仅能加深你对EAM能量构成和晶体几何学的理解，也是验证和拟合势函数参数时的基础步骤。",
            "id": "3754212",
            "problem": "考虑一个通过嵌入原子方法（EAM）建模的单原子晶体，该方法将总能量定义为各原子的嵌入能与对相互作用之和。具体来说，总能量由以下表达式定义：\n$$\nE_{\\text{tot}} \\equiv \\sum_{i} \\left[ F\\!\\left(\\rho_{i}\\right) + \\frac{1}{2}\\sum_{j\\neq i} \\phi\\!\\left(r_{ij}\\right) \\right],\n$$\n其中 $F(\\rho)$ 是作为原子 $i$ 处宿主电子密度 $\\rho_{i} \\equiv \\sum_{j\\neq i} f(r_{ij})$ 的函数的嵌入能，$\\phi(r)$ 是一个径向对称的对势，$r_{ij}$ 是原子 $i$ 和 $j$ 之间的距离。假设一个晶格参数为 $a$ 的单原子面心立方（fcc）晶体，其中所有原子在晶体学上是等价的，并且 $f(r)$ 是一个仅取决于 $r$ 的单调递减正函数。\n\n给定一种特定形式的对势：\n$$\n\\phi(r) = \\varepsilon \\,\\exp(-\\alpha r),\n$$\n其中 $\\varepsilon>0$ 且 $\\alpha>0$，并要求在计算任何晶格求和时仅保留前两个晶格壳层。对于 fcc 晶格，前两个壳层的配位数和距离为：\n$$\nz_{1} = 12, \\quad r_{1} = \\frac{a}{\\sqrt{2}} \\quad \\text{和} \\quad z_{2} = 6, \\quad r_{2} = a.\n$$\n\n从上述 EAM基本定义出发，并利用完美单原子晶体中每个原子的内聚能可以写为单个代表性原子的能量（由于平移对称性）这一事实，通过显式执行晶格壳层求和，推导出对势 $\\phi(r)$ 对每个原子内聚能的贡献。在您的推导中，请明确区分对相互作用项和嵌入项，并仅使用指定的前两个壳层。\n\n将您的最终答案表示为每个原子无量纲对势贡献的单个闭式解析表达式，即 $E_{\\text{pair}}^{\\text{atom}}(a)/\\varepsilon$，用 $a$ 和 $\\alpha$ 表示。无需进行数值代入。最终表达式中不要包含单位。",
            "solution": "首先验证问题，以确保其科学基础可靠、问题设定合理且客观。\n\n### 第1步：提取已知条件\n-   **总能量表达式**: $E_{\\text{tot}} \\equiv \\sum_{i} \\left[ F\\!\\left(\\rho_{i}\\right) + \\frac{1}{2}\\sum_{j\\neq i} \\phi\\!\\left(r_{ij}\\right) \\right]$\n-   **宿主电子密度**: $\\rho_{i} \\equiv \\sum_{j\\neq i} f(r_{ij})$\n-   **晶体结构**: 单原子面心立方（fcc），晶格参数为 $a$。\n-   **电子密度函数**: $f(r)$ 是一个单调递减的正函数。\n-   **对势**: $\\phi(r) = \\varepsilon \\,\\exp(-\\alpha r)$，参数 $\\varepsilon>0$ 且 $\\alpha>0$。\n-   **近似**: 晶格求和在计算到前两个邻居壳层后截断。\n-   **fcc 壳层数据**:\n    -   第一壳层：配位数 $z_{1} = 12$，距离 $r_{1} = \\frac{a}{\\sqrt{2}}$。\n    -   第二壳层：配位数 $z_{2} = 6$，距离 $r_{2} = a$。\n-   **目标**: 推导每个原子内聚能的无量纲对势贡献 $E_{\\text{pair}}^{\\text{atom}}(a)/\\varepsilon$。\n\n### 第2步：使用提取的已知条件进行验证\n-   **科学基础可靠**: 该问题基于嵌入原子方法（EAM），这是一种在计算材料科学中广泛使用的标准且成熟的多体势模型。表达式、参数和晶格性质均与已建立的物理学和晶体学一致。\n-   **问题设定合理**: 问题定义清晰。它提供了在指定近似（双壳层求和）下计算特定量（$E_{\\text{pair}}^{\\text{atom}}$）所需的所有函数和参数。对于所要求的计算，并不需要 $F(\\rho)$ 和 $f(r)$ 的具体形式，因此它们不是缺失信息。问题存在唯一且有意义的解。\n-   **客观性**: 问题以精确、定量和无偏见的科学语言陈述。\n\n### 第3步：结论与行动\n该问题**有效**，因其科学上可靠、自洽且设定合理。将进行推导求解。\n\n### 推导\n包含 $N$ 个原子的系统的总能量由 EAM 表达式给出：\n$$\nE_{\\text{tot}} = \\sum_{i=1}^{N} \\left[ F(\\rho_{i}) + \\frac{1}{2}\\sum_{j\\neq i} \\phi(r_{ij}) \\right]\n$$\n每个原子的内聚能 $E^{\\text{atom}}$ 是总能量除以原子数，即 $E^{\\text{atom}} = E_{\\text{tot}}/N$。对于完美的单原子晶体，由于平移对称性，所有原子在晶体学上是等价的。这意味着与每个原子相关的能量是相同的。因此，每个原子的能量等于任何单个代表性原子的能量，我们可以将其标记为原子 $i$。\n$$\nE^{\\text{atom}} = E_{i} = F(\\rho_{i}) + \\frac{1}{2}\\sum_{j\\neq i} \\phi(r_{ij})\n$$\n此表达式中每个原子能量的因子 $\\frac{1}{2}$ 正确地说明了每个对相互作用（键）由两个原子共享的事实。\n\n问题要求计算对势 $\\phi(r)$ 对此每个原子内聚能的贡献。我们将此贡献指定为 $E_{\\text{pair}}^{\\text{atom}}$。从 $E^{\\text{atom}}$ 的表达式中，该项为：\n$$\nE_{\\text{pair}}^{\\text{atom}} = \\frac{1}{2}\\sum_{j\\neq i} \\phi(r_{ij})\n$$\n该求和是对中心原子 $i$ 的所有邻居 $j$ 进行的。我们可以将这些邻居分组为配位壳层，其中给定壳层 $k$ 中的所有原子与原子 $i$ 的距离都相同，为 $r_k$。壳层 $k$ 中的原子数是配位数 $z_k$。因此，该和可以重写为对壳层的求和：\n$$\n\\sum_{j\\neq i} \\phi(r_{ij}) = \\sum_{k=1}^{\\infty} z_k \\phi(r_k)\n$$\n问题指定我们在此求和中必须只保留前两个晶格壳层。因此，该和近似为：\n$$\n\\sum_{j\\neq i} \\phi(r_{ij}) \\approx z_1 \\phi(r_1) + z_2 \\phi(r_2)\n$$\n将此近似代入 $E_{\\text{pair}}^{\\text{atom}}$ 的表达式中，得到：\n$$\nE_{\\text{pair}}^{\\text{atom}} \\approx \\frac{1}{2} \\left[ z_1 \\phi(r_1) + z_2 \\phi(r_2) \\right]\n$$\n给定 fcc 晶格的值：$z_1 = 12$，$r_1 = a/\\sqrt{2}$ 和 $z_2 = 6$，$r_2 = a$。代入这些值可得：\n$$\nE_{\\text{pair}}^{\\text{atom}} = \\frac{1}{2} \\left[ 12 \\cdot \\phi\\left(\\frac{a}{\\sqrt{2}}\\right) + 6 \\cdot \\phi(a) \\right] = 6 \\cdot \\phi\\left(\\frac{a}{\\sqrt{2}}\\right) + 3 \\cdot \\phi(a)\n$$\n现在，我们代入给定的对势函数形式 $\\phi(r) = \\varepsilon \\exp(-\\alpha r)$:\n$$\n\\phi\\left(\\frac{a}{\\sqrt{2}}\\right) = \\varepsilon \\exp\\left(-\\alpha \\frac{a}{\\sqrt{2}}\\right)\n$$\n$$\n\\phi(a) = \\varepsilon \\exp(-\\alpha a)\n$$\n将这些代入 $E_{\\text{pair}}^{\\text{atom}}$ 的表达式中：\n$$\nE_{\\text{pair}}^{\\text{atom}}(a) = 6 \\varepsilon \\exp\\left(-\\frac{\\alpha a}{\\sqrt{2}}\\right) + 3 \\varepsilon \\exp(-\\alpha a)\n$$\n最后一步是通过将整个表达式除以 $\\varepsilon$ 来求得无量纲量 $E_{\\text{pair}}^{\\text{atom}}(a) / \\varepsilon$：\n$$\n\\frac{E_{\\text{pair}}^{\\text{atom}}(a)}{\\varepsilon} = 6 \\exp\\left(-\\frac{\\alpha a}{\\sqrt{2}}\\right) + 3 \\exp(-\\alpha a)\n$$\n这是在 fcc 晶体的双壳层近似下，每个原子内聚能的无量纲对势贡献的最终闭式解析表达式。",
            "answer": "$$\n\\boxed{6 \\exp\\left(-\\frac{\\alpha a}{\\sqrt{2}}\\right) + 3 \\exp(-\\alpha a)}\n$$"
        },
        {
            "introduction": "在计算模拟中，为了提高计算效率，原子间相互作用势通常需要在有限距离处被截断。然而，一个简单的“硬”截断会在能量函数中引入不连续性，导致计算出的力和应力在截断半径处发生不合物理的突变。本次实践聚焦于解决这一关键技术问题。你将推导出一个平滑的“锥化”函数，它能够确保能量、力乃至弹性常数在截断区域内平滑地过渡到零，这是构建稳定且可靠的分子动力学模拟所必需的。",
            "id": "3754243",
            "problem": "考虑一个用嵌入原子方法（EAM）建模的金属，其原子构型在位置 $\\{\\mathbf{r}_i\\}$ 处的总能量定义为\n$$\nE = \\sum_{i} F(\\rho_i) + \\frac{1}{2} \\sum_{i \\neq j} \\phi(r_{ij}), \\quad \\rho_i = \\sum_{j \\neq i} g(r_{ij}),\n$$\n其中 $r_{ij} = |\\mathbf{r}_i - \\mathbf{r}_j|$，$F(\\rho)$ 是作为主体电子密度 $\\rho_i$ 函数的嵌入能，$\\phi(r)$ 是对相互作用，而 $g(r)$ 是距离为 $r$ 的原子所贡献的电子密度。在实践中，为了保持计算效率，每个径向函数都会在一个有限的截断半径 $r_c$ 处被截断。一个朴素的截断 $f(r) \\mapsto f(r) \\,\\Theta(r_c - r)$（其中 $\\Theta$ 是亥维赛德阶跃函数，$f \\in \\{\\phi,g\\}$）在动力学过程中原子对跨越 $r_c$ 时，或者当构型受到无穷小均匀应变时，会引起力和基于维里定理的应力的不连续性。\n\n为了消除这些人为效应，人们将 $f(r)$ 替换为一个锥化形式 $f(r) s(r)$，其中 $s(r)$ 在区间 $[r_s, r_c]$（$r_s  r_c$）内从 $1$ 平滑过渡到 $0$，并在该区间外为常数。从 EAM 能量定义、力定义 $\\mathbf{F}_k = -\\nabla_{\\mathbf{r}_k} E$ 以及对中心力的维里（Irving–Kirkwood）应力定义出发，论证 $s(r)$ 在 $r_c$ 附近的可微性如何影响力和维里的连续性，并确定 $s(r)$ 在 $r = r_c$ 和 $r = r_s$ 处的最小平滑度要求，以使力和维里都是原子位置和无穷小均匀应变参数的连续函数。\n\n然后，在这些平滑度要求和 $s(r)$ 在 $[r_s,r_c]$ 区间外为常数的约束下，构建在区间 $[r_s, r_c]$ 上满足您分析所隐含的边界条件的最低阶多项式锥化函数 $s(r)$。将您的最终结果表示为一个仅含 $r$、$r_s$ 和 $r_c$ 的、在 $r \\in [r_s, r_c]$ 上有效的 $s(r)$ 的单一闭式解析表达式。最终答案不需要数值近似。",
            "solution": "首先评估问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n-   在嵌入原子方法（EAM）中，原子构型的总能量由下式给出：\n    $E = \\sum_{i} F(\\rho_i) + \\frac{1}{2} \\sum_{i \\neq j} \\phi(r_{ij})$\n-   位置 $i$ 处的主体电子密度为：\n    $\\rho_i = \\sum_{j \\neq i} g(r_{ij})$\n-   $r_{ij} = |\\mathbf{r}_i - \\mathbf{r}_j|$ 是原子 $i$ 和原子 $j$ 之间的距离。\n-   $F(\\rho)$ 是嵌入能函数。\n-   $\\phi(r)$ 是对相互作用势。\n-   $g(r)$ 是电子密度贡献函数。\n-   径向函数 $\\phi(r)$ 和 $g(r)$ 在截断半径 $r_c$ 处被截断。\n-   对于 $f \\in \\{\\phi, g\\}$，朴素截断 $f(r) \\mapsto f(r) \\Theta(r_c - r)$ 是有问题的。\n-   引入了平滑截断：$f(r) \\mapsto f(r)s(r)$。\n-   锥化函数 $s(r)$ 具有以下性质：\n    -   它在区间 $[r_s, r_c]$（其中 $r_s  r_c$）内从 $1$ 平滑过渡到 $0$。\n    -   当 $r  r_s$ 时，$s(r) = 1$。\n    -   当 $r  r_c$ 时，$s(r) = 0$。\n-   原子 $k$ 上的力定义为 $\\mathbf{F}_k = -\\nabla_{\\mathbf{r}_k} E$。\n-   维里应力也需要考虑，其连续性是必需的。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据：** 该问题基于嵌入原子方法，这是计算材料科学中一类成熟且广泛使用的原子间势。力、维里应力和平滑截断的概念是分子动力学模拟中的标准内容。其表述是科学合理的。\n-   **适定性：** 该问题要求找出锥化函数 $s(r)$ 的最小平滑度要求，然后构建满足这些要求的最低阶多项式。目标明确，并能导出一个唯一解。\n-   **客观性：** 该问题使用精确的数学和物理术语进行陈述，不含主观论断。\n\n该问题是自洽、一致且科学有效的。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n### 解答推导\n\n分析分两部分进行。首先，我们确定锥化函数 $s(r)$ 的最小平滑度要求。其次，我们构建满足这些要求的 $s(r)$ 的具体多项式形式。\n\n令修正后的锥化势函数为 $\\tilde{\\phi}(r) = \\phi(r)s(r)$ 和 $\\tilde{g}(r) = g(r)s(r)$。总能量则为：\n$$\nE = \\sum_{i} F\\left( \\sum_{j \\neq i} \\tilde{g}(r_{ij}) \\right) + \\frac{1}{2} \\sum_{i \\neq j} \\tilde{\\phi}(r_{ij})\n$$\n\n**1. 力的连续性**\n\n原子 $k$ 上的力是总能量对其位置 $\\mathbf{r}_k$ 的负梯度：\n$$\n\\mathbf{F}_k = -\\nabla_{\\mathbf{r}_k} E = -\\nabla_{\\mathbf{r}_k} \\left( \\sum_i F(\\rho_i) + \\frac{1}{2}\\sum_{i \\neq j} \\tilde{\\phi}(r_{ij}) \\right)\n$$\n其中 $\\rho_i = \\sum_{j \\neq i} \\tilde{g}(r_{ij})$。\n我们逐项计算梯度。对相互作用项的梯度为：\n$$\n-\\nabla_{\\mathbf{r}_k} \\left( \\frac{1}{2}\\sum_{i \\neq j} \\tilde{\\phi}(r_{ij}) \\right) = -\\sum_{j \\neq k} \\frac{d\\tilde{\\phi}(r_{kj})}{dr_{kj}} \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}} = -\\sum_{j \\neq k} \\tilde{\\phi}'(r_{kj}) \\hat{\\mathbf{r}}_{kj}\n$$\n其中 $\\hat{\\mathbf{r}}_{kj} = (\\mathbf{r}_k - \\mathbf{r}_j) / r_{kj}$。\n\n嵌入能项的梯度更为复杂：\n$$\n-\\nabla_{\\mathbf{r}_k} \\left( \\sum_i F(\\rho_i) \\right) = - \\sum_i \\frac{dF}{d\\rho_i} \\nabla_{\\mathbf{r}_k} \\rho_i = -\\sum_i F'(\\rho_i) \\nabla_{\\mathbf{r}_k} \\left( \\sum_{j \\neq i} \\tilde{g}(r_{ij}) \\right)\n$$\n梯度 $\\nabla_{\\mathbf{r}_k} \\rho_i$ 仅在 $\\rho_i$ 的求和中涉及原子 $k$ 时才非零。这发生在 $i=k$ 或 $j=k$ 的情况下。\n-   当 $i=k$ 时：$\\nabla_{\\mathbf{r}_k} \\rho_k = \\nabla_{\\mathbf{r}_k} \\sum_{j \\neq k} \\tilde{g}(r_{kj}) = \\sum_{j \\neq k} \\tilde{g}'(r_{kj}) \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}}$。\n-   当 $j=k$ 时（在 $\\rho_i$ 的求和中，且 $i \\neq k$）：$\\nabla_{\\mathbf{r}_k} \\tilde{g}(r_{ik}) = \\tilde{g}'(r_{ik}) \\frac{\\mathbf{r}_k - \\mathbf{r}_i}{r_{ik}}$。\n\n结合这些，原子 $k$ 上的嵌入力为：\n$$\n-F'(\\rho_k) \\sum_{j \\neq k} \\tilde{g}'(r_{kj}) \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}} - \\sum_{i \\neq k} F'(\\rho_i) \\tilde{g}'(r_{ik}) \\frac{\\mathbf{r}_k - \\mathbf{r}_i}{r_{ik}}\n$$\n通过在第二个和式中将索引 $i$ 重新标记为 $j$，我们可以合并各项：\n$$\n-\\sum_{j \\neq k} \\left[ F'(\\rho_k) \\tilde{g}'(r_{kj}) + F'(\\rho_j) \\tilde{g}'(r_{jk}) \\right] \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}}\n$$\n原子 $k$ 上的总力是对相互作用贡献和嵌入贡献之和：\n$$\n\\mathbf{F}_k = - \\sum_{j \\neq k} \\left[ \\tilde{\\phi}'(r_{kj}) + F'(\\rho_k)\\tilde{g}'(r_{kj}) + F'(\\rho_j)\\tilde{g}'(r_{kj}) \\right] \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}}\n$$\n为了使力 $\\mathbf{F}_k$ 成为原子位置的连续函数，$\\tilde{\\phi}'(r)$ 和 $\\tilde{g}'(r)$ 必须是 $r$ 的连续函数。$\\tilde{\\phi}(r) = \\phi(r)s(r)$ 的导数是 $\\tilde{\\phi}'(r) = \\phi'(r)s(r) + \\phi(r)s'(r)$。假设基本函数 $\\phi(r)$ 和 $\\phi'(r)$ 是平滑的，要使 $\\tilde{\\phi}'(r)$ 在边界 $r_s$ 和 $r_c$ 处连续，则要求 $s(r)$ 和 $s'(r)$ 都必须是连续的。这意味着 $s(r)$ 必须是连续可微的，即 $s(r) \\in C^1$。\n$C^1$ 连续性所需的边界条件是：\n-   $s(r)$ 必须是连续的：$s(r_s) = 1$ 且 $s(r_c) = 0$。\n-   $s'(r)$ 必须是连续的：$s'(r_s) = 0$（因为当 $r  r_s$ 时 $s'(r)=0$）且 $s'(r_c) = 0$（因为当 $r  r_c$ 时 $s'(r)=0$）。\n\n**2. 维里应力及其导数的连续性**\n\n维里张量与应力张量相关，可以表示为对原子对的求和。对于 EAM 势，其表达式为：\n$$\n\\mathcal{V}_{\\alpha\\beta} = \\frac{1}{2} \\sum_{i \\neq j} r_{ij, \\alpha} F_{ij, \\beta}\n$$\n其中 $F_{ij, \\beta}$ 是原子 $j$ 对原子 $i$ 的力的 $\\beta$ 分量。通过对称化力的表达式，维里可以写为：\n$$\n\\boldsymbol{\\mathcal{V}} = -\\frac{1}{2} \\sum_{i \\neq j} \\frac{1}{r_{ij}} \\left[ \\tilde{\\phi}'(r_{ij}) + (F'(\\rho_i)+F'(\\rho_j))\\tilde{g}'(r_{ij}) \\right] \\mathbf{r}_{ij} \\otimes \\mathbf{r}_{ij}\n$$\n维里张量本身作为原子位置的函数，其连续性要求方括号中的系数是连续的，这又要求 $\\tilde{\\phi}'(r)$ 和 $\\tilde{g}'(r)$ 是连续的。这与为力推导出的对 $s(r)$ 的 $C^1$ 要求相同。\n\n然而，问题要求函数关于“无穷小均匀应变参数”是连续的。这意味着从能量的应变导数导出的物理量，如弹性常数，也必须是连续的。弹性常数张量为 $C_{\\alpha\\beta\\mu\\nu} = \\frac{1}{V} \\frac{\\partial^2 E}{\\partial \\epsilon_{\\alpha\\beta} \\partial \\epsilon_{\\mu\\nu}}$。为了使弹性常数在原子对跨越截断边界时是连续函数，有效势的二阶导数 $\\tilde{\\phi}''(r)$ 和 $\\tilde{g}''(r)$ 必须是连续的。\n\n我们来考察 $\\tilde{\\phi}(r)$ 的二阶导数：\n$$\n\\tilde{\\phi}''(r) = \\frac{d}{dr}\\left[\\phi'(r)s(r) + \\phi(r)s'(r)\\right] = \\phi''(r)s(r) + 2\\phi'(r)s'(r) + \\phi(r)s''(r)\n$$\n假设基本函数 $\\phi(r)$ 及其导数是平滑的，要使 $\\tilde{\\phi}''(r)$ 在 $r_s$ 和 $r_c$ 处连续，则要求 $s(r)$、$s'(r)$ 和 $s''(r)$ 都是连续的。因此，对于一个能够产生连续的力、应力和弹性常数的物理上稳健的势，其最小平滑度要求是锥化函数 $s(r)$ 必须是二阶连续可微的，即 $s(r) \\in C^2$。\n\n这施加了两个额外的边界条件：\n-   $s''(r)$ 必须是连续的：$s''(r_s) = 0$ 且 $s''(r_c) = 0$。\n\n总而言之，我们在区间 $[r_s, r_c]$ 上对 $s(r)$ 有六个边界条件：\n1.  $s(r_s) = 1$\n2.  $s(r_c) = 0$\n3.  $s'(r_s) = 0$\n4.  $s'(r_c) = 0$\n5.  $s''(r_s) = 0$\n6.  $s''(r_c) = 0$\n\n**3. 多项式锥化函数的构建**\n\n为了用最低阶多项式满足这六个条件，我们需要一个 5 次多项式（五次多项式）。我们定义一个归一化变量 $x = \\frac{r - r_s}{r_c - r_s}$，这样当 $r \\in [r_s, r_c]$ 时，$x \\in [0, 1]$。令我们的多项式为 $s(r) = P(x)$。\n用 $P(x)$ 表示的边界条件是：\n-   $P(0) = 1$\n-   $P(1) = 0$\n-   $P'(0) = 0$（因为 $s' \\propto P'$）\n-   $P'(1) = 0$\n-   $P''(0) = 0$（因为 $s'' \\propto P''$）\n-   $P''(1) = 0$\n\n设 $P(x) = a x^5 + b x^4 + c x^3 + d x^2 + e x + f$。\n-   $P(0)=1 \\implies f=1$。\n-   $P'(x) = 5ax^4 + 4bx^3 + 3cx^2 + 2dx + e$。$P'(0)=0 \\implies e=0$。\n-   $P''(x) = 20ax^3 + 12bx^2 + 6cx + 2d$。$P''(0)=0 \\implies d=0$。\n\n因此多项式简化为 $P(x) = ax^5 + bx^4 + cx^3 + 1$。现在应用 $x=1$ 处的条件：\n1.  $P(1) = a+b+c+1 = 0$\n2.  $P'(1) = 5a+4b+3c = 0$\n3.  $P''(1) = 20a+12b+6c = 0$，可简化为 $10a+6b+3c = 0$。\n\n我们求解这个三元线性方程组。\n由 (1) 式得，$c = -1 - a - b$。代入 (2) 和 (3) 式：\n-   $5a+4b+3(-1-a-b) = 0 \\implies 2a+b=3$\n-   $10a+6b+3(-1-a-b) = 0 \\implies 7a+3b=3$\n\n由 $2a+b=3$ 得，$b=3-2a$。将此代入第二个方程：\n$7a+3(3-2a)=3 \\implies 7a+9-6a=3 \\implies a = -6$。\n于是，$b = 3-2(-6) = 15$。\n最后，$c = -1 - (-6) - 15 = -10$。\n\n系数为 $a=-6, b=15, c=-10, d=0, e=0, f=1$。在归一化坐标下的多项式是：\n$$\nP(x) = -6x^5 + 15x^4 - 10x^3 + 1\n$$\n将 $x = \\frac{r - r_s}{r_c - r_s}$ 代回，我们得到在区间 $[r_s, r_c]$ 上锥化函数 $s(r)$ 的最终表达式。",
            "answer": "$$\n\\boxed{-6 \\left(\\frac{r - r_s}{r_c - r_s}\\right)^5 + 15 \\left(\\frac{r - r_s}{r_c - r_s}\\right)^4 - 10 \\left(\\frac{r - r_s}{r_c - r_s}\\right)^3 + 1}\n$$"
        },
        {
            "introduction": "掌握了势函数的理论和构造技巧后，最终的挑战是将其转化为高效的计算机代码。本次实践将带你深入EAM计算的核心——电子密度$\\rho_i$的累加过程。你将设计并实现一个线性时间复杂度（$O(N)$）的算法，该算法不仅能正确处理独特的邻近原子对以避免重复计算，还通过优化数据访问模式（缓存局部性）来追求极致的计算性能。这个练习是从理论物理学家到计算科学家的重要一步，让你亲身体验高性能科学计算中的关键思想。",
            "id": "3754216",
            "problem": "给定每个原子的嵌入原子方法 (EAM) 电子密度的定义如下：对于索引为 $i$ 的原子，标量电子密度 $\\rho_i$ 定义为其邻居原子对贡献的总和，\n$$\n\\rho_i = \\sum_{j \\neq i} f\\!\\left(r_{ij}\\right),\n$$\n其中 $f(r)$ 是一个在离散采样半径上制表的标量值径向函数，$r_{ij}$ 是原子 $i$ 和原子 $j$ 之间的距离。在邻居列表的表述中，每个邻居对 $(i,j)$ 代表两个不同原子之间的无序相互作用。假设邻居列表是唯一的（例如，只列出 $j  i$ 的原子对），因此没有原子对会出现一次以上。目标是计算所有的 $\\rho_i$，同时在每个原子的平均邻居数量有界的假设下，实现一个单遍的 $O(N)$ 算法，通过使用连续数组和保持局部性的迭代来最小化缓存未命中，并通过每对原子只更新一次对称贡献来避免重复计算。\n\n基本基础和假设：\n- 上述电子密度定义是起点。本任务中不需要涉及嵌入能的更高级别 EAM 能量表达式。\n- 函数 $f(r)$ 以径向点上的列表形式提供。必须使用分段线性插值在列表点之间进行插值。具体来说：\n  - 如果 $r \\le r_{\\min}$，则 $f(r) = f(r_{\\min})$。\n  - 如果 $r \\ge r_{\\max}$，则 $f(r) = 0$。\n  - 否则，$f(r)$ 是围绕 $r$ 的两个最近的制表半径之间的线性插值。\n- 邻居列表包含唯一的无序原子对 $(i,j)$ 及其相关距离 $r_{ij}$，并且不需要周期性边界条件。无需从位置推断距离；距离直接在邻居列表中提供。所有原子都从 $0$ 索引到 $N-1$。\n\n算法要求：\n- 设计一个原地累加算法，该算法对邻居列表仅迭代一次。对于每对距离为 $r_{ij}$ 的原子对 $(i,j)$，计算 $f(r_{ij})$ 并将此贡献同时加到 $\\rho_i$ 和 $\\rho_j$ 上。\n- 对原子对索引和距离使用数组结构 (structure-of-arrays) 组织，并在累加前按第一个索引 $i$ 对原子对进行排序，以增强空间局部性并减少缓存未命中。\n- 证明在每个原子的最大邻居数固定的情况下，总运行时间按 $O(N)$ 比例缩放。\n- 通过从不遍历 $(i,j)$ 和 $(j,i)$ 来确保不发生重复计算；而是遍历唯一的原子对列表，并在一步中更新两个原子。\n\n所有测试用例的制表函数：\n- 半径样本：$r$ 等于 $0.0$, $1.0$, $2.0$, $3.0$, $3.5$。\n- 函数样本：$f(r)$ 等于 $1.0$, $0.8$, $0.3$, $0.1$, $0.0$。\n\n测试套件：\n- 测试用例 1 (正常路径)：$N = 4$ 个原子。邻居对及其距离：\n  - $(0,1,1.0)$,\n  - $(0,2,2.0)$,\n  - $(1,2,1.0)$,\n  - $(2,3,2.0)$。\n- 测试用例 2 (边界：无邻居)：$N = 3$ 个原子。邻居对列表为空。\n- 测试用例 3 (插值覆盖)：$N = 5$ 个原子。邻居对及其距离：\n  - $(0,1,0.5)$,\n  - $(0,2,1.5)$,\n  - $(1,3,2.75)$,\n  - $(2,4,1.5)$,\n  - $(3,4,0.5)$。\n- 测试用例 4 ($r_{\\max}$ 处的精确端点)：$N = 2$ 个原子。邻居对及其距离：\n  - $(0,1,3.5)$。\n\n单位：\n- 距离 $r$ 使用任意长度单位，$f(r)$ 和 $\\rho_i$ 是无量纲的。不需要进行物理单位转换。\n\n你的任务：\n- 在一个独立的自包含程序中实现上述算法，该程序构建制表函数和测试套件，执行分段线性插值，通过对唯一原子对进行单遍扫描来计算所有 $\\rho_i$，同时最小化缓存未命中并避免重复计算，并为每个测试用例打印最终的电子密度。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是按原子索引从 $0$ 到 $N-1$ 排序的浮点数列表。例如，输出必须看起来像 $[[\\rho_{0}^{(1)},\\rho_{1}^{(1)},\\dots],\\,[\\rho_{0}^{(2)},\\rho_{1}^{(2)},\\dots],\\,\\dots]$，不含任何额外文本。",
            "solution": "该问题要求实现一种算法，用于计算一个包含 $N$ 个原子的系统的嵌入原子方法 (EAM) 电子密度 $\\rho_i$。原子 $i$ 的电子密度定义为其邻近原子 $j$ 贡献的总和：\n$$\n\\rho_i = \\sum_{j \\neq i} f(r_{ij})\n$$\n其中 $r_{ij}$ 是原子 $i$ 和原子 $j$ 之间的距离，$f(r)$ 是一个径向对函数。问题提供了 $f(r)$ 的制表形式，并指定了分段线性插值方案以在任意距离处对其进行求值。任务的核心是设计并实现一个高效的单遍算法，该算法能为一组给定的唯一邻居对 $(i,j)$ 正确计算所有 $\\rho_i$ 值。\n\n该算法必须遵循几个关键的正确性和效率原则：\n1.  **对称更新**：邻居列表由唯一的、无序的原子对 $(i,j)$ 组成。这对原子对整个系统的贡献基于 $f(r_{ij})$。这个单一的值必须被加到原子 $i$ 的密度上，并且对称地，也要加到原子 $j$ 的密度上。一个遍历这个唯一列表并对每对原子执行此双重更新的算法，可以保证每个相互作用都被精确计数一次，并且 $\\rho_i$ 的最终总和是正确的。\n2.  **数据局部性**：对于大规模模拟，内存访问模式会显著影响性能。问题指定按第一个原子索引 $i$ 对邻居列表进行排序。这将所有涉及原子 $i$ 的原子对组合在一起。在迭代时，这改善了访问和更新 $\\rho_i$ 的时间局部性。虽然在小型测试用例上效果微不足道，但在实践中这是一项至关重要的优化。\n3.  **线性复杂度**：在每个原子的邻居数量有界的标准假设下，算法的计算成本应与原子数 $N$呈线性关系。\n\n**算法设计与复杂度分析**\n\n所提出的算法流程如下：\n1.  初始化一个大小为 $N$ 的数组 $\\rho$，所有元素均为零。该数组将存储累积的电子密度 $\\rho_0, \\rho_1, \\dots, \\rho_{N-1}$。\n2.  为增强数据局部性，根据每对中的第一个原子索引对提供的邻居对列表进行排序。\n3.  对排序后的邻居列表仅迭代一次。对于代表一对原子 $(i,j)$ 及其间距 $r_{ij}$ 的每个条目：\n    a. 使用指定的分段线性插值规则评估函数 $f(r_{ij})$。函数 $f(r)$ 是基于一组制表半径 $\\{r_k\\}$ 和相应的值 $\\{f(r_k)\\}$ 定义的：\n       - 如果 $r \\le r_{\\min}$，$f(r) = f(r_{\\min})$。\n       - 如果 $r \\ge r_{\\max}$，$f(r) = 0$。\n       - 如果 $r_k \\le r  r_{k+1}$，$f(r)$ 通过线性插值确定：\n         $$\n         f(r) = f(r_k) + \\frac{f(r_{k+1}) - f(r_k)}{r_{k+1} - r_k}(r - r_k)\n         $$\n       这种插值可以使用标准库函数（如 `scipy.interpolate.interp1d`）稳健地实现，该函数能有效处理边界情况和区间搜索。\n    b. 将计算出的值 $f(r_{ij})$ 加到该原子对中两个原子的密度累加器上：\n       $$\n       \\rho_i \\leftarrow \\rho_i + f(r_{ij})\n       $$\n       $$\n       \\rho_j \\leftarrow \\rho_j + f(r_{ij})\n       $$\n4.  循环完成后，数组 $\\rho$ 包含所有原子的最终电子密度。\n\n**复杂度证明 ($O(N)$)**：\n设 $N$ 为原子数。问题陈述了有界的平均邻居数，这意味着邻居列表中的总对数 $M$ 与 $N$ 成正比，即 $M \\in O(N)$。\n- **步骤 1 (初始化)**：创建一个大小为 $N$ 的零数组需要 $O(N)$ 时间。\n- **步骤 2 (排序)**：按第一个索引（一个在 $[0, N-1]$ 范围内的整数）对 $M$ 个原子对进行排序，可以使用像计数排序这样的线性时间算法在 $O(M+N)$ 时间内完成。由于 $M \\in O(N)$，此步骤的时间复杂度为 $O(N)$。\n- **步骤 3 (迭代)**：算法迭代 $M$ 次。在循环内部：\n    - 评估 $f(r_{ij})$ 涉及在制表数据中找到正确的区间。对于 $k_s$ 个采样点，此搜索需要 $O(\\log k_s)$ 时间。由于 $k_s$ 是一个小的固定常数，这实际上是一个 $O(1)$ 操作。\n    - 对 $\\rho$ 数组的两次加法是 $O(1)$ 操作。\n    - 因此，每对原子的工作量是恒定的。循环的总时间是 $O(M)$。\n- 总运行时间复杂度是这些步骤的总和：$O(N) + O(N) + O(M) = O(N) + O(N) + O(N) = O(N)$。该算法的运行时间与原子数呈线性关系，符合要求。\n\n下面的实现是针对所提供的测试用例的。为了简洁和正确，插值由 `scipy.interpolate.interp1d` 处理，主循环执行对称的密度累加。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Solves the EAM electron density problem for all test cases.\n    \"\"\"\n    # Tabulated function data for all test cases.\n    # Radii samples and corresponding function values.\n    r_samples = np.array([0.0, 1.0, 2.0, 3.0, 3.5])\n    f_samples = np.array([1.0, 0.8, 0.3, 0.1, 0.0])\n\n    # Per the problem description, f(r) for r = r_max is 0.\n    # For r = r_min, f(r) = f(r_min).\n    # scipy.interpolate.interp1d handles these boundary conditions\n    # with the fill_value parameter.\n    # fill_value=(below, above)\n    f_interpolator = interp1d(\n        r_samples, \n        f_samples, \n        kind='linear', \n        bounds_error=False, \n        fill_value=(f_samples[0], 0.0)\n    )\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (Number of atoms N, neighbor list of (i, j, r_ij)).\n    test_cases = [\n        # Test case 1 (happy path)\n        (4, [\n            (0, 1, 1.0),\n            (0, 2, 2.0),\n            (1, 2, 1.0),\n            (2, 3, 2.0),\n        ]),\n        # Test case 2 (boundary: no neighbors)\n        (3, []),\n        # Test case 3 (interpolation coverage)\n        (5, [\n            (0, 1, 0.5),\n            (0, 2, 1.5),\n            (1, 3, 2.75),\n            (2, 4, 1.5),\n            (3, 4, 0.5),\n        ]),\n        # Test case 4 (exact endpoint at r_max)\n        (2, [(0, 1, 3.5)]),\n    ]\n\n    results = []\n    # Process each test case\n    for N, neighbor_list in test_cases:\n        # Step 1: Initialize density array to zeros.\n        rhos = np.zeros(N, dtype=float)\n\n        # Step 2: Sort pairs by the first index for cache locality (as required).\n        # For small test cases, this has negligible performance impact but is done\n        # for algorithmic correctness.\n        # The lambda function extracts the first element (atom i) for sorting.\n        neighbor_list.sort(key=lambda pair: pair[0])\n\n        # Step 3: Single pass over the unique neighbor list.\n        for i, j, rij in neighbor_list:\n            # Step 3a: Evaluate f(r_ij) using interpolation.\n            f_val = f_interpolator(rij)\n\n            # Step 3b: Symmetrically update densities for both atoms in the pair.\n            # This is the \"in-place accumulation\".\n            rhos[i] += f_val\n            rhos[j] += f_val\n        \n        # Store the computed densities as a standard Python list.\n        results.append(rhos.tolist())\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists: [[...], [...], ...]\n    # map(str, results) converts each inner list to its string representation.\n    # ','.join(...) combines them with commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function.\nsolve()\n\n```"
        }
    ]
}