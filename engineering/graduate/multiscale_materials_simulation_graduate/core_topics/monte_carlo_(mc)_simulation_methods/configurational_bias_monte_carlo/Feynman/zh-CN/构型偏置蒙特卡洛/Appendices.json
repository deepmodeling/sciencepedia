{
    "hands_on_practices": [
        {
            "introduction": "构型偏置蒙特卡洛（CBMC）方法的核心在于其智能的试探构象选择过程，该过程由一个“局域能量”项进行引导。为了正确实现该算法，精确地定义此能量项至关重要。下面的练习将帮助你明确在聚合物链的增长步骤中，哪些能量贡献（键合与非键合）必须包含在用于计算试探权重（即玻尔兹曼因子）的局域能量中，从而确保偏置选择的有效性。()",
            "id": "3797247",
            "problem": "使用构象偏置蒙特卡洛 (CBMC) 方法在恒定温度 $T$ 下模拟一个线性聚合物。分子内能量由分别依赖于键长 $r$、键角 $\\theta$ 和二面角 $\\phi$ 的键合项 $u_{\\text{bond}}(r)$、$u_{\\text{angle}}(\\theta)$ 和 $u_{\\text{dihedral}}(\\phi)$，以及作用于非键合连接位点对之间的非键相互作用 $u_{\\text{nb}}(r)$ 组成。非键势是具有对相加性的，在截断半径 $r_c$ 处被截断和移位，使得 $u_{\\text{nb}}(r\\ge r_c)=0$，并且通过维护邻居列表，只考虑 $r_c$ 范围内的位点对。\n\n在一个再生长步骤中，一个新的位点 $i$ 被连接到位点 $i-1$ 上，并为决定 $r_{i,i-1}$、$\\theta_{i,i-1,i-2}$、$\\phi_{i,i-1,i-2,i-3}$ 以及新位点 $i$ 与周围位点 $j$ 之间距离 $r_{ij}$ 的局部自由度生成 $k$ 个试验构象 $\\{\\mathbf{q}_\\ell\\}_{\\ell=1}^k$。CBMC 以正比于局部能量 $U_{\\text{loc}}(\\mathbf{q}_\\ell)$ 的玻尔兹曼因子的概率，从 $k$ 个试验中选择一个，并使用相应的 Rosenbluth 权重来确保正则系综中的细致平衡。\n\n从正则分布 $p(\\mathbf{x}) \\propto \\exp(-\\beta U(\\mathbf{x}))$（其中 $\\beta = 1/(k_{\\text{B}} T)$）和用于试验选择的细致平衡的定义出发，请确定哪个表达式正确地指定了在此再生长步骤中用于试验权重的局部能量 $U_{\\text{loc}}$，以及哪个理由正确地解释了在此情境下使用邻居列表时为何可以忽略远程相互作用。\n\n假设采用标准的力场约定，其中被键合拓扑排除的非键相互作用（例如 $1$-$2$ 和 $1$-$3$ 对）不包含在 $u_{\\text{nb}}$ 中，并且任何 $1$-$4$ 标度因子已酌情内置于 $u_{\\text{dihedral}}$ 或 $u_{\\text{nb}}$ 中。\n\n选择唯一最佳选项。\n\nA. $U_{\\text{loc}}$ 等于新形成的局部几何结构的键合贡献之和，$u_{\\text{bond}}(r_{i,i-1}) + u_{\\text{angle}}(\\theta_{i,i-1,i-2}) + u_{\\text{dihedral}}(\\phi_{i,i-1,i-2,i-3})$，加上新位点 $i$ 与其邻居列表中截断半径内的所有位点 $j$ 之间的非键相互作用之和，$\\sum_{j \\in \\mathcal{N}(i)} u_{\\text{nb}}(r_{ij})$。可以忽略远程相互作用，因为对于 $r \\ge r_c$，截断并移位的 $u_{\\text{nb}}$ 恰好为零，所以来自超出 $r_c$ 的位点对的贡献与试验无关，并在相对试验概率中被抵消。\n\nB. $U_{\\text{loc}}$ 仅包含键合项 $u_{\\text{bond}}(r_{i,i-1}) + u_{\\text{angle}}(\\theta_{i,i-1,i-2}) + u_{\\text{dihedral}}(\\phi_{i,i-1,i-2,i-3})$，而非键项被排除，因为邻居列表已经降低了计算成本，且非键相互作用与所选的试验构象无关。\n\nC. $U_{\\text{loc}}$ 是全系统的能量差 $U_{\\text{after}} - U_{\\text{before}}$，即对聚合物中所有键合和非键相互作用求和，因为细致平衡要求即使在使用邻居列表时也要考虑长程静电作用；远程相互作用必须被包括在内。\n\nD. $U_{\\text{loc}}$ 是新位点 $i$ 与系统中所有原子的键合和非键相互作用之和，$\\sum_{j} u_{\\text{nb}}(r_{ij})$ 不带任何截断，因为对势的截断会违反细致平衡；因此，不能忽略超出 $r_c$ 的相互作用。\n\nE. $U_{\\text{loc}}$ 等于键合项加上与邻居列表伙伴的非键相互作用，但必须减去一个平均场背景能量密度以补偿被忽略的远程原子；为保持无偏的试验选择，这个平均场修正是必需的。",
            "solution": "问题陈述已提交验证。\n\n**第1步：提取已知条件**\n- **模拟方法：** 在恒定温度 $T$ 下进行构象偏置蒙特卡洛 (CBMC) 模拟。\n- **体系：** 线性聚合物。\n- **系综：** 正则系综，概率分布为 $p(\\mathbf{x}) \\propto \\exp(-\\beta U(\\mathbf{x}))$，其中 $\\beta = 1/(k_{\\text{B}} T)$。\n- **分子内势：** 由键合项组成：$u_{\\text{bond}}(r)$、$u_{\\text{angle}}(\\theta)$ 和 $u_{\\text{dihedral}}(\\phi)$。\n- **非键势：** $u_{\\text{nb}}(r)$，对相加性，截断并移位，使得 $u_{\\text{nb}}(r \\ge r_c) = 0$。\n- **计算细节：** 使用邻居列表来考虑截断半径 $r_c$ 内的位点对。\n- **CBMC 移动：** 一个再生长步骤，其中新位点 $i$ 连接到位点 $i-1$。\n- **试验生成：** 为局部自由度（$r_{i,i-1}$, $\\theta_{i,i-1,i-2}$, $\\phi_{i,i-1,i-2,i-3}$）生成 $k$ 个试验构象 $\\{\\mathbf{q}_\\ell\\}_{\\ell=1}^k$。\n- **试验选择：** 以与类玻尔兹曼权重 $\\exp(-\\beta U_{\\text{loc}}(\\mathbf{q}_\\ell))$ 成正比的概率选择一个试验 $\\ell$。\n- **细致平衡：** 整个过程使用 Rosenbluth 权重来满足细致平衡。\n- **力场约定：** 对于 $1$-$2$ 和 $1$-$3$ 对，排除非键相互作用。\n- **问题：** 确定用于试验权重的局部能量 $U_{\\text{loc}}$ 的正确表达式，以及忽略远程相互作用的正确理由。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据：** 问题描述了应用于聚合物链的标准 CBMC 算法，这是分子模拟中的一项基石技术。键合势和非键势、势函数截断、邻居列表的使用，以及 Rosenbluth 权重和细致平衡的概念，都是基础性的且表述正确。\n- **良构性：** 问题要求在指定条件下，定义 CBMC 算法中的一个特定项 $U_{\\text{loc}}$。这是一个明确定义的问题，可以从统计力学原理中推导出唯一且有意义的答案。\n- **客观性：** 问题以计算物理和计算化学领域通用的精确技术语言陈述。没有主观或模棱两可的术语。\n\n**第3步：结论与行动**\n问题陈述在科学上是合理的、良构的且客观的。这是一个有效的问题。可以进行求解过程。\n\n**解题推导**\n\n在正则系综中进行蒙特卡洛模拟的目标是生成一系列构象 $\\mathbf{x}$，使其出现的概率遵循玻尔兹曼分布 $p(\\mathbf{x}) \\propto \\exp(-\\beta U(\\mathbf{x}))$。这是通过构建满足细致平衡条件的移动来实现的。\n\n构象偏置蒙特卡洛 (CBMC) 方法是一种先进的技术，可提高采样效率，特别是对于链状分子。在再生长步骤中，CBMC 不是为新位点生成单个随机试验位置然后接受或拒绝它，而是生成一组 $k$ 个试验位置并智能地选择其中一个。\n\n设添加位点 $i$ 之前的系统状态为 $\\mathbf{x}_{\\text{old}}$，总能量为 $U(\\mathbf{x}_{\\text{old}})$。一个新位点 $i$ 将从位点 $i-1$ 生长出来。对于 $k$ 个试验构象中的每一个 $\\mathbf{q}_\\ell$（它定义了新位点的位置 $\\mathbf{r}_i^{(\\ell)}$），都定义了一个相应的“新”系统构象 $\\mathbf{x}_{\\text{new}}^{(\\ell)}$。这个新构象的总能量将是 $U(\\mathbf{x}_{\\text{new}}^{(\\ell)})$。\n\n在试验构象 $\\ell$ 中添加位点 $i$ 时的能量变化为：\n$$\n\\Delta U^{(\\ell)} = U(\\mathbf{x}_{\\text{new}}^{(\\ell)}) - U(\\mathbf{x}_{\\text{old}})\n$$\n这个能量变化完全归因于涉及新添加位点 $i$ 的相互作用。它包括新的分子内（键合）相互作用以及位点 $i$ 与系统中所有其他位点 $j$ 的新非键相互作用。\n$$\n\\Delta U^{(\\ell)} = \\left[ u_{\\text{bond}}(r_{i,i-1}^{(\\ell)}) + u_{\\text{angle}}(\\theta_{i,i-1,i-2}^{(\\ell)}) + u_{\\text{dihedral}}(\\phi_{i,i-1,i-2,i-3}^{(\\ell)}) \\right] + \\sum_{j} u_{\\text{nb}}(r_{ij}^{(\\ell)})\n$$\n根据力场规则（例如，排除位点 $i-1$、$i-2$、$i-3$），对 $j$ 的求和包括了系统中与位点 $i$ 有非键相互作用的所有其他位点。\n\n在 CBMC 中，我们对试验构象的选择施加偏置。我们不是均匀地从 $k$ 个试验中选择一个，而是以与权重 $w_\\ell$ 成正比的概率 $P_{\\text{select}}(\\ell)$ 来选择试验 $\\ell$。为了改善采样，选择此权重以偏向低能构象。标准的选择是某个“局部能量”$U_{\\text{loc}}(\\mathbf{q}_\\ell)$ 的玻尔兹曼因子：\n$$\nw_\\ell = \\exp(-\\beta U_{\\text{loc}}(\\mathbf{q}_\\ell))\n$$\n那么选择试验 $\\ell$ 的概率是：\n$$\nP_{\\text{select}}(\\ell) = \\frac{w_\\ell}{\\sum_{m=1}^k w_m} = \\frac{\\exp(-\\beta U_{\\text{loc}}(\\mathbf{q}_\\ell))}{\\sum_{m=1}^k \\exp(-\\beta U_{\\text{loc}}(\\mathbf{q}_m))}\n$$\n$W = \\sum_{m=1}^k w_m$ 项是 Rosenbluth 因子，它在最终的接受步骤中用于校正此选择步骤中引入的偏置，从而确保全局上满足细致平衡。\n\n关键问题是 $U_{\\text{loc}}$ 的定义。为了使偏置有效，$U_{\\text{loc}}$ 应包括所有依赖于位点 $i$ 的特定试验位置的能量项。这恰好是上面计算的总能量变化 $\\Delta U^{(\\ell)}$。任何不涉及位点 $i$ 的能量项相对于试验 $\\ell$ 的选择是恒定的，并会从相对概率 $w_\\ell/w_m$ 中抵消掉。因此，局部能量的理想选择是新粒子与系统其余部分的相互作用能。\n$$\nU_{\\text{loc}}(\\mathbf{q}_\\ell) = \\left[ u_{\\text{bond}}(r_{i,i-1}^{(\\ell)}) + u_{\\text{angle}}(\\theta_{i,i-1,i-2}^{(\\ell)}) + u_{\\text{dihedral}}(\\phi_{i,i-1,i-2,i-3}^{(\\ell)}) \\right] + \\sum_{j} u_{\\text{nb}}(r_{ij}^{(\\ell)})\n$$\n现在，我们必须考虑非键势 $u_{\\text{nb}}(r)$ 的性质。问题陈述它被截断和移位，因此 $u_{\\text{nb}}(r \\ge r_c) = 0$。这对求和 $\\sum_{j} u_{\\text{nb}}(r_{ij}^{(\\ell)})$ 有一个关键的影响。任何距离 $r_{ij}^{(\\ell)}$ 大于或等于截断半径 $r_c$ 的项对总和的贡献恰好为零。因此，求和可以限制在满足 $r_{ij}^{(\\ell)}  r_c$ 的位点 $j$ 上，而不会有任何精度损失。\n$$\n\\sum_{j} u_{\\text{nb}}(r_{ij}^{(\\ell)}) = \\sum_{j \\text{ where } r_{ij}^{(\\ell)}  r_c} u_{\\text{nb}}(r_{ij}^{(\\ell)})\n$$\n这正是邻居列表的用武之地；它们提供了一个预编译的粒子列表，这些粒子可能位于给定区域的截断半径内，从而大大降低了寻找这些相互作用对的计算成本。\n\n因此，合适的局部能量 $U_{\\text{loc}}$ 由新的键合能量项加上新位点 $i$ 与截断距离 $r_c$ 内所有其他位点 $j$ 之间的非键相互作用之和组成。对于此势模型，忽略与远程原子（超出 $r_c$）的相互作用不是一个近似；这是势被定义为在 $r \\ge r_c$ 时为零的精确结果。\n\n**选项评估**\n\n**A. $U_{\\text{loc}}$ 等于新形成的局部几何结构的键合贡献之和，$u_{\\text{bond}}(r_{i,i-1}) + u_{\\text{angle}}(\\theta_{i,i-1,i-2}) + u_{\\text{dihedral}}(\\phi_{i,i-1,i-2,i-3})$，加上新位点 $i$ 与其邻居列表中截断半径内的所有位点 $j$ 之间的非键相互作用之和，$\\sum_{j \\in \\mathcal{N}(i)} u_{\\text{nb}}(r_{ij})$。可以忽略远程相互作用，因为对于 $r \\ge r_c$，截断并移位的 $u_{\\text{nb}}$ 恰好为零，所以来自超出 $r_c$ 的位点对的贡献与试验无关，并在相对试验概率中被抵消。**\n- $U_{\\text{loc}}$ 的表达式是正确的。它包括了所有依赖于位点 $i$ 试验位置的新键合和非键相互作用，并考虑了截断。\n- 理由是正确的。对于截断势，超出截断半径的相互作用严格为零，而不仅仅是被忽略或近似。这意味着它们对能量的贡献为零，并且不影响试验的相对概率。\n- **结论：正确。**\n\n**B. $U_{\\text{loc}}$ 仅包含键合项 $u_{\\text{bond}}(r_{i,i-1}) + u_{\\text{angle}}(\\theta_{i,i-1,i-2}) + u_{\\text{dihedral}}(\\phi_{i,i-1,i-2,i-3})$，而非键项被排除，因为邻居列表已经降低了计算成本，且非键相互作用与所选的试验构象无关。**\n- $U_{\\text{loc}}$ 的表达式不正确。CBMC 的一个关键目的是避免生成具有严重空间冲突的试验位置，而这种冲突源于非键相互作用。将这些相互作用从偏置能量 $U_{\\text{loc}}$ 中排除会使其失去意义，并使算法效率极低。\n- 理由在两点上是不正确的。首先，虽然邻居列表降低了成本，但这并不是从偏置中省略非键能量的理由。其次，非键相互作用能 $u_{\\text{nb}}(r_{ij})$ 强烈依赖于试验构象，因为距离 $r_{ij}$ 随试验的选择而变化。\n- **结论：不正确。**\n\n**C. $U_{\\text{loc}}$ 是全系统的能量差 $U_{\\text{after}} - U_{\\text{before}}$，即对聚合物中所有键合和非键相互作用求和，因为细致平衡要求即使在使用邻居列表时也要考虑长程静电作用；远程相互作用必须被包括在内。**\n- $U_{\\text{loc}}$ 的表达式有细微的混淆。虽然 $U_{\\text{loc}}$ 应等于所选试验的系统能量变化 $\\Delta U^{(\\ell)}$，但“全系统能量差”的措辞是模糊的。更重要的是，理由不正确。问题明确指出使用了截断并移位的势，根据定义，它没有长程分量。提及“长程静电作用”与给定的势函数形式相矛盾。\n- **结论：不正确。**\n\n**D. $U_{\\text{loc}}$ 是新位点 $i$ 与系统中所有原子的键合和非键相互作用之和，$\\sum_{j} u_{\\text{nb}}(r_{ij})$ 不带任何截断，因为对势的截断会违反细致平衡；因此，不能忽略超出 $r_c$ 的相互作用。**\n- 理由根本上是错误的。使用截断势并不违反细致平衡。蒙特卡洛模拟可以为*任何*定义良好的势能函数 $U(\\mathbf{x})$ 完美地满足细致平衡。截断势只是定义了一个新的能量函数，从而定义了一个新的物理模型。模拟会为此新模型正确地采样系综。\n- 因为理由是错误的，所以不使用截断的结论也是基于一个错误的前提（在模拟截断模型的背景下）。\n- **结论：不正确。**\n\n**E. $U_{\\text{loc}}$ 等于键合项加上与邻居列表伙伴的非键相互作用，但必须减去一个平均场背景能量密度以补偿被忽略的远程原子；为保持无偏的试验选择，这个平均场修正是必需的。**\n- 在 MC 移动的微观能量计算中包含平均场修正是错误的。这种修正（尾部修正）有时应用于可观测量（如总能量或压力）的系综平均值，以基于使用截断势的模拟来估计具有非截断势的系统的性质。它们不是用于生成和接受构象的势能 $U(\\mathbf{x})$ 的一部分。此外，由于模型是由截断势定义的，因此不需要补偿。\n- 理由也是不正确的。试验选择本质上是*有偏的*；接受步骤中的 Rosenbluth 因子确保了整个移动是正确的（从长远来看是无偏的）。平均场项与此过程无关。\n- **结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在确定了用于偏置选择的能量之后，下一步是计算所有试探构象的权重之和，即罗森布鲁斯权重。这个计算在数值上极具挑战性，因为直接对能量的指数求和很容易导致浮点数上溢或下溢，从而产生严重错误。本练习将引导你应用“log-sum-exp”技巧来稳定地计算罗森布鲁斯权重，这是任何可靠的CBMC代码实现中都必不可少的一步。()",
            "id": "3745270",
            "problem": "考虑构象偏置蒙特卡洛（CBMC）中的一个聚合物增长步骤，其中一个单体将通过从 $k$ 个试探位置中抽样来放置。对于链段 $i$ 的第 $j$ 次试探，设能量增量变化为 $\\Delta U_i^{(j)}$，以热能为单位进行测量，因此它是玻尔兹曼常数乘以温度 $k_{\\mathrm{B}} T$ 的无量纲倍数，从而逆热能为 $\\beta = 1$。链段 $i$ 的 Rosenbluth 和（也称为 Rosenbluth 因子）定义为 $w_i = \\sum_{j=1}^{k} \\exp\\!\\left(-\\beta \\,\\Delta U_i^{(j)}\\right)$，相应的归一化抽样概率对于第 $j$ 次试探为 $p_i^{(j)} = \\exp\\!\\left(-\\beta \\,\\Delta U_i^{(j)}\\right) / w_i$。在多尺度建模与分析中，CBMC 依赖于对 $w_i$ 的正确评估来进行接受决策和偏差校正。从统计力学出发，利用玻尔兹曼权重原理，即一个构象的相对权重与 $\\exp\\!\\left(-\\beta U\\right)$ 成正比，从第一性原理证明 $w_i$ 和 $p_i^{(j)}$ 的形式。然后分析当 $\\Delta U_i^{(j)}$ 的量级很大时出现的浮点数陷阱，重点关注当 $\\Delta U_i^{(j)}$ 为大的正数时（导致 $\\exp\\!\\left(-\\beta \\,\\Delta U_i^{(j)}\\right)$ 极小）发生的下溢，以及当 $\\Delta U_i^{(j)}$ 为大的负数时（导致 $\\exp\\!\\left(-\\beta \\,\\Delta U_i^{(j)}\\right)$ 极大）发生的上溢。使用 log-sum-exp 恒等式推导一个数值稳定的 $\\log w_i$ 表达式。从 $x_j = -\\beta \\,\\Delta U_i^{(j)}$ 开始，展示如何计算\n$$\n\\log w_i = m + \\log\\!\\left(\\sum_{j=1}^{k} \\exp(x_j - m)\\right), \\quad \\text{其中 } m = \\max_{1 \\le j \\le k} x_j,\n$$\n并解释为什么用这种方法计算 $\\log w_i$ 可以避免中间指数项的上溢和下溢。解释如何从 $\\log w_i$ 恢复 $w_i$，以及如何检测当 $\\log w_i$ 超过使 $\\exp(\\log w_i)$ 上溢的阈值时，$w_i$ 本身无法用双精度浮点数表示的情况。利用这些推导设计一个算法，给定一个试探能量差列表 $\\Delta U_i^{(j)}$（无量纲，以 $k_{\\mathrm{B}} T$ 为单位，因此 $\\beta = 1$），为每个集合生成：\n- 通过 $\\log w_i$ 计算的稳定化 Rosenbluth 和 $w_i$；如果 $\\log w_i$ 大于最大可表示浮点数的自然对数，则为 $w_i$ 返回 $+\\infty$。\n- 稳定化的对数 $\\log w_i$。\n- 一个布尔值，指示直接朴素求和 $\\sum_j \\exp\\!\\left(-\\beta \\,\\Delta U_i^{(j)}\\right)$ 的结果是否在 $10^{-12}$ 的相对容差内与稳定化的 $w_i$ 匹配，或者两者都为 $+\\infty$，或者两者都恰好为 $0.0$。\n\n您的程序必须实现此算法，并将其应用于以下试探能量差列表的测试套件，每个列表都表示为以 $k_{\\mathrm{B}} T$ 为单位的 $\\Delta U$ 值（无量纲）：\n- 案例1（中等值，正常路径）：$\\left[ -0.1, 0.0, 0.2, 0.5 \\right]$。\n- 案例2（单个项下溢但和为有限值）：$\\left[ 100.0, 800.0, 1000.0 \\right]$。\n- 案例3（朴素指数计算中上溢）：$\\left[ -800.0, -1000.0, -1200.0 \\right]$。\n- 案例4（混合极端值）：$\\left[ -1000.0, 0.0, 1000.0 \\right]$。\n- 案例5（单次试探边界情况）：$\\left[ 0.0 \\right]$。\n- 案例6（跨越负值到正值的大集合）：一个包含100个从 $-50.0$ 到 $50.0$（含两端）线性间隔的值的列表。\n- 案例7（极端负值）：$\\left[ -1500.0, -1400.0 \\right]$。\n\n最终输出格式必须是单行，由方括号括起来的逗号分隔列表组成。每个元素对应一个测试案例，并且本身必须是 $[w_i, \\log w_i, \\text{eq}]$ 形式的列表，其中 $w_i$ 和 $\\log w_i$ 是浮点数（如果检测到上溢，则用 Python 字符串 `inf` 表示 $+\\infty$），`eq` 是一个布尔值。例如，整体输出应类似于 $[[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot],\\ldots]$，除了逗号外没有额外的空白字符。本问题不涉及角度；不需要角度单位。由于所有能量都以 $k_{\\mathrm{B}} T$ 为单位给出，因此输出是无量纲的，不需要物理单位。\n\n您的任务是生成一个完整、可运行的程序，对给定的测试套件精确执行这些计算，并仅按所述格式打印单行输出。",
            "solution": "构象偏置蒙特卡洛（CBMC）的基础是统计力学中的玻尔兹曼分布，该分布指出，在逆温 $\\beta$ 下，能量为 $U$ 的微观状态的相对概率与 $\\exp\\!\\left(-\\beta U\\right)$ 成正比。在 CBMC 聚合物增长中，对于链段 $i$，我们提出 $k$ 个试探位置，其相对于某个参考态的能量增量变化为 $\\Delta U_i^{(j)}$。根据玻尔兹曼原理，第 $j$ 次试探的未归一化权重直接得出为 $\\exp\\!\\left(-\\beta \\Delta U_i^{(j)}\\right)$。对 $k$ 个选项进行归一化，得到抽样概率\n$$\np_i^{(j)} = \\frac{\\exp\\!\\left(-\\beta \\Delta U_i^{(j)}\\right)}{\\sum_{\\ell=1}^{k} \\exp\\!\\left(-\\beta \\Delta U_i^{(\\ell)}\\right)},\n$$\n其中分母是 Rosenbluth 和\n$$\nw_i = \\sum_{j=1}^{k} \\exp\\!\\left(-\\beta \\Delta U_i^{(j)}\\right).\n$$\n这个定义是经过充分检验的玻尔兹曼权重原理的直接推论，并且当与多尺度建模中再生长移动的适当接受准则相结合时，可确保细致平衡。\n\n在实现 $w_i$ 时，朴素的计算方法可能会在数值上失败：\n- 如果 $\\Delta U_i^{(j)}$ 是大的正数，那么 $-\\beta \\Delta U_i^{(j)}$ 是大的负数，因此 $\\exp\\!\\left(-\\beta \\Delta U_i^{(j)}\\right)$ 在双精度计算中可能会下溢到 $0.0$。\n- 如果 $\\Delta U_i^{(j)}$ 是大的负数，那么 $-\\beta \\Delta U_i^{(j)}$ 是大的正数，因此 $\\exp\\!\\left(-\\beta \\Delta U_i^{(j)}\\right)$ 可能会上溢到 $+\\infty$。\n\n如果直接将指数项求和来计算总和，单个项的下溢或上溢可能会使 $w_i$ 的计算无效。为了稳定计算，定义 $x_j = -\\beta \\,\\Delta U_i^{(j)}$ 并设 $m = \\max_j x_j$。然后从和式中提出因子 $\\exp(m)$：\n$$\nw_i = \\sum_{j=1}^{k} \\exp(x_j) = \\exp(m) \\sum_{j=1}^{k} \\exp(x_j - m).\n$$\n对两边取自然对数，得到 log-sum-exp 恒等式：\n$$\n\\log w_i = m + \\log\\!\\left(\\sum_{j=1}^{k} \\exp(x_j - m)\\right).\n$$\n这个表达式在数值上是稳定的，原因有二。首先，所有的指数 $(x_j - m)$ 都 $\\le 0$，所以 $\\exp(x_j - m) \\in (0,1]$，这消除了内部指数项的上溢。其次，在朴素计算中会下溢的项变得非常小，但在取对数之前，它们在和式内部被安全地累加。唯一剩下的风险是，当 $\\log w_i$ 本身过大，以至于在转换回 $w_i$ 时，$\\exp(\\log w_i)$ 无法用双精度浮点数表示。\n\n要从 $\\log w_i$ 恢复 $w_i$，如果 $\\log w_i$ 低于上溢阈值，则计算 $w_i = \\exp(\\log w_i)$。对于 IEEE $754$ 双精度浮点数，最大的有限浮点数约为 $1.7976931348623157 \\times 10^{308}$，指数函数的阈值大约为 $\\log(1.7976931348623157 \\times 10^{308}) \\approx 709.782712893384$。因此，如果 $\\log w_i  \\log(\\text{max float})$，我们应该返回 $+\\infty$ 来表示 $w_i$ 发生了上溢，即使 $\\log w_i$ 是有限的。\n\n算法设计：\n1. 输入是 $\\Delta U_i^{(j)}$ 列表，全部是无量纲的，以 $k_{\\mathrm{B}} T$ 为单位，这意味着 $\\beta = 1$。\n2. 对每个列表，计算 $x_j = -\\beta \\,\\Delta U_i^{(j)}$，即 $x_j = -\\Delta U_i^{(j)}$。\n3. 计算 $m = \\max_j x_j$，然后在双精度下计算 $s = \\sum_j \\exp(x_j - m)$。计算 $\\log w_i = m + \\log(s)$。\n4. 如果 $\\log w_i$ 超过阈值 $\\log(\\text{max float})$，则设置 $w_i = +\\infty$；否则设置 $w_i = \\exp(\\log w_i)$。\n5. 为了比较，计算朴素和 $w_i^{\\text{naive}} = \\sum_j \\exp(x_j)$，由于单个项的下溢或上溢，其结果可能是 $0.0$、有限值或 $+\\infty$。\n6. 定义一个等价性检查：\n   - 如果 $w_i$ 和 $w_i^{\\text{naive}}$ 都是 $+\\infty$，返回真。\n   - 否则，如果两者都恰好为 $0.0$，返回真。\n   - 否则，如果两者都是有限值，检查相对一致性 $\\left|w_i - w_i^{\\text{naive}}\\right| / \\max(1.0, |w_i|, |w_i^{\\text{naive}}|) \\le 10^{-12}$，如果满足则返回真。\n   - 否则返回假。\n7. 对每个测试案例，输出三元组 $\\left[w_i, \\log w_i, \\text{eq}\\right]$。\n8. 将所有三元组聚合到一个列表中，以要求的格式（用逗号分隔，无多余空格）打印为单行。\n\n测试套件分析：\n- 案例1：中等值产生一个良态和；朴素和稳定化方法结果一致。\n- 案例2：某些指数项会单独下溢为零（例如 $\\exp(-800)$ 和 $\\exp(-1000)$），但最大的项 $\\exp(-100)$ 是有限的；稳定化和朴素方法结果一致，表明如果主导项是可表示的，小贡献项的下溢不会破坏求和结果。\n- 案例3：极端的负 $\\Delta U$ 值产生像 $\\exp(800)$ 这样的指数，导致上溢；朴素和返回 $+\\infty$。稳定化的 $\\log w_i$ 是有限的（接近 $800$），但 $w_i$ 必须报告为 $+\\infty$，因为 $\\exp(\\log w_i)$ 无法表示；由于两者都为 $+\\infty$，等价性为真。\n- 案例4：混合极端值包括朴素指数计算中的上溢和下溢；稳定化处理产生有限的 $\\log w_i$ 和 $w_i = +\\infty$；等价性成立。\n- 案例5：单个元素给出 $w_i = \\exp(0) = 1.0$ 的精确值。\n- 案例6：从 $-50.0$ 到 $50.0$ 的范围产生一个大但有限的和；稳定化和朴素方法结果一致。\n- 案例7：更极端的负值确保朴素指数计算上溢且 $w_i = +\\infty$；稳定化的 $\\log w_i$ 是有限且大的；等价性成立。\n\n此过程通过玻尔兹曼权重遵循第一性原理，使用经过充分检验的数值稳定化策略，并为指定的测试套件生成确定性的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef log_sum_exp(x: np.ndarray) - float:\n    \"\"\"\n    Compute log(sum(exp(x))) in a numerically stable manner.\n    Returns a Python float.\n    \"\"\"\n    # Handle empty input defensively (not expected in this problem)\n    if x.size == 0:\n        return -np.inf\n    # Use max trick\n    m = np.max(x)\n    # If m is -inf (all entries -inf), then sum exp(x - m) is 0 - log is -inf\n    if not np.isfinite(m):\n        # If any finite exists, np.max would be finite; here m is -inf = all -inf\n        return -np.inf\n    # Compute the sum of exponentials of shifted values\n    s = np.sum(np.exp(x - m))\n    # s should be = 1.0 if at least one finite term exists\n    return float(m + np.log(s))\n\ndef stable_rosenbluth(dU: np.ndarray, beta: float = 1.0):\n    \"\"\"\n    Given an array of Delta U values (dimensionless, in units of k_B T),\n    compute the stabilized Rosenbluth sum w and its logarithm log_w.\n    Also compute the naive sum for comparison.\n    \"\"\"\n    # Convert to exponent arguments x = -beta * dU\n    x = -beta * dU\n    # Stabilized log-sum-exp\n    log_w = log_sum_exp(x)\n    # Determine overflow threshold for exp\n    log_max = np.log(np.finfo(np.float64).max)\n    if log_w  log_max:\n        w = float('inf')\n    else:\n        w = float(np.exp(log_w))\n    # Naive sum (may underflow/overflow)\n    with np.errstate(over='ignore'):\n        exp_x = np.exp(x)\n        naive_w = float(np.sum(exp_x))\n    return w, log_w, naive_w\n\ndef compare_w(w: float, naive_w: float, rtol: float = 1e-12) - bool:\n    \"\"\"\n    Compare stabilized w with naive w using relative tolerance,\n    accounting for infinities and exact zeros.\n    \"\"\"\n    if np.isinf(w) and np.isinf(naive_w):\n        return True\n    if w == 0.0 and naive_w == 0.0:\n        return True\n    if np.isfinite(w) and np.isfinite(naive_w):\n        denom = max(1.0, abs(w), abs(naive_w))\n        rel_err = abs(w - naive_w) / denom\n        return rel_err = rtol\n    return False\n\ndef format_value(val):\n    \"\"\"\n    Format a value (float, bool, list/tuple) without spaces, as required.\n    \"\"\"\n    if isinstance(val, (list, tuple)):\n        return \"[\" + \",\".join(format_value(v) for v in val) + \"]\"\n    if isinstance(val, (np.floating, float)):\n        if np.isinf(val):\n            return \"inf\"\n        # Use repr for a compact precise representation\n        return repr(float(val))\n    if isinstance(val, (np.bool_, bool)):\n        return \"True\" if bool(val) else \"False\"\n    # Fallback for integers if any appear\n    if isinstance(val, (np.integer, int)):\n        return str(int(val))\n    # Fallback: convert to string\n    return str(val)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # All energies are dimensionless in units of k_B T (beta = 1).\n    test_cases = [\n        [-0.1, 0.0, 0.2, 0.5],               # Case 1\n        [100.0, 800.0, 1000.0],              # Case 2\n        [-800.0, -1000.0, -1200.0],          # Case 3\n        [-1000.0, 0.0, 1000.0],              # Case 4\n        [0.0],                               # Case 5\n        list(np.linspace(-50.0, 50.0, 100)), # Case 6\n        [-1500.0, -1400.0],                  # Case 7\n    ]\n\n    beta = 1.0  # energies are in k_B T units\n    results = []\n    for case in test_cases:\n        dU = np.array(case, dtype=np.float64)\n        w, log_w, naive_w = stable_rosenbluth(dU, beta=beta)\n        eq = compare_w(w, naive_w, rtol=1e-12)\n        results.append([w, log_w, eq])\n\n    # Final print statement in the exact required format: single line, no extra spaces.\n    print(format_value(results))\n\nsolve()\n```"
        },
        {
            "introduction": "一个正确的蒙特卡洛算法必须满足细致平衡条件，以确保它能够从目标概率分布（如玻尔兹曼分布）中进行正确抽样。虽然理论推导是必要的，但通过数值模拟来验证这一基本原理也同样重要，这可以帮助我们捕捉到实现中可能存在的微妙错误。这个高级练习将指导你为一个简化的CBMC过程设计并实施一个数值测试，通过统计分析模拟过程中产生的跃迁，来验证细致平衡条件是否得到满足。()",
            "id": "3745237",
            "problem": "考虑一个方格点阵上的两步聚合物链，其步长限制在集合 $\\{\\text{U},\\text{R}\\}$ 内。一个链构型是两步的序列，产生四种可能的状态：$\\text{UU}$、$\\text{UR}$、$\\text{RU}$ 和 $\\text{RR}$。状态 $x$ 的链能量 $U(x)$ 定义为每步的方向能量与施加在第二步上的弯曲罚项之和。具体而言，设第一步的方向能量为 $\\varepsilon_{\\text{U}} = 0$ 和 $\\varepsilon_{\\text{R}} = 0.5$。对于第二步，如果第二步与第一步相同，则增加一个为 $0$ 的弯曲罚项；如果不同，则为 $1$。总能量则为\n$$\nU(x) = \\varepsilon_{d_1} + \\varepsilon_{d_2} + \\text{bend}(d_1,d_2),\n$$\n其中 $x = (d_1,d_2)$ 且 $d_1,d_2 \\in \\{\\text{U},\\text{R}\\}$，并且如果 $d_2 = d_1$，则 $\\text{bend}(d_1,d_2) = 0$，否则为 $1$。\n\n设目标平稳分布为逆温度 $\\beta$ 下的正则玻尔兹曼分布，其定义（不计归一化常数 $Z$）为\n$$\n\\pi(x) = \\frac{1}{Z}\\exp\\big(-\\beta U(x)\\big).\n$$\n使用马尔可夫链蒙特卡罗（MCMC）算法，通过一种受构型偏置蒙特卡罗（CBMC）启发的再生长移动，从 $\\pi(x)$ 中采样。CBMC 提议使用 Rosenbluth 加权分两个阶段生成链：\n- 在第一步，以与 $\\exp\\big(-\\beta \\varepsilon_{d_1}\\big)$ 成正比的概率抽取 $d_1 \\in \\{\\text{U},\\text{R}\\}$，归一化因子为\n$$\nW_1 = \\exp\\big(-\\beta \\varepsilon_{\\text{U}}\\big) + \\exp\\big(-\\beta \\varepsilon_{\\text{R}}\\big).\n$$\n- 在第二步，给定 $d_1$，以与 $\\exp\\big(-\\beta(\\varepsilon_{d_2} + \\text{bend}(d_1,d_2))\\big)$ 成正比的概率抽取 $d_2 \\in \\{\\text{U},\\text{R}\\}$，归一化因子为\n$$\nW_2(d_1) = \\exp\\big(-\\beta(\\varepsilon_{\\text{U}} + \\text{bend}(d_1,\\text{U}))\\big) + \\exp\\big(-\\beta(\\varepsilon_{\\text{R}} + \\text{bend}(d_1,\\text{R}))\\big).\n$$\n这产生了一个提议分布 $q(x)$，其与 $\\exp\\big(-\\beta U(x)\\big)/(W_1 W_2(d_1))$ 成正比。\n\n使用 Metropolis-Hastings 原理，根据上述 CBMC 提议结构，推导一个能确保相对于 $\\pi(x)$ 满足细致平衡的接受概率。然后，通过估计比率\n$$\nR(x,x') = \\frac{\\pi(x) P(x \\to x')}{\\pi(x') P(x' \\to x)},\n$$\n来实现细致平衡的数值验证，其中 $P(x \\to x')$ 是所构建的马尔可夫链下的单步转移概率。该估计必须从长模拟中的采样转移中获得。您必须：\n- 精确地实现所述的 CBMC 提议机制。\n- 在一个关于四个状态 $\\{\\text{UU},\\text{UR},\\text{RU},\\text{RR}\\}$ 的离散时间马尔可夫链中，使用推导出的接受概率执行再生长移动。\n- 根据采样得到的转移，将 $P(x \\to x')$ 估计为从状态 $x$ 到状态 $x'$ 的接受转移次数除以在状态 $x$ 时所做的提议次数。为确保稳健性，请使用 Jeffreys 平滑估计量\n$$\n\\widehat{P}(x \\to x') = \\frac{K(x \\to x') + 0.5}{N(x) + 1},\n$$\n其中 $N(x)$ 是当链处于状态 $x$ 时尝试提议的次数，而 $K(x \\to x')$ 是从 $x$ 到 $x'$ 的接受转移次数。\n- 构建经验比率\n$$\n\\widehat{R}(x,x') = \\frac{\\pi(x) \\widehat{P}(x \\to x')}{\\pi(x') \\widehat{P}(x' \\to x)} = \\exp\\big(-\\beta(U(x) - U(x'))\\big)\\cdot \\frac{\\widehat{P}(x \\to x')}{\\widehat{P}(x' \\to x)}.\n$$\n- 使用 delta 方法对二项比例进行近似，将 $\\log \\widehat{P}$ 视为近似正态分布，为 $\\log \\widehat{R}(x,x')$ 构建一个 $95\\%$ 的置信区间：\n$$\n\\operatorname{Var}\\big(\\log \\widehat{P}(x \\to x')\\big) \\approx \\frac{1 - \\widehat{P}(x \\to x')}{\\widehat{P}(x \\to x')\\cdot (N(x) + 1)}.\n$$\n假设正向和反向估计之间相互独立，并将方差相加来近似 $\\operatorname{Var}\\big(\\log \\widehat{R}(x,x')\\big)$。然后将置信区间转换回原始尺度，以检验其是否包含 $1$。\n\n您的程序必须运行三个测试用例，这些用例在逆温度 $\\beta$、样本长度和状态对 $(x,x')$ 上有所不同：\n- 测试用例 1：$\\beta = 1.0$，提议数 $N_{\\text{sim}} = 200000$，对 $(x,x') = (\\text{UU},\\text{UR})$。\n- 测试用例 2：$\\beta = 0.1$，提议数 $N_{\\text{sim}} = 100000$，对 $(x,x') = (\\text{RR},\\text{RU})$。\n- 测试用例 3：$\\beta = 3.0$，提议数 $N_{\\text{sim}} = 150000$，对 $(x,x') = (\\text{UU},\\text{RR})$。\n\n对于每个测试用例，返回一个布尔值，指示 $\\widehat{R}(x,x')$ 的 $95\\%$ 置信区间是否包含 $1$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[true,false,true]”，但使用 Python布尔值的大小写），严格按照上面列出的测试用例的顺序。不涉及物理单位；所有量纲均为无量纲。不使用角度。不得使用百分比；所有分数量必须表示为小数。",
            "solution": "该问题要求推导用于构型偏置蒙特卡罗（CBMC）再生长移动的 Metropolis-Hastings 接受概率，并随后对细致平衡条件进行数值验证。\n\n首先，我们建立理论基础。马尔可夫链蒙特卡罗（MCMC）模拟的目标是生成一系列从正则玻尔兹曼分布 $\\pi(x) \\propto \\exp(-\\beta U(x))$ 中抽样的状态 $x$，其中 $U(x)$ 是状态 $x$ 的能量，$\\beta$ 是逆温度。要使链的平稳分布为 $\\pi(x)$，一个充分条件是细致平衡原理，该原理指出对于任何两个状态 $x$ 和 $x'$，稳态下的转移速率必须相等：\n$$\n\\pi(x) P(x \\to x') = \\pi(x') P(x' \\to x)\n$$\n此处，$P(x \\to x')$ 是从状态 $x$到状态 $x'$的单步转移概率。在 Metropolis-Hastings 算法中，此转移概率是提议概率 $q(x \\to x')$ 和接受概率 $A(x \\to x')$ 的乘积：$P(x \\to x') = q(x \\to x') A(x \\to x')$。接受概率旨在强制满足细致平衡，并由以下公式给出：\n$$\nA(x \\to x') = \\min\\left(1, \\frac{\\pi(x') q(x' \\to x)}{\\pi(x) q(x \\to x')}\\right)\n$$\n\n该系统由一个两步聚合物链组成，步长方向为 $d_1, d_2 \\in \\{\\text{U}, \\text{R}\\}$。四种可能的状态是 $x_{\\text{UU}}=(\\text{U},\\text{U})$、$x_{\\text{UR}}=(\\text{U},\\text{R})$、$x_{\\text{RU}}=(\\text{R},\\text{U})$ 和 $x_{\\text{RR}}=(\\text{R},\\text{R})$。能量函数为 $U(x) = \\varepsilon_{d_1} + \\varepsilon_{d_2} + \\text{bend}(d_1,d_2)$，其中 $\\varepsilon_{\\text{U}}=0$，$\\varepsilon_{\\text{R}}=0.5$，并且当 $d_1 \\neq d_2$ 时弯曲罚项 $\\text{bend}(d_1, d_2)$ 为 $1$，否则为 $0$。这四个状态的能量为：\n- $U(x_{\\text{UU}}) = \\varepsilon_{\\text{U}} + \\varepsilon_{\\text{U}} + \\text{bend}(\\text{U},\\text{U}) = 0 + 0 + 0 = 0$\n- $U(x_{\\text{UR}}) = \\varepsilon_{\\text{U}} + \\varepsilon_{\\text{R}} + \\text{bend}(\\text{U},\\text{R}) = 0 + 0.5 + 1 = 1.5$\n- $U(x_{\\text{RU}}) = \\varepsilon_{\\text{R}} + \\varepsilon_{\\text{U}} + \\text{bend}(\\text{R},\\text{U}) = 0.5 + 0 + 1 = 1.5$\n- $U(x_{\\text{RR}}) = \\varepsilon_{\\text{R}} + \\varepsilon_{\\text{R}} + \\text{bend}(\\text{R},\\text{R}) = 0.5 + 0.5 + 0 = 1.0$\n\n提议机制是链的完全再生长。这意味着提议状态 $x'$ 是从头开始生成的，独立于当前状态 $x$。因此，提议分布 $q(x \\to x')$ 仅是提议状态 $x'$ 的函数，我们称之为 $g(x')$。生成一个特定新链 $x'=(d'_1, d'_2)$ 的概率是选择每一步的概率之积，由 CBMC 过程定义如下：\n$$\ng(x') = \\left( \\frac{\\exp(-\\beta \\varepsilon_{d'_1})}{W_1} \\right) \\left( \\frac{\\exp(-\\beta(\\varepsilon_{d'_2} + \\text{bend}(d'_1, d'_2)))}{W_2(d'_1)} \\right)\n$$\n其中 $W_1$ 和 $W_2(d'_1)$ 分别是第一和第二生长阶段的 Rosenbluth 权重。合并各项，我们得到 $g(x') = \\frac{\\exp(-\\beta U(x'))}{W_1 W_2(d'_1)}$。我们将生成构型 $x'=(d'_1, d'_2)$ 的总 Rosenbluth 权重定义为 $W(x') = W_1 W_2(d'_1)$。因此，提议概率为 $g(x') = \\exp(-\\beta U(x')) / W(x')$。\n\n对于此独立采样器，$q(x \\to x') = g(x')$ 且逆向提议概率为 $q(x' \\to x) = g(x)$。将这些以及 $\\pi(x) \\propto \\exp(-\\beta U(x))$ 代入 Metropolis-Hastings 接受准则：\n$$\nA(x \\to x') = \\min\\left(1, \\frac{\\exp(-\\beta U(x')) g(x)}{\\exp(-\\beta U(x)) g(x')}\\right) = \\min\\left(1, \\frac{\\exp(-\\beta U(x')) [\\exp(-\\beta U(x))/W(x)]}{\\exp(-\\beta U(x)) [\\exp(-\\beta U(x'))/W(x')]}\\right)\n$$\n$$\nA(x \\to x') = \\min\\left(1, \\frac{W(x')}{W(x)}\\right)\n$$\n这是 CBMC 完全再生长移动的标准接受概率。构型 $x=(d_1, d_2)$ 的 Rosenbluth 权重为 $W(x) = W_1 W_2(d_1)$。\n$W_1 = \\exp(-\\beta \\varepsilon_{\\text{U}}) + \\exp(-\\beta \\varepsilon_{\\text{R}}) = 1 + \\exp(-0.5\\beta)$。\n第二阶段的权重 $W_2(d_1)$ 取决于第一步 $d_1$：\n- 对于 $d_1 = \\text{U}$：$W_2(\\text{U}) = \\exp(-\\beta(\\varepsilon_{\\text{U}} + 0)) + \\exp(-\\beta(\\varepsilon_{\\text{R}} + 1)) = 1 + \\exp(-\\beta(0.5+1)) = 1 + \\exp(-1.5\\beta)$。\n- 对于 $d_1 = \\text{R}$：$W_2(\\text{R}) = \\exp(-\\beta(\\varepsilon_{\\text{U}} + 1)) + \\exp(-\\beta(\\varepsilon_{\\text{R}} + 0)) = \\exp(-\\beta) + \\exp(-0.5\\beta)$。\n由于 $W(x')/W(x) = (W_1 W_2(d'_1))/(W_1 W_2(d_1)) = W_2(d'_1)/W_2(d_1)$，接受概率简化为：\n$$\nA(x \\to x') = \\min\\left(1, \\frac{W_2(d'_1)}{W_2(d_1)}\\right)\n$$\n其中 $d_1$ 是旧状态 $x$ 的第一步，$d'_1$ 是提议状态 $x'$ 的第一步。\n\n为了对细致平衡进行数值验证，我们对马尔可夫链进行大量步数 $N_{\\text{sim}}$ 的模拟。我们记录从每个状态 $x$ 提出提议的次数，记为 $N(x)$，以及从 $x$ 到 $x'$ 的接受转移次数，记为 $K(x \\to x')$。转移概率 $P(x \\to x')$ 使用 Jeffreys 平滑估计量进行估计：\n$$\n\\widehat{P}(x \\to x') = \\frac{K(x \\to x') + 0.5}{N(x) + 1}\n$$\n细致平衡要求 $\\pi(x) P(x \\to x') = \\pi(x') P(x' \\to x)$，或等效地，比率 $R(x,x') = \\frac{\\pi(x) P(x \\to x')}{\\pi(x') P(x' \\to x)}$ 必须等于 $1$。我们通过构建经验比率来检验这一点：\n$$\n\\widehat{R}(x,x') = \\frac{\\pi(x) \\widehat{P}(x \\to x')}{\\pi(x') \\widehat{P}(x' \\to x)} = \\frac{\\exp(-\\beta U(x)) \\widehat{P}(x \\to x')}{\\exp(-\\beta U(x')) \\widehat{P}(x' \\to x)} = \\exp\\big(-\\beta(U(x) - U(x'))\\big)\\cdot \\frac{\\widehat{P}(x \\to x')}{\\widehat{P}(x' \\to x)}\n$$\n我们在对数空间中分析此比率，因为这将乘积转换为求和，从而简化了方差计算。对数比率为 $\\log\\widehat{R}(x,x') = -\\beta(U(x) - U(x')) + \\log\\widehat{P}(x \\to x') - \\log\\widehat{P}(x' \\to x)$。我们在 $0.95$ 置信水平下为 $\\log\\widehat{R}(x,x')$ 构建一个置信区间。概率估计量对数的方差使用 delta 方法进行近似，具体如下：\n$$\n\\operatorname{Var}\\big(\\log \\widehat{P}(x \\to x')\\big) \\approx \\frac{1 - \\widehat{P}(x \\to x')}{\\widehat{P}(x \\to x')\\cdot (N(x) + 1)}\n$$\n假设正向和反向转移估计是独立的，它们的方差相加：$\\operatorname{Var}(\\log \\widehat{R}) \\approx \\operatorname{Var}(\\log \\widehat{P}(x \\to x')) + \\operatorname{Var}(\\log \\widehat{P}(x' \\to x))$。$\\log\\widehat{R}$ 的置信区间为 $[\\log\\widehat{R} - z_{0.975} \\sigma_{\\log\\widehat{R}}, \\log\\widehat{R} + z_{0.975} \\sigma_{\\log\\widehat{R}}]$，其中 $\\sigma_{\\log\\widehat{R}}$ 是标准差，而 $z_{0.975} \\approx 1.96$ 是标准正态分布的临界值。如果该区间包含 $0$，则认为细致平衡得到验证，这等效于 $\\widehat{R}$ 的置信区间包含 $1$。\n\n实现将首先为 4 个状态设置常量。然后，对每个测试用例，它将运行 MCMC 模拟。在每一步中，通过两阶段 CBMC 生长过程提出一个新状态，使用 $W_2$ 权重的比率计算接受概率，并决定接受或拒绝该移动。$N(x)$ 和 $K(x \\to x')$ 的计数器会相应更新。模拟结束后，对指定的配对 $(x, x')$ 进行统计分析，以确定对数比率的置信区间是否包含 $0$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the problem by running simulations for three test cases\n    and checking the detailed balance condition.\n    \"\"\"\n    test_cases = [\n        (1.0, 200000, ('UU', 'UR')),\n        (0.1, 100000, ('RR', 'RU')),\n        (3.0, 150000, ('UU', 'RR')),\n    ]\n\n    results = []\n    for beta, n_sim, pair in test_cases:\n        result = run_and_analyze_case(beta, n_sim, pair)\n        results.append(result)\n\n    # Format the final output as a string using Python's boolean capitalization.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_and_analyze_case(beta, n_sim, pair):\n    \"\"\"\n    Runs a single test case simulation and performs the statistical analysis.\n    \"\"\"\n    # State mapping and properties\n    states_map = {'UU': 0, 'UR': 1, 'RU': 2, 'RR': 3}\n    inv_states_map = {v: k for k, v in states_map.items()}\n    energies = np.array([0.0, 1.5, 1.5, 1.0])\n    first_steps = ['U', 'U', 'R', 'R']  # d_1 for each state index\n\n    # Pre-calculate values dependent on beta\n    exp_m05b = np.exp(-0.5 * beta)\n    exp_m10b = np.exp(-1.0 * beta)\n    exp_m15b = np.exp(-1.5 * beta)\n    \n    # Rosenbluth weights for the second step\n    w2_vals = {\n        'U': 1.0 + exp_m15b,\n        'R': exp_m10b + exp_m05b\n    }\n\n    # Proposal probabilities for CBMC regrowth\n    p_d1_U = 1.0 / (1.0 + exp_m05b)\n    p_d2_U_given_d1_U = 1.0 / w2_vals['U']\n    p_d2_U_given_d1_R = exp_m10b / w2_vals['R']\n\n    def propose_new_state():\n        # Step 1: Propose d1\n        d1_prime = 'U' if np.random.rand()  p_d1_U else 'R'\n        \n        # Step 2: Propose d2\n        if d1_prime == 'U':\n            d2_prime = 'U' if np.random.rand()  p_d2_U_given_d1_U else 'R'\n        else:  # d1_prime == 'R'\n            d2_prime = 'U' if np.random.rand()  p_d2_U_given_d1_R else 'R'\n            \n        return states_map[d1_prime + d2_prime]\n\n    # MCMC Simulation\n    # Start at an arbitrary state (e.g., UU)\n    current_state_idx = states_map['UU']\n    # N(x): number of proposals from state x\n    N_counts = np.zeros(4, dtype=np.int64)\n    # K(x -> x'): number of accepted transitions\n    K_counts = np.zeros((4, 4), dtype=np.int64)\n\n    for _ in range(n_sim):\n        old_state_idx = current_state_idx\n        N_counts[old_state_idx] += 1\n\n        proposed_state_idx = propose_new_state()\n        \n        # Acceptance probability: min(1, W2(d'_1) / W2(d_1))\n        d1_old = first_steps[old_state_idx]\n        d1_new = first_steps[proposed_state_idx]\n        \n        w2_old = w2_vals[d1_old]\n        w2_new = w2_vals[d1_new]\n\n        acceptance_prob = min(1.0, w2_new / w2_old)\n\n        if np.random.rand()  acceptance_prob:\n            # Accept the move\n            current_state_idx = proposed_state_idx\n            K_counts[old_state_idx, proposed_state_idx] += 1\n        else:\n            # Reject the move, stay in the same state\n            # The transition is to the same state\n            K_counts[old_state_idx, old_state_idx] += 1\n            # current_state_idx remains old_state_idx\n\n    # Post-simulation analysis for the specified pair (x, x')\n    x_name, xp_name = pair\n    x_idx, xp_idx = states_map[x_name], states_map[xp_name]\n\n    # Jeffreys smoothed estimators for transition probabilities\n    # Here, P(x -> x') is the total transition prob, estimated by accepted moves / total proposals\n    N_x = N_counts[x_idx]\n    N_xp = N_counts[xp_idx]\n    \n    # We are interested in the transition prob between two DISTINCT states\n    # K_counts already stores the accepted transitions, including self-transitions on rejection\n    # The P(x->x') in the detailed balance is for x != x'\n    K_x_to_xp = K_counts[x_idx, xp_idx]\n    K_xp_to_x = K_counts[xp_idx, x_idx]\n    \n    # +1 ensures no division by zero if a state is never visited\n    p_hat_fwd = (K_x_to_xp + 0.5) / (N_x + 1)\n    p_hat_rev = (K_xp_to_x + 0.5) / (N_xp + 1)\n    \n    # Handle case where a probability is zero (or near-zero), making log infinite\n    if p_hat_fwd = 0 or p_hat_rev = 0:\n        return False\n\n    # Log of the empirical ratio R_hat\n    U_x = energies[x_idx]\n    U_xp = energies[xp_idx]\n    log_R_hat = -beta * (U_x - U_xp) + np.log(p_hat_fwd) - np.log(p_hat_rev)\n\n    # Variance of log_R_hat using the provided formula\n    var_log_p_fwd = (1.0 - p_hat_fwd) / (p_hat_fwd * (N_x + 1.0))\n    var_log_p_rev = (1.0 - p_hat_rev) / (p_hat_rev * (N_xp + 1.0))\n    \n    var_log_R_hat = var_log_p_fwd + var_log_p_rev\n    std_log_R_hat = np.sqrt(var_log_R_hat)\n    \n    # Construct 95% CI for log(R_hat)\n    z_score = norm.ppf(0.975)  # for 95% confidence\n    ci_lower = log_R_hat - z_score * std_log_R_hat\n    ci_upper = log_R_hat + z_score * std_log_R_hat\n    \n    # Check if the CI for log(R) contains 0 (which means CI for R contains 1)\n    return (ci_lower = 0) and (ci_upper >= 0)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}