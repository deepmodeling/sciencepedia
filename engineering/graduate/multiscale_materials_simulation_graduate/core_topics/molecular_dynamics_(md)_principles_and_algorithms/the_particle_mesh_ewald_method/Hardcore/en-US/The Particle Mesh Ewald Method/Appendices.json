{
    "hands_on_practices": [
        {
            "introduction": "The Particle Mesh Ewald method bridges the continuous world of particles and the discrete world of a computational grid. The first critical step is to accurately transfer particle charges onto this grid. This foundational exercise guides you through deriving the widely used Cloud-in-Cell (CIC) charge assignment scheme from first principles, ensuring that fundamental physical laws like charge conservation are respected in the discretization process .",
            "id": "3849522",
            "problem": "A key step in the Particle Mesh Ewald (PME) method is the assignment of point charges to a mesh to obtain a smooth mesh charge density suitable for solving Poisson’s equation in Fourier space. Consider a three-dimensional uniform Cartesian mesh with spacings $\\Delta x$, $\\Delta y$, and $\\Delta z$ along the $x$, $y$, and $z$ axes, respectively. A particle of charge $q$ is located at position $\\mathbf{r} = (x,y,z)$ inside a single mesh cell bounded by node indices $(i,j,k)$ at the lower-near-left corner and $(i+1,j+1,k+1)$ at the upper-far-right corner. Define the fractional offsets\n$$\nu_x = \\frac{x - x_i}{\\Delta x}, \\quad u_y = \\frac{y - y_j}{\\Delta y}, \\quad u_z = \\frac{z - z_k}{\\Delta z},\n$$\nwhere $x_i = i \\,\\Delta x$, $y_j = j \\,\\Delta y$, and $z_k = k \\,\\Delta z$, and assume $u_x,u_y,u_z \\in [0,1)$.\n\nStarting from first principles appropriate for multiscale materials simulation and mesh-based interpolation, use only the following fundamental requirements to derive the Cloud-In-Cell (CIC) charge assignment weights to the eight nearest mesh nodes:\n- Conservation of charge: the sum of assigned fractions equals one.\n- Locality: only the eight nearest nodes of the containing cell receive nonzero weight.\n- Linear consistency in one dimension: when restricting to a single axis, the assignment reduces to linear interpolation between the two adjacent nodes.\n- Tensor-product separability on a Cartesian grid: the three-dimensional assignment is the product of one-dimensional assignments along each axis.\n\nDerive explicit analytical expressions for the eight dimensionless weights $w_{n}$, $n=1,\\dots,8$, corresponding to the nodes ordered as\n$$\n(i,j,k),\\ (i+1,j,k),\\ (i,j+1,k),\\ (i+1,j+1,k),\\ (i,j,k+1),\\ (i+1,j,k+1),\\ (i,j+1,k+1),\\ (i+1,j+1,k+1).\n$$\nExpress your final answer as a single row vector containing the eight $w_n$ in this order, in terms of $u_x$, $u_y$, and $u_z$. Do not include units. The final answer must be a single analytical expression.",
            "solution": "The problem is scientifically grounded, well-posed, objective, and contains all necessary information to derive the requested charge assignment weights. It is therefore deemed valid and a solution is provided.\n\nThe derivation proceeds from the given fundamental requirements. We first establish the form of the one-dimensional interpolation weights and then extend them to three dimensions using the principle of tensor-product separability.\n\nThe requirement of linear consistency in one dimension states that the assignment reduces to linear interpolation. Consider the $x$-axis. A particle with fractional coordinate $u_x \\in [0,1)$ lies between grid nodes at integer indices $i$ and $i+1$. Let $W_i(u_x)$ and $W_{i+1}(u_x)$ be the dimensionless weights assigned to nodes $i$ and $i+1$ respectively. For linear interpolation, the weights must be linear functions of $u_x$.\nWhen the particle is located exactly at node $i$, its fractional coordinate is $u_x=0$. All of the particle's charge must be assigned to node $i$. This gives the boundary conditions $W_i(0) = 1$ and $W_{i+1}(0) = 0$.\nWhen the particle is located exactly at node $i+1$, its fractional coordinate is $u_x=1$. All of the particle's charge must be assigned to node $i+1$. This gives the boundary conditions $W_i(1) = 0$ and $W_{i+1}(1) = 1$.\nThe unique linear function for $W_i(u_x)$ that satisfies the conditions $W_i(0) = 1$ and $W_i(1) = 0$ is:\n$$\nW_i(u_x) = 1 - u_x\n$$\nThe unique linear function for $W_{i+1}(u_x)$ that satisfies the conditions $W_{i+1}(0) = 0$ and $W_{i+1}(1) = 1$ is:\n$$\nW_{i+1}(u_x) = u_x\n$$\nThese are the one-dimensional Cloud-In-Cell (CIC) weights. We verify charge conservation in one dimension: the sum of the weights is $W_i(u_x) + W_{i+1}(u_x) = (1 - u_x) + u_x = 1$. This is consistent with the charge conservation requirement.\n\nNext, we use the requirement of tensor-product separability on a Cartesian grid to construct the three-dimensional weights. The weight assigned to a node is the product of the one-dimensional weights for each coordinate. The particle is located in the cell with its lower-near-left corner at node $(i,j,k)$. The eight nodes of this cell are indexed by $(i+l, j+m, k+p)$ where $l, m, p \\in \\{0,1\\}$.\nThe fractional coordinates are $u_x$, $u_y$, and $u_z$. The weight $w_{i+l,j+m,k+p}$ assigned to node $(i+l,j+m,k+p)$ is given by:\n$$\nw_{i+l,j+m,k+p} = W_l(u_x) W_m(u_y) W_p(u_z)\n$$\nwhere we have generalized the one-dimensional weight functions as $W_0(u) = 1-u$ for the \"lower\" node and $W_1(u) = u$ for the \"upper\" node along any given axis.\nSubstituting these gives the general formula for the weight assigned to node $(i+l,j+m,k+p)$:\n$$\nw_{i+l,j+m,k+p} = (1-u_x)^{1-l} (u_x)^l (1-u_y)^{1-m} (u_y)^m (1-u_z)^{1-p} (u_z)^p\n$$\nThe locality requirement is satisfied by construction, as only the eight nodes of the cell (for which $l,m,p \\in \\{0,1\\}$) receive non-zero weights. All other nodes in the system receive zero weight.\nThe total charge conservation is also guaranteed by the tensor product structure:\n$$\n\\sum_{l=0}^{1} \\sum_{m=0}^{1} \\sum_{p=0}^{1} w_{i+l,j+m,k+p} = \\left( \\sum_{l=0}^{1} W_l(u_x) \\right) \\left( \\sum_{m=0}^{1} W_m(u_y) \\right) \\left( \\sum_{p=0}^{1} W_p(u_z) \\right)\n$$\nSince each sum in parentheses equals $1$, the total sum of all eight weights is $1 \\times 1 \\times 1 = 1$.\n\nWe now list the explicit expressions for the eight weights $w_n$ for $n=1, \\dots, 8$, corresponding to the specified node ordering.\nFor node $(i,j,k)$, we have $(l,m,p)=(0,0,0)$, so the weight is $w_1 = W_0(u_x)W_0(u_y)W_0(u_z) = (1-u_x)(1-u_y)(1-u_z)$.\nFor node $(i+1,j,k)$, we have $(l,m,p)=(1,0,0)$, so the weight is $w_2 = W_1(u_x)W_0(u_y)W_0(u_z) = u_x(1-u_y)(1-u_z)$.\nFor node $(i,j+1,k)$, we have $(l,m,p)=(0,1,0)$, so the weight is $w_3 = W_0(u_x)W_1(u_y)W_0(u_z) = (1-u_x)u_y(1-u_z)$.\nFor node $(i+1,j+1,k)$, we have $(l,m,p)=(1,1,0)$, so the weight is $w_4 = W_1(u_x)W_1(u_y)W_0(u_z) = u_x u_y (1-u_z)$.\nFor node $(i,j,k+1)$, we have $(l,m,p)=(0,0,1)$, so the weight is $w_5 = W_0(u_x)W_0(u_y)W_1(u_z) = (1-u_x)(1-u_y)u_z$.\nFor node $(i+1,j,k+1)$, we have $(l,m,p)=(1,0,1)$, so the weight is $w_6 = W_1(u_x)W_0(u_y)W_1(u_z) = u_x(1-u_y)u_z$.\nFor node $(i,j+1,k+1)$, we have $(l,m,p)=(0,1,1)$, so the weight is $w_7 = W_0(u_x)W_1(u_y)W_1(u_z) = (1-u_x)u_y u_z$.\nFor node $(i+1,j+1,k+1)$, we have $(l,m,p)=(1,1,1)$, so the weight is $w_8 = W_1(u_x)W_1(u_y)W_1(u_z) = u_x u_y u_z$.\n\nThese eight expressions constitute the derived Cloud-In-Cell assignment weights. They represent the fraction of the particle's charge $q$ that is assigned to each of the eight surrounding grid nodes.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n(1-u_x)(1-u_y)(1-u_z) & u_x(1-u_y)(1-u_z) & (1-u_x)u_y(1-u_z) & u_x u_y (1-u_z) & (1-u_x)(1-u_y)u_z & u_x(1-u_y)u_z & (1-u_x)u_y u_z & u_x u_y u_z\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "With charges mapped to a grid, the power of the PME method comes from solving Poisson's equation with the speed of the Fast Fourier Transform (FFT). This hands-on implementation challenges you to build the core reciprocal-space force pipeline, from the forward FFT of the charge density to the final interpolation of the electric field back to the particles . Completing this practice provides a working, from-scratch understanding of how PME efficiently computes long-range forces.",
            "id": "3282499",
            "problem": "You are to implement a simplified three-dimensional Particle Mesh Ewald (PME) method using the Fast Fourier Transform (FFT) to evaluate long-range electrostatic forces in a periodic cubic domain. The goal is to compute particle forces arising from the reciprocal-space (long-range) component only, under periodic boundary conditions and dimensionless units. The implementation must be fully self-contained and strictly use the Fast Fourier Transform (FFT) as the computational accelerator.\n\nThe computational domain is a periodic cube with side length $L=1$. All positions are given in reduced coordinates within $[0,1)$, all charges are dimensionless, and forces must be returned in dimensionless units. No physical unit conversion is required or permitted. Angle units are not applicable in this setting.\n\nYou must start from foundational principles and definitions of the discrete Fourier transform and Poisson’s equation, but the problem statement does not provide any shortcut formulas for the PME implementation. Your approach must be derived from first principles: map charges to a mesh, compute the potential in reciprocal space via FFTs and a screened Green’s function, differentiate in Fourier space to obtain the electric field, transform back to real space, and interpolate forces at particle locations.\n\nAlgorithmic specification:\n- The domain is a periodic cube of side length $L=1$ discretized on a uniform grid with $N \\times N \\times N$ points.\n- Use Cloud-In-Cell (CIC) charge assignment to place particle charges onto the mesh.\n- Use a three-dimensional Fast Fourier Transform (FFT) to transform the mesh charge density to reciprocal space.\n- Apply a screened reciprocal-space Green’s function characterized by a positive screening parameter $\\alpha$ to compute the long-range potential. The zero mode $\\mathbf{k}=\\mathbf{0}$ must be set to zero to enforce neutrality of the periodic cell.\n- Compute the electric field by differentiating the potential in reciprocal space.\n- Use the inverse FFT to return to real space and interpolate the electric field at particle positions using the same CIC weights. The force on particle $i$ is $q_i$ times the interpolated electric field at its position.\n- Use strictly dimensionless quantities throughout.\n\nTest suite:\nImplement your program to run exactly the following four test cases without any user input. For each case, $N$ denotes the grid size, $\\alpha$ denotes the screening parameter, $q_i$ are particle charges, and $\\mathbf{r}_i$ are particle positions in reduced coordinates in the unit cube.\n1. Happy path case: $N=16$, $\\alpha=3.5$, two particles with charges $[1.0,-1.0]$ at positions $\\mathbf{r}_1=[0.25,0.25,0.25]$, $\\mathbf{r}_2=[0.75,0.75,0.75]$.\n2. Boundary placement case: $N=16$, $\\alpha=2.5$, three particles with charges $[1.0,-0.5,0.5]$ at positions $\\mathbf{r}_1=[0.99,0.01,0.5]$, $\\mathbf{r}_2=[0.1,0.9,0.1]$, $\\mathbf{r}_3=[0.4,0.4,0.95]$.\n3. Edge case with zero charges: $N=8$, $\\alpha=2.0$, four particles with charges $[0.0,0.0,0.0,0.0]$ at positions $\\mathbf{r}_1=[0.2,0.3,0.4]$, $\\mathbf{r}_2=[0.6,0.2,0.1]$, $\\mathbf{r}_3=[0.8,0.8,0.8]$, $\\mathbf{r}_4=[0.1,0.7,0.9]$.\n4. Symmetric arrangement case: $N=32$, $\\alpha=3.0$, four particles with charges $[1.0,1.0,-1.0,-1.0]$ at positions $\\mathbf{r}_1=[0.25,0.25,0.5]$, $\\mathbf{r}_2=[0.75,0.25,0.5]$, $\\mathbf{r}_3=[0.25,0.75,0.5]$, $\\mathbf{r}_4=[0.75,0.75,0.5]$.\n\nRequired output:\nFor each test case, output a list of particle force vectors, where each force vector is a list of three floating-point numbers $[F_x,F_y,F_z]$ in dimensionless units. Aggregate the four per-case lists into a single list. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets and with no spaces, where each element is itself a list of force vectors (for example, $[[[F_{x,1},F_{y,1},F_{z,1}],\\ldots],\\ldots]$).\n\nYour implementation must:\n- Use only the Python standard library and the NumPy library.\n- Be deterministic and require no input.\n- Handle periodic boundary conditions consistently in both charge assignment and field interpolation.\n- Use three-dimensional FFTs to compute the reciprocal-space solution.",
            "solution": "The problem requires the implementation of a simplified three-dimensional Particle Mesh Ewald (PME) method to compute the long-range component of electrostatic forces on a set of charged particles within a periodic cubic domain. The solution must be derived from foundational principles.\n\n### 1. Foundational Principles: Electrostatics in Reciprocal Space\n\nThe fundamental relationship between the electrostatic potential $\\phi(\\mathbf{r})$ and the charge density $\\rho(\\mathbf{r})$ is given by Poisson's equation. In the dimensionless units specified for this problem, we write:\n$$\n\\nabla^2 \\phi(\\mathbf{r}) = -\\rho(\\mathbf{r})\n$$\nThe electric field $\\mathbf{E}(\\mathbf{r})$ is the negative gradient of the potential:\n$$\n\\mathbf{E}(\\mathbf{r}) = -\\nabla \\phi(\\mathbf{r})\n$$\nThe system is defined in a cubic box of side length $L=1$ with periodic boundary conditions. Such problems are naturally handled using Fourier series, which for computational purposes become Discrete Fourier Transforms (DFTs). A function $f(\\mathbf{r})$ on the periodic domain can be represented by its Fourier coefficients $\\tilde{f}(\\mathbf{k})$:\n$$\nf(\\mathbf{r}) = \\sum_{\\mathbf{k}} \\tilde{f}(\\mathbf{k}) e^{i\\mathbf{k} \\cdot \\mathbf{r}}\n$$\nwhere the wave vectors $\\mathbf{k}$ are discrete due to periodicity: $\\mathbf{k} = \\frac{2\\pi}{L}(n_x, n_y, n_z) = 2\\pi(n_x, n_y, n_z)$ since $L=1$, and $n_x, n_y, n_z$ are integers.\n\nIn Fourier space, the gradient operator $\\nabla$ transforms into multiplication by $i\\mathbf{k}$, and the Laplacian $\\nabla^2$ transforms into multiplication by $-|\\mathbf{k}|^2$. Applying the Fourier transform to the governing equations yields their algebraic counterparts:\n$$\n-|\\mathbf{k}|^2 \\tilde{\\phi}(\\mathbf{k}) = -\\tilde{\\rho}(\\mathbf{k}) \\implies \\tilde{\\phi}(\\mathbf{k}) = \\frac{\\tilde{\\rho}(\\mathbf{k})}{|\\mathbf{k}|^2}\n$$\n$$\n\\tilde{\\mathbf{E}}(\\mathbf{k}) = -i\\mathbf{k} \\tilde{\\phi}(\\mathbf{k})\n$$\n\n### 2. The Particle Mesh Ewald (PME) Method\n\nThe PME method provides an efficient way to calculate long-range forces by solving for a smoothed potential on a grid. The core idea of the Ewald split is to replace point charges with a superposition of two distributions: a localized one for short-range interactions (not part of this problem) and a smooth, long-ranged one for reciprocal-space calculation. The smooth distribution is typically a Gaussian cloud for each particle.\n\nThe effect of this smoothing in reciprocal space is the introduction of a damping factor into the potential calculation. The \"screened reciprocal-space Green's function\" specified in the problem combines the $1/|\\mathbf{k}|^2$ term from Poisson's equation with a Gaussian factor dependent on the screening parameter $\\alpha$. The Fourier-space potential is thus calculated as:\n$$\n\\tilde{\\phi}(\\mathbf{k}) = \\tilde{G}(\\mathbf{k}) \\tilde{\\rho}(\\mathbf{k})\n$$\nwhere $\\tilde{\\rho}(\\mathbf{k})$ is the Fourier transform of the charge density on the grid and $\\tilde{G}(\\mathbf{k})$ is the PME reciprocal-space kernel (or Green's function):\n$$\n\\tilde{G}(\\mathbf{k}) = \\frac{\\exp(-|\\mathbf{k}|^2 / (4\\alpha^2))}{|\\mathbf{k}|^2}\n$$\nFor $\\mathbf{k} = \\mathbf{0}$, the denominator $|\\mathbf{k}|^2$ is zero, leading to a singularity. This term corresponds to the average potential of the system. For a system with overall charge neutrality in a periodic box, this term's contribution to the force is zero. The problem mandates setting the $\\mathbf{k}=\\mathbf{0}$ mode to zero, which is the standard procedure. Thus, we define $\\tilde{G}(\\mathbf{0}) = 0$.\n\n### 3. Discretization and Algorithmic Steps\n\nThe continuous fields are discretized on a uniform $N \\times N \\times N$ grid. Continuous Fourier transforms are replaced by DFTs, which are computed efficiently using the Fast Fourier Transform (FFT) algorithm. Let the grid spacing be $h = L/N = 1/N$.\n\n#### Step 1: Charge Assignment\nParticle charges, which are delta functions in the continuous representation, must be transferred to the discrete grid. The Cloud-in-Cell (CIC) or trilinear interpolation scheme is used. For a particle $i$ with charge $q_i$ at reduced position $\\mathbf{r}_i = (u_i, v_i, w_i) \\in [0,1)^3$, its scaled coordinates are $\\mathbf{s}_i = N\\mathbf{r}_i$. The integer part of $\\mathbf{s}_i$ identifies the primary grid cell, $\\mathbf{n}_i = (\\lfloor s_{ix} \\rfloor, \\lfloor s_{iy} \\rfloor, \\lfloor s_{iz} \\rfloor)$, and the fractional part gives the displacement within that cell, $\\mathbf{d}_i = \\mathbf{s}_i - \\mathbf{n}_i$.\n\nThe charge $q_i$ is distributed to the $8$ corners of the cell containing $\\mathbf{s}_i$. The charge assigned to a corner at offset $(\\delta_x, \\delta_y, \\delta_z)$ from $\\mathbf{n}_i$ (where $\\delta_j \\in \\{0,1\\}$) is:\n$$\n\\Delta\\rho = q_i \\cdot W_x(\\delta_x) \\cdot W_y(\\delta_y) \\cdot W_z(\\delta_z)\n$$\nwhere the weighting factors are $W_j(\\delta_j) = (1-d_{ij})^{1-\\delta_j} d_{ij}^{\\delta_j}$. This procedure is performed for all particles, accumulating charges on the grid $\\rho_{\\text{grid}}$. Grid indices are taken modulo $N$ to enforce periodicity.\n\n#### Step 2: Fourier Transform of Charge Density\nThe gridded charge density $\\rho_{\\text{grid}}$ is transformed to reciprocal space using a 3D FFT:\n$$\n\\tilde{\\rho}(\\mathbf{k}) = \\text{FFT3D}[\\rho_{\\text{grid}}]\n$$\n\n#### Step 3: Reciprocal Space Calculation\nThe potential and electric field are computed in Fourier space.\nFirst, the grid of discrete wave vectors $\\mathbf{k} = 2\\pi(n_x, n_y, n_z)$ is constructed, where $n_x, n_y, n_z$ are the integer frequencies corresponding to the FFT grid indices.\nThen, the Green's function $\\tilde{G}(\\mathbf{k})$ is computed for all $\\mathbf{k}$, with $\\tilde{G}(\\mathbf{0})=0$.\nThe potential is found by element-wise multiplication:\n$$\n\\tilde{\\phi}(\\mathbf{k}) = \\tilde{G}(\\mathbf{k}) \\tilde{\\rho}(\\mathbf{k})\n$$\nThe electric field components are then calculated:\n$$\n\\tilde{E}_x(\\mathbf{k}) = -i k_x \\tilde{\\phi}(\\mathbf{k}) \\quad ; \\quad \\tilde{E}_y(\\mathbf{k}) = -i k_y \\tilde{\\phi}(\\mathbf{k}) \\quad ; \\quad \\tilde{E}_z(\\mathbf{k}) = -i k_z \\tilde{\\phi}(\\mathbf{k})\n$$\n\n#### Step 4: Inverse Fourier Transform\nThe electric field on the grid, $\\mathbf{E}_{\\text{grid}}$, is obtained by applying the inverse 3D FFT to each component of $\\tilde{\\mathbf{E}}(\\mathbf{k})$:\n$$\n\\mathbf{E}_{\\text{grid}}(\\mathbf{r}) = \\text{iFFT3D}[\\tilde{\\mathbf{E}}(\\mathbf{k})]\n$$\nThe result of the iFFT will be a complex array; the physical field is its real part.\n\n#### Step 5: Force Interpolation and Calculation\nTo find the force on each particle, the electric field must be interpolated from the grid back to the particle's position. For consistency and to ensure momentum conservation (i.e., $\\mathbf{F}_{ij} = -\\mathbf{F}_{ji}$), the same CIC interpolation scheme used for charge assignment is applied. The electric field at particle $i$'s position $\\mathbf{r}_i$ is a weighted average of the field values at the $8$ surrounding grid points:\n$$\n\\mathbf{E}(\\mathbf{r}_i) = \\sum_{\\text{8 neighbors } \\mathbf{g}} \\mathbf{E}_{\\text{grid}}(\\mathbf{g}) \\cdot W(\\mathbf{r}_i, \\mathbf{g})\n$$\nwhere the weights $W$ are the same trilinear weights from Step 1.\nFinally, the force on particle $i$ is calculated as:\n$$\n\\mathbf{F}_i = q_i \\mathbf{E}(\\mathbf{r}_i)\n$$\nThis process is repeated for all particles and for each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef format_list_no_spaces(item):\n    \"\"\"\n    Recursively formats a nested list or numpy array into a string\n    with no spaces, as per the strict output format requirement.\n    \"\"\"\n    if isinstance(item, (list, np.ndarray)):\n        return \"[\" + \",\".join(format_list_no_spaces(x) for x in item) + \"]\"\n    return str(item)\n\ndef solve_pme_case(N, alpha, charges, positions):\n    \"\"\"\n    Computes reciprocal-space electrostatic forces for one test case.\n    \"\"\"\n    # Box length L=1 is assumed throughout.\n    L = 1.0\n    \n    # Step 1: Charge Assignment (CIC)\n    rho = np.zeros((N, N, N), dtype=float)\n    num_particles = len(charges)\n    # Store particle info for interpolation later\n    particle_info = []\n\n    for i in range(num_particles):\n        q_i = charges[i]\n        r_i = np.array(positions[i]) # Reduced coordinates [0, 1)\n\n        s_i = r_i * N\n        n_i = np.floor(s_i).astype(int)\n        d_i = s_i - n_i\n\n        particle_info.append({'n': n_i, 'd': d_i})\n\n        for dz in range(2):\n            wz = (1 - d_i[2]) if dz == 0 else d_i[2]\n            z_idx = (n_i[2] + dz) % N\n            for dy in range(2):\n                wy = (1 - d_i[1]) if dy == 0 else d_i[1]\n                y_idx = (n_i[1] + dy) % N\n                for dx in range(2):\n                    wx = (1 - d_i[0]) if dx == 0 else d_i[0]\n                    x_idx = (n_i[0] + dx) % N\n                    \n                    weight = wx * wy * wz\n                    rho[z_idx, y_idx, x_idx] += q_i * weight\n    \n    # Step 2: FFT of charge density\n    rho_k = np.fft.fftn(rho)\n\n    # Step 3: Reciprocal Space Calculation\n    # Generate wave vectors k\n    kx_int = np.fft.fftfreq(N) * N\n    ky_int = np.fft.fftfreq(N) * N\n    kz_int = np.fft.fftfreq(N) * N\n    \n    kx = 2 * np.pi * kx_int / L\n    ky = 2 * np.pi * ky_int / L\n    kz = 2 * np.pi * kz_int / L\n    \n    kz_grid, ky_grid, kx_grid = np.meshgrid(kz, ky, kx, indexing='ij')\n\n    k_squared = kx_grid**2 + ky_grid**2 + kz_grid**2\n    \n    # Calculate reciprocal Green's function G_k\n    G_k = np.zeros((N, N, N), dtype=float)\n    # Avoid division by zero at k=0\n    non_zero_k = k_squared != 0\n    G_k[non_zero_k] = np.exp(-k_squared[non_zero_k] / (4 * alpha**2)) / k_squared[non_zero_k]\n    # k=0 mode is explicitly set to 0. It is already 0 from initialization.\n\n    # Calculate potential and field in Fourier space\n    phi_k = G_k * rho_k\n    \n    Ex_k = -1j * kx_grid * phi_k\n    Ey_k = -1j * ky_grid * phi_k\n    Ez_k = -1j * kz_grid * phi_k\n\n    # Step 4: Inverse FFT to get E-field on the grid\n    Ex_grid = np.real(np.fft.ifftn(Ex_k))\n    Ey_grid = np.real(np.fft.ifftn(Ey_k))\n    Ez_grid = np.real(np.fft.ifftn(Ez_k))\n\n    # Step 5 and 6: Force Interpolation and Calculation\n    forces = []\n    for i in range(num_particles):\n        q_i = charges[i]\n        n_i = particle_info[i]['n']\n        d_i = particle_info[i]['d']\n        \n        E_interp = np.zeros(3, dtype=float)\n        \n        for dz in range(2):\n            wz = (1 - d_i[2]) if dz == 0 else d_i[2]\n            z_idx = (n_i[2] + dz) % N\n            for dy in range(2):\n                wy = (1 - d_i[1]) if dy == 0 else d_i[1]\n                y_idx = (n_i[1] + dy) % N\n                for dx in range(2):\n                    wx = (1 - d_i[0]) if dx == 0 else d_i[0]\n                    x_idx = (n_i[0] + dx) % N\n\n                    weight = wx * wy * wz\n                    E_interp[0] += Ex_grid[z_idx, y_idx, x_idx] * weight\n                    E_interp[1] += Ey_grid[z_idx, y_idx, x_idx] * weight\n                    E_interp[2] += Ez_grid[z_idx, y_idx, x_idx] * weight\n        \n        force_i = q_i * E_interp\n        forces.append(force_i.tolist())\n    \n    return forces\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 16, \"alpha\": 3.5, \"charges\": [1.0, -1.0],\n            \"positions\": [[0.25, 0.25, 0.25], [0.75, 0.75, 0.75]]\n        },\n        {\n            \"N\": 16, \"alpha\": 2.5, \"charges\": [1.0, -0.5, 0.5],\n            \"positions\": [[0.99, 0.01, 0.5], [0.1, 0.9, 0.1], [0.4, 0.4, 0.95]]\n        },\n        {\n            \"N\": 8, \"alpha\": 2.0, \"charges\": [0.0, 0.0, 0.0, 0.0],\n            \"positions\": [[0.2, 0.3, 0.4], [0.6, 0.2, 0.1], [0.8, 0.8, 0.8], [0.1, 0.7, 0.9]]\n        },\n        {\n            \"N\": 32, \"alpha\": 3.0, \"charges\": [1.0, 1.0, -1.0, -1.0],\n            \"positions\": [[0.25, 0.25, 0.5], [0.75, 0.25, 0.5], [0.25, 0.75, 0.5], [0.75, 0.75, 0.5]]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_pme_case(case[\"N\"], case[\"alpha\"], case[\"charges\"], case[\"positions\"])\n        results.append(result)\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_list_no_spaces(results))\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond calculating forces, computing the total energy reveals subtle but crucial physics underlying periodic simulations. This advanced practice explores the profound consequences of simulating a system with a net charge, a scenario where the standard Ewald sum diverges if not handled correctly . By implementing the full Ewald energy expression, including the often-overlooked background correction term, you will numerically verify the method's dependence on the Ewald parameter $\\alpha$ for non-neutral systems.",
            "id": "2424414",
            "problem": "You are asked to examine the consequences of violating charge neutrality in a three-dimensional periodic Particle–Mesh Ewald (PME) calculation from first principles, and to validate those consequences numerically. Work in a cubic periodic box of side length $L$ with point charges and adopt dimensionless units throughout. Angles do not appear in this problem.\n\nStarting point and derivation requirements:\n- Begin from the electrostatic fundamentals: Coulomb’s law for point charges, the Poisson equation $\\nabla^2 \\phi(\\mathbf{r}) = -4\\pi \\rho(\\mathbf{r})$ under periodic boundary conditions, and the definition of electrostatic energy $E = \\tfrac{1}{2}\\int \\rho(\\mathbf{r}) \\,\\phi(\\mathbf{r})\\, d^3r$.\n- Use Ewald’s idea: add and subtract a Gaussian-screened charge distribution to split the $1/r$ interaction into a rapidly decaying real-space term and a smoothly varying reciprocal-space term, together with a self-interaction correction.\n- Reason about the zero-wavevector (reciprocal-space) contribution: explain why the zero mode is ill defined when the total charge $Q=\\sum_i q_i \\neq 0$, and why a uniform neutralizing background of density $-Q/V$ (with $V=L^3$) is a mathematically consistent way to regularize the problem under conducting (“tin-foil”) boundary conditions.\n- From this foundation, derive an implementable expression for the Ewald total energy that comprises: a real-space sum over periodic images within a cutoff radius, a reciprocal-space sum over nonzero wavevectors up to a cutoff, a self-interaction correction, and a uniform-background correction that is identically zero when $Q=0$ and nonzero when $Q\\neq 0$.\n\nComputation requirements for your program:\n- Implement the periodic Ewald summation for a cubic box of side length $L$ using the following components, each derived from the above principles:\n    1. A real-space pairwise term that decays rapidly with separation after Gaussian screening; sum over particle pairs and periodic images within a real-space cutoff $r_c$ while excluding self-interactions.\n    2. A reciprocal-space term that uses the structure factor $S(\\mathbf{k})$ on wavevectors $\\mathbf{k} = (2\\pi/L)\\,\\mathbf{n}$ for integer triplets $\\mathbf{n}$, excluding $\\mathbf{n}=\\mathbf{0}$, with a smoothly decaying kernel controlled by a positive splitting parameter $\\alpha$; truncate to $|n_x|,|n_y|,|n_z|\\le K_{\\max}$.\n    3. A self-interaction correction accounting for the subtraction of each particle’s Gaussian-screened self-field.\n    4. A uniform-background correction consistent with a spatially uniform neutralizing charge density of $-Q/V$ under conducting boundary conditions. This term must be included generally (it vanishes automatically when $Q=0$).\n- Show, by computing the total Ewald energy at two distinct values $\\alpha_1$ and $\\alpha_2$, that for neutral systems ($Q=0$) the total energy is practically independent of $\\alpha$ (within numerical truncation error), whereas for non-neutral systems ($Q\\neq 0$) the total energy depends on $\\alpha$ due to the background regularization. Quantify this by reporting the absolute difference $\\Delta E = |E(\\alpha_1) - E(\\alpha_2)|$.\n\nParameter values and test suite:\n- Use a cubic box of side length $L = 10.0$ and volume $V = L^3$.\n- Use two Ewald splitting parameters $\\alpha_1 = 0.25$ and $\\alpha_2 = 0.45$.\n- Use a real-space cutoff $r_c = 4.9$ and include periodic images sufficient to account for all pair separations within this cutoff. Ensure that self-interactions are excluded.\n- Use a reciprocal-space cutoff defined by integer limits $K_{\\max} = 12$ on each Cartesian index for the wavevector triplets $\\mathbf{n} = (n_x,n_y,n_z)$, and exclude $\\mathbf{n}=\\mathbf{0}$ from the sum.\n- Adopt conducting (“tin-foil”) boundary conditions for any shape-dependent surface terms.\n\nEvaluate the absolute energy difference $\\Delta E$ for each of the following four test cases, all within the same box:\n1. Neutral dimer: two charges $q = [1.0, -1.0]$ at positions $\\mathbf{r} = \\big[(1.0,1.0,1.0), (3.0,1.0,1.0)\\big]$.\n2. Non-neutral single charge: one charge $q = [1.0]$ at position $\\mathbf{r} = \\big[(2.0,2.0,2.0)\\big]$.\n3. Neutral trimer: three charges $q = [1.0, 1.0, -2.0]$ at positions $\\mathbf{r} = \\big[(1.0,2.0,3.0), (7.0,2.0,2.0), (4.0,7.0,5.0)\\big]$.\n4. Nearly neutral trimer with small net charge: three charges $q = [1.0, 1.0, -1.9]$ at positions $\\mathbf{r} = \\big[(1.0,2.0,3.0), (7.0,2.0,2.0), (4.0,7.0,5.0)\\big]$.\n\nYour program must compute the total Ewald energy for each case at $\\alpha_1$ and $\\alpha_2$, include all four energy components described above, and then return the absolute differences $\\Delta E$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite: $[\\Delta E_1,\\Delta E_2,\\Delta E_3,\\Delta E_4]$.",
            "solution": "The problem as stated is valid. It is scientifically grounded in the fundamental principles of electrostatics and computational physics, specifically the Ewald summation method. It is well-posed, providing all necessary physical and numerical parameters to derive and implement a solution. The language is objective and precise. We shall proceed with the derivation and subsequent numerical validation.\n\nThe primary objective is to calculate the total electrostatic energy of a system of $N$ point charges $\\{q_i\\}$ at positions $\\{\\mathbf{r}_i\\}$ within a cubic periodic box of side length $L$. The interaction potential is the Coulomb potential, and the total energy for an infinite periodic lattice is given by the conditionally convergent sum:\n$$ E = \\frac{1}{2} \\sum_{\\mathbf{n} \\in \\mathbb{Z}^3} \\sum_{i=1}^N \\sum_{j=1}^N \\frac{q_i q_j}{|\\mathbf{r}_i - \\mathbf{r}_j + \\mathbf{n}L|} $$\nwhere the prime on the sum indicates that the term for $i=j$ is omitted when the periodic image vector $\\mathbf{n}$ is the zero vector, $\\mathbf{n}=(0,0,0)$.\n\nThe Ewald method provides a robust way to compute this sum by splitting the $1/r$ potential into a short-range part, evaluated by a rapidly converging sum in real space, and a long-range part, evaluated by a rapidly converging sum in reciprocal (Fourier) space. The split is achieved using the identity:\n$$ \\frac{1}{r} = \\frac{\\text{erfc}(\\alpha r)}{r} + \\frac{\\text{erf}(\\alpha r)}{r} $$\nwhere $\\text{erf}$ is the error function, $\\text{erfc}$ is the complementary error function, and $\\alpha$ is a parameter that controls the width of the splitting. The term with $\\text{erfc}(\\alpha r)$ decays rapidly in real space, whereas the term with $\\text{erf}(\\alpha r)$ is smooth and suitable for Fourier methods. This decomposition leads to a total energy expression with four distinct components:\n$$ E = E_{\\text{real}} + E_{\\text{recip}} + E_{\\text{self}} + E_{\\text{bkg}} $$\n\nWe will now derive each of these terms.\n\n1.  **Real-Space Energy ($E_{\\text{real}}$)**: This term arises from the direct summation of the short-range part of the potential. Due to the rapid decay of $\\text{erfc}(\\alpha r)/r$, the sum can be truncated at a cutoff radius $r_c$. For a cutoff $r_c  L/2$, the minimum image convention is sufficient to account for all relevant interactions. The sum is taken over all unique pairs of particles, considering their closest periodic image.\n    $$ E_{\\text{real}} = \\sum_{1 \\le i  j \\le N} \\frac{q_i q_j \\text{erfc}(\\alpha r_{ij,\\text{mic}})}{r_{ij,\\text{mic}}} $$\n    where $r_{ij,\\text{mic}}$ is the distance between particle $i$ and the closest periodic image of particle $j$, and the sum includes only pairs for which $r_{ij,\\text{mic}}  r_c$.\n\n2.  **Reciprocal-Space Energy ($E_{\\text{recip}}$)**: The long-range part of the energy is computed in reciprocal space. This term corresponds to the energy of a system of smooth Gaussian charge distributions, $\\rho_g(\\mathbf{r}) = \\sum_i q_i (\\alpha/\\sqrt{\\pi})^3 e^{-\\alpha^2(\\mathbf{r}-\\mathbf{r}_i)^2}$, which produce the potential $\\phi_g(\\mathbf{r}) = \\sum_i q_i \\text{erf}(\\alpha|\\mathbf{r}-\\mathbf{r}_i|)/|\\mathbf{r}-\\mathbf{r}_i|$. Using the Poisson equation in Fourier space, $\\hat{\\phi}(\\mathbf{k}) = (4\\pi/k^2)\\hat{\\rho}(\\mathbf{k})$, the energy can be written as a sum over reciprocal lattice vectors $\\mathbf{k} = (2\\pi/L)\\mathbf{n}$ for integer vectors $\\mathbf{n}=(n_x,n_y,n_z)$.\n    The Fourier transform of the Gaussian charge density is $\\hat{\\rho}_g(\\mathbf{k}) = S(\\mathbf{k}) e^{-k^2/(4\\alpha^2)}$, where $S(\\mathbf{k}) = \\sum_{j=1}^N q_j e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j}$ is the structure factor. The resulting energy is:\n    $$ E_{\\text{recip}} = \\frac{1}{2V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\hat{\\rho}_g(\\mathbf{k}) \\hat{\\phi}_g(-\\mathbf{k}) = \\frac{2\\pi}{V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\frac{|S(\\mathbf{k})|^2}{k^2} e^{-k^2/(4\\alpha^2)} $$\n    The sum explicitly excludes the $\\mathbf{k}=\\mathbf{0}$ term, which requires special consideration.\n\n3.  **Self-Interaction Correction ($E_{\\text{self}}$)**: The reciprocal-space sum includes the self-interaction of each Gaussian charge cloud (the $i=j$ terms in $|S(\\mathbf{k})|^2$). This is an artifact of the method and must be subtracted. The self-energy of a single Gaussian charge distribution $q_i(\\alpha/\\sqrt{\\pi})^3 e^{-\\alpha^2 r^2}$ is found to be $q_i^2 \\alpha / \\sqrt{\\pi}$. Summing over all particles, the total self-energy correction is:\n    $$ E_{\\text{self}} = - \\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{i=1}^N q_i^2 $$\n\n4.  **Zero Wavevector and Background Correction ($E_{\\text{bkg}}$)**: We now address the $\\mathbf{k}=\\mathbf{0}$ term. The structure factor at $\\mathbf{k}=\\mathbf{0}$ is $S(\\mathbf{0}) = \\sum_i q_i = Q$, the total charge of the system. If $Q \\neq 0$, the summand for $E_{\\text{recip}}$ diverges as $1/k^2$ for $k \\to 0$. This reflects the physical reality that the energy of a periodic array of net charges is infinite. To regularize this, one assumes the system is neutralized by a uniform background charge of density $\\rho_{bg} = -Q/V$, where $V=L^3$. This corresponds to the standard procedure for PME calculations under conducting (\"tin-foil\") boundary conditions, where the neutralizing background makes the total average charge density zero. The energy contribution of this neutralization is derived by examining the limit of the $\\mathbf{k} \\to \\mathbf{0}$ term in the reciprocal-space energy expression:\n    $$ \\lim_{k\\to 0} \\frac{2\\pi}{V} \\frac{|S(\\mathbf{k})|^2}{k^2} e^{-k^2/(4\\alpha^2)} \\approx \\lim_{k\\to 0} \\frac{2\\pi Q^2}{V k^2} \\left(1 - \\frac{k^2}{4\\alpha^2} + \\dots\\right) = \\frac{2\\pi Q^2}{Vk^2} - \\frac{\\pi Q^2}{2V\\alpha^2} $$\n    The divergent $1/k^2$ term is exactly cancelled by the energy of the neutralizing background. The remaining finite term is the required correction, which depends explicitly on $Q$ and $\\alpha$. This term is zero if and only if the system is neutral ($Q=0$). $E_{\\text{bkg}} = -\\frac{\\pi Q^2}{2V\\alpha^2}$\n\n**Summary of Formulas and $\\alpha$-dependence**:\nThe total energy is given by the sum of these four components:\n$$ E(\\alpha) = \\left( \\sum_{1 \\le i  j \\le N, r_{ij,\\text{mic}}  r_c} \\frac{q_i q_j \\text{erfc}(\\alpha r_{ij,\\text{mic}})}{r_{ij,\\text{mic}}} \\right) + \\left( \\frac{2\\pi}{V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} |S(\\mathbf{k})|^2 \\right) - \\left( \\frac{\\alpha}{\\sqrt{\\pi}} \\sum_{i=1}^N q_i^2 \\right) - \\left( \\frac{\\pi (\\sum_i q_i)^2}{2V \\alpha^2} \\right) $$\nFor a charge-neutral system ($Q=0$), the background correction $E_{\\text{bkg}}$ is zero. The sum of the other three terms, representing the energy of the periodic system in vacuum, is constructed to be largely independent of the non-physical splitting parameter $\\alpha$, provided the cutoffs $r_c$ and $K_{\\max}$ are sufficiently large. Any residual dependence is due to truncation errors.\nHowever, for a non-neutral system ($Q \\neq 0$), the total energy includes the term $E_{\\text{bkg}}(\\alpha) = -(\\pi Q^2 / 2V) \\alpha^{-2}$. This term introduces an explicit and strong dependence on $\\alpha$ that is not cancelled by the other terms. The absolute difference in total energy calculated at two different values of $\\alpha$ will therefore be approximately zero for a neutral system but significantly non-zero for a non-neutral one. We will demonstrate this numerically.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\n\ndef solve():\n    \"\"\"\n    Computes the absolute difference in Ewald energy for different alpha values.\n    \"\"\"\n    def calculate_ewald_energy(q, r, L, alpha, r_c, k_max):\n        \"\"\"\n        Calculates the total Ewald energy for a system of point charges.\n\n        Args:\n            q (np.ndarray): Array of charges.\n            r (np.ndarray): Array of particle positions (N x 3).\n            L (float): Side length of the cubic box.\n            alpha (float): Ewald splitting parameter.\n            r_c (float): Real-space cutoff radius.\n            k_max (int): Reciprocal-space cutoff index.\n\n        Returns:\n            float: Total Ewald energy.\n        \"\"\"\n        N = len(q)\n        V = L**3\n        Q = np.sum(q)\n\n        # 1. Real-space energy\n        E_real = 0.0\n        for i in range(N):\n            for j in range(i + 1, N):\n                rij_vec = r[i] - r[j]\n                # Minimum Image Convention\n                rij_vec_mic = rij_vec - L * np.round(rij_vec / L)\n                dist = np.linalg.norm(rij_vec_mic)\n                if dist  r_c:\n                    E_real += q[i] * q[j] * erfc(alpha * dist) / dist\n\n        # 2. Self-interaction energy\n        E_self = - (alpha / np.sqrt(np.pi)) * np.sum(q**2)\n\n        # 3. Reciprocal-space energy\n        E_recip = 0.0\n        # Generate integer vectors n\n        n_vals = np.arange(-k_max, k_max + 1)\n        # Use meshgrid to get all combinations of (nx, ny, nz)\n        nx, ny, nz = np.meshgrid(n_vals, n_vals, n_vals, indexing='ij')\n        n_vectors = np.stack((nx.ravel(), ny.ravel(), nz.ravel()), axis=-1)\n        \n        # Filter out n = (0,0,0)\n        n_vectors = n_vectors[np.any(n_vectors != 0, axis=1)]\n\n        # k vectors and k^2\n        k_vectors = (2.0 * np.pi / L) * n_vectors\n        k_sq = np.sum(k_vectors**2, axis=1)\n\n        # Structure factor |S(k)|^2\n        # k_dot_r will have shape (num_k_vectors, N)\n        k_dot_r = np.dot(k_vectors, r.T)\n        \n        # Broadcast q for summation\n        cos_sum = np.sum(q * np.cos(k_dot_r), axis=1)\n        sin_sum = np.sum(q * np.sin(k_dot_r), axis=1)\n        S_k_sq = cos_sum**2 + sin_sum**2\n\n        recip_terms = (np.exp(-k_sq / (4.0 * alpha**2)) / k_sq) * S_k_sq\n        E_recip = (2.0 * np.pi / V) * np.sum(recip_terms)\n\n        # 4. Background (neutralizing plasma) energy correction\n        if abs(Q)  1e-9:\n            E_bkg = - (np.pi * Q**2) / (2.0 * V * alpha**2)\n        else:\n            E_bkg = 0.0\n\n        return E_real + E_recip + E_self + E_bkg\n        \n    # --- Problem Parameters ---\n    L = 10.0\n    alpha1 = 0.25\n    alpha2 = 0.45\n    r_c = 4.9\n    k_max = 12\n\n    # --- Test Cases ---\n    test_cases = [\n        # 1. Neutral dimer\n        {\n            \"q\": np.array([1.0, -1.0]),\n            \"r\": np.array([[1.0, 1.0, 1.0], [3.0, 1.0, 1.0]])\n        },\n        # 2. Non-neutral single charge\n        {\n            \"q\": np.array([1.0]),\n            \"r\": np.array([[2.0, 2.0, 2.0]])\n        },\n        # 3. Neutral trimer\n        {\n            \"q\": np.array([1.0, 1.0, -2.0]),\n            \"r\": np.array([[1.0, 2.0, 3.0], [7.0, 2.0, 2.0], [4.0, 7.0, 5.0]])\n        },\n        # 4. Nearly neutral trimer\n        {\n            \"q\": np.array([1.0, 1.0, -1.9]),\n            \"r\": np.array([[1.0, 2.0, 3.0], [7.0, 2.0, 2.0], [4.0, 7.0, 5.0]])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        E1 = calculate_ewald_energy(case[\"q\"], case[\"r\"], L, alpha1, r_c, k_max)\n        E2 = calculate_ewald_energy(case[\"q\"], case[\"r\"], L, alpha2, r_c, k_max)\n        delta_E = abs(E1 - E2)\n        results.append(delta_E)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.10f}' for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}