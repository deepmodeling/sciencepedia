{
    "hands_on_practices": [
        {
            "introduction": "The first step in any Particle-Mesh (PM) method is to represent the discrete particle charges as a smooth density on a regular grid. This exercise  delves into the derivation of the widely-used Cloud-in-Cell (CIC) assignment scheme, not as an arbitrary choice, but as a consequence of fundamental principles like charge conservation and linear consistency. Mastering this derivation provides a solid foundation for understanding the critical interface between the particle and mesh components of the PME algorithm.",
            "id": "3849522",
            "problem": "A key step in the Particle Mesh Ewald (PME) method is the assignment of point charges to a mesh to obtain a smooth mesh charge density suitable for solving Poisson’s equation in Fourier space. Consider a three-dimensional uniform Cartesian mesh with spacings $\\Delta x$, $\\Delta y$, and $\\Delta z$ along the $x$, $y$, and $z$ axes, respectively. A particle of charge $q$ is located at position $\\mathbf{r} = (x,y,z)$ inside a single mesh cell bounded by node indices $(i,j,k)$ at the lower-near-left corner and $(i+1,j+1,k+1)$ at the upper-far-right corner. Define the fractional offsets\n$$\nu_x = \\frac{x - x_i}{\\Delta x}, \\quad u_y = \\frac{y - y_j}{\\Delta y}, \\quad u_z = \\frac{z - z_k}{\\Delta z},\n$$\nwhere $x_i = i \\,\\Delta x$, $y_j = j \\,\\Delta y$, and $z_k = k \\,\\Delta z$, and assume $u_x,u_y,u_z \\in [0,1)$.\n\nStarting from first principles appropriate for multiscale materials simulation and mesh-based interpolation, use only the following fundamental requirements to derive the Cloud-In-Cell (CIC) charge assignment weights to the eight nearest mesh nodes:\n- Conservation of charge: the sum of assigned fractions equals one.\n- Locality: only the eight nearest nodes of the containing cell receive nonzero weight.\n- Linear consistency in one dimension: when restricting to a single axis, the assignment reduces to linear interpolation between the two adjacent nodes.\n- Tensor-product separability on a Cartesian grid: the three-dimensional assignment is the product of one-dimensional assignments along each axis.\n\nDerive explicit analytical expressions for the eight dimensionless weights $w_{n}$, $n=1,\\dots,8$, corresponding to the nodes ordered as\n$$\n(i,j,k),\\ (i+1,j,k),\\ (i,j+1,k),\\ (i+1,j+1,k),\\ (i,j,k+1),\\ (i+1,j,k+1),\\ (i,j+1,k+1),\\ (i+1,j+1,k+1).\n$$\nExpress your final answer as a single row vector containing the eight $w_n$ in this order, in terms of $u_x$, $u_y$, and $u_z$. Do not include units. The final answer must be a single analytical expression.",
            "solution": "The problem is scientifically grounded, well-posed, objective, and contains all necessary information to derive the requested charge assignment weights. It is therefore deemed valid and a solution is provided.\n\nThe derivation proceeds from the given fundamental requirements. We first establish the form of the one-dimensional interpolation weights and then extend them to three dimensions using the principle of tensor-product separability.\n\nThe requirement of linear consistency in one dimension states that the assignment reduces to linear interpolation. Consider the $x$-axis. A particle with fractional coordinate $u_x \\in [0,1)$ lies between grid nodes at integer indices $i$ and $i+1$. Let $W_i(u_x)$ and $W_{i+1}(u_x)$ be the dimensionless weights assigned to nodes $i$ and $i+1$ respectively. For linear interpolation, the weights must be linear functions of $u_x$.\nWhen the particle is located exactly at node $i$, its fractional coordinate is $u_x=0$. All of the particle's charge must be assigned to node $i$. This gives the boundary conditions $W_i(0) = 1$ and $W_{i+1}(0) = 0$.\nWhen the particle is located exactly at node $i+1$, its fractional coordinate is $u_x=1$. All of the particle's charge must be assigned to node $i+1$. This gives the boundary conditions $W_i(1) = 0$ and $W_{i+1}(1) = 1$.\nThe unique linear function for $W_i(u_x)$ that satisfies the conditions $W_i(0) = 1$ and $W_i(1) = 0$ is:\n$$\nW_i(u_x) = 1 - u_x\n$$\nThe unique linear function for $W_{i+1}(u_x)$ that satisfies the conditions $W_{i+1}(0) = 0$ and $W_{i+1}(1) = 1$ is:\n$$\nW_{i+1}(u_x) = u_x\n$$\nThese are the one-dimensional Cloud-In-Cell (CIC) weights. We verify charge conservation in one dimension: the sum of the weights is $W_i(u_x) + W_{i+1}(u_x) = (1 - u_x) + u_x = 1$. This is consistent with the charge conservation requirement.\n\nNext, we use the requirement of tensor-product separability on a Cartesian grid to construct the three-dimensional weights. The weight assigned to a node is the product of the one-dimensional weights for each coordinate. The particle is located in the cell with its lower-near-left corner at node $(i,j,k)$. The eight nodes of this cell are indexed by $(i+l, j+m, k+p)$ where $l, m, p \\in \\{0,1\\}$.\nThe fractional coordinates are $u_x$, $u_y$, and $u_z$. The weight $w_{i+l,j+m,k+p}$ assigned to node $(i+l,j+m,k+p)$ is given by:\n$$\nw_{i+l,j+m,k+p} = W_l(u_x) W_m(u_y) W_p(u_z)\n$$\nwhere we have generalized the one-dimensional weight functions as $W_0(u) = 1-u$ for the \"lower\" node and $W_1(u) = u$ for the \"upper\" node along any given axis.\nSubstituting these gives the general formula for the weight assigned to node $(i+l,j+m,k+p)$:\n$$\nw_{i+l,j+m,k+p} = (1-u_x)^{1-l} (u_x)^l (1-u_y)^{1-m} (u_y)^m (1-u_z)^{1-p} (u_z)^p\n$$\nThe locality requirement is satisfied by construction, as only the eight nodes of the cell (for which $l,m,p \\in \\{0,1\\}$) receive non-zero weights. All other nodes in the system receive zero weight.\nThe total charge conservation is also guaranteed by the tensor product structure:\n$$\n\\sum_{l=0}^{1} \\sum_{m=0}^{1} \\sum_{p=0}^{1} w_{i+l,j+m,k+p} = \\left( \\sum_{l=0}^{1} W_l(u_x) \\right) \\left( \\sum_{m=0}^{1} W_m(u_y) \\right) \\left( \\sum_{p=0}^{1} W_p(u_z) \\right)\n$$\nSince each sum in parentheses equals $1$, the total sum of all eight weights is $1 \\times 1 \\times 1 = 1$.\n\nWe now list the explicit expressions for the eight weights $w_n$ for $n=1, \\dots, 8$, corresponding to the specified node ordering.\nFor node $(i,j,k)$, we have $(l,m,p)=(0,0,0)$, so the weight is $w_1 = W_0(u_x)W_0(u_y)W_0(u_z) = (1-u_x)(1-u_y)(1-u_z)$.\nFor node $(i+1,j,k)$, we have $(l,m,p)=(1,0,0)$, so the weight is $w_2 = W_1(u_x)W_0(u_y)W_0(u_z) = u_x(1-u_y)(1-u_z)$.\nFor node $(i,j+1,k)$, we have $(l,m,p)=(0,1,0)$, so the weight is $w_3 = W_0(u_x)W_1(u_y)W_0(u_z) = (1-u_x)u_y(1-u_z)$.\nFor node $(i+1,j+1,k)$, we have $(l,m,p)=(1,1,0)$, so the weight is $w_4 = W_1(u_x)W_1(u_y)W_0(u_z) = u_x u_y (1-u_z)$.\nFor node $(i,j,k+1)$, we have $(l,m,p)=(0,0,1)$, so the weight is $w_5 = W_0(u_x)W_0(u_y)W_1(u_z) = (1-u_x)(1-u_y)u_z$.\nFor node $(i+1,j,k+1)$, we have $(l,m,p)=(1,0,1)$, so the weight is $w_6 = W_1(u_x)W_0(u_y)W_1(u_z) = u_x(1-u_y)u_z$.\nFor node $(i,j+1,k+1)$, we have $(l,m,p)=(0,1,1)$, so the weight is $w_7 = W_0(u_x)W_1(u_y)W_1(u_z) = (1-u_x)u_y u_z$.\nFor node $(i+1,j+1,k+1)$, we have $(l,m,p)=(1,1,1)$, so the weight is $w_8 = W_1(u_x)W_1(u_y)W_1(u_z) = u_x u_y u_z$.\n\nThese eight expressions constitute the derived Cloud-In-Cell assignment weights. They represent the fraction of the particle's charge $q$ that is assigned to each of the eight surrounding grid nodes.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n(1-u_x)(1-u_y)(1-u_z) & u_x(1-u_y)(1-u_z) & (1-u_x)u_y(1-u_z) & u_x u_y (1-u_z) & (1-u_x)(1-u_y)u_z & u_x(1-u_y)u_z & (1-u_x)u_y u_z & u_x u_y u_z\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "After mapping charges to the grid, the PME method transitions to reciprocal space via the Fast Fourier Transform (FFT) to solve for the long-range potential. This computational step does not operate on a continuous Fourier space but on a discrete set of wavevectors, $\\mathbf{k}$, determined by the simulation cell's periodicity and the mesh's resolution. This practice  guides you through the derivation of this discrete $\\mathbf{k}$-space grid, clarifying the connection between the physical system and its numerical representation in the FFT-based solver.",
            "id": "3849514",
            "problem": "In multiscale materials simulation, the Particle Mesh Ewald (PME) method accelerates the reciprocal-space component of the Ewald summation by interpolating charges onto a mesh and evaluating the resulting convolution via the Fast Fourier Transform (FFT). Consider a three-dimensional cubic periodic cell of side length $L$ and a uniform mesh of $M$ points along each Cartesian direction. Starting from the foundational representation of a spatially periodic function by a Fourier series, and using periodic boundary conditions, derive the set of discrete reciprocal-space wavevectors sampled by the FFT when the domain is discretized on an $M \\times M \\times M$ mesh. Your derivation should be based on the facts that a function periodic with period $L$ in each direction admits Fourier modes with integer multiples of a fundamental wavevector and that discretization on a uniform mesh of $M$ points per direction imposes a finite bandlimit determined by the sampling theorem.\n\nThen, for a cubic cell with $L=4\\,\\mathrm{nm}$ and a mesh with $M=64$, determine the smallest nonzero magnitude of the discrete wavevector in the reciprocal-space grid associated with the FFT sampling. Round your final numeric magnitude to four significant figures and express it in $\\mathrm{nm}^{-1}$.",
            "solution": "The problem is valid and can be solved by applying the principles of Fourier analysis to a periodic, discretized domain. The derivation proceeds in two stages, followed by a numerical calculation. First, we establish the wavevectors compatible with the periodic boundary conditions of the real-space cell. Second, we apply the constraints imposed by the discretization of this cell onto a finite mesh, as sampled by the Fast Fourier Transform (FFT).\n\nLet the three-dimensional cubic periodic cell have a side length of $L$. A function $f(\\mathbf{r})$ defined within this volume and subject to periodic boundary conditions must satisfy $f(\\mathbf{r} + \\mathbf{R}) = f(\\mathbf{r})$, where $\\mathbf{R}$ is any lattice vector of the simulation cell. For a cubic cell, these lattice vectors are of the form $\\mathbf{R} = L(n_x \\mathbf{e}_x + n_y \\mathbf{e}_y + n_z \\mathbf{e}_z)$ for any integers $n_x, n_y, n_z$, where $\\mathbf{e}_j$ are the Cartesian unit vectors.\n\nAs stated in the problem, such a spatially periodic function can be represented by a Fourier series, which is a sum over plane waves:\n$$f(\\mathbf{r}) = \\sum_{\\mathbf{k}} \\hat{f}(\\mathbf{k}) \\exp(i \\mathbf{k} \\cdot \\mathbf{r})$$\nThe basis functions $\\exp(i \\mathbf{k} \\cdot \\mathbf{r})$ must themselves satisfy the periodic boundary conditions. For any basis vector of the real-space lattice, for instance $L\\mathbf{e}_x$, we must have:\n$$\\exp(i \\mathbf{k} \\cdot (\\mathbf{r} + L\\mathbf{e}_x)) = \\exp(i \\mathbf{k} \\cdot \\mathbf{r})$$\nThis implies that $\\exp(i \\mathbf{k} \\cdot L\\mathbf{e}_x) = 1$, which simplifies to $\\exp(i k_x L) = 1$. This condition is satisfied if and only if the argument of the exponential is an integer multiple of $2\\pi$. That is, $k_x L = 2\\pi h_x$ for some integer $h_x$. Applying this requirement to all three Cartesian directions, we find the components of the allowed wavevectors $\\mathbf{k}$:\n$$k_x = \\frac{2\\pi}{L}h_x, \\quad k_y = \\frac{2\\pi}{L}h_y, \\quad k_z = \\frac{2\\pi}{L}h_z$$\nwhere $h_x, h_y, h_z \\in \\mathbb{Z}$. The set of all such vectors $\\mathbf{k} = \\frac{2\\pi}{L}(h_x, h_y, h_z)$ forms the reciprocal lattice. The fundamental wavevector has magnitude $\\frac{2\\pi}{L}$, and all allowed modes are integer multiples thereof.\n\nNext, we consider the discretization of the real-space domain onto a uniform $M \\times M \\times M$ mesh. The grid points are located at positions $\\mathbf{r}_{\\mathbf{n}} = (\\frac{n_x L}{M}, \\frac{n_y L}{M}, \\frac{n_z L}{M})$, where the indices $n_x, n_y, n_z$ are integers running from $0$ to $M-1$. The Particle Mesh Ewald (PME) method evaluates sums over reciprocal space by using the Discrete Fourier Transform (DFT), which is efficiently computed via the FFT algorithm.\n\nThe DFT operates on the values of the function at the discrete grid points $f(\\mathbf{r}_{\\mathbf{n}})$. According to the Nyquist-Shannon sampling theorem, sampling a function at a finite number of points imposes a bandlimit on the frequencies (or wavevectors) that can be uniquely resolved. Any wavevector $\\mathbf{k}$ is aliased with an infinite set of other wavevectors $\\mathbf{k}'$ if they are indistinguishable on the grid, i.e., if $\\exp(i \\mathbf{k} \\cdot \\mathbf{r}_{\\mathbf{n}}) = \\exp(i \\mathbf{k}' \\cdot \\mathbf{r}_{\\mathbf{n}})$ for all grid points $\\mathbf{r}_{\\mathbf{n}}$. This condition is equivalent to $\\exp(i (\\mathbf{k}' - \\mathbf{k}) \\cdot \\mathbf{r}_{\\mathbf{n}}) = 1$.\n\nIn our case, the wavevectors are of the form $\\mathbf{k} = \\frac{2\\pi}{L}(h_x, h_y, h_z)$. The condition for aliasing becomes:\n$$\\exp\\left(i \\left( \\frac{2\\pi}{L}(\\Delta h_x, \\Delta h_y, \\Delta h_z) \\right) \\cdot \\left( \\frac{L}{M}(n_x, n_y, n_z) \\right) \\right) = 1$$\n$$\\exp\\left(i \\frac{2\\pi}{M} (\\Delta h_x n_x + \\Delta h_y n_y + \\Delta h_z n_z) \\right) = 1$$\nFor this to hold for all integer combinations of $n_x, n_y, n_z$ from $0$ to $M-1$, the integer differences $\\Delta h_x, \\Delta h_y, \\Delta h_z$ must be integer multiples of $M$. This means that wavevectors whose integer indices $(h_x, h_y, h_z)$ differ by a multiple of $M$ in any component are equivalent on the grid.\n\nTherefore, the DFT samples a unique, finite set of $M^3$ wavevectors. This set is formed by choosing a primitive cell of the \"aliasing lattice\". A conventional and symmetric choice for the $M$ unique integer indices in each direction, for an even $M$, is the set $\\{ -M/2, -M/2+1, \\dots, M/2-1 \\}$.\nThe set of discrete reciprocal-space wavevectors $\\mathcal{K}$ sampled by the FFT is thus:\n$$\\mathcal{K} = \\left\\{ \\mathbf{k} = \\frac{2\\pi}{L}(m_x, m_y, m_z) \\mid m_x, m_y, m_z \\in \\left\\{-\\frac{M}{2}, -\\frac{M}{2}+1, \\dots, \\frac{M}{2}-1\\right\\} \\right\\}$$\nThis completes the derivation.\n\nNow, we must determine the smallest nonzero magnitude of a vector in this set for the given parameters $L=4\\,\\mathrm{nm}$ and $M=64$.\nWith $M=64$, the integer indices $m_x, m_y, m_z$ for the wavevectors are in the set:\n$$m_j \\in \\left\\{-\\frac{64}{2}, \\dots, \\frac{64}{2}-1\\right\\} = \\{-32, -31, \\dots, 31\\}$$\nThe magnitude squared of a wavevector $\\mathbf{k}$ is given by:\n$$|\\mathbf{k}|^2 = k_x^2 + k_y^2 + k_z^2 = \\left(\\frac{2\\pi}{L}\\right)^2 (m_x^2 + m_y^2 + m_z^2)$$\nTo find the smallest nonzero magnitude, we must find the smallest nonzero value of the sum of squares $S = m_x^2 + m_y^2 + m_z^2$. The vector is nonzero if and only if at least one of $m_x, m_y, m_z$ is nonzero. The smallest possible nonzero integer value for any $m_j^2$ is $(\\pm 1)^2 = 1$. The minimum nonzero value for the sum $S$ is obtained by setting one of the indices to $\\pm 1$ and the other two to $0$. For example, we can choose $(m_x, m_y, m_z) = (1, 0, 0)$. Since $1$ and $0$ are both in the allowed set of indices $\\{-32, \\dots, 31\\}$, this is a valid choice.\nFor this choice, the minimum nonzero sum of squares is:\n$$S_{\\min} = 1^2 + 0^2 + 0^2 = 1$$\nThe smallest nonzero magnitude squared is then:\n$$|\\mathbf{k}|_{\\min}^2 = \\left(\\frac{2\\pi}{L}\\right)^2 S_{\\min} = \\left(\\frac{2\\pi}{L}\\right)^2 (1) = \\frac{4\\pi^2}{L^2}$$\nThe smallest nonzero magnitude is the square root:\n$$|\\mathbf{k}|_{\\min} = \\sqrt{\\frac{4\\pi^2}{L^2}} = \\frac{2\\pi}{L}$$\nSubstituting the given value $L = 4\\,\\mathrm{nm}$:\n$$|\\mathbf{k}|_{\\min} = \\frac{2\\pi}{4\\,\\mathrm{nm}} = \\frac{\\pi}{2}\\,\\mathrm{nm}^{-1}$$\nTo provide a numerical answer, we evaluate this expression and round to four significant figures:\n$$|\\mathbf{k}|_{\\min} \\approx 1.570796... \\,\\mathrm{nm}^{-1}$$\nRounding this result to four significant figures gives $1.571\\,\\mathrm{nm}^{-1}$.",
            "answer": "$$ \\boxed{1.571} $$"
        },
        {
            "introduction": "Having established how to map charges onto a mesh and how the corresponding reciprocal space is structured, we can now synthesize these components into a working algorithm. This final, capstone practice  challenges you to implement the complete reciprocal-space portion of the PME method, from charge assignment to force interpolation. By translating the theoretical steps into a functional code, you will gain invaluable hands-on insight into the operational details of how PME efficiently computes long-range forces.",
            "id": "3282499",
            "problem": "You are to implement a simplified three-dimensional Particle Mesh Ewald (PME) method using the Fast Fourier Transform (FFT) to evaluate long-range electrostatic forces in a periodic cubic domain. The goal is to compute particle forces arising from the reciprocal-space (long-range) component only, under periodic boundary conditions and dimensionless units. The implementation must be fully self-contained and strictly use the Fast Fourier Transform (FFT) as the computational accelerator.\n\nThe computational domain is a periodic cube with side length $L=1$. All positions are given in reduced coordinates within $[0,1)$, all charges are dimensionless, and forces must be returned in dimensionless units. No physical unit conversion is required or permitted. Angle units are not applicable in this setting.\n\nYou must start from foundational principles and definitions of the discrete Fourier transform and Poisson’s equation, but the problem statement does not provide any shortcut formulas for the PME implementation. Your approach must be derived from first principles: map charges to a mesh, compute the potential in reciprocal space via FFTs and a screened Green’s function, differentiate in Fourier space to obtain the electric field, transform back to real space, and interpolate forces at particle locations.\n\nAlgorithmic specification:\n- The domain is a periodic cube of side length $L=1$ discretized on a uniform grid with $N \\times N \\times N$ points.\n- Use Cloud-In-Cell (CIC) charge assignment to place particle charges onto the mesh.\n- Use a three-dimensional Fast Fourier Transform (FFT) to transform the mesh charge density to reciprocal space.\n- Apply a screened reciprocal-space Green’s function characterized by a positive screening parameter $\\alpha$ to compute the long-range potential. The zero mode $\\mathbf{k}=\\mathbf{0}$ must be set to zero to enforce neutrality of the periodic cell.\n- Compute the electric field by differentiating the potential in reciprocal space.\n- Use the inverse FFT to return to real space and interpolate the electric field at particle positions using the same CIC weights. The force on particle $i$ is $q_i$ times the interpolated electric field at its position.\n- Use strictly dimensionless quantities throughout.\n\nTest suite:\nImplement your program to run exactly the following four test cases without any user input. For each case, $N$ denotes the grid size, $\\alpha$ denotes the screening parameter, $q_i$ are particle charges, and $\\mathbf{r}_i$ are particle positions in reduced coordinates in the unit cube.\n1. Happy path case: $N=16$, $\\alpha=3.5$, two particles with charges $[1.0,-1.0]$ at positions $\\mathbf{r}_1=[0.25,0.25,0.25]$, $\\mathbf{r}_2=[0.75,0.75,0.75]$.\n2. Boundary placement case: $N=16$, $\\alpha=2.5$, three particles with charges $[1.0,-0.5,0.5]$ at positions $\\mathbf{r}_1=[0.99,0.01,0.5]$, $\\mathbf{r}_2=[0.1,0.9,0.1]$, $\\mathbf{r}_3=[0.4,0.4,0.95]$.\n3. Edge case with zero charges: $N=8$, $\\alpha=2.0$, four particles with charges $[0.0,0.0,0.0,0.0]$ at positions $\\mathbf{r}_1=[0.2,0.3,0.4]$, $\\mathbf{r}_2=[0.6,0.2,0.1]$, $\\mathbf{r}_3=[0.8,0.8,0.8]$, $\\mathbf{r}_4=[0.1,0.7,0.9]$.\n4. Symmetric arrangement case: $N=32$, $\\alpha=3.0$, four particles with charges $[1.0,1.0,-1.0,-1.0]$ at positions $\\mathbf{r}_1=[0.25,0.25,0.5]$, $\\mathbf{r}_2=[0.75,0.25,0.5]$, $\\mathbf{r}_3=[0.25,0.75,0.5]$, $\\mathbf{r}_4=[0.75,0.75,0.5]$.\n\nRequired output:\nFor each test case, output a list of particle force vectors, where each force vector is a list of three floating-point numbers $[F_x,F_y,F_z]$ in dimensionless units. Aggregate the four per-case lists into a single list. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets and with no spaces, where each element is itself a list of force vectors (for example, $[[[F_{x,1},F_{y,1},F_{z,1}],\\ldots],\\ldots]$).\n\nYour implementation must:\n- Use only the Python standard library and the NumPy library.\n- Be deterministic and require no input.\n- Handle periodic boundary conditions consistently in both charge assignment and field interpolation.\n- Use three-dimensional FFTs to compute the reciprocal-space solution.",
            "solution": "The problem requires the implementation of a simplified three-dimensional Particle Mesh Ewald (PME) method to compute the long-range component of electrostatic forces on a set of charged particles within a periodic cubic domain. The solution must be derived from foundational principles.\n\n### 1. Foundational Principles: Electrostatics in Reciprocal Space\n\nThe fundamental relationship between the electrostatic potential $\\phi(\\mathbf{r})$ and the charge density $\\rho(\\mathbf{r})$ is given by Poisson's equation. In the dimensionless units specified for this problem, we write:\n$$\n\\nabla^2 \\phi(\\mathbf{r}) = -\\rho(\\mathbf{r})\n$$\nThe electric field $\\mathbf{E}(\\mathbf{r})$ is the negative gradient of the potential:\n$$\n\\mathbf{E}(\\mathbf{r}) = -\\nabla \\phi(\\mathbf{r})\n$$\nThe system is defined in a cubic box of side length $L=1$ with periodic boundary conditions. Such problems are naturally handled using Fourier series, which for computational purposes become Discrete Fourier Transforms (DFTs). A function $f(\\mathbf{r})$ on the periodic domain can be represented by its Fourier coefficients $\\tilde{f}(\\mathbf{k})$:\n$$\nf(\\mathbf{r}) = \\sum_{\\mathbf{k}} \\tilde{f}(\\mathbf{k}) \\exp(i\\mathbf{k} \\cdot \\mathbf{r})\n$$\nwhere the wave vectors $\\mathbf{k}$ are discrete due to periodicity: $\\mathbf{k} = \\frac{2\\pi}{L}(n_x, n_y, n_z) = 2\\pi(n_x, n_y, n_z)$ since $L=1$, and $n_x, n_y, n_z$ are integers.\n\nIn Fourier space, the gradient operator $\\nabla$ transforms into multiplication by $i\\mathbf{k}$, and the Laplacian $\\nabla^2$ transforms into multiplication by $-|\\mathbf{k}|^2$. Applying the Fourier transform to the governing equations yields their algebraic counterparts:\n$$\n-|\\mathbf{k}|^2 \\tilde{\\phi}(\\mathbf{k}) = -\\tilde{\\rho}(\\mathbf{k}) \\implies \\tilde{\\phi}(\\mathbf{k}) = \\frac{\\tilde{\\rho}(\\mathbf{k})}{|\\mathbf{k}|^2}\n$$\n$$\n\\tilde{\\mathbf{E}}(\\mathbf{k}) = -i\\mathbf{k} \\tilde{\\phi}(\\mathbf{k})\n$$\n\n### 2. The Particle Mesh Ewald (PME) Method\n\nThe PME method provides an efficient way to calculate long-range forces by solving for a smoothed potential on a grid. The core idea of the Ewald split is to replace point charges with a superposition of two distributions: a localized one for short-range interactions (not part of this problem) and a smooth, long-ranged one for reciprocal-space calculation. The smooth distribution is typically a Gaussian cloud for each particle.\n\nThe effect of this smoothing in reciprocal space is the introduction of a damping factor into the potential calculation. The \"screened reciprocal-space Green's function\" specified in the problem combines the $1/|\\mathbf{k}|^2$ term from Poisson's equation with a Gaussian factor dependent on the screening parameter $\\alpha$. The Fourier-space potential is thus calculated as:\n$$\n\\tilde{\\phi}(\\mathbf{k}) = \\tilde{G}(\\mathbf{k}) \\tilde{\\rho}(\\mathbf{k})\n$$\nwhere $\\tilde{\\rho}(\\mathbf{k})$ is the Fourier transform of the charge density on the grid and $\\tilde{G}(\\mathbf{k})$ is the PME reciprocal-space kernel (or Green's function):\n$$\n\\tilde{G}(\\mathbf{k}) = \\frac{\\exp(-|\\mathbf{k}|^2 / (4\\alpha^2))}{|\\mathbf{k}|^2}\n$$\nFor $\\mathbf{k} = \\mathbf{0}$, the denominator $|\\mathbf{k}|^2$ is zero, leading to a singularity. This term corresponds to the average potential of the system. For a system with overall charge neutrality in a periodic box, this term's contribution to the force is zero. The problem mandates setting the $\\mathbf{k}=\\mathbf{0}$ mode to zero, which is the standard procedure. Thus, we define $\\tilde{G}(\\mathbf{0}) = 0$.\n\n### 3. Discretization and Algorithmic Steps\n\nThe continuous fields are discretized on a uniform $N \\times N \\times N$ grid. Continuous Fourier transforms are replaced by DFTs, which are computed efficiently using the Fast Fourier Transform (FFT) algorithm. Let the grid spacing be $h = L/N = 1/N$.\n\n#### Step 1: Charge Assignment\nParticle charges, which are delta functions in the continuous representation, must be transferred to the discrete grid. The Cloud-in-Cell (CIC) or trilinear interpolation scheme is used. For a particle $i$ with charge $q_i$ at reduced position $\\mathbf{r}_i = (u_i, v_i, w_i) \\in [0,1)^3$, its scaled coordinates are $\\mathbf{s}_i = N\\mathbf{r}_i$. The integer part of $\\mathbf{s}_i$ identifies the primary grid cell, $\\mathbf{n}_i = (\\lfloor s_{ix} \\rfloor, \\lfloor s_{iy} \\rfloor, \\lfloor s_{iz} \\rfloor)$, and the fractional part gives the displacement within that cell, $\\mathbf{d}_i = \\mathbf{s}_i - \\mathbf{n}_i$.\n\nThe charge $q_i$ is distributed to the $8$ corners of the cell containing $\\mathbf{s}_i$. The charge assigned to a corner at offset $(\\delta_x, \\delta_y, \\delta_z)$ from $\\mathbf{n}_i$ (where $\\delta_j \\in \\{0,1\\}$) is:\n$$\n\\Delta\\rho = q_i \\cdot W_x(\\delta_x) \\cdot W_y(\\delta_y) \\cdot W_z(\\delta_z)\n$$\nwhere the weighting factors are $W_j(\\delta_j) = (1-d_{ij})^{1-\\delta_j} d_{ij}^{\\delta_j}$. This procedure is performed for all particles, accumulating charges on the grid $\\rho_{\\text{grid}}$. Grid indices are taken modulo $N$ to enforce periodicity.\n\n#### Step 2: Fourier Transform of Charge Density\nThe gridded charge density $\\rho_{\\text{grid}}$ is transformed to reciprocal space using a 3D FFT:\n$$\n\\tilde{\\rho}(\\mathbf{k}) = \\text{FFT3D}[\\rho_{\\text{grid}}]\n$$\n\n#### Step 3: Reciprocal Space Calculation\nThe potential and electric field are computed in Fourier space.\nFirst, the grid of discrete wave vectors $\\mathbf{k} = 2\\pi(n_x, n_y, n_z)$ is constructed, where $n_x, n_y, n_z$ are the integer frequencies corresponding to the FFT grid indices.\nThen, the Green's function $\\tilde{G}(\\mathbf{k})$ is computed for all $\\mathbf{k}$, with $\\tilde{G}(\\mathbf{0})=0$.\nThe potential is found by element-wise multiplication:\n$$\n\\tilde{\\phi}(\\mathbf{k}) = \\tilde{G}(\\mathbf{k}) \\tilde{\\rho}(\\mathbf{k})\n$$\nThe electric field components are then calculated:\n$$\n\\tilde{E}_x(\\mathbf{k}) = -i k_x \\tilde{\\phi}(\\mathbf{k}) \\quad ; \\quad \\tilde{E}_y(\\mathbf{k}) = -i k_y \\tilde{\\phi}(\\mathbf{k}) \\quad ; \\quad \\tilde{E}_z(\\mathbf{k}) = -i k_z \\tilde{\\phi}(\\mathbf{k})\n$$\n\n#### Step 4: Inverse Fourier Transform\nThe electric field on the grid, $\\mathbf{E}_{\\text{grid}}$, is obtained by applying the inverse 3D FFT to each component of $\\tilde{\\mathbf{E}}(\\mathbf{k})$:\n$$\n\\mathbf{E}_{\\text{grid}}(\\mathbf{r}) = \\text{iFFT3D}[\\tilde{\\mathbf{E}}(\\mathbf{k})]\n$$\nThe result of the iFFT will be a complex array; the physical field is its real part.\n\n#### Step 5: Force Interpolation and Calculation\nTo find the force on each particle, the electric field must be interpolated from the grid back to the particle's position. For consistency and to ensure momentum conservation (i.e., $\\mathbf{F}_{ij} = -\\mathbf{F}_{ji}$), the same CIC interpolation scheme used for charge assignment is applied. The electric field at particle $i$'s position $\\mathbf{r}_i$ is a weighted average of the field values at the $8$ surrounding grid points:\n$$\n\\mathbf{E}(\\mathbf{r}_i) = \\sum_{\\text{8 neighbors } \\mathbf{g}} \\mathbf{E}_{\\text{grid}}(\\mathbf{g}) \\cdot W(\\mathbf{r}_i, \\mathbf{g})\n$$\nwhere the weights $W$ are the same trilinear weights from Step 1.\nFinally, the force on particle $i$ is calculated as:\n$$\n\\mathbf{F}_i = q_i \\mathbf{E}(\\mathbf{r}_i)\n$$\nThis process is repeated for all particles and for each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef format_list_no_spaces(item):\n    \"\"\"\n    Recursively formats a nested list or numpy array into a string\n    with no spaces, as per the strict output format requirement.\n    \"\"\"\n    if isinstance(item, (list, np.ndarray)):\n        return \"[\" + \",\".join(format_list_no_spaces(x) for x in item) + \"]\"\n    return str(item)\n\ndef solve_pme_case(N, alpha, charges, positions):\n    \"\"\"\n    Computes reciprocal-space electrostatic forces for one test case.\n    \"\"\"\n    # Box length L=1 is assumed throughout.\n    L = 1.0\n    \n    # Step 1: Charge Assignment (CIC)\n    rho = np.zeros((N, N, N), dtype=float)\n    num_particles = len(charges)\n    # Store particle info for interpolation later\n    particle_info = []\n\n    for i in range(num_particles):\n        q_i = charges[i]\n        r_i = np.array(positions[i]) # Reduced coordinates [0, 1)\n\n        s_i = r_i * N\n        n_i = np.floor(s_i).astype(int)\n        d_i = s_i - n_i\n\n        particle_info.append({'n': n_i, 'd': d_i})\n\n        for dz in range(2):\n            wz = (1 - d_i[2]) if dz == 0 else d_i[2]\n            z_idx = (n_i[2] + dz) % N\n            for dy in range(2):\n                wy = (1 - d_i[1]) if dy == 0 else d_i[1]\n                y_idx = (n_i[1] + dy) % N\n                for dx in range(2):\n                    wx = (1 - d_i[0]) if dx == 0 else d_i[0]\n                    x_idx = (n_i[0] + dx) % N\n                    \n                    weight = wx * wy * wz\n                    rho[z_idx, y_idx, x_idx] += q_i * weight\n    \n    # Step 2: FFT of charge density\n    rho_k = np.fft.fftn(rho)\n\n    # Step 3: Reciprocal Space Calculation\n    # Generate wave vectors k\n    kx_int = np.fft.fftfreq(N) * N\n    ky_int = np.fft.fftfreq(N) * N\n    kz_int = np.fft.fftfreq(N) * N\n    \n    kx = 2 * np.pi * kx_int / L\n    ky = 2 * np.pi * ky_int / L\n    kz = 2 * np.pi * kz_int / L\n    \n    kz_grid, ky_grid, kx_grid = np.meshgrid(kz, ky, kx, indexing='ij')\n\n    k_squared = kx_grid**2 + ky_grid**2 + kz_grid**2\n    \n    # Calculate reciprocal Green's function G_k\n    G_k = np.zeros((N, N, N), dtype=float)\n    # Avoid division by zero at k=0\n    non_zero_k = k_squared != 0\n    G_k[non_zero_k] = np.exp(-k_squared[non_zero_k] / (4 * alpha**2)) / k_squared[non_zero_k]\n    # k=0 mode is explicitly set to 0. It is already 0 from initialization.\n\n    # Calculate potential and field in Fourier space\n    phi_k = G_k * rho_k\n    \n    Ex_k = -1j * kx_grid * phi_k\n    Ey_k = -1j * ky_grid * phi_k\n    Ez_k = -1j * kz_grid * phi_k\n\n    # Step 4: Inverse FFT to get E-field on the grid\n    Ex_grid = np.real(np.fft.ifftn(Ex_k))\n    Ey_grid = np.real(np.fft.ifftn(Ey_k))\n    Ez_grid = np.real(np.fft.ifftn(Ez_k))\n\n    # Step 5 and 6: Force Interpolation and Calculation\n    forces = []\n    for i in range(num_particles):\n        q_i = charges[i]\n        n_i = particle_info[i]['n']\n        d_i = particle_info[i]['d']\n        \n        E_interp = np.zeros(3, dtype=float)\n        \n        for dz in range(2):\n            wz = (1 - d_i[2]) if dz == 0 else d_i[2]\n            z_idx = (n_i[2] + dz) % N\n            for dy in range(2):\n                wy = (1 - d_i[1]) if dy == 0 else d_i[1]\n                y_idx = (n_i[1] + dy) % N\n                for dx in range(2):\n                    wx = (1 - d_i[0]) if dx == 0 else d_i[0]\n                    x_idx = (n_i[0] + dx) % N\n\n                    weight = wx * wy * wz\n                    E_interp[0] += Ex_grid[z_idx, y_idx, x_idx] * weight\n                    E_interp[1] += Ey_grid[z_idx, y_idx, x_idx] * weight\n                    E_interp[2] += Ez_grid[z_idx, y_idx, x_idx] * weight\n        \n        force_i = q_i * E_interp\n        forces.append(force_i.tolist())\n    \n    return forces\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 16, \"alpha\": 3.5, \"charges\": [1.0, -1.0],\n            \"positions\": [[0.25, 0.25, 0.25], [0.75, 0.75, 0.75]]\n        },\n        {\n            \"N\": 16, \"alpha\": 2.5, \"charges\": [1.0, -0.5, 0.5],\n            \"positions\": [[0.99, 0.01, 0.5], [0.1, 0.9, 0.1], [0.4, 0.4, 0.95]]\n        },\n        {\n            \"N\": 8, \"alpha\": 2.0, \"charges\": [0.0, 0.0, 0.0, 0.0],\n            \"positions\": [[0.2, 0.3, 0.4], [0.6, 0.2, 0.1], [0.8, 0.8, 0.8], [0.1, 0.7, 0.9]]\n        },\n        {\n            \"N\": 32, \"alpha\": 3.0, \"charges\": [1.0, 1.0, -1.0, -1.0],\n            \"positions\": [[0.25, 0.25, 0.5], [0.75, 0.25, 0.5], [0.25, 0.75, 0.5], [0.75, 0.75, 0.5]]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_pme_case(case[\"N\"], case[\"alpha\"], case[\"charges\"], case[\"positions\"])\n        results.append(result)\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_list_no_spaces(results))\n\nsolve()\n```"
        }
    ]
}