{
    "hands_on_practices": [
        {
            "introduction": "At the heart of any molecular dynamics simulation is the numerical integrator that propagates the system through time. This exercise contrasts the long-term energy conservation behavior of a symplectic integrator (Velocity Verlet), which is standard in MD, with a general-purpose, non-symplectic integrator (Runge-Kutta 4). By implementing and testing both, you will gain a firsthand understanding of why symplectic methods are essential for maintaining the stability and physical realism of long-term MD simulations .",
            "id": "3805850",
            "problem": "You are given a separable Hamiltonian dynamical system with one Cartesian degree of freedom, defined by the Hamiltonian $H(x,p) = T(p) + V(x)$, where $T(p) = \\frac{p^2}{2m}$ and $V(x)$ is a scalar potential energy. The canonical equations of motion are equivalent to Newton's second law with $p = m v$ and $m \\ddot{x} = -\\frac{\\partial V}{\\partial x}$. The total energy $H(x,p)$ should be conserved for exact dynamics. Your task is to implement two time-stepping algorithms for this separable Hamiltonian system, simulate long-time dynamics for several test cases, and quantify the energy drift for each integrator. The two algorithms to compare are: the velocity Verlet method, which is a symplectic composition method for separable Hamiltonians, and the classical fourth-order Runge–Kutta method (Runge–Kutta 4), which is a non-symplectic general-purpose ordinary differential equation integrator. You must base your implementation on the fundamental laws and core definitions stated above, without using any pre-derived formulas that target the final result.\n\nDefinitions and requirements:\n- The state variables are $x(t)$ and $v(t)$, where $v(t) = \\dot{x}(t)$ and $p(t) = m v(t)$.\n- The force is $F(x) = -\\frac{\\partial V}{\\partial x}$ and the acceleration is $a(x) = \\frac{F(x)}{m}$.\n- The total energy is $H(x,p) = \\frac{p^2}{2m} + V(x) = \\frac{1}{2} m v^2 + V(x)$.\n- The velocity Verlet update at time step size $\\Delta t$ advances $(x_n, v_n)$ to $(x_{n+1}, v_{n+1})$ using the sequence: half-step velocity update, position update, and another half-step velocity update, with acceleration evaluated at positions $x_n$ and $x_{n+1}$.\n- The Runge–Kutta 4 update advances the state vector $y = [x, v]^\\top$ via four staged evaluations of the right-hand side $f(y) = [v, a(x)]^\\top$ and a weighted average to produce $y_{n+1}$.\n\nEnergy drift metric:\n- For a given integrator, time step $\\Delta t$, total simulation time $T$, and initial conditions $(x(0), v(0))$, integrate the system and record the total energy $H(t_i)$ at each discrete time $t_i = i \\Delta t$ for $i = 0, 1, \\dots, N$ where $N = \\lfloor T / \\Delta t \\rfloor$.\n- Define the energy deviation $E_i = H(t_i) - H(0)$.\n- Compute the best-fit linear drift rate $s$ (in Joules per second) by least squares regression of $E_i$ versus $t_i$, i.e., find $s$ that minimizes $\\sum_{i=0}^N (E_i - s t_i - b)^2$ over $s$ and $b$, and report the slope $s$. Explicitly, let $\\bar{t} = \\frac{1}{N+1} \\sum_{i=0}^N t_i$ and $\\bar{E} = \\frac{1}{N+1} \\sum_{i=0}^N E_i$, then compute $$s = \\frac{\\sum_{i=0}^N (t_i - \\bar{t})(E_i - \\bar{E})}{\\sum_{i=0}^N (t_i - \\bar{t})^2}.$$\n\nPotentials and units:\n- Use two potentials, both separable in the sense $H = T(p) + V(x)$:\n  1. Harmonic potential: $V(x) = \\frac{1}{2} k x^2$, with force $F(x) = -k x$.\n  2. Anharmonic quartic potential: $V(x) = \\frac{1}{2} k x^2 + \\frac{1}{4} \\alpha x^4$, with force $F(x) = -k x - \\alpha x^3$.\n- All physical quantities are in SI units: mass in kilograms (kg), position in meters (m), time in seconds (s), spring constant $k$ in newtons per meter (N/m), quartic coefficient $\\alpha$ in newtons per cubic meter (N/m$^3$), and energy in joules (J). The drift rate must be reported in joules per second (J/s).\n\nImplement both integrators, simulate, and compute the drift rates for each case in the test suite below. No external input is allowed; your program must be self-contained. Use double-precision floating point arithmetic.\n\nTest suite:\n- Case A (moderate time step, harmonic oscillator):\n  - $m = 1$ kg, $k = 1$ N/m, initial condition $x(0) = 1$ m, $v(0) = 0$ m/s.\n  - Time step $\\Delta t = 0.05$ s.\n  - Total simulation time $T = 100 \\times 2\\pi \\sqrt{m/k}$ s.\n- Case B (near stability boundary time step, harmonic oscillator):\n  - $m = 1$ kg, $k = 1$ N/m, initial condition $x(0) = 1$ m, $v(0) = 0$ m/s.\n  - Time step $\\Delta t = 1.9$ s.\n  - Total simulation time $T = 400$ s.\n- Case C (anharmonic quartic potential, moderate time step):\n  - $m = 1$ kg, $k = 1$ N/m, $\\alpha = 1$ N/m$^3$, initial condition $x(0) = 1$ m, $v(0) = 0$ m/s.\n  - Time step $\\Delta t = 0.01$ s.\n  - Total simulation time $T = 200$ s.\n- Case D (stiff harmonic oscillator, many periods):\n  - $m = 1$ kg, $k = 100$ N/m, initial condition $x(0) = 0.1$ m, $v(0) = 0$ m/s.\n  - Time step $\\Delta t = 0.02$ s.\n  - Total simulation time $T = 100 \\times 2\\pi \\sqrt{m/k}$ s.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and must be a two-element list $[s_{\\mathrm{RK4}}, s_{\\mathrm{VV}}]$ in joules per second, ordered as Cases A, B, C, D. For example: $[[s_A^{\\mathrm{RK4}}, s_A^{\\mathrm{VV}}],[s_B^{\\mathrm{RK4}}, s_B^{\\mathrm{VV}}],[s_C^{\\mathrm{RK4}}, s_C^{\\mathrm{VV}}],[s_D^{\\mathrm{RK4}}, s_D^{\\mathrm{VV}}]]$.",
            "solution": "The problem requires a comparative analysis of two numerical integration algorithms, the velocity Verlet method and the classical fourth-order Runge-Kutta method, in the context of a one-dimensional, separable Hamiltonian system. The primary goal is to quantify and compare the long-term energy conservation properties of these integrators by computing the rate of energy drift.\n\nThe validation of the problem statement proceeds as follows.\n\n**Step 1: Extract Givens**\n\n*   **System Definition**: A separable Hamiltonian system with $H(x,p) = T(p) + V(x)$, where $T(p) = \\frac{p^2}{2m}$ and $V(x)$ is a scalar potential.\n*   **Equations of Motion**: $p = mv$, $m \\ddot{x} = -\\frac{\\partial V}{\\partial x}$.\n*   **State Variables**: $x(t)$, $v(t) = \\dot{x}(t)$.\n*   **Force and Acceleration**: $F(x) = -\\frac{\\partial V}{\\partial x}$, $a(x) = \\frac{F(x)}{m}$.\n*   **Total Energy**: $H(x,p) = \\frac{1}{2} m v^2 + V(x)$.\n*   **Velocity Verlet (VV) Integrator**: Update from $(x_n, v_n)$ to $(x_{n+1}, v_{n+1})$ in three steps:\n    1.  Half-step velocity update.\n    2.  Full-step position update.\n    3.  Second half-step velocity update.\n*   **Runge-Kutta 4 (RK4) Integrator**: Update for state vector $y = [x, v]^\\top$ using the function $f(y) = [v, a(x)]^\\top$ and four staged evaluations.\n*   **Energy Drift Metric**:\n    *   Simulate for total time $T$ with time step $\\Delta t$, generating $N+1$ data points where $N = \\lfloor T / \\Delta t \\rfloor$.\n    *   Time points: $t_i = i \\Delta t$ for $i = 0, \\dots, N$.\n    *   Energy deviation: $E_i = H(t_i) - H(0)$.\n    *   Drift rate $s$: The slope from a linear least squares fit of $E_i$ versus $t_i$, given by the formula $s = \\frac{\\sum_{i=0}^N (t_i - \\bar{t})(E_i - \\bar{E})}{\\sum_{i=0}^N (t_i - \\bar{t})^2}$, where $\\bar{t} = \\frac{1}{N+1} \\sum_{i=0}^N t_i$ and $\\bar{E} = \\frac{1}{N+1} \\sum_{i=0}^N E_i$.\n*   **Potentials**:\n    1.  Harmonic: $V(x) = \\frac{1}{2} k x^2$, $F(x) = -k x$.\n    2.  Anharmonic Quartic: $V(x) = \\frac{1}{2} k x^2 + \\frac{1}{4} \\alpha x^4$, $F(x) = -k x - \\alpha x^3$.\n*   **Units**: SI units (kg, m, s, N/m, N/m$^3$, J, J/s).\n*   **Test Cases**:\n    *   Case A: Harmonic, $m=1$, $k=1$, $x(0)=1$, $v(0)=0$, $\\Delta t=0.05$, $T=100 \\times 2\\pi \\sqrt{m/k}$.\n    *   Case B: Harmonic, $m=1$, $k=1$, $x(0)=1$, $v(0)=0$, $\\Delta t=1.9$, $T=400$.\n    *   Case C: Anharmonic, $m=1$, $k=1$, $\\alpha=1$, $x(0)=1$, $v(0)=0$, $\\Delta t=0.01$, $T=200$.\n    *   Case D: Harmonic, $m=1$, $k=100$, $x(0)=0.1$, $v(0)=0$, $\\Delta t=0.02$, $T=100 \\times 2\\pi \\sqrt{m/k}$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is scientifically grounded, well-posed, and objective. It is based on fundamental principles of classical Hamiltonian mechanics and standard numerical methods for ordinary differential equations. The definitions of the integrators are standard, and the energy drift metric is a well-defined statistical measure. All parameters required for simulation and analysis are provided, and there are no internal contradictions. The problem is a standard exercise in computational physics designed to illustrate the superior long-term energy conservation of symplectic integrators (like velocity Verlet) compared to general-purpose non-symplectic integrators (like RK4) for Hamiltonian systems.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A complete, reasoned solution will be provided.\n\n**Solution Derivation**\n\nThe core of the problem lies in the numerical integration of Newton's equations of motion, which are derived from a Hamiltonian. The total energy $H$ is a conserved quantity for the exact dynamics, meaning $\\frac{dH}{dt}=0$. Numerical integrators, however, introduce discretization errors that can cause the computed energy to either fluctuate or systematically drift over time.\n\n**1. Hamiltonian System**\n\nThe system is described by the state $(x, p)$ in phase space. The equations of motion are given by Hamilton's equations:\n$$ \\dot{x} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m} $$\n$$ \\dot{p} = -\\frac{\\partial H}{\\partial x} = -\\frac{\\partial V}{\\partial x} = F(x) $$\nUsing $p = mv$, these are equivalent to $\\dot{x} = v$ and $\\dot{v} = F(x)/m = a(x)$, forming a system of two first-order ordinary differential equations (ODEs). We write this as $\\dot{\\mathbf{y}} = \\mathbf{f}(\\mathbf{y})$, where $\\mathbf{y}(t) = [x(t), v(t)]^\\top$ and $\\mathbf{f}(\\mathbf{y}) = [v, a(x)]^\\top$.\n\n**2. Velocity Verlet (VV) Integrator**\n\nThe velocity Verlet algorithm is a member of the family of symplectic integrators. These algorithms are specifically designed for Hamiltonian systems and have the property of preserving the phase space volume element, which leads to excellent long-term energy stability. The energy does not drift systematically but rather oscillates around its true initial value.\n\nThe algorithm, advancing from time $t_n$ to $t_{n+1} = t_n + \\Delta t$, is derived from a symmetric splitting of the Hamiltonian evolution operator. Following the problem's descriptive definition:\n\n1.  **First half-step velocity update**: The velocity is advanced by a half time step using the current acceleration $a_n = a(x_n)$.\n    $$ v_{n+1/2} = v_n + a_n \\frac{\\Delta t}{2} $$\n2.  **Full-step position update**: The position is advanced by a full time step using the half-step velocity.\n    $$ x_{n+1} = x_n + v_{n+1/2} \\Delta t $$\n3.  **Second half-step velocity update**: First, compute the new acceleration $a_{n+1} = a(x_{n+1})$ at the new position. Then, complete the velocity update.\n    $$ v_{n+1} = v_{n+1/2} + a_{n+1} \\frac{\\Delta t}{2} $$\n\nThese three steps constitute the update from $(x_n, v_n)$ to $(x_{n+1}, v_{n+1})$.\n\n**3. Runge-Kutta 4 (RK4) Integrator**\n\nThe classical fourth-order Runge-Kutta method is a widely used, high-accuracy, general-purpose ODE solver. It is not symplectic. While it is highly accurate for a single step (local error is $O(\\Delta t^5)$), for long-term integrations of Hamiltonian systems, the small errors accumulate in a way that typically causes the total energy to drift systematically.\n\nThe update from $\\mathbf{y}_n$ to $\\mathbf{y}_{n+1}$ is given by:\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) $$\nwhere the stages $\\mathbf{k}_i$ are vectors with two components, $[k_{i,x}, k_{i,v}]^\\top$. For our system $\\dot{\\mathbf{y}} = [v, a(x)]^\\top$, the stages are:\n$$ \\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) = [v_n, a(x_n)]^\\top $$\n$$ \\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) = \\left[ v_n + \\frac{\\Delta t}{2} k_{1,v}, a\\left(x_n + \\frac{\\Delta t}{2} k_{1,x}\\right) \\right]^\\top $$\n$$ \\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) = \\left[ v_n + \\frac{\\Delta t}{2} k_{2,v}, a\\left(x_n + \\frac{\\Delta t}{2} k_{2,x}\\right) \\right]^\\top $$\n$$ \\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + \\Delta t \\mathbf{k}_3) = \\left[ v_n + \\Delta t k_{3,v}, a(x_n + \\Delta t k_{3,x}) \\right]^\\top $$\nThe components for position and velocity are then updated using the weighted average of the corresponding components of the stage vectors.\n\n**4. Energy Drift Calculation**\n\nFor each simulation run (a choice of integrator, potential, and parameters), we generate a time series of states $(x_i, v_i)$ at times $t_i = i \\Delta t$ for $i \\in \\{0, 1, ..., N\\}$. From this, we compute the total energy $H_i = \\frac{1}{2}m v_i^2 + V(x_i)$ and the energy deviation $E_i = H_i - H_0$.\n\nWe seek the slope $s$ of the best-fit line to the points $(t_i, E_i)$. The method of least squares minimizes the sum of squared residuals $S(s, b) = \\sum_{i=0}^N (E_i - (s t_i + b))^2$. The slope $s$ that minimizes this sum is given by the standard formula for simple linear regression:\n$$ s = \\frac{\\sum_{i=0}^N (t_i - \\bar{t})(E_i - \\bar{E})}{\\sum_{i=0}^N (t_i - \\bar{t})^2} = \\frac{\\text{Cov}(t, E)}{\\text{Var}(t)} $$\nwhere $\\bar{t}$ and $\\bar{E}$ are the sample means of the time points and energy deviations, respectively. This value $s$ represents the average rate of energy change in Joules per second over the course of the simulation.\n\nThe implementation will consist of functions for the physics (potentials and forces), the two integrators, the simulation driver, and the drift calculation, executed for each of the four specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n\n    # --- Physics and Potential Definitions ---\n\n    def force_harmonic(x, k, **kwargs):\n        \"\"\"Force for the harmonic potential.\"\"\"\n        return -k * x\n\n    def potential_harmonic(x, k, **kwargs):\n        \"\"\"Harmonic potential energy.\"\"\"\n        return 0.5 * k * x**2\n\n    def force_quartic(x, k, alpha, **kwargs):\n        \"\"\"Force for the anharmonic quartic potential.\"\"\"\n        return -k * x - alpha * x**3\n\n    def potential_quartic(x, k, alpha, **kwargs):\n        \"\"\"Anharmonic quartic potential energy.\"\"\"\n        return 0.5 * k * x**2 + 0.25 * alpha * x**4\n\n    def acceleration(x, m, force_func, **params):\n        \"\"\"Calculate acceleration given a force function.\"\"\"\n        return force_func(x, **params) / m\n        \n    def total_energy(x, v, m, potential_func, **params):\n        \"\"\"Calculate total energy of the system.\"\"\"\n        kinetic = 0.5 * m * v**2\n        potential = potential_func(x, **params)\n        return kinetic + potential\n\n    # --- Integrator Implementations ---\n\n    def integrator_vv(x0, v0, m, dt, N, force_func, **params):\n        \"\"\"Velocity Verlet integrator.\"\"\"\n        x_hist = np.zeros(N + 1)\n        v_hist = np.zeros(N + 1)\n        x_hist[0], v_hist[0] = x0, v0\n\n        x, v = x0, v0\n        for i in range(N):\n            a_n = acceleration(x, m, force_func, **params)\n            v_half = v + 0.5 * dt * a_n\n            x_new = x + dt * v_half\n            a_n_plus_1 = acceleration(x_new, m, force_func, **params)\n            v_new = v_half + 0.5 * dt * a_n_plus_1\n            \n            x, v = x_new, v_new\n            x_hist[i+1], v_hist[i+1] = x, v\n        \n        return x_hist, v_hist\n\n    def integrator_rk4(x0, v0, m, dt, N, force_func, **params):\n        \"\"\"Classical 4th-order Runge-Kutta integrator.\"\"\"\n        x_hist = np.zeros(N + 1)\n        v_hist = np.zeros(N + 1)\n        x_hist[0], v_hist[0] = x0, v0\n\n        x, v = x0, v0\n        for i in range(N):\n            # k1\n            k1_x = v\n            k1_v = acceleration(x, m, force_func, **params)\n            \n            # k2\n            k2_x = v + 0.5 * dt * k1_v\n            k2_v = acceleration(x + 0.5 * dt * k1_x, m, force_func, **params)\n            \n            # k3\n            k3_x = v + 0.5 * dt * k2_v\n            k3_v = acceleration(x + 0.5 * dt * k2_x, m, force_func, **params)\n            \n            # k4\n            k4_x = v + dt * k3_v\n            k4_v = acceleration(x + dt * k3_x, m, force_func, **params)\n            \n            # Update\n            x_new = x + (dt / 6.0) * (k1_x + 2.0*k2_x + 2.0*k3_x + k4_x)\n            v_new = v + (dt / 6.0) * (k1_v + 2.0*k2_v + 2.0*k3_v + k4_v)\n            \n            x, v = x_new, v_new\n            x_hist[i+1], v_hist[i+1] = x, v\n            \n        return x_hist, v_hist\n        \n    # --- Analysis Definition ---\n    \n    def calculate_drift(times, energies):\n        \"\"\"\n        Calculates the energy drift rate s via linear regression.\n        s = Cov(t, E) / Var(t)\n        \"\"\"\n        t_bar = np.mean(times)\n        e_bar = np.mean(energies)\n        \n        numerator = np.sum((times - t_bar) * (energies - e_bar))\n        denominator = np.sum((times - t_bar)**2)\n        \n        if denominator == 0:\n            return 0.0\n        \n        return numerator / denominator\n\n    # --- Test Suite Definition ---\n    \n    test_cases = [\n        # Case A\n        {'name': 'A', 'm': 1.0, 'k': 1.0, 'alpha': 0.0, \n         'x0': 1.0, 'v0': 0.0, 'dt': 0.05, \n         'T': 100 * 2 * np.pi * np.sqrt(1.0/1.0),\n         'force_func': force_harmonic, 'pot_func': potential_harmonic,\n         'params': {'k': 1.0}},\n        # Case B\n        {'name': 'B', 'm': 1.0, 'k': 1.0, 'alpha': 0.0, \n         'x0': 1.0, 'v0': 0.0, 'dt': 1.9, 'T': 400.0,\n         'force_func': force_harmonic, 'pot_func': potential_harmonic,\n         'params': {'k': 1.0}},\n        # Case C\n        {'name': 'C', 'm': 1.0, 'k': 1.0, 'alpha': 1.0, \n         'x0': 1.0, 'v0': 0.0, 'dt': 0.01, 'T': 200.0,\n         'force_func': force_quartic, 'pot_func': potential_quartic,\n         'params': {'k': 1.0, 'alpha': 1.0}},\n        # Case D\n        {'name': 'D', 'm': 1.0, 'k': 100.0, 'alpha': 0.0, \n         'x0': 0.1, 'v0': 0.0, 'dt': 0.02, \n         'T': 100 * 2 * np.pi * np.sqrt(1.0/100.0),\n         'force_func': force_harmonic, 'pot_func': potential_harmonic,\n         'params': {'k': 100.0}},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = int(np.floor(case['T'] / case['dt']))\n        times = np.linspace(0, N * case['dt'], N + 1)\n        \n        case_results = []\n        \n        # Runge-Kutta 4\n        x_hist_rk4, v_hist_rk4 = integrator_rk4(\n            case['x0'], case['v0'], case['m'], case['dt'], N, case['force_func'], **case['params']\n        )\n        energies_rk4 = total_energy(x_hist_rk4, v_hist_rk4, case['m'], case['pot_func'], **case['params'])\n        e_dev_rk4 = energies_rk4 - energies_rk4[0]\n        drift_rk4 = calculate_drift(times, e_dev_rk4)\n        case_results.append(drift_rk4)\n\n        # Velocity Verlet\n        x_hist_vv, v_hist_vv = integrator_vv(\n            case['x0'], case['v0'], case['m'], case['dt'], N, case['force_func'], **case['params']\n        )\n        energies_vv = total_energy(x_hist_vv, v_hist_vv, case['m'], case['pot_func'], **case['params'])\n        e_dev_vv = energies_vv - energies_vv[0]\n        drift_vv = calculate_drift(times, e_dev_vv)\n        case_results.append(drift_vv)\n        \n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Many molecular systems feature forces acting on vastly different timescales, such as fast bond vibrations and slow conformational changes. This practice introduces the Reversible Reference System Propagator Algorithm (RESPA), a multiple-time-step method that improves computational efficiency by integrating fast and slow motions with different step sizes. You will investigate how RESPA's construction affects the properties of the conserved shadow Hamiltonian, specifically the amplitude of energy fluctuations and the mean energy offset, compared to a standard single-timestep approach .",
            "id": "3805783",
            "problem": "Consider a one-dimensional particle in reduced, dimensionless units where the mass is $m=1$. The system is defined by the Hamiltonian $H(x,p)=K(p)+U(x)$ with kinetic energy $K(p)=\\frac{p^2}{2m}$ and a split potential $U(x)=U_{\\mathrm{fast}}(x)+U_{\\mathrm{slow}}(x)$. The fast component is $U_{\\mathrm{fast}}(x)=\\frac{1}{2}k_{\\mathrm{f}}x^2$ and the slow component is $U_{\\mathrm{slow}}(x)=\\frac{1}{2}k_{\\mathrm{s}}x^2+\\frac{g}{4}x^4$, with forces $F_{\\mathrm{fast}}(x)=-\\frac{dU_{\\mathrm{fast}}}{dx}=-k_{\\mathrm{f}}x$ and $F_{\\mathrm{slow}}(x)=-\\frac{dU_{\\mathrm{slow}}}{dx}=-k_{\\mathrm{s}}x-gx^3$. Let initial conditions be $(x(0),v(0))=(x_0,v_0)$ with $p(0)=mv(0)=v(0)$ because $m=1$.\n\nFrom first principles, start with Newton’s second law $\\frac{d^2x}{dt^2}=\\frac{F(x)}{m}$ and the definition of the Hamiltonian flow being symplectic for appropriate integrators. Implement two Molecular Dynamics (MD) time integrators:\n\n1. A single-timestep velocity Verlet integrator that advances $(x,v)$ by a step size $\\Delta$ using the total force $F(x)=F_{\\mathrm{fast}}(x)+F_{\\mathrm{slow}}(x)$.\n\n2. A two-level Reversible Reference System Propagator Algorithm (RESPA) with outer step size $\\Delta$ and $n$ inner steps for the fast forces, each of size $\\delta=\\Delta/n$. Use the symmetric Strang splitting in which the slow force is applied as a half-kick at the beginning and end of each outer step, and the fast force is integrated via velocity Verlet substeps inside the outer step.\n\nFor each method, advance the dynamics for a given number of outer steps $N_{\\mathrm{outer}}$, and at the end of every outer step compute the total energy $E(t)=\\frac{1}{2}mv^2+U_{\\mathrm{fast}}(x)+U_{\\mathrm{slow}}(x)$ using $m=1$. Let $E_0$ be the energy at $t=0$. Over the sampled energy time series $\\{E_k\\}_{k=1}^{N_{\\mathrm{outer}}}$, compute the fluctuation amplitude as the root-mean-square (RMS) about the sample mean $\\bar{E}$,\n$$\n\\mathrm{RMS}=\\sqrt{\\frac{1}{N_{\\mathrm{outer}}}\\sum_{k=1}^{N_{\\mathrm{outer}}}\\left(E_k-\\bar{E}\\right)^2},\n$$\nand compute the mean offset from the initial energy, which serves as an approximation to the deviation between the numerical shadow Hamiltonian and the true Hamiltonian,\n$$\n\\Delta E_{\\mathrm{offset}}=\\bar{E}-E_0.\n$$\n\nYour program must implement both integrators and, for each test case defined below, return the list $[\\mathrm{RMS}_{\\mathrm{Verlet}},\\mathrm{RMS}_{\\mathrm{RESPA}},\\Delta E_{\\mathrm{offset,Verlet}},\\Delta E_{\\mathrm{offset,RESPA}}]$ with all quantities in reduced, dimensionless units.\n\nTest Suite:\n- Case $1$ (happy path, harmonic slow part): $(x_0,v_0)=(0.1,0.0)$, $k_{\\mathrm{f}}=100$, $k_{\\mathrm{s}}=1$, $g=0$, $\\Delta=0.05$, $n=5$, $N_{\\mathrm{outer}}=2000$.\n- Case $2$ (slow quartic nonlinearity): $(x_0,v_0)=(0.2,0.1)$, $k_{\\mathrm{f}}=100$, $k_{\\mathrm{s}}=1$, $g=0.1$, $\\Delta=0.05$, $n=5$, $N_{\\mathrm{outer}}=2000$.\n- Case $3$ (near fast-mode stability boundary): $(x_0,v_0)=(0.1,0.0)$, $k_{\\mathrm{f}}=100$, $k_{\\mathrm{s}}=1$, $g=0$, $\\Delta=0.18$, $n=10$, $N_{\\mathrm{outer}}=1000$.\n- Case $4$ (no slow splitting, moderate fast stiffness): $(x_0,v_0)=(0.3,-0.2)$, $k_{\\mathrm{f}}=25$, $k_{\\mathrm{s}}=0$, $g=0$, $\\Delta=0.12$, $n=3$, $N_{\\mathrm{outer}}=1500$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list of lists, with no spaces, in the form\n$$\n\\left[\\left[\\mathrm{RMS}_{\\mathrm{Verlet}},\\mathrm{RMS}_{\\mathrm{RESPA}},\\Delta E_{\\mathrm{offset,Verlet}},\\Delta E_{\\mathrm{offset,RESPA}}\\right]_{\\text{Case }1},\\dots,\\left[\\cdot\\right]_{\\text{Case }4}\\right].\n$$\nAll quantities must be computed and reported in reduced, dimensionless units. Express all floats numerically; no angles or percentages are involved in this problem. This problem is universally applicable: implement in any modern programming language using the definitions and integrators described, and adhere to the specified output format.",
            "solution": "The user-provided problem is assessed to be **valid**. It is a well-posed, scientifically grounded problem in the field of computational physics, specifically concerning numerical integration methods in molecular dynamics. All necessary parameters and definitions are provided, and there are no internal contradictions or ambiguities.\n\nHerein, a complete solution is presented, starting from first principles as requested.\n\nThe problem requires the implementation and comparison of two numerical integrators for a one-dimensional classical particle system described by the Hamiltonian $H(x,p) = K(p) + U(x)$. The particle has mass $m=1$ in reduced units, so its momentum $p$ is equal to its velocity $v$. The kinetic energy is $K(v) = \\frac{1}{2}mv^2 = \\frac{1}{2}v^2$. The potential energy $U(x)$ is split into a fast component, $U_{\\mathrm{fast}}(x) = \\frac{1}{2}k_{\\mathrm{f}}x^2$, and a slow component, $U_{\\mathrm{slow}}(x) = \\frac{1}{2}k_{\\mathrm{s}}x^2 + \\frac{g}{4}x^4$. The corresponding forces are $F_{\\mathrm{fast}}(x) = -k_{\\mathrm{f}}x$ and $F_{\\mathrm{slow}}(x) = -k_{\\mathrm{s}}x - gx^3$. The total force is $F(x) = F_{\\mathrm{fast}}(x) + F_{\\mathrm{slow}}(x)$.\n\nThe dynamics are governed by Newton's second law, which for $m=1$ is $\\frac{d^2x}{dt^2} = F(x)$. We will solve this equation of motion numerically using two different symplectic integrators.\n\n### 1. Velocity Verlet Integrator\n\nThe Velocity Verlet algorithm is a second-order, time-reversible, and symplectic integrator widely used in molecular dynamics. It propagates the position $x$ and velocity $v$ over a timestep $\\Delta$. The algorithm can be derived from a Trotter factorization of the Liouville propagator for the full Hamiltonian. For a single step from time $t$ to $t+\\Delta$, given the state $(x(t), v(t))$, the algorithm proceeds as follows:\n1.  Compute the acceleration $a(t) = F(x(t))/m$.\n2.  Advance the velocity by a half-step: $v(t+\\Delta/2) = v(t) + \\frac{1}{2} a(t) \\Delta$.\n3.  Advance the position by a full step using the half-step velocity: $x(t+\\Delta) = x(t) + v(t+\\Delta/2) \\Delta$.\n4.  Compute the new acceleration at the new position: $a(t+\\Delta) = F(x(t+\\Delta))/m$.\n5.  Complete the velocity update for the second half-step: $v(t+\\Delta) = v(t+\\Delta/2) + \\frac{1}{2} a(t+\\Delta) \\Delta$.\n\nIn this problem, the Velocity Verlet integrator uses the total force $F(x)$ and a timestep $\\Delta$.\n\n### 2. Reversible Reference System Propagator Algorithm (RESPA)\n\nRESPA is a multiple-timestep integrator designed for systems with forces acting on different time scales. It is based on a symmetric Strang splitting of the Liouville operator, $iL = \\{H, \\cdot\\}$, which is separated into components corresponding to the fast and slow forces: $iL = iL_{\\mathrm{fast}} + iL_{\\mathrm{slow}}$. The evolution operator for a single outer timestep $\\Delta$ is approximated as:\n$$\ne^{iL\\Delta} \\approx e^{iL_{\\mathrm{slow}} \\Delta/2} \\ e^{i(L_{\\mathrm{kin}} + L_{\\mathrm{fast}})\\Delta} \\ e^{iL_{\\mathrm{slow}} \\Delta/2}\n$$\nHere, $iL_{\\mathrm{kin}}$ corresponds to the kinetic energy term, and the operators are applied sequentially.\nThe implementation follows this structure for one outer step of size $\\Delta$:\n1.  **First slow kick**: The velocity is updated by a half-step using only the slow force: $v \\leftarrow v + \\frac{F_{\\mathrm{slow}}(x)}{2m}\\Delta$.\n2.  **Fast dynamics propagation**: The system is evolved for a full duration $\\Delta$ under the Hamiltonian $H_{\\mathrm{fast}} = K(v) + U_{\\mathrm{fast}}(x)$. This is accomplished by performing $n$ sub-steps of a Velocity Verlet integrator, each with a small inner timestep $\\delta = \\Delta/n$ and using only the fast force $F_{\\mathrm{fast}}(x)$.\n3.  **Second slow kick**: The velocity is updated again by a half-step using the slow force at the new position: $v \\leftarrow v + \\frac{F_{\\mathrm{slow}}(x)}{2m}\\Delta$.\n\nThis symmetric splitting maintains time-reversibility and symplecticity, leading to excellent long-term energy conservation properties, particularly when there is a significant separation in time scales between the fast and slow forces ($k_{\\mathrm{f}} \\gg k_{\\mathrm{s}}$).\n\n### 3. Analysis of Energy Conservation\n\nFor any symplectic integrator, the total energy of the system does not drift systematically but rather fluctuates around a constant value corresponding to a \"shadow Hamiltonian\" that is close to the true Hamiltonian. We quantify the quality of energy conservation using two metrics, computed from the time series of total energy $\\{E_k\\}_{k=1}^{N_{\\mathrm{outer}}}$ sampled at the end of each outer step:\n-   **RMS Fluctuation Amplitude**: $\\mathrm{RMS} = \\sqrt{\\frac{1}{N_{\\mathrm{outer}}}\\sum_{k=1}^{N_{\\mathrm{outer}}}(E_k - \\bar{E})^2}$, where $\\bar{E}$ is the sample mean of the energy time series. This measures the magnitude of energy oscillations.\n-   **Mean Energy Offset**: $\\Delta E_{\\mathrm{offset}} = \\bar{E} - E_0$, where $E_0$ is the initial energy. This measures the deviation of the conserved shadow Hamiltonian from the true initial energy.\n\nThe program below will implement both integrators, run simulations for the specified test cases, and compute these two metrics to compare the performance of standard Verlet with the multiscale RESPA method.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares Velocity Verlet and RESPA integrators for a 1D particle system,\n    analyzing their energy conservation for several test cases.\n    \"\"\"\n    \n    # Test cases defined in the problem statement.\n    # Format: (x0, v0, k_f, k_s, g, Delta, n, N_outer)\n    test_cases = [\n        (0.1, 0.0, 100.0, 1.0, 0.0, 0.05, 5, 2000),\n        (0.2, 0.1, 100.0, 1.0, 0.1, 0.05, 5, 2000),\n        (0.1, 0.0, 100.0, 1.0, 0.0, 0.18, 10, 1000),\n        (0.3, -0.2, 25.0, 0.0, 0.0, 0.12, 3, 1500),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        x0, v0, kf, ks, g, Delta, n, N_outer = case\n        m = 1.0\n\n        # Define force and energy functions based on case parameters\n        def F_total(x):\n            return -(kf + ks) * x - g * x**3\n\n        def F_fast(x):\n            return -kf * x\n\n        def F_slow(x):\n            return -ks * x - g * x**3\n\n        def total_energy(x, v):\n            U_fast = 0.5 * kf * x**2\n            U_slow = 0.5 * ks * x**2 + 0.25 * g * x**4\n            K = 0.5 * m * v**2\n            return K + U_fast + U_slow\n\n        # --- Velocity Verlet Simulation ---\n        x, v = x0, v0\n        E0 = total_energy(x, v)\n        energies_verlet = np.zeros(N_outer)\n\n        for i in range(N_outer):\n            # Standard Velocity Verlet step\n            a = F_total(x) / m\n            v_half = v + 0.5 * a * Delta\n            x = x + v_half * Delta\n            a_new = F_total(x) / m\n            v = v_half + 0.5 * a_new * Delta\n            energies_verlet[i] = total_energy(x, v)\n        \n        # Analyze Verlet results\n        E_mean_verlet = np.mean(energies_verlet)\n        # np.std uses N in the denominator by default (ddof=0), matching the problem's RMS formula\n        RMS_verlet = np.std(energies_verlet) \n        dE_offset_verlet = E_mean_verlet - E0\n\n        # --- RESPA Simulation ---\n        x, v = x0, v0\n        delta = Delta / n\n        energies_respa = np.zeros(N_outer)\n\n        for i in range(N_outer):\n            # RESPA step with symmetric Strang splitting\n            # 1. First half-kick with slow force\n            v = v + 0.5 * (F_slow(x) / m) * Delta\n\n            # 2. n Verlet sub-steps with fast force\n            for _ in range(n):\n                a_fast = F_fast(x) / m\n                v_half_inner = v + 0.5 * a_fast * delta\n                x = x + v_half_inner * delta\n                a_fast_new = F_fast(x) / m\n                v = v_half_inner + 0.5 * a_fast_new * delta\n            \n            # 3. Second half-kick with slow force\n            v = v + 0.5 * (F_slow(x) / m) * Delta\n            \n            energies_respa[i] = total_energy(x, v)\n        \n        # Analyze RESPA results\n        E_mean_respa = np.mean(energies_respa)\n        RMS_respa = np.std(energies_respa)\n        dE_offset_respa = E_mean_respa - E0\n        \n        all_results.append([RMS_verlet, RMS_respa, dE_offset_verlet, dE_offset_respa])\n\n    # Format the final output string as specified\n    result_strings = []\n    for res_list in all_results:\n        # Use .16g for good precision without unnecessary trailing zeros\n        s_list = [f\"{val:.16g}\" for val in res_list]\n        result_strings.append(f\"[{','.join(s_list)}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "To improve efficiency and model specific molecular features, many simulations employ rigid constraints on bonds and angles, removing the fastest vibrational motions. This exercise explores how constraint-satisfaction algorithms, which project velocities onto a constraint manifold, can themselves impact total energy conservation. By analyzing the energy change introduced by a constraint stabilization procedure for a rigid water model, you will learn to manage the critical trade-off between numerical tolerance, constraint satisfaction, and long-term energy stability .",
            "id": "3805782",
            "problem": "Consider a single rigid water molecule modeled by three point masses: one oxygen atom and two hydrogen atoms. The rigid geometry is enforced by holonomic constraints that keep all three pairwise distances fixed. The constraints are defined on the squared distances so that the constraint functions are differentiable and their time derivatives yield linear velocity conditions. Starting from Newton's second law, define a constraint stabilization step on the velocities that projects the current velocity vector onto the tangent space of the constraint manifold by applying mass-weighted corrective impulses. Compute the energy change due to this stabilization and propose numerical tolerance settings that minimize energy drift while still achieving acceptable constraint satisfaction.\n\nFundamental base. Begin from Newton's second law, $m_i \\,\\mathbf{a}_i = \\mathbf{F}_i$, and the definition of kinetic energy $T = \\frac{1}{2}\\sum_{i} m_i \\|\\mathbf{v}_i\\|^2$. For a holonomic constraint $g_k(\\mathbf{r}) = 0$, the velocity-level constraint is $\\dot{g}_k(\\mathbf{r},\\mathbf{v}) = \\nabla g_k(\\mathbf{r}) \\cdot \\mathbf{v} = 0$. The mass-weighted projection to enforce $\\dot{g}_k=0$ proceeds by adding velocity impulses $\\Delta \\mathbf{v}_i$ that are linear combinations of the constraint gradients scaled by Lagrange multipliers. In a sequential stabilization (Gauss–Seidel) sweep, each constraint is corrected in turn, which can induce small violations in other constraints, so multiple sweeps are used until a stopping criterion is met.\n\nModel and units. Use fixed rigid geometry intended for a typical water model:\n- Oxygen mass $m_O = 15.999\\ \\mathrm{amu}$, hydrogen mass $m_H = 1.008\\ \\mathrm{amu}$, with $1\\ \\mathrm{amu} = 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$. Express all masses in $\\mathrm{kg}$.\n- Oxygen–hydrogen bond length $r_{OH} = 9.572\\times 10^{-11}\\ \\mathrm{m}$.\n- Hydrogen–oxygen–hydrogen angle $\\theta = 104.52^\\circ$ (angle unit is degrees).\n- Place the oxygen atom at the origin $\\mathbf{r}_O = (0,0,0)$; place the first hydrogen at $\\mathbf{r}_{H1} = (r_{OH}, 0, 0)$; place the second hydrogen at $\\mathbf{r}_{H2} = (r_{OH}\\cos\\theta, r_{OH}\\sin\\theta, 0)$.\n- Enforce three distance constraints using squared-distance functions\n$$\ng_1(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_{O}-\\mathbf{r}_{H1}\\|^2 - r_{OH}^2\\right),\\quad\ng_2(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_{O}-\\mathbf{r}_{H2}\\|^2 - r_{OH}^2\\right),\\quad\ng_3(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_{H1}-\\mathbf{r}_{H2}\\|^2 - r_{HH}^2\\right),\n$$\nwhere $r_{HH} = 2\\,r_{OH}\\,\\sin(\\theta/2)$ ensures geometric consistency. The corresponding velocity constraints are\n$$\n\\dot{g}_k(\\mathbf{r},\\mathbf{v}) = \\mathbf{r}_{pq}\\cdot(\\mathbf{v}_p - \\mathbf{v}_q) = 0,\n$$\nwhere $\\mathbf{r}_{pq} = \\mathbf{r}_p - \\mathbf{r}_q$ for the atom pair of constraint $k$.\n\nConstraint stabilization step. In one Gauss–Seidel iteration over constraints, for each constraint $k$ connecting atoms $p$ and $q$, compute the scalar residual\n$$\ns_k = \\mathbf{r}_{pq}\\cdot(\\mathbf{v}_p - \\mathbf{v}_q),\n$$\nand apply the minimal mass-weighted correction that would make $s_k = 0$ for that constraint alone:\n$$\n\\lambda_k = -\\frac{s_k}{\\alpha_{pq}},\\quad \\alpha_{pq} = \\|\\mathbf{r}_{pq}\\|^2\\left(\\frac{1}{m_p} + \\frac{1}{m_q}\\right),\n$$\n$$\n\\mathbf{v}_p \\leftarrow \\mathbf{v}_p + \\frac{\\lambda_k}{m_p}\\,\\mathbf{r}_{pq},\\quad\n\\mathbf{v}_q \\leftarrow \\mathbf{v}_q - \\frac{\\lambda_k}{m_q}\\,\\mathbf{r}_{pq}.\n$$\nIterate sweeps until all constraints satisfy a normalized residual threshold. Let the instantaneous mass-weighted root-mean-square speed be\n$$\nv_{\\mathrm{rms}} = \\sqrt{\\frac{\\sum_i m_i \\|\\mathbf{v}_i\\|^2}{\\sum_i m_i}},\n$$\nand define for each constraint the dimensionless normalized residual\n$$\n\\rho_k = \\frac{|s_k|}{\\|\\mathbf{r}_{pq}\\|\\, v_{\\mathrm{rms}}}.\n$$\nTerminate the iteration when $\\max_k \\rho_k \\le \\mathrm{rtol}$, where $\\mathrm{rtol}$ is a relative tolerance parameter.\n\nEnergy change due to stabilization. The kinetic energy before and after stabilization are\n$$\nT_{\\mathrm{before}} = \\tfrac{1}{2}\\sum_i m_i \\|\\mathbf{v}_i^{\\mathrm{(before)}}\\|^2,\\quad\nT_{\\mathrm{after}} = \\tfrac{1}{2}\\sum_i m_i \\|\\mathbf{v}_i^{\\mathrm{(after)}}\\|^2.\n$$\nThe energy change is\n$$\n\\Delta T = T_{\\mathrm{after}} - T_{\\mathrm{before}},\n$$\nwhich should be expressed in Joules (J).\n\nTolerance proposal objective. Given a target normalized residual bound $\\rho^\\ast = 10^{-6}$, propose a tolerance $\\mathrm{rtol}$ from a candidate set that minimizes $|\\Delta T|$ while ensuring $\\max_k \\rho_k \\le \\rho^\\ast$. If no candidate achieves the target, choose among candidates the one with smallest $\\max_k \\rho_k$, breaking ties by smallest $|\\Delta T|$, and if still tied, by the largest $\\mathrm{rtol}$.\n\nTest suite. Use three test cases with distinct initial velocities (in $\\mathrm{m/s}$):\n- Case A (thermal-like): $\\mathbf{v}_O = (300,-200,100)$, $\\mathbf{v}_{H1} = (1500,2000,-1000)$, $\\mathbf{v}_{H2} = (-1200,800,600)$.\n- Case B (near-rigid rotation): define angular velocity $\\boldsymbol{\\omega} = (0,5\\times 10^{11},0)\\ \\mathrm{s}^{-1}$, compute the center of mass position $\\mathbf{r}_{\\mathrm{COM}}$, and set $\\mathbf{v}_i = \\boldsymbol{\\omega} \\times (\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{COM}})$ for $i \\in \\{O,H1,H2\\}$.\n- Case C (edge violation): $\\mathbf{v}_O = (0,0,0)$, $\\mathbf{v}_{H1} = (20000,0,0)$, $\\mathbf{v}_{H2} = (0,0,0)$.\n\nCandidate tolerances and iteration cap. Use candidate tolerances $\\mathrm{rtol} \\in \\{10^{-2},10^{-4},10^{-6},10^{-8},10^{-10}\\}$ and a maximum of $N_{\\max} = 200$ Gauss–Seidel sweeps per stabilization.\n\nRequired output. For each test case, determine the recommended tolerance $\\mathrm{rtol}_{\\mathrm{rec}}$ and compute the corresponding energy change $\\Delta T$ after stabilization. Express each $\\Delta T$ in $\\mathrm{J}$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a two-item list $[\\mathrm{rtol}_{\\mathrm{rec}}, \\Delta T]$ for one test case. For example, the format is $[[\\mathrm{rtol}_A,\\Delta T_A],[\\mathrm{rtol}_B,\\Delta T_B],[\\mathrm{rtol}_C,\\Delta T_C]]$ with numeric values.",
            "solution": "The user wants me to solve a problem in the field of molecular dynamics, specifically related to energy conservation and constraint satisfaction for rigid bodies.\n\nHere's a plan:\n1.  **Validate the problem statement**: I need to go through the problem validation checklist.\n    *   **Step 1: Extract Givens**: I will list all the physical constants, model parameters, mathematical formulas, initial conditions, and the objective.\n    *   **Step 2: Validate**: I will check for scientific grounding, well-posedness, objectivity, and other potential flaws. The problem seems to be a standard exercise in computational physics/chemistry, using the well-known SHAKE/RATTLE or a similar Gauss-Seidel stabilization scheme.\n        *   **Scientific Grounding**: The principles are Newton's second law, kinetic energy, holonomic constraints, Lagrange multipliers (implicitly via the projection method), and Gauss-Seidel iteration. These are all standard and sound. The model is a rigid water molecule, a common simplification. The equations for the velocity correction (`lambda_k`, `v_p`, `v_q` updates) are a standard formulation of a velocity-level constraint solver (like RATTLE).\n        *   **Well-Posed**: The problem asks to find an optimal tolerance from a given set based on a clearly defined objective function (minimizing energy change subject to a constraint satisfaction target). The iterative procedure has a stopping criterion (max iterations or tolerance met). This seems well-posed. The objective function is also well-defined with clear tie-breaking rules.\n        *   **Objective**: The language is precise and quantitative. No subjective claims.\n        *   **Completeness**: All necessary data is provided: masses, bond lengths, angles, initial velocities for three cases, candidate tolerances, max iterations, and the formula for everything. The geometry is fully specified. The update rules are explicit. The objective is clear.\n        *   **Consistency**: The geometry is consistent since `r_HH` is derived from `r_OH` and `theta`. The formulas seem standard. `alpha_pq` is the inverse of the effective mass for the constraint, which is correct. The velocity updates conserve linear momentum for the pair `(p,q)` since `Δp_p + Δp_q = m_p * (λ_k/m_p) * r_pq + m_q * (-λ_k/m_q) * r_pq = 0`. They might not conserve total angular momentum, but the problem does not require it. The method is a projection, which is known to find the smallest change in the mass-weighted velocity norm, thus minimizing the change in kinetic energy *for a single constraint application*. The Gauss-Seidel nature means the overall process is not a true projection onto the intersection of all constraint surfaces simultaneously, hence the energy change `ΔT` is generally non-zero. The problem is about investigating this `ΔT`.\n    *   **Step 3: Verdict**: The problem looks valid. It is a standard, well-defined computational physics problem.\n\n2.  **Solve the problem**: Since the problem is valid, I will proceed to develop the solution.\n    *   **Principle-Based Design**: I will structure my explanation around the concepts of rigid body dynamics, constraint mechanics, and iterative numerical methods.\n        *   **Setup**: Define the system: atoms, masses, initial positions based on the given geometry. I'll need to calculate `r_HH`.\n        *   **Constraint Formulation**: Explain the three squared-distance constraints and their corresponding velocity-level forms.\n        *   **Iterative Stabilization Algorithm (Gauss-Seidel)**: Describe the core loop. For each `rtol` candidate:\n            1.  Initialize velocities `v` with the test case values.\n            2.  Start the iterative loop (up to `N_max` sweeps).\n            3.  In each sweep, iterate through the three constraints (`g_1`, `g_2`, `g_3`).\n            4.  For each constraint `k` (between atoms `p` and `q`):\n                *   Calculate `r_pq`.\n                *   Calculate the residual `s_k`.\n                *   Calculate `alpha_pq`.\n                *   Calculate the Lagrange multiplier `lambda_k`.\n                *   Update velocities `v_p` and `v_q`.\n            5.  After one full sweep (all 3 constraints), check the stopping criterion.\n                *   Calculate `v_rms`.\n                *   Calculate the normalized residuals `rho_k` for all `k`.\n                *   If `max(rho_k) = rtol`, the iteration for this `rtol` converges. Break the loop.\n        *   **Energy Calculation**: After the iterative process terminates (either by convergence or max iterations), calculate the final kinetic energy `T_after` and the change `ΔT = T_after - T_before`.\n        *   **Tolerance Selection**: For each test case, I'll have a set of results: `(rtol, max_rho_k, ΔT)`. I need to apply the selection logic:\n            1.  Filter the results to keep only those where `max_rho_k = rho_ast` (where `rho_ast = 1e-6`).\n            2.  If this filtered set is not empty, find the one that minimizes `|ΔT|`.\n            3.  If the filtered set is empty, go back to the full set of results. Find the one that minimizes `max_rho_k`.\n            4.  Break ties in step 3 by choosing the one with the smallest `|ΔT|`.\n            5.  Break any remaining ties by choosing the largest `rtol`.\n        *   **Final Output**: Collect the `[rtol_rec, ΔT]` for each test case and format the output.\n\n3.  **Implement the code**: I will write a Python script using `numpy`.\n    *   **Constants**: Define physical constants `m_O`, `m_H`, `amu`, `r_OH`, `theta`. Convert to SI units (kg, m, rad).\n    *   **Geometry**: Calculate initial positions `r_O`, `r_{H1}`, `r_{H2}` and the `r_{HH}` distance.\n    *   **Structure**: Create a main `solve` function. Inside, loop through the test cases.\n    *   **Test Cases**: Define the initial velocities for cases A, B, and C. For case B, I need to compute the center of mass `r_COM` and then the initial velocities.\n    *   **Stabilization Function**: Create a helper function, say `stabilize(velocities, rtol, ...)` that takes initial velocities and a tolerance, performs the Gauss-Seidel iteration, and returns the final velocities, the max residual, and the number of iterations.\n    *   **Main Loop**: For each test case:\n        *   Calculate `T_before`.\n        *   Create a list to store results for each `rtol`.\n        *   Loop through the candidate `rtol` values:\n            *   Call the `stabilize` function.\n            *   Calculate `T_after` and `ΔT`.\n            *   Store `(rtol, max_rho_final, ΔT)`.\n        *   Apply the selection logic to the stored results to find the best `rtol` and its corresponding `ΔT`.\n        *   Append `[best_rtol, best_delta_T]` to the final results list.\n    *   **Print**: Format the final list of lists and print it.\n\nLet's do some calculations to double-check my understanding.\n\n**Geometry calculation:**\n- `m_O = 15.999 * 1.66053906660e-27` kg\n- `m_H = 1.008 * 1.66053906660e-27` kg\n- `r_OH = 9.572e-11` m\n- `theta = 104.52` degrees. `theta_rad = np.deg2rad(104.52)`\n- `r_O = (0, 0, 0)`\n- `r_{H1} = (r_OH, 0, 0)`\n- `r_{H2} = (r_OH * cos(theta_rad), r_OH * sin(theta_rad), 0)`\n- `r_HH = 2 * r_OH * sin(theta_rad / 2)`\n- Let's check `r_HH` vs `||r_{H1} - r_{H2}||`.\n  - `r_{H1} - r_{H2} = (r_OH * (1 - cos(theta_rad)), -r_OH * sin(theta_rad), 0)`\n  - `||r_{H1} - r_{H2}||^2 = r_OH^2 * ((1 - cos(theta_rad))^2 + sin^2(theta_rad))`\n  - `= r_OH^2 * (1 - 2*cos(theta_rad) + cos^2(theta_rad) + sin^2(theta_rad))`\n  - `= r_OH^2 * (2 - 2*cos(theta_rad))`\n  - `= 2 * r_OH^2 * (1 - cos(theta_rad))`\n  - using `1 - cos(x) = 2 * sin^2(x/2)`\n  - `= 2 * r_OH^2 * (2 * sin^2(theta_rad / 2))`\n  - `= 4 * r_OH^2 * sin^2(theta_rad / 2)`\n  - So `||r_{H1} - r_{H2}|| = 2 * r_OH * sin(theta_rad / 2)`. This matches `r_HH`. The geometry is consistent.\n\n**Constraint equations:**\n- `g_1`: atoms O (0) and H1 (1). Pair (0, 1). `r_01 = r_0 - r_1`.\n- `g_2`: atoms O (0) and H2 (2). Pair (0, 2). `r_02 = r_0 - r_2`.\n- `g_3`: atoms H1 (1) and H2 (2). Pair (1, 2). `r_12 = r_1 - r_2`.\n- The problem defines `r_pq = r_p - r_q`. So `r_OH1 = r_O - r_{H1}`. Let's be careful with indexing and pairing. Let's use indices 0, 1, 2 for O, H1, H2.\n- Constraints:\n    1. Pair (0,1): `p=0, q=1`. `r_01 = r_0 - r_1`. `m_0, m_1`.\n    2. Pair (0,2): `p=0, q=2`. `r_02 = r_0 - r_2`. `m_0, m_2`.\n    3. Pair (1,2): `p=1, q=2`. `r_12 = r_1 - r_2`. `m_1, m_2`.\n\n**Stabilization step `k` for pair `(p,q)`:**\n- `r_pq = r_p - r_q`\n- `s_k = r_pq . (v_p - v_q)`\n- `alpha_pq = ||r_pq||^2 * (1/m_p + 1/m_q)`\n- `lambda_k = -s_k / alpha_pq`\n- `v_p_new = v_p_old + (lambda_k / m_p) * r_pq`\n- `v_q_new = v_q_old - (lambda_k / m_q) * r_pq`\n\nThis all looks standard. I need to implement this loop carefully.\n\n**Case B velocity calculation:**\n- `M_tot = m_O + 2*m_H`\n- `r_COM = (m_O * r_O + m_H * r_{H1} + m_H * r_{H2}) / M_tot`\n- `v_O = w x (r_O - r_COM)`\n- `v_{H1} = w x (r_{H1} - r_COM)`\n- `v_{H2} = w x (r_{H2} - r_COM)`\n- `w = (0, 5e11, 0)`\n- This initial velocity field represents pure rotation around the center of mass. For a perfectly rigid body, this velocity field should perfectly satisfy the constraint velocity equations `r_pq . (v_p - v_q) = 0`. Let's check this.\n- `v_p - v_q = (w x (r_p - r_COM)) - (w x (r_q - r_COM)) = w x (r_p - r_q) = w x r_pq`.\n- So `s_k = r_pq . (v_p - v_q) = r_pq . (w x r_pq)`.\n- The scalar triple product `A . (B x A)` is always zero. So, `s_k` should be exactly zero for all constraints.\n- This means that for Case B, the initial velocities already satisfy the constraints perfectly. `s_k = 0` for all `k`.\n- Therefore, `lambda_k = 0`, `Δv_i = 0`, and stabilization should do nothing. The velocities should not change. `T_after` should equal `T_before`, and `ΔT` should be 0. The normalized residuals `rho_k` will also be zero.\n- This is an important check. My code should reproduce this. `max_k rho_k` will be 0, which is less than any positive `rtol`. Thus, the loop will terminate after 0 or 1 sweep. The selection logic then needs to be applied.\n- For case B, all `rtol` candidates will achieve `max_rho_k = 0 = 1e-6`. The energy change `|ΔT|` will be 0 for all of them. The tie-breaker is to choose the largest `rtol`. So for case B, the answer should be `[1e-2, 0.0]`. This is a good sanity check for my implementation.\n\n**Energy change calculation:**\n- `T_before = 0.5 * (m_O * ||v_O_init||^2 + m_H * ||v_{H1}_init||^2 + m_H * ||v_{H2}_init||^2)`\n- After stabilization with a given `rtol`, I get `v_O_final`, `v_{H1}_final`, `v_{H2}_final`.\n- `T_after = 0.5 * (m_O * ||v_O_final||^2 + m_H * ||v_{H1}_final||^2 + m_H * ||v_{H2}_final||^2)`\n- `ΔT = T_after - T_before`\n\n**Selection logic implementation:**\n- For a given test case:\n    - `results = []`\n    - `for rtol in [1e-2, 1e-4, 1e-6, 1e-8, 1e-10]:`\n        - `v_final, max_rho = stabilize(v_init, rtol)`\n        - `delta_T = calc_delta_T(v_init, v_final)`\n        - `results.append({'rtol': rtol, 'max_rho': max_rho, 'delta_T': delta_T})`\n- Now, process `results`.\n    - `rho_star = 1e-6`\n    - `achieved_target = [res for res in results if res['max_rho'] = rho_star]`\n    - `if achieved_target:`\n        - `best = min(achieved_target, key=lambda x: abs(x['delta_T']))`\n    - `else:`\n        - `best = min(results, key=lambda x: (x['max_rho'], abs(x['delta_T']), -x['rtol']))`\n        // Note: `min` with `-x['rtol']` will maximize `rtol`.\n- The final output for this case is `[best['rtol'], best['delta_T']]`.\n\nThis logic seems correct and directly implements the problem description.\n\nNow, let's think about the structure of the code itself.\n- It's a good idea to put the physical and geometrical constants at the top level.\n- `solve` function will contain the main logic.\n- A helper function `run_case(v_initial, ...)` would be clean. This function would loop through the `rtol` candidates, call the stabilization logic, and perform the selection.\n- The stabilization logic itself can be a function `stabilize(velocities, positions, masses, ...)`\n- The code must be self-contained. All data is given.\n\nLet's refine the structure.\n```python\nimport numpy as np\n\n# Global constants\nAMU_TO_KG = 1.66053906660e-27\n# ... other constants\n\ndef setup_geometry():\n    # Calculate masses, positions, r_HH\n    # Return a dictionary or tuple with this info\n    pass\n\ndef stabilize(velocities, geometry, rtol, max_sweeps):\n    # Implements the Gauss-Seidel stabilization\n    # returns final_velocities, max_rho_final\n    pass\n\ndef calculate_energy(masses, velocities):\n    # Calculates total kinetic energy\n    pass\n\ndef solve():\n    geometry = setup_geometry()\n    masses = geometry['masses']\n    positions = geometry['positions']\n    \n    # Test cases\n    v_A = ...\n    v_B = ... # calculate this\n    v_C = ...\n    test_cases = [v_A, v_B, v_C]\n    \n    candidate_rtols = [1e-2, 1e-4, 1e-6, 1e-8, 1e-10]\n    rho_target = 1e-6\n    max_sweeps = 200\n    \n    final_results = []\n    \n    for v_initial in test_cases:\n        \n        T_before = calculate_energy(masses, v_initial)\n        \n        results_per_case = []\n        for rtol in candidate_rtols:\n            v_final, max_rho_final = stabilize(v_initial.copy(), geometry, rtol, max_sweeps)\n            T_after = calculate_energy(masses, v_final)\n            delta_T = T_after - T_before\n            results_per_case.append({\n                'rtol': rtol,\n                'max_rho': max_rho_final,\n                'delta_T': delta_T\n            })\n            \n        # Selection logic\n        achieved_target = [res for res in results_per_case if res['max_rho'] = rho_target]\n        \n        if achieved_target:\n            # Minimize |delta_T|\n            best_res = min(achieved_target, key=lambda x: abs(x['delta_T']))\n        else:\n            # Minimize max_rho, then |delta_T|, then maximize rtol\n            best_res = min(results_per_case, key=lambda x: (x['max_rho'], abs(x['delta_T']), -x['rtol']))\n            \n        final_results.append([best_res['rtol'], best_res['delta_T']])\n        \n    print(f\"[{','.join(map(str, final_results))}]\")\n\n# Call solve()\n```\n\nThis structure is robust. The `stabilize` function is the core.\nInside `stabilize`:\n- `v = velocities.copy()`\n- `m = masses`\n- `r = positions`\n- `constraints = [(0,1), (0,2), (1,2)]`\n- `r_pqs = [r[0]-r[1], r[0]-r[2], r[1]-r[2]]`\n- `r_pq_sq_norms = [np.linalg.norm(rpq)**2 for rpq in r_pqs]`\n- Precompute `alpha_pq` denominators for efficiency.\n  - `alpha_01 = r_pq_sq_norms[0] * (1/m[0] + 1/m[1])`\n  - `alpha_02 = r_pq_sq_norms[1] * (1/m[0] + 1/m[2])`\n  - `alpha_12 = r_pq_sq_norms[2] * (1/m[1] + 1/m[2])`\n  - `alphas = [alpha_01, alpha_02, alpha_12]`\n- `for sweep in range(max_sweeps):`\n  - `v_pre_sweep = v.copy()` (or calculate residuals before the sweep)\n  - `for k in range(3):` - iterate over the 3 constraints\n    - `p, q = constraints[k]`\n    - `s_k = np.dot(r_pqs[k], v[p] - v[q])`\n    - `lambda_k = -s_k / alphas[k]`\n    - `v[p] += (lambda_k / m[p]) * r_pqs[k]`\n    - `v[q] -= (lambda_k / m[q]) * r_pqs[k]`\n  - `// Check for convergence`\n  - `M_tot = sum(m)`\n  - `KE_tot = calculate_energy(m, v)`\n  - `v_rms_sq = 2 * KE_tot / M_tot`\n  - `v_rms = np.sqrt(v_rms_sq)`\n  - `max_rho = 0`\n  - `for k in range(3):`\n    - `p, q = constraints[k]`\n    - `s_k = np.dot(r_pqs[k], v[p] - v[q])`\n    - `rho_k = abs(s_k) / (np.sqrt(r_pq_sq_norms[k]) * v_rms)`\n    - `max_rho = max(max_rho, rho_k)`\n  - `if max_rho = rtol:`\n    - `return v, max_rho`\n- `// If loop finishes, we didn't converge within max_sweeps`\n- `// We still need to calculate the final max_rho`\n- `return v, max_rho`\n\nThis seems correct. There's a slight ambiguity: should the convergence check be done with velocities from the start of the sweep or the end? The problem states \"Iterate sweeps until all constraints satisfy a normalized residual threshold\". This implies checking after each full sweep. My implementation plan does this.\nCalculation of `v_rms`: The formula `sqrt(sum(m_i * ||v_i||^2) / sum(m_i))` is equivalent to `sqrt(2 * T / M_tot)`. This is more efficient.\nThe normalized residual `rho_k` formula uses `||r_pq||`, which is `sqrt(r_pq_sq_norms[k])`. I've accounted for that.\n\nFinal check on the problem statement for any subtleties.\n- \"sequential stabilization (Gauss–Seidel) sweep, each constraint is corrected in turn\". This means my plan to update `v` in place within the inner loop over constraints is correct. One correction immediately affects the next.\n- \"multiple sweeps are used until a stopping criterion is met.\" Yes, loop over sweeps.\n- \"Terminate the iteration when `max_k rho_k = rtol`\". Yes, check this after each sweep.\n- Tie-breaking rules are clear.\n- Output format `[rtol, ΔT]` seems to imply floating point numbers. The example `[[\\mathrm{rtol}_A,\\Delta T_A],...` confirms this. A list of lists.\n- Values of constants are given precisely. I must use them.\n\nFor Case C, `v_O = (0,0,0)`, `v_H1 = (20000,0,0)`, `v_{H2} = (0,0,0)`.\nThis configuration has a huge velocity on H1, pointing directly away from O. This will cause a large violation of the O-H1 distance constraint (`g_1`).\n`s_1 = (r_O - r_{H1}) . (v_O - v_{H1}) = (-r_{H1}) . (-v_{H1}) = r_{H1} . v_{H1}`.\n`r_{H1} = (r_OH, 0, 0)`. `v_{H1} = (20000, 0, 0)`.\n`s_1 = r_OH * 20000  0`. This is a large initial residual.\nIt will also violate the H1-H2 constraint.\n`s_3 = (r_{H1} - r_{H2}) . (v_{H1} - v_{H2}) = (r_{H1}-r_{H2}) . v_{H1}`. This will also be non-zero.\nThis case is a good stress test for the algorithm. It will likely require many iterations to converge, especially for smaller `rtol`.\n\nI am confident in my plan. I will now proceed with writing the solution.\n---\n**Problem Validation**\n\n**Step 1: Extract Givens**\n\n- **Model**: Single rigid water molecule with 3 point masses (1 Oxygen, 2 Hydrogen).\n- **Physics**: Holonomic constraints on squared pairwise distances. Basis is Newton's second law $m_i \\,\\mathbf{a}_i = \\mathbf{F}_i$. Kinetic energy $T = \\frac{1}{2}\\sum_{i} m_i \\|\\mathbf{v}_i\\|^2$. Velocity constraint $\\dot{g}_k(\\mathbf{r},\\mathbf{v}) = \\nabla g_k(\\mathbf{r}) \\cdot \\mathbf{v} = 0$.\n- **Masses**: $m_O = 15.999\\ \\mathrm{amu}$, $m_H = 1.008\\ \\mathrm{amu}$.\n- **Conversion**: $1\\ \\mathrm{amu} = 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$.\n- **Geometry**:\n    - $r_{OH} = 9.572\\times 10^{-11}\\ \\mathrm{m}$.\n    - $\\theta = 104.52^\\circ$.\n    - $\\mathbf{r}_O = (0,0,0)$.\n    - $\\mathbf{r}_{H1} = (r_{OH}, 0, 0)$.\n    - $\\mathbf{r}_{H2} = (r_{OH}\\cos\\theta, r_{OH}\\sin\\theta, 0)$.\n- **Constraints**:\n    - $g_1(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_{O}-\\mathbf{r}_{H1}\\|^2 - r_{OH}^2\\right) = 0$.\n    - $g_2(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_{O}-\\mathbf{r}_{H2}\\|^2 - r_{OH}^2\\right) = 0$.\n    - $g_3(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_{H1}-\\mathbf{r}_{H2}\\|^2 - r_{HH}^2\\right) = 0$, where $r_{HH} = 2\\,r_{OH}\\,\\sin(\\theta/2)$.\n- **Velocity Constraints**: $\\dot{g}_k(\\mathbf{r},\\mathbf{v}) = \\mathbf{r}_{pq}\\cdot(\\mathbf{v}_p - \\mathbf{v}_q) = 0$, with $\\mathbf{r}_{pq} = \\mathbf{r}_p - \\mathbf{r}_q$.\n- **Stabilization Algorithm (Gauss-Seidel)**:\n    - Residual: $s_k = \\mathbf{r}_{pq}\\cdot(\\mathbf{v}_p - \\mathbf{v}_q)$.\n    - Correction factor: $\\lambda_k = -\\frac{s_k}{\\alpha_{pq}}$, where $\\alpha_{pq} = \\|\\mathbf{r}_{pq}\\|^2\\left(\\frac{1}{m_p} + \\frac{1}{m_q}\\right)$.\n    - Velocity updates: $\\mathbf{v}_p \\leftarrow \\mathbf{v}_p + \\frac{\\lambda_k}{m_p}\\,\\mathbf{r}_{pq}$, $\\mathbf{v}_q \\leftarrow \\mathbf{v}_q - \\frac{\\lambda_k}{m_q}\\,\\mathbf{r}_{pq}$.\n- **Convergence Criterion**:\n    - Mass-weighted RMS speed: $v_{\\mathrm{rms}} = \\sqrt{\\frac{\\sum_i m_i \\|\\mathbf{v}_i\\|^2}{\\sum_i m_i}}$.\n    - Normalized residual: $\\rho_k = \\frac{|s_k|}{\\|\\mathbf{r}_{pq}\\|\\, v_{\\mathrm{rms}}}$.\n    - Termination: When $\\max_k \\rho_k \\le \\mathrm{rtol}$.\n- **Iteration Limit**: $N_{\\max} = 200$ sweeps.\n- **Objective**:\n    - Target residual bound: $\\rho^\\ast = 10^{-6}$.\n    - Candidate tolerances: $\\mathrm{rtol} \\in \\{10^{-2},10^{-4},10^{-6},10^{-8},10^{-10}\\}$.\n    - Selection Logic:\n        1. Among candidates that achieve $\\max_k \\rho_k \\le \\rho^\\ast$, choose the one that minimizes $|\\Delta T|$.\n        2. If no candidate achieves the target, choose the one with the smallest $\\max_k \\rho_k$. Break ties by smallest $|\\Delta T|$, then by largest $\\mathrm{rtol}$.\n- **Energy Change**: $\\Delta T = T_{\\mathrm{after}} - T_{\\mathrm{before}}$, with $T = \\tfrac{1}{2}\\sum_i m_i \\|\\mathbf{v}_i\\|^2$.\n- **Test Cases (initial velocities in m/s)**:\n    - Case A: $\\mathbf{v}_O = (300,-200,100)$, $\\mathbf{v}_{H1} = (1500,2000,-1000)$, $\\mathbf{v}_{H2} = (-1200,800,600)$.\n    - Case B: $\\boldsymbol{\\omega} = (0,5\\times 10^{11},0)\\ \\mathrm{s}^{-1}$, $\\mathbf{v}_i = \\boldsymbol{\\omega} \\times (\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{COM}})$.\n    - Case C: $\\mathbf{v}_O = (0,0,0)$, $\\mathbf{v}_{H1} = (20000,0,0)$, $\\mathbf{v}_{H2} = (0,0,0)$.\n- **Output Format**: A list of lists: $[[\\mathrm{rtol}_A,\\Delta T_A],[\\mathrm{rtol}_B,\\Delta T_B],[\\mathrm{rtol}_C,\\Delta T_C]]$.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded**: The problem is based on classical mechanics, holonomic constraints, and established numerical methods for molecular simulation (specifically, a RATTLE-like velocity stabilization scheme). The physics and mathematics are standard and sound.\n- **Well-Posed**: The problem is clearly defined. It provides all necessary parameters, initial conditions, a specific algorithm, and a deterministic objective function with explicit tie-breaking rules. A unique solution is expected.\n- **Objective**: The problem is stated in precise, quantitative terms, free of subjective language.\n- **Incomplete or Contradictory Setup**: The problem is self-contained. The geometry is internally consistent, as $r_{HH}$ is derived from $r_{OH}$ and $\\theta$. All required formulas and data are provided.\n- **Unrealistic or Infeasible**: The parameters (masses, geometry) are standard for water models. The velocities are within physically plausible, albeit high-energy, regimes. The computational task is feasible.\n- **Ill-Posed or Poorly Structured**: The structure is clear, and the objective is unambiguous. The iterative algorithm is guaranteed to terminate due to the maximum sweep limit.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is a well-defined, scientifically sound problem in computational physics. I will proceed with the solution.\n\n---\n\nThe problem requires an analysis of energy conservation for a velocity-level constraint stabilization algorithm applied to a rigid water molecule. The solution involves implementing the specified Gauss-Seidel iterative procedure for several initial velocity configurations and selecting an optimal numerical tolerance based on a multi-part objective function.\n\n### System and Geometry Definition\nThe system consists of three point masses: one oxygen atom ($O$, index $0$) and two hydrogen atoms ($H1$, index $1$; $H2$, index $2$). Their masses are $m_O = 15.999 \\times 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$ and $m_{H1} = m_{H2} = m_H = 1.008 \\times 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$.\n\nThe geometry is fixed in a plane. With the oxygen atom at the origin $\\mathbf{r}_0 = (0,0,0)$, the hydrogen positions are defined by the O-H bond length $r_{OH} = 9.572\\times 10^{-11}\\ \\mathrm{m}$ and the H-O-H angle $\\theta = 104.52^\\circ$.\nLet $\\theta_{rad}$ be the angle in radians. The positions are:\n- $\\mathbf{r}_0 = (0, 0, 0)$\n- $\\mathbf{r}_1 = (r_{OH}, 0, 0)$\n- $\\mathbf{r}_2 = (r_{OH}\\cos\\theta_{rad}, r_{OH}\\sin\\theta_{rad}, 0)$\n\n### Holonomic Constraints\nThe rigidity of the molecule is enforced by three holonomic constraints on the squared interatomic distances:\n$g_1(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_0 - \\mathbf{r}_1\\|^2 - r_{OH}^2\\right) = 0$\n$g_2(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_0 - \\mathbf{r}_2\\|^2 - r_{OH}^2\\right) = 0$\n$g_3(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_1 - \\mathbf{r}_2\\|^2 - r_{HH}^2\\right) = 0$\nThe H-H distance $r_{HH}$ is determined by the geometry: $r_{HH} = 2 r_{OH} \\sin(\\theta/2)$. This ensures the constraints are consistent.\n\nFor the motion to be physically valid for a rigid body, the time derivative of each constraint function must be zero. This leads to velocity-level constraints. For a generic constraint $k$ between atoms $p$ and $q$, we have:\n$\\dot{g}_k(\\mathbf{r}, \\mathbf{v}) = \\frac{\\partial g_k}{\\partial \\mathbf{r}} \\cdot \\mathbf{v} = (\\mathbf{r}_p - \\mathbf{r}_q) \\cdot (\\mathbf{v}_p - \\mathbf{v}_q) = 0$\nLet $\\mathbf{r}_{pq} = \\mathbf{r}_p - \\mathbf{r}_q$. The condition is $\\mathbf{r}_{pq} \\cdot (\\mathbf{v}_p - \\mathbf{v}_q) = 0$. This means the relative velocity of the two atoms must be orthogonal to their separation vector.\n\n### Velocity Stabilization Algorithm\nNumerical integration schemes can introduce small errors, causing the velocities to drift off the constraint manifold, i.e., $\\mathbf{r}_{pq} \\cdot (\\mathbf{v}_p - \\mathbf{v}_q) \\neq 0$. The stabilization algorithm projects the velocities back onto this manifold. The prescribed method is a Gauss-Seidel iterative procedure. In each sweep, we sequentially correct for each of the three constraints.\n\nFor a single constraint $k$ between atoms $p$ and $q$, the violation is measured by the residual $s_k = \\mathbf{r}_{pq} \\cdot (\\mathbf{v}_p - \\mathbf{v}_q)$. The goal is to find velocity corrections $\\Delta\\mathbf{v}_p$ and $\\Delta\\mathbf{v}_q$ that nullify this residual. The method provides a solution that corresponds to applying corrective impulses along the direction of the separation vector $\\mathbf{r}_{pq}$. This direction is parallel to the gradient of the constraint function, $\\nabla_{\\mathbf{r}_p} g_k = \\mathbf{r}_{pq}$. The changes are:\n$\\Delta \\mathbf{v}_p = \\frac{\\lambda_k}{m_p} \\mathbf{r}_{pq}$\n$\\Delta \\mathbf{v}_q = -\\frac{\\lambda_k}{m_q} \\mathbf{r}_{pq}$\nThe scalar $\\lambda_k$ is a Lagrange multiplier determined by requiring the new velocities $\\mathbf{v}'_p = \\mathbf{v}_p + \\Delta\\mathbf{v}_p$ and $\\mathbf{v}'_q = \\mathbf{v}_q + \\Delta\\mathbf{v}_q$ to satisfy the constraint:\n$\\mathbf{r}_{pq} \\cdot (\\mathbf{v}'_p - \\mathbf{v}'_q) = 0 \\implies \\mathbf{r}_{pq} \\cdot (\\mathbf{v}_p - \\mathbf{v}_q) + \\lambda_k \\|\\mathbf{r}_{pq}\\|^2 \\left( \\frac{1}{m_p} + \\frac{1}{m_q} \\right) = 0$\nSolving for $\\lambda_k$ gives:\n$\\lambda_k = - \\frac{s_k}{\\alpha_{pq}}$, where $\\alpha_{pq} = \\|\\mathbf{r}_{pq}\\|^2 \\left(\\frac{1}{m_p} + \\frac{1}{m_q}\\right)$.\nThe velocities are updated sequentially for each of the three constraints. Because correcting one constraint can introduce a small violation in others, the process is repeated in sweeps until all constraints are satisfied to a desired tolerance.\n\n### Convergence and Tolerance\nThe iteration continues until the maximum normalized residual $\\max_k \\rho_k$ falls below a specified tolerance $\\mathrm{rtol}$. The normalized residual $\\rho_k = \\frac{|s_k|}{\\|\\mathbf{r}_{pq}\\| v_{\\mathrm{rms}}}$ compares the speed of constraint violation to the system's overall root-mean-square speed $v_{\\mathrm{rms}} = \\sqrt{2T/M_{tot}}$, where $T$ is the total kinetic energy and $M_{tot}$ is the total mass. Iterations stop if convergence is reached or after a maximum of $N_{max}=200$ sweeps.\n\n### Energy Change and Tolerance Selection\nThe kinetic energy before stabilization is $T_{\\mathrm{before}} = \\frac{1}{2}\\sum_i m_i \\|\\mathbf{v}_i^{\\mathrm{(before)}}\\|^2$. After stabilization, the final kinetic energy is $T_{\\mathrm{after}} = \\frac{1}{2}\\sum_i m_i \\|\\mathbf{v}_i^{\\mathrm{(after)}}\\|^2$. The change is $\\Delta T = T_{\\mathrm{after}} - T_{\\mathrm{before}}$. While each individual correction step is designed to be minimal in a mass-weighted sense, the sequential nature of the Gauss-Seidel scheme generally leads to a non-zero $\\Delta T$.\n\nThe objective is to select the best tolerance `rtol` from the set $\\{10^{-2},10^{-4},10^{-6},10^{-8},10^{-10}\\}$ for each test case.\n1. Primary Goal: Satisfy the strict constraint requirement $\\max_k \\rho_k \\le \\rho^\\ast=10^{-6}$. Among tolerances that achieve this, select the one that results in the minimum absolute energy change $|\\Delta T|$.\n2. Fallback: If no tolerance meets the primary goal, select the one that produces the smallest $\\max_k \\rho_k$. Ties are broken by choosing the smallest $|\\Delta T|$, and then by choosing the largest `rtol`.\n\nThe computational procedure is to run the stabilization for each test case with each candidate `rtol`, record the final $\\max_k \\rho_k$ and $\\Delta T$, and then apply the selection logic to find the recommended tolerance and corresponding energy change.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the rigid water molecule constraint stabilization problem.\n    \"\"\"\n    #\n    # Step 1: Define Constants and System Geometry\n    #\n    AMU_TO_KG = 1.66053906660e-27\n    M_O_AMU = 15.999\n    M_H_AMU = 1.008\n    R_OH = 9.572e-11  # meters\n    THETA_DEG = 104.52  # degrees\n\n    m_o = M_O_AMU * AMU_TO_KG\n    m_h = M_H_AMU * AMU_TO_KG\n    masses = np.array([m_o, m_h, m_h])\n    \n    theta_rad = np.deg2rad(THETA_DEG)\n    r_h1 = np.array([R_OH, 0.0, 0.0])\n    r_h2 = np.array([R_OH * np.cos(theta_rad), R_OH * np.sin(theta_rad), 0.0])\n    r_o = np.array([0.0, 0.0, 0.0])\n    \n    positions = np.array([r_o, r_h1, r_h2])\n    \n    # Store constraint definitions: atom pairs (p, q) and reference squared distance\n    r_hh_sq = (2 * R_OH * np.sin(theta_rad / 2))**2\n    constraint_defs = [\n        (0, 1, R_OH**2),\n        (0, 2, R_OH**2),\n        (1, 2, r_hh_sq)\n    ]\n\n    r_pqs = [positions[p] - positions[q] for p, q, _ in constraint_defs]\n    r_pq_norms = [np.linalg.norm(rpq) for rpq in r_pqs]\n    \n    # Precompute alpha denominators for lambda calculation\n    alphas = []\n    for (p, q, _), rpq in zip(constraint_defs, r_pqs):\n        alpha = np.dot(rpq, rpq) * (1.0 / masses[p] + 1.0 / masses[q])\n        alphas.append(alpha)\n\n    #\n    # Step 2: Define Stabilization and Helper Functions\n    #\n    def calculate_ke(m, v):\n        \"\"\"Calculates total kinetic energy.\"\"\"\n        ke = 0.0\n        for i in range(len(m)):\n            ke += 0.5 * m[i] * np.dot(v[i], v[i])\n        return ke\n\n    def stabilize(v_init, rtol, max_sweeps):\n        \"\"\"Performs Gauss-Seidel velocity stabilization.\"\"\"\n        v = v_init.copy()\n        \n        for _ in range(max_sweeps):\n            for i, (p, q, _) in enumerate(constraint_defs):\n                s_k = np.dot(r_pqs[i], v[p] - v[q])\n                lambda_k = -s_k / alphas[i]\n                \n                v[p] += (lambda_k / masses[p]) * r_pqs[i]\n                v[q] -= (lambda_k / masses[q]) * r_pqs[i]\n                \n            # Convergence check after a full sweep\n            total_mass = np.sum(masses)\n            total_ke = calculate_ke(masses, v)\n            if total_ke == 0:\n                # If all velocities are zero, residuals are zero\n                max_rho = 0.0\n            else:\n                v_rms = np.sqrt(2 * total_ke / total_mass)\n                max_rho = 0.0\n                for i, (p, q, _) in enumerate(constraint_defs):\n                    s_k = np.dot(r_pqs[i], v[p] - v[q])\n                    rho_k = abs(s_k) / (r_pq_norms[i] * v_rms)\n                    if rho_k > max_rho:\n                        max_rho = rho_k\n            \n            if max_rho = rtol:\n                return v, max_rho\n        \n        # If max_sweeps is reached, calculate and return final residual\n        total_mass = np.sum(masses)\n        total_ke = calculate_ke(masses, v)\n        if total_ke == 0:\n            max_rho = 0.0\n        else:\n            v_rms = np.sqrt(2 * total_ke / total_mass)\n            max_rho = 0.0\n            for i, (p, q, _) in enumerate(constraint_defs):\n                s_k = np.dot(r_pqs[i], v[p] - v[q])\n                rho_k = abs(s_k) / (r_pq_norms[i] * v_rms)\n                if rho_k > max_rho:\n                    max_rho = rho_k\n                    \n        return v, max_rho\n\n    #\n    # Step 3: Define Test Cases\n    #\n    # Case A\n    v_a = np.array([\n        [300.0, -200.0, 100.0],\n        [1500.0, 2000.0, -1000.0],\n        [-1200.0, 800.0, 600.0]\n    ])\n\n    # Case B\n    omega_b = np.array([0.0, 5.0e11, 0.0])\n    total_mass_b = np.sum(masses)\n    r_com_b = (masses[0] * positions[0] + masses[1] * positions[1] + masses[2] * positions[2]) / total_mass_b\n    v_b = np.array([\n        np.cross(omega_b, positions[0] - r_com_b),\n        np.cross(omega_b, positions[1] - r_com_b),\n        np.cross(omega_b, positions[2] - r_com_b)\n    ])\n    \n    # Case C\n    v_c = np.array([\n        [0.0, 0.0, 0.0],\n        [20000.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0]\n    ])\n    \n    test_cases = [v_a, v_b, v_c]\n    \n    #\n    # Step 4: Run Simulations and Apply Selection Logic\n    #\n    candidate_rtols = [1e-2, 1e-4, 1e-6, 1e-8, 1e-10]\n    rho_target = 1e-6\n    max_sweeps = 200\n    \n    final_results = []\n    \n    for v_initial in test_cases:\n        t_before = calculate_ke(masses, v_initial)\n        \n        results_per_case = []\n        for rtol in candidate_rtols:\n            v_final, max_rho_final = stabilize(v_initial, rtol, max_sweeps)\n            t_after = calculate_ke(masses, v_final)\n            delta_t = t_after - t_before\n            \n            results_per_case.append({\n                'rtol': rtol,\n                'max_rho': max_rho_final,\n                'delta_T': delta_t\n            })\n\n        # Apply selection logic\n        achieved_target = [res for res in results_per_case if res['max_rho'] = rho_target]\n        \n        if achieved_target:\n            # Minimize |delta_T| among those meeting the target\n            best_res = min(achieved_target, key=lambda x: abs(x['delta_T']))\n        else:\n            # Minimize max_rho, then |delta_T|, then maximize rtol\n            # Note: min on -rtol maximizes rtol\n            best_res = min(results_per_case, key=lambda x: (x['max_rho'], abs(x['delta_T']), -x['rtol']))\n\n        final_results.append([best_res['rtol'], best_res['delta_T']])\n\n    #\n    # Step 5: Format and Print Final Output\n    #\n    output_str = f\"[{','.join(map(str, final_results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}