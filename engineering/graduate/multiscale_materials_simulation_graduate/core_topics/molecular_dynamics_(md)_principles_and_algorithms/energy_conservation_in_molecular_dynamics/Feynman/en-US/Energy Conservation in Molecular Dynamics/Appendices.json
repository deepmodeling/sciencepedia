{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of reliable Molecular Dynamics (MD) simulations is the choice of a numerical integrator that respects the underlying physics of the system. For Hamiltonian systems, this means using an integrator that approximately conserves energy over long timescales. This first practice provides a foundational, hands-on comparison between the symplectic velocity Verlet algorithm, a workhorse of MD, and the general-purpose, non-symplectic Runge-Kutta 4 method . By implementing both and measuring their long-term energy drift, you will directly observe why symplectic integrators are indispensable for stable MD simulations.",
            "id": "3805850",
            "problem": "You are given a separable Hamiltonian dynamical system with one Cartesian degree of freedom, defined by the Hamiltonian $H(x,p) = T(p) + V(x)$, where $T(p) = \\frac{p^2}{2m}$ and $V(x)$ is a scalar potential energy. The canonical equations of motion are equivalent to Newton's second law with $p = m v$ and $m \\ddot{x} = -\\frac{\\partial V}{\\partial x}$. The total energy $H(x,p)$ should be conserved for exact dynamics. Your task is to implement two time-stepping algorithms for this separable Hamiltonian system, simulate long-time dynamics for several test cases, and quantify the energy drift for each integrator. The two algorithms to compare are: the velocity Verlet method, which is a symplectic composition method for separable Hamiltonians, and the classical fourth-order Runge–Kutta method (Runge–Kutta 4), which is a non-symplectic general-purpose ordinary differential equation integrator. You must base your implementation on the fundamental laws and core definitions stated above, without using any pre-derived formulas that target the final result.\n\nDefinitions and requirements:\n- The state variables are $x(t)$ and $v(t)$, where $v(t) = \\dot{x}(t)$ and $p(t) = m v(t)$.\n- The force is $F(x) = -\\frac{\\partial V}{\\partial x}$ and the acceleration is $a(x) = \\frac{F(x)}{m}$.\n- The total energy is $H(x,p) = \\frac{p^2}{2m} + V(x) = \\frac{1}{2} m v^2 + V(x)$.\n- The velocity Verlet update at time step size $\\Delta t$ advances $(x_n, v_n)$ to $(x_{n+1}, v_{n+1})$ using the sequence: half-step velocity update, position update, and another half-step velocity update, with acceleration evaluated at positions $x_n$ and $x_{n+1}$.\n- The Runge–Kutta 4 update advances the state vector $y = [x, v]^\\top$ via four staged evaluations of the right-hand side $f(y) = [v, a(x)]^\\top$ and a weighted average to produce $y_{n+1}$.\n\nEnergy drift metric:\n- For a given integrator, time step $\\Delta t$, total simulation time $T$, and initial conditions $(x(0), v(0))$, integrate the system and record the total energy $H(t_i)$ at each discrete time $t_i = i \\Delta t$ for $i = 0, 1, \\dots, N$ where $N = \\lfloor T / \\Delta t \\rfloor$.\n- Define the energy deviation $E_i = H(t_i) - H(0)$.\n- Compute the best-fit linear drift rate $s$ (in Joules per second) by least squares regression of $E_i$ versus $t_i$, i.e., find $s$ that minimizes $\\sum_{i=0}^N (E_i - s t_i - b)^2$ over $s$ and $b$, and report the slope $s$. Explicitly, let $\\bar{t} = \\frac{1}{N+1} \\sum_{i=0}^N t_i$ and $\\bar{E} = \\frac{1}{N+1} \\sum_{i=0}^N E_i$, then compute $$s = \\frac{\\sum_{i=0}^N (t_i - \\bar{t})(E_i - \\bar{E})}{\\sum_{i=0}^N (t_i - \\bar{t})^2}.$$\n\nPotentials and units:\n- Use two potentials, both separable in the sense $H = T(p) + V(x)$:\n  1. Harmonic potential: $V(x) = \\frac{1}{2} k x^2$, with force $F(x) = -k x$.\n  2. Anharmonic quartic potential: $V(x) = \\frac{1}{2} k x^2 + \\frac{1}{4} \\alpha x^4$, with force $F(x) = -k x - \\alpha x^3$.\n- All physical quantities are in SI units: mass in kilograms (kg), position in meters (m), time in seconds (s), spring constant $k$ in newtons per meter (N/m), quartic coefficient $\\alpha$ in newtons per cubic meter (N/m$^3$), and energy in joules (J). The drift rate must be reported in joules per second (J/s).\n\nImplement both integrators, simulate, and compute the drift rates for each case in the test suite below. No external input is allowed; your program must be self-contained. Use double-precision floating point arithmetic.\n\nTest suite:\n- Case A (moderate time step, harmonic oscillator):\n  - $m = 1$ kg, $k = 1$ N/m, initial condition $x(0) = 1$ m, $v(0) = 0$ m/s.\n  - Time step $\\Delta t = 0.05$ s.\n  - Total simulation time $T = 100 \\times 2\\pi \\sqrt{m/k}$ s.\n- Case B (near stability boundary time step, harmonic oscillator):\n  - $m = 1$ kg, $k = 1$ N/m, initial condition $x(0) = 1$ m, $v(0) = 0$ m/s.\n  - Time step $\\Delta t = 1.9$ s.\n  - Total simulation time $T = 400$ s.\n- Case C (anharmonic quartic potential, moderate time step):\n  - $m = 1$ kg, $k = 1$ N/m, $\\alpha = 1$ N/m$^3$, initial condition $x(0) = 1$ m, $v(0) = 0$ m/s.\n  - Time step $\\Delta t = 0.01$ s.\n  - Total simulation time $T = 200$ s.\n- Case D (stiff harmonic oscillator, many periods):\n  - $m = 1$ kg, $k = 100$ N/m, initial condition $x(0) = 0.1$ m, $v(0) = 0$ m/s.\n  - Time step $\\Delta t = 0.02$ s.\n  - Total simulation time $T = 100 \\times 2\\pi \\sqrt{m/k}$ s.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and must be a two-element list $[s_{\\mathrm{RK4}}, s_{\\mathrm{VV}}]$ in joules per second, ordered as Cases A, B, C, D. For example: $[[s_A^{\\mathrm{RK4}}, s_A^{\\mathrm{VV}}],[s_B^{\\mathrm{RK4}}, s_B^{\\mathrm{VV}}],[s_C^{\\mathrm{RK4}}, s_C^{\\mathrm{VV}}],[s_D^{\\mathrm{RK4}}, s_D^{\\mathrm{VV}}]]$.",
            "solution": "The problem requires a comparative analysis of two numerical integration algorithms, the velocity Verlet method and the classical fourth-order Runge-Kutta method, in the context of a one-dimensional, separable Hamiltonian system. The primary goal is to quantify and compare the long-term energy conservation properties of these integrators by computing the rate of energy drift.\n\nThe validation of the problem statement proceeds as follows.\n\n**Step 1: Extract Givens**\n\n*   **System Definition**: A separable Hamiltonian system with $H(x,p) = T(p) + V(x)$, where $T(p) = \\frac{p^2}{2m}$ and $V(x)$ is a scalar potential.\n*   **Equations of Motion**: $p = mv$, $m \\ddot{x} = -\\frac{\\partial V}{\\partial x}$.\n*   **State Variables**: $x(t)$, $v(t) = \\dot{x}(t)$.\n*   **Force and Acceleration**: $F(x) = -\\frac{\\partial V}{\\partial x}$, $a(x) = \\frac{F(x)}{m}$.\n*   **Total Energy**: $H(x,p) = \\frac{1}{2} m v^2 + V(x)$.\n*   **Velocity Verlet (VV) Integrator**: Update from $(x_n, v_n)$ to $(x_{n+1}, v_{n+1})$ in three steps:\n    1.  Half-step velocity update.\n    2.  Full-step position update.\n    3.  Second half-step velocity update.\n*   **Runge-Kutta 4 (RK4) Integrator**: Update for state vector $y = [x, v]^\\top$ using the function $f(y) = [v, a(x)]^\\top$ and four staged evaluations.\n*   **Energy Drift Metric**:\n    *   Simulate for total time $T$ with time step $\\Delta t$, generating $N+1$ data points where $N = \\lfloor T / \\Delta t \\rfloor$.\n    *   Time points: $t_i = i \\Delta t$ for $i = 0, \\dots, N$.\n    *   Energy deviation: $E_i = H(t_i) - H(0)$.\n    *   Drift rate $s$: The slope from a linear least squares fit of $E_i$ versus $t_i$, given by the formula $s = \\frac{\\sum_{i=0}^N (t_i - \\bar{t})(E_i - \\bar{E})}{\\sum_{i=0}^N (t_i - \\bar{t})^2}$, where $\\bar{t} = \\frac{1}{N+1} \\sum_{i=0}^N t_i$ and $\\bar{E} = \\frac{1}{N+1} \\sum_{i=0}^N E_i$.\n*   **Potentials**:\n    1.  Harmonic: $V(x) = \\frac{1}{2} k x^2$, $F(x) = -k x$.\n    2.  Anharmonic Quartic: $V(x) = \\frac{1}{2} k x^2 + \\frac{1}{4} \\alpha x^4$, $F(x) = -k x - \\alpha x^3$.\n*   **Units**: SI units (kg, m, s, N/m, N/m$^3$, J, J/s).\n*   **Test Cases**:\n    *   Case A: Harmonic, $m=1$, $k=1$, $x(0)=1$, $v(0)=0$, $\\Delta t=0.05$, $T=100 \\times 2\\pi \\sqrt{m/k}$.\n    *   Case B: Harmonic, $m=1$, $k=1$, $x(0)=1$, $v(0)=0$, $\\Delta t=1.9$, $T=400$.\n    *   Case C: Anharmonic, $m=1$, $k=1$, $\\alpha=1$, $x(0)=1$, $v(0)=0$, $\\Delta t=0.01$, $T=200$.\n    *   Case D: Harmonic, $m=1$, $k=100$, $x(0)=0.1$, $v(0)=0$, $\\Delta t=0.02$, $T=100 \\times 2\\pi \\sqrt{m/k}$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is scientifically grounded, well-posed, and objective. It is based on fundamental principles of classical Hamiltonian mechanics and standard numerical methods for ordinary differential equations. The definitions of the integrators are standard, and the energy drift metric is a well-defined statistical measure. All parameters required for simulation and analysis are provided, and there are no internal contradictions. The problem is a standard exercise in computational physics designed to illustrate the superior long-term energy conservation of symplectic integrators (like velocity Verlet) compared to general-purpose non-symplectic integrators (like RK4) for Hamiltonian systems.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A complete, reasoned solution will be provided.\n\n**Solution Derivation**\n\nThe core of the problem lies in the numerical integration of Newton's equations of motion, which are derived from a Hamiltonian. The total energy $H$ is a conserved quantity for the exact dynamics, meaning $\\frac{dH}{dt}=0$. Numerical integrators, however, introduce discretization errors that can cause the computed energy to either fluctuate or systematically drift over time.\n\n**1. Hamiltonian System**\n\nThe system is described by the state $(x, p)$ in phase space. The equations of motion are given by Hamilton's equations:\n$$ \\dot{x} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m} $$\n$$ \\dot{p} = -\\frac{\\partial H}{\\partial x} = -\\frac{\\partial V}{\\partial x} = F(x) $$\nUsing $p = mv$, these are equivalent to $\\dot{x} = v$ and $\\dot{v} = F(x)/m = a(x)$, forming a system of two first-order ordinary differential equations (ODEs). We write this as $\\dot{\\mathbf{y}} = \\mathbf{f}(\\mathbf{y})$, where $\\mathbf{y}(t) = [x(t), v(t)]^\\top$ and $\\mathbf{f}(\\mathbf{y}) = [v, a(x)]^\\top$.\n\n**2. Velocity Verlet (VV) Integrator**\n\nThe velocity Verlet algorithm is a member of the family of symplectic integrators. These algorithms are specifically designed for Hamiltonian systems and have the property of preserving the phase space volume element, which leads to excellent long-term energy stability. The energy does not drift systematically but rather oscillates around its true initial value.\n\nThe algorithm, advancing from time $t_n$ to $t_{n+1} = t_n + \\Delta t$, is derived from a symmetric splitting of the Hamiltonian evolution operator. Following the problem's descriptive definition:\n\n1.  **First half-step velocity update**: The velocity is advanced by a half time step using the current acceleration $a_n = a(x_n)$.\n    $$ v_{n+1/2} = v_n + a_n \\frac{\\Delta t}{2} $$\n2.  **Full-step position update**: The position is advanced by a full time step using the half-step velocity.\n    $$ x_{n+1} = x_n + v_{n+1/2} \\Delta t $$\n3.  **Second half-step velocity update**: First, compute the new acceleration $a_{n+1} = a(x_{n+1})$ at the new position. Then, complete the velocity update.\n    $$ v_{n+1} = v_{n+1/2} + a_{n+1} \\frac{\\Delta t}{2} $$\n\nThese three steps constitute the update from $(x_n, v_n)$ to $(x_{n+1}, v_{n+1})$.\n\n**3. Runge-Kutta 4 (RK4) Integrator**\n\nThe classical fourth-order Runge-Kutta method is a widely used, high-accuracy, general-purpose ODE solver. It is not symplectic. While it is highly accurate for a single step (local error is $O(\\Delta t^5)$), for long-term integrations of Hamiltonian systems, the small errors accumulate in a way that typically causes the total energy to drift systematically.\n\nThe update from $\\mathbf{y}_n$ to $\\mathbf{y}_{n+1}$ is given by:\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) $$\nwhere the stages $\\mathbf{k}_i$ are vectors with two components, $[k_{i,x}, k_{i,v}]^\\top$. For our system $\\dot{\\mathbf{y}} = [v, a(x)]^\\top$, the stages are:\n$$ \\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) = [v_n, a(x_n)]^\\top $$\n$$ \\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) = \\left[ v_n + \\frac{\\Delta t}{2} k_{1,v}, a\\left(x_n + \\frac{\\Delta t}{2} k_{1,x}\\right) \\right]^\\top $$\n$$ \\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) = \\left[ v_n + \\frac{\\Delta t}{2} k_{2,v}, a\\left(x_n + \\frac{\\Delta t}{2} k_{2,x}\\right) \\right]^\\top $$\n$$ \\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + \\Delta t \\mathbf{k}_3) = \\left[ v_n + \\Delta t k_{3,v}, a(x_n + \\Delta t k_{3,x}) \\right]^\\top $$\nThe components for position and velocity are then updated using the weighted average of the corresponding components of the stage vectors.\n\n**4. Energy Drift Calculation**\n\nFor each simulation run (a choice of integrator, potential, and parameters), we generate a time series of states $(x_i, v_i)$ at times $t_i = i \\Delta t$ for $i \\in \\{0, 1, ..., N\\}$. From this, we compute the total energy $H_i = \\frac{1}{2}m v_i^2 + V(x_i)$ and the energy deviation $E_i = H_i - H_0$.\n\nWe seek the slope $s$ of the best-fit line to the points $(t_i, E_i)$. The method of least squares minimizes the sum of squared residuals $S(s, b) = \\sum_{i=0}^N (E_i - (s t_i + b))^2$. The slope $s$ that minimizes this sum is given by the standard formula for simple linear regression:\n$$ s = \\frac{\\sum_{i=0}^N (t_i - \\bar{t})(E_i - \\bar{E})}{\\sum_{i=0}^N (t_i - \\bar{t})^2} = \\frac{\\text{Cov}(t, E)}{\\text{Var}(t)} $$\nwhere $\\bar{t}$ and $\\bar{E}$ are the sample means of the time points and energy deviations, respectively. This value $s$ represents the average rate of energy change in Joules per second over the course of the simulation.\n\nThe implementation will consist of functions for the physics (potentials and forces), the two integrators, the simulation driver, and the drift calculation, executed for each of the four specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n\n    # --- Physics and Potential Definitions ---\n\n    def force_harmonic(x, k, **kwargs):\n        \"\"\"Force for the harmonic potential.\"\"\"\n        return -k * x\n\n    def potential_harmonic(x, k, **kwargs):\n        \"\"\"Harmonic potential energy.\"\"\"\n        return 0.5 * k * x**2\n\n    def force_quartic(x, k, alpha, **kwargs):\n        \"\"\"Force for the anharmonic quartic potential.\"\"\"\n        return -k * x - alpha * x**3\n\n    def potential_quartic(x, k, alpha, **kwargs):\n        \"\"\"Anharmonic quartic potential energy.\"\"\"\n        return 0.5 * k * x**2 + 0.25 * alpha * x**4\n\n    def acceleration(x, m, force_func, **params):\n        \"\"\"Calculate acceleration given a force function.\"\"\"\n        return force_func(x, **params) / m\n        \n    def total_energy(x, v, m, potential_func, **params):\n        \"\"\"Calculate total energy of the system.\"\"\"\n        kinetic = 0.5 * m * v**2\n        potential = potential_func(x, **params)\n        return kinetic + potential\n\n    # --- Integrator Implementations ---\n\n    def integrator_vv(x0, v0, m, dt, N, force_func, **params):\n        \"\"\"Velocity Verlet integrator.\"\"\"\n        x_hist = np.zeros(N + 1)\n        v_hist = np.zeros(N + 1)\n        x_hist[0], v_hist[0] = x0, v0\n\n        x, v = x0, v0\n        for i in range(N):\n            a_n = acceleration(x, m, force_func, **params)\n            v_half = v + 0.5 * dt * a_n\n            x_new = x + dt * v_half\n            a_n_plus_1 = acceleration(x_new, m, force_func, **params)\n            v_new = v_half + 0.5 * dt * a_n_plus_1\n            \n            x, v = x_new, v_new\n            x_hist[i+1], v_hist[i+1] = x, v\n        \n        return x_hist, v_hist\n\n    def integrator_rk4(x0, v0, m, dt, N, force_func, **params):\n        \"\"\"Classical 4th-order Runge-Kutta integrator.\"\"\"\n        x_hist = np.zeros(N + 1)\n        v_hist = np.zeros(N + 1)\n        x_hist[0], v_hist[0] = x0, v0\n\n        x, v = x0, v0\n        for i in range(N):\n            # k1\n            k1_x = v\n            k1_v = acceleration(x, m, force_func, **params)\n            \n            # k2\n            k2_x = v + 0.5 * dt * k1_v\n            k2_v = acceleration(x + 0.5 * dt * k1_x, m, force_func, **params)\n            \n            # k3\n            k3_x = v + 0.5 * dt * k2_v\n            k3_v = acceleration(x + 0.5 * dt * k2_x, m, force_func, **params)\n            \n            # k4\n            k4_x = v + dt * k3_v\n            k4_v = acceleration(x + dt * k3_x, m, force_func, **params)\n            \n            # Update\n            x_new = x + (dt / 6.0) * (k1_x + 2.0*k2_x + 2.0*k3_x + k4_x)\n            v_new = v + (dt / 6.0) * (k1_v + 2.0*k2_v + 2.0*k3_v + k4_v)\n            \n            x, v = x_new, v_new\n            x_hist[i+1], v_hist[i+1] = x, v\n            \n        return x_hist, v_hist\n        \n    # --- Analysis Definition ---\n    \n    def calculate_drift(times, energies):\n        \"\"\"\n        Calculates the energy drift rate s via linear regression.\n        s = Cov(t, E) / Var(t)\n        \"\"\"\n        t_bar = np.mean(times)\n        e_bar = np.mean(energies)\n        \n        numerator = np.sum((times - t_bar) * (energies - e_bar))\n        denominator = np.sum((times - t_bar)**2)\n        \n        if denominator == 0:\n            return 0.0\n        \n        return numerator / denominator\n\n    # --- Test Suite Definition ---\n    \n    test_cases = [\n        # Case A\n        {'name': 'A', 'm': 1.0, 'k': 1.0, 'alpha': 0.0, \n         'x0': 1.0, 'v0': 0.0, 'dt': 0.05, \n         'T': 100 * 2 * np.pi * np.sqrt(1.0/1.0),\n         'force_func': force_harmonic, 'pot_func': potential_harmonic,\n         'params': {'k': 1.0}},\n        # Case B\n        {'name': 'B', 'm': 1.0, 'k': 1.0, 'alpha': 0.0, \n         'x0': 1.0, 'v0': 0.0, 'dt': 1.9, 'T': 400.0,\n         'force_func': force_harmonic, 'pot_func': potential_harmonic,\n         'params': {'k': 1.0}},\n        # Case C\n        {'name': 'C', 'm': 1.0, 'k': 1.0, 'alpha': 1.0, \n         'x0': 1.0, 'v0': 0.0, 'dt': 0.01, 'T': 200.0,\n         'force_func': force_quartic, 'pot_func': potential_quartic,\n         'params': {'k': 1.0, 'alpha': 1.0}},\n        # Case D\n        {'name': 'D', 'm': 1.0, 'k': 100.0, 'alpha': 0.0, \n         'x0': 0.1, 'v0': 0.0, 'dt': 0.02, \n         'T': 100 * 2 * np.pi * np.sqrt(1.0/100.0),\n         'force_func': force_harmonic, 'pot_func': potential_harmonic,\n         'params': {'k': 100.0}},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = int(np.floor(case['T'] / case['dt']))\n        times = np.linspace(0, N * case['dt'], N + 1)\n        \n        case_results = []\n        \n        # Runge-Kutta 4\n        x_hist_rk4, v_hist_rk4 = integrator_rk4(\n            case['x0'], case['v0'], case['m'], case['dt'], N, case['force_func'], **case['params']\n        )\n        energies_rk4 = total_energy(x_hist_rk4, v_hist_rk4, case['m'], case['pot_func'], **case['params'])\n        e_dev_rk4 = energies_rk4 - energies_rk4[0]\n        drift_rk4 = calculate_drift(times, e_dev_rk4)\n        case_results.append(drift_rk4)\n\n        # Velocity Verlet\n        x_hist_vv, v_hist_vv = integrator_vv(\n            case['x0'], case['v0'], case['m'], case['dt'], N, case['force_func'], **case['params']\n        )\n        energies_vv = total_energy(x_hist_vv, v_hist_vv, case['m'], case['pot_func'], **case['params'])\n        e_dev_vv = energies_vv - energies_vv[0]\n        drift_vv = calculate_drift(times, e_dev_vv)\n        case_results.append(drift_vv)\n        \n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While a symplectic integrator is necessary for energy conservation, it is not sufficient. The physical model itself, particularly the potential energy function, must be carefully constructed to avoid introducing artificial energy sources or sinks. This practice examines a common pitfall in MD: the use of potential cutoffs to improve computational efficiency . You will quantify the discrete energy jumps caused by a naively truncated Lennard-Jones potential and contrast this with the smooth, energy-conserving behavior of a switched potential, revealing the critical link between the smoothness of the potential and the stability of the simulation.",
            "id": "3805821",
            "problem": "You are tasked with deriving, implementing, and numerically evaluating the energy drift per cutoff-crossing event for a single particle pair in a Microcanonical Ensemble (NVE) molecular dynamics step when using either a truncated Lennard-Jones (LJ) potential or a switched (smoothly decaying) Lennard-Jones potential. The objective is to quantify the change in the total mechanical energy per crossing event near the cutoff radius $r_c$ in reduced Lennard-Jones units, that is, distances in units of $\\sigma$, velocities in units of $\\sigma/\\tau$, energies in units of $\\epsilon$, and time in units of $\\tau$, where $\\tau = \\sqrt{m \\sigma^2 / \\epsilon}$ for particle mass $m$. The final outputs of your program must be expressed as energy drifts in units of $\\epsilon$.\n\nStart from the following foundational base:\n- Newton's Second Law: $m \\, \\mathrm{d}^2 \\mathbf{r}/\\mathrm{d}t^2 = \\mathbf{F}$.\n- Definition of velocity: $\\mathbf{v} = \\mathrm{d}\\mathbf{r}/\\mathrm{d}t$.\n- Mechanical energy in classical mechanics: $E = K + U$, where $K = \\frac{1}{2} m v^2$ is kinetic energy and $U$ is potential energy.\n- For a conservative potential $U(\\mathbf{r})$, the force is $\\mathbf{F}(\\mathbf{r}) = - \\nabla U(\\mathbf{r})$. For smooth $U$, energy is conserved under exact dynamics, i.e., $\\mathrm{d}E/\\mathrm{d}t = \\mathbf{v} \\cdot (\\mathbf{F} + \\nabla U) = 0$.\n- Lennard-Jones potential: $U_{\\mathrm{LJ}}(r) = 4 \\epsilon \\left[ \\left( \\frac{\\sigma}{r} \\right)^{12} - \\left( \\frac{\\sigma}{r} \\right)^6 \\right]$.\n\nDefine two models for the interaction near the cutoff radius:\n1. Truncated-unshifted Lennard-Jones potential:\n   $$U_{\\mathrm{T}}(r) = \\begin{cases}\n   U_{\\mathrm{LJ}}(r),  r  r_c, \\\\\n   0,  r \\ge r_c,\n   \\end{cases}\n   \\quad\n   \\mathbf{F}_{\\mathrm{T}}(r) = \\begin{cases}\n   -\\nabla U_{\\mathrm{LJ}}(r),  r  r_c, \\\\\n   \\mathbf{0},  r \\ge r_c.\n   \\end{cases}$$\n   Note that $U_{\\mathrm{T}}(r)$ has a finite jump of magnitude $\\Delta U = U_{\\mathrm{LJ}}(r_c) - 0$ at $r_c$, which violates differentiability and can cause a discrete energy change when the pair crosses $r_c$.\n2. Switched Lennard-Jones potential: define a smooth switching function $S(r)$ such that $S(r) = 1$ for $r \\le r_s$, $S(r) = 0$ for $r \\ge r_c$, and $S(r)$ is sufficiently smooth on $[r_s, r_c]$. One choice is the quintic smoothstep\n   $$x = \\frac{r - r_s}{r_c - r_s}, \\quad S(r) = \\begin{cases}\n   1,  r \\le r_s, \\\\\n   1 - 10 x^3 + 15 x^4 - 6 x^5,  r_s  r  r_c, \\\\\n   0,  r \\ge r_c,\n   \\end{cases}$$\n   so that $S(r)$ and $\\frac{\\mathrm{d}S}{\\mathrm{d}r}$ are continuous at $r = r_s$ and $r = r_c$. Then\n   $$U_{\\mathrm{S}}(r) = S(r) \\, U_{\\mathrm{LJ}}(r), \\quad \\mathbf{F}_{\\mathrm{S}}(r) = -\\nabla \\left( S(r) \\, U_{\\mathrm{LJ}}(r) \\right).$$\n   Because $U_{\\mathrm{S}}(r)$ is continuous with continuous derivative, exact dynamics conserves energy across $r_c$ without any finite jump in $U$.\n\nAssume the relative motion of two particles can be reduced to a one-dimensional radial coordinate $r(t)$ with relative velocity $v_{\\mathrm{rel}}$ near $r_c$ during a single timestep $\\Delta t$; assume reduced mass is absorbed into the reduced time unit $\\tau$. Consider the predicted displacement over one timestep $\\Delta t$ as $r_1 \\approx r_0 + v_{\\mathrm{rel}} \\, \\Delta t$. A crossing event occurs if either $r_0  r_c$ and $r_1 \\ge r_c$ (outward crossing) or $r_0  r_c$ and $r_1 \\le r_c$ (inward crossing). If no crossing occurs, the energy drift per event is zero for both models.\n\nYour task:\n- Derive, from the above base, an expression for the energy drift per crossing event, defined as $\\Delta E = E_{\\text{after}} - E_{\\text{before}}$, for both the truncated-unshifted and the switched potential models. You must explicitly show why the truncated case produces a finite drift tied to the jump in $U$ at $r_c$, and why the switched case does not.\n- Implement a program that, given $\\epsilon$, $\\sigma$, $r_c$, $r_s$, $r_0$, $v_{\\mathrm{rel}}$, and $\\Delta t$ in reduced Lennard-Jones units, detects whether a crossing occurs and computes the per-event energy drift $\\Delta E$ for both models in units of $\\epsilon$.\n- Use the following test suite. For each case, compute and return a pair $[\\Delta E_{\\mathrm{T}}, \\Delta E_{\\mathrm{S}}]$ in units of $\\epsilon$ as decimal floats:\n  1. Case A (happy path outward crossing): $\\epsilon = 1$, $\\sigma = 1$, $r_c = 2.5$, $r_s = 2.0$, $r_0 = 2.49$, $v_{\\mathrm{rel}} = 0.8$, $\\Delta t = 0.02$.\n  2. Case B (no crossing within the step): $\\epsilon = 1$, $\\sigma = 1$, $r_c = 2.5$, $r_s = 2.0$, $r_0 = 2.49$, $v_{\\mathrm{rel}} = 0.1$, $\\Delta t = 0.01$.\n  3. Case C (inward crossing): $\\epsilon = 1$, $\\sigma = 1$, $r_c = 2.5$, $r_s = 2.0$, $r_0 = 2.51$, $v_{\\mathrm{rel}} = -0.8$, $\\Delta t = 0.02$.\n  4. Case D (outward crossing at a larger cutoff): $\\epsilon = 1$, $\\sigma = 1$, $r_c = 3.0$, $r_s = 2.5$, $r_0 = 2.999$, $v_{\\mathrm{rel}} = 0.5$, $\\Delta t = 0.004$.\n  5. Case E (boundary-touching outward crossing): $\\epsilon = 1$, $\\sigma = 1$, $r_c = 2.5$, $r_s = 2.0$, $r_0 = 2.5 - 10^{-6}$, $v_{\\mathrm{rel}} = 1.0$, $\\Delta t = 10^{-6}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to a test case and is itself a list of the two energy drift values $[\\Delta E_{\\mathrm{T}}, \\Delta E_{\\mathrm{S}}]$ in units of $\\epsilon$. For example: $[[e_{1,T},e_{1,S}],[e_{2,T},e_{2,S}],\\dots]$.",
            "solution": "The problem requires the derivation and calculation of the energy drift per cutoff-crossing event in a molecular dynamics simulation step for a two-particle system interacting via two different potential models: a truncated Lennard-Jones potential and a switched Lennard-Jones potential. The analysis will be performed in reduced Lennard-Jones units, where the characteristic energy $\\epsilon = 1$, the characteristic length $\\sigma = 1$, and the particle mass $m = 1$. The total mechanical energy is given by $E = K + U$, where $K$ is the kinetic energy and $U$ is the potential energy. The energy drift per event is defined as $\\Delta E = E_{\\text{after}} - E_{\\text{before}}$.\n\nThe Lennard-Jones potential is given by:\n$$U_{\\mathrm{LJ}}(r) = 4 \\epsilon \\left[ \\left( \\frac{\\sigma}{r} \\right)^{12} - \\left( \\frac{\\sigma}{r} \\right)^6 \\right]$$\nIn reduced units ($\\epsilon=1, \\sigma=1$), this simplifies to:\n$$U_{\\mathrm{LJ}}(r) = 4 \\left( r^{-12} - r^{-6} \\right)$$\nA crossing event is defined as occurring within a single timestep $\\Delta t$, where the particle's radial position changes from $r_0$ to $r_1 = r_0 + v_{\\mathrm{rel}} \\Delta t$. An outward crossing occurs if $r_0  r_c$ and $r_1 \\ge r_c$. An inward crossing occurs if $r_0  r_c$ and $r_1 \\le r_c$.\n\n**Analysis of the Truncated-Unshifted Potential ($U_{\\mathrm{T}}$)**\n\nThe truncated-unshifted potential, $U_{\\mathrm{T}}(r)$, is defined as:\n$$U_{\\mathrm{T}}(r) = \\begin{cases}\nU_{\\mathrm{LJ}}(r),  r  r_c \\\\\n0,  r \\ge r_c\n\\end{cases}$$\nThis potential function has a jump discontinuity at the cutoff radius $r_c$. The value of the potential approaches $U_{\\mathrm{LJ}}(r_c)$ as $r$ approaches $r_c$ from below, but abruptly drops to $0$ at $r=r_c$.\n$$\\lim_{r \\to r_c^-} U_{\\mathrm{T}}(r) = U_{\\mathrm{LJ}}(r_c)$$\n$$\\lim_{r \\to r_c^+} U_{\\mathrm{T}}(r) = 0$$\nThe magnitude of this discontinuity is $|U_{\\mathrm{LJ}}(r_c)|$. The \"per-event energy drift\" described in the problem is the discrete change in total energy caused by this jump in potential energy. When a particle pair crosses the cutoff radius $r_c$, its kinetic energy $K$ can be considered continuous through the infinitesimal crossing point, but the potential energy $U$ changes instantaneously. The resulting change in total energy, $\\Delta E = \\Delta K + \\Delta U$, is therefore dominated by the jump in potential, so $\\Delta E = \\Delta U$.\n\n1.  **Outward Crossing ($r_0  r_c$ and $r_1 \\ge r_c$)**:\n    The system transitions from a state governed by the potential $U_{\\mathrm{LJ}}(r)$ to a state governed by a potential of $0$. At the moment of crossing $r_c$, the potential energy effectively changes from $U_{\\text{before}} = U_{\\mathrm{LJ}}(r_c)$ to $U_{\\text{after}} = 0$. The energy drift is:\n    $$\\Delta E_{\\mathrm{T}} = U_{\\text{after}} - U_{\\text{before}} = 0 - U_{\\mathrm{LJ}}(r_c) = -U_{\\mathrm{LJ}}(r_c)$$\n    Substituting the expression for $U_{\\mathrm{LJ}}(r_c)$ in reduced units:\n    $$\\Delta E_{\\mathrm{T}} = -4 \\left( r_c^{-12} - r_c^{-6} \\right)$$\n\n2.  **Inward Crossing ($r_0  r_c$ and $r_1 \\le r_c$)**:\n    The system transitions from the region of zero potential to the region where the potential is $U_{\\mathrm{LJ}}(r)$. At the moment of crossing $r_c$, the potential energy changes from $U_{\\text{before}} = 0$ to $U_{\\text{after}} = U_{\\mathrm{LJ}}(r_c)$. The energy drift is:\n    $$\\Delta E_{\\mathrm{T}} = U_{\\text{after}} - U_{\\text{before}} = U_{\\mathrm{LJ}}(r_c) - 0 = U_{\\mathrm{LJ}}(r_c)$$\n    In reduced units:\n    $$\\Delta E_{\\mathrm{T}} = 4 \\left( r_c^{-12} - r_c^{-6} \\right)$$\n\n3.  **No Crossing**:\n    If the particle pair does not cross the cutoff radius $r_c$ during the timestep, the potential energy function remains continuous for the particle's trajectory within that step. Therefore, there is no energy drift associated with a potential discontinuity.\n    $$\\Delta E_{\\mathrm{T}} = 0$$\n\n**Analysis of the Switched Potential ($U_{\\mathrm{S}}$)**\n\nThe switched potential is defined as $U_{\\mathrm{S}}(r) = S(r) U_{\\mathrm{LJ}}(r)$, where $S(r)$ is a quintic smoothstep switching function:\n$$x(r) = \\frac{r - r_s}{r_c - r_s}$$\n$$S(r) = \\begin{cases}\n1,  r \\le r_s \\\\\n1 - 10 x^3 + 15 x^4 - 6 x^5,  r_s  r  r_c \\\\\n0,  r \\ge r_c\n\\end{cases}$$\nThis switching function is constructed such that it and its first derivative are continuous and equal to $0$ at $r=r_c$. Specifically, $S(r_c) = 0$ and $\\frac{\\mathrm{d}S}{\\mathrm{d}r}|_{r_c} = 0$.\n\nLet's examine the behavior of $U_{\\mathrm{S}}(r)$ and its derivative (which is related to the force) at the cutoff radius $r_c$:\n-   **Continuity of the Potential**:\n    As $r \\to r_c^-$, the potential is $U_{\\mathrm{S}}(r) = S(r)U_{\\mathrm{LJ}}(r)$. The limit is:\n    $$\\lim_{r \\to r_c^-} U_{\\mathrm{S}}(r) = S(r_c) U_{\\mathrm{LJ}}(r_c) = 0 \\cdot U_{\\mathrm{LJ}}(r_c) = 0$$\n    For $r \\ge r_c$, the potential $U_{\\mathrm{S}}(r)$ is defined as $0$. Since both limits are equal, $U_{\\mathrm{S}}(r)$ is continuous at $r_c$. There is no jump in potential energy.\n\n-   **Continuity of the Force**:\n    The force is $F_{\\mathrm{S}}(r) = -\\frac{\\mathrm{d}U_{\\mathrm{S}}}{\\mathrm{d}r}$. Using the product rule for $r_s  r  r_c$:\n    $$\\frac{\\mathrm{d}U_{\\mathrm{S}}}{\\mathrm{d}r} = \\frac{\\mathrm{d}S}{\\mathrm{d}r} U_{\\mathrm{LJ}}(r) + S(r) \\frac{\\mathrm{d}U_{\\mathrm{LJ}}}{\\mathrm{d}r}$$\n    As $r \\to r_c^-$, the limit of the derivative is:\n    $$\\lim_{r \\to r_c^-} \\frac{\\mathrm{d}U_{\\mathrm{S}}}{\\mathrm{d}r} = \\left(\\frac{\\mathrm{d}S}{\\mathrm{d}r}\\bigg|_{r_c}\\right) U_{\\mathrm{LJ}}(r_c) + S(r_c) \\left(\\frac{\\mathrm{d}U_{\\mathrm{LJ}}}{\\mathrm{d}r}\\bigg|_{r_c}\\right) = (0) \\cdot U_{\\mathrm{LJ}}(r_c) + (0) \\cdot \\left(\\frac{\\mathrm{d}U_{\\mathrm{LJ}}}{\\mathrm{d}r}\\bigg|_{r_c}\\right) = 0$$\n    For $r \\ge r_c$, the derivative is also $0$. Thus, the derivative of the potential is continuous, which means the force is continuous (and zero) at $r_c$.\n\nBecause both the potential $U_{\\mathrm{S}}(r)$ and the force derived from it are continuous functions everywhere, the total mechanical energy is conserved under exact dynamics. There is no potential discontinuity at the cutoff to cause a discrete jump in energy. Consequently, the energy drift per crossing event, as defined by the abrupt jump mechanism, is zero for the switched potential model. Any energy drift in a real simulation using this potential would arise from the numerical integration algorithm's inaccuracies over the finite timestep $\\Delta t$, not from the definition of the potential itself.\n$$\\Delta E_{\\mathrm{S}} = 0$$\n\n**Algorithmic Summary**\n\nFor each test case with parameters $(\\epsilon, \\sigma, r_c, r_s, r_0, v_{\\mathrm{rel}}, \\Delta t)$, the energy drifts $\\Delta E_{\\mathrm{T}}$ and $\\Delta E_{\\mathrm{S}}$ are computed as follows:\n1.  Set reduced units $\\epsilon=1$ and $\\sigma=1$.\n2.  Calculate the final radial position: $r_1 = r_0 + v_{\\mathrm{rel}} \\Delta t$.\n3.  Check for a crossing event:\n    - If $r_0  r_c$ and $r_1 \\ge r_c$, an outward crossing occurs.\n    - If $r_0  r_c$ and $r_1 \\le r_c$, an inward crossing occurs.\n4.  Calculate $\\Delta E_{\\mathrm{T}}$:\n    - For outward crossing: $\\Delta E_{\\mathrm{T}} = -4(r_c^{-12} - r_c^{-6})$.\n    - For inward crossing: $\\Delta E_{\\mathrm{T}} = +4(r_c^{-12} - r_c^{-6})$.\n    - For no crossing: $\\Delta E_{\\mathrm{T}} = 0$.\n5.  Calculate $\\Delta E_{\\mathrm{S}}$:\n    - $\\Delta E_{\\mathrm{S}}$ is always $0$ based on the continuous nature of the potential.\nThe results are then collected and formatted.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the energy drift per cutoff-crossing event for truncated and\n    switched Lennard-Jones potentials.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (epsilon, sigma, r_c, r_s, r_0, v_rel, dt)\n    test_cases = [\n        # Case A (happy path outward crossing)\n        (1.0, 1.0, 2.5, 2.0, 2.49, 0.8, 0.02),\n        # Case B (no crossing within the step)\n        (1.0, 1.0, 2.5, 2.0, 2.49, 0.1, 0.01),\n        # Case C (inward crossing)\n        (1.0, 1.0, 2.5, 2.0, 2.51, -0.8, 0.02),\n        # Case D (outward crossing at a larger cutoff)\n        (1.0, 1.0, 3.0, 2.5, 2.999, 0.5, 0.004),\n        # Case E (boundary-touching outward crossing)\n        (1.0, 1.0, 2.5, 2.0, 2.5 - 1e-6, 1.0, 1e-6),\n    ]\n\n    results = []\n\n    def u_lj(r, epsilon=1.0, sigma=1.0):\n        \"\"\"Calculates the Lennard-Jones potential in reduced units.\"\"\"\n        # Using np.power for robust floating point exponentiation\n        s_over_r_6 = np.power(sigma / r, 6)\n        s_over_r_12 = np.power(s_over_r_6, 2)\n        return 4.0 * epsilon * (s_over_r_12 - s_over_r_6)\n\n    for case in test_cases:\n        epsilon, sigma, r_c, r_s, r_0, v_rel, dt = case\n\n        # Calculate final position based on simple displacement approximation\n        r_1 = r_0 + v_rel * dt\n\n        # Initialize energy drifts\n        delta_E_T = 0.0\n        delta_E_S = 0.0 # By definition, the switched potential is smooth\n\n        # Check for crossing event based on problem definition\n        is_outward_crossing = (r_0  r_c) and (r_1 = r_c)\n        is_inward_crossing = (r_0  r_c) and (r_1 = r_c)\n\n        if is_outward_crossing:\n            # Energy drift is the negative of the potential energy discontinuity\n            delta_E_T = -u_lj(r_c, epsilon, sigma)\n        elif is_inward_crossing:\n            # Energy drift is the positive of the potential energy discontinuity\n            delta_E_T = u_lj(r_c, epsilon, sigma)\n        # Otherwise, if no crossing, delta_E_T remains 0.\n\n        # The energy drift for the switched potential is 0 by design,\n        # as there is no discontinuity in the potential or force.\n        delta_E_S = 0.0\n        \n        # All output energies are in units of epsilon. Since epsilon=1, the\n        # calculated values are the final answer.\n        results.append([delta_E_T, delta_E_S])\n\n    # Final print statement in the exact required format.\n    # Use map(str, ...) to convert each sublist to a string, then join.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Many molecular models gain efficiency by treating molecules or parts of molecules as rigid bodies, which requires specialized constraint algorithms. These algorithms enforce fixed geometries by applying corrective impulses, a process that can interfere with energy conservation. In this advanced exercise, you will implement a velocity-level constraint stabilization scheme for a rigid water molecule and analyze the resulting change in kinetic energy . This practice explores the practical trade-off between maintaining precise geometric constraints and minimizing energy drift, a key skill in setting up and tuning robust biomolecular simulations.",
            "id": "3805782",
            "problem": "Consider a single rigid water molecule modeled by three point masses: one oxygen atom and two hydrogen atoms. The rigid geometry is enforced by holonomic constraints that keep all three pairwise distances fixed. The constraints are defined on the squared distances so that the constraint functions are differentiable and their time derivatives yield linear velocity conditions. Starting from Newton's second law, define a constraint stabilization step on the velocities that projects the current velocity vector onto the tangent space of the constraint manifold by applying mass-weighted corrective impulses. Compute the energy change due to this stabilization and propose numerical tolerance settings that minimize energy drift while still achieving acceptable constraint satisfaction.\n\nFundamental base. Begin from Newton's second law, $m_i \\,\\mathbf{a}_i = \\mathbf{F}_i$, and the definition of kinetic energy $T = \\frac{1}{2}\\sum_{i} m_i \\|\\mathbf{v}_i\\|^2$. For a holonomic constraint $g_k(\\mathbf{r}) = 0$, the velocity-level constraint is $\\dot{g}_k(\\mathbf{r},\\mathbf{v}) = \\nabla g_k(\\mathbf{r}) \\cdot \\mathbf{v} = 0$. The mass-weighted projection to enforce $\\dot{g}_k=0$ proceeds by adding velocity impulses $\\Delta \\mathbf{v}_i$ that are linear combinations of the constraint gradients scaled by Lagrange multipliers. In a sequential stabilization (Gauss–Seidel) sweep, each constraint is corrected in turn, which can induce small violations in other constraints, so multiple sweeps are used until a stopping criterion is met.\n\nModel and units. Use fixed rigid geometry intended for a typical water model:\n- Oxygen mass $m_O = 15.999\\ \\mathrm{amu}$, hydrogen mass $m_H = 1.008\\ \\mathrm{amu}$, with $1\\ \\mathrm{amu} = 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$. Express all masses in $\\mathrm{kg}$.\n- Oxygen–hydrogen bond length $r_{OH} = 9.572\\times 10^{-11}\\ \\mathrm{m}$.\n- Hydrogen–oxygen–hydrogen angle $\\theta = 104.52^\\circ$ (angle unit is degrees).\n- Place the oxygen atom at the origin $\\mathbf{r}_O = (0,0,0)$; place the first hydrogen at $\\mathbf{r}_{H1} = (r_{OH}, 0, 0)$; place the second hydrogen at $\\mathbf{r}_{H2} = (r_{OH}\\cos\\theta, r_{OH}\\sin\\theta, 0)$.\n- Enforce three distance constraints using squared-distance functions\n$$\ng_1(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_{O}-\\mathbf{r}_{H1}\\|^2 - r_{OH}^2\\right),\\quad\ng_2(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_{O}-\\mathbf{r}_{H2}\\|^2 - r_{OH}^2\\right),\\quad\ng_3(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_{H1}-\\mathbf{r}_{H2}\\|^2 - r_{HH}^2\\right),\n$$\nwhere $r_{HH} = 2\\,r_{OH}\\,\\sin(\\theta/2)$ ensures geometric consistency. The corresponding velocity constraints are\n$$\n\\dot{g}_k(\\mathbf{r},\\mathbf{v}) = \\mathbf{r}_{pq}\\cdot(\\mathbf{v}_p - \\mathbf{v}_q) = 0,\n$$\nwhere $\\mathbf{r}_{pq} = \\mathbf{r}_p - \\mathbf{r}_q$ for the atom pair of constraint $k$.\n\nConstraint stabilization step. In one Gauss–Seidel iteration over constraints, for each constraint $k$ connecting atoms $p$ and $q$, compute the scalar residual\n$$\ns_k = \\mathbf{r}_{pq}\\cdot(\\mathbf{v}_p - \\mathbf{v}_q),\n$$\nand apply the minimal mass-weighted correction that would make $s_k = 0$ for that constraint alone:\n$$\n\\lambda_k = -\\frac{s_k}{\\alpha_{pq}},\\quad \\alpha_{pq} = \\|\\mathbf{r}_{pq}\\|^2\\left(\\frac{1}{m_p} + \\frac{1}{m_q}\\right),\n$$\n$$\n\\mathbf{v}_p \\leftarrow \\mathbf{v}_p + \\frac{\\lambda_k}{m_p}\\,\\mathbf{r}_{pq},\\quad\n\\mathbf{v}_q \\leftarrow \\mathbf{v}_q - \\frac{\\lambda_k}{m_q}\\,\\mathbf{r}_{pq}.\n$$\nIterate sweeps until all constraints satisfy a normalized residual threshold. Let the instantaneous mass-weighted root-mean-square speed be\n$$\nv_{\\mathrm{rms}} = \\sqrt{\\frac{\\sum_i m_i \\|\\mathbf{v}_i\\|^2}{\\sum_i m_i}},\n$$\nand define for each constraint the dimensionless normalized residual\n$$\n\\rho_k = \\frac{|s_k|}{\\|\\mathbf{r}_{pq}\\|\\, v_{\\mathrm{rms}}}.\n$$\nTerminate the iteration when $\\max_k \\rho_k \\le \\mathrm{rtol}$, where $\\mathrm{rtol}$ is a relative tolerance parameter.\n\nEnergy change due to stabilization. The kinetic energy before and after stabilization are\n$$\nT_{\\mathrm{before}} = \\tfrac{1}{2}\\sum_i m_i \\|\\mathbf{v}_i^{\\mathrm{(before)}}\\|^2,\\quad\nT_{\\mathrm{after}} = \\tfrac{1}{2}\\sum_i m_i \\|\\mathbf{v}_i^{\\mathrm{(after)}}\\|^2.\n$$\nThe energy change is\n$$\n\\Delta T = T_{\\mathrm{after}} - T_{\\mathrm{before}},\n$$\nwhich should be expressed in Joules (J).\n\nTolerance proposal objective. Given a target normalized residual bound $\\rho^\\ast = 10^{-6}$, propose a tolerance $\\mathrm{rtol}$ from a candidate set that minimizes $|\\Delta T|$ while ensuring $\\max_k \\rho_k \\le \\rho^\\ast$. If no candidate achieves the target, choose among candidates the one with smallest $\\max_k \\rho_k$, breaking ties by smallest $|\\Delta T|$, and if still tied, by the largest $\\mathrm{rtol}$.\n\nTest suite. Use three test cases with distinct initial velocities (in $\\mathrm{m/s}$):\n- Case A (thermal-like): $\\mathbf{v}_O = (300,-200,100)$, $\\mathbf{v}_{H1} = (1500,2000,-1000)$, $\\mathbf{v}_{H2} = (-1200,800,600)$.\n- Case B (near-rigid rotation): define angular velocity $\\boldsymbol{\\omega} = (0,5\\times 10^{11},0)\\ \\mathrm{s}^{-1}$, compute the center of mass position $\\mathbf{r}_{\\mathrm{COM}}$, and set $\\mathbf{v}_i = \\boldsymbol{\\omega} \\times (\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{COM}})$ for $i \\in \\{O,H1,H2\\}$.\n- Case C (edge violation): $\\mathbf{v}_O = (0,0,0)$, $\\mathbf{v}_{H1} = (20000,0,0)$, $\\mathbf{v}_{H2} = (0,0,0)$.\n\nCandidate tolerances and iteration cap. Use candidate tolerances $\\mathrm{rtol} \\in \\{10^{-2},10^{-4},10^{-6},10^{-8},10^{-10}\\}$ and a maximum of $N_{\\max} = 200$ Gauss–Seidel sweeps per stabilization.\n\nRequired output. For each test case, determine the recommended tolerance $\\mathrm{rtol}_{\\mathrm{rec}}$ according to the objective above, and compute the corresponding energy change $\\Delta T$ after stabilization. Express each $\\Delta T$ in $\\mathrm{J}$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a two-item list $[\\mathrm{rtol}_{\\mathrm{rec}}, \\Delta T]$ for one test case. For example, the format is $[[\\mathrm{rtol}_A,\\Delta T_A],[\\mathrm{rtol}_B,\\Delta T_B],[\\mathrm{rtol}_C,\\Delta T_C]]$ with numeric values.",
            "solution": "The problem requires an analysis of energy conservation for a velocity-level constraint stabilization algorithm applied to a rigid water molecule. The solution involves implementing the specified Gauss-Seidel iterative procedure for several initial velocity configurations and selecting an optimal numerical tolerance based on a multi-part objective function.\n\n### System and Geometry Definition\nThe system consists of three point masses: one oxygen atom ($O$, index $0$) and two hydrogen atoms ($H1$, index $1$; $H2$, index $2$). Their masses are $m_O = 15.999 \\times 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$ and $m_{H1} = m_{H2} = m_H = 1.008 \\times 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$.\n\nThe geometry is fixed in a plane. With the oxygen atom at the origin $\\mathbf{r}_0 = (0,0,0)$, the hydrogen positions are defined by the O-H bond length $r_{OH} = 9.572\\times 10^{-11}\\ \\mathrm{m}$ and the H-O-H angle $\\theta = 104.52^\\circ$.\nLet $\\theta_{rad}$ be the angle in radians. The positions are:\n- $\\mathbf{r}_0 = (0, 0, 0)$\n- $\\mathbf{r}_1 = (r_{OH}, 0, 0)$\n- $\\mathbf{r}_2 = (r_{OH}\\cos\\theta_{rad}, r_{OH}\\sin\\theta_{rad}, 0)$\n\n### Holonomic Constraints\nThe rigidity of the molecule is enforced by three holonomic constraints on the squared interatomic distances:\n$g_1(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_0 - \\mathbf{r}_1\\|^2 - r_{OH}^2\\right) = 0$\n$g_2(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_0 - \\mathbf{r}_2\\|^2 - r_{OH}^2\\right) = 0$\n$g_3(\\mathbf{r}) = \\tfrac{1}{2}\\left(\\|\\mathbf{r}_1 - \\mathbf{r}_2\\|^2 - r_{HH}^2\\right) = 0$\nThe H-H distance $r_{HH}$ is determined by the geometry: $r_{HH} = 2 r_{OH} \\sin(\\theta/2)$. This ensures the constraints are consistent.\n\nFor the motion to be physically valid for a rigid body, the time derivative of each constraint function must be zero. This leads to velocity-level constraints. For a generic constraint $k$ between atoms $p$ and $q$, we have:\n$\\dot{g}_k(\\mathbf{r}, \\mathbf{v}) = \\frac{\\partial g_k}{\\partial \\mathbf{r}} \\cdot \\mathbf{v} = (\\mathbf{r}_p - \\mathbf{r}_q) \\cdot (\\mathbf{v}_p - \\mathbf{v}_q) = 0$\nLet $\\mathbf{r}_{pq} = \\mathbf{r}_p - \\mathbf{r}_q$. The condition is $\\mathbf{r}_{pq} \\cdot (\\mathbf{v}_p - \\mathbf{v}_q) = 0$. This means the relative velocity of the two atoms must be orthogonal to their separation vector.\n\n### Velocity Stabilization Algorithm\nNumerical integration schemes can introduce small errors, causing the velocities to drift off the constraint manifold, i.e., $\\mathbf{r}_{pq} \\cdot (\\mathbf{v}_p - \\mathbf{v}_q) \\neq 0$. The stabilization algorithm projects the velocities back onto this manifold. The prescribed method is a Gauss-Seidel iterative procedure. In each sweep, we sequentially correct for each of the three constraints.\n\nFor a single constraint $k$ between atoms $p$ and $q$, the violation is measured by the residual $s_k = \\mathbf{r}_{pq} \\cdot (\\mathbf{v}_p - \\mathbf{v}_q)$. The goal is to find velocity corrections $\\Delta\\mathbf{v}_p$ and $\\Delta\\mathbf{v}_q$ that nullify this residual. The method provides a solution that corresponds to applying corrective impulses along the direction of the separation vector $\\mathbf{r}_{pq}$. This direction is parallel to the gradient of the constraint function, $\\nabla_{\\mathbf{r}_p} g_k = \\mathbf{r}_{pq}$. The changes are:\n$\\Delta \\mathbf{v}_p = \\frac{\\lambda_k}{m_p} \\mathbf{r}_{pq}$\n$\\Delta \\mathbf{v}_q = -\\frac{\\lambda_k}{m_q} \\mathbf{r}_{pq}$\nThe scalar $\\lambda_k$ is a Lagrange multiplier determined by requiring the new velocities $\\mathbf{v}'_p = \\mathbf{v}_p + \\Delta\\mathbf{v}_p$ and $\\mathbf{v}'_q = \\mathbf{v}_q + \\Delta\\mathbf{v}_q$ to satisfy the constraint:\n$\\mathbf{r}_{pq} \\cdot (\\mathbf{v}'_p - \\mathbf{v}'_q) = 0 \\implies \\mathbf{r}_{pq} \\cdot (\\mathbf{v}_p - \\mathbf{v}_q) + \\lambda_k \\|\\mathbf{r}_{pq}\\|^2 \\left( \\frac{1}{m_p} + \\frac{1}{m_q} \\right) = 0$\nSolving for $\\lambda_k$ gives:\n$\\lambda_k = - \\frac{s_k}{\\alpha_{pq}}$, where $\\alpha_{pq} = \\|\\mathbf{r}_{pq}\\|^2 \\left(\\frac{1}{m_p} + \\frac{1}{m_q}\\right)$.\nThe velocities are updated sequentially for each of the three constraints. Because correcting one constraint can introduce a small violation in others, the process is repeated in sweeps until all constraints are satisfied to a desired tolerance.\n\n### Convergence and Tolerance\nThe iteration continues until the maximum normalized residual $\\max_k \\rho_k$ falls below a specified tolerance $\\mathrm{rtol}$. The normalized residual $\\rho_k = \\frac{|s_k|}{\\|\\mathbf{r}_{pq}\\| v_{\\mathrm{rms}}}$ compares the speed of constraint violation to the system's overall root-mean-square speed $v_{\\mathrm{rms}} = \\sqrt{2T/M_{tot}}$, where $T$ is the total kinetic energy and $M_{tot}$ is the total mass. Iterations stop if convergence is reached or after a maximum of $N_{max}=200$ sweeps.\n\n### Energy Change and Tolerance Selection\nThe kinetic energy before stabilization is $T_{\\mathrm{before}} = \\frac{1}{2}\\sum_i m_i \\|\\mathbf{v}_i^{\\mathrm{(before)}}\\|^2$. After stabilization, the final kinetic energy is $T_{\\mathrm{after}} = \\frac{1}{2}\\sum_i m_i \\|\\mathbf{v}_i^{\\mathrm{(after)}}\\|^2$. The change is $\\Delta T = T_{\\mathrm{after}} - T_{\\mathrm{before}}$. While each individual correction step is designed to be minimal in a mass-weighted sense, the sequential nature of the Gauss-Seidel scheme generally leads to a non-zero $\\Delta T$.\n\nThe objective is to select the best tolerance `rtol` from the set $\\{10^{-2},10^{-4},10^{-6},10^{-8},10^{-10}\\}$ for each test case.\n1. Primary Goal: Satisfy the strict constraint requirement $\\max_k \\rho_k \\le \\rho^\\ast=10^{-6}$. Among tolerances that achieve this, select the one that results in the minimum absolute energy change $|\\Delta T|$.\n2. Fallback: If no tolerance meets the primary goal, select the one that produces the smallest $\\max_k \\rho_k$. Ties are broken by choosing the smallest $|\\Delta T|$, and then by choosing the largest `rtol`.\n\nThe computational procedure is to run the stabilization for each test case with each candidate `rtol`, record the final $\\max_k \\rho_k$ and $\\Delta T$, and then apply the selection logic to find the recommended tolerance and corresponding energy change.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the rigid water molecule constraint stabilization problem.\n    \"\"\"\n    #\n    # Step 1: Define Constants and System Geometry\n    #\n    AMU_TO_KG = 1.66053906660e-27\n    M_O_AMU = 15.999\n    M_H_AMU = 1.008\n    R_OH = 9.572e-11  # meters\n    THETA_DEG = 104.52  # degrees\n\n    m_o = M_O_AMU * AMU_TO_KG\n    m_h = M_H_AMU * AMU_TO_KG\n    masses = np.array([m_o, m_h, m_h])\n    \n    theta_rad = np.deg2rad(THETA_DEG)\n    r_h1 = np.array([R_OH, 0.0, 0.0])\n    r_h2 = np.array([R_OH * np.cos(theta_rad), R_OH * np.sin(theta_rad), 0.0])\n    r_o = np.array([0.0, 0.0, 0.0])\n    \n    positions = np.array([r_o, r_h1, r_h2])\n    \n    # Store constraint definitions: atom pairs (p, q) and reference squared distance\n    r_hh_sq = (2 * R_OH * np.sin(theta_rad / 2))**2\n    constraint_defs = [\n        (0, 1, R_OH**2),\n        (0, 2, R_OH**2),\n        (1, 2, r_hh_sq)\n    ]\n\n    r_pqs = [positions[p] - positions[q] for p, q, _ in constraint_defs]\n    r_pq_norms = [np.linalg.norm(rpq) for rpq in r_pqs]\n    \n    # Precompute alpha denominators for lambda calculation\n    alphas = []\n    for (p, q, _), rpq in zip(constraint_defs, r_pqs):\n        alpha = np.dot(rpq, rpq) * (1.0 / masses[p] + 1.0 / masses[q])\n        alphas.append(alpha)\n\n    #\n    # Step 2: Define Stabilization and Helper Functions\n    #\n    def calculate_ke(m, v):\n        \"\"\"Calculates total kinetic energy.\"\"\"\n        ke = 0.0\n        for i in range(len(m)):\n            ke += 0.5 * m[i] * np.dot(v[i], v[i])\n        return ke\n\n    def stabilize(v_init, rtol, max_sweeps):\n        \"\"\"Performs Gauss-Seidel velocity stabilization.\"\"\"\n        v = v_init.copy()\n        \n        for _ in range(max_sweeps):\n            for i, (p, q, _) in enumerate(constraint_defs):\n                s_k = np.dot(r_pqs[i], v[p] - v[q])\n                lambda_k = -s_k / alphas[i]\n                \n                v[p] += (lambda_k / masses[p]) * r_pqs[i]\n                v[q] -= (lambda_k / masses[q]) * r_pqs[i]\n                \n            # Convergence check after a full sweep\n            total_mass = np.sum(masses)\n            total_ke = calculate_ke(masses, v)\n            if total_ke == 0:\n                # If all velocities are zero, residuals are zero\n                max_rho = 0.0\n            else:\n                v_rms = np.sqrt(2 * total_ke / total_mass)\n                max_rho = 0.0\n                for i, (p, q, _) in enumerate(constraint_defs):\n                    s_k = np.dot(r_pqs[i], v[p] - v[q])\n                    rho_k = abs(s_k) / (r_pq_norms[i] * v_rms)\n                    if rho_k > max_rho:\n                        max_rho = rho_k\n            \n            if max_rho = rtol:\n                return v, max_rho\n        \n        # If max_sweeps is reached, calculate and return final residual\n        total_mass = np.sum(masses)\n        total_ke = calculate_ke(masses, v)\n        if total_ke == 0:\n            max_rho = 0.0\n        else:\n            v_rms = np.sqrt(2 * total_ke / total_mass)\n            max_rho = 0.0\n            for i, (p, q, _) in enumerate(constraint_defs):\n                s_k = np.dot(r_pqs[i], v[p] - v[q])\n                rho_k = abs(s_k) / (r_pq_norms[i] * v_rms)\n                if rho_k > max_rho:\n                    max_rho = rho_k\n                    \n        return v, max_rho\n\n    #\n    # Step 3: Define Test Cases\n    #\n    # Case A\n    v_a = np.array([\n        [300.0, -200.0, 100.0],\n        [1500.0, 2000.0, -1000.0],\n        [-1200.0, 800.0, 600.0]\n    ])\n\n    # Case B\n    omega_b = np.array([0.0, 5.0e11, 0.0])\n    total_mass_b = np.sum(masses)\n    r_com_b = (masses[0] * positions[0] + masses[1] * positions[1] + masses[2] * positions[2]) / total_mass_b\n    v_b = np.array([\n        np.cross(omega_b, positions[0] - r_com_b),\n        np.cross(omega_b, positions[1] - r_com_b),\n        np.cross(omega_b, positions[2] - r_com_b)\n    ])\n    \n    # Case C\n    v_c = np.array([\n        [0.0, 0.0, 0.0],\n        [20000.0, 0.0, 0.0],\n        [0.0, 0.0, 0.0]\n    ])\n    \n    test_cases = [v_a, v_b, v_c]\n    \n    #\n    # Step 4: Run Simulations and Apply Selection Logic\n    #\n    candidate_rtols = [1e-2, 1e-4, 1e-6, 1e-8, 1e-10]\n    rho_target = 1e-6\n    max_sweeps = 200\n    \n    final_results = []\n    \n    for v_initial in test_cases:\n        t_before = calculate_ke(masses, v_initial)\n        \n        results_per_case = []\n        for rtol in candidate_rtols:\n            v_final, max_rho_final = stabilize(v_initial, rtol, max_sweeps)\n            t_after = calculate_ke(masses, v_final)\n            delta_t = t_after - t_before\n            \n            results_per_case.append({\n                'rtol': rtol,\n                'max_rho': max_rho_final,\n                'delta_T': delta_t\n            })\n\n        # Apply selection logic\n        achieved_target = [res for res in results_per_case if res['max_rho'] = rho_target]\n        \n        if achieved_target:\n            # Minimize |delta_T| among those meeting the target\n            best_res = min(achieved_target, key=lambda x: abs(x['delta_T']))\n        else:\n            # Minimize max_rho, then |delta_T|, then maximize rtol\n            # Note: min on -rtol maximizes rtol\n            best_res = min(results_per_case, key=lambda x: (x['max_rho'], abs(x['delta_T']), -x['rtol']))\n\n        final_results.append([best_res['rtol'], best_res['delta_T']])\n\n    #\n    # Step 5: Format and Print Final Output\n    #\n    output_str = f\"[{','.join(map(str, final_results))}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}