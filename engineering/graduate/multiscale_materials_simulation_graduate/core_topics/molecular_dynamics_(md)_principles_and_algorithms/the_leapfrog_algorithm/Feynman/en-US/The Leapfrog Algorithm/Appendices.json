{
    "hands_on_practices": [
        {
            "introduction": "The first step in applying any numerical integration scheme is to understand the constraints on the time step $\\Delta t$ required for a stable simulation. For oscillatory systems, which are ubiquitous in materials modeling, an excessively large time step can lead to an unphysical, exponential growth in energy and amplitude. This practice guides you through a linear stability analysis of the leapfrog algorithm applied to a simple harmonic oscillator, which serves as a fundamental model for atomic vibrations. By deriving the amplification matrix and its eigenvalues, you will uncover the famous stability condition that is a cornerstone of setting up stable molecular dynamics simulations .",
            "id": "3847513",
            "problem": "In multiscale materials simulation, the time integration of lattice vibrations is often performed with the leapfrog algorithm in Molecular Dynamics (MD). Consider a single coarse-grained harmonic mode governed by Newton’s second law for a linear spring-mass system, $$m\\,\\ddot{x}(t) + k\\,x(t) = 0,$$ where $m$ is the mass and $k$ is the effective spring constant. The leapfrog algorithm advances the position $x^{n}$ at integer times $t^{n} = n\\,\\Delta t$ and the velocity $v^{n+1/2}$ at half-integer times $t^{n+1/2} = \\left(n+\\frac{1}{2}\\right)\\Delta t$, using the discrete acceleration evaluated at integer times.\n\nStarting from Newton’s second law and the definition of the leapfrog updates, derive the one-step linear mapping of the state vector $$\\begin{pmatrix} x^{n} \\\\ v^{n-1/2} \\end{pmatrix} \\mapsto \\begin{pmatrix} x^{n+1} \\\\ v^{n+1/2} \\end{pmatrix}$$ and obtain the corresponding amplification factor(s) as the eigenvalues of this mapping. Based on first principles of linear stability for constant-coefficient discrete dynamical systems, deduce the condition on the time step $\\Delta t$ that ensures bounded discrete trajectories for this oscillator as a function of $$\\omega \\equiv \\sqrt{\\frac{k}{m}}.$$\n\nFinally, for a representative coarse-grained site with mass $$m = 4.6636 \\times 10^{-26}\\,\\text{kg}$$ and spring constant $$k = 64\\,\\text{N/m},$$ compute the maximum linearly stable leapfrog time step $$\\Delta t_{\\max}$$ and express it in femtoseconds. Round your answer to $4$ significant figures and report the numerical value of $\\Delta t_{\\max}$ in femtoseconds (fs).",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- Equation of motion: $$m\\,\\ddot{x}(t) + k\\,x(t) = 0$$, where $$m$$ is mass and $$k$$ is the spring constant.\n- Leapfrog algorithm updates: The position $$x^{n}$$ is evaluated at integer times $$t^{n} = n\\,\\Delta t$$. The velocity $$v^{n+1/2}$$ is evaluated at half-integer times $$t^{n+1/2} = \\left(n+\\frac{1}{2}\\right)\\Delta t$$.\n- Task 1: Derive the one-step linear mapping from the state vector $$\\begin{pmatrix} x^{n} \\\\ v^{n-1/2} \\end{pmatrix}$$ to $$\\begin{pmatrix} x^{n+1} \\\\ v^{n+1/2} \\end{pmatrix}$$.\n- Task 2: Obtain the amplification factors (eigenvalues) of this mapping.\n- Task 3: Deduce the stability condition for $$\\Delta t$$ as a function of $$\\omega \\equiv \\sqrt{\\frac{k}{m}}$$.\n- Task 4: For $$m = 4.6636 \\times 10^{-26}\\,\\text{kg}$$ and $$k = 64\\,\\text{N/m}$$, compute the maximum linearly stable time step $$\\Delta t_{\\max}$$ in femtoseconds, rounded to $$4$$ significant figures.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem describes the linear stability analysis of the leapfrog (or Störmer-Verlet) method applied to a simple harmonic oscillator. This is a canonical problem in numerical analysis and computational physics, particularly relevant to molecular dynamics simulations. The model and method are well-established.\n- **Well-Posed**: The problem is clearly specified. It asks for a derivation of a transfer matrix, its eigenvalues, the resulting stability condition, and a final numerical calculation. All necessary definitions and data are provided, and a unique, meaningful solution exists.\n- **Objective**: The problem is stated using precise, standard scientific terminology. It is free from ambiguity and subjectivity.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\nThe governing equation for the harmonic oscillator is given by Newton's second law:\n$$m\\,\\ddot{x}(t) + k\\,x(t) = 0$$\nThis can be rewritten in terms of the angular frequency $$\\omega = \\sqrt{k/m}$$ as:\n$$\\ddot{x}(t) = -\\omega^2 x(t)$$\nThe acceleration at any time $$t$$ is $$a(t) = \\ddot{x}(t) = -\\omega^2 x(t)$$.\n\nThe leapfrog algorithm uses a staggered time grid. The updates are defined as follows:\n$1$. The velocity is updated from time $$t^{n-1/2}$$ to $$t^{n+1/2}$$ using the acceleration evaluated at the integer time step $$t^n$$.\n$$v^{n+1/2} = v^{n-1/2} + a(t^n)\\,\\Delta t = v^{n-1/2} + a(x^n)\\,\\Delta t$$\n$2$. The position is updated from time $$t^n$$ to $$t^{n+1}$$ using the newly computed velocity at the half-integer time step $$t^{n+1/2}$$.\n$$x^{n+1} = x^n + v^{n+1/2}\\,\\Delta t$$\n\nWe are tasked with finding the linear mapping that transforms the state vector $$\\begin{pmatrix} x^n \\\\ v^{n-1/2} \\end{pmatrix}$$ into $$\\begin{pmatrix} x^{n+1} \\\\ v^{n+1/2} \\end{pmatrix}$$. To do this, we substitute the expression for acceleration, $$a(x^n) = -\\omega^2 x^n$$, into the velocity update equation:\n$$v^{n+1/2} = v^{n-1/2} - (\\omega^2 x^n)\\,\\Delta t$$\nThis equation can be rewritten as:\n$$v^{n+1/2} = -\\omega^2 \\Delta t\\,x^n + v^{n-1/2}$$\n\nNext, we substitute this new expression for $$v^{n+1/2}$$ into the position update equation:\n$$x^{n+1} = x^n + (v^{n-1/2} - \\omega^2 \\Delta t\\,x^n)\\,\\Delta t$$\n$$x^{n+1} = x^n + v^{n-1/2}\\,\\Delta t - \\omega^2 (\\Delta t)^2 x^n$$\nRearranging the terms to group $$x^n$$ and $$v^{n-1/2}$$:\n$$x^{n+1} = (1 - \\omega^2 (\\Delta t)^2)\\,x^n + \\Delta t\\,v^{n-1/2}$$\n\nWe now have a system of two linear equations relating the state at step $$n+1$$ to the state at step $$n$$:\n$$x^{n+1} = (1 - \\omega^2 (\\Delta t)^2)\\,x^n + \\Delta t\\,v^{n-1/2}$$\n$$v^{n+1/2} = -\\omega^2 \\Delta t\\,x^n + 1 \\cdot v^{n-1/2}$$\n\nThis system can be written in matrix form, which represents the one-step linear mapping:\n$$\\begin{pmatrix} x^{n+1} \\\\ v^{n+1/2} \\end{pmatrix} = \\begin{pmatrix} 1 - \\omega^2 (\\Delta t)^2 & \\Delta t \\\\ -\\omega^2 \\Delta t & 1 \\end{pmatrix} \\begin{pmatrix} x^n \\\\ v^{n-1/2} \\end{pmatrix}$$\nThe matrix in this equation is the transfer matrix, often called the amplification matrix, $$\\mathbf{A}$$.\n$$\\mathbf{A} = \\begin{pmatrix} 1 - \\omega^2 (\\Delta t)^2 & \\Delta t \\\\ -\\omega^2 \\Delta t & 1 \\end{pmatrix}$$\n\nThe amplification factors are the eigenvalues, $$\\lambda$$, of the matrix $$\\mathbf{A}$$. They are found by solving the characteristic equation $$\\det(\\mathbf{A} - \\lambda \\mathbf{I}) = 0$$, where $$\\mathbf{I}$$ is the identity matrix.\n$$\\det \\begin{pmatrix} 1 - \\omega^2 (\\Delta t)^2 - \\lambda & \\Delta t \\\\ -\\omega^2 \\Delta t & 1 - \\lambda \\end{pmatrix} = 0$$\n$$(1 - \\omega^2 (\\Delta t)^2 - \\lambda)(1 - \\lambda) - (\\Delta t)(-\\omega^2 \\Delta t) = 0$$\n$$1 - \\lambda - \\omega^2 (\\Delta t)^2 + \\lambda \\omega^2 (\\Delta t)^2 - \\lambda + \\lambda^2 + \\omega^2 (\\Delta t)^2 = 0$$\n$$\\lambda^2 + (\\omega^2 (\\Delta t)^2 - 2)\\lambda + 1 = 0$$\n\nWe solve this quadratic equation for $$\\lambda$$ using the quadratic formula, $$\\lambda = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$, with $$a=1$$, $$b = \\omega^2 (\\Delta t)^2 - 2$$, and $$c=1$$.\n$$\\lambda = \\frac{-( \\omega^2 (\\Delta t)^2 - 2) \\pm \\sqrt{(\\omega^2 (\\Delta t)^2 - 2)^2 - 4}}{2}$$\n$$\\lambda = \\frac{2 - (\\omega \\Delta t)^2 \\pm \\sqrt{(\\omega \\Delta t)^4 - 4(\\omega \\Delta t)^2 + 4 - 4}}{2}$$\n$$\\lambda = \\frac{2 - (\\omega \\Delta t)^2 \\pm \\sqrt{(\\omega \\Delta t)^2 ((\\omega \\Delta t)^2 - 4)}}{2}$$\n$$\\lambda = 1 - \\frac{(\\omega \\Delta t)^2}{2} \\pm \\frac{\\omega \\Delta t}{2}\\sqrt{(\\omega \\Delta t)^2 - 4}$$\n\nFor a discrete dynamical system to have bounded solutions, it must be stable. Linear stability requires that the magnitude of all eigenvalues (the spectral radius of $$\\mathbf{A}$$) must not exceed $$1$$. That is, $$|\\lambda| \\le 1$$. We analyze this condition by examining the term under the square root, $$(\\omega \\Delta t)^2 - 4$$.\n\nCase 1: $$(\\omega \\Delta t)^2 > 4$$, or $$|\\omega \\Delta t| > 2$$.\nThe eigenvalues are real. The product of the two eigenvalues is $$\\lambda_1 \\lambda_2 = c/a = 1$$. If the eigenvalues are real and not equal to $$\\pm 1$$, one must have magnitude greater than $$1$$ and the other less than $$1$$. This corresponds to an unstable mode that grows exponentially. The system is unstable.\n\nCase 2: $$(\\omega \\Delta t)^2 = 4$$, or $$|\\omega \\Delta t| = 2$$.\nThe term under the square root is zero, yielding a degenerate eigenvalue $$\\lambda = 1 - \\frac{4}{2} = -1$$. Since $$|\\lambda| = 1$$, this is the limit of stability (marginal stability).\n\nCase 3: $$(\\omega \\Delta t)^2 < 4$$, or $$|\\omega \\Delta t| < 2$$.\nThe term under the square root is negative. The eigenvalues are a complex conjugate pair.\n$$\\lambda = 1 - \\frac{(\\omega \\Delta t)^2}{2} \\pm i \\frac{\\omega \\Delta t}{2}\\sqrt{4 - (\\omega \\Delta t)^2}$$\nThe magnitude squared of these eigenvalues is:\n$$|\\lambda|^2 = \\left(1 - \\frac{(\\omega \\Delta t)^2}{2}\\right)^2 + \\left(\\frac{\\omega \\Delta t}{2}\\sqrt{4 - (\\omega \\Delta t)^2}\\right)^2$$\n$$|\\lambda|^2 = 1 - (\\omega \\Delta t)^2 + \\frac{(\\omega \\Delta t)^4}{4} + \\frac{(\\omega \\Delta t)^2}{4}(4 - (\\omega \\Delta t)^2)$$\n$$|\\lambda|^2 = 1 - (\\omega \\Delta t)^2 + \\frac{(\\omega \\Delta t)^4}{4} + (\\omega \\Delta t)^2 - \\frac{(\\omega \\Delta t)^4}{4}$$\n$$|\\lambda|^2 = 1$$\nThus, $$|\\lambda| = 1$$. In this regime, the eigenvalues lie on the unit circle in the complex plane. The discrete evolution preserves the norm of the state vector in a certain sense, leading to bounded, oscillatory solutions. The system is stable.\n\nCombining these cases, the condition for linear stability (bounded trajectories) is $$|\\omega \\Delta t| \\le 2$$. Since $$\\omega > 0$$ and $$\\Delta t > 0$$, this simplifies to:\n$$\\omega \\Delta t \\le 2$$\n$$\\Delta t \\le \\frac{2}{\\omega}$$\n\nThe maximum linearly stable time step is therefore $$\\Delta t_{\\max} = \\frac{2}{\\omega}$$.\n\nFinally, we compute the numerical value for $$\\Delta t_{\\max}$$ given the parameters $$m = 4.6636 \\times 10^{-26}\\,\\text{kg}$$ and $$k = 64\\,\\text{N/m}$$. First, we calculate $$\\omega$$:\n$$\\omega = \\sqrt{\\frac{k}{m}} = \\sqrt{\\frac{64\\,\\text{N/m}}{4.6636 \\times 10^{-26}\\,\\text{kg}}}$$\n$$\\omega \\approx \\sqrt{1.37229134 \\times 10^{27}\\,\\text{s}^{-2}} \\approx 3.7044448 \\times 10^{13}\\,\\text{rad/s}$$\n\nNow we can compute $$\\Delta t_{\\max}$$:\n$$\\Delta t_{\\max} = \\frac{2}{\\omega} \\approx \\frac{2}{3.7044448 \\times 10^{13}\\,\\text{s}^{-1}}$$\n$$\\Delta t_{\\max} \\approx 5.398923 \\times 10^{-14}\\,\\text{s}$$\n\nThe problem requires the answer in femtoseconds ($$1\\,\\text{fs} = 10^{-15}\\,\\text{s}$$).\n$$\\Delta t_{\\max} \\approx 5.398923 \\times 10^{-14}\\,\\text{s} \\times \\frac{1\\,\\text{fs}}{10^{-15}\\,\\text{s}} = 53.98923\\,\\text{fs}$$\n\nRounding to $$4$$ significant figures, we get:\n$$\\Delta t_{\\max} \\approx 53.99\\,\\text{fs}$$",
            "answer": "$$\n\\boxed{53.99}\n$$"
        },
        {
            "introduction": "The leapfrog algorithm's excellent long-term performance is not accidental; it arises from its deep connection to the geometric structure of Hamiltonian mechanics. One of its key properties is time-reversibility, meaning a simulation run forward and then backward in time will return to its starting point. This practice bridges theory and implementation by having you first derive the algorithm from a symmetric decomposition of the Hamiltonian evolution operator, and then write code to numerically verify its time-reversibility to machine precision. Completing this exercise provides tangible proof of the algorithm's geometric fidelity and builds confidence in its implementation .",
            "id": "3847494",
            "problem": "You are to design, implement, and validate a reversible Leapfrog (also known as Störmer–Verlet or velocity-Verlet) time integrator for a one-dimensional harmonic oscillator as a model system arising in multiscale materials simulation. Your task is to start from first principles and derive a symmetric, time-reversible update rule, implement it in a complete program, and then run a numerical experiment that confirms time reversibility to machine precision and assesses energy error scaling. Your program must execute a predefined test suite and output a single line in the specified format.\n\nFundamental base: Begin from Hamiltonian mechanics for a one-dimensional mass-spring system with Hamiltonian\n$$\nH(x,p) = \\frac{p^2}{2m} + \\frac{k x^2}{2},\n$$\nwhere $x$ is position, $p$ is momentum, $m$ is mass, and $k$ is stiffness. Hamilton’s equations are\n$$\n\\dot{x} = \\frac{\\partial H}{\\partial p} = \\frac{p}{m}, \\quad \\dot{p} = -\\frac{\\partial H}{\\partial x} = -k x.\n$$\nDefine velocity $v = \\dot{x} = p/m$. The natural frequency is $\\omega = \\sqrt{k/m}$.\n\nDerivation requirement: Using only the above fundamental laws and the definition of velocity, derive a symmetric operator splitting of the Hamiltonian flow into kinetic and potential parts that leads to a second-order, time-reversible Leapfrog update. Do not invoke any formula not deducible from the stated base. In particular:\n- Split the evolution over a single time step $\\Delta t$ into substeps that exactly integrate the kinetic part with $k = 0$ and the potential part with $m \\to \\infty$ separately, then compose them symmetrically over $\\Delta t$ to obtain a second-order method. The composition must be symmetric in time so that replacing $\\Delta t$ by $-\\Delta t$ exactly inverts one step in exact arithmetic.\n- Express the algorithm in terms of updates to $(x,v)$ over substeps of sizes proportional to $\\Delta t$, ensuring the scheme is self-consistent and well-defined for any $(m,k,\\Delta t)$ within the linear stability domain.\n\nNumerical experiment design: For each test case below, do the following.\n1. Initialize $(x_0,v_0)$ from an amplitude-phase parametrization of the analytical solution $x(t) = A \\cos(\\omega t + \\phi)$ and $v(t) = \\dot{x}(t) = -A \\,\\omega \\sin(\\omega t + \\phi)$ at time $t=0$, where $A$ is amplitude and $\\phi$ is phase in radians.\n2. Perform a forward integration of $N$ steps with step size $\\Delta t$ using the derived Leapfrog scheme to obtain $(x_N, v_N)$. Along this forward trajectory, compute the maximum absolute energy deviation\n$$\n\\max_{0 \\leq n \\leq N} \\left| E_n - E_0 \\right|, \\quad E_n = \\frac{1}{2} m v_n^2 + \\frac{1}{2} k x_n^2,\n$$\nwhere $E_0$ is the initial energy at $t=0$.\n3. Perform a backward integration of $N$ steps with step size $-\\Delta t$ starting from $(x_N, v_N)$ using the same Leapfrog scheme to recover $(\\tilde{x}_0, \\tilde{v}_0)$, the numerical approximation to the initial state.\n4. Compute the phase-space round-trip error\n$$\n\\varepsilon_{\\text{rt}} = \\max \\left( | \\tilde{x}_0 - x_0 |, | \\tilde{v}_0 - v_0 | \\right).\n$$\n\nError tolerances: You must specify and use the following tolerances rooted in floating-point roundoff and backward error analysis.\n- Let $\\epsilon_{\\mathrm{mach}}$ denote the machine epsilon of double-precision floating-point arithmetic. Use a reversibility tolerance\n$$\n\\tau_{\\text{rt}} = \\alpha \\,\\epsilon_{\\mathrm{mach}} \\, \\left( 1 + |x_0| + |v_0| \\right) \\, N,\n$$\nwith $\\alpha = 200$. Declare the reversibility test passed if $\\varepsilon_{\\text{rt}} \\le \\tau_{\\text{rt}}$.\n- For the energy error over the forward trajectory, use the scaling characteristic of symplectic integrators for quadratic Hamiltonians and set\n$$\n\\tau_{E} = \\gamma \\, E_0 \\, (\\omega \\Delta t)^2,\n$$\nwith $\\gamma = 4$. Declare the energy test passed if $\\max_{0 \\leq n \\leq N} |E_n - E_0| \\le \\tau_E$.\n\nUnits and angles: All quantities are nondimensionalized, so treat $m$, $k$, $x$, $v$, $\\Delta t$, and $E$ as unitless. Angles for $\\phi$ are in radians.\n\nStability constraint: The Leapfrog scheme for the harmonic oscillator is linearly stable for $\\omega \\Delta t < 2$. Ensure each test case respects $\\omega \\Delta t < 2$.\n\nTest suite: Use the following test cases, each as a tuple $(m,k,\\Delta t,N,A,\\phi)$.\n- Case $\\#1$: $(1, 1, 0.01, 10000, 1.0, 0.0)$.\n- Case $\\#2$: $(2, 0.5, 3.99, 100, 0.1, 1.0)$, noting that $\\omega = \\sqrt{0.5/2} = 0.5$ so $2/\\omega = 4$ and $\\Delta t = 3.99$ is close to but below the stability boundary.\n- Case $\\#3$: $(1, 4, 0.7, 5000, 0.5, 0.3)$.\n- Case $\\#4$: $(1, 1, 1.9, 1000, 0.7, 1.2)$.\n\nRequired final output format: Your program should produce a single line of output containing a list of length $4$, where each element corresponds to one test case and is itself a list of two booleans $[\\text{reversibility\\_ok}, \\text{energy\\_ok}]$. The output must be a single Python-style list literal on one line, for example, $[[\\text{True},\\text{True}],[\\text{True},\\text{True}],[\\text{True},\\text{True}],[\\text{True},\\text{True}]]$ if all tests pass.\n\nAngle unit specification: All $\\phi$ values are given in radians. No other unit conversions are needed.\n\nYour program must be a complete, runnable program that implements the derived Leapfrog scheme, computes the requested metrics, applies the tolerances as specified, and prints the results in the exact required single-line format. No user input is permitted; all values must be hard-coded as above. The program must use double-precision arithmetic. The final printed line must be the only output.",
            "solution": "The problem requires the derivation, implementation, and validation of a time-reversible Leapfrog integrator for a one-dimensional harmonic oscillator. The process begins with a derivation from first principles of Hamiltonian mechanics, followed by the design and execution of a numerical experiment to verify the algorithm's properties of time reversibility and energy conservation.\n\n### Derivation of the Symmetric Leapfrog Integrator\n\nThe system is described by the Hamiltonian $H(x,p) = \\frac{p^2}{2m} + \\frac{k x^2}{2}$, which is separable into a kinetic part, $H_T = \\frac{p^2}{2m}$, and a potential part, $H_V = \\frac{k x^2}{2}$. The time evolution of the state vector $(x, p)$ is governed by Hamilton's equations, which can be formally written using the Liouvillian operator, $L_H$, as $\\frac{d}{dt}(x,p) = L_H(x,p)$. The formal solution over a time step $\\Delta t$ is given by the action of the evolution operator, $e^{\\Delta t L_H}$.\n\nSince $H = H_T + H_V$, the Liouvillian also splits: $L_H = L_T + L_V$.\nThe operator $L_T$ corresponds to the equations of motion under only the kinetic part of the Hamiltonian ($k=0$):\n$$\n\\dot{x} = \\frac{p}{m}, \\quad \\dot{p} = 0 \\implies p(t) = \\text{const}, \\quad x(t) = x(0) + \\frac{p(0)}{m}t.\n$$\nThe operator $L_V$ corresponds to the equations of motion under only the potential part ($m \\to \\infty$, which implies $\\dot{x} = p/m \\to 0$):\n$$\n\\dot{x} = 0, \\quad \\dot{p} = -kx \\implies x(t) = \\text{const}, \\quad p(t) = p(0) - kx(0)t.\n$$\nThe evolution operators $e^{\\Delta t L_T}$ and $e^{\\Delta t L_V}$ correspond to the exact solutions of these two simplified systems.\n\nA second-order accurate, symmetric, and time-reversible integrator can be constructed using Strang splitting, which composes the exact sub-solutions in a symmetric sequence. Over a single time step $\\Delta t$, the evolution operator is approximated as:\n$$\ne^{\\Delta t L_H} \\approx e^{\\frac{\\Delta t}{2} L_V} e^{\\Delta t L_T} e^{\\frac{\\Delta t}{2} L_V}\n$$\nThis corresponds to a three-step update from the state $(x_n, p_n)$ to $(x_{n+1}, p_{n+1})$:\n1.  **Potential half-step:** Evolve under $H_V$ for time $\\Delta t/2$.\n    $$\n    p_{n+1/2}' = p_n - k x_n \\frac{\\Delta t}{2}\n    $$\n    $$\n    x_{n+1/2}' = x_n\n    $$\n2.  **Kinetic full-step:** Evolve the result under $H_T$ for time $\\Delta t$.\n    $$\n    x_{n+1} = x_{n+1/2}' + \\frac{p_{n+1/2}'}{m} \\Delta t = x_n + \\frac{p_{n+1/2}'}{m} \\Delta t\n    $$\n    $$\n    p_{n+1/2}'' = p_{n+1/2}'\n    $$\n3.  **Potential half-step:** Evolve the result under $H_V$ for time $\\Delta t/2$.\n    $$\n    p_{n+1} = p_{n+1/2}'' - k x_{n+1} \\frac{\\Delta t}{2} = p_{n+1/2}' - k x_{n+1} \\frac{\\Delta t}{2}\n    $$\n    $$\n    x_{n+1} \\text{ remains unchanged.}\n    $$\nTo express this in terms of velocity $v=p/m$, we substitute $p_n = m v_n$ and define the acceleration $a(x) = F(x)/m = -kx/m$. The steps become:\nFrom $(x_n, v_n)$:\n1.  Update velocity with a half-step using the acceleration at $x_n$:\n    $$v_{n+1/2} = v_n + a(x_n) \\frac{\\Delta t}{2}$$\n2.  Update position with a full-step using the mid-step velocity $v_{n+1/2}$:\n    $$x_{n+1} = x_n + v_{n+1/2} \\Delta t$$\n3.  Update velocity with the second half-step using the new acceleration at $x_{n+1}$:\n    $$v_{n+1} = v_{n+1/2} + a(x_{n+1}) \\frac{\\Delta t}{2}$$\nThis is the velocity-Verlet form of the Leapfrog algorithm. Its symmetric construction ensures time reversibility: applying the same algorithm with a time step of $-\\Delta t$ exactly reverses one forward step in exact arithmetic.\n\n### Numerical Experiment\n\nThe derived algorithm is implemented and tested according to the problem specification. For each test case, the following procedure is executed:\n1.  **Initialization:** The system is initialized at $t=0$ using the analytical solution for amplitude $A$ and phase $\\phi$: $x_0 = A \\cos(\\phi)$ and $v_0 = -A \\omega \\sin(\\phi)$, where $\\omega = \\sqrt{k/m}$. The initial energy is $E_0 = \\frac{1}{2}mv_0^2 + \\frac{1}{2}kx_0^2$.\n2.  **Forward Integration:** The system is integrated forward for $N$ steps with step size $\\Delta t$. During this trajectory, the maximum absolute deviation of the numerical energy, $\\max_n |E_n - E_0|$, is calculated. Let the final state be $(x_N, v_N)$.\n3.  **Backward Integration:** Starting from $(x_N, v_N)$, the system is integrated backward for $N$ steps using a time step of $-\\Delta t$. The resulting state, $(\\tilde{x}_0, \\tilde{v}_0)$, is an approximation of the initial state.\n4.  **Error Evaluation:**\n    *   The **round-trip error**, $\\varepsilon_{\\text{rt}} = \\max(|\\tilde{x}_0 - x_0|, |\\tilde{v}_0 - v_0|)$, quantifies the numerical reversibility. The test passes if $\\varepsilon_{\\text{rt}} \\le \\tau_{\\text{rt}}$, where the tolerance $\\tau_{\\text{rt}} = \\alpha \\epsilon_{\\mathrm{mach}} (1 + |x_0| + |v_0|) N$ with $\\alpha=200$ accounts for the expected accumulation of floating-point round-off error.\n    *   The **energy conservation error** is tested by comparing the maximum energy deviation against the tolerance $\\tau_E = \\gamma E_0 (\\omega \\Delta t)^2$ with $\\gamma=4$. The test passes if $\\max_n |E_n - E_0| \\le \\tau_E$. This tolerance is based on the known error behavior of symplectic integrators for quadratic Hamiltonians, where the energy error is bounded and scales with $(\\Delta t)^2$.\n\nThe program iterates through the four specified test cases, performs these calculations, and determines two boolean outcomes for each: `reversibility_ok` and `energy_ok`. The final results are aggregated and printed in the specified format. The use of double-precision floating-point arithmetic (`float` in Python) and the `numpy` library is essential for meeting the precision requirements.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates a reversible Leapfrog integrator for a 1D harmonic oscillator.\n    Executes a predefined test suite and reports on time reversibility and energy error.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, k, dt, N, A, phi)\n        (1.0, 1.0, 0.01, 10000, 1.0, 0.0),\n        (2.0, 0.5, 3.99, 100, 0.1, 1.0),\n        (1.0, 4.0, 0.7, 5000, 0.5, 0.3),\n        (1.0, 1.0, 1.9, 1000, 0.7, 1.2),\n    ]\n\n    results = []\n    \n    # Define constants for error tolerances\n    eps_mach = np.finfo(float).eps\n    alpha = 200.0\n    gamma = 4.0\n\n    def leapfrog_step(x, v, m, k, dt):\n        \"\"\"Performs a single step of the velocity-Verlet algorithm.\"\"\"\n        a = -k * x / m\n        v_half = v + a * dt / 2.0\n        x_new = x + v_half * dt\n        a_new = -k * x_new / m\n        v_new = v_half + a_new * dt / 2.0\n        return x_new, v_new\n\n    for case in test_cases:\n        m, k, dt, N, A, phi = case\n        \n        # 1. Initialization\n        omega = np.sqrt(k / m)\n        \n        # Ensure stability constraint is met (as a sanity check)\n        if omega * abs(dt) >= 2.0:\n            raise ValueError(f\"Stability condition omega*dt < 2 not met for case {case}\")\n            \n        x0 = A * np.cos(phi)\n        v0 = -A * omega * np.sin(phi)\n        E0 = 0.5 * m * v0**2 + 0.5 * k * x0**2\n\n        # 2. Forward integration and energy error tracking\n        x_f, v_f = x0, v0\n        max_energy_deviation = 0.0\n        for _ in range(N):\n            x_f, v_f = leapfrog_step(x_f, v_f, m, k, dt)\n            En = 0.5 * m * v_f**2 + 0.5 * k * x_f**2\n            max_energy_deviation = max(max_energy_deviation, abs(En - E0))\n        \n        xN, vN = x_f, v_f\n\n        # 3. Backward integration\n        x_b, v_b = xN, vN\n        for _ in range(N):\n            x_b, v_b = leapfrog_step(x_b, v_b, m, k, -dt)\n        \n        x_tilde_0, v_tilde_0 = x_b, v_b\n\n        # 4. Compute errors and check against tolerances\n        \n        # Reversibility test\n        err_rt = max(abs(x_tilde_0 - x0), abs(v_tilde_0 - v0))\n        tol_rt = alpha * eps_mach * (1.0 + abs(x0) + abs(v0)) * N\n        reversibility_ok = err_rt <= tol_rt\n        \n        # Energy conservation test\n        tol_E = gamma * E0 * (omega * dt)**2\n        if E0 == 0:\n            # If initial energy is zero (trivial case), it must remain exactly zero\n            energy_ok = (max_energy_deviation == 0.0)\n        else:\n            energy_ok = max_energy_deviation <= tol_E\n\n        # Append boolean results\n        results.append([reversibility_ok, energy_ok])\n\n    # Final print statement in the exact required format.\n    # The format requires no spaces, e.g., [[True,True],[False,True]]\n    sub_results_str = [str(res_pair).replace(' ', '') for res_pair in results]\n    print(f\"[{','.join(sub_results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In computational science, it is tempting to believe that a higher-order method is always superior. This practice challenges that notion by comparing the second-order leapfrog algorithm with the classic fourth-order Runge-Kutta (RK4) method for a nonlinear Hamiltonian system. While RK4 has a smaller local error for a given time step, it is not symplectic and fails to conserve a shadow Hamiltonian. Through this numerical experiment, you will observe firsthand how leapfrog's superior geometric properties result in bounded energy error over long simulations, while RK4 leads to a systematic energy drift, making leapfrog the preferred choice for long-term molecular dynamics simulations .",
            "id": "3847470",
            "problem": "Consider a single-degree-of-freedom, conservative nonlinear oscillator that models a coarse-grained mode in a multiscale materials simulation. Let the displacement be $x(t)$ and velocity be $v(t)=\\frac{dx}{dt}$, with dynamics governed by Newton's second law for unit mass under a potential $U(x)=\\frac{1}{2}x^{2}+\\frac{\\alpha}{4}x^{4}$. The equation of motion is the first-order system\n$$\n\\frac{dx}{dt} = v,\\qquad \\frac{dv}{dt} = a(x) = -\\frac{dU}{dx} = -x - \\alpha x^{3}.\n$$\nThe Hamiltonian (total energy) is\n$$\nH(x,v) = \\frac{1}{2}v^{2} + \\frac{1}{2}x^{2} + \\frac{\\alpha}{4}x^{4},\n$$\nwhich is conserved exactly by the continuous dynamics.\n\nYou must implement two explicit time-integration algorithms to advance the solution from $(x(0),v(0))$ to $(x(T),v(T))$ over a long integration time $T$ using a uniform time step $\\Delta t$:\n- The Leapfrog algorithm (also called velocity Verlet), which updates a staggered velocity and is known to be symplectic.\n- The Runge–Kutta fourth-order method (RK4), which advances the coupled first-order system with classical fourth-order accuracy but is not symplectic.\n\nDefine the global state error at final time $T$ for a numerical method with time step $\\Delta t$ as\n$$\ne(\\Delta t; T) = \\sqrt{\\left(x_{\\Delta t}(T)-x_{\\mathrm{ref}}(T)\\right)^{2} + \\left(v_{\\Delta t}(T)-v_{\\mathrm{ref}}(T)\\right)^{2}},\n$$\nwhere $(x_{\\mathrm{ref}}(T),v_{\\mathrm{ref}}(T))$ is a high-accuracy reference solution obtained by RK4 with a much smaller time step $\\Delta t_{\\mathrm{ref}}$.\n\nYour program must:\n1. Work in dimensionless units for all quantities $(x,v,t,\\alpha,\\Delta t,T)$.\n2. For each test case listed below, compute the reference solution with RK4 at $\\Delta t_{\\mathrm{ref}}=\\Delta t_{\\mathrm{base}}/16$, then compute the global error $e(\\Delta t;T)$ for each method and each time step $\\Delta t \\in \\{\\Delta t_{\\mathrm{base}},\\Delta t_{\\mathrm{base}}/2,\\Delta t_{\\mathrm{base}}/4\\}$.\n3. For each method and each test case, estimate the empirical error scaling exponent $s$ by performing a linear least-squares fit of $\\log(e)$ versus $\\log(\\Delta t)$ over the three values of $\\Delta t$, so that $e(\\Delta t;T)\\approx C\\,(\\Delta t)^{s}$.\n4. For each method at the coarsest step $\\Delta t=\\Delta t_{\\mathrm{base}}$, compute the relative energy drift at time $T$,\n$$\nd = \\frac{\\left|H\\big(x_{\\Delta t}(T),v_{\\Delta t}(T)\\big) - H\\big(x(0),v(0)\\big)\\right|}{\\left|H\\big(x(0),v(0)\\big)\\right|}.\n$$\n\nTest suite (all quantities dimensionless):\n- Case $1$: $\\alpha=0.1$, $x(0)=1.0$, $v(0)=0.0$, $T=200.0$, $\\Delta t_{\\mathrm{base}}=0.05$.\n- Case $2$: $\\alpha=1.0$, $x(0)=0.5$, $v(0)=0.0$, $T=200.0$, $\\Delta t_{\\mathrm{base}}=0.04$.\n- Case $3$: $\\alpha=-0.3$, $x(0)=0.8$, $v(0)=0.0$, $T=200.0$, $\\Delta t_{\\mathrm{base}}=0.04$.\n- Case $4$: $\\alpha=0.5$, $x(0)=1.2$, $v(0)=0.0$, $T=192.0$, $\\Delta t_{\\mathrm{base}}=0.03$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a sublist of four floating-point numbers in the order $[s_{\\mathrm{Leapfrog}}, s_{\\mathrm{RK4}}, d_{\\mathrm{Leapfrog}}, d_{\\mathrm{RK4}}]$, where $s$ is the empirical error scaling exponent and $d$ is the relative energy drift at $\\Delta t=\\Delta t_{\\mathrm{base}}$. The final format is\n$$\n\\text{[}[s_{L,1},s_{R,1},d_{L,1},d_{R,1}],\\ [s_{L,2},s_{R,2},d_{L,2},d_{R,2}],\\ [s_{L,3},s_{R,3},d_{L,3},d_{R,3}],\\ [s_{L,4},s_{R,4},d_{L,4},d_{R,4}]\\text{]},\n$$\nwith each number expressed as a decimal. The program must be self-contained and require no input. Ensure that for each case, $T/\\Delta t$ and $T/\\Delta t_{\\mathrm{ref}}$ are integers so that the final time $T$ is exactly reached by all integrations.",
            "solution": "The problem requires the implementation and comparison of two numerical integration algorithms, the Leapfrog (velocity Verlet) method and the classical fourth-order Runge-Kutta (RK$4$) method, for a conservative nonlinear oscillator. The comparison is based on the global error convergence rate and long-term energy conservation. The oscillator is a single-degree-of-freedom system with unit mass, whose dynamics are described by a Hamiltonian $H(x,v)$.\n\nThe system is defined by the position $x(t)$ and velocity $v(t)$, with the potential energy given by $U(x) = \\frac{1}{2}x^2 + \\frac{\\alpha}{4}x^4$. The equations of motion form a first-order system:\n$$\n\\frac{dx}{dt} = v\n$$\n$$\n\\frac{dv}{dt} = a(x) = -\\frac{dU}{dx} = -x - \\alpha x^3\n$$\nThe total energy, or Hamiltonian, is a conserved quantity in the exact dynamics:\n$$\nH(x,v) = \\frac{1}{2}v^2 + U(x) = \\frac{1}{2}v^2 + \\frac{1}{2}x^2 + \\frac{\\alpha}{4}x^4\n$$\nWe will discretize these equations with a uniform time step $\\Delta t$ to advance the state $(x_n, v_n)$ at time $t_n$ to $(x_{n+1}, v_{n+1})$ at time $t_{n+1} = t_n + \\Delta t$.\n\n**Leapfrog (Velocity Verlet) Algorithm**\nThe Leapfrog algorithm is a second-order symplectic integrator, a property that makes it exceptionally suitable for long-term simulations of Hamiltonian systems. Its symplecticity ensures the conservation of a \"shadow\" Hamiltonian, which is a perturbed version of the true Hamiltonian, leading to bounded energy fluctuations rather than a systematic drift. The velocity Verlet formulation is a popular and algebraically equivalent variant that synchronizes positions and velocities at integer time steps. The update from time $t_n$ to $t_{n+1}$ proceeds in three steps:\n\n$1$. Update the velocity by a half step:\n$$\nv_{n+1/2} = v_n + a(x_n) \\frac{\\Delta t}{2}\n$$\n$2$. Update the position by a full step using the half-step velocity:\n$$\nx_{n+1} = x_n + v_{n+1/2} \\Delta t\n$$\n$3$. Update the velocity by the remaining half step using the new acceleration:\n$$\nv_{n+1} = v_{n+1/2} + a(x_{n+1}) \\frac{\\Delta t}{2}\n$$\nThis algorithm is time-reversible and has a local truncation error of order $(\\Delta t)^3$, leading to a global error of order $(\\Delta t)^2$. We therefore expect its empirical error scaling exponent $s_{\\mathrm{Leapfrog}}$ to be approximately $2$.\n\n**Runge-Kutta Fourth-Order (RK4) Algorithm**\nThe classical RK$4$ method is a high-order, general-purpose explicit solver for ordinary differential equations. It achieves fourth-order accuracy by evaluating the derivative function four times per step at carefully chosen intermediate points. For the state vector $\\mathbf{y}(t) = [x(t), v(t)]^T$, the system is $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$, where $\\mathbf{f}(\\mathbf{y}) = [v, a(x)]^T$. The update rule is:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nwhere the four stages are:\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n) = [v_n, a(x_n)]^T\n$$\n$$\n\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1)\n$$\n$$\n\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2)\n$$\n$$\n\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + \\Delta t \\mathbf{k}_3)\n$$\nRK$4$ has a local truncation error of order $(\\Delta t)^5$, leading to a global error of order $(\\Delta t)^4$. We expect its empirical error scaling exponent $s_{\\mathrm{RK4}}$ to be approximately $4$. However, RK$4$ is not a symplectic integrator. For Hamiltonian systems, this means it does not conserve a shadow Hamiltonian, and the numerical energy typically exhibits a slow, systematic drift over long integration times.\n\n**Numerical Analysis**\nTo evaluate the algorithms, we perform the following tasks:\n\n$1$. **Reference Solution**: A high-accuracy reference solution $(x_{\\mathrm{ref}}(T), v_{\\mathrm{ref}}(T))$ is computed using the RK$4$ method with a very small time step, $\\Delta t_{\\mathrm{ref}} = \\Delta t_{\\mathrm{base}}/16$. This solution serves as a proxy for the true analytical solution.\n\n$2$. **Global Error and Convergence Rate**: The global error $e(\\Delta t; T)$ is computed for both algorithms at time steps $\\Delta t \\in \\{\\Delta t_{\\mathrm{base}}, \\Delta t_{\\mathrm{base}}/2, \\Delta t_{\\mathrm{base}}/4\\}$. The error is measured as the Euclidean distance in phase space between the numerical solution and the reference solution:\n$$\ne(\\Delta t; T) = \\sqrt{\\left(x_{\\Delta t}(T)-x_{\\mathrm{ref}}(T)\\right)^{2} + \\left(v_{\\Delta t}(T)-v_{\\mathrm{ref}}(T)\\right)^{2}}\n$$\nThe empirical order of convergence, $s$, is determined by the relationship $e(\\Delta t) \\propto (\\Delta t)^s$. Taking logarithms, we have $\\log(e) = s \\log(\\Delta t) + \\text{const}$. We find $s$ by performing a linear least-squares fit on the points $(\\log(\\Delta t_i), \\log(e_i))$. The slope of this line is the desired exponent $s$.\n\n$3$. **Energy Conservation**: The long-term stability of the integrators is assessed by computing the relative energy drift, $d$, at the final time $T$ for the coarsest time step $\\Delta t_{\\mathrm{base}}$:\n$$\nd = \\frac{\\left|H\\big(x_{\\Delta t}(T),v_{\\Delta t}(T)\\big) - H\\big(x(0),v(0)\\big)\\right|}{\\left|H\\big(x(0),v(0)\\big)\\right|}\n$$\nThe expected outcome is that for a long integration time $T$, the Leapfrog algorithm, despite being lower-order, will exhibit superior energy conservation (smaller $d$) compared to RK$4$, which will show energy drift.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing Leapfrog and RK4 integrators for a nonlinear oscillator.\n    \"\"\"\n    \n    # Test suite: (alpha, x0, v0, T, dt_base)\n    test_cases = [\n        (0.1, 1.0, 0.0, 200.0, 0.05),\n        (1.0, 0.5, 0.0, 200.0, 0.04),\n        (-0.3, 0.8, 0.0, 200.0, 0.04),\n        (0.5, 1.2, 0.0, 192.0, 0.03),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        alpha, x0, v0, T, dt_base = case\n\n        # Define model-specific functions\n        def acceleration(x, alpha_val):\n            return -x - alpha_val * x**3\n\n        def hamiltonian(x, v, alpha_val):\n            return 0.5 * v**2 + 0.5 * x**2 + 0.25 * alpha_val * x**4\n\n        # Define integrator step functions\n        def leapfrog_step(x, v, dt, alpha_val):\n            v_half = v + acceleration(x, alpha_val) * dt / 2.0\n            x_new = x + v_half * dt\n            v_new = v_half + acceleration(x_new, alpha_val) * dt / 2.0\n            return x_new, v_new\n\n        def rk4_step(x, v, dt, alpha_val):\n            # k1\n            k1_x = v\n            k1_v = acceleration(x, alpha_val)\n            # k2\n            x2 = x + 0.5 * dt * k1_x\n            v2 = v + 0.5 * dt * k1_v\n            k2_x = v2\n            k2_v = acceleration(x2, alpha_val)\n            # k3\n            x3 = x + 0.5 * dt * k2_x\n            v3 = v + 0.5 * dt * k2_v\n            k3_x = v3\n            k3_v = acceleration(x3, alpha_val)\n            # k4\n            x4 = x + dt * k3_x\n            v4 = v + dt * k3_v\n            k4_x = v4\n            k4_v = acceleration(x4, alpha_val)\n\n            x_new = x + (dt / 6.0) * (k1_x + 2.0 * k2_x + 2.0 * k3_x + k4_x)\n            v_new = v + (dt / 6.0) * (k1_v + 2.0 * k2_v + 2.0 * k3_v + k4_v)\n            return x_new, v_new\n\n        # Define simulation runner\n        def run_simulation(step_func, x_start, v_start, T_sim, dt_sim, alpha_val):\n            x_curr, v_curr = x_start, v_start\n            num_steps = int(round(T_sim / dt_sim))\n            for _ in range(num_steps):\n                x_curr, v_curr = step_func(x_curr, v_curr, dt_sim, alpha_val)\n            return x_curr, v_curr\n\n        # 1. Compute reference solution\n        dt_ref = dt_base / 16.0\n        x_ref, v_ref = run_simulation(rk4_step, x0, v0, T, dt_ref, alpha)\n\n        # 2. Compute global errors for different dt\n        dts = np.array([dt_base, dt_base / 2.0, dt_base / 4.0])\n        errors_leapfrog = []\n        errors_rk4 = []\n\n        for dt in dts:\n            # Leapfrog error\n            x_L, v_L = run_simulation(leapfrog_step, x0, v0, T, dt, alpha)\n            err_L = np.sqrt((x_L - x_ref)**2 + (v_L - v_ref)**2)\n            errors_leapfrog.append(err_L)\n\n            # RK4 error\n            x_R, v_R = run_simulation(rk4_step, x0, v0, T, dt, alpha)\n            err_R = np.sqrt((x_R - x_ref)**2 + (v_R - v_ref)**2)\n            errors_rk4.append(err_R)\n\n        # 3. Estimate empirical error scaling exponent s\n        log_dts = np.log(dts)\n        log_errors_L = np.log(errors_leapfrog)\n        log_errors_R = np.log(errors_rk4)\n        \n        # Use np.polyfit for linear least-squares regression. It returns [slope, intercept].\n        s_leapfrog = np.polyfit(log_dts, log_errors_L, 1)[0]\n        s_rk4 = np.polyfit(log_dts, log_errors_R, 1)[0]\n\n        # 4. Compute relative energy drift d at dt = dt_base\n        H0 = hamiltonian(x0, v0, alpha)\n\n        # Leapfrog drift\n        x_L_final, v_L_final = run_simulation(leapfrog_step, x0, v0, T, dt_base, alpha)\n        H_L_final = hamiltonian(x_L_final, v_L_final, alpha)\n        d_leapfrog = np.abs(H_L_final - H0) / np.abs(H0)\n\n        # RK4 drift\n        x_R_final, v_R_final = run_simulation(rk4_step, x0, v0, T, dt_base, alpha)\n        H_R_final = hamiltonian(x_R_final, v_R_final, alpha)\n        d_rk4 = np.abs(H_R_final - H0) / np.abs(H0)\n\n        case_results = [s_leapfrog, s_rk4, d_leapfrog, d_rk4]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists.\n    inner_strings = [f\"[{','.join(f'{val}' for val in res)}]\" for res in all_results]\n    final_output_str = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}