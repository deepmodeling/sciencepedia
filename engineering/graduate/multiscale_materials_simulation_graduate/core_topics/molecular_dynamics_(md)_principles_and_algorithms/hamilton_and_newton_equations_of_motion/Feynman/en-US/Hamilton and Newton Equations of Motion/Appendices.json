{
    "hands_on_practices": [
        {
            "introduction": "Hamiltonian dynamics possesses a remarkable geometric property: the volume of any region in phase space is preserved as the system evolves in time. This principle, known as Liouville's theorem, is a cornerstone of statistical mechanics and a key benchmark for designing reliable numerical integrators. In this exercise (), you will provide a direct proof of this theorem for the simple harmonic oscillator, a fundamental model for vibrations in materials, by explicitly calculating the Jacobian of the time-evolution map.",
            "id": "3814000",
            "problem": "In multiscale materials simulation, a local vibrational mode in a crystalline solid can often be approximated as a one-dimensional harmonic oscillator. Consider the Hamiltonian system for a single coarse-grained degree of freedom with position $x$ and momentum $p$, with mass $m$ and angular frequency $\\omega$, governed by Hamilton's equations derived from the Hamiltonian\n$$\nH(x,p) = \\frac{p^{2}}{2 m} + \\frac{1}{2} m \\omega^{2} x^{2}.\n$$\nLet the initial condition at time $t=0$ be $(x(0),p(0)) = (x_{0},p_{0})$. Define the flow map $\\Phi^{t}$ that takes the initial state $(x_{0},p_{0})$ to the state $(x(t),p(t))$ at time $t$ under the Hamiltonian dynamics. In the context of Molecular Dynamics (MD), phase-space volume conservation is related to the Jacobian determinant of $\\Phi^{t}$.\n\nStarting from Newton's second law and Hamilton's equations, derive the explicit form of $(x(t),p(t))$ in terms of $(x_{0},p_{0})$, and then compute the Jacobian matrix $\\mathrm{D}\\Phi^{t}(x_{0},p_{0})$ and its determinant. Verify that the Jacobian determinant is equal to $1$ for all real times $t$. Express the final answer as a dimensionless number with no units.",
            "solution": "The problem statement is first subjected to validation.\nThe givens are:\n- A one-dimensional system described by a position coordinate $x$ and momentum $p$.\n- The mass of the particle is $m$ and its angular frequency of oscillation is $\\omega$.\n- The system's Hamiltonian is explicitly provided as $H(x,p) = \\frac{p^{2}}{2 m} + \\frac{1}{2} m \\omega^{2} x^{2}$.\n- The initial conditions at time $t=0$ are $(x(0),p(0)) = (x_{0},p_{0})$.\n- The flow map $\\Phi^{t}$ is defined as the function that evolves the initial state to the state at time $t$, i.e., $\\Phi^{t}(x_{0},p_{0}) = (x(t),p(t))$.\nThe tasks are to derive $(x(t),p(t))$, compute the Jacobian matrix $\\mathrm{D}\\Phi^{t}(x_{0},p_{0})$, calculate its determinant, and verify that the determinant is equal to $1$.\n\nThe problem is scientifically sound, as it deals with the canonical one-dimensional harmonic oscillator, a fundamental model in physics. The concepts of Hamiltonian mechanics, flow maps, and Jacobians are standard and correctly applied. The problem is well-posed, with sufficient information to derive a unique solution. The language is objective and formal. Therefore, the problem is deemed valid.\n\nWe proceed with the solution. First, we derive the equations of motion from the Hamiltonian using Hamilton's canonical equations:\n$$\n\\dot{x} = \\frac{\\partial H}{\\partial p} \\quad \\text{and} \\quad \\dot{p} = -\\frac{\\partial H}{\\partial x}\n$$\nWe compute the required partial derivatives of the given Hamiltonian $H(x,p) = \\frac{p^{2}}{2m} + \\frac{1}{2}m\\omega^{2}x^{2}$:\n$$\n\\frac{\\partial H}{\\partial p} = \\frac{\\partial}{\\partial p} \\left( \\frac{p^{2}}{2m} + \\frac{1}{2}m\\omega^{2}x^{2} \\right) = \\frac{2p}{2m} = \\frac{p}{m}\n$$\n$$\n\\frac{\\partial H}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\frac{p^{2}}{2m} + \\frac{1}{2}m\\omega^{2}x^{2} \\right) = \\frac{1}{2}m\\omega^{2}(2x) = m\\omega^{2}x\n$$\nSubstituting these expressions into Hamilton's equations yields a system of two coupled first-order ordinary differential equations (ODEs):\n$$\n(1) \\quad \\dot{x} = \\frac{p}{m}\n$$\n$$\n(2) \\quad \\dot{p} = -m\\omega^{2}x\n$$\nTo show the connection to Newton's second law, as requested by the problem, we can differentiate equation (1) with respect to time $t$:\n$$\n\\ddot{x} = \\frac{\\dot{p}}{m}\n$$\nSubstituting equation (2) into this result eliminates $\\dot{p}$:\n$$\n\\ddot{x} = \\frac{-m\\omega^{2}x}{m} = -\\omega^{2}x\n$$\nThis leads to the familiar second-order ODE for simple harmonic motion, $\\ddot{x} + \\omega^{2}x = 0$, which is the embodiment of Newton's second law for a harmonic force $F = -m\\omega^2 x$.\n\nThe general solution to this second-order ODE is:\n$$\nx(t) = A \\cos(\\omega t) + B \\sin(\\omega t)\n$$\nwhere $A$ and $B$ are constants to be determined from the initial conditions $(x_{0},p_{0})$. At $t=0$, we have $x(0) = x_{0}$:\n$$\nx(0) = A \\cos(0) + B \\sin(0) = A \\cdot 1 + B \\cdot 0 = A\n$$\nHence, the constant $A$ is equal to the initial position $x_{0}$.\n\nTo determine the constant $B$, we use the initial condition for the momentum, $p(0) = p_{0}$. First, we find the expression for $p(t)$ using equation (1), $p(t) = m\\dot{x}(t)$. We differentiate $x(t)$ with respect to time:\n$$\n\\dot{x}(t) = \\frac{d}{dt} (x_{0} \\cos(\\omega t) + B \\sin(\\omega t)) = -x_{0}\\omega\\sin(\\omega t) + B\\omega\\cos(\\omega t)\n$$\nTherefore, the momentum is:\n$$\np(t) = m\\dot{x}(t) = m(-x_{0}\\omega\\sin(\\omega t) + B\\omega\\cos(\\omega t))\n$$\nApplying the initial condition at $t=0$:\n$$\np(0) = m(-x_{0}\\omega\\sin(0) + B\\omega\\cos(0)) = m(0 + B\\omega) = mB\\omega\n$$\nSince $p(0)=p_{0}$, we have $p_{0} = mB\\omega$, which allows us to solve for $B$:\n$$\nB = \\frac{p_{0}}{m\\omega}\n$$\nSubstituting the expressions for $A$ and $B$ back into the solutions for $x(t)$ and $p(t)$, we obtain the explicit form of the flow map $\\Phi^{t}(x_{0},p_{0}) = (x(t),p(t))$:\n$$\nx(t) = x_{0} \\cos(\\omega t) + \\frac{p_{0}}{m\\omega} \\sin(\\omega t)\n$$\n$$\np(t) = -m\\omega x_{0} \\sin(\\omega t) + p_{0} \\cos(\\omega t)\n$$\nThese are the components of the state vector at time $t$ expressed in terms of the initial state.\n\nNext, we calculate the Jacobian matrix of the flow map, $\\mathrm{D}\\Phi^{t}(x_{0},p_{0})$. The Jacobian is the matrix of all first-order partial derivatives of the vector function $\\Phi^t$ with respect to its input variables $(x_{0},p_{0})$:\n$$\n\\mathrm{D}\\Phi^{t}(x_{0},p_{0}) = \n\\begin{pmatrix} \n\\frac{\\partial x(t)}{\\partial x_{0}} & \\frac{\\partial x(t)}{\\partial p_{0}} \\\\\n\\frac{\\partial p(t)}{\\partial x_{0}} & \\frac{\\partial p(t)}{\\partial p_{0}} \n\\end{pmatrix}\n$$\nWe calculate the four elements of this matrix:\n$$\n\\frac{\\partial x(t)}{\\partial x_{0}} = \\frac{\\partial}{\\partial x_{0}} \\left( x_{0} \\cos(\\omega t) + \\frac{p_{0}}{m\\omega} \\sin(\\omega t) \\right) = \\cos(\\omega t)\n$$\n$$\n\\frac{\\partial x(t)}{\\partial p_{0}} = \\frac{\\partial}{\\partial p_{0}} \\left( x_{0} \\cos(\\omega t) + \\frac{p_{0}}{m\\omega} \\sin(\\omega t) \\right) = \\frac{1}{m\\omega} \\sin(\\omega t)\n$$\n$$\n\\frac{\\partial p(t)}{\\partial x_{0}} = \\frac{\\partial}{\\partial x_{0}} \\left( -m\\omega x_{0} \\sin(\\omega t) + p_{0} \\cos(\\omega t) \\right) = -m\\omega \\sin(\\omega t)\n$$\n$$\n\\frac{\\partial p(t)}{\\partial p_{0}} = \\frac{\\partial}{\\partial p_{0}} \\left( -m\\omega x_{0} \\sin(\\omega t) + p_{0} \\cos(\\omega t) \\right) = \\cos(\\omega t)\n$$\nThe Jacobian matrix is therefore:\n$$\n\\mathrm{D}\\Phi^{t}(x_{0},p_{0}) = \n\\begin{pmatrix} \n\\cos(\\omega t) & \\frac{1}{m\\omega} \\sin(\\omega t) \\\\\n-m\\omega \\sin(\\omega t) & \\cos(\\omega t)\n\\end{pmatrix}\n$$\nFinally, we compute the determinant of this matrix. For a $2 \\times 2$ matrix $\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$, the determinant is $ad-bc$.\n$$\n\\det(\\mathrm{D}\\Phi^{t}(x_{0},p_{0})) = (\\cos(\\omega t))(\\cos(\\omega t)) - \\left(\\frac{1}{m\\omega} \\sin(\\omega t)\\right)(-m\\omega \\sin(\\omega t))\n$$\n$$\n\\det(\\mathrm{D}\\Phi^{t}(x_{0},p_{0})) = \\cos^{2}(\\omega t) - \\left(-\\frac{m\\omega}{m\\omega} \\sin^{2}(\\omega t)\\right)\n$$\n$$\n\\det(\\mathrm{D}\\Phi^{t}(x_{0},p_{0})) = \\cos^{2}(\\omega t) + \\sin^{2}(\\omega t)\n$$\nUsing the fundamental trigonometric identity $\\cos^{2}(\\theta) + \\sin^{2}(\\theta) = 1$, we obtain:\n$$\n\\det(\\mathrm{D}\\Phi^{t}(x_{0},p_{0})) = 1\n$$\nThis result is independent of time $t$, initial conditions $(x_{0},p_{0})$, mass $m$, and frequency $\\omega$. This verifies that the Jacobian determinant is indeed $1$ for all real times $t$, a manifestation of Liouville's theorem, which states that Hamiltonian flows preserve phase-space volume.",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "When we translate the continuous equations of motion into a step-by-step algorithm for computer simulation, the choice of time step $\\Delta t$ becomes critical. If the time step is too large, the numerical solution can become unstable and diverge exponentially from the true physical trajectory. This exercise () guides you through a linear stability analysis of the velocity Verlet algorithm—a workhorse of molecular dynamics—to determine the maximum stable time step for a harmonic oscillator, which represents the fastest vibrational frequency in a simulation.",
            "id": "3814061",
            "problem": "In atomistic Molecular Dynamics (MD), bonded interactions are often modeled as harmonic springs. Consider a single degree-of-freedom harmonic oscillator representing an isolated bonded interaction with mass $m$ and spring constant $k$. The dynamics are governed by Newton's second law $m \\ddot{x} = -k x$, which is equivalent to a Hamiltonian $H(p,x) = \\frac{p^2}{2m} + \\frac{k}{2} x^2$ with canonical equations $\\dot{x} = \\frac{\\partial H}{\\partial p}$ and $\\dot{p} = -\\frac{\\partial H}{\\partial x}$. Using the velocity Verlet time integrator, analyze the linear stability of the discrete dynamics by deriving the discrete dispersion relation for the position sequence $x_{n}$, assuming a mode ansatz with a constant phase advance per step measured in radians. From this dispersion relation, determine the largest time step $\\Delta t$ for which solutions remain bounded (i.e., do not exhibit exponential growth), expressed as a closed-form analytic function of $k$ and $m$. Express the final time step in seconds. No numerical rounding is required.",
            "solution": "The problem statement is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- System: A single degree-of-freedom harmonic oscillator representing an isolated bonded interaction.\n- Mass: $m$.\n- Spring constant: $k$.\n- Equation of motion (Newtonian): $m \\ddot{x} = - k x$.\n- Hamiltonian: $H(p,x) = \\frac{p^{2}}{2 m} + \\frac{k}{2} x^{2}$.\n- Canonical equations: $\\dot{x} = \\frac{\\partial H}{\\partial p}$ and $\\dot{p} = - \\frac{\\partial H}{\\partial x}$.\n- Time integration scheme: Velocity Verlet.\n- Analysis method: Analyze linear stability by deriving the discrete dispersion relation for the position sequence $x_n$.\n- Ansatz: A mode ansatz with a constant phase advance per step.\n- Objective: Determine the largest time step $\\Delta t$ for which solutions remain bounded, expressed as a closed-form analytic function of $k$ and $m$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded (Critical)**: The problem is a standard, fundamental exercise in computational physics and molecular simulation. The harmonic oscillator is a canonical model system, and the velocity Verlet algorithm is one of the most common and important time integrators. The stability analysis of numerical methods is a core topic in the field. The problem is firmly based on established principles of classical mechanics and numerical analysis.\n- **Well-Posed**: The problem provides a clearly defined physical system, a specific numerical algorithm, and a precise question (the stability limit of the timestep). It has a unique, stable, and meaningful solution.\n- **Objective (Critical)**: The language is technical, precise, and free of any subjective or ambiguous terminology.\n- **Completeness**: The problem is self-contained. All necessary information to perform the stability analysis is provided. There are no missing or contradictory conditions.\n\n### Step 3: Verdict and Action\nThe problem is valid as it is scientifically grounded, well-posed, objective, and complete. A solution will be provided.\n\nThe dynamics of the harmonic oscillator are described by the equation $m \\ddot{x} = -k x$. The natural angular frequency of the oscillator is $\\omega = \\sqrt{k/m}$. The equation of motion can be written as $\\ddot{x} + \\omega^2 x = 0$. The acceleration is $a(t) = \\ddot{x}(t) = -\\omega^2 x(t)$.\n\nThe velocity Verlet algorithm propagates the position $x$ and velocity $v$ from time $n \\Delta t$ to $(n+1) \\Delta t$. Let $x_n = x(n \\Delta t)$, $v_n = v(n \\Delta t)$, and $a_n = a(n \\Delta t)$. The algorithm consists of two main steps:\n1. Position update:\n   $$x_{n+1} = x_n + v_n \\Delta t + \\frac{1}{2} a_n (\\Delta t)^2$$\n2. Velocity update:\n   $$v_{n+1} = v_n + \\frac{1}{2} (a_n + a_{n+1}) \\Delta t$$\nFor the harmonic oscillator, we have $a_n = -\\omega^2 x_n$ and $a_{n+1} = -\\omega^2 x_{n+1}$.\n\nTo derive the discrete dispersion relation for the position sequence $x_n$, we combine these equations to form a single recurrence relation for $x$ only.\nFirst, substitute $a_n = -\\omega^2 x_n$ into the position update equation:\n$$x_{n+1} = x_n + v_n \\Delta t - \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2 \\quad (*)$$\nNext, we write the position update for the subsequent step, from $n+1$ to $n+2$:\n$$x_{n+2} = x_{n+1} + v_{n+1} \\Delta t + \\frac{1}{2} a_{n+1} (\\Delta t)^2$$\nSubstituting $a_{n+1} = -\\omega^2 x_{n+1}$, we have:\n$$x_{n+2} = x_{n+1} + v_{n+1} \\Delta t - \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2 \\quad (**)$$\nTo eliminate the velocities, we use the velocity update equation:\n$$v_{n+1} = v_n - \\frac{\\omega^2 \\Delta t}{2} (x_n + x_{n+1})$$\nWe can express $v_n$ and $v_{n+1}$ in terms of positions using the position update equations. From equation $(*)$, we rearrange to find $v_n$:\n$$v_n \\Delta t = x_{n+1} - x_n + \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2$$\nSimilarly, from equation $(**)$, we find $v_{n+1}$:\n$$v_{n+1} \\Delta t = x_{n+2} - x_{n+1} + \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2$$\nNow, substitute these expressions for $v_n \\Delta t$ and $v_{n+1} \\Delta t$ into the velocity update equation after multiplying it by $\\Delta t$:\n$$v_{n+1} \\Delta t = v_n \\Delta t - \\frac{\\omega^2 (\\Delta t)^2}{2} (x_n + x_{n+1})$$\n$$\\left( x_{n+2} - x_{n+1} + \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2 \\right) = \\left( x_{n+1} - x_n + \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2 \\right) - \\frac{\\omega^2 (\\Delta t)^2}{2} (x_n + x_{n+1})$$\nWe simplify the expression by collecting terms:\n$$x_{n+2} - x_{n+1} + \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2 = x_{n+1} - x_n + \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2 - \\frac{1}{2} \\omega^2 x_n (\\Delta t)^2 - \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2$$\n$$x_{n+2} - x_{n+1} + \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2 = x_{n+1} - x_n - \\frac{1}{2} \\omega^2 x_{n+1} (\\Delta t)^2$$\nIsolating $x_{n+2}$:\n$$x_{n+2} = 2x_{n+1} - x_n - \\omega^2 (\\Delta t)^2 x_{n+1}$$\nThis gives the three-term recurrence relation for the position sequence:\n$$x_{n+2} - (2 - \\omega^2 (\\Delta t)^2) x_{n+1} + x_n = 0$$\nTo find the discrete dispersion relation, we use the requested mode ansatz. Let the solution be of the form $x_n = A \\exp(i \\phi n)$, where $\\phi$ is the constant phase advance per step. Substituting this into the recurrence relation:\n$$A \\exp(i \\phi (n+2)) - (2 - \\omega^2 (\\Delta t)^2) A \\exp(i \\phi (n+1)) + A \\exp(i \\phi n) = 0$$\nDividing by $A \\exp(i \\phi n)$ (since $A \\neq 0$ for a non-trivial solution):\n$$\\exp(2i\\phi) - (2 - \\omega^2 (\\Delta t)^2) \\exp(i\\phi) + 1 = 0$$\nThis is a quadratic equation for $\\exp(i\\phi)$. To obtain the dispersion relation, we divide by $\\exp(i\\phi)$:\n$$\\exp(i\\phi) - (2 - \\omega^2 (\\Delta t)^2) + \\exp(-i\\phi) = 0$$\nUsing Euler's identity, $\\exp(i\\phi) + \\exp(-i\\phi) = 2 \\cos(\\phi)$, we get:\n$$2 \\cos(\\phi) = 2 - \\omega^2 (\\Delta t)^2$$\n$$\\cos(\\phi) = 1 - \\frac{\\omega^2 (\\Delta t)^2}{2}$$\nThis is the discrete dispersion relation for the velocity Verlet algorithm applied to a harmonic oscillator. It relates the numerical phase advance per step, $\\phi$, to the true physical frequency, $\\omega$, and the time step, $\\Delta t$.\n\nFor the numerical solution $x_n$ to remain bounded (i.e., not grow exponentially), the phase advance $\\phi$ must be a real number. This requires that its cosine lies in the interval $[-1, 1]$.\n$$-1 \\le \\cos(\\phi) \\le 1$$\nSubstituting the derived expression for $\\cos(\\phi)$:\n$$-1 \\le 1 - \\frac{\\omega^2 (\\Delta t)^2}{2} \\le 1$$\nWe analyze the two inequalities separately.\nThe right-hand inequality is:\n$$1 - \\frac{\\omega^2 (\\Delta t)^2}{2} \\le 1 \\implies -\\frac{\\omega^2 (\\Delta t)^2}{2} \\le 0$$\nThis is always true, since $\\omega^2 \\ge 0$ and $(\\Delta t)^2 \\ge 0$.\nThe left-hand inequality gives the stability-limiting condition:\n$$-1 \\le 1 - \\frac{\\omega^2 (\\Delta t)^2}{2}$$\n$$\\frac{\\omega^2 (\\Delta t)^2}{2} \\le 1 + 1$$\n$$\\frac{\\omega^2 (\\Delta t)^2}{2} \\le 2$$\n$$\\omega^2 (\\Delta t)^2 \\le 4$$\nTaking the square root of both sides (and noting that $\\omega > 0$ and $\\Delta t > 0$):\n$$\\omega \\Delta t \\le 2$$\nThe largest time step $\\Delta t_{max}$ for which the solution remains bounded corresponds to the equality:\n$$\\omega \\Delta t_{max} = 2$$\n$$\\Delta t_{max} = \\frac{2}{\\omega}$$\nFinally, we substitute the definition of the natural frequency, $\\omega = \\sqrt{k/m}$:\n$$\\Delta t_{max} = \\frac{2}{\\sqrt{k/m}}$$\n$$\\Delta t_{max} = 2 \\sqrt{\\frac{m}{k}}$$\nThis is the closed-form analytic expression for the largest stable time step. If the quantities $m$ and $k$ are given in SI units ($kg$ and $N/m = kg/s^2$, respectively), the resulting time step $\\Delta t_{max}$ will be in seconds.",
            "answer": "$$\\boxed{2 \\sqrt{\\frac{m}{k}}}$$"
        },
        {
            "introduction": "Not all numerical integrators are suitable for the long-time simulations required in materials science. Symplectic integrators, such as the velocity Verlet method, are specifically designed to preserve the geometric structure of Hamiltonian flow, leading to excellent long-term energy conservation. This practical coding exercise () contrasts the performance of the symplectic velocity Verlet method with the non-symplectic but high-order Runge-Kutta method, allowing you to directly observe the critical difference between bounded energy error and systematic energy drift.",
            "id": "3814073",
            "problem": "You are tasked to design and implement a program to compare long-time energy behavior of two time-integration methods for Hamiltonian dynamics, in the context of conservative atomistic models used in multiscale materials simulation. Begin from first principles of Hamiltonian mechanics and Newtonian mechanics. For a system with generalized coordinates $q \\in \\mathbb{R}^d$ and momenta $p \\in \\mathbb{R}^d$, with Hamiltonian $H(q,p) = T(p) + V(q)$ where $T(p)$ is the kinetic energy and $V(q)$ is the potential energy, the equations of motion are Hamilton's equations:\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p}, \\quad \n\\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q},\n$$\nand, equivalently for constant mass $m$, Newton's second law takes the form\n$$\nm \\frac{d^2 q}{dt^2} = -\\nabla V(q).\n$$\nUse dimensionless units with $m = 1$ and $T(p) = \\frac{1}{2} p^\\top p$. Implement and compare two numerical methods for integrating these equations over long times: the classical fourth-order Runge–Kutta method and the velocity Verlet method. Do not assume or use any externally given formulas beyond the fundamental laws stated above; the implementations must follow from discretizing the continuous-time ordinary differential equations implied by these laws.\n\nDefine and use the following potential energy models that are standard surrogates for interatomic interactions and vibrational modes in materials:\n\n- Single-degree-of-freedom anharmonic oscillator (Duffing-type): \n$$\nV(q) = \\frac{1}{2} k q^2 + \\frac{1}{4} \\alpha q^4,\n$$\nwith parameters $k$ and $\\alpha$ specified per test.\n\n- Two-degree-of-freedom coupled stiff–slow anharmonic oscillator:\n$$\nV(q) = \\frac{1}{2} k_1 q_1^2 + \\frac{1}{2} k_2 q_2^2 + \\frac{1}{4} \\alpha (q_1^4 + q_2^4) + \\frac{1}{2} \\beta q_1^2 q_2^2,\n$$\nwith parameters $k_1$, $k_2$, $\\alpha$, $\\beta$ specified per test, where $q = (q_1, q_2)$.\n\nFor each test case below, integrate both methods for $N$ steps with time step $h$, starting from the given initial condition $(q_0, p_0)$. The mass is $m = 1$, so velocity $v$ satisfies $v = p$. At each step $n$, compute the total energy \n$$\nH_n = \\frac{1}{2} p_n^\\top p_n + V(q_n).\n$$\nLet $H_0$ be the energy at the initial state and $H_N$ be the energy at the final state. For each method, report the final relative energy change defined by\n$$\n\\Delta_{\\text{rel}} = \\frac{H_N - H_0}{H_0}.\n$$\nAll quantities are dimensionless. Angles do not appear, so no angle unit is needed.\n\nTest suite parameters:\n\n- Case $1$ (single-degree-of-freedom anharmonic oscillator, \"happy path\"):\n  - Parameters: $k = 1.0$, $\\alpha = 0.1$.\n  - Initial condition: $q_0 = 1.0$, $p_0 = 0.0$.\n  - Time step: $h = 0.1$.\n  - Number of steps: $N = 50000$.\n\n- Case $2$ (single-degree-of-freedom anharmonic oscillator, small step, longer time):\n  - Parameters: $k = 1.0$, $\\alpha = 0.1$.\n  - Initial condition: $q_0 = 1.0$, $p_0 = 0.0$.\n  - Time step: $h = 0.01$.\n  - Number of steps: $N = 60000$.\n\n- Case $3$ (two-degree-of-freedom stiff–slow coupled anharmonic oscillator):\n  - Parameters: $k_1 = 1.0$, $k_2 = 25.0$, $\\alpha = 0.05$, $\\beta = 0.02$.\n  - Initial condition: $q_0 = (1.0, 0.5)$, $p_0 = (0.0, 0.0)$.\n  - Time step: $h = 0.02$.\n  - Number of steps: $N = 50000$.\n\nYour program must perform both integrations for each case and compute the final relative energy change for each method. The final output must be a single line containing a list of lists, in the order of the test cases above, where each inner list has the two floating-point values [$\\Delta_{\\text{rel}}^{\\text{RK4}}$, $\\Delta_{\\text{rel}}^{\\text{Verlet}}$] rounded to six decimal places. For example, the final output format must be exactly like `[[x_1,y_1],[x_2,y_2],[x_3,y_3]]` with no additional text, where $x_i$ and $y_i$ are the rounded values for case $i$.",
            "solution": "The problem requires the implementation and comparison of two numerical integration methods, the fourth-order Runge-Kutta (RK4) method and the velocity Verlet method, for solving the equations of motion in a conservative Hamiltonian system. The context is atomistic simulation, where long-term energy conservation is a critical property of a good integrator. We begin from the first principles of Hamiltonian and Newtonian mechanics.\n\nA conservative mechanical system is described by a Hamiltonian $H(q, p)$, which is the total energy of the system, expressed as a function of generalized coordinates $q$ and momenta $p$. For the systems in question, the Hamiltonian is separable, of the form $H(q,p) = T(p) + V(q)$, where $T(p)$ is the kinetic energy and $V(q)$ is the potential energy. Given the mass $m=1$ in dimensionless units, the kinetic energy is $T(p) = \\frac{1}{2} p^\\top p$.\n\nThe time evolution of the system is governed by Hamilton's equations:\n$$\n\\frac{dq}{dt} = \\frac{\\partial H}{\\partial p}, \\quad \\frac{dp}{dt} = -\\frac{\\partial H}{\\partial q}\n$$\nSubstituting the given Hamiltonian, we obtain a system of first-order ordinary differential equations (ODEs):\n$$\n\\frac{dq}{dt} = \\frac{\\partial}{\\partial p} \\left(\\frac{1}{2} p^\\top p + V(q)\\right) = p\n$$\n$$\n\\frac{dp}{dt} = -\\frac{\\partial}{\\partial q} \\left(\\frac{1}{2} p^\\top p + V(q)\\right) = -\\nabla_q V(q)\n$$\nThe term $F(q) = -\\nabla_q V(q)$ is the force acting on the system. The equations of motion can be written as $\\dot{q} = p$ and $\\dot{p} = F(q)$. This is equivalent to Newton's second law, $m\\ddot{q} = F(q)$, since $\\ddot{q} = \\dot{p} = F(q)$ when $m=1$.\n\nWe will now discretize these continuous equations to derive the two specified numerical integrators.\n\n### Integrator Derivation\n\n**1. Fourth-Order Runge-Kutta (RK4) Method**\n\nThe RK4 method is a general-purpose solver for a first-order ODE of the form $\\dot{y} = f(t, y)$. Our system can be expressed in this form by defining a state vector $y(t) = (q(t), p(t))^\\top$. The function $f(y)$ is then:\n$f(y) = f(q,p) = (\\dot{q}, \\dot{p}) = (p, F(q))$.\nThe RK4 method advances the state from time $t_n$ to $t_{n+1} = t_n + h$ using a weighted average of four intermediate steps (slopes):\n$$\ny_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\nwhere $h$ is the time step, and the slopes $k_i$ are defined as:\n$$\n\\begin{aligned}\nk_1 &= f(y_n) = (p_n, F(q_n)) \\\\\nk_2 &= f\\left(y_n + \\frac{h}{2}k_1\\right) = f\\left(q_n + \\frac{h}{2}p_n, p_n + \\frac{h}{2}F(q_n)\\right) \\\\\nk_3 &= f\\left(y_n + \\frac{h}{2}k_2\\right) \\\\\nk_4 &= f(y_n + h k_3)\n\\end{aligned}\n$$\nBy evaluating $f$ at each intermediate point, we obtain the derivatives with respect to time for both $q$ and $p$. These are then combined in the final update step to calculate $(q_{n+1}, p_{n+1})$. RK4 is a high-order method (local error $\\mathcal{O}(h^5)$, global error $\\mathcal{O}(h^4)$) but it is not symplectic, meaning it does not exactly preserve the geometric structure of Hamiltonian flow. This typically leads to a systematic drift in the total energy over long simulations.\n\n**2. Velocity Verlet Method**\n\nThe velocity Verlet method is derived by discretizing Newton's second law, $\\ddot{q} = F(q)/m$. A Taylor series expansion for the position $q(t)$ around time $t_n$ gives:\n$$\nq(t_n+h) = q(t_n) + h \\dot{q}(t_n) + \\frac{h^2}{2} \\ddot{q}(t_n) + \\mathcal{O}(h^3)\n$$\nIn our notation, with mass $m=1$, this becomes the position update rule:\n$$\nq_{n+1} = q_n + h p_n + \\frac{h^2}{2} F(q_n)\n$$\nTo update the momentum, we consider the definition $\\dot{p} = F(q)$ and integrate it over one time step:\n$$\np_{n+1} - p_n = \\int_{t_n}^{t_{n+1}} F(q(t)) dt\n$$\nApproximating the integral using the trapezoidal rule, which offers second-order accuracy, we get:\n$$\n\\int_{t_n}^{t_{n+1}} F(q(t)) dt \\approx \\frac{h}{2} [F(q(t_n)) + F(q(t_{n+1}))]\n$$\nThis gives the momentum update rule:\n$$\np_{n+1} = p_n + \\frac{h}{2} [F(q_n) + F(q_{n+1})]\n$$\nNote that this update requires the force $F(q_{n+1})$ at the new position $q_{n+1}$, which we have already computed in the first step. The sequence of operations is therefore:\n1.  Update position $q_{n+1}$ using $p_n$ and $F(q_n)$.\n2.  Compute the new force $F(q_{n+1})$ using the new position.\n3.  Update momentum $p_{n+1}$ using an average of the old and new forces.\n\nThe velocity Verlet algorithm is a symplectic integrator. This property ensures that it has excellent long-term energy conservation, characterized by bounded fluctuations around the true energy rather than a systematic drift.\n\n### Potential Models and Forces\n\nThe force $F(q)$ is derived from the potential energy $V(q)$ as $F(q) = -\\nabla_q V(q)$.\n\n**1. Single-DOF Anharmonic Oscillator (Duffing-type)**\n- Potential: $V(q) = \\frac{1}{2} k q^2 + \\frac{1}{4} \\alpha q^4$\n- Force: $F(q) = -\\frac{dV}{dq} = -(k q + \\alpha q^3)$\n\n**2. Two-DOF Coupled Anharmonic Oscillator**\n- Potential: $V(q_1, q_2) = \\frac{1}{2} k_1 q_1^2 + \\frac{1}{2} k_2 q_2^2 + \\frac{1}{4} \\alpha (q_1^4 + q_2^4) + \\frac{1}{2} \\beta q_1^2 q_2^2$\n- Force Vector $F(q)=-\\nabla V(q) = (F_1, F_2)^\\top$:\n  - $F_1(q_1, q_2) = -\\frac{\\partial V}{\\partial q_1} = -(k_1 q_1 + \\alpha q_1^3 + \\beta q_1 q_2^2)$\n  - $F_2(q_1, q_2) = -\\frac{\\partial V}{\\partial q_2} = -(k_2 q_2 + \\alpha q_2^3 + \\beta q_1^2 q_2)$\n\n### Simulation and Analysis\n\nFor each test case, the system is initialized at $(q_0, p_0)$. The initial energy $H_0 = \\frac{1}{2} p_0^\\top p_0 + V(q_0)$ is calculated. Then, the system is evolved for $N$ steps using a time step of $h$, once with the RK4 integrator and once with the velocity Verlet integrator. After $N$ steps, the final energy $H_N = \\frac{1}{2} p_N^\\top p_N + V(q_N)$ is computed. The metric for comparison is the relative energy change, $\\Delta_{\\text{rel}} = (H_N - H_0) / H_0$. This value quantifies the energy conservation properties of each method over the duration of the simulation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run simulations and compare integrator energy conservation.\n    \"\"\"\n\n    # --- Potential and Force Functions ---\n    \n    # 1-DOF Duffing Oscillator\n    def potential_duffing(q, k, alpha):\n        # V(q) = 1/2 k q^2 + 1/4 alpha q^4\n        q_scalar = q[0]\n        return 0.5 * k * q_scalar**2 + 0.25 * alpha * q_scalar**4\n\n    def force_duffing(q, k, alpha):\n        # F(q) = -dV/dq = -(k q + alpha q^3)\n        return -(k * q + alpha * q**3)\n\n    # 2-DOF Coupled Oscillator\n    def potential_coupled(q, k1, k2, alpha, beta):\n        # V(q) = 1/2 k1 q1^2 + 1/2 k2 q2^2 + 1/4 alpha (q1^4 + q2^4) + 1/2 beta q1^2 q2^2\n        q1, q2 = q[0], q[1]\n        return (0.5 * k1 * q1**2 + 0.5 * k2 * q2**2 +\n                0.25 * alpha * (q1**4 + q2**4) + 0.5 * beta * q1**2 * q2**2)\n\n    def force_coupled(q, k1, k2, alpha, beta):\n        # F(q) = -grad(V)\n        q1, q2 = q[0], q[1]\n        F1 = -(k1 * q1 + alpha * q1**3 + beta * q1 * q2**2)\n        F2 = -(k2 * q2 + alpha * q2**3 + beta * q1**2 * q2)\n        return np.array([F1, F2])\n\n    \n    # --- Numerical Integrators ---\n\n    def rk4_step(q, p, h, force_func, f_params):\n        \"\"\"A single step of the RK4 integrator for a Hamiltonian system.\"\"\"\n        # dot(q) = p, dot(p) = F(q)\n\n        # k1\n        q_dot_1 = p\n        p_dot_1 = force_func(q, **f_params)\n\n        # k2\n        q_temp_2 = q + 0.5 * h * q_dot_1\n        p_temp_2 = p + 0.5 * h * p_dot_1\n        q_dot_2 = p_temp_2\n        p_dot_2 = force_func(q_temp_2, **f_params)\n\n        # k3\n        q_temp_3 = q + 0.5 * h * q_dot_2\n        p_temp_3 = p + 0.5 * h * p_dot_2\n        q_dot_3 = p_temp_3\n        p_dot_3 = force_func(q_temp_3, **f_params)\n\n        # k4\n        q_temp_4 = q + h * q_dot_3\n        p_temp_4 = p + h * p_dot_3\n        q_dot_4 = p_temp_4\n        p_dot_4 = force_func(q_temp_4, **f_params)\n\n        # Final update\n        q_next = q + (h / 6.0) * (q_dot_1 + 2.0 * q_dot_2 + 2.0 * q_dot_3 + q_dot_4)\n        p_next = p + (h / 6.0) * (p_dot_1 + 2.0 * p_dot_2 + 2.0 * p_dot_3 + p_dot_4)\n        \n        return q_next, p_next\n\n    def verlet_step(q, p, h, force_func, f_params):\n        \"\"\"A single step of the Velocity Verlet integrator.\"\"\"\n        # Using m=1, p=v\n        F_n = force_func(q, **f_params)\n        \n        # 1. Update position\n        q_next = q + h * p + 0.5 * h**2 * F_n\n        \n        # 2. Compute new force\n        F_n_plus_1 = force_func(q_next, **f_params)\n        \n        # 3. Update momentum (velocity)\n        p_next = p + 0.5 * h * (F_n + F_n_plus_1)\n        \n        return q_next, p_next\n\n    # --- Simulation Runner ---\n    \n    def run_simulation(integrator, q0, p0, h, N, pot_func, p_params, force_func, f_params):\n        \"\"\"Runs a simulation for N steps and returns relative energy error.\"\"\"\n        q, p = np.copy(q0), np.copy(p0)\n        \n        H0 = 0.5 * np.dot(p0, p0) + pot_func(q0, **p_params)\n        \n        for _ in range(N):\n            q, p = integrator(q, p, h, force_func, f_params)\n            \n        HN = 0.5 * np.dot(p, p) + pot_func(q, **p_params)\n        \n        # Avoid division by zero if initial energy is zero\n        if H0 == 0:\n            return HN # or some other indicator of this special case\n            \n        return (HN - H0) / H0\n\n    # --- Test Cases Definition ---\n    \n    test_cases = [\n        {\n            \"name\": \"Case 1: 1-DOF, h=0.1, N=50k\",\n            \"potential\": potential_duffing,\n            \"force\": force_duffing,\n            \"params\": {\"k\": 1.0, \"alpha\": 0.1},\n            \"q0\": np.array([1.0]),\n            \"p0\": np.array([0.0]),\n            \"h\": 0.1,\n            \"N\": 50000,\n        },\n        {\n            \"name\": \"Case 2: 1-DOF, h=0.01, N=60k\",\n            \"potential\": potential_duffing,\n            \"force\": force_duffing,\n            \"params\": {\"k\": 1.0, \"alpha\": 0.1},\n            \"q0\": np.array([1.0]),\n            \"p0\": np.array([0.0]),\n            \"h\": 0.01,\n            \"N\": 60000,\n        },\n        {\n            \"name\": \"Case 3: 2-DOF stiff-slow\",\n            \"potential\": potential_coupled,\n            \"force\": force_coupled,\n            \"params\": {\"k1\": 1.0, \"k2\": 25.0, \"alpha\": 0.05, \"beta\": 0.02},\n            \"q0\": np.array([1.0, 0.5]),\n            \"p0\": np.array([0.0, 0.0]),\n            \"h\": 0.02,\n            \"N\": 50000,\n        },\n    ]\n\n    # --- Main Loop ---\n    \n    all_results = []\n    for case in test_cases:\n        delta_rk4 = run_simulation(\n            rk4_step, case[\"q0\"], case[\"p0\"], case[\"h\"], case[\"N\"],\n            case[\"potential\"], case[\"params\"], case[\"force\"], case[\"params\"]\n        )\n        \n        delta_verlet = run_simulation(\n            verlet_step, case[\"q0\"], case[\"p0\"], case[\"h\"], case[\"N\"],\n            case[\"potential\"], case[\"params\"], case[\"force\"], case[\"params\"]\n        )\n        \n        all_results.append([round(delta_rk4, 6), round(delta_verlet, 6)])\n\n    # Format the final output string exactly as required.\n    string_results = [f\"[{r[0]},{r[1]}]\" for r in all_results]\n    print(f\"[{','.join(string_results)}]\")\n\nsolve()\n```"
        }
    ]
}