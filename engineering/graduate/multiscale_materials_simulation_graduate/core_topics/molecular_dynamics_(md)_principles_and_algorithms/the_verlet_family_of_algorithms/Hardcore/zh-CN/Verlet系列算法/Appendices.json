{
    "hands_on_practices": [
        {
            "introduction": "理论与实践的结合始于对基本机制的深刻理解。本练习旨在通过一个核心模型——简谐振子——来阐明速度Verlet算法的代数结构。通过推导单步更新矩阵，我们能以线性代数的形式精确地观察到算法如何将系统的相空间状态 $(x, v)$ 从一个时间步推进到下一个时间步，从而为后续更复杂的分析奠定坚实基础 。",
            "id": "3852924",
            "problem": "在多尺度材料模拟中，时间可逆和辛积分器（如 Verlet 族）被用来推进原子级和粗粒化动力学变量，同时控制守恒量的长期漂移。考虑一个被建模为谐振子的单一粗粒化模式，其质量为 $m$，刚度系数为 $k$，受牛顿第二定律 $m\\,\\ddot{x}(t)=-k\\,x(t)$ 控制。设离散时间步长为 $\\Delta t>0$，并定义力 $F(x)=-k\\,x$ 和加速度 $a(x)=F(x)/m$。\n\n从时刻 $t_n$ 的相空间状态 $(x_n,v_n)$ 出发，使用速度 Verlet 算法将系统推进一个步长，该算法定义为在一个大小为 $\\Delta t$ 的步长上应用的以下序列：\n- 位置更新：$x_{n+1}=x_n+\\Delta t\\,v_n+\\tfrac{1}{2}(\\Delta t)^2\\,a(x_n)$，\n- 加速度刷新：$a(x_{n+1})=a(x)$ 在 $x=x_{n+1}$ 处求值，\n- 速度更新：$v_{n+1}=v_n+\\tfrac{1}{2}\\Delta t\\left[a(x_n)+a(x_{n+1})\\right]$。\n\n仅使用上述定义和牛顿第二定律，推导用 $x_n$、$v_n$、$m$、$k$ 和 $\\Delta t$ 表示的 $x_{n+1}$ 和 $v_{n+1}$ 的显式闭式表达式。然后将它们整合为一个线性映射，写成一个 $2\\times 2$ 矩阵 $A(\\Delta t)$，使得\n$$\n\\begin{pmatrix}\nx_{n+1}\\\\\nv_{n+1}\n\\end{pmatrix}\n=A(\\Delta t)\n\\begin{pmatrix}\nx_n\\\\\nv_n\n\\end{pmatrix}.\n$$\n用固有频率 $\\omega=\\sqrt{k/m}$ 和 $\\Delta t$ 表示您的最终矩阵，并尽可能简化。仅提供矩阵 $A(\\Delta t)$ 作为最终答案。不需要进行数值计算，也无需四舍五入。",
            "solution": "问题陈述经评估具有科学依据、提法恰当且客观。它为应用于谐振子的速度 Verlet 算法提供了一套完整且一致的定义，并要求得出一个具体、可推导的结果。所有必要信息均已提供，该任务是计算物理学中的一个标准练习。因此，该问题是有效的，并将推导出一个解。\n\n目标是找到表示应用于简谐振子的速度 Verlet 算法的单步传播矩阵的 $2 \\times 2$ 矩阵 $A(\\Delta t)$。第 $n$ 步的状态向量由 $\\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}$ 给出。更新后的状态向量为 $\\begin{pmatrix} x_{n+1} \\\\ v_{n+1} \\end{pmatrix} = A(\\Delta t) \\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}$。\n\n谐振子的运动控制方程是牛顿第二定律：\n$$m\\,\\ddot{x}(t) = -k\\,x(t)$$\n力为 $F(x) = -k\\,x$，加速度为 $a(x) = F(x)/m = -k\\,x/m$。\n我们定义振子的固有频率为 $\\omega = \\sqrt{k/m}$，因此加速度可以写成：\n$$a(x) = -\\omega^2 x$$\n这意味着在时刻 $t_n$ 和 $t_{n+1}$ 的加速度分别为 $a(x_n) = a_n = -\\omega^2 x_n$ 和 $a(x_{n+1}) = a_{n+1} = -\\omega^2 x_{n+1}$。\n\n速度 Verlet 算法由以下更新序列定义：\n1.  位置更新：$x_{n+1} = x_n + \\Delta t\\,v_n + \\frac{1}{2}(\\Delta t)^2\\,a_n$\n2.  速度更新：$v_{n+1} = v_n + \\frac{1}{2}\\Delta t\\left[a_n + a_{n+1}\\right]$\n\n我们现在将推导用 $x_n$ 和 $v_n$ 表示的 $x_{n+1}$ 和 $v_{n+1}$ 的显式表达式。\n\n首先，我们求 $x_{n+1}$ 的表达式。我们将 $a_n = -\\omega^2 x_n$ 代入位置更新方程：\n$$x_{n+1} = x_n + \\Delta t\\,v_n + \\frac{1}{2}(\\Delta t)^2 (-\\omega^2 x_n)$$\n按 $x_n$ 和 $v_n$ 的项进行分组：\n$$x_{n+1} = \\left(1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\\right) x_n + (\\Delta t) v_n$$\n这个方程给出了矩阵 $A(\\Delta t)$ 的第一行。其分量为：\n$$A_{11} = 1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2$$\n$$A_{12} = \\Delta t$$\n\n接下来，我们求 $v_{n+1}$ 的表达式。我们将加速度的表达式 $a_n = -\\omega^2 x_n$ 和 $a_{n+1} = -\\omega^2 x_{n+1}$ 代入速度更新方程：\n$$v_{n+1} = v_n + \\frac{1}{2}\\Delta t\\left[-\\omega^2 x_n - \\omega^2 x_{n+1}\\right]$$\n$$v_{n+1} = v_n - \\frac{1}{2}\\omega^2 \\Delta t (x_n + x_{n+1})$$\n这个 $v_{n+1}$ 的表达式目前依赖于 $x_{n+1}$。为了获得一个仅用时刻 $t_n$ 的状态 $(x_n, v_n)$ 表示的表达式，我们必须代入先前推导出的 $x_{n+1}$ 的表达式：\n$$v_{n+1} = v_n - \\frac{1}{2}\\omega^2 \\Delta t \\left[ x_n + \\left( \\left(1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\\right) x_n + (\\Delta t) v_n \\right) \\right]$$\n现在，我们简化方括号中的项：\n$$x_n + \\left(1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\\right) x_n + (\\Delta t) v_n = \\left(2 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\\right) x_n + (\\Delta t) v_n$$\n将此代回 $v_{n+1}$ 的方程中：\n$$v_{n+1} = v_n - \\frac{1}{2}\\omega^2 \\Delta t \\left[ \\left(2 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\\right) x_n + (\\Delta t) v_n \\right]$$\n将项 $-\\frac{1}{2}\\omega^2 \\Delta t$ 分配到括号中：\n$$v_{n+1} = v_n - \\left( \\frac{1}{2}\\omega^2 \\Delta t \\cdot 2 - \\frac{1}{2}\\omega^2 \\Delta t \\cdot \\frac{1}{2}\\omega^2 (\\Delta t)^2 \\right) x_n - \\left( \\frac{1}{2}\\omega^2 \\Delta t \\cdot \\Delta t \\right) v_n$$\n$$v_{n+1} = v_n - \\left( \\omega^2 \\Delta t - \\frac{1}{4}\\omega^4 (\\Delta t)^3 \\right) x_n - \\frac{1}{2}\\omega^2 (\\Delta t)^2 v_n$$\n最后，我们按 $x_n$ 和 $v_n$ 的项进行分组：\n$$v_{n+1} = \\left( -\\omega^2 \\Delta t + \\frac{1}{4}\\omega^4 (\\Delta t)^3 \\right) x_n + \\left( 1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2 \\right) v_n$$\n这个方程给出了矩阵 $A(\\Delta t)$ 的第二行。其分量为：\n$$A_{21} = -\\omega^2 \\Delta t + \\frac{1}{4}\\omega^4 (\\Delta t)^3 = -\\omega^2 \\Delta t \\left(1 - \\frac{1}{4}\\omega^2 (\\Delta t)^2\\right)$$\n$$A_{22} = 1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2$$\n通过提出因子 $-\\omega^2 \\Delta t$，可以简化 $A_{21}$ 的表达式。\n\n结合这些结果，线性映射为：\n$$\n\\begin{pmatrix}\nx_{n+1}\\\\\nv_{n+1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2  \\Delta t \\\\\n-\\omega^2 \\Delta t \\left(1 - \\frac{1}{4}\\omega^2 (\\Delta t)^2\\right)  1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\n\\end{pmatrix}\n\\begin{pmatrix}\nx_n\\\\\nv_n\n\\end{pmatrix}\n$$\n因此，矩阵 $A(\\Delta t)$ 是：\n$$\nA(\\Delta t) =\n\\begin{pmatrix}\n1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2  \\Delta t \\\\\n-\\omega^2 \\Delta t \\left(1 - \\frac{1}{4}\\omega^2 (\\Delta t)^2\\right)  1 - \\frac{1}{2}\\omega^2 (\\Delta t)^2\n\\end{pmatrix}\n$$\n这是用 $\\omega$ 和 $\\Delta t$ 表示的矩阵的最终简化形式。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 - \\frac{1}{2}\\omega^{2} (\\Delta t)^{2}  \\Delta t \\\\\n-\\omega^{2} \\Delta t \\left(1 - \\frac{1}{4}\\omega^{2} (\\Delta t)^{2}\\right)  1 - \\frac{1}{2}\\omega^{2} (\\Delta t)^{2}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在长时间尺度模拟中，一个积分算法的保真度至关重要。Verlet算法家族虽然在能量守恒方面表现优异，但它们并非完美无瑕；它们会引入微小的、系统性的误差。本练习深入探讨了其中一种最关键的误差——相位误差，通过对Störmer-Verlet方法的分析，您将量化数值振荡频率与真实频率之间的微小偏差 。理解这种误差的来源及其对时间步长的依赖关系，对于评估和选择多尺度模拟中的积分方案至关重要。",
            "id": "3852926",
            "problem": "在多尺度材料模拟中，通常使用Verlet族中的辛格式来对各个晶格振动模式进行积分。考虑一个晶体固体的简正模式，其被线性化为遵循 $m\\,\\ddot{x}(t) = -k\\,x(t)$ 的谐振子，角频率为 $\\omega = \\sqrt{k/m}$。将时间步长为 $\\Delta t$ 的 Störmer–Verlet（也称为位置Verlet）方法的位置更新应用于此模式，得到中心差分递推关系\n$$\nx_{n+1} - 2\\,x_{n} + x_{n-1} \\;=\\; -\\,\\omega^{2}\\,(\\Delta t)^{2}\\,x_{n},\n$$\n其中 $x_{n} \\equiv x(n\\,\\Delta t)$。将每步的数值相移定义为 $\\theta$，因此对于稳定的 $\\Delta t$，数值解随步数推进的形式为 $x_{n} \\propto \\exp(i\\,n\\,\\theta)$。\n\n仅从牛顿第二定律 $v = dx/dt$ 和上述Störmer–Verlet递推关系中隐含的中心差分格式出发，推导数值相移 $\\theta$ 在小 $\\Delta t$ 情况下的渐近展开式，并用它来计算经过一个真实周期 $T = \\frac{2\\pi}{\\omega}$ 后累积的相位误差。这里的“每周期相位误差”指的是在周期 $T$ 内的数值相移与精确值 $2\\pi$ 之间的差值（以弧度为单位）。\n\n请将您的最终答案表示为每周期相位误差关于 $\\Delta t$ 的首阶项，以弧度为单位，形式为一个包含 $\\omega$ 和 $\\Delta t$ 的闭合解析表达式。不要包含高阶项。最终答案必须是单个表达式。角度单位必须是弧度。",
            "solution": "首先验证问题，以确保其是适定的、科学上合理的且内部一致的。\n\n### 第一步：提取已知条件\n- 线性化谐振子的运动方程：$m\\,\\ddot{x}(t) = -k\\,x(t)$。\n- 角频率：$\\omega = \\sqrt{k/m}$。\n- Störmer–Verlet中心差分递推关系：$x_{n+1} - 2\\,x_{n} + x_{n-1} = -\\,\\omega^{2}\\,(\\Delta t)^{2}\\,x_{n}$，其中 $x_{n} \\equiv x(n\\,\\Delta t)$。\n- 数值解的形式：$x_{n} \\propto \\exp(i\\,n\\,\\theta)$，其中 $\\theta$ 是每步的数值相移。\n- 真实周期的定义：$T = \\frac{2\\pi}{\\omega}$。\n- 每周期相位误差的定义：在一个周期 $T$ 内的总数值相移与精确相移 $2\\pi$ 之间的差值。\n- 要求答案：每周期相位误差的渐近展开（针对小 $\\Delta t$）的首阶项。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学基础**：该问题描述了将 Störmer–Verlet 方法应用于简谐振子，这是计算物理和数值分析中的一个标准和基础课题。所提供的递推关系是正确的有限差分表示。数值相位误差的概念是积分算法分析的核心。该问题在科学上是严谨的。\n- **适定性**：该问题是适定的。它提供了一个明确的起点（递推关系）和一个精确定义的目标（每周期的首阶相位误差）。所有必要的定义和变量都已给出，且该任务导向一个唯一、有意义的解析表达式。\n- **客观性**：该问题以客观、正式的语言陈述，不含任何主观或非科学内容。\n\n### 第三步：结论与行动\n问题有效。将推导一个完整的解。\n\n### 解的推导\n分析始于所给出的谐振子的Störmer–Verlet递推关系：\n$$x_{n+1} - 2\\,x_{n} + x_{n-1} = -\\,\\omega^{2}\\,(\\Delta t)^{2}\\,x_{n}$$\n我们已知数值解的形式为 $x_{n} = A \\exp(i n \\theta)$，其中 $A$ 为某个常数振幅，$\\theta$ 为每步的数值相移。将此试探解代入递推关系得到：\n$$A \\exp(i (n+1) \\theta) - 2 A \\exp(i n \\theta) + A \\exp(i (n-1) \\theta) = -\\omega^{2}(\\Delta t)^{2} A \\exp(i n \\theta)$$\n假设存在非平凡解（$A \\neq 0$），我们可以将整个方程除以 $A \\exp(i n \\theta)$：\n$$\\exp(i \\theta) - 2 + \\exp(-i \\theta) = -\\omega^{2}(\\Delta t)^{2}$$\n使用欧拉公式 $\\exp(i\\theta) + \\exp(-i\\theta) = 2\\cos(\\theta)$，左侧简化为：\n$$2\\cos(\\theta) - 2 = -\\omega^{2}(\\Delta t)^{2}$$\n这个方程给出了数值相移 $\\theta$ 与物理参数 $\\omega$ 和 $\\Delta t$ 之间的精确关系。我们可以使用三角恒等式 $1 - \\cos(\\theta) = 2\\sin^{2}(\\theta/2)$ 对其进行变换：\n$$-2(1 - \\cos(\\theta)) = -\\omega^{2}(\\Delta t)^{2}$$\n$$-2(2\\sin^{2}(\\theta/2)) = -\\omega^{2}(\\Delta t)^{2}$$\n$$4\\sin^{2}(\\theta/2) = (\\omega \\Delta t)^{2}$$\n对两边取平方根得到：\n$$2|\\sin(\\theta/2)| = |\\omega \\Delta t|$$\n对于小的时间步长 $\\Delta t$，相移 $\\theta$ 也是小的正数，因此 $\\sin(\\theta/2) > 0$。我们假设 $\\omega > 0$ 且 $\\Delta t > 0$。因此，我们有：\n$$\\sin(\\frac{\\theta}{2}) = \\frac{\\omega \\Delta t}{2}$$\n这个方程隐式地定义了 $\\theta$。为了求得相位误差，我们需要一个关于 $\\Delta t$ 幂次的 $\\theta$ 的显式展开式。我们可以通过求解 $\\theta$ 并使用反正弦函数的泰勒级数来找到这个展开式。\n$$\\frac{\\theta}{2} = \\arcsin\\left(\\frac{\\omega \\Delta t}{2}\\right)$$\n$\\arcsin(u)$ 在 $u=0$ 附近的泰勒级数为：\n$$\\arcsin(u) = u + \\frac{u^{3}}{6} + \\frac{3u^{5}}{40} + O(u^{7})$$\n令 $u = \\frac{\\omega \\Delta t}{2}$，我们得到 $\\theta$ 的展开式：\n$$\\theta = 2 \\arcsin\\left(\\frac{\\omega \\Delta t}{2}\\right) = 2 \\left[ \\left(\\frac{\\omega \\Delta t}{2}\\right) + \\frac{1}{6}\\left(\\frac{\\omega \\Delta t}{2}\\right)^{3} + O\\left((\\Delta t)^{5}\\right) \\right]$$\n$$\\theta = \\omega \\Delta t + 2 \\cdot \\frac{1}{6} \\frac{(\\omega \\Delta t)^{3}}{8} + O\\left((\\Delta t)^{5}\\right)$$\n$$\\theta = \\omega \\Delta t + \\frac{(\\omega \\Delta t)^{3}}{24} + O\\left((\\Delta t)^{5}\\right)$$\n这是每步数值相移的渐近展开式。首项 $\\omega \\Delta t$ 是每步的精确相移。\n\n接下来，我们计算在一个真实周期 $T = \\frac{2\\pi}{\\omega}$ 内累积的总相位。这个周期内的时间步数 $N$ 为：\n$$N = \\frac{T}{\\Delta t} = \\frac{2\\pi}{\\omega \\Delta t}$$\n在 $N$ 步后累积的总数值相位 $\\Phi_{\\text{num}}$ 为：\n$$\\Phi_{\\text{num}} = N \\theta = \\left(\\frac{2\\pi}{\\omega \\Delta t}\\right) \\left[ \\omega \\Delta t + \\frac{(\\omega \\Delta t)^{3}}{24} + O\\left((\\Delta t)^{5}\\right) \\right]$$\n将因子 $\\frac{2\\pi}{\\omega \\Delta t}$ 分配进去：\n$$\\Phi_{\\text{num}} = 2\\pi + \\frac{2\\pi}{\\omega \\Delta t} \\frac{(\\omega \\Delta t)^{3}}{24} + O\\left((\\Delta t)^{4}\\right)$$\n$$\\Phi_{\\text{num}} = 2\\pi + \\frac{2\\pi(\\omega \\Delta t)^{2}}{24} + O\\left((\\Delta t)^{4}\\right)$$\n$$\\Phi_{\\text{num}} = 2\\pi + \\frac{\\pi (\\omega \\Delta t)^{2}}{12} + O\\left((\\Delta t)^{4}\\right)$$\n一个周期内的精确相移为 $\\Phi_{\\text{exact}} = \\omega T = 2\\pi$。每周期相位误差 $\\Delta\\Phi$ 是差值 $\\Phi_{\\text{num}} - \\Phi_{\\text{exact}}$：\n$$\\Delta\\Phi = \\left[ 2\\pi + \\frac{\\pi (\\omega \\Delta t)^{2}}{12} + O\\left((\\Delta t)^{4}\\right) \\right] - 2\\pi$$\n$$\\Delta\\Phi = \\frac{\\pi (\\omega \\Delta t)^{2}}{12} + O\\left((\\Delta t)^{4}\\right)$$\n问题要求的是每周期相位误差的首阶项。这是展开式中的第一项。\n每周期的首阶相位误差为 $\\frac{\\pi}{12}(\\omega \\Delta t)^{2}$。这表明数值频率略小于真实频率，导致一个与 $\\omega \\Delta t$ 平方成正比增长的相位滞后。",
            "answer": "$$\\boxed{\\frac{\\pi}{12}(\\omega \\Delta t)^{2}}$$"
        },
        {
            "introduction": "Verlet算法的卓越稳定性源于其深刻的几何性质，其中最引人注目的是时间可逆性。这个性质确保了算法在时间上向前和向后演化时遵循相同的规则，这是其作为辛积分器的一个关键特征。本练习将理论付诸于计算实践：您将通过编写代码来模拟一个非线性摆，并数值验证算法的时间可逆性 。通过将模拟向前推进，然后反转速度并向后演化，您将亲眼见证算法如何精确地“撤销”自身的轨迹，除了微小的浮点舍入误差外，最终完美地回到初始状态。",
            "id": "2420944",
            "problem": "您的任务是研究无阻尼非线性单摆，其角位移 $\\theta(t)$ 由二阶常微分方程 $\\ddot{\\theta}(t) + \\dfrac{g}{L}\\sin(\\theta(t)) = 0$ 控制，其中 $g$ 是重力加速度，$L$ 是摆长。角度必须以弧度表示，时间以秒表示，角速度 $\\dot{\\theta}$ 以弧度/秒表示。任务是通过以下方式演示一个辛的二阶更新方案的时间可逆性：将系统从一个初始状态开始，在时间上正向演化固定的步数，然后再反向演化以返回初始状态，并量化这次正向再反向演化后与初始状态的偏差。\n\n定义如下：\n- 状态为 $(\\theta,\\dot{\\theta})$，其中 $\\theta \\in \\mathbb{R}$ 且 $\\dot{\\theta} \\in \\mathbb{R}$。\n- 角加速度函数为 $a(\\theta) = -\\dfrac{g}{L}\\sin(\\theta)$。\n- 正向演化包含 $N$ 个大小为 $\\Delta t$ 的离散时间步，其中 $N$ 是一个正整数，$T = N\\,\\Delta t$ 是总模拟时间。\n- 反向演化包含 $N$ 个步长，这些步长在时间反演对称的意义上精确地逆转正向演化：从正向演化的终点状态 $(\\theta_T,\\dot{\\theta}_T)$ 开始，将速度反转为 $-\\dot{\\theta}_T$，然后应用相同的 $N$ 个步长，最后再次反转速度，以便与初始状态 $(\\theta_0,\\dot{\\theta}_0)$ 进行比较。\n\n使用如下定义的无量纲误差来衡量最终偏差。设 $\\omega_0 = \\sqrt{g/L}$ 为小角度固有频率。设 $\\Delta \\theta$ 为恢复的角度与初始角度之间的主值角差，必要时通过加上 $2\\pi$ 的整数倍将其归约到 $(-\\pi,\\pi]$ 区间。设 $\\Delta \\dot{\\theta}$ 为恢复的角速度与初始角速度之差。定义无量纲误差\n$$\nE = \\sqrt{(\\Delta \\theta)^2 + \\left(\\dfrac{\\Delta \\dot{\\theta}}{\\omega_0}\\right)^2}.\n$$\n角度单位为弧度，角速度单位为弧度/秒，$\\omega_0$ 单位为弧度/秒，因此 $E$ 是无量纲的。您的程序必须为下面列出的每个测试用例计算 $E$。\n\n测试套件。对每个测试用例，使用指定的参数 $(g, L, \\theta_0, \\dot{\\theta}_0, T, \\Delta t)$，所有参数均采用国际单位制 (SI)，角度以弧度表示。对每个测试，$T/\\Delta t$ 均为整数。\n- 测试 1 (小角度，典型步长)：$g = 9.81\\ \\mathrm{m/s^2}$，$L = 1.0\\ \\mathrm{m}$，$\\theta_0 = 0.2\\ \\mathrm{rad}$，$\\dot{\\theta}_0 = 0.0\\ \\mathrm{rad/s}$，$T = 10.0\\ \\mathrm{s}$，$\\Delta t = 0.005\\ \\mathrm{s}$。\n- 测试 2 (接近垂直位置的大角度，精细步长)：$g = 9.81\\ \\mathrm{m/s^2}$，$L = 1.0\\ \\mathrm{m}$，$\\theta_0 = 2.9\\ \\mathrm{rad}$，$\\dot{\\theta}_0 = 0.0\\ \\mathrm{rad/s}$，$T = 10.0\\ \\mathrm{s}$，$\\Delta t = 0.001\\ \\mathrm{s}$。\n- 测试 3 (非零初速度)：$g = 9.81\\ \\mathrm{m/s^2}$，$L = 0.7\\ \\mathrm{m}$，$\\theta_0 = 0.0\\ \\mathrm{rad}$，$\\dot{\\theta}_0 = 1.5\\ \\mathrm{rad/s}$，$T = 12.0\\ \\mathrm{s}$，$\\Delta t = 0.002\\ \\mathrm{s}$。\n- 测试 4 (接近线性稳定性边界的粗略步长)：$g = 9.81\\ \\mathrm{m/s^2}$，$L = 2.0\\ \\mathrm{m}$，$\\theta_0 = 0.01\\ \\mathrm{rad}$，$\\dot{\\theta}_0 = 0.0\\ \\mathrm{rad/s}$，$T = 18.0\\ \\mathrm{s}$，$\\Delta t = 0.9\\ \\mathrm{s}$。\n\n您的程序必须：\n- 实现所述的无阻尼非线性单摆动力学。\n- 对每个测试执行：进行 $N = T/\\Delta t$ 步的正向演化，然后进行如上所述的反向演化，最后计算上面定义的无量纲误差 $E$。\n- 将结果汇总为单行输出，其中包含按上述顺序排列的测试误差列表，四舍五入到 $12$ 位有效数字，并以科学记数法的十进制数形式打印。\n\n最终输出格式。您的程序应生成一行包含结果的输出，格式为方括号内以逗号分隔的列表，例如 `\"[e_1,e_2,e_3,e_4]\"`，其中每个 $e_k$ 是测试 $k$ 的无量纲误差，如上定义，并格式化为具有 $12$ 位有效数字的科学记数法。",
            "solution": "问题陈述是有效的。它描述了计算物理学中一个适定的数值实验，该实验基于经典力学和数值分析的标准原理。\n\n所考虑的物理系统是简单的非线性单摆，其运动由以下二阶常微分方程控制：\n$$\n\\ddot{\\theta}(t) + \\frac{g}{L}\\sin(\\theta(t)) = 0\n$$\n其中 $\\theta(t)$ 是角位移，$g$ 是重力加速度，$L$ 是摆的长度。通过定义状态向量 $(\\theta, \\dot{\\theta})$，该方程可以写成一个一阶方程组：\n$$\n\\begin{cases}\n\\frac{d\\theta}{dt} = \\dot{\\theta} \\\\\n\\frac{d\\dot{\\theta}}{dt} = -\\frac{g}{L}\\sin(\\theta)\n\\end{cases}\n$$\n该系统描述了二维相空间中的运动。它是一个哈密顿系统，意味着其动力学过程会守恒一个量，即比能（单位质量的能量），由 $E = \\frac{1}{2}L^2\\dot{\\theta}^2 - gL\\cos(\\theta)$ 给出。用于积分此类系统的数值方法理想情况下应保持相空间中流的几何特性。辛积分器就是为此目的设计的。它们不一定精确守恒能量，但它们确实守恒一个附近的“影子”哈密顿量，这可以防止能量的长期漂移并确保相空间体积的保持。许多辛积分器的一个关键特性是时间可逆性。如果一个算法从状态 $(\\theta_n, \\dot{\\theta}_n)$ 向前演化一个时间步到 $(\\theta_{n+1}, \\dot{\\theta}_{n+1})$，然后从一个时间反转的状态 $(\\theta_{n+1}, -\\dot{\\theta}_{n+1})$ 向前演化一个时间步，得到状态 $(\\theta_n, -\\dot{\\theta}_n)$，那么该算法就是时间可逆的。\n\n问题要求使用一个二阶的辛更新方案。速度Verlet算法是一个标准且合适的选择。它是Verlet积分族的一员，以其在应用于形式为 $\\ddot{\\mathbf{q}} = \\mathbf{F}(\\mathbf{q})$ 的哈密顿系统时所表现出的良好稳定性和辛性质而闻名。对于我们的摆系统，其状态为 $(\\theta, \\dot{\\theta})$，加速度为 $a(\\theta) = -\\frac{g}{L}\\sin(\\theta)$，从时间 $t_n$到 $t_{n+1} = t_n + \\Delta t$ 的单个积分步按以下方式进行：\n$1$. 首先，计算时间间隔中点的速度：\n$$\n\\dot{\\theta}_{n+1/2} = \\dot{\\theta}_n + a(\\theta_n) \\frac{\\Delta t}{2}\n$$\n$2$. 接下来，使用此中点速度更新位置：\n$$\n\\theta_{n+1} = \\theta_n + \\dot{\\theta}_{n+1/2} \\, \\Delta t\n$$\n$3$. 最后，使用新位置 $\\theta_{n+1}$ 将速度更新到时间间隔的末端：\n$$\n\\dot{\\theta}_{n+1} = \\dot{\\theta}_{n+1/2} + a(\\theta_{n+1}) \\frac{\\Delta t}{2}\n$$\n该算法是显式时间可逆的，并且在 $\\Delta t$ 上具有二阶精度。\n\n为演示数值模拟的时间可逆性，对每个测试用例实施以下过程：\n$1$. **正向演化：** 系统从初始状态 $(\\theta_0, \\dot{\\theta}_0)$ 开始，使用 $N = T/\\Delta t$ 步的速度Verlet算法演化总时间 $T$。这会产生最终状态 $(\\theta_T, \\dot{\\theta}_T)$。\n$2$. **反向演化：** 为了逆转过程，我们从状态 $(\\theta_T, -\\dot{\\theta}_T)$ 开始——注意速度的反转。然后我们应用相同的速度Verlet算法再进行 $N$ 步。这会产生一个状态 $(\\theta'_{\\text{rec}}, \\dot{\\theta}'_{\\text{rec}})$。\n$3$. **最终状态恢复：** 再次反转最终速度以获得恢复的状态 $(\\theta_{\\text{rec}}, \\dot{\\theta}_{\\text{rec}}) = (\\theta'_{\\text{rec}}, -\\dot{\\theta}'_{\\text{rec}})$。在精确算术中，由于算法的时间可逆性，我们应该有 $(\\theta_{\\text{rec}}, \\dot{\\theta}_{\\text{rec}}) = (\\theta_0, \\dot{\\theta}_0)$。在实践中，浮点舍入误差会导致微小的偏差。\n\n偏差由无量纲误差 $E$ 量化：\n$$\nE = \\sqrt{(\\Delta \\theta)^2 + \\left(\\frac{\\Delta \\dot{\\theta}}{\\omega_0}\\right)^2}\n$$\n其中 $\\omega_0 = \\sqrt{g/L}$ 是小角度振荡的固有频率。差值为 $\\Delta \\dot{\\theta} = \\dot{\\theta}_{\\text{rec}} - \\dot{\\theta}_0$ 和 $\\Delta \\theta$，后者是主值角差，计算方式为 $\\Delta\\theta_{\\text{raw}} = \\theta_{\\text{rec}} - \\theta_0$，然后映射到区间 $(-\\pi, \\pi]$。这可以通过使用双参数反正切函数进行稳健计算：$\\Delta\\theta = \\text{atan2}(\\sin(\\Delta\\theta_{\\text{raw}}), \\cos(\\Delta\\theta_{\\text{raw}}))$。\n\n实现为每个提供的测试用例精确地遵循了这些步骤。所得误差 $E$ 是累积浮点不精确度的度量，预计该值会很小，从而证实了辛积分器卓越的数值稳定性和可逆性。最终的程序实现了这一完整过程。对于每个测试用例，它设置参数，运行正向然后反向的模拟，计算误差，并按规定格式化结果。创建了一个实现速度Verlet步骤的函数。对每个测试用例调用两次：一次用于正向演化，一次用于反向演化。所有测试用例的计算误差被收集并以所需格式打印。所获得的数值应该非常小，证实了与完美时间反演的偏差在机器精度量级，这符合正确实现的时间可逆算法的预期。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the time-reversibility error for the nonlinear pendulum simulation\n    using a symplectic Velocity Verlet integrator.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (g, L, theta_0, v_theta_0, T, dt)\n        # Test 1\n        (9.81, 1.0, 0.2, 0.0, 10.0, 0.005),\n        # Test 2\n        (9.81, 1.0, 2.9, 0.0, 10.0, 0.001),\n        # Test 3\n        (9.81, 0.7, 0.0, 1.5, 12.0, 0.002),\n        # Test 4\n        (9.81, 2.0, 0.01, 0.0, 18.0, 0.9),\n    ]\n\n    results = []\n\n    def run_simulation(theta_init, v_theta_init, g, L, dt, N):\n        \"\"\"\n        Evolves the pendulum state for N steps using the Velocity Verlet algorithm.\n        \n        Args:\n            theta_init (float): Initial angle in radians.\n            v_theta_init (float): Initial angular velocity in rad/s.\n            g (float): Gravitational acceleration in m/s^2.\n            L (float): Pendulum length in m.\n            dt (float): Time step in s.\n            N (int): Number of steps.\n\n        Returns:\n            tuple[float, float]: Final angle and angular velocity.\n        \"\"\"\n        theta = theta_init\n        v_theta = v_theta_init\n        accel_factor = -g / L\n\n        for _ in range(N):\n            # Velocity Verlet half-step for velocity\n            v_theta_half = v_theta + 0.5 * dt * accel_factor * np.sin(theta)\n            # Full-step for position\n            theta = theta + dt * v_theta_half\n            # Second half-step for velocity, using the updated position\n            v_theta = v_theta_half + 0.5 * dt * accel_factor * np.sin(theta)\n        \n        return theta, v_theta\n\n    for case in test_cases:\n        g, L, theta_0, v_theta_0, T, dt = case\n        \n        # Number of steps. The problem guarantees T/dt is an integer.\n        N = int(round(T / dt))\n\n        # 1. Forward evolution from initial state (theta_0, v_theta_0)\n        theta_T, v_theta_T = run_simulation(theta_0, v_theta_0, g, L, dt, N)\n\n        # 2. Backward evolution\n        # Initial state for backward run: reverse velocity at the end of forward run\n        theta_B0 = theta_T\n        v_theta_B0 = -v_theta_T\n        \n        # Evolve \"forward\" in time from this new state\n        theta_rec_raw, v_theta_rec_raw = run_simulation(theta_B0, v_theta_B0, g, L, dt, N)\n        \n        # The true recovered state is obtained by re-reversing the final velocity\n        theta_rec = theta_rec_raw\n        v_theta_rec = -v_theta_rec_raw\n\n        # 3. Calculate dimensionless error E\n        omega_0 = np.sqrt(g / L)\n        \n        # Calculate deviation from initial state\n        delta_v_theta = v_theta_rec - v_theta_0\n        \n        # Calculate raw angular difference. Angle can wrap around many times.\n        delta_theta_raw = theta_rec - theta_0\n        \n        # Normalize angular difference to the principal-value interval (-pi, pi]\n        delta_theta = np.arctan2(np.sin(delta_theta_raw), np.cos(delta_theta_raw))\n        \n        # Calculate dimensionless error\n        E = np.sqrt(delta_theta**2 + (delta_v_theta / omega_0)**2)\n        results.append(E)\n\n    # Format output as specified: a list of errors in scientific notation with 12 significant digits.\n    # The format specifier {:.11e} gives 1 digit before the decimal and 11 after,\n    # totaling 12 significant digits for a normalized scientific number.\n    formatted_results = [\"{:.11e}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}