{
    "hands_on_practices": [
        {
            "introduction": "理解幽灵力的最好方法是在最简单的情景中亲眼见证它的出现。这个练习提供了一个基础性的、可解析的反例，让你能够精确计算出幽灵力。我们将看到，在一个一维原子链中，一个看似完美的均匀变形，仅仅因为在原子-连续介质界面上切断了一个化学键，就会在界面原子上产生一个非零的力，从而揭示问题的根源。",
            "id": "3812134",
            "problem": "考虑一个无限长的一维原子链，其参考晶格间距为 $a>0$，原子由索引 $i\\in\\mathbb{Z}$ 标记。每对最近邻原子 $(i,i+1)$ 通过一个刚度为 $k>0$、静止长度为 $a$ 的谐振子弹簧相互作用。对于一个形变后位置为 $y_i$ 的构型，其总原子势能为\n$$\n\\mathcal{E}_{\\mathrm{atom}}(y)=\\sum_{i\\in\\mathbb{Z}}\\frac{k}{2}\\left(\\left(y_{i+1}-y_i\\right)-a\\right)^{2}.\n$$\n在一个模拟突变界面的朴素原子-连续介质耦合构造中，假设所有跨越原子 $i=0$ 和 $i=1$ 之间界面的键都被删除（即最近邻键 $(0,1)$ 被移除），而所有其他键保持不变。不存在外力。采用准静态设置，使得力可以从势能相对于位置的梯度导出。\n\n现在，对于一个固定的微小应变 $\\epsilon\\in\\mathbb{R}$，施加一个均匀的仿射位移场 $u_i=\\epsilon\\, i\\, a$，因此形变后的构型为 $y_i=x_i+u_i=(1+\\epsilon)\\,i\\,a$，其中 $x_i=i\\,a$ 是参考位置。将内部节点力 $f_i(y)$ 定义为总能量相对于 $y_i$ 的负梯度。\n\n仅使用上述定义和标准力学原理（力是能量的负梯度；谐振子弹簧的胡克定律），明确地构造这个反例，并计算由切断的键导致的界面节点 $i=0$ 处的精确残余内力。使用正向力作用于正晶格方向（从较小的 $i$ 指向较大的 $i$）的惯例来指明力的符号。将您的最终答案表示为一个关于 $k$、$a$ 和 $\\epsilon$ 的闭式符号表达式。如果要指定单位，$k$ 的单位取牛顿/米 (N/m)，$a$ 的单位取米 (m)，并注意 $\\epsilon$ 是无量纲的，因此力的单位将是牛顿 (N)。不要代入数值。",
            "solution": "用户希望我解决一个关于在一个简化的一维原子模型中计算“鬼力”的问题。\n\n### 步骤1：问题验证\n\n首先，我将根据用户的指示验证问题陈述。\n\n#### 提取已知条件\n\n*   **系统**：一个无限长的一维原子链，原子由索引 $i \\in \\mathbb{Z}$ 标记。\n*   **参考构型**：参考晶格间距为 $a > 0$，参考位置为 $x_i = i a$。\n*   **势能**：对于一个完整（未切割）的链，原子势能为 $\\mathcal{E}_{\\mathrm{atom}}(y)=\\sum_{i\\in\\mathbb{Z}}\\frac{k}{2}\\left(\\left(y_{i+1}-y_i\\right)-a\\right)^{2}$。相互作用是通过刚度为 $k > 0$、静止长度为 $a$ 的最近邻谐振子弹簧。\n*   **模型修改**：最近邻键 $(0,1)$ 被删除。所有其他键保持不变。这定义了需要计算力的系统。\n*   **力学条件**：没有外力。系统处于准静态设置中。\n*   **位移场**：对于一个恒定应变 $\\epsilon \\in \\mathbb{R}$，施加一个均匀的仿射位移 $u_i=\\epsilon\\, i\\, a$。\n*   **形变构型**：原子位置由 $y_i = x_i + u_i = (1+\\epsilon)\\,i\\,a$ 给出。\n*   **力的定义**：原子 $i$ 上的内部节点力为 $f_i(y) = -\\frac{\\partial \\mathcal{E}}{\\partial y_i}$，其中 $\\mathcal{E}$ 是修改后系统的总势能。\n*   **目标**：计算界面节点 $i=0$ 处的残余内力。\n*   **符号约定**：正向力作用于正晶格方向（$i$ 增大的方向）。\n*   **输出格式**：答案应为一个关于 $k$、$a$ 和 $\\epsilon$ 的闭式符号表达式。\n\n#### 使用提取的已知条件进行验证\n\n1.  **科学基础**：该问题具有科学合理性。它采用了一维晶格的标准谐波势，这是固态物理学中的一个基本模型。通过删除化学键来创建界面，并计算在均匀形变下产生的伪“鬼力”的概念，是多尺度材料模拟领域一个成熟的课题，尤其是在准连续介质 (Quasicontinuum, QC) 方法的背景下。所使用的原理（势能，力是能量的负梯度）是经典力学的基石。\n\n2.  **适定性**：该问题是适定的。它完整描述了系统的势能（修改后）、原子的具体构型，并精确定义了待计算的量（原子0上的力）。所有必要的参数（$k$、$a$、$\\epsilon$）都已定义。计算将导出一个唯一且有意义的结果。\n\n3.  **客观性**：该问题以精确、客观和数学化的语言陈述，没有任何主观或模棱两可的术语。\n\n4.  **缺陷检查清单**：该问题没有表现出任何列出的缺陷。它不是科学上不合理、不相关、不完整、矛盾、不切实际、不适定或微不足道的。这是一个标准的、可解的问题，旨在说明计算模型中的一个特定物理伪影。\n\n#### 结论\n\n问题是 **有效的**。我现在将继续进行解答。\n\n### 步骤2：求解推导\n\n系统的总势能 $\\mathcal{E}_{\\text{cut}}$ 由所有现存键的能量总和定义。由于原子 $i=0$ 和 $i=1$ 之间的键被删除，对应于此键的项从总能量和中移除。能量为：\n$$\n\\mathcal{E}_{\\text{cut}}(y) = \\sum_{j \\in \\mathbb{Z}, j \\neq 0} \\frac{k}{2} \\left( (y_{j+1} - y_j) - a \\right)^2\n$$\n这个求和可以分为两部分：一部分是切口左侧的半无限链，另一部分是切口右侧的半无限链：\n$$\n\\mathcal{E}_{\\text{cut}}(y) = \\sum_{j=-\\infty}^{-1} \\frac{k}{2} \\left( (y_{j+1} - y_j) - a \\right)^2 + \\sum_{j=1}^{\\infty} \\frac{k}{2} \\left( (y_{j+1} - y_j) - a \\right)^2\n$$\n原子 $i=0$ 上的内力定义为总势能相对于位置 $y_0$ 的负梯度：\n$$\nf_0 = -\\frac{\\partial \\mathcal{E}_{\\text{cut}}}{\\partial y_0}\n$$\n为了计算这个导数，我们必须找出能量表达式 $\\mathcal{E}_{\\text{cut}}$ 中所有依赖于 $y_0$ 的项。检查求和式可知，位置 $y_0$ 仅出现在连接原子 $i=-1$ 和原子 $i=0$ 的键中。这对应于索引 $j$ 满足 $j+1=0$ 的项，即 $j=-1$。键 $(0,1)$ 对应的项（本应对应于 $j=0$ 且也涉及 $y_0$）已从求和中明确移除。\n\n因此，只有 $j=-1$ 的项对关于 $y_0$ 的导数有贡献：\n$$\nf_0 = -\\frac{\\partial}{\\partial y_0} \\left[ \\frac{k}{2} \\left( (y_0 - y_{-1}) - a \\right)^2 \\right]\n$$\n应用链式法则求导，我们得到：\n$$\nf_0 = - \\frac{k}{2} \\cdot 2 \\left( (y_0 - y_{-1}) - a \\right) \\cdot \\frac{\\partial}{\\partial y_0} \\left( y_0 - y_{-1} - a \\right)\n$$\n$$\nf_0 = -k \\left( (y_0 - y_{-1}) - a \\right) \\cdot (1)\n$$\n$$\nf_0 = -k \\left( y_0 - y_{-1} - a \\right)\n$$\n现在，我们将给定的形变后位置 $y_i = (1+\\epsilon)ia$ 代入此力表达式中。\n对于原子 $i=0$：\n$$\ny_0 = (1+\\epsilon)(0)a = 0\n$$\n对于原子 $i=-1$：\n$$\ny_{-1} = (1+\\epsilon)(-1)a = -(1+\\epsilon)a\n$$\n将这些值代回 $f_0$ 的表达式中：\n$$\nf_0 = -k \\left( 0 - (-(1+\\epsilon)a) - a \\right)\n$$\n$$\nf_0 = -k \\left( (1+\\epsilon)a - a \\right)\n$$\n$$\nf_0 = -k \\left( a + \\epsilon a - a \\right)\n$$\n$$\nf_0 = -k (\\epsilon a)\n$$\n因此，原子 $i=0$ 上残余力的最终表达式为：\n$$\nf_0 = -k a \\epsilon\n$$\n这个非零力是朴素耦合方案产生的一种伪影。在一个完美的、未切割的晶格中，在相同的均匀应变下，任何原子上的力都将为零，因为来自左右相邻键的力会完全抵消。通过切断键 $(0,1)$，我们移除了原子 $1$ 对原子 $0$ 施加的力，从而留下了来自原子 $-1$ 的一个不平衡力。对于正应变 $\\epsilon > 0$，弹簧 $(-1,0)$ 被拉伸，它将原子 $0$ 向负方向拉动，这与最终结果中的负号一致。",
            "answer": "$$\n\\boxed{-k a \\epsilon}\n$$"
        },
        {
            "introduction": "在第一个练习的基础上，本实践将探讨模型复杂性如何影响幽灵力。我们将把一维链模型扩展到包含次近邻相互作用，并比较两种不同的界面能量分配方案。这个练习旨在证明幽灵力并非一个固定不变的伪影，而是对物理模型和多尺度耦合方法细节都非常敏感的。",
            "id": "3812109",
            "problem": "考虑一个无限一维晶体链，其原子由整数 $i \\in \\mathbb{Z}$ 索引，参考晶格间距为 $a>0$，并且存在直至次近邻的谐波对相互作用。完全原子系统的势能为\n$$\nE_{\\text{atom}} = \\sum_{i\\in\\mathbb{Z}} \\left[ \\frac{1}{2} k_{1} \\left( y_{i+1} - y_{i} - a \\right)^{2} + \\frac{1}{2} k_{2} \\left( y_{i+2} - y_{i} - 2a \\right)^{2} \\right],\n$$\n其中 $k_{1}>0$ 和 $k_{2}>0$ 分别是最近邻和次近邻相互作用的弹簧常数，$y_{i}$ 是原子的当前位置。假设存在一个均匀小应变 $\\epsilon$，使得位移场为 $u_{i} = \\epsilon\\, i\\, a$，因此 $y_{i} = i a + u_{i} = i a (1+\\epsilon)$。\n\n我们使用一种受拟连续介质 (QC) 方法启发的基于能量的方案，将原子区域与连续介质区域耦合，界面位于 $i=0$ 和 $i=1$ 之间。左侧 ($i\\le 0$) 被原子化处理，而右侧 ($i\\ge 1$) 在连续介质近似下通过柯西-玻恩法则处理。伪力的产生是因为跨越界面的键没有得到一致的表示。将左区域能量 $E_{\\text{left}}$ 定义为分配给原子侧的总能量部分，它通过 $f_{0} = -\\partial E_{\\text{left}}/\\partial y_{0}$ 决定了界面原子 $i=0$ 上的力。\n\n考虑了两种在界面处切割键的策略：\n\n- 非对称切割：在 $E_{\\text{left}}$ 中只包含两个端点都位于原子区域 ($i \\le 0$) 的键。一个端点在 $i\\le 0$ 区域而另一个端点在 $i\\ge 1$ 区域的键从 $E_{\\text{left}}$ 中省略。\n\n- 对称切割：在 $E_{\\text{left}}$ 中包含所有左端点位于 $i\\le 0$ 区域的键，并具有以下权重：右端点也位于 $i\\le 0$ 区域的键的权重为 $1$，而跨越界面的键（一个端点在 $i\\le 0$ 区域，另一个在 $i\\ge 1$ 区域）的权重为 $1/2$。\n\n从力是能量负梯度的基本定义出发，并使用上述的均匀应变构型，推导在两种切割策略下界面原子上的伪力 $f_{0}$ 的解析表达式。然后，以 $k_{1}$ 和 $k_{2}$ 表示的单个封闭形式解析表达式报告其大小之比 $R = |f_{0}^{\\text{asym}}|/|f_{0}^{\\text{sym}}|$。无需进行数值计算或四舍五入。",
            "solution": "问题陈述经评估有效。其科学依据在于固态物理学和计算材料科学的原理，特别是关于多尺度建模和原子-连续介质耦合中伪力的概念。该问题是适定的，提供了所有必要的参数、定义和条件，从而可以推导出唯一的解析解。语言是客观的，设置是自洽且无矛盾的。\n\n目标是对于两种不同的能量分配方案，推导位于索引 $i=0$ 的界面原子上的伪力 $f_{0}$，然后求出它们的大小之比。\n\n首先，我们分析在均匀应变 $\\epsilon$ 下的原子位置和键的伸长量。原子 $i$ 的位置由 $y_{i} = i a (1+\\epsilon)$ 给出。\n\n原子 $i$ 和 $i+1$ 之间的最近邻键的长度变化为：\n$$ y_{i+1} - y_{i} = (i+1) a (1+\\epsilon) - i a (1+\\epsilon) = a(1+\\epsilon) $$\n势能中的项是相对于参考长度 $a$ 的伸长量：\n$$ \\Delta L_{1} = (y_{i+1} - y_{i}) - a = a(1+\\epsilon) - a = a\\epsilon $$\n\n原子 $i$ 和 $i+2$ 之间的次近邻键的长度变化为：\n$$ y_{i+2} - y_{i} = (i+2) a (1+\\epsilon) - i a (1+\\epsilon) = 2a(1+\\epsilon) $$\n势能中的项是相对于参考长度 $2a$ 的伸长量：\n$$ \\Delta L_{2} = (y_{i+2} - y_{i}) - 2a = 2a(1+\\epsilon) - 2a = 2a\\epsilon $$\n这些伸长量在整个晶体中是均匀的，正如恒定应变所预期的那样。在一个完美的、无限的晶体中，由于对称性，任何原子上的净力为零。伪力源于在人为界面上能量的不一致求和。\n\n我们现在为每种切割策略推导伪力。原子 $0$ 上的力是通过其与邻居的相互作用计算的。原子 $0$ 的邻居是原子 $-1$ 和 $-2$（左侧），以及原子 $1$ 和 $2$（右侧）。相关的键是 $(-1,0)$ 和 $(-2,0)$（来自左侧），以及 $(0,1)$ 和 $(0,2)$（来自右侧）。\n\n非对称切割：\n对于非对称切割，$E_{\\text{left}}^{\\text{asym}}$ 只包含两个端点都位于原子区域（即索引小于或等于 $0$）的键的能量。为了求出原子 $0$ 上的力（$f_{0}^{\\text{asym}} = -\\partial E_{\\text{left}}^{\\text{asym}}/\\partial y_{0}$），我们需要识别出 $E_{\\text{left}}^{\\text{asym}}$ 中依赖于 $y_{0}$ 的项。\n- 最近邻键 $(-1,0)$ 的两个原子索引都 $\\le 0$。其能量项 $\\frac{1}{2} k_{1} (y_0 - y_{-1} - a)^2$ 被包含在 $E_{\\text{left}}^{\\text{asym}}$ 中。\n- 次近邻键 $(-2,0)$ 的两个原子索引都 $\\le 0$。其能量项 $\\frac{1}{2} k_{2} (y_0 - y_{-2} - 2a)^2$ 被包含在 $E_{\\text{left}}^{\\text{asym}}$ 中。\n- 键 $(0,1)$ 跨越界面，因为原子 1 在连续介质区域 ($1 \\ge 1$)。其能量被从 $E_{\\text{left}}^{\\text{asym}}$ 中排除。\n- 键 $(0,2)$ 也跨越界面并被排除。\n\n因此，$E_{\\text{left}}^{\\text{asym}}$ 中依赖于 $y_0$ 的项仅来自于它与原子 $-1$ 和 $-2$ 的相互作用。力为：\n$$ f_{0}^{\\text{asym}} = -\\frac{\\partial}{\\partial y_{0}} \\left[ \\frac{1}{2} k_{1} (y_0 - y_{-1} - a)^2 + \\frac{1}{2} k_{2} (y_0 - y_{-2} - 2a)^2 \\right] $$\n$$ f_{0}^{\\text{asym}} = - \\left[ k_{1} (y_0 - y_{-1} - a) + k_{2} (y_0 - y_{-2} - 2a) \\right] $$\n代入均匀应变表达式，其中 $y_0 - y_{-1} = a(1+\\epsilon)$ 且 $y_0 - y_{-2} = 2a(1+\\epsilon)$：\n$$ y_0 - y_{-1} - a = a(1+\\epsilon) - a = a\\epsilon $$\n$$ y_0 - y_{-2} - 2a = 2a(1+\\epsilon) - 2a = 2a\\epsilon $$\n所以伪力是：\n$$ f_{0}^{\\text{asym}} = - [ k_{1} (a\\epsilon) + k_{2} (2a\\epsilon) ] = -a\\epsilon (k_{1} + 2k_{2}) $$\n\n对称切割：\n对于对称切割，$E_{\\text{left}}^{\\text{sym}}$ 包含所有左端点位于原子区域 ($i \\le 0$) 的键。完全在该区域内的键权重为 $1$，而跨越界面的键权重为 $1/2$。我们识别涉及 $y_0$ 的能量项：\n- 键 $(-1,0)$：左端点为 $-1 \\le 0$，右端点为 $0 \\le 0$。权重为 $1$。项：$1 \\times \\frac{1}{2} k_{1} (y_0 - y_{-1} - a)^2$。\n- 键 $(-2,0)$：左端点为 $-2 \\le 0$，右端点为 $0 \\le 0$。权重为 $1$。项：$1 \\times \\frac{1}{2} k_{2} (y_0 - y_{-2} - 2a)^2$。\n- 键 $(0,1)$：左端点为 $0 \\le 0$，右端点为 $1 \\ge 1$。跨越界面。权重为 $1/2$。项：$\\frac{1}{2} \\times \\frac{1}{2} k_{1} (y_1 - y_0 - a)^2$。\n- 键 $(0,2)$：左端点为 $0 \\le 0$，右端点为 $2 \\ge 1$。跨越界面。权重为 $1/2$。项：$\\frac{1}{2} \\times \\frac{1}{2} k_{2} (y_2 - y_0 - 2a)^2$。\n\n力 $f_{0}^{\\text{sym}} = -\\partial E_{\\text{left}}^{\\text{sym}}/\\partial y_{0}$ 由这些加权能量贡献的总和计算得出：\n$$ f_{0}^{\\text{sym}} = -\\frac{\\partial}{\\partial y_{0}} \\left[ \\frac{1}{2} k_{1} (y_0 - y_{-1} - a)^2 + \\frac{1}{2} k_{2} (y_0 - y_{-2} - 2a)^2 + \\frac{1}{4} k_{1} (y_1 - y_0 - a)^2 + \\frac{1}{4} k_{2} (y_2 - y_0 - 2a)^2 \\right] $$\n对 $y_0$ 求导：\n$$ f_{0}^{\\text{sym}} = - \\left[ k_{1} (y_0 - y_{-1} - a) + k_{2} (y_0 - y_{-2} - 2a) + \\frac{1}{2} k_{1} (y_1 - y_0 - a)(-1) + \\frac{1}{2} k_{2} (y_2 - y_0 - 2a)(-1) \\right] $$\n$$ f_{0}^{\\text{sym}} = - k_{1} (y_0 - y_{-1} - a) - k_{2} (y_0 - y_{-2} - 2a) + \\frac{1}{2} k_{1} (y_1 - y_0 - a) + \\frac{1}{2} k_{2} (y_2 - y_0 - 2a) $$\n代入均匀应变伸长量：$\\Delta L_{1} = a\\epsilon$ 和 $\\Delta L_{2} = 2a\\epsilon$：\n$$ f_{0}^{\\text{sym}} = -k_{1}(a\\epsilon) - k_{2}(2a\\epsilon) + \\frac{1}{2} k_{1}(a\\epsilon) + \\frac{1}{2} k_{2}(2a\\epsilon) $$\n$$ f_{0}^{\\text{sym}} = a\\epsilon \\left(-k_{1} - 2k_{2} + \\frac{1}{2}k_{1} + k_{2} \\right) = a\\epsilon \\left(-\\frac{1}{2}k_{1} - k_{2} \\right) $$\n$$ f_{0}^{\\text{sym}} = -\\frac{1}{2} a\\epsilon (k_1 + 2k_2) $$\n\n大小之比：\n问题要求比值 $R = |f_{0}^{\\text{asym}}|/|f_{0}^{\\text{sym}}|$。\n力的大小为：\n$$ |f_{0}^{\\text{asym}}| = |-a\\epsilon (k_{1} + 2k_{2})| = |a\\epsilon|(k_{1} + 2k_{2}) $$\n$$ |f_{0}^{\\text{sym}}| = |-\\frac{1}{2} a\\epsilon (k_1 + 2k_2)| = \\frac{1}{2}|a\\epsilon|(k_{1} + 2k_{2}) $$\n比值 $R$ 为：\n$$ R = \\frac{|a\\epsilon|(k_{1} + 2k_{2})}{\\frac{1}{2}|a\\epsilon|(k_{1} + 2k_{2})} $$\n由于 $\\epsilon \\ne 0$，$a > 0$，$k_1 > 0$ 且 $k_2 > 0$，项 $|a\\epsilon|(k_{1} + 2k_{2})$ 不为零，可以从分子和分母中约去。\n$$ R = \\frac{1}{1/2} = 2 $$\n伪力的大小之比是一个常数值 $2$，与应变 $\\epsilon$ 和弹簧常数 $k_1$、$k_2$ 无关。",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "现在，我们将从一维的解析模型转向更真实的二维数值模拟。本实践的核心是为一个二维三角晶格设计一个“补丁测试”(patch test)，这是验证多尺度方法的标准流程。你将实现并比较一个会产生幽灵力的“朴素”耦合方案和一个能够消除幽灵力的修正方案，并观察它们在拉伸和剪切变形下的不同表现。",
            "id": "3812139",
            "problem": "考虑一个二维三角布拉菲晶格，其原胞矢量为 $d_1 = (a,0)$ 和 $d_2 = \\left(\\frac{a}{2}, \\frac{\\sqrt{3}a}{2}\\right)$。晶格格点由整数对 $(i,j)$ 索引，其位置为 $x_{i,j} = i\\,d_1 + j\\,d_2$。每个原子通过中心对势 $\\phi(r) = \\frac{k}{2}(r - a)^2$ 与其六个最近邻原子相互作用，其中 $r$ 是变形后的键长，$a$ 是参考键长，$k$ 是刚度。一个均匀变形 $F \\in \\mathbb{R}^{2 \\times 2}$ 将参考键矢量 $b$ 映射到变形后的键矢量 $v = F\\,b$。在变形 $F$ 下沿键传递的力是中心力 $f(F,b) = k\\left(\\lVert F\\,b \\rVert - a\\right)\\frac{F\\,b}{\\lVert F\\,b \\rVert}$，作用于原点原子，方向指向其变形后的邻居。\n\n定义晶格指数空间中的六个最近邻偏移量为 $\\Delta = \\{(1,0),(0,1),(-1,1),(-1,0),(0,-1),(1,-1)\\}$，对应于参考键矢量 $b(\\delta) = \\delta_1\\,d_1 + \\delta_2\\,d_2$，其中 $\\delta = (\\delta_1,\\delta_2) \\in \\Delta$。\n\n我们在一个具有 $N_x$ 列和 $N_y$ 行的有限矩形晶格上设计一个准连续介质（QC）耦合方法，在 $j$ 方向采用周期性边界条件，在 $i$ 方向采用自由边界。设原子区域 $\\mathcal{A}$ 由索引条件 $i  I$ 定义，连续介质区域 $\\mathcal{C}$ 由 $i \\ge I$ 定义，其中 $I$ 是一个整数界面索引，满足 $1 \\le I \\le N_x - 1$。我们考虑两种 QC 耦合变体：\n\n1. 朴素的基于能量的混合（类 QCE）：将连接 $\\mathcal{A}$ 中原子与 $\\mathcal{C}$ 中原子的键被舍弃。也就是说，对于任何原子 $(i,j) \\in \\mathcal{A}$ 和邻居偏移量 $\\delta \\in \\Delta$，如果 $(i+\\delta_1,j+\\delta_2) \\in \\mathcal{C}$，则键力贡献 $f(F,b(\\delta))$ 被忽略。\n\n2. 满足“斑图检验”的校正：对于每个从 $\\mathcal{A}$ 跨越到 $\\mathcal{C}$ 的被舍弃的键，一个等于 $f(F,b(\\delta))$ 的外部校正力被施加到原子 $(i,j) \\in \\mathcal{A}$ 上。在均匀变形 $F$ 下，这模拟了来自 $\\mathcal{C}$ 的柯西-玻恩（Cauchy–Born）牵引力并恢复了力的平衡。\n\n定义原子 $(i,j)$ 处的节点残差为 $R_{i,j} = \\sum_{\\delta \\in \\Delta} \\mathcal{W}_{i,j}(\\delta)$，其中如果 $(i+\\delta_1,j+\\delta_2) \\in \\mathcal{A}$，则 $\\mathcal{W}_{i,j}(\\delta)$ 等于 $f(F,b(\\delta))$；如果邻居索引 $(i+\\delta_1)$ 超出 $[0,N_x-1]$，则等于 $0$；对于跨入 $\\mathcal{C}$ 的键，在朴素混合变体中等于 $0$，或在满足“斑图检验”的校正变体中等于 $f(F,b(\\delta))$。残差仅对 $i = I - 1$（与界面相邻的原子列）的原子 $(i,j) \\in \\mathcal{A}$ 进行评估，并且周期性意味着索引 $j+\\delta_2$ 应取模 $N_y$。\n\n将在均匀变形 $F$ 下朴素混合变体的界面牵引力跳跃定义为单位界面长度上净缺失牵引力的量值。设 $\\mathcal{B}_{\\mathrm{cut}}$ 为从 $i=I-1$ 的原子 $(i,j) \\in \\mathcal{A}$ 跨越到 $\\mathcal{C}$ 中邻居的键的集合。那么牵引力跳跃为\n$$\nT = \\frac{\\left\\lVert \\sum_{(i,j)\\in \\mathcal{A},\\, i=I-1}\\; \\sum_{\\delta \\in \\Delta:\\, i+\\delta_1 \\ge I} f(F,b(\\delta)) \\right\\rVert}{L_{\\mathrm{int}}},\n$$\n其中 $L_{\\mathrm{int}} = N_y\\,\\lVert d_2 \\rVert$ 是平行于 $d_2$ 的界面段的物理长度。对于满足“斑图检验”的校正，$T=0$ 是由构造决定的；对于纯原子晶格（无连续介质区域），$T=0$ 并且在均匀变形 $F$ 下所有残差都消失。\n\n此问题中的所有量都是无量纲的。您的任务是为此设置实现一个数值“斑图检验”，并为每个测试用例计算两个可观察的指标：\n- 界面相邻原子列中原子的最大节点残差量值，即 $\\max_{j} \\lVert R_{I-1,j} \\rVert$。\n- 如上定义的界面牵引力跳跃量值 $T$。\n\n从牛顿定律和中心力相互作用开始推导，并利用 $F$ 的均匀性和晶格对称性来论证在纯原子和校正后的 QC 情况下的预期行为。\n\n您的程序应该为以下参数测试套件 $(N_x,N_y,I,k,a,F,\\text{mode})$ 评估这些指标，其中 $\\text{mode} \\in \\{\\text{atomistic},\\text{naive},\\text{corrected}\\}$：\n\n- 测试 1（理想情况，纯原子）：$(20,20,10,1.0,1.0,F=\\begin{pmatrix}1.05 & 0\\\\0 & 1.05\\end{pmatrix},\\text{atomistic})$。\n- 测试 2（存在“鬼”力，各向同性拉伸下的朴素混合）：$(20,20,10,1.0,1.0,F=\\begin{pmatrix}1.05 & 0\\\\0 & 1.05\\end{pmatrix},\\text{naive})$。\n- 测试 3（“鬼”力已校正，各向同性拉伸）：$(20,20,10,1.0,1.0,F=\\begin{pmatrix}1.05 & 0\\\\0 & 1.05\\end{pmatrix},\\text{corrected})$。\n- 测试 4（边界情况，单位变形）：$(20,20,10,1.0,1.0,F=\\begin{pmatrix}1 & 0\\\\0 & 1\\end{pmatrix},\\text{naive})$。\n- 测试 5（剪切变形，存在“鬼”力）：$(30,12,15,1.0,1.0,F=\\begin{pmatrix}1 & 0.1\\\\0 & 1\\end{pmatrix},\\text{naive})$。\n- 测试 6（剪切变形，“鬼”力已校正）：$(30,12,15,1.0,1.0,F=\\begin{pmatrix}1 & 0.1\\\\0 & 1\\end{pmatrix},\\text{corrected})$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序为 $[\\text{res}_1,\\text{trac}_1,\\text{res}_2,\\text{trac}_2,\\dots,\\text{res}_6,\\text{trac}_6]$，其中 $\\text{res}_t$ 是测试 $t$ 的最大节点残差量值，$\\text{trac}_t$ 是测试 $t$ 的牵引力跳跃量值，每个都表示为浮点数。",
            "solution": "该问题要求为一个在均匀变形下的二维三角晶格的准连续介质（QC）模型计算两个指标——最大节点残差和界面牵引力跳跃。分析是针对三种耦合变体进行的：完全原子模型、朴素的基于能量的 QC 耦合，以及满足“斑图检验”的校正 QC 耦合。\n\n### 1. 基本原理：平衡与中心力\n\n根据牛顿第一定律，要使物体处于静态平衡状态，作用在其任何组成粒子上的合力必须为零。在我们的晶格系统中，每个由 $\\alpha$ 索引的原子通过中心对力 $f_{\\alpha\\beta}$ 与其邻居 $\\beta$ 相互作用。作用在原子 $\\alpha$ 上的总力是其邻居作用力的矢量和：\n$$\nF_{\\alpha} = \\sum_{\\beta} f_{\\alpha\\beta}\n$$\n对于静态构型，或正在进行匀速运动（包括均匀变形）的构型，对于每个不受外部体积力作用的原子 $\\alpha$，这个合力 $F_{\\alpha}$ 必须为零。\n\n在一个承受均匀变形梯度 $F$ 下，一个邻居（其参考位置由键矢量 $b$ 描述）对位于原点的原子施加的力由以下公式给出：\n$$\nf(F,b) = k\\left(\\lVert F\\,b \\rVert - a\\right)\\frac{F\\,b}{\\lVert F\\,b \\rVert}\n$$\n此处，$k$ 是键刚度，$a$ 是参考键长（等于参考构型中的最近邻距离），$F\\,b$ 是变形后的键矢量。\n\n### 2. “斑图检验”与完美晶格\n\n任何多尺度方法的一个基本一致性检验是“斑图检验”（patch test）。它断言，如果整个系统承受一个应能被粗粒化（连续介质）模型精确表示的变形状态，则耦合方法必须无误地再现该状态。对于原子-连续介质耦合，最简单的此类状态是均匀变形 $F$。\n\n在一个承受均匀变形 $F$ 的完美无限晶格中，原子位置根据连续介质变形进行映射，这一概念被称为柯西-玻恩（Cauchy-Born）法则。作用在任何原子上的净力是来自其所有邻居的力之和：\n$$\nF_{total} = \\sum_{\\delta \\in \\Delta} f(F, b(\\delta))\n$$\n其中 $\\Delta$ 是六个最近邻的索引偏移量集合。对于三角晶格，参考键矢量集合 $\\{b(\\delta) | \\delta \\in \\Delta\\}$ 是中心对称的。这意味着对于集合中的每个键矢量 $b$，其相反矢量 $-b$ 也在集合中。具体来说，邻居以三个相反的对出现：$(\\delta_1,\\delta_2)$ 和 $(-\\delta_1,-\\delta_2)$。例如，$\\delta=(1,0)$ 与 $\\delta=(-1,0)$ 配对。力函数具有属性 $f(F,-b) = -f(F,b)$，因为 $\\lVert F(-b) \\rVert = \\lVert F b \\rVert$。因此，在一个中心对称邻域上的力之和为零：\n$$\nF_{total} = \\sum_{k=1}^{3} \\left[ f(F, b_k) + f(F, -b_k) \\right] = \\sum_{k=1}^{3} \\left[ f(F, b_k) - f(F, b_k) \\right] = 0\n$$\n因此，在一个完全 `atomistic` 的计算域中，任何远离自由边界的原子（一个“内部”原子）都承受零净力，其节点残差为零。这不言而喻地通过了“斑图检验”。\n\n### 3. 准连续介质界面与“鬼”力\n\nQC 方法将系统划分为原子区域 $\\mathcal{A}$ 和连续介质区域 $\\mathcal{C}$。`naive`（类 QCE）耦合方案通过简单地丢弃从 $\\mathcal{A}$ 中的原子跨越到 $\\mathcal{C}$ 中邻居的相互作用（键）来处理界面。\n\n考虑一个位于界面边界上的原子 $(i,j)$，其 $i=I-1$。它的邻域不再完整；力的总和仅对同样在 $\\mathcal{A}$ 中的邻居（或在物理域之外，贡献零力）进行计算。\n$$\nR_{i,j} = \\sum_{\\delta: (i+\\delta_1, j+\\delta_2) \\in \\mathcal{A}} f(F, b(\\delta))\n$$\n由于求和现在是基于一个不完整的、非中心对称的邻居集合，其总和通常不为零。这个非零的节点残差 $R_{i,j}$ 是不一致耦合方案产生的伪影，被称为“鬼”力（ghost force）。它表示在界面处违反了力学平衡，并表明朴素方法未能通过“斑图检验”。\n\n`interface traction jump`（界面牵引力跳跃）$T$ 量化了这种不一致性的大小。它是所有被丢弃的键产生的净力，并由界面长度 $L_{\\mathrm{int}} = N_y \\lVert d_2 \\rVert = N_y a$ 进行归一化。\n$$\nT = \\frac{\\left\\lVert \\sum_{\\text{cut bonds}} f(F,b(\\delta)) \\right\\rVert}{L_{\\mathrm{int}}}\n$$\n作用在界面原子上的“鬼”力之和恰好是来自被切断键的力之和的负值，因为所有键（切断和未切断）的总力必须为零。\n\n### 4. 满足“斑图检验”的校正\n\n`corrected` QC 方案解决了“鬼”力问题。对于在 `naive` 方案中被移除的、从 $\\mathcal{A}$ 中原子到 $\\mathcal{C}$ 中邻居的每个键，一个等于该键本应承载的力 $f(F,b(\\delta))$ 的外力被施加到 $\\mathcal{A}$ 中的原子上。这个校正力精确地模拟了根据柯西-玻恩法则，连续介质区域应对原子区域施加的牵引力。\n\n通过此校正，界面原子 $(i,j)$ 的节点残差变为：\n$$\nR_{i,j} = \\left( \\sum_{\\delta: \\text{neighbor in } \\mathcal{A}} f(F, b(\\delta)) \\right) + \\left( \\sum_{\\delta: \\text{neighbor in } \\mathcal{C}} f(F, b(\\delta)) \\right) = \\sum_{\\delta \\in \\Delta} f(F, b(\\delta)) = 0\n$$\n力的平衡被完美恢复，“鬼”力被消除，节点残差为零，`corrected` 方法通过了“斑图检验”。根据构造，`traction jump`（牵引力跳跃）$T$ 也为零。\n\n### 5. 算法设计\n\n数值实现通过直接应用定义来进行。对于每个测试用例，我们设置参数 $(N_x, N_y, I, k, a, F, \\text{mode})$。由于变形的均匀性和 $j$ 方向的周期性，对于所有界面原子 $j \\in [0, N_y-1]$，节点残差 $R_{I-1,j}$ 和缺失键力的集合是相同的。这允许一个显著的简化：我们可以为单个代表性原子（例如，在 $j=0$ 处的原子）计算残差和缺失力，并对牵引力跳跃的结果按 $N_y$ 进行缩放。\n\n单个测试用例的算法如下：\n1.  将节点残差矢量和每个原子的缺失力矢量初始化为零。\n2.  定义原胞晶格矢量 $d_1, d_2$ 并构造六个最近邻参考键矢量集合 $\\{b(\\delta)\\}$。\n3.  遍历六个邻居偏移量 $\\delta \\in \\Delta$ 中的每一个。a. 计算在给定变形 $F$ 下该键将承载的力矢量 $f(F,b(\\delta))$。b. 确定邻居原子相对于界面索引 $I$ 的位置。c. 应用与模拟 `mode`（`atomistic`、`naive` 或 `corrected`）相对应的逻辑，以确定要添加到节点残差中的力贡献。d. 对于 `naive` 模式，如果一个键被切断（即其力贡献被设为零），则将计算出的力矢量 $f(F,b(\\delta))$ 添加到每个原子的缺失力累加器中。\n4.  遍历所有六个邻居后，最终节点残差矢量的量值是第一个指标。\n5.  对于 `naive` 模式，第二个指标，即牵引力跳跃 $T$，计算为每个原子的缺失力矢量的量值除以参考键长 $a$。对于 `atomistic` 和 `corrected` 模式，$T$ 为零。\n\n对每个测试用例执行此过程以生成所需的输出。对于 `atomistic` 和 `corrected` 模式，计算出的残差应为零（或在机器精度范围内），这验证了理论分析。",
            "answer": "```python\nimport numpy as np\n\ndef compute_qc_metrics(Nx, Ny, I, k, a, F_matrix, mode):\n    \"\"\"\n    Computes the maximum nodal residual and interface traction jump for a given test case.\n    \n    Args:\n        Nx (int): Number of columns in the lattice.\n        Ny (int): Number of rows in the lattice.\n        I (int): Interface index.\n        k (float): Bond stiffness.\n        a (float): Reference bond length.\n        F_matrix (list of lists): The 2x2 deformation gradient matrix.\n        mode (str): The simulation mode ('atomistic', 'naive', 'corrected').\n\n    Returns:\n        tuple: A tuple containing (max_residual_norm, traction_jump).\n    \"\"\"\n    F = np.array(F_matrix)\n    d1 = np.array([a, 0.0])\n    d2 = np.array([a / 2.0, a * np.sqrt(3) / 2.0])\n    \n    # Offsets in lattice index space for a triangular lattice with primitive vectors d1, d2\n    delta_list = [(1, 0), (0, 1), (-1, 1), (-1, 0), (0, -1), (1, -1)]\n    b_vectors = {delta: delta[0] * d1 + delta[1] * d2 for delta in delta_list}\n\n    # Due to homogeneity and periodicity, the residual is the same for all interface atoms.\n    # We can compute it for a single representative atom.\n    i_atom = I - 1\n    \n    nodal_residual = np.zeros(2)\n    missing_force_per_atom = np.zeros(2)\n\n    for delta in delta_list:\n        d1_idx, _ = delta\n        \n        b = b_vectors[delta]\n        v = F @ b\n        r = np.linalg.norm(v)\n\n        # Calculate the central force vector for the bond\n        force_vec = np.zeros(2)\n        if r > 1e-15:\n            force_vec = k * (r - a) * v / r\n\n        force_contribution = np.zeros(2)\n        i_neighbor = i_atom + d1_idx\n\n        # Check for free boundaries in the i-direction\n        if not (0 = i_neighbor  Nx):\n            # Neighbor is outside the simulation grid, force contribution is zero\n            force_contribution = np.zeros(2)\n        else:\n            # Neighbor is inside the simulation grid. Apply QC coupling rules.\n            is_neighbor_in_C = (i_neighbor >= I)\n            \n            if mode == 'atomistic':\n                # 'atomistic' mode means no A/C partition. All on-grid bonds are active.\n                force_contribution = force_vec\n            \n            elif mode == 'naive':\n                if is_neighbor_in_C:\n                    # Naively cut bond crossing into the continuum region.\n                    force_contribution = np.zeros(2)\n                    missing_force_per_atom += force_vec\n                else: # Neighbor is in the atomistic region\n                    force_contribution = force_vec\n\n            elif mode == 'corrected':\n                # Force is always included, either as a real bond force (neighbor in A)\n                # or as a correction force (neighbor in C).\n                force_contribution = force_vec\n\n        nodal_residual += force_contribution\n    \n    max_residual_norm = np.linalg.norm(nodal_residual)\n    \n    traction_jump = 0.0\n    if mode == 'naive':\n        # The total missing force is Ny * missing_force_per_atom.\n        # The interface length L_int is Ny * ||d2|| = Ny * a.\n        # T = ||Ny * missing_force_per_atom|| / (Ny * a) = ||missing_force_per_atom|| / a\n        # Added a check for a > 0 to avoid division by zero.\n        if a > 1e-15:\n            traction_jump = np.linalg.norm(missing_force_per_atom) / a\n\n    return max_residual_norm, traction_jump\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Test 1 (happy path, pure atomistic)\n        (20, 20, 10, 1.0, 1.0, [[1.05, 0], [0, 1.05]], 'atomistic'),\n        # Test 2 (ghost force present, naive mixing under isotropic stretch)\n        (20, 20, 10, 1.0, 1.0, [[1.05, 0], [0, 1.05]], 'naive'),\n        # Test 3 (ghost force corrected, isotropic stretch)\n        (20, 20, 10, 1.0, 1.0, [[1.05, 0], [0, 1.05]], 'corrected'),\n        # Test 4 (boundary case, identity deformation)\n        (20, 20, 10, 1.0, 1.0, [[1.0, 0], [0, 1.0]], 'naive'),\n        # Test 5 (shear deformation, ghost force present)\n        (30, 12, 15, 1.0, 1.0, [[1.0, 0.1], [0, 1.0]], 'naive'),\n        # Test 6 (shear deformation, ghost force corrected)\n        (30, 12, 15, 1.0, 1.0, [[1.0, 0.1], [0, 1.0]], 'corrected')\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny, I, k, a, F_matrix, mode = case\n        res, trac = compute_qc_metrics(Nx, Ny, I, k, a, F_matrix, mode)\n        results.extend([res, trac])\n\n    # Format the final output string as specified\n    output_str = '[' + ','.join(f\"{x:.12f}\" for x in results) + ']'\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}