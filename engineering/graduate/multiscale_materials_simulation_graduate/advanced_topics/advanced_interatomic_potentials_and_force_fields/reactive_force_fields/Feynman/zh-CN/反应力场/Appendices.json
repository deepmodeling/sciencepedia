{
    "hands_on_practices": [
        {
            "introduction": "反应力场（ReaxFF）模拟化学反应的能力，其核心在于它基于键级的能量表达式。键能项会根据键级的大小动态调整，从而能够平滑地描述化学键从形成到断裂的整个过程。通过这个练习，您将亲手计算一个化学键在减弱过程中的能量变化，这能帮助您直观地理解ReaxFF是如何在能量层面捕捉化学键断裂这一基本化学事件的。",
            "id": "3837640",
            "problem": "考虑反应力场 (ReaxFF) 中单个共价键的键能贡献，该贡献被建模为键级的显式函数。瞬时键能由以下参数化形式给出\n$$\nE_{\\text{bond}}(BO_{ij}) = -D_{e}\\,S(BO_{ij})\\,BO_{ij},\n$$\n其中 $D_{e}$ 是解离能标度，$BO_{ij}$ 是原子 $i$ 和 $j$ 之间的键级，$S(BO_{ij})$ 是一个平滑切换函数，用于调节键能随键级降低而减弱的方式。假设参数和函数形式采用以下科学标准选择：\n- 切换函数为\n$$\nS(BO_{ij}) = \\exp\\!\\big(-\\gamma\\,(1-BO_{ij})\\big),\n$$\n其中无量纲参数 $\\gamma = 2.0$。\n- 解离能标度为 $D_{e} = 400\\,\\text{kJ mol}^{-1}$。\n\n假设在一个反应坐标中，一个键被减弱，使得其键级从 $BO_{ij} = 1.0$ 降低到 $BO_{ij} = 0.2$。使用上述定义和标准的能量计算方法，计算键能的变化\n$$\n\\Delta E_{\\text{bond}} = E_{\\text{bond}}(0.2) - E_{\\text{bond}}(1.0).\n$$\n将最终数值答案四舍五入至四位有效数字，并以 $\\text{kJ mol}^{-1}$ 为单位表示。此外，简要解释在 ReaxFF 中 $\\Delta E_{\\text{bond}}$ 的符号和大小在键减弱方面的化学意义，但请注意，最终答案只需要 $\\Delta E_{\\text{bond}}$ 的数值。",
            "solution": "该问题是有效的，因为它基于计算化学原理（特别是反应力场），并且问题是适定的，为求得唯一解提供了所有必要信息。\n\n该问题要求计算当两个原子间的键级 $BO_{ij}$ 从一个初始值降低到一个最终值时，键能的变化量 $\\Delta E_{\\text{bond}}$。键能 $E_{\\text{bond}}$ 作为 $BO_{ij}$ 的函数给出：\n$$\nE_{\\text{bond}}(BO_{ij}) = -D_{e}\\,S(BO_{ij})\\,BO_{ij}\n$$\n切换函数 $S(BO_{ij})$ 定义为：\n$$\nS(BO_{ij}) = \\exp(-\\gamma\\,(1-BO_{ij}))\n$$\n给定的参数是解离能标度 $D_e = 400\\,\\text{kJ mol}^{-1}$ 和无量纲参数 $\\gamma = 2.0$。键级从初始状态 $BO_{\\text{initial}} = 1.0$ 变化到最终状态 $BO_{\\text{final}} = 0.2$。\n\n键能的变化定义为最终能量减去初始能量：\n$$\n\\Delta E_{\\text{bond}} = E_{\\text{bond}}(BO_{\\text{final}}) - E_{\\text{bond}}(BO_{\\text{initial}})\n$$\n首先，我们计算初始键能 $E_{\\text{bond}}(BO_{\\text{initial}})$，其中 $BO_{\\text{initial}} = 1.0$。\n在此键级下，切换函数为：\n$$\nS(1.0) = \\exp(-\\gamma\\,(1-1.0)) = \\exp(0) = 1\n$$\n因此，初始键能为：\n$$\nE_{\\text{bond}}(1.0) = -D_e \\times S(1.0) \\times 1.0 = -D_e \\times 1 \\times 1.0 = -D_e\n$$\n代入 $D_e$ 的值：\n$$\nE_{\\text{bond}}(1.0) = -400\\,\\text{kJ mol}^{-1}\n$$\n这个结果具有物理意义：对于单键 ($BO_{ij} = 1.0$)，键能等于键解离能标度的负值，代表一个稳定、完全形成的键。\n\n接下来，我们计算最终键能 $E_{\\text{bond}}(BO_{\\text{final}})$，其中 $BO_{\\text{final}} = 0.2$。\n在此键级下，切换函数为：\n$$\nS(0.2) = \\exp(-\\gamma\\,(1-0.2)) = \\exp(-2.0\\,(0.8)) = \\exp(-1.6)\n$$\n因此，最终键能为：\n$$\nE_{\\text{bond}}(0.2) = -D_e \\times S(0.2) \\times 0.2 = -D_e \\times \\exp(-1.6) \\times 0.2\n$$\n现在，我们可以计算键能的变化 $\\Delta E_{\\text{bond}}$：\n$$\n\\Delta E_{\\text{bond}} = E_{\\text{bond}}(0.2) - E_{\\text{bond}}(1.0) = \\big(-D_e \\times 0.2 \\times \\exp(-1.6)\\big) - (-D_e)\n$$\n$$\n\\Delta E_{\\text{bond}} = D_e - 0.2 \\times D_e \\times \\exp(-1.6)\n$$\n提出公因子 $D_e$：\n$$\n\\Delta E_{\\text{bond}} = D_e \\left(1 - 0.2 \\times \\exp(-1.6)\\right)\n$$\n代入 $D_e = 400\\,\\text{kJ mol}^{-1}$ 的值：\n$$\n\\Delta E_{\\text{bond}} = 400 \\left(1 - 0.2 \\times \\exp(-1.6)\\right) \\,\\text{kJ mol}^{-1}\n$$\n我们计算该数值表达式：\n$\\exp(-1.6)$ 的值约为 $0.2018965$。\n$$\n\\Delta E_{\\text{bond}} \\approx 400 \\left(1 - 0.2 \\times 0.2018965\\right) \\,\\text{kJ mol}^{-1}\n$$\n$$\n\\Delta E_{\\text{bond}} \\approx 400 \\left(1 - 0.0403793\\right) \\,\\text{kJ mol}^{-1}\n$$\n$$\n\\Delta E_{\\text{bond}} \\approx 400 \\left(0.9596207\\right) \\,\\text{kJ mol}^{-1}\n$$\n$$\n\\Delta E_{\\text{bond}} \\approx 383.84828 \\,\\text{kJ mol}^{-1}\n$$\n题目要求将答案四舍五入到四位有效数字。\n$$\n\\Delta E_{\\text{bond}} = 383.8\\,\\text{kJ mol}^{-1}\n$$\n这个结果的化学解释如下。$\\Delta E_{\\text{bond}}$ 的符号为正，表示系统的能量增加了。这与键的减弱或断裂过程一致，该过程需要输入能量。其大小 $383.8\\,\\text{kJ mol}^{-1}$ 代表了将键级从一个完全的单键 ($BO_{ij} = 1.0$) 降低到一个非常弱、接近解离的状态 ($BO_{ij} = 0.2$) 所需的能量。这个值接近完全解离能标度 $D_e = 400\\,\\text{kJ mol}^{-1}$，这是合理的，因为该键已经几乎完全断裂。在 ReaxFF 的能量形貌中，这对应于从一个能量极小点（稳定的键）显著地向能量高处移动，朝向解离极限。",
            "answer": "$$\n\\boxed{383.8}\n$$"
        },
        {
            "introduction": "一个完整的ReaxFF势函数并非单一公式，而是多种能量贡献项的复杂总和，这些贡献项共同描述了原子间的相互作用。总势能被细分为共价相互作用（如键伸缩和角弯曲）与非共价相互作用（如库仑静电和范德华斯力），并且所有这些项都受到原子间键级和动态电荷的调节。本练习将引导您为一个简单的三原子体系，一步步计算其总能量，从而揭开ReaxFF模拟中能量计算的“黑箱”，让您清晰地看到不同物理作用是如何被整合的。",
            "id": "4256259",
            "problem": "一个由原子 $A$、$B$ 和 $C$ 构成的三原子体系位于 $xy$ 平面内。原子坐标（单位为埃）为 $A:(0,0,0)$、$B:(1.40,0,0)$ 和 $C:(1.8104,1.1276,0)$，由此得到键长 $r_{AB} = 1.40$ 埃和 $r_{BC} = 1.20$ 埃。位于 $B$ 处的价键角为 $\\theta_{ABC} = 110$ 度。键级为 $B_{AB} = 0.85$ 和 $B_{BC} = 0.65$。部分电荷（以基本电荷为单位）为 $q_A = +0.4$，$q_B = -0.3$ 和 $q_C = -0.1$。使用以下反应力场能量分解和函数形式，计算总势能 $E_{\\text{tot}}$：\n\n总能量定义为 $E_{\\text{tot}} = E_{\\text{bond}} + E_{\\text{val}} + E_{\\text{coul}} + E_{\\text{vdW}}$，其中：\n\n1. 键能为\n$$\nE_{\\text{bond}} = \\sum_{\\langle i,j\\rangle} \\left( - D_{ij} \\, B_{ij} \\, \\exp\\!\\left[-\\alpha_{ij} \\left(r_{ij} - r_{0,ij}\\right)\\right] \\right),\n$$\n其中参数为 $D_{AB} = 250$ kJ/mol，$D_{BC} = 220$ kJ/mol，$\\alpha_{AB} = 3.0$ 埃$^{-1}$，$\\alpha_{BC} = 3.2$ 埃$^{-1}$，$r_{0,AB} = 1.30$ 埃，以及 $r_{0,BC} = 1.25$ 埃。\n\n2. 价键角能量为\n$$\nE_{\\text{val}} = k_{\\theta} \\, B_{AB} \\, B_{BC} \\left(\\theta_{ABC} - \\theta_{0}\\right)^{2},\n$$\n其中 $k_{\\theta} = 40$ kJ/mol/弧度$^{2}$ 且 $\\theta_{0} = 115$ 度。在此项的计算中使用弧度。\n\n3. 静电（库仑）能量使用屏蔽的对相互作用\n$$\nE_{\\text{coul}} = \\sum_{i",
            "solution": "该问题被验证为自洽、有科学依据且定义明确。所提供的数据一致且足以得出唯一解。我们通过对其四个组成部分求和来计算总势能 $E_{\\text{tot}}$：$E_{\\text{bond}}$、$E_{\\text{val}}$、$E_{\\text{coul}}$ 和 $E_{\\text{vdW}}$。\n\n首先，我们必须使用给定的原子坐标 $A:(0,0,0)$ 和 $C:(1.8104, 1.1276, 0)$ 计算非键距离 $r_{AC}$。所有坐标的单位均为埃。\n$$\nr_{AC} = \\sqrt{(x_C - x_A)^2 + (y_C - y_A)^2 + (z_C - z_A)^2}\n$$\n$$\nr_{AC} = \\sqrt{(1.8104 - 0)^2 + (1.1276 - 0)^2 + (0 - 0)^2} = \\sqrt{3.27754816 + 1.27158176} = \\sqrt{4.54912992}\n$$\n$$\nr_{AC} \\approx 2.1328689 \\, \\text{埃}\n$$\n其他距离已给出，为 $r_{AB} = 1.40$ 埃和 $r_{BC} = 1.20$ 埃。\n\n总能量为 $E_{\\text{tot}} = E_{\\text{bond}} + E_{\\text{val}} + E_{\\text{coul}} + E_{\\text{vdW}}$。\n\n1.  **键能 ($E_{\\text{bond}}$)**\n    键能是来自两个键 $A-B$ 和 $B-C$ 的贡献之和：\n    $$\n    E_{\\text{bond}} = E_{\\text{bond, AB}} + E_{\\text{bond, BC}}\n    $$\n    $$\n    E_{\\text{bond, AB}} = -D_{AB} B_{AB} \\exp\\left[-\\alpha_{AB} (r_{AB} - r_{0,AB})\\right]\n    $$\n    代入给定值：$D_{AB} = 250$ kJ/mol，$B_{AB} = 0.85$，$\\alpha_{AB} = 3.0$ 埃$^{-1}$，$r_{AB} = 1.40$ 埃，以及 $r_{0,AB} = 1.30$ 埃。\n    $$\n    E_{\\text{bond, AB}} = -250 \\times 0.85 \\times \\exp[-3.0 \\times (1.40 - 1.30)] = -212.5 \\times \\exp[-0.3] \\approx -157.4239 \\, \\text{kJ/mol}\n    $$\n    $$\n    E_{\\text{bond, BC}} = -D_{BC} B_{BC} \\exp\\left[-\\alpha_{BC} (r_{BC} - r_{0,BC})\\right]\n    $$\n    代入给定值：$D_{BC} = 220$ kJ/mol，$B_{BC} = 0.65$，$\\alpha_{BC} = 3.2$ 埃$^{-1}$，$r_{BC} = 1.20$ 埃，以及 $r_{0,BC} = 1.25$ 埃。\n    $$\n    E_{\\text{bond, BC}} = -220 \\times 0.65 \\times \\exp[-3.2 \\times (1.20 - 1.25)] = -143 \\times \\exp[0.16] \\approx -167.8111 \\, \\text{kJ/mol}\n    $$\n    总键能为：\n    $$\n    E_{\\text{bond}} \\approx -157.4239 - 167.8111 = -325.2350 \\, \\text{kJ/mol}\n    $$\n\n2.  **价键角能量 ($E_{\\text{val}}$)**\n    价键角能量由下式给出：\n    $$\n    E_{\\text{val}} = k_{\\theta} B_{AB} B_{BC} (\\theta_{ABC} - \\theta_{0})^2\n    $$\n    计算时角度必须以弧度为单位。给定的角度为 $\\theta_{ABC} = 110^{\\circ}$ 和 $\\theta_{0} = 115^{\\circ}$。\n    角度差为 $\\Delta\\theta = \\theta_{ABC} - \\theta_{0} = 110^{\\circ} - 115^{\\circ} = -5^{\\circ}$。\n    转换为弧度：$\\Delta\\theta_{\\text{rad}} = -5 \\times \\frac{\\pi}{180} = -\\frac{\\pi}{36}$ 弧度。\n    代入数值 $k_{\\theta} = 40$ kJ/mol/弧度$^2$，$B_{AB} = 0.85$，和 $B_{BC} = 0.65$：\n    $$\n    E_{\\text{val}} = 40 \\times 0.85 \\times 0.65 \\times \\left(-\\frac{\\pi}{36}\\right)^2 = 22.1 \\times \\left(-\\frac{\\pi}{36}\\right)^2 \\approx 0.1683 \\, \\text{kJ/mol}\n    $$\n\n3.  **静电（库仑）能量 ($E_{\\text{coul}}$)**\n    库仑能量是对所有唯一的原子对（$A-B$、$A-C$、$B-C$）求和：\n    $$\n    E_{\\text{coul}} = \\sum_{i",
            "answer": "$$\n\\boxed{-424.4}\n$$"
        },
        {
            "introduction": "在ReaxFF中，随化学环境动态变化的原子电荷是精确描述体系静电相互作用的关键。这些电荷需要在分子动力学模拟的每一步通过电荷均衡（Charge Equilibration, QEq）方法重新计算。QEq方法本质上是在满足总电荷守恒的约束下，寻找一组使体系静电能最小化的电荷分布，这在数学上等价于求解一个大型的约束线性方程组。这项高级编程练习将挑战您设计并实现一个高效且符合物理约束的数值求解器（投影预条件共轭梯度法），让您深入掌握ReaxFF力场实现中最为核心且计算成本最高的算法之一。",
            "id": "3800883",
            "problem": "您的任务是设计并实现一个数值方案，用于求解在每个分子动力学（MD）步骤中，反应力场（ReaxFF）模型中出现的电荷平衡（QEq）线性系统。QEq 系统源于在总电荷约束下最小化一个关于原子电荷的二次能量。设存在 $n$ 个原子，其电荷向量为 $q \\in \\mathbb{R}^n$。能量是 $q$ 的一个二次泛函，其中包含一个对称正定的硬度耦合矩阵 $H \\in \\mathbb{R}^{n \\times n}$ 和一个电负性向量 $\\chi \\in \\mathbb{R}^n$。总电荷被约束为一个给定的标量 $Q \\in \\mathbb{R}$。在约束条件下最小化能量会得到一个带线性等式约束的 Karush–Kuhn–Tucker (KKT) 系统。您的工作是推导、实现并分析一个高效的求解器，该求解器使用预条件共轭梯度（PCG）方法，并设置停止容差为 $\\epsilon$，同时在每一步严格保持总电荷约束。\n\n从以下基本原理开始：\n- QEq 能量是 $q$ 的一个二次泛函，其中包含一个对称正定矩阵 $H$ 和一个线性项 $\\chi$，等式约束为 $\\sum_{i=1}^n q_i = Q$。\n- 在线性等式约束下最小化二次泛函会得到一个 KKT 系统。精确求解 KKT 系统可以简化为通过投影在约束的零空间上求解一个等效的对称正定系统。\n- 应用于对称正定算子的预条件共轭梯度（PCG）方法的收敛迭代次数取决于预处理后算子的条件数，每次迭代的成本为一次算子应用加上向量运算的成本。\n\n您的任务：\n1) 从第一性原理出发，推导出一个投影 PCG 方案，通过在总电荷约束的零空间上进行运算，来求解每个 MD 步骤中的 QEq 线性系统，确保迭代过程中的电荷始终满足 $\\sum_{i=1}^n q_i = Q$。清晰地定义被求逆的算子、右端向量以及用于强制执行约束的投影。提出一个简单的预条件子并说明其选择的理由。\n2) 根据残差范数和容差 $\\epsilon$ 指定一个停止规则，并根据 $n$ 和 PCG 迭代次数 $k$ 推导出每个 MD 步骤的渐进计算复杂度，假设稠密矩阵向量乘法的成本为 $O(n^2)$。\n3) 在一个完整、可运行的程序中实现您的方案，该程序能从提供的测试配置中构建物理上合理的 QEq 矩阵 $H$ 和向量 $\\chi$。对非对角耦合使用屏蔽库仑相互作用模型，并在对角线上使用正的自硬度，以保持对称性和正定性。求解器必须通过适当的投影，在每次迭代中确保总电荷约束在数值精度范围内得到精确满足。\n\n屏蔽库仑模型构建指南：\n- 对于原子位置 $\\{r_i\\}_{i=1}^n \\subset \\mathbb{R}^3$，通过 $H_{ij} = \\dfrac{\\kappa}{\\sqrt{\\lVert r_i - r_j \\rVert^2 + \\delta^2}}$（对于 $i \\neq j$）定义非对角耦合，其中 $\\kappa > 0$ 且 $\\delta > 0$。\n- 对角线元素为 $H_{ii} = \\eta_i > 0$，即自硬度参数。\n- 电负性 $\\chi_i$ 是给定的标量。电荷 $q_i$ 必须以基本电荷单位报告。\n\n停止规则说明：\n- 使用投影残差 $r$，当 $\\lVert r \\rVert_2 \\le \\epsilon \\lVert b \\rVert_2$ 时终止，其中 $b$ 是适用于该约束系统的投影右端项。\n\n输出要求：\n- 对于每个测试用例，返回一个列表，包含：整数迭代次数 $k$、最终残差范数的浮点数、电荷总和与 $Q$ 的偏差的浮点数（应接近 0）、与 $n^2 k$ 成正比的整数复杂度估计，以及电荷列表 $q$（以基本电荷单位表示的浮点数）。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，\"[result1,result2,...]\"）。\n\n测试套件：\n使用以下四个测试用例。除位置坐标（在测试构建中单位一致的任意长度单位）外，所有量均为无量纲数，电荷以基本电荷单位 $e$ 报告。\n\n- 用例 A (常规情况):\n    - $n = 5$,\n    - 位置 $r_1 = (0.0, 0.0, 0.0)$, $r_2 = (1.2, 0.0, 0.0)$, $r_3 = (0.0, 1.0, 0.0)$, $r_4 = (0.0, 0.0, 1.5)$, $r_5 = (1.0, 1.0, 1.0)$,\n    - $\\kappa = 1.0$, $\\delta = 0.2$,\n    - 自硬度 $\\eta = [9.0, 10.0, 11.0, 9.5, 10.5]$,\n    - 电负性 $\\chi = [-5.0, -5.2, -5.1, -4.9, -5.3]$,\n    - 总电荷 $Q = 0.0$,\n    - 容差 $\\epsilon = 10^{-8}$.\n\n- 用例 B (边界维度):\n    - $n = 1$,\n    - 位置 $r_1 = (0.0, 0.0, 0.0)$,\n    - 无非对角相互作用,\n    - $H = [12.0]$,\n    - $\\chi = [-5.0]$,\n    - 总电荷 $Q = 0.3$,\n    - 容差 $\\epsilon = 10^{-10}$.\n\n- 用例 C (病态但可解):\n    - $n = 12$,\n    - 位置 $r_i = (0.8 \\cdot (i-1), 0.0, 0.0)$ for $i = 1, 2, \\dots, 12$,\n    - $\\kappa = 1.0$, $\\delta = 0.05$,\n    - 自硬度 $\\eta_i = 8.0$ for all $i$,\n    - 电负性 $\\chi_i = -5.0 + 0.1 \\sin(i)$ for $i = 1, 2, \\dots, 12$,\n    - 总电荷 $Q = 0.0$,\n    - 容差 $\\epsilon = 10^{-10}$.\n\n- 用例 D (严格容差):\n    - $n = 8$,\n    - 位置 $r_i$ 由 $r_1 = (0.0, 0.0, 0.0)$, $r_2 = (0.7, 0.1, 0.0)$, $r_3 = (0.1, 0.8, 0.2)$, $r_4 = (0.0, 0.2, 0.9)$, $r_5 = (0.9, 0.9, 0.1)$, $r_6 = (1.2, 0.3, 0.4)$, $r_7 = (0.4, 1.1, 0.5)$, $r_8 = (0.6, 0.6, 1.0)$ 给出,\n    - $\\kappa = 1.0$, $\\delta = 0.1$,\n    - 自硬度 $\\eta = [10.0, 10.0, 9.5, 9.5, 11.0, 10.5, 10.0, 9.8]$,\n    - 电负性 $\\chi = [-5.1, -5.0, -4.9, -5.2, -5.3, -5.1, -5.0, -5.2]$,\n    - 总电荷 $Q = 0.0$,\n    - 容差 $\\epsilon = 10^{-12}$.\n\n所有电荷必须以基本电荷单位 $e$ 报告。您的实现必须是自包含的，并使用雅可比预条件子（对角预条件），在每次迭代中显式投影到约束的零空间，以在数值精度范围内保持 $\\sum_{i=1}^n q_i = Q$。复杂度估计必须报告为与稠密矩阵向量乘法的 $n^2 k$ 成正比的整数。您的程序必须无需用户输入即可按原样运行，并以单个打印语句生成上述指定的精确输出格式。",
            "solution": "在电荷平衡（QEq）模型中计算平衡原子电荷 $q_i$ 的问题是一个约束二次最小化问题。我们的任务是为该问题推导并实现一个投影预条件共轭梯度（PCG）求解器，确保在每次迭代中都满足总电荷约束。\n\n### 1. 数学公式\n\n一个包含 $n$ 个原子，电荷为 $q = (q_1, \\dots, q_n)^T \\in \\mathbb{R}^n$ 的系统的 QEq 能量 $E(q)$ 由一个二次泛函给出：\n$$\nE(q) = \\chi^T q + \\frac{1}{2} q^T H q\n$$\n其中 $\\chi \\in \\mathbb{R}^n$ 是电负性向量，而 $H \\in \\mathbb{R}^{n \\times n}$ 是对称正定的硬度耦合矩阵。电荷必须满足固定总电荷 $Q \\in \\mathbb{R}$ 的约束：\n$$\n\\sum_{i=1}^n q_i = 1^T q = Q\n$$\n其中 $1$ 是全为一的向量。问题是找到使 $E(q)$ 在此约束条件下最小化的电荷向量 $q$。\n\n为解决这个约束优化问题，我们引入一个拉格朗日乘子 $\\lambda$ 并构造拉格朗日量 $\\mathcal{L}(q, \\lambda)$:\n$$\n\\mathcal{L}(q, \\lambda) = E(q) - \\lambda(1^T q - Q) = \\chi^T q + \\frac{1}{2} q^T H q - \\lambda(1^T q - Q)\n$$\n最小化的一阶必要条件（Karush-Kuhn-Tucker 条件）通过将关于 $q$ 和 $\\lambda$ 的梯度设为零来找到：\n$$\n\\nabla_q \\mathcal{L} = \\chi + Hq - \\lambda 1 = 0 \\implies Hq + \\chi = \\lambda 1\n$$\n$$\n\\nabla_\\lambda \\mathcal{L} = -(1^T q - Q) = 0 \\implies 1^T q = Q\n$$\n这构成一个块线性系统，称为 KKT 系统：\n$$\n\\begin{pmatrix} H  -1 \\\\ -1^T  0 \\end{pmatrix} \\begin{pmatrix} q \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} -\\chi \\\\ -Q \\end{pmatrix}\n$$\n这个 $(n+1) \\times (n+1)$ 的矩阵是对称但非定的，这使其不适用于标准的共轭梯度法。\n\n### 2. 投影方法\n\n为了高效地求解这个系统，我们使用一种投影方法，专门在满足约束齐次形式的向量子空间中进行运算。任何有效的电荷向量 $q$ 都可以分解为 $q = q_{part} + q_{null}$，其中 $q_{part}$ 是一个满足 $1^T q_{part} = Q$ 的特解，而 $q_{null}$ 位于约束的零空间中，即 $1^T q_{null} = 0$。对于特解，一个简单的选择是均匀分配电荷：$q_{part} = \\frac{Q}{n} 1$。然后我们求解修正量 $q_{null}$。\n\n我们定义一个投影算子 $P$，它将任何向量投影到 $1^T$ 的零空间上。该算子为：\n$$\nP = I - \\frac{1}{n} 1 1^T\n$$\n其中 $I$ 是 $n \\times n$ 的单位矩阵。对于任何向量 $v \\in \\mathbb{R}^n$，有 $1^T(Pv)=0$。该算子是对称的（$P=P^T$）且是幂等的（$P^2=P$）。\n\n将这个投影应用于第一个 KKT 方程 $Hq + \\chi = \\lambda 1$，我们得到：\n$$\nP(Hq + \\chi) = P(\\lambda 1)\n$$\n由于 $P1 = (I - \\frac{1}{n} 1 1^T)1 = 1 - \\frac{1}{n}1(1^T1) = 1 - \\frac{1}{n}1(n) = 0$，右侧消失：\n$$\nP(Hq + \\chi) = 0\n$$\n这个方程必须求解一个同时满足 $1^Tq=Q$ 的 $q$。我们从一个满足约束的初始猜测 $q^{(0)}$ 开始，例如 $q^{(0)} = \\frac{Q}{n} 1$。迭代方法的目标是找到一个修正量 $\\delta q$，使得 $q = q^{(0)} + \\delta q$ 是解，并且 $1^T \\delta q = 0$。\n投影后的方程变为：\n$$\nP(H(q^{(0)} + \\delta q) + \\chi) = 0 \\implies P H \\delta q = -P(Hq^{(0)} + \\chi)\n$$\n由于 $\\delta q$ 在零空间中，所以 $P\\delta q = \\delta q$。我们可以更对称地写出系统：\n$$\n(PHP) \\delta q = -P(Hq^{(0)} + \\chi)\n$$\n这定义了一个线性系统 $A_p x = b_p$，其中算子是 $A_p = PHP$，未知数是 $x = \\delta q$，右端项是 $b_p = -P(Hq^{(0)} + \\chi)$。算子 $A_p$ 在由 $1^T x = 0$ 定义的零空间上是对称且正定的。因此，该系统适合使用共轭梯度法求解。\n\n### 3. 投影预条件共轭梯度（PCG）算法\n\nPCG 算法是求解 $Ax=b$ 系统的一种迭代方法，其中 $A$ 是对称正定的。我们将其应用于我们的投影系统。我们可以不显式地构造 $\\delta q$，而是用总电荷向量 $q$ 来表述算法，确保所有的搜索方向和残差都被投影到约束的零空间中。\n\n被求逆的算子是 $A_p = PHP$。右端项是 $b_p$，即初始投影残差。预条件子 $M$ 用于通过找到 $A_p$ 的近似逆来加速收敛。问题指定了雅可比预条件子，即 $H$ 的对角线，所以 $M = \\text{Diag}(H)$。预处理步骤涉及求解 $Mz=r$（这是一个简单的逐元素除法），然后投影结果：$\\tilde{z} = P(M^{-1}r)$。\n\n详细算法如下：\n\n1.  **初始化** ($k=0$):\n    *   设置初始猜测 $q^{(0)} = (Q/n) \\cdot 1$。\n    *   计算初始完整梯度 $g^{(0)} = H q^{(0)} + \\chi$。\n    *   计算初始投影残差 $r^{(0)} = -P g^{(0)} = -(g^{(0)} - \\frac{1}{n}(1^T g^{(0)})1)$。\n    *   定义投影右端项 $b_{p} = r^{(0)}$。\n    *   设置停止准则范数：$\\tau = \\epsilon \\lVert b_{p} \\rVert_2$。\n    *   如果 $\\lVert r^{(0)} \\rVert_2 \\le \\tau$，算法以 $k=0$ 次迭代终止。\n    *   应用预条件子：求解 $M z^{(0)} = r^{(0)}$，其中 $M = \\text{Diag}(H)$。$z^{(0)}_i = r^{(0)}_i / H_{ii}$。\n    *   投影预处理后的残差：$\\tilde{z}^{(0)} = P z^{(0)}$。\n    *   设置第一个搜索方向：$p^{(0)} = \\tilde{z}^{(0)}$。\n\n2.  **迭代循环** (for $k=0, 1, 2, \\dots$):\n    *   计算矩阵向量乘积与搜索方向：$v = H p^{(k)}$。\n    *   计算步长：$\\alpha_k = (r^{(k)T} \\tilde{z}^{(k)}) / (p^{(k)T} v)$。注意：由于 $1^T p^{(k)}=0$，所以 $p^{(k)T} (P v) = p^{(k)T} v$。\n    *   更新解：$q^{(k+1)} = q^{(k)} + \\alpha_k p^{(k)}$。（约束 $1^T q^{(k+1)}=Q$ 得到保持，因为 $1^T p^{(k)}=0$）。\n    *   投影矩阵向量乘积以更新残差：$v_p = P v = v - \\frac{1}{n}(1^T v)1$。\n    *   更新残差：$r^{(k+1)} = r^{(k)} - \\alpha_k v_p$。（确保 $r^{(k+1)}$ 保持在零空间中）。\n    *   检查收敛性：如果 $\\lVert r^{(k+1)} \\rVert_2 \\le \\tau$，则将 $k \\to k+1$ 并终止。\n    *   应用预条件子：求解 $M z^{(k+1)} = r^{(k+1)}$。\n    *   投影预处理后的残差：$\\tilde{z}^{(k+1)} = P z^{(k+1)}$。\n    *   计算 Polak-Ribière 参数：$\\beta_k = (r^{(k+1)T} \\tilde{z}^{(k+1)}) / (r^{(k)T} \\tilde{z}^{(k)})$。\n    *   更新搜索方向：$p^{(k+1)} = \\tilde{z}^{(k+1)} + \\beta_k p^{(k)}$。\n\n选择雅可比预条件子（$M=\\text{Diag}(H)$）的理由是其简单和高效。其构建和求逆的成本可忽略不计（$O(n)$），并且它能捕捉硬度矩阵 $H$ 的主要对角项，通常能显著改善条件数，从而加速收敛。\n\n### 4. 计算复杂度\n\n每个 MD 步骤的复杂度主要由 PCG 求解器决定。设置成本，包括构建稠密矩阵 $H$，为 $O(n^2)$。在每次 PCG 迭代中，最昂贵的操作是稠密矩阵向量乘积 $H p^{(k)}$，成本为 $O(n^2)$。所有其他操作（向量加法、点积、投影、预处理）的复杂度均为 $O(n)$。因此，如果求解器需要 $k$ 次迭代才能收敛，PCG 部分的总计算复杂度为 $O(k \\cdot n^2)$。每个 MD 步骤的总复杂度为 $O(n^2 + k \\cdot n^2) = O((k+1)n^2)$。按要求，复杂度估计将报告为与 $n^2 k$ 成正比的整数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the QEq solver.\n    This function is self-contained and adheres to the specified execution environment.\n    \"\"\"\n\n    test_cases = {\n        \"A\": {\n            \"n\": 5,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], [1.2, 0.0, 0.0], [0.0, 1.0, 0.0],\n                [0.0, 0.0, 1.5], [1.0, 1.0, 1.0]\n            ]),\n            \"kappa\": 1.0,\n            \"delta\": 0.2,\n            \"eta\": np.array([9.0, 10.0, 11.0, 9.5, 10.5]),\n            \"chi\": np.array([-5.0, -5.2, -5.1, -4.9, -5.3]),\n            \"Q\": 0.0,\n            \"epsilon\": 1e-8\n        },\n        \"B\": {\n            \"n\": 1,\n            \"positions\": np.array([[0.0, 0.0, 0.0]]),\n            \"H\": np.array([[12.0]]),\n            \"chi\": np.array([-5.0]),\n            \"Q\": 0.3,\n            \"epsilon\": 1e-10\n        },\n        \"C\": {\n            \"n\": 12,\n            \"positions\": np.array([[0.8 * i, 0.0, 0.0] for i in range(12)]),\n            \"kappa\": 1.0,\n            \"delta\": 0.05,\n            \"eta\": np.full(12, 8.0),\n            \"chi\": np.array([-5.0 + 0.1 * np.sin(i + 1) for i in range(12)]),\n            \"Q\": 0.0,\n            \"epsilon\": 1e-10\n        },\n        \"D\": {\n            \"n\": 8,\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], [0.7, 0.1, 0.0], [0.1, 0.8, 0.2], [0.0, 0.2, 0.9],\n                [0.9, 0.9, 0.1], [1.2, 0.3, 0.4], [0.4, 1.1, 0.5], [0.6, 0.6, 1.0]\n            ]),\n            \"kappa\": 1.0,\n            \"delta\": 0.1,\n            \"eta\": np.array([10.0, 10.0, 9.5, 9.5, 11.0, 10.5, 10.0, 9.8]),\n            \"chi\": np.array([-5.1, -5.0, -4.9, -5.2, -5.3, -5.1, -5.0, -5.2]),\n            \"Q\": 0.0,\n            \"epsilon\": 1e-12\n        }\n    }\n\n    def build_system(params):\n        \"\"\"Constructs the H matrix and chi vector.\"\"\"\n        if params['n'] > 1 and \"H\" not in params:\n            n = params['n']\n            positions = params['positions']\n            kappa = params['kappa']\n            delta = params['delta']\n            eta = params['eta']\n            \n            H = np.zeros((n, n))\n            for i in range(n):\n                H[i, i] = eta[i]\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(positions[i] - positions[j])\n                    val = kappa / np.sqrt(dist**2 + delta**2)\n                    H[i, j] = val\n                    H[j, i] = val\n            return H, params['chi']\n        else:\n            return params['H'], params['chi']\n\n    def solve_qeq_projected_pcg(H, chi, Q, epsilon, n):\n        \"\"\"\n        Solves the QEq system using a projected Preconditioned Conjugate Gradient method.\n        \"\"\"\n        if n == 1:\n            q = np.array([Q])\n            final_res_norm = 0.0\n            charge_dev = 0.0\n            k = 0\n            complexity = 0\n            return [k, final_res_norm, charge_dev, complexity, list(q)]\n        \n        # Projection operator P(v) = v - mean(v)\n        def project(v):\n            return v - np.mean(v)\n\n        # --- Algorithm Initialization ---\n        k = 0\n        q = (Q / n) * np.ones(n)\n        \n        g = H @ q + chi\n        r = -project(g)\n        \n        b_proj = r.copy()\n        b_norm = np.linalg.norm(b_proj)\n\n        # Handle case where initial guess is the solution\n        if b_norm == 0:\n            final_res_norm = 0.0\n            charge_dev = np.sum(q) - Q\n            complexity = int(n**2 * k)\n            return [k, final_res_norm, charge_dev, complexity, list(q)]\n\n        stop_tol = epsilon * b_norm\n        r_norm = np.linalg.norm(r)\n        \n        if r_norm = stop_tol:\n            final_res_norm = r_norm\n            charge_dev = np.sum(q) - Q\n            complexity = int(n**2 * k)\n            return [k, final_res_norm, charge_dev, complexity, list(q)]\n            \n        diag_H = np.diag(H)\n        z = r / diag_H\n        z_tilde = project(z)\n        p = z_tilde.copy()\n        \n        rz_old = np.dot(r, z_tilde)\n        \n        max_iter = 5 * n # A safe upper bound for iterations\n\n        # --- PCG Iteration Loop ---\n        for k_iter in range(1, max_iter + 1):\n            Hp = H @ p\n            \n            # Optimization: p is projected, so p.T @ P(Hp) = p.T @ Hp\n            p_Hp = np.dot(p, Hp)\n            \n            # Should not happen with SPD matrix, but for safety\n            if p_Hp = 0:\n                # Fallback to steepest descent if curvature is not positive\n                # In this problem, H is SPD on the nullspace, so this is unlikely\n                # but good practice for robustness.\n                p = r.copy()\n                Hp = H @ p\n                p_Hp = np.dot(p, Hp)\n                if p_Hp = 0: # If still failing, system is likely not SPD\n                    break\n            \n            alpha = rz_old / p_Hp\n            \n            q += alpha * p\n            \n            # Residual update needs the projected matrix-vector product\n            v_p = project(Hp)\n            r -= alpha * v_p\n            \n            r_norm = np.linalg.norm(r)\n            if r_norm = stop_tol:\n                k = k_iter\n                break\n                \n            z = r / diag_H\n            z_tilde = project(z)\n            \n            rz_new = np.dot(r, z_tilde)\n            beta = rz_new / rz_old\n            \n            p = z_tilde + beta * p\n            rz_old = rz_new\n        else: # if loop finished without break\n            k = max_iter\n\n        final_res_norm = r_norm\n        charge_dev = np.sum(q) - Q\n        complexity = int(n**2 * k)\n        \n        return [k, final_res_norm, charge_dev, complexity, list(q)]\n\n    results_str = []\n    for case_name in sorted(test_cases.keys()):\n        params = test_cases[case_name]\n        H, chi = build_system(params)\n        \n        result_list = solve_qeq_projected_pcg(H, chi, params['Q'], params['epsilon'], params['n'])\n        \n        k, res_norm, charge_dev, complexity, q_list = result_list\n        \n        # Format the output string for this case\n        q_str = f\"[{','.join(f'{x:.15e}' for x in q_list)}]\"\n        case_result_str = (f\"[{k},{res_norm:.15e},{charge_dev:.15e},\"\n                           f\"{complexity},{q_str}]\")\n        results_str.append(case_result_str)\n        \n    # Print the final single-line output\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n\n```"
        }
    ]
}