{
    "hands_on_practices": [
        {
            "introduction": "修正嵌入原子方法 (MEAM) 势的核心是嵌入能项，它依赖于每个原子所在位置的背景电子密度。在深入研究角度依赖性和屏蔽效应等复杂概念之前，我们必须首先掌握如何计算这个基本的背景电子密度。这项练习  将引导您在一个理想的面心立方 (fcc) 晶体中，通过对最近邻原子贡献进行求和，来计算这个零阶电子密度。这个基本计算不仅能巩固您对晶体几何学的理解，也为构建更复杂的 MEAM 模型奠定了坚实的基础。",
            "id": "3782223",
            "problem": "考虑一个晶格常数为 $a$、处于零温下的完美单原子面心立方（fcc）晶体。在修正嵌入原子方法（MEAM）中，位于 $i$ 位点的原子的嵌入能表示为该位点背景电子密度 $\\rho_i$ 的函数，而该背景电子密度由相邻原子的贡献构成。假设以下物理上标准的条件：\n\n- 单个孤立原子的原子电子密度是球对称且严格径向衰减的，记为 $\\rho_a(r)$，其中 $r$ 是与原子的标量距离。\n- 环境是理想的 fcc 晶格，没有缺陷或遮蔽，因此对相邻原子贡献的屏蔽是完全的且等于1，空间对称性是立方的。\n- 在构建 $\\rho_i$ 时，仅考虑最近邻壳层，并且基于立方对称性和 $\\rho_a(r)$ 的球对称形式，可以忽略角度依赖的贡献。\n\n从 MEAM 的核心概念出发，即 $i$ 位点的背景电子密度 $\\rho_i$ 是通过对来自相邻原子的球对称原子电子密度贡献求和来构建的，请仅使用 fcc 晶格的最近邻壳层，计算 $\\rho_i$ 关于 $a$ 和 $\\rho_a(r)$ 的闭式解析表达式。你的最终答案必须是单个闭式解析表达式。不需要数值近似，也无需报告单位。",
            "solution": "问题要求计算在一个完美面心立方（fcc）晶体中，原子位点 $i$ 处的背景电子密度 $\\rho_i$ 的闭式解析表达式。计算将在修正嵌入原子方法（MEAM）的框架下进行，并简化为只包含最近邻壳层的贡献，忽略角度依赖项。\n\n根据问题陈述，位点 $i$ 处的背景电子密度 $\\rho_i$ 是通过其相邻原子的球对称原子电子密度贡献 $\\rho_a(r)$ 的线性叠加来构建的。根据只考虑最近邻壳层的要求，$\\rho_i$ 的表达式为：\n$$\n\\rho_i = \\sum_{j \\in \\text{NN}(i)} \\rho_a(r_{ij})\n$$\n其中 $\\text{NN}(i)$ 是原子 $i$ 的最近邻原子集合，$r_{ij}$ 是原子 $i$ 与其相邻原子 $j$ 之间的距离。\n\n对于完美的晶体结构，每个原子都处于相同的环境中。因此，我们可以不失一般性地将参考原子 $i$ 置于坐标系的原点。在完美晶格中，所有最近邻原子都处于相同的距离，我们将其记为 $r_{\\text{NN}}$。这些最近邻原子的数量是晶格的第一配位数，我们将其记为 $Z_{\\text{NN}}$。\n\n因此，求和可以被简化。由于对于所有 $j \\in \\text{NN}(i)$，都有 $\\rho_a(r_{ij}) = \\rho_a(r_{\\text{NN}})$，所以求和变成了一个乘积：\n$$\n\\rho_i = Z_{\\text{NN}} \\cdot \\rho_a(r_{\\text{NN}})\n$$\n为了继续计算，我们必须确定 fcc 晶格结构中 $Z_{\\text{NN}}$ 和 $r_{\\text{NN}}$ 的值，并用晶格常数 $a$ 来表示它们。\n\nfcc 晶格的常规晶胞是一个边长为 $a$ 的立方体，其 8 个顶点和 6 个面心都有原子。我们将一个参考原子置于原点，坐标为 $(0, 0, 0)$。其相邻原子的位置可以被确定。\n\n立方体顶点的原子位于诸如 $(a, 0, 0)$、$(0, a, 0)$ 等位置。到这些原子的距离是 $a$。\n面心的原子位于诸如 $(\\frac{a}{2}, \\frac{a}{2}, 0)$、$(\\frac{a}{2}, 0, \\frac{a}{2})$、$(0, \\frac{a}{2}, \\frac{a}{2})$ 以及它们带符号的排列组合位置。从原点到位于 $(\\frac{a}{2}, \\frac{a}{2}, 0)$ 的原子的距离是：\n$$\nr = \\sqrt{\\left(\\frac{a}{2}\\right)^2 + \\left(\\frac{a}{2}\\right)^2 + 0^2} = \\sqrt{\\frac{a^2}{4} + \\frac{a^2}{4}} = \\sqrt{\\frac{2a^2}{4}} = \\sqrt{\\frac{a^2}{2}} = \\frac{a}{\\sqrt{2}}\n$$\n我们必须将这个距离与到顶点原子的距离 $a$ 进行比较。由于 $\\frac{1}{\\sqrt{2}} \\approx 0.707$，我们有 $\\frac{a}{\\sqrt{2}}  a$。因此，面心原子是最近邻。最近邻距离为：\n$$\nr_{\\text{NN}} = \\frac{a}{\\sqrt{2}}\n$$\n接下来，我们确定配位数 $Z_{\\text{NN}}$。对于位于原点的参考原子，其最近邻是与该顶点相交的立方体面心上的原子。在正确的距离上有 12 个这样的面心原子。它们相对于原点的坐标由 $(\\pm \\frac{a}{2}, \\pm \\frac{a}{2}, 0)$ 的所有非零排列给出。这些是：\n- 在 $xy$ 平面内：$(\\frac{a}{2}, \\frac{a}{2}, 0)$, $(\\frac{a}{2}, -\\frac{a}{2}, 0)$, $(-\\frac{a}{2}, \\frac{a}{2}, 0)$, $(-\\frac{a}{2}, -\\frac{a}{2}, 0)$。这是 4 个邻居。\n- 在 $xz$ 平面内：$(\\frac{a}{2}, 0, \\frac{a}{2})$, $(\\frac{a}{2}, 0, -\\frac{a}{2})$, $(-\\frac{a}{2}, 0, \\frac{a}{2})$, $(-\\frac{a}{2}, 0, -\\frac{a}{2})$。这是 4 个邻居。\n- 在 $yz$ 平面内：$(0, \\frac{a}{2}, \\frac{a}{2})$, $(0, \\frac{a}{2}, -\\frac{a}{2})$, $(0, -\\frac{a}{2}, \\frac{a}{2})$, $(0, -\\frac{a}{2}, -\\frac{a}{2})$。这是 4 个邻居。\n\n将这些相加，总共有 $4 + 4 + 4 = 12$ 个最近邻原子。因此，fcc 晶格的第一配位数为：\n$$\nZ_{\\text{NN}} = 12\n$$\n现在，我们可以将推导出的 $Z_{\\text{NN}}$ 和 $r_{\\text{NN}}$ 的值代回到 $\\rho_i$ 的表达式中：\n$$\n\\rho_i = Z_{\\text{NN}} \\cdot \\rho_a(r_{\\text{NN}}) = 12 \\cdot \\rho_a\\left(\\frac{a}{\\sqrt{2}}\\right)\n$$\n该表达式代表了在所提供的简化的 MEAM 假设下，完美 fcc 晶体中任意原子位点上的零阶背景电子密度。忽略角度贡献是合理的，因为 fcc 晶格中最近邻壳层具有高度对称性，这将导致完整 MEAM 中的一阶角度依赖项求和为零。屏蔽因子为1是 MEAM 的一个核心概念，但它不进入本次特定计算，因为它应用于部分（角度）电子密度的构建，而根据问题陈述这部分已被排除。",
            "answer": "$$\\boxed{12 \\rho_a\\left(\\frac{a}{\\sqrt{2}}\\right)}$$"
        },
        {
            "introduction": "MEAM 与其前身 EAM 的关键区别在于引入了对原子间相互作用的“屏蔽”效应。这种多体效应使得原子间的有效作用力取决于其局部几何环境。这项练习  提供了一个理想化的一维原子链模型，让您能够精确地分析并计算屏蔽因子 $S_{ij}$。通过对比最近邻和次近邻原子对所受到的屏蔽差异，您将深刻理解屏蔽效应是如何从根本上改变相互作用的性质，特别是当一个原子恰好位于另外两个原子之间时，会产生完全屏蔽这一戏剧性结果。",
            "id": "3782093",
            "problem": "考虑修正嵌入原子方法 (MEAM) 势，其中原子间的对相互作用会因其他原子的存在而被乘法屏蔽。在 MEAM 中，原子 $i$ 和 $j$ 之间的屏蔽因子定义为 $S_{ij} = \\prod_{k \\neq i,j} S_{ikj}$，其中每个三体因子 $S_{ikj}$ 取决于三元组 $(i,k,j)$ 周围的局域几何结构。对于一个由相同原子组成的无限长线性链，原子位于 $x$ 轴上，位置为 $x_n = n a$，具有均匀间距 $a  0$，假设其具有以下特定的、受几何结构启发的连续屏蔽形式：\n$$\nS_{ikj} = \\frac{\\left(r_{ik} + r_{kj} - r_{ij}\\right)^{2}}{\\left(r_{ik} + r_{kj} - r_{ij}\\right)^{2} + d_{0}^{2}},\n$$\n其中 $r_{pq}$ 表示原子 $p$ 和 $q$ 之间的欧几里得距离，$d_{0}  0$ 是一个特征屏蔽软度长度标度，用于正则化完全屏蔽和未屏蔽构型之间的转变。\n\n从 MEAM 定义 $S_{ij} = \\prod_{k \\neq i,j} S_{ikj}$ 和一维链所蕴含的几何距离出发，推导以下情况的屏蔽因子：\n- 间距为 $r_{ij} = a$ 的最近邻，以及\n- 间距为 $r_{ij} = 2 a$ 的次近邻。\n\n定性地说明为何这些屏蔽因子在线性链中有所不同，然后在给定的 $S_{ikj}$ 形式下，计算这两种情况的闭式解析表达式。将最终答案表示为一个双元素行向量，其第一个元素是最近邻屏蔽因子，第二个元素是次近邻屏蔽因子，用 $a$ 和 $d_{0}$ 表示。不需要进行数值取整，应提供精确表达式。",
            "solution": "### 屏蔽因子的推导\n\n计算的核心在于三体屏蔽项 $S_{ikj}$，它依赖于量 $\\Delta_{ikj} = r_{ik} + r_{kj} - r_{ij}$。对于线性链，原子位于间距 $a$ 的整数倍位置上。不失一般性，我们将原子 $i$ 置于原点，$x_i=0$。任意原子 $p$ 的位置为 $x_p = p a$。距离为 $r_{pq} = |p-q|a$。\n\n量 $\\Delta_{ikj}$ 变为：\n$$\n\\Delta_{ikj} = (|k-i|a + |j-k|a - |j-i|a) = (|k| + |j-k| - |j|)a\n$$\n其中我们已设 $i=0$。关键的洞见在于，当且仅当原子 $k$ 位于连接原子 $i$ 和 $j$ 的线段上时，$\\Delta_{ikj} = 0$。对于我们的离散链，这意味着代表原子 $i$ 和 $j$ 的整数之间严格存在一个整数 $k$。如果 $\\Delta_{ikj} = 0$，那么 $S_{ikj} = \\frac{0^2}{0^2 + d_0^2} = 0$。这意味着完美屏蔽。\n\n#### 情况 1：最近邻屏蔽因子 ($S_{NN}$)\n\n我们考虑两个最近邻原子，比如位于位置 $i=0$ 和 $j=1$ 的原子。距离是 $r_{01} = a$。总屏蔽因子是所有其他原子 $k \\in \\mathbb{Z}$（其中 $k \\neq 0$ 且 $k \\neq 1$）的乘积。\n$$\nS_{NN} = S_{01} = \\prod_{k \\in \\mathbb{Z} \\setminus \\{0,1\\}} S_{0k1}\n$$\n对于这对原子，量 $\\Delta_{0k1}$ 为：\n$$\n\\Delta_{0k1} = (|k| + |1-k| - |1|)a = (|k| + |1-k| - 1)a\n$$\n屏蔽原子 $k$ 是整数。不存在整数 $k$ 使得 $0  k  1$。因此，没有原子位于原子 0 和 1 之间，$\\Delta_{0k1}$ 永远不为零。\n\n我们来计算屏蔽原子 $k$ 的 $\\Delta_{0k1}$：\n- 对于 $k > 1$（例如，$k=2, 3, \\dots$）：$\\Delta_{0k1} = (k + (k-1) - 1)a = (2k-2)a = 2(k-1)a$。\n- 对于 $k  0$（例如，$k=-1, -2, \\dots$）：$\\Delta_{0k1} = (-k + (1-k) - 1)a = (-2k)a$。\n\n$S_{01}$ 的乘积可以分成两部分：一部分用于 $k > 1$，另一部分用于 $k  0$。\n$$\nS_{01} = \\left( \\prod_{k=2}^{\\infty} S_{0k1} \\right) \\left( \\prod_{k=-\\infty}^{-1} S_{0k1} \\right)\n$$\n代入 $\\Delta_{0k1}$ 的表达式：\n$$\nS_{01} = \\left( \\prod_{k=2}^{\\infty} \\frac{(2(k-1)a)^2}{(2(k-1)a)^2 + d_0^2} \\right) \\left( \\prod_{k=-\\infty}^{-1} \\frac{(-2ka)^2}{(-2ka)^2 + d_0^2} \\right)\n$$\n让我们对乘积进行重新索引。在第一个乘积中，令 $n = k-1$；$n$ 从 $1$ 到 $\\infty$。在第二个乘积中，令 $n = -k$；$n$ 也从 $1$ 到 $\\infty$。\n$$\nS_{01} = \\left( \\prod_{n=1}^{\\infty} \\frac{(2na)^2}{(2na)^2 + d_0^2} \\right) \\left( \\prod_{n=1}^{\\infty} \\frac{(2na)^2}{(2na)^2 + d_0^2} \\right) = \\left( \\prod_{n=1}^{\\infty} \\frac{(2na)^2}{(2na)^2 + d_0^2} \\right)^2\n$$\n为了计算这个无穷乘积，我们使用双曲正弦函数的无穷乘积展开式：\n$$\n\\frac{\\sinh(\\pi z)}{\\pi z} = \\prod_{n=1}^{\\infty} \\left(1 + \\frac{z^2}{n^2}\\right)\n$$\n让我们重新整理我们的乘积项：\n$$\n\\frac{(2na)^2}{(2na)^2 + d_0^2} = \\frac{1}{1 + \\frac{d_0^2}{(2na)^2}} = \\frac{1}{1 + \\frac{(d_0/(2a))^2}{n^2}}\n$$\n该乘积变为：\n$$\n\\prod_{n=1}^{\\infty} \\frac{1}{1 + \\frac{(d_0/(2a))^2}{n^2}} = \\frac{1}{\\prod_{n=1}^{\\infty} \\left(1 + \\frac{(d_0/(2a))^2}{n^2}\\right)}\n$$\n通过在双曲正弦展开式中设置 $z = \\frac{d_0}{2a}$，我们得到：\n$$\n\\prod_{n=1}^{\\infty} \\left(1 + \\left(\\frac{d_0}{2a}\\right)^2 \\frac{1}{n^2}\\right) = \\frac{\\sinh\\left(\\frac{\\pi d_0}{2a}\\right)}{\\frac{\\pi d_0}{2a}}\n$$\n因此，$S_{01}$ 括号内的乘积是此表达式的倒数：\n$$\n\\prod_{n=1}^{\\infty} \\frac{(2na)^2}{(2na)^2 + d_0^2} = \\frac{\\frac{\\pi d_0}{2a}}{\\sinh\\left(\\frac{\\pi d_0}{2a}\\right)}\n$$\n最后，最近邻屏蔽因子是此结果的平方：\n$$\nS_{NN} = \\left( \\frac{\\frac{\\pi d_0}{2a}}{\\sinh\\left(\\frac{\\pi d_0}{2a}\\right)} \\right)^2\n$$\n\n#### 情况 2：次近邻屏蔽因子 ($S_{NNN}$)\n\n我们考虑两个次近邻原子，比如位于位置 $i=0$ 和 $j=2$ 的原子。距离是 $r_{02} = 2a$。总屏蔽因子是所有其他原子 $k \\in \\mathbb{Z}$（其中 $k \\neq 0$ 且 $k \\neq 2$）的乘积。\n$$\nS_{NNN} = S_{02} = \\prod_{k \\in \\mathbb{Z} \\setminus \\{0,2\\}} S_{0k2}\n$$\n这个乘积包括了来自 $k=1$ 处原子的项。我们来计算来自该原子的屏蔽贡献 $S_{012}$。量 $\\Delta_{012}$ 为：\n$$\n\\Delta_{012} = (|1-0|a + |2-1|a - |2-0|a) = (a + a - 2a) = 0\n$$\n由于 $\\Delta_{012}=0$，对应的三体屏蔽项为：\n$$\nS_{012} = \\frac{(\\Delta_{012})^2}{(\\Delta_{012})^2 + d_0^2} = \\frac{0^2}{0^2 + d_0^2} = 0\n$$\n总屏蔽因子 $S_{02}$ 是许多项的乘积，其中一项是 $S_{012}=0$。因此，整个乘积为零。\n$$\nS_{NNN} = S_{02} = S_{0(-1)2} \\cdots S_{012} \\cdots S_{032} \\cdots = 0\n$$\n\n#### 定性比较\n\n最近邻和次近邻的屏蔽因子因一维链的几何结构而根本不同。\n- 对于**最近邻**对（例如，位于 $0$ 和 $a$ 的原子），连接它们的线段上没有其他原子。因此，没有单个原子 $k$ 能提供“完美”屏蔽（对于所有 $k$ 都有 $\\Delta_{ikj} \\neq 0$）。总屏蔽 $S_{NN}$ 是无限链中所有其他原子累积的部分屏蔽的结果，从而产生一个非零值，该值取决于长度标度之比 $d_0/a$。\n- 对于**次近邻**对（例如，位于 $0$ 和 $2a$ 的原子），有一个原子（位于 $a$）正好位于它们之间的线段上。这个居间原子导致了完美屏蔽条件（$\\Delta_{012}=0$），使其屏蔽贡献 $S_{012}$ 等于零。因为总屏蔽因子 $S_{NNN}$ 是所有单个贡献的乘积，这个单一的零值项迫使整个屏蔽因子为零。这表明，在这个特定的 MEAM 模型中，次近邻之间的相互作用被位于它们之间的原子完全屏蔽了。\n\n最终答案是一个包含 $S_{NN}$ 和 $S_{NNN}$ 的双元素行向量。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\left( \\frac{\\frac{\\pi d_0}{2a}}{\\sinh\\left(\\frac{\\pi d_0}{2a}\\right)} \\right)^{2}  0 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "一个有效的原子间势不仅要能描述能量，还必须能够准确预测材料的宏观物理性质，并保证其在物理上是稳定的。这项实践  探讨了 MEAM 势的角度依赖参数 $t_k$ 与材料宏观弹性常数之间的深刻联系。您将学习如何将微观参数与立方晶体的 Born 稳定性判据联系起来，并实现一个算法来自动调整这些参数，以修正一个初始不稳定的势函数。这个练习模拟了势函数开发过程中的一个核心任务——参数校准与验证，展示了如何确保我们的计算模型遵循基本的物理定律。",
            "id": "3782204",
            "problem": "要求您形式化地阐述修正嵌入原子法（Modified Embedded Atom Method, MEAM）参数化如何通过角权重参数影响力学稳定性，并构建一个算法程序，在出现违背稳定性的情况时自动调整这些参数以恢复稳定性。修正嵌入原子法（MEAM）代表 Modified Embedded Atom Method。请从以下基本出发点开始：(i) 晶体固体的总能量可以通过一个依赖于原子对间距和局域电子密度的原子间势来近似；(ii) 在小均匀应变下，晶体固体的弹性响应由应力与应变之间的线性关系（胡克定律）定义；(iii) 对于立方晶体，Born 稳定性判据是二次弹性储能密度为正定的充要条件，它要求以下不等式成立：$C_{11}-C_{12}0$，$C_{44}0$，以及 $C_{11}+2C_{12}0$。在 MEAM 中，局域电子密度由径向和角向贡献构成，其中角权重参数 $t_k$ ($k=1,\\dots,m$) 控制高阶的取向依赖项。在参数 $t_k$ 围绕一个校准参考值发生小扰动时，弹性常数会根据以下形式的灵敏度关系发生一阶变化\n$$\n\\Delta \\boldsymbol{C} \\approx \\boldsymbol{S}\\,\\Delta \\boldsymbol{t},\n$$\n其中 $\\boldsymbol{C}=[C_{11},C_{12},C_{44}]^{\\top}$，$\\boldsymbol{t}=[t_1,\\dots,t_m]^{\\top}$，并且 $\\boldsymbol{S}\\in\\mathbb{R}^{3\\times m}$ 是一个灵敏度矩阵，它编码了弹性常数如何响应 MEAM 角权重的无穷小变化。令 $\\boldsymbol{C}^{(0)}$ 表示参考校准下的基准弹性常数（与灵敏度响应的单位相同），因此对于有限偏差，我们采用线性化模型\n$$\n\\boldsymbol{C}(\\boldsymbol{t}) \\approx \\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\,\\boldsymbol{t}.\n$$\n在本问题中，您将：(a) 证明 MEAM 角权重 $t_k$ 的不当取值可能违背 Born 稳定性判据，以及 (b) 实现一个程序来求解以下约束优化问题\n$$\n\\min_{\\boldsymbol{t}} \\;\\frac{1}{2}\\lVert \\boldsymbol{t}-\\boldsymbol{t}^{(0)}\\rVert_2^2 \\quad \\text{subject to} \\quad \\boldsymbol{A}\\,\\boldsymbol{C}(\\boldsymbol{t}) \\ge \\boldsymbol{0}, \\quad \\ell_k \\le t_k \\le u_k,\n$$\n其中 $\\boldsymbol{t}^{(0)}$ 是 MEAM 角权重的初始选择，$\\boldsymbol{A}$ 编码了立方晶体的线性 Born 约束，\n$$\n\\boldsymbol{A}=\\begin{bmatrix}1  -1  0\\\\ 0  0  1\\\\ 1  2  0\\end{bmatrix},\n$$\n并且 $\\ell_k,u_k$ 是 $t_k$ 的物理上合理的界限。对于每个测试用例，您的程序必须报告初始参数是否违背 Born 稳定性判据，以及调整程序是否在规定的界限内获得了稳定的解。\n\n所有弹性常数的计算都必须在一致的单位制下进行；弹性常数的单位取为吉帕斯卡（$\\mathrm{GPa}$）。最终程序不应接受任何用户输入，并且只应打印下面描述的所需输出行。\n\n请为以下测试套件实现您的解决方案，每个案例由 $(\\boldsymbol{C}^{(0)}, \\boldsymbol{S}, \\boldsymbol{t}^{(0)}, \\text{bounds})$ 定义：\n\n- 案例 1（理想情况，初始稳定）：\n  - $\\boldsymbol{C}^{(0)} = [\\,110,\\,60,\\,40\\,]$,\n  - $\\boldsymbol{S} = \\begin{bmatrix} 10  -5  0  0 \\\\ -8  3  1  0 \\\\ 2  -1  0.5  1 \\end{bmatrix}$,\n  - $\\boldsymbol{t}^{(0)} = [\\,0.1,\\,-0.2,\\,0.05,\\,0.0\\,]$,\n  - 所有 $k$ 的界限为 $t_k\\in[-1,1]$。\n- 案例 2（初始违背，可恢复）：\n  - $\\boldsymbol{C}^{(0)} = [\\,100,\\,50,\\,30\\,]$,\n  - $\\boldsymbol{S} = \\begin{bmatrix} -20  0  5  0 \\\\ 5  -15  0  0 \\\\ 0  0  -40  10 \\end{bmatrix}$,\n  - $\\boldsymbol{t}^{(0)} = [\\,0.0,\\,0.0,\\,1.0,\\,-0.5\\,]$,\n  - 所有 $k$ 的界限为 $t_k\\in[-1,1]$。\n- 案例 3（初始违背，界限内不可行）：\n  - $\\boldsymbol{C}^{(0)} = [\\,5,\\,6,\\,-2\\,]$,\n  - $\\boldsymbol{S} = \\begin{bmatrix} 0.5  0.5  0.5  0.5 \\\\ 0.5  0.4  0.3  0.2 \\\\ 0.1  0.1  0.1  0.1 \\end{bmatrix}$,\n  - $\\boldsymbol{t}^{(0)} = [\\,0.0,\\,0.0,\\,0.0,\\,0.0\\,]$,\n  - 所有 $k$ 的界限为 $t_k\\in[-0.3,0.3]$。\n\n对于每个测试用例，您的程序必须计算 $\\boldsymbol{C}(\\boldsymbol{t}^{(0)})$，确定是否违背 Born 判据，如有必要则求解约束调整问题以得到 $\\boldsymbol{t}^{\\star}$，然后用 $\\boldsymbol{C}(\\boldsymbol{t}^{\\star})$ 重新检查稳定性。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表，其中每个测试用例对应一个形式为 $[\\text{initial\\_violation},\\text{restored\\_stability}]$ 的双元素布尔值列表（无空格）。例如，您的输出应类似于 $[[\\text{b}_{1},\\text{b}_{2}],[\\text{b}_{3},\\text{b}_{4}],[\\text{b}_{5},\\text{b}_{6}]]$，其中每个 $\\text{b}_{i}$ 为 $\\text{True}$ 或 $\\text{False}$。",
            "solution": "本问题要求开发一个算法程序，用于分析和强制实现立方晶体的力学稳定性，该稳定性由修正嵌入原子法（MEAM）势描述。解决方案包括两个主要部分：(1) 在给定一组初始 MEAM 角权重参数的情况下，检查是否违背 Born 稳定性判据；(2) 如果存在违背，则求解一个约束优化问题，以找到恢复稳定性的最小参数调整。\n\n### 基于原理的设计\n\n1.  **物理模型与稳定性判据**：材料的力学稳定性是基础。对于小变形下的立方晶体，其弹性储能密度必须是正定的。如果弹性常数矩阵 $\\boldsymbol{C}$ 满足 Born 稳定性判据，则该条件得到保证：\n    $$\n    C_{11} - C_{12} > 0\n    $$\n    $$\n    C_{44} > 0\n    $$\n    $$\n    C_{11} + 2C_{12} > 0\n    $$\n    这三个线性不等式可以紧凑地写成矩阵形式。将弹性常数向量定义为 $\\boldsymbol{C} = [C_{11}, C_{12}, C_{44}]^\\top$，则该判据等价于 $\\boldsymbol{A}\\boldsymbol{C} > \\boldsymbol{0}$，其中矩阵 $\\boldsymbol{A}$ 如下所示：\n    $$\n    \\boldsymbol{A} = \\begin{bmatrix} 1  -1  0 \\\\ 0  0  1 \\\\ 1  2  0 \\end{bmatrix}\n    $$\n\n2.  **线性化 MEAM 模型**：问题提供了一个线性化模型，将 MEAM 角权重参数 $\\boldsymbol{t}=[t_1, \\dots, t_m]^\\top$ 与弹性常数 $\\boldsymbol{C}$ 联系起来：\n    $$\n    \\boldsymbol{C}(\\boldsymbol{t}) = \\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\boldsymbol{t}\n    $$\n    此处，$\\boldsymbol{C}^{(0)}$ 代表基准弹性常数，灵敏度矩阵 $\\boldsymbol{S}$ 量化了每个参数 $t_k$ 如何影响弹性常数。这种线性近似使得可调参数与力学稳定性之间建立了直接的数学联系。\n\n3.  **表述为约束优化问题**：当参数的初始选择 $\\boldsymbol{t}^{(0)}$ 导致违背 Born 判据时，我们寻求一组修正后的参数 $\\boldsymbol{t}$，使其在满足稳定性条件的同时，尽可能接近原始选择 $\\boldsymbol{t}^{(0)}$。这是一个经典的工程和科学问题，被形式化为一个约束优化问题。目标是最小化新参数与初始参数之间的欧几里得距离（或其平方），这鼓励最小的扰动。约束条件强制施加了物理和力学要求。\n    该优化问题为：\n    $$\n    \\min_{\\boldsymbol{t}} \\;\\frac{1}{2}\\lVert \\boldsymbol{t}-\\boldsymbol{t}^{(0)}\\rVert_2^2\n    $$\n    满足约束：\n    1.  **力学稳定性**：$\\boldsymbol{A}\\,\\boldsymbol{C}(\\boldsymbol{t}) \\ge \\boldsymbol{0}$\n    2.  **参数界限**：对所有 $k=1, \\dots, m$，$\\ell_k \\le t_k \\le u_k$。\n\n    将线性化模型代入稳定性约束，得到：\n    $$\n    \\boldsymbol{A}(\\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\boldsymbol{t}) \\ge \\boldsymbol{0} \\implies (\\boldsymbol{A}\\boldsymbol{S})\\boldsymbol{t} \\ge -\\boldsymbol{A}\\boldsymbol{C}^{(0)}\n    $$\n    这是一个线性不等式组。目标函数 $\\frac{1}{2}\\lVert \\boldsymbol{t}-\\boldsymbol{t}^{(0)}\\rVert_2^2 = \\frac{1}{2}\\sum_k (t_k - t_k^{(0)})^2$ 是一个严格凸的二次函数。约束（包括稳定性和界限）是线性的。这种特定结构定义了一个 **二次规划（Quadratic Programming, QP）** 问题。QP 问题是一类研究得很透彻的凸优化问题，如果存在可行解，则保证有唯一的全局最小值。\n\n4.  **算法流程与数值实现**：\n    每个测试用例的算法流程如下：\n    a.  **初始稳定性检查**：给定初始参数集 $\\boldsymbol{t}^{(0)}$，计算相应的弹性常数 $\\boldsymbol{C}_{initial} = \\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\boldsymbol{t}^{(0)}$。然后，评估 Born 稳定性判据 $\\boldsymbol{A}\\boldsymbol{C}_{initial} > \\boldsymbol{0}$。在数值实现中，此检查表示为 $\\boldsymbol{A}\\boldsymbol{C}_{initial} > \\epsilon$，其中 $\\epsilon$ 是一个小的正容差（例如 $10^{-9}$）。此检查确定 `initial_violation` 的状态。\n    b.  **条件优化**：\n        - 如果初始状态是稳定的（`initial_violation` 为 false），则无需任何操作。状态已经稳定，因此 `restored_stability` 为 true。\n        - 如果初始状态不稳定（`initial_violation` 为 true），则必须求解 QP 问题。我们使用序贯最小二乘规划（Sequential Least Squares Programming, SLSQP）算法，该算法在 `scipy.optimize.minimize` 中可用，非常适合此类问题。\n    c.  **优化后分析**：优化的结果决定了 `restored_stability`：\n        - 如果优化器未能收敛（例如 `success=False`），这意味着不存在同时满足稳定性和参数界限约束的解。问题是不可行的，无法恢复稳定性。因此，`restored_stability` 为 false。\n        - 如果优化器收敛到解 $\\boldsymbol{t}^{\\star}$（`success=True`），则会再次检查得到的弹性常数 $\\boldsymbol{C}_{final} = \\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\boldsymbol{t}^{\\star}$ 是否满足严格稳定性（$\\boldsymbol{A}\\boldsymbol{C}_{final} > \\epsilon$）。此优化的一个关键特征是，如果初始点 $\\boldsymbol{t}^{(0)}$ 不可行，最优解 $\\boldsymbol{t}^{\\star}$ 将位于可行域的边界上。这意味着至少有一个稳定性约束将是活动的（即等于零），例如 $C_{44} = 0$。这种状态被称为临界稳定，而非严格稳定。因此，严格稳定性检查（`> \\epsilon`）将会失败，并且 `restored_stability` 将被报告为 false。\n\n优化器所寻求的数值可行性（$\\ge 0$）与严格稳定性的物理要求（$ 0$）之间的这种严格区分，对于正确解释结果至关重要。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves a series of MEAM parameter stability problems by checking initial\n    stability and performing constrained optimization if necessary.\n    \"\"\"\n    # Define the constant matrix A for Born stability criteria and a tolerance for strict inequality.\n    A = np.array([\n        [1.0, -1.0, 0.0],\n        [0.0, 0.0, 1.0],\n        [1.0, 2.0, 0.0]\n    ])\n    STABILITY_TOLERANCE = 1e-9\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, initially stable)\n        {\n            \"C0\": np.array([110.0, 60.0, 40.0]),\n            \"S\": np.array([\n                [10.0, -5.0, 0.0, 0.0],\n                [-8.0, 3.0, 1.0, 0.0],\n                [2.0, -1.0, 0.5, 1.0]\n            ]),\n            \"t0\": np.array([0.1, -0.2, 0.05, 0.0]),\n            \"bounds\": [(-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0)]\n        },\n        # Case 2 (initial violation, feasible restoration)\n        {\n            \"C0\": np.array([100.0, 50.0, 30.0]),\n            \"S\": np.array([\n                [-20.0, 0.0, 5.0, 0.0],\n                [5.0, -15.0, 0.0, 0.0],\n                [0.0, 0.0, -40.0, 10.0]\n            ]),\n            \"t0\": np.array([0.0, 0.0, 1.0, -0.5]),\n            \"bounds\": [(-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0)]\n        },\n        # Case 3 (initial violation, infeasible within bounds)\n        {\n            \"C0\": np.array([5.0, 6.0, -2.0]),\n            \"S\": np.array([\n                [0.5, 0.5, 0.5, 0.5],\n                [0.5, 0.4, 0.3, 0.2],\n                [0.1, 0.1, 0.1, 0.1]\n            ]),\n            \"t0\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"bounds\": [(-0.3, 0.3), (-0.3, 0.3), (-0.3, 0.3), (-0.3, 0.3)]\n        }\n    ]\n\n    results = []\n\n    def is_stable(C_vector):\n        \"\"\"Checks if a vector of elastic constants satisfies the strict Born stability criteria.\"\"\"\n        born_metrics = A @ C_vector\n        return np.all(born_metrics > STABILITY_TOLERANCE)\n\n    for case in test_cases:\n        C0, S, t0, bounds = case[\"C0\"], case[\"S\"], case[\"t0\"], case[\"bounds\"]\n        \n        # 1. Initial State Analysis\n        C_initial = C0 + S @ t0\n        initial_violation = not is_stable(C_initial)\n\n        restored_stability = False\n        \n        if not initial_violation:\n            # If already stable, the 'restored' status is True as stability is maintained.\n            restored_stability = True\n        else:\n            # 2. Setup and run optimization problem for unstable cases.\n            # Objective function: minimize 0.5 * ||t - t0||^2\n            def objective_fun(t):\n                return 0.5 * np.sum((t - t0)**2)\n\n            # Jacobian of the objective function\n            def objective_jac(t):\n                return t - t0\n\n            # Constraints: A*C(t) >= 0 => A*C0 + (A*S)*t >= 0\n            # Scipy's 'ineq' constraint type is f(x) >= 0.\n            AS = A @ S\n            A_C0 = A @ C0\n            constraints = {\n                'type': 'ineq',\n                'fun': lambda t: A_C0 + AS @ t,\n                'jac': lambda t: AS \n            }\n\n            # Solve the Quadratic Program\n            opt_result = minimize(\n                fun=objective_fun,\n                x0=t0,\n                method='SLSQP',\n                jac=objective_jac,\n                bounds=bounds,\n                constraints=[constraints],\n                options={'ftol': 1e-12, 'disp': False}\n            )\n            \n            # 3. Post-Optimization Analysis\n            if opt_result.success:\n                # If optimizer converges, check if the solution is *strictly* stable.\n                # The solution will lie on the boundary (marginal stability), so this check\n                # for strict stability will fail.\n                t_star = opt_result.x\n                C_final = C0 + S @ t_star\n                if is_stable(C_final):\n                    restored_stability = True\n            # If optimization fails (e.g., infeasible), restored_stability remains False.\n\n        # Store the boolean pair for this case\n        results.append((initial_violation, restored_stability))\n\n    # Final print statement in the exact required format.\n    # The boolean values need to be lowercase for the final output format.\n    result_strings = [f\"[{str(v[0]).lower()},{str(v[1]).lower()}]\" for v in results]\n    # The problem description asks for True/False, not true/false. Let's revert this.\n    result_strings = [f\"[{v[0]},{v[1]}]\" for v in results]\n    print(f\"[{','.join(result_strings)}]\")\n\n# Since the environment will execute the code, the call must be present.\n# The expected output for the provided cases is [[False,True],[True,False],[True,False]].\n# Let's double check the output format. It's [[b1,b2],[b3,b4],[b5,b6]]. My code generates this.\n# Case 2 restored_stability is False because the QP finds a point on the boundary, which is not strictly stable.\n# Case 3 restored_stability is False because it's infeasible.\n# Correct logic.\nsolve()\n```"
        }
    ]
}