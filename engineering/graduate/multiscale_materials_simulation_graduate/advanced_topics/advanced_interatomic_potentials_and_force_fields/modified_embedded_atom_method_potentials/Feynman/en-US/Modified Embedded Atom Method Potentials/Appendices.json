{
    "hands_on_practices": [
        {
            "introduction": "The Modified Embedded Atom Method (MEAM) potential, like other embedded-atom methods, approximates the complex quantum mechanical interactions in a material. A cornerstone of this model is the concept of a background electron density, which each atom \"experiences\" due to its neighbors. This first exercise provides practice in calculating this fundamental quantity, $\\rho_i$, in a highly symmetric environment, connecting the abstract model to the concrete geometry of a crystal lattice .",
            "id": "3782223",
            "problem": "Consider a perfect monatomic face-centered cubic (fcc) crystal with lattice parameter $a$ at zero temperature. In the Modified Embedded Atom Method (MEAM), the embedding energy of an atom at site $i$ is expressed as a function of a background electron density $\\rho_i$ at that site, which is constructed from contributions of neighboring atoms. Assume the following physically standard conditions:\n\n- The atomic electron density associated with a single isolated atom is spherically symmetric and strictly radially decaying, denoted $\\rho_a(r)$, where $r$ is the scalar separation from the atom.\n- The environment is an ideal fcc lattice without defects or occlusion, so the screening of neighbor contributions is complete and equal to unity, and the spatial symmetry is cubic.\n- Only the nearest-neighbor shell is to be included in the construction of $\\rho_i$, and angular-dependent contributions can be neglected based on the cubic symmetry and the spherically symmetric form of $\\rho_a(r)$.\n\nStarting from the core MEAM concept that the background electron density $\\rho_i$ at site $i$ is constructed by summing spherically symmetric atomic electron density contributions from neighboring atoms, compute the closed-form analytic expression for $\\rho_i$ in terms of $a$ and $\\rho_a(r)$ by using only the nearest-neighbor shell of the fcc lattice. Your final answer must be a single closed-form analytic expression. No numerical approximation is required, and no units need to be reported.",
            "solution": "The problem asks for a closed-form analytic expression for the background electron density, $\\rho_i$, at an atomic site $i$ within a perfect face-centered cubic (fcc) crystal. The calculation is to be performed under the framework of the Modified Embedded Atom Method (MEAM), simplified to include only contributions from the nearest-neighbor shell and neglecting angular-dependent terms.\n\nAccording to the problem statement, the background electron density $\\rho_i$ at site $i$ is constructed by the linear superposition of spherically symmetric atomic electron density contributions, $\\rho_a(r)$, from its neighboring atoms. Given the instruction to consider only the nearest-neighbor shell, the expression for $\\rho_i$ is:\n$$\n\\rho_i = \\sum_{j \\in \\text{NN}(i)} \\rho_a(r_{ij})\n$$\nwhere $\\text{NN}(i)$ is the set of nearest neighbors to atom $i$, and $r_{ij}$ is the distance between atom $i$ and its neighbor $j$.\n\nFor a perfect crystal structure, every atom is in an identical environment. Therefore, we can place our reference atom, $i$, at the origin of a coordinate system without loss of generality. In a perfect lattice, all nearest neighbors are at the same distance, which we will denote as $r_{\\text{NN}}$. The number of these nearest neighbors is the first coordination number of the lattice, which we denote as $Z_{\\text{NN}}$.\n\nThe summation can thus be simplified. Since $\\rho_a(r_{ij}) = \\rho_a(r_{\\text{NN}})$ for all $j \\in \\text{NN}(i)$, the sum becomes a product:\n$$\n\\rho_i = Z_{\\text{NN}} \\cdot \\rho_a(r_{\\text{NN}})\n$$\nTo proceed, we must determine the values of $Z_{\\text{NN}}$ and $r_{\\text{NN}}$ for the fcc lattice structure in terms of its lattice parameter, $a$.\n\nThe conventional unit cell of an fcc lattice is a cube of side length $a$ with atoms at the $8$ corners and at the center of the $6$ faces. Let's place a reference atom at the origin, coordinates $(0, 0, 0)$. The positions of its neighbors can be identified.\n\nThe atoms at the corners of the cube are at positions like $(a, 0, 0)$, $(0, a, 0)$, etc. The distance to these atoms is $a$.\nThe atoms at the centers of the faces are at positions like $(\\frac{a}{2}, \\frac{a}{2}, 0)$, $(\\frac{a}{2}, 0, \\frac{a}{2})$, $(0, \\frac{a}{2}, \\frac{a}{2})$, and their permutations with signs. The distance from the origin to an atom at $(\\frac{a}{2}, \\frac{a}{2}, 0)$ is:\n$$\nr = \\sqrt{\\left(\\frac{a}{2}\\right)^2 + \\left(\\frac{a}{2}\\right)^2 + 0^2} = \\sqrt{\\frac{a^2}{4} + \\frac{a^2}{4}} = \\sqrt{\\frac{2a^2}{4}} = \\sqrt{\\frac{a^2}{2}} = \\frac{a}{\\sqrt{2}}\n$$\nWe must compare this distance to the distance to the corner atoms, which is $a$. Since $\\frac{1}{\\sqrt{2}} \\approx 0.707$, we have $\\frac{a}{\\sqrt{2}} < a$. Therefore, the face-centered atoms are the nearest neighbors to a corner atom. The nearest-neighbor distance is:\n$$\nr_{\\text{NN}} = \\frac{a}{\\sqrt{2}}\n$$\nNext, we determine the coordination number, $Z_{\\text{NN}}$. For a reference atom at the origin, the nearest neighbors are the atoms on the faces of the cubes that meet at this corner. There are $12$ such face centers at the correct distance. Their coordinates relative to the origin are given by all non-zero permutations of $(\\pm \\frac{a}{2}, \\pm \\frac{a}{2}, 0)$. These are:\n- In the $xy$-plane: $(\\frac{a}{2}, \\frac{a}{2}, 0)$, $(\\frac{a}{2}, -\\frac{a}{2}, 0)$, $(-\\frac{a}{2}, \\frac{a}{2}, 0)$, $(-\\frac{a}{2}, -\\frac{a}{2}, 0)$. This is $4$ neighbors.\n- In the $xz$-plane: $(\\frac{a}{2}, 0, \\frac{a}{2})$, $(\\frac{a}{2}, 0, -\\frac{a}{2})$, $(-\\frac{a}{2}, 0, \\frac{a}{2})$, $(-\\frac{a}{2}, 0, -\\frac{a}{2})$. This is $4$ neighbors.\n- In the $yz$-plane: $(0, \\frac{a}{2}, \\frac{a}{2})$, $(0, \\frac{a}{2}, -\\frac{a}{2})$, $(0, -\\frac{a}{2}, \\frac{a}{2})$, $(0, -\\frac{a}{2}, -\\frac{a}{2})$. This is $4$ neighbors.\n\nSumming these up gives a total of $4 + 4 + 4 = 12$ nearest neighbors. Thus, the first coordination number for the fcc lattice is:\n$$\nZ_{\\text{NN}} = 12\n$$\nNow, we can substitute the derived values for $Z_{\\text{NN}}$ and $r_{\\text{NN}}$ back into our expression for $\\rho_i$:\n$$\n\\rho_i = Z_{\\text{NN}} \\cdot \\rho_a(r_{\\text{NN}}) = 12 \\cdot \\rho_a\\left(\\frac{a}{\\sqrt{2}}\\right)\n$$\nThis expression represents the zeroth-order background electron density at any atomic site in a perfect fcc crystal, based on the simplified MEAM assumptions provided. The neglect of angular contributions is justified by the high symmetry of the nearest-neighbor shell in the fcc lattice, which would cause the first-order angularly dependent terms in the full MEAM to sum to zero. The screening factor of unity, while a core MEAM concept, does not enter this particular calculation as it applies to the construction of partial (angular) electron densities, which have been excluded by the problem statement.",
            "answer": "$$\\boxed{12 \\rho_a\\left(\\frac{a}{\\sqrt{2}}\\right)}$$"
        },
        {
            "introduction": "A physically realistic interatomic potential must not only describe atomic interactions but also predict stable material properties. This practice demonstrates how to connect the abstract parameters of a MEAM potential, such as the angular weights $t_k$, to macroscopic mechanical properties, specifically the elastic constants $C_{11}$, $C_{12}$, and $C_{44}$ of a cubic crystal. You will implement an algorithm to enforce the Born stability criteria, a critical step in potential development that ensures the modeled crystal is mechanically stable and not prone to spontaneous collapse or deformation .",
            "id": "3782204",
            "problem": "You are asked to formalize how the Modified Embedded Atom Method (MEAM) parametrization through angular weight parameters can affect mechanical stability, and to construct an algorithmic procedure that automatically adjusts these parameters to restore stability when violations occur. Begin from the following fundamental bases: (i) the total energy of a crystalline solid may be approximated by an interatomic potential that depends on pairwise separations and a local electron density, (ii) under small homogeneous strain, the elastic response of a crystalline solid is defined by the linear relation between stress and strain (Hookeâ€™s law), and (iii) the Born stability criteria for a cubic crystal, which are necessary and sufficient for a positive-definite quadratic elastic energy density, require the following inequalities to hold: $C_{11}-C_{12}>0$, $C_{44}>0$, and $C_{11}+2C_{12}>0$. In MEAM, the local electron density is constructed from radial and angular contributions, with angular weight parameters $t_k$ ($k=1,\\dots,m$) controlling higher-order orientation-dependent terms. Under a small perturbation of the parameters $t_k$ around a calibrated reference, the elastic constants change to first order according to a sensitivity relation of the form\n$$\n\\Delta \\boldsymbol{C} \\approx \\boldsymbol{S}\\,\\Delta \\boldsymbol{t},\n$$\nwhere $\\boldsymbol{C}=[C_{11},C_{12},C_{44}]^{\\top}$, $\\boldsymbol{t}=[t_1,\\dots,t_m]^{\\top}$, and $\\boldsymbol{S}\\in\\mathbb{R}^{3\\times m}$ is a sensitivity matrix that encodes how the elastic constants respond to infinitesimal changes in the MEAM angular weights. Let $\\boldsymbol{C}^{(0)}$ denote the baseline elastic constants at the reference calibration (in the same units as the sensitivity responses), so that for finite deviations one employs the linearized model\n$$\n\\boldsymbol{C}(\\boldsymbol{t}) \\approx \\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\,\\boldsymbol{t}.\n$$\nIn this problem you will: (a) demonstrate that ill-chosen values of the MEAM angular weights $t_k$ can violate the Born stability criteria, and (b) implement a procedure that solves the constrained optimization problem\n$$\n\\min_{\\boldsymbol{t}} \\;\\frac{1}{2}\\lVert \\boldsymbol{t}-\\boldsymbol{t}^{(0)}\\rVert_2^2 \\quad \\text{subject to} \\quad \\boldsymbol{A}\\,\\boldsymbol{C}(\\boldsymbol{t}) \\ge \\boldsymbol{0}, \\quad \\ell_k \\le t_k \\le u_k,\n$$\nwhere $\\boldsymbol{t}^{(0)}$ is the initial choice of MEAM angular weights, $\\boldsymbol{A}$ encodes the linear Born constraints for a cubic crystal,\n$$\n\\boldsymbol{A}=\\begin{bmatrix}1 & -1 & 0\\\\ 0 & 0 & 1\\\\ 1 & 2 & 0\\end{bmatrix},\n$$\nand $\\ell_k,u_k$ are physically reasonable bounds on $t_k$. Your program must, for each test case, report whether the initial parameters violate the Born stability criteria and whether the adjustment procedure achieves a stable solution within the prescribed bounds.\n\nAll computations of elastic constants must be carried out in a consistent unit system; take the units of the elastic constants to be gigapascals ($\\mathrm{GPa}$). The final program should not take any user input and should only print the required output line described below.\n\nImplement your solution for the following test suite, each case defined by $(\\boldsymbol{C}^{(0)}, \\boldsymbol{S}, \\boldsymbol{t}^{(0)}, \\text{bounds})$:\n\n- Case $1$ (happy path, initially stable):\n  - $\\boldsymbol{C}^{(0)} = [\\,110,\\,60,\\,40\\,]$,\n  - $\\boldsymbol{S} = \\begin{bmatrix} 10 & -5 & 0 & 0 \\\\ -8 & 3 & 1 & 0 \\\\ 2 & -1 & 0.5 & 1 \\end{bmatrix}$,\n  - $\\boldsymbol{t}^{(0)} = [\\,0.1,\\,-0.2,\\,0.05,\\,0.0\\,]$,\n  - bounds $t_k\\in[-1,1]$ for all $k$.\n- Case $2$ (initial violation, feasible restoration):\n  - $\\boldsymbol{C}^{(0)} = [\\,100,\\,50,\\,30\\,]$,\n  - $\\boldsymbol{S} = \\begin{bmatrix} -20 & 0 & 5 & 0 \\\\ 5 & -15 & 0 & 0 \\\\ 0 & 0 & -40 & 10 \\end{bmatrix}$,\n  - $\\boldsymbol{t}^{(0)} = [\\,0.0,\\,0.0,\\,1.0,\\,-0.5\\,]$,\n  - bounds $t_k\\in[-1,1]$ for all $k$.\n- Case $3$ (initial violation, infeasible within bounds):\n  - $\\boldsymbol{C}^{(0)} = [\\,5,\\,6,\\,-2\\,]$,\n  - $\\boldsymbol{S} = \\begin{bmatrix} 0.5 & 0.5 & 0.5 & 0.5 \\\\ 0.5 & 0.4 & 0.3 & 0.2 \\\\ 0.1 & 0.1 & 0.1 & 0.1 \\end{bmatrix}$,\n  - $\\boldsymbol{t}^{(0)} = [\\,0.0,\\,0.0,\\,0.0,\\,0.0\\,]$,\n  - bounds $t_k\\in[-0.3,0.3]$ for all $k$.\n\nYour program must, for each test case, compute $\\boldsymbol{C}(\\boldsymbol{t}^{(0)})$, determine whether the Born criteria are violated, solve the constrained adjustment to get $\\boldsymbol{t}^{\\star}$ if necessary, and then re-check stability with $\\boldsymbol{C}(\\boldsymbol{t}^{\\star})$. The final output must be a single line containing a comma-separated list enclosed in square brackets, where each test case contributes a two-element bracketed list of booleans (with no spaces) of the form $[\\text{initial\\_violation},\\text{restored\\_stability}]$. For example, your output should look like $[[\\text{b}_{1},\\text{b}_{2}],[\\text{b}_{3},\\text{b}_{4}],[\\text{b}_{5},\\text{b}_{6}]]$ where each $\\text{b}_{i}$ is either $\\text{True}$ or $\\text{False}$.",
            "solution": "The present problem requires the development of an algorithmic procedure to analyze and enforce the mechanical stability of a cubic crystal, as described by the Modified Embedded Atom Method (MEAM) potential. The solution involves two main components: (1) checking for violations of the Born stability criteria given an initial set of MEAM angular weight parameters, and (2) if a violation exists, solving a constrained optimization problem to find the minimal adjustment to these parameters that restores stability.\n\n### Principle-Based Design\n\n1.  **Physical Model and Stability Criteria**: The mechanical stability of a material is fundamental. For a cubic crystal under small deformations, its elastic energy density must be positive-definite. This condition is guaranteed if the matrix of elastic constants $\\boldsymbol{C}$ satisfies the Born stability criteria:\n    $$\n    C_{11} - C_{12} > 0\n    $$\n    $$\n    C_{44} > 0\n    $$\n    $$\n    C_{11} + 2C_{12} > 0\n    $$\n    These three linear inequalities can be compactly written in matrix form. Defining the vector of elastic constants as $\\boldsymbol{C} = [C_{11}, C_{12}, C_{44}]^\\top$, the criteria are equivalent to $\\boldsymbol{A}\\boldsymbol{C} > \\boldsymbol{0}$, where the matrix $\\boldsymbol{A}$ is given as:\n    $$\n    \\boldsymbol{A} = \\begin{bmatrix} 1 & -1 & 0 \\\\ 0 & 0 & 1 \\\\ 1 & 2 & 0 \\end{bmatrix}\n    $$\n\n2.  **Linearized MEAM Model**: The problem provides a linearized model connecting the MEAM angular weight parameters $\\boldsymbol{t}=[t_1, \\dots, t_m]^\\top$ to the elastic constants $\\boldsymbol{C}$:\n    $$\n    \\boldsymbol{C}(\\boldsymbol{t}) = \\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\boldsymbol{t}\n    $$\n    Here, $\\boldsymbol{C}^{(0)}$ represents the baseline elastic constants, and the sensitivity matrix $\\boldsymbol{S}$ quantifies how each parameter $t_k$ influences the elastic constants. This linear approximation allows for a direct mathematical connection between the adjustable parameters and mechanical stability.\n\n3.  **Formulation as a Constrained Optimization Problem**: When an initial choice of parameters $\\boldsymbol{t}^{(0)}$ leads to a violation of the Born criteria, we seek a corrected set of parameters $\\boldsymbol{t}$ that are as close as possible to the original choice $\\boldsymbol{t}^{(0)}$ while satisfying the stability conditions. This is a classic engineering and scientific problem, formalized as a constrained optimization problem. The objective is to minimize the Euclidean distance (or its square) between the new and initial parameters, which encourages a minimal perturbation. The constraints enforce physical and mechanical requirements.\n    The optimization problem is:\n    $$\n    \\min_{\\boldsymbol{t}} \\;\\frac{1}{2}\\lVert \\boldsymbol{t}-\\boldsymbol{t}^{(0)}\\rVert_2^2\n    $$\n    subject to:\n    1.  **Mechanical Stability**: $\\boldsymbol{A}\\,\\boldsymbol{C}(\\boldsymbol{t}) \\ge \\boldsymbol{0}$\n    2.  **Parameter Bounds**: $\\ell_k \\le t_k \\le u_k$ for all $k=1, \\dots, m$.\n\n    Substituting the linearized model into the stability constraint yields:\n    $$\n    \\boldsymbol{A}(\\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\boldsymbol{t}) \\ge \\boldsymbol{0} \\implies (\\boldsymbol{A}\\boldsymbol{S})\\boldsymbol{t} \\ge -\\boldsymbol{A}\\boldsymbol{C}^{(0)}\n    $$\n    This is a system of linear inequalities. The objective function $\\frac{1}{2}\\lVert \\boldsymbol{t}-\\boldsymbol{t}^{(0)}\\rVert_2^2 = \\frac{1}{2}\\sum_k (t_k - t_k^{(0)})^2$ is a strictly convex quadratic function. The constraints (both stability and bounds) are linear. This specific structure defines a **Quadratic Programming (QP)** problem. QP problems are a well-understood class of convex optimization problems, which, if a feasible solution exists, guarantee a unique global minimum.\n\n4.  **Algorithmic Procedure and Numerical Implementation**:\n    The algorithm for each test case proceeds as follows:\n    a.  **Initial Stability Check**: Given an initial parameter set $\\boldsymbol{t}^{(0)}$, calculate the corresponding elastic constants $\\boldsymbol{C}_{initial} = \\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\boldsymbol{t}^{(0)}$. Then, evaluate the Born stability criteria, $\\boldsymbol{A}\\boldsymbol{C}_{initial} > \\boldsymbol{0}$. For numerical implementation, this is checked as $\\boldsymbol{A}\\boldsymbol{C}_{initial} > \\epsilon$, where $\\epsilon$ is a small positive tolerance (e.g., $10^{-9}$). This check determines the `initial_violation` status.\n    b.  **Conditional Optimization**:\n        - If the initial state is stable (`initial_violation` is false), no action is needed. The state is already stable, so `restored_stability` is true.\n        - If the initial state is unstable (`initial_violation` is true), the QP problem must be solved. We use the Sequential Least Squares Programming (SLSQP) algorithm, available in `scipy.optimize.minimize`, which is well-suited for such problems.\n    c.  **Post-Optimization Analysis**: The outcome of the optimization determines `restored_stability`:\n        - If the optimizer fails to converge (e.g., `success=False`), it implies that no solution exists that satisfies both the stability constraints and the parameter bounds. The problem is infeasible, and stability cannot be restored. Thus, `restored_stability` is false.\n        - If the optimizer converges to a solution $\\boldsymbol{t}^{\\star}$ (`success=True`), the resulting elastic constants $\\boldsymbol{C}_{final} = \\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\boldsymbol{t}^{\\star}$ are checked again for strict stability ($\\boldsymbol{A}\\boldsymbol{C}_{final} > \\epsilon$). It is a crucial feature of this optimization that if the initial point $\\boldsymbol{t}^{(0)}$ is infeasible, the optimal solution $\\boldsymbol{t}^{\\star}$ will lie on the boundary of the feasible region. This means at least one of the stability constraints will be active (i.e., equal to zero), e.g., $C_{44} = 0$. Such a state is termed marginally stable, not strictly stable. Therefore, the check for strict stability (`> \\epsilon`) will fail, and `restored_stability` will be reported as false.\n\nThis rigorous distinction between the numerical feasibility sought by the optimizer ($\\ge 0$) and the physical requirement of strict stability ($> 0$) is central to correctly interpreting the results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves a series of MEAM parameter stability problems by checking initial\n    stability and performing constrained optimization if necessary.\n    \"\"\"\n    # Define the constant matrix A for Born stability criteria and a tolerance for strict inequality.\n    A = np.array([\n        [1.0, -1.0, 0.0],\n        [0.0, 0.0, 1.0],\n        [1.0, 2.0, 0.0]\n    ])\n    STABILITY_TOLERANCE = 1e-9\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, initially stable)\n        {\n            \"C0\": np.array([110.0, 60.0, 40.0]),\n            \"S\": np.array([\n                [10.0, -5.0, 0.0, 0.0],\n                [-8.0, 3.0, 1.0, 0.0],\n                [2.0, -1.0, 0.5, 1.0]\n            ]),\n            \"t0\": np.array([0.1, -0.2, 0.05, 0.0]),\n            \"bounds\": [(-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0)]\n        },\n        # Case 2 (initial violation, feasible restoration)\n        {\n            \"C0\": np.array([100.0, 50.0, 30.0]),\n            \"S\": np.array([\n                [-20.0, 0.0, 5.0, 0.0],\n                [5.0, -15.0, 0.0, 0.0],\n                [0.0, 0.0, -40.0, 10.0]\n            ]),\n            \"t0\": np.array([0.0, 0.0, 1.0, -0.5]),\n            \"bounds\": [(-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0)]\n        },\n        # Case 3 (initial violation, infeasible within bounds)\n        {\n            \"C0\": np.array([5.0, 6.0, -2.0]),\n            \"S\": np.array([\n                [0.5, 0.5, 0.5, 0.5],\n                [0.5, 0.4, 0.3, 0.2],\n                [0.1, 0.1, 0.1, 0.1]\n            ]),\n            \"t0\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"bounds\": [(-0.3, 0.3), (-0.3, 0.3), (-0.3, 0.3), (-0.3, 0.3)]\n        }\n    ]\n\n    results = []\n\n    def is_stable(C_vector):\n        \"\"\"Checks if a vector of elastic constants satisfies the strict Born stability criteria.\"\"\"\n        born_metrics = A @ C_vector\n        return np.all(born_metrics > STABILITY_TOLERANCE)\n\n    for case in test_cases:\n        C0, S, t0, bounds = case[\"C0\"], case[\"S\"], case[\"t0\"], case[\"bounds\"]\n        \n        # 1. Initial State Analysis\n        C_initial = C0 + S @ t0\n        initial_violation = not is_stable(C_initial)\n\n        restored_stability = False\n        \n        if not initial_violation:\n            # If already stable, the 'restored' status is True as stability is maintained.\n            restored_stability = True\n        else:\n            # 2. Setup and run optimization problem for unstable cases.\n            # Objective function: minimize 0.5 * ||t - t0||^2\n            def objective_fun(t):\n                return 0.5 * np.sum((t - t0)**2)\n\n            # Jacobian of the objective function\n            def objective_jac(t):\n                return t - t0\n\n            # Constraints: A*C(t) >= 0 => A*C0 + (A*S)*t >= 0\n            # Scipy's 'ineq' constraint type is f(x) >= 0.\n            AS = A @ S\n            A_C0 = A @ C0\n            constraints = {\n                'type': 'ineq',\n                'fun': lambda t: A_C0 + AS @ t,\n                'jac': lambda t: AS \n            }\n\n            # Solve the Quadratic Program\n            opt_result = minimize(\n                fun=objective_fun,\n                x0=t0,\n                method='SLSQP',\n                jac=objective_jac,\n                bounds=bounds,\n                constraints=[constraints],\n                options={'ftol': 1e-12, 'disp': False}\n            )\n            \n            # 3. Post-Optimization Analysis\n            if opt_result.success:\n                # If optimizer converges, check if the solution is *strictly* stable.\n                # The solution will lie on the boundary (marginal stability), so this check\n                # for strict stability will fail.\n                t_star = opt_result.x\n                C_final = C0 + S @ t_star\n                if is_stable(C_final):\n                    restored_stability = True\n            # If optimization fails (e.g., infeasible), restored_stability remains False.\n\n        # Store the boolean pair for this case\n        results.append((initial_violation, restored_stability))\n\n    # Final print statement in the exact required format.\n    result_strings = [f\"[{v[0]},{v[1]}]\" for v in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate test of an interatomic potential is its performance in a dynamic simulation. This hands-on exercise guides you through a microcanonical (NVE) molecular dynamics simulation to assess one of the most important metrics of numerical accuracy: energy conservation. By tracking the total energy of a small system over time, you will investigate how the choice of the integration time step, $\\Delta t$, affects the stability and reliability of the simulation, a crucial skill for any computational materials scientist .",
            "id": "3782169",
            "problem": "You are tasked with designing and implementing a numerical experiment to assess energy drift in a microcanonical ensemble simulation, known as Number of particles, Volume, and Energy (NVE), when using a Modified Embedded Atom Method (MEAM) potential model. Starting from the following fundamental base: Newton's Second Law $\\mathbf{F} = m \\mathbf{a}$, conservation of Hamiltonian energy for conservative forces, and the definition of total energy as the sum of kinetic and potential energies, your program shall approximate dynamic evolution using a time-reversible symplectic integrator and measure the time-step sensitivity of the relative energy error.\n\nConsider a system of $N = 3$ identical atoms in three dimensions with atomic mass $m = 26.9815385$ atomic mass units (amu). Let the positions be in Angstrom ($\\mathrm{\\AA}$), velocities in Angstrom per femtosecond ($\\mathrm{\\AA}/\\mathrm{fs}$), time in femtoseconds ($\\mathrm{fs}$), and energy in electronvolts ($\\mathrm{eV}$). The three atoms are initialized at positions\n$$\n\\mathbf{r}_1(0) = (0,0,0),\\quad\n\\mathbf{r}_2(0) = (2.86,0,0),\\quad\n\\mathbf{r}_3(0) = (1.43,\\sqrt{3}\\cdot 1.43,0),\n$$\nand velocities\n$$\n\\mathbf{v}_1(0) = (0,0.001,0),\\quad\n\\mathbf{v}_2(0) = (-0.001,0,0),\\quad\n\\mathbf{v}_3(0) = (0,-0.001,0).\n$$\n\nDefine the MEAM-like total potential energy $U(\\{\\mathbf{r}_i\\})$ for a configuration $\\{\\mathbf{r}_i\\}$ as\n$$\nU = \\frac{1}{2} \\sum_{i\\neq j} \\phi(r_{ij}) + \\sum_{i} F(\\rho_i) + \\sum_{i} T_i,\n$$\nwith the following components:\n- Pair term $\\phi(r)$:\n$$\n\\phi(r) = D_0\\left[\\left(1 - e^{-a(r - r_0)}\\right)^2 - 1\\right]\\, f_c(r),\n$$\n- Background electron density at atom $i$:\n$$\n\\rho_i = \\sum_{j\\neq i} \\rho_0\\, e^{-\\beta (r_{ij} - r_0)}\\, f_c(r_{ij}),\n$$\n- Embedding energy\n$$\nF(\\rho_i) = -F_0 \\sqrt{\\rho_i + \\varepsilon_{\\rho}},\n$$\n- Angular contribution\n$$\nT_i = \\gamma \\sum_{\\substack{j\\neq i\\\\k\\neq i\\\\ j<k}} \\left[e^{-\\beta_{\\mathrm{ang}}(r_{ij}-r_0)} f_c(r_{ij})\\right]\\left[e^{-\\beta_{\\mathrm{ang}}(r_{ik}-r_0)} f_c(r_{ik})\\right]\\left(\\cos^2\\theta_{ijk} - \\frac{1}{3}\\right),\n$$\nwhere $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$, $\\cos\\theta_{ijk} = \\frac{(\\mathbf{r}_j-\\mathbf{r}_i)\\cdot(\\mathbf{r}_k-\\mathbf{r}_i)}{r_{ij} r_{ik}}$, and the smooth cutoff $f_c(r)$ is\n$$\nf_c(r) = \\begin{cases}\n1,& r \\le r_{\\mathrm{sw}},\\\\\n\\frac{1}{2}\\left[1+\\cos\\left(\\pi\\frac{r-r_{\\mathrm{sw}}}{r_{\\mathrm{cut}}-r_{\\mathrm{sw}}}\\right)\\right],& r_{\\mathrm{sw}} < r < r_{\\mathrm{cut}},\\\\\n0,& r \\ge r_{\\mathrm{cut}}.\n\\end{cases}\n$$\n\nUse the following scientifically plausible parameter values for a face-centered cubic metal-like system:\n- $D_0 = 0.25$ $\\mathrm{eV}$,\n- $a = 1.2$ $\\mathrm{\\AA}^{-1}$,\n- $r_0 = 2.86$ $\\mathrm{\\AA}$,\n- $\\rho_0 = 1.0$,\n- $\\beta = 1.0$ $\\mathrm{\\AA}^{-1}$,\n- $F_0 = 1.5$ $\\mathrm{eV}$,\n- $\\varepsilon_{\\rho} = 10^{-8}$ (dimensionless regularizer),\n- $\\gamma = 0.1$ $\\mathrm{eV}$,\n- $\\beta_{\\mathrm{ang}} = 0.8$ $\\mathrm{\\AA}^{-1}$,\n- $r_{\\mathrm{cut}} = 4.0$ $\\mathrm{\\AA}$,\n- $r_{\\mathrm{sw}} = r_{\\mathrm{cut}} - 0.5$ $\\mathrm{\\AA}$.\n\nEvolve the system using the Velocity Verlet algorithm:\n$$\n\\mathbf{r}(t+\\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t)\\Delta t + \\frac{1}{2}\\mathbf{a}(t)\\Delta t^2,\\quad\n\\mathbf{v}(t+\\Delta t) = \\mathbf{v}(t) + \\frac{1}{2}\\left[\\mathbf{a}(t)+\\mathbf{a}(t+\\Delta t)\\right]\\Delta t,\n$$\nwith forces computed as $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U$ and accelerations $\\mathbf{a}_i = \\mathbf{F}_i/m$. To ensure unit consistency, compute kinetic energy as\n$$\nK = \\frac{1}{2}\\sum_i m_{\\mathrm{kg}} \\|\\mathbf{v}_i\\|^2_{\\mathrm{m/s}} \\cdot \\frac{1}{q_e},\n$$\nwhere $m_{\\mathrm{kg}} = m_{\\mathrm{amu}}\\times 1.66053906660\\times 10^{-27}$ $\\mathrm{kg}$, $\\|\\mathbf{v}\\|_{\\mathrm{m/s}} = \\|\\mathbf{v}\\|_{\\mathrm{\\AA/fs}}\\times 10^{5}$, and $q_e = 1.602176634\\times 10^{-19}$ $\\mathrm{J/eV}$. Convert accelerations to $\\mathrm{\\AA/fs}^2$ via\n$$\n\\mathbf{a}_{\\mathrm{\\AA/fs}^2} = \\frac{\\mathbf{F}_{\\mathrm{eV/\\AA}} \\cdot 1.602176634\\times 10^{-29}}{m_{\\mathrm{kg}}}.\n$$\n\nImplement forces via numerical differentiation of $U$ using central differences:\n$$\nF_{i\\alpha} \\approx -\\frac{U(\\ldots, r_{i\\alpha}+h, \\ldots) - U(\\ldots, r_{i\\alpha}-h, \\ldots)}{2h},\n$$\nwith $h = 10^{-6}$ $\\mathrm{\\AA}$ and $\\alpha\\in\\{x,y,z\\}$.\n\nDefine the relative energy error at step $n$ as\n$$\n\\delta_n = \\frac{|E_n - E_0|}{|E_0|},\\quad E_n = K_n + U_n.\n$$\n\nYour program must, for each test case below, scan the candidate time steps and determine the maximum $\\Delta t$ that yields $\\max_n \\delta_n$ strictly below the prescribed threshold. If no candidate satisfies the criterion, return $0.0$.\n\nUse the following candidate time steps in femtoseconds:\n$$\n\\Delta t \\in \\{0.01, 0.02, 0.05, 0.10\\}\\ \\mathrm{fs}.\n$$\n\nTest suite:\n- Case $1$: threshold $= 10^{-3}$ (decimal), $N_{\\mathrm{steps}} = 200$.\n- Case $2$: threshold $= 3\\times 10^{-4}$ (decimal), $N_{\\mathrm{steps}} = 300$.\n- Case $3$: threshold $= 10^{-6}$ (decimal), $N_{\\mathrm{steps}} = 200$.\n- Case $4$: threshold $= 5\\times 10^{-3}$ (decimal), $N_{\\mathrm{steps}} = 600$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is the maximum $\\Delta t$ in $\\mathrm{fs}$ for the corresponding test case, represented as a float.",
            "solution": "The problem requires the design and implementation of a numerical experiment to assess the energy conservation properties of a molecular dynamics (MD) simulation. This task is grounded in the fundamental principles of classical mechanics and computational physics, specifically for simulating atomic-scale systems.\n\nThe core of the simulation is Newton's Second Law, $\\mathbf{F} = m \\mathbf{a}$, which dictates the motion of each atom. In a closed, isolated system with forces derivable from a scalar potential, the total energy (the Hamiltonian) is a conserved quantity. The simulation is conducted in the microcanonical (NVE) ensemble, where the number of particles ($N$), system volume ($V$), and total energy ($E$) are constant. The total energy is the sum of the kinetic energy ($K$) and potential energy ($U$), $E = K + U$.\n\nThe system consists of $N=3$ identical atoms, whose interactions are described by a Modified Embedded Atom Method (MEAM) potential. This is a many-body potential, meaning the force on any given atom depends not only on its pairwise distances to other atoms but also on the local environment, including angular distributions. The potential energy function $U$ is explicitly defined as a sum of three components:\n1.  A pairwise term $\\phi(r_{ij})$ that models repulsion and attraction between atom pairs, similar to a Morse potential but modified by a cutoff function.\n2.  An embedding energy term $F(\\rho_i)$, where each atom's contribution to the energy depends on the local electron density $\\rho_i$ created by its neighbors. This term is a hallmark of EAM-type potentials and captures metallic bonding aspects.\n3.  An angular contribution $T_i$, which penalizes or favors specific bond angles $\\theta_{ijk}$, providing directional bonding characteristics necessary to distinguish different crystal structures.\n\nThese components are defined by a set of given parameters ($D_0, a, r_0$, etc.). The potential is smoothly truncated to zero at a cutoff distance $r_{\\text{cut}}$ using a switching function $f_c(r)$ to ensure continuity of forces, which is crucial for numerical stability.\n\nThe time evolution of the system is approximated using the Velocity Verlet algorithm. This is a symplectic, time-reversible integrator, well-suited for NVE simulations because it exhibits excellent long-term energy conservation compared to simpler methods like the Euler integrator. The algorithm updates atomic positions $\\mathbf{r}$ and velocities $\\mathbf{v}$ in discrete time steps $\\Delta t$. The algorithm proceeds in two stages: updating positions using current velocities and accelerations, and then updating velocities using an average of the current and next accelerations.\n\nA critical step in the simulation is the calculation of the forces $\\mathbf{F}_i$ on each atom $i$. The force is the negative gradient of the potential energy with respect to the atom's position, $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U$. The problem specifies that these forces be computed numerically using the central difference method, where each component of the gradient is approximated by evaluating the potential energy at small displacements $\\pm h$ along each coordinate axis.\n\nThe simulation is performed using a consistent set of units: electronvolts (eV) for energy, Angstroms ($\\mathrm{\\AA}$) for distance, femtoseconds (fs) for time, and atomic mass units (amu) for mass. The provided conversion factors are necessary to relate these simulation units to SI base units when calculating kinetic energy and acceleration, ensuring physical consistency. For example, the acceleration $\\mathbf{a}_i = \\mathbf{F}_i/m$ requires converting the force from $\\mathrm{eV/\\AA}$ and mass from amu to compatible units.\n\nThe objective of the experiment is to quantify the numerical error introduced by the discrete time stepping. In a perfect simulation of a conservative system, the total energy $E_n$ at any step $n$ would be identical to the initial energy $E_0$. In practice, numerical integration introduces small errors, causing the energy to drift. This drift is measured by the relative energy error, $\\delta_n = |E_n - E_0|/|E_0|$. The sensitivity of this error to the choice of time step $\\Delta t$ is investigated. The program must find the maximum candidate $\\Delta t$ for which the maximum observed relative error, $\\max_n \\delta_n$, remains below a specified threshold over a given number of simulation steps. The algorithm iterates through a list of candidate time steps in descending order for each test case. The first (and thus largest) $\\Delta t$ that meets the error criterion is selected as the result. If no time step is suitable, the result is $0.0$.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the molecular dynamics energy drift problem.\n    \"\"\"\n    #\n    # --- Problem Constants and Parameters ---\n    #\n    PARAMS = {\n        'm_amu': 26.9815385,          # amu\n        'D0': 0.25,                  # eV\n        'a': 1.2,                    # 1/Angstrom\n        'r0': 2.86,                  # Angstrom\n        'rho0': 1.0,                 # dimensionless\n        'beta': 1.0,                 # 1/Angstrom\n        'F0': 1.5,                   # eV\n        'epsilon_rho': 1e-8,         # dimensionless\n        'gamma': 0.1,                # eV\n        'beta_ang': 0.8,             # 1/Angstrom\n        'r_cut': 4.0,                # Angstrom\n        'r_sw': 3.5,                 # Angstrom\n        'h_diff': 1e-6,              # Angstrom for numerical differentiation\n    }\n\n    # Physical constants for unit conversion\n    AMU_to_KG = 1.66053906660e-27\n    EV_to_J = 1.602176634e-19\n    J_to_EV = 1.0 / EV_to_J\n    ANGSTROM_to_M = 1e-10\n    FS_to_S = 1e-15\n    \n    PARAMS['m_kg'] = PARAMS['m_amu'] * AMU_to_KG\n\n    # Pre-calculated conversion factor for kinetic energy\n    # Factor to convert m(amu) * v(A/fs)^2 to eV\n    # v_ms = v_Afs * 1e5, m_kg = m_amu * AMU_to_KG\n    # K(J) = 0.5 * m_kg * v_ms^2 = 0.5 * (m_amu * AMU_to_KG) * (v_Afs * 1e5)^2\n    # K(eV) = K(J) * J_to_EV\n    KE_FACTOR = 0.5 * AMU_to_KG * (1e5)**2 * J_to_EV\n    \n    # Pre-calculated conversion factor for force/acceleration\n    # a(A/fs^2) = F(eV/A) * factor / m(amu)\n    # Using the text's formula: a(A/fs^2) = F(eV/A) * 1.602e-29 / m_kg\n    # m_kg = m_amu * AMU_to_KG\n    # a(A/fs^2) = F(eV/A) * 1.602e-29 / (m_amu * AMU_to_KG)\n    # factor = 1.602...e-29 / AMU_to_KG\n    ACCEL_FACTOR = 1.602176634e-29 / AMU_to_KG\n    \n    #\n    # --- Core Simulation Functions ---\n    #\n    def cutoff_function(r, r_sw, r_cut):\n        if r <= r_sw:\n            return 1.0\n        if r >= r_cut:\n            return 0.0\n        return 0.5 * (1.0 + math.cos(math.pi * (r - r_sw) / (r_cut - r_sw)))\n\n    def potential_energy(positions, p):\n        N = positions.shape[0]\n        U_pair = 0.0\n        rhos = np.zeros(N)\n        \n        # Pairwise and density terms\n        for i in range(N):\n            for j in range(i + 1, N):\n                r_vec = positions[i] - positions[j]\n                r_ij = np.linalg.norm(r_vec)\n                \n                if r_ij >= p['r_cut']:\n                    continue\n                \n                fc_val = cutoff_function(r_ij, p['r_sw'], p['r_cut'])\n                if fc_val == 0:\n                    continue\n\n                # Pair term contribution\n                exp_term_pair = math.exp(-p['a'] * (r_ij - p['r0']))\n                U_pair += p['D0'] * ((1.0 - exp_term_pair)**2 - 1.0) * fc_val\n                \n                # Density contribution\n                exp_term_rho = math.exp(-p['beta'] * (r_ij - p['r0']))\n                rho_contrib = p['rho0'] * exp_term_rho * fc_val\n                rhos[i] += rho_contrib\n                rhos[j] += rho_contrib\n\n        # Embedding energy term\n        U_embed = -p['F0'] * np.sum(np.sqrt(rhos + p['epsilon_rho']))\n        \n        # Angular contribution term\n        U_angular = 0.0\n        for i in range(N):\n            # For N=3, there's only one pair of neighbors (j,k) for each atom i\n            neighbors = [idx for idx in range(N) if idx != i]\n            j, k = neighbors[0], neighbors[1]\n            \n            r_vec_ij = positions[j] - positions[i]\n            r_ij = np.linalg.norm(r_vec_ij)\n            \n            r_vec_ik = positions[k] - positions[i]\n            r_ik = np.linalg.norm(r_vec_ik)\n\n            if r_ij >= p['r_cut'] or r_ik >= p['r_cut'] or r_ij == 0.0 or r_ik == 0.0:\n                continue\n\n            fc_ij = cutoff_function(r_ij, p['r_sw'], p['r_cut'])\n            fc_ik = cutoff_function(r_ik, p['r_sw'], p['r_cut'])\n            \n            if fc_ij == 0 or fc_ik == 0:\n                continue\n            \n            term_j = math.exp(-p['beta_ang'] * (r_ij - p['r0'])) * fc_ij\n            term_k = math.exp(-p['beta_ang'] * (r_ik - p['r0'])) * fc_ik\n            cos_theta_ijk = np.dot(r_vec_ij, r_vec_ik) / (r_ij * r_ik)\n            \n            T_i_term = term_j * term_k * (cos_theta_ijk**2 - 1.0/3.0)\n            U_angular += p['gamma'] * T_i_term\n            \n        return U_pair + U_embed + U_angular\n\n    def kinetic_energy(velocities, mass_amu):\n        # K = 1/2 * m * v^2, converted to eV\n        return KE_FACTOR * mass_amu * np.sum(velocities**2)\n\n    def compute_forces(positions, p):\n        forces = np.zeros_like(positions)\n        N = positions.shape[0]\n        h = p['h_diff']\n        \n        for i in range(N):\n            for alpha in range(3):\n                pos_plus = positions.copy()\n                pos_plus[i, alpha] += h\n                U_plus = potential_energy(pos_plus, p)\n\n                pos_minus = positions.copy()\n                pos_minus[i, alpha] -= h\n                U_minus = potential_energy(pos_minus, p)\n                \n                forces[i, alpha] = -(U_plus - U_minus) / (2.0 * h)\n        return forces\n\n    def run_simulation(dt, n_steps, p):\n        # Initial conditions\n        r = np.array([\n            [0.0, 0.0, 0.0],\n            [2.86, 0.0, 0.0],\n            [1.43, math.sqrt(3.0) * 1.43, 0.0]\n        ])\n        v = np.array([\n            [0.0, 0.001, 0.0],\n            [-0.001, 0.0, 0.0],\n            [0.0, -0.001, 0.0]\n        ])\n\n        # Initial energy calculation\n        U0 = potential_energy(r, p)\n        K0 = kinetic_energy(v, p['m_amu'])\n        E0 = U0 + K0\n\n        if abs(E0) < 1e-12:  # Avoid division by zero for relative error\n             return float('inf')\n\n        # Initial force and acceleration\n        forces = compute_forces(r, p)\n        a = forces * (ACCEL_FACTOR / p['m_amu'])\n        \n        max_rel_error = 0.0\n\n        for _ in range(n_steps):\n            # Velocity Verlet step\n            v_half = v + 0.5 * a * dt\n            r = r + v_half * dt\n            \n            forces_new = compute_forces(r, p)\n            a_new = forces_new * (ACCEL_FACTOR / p['m_amu'])\n            \n            v = v_half + 0.5 * a_new * dt\n            a = a_new\n            \n            # Energy calculation for drift analysis\n            Un = potential_energy(r, p)\n            Kn = kinetic_energy(v, p['m_amu'])\n            En = Un + Kn\n            \n            rel_error = abs(En - E0) / abs(E0)\n            if rel_error > max_rel_error:\n                max_rel_error = rel_error\n        \n        return max_rel_error\n\n    #\n    # --- Main Execution Logic ---\n    #\n    test_cases = [\n        (1e-3, 200),\n        (3e-4, 300),\n        (1e-6, 200),\n        (5e-3, 600)\n    ]\n    candidate_dts = [0.01, 0.02, 0.05, 0.10]\n    \n    results = []\n    \n    for threshold, n_steps in test_cases:\n        found_dt = 0.0\n        # Iterate dt in descending order to find the maximum suitable value\n        for dt in sorted(candidate_dts, reverse=True):\n            max_error = run_simulation(dt, n_steps, PARAMS)\n            if max_error < threshold:\n                found_dt = dt\n                break\n        results.append(found_dt)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}