{
    "hands_on_practices": [
        {
            "introduction": "本练习是一项基础性训练，旨在将背景电子密度这个嵌入原子方法（EAM）和修正嵌入原子方法（MEAM）势函数中的核心抽象概念，与一种常见晶体结构（面心立方，FCC）的具体几何构型联系起来。通过这个计算，您可以巩固对模型中如何量化局域原子环境的理解。",
            "id": "3782223",
            "problem": "考虑一个在零温度下，晶格常数为 $a$ 的完美单原子面心立方（fcc）晶体。在修正嵌入原子方法（MEAM）中，位于 $i$ 位点的原子的嵌入能表示为该位点背景电子密度 $\\rho_i$ 的函数，该密度是由相邻原子的贡献构建的。假设以下物理上标准的条件：\n\n- 与单个孤立原子相关的原子电子密度是球对称且严格径向衰减的，记为 $\\rho_a(r)$，其中 $r$ 是与原子的标量距离。\n- 环境是理想的fcc晶格，无缺陷或遮挡，因此相邻原子贡献的屏蔽是完全的且等于1，空间对称性是立方的。\n- 在构建 $\\rho_i$ 时只包含最近邻壳层，并且基于立方对称性和 $\\rho_a(r)$ 的球对称形式，可以忽略角度依赖的贡献。\n\n从MEAM的核心概念出发，即位于 $i$ 位点的背景电子密度 $\\rho_i$ 是通过对来自相邻原子的球对称原子电子密度贡献求和来构建的，请仅使用fcc晶格的最近邻壳层，计算 $\\rho_i$ 关于 $a$ 和 $\\rho_a(r)$ 的闭式解析表达式。你的最终答案必须是单个闭式解析表达式。不需要数值近似，也不需要报告单位。",
            "solution": "问题要求计算在一个完美面心立方（fcc）晶体中，位于原子位点 $i$ 的背景电子密度 $\\rho_i$ 的闭式解析表达式。计算将在修正嵌入原子方法（MEAM）的框架下进行，并简化为只包括来自最近邻壳层的贡献，同时忽略角度依赖项。\n\n根据问题陈述，位于位点 $i$ 的背景电子密度 $\\rho_i$ 是通过对其相邻原子的球对称原子电子密度贡献 $\\rho_a(r)$ 进行线性叠加来构建的。根据只考虑最近邻壳层的指示，$\\rho_i$ 的表达式为：\n$$\n\\rho_i = \\sum_{j \\in \\text{NN}(i)} \\rho_a(r_{ij})\n$$\n其中 $\\text{NN}(i)$ 是原子 $i$ 的最近邻原子集合，$r_{ij}$ 是原子 $i$ 与其邻居 $j$ 之间的距离。\n\n对于一个完美的晶体结构，每个原子都处于相同的环境中。因此，我们可以不失一般性地将参考原子 $i$ 放置在坐标系的原点。在一个完美的晶格中，所有最近邻原子都处于相同的距离，我们将其表示为 $r_{\\text{NN}}$。这些最近邻原子的数量是晶格的第一配位数，我们将其表示为 $Z_{\\text{NN}}$。\n\n因此，求和可以被简化。由于对于所有 $j \\in \\text{NN}(i)$，都有 $\\rho_a(r_{ij}) = \\rho_a(r_{\\text{NN}})$，所以求和变成了一个乘积：\n$$\n\\rho_i = Z_{\\text{NN}} \\cdot \\rho_a(r_{\\text{NN}})\n$$\n为了继续计算，我们必须确定fcc晶格结构的第一配位数 $Z_{\\text{NN}}$ 和最近邻距离 $r_{\\text{NN}}$（用晶格常数 $a$ 表示）。\n\nfcc晶格的传统晶胞是一个边长为 $a$ 的立方体，在8个角和6个面的中心有原子。让我们将一个参考原子置于原点，坐标为 $(0, 0, 0)$。其邻居的位置可以被确定。\n\n立方体角上的原子位于诸如 $(a, 0, 0)$、$(0, a, 0)$ 等位置。到这些原子的距离是 $a$。\n面心的原子位于诸如 $(\\frac{a}{2}, \\frac{a}{2}, 0)$、$(\\frac{a}{2}, 0, \\frac{a}{2})$、$(0, \\frac{a}{2}, \\frac{a}{2})$ 以及它们带符号的排列组合位置。从原点到位于 $(\\frac{a}{2}, \\frac{a}{2}, 0)$ 的原子的距离是：\n$$\nr = \\sqrt{\\left(\\frac{a}{2}\\right)^2 + \\left(\\frac{a}{2}\\right)^2 + 0^2} = \\sqrt{\\frac{a^2}{4} + \\frac{a^2}{4}} = \\sqrt{\\frac{2a^2}{4}} = \\sqrt{\\frac{a^2}{2}} = \\frac{a}{\\sqrt{2}}\n$$\n我们必须将这个距离与到角上原子的距离 $a$ 进行比较。因为 $\\frac{1}{\\sqrt{2}} \\approx 0.707$，所以我们有 $\\frac{a}{\\sqrt{2}}  a$。因此，面心原子是角上原子的最近邻。最近邻距离是：\n$$\nr_{\\text{NN}} = \\frac{a}{\\sqrt{2}}\n$$\n接下来，我们确定配位数 $Z_{\\text{NN}}$。对于位于原点的参考原子，最近邻是在此角相交的立方体面上的原子。在正确距离上有12个这样的面心原子。它们相对于原点的坐标由 $(\\pm \\frac{a}{2}, \\pm \\frac{a}{2}, 0)$ 的所有非零排列给出。\n- 在 $xy$ 平面内：$(\\frac{a}{2}, \\frac{a}{2}, 0)$, $(\\frac{a}{2}, -\\frac{a}{2}, 0)$, $(-\\frac{a}{2}, \\frac{a}{2}, 0)$, $(-\\frac{a}{2}, -\\frac{a}{2}, 0)$。这是4个邻居。\n- 在 $xz$ 平面内：$(\\frac{a}{2}, 0, \\frac{a}{2})$, $(\\frac{a}{2}, 0, -\\frac{a}{2})$, $(-\\frac{a}{2}, 0, \\frac{a}{2})$, $(-\\frac{a}{2}, 0, -\\frac{a}{2})$。这是4个邻居。\n- 在 $yz$ 平面内：$(0, \\frac{a}{2}, \\frac{a}{2})$, $(0, \\frac{a}{2}, -\\frac{a}{2})$, $(0, -\\frac{a}{2}, \\frac{a}{2})$, $(0, -\\frac{a}{2}, -\\frac{a}{2})$。这是4个邻居。\n\n将这些相加，总共得到 $4 + 4 + 4 = 12$ 个最近邻。因此，fcc晶格的第一配位数为：\n$$\nZ_{\\text{NN}} = 12\n$$\n现在，我们可以将推导出的 $Z_{\\text{NN}}$ 和 $r_{\\text{NN}}$ 的值代回到我们关于 $\\rho_i$ 的表达式中：\n$$\n\\rho_i = Z_{\\text{NN}} \\cdot \\rho_a(r_{\\text{NN}}) = 12 \\cdot \\rho_a\\left(\\frac{a}{\\sqrt{2}}\\right)\n$$\n这个表达式代表了在一个完美fcc晶体中任何原子位点的零阶背景电子密度，基于所提供的简化的MEAM假设。忽略角度贡献是合理的，因为fcc晶格中最近邻壳层具有高对称性，这会导致完整MEAM中的一阶角度依赖项求和为零。等于1的屏蔽因子虽然是MEAM的一个核心概念，但并未进入本次特定的计算中，因为它应用于构建部分（角度）电子密度，而问题陈述已将这些排除在外。",
            "answer": "$$\\boxed{12 \\rho_a\\left(\\frac{a}{\\sqrt{2}}\\right)}$$"
        },
        {
            "introduction": "在完成电子密度的计算之后，本练习将深入探讨 MEAM 中“修正”的内涵：对相互作用的屏蔽效应。这个练习使用一个简化的一维模型，清晰地展示了中间原子的存在如何完全屏蔽其邻居之间的相互作用，这是该势函数所捕捉到的一个关键物理概念。",
            "id": "3782093",
            "problem": "考虑修正嵌入原子方法 (MEAM) 势，其中原子间的对相互作用会因其他原子的存在而被乘性屏蔽。在MEAM中，原子 $i$ 和 $j$ 之间的屏蔽因子定义为 $S_{ij} = \\prod_{k \\neq i,j} S_{ikj}$，其中每个三体因子 $S_{ikj}$ 取决于三原子组 $(i,k,j)$ 周围的局域几何结构。对于一个由相同原子组成的无限长线性链，原子位于x轴上，位置为 $x_n = n a$，均匀间距为 $a  0$。假设其具有以下连续且具有几何动机的特定屏蔽形式：\n$$\nS_{ikj} = \\frac{\\left(r_{ik} + r_{kj} - r_{ij}\\right)^{2}}{\\left(r_{ik} + r_{kj} - r_{ij}\\right)^{2} + d_{0}^{2}},\n$$\n其中 $r_{pq}$ 表示原子 $p$ 和 $q$ 之间的欧几里得距离，而 $d_{0}  0$ 是一个特征屏蔽软度长度标度，用于调节完全屏蔽和未屏蔽构型之间的过渡。\n\n从MEAM定义 $S_{ij} = \\prod_{k \\neq i,j} S_{ikj}$ 和一维链所蕴含的几何距离出发，推导以下两种情况的屏蔽因子：\n- 间距为 $r_{ij} = a$ 的最近邻原子，以及\n- 间距为 $r_{ij} = 2 a$ 的次近邻原子。\n\n定性地说明为何在线性链中这些屏蔽因子会有所不同，然后根据给定的 $S_{ikj}$ 形式，计算这两种情况下的闭式解析表达式。将最终答案表示为一个双分量行向量，其第一个分量是最近邻屏蔽因子，第二个分量是次近邻屏蔽因子，均用 $a$ 和 $d_{0}$ 表示。无需进行数值四舍五入，应提供精确表达式。",
            "solution": "首先验证该问题，以确保其在科学上是合理的、良定的和客观的。\n\n### 步骤1：提取已知条件\n- **模型：** 修正嵌入原子方法 (MEAM)。\n- **系统：** 由相同原子组成的无限长线性链。\n- **原子位置：** $x_n = n a$，其中 $n$ 为整数，$a  0$ 为均匀间距。\n- **距离：** $r_{pq}$ 是原子 $p$ 和 $q$ 之间的欧几里得距离。对于线性链，$r_{pq} = |p-q|a$。\n- **总屏蔽因子：** $S_{ij} = \\prod_{k \\neq i,j} S_{ikj}$。\n- **三体屏蔽项：** $S_{ikj} = \\frac{\\left(r_{ik} + r_{kj} - r_{ij}\\right)^{2}}{\\left(r_{ik} + r_{kj} - r_{ij}\\right)^{2} + d_{0}^{2}}$，其中 $d_0  0$。\n- **任务：** 推导以下两种情况的屏蔽因子 $S_{ij}$：\n    1. 最近邻 ($r_{ij} = a$) 。\n    2. 次近邻 ($r_{ij} = 2a$) 。\n\n### 步骤2：使用已知条件进行验证\n- **科学依据：** 该问题基于MEAM势，这是计算材料科学中广泛使用的半经验模型。$S_{ikj}$ 的特定函数形式是一个简化的、连续的屏蔽模型，但它在数学上是一致的，并且在物理上是可解释的。$r_{ik} + r_{kj} - r_{ij}$ 项与三角不等式有关，并正确地捕捉了共线性的几何概念。该问题具有科学依据。\n- **良定性：** 该问题提供了进行计算所需的所有必要定义、系统几何结构和函数形式。目标陈述明确。存在唯一解，且可从所提供的信息中推导出来。\n- **客观性：** 该问题以精确、正式的语言陈述，没有模糊性或主观论断。\n\n### 步骤3：结论与行动\n该问题是**有效的**。这是一个理论凝聚态物理学中的良定问题，可以解析求解。我现在将进行求解。\n\n### 屏蔽因子的推导\n\n计算的核心在于三体屏蔽项 $S_{ikj}$，它依赖于量 $\\Delta_{ikj} = r_{ik} + r_{kj} - r_{ij}$。对于线性链，原子位于间距 $a$ 的整数倍位置上。不失一般性，我们将原子 $i$ 置于原点，$x_i=0$。任意原子 $p$ 的位置为 $x_p = p a$。距离为 $r_{pq} = |p-q|a$。\n\n量 $\\Delta_{ikj}$ 变为：\n$$\n\\Delta_{ikj} = (|k-i|a + |j-k|a - |j-i|a) = (|k| + |j-k| - |j|)a\n$$\n其中我们已设 $i=0$。关键的洞察是，$\\Delta_{ikj} = 0$ 当且仅当原子 $k$ 位于连接原子 $i$ 和 $j$ 的线段上。对于我们的离散链，这意味着代表原子 $k$ 的整数严格位于代表原子 $i$ 和 $j$ 的整数之间。如果 $\\Delta_{ikj} = 0$，那么 $S_{ikj} = \\frac{0^2}{0^2 + d_0^2} = 0$。这意味着完全屏蔽。\n\n#### 情况1：最近邻屏蔽因子 ($S_{NN}$)\n\n我们考虑两个最近邻原子，例如位于位置 $i=0$ 和 $j=1$ 的原子。距离为 $r_{01} = a$。总屏蔽因子是所有其他原子 $k \\in \\mathbb{Z}$（其中 $k \\neq 0$ 且 $k \\neq 1$）的乘积。\n$$\nS_{NN} = S_{01} = \\prod_{k \\in \\mathbb{Z} \\setminus \\{0,1\\}} S_{0k1}\n$$\n对于这对原子，量 $\\Delta_{0k1}$ 为：\n$$\n\\Delta_{0k1} = (|k| + |1-k| - |1|)a = (|k| + |1-k| - 1)a\n$$\n屏蔽原子 $k$ 是整数。不存在整数 $k$ 使得 $0  k  1$。因此，没有原子位于原子0和1之间，$\\Delta_{0k1}$ 永远不可能为零。\n\n让我们对屏蔽原子 $k$ 计算 $\\Delta_{0k1}$：\n- 对于 $k  1$ (例如, $k=2, 3, \\dots$)：$\\Delta_{0k1} = (k + (k-1) - 1)a = (2k-2)a = 2(k-1)a$。\n- 对于 $k  0$ (例如, $k=-1, -2, \\dots$)：$\\Delta_{0k1} = (-k + (1-k) - 1)a = (-2k)a$。\n\n$S_{01}$ 的乘积可以分为两部分：一部分用于 $k  1$，另一部分用于 $k  0$。\n$$\nS_{01} = \\left( \\prod_{k=2}^{\\infty} S_{0k1} \\right) \\left( \\prod_{k=-\\infty}^{-1} S_{0k1} \\right)\n$$\n代入 $\\Delta_{0k1}$ 的表达式：\n$$\nS_{01} = \\left( \\prod_{k=2}^{\\infty} \\frac{(2(k-1)a)^2}{(2(k-1)a)^2 + d_0^2} \\right) \\left( \\prod_{k=-\\infty}^{-1} \\frac{(-2ka)^2}{(-2ka)^2 + d_0^2} \\right)\n$$\n让我们对乘积重新索引。在第一个乘积中，令 $n = k-1$；$n$ 从 1 到 $\\infty$。在第二个乘积中，令 $n = -k$；$n$ 也从 1 到 $\\infty$。\n$$\nS_{01} = \\left( \\prod_{n=1}^{\\infty} \\frac{(2na)^2}{(2na)^2 + d_0^2} \\right) \\left( \\prod_{n=1}^{\\infty} \\frac{(2na)^2}{(2na)^2 + d_0^2} \\right) = \\left( \\prod_{n=1}^{\\infty} \\frac{(2na)^2}{(2na)^2 + d_0^2} \\right)^2\n$$\n为计算此无穷乘积，我们使用双曲正弦函数的无穷乘积展开式：\n$$\n\\frac{\\sinh(\\pi z)}{\\pi z} = \\prod_{n=1}^{\\infty} \\left(1 + \\frac{z^2}{n^2}\\right)\n$$\n让我们重新排列我们的乘积项：\n$$\n\\frac{(2na)^2}{(2na)^2 + d_0^2} = \\frac{1}{1 + \\frac{d_0^2}{(2na)^2}} = \\frac{1}{1 + \\frac{(d_0/(2a))^2}{n^2}}\n$$\n乘积变为：\n$$\n\\prod_{n=1}^{\\infty} \\frac{1}{1 + \\frac{(d_0/(2a))^2}{n^2}} = \\frac{1}{\\prod_{n=1}^{\\infty} \\left(1 + \\frac{(d_0/(2a))^2}{n^2}\\right)}\n$$\n通过在双曲正弦展开式中令 $z = \\frac{d_0}{2a}$，我们得到：\n$$\n\\prod_{n=1}^{\\infty} \\left(1 + \\left(\\frac{d_0}{2a}\\right)^2 \\frac{1}{n^2}\\right) = \\frac{\\sinh\\left(\\frac{\\pi d_0}{2a}\\right)}{\\frac{\\pi d_0}{2a}}\n$$\n因此，$S_{01}$ 括号内的乘积是此表达式的倒数：\n$$\n\\prod_{n=1}^{\\infty} \\frac{(2na)^2}{(2na)^2 + d_0^2} = \\frac{\\frac{\\pi d_0}{2a}}{\\sinh\\left(\\frac{\\pi d_0}{2a}\\right)}\n$$\n最后，最近邻屏蔽因子是此结果的平方：\n$$\nS_{NN} = \\left( \\frac{\\frac{\\pi d_0}{2a}}{\\sinh\\left(\\frac{\\pi d_0}{2a}\\right)} \\right)^2\n$$\n\n#### 情况2：次近邻屏蔽因子 ($S_{NNN}$)\n\n我们考虑两个次近邻原子，例如位于位置 $i=0$ 和 $j=2$ 的原子。距离为 $r_{02} = 2a$。总屏蔽因子是所有其他原子 $k \\in \\mathbb{Z}$（其中 $k \\neq 0$ 且 $k \\neq 2$）的乘积。\n$$\nS_{NNN} = S_{02} = \\prod_{k \\in \\mathbb{Z} \\setminus \\{0,2\\}} S_{0k2}\n$$\n这个乘积包含了位于 $k=1$ 的原子的项。让我们计算来自这个原子的屏蔽贡献 $S_{012}$。量 $\\Delta_{012}$ 是：\n$$\n\\Delta_{012} = (|1-0|a + |2-1|a - |2-0|a) = (a + a - 2a) = 0\n$$\n由于 $\\Delta_{012}=0$，对应的三体屏蔽项是：\n$$\nS_{012} = \\frac{(\\Delta_{012})^2}{(\\Delta_{012})^2 + d_0^2} = \\frac{0^2}{0^2 + d_0^2} = 0\n$$\n总屏蔽因子 $S_{02}$ 是许多项的乘积，其中一项是 $S_{012}=0$。因此，整个乘积为零。\n$$\nS_{NNN} = S_{02} = S_{0(-1)2} \\cdots S_{012} \\cdots S_{032} \\cdots = 0\n$$\n\n#### 定性比较\n\n最近邻和次近邻的屏蔽因子由于一维链的几何结构而有根本性的不同。\n- 对于**最近邻**原子对（例如，位于 $0$ 和 $a$ 的原子），没有其他原子位于连接它们的线段上。因此，没有任何单个原子 $k$ 能提供“完美”屏蔽（对所有 $k$ 都有 $\\Delta_{ikj} \\neq 0$）。总屏蔽 $S_{NN}$ 是无限链中所有其他原子累积的部分屏蔽的结果，其值为一个非零值，取决于长度标度 $d_0/a$ 的比率。\n- 对于**次近邻**原子对（例如，位于 $0$ 和 $2a$ 的原子），有一个原子（位于 $a$）恰好位于它们之间的线段上。这个居间原子导致了完美屏蔽条件（$\\Delta_{012}=0$），使其屏蔽贡献 $S_{012}$ 等于零。因为总屏蔽因子 $S_{NNN}$ 是所有单个贡献的乘积，这一个值为零的项迫使整个屏蔽因子为零。这表明，在这个特定的MEAM模型中，次近邻原子之间的相互作用被位于它们之间的原子完全屏蔽了。\n\n最终答案是包含 $S_{NN}$ 和 $S_{NNN}$ 的一个双分量行向量。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\left( \\frac{\\frac{\\pi d_0}{2a}}{\\sinh\\left(\\frac{\\pi d_0}{2a}\\right)} \\right)^{2}  0 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "最后的这个练习则在势函数的理论构建与其在材料建模中的实际应用之间架起了一座桥梁。通过探索 MEAM 的角向参数与晶体弹性常数之间的关系，本练习展示了如何验证和调整势函数，以确保其能预测物理上真实的力学稳定性（例如，满足 Born 稳定性判据 $C_{11}-C_{12} \\gt 0$），这是任何可靠模拟的必要条件。",
            "id": "3782204",
            "problem": "本题要求您形式化描述修正嵌入原子法（MEAM）中通过角权重参数的参数化如何影响力学稳定性，并构建一个算法程序，在出现违背情况时自动调整这些参数以恢复稳定性。修正嵌入原子法（Modified Embedded Atom Method, MEAM）。从以下基本依据出发：(i) 晶体固体的总能量可以通过一个依赖于原子对间距和局域电子密度的原子间势来近似；(ii) 在小均匀应变下，晶体固体的弹性响应由应力与应变之间的线性关系（胡克定律）定义；(iii) 对于立方晶体，Born 稳定性判据是其二次弹性势能密度为正定的充要条件，要求以下不等式成立：$C_{11}-C_{12}0$，$C_{44}0$，以及 $C_{11}+2C_{12}0$。在 MEAM 中，局域电子密度由径向和角向贡献构成，其中角权重参数 $t_k$ ($k=1,\\dots,m$) 控制高阶取向依赖项。在校准参考值附近对参数 $t_k$ 施加小扰动时，弹性常数会根据以下形式的灵敏度关系发生一阶变化\n$$\n\\Delta \\boldsymbol{C} \\approx \\boldsymbol{S}\\,\\Delta \\boldsymbol{t},\n$$\n其中 $\\boldsymbol{C}=[C_{11},C_{12},C_{44}]^{\\top}$，$\\boldsymbol{t}=[t_1,\\dots,t_m]^{\\top}$，且 $\\boldsymbol{S}\\in\\mathbb{R}^{3\\times m}$ 是一个灵敏度矩阵，它编码了弹性常数如何响应 MEAM 角权重的无穷小变化。令 $\\boldsymbol{C}^{(0)}$ 表示参考校准下的基准弹性常数（单位与灵敏度响应相同），因此对于有限偏差，我们采用线性化模型\n$$\n\\boldsymbol{C}(\\boldsymbol{t}) \\approx \\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\,\\boldsymbol{t}.\n$$\n在本问题中，您将：(a) 证明 MEAM 角权重 $t_k$ 的不当取值可能违背 Born 稳定性判据；(b) 实现一个程序来求解以下约束优化问题\n$$\n\\min_{\\boldsymbol{t}} \\;\\frac{1}{2}\\lVert \\boldsymbol{t}-\\boldsymbol{t}^{(0)}\\rVert_2^2 \\quad \\text{subject to} \\quad \\boldsymbol{A}\\,\\boldsymbol{C}(\\boldsymbol{t}) \\ge \\boldsymbol{0}, \\quad \\ell_k \\le t_k \\le u_k,\n$$\n其中 $\\boldsymbol{t}^{(0)}$ 是 MEAM 角权重的初始选择，$\\boldsymbol{A}$ 编码了立方晶体的线性 Born 约束，\n$$\n\\boldsymbol{A}=\\begin{bmatrix}1  -1  0\\\\ 0  0  1\\\\ 1  2  0\\end{bmatrix},\n$$\n且 $\\ell_k,u_k$ 是 $t_k$ 的物理上合理的界限。对于每个测试用例，您的程序必须报告初始参数是否违背 Born 稳定性判据，以及调整程序是否在规定界限内获得了稳定的解。\n\n所有弹性常数的计算必须在一致的单位制下进行；弹性常数的单位取为吉帕斯卡（$\\mathrm{GPa}$）。最终程序不应接受任何用户输入，且仅应打印下述要求的输出行。\n\n为以下测试套件实现您的解决方案，每个案例由 $(\\boldsymbol{C}^{(0)}, \\boldsymbol{S}, \\boldsymbol{t}^{(0)}, \\text{bounds})$ 定义：\n\n- 案例 1 (理想情况，初始稳定):\n  - $\\boldsymbol{C}^{(0)} = [\\,110,\\,60,\\,40\\,]$,\n  - $\\boldsymbol{S} = \\begin{bmatrix} 10  -5  0  0 \\\\ -8  3  1  0 \\\\ 2  -1  0.5  1 \\end{bmatrix}$,\n  - $\\boldsymbol{t}^{(0)} = [\\,0.1,\\,-0.2,\\,0.05,\\,0.0\\,]$,\n  - 对所有 $k$，$t_k$ 的界限为 $[-1,1]$。\n- 案例 2 (初始违背，可恢复):\n  - $\\boldsymbol{C}^{(0)} = [\\,100,\\,50,\\,30\\,]$,\n  - $\\boldsymbol{S} = \\begin{bmatrix} -20  0  5  0 \\\\ 5  -15  0  0 \\\\ 0  0  -40  10 \\end{bmatrix}$,\n  - $\\boldsymbol{t}^{(0)} = [\\,0.0,\\,0.0,\\,1.0,\\,-0.5\\,]$,\n  - 对所有 $k$，$t_k$ 的界限为 $[-1,1]$。\n- 案例 3 (初始违背，界限内不可行):\n  - $\\boldsymbol{C}^{(0)} = [\\,5,\\,6,\\,-2\\,]$,\n  - $\\boldsymbol{S} = \\begin{bmatrix} 0.5  0.5  0.5  0.5 \\\\ 0.5  0.4  0.3  0.2 \\\\ 0.1  0.1  0.1  0.1 \\end{bmatrix}$,\n  - $\\boldsymbol{t}^{(0)} = [\\,0.0,\\,0.0,\\,0.0,\\,0.0\\,]$,\n  - 对所有 $k$，$t_k$ 的界限为 $[-0.3,0.3]$。\n\n对于每个测试用例，您的程序必须计算 $\\boldsymbol{C}(\\boldsymbol{t}^{(0)})$，判断 Born 判据是否被违背，如有必要则求解约束调整问题以得到 $\\boldsymbol{t}^{\\star}$，然后用 $\\boldsymbol{C}(\\boldsymbol{t}^{\\star})$ 重新检查稳定性。最终输出必须是单行，包含一个由方括号括起来的逗号分隔列表，其中每个测试用例对应一个形式为 $[\\text{initial\\_violation},\\text{restored\\_stability}]$ 的双元素布尔值列表（无空格）。例如，您的输出应类似于 $[[\\text{b}_{1},\\text{b}_{2}],[\\text{b}_{3},\\text{b}_{4}],[\\text{b}_{5},\\text{b}_{6}]]$，其中每个 $\\text{b}_{i}$ 为 $\\text{True}$ 或 $\\text{False}$。",
            "solution": "当前问题要求开发一个算法程序，用于分析和强制实现立方晶体的力学稳定性，该稳定性由修正嵌入原子法（MEAM）势描述。解决方案涉及两个主要部分：(1) 在给定一组初始 MEAM 角权重参数的情况下，检查是否违背 Born 稳定性判据；(2) 如果存在违背，则求解一个约束优化问题，以找到恢复稳定性的最小参数调整量。\n\n### 基于原理的设计\n\n1.  **物理模型与稳定性判据**：材料的力学稳定性是其基本属性。对于小变形下的立方晶体，其弹性势能密度必须是正定的。如果弹性常数矩阵 $\\boldsymbol{C}$ 满足 Born 稳定性判据，则该条件得到保证：\n    $$\n    C_{11} - C_{12}  0\n    $$\n    $$\n    C_{44}  0\n    $$\n    $$\n    C_{11} + 2C_{12}  0\n    $$\n    这三个线性不等式可以紧凑地写成矩阵形式。定义弹性常数向量为 $\\boldsymbol{C} = [C_{11}, C_{12}, C_{44}]^\\top$，则该判据等价于 $\\boldsymbol{A}\\boldsymbol{C}  \\boldsymbol{0}$，其中矩阵 $\\boldsymbol{A}$ 如下所示：\n    $$\n    \\boldsymbol{A} = \\begin{bmatrix} 1  -1  0 \\\\ 0  0  1 \\\\ 1  2  0 \\end{bmatrix}\n    $$\n\n2.  **线性化 MEAM 模型**：该问题提供了一个线性化模型，将 MEAM 角权重参数 $\\boldsymbol{t}=[t_1, \\dots, t_m]^\\top$ 与弹性常数 $\\boldsymbol{C}$ 联系起来：\n    $$\n    \\boldsymbol{C}(\\boldsymbol{t}) = \\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\boldsymbol{t}\n    $$\n    在这里，$\\boldsymbol{C}^{(0)}$ 代表基准弹性常数，灵敏度矩阵 $\\boldsymbol{S}$ 量化了每个参数 $t_k$ 如何影响弹性常数。这种线性近似使得可调参数与力学稳定性之间建立了直接的数学联系。\n\n3.  **表述为约束优化问题**：当参数的初始选择 $\\boldsymbol{t}^{(0)}$ 导致违背 Born 判据时，我们寻求一组修正后的参数 $\\boldsymbol{t}$，使其在满足稳定性条件的同时，尽可能接近原始选择 $\\boldsymbol{t}^{(0)}$。这是一个经典的工程和科学问题，可形式化为一个约束优化问题。目标是最小化新旧参数之间的欧几里得距离（或其平方），这鼓励了最小的扰动。约束条件则强制施加了物理和力学要求。\n    该优化问题是：\n    $$\n    \\min_{\\boldsymbol{t}} \\;\\frac{1}{2}\\lVert \\boldsymbol{t}-\\boldsymbol{t}^{(0)}\\rVert_2^2\n    $$\n    约束条件为：\n    1.  **力学稳定性**：$\\boldsymbol{A}\\,\\boldsymbol{C}(\\boldsymbol{t}) \\ge \\boldsymbol{0}$\n    2.  **参数界限**：$\\ell_k \\le t_k \\le u_k$，对所有 $k=1, \\dots, m$。\n\n    将线性化模型代入稳定性约束，可得：\n    $$\n    \\boldsymbol{A}(\\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\boldsymbol{t}) \\ge \\boldsymbol{0} \\implies (\\boldsymbol{A}\\boldsymbol{S})\\boldsymbol{t} \\ge -\\boldsymbol{A}\\boldsymbol{C}^{(0)}\n    $$\n    这是一个线性不等式组。目标函数 $\\frac{1}{2}\\lVert \\boldsymbol{t}-\\boldsymbol{t}^{(0)}\\rVert_2^2 = \\frac{1}{2}\\sum_k (t_k - t_k^{(0)})^2$ 是一个严格凸的二次函数。约束条件（包括稳定性和界限）是线性的。这种特定结构定义了一个 **二次规划（Quadratic Programming, QP）** 问题。QP 问题是一类已被充分理解的凸优化问题，如果存在可行解，则保证有唯一的全局最小值。\n\n4.  **算法流程与数值实现**：\n    每个测试用例的算法流程如下：\n    a.  **初始稳定性检查**：给定初始参数集 $\\boldsymbol{t}^{(0)}$，计算相应的弹性常数 $\\boldsymbol{C}_{initial} = \\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\boldsymbol{t}^{(0)}$。然后，评估 Born 稳定性判据 $\\boldsymbol{A}\\boldsymbol{C}_{initial}  \\boldsymbol{0}$。在数值实现中，此检查为 $\\boldsymbol{A}\\boldsymbol{C}_{initial}  \\epsilon$，其中 $\\epsilon$ 是一个小的正公差（例如，$10^{-9}$）。此检查确定 `initial_violation` 的状态。\n    b.  **条件优化**：\n        - 如果初始状态是稳定的（`initial_violation` 为 false），则无需任何操作。该状态已经稳定，因此 `restored_stability` 为 true。\n        - 如果初始状态不稳定（`initial_violation` 为 true），则必须求解 QP 问题。我们使用 `scipy.optimize.minimize` 中提供的序列最小二乘规划（Sequential Least Squares Programming, SLSQP）算法，该算法非常适合此类问题。\n    c.  **优化后分析**：优化的结果决定了 `restored_stability` 的值：\n        - 如果优化器未能收敛（例如，`success=False`），则意味着不存在同时满足稳定性和参数界限约束的解。该问题是不可行的，无法恢复稳定性。因此，`restored_stability` 为 false。\n        - 如果优化器收敛到解 $\\boldsymbol{t}^{\\star}$（`success=True`），则会对得到的弹性常数 $\\boldsymbol{C}_{final} = \\boldsymbol{C}^{(0)} + \\boldsymbol{S}\\boldsymbol{t}^{\\star}$ 再次进行严格稳定性检查（$\\boldsymbol{A}\\boldsymbol{C}_{final}  \\epsilon$）。该优化的一个关键特征是，如果初始点 $\\boldsymbol{t}^{(0)}$ 不可行，最优解 $\\boldsymbol{t}^{\\star}$ 将位于可行域的边界上。这意味着至少有一个稳定性约束将处于激活状态（即等于零），例如 $C_{44} = 0$。这种状态被称为临界稳定，而非严格稳定。因此，严格稳定性的检查（` \\epsilon`）将会失败，并且 `restored_stability` 将被报告为 false。\n\n优化器寻求的数值可行性（$\\ge 0$）与物理上要求的严格稳定性（$ 0$）之间的这种严格区分，对于正确解释结果至关重要。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves a series of MEAM parameter stability problems by checking initial\n    stability and performing constrained optimization if necessary.\n    \"\"\"\n    # Define the constant matrix A for Born stability criteria and a tolerance for strict inequality.\n    A = np.array([\n        [1.0, -1.0, 0.0],\n        [0.0, 0.0, 1.0],\n        [1.0, 2.0, 0.0]\n    ])\n    STABILITY_TOLERANCE = 1e-9\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, initially stable)\n        {\n            \"C0\": np.array([110.0, 60.0, 40.0]),\n            \"S\": np.array([\n                [10.0, -5.0, 0.0, 0.0],\n                [-8.0, 3.0, 1.0, 0.0],\n                [2.0, -1.0, 0.5, 1.0]\n            ]),\n            \"t0\": np.array([0.1, -0.2, 0.05, 0.0]),\n            \"bounds\": [(-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0)]\n        },\n        # Case 2 (initial violation, feasible restoration)\n        {\n            \"C0\": np.array([100.0, 50.0, 30.0]),\n            \"S\": np.array([\n                [-20.0, 0.0, 5.0, 0.0],\n                [5.0, -15.0, 0.0, 0.0],\n                [0.0, 0.0, -40.0, 10.0]\n            ]),\n            \"t0\": np.array([0.0, 0.0, 1.0, -0.5]),\n            \"bounds\": [(-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0), (-1.0, 1.0)]\n        },\n        # Case 3 (initial violation, infeasible within bounds)\n        {\n            \"C0\": np.array([5.0, 6.0, -2.0]),\n            \"S\": np.array([\n                [0.5, 0.5, 0.5, 0.5],\n                [0.5, 0.4, 0.3, 0.2],\n                [0.1, 0.1, 0.1, 0.1]\n            ]),\n            \"t0\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"bounds\": [(-0.3, 0.3), (-0.3, 0.3), (-0.3, 0.3), (-0.3, 0.3)]\n        }\n    ]\n\n    results = []\n\n    def is_stable(C_vector):\n        \"\"\"Checks if a vector of elastic constants satisfies the strict Born stability criteria.\"\"\"\n        born_metrics = A @ C_vector\n        return np.all(born_metrics > STABILITY_TOLERANCE)\n\n    for case in test_cases:\n        C0, S, t0, bounds = case[\"C0\"], case[\"S\"], case[\"t0\"], case[\"bounds\"]\n        \n        # 1. Initial State Analysis\n        C_initial = C0 + S @ t0\n        initial_violation = not is_stable(C_initial)\n\n        restored_stability = False\n        \n        if not initial_violation:\n            # If already stable, the 'restored' status is True as stability is maintained.\n            restored_stability = True\n        else:\n            # 2. Setup and run optimization problem for unstable cases.\n            # Objective function: minimize 0.5 * ||t - t0||^2\n            def objective_fun(t):\n                return 0.5 * np.sum((t - t0)**2)\n\n            # Jacobian of the objective function\n            def objective_jac(t):\n                return t - t0\n\n            # Constraints: A*C(t) >= 0 => A*C0 + (A*S)*t >= 0\n            # Scipy's 'ineq' constraint type is f(x) >= 0.\n            AS = A @ S\n            A_C0 = A @ C0\n            constraints = {\n                'type': 'ineq',\n                'fun': lambda t: A_C0 + AS @ t,\n                'jac': lambda t: AS \n            }\n\n            # Solve the Quadratic Program\n            opt_result = minimize(\n                fun=objective_fun,\n                x0=t0,\n                method='SLSQP',\n                jac=objective_jac,\n                bounds=bounds,\n                constraints=[constraints],\n                options={'ftol': 1e-12, 'disp': False}\n            )\n            \n            # 3. Post-Optimization Analysis\n            if opt_result.success:\n                # If optimizer converges, check if the solution is *strictly* stable.\n                # The solution will lie on the boundary (marginal stability), so this check\n                # for strict stability will fail.\n                t_star = opt_result.x\n                C_final = C0 + S @ t_star\n                if is_stable(C_final):\n                    restored_stability = True\n            # If optimization fails (e.g., infeasible), restored_stability remains False.\n\n        # Store the boolean pair for this case\n        results.append((initial_violation, restored_stability))\n\n    # Final print statement in the exact required format.\n    result_strings = [f\"[{'True' if v[0] else 'False'},{'True' if v[1] else 'False'}]\" for v in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}