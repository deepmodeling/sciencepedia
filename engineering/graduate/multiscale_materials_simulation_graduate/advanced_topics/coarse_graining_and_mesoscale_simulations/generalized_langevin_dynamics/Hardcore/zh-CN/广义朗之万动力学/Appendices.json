{
    "hands_on_practices": [
        {
            "introduction": "广义朗之万动力学的核心是涨落-耗散定理（FDT），它将系统的耗散（通过记忆核 $\\Gamma(t)$ 描述）与随机力的涨落特性联系起来。这个练习将通过一个具体的例子来巩固你对这一基本原理的理解。你将从一个给定的记忆核出发，利用维纳-辛钦定理计算随机力的功率谱，并验证其与记忆核傅里叶变换之间的关系，从而亲手揭示耗散与涨落之间的深刻联系。",
            "id": "3811520",
            "problem": "考虑一个处于温度为 $T$ 的平衡态中的单个标记粒子的广义朗之万方程 (GLE)：\n$$m\\,\\dot{v}(t)=-\\int_{0}^{t}\\Gamma(t-s)\\,v(s)\\,\\mathrm{d}s+R(t),$$\n其中 $m$ 是粒子质量，$v(t)$ 是其速度，$\\Gamma(t)$ 是一个因果记忆核，$R(t)$ 是一个平稳、零均值的随机力。在平衡态下，涨落-耗散定理 (FDT) 指出，随机力自相关 $C_{RR}(t)\\equiv\\langle R(t)R(0)\\rangle$ 与记忆核通过 $C_{RR}(t)=k_{B}T\\,\\Gamma(|t|)$ 相关联，其中 $k_{B}$ 是 Boltzmann 常数。对于一个平稳过程，维纳-辛钦定理断言噪声功率谱 $S_{RR}(\\omega)$ 是 $C_{RR}(t)$ 的傅里叶变换：\n$$S_{RR}(\\omega)=\\int_{-\\infty}^{\\infty}C_{RR}(t)\\,\\exp(i\\omega t)\\,\\mathrm{d}t,$$\n其中 $\\omega$ 是角频率。设记忆核为 Debye 型指数形式，\n$$\\Gamma(t)=\\gamma\\,\\exp\\!\\left(-\\frac{t}{\\tau}\\right)\\quad\\text{for }t\\geq 0,$$\n其中 $\\gamma0$ 和 $\\tau0$ 是材料参数。定义核的单边傅里叶变换\n$$\\tilde{\\Gamma}(\\omega)=\\int_{0}^{\\infty}\\Gamma(t)\\,\\exp(i\\omega t)\\,\\mathrm{d}t.$$\n从所述原理和定义出发，使用维纳-辛钦定理计算该核的噪声功率谱 $S_{RR}(\\omega)$。然后，通过显式计算 $\\tilde{\\Gamma}(\\omega)$，证明由平衡统计力学所蕴含的功率谱与单边变换之间的关系。将最终的功率谱表示为 $\\omega$、$k_{B}$、$T$、$\\gamma$ 和 $\\tau$ 的符号函数，并以国际单位制 (SI) 为基础。不需要进行数值计算，也无需四舍五入。方框内的最终答案必须是 $S_{RR}(\\omega)$ 的单个闭式表达式；方框内不要包含单位。",
            "solution": "该问题是有效的。它在科学上基于统计力学原理，特别是布朗运动理论和线性响应理论。问题是适定的、自洽的，并且所有术语都已形式化定义。\n\n主要目标是计算给定记忆核 $\\Gamma(t)$ 的噪声功率谱 $S_{RR}(\\omega)$。我们将按照问题的要求，通过两种途径来完成：首先，使用维纳-辛钦定理进行直接计算；其次，将其与核的单边傅里叶变换 $\\tilde{\\Gamma}(\\omega)$ 相关联，以证明它们之间的联系。\n\n首先，我们直接计算功率谱 $S_{RR}(\\omega)$。维纳-辛钦定理指出，功率谱是自相关函数 $C_{RR}(t)$ 的傅里叶变换：\n$$S_{RR}(\\omega)=\\int_{-\\infty}^{\\infty}C_{RR}(t)\\,\\exp(i\\omega t)\\,\\mathrm{d}t$$\n涨落-耗散定理 (FDT) 提供了随机力自相关函数 $C_{RR}(t)$ 与记忆核 $\\Gamma(t)$ 之间的联系：\n$$C_{RR}(t) = k_{B}T\\,\\Gamma(|t|)$$\n将 FDT 代入维纳-辛钦定理，得到：\n$$S_{RR}(\\omega) = \\int_{-\\infty}^{\\infty} k_{B}T\\,\\Gamma(|t|)\\,\\exp(i\\omega t)\\,\\mathrm{d}t = k_{B}T\\int_{-\\infty}^{\\infty}\\Gamma(|t|)\\,\\exp(i\\omega t)\\,\\mathrm{d}t$$\n问题指定了一个 Debye 型记忆核：\n$$\\Gamma(t)=\\gamma\\,\\exp\\!\\left(-\\frac{t}{\\tau}\\right)\\quad\\text{for }t\\geq 0$$\n由于核是因果的，因此对于 $t0$，有 $\\Gamma(t)=0$。所以，项 $\\Gamma(|t|)$ 为：\n$$\\Gamma(|t|) = \\gamma\\,\\exp\\!\\left(-\\frac{|t|}{\\tau}\\right)$$\n现在我们可以将这个具体形式代入 $S_{RR}(\\omega)$ 的积分中：\n$$S_{RR}(\\omega) = k_{B}T\\,\\gamma\\int_{-\\infty}^{\\infty}\\exp\\!\\left(-\\frac{|t|}{\\tau}\\right)\\exp(i\\omega t)\\,\\mathrm{d}t$$\n为了计算这个积分，我们在 $t=0$ 处分割积分域：\n$$S_{RR}(\\omega) = k_{B}T\\,\\gamma\\left[ \\int_{-\\infty}^{0}\\exp\\!\\left(\\frac{t}{\\tau}\\right)\\exp(i\\omega t)\\,\\mathrm{d}t + \\int_{0}^{\\infty}\\exp\\!\\left(-\\frac{t}{\\tau}\\right)\\exp(i\\omega t)\\,\\mathrm{d}t \\right]$$\n我们分别计算每个积分。对于第一个积分：\n$$\\int_{-\\infty}^{0}\\exp\\!\\left(t\\left(\\frac{1}{\\tau} + i\\omega\\right)\\right)\\,\\mathrm{d}t = \\left[\\frac{\\exp\\!\\left(t\\left(\\frac{1}{\\tau} + i\\omega\\right)\\right)}{\\frac{1}{\\tau} + i\\omega}\\right]_{-\\infty}^{0} = \\frac{1}{\\frac{1}{\\tau} + i\\omega} - 0 = \\frac{\\tau}{1+i\\omega\\tau}$$\n对于第二个积分：\n$$\\int_{0}^{\\infty}\\exp\\!\\left(t\\left(-\\frac{1}{\\tau} + i\\omega\\right)\\right)\\,\\mathrm{d}t = \\left[\\frac{\\exp\\!\\left(t\\left(-\\frac{1}{\\tau} + i\\omega\\right)\\right)}{-\\frac{1}{\\tau} + i\\omega}\\right]_{0}^{\\infty} = 0 - \\frac{1}{-\\frac{1}{\\tau} + i\\omega} = \\frac{1}{\\frac{1}{\\tau} - i\\omega} = \\frac{\\tau}{1-i\\omega\\tau}$$\n将这些结果代回 $S_{RR}(\\omega)$ 的表达式中：\n$$S_{RR}(\\omega) = k_{B}T\\,\\gamma\\left( \\frac{\\tau}{1+i\\omega\\tau} + \\frac{\\tau}{1-i\\omega\\tau} \\right)$$\n为了化简，我们进行通分：\n$$S_{RR}(\\omega) = k_{B}T\\,\\gamma\\tau\\left( \\frac{(1-i\\omega\\tau) + (1+i\\omega\\tau)}{(1+i\\omega\\tau)(1-i\\omega\\tau)} \\right) = k_{B}T\\,\\gamma\\tau\\left( \\frac{2}{1 - (i\\omega\\tau)^{2}} \\right)$$\n$$S_{RR}(\\omega) = k_{B}T\\,\\gamma\\tau\\left( \\frac{2}{1 + \\omega^{2}\\tau^{2}} \\right) = \\frac{2k_{B}T\\gamma\\tau}{1+\\omega^{2}\\tau^{2}}$$\n这就是噪声功率谱的闭式表达式。\n\n接下来，我们证明 $S_{RR}(\\omega)$ 与核的单边傅里叶变换 $\\tilde{\\Gamma}(\\omega)$ 之间的关系。问题将此变换定义为：\n$$\\tilde{\\Gamma}(\\omega)=\\int_{0}^{\\infty}\\Gamma(t)\\,\\exp(i\\omega t)\\,\\mathrm{d}t$$\n使用 Debye 核，我们有：\n$$\\tilde{\\Gamma}(\\omega) = \\int_{0}^{\\infty}\\gamma\\,\\exp\\!\\left(-\\frac{t}{\\tau}\\right)\\exp(i\\omega t)\\,\\mathrm{d}t = \\gamma\\int_{0}^{\\infty}\\exp\\!\\left(t\\left(-\\frac{1}{\\tau} + i\\omega\\right)\\right)\\,\\mathrm{d}t$$\n这与我们之前计算的第二个积分相同，只是乘以了 $\\gamma$。因此：\n$$\\tilde{\\Gamma}(\\omega) = \\gamma\\left(\\frac{\\tau}{1-i\\omega\\tau}\\right) = \\frac{\\gamma\\tau}{1-i\\omega\\tau}$$\n为了将其与 $S_{RR}(\\omega)$ 联系起来，让我们回到一般积分形式：\n$$S_{RR}(\\omega) = k_{B}T\\int_{-\\infty}^{\\infty}\\Gamma(|t|)\\,\\exp(i\\omega t)\\,\\mathrm{d}t = k_{B}T\\left[\\int_{-\\infty}^{0}\\Gamma(-t)\\exp(i\\omega t)\\,\\mathrm{d}t + \\int_{0}^{\\infty}\\Gamma(t)\\exp(i\\omega t)\\,\\mathrm{d}t\\right]$$\n第二项是 $k_{B}T\\,\\tilde{\\Gamma}(\\omega)$。对于第一项，我们进行变量代换 $s=-t$，因此 $\\mathrm{d}t=-\\mathrm{d}s$：\n$$\\int_{-\\infty}^{0}\\Gamma(-t)\\exp(i\\omega t)\\,\\mathrm{d}t = \\int_{\\infty}^{0}\\Gamma(s)\\exp(-i\\omega s)(-\\mathrm{d}s) = \\int_{0}^{\\infty}\\Gamma(s)\\exp(-i\\omega s)\\,\\mathrm{d}s$$\n这个积分是 $\\tilde{\\Gamma}(-\\omega)$ 的定义。因此，我们建立了一般关系：\n$$S_{RR}(\\omega) = k_{B}T\\left[\\tilde{\\Gamma}(-\\omega) + \\tilde{\\Gamma}(\\omega)\\right]$$\n由于核 $\\Gamma(t)$ 是一个实值函数，所以 $\\tilde{\\Gamma}(-\\omega) = \\tilde{\\Gamma}(\\omega)^{*}$，其中星号表示复共轭。该关系也可以写成：\n$$S_{RR}(\\omega) = k_{B}T\\left[\\tilde{\\Gamma}(\\omega)^{*} + \\tilde{\\Gamma}(\\omega)\\right] = 2k_{B}T\\,\\text{Re}\\left[\\tilde{\\Gamma}(\\omega)\\right]$$\n让我们对我们特定的核验证这一点。我们得到 $\\tilde{\\Gamma}(\\omega) = \\frac{\\gamma\\tau}{1-i\\omega\\tau}$。为了求其实部，我们将分子和分母同乘以分母的复共轭：\n$$\\tilde{\\Gamma}(\\omega) = \\frac{\\gamma\\tau(1+i\\omega\\tau)}{(1-i\\omega\\tau)(1+i\\omega\\tau)} = \\frac{\\gamma\\tau + i\\gamma\\tau^{2}\\omega}{1+\\omega^{2}\\tau^{2}} = \\frac{\\gamma\\tau}{1+\\omega^{2}\\tau^{2}} + i\\frac{\\gamma\\tau^{2}\\omega}{1+\\omega^{2}\\tau^{2}}$$\n实部是：\n$$\\text{Re}\\left[\\tilde{\\Gamma}(\\omega)\\right] = \\frac{\\gamma\\tau}{1+\\omega^{2}\\tau^{2}}$$\n使用这个一般关系，功率谱为：\n$$S_{RR}(\\omega) = 2k_{B}T\\,\\text{Re}\\left[\\tilde{\\Gamma}(\\omega)\\right] = 2k_{B}T\\left(\\frac{\\gamma\\tau}{1+\\omega^{2}\\tau^{2}}\\right) = \\frac{2k_{B}T\\gamma\\tau}{1+\\omega^{2}\\tau^{2}}$$\n这个结果与通过直接计算得到的结果完全相同，从而证明了平衡统计力学所蕴含的联系。噪声功率谱的最终表达式是关于频率 $\\omega$ 的洛伦兹函数。",
            "answer": "$$\\boxed{\\frac{2k_{B}T\\gamma\\tau}{1+\\omega^{2}\\tau^{2}}}$$"
        },
        {
            "introduction": "在多尺度建模中，一个常见的任务是从微观（例如，分子动力学）模拟数据中为粗粒化模型确定参数。本练习将引导你解决这样一个关键的“反求问题”：给定一个速度自相关函数（VACF），如何推导出与之对应的广义朗之万方程中的记忆核 $\\Gamma(t)$？通过掌握这一从可观测的关联函数到模型内在记忆函数的推导过程，你将能够为复杂的物理系统建立有效的粗粒化描述。",
            "id": "3811501",
            "problem": "考虑一个嵌入在致密材料中的标记粒子的标量粗粒化速度 $v(t)$，该系统在多尺度材料模拟中通过广义朗之万方程 (GLE) 进行建模。假设系统处于绝对温度为 $T$ 的热平衡状态，粒子质量为 $m$，其速度 $v(t)$ 的动力学由带有记忆核 $\\Gamma(t)$ 和满足涨落-耗散定理 (FDT) 的零均值稳态随机力 $R(t)$ 的 GLE 描述。将速度自相关函数 (VACF) 定义为 $C_{v}(t) = \\langle v(t)v(0)\\rangle$，其中 $\\langle \\cdot \\rangle$ 表示平衡系综平均。在一个特定的粗粒化模型中，原子模拟产生的 VACF 可以很好地用双指数形式表示\n$$\nC_{v}(t) = \\frac{k_{B}T}{m}\\left[a\\exp(-\\lambda_{1}t) + (1-a)\\exp(-\\lambda_{2}t)\\right],\n$$\n其中 $0  a  1$ 且 $\\lambda_1 \\neq \\lambda_2  0$ 是从模拟数据中拟合出的常数。利用 GLE 动力学和平衡统计力学的基本原理，推导出与这个给定的 VACF 一致的记忆核 $\\Gamma(t)$。将你的最终答案表示为关于 $m, a, \\lambda_1, \\lambda_2$ 的函数。然后，简要地论证你的结果如何通过检查零频极限（也称为 Green-Kubo 关系）与涨落-耗散定理（FDT）自动保持一致。",
            "solution": "问题陈述具有科学依据、良定且客观。它在广义朗之万方程 (GLE) 和平衡统计力学的既定理论框架内提供了一套完整且一致的给定条件。所要求的任务是该领域的标准推导。因此，该问题是有效的，并将提供解答。\n\n该问题要求推导与给定的双指数速度自相关函数 (VACF) $C_v(t)$ 一致的记忆核 $\\Gamma(t)$，并随后使用涨落-耗散定理 (FDT) 进行一致性检验。\n\n出发点是质量为 $m$ 的粒子的标量速度 $v(t)$ 的广义朗之万方程：\n$$\nm \\frac{d v(t)}{dt} = -\\int_{0}^{t} \\Gamma(t-t') v(t') dt' + R(t)\n$$\n在此，$\\Gamma(t)$ 是记忆核，$R(t)$ 是随机力，它是一个零均值的稳态过程，$\\langle R(t) \\rangle = 0$。一个源于正式推导 GLE 的投影算符方法的基本性质是，在时间 $t  0$ 时的随机力与初始速度 $v(0)$ 不相关。这表示为 $\\langle R(t) v(0) \\rangle = 0$（对于 $t  0$）。\n\n为求出 VACF $C_v(t) = \\langle v(t) v(0) \\rangle$ 所满足的方程，我们将 GLE 乘以 $v(0)$ 并进行平衡系综平均：\n$$\nm \\left\\langle \\frac{d v(t)}{dt} v(0) \\right\\rangle = -\\left\\langle \\left( \\int_{0}^{t} \\Gamma(t-t') v(t') dt' \\right) v(0) \\right\\rangle + \\langle R(t) v(0) \\rangle\n$$\n利用平衡平均的稳态性，左侧可写为 $m \\frac{d}{dt} \\langle v(t) v(0) \\rangle = m \\frac{dC_v(t)}{dt}$。随机力项为零，$\\langle R(t) v(0) \\rangle = 0$。根据线性性质，平均可以移入摩擦项的积分内部。这样就得到了关于 $C_v(t)$ 的沃尔泰拉积分微分方程：\n$$\nm \\frac{dC_v(t)}{dt} = -\\int_{0}^{t} \\Gamma(t-t') C_v(t') dt'\n$$\n\n这个方程在拉普拉斯域中最容易求解。我们将函数 $f(t)$ 的拉普拉斯变换定义为 $\\hat{f}(s) = \\mathcal{L}\\{f(t)\\} = \\int_{0}^{\\infty} \\exp(-st) f(t) dt$。导数的拉普拉斯变换为 $\\mathcal{L}\\{f'(t)\\} = s\\hat{f}(s) - f(0)$，卷积的拉普拉斯变换为 $\\mathcal{L}\\{\\int_0^t g(t-\\tau)h(\\tau)d\\tau\\} = \\hat{g}(s)\\hat{h}(s)$。对 $C_v(t)$ 的方程应用拉普拉斯变换，得到：\n$$\nm \\left( s\\hat{C}_v(s) - C_v(0) \\right) = - \\hat{\\Gamma}(s) \\hat{C}_v(s)\n$$\n我们可以重新整理这个代数方程，以求解拉普拉斯域中的记忆核 $\\hat{\\Gamma}(s)$：\n$$\n\\hat{\\Gamma}(s) \\hat{C}_v(s) = m C_v(0) - m s \\hat{C}_v(s)\n$$\n$$\n\\hat{\\Gamma}(s) = \\frac{m C_v(0)}{\\hat{C}_v(s)} - m s\n$$\n问题给出的 VACF 为：\n$$\nC_v(t) = \\frac{k_{B}T}{m}\\left[a\\exp(-\\lambda_{1}t) + (1-a)\\exp(-\\lambda_{2}t)\\right]\n$$\n在 $t=0$ 时的值为 $C_v(0) = \\frac{k_{B}T}{m}(a + (1-a)) = \\frac{k_{B}T}{m}$，这与能量均分定理 $\\frac{1}{2}m\\langle v^2 \\rangle = \\frac{1}{2}k_B T$ 一致。\n接下来，我们求拉普拉斯变换 $\\hat{C}_v(s)$：\n$$\n\\hat{C}_v(s) = \\mathcal{L}\\left\\{ \\frac{k_{B}T}{m}\\left[a\\exp(-\\lambda_{1}t) + (1-a)\\exp(-\\lambda_{2}t)\\right] \\right\\} = \\frac{k_{B}T}{m} \\left( \\frac{a}{s+\\lambda_1} + \\frac{1-a}{s+\\lambda_2} \\right)\n$$\n合并各项得到：\n$$\n\\hat{C}_v(s) = \\frac{k_{B}T}{m} \\frac{a(s+\\lambda_2) + (1-a)(s+\\lambda_1)}{(s+\\lambda_1)(s+\\lambda_2)} = \\frac{k_{B}T}{m} \\frac{s + (1-a)\\lambda_1 + a\\lambda_2}{(s+\\lambda_1)(s+\\lambda_2)}\n$$\n将此式和 $C_v(0)$ 代入 $\\hat{\\Gamma}(s)$ 的表达式中：\n$$\n\\hat{\\Gamma}(s) = \\frac{m \\left(\\frac{k_B T}{m}\\right)}{\\frac{k_{B}T}{m} \\frac{s + (1-a)\\lambda_1 + a\\lambda_2}{(s+\\lambda_1)(s+\\lambda_2)}} - m s = m \\frac{(s+\\lambda_1)(s+\\lambda_2)}{s + (1-a)\\lambda_1 + a\\lambda_2} - m s\n$$\n展开分子并通过公分母合并各项：\n$$\n\\hat{\\Gamma}(s) = \\frac{m (s^2 + (\\lambda_1+\\lambda_2)s + \\lambda_1\\lambda_2) - m s (s + (1-a)\\lambda_1 + a\\lambda_2)}{s + (1-a)\\lambda_1 + a\\lambda_2}\n$$\n$$\n\\hat{\\Gamma}(s) = \\frac{m s^2 + m(\\lambda_1+\\lambda_2)s + m\\lambda_1\\lambda_2 - m s^2 - m((1-a)\\lambda_1 + a\\lambda_2)s}{s + (1-a)\\lambda_1 + a\\lambda_2}\n$$\n$ms^2$ 项相互抵消。分子中线性 $s$ 项的系数简化为 $m(\\lambda_1+\\lambda_2 - ((1-a)\\lambda_1 + a\\lambda_2)) = m(a\\lambda_1 + (1-a)\\lambda_2)$。\n因此，\n$$\n\\hat{\\Gamma}(s) = \\frac{m(a\\lambda_1 + (1-a)\\lambda_2)s + m\\lambda_1\\lambda_2}{s + (1-a)\\lambda_1 + a\\lambda_2}\n$$\n为进行拉普拉斯逆变换，我们使用多项式长除法。令 $P = m(a\\lambda_1 + (1-a)\\lambda_2)$ 且 $Q = (1-a)\\lambda_1 + a\\lambda_2$。表达式为 $\\frac{Ps + m\\lambda_1\\lambda_2}{s+Q}$。\n$$\n\\frac{Ps + m\\lambda_1\\lambda_2}{s+Q} = \\frac{P(s+Q) - PQ + m\\lambda_1\\lambda_2}{s+Q} = P + \\frac{m\\lambda_1\\lambda_2 - PQ}{s+Q}\n$$\n常数项可显著简化：\n$PQ = m(a\\lambda_1 + (1-a)\\lambda_2)((1-a)\\lambda_1 + a\\lambda_2)$\n$PQ = m[a(1-a)\\lambda_1^2 + a^2\\lambda_1\\lambda_2 + (1-a)^2\\lambda_1\\lambda_2 + a(1-a)\\lambda_2^2]$\n$PQ = m[a(1-a)(\\lambda_1^2+\\lambda_2^2) + (a^2+(1-a)^2)\\lambda_1\\lambda_2]$\n分子中的项变为：\n$m\\lambda_1\\lambda_2 - PQ = m[\\lambda_1\\lambda_2 - a(1-a)(\\lambda_1^2+\\lambda_2^2) - (2a^2-2a+1)\\lambda_1\\lambda_2]$\n$= m[(1 - (2a^2-2a+1))\\lambda_1\\lambda_2 - a(1-a)(\\lambda_1^2+\\lambda_2^2)]$\n$= m[(-2a^2+2a)\\lambda_1\\lambda_2 - a(1-a)(\\lambda_1^2+\\lambda_2^2)]$\n$= m[2a(1-a)\\lambda_1\\lambda_2 - a(1-a)(\\lambda_1^2+\\lambda_2^2)]$\n$= -ma(1-a)(\\lambda_1^2-2\\lambda_1\\lambda_2+\\lambda_2^2) = -ma(1-a)(\\lambda_1-\\lambda_2)^2$\n将此结果代回 $\\hat{\\Gamma}(s)$ 的表达式中：\n$$\n\\hat{\\Gamma}(s) = m(a\\lambda_1 + (1-a)\\lambda_2) - \\frac{ma(1-a)(\\lambda_1-\\lambda_2)^2}{s + (1-a)\\lambda_1 + a\\lambda_2}\n$$\n这是记忆核的拉普拉斯变换。进行拉普拉斯逆变换，使用 $\\mathcal{L}^{-1}\\{C\\} = C\\delta(t)$（其中 $\\delta(t)$ 是狄拉克δ分布）和 $\\mathcal{L}^{-1}\\{1/(s+k)\\} = \\exp(-kt)$，得到时域记忆核 $\\Gamma(t)$：\n$$\n\\Gamma(t) = m(a\\lambda_1 + (1-a)\\lambda_2)\\delta(t) - ma(1-a)(\\lambda_1 - \\lambda_2)^2 \\exp(-((1-a)\\lambda_1 + a\\lambda_2)t)\n$$\n\n对于问题的第二部分，我们必须使用涨落-耗散定理验证其一致性。FDT 将耗散（由摩擦表示）与涨落（由相关函数表示）联系起来。具体来说，零频迁移率 $\\mu_0$ 必须等于总摩擦 $\\gamma_{tot}$ 的倒数。\n“基于力的耗散估计”指的是关于迁移率的 Green-Kubo 关系：\n$$\n\\mu_0 = \\frac{1}{k_B T} \\int_0^\\infty C_v(t) dt = \\frac{1}{k_B T} \\hat{C}_v(s=0)\n$$\n总摩擦是记忆核的时间积分：\n$$\n\\gamma_{tot} = \\int_0^\\infty \\Gamma(t) dt = \\hat{\\Gamma}(s=0)\n$$\n一致性要求为 $\\mu_0 = 1/\\gamma_{tot}$，这等价于检验是否 $\\hat{C}_v(0) / (k_B T) = 1/\\hat{\\Gamma}(0)$，或 $\\hat{\\Gamma}(0)\\hat{C}_v(0) = k_B T$。\n这个关系是 GLE 本身的直接推论，无需显式计算积分。我们回到 VACF 的拉普拉斯域方程：\n$$\nm \\left( s\\hat{C}_v(s) - C_v(0) \\right) = - \\hat{\\Gamma}(s) \\hat{C}_v(s)\n$$\n令 $s=0$ 得到：\n$$\nm (0 - C_v(0)) = - \\hat{\\Gamma}(0) \\hat{C}_v(0)\n$$\n$$\nm C_v(0) = \\hat{\\Gamma}(0) \\hat{C}_v(0)\n$$\n因为在温度 $T$ 下的平衡意味着 $C_v(0) = \\frac{k_B T}{m}$，我们将其代入：\n$$\nm \\left( \\frac{k_B T}{m} \\right) = \\hat{\\Gamma}(0) \\hat{C}_v(0)\n$$\n这直接证明了 $\\hat{\\Gamma}(0) \\hat{C}_v(0) = k_B T$，从而证实了该框架的一致性。因此，推导出的核 $\\Gamma(t)$ 与所构建的 FDT 是一致的。\n\n推导的主要结果是 $\\Gamma(t)$ 的函数形式。",
            "answer": "$$\n\\boxed{m\\left(a\\lambda_1 + (1-a)\\lambda_2\\right)\\delta(t) - ma(1-a)\\left(\\lambda_1 - \\lambda_2\\right)^2 \\exp\\left(-\\left((1-a)\\lambda_1 + a\\lambda_2\\right)t\\right)}\n$$"
        },
        {
            "introduction": "理论的优雅必须与计算的可行性相结合。广义朗之万方程中的记忆积分虽然形式简洁，但在数值模拟中直接计算的成本可能非常高，尤其是当记忆效应是长程的时候。这个动手编程练习将带你探索一种高效的算法解决方案：利用快速傅里叶变换（FFT）来加速卷积计算，从而将每一步的计算复杂度从 $\\mathcal{O}(M)$ 显著降低到 $\\mathcal{O}(\\log M)$。",
            "id": "3811483",
            "problem": "考虑在多尺度材料模拟中出现的一维广义朗之万方程 (GLE) 的记忆项。在离散时间索引 $n$ 处的记忆项被定义为离散卷积\n$$\n\\mathcal{M}_n \\equiv \\sum_{k=0}^{M-1} \\gamma_k \\, v_{n-k},\n$$\n其中 $v_n$ 是离散速度历史，$\\gamma_k$ 是由平稳核生成的记忆核权重，$M$ 是有限记忆长度，$n \\in \\{0,1,\\dots,N-1\\}$ 表示当前步。假设当 $n-k  0$ 时，$v_{n-k} = 0$。当核是平稳的并且被截断到有限范围时，这种卷积出现在 GLE 的显式时间离散化中。从以下基本依据出发：(i) 牛顿第二定律，即动量变化率等于总力；(ii) 卷积作为加权和的定义；(iii) 离散傅里叶变换 (DFT) 卷积定理，推导一种算法策略，通过利用 $\\gamma_k$ 的平稳性，将计算 $\\mathcal{M}_n$ 的摊销每步复杂度从 $\\mathcal{O}(M)$ 降低到 $\\mathcal{O}(\\log M)$。\n\n你的推导必须从离散记忆力作为卷积的定义开始，并利用离散傅里叶变换的性质，即时域中的卷积等于频域中的乘积。解释线性卷积（而非循环卷积）的必要性，以及如何使用补零的重叠保留法来实现它。明确论证对于平稳核，预先计算补零核的傅里叶变换如何构成对卷积权重的预计算。展示如何选择块大小 $B$ 和 FFT 长度 $L$（使得 $L$ 是大于或等于 $B + M - 1$ 的最小2的幂次方），如何以 $M-1$ 的重叠量分块处理信号，以及每块丢弃 $M-1$ 个瞬态样本如何实现正确的线性卷积。提供一个简单的操作计数模型，以论证当 $B$ 的选择与 $M$ 成正比时，摊销每步复杂度的规模如何变为 $\\mathcal{O}(\\log M)$。\n\n然后实现一个程序，该程序：\n- 通过将 $\\gamma_k$ 补零至长度 $L$ 并计算其 DFT，为每个测试用例预计算一次频域核权重。\n- 实现一个基于重叠保留法和快速傅里叶变换 (FFT) 的卷积来计算 $n \\in \\{0,\\dots,N-1\\}$ 的 $\\mathcal{M}_n$。\n- 使用直接卷积计算参考结果。\n- 为每个测试用例报告两个量：基于 FFT 的结果与直接结果之间的最大绝对误差，以及一个定义如下的理论每步成本比\n$$\n\\mathcal{R} \\equiv \\frac{M}{\\frac{2 L \\log_2 L + L}{B}},\n$$\n该比率比较了朴素的每步操作计数（与 $M$ 成正比）与每块进行一次正向 FFT、一次逆向 FFT 和一次逐点复数乘法的摊销 FFT 每步成本。\n\n测试套件：\n- 情况1：$N=64$，$M=17$，平稳指数核 $\\gamma_k = \\exp(-k/\\tau)$，其中 $\\tau=5$；$v_n$ 是具有固定种子的独立同分布标准正态随机变量；块大小 $B=M$。\n- 情况2：$N=64$，$M=1$，$\\gamma_0 = 1$ 且无其他项；$v_n$ 是具有固定种子的独立同分布标准正态随机变量；$B=M$。\n- 情况3：$N=96$，$M=33$，幂律核 $\\gamma_k = (k+1)^{-p}$，其中 $p=1.5$；$v_n$ 是具有固定种子的独立同分布标准正态随机变量；$B=M$。\n- 情况4：$N=10$，$M=8$，零核，即对所有 $k$ 都有 $\\gamma_k = 0$；$v_n$ 是具有固定种子的独立同分布标准正态随机变量；$B=M$。\n- 情况5：$N=32$，$M=5$，三角核 $\\gamma_k = (M-k)/M$；确定性斜坡信号 $v_n = n$；$B=M$。\n\n你的程序必须输出一行，其中包含这些情况的配对列表，每个配对为 $[\\text{max\\_abs\\_error}, \\mathcal{R}]$（浮点数）。要求的输出格式是包含一个类 JSON 列表的单行，例如，\n\"[ [error1,ratio1],[error2,ratio2],... ]\"。",
            "solution": "任务是推导并实现一种高效算法，用于计算广义朗之万方程 (GLE) 中的离散记忆项，并将其每步复杂度从 $\\mathcal{O}(M)$ 降低到 $\\mathcal{O}(\\log M)$。推导过程必须基于基本原理，包括牛顿第二定律（根据 GLE 的上下文）、卷积的定义以及离散傅里叶变换 (DFT) 的卷积定理。\n\n在离散时间步 $n$ 的记忆项 $\\mathcal{M}_n$ 定义为对过去速度历史 $v$ 的求和：\n$$\n\\mathcal{M}_n \\equiv \\sum_{k=0}^{M-1} \\gamma_k \\, v_{n-k}\n$$\n这里，$\\gamma_k$ 是长度为 $M$ 的平稳记忆核的权重，$v_j$ 是时间步 $j$ 的速度，我们假设当 $j  0$ 时，$v_j = 0$。该方程对 $n \\in \\{0, 1, \\dots, N-1\\}$ 进行求值。\n\n对每个时间步 $n$ 直接计算 $\\mathcal{M}_n$ 需要 $M$ 次乘法和 $M-1$ 次加法。因此，在 $N$ 个时间步上的模拟，其记忆项的总计算成本将与 $\\mathcal{O}(NM)$ 成正比。对于记忆长度 $M$ 较大的模拟，这个成本可能会高得令人望而却步。\n\n$\\mathcal{M}_n$ 的表达式是核序列 $\\gamma = \\{\\gamma_k\\}_{k=0}^{M-1}$ 和速度历史 $v = \\{v_j\\}$ 的离散线性卷积。我们可以将其写作 $\\mathcal{M}_n = (\\gamma * v)_n$。离散傅里叶变换 (DFT) 的卷积定理为加速此计算提供了一条途径。该定理指出，对于两个长度为 $L$ 的序列 $a$ 和 $b$，其循环卷积的 DFT 是它们各自 DFT 的逐元素乘积：\n$$\n\\text{DFT}(a \\circledast b) = \\text{DFT}(a) \\cdot \\text{DFT}(b)\n$$\n其中 $\\circledast$ 表示循环卷积，$\\cdot$ 表示逐元素乘法。然后，通过一次逆 DFT 可以在时域中恢复卷积后的序列：$a \\circledast b = \\text{IDFT}(\\text{DFT}(a) \\cdot \\text{DFT}(b))$。\n\n然而，记忆项 $\\mathcal{M}_n$ 是一个*线性*卷积。直接对长度为 $M$ 的序列应用 DFT 卷积定理会得到*循环*卷积，它会错误地将序列环绕，从而产生混叠误差。为了使用 DFT 计算线性卷积，我们必须将问题嵌入到一个更大的空间中。一个长度为 $M$ 的序列和一个长度为 $B$ 的序列的线性卷积结果是一个长度为 $M+B-1$ 的序列。因此，为避免环绕效应，必须对长度为 $L \\ge M+B-1$ 的序列执行 DFT。这可以通过将原始序列用零填充到长度 $L$ 来实现。\n\n直接卷积的高成本源于每个时间步都重新计算求和。由于核 $\\gamma_k$ 是平稳的（时不变的），它对卷积的贡献可以被预先计算。其策略是使用一种基于块的快速卷积算法，例如重叠保留法。这种方法将快速傅里叶变换 (FFT)——一种计算 DFT 的高效算法——的成本摊销到许多时间步上。\n\n重叠保留法的算法流程如下：\n1.  **参数选择**：为处理速度信号 $v$ 选择一个块大小 $B$。设核的大小为 $M$。FFT 长度 $L$ 必须满足 $L \\ge M+B-1$。为了获得最佳的 FFT 性能，$L$ 通常被选为大于或等于 $M+B-1$ 的最小2的幂次方。\n2.  **核的预计算**：将核序列 $\\gamma = [\\gamma_0, \\gamma_1, \\dots, \\gamma_{M-1}]$ 用零填充到长度 $L$。然后计算其 DFT，记为 $\\hat{\\gamma} = \\text{DFT}([\\gamma_0, \\dots, \\gamma_{M-1}, 0, \\dots, 0])$。由于 $\\gamma$ 是平稳的，这对整个模拟来说是一次性预计算，代表了频域中预计算的卷积权重。\n3.  **信号分块与处理**：速度信号 $v$ 被分块重叠处理。每个待变换的数据块长度为 $L$。它由前一个数据段末尾的 $M-1$ 个样本和附加的速度信号中的 $B$ 个新样本构成。\n4.  **逐块卷积**：对每个长度为 $L$ 的数据块 $v_{\\text{block}}$：\n    a. 计算其 DFT，$\\hat{v}_{\\text{block}} = \\text{DFT}(v_{\\text{block}})$。\n    b. 在频域中执行逐元素乘法：$\\hat{\\mathcal{M}}_{\\text{block}} = \\hat{\\gamma} \\cdot \\hat{v}_{\\text{block}}$。\n    c. 计算逆 DFT 以返回时域：$\\mathcal{M}_{\\text{block}} = \\text{IDFT}(\\hat{\\mathcal{M}}_{\\text{block}})$。\n5.  **重叠保留**：得到的序列 $\\mathcal{M}_{\\text{block}}$ 是补零核与数据块的 $L$ 点循环卷积。$\\mathcal{M}_{\\text{block}}$ 的前 $M-1$ 个点由于循环卷积的混叠效应而被污染，因为它们依赖于数据块的环绕部分。这 $M-1$ 个点被丢弃。其后的 $B$ 个点与线性卷积的结果相同，并被保留作为当前 $B$ 个时间步块的有效输出。\n6.  **拼接**：将每个块的有效 $B$ 点段拼接起来，形成完整的记忆项历史 $\\mathcal{M}_0, \\mathcal{M}_1, \\dots, \\mathcal{M}_{N-1}$。初始条件 $v_j=0$ for $j0$ 通过在处理第一个块之前在速度信号前面附加 $M-1$ 个零来处理。\n\n**摊销复杂度分析**：\n长度为 $L$ 的 FFT 的计算成本是 $\\mathcal{O}(L \\log L)$。对于每个块，我们执行一次正向 FFT、一次逆向 FFT 和 $L$ 次复数乘法。因此，每个块的总成本主要由 FFT 决定，达到 $\\mathcal{O}(L \\log L)$。每个块产生 $B$ 个有效输出点。因此，每个时间步的摊销成本是 $\\frac{\\mathcal{O}(L \\log L)}{B}$。\n\n为了分析其规模，我们选择一个与记忆长度 $M$ 成正比的块大小 $B$，例如 $B=M$。那么，我们需要一个 FFT 长度 $L \\ge M+B-1 = 2M-1$。选择 $L$ 作为下一个2的幂次方使得 $L$ 与 $M$ 成正比（即 $L \\approx 2M$）。每步的摊销成本变为：\n$$\n\\text{Cost per step} \\propto \\frac{L \\log L}{B} \\propto \\frac{M \\log M}{M} = \\mathcal{O}(\\log M)\n$$\n这表明与直接卷积的 $\\mathcal{O}(M)$ 复杂度相比，有了显著的降低。\n\n理论每步成本比 $\\mathcal{R}$ 比较了直接方法的运算计数（与 $M$ 成正比）与摊销 FFT 方法的计数。将大小为 $L$ 的 FFT 的运算计数近似为 $L \\log_2 L$，一个块的成本（一次正向 FFT，一次逆向 FFT 和 $L$ 次逐点乘法）是 $2L \\log_2 L + L$。摊销到 $B$ 步上，每步的成本是 $\\frac{2L \\log_2 L + L}{B}$。因此，该比率为：\n$$\n\\mathcal{R} \\equiv \\frac{M}{\\frac{2 L \\log_2 L + L}{B}}\n$$\n该比率量化了基于 FFT 的算法相对于直接求和所实现的理论加速效果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all specified test cases.\n    It computes the memory term using both direct convolution and\n    an overlap-save FFT-based method, then reports the maximum\n    absolute error and a theoretical cost ratio.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Exponential kernel, random velocity\n        {\n            'N': 64, 'M': 17, 'B': 17,\n            'gamma_gen': lambda M: np.exp(-np.arange(M) / 5.0),\n            'v_gen': lambda N, seed: np.random.RandomState(seed).standard_normal(N)\n        },\n        # Case 2: Delta kernel (M=1), random velocity\n        {\n            'N': 64, 'M': 1, 'B': 1,\n            'gamma_gen': lambda M: np.array([1.0]),\n            'v_gen': lambda N, seed: np.random.RandomState(seed).standard_normal(N)\n        },\n        # Case 3: Power-law kernel, random velocity\n        {\n            'N': 96, 'M': 33, 'B': 33,\n            'gamma_gen': lambda M: (np.arange(M) + 1.0)**(-1.5),\n            'v_gen': lambda N, seed: np.random.RandomState(seed).standard_normal(N)\n        },\n        # Case 4: Zero kernel, random velocity\n        {\n            'N': 10, 'M': 8, 'B': 8,\n            'gamma_gen': lambda M: np.zeros(M),\n            'v_gen': lambda N, seed: np.random.RandomState(seed).standard_normal(N)\n        },\n        # Case 5: Triangular kernel, deterministic ramp velocity\n        {\n            'N': 32, 'M': 5, 'B': 5,\n            'gamma_gen': lambda M: (M - np.arange(M)) / M if M  0 else np.array([]),\n            'v_gen': lambda N, seed: np.arange(N, dtype=float)\n        }\n    ]\n\n    results = []\n\n    for i, case in enumerate(test_cases):\n        N, M, B = case['N'], case['M'], case['B']\n        \n        # Generate kernel gamma\n        gamma = case['gamma_gen'](M)\n        \n        # Generate velocity v with a fixed seed for each case\n        v = case['v_gen'](N, seed=i)\n\n        # --- Direct Convolution (Reference) ---\n        # np.convolve in 'full' mode computes the linear convolution.\n        # The result has length N + M - 1. We take the first N points.\n        if N == 0:\n            m_direct = np.array([])\n        elif M == 0:\n            m_direct = np.zeros(N)\n        else:\n            m_direct = np.convolve(v, gamma, mode='full')[:N]\n\n        # --- Overlap-Save FFT Convolution ---\n        if N == 0:\n            m_fft = np.array([])\n        elif M == 0:\n            m_fft = np.zeros(N)\n        else:\n            # Determine FFT length L\n            L_min = M + B - 1\n            if L_min = 0:\n                L = 1\n            else:\n                L = 1  (L_min - 1).bit_length()\n\n            # Precompute FFT of zero-padded kernel\n            gamma_padded = np.zeros(L)\n            gamma_padded[:M] = gamma\n            gamma_fft = np.fft.fft(gamma_padded)\n\n            # Pad velocity signal at the start with M-1 zeros\n            # to handle boundary conditions v_{n0}=0\n            v_padded = np.pad(v, (M - 1, 0), 'constant')\n            \n            num_blocks = int(np.ceil(N / B))\n            fft_results = []\n            \n            for j in range(num_blocks):\n                start_idx = j * B\n                end_idx = start_idx + L\n                \n                block_v = np.zeros(L)\n                # Take a slice of v_padded, pad with zeros if it's too short\n                v_slice = v_padded[start_idx:end_idx]\n                block_v[:len(v_slice)] = v_slice\n\n                # Convolution in frequency domain\n                block_v_fft = np.fft.fft(block_v)\n                conv_block_fft = gamma_fft * block_v_fft\n                conv_block = np.fft.ifft(conv_block_fft).real\n\n                # Discard M-1 transient samples and save the valid part\n                valid_part = conv_block[M - 1 : M - 1 + B]\n                fft_results.append(valid_part)\n\n            m_fft = np.concatenate(fft_results)[:N]\n\n        # --- Calculate Metrics ---\n        # Maximum absolute error\n        if N  0:\n            max_abs_error = np.max(np.abs(m_direct - m_fft))\n        else:\n            max_abs_error = 0.0\n\n        # Theoretical per-step cost ratio\n        L_min_for_R = M + B - 1\n        if L_min_for_R = 0:\n            L_for_R = 1\n        else:\n             L_for_R = 1  (L_min_for_R - 1).bit_length()\n        \n        if B == 0 or M == 0:\n            cost_ratio = float('inf') if M  0 else 0.0\n        else:\n            amortized_fft_cost = (2 * L_for_R * np.log2(L_for_R) + L_for_R) / B\n            if amortized_fft_cost  0:\n                cost_ratio = M / amortized_fft_cost\n            else:\n                cost_ratio = float('inf') # Avoid division by zero if cost is somehow zero\n\n        results.append([max_abs_error, cost_ratio])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join(f\"[{e},{r}]\" for e, r in results) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}