{
    "hands_on_practices": [
        {
            "introduction": "In Hamiltonian-based adaptive resolution methods, the potential energy of the system explicitly depends on the particles' absolute positions through a switching function $w(x)$. This spatial dependency gives rise to an additional \"thermodynamic force,\" which is unphysical but necessary to ensure thermodynamic consistency. This exercise provides a concrete calculation to understand how this force originates from the gradient of the potential and how its magnitude is controlled by a key simulation parameter, the hybrid width $L_h$ .",
            "id": "3790089",
            "problem": "Consider a one-dimensional Adaptive Resolution Simulation (AdResS) setup for a multiscale materials simulation, where a particle moves along the spatial coordinate $x$ across a hybrid region of width $L_{h}$. The hybrid region smoothly blends atomistic and coarse-grained descriptions through a position-dependent mixing function $w(x)$. Assume Hamiltonian (energy-based) interpolation of pair interactions such that the effective potential energy for a single interacting pair at separation $r$ and position $x$ is\n$$\nU_{\\text{eff}}(x,r) = w(x)\\,U_{\\text{AT}}(r) + \\bigl(1 - w(x)\\bigr)\\,U_{\\text{CG}}(r),\n$$\nwhere $U_{\\text{AT}}(r)$ is the atomistic pair potential and $U_{\\text{CG}}(r)$ is the coarse-grained pair potential. Because $w(x)$ depends on position, the force along $x$ includes an additional term arising from the chain rule. This extra term can cause a force discontinuity if its maximum magnitude is too large.\n\nLet the atomistic pair potential be the Lennard–Jones potential\n$$\nU_{\\text{AT}}(r) = 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right],\n$$\nwith minimum at $r_{m} = 2^{1/6}\\sigma$ and minimum value $U_{\\text{AT}}(r_{m}) = -\\varepsilon$. Let the coarse-grained potential be the Weeks–Chandler–Andersen (WCA) truncation of Lennard–Jones,\n$$\nU_{\\text{CG}}(r) = \n\\begin{cases}\nU_{\\text{AT}}(r) + \\varepsilon, & r \\le r_{c}, \\\\\n0, & r > r_{c},\n\\end{cases}\n\\quad\\text{with}\\quad r_{c} = 2^{1/6}\\sigma,\n$$\nso that $U_{\\text{CG}}(r_{m}) = 0$. The mixing function is chosen to be the smooth $C^{1}$ function\n$$\nw(x) = \n\\begin{cases}\n0, & x \\le 0, \\\\\n\\sin^{2}\\!\\left(\\dfrac{\\pi x}{2 L_{h}}\\right), & 0 < x < L_{h}, \\\\\n1, & x \\ge L_{h}.\n\\end{cases}\n$$\nAssume the worst-case scenario for the force discontinuity occurs for a pair at separation $r = r_{m}$ within the hybrid region where the gradient of $w(x)$ attains its maximum. Let the Lennard–Jones depth be $\\varepsilon = 2.0\\,\\text{kJ/mol}$, and let the threshold for the maximum allowed magnitude of the discontinuity-inducing force along $x$ be $F_{\\text{thr}} = 1.0 \\times 10^{-11}\\,\\text{N}$. Use Avogadro’s constant $N_{A} = 6.02214076 \\times 10^{23}\\,\\text{mol}^{-1}$.\n\nUsing only fundamental principles (force is the negative gradient of potential energy and standard calculus), determine the minimal hybrid width $L_{h}$ that ensures the maximum magnitude of the force discontinuity induced by the position dependence of $w(x)$ does not exceed $F_{\\text{thr}}$. Express your final answer in nanometers and round your result to four significant figures.",
            "solution": "The problem asks for the minimal hybrid width $L_{h}$ in an Adaptive Resolution Simulation (AdResS) setup, such that the magnitude of an extra force term arising from the spatial dependence of the potential energy does not exceed a given threshold.\n\nThe first step is to identify the force in question. According to fundamental principles of Newtonian mechanics, the force $\\vec{F}$ on a particle is the negative gradient of its potential energy $U$. In one dimension, the force component $F_x$ along the spatial coordinate $x$ is given by\n$$\nF_x = -\\frac{\\partial U}{\\partial x}.\n$$\nThe problem defines an effective potential energy $U_{\\text{eff}}$ for an interacting pair of particles. This potential depends not only on the inter-particle separation $r$ but also on the absolute position $x$ of the pair (e.g., their center of mass) via a mixing function $w(x)$. The effective potential is\n$$\nU_{\\text{eff}}(x,r) = w(x)\\,U_{\\text{AT}}(r) + \\bigl(1 - w(x)\\bigr)\\,U_{\\text{CG}}(r).\n$$\nThe force component along $x$ resulting from this potential is obtained by differentiating $U_{\\text{eff}}(x,r)$ with respect to $x$. The terms $U_{\\text{AT}}(r)$ and $U_{\\text{CG}}(r)$ depend only on the separation $r$, which is independent of the absolute position $x$. Therefore, when we apply the partial derivative with respect to $x$, we use the chain rule on $w(x)$:\n$$\nF_x = -\\frac{\\partial}{\\partial x} \\left[ w(x)\\,U_{\\text{AT}}(r) + U_{\\text{CG}}(r) - w(x)\\,U_{\\text{CG}}(r) \\right].\n$$\n$$\nF_x = -\\left[ \\frac{dw(x)}{dx}\\,U_{\\text{AT}}(r) - \\frac{dw(x)}{dx}\\,U_{\\text{CG}}(r) \\right].\n$$\nThis can be factored to yield the expression for the so-called \"thermodynamic force,\" which is the \"discontinuity-inducing force\" mentioned in the problem:\n$$\nF_{\\text{th}}(x,r) = -\\frac{dw(x)}{dx} \\left[ U_{\\text{AT}}(r) - U_{\\text{CG}}(r) \\right].\n$$\nThe problem requires us to find the minimal $L_{h}$ that ensures the maximum magnitude of this force, $|F_{\\text{th}}(x,r)|_{\\text{max}}$, does not exceed the threshold $F_{\\text{thr}}$. The maximum magnitude is given by\n$$\n|F_{\\text{th}}(x,r)|_{\\text{max}} = \\max_{x,r} \\left| -\\frac{dw(x)}{dx} \\left[ U_{\\text{AT}}(r) - U_{\\text{CG}}(r) \\right] \\right| = \\max_x \\left| \\frac{dw(x)}{dx} \\right| \\cdot \\max_r \\left| U_{\\text{AT}}(r) - U_{\\text{CG}}(r) \\right|.\n$$\nThe problem specifies a worst-case scenario where the separation is fixed at $r = r_m = 2^{1/6}\\sigma$ and the position $x$ is where the gradient of $w(x)$ is maximal. Thus, we need to evaluate the two terms under these specific conditions.\n\nFirst, let us evaluate the potential energy difference at $r = r_m$. We are given:\n$U_{\\text{AT}}(r_m) = -\\varepsilon$.\nThe coarse-grained potential is defined for $r \\le r_c = 2^{1/6}\\sigma$ as $U_{\\text{CG}}(r) = U_{\\text{AT}}(r) + \\varepsilon$. Since $r_m = r_c$, we have:\n$U_{\\text{CG}}(r_m) = U_{\\text{AT}}(r_m) + \\varepsilon = -\\varepsilon + \\varepsilon = 0$.\nThe difference in potential energy is therefore:\n$U_{\\text{AT}}(r_m) - U_{\\text{CG}}(r_m) = -\\varepsilon - 0 = -\\varepsilon$.\nThe magnitude of this difference is $|-\\varepsilon| = \\varepsilon$.\n\nSecond, we must find the maximum magnitude of the gradient of the mixing function, $\\left| \\frac{dw(x)}{dx} \\right|$. The mixing function inside the hybrid region ($0 < x < L_h$) is\n$$\nw(x) = \\sin^{2}\\!\\left(\\dfrac{\\pi x}{2 L_{h}}\\right).\n$$\nIts derivative with respect to $x$ is:\n$$\n\\frac{dw}{dx} = \\frac{d}{dx} \\left[ \\sin^{2}\\!\\left(\\dfrac{\\pi x}{2 L_{h}}\\right) \\right] = 2\\sin\\left(\\dfrac{\\pi x}{2 L_{h}}\\right)\\cos\\left(\\dfrac{\\pi x}{2 L_{h}}\\right) \\cdot \\frac{\\pi}{2 L_{h}}.\n$$\nUsing the trigonometric identity $\\sin(2\\theta) = 2\\sin(\\theta)\\cos(\\theta)$, we simplify the derivative to:\n$$\n\\frac{dw}{dx} = \\frac{\\pi}{2 L_{h}} \\sin\\left(\\frac{\\pi x}{L_{h}}\\right).\n$$\nTo find the maximum value of this derivative in the interval $x \\in (0, L_h)$, we find where the sine function is maximal. The function $\\sin(\\theta)$ has a maximum value of $1$. This occurs when its argument is $\\theta = \\frac{\\pi}{2}$. Here, the argument is $\\frac{\\pi x}{L_{h}}$, so the maximum occurs at:\n$$\n\\frac{\\pi x}{L_{h}} = \\frac{\\pi}{2} \\implies x = \\frac{L_{h}}{2}.\n$$\nThis position is exactly in the middle of the hybrid region, which is consistent with the problem's premise. The maximum value of the gradient's magnitude is:\n$$\n\\max_{x \\in (0, L_h)} \\left| \\frac{dw}{dx} \\right| = \\left| \\frac{\\pi}{2 L_{h}} \\sin\\left(\\frac{\\pi}{2}\\right) \\right| = \\frac{\\pi}{2 L_{h}}.\n$$\nNow we can assemble the expression for the maximum magnitude of the force:\n$$\n|F_{\\text{th}}|_{\\text{max}} = \\left( \\frac{\\pi}{2 L_{h}} \\right) \\cdot \\varepsilon.\n$$\nThe problem requires that this maximum force does not exceed the threshold $F_{\\text{thr}}$. The minimal width $L_h$ corresponds to the equality:\n$$\n|F_{\\text{th}}|_{\\text{max}} = F_{\\text{thr}} \\implies \\frac{\\pi \\varepsilon}{2 L_{h}} = F_{\\text{thr}}.\n$$\nSolving for $L_h$, we obtain:\n$$\nL_{h} = \\frac{\\pi \\varepsilon}{2 F_{\\text{thr}}}.\n$$\nTo calculate the numerical value, we must ensure all units are consistent. The energy $\\varepsilon = 2.0\\,\\text{kJ/mol}$ is a molar quantity. We must convert it to energy per particle in Joules using Avogadro's constant, $N_A = 6.02214076 \\times 10^{23}\\,\\text{mol}^{-1}$.\n$$\n\\varepsilon_{\\text{particle}} = \\frac{2.0\\,\\text{kJ/mol} \\times 1000\\,\\text{J/kJ}}{6.02214076 \\times 10^{23}\\,\\text{mol}^{-1}} = \\frac{2.0 \\times 10^3}{6.02214076 \\times 10^{23}}\\,\\text{J}.\n$$\nThe force threshold is given as $F_{\\text{thr}} = 1.0 \\times 10^{-11}\\,\\text{N}$. Substituting these values into the expression for $L_h$:\n$$\nL_{h} = \\frac{\\pi \\cdot \\left(\\dfrac{2.0 \\times 10^3}{6.02214076 \\times 10^{23}}\\right)\\,\\text{J}}{2 \\cdot (1.0 \\times 10^{-11}\\,\\text{N})}.\n$$\nThe units are Joules per Newton ($\\text{J}/\\text{N}$), which is equivalent to meters ($\\text{m}$), as $1\\,\\text{J} = 1\\,\\text{N}\\cdot\\text{m}$.\n$$\nL_{h} = \\frac{\\pi \\cdot 2.0 \\times 10^3}{2 \\cdot 1.0 \\times 10^{-11} \\cdot 6.02214076 \\times 10^{23}}\\,\\text{m}.\n$$\n$$\nL_{h} = \\frac{\\pi \\times 10^3}{6.02214076 \\times 10^{(23-11)}}\\,\\text{m} = \\frac{\\pi \\times 10^3}{6.02214076 \\times 10^{12}}\\,\\text{m}.\n$$\n$$\nL_{h} = \\frac{\\pi}{6.02214076 \\times 10^9}\\,\\text{m} \\approx 0.5216719 \\times 10^{-9}\\,\\text{m}.\n$$\nThe problem asks for the result in nanometers ($1\\,\\text{nm} = 10^{-9}\\,\\text{m}$).\n$$\nL_{h} \\approx 0.5216719\\,\\text{nm}.\n$$\nFinally, rounding the result to four significant figures gives:\n$$\nL_{h} \\approx 0.5217\\,\\text{nm}.\n$$",
            "answer": "$$\\boxed{0.5217}$$"
        },
        {
            "introduction": "A primary goal of many AdResS implementations is to maintain mechanical equilibrium, such as a uniform density profile $\\rho_0$, across the hybrid region. Deviations in density create pressure gradients, which must be counteracted by an external thermodynamic force that is iteratively adjusted in a feedback loop. This practice guides you through implementing the core numerical algorithm for this iterative force update, connecting macroscopic concepts like pressure and compressibility to the microscopic forces applied in the simulation .",
            "id": "3790145",
            "problem": "A one-dimensional hybrid region in Adaptive Resolution Simulation (AdResS) is discretized into a uniform grid of points with spacing $\\Delta x$. Let the measured number density profile at iteration $n$ be $\\rho^{(n)}(x)$ and the reference uniform number density be $\\rho_0$. For small deviations from $\\rho_0$ and isothermal conditions, mechanical equilibrium requires the pressure gradient to be balanced by a position-dependent body force, which is implemented as the thermodynamic force acting on particles. The isothermal compressibility $\\kappa_T$ relates pressure variations to density variations about $\\rho_0$. Starting from these principles, derive a consistent discrete update for the thermodynamic force field $f_{\\mathrm{th}}^{(n+1)}(x)$ using a second-order accurate finite-difference approximation of the density gradient on the grid and an under-relaxation scheme with parameter $\\alpha \\in (0,1]$, and apply one of the specified boundary conditions. Do not assume shortcuts beyond the fundamental laws stated. Your program must implement this update for each provided test case and return the next-iteration thermodynamic force values at the grid points.\n\nDefinitions and constraints to use:\n- The Adaptive Resolution Simulation (AdResS) framework enforces mechanical equilibrium in the hybrid region via a thermodynamic force field $f_{\\mathrm{th}}(x)$ applied to particles.\n- The mechanical equilibrium in one spatial dimension requires $\\partial_x p(x) + \\rho(x) f_{\\mathrm{th}}(x) = 0$, where $p(x)$ is pressure and $\\rho(x)$ is number density.\n- For small deviations from $\\rho_0$, the linearized equation of state at constant temperature uses the isothermal compressibility $\\kappa_T$ defined as $\\kappa_T = \\frac{1}{\\rho}\\left(\\frac{\\partial \\rho}{\\partial p}\\right)_T$, linking $\\partial_x p(x)$ to $\\partial_x \\rho(x)$ near $\\rho_0$.\n- Discretization: use a second-order accurate finite-difference approximation of $\\partial_x \\rho(x)$ on a uniform grid. For interior points, use a centered difference. For boundary points, use a one-sided second-order accurate difference.\n- Under-relaxation: update the force via $f_{\\mathrm{th}}^{(n+1)}(x_i)$ obtained by mixing the previous iteration $f_{\\mathrm{th}}^{(n)}(x_i)$ with the new estimate based on the measured density gradient using a mixing factor $\\alpha$.\n- Boundary conditions to be applied after the update:\n  - Dirichlet: set $f_{\\mathrm{th}}^{(n+1)}$ to $0$ at both ends of the domain.\n  - Neumann: set $\\partial_x f_{\\mathrm{th}}^{(n+1)} = 0$ at both ends of the domain, implemented by copying the adjacent interior value to the boundaries.\n\nUnits:\n- Number density $\\rho$ must be in $\\mathrm{m}^{-3}$.\n- Spacing $\\Delta x$ must be in $\\mathrm{m}$.\n- Isothermal compressibility $\\kappa_T$ must be in $\\mathrm{Pa}^{-1}$.\n- The thermodynamic force $f_{\\mathrm{th}}$ must be expressed in $\\mathrm{N}$ per particle at each grid point.\n\nYour program must implement the algorithm with no external input and produce a single line of output with the results for each test case as a list of lists of floats (in $\\mathrm{N}$), using Python default float string formatting, aggregated into one bracketed, comma-separated list (for example, $\\left[\\text{case}_1,\\text{case}_2,\\dots\\right]$). Each test case must be processed independently.\n\nTest suite:\n- Case $1$ (happy path):\n  - $\\rho_0 = 3.343\\times 10^{28}\\ \\mathrm{m}^{-3}$,\n  - $\\kappa_T = 4.5\\times 10^{-10}\\ \\mathrm{Pa}^{-1}$,\n  - $\\Delta x = 5.0\\times 10^{-10}\\ \\mathrm{m}$,\n  - $\\rho^{(n)} = \\left[\\rho_0\\times 1.00,\\ \\rho_0\\times 1.02,\\ \\rho_0\\times 1.05,\\ \\rho_0\\times 1.02,\\ \\rho_0\\times 1.00\\right]$,\n  - $\\alpha = 0.8$,\n  - Boundary condition: Dirichlet,\n  - $f_{\\mathrm{th}}^{(n)} = \\left[0.0,\\ 0.0,\\ 0.0,\\ 0.0,\\ 0.0\\right]\\ \\mathrm{N}$.\n- Case $2$ (uniform density, boundary check):\n  - $\\rho_0 = 3.343\\times 10^{28}\\ \\mathrm{m}^{-3}$,\n  - $\\kappa_T = 4.5\\times 10^{-10}\\ \\mathrm{Pa}^{-1}$,\n  - $\\Delta x = 5.0\\times 10^{-10}\\ \\mathrm{m}$,\n  - $\\rho^{(n)} = \\left[\\rho_0\\times 1.00,\\ \\rho_0\\times 1.00,\\ \\rho_0\\times 1.00,\\ \\rho_0\\times 1.00,\\ \\rho_0\\times 1.00\\right]$,\n  - $\\alpha = 1.0$,\n  - Boundary condition: Dirichlet,\n  - $f_{\\mathrm{th}}^{(n)} = \\left[0.0,\\ 0.0,\\ 0.0,\\ 0.0,\\ 0.0\\right]\\ \\mathrm{N}$.\n- Case $3$ (step change with Neumann boundary):\n  - $\\rho_0 = 3.343\\times 10^{28}\\ \\mathrm{m}^{-3}$,\n  - $\\kappa_T = 4.5\\times 10^{-10}\\ \\mathrm{Pa}^{-1}$,\n  - $\\Delta x = 5.0\\times 10^{-10}\\ \\mathrm{m}$,\n  - $\\rho^{(n)} = \\left[\\rho_0\\times 0.95,\\ \\rho_0\\times 0.95,\\ \\rho_0\\times 1.10,\\ \\rho_0\\times 1.10,\\ \\rho_0\\times 1.10\\right]$,\n  - $\\alpha = 0.5$,\n  - Boundary condition: Neumann,\n  - $f_{\\mathrm{th}}^{(n)} = \\left[0.0,\\ 0.0,\\ 0.0,\\ 0.0,\\ 0.0\\right]\\ \\mathrm{N}$.\n- Case $4$ (non-monotonic small fluctuations with Neumann boundary):\n  - $\\rho_0 = 3.343\\times 10^{28}\\ \\mathrm{m}^{-3}$,\n  - $\\kappa_T = 4.5\\times 10^{-10}\\ \\mathrm{Pa}^{-1}$,\n  - $\\Delta x = 5.0\\times 10^{-10}\\ \\mathrm{m}$,\n  - $\\rho^{(n)} = \\left[\\rho_0\\times 1.00,\\ \\rho_0\\times 0.98,\\ \\rho_0\\times 1.02,\\ \\rho_0\\times 1.01,\\ \\rho_0\\times 0.99,\\ \\rho_0\\times 1.00\\right]$,\n  - $\\alpha = 0.7$,\n  - Boundary condition: Neumann,\n  - $f_{\\mathrm{th}}^{(n)} = \\left[0.0,\\ 0.0,\\ 0.0,\\ 0.0,\\ 0.0,\\ 0.0\\right]\\ \\mathrm{N}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list containing the next-iteration force values for the corresponding test case (for example, $\\left[[f_{1,1},\\dots,f_{1,N_1}],[f_{2,1},\\dots,f_{2,N_2}],\\dots\\right]$), in units of $\\mathrm{N}$ per particle.",
            "solution": "The user wants a meticulous and exacting STEM professor to solve a physics problem. I will first validate the problem statement.\n\n### Step 1: Problem Validation\n\nThe problem requires the derivation and implementation of a numerical update rule for the thermodynamic force in an Adaptive Resolution Simulation (AdResS).\n\n#### Extracted Givens\n- **Framework**: One-dimensional hybrid region in AdResS.\n- **Grid**: Uniform grid with spacing $\\Delta x$.\n- **State Variables**: Number density at iteration $n$ is $\\rho^{(n)}(x)$, reference uniform number density is $\\rho_0$.\n- **Physical Law**: Mechanical equilibrium is given by $\\partial_x p(x) + \\rho(x) f_{\\mathrm{th}}(x) = 0$, where $p(x)$ is pressure and $f_{\\mathrm{th}}(x)$ is the thermodynamic force.\n- **Equation of State**: For small density deviations under isothermal conditions, the isothermal compressibility is $\\kappa_T = \\frac{1}{\\rho}\\left(\\frac{\\partial \\rho}{\\partial p}\\right)_T$.\n- **Numerical Scheme**:\n    1.  **Gradient Approximation**: $\\partial_x \\rho(x)$ is approximated using a second-order accurate finite-difference scheme.\n        - Interior points: Centered difference.\n        - Boundary points: One-sided difference.\n    2.  **Iterative Update**: The force is updated using an under-relaxation scheme with mixing parameter $\\alpha \\in (0,1]$: $f_{\\mathrm{th}}^{(n+1)}(x_i)$ is a mix of $f_{\\mathrm{th}}^{(n)}(x_i)$ and a new estimate derived from $\\rho^{(n)}(x)$.\n- **Boundary Conditions (BCs)**: Applied after the update.\n    - **Dirichlet**: $f_{\\mathrm{th}}^{(n+1)} = 0$ at both ends.\n    - **Neumann**: $\\partial_x f_{\\mathrm{th}}^{(n+1)} = 0$ at both ends, implemented by setting the boundary value to the adjacent interior value.\n- **Units**: $\\rho$ in $\\mathrm{m}^{-3}$, $\\Delta x$ in $\\mathrm{m}$, $\\kappa_T$ in $\\mathrm{Pa}^{-1}$, $f_{\\mathrm{th}}$ in $\\mathrm{N}$.\n- **Test Cases**: Four specific test cases are provided with all necessary numerical values and parameters.\n\n#### Validation against Criteria\n- **Scientifically Grounded**: The problem is based on fundamental principles of statistical mechanics and fluid dynamics, specifically the condition of mechanical equilibrium ($\\nabla p = -\\rho \\mathbf{F}_{\\text{body}}$) and the definition of isothermal compressibility. The AdResS method is a standard technique in multiscale materials simulation. The problem is scientifically sound.\n- **Well-Posed**: The problem is well-posed. It provides a clear initial state ($f_{\\mathrm{th}}^{(n)}$, $\\rho^{(n)}$) and a deterministic set of rules to compute the next state ($f_{\\mathrm{th}}^{(n+1)}$). The provided information is sufficient and self-consistent, ensuring a unique solution for each test case exists.\n- **Objective**: The problem is stated in precise, objective language. All terms are defined mathematically or procedurally. There are no subjective or opinion-based statements.\n\n#### Verdict\nThe problem is **valid**. It is a well-defined task in computational physics that requires deriving an algorithm from first principles and implementing it numerically.\n\n### Step 2: Derivation and Algorithmic Design\n\nThe objective is to derive the discrete update rule for the thermodynamic force, $f_{\\mathrm{th}}^{(n+1)}(x_i)$.\n\n#### Principle-Based Derivation\n1.  **Force from Pressure Gradient**: The condition for mechanical equilibrium in one dimension is:\n    $$\n    \\frac{\\partial p(x)}{\\partial x} + \\rho(x) f_{\\mathrm{th}}(x) = 0\n    $$\n    Solving for the thermodynamic force $f_{\\mathrm{th}}(x)$ gives:\n    $$\n    f_{\\mathrm{th}}(x) = -\\frac{1}{\\rho(x)} \\frac{\\partial p(x)}{\\partial x}\n    $$\n    The problem specifies that we consider small deviations of the density $\\rho(x)$ from the reference density $\\rho_0$. It is therefore a consistent approximation to replace $\\rho(x)$ in the denominator with $\\rho_0$:\n    $$\n    f_{\\mathrm{th}}(x) \\approx -\\frac{1}{\\rho_0} \\frac{\\partial p(x)}{\\partial x}\n    $$\n\n2.  **Pressure Gradient from Density Gradient**: The isothermal compressibility $\\kappa_T$ is defined as $\\kappa_T = \\frac{1}{\\rho} \\left(\\frac{\\partial \\rho}{\\partial p}\\right)_T$. We can rearrange this to express the change in pressure with respect to density:\n    $$\n    \\left(\\frac{\\partial p}{\\partial \\rho}\\right)_T = \\frac{1}{\\rho \\kappa_T}\n    $$\n    Using the chain rule, the pressure gradient can be related to the density gradient:\n    $$\n    \\frac{\\partial p(x)}{\\partial x} = \\left(\\frac{\\partial p}{\\partial \\rho}\\right)_T \\frac{\\partial \\rho(x)}{\\partial x}\n    $$\n    For small deviations around the reference state $(\\rho_0, p_0)$, we evaluate the derivative term at $\\rho_0$:\n    $$\n    \\frac{\\partial p(x)}{\\partial x} \\approx \\frac{1}{\\rho_0 \\kappa_T} \\frac{\\partial \\rho(x)}{\\partial x}\n    $$\n\n3.  **Target Force Expression**: By substituting the expression for the pressure gradient into the expression for the force, we obtain the \"target\" thermodynamic force, which we denote as $f_{\\text{target}}(x)$, that would perfectly balance the forces arising from the density profile $\\rho(x)$:\n    $$\n    f_{\\text{target}}(x) = -\\frac{1}{\\rho_0} \\left( \\frac{1}{\\rho_0 \\kappa_T} \\frac{\\partial \\rho(x)}{\\partial x} \\right) = -\\frac{1}{\\rho_0^2 \\kappa_T} \\frac{\\partial \\rho(x)}{\\partial x}\n    $$\n    At iteration $n$, the target force is computed using the measured density profile $\\rho^{(n)}(x)$:\n    $$\n    f_{\\text{target}}^{(n)}(x) = -\\frac{1}{\\rho_0^2 \\kappa_T} \\frac{\\partial \\rho^{(n)}(x)}{\\partial x}\n    $$\n\n4.  **Discretization of the Density Gradient**: The continuous function $\\rho^{(n)}(x)$ is known only at discrete grid points $x_i$, giving values $\\rho_i^{(n)}$. We must approximate the derivative $\\frac{\\partial \\rho^{(n)}(x)}{\\partial x}$ at each grid point $x_i$ using second-order accurate finite-difference formulas. For a grid with $N$ points indexed $i=0, 1, \\dots, N-1$:\n    -   **Interior points ($1 \\le i \\le N-2$)**: The second-order centered difference formula is used:\n        $$\n        \\left(\\frac{\\partial \\rho^{(n)}}{\\partial x}\\right)_i = \\frac{\\rho_{i+1}^{(n)} - \\rho_{i-1}^{(n)}}{2 \\Delta x}\n        $$\n    -   **Left boundary point ($i=0$)**: The second-order forward difference formula is used:\n        $$\n        \\left(\\frac{\\partial \\rho^{(n)}}{\\partial x}\\right)_0 = \\frac{-3\\rho_0^{(n)} + 4\\rho_1^{(n)} - \\rho_2^{(n)}}{2 \\Delta x}\n        $$\n    -   **Right boundary point ($i=N-1$)**: The second-order backward difference formula is used:\n        $$\n        \\left(\\frac{\\partial \\rho^{(n)}}{\\partial x}\\right)_{N-1} = \\frac{3\\rho_{N-1}^{(n)} - 4\\rho_{N-2}^{(n)} + \\rho_{N-3}^{(n)}}{2 \\Delta x}\n        $$\n\n5.  **Under-Relaxation Update Rule**: The force for the next iteration, $f_{\\mathrm{th}}^{(n+1)}$, is obtained by mixing the current force $f_{\\mathrm{th}}^{(n)}$ with the calculated target force $f_{\\text{target}}^{(n)}$ using the relaxation parameter $\\alpha$:\n    $$\n    f_{\\mathrm{th}, i}^{(n+1)} = (1-\\alpha) f_{\\mathrm{th}, i}^{(n)} + \\alpha f_{\\text{target}, i}^{(n)}\n    $$\n    Substituting the expression for the discrete target force, the full update rule for each grid point $i$ is:\n    $$\n    f_{\\mathrm{th}, i}^{(n+1)} = (1-\\alpha) f_{\\mathrm{th}, i}^{(n)} - \\frac{\\alpha}{\\rho_0^2 \\kappa_T} \\left(\\frac{\\partial \\rho^{(n)}}{\\partial x}\\right)_i\n    $$\n    Let's denote the force field computed using this rule as $\\tilde{f}_{\\mathrm{th}}^{(n+1)}$.\n\n6.  **Application of Boundary Conditions**: The final step is to apply the specified boundary conditions to the calculated force field $\\tilde{f}_{\\mathrm{th}}^{(n+1)}$ to obtain the final $f_{\\mathrm{th}}^{(n+1)}$.\n    -   **Dirichlet BC**: The force at the boundaries is set to zero.\n        $$\n        f_{\\mathrm{th}, 0}^{(n+1)} = 0\n        $$\n        $$\n        f_{\\mathrm{th}, N-1}^{(n+1)} = 0\n        $$\n        The interior points remain unchanged: $f_{\\mathrm{th}, i}^{(n+1)} = \\tilde{f}_{\\mathrm{th}, i}^{(n+1)}$ for $1 \\le i \\le N-2$.\n    -   **Neumann BC**: The derivative of the force is set to zero, which is implemented by copying the values from the adjacent interior points.\n        $$\n        f_{\\mathrm{th}, 0}^{(n+1)} = \\tilde{f}_{\\mathrm{th}, 1}^{(n+1)}\n        $$\n        $$\n        f_{\\mathrm{th}, N-1}^{(n+1)} = \\tilde{f}_{\\mathrm{th}, N-2}^{(n+1)}\n        $$\n        The interior points remain unchanged.\n\nThis completes the derivation of the algorithm to be implemented.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the next-iteration thermodynamic force in an AdResS simulation.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"rho_0\": 3.343e28,  # m^-3\n            \"kappa_T\": 4.5e-10,  # Pa^-1\n            \"delta_x\": 5.0e-10,  # m\n            \"rho_n_factors\": [1.00, 1.02, 1.05, 1.02, 1.00],\n            \"alpha\": 0.8,\n            \"bc_type\": \"Dirichlet\",\n            \"f_th_n\": [0.0, 0.0, 0.0, 0.0, 0.0],  # N\n        },\n        {\n            \"rho_0\": 3.343e28,\n            \"kappa_T\": 4.5e-10,\n            \"delta_x\": 5.0e-10,\n            \"rho_n_factors\": [1.00, 1.00, 1.00, 1.00, 1.00],\n            \"alpha\": 1.0,\n            \"bc_type\": \"Dirichlet\",\n            \"f_th_n\": [0.0, 0.0, 0.0, 0.0, 0.0],\n        },\n        {\n            \"rho_0\": 3.343e28,\n            \"kappa_T\": 4.5e-10,\n            \"delta_x\": 5.0e-10,\n            \"rho_n_factors\": [0.95, 0.95, 1.10, 1.10, 1.10],\n            \"alpha\": 0.5,\n            \"bc_type\": \"Neumann\",\n            \"f_th_n\": [0.0, 0.0, 0.0, 0.0, 0.0],\n        },\n        {\n            \"rho_0\": 3.343e28,\n            \"kappa_T\": 4.5e-10,\n            \"delta_x\": 5.0e-10,\n            \"rho_n_factors\": [1.00, 0.98, 1.02, 1.01, 0.99, 1.00],\n            \"alpha\": 0.7,\n            \"bc_type\": \"Neumann\",\n            \"f_th_n\": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        rho_0 = case[\"rho_0\"]\n        kappa_T = case[\"kappa_T\"]\n        delta_x = case[\"delta_x\"]\n        alpha = case[\"alpha\"]\n        bc_type = case[\"bc_type\"]\n\n        rho_n = np.array(case[\"rho_n_factors\"]) * rho_0\n        f_th_n = np.array(case[\"f_th_n\"])\n        \n        N = len(rho_n)\n        grad_rho = np.zeros(N)\n\n        # Calculate second-order accurate finite differences for the density gradient\n        if N >= 3:\n            # Left boundary (i=0): second-order forward difference\n            grad_rho[0] = (-3 * rho_n[0] + 4 * rho_n[1] - rho_n[2]) / (2 * delta_x)\n            \n            # Right boundary (i=N-1): second-order backward difference\n            grad_rho[N-1] = (3 * rho_n[N-1] - 4 * rho_n[N-2] + rho_n[N-3]) / (2 * delta_x)\n\n            # Interior points: second-order centered difference\n            for i in range(1, N - 1):\n                grad_rho[i] = (rho_n[i+1] - rho_n[i-1]) / (2 * delta_x)\n        else:\n            # For N3, second-order stencils are not defined.\n            # Handle as per problem context (not specified, but this would be an invalid grid for the method)\n            # The test cases all have N>=5, so this branch is not taken.\n            pass\n\n        # Calculate the target force based on the density gradient\n        # f_target = - (1 / (rho_0^2 * kappa_T)) * grad_rho\n        prefactor = -1.0 / (rho_0**2 * kappa_T)\n        f_target = prefactor * grad_rho\n\n        # Apply the under-relaxation update rule\n        # f_th_next = (1 - alpha) * f_th_n + alpha * f_target\n        f_th_next = (1.0 - alpha) * f_th_n + alpha * f_target\n\n        # Apply boundary conditions to the updated force field\n        if bc_type == \"Dirichlet\":\n            f_th_next[0] = 0.0\n            f_th_next[N-1] = 0.0\n        elif bc_type == \"Neumann\":\n            if N >= 2:\n                f_th_next[0] = f_th_next[1]\n                f_th_next[N-1] = f_th_next[N-2]\n        \n        results.append(f_th_next.tolist())\n\n    # Format output exactly as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Setting up a multiscale simulation involves making practical choices about simulation parameters that balance computational speed with physical accuracy. The width of the hybrid region, $w$, is a critical parameter; making it wider often reduces artifacts but increases the number of expensive atomistic calculations. This exercise formalizes this trade-off by modeling both simulation error and computational cost as functions of the hybrid width, challenging you to find the optimal parameter based on a defined objective .",
            "id": "3790123",
            "problem": "In adaptive resolution molecular simulation, an Adaptive Resolution Simulation (AdResS) partitions a periodic cubic domain of side length $L$ into three contiguous slabs along a single Cartesian axis: an atomistic core of length $L_{\\mathrm{A}}$, two hybrid transition slabs of width $w$ each, and the remaining outer coarse-grained reservoir. For a homogeneous liquid of number density $\\rho$ in reduced Lennard-Jones units, assume the following scientifically grounded and widely used modeling hypotheses rooted in Newtonian mechanics and equilibrium statistical mechanics:\n\n- Computational cost per time step scales linearly with the number of degrees of freedom. Approximating proportionality with per-particle costs for each region, the total cost is modeled as\n$$\nC(w) = c_{\\mathrm{A}} N_{\\mathrm{A}} + c_{\\mathrm{H}} N_{\\mathrm{H}} + c_{\\mathrm{C}} N_{\\mathrm{C}},\n$$\nwhere $N_{\\mathrm{A}} = \\rho V_{\\mathrm{A}}$, $N_{\\mathrm{H}} = \\rho V_{\\mathrm{H}}$, and $N_{\\mathrm{C}} = \\rho V_{\\mathrm{C}}$ are particle counts determined from volumes $V_{\\mathrm{A}} = L_{\\mathrm{A}} L^2$, $V_{\\mathrm{H}} = 2 w L^2$, and $V_{\\mathrm{C}} = L^3 - V_{\\mathrm{A}} - V_{\\mathrm{H}}$.\n- The structural error in an atomistic observable caused by hybrid interpolation decays with the hybrid width $w$ over a liquid correlation length $\\xi$, consistent with linear response theory. We model this contribution as\n$$\nE_{\\mathrm{g}}(w) = E_0 \\exp\\!\\left(-\\frac{w}{\\xi}\\right).\n$$\n- The finite-reservoir error arising from a limited coarse-grained thickness $L_{\\mathrm{C}}(w) = L - L_{\\mathrm{A}} - 2 w$ decays exponentially with $L_{\\mathrm{C}}$ over a reservoir correlation length $\\lambda$, capturing the screening of perturbations:\n$$\nE_{\\mathrm{fs}}(w) = B \\exp\\!\\left(-\\frac{L_{\\mathrm{C}}(w)}{\\lambda}\\right).\n$$\n- The total accuracy loss is conservatively approximated by the sum\n$$\nE_{\\mathrm{tot}}(w) = E_{\\mathrm{g}}(w) + E_{\\mathrm{fs}}(w).\n$$\n\nYour program must, for each provided test case, evaluate $C(w)$ and $E_{\\mathrm{tot}}(w)$ over a list of candidate widths, then recommend a single optimal width according to the following rule:\n\n- Primary feasibility: select among all $w$ satisfying $E_{\\mathrm{tot}}(w) \\le \\tau$ (given tolerance) the one with minimal $C(w)$. If multiple widths have identical $C(w)$ within an absolute difference of $10^{-12}$, choose the smaller $w$.\n- If no width satisfies $E_{\\mathrm{tot}}(w) \\le \\tau$, select the $w$ that minimizes $E_{\\mathrm{tot}}(w)$. If there is a tie in $E_{\\mathrm{tot}}(w)$ within an absolute difference of $10^{-12}$, choose the one with minimal $C(w)$; if still tied, choose the smaller $w$.\n\nAll quantities are dimensionless reduced units. The output for each test case must be the triple $[w^\\star, C(w^\\star), E_{\\mathrm{tot}}(w^\\star)]$ with each float rounded to $6$ decimal places.\n\nTest suite. For each case below, the candidate widths satisfy $2 w + L_{\\mathrm{A}} \\le L$ so that the reservoir has nonnegative thickness. Your program must compute the optimal triple for each case and print a single line that is a list of these triples, in order, with no extra text.\n\n- Case A (happy path, multiple feasible widths):\n    - $L = 10$, $L_{\\mathrm{A}} = 4$, $\\rho = 0.8$\n    - Costs: $c_{\\mathrm{A}} = 5$, $c_{\\mathrm{H}} = 7$, $c_{\\mathrm{C}} = 1$\n    - Error parameters: $E_0 = 0.12$, $B = 0.08$, $\\xi = 1.0$, $\\lambda = 1.0$\n    - Tolerance: $\\tau = 0.05$\n    - Candidates: $w \\in \\{0.5, 1.0, 1.5, 2.0, 2.5\\}$\n- Case B (tight tolerance, no feasible widths):\n    - $L = 10$, $L_{\\mathrm{A}} = 4$, $\\rho = 0.8$\n    - Costs: $c_{\\mathrm{A}} = 5$, $c_{\\mathrm{H}} = 7$, $c_{\\mathrm{C}} = 1$\n    - Error parameters: $E_0 = 0.12$, $B = 0.08$, $\\xi = 1.0$, $\\lambda = 1.0$\n    - Tolerance: $\\tau = 0.02$\n    - Candidates: $w \\in \\{0.5, 1.0, 1.5, 2.0, 2.5\\}$\n- Case C (smaller box, different liquid and costs):\n    - $L = 8$, $L_{\\mathrm{A}} = 3$, $\\rho = 0.85$\n    - Costs: $c_{\\mathrm{A}} = 6$, $c_{\\mathrm{H}} = 8$, $c_{\\mathrm{C}} = 1$\n    - Error parameters: $E_0 = 0.15$, $B = 0.10$, $\\xi = 0.8$, $\\lambda = 0.8$\n    - Tolerance: $\\tau = 0.04$\n    - Candidates: $w \\in \\{0.5, 1.0, 1.5, 2.0\\}$\n- Case D (larger box, longer-ranged structure, moderate tolerance):\n    - $L = 12$, $L_{\\mathrm{A}} = 4$, $\\rho = 0.75$\n    - Costs: $c_{\\mathrm{A}} = 5$, $c_{\\mathrm{H}} = 7$, $c_{\\mathrm{C}} = 1$\n    - Error parameters: $E_0 = 0.10$, $B = 0.05$, $\\xi = 1.2$, $\\lambda = 1.5$\n    - Tolerance: $\\tau = 0.03$\n    - Candidates: $w \\in \\{0.5, 1.0, 2.0, 3.0, 3.5\\}$\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list of lists, with each inner list the optimal triple for a case in the same order as listed above. For example, a syntactically correct output looks like\n$[[w_1,C_1,E_1],[w_2,C_2,E_2],[w_3,C_3,E_3],[w_4,C_4,E_4]]$\nwith each float rounded to $6$ decimal places and no additional whitespace or text.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the principles of multiscale molecular simulation, specifically the Adaptive Resolution Simulation (AdResS) method. The provided models for computational cost and simulation error are well-established, physically motivated simplifications. The problem is well-posed, with all necessary parameters and a clear, unambiguous optimization objective, including tie-breaking rules, ensuring a unique solution exists for each test case from the provided candidate sets. The language is objective and formal. Therefore, I will proceed with a complete solution.\n\nThe core of the problem is to select an optimal hybrid slab width, $w^\\star$, from a set of discrete candidates. The selection is based on a trade-off between computational cost, $C(w)$, and total numerical error, $E_{\\mathrm{tot}}(w)$.\n\nFirst, we formalize the models for cost and error as functions of the hybrid width $w$. The system is a cubic domain of side length $L$ with number density $\\rho$.\n\nThe computational cost, $C(w)$, is given by:\n$$\nC(w) = c_{\\mathrm{A}} N_{\\mathrm{A}} + c_{\\mathrm{H}} N_{\\mathrm{H}}(w) + c_{\\mathrm{C}} N_{\\mathrm{C}}(w)\n$$\nwhere $c_{\\mathrm{A}}$, $c_{\\mathrm{H}}$, and $c_{\\mathrm{C}}$ are the per-particle computational costs in the atomistic, hybrid, and coarse-grained regions, respectively. The number of particles in each region, $N_i$, is the product of the density $\\rho$ and the region's volume $V_i$. The volumes are:\n- Atomistic volume (constant): $V_{\\mathrm{A}} = L_{\\mathrm{A}} L^2$\n- Hybrid volume (depends on $w$): $V_{\\mathrm{H}}(w) = 2 w L^2$\n- Coarse-grained volume (depends on $w$): $V_{\\mathrm{C}}(w) = L^3 - V_{\\mathrm{A}} - V_{\\mathrm{H}}(w) = (L - L_{\\mathrm{A}} - 2w) L^2$\n\nSubstituting these into the cost function yields an expression linear in $w$:\n$$\nC(w) = c_{\\mathrm{A}} (\\rho L_{\\mathrm{A}} L^2) + c_{\\mathrm{H}} (\\rho 2w L^2) + c_{\\mathrm{C}} (\\rho (L - L_{\\mathrm{A}} - 2w) L^2)\n$$\n$$\nC(w) = \\rho L^2 \\left[ c_{\\mathrm{A}} L_{\\mathrm{A}} + c_{\\mathrm{C}}(L - L_{\\mathrm{A}}) \\right] + 2 \\rho L^2 (c_{\\mathrm{H}} - c_{\\mathrm{C}}) w\n$$\nThis shows that $C(w)$ increases or decreases linearly with $w$, depending on the sign of $(c_{\\mathrm{H}} - c_{\\mathrm{C}})$. Given that a hybrid particle is computationally more expensive than a coarse-grained one ($c_{\\mathrm{H}}  c_{\\mathrm{C}}$), the cost $C(w)$ is a monotonically increasing function of $w$.\n\nThe total error, $E_{\\mathrm{tot}}(w)$, is the sum of two contributions:\n$$\nE_{\\mathrm{tot}}(w) = E_{\\mathrm{g}}(w) + E_{\\mathrm{fs}}(w)\n$$\nThe first term, $E_{\\mathrm{g}}(w)$, represents the error from the atomistic/coarse-grained coupling, which decays exponentially with the width $w$ of the transition region:\n$$\nE_{\\mathrm{g}}(w) = E_0 \\exp\\left(-\\frac{w}{\\xi}\\right)\n$$\nHere, $E_0$ is the error amplitude and $\\xi$ is a characteristic correlation length.\n\nThe second term, $E_{\\mathrm{fs}}(w)$, is a finite-size error due to the limited thickness of the coarse-grained reservoir, $L_{\\mathrm{C}}(w) = L - L_{\\mathrm{A}} - 2w$. This error also decays exponentially with the reservoir thickness:\n$$\nE_{\\mathrm{fs}}(w) = B \\exp\\left(-\\frac{L_{\\mathrm{C}}(w)}{\\lambda}\\right) = B \\exp\\left(-\\frac{L - L_{\\mathrm{A}} - 2w}{\\lambda}\\right)\n$$\nHere, $B$ is the error amplitude and $\\lambda$ is a reservoir correlation length. This term can be rewritten to show its explicit dependence on $w$:\n$$\nE_{\\mathrm{fs}}(w) = \\left( B \\exp\\left(-\\frac{L - L_{\\mathrm{A}}}{\\lambda}\\right) \\right) \\exp\\left(\\frac{2w}{\\lambda}\\right)\n$$\nThis is an exponentially increasing function of $w$. The total error $E_{\\mathrm{tot}}(w)$ is the sum of an exponentially decaying term and an exponentially increasing term, which typically results in a function with a single minimum.\n\nThe optimization procedure follows a two-tiered decision rule:\n\n1.  **Primary Rule (Feasibility-Driven):** Identify the set of \"feasible\" widths, defined as all candidate widths $\\{w_i\\}$ for which the total error does not exceed a given tolerance $\\tau$, i.e., $E_{\\mathrm{tot}}(w_i) \\le \\tau$.\n    - If this feasible set is non-empty, the optimal width $w^\\star$ is the one within this set that minimizes the computational cost $C(w_i)$.\n    - A tie-breaking rule is specified: if multiple feasible widths yield costs that are identical within an absolute difference of $10^{-12}$, the one with the smallest width $w$ is chosen.\n\n2.  **Secondary Rule (Error-Driven):** If no candidate width satisfies the feasibility condition (i.e., the feasible set is empty), the objective shifts to minimizing the error.\n    - The optimal width $w^\\star$ is the one among all candidates that results in the minimum total error $E_{\\mathrm{tot}}(w_i)$.\n    - A multi-level tie-breaking rule applies: if multiple widths yield minimum errors that are identical within an absolute difference of $10^{-12}$, the one with the lower computational cost $C(w)$ is chosen. If the cost is also tied (within $10^{-12}$), the smaller width $w$ is chosen.\n\nThe algorithm to find the optimal triple $[w^\\star, C(w^\\star), E_{\\mathrm{tot}}(w^\\star)]$ is as follows:\nFor each test case:\n1.  For each candidate width $w$ in the provided list, calculate the corresponding cost $C(w)$ and total error $E_{\\mathrm{tot}}(w)$ using the model equations and given parameters. Store these results as a list of data structures, each containing $(w, C, E)$.\n2.  Partition this list into two groups: a `feasible` group where $E \\le \\tau$, and an `infeasible` group.\n3.  If the `feasible` group is not empty:\n    a. Find the minimum cost, $C_{\\min}$, among all candidates in the `feasible` group.\n    b. Select a subset of these candidates for which the cost $C$ satisfies $|C - C_{\\min}| \\le 10^{-12}$.\n    c. From this subset, select the candidate with the minimum width $w$. This is the optimal solution.\n4.  If the `feasible` group is empty:\n    a. Find the minimum error, $E_{\\min}$, among all candidate results (the full original list).\n    b. Select a subset of candidates for which the error $E$ satisfies $|E - E_{\\min}| \\le 10^{-12}$.\n    c. From this error-tied subset, find the minimum cost, $C'_{\\min}$.\n    d. Select a further subset for which the cost $C$ satisfies $|C - C'_{\\min}| \\le 10^{-12}$.\n    e. From this final subset, select the candidate with the minimum width $w$. This is the optimal solution.\n5.  Format the resulting optimal triple $[w^\\star, C(w^\\star), E_{\\mathrm{tot}}(w^\\star)]$ by rounding each floating-point number to $6$ decimal places.\n6.  Collect the formatted triples from all test cases into a final list.\n\nThis procedure is implemented for each of the four test cases provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the adaptive resolution simulation optimization problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"params\": {\n                \"L\": 10.0, \"LA\": 4.0, \"rho\": 0.8,\n                \"cA\": 5.0, \"cH\": 7.0, \"cC\": 1.0,\n                \"E0\": 0.12, \"B\": 0.08, \"xi\": 1.0, \"lambda_\": 1.0,\n                \"tau\": 0.05\n            },\n            \"candidates\": [0.5, 1.0, 1.5, 2.0, 2.5]\n        },\n        {\n            \"name\": \"Case B\",\n            \"params\": {\n                \"L\": 10.0, \"LA\": 4.0, \"rho\": 0.8,\n                \"cA\": 5.0, \"cH\": 7.0, \"cC\": 1.0,\n                \"E0\": 0.12, \"B\": 0.08, \"xi\": 1.0, \"lambda_\": 1.0,\n                \"tau\": 0.02\n            },\n            \"candidates\": [0.5, 1.0, 1.5, 2.0, 2.5]\n        },\n        {\n            \"name\": \"Case C\",\n            \"params\": {\n                \"L\": 8.0, \"LA\": 3.0, \"rho\": 0.85,\n                \"cA\": 6.0, \"cH\": 8.0, \"cC\": 1.0,\n                \"E0\": 0.15, \"B\": 0.10, \"xi\": 0.8, \"lambda_\": 0.8,\n                \"tau\": 0.04\n            },\n            \"candidates\": [0.5, 1.0, 1.5, 2.0]\n        },\n        {\n            \"name\": \"Case D\",\n            \"params\": {\n                \"L\": 12.0, \"LA\": 4.0, \"rho\": 0.75,\n                \"cA\": 5.0, \"cH\": 7.0, \"cC\": 1.0,\n                \"E0\": 0.10, \"B\": 0.05, \"xi\": 1.2, \"lambda_\": 1.5,\n                \"tau\": 0.03\n            },\n            \"candidates\": [0.5, 1.0, 2.0, 3.0, 3.5]\n        }\n    ]\n\n    all_results = []\n    \n    TOL = 1e-12 # Absolute tolerance for float comparisons\n\n    for case in test_cases:\n        params = case['params']\n        candidate_widths = case['candidates']\n        \n        metrics = []\n        for w in candidate_widths:\n            # Calculate cost\n            cost_const_term = params['rho'] * params['L']**2 * (params['cA'] * params['LA'] + params['cC'] * (params['L'] - params['LA']))\n            cost_w_term = 2 * params['rho'] * params['L']**2 * (params['cH'] - params['cC']) * w\n            cost = cost_const_term + cost_w_term\n\n            # Calculate error\n            LC = params['L'] - params['LA'] - 2 * w\n            Eg = params['E0'] * np.exp(-w / params['xi'])\n            Efs = params['B'] * np.exp(-LC / params['lambda_'])\n            error = Eg + Efs\n            \n            metrics.append({'w': w, 'cost': cost, 'error': error})\n\n        # Apply selection logic\n        feasible = [m for m in metrics if m['error'] = params['tau']]\n\n        if feasible:\n            # Primary Rule: Minimize cost from feasible set\n            min_cost = min(m['cost'] for m in feasible)\n            tied_cost_candidates = [m for m in feasible if abs(m['cost'] - min_cost) = TOL]\n            best_candidate = min(tied_cost_candidates, key=lambda m: m['w'])\n        else:\n            # Secondary Rule: Minimize error from all candidates\n            min_error = min(m['error'] for m in metrics)\n            tied_error_candidates = [m for m in metrics if abs(m['error'] - min_error) = TOL]\n            \n            min_cost_in_tie = min(m['cost'] for m in tied_error_candidates)\n            tied_cost_candidates = [m for m in tied_error_candidates if abs(m['cost'] - min_cost_in_tie) = TOL]\n\n            best_candidate = min(tied_cost_candidates, key=lambda m: m['w'])\n            \n        w_star = best_candidate['w']\n        c_star = best_candidate['cost']\n        e_star = best_candidate['error']\n        \n        # Format result triple with 6 decimal places\n        w_str = f\"{round(w_star, 6):.6f}\"\n        c_str = f\"{round(c_star, 6):.6f}\"\n        e_str = f\"{round(e_star, 6):.6f}\"\n        \n        all_results.append(f\"[{w_str},{c_str},{e_str}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}