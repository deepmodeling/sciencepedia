{
    "hands_on_practices": [
        {
            "introduction": "Markov State Models (MSMs) provide a powerful framework for analyzing complex dynamics by partitioning the state space into a finite set of discrete states. Within this context, the committor is no longer a continuous function but a vector of probabilities, one for each state. This exercise  challenges you to derive the fundamental linear system for the discrete committor from first principles, a cornerstone for applying Transition Path Theory to data-driven models.",
            "id": "3796686",
            "problem": "Consider a coarse-grained dynamical system modeled as a discrete-time Markov State Model (MSM), defined by a finite set of states $\\{0,1,\\dots,N-1\\}$ and a row-stochastic transition probability matrix $P \\in \\mathbb{R}^{N \\times N}$ with entries $P_{ij} \\ge 0$ and $\\sum_{j=0}^{N-1} P_{ij} = 1$ for each state $i$. In Transition Path Theory (TPT), the forward committor function $q$ assigns to each state $i$ the probability $q_i \\in [0,1]$ that trajectories starting from $i$ will reach a designated product set $B$ before first reaching a designated reactant set $A$, where $A$ and $B$ are disjoint subsets of $\\{0,1,\\dots,N-1\\}$.\n\nStarting from first principles for discrete-time Markov processes and the definition of the forward committor $q_i = \\mathbb{P}(\\tau_B  \\tau_A \\mid X_0 = i)$, with boundary conditions $q_i = 0$ for $i \\in A$ and $q_i = 1$ for $i \\in B$, derive the necessary linear system that determines the interior values $q_i$ for $i \\notin A \\cup B$ using only the Markov property and the law of total probability. Based on this derivation, write a program that computes the discrete committor vector $q$ for each of the following test cases.\n\nYou must express all final numerical outputs as floating-point numbers rounded to six decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in which each element corresponds to one test case and is itself a list containing the full committor vector $q$ for that test case in state index order (e.g., $[ [q_0^{(1)}, q_1^{(1)}, \\dots], [q_0^{(2)}, \\dots], \\dots ]$), with no spaces anywhere in the line.\n\nTest Suite:\n\n$1.$ Three-state system with one interior state:\n$$\nP^{(1)} =\n\\begin{pmatrix}\n1.0  0.0  0.0 \\\\\n0.3  0.4  0.3 \\\\\n0.0  0.0  1.0\n\\end{pmatrix},\n\\quad\nA^{(1)} = \\{0\\},\n\\quad\nB^{(1)} = \\{2\\}.\n$$\n\n$2.$ Five-state system with two interior states:\n$$\nP^{(2)} =\n\\begin{pmatrix}\n1.0  0.0  0.0  0.0  0.0 \\\\\n1.0  0.0  0.0  0.0  0.0 \\\\\n0.4  0.1  0.3  0.2  0.0 \\\\\n0.1  0.2  0.2  0.3  0.2 \\\\\n0.0  0.0  0.0  0.0  1.0\n\\end{pmatrix},\n\\quad\nA^{(2)} = \\{0,1\\},\n\\quad\nB^{(2)} = \\{4\\}.\n$$\n\n$3.$ Four-state system where the interior has no direct pathways to $B$:\n$$\nP^{(3)} =\n\\begin{pmatrix}\n1.0  0.0  0.0  0.0 \\\\\n0.6  0.4  0.0  0.0 \\\\\n0.5  0.5  0.0  0.0 \\\\\n0.0  0.0  0.0  1.0\n\\end{pmatrix},\n\\quad\nA^{(3)} = \\{0\\},\n\\quad\nB^{(3)} = \\{3\\}.\n$$\n\nRequirements:\n\n$1.$ Use only the definition of the committor for discrete-time Markov chains, the Markov property, and the law of total probability as the fundamental base to derive the governing linear equations.\n\n$2.$ Implement a robust numerical procedure that, given $P$, $A$, and $B$, constructs and solves the linear system for the interior states and assembles the full committor vector $q$ obeying the boundary conditions, ensuring $q_i \\in [0,1]$.\n\n$3.$ For each test case, output the full committor vector $q$ as floating-point numbers rounded to six decimal places, in increasing state index order.\n\n$4.$ Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case result printed as a list of six-decimal floats and no spaces, for example $[[0.000000,0.500000,1.000000],[\\dots],[\\dots]]$.\n\nAll answers are dimensionless probabilities; no physical units are required.",
            "solution": "The objective is to derive the linear system governing the forward committor function $q$ for a discrete-time Markov State Model and then to implement a program to solve it for several test cases.\n\nLet the system be defined by a set of states $\\{0, 1, \\dots, N-1\\}$ and a row-stochastic transition probability matrix $P \\in \\mathbb{R}^{N \\times N}$. We are given a reactant set $A$ and a product set $B$, which are disjoint subsets of the state space. The forward committor, $q_i$, is defined as the probability that a trajectory starting in state $i$ reaches the set $B$ before reaching the set $A$. Formally, $q_i = \\mathbb{P}(\\tau_B  \\tau_A \\mid X_0 = i)$, where $\\tau_S = \\min\\{n \\ge 0 \\mid X_n \\in S\\}$ is the first hitting time of a set $S$.\n\nBy this definition, the committor values for states within the sets $A$ and $B$ are fixed by boundary conditions. If a trajectory starts in $A$, it has reached $A$ at time $0$, so $\\tau_A = 0$. Since $A$ and $B$ are disjoint, it cannot have reached $B$ first, thus $\\tau_B > 0$. Therefore, for any state $i \\in A$, $\\tau_A \\le \\tau_B$, and the condition $\\tau_B  \\tau_A$ is false. The probability is zero:\n$$ q_i = 0 \\quad \\text{for all } i \\in A $$\nConversely, if a trajectory starts in $B$, it has reached $B$ at time $0$, so $\\tau_B = 0$. Since it has not yet visited $A$, $\\tau_A > 0$ (or $\\tau_A=0$ only if $A \\cap B \\neq \\emptyset$, which is ruled out). Thus, $\\tau_B  \\tau_A$ is true, and the probability is one:\n$$ q_i = 1 \\quad \\text{for all } i \\in B $$\n\nOur task is to determine the values of $q_i$ for all other states, which we call the interior states. Let the set of interior states be $I = \\{0, 1, \\dots, N-1\\} \\setminus (A \\cup B)$.\n\nFor any interior state $i \\in I$, we can find an equation for $q_i$ using a first-step analysis, which relies on the law of total probability and the Markov property. We condition the event $\\tau_B  \\tau_A$ on the outcome of the first step of the process, $X_1$.\nThe law of total probability gives:\n$$ q_i = \\mathbb{P}(\\tau_B  \\tau_A \\mid X_0 = i) = \\sum_{j=0}^{N-1} \\mathbb{P}(\\tau_B  \\tau_A \\mid X_1 = j, X_0 = i) \\cdot \\mathbb{P}(X_1 = j \\mid X_0 = i) $$\n\nThe term $\\mathbb{P}(X_1 = j \\mid X_0 = i)$ is simply the transition probability from state $i$ to state $j$, which is given by the matrix element $P_{ij}$.\n\nThe term $\\mathbb{P}(\\tau_B  \\tau_A \\mid X_1 = j, X_0 = i)$ is the probability of the event, given that the process is in state $j$ at time $1$. Due to the Markov property, the future evolution of the process depends only on its current state ($X_1=j$), not on its past states (like $X_0=i$). Therefore:\n$$ \\mathbb{P}(\\tau_B  \\tau_A \\mid X_1 = j, X_0 = i) = \\mathbb{P}(\\tau_B'  \\tau_A' \\mid X'_0 = j) $$\nwhere the primes denote a process starting anew from time $0$. This is precisely the definition of the committor for state $j$, $q_j$.\n\nSubstituting these components back into the equation, we get the fundamental relationship for any interior state $i \\in I$:\n$$ q_i = \\sum_{j=0}^{N-1} P_{ij} q_j $$\nThis shows that the committor function is a harmonic function with respect to the transition operator $P$ on the set of interior states.\n\nTo turn this into a solvable linear system, we separate the sum over all states $j$ into three parts, based on whether $j$ is in $A$, $B$, or $I$:\n$$ q_i = \\sum_{j \\in A} P_{ij} q_j + \\sum_{j \\in B} P_{ij} q_j + \\sum_{j \\in I} P_{ij} q_j $$\n\nNow, we substitute the known boundary values for $q_j$:\n$$ q_i = \\sum_{j \\in A} P_{ij} (0) + \\sum_{j \\in B} P_{ij} (1) + \\sum_{j \\in I} P_{ij} q_j $$\nThis simplifies to:\n$$ q_i = \\sum_{j \\in B} P_{ij} + \\sum_{j \\in I} P_{ij} q_j $$\n\nWe can rearrange this equation to group all the unknown variables, which are the $q_k$ for $k \\in I$, on the left-hand side:\n$$ q_i - \\sum_{j \\in I} P_{ij} q_j = \\sum_{j \\in B} P_{ij} $$\n\nThis is a linear equation for each $i \\in I$. We have a system of $|I|$ linear equations in $|I|$ unknowns. Let's write this system in matrix form. Let $q_I$ be the column vector of unknown committor values for states in $I$. Let the states in $I$ be indexed from $1$ to $m=|I|$. The equation for the $k$-th state in $I$, $i_k$, is:\n$$ q_{i_k} - \\sum_{l=1}^{m} P_{i_k, i_l} q_{i_l} = \\sum_{j \\in B} P_{i_k, j} $$\nThis can be expressed as:\n$$ \\sum_{l=1}^{m} (\\delta_{kl} - P_{i_k, i_l}) q_{i_l} = \\sum_{j \\in B} P_{i_k, j} $$\nwhere $\\delta_{kl}$ is the Kronecker delta.\n\nLet $L$ be an $m \\times m$ matrix with elements $L_{kl} = \\delta_{kl} - P_{i_k, i_l}$. This matrix can be written as $L = I_m - P_{II}$, where $I_m$ is the $m \\times m$ identity matrix and $P_{II}$ is the submatrix of $P$ corresponding to transitions *between* the interior states.\nLet $b$ be a column vector of size $m$, where the $k$-th element is $b_k = \\sum_{j \\in B} P_{i_k, j}$. This vector represents the total probability of transitioning from each interior state directly to the product set $B$ in one step.\n\nThe linear system to be solved for the interior committor values $q_I$ is:\n$$ (I_m - P_{II}) q_I = b $$\nThe solution is given by $q_I = (I_m - P_{II})^{-1} b$, provided the matrix $(I_m - P_{II})$ is invertible. Invertibility is guaranteed if every interior state has a non-zero probability of eventually reaching either $A$ or $B$.\n\nThe overall algorithm is:\n1. Identify the interior states $I$.\n2. Construct the submatrix $P_{II}$ of $P$ for transitions between states in $I$.\n3. Construct the matrix $L = I_m - P_{II}$.\n4. Construct the right-hand side vector $b$, where each element $b_k$ is the sum of probabilities of transitioning from the interior state $i_k$ to any state in $B$.\n5. Solve the linear system $L q_I = b$ to find the committor values for the interior states.\n6. Assemble the full committor vector $q$ of size $N$ by combining the computed values $q_I$ with the boundary conditions $q_A=0$ and $q_B=1$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_committor(P, A, B):\n    \"\"\"\n    Computes the forward committor vector for a discrete-time Markov State Model.\n\n    Args:\n        P (np.ndarray): The transition probability matrix.\n        A (set): The set of reactant state indices.\n        B (set): The set of product state indices.\n\n    Returns:\n        np.ndarray: The full committor vector q.\n    \"\"\"\n    num_states = P.shape[0]\n    all_states = set(range(num_states))\n    \n    # Identify interior states\n    interior_states = sorted(list(all_states - A - B))\n    num_interior = len(interior_states)\n    \n    # Initialize the full committor vector\n    q = np.zeros(num_states, dtype=float)\n    \n    # Apply boundary conditions\n    for state in A:\n        q[state] = 0.0\n    for state in B:\n        q[state] = 1.0\n        \n    if num_interior > 0:\n        # Construct the linear system L*q_I = b\n        # L = I - P_II\n        P_II = P[np.ix_(interior_states, interior_states)]\n        L = np.identity(num_interior) - P_II\n        \n        # Construct the right-hand side vector b\n        b = np.zeros(num_interior)\n        b = P[np.ix_(interior_states, list(B))].sum(axis=1)\n\n        # Solve for the interior committor values\n        try:\n            q_I = np.linalg.solve(L, b)\n        except np.linalg.LinAlgError:\n            # This case happens if L is singular, e.g., if there are trapping\n            # interior states that can't reach A or B.\n            # In such a scenario, more advanced methods might be needed,\n            # but for the given problems, linalg.solve is sufficient.\n            # Here we can return NaNs or raise an error.\n            # For this problem, let's assume the system is solvable.\n            raise\n            \n        # Place the solved interior values into the full committor vector\n        for i, val in enumerate(q_I):\n            q[interior_states[i]] = val\n            \n    # Ensure all probabilities are in [0, 1] by clamping.\n    # This can handle potential small numerical precision errors.\n    np.clip(q, 0.0, 1.0, out=q)\n    \n    return q\n\ndef solve():\n    \"\"\"\n    Defines and solves the test cases for committor calculation.\n    \"\"\"\n    test_cases = [\n        (\n            np.array([\n                [1.0, 0.0, 0.0],\n                [0.3, 0.4, 0.3],\n                [0.0, 0.0, 1.0]\n            ]),\n            {0},\n            {2}\n        ),\n        (\n            np.array([\n                [1.0, 0.0, 0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0, 0.0, 0.0],\n                [0.4, 0.1, 0.3, 0.2, 0.0],\n                [0.1, 0.2, 0.2, 0.3, 0.2],\n                [0.0, 0.0, 0.0, 0.0, 1.0]\n            ]),\n            {0, 1},\n            {4}\n        ),\n        (\n            np.array([\n                [1.0, 0.0, 0.0, 0.0],\n                [0.6, 0.4, 0.0, 0.0],\n                [0.5, 0.5, 0.0, 0.0],\n                [0.0, 0.0, 0.0, 1.0]\n            ]),\n            {0},\n            {3}\n        )\n    ]\n\n    results = []\n    for P, A, B in test_cases:\n        q_vector = compute_committor(P, A, B)\n        # Format each number to six decimal places\n        formatted_q = [f\"{x:.6f}\" for x in q_vector]\n        results.append(f\"[{','.join(formatted_q)}]\")\n\n    # Print the final result in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While discrete models are powerful, many systems are naturally described by continuous dynamics governed by stochastic differential equations. In this setting, the committor is the solution to an elliptic partial differential equation known as the backward Kolmogorov equation. This practice  provides essential hands-on experience in building a numerical solver from the ground up using the finite-difference method, a workhorse technique for tackling such boundary-value problems in computational science.",
            "id": "3796690",
            "problem": "Consider overdamped Brownian dynamics of a material degree of freedom modeled as a stochastic differential equation (SDE) in a bounded domain, with a drift arising from a potential and a constant diffusion coefficient. The committor function, defined as the probability that a trajectory starting at a given point first reaches a specified product set before hitting a reactant set, is a central object for identifying reaction coordinates in multiscale materials simulation. Starting from the definition of the committor function and the generator of the SDE, derive the governing stationary boundary-value problem (the backward Kolmogorov formulation) and then construct a second-order finite-difference discretization that enforces Dirichlet boundary conditions on the reactant and product sets and reflective (Neumann) conditions where applicable.\n\nYour program must numerically solve the committor boundary-value problem on the following test suite of cases using a finite-difference method with scientifically reasonable grid resolutions. All quantities are dimensionless, and all outputs must be reported as floats rounded to six decimal places. The final output must be a single line containing the results as a comma-separated list enclosed in square brackets, in the order and format specified below.\n\nFundamental base to use for derivation:\n- Overdamped Langevin dynamics SDE and its generator for smooth potentials and constant diffusion.\n- The definition of the committor as a first-hitting probability between two disjoint boundary sets.\n- The correspondence between first-hitting probabilities and stationary solutions of the backward Kolmogorov equation with appropriate boundary conditions (Dirichlet on hitting sets and Neumann on reflecting boundaries).\n\nTask details:\n1. One-dimensional double-well drift case:\n   - Domain: $x \\in [-1,1]$.\n   - Potential: $U(x) = \\frac{x^{4}}{4} - \\frac{x^{2}}{2}$.\n   - Drift: $b(x) = -\\frac{dU}{dx} = -(x^{3} - x)$.\n   - Diffusion coefficient: $D = 0.05$.\n   - Boundary sets: reactant set $A$ is the left endpoint $x=-1$ and product set $B$ is the right endpoint $x=1$.\n   - Boundary conditions: $q(-1)=0$ and $q(1)=1$.\n   - Grid: use $N=1001$ uniformly spaced points over $[-1,1]$.\n   - Quantity to report: the committor $q(x)$ evaluated at $x=0$.\n\n2. One-dimensional driftless case (harmonic committor along an interval):\n   - Domain: $x \\in [0,1]$.\n   - Drift: $b(x) = 0$.\n   - Diffusion coefficient: $D = 0.1$.\n   - Boundary sets: $A$ is $x=0$ and $B$ is $x=1$.\n   - Boundary conditions: $q(0)=0$ and $q(1)=1$.\n   - Grid: use $N=501$ uniformly spaced points over $[0,1]$.\n   - Quantity to report: the committor $q(x)$ evaluated at $x=0.3$.\n\n3. Two-dimensional driftless rectangle with mixed boundary conditions:\n   - Domain: $(x,y) \\in [-1,1] \\times [0,1]$.\n   - Drift: $\\mathbf{b}(x,y) = (0,0)$.\n   - Diffusion coefficient: $D = 1.0$.\n   - Boundary sets and conditions: Dirichlet $q=0$ on the left boundary $x=-1$ (reactant) and Dirichlet $q=1$ on the right boundary $x=1$ (product). Reflective (Neumann) boundary conditions on the top and bottom boundaries $y=1$ and $y=0$, enforcing zero normal derivative $\\partial q / \\partial y = 0$ there.\n   - Grid: use $N_{x}=81$ uniformly spaced points over $[-1,1]$ and $N_{y}=61$ uniformly spaced points over $[0,1]$.\n   - Quantity to report: the committor $q(x,y)$ evaluated at $(x,y)=(0.2,0.7)$.\n\nAlgorithmic requirements:\n- Derive the stationary backward Kolmogorov equation associated with the SDE generator inside the domain and enforce $q=0$ on the reactant set and $q=1$ on the product set. Use reflective boundary conditions where specified.\n- Discretize using second-order central finite differences for spatial derivatives. For Neumann boundaries, use a ghost-point reflection to impose zero normal derivative.\n- Assemble and solve the resulting linear system using a robust sparse linear solver.\n- Evaluate the committor at the specified query points using appropriate interpolation on the computed grid (linear interpolation in one dimension and bilinear interpolation in two dimensions).\n\nTest suite and output specification:\n- Compute the three scalar quantities listed above in the order of the cases. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, rounded to six decimal places (for example, \"[0.500000,0.300000,0.600000]\").\n\nNo external input is allowed. All computations must be self-contained and reproducible given the specifications above. The final answers must be in dimensionless units and reported as floats rounded to six decimal places.",
            "solution": "The user has provided a problem that is scientifically grounded, well-posed, and objective. It is a standard, albeit non-trivial, numerical problem in computational physics and chemistry, suitable for testing knowledge of the mathematical foundations of reaction coordinates and the numerical methods for solving elliptic partial differential equations. The problem is valid.\n\nThe central task is to solve for the committor function $q(\\mathbf{x})$, which is fundamental to the analysis of rare events and the identification of optimal reaction coordinates in complex systems. The committor $q(\\mathbf{x})$ is defined as the probability that a trajectory of a stochastic process, starting at state $\\mathbf{x}$, will first reach a predefined product state set $B$ before reaching a reactant state set $A$.\n\nThe dynamics of the system are described by an overdamped Langevin stochastic differential equation (SDE) for the state vector $\\mathbf{X}_t$:\n$$\nd\\mathbf{X}_t = \\mathbf{b}(\\mathbf{X}_t) dt + \\sqrt{2D} d\\mathbf{W}_t\n$$\nHere, $\\mathbf{b}(\\mathbf{x})$ is the drift term, which in our case is derived from a potential $U(\\mathbf{x})$ as $\\mathbf{b}(\\mathbf{x}) = -\\nabla U(\\mathbf{x})$. $D$ is a constant, scalar diffusion coefficient, and $\\mathbf{W}_t$ represents a vector of independent Wiener processes.\n\nThe generator of this SDE, denoted by $\\mathcal{L}$, acts on a suitably smooth function $f(\\mathbf{x})$ and is given by:\n$$\n\\mathcal{L}f(\\mathbf{x}) = \\mathbf{b}(\\mathbf{x}) \\cdot \\nabla f(\\mathbf{x}) + D \\nabla^2 f(\\mathbf{x})\n$$\nA fundamental theorem of stochastic processes states that the committor function $q(\\mathbf{x})$ is the solution to the stationary backward Kolmogorov equation, $\\mathcal{L}q = 0$, within the domain $\\Omega$ that lies between the sets $A$ and $B$. The equation is:\n$$\n\\mathbf{b}(\\mathbf{x}) \\cdot \\nabla q(\\mathbf{x}) + D \\nabla^2 q(\\mathbf{x}) = 0 \\quad \\text{for } \\mathbf{x} \\in \\Omega\n$$\nThis is an elliptic partial differential equation (PDE). To obtain a unique solution, we must specify boundary conditions. By its definition, the committor must satisfy:\n- $q(\\mathbf{x}) = 0$ for all $\\mathbf{x} \\in A$ (Dirichlet boundary condition on the reactant set).\n- $q(\\mathbf{x}) = 1$ for all $\\mathbf{x} \\in B$ (Dirichlet boundary condition on the product set).\n- On any other boundaries of the domain that are reflecting (i.e., trajectories do not exit through them), we impose a no-flux condition, which for the backward Kolmogorov equation translates to a zero-normal-derivative (homogeneous Neumann) boundary condition: $\\mathbf{n} \\cdot \\nabla q(\\mathbf{x}) = 0$, where $\\mathbf{n}$ is the unit normal vector to the boundary.\n\nWe will solve this boundary value problem for the three specified cases using a second-order finite-difference method. This method involves discretizing the domain on a grid, approximating the derivatives at each grid point, and solving the resulting system of linear algebraic equations.\n\n**Case 1: One-dimensional double-well drift case**\n- Domain: $x \\in [-1,1]$.\n- PDE: $b(x) \\frac{dq}{dx} + D \\frac{d^2q}{dx^2} = 0$, with $b(x) = x - x^3$ and $D = 0.05$.\n- Boundary Conditions (BCs): $q(-1) = 0$, $q(1) = 1$.\nWe discretize the domain into $N=1001$ points $x_i = -1 + i\\Delta x$ for $i \\in \\{0, 1, \\dots, N-1\\}$, with spacing $\\Delta x = 2 / (N-1)$. For each interior point $x_i$ ($i \\in \\{1, \\dots, N-2\\}$), we approximate the derivatives using second-order central differences:\n$$\n\\frac{dq}{dx}\\bigg|_{x_i} \\approx \\frac{q_{i+1} - q_{i-1}}{2\\Delta x}, \\quad \\frac{d^2q}{dx^2}\\bigg|_{x_i} \\approx \\frac{q_{i+1} - 2q_i + q_{i-1}}{(\\Delta x)^2}\n$$\nSubstituting these into the PDE and rearranging gives a linear equation for each $q_i$:\n$$\n\\left(\\frac{D}{(\\Delta x)^2} - \\frac{b(x_i)}{2\\Delta x}\\right) q_{i-1} - \\left(\\frac{2D}{(\\Delta x)^2}\\right) q_i + \\left(\\frac{D}{(\\Delta x)^2} + \\frac{b(x_i)}{2\\Delta x}\\right) q_{i+1} = 0\n$$\nThis forms a tridiagonal system of $N-2$ linear equations for the unknown interior values $\\{q_1, \\dots, q_{N-2}\\}$. The known boundary values $q_0=0$ and $q_{N-1}=1$ are incorporated into the equations for $q_1$ and $q_{N-2}$, respectively. The term involving $q_0$ is zero, and the term involving $q_{N-1}$ is moved to the right-hand side of the equation for $q_{N-2}$. Notably, due to the symmetry of the potential $U(x)$, the domain, and the boundary conditions, the analytical solution is $q(x) = (\\int_{-1}^{x} e^{U(s)/D} ds) / (\\int_{-1}^{1} e^{U(s)/D} ds)$, which evaluates to $q(0)=0.5$. Our numerical result should closely match this value.\n\n**Case 2: One-dimensional driftless case**\n- Domain: $x \\in [0,1]$.\n- PDE: $D \\frac{d^2q}{dx^2} = 0$, since $b(x)=0$. With $D=0.1$, this simplifies to $\\frac{d^2q}{dx^2} = 0$.\n- BCs: $q(0)=0$, $q(1)=1$.\nThe analytical solution is trivially $q(x) = x$, so we expect $q(0.3) = 0.3$. We will nonetheless solve it numerically on a grid of $N=501$ points. The discretization is identical to Case 1, but with $b(x_i) = 0$. The linear equation for each interior point $q_i$ is:\n$$\n\\frac{D}{(\\Delta x)^2} q_{i-1} - \\frac{2D}{(\\Delta x)^2} q_i + \\frac{D}{(\\Delta x)^2} q_{i+1} = 0 \\quad \\implies \\quad q_{i-1} - 2q_i + q_{i+1} = 0\n$$\nThis is the standard finite-difference approximation of a zero second derivative. We solve the resulting tridiagonal system.\n\n**Case 3: Two-dimensional driftless rectangle**\n- Domain: $(x,y) \\in [-1,1] \\times [0,1]$.\n- PDE: $D(\\frac{\\partial^2 q}{\\partial x^2} + \\frac{\\partial^2 q}{\\partial y^2}) = 0$, which is Laplace's equation, as $\\mathbf{b}(x,y)=(0,0)$.\n- BCs: $q(-1,y)=0$ (Dirichlet), $q(1,y)=1$ (Dirichlet), $\\frac{\\partial q}{\\partial y}(x,0)=0$ (Neumann), $\\frac{\\partial q}{\\partial y}(x,1)=0$ (Neumann).\nWe use a grid of $N_x=81$ by $N_y=61$ points. The unknowns are the committor values $q_{i,j}$ at grid points $(x_i, y_j)$ that are not on the Dirichlet boundaries. This includes the points on the Neumann boundaries. The unknowns are thus $q_{i,j}$ for $i \\in \\{1, \\dots, N_x-2\\}$ and $j \\in \\{0, \\dots, N_y-1\\}$.\nFor an interior point $(x_i, y_j)$ (where $j \\in \\{1, \\dots, N_y-2\\}$), the discretized Laplace equation is the classic five-point stencil:\n$$\n\\frac{q_{i+1,j} - 2q_{i,j} + q_{i-1,j}}{(\\Delta x)^2} + \\frac{q_{i,j+1} - 2q_{i,j} + q_{i,j-1}}{(\\Delta y)^2} = 0\n$$\nFor the Neumann boundaries, we use a ghost-point method. For the bottom boundary $j=0$, the condition $\\frac{\\partial q}{\\partial y}|_{j=0}=0$ is approximated by $\\frac{q_{i,1} - q_{i,-1}}{2\\Delta y} = 0$, implying the ghost value $q_{i,-1} = q_{i,1}$. Substituting this into the five-point stencil at $j=0$ yields:\n$$\n\\frac{q_{i+1,0} - 2q_{i,0} + q_{i-1,0}}{(\\Delta x)^2} + \\frac{2q_{i,1} - 2q_{i,0}}{(\\Delta y)^2} = 0\n$$\nA similar equation is derived for the top boundary $j=N_y-1$. All these equations are assembled into a large, sparse linear system $M\\mathbf{q} = \\mathbf{r}$, where $\\mathbf{q}$ is a flattened vector of the unknown grid values. Because of the Neumann conditions in $y$, the analytical solution has no $y$-dependence and is $q(x,y) = (x+1)/2$. Thus, we expect $q(0.2, 0.7) = (0.2+1)/2 = 0.6$.\n\n**Solution Strategy**\nFor each case, we will construct the sparse matrix and right-hand side vector for the linear system. We will use a sparse linear algebra solver from the `scipy` library, which is efficient for such problems. After obtaining the solution on the grid, we will use interpolation (linear for 1D, bilinear for 2D) to find the committor value at the specified query point.",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve_case_1():\n    \"\"\"\n    Solves the 1D double-well committor problem.\n    PDE: b(x)q'(x) + Dq''(x) = 0\n    Domain: x in [-1, 1]\n    BCs: q(-1) = 0, q(1) = 1\n    \"\"\"\n    N = 1001\n    D = 0.05\n    x_domain = [-1.0, 1.0]\n\n    x_grid = np.linspace(x_domain[0], x_domain[1], N)\n    dx = (x_domain[1] - x_domain[0]) / (N - 1)\n\n    # Interior points are indexed 1 to N-2\n    num_unknowns = N - 2\n    \n    # Use LIL matrix for efficient construction\n    A = lil_matrix((num_unknowns, num_unknowns))\n    b_vec = np.zeros(num_unknowns)\n\n    # Drift function b(x) = -dU/dx = -(x^3 - x) = x - x^3\n    def drift(x):\n        return x - x**3\n\n    # Populate matrix A and vector b\n    for i in range(1, N - 1):\n        idx = i - 1  # Matrix index for grid point i\n        xi = x_grid[i]\n        b_x = drift(xi)\n\n        # Coefficients from central difference scheme\n        c_minus = D / (dx**2) - b_x / (2 * dx)\n        c_zero = -2 * D / (dx**2)\n        c_plus = D / (dx**2) + b_x / (2 * dx)\n        \n        A[idx, idx] = c_zero\n        if i > 1:\n            A[idx, idx - 1] = c_minus\n        if i  N - 2:\n            A[idx, idx + 1] = c_plus\n\n        # Apply boundary conditions\n        if i == 1:\n            # q_0 = 0, so c_minus * q_0 term is zero\n            pass\n        if i == N - 2:\n            # q_{N-1} = 1\n            b_vec[idx] = -c_plus * 1.0\n    \n    # Convert to CSC format for fast solving\n    A_csc = A.tocsc()\n    \n    # Solve the linear system\n    q_interior = spsolve(A_csc, b_vec)\n    \n    # Reconstruct full solution\n    q_sol = np.zeros(N)\n    q_sol[0] = 0.0\n    q_sol[N-1] = 1.0\n    q_sol[1:-1] = q_interior\n    \n    # Interpolate to find q(0)\n    query_x = 0.0\n    result = np.interp(query_x, x_grid, q_sol)\n    \n    return result\n\ndef solve_case_2():\n    \"\"\"\n    Solves the 1D driftless committor problem.\n    PDE: Dq''(x) = 0\n    Domain: x in [0, 1]\n    BCs: q(0) = 0, q(1) = 1\n    \"\"\"\n    N = 501\n    D = 0.1\n    x_domain = [0.0, 1.0]\n\n    x_grid = np.linspace(x_domain[0], x_domain[1], N)\n    dx = (x_domain[1] - x_domain[0]) / (N - 1)\n\n    num_unknowns = N - 2\n    A = lil_matrix((num_unknowns, num_unknowns))\n    b_vec = np.zeros(num_unknowns)\n\n    # Drift is zero for this case\n    b_x = 0.0\n    c_minus = D / (dx**2) - b_x / (2 * dx)\n    c_zero = -2 * D / (dx**2)\n    c_plus = D / (dx**2) + b_x / (2 * dx)\n    \n    for i in range(1, N - 1):\n        idx = i - 1\n        A[idx, idx] = c_zero\n        if i > 1:\n            A[idx, idx - 1] = c_minus\n        if i  N - 2:\n            A[idx, idx + 1] = c_plus\n            \n        if i == N - 2:\n            b_vec[idx] = -c_plus * 1.0\n\n    A_csc = A.tocsc()\n    q_interior = spsolve(A_csc, b_vec)\n    \n    q_sol = np.zeros(N)\n    q_sol[0] = 0.0\n    q_sol[N-1] = 1.0\n    q_sol[1:-1] = q_interior\n    \n    query_x = 0.3\n    result = np.interp(query_x, x_grid, q_sol)\n    \n    return result\n\ndef solve_case_3():\n    \"\"\"\n    Solves the 2D driftless committor problem with mixed BCs.\n    PDE: D * (d^2q/dx^2 + d^2q/dy^2) = 0\n    Domain: (x,y) in [-1,1] x [0,1]\n    BCs: q(-1,y)=0, q(1,y)=1, dq/dy(x,0)=0, dq/dy(x,1)=0\n    \"\"\"\n    Nx, Ny = 81, 61\n    D = 1.0\n    x_domain = [-1.0, 1.0]\n    y_domain = [0.0, 1.0]\n\n    x_grid = np.linspace(x_domain[0], x_domain[1], Nx)\n    y_grid = np.linspace(y_domain[0], y_domain[1], Ny)\n    dx = (x_domain[1] - x_domain[0]) / (Nx - 1)\n    dy = (y_domain[1] - y_domain[0]) / (Ny - 1)\n\n    # Unknowns are interior in x, all points in y\n    num_unknowns = (Nx - 2) * Ny\n    A = lil_matrix((num_unknowns, num_unknowns))\n    b_vec = np.zeros(num_unknowns)\n\n    # Coefficients for Laplace's equation\n    ax = D / (dx**2)\n    ay = D / (dy**2)\n\n    def get_k(i, j):\n        # Map (i, j) grid index to flattened index k\n        # i is in [1, Nx-2], j is in [0, Ny-1]\n        return (i - 1) * Ny + j\n\n    for i in range(1, Nx - 1):\n        for j in range(Ny):\n            k = get_k(i, j)\n            \n            # Diagonal term (contribution of q_{i,j})\n            A[k, k] = -2 * (ax + ay)\n            \n            # x-direction neighbors\n            # q_{i-1,j}\n            if i == 1: # Left Dirichlet boundary q=0\n                pass # Contribution is zero\n            else:\n                A[k, get_k(i - 1, j)] = ax\n            # q_{i+1,j}\n            if i == Nx - 2: # Right Dirichlet boundary q=1\n                b_vec[k] -= ax * 1.0\n            else:\n                A[k, get_k(i + 1, j)] = ax\n\n            # y-direction neighbors\n            if j == 0: # Bottom Neumann boundary\n                A[k, get_k(i, j + 1)] = 2 * ay\n            elif j == Ny - 1: # Top Neumann boundary\n                A[k, get_k(i, j - 1)] = 2 * ay\n            else: # Interior in y\n                A[k, get_k(i, j - 1)] = ay\n                A[k, get_k(i, j + 1)] = ay\n\n    A_csc = A.tocsc()\n    q_flat = spsolve(A_csc, b_vec)\n    \n    q_unknowns = q_flat.reshape((Nx - 2, Ny))\n    \n    q_full = np.zeros((Nx, Ny))\n    q_full[0, :] = 0.0   # Left Dirichlet BC\n    q_full[-1, :] = 1.0  # Right Dirichlet BC\n    q_full[1:-1, :] = q_unknowns\n\n    # Bilinear interpolation\n    query_x, query_y = 0.2, 0.7\n    \n    x_idx_float = (query_x - x_grid[0]) / dx\n    y_idx_float = (query_y - y_grid[0]) / dy\n    \n    i = int(x_idx_float)\n    j = int(y_idx_float)\n    \n    t = x_idx_float - i\n    u = y_idx_float - j\n    \n    q11 = q_full[i, j]\n    q21 = q_full[i + 1, j]\n    q12 = q_full[i, j + 1]\n    q22 = q_full[i + 1, j + 1]\n    \n    result = (1 - t) * (1 - u) * q11 + t * (1 - u) * q21 + (1 - t) * u * q12 + t * u * q22\n    \n    return result\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    result1 = solve_case_1()\n    result2 = solve_case_2()\n    result3 = solve_case_3()\n    \n    # Format the output as a comma-separated list of floats with 6 decimal places.\n    output_str = f\"[{result1:.6f},{result2:.6f},{result3:.6f}]\"\n    print(output_str)\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "In the special but important case of one-dimensional systems, the committor's governing Ordinary Differential Equation (ODE) can often be solved analytically, yielding an explicit integral formula. This exercise  explores this exact solution, shifting the challenge from solving a PDE to accurately computing definite integrals. You will confront key issues of numerical stability that arise in the low-noise regime, a common scenario in the study of rare events.",
            "id": "3796696",
            "problem": "Consider a one-dimensional overdamped stochastic dynamics for a reaction coordinate $x(t)$ evolving under a smooth potential energy function $V(x)$ with additive noise of intensity $\\varepsilon  0$. The process is modeled by the overdamped Langevin equation\n$$\ndx(t) = -\\partial_x V(x(t))\\, dt + \\sqrt{2 \\varepsilon}\\, dW_t,\n$$\nwhere $W_t$ is a standard Wiener process. Define two disjoint sets $A$ and $B$ on the real line with thresholds $a  b$, interpreted as $A = \\{ x \\le a \\}$ and $B = \\{ x \\ge b \\}$. The committor function $q(x)$ is the probability that a trajectory starting at $x$ will reach set $B$ before set $A$. Under the backward Kolmogorov formulation for this dynamics, the committor $q(x)$ on the open interval $(a,b)$ solves the boundary value problem\n$$\n\\mathcal{L} q(x) = 0 \\quad \\text{for } x \\in (a,b), \\quad q(a) = 0, \\quad q(b) = 1,\n$$\nwhere the generator $\\mathcal{L}$ for the overdamped process is the second-order differential operator\n$$\n\\mathcal{L} f(x) = -\\partial_x V(x)\\, \\partial_x f(x) + \\varepsilon\\, \\partial_{xx} f(x).\n$$\nThis committor function is central in rare-event algorithms because it serves as an optimal reaction coordinate: it is constant on iso-committor surfaces and it minimizes probabilistic flux mismatch in Transition Path Theory (TPT) and drives efficient stratification in Weighted Ensemble (WE) schemes.\n\nYour task is to write a complete program that, for given potentials $V(x)$, thresholds $a$ and $b$, and noise intensities $\\varepsilon$, computes $q(x_0)$ for a specified starting point $x_0 \\in [a,b]$ by solving the above boundary value problem in a mathematically consistent manner. All computations are dimensionless; the final outputs are probabilities and must be expressed as decimal floats. If $x_0 = a$ or $x_0 = b$, enforce the boundary conditions $q(a) = 0$ and $q(b) = 1$ exactly.\n\nYou must implement a method grounded in the governing equations. The derivation must start from the generator $\\mathcal{L}$ and the boundary value problem, and the computation must respect the boundary conditions. Ensure numerical stability and accuracy appropriate for advanced graduate-level analysis of rare events.\n\nTest Suite:\nCompute $q(x_0)$ for each of the following six cases. All results must be printed as decimal floats rounded to eight decimal places. The potentials are smooth polynomials defined below. No physical units are required because the problem is dimensionless.\n\n- Case 1 (symmetric double-well, moderate noise, central start):\n  - $V(x) = \\dfrac{(x^2 - 1)^2}{4}$,\n  - $a = -0.9$, $b = 0.9$,\n  - $\\varepsilon = 0.05$,\n  - $x_0 = 0.0$.\n\n- Case 2 (tilted double-well, moderate noise, central start):\n  - $V(x) = \\dfrac{(x^2 - 1)^2}{4} + \\alpha x$ with $\\alpha = 0.2$,\n  - $a = -0.9$, $b = 0.9$,\n  - $\\varepsilon = 0.05$,\n  - $x_0 = 0.0$.\n\n- Case 3 (symmetric double-well, small noise, off-center start; rare-event regime):\n  - $V(x) = \\dfrac{(x^2 - 1)^2}{4}$,\n  - $a = -0.9$, $b = 0.9$,\n  - $\\varepsilon = 0.01$,\n  - $x_0 = -0.5$.\n\n- Case 4 (symmetric double-well, boundary start at $A$):\n  - $V(x) = \\dfrac{(x^2 - 1)^2}{4}$,\n  - $a = -0.9$, $b = 0.9$,\n  - $\\varepsilon = 0.05$,\n  - $x_0 = a$.\n\n- Case 5 (symmetric double-well, boundary start at $B$):\n  - $V(x) = \\dfrac{(x^2 - 1)^2}{4}$,\n  - $a = -0.9$, $b = 0.9$,\n  - $\\varepsilon = 0.05$,\n  - $x_0 = b$.\n\n- Case 6 (weakly tilted double-well, small noise, off-center start):\n  - $V(x) = \\dfrac{(x^2 - 1)^2}{4} + \\alpha x$ with $\\alpha = -0.1$,\n  - $a = -0.9$, $b = 0.9$,\n  - $\\varepsilon = 0.02$,\n  - $x_0 = 0.3$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, each rounded to eight decimal places, for example:\n$$\n[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5},\\text{result6}]\n$$",
            "solution": "The problem statement is assessed to be **valid**. It is scientifically grounded, well-posed, and objective. The problem asks for the computation of the committor function $q(x)$ for a one-dimensional overdamped Langevin dynamics, which is a standard and well-defined problem in statistical mechanics and the theory of stochastic processes. The governing equation, $\\mathcal{L} q(x) = 0$, where $\\mathcal{L}$ is the backward Kolmogorov operator, and the associated boundary conditions $q(a)=0$ and $q(b)=1$, form a well-posed boundary value problem. All parameters and functions are clearly defined, and the premises are consistent with established scientific principles. The problem does not violate any of the invalidity criteria.\n\nThe task is to find the value of the committor function $q(x_0)$ for a particle starting at $x_0 \\in [a,b]$. The function $q(x)$ is defined as the solution to the boundary value problem:\n$$\n\\varepsilon \\frac{d^2q}{dx^2}(x) - \\frac{dV}{dx}(x) \\frac{dq}{dx}(x) = 0, \\quad \\text{for } x \\in (a,b)\n$$\nwith boundary conditions $q(a)=0$ and $q(b)=1$.\n\nThis is a second-order linear ordinary differential equation (ODE). We can solve it by first reducing its order. Let $p(x) = \\frac{dq}{dx}(x)$. The ODE becomes a first-order ODE for $p(x)$:\n$$\n\\varepsilon \\frac{dp}{dx}(x) = \\frac{dV}{dx}(x) p(x)\n$$\nThis is a separable equation:\n$$\n\\frac{dp}{p} = \\frac{1}{\\varepsilon} \\frac{dV}{dx} dx\n$$\nIntegrating both sides yields:\n$$\n\\ln(p(x)) = \\frac{V(x)}{\\varepsilon} + C_0\n$$\nwhere $C_0$ is a constant of integration. Exponentiating both sides gives:\n$$\np(x) = e^{C_0} e^{V(x)/\\varepsilon} = C_1 e^{V(x)/\\varepsilon}\n$$\nwhere $C_1$ is an arbitrary constant. Since $p(x) = \\frac{dq}{dx}(x)$, we can find $q(x)$ by integrating $p(x)$ with respect to $x$:\n$$\nq(x) = \\int p(y) dy + C_2 = C_1 \\int e^{V(y)/\\varepsilon} dy + C_2\n$$\nTo manage the constants of integration, we write this as a definite integral from the boundary $a$:\n$$\nq(x) = C_1 \\int_a^x e^{V(y)/\\varepsilon} dy + C_2\n$$\nNow, we apply the boundary conditions to determine the constants $C_1$ and $C_2$.\n$1$. At $x=a$, we have $q(a)=0$:\n$$\nq(a) = C_1 \\int_a^a e^{V(y)/\\varepsilon} dy + C_2 = C_1 \\cdot 0 + C_2 = 0 \\implies C_2 = 0\n$$\n$2$. At $x=b$, we have $q(b)=1$:\n$$\nq(b) = C_1 \\int_a^b e^{V(y)/\\varepsilon} dy = 1 \\implies C_1 = \\frac{1}{\\int_a^b e^{V(y)/\\varepsilon} dy}\n$$\nSubstituting the expressions for $C_1$ and $C_2$ back into the equation for $q(x)$, we obtain the exact analytical solution:\n$$\nq(x) = \\frac{\\int_a^x e^{V(y)/\\varepsilon} dy}{\\int_a^b e^{V(y)/\\varepsilon} dy}\n$$\nThis formula provides the committor probability $q(x)$ for any point $x \\in [a,b]$. The evaluation for a specific starting point $x_0$ simply requires setting $x=x_0$. If $x_0=a$, the numerator integral is zero, so $q(a)=0$. If $x_0=b$, the numerator and denominator integrals are identical, so $q(b)=1$. These results match the boundary conditions, as expected.\n\nFor a general potential $V(x)$, the integrals must be computed numerically. A significant challenge in numerical evaluation arises when the noise intensity $\\varepsilon$ is small. In such cases, the term $V(y)/\\varepsilon$ in the exponent can become very large, leading to numerical overflow errors when computing $e^{V(y)/\\varepsilon}$. To ensure numerical stability, we can rescale the integrand. Let $V_{max} = \\max_{y \\in [a,b]} V(y)$. We can rewrite the expression for $q(x)$ by factoring out $e^{V_{max}/\\varepsilon}$:\n$$\nq(x) = \\frac{\\int_a^x e^{(V(y) - V_{max})/\\varepsilon} e^{V_{max}/\\varepsilon} dy}{\\int_a^b e^{(V(y) - V_{max})/\\varepsilon} e^{V_{max}/\\varepsilon} dy} = \\frac{e^{V_{max}/\\varepsilon} \\int_a^x e^{(V(y) - V_{max})/\\varepsilon} dy}{e^{V_{max}/\\varepsilon} \\int_a^b e^{(V(y) - V_{max})/\\varepsilon} dy}\n$$\nThe constant factor cancels, yielding a numerically stable formula:\n$$\nq(x) = \\frac{\\int_a^x e^{(V(y) - V_{max})/\\varepsilon} dy}{\\int_a^b e^{(V(y) - V_{max})/\\varepsilon} dy}\n$$\nIn this form, the argument of the exponential is always less than or equal to zero, so the integrand's maximum value is $1$, preventing overflow.\n\nThe implementation will therefore follow these steps:\n$1$. For a given case $(V(x), a, b, \\varepsilon, x_0)$, first check if $x_0$ is at a boundary ($x_0=a$ or $x_0=b$) and return $0$ or $1$ accordingly.\n$2$. For $x_0 \\in (a,b)$, find the maximum value $V_{max}$ of the potential $V(y)$ over the interval $[a,b]$. Since the provided potentials $V(x) = \\frac{(x^2-1)^2}{4} + \\alpha x$ are polynomials, their derivatives $V'(x)=x^3-x+\\alpha$ are also polynomials. The maximum of $V(x)$ on $[a,b]$ occurs either at the endpoints $a, b$ or at a critical point $x_c \\in (a,b)$ where $V'(x_c)=0$. We find the roots of $V'(x)$ numerically, screen for real roots inside $(a,b)$, and evaluate $V(x)$ at these points and at $a, b$ to find $V_{max}$.\n$3$. Define the stabilized integrand $f(y) = e^{(V(y) - V_{max})/\\varepsilon}$.\n$4$. Use a high-precision numerical quadrature routine, such as `scipy.integrate.quad`, to compute the numerator integral $I_{num} = \\int_a^{x_0} f(y) dy$ and the denominator integral $I_{den} = \\int_a^b f(y) dy$.\n$5$. The final result is the ratio $q(x_0) = I_{num} / I_{den}$.\nThis procedure is robust, accurate, and directly implements the derived analytical solution.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the committor problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (symmetric double-well, moderate noise, central start):\n        {'alpha': 0.0, 'a': -0.9, 'b': 0.9, 'epsilon': 0.05, 'x0': 0.0},\n        # Case 2 (tilted double-well, moderate noise, central start):\n        {'alpha': 0.2, 'a': -0.9, 'b': 0.9, 'epsilon': 0.05, 'x0': 0.0},\n        # Case 3 (symmetric double-well, small noise, off-center start; rare-event regime):\n        {'alpha': 0.0, 'a': -0.9, 'b': 0.9, 'epsilon': 0.01, 'x0': -0.5},\n        # Case 4 (symmetric double-well, boundary start at A):\n        {'alpha': 0.0, 'a': -0.9, 'b': 0.9, 'epsilon': 0.05, 'x0': -0.9},\n        # Case 5 (symmetric double-well, boundary start at B):\n        {'alpha': 0.0, 'a': -0.9, 'b': 0.9, 'epsilon': 0.05, 'x0': 0.9},\n        # Case 6 (weakly tilted double-well, small noise, off-center start):\n        {'alpha': -0.1, 'a': -0.9, 'b': 0.9, 'epsilon': 0.02, 'x0': 0.3},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_committor(\n            case['alpha'], case['a'], case['b'], case['epsilon'], case['x0']\n        )\n        results.append(result)\n\n    # Format the final output string as required.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\n\ndef compute_committor(alpha, a, b, epsilon, x0):\n    \"\"\"\n    Computes the committor probability q(x0) for a given potential and parameters.\n\n    The committor q(x) is the solution to the ODE:\n    epsilon * q''(x) - V'(x) * q'(x) = 0\n    with boundary conditions q(a)=0 and q(b)=1.\n\n    The analytical solution is q(x) = Integral[a, x](exp(V(y)/epsilon) dy) / Integral[a, b](exp(V(y)/epsilon) dy).\n\n    Args:\n        alpha (float): The tilt parameter for the potential V(x).\n        a (float): The boundary for state A.\n        b (float): The boundary for state B.\n        epsilon (float): The noise intensity.\n        x0 (float): The starting point.\n\n    Returns:\n        float: The committor probability q(x0).\n    \"\"\"\n    # Handle the boundary conditions directly.\n    if np.isclose(x0, a):\n        return 0.0\n    if np.isclose(x0, b):\n        return 1.0\n\n    # Define the potential V(x) = (x^2 - 1)^2 / 4 + alpha * x\n    V = lambda x: (x**2 - 1)**2 / 4 + alpha * x\n    \n    # To ensure numerical stability, we find the maximum of V(x) on [a, b].\n    # The derivative is V'(x) = x^3 - x + alpha.\n    # The coefficients for the polynomial V'(x) are [1, 0, -1, alpha].\n    V_prime_coeffs = [1, 0, -1, alpha]\n    \n    # Find the roots of the derivative polynomial.\n    crit_points_all = np.roots(V_prime_coeffs)\n    \n    # Filter for real roots that lie within the open interval (a, b).\n    real_crit_points_in_interval = [\n        p.real for p in crit_points_all if np.isclose(p.imag, 0) and a  p.real  b\n    ]\n    \n    # The maximum of V(x) on [a, b] must occur at the endpoints or at a critical point.\n    candidate_points = [a, b] + real_crit_points_in_interval\n    V_values = [V(p) for p in candidate_points]\n    V_max = np.max(V_values)\n\n    # Define the numerically stabilized integrand: exp((V(y) - V_max) / epsilon).\n    # This prevents overflow by ensuring the exponent is non-positive.\n    integrand = lambda y: np.exp((V(y) - V_max) / epsilon)\n\n    # Compute the numerator integral from a to x0.\n    numerator_integral, num_err = quad(integrand, a, x0, limit=200)\n    \n    # Compute the denominator integral from a to b.\n    denominator_integral, den_err = quad(integrand, a, b, limit=200)\n\n    # The committor is the ratio of the two integrals.\n    # A zero denominator is highly unlikely given the strictly positive integrand\n    # unless a=b, which is not the case. It could underflow for extremely small epsilon.\n    if np.isclose(denominator_integral, 0):\n        # Physical interpretation: If the total probability mass underflows to zero,\n        # the probability of reaching any x > a is effectively zero.\n        return 0.0\n        \n    return numerator_integral / denominator_integral\n\nsolve()\n```"
        }
    ]
}