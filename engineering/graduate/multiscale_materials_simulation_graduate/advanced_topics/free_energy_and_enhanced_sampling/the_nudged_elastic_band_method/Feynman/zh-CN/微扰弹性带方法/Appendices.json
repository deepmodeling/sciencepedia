{
    "hands_on_practices": [
        {
            "introduction": "为了掌握微动弹性带（NEB）方法，最关键的第一步是理解作用在路径上每个“像”点的独特驱动力。这个练习将引导你亲手分解这个力。通过对一个具体示例进行计算 ，你将精确地看到真实物理作用力如何被分解为垂直于路径（驱动路径向最小能量路径移动）和平行于路径（被舍弃）的分量，以及弹簧力如何沿着路径重新分布像点。这个基础计算是整个NEB算法核心机制的缩影。",
            "id": "3849267",
            "problem": "考虑一个在二维构型空间中用于寻找最小能量路径的微移弹性带（Nudged Elastic Band, NEB）方法中使用的离散图像路径。给定三个连续的图像，其位置分别为 $\\mathbf{R}_{i-1} = (1.0,\\,0.0)$、$\\mathbf{R}_{i} = (2.0,\\,1.0)$ 和 $\\mathbf{R}_{i+1} = (3.5,\\,1.5)$，所有坐标均以埃（Ångström）为单位。图像 $i$ 处的路径切线被指定为单位向量 $\\hat{\\tau}_{i} = \\left(\\frac{1}{\\sqrt{2}},\\,\\frac{1}{\\sqrt{2}}\\right)$。在 $\\mathbf{R}_{i}$ 处的势能梯度为 $\\nabla V(\\mathbf{R}_{i}) = (4,\\,-2)$，单位为电子伏特每埃。物理力为 $\\mathbf{F}_{i}^{\\text{true}} = -\\nabla V(\\mathbf{R}_{i})$。NEB 弹簧常数为 $k = 0.5$，单位为电子伏特每平方埃。使用 NEB 力，通过步长为 $\\eta = \\frac{1}{20}$（单位为平方埃每电子伏特）的最速下降法移动来更新图像。\n\n从以下基本原理出发：\n- 物理力由 $\\mathbf{F} = -\\nabla V$ 给出。\n- 向量 $\\mathbf{a}$ 沿单位方向 $\\hat{\\mathbf{u}}$ 的平行分量是 $(\\mathbf{a}\\cdot\\hat{\\mathbf{u}})\\,\\hat{\\mathbf{u}}$，垂直分量是 $\\mathbf{a} - (\\mathbf{a}\\cdot\\hat{\\mathbf{u}})\\,\\hat{\\mathbf{u}}$。\n- 位置的最速下降更新使用 $\\mathbf{R}^{\\text{new}} = \\mathbf{R}^{\\text{old}} + \\eta\\,\\mathbf{F}^{\\text{eff}}$，其中 $\\mathbf{F}^{\\text{eff}}$ 为有效力。\n\n计算 $\\mathbf{F}_{i}^{\\text{true}}$ 相对于 $\\hat{\\tau}_{i}$ 的垂直和平行分量。然后，利用从给定位置计算出的路径上相邻图像间距的差异，构建沿 $\\hat{\\tau}_{i}$ 的平行弹簧贡献，并通过组合物理力的垂直分量和平行弹簧项来形成 NEB 有效力。最后，确定由此次 NEB 更新产生的单步位移大小 $\\|\\Delta \\mathbf{R}_{i}\\| = \\|\\eta\\,\\mathbf{F}_{i}^{\\text{NEB}}\\|$。\n\n请以精确的闭合形式解析表达式给出最终答案。位移大小以埃（Ångström）表示。不要四舍五入，需要精确表达式。最终答案必须是单个表达式。",
            "solution": "首先验证问题，以确保其具有科学依据、问题设定合理且所有必要信息均已提供。\n\n**问题验证**\n\n从问题陈述中提取的已知条件：\n- 三个连续图像的位置：$\\mathbf{R}_{i-1} = (1.0,\\,0.0)$、$\\mathbf{R}_{i} = (2.0,\\,1.0)$ 和 $\\mathbf{R}_{i+1} = (3.5,\\,1.5)$。所有坐标均以埃（Å）为单位。\n- 图像 $i$ 处的指定路径切线：$\\hat{\\tau}_{i} = \\left(\\frac{1}{\\sqrt{2}},\\,\\frac{1}{\\sqrt{2}}\\right)$。\n- $\\mathbf{R}_{i}$ 处的势能梯度：$\\nabla V(\\mathbf{R}_{i}) = (4,\\,-2)$，单位为电子伏特每埃（eV/Å）。\n- 真实物理力的定义：$\\mathbf{F}_{i}^{\\text{true}} = -\\nabla V(\\mathbf{R}_{i})$。\n- NEB 弹簧常数：$k = 0.5$ eV/Å$^2$。\n- 最速下降步长：$\\eta = \\frac{1}{20}$ Å$^2$/eV。\n- 更新规则：$\\mathbf{R}^{\\text{new}} = \\mathbf{R}^{\\text{old}} + \\eta\\,\\mathbf{F}^{\\text{eff}}$。\n- 向量分量的定义：向量 $\\mathbf{a}$ 沿单位方向 $\\hat{\\mathbf{u}}$ 的平行分量为 $(\\mathbf{a}\\cdot\\hat{\\mathbf{u}})\\,\\hat{\\mathbf{u}}$，垂直分量为 $\\mathbf{a} - (\\mathbf{a}\\cdot\\hat{\\mathbf{u}})\\,\\hat{\\mathbf{u}}$。\n\n该问题是科学合理的，因为它基于计算科学中成熟的微移弹性带（NEB）方法。所有参数都明确定义，单位一致，目标清晰。对此类练习使用指定的切线向量是一种有效的简化，不会产生矛盾。因此，该问题被认为是有效的，可以推导出解决方案。\n\n**求解推导**\n\n求解过程遵循问题陈述中要求的步骤。\n\n首先，我们利用给定的势能梯度确定作用在图像 $i$ 上的真实物理力 $\\mathbf{F}_{i}^{\\text{true}}$：\n$$\n\\mathbf{F}_{i}^{\\text{true}} = -\\nabla V(\\mathbf{R}_{i}) = -(4,\\,-2) = (-4,\\,2) \\quad \\text{eV/Å}\n$$\n\n接下来，我们将此力分解为平行于和垂直于指定路径切线 $\\hat{\\tau}_{i} = \\left(\\frac{1}{\\sqrt{2}},\\,\\frac{1}{\\sqrt{2}}\\right)$ 的分量。平行分量通过将 $\\mathbf{F}_{i}^{\\text{true}}$ 投影到 $\\hat{\\tau}_{i}$ 上得到：\n$$\n\\mathbf{F}_{i}^{\\text{true},\\parallel} = (\\mathbf{F}_{i}^{\\text{true}} \\cdot \\hat{\\tau}_{i}) \\hat{\\tau}_{i}\n$$\n标量投影为：\n$$\n\\mathbf{F}_{i}^{\\text{true}} \\cdot \\hat{\\tau}_{i} = (-4,\\,2) \\cdot \\left(\\frac{1}{\\sqrt{2}},\\,\\frac{1}{\\sqrt{2}}\\right) = -4\\left(\\frac{1}{\\sqrt{2}}\\right) + 2\\left(\\frac{1}{\\sqrt{2}}\\right) = -\\frac{2}{\\sqrt{2}} = -\\sqrt{2} \\quad \\text{eV/Å}\n$$\n真实力的垂直分量 $\\mathbf{F}_{i}^{\\perp}$ 是真实力中与路径切线正交的部分。该分量用于 NEB 力中，以引导路径朝向最小能量路径，而不会导致图像沿路径滑动。\n$$\n\\mathbf{F}_{i}^{\\perp} = \\mathbf{F}_{i}^{\\text{true}} - \\mathbf{F}_{i}^{\\text{true},\\parallel} = \\mathbf{F}_{i}^{\\text{true}} - (\\mathbf{F}_{i}^{\\text{true}} \\cdot \\hat{\\tau}_{i}) \\hat{\\tau}_{i}\n$$\n代入数值：\n$$\n\\mathbf{F}_{i}^{\\perp} = (-4,\\,2) - (-\\sqrt{2})\\left(\\frac{1}{\\sqrt{2}},\\,\\frac{1}{\\sqrt{2}}\\right) = (-4,\\,2) - (-1,\\,-1) = (-3,\\,3) \\quad \\text{eV/Å}\n$$\n\nNEB 力的第二部分是弹簧力，其作用是保持路径上图像之间的等间距。弹簧力平行于路径切线方向。\n$$\n\\mathbf{F}_{i}^{\\text{spring},\\parallel} = k (\\|\\mathbf{R}_{i+1} - \\mathbf{R}_{i}\\| - \\|\\mathbf{R}_{i} - \\mathbf{R}_{i-1}\\|) \\hat{\\tau}_{i}\n$$\n我们需要计算与图像 $i$ 相邻的路径段的长度：\n$$\n\\mathbf{R}_{i} - \\mathbf{R}_{i-1} = (2.0 - 1.0,\\,1.0 - 0.0) = (1,\\,1) \\quad \\text{Å}\n$$\n$$\n\\|\\mathbf{R}_{i} - \\mathbf{R}_{i-1}\\| = \\sqrt{1^2 + 1^2} = \\sqrt{2} \\quad \\text{Å}\n$$\n$$\n\\mathbf{R}_{i+1} - \\mathbf{R}_{i} = (3.5 - 2.0,\\,1.5 - 1.0) = (1.5,\\,0.5) = \\left(\\frac{3}{2},\\,\\frac{1}{2}\\right) \\quad \\text{Å}\n$$\n$$\n\\|\\mathbf{R}_{i+1} - \\mathbf{R}_{i}\\| = \\sqrt{\\left(\\frac{3}{2}\\right)^2 + \\left(\\frac{1}{2}\\right)^2} = \\sqrt{\\frac{9}{4} + \\frac{1}{4}} = \\sqrt{\\frac{10}{4}} = \\sqrt{\\frac{5}{2}} \\quad \\text{Å}\n$$\n弹簧常数 $k = 0.5 = \\frac{1}{2}$ eV/Å$^2$，则弹簧力为：\n$$\n\\mathbf{F}_{i}^{\\text{spring},\\parallel} = \\frac{1}{2} \\left(\\sqrt{\\frac{5}{2}} - \\sqrt{2}\\right) \\hat{\\tau}_{i}\n$$\n\n总 NEB 力 $\\mathbf{F}_{i}^{\\text{NEB}}$ 是真实力的垂直分量与弹簧力的平行分量之和：\n$$\n\\mathbf{F}_{i}^{\\text{NEB}} = \\mathbf{F}_{i}^{\\perp} + \\mathbf{F}_{i}^{\\text{spring},\\parallel}\n$$\n由于 $\\mathbf{F}_{i}^{\\perp}$ 与 $\\hat{\\tau}_{i}$ 正交，而 $\\mathbf{F}_{i}^{\\text{spring},\\parallel}$ 与 $\\hat{\\tau}_{i}$ 平行，因此这两个向量相互正交。所以，总 NEB 力大小的平方等于它们各自大小平方的和：\n$$\n\\|\\mathbf{F}_{i}^{\\text{NEB}}\\|^2 = \\|\\mathbf{F}_{i}^{\\perp}\\|^2 + \\|\\mathbf{F}_{i}^{\\text{spring},\\parallel}\\|^2\n$$\n我们来计算大小的平方：\n$$\n\\|\\mathbf{F}_{i}^{\\perp}\\|^2 =\\|(-3,\\,3)\\|^2 = (-3)^2 + 3^2 = 9 + 9 = 18\n$$\n$$\n\\|\\mathbf{F}_{i}^{\\text{spring},\\parallel}\\|^2 = \\left\\| \\frac{1}{2} \\left(\\sqrt{\\frac{5}{2}} - \\sqrt{2}\\right) \\hat{\\tau}_{i} \\right\\|^2 = \\left( \\frac{1}{2} \\left(\\sqrt{\\frac{5}{2}} - \\sqrt{2}\\right) \\right)^2 \\|\\hat{\\tau}_{i}\\|^2\n$$\n因为 $\\hat{\\tau}_{i}$ 是单位向量，所以 $\\|\\hat{\\tau}_{i}\\|^2 = 1$。\n$$\n\\|\\mathbf{F}_{i}^{\\text{spring},\\parallel}\\|^2 = \\frac{1}{4} \\left(\\sqrt{\\frac{5}{2}} - \\sqrt{2}\\right)^2 = \\frac{1}{4} \\left( \\frac{5}{2} - 2\\sqrt{\\frac{5}{2}}\\sqrt{2} + 2 \\right) = \\frac{1}{4} \\left( \\frac{9}{2} - 2\\sqrt{5} \\right) = \\frac{9}{8} - \\frac{\\sqrt{5}}{2} = \\frac{9 - 4\\sqrt{5}}{8}\n$$\n现在，将大小的平方相加：\n$$\n\\|\\mathbf{F}_{i}^{\\text{NEB}}\\|^2 = 18 + \\frac{9 - 4\\sqrt{5}}{8} = \\frac{144}{8} + \\frac{9 - 4\\sqrt{5}}{8} = \\frac{153 - 4\\sqrt{5}}{8}\n$$\n\n最后，我们使用步长为 $\\eta = \\frac{1}{20}$ 的最速下降更新规则计算单步位移的大小 $\\|\\Delta \\mathbf{R}_{i}\\|$：\n$$\n\\|\\Delta \\mathbf{R}_{i}\\| = \\|\\eta\\,\\mathbf{F}_{i}^{\\text{NEB}}\\| = \\eta \\|\\mathbf{F}_{i}^{\\text{NEB}}\\| = \\frac{1}{20} \\sqrt{\\frac{153 - 4\\sqrt{5}}{8}}\n$$\n为了将其表示为单个分数，我们简化表达式：\n$$\n\\|\\Delta \\mathbf{R}_{i}\\| = \\frac{1}{20} \\frac{\\sqrt{153 - 4\\sqrt{5}}}{\\sqrt{8}} = \\frac{\\sqrt{153 - 4\\sqrt{5}}}{20 \\cdot 2\\sqrt{2}} = \\frac{\\sqrt{153 - 4\\sqrt{5}}}{40\\sqrt{2}}\n$$\n将分母有理化：\n$$\n\\|\\Delta \\mathbf{R}_{i}\\| = \\frac{\\sqrt{153 - 4\\sqrt{5}} \\cdot \\sqrt{2}}{40\\sqrt{2} \\cdot \\sqrt{2}} = \\frac{\\sqrt{2(153 - 4\\sqrt{5})}}{40 \\cdot 2} = \\frac{\\sqrt{306 - 8\\sqrt{5}}}{80}\n$$\n这就是位移大小的最终精确解析表达式，单位为埃（Å）。",
            "answer": "$$\\boxed{\\frac{\\sqrt{306 - 8\\sqrt{5}}}{80}}$$"
        },
        {
            "introduction": "在理解了单个像点上的力之后，我们现在转向一个更实际的问题：如何为整条路径实现NEB算法。一个核心的微妙之处在于如何定义路径的“切线方向” $\\hat{\\tau}_i$。这个编码练习  将让你在一个经典的二维势能面（Müller-Brown势能面）上，对比一个简单的几何切线定义和一个更先进的、考虑能量变化的切线定义。通过比较两种方法产生的力和像点移动，你将亲身体会到为何一个好的切线定义对于避免算法扭结和确保收敛至关重要。",
            "id": "3849299",
            "problem": "给定一个二维势能面，称为 Müller-Brown 势能面。考虑该势能面上两个固定端点之间由一系列图像（image）构成的离散路径。目标是构建一个算法，使用两种不同的定义来计算图像切线，组装相应的微动弹性带（Nudged Elastic Band, NEB）力，对图像位置执行一次显式欧拉更新，并比较由朴素切线定义和改进切线定义所产生的整体运动。\n\n从以下基本原理和核心定义开始：\n\n- 势能函数 $V(\\mathbf{r})$ 通过其负梯度产生力 $\\mathbf{F}(\\mathbf{r}) = -\\nabla V(\\mathbf{r})$。\n- 构型空间中的一条路径被离散化为 $N$ 个图像 $\\{\\mathbf{R}_0, \\mathbf{R}_1, \\ldots, \\mathbf{R}_{N-1}\\}$，其中 $\\mathbf{R}_0$ 和 $\\mathbf{R}_{N-1}$ 是固定端点，而对于 $i \\in \\{1,\\ldots,N-2\\}$ 的图像 $\\mathbf{R}_i$ 可以根据定义的力移动。\n- 向量在某一单位方向向量及其垂直补集上的投影概念，允许将任意向量分解为平行于该方向和正交于该方向的分量。\n\nMüller-Brown 势 $V(x,y)$ 由四个类高斯项的总和定义，其参数在文献中被广泛使用。设参数为：\n- $A = [-200, -100, -170, 15]$，\n- $a = [-1, -1, -6.5, 0.7]$，\n- $b = [0, 0, 11, 0.6]$，\n- $c = [-10, -10, -6.5, 0.7]$，\n- $x_0 = [1, 0, -0.5, -1]$，\n- $y_0 = [0, 0.5, 1.5, 1]$。\n\n势能为：\n$$\nV(x,y) = \\sum_{k=1}^{4} A_k \\exp\\left(a_k (x - x_{0,k})^2 + b_k (x - x_{0,k})(y - y_{0,k}) + c_k (y - y_{0,k})^2\\right).\n$$\n\n根据此 $V(x,y)$，通过对指数项进行微分，显式计算梯度分量，以获得 $\\partial V / \\partial x$ 和 $\\partial V / \\partial y$，用于计算力 $\\mathbf{F}(\\mathbf{r}) = -\\nabla V(\\mathbf{r})$。\n\n对于每个内部图像 $\\mathbf{R}_i$（其中 $i \\in \\{1,\\ldots,N-2\\}$），定义两种切线方案：\n\n- 朴素切线定义：使用基于相邻图像的中心差分方向，并将其归一化为单位向量。当中心差分退化为零向量时，则回退到基于具有较长路径段的单个邻居的方向差分，并进行归一化。\n\n- 改进切线定义：使用相邻图像的能量来确定方向。设 $E_i = V(\\mathbf{R}_i)$，并定义能量差 $dE_{+} = E_{i+1} - E_i$ 和 $dE_{-} = E_{i-1} - E_i$。使用以下规则选择切线：\n  1. 如果两个相邻图像的能量都更高，即 $dE_{+} > 0$ 且 $dE_{-} > 0$，则将方向构造为前向和后向差分的加权和，权重与能量增加的幅度成正比，然后将结果归一化。\n  2. 如果两个相邻图像的能量都更低，即 $dE_{+}  0$ 且 $dE_{-}  0$，则将方向构造为前向和后向差分的加权和，权重与能量减少的幅度成正比，然后将结果归一化。\n  3. 否则（图像间的能量呈单调变化），选择指向能量变化幅度较大的邻居的差分向量，并对结果进行归一化。\n\n对于每个内部图像，使用单位切线 $\\hat{\\tau}_i$ 来组装 NEB 力，该力包含：\n- 垂直于路径切线的真实力分量，通过将基于梯度的力分解为相对于 $\\hat{\\tau}_i$ 的平行和垂直分量，并舍弃平行分量来计算。\n- 沿路径切线作用的弹簧力，旨在保持图像间的均匀间距，使用一个线性弹簧，其弹性系数 $k$ 取决于相邻路径段长度的差异。\n\n计算完这些力后，对内部图像执行一个步长为 $\\Delta t$ 的单步显式欧拉更新：\n$$\n\\mathbf{R}_i^{\\text{new}} = \\mathbf{R}_i + \\Delta t \\, \\mathbf{F}_i^{\\text{NEB}},\n$$\n同时保持端点固定。\n\n你的程序必须：\n\n1. 实现 $V(x,y)$ 及其梯度 $\\nabla V(x,y)$。\n2. 通过在给定的固定端点之间进行线性插值，构建一条包含 $N$ 个图像的初始路径。\n3. 计算图像能量 $E_i$。\n4. 通过上述的朴素和改进两种定义计算切线 $\\hat{\\tau}_i$。\n5. 使用真实力的垂直分量和带有弹性系数 $k$ 的切向弹簧力来组装 NEB 力。\n6. 对每种切线定义，使用步长 $\\Delta t$ 对内部图像执行一次显式欧拉更新。\n7. 对于每种情况，返回四个量：\n   - 使用朴素切线时，内部图像上 NEB 力的欧几里得范数之和。\n   - 使用改进切线时，内部图像上 NEB 力的欧几里得范数之和。\n   - 使用朴素切线时，内部图像上欧拉位移的欧几里得范数之和。\n   - 使用改进切线时，内部图像上欧拉位移的欧几里得范数之和。\n\n在此问题中，所有量都是无量纲的。不涉及角度或百分比。\n\n所有测试的端点都固定在 Müller-Brown 势能面两个已知极小值点的近似值上：\n- $\\mathbf{R}_{\\text{start}} = (-0.558, \\; 1.442)$，\n- $\\mathbf{R}_{\\text{end}} = (0.623, \\; 0.028)$。\n\n测试套件：\n- 情况 1：$N = 9$，$k = 1.0$，$\\Delta t = 0.05$。\n- 情况 2：$N = 3$，$k = 1.0$，$\\Delta t = 0.05$。\n- 情况 3：$N = 7$，$k = 5.0$，$\\Delta t = 0.10$。\n- 情况 4：$N = 11$，$k = 0.0$，$\\Delta t = 0.05$。\n\n最终输出格式：\n你的程序应该生成单行输出，其中包含所有测试用例的结果，形式为一个由方括号括起来的逗号分隔列表，每个测试用例的结果本身是按上述顺序排列的四个数字的列表。例如，输出行应如下所示：\n$$\n[\\,[f_1^{\\text{naive}}, f_1^{\\text{improved}}, d_1^{\\text{naive}}, d_1^{\\text{improved}}],\\,[f_2^{\\text{naive}}, f_2^{\\text{improved}}, d_2^{\\text{naive}}, d_2^{\\text{improved}}],\\,\\ldots\\,]\n$$",
            "solution": "该问题要求在微动弹性带（NEB）方法中实现并比较两种不同的切线定义。我们将在 Müller-Brown 势能面上对一条离散路径执行单步模拟。该过程涉及定义势及其梯度、初始化路径、使用两种切线方案计算 NEB 力，并应用一个显式欧拉积分步骤。\n\n首先，我们定义 Müller-Brown 势能面（PES）的数学框架以及由其派生的力。势能 $V(x,y)$ 由以下公式给出：\n$$\nV(x,y) = \\sum_{k=1}^{4} A_k \\exp\\left(a_k (x - x_{0,k})^2 + b_k (x - x_{0,k})(y - y_{0,k}) + c_k (y - y_{0,k})^2\\right)\n$$\n对于 $k \\in \\{1,2,3,4\\}$ 的参数 $\\{A_k, a_k, b_k, c_k, x_{0,k}, y_{0,k}\\}$ 是给定的常数。令 $\\mathbf{r} = (x,y)$ 为位置向量。在 $\\mathbf{r}$ 处的粒子受到的力由势的负梯度给出，即 $\\mathbf{F}(\\mathbf{r}) = -\\nabla V(\\mathbf{r})$。梯度的分量通过偏微分求得：\n$$\n\\frac{\\partial V}{\\partial x} = \\sum_{k=1}^{4} A_k \\exp(\\dots) \\left[ 2a_k(x-x_{0,k}) + b_k(y-y_{0,k}) \\right]\n$$\n$$\n\\frac{\\partial V}{\\partial y} = \\sum_{k=1}^{4} A_k \\exp(\\dots) \\left[ b_k(x-x_{0,k}) + 2c_k(y-y_{0,k}) \\right]\n$$\n其中 $\\exp(\\dots)$ 代表 $V(x,y)$ 定义中的完整指数项。\n\n一个反应路径被离散化为一系列 $N$ 个图像，表示为 $\\{\\mathbf{R}_0, \\mathbf{R}_1, \\dots, \\mathbf{R}_{N-1}\\}$。图像 $\\mathbf{R}_0$ 和 $\\mathbf{R}_{N-1}$ 是固定的端点，对应于势能面上的局部极小值点。初始路径通过在这些端点之间进行线性插值来构建：\n$$\n\\mathbf{R}_i = \\mathbf{R}_0 + \\frac{i}{N-1}(\\mathbf{R}_{N-1} - \\mathbf{R}_0) \\quad \\text{for } i = 0, \\dots, N-1.\n$$\n\nNEB 方法的核心是定义作用于内部图像 $\\mathbf{R}_i$（$i \\in \\{1, \\dots, N-2\\}$）上的力。这个力 $\\mathbf{F}_i^{\\text{NEB}}$ 由两部分组成：真实势能力的垂直分量 $\\mathbf{F}_i^\\perp$ 和一个平行的弹簧力 $\\mathbf{F}_i^s$。\n$$\n\\mathbf{F}_i^{\\text{NEB}} = \\mathbf{F}_i^\\perp + \\mathbf{F}_i^s\n$$\n真实力为 $\\mathbf{F}_i = -\\nabla V(\\mathbf{R}_i)$。力的分解需要一个定义路径局部方向的切向量 $\\hat{\\tau}_i$。垂直力分量将图像推向最低能量路径：\n$$\n\\mathbf{F}_i^\\perp = \\mathbf{F}_i - (\\mathbf{F}_i \\cdot \\hat{\\tau}_i)\\hat{\\tau}_i\n$$\n弹簧力分量确保图像沿路径大致均匀分布：\n$$\n\\mathbf{F}_i^s = k (\\|\\mathbf{R}_{i+1} - \\mathbf{R}_i\\| - \\|\\mathbf{R}_i - \\mathbf{R}_{i-1}\\|) \\hat{\\tau}_i\n$$\n这里，$k$ 是弹性系数。该问题要求评估切向量 $\\hat{\\tau}_i$ 的两种不同定义。\n\n1.  **朴素切线**：切线使用图像位置的简单中心有限差分来估计。\n    $$\n    \\mathbf{\\tau}_{i, \\text{naive}} = \\mathbf{R}_{i+1} - \\mathbf{R}_{i-1}\n    $$\n    该向量随后被归一化为单位长度，即 $\\hat{\\tau}_{i, \\text{naive}} = \\mathbf{\\tau}_{i, \\text{naive}} / \\|\\mathbf{\\tau}_{i, \\text{naive}}\\|$。为 $\\mathbf{R}_{i+1} = \\mathbf{R}_{i-1}$ 的退化情况定义了回退方法，这种情况下切线向量为零。此时，切线取为连接到邻居的两个路径段（$(\\mathbf{R}_{i+1} - \\mathbf{R}_i)$ 或 $(\\mathbf{R}_i - \\mathbf{R}_{i-1})$）中较长者的归一化向量。\n\n2.  **改进切线**：这个定义受到 Henkelman 和 Jónsson 工作的启发，使用图像的势能 $E_j=V(\\mathbf{R}_j)$ 来提供更稳健的切线估计，尤其是在极值点附近。设 $dE_+ = E_{i+1} - E_i$ 和 $dE_- = E_{i-1} - E_i$。切线由三种情况定义：\n    - 如果图像 $\\mathbf{R}_i$ 位于带上能量的局部最小值或最大值处（即 $(dE_+  0 \\text{ 且 } dE_-  0)$ 或 $(dE_+  0 \\text{ 且 } dE_-  0)$），则切线是到相邻图像的向量 $\\mathbf{v}_+ = \\mathbf{R}_{i+1}-\\mathbf{R}_i$ 和 $\\mathbf{v}_- = \\mathbf{R}_i-\\mathbf{R}_{i-1}$ 的加权平均。为防止扭结（kinking），切线的权重设置使其更多地与经历较小能量变化的路径段对齐。未归一化的切线是 $\\mathbf{\\tau}_{i, \\text{imp}} = \\mathbf{v}_+ |dE_-| + \\mathbf{v}_- |dE_+|$。\n    - 否则，能量呈单调变化。切线取为指向能量变化幅度较大的邻居的向量。如果 $|dE_+|  |dE_-|$，则 $\\mathbf{\\tau}_{i, \\text{imp}} = \\mathbf{R}_{i+1} - \\mathbf{R}_i$。如果 $|dE_-|  |dE_+|$，则 $\\mathbf{\\tau}_{i, \\text{imp}} = \\mathbf{R}_i - \\mathbf{R}_{i-1}$。如果 $|dE_+| = |dE_-|$，我们按惯例选择前向方向。\n    在所有情况下，得到的向量 $\\mathbf{\\tau}_{i, \\text{imp}}$ 都被归一化以产生单位切线 $\\hat{\\tau}_{i, \\text{imp}}$。\n\n一旦为所有内部图像 $i \\in \\{1, \\dots, N-2\\}$ 计算出 NEB 力 $\\mathbf{F}_{i, \\text{naive}}^{\\text{NEB}}$ 和 $\\mathbf{F}_{i, \\text{improved}}^{\\text{NEB}}$，我们就执行一个步长为 $\\Delta t$ 的单步显式欧拉积分：\n$$\n\\mathbf{R}_i^{\\text{new}} = \\mathbf{R}_i + \\Delta t \\, \\mathbf{F}_i^{\\text{NEB}}\n$$\n此更新针对每种切线定义分别执行，生成两组新的图像位置。\n\n最后，对于每个给定的测试用例，我们必须计算并报告四个聚合量：\n- 使用朴素切线时，所有内部图像的 NEB 力的欧几里得范数之和：$\\sum_{i=1}^{N-2} \\|\\mathbf{F}_{i, \\text{naive}}^{\\text{NEB}}\\|$。\n- 使用改进切线时的相同总和：$\\sum_{i=1}^{N-2} \\|\\mathbf{F}_{i, \\text{improved}}^{\\text{NEB}}\\|$。\n- 使用朴素切线时，图像位移 $\\Delta \\mathbf{R}_i = \\mathbf{R}_i^{\\text{new}} - \\mathbf{R}_i$ 的欧几里得范数之和：$\\sum_{i=1}^{N-2} \\|\\Delta t \\, \\mathbf{F}_{i, \\text{naive}}^{\\text{NEB}}\\|$。\n- 使用改进切线时的相同总和：$\\sum_{i=1}^{N-2} \\|\\Delta t \\, \\mathbf{F}_{i, \\text{improved}}^{\\text{NEB}}\\|$。\n请注意，位移范数就是力范数乘以 $\\Delta t$。\n\n每个测试用例的算法流程如下：\n1.  通过在 $\\mathbf{R}_{\\text{start}} = (-0.558, \\; 1.442)$ 和 $\\mathbf{R}_{\\text{end}} = (0.623, \\; 0.028)$ 之间进行线性插值，初始化包含 $N$ 个图像的路径。\n2.  计算所有图像的势能 $E_i = V(\\mathbf{R}_i)$。\n3.  对于每个内部图像 $i \\in \\{1, \\dots, N-2\\}$：\n    a. 计算朴素切线 $\\hat{\\tau}_{i, \\text{naive}}$ 和改进切线 $\\hat{\\tau}_{i, \\text{improved}}$。\n    b. 计算真实力 $\\mathbf{F}_i = -\\nabla V(\\mathbf{R}_i)$。\n    c. 使用各自的切线组装 NEB 力 $\\mathbf{F}_{i, \\text{naive}}^{\\text{NEB}}$ 和 $\\mathbf{F}_{i, \\text{improved}}^{\\text{NEB}}$。\n4.  对两种方法，将所有内部图像上的力范数和相应位移的范数求和。\n5.  收集四个最终标量值以供最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global parameters for the Müller-Brown potential\nA = np.array([-200, -100, -170, 15])\na = np.array([-1, -1, -6.5, 0.7])\nb = np.array([0, 0, 11, 0.6])\nc = np.array([-10, -10, -6.5, 0.7])\nx0 = np.array([1, 0, -0.5, -1])\ny0 = np.array([0, 0.5, 1.5, 1])\n\ndef muller_brown_potential(x, y):\n    \"\"\"Computes the Müller-Brown potential V(x,y).\"\"\"\n    val = 0.0\n    for k in range(4):\n        dx = x - x0[k]\n        dy = y - y0[k]\n        val += A[k] * np.exp(a[k] * dx**2 + b[k] * dx * dy + c[k] * dy**2)\n    return val\n\ndef muller_brown_gradient(x, y):\n    \"\"\"Computes the gradient of the Müller-Brown potential.\"\"\"\n    grad_x = 0.0\n    grad_y = 0.0\n    for k in range(4):\n        dx = x - x0[k]\n        dy = y - y0[k]\n        exp_term = np.exp(a[k] * dx**2 + b[k] * dx * dy + c[k] * dy**2)\n        \n        dEx_dx = 2 * a[k] * dx + b[k] * dy\n        dEx_dy = b[k] * dx + 2 * c[k] * dy\n        \n        grad_x += A[k] * exp_term * dEx_dx\n        grad_y += A[k] * exp_term * dEx_dy\n    return np.array([grad_x, grad_y])\n\ndef normalize(v):\n    \"\"\"Normalizes a vector, handling the zero-vector case.\"\"\"\n    norm = np.linalg.norm(v)\n    if norm  1e-9:  # A small tolerance for floating point comparisons\n        return np.zeros_like(v)\n    return v / norm\n\ndef compute_neb_forces(R_path, k):\n    \"\"\"\n    Computes NEB forces for a given path using both naive and improved tangents.\n    \"\"\"\n    N = len(R_path)\n    energies = np.array([muller_brown_potential(pos[0], pos[1]) for pos in R_path])\n    \n    F_neb_naive = np.zeros_like(R_path)\n    F_neb_improved = np.zeros_like(R_path)\n\n    for i in range(1, N - 1):\n        R_prev, R_curr, R_next = R_path[i-1], R_path[i], R_path[i+1]\n        E_prev, E_curr, E_next = energies[i-1], energies[i], energies[i+1]\n        \n        true_force = -muller_brown_gradient(R_curr[0], R_curr[1])\n\n        # 1. Naive Tangent\n        tau_naive_un = R_next - R_prev\n        if np.linalg.norm(tau_naive_un)  1e-9:\n            # Fallback for degenerate centered difference\n            seg_fwd = R_next - R_curr\n            seg_bwd = R_curr - R_prev\n            if np.linalg.norm(seg_fwd) > np.linalg.norm(seg_bwd):\n                tau_naive_un = seg_fwd\n            else:\n                tau_naive_un = seg_bwd\n        tau_hat_naive = normalize(tau_naive_un)\n\n        # 2. Improved Tangent\n        dE_plus = E_next - E_curr\n        dE_minus = E_prev - E_curr\n        \n        v_fwd = R_next - R_curr\n        v_bwd = R_curr - R_prev\n\n        if dE_plus > 0 and dE_minus > 0: # Valley\n            tau_imp_un = v_fwd * abs(dE_minus) + v_bwd * abs(dE_plus)\n        elif dE_plus  0 and dE_minus  0: # Ridge\n            tau_imp_un = v_fwd * abs(dE_minus) + v_bwd * abs(dE_plus)\n        else: # Monotonic\n            if abs(dE_plus) > abs(dE_minus):\n                tau_imp_un = v_fwd\n            elif abs(dE_minus) > abs(dE_plus):\n                tau_imp_un = v_bwd\n            else: # Equal magnitude change, choose forward\n                tau_imp_un = v_fwd\n        tau_hat_improved = normalize(tau_imp_un)\n        \n        # Assemble forces for both tangent definitions\n        tangents = [tau_hat_naive, tau_hat_improved]\n        force_arrays = [F_neb_naive, F_neb_improved]\n\n        for j in range(2):\n            tau_hat = tangents[j]\n            F_neb_array = force_arrays[j]\n\n            # Perpendicular force component\n            F_perp = true_force - np.dot(true_force, tau_hat) * tau_hat\n            \n            # Spring force component\n            seg_len_plus = np.linalg.norm(v_fwd)\n            seg_len_minus = np.linalg.norm(v_bwd)\n            F_spring = k * (seg_len_plus - seg_len_minus) * tau_hat\n            \n            F_neb_array[i] = F_perp + F_spring\n            \n    return F_neb_naive, F_neb_improved\n\ndef solve():\n    R_start = np.array([-0.558, 1.442])\n    R_end = np.array([0.623, 0.028])\n\n    test_cases = [\n        (9, 1.0, 0.05),\n        (3, 1.0, 0.05),\n        (7, 5.0, 0.10),\n        (11, 0.0, 0.05),\n    ]\n\n    results = []\n    for N, k, dt in test_cases:\n        # 1. Initialize path\n        path = np.linspace(R_start, R_end, N)\n        \n        # 2. Compute NEB forces for both tangent types\n        F_naive, F_improved = compute_neb_forces(path, k)\n        \n        # 3. Calculate result metrics (sums over interior images)\n        interior_forces_naive = F_naive[1:-1]\n        interior_forces_improved = F_improved[1:-1]\n        \n        sum_F_norm_naive = np.sum(np.linalg.norm(interior_forces_naive, axis=1))\n        sum_F_norm_improved = np.sum(np.linalg.norm(interior_forces_improved, axis=1))\n\n        # Displacement is dt * Force, so sum of disp norms is dt * sum of force norms\n        sum_disp_norm_naive = dt * sum_F_norm_naive\n        sum_disp_norm_improved = dt * sum_F_norm_improved\n        \n        results.append([\n            sum_F_norm_naive, \n            sum_F_norm_improved, \n            sum_disp_norm_naive, \n            sum_disp_norm_improved\n        ])\n\n    # Final print statement in the exact required format.\n    # The format specifier ensures consistent output formatting.\n    formatted_results = [f\"[{','.join(f'{x:.7f}' for x in case_res)}]\" for case_res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "NEB计算成功收敛后，我们的工作还没有结束。路径上能量最高的像点仅仅是过渡态的“候选者”。为了确认它是否是一个物理上真实的过渡态（即一级鞍点），我们必须分析该点上势能面的曲率。这个练习  将指导你完成这一关键的验证步骤。你将通过数值方法计算候选鞍点处的Hessian矩阵，并通过分析其特征值来验证它是否恰好只有一个负特征值。这个过程不仅能确认过渡态的有效性，还能让你了解NEB路径与真实反应坐标的对齐程度。",
            "id": "3789297",
            "problem": "给定一个由函数 $E(\\mathbf{x})$（其中 $\\mathbf{x} \\in \\mathbb{R}^2$）指定的二维无量纲势能面，以及三条通过使用微动弹性带（Nudged Elastic Band, NEB）方法获得的候选鞍点镜像的离散路径。您的任务是在每条路径的中心镜像处数值构建完整的 Hessian 矩阵，通过单一负特征值判据对鞍点进行分类，并量化最不稳定模式相对于 NEB 路径切线的朝向。\n\n使用的基础理论：\n- 标量场 $E(\\mathbf{x})$ 在点 $\\mathbf{x}^\\star$ 处的 Hessian 矩阵是由二阶偏导数定义的矩阵：$H_{ij}(\\mathbf{x}^\\star) = \\frac{\\partial^2 E}{\\partial x_i \\partial x_j}(\\mathbf{x}^\\star)$。\n- 对称 Hessian 矩阵的特征值 $\\lambda_k$ 和特征向量 $\\mathbf{v}_k$ 满足 $H \\mathbf{v}_k = \\lambda_k \\mathbf{v}_k$，其中 $\\{\\mathbf{v}_k\\}$ 是标准正交的。\n- 在原子模拟中，过渡态是一个一阶鞍点，意味着其 Hessian 矩阵恰好有一个严格为负的特征值。\n- 在离散路径 $\\{\\mathbf{x}_0,\\mathbf{x}_1,\\mathbf{x}_2\\}$ 中，索引为 $m$ 的镜像处的 NEB 路径切线可通过归一化差分近似：$\\mathbf{t} = \\frac{\\mathbf{x}_{m+1} - \\mathbf{x}_{m-1}}{\\|\\mathbf{x}_{m+1} - \\mathbf{x}_{m-1}\\|}$。\n\n您必须实现一个用于偏导数的对称中心有限差分近似，并使用均匀步长 $h$ 来数值计算 Hessian 矩阵。使用一个负值容差 $\\tau$ 来对特征值进行分类：如果特征值 $\\lambda  -\\tau$，则计为负；如果 $\\lambda  \\tau$，则计为正；否则视为数值上为零。报告最小负特征值对应的特征向量与 NEB 切线之间的夹角（以弧度为单位），并报告该特征向量相对于切线的带符号平行分量和垂直分量的范数。夹角应在方向之间计算（忽略总体符号），即在余弦计算中使用点积的绝对值，并以弧度表示。\n\n测试套件：\n- 情况 1 (理想情况): $E_1(x_1,x_2) = (x_1^2 - 1)^2 + 0.5\\,x_2^2$。离散路径镜像为 $\\mathbf{x}_0 = (-1,0)$，$\\mathbf{x}_1 = (0,0)$ 和 $\\mathbf{x}_2 = (1,0)$。使用 $h = 10^{-4}$ 和 $\\tau = 10^{-8}$。\n- 情况 2 (非过渡态的最大值点): $E_2(x_1,x_2) = -x_1^2 - x_2^2 + 0.1\\,(x_1^4 + x_2^4)$。离散路径镜像为 $\\mathbf{x}_0 = (-0.1,0)$，$\\mathbf{x}_1 = (0,0)$ 和 $\\mathbf{x}_2 = (0.1,0)$。使用 $h = 10^{-4}$ 和 $\\tau = 10^{-8}$。\n- 情况 3 (近简并的平坦方向): $E_3(x_1,x_2) = (x_1^2 - 1)^2 + \\epsilon\\,x_2^4$ 其中 $\\epsilon = 10^{-6}$。离散路径镜像为 $\\mathbf{x}_0 = (-1,0)$，$\\mathbf{x}_1 = (0,0)$ 和 $\\mathbf{x}_2 = (1,0)$。使用 $h = 10^{-4}$ 和 $\\tau = 10^{-8}$。\n\n对于每种情况，在中心镜像 $\\mathbf{x}_1$ 处执行以下操作：\n- 使用步长为 $h$ 的对称中心有限差分法，数值计算完整的 Hessian 矩阵 $H(\\mathbf{x}_1)$。\n- 计算 $H(\\mathbf{x}_1)$ 的所有特征值和特征向量。\n- 使用 $\\tau$ 验证单一负特征值判据，并返回一个布尔值，指示该判据是否成立。\n- 根据给定的相邻镜像计算 $\\mathbf{x}_1$ 处的 NEB 切线 $\\mathbf{t}$ 并将其归一化。\n- 选择与最小负特征值（即最小的特征值）对应的特征向量 $\\mathbf{v}_{\\min}$。计算由 $\\mathbf{v}_{\\min}$ 和 $\\mathbf{t}$ 所张成的方向之间的夹角 $\\theta$（以弧度为单位），带符号的平行分量 $c_{\\parallel} = \\mathbf{v}_{\\min} \\cdot \\mathbf{t}$，以及垂直分量的范数 $c_{\\perp} = \\|\\mathbf{v}_{\\min} - c_{\\parallel}\\,\\mathbf{t}\\|$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素按顺序对应一种情况。每种情况的结果必须是一个列表，结构为 $[\\text{布尔值}, \\theta, c_{\\parallel}, c_{\\perp}]$，其中角度 $\\theta$ 以弧度为单位。\n- 格式示例: $[[\\text{True}, 0.123, 0.456, 0.789],[\\text{False}, 0.321, -0.654, 0.987],[\\text{True}, 0.000, 1.000, 0.000]]$。\n\n所有量均为无量纲；角度以弧度表示。不需要外部输入；请完全按照上述规定在您的程序中硬编码测试套件。",
            "solution": "该问题要求分析在二维势能面上通过微动弹性带 (NEB) 计算获得的候选鞍点。对于给定的三种情况，我们必须表征离散路径 $\\{\\mathbf{x}_0, \\mathbf{x}_1, \\mathbf{x}_2\\}$ 中心镜像 $\\mathbf{x}_1$ 处的驻点。这种表征涉及计算 Hessian 矩阵，分析其特征值以确定该点是否为一阶鞍点（过渡态），并量化不稳定模式与反应路径切线的对齐程度。\n\n每种情况的步骤如下：\n\n1.  **Hessian 矩阵的数值计算**\n\n对于标量势能函数 $E(\\mathbf{x})$（其中 $\\mathbf{x} = (x_1, x_2)$），其 Hessian 矩阵 $H$ 是一个 $2 \\times 2$ 的二阶偏导数矩阵：\n$$\nH(\\mathbf{x}) = \\begin{pmatrix}\n\\frac{\\partial^2 E}{\\partial x_1^2}  \\frac{\\partial^2 E}{\\partial x_1 \\partial x_2} \\\\\n\\frac{\\partial^2 E}{\\partial x_2 \\partial x_1}  \\frac{\\partial^2 E}{\\partial x_2^2}\n\\end{pmatrix}\n$$\n由于势能函数是连续可微的，Hessian 矩阵是对称的，即 $\\frac{\\partial^2 E}{\\partial x_1 \\partial x_2} = \\frac{\\partial^2 E}{\\partial x_2 \\partial x_1}$。我们的任务是使用步长为 $h$ 的对称中心有限差分格式，在中心镜像 $\\mathbf{x}_1 = (x_{1,1}, x_{2,1})$ 处计算该矩阵。各分量的公式如下：\n\n-   对角元素：\n    $$\n    H_{11} = \\frac{\\partial^2 E}{\\partial x_1^2} \\approx \\frac{E(x_{1,1}+h, x_{2,1}) - 2E(x_{1,1}, x_{2,1}) + E(x_{1,1}-h, x_{2,1})}{h^2}\n    $$\n    $$\n    H_{22} = \\frac{\\partial^2 E}{\\partial x_2^2} \\approx \\frac{E(x_{1,1}, x_{2,1}+h) - 2E(x_{1,1}, x_{2,1}) + E(x_{1,1}, x_{2,1}-h)}{h^2}\n    $$\n-   非对角元素：\n    $$\n    H_{12} = H_{21} = \\frac{\\partial^2 E}{\\partial x_1 \\partial x_2} \\approx \\frac{E(x_{1,1}+h, x_{2,1}+h) - E(x_{1,1}+h, x_{2,1}-h) - E(x_{1,1}-h, x_{2,1}+h) + E(x_{1,1}-h, x_{2,1}-h)}{4h^2}\n    $$\n在每个测试案例中，这些近似公式将应用于特定能量函数 $E(x_1, x_2)$ 在点 $\\mathbf{x}_1$ 处的计算。\n\n2.  **特征值分析与鞍点分类**\n\n一旦数值 Hessian 矩阵 $H(\\mathbf{x}_1)$ 构建完成，我们求解特征值问题 $H \\mathbf{v}_k = \\lambda_k \\mathbf{v}_k$ 以找到其特征值 $\\lambda_k$ 和对应的特征向量 $\\mathbf{v}_k$。对于一个对称的 $2 \\times 2$ Hessian 矩阵，我们将获得两个实数特征值 $\\lambda_1$ 和 $\\lambda_2$。\n\n过渡态（或一阶鞍点）的特征是恰好有一个负特征值。我们使用提供的负值容差 $\\tau$ 来进行此分类。一个特征值 $\\lambda$ 被计为负，当且仅当 $\\lambda  -\\tau$。我们计算此类负特征值的数量。如果数量恰好为一个，则点 $\\mathbf{x}_1$ 被分类为过渡态。\n\n3.  **不稳定模式与路径切线分析**\n\n如果该点是鞍点，则对应于单一负特征值的特征向量代表了“不稳定模式”的方向——即离开鞍点的最低能垒方向。我们将此特征向量表示为 $\\mathbf{v}_{\\min}$。\n\n中心镜像 $\\mathbf{x}_1$ 处的 NEB 路径切线提供了反应路径方向的近似。它使用相邻镜像 $\\mathbf{x}_0$ 和 $\\mathbf{x}_2$ 计算得出：\n$$\n\\mathbf{t} = \\frac{\\mathbf{x}_2 - \\mathbf{x}_0}{\\|\\mathbf{x}_2 - \\mathbf{x}_0\\|}\n$$\n切向量 $\\mathbf{t}$ 被归一化为单位向量。\n\n最后，我们量化不稳定模式 $\\mathbf{v}_{\\min}$ 和路径切线 $\\mathbf{t}$ 之间的关系。$\\mathbf{v}_{\\min}$（由标准特征求解器返回）和 $\\mathbf{t}$ 都是单位向量。\n\n-   **夹角 $\\theta$**：计算两个向量方向之间的夹角。为确保角度在 $0$ 和 $\\pi/2$ 弧度之间（即我们比较的是方向，而不是具有任意符号的具体向量），我们使用点积的绝对值：\n    $$\n    \\theta = \\arccos(|\\mathbf{v}_{\\min} \\cdot \\mathbf{t}|)\n    $$\n-   **带符号平行分量 $c_{\\parallel}$**：它测量 $\\mathbf{v}_{\\min}$ 在 $\\mathbf{t}$ 上的投影。由于 $\\mathbf{t}$ 是单位向量，这即是点积：\n    $$\n    c_{\\parallel} = \\mathbf{v}_{\\min} \\cdot \\mathbf{t}\n    $$\n    $c_{\\parallel}$ 的符号取决于数值求解器返回的特征向量的任意符号约定。\n-   **垂直分量范数 $c_{\\perp}$**：它测量 $\\mathbf{v}_{\\min}$ 中与切线 $\\mathbf{t}$ 正交的分量的大小。它被计算为向量差的范数：\n    $$\n    c_{\\perp} = \\|\\mathbf{v}_{\\min} - c_{\\parallel} \\mathbf{t}\\|\n    $$\n通过将此完整过程应用于三个测试案例中的每一个，我们可以验证候选鞍点的性质以及 NEB 路径对齐的质量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by analyzing candidate saddle points for three test cases.\n    \"\"\"\n\n    def compute_hessian(E, x, h):\n        \"\"\"\n        Computes the Hessian matrix of a 2D scalar function E at point x\n        using symmetric central finite differences with step size h.\n        \"\"\"\n        x1, x2 = x\n        \n        # Second derivative with respect to x1\n        H11 = (E(x1 + h, x2) - 2 * E(x1, x2) + E(x1 - h, x2)) / (h**2)\n        \n        # Second derivative with respect to x2\n        H22 = (E(x1, x2 + h) - 2 * E(x1, x2) + E(x1, x2 - h)) / (h**2)\n        \n        # Mixed partial derivative\n        H12 = (E(x1 + h, x2 + h) - E(x1 + h, x2 - h) - E(x1 - h, x2 + h) + E(x1 - h, x2 - h)) / (4 * h**2)\n        \n        # Hessian is symmetric, H21 = H12\n        return np.array([[H11, H12], [H12, H22]])\n\n    def analyze_saddle(E, path, h, tau):\n        \"\"\"\n        Performs the full analysis for a given potential and path.\n        \"\"\"\n        x0, x1, x2 = path\n        \n        # 1. Compute the Hessian at the central image x1\n        H = compute_hessian(E, x1, h)\n        \n        # 2. Compute eigenvalues and eigenvectors.\n        # numpy.linalg.eigh is used for symmetric matrices. It returns eigenvalues\n        # in ascending order and corresponding eigenvectors as columns.\n        eigenvalues, eigenvectors = np.linalg.eigh(H)\n        \n        # 3. Verify the single negative eigenvalue criterion\n        num_negative_eigenvalues = np.sum(eigenvalues  -tau)\n        is_transition_state = (num_negative_eigenvalues == 1)\n        \n        # 4. Compute the NEB tangent at x1\n        tangent_raw = x2 - x0\n        tangent = tangent_raw / np.linalg.norm(tangent_raw)\n        \n        # 5. Select the eigenvector for the most negative eigenvalue\n        # This corresponds to the first eigenvalue/eigenvector from eigh.\n        v_min = eigenvectors[:, 0]\n        \n        # 6. Compute angle, parallel, and perpendicular components\n        # Angle between directions (using abs of dot product)\n        dot_product = np.dot(v_min, tangent)\n        \n        # Handle potential floating point inaccuracies for arccos\n        # Clamp the argument to the valid range [-1, 1]\n        angle_arg = np.clip(np.abs(dot_product), -1.0, 1.0)\n        theta = np.arccos(angle_arg)\n        \n        # Signed parallel component\n        c_parallel = dot_product\n        \n        # Perpendicular component norm\n        c_perpendicular = np.linalg.norm(v_min - c_parallel * tangent)\n        \n        return [is_transition_state, theta, c_parallel, c_perpendicular]\n\n    # Test suite parameters\n    h = 1e-4\n    tau = 1e-8\n    \n    test_cases = [\n        {\n            \"E\": lambda x1, x2: (x1**2 - 1)**2 + 0.5 * x2**2,\n            \"path\": (np.array([-1.0, 0.0]), np.array([0.0, 0.0]), np.array([1.0, 0.0])),\n        },\n        {\n            \"E\": lambda x1, x2: -x1**2 - x2**2 + 0.1 * (x1**4 + x2**4),\n            \"path\": (np.array([-0.1, 0.0]), np.array([0.0, 0.0]), np.array([0.1, 0.0])),\n        },\n        {\n            \"E\": lambda x1, x2: (x1**2 - 1)**2 + 1e-6 * x2**4,\n            \"path\": (np.array([-1.0, 0.0]), np.array([0.0, 0.0]), np.array([1.0, 0.0])),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_saddle(case[\"E\"], case[\"path\"], h, tau)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() of a list automatically includes brackets and commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}