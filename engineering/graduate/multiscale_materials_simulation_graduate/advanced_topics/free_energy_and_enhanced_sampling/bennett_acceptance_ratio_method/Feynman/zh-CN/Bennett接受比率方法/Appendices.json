{
    "hands_on_practices": [
        {
            "introduction": "Bennett验收比（BAR）方法的核心是一个涉及费米函数 $f(x) = (1 + \\exp(x))^{-1}$ 的方程。直接计算这个函数可能会遇到数值不稳定的问题，尤其当 $x$ 是一个较大的正数时，$\\exp(x)$ 的值可能会超出标准浮点数的表示范围，导致上溢。本练习旨在通过一个简单的代数变换，教会您如何编写一个在数值上稳定的费米函数实现，这是构建任何可靠的科学计算程序的基石。",
            "id": "2463465",
            "problem": "给定在计算化学中用于计算自由能差的 Bennett 接受比方法（BAR, Bennett acceptance ratio method）中出现的费米函数 $f(x)$ 的定义：\n$$\nf(x) = \\frac{1}{1 + e^{x}}.\n$$\n在标准双精度浮点运算中，对于大的正数 $x$，直接计算 $e^{x}$ 可能导致上溢；对于大的负数 $x$，则可能导致严重的下溢。您的任务是使用双精度算术，为所有实数 $x$ 实现一个数值稳定的 $f(x)$ 计算方法。您的实现必须对所有实数输入 $x$ 返回一个在 $[0,1]$ 区间内的有限结果。\n\n实现一个程序，该程序：\n- 在双精度算术下，使用数值稳定的方案计算如上定义的 $f(x)$。\n- 将此计算应用于以下有序的测试输入集：\n  - $x \\in \\{-1000,\\,-745,\\,-100,\\,-50,\\,-10^{-12},\\,0,\\,10^{-12},\\,50,\\,100,\\,709,\\,710,\\,1000\\}$。\n- 以与输入完全相同的顺序生成 $f(x)$ 的结果。\n\n要求和输出规范：\n- 所有计算均使用双精度算术。\n- 最终的程序输出必须是单行，包含一个用方括号括起来的逗号分隔列表，其中的值按测试输入的顺序排列。例如，要求的格式为“[result1,result2,result3,...]”。\n- 输出为实数（浮点值）。本问题不涉及物理单位。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表（例如，“[result1,result2,result3]”）。",
            "solution": "提交问题陈述以进行验证。\n\n步骤 1：提取已知信息\n-   函数定义：费米函数为 $f(x) = \\frac{1}{1 + e^{x}}$。\n-   数值挑战：对 $e^{x}$ 的标准双精度计算可能因大的正数 $x$ 而导致上溢，因大的负数 $x$ 而导致下溢。\n-   任务：实现一个数值稳定的方法来计算所有实数 $x$ 的 $f(x)$，该方法返回一个在区间 $[0, 1]$ 内的有限值。\n-   测试输入：$x \\in \\{-1000,\\,-745,\\,-100,\\,-50,\\,-10^{-12},\\,0,\\,10^{-12},\\,50,\\,100,\\,709,\\,710,\\,1000\\}$。\n-   计算精度：双精度算术。\n-   输出格式：单行，结果为用方括号括起来的逗号分隔列表。\n\n步骤 2：使用提取的已知信息进行验证\n对问题进行严格审查。\n-   **科学依据**：该问题在数值分析和计算科学领域有充分的依据。费米函数（或逻辑斯谛 S 型函数）是基础函数，在其直接计算中可能出现的浮点数上溢和下溢是科学计算中一个经典且无争议的问题。指定的输入值，如 $709$ 和 $710$，被正确地选择用于探测标准 64 位双精度算术中 $e^x$ 的上溢边界，其上溢阈值约为 $x \\approx 709.78$。\n-   **适定性**：该问题是适定的。它要求实现一个算法来克服一个特定且明确定义的数值不稳定性。通过标准的数值技术可以获得唯一且稳定的解。\n-   **客观性**：该问题以精确、客观且无歧义的术语陈述。它不包含任何主观或基于意见的内容。\n\n步骤 3：结论与行动\n问题被判定为**有效**。这是数值编程中的一个标准练习，既科学合理又规定明确。开始求解。\n\n一个鲁棒的解法需要分析函数的行为以及浮点运算的局限性。函数由下式给出：\n$$\nf(x) = \\frac{1}{1 + e^{x}}\n$$\n我们针对输入变量 $x$ 的不同区间来分析该表达式的数值稳定性。\n\n情况 1：$x$ 是大的正数。\n对于大的正数 $x$，$e^x$ 项会指数级增长。在标准的 IEEE 754 双精度算术中，可表示的最大有限值约为 $1.8 \\times 10^{308}$。当 $x > \\ln(1.8 \\times 10^{308}) \\approx 709.78$ 时，指数函数 $e^x$ 将会发生上溢。对于像 $710$ 或 $1000$ 这样的 $x$ 值进行直接计算，会导致一个中间的无穷大值，这是一种不良的数值实践，即使浮点单元根据其对 `inf` 的处理规则最终能正确地解析出结果 $0$。\n\n为了创建一个稳定的算法，我们必须重构表达式以避免在 $x$ 为正数时计算 $e^x$。我们可以将分子和分母同乘以 $e^{-x}$：\n$$\nf(x) = \\frac{1}{1 + e^{x}} = \\frac{e^{-x}}{e^{-x}(1 + e^{x})} = \\frac{e^{-x}}{e^{-x} + 1}\n$$\n在这个替代形式中，如果 $x$ 是正数，那么 $-x$ 就是负数。计算 $e^{-x}$ 将得到一个介于 $0$ 和 $1$ 之间的值，从而防止上溢。对于 $x \\ge 0$，这种形式是数值稳定的。\n\n情况 2：$x$ 是大的负数。\n对于大的负数 $x$，$e^x$ 项趋近于 $0$。在双精度下，当 $x  \\ln(2.2 \\times 10^{-308}) \\approx -708.4$ 时，$e^x$ 将下溢为精确的 $0$。在这种情况下，直接计算 $f(x) = \\frac{1}{1 + e^x}$ 变为 $\\frac{1}{1 + 0} = 1$。这个计算是数值稳定的，并能给出正确的极限值。不存在上溢或灾难性抵消的风险。\n\n情况 3：$x$ 接近 0。\n对于 $x=0$，两种形式都得到 $f(0) = \\frac{1}{1+e^0} = \\frac{1}{2}$，这是稳定的。\n\n基于此分析，一个根据 $x$ 的符号选择合适公式的混合算法，可以在整个实数轴上提供完全的数值稳定性。\n\n提出的稳定算法如下：\n-   如果 $x  0$，使用原始形式：$f(x) = \\frac{1}{1 + e^x}$。指数函数的参数是负数，确保了稳定性。\n-   如果 $x \\ge 0$，使用代数等价形式：$f(x) = \\frac{e^{-x}}{1 + e^{-x}}$。指数函数的参数是非正数，同样确保了稳定性。\n\n这种策略保证了传递给指数函数的参数总是小于或等于零，从而鲁棒地防止上溢，并为任何实数输入 $x$ 产生有限的结果。现在将此实现应用于所提供的测试输入集。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Fermi function f(x) = 1/(1 + exp(x)) for a given set of\n    test inputs using a numerically stable scheme. The final results are\n    printed in the specified format.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        -1000.0,\n        -745.0,\n        -100.0,\n        -50.0,\n        -1.0e-12,\n        0.0,\n        1.0e-12,\n        50.0,\n        100.0,\n        709.0,\n        710.0,\n        1000.0\n    ]\n\n    def stable_fermi(x: float) - float:\n        \"\"\"\n        Calculates the Fermi function f(x) = 1 / (1 + exp(x)) in a\n        numerically stable manner.\n\n        The method switches between two algebraically equivalent forms of the\n        function based on the sign of x to prevent floating-point overflow.\n\n        Args:\n            x: A real number (float).\n\n        Returns:\n            The value of f(x) as a float.\n        \"\"\"\n        # For x  0, the argument to exp(x) is negative, so the direct\n        # evaluation is stable and does not risk overflow.\n        if x  0.0:\n            return 1.0 / (1.0 + np.exp(x))\n        else:\n            # For x >= 0, exp(x) can overflow for large x.\n            # We use the equivalent form f(x) = exp(-x) / (1 + exp(-x)).\n            # The argument to the exponential, -x, is non-positive,\n            # which prevents overflow.\n            exp_neg_x = np.exp(-x)\n            return exp_neg_x / (1.0 + exp_neg_x)\n\n    # Calculate the results for all test cases.\n    results = [stable_fermi(x) for x in test_cases]\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) is used to format numbers without trailing zeros\n    # for cleaner representation, though standard float conversion is sufficient.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论上，BAR 估计量在样本量趋于无穷时是无偏的，并且具有最小方差。然而，在实际应用中，我们总是处理有限的样本，这会引入统计误差和潜在的偏差，尤其是在样本量很小的情况下。本练习通过一个简单的一维谐振子模型——其自由能差 $\\Delta F$ 具有精确的解析解——让您亲手计算并观察这种偏差。通过比较模拟估计值与精确值，您将对估计量的统计特性有更深刻和直观的理解。",
            "id": "2463439",
            "problem": "给定两个经典一维谐振子态，分别记为态 $\\mathrm{A}$ 和态 $\\mathrm{B}$。对于构型 $x \\in \\mathbb{R}$，其在态 $\\mathrm{A}$ 中的约化势能（以玻尔兹曼常数与温度的乘积 $k_{\\mathrm{B}}T$ 为单位）为 $u_{\\mathrm{A}}(x) = \\tfrac{1}{2} k_{\\mathrm{A}} (x - \\mu_{\\mathrm{A}})^{2}$，在态 $\\mathrm{B}$ 中的约化势能为 $u_{\\mathrm{B}}(x) = \\tfrac{1}{2} k_{\\mathrm{B}} (x - \\mu_{\\mathrm{B}})^{2}$。假设逆温为 $\\beta = 1$，因此所有能量都是以 $k_{\\mathrm{B}}T$ 为单位的无量纲量。对于此类谐振子，态 $\\mathrm{X} \\in \\{\\mathrm{A},\\mathrm{B}\\}$ 的经典构型配分函数为 $Z_{\\mathrm{X}} = \\int_{-\\infty}^{\\infty} \\exp\\!\\left(-u_{\\mathrm{X}}(x)\\right)\\,\\mathrm{d}x = \\sqrt{\\tfrac{2\\pi}{k_{\\mathrm{X}}}}$，约化自由能为 $F_{\\mathrm{X}} = -\\ln Z_{\\mathrm{X}}$。因此，精确的约化自由能差为 $\\Delta F_{\\mathrm{exact}} = F_{\\mathrm{B}} - F_{\\mathrm{A}} = \\tfrac{1}{2}\\ln\\!\\left(\\tfrac{k_{\\mathrm{B}}}{k_{\\mathrm{A}}}\\right)$。\n\n假设您从态 $\\mathrm{A}$ 的正则分布中独立抽样 $N_{\\mathrm{A}}$ 个构型 $\\{x_{i}\\}_{i=1}^{N_{\\mathrm{A}}}$，并从态 $\\mathrm{B}$ 的正则分布中独立抽样 $N_{\\mathrm{B}}$ 个构型 $\\{y_{j}\\}_{j=1}^{N_{\\mathrm{B}}}$。对于在 $\\beta=1$ 条件下，$u_{\\mathrm{X}}(x) = \\tfrac{1}{2} k_{\\mathrm{X}} (x - \\mu_{\\mathrm{X}})^{2}$ 的一维谐振子，在态 $\\mathrm{X}$ 中 $x$ 的平衡分布是均值为 $\\mu_{\\mathrm{X}}$、方差为 $1/k_{\\mathrm{X}}$ 的高斯分布。定义约化能量差 $\\Delta u_{i} = u_{\\mathrm{B}}(x_{i}) - u_{\\mathrm{A}}(x_{i})$（其中 $i \\in \\{1,\\dots,N_{\\mathrm{A}}\\}$）和 $\\Delta u'_{j} = u_{\\mathrm{A}}(y_{j}) - u_{\\mathrm{B}}(y_{j})$（其中 $j \\in \\{1,\\dots,N_{\\mathrm{B}}\\}$）。\n\nBennett 接受率 (BAR) 估计器将约化自由能差 $\\Delta F$ 的估计值 $\\widehat{\\Delta f}$ 定义为以下方程的唯一解：\n$$\n\\sum_{i=1}^{N_{\\mathrm{A}}} \\frac{1}{1 + \\exp\\!\\left(\\Delta u_{i} - \\widehat{\\Delta f} + \\ln\\!\\left(\\tfrac{N_{\\mathrm{A}}}{N_{\\mathrm{B}}}\\right)\\right)} \\;=\\;\n\\sum_{j=1}^{N_{\\mathrm{B}}} \\frac{1}{1 + \\exp\\!\\left(\\Delta u'_{j} + \\widehat{\\Delta f} - \\ln\\!\\left(\\tfrac{N_{\\mathrm{A}}}{N_{\\mathrm{B}}}\\right)\\right)} \\, .\n$$\n对于样本的一次实现，将偏差定义为 $b = \\widehat{\\Delta f} - \\Delta F_{\\mathrm{exact}}$。\n\n您的任务是为以下每个测试用例计算偏差 $b$。所有量均为无量纲（以 $k_{\\mathrm{B}}T$ 为单位）。对于每个用例，使用指定的随机种子从指定的高斯平衡分布中抽取独立样本，根据上述 BAR 方程计算 $\\widehat{\\Delta f}$，并报告四舍五入到 6 位小数的 $b$ 值。\n\n测试套件（每个元组为 $(k_{\\mathrm{A}}, \\mu_{\\mathrm{A}}, k_{\\mathrm{B}}, \\mu_{\\mathrm{B}}, N_{\\mathrm{A}}, N_{\\mathrm{B}}, \\text{seed})$）：\n- 用例 1：$(1.0, 0.0, 2.0, 0.0, 8, 8, 12345)$\n- 用例 2：$(1.0, 0.0, 1.0, 3.0, 5, 5, 54321)$\n- 用例 3：$(0.5, -1.0, 5.0, 1.0, 4, 4, 2024)$\n- 用例 4：$(1.0, 0.0, 3.0, 0.0, 2, 9, 777)$\n- 用例 5：$(1.0, 0.0, 1.0, 0.0, 1, 1, 999)$\n\n您的程序必须生成单行输出，其中包含一个逗号分隔的列表，按用例顺序列出五个偏差值，并用方括号括起来，例如 $[\\text{bias}_{1},\\text{bias}_{2},\\text{bias}_{3},\\text{bias}_{4},\\text{bias}_{5}]$，每个 $\\text{bias}_{i}$ 都四舍五入到 6 位小数。输出值为无量纲。不应打印任何其他文本。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它提出了一个在统计力学领域内适定的、有科学依据的计算问题。模型系统（经典一维谐振子）和方法论（Bennett 接受率，BAR）都是标准的，并且描述正确。所有参数和过程都已明确定义，确保问题是自洽的，并允许一个唯一的、可验证的解。我们将着手进行计算。\n\n任务是为五个不同的用例计算 BAR 自由能估计器的偏差 $b = \\widehat{\\Delta f} - \\Delta F_{\\mathrm{exact}}$。估计值 $\\widehat{\\Delta f}$ 是从模拟数据计算出的自由能差，而 $\\Delta F_{\\mathrm{exact}}$ 是解析值。\n\n首先，我们确定解析量。两个态 $\\mathrm{A}$ 和 $\\mathrm{B}$ 的约化势能由下式给出：\n$$\nu_{\\mathrm{A}}(x) = \\frac{1}{2} k_{\\mathrm{A}} (x - \\mu_{\\mathrm{A}})^{2}\n$$\n$$\nu_{\\mathrm{B}}(x) = \\frac{1}{2} k_{\\mathrm{B}} (x - \\mu_{\\mathrm{B}})^{2}\n$$\n这些态之间的精确约化自由能差为：\n$$\n\\Delta F_{\\mathrm{exact}} = F_{\\mathrm{B}} - F_{\\mathrm{A}} = \\frac{1}{2}\\ln\\!\\left(\\frac{k_{\\mathrm{B}}}{k_{\\mathrm{A}}}\\right)\n$$\n该公式源自谐振子的经典配分函数，并将用作计算偏差的参考值。\n\n计算过程涉及生成有限的构型样本。对于态 $\\mathrm{A}$，从其正则分布中抽取 $N_{\\mathrm{A}}$ 个构型 $\\{x_i\\}_{i=1}^{N_{\\mathrm{A}}}$。对于谐振子，此分布是均值为 $\\mu_{\\mathrm{A}}$、方差为 $\\sigma^2_{\\mathrm{A}} = 1/k_{\\mathrm{A}}$ 的高斯分布。类似地，对于态 $\\mathrm{B}$，从均值为 $\\mu_{\\mathrm{B}}$、方差为 $\\sigma^2_{\\mathrm{B}} = 1/k_{\\mathrm{B}}$ 的高斯分布中抽取 $N_{\\mathrm{B}}$ 个构型 $\\{y_j\\}_{j=1}^{N_{\\mathrm{B}}}$。将使用指定的种子生成随机样本，以确保可复现性。\n\n获得样本后，我们计算功值。正向功值是在来自态 $\\mathrm{A}$ 的样本上评估的能量差：\n$$\n\\Delta u_{i} = u_{\\mathrm{B}}(x_{i}) - u_{\\mathrm{A}}(x_{i}), \\quad i = 1, \\dots, N_{\\mathrm{A}}\n$$\n反向功值是在来自态 $\\mathrm{B}$ 的样本上评估的：\n$$\n\\Delta u'_{j} = u_{\\mathrm{A}}(y_{j}) - u_{\\mathrm{B}}(y_{j}), \\quad j = 1, \\dots, N_{\\mathrm{B}}\n$$\n\n自由能差的 BAR 估计值 $\\widehat{\\Delta f}$ 是以下隐式方程的解：\n$$\n\\sum_{i=1}^{N_{\\mathrm{A}}} \\frac{1}{1 + \\exp\\!\\left(\\Delta u_{i} - \\widehat{\\Delta f} + C \\right)} = \\sum_{j=1}^{N_{\\mathrm{B}}} \\frac{1}{1 + \\exp\\!\\left(\\Delta u'_{j} + \\widehat{\\Delta f} - C \\right)}\n$$\n其中 $C = \\ln(N_{\\mathrm{A}}/N_{\\mathrm{B}})$。为了找到 $\\widehat{\\Delta f}$，我们将函数 $G(\\widehat{\\Delta f})$ 定义为方程左侧 (LHS) 和右侧 (RHS) 之间的差，该差必须等于零：\n$$\nG(\\widehat{\\Delta f}) = \\sum_{i=1}^{N_{\\mathrm{A}}} \\frac{1}{1 + \\exp\\!\\left(\\Delta u_{i} - \\widehat{\\Delta f} + C \\right)} - \\sum_{j=1}^{N_{\\mathrm{B}}} \\frac{1}{1 + \\exp\\!\\left(\\Delta u'_{j} + \\widehat{\\Delta f} - C \\right)} = 0\n$$\n函数 $G(\\widehat{\\Delta f})$ 是严格单调的。其关于 $\\widehat{\\Delta f}$ 的一阶导数为：\n$$\n\\frac{dG}{d\\widehat{\\Delta f}} = \\sum_{i=1}^{N_{\\mathrm{A}}} \\frac{\\exp(\\dots)}{(1+\\exp(\\dots))^2} + \\sum_{j=1}^{N_{\\mathrm{B}}} \\frac{\\exp(\\dots)}{(1+\\exp(\\dots))^2}\n$$\n其中指数函数的参数与 $G(\\widehat{\\Delta f})$ 定义中的相同。由于该导数是严格正项之和，$G(\\widehat{\\Delta f})$ 是 $\\widehat{\\Delta f}$ 的一个严格增函数。此性质，加上 $G(\\widehat{\\Delta f})$ 在 $\\widehat{\\Delta f} \\to -\\infty$ 时渐近于 $-N_{\\mathrm{B}}$ 并在 $\\widehat{\\Delta f} \\to +\\infty$ 时渐近于 $N_{\\mathrm{A}}$ 的事实，保证了唯一根的存在。将使用鲁棒算法，特别是 Brent-Dekker 方法（来自 SciPy 库的 `brentq`），以数值方式找到此根，该方法对于有界单调函数是高效且可靠的。\n\n对于每个测试用例，将以编程方式执行以下步骤：\n1.  设置随机数生成器种子。\n2.  从 $N(\\mu_{\\mathrm{A}}, 1/k_{\\mathrm{A}})$ 生成 $N_{\\mathrm{A}}$ 个样本，并从 $N(\\mu_{\\mathrm{B}}, 1/k_{\\mathrm{B}})$ 生成 $N_{\\mathrm{B}}$ 个样本。\n3.  计算 $\\Delta u_i$ 和 $\\Delta u'_j$ 的数组。\n4.  对 $\\widehat{\\Delta f}$ 数值求解 $G(\\widehat{\\Delta f}) = 0$。\n5.  计算 $\\Delta F_{\\mathrm{exact}} = \\frac{1}{2} \\ln(k_{\\mathrm{B}}/k_{\\mathrm{A}})$。\n6.  计算偏差 $b = \\widehat{\\Delta f} - \\Delta F_{\\mathrm{exact}}$。\n7.  按要求将每个用例的最终结果四舍五入到 6 位小数。然后将整套结果格式化为指定的列表格式。这个系统化过程将在提供的 Python 脚本中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Computes the bias of the Bennett Acceptance Ratio (BAR) estimator for a series of test cases\n    involving one-dimensional harmonic oscillators.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (kA, muA, kB, muB, NA, NB, seed)\n        (1.0, 0.0, 2.0, 0.0, 8, 8, 12345),\n        (1.0, 0.0, 1.0, 3.0, 5, 5, 54321),\n        (0.5, -1.0, 5.0, 1.0, 4, 4, 2024),\n        (1.0, 0.0, 3.0, 0.0, 2, 9, 777),\n        (1.0, 0.0, 1.0, 0.0, 1, 1, 999)\n    ]\n\n    results = []\n    for case in test_cases:\n        kA, muA, kB, muB, NA, NB, seed = case\n\n        # Set up random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Generate samples from equilibrium distributions\n        # State A: Gaussian with mean muA, variance 1/kA\n        std_dev_A = np.sqrt(1.0 / kA)\n        samples_A = rng.normal(loc=muA, scale=std_dev_A, size=NA)\n\n        # State B: Gaussian with mean muB, variance 1/kB\n        std_dev_B = np.sqrt(1.0 / kB)\n        samples_B = rng.normal(loc=muB, scale=std_dev_B, size=NB)\n\n        # Define reduced potential energy functions\n        def uA(x):\n            return 0.5 * kA * (x - muA)**2\n        \n        def uB(x):\n            return 0.5 * kB * (x - muB)**2\n\n        # Calculate energy differences (work values)\n        delta_u_fwd = uB(samples_A) - uA(samples_A)\n        delta_u_rev = uA(samples_B) - uB(samples_B)\n        \n        # Constant term in the BAR equation exponent\n        log_N_ratio = np.log(NA / NB)\n\n        # Define the function whose root is the BAR estimate df_hat\n        def bar_equation(df_hat):\n            \"\"\"\n            Represents the BAR equation in the form G(df_hat) = 0.\n            \"\"\"\n            # Term for forward samples (A - B)\n            arg_fwd = delta_u_fwd - df_hat + log_N_ratio\n            sum_fwd = np.sum(1.0 / (1.0 + np.exp(arg_fwd)))\n            \n            # Term for reverse samples (B - A)\n            arg_rev = delta_u_rev + df_hat - log_N_ratio\n            sum_rev = np.sum(1.0 / (1.0 + np.exp(arg_rev)))\n            \n            return sum_fwd - sum_rev\n\n        # Solve for df_hat using a numerical root finder.\n        # A wide bracket [-100, 100] is safe as the function is monotonic\n        # and crosses zero within this range for any reasonable inputs.\n        try:\n            df_hat = brentq(bar_equation, -100.0, 100.0)\n        except ValueError:\n            # This should not be reached due to the function's monotonic properties.\n            # Included for robustness in principle.\n            df_hat = np.nan\n\n        # Calculate exact free energy difference\n        df_exact = 0.5 * np.log(kB / kA)\n\n        # Calculate the bias\n        bias = df_hat - df_exact\n        \n        # Round to 6 decimal places and append to results list\n        results.append(round(bias, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了基本数值技巧和统计概念后，是时候将所有知识融会贯通，完成一个完整的自由能计算流程了。本练习将引导您为一个在二维势能面中运动的粒子实施完整的 BAR 方法。您需要从给定的玻尔兹曼分布中生成构象样本，计算必要的能量差，并最终求解 BAR 方程以获得自由能差，从而全面体验一个典型的计算化学研究任务。",
            "id": "2463503",
            "problem": "考虑一个在二维组态空间中运动的单粒子，其位置矢量为 $\\mathbf{r} = (x,y)$。对于给定的标量参数 $q$，其约化势能（即势能乘以逆热能，逆温度为 $\\beta$）定义为\n$$\nu(q;\\mathbf{r}) \\equiv \\beta U(q;\\mathbf{r}) = \\tfrac{1}{2} k \\left(x^2 + y^2\\right) - q \\, \\mathbf{E} \\cdot \\mathbf{r},\n$$\n其中 $k$ 是一个正标量弹性系数，$\\mathbf{E} = (E_x, E_y)$ 是一个固定的电场矢量。所有计算完全在 $\\beta = 1$ 的约化无量纲单位下进行，因此所有能量都是无量纲的；不使用也不需要物理单位。\n\n定义两个热力学态 $A$ 和 $B$，它们仅在标量参数 $q$ 的值上有所不同，分别记为 $q_A$ 和 $q_B$。相应的约化势能为 $u_A(\\mathbf{r}) = u(q_A;\\mathbf{r})$ 和 $u_B(\\mathbf{r}) = u(q_B;\\mathbf{r})$。令约化自由能差 $\\Delta f_{BA}$ 定义为\n$$\n\\Delta f_{BA} \\equiv f_B - f_A = -\\ln Z_B + \\ln Z_A,\n$$\n其中 $Z_A$ 和 $Z_B$ 分别是状态 $A$ 和 $B$ 的约化配分函数。\n\n给定从正比于 $\\exp\\{-u_A(\\mathbf{r})\\}$ 的归一化玻尔兹曼分布中抽取的独立同分布样本 $\\{\\mathbf{r}_i^{(A)}\\}_{i=1}^{N_A}$，以及从正比于 $\\exp\\{-u_B(\\mathbf{r})\\}$ 的归一化玻尔兹曼分布中抽取的独立同分布样本 $\\{\\mathbf{r}_j^{(B)}\\}_{j=1}^{N_B}$，Bennett接受率（BAR）方法将 $\\Delta f_{BA}$ 定义为以下方程的唯一解\n$$\n\\frac{1}{N_A} \\sum_{i=1}^{N_A} \\frac{1}{1+\\exp\\left(\\Delta u(\\mathbf{r}_i^{(A)}) - \\Delta f_{BA} - c\\right)} \\;=\\; \\frac{1}{N_B} \\sum_{j=1}^{N_B} \\frac{1}{1+\\exp\\left(-\\Delta u(\\mathbf{r}_j^{(B)}) + \\Delta f_{BA} + c\\right)},\n$$\n其中 $\\Delta u(\\mathbf{r}) \\equiv u_B(\\mathbf{r}) - u_A(\\mathbf{r})$ 且 $c \\equiv \\ln\\!\\left(\\frac{N_B}{N_A}\\right)$。\n\n您的任务是编写一个完整的、可运行的程序，该程序能够：\n- 对于下面指定的每个测试用例，使用指定的随机数生成器种子从对应于 $u_A(\\mathbf{r})$ 和 $u_B(\\mathbf{r})$ 的精确玻尔兹曼分布中生成所需的独立样本以保证可复现性。\n- 通过求解上述BAR定义方程来计算约化自由能差 $\\Delta f_{BA}$。\n- 在单行上生成所有测试用例的最终结果，其格式与本问题陈述末尾指定的完全一致。\n\n所有计算都必须在约化无量纲单位下进行。不涉及角度。所需的输出值为实数，必须以浮点值的形式报告，并精确到小数点后六位。\n\n测试套件：\n对于每个用例，给出参数 $(k, q_A, q_B, E_x, E_y, N_A, N_B, \\text{seed})$。\n\n- 用例 $1$：$(k, q_A, q_B, E_x, E_y, N_A, N_B, \\text{seed}) = (1.0, 0.0, 1.0, 0.8, -0.4, 20000, 20000, 12345)$。\n- 用例 $2$：$(k, q_A, q_B, E_x, E_y, N_A, N_B, \\text{seed}) = (1.0, 0.7, 0.7, 1.2, -0.3, 15000, 15000, 54321)$。\n- 用例 $3$：$(k, q_A, q_B, E_x, E_y, N_A, N_B, \\text{seed}) = (1.0, 0.5, 0.9, 1.0, 1.0, 5000, 20000, 2023)$。\n- 用例 $4$：$(k, q_A, q_B, E_x, E_y, N_A, N_B, \\text{seed}) = (2.0, -0.6, 0.4, 0.0, 0.0, 10000, 10000, 777)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个BAR估计的 $\\Delta f_{BA}$ 值的列表，按上述用例的顺序排列，格式为逗号分隔并用方括号括起。每个值必须四舍五入到小数点后六位。例如，输出必须具有以下形式：\n\"[v1,v2,v3,v4]\"\n其中每个 $v_i$ 是一个小数点后恰好有六位的浮点值。",
            "solution": "该问题要求使用Bennett接受率（BAR）方法计算两个热力学态 $A$ 和 $B$ 之间的约化自由能差 $\\Delta f_{BA}$。该系统由一个在二维势中的单粒子组成。在进行数值实现之前，必须对底层的物理模型和数值方法进行严格分析。\n\n首先，我们分析势能函数。由参数 $q$ 定义的状态的约化势能由下式给出：\n$$\nu(q;\\mathbf{r}) = \\tfrac{1}{2} k \\left(x^2 + y^2\\right) - q \\, \\mathbf{E} \\cdot \\mathbf{r}\n$$\n其中 $\\mathbf{r}=(x,y)$, $k0$, 且 $\\mathbf{E}=(E_x, E_y)$。为了理解系统的统计特性，我们必须确定玻尔兹曼分布 $p(\\mathbf{r}) \\propto \\exp(-u(q;\\mathbf{r}))$ 的形式。我们可以通过对 $x$ 和 $y$ 坐标进行配方来重写势能：\n$$\n\\begin{aligned}\nu(q;\\mathbf{r}) = \\left(\\tfrac{1}{2} k x^2 - q E_x x\\right) + \\left(\\tfrac{1}{2} k y^2 - q E_y y\\right) \\\\\n= \\tfrac{k}{2} \\left[x^2 - \\tfrac{2qE_x}{k} x\\right] + \\tfrac{k}{2} \\left[y^2 - \\tfrac{2qE_y}{k} y\\right] \\\\\n= \\tfrac{k}{2} \\left[\\left(x - \\tfrac{qE_x}{k}\\right)^2 - \\left(\\tfrac{qE_x}{k}\\right)^2\\right] + \\tfrac{k}{2} \\left[\\left(y - \\tfrac{qE_y}{k}\\right)^2 - \\left(\\tfrac{qE_y}{k}\\right)^2\\right] \\\\\n= \\tfrac{k}{2} \\left(x - \\tfrac{qE_x}{k}\\right)^2 + \\tfrac{k}{2} \\left(y - \\tfrac{qE_y}{k}\\right)^2 - \\tfrac{q^2}{2k}(E_x^2 + E_y^2)\n\\end{aligned}\n$$\n因此，概率密度函数为：\n$$\np(q;\\mathbf{r}) \\propto \\exp\\left\\{ -\\tfrac{k}{2} \\left[\\left(x - \\tfrac{qE_x}{k}\\right)^2 + \\left(y - \\tfrac{qE_y}{k}\\right)^2\\right] \\right\\}\n$$\n这是一个二元正态（高斯）分布 $\\mathcal{N}(\\boldsymbol{\\mu}(q), \\boldsymbol{\\Sigma})$ 的核。均值向量 $\\boldsymbol{\\mu}(q)$ 和协方差矩阵 $\\boldsymbol{\\Sigma}$ 可以通过将指数与标准形式 $-\\frac{1}{2}(\\mathbf{r}-\\boldsymbol{\\mu})^T \\boldsymbol{\\Sigma}^{-1} (\\mathbf{r}-\\boldsymbol{\\mu})$进行比较来确定。\n均值向量为：\n$$\n\\boldsymbol{\\mu}(q) = \\begin{pmatrix} \\mu_x(q) \\\\ \\mu_y(q) \\end{pmatrix} = \\begin{pmatrix} qE_x/k \\\\ qE_y/k \\end{pmatrix} = \\frac{q}{k}\\mathbf{E}\n$$\n协方差矩阵的逆是 $\\boldsymbol{\\Sigma}^{-1} = k \\mathbf{I}$，其中 $\\mathbf{I}$ 是 $2 \\times 2$ 的单位矩阵。因此，协方差矩阵是：\n$$\n\\boldsymbol{\\Sigma} = \\frac{1}{k}\\mathbf{I} = \\begin{pmatrix} 1/k  0 \\\\ 0  1/k \\end{pmatrix}\n$$\n该分析证明了粒子的位置 $(x,y)$ 服从一个二元正态分布，其分量不相关，每个分量的方差为 $\\sigma^2 = 1/k$。要为状态 $A$ 和 $B$ 生成所需的样本，必须分别从 $\\mathcal{N}(\\boldsymbol{\\mu}(q_A), \\boldsymbol{\\Sigma})$ 和 $\\mathcal{N}(\\boldsymbol{\\mu}(q_B), \\boldsymbol{\\Sigma})$ 中抽样。\n\n接下来，我们来处理BAR方程本身。该方程需要计算势能差 $\\Delta u(\\mathbf{r})$：\n$$\n\\Delta u(\\mathbf{r}) = u_B(\\mathbf{r}) - u_A(\\mathbf{r}) = u(q_B;\\mathbf{r}) - u(q_A;\\mathbf{r})\n$$\n$$\n\\Delta u(\\mathbf{r}) = \\left(\\tfrac{1}{2} k r^2 - q_B \\mathbf{E} \\cdot \\mathbf{r}\\right) - \\left(\\tfrac{1}{2} k r^2 - q_A \\mathbf{E} \\cdot \\mathbf{r}\\right) = -(q_B - q_A) \\mathbf{E} \\cdot \\mathbf{r}\n$$\n令 $\\Delta q = q_B - q_A$。则 $\\Delta u(\\mathbf{r}) = -\\Delta q \\, (\\mathbf{E} \\cdot \\mathbf{r})$。\n$\\Delta f_{BA}$ 的BAR方程为：\n$$\n\\left\\langle \\frac{1}{1+\\exp\\left(\\Delta u(\\mathbf{r}) - \\Delta f_{BA} - c\\right)} \\right\\rangle_A = \\left\\langle \\frac{1}{1+\\exp\\left(-\\Delta u(\\mathbf{r}) + \\Delta f_{BA} + c\\right)} \\right\\rangle_B\n$$\n其中 $\\langle \\cdot \\rangle_X$ 表示对从状态 $X$ 抽取的构型进行样本平均，且 $c = \\ln(N_B/N_A)$。这是一个关于未知数 $\\Delta f_{BA}$ 的非线性方程。我们可以定义一个目标函数 $g(\\Delta f)$，其根即为所求的解：\n$$\ng(\\Delta f) = \\frac{1}{N_A} \\sum_{i=1}^{N_A} \\frac{1}{1+e^{\\Delta u(\\mathbf{r}_i^{(A)}) - \\Delta f - c}} - \\frac{1}{N_B} \\sum_{j=1}^{N_B} \\frac{1}{1+e^{-\\Delta u(\\mathbf{r}_j^{(B)}) + \\Delta f + c}}\n$$\n函数 $g(\\Delta f)$ 是关于 $\\Delta f$ 的连续且严格单调递增函数。当 $\\Delta f \\to -\\infty$ 时，$g(\\Delta f) \\to -1$。当 $\\Delta f \\to +\\infty$ 时，$g(\\Delta f) \\to 1$。因此，保证存在一个唯一的根使得 $g(\\Delta f) = 0$。必须使用数值求根算法（如Brent方法）来找到这个根。\n\n对于这个具体问题，存在自由能差的解析解，它可以作为对数值结果的关键检验。约化配分函数 $Z(q)$ 是：\n$$\nZ(q) = \\int e^{-u(q;\\mathbf{r})} d\\mathbf{r} = e^{\\frac{q^2 E^2}{2k}} \\int \\int e^{-\\frac{k}{2}(x-\\mu_x)^2} e^{-\\frac{k}{2}(y-\\mu_y)^2} dx dy\n$$\n其中 $E^2 = |\\mathbf{E}|^2$。每个积分都是一个标准高斯积分，其值为 $\\sqrt{2\\pi/k}$。\n$$\nZ(q) = e^{\\frac{q^2 E^2}{2k}} \\left(\\frac{2\\pi}{k}\\right)\n$$\n约化自由能是 $f(q) = -\\ln Z(q) = -\\frac{q^2 E^2}{2k} - \\ln\\left(\\frac{2\\pi}{k}\\right)$。因此，精确的自由能差为：\n$$\n\\Delta f_{BA} = f(q_B) - f(q_A) = \\left[-\\frac{q_B^2 E^2}{2k} - \\ln\\left(\\frac{2\\pi}{k}\\right)\\right] - \\left[-\\frac{q_A^2 E^2}{2k} - \\ln\\left(\\frac{2\\pi}{k}\\right)\\right] = -\\frac{(q_B^2 - q_A^2)E^2}{2k}\n$$\n使用有限数量样本通过BAR方程数值估算出的 $\\Delta f_{BA}$ 应该是这个精确理论值的统计估计。\n\n计算流程如下：\n1. 对每个测试用例，设置参数 $(k, q_A, q_B, \\mathbf{E}, N_A, N_B)$ 和随机数生成器种子。\n2. 从 $\\mathcal{N}(\\boldsymbol{\\mu}(q_A), \\boldsymbol{\\Sigma})$ 生成 $N_A$ 个样本 $\\mathbf{r}_i^{(A)}$，并从 $\\mathcal{N}(\\boldsymbol{\\mu}(q_B), \\boldsymbol{\\Sigma})$ 生成 $N_B$ 个样本 $\\mathbf{r}_j^{(B)}$。\n3. 为每组样本计算势能差数组：$\\Delta u_i^{(A)} = -\\Delta q (\\mathbf{E} \\cdot \\mathbf{r}_i^{(A)})$ 和 $\\Delta u_j^{(B)} = -\\Delta q (\\mathbf{E} \\cdot \\mathbf{r}_j^{(B)})$。\n4. 数值求解方程 $g(\\Delta f) = 0$ 以得到 $\\Delta f$，从而找到 $\\Delta f_{BA}$ 的BAR估计值。\n5. 对所有测试用例重复此过程，并按规定格式化输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the Bennett Acceptance Ratio (BAR) problem for a series of test cases.\n    For each case, it generates samples from the specified Boltzmann distributions,\n    then numerically solves the BAR equation to find the reduced free energy difference.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, q_A, q_B, E_x, E_y, N_A, N_B, seed)\n        (1.0, 0.0, 1.0, 0.8, -0.4, 20000, 20000, 12345),\n        (1.0, 0.7, 0.7, 1.2, -0.3, 15000, 15000, 54321),\n        (1.0, 0.5, 0.9, 1.0, 1.0, 5000, 20000, 2023),\n        (2.0, -0.6, 0.4, 0.0, 0.0, 10000, 10000, 777),\n    ]\n\n    results = []\n    for case in test_cases:\n        k, q_A, q_B, E_x, E_y, N_A, N_B, seed = case\n\n        # Initialize the random number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # 1. Define system parameters and sampling distributions.\n        E = np.array([E_x, E_y])\n        sigma = 1.0 / np.sqrt(k)\n\n        # 2. Generate samples for states A and B.\n        mu_A = (q_A / k) * E\n        mu_B = (q_B / k) * E\n        \n        samples_A = rng.normal(loc=mu_A, scale=sigma, size=(N_A, 2))\n        samples_B = rng.normal(loc=mu_B, scale=sigma, size=(N_B, 2))\n\n        # 3. Calculate potential energy differences for the samples.\n        delta_q = q_B - q_A\n        du_samples_from_A = -delta_q * np.dot(samples_A, E)\n        du_samples_from_B = -delta_q * np.dot(samples_B, E)\n        \n        # 4. Solve the BAR equation for the free energy difference delta_f_BA.\n        c = np.log(N_B / N_A)\n\n        def bar_root_function(delta_f):\n            \"\"\"The BAR equation G(delta_f) = 0 for the root-finder.\"\"\"\n            arg_A = du_samples_from_A - delta_f - c\n            avg_A = np.mean(1.0 / (1.0 + np.exp(arg_A)))\n            \n            arg_B = -du_samples_from_B + delta_f + c\n            avg_B = np.mean(1.0 / (1.0 + np.exp(arg_B)))\n            \n            return avg_A - avg_B\n\n        # Find the root of the BAR equation using Brent's method.\n        sol = root_scalar(bar_root_function, bracket=[-100, 100], method='brentq')\n        delta_f_ba_estimate = sol.root\n\n        results.append(round(delta_f_ba_estimate, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}