{
    "hands_on_practices": [
        {
            "introduction": "机器学习势函数必须能够产生稳定的分子动力学轨迹，这种稳定性从根本上取决于其所描述的势能面的数学性质。本练习探讨了可微性的关键作用，它确保了力的连续性和非脉冲性。您将学习设计诊断测试，以检测由描述符截断等技术选择引入的非物理不连续性，从而确保您的模型在物理上是合理的。",
            "id": "3789446",
            "problem": "考虑一个用于分子动力学（MD）的机器学习（ML）原子间势，它表示为原子位置 $\\mathbf{R} = (\\mathbf{R}_1, \\dots, \\mathbf{R}_N)$ 和原子种类标识 $\\mathbf{Z} = (Z_1, \\dots, Z_N)$ 上的一个可微标量场 $E(\\mathbf{R}, \\mathbf{Z})$。原子 $i$ 受到的力由 $\\mathbf{F}_i(\\mathbf{R}, \\mathbf{Z}) = -\\nabla_{\\mathbf{R}_i} E(\\mathbf{R}, \\mathbf{Z})$ 定义。该势采用在截断半径 $r_c$ 处截断的局域描述符，并可能使用一个开关函数，使相互作用在 $r_c$ 附近过渡到零。在多尺度材料模拟中，训练和验证必须确保轨迹符合物理规律以及时间积分的稳定性。\n\n哪个选项最佳地阐述了 $E(\\mathbf{R}, \\mathbf{Z})$ 关于位置的可微性对于稳定MD的作用，并提出了一种物理启发的、可证伪的诊断测试，以检测由描述符截断或截断开关引起的非物理不连续性？\n\nA. $E(\\mathbf{R}, \\mathbf{Z})$ 关于 $\\mathbf{R}$ 的可微性确保了 $\\mathbf{F}(\\mathbf{R}, \\mathbf{Z}) = -\\nabla_{\\mathbf{R}} E(\\mathbf{R}, \\mathbf{Z})$ 至少是连续的；如果 $\\mathbf{F}$ 在 $\\mathbf{R}$ 上是局部利普希茨的，那么牛顿初值问题 $m_i \\ddot{\\mathbf{R}}_i = \\mathbf{F}_i(\\mathbf{R}, \\mathbf{Z})$ 解的存在性和唯一性就得以保证，并且辛积分器可以避免伪脉冲。一个诊断测试包括两部分：(i) 进行一维径向扫描，平滑地改变一个邻近原子对的距离 $r_{jk}(s)$ 使其跨越 $r_c$，记录 $E(s)$ 和 $\\mathbf{F}(s)$，并在 $r_{jk} = r_c$ 处检验 $\\lim_{\\Delta s \\to 0} \\|\\Delta \\mathbf{F}\\|/\\Delta r$ 的有界性；以及 (ii) 在位形空间中进行闭环功测试，沿着一个穿过截断区域的小闭环计算 $\\oint \\mathbf{F}(\\mathbf{R}, \\mathbf{Z}) \\cdot d\\mathbf{R}$，对于一个保守、可微的势，该值必须为 $0$（在容差范围内）。任何与步长无关的非零环流或力跳变都表明存在由描述符截断或截断开关引起的非物理不连续性。\n\nB. $E(\\mathbf{R}, \\mathbf{Z})$ 关于 $\\mathbf{R}$ 的可微性对于MD稳定性不是必需的，因为不连续的力可以通过选择足够小的时间步长来控制；一个实用的测试是运行一个长时间的MD轨迹，并检查总能量是否在可接受的范围内波动，而无需监测截断半径附近的力。\n\nC. 稳定的MD要求 $E(\\mathbf{R}, \\mathbf{Z})$ 是二次可微且全局凸的，从而使其Hessian矩阵 $\\nabla^2_{\\mathbf{R}} E(\\mathbf{R}, \\mathbf{Z})$ 是正定的；一个合适的测试是在远离截断处的代表性构型上计算 $\\nabla^2_{\\mathbf{R}} E(\\mathbf{R}, \\mathbf{Z})$ 并验证其正定性，这能保证在描述符截断处不发生不连续性。\n\nD. $E(\\mathbf{R}, \\mathbf{Z})$ 关于 $\\mathbf{R}$ 的连续性对于MD稳定性是足够的；为了检测截断问题，在 $r_c$ 处应用一个线性锥化函数以强制 $E$ 连续，然后只测试跨越 $r_{jk} \\approx r_c$ 处的能量差 $\\Delta E$，而忽略 $\\mathbf{F}$ 的行为，因为力的不连续性会随时间平均掉。",
            "solution": "基本的出发点是牛顿第二定律以及从势能定义力。对于质量为 $m_i$ 的原子 $i$，其运动遵循\n$$\nm_i \\ddot{\\mathbf{R}}_i(t) = \\mathbf{F}_i(\\mathbf{R}(t), \\mathbf{Z}) \\quad \\text{with} \\quad \\mathbf{F}_i(\\mathbf{R}, \\mathbf{Z}) = -\\nabla_{\\mathbf{R}_i} E(\\mathbf{R}, \\mathbf{Z}).\n$$\n这是一个常微分方程组（ODEs）。常微分方程的存在唯一性定理（Picard–Lindelöf）确保，如果右端项 $\\mathbf{F}(\\mathbf{R}, \\mathbf{Z})$ 在 $\\mathbf{R}$ 上是局部利普希茨连续的，那么给定初始条件 $(\\mathbf{R}(0), \\dot{\\mathbf{R}}(0))$，在局部时间内存在唯一解。对于一个在 $\\mathbf{R}$ 上至少是 $C^1$ 的标量势 $E(\\mathbf{R}, \\mathbf{Z})$，力场 $\\mathbf{F}(\\mathbf{R}, \\mathbf{Z})$ 是连续的；如果 $E$ 是 $C^2$ 的，那么 $\\mathbf{F}$ 是 $C^1$ 的，并且通常是局部利普希茨的。当 $E$ 关于 $\\mathbf{R}$ 不可微时，例如由于描述符截断或不恰当的截断开关，$\\mathbf{F}$ 会出现不连续性，这会产生冲量力，违反了标准MD积分器（如速度Verlet算法）背后的假设，并可能导致数值不稳定性和非物理轨迹。\n\n此外，由于 $\\mathbf{F}$ 是标量势的梯度，它是一个保守场：在位形空间中沿任何闭合路径所做的功必须为零，\n$$\n\\oint \\mathbf{F}(\\mathbf{R}, \\mathbf{Z}) \\cdot d\\mathbf{R} = 0,\n$$\n条件是 $E(\\mathbf{R}, \\mathbf{Z})$ 在该环路及其内部是可微的。如果描述符截断或截断开关引入了不连续性或非保守行为，这个环流量可能变为非零。\n\n为了设计一个物理启发的测试，考虑一个参数化路径 $\\mathbf{R}(s)$，该路径将一个邻近原子移动跨越截断半径 $r_c$，同时保持其他原子固定或平滑移动。沿着这条路径，\n$$\n\\frac{dE}{ds} = \\sum_{i=1}^N \\nabla_{\\mathbf{R}_i} E(\\mathbf{R}(s), \\mathbf{Z}) \\cdot \\frac{d\\mathbf{R}_i}{ds} = -\\sum_{i=1}^N \\mathbf{F}_i(\\mathbf{R}(s), \\mathbf{Z}) \\cdot \\frac{d\\mathbf{R}_i}{ds}.\n$$\n在 $r_{jk}(s) = r_c$ 处，如果 $E$ 是 $C^1$ 的，那么 $\\mathbf{F}(\\mathbf{R}(s), \\mathbf{Z})$ 和 $\\frac{dE}{ds}$ 的单侧极限应该匹配。不连续性表现为 $\\mathbf{F}$ 的一个跳变，这个跳变不会随着步长的缩小而减小。一个补充性的检查是在位形空间中构造一个环绕截断区域的小闭环，并计算\n$$\n\\oint \\mathbf{F}(\\mathbf{R}, \\mathbf{Z}) \\cdot d\\mathbf{R},\n$$\n对于一个保守、可微的势，该值应在数值容差范围内为 $0$；一个非零值表示存在非保守性假象。\n\n这些原则启发了主动学习和物理启发的训练策略：惩罚 $r_c$ 附近描述符的大梯度，强制使用至少是 $C^1$（最好是 $C^2$）的平滑截断函数，包括力一致性损失，并查询测得的力跳变或闭环功超过阈值的构型以扩充训练集。\n\n逐项分析：\n\nA. 该选项正确地将 $E(\\mathbf{R}, \\mathbf{Z})$ 的可微性与 $\\mathbf{F}(\\mathbf{R}, \\mathbf{Z})$ 的连续性和局部利普希茨特性联系起来，这是常微分方程 $m_i \\ddot{\\mathbf{R}}_i = \\mathbf{F}_i(\\mathbf{R}, \\mathbf{Z})$ 解的存在性和唯一性的基础。它明确提出了两种严格的诊断方法：一种是跨越 $r_c$ 的局部扫描，检查步长缩小时 $\\|\\Delta \\mathbf{F}\\|/\\Delta r$ 的行为；另一种是截断半径附近的闭环环流测试 $\\oint \\mathbf{F} \\cdot d\\mathbf{R}$。这两种方法都直接针对由描述符截断或截断开关引入的非物理不连续性和非保守性假象。结论 — 正确。\n\nB. 该选项声称可微性是不必要的，并表明足够小的时间步长可以稳定不连续的力。然而，$\\mathbf{F}$ 中的不连续性会产生冲量，这违反了标准MD积分器的假设，并破坏了基于局部利普希茨连续性的常微分方程的存在唯一性条件。所提出的测试——监测长时间的总能量波动而不检查 $r_c$ 附近的力——可能会错过局部的非物理跳变和非保守性假象。结论 — 错误。\n\nC. 该选项要求Hessian矩阵 $\\nabla^2_{\\mathbf{R}} E(\\mathbf{R}, \\mathbf{Z})$ 具有全局凸性和正定性，这对于真实的材料势既非必要也非典型，因为 $E(\\mathbf{R}, \\mathbf{Z})$ 通常是非凸的，以容纳键合、相变和缺陷。此外，在远离截断处评估Hessian矩阵并不能诊断在 $r_c$ 处引入的不连续性；一个势可以是非凸但完全可微的，或者其不连续性局限在截断处而在其他地方表现良好。结论 — 错误。\n\nD. 该选项断言 $E(\\mathbf{R}, \\mathbf{Z})$ 的连续性对于MD稳定性是足够的，并且只关注 $r_c$ 附近的 $E$ 的连续性。然而，稳定的MD至少需要连续的力，即 $E$ 在 $\\mathbf{R}$ 上应该是 $C^1$ 的。在 $r_c$ 处进行线性锥化可以强制 $E$ 连续，但会使 $\\nabla_{\\mathbf{R}} E$ 不连续，从而产生力跳变。忽略 $\\mathbf{F}$ 的行为并仅依赖能量差无法检测到力中的非物理不连续性。结论 — 错误。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "除了平滑性，预测力的准确性直接影响模拟的物理真实性。在微正则系综（NVE）中，总能量必须守恒，任何偏差都指向势函数的缺陷。本练习在模型的均方根力误差与一个关键的模拟可观测量——温度稳定性之间建立了定量的联系。通过推导这种关系，您将理解如何根据期望的模拟保真度为模型设定具体的精度目标。",
            "id": "3789431",
            "problem": "考虑一个晶体固体的分子动力学模拟，该模拟在微正则（恒定粒子数、体积、能量）系综 (NVE) 下，使用速度-Verlet积分算法和时间步长 $\\Delta t$ 进行。一个机器学习原子间势提供了对 $N$ 个质量均为 $m$ 的原子的总势能 $U_{\\text{ML}}(\\mathbf{r})$ 和力 $\\mathbf{F}_{\\text{ML}}(\\mathbf{r})$ 的预测。设真实势能为 $U(\\mathbf{r})$，真实力为 $\\mathbf{F}(\\mathbf{r}) = -\\nabla U(\\mathbf{r})$。定义瞬时速度矢量 $\\mathbf{v} \\in \\mathbb{R}^{3N}$ 和力预测误差矢量 $\\boldsymbol{\\eta}(\\mathbf{r}) \\in \\mathbb{R}^{3N}$，使得 $\\mathbf{F}_{\\text{ML}}(\\mathbf{r}) = \\mathbf{F}(\\mathbf{r}) + \\boldsymbol{\\eta}(\\mathbf{r})$。\n\n假设以下具有物理依据的基础：\n- Newton 第二定律：对于真实力，$m \\, d\\mathbf{v}/dt = \\mathbf{F}(\\mathbf{r})$。\n- 三维空间中动能温度 $T$ 的能量均分定理：瞬时动能为 $K = \\frac{1}{2} \\sum_{i=1}^{3N} m v_i^2$，对于一个各态遍历的微正则态，$\\sum_{i=1}^{3N} v_i^2$ 的典型量级满足 $\\sum_{i=1}^{3N} v_i^2 \\approx \\frac{3 N k_B T}{m}$，其中 $k_B$ 是 Boltzmann 常数。\n- 温度通过 $K = \\frac{3 N}{2} k_B T$ 与动能相关。\n\n假设主动学习循环监测每个笛卡尔自由度的均方根 (RMS) 力误差，\n$$\n\\delta F = \\left( \\frac{1}{3N} \\sum_{i=1}^{3N} \\eta_i^2 \\right)^{1/2},\n$$\n以及每个构型的 RMS 能量误差 $\\delta U = \\left\\langle \\left( U_{\\text{ML}}(\\mathbf{r}) - U(\\mathbf{r}) \\right)^2 \\right\\rangle^{1/2}$。在 NVE 动力学中，非零的 $\\boldsymbol{\\eta}$ 会因伪功 $\\sum_{i=1}^{3N} v_i \\eta_i$ 而注入或移除能量，可能导致温度漂移。\n\n定义一个目标——每步相对温度稳定性容差 $\\alpha$（无量纲），意味着在每个积分步长中，温度变化的幅度满足 $|\\Delta T| \\le \\alpha T$。在单个时间步长内 $\\mathbf{v}$ 和 $\\boldsymbol{\\eta}$ 最坏情况对齐（瞬时伪功率最大化）的条件下，并假设所有原子质量均为 $m$，推导可接受的每步 RMS 力误差 $\\delta F_{\\max}$ 的一个界。该界应为一个以 $\\alpha$、$\\Delta t$、$m$、$k_B$ 和 $T$ 表示的闭式解析表达式，使得最坏情况下的每步温度漂移遵循 $|\\Delta T| \\le \\alpha T$。\n\n以单一解析表达式给出你的最终界。无需进行数值计算。如果引入中间变量，请清晰地定义它们。以符号形式表示最终界；不要在最终的方框表达式中包含单位。",
            "solution": "问题要求推导在微正则 (NVE) 系综分子动力学模拟中，使用的机器学习原子间势的均方根 (RMS) 力误差 $\\delta F_{\\max}$ 的一个上界。该界必须确保在最坏情况下，每步的温度变化 $\\Delta T$ 不超过指定的相对容差 $\\alpha T$。\n\n$N$ 粒子系统的第 $i$ 个笛卡尔自由度的动力学由机器学习势预测的力 $\\mathbf{F}_{\\text{ML}}$ 控制。这个力是真实物理力 $\\mathbf{F}$ 和一个误差项 $\\boldsymbol{\\eta}$ 的和。\n$$\nm \\frac{d^2\\mathbf{r}}{dt^2} = m \\frac{d\\mathbf{v}}{dt} = \\mathbf{F}_{\\text{ML}}(\\mathbf{r}) = \\mathbf{F}(\\mathbf{r}) + \\boldsymbol{\\eta}(\\mathbf{r})\n$$\n动能 $K$ 的变化率由作用于系统的合力所做的功率给出：\n$$\n\\frac{dK}{dt} = \\frac{d}{dt} \\left( \\frac{1}{2} m \\sum_{i=1}^{3N} v_i^2 \\right) = \\sum_{i=1}^{3N} (m \\dot{v}_i) v_i = \\mathbf{F}_{\\text{ML}} \\cdot \\mathbf{v}\n$$\n代入 $\\mathbf{F}_{\\text{ML}} = \\mathbf{F} + \\boldsymbol{\\eta}$：\n$$\n\\frac{dK}{dt} = (\\mathbf{F} + \\boldsymbol{\\eta}) \\cdot \\mathbf{v} = \\mathbf{F} \\cdot \\mathbf{v} + \\boldsymbol{\\eta} \\cdot \\mathbf{v}\n$$\n真实势能 $U$ 的变化率为 $\\frac{dU}{dt} = \\nabla U(\\mathbf{r}) \\cdot \\frac{d\\mathbf{r}}{dt} = (-\\mathbf{F}) \\cdot \\mathbf{v}$。\n因此，真实总能量 $E = K + U$ 的变化率为：\n$$\n\\frac{dE}{dt} = \\frac{dK}{dt} + \\frac{dU}{dt} = (\\mathbf{F} \\cdot \\mathbf{v} + \\boldsymbol{\\eta} \\cdot \\mathbf{v}) - (\\mathbf{F} \\cdot \\mathbf{v}) = \\boldsymbol{\\eta} \\cdot \\mathbf{v}\n$$\n这个方程表明，误差力 $\\boldsymbol{\\eta}$ 以 $\\boldsymbol{\\eta} \\cdot \\mathbf{v}$ 的速率对系统做伪功，导致真实总能量不守恒。这种伪能量注入是 NVE 模拟中温度漂移的根本原因。\n\n在单个离散时间步长 $\\Delta t$ 内，总能量的变化为 $\\Delta E \\approx (\\boldsymbol{\\eta} \\cdot \\mathbf{v}) \\Delta t$。能量的这种变化被分配到动能和势能中。温度漂移是这种伪功引起的动能系统性变化的直接后果。我们通过仅考虑由误差力引起的动能变化来分离这种效应：\n$$\n\\Delta K_{\\text{err}} \\approx (\\boldsymbol{\\eta} \\cdot \\mathbf{v}) \\Delta t\n$$\n问题要求我们考虑温度漂移的最坏情况。当矢量 $\\boldsymbol{\\eta}$ 和 $\\mathbf{v}$ 共线时，伪动能变化的幅度 $|\\Delta K_{\\text{err}}|$ 达到最大。根据 Cauchy-Schwarz 不等式，$|\\boldsymbol{\\eta} \\cdot \\mathbf{v}| \\le ||\\boldsymbol{\\eta}|| \\cdot ||\\mathbf{v}||$，其中 $||\\cdot||$ 表示 $\\mathbb{R}^{3N}$ 中的欧几里得范数。因此，最坏情况下的变化是：\n$$\n|\\Delta K|_{\\text{worst}} = ||\\boldsymbol{\\eta}|| \\cdot ||\\mathbf{v}|| \\Delta t\n$$\n我们需要用给定的量来表示范数 $||\\boldsymbol{\\eta}||$ 和 $||\\mathbf{v}||$。\nRMS 力误差 $\\delta F$ 定义为：\n$$\n\\delta F = \\left( \\frac{1}{3N} \\sum_{i=1}^{3N} \\eta_i^2 \\right)^{1/2} = \\left( \\frac{||\\boldsymbol{\\eta}||^2}{3N} \\right)^{1/2} = \\frac{||\\boldsymbol{\\eta}||}{\\sqrt{3N}}\n$$\n对 $||\\boldsymbol{\\eta}||$ 重新整理得到：\n$$\n||\\boldsymbol{\\eta}|| = \\sqrt{3N} \\, \\delta F\n$$\n动能 $K$ 通过定义 $K = \\frac{3N}{2} k_B T$ 与温度 $T$ 相关。它也由 $K = \\frac{1}{2} \\sum_{i=1}^{3N} m v_i^2$ 给出。由于所有原子的质量 $m$ 相同，这可以简化为 $K = \\frac{m}{2} ||\\mathbf{v}||^2$。令 $K$ 的两个表达式相等：\n$$\n\\frac{m}{2} ||\\mathbf{v}||^2 = \\frac{3N}{2} k_B T\n$$\n解出 $||\\mathbf{v}||$ 得到：\n$$\n||\\mathbf{v}|| = \\sqrt{\\frac{3N k_B T}{m}}\n$$\n将这些范数表达式代入 $|\\Delta K|_{\\text{worst}}$ 的方程中：\n$$\n|\\Delta K|_{\\text{worst}} = (\\sqrt{3N} \\, \\delta F) \\left( \\sqrt{\\frac{3N k_B T}{m}} \\right) \\Delta t = \\delta F \\Delta t \\sqrt{3N \\cdot \\frac{3N k_B T}{m}} = \\delta F \\Delta t \\frac{3N}{\\sqrt{m}} \\sqrt{k_B T}\n$$\n问题指定了温度稳定性容差 $|\\Delta T| \\le \\alpha T$。我们可以将其与最大允许动能变化 $|\\Delta K|_{\\text{limit}}$ 联系起来。从 $K = \\frac{3N}{2} k_B T$ 可知，微小变化 $\\Delta K$ 与 $\\Delta T$ 的关系为 $\\Delta K = \\frac{3N}{2} k_B \\Delta T$。因此，稳定性标准意味着：\n$$\n|\\Delta K| \\le \\frac{3N}{2} k_B (\\alpha T)\n$$\n通过将最坏情况下的动能变化设为等于此最大允许变化，可以找到可接受的 RMS 力误差的界 $\\delta F_{\\max}$：\n$$\n|\\Delta K|_{\\text{worst}} = |\\Delta K|_{\\text{limit}}\n$$\n$$\n\\delta F_{\\max} \\Delta t \\frac{3N}{\\sqrt{m}} \\sqrt{k_B T} = \\frac{3N}{2} k_B \\alpha T\n$$\n最后，我们求解 $\\delta F_{\\max}$：\n$$\n\\delta F_{\\max} = \\frac{\\frac{3N}{2} k_B \\alpha T}{\\Delta t \\frac{3N}{\\sqrt{m}} \\sqrt{k_B T}}\n$$\n$3N$ 项相互抵消。\n$$\n\\delta F_{\\max} = \\frac{k_B \\alpha T \\sqrt{m}}{2 \\Delta t \\sqrt{k_B T}} = \\frac{\\alpha \\sqrt{m}}{2 \\Delta t} \\frac{k_B T}{\\sqrt{k_B T}}\n$$\n简化表达式得到最终的界：\n$$\n\\delta F_{\\max} = \\frac{\\alpha}{2 \\Delta t} \\sqrt{m k_B T}\n$$\n此表达式给出了每个自由度的最大可容忍 RMS 力误差，它是稳定性参数 $\\alpha$、积分时间步长 $\\Delta t$、原子质量 $m$、Boltzmann 常数 $k_B$ 和系统温度 $T$ 的函数。",
            "answer": "$$ \\boxed{ \\frac{\\alpha}{2 \\Delta t} \\sqrt{m k_B T} } $$"
        },
        {
            "introduction": "主动学习旨在通过智能地选择信息量最大的新数据进行标记来有效地改进模型。这需要一种策略来识别当前模型认为最不确定或位于构型空间未探索区域的构型。本练习将指导您在描述符空间中实现一种复杂的主动学习策略——最大最小距离采样。您将把使用核方法最大化相异性的理论概念转化为一个实用的算法，用于为您的训练集选择新的候选结构。",
            "id": "3789380",
            "problem": "考虑在多尺度材料模拟中，为机器学习（ML）原子间势进行主动学习的任务。在分子动力学（MD）中，每一帧都可以由一组嵌入在有限维欧几里得空间中的原子描述符向量来表示。设每个描述符向量为元素 $x \\in \\mathbb{R}^d$，其中 $d$ 是描述符维度。假设我们有一个当前已标记的帧集合 $\\mathcal{S} = \\{ S_1, S_2, \\dots, S_m \\}$，以及一个未标记的候选帧批次 $\\mathcal{C} = \\{ C_1, C_2, \\dots, C_k \\}$。每一帧 $S_i$ 或 $C_j$ 分别是一个由描述符向量组成的有限集，即 $S_i = \\{ s_{i,1},\\dots,s_{i,n_i} \\} \\subset \\mathbb{R}^d$ 和 $C_j = \\{ c_{j,1},\\dots,c_{j,p_j} \\} \\subset \\mathbb{R}^d$。\n\n我们通过由半正定度量矩阵诱导的高斯径向基函数（RBF）核来定义相似性。设 $M \\in \\mathbb{R}^{d \\times d}$ 是对称半正定矩阵，且 $\\ell > 0$ 是一个长度尺度。两个描述符向量 $x,y \\in \\mathbb{R}^d$ 之间的核函数为\n$$\nk(x,y) = \\exp\\!\\left( - \\frac{1}{2 \\ell^2} (x-y)^\\top M (x-y) \\right).\n$$\n该核在再生核希尔伯特空间（RKHS）中诱导了一个内积，一帧 $A = \\{ a_1,\\dots,a_{n_A} \\}$ 的核均值嵌入是经验均值元素 $\\mu_A = \\frac{1}{n_A} \\sum_{i=1}^{n_A} \\phi(a_i)$，其中 $\\phi(\\cdot)$ 是与 $k(\\cdot,\\cdot)$ 相关联的特征映射。均值嵌入之间的平方距离是有偏平方最大均值差异（MMD），\n$$\n\\operatorname{MMD}^2_{\\text{biased}}(A,B) = \\left\\| \\mu_A - \\mu_B \\right\\|_{\\mathcal{H}}^2\n= \\frac{1}{n_A^2} \\sum_{i=1}^{n_A} \\sum_{j=1}^{n_A} k(a_i,a_j)\n+ \\frac{1}{n_B^2} \\sum_{i=1}^{n_B} \\sum_{j=1}^{n_B} k(b_i,b_j)\n- \\frac{2}{n_A n_B} \\sum_{i=1}^{n_A} \\sum_{j=1}^{n_B} k(a_i,b_j),\n$$\n对于任何 $n_A \\ge 1$ 和 $n_B \\ge 1$ 都有很好的定义。\n\n描述符空间中的Maximin距离采样选择的候选帧 $C^* \\in \\mathcal{C}$ 是使其与当前集合 $\\mathcal{S}$ 的最小距离最大化的帧，其中帧之间的距离是均值嵌入之差的RKHS范数。具体地，定义\n$$\nd(C,\\mathcal{S}) = \\min_{S \\in \\mathcal{S}} \\sqrt{ \\operatorname{MMD}^2_{\\text{biased}}(C,S) }.\n$$\nMaximin选择为\n$$\nC^* = \\arg\\max_{C \\in \\mathcal{C}} d(C,\\mathcal{S}).\n$$\n当多个候选帧达到相同的 $d(C,\\mathcal{S})$ 最大值时，必须通过返回最小的候选索引来解决平局问题（即，使 $C_j$ 达到最大值的最小 $j$）。\n\n您的任务是编写一个完整的程序，该程序：\n- 实现由 $M$ 和 $\\ell$ 参数化的RBF核 $k(x,y)$。\n- 对任意两帧 $A,B$ 计算 $\\operatorname{MMD}^2_{\\text{biased}}(A,B)$。\n- 对于每个测试用例，为所有候选帧 $C_j$ 计算 $d(C_j,\\mathcal{S})$，根据maximin规则选择 $C^*$，并以整数形式返回 $C^*$ 的索引。\n\n此问题不涉及物理单位；所有量均为无量纲。不使用角度。不使用百分比。\n\n测试套件：\n对于每个测试用例，您将获得 $d$、$M$、$\\ell$、当前集合 $\\mathcal{S}$ 和候选集合 $\\mathcal{C}$。所有描述符向量都以分量列表的形式明确提供。您的程序必须处理以下四种情况：\n\n- 情况1（理想情况，各向同性度量）：\n  - $d = 2$, $M = I_2$, $\\ell = 1.0$。\n  - $\\mathcal{S}$:\n    - $S_1 = \\{ (0.0, 0.0), (1.0, 0.0), (0.5, 0.5) \\}$,\n    - $S_2 = \\{ (2.0, 2.0), (2.5, 2.0) \\}$。\n  - $\\mathcal{C}$:\n    - $C_1 = \\{ (3.0, 3.0), (2.8, 3.2) \\}$,\n    - $C_2 = \\{ (0.9, 0.1), (0.6, 0.4) \\}$,\n    - $C_3 = \\{ (-1.0, -1.0), (-0.5, -0.2) \\}$。\n\n- 情况2（候选帧与当前某一帧相同，各向同性度量，不同长度尺度）：\n  - $d = 2$, $M = I_2$, $\\ell = 0.8$。\n  - $\\mathcal{S}$:\n    - $S_1 = \\{ (0.0, 0.0), (1.0, 0.0) \\}$。\n  - $\\mathcal{C}$:\n    - $C_1 = \\{ (0.0, 0.0), (1.0, 0.0) \\}$,\n    - $C_2 = \\{ (3.0, 0.0), (3.5, 0.5) \\}$,\n    - $C_3 = \\{ (1.2, 0.1), (1.1, -0.1) \\}$。\n\n- 情况3（各向异性度量，更高维度）：\n  - $d = 3$, $M = \\operatorname{diag}(2.0, 1.0, 0.5)$, $\\ell = 1.5$。\n  - $\\mathcal{S}$:\n    - $S_1 = \\{ (0.0, 0.0, 0.0), (0.2, -0.1, 0.0) \\}$,\n    - $S_2 = \\{ (1.0, 0.0, 0.0), (1.1, 0.1, -0.1) \\}$。\n  - $\\mathcal{C}$:\n    - $C_1 = \\{ (0.9, 0.0, 0.0), (1.2, -0.2, 0.2) \\}$,\n    - $C_2 = \\{ (-1.0, 0.0, 0.0), (-1.2, 0.2, -0.1) \\}$,\n    - $C_3 = \\{ (0.0, 1.0, 0.0), (0.0, 1.2, 0.2) \\}$。\n\n- 情况4（单描述符帧，各向同性度量，小长度尺度）：\n  - $d = 2$, $M = I_2$, $\\ell = 0.5$。\n  - $\\mathcal{S}$:\n    - $S_1 = \\{ (0.0, 0.0) \\}$,\n    - $S_2 = \\{ (0.2, 0.2) \\}$。\n  - $\\mathcal{C}$:\n    - $C_1 = \\{ (0.0, 0.1) \\}$,\n    - $C_2 = \\{ (1.0, 1.0) \\}$,\n    - $C_3 = \\{ (0.25, 0.25) \\}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是为情况 $i$ 选择的候选索引（整数形式）。在每种情况下，索引都是相对于 $\\mathcal{C} = \\{ C_1, C_2, \\dots \\}$ 从1开始的。",
            "solution": "我们提出了一种在描述符空间中使用核诱导度量进行maximin距离采样的有原则的推导和算法，适用于机器学习（ML）原子间势的主动学习。目标是选择一个在具有物理意义的描述符方面与当前已标记帧最大程度上不相似的候选MD帧，同时尊重核函数所编码的对称性和不变性。\n\n步骤1：核诱导的相似性和度量。设 $x,y \\in \\mathbb{R}^d$ 为描述符向量。具有各向异性度量矩阵 $M \\in \\mathbb{R}^{d \\times d}$ 和正长度尺度 $\\ell$ 的高斯径向基函数（RBF）核定义为\n$$\nk(x,y) = \\exp\\!\\left( - \\frac{1}{2 \\ell^2} (x-y)^\\top M (x-y) \\right).\n$$\n如果 $M$ 是对称半正定的，则量 $(x-y)^\\top M (x-y)$ 是一个有效的平方半范数，且 $k(x,y)$ 是正定的。这确保了再生核希尔伯特空间（RKHS）$\\mathcal{H}$ 和特征映射 $\\phi : \\mathbb{R}^d \\to \\mathcal{H}$ 的存在，使得 $k(x,y) = \\langle \\phi(x), \\phi(y) \\rangle_{\\mathcal{H}}$。在物理上，$M$ 可以编码跨描述符维度的各向异性缩放，反映了描述符分量的物理信息加权（例如，增强沿某些不变特征的灵敏度）。\n\n步骤2：帧的均值嵌入。对于一帧 $A = \\{ a_1,\\dots,a_{n_A} \\}$，其在 $\\mathcal{H}$ 中的经验均值元素定义为\n$$\n\\mu_A = \\frac{1}{n_A} \\sum_{i=1}^{n_A} \\phi(a_i).\n$$\n这种构造将每个原子的信息聚合成一个帧级别的表示，保留了核所捕获的对称性。RKHS范数 $||\\mu_A - \\mu_B||_{\\mathcal{H}}$ 通过描述符的分布来衡量帧 $A$ 和 $B$ 之间的距离。\n\n步骤3：有偏平方最大均值差异（MMD）。均值嵌入之间的平方距离为\n$$\n\\left\\| \\mu_A - \\mu_B \\right\\|_{\\mathcal{H}}^2\n= \\left\\langle \\mu_A, \\mu_A \\right\\rangle_{\\mathcal{H}}\n+ \\left\\langle \\mu_B, \\mu_B \\right\\rangle_{\\mathcal{H}}\n- 2 \\left\\langle \\mu_A, \\mu_B \\right\\rangle_{\\mathcal{H}},\n$$\n并且，根据再生性质，\n$$\n\\left\\langle \\mu_A, \\mu_A \\right\\rangle_{\\mathcal{H}}\n= \\left\\langle \\frac{1}{n_A} \\sum_{i=1}^{n_A} \\phi(a_i), \\frac{1}{n_A} \\sum_{j=1}^{n_A} \\phi(a_j) \\right\\rangle_{\\mathcal{H}}\n= \\frac{1}{n_A^2} \\sum_{i=1}^{n_A} \\sum_{j=1}^{n_A} \\left\\langle \\phi(a_i), \\phi(a_j) \\right\\rangle_{\\mathcal{H}}\n= \\frac{1}{n_A^2} \\sum_{i=1}^{n_A} \\sum_{j=1}^{n_A} k(a_i,a_j).\n$$\n类似地，\n$$\n\\left\\langle \\mu_B, \\mu_B \\right\\rangle_{\\mathcal{H}} = \\frac{1}{n_B^2} \\sum_{i=1}^{n_B} \\sum_{j=1}^{n_B} k(b_i,b_j),\n\\quad\n\\left\\langle \\mu_A, \\mu_B \\right\\rangle_{\\mathcal{H}} = \\frac{1}{n_A n_B} \\sum_{i=1}^{n_A} \\sum_{j=1}^{n_B} k(a_i,b_j).\n$$\n因此，\n$$\n\\operatorname{MMD}^2_{\\text{biased}}(A,B)\n= \\frac{1}{n_A^2} \\sum_{i=1}^{n_A} \\sum_{j=1}^{n_A} k(a_i,a_j)\n+ \\frac{1}{n_B^2} \\sum_{i=1}^{n_B} \\sum_{j=1}^{n_B} k(b_i,b_j)\n- \\frac{2}{n_A n_B} \\sum_{i=1}^{n_A} \\sum_{j=1}^{n_B} k(a_i,b_j).\n$$\n这个有偏估计量等于经验均值嵌入之间的平方RKHS距离，并且对于任何 $n_A \\ge 1$ 和 $n_B \\ge 1$ 都定义良好，这对于包含单个描述符向量的帧至关重要。\n\n步骤4：Maximin距离选择。对于一个候选帧 $C$ 和一个当前集合 $\\mathcal{S} = \\{ S_1, \\dots, S_m \\}$，定义候选帧到集合的距离为\n$$\nd(C,\\mathcal{S}) = \\min_{S \\in \\mathcal{S}} \\sqrt{ \\operatorname{MMD}^2_{\\text{biased}}(C,S) }.\n$$\nMaximin采样选择\n$$\nC^* = \\arg\\max_{C \\in \\mathcal{C}} d(C,\\mathcal{S}).\n$$\n该规则通过优先选择与最近的当前帧最大程度上不相似（在RKHS均值嵌入距离意义上）的候选帧来促进探索。从物理信息的角度看，这通过确保新帧占据描述符空间中代表性不足的区域，同时尊重 $M$ 中编码的各向异性缩放和特征长度 $\\ell$，从而降低了外推风险。\n\n步骤5：算法实现。\n- 通过以下方式计算成对核矩阵 $K_{AA}$、$K_{BB}$ 和 $K_{AB}$\n$$\nK_{ij}^{AB} = k(a_i,b_j) = \\exp\\!\\left( - \\frac{1}{2 \\ell^2} (a_i-b_j)^\\top M (a_i-b_j) \\right).\n$$\n高效的计算使用以下恒等式\n$$\n(a-b)^\\top M (a-b) = a^\\top M a + b^\\top M b - 2 a^\\top M b,\n$$\n预先计算所有对的 $a^\\top M a$、$b^\\top M b$ 和 $a^\\top M b$。\n- 如上计算 $\\operatorname{MMD}^2_{\\text{biased}}(A,B)$。\n- 对每个候选帧 $C_j$，评估 $d(C_j,\\mathcal{S}) = \\min_{S_i \\in \\mathcal{S}} \\sqrt{\\operatorname{MMD}^2_{\\text{biased}}(C_j,S_i)}$。\n- 通过在所有 $j$ 中最大化 $d(C_j,\\mathcal{S})$ 来选择 $C^*$。通过最小的 $j$（遇到的第一个最大值）来解决平局。\n\n步骤6：边界情况和数值考虑。\n- 因为 $\\operatorname{MMD}^2_{\\text{biased}}(A,B)$ 通过构造是非负的，数值舍入误差可能会产生微小的负值；在取平方根之前，通过将其下限钳制在0来强制非负性。\n- 当候选帧与当前帧完全匹配时，核矩阵将产生 $\\operatorname{MMD}^2_{\\text{biased}}(C,S) = 0$，因此 $d(C,\\mathcal{S}) = 0$，除非所有候选帧都同样接近，否则算法会正确地避免选择该候选者。\n\n步骤7：输出规范。对于四个测试用例中的每一个，返回所选候选者的基于1的索引（整数形式）。将这四个整数聚合到单行中，格式为 $[r_1,r_2,r_3,r_4]$。\n\n提供的程序遵循此推导，实现了核函数和MMD计算，对每个测试用例应用maximin规则，并打印所需的单行输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rbf_kernel_matrix(X: np.ndarray, Y: np.ndarray, M: np.ndarray, ell: float) -> np.ndarray:\n    \"\"\"\n    Compute the Gaussian RBF kernel matrix K between two sets of descriptor vectors X and Y\n    using an anisotropic metric M and length scale ell.\n\n    k(x,y) = exp( - (1/(2*ell^2)) * (x - y)^T M (x - y) )\n\n    Parameters:\n        X: shape (n_x, d)\n        Y: shape (n_y, d)\n        M: shape (d, d), symmetric positive semidefinite\n        ell: positive float\n\n    Returns:\n        K: shape (n_x, n_y)\n    \"\"\"\n    # Precompute terms using quadratic form identity:\n    # (x - y)^T M (x - y) = x^T M x + y^T M y - 2 x^T M y\n    X_M = X @ M           # shape (n_x, d)\n    Y_M = Y @ M           # shape (n_y, d)\n\n    xMx = np.einsum('ij,ij->i', X, X_M)  # shape (n_x,)\n    yMy = np.einsum('ij,ij->i', Y, Y_M)  # shape (n_y,)\n\n    cross = X @ M @ Y.T                   # shape (n_x, n_y)\n\n    # Broadcast to form pairwise metric distances squared\n    dist2 = xMx[:, None] + yMy[None, :] - 2.0 * cross\n\n    # Numerical safety: ensure non-negative due to PSD M\n    dist2 = np.maximum(dist2, 0.0)\n\n    K = np.exp(-0.5 * dist2 / (ell ** 2))\n    return K\n\ndef mmd2_biased(A: np.ndarray, B: np.ndarray, M: np.ndarray, ell: float) -> float:\n    \"\"\"\n    Compute the biased squared MMD between two frames A and B (sets of descriptors),\n    using the Gaussian RBF kernel with metric M and length scale ell.\n\n    MMD^2_biased(A,B) = (1/n_A^2) sum_{i,j} k(a_i,a_j)\n                      + (1/n_B^2) sum_{i,j} k(b_i,b_j)\n                      - (2/(n_A n_B)) sum_{i,j} k(a_i,b_j)\n    \"\"\"\n    nA = A.shape[0]\n    nB = B.shape[0]\n\n    KA = rbf_kernel_matrix(A, A, M, ell)\n    KB = rbf_kernel_matrix(B, B, M, ell)\n    KAB = rbf_kernel_matrix(A, B, M, ell)\n\n    term_A = np.sum(KA) / (nA ** 2)\n    term_B = np.sum(KB) / (nB ** 2)\n    term_AB = (2.0 * np.sum(KAB)) / (nA * nB)\n\n    mmd2 = term_A + term_B - term_AB\n\n    # Clamp small negative due to numerical roundoff\n    if mmd2 < 0.0 and mmd2 > -1e-12:\n        mmd2 = 0.0\n\n    return float(mmd2)\n\ndef maximin_candidate_index(current_frames, candidate_frames, M, ell):\n    \"\"\"\n    Given a list of current frames and candidate frames (each a numpy array of shape (n_i, d)),\n    return the 1-based index of the candidate that maximizes the minimum sqrt(MMD^2_biased)\n    to the current frames. Ties are broken by smallest index (np.argmax behavior).\n    \"\"\"\n    min_distances = []\n    for C in candidate_frames:\n        # Compute distance to each current frame\n        dists = []\n        for S in current_frames:\n            mmd2 = mmd2_biased(C, S, M, ell)\n            # Ensure non-negative before sqrt\n            dists.append(np.sqrt(max(mmd2, 0.0)))\n        # Candidate-to-set distance is min over current frames\n        min_distances.append(min(dists))\n\n    # Select the candidate with maximum min-distance; 1-based index\n    # np.argmax returns first occurrence in case of ties -> smallest index tie-break\n    best_idx = int(np.argmax(min_distances)) + 1\n    return best_idx\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    test_cases = []\n\n    # Case 1\n    d1 = 2\n    M1 = np.eye(d1)\n    ell1 = 1.0\n    S1_1 = np.array([[0.0, 0.0],\n                     [1.0, 0.0],\n                     [0.5, 0.5]])\n    S1_2 = np.array([[2.0, 2.0],\n                     [2.5, 2.0]])\n    C1_1 = np.array([[3.0, 3.0],\n                     [2.8, 3.2]])\n    C1_2 = np.array([[0.9, 0.1],\n                     [0.6, 0.4]])\n    C1_3 = np.array([[-1.0, -1.0],\n                     [-0.5, -0.2]])\n    test_cases.append(( [S1_1, S1_2], [C1_1, C1_2, C1_3], M1, ell1 ))\n\n    # Case 2\n    d2 = 2\n    M2 = np.eye(d2)\n    ell2 = 0.8\n    S2_1 = np.array([[0.0, 0.0],\n                     [1.0, 0.0]])\n    C2_1 = np.array([[0.0, 0.0],\n                     [1.0, 0.0]])  # identical to S2_1\n    C2_2 = np.array([[3.0, 0.0],\n                     [3.5, 0.5]])\n    C2_3 = np.array([[1.2, 0.1],\n                     [1.1, -0.1]])\n    test_cases.append(( [S2_1], [C2_1, C2_2, C2_3], M2, ell2 ))\n\n    # Case 3\n    d3 = 3\n    M3 = np.diag([2.0, 1.0, 0.5])\n    ell3 = 1.5\n    S3_1 = np.array([[0.0, 0.0, 0.0],\n                     [0.2, -0.1, 0.0]])\n    S3_2 = np.array([[1.0, 0.0, 0.0],\n                     [1.1, 0.1, -0.1]])\n    C3_1 = np.array([[0.9, 0.0, 0.0],\n                     [1.2, -0.2, 0.2]])\n    C3_2 = np.array([[-1.0, 0.0, 0.0],\n                     [-1.2, 0.2, -0.1]])\n    C3_3 = np.array([[0.0, 1.0, 0.0],\n                     [0.0, 1.2, 0.2]])\n    test_cases.append(( [S3_1, S3_2], [C3_1, C3_2, C3_3], M3, ell3 ))\n\n    # Case 4\n    d4 = 2\n    M4 = np.eye(d4)\n    ell4 = 0.5\n    S4_1 = np.array([[0.0, 0.0]])\n    S4_2 = np.array([[0.2, 0.2]])\n    C4_1 = np.array([[0.0, 0.1]])\n    C4_2 = np.array([[1.0, 1.0]])\n    C4_3 = np.array([[0.25, 0.25]])\n    test_cases.append(( [S4_1, S4_2], [C4_1, C4_2, C4_3], M4, ell4 ))\n\n    results = []\n    for current_frames, candidate_frames, M, ell in test_cases:\n        idx = maximin_candidate_index(current_frames, candidate_frames, M, ell)\n        results.append(idx)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}