{
    "hands_on_practices": [
        {
            "introduction": "To build intuition for how atomic environment descriptors encode structural information, it is invaluable to compute them for simple, idealized geometries. This exercise focuses on calculating Behler-Parrinello symmetry functions for perfect tetrahedral and octahedral coordinations. By doing so, you will gain direct insight into how the descriptor's parameters, such as $\\lambda$ and $\\zeta$, can be tuned to maximize the contrast between different local bonding patterns, a key step in building a discriminative model .",
            "id": "3791376",
            "problem": "You are designing atom-centered descriptors for feature learning in multiscale materials simulation using Behler–Parrinello atomic symmetry functions (BP-ASF). Consider a central atom $i$ in two idealized local environments:\n\n- A perfect tetrahedral coordination: $4$ neighbors all at distance $r_{0}$ from $i$, and all bond–bond angles at the central atom equal to the tetrahedral angle with $\\cos\\theta=-\\frac{1}{3}$.\n- A perfect octahedral coordination: $6$ neighbors all at distance $r_{0}$ from $i$, where the bond–bond angles at $i$ consist of $12$ right angles with $\\cos\\theta=0$ and $3$ straight angles with $\\cos\\theta=-1$.\n\nUse the following BP-ASF definitions with a cosine cutoff:\n- The radial function\n$$\nG_{2}^{(i)}(\\eta_{2},R_{s},R_{c})=\\sum_{j\\neq i}\\exp\\!\\big(-\\eta_{2}\\big(r_{ij}-R_{s}\\big)^{2}\\big)\\,f_{c}(r_{ij}),\n$$\n- The angular function\n$$\nG_{4}^{(i)}(\\eta_{4},\\lambda,\\zeta,R_{c})=2^{\\,1-\\zeta}\\sum_{\\substack{j\\neq i\\\\k\\neq i\\\\j<k}}\\big(1+\\lambda\\cos\\theta_{ijk}\\big)^{\\zeta}\\,\\exp\\!\\big(-\\eta_{4}\\big(r_{ij}^{2}+r_{ik}^{2}\\big)\\big)\\,f_{c}(r_{ij})\\,f_{c}(r_{ik}),\n$$\nwith the cutoff function\n$$\nf_{c}(r)=\n\\begin{cases}\n\\frac{1}{2}\\Big(\\cos\\big(\\pi r/R_{c}\\big)+1\\Big), & r\\le R_{c},\\\\[4pt]\n0, & r>R_{c}.\n\\end{cases}\n$$\n\nAssume $r_{0}=2.5\\,\\text{Å}$ and $R_{c}=7.5\\,\\text{Å}$ so that all neighbors lie within the cutoff. For $G_{2}$, take $R_{s}=r_{0}$ and $\\eta_{2}=1.0\\,\\text{Å}^{-2}$. For $G_{4}$, choose $\\eta_{4}=\\frac{\\ln 2}{2r_{0}^{2}}$ and consider the parameter grid $\\lambda\\in\\{+1,-1\\}$ and $\\zeta\\in\\{1,2,4\\}$.\n\nTasks:\n1. Compute $G_{2}$ for the tetrahedral environment.\n2. For each $(\\lambda,\\zeta)$ in the grid, compute $G_{4}$ for the tetrahedral environment and for the octahedral environment. Identify the $(\\lambda,\\zeta)$ that maximizes the absolute contrast $\\big|G_{4}^{\\text{tetra}}-G_{4}^{\\text{octa}}\\big|$.\n3. Report, as a single row vector, the value of $G_{2}$ for the tetrahedral environment, the value of $G_{4}$ for the tetrahedral environment using the optimal $(\\lambda,\\zeta)$ found in step 2, and the corresponding numerical values of $\\lambda$ and $\\zeta$.\n\nRound all reported numerical values to four significant figures. The descriptors are dimensionless; report the final numerical values without units and angles are handled via their cosines as specified.",
            "solution": "The Behler–Parrinello atomic symmetry functions (BP-ASF) defined for $G_{2}$ and $G_{4}$ are used to encode local atomic environments. We proceed from their definitions and the specified ideal geometries.\n\nFirst, we compute the cutoff factor at the neighbor distance $r_{0}$. With $r_{0}=2.5$ and $R_{c}=7.5$, we have $\\frac{r_{0}}{R_{c}}=\\frac{1}{3}$, hence\n$$\nf_{c}(r_{0})=\\frac{1}{2}\\Big(\\cos\\big(\\pi/3\\big)+1\\Big)=\\frac{1}{2}\\Big(\\frac{1}{2}+1\\Big)=\\frac{3}{4}.\n$$\nTherefore $f_{c}(r_{0})=\\frac{3}{4}$ and $f_{c}(r_{0})^{2}=\\Big(\\frac{3}{4}\\Big)^{2}=\\frac{9}{16}$.\n\nTask 1: Compute $G_{2}$ for the tetrahedral environment.\n\nIn the tetrahedral environment, all four neighbor distances are $r_{ij}=r_{0}$, and since $R_{s}=r_{0}$,\n$$\n\\exp\\!\\big(-\\eta_{2}\\big(r_{ij}-R_{s}\\big)^{2}\\big)=\\exp(0)=1.\n$$\nThus,\n$$\nG_{2}^{\\text{tetra}}=\\sum_{j=1}^{4}1\\cdot f_{c}(r_{0})=4\\,f_{c}(r_{0})=4\\cdot\\frac{3}{4}=3.\n$$\n\nTask 2: Compute $G_{4}$ for both environments across the parameter grid and identify the optimal $(\\lambda,\\zeta)$.\n\nWe first simplify the radial factor in $G_{4}$. For any pair $(j,k)$ with $r_{ij}=r_{ik}=r_{0}$, and with the given $\\eta_{4}=\\frac{\\ln 2}{2r_{0}^{2}}$, the exponential factor becomes\n$$\n\\exp\\!\\big(-\\eta_{4}(r_{ij}^{2}+r_{ik}^{2})\\big)=\\exp\\!\\Big(-\\frac{\\ln 2}{2r_{0}^{2}}(r_{0}^{2}+r_{0}^{2})\\Big)=\\exp(-\\ln 2)=\\frac{1}{2}.\n$$\nTherefore, for any contributing pair, the radial–cutoff factor is\n$$\n\\exp\\!\\big(-\\eta_{4}(r_{ij}^{2}+r_{ik}^{2})\\big)\\,f_{c}(r_{ij})\\,f_{c}(r_{ik})=\\frac{1}{2}\\cdot f_{c}(r_{0})^{2}=\\frac{1}{2}\\cdot\\frac{9}{16}=\\frac{9}{32}.\n$$\n\nNext, we count angle multiplicities.\n\n- Tetrahedral environment: There are $\\binom{4}{2}=6$ unordered neighbor pairs $(j,k)$ with a single bond–bond angle at the central atom, all with $\\cos\\theta=-\\frac{1}{3}$.\n\n- Octahedral environment: There are $\\binom{6}{2}=15$ unordered neighbor pairs, of which $12$ have $\\cos\\theta=0$ (perpendicular axes) and $3$ have $\\cos\\theta=-1$ (opposite axes).\n\nUsing the $G_{4}$ definition,\n$$\nG_{4}=2^{\\,1-\\zeta}\\sum_{j<k}\\big(1+\\lambda\\cos\\theta_{ijk}\\big)^{\\zeta}\\cdot\\frac{9}{32}.\n$$\n\nHence, for the tetrahedral environment,\n$$\nG_{4}^{\\text{tetra}}(\\lambda,\\zeta)=2^{\\,1-\\zeta}\\cdot 6\\cdot\\big(1+\\lambda\\cdot(-\\tfrac{1}{3})\\big)^{\\zeta}\\cdot\\frac{9}{32}\n=2^{\\,1-\\zeta}\\cdot\\frac{54}{32}\\cdot\\big(1-\\tfrac{\\lambda}{3}\\big)^{\\zeta}\n=2^{\\,1-\\zeta}\\cdot\\frac{27}{16}\\cdot\\big(1-\\tfrac{\\lambda}{3}\\big)^{\\zeta}.\n$$\n\nFor the octahedral environment,\n$$\nG_{4}^{\\text{octa}}(\\lambda,\\zeta)=2^{\\,1-\\zeta}\\left[12\\cdot\\big(1+\\lambda\\cdot 0\\big)^{\\zeta}+3\\cdot\\big(1+\\lambda\\cdot(-1)\\big)^{\\zeta}\\right]\\cdot\\frac{9}{32}\n=2^{\\,1-\\zeta}\\left[12+3\\cdot(1-\\lambda)^{\\zeta}\\right]\\cdot\\frac{9}{32}.\n$$\n\nWe evaluate these for $\\lambda\\in\\{+1,-1\\}$ and $\\zeta\\in\\{1,2,4\\}$.\n\nCase $\\lambda=+1$:\n- $\\zeta=1$:\n$$\nG_{4}^{\\text{tetra}}=2^{0}\\cdot\\frac{27}{16}\\cdot\\Big(1-\\frac{1}{3}\\Big)=\\frac{27}{16}\\cdot\\frac{2}{3}=\\frac{9}{8}=1.125,\n$$\n$$\nG_{4}^{\\text{octa}}=2^{0}\\cdot\\Big[12+3\\cdot(1-1)^{1}\\Big]\\cdot\\frac{9}{32}=12\\cdot\\frac{9}{32}=\\frac{108}{32}=\\frac{27}{8}=3.375,\n$$\n$$\n\\big|G_{4}^{\\text{tetra}}-G_{4}^{\\text{octa}}\\big|=\\Big|\\frac{9}{8}-\\frac{27}{8}\\Big|=\\frac{18}{8}=2.25.\n$$\n- $\\zeta=2$:\n$$\nG_{4}^{\\text{tetra}}=2^{-1}\\cdot\\frac{27}{16}\\cdot\\Big(\\frac{2}{3}\\Big)^{2}=\\frac{27}{32}\\cdot\\frac{4}{9}=\\frac{3}{8}=0.375,\n$$\n$$\nG_{4}^{\\text{octa}}=2^{-1}\\cdot\\Big[12+3\\cdot(0)^{2}\\Big]\\cdot\\frac{9}{32}=\\frac{12}{2}\\cdot\\frac{9}{32}=\\frac{108}{64}=\\frac{27}{16}=1.6875,\n$$\n$$\n\\big|G_{4}^{\\text{tetra}}-G_{4}^{\\text{octa}}\\big|=\\Big|\\frac{3}{8}-\\frac{27}{16}\\Big|=\\frac{21}{16}=1.3125.\n$$\n- $\\zeta=4$:\n$$\nG_{4}^{\\text{tetra}}=2^{-3}\\cdot\\frac{27}{16}\\cdot\\Big(\\frac{2}{3}\\Big)^{4}=\\frac{27}{128}\\cdot\\frac{16}{81}=\\frac{1}{24}\\approx 0.04167,\n$$\n$$\nG_{4}^{\\text{octa}}=2^{-3}\\cdot\\Big[12+3\\cdot(0)^{4}\\Big]\\cdot\\frac{9}{32}=\\frac{12}{8}\\cdot\\frac{9}{32}=\\frac{108}{256}=\\frac{27}{64}=0.421875,\n$$\n$$\n\\big|G_{4}^{\\text{tetra}}-G_{4}^{\\text{octa}}\\big|=\\Big|\\frac{1}{24}-\\frac{27}{64}\\Big| = \\Big|\\frac{8 - 81}{192}\\Big| = \\frac{73}{192} \\approx 0.3802.\n$$\n\nCase $\\lambda=-1$:\n- $\\zeta=1$:\n$$\nG_{4}^{\\text{tetra}}=2^{0}\\cdot\\frac{27}{16}\\cdot\\Big(1+\\frac{1}{3}\\Big)=\\frac{27}{16}\\cdot\\frac{4}{3}=\\frac{9}{4}=2.25,\n$$\n$$\nG_{4}^{\\text{octa}}=2^{0}\\cdot\\Big[12+3\\cdot(1-(-1))^{1}\\Big]\\cdot\\frac{9}{32}=\\Big[12+3\\cdot 2\\Big]\\cdot\\frac{9}{32}=18\\cdot\\frac{9}{32}=\\frac{162}{32}=\\frac{81}{16}=5.0625,\n$$\n$$\n\\big|G_{4}^{\\text{tetra}}-G_{4}^{\\text{octa}}\\big|=\\Big|\\frac{9}{4}-\\frac{81}{16}\\Big|=\\frac{45}{16}=2.8125.\n$$\n- $\\zeta=2$:\n$$\nG_{4}^{\\text{tetra}}=2^{-1}\\cdot\\frac{27}{16}\\cdot\\Big(\\frac{4}{3}\\Big)^{2}=\\frac{27}{32}\\cdot\\frac{16}{9}=\\frac{3}{2}=1.5,\n$$\n$$\nG_{4}^{\\text{octa}}=2^{-1}\\cdot\\Big[12+3\\cdot(2)^{2}\\Big]\\cdot\\frac{9}{32}=\\frac{12+12}{2}\\cdot\\frac{9}{32}=12\\cdot\\frac{9}{32}=\\frac{108}{32}=\\frac{27}{8}=3.375,\n$$\n$$\n\\big|G_{4}^{\\text{tetra}}-G_{4}^{\\text{octa}}\\big|=\\Big|\\frac{3}{2}-\\frac{27}{8}\\Big|=\\frac{15}{8}=1.875.\n$$\n- $\\zeta=4$:\n$$\nG_{4}^{\\text{tetra}}=2^{-3}\\cdot\\frac{27}{16}\\cdot\\Big(\\frac{4}{3}\\Big)^{4}=\\frac{27}{128}\\cdot\\frac{256}{81}=\\frac{2}{3}\\approx 0.6667,\n$$\n$$\nG_{4}^{\\text{octa}}=2^{-3}\\cdot\\Big[12+3\\cdot(2)^{4}\\Big]\\cdot\\frac{9}{32}=\\frac{12+48}{8}\\cdot\\frac{9}{32}=\\frac{60}{8}\\cdot\\frac{9}{32}=\\frac{540}{256}=\\frac{135}{64}=2.109375,\n$$\n$$\n\\big|G_{4}^{\\text{tetra}}-G_{4}^{\\text{octa}}\\big|=\\Big|\\frac{2}{3}-2.109375\\Big| \\approx 1.4427.\n$$\n\nComparing all absolute contrasts, the largest is achieved for $\\lambda=-1$ and $\\zeta=1$, with $\\big|G_{4}^{\\text{tetra}}-G_{4}^{\\text{octa}}\\big|=2.8125$. Physically, $\\lambda=-1$ emphasizes environments with large angles near $\\pi$ through the factor $\\big(1+\\lambda\\cos\\theta\\big)$, which strongly differentiates octahedral coordination (containing $180^{\\circ}$ bonds) from tetrahedral coordination (which has no $180^{\\circ}$ bond–bond angles). Lower $\\zeta$ reduces smoothing and increases sensitivity to these angular differences.\n\nTask 3: Report the requested row vector. Using four significant figures,\n$$\nG_{2}^{\\text{tetra}}=3.000,\\quad G_{4}^{\\text{tetra}}(\\lambda=-1,\\zeta=1)=2.250,\\quad \\lambda=-1,\\quad \\zeta=1.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix} 3.000 & 2.250 & -1 & 1 \\end{pmatrix}}$$"
        },
        {
            "introduction": "Moving beyond simple calculations, the practical application of descriptors requires a principled strategy for parameter selection. An effective set of symmetry functions must be tailored to resolve the key structural features of the material being modeled, such as the distinct shells in its radial distribution function. This design-oriented problem challenges you to think like a model developer, evaluating different strategies to select the optimal parameters for a descriptor set intended to capture the specific radial and angular motifs of a realistic alloy system .",
            "id": "3791305",
            "problem": "You are designing atom-centered symmetry functions for a machine-learned interatomic potential intended to model a close-packed binary alloy. Experimental and atomistic simulation evidence indicate that the radial distribution function has pronounced first- and second-shell peaks at distances approximately $r_{1}\\approx 2.50\\,\\text{\\AA}$ and $r_{2}\\approx 3.60\\,\\text{\\AA}$, with standard deviations of about $\\sigma_{1}\\approx 0.10\\,\\text{\\AA}$ and $\\sigma_{2}\\approx 0.15\\,\\text{\\AA}$, and a weaker, broadened tail extending to a practical cutoff of $R_{c}\\approx 6.0\\,\\text{\\AA}$. The bond-angle distribution exhibits dominant features near $\\theta\\approx 60^{\\circ}$ and $\\theta\\approx 120^{\\circ}$, with spreads of about $\\pm 10^{\\circ}$, consistent with close-packed short-range motifs. You will employ atom-centered symmetry functions (ACSFs) comprising radial channels parameterized by $(\\eta,R_{s})$ and angular channels parameterized by $(\\eta,\\zeta,\\lambda)$, where $\\eta$ controls radial or angular decay/width, $R_{s}$ sets the radial center, $\\zeta$ sharpens or broadens angular selectivity, and $\\lambda$ modulates the parity with respect to the cosine of the bond angle.\n\nUsing only the following fundamental bases: the requirement of smoothness and locality up to a cutoff for atom-centered descriptors, the invariance of descriptors to global rotation/translation/permutation of like atoms, and the standard properties of Gaussian localization and polynomial shaping around a variable such as $\\cos\\theta$, select the most principled strategy for choosing $(\\eta,R_{s},\\zeta,\\lambda)$ so that the descriptor resolves the stated radial shell structure and angular motifs with minimal redundancy while maintaining smoothness and overlap.\n\nWhich option best implements a principled, first-principles strategy?\n\nA. Choose a single radial channel with $R_{s}=3.50\\,\\text{\\AA}$ and a very small width parameter $\\eta=0.10\\,\\text{\\AA}^{-2}$ to ensure smoothness across all shells, and a single angular channel with $\\lambda=+1$ and a very sharp $\\zeta=16$ to strongly emphasize the most likely angle; do not include additional $R_{s}$ values to avoid overparameterization.\n\nB. Estimate the radial resolution needed from the separations and spreads of the first two shells, set a target Gaussian width $\\sigma$ on the order of the smaller shell separation (for example $\\sigma\\approx 0.4\\,\\text{\\AA}$ so that two peaks $\\Delta r\\approx 1.1\\,\\text{\\AA}$ apart are resolved with some overlap), and choose $\\eta\\approx 1/(2\\sigma^{2})\\approx 3.1\\,\\text{\\AA}^{-2}$. Place several $R_{s}$ values aligned to $r_{1}$ and $r_{2}$ and interleaved to tile $[0,R_{c}]$ with spacing comparable to $\\sigma$ (for example $R_{s}\\in\\{2.5,3.0,3.6,4.5,5.5\\}\\,\\text{\\AA}$). For angles, use both parities $\\lambda=\\pm 1$ to discriminate $\\cos\\theta>0$ versus $\\cos\\theta<0$, and select a moderate $\\zeta$ (for example $\\zeta\\in\\{2,3,4\\}$) so that channels respond differently to $\\theta\\approx 60^{\\circ}$ (where $\\cos\\theta\\approx 0.5$) and $\\theta\\approx 120^{\\circ}$ (where $\\cos\\theta\\approx -0.5$), while avoiding over-sharpening.\n\nC. Maximize radial resolution by taking an extremely large $\\eta=50\\,\\text{\\AA}^{-2}$ and a dense uniform grid of $R_{s}$ every $0.10\\,\\text{\\AA}$ up to $R_{c}$, and for angles use only $\\zeta=1$ with no control over $\\lambda$ to reduce the number of channels; rely on the learning algorithm to combine these into smooth features.\n\nD. Determine $\\eta$ from the average coordination number by setting $\\eta=1/z^{2}$ where $z$ is the nearest-neighbor coordination, set $R_{s}=0$ for all radial channels to avoid biasing toward any shell, and for angles draw $\\lambda$ uniformly at random in $[-1,1]$ and $\\zeta$ uniformly from $\\{1,\\dots,16\\}$ to enhance diversity.\n\nE. Match the cutoff scale by fixing $\\eta=1/R_{c}^{2}$ for all channels, choose a single intermediate $R_{s}=R_{c}/2$ to balance inner and outer neighbors, and in angles set only $\\lambda=-1$ with a very high $\\zeta=10$ so that the channels focus on obtuse angles and suppress acute ones, consistent with minimizing short-range noise.\n\nSelect the best option.",
            "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n-   System: A close-packed binary alloy.\n-   Descriptor Type: Atom-centered symmetry functions (ACSFs).\n-   Radial Structure (from RDF): First shell peak at $r_{1}\\approx 2.50\\,\\text{\\AA}$ with spread $\\sigma_{1}\\approx 0.10\\,\\text{\\AA}$. Second shell peak at $r_{2}\\approx 3.60\\,\\text{\\AA}$ with spread $\\sigma_{2}\\approx 0.15\\,\\text{\\AA}$. Practical cutoff at $R_{c}\\approx 6.0\\,\\text{\\AA}$.\n-   Angular Structure (from BAD): Dominant features near $\\theta\\approx 60^{\\circ}$ and $\\theta\\approx 120^{\\circ}$, with spreads of about $\\pm 10^{\\circ}$.\n-   ACSF Parameterization:\n    -   Radial channels (G2 type): $G^{2}(\\eta, R_{s})$. The function is of the form $\\sum_{j} e^{-\\eta (R_{ij} - R_{s})^2} f_c(R_{ij})$. $\\eta$ controls the width and $R_{s}$ the center of the Gaussian.\n    -   Angular channels (G4/G5 type): $G^{4/5}(\\eta, \\zeta, \\lambda)$. The angular part is modulated by a factor $(1 + \\lambda \\cos\\theta_{jik})^\\zeta$. $\\zeta$ controls the angular sharpness and $\\lambda$ the parity.\n-   Fundamental Principles:\n    1.  Descriptors must be smooth and local (vanish at $R_c$).\n    2.  Descriptors must be invariant to rotation, translation, and permutation of like atoms.\n    3.  Descriptors are constructed from basis functions, typically using Gaussian localization for radial parts and polynomial shaping for angular parts.\n-   Objective: Select the most principled strategy for choosing the parameters $(\\eta, R_{s}, \\zeta, \\lambda)$ to resolve the specified structural motifs with minimal redundancy, while maintaining smoothness and overlap.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientific Grounding**: The problem is located squarely within the well-established field of developing machine-learned interatomic potentials. Atom-centered symmetry functions are a canonical descriptor class introduced by Behler and Parrinello. The RDF and BAD features provided are physically realistic for close-packed alloys (e.g., FCC-like local environments). The parameterization and principles are standard. The problem is scientifically sound.\n-   **Well-Posedness**: The problem asks for the most \"principled\" strategy, grounding the evaluation in the established theory and best practices of descriptor design. Given the specific structural information, a logically and physically motivated choice of parameters can be determined, allowing for a decisive evaluation of the given options. The problem is well-posed.\n-   **Objectivity**: The problem statement is framed using precise, quantitative, and technical language. It is free from subjective or biased phrasing.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. It is scientifically grounded, well-posed, and objective, providing a clear basis for a rigorous analytical solution. I will proceed with the derivation and evaluation of the options.\n\n### Derivation of a Principled Strategy\n\nThe goal is to construct a feature vector (a set of descriptor values) for each atom that uniquely and robustly represents its local chemical environment. The basis functions used to build this descriptor must be chosen to resolve the known, physically significant structural features of the system.\n\n**Radial Channel Strategy ($G^2$ functions):**\nThe radial ACSF, $G^2$, is a sum of Gaussians centered at various distances $R_s$ from the central atom. The set of all $G^2$ values for an atom is effectively a discretized and smeared representation of its radial distribution function.\n1.  **Resolution and Width ($\\eta$):** The descriptor must distinguish the two shells at $r_1 \\approx 2.50\\,\\text{\\AA}$ and $r_2 \\approx 3.60\\,\\text{\\AA}$. The separation is $\\Delta r = r_2 - r_1 \\approx 1.1\\,\\text{\\AA}$. To resolve two peaks, the standard deviation, $\\sigma$, of the Gaussian basis functions must be significantly smaller than their separation, $\\Delta r$. A choice on the order of $\\sigma \\approx \\Delta r / 3$ to $\\Delta r / 2$ is typical, ensuring resolution with sufficient overlap for smoothness. For instance, choosing $\\sigma \\approx 0.4\\,\\text{\\AA}$ is a reasonable compromise. The parameter $\\eta$ is related to the Gaussian standard deviation by $\\eta = 1/(2\\sigma^2)$. For $\\sigma = 0.4\\,\\text{\\AA}$, this gives $\\eta = 1/(2 \\times (0.4\\,\\text{\\AA})^2) = 1/(0.32\\,\\text{\\AA}^2) \\approx 3.125\\,\\text{\\AA}^{-2}$. An extremely small $\\eta$ (very wide Gaussian) would merge the two peaks, while an extremely large $\\eta$ (very narrow Gaussian) would lead to a sparse, \"spiky\" representation sensitive to tiny atomic displacements, thus lacking robustness and smoothness.\n2.  **Coverage and Centers ($R_s$):** To describe the entire environment up to the cutoff $R_c \\approx 6.0\\,\\text{\\AA}$, the radial domain $[0, R_c]$ must be tiled with these Gaussians. This requires a set of multiple $R_s$ values. A principled approach places $R_s$ values at the known peak locations ($2.50\\,\\text{\\AA}$ and $3.60\\,\\text{\\AA}$) to capture these features directly. Additional $R_s$ values should be interleaved between them and beyond, up to $R_c$, with a spacing comparable to $\\sigma$, to ensure the entire radial space is covered without significant gaps or excessive redundancy.\n\n**Angular Channel Strategy ($G^4/G^5$ functions):**\nThe angular ACSF probes the distribution of angles $\\theta_{jik}$ between triplets of atoms centered on atom $i$. The angular dependence is controlled by $(1 + \\lambda \\cos\\theta_{jik})^\\zeta$.\n1.  **Parity ($\\lambda$):** The problem states that angular motifs exist near both $\\theta \\approx 60^{\\circ}$ ($\\cos\\theta \\approx 0.5$) and $\\theta \\approx 120^{\\circ}$ ($\\cos\\theta \\approx -0.5$). To distinguish between these, the basis functions must respond differently to positive and negative values of $\\cos\\theta$.\n    -   With $\\lambda = +1$, the term is $(1 + \\cos\\theta)^\\zeta$. This is maximal at $\\theta = 0^{\\circ}$ and zero at $\\theta = 180^{\\circ}$. It is sensitive to acute angles.\n    -   With $\\lambda = -1$, the term is $(1 - \\cos\\theta)^\\zeta$. This is maximal at $\\theta = 180^{\\circ}$ and zero at $\\theta = 0^{\\circ}$. It is sensitive to obtuse angles.\n    Therefore, to resolve both the $60^{\\circ}$ and $120^{\\circ}$ features, it is imperative to use functions with both $\\lambda = +1$ and $\\lambda = -1$.\n2.  **Sharpness ($\\zeta$):** The parameter $\\zeta$ controls the width of the angular features. A very large $\\zeta$ creates an extremely narrow peak, which may fail to capture features with a physical spread (here, $\\pm 10^{\\circ}$) and can make the potential energy surface rough. A very small $\\zeta$ gives a very broad function, failing to resolve different angles. A principled strategy uses a small set of moderate $\\zeta$ values (e.g., $\\zeta \\in \\{1, 2, 4, ...\\}$) to provide a multi-resolution description of the angular environment, allowing the model to learn which level of angular detail is important.\n\n### Evaluation of Options\n\n**A. Choose a single radial channel with $R_{s}=3.50\\,\\text{\\AA}$ and a very small width parameter $\\eta=0.10\\,\\text{\\AA}^{-2}$ to ensure smoothness across all shells, and a single angular channel with $\\lambda=+1$ and a very sharp $\\zeta=16$ to strongly emphasize the most likely angle; do not include additional $R_{s}$ values to avoid overparameterization.**\n-   **Radial:** A single radial channel cannot resolve the two distinct shells at $r_1$ and $r_2$. An $\\eta$ of $0.10\\,\\text{\\AA}^{-2}$ corresponds to $\\sigma = \\sqrt{1/(2\\eta)} \\approx 2.24\\,\\text{\\AA}$, which is an extremely wide Gaussian that would average over both shells, completely losing the essential radial information.\n-   **Angular:** Using only $\\lambda=+1$ makes the descriptor blind to the feature at $120^{\\circ}$. A very high $\\zeta=16$ creates a very sharply peaked function that is likely too sensitive and not robust to the thermal spread of bond angles.\n-   **Verdict:** This strategy is fundamentally flawed. **Incorrect**.\n\n**B. Estimate the radial resolution needed from the separations and spreads of the first two shells, set a target Gaussian width $\\sigma$ on the order of the smaller shell separation (for example $\\sigma\\approx 0.4\\,\\text{\\AA}$ so that two peaks $\\Delta r\\approx 1.1\\,\\text{\\AA}$ apart are resolved with some overlap), and choose $\\eta\\approx 1/(2\\sigma^{2})\\approx 3.1\\,\\text{\\AA}^{-2}$. Place several $R_{s}$ values aligned to $r_{1}$ and $r_{2}$ and interleaved to tile $[0,R_{c}]$ with spacing comparable to $\\sigma$ (for example $R_{s}\\in\\{2.5,3.0,3.6,4.5,5.5\\}\\,\\text{\\AA}$). For angles, use both parities $\\lambda=\\pm 1$ to discriminate $\\cos\\theta>0$ versus $\\cos\\theta<0$, and select a moderate $\\zeta$ (for example $\\zeta\\in\\{2,3,4\\}$) so that channels respond differently to $\\theta\\approx 60^{\\circ}$ (where $\\cos\\theta\\approx 0.5$) and $\\theta\\approx 120^{\\circ}$ (where $\\cos\\theta\\approx -0.5$), while avoiding over-sharpening.**\n-   **Radial:** This option follows the principled derivation perfectly. It correctly relates the required resolution to the peak separation, chooses a sensible width $\\sigma$ and corresponding $\\eta$, and proposes a systematic tiling of radial space with multiple $R_s$ values, including at the known peaks.\n-   **Angular:** This option correctly identifies the need for both $\\lambda=+1$ and $\\lambda=-1$ to resolve acute and obtuse angle motifs. It proposes using a set of moderate $\\zeta$ values, providing a robust, multi-resolution angular description that avoids over-sharpening.\n-   **Verdict:** This option represents the state-of-the-art, physically motivated best practice for ACSF parameterization. **Correct**.\n\n**C. Maximize radial resolution by taking an extremely large $\\eta=50\\,\\text{\\AA}^{-2}$ and a dense uniform grid of $R_{s}$ every $0.10\\,\\text{\\AA}$ up to $R_{c}$, and for angles use only $\\zeta=1$ with no control over $\\lambda$ to reduce the number of channels; rely on the learning algorithm to combine these into smooth features.**\n-   **Radial:** An extremely large $\\eta=50\\,\\text{\\AA}^{-2}$ ($\\sigma = 0.1\\,\\text{\\AA}$) and dense grid is a brute-force approach. It creates a vast, highly correlated, and non-smooth set of basis functions. This violates the principle of minimal redundancy and smoothness, leads to numerical instability, and is computationally inefficient. It is not a principled design.\n-   **Angular:** Using only $\\zeta=1$ provides only a single, very broad angular resolution. \"No control over $\\lambda$\" is ill-defined, but if interpreted as using only one value (e.g., $\\lambda=1$), it fails to resolve the full angular structure.\n-   **Verdict:** This strategy is inefficient, numerically problematic, and not principled. **Incorrect**.\n\n**D. Determine $\\eta$ from the average coordination number by setting $\\eta=1/z^{2}$ where $z$ is the nearest-neighbor coordination, set $R_{s}=0$ for all radial channels to avoid biasing toward any shell, and for angles draw $\\lambda$ uniformly at random in $[-1,1]$ and $\\zeta$ uniformly from $\\{1,\\dots,16\\}$ to enhance diversity.**\n-   **Radial:** Setting $R_s=0$ for all G2-type functions means they are all centered on the origin atom. This completely defeats their purpose, which is to resolve the positions of neighboring atoms in radial shells. The heuristic $\\eta=1/z^2$ has no direct physical justification related to resolving the RDF.\n-   **Angular:** The standard ACSF formulation requires $\\lambda = \\pm 1$. Drawing $\\lambda$ from a continuous random interval $[-1,1]$ is not meaningful within the established framework. Randomly drawing $\\zeta$ is a stochastic, unprincipled approach, contrasting with a systematic choice of a few values to provide multi-resolution.\n-   **Verdict:** This strategy is based on incorrect application of ACSF principles and arbitrary heuristics. **Incorrect**.\n\n**E. Match the cutoff scale by fixing $\\eta=1/R_{c}^{2}$ for all channels, choose a single intermediate $R_{s}=R_{c}/2$ to balance inner and outer neighbors, and in angles set only $\\lambda=-1$ with a very high $\\zeta=10$ so that the channels focus on obtuse angles and suppress acute ones, consistent with minimizing short-range noise.**\n-   **Radial:** Setting $\\eta=1/R_c^2 = 1/(6.0)^2 \\approx 0.028\\,\\text{\\AA}^{-2}$ results in a Gaussian so broad ($\\sigma \\approx 4.2\\,\\text{\\AA}$) that it averages the entire environment up to the cutoff, offering virtually no radial resolution. A single $R_s$ value cannot resolve multiple shells.\n-   **Angular:** Using only $\\lambda=-1$ completely ignores the significant structural motif at $\\theta \\approx 60^{\\circ}$. The justification to \"suppress acute ones\" is a subjective choice that contradicts the problem statement, which requires resolving all stated features.\n-   **Verdict:** This strategy ignores the specific structural information provided and makes poor parameter choices that fail to resolve the known features. **Incorrect**.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "A well-designed descriptor is the foundation of a machine-learned potential, but the model's predictions are only reliable for environments similar to those in its training data. This advanced practice addresses a critical aspect of deploying machine learning models in production: safety and uncertainty quantification. You will implement an out-of-distribution (OOD) detection system that operates directly in the descriptor space, learning the domain of known structures and flagging any novel atomic configurations for which the model's predictions might be unsafe extrapolations .",
            "id": "3791381",
            "problem": "You are tasked with designing and implementing an out-of-distribution detection test in atomic environment descriptor space using density estimation to flag unsafe predictions for new atomic configurations. Work in the context of multiscale materials simulation, where local atomic environments are represented by rotation- and permutation-invariant radial descriptors. The program you produce must be a complete, runnable program that performs the following steps and outputs the required results.\n\nBegin from the following fundamental base: local atomic environments are collections of neighbor atoms around a central site. Let the central atom be at the origin and let the neighbor set be denoted by $\\mathcal{N} = \\{ \\mathbf{r}_i \\}_{i=1}^{n}$ with distances $r_i = \\|\\mathbf{r}_i\\|$. Atomic environment descriptors are constructed as invariant maps from $\\mathcal{N}$ to a fixed-length vector using a radial basis expansion with a cutoff. Let the descriptor dimension be $d$, let the radial centers be $\\{\\mu_k\\}_{k=1}^{d}$, and let the Gaussian width be $\\sigma > 0$. Define a cutoff radius $r_c > 0$. The descriptor components are given by\n$$\nD_k(\\mathcal{N}) = \\begin{cases}\n\\frac{1}{n_c} \\sum\\limits_{i=1}^{n_c} \\exp\\!\\left(-\\dfrac{(r_i - \\mu_k)^2}{2\\sigma^2}\\right) & \\text{if } n_c > 0,\\\\[8pt]\n0 & \\text{if } n_c = 0,\n\\end{cases}\n$$\nwhere $n_c$ is the number of neighbors with $r_i \\le r_c$. This construction yields a descriptor $\\mathbf{D}(\\mathcal{N}) \\in \\mathbb{R}^d$ that is invariant to rotations and permutations of $\\mathcal{N}$. Distances must be interpreted in Angstroms and all distances used must be expressed in Angstroms.\n\nUse probabilistic density estimation on the descriptor space to detect out-of-distribution environments. Fit a multivariate normal density to the training descriptors by estimating the mean vector $\\hat{\\boldsymbol{\\mu}} \\in \\mathbb{R}^d$ and covariance matrix $\\hat{\\boldsymbol{\\Sigma}} \\in \\mathbb{R}^{d \\times d}$ from the training set. For numerical stability, use covariance shrinkage\n$$\n\\hat{\\boldsymbol{\\Sigma}}_{\\text{shrunk}} = (1 - \\alpha)\\,\\hat{\\boldsymbol{\\Sigma}} + \\alpha\\, \\operatorname{diag}(\\hat{\\boldsymbol{\\Sigma}}) + \\varepsilon \\mathbf{I}_d,\n$$\nwith a small $\\varepsilon > 0$ and shrinkage weight $\\alpha \\in [0,1)$. Given a descriptor $\\mathbf{x} \\in \\mathbb{R}^d$, compute the log-likelihood under the fitted density\n$$\n\\log \\hat{p}(\\mathbf{x}) = -\\tfrac{1}{2}\\Big[ (\\mathbf{x} - \\hat{\\boldsymbol{\\mu}})^\\top \\hat{\\boldsymbol{\\Sigma}}_{\\text{shrunk}}^{-1} (\\mathbf{x} - \\hat{\\boldsymbol{\\mu}}) + d \\log(2\\pi) + \\log \\det(\\hat{\\boldsymbol{\\Sigma}}_{\\text{shrunk}}) \\Big].\n$$\nCalibrate a decision threshold $\\tau$ as the $q$-quantile of the training log-likelihoods (choose $q = 0.05$). A new configuration is flagged as unsafe if its log-likelihood is below $\\tau$, i.e., if $\\log \\hat{p}(\\mathbf{x}) < \\tau$.\n\nTraining data generation: Construct $N_{\\mathrm{train}}$ training environments, each comprising two coordination shells with small thermal-like jitter. For each training environment, sample $n_1$ neighbors at radius $r_1$ and $n_2$ neighbors at radius $r_2$, with independent Gaussian jitter of standard deviation $s$ added to each radius, and discard any neighbors with distances exceeding $r_c$ when forming descriptors. Use the following fixed parameters for the entire problem:\n- Descriptor centers: $\\mu_k$ linearly spaced between $1.5$ and $4.0$ Angstroms inclusive with $d = 8$ components.\n- Gaussian width: $\\sigma = 0.15$ Angstroms.\n- Cutoff radius: $r_c = 4.5$ Angstroms.\n- Training shell parameters: $n_1 = 12$ at $r_1 = 2.5$ Angstroms, $n_2 = 6$ at $r_2 = 3.5$ Angstroms, with jitter $s = 0.05$ Angstroms.\n- Number of training environments: $N_{\\mathrm{train}} = 200$.\n- Covariance shrinkage parameters: $\\alpha = 0.1$, $\\varepsilon = 10^{-6}$.\n- Quantile for threshold: $q = 0.05$.\n\nTo ensure universal applicability across modern programming languages, represent environments by their neighbor distance lists only (no angles are required). All distances must be in Angstroms. The descriptor calculation should use only these distances and the specified parameters. The learning and detection steps should operate entirely in descriptor space.\n\nTest suite: Implement the following six test cases, each defined by a set of neighbor distances (in Angstroms). For stochastic generation, use fixed random seeds per test case to ensure determinism. In each case, distances are independently sampled from a normal distribution centered at the specified radius, with the specified count and jitter, then truncated to nonnegative values; any distances larger than $r_c$ must be excluded by the descriptor rule.\n\n- Case $1$ (in-distribution, small jitter): $n_1 = 12$ at $r_1 = 2.52$ with jitter $s_1 = 0.02$; $n_2 = 6$ at $r_2 = 3.48$ with jitter $s_2 = 0.02$.\n- Case $2$ (empty environment): no neighbors.\n- Case $3$ (boundary neighbors): $n_b = 2$ neighbors at exactly $r_c = 4.5$, jitter $s_b = 0.0$.\n- Case $4$ (short-range anomaly): $n = 6$ neighbors at $r = 1.2$ with jitter $s = 0.01$.\n- Case $5$ (high coordination density): $n_1 = 30$ at $r_1 = 2.5$ with jitter $s_1 = 0.05$; $n_2 = 15$ at $r_2 = 3.5$ with jitter $s_2 = 0.05$.\n- Case $6$ (shifted shells): $n_1 = 12$ at $r_1 = 2.8$ with jitter $s_1 = 0.05$; $n_2 = 6$ at $r_2 = 3.0$ with jitter $s_2 = 0.05$.\n\nFor each case, compute the descriptor $\\mathbf{D}$, the standardized descriptor using training statistics, the Gaussian log-likelihood under the trained density, and determine whether it is flagged unsafe as per the threshold rule. The final output must aggregate the boolean unsafe flags in order for the six cases.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5,result6]\"). Each result must be a boolean value, with True meaning \"unsafe\" and False meaning \"safe\".",
            "solution": "The problem requires the design and implementation of an out-of-distribution detection mechanism for atomic environments, a critical task for ensuring the reliability of machine learning models in materials simulation. The solution proceeds in three main stages: first, defining a suitable representation for atomic environments; second, building a probabilistic model of the distribution of these representations from a training dataset; and third, using this model to classify new environments as either in-distribution (safe) or out-of-distribution (unsafe).\n\n**1. Atomic Environment Descriptor**\n\nAn atomic environment, consisting of a collection of neighbor atoms $\\mathcal{N} = \\{ \\mathbf{r}_i \\}_{i=1}^{n}$ around a central atom, must be transformed into a fixed-length numerical vector, known as a descriptor, that is invariant to rotation, translation, and permutation of identical atoms. The problem specifies a radial descriptor, which depends only on the distances $r_i = \\|\\mathbf{r}_i\\|$ of the neighbor atoms from the central atom.\n\nThe descriptor $\\mathbf{D}(\\mathcal{N})$ is an $d$-dimensional vector, where each component $D_k$ is computed by projecting the set of neighbor distances onto a radial basis function. This basis consists of $d$ Gaussian functions centered at predefined radii $\\{\\mu_k\\}_{k=1}^{d}$. A cutoff radius $r_c > 0$ is defined, and only neighbors within this radius contribute to the descriptor. Let $n_c$ be the number of neighbors with $r_i \\le r_c$. The $k$-th component of the descriptor is given by:\n$$\nD_k(\\mathcal{N}) = \\begin{cases}\n\\frac{1}{n_c} \\sum\\limits_{i=1}^{n_c} \\exp\\!\\left(-\\dfrac{(r_i - \\mu_k)^2}{2\\sigma^2}\\right) & \\text{if } n_c > 0, \\\\\n0 & \\text{if } n_c = 0.\n\\end{cases}\n$$\nThe parameter $\\sigma$ controls the width of the Gaussian basis functions. The normalization by $1/n_c$ makes the descriptor an average representation, independent of the coordination number within the cutoff sphere.\n\nThe fixed parameters for this descriptor are:\n-   Dimension: $d = 8$.\n-   Radial centers $\\{\\mu_k\\}_{k=1}^{8}$: linearly spaced from $1.5$ to $4.0$ Angstroms.\n-   Gaussian width: $\\sigma = 0.15$ Angstroms.\n-   Cutoff radius: $r_c = 4.5$ Angstroms.\n\n**2. Probabilistic Density Estimation and Out-of-Distribution Detection**\n\nThe core of the detection method lies in modeling the probability density of descriptors corresponding to known, valid atomic environments. We assume that the descriptors of such \"in-distribution\" configurations can be modeled by a multivariate normal distribution.\n\nFirst, a training set of $N_{\\mathrm{train}} = 200$ atomic environments is generated. Each environment is constructed by sampling neighbor distances from normal distributions to simulate thermal vibrations around ideal coordination shells: $n_1 = 12$ neighbors around $r_1 = 2.5$ Å and $n_2 = 6$ neighbors around $r_2 = 3.5$ Å, with a positional jitter standard deviation of $s = 0.05$ Å. For each of these $N_{\\mathrm{train}}$ environments, a descriptor vector is computed, forming the training set $\\{\\mathbf{x}_i\\}_{i=1}^{N_{\\mathrm{train}}}$.\n\nFrom this training set, we estimate the parameters of the multivariate normal distribution $\\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$:\n-   The mean vector $\\hat{\\boldsymbol{\\mu}}$ is the sample mean of the training descriptors.\n-   The covariance matrix $\\hat{\\boldsymbol{\\Sigma}}$ is the sample covariance.\n\nTo ensure the covariance matrix is well-conditioned and invertible, especially with a limited number of samples, a shrinkage regularization is applied:\n$$\n\\hat{\\boldsymbol{\\Sigma}}_{\\text{shrunk}} = (1 - \\alpha)\\,\\hat{\\boldsymbol{\\Sigma}} + \\alpha\\, \\operatorname{diag}(\\hat{\\boldsymbol{\\Sigma}}) + \\varepsilon \\mathbf{I}_d\n$$\nwhere $\\alpha = 0.1$ is the shrinkage weight, $\\varepsilon = 10^{-6}$ is a small regularization term to guarantee positive definiteness, and $\\mathbf{I}_d$ is the $d \\times d$ identity matrix.\n\nWith the fitted model $\\hat{p}(\\mathbf{x}) \\sim \\mathcal{N}(\\hat{\\boldsymbol{\\mu}}, \\hat{\\boldsymbol{\\Sigma}}_{\\text{shrunk}})$, we can evaluate the log-likelihood of any new descriptor $\\mathbf{x}$:\n$$\n\\log \\hat{p}(\\mathbf{x}) = -\\tfrac{1}{2}\\left[ (\\mathbf{x} - \\hat{\\boldsymbol{\\mu}})^\\top \\hat{\\boldsymbol{\\Sigma}}_{\\text{shrunk}}^{-1} (\\mathbf{x} - \\hat{\\boldsymbol{\\mu}}) + d \\log(2\\pi) + \\log \\det(\\hat{\\boldsymbol{\\Sigma}}_{\\text{shrunk}}) \\right]\n$$\nThe term $(\\mathbf{x} - \\hat{\\boldsymbol{\\mu}})^\\top \\hat{\\boldsymbol{\\Sigma}}_{\\text{shrunk}}^{-1} (\\mathbf{x} - \\hat{\\boldsymbol{\\mu}})$ is the squared Mahalanobis distance, which measures the distance of $\\mathbf{x}$ from the center of the distribution, accounting for variance and correlation.\n\nA decision threshold $\\tau$ is established to distinguish between in-distribution and out-of-distribution samples. This threshold is calibrated by computing the log-likelihood for all training samples and finding the $q=0.05$ quantile. This means that $5\\%$ of the training data will have a log-likelihood below $\\tau$.\nA new environment with descriptor $\\mathbf{x}_{\\text{new}}$ is then classified as \"unsafe\" (out-of-distribution) if its log-likelihood falls below this threshold:\n$$\n\\log \\hat{p}(\\mathbf{x}_{\\text{new}}) < \\tau\n$$\n\n**3. Implementation and Evaluation**\n\nThe algorithm is implemented by first performing the training phase: generating $N_{\\mathrm{train}}$ environments, computing their descriptors, fitting the shrunken multivariate Gaussian model, and calculating the decision threshold $\\tau$. Determinism is ensured by using a fixed random seed for the training data generation.\n\nNext, the test phase evaluates six distinct atomic environments:\n-   **Case 1**: An in-distribution-like environment with slightly different mean radii and jitter.\n-   **Case 2**: An empty environment with no neighbors.\n-   **Case 3**: An environment with two neighbors exactly at the cutoff radius.\n-   **Case 4**: An anomalous environment with neighbors at an unusually short distance.\n-   **Case 5**: An environment with an atypically high coordination number.\n-   **Case 6**: An environment with valid coordination but shifted shell radii.\n\nFor each test case, neighbor distances are generated (using a unique fixed seed for each stochastic case), the corresponding descriptor is computed, and its log-likelihood is calculated using the trained model. This log-likelihood is then compared against the threshold $\\tau$ to determine if the environment is unsafe. The final output is an ordered collection of these boolean safety flags.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Implements the out-of-distribution detection test for atomic environments.\n    \"\"\"\n    # -------------------\n    # 1. Define Parameters\n    # -------------------\n    \n    # Descriptor parameters\n    D_DIM = 8\n    MU_K = np.linspace(1.5, 4.0, D_DIM)\n    SIGMA = 0.15\n    R_CUTOFF = 4.5\n\n    # Training parameters\n    N_TRAIN = 200\n    TRAIN_N1 = 12\n    TRAIN_R1 = 2.5\n    TRAIN_N2 = 6\n    TRAIN_R2 = 3.5\n    TRAIN_S = 0.05\n\n    # Density model parameters\n    ALPHA = 0.1\n    EPSILON = 1e-6\n    QUANTILE_Q = 0.05\n    \n    # Random seed for training data generation\n    TRAIN_SEED = 42\n\n    # -------------------\n    # 2. Helper Functions\n    # -------------------\n\n    def compute_descriptor(distances, mus, sigma, r_c):\n        \"\"\"\n        Computes the radial descriptor for a given set of neighbor distances.\n        \"\"\"\n        distances_arr = np.array(distances, dtype=float)\n        neighbors_in_cutoff = distances_arr[distances_arr <= r_c]\n        n_c = len(neighbors_in_cutoff)\n\n        if n_c == 0:\n            return np.zeros_like(mus)\n\n        # Use broadcasting for efficient computation\n        # neighbors_in_cutoff shape: (n_c,) -> (n_c, 1)\n        # mus shape: (d,) -> (1, d)\n        term = -(neighbors_in_cutoff[:, np.newaxis] - mus[np.newaxis, :])**2 / (2 * sigma**2)\n        gaussians = np.exp(term)\n        \n        # Sum over neighbors and normalize by n_c\n        descriptor = np.sum(gaussians, axis=0) / n_c\n        return descriptor\n\n    def log_likelihood_gaussian(x, mu, cov_inv, log_det_cov, d):\n        \"\"\"\n        Computes the log-likelihood of x under a multivariate Gaussian distribution.\n        \"\"\"\n        diff = x - mu\n        mahalanobis_sq = diff.T @ cov_inv @ diff\n        log_p = -0.5 * (mahalanobis_sq + d * np.log(2 * np.pi) + log_det_cov)\n        return log_p\n\n    # -------------------\n    # 3. Training Phase\n    # -------------------\n\n    # Generate training environments\n    np.random.seed(TRAIN_SEED)\n    training_environments = []\n    for _ in range(N_TRAIN):\n        # Sample distances for two shells with jitter\n        dists1 = np.random.normal(loc=TRAIN_R1, scale=TRAIN_S, size=TRAIN_N1)\n        dists2 = np.random.normal(loc=TRAIN_R2, scale=TRAIN_S, size=TRAIN_N2)\n        # Concatenate and truncate to be non-negative\n        all_dists = np.concatenate([dists1, dists2])\n        all_dists[all_dists < 0] = 0.0\n        training_environments.append(all_dists.tolist())\n\n    # Compute training descriptors\n    training_descriptors = np.array([\n        compute_descriptor(dists, MU_K, SIGMA, R_CUTOFF) for dists in training_environments\n    ])\n\n    # Fit Gaussian model\n    mu_hat = np.mean(training_descriptors, axis=0)\n    cov_hat = np.cov(training_descriptors, rowvar=False)\n\n    # Apply covariance shrinkage\n    cov_shrunk = (\n        (1 - ALPHA) * cov_hat +\n        ALPHA * np.diag(np.diag(cov_hat)) +\n        EPSILON * np.identity(D_DIM)\n    )\n\n    # Pre-compute inverse and log-determinant for efficiency\n    cov_shrunk_inv = linalg.inv(cov_shrunk)\n    sign, log_det_cov_shrunk = np.linalg.slogdet(cov_shrunk)\n    if sign <= 0:\n        # This should not happen with the given regularization\n        raise ValueError(\"Covariance matrix is not positive definite.\")\n\n    # Calibrate detection threshold\n    log_likelihoods_train = np.array([\n        log_likelihood_gaussian(x, mu_hat, cov_shrunk_inv, log_det_cov_shrunk, D_DIM)\n        for x in training_descriptors\n    ])\n    threshold = np.quantile(log_likelihoods_train, QUANTILE_Q)\n\n    # -------------------\n    # 4. Testing Phase\n    # -------------------\n\n    test_cases_params = [\n        # Case 1: In-distribution, small jitter\n        {'distributions': [(2.52, 0.02, 12), (3.48, 0.02, 6)], 'seed': 1},\n        # Case 2: Empty environment\n        {'distributions': [], 'seed': 2},\n        # Case 3: Boundary neighbors\n        {'distances': [4.5, 4.5], 'seed': 3},\n        # Case 4: Short-range anomaly\n        {'distributions': [(1.2, 0.01, 6)], 'seed': 4},\n        # Case 5: High coordination density\n        {'distributions': [(2.5, 0.05, 30), (3.5, 0.05, 15)], 'seed': 5},\n        # Case 6: Shifted shells\n        {'distributions': [(2.8, 0.05, 12), (3.0, 0.05, 6)], 'seed': 6},\n    ]\n\n    results = []\n    for params in test_cases_params:\n        np.random.seed(params['seed'])\n        \n        if 'distances' in params: # Deterministic case\n            test_distances = params['distances']\n        else: # Stochastic case\n            all_dists = []\n            for r_mean, r_jitter, n_atoms in params['distributions']:\n                dists = np.random.normal(loc=r_mean, scale=r_jitter, size=n_atoms)\n                all_dists.append(dists)\n            if all_dists:\n                test_distances = np.concatenate(all_dists)\n                test_distances[test_distances < 0] = 0.0\n            else:\n                test_distances = []\n\n        # Compute descriptor and log-likelihood for the test case\n        test_descriptor = compute_descriptor(test_distances, MU_K, SIGMA, R_CUTOFF)\n        test_log_likelihood = log_likelihood_gaussian(\n            test_descriptor, mu_hat, cov_shrunk_inv, log_det_cov_shrunk, D_DIM\n        )\n\n        # Flag as unsafe if below threshold\n        is_unsafe = test_log_likelihood < threshold\n        results.append(is_unsafe)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}