{
    "hands_on_practices": [
        {
            "introduction": "The core event in any surface hopping simulation is the \"hop\" itself, where the system transitions between potential energy surfaces. This is not merely a change in potential energy; to conserve the total energy of the system, the nuclear kinetic energy must be adjusted instantaneously. This foundational exercise  guides you through the implementation of this critical momentum rescaling procedure, a cornerstone of methods like Tully's Fewest Switches Surface Hopping.",
            "id": "5295218",
            "problem": "Consider a two-state, two-dimensional avoided crossing model for nonadiabatic molecular dynamics in atomic units (electron mass units for mass, Hartree for energy, Bohr for length, and atomic unit for momentum). The diabatic electronic Hamiltonian is defined as\n$$\n\\hat{H}_{\\mathrm{d}}(\\mathbf{R}) =\n\\begin{pmatrix}\na\\, x & \\Delta/2 \\\\\n\\Delta/2 & -a\\, x\n\\end{pmatrix},\n$$\nwhere $\\mathbf{R} = (x,y)$ is the nuclear position vector, $a$ is a constant with units of energy per length, and $\\Delta$ is a constant with units of energy. The corresponding adiabatic energies at position $\\mathbf{R}$ are\n$$\nE_{\\pm}(x) = \\pm \\sqrt{(a x)^2 + (\\Delta/2)^2}.\n$$\nA surface hop at fixed $\\mathbf{R}$ changes the electronic state energy from the current surface to the target surface, with energy difference\n$$\n\\Delta E = E_{\\mathrm{target}}(x) - E_{\\mathrm{source}}(x).\n$$\nClassical nuclei have masses $\\mathbf{m} = (m_x, m_y)$ and momenta $\\mathbf{p} = (p_x, p_y)$. The classical nuclear kinetic energy is\n$$\nK(\\mathbf{p},\\mathbf{m}) = \\frac{p_x^2}{2 m_x} + \\frac{p_y^2}{2 m_y}.\n$$\nIn Tully’s fewest switches surface hopping, to conserve the total energy of the quantum-classical system at the instant of the hop, the nuclear momentum must be adjusted along the nonadiabatic coupling direction. For this Hamiltonian, the nonadiabatic coupling is collinear with the $x$ axis at all $\\mathbf{R}$, so the momentum rescaling vector is along $\\hat{\\mathbf{e}}_x$. The algorithm must determine the scalar momentum adjustment that changes only the $x$ component of the momentum, resulting in a new momentum $\\mathbf{p}' = (p_x', p_y')$ with $p_y' = p_y$ and $p_x'$ determined by energy conservation and minimal change consistent with the hop direction (kinetic energy decrease for $\\Delta E > 0$ and increase for $\\Delta E < 0$). If a real-valued solution for the rescaling does not exist for an upward hop ($\\Delta E > 0$), the hop is rejected and the momentum is left unchanged.\n\nStarting from the definition of total energy as the sum of classical nuclear kinetic energy and the adiabatic electronic energy at fixed $\\mathbf{R}$, and using the constraint that only the component of momentum along the nonadiabatic coupling direction is changed during a hop, derive the expression for the adjusted momentum and implement a program that, for each test case, computes:\n- the boolean hop success indicator (true if an energy-conserving rescaling exists and is applied, false if the hop is rejected),\n- the change in momentum components $(\\Delta p_x, \\Delta p_y)$, expressed in atomic units,\n- the absolute energy conservation error, defined as $\\left| \\big(K(\\mathbf{p}',\\mathbf{m}) + E_{\\mathrm{target}}(x)\\big) - \\big(K(\\mathbf{p},\\mathbf{m}) + E_{\\mathrm{source}}(x)\\big) \\right|$, expressed in Hartree.\n\nUse the following test suite, where each case is specified by $(m_x, m_y, a, \\Delta, x, y, p_x, p_y, s)$, with $s = +1$ indicating a hop from the lower to the upper adiabatic surface (upward hop) and $s = -1$ indicating a hop from the upper to the lower adiabatic surface (downward hop):\n1. $(m_x, m_y, a, \\Delta, x, y, p_x, p_y, s) = (1836, 1836, 0.02, 0.05, 0.5, 0.0, 5.0, 1.0, +1)$.\n2. $(m_x, m_y, a, \\Delta, x, y, p_x, p_y, s) = (1836, 1836, 0.02, 0.05, 0.5, 0.0, 0.05, 0.0, +1)$.\n3. $(m_x, m_y, a, \\Delta, x, y, p_x, p_y, s) = (1836, 1836, 0.02, 0.05, 0.5, 0.0, 5.0, 1.0, -1)$.\n4. $(m_x, m_y, a, \\Delta, x, y, p_x, p_y, s) = (5000, 1000, 0.03, 0.02, 1.0, 0.2, 40.0, 20.0, +1)$.\n5. $(m_x, m_y, a, \\Delta, x, y, p_x, p_y, s) = (1836, 1836, 0.02, 0.001, 0.0, 0.0, 3.0, 0.0, +1)$.\n\nFor each case, compute $\\Delta E$ using $E_{\\pm}(x)$ and $s$, perform the momentum adjustment along $\\hat{\\mathbf{e}}_x$, and report the hop success, $\\Delta p_x$, $\\Delta p_y$, and the absolute energy conservation error. If the hop is rejected, report the hop success as false, $\\Delta p_x = 0$, $\\Delta p_y = 0$, and compute the absolute energy conservation error with the unmodified momentum and unmodified electronic state (so the error should be zero).\n\nYour program should produce a single line of output containing the results for the five test cases as a comma-separated list of lists, each inner list being of the form $[\\mathrm{success}, \\Delta p_x, \\Delta p_y, \\mathrm{error}]$, enclosed in square brackets. For example, the output format must be\n$$\n[\\,[\\mathrm{success}_1, \\Delta p_{x,1}, \\Delta p_{y,1}, \\mathrm{error}_1], \\ldots, [\\mathrm{success}_5, \\Delta p_{x,5}, \\Delta p_{y,5}, \\mathrm{error}_5]\\,].\n$$\nVerify that the absolute energy conservation error is below $10^{-12}$ Hartree for all successful hops.",
            "solution": "The user wants me to derive the momentum adjustment rule for a surface hop in a two-state model and implement it as a Python program.\n\n### Problem Validation\nThe problem statement is scientifically sound, well-posed, and objective. It provides a standard model from computational physics (an avoided crossing model), defines all relevant physical quantities and parameters in consistent atomic units, and specifies a clear algorithm (momentum rescaling in Tully's surface hopping). The nonadiabatic coupling being directed along the $x$-axis is a correct consequence of the given Hamiltonian's dependence only on the $x$ coordinate. The test cases are well-defined, and the required output format is unambiguous. The problem is deemed **valid**.\n\n### Derivation of the Momentum Adjustment\nThe core principle is the conservation of total energy during an instantaneous electronic transition (a \"hop\"). The total energy $E_{\\mathrm{tot}}$ is the sum of the nuclear kinetic energy $K(\\mathbf{p}, \\mathbf{m})$ and the electronic potential energy $E_{\\mathrm{elec}}(x)$. Let the initial state be defined by momentum $\\mathbf{p}=(p_x, p_y)$ and electronic energy $E_{\\mathrm{source}}(x)$, and the final state by momentum $\\mathbf{p}'=(p_x', p_y')$ and electronic energy $E_{\\mathrm{target}}(x)$.\n\nTotal energy conservation implies:\n$$\nE_{\\mathrm{tot, final}} = E_{\\mathrm{tot, initial}}\n$$\n$$\nK(\\mathbf{p}', \\mathbf{m}) + E_{\\mathrm{target}}(x) = K(\\mathbf{p}, \\mathbf{m}) + E_{\\mathrm{source}}(x)\n$$\nLet $\\Delta E = E_{\\mathrm{target}}(x) - E_{\\mathrm{source}}(x)$ be the change in electronic energy. The change in kinetic energy must compensate for this:\n$$\nK(\\mathbf{p}', \\mathbf{m}) = K(\\mathbf{p}, \\mathbf{m}) - \\Delta E\n$$\nThe problem states that the momentum adjustment is performed only along the direction of the nonadiabatic coupling, which is given as the $x$-axis ($\\hat{\\mathbf{e}}_x$). This means only the $p_x$ component of the momentum changes, while $p_y$ remains constant ($p_y' = p_y$).\n\nExpanding the kinetic energy terms:\n$$\n\\frac{(p_x')^2}{2 m_x} + \\frac{(p_y')^2}{2 m_y} = \\frac{p_x^2}{2 m_x} + \\frac{p_y^2}{2 m_y} - \\Delta E\n$$\nSince $p_y' = p_y$, the terms involving $p_y$ cancel out:\n$$\n\\frac{(p_x')^2}{2 m_x} = \\frac{p_x^2}{2 m_x} - \\Delta E\n$$\nSolving for $(p_x')^2$:\n$$\n(p_x')^2 = p_x^2 - 2 m_x \\Delta E\n$$\nThis yields two possible solutions for the new momentum component $p_x'$:\n$$\np_x' = \\pm \\sqrt{p_x^2 - 2 m_x \\Delta E}\n$$\n\n### Analysis of Hop Scenarios\nLet's define the quantity under the square root as $\\alpha = p_x^2 - 2 m_x \\Delta E$. For $p_x'$ to be a real number, we must have $\\alpha \\ge 0$.\n\nThe adiabatic energies are given by $E_{\\pm}(x) = \\pm \\sqrt{(ax)^2 + (\\Delta/2)^2}$.\n\n**1. Upward Hop ($s = +1$)**\nThe hop is from the lower surface $E_-(x)$ to the upper surface $E_+(x)$.\n$E_{\\mathrm{source}}(x) = E_-(x)$ and $E_{\\mathrm{target}}(x) = E_+(x)$.\nThe change in electronic energy is $\\Delta E = E_+(x) - E_-(x) = 2 \\sqrt{(ax)^2 + (\\Delta/2)^2}$. Since the square root is always non-negative, $\\Delta E \\ge 0$. Kinetic energy must be consumed to fuel the electronic excitation.\n\nFor a real solution for $p_x'$ to exist, we require $\\alpha \\ge 0$:\n$$\np_x^2 - 2 m_x \\Delta E \\ge 0 \\implies \\frac{p_x^2}{2m_x} \\ge \\Delta E\n$$\nThis condition means the kinetic energy associated with the $x$-component of motion must be at least as large as the energy required for the electronic transition. If this condition is not met ($\\alpha < 0$), there is not enough kinetic energy along the coupling direction to pay for the hop. The hop is rejected, or \"frustrated.\" In this case, the hop is unsuccessful, and the momenta are unchanged ($\\Delta p_x = 0$, $\\Delta p_y = 0$).\n\nIf the hop is successful ($\\alpha \\ge 0$), we must choose between $p_x' = \\sqrt{\\alpha}$ and $p_x' = -\\sqrt{\\alpha}$. The problem states to use the solution with \"minimal change consistent with the hop direction.\" This is interpreted as choosing the value of $p_x'$ that is closest to the original $p_x$. This corresponds to choosing the root that has the same sign as the original $p_x$, effectively reducing its magnitude:\n$$\np_x' = \\mathrm{sign}(p_x) \\sqrt{\\alpha}\n$$\n\n**2. Downward Hop ($s = -1$)**\nThe hop is from the upper surface $E_+(x)$ to the lower surface $E_-(x)$.\n$E_{\\mathrm{source}}(x) = E_+(x)$ and $E_{\\mathrm{target}}(x) = E_-(x)$.\nThe change in electronic energy is $\\Delta E = E_-(x) - E_+(x) = -2 \\sqrt{(ax)^2 + (\\Delta/2)^2}$. In this case, $\\Delta E \\le 0$. Energy is released from the electronic system and converted into nuclear kinetic energy.\n\nThe condition $\\alpha \\ge 0$ becomes $p_x^2 - 2 m_x \\Delta E \\ge 0$. Since $m_x > 0$ and $\\Delta E \\le 0$, the term $-2m_x\\Delta E$ is non-negative. Thus, $\\alpha$ is always non-negative for a downward hop. A downward hop is never rejected for energetic reasons.\n\nAs with the upward hop, we choose the solution for $p_x'$ that represents the minimal change, which again corresponds to preserving the sign of $p_x$:\n$$\np_x' = \\mathrm{sign}(p_x) \\sqrt{\\alpha} = \\mathrm{sign}(p_x) \\sqrt{p_x^2 - 2 m_x \\Delta E}\n$$\nThis choice increases the magnitude of the momentum along the coupling direction. If $p_x=0$, the two roots $\\pm\\sqrt{\\alpha}$ represent equal changes. By convention, we can choose the positive root, which corresponds to giving the particle a \"kick\" in the positive direction of the coupling vector. The function `np.copysign` conveniently handles this logic, including the $p_x=0$ case where it defaults to the positive root.\n\n### Final Algorithm Summary\nFor each test case $(m_x, m_y, a, \\Delta, x, y, p_x, p_y, s)$:\n1. Calculate the energy gap for the hop, $\\Delta E = s \\cdot 2 \\sqrt{(ax)^2 + (\\Delta/2)^2}$.\n2. Calculate $\\alpha = p_x^2 - 2 m_x \\Delta E$.\n3. If the hop is upward ($s=+1$) and $\\alpha < 0$, the hop is rejected. The result is `[false, 0.0, 0.0, 0.0]`.\n4. Otherwise, the hop is successful.\n   a. Calculate the new momentum $p_x' = \\mathrm{copysign}(\\sqrt{\\alpha}, p_x)$.\n   b. Calculate the momentum change $\\Delta p_x = p_x' - p_x$ and $\\Delta p_y = 0$.\n   c. Verify energy conservation by calculating the error: $\\left| (K(\\mathbf{p}') + E_{\\mathrm{target}}) - (K(\\mathbf{p}) + E_{\\mathrm{source}}) \\right|$, which should be near machine precision.\n   d. The result is `[true, $\\Delta p_x$, $\\Delta p_y$, error]`.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases for the surface hopping problem.\n    \"\"\"\n\n    def compute_hop(params):\n        \"\"\"\n        Computes the momentum adjustment for a single surface hop event according to\n        Tully's fewest switches surface hopping algorithm rules.\n\n        Args:\n            params (tuple): A tuple containing the parameters for the hop event:\n                            (mx, my, a, delta_param, x, y, px, py, s)\n\n        Returns:\n            list: A list containing [success, delta_px, delta_py, error].\n        \"\"\"\n        mx, my, a, delta_param, x, y, px, py, s = params\n\n        # 1. Calculate adiabatic energies and the energy difference for the hop.\n        #    The adiabatic energies are E_pm = +/- sqrt((a*x)^2 + (Delta/2)^2).\n        E_gap_half = np.sqrt((a * x)**2 + (delta_param / 2)**2)\n        delta_E = s * 2 * E_gap_half\n\n        if s == 1:  # Upward hop: from E- to E+\n            E_source = -E_gap_half\n            E_target = E_gap_half\n        else:  # Downward hop: from E+ to E-\n            E_source = E_gap_half\n            E_target = -E_gap_half\n\n        # 2. Calculate the initial total energy for the final error check.\n        K_initial = px**2 / (2 * mx) + py**2 / (2 * my)\n        E_total_initial = K_initial + E_source\n\n        # 3. Determine if the hop is energetically possible.\n        #    From energy conservation, (p_x')^2 = p_x^2 - 2*m_x*delta_E.\n        #    The term under the square root, alpha, must be non-negative.\n        alpha = px**2 - 2 * mx * delta_E\n\n        if s == 1 and alpha < 0:\n            # Hop is rejected (\"frustrated\") as there is insufficient kinetic energy.\n            success = False\n            delta_px = 0.0\n            delta_py = 0.0\n            # As per the problem, the error is 0 since momentum and state are unchanged.\n            error = 0.0\n            return [success, delta_px, delta_py, error]\n\n        # 4. If the hop is not rejected, calculate the new momentum and related quantities.\n        success = True\n        \n        sqrt_alpha = np.sqrt(alpha)\n        # Choose the root for p_x' that corresponds to minimal change, which means\n        # preserving the sign of p_x. np.copysign handles the px=0 case by\n        # convention, assigning the sign of +0.0 (positive).\n        px_new = np.copysign(sqrt_alpha, px)\n            \n        py_new = py  # Momentum component orthogonal to the coupling is unchanged.\n\n        delta_px = px_new - px\n        delta_py = 0.0\n\n        # 5. Calculate the absolute energy conservation error to verify the calculation.\n        K_final = px_new**2 / (2 * mx) + py_new**2 / (2 * my)\n        E_total_final = K_final + E_target\n        error = np.abs(E_total_final - E_total_initial)\n\n        return [success, delta_px, delta_py, error]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (mx, my, a, delta, x, y, px, py, s)\n        (1836, 1836, 0.02, 0.05, 0.5, 0.0, 5.0, 1.0, +1),\n        (1836, 1836, 0.02, 0.05, 0.5, 0.0, 0.05, 0.0, +1),\n        (1836, 1836, 0.02, 0.05, 0.5, 0.0, 5.0, 1.0, -1),\n        (5000, 1000, 0.03, 0.02, 1.0, 0.2, 40.0, 20.0, +1),\n        (1836, 1836, 0.02, 0.001, 0.0, 0.0, 3.0, 0.0, +1),\n    ]\n\n    results = [compute_hop(case) for case in test_cases]\n\n    # Format the output string precisely as specified in the problem statement.\n    formatted_results = []\n    for res in results:\n        s_bool, dpx, dpy, err = res\n        s_str = str(s_bool).lower() # Convert True/False to true/false\n        # Use full precision for floats, then join into a string representation of a list.\n        formatted_results.append(f\"[{s_str},{dpx},{dpy},{err}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Now that you have mastered the mechanics of a single hop, the next step is to integrate it into a complete trajectory simulation. This practice  challenges you to implement the full Fewest Switches Surface Hopping (FSSH) algorithm for a system featuring a conical intersection, a ubiquitous feature in photochemistry and materials science. You will propagate both nuclear and electronic degrees of freedom, compute non-adiabatic couplings from first principles, and apply the stochastic hopping logic to observe emergent phenomena like frustrated hops.",
            "id": "3826214",
            "problem": "Consider a two-state vibronic model of a Conical Intersection (CI) in two nuclear coordinates, where the diabatic electronic Hamiltonian depends linearly on the nuclear coordinates. The goal is to implement Fewest Switches Surface Hopping (FSSH) to simulate non-adiabatic molecular dynamics across the CI and to quantify the rate of frustrated hops near the seam when the kinetic energy along the Nonadiabatic Coupling (NAC) direction is low. You must derive all required quantities from first principles, starting only from the time-dependent Schrödinger equation for the electronic subsystem and Newton's second law for the nuclei, without assuming pre-given shortcut formulas. Use atomic units throughout, where the reduced Planck constant is $1$ and distances are in Bohr, energies in Hartree, masses in electron mass units, and time in atomic time units. Report the final metric as dimensionless decimals.\n\nFundamental base:\n- The nuclei obey Newton's second law, $m \\, d^2 \\mathbf{R} / dt^2 = -\\nabla E_\\mathrm{active}(\\mathbf{R})$, where $\\mathbf{R} = (x,y)$, $m$ is the nuclear mass (assume the same mass for both coordinates), and $E_\\mathrm{active}(\\mathbf{R})$ is the adiabatic energy of the currently active electronic state.\n- The electronic amplitudes $\\{c_1, c_2\\}$ obey the time-dependent Schrödinger equation $i \\, d \\mathbf{c} / dt = \\hat{H}_\\mathrm{el}(\\mathbf{R}(t)) \\, \\mathbf{c}(t)$ including derivative (nonadiabatic) couplings due to the nuclear velocity $\\mathbf{v} = d\\mathbf{R}/dt$. The nonadiabatic transition probability per time step between adiabatic states emerges from this dynamics and must be derived.\n- The diabatic Hamiltonian is linear in the nuclear coordinates, with a diagonal term that changes sign across the seam and an off-diagonal coupling that depends on the coordinate orthogonal to the seam direction. Specifically, the diabatic Hamiltonian has the form\n$$\n\\hat{H}_\\mathrm{d}(\\mathbf{R}) =\n\\begin{pmatrix}\n\\lambda x & \\kappa y \\\\\n\\kappa y & -\\lambda x\n\\end{pmatrix},\n$$\nwhere $\\lambda$ and $\\kappa$ are constant parameters. Its adiabatic energies and eigenvectors must be obtained by diagonalization, and the derivative couplings between adiabatic states must be obtained from the nuclear coordinate dependence of the adiabatic eigenvectors.\n\nSimulation and observable:\n- Implement Fewest Switches Surface Hopping (FSSH) in the adiabatic representation for this two-state, two-coordinate CI model. Propagate nuclei on the currently active adiabatic surface using a time-reversible scheme that is consistent with $m \\, d^2 \\mathbf{R} / dt^2 = -\\nabla E_\\mathrm{active}(\\mathbf{R})$.\n- Propagate electronic amplitudes using the time-dependent Schrödinger equation with the computed adiabatic energies and derivative couplings.\n- Decide hops stochastically according to the derived transition probability between the adiabatic states. Upon an attempted hop, rescale the nuclear velocity along the NAC direction to conserve total energy. If the energy conservation cannot be satisfied due to insufficient kinetic energy along the NAC direction, the hop is frustrated and must be rejected. You must test the energy-rescaling feasibility along the NAC direction only.\n- Quantify the fraction of frustrated upward hops that occur within a defined \"near-seam\" region, which you must define in terms of the Euclidean distance $r = \\sqrt{x^2 + y^2}$. Count only upward attempted hops (from the lower adiabatic surface to the upper adiabatic surface) whose centers are inside the near-seam region, and report the fraction that are frustrated among those attempts. If there are no attempted upward hops inside the near-seam region, report $0.0$ for that test case.\n\nUnits and output:\n- Use atomic units for all quantities. The fraction of frustrated hops is dimensionless and must be expressed as a decimal rounded to six digits after the decimal point.\n- Angles, if any, must be interpreted in radians.\n\nModel parameters and integration control:\n- Diabatic linear coefficients: $\\lambda = 0.5$ and $\\kappa = 0.3$.\n- Nuclear mass: $m = 2000$ for both degrees of freedom.\n- Time step: $\\Delta t = 0.1$.\n- Number of time steps per test case: $N_\\mathrm{steps} = 10000$.\n- Near-seam radius: $r_0 = 0.05$.\n- Random number generator must be seeded deterministically so that all results are reproducible.\n\nInitial conditions and test suite:\nFor each test case, set the initial active surface to the lower adiabatic state, and set the initial electronic amplitudes to $c_\\mathrm{lower}(0) = 1$ and $c_\\mathrm{upper}(0) = 0$. For velocity alignment, use the NAC unit vector at the initial position $\\mathbf{R}(0)$; “aligned” means the velocity is colinear with the NAC unit vector, and “perpendicular” means the velocity is orthogonal to it.\n\nProvide the following test suite:\n- Test case A (happy path, near seam, low NAC-direction kinetic energy): $\\mathbf{R}(0) = (0.02, 0.02)$, speed $s = 0.05$, velocity perpendicular to the NAC direction at $\\mathbf{R}(0)$.\n- Test case B (near seam, high NAC-direction kinetic energy): $\\mathbf{R}(0) = (0.02, 0.02)$, speed $s = 0.20$, velocity aligned with the NAC direction at $\\mathbf{R}(0)$.\n- Test case C (far from seam, moderate speed, low NAC-direction kinetic energy): $\\mathbf{R}(0) = (0.20, 0.20)$, speed $s = 0.10$, velocity perpendicular to the NAC direction at $\\mathbf{R}(0)$.\n- Test case D (very near seam, very low speed, low NAC-direction kinetic energy): $\\mathbf{R}(0) = (0.01, 0.01)$, speed $s = 0.005$, velocity perpendicular to the NAC direction at $\\mathbf{R}(0)$.\n\nRequired final program behavior:\n- Implement the above simulation and compute, for each test case, the fraction of frustrated upward hops inside the near-seam region $r < r_0$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[A,B,C,D]$, where each entry is the decimal fraction rounded to six digits after the decimal point, for example, $[0.123456,0.234567,0.000000,0.999000]$.",
            "solution": "The problem requires the implementation of the Fewest Switches Surface Hopping (FSSH) algorithm for a two-state, two-dimensional linear vibronic coupling model of a conical intersection (CI). All dynamically relevant quantities must be derived from fundamental principles. The simulation will be used to calculate the fraction of frustrated upward hops near the CI seam.\n\n**1. Adiabatic Representation**\n\nThe system is described by a diabatic electronic Hamiltonian, which is a linear function of the nuclear coordinates $\\mathbf{R} = (x, y)$:\n$$\n\\hat{H}_\\mathrm{d}(\\mathbf{R}) =\n\\begin{pmatrix}\n\\lambda x & \\kappa y \\\\\n\\kappa y & -\\lambda x\n\\end{pmatrix}\n$$\nThe FSSH algorithm operates in the adiabatic representation. The adiabatic energies, $E_k(\\mathbf{R})$, are the eigenvalues of $\\hat{H}_\\mathrm{d}(\\mathbf{R})$. They are found by solving the characteristic equation $\\det(\\hat{H}_\\mathrm{d} - E \\mathbb{I}) = 0$:\n$$\n(\\lambda x - E)(-\\lambda x - E) - (\\kappa y)^2 = 0 \\implies E^2 = (\\lambda x)^2 + (\\kappa y)^2\n$$\nThis gives two adiabatic potential energy surfaces:\n$$\nE_{0,1}(\\mathbf{R}) = \\mp \\sqrt{(\\lambda x)^2 + (\\kappa y)^2}\n$$\nwhere we denote the lower state by $k=0$ and the upper state by $k=1$. The states are degenerate at the origin $\\mathbf{R}=(0,0)$, which is the conical intersection. Let $E(\\mathbf{R}) = \\sqrt{(\\lambda x)^2 + (\\kappa y)^2}$, so $E_0 = -E$ and $E_1 = E$.\n\nThe adiabatic electronic states $|\\psi_k(\\mathbf{R})\\rangle$ are the corresponding eigenvectors. They are related to the diabatic states $|\\phi_1\\rangle, |\\phi_2\\rangle$ (which are the standard basis vectors $(1,0)^T$ and $(0,1)^T$) by a unitary transformation. A convenient way to express the eigenvectors is by defining a mixing angle $\\theta(\\mathbf{R})$:\n$$\n\\cos(2\\theta) = \\frac{\\lambda x}{E}, \\quad \\sin(2\\theta) = \\frac{\\kappa y}{E}\n$$\nThis implies $2\\theta(\\mathbf{R}) = \\mathrm{atan2}(\\kappa y, \\lambda x)$. With this, the diabatic Hamiltonian can be written as:\n$$\n\\hat{H}_\\mathrm{d} = E \\begin{pmatrix} \\cos(2\\theta) & \\sin(2\\theta) \\\\ \\sin(2\\theta) & -\\cos(2\\theta) \\end{pmatrix}\n$$\nThe normalized eigenvectors (adiabatic states) corresponding to eigenvalues $E_0 = -E$ and $E_1 = E$ are:\n$$\n|\\psi_0(\\mathbf{R})\\rangle = \\begin{pmatrix} -\\sin\\theta \\\\ \\cos\\theta \\end{pmatrix}, \\quad |\\psi_1(\\mathbf{R})\\rangle = \\begin{pmatrix} \\cos\\theta \\\\ \\sin\\theta \\end{pmatrix}\n$$\n\n**2. Non-Adiabatic Couplings (NAC)**\n\nNuclear motion induces transitions between adiabatic states. This is governed by the non-adiabatic coupling (NAC) vector, $\\mathbf{d}_{kj}(\\mathbf{R}) = \\langle \\psi_k | \\nabla_{\\mathbf{R}} | \\psi_j \\rangle$. For a two-state system, we are interested in $\\mathbf{d}_{01}$. Using the Hellmann-Feynman theorem for $k \\ne j$:\n$$\n\\mathbf{d}_{kj} = \\frac{\\langle \\psi_k | (\\nabla_{\\mathbf{R}} \\hat{H}_\\mathrm{d}) | \\psi_j \\rangle}{E_j - E_k}\n$$\nThe gradients of the diabatic Hamiltonian are:\n$$\n\\nabla_x \\hat{H}_\\mathrm{d} = \\begin{pmatrix} \\lambda & 0 \\\\ 0 & -\\lambda \\end{pmatrix} = \\lambda\\sigma_z, \\quad \\nabla_y \\hat{H}_\\mathrm{d} = \\begin{pmatrix} 0 & \\kappa \\\\ \\kappa & 0 \\end{pmatrix} = \\kappa\\sigma_x\n$$\nTransforming these gradient operators to the adiabatic basis and taking the off-diagonal elements gives the matrix elements for the numerator. The energy denominator is $E_1 - E_0 = 2E$. This leads to:\n$$\nd_{01,x} = \\frac{\\langle \\psi_0 | \\lambda \\sigma_z | \\psi_1 \\rangle}{2E} = \\frac{\\lambda(-\\sin(2\\theta))}{2E} = \\frac{-\\lambda}{2E} \\frac{\\kappa y}{E} = \\frac{-\\lambda \\kappa y}{2E^2}\n$$\n$$\nd_{01,y} = \\frac{\\langle \\psi_0 | \\kappa \\sigma_x | \\psi_1 \\rangle}{2E} = \\frac{\\kappa(\\cos(2\\theta))}{2E} = \\frac{\\kappa}{2E} \\frac{\\lambda x}{E} = \\frac{\\lambda \\kappa x}{2E^2}\n$$\nCombining these, the NAC vector is:\n$$\n\\mathbf{d}_{01}(\\mathbf{R}) = \\frac{\\lambda \\kappa}{2((\\lambda x)^2 + (\\kappa y)^2)} \\begin{pmatrix} -y \\\\ x \\end{pmatrix}\n$$\nThis result can be verified by noting that $\\mathbf{d}_{01} = \\langle \\psi_0 | \\nabla \\psi_1 \\rangle = \\nabla \\theta$, which yields the same expression. Note that $\\mathbf{d}_{10} = -\\mathbf{d}_{01}$. The NAC vector is singular at the CI, which requires careful numerical handling.\n\n**3. Equations of Motion**\n\nThe simulation couples classical nuclear dynamics with quantum electronic dynamics.\nThe nuclei evolve according to Newton's second law on the active adiabatic surface $E_k(\\mathbf{R})$:\n$$\nm \\frac{d^2\\mathbf{R}}{dt^2} = \\mathbf{F}_k(\\mathbf{R}) = -\\nabla_{\\mathbf{R}} E_k(\\mathbf{R})\n$$\nThe forces are $\\mathbf{F}_0 = -\\nabla E_0 = \\nabla E$ and $\\mathbf{F}_1 = -\\nabla E_1 = -\\nabla E$, where $\\nabla E = (E)^{-1}(\\lambda^2 x, \\kappa^2 y)$. Hence, the lower surface is repulsive and the upper surface is attractive with respect to the CI.\n\nThe electronic wavefunction $|\\Psi(t)\\rangle = c_0(t)|\\psi_0\\rangle + c_1(t)|\\psi_1\\rangle$ evolves according to the time-dependent Schrödinger equation in the adiabatic basis:\n$$\ni \\frac{d c_k}{dt} = E_k c_k - i \\sum_j (\\mathbf{v} \\cdot \\mathbf{d}_{kj}) c_j\n$$\nwhere $\\mathbf{v} = d\\mathbf{R}/dt$ is the nuclear velocity. This can be written in matrix form $i \\dot{\\mathbf{c}} = \\mathbf{A} \\mathbf{c}$, with the coupling matrix $\\mathbf{A}$:\n$$\n\\mathbf{A} = \\begin{pmatrix} E_0 & -i \\mathbf{v} \\cdot \\mathbf{d}_{01} \\\\ i \\mathbf{v} \\cdot \\mathbf{d}_{01} & E_1 \\end{pmatrix}\n$$\n\n**4. Numerical Integration Scheme**\n\nA Velocity-Verlet algorithm is used to integrate the nuclear equations of motion. A single time step $\\Delta t$ is performed as:\n1.  Update velocities by a half-step: $\\mathbf{v}(t+\\Delta t/2) = \\mathbf{v}(t) + \\mathbf{F}_k(t)/m \\cdot (\\Delta t/2)$.\n2.  Update positions by a full step: $\\mathbf{R}(t+\\Delta t) = \\mathbf{R}(t) + \\mathbf{v}(t+\\Delta t/2) \\cdot \\Delta t$.\n3.  At $\\mathbf{R}(t+\\Delta t)$, evaluate electronic properties ($E_k$, $\\mathbf{d}_{01}$) and propagate electronic coefficients $c_k$ from $t$ to $t+\\Delta t$.\n4.  Perform the FSSH stochastic hop decision. If a hop occurs, update the active state $k$ and rescale the velocity $\\mathbf{v}(t+\\Delta t/2)$.\n5.  Calculate the new force $\\mathbf{F}_k(t+\\Delta t)$ using the (potentially new) active state.\n6.  Update velocities by a second half-step: $\\mathbf{v}(t+\\Delta t) = \\mathbf{v}(t+\\Delta t/2) + \\mathbf{F}_k(t+\\Delta t)/m \\cdot (\\Delta t/2)$.\n\n**5. FSSH Algorithm Details**\n\n- **Electronic Propagation**: The electronic coefficients are propagated over $\\Delta t$ via the matrix exponential: $\\mathbf{c}(t+\\Delta t) = \\exp(-i\\mathbf{A}\\Delta t)\\mathbf{c}(t)$. For a $2 \\times 2$ matrix $\\mathbf{A}$, this can be calculated analytically. Let $\\Omega = \\sqrt{E^2 + (\\mathbf{v}\\cdot\\mathbf{d}_{01})^2}$. The propagator is:\n$$\n\\exp(-i\\mathbf{A}\\Delta t) = \\cos(\\Omega\\Delta t)\\mathbb{I} - i \\frac{\\sin(\\Omega\\Delta t)}{\\Omega} \\left(\\mathbf{A} - \\frac{E_0+E_1}{2}\\mathbb{I}\\right)\n$$\nSince $E_0+E_1=0$, the second term simplifies.\n\n- **Hopping Probability**: The probability of hopping from the active state $k$ to another state $j$ within $\\Delta t$ is computed as $P_{k \\to j} = \\max(0, b_{kj}\\Delta t)$, where:\n$$\nb_{kj} = -2\\frac{\\mathrm{Re}[c_j^* c_k (\\mathbf{v} \\cdot \\mathbf{d}_{kj})]}{|c_k|^2}\n$$\nA random number $\\xi \\in [0,1]$ is drawn. If $\\xi < P_{k \\to j}$, a hop is attempted.\n\n- **Stochastic Hopping and Energy Conservation**: Upon an attempted hop from state $k$ to $j$, total energy must be conserved. The kinetic energy must change by $\\Delta E = E_k - E_j$. This change is accommodated by rescaling the component of the nuclear velocity along the NAC vector $\\mathbf{d}_{kj}$. Let $\\hat{\\mathbf{d}}_{kj}$ be the unit vector along $\\mathbf{d}_{kj}$ and $v_\\parallel = \\mathbf{v} \\cdot \\hat{\\mathbf{d}}_{kj}$. The new velocity component $v'_\\parallel$ must satisfy:\n$$\n\\frac{1}{2}m(v'_\\parallel)^2 = \\frac{1}{2}m v_\\parallel^2 + \\Delta E\n$$\nA hop is **frustrated** and rejected if there is insufficient kinetic energy along the NAC direction to supply the required potential energy, i.e., if $v_\\parallel^2 + 2\\Delta E/m < 0$. Otherwise, the hop is accepted, the active state is switched to $j$, and the velocity is updated:\n$$\nv'_\\parallel = \\mathrm{sign}(v_\\parallel) \\sqrt{v_\\parallel^2 + 2\\Delta E/m}\n$$\n$$\n\\mathbf{v}' = \\mathbf{v} + (v'_\\parallel - v_\\parallel)\\hat{\\mathbf{d}}_{kj}\n$$\n\n**6. Observable Definition**\n\nThe goal is to quantify the fraction of frustrated upward hops in a near-seam region, defined by $r<r_0$ where $r = \\sqrt{x^2+y^2}$. Two counters are maintained throughout the simulation:\n1.  `total_upward_hops_in_region`: Incremented for every attempted upward hop (from state $k=0$ to $j=1$) where the hop is decided at a nuclear position $\\mathbf{R}$ inside the near-seam region.\n2.  `frustrated_upward_hops_in_region`: Incremented for each of the above attempts that is found to be frustrated.\n\nThe final reported metric is the ratio of these two counters. If no upward hops are attempted in the region, the fraction is $0.0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global parameters in atomic units\nPARAMS = {\n    'lambda': 0.5,\n    'kappa': 0.3,\n    'm': 2000.0,\n    'dt': 0.1,\n    'n_steps': 10000,\n    'r0': 0.05,\n    'seed': 42  # For reproducible results\n}\n\ndef get_adiabatic_properties(R, lam, kap):\n    \"\"\"\n    Computes adiabatic energies and the non-adiabatic coupling vector.\n    \"\"\"\n    x, y = R\n    E_sq = (lam * x)**2 + (kap * y)**2\n    \n    # Add a small epsilon to avoid division by zero right at the CI\n    if E_sq < 1e-24:\n        # At the CI, energies are degenerate and NAC is undefined. \n        # Return zeros; logic downstream should handle this gracefully.\n        return np.zeros(2), np.zeros(2)\n\n    E = np.sqrt(E_sq)\n    \n    # Adiabatic energies: E0 (lower), E1 (upper)\n    energies = np.array([-E, E])\n    \n    # Non-adiabatic coupling vector d_01\n    d01_vec = (lam * kap / (2.0 * E_sq)) * np.array([-y, x])\n    \n    return energies, d01_vec\n\ndef get_force(R, active_state, energies, lam, kap):\n    \"\"\"\n    Computes the force on the nuclei for the given active state.\n    F_k = -grad(E_k)\n    \"\"\"\n    E = energies[1]  # E is the magnitude, E_1 = E\n    if E < 1e-12:\n        return np.zeros(2)\n        \n    x, y = R\n    grad_E = np.array([lam**2 * x, kap**2 * y]) / E\n    \n    if active_state == 0:  # Lower surface: F = -grad(E_0) = -grad(-E) = grad(E)\n        return grad_E\n    else:  # Upper surface: F = -grad(E_1) = -grad(E)\n        return -grad_E\n\ndef propagate_electronic(c, v, energies, d01_vec, dt):\n    \"\"\"\n    Propagates electronic coefficients over one time step.\n    \"\"\"\n    E0, E1 = energies\n    E_half_gap = (E1 - E0) / 2.0  # This is E\n\n    V01 = np.dot(v, d01_vec)\n    \n    omega_sq = E_half_gap**2 + V01**2\n    if omega_sq < 1e-24:\n        omega = 0.0\n    else:\n        omega = np.sqrt(omega_sq)\n\n    if omega == 0.0:\n        # No coupling or degeneracy, only phase evolution\n        U = np.diag([np.exp(-1j * E0 * dt), np.exp(-1j * E1 * dt)])\n    else:\n        C_ = np.cos(omega * dt)\n        S_ = np.sin(omega * dt) / omega\n        \n        # Propagator for c = (c_0, c_1)^T\n        # A = [E0, -iV01; iV01, E1]. exp(-iA*dt)\n        U = np.array([\n            [C_ - 1j * E0 * S_, 1j * (-1j * V01) * S_],\n            [1j * (1j * V01) * S_, C_ - 1j * E1 * S_]\n        ])\n        U[0,1] = -V01*S_\n        U[1,0] = V01*S_\n\n\n    return U @ c\n\ndef fssh_hop_logic(c, v, energies, d01_vec, R, active_state, m, dt, r0, counters, rng):\n    \"\"\"\n    Implements FSSH stochastic hopping logic, velocity rescaling, and frustration check.\n    \"\"\"\n    k = active_state  # current state\n    j = 1 - k  # target state\n\n    c_k_norm_sq = np.abs(c[k])**2\n    if c_k_norm_sq < 1e-12:\n        return active_state, v\n\n    d_kj = d01_vec if k == 0 else -d01_vec\n    V_kj = np.dot(v, d_kj)\n    \n    b_kj = -2.0 * np.real(np.conj(c[j]) * c[k] * V_kj) / c_k_norm_sq\n    p_hop = b_kj * dt\n    \n    if p_hop < 0:\n        return active_state, v\n\n    xi = rng.random()\n    if xi < p_hop:\n        # Hop is attempted\n        is_upward_hop = (k == 0)\n        pos_norm = np.linalg.norm(R)\n        in_region = (pos_norm < r0)\n\n        if is_upward_hop and in_region:\n            counters['total_upward_hops_in_region'] += 1\n            \n        DeltaE = energies[k] - energies[j]\n        \n        d_norm_sq = np.dot(d_kj, d_kj)\n        if d_norm_sq < 1e-16: # NAC vector is zero, direction undefined\n            if is_upward_hop and in_region:\n                counters['frustrated_upward_hops_in_region'] += 1\n            return k, v # Reject hop\n\n        d_hat = d_kj / np.sqrt(d_norm_sq)\n        v_parallel = np.dot(v, d_hat)\n        \n        T_rescale_sq = v_parallel**2 + 2.0 * DeltaE / m\n\n        if T_rescale_sq < 0: # Frustrated hop\n            if is_upward_hop and in_region:\n                counters['frustrated_upward_hops_in_region'] += 1\n            # hop is rejected\n            return k, v\n        else: # Hop accepted\n            v_parallel_new = np.sign(v_parallel) * np.sqrt(T_rescale_sq) if v_parallel != 0 else np.sqrt(T_rescale_sq)\n            v_new = v + (v_parallel_new - v_parallel) * d_hat\n            return j, v_new\n\n    return k, v # No hop\n\ndef run_simulation(R0, v0):\n    \"\"\"\n    Main FSSH simulation function for a single trajectory.\n    \"\"\"\n    lam = PARAMS['lambda']\n    kap = PARAMS['kappa']\n    m = PARAMS['m']\n    dt = PARAMS['dt']\n    n_steps = PARAMS['n_steps']\n    r0 = PARAMS['r0']\n    seed = PARAMS['seed']\n    rng = np.random.default_rng(seed)\n\n    R = np.array(R0, dtype=float)\n    v = np.array(v0, dtype=float)\n    c = np.array([1.0 + 0j, 0.0 + 0j]) # Start in lower state, c0=1\n    active_state = 0\n    \n    counters = {\n        'total_upward_hops_in_region': 0,\n        'frustrated_upward_hops_in_region': 0\n    }\n\n    for _ in range(n_steps):\n        # Velocity-Verlet part 1\n        energies_t, _ = get_adiabatic_properties(R, lam, kap)\n        force_t = get_force(R, active_state, energies_t, lam, kap)\n        v += force_t / m * (dt / 2.0) # v(t+dt/2)\n        \n        # Position update\n        R += v * dt # R(t+dt)\n        \n        # Electronic properties at R(t+dt) and propagation using v(t+dt/2)\n        energies, d01_vec = get_adiabatic_properties(R, lam, kap)\n        c = propagate_electronic(c, v, energies, d01_vec, dt)\n        \n        # FSSH logic\n        active_state, v = fssh_hop_logic(c, v, energies, d01_vec, R, active_state, m, dt, r0, counters, rng)\n\n        # Velocity-Verlet part 2\n        energies, _ = get_adiabatic_properties(R, lam, kap)\n        force_tp1 = get_force(R, active_state, energies, lam, kap)\n        v += force_tp1 / m * (dt / 2.0) # v(t+dt)\n        \n    if counters['total_upward_hops_in_region'] == 0:\n        return 0.0\n    \n    fraction = counters['frustrated_upward_hops_in_region'] / counters['total_upward_hops_in_region']\n    return fraction\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test suite, printing the final results.\n    \"\"\"\n    test_cases_spec = [\n        {'R0': (0.02, 0.02), 's': 0.05, 'align': 'perp'},\n        {'R0': (0.02, 0.02), 's': 0.20, 'align': 'aligned'},\n        {'R0': (0.20, 0.20), 's': 0.10, 'align': 'perp'},\n        {'R0': (0.01, 0.01), 's': 0.005, 'align': 'perp'}\n    ]\n\n    results = []\n    \n    for case in test_cases_spec:\n        R0 = np.array(case['R0'])\n        s = case['s']\n        align = case['align']\n        \n        _, d01_at_R0 = get_adiabatic_properties(R0, PARAMS['lambda'], PARAMS['kappa'])\n        d01_norm = np.linalg.norm(d01_at_R0)\n        \n        if d01_norm < 1e-12:\n            # Handle cases where NAC is ill-defined e.g. on an axis\n            # For R=(a,a), d01 direction is (-1,1)\n            nac_dir = np.array([-1.0, 1.0]) / np.sqrt(2.0)\n        else:\n            nac_dir = d01_at_R0 / d01_norm\n        \n        if align == 'aligned':\n            v0 = s * nac_dir\n        else: # 'perp'\n            perp_dir = np.array([-nac_dir[1], nac_dir[0]])\n            v0 = s * perp_dir\n            \n        fraction = run_simulation(R0, v0)\n        results.append(f\"{fraction:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A truly deep understanding of a simulation method requires appreciating its limitations. This final exercise  focuses on \"frustrated hops,\" a well-known artifact in FSSH that can cause the system's dynamics to violate the fundamental principle of detailed balance, leading to incorrect equilibrium populations. Using a simplified model to isolate the effect, you will quantify this deviation and test several common correction schemes, providing a window into the ongoing research and refinement of non-adiabatic methods.",
            "id": "5295188",
            "problem": "Consider a one-dimensional two-surface nonadiabatic molecular dynamics model designed to isolate the treatment of frustrated hops in Fewest Switches Surface Hopping (FSSH). The nuclear degree of freedom is represented by a single classical particle with mass $m$ and velocity $v$. The two adiabatic electronic surfaces have constant energy difference $\\Delta E$ so that the upper surface energy is $E_2 = E_1 + \\Delta E$, and the nonadiabatic coupling is assumed to be aligned with the single nuclear degree of freedom so that directional effects depend on the sign of $v$. All quantities are dimensionless; set the Boltzmann constant $k_{\\mathrm{B}} = 1$.\n\nAt each discrete time step, a hop attempt from the current surface is generated with a probability that depends linearly on the component of the velocity along the nonadiabatic coupling, clipped to remain within the interval $[0,1]$. Specifically, define a small coupling coefficient $\\alpha > 0$ and a prefactor $p_0 \\in (0,1)$, and let the attempt probabilities be\n$$\nP_{1\\to 2}^{\\mathrm{att}}(v) = \\min\\left(1,\\, p_0 \\max(0, \\alpha v)\\right), \\quad\nP_{2\\to 1}^{\\mathrm{att}}(v) = \\min\\left(1,\\, p_0 \\max(0, \\alpha(-v))\\right).\n$$\nAn upward hop $1\\to 2$ conserves total energy only if the current kinetic energy $K=\\frac{1}{2} m v^2$ satisfies $K \\ge \\Delta E$. If accepted, it rescales the speed to conserve energy via\n$$\nv' = \\mathrm{sgn}(v)\\,\\sqrt{v^2 - \\frac{2\\Delta E}{m}}.\n$$\nA downward hop $2\\to 1$ is always energetically allowed and similarly rescales the speed via\n$$\nv' = \\mathrm{sgn}(v)\\,\\sqrt{v^2 + \\frac{2\\Delta E}{m}}.\n$$\n\nIf an attempted upward hop is energetically forbidden ($K < \\Delta E$), it is a frustrated hop. Your algorithm must implement two control options for frustrated hops:\n\n1. Velocity reversal criterion. If a Boolean flag $r \\in \\{0,1\\}$ is set to $1$, then upon a frustrated hop, reverse the nuclear velocity according to $v \\leftarrow -v$; if $r=0$, leave $v$ unchanged.\n\n2. Population adjustment option. Upon a frustrated hop, modify the next-step upward hop attempt probability by multiplying it by a factor $F$ applied for exactly one subsequent time step, with mode $\\mu \\in \\{\\mathrm{none}, \\mathrm{renorm}, \\mathrm{boltz}\\}$:\n   - $\\mu = \\mathrm{none}$: $F = 1$ (no population adjustment).\n   - $\\mu = \\mathrm{renorm}$: $F = 0$ (eliminate the next-step upward attempt, mimicking full instantaneous renormalization away from the target state).\n   - $\\mu = \\mathrm{boltz}$: $F = \\exp(-\\Delta E / T)$ (Boltzmann reweight the next-step upward attempt).\n\nHere, $T$ is the dimensionless temperature and the initial velocities are sampled independently from the one-dimensional Maxwell-Boltzmann distribution $v \\sim \\mathcal{N}(0, \\sigma^2)$ with variance $\\sigma^2 = T/m$. For clarity: the population adjustment factor $F$ is applied only to $P_{1\\to 2}^{\\mathrm{att}}(v)$ for the single time step following a frustrated hop. After that one step, the factor is reset to $1$ unless another frustrated hop occurs.\n\nTo assess the impact on Detailed Balance (DB), define the empirical hop ratio\n$$\nR = \\frac{N_{1\\to 2}^{\\mathrm{acc}}}{N_{2\\to 1}^{\\mathrm{acc}}},\n$$\nwhere $N_{1\\to 2}^{\\mathrm{acc}}$ and $N_{2\\to 1}^{\\mathrm{acc}}$ are the counts of accepted upward and downward hops collected after discarding the first $f_{\\mathrm{burn}}$ fraction of time steps as a burn-in period. The canonical DB ratio target for two constant-energy surfaces at temperature $T$ is\n$$\nR_{\\mathrm{B}} = \\exp\\left(-\\frac{\\Delta E}{T}\\right).\n$$\nDefine the DB deviation measure as the absolute difference\n$$\nD = \\left| R - R_{\\mathrm{B}} \\right|.\n$$\n\nImplement a program that, for each test case specified below, simulates the above process with the given parameters using a fixed random seed, and outputs the DB deviation $D$ as a floating-point number. Use $N$ independent particles with initial surfaces drawn uniformly from $\\{1,2\\}$ and velocities independently sampled as described. Evolve for $M$ discrete time steps, discarding the first $\\lfloor f_{\\mathrm{burn}} M \\rfloor$ steps from the hop counts. The algorithm must be entirely deterministic given the fixed random seed. The final output must be a single line containing the list of $D$ values for all test cases, formatted as a comma-separated list enclosed in square brackets.\n\nTest Suite. Use the following parameter sets, expressed in dimensionless units:\n- Case A (happy path, no reversal, no adjustment): $m=1$, $\\Delta E = 0.5$, $T = 1$, $\\alpha = 0.5$, $p_0 = 0.1$, $r=0$, $\\mu=\\mathrm{none}$, $N=4096$, $M=4096$, $f_{\\mathrm{burn}}=0.2$.\n- Case B (reversal enabled): $m=1$, $\\Delta E = 0.5$, $T = 1$, $\\alpha = 0.5$, $p_0 = 0.1$, $r=1$, $\\mu=\\mathrm{none}$, $N=4096$, $M=4096$, $f_{\\mathrm{burn}}=0.2$.\n- Case C (Boltzmann population adjustment, no reversal): $m=1$, $\\Delta E = 0.5$, $T = 1$, $\\alpha = 0.5$, $p_0 = 0.1$, $r=0$, $\\mu=\\mathrm{boltz}$, $N=4096$, $M=4096$, $f_{\\mathrm{burn}}=0.2$.\n- Case D (large gap, reversal and renormalization): $m=1$, $\\Delta E = 2.0$, $T = 1$, $\\alpha = 0.5$, $p_0 = 0.1$, $r=1$, $\\mu=\\mathrm{renorm}$, $N=4096$, $M=4096$, $f_{\\mathrm{burn}}=0.2$.\n- Case E (low temperature, Boltzmann adjustment): $m=1$, $\\Delta E = 0.2$, $T = 0.2$, $\\alpha = 0.5$, $p_0 = 0.1$, $r=0$, $\\mu=\\mathrm{boltz}$, $N=4096$, $M=4096$, $f_{\\mathrm{burn}}=0.2$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Each result should be the value of $D$ for the corresponding test case, expressed as a floating-point number.",
            "solution": "The problem requires the implementation of a simulation based on a simplified one-dimensional, two-surface model for nonadiabatic molecular dynamics. The goal is to evaluate the effect of different treatments for \"frustrated hops\" on the system's ability to satisfy the principle of Detailed Balance.\n\nThe simulation's design is founded on several core principles from statistical mechanics and computational physics, which are translated into a vectorized numerical algorithm.\n\nFirst, the system is modeled as a canonical ensemble of $N$ independent, non-interacting classical particles. This approach uses statistical averaging to obtain macroscopic observables from microscopic dynamics. The initial state of the ensemble is prepared to be consistent with thermal equilibrium at a given temperature $T$. Specifically, initial velocities $v$ are sampled from a Maxwell-Boltzmann distribution, which in one dimension takes the form of a normal distribution $\\mathcal{N}(0, \\sigma^2)$ with variance $\\sigma^2 = k_{\\mathrm{B}} T/m$. Since the Boltzmann constant is set to $k_{\\mathrm{B}}=1$, this simplifies to $\\sigma^2 = T/m$. The initial electronic state for each particle is chosen uniformly from the two available surfaces, $\\{1, 2\\}$, representing an unbiased initial population.\n\nSecond, the dynamics follow the Fewest Switches Surface Hopping (FSSH) methodology. In this mixed quantum-classical scheme, each particle evolves classically on a single adiabatic potential energy surface at any given time. Nonadiabatic transitions between surfaces are treated as instantaneous, stochastic \"hops\". The probability of attempting a hop is a function of the nuclear velocity $v$ and a coupling coefficient $\\alpha$, modeling the interaction strength between the electronic states mediated by nuclear motion. The given probabilities, $P_{1\\to 2}^{\\mathrm{att}}(v) = \\min(1, p_0 \\max(0, \\alpha v))$ for upward hops and $P_{2\\to 1}^{\\mathrm{att}}(v) = \\min(1, p_0 \\max(0, \\alpha(-v)))$ for downward hops, capture the essential physics that hopping is promoted by motion along the direction of the nonadiabatic coupling vector. The use of $\\max(0, \\dots)$ ensures that hops are only attempted when the velocity component is correctly aligned (e.g., $v>0$ for an upward hop if the coupling is positive in that direction).\n\nThird, the principle of total energy conservation is strictly enforced during hops. A hop from the lower surface $1$ to the upper surface $2$ requires an energy input of $\\Delta E$. This is only possible if the particle's kinetic energy $K = \\frac{1}{2}mv^2$ is sufficient, i.e., $K \\ge \\Delta E$. If a hop is attempted and is energetically allowed, the velocity is rescaled to $v' = \\mathrm{sgn}(v)\\,\\sqrt{v^2 - \\frac{2\\Delta E}{m}}$ to ensure the total energy is conserved. The factor $\\mathrm{sgn}(v)$ preserves the direction of motion. Conversely, a downward hop ($2 \\to 1$) releases energy $\\Delta E$, which is converted into kinetic energy, and is thus always energetically allowed. The velocity is rescaled to $v' = \\mathrm{sgn}(v)\\,\\sqrt{v^2 + \\frac{2\\Delta E}{m}}$.\n\nAn attempted upward hop that is energetically forbidden ($K < \\Delta E$) is termed a \"frustrated hop\". These events are a known deficiency in the standard FSSH algorithm, leading to violations of Detailed Balance. The problem specifies two correction schemes to be tested. The first is velocity reversal ($v \\leftarrow -v$ if the flag $r=1$ is active), an ad-hoc fix intended to make the particle \"re-scatter\" from the region of strong coupling. The second is a population adjustment, where the subsequent attempt probability $P_{1\\to 2}^{\\mathrm{att}}$ is multiplied by a factor $F$ for one time step. The modes $\\mu \\in \\{\\mathrm{none}, \\mathrm{renorm}, \\mathrm{boltz}\\}$ correspond to factors $F=1$ (no correction), $F=0$ (suppressing the next attempt), and $F = \\exp(-\\Delta E / T)$ (re-weighting by the Boltzmann factor), respectively.\n\nThe primary observable for validation is the empirical hop ratio $R = N_{1\\to 2}^{\\mathrm{acc}} / N_{2\\to 1}^{\\mathrm{acc}}$, where $N^{\\mathrm{acc}}$ are the total counts of accepted hops across the ensemble after a burn-in period of $\\lfloor f_{\\mathrm{burn}} M \\rfloor$ time steps. The burn-in period allows the system to reach a statistical steady state, independent of the specific initial conditions. For a system in thermal equilibrium, Detailed Balance requires this ratio to equal the canonical Boltzmann ratio, $R_{\\mathrm{B}} = \\exp(-\\Delta E/T)$. The performance of each frustrated-hop scheme is quantified by the deviation $D = |R - R_{\\mathrm{B}}|$.\n\nThe algorithmic implementation is designed for efficiency using NumPy's vectorization capabilities. The states of all $N$ particles (their surfaces, velocities, and any state-dependent adjustment factors) are stored in arrays. The simulation proceeds in discrete time steps. Within each step, logical masks are used to identify subsets of particles (e.g., those on surface $1$, those attempting to hop, those whose hops\nare frustrated). This allows for conditional logic and state updates to be applied to the entire ensemble simultaneously, avoiding explicit loops over particles. A fixed random seed is used at the start of the process to ensure that the stochastic elements of the simulation (initial conditions, hop decisions) are reproducible, yielding a deterministic final output for each test case. The population adjustment factor $F$, which applies for one time step following a frustrated hop, is managed by maintaining an array `F_adj` of factors for each particle. At each time step `t`, a new array `F_adj_next` is prepared for step `t+1`, initialized to all ones, and then modified for any particles that experience a frustrated hop during step `t`. This correctly implements the one-step \"memory\" effect described.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Per problem statement: \"use a fixed random seed\".\n    # This ensures the entire sequence of random numbers used across all \n    # test cases is deterministic. The seed is set once for the entire suite.\n    np.random.seed(0)\n\n    test_cases = [\n        # Case A: happy path, no reversal, no adjustment\n        {'m': 1.0, 'dE': 0.5, 'T': 1.0, 'alpha': 0.5, 'p0': 0.1, 'r': 0, 'mu': 'none', 'N': 4096, 'M': 4096, 'f_burn': 0.2, 'case_id':'A'},\n        # Case B: reversal enabled\n        {'m': 1.0, 'dE': 0.5, 'T': 1.0, 'alpha': 0.5, 'p0': 0.1, 'r': 1, 'mu': 'none', 'N': 4096, 'M': 4096, 'f_burn': 0.2, 'case_id':'B'},\n        # Case C: Boltzmann population adjustment, no reversal\n        {'m': 1.0, 'dE': 0.5, 'T': 1.0, 'alpha': 0.5, 'p0': 0.1, 'r': 0, 'mu': 'boltz', 'N': 4096, 'M': 4096, 'f_burn': 0.2, 'case_id':'C'},\n        # Case D: large gap, reversal and renormalization\n        {'m': 1.0, 'dE': 2.0, 'T': 1.0, 'alpha': 0.5, 'p0': 0.1, 'r': 1, 'mu': 'renorm', 'N': 4096, 'M': 4096, 'f_burn': 0.2, 'case_id':'D'},\n        # Case E: low temperature, Boltzmann adjustment\n        {'m': 1.0, 'dE': 0.2, 'T': 0.2, 'alpha': 0.5, 'p0': 0.1, 'r': 0, 'mu': 'boltz', 'N': 4096, 'M': 4096, 'f_burn': 0.2, 'case_id':'E'},\n    ]\n\n    results = []\n    for params in test_cases:\n        # We pop 'case_id' as it's not a parameter for the simulation function.\n        case_id = params.pop('case_id')\n        D = simulate(**params)\n        results.append(D)\n        # Restore for potential debugging/display\n        params['case_id'] = case_id\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef simulate(m, dE, T, alpha, p0, r, mu, N, M, f_burn):\n    \"\"\"\n    Simulates the nonadiabatic molecular dynamics for a given set of parameters.\n    \"\"\"\n    # Calculate derived parameters\n    sigma_v = np.sqrt(T / m)\n    burn_in_steps = int(f_burn * M)\n\n    # Determine population adjustment factor F based on mode mu\n    if mu == 'none':\n        F = 1.0\n    elif mu == 'renorm':\n        F = 0.0\n    elif mu == 'boltz':\n        F = np.exp(-dE / T)\n    else:\n        # This case should not be reached with the given test suite.\n        raise ValueError(f\"Invalid population adjustment mode: {mu}\")\n\n    # --- Initialization ---\n    # Surfaces: 1 for lower, 2 for upper\n    surfaces = np.random.randint(1, 3, size=N)\n    # Velocities from Maxwell-Boltzmann distribution\n    velocities = np.random.normal(loc=0.0, scale=sigma_v, size=N)\n    \n    # F_adj stores the population adjustment factor for each particle for the current step\n    F_adj = np.ones(N, dtype=np.float64)\n\n    # Hop counters (accumulated after burn-in)\n    N_12_acc = 0\n    N_21_acc = 0\n\n    # --- Main Simulation Loop ---\n    for t in range(M):\n        # Array for next step's adjustment factors, initialized to 1 (no adjustment)\n        F_adj_next = np.ones(N, dtype=np.float64)\n\n        # --- Handle hops from surface 1 to 2 (upward) ---\n        idx_s1 = np.where(surfaces == 1)[0]\n        if idx_s1.size > 0:\n            v_s1 = velocities[idx_s1]\n            \n            p_up_base = p0 * np.maximum(0, alpha * v_s1)\n            p_up_att = np.minimum(1.0, F_adj[idx_s1] * p_up_base)\n\n            rand_s1 = np.random.rand(idx_s1.size)\n            attempt_up_indices = idx_s1[rand_s1 < p_up_att]\n\n            if attempt_up_indices.size > 0:\n                v_attempt_up = velocities[attempt_up_indices]\n                K_attempt_up = 0.5 * m * v_attempt_up**2\n                \n                allowed_mask = K_attempt_up >= dE\n                \n                # Process accepted hops\n                accepted_up_indices = attempt_up_indices[allowed_mask]\n                if accepted_up_indices.size > 0:\n                    if t >= burn_in_steps:\n                        N_12_acc += accepted_up_indices.size\n                    \n                    v_old = velocities[accepted_up_indices]\n                    velocities[accepted_up_indices] = np.sign(v_old) * np.sqrt(v_old**2 - (2 * dE / m))\n                    surfaces[accepted_up_indices] = 2\n\n                # Process frustrated hops\n                frustrated_hop_indices = attempt_up_indices[~allowed_mask]\n                if frustrated_hop_indices.size > 0:\n                    if r == 1:\n                        velocities[frustrated_hop_indices] *= -1\n                    if mu != 'none':\n                        F_adj_next[frustrated_hop_indices] = F\n\n        # --- Handle hops from surface 2 to 1 (downward) ---\n        idx_s2 = np.where(surfaces == 2)[0]\n        if idx_s2.size > 0:\n            v_s2 = velocities[idx_s2]\n            p_down_att = np.minimum(1.0, p0 * np.maximum(0, alpha * -v_s2))\n\n            rand_s2 = np.random.rand(idx_s2.size)\n            accepted_down_indices = idx_s2[rand_s2 < p_down_att]\n\n            if accepted_down_indices.size > 0:\n                if t >= burn_in_steps:\n                    N_21_acc += accepted_down_indices.size\n                \n                v_old = velocities[accepted_down_indices]\n                velocities[accepted_down_indices] = np.sign(v_old) * np.sqrt(v_old**2 + (2 * dE / m))\n                surfaces[accepted_down_indices] = 1\n        \n        # Prepare adjustment factor for the next time step\n        F_adj = F_adj_next\n\n    # --- Calculate Final Observables ---\n    R_B = np.exp(-dE / T)\n    \n    if N_21_acc == 0:\n        if N_12_acc == 0:\n            R = 0.0 # Define 0/0 as 0\n        else:\n            # Handle division by zero: R is effectively infinite\n            R = np.finfo(np.float64).max\n    else:\n        R = N_12_acc / N_21_acc\n\n    D = np.abs(R - R_B)\n    return D\n\n# Execute the simulation and print the final result.\nsolve()\n```"
        }
    ]
}