{
    "hands_on_practices": [
        {
            "introduction": "非绝热分子动力学的核心在于电子态之间的“跃迁”事件。在最少切换表面跳跃 (FSSH) 算法中，这种跃迁被处理为瞬时发生的，并且必须严格遵守总能量守恒。这个练习  聚焦于这一核心机制：当发生表面跳跃时，如何调整原子核的动量以精确补偿电子能量的变化。通过在一个明确定义的二维势能面模型中推导和实现动量重整化方案，您将掌握 FSSH 算法最基本的构建模块。",
            "id": "5295218",
            "problem": "考虑一个用于非绝热分子动力学的双态二维避免交叉模型，采用原子单位制（质量使用电子质量单位，能量使用哈特里，长度使用玻尔，动量使用原子单位）。非绝热电子哈密顿量定义为\n$$\n\\hat{H}_{\\mathrm{d}}(\\mathbf{R}) =\n\\begin{pmatrix}\na\\, x  & \\Delta/2 \\\\\n\\Delta/2 & -a\\, x\n\\end{pmatrix},\n$$\n其中 $\\mathbf{R} = (x,y)$ 是核位置矢量，$a$ 是一个单位为能量/长度的常数，$\\Delta$ 是一个单位为能量的常数。在位置 $\\mathbf{R}$ 处对应的绝热能量为\n$$\nE_{\\pm}(x) = \\pm \\sqrt{(a x)^2 + (\\Delta/2)^2}.\n$$\n在固定的 $\\mathbf{R}$ 位置发生一次势面跳跃，会使电子态能量从当前势面变为目标势面，能量差为\n$$\n\\Delta E = E_{\\mathrm{target}}(x) - E_{\\mathrm{source}}(x).\n$$\n经典原子核的质量为 $\\mathbf{m} = (m_x, m_y)$，动量为 $\\mathbf{p} = (p_x, p_y)$。经典核动能为\n$$\nK(\\mathbf{p},\\mathbf{m}) = \\frac{p_x^2}{2 m_x} + \\frac{p_y^2}{2 m_y}.\n$$\n在 Tully 的最少切换势面跳跃方法中，为了在跳跃瞬间保持量子-经典体系的总能量守恒，核动量必须沿着非绝热耦合方向进行调整。对于此哈密顿量，在所有 $\\mathbf{R}$ 位置，非绝热耦合都与 $x$ 轴共线，因此动量重标度方向沿着 $\\hat{\\mathbf{e}}_x$ 方向。该算法必须确定一个标量动量调整值，该调整仅改变动量的 $x$ 分量，得到新的动量 $\\mathbf{p}' = (p_x', p_y')$，其中 $p_y' = p_y$，$p_x'$ 由能量守恒和与跳跃方向一致的最小变化（对于 $\\Delta E > 0$ 动能减少，对于 $\\Delta E < 0$ 动能增加）确定。如果对于向上跳跃（$\\Delta E > 0$），重标度不存在实数值解，则该跳跃被拒绝，动量保持不变。\n\n从总能量（定义为经典核动能与固定 $\\mathbf{R}$ 处的绝热电子能量之和）的定义出发，并利用在跳跃过程中仅改变沿非绝热耦合方向的动量分量这一约束，推导出调整后动量的表达式，并实现一个程序，对每个测试用例计算：\n- 布尔型的跳跃成功指示符（如果存在并应用了能量守恒的重标度，则为 true；如果跳跃被拒绝，则为 false），\n- 动量分量的变化 $(\\Delta p_x, \\Delta p_y)$，以原子单位表示，\n- 绝对能量守恒误差，定义为 $\\left| \\big(K(\\mathbf{p}',\\mathbf{m}) + E_{\\mathrm{target}}(x)\\big) - \\big(K(\\mathbf{p},\\mathbf{m}) + E_{\\mathrm{source}}(x)\\big) \\right|$，以哈特里表示。\n\n使用以下测试套件，其中每个用例由 $(m_x, m_y, a, \\Delta, x, y, p_x, p_y, s)$ 指定，$s = +1$ 表示从较低的绝热势面跳跃到较高的绝热势面（向上跳跃），$s = -1$ 表示从较高的绝热势面跳跃到较低的绝热势面（向下跳跃）：\n1. $(m_x, m_y, a, \\Delta, x, y, p_x, p_y, s) = (1836, 1836, 0.02, 0.05, 0.5, 0.0, 5.0, 1.0, +1)$.\n2. $(m_x, m_y, a, \\Delta, x, y, p_x, p_y, s) = (1836, 1836, 0.02, 0.05, 0.5, 0.0, 0.05, 0.0, +1)$.\n3. $(m_x, m_y, a, \\Delta, x, y, p_x, p_y, s) = (1836, 1836, 0.02, 0.05, 0.5, 0.0, 5.0, 1.0, -1)$.\n4. $(m_x, m_y, a, \\Delta, x, y, p_x, p_y, s) = (5000, 1000, 0.03, 0.02, 1.0, 0.2, 40.0, 20.0, +1)$.\n5. $(m_x, m_y, a, \\Delta, x, y, p_x, p_y, s) = (1836, 1836, 0.02, 0.001, 0.0, 0.0, 3.0, 0.0, +1)$.\n\n对于每个用例，使用 $E_{\\pm}(x)$ 和 $s$ 计算 $\\Delta E$，沿 $\\hat{\\mathbf{e}}_x$ 方向进行动量调整，并报告跳跃成功与否、$\\Delta p_x$、$\\Delta p_y$ 和绝对能量守恒误差。如果跳跃被拒绝，报告跳跃成功为 false，$\\Delta p_x = 0$，$\\Delta p_y = 0$，并用未修改的动量和未修改的电子态计算绝对能量守恒误差（因此误差应为零）。\n\n您的程序应生成单行输出，其中包含五个测试用例的结果，格式为逗号分隔的列表的列表，每个内部列表的形式为 $[\\mathrm{success}, \\Delta p_x, \\Delta p_y, \\mathrm{error}]$，并用方括号括起来。例如，输出格式必须是\n$$\n[[\\mathrm{success}_1, \\Delta p_{x,1}, \\Delta p_{y,1}, \\mathrm{error}_1], \\ldots, [\\mathrm{success}_5, \\Delta p_{x,5}, \\Delta p_{y,5}, \\mathrm{error}_5]].\n$$\n验证对于所有成功的跳跃，绝对能量守恒误差都低于 $10^{-12}$ 哈特里。",
            "solution": "用户希望我推导出一个双态模型中势面跳跃的动量调整规则，并将其实现为一个 Python 程序。\n\n### 问题验证\n问题陈述在科学上是合理的、定义明确且客观的。它提供了一个计算物理学中的标准模型（避免交叉模型），以一致的原子单位定义了所有相关的物理量和参数，并指定了一个清晰的算法（Tully 势面跳跃中的动量重标度）。非绝热耦合沿 $x$ 轴方向是给定哈密顿量仅依赖于 $x$ 坐标的正确推论。测试用例定义明确，所需的输出格式也很清晰。该问题被认为是**有效的**。\n\n### 动量调整的推导\n核心原理是在瞬时电子跃迁（“跳跃”）期间总能量守恒。总能量 $E_{\\mathrm{tot}}$ 是核动能 $K(\\mathbf{p}, \\mathbf{m})$ 和电子势能 $E_{\\mathrm{elec}}(x)$ 的和。设初始状态由动量 $\\mathbf{p}=(p_x, p_y)$ 和电子能量 $E_{\\mathrm{source}}(x)$ 定义，末状态由动量 $\\mathbf{p}'=(p_x', p_y')$ 和电子能量 $E_{\\mathrm{target}}(x)$ 定义。\n\n总能量守恒意味着：\n$$\nE_{\\mathrm{tot, final}} = E_{\\mathrm{tot, initial}}\n$$\n$$\nK(\\mathbf{p}', \\mathbf{m}) + E_{\\mathrm{target}}(x) = K(\\mathbf{p}, \\mathbf{m}) + E_{\\mathrm{source}}(x)\n$$\n令 $\\Delta E = E_{\\mathrm{target}}(x) - E_{\\mathrm{source}}(x)$ 为电子能量的变化。动能的变化必须补偿这个能量差：\n$$\nK(\\mathbf{p}', \\mathbf{m}) = K(\\mathbf{p}, \\mathbf{m}) - \\Delta E\n$$\n问题陈述指出，动量调整仅沿非绝热耦合的方向进行，该方向被指定为 $x$ 轴（$\\hat{\\mathbf{e}}_x$）。这意味着只有动量的 $p_x$ 分量发生变化，而 $p_y$ 保持不变（$p_y' = p_y$）。\n\n展开动能项：\n$$\n\\frac{(p_x')^2}{2 m_x} + \\frac{(p_y')^2}{2 m_y} = \\frac{p_x^2}{2 m_x} + \\frac{p_y^2}{2 m_y} - \\Delta E\n$$\n由于 $p_y' = p_y$，涉及 $p_y$ 的项相互抵消：\n$$\n\\frac{(p_x')^2}{2 m_x} = \\frac{p_x^2}{2 m_x} - \\Delta E\n$$\n求解 $(p_x')^2$：\n$$\n(p_x')^2 = p_x^2 - 2 m_x \\Delta E\n$$\n这为新的动量分量 $p_x'$ 提供了两个可能的解：\n$$\np_x' = \\pm \\sqrt{p_x^2 - 2 m_x \\Delta E}\n$$\n\n### 跳跃情景分析\n我们将平方根下的量定义为 $\\alpha = p_x^2 - 2 m_x \\Delta E$。为了使 $p_x'$ 是实数，必须有 $\\alpha \\ge 0$。\n\n绝热能量由 $E_{\\pm}(x) = \\pm \\sqrt{(ax)^2 + (\\Delta/2)^2}$ 给出。\n\n**1. 向上跳跃 ($s = +1$)**\n跳跃是从较低势面 $E_-(x)$ 到较高势面 $E_+(x)$。\n$E_{\\mathrm{source}}(x) = E_-(x)$ 且 $E_{\\mathrm{target}}(x) = E_+(x)$。\n电子能量的变化为 $\\Delta E = E_+(x) - E_-(x) = 2 \\sqrt{(ax)^2 + (\\Delta/2)^2}$。由于平方根总是非负的，$\\Delta E \\ge 0$。动能必须被消耗以提供电子激发所需的能量。\n\n为了使 $p_x'$ 存在实数解，我们需要 $\\alpha \\ge 0$：\n$$\np_x^2 - 2 m_x \\Delta E \\ge 0 \\implies \\frac{p_x^2}{2m_x} \\ge \\Delta E\n$$\n这个条件意味着与运动的 $x$ 分量相关的动能必须至少与电子跃迁所需的能量一样大。如果不满足此条件（$\\alpha < 0$），则沿耦合方向没有足够的动能来支付跳跃的能量。该跳跃被拒绝，或称为“受挫”。在这种情况下，跳跃不成功，动量保持不变（$\\Delta p_x = 0$，$\\Delta p_y = 0$）。\n\n如果跳跃成功（$\\alpha \\ge 0$），我们必须在 $p_x' = \\sqrt{\\alpha}$ 和 $p_x' = -\\sqrt{\\alpha}$ 之间进行选择。问题陈述要求使用“与跳跃方向一致的最小变化”的解。这被解释为选择最接近原始 $p_x$ 的 $p_x'$ 值。这对应于选择与原始 $p_x$ 符号相同的根，从而有效地减小其大小：\n$$\np_x' = \\mathrm{sign}(p_x) \\sqrt{\\alpha}\n$$\n\n**2. 向下跳跃 ($s = -1$)**\n跳跃是从较高势面 $E_+(x)$ 到较低势面 $E_-(x)$。\n$E_{\\mathrm{source}}(x) = E_+(x)$ 且 $E_{\\mathrm{target}}(x) = E_-(x)$。\n电子能量的变化为 $\\Delta E = E_-(x) - E_+(x) = -2 \\sqrt{(ax)^2 + (\\Delta/2)^2}$。在这种情况下，$\\Delta E \\le 0$。能量从电子系统释放并转化为核动能。\n\n条件 $\\alpha \\ge 0$ 变为 $p_x^2 - 2 m_x \\Delta E \\ge 0$。由于 $m_x > 0$ 且 $\\Delta E \\le 0$，项 $-2m_x\\Delta E$ 是非负的。因此，对于向下跳跃，$\\alpha$ 总是非负的。向下跳跃从不会因能量原因被拒绝。\n\n与向上跳跃一样，我们选择代表最小变化的 $p_x'$ 解，这同样对应于保持 $p_x$ 的符号：\n$$\np_x' = \\mathrm{sign}(p_x) \\sqrt{\\alpha} = \\mathrm{sign}(p_x) \\sqrt{p_x^2 - 2 m_x \\Delta E}\n$$\n这个选择增加了沿耦合方向动量的大小。如果 $p_x=0$，两个根 $\\pm\\sqrt{\\alpha}$ 代表相等的变化。按照惯例，我们可以选择正根，这对应于在耦合矢量的正方向上给粒子一个“推动”。`np.copysign` 函数方便地处理了这种逻辑，包括 $p_x=0$ 的情况，此时它默认为正根。\n\n### 最终算法总结\n对于每个测试用例 $(m_x, m_y, a, \\Delta, x, y, p_x, p_y, s)$：\n1. 计算跳跃的能隙，$\\Delta E = s \\cdot 2 \\sqrt{(ax)^2 + (\\Delta/2)^2}$。\n2. 计算 $\\alpha = p_x^2 - 2 m_x \\Delta E$。\n3. 如果是向上跳跃（$s=+1$）且 $\\alpha < 0$，则跳跃被拒绝。结果是 `[false, 0.0, 0.0, 0.0]`。\n4. 否则，跳跃成功。\n   a. 计算新动量 $p_x' = \\mathrm{copysign}(\\sqrt{\\alpha}, p_x)$。\n   b. 计算动量变化 $\\Delta p_x = p_x' - p_x$ 和 $\\Delta p_y = 0$。\n   c. 通过计算误差来验证能量守恒：$\\left| (K(\\mathbf{p}') + E_{\\mathrm{target}}) - (K(\\mathbf{p}) + E_{\\mathrm{source}}) \\right|$，其值应接近机器精度。\n   d. 结果是 `[true, $\\Delta p_x$, $\\Delta p_y$, error]`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases for the surface hopping problem.\n    \"\"\"\n\n    def compute_hop(params):\n        \"\"\"\n        Computes the momentum adjustment for a single surface hop event according to\n        Tully's fewest switches surface hopping algorithm rules.\n\n        Args:\n            params (tuple): A tuple containing the parameters for the hop event:\n                            (mx, my, a, delta_param, x, y, px, py, s)\n\n        Returns:\n            list: A list containing [success, delta_px, delta_py, error].\n        \"\"\"\n        mx, my, a, delta_param, x, y, px, py, s = params\n\n        # 1. Calculate adiabatic energies and the energy difference for the hop.\n        #    The adiabatic energies are E_pm = +/- sqrt((a*x)^2 + (Delta/2)^2).\n        E_gap_half = np.sqrt((a * x)**2 + (delta_param / 2)**2)\n        delta_E = s * 2 * E_gap_half\n\n        if s == 1:  # Upward hop: from E- to E+\n            E_source = -E_gap_half\n            E_target = E_gap_half\n        else:  # Downward hop: from E+ to E-\n            E_source = E_gap_half\n            E_target = -E_gap_half\n\n        # 2. Calculate the initial total energy for the final error check.\n        K_initial = px**2 / (2 * mx) + py**2 / (2 * my)\n        E_total_initial = K_initial + E_source\n\n        # 3. Determine if the hop is energetically possible.\n        #    From energy conservation, (p_x')^2 = p_x^2 - 2*m_x*delta_E.\n        #    The term under the square root, alpha, must be non-negative.\n        alpha = px**2 - 2 * mx * delta_E\n\n        if s == 1 and alpha  0:\n            # Hop is rejected (\"frustrated\") as there is insufficient kinetic energy.\n            success = False\n            delta_px = 0.0\n            delta_py = 0.0\n            # As per the problem, the error is 0 since momentum and state are unchanged.\n            error = 0.0\n            return [success, delta_px, delta_py, error]\n\n        # 4. If the hop is not rejected, calculate the new momentum and related quantities.\n        success = True\n        \n        sqrt_alpha = np.sqrt(alpha)\n        # Choose the root for p_x' that corresponds to minimal change, which means\n        # preserving the sign of p_x. np.copysign handles the px=0 case by\n        # convention, assigning the sign of +0.0 (positive).\n        px_new = np.copysign(sqrt_alpha, px)\n            \n        py_new = py  # Momentum component orthogonal to the coupling is unchanged.\n\n        delta_px = px_new - px\n        delta_py = 0.0\n\n        # 5. Calculate the absolute energy conservation error to verify the calculation.\n        K_final = px_new**2 / (2 * mx) + py_new**2 / (2 * my)\n        E_total_final = K_final + E_target\n        error = np.abs(E_total_final - E_total_initial)\n\n        return [success, delta_px, delta_py, error]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (mx, my, a, delta, x, y, px, py, s)\n        (1836, 1836, 0.02, 0.05, 0.5, 0.0, 5.0, 1.0, +1),\n        (1836, 1836, 0.02, 0.05, 0.5, 0.0, 0.05, 0.0, +1),\n        (1836, 1836, 0.02, 0.05, 0.5, 0.0, 5.0, 1.0, -1),\n        (5000, 1000, 0.03, 0.02, 1.0, 0.2, 40.0, 20.0, +1),\n        (1836, 1836, 0.02, 0.001, 0.0, 0.0, 3.0, 0.0, +1),\n    ]\n\n    results = [compute_hop(case) for case in test_cases]\n\n    # Format the output string precisely as specified in the problem statement.\n    formatted_results = []\n    for res in results:\n        s_bool, dpx, dpy, err = res\n        s_str = str(s_bool).lower() # Convert True/False to true/false\n        # Use full precision for floats, then join into a string representation of a list.\n        formatted_results.append(f\"[{s_str},{dpx},{dpy},{err}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了动量重整化的基本原理后，下一步是将其整合到一个完整的动力学模拟中。这个练习  指导您从第一性原理出发，为锥形交叉（光化学中的一个关键特征）的二维振动模型构建一个功能齐全的 FSSH 模拟。您需要处理原子核的运动、电子波函数的演化以及两者之间的随机跳跃耦合，最终量化一个重要的物理量——受阻跳跃的发生率，从而深入理解 FSSH 在模拟复杂非绝热过程中的能力和挑战。",
            "id": "3826214",
            "problem": "考虑一个在两个核坐标中的锥形交叉（CI）的双态振动电子模型，其中非绝热电子哈密顿量线性地依赖于核坐标。目标是实现最少切换表面跳跃（FSSH）来模拟跨越CI的非绝热分子动力学，并量化当沿着非绝热耦合（NAC）方向的动能较低时，在交叉缝附近发生的受阻跳跃的速率。您必须从基本原理出发，仅从电子子系统的含时薛定谔方程和核的牛顿第二定律推导出所有必需的量，而不假设预先给定的简化公式。在整个过程中使用原子单位，其中约化普朗克常数为$1$，距离单位为玻尔，能量单位为哈特里，质量单位为电子质量单位，时间单位为原子时间单位。将最终指标报告为无量纲的小数。\n\n基本基础：\n- 核遵守牛顿第二定律，\n$$m \\, \\frac{d^2 \\mathbf{R}}{dt^2} = -\\nabla E_\\mathrm{active}(\\mathbf{R})$$\n其中 $\\mathbf{R} = (x,y)$，$m$ 是核质量（假设两个坐标的质量相同），$E_\\mathrm{active}(\\mathbf{R})$ 是当前活化电子态的绝热能量。\n- 电子振幅 $\\{c_1, c_2\\}$ 遵守含时薛定谔方程\n$$i \\, \\frac{d \\mathbf{c}}{dt} = \\hat{H}_\\mathrm{el}(\\mathbf{R}(t)) \\, \\mathbf{c}(t)$$\n其中包括由核速度 $\\mathbf{v} = d\\mathbf{R}/dt$ 引起的导数（非绝热）耦合。绝热态之间每个时间步的非绝热跃迁概率源于此动力学，并且必须被推导出来。\n- 非绝热哈密顿量在核坐标上是线性的，其对角项在交叉缝两边变号，非对角耦合项依赖于与交叉缝方向垂直的坐标。具体来说，非绝热哈密顿量的形式为\n$$\n\\hat{H}_\\mathrm{d}(\\mathbf{R}) =\n\\begin{pmatrix}\n\\lambda x   \\kappa y \\\\\n\\kappa y  -\\lambda x\n\\end{pmatrix},\n$$\n其中 $\\lambda$ 和 $\\kappa$ 是常数参数。其绝热能量和本征矢量必须通过对角化获得，而绝热态之间的导数耦合必须从绝热本征矢量的核坐标依赖性中获得。\n\n模拟与可观测量：\n- 为这个双态、双坐标的CI模型，在绝热表象中实现最少切换表面跳跃（FSSH）。使用与 $m \\, d^2 \\mathbf{R} / dt^2 = -\\nabla E_\\mathrm{active}(\\mathbf{R})$ 一致的时间可逆方案，在当前活化的绝热面上进行核的传播。\n- 使用计算出的绝热能量和导数耦合，根据含时薛定谔方程传播电子振幅。\n- 根据推导出的绝热态之间的跃迁概率，随机决定是否跳跃。在尝试跳跃时，沿NAC方向重新标度核速度以保持总能量守恒。如果由于NAC方向上的动能不足而无法满足能量守恒，则该跳跃是受阻的，必须被拒绝。您必须仅沿NAC方向测试能量重标度的可行性。\n- 量化在定义的“近交叉缝”区域内发生的受阻向上跳跃的比例，您必须根据欧几里得距离 $r = \\sqrt{x^2 + y^2}$ 来定义该区域。只统计中心位于近交叉缝区域内的向上尝试跳跃（从较低的绝热面到较高的绝热面），并报告在这些尝试中受阻的比例。如果在近交叉缝区域内没有尝试向上跳跃，则该测试用例报告$0.0$。\n\n单位与输出：\n- 所有量均使用原子单位。受阻跳跃的比例是无量纲的，必须表示为小数点后保留六位的小数。\n- 角度（如有）必须以弧度为单位解释。\n\n模型参数与积分控制：\n- 非绝热线性系数：$\\lambda = 0.5$ 和 $\\kappa = 0.3$。\n- 核质量：$m = 2000$（对两个自由度均适用）。\n- 时间步长：$\\Delta t = 0.1$。\n- 每个测试用例的时间步数：$N_\\mathrm{steps} = 10000$。\n- 近交叉缝半径：$r_0 = 0.05$。\n- 随机数生成器必须确定性地设置种子，以便所有结果都是可复现的。\n\n初始条件与测试套件：\n对于每个测试用例，将初始活化面设置为较低的绝热态，并将初始电子振幅设置为 $c_\\mathrm{lower}(0) = 1$ 和 $c_\\mathrm{upper}(0) = 0$。对于速度取向，使用初始位置 $\\mathbf{R}(0)$ 处的NAC单位矢量；“对齐”意味着速度与NAC单位矢量共线，“垂直”意味着速度与其正交。\n\n提供以下测试套件：\n- 测试用例A（理想路径，近交叉缝，低NAC方向动能）：$\\mathbf{R}(0) = (0.02, 0.02)$，速率 $s = 0.05$，速度在 $\\mathbf{R}(0)$ 处与NAC方向垂直。\n- 测试用例B（近交叉缝，高NAC方向动能）：$\\mathbf{R}(0) = (0.02, 0.02)$，速率 $s = 0.20$，速度在 $\\mathbf{R}(0)$ 处与NAC方向对齐。\n- 测试用例C（远离交叉缝，中等速率，低NAC方向动能）：$\\mathbf{R}(0) = (0.20, 0.20)$，速率 $s = 0.10$，速度在 $\\mathbf{R}(0)$ 处与NAC方向垂直。\n- 测试用例D（非常靠近交叉缝，非常低速率，低NAC方向动能）：$\\mathbf{R}(0) = (0.01, 0.01)$，速率 $s = 0.005$，速度在 $\\mathbf{R}(0)$ 处与NAC方向垂直。\n\n要求的最终程序行为：\n- 实现上述模拟，并为每个测试用例计算在近交叉缝区域 $r  r_0$ 内受阻向上跳跃的比例。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，结果顺序为 $[A,B,C,D]$，其中每个条目是小数点后保留六位的小数，例如 $[0.123456,0.234567,0.000000,0.999000]$。",
            "solution": "该问题要求为一个双态、二维线性振动电子耦合模型的锥形交叉（CI）实现最少切换表面跳跃（FSSH）算法。所有与动力学相关的量都必须从基本原理推导。该模拟将用于计算CI交叉缝附近受阻向上跳跃的比例。\n\n**1. 绝热表象**\n\n系统由一个非绝热电子哈密顿量描述，该哈密顿量是核坐标 $\\mathbf{R} = (x, y)$ 的线性函数：\n$$\n\\hat{H}_\\mathrm{d}(\\mathbf{R}) =\n\\begin{pmatrix}\n\\lambda x   \\kappa y \\\\\n\\kappa y  -\\lambda x\n\\end{pmatrix}\n$$\nFSSH算法在绝热表象中运行。绝热能量 $E_k(\\mathbf{R})$ 是 $\\hat{H}_\\mathrm{d}(\\mathbf{R})$ 的本征值。它们通过求解特征方程 $\\det(\\hat{H}_\\mathrm{d} - E \\mathbb{I}) = 0$ 得到：\n$$\n(\\lambda x - E)(-\\lambda x - E) - (\\kappa y)^2 = 0 \\implies E^2 = (\\lambda x)^2 + (\\kappa y)^2\n$$\n这给出了两个绝热势能面：\n$$\nE_{0,1}(\\mathbf{R}) = \\mp \\sqrt{(\\lambda x)^2 + (\\kappa y)^2}\n$$\n其中，我们将较低的态记为 $k=0$，较高的态记为 $k=1$。这两个态在原点 $\\mathbf{R}=(0,0)$ 处简并，这里是锥形交叉点。令 $E(\\mathbf{R}) = \\sqrt{(\\lambda x)^2 + (\\kappa y)^2}$，则 $E_0 = -E$ 且 $E_1 = E$。\n\n绝热电子态 $|\\psi_k(\\mathbf{R})\\rangle$ 是相应的本征矢量。它们通过一个幺正变换与非绝热态 $|\\phi_1\\rangle, |\\phi_2\\rangle$（即标准基矢量 $(1,0)^T$ 和 $(0,1)^T$）相关联。一种方便表示本征矢量的方法是定义一个混合角 $\\theta(\\mathbf{R})$：\n$$\n\\cos(2\\theta) = \\frac{\\lambda x}{E}, \\quad \\sin(2\\theta) = \\frac{\\kappa y}{E}\n$$\n这意味着 $2\\theta(\\mathbf{R}) = \\mathrm{atan2}(\\kappa y, \\lambda x)$。由此，非绝热哈密顿量可以写为：\n$$\n\\hat{H}_\\mathrm{d} = E \\begin{pmatrix} \\cos(2\\theta)   \\sin(2\\theta) \\\\ \\sin(2\\theta)  -\\cos(2\\theta) \\end{pmatrix}\n$$\n对应于本征值 $E_0 = -E$ 和 $E_1 = E$ 的归一化本征矢量（绝热态）是：\n$$\n|\\psi_0(\\mathbf{R})\\rangle = \\begin{pmatrix} -\\sin\\theta \\\\ \\cos\\theta \\end{pmatrix}, \\quad |\\psi_1(\\mathbf{R})\\rangle = \\begin{pmatrix} \\cos\\theta \\\\ \\sin\\theta \\end{pmatrix}\n$$\n\n**2. 非绝热耦合（NAC）**\n\n核运动引起绝热态之间的跃迁。这由非绝热耦合（NAC）矢量 $\\mathbf{d}_{kj}(\\mathbf{R}) = \\langle \\psi_k | \\nabla_{\\mathbf{R}} | \\psi_j \\rangle$ 控制。对于一个双态系统，我们关心的是 $\\mathbf{d}_{01}$。对于 $k \\ne j$，使用Hellmann-Feynman定理：\n$$\n\\mathbf{d}_{kj} = \\frac{\\langle \\psi_k | (\\nabla_{\\mathbf{R}} \\hat{H}_\\mathrm{d}) | \\psi_j \\rangle}{E_j - E_k}\n$$\n非绝热哈密顿量的梯度为：\n$$\n\\nabla_x \\hat{H}_\\mathrm{d} = \\begin{pmatrix} \\lambda   0 \\\\ 0  -\\lambda \\end{pmatrix} = \\lambda\\sigma_z, \\quad \\nabla_y \\hat{H}_\\mathrm{d} = \\begin{pmatrix} 0   \\kappa \\\\ \\kappa  0 \\end{pmatrix} = \\kappa\\sigma_x\n$$\n将这些梯度算符变换到绝热基并取非对角元，得到分子的矩阵元。能量分母是 $E_1 - E_0 = 2E$。这导致：\n$$\nd_{01,x} = \\frac{\\langle \\psi_0 | \\lambda \\sigma_z | \\psi_1 \\rangle}{2E} = \\frac{\\lambda(-\\sin(2\\theta))}{2E} = \\frac{-\\lambda}{2E} \\frac{\\kappa y}{E} = \\frac{-\\lambda \\kappa y}{2E^2}\n$$\n$$\nd_{01,y} = \\frac{\\langle \\psi_0 | \\kappa \\sigma_x | \\psi_1 \\rangle}{2E} = \\frac{\\kappa(\\cos(2\\theta))}{2E} = \\frac{\\kappa}{2E} \\frac{\\lambda x}{E} = \\frac{\\lambda \\kappa x}{2E^2}\n$$\n综合起来，NAC矢量是：\n$$\n\\mathbf{d}_{01}(\\mathbf{R}) = \\frac{\\lambda \\kappa}{2((\\lambda x)^2 + (\\kappa y)^2)} \\begin{pmatrix} -y \\\\ x \\end{pmatrix}\n$$\n这个结果可以通过注意到 $\\mathbf{d}_{01} = \\langle \\psi_0 | \\nabla \\psi_1 \\rangle = \\nabla \\theta$ 来验证，这会得到相同的表达式。注意 $\\mathbf{d}_{10} = -\\mathbf{d}_{01}$。NAC矢量在CI处是奇异的，这需要仔细的数值处理。\n\n**3. 运动方程**\n\n模拟将经典核动力学与量子电子动力学耦合起来。\n核在活化的绝热面 $E_k(\\mathbf{R})$ 上根据牛顿第二定律演化：\n$$\nm \\frac{d^2\\mathbf{R}}{dt^2} = \\mathbf{F}_k(\\mathbf{R}) = -\\nabla_{\\mathbf{R}} E_k(\\mathbf{R})\n$$\n力为 $\\mathbf{F}_0 = -\\nabla E_0 = \\nabla E$ 和 $\\mathbf{F}_1 = -\\nabla E_1 = -\\nabla E$，其中 $\\nabla E = (E)^{-1}(\\lambda^2 x, \\kappa^2 y)$。因此，相对于CI，较低的势能面是排斥的，较高的势能面是吸引的。\n\n电子波函数 $|\\Psi(t)\\rangle = c_0(t)|\\psi_0\\rangle + c_1(t)|\\psi_1\\rangle$ 根据绝热基中的含时薛定谔方程演化：\n$$\ni \\frac{d c_k}{dt} = E_k c_k - i \\sum_j (\\mathbf{v} \\cdot \\mathbf{d}_{kj}) c_j\n$$\n其中 $\\mathbf{v} = d\\mathbf{R}/dt$ 是核速度。这可以写成矩阵形式 $i \\dot{\\mathbf{c}} = \\mathbf{A} \\mathbf{c}$，其中耦合矩阵 $\\mathbf{A}$ 为：\n$$\n\\mathbf{A} = \\begin{pmatrix} E_0   -i \\mathbf{v} \\cdot \\mathbf{d}_{01} \\\\ i \\mathbf{v} \\cdot \\mathbf{d}_{01}  E_1 \\end{pmatrix}\n$$\n\n**4. 数值积分方案**\n\n使用Velocity-Verlet算法来积分核的运动方程。单个时间步长 $\\Delta t$ 的执行过程如下：\n1.  半步更新速度：$\\mathbf{v}(t+\\Delta t/2) = \\mathbf{v}(t) + \\mathbf{F}_k(t)/m \\cdot (\\Delta t/2)$。\n2.  整步更新位置：$\\mathbf{R}(t+\\Delta t) = \\mathbf{R}(t) + \\mathbf{v}(t+\\Delta t/2) \\cdot \\Delta t$。\n3.  在 $\\mathbf{R}(t+\\Delta t)$ 处，评估电子性质（$E_k$, $\\mathbf{d}_{01}$）并将电子系数 $c_k$ 从 $t$ 传播到 $t+\\Delta t$。\n4.  执行FSSH随机跳跃决策。如果发生跳跃，更新活化态 $k$ 并重新标度速度 $\\mathbf{v}(t+\\Delta t/2)$。\n5.  使用（可能已更新的）活化态计算新的力 $\\mathbf{F}_k(t+\\Delta t)$。\n6.  第二个半步更新速度：$\\mathbf{v}(t+\\Delta t) = \\mathbf{v}(t+\\Delta t/2) + \\mathbf{F}_k(t+\\Delta t)/m \\cdot (\\Delta t/2)$。\n\n**5. FSSH算法细节**\n\n- **电子传播**：电子系数通过矩阵指数在 $\\Delta t$ 时间内传播：$\\mathbf{c}(t+\\Delta t) = \\exp(-i\\mathbf{A}\\Delta t)\\mathbf{c}(t)$。对于一个 $2 \\times 2$ 的矩阵 $\\mathbf{A}$，这可以解析计算。令 $\\Omega = \\sqrt{E^2 + (\\mathbf{v}\\cdot\\mathbf{d}_{01})^2}$。传播算符为：\n$$\n\\exp(-i\\mathbf{A}\\Delta t) = \\cos(\\Omega\\Delta t)\\mathbb{I} - i \\frac{\\sin(\\Omega\\Delta t)}{\\Omega} \\left(\\mathbf{A} - \\frac{E_0+E_1}{2}\\mathbb{I}\\right)\n$$\n由于 $E_0+E_1=0$，第二项得到简化。\n\n- **跳跃概率**：在 $\\Delta t$ 内从活化态 $k$ 跳到另一态 $j$ 的概率计算为 $P_{k \\to j} = \\max(0, b_{kj}\\Delta t)$，其中：\n$$\nb_{kj} = -2\\frac{\\mathrm{Re}[c_j^* c_k (\\mathbf{v} \\cdot \\mathbf{d}_{kj})]}{|c_k|^2}\n$$\n抽取一个随机数 $\\xi \\in [0,1]$。如果 $\\xi  P_{k \\to j}$，则尝试一次跳跃。\n\n- **随机跳跃与能量守恒**：在尝试从态 $k$ 跳到态 $j$ 时，总能量必须守恒。动能必须改变 $\\Delta E = E_k - E_j$。这个改变通过重新标度核速度沿NAC矢量 $\\mathbf{d}_{kj}$ 的分量来满足。令 $\\hat{\\mathbf{d}}_{kj}$ 为沿 $\\mathbf{d}_{kj}$ 的单位矢量，且 $v_\\parallel = \\mathbf{v} \\cdot \\hat{\\mathbf{d}}_{kj}$。新的速度分量 $v'_\\parallel$ 必须满足：\n$$\n\\frac{1}{2}m(v'_\\parallel)^2 = \\frac{1}{2}m v_\\parallel^2 + \\Delta E\n$$\n如果沿NAC方向没有足够的动能来提供所需的势能，即如果 $v_\\parallel^2 + 2\\Delta E/m  0$，则跳跃是**受阻的**并被拒绝。否则，跳跃被接受，活化态切换到 $j$，并且速度更新为：\n$$\nv'_\\parallel = \\mathrm{sign}(v_\\parallel) \\sqrt{v_\\parallel^2 + 2\\Delta E/m}\n$$\n$$\n\\mathbf{v}' = \\mathbf{v} + (v'_\\parallel - v_\\parallel)\\hat{\\mathbf{d}}_{kj}\n$$\n\n**6. 可观测量定义**\n\n目标是量化在近交叉缝区域内（由 $r  r_0$ 定义）受阻向上跳跃的比例。向上跳跃（从 $k=0$ 到 $j=1$）是受阻的，如果尝试了跳跃但被能量守恒条件拒绝。该算法必须跟踪：\n- `total_upward_hops_in_region`: 在 $r  r_0$ 区域内，从活化态 0 到 1 的跳跃尝试次数。\n- `frustrated_upward_hops_in_region`: 上述跳跃尝试中受阻的次数。\n\n最终报告的比率是 `frustrated_upward_hops_in_region` / `total_upward_hops_in_region`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global parameters in atomic units\nPARAMS = {\n    'lambda': 0.5,\n    'kappa': 0.3,\n    'm': 2000.0,\n    'dt': 0.1,\n    'n_steps': 10000,\n    'r0': 0.05,\n    'seed': 42  # For reproducible results\n}\n\ndef get_adiabatic_properties(R, lam, kap):\n    \"\"\"\n    Computes adiabatic energies and the non-adiabatic coupling vector.\n    \"\"\"\n    x, y = R\n    E_sq = (lam * x)**2 + (kap * y)**2\n    \n    # Add a small epsilon to avoid division by zero right at the CI\n    if E_sq  1e-24:\n        # At the CI, energies are degenerate and NAC is undefined. \n        # Return zeros; logic downstream should handle this gracefully.\n        return np.zeros(2), np.zeros(2)\n\n    E = np.sqrt(E_sq)\n    \n    # Adiabatic energies: E0 (lower), E1 (upper)\n    energies = np.array([-E, E])\n    \n    # Non-adiabatic coupling vector d_01\n    d01_vec = (lam * kap / (2.0 * E_sq)) * np.array([-y, x])\n    \n    return energies, d01_vec\n\ndef get_force(R, active_state, energies, lam, kap):\n    \"\"\"\n    Computes the force on the nuclei for the given active state.\n    F_k = -grad(E_k)\n    \"\"\"\n    E = energies[1]  # E is the magnitude, E_1 = E\n    if E  1e-12:\n        return np.zeros(2)\n        \n    x, y = R\n    grad_E = np.array([lam**2 * x, kap**2 * y]) / E\n    \n    if active_state == 0:  # Lower surface: F = -grad(E_0) = -grad(-E) = grad(E)\n        return grad_E\n    else:  # Upper surface: F = -grad(E_1) = -grad(E)\n        return -grad_E\n\ndef propagate_electronic(c, v, energies, d01_vec, dt):\n    \"\"\"\n    Propagates electronic coefficients over one time step.\n    \"\"\"\n    E0, E1 = energies\n    E_half_gap = (E1 - E0) / 2.0  # This is E\n\n    V01 = np.dot(v, d01_vec)\n    \n    omega_sq = E_half_gap**2 + V01**2\n    if omega_sq  1e-24:\n        omega = 0.0\n    else:\n        omega = np.sqrt(omega_sq)\n\n    if omega == 0.0:\n        # No coupling or degeneracy, only phase evolution\n        U = np.diag([np.exp(-1j * E0 * dt), np.exp(-1j * E1 * dt)])\n    else:\n        C_ = np.cos(omega * dt)\n        S_ = np.sin(omega * dt) / omega\n        \n        # Propagator for c = (c_0, c_1)^T\n        # A = [E0, -iV01; iV01, E1]. exp(-iA*dt)\n        # Simplified since E0+E1 = 0\n        U = np.array([\n            [C_ - 1j * E0 * S_, -V01 * S_],\n            [V01 * S_, C_ - 1j * E1 * S_]\n        ])\n\n    return U @ c\n\ndef fssh_hop_logic(c, v, energies, d01_vec, R, active_state, m, dt, r0, counters, rng):\n    \"\"\"\n    Implements FSSH stochastic hopping logic, velocity rescaling, and frustration check.\n    \"\"\"\n    k = active_state  # current state\n    j = 1 - k  # target state\n\n    c_k_norm_sq = np.abs(c[k])**2\n    if c_k_norm_sq  1e-12:\n        return active_state, v\n\n    d_kj = d01_vec if k == 0 else -d01_vec\n    V_kj = np.dot(v, d_kj)\n    \n    b_kj = -2.0 * np.real(np.conj(c[j]) * c[k] * V_kj) / c_k_norm_sq\n    p_hop = b_kj * dt\n    \n    if p_hop = 0:\n        return active_state, v\n\n    xi = rng.random()\n    if xi  p_hop:\n        # Hop is attempted\n        is_upward_hop = (k == 0)\n        pos_norm = np.linalg.norm(R)\n        in_region = (pos_norm  r0)\n\n        if is_upward_hop and in_region:\n            counters['total_upward_hops_in_region'] += 1\n            \n        DeltaE = energies[k] - energies[j]\n        \n        d_norm_sq = np.dot(d_kj, d_kj)\n        if d_norm_sq  1e-16: # NAC vector is zero, direction undefined\n            if is_upward_hop and in_region:\n                counters['frustrated_upward_hops_in_region'] += 1\n            return k, v # Reject hop\n\n        d_hat = d_kj / np.sqrt(d_norm_sq)\n        v_parallel = np.dot(v, d_hat)\n        \n        T_rescale_sq = v_parallel**2 + 2.0 * DeltaE / m\n\n        if T_rescale_sq  0: # Frustrated hop\n            if is_upward_hop and in_region:\n                counters['frustrated_upward_hops_in_region'] += 1\n            # hop is rejected\n            return k, v\n        else: # Hop accepted\n            v_parallel_new = np.sign(v_parallel) * np.sqrt(T_rescale_sq) if v_parallel != 0 else np.sqrt(T_rescale_sq)\n            v_new = v + (v_parallel_new - v_parallel) * d_hat\n            return j, v_new\n\n    return k, v # No hop\n\ndef run_simulation(R0, v0):\n    \"\"\"\n    Main FSSH simulation function for a single trajectory.\n    \"\"\"\n    lam = PARAMS['lambda']\n    kap = PARAMS['kappa']\n    m = PARAMS['m']\n    dt = PARAMS['dt']\n    n_steps = PARAMS['n_steps']\n    r0 = PARAMS['r0']\n    seed = PARAMS['seed']\n    rng = np.random.default_rng(seed)\n\n    R = np.array(R0, dtype=float)\n    v = np.array(v0, dtype=float)\n    c = np.array([1.0 + 0j, 0.0 + 0j]) # Start in lower state, c0=1\n    active_state = 0\n    \n    counters = {\n        'total_upward_hops_in_region': 0,\n        'frustrated_upward_hops_in_region': 0\n    }\n\n    for _ in range(n_steps):\n        # Velocity-Verlet part 1\n        energies_t, _ = get_adiabatic_properties(R, lam, kap)\n        force_t = get_force(R, active_state, energies_t, lam, kap)\n        v_half = v + force_t / m * (dt / 2.0) # v(t+dt/2)\n        \n        # Position update\n        R += v_half * dt # R(t+dt)\n        \n        # Electronic properties at R(t+dt) and propagation using v(t+dt/2)\n        energies, d01_vec = get_adiabatic_properties(R, lam, kap)\n        c = propagate_electronic(c, v_half, energies, d01_vec, dt)\n        \n        # FSSH logic\n        new_active_state, v_half_new = fssh_hop_logic(c, v_half, energies, d01_vec, R, active_state, m, dt, r0, counters, rng)\n\n        active_state = new_active_state\n        v_half = v_half_new\n        \n        # Velocity-Verlet part 2\n        energies, _ = get_adiabatic_properties(R, lam, kap)\n        force_tp1 = get_force(R, active_state, energies, lam, kap)\n        v = v_half + force_tp1 / m * (dt / 2.0) # v(t+dt)\n        \n    if counters['total_upward_hops_in_region'] == 0:\n        return 0.0\n    \n    fraction = counters['frustrated_upward_hops_in_region'] / counters['total_upward_hops_in_region']\n    return fraction\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test suite, printing the final results.\n    \"\"\"\n    test_cases_spec = [\n        {'R0': (0.02, 0.02), 's': 0.05, 'align': 'perp'},\n        {'R0': (0.02, 0.02), 's': 0.20, 'align': 'aligned'},\n        {'R0': (0.20, 0.20), 's': 0.10, 'align': 'perp'},\n        {'R0': (0.01, 0.01), 's': 0.005, 'align': 'perp'}\n    ]\n\n    results = []\n    \n    for case in test_cases_spec:\n        R0 = np.array(case['R0'])\n        s = case['s']\n        align = case['align']\n        \n        _, d01_at_R0 = get_adiabatic_properties(R0, PARAMS['lambda'], PARAMS['kappa'])\n        d01_norm = np.linalg.norm(d01_at_R0)\n        \n        if d01_norm  1e-12:\n            # Handle cases where NAC is ill-defined e.g. on an axis\n            # For R=(a,a), d01 direction is (-1,1)\n            nac_dir = np.array([-1.0, 1.0]) / np.sqrt(2.0)\n        else:\n            nac_dir = d01_at_R0 / d01_norm\n        \n        if align == 'aligned':\n            v0 = s * nac_dir\n        else: # 'perp'\n            perp_dir = np.array([-nac_dir[1], nac_dir[0]])\n            v0 = s * perp_dir\n            \n        fraction = run_simulation(R0, v0)\n        results.append(f\"{fraction:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "标准的 FSSH 算法在理论上存在一个著名缺陷：它不能严格满足细致平衡原理，这主要源于“受阻跳跃”问题——即向上跃迁因原子核动能不足而被拒绝。这个高级练习  允许您通过一个简化的模型来探索和评估各种针对受阻跳跃的修正方案，例如速度反转或布居数重整化。通过量化不同方案对细致平衡的偏离程度，您将对 FSSH 算法的理论局限性及其在追求统计力学一致性方面的改进策略有更深刻的认识。",
            "id": "5295188",
            "problem": "考虑一个一维双面非绝热分子动力学模型，该模型旨在分离对最小切换表面跳跃 (Fewest Switches Surface Hopping, FSSH) 中受阻跳跃的处理。核自由度由一个质量为 $m$、速度为 $v$ 的经典粒子表示。两个绝热电子能面具有恒定的能量差 $\\Delta E$，因此上层能面的能量为 $E_2 = E_1 + \\Delta E$，并且非绝热耦合被假定为与唯一的核自由度对齐，以使方向效应取决于 $v$ 的符号。所有量均为无量纲；设玻尔兹曼常数 $k_{\\mathrm{B}} = 1$。\n\n在每个离散时间步，从当前能面生成一个跳跃尝试，其概率线性依赖于沿非绝热耦合方向的速度分量，并被截断以保持在区间 $[0,1]$ 内。具体来说，定义一个小的耦合系数 $\\alpha  0$ 和一个前置因子 $p_0 \\in (0,1)$，并令尝试概率为\n$$\nP_{1\\to 2}^{\\mathrm{att}}(v) = \\min\\left(1,\\, p_0 \\max(0, \\alpha v)\\right), \\quad\nP_{2\\to 1}^{\\mathrm{att}}(v) = \\min\\left(1,\\, p_0 \\max(0, \\alpha(-v))\\right).\n$$\n仅当当前动能 $K=\\frac{1}{2} m v^2$ 满足 $K \\ge \\Delta E$ 时，向上跳跃 $1\\to 2$ 才能守恒总能量。如果跳跃被接受，它会通过以下方式重标定速度以守恒能量：\n$$\nv' = \\mathrm{sgn}(v)\\,\\sqrt{v^2 - \\frac{2\\Delta E}{m}}.\n$$\n向下跳跃 $2\\to 1$ 在能量上总是允许的，并类似地通过以下方式重标定速度：\n$$\nv' = \\mathrm{sgn}(v)\\,\\sqrt{v^2 + \\frac{2\\Delta E}{m}}.\n$$\n\n如果尝试的向上跳跃在能量上被禁止 ($K  \\Delta E$)，则它是一次受阻跳跃。您的算法必须为受阻跳跃实现两种控制选项：\n\n1. 速度反转判据。如果布尔标志 $r \\in \\{0,1\\}$ 设置为 $1$，则在发生受阻跳跃时，根据 $v \\leftarrow -v$ 反转核速度；如果 $r=0$，则保持 $v$ 不变。\n\n2. 布居数调整选项。在发生受阻跳跃时，通过乘以一个因子 $F$ 来修改下一步向上跳跃的尝试概率，该因子仅在接下来的一个时间步内有效，模式为 $\\mu \\in \\{\\mathrm{none}, \\mathrm{renorm}, \\mathrm{boltz}\\}$:\n   - $\\mu = \\mathrm{none}$: $F = 1$ (无布居数调整)。\n   - $\\mu = \\mathrm{renorm}$: $F = 0$ (消除下一步的向上尝试，模拟从目标态进行的完全瞬时重整化)。\n   - $\\mu = \\mathrm{boltz}$: $F = \\exp(-\\Delta E / T)$ (对下一步的向上尝试进行玻尔兹曼重加权)。\n\n在这里，$T$ 是无量纲温度，初始速度从一维麦克斯韦-玻尔兹曼分布 $v \\sim \\mathcal{N}(0, \\sigma^2)$ 中独立采样，其方差为 $\\sigma^2 = T/m$。为清楚起见：布居数调整因子 $F$ 仅在发生受阻跳跃后的单个时间步内应用于 $P_{1\\to 2}^{\\mathrm{att}}(v)$。在该步之后，除非发生另一次受阻跳跃，否则该因子将重置为 $1$。\n\n为评估对细致平衡 (Detailed Balance, DB) 的影响，定义经验跳跃比率\n$$\nR = \\frac{N_{1\\to 2}^{\\mathrm{acc}}}{N_{2\\to 1}^{\\mathrm{acc}}},\n$$\n其中 $N_{1\\to 2}^{\\mathrm{acc}}$ 和 $N_{2\\to 1}^{\\mathrm{acc}}$ 是在丢弃前 $f_{\\mathrm{burn}}$ 比例的时间步作为平衡期后，收集到的已接受的向上和向下跳跃的计数。在温度 $T$ 下，两个恒定能量能面的典型细致平衡比率目标是\n$$\nR_{\\mathrm{B}} = \\exp\\left(-\\frac{\\Delta E}{T}\\right).\n$$\n将细致平衡偏差度量定义为绝对差\n$$\nD = \\left| R - R_{\\mathrm{B}} \\right|.\n$$\n\n实现一个程序，对于下面指定的每个测试用例，使用给定的参数和固定的随机种子模拟上述过程，并以浮点数形式输出细致平衡偏差 $D$。使用 $N$ 个独立粒子，其初始能面从 $\\{1,2\\}$ 中均匀抽取，速度如前述独立采样。演化 $M$ 个离散时间步，从跳跃计数中丢弃前 $\\lfloor f_{\\mathrm{burn}} M \\rfloor$ 步。在给定固定随机种子的情况下，算法必须是完全确定性的。最终输出必须是单行，包含所有测试用例的 $D$ 值列表，格式为由方括号括起来的逗号分隔列表。\n\n测试套件。使用以下参数集，以无量纲单位表示：\n- 用例 A (理想情况，无反转，无调整): $m=1$, $\\Delta E = 0.5$, $T = 1$, $\\alpha = 0.5$, $p_0 = 0.1$, $r=0$, $\\mu=\\mathrm{none}$, $N=4096$, $M=4096$, $f_{\\mathrm{burn}}=0.2$。\n- 用例 B (启用反转): $m=1$, $\\Delta E = 0.5$, $T = 1$, $\\alpha = 0.5$, $p_0 = 0.1$, $r=1$, $\\mu=\\mathrm{none}$, $N=4096$, $M=4096$, $f_{\\mathrm{burn}}=0.2$。\n- 用例 C (玻尔兹曼布居数调整，无反转): $m=1$, $\\Delta E = 0.5$, $T = 1$, $\\alpha = 0.5$, $p_0 = 0.1$, $r=0$, $\\mu=\\mathrm{boltz}$, $N=4096$, $M=4096$, $f_{\\mathrm{burn}}=0.2$。\n- 用例 D (大能隙，反转和重整化): $m=1$, $\\Delta E = 2.0$, $T = 1$, $\\alpha = 0.5$, $p_0 = 0.1$, $r=1$, $\\mu=\\mathrm{renorm}$, $N=4096$, $M=4096$, $f_{\\mathrm{burn}}=0.2$。\n- 用例 E (低温，玻尔兹曼调整): $m=1$, $\\Delta E = 0.2$, $T = 0.2$, $\\alpha = 0.5$, $p_0 = 0.1$, $r=0$, $\\mu=\\mathrm{boltz}$, $N=4096$, $M=4096$, $f_{\\mathrm{burn}}=0.2$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔的结果列表（例如，`[result1,result2,result3]`）。每个结果都应是对应测试用例的 $D$ 值，以浮点数表示。",
            "solution": "该问题要求基于一个简化的一维双面非绝热分子动力学模型来实现一个模拟。其目标是评估不同“受阻跳跃”处理方法对系统满足细致平衡原理能力的影响。\n\n该模拟的设计基于统计力学和计算物理学的几个核心原理，这些原理被转化为一个向量化的数值算法。\n\n首先，系统被建模为由 $N$ 个独立的、无相互作用的经典粒子组成的正则系综。这种方法利用统计平均从微观动力学中获得宏观可观测量。系综的初始状态被设置为与给定温度 $T$ 下的热平衡状态一致。具体来说，初始速度 $v$ 从麦克斯韦-玻尔兹曼分布中采样，在一维情况下，该分布形式为方差 $\\sigma^2 = k_{\\mathrm{B}} T/m$ 的正态分布 $\\mathcal{N}(0, \\sigma^2)$。由于玻尔兹曼常数设为 $k_{\\mathrm{B}}=1$，这简化为 $\\sigma^2 = T/m$。每个粒子的初始电子态从两个可用能面 $\\{1, 2\\}$ 中均匀选取，代表一个无偏的初始布居。\n\n其次，动力学遵循最小切换表面跳跃 (Fewest Switches Surface Hopping, FSSH) 方法论。在这种混合量子-经典方案中，每个粒子在任何给定时间都在单个绝热势能面上进行经典演化。能面之间的非绝热跃迁被处理为瞬时的、随机的“跳跃”。尝试跳跃的概率是核速度 $v$ 和耦合系数 $\\alpha$ 的函数，该模型描述了由核运动介导的电子态之间的相互作用强度。给定的向上跳跃概率 $P_{1\\to 2}^{\\mathrm{att}}(v) = \\min(1, p_0 \\max(0, \\alpha v))$ 和向下跳跃概率 $P_{2\\to 1}^{\\mathrm{att}}(v) = \\min(1, p_0 \\max(0, \\alpha(-v)))$ 捕捉了物理本质，即沿非绝热耦合矢量方向的运动会促进跳跃。使用 $\\max(0, \\dots)$ 确保只有当速度分量方向正确时（例如，如果该方向的耦合为正，则向上跳跃需要 $v0$）才会尝试跳跃。\n\n第三，在跳跃过程中严格执行总能量守恒原理。从较低能面 $1$ 跳跃到较高能面 $2$ 需要 $\\Delta E$ 的能量输入。这仅在粒子的动能 $K = \\frac{1}{2}mv^2$ 足够大，即 $K \\ge \\Delta E$ 时才可能发生。如果尝试的跳跃在能量上是允许的，速度将被重标定为 $v' = \\mathrm{sgn}(v)\\,\\sqrt{v^2 - \\frac{2\\Delta E}{m}}$ 以确保总能量守恒。因子 $\\mathrm{sgn}(v)$ 保持运动方向。相反，向下跳跃 ($2 \\to 1$) 会释放能量 $\\Delta E$，该能量转化为动能，因此在能量上总是允许的。速度被重标定为 $v' = \\mathrm{sgn}(v)\\,\\sqrt{v^2 + \\frac{2\\Delta E}{m}}$。\n\n一次能量上被禁止的 ($K  \\Delta E$) 向上跳跃尝试被称为“受阻跳跃”。这些事件是标准 FSSH 算法中的一个已知缺陷，会导致对细致平衡的违背。问题指定了两种需要测试的修正方案。第一种是速度反转（如果标志 $r=1$ 激活，则 $v \\leftarrow -v$），这是一种旨在使粒子从强耦合区域“重新散射”的临时性修复。第二种是布居数调整，即在接下来的一个时间步内，将尝试概率 $P_{1\\to 2}^{\\mathrm{att}}$ 乘以一个因子 $F$。模式 $\\mu \\in \\{\\mathrm{none}, \\mathrm{renorm}, \\mathrm{boltz}\\}$ 分别对应于因子 $F=1$（无修正）、$F=0$（抑制下一次尝试）和 $F = \\exp(-\\Delta E / T)$（通过玻尔兹曼因子重加权）。\n\n用于验证的主要可观测量是经验跳跃比率 $R = N_{1\\to 2}^{\\mathrm{acc}} / N_{2\\to 1}^{\\mathrm{acc}}$，其中 $N^{\\mathrm{acc}}$ 是在经过 $\\lfloor f_{\\mathrm{burn}} M \\rfloor$ 个时间步的平衡期后，整个系综中已接受的跳跃总数。平衡期使系统能够达到一个统计稳态，该状态与具体的初始条件无关。对于处于热平衡的系统，细致平衡要求该比率等于典型玻尔兹曼比率 $R_{\\mathrm{B}} = \\exp(-\\Delta E/T)$。每种受阻跳跃方案的性能由偏差 $D = |R - R_{\\mathrm{B}}|$ 来量化。\n\n算法实现利用 NumPy 的向量化能力来提高效率。所有 $N$ 个粒子的状态（它们的能面、速度以及任何与状态相关的调整因子）都存储在数组中。模拟以离散时间步进行。在每个步骤中，使用逻辑掩码来识别粒子的子集（例如，处于能面 1 上的粒子、尝试跳跃的粒子、跳跃受阻的粒子）。这允许将条件逻辑和状态更新同时应用于整个系综，从而避免了对粒子进行显式循环。在过程开始时使用固定的随机种子，以确保模拟中的随机元素（初始条件、跳跃决策）是可复现的，从而为每个测试用例产生确定性的最终输出。布居数调整因子 $F$ 在受阻跳跃后的一个时间步内有效，通过维护一个针对每个粒子的因子数组 `F_adj` 来管理。在每个时间步 `t`，为步骤 `t+1` 准备一个新的数组 `F_adj_next`，该数组初始化为全 1，然后对在步骤 `t` 期间经历受阻跳跃的任何粒子进行修改。这正确地实现了所描述的单步“记忆”效应。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Per problem statement: \"use a fixed random seed\".\n    # This ensures the entire sequence of random numbers used across all \n    # test cases is deterministic. The seed is set once for the entire suite.\n    np.random.seed(0)\n\n    test_cases = [\n        # Case A: happy path, no reversal, no adjustment\n        {'m': 1.0, 'dE': 0.5, 'T': 1.0, 'alpha': 0.5, 'p0': 0.1, 'r': 0, 'mu': 'none', 'N': 4096, 'M': 4096, 'f_burn': 0.2, 'case_id':'A'},\n        # Case B: reversal enabled\n        {'m': 1.0, 'dE': 0.5, 'T': 1.0, 'alpha': 0.5, 'p0': 0.1, 'r': 1, 'mu': 'none', 'N': 4096, 'M': 4096, 'f_burn': 0.2, 'case_id':'B'},\n        # Case C: Boltzmann population adjustment, no reversal\n        {'m': 1.0, 'dE': 0.5, 'T': 1.0, 'alpha': 0.5, 'p0': 0.1, 'r': 0, 'mu': 'boltz', 'N': 4096, 'M': 4096, 'f_burn': 0.2, 'case_id':'C'},\n        # Case D: large gap, reversal and renormalization\n        {'m': 1.0, 'dE': 2.0, 'T': 1.0, 'alpha': 0.5, 'p0': 0.1, 'r': 1, 'mu': 'renorm', 'N': 4096, 'M': 4096, 'f_burn': 0.2, 'case_id':'D'},\n        # Case E: low temperature, Boltzmann adjustment\n        {'m': 1.0, 'dE': 0.2, 'T': 0.2, 'alpha': 0.5, 'p0': 0.1, 'r': 0, 'mu': 'boltz', 'N': 4096, 'M': 4096, 'f_burn': 0.2, 'case_id':'E'},\n    ]\n\n    results = []\n    for params in test_cases:\n        # We pop 'case_id' as it's not a parameter for the simulation function.\n        case_id = params.pop('case_id')\n        D = simulate(**params)\n        results.append(D)\n        # Restore for potential debugging/display\n        params['case_id'] = case_id\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef simulate(m, dE, T, alpha, p0, r, mu, N, M, f_burn):\n    \"\"\"\n    Simulates the nonadiabatic molecular dynamics for a given set of parameters.\n    \"\"\"\n    # Calculate derived parameters\n    sigma_v = np.sqrt(T / m)\n    burn_in_steps = int(f_burn * M)\n\n    # Determine population adjustment factor F based on mode mu\n    if mu == 'none':\n        F = 1.0\n    elif mu == 'renorm':\n        F = 0.0\n    elif mu == 'boltz':\n        F = np.exp(-dE / T)\n    else:\n        # This case should not be reached with the given test suite.\n        raise ValueError(f\"Invalid population adjustment mode: {mu}\")\n\n    # --- Initialization ---\n    # Surfaces: 1 for lower, 2 for upper\n    surfaces = np.random.randint(1, 3, size=N)\n    # Velocities from Maxwell-Boltzmann distribution\n    velocities = np.random.normal(loc=0.0, scale=sigma_v, size=N)\n    \n    # F_adj stores the population adjustment factor for each particle for the current step\n    F_adj = np.ones(N, dtype=np.float64)\n\n    # Hop counters (accumulated after burn-in)\n    N_12_acc = 0\n    N_21_acc = 0\n\n    # --- Main Simulation Loop ---\n    for t in range(M):\n        # Array for next step's adjustment factors, initialized to 1 (no adjustment)\n        F_adj_next = np.ones(N, dtype=np.float64)\n\n        # --- Handle hops from surface 1 to 2 (upward) ---\n        idx_s1 = np.where(surfaces == 1)[0]\n        if idx_s1.size > 0:\n            v_s1 = velocities[idx_s1]\n            \n            p_up_base = p0 * np.maximum(0, alpha * v_s1)\n            p_up_att = np.minimum(1.0, F_adj[idx_s1] * p_up_base)\n\n            rand_s1 = np.random.rand(idx_s1.size)\n            attempt_up_indices = idx_s1[rand_s1  p_up_att]\n\n            if attempt_up_indices.size > 0:\n                v_attempt_up = velocities[attempt_up_indices]\n                K_attempt_up = 0.5 * m * v_attempt_up**2\n                \n                allowed_mask = K_attempt_up >= dE\n                \n                # Process accepted hops\n                accepted_up_indices = attempt_up_indices[allowed_mask]\n                if accepted_up_indices.size > 0:\n                    if t >= burn_in_steps:\n                        N_12_acc += accepted_up_indices.size\n                    \n                    v_old = velocities[accepted_up_indices]\n                    velocities[accepted_up_indices] = np.sign(v_old) * np.sqrt(v_old**2 - (2 * dE / m))\n                    surfaces[accepted_up_indices] = 2\n\n                # Process frustrated hops\n                frustrated_hop_indices = attempt_up_indices[~allowed_mask]\n                if frustrated_hop_indices.size > 0:\n                    if r == 1:\n                        velocities[frustrated_hop_indices] *= -1\n                    if mu != 'none':\n                        F_adj_next[frustrated_hop_indices] = F\n\n        # --- Handle hops from surface 2 to 1 (downward) ---\n        idx_s2 = np.where(surfaces == 2)[0]\n        if idx_s2.size > 0:\n            v_s2 = velocities[idx_s2]\n            p_down_att = np.minimum(1.0, p0 * np.maximum(0, alpha * -v_s2))\n\n            rand_s2 = np.random.rand(idx_s2.size)\n            accepted_down_indices = idx_s2[rand_s2  p_down_att]\n\n            if accepted_down_indices.size > 0:\n                if t >= burn_in_steps:\n                    N_21_acc += accepted_down_indices.size\n                \n                v_old = velocities[accepted_down_indices]\n                velocities[accepted_down_indices] = np.sign(v_old) * np.sqrt(v_old**2 + (2 * dE / m))\n                surfaces[accepted_down_indices] = 1\n        \n        # Prepare adjustment factor for the next time step\n        F_adj = F_adj_next\n\n    # --- Calculate Final Observables ---\n    R_B = np.exp(-dE / T)\n    \n    if N_21_acc == 0:\n        if N_12_acc == 0:\n            R = 0.0 # Define 0/0 as 0\n        else:\n            # Handle division by zero: R is effectively infinite\n            R = np.finfo(np.float64).max\n    else:\n        R = N_12_acc / N_21_acc\n\n    D = np.abs(R - R_B)\n    return D\n\n# Execute the simulation and print the final result.\nsolve()\n```"
        }
    ]
}