{
    "hands_on_practices": [
        {
            "introduction": "Understanding the kinetics of point defects fundamentally begins with the elementary atomic hop. The energy barrier an atom must overcome to move from one lattice site to another, known as the migration barrier, is a critical parameter governing diffusion rates. This exercise guides you through the implementation of the Nudged Elastic Band (NEB) method , a cornerstone computational technique used to find the minimum energy path and its associated energy barrier for such atomic transitions.",
            "id": "3833685",
            "problem": "A single migrating atom in a crystalline host can be modeled as a point moving in two spatial dimensions under the influence of fixed lattice sites and an obstacle. The total potential energy is defined as the sum of two attractive Morse potentials centered at two lattice sites and one short-range repulsive exponential potential centered at an obstacle. Let the atom position be $\\mathbf{R} = (x,y)$ in a plane, the left lattice site be at $\\mathbf{R}_{\\mathrm{L}} = (-a,0)$, the right lattice site be at $\\mathbf{R}_{\\mathrm{R}} = (a,0)$, and the central obstacle be at $\\mathbf{R}_{\\mathrm{O}} = (0,0)$. The total potential energy is\n$$\nE(\\mathbf{R}) = V_{\\mathrm{Morse}}(|\\mathbf{R} - \\mathbf{R}_{\\mathrm{L}}|) + V_{\\mathrm{Morse}}(|\\mathbf{R} - \\mathbf{R}_{\\mathrm{R}}|) + V_{\\mathrm{rep}}(|\\mathbf{R} - \\mathbf{R}_{\\mathrm{O}}|),\n$$\nwhere the Morse attraction is\n$$\nV_{\\mathrm{Morse}}(r) = D_e \\left(\\left(1 - e^{-\\alpha (r - r_0)}\\right)^2 - 1\\right),\n$$\nand the repulsive obstacle is\n$$\nV_{\\mathrm{rep}}(r) = A e^{-\\beta r}.\n$$\nAll distances are to be treated in angstroms, denoted $\\mathrm{\\AA}$, and all energies in electronvolts, denoted $\\mathrm{eV}$.\n\nYou must implement the Nudged Elastic Band (NEB) method to compute the migration barrier for the atom moving from an initial minimum near the left site to a final minimum near the right site. Use the following physically motivated setup:\n- The initial atom position is $\\mathbf{R}_{\\mathrm{start}} = (-a + r_0, 0)$ and the final atom position is $\\mathbf{R}_{\\mathrm{end}} = (a - r_0, 0)$, approximating local minima at a distance $r_0$ from each lattice site along the line connecting them.\n- Construct an initial path of $N$ images by linear interpolation in Cartesian coordinates between $\\mathbf{R}_{\\mathrm{start}}$ and $\\mathbf{R}_{\\mathrm{end}}$. The endpoints are fixed throughout optimization.\n- The NEB force on an interior image $i$ combines the true force perpendicular to the local path tangent and a spring force along the tangent. Let $\\mathbf{F}_i^{\\mathrm{true}} = -\\nabla E(\\mathbf{R}_i)$ be the true force at image $i$, and let the tangent $\\boldsymbol{\\tau}_i$ be defined by an energy-weighted scheme using adjacent images $i-1$ and $i+1$:\n  - Define $\\Delta \\mathbf{R}_i^+ = \\mathbf{R}_{i+1} - \\mathbf{R}_i$, $\\Delta \\mathbf{R}_i^- = \\mathbf{R}_i - \\mathbf{R}_{i-1}$, $E_{i-1} = E(\\mathbf{R}_{i-1})$, $E_i = E(\\mathbf{R}_i)$, $E_{i+1} = E(\\mathbf{R}_{i+1})$.\n  - If $E_{i+1}  E_i  E_{i-1}$, set $\\boldsymbol{\\tau}_i$ to the unit vector along $\\Delta \\mathbf{R}_i^+$.\n  - If $E_{i+1}  E_i  E_{i-1}$, set $\\boldsymbol{\\tau}_i$ to the unit vector along $\\Delta \\mathbf{R}_i^-$.\n  - Otherwise, set $\\boldsymbol{\\tau}_i \\propto \\max(E_{i+1} - E_i, 0)\\,\\Delta \\mathbf{R}_i^+ + \\max(E_{i-1} - E_i, 0)\\,\\Delta \\mathbf{R}_i^-$ and normalize to unit length. If the resulting vector is zero, use $\\Delta \\mathbf{R}_i^+ + \\Delta \\mathbf{R}_i^-$ normalized.\n- The NEB force on non-climbing images is\n$$\n\\mathbf{F}_i^{\\mathrm{NEB}} = \\mathbf{F}_i^{\\perp} + \\mathbf{F}_i^{\\mathrm{spring}},\n$$\nwhere the perpendicular component is $\\mathbf{F}_i^{\\perp} = \\mathbf{F}_i^{\\mathrm{true}} - (\\mathbf{F}_i^{\\mathrm{true}} \\cdot \\boldsymbol{\\tau}_i)\\,\\boldsymbol{\\tau}_i$, and the spring force is $\\mathbf{F}_i^{\\mathrm{spring}} = k_s \\left(\\|\\Delta \\mathbf{R}_i^+\\| - \\|\\Delta \\mathbf{R}_i^-\\|\\right) \\boldsymbol{\\tau}_i$, with $k_s$ a constant spring constant in units of $\\mathrm{eV}/\\mathrm{\\AA}^2$.\n- Apply the climbing image modification by identifying at each iteration the interior image $m$ with the largest energy and replacing its force with\n$$\n\\mathbf{F}_m^{\\mathrm{CI}} = \\mathbf{F}_m^{\\mathrm{true}} - 2\\,(\\mathbf{F}_m^{\\mathrm{true}} \\cdot \\boldsymbol{\\tau}_m)\\,\\boldsymbol{\\tau}_m,\n$$\nremoving any spring contribution for that image.\n\nUse a simple explicit update rule for interior images:\n$$\n\\mathbf{R}_i \\leftarrow \\mathbf{R}_i + \\eta\\,\\mathbf{F}_i,\n$$\nwhere $\\eta$ is a user-specified step size with units $\\mathrm{\\AA}^2/\\mathrm{eV}$, and $\\mathbf{F}_i$ is $\\mathbf{F}_i^{\\mathrm{NEB}}$ for non-climbing images or $\\mathbf{F}_i^{\\mathrm{CI}}$ for the climbing image. The endpoints are fixed and not updated.\n\nConverge the NEB optimization when the maximum magnitude of the NEB force among interior images satisfies $\\max_i \\|\\mathbf{F}_i\\|  \\varepsilon$, where $\\varepsilon$ is a tolerance in units of $\\mathrm{eV}/\\mathrm{\\AA}$, or when a maximum number of iterations is reached. After convergence, compute the migration barrier as\n$$\nE_{\\mathrm{barrier}} = E(\\mathbf{R}_m) - E(\\mathbf{R}_{\\mathrm{start}}),\n$$\nexpressed in $\\mathrm{eV}$, where $\\mathbf{R}_m$ is the converged climbing image coordinate.\n\nYour program must implement the above and produce results for the following test suite, each case specified as a tuple of parameters $(a, D_e, \\alpha, r_0, A, \\beta, N, k_s, \\text{max\\_iter}, \\eta, \\varepsilon)$ with units indicated:\n- Case $1$: $(2.0\\,\\mathrm{\\AA}, 0.2\\,\\mathrm{eV}, 2.0\\,\\mathrm{\\AA}^{-1}, 0.5\\,\\mathrm{\\AA}, 0.5\\,\\mathrm{eV}, 3.0\\,\\mathrm{\\AA}^{-1}, 9, 0.1\\,\\mathrm{eV}/\\mathrm{\\AA}^2, 2000, 0.05\\,\\mathrm{\\AA}^2/\\mathrm{eV}, 10^{-3}\\,\\mathrm{eV}/\\mathrm{\\AA})$.\n- Case $2$: $(2.0\\,\\mathrm{\\AA}, 0.2\\,\\mathrm{eV}, 2.0\\,\\mathrm{\\AA}^{-1}, 0.5\\,\\mathrm{\\AA}, 0.5\\,\\mathrm{eV}, 3.0\\,\\mathrm{\\AA}^{-1}, 3, 0.1\\,\\mathrm{eV}/\\mathrm{\\AA}^2, 3000, 0.02\\,\\mathrm{\\AA}^2/\\mathrm{eV}, 10^{-3}\\,\\mathrm{eV}/\\mathrm{\\AA})$.\n- Case $3$: $(2.0\\,\\mathrm{\\AA}, 0.2\\,\\mathrm{eV}, 2.0\\,\\mathrm{\\AA}^{-1}, 0.5\\,\\mathrm{\\AA}, 0.5\\,\\mathrm{eV}, 3.0\\,\\mathrm{\\AA}^{-1}, 9, 0.02\\,\\mathrm{eV}/\\mathrm{\\AA}^2, 3000, 0.05\\,\\mathrm{\\AA}^2/\\mathrm{eV}, 10^{-3}\\,\\mathrm{eV}/\\mathrm{\\AA})$.\n- Case $4$: $(2.0\\,\\mathrm{\\AA}, 0.2\\,\\mathrm{eV}, 2.0\\,\\mathrm{\\AA}^{-1}, 0.5\\,\\mathrm{\\AA}, 1.0\\,\\mathrm{eV}, 3.0\\,\\mathrm{\\AA}^{-1}, 9, 0.1\\,\\mathrm{eV}/\\mathrm{\\AA}^2, 2000, 0.05\\,\\mathrm{\\AA}^2/\\mathrm{eV}, 10^{-3}\\,\\mathrm{eV}/\\mathrm{\\AA})$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[x_1, x_2, x_3, x_4]$, where each $x_i$ is the migration barrier $E_{\\mathrm{barrier}}$ in $\\mathrm{eV}$, rounded to six decimal places.",
            "solution": "The problem is subjected to validation and is confirmed to be **valid**. It is scientifically grounded in established principles of computational materials science, mathematically well-posed, objective, and provides a complete and consistent set of parameters and instructions for implementing the Nudged Elastic Band (NEB) method. The potential energy model and the NEB algorithm are standard tools in the field. The provided parameters and units are physically consistent and computationally feasible.\n\nThe solution proceeds by implementing the specified algorithm. The core components of the implementation are the potential energy surface, the NEB optimization loop, and the final barrier calculation.\n\n### 1. Potential Energy Surface and Force Calculation\n\nThe total potential energy $E(\\mathbf{R})$ for an atom at position $\\mathbf{R}=(x,y)$ is the sum of three potentials: two attractive Morse potentials from lattice sites at $\\mathbf{R}_{\\mathrm{L}}=(-a,0)$ and $\\mathbf{R}_{\\mathrm{R}}=(a,0)$, and one repulsive potential from an obstacle at $\\mathbf{R}_{\\mathrm{O}}=(0,0)$.\n\n$$\nE(\\mathbf{R}) = V_{\\mathrm{Morse}}(r_L) + V_{\\mathrm{Morse}}(r_R) + V_{\\mathrm{rep}}(r_O)\n$$\n\nwhere $r_L = |\\mathbf{R} - \\mathbf{R}_{\\mathrm{L}}|$, $r_R = |\\mathbf{R} - \\mathbf{R}_{\\mathrm{R}}|$, and $r_O = |\\mathbf{R} - \\mathbf{R}_{\\mathrm{O}}|$. The Morse potential is $V_{\\mathrm{Morse}}(r) = D_e \\left(\\left(1 - e^{-\\alpha (r - r_0)}\\right)^2 - 1\\right)$ and the repulsive potential is $V_{\\mathrm{rep}}(r) = A e^{-\\beta r}$.\n\nThe \"true\" force on the atom is the negative gradient of the potential energy, $\\mathbf{F}^{\\mathrm{true}} = -\\nabla E(\\mathbf{R})$. Using the chain rule, $\\nabla V(r(\\mathbf{R})) = \\frac{dV}{dr} \\nabla r$, the gradient of the total potential is:\n\n$$\n\\nabla E(\\mathbf{R}) = \\frac{d V_{\\mathrm{Morse}}}{dr}(r_L) \\frac{\\mathbf{R} - \\mathbf{R}_{\\mathrm{L}}}{r_L} + \\frac{d V_{\\mathrm{Morse}}}{dr}(r_R) \\frac{\\mathbf{R} - \\mathbf{R}_{\\mathrm{R}}}{r_R} + \\frac{d V_{\\mathrm{rep}}}{dr}(r_O) \\frac{\\mathbf{R} - \\mathbf{R}_{\\mathrm{O}}}{r_O}\n$$\n\nThe required derivatives of the potential functions are:\n$$\n\\frac{d V_{\\mathrm{Morse}}}{dr} = 2\\alpha D_e \\left(e^{-\\alpha (r - r_0)} - e^{-2\\alpha (r - r_0)}\\right)\n$$\n$$\n\\frac{d V_{\\mathrm{rep}}}{dr} = -\\beta A e^{-\\beta r}\n$$\n\nThese expressions allow for the analytical computation of the energy and force at any point $\\mathbf{R}$.\n\n### 2. Nudged Elastic Band (NEB) with Climbing Image\n\nThe NEB method finds the minimum energy path (MEP) between two local minima, $\\mathbf{R}_{\\mathrm{start}}$ and $\\mathbf{R}_{\\mathrm{end}}$. The path is discretized into a series of $N$ images, $\\{\\mathbf{R}_0, \\mathbf{R}_1, \\ldots, \\mathbf{R}_{N-1}\\}$, where $\\mathbf{R}_0 = \\mathbf{R}_{\\mathrm{start}}$ and $\\mathbf{R}_{N-1} = \\mathbf{R}_{\\mathrm{end}}$.\n\n#### Path Initialization\nThe initial path is created by linear interpolation between the start and end points:\n$\\mathbf{R}_{\\mathrm{start}} = (-a + r_0, 0)$ and $\\mathbf{R}_{\\mathrm{end}} = (a - r_0, 0)$.\nFor $i = 0, \\ldots, N-1$, the initial position of image $i$ is:\n$$\n\\mathbf{R}_i = \\mathbf{R}_{\\mathrm{start}} + \\frac{i}{N-1} (\\mathbf{R}_{\\mathrm{end}} - \\mathbf{R}_{\\mathrm{start}})\n$$\n\n#### Iterative Optimization\nThe interior images ($\\mathbf{R}_1, \\ldots, \\mathbf{R}_{N-2}$) are relaxed iteratively towards the MEP. The endpoints $\\mathbf{R}_0$ and $\\mathbf{R}_{N-1}$ remain fixed. At each iteration, a specific NEB force is calculated for each interior image, and its position is updated using an explicit Euler step:\n$$\n\\mathbf{R}_i \\leftarrow \\mathbf{R}_i + \\eta\\,\\mathbf{F}_i \\quad \\text{for } i=1, \\ldots, N-2\n$$\nwhere $\\eta$ is the step size and $\\mathbf{F}_i$ is the calculated NEB force.\n\n#### Tangent and Force Calculation\nThe force on each interior image $i$ depends on the local path tangent $\\boldsymbol{\\tau}_i$. The tangent is defined using an energy-weighted scheme to ensure it points \"uphill\" from the current image. Let $\\Delta \\mathbf{R}_i^+ = \\mathbf{R}_{i+1} - \\mathbf{R}_i$ and $\\Delta \\mathbf{R}_i^- = \\mathbf{R}_i - \\mathbf{R}_{i-1}$. The tangent vector $\\boldsymbol{\\tau}_i$ is determined by the relative energies of adjacent images, as specified in the problem statement.\n\nFor most images, the NEB force is a sum of the perpendicular component of the true force and a parallel spring force:\n$$\n\\mathbf{F}_i^{\\mathrm{NEB}} = \\mathbf{F}_i^{\\perp} + \\mathbf{F}_i^{\\mathrm{spring}}\n$$\nwhere:\n- $\\mathbf{F}_i^{\\perp} = \\mathbf{F}_i^{\\mathrm{true}} - (\\mathbf{F}_i^{\\mathrm{true}} \\cdot \\boldsymbol{\\tau}_i)\\,\\boldsymbol{\\tau}_i$ is the component of the true force perpendicular to the path. This component drives the path towards the MEP.\n- $\\mathbf{F}_i^{\\mathrm{spring}} = k_s \\left(\\|\\Delta \\mathbf{R}_i^+\\| - \\|\\Delta \\mathbf{R}_i^-\\|\\right) \\boldsymbol{\\tau}_i$ is a spring force along the tangent that ensures equal spacing of images. $k_s$ is the spring constant.\n\nTo accurately locate the saddle point (the maximum along the MEP), the climbing image (CI) modification is used. At each iteration, the interior image $m$ with the highest potential energy, $E(\\mathbf{R}_m) = \\max_{j=1..N-2} E(\\mathbf{R}_j)$, is identified. The force for this image is modified to push it towards the true saddle point:\n$$\n\\mathbf{F}_m^{\\mathrm{CI}} = \\mathbf{F}_m^{\\mathrm{true}} - 2\\,(\\mathbf{F}_m^{\\mathrm{true}} \\cdot \\boldsymbol{\\tau}_m)\\,\\boldsymbol{\\tau}_m\n$$\nThis force inverts the component of the true force parallel to the path, while still minimizing the perpendicular component, effectively driving the image \"uphill\" along the path to the saddle point.\n\n#### Convergence\nThe iterative process continues until the maximum magnitude of the force on any interior image falls below a threshold $\\varepsilon$, i.e., $\\max_{i=1..N-2} \\|\\mathbf{F}_i\\|  \\varepsilon$, or a maximum number of iterations is reached.\n\n### 3. Migration Barrier Calculation\nAfter the path has converged, the migration energy barrier is the difference between the energy of the saddle point and the energy of the initial state. The saddle point energy is taken as the maximum energy among all images on the converged path.\n$$\nE_{\\mathrm{barrier}} = \\left( \\max_{i=0..N-1} E(\\mathbf{R}_i) \\right) - E(\\mathbf{R}_{\\mathrm{start}})\n$$\nThis value gives the minimum energy required for the atom to migrate from the initial to the final lattice site.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that sets up and runs the NEB calculations for all test cases.\n    \"\"\"\n\n    # Helper function to normalize a vector, handling the zero-norm case.\n    def normalize(v):\n        norm = np.linalg.norm(v)\n        if norm  1e-12:  # A small tolerance to avoid division by zero\n            return np.zeros_like(v)\n        return v / norm\n\n    # Potential energy functions\n    def V_morse(r, De, alpha, r0):\n        return De * ((1 - np.exp(-alpha * (r - r0)))**2 - 1)\n\n    def V_rep(r, A, beta):\n        return A * np.exp(-beta * r)\n\n    # Derivatives of potentials w.r.t. distance r\n    def dV_morse_dr(r, De, alpha, r0):\n        exp1 = np.exp(-alpha * (r - r0))\n        # To avoid overflow with large negative r-r0, we can cap the exponent\n        # but with current parameters it is not an issue.\n        exp2 = np.exp(-2 * alpha * (r - r0))\n        return 2 * alpha * De * (exp1 - exp2)\n\n    def dV_rep_dr(r, A, beta):\n        return -beta * A * np.exp(-beta * r)\n\n    # Total potential energy function\n    def total_potential(R, a, De, alpha, r0, A, beta):\n        R_L = np.array([-a, 0.0])\n        R_R = np.array([a, 0.0])\n        R_O = np.array([0.0, 0.0])\n        \n        r_L = np.linalg.norm(R - R_L)\n        r_R = np.linalg.norm(R - R_R)\n        r_O = np.linalg.norm(R - R_O)\n        \n        E = V_morse(r_L, De, alpha, r0) + \\\n            V_morse(r_R, De, alpha, r0) + \\\n            V_rep(r_O, A, beta)\n        return E\n\n    # True force function (-gradient of potential)\n    def true_force(R, a, De, alpha, r0, A, beta):\n        R_L = np.array([-a, 0.0])\n        R_R = np.array([a, 0.0])\n        R_O = np.array([0.0, 0.0])\n\n        r_L = np.linalg.norm(R - R_L)\n        r_R = np.linalg.norm(R - R_R)\n        r_O = np.linalg.norm(R - R_O)\n        \n        # Add a small epsilon to distance to avoid division by zero in gradient calculation\n        # if R coincides with a center (r=0).\n        eps = 1e-12\n        \n        grad_r_L = (R - R_L) / (r_L + eps)\n        grad_r_R = (R - R_R) / (r_R + eps)\n        grad_r_O = (R - R_O) / (r_O + eps)\n\n        grad_E = dV_morse_dr(r_L, De, alpha, r0) * grad_r_L + \\\n                 dV_morse_dr(r_R, De, alpha, r0) * grad_r_R + \\\n                 dV_rep_dr(r_O, A, beta) * grad_r_O\n                 \n        return -grad_E\n\n    def solve_case(params):\n        \"\"\"\n        Executes the CI-NEB algorithm for a single set of parameters.\n        \"\"\"\n        a, De, alpha, r0, A, beta, N, ks, max_iter, eta, epsilon = params\n        \n        # 1. Initialize path by linear interpolation\n        R_start = np.array([-a + r0, 0.0])\n        R_end = np.array([a - r0, 0.0])\n        \n        path = np.zeros((N, 2))\n        path[0] = R_start\n        path[-1] = R_end\n        if N  1:\n            for i in range(1, N - 1):\n                path[i] = R_start + i * (R_end - R_start) / (N - 1)\n\n        # Encapsulate potential parameters for easy passing\n        potential_params = (a, De, alpha, r0, A, beta)\n        \n        # 2. Main NEB optimization loop\n        for _ in range(max_iter):\n            # Calculate energies of all images on the current path\n            energies = np.array([total_potential(R, *potential_params) for R in path])\n            \n            # There are no interior images to optimize if N  3\n            if N  3:\n                break\n            \n            # Calculate true forces on interior images (indices 1 to N-2)\n            forces_true = np.array([true_force(path[i], *potential_params) for i in range(1, N - 1)])\n            \n            # Identify the climbing image (image with the highest energy)\n            interior_energies = energies[1:-1]\n            climbing_image_idx = np.argmax(interior_energies) + 1\n            \n            neb_forces = np.zeros_like(forces_true)\n            \n            # Loop over interior images (from path index 1 to N-2)\n            for i in range(1, N - 1):\n                # Get energies and positions of adjacent images\n                E_prev, E_curr, E_next = energies[i-1], energies[i], energies[i+1]\n                R_prev, R_curr, R_next = path[i-1], path[i], path[i+1]\n                \n                dR_plus = R_next - R_curr\n                dR_minus = R_curr - R_prev\n                \n                # Tangent calculation based on the problem's energy-weighted scheme\n                if E_next  E_curr and E_curr  E_prev:\n                    tangent_vec = dR_plus\n                elif E_next  E_curr and E_curr  E_prev:\n                    tangent_vec = dR_minus\n                else:\n                    dE_plus = E_next - E_curr\n                    dE_minus = E_prev - E_curr\n                    tangent_vec = max(0, dE_plus) * dR_plus + max(0, dE_minus) * dR_minus\n                    if np.linalg.norm(tangent_vec)  1e-12:\n                        tangent_vec = dR_plus + dR_minus\n                \n                tau = normalize(tangent_vec)\n                \n                # Retrieve the true force for the current image (i)\n                # Note: forces_true is indexed from 0, so image i corresponds to index i-1\n                F_true_i = forces_true[i-1]\n\n                # Calculate the final force (CI or regular NEB)\n                if i == climbing_image_idx:\n                    # Climbing image force: invert force component parallel to the tangent\n                    force = F_true_i - 2 * np.dot(F_true_i, tau) * tau\n                else:\n                    # Regular NEB force\n                    F_perp = F_true_i - np.dot(F_true_i, tau) * tau\n                    F_spring = ks * (np.linalg.norm(dR_plus) - np.linalg.norm(dR_minus)) * tau\n                    force = F_perp + F_spring\n                \n                neb_forces[i-1] = force\n                \n            # Check for convergence\n            max_force_mag = np.max(np.linalg.norm(neb_forces, axis=1))\n            if max_force_mag  epsilon:\n                break\n                \n            # Update interior image positions using explicit Euler\n            path[1:-1] += eta * neb_forces\n\n        # 3. Calculate migration barrier from the converged path\n        final_energies = np.array([total_potential(R, *potential_params) for R in path])\n        \n        # Saddle point energy is the maximum a-long the path\n        E_saddle = np.max(final_energies)\n        E_start = final_energies[0]\n        E_barrier = E_saddle - E_start\n        \n        return round(E_barrier, 6)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, De, alpha, r0, A, beta, N, ks, max_iter, eta, epsilon)\n        (2.0, 0.2, 2.0, 0.5, 0.5, 3.0, 9, 0.1, 2000, 0.05, 1e-3),\n        (2.0, 0.2, 2.0, 0.5, 0.5, 3.0, 3, 0.1, 3000, 0.02, 1e-3),\n        (2.0, 0.2, 2.0, 0.5, 0.5, 3.0, 9, 0.02, 3000, 0.05, 1e-3),\n        (2.0, 0.2, 2.0, 0.5, 1.0, 3.0, 9, 0.1, 2000, 0.05, 1e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With the knowledge of energy barriers for individual hops, we can move to a larger scale and simulate the long-time diffusive behavior of defects. This practice introduces the Kinetic Monte Carlo (KMC) method, a powerful simulation technique that bridges the gap between the timescale of single atomic vibrations and the macroscopic timescale of diffusion. You will construct a KMC model  to simulate a defect's random walk and compute the tracer diffusion coefficient, directly connecting microscopic hop rates to a macroscopic transport property.",
            "id": "2784754",
            "problem": "You are asked to build a complete, runnable program that parameterizes a Kinetic Monte Carlo (KMC) model for point defect diffusion in a crystalline solid using Density Functional Theory (DFT)-derived energy barriers and attempt frequencies, and validates the predicted diffusivities against an Arrhenius-form experimental dataset. The physical setting is a point defect (either a vacancy or an interstitial) performing thermally activated nearest-neighbor hops on a simple cubic lattice. The derivation and implementation must start from fundamental principles that are standard for nanomechanics and surface and interface science.\n\nAssume the following foundational base:\n- Under harmonic Transition State Theory (hTST), the transition rate for a single activated hop is given by $k = \\nu \\exp\\!\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right)$, where $k$ is the rate in $\\mathrm{s}^{-1}$, $\\nu$ is the attempt frequency in $\\mathrm{s}^{-1}$, $E_\\mathrm{a}$ is the activation energy in electron volts (eV), $k_\\mathrm{B}$ is the Boltzmann constant, and $T$ is the absolute temperature in $\\mathrm{K}$. Use $k_\\mathrm{B} = 8.617\\,333\\,262\\,145\\times 10^{-5}\\ \\mathrm{eV/K}$.\n- A simple cubic lattice has $z = 6$ equivalent nearest neighbors, separated by the lattice parameter $a$ (the jump length) expressed in meters.\n- Kinetic Monte Carlo with the residence-time algorithm advances time by random increments drawn from an exponential distribution with mean $1/R_\\mathrm{tot}$, where $R_\\mathrm{tot}$ is the total rate of leaving the current state. For $z$ equivalent neighbors, $R_\\mathrm{tot} = z k$. Directional choices among equivalent neighbors are sampled with probabilities proportional to their individual rates.\n\nUsing these bases, you must:\n- Derive a simulation-consistent estimator for the tracer diffusivity $D$ of the point defect in $d = 3$ spatial dimensions, by expressing $D$ in terms of the mean-squared displacement over the total elapsed time, i.e., using the Einstein relation and properties of a continuous-time, nearest-neighbor random walk. Your derivation must proceed from the definitions above and standard random-walk theory, without invoking any pre-tabulated shortcut formulas for the diffusion coefficient.\n- Construct a KMC algorithm that, for a given parameter set $(a, T, E_\\mathrm{a}, \\nu, z)$, performs $n$ hops, accumulates the total physical time advanced by the residence-time algorithm, and samples random jump directions among the $z$ equivalent neighbors to generate the trajectory of the defect in $3$ dimensions. Your algorithm must then compute the tracer diffusivity estimate $D_\\mathrm{KMC}$ in $\\mathrm{m}^2/\\mathrm{s}$ from that trajectory.\n- Validate $D_\\mathrm{KMC}$ against an experimental Arrhenius model $D_\\mathrm{exp}(T) = D_0 \\exp\\!\\left(-\\frac{Q}{k_\\mathrm{B} T}\\right)$ at the same temperature $T$, where $D_0$ and $Q$ are provided for each test case. For the purposes of this problem, the “experimental” parameters are internally consistent with the underlying DFT parameters but are to be treated as given experimental values.\n\nUnits and numerical outputs:\n- All lengths must be in meters, energies in electron volts, temperature in Kelvin, time in seconds, and diffusivity in $\\mathrm{m}^2/\\mathrm{s}$.\n- Your program must output diffusivities in $\\mathrm{m}^2/\\mathrm{s}$.\n- The validation criterion is defined as a boolean pass/fail per test case: a case passes if the absolute relative error $\\left|D_\\mathrm{KMC} - D_\\mathrm{exp}\\right|/D_\\mathrm{exp}$ is less than or equal to a tolerance $\\epsilon$, where $\\epsilon = 0.2$.\n\nTest suite:\nImplement your program to run exactly the following three test cases, each specified by $(a, T, E_\\mathrm{a}, \\nu, z, D_0, Q)$, where $D_0$ and $Q$ parameterize the Arrhenius-form experimental reference $D_\\mathrm{exp}$.\n\n- Case A (vacancy-like, moderate barrier, “happy path”):\n  - $a = 3.0\\times 10^{-10}\\ \\mathrm{m}$,\n  - $T = 900\\ \\mathrm{K}$,\n  - $E_\\mathrm{a} = 0.6\\ \\mathrm{eV}$,\n  - $\\nu = 1.0\\times 10^{13}\\ \\mathrm{s}^{-1}$,\n  - $z = 6$,\n  - $D_0 = a^2 \\nu$,\n  - $Q = E_\\mathrm{a}$.\n- Case B (interstitial-like, low barrier, faster diffusion):\n  - $a = 2.86\\times 10^{-10}\\ \\mathrm{m}$,\n  - $T = 600\\ \\mathrm{K}$,\n  - $E_\\mathrm{a} = 0.2\\ \\mathrm{eV}$,\n  - $\\nu = 5.0\\times 10^{12}\\ \\mathrm{s}^{-1}$,\n  - $z = 6$,\n  - $D_0 = a^2 \\nu$,\n  - $Q = E_\\mathrm{a}$.\n- Case C (edge case, very high barrier, extremely slow diffusion):\n  - $a = 3.0\\times 10^{-10}\\ \\mathrm{m}$,\n  - $T = 300\\ \\mathrm{K}$,\n  - $E_\\mathrm{a} = 2.0\\ \\mathrm{eV}$,\n  - $\\nu = 1.0\\times 10^{13}\\ \\mathrm{s}^{-1}$,\n  - $z = 6$,\n  - $D_0 = a^2 \\nu$,\n  - $Q = E_\\mathrm{a}$.\n\nAlgorithmic constraints and guidance:\n- Use the residence-time algorithm with total rate $R_\\mathrm{tot} = z \\nu \\exp\\!\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right)$ and equal-probability selection among the $z$ directions at each hop.\n- To ensure statistical stability while remaining efficient, you may choose a fixed number of hops $n$ (shared or per-case) large enough that the relative error criterion can be meaningfully tested. Use any scientifically sound method to sample the residence times and the sequence of directions consistent with the above physics.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of length $3$, enclosed in square brackets, where each element is itself a list of length $3$ in the form $[D_\\mathrm{KMC}, D_\\mathrm{exp}, \\mathrm{pass}]$. For example: $[[D_1,D_1^\\ast,\\mathrm{True}],[D_2,D_2^\\ast,\\mathrm{False}],[D_3,D_3^\\ast,\\mathrm{True}]]$.\n- Each $D_\\mathrm{KMC}$ and $D_\\mathrm{exp}$ must be provided in $\\mathrm{m}^2/\\mathrm{s}$. The boolean $\\mathrm{pass}$ must be $\\mathrm{True}$ if $\\left|D_\\mathrm{KMC} - D_\\mathrm{exp}\\right|/D_\\mathrm{exp} \\le \\epsilon$ with $\\epsilon = 0.2$, and $\\mathrm{False}$ otherwise.",
            "solution": "The provided problem statement is subjected to validation.\n\n### Step 1: Extract Givens\n- **Transition Rate**: The rate for a single activated hop follows harmonic Transition State Theory (hTST): $k = \\nu \\exp\\!\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right)$.\n- **Constants**: Boltzmann constant $k_\\mathrm{B} = 8.617\\,333\\,262\\,145\\times 10^{-5}\\ \\mathrm{eV/K}$.\n- **Lattice**: Simple cubic with coordination number $z = 6$. The nearest-neighbor jump length is the lattice parameter, $a$.\n- **KMC Algorithm**: The simulation must use the residence-time algorithm. The time increment $\\Delta t$ is drawn from an exponential distribution with mean $1/R_\\mathrm{tot}$. The total rate of escape is $R_\\mathrm{tot} = z k$.\n- **Diffusivity Definition**: The tracer diffusivity $D$ in $d=3$ dimensions is defined by the Einstein relation, derived from the mean-squared displacement (MSD).\n- **Experimental Reference**: Diffusivity follows an Arrhenius form, $D_\\mathrm{exp}(T) = D_0 \\exp\\!\\left(-\\frac{Q}{k_\\mathrm{B} T}\\right)$.\n- **Validation Criterion**: The simulation result $D_\\mathrm{KMC}$ for a given test case is considered valid if the absolute relative error with respect to $D_\\mathrm{exp}$ is at most $\\epsilon = 0.2$, i.e., $\\left|D_\\mathrm{KMC} - D_\\mathrm{exp}\\right|/D_\\mathrm{exp} \\le 0.2$.\n- **Test Cases**: Three cases are provided, each defined by a set of parameters $(a, T, E_\\mathrm{a}, \\nu, z, D_0, Q)$. For all cases, $z=6$, and the experimental parameters are defined as $D_0 = a^2 \\nu$ and $Q = E_\\mathrm{a}$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is impeccably grounded in the standard principles of statistical mechanics and computational materials science, specifically the theories of thermally activated processes (hTST), stochastic simulation (KMC), and random walks (Einstein relation). These are textbook concepts in the field.\n- **Well-Posedness**: The problem is well-posed. It provides all necessary physical parameters and constants, a clear objective (derive, implement, and validate), and a quantitative, unambiguous criterion for validation. The stochastic nature of the KMC output is acknowledged, and the need for a statistically significant number of simulation steps is implied, which is a standard aspect of such problems, not a flaw.\n- **Objectivity**: The problem is stated in objective, formal language, free of any subjectivity or non-scientific claims.\n- **Internal Consistency**: A critical check for consistency is required. The problem specifies the parameters for the \"experimental\" model $D_\\mathrm{exp}$ in terms of the microscopic simulation parameters. A theoretical derivation must connect the two. As will be shown, the problem is constructed to be perfectly self-consistent, where the theoretical prediction for diffusivity derived from microscopic parameters exactly matches the provided \"experimental\" form.\n\n### Step 3: Verdict and Action\nThe problem is assessed as **valid**. It is a standard, well-defined problem in computational physics that tests fundamental understanding and implementation skills. I will now proceed with the solution.\n\n### Derivation of the Tracer Diffusivity\n\nThe tracer diffusivity $D$ is defined by the Einstein relation in $d=3$ dimensions:\n$$\nD = \\lim_{t\\to\\infty} \\frac{\\langle |\\mathbf{r}(t) - \\mathbf{r}(0)|^2 \\rangle}{2dt} = \\lim_{t\\to\\infty} \\frac{\\langle |\\mathbf{r}(t) - \\mathbf{r}(0)|^2 \\rangle}{6t}\n$$\nHere, $\\langle \\cdot \\rangle$ denotes an ensemble average over many trajectories. Let the defect start at the origin, $\\mathbf{r}(0) = \\mathbf{0}$. After $n$ hops, the position is $\\mathbf{r}_n = \\sum_{i=1}^{n} \\Delta\\mathbf{r}_i$, where $\\Delta\\mathbf{r}_i$ is the displacement vector for the $i$-th hop.\n\nThe mean-squared displacement (MSD) after $n$ hops is:\n$$\n\\langle |\\mathbf{r}_n|^2 \\rangle = \\left\\langle \\left(\\sum_{i=1}^{n} \\Delta\\mathbf{r}_i\\right) \\cdot \\left(\\sum_{j=1}^{n} \\Delta\\mathbf{r}_j\\right) \\right\\rangle = \\sum_{i=1}^{n} \\langle |\\Delta\\mathbf{r}_i|^2 \\rangle + \\sum_{i \\neq j} \\langle \\Delta\\mathbf{r}_i \\cdot \\Delta\\mathbf{r}_j \\rangle\n$$\nFor a random walk on a lattice, successive hops are uncorrelated. On a centrosymmetric lattice like simple cubic, the average displacement of a single hop is zero, and hops in different directions are equally likely, leading to $\\langle \\Delta\\mathbf{r}_i \\cdot \\Delta\\mathbf{r}_j \\rangle = \\langle \\Delta\\mathbf{r}_i \\rangle \\cdot \\langle \\Delta\\mathbf{r}_j \\rangle = 0$ for $i \\neq j$.\nThe jump length is fixed at the nearest-neighbor distance $a$, so $|\\Delta\\mathbf{r}_i|^2 = a^2$ for all $i$. The MSD simplifies to:\n$$\n\\langle |\\mathbf{r}_n|^2 \\rangle = n a^2\n$$\nThe total time elapsed after $n$ hops, $t_n$, is the sum of $n$ individual time increments: $t_n = \\sum_{i=1}^{n} \\Delta t_i$. In the residence-time algorithm, each $\\Delta t_i$ is a random variable drawn from an exponential distribution with rate parameter $R_\\mathrm{tot}$. The expected value of each time step is $\\langle \\Delta t \\rangle = 1/R_\\mathrm{tot}$. By the law of large numbers, for a large number of hops $n$, the total time $t_n$ approximates its expected value:\n$$\nt_n \\approx n \\langle \\Delta t \\rangle = \\frac{n}{R_\\mathrm{tot}}\n$$\nSubstituting the expressions for MSD and total time into the Einstein relation, we obtain the theoretical diffusivity $D_\\mathrm{theory}$:\n$$\nD_\\mathrm{theory} = \\frac{\\langle |\\mathbf{r}_n|^2 \\rangle}{6 t_n} = \\frac{n a^2}{6 (n/R_\\mathrm{tot})} = \\frac{a^2 R_\\mathrm{tot}}{6}\n$$\nThe total rate $R_\\mathrm{tot}$ is the sum of rates for all possible escape paths. For a simple cubic lattice with $z=6$ identical nearest-neighbor sites, $R_\\mathrm{tot} = z k$. Substituting the expression for the hop rate $k$:\n$$\nD_\\mathrm{theory} = \\frac{a^2 (z k)}{6} = \\frac{z a^2}{6} \\nu \\exp\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right)\n$$\nFor the specific case of a simple cubic lattice where $z=6$, this becomes:\n$$\nD_\\mathrm{theory} = \\frac{6 a^2}{6} \\nu \\exp\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right) = a^2 \\nu \\exp\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right)\n$$\nNow, we compare this with the provided experimental form, $D_\\mathrm{exp}(T) = D_0 \\exp\\left(-\\frac{Q}{k_\\mathrm{B} T}\\right)$. The problem states that for all test cases, $D_0 = a^2 \\nu$ and $Q = E_\\mathrm{a}$. Therefore, the analytical form of the experimental data is identical to our derived theoretical diffusivity: $D_\\mathrm{theory} = D_\\mathrm{exp}$.\nThis confirms the internal consistency of the problem. The KMC simulation, being a numerical realization of the theoretical model, should yield a diffusivity $D_\\mathrm{KMC}$ that converges to this analytical value $D_\\mathrm{exp}$ in the limit of a large number of hops. Any deviation will be due to statistical noise inherent in the stochastic simulation.\n\n### Kinetic Monte Carlo Algorithm Design\n\nThe algorithm to be implemented will simulate the trajectory of a single point defect and compute its diffusivity.\n1.  **Initialization**: For each test case, retrieve the parameters $(a, T, E_\\mathrm{a}, \\nu, z)$.\n    - Set the initial position of the defect to the origin, $\\mathbf{r} = [0, 0, 0]$.\n    - Set the total elapsed time to zero, $t_\\mathrm{total} = 0$.\n    - Define the set of $z=6$ possible jump vectors: $\\{(\\pm a, 0, 0), (0, \\pm a, 0), (0, 0, \\pm a)\\}$.\n2.  **Rate Calculation**: Compute the single hop rate $k = \\nu \\exp(-E_\\mathrm{a} / (k_\\mathrm{B} T))$ and the total escape rate $R_\\mathrm{tot} = z k$. The mean residence time is $\\tau = 1/R_\\mathrm{tot}$.\n3.  **Simulation Loop**: Iterate for a fixed, large number of hops, $n_{hops}$. A value of $n_{hops} = 10000$ is chosen. This is large enough to ensure that statistical fluctuations in the final computed diffusivity are small, allowing for a meaningful comparison against the validation tolerance of $\\epsilon=0.2$, while remaining computationally inexpensive.\n    - **Time Advancement**: Draw a random number $u$ from a uniform distribution $U(0, 1)$ and advance the simulation time by $\\Delta t = -\\ln(u) / R_\\mathrm{tot}$. This is equivalent to drawing from an exponential distribution with mean $\\tau$. Update $t_\\mathrm{total} = t_\\mathrm{total} + \\Delta t$.\n    - **Jump Selection**: Since all $z=6$ neighboring sites are equivalent, select one of the six jump vectors with uniform probability $1/6$.\n    - **Position Update**: Add the selected jump vector to the current position $\\mathbf{r}$.\n4.  **Diffusivity Calculation**: After $n_{hops}$ are completed, the final position is $\\mathbf{r}_\\mathrm{final}$ and the total time is $t_\\mathrm{total}$. The KMC-estimated diffusivity is calculated using the endpoint data, consistent with the Einstein relation:\n    $$\n    D_\\mathrm{KMC} = \\frac{|\\mathbf{r}_\\mathrm{final}|^2}{6 t_\\mathrm{total}}\n    $$\n5.  **Validation**: Calculate the \"experimental\" value $D_\\mathrm{exp} = (a^2 \\nu) \\exp(-E_\\mathrm{a} / (k_\\mathrm{B} T))$. Determine if the pass condition $\\left|D_\\mathrm{KMC} - D_\\mathrm{exp}\\right|/D_\\mathrm{exp} \\le 0.2$ is met.\nThis procedure will be implemented for each of the three test cases provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a Kinetic Monte Carlo (KMC) simulation for point defect\n    diffusion, validating the results against an analytical Arrhenius-form model.\n    \"\"\"\n\n    # Boltzmann constant in eV/K\n    k_B = 8.617333262145e-5\n\n    # Number of hops for the KMC simulation.\n    # Chosen to be large enough for statistical convergence.\n    n_hops = 10000\n\n    # Tolerance for validation\n    epsilon = 0.2\n\n    # Test cases as specified in the problem statement.\n    # (a, T, E_a, nu, z, D0_formula, Q_formula)\n    # D0 and Q are given as formulas a^2*nu and E_a, respectively.\n    test_cases = [\n        # Case A: Vacancy-like, moderate barrier\n        {'a': 3.0e-10, 'T': 900.0, 'E_a': 0.6, 'nu': 1.0e13, 'z': 6},\n        # Case B: Interstitial-like, low barrier\n        {'a': 2.86e-10, 'T': 600.0, 'E_a': 0.2, 'nu': 5.0e12, 'z': 6},\n        # Case C: Edge case, very high barrier\n        {'a': 3.0e-10, 'T': 300.0, 'E_a': 2.0, 'nu': 1.0e13, 'z': 6},\n    ]\n\n    results = []\n\n    # Use a fixed seed for reproducibility of the stochastic simulation\n    np.random.seed(42)\n\n    for case in test_cases:\n        a = case['a']\n        T = case['T']\n        E_a = case['E_a']\n        nu = case['nu']\n        z = case['z']\n\n        # --- Theoretical/Experimental Calculation ---\n        # The problem states D0 = a^2 * nu and Q = E_a.\n        # This is consistent with the derivation for a simple cubic lattice (z=6).\n        D_exp = (a**2 * nu) * np.exp(-E_a / (k_B * T))\n\n        # --- KMC Simulation ---\n        # 1. Initialization\n        position = np.zeros(3)\n        total_time = 0.0\n\n        # Define the jump vectors for a simple cubic lattice\n        jump_vectors = a * np.array([\n            [1, 0, 0], [-1, 0, 0],\n            [0, 1, 0], [0, -1, 0],\n            [0, 0, 1], [0, 0, -1]\n        ])\n\n        # 2. Rate Calculation\n        k_hop = nu * np.exp(-E_a / (k_B * T))\n        R_tot = z * k_hop\n        \n        # Mean time step (scale for exponential distribution)\n        # Handle R_tot=0 case to avoid division by zero, though not expected here.\n        tau = 1.0 / R_tot if R_tot  0 else float('inf')\n\n        # 3. Simulation Loop\n        # Advance time by drawing from exponential distribution\n        time_steps = np.random.exponential(scale=tau, size=n_hops)\n        total_time = np.sum(time_steps)\n        \n        # Select jump directions uniformly\n        jump_indices = np.random.randint(0, z, size=n_hops)\n        \n        # Sum up all jump vectors to get the final position\n        # This is more efficient than a Python loop for position updates\n        final_position = np.sum(jump_vectors[jump_indices], axis=0)\n        \n        # 4. Diffusivity Calculation\n        # Mean squared displacement from origin\n        msd = np.dot(final_position, final_position)\n        \n        # Einstein relation in 3D\n        D_kmc = msd / (6.0 * total_time)\n\n        # 5. Validation\n        relative_error = np.abs(D_kmc - D_exp) / D_exp\n        passed = relative_error = epsilon\n\n        results.append([D_kmc, D_exp, passed])\n\n    # Format the final output string to match the specified format `[[d,d_exp,pass],...]`\n    # without any spaces.\n    results_str_parts = []\n    for res in results:\n        # Format each sublist manually to control spacing\n        # res[2] is a bool, str(res[2]) gives 'True'/'False'\n        part = f\"[{res[0]},{res[1]},{res[2]}]\"\n        results_str_parts.append(part)\n    \n    final_output = f\"[{','.join(results_str_parts)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "To complement the computational perspective of KMC, this practice focuses on constructing an analytical model for diffusion. By integrating concepts from thermodynamics and kinetics, you can derive a closed-form expression for the self-diffusion coefficient mediated by vacancies. This exercise  demonstrates how to combine the vacancy formation energy ($E_f$), migration energy ($E_m$), and lattice properties into a single predictive equation, providing a powerful theoretical framework for understanding thermally activated diffusion.",
            "id": "2784728",
            "problem": "A monatomic face-centered cubic crystal undergoes self-diffusion mediated by dilute thermal vacancies. Consider the following experimentally inferred parameters that characterize the thermally activated steps of the process: vacancy formation energy $E_f=1.2\\ \\mathrm{eV}$, vacancy migration energy $E_m=0.7\\ \\mathrm{eV}$, lattice parameter $a=0.36\\ \\mathrm{nm}$, and an atomic attempt frequency $\\nu=10^{13}\\ \\mathrm{s^{-1}}$. The correlation factor for vacancy-mediated tracer diffusion in this lattice is $f=0.78$. Assume that the vacancy concentration is governed by thermal equilibrium with no explicit formation entropy (that is, the formation entropy contribution to the equilibrium concentration is negligible), that jumps are to nearest neighbors only, and that the dilute-vacancy approximation holds so that site occupancies are independent. Take the Boltzmann constant as $k_B=8.617333262\\times 10^{-5}\\ \\mathrm{eV\\,K^{-1}}$.\n\nStarting from the definitions of equilibrium point-defect populations, transition-state theory for activated hopping, and the Einstein random-walk relation for diffusion in three dimensions, derive an expression for the tracer self-diffusion coefficient and evaluate it at temperature $T=1000\\ \\mathrm{K}$. Express your final result in $\\mathrm{m^2\\,s^{-1}}$ and round your answer to $3$ significant figures.",
            "solution": "The problem statement is analyzed and found to be valid. It is a well-posed problem in solid-state physics, grounded in established scientific principles, with sufficient and consistent data for a unique solution. We may proceed with the derivation.\n\nThe tracer self-diffusion coefficient, $D_T$, is derived by combining three fundamental concepts: the equilibrium concentration of point defects, the rate of atomic jumps via transition-state theory, and the random-walk model of diffusion.\n\nFirst, we determine the equilibrium concentration of vacancies, $X_v$. The formation of a vacancy changes the Gibbs free energy of the crystal. The Gibbs free energy of formation is $G_f = E_f - T S_f$, where $E_f$ is the vacancy formation energy and $S_f$ is the vacancy formation entropy. The problem specifies that the formation entropy contribution is negligible, which simplifies the free energy to $G_f \\approx E_f$. The equilibrium fraction of vacant lattice sites, $X_v$, is given by the Boltzmann factor for creating a defect:\n$$X_v = \\exp\\left(-\\frac{G_f}{k_B T}\\right) \\approx \\exp\\left(-\\frac{E_f}{k_B T}\\right)$$\nHere, $k_B$ is the Boltzmann constant and $T$ is the absolute temperature. This expression is valid for a dilute concentration of vacancies, $X_v \\ll 1$, an assumption given in the problem.\n\nSecond, we formulate the rate of atomic jumps. An atom can diffuse only if an adjacent lattice site is vacant. The rate at which a specific atom jumps into a specific neighboring vacancy is given by transition-state theory. This jump rate, $\\omega$, is characterized by an activation energy barrier, the migration energy $E_m$, and an attempt frequency, $\\nu$.\n$$\\omega = \\nu \\exp\\left(-\\frac{E_m}{k_B T}\\right)$$\nThe total jump frequency of a tracer atom, $\\Gamma_T$, is the product of this intrinsic jump rate, $\\omega$, and the probability that a neighboring site is vacant. For a face-centered cubic (FCC) lattice, each atom has $z=12$ nearest neighbors. In the dilute limit, the probability of finding a vacancy at any one of the $z$ neighboring sites is $z X_v$. Therefore, the total jump frequency for a tracer atom is:\n$$\\Gamma_T = z X_v \\omega$$\nSubstituting the expressions for $X_v$ and $\\omega$:\n$$\\Gamma_T = z \\nu \\exp\\left(-\\frac{E_f + E_m}{k_B T}\\right)$$\n\nThird, we use the Einstein relation for diffusion in a three-dimensional crystal lattice. The diffusion coefficient, $D$, is related to the mean squared jump distance, $d^2$, and the jump frequency, $\\Gamma$, by:\n$$D = \\frac{1}{6} \\Gamma d^2$$\nFor tracer diffusion, we must account for the fact that successive jumps of an atom via the vacancy mechanism are not independent. A tracer atom that has just exchanged with a vacancy has a higher-than-random probability of jumping back into the same vacancy. This correlation reduces the net displacement. The effect is quantified by the correlation factor, $f$. The tracer self-diffusion coefficient $D_T$ is thus:\n$$D_T = \\frac{1}{6} f \\Gamma_T d^2$$\n\nFor the FCC lattice, the nearest-neighbor jump distance $d$ is half the diagonal of a face of the conventional cubic cell. This relates $d$ to the lattice parameter $a$ as $d = a/\\sqrt{2}$. Consequently, $d^2 = a^2/2$.\nSubstituting the expressions for $\\Gamma_T$ and $d^2$ into the equation for $D_T$:\n$$D_T = \\frac{1}{6} f \\left( z \\nu \\exp\\left(-\\frac{E_f + E_m}{k_B T}\\right) \\right) \\left( \\frac{a^2}{2} \\right)$$\nWith $z=12$ for the FCC lattice, we simplify the expression:\n$$D_T = \\frac{1}{6} f (12) \\nu \\frac{a^2}{2} \\exp\\left(-\\frac{E_f + E_m}{k_B T}\\right)$$\n$$D_T = f \\nu a^2 \\exp\\left(-\\frac{E_f + E_m}{k_B T}\\right)$$\nThis is the final analytical expression for the tracer self-diffusion coefficient. It is of the Arrhenius form $D_T = D_0 \\exp(-Q/k_B T)$, with a pre-exponential factor $D_0 = f \\nu a^2$ and an activation energy for diffusion $Q = E_f + E_m$.\n\nWe now evaluate this expression numerically using the provided parameters:\n- Correlation factor: $f = 0.78$\n- Attempt frequency: $\\nu = 10^{13} \\ \\mathrm{s^{-1}}$\n- Lattice parameter: $a = 0.36 \\ \\mathrm{nm} = 0.36 \\times 10^{-9} \\ \\mathrm{m}$\n- Vacancy formation energy: $E_f = 1.2 \\ \\mathrm{eV}$\n- Vacancy migration energy: $E_m = 0.7 \\ \\mathrm{eV}$\n- Temperature: $T = 1000 \\ \\mathrm{K}$\n- Boltzmann constant: $k_B = 8.617333262 \\times 10^{-5} \\ \\mathrm{eV\\,K^{-1}}$\n\nFirst, calculate the total activation energy $Q$:\n$$Q = E_f + E_m = 1.2 \\ \\mathrm{eV} + 0.7 \\ \\mathrm{eV} = 1.9 \\ \\mathrm{eV}$$\nNext, calculate the thermal energy $k_B T$:\n$$k_B T = (8.617333262 \\times 10^{-5} \\ \\mathrm{eV\\,K^{-1}}) \\times (1000 \\ \\mathrm{K}) \\approx 0.086173 \\ \\mathrm{eV}$$\nNow, compute the exponential term:\n$$\\frac{Q}{k_B T} = \\frac{1.9 \\ \\mathrm{eV}}{0.086173 \\ \\mathrm{eV}} \\approx 22.048$$\n$$\\exp\\left(-\\frac{Q}{k_B T}\\right) = \\exp(-22.048) \\approx 2.405 \\times 10^{-10}$$\nNext, calculate the pre-exponential factor $D_0$:\n$$D_0 = f \\nu a^2 = (0.78) \\times (10^{13} \\ \\mathrm{s^{-1}}) \\times (0.36 \\times 10^{-9} \\ \\mathrm{m})^2$$\n$$D_0 = (0.78) \\times (10^{13} \\ \\mathrm{s^{-1}}) \\times (1.296 \\times 10^{-19} \\ \\mathrm{m^2})$$\n$$D_0 \\approx 1.011 \\times 10^{-6} \\ \\mathrm{m^2\\,s^{-1}}$$\nFinally, combine these results to find $D_T$:\n$$D_T = D_0 \\exp\\left(-\\frac{Q}{k_B T}\\right) \\approx (1.011 \\times 10^{-6} \\ \\mathrm{m^2\\,s^{-1}}) \\times (2.405 \\times 10^{-10})$$\n$$D_T \\approx 2.431 \\times 10^{-16} \\ \\mathrm{m^2\\,s^{-1}}$$\nRounding the result to $3$ significant figures as requested gives:\n$$D_T = 2.43 \\times 10^{-16} \\ \\mathrm{m^2\\,s^{-1}}$$",
            "answer": "$$\\boxed{2.43 \\times 10^{-16}}$$"
        }
    ]
}