{
    "hands_on_practices": [
        {
            "introduction": "理解材料中点缺陷行为的第一步是确定它们的热力学性质。此练习将指导您如何使用来自第一性原理计算（如密度泛函理论，DFT）的能量数据来预测不同缺陷构型（在此案例中为填隙原子）的相对布居数 。通过这个实践，您将学会如何将原子尺度的电子总能量与宏观的吉布斯自由能和缺陷浓度联系起来，这是多尺度建模的基础。",
            "id": "2784699",
            "problem": "一个单原子面心立方晶体在密度泛函理论（DFT, Density Functional Theory）中使用周期性超胞进行建模。考虑两种中性自填隙构型：四面体填隙和八面体填隙。为体超胞和两种缺陷超胞提供了以下量：\n\n- 含有 $N=250$ 个原子的体超胞：总电子能量 $E_{\\text{bulk}} = -875.000 \\ \\text{eV}$。\n- 在 $T=0 \\ \\text{K}}$ 时的主体原子化学势：$\\mu_{\\text{host}} = E_{\\text{bulk}}/N = -3.500 \\ \\text{eV}$。\n- 四面体填隙超胞（包含 $N+1$ 个原子）：总电子能量 $E_{\\text{tet}} = -875.300 \\ \\text{eV}$。\n- 八面体填隙超胞（包含 $N+1$ 个原子）：总电子能量 $E_{\\text{oct}} = -875.000 \\ \\text{eV}$。\n- 在 $T=800 \\ \\text{K}$ 时的振动形成自由能修正（准谐近似，包含零点能）：\n  - 四面体：$\\Delta F_{\\text{vib}}^{\\text{tet}}(800 \\ \\text{K}) = -0.12 \\ \\text{eV}$。\n  - 八面体：$\\Delta F_{\\text{vib}}^{\\text{oct}}(800 \\ \\text{K}) = -0.20 \\ \\text{eV}$。\n\n假设对于固体，压力-体积贡献可以忽略不计，并且在温度 $T$ 时，构型 $s \\in \\{\\text{tet}, \\text{oct}\\}$ 的形成吉布斯自由能由来自 DFT 电子能量的 $T=0 \\ \\text{K}$ 形成能与在温度 $T$ 时的振动形成自由能修正之和给出，即\n$$\n\\Delta G_f^{s}(T) = \\left[E^{s} - E_{\\text{bulk}} - \\mu_{\\text{host}}\\right] + \\Delta F_{\\text{vib}}^{s}(T).\n$$\n这里 $E^{s}$ 是包含构型为 $s$ 的自填隙的超胞的总能量。\n\n将每种对称性类别的每个可用位点的平衡占有率视为与其形成吉布斯自由能相关的玻尔兹曼因子的比例，并计算在 $T=800 \\ \\text{K}$ 时，四面体与八面体每位点占有率之比。使用玻尔兹曼常数 $k_B = 8.617333262 \\times 10^{-5} \\ \\text{eV} \\, \\text{K}^{-1}$。将你最终的数值比率四舍五入到三位有效数字。将该比率表示为纯数（无单位）。",
            "solution": "我们被要求计算在 $T=800 \\ \\text{K}$ 时，四面体和八面体填隙构型的每位点平衡占有率之比。根据平衡统计力学，当每种构型 $s$ 被视为具有形成吉布斯自由能 $\\Delta G_f^{s}(T)$ 的独立非相互作用激发时，每个可用位点的平衡占有率与玻尔兹曼因子 $\\exp\\!\\left[-\\Delta G_f^{s}(T)/(k_B T)\\right]$ 成正比。因此，每位点占有率之比为\n$$\n\\frac{n_{\\text{tet}}}{n_{\\text{oct}}} = \\frac{\\exp\\!\\left[-\\Delta G_f^{\\text{tet}}(T)/(k_B T)\\right]}{\\exp\\!\\left[-\\Delta G_f^{\\text{oct}}(T)/(k_B T)\\right]} = \\exp\\!\\left[-\\frac{\\Delta G_f^{\\text{tet}}(T) - \\Delta G_f^{\\text{oct}}(T)}{k_B T}\\right].\n$$\n\n因此，我们必须根据提供的 DFT 和振动数据来计算 $\\Delta G_f^{\\text{tet}}(800 \\ \\text{K}) - \\Delta G_f^{\\text{oct}}(800 \\ \\text{K})$。\n\n首先，计算每种构型在 $T=0 \\ \\text{K}$ 时的电子形成能（焓的部分，忽略 $pV$）。对于自填隙，插入了一个额外的主体原子，因此 $T=0 \\ \\text{K}$ 的形成能为\n$$\n\\Delta E_f^{s} = E^{s} - E_{\\text{bulk}} - \\mu_{\\text{host}}.\n$$\n\n- 对于四面体填隙：\n$$\n\\Delta E_f^{\\text{tet}} = E_{\\text{tet}} - E_{\\text{bulk}} - \\mu_{\\text{host}} = \\left(-875.300 \\ \\text{eV}\\right) - \\left(-875.000 \\ \\text{eV}\\right) - \\left(-3.500 \\ \\text{eV}\\right).\n$$\n逐项计算：\n$$\nE_{\\text{tet}} - E_{\\text{bulk}} = -0.300 \\ \\text{eV}, \\quad \\text{and} \\quad -\\mu_{\\text{host}} = +3.500 \\ \\text{eV}.\n$$\n因此，\n$$\n\\Delta E_f^{\\text{tet}} = -0.300 \\ \\text{eV} + 3.500 \\ \\text{eV} = 3.200 \\ \\text{eV}.\n$$\n\n- 对于八面体填隙：\n$$\n\\Delta E_f^{\\text{oct}} = E_{\\text{oct}} - E_{\\text{bulk}} - \\mu_{\\text{host}} = \\left(-875.000 \\ \\text{eV}\\right) - \\left(-875.000 \\ \\text{eV}\\right) - \\left(-3.500 \\ \\text{eV}\\right).\n$$\n计算：\n$$\nE_{\\text{oct}} - E_{\\text{bulk}} = 0.000 \\ \\text{eV}, \\quad \\text{and} \\quad -\\mu_{\\text{host}} = +3.500 \\ \\text{eV},\n$$\n所以\n$$\n\\Delta E_f^{\\text{oct}} = 0.000 \\ \\text{eV} + 3.500 \\ \\text{eV} = 3.500 \\ \\text{eV}.\n$$\n\n接下来，结合在 $T=800 \\ \\text{K}$ 时的振动形成自由能修正，以获得形成吉布斯自由能：\n$$\n\\Delta G_f^{\\text{tet}}(800 \\ \\text{K}) = \\Delta E_f^{\\text{tet}} + \\Delta F_{\\text{vib}}^{\\text{tet}}(800 \\ \\text{K}) = 3.200 \\ \\text{eV} + \\left(-0.12 \\ \\text{eV}\\right) = 3.080 \\ \\text{eV},\n$$\n$$\n\\Delta G_f^{\\text{oct}}(800 \\ \\text{K}) = \\Delta E_f^{\\text{oct}} + \\Delta F_{\\text{vib}}^{\\text{oct}}(800 \\ \\text{K}) = 3.500 \\ \\text{eV} + \\left(-0.20 \\ \\text{eV}\\right) = 3.300 \\ \\text{eV}.\n$$\n\n因此，差值为\n$$\n\\Delta G_f^{\\text{tet}}(800 \\ \\text{K}) - \\Delta G_f^{\\text{oct}}(800 \\ \\text{K}) = 3.080 \\ \\text{eV} - 3.300 \\ \\text{eV} = -0.220 \\ \\text{eV}.\n$$\n\n将此结果代入占有率比的表达式中：\n$$\n\\frac{n_{\\text{tet}}}{n_{\\text{oct}}} = \\exp\\!\\left[-\\frac{-0.220 \\ \\text{eV}}{k_B T}\\right] = \\exp\\!\\left[\\frac{0.220 \\ \\text{eV}}{k_B T}\\right].\n$$\n\n使用 $k_B = 8.617333262 \\times 10^{-5} \\ \\text{eV} \\, \\text{K}^{-1}$ 计算在 $T=800 \\ \\text{K}$ 时的 $k_B T$：\n$$\nk_B T = \\left(8.617333262 \\times 10^{-5} \\ \\text{eV} \\, \\text{K}^{-1}\\right)\\left(800 \\ \\text{K}\\right) = 6.8938666096 \\times 10^{-2} \\ \\text{eV}.\n$$\n\n因此，\n$$\n\\frac{n_{\\text{tet}}}{n_{\\text{oct}}} = \\exp\\!\\left(\\frac{0.220}{0.068938666096}\\right) \\approx \\exp\\!\\left(3.1912\\right).\n$$\n\n最后，\n$$\n\\exp\\!\\left(3.1912\\right) \\approx 24.3 \\quad \\text{(rounded to three significant figures)}.\n$$\n这个无量纲值就是所求的每位点占有率之比。",
            "answer": "$$\\boxed{24.3}$$"
        },
        {
            "introduction": "在确定了缺陷的稳定构型之后，下一步是研究它们的动力学行为，即它们如何在晶体中迁移。本练习将介绍一种核心计算方法——微动弹性带（Nudged Elastic Band, NEB）方法，用于寻找缺陷迁移的最小能量路径并计算能垒 。这个迁移能垒是理解扩散、蠕变和相变等多种材料现象动力学的关键参数。",
            "id": "3833685",
            "problem": "一个在晶体基质中迁移的单个原子可以被建模为一个在固定晶格位点和障碍物影响下于二维空间中运动的点。总势能定义为以两个晶格位点为中心的两个吸引性莫尔斯势与一个以障碍物为中心的短程排斥指数势之和。设原子位置在平面上为 $\\mathbf{R} = (x,y)$，左侧晶格位点位于 $\\mathbf{R}_{\\mathrm{L}} = (-a,0)$，右侧晶格位点位于 $\\mathbf{R}_{\\mathrm{R}} = (a,0)$，中心障碍物位于 $\\mathbf{R}_{\\mathrm{O}} = (0,0)$。总势能为\n$$\nE(\\mathbf{R}) = V_{\\mathrm{Morse}}(|\\mathbf{R} - \\mathbf{R}_{\\mathrm{L}}|) + V_{\\mathrm{Morse}}(|\\mathbf{R} - \\mathbf{R}_{\\mathrm{R}}|) + V_{\\mathrm{rep}}(|\\mathbf{R} - \\mathbf{R}_{\\mathrm{O}}|),\n$$\n其中莫尔斯吸引势为\n$$\nV_{\\mathrm{Morse}}(r) = D_e \\left(\\left(1 - e^{-\\alpha (r - r_0)}\\right)^2 - 1\\right),\n$$\n排斥障碍物势为\n$$\nV_{\\mathrm{rep}}(r) = A e^{-\\beta r}.\n$$\n所有距离均以埃（表示为 $\\mathrm{\\AA}$）为单位，所有能量均以电子伏特（表示为 $\\mathrm{eV}$）为单位。\n\n您必须实现微动弹性带（Nudged Elastic Band, NEB）方法，以计算原子从靠近左侧位点的初始极小值点移动到靠近右侧位点的最终极小值点的迁移势垒。使用以下具有物理动机的设置：\n- 初始原子位置为 $\\mathbf{R}_{\\mathrm{start}} = (-a + r_0, 0)$，最终原子位置为 $\\mathbf{R}_{\\mathrm{end}} = (a - r_0, 0)$，这近似于沿连接两个晶格位点的直线上、距离各自位点 $r_0$ 处的局域极小值点。\n- 通过在 $\\mathbf{R}_{\\mathrm{start}}$ 和 $\\mathbf{R}_{\\mathrm{end}}$ 之间进行笛卡尔坐标的线性插值，构建一条由 $N$ 个构象（image）组成的初始路径。在整个优化过程中，端点是固定的。\n- 作用于内部构象 $i$ 上的NEB力是垂直于局域路径切线的真实力分量和沿切线的弹簧力的组合。设 $\\mathbf{F}_i^{\\mathrm{true}} = -\\nabla E(\\mathbf{R}_i)$ 为构象 $i$ 上的真实力，切线 $\\boldsymbol{\\tau}_i$ 通过使用相邻构象 $i-1$ 和 $i+1$ 的能量加权方案来定义：\n  - 定义 $\\Delta \\mathbf{R}_i^+ = \\mathbf{R}_{i+1} - \\mathbf{R}_i$，$\\Delta \\mathbf{R}_i^- = \\mathbf{R}_i - \\mathbf{R}_{i-1}$，$E_{i-1} = E(\\mathbf{R}_{i-1})$，$E_i = E(\\mathbf{R}_i)$，$E_{i+1} = E(\\mathbf{R}_{i+1})$。\n  - 如果 $E_{i+1} > E_i > E_{i-1}$，则将 $\\boldsymbol{\\tau}_i$ 设置为沿 $\\Delta \\mathbf{R}_i^+$ 方向的单位向量。\n  - 如果 $E_{i+1}  E_i  E_{i-1}$，则将 $\\boldsymbol{\\tau}_i$ 设置为沿 $\\Delta \\mathbf{R}_i^-$ 方向的单位向量。\n  - 否则，设置 $\\boldsymbol{\\tau}_i \\propto \\max(E_{i+1} - E_i, 0)\\,\\Delta \\mathbf{R}_i^+ + \\max(E_{i-1} - E_i, 0)\\,\\Delta \\mathbf{R}_i^-$ 并将其归一化为单位长度。如果结果向量为零，则使用归一化后的 $\\Delta \\mathbf{R}_i^+ + \\Delta \\mathbf{R}_i^-$。\n- 对于非爬山构象，NEB力为\n$$\n\\mathbf{F}_i^{\\mathrm{NEB}} = \\mathbf{F}_i^{\\perp} + \\mathbf{F}_i^{\\mathrm{spring}},\n$$\n其中垂直分量为 $\\mathbf{F}_i^{\\perp} = \\mathbf{F}_i^{\\mathrm{true}} - (\\mathbf{F}_i^{\\mathrm{true}} \\cdot \\boldsymbol{\\tau}_i)\\,\\boldsymbol{\\tau}_i$，弹簧力为 $\\mathbf{F}_i^{\\mathrm{spring}} = k_s \\left(\\|\\Delta \\mathbf{R}_i^+\\| - \\|\\Delta \\mathbf{R}_i^-\\|\\right) \\boldsymbol{\\tau}_i$，$k_s$ 是一个常数弹簧常数，单位为 $\\mathrm{eV}/\\mathrm{\\AA}^2$。\n- 应用爬山构象修正：在每次迭代中，找出能量最高的内部构象 $m$，并将其力替换为\n$$\n\\mathbf{F}_m^{\\mathrm{CI}} = \\mathbf{F}_m^{\\mathrm{true}} - 2\\,(\\mathbf{F}_m^{\\mathrm{true}} \\cdot \\boldsymbol{\\tau}_m)\\,\\boldsymbol{\\tau}_m,\n$$\n同时移除该构象的任何弹簧力贡献。\n\n对内部构象使用一个简单的显式更新规则：\n$$\n\\mathbf{R}_i \\leftarrow \\mathbf{R}_i + \\eta\\,\\mathbf{F}_i,\n$$\n其中 $\\eta$ 是用户指定的步长，单位为 $\\mathrm{\\AA}^2/\\mathrm{eV}$，$\\mathbf{F}_i$ 对于非爬山构象是 $\\mathbf{F}_i^{\\mathrm{NEB}}$，对于爬山构象是 $\\mathbf{F}_i^{\\mathrm{CI}}$。端点是固定的，不进行更新。\n\n当内部构象上的NEB力的最大模满足 $\\max_i \\|\\mathbf{F}_i\\|  \\varepsilon$ 时（其中 $\\varepsilon$ 是以 $\\mathrm{eV}/\\mathrm{\\AA}$ 为单位的容差），或者达到最大迭代次数时，NEB优化收敛。收敛后，按如下方式计算迁移势垒\n$$\nE_{\\mathrm{barrier}} = E(\\mathbf{R}_m) - E(\\mathbf{R}_{\\mathrm{start}}),\n$$\n结果以 $\\mathrm{eV}$ 表示，其中 $\\mathbf{R}_m$ 是收敛后的爬山构象的坐标。\n\n您的程序必须实现以上内容，并为以下测试套件生成结果，每个案例由一组参数元组 $(a, D_e, \\alpha, r_0, A, \\beta, N, k_s, \\text{max\\_iter}, \\eta, \\varepsilon)$ 指定，并标明单位：\n- 案例 1：$(2.0\\,\\mathrm{\\AA}, 0.2\\,\\mathrm{eV}, 2.0\\,\\mathrm{\\AA}^{-1}, 0.5\\,\\mathrm{\\AA}, 0.5\\,\\mathrm{eV}, 3.0\\,\\mathrm{\\AA}^{-1}, 9, 0.1\\,\\mathrm{eV}/\\mathrm{\\AA}^2, 2000, 0.05\\,\\mathrm{\\AA}^2/\\mathrm{eV}, 10^{-3}\\,\\mathrm{eV}/\\mathrm{\\AA})$。\n- 案例 2：$(2.0\\,\\mathrm{\\AA}, 0.2\\,\\mathrm{eV}, 2.0\\,\\mathrm{\\AA}^{-1}, 0.5\\,\\mathrm{\\AA}, 0.5\\,\\mathrm{eV}, 3.0\\,\\mathrm{\\AA}^{-1}, 3, 0.1\\,\\mathrm{eV}/\\mathrm{\\AA}^2, 3000, 0.02\\,\\mathrm{\\AA}^2/\\mathrm{eV}, 10^{-3}\\,\\mathrm{eV}/\\mathrm{\\AA})$。\n- 案例 3：$(2.0\\,\\mathrm{\\AA}, 0.2\\,\\mathrm{eV}, 2.0\\,\\mathrm{\\AA}^{-1}, 0.5\\,\\mathrm{\\AA}, 0.5\\,\\mathrm{eV}, 3.0\\,\\mathrm{\\AA}^{-1}, 9, 0.02\\,\\mathrm{eV}/\\mathrm{\\AA}^2, 3000, 0.05\\,\\mathrm{\\AA}^2/\\mathrm{eV}, 10^{-3}\\,\\mathrm{eV}/\\mathrm{\\AA})$。\n- 案例 4：$(2.0\\,\\mathrm{\\AA}, 0.2\\,\\mathrm{eV}, 2.0\\,\\mathrm{\\AA}^{-1}, 0.5\\,\\mathrm{\\AA}, 1.0\\,\\mathrm{eV}, 3.0\\,\\mathrm{\\AA}^{-1}, 9, 0.1\\,\\mathrm{eV}/\\mathrm{\\AA}^2, 2000, 0.05\\,\\mathrm{\\AA}^2/\\mathrm{eV}, 10^{-3}\\,\\mathrm{eV}/\\mathrm{\\AA})$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[x_1, x_2, x_3, x_4]$，其中每个 $x_i$ 是以 $\\mathrm{eV}$ 为单位的迁移势垒 $E_{\\mathrm{barrier}}$，四舍五入到六位小数。",
            "solution": "该问题经过验证，确认为**有效**。它在科学上基于计算材料科学的既定原理，在数学上是适定的、客观的，并为实现微动弹性带（NEB）方法提供了一套完整且一致的参数和指令。势能模型和NEB算法是该领域的标准工具。所提供的参数和单位在物理上是一致的，在计算上是可行的。\n\n解决方案通过实现指定的算法来进行。实现的核心组成部分是势能面、NEB优化循环和最终的势垒计算。\n\n### 1. 势能面与力的计算\n\n位于位置 $\\mathbf{R}=(x,y)$ 的原子的总势能 $E(\\mathbf{R})$ 是三个势之和：来自晶格位点 $\\mathbf{R}_{\\mathrm{L}}=(-a,0)$ 和 $\\mathbf{R}_{\\mathrm{R}}=(a,0)$ 的两个吸引性莫尔斯势，以及来自障碍物 $\\mathbf{R}_{\\mathrm{O}}=(0,0)$ 的一个排斥势。\n\n$$\nE(\\mathbf{R}) = V_{\\mathrm{Morse}}(r_L) + V_{\\mathrm{Morse}}(r_R) + V_{\\mathrm{rep}}(r_O)\n$$\n\n其中 $r_L = |\\mathbf{R} - \\mathbf{R}_{\\mathrm{L}}|$，$r_R = |\\mathbf{R} - \\mathbf{R}_{\\mathrm{R}}|$，$r_O = |\\mathbf{R} - \\mathbf{R}_{\\mathrm{O}}|$。莫尔斯势为 $V_{\\mathrm{Morse}}(r) = D_e \\left(\\left(1 - e^{-\\alpha (r - r_0)}\\right)^2 - 1\\right)$，排斥势为 $V_{\\mathrm{rep}}(r) = A e^{-\\beta r}$。\n\n原子上的“真实”力是势能的负梯度，$\\mathbf{F}^{\\mathrm{true}} = -\\nabla E(\\mathbf{R})$。使用链式法则，$\\nabla V(r(\\mathbf{R})) = \\frac{dV}{dr} \\nabla r$，总势能的梯度为：\n\n$$\n\\nabla E(\\mathbf{R}) = \\frac{d V_{\\mathrm{Morse}}}{dr}(r_L) \\frac{\\mathbf{R} - \\mathbf{R}_{\\mathrm{L}}}{r_L} + \\frac{d V_{\\mathrm{Morse}}}{dr}(r_R) \\frac{\\mathbf{R} - \\mathbf{R}_{\\mathrm{R}}}{r_R} + \\frac{d V_{\\mathrm{rep}}}{dr}(r_O) \\frac{\\mathbf{R} - \\mathbf{R}_{\\mathrm{O}}}{r_O}\n$$\n\n势能函数所需的导数为：\n$$\n\\frac{d V_{\\mathrm{Morse}}}{dr} = 2\\alpha D_e \\left(e^{-\\alpha (r - r_0)} - e^{-2\\alpha (r - r_0)}\\right)\n$$\n$$\n\\frac{d V_{\\mathrm{rep}}}{dr} = -\\beta A e^{-\\beta r}\n$$\n\n这些表达式允许在任意点 $\\mathbf{R}$ 对能量和力进行解析计算。\n\n### 2. 带爬山构象的微动弹性带（NEB）\n\nNEB方法用于寻找两个局域极小值点 $\\mathbf{R}_{\\mathrm{start}}$ 和 $\\mathbf{R}_{\\mathrm{end}}$ 之间的最小能量路径（MEP）。该路径被离散化为一系列 $N$ 个构象（image），$\\{\\mathbf{R}_0, \\mathbf{R}_1, \\ldots, \\mathbf{R}_{N-1}\\}$，其中 $\\mathbf{R}_0 = \\mathbf{R}_{\\mathrm{start}}$ 且 $\\mathbf{R}_{N-1} = \\mathbf{R}_{\\mathrm{end}}$。\n\n#### 路径初始化\n初始路径通过在起点和终点之间进行线性插值来创建：$\\mathbf{R}_{\\mathrm{start}} = (-a + r_0, 0)$ 和 $\\mathbf{R}_{\\mathrm{end}} = (a - r_0, 0)$。对于 $i = 0, \\ldots, N-1$，构象 $i$ 的初始位置为：\n$$\n\\mathbf{R}_i = \\mathbf{R}_{\\mathrm{start}} + \\frac{i}{N-1} (\\mathbf{R}_{\\mathrm{end}} - \\mathbf{R}_{\\mathrm{start}})\n$$\n\n#### 迭代优化\n内部构象（$\\mathbf{R}_1, \\ldots, \\mathbf{R}_{N-2}$）通过迭代弛豫到最小能量路径上。端点 $\\mathbf{R}_0$ 和 $\\mathbf{R}_{N-1}$ 保持固定。在每次迭代中，为每个内部构象计算一个特定的NEB力，并使用显式欧拉步更新其位置：\n$$\n\\mathbf{R}_i \\leftarrow \\mathbf{R}_i + \\eta\\,\\mathbf{F}_i \\quad \\text{for } i=1, \\ldots, N-2\n$$\n其中 $\\eta$ 是步长，$\\mathbf{F}_i$ 是计算出的NEB力。\n\n#### 切线和力的计算\n每个内部构象 $i$ 上的力取决于局域路径切线 $\\boldsymbol{\\tau}_i$。切线使用能量加权方案定义，以确保它从当前构象指向“上坡”方向。设 $\\Delta \\mathbf{R}_i^+ = \\mathbf{R}_{i+1} - \\mathbf{R}_i$ 和 $\\Delta \\mathbf{R}_i^- = \\mathbf{R}_i - \\mathbf{R}_{i-1}$。切向量 $\\boldsymbol{\\tau}_i$ 由相邻构象的相对能量确定，如问题陈述中所指定。\n\n对于大多数构象，NEB力是真实力的垂直分量和一个平行的弹簧力之和：\n$$\n\\mathbf{F}_i^{\\mathrm{NEB}} = \\mathbf{F}_i^{\\perp} + \\mathbf{F}_i^{\\mathrm{spring}}\n$$\n其中：\n- $\\mathbf{F}_i^{\\perp} = \\mathbf{F}_i^{\\mathrm{true}} - (\\mathbf{F}_i^{\\mathrm{true}} \\cdot \\boldsymbol{\\tau}_i)\\,\\boldsymbol{\\tau}_i$ 是真实力垂直于路径的分量。该分量驱动路径向最小能量路径移动。\n- $\\mathbf{F}_i^{\\mathrm{spring}} = k_s \\left(\\|\\Delta \\mathbf{R}_i^+\\| - \\|\\Delta \\mathbf{R}_i^-\\|\\right) \\boldsymbol{\\tau}_i$ 是一个沿切线方向的弹簧力，确保构象等间距分布。$k_s$ 是弹簧常数。\n\n为了准确定位鞍点（最小能量路径上的最高点），使用了爬山构象（CI）修正。在每次迭代中，找出具有最高势能的内部构象 $m$，$E(\\mathbf{R}_m) = \\max_{j=1..N-2} E(\\mathbf{R}_j)$。该构象的力被修改，以将其推向真实的鞍点：\n$$\n\\mathbf{F}_m^{\\mathrm{CI}} = \\mathbf{F}_m^{\\mathrm{true}} - 2\\,(\\mathbf{F}_m^{\\mathrm{true}} \\cdot \\boldsymbol{\\tau}_m)\\,\\boldsymbol{\\tau}_m\n$$\n这个力反转了真实力平行于路径的分量，同时仍然最小化垂直分量，从而有效地将构象沿路径“上坡”驱动到鞍点。\n\n#### 收敛\n迭代过程持续进行，直到任何内部构象上的力的最大模降至阈值 $\\varepsilon$ 以下，即 $\\max_{i=1..N-2} \\|\\mathbf{F}_i\\|  \\varepsilon$，或达到最大迭代次数。\n\n### 3. 迁移势垒计算\n路径收敛后，迁移能垒是鞍点能量与初始态能量之差。鞍点能量取为收敛路径上所有构象中的最大能量。\n$$\nE_{\\mathrm{barrier}} = \\left( \\max_{i=0..N-1} E(\\mathbf{R}_i) \\right) - E(\\mathbf{R}_{\\mathrm{start}})\n$$\n该值给出了原子从初始晶格位点迁移到最终晶格位点所需的最小能量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that sets up and runs the NEB calculations for all test cases.\n    \"\"\"\n\n    # Helper function to normalize a vector, handling the zero-norm case.\n    def normalize(v):\n        norm = np.linalg.norm(v)\n        if norm  1e-12:  # A small tolerance to avoid division by zero\n            return np.zeros_like(v)\n        return v / norm\n\n    # Potential energy functions\n    def V_morse(r, De, alpha, r0):\n        return De * ((1 - np.exp(-alpha * (r - r0)))**2 - 1)\n\n    def V_rep(r, A, beta):\n        return A * np.exp(-beta * r)\n\n    # Derivatives of potentials w.r.t. distance r\n    def dV_morse_dr(r, De, alpha, r0):\n        exp1 = np.exp(-alpha * (r - r0))\n        # To avoid overflow with large negative r-r0, we can cap the exponent\n        # but with current parameters it is not an issue.\n        exp2 = np.exp(-2 * alpha * (r - r0))\n        return 2 * alpha * De * (exp1 - exp2)\n\n    def dV_rep_dr(r, A, beta):\n        return -beta * A * np.exp(-beta * r)\n\n    # Total potential energy function\n    def total_potential(R, a, De, alpha, r0, A, beta):\n        R_L = np.array([-a, 0.0])\n        R_R = np.array([a, 0.0])\n        R_O = np.array([0.0, 0.0])\n        \n        r_L = np.linalg.norm(R - R_L)\n        r_R = np.linalg.norm(R - R_R)\n        r_O = np.linalg.norm(R - R_O)\n        \n        E = V_morse(r_L, De, alpha, r0) + \\\n            V_morse(r_R, De, alpha, r0) + \\\n            V_rep(r_O, A, beta)\n        return E\n\n    # True force function (-gradient of potential)\n    def true_force(R, a, De, alpha, r0, A, beta):\n        R_L = np.array([-a, 0.0])\n        R_R = np.array([a, 0.0])\n        R_O = np.array([0.0, 0.0])\n\n        r_L = np.linalg.norm(R - R_L)\n        r_R = np.linalg.norm(R - R_R)\n        r_O = np.linalg.norm(R - R_O)\n        \n        # Add a small epsilon to distance to avoid division by zero in gradient calculation\n        # if R coincides with a center (r=0).\n        eps = 1e-12\n        \n        grad_r_L = (R - R_L) / (r_L + eps)\n        grad_r_R = (R - R_R) / (r_R + eps)\n        grad_r_O = (R - R_O) / (r_O + eps)\n\n        grad_E = dV_morse_dr(r_L, De, alpha, r0) * grad_r_L + \\\n                 dV_morse_dr(r_R, De, alpha, r0) * grad_r_R + \\\n                 dV_rep_dr(r_O, A, beta) * grad_r_O\n                 \n        return -grad_E\n\n    def solve_case(params):\n        \"\"\"\n        Executes the CI-NEB algorithm for a single set of parameters.\n        \"\"\"\n        a, De, alpha, r0, A, beta, N, ks, max_iter, eta, epsilon = params\n        \n        # 1. Initialize path by linear interpolation\n        R_start = np.array([-a + r0, 0.0])\n        R_end = np.array([a - r0, 0.0])\n        \n        path = np.zeros((N, 2))\n        path[0] = R_start\n        path[-1] = R_end\n        if N > 1:\n            for i in range(1, N - 1):\n                path[i] = R_start + i * (R_end - R_start) / (N - 1)\n\n        # Encapsulate potential parameters for easy passing\n        potential_params = (a, De, alpha, r0, A, beta)\n        \n        # 2. Main NEB optimization loop\n        for _ in range(max_iter):\n            # Calculate energies of all images on the current path\n            energies = np.array([total_potential(R, *potential_params) for R in path])\n            \n            # There are no interior images to optimize if N  3\n            if N  3:\n                break\n            \n            # Calculate true forces on interior images (indices 1 to N-2)\n            forces_true = np.array([true_force(path[i], *potential_params) for i in range(1, N - 1)])\n            \n            # Identify the climbing image (image with the highest energy)\n            interior_energies = energies[1:-1]\n            climbing_image_idx = np.argmax(interior_energies) + 1\n            \n            neb_forces = np.zeros_like(forces_true)\n            \n            # Loop over interior images (from path index 1 to N-2)\n            for i in range(1, N - 1):\n                # Get energies and positions of adjacent images\n                E_prev, E_curr, E_next = energies[i-1], energies[i], energies[i+1]\n                R_prev, R_curr, R_next = path[i-1], path[i], path[i+1]\n                \n                dR_plus = R_next - R_curr\n                dR_minus = R_curr - R_prev\n                \n                # Tangent calculation based on the problem's energy-weighted scheme\n                if E_next > E_curr and E_curr > E_prev:\n                    tangent_vec = dR_plus\n                elif E_next  E_curr and E_curr  E_prev:\n                    tangent_vec = dR_minus\n                else:\n                    dE_plus = E_next - E_curr\n                    dE_minus = E_prev - E_curr\n                    tangent_vec = max(0, dE_plus) * dR_plus + max(0, dE_minus) * dR_minus\n                    if np.linalg.norm(tangent_vec)  1e-12:\n                        tangent_vec = dR_plus + dR_minus\n                \n                tau = normalize(tangent_vec)\n                \n                # Retrieve the true force for the current image (i)\n                # Note: forces_true is indexed from 0, so image i corresponds to index i-1\n                F_true_i = forces_true[i-1]\n\n                # Calculate the final force (CI or regular NEB)\n                if i == climbing_image_idx:\n                    # Climbing image force: invert force component parallel to the tangent\n                    force = F_true_i - 2 * np.dot(F_true_i, tau) * tau\n                else:\n                    # Regular NEB force\n                    F_perp = F_true_i - np.dot(F_true_i, tau) * tau\n                    F_spring = ks * (np.linalg.norm(dR_plus) - np.linalg.norm(dR_minus)) * tau\n                    force = F_perp + F_spring\n                \n                neb_forces[i-1] = force\n                \n            # Check for convergence\n            max_force_mag = np.max(np.linalg.norm(neb_forces, axis=1))\n            if max_force_mag  epsilon:\n                break\n                \n            # Update interior image positions using explicit Euler\n            path[1:-1] += eta * neb_forces\n\n        # 3. Calculate migration barrier from the converged path\n        final_energies = np.array([total_potential(R, *potential_params) for R in path])\n        \n        # Saddle point energy is the maximum along the path\n        E_saddle = np.max(final_energies)\n        E_start = final_energies[0]\n        E_barrier = E_saddle - E_start\n        \n        return round(E_barrier, 6)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, De, alpha, r0, A, beta, N, ks, max_iter, eta, epsilon)\n        (2.0, 0.2, 2.0, 0.5, 0.5, 3.0, 9, 0.1, 2000, 0.05, 1e-3),\n        (2.0, 0.2, 2.0, 0.5, 0.5, 3.0, 3, 0.1, 3000, 0.02, 1e-3),\n        (2.0, 0.2, 2.0, 0.5, 0.5, 3.0, 9, 0.02, 3000, 0.05, 1e-3),\n        (2.0, 0.2, 2.0, 0.5, 1.0, 3.0, 9, 0.1, 2000, 0.05, 1e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了缺陷的形成能和迁移能垒后，我们就可以模拟缺陷在宏观时间尺度上的集体行为。本练习将引导您构建一个动力学蒙特卡洛（Kinetic Monte Carlo, KMC）模型，这是一种连接原子跳跃事件与宏观材料性质（如扩散系数）的强大方法 。通过将从原子尺度计算中获得的参数应用于KMC模拟，您将亲身体验多尺度材料模拟的核心思想。",
            "id": "2784754",
            "problem": "要求您构建一个完整、可运行的程序，该程序使用密度泛函理论（DFT）推导的能垒和尝试频率，对晶体固体中点缺陷扩散的动力学蒙特卡洛（KMC）模型进行参数化，并根据阿伦尼乌斯形式的实验数据集验证预测的扩散系数。物理背景为一个点缺陷（空位或间隙原子）在简单立方晶格上进行热激活的最近邻跃迁。推导和实现必须从纳米力学以及表面与界面科学中的标准基本原理出发。\n\n假设以下基础：\n- 根据谐波过渡态理论（hTST），单次激活跃迁的跃迁速率由 $k = \\nu \\exp\\!\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right)$ 给出，其中 $k$ 是速率，单位为 $\\mathrm{s}^{-1}$；$\\nu$ 是尝试频率，单位为 $\\mathrm{s}^{-1}$；$E_\\mathrm{a}$ 是活化能，单位为电子伏特（eV）；$k_\\mathrm{B}$ 是玻尔兹曼常数；$T$ 是绝对温度，单位为 $\\mathrm{K}$。使用 $k_\\mathrm{B} = 8.617\\,333\\,262\\,145\\times 10^{-5}\\ \\mathrm{eV/K}$。\n- 一个简单立方晶格有 $z = 6$ 个等价的最近邻，它们之间的距离为晶格常数 $a$（跃迁长度），以米为单位表示。\n- 使用驻留时间算法的动力学蒙特卡洛通过从均值为 $1/R_\\mathrm{tot}$ 的指数分布中抽取的随机增量来推进时间，其中 $R_\\mathrm{tot}$ 是离开当前状态的总速率。对于 $z$ 个等价邻居，$R_\\mathrm{tot} = z k$。在等价邻居中的方向选择是根据其各自速率成比例的概率进行抽样的。\n\n基于这些基础，您必须：\n- 在 $d = 3$ 空间维度中，为点缺陷的示踪扩散系数 $D$ 推导一个与模拟一致的估计量，通过将 $D$ 表示为总耗时内的均方位移，即使用爱因斯坦关系以及连续时间最近邻随机行走的性质。您的推导必须从上述定义和标准随机行走理论出发，不得调用任何预先制表的扩散系数快捷公式。\n- 构建一个 KMC 算法，对于给定的参数集 $(a, T, E_\\mathrm{a}, \\nu, z)$，执行 $n$ 次跃迁，累加驻留时间算法推进的总物理时间，并在 $z$ 个等价邻居中抽样随机跃迁方向，以生成缺陷在 $3$ 维空间中的轨迹。然后，您的算法必须从该轨迹计算出示踪扩散系数的估计值 $D_\\mathrm{KMC}$，单位为 $\\mathrm{m}^2/\\mathrm{s}$。\n- 根据实验阿伦尼乌斯模型 $D_\\mathrm{exp}(T) = D_0 \\exp\\!\\left(-\\frac{Q}{k_\\mathrm{B} T}\\right)$ 在相同温度 $T$ 下验证 $D_\\mathrm{KMC}$，其中 $D_0$ 和 $Q$ 为每个测试用例提供。为本问题之目的，“实验”参数与底层的DFT参数在内部是一致的，但应被视为给定的实验值。\n\n单位和数值输出：\n- 所有长度必须以米为单位，能量以电子伏特为单位，温度以开尔文为单位，时间以秒为单位，扩散系数以 $\\mathrm{m}^2/\\mathrm{s}$ 为单位。\n- 您的程序必须输出扩散系数，单位为 $\\mathrm{m}^2/\\mathrm{s}$。\n- 验证标准定义为每个测试用例的布尔值通过/失败：如果绝对相对误差 $\\left|D_\\mathrm{KMC} - D_\\mathrm{exp}\\right|/D_\\mathrm{exp}$ 小于或等于容差 $\\epsilon$（其中 $\\epsilon = 0.2$），则该用例通过。\n\n测试套件：\n实现您的程序以精确运行以下三个测试用例，每个用例由 $(a, T, E_\\mathrm{a}, \\nu, z, D_0, Q)$ 指定，其中 $D_0$ 和 $Q$ 用于参数化阿伦尼乌斯形式的实验参考 $D_\\mathrm{exp}$。\n\n- 用例 A（类空位，中等能垒，“理想路径”）：\n  - $a = 3.0\\times 10^{-10}\\ \\mathrm{m}$，\n  - $T = 900\\ \\mathrm{K}$，\n  - $E_\\mathrm{a} = 0.6\\ \\mathrm{eV}$，\n  - $\\nu = 1.0\\times 10^{13}\\ \\mathrm{s}^{-1}$，\n  - $z = 6$，\n  - $D_0 = a^2 \\nu$，\n  - $Q = E_\\mathrm{a}$。\n- 用例 B（类间隙原子，低能垒，更快扩散）：\n  - $a = 2.86\\times 10^{-10}\\ \\mathrm{m}$，\n  - $T = 600\\ \\mathrm{K}$，\n  - $E_\\mathrm{a} = 0.2\\ \\mathrm{eV}$，\n  - $\\nu = 5.0\\times 10^{12}\\ \\mathrm{s}^{-1}$，\n  - $z = 6$，\n  - $D_0 = a^2 \\nu$，\n  - $Q = E_\\mathrm{a}$。\n- 用例 C（边缘情况，极高能垒，极慢扩散）：\n  - $a = 3.0\\times 10^{-10}\\ \\mathrm{m}$，\n  - $T = 300\\ \\mathrm{K}$，\n  - $E_\\mathrm{a} = 2.0\\ \\mathrm{eV}$，\n  - $\\nu = 1.0\\times 10^{13}\\ \\mathrm{s}^{-1}$，\n  - $z = 6$，\n  - $D_0 = a^2 \\nu$，\n  - $Q = E_\\mathrm{a}$。\n\n算法约束和指导：\n- 使用驻留时间算法，总速率为 $R_\\mathrm{tot} = z \\nu \\exp\\!\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right)$，并在每次跃迁时在 $z$ 个方向中进行等概率选择。\n- 为确保统计稳定性同时保持效率，您可以选择一个固定的跃迁次数 $n$（所有用例共享或每个用例单独设置），该值应足够大，以使相对误差标准能够得到有意义的测试。\n- 使用任何科学上合理的方法来抽样与上述物理过程一致的驻留时间和方向序列。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表形式的结果，列表长度为 $3$，并用方括号括起来，其中每个元素本身是一个长度为 $3$ 的列表，形式为 $[D_\\mathrm{KMC}, D_\\mathrm{exp}, \\mathrm{pass}]$。例如：$[[D_1,D_1^\\ast,\\mathrm{True}],[D_2,D_2^\\ast,\\mathrm{False}],[D_3,D_3^\\ast,\\mathrm{True}]]$。\n- 每个 $D_\\mathrm{KMC}$ 和 $D_\\mathrm{exp}$ 都必须以 $\\mathrm{m}^2/\\mathrm{s}$ 为单位提供。如果 $\\left|D_\\mathrm{KMC} - D_\\mathrm{exp}\\right|/D_\\mathrm{exp} \\le \\epsilon$（其中 $\\epsilon = 0.2$），布尔值 $\\mathrm{pass}$ 必须为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。",
            "solution": "所提供的问题陈述需经过验证。\n\n### 步骤1：提取给定条件\n- **跃迁速率**：单次激活跃迁的速率遵循谐波过渡态理论（hTST）：$k = \\nu \\exp\\!\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right)$。\n- **常数**：玻尔兹曼常数 $k_\\mathrm{B} = 8.617\\,333\\,262\\,145\\times 10^{-5}\\ \\mathrm{eV/K}$。\n- **晶格**：简单立方晶格，配位数为 $z = 6$。最近邻跃迁长度为晶格常数 $a$。\n- **KMC算法**：模拟必须使用驻留时间算法。时间增量 $\\Delta t$ 从均值为 $1/R_\\mathrm{tot}$ 的指数分布中抽取。总逃逸速率为 $R_\\mathrm{tot} = z k$。\n- **扩散系数定义**：在 $d=3$ 维度中的示踪扩散系数 $D$ 由爱因斯坦关系定义，从均方位移（MSD）推导得出。\n- **实验参考**：扩散系数遵循阿伦尼乌斯形式，$D_\\mathrm{exp}(T) = D_0 \\exp\\!\\left(-\\frac{Q}{k_\\mathrm{B} T}\\right)$。\n- **验证标准**：对于给定的测试用例，如果其相对于 $D_\\mathrm{exp}$ 的绝对相对误差最多为 $\\epsilon = 0.2$，即 $\\left|D_\\mathrm{KMC} - D_\\mathrm{exp}\\right|/D_\\mathrm{exp} \\le 0.2$，则认为模拟结果 $D_\\mathrm{KMC}$ 有效。\n- **测试用例**：提供了三个用例，每个用例由一组参数 $(a, T, E_\\mathrm{a}, \\nu, z, D_0, Q)$ 定义。对于所有用例，$z=6$，且实验参数定义为 $D_0 = a^2 \\nu$ 和 $Q = E_\\mathrm{a}$。\n\n### 步骤2：使用提取的给定条件进行验证\n- **科学基础**：该问题完美地基于统计力学和计算材料科学的标准原理，特别是热激活过程理论（hTST）、随机模拟（KMC）和随机行走（爱因斯坦关系）。这些是该领域的教科书概念。\n- **适定性**：问题是适定的。它提供了所有必要的物理参数和常数，一个明确的目标（推导、实现和验证），以及一个定量的、明确的验证标准。KMC输出的随机性已被承认，并且暗示了需要统计上显著数量的模拟步骤，这是此类问题的标准方面，而不是缺陷。\n- **客观性**：问题以客观、正式的语言陈述，没有任何主观性或非科学性主张。\n- **内部一致性**：需要对一致性进行严格检查。问题根据微观模拟参数指定了“实验”模型 $D_\\mathrm{exp}$ 的参数。理论推导必须将两者联系起来。如下所示，该问题的构造是完全自洽的，其中从微观参数推导出的扩散系数的理论预测与所提供的“实验”形式完全匹配。\n\n### 步骤3：结论与行动\n问题被评估为 **有效**。这是一个标准的、定义明确的计算物理问题，用于测试基本理解和实现技能。我现在将着手解决。\n\n### 示踪扩散系数的推导\n\n示踪扩散系数 $D$ 由 $d=3$ 维的爱因斯坦关系定义：\n$$\nD = \\lim_{t\\to\\infty} \\frac{\\langle |\\mathbf{r}(t) - \\mathbf{r}(0)|^2 \\rangle}{2dt} = \\lim_{t\\to\\infty} \\frac{\\langle |\\mathbf{r}(t) - \\mathbf{r}(0)|^2 \\rangle}{6t}\n$$\n这里，$\\langle \\cdot \\rangle$ 表示对许多轨迹的系综平均。设缺陷从原点开始，$\\mathbf{r}(0) = \\mathbf{0}$。经过 $n$ 次跃迁后，位置为 $\\mathbf{r}_n = \\sum_{i=1}^{n} \\Delta\\mathbf{r}_i$，其中 $\\Delta\\mathbf{r}_i$ 是第 $i$ 次跃迁的位移矢量。\n\n$n$ 次跃迁后的均方位移（MSD）为：\n$$\n\\langle |\\mathbf{r}_n|^2 \\rangle = \\left\\langle \\left(\\sum_{i=1}^{n} \\Delta\\mathbf{r}_i\\right) \\cdot \\left(\\sum_{j=1}^{n} \\Delta\\mathbf{r}_j\\right) \\right\\rangle = \\sum_{i=1}^{n} \\langle |\\Delta\\mathbf{r}_i|^2 \\rangle + \\sum_{i \\neq j} \\langle \\Delta\\mathbf{r}_i \\cdot \\Delta\\mathbf{r}_j \\rangle\n$$\n对于晶格上的随机行走，连续的跃迁是不相关的。在像简单立方这样的中心对称晶格上，单次跃迁的平均位移为零，且向不同方向的跃迁等可能，导致对于 $i \\neq j$ 有 $\\langle \\Delta\\mathbf{r}_i \\cdot \\Delta\\mathbf{r}_j \\rangle = \\langle \\Delta\\mathbf{r}_i \\rangle \\cdot \\langle \\Delta\\mathbf{r}_j \\rangle = 0$。\n跃迁长度固定为最近邻距离 $a$，因此对于所有 $i$ 都有 $|\\Delta\\mathbf{r}_i|^2 = a^2$。MSD简化为：\n$$\n\\langle |\\mathbf{r}_n|^2 \\rangle = n a^2\n$$\n$n$ 次跃迁后经过的总时间 $t_n$ 是 $n$ 个独立时间增量的总和：$t_n = \\sum_{i=1}^{n} \\Delta t_i$。在驻留时间算法中，每个 $\\Delta t_i$ 是从速率参数为 $R_\\mathrm{tot}$ 的指数分布中抽取的随机变量。每个时间步的期望值为 $\\langle \\Delta t \\rangle = 1/R_\\mathrm{tot}$。根据大数定律，对于大量的跃迁次数 $n$，总时间 $t_n$ 近似于其期望值：\n$$\nt_n \\approx n \\langle \\Delta t \\rangle = \\frac{n}{R_\\mathrm{tot}}\n$$\n将MSD和总时间的表达式代入爱因斯坦关系，我们得到理论扩散系数 $D_\\mathrm{theory}$：\n$$\nD_\\mathrm{theory} = \\frac{\\langle |\\mathbf{r}_n|^2 \\rangle}{6 t_n} = \\frac{n a^2}{6 (n/R_\\mathrm{tot})} = \\frac{a^2 R_\\mathrm{tot}}{6}\n$$\n总速率 $R_\\mathrm{tot}$ 是所有可能逃逸路径速率的总和。对于具有 $z=6$ 个相同最近邻位置的简单立方晶格，$R_\\mathrm{tot} = z k$。代入跃迁速率 $k$ 的表达式：\n$$\nD_\\mathrm{theory} = \\frac{a^2 (z k)}{6} = \\frac{z a^2}{6} \\nu \\exp\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right)\n$$\n对于简单立方晶格的特定情况，$z=6$，这变为：\n$$\nD_\\mathrm{theory} = \\frac{6 a^2}{6} \\nu \\exp\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right) = a^2 \\nu \\exp\\left(-\\frac{E_\\mathrm{a}}{k_\\mathrm{B} T}\\right)\n$$\n现在，我们将其与给定的实验形式 $D_\\mathrm{exp}(T) = D_0 \\exp\\left(-\\frac{Q}{k_\\mathrm{B} T}\\right)$ 进行比较。问题陈述中指出，对于所有测试用例，$D_0 = a^2 \\nu$ 且 $Q = E_\\mathrm{a}$。因此，实验数据的解析形式与我们推导的理论扩散系数完全相同：$D_\\mathrm{theory} = D_\\mathrm{exp}$。\n这证实了问题的内部一致性。KMC模拟作为理论模型的数值实现，应该在大量跃迁的极限下产生一个收敛到该解析值 $D_\\mathrm{exp}$ 的扩散系数 $D_\\mathrm{KMC}$。任何偏差都将归因于随机模拟中固有的统计噪声。\n\n### 动力学蒙特卡洛算法设计\n\n将要实现的算法将模拟单个点缺陷的轨迹并计算其扩散系数。\n1.  **初始化**：对于每个测试用例，检索参数 $(a, T, E_\\mathrm{a}, \\nu, z)$。\n    - 将缺陷的初始位置设置为原点，$\\mathbf{r} = [0, 0, 0]$。\n    - 将总经过时间设置为零，$t_\\mathrm{total} = 0$。\n    - 定义 $z=6$ 个可能的跃迁矢量集合：$\\{(\\pm a, 0, 0), (0, \\pm a, 0), (0, 0, \\pm a)\\}$。\n2.  **速率计算**：计算单次跃迁速率 $k = \\nu \\exp(-E_\\mathrm{a} / (k_\\mathrm{B} T))$ 和总逃逸速率 $R_\\mathrm{tot} = z k$。平均驻留时间为 $\\tau = 1/R_\\mathrm{tot}$。\n3.  **模拟循环**：迭代一个固定的、较大的跃迁次数 $n_{hops}$。选择 $n_{hops} = 10000$。这个值足够大，以确保最终计算出的扩散系数的统计波动足够小，从而可以与 $\\epsilon=0.2$ 的验证容差进行有意义的比较，同时计算成本保持较低。\n    - **时间推进**：从均匀分布 $U(0, 1)$ 中抽取一个随机数 $u$，并将模拟时间推进 $\\Delta t = -\\ln(u) / R_\\mathrm{tot}$。这等效于从均值为 $\\tau$ 的指数分布中抽取。更新 $t_\\mathrm{total} = t_\\mathrm{total} + \\Delta t$。\n    - **跃迁选择**：由于所有 $z=6$ 个相邻位置都是等价的，以 $1/6$ 的均匀概率选择六个跃迁矢量之一。\n    - **位置更新**：将选定的跃迁矢量加到当前位置 $\\mathbf{r}$。\n4.  **扩散系数计算**：完成 $n_{hops}$ 次跃迁后，最终位置为 $\\mathbf{r}_\\mathrm{final}$，总时间为 $t_\\mathrm{total}$。使用端点数据，根据爱因斯坦关系计算KMC估计的扩散系数：\n    $$\n    D_\\mathrm{KMC} = \\frac{|\\mathbf{r}_\\mathrm{final}|^2}{6 t_\\mathrm{total}}\n    $$\n5.  **验证**：计算“实验”值 $D_\\mathrm{exp} = (a^2 \\nu) \\exp(-E_\\mathrm{a} / (k_\\mathrm{B} T))$。判断是否满足通过条件 $\\left|D_\\mathrm{KMC} - D_\\mathrm{exp}\\right|/D_\\mathrm{exp} \\le 0.2$。\n此过程将对提供的三个测试用例中的每一个实施。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a Kinetic Monte Carlo (KMC) simulation for point defect\n    diffusion, validating the results against an analytical Arrhenius-form model.\n    \"\"\"\n\n    # Boltzmann constant in eV/K\n    k_B = 8.617333262145e-5\n\n    # Number of hops for the KMC simulation.\n    # Chosen to be large enough for statistical convergence.\n    n_hops = 10000\n\n    # Tolerance for validation\n    epsilon = 0.2\n\n    # Test cases as specified in the problem statement.\n    # (a, T, E_a, nu, z, D0_formula, Q_formula)\n    # D0 and Q are given as formulas a^2*nu and E_a, respectively.\n    test_cases = [\n        # Case A: Vacancy-like, moderate barrier\n        {'a': 3.0e-10, 'T': 900.0, 'E_a': 0.6, 'nu': 1.0e13, 'z': 6},\n        # Case B: Interstitial-like, low barrier\n        {'a': 2.86e-10, 'T': 600.0, 'E_a': 0.2, 'nu': 5.0e12, 'z': 6},\n        # Case C: Edge case, very high barrier\n        {'a': 3.0e-10, 'T': 300.0, 'E_a': 2.0, 'nu': 1.0e13, 'z': 6},\n    ]\n\n    results = []\n\n    # Use a fixed seed for reproducibility of the stochastic simulation\n    np.random.seed(42)\n\n    for case in test_cases:\n        a = case['a']\n        T = case['T']\n        E_a = case['E_a']\n        nu = case['nu']\n        z = case['z']\n\n        # --- Theoretical/Experimental Calculation ---\n        # The problem states D0 = a^2 * nu and Q = E_a.\n        # This is consistent with the derivation for a simple cubic lattice (z=6).\n        D_exp = (a**2 * nu) * np.exp(-E_a / (k_B * T))\n\n        # --- KMC Simulation ---\n        # 1. Initialization\n        position = np.zeros(3)\n        total_time = 0.0\n\n        # Define the jump vectors for a simple cubic lattice\n        jump_vectors = a * np.array([\n            [1, 0, 0], [-1, 0, 0],\n            [0, 1, 0], [0, -1, 0],\n            [0, 0, 1], [0, 0, -1]\n        ])\n\n        # 2. Rate Calculation\n        k_hop = nu * np.exp(-E_a / (k_B * T))\n        R_tot = z * k_hop\n        \n        # Mean time step (scale for exponential distribution)\n        # Handle R_tot=0 case to avoid division by zero, though not expected here.\n        tau = 1.0 / R_tot if R_tot > 0 else float('inf')\n\n        # 3. Simulation Loop\n        # Advance time by drawing from exponential distribution\n        time_steps = np.random.exponential(scale=tau, size=n_hops)\n        total_time = np.sum(time_steps)\n        \n        # Select jump directions uniformly\n        jump_indices = np.random.randint(0, z, size=n_hops)\n        \n        # Sum up all jump vectors to get the final position\n        # This is more efficient than a Python loop for position updates\n        final_position = np.sum(jump_vectors[jump_indices], axis=0)\n        \n        # 4. Diffusivity Calculation\n        # Mean squared displacement from origin\n        msd = np.dot(final_position, final_position)\n        \n        # Einstein relation in 3D\n        D_kmc = msd / (6.0 * total_time)\n\n        # 5. Validation\n        relative_error = np.abs(D_kmc - D_exp) / D_exp\n        passed = relative_error = epsilon\n\n        results.append([D_kmc, D_exp, passed])\n\n    # Format the final output string to match the specified format `[[d,d_exp,pass],...]`\n    # without any spaces.\n    results_str_parts = []\n    for res in results:\n        # Format each sublist manually to control spacing\n        # res[2] is a bool, str(res[2]) gives 'True'/'False'\n        part = f\"[{res[0]},{res[1]},{str(res[2])}]\"\n        results_str_parts.append(part)\n    \n    final_output = f\"[{','.join(results_str_parts)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}