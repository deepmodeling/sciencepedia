{
    "hands_on_practices": [
        {
            "introduction": "Before modeling the collective behavior of dislocations that leads to plasticity, it is essential to understand the properties of a single dislocation line. This exercise focuses on the fundamental geometric characterization of a dislocation through its Burgers vector $\\mathbf{b}$ and line direction $\\boldsymbol{\\xi}$. By calculating the character angle $\\theta$, you will gain insight into how this basic geometric property directly influences physical behavior like dislocation mobility, a critical parameter in mesoscale simulation methods such as Discrete Dislocation Dynamics (DDD) .",
            "id": "3825957",
            "problem": "Consider a straight dislocation segment in a Face-Centered Cubic (FCC) crystal with slip system $\\{111\\}\\langle 110\\rangle$. Let the crystal lattice parameter be $a$, and adopt an orthonormal Cartesian basis aligned with the crystallographic axes $[100]$, $[010]$, and $[001]$. The dislocation has Burgers vector $\\mathbf{b}=\\frac{a}{2}[1\\,\\,-1\\,\\,0]$ and lies within the $(1\\,\\,1\\,\\,1)$ slip plane with line direction parallel to $[1\\,\\,0\\,\\,-1]$. The line direction unit vector is $\\boldsymbol{\\xi}=\\frac{1}{\\sqrt{2}}[1\\,\\,0\\,\\,-1]$. \n\nStarting from the geometric definition of the angle between two vectors and the fundamental kinematics of dislocations (Burgers vector, line direction, and slip plane compatibility), derive the character angle $\\theta$ between $\\mathbf{b}$ and $\\boldsymbol{\\xi}$. Use the definition that $\\theta$ is the angle between $\\mathbf{b}$ and $\\boldsymbol{\\xi}$, and express $\\theta$ in radians. Provide the exact value.\n\nThen, using the Peach–Koehler force and a linear drag law with character-dependent drag, explain how the character angle influences glide mobility in a mesoscale description such as Discrete Dislocation Dynamics (DDD; Discrete Dislocation Dynamics). Assume the drag for screw and edge characters are $B_{\\mathrm{s}}$ and $B_{\\mathrm{e}}$, respectively, and that the power dissipation per unit length is additive in the screw and edge components. No numerical evaluation of mobility is required.\n\nExpress the final angle in radians. No rounding is required; provide an exact value.",
            "solution": "A dislocation is characterized by its Burgers vector $\\mathbf{b}$ and line direction $\\boldsymbol{\\xi}$. The character angle $\\theta$ is defined as the angle between $\\mathbf{b}$ and $\\boldsymbol{\\xi}$. From elementary vector geometry, the angle $\\theta$ between vectors $\\mathbf{u}$ and $\\mathbf{v}$ is given by\n$$\n\\cos(\\theta)=\\frac{\\mathbf{u}\\cdot\\mathbf{v}}{\\|\\mathbf{u}\\|\\,\\|\\mathbf{v}\\|}.\n$$\nApplying this to the dislocation, with $\\mathbf{u}=\\mathbf{b}$ and $\\mathbf{v}=\\boldsymbol{\\xi}$, we have\n$$\n\\cos(\\theta)=\\frac{\\mathbf{b}\\cdot\\boldsymbol{\\xi}}{\\|\\mathbf{b}\\|\\,\\|\\boldsymbol{\\xi}\\|}.\n$$\nBy construction, $\\boldsymbol{\\xi}$ is a unit vector, so $\\|\\boldsymbol{\\xi}\\|=1$. Therefore,\n$$\n\\cos(\\theta)=\\frac{\\mathbf{b}\\cdot\\boldsymbol{\\xi}}{\\|\\mathbf{b}\\|}.\n$$\n\nWe now compute $\\mathbf{b}\\cdot\\boldsymbol{\\xi}$ and $\\|\\mathbf{b}\\|$ explicitly. In the chosen orthonormal basis, write\n$$\n\\mathbf{b}=\\frac{a}{2}\\begin{pmatrix}1\\\\-1\\\\0\\end{pmatrix},\\qquad\n\\boldsymbol{\\xi}=\\frac{1}{\\sqrt{2}}\\begin{pmatrix}1\\\\0\\\\-1\\end{pmatrix}.\n$$\nThe dot product is\n$$\n\\mathbf{b}\\cdot\\boldsymbol{\\xi}=\\left(\\frac{a}{2}\\right)\\left(\\frac{1}{\\sqrt{2}}\\right)\\left(1\\cdot 1+(-1)\\cdot 0+0\\cdot(-1)\\right)=\\frac{a}{2\\sqrt{2}}\\cdot 1=\\frac{a}{2\\sqrt{2}}.\n$$\nThe norm of $\\mathbf{b}$ is\n$$\n\\|\\mathbf{b}\\|=\\left\\|\\frac{a}{2}\\begin{pmatrix}1\\\\-1\\\\0\\end{pmatrix}\\right\\|=\\frac{a}{2}\\sqrt{1^{2}+(-1)^{2}+0^{2}}=\\frac{a}{2}\\sqrt{2}=\\frac{a\\sqrt{2}}{2}.\n$$\nTherefore,\n$$\n\\cos(\\theta)=\\frac{\\frac{a}{2\\sqrt{2}}}{\\frac{a\\sqrt{2}}{2}}=\\frac{a}{2\\sqrt{2}}\\cdot\\frac{2}{a\\sqrt{2}}=\\frac{1}{2}.\n$$\nThus,\n$$\n\\theta=\\arccos\\!\\left(\\frac{1}{2}\\right)=\\frac{\\pi}{3}.\n$$\nThe exact value of the character angle is $\\theta=\\frac{\\pi}{3}$ radians. This corresponds to a mixed character: neither purely screw ($\\theta=0$) nor purely edge ($\\theta=\\frac{\\pi}{2}$).\n\nImplications for mobility from first principles: The Peach–Koehler force per unit length on a dislocation with line direction $\\boldsymbol{\\xi}$ and Burgers vector $\\mathbf{b}$ in a stress field with Cauchy stress tensor $\\boldsymbol{\\sigma}$ is\n$$\n\\mathbf{f}_{\\mathrm{PK}}=(\\boldsymbol{\\sigma}\\cdot\\mathbf{b})\\times\\boldsymbol{\\xi}.\n$$\nFor pure glide under a resolved shear stress $\\tau$ on the slip system, the glide component of the Peach–Koehler force magnitude per unit length is\n$$\nf_{\\mathrm{glide}}=\\tau\\,\\|\\mathbf{b}\\|.\n$$\nIn a linear drag regime, the kinetic relation for the glide velocity $v$ is governed by the balance of power: the external power input $f_{\\mathrm{glide}}\\,v$ equals the dissipated power. If the dislocation has mixed character with screw fraction $\\cos(\\theta)$ and edge fraction $\\sin(\\theta)$, and if the drag coefficients for screw and edge characters are $B_{\\mathrm{s}}$ and $B_{\\mathrm{e}}$, respectively, a commonly used mesoscale additive dissipation model (consistent with projecting the velocity onto character components and adding their dissipations) gives the total dissipated power per unit length as\n$$\nP_{\\mathrm{diss}}=B_{\\mathrm{s}}\\,v^{2}\\cos^{2}(\\theta)+B_{\\mathrm{e}}\\,v^{2}\\sin^{2}(\\theta).\n$$\nEquating $f_{\\mathrm{glide}}\\,v=P_{\\mathrm{diss}}$ yields an effective drag\n$$\nB_{\\mathrm{eff}}(\\theta)=B_{\\mathrm{s}}\\cos^{2}(\\theta)+B_{\\mathrm{e}}\\sin^{2}(\\theta),\n$$\nand hence an effective mobility $M_{\\mathrm{eff}}(\\theta)=\\frac{1}{B_{\\mathrm{eff}}(\\theta)}$, so that\n$$\nv=M_{\\mathrm{eff}}(\\theta)\\,f_{\\mathrm{glide}}=\\frac{\\tau\\,\\|\\mathbf{b}\\|}{B_{\\mathrm{s}}\\cos^{2}(\\theta)+B_{\\mathrm{e}}\\sin^{2}(\\theta)}.\n$$\nFor the determined character angle $\\theta=\\frac{\\pi}{3}$, we have $\\cos^{2}(\\theta)=\\left(\\frac{1}{2}\\right)^{2}=\\frac{1}{4}$ and $\\sin^{2}(\\theta)=1-\\frac{1}{4}=\\frac{3}{4}$, leading to\n$$\nB_{\\mathrm{eff}}\\!\\left(\\frac{\\pi}{3}\\right)=\\frac{B_{\\mathrm{s}}}{4}+\\frac{3B_{\\mathrm{e}}}{4}.\n$$\nThus, if $B_{\\mathrm{e}}B_{\\mathrm{s}}$, the mixed character here is closer to edge-dominated in its dissipative weighting and results in lower mobility than a screw segment under the same $\\tau$. Conversely, if $B_{\\mathrm{s}}B_{\\mathrm{e}}$ (as often observed in body-centered cubic crystals due to nonplanar screw cores), the mobility is more limited by the screw component. In Face-Centered Cubic crystals at moderate temperatures, $B_{\\mathrm{s}}$ and $B_{\\mathrm{e}}$ can be comparable, making mixed segments like $\\theta=\\frac{\\pi}{3}$ moderately mobile; however, the nonzero screw component also affects mechanisms such as cross-slip, which strictly require $\\theta=0$. From a multiscale perspective, atomistic calculations of drag and core structures inform the character-dependent $B_{\\mathrm{s}}$ and $B_{\\mathrm{e}}$, which then enter mesoscale Discrete Dislocation Dynamics through $B_{\\mathrm{eff}}(\\theta)$, with $\\theta$ computed from $\\mathbf{b}$ and $\\boldsymbol{\\xi}$ as shown.",
            "answer": "$$\\boxed{\\frac{\\pi}{3}}$$"
        },
        {
            "introduction": "The plastic deformation of a material is the macroscopic manifestation of countless dislocation movements. Continuum plasticity models abstract this complex collective behavior into a set of constitutive equations. This practice challenges you to implement the radial return algorithm, a cornerstone of computational solid mechanics, to numerically integrate these equations . Mastering this hands-on implementation will provide you with a core skill for developing or understanding finite element codes used to simulate plastic deformation in engineering materials.",
            "id": "3825969",
            "problem": "Implement a small-strain uniaxial elastoplastic stress update with linear isotropic hardening using an implicit backward-Euler step and the radial return mapping logic specialized to one dimension, and compute the updated Cauchy stress. Work from first principles of rate-independent associative plasticity to derive the update equations and then implement them in a program that evaluates a specified test suite. Express every stress in Pascals (Pa) and every strain as a dimensionless quantity. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is a float in Pascals rounded to six decimal places.\n\nUse the following foundations.\n- Kinematics: For small strains, the total strain satisfies the additive decomposition $ \\varepsilon = \\varepsilon^{\\mathrm{e}} + \\varepsilon^{\\mathrm{p}} $.\n- Elasticity: In uniaxial form, the Cauchy stress is $ \\sigma = E \\, \\varepsilon^{\\mathrm{e}} $, where $ E $ is the Young’s modulus.\n- Yield criterion: Use the von Mises (also called $ J_2 $) criterion specialized to one dimension, $ f(\\sigma, \\alpha) = |\\sigma| - \\left( \\sigma_{y0} + H \\, \\alpha \\right) \\le 0 $, where $ \\sigma_{y0} $ is the initial yield stress, $ H $ is the linear isotropic hardening modulus, and $ \\alpha $ is the accumulated hardening variable consistent with the plastic strain measure in one dimension.\n- Flow rule and hardening law: Assume an associated flow, $ \\dot{\\varepsilon}^{\\mathrm{p}} = \\dot{\\gamma} \\, \\operatorname{sgn}(\\sigma) $ and $ \\dot{\\alpha} = \\dot{\\gamma} $, with $ \\dot{\\gamma} \\ge 0 $. The consistency conditions are $ f \\le 0 $, $ \\dot{\\gamma} \\ge 0 $, and $ \\dot{\\gamma} \\, f = 0 $.\n- Time integration: Over a strain increment $ \\Delta \\varepsilon $, apply an implicit backward-Euler update for the inelastic evolution equations.\n\nGiven material parameters $ E $, $ \\sigma_{y0} $, and $ H $, and the previous state $ \\sigma_n $ and $ \\alpha_n $ at time $ t_n $, together with a total strain increment $ \\Delta \\varepsilon $ from $ t_n $ to $ t_{n+1} $, derive from the above foundations a robust radial return update specialized to one dimension that computes the updated Cauchy stress $ \\sigma_{n+1} $ in Pascals and updated hardening variable $ \\alpha_{n+1} $. Then implement the algorithm to compute $ \\sigma_{n+1} $ for each test case below.\n\nUse the following test suite. For each case, all stresses are in Pascals (Pa), all strains are dimensionless, and the output must be the updated Cauchy stress $ \\sigma_{n+1} $ in Pascals (Pa), rounded to six decimal places.\n- Case $1$ (elastic loading): $ E = 210 \\times 10^{9} $, $ \\sigma_{y0} = 250 \\times 10^{6} $, $ H = 1 \\times 10^{9} $, $ \\sigma_{n} = 200 \\times 10^{6} $, $ \\alpha_{n} = 0 $, $ \\Delta \\varepsilon = 1 \\times 10^{-4} $.\n- Case $2$ (onset of yielding): $ E = 210 \\times 10^{9} $, $ \\sigma_{y0} = 250 \\times 10^{6} $, $ H = 1 \\times 10^{9} $, $ \\sigma_{n} = 200 \\times 10^{6} $, $ \\alpha_{n} = 0 $, $ \\Delta \\varepsilon = \\dfrac{50 \\times 10^{6}}{210 \\times 10^{9}} $.\n- Case $3$ (plastic loading with hardening): $ E = 210 \\times 10^{9} $, $ \\sigma_{y0} = 250 \\times 10^{6} $, $ H = 1 \\times 10^{9} $, $ \\sigma_{n} = 200 \\times 10^{6} $, $ \\alpha_{n} = 0 $, $ \\Delta \\varepsilon = 5 \\times 10^{-4} $.\n- Case $4$ (perfect plasticity limit): $ E = 210 \\times 10^{9} $, $ \\sigma_{y0} = 250 \\times 10^{6} $, $ H = 0 $, $ \\sigma_{n} = 200 \\times 10^{6} $, $ \\alpha_{n} = 0 $, $ \\Delta \\varepsilon = 5 \\times 10^{-4} $.\n- Case $5$ (elastic reverse loading after hardening): $ E = 210 \\times 10^{9} $, $ \\sigma_{y0} = 250 \\times 10^{6} $, $ H = 2 \\times 10^{9} $, $ \\sigma_{n} = 260 \\times 10^{6} $, $ \\alpha_{n} = 1 \\times 10^{-2} $, $ \\Delta \\varepsilon = -1 \\times 10^{-4} $.\n- Case $6$ (plastic compression): $ E = 210 \\times 10^{9} $, $ \\sigma_{y0} = 250 \\times 10^{6} $, $ H = 1 \\times 10^{9} $, $ \\sigma_{n} = 0 $, $ \\alpha_{n} = 0 $, $ \\Delta \\varepsilon = -2 \\times 10^{-3} $.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Cases $1$ through $6$, for example $[\\text{result1},\\text{result2},\\dots]$. Each entry must be a float in Pascals rounded to six decimal places.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the established theory of rate-independent continuum plasticity, is mathematically well-posed, and is presented in an objective, unambiguous manner. All necessary parameters and conditions are provided for a unique solution to be determined for each test case. The problem requires the derivation and implementation of a standard, canonical algorithm in computational solid mechanics.\n\nThe task is to derive and implement a stress update algorithm for a one-dimensional, small-strain elastoplastic model with linear isotropic hardening. The integration of the constitutive equations over a finite time step is performed using an implicit backward-Euler scheme, which leads to the radial return mapping algorithm.\n\nThe state of the material at time $t_n$ is known and defined by the Cauchy stress $\\sigma_n$ and the accumulated hardening variable $\\alpha_n$. The material is subjected to a total strain increment $\\Delta \\varepsilon$ over the time interval $[t_n, t_{n+1}]$. The goal is to compute the updated stress $\\sigma_{n+1}$ and hardening variable $\\alpha_{n+1}$.\n\nThe procedure is partitioned into three main steps: an elastic trial, a yield check, and a potential plastic corrector step.\n\n**1. Elastic Trial Step**\n\nFirst, we assume that the entire strain increment $\\Delta \\varepsilon$ is purely elastic. This means there is no change in the plastic state variables during the increment.\n$$ \\Delta \\varepsilon^{\\mathrm{p}} = 0 \\implies \\varepsilon_{n+1}^{\\mathrm{p}} = \\varepsilon_n^{\\mathrm{p}} $$\n$$ \\Delta \\alpha = 0 \\implies \\alpha_{n+1} = \\alpha_n $$\nThe total strain at time $t_{n+1}$ is $\\varepsilon_{n+1} = \\varepsilon_n + \\Delta \\varepsilon$. Using the additive decomposition of strain, $\\varepsilon = \\varepsilon^{\\mathrm{e}} + \\varepsilon^{\\mathrm{p}}$, the trial elastic strain at $t_{n+1}$ is:\n$$ \\varepsilon_{n+1}^{\\mathrm{e, trial}} = \\varepsilon_{n+1} - \\varepsilon_{n+1}^{\\mathrm{p}} = (\\varepsilon_n^{\\mathrm{e}} + \\varepsilon_n^{\\mathrm{p}}) + \\Delta \\varepsilon - \\varepsilon_n^{\\mathrm{p}} = \\varepsilon_n^{\\mathrm{e}} + \\Delta \\varepsilon $$\nThe trial stress, $\\sigma_{n+1}^{\\mathrm{trial}}$, is computed using the linear elastic law, $\\sigma = E \\varepsilon^{\\mathrm{e}}$:\n$$ \\sigma_{n+1}^{\\mathrm{trial}} = E \\, \\varepsilon_{n+1}^{\\mathrm{e, trial}} = E (\\varepsilon_n^{\\mathrm{e}} + \\Delta \\varepsilon) $$\nSince $\\sigma_n = E \\varepsilon_n^{\\mathrm{e}}$, this simplifies to a direct update from the previous stress state:\n$$ \\sigma_{n+1}^{\\mathrm{trial}} = \\sigma_n + E \\Delta \\varepsilon $$\n\n**2. Yield Check**\n\nThe elastic trial assumption is valid only if the resulting trial stress state does not violate the yield condition. The yield function is given by $f(\\sigma, \\alpha) = |\\sigma| - \\sigma_y(\\alpha)$, where the current yield stress is $\\sigma_y(\\alpha) = \\sigma_{y0} + H \\alpha$. We evaluate the yield function at the trial state $(\\sigma_{n+1}^{\\mathrm{trial}}, \\alpha_n)$:\n$$ f^{\\mathrm{trial}} = f(\\sigma_{n+1}^{\\mathrm{trial}}, \\alpha_n) = |\\sigma_{n+1}^{\\mathrm{trial}}| - (\\sigma_{y0} + H \\alpha_n) $$\nThere are two possibilities:\n- If $f^{\\mathrm{trial}} \\le 0$, the trial state is within or on the yield surface. The assumption of elastic deformation is correct. The final updated state is the trial state:\n  $$ \\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{trial}} $$\n  $$ \\alpha_{n+1} = \\alpha_n $$\n- If $f^{\\mathrm{trial}} > 0$, the trial state lies outside the yield surface, which is physically inadmissible. The elastic assumption is incorrect, and plastic deformation must have occurred. A plastic corrector step is required to return the stress state to the updated yield surface.\n\n**3. Plastic Corrector Step (Radial Return)**\n\nWhen $f^{\\mathrm{trial}} > 0$, plastic flow occurs. The state at $t_{n+1}$ must satisfy the full set of constitutive equations, integrated using an implicit backward-Euler scheme. The plastic strain and hardening variable increments are:\n$$ \\Delta \\varepsilon^{\\mathrm{p}} = \\varepsilon_{n+1}^{\\mathrm{p}} - \\varepsilon_n^{\\mathrm{p}} = \\Delta\\gamma \\, \\operatorname{sgn}(\\sigma_{n+1}) $$\n$$ \\Delta \\alpha = \\alpha_{n+1} - \\alpha_n = \\Delta\\gamma $$\nwhere $\\Delta\\gamma \\ge 0$ is the consistency parameter or plastic multiplier increment for the finite time step.\n\nThe stress-strain relation at $t_{n+1}$ is:\n$$ \\sigma_{n+1} = E \\varepsilon_{n+1}^{\\mathrm{e}} = E(\\varepsilon_{n+1} - \\varepsilon_{n+1}^{\\mathrm{p}}) = E(\\varepsilon_n + \\Delta\\varepsilon - (\\varepsilon_n^{\\mathrm{p}} + \\Delta\\varepsilon^{\\mathrm{p}})) $$\n$$ \\sigma_{n+1} = E(\\varepsilon_n^{\\mathrm{e}} + \\Delta\\varepsilon - \\Delta\\varepsilon^{\\mathrm{p}}) = \\sigma_n + E\\Delta\\varepsilon - E\\Delta\\varepsilon^{\\mathrm{p}} $$\nRecognizing the trial stress term $\\sigma_{n+1}^{\\mathrm{trial}} = \\sigma_n + E \\Delta \\varepsilon$, we have:\n$$ \\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{trial}} - E \\Delta\\varepsilon^{\\mathrm{p}} $$\nSubstituting the flow rule:\n$$ \\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{trial}} - E \\Delta\\gamma \\, \\operatorname{sgn}(\\sigma_{n+1}) $$\nThis equation shows that the final stress $\\sigma_{n+1}$ is obtained by \"returning\" from the trial stress $\\sigma_{n+1}^{\\mathrm{trial}}$. For a plastic step, the final state must lie on the expanded yield surface, satisfying the consistency condition $f(\\sigma_{n+1}, \\alpha_{n+1}) = 0$:\n$$ |\\sigma_{n+1}| - (\\sigma_{y0} + H \\alpha_{n+1}) = 0 $$\nSubstituting the hardening law $\\alpha_{n+1} = \\alpha_n + \\Delta\\gamma$:\n$$ |\\sigma_{n+1}| = \\sigma_{y0} + H(\\alpha_n + \\Delta\\gamma) = (\\sigma_{y0} + H\\alpha_n) + H\\Delta\\gamma $$\n\nWe now have a system of two equations to solve for the two unknowns, $\\sigma_{n+1}$ and $\\Delta\\gamma$. A key observation is that the return path does not change the sign of the stress, so $\\operatorname{sgn}(\\sigma_{n+1}) = \\operatorname{sgn}(\\sigma_{n+1}^{\\mathrm{trial}})$. Taking the absolute value of the stress return equation (and noting $|\\operatorname{sgn}(\\sigma_{n+1})| = 1$):\n$$ |\\sigma_{n+1}| = |\\sigma_{n+1}^{\\mathrm{trial}} - E \\Delta\\gamma \\, \\operatorname{sgn}(\\sigma_{n+1})| = |\\sigma_{n+1}^{\\mathrm{trial}}| - E \\Delta\\gamma $$\nEquating this with the yield condition:\n$$ |\\sigma_{n+1}^{\\mathrm{trial}}| - E \\Delta\\gamma = (\\sigma_{y0} + H\\alpha_n) + H\\Delta\\gamma $$\nSolving for $\\Delta\\gamma$:\n$$ |\\sigma_{n+1}^{\\mathrm{trial}}| - (\\sigma_{y0} + H\\alpha_n) = (E+H)\\Delta\\gamma $$\nThe term on the left is precisely the trial yield function value, $f^{\\mathrm{trial}}$. Thus, the plastic multiplier is determined as:\n$$ \\Delta\\gamma = \\frac{f^{\\mathrm{trial}}}{E+H} $$\nSince we are in the plastic case, $f^{\\mathrm{trial}}  0$. As $E > 0$ and $H \\ge 0$, it follows that $\\Delta\\gamma > 0$, consistent with its definition.\n\nWith $\\Delta\\gamma$ known, the final state variables can be computed.\nThe updated stress is:\n$$ \\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{trial}} - E \\Delta\\gamma \\, \\operatorname{sgn}(\\sigma_{n+1}^{\\mathrm{trial}}) $$\nThe updated hardening variable is:\n$$ \\alpha_{n+1} = \\alpha_n + \\Delta\\gamma $$\n\n**Summary of the Algorithm**\nFor a given state $(\\sigma_n, \\alpha_n)$, material parameters $(E, \\sigma_{y0}, H)$, and strain increment $\\Delta \\varepsilon$:\n1.  Compute the trial stress: $\\sigma_{n+1}^{\\mathrm{trial}} = \\sigma_n + E \\Delta \\varepsilon$.\n2.  Compute the yield stress at the start of the increment: $\\sigma_y(\\alpha_n) = \\sigma_{y0} + H \\alpha_n$.\n3.  Check for yielding by evaluating the trial yield function: $f^{\\mathrm{trial}} = |\\sigma_{n+1}^{\\mathrm{trial}}| - \\sigma_y(\\alpha_n)$.\n4.  If $f^{\\mathrm{trial}} \\le 0$ (elastic step):\n    -   $\\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{trial}}$\n    -   $\\alpha_{n+1} = \\alpha_n$\n5.  If $f^{\\mathrm{trial}}  0$ (plastic step):\n    -   Compute the plastic multiplier: $\\Delta\\gamma = f^{\\mathrm{trial}} / (E+H)$.\n    -   Update the stress: $\\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{trial}} - E \\Delta\\gamma \\operatorname{sgn}(\\sigma_{n+1}^{\\mathrm{trial}})$.\n    -   Update the hardening variable: $\\alpha_{n+1} = \\alpha_n + \\Delta\\gamma$.\nThis algorithm is implemented to evaluate the provided test suite.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the updated Cauchy stress for a series of uniaxial elastoplastic\n    test cases using a 1D radial return mapping algorithm.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary of parameters.\n    test_cases = [\n        # Case 1 (elastic loading)\n        {\"E\": 210e9, \"sigma_y0\": 250e6, \"H\": 1e9, \"sigma_n\": 200e6, \"alpha_n\": 0, \"delta_eps\": 1e-4},\n        # Case 2 (onset of yielding)\n        {\"E\": 210e9, \"sigma_y0\": 250e6, \"H\": 1e9, \"sigma_n\": 200e6, \"alpha_n\": 0, \"delta_eps\": 50e6 / 210e9},\n        # Case 3 (plastic loading with hardening)\n        {\"E\": 210e9, \"sigma_y0\": 250e6, \"H\": 1e9, \"sigma_n\": 200e6, \"alpha_n\": 0, \"delta_eps\": 5e-4},\n        # Case 4 (perfect plasticity limit)\n        {\"E\": 210e9, \"sigma_y0\": 250e6, \"H\": 0, \"sigma_n\": 200e6, \"alpha_n\": 0, \"delta_eps\": 5e-4},\n        # Case 5 (elastic reverse loading after hardening)\n        {\"E\": 210e9, \"sigma_y0\": 250e6, \"H\": 2e9, \"sigma_n\": 260e6, \"alpha_n\": 1e-2, \"delta_eps\": -1e-4},\n        # Case 6 (plastic compression)\n        {\"E\": 210e9, \"sigma_y0\": 250e6, \"H\": 1e9, \"sigma_n\": 0, \"alpha_n\": 0, \"delta_eps\": -2e-3},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current case\n        E = case[\"E\"]\n        sigma_y0 = case[\"sigma_y0\"]\n        H = case[\"H\"]\n        sigma_n = case[\"sigma_n\"]\n        alpha_n = case[\"alpha_n\"]\n        delta_eps = case[\"delta_eps\"]\n\n        # Step 1: Elastic Trial Step\n        # Compute the trial stress\n        sigma_trial = sigma_n + E * delta_eps\n\n        # Step 2: Yield Check\n        # Compute the current yield stress based on the state at step n\n        sigma_y_n = sigma_y0 + H * alpha_n\n        \n        # Evaluate the yield function at the trial state\n        f_trial = abs(sigma_trial) - sigma_y_n\n\n        # Step 3  4: Determine Final State (Elastic or Plastic)\n        if f_trial = 0:\n            # Elastic step: The trial state is the final state.\n            sigma_np1 = sigma_trial\n            # alpha_np1 = alpha_n # No change in hardening variable\n        else:\n            # Plastic step: Apply plastic corrector (radial return)\n            # The denominator (E+H) can be zero if E=-H, which is not physically\n            # realistic for this model. For H=0 (perfect plasticity), E+H=E > 0.\n            # Handle the case where H is zero to prevent division by zero if E were zero.\n            # However, E > 0 is a physical requirement for elastic materials.\n            if E + H = 0:\n                raise ValueError(\"E + H must be positive.\")\n\n            # Calculate the plastic multiplier increment\n            delta_gamma = f_trial / (E + H)\n\n            # Update stress using the radial return formula\n            sigma_np1 = sigma_trial - E * delta_gamma * np.sign(sigma_trial)\n            \n            # Update the hardening variable\n            # alpha_np1 = alpha_n + delta_gamma\n\n        # Round the final stress to six decimal places as required\n        rounded_result = round(sigma_np1, 6)\n        results.append(rounded_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real materials are rarely homogeneous; their properties vary spatially due to microstructural features like grain boundaries and dislocation patterns. A central question in multiscale modeling is determining the smallest volume that statistically represents the behavior of the bulk material—the Representative Volume Element (RVE). This computational exercise guides you through a standard procedure to determine the RVE size by generating virtual microstructures and analyzing the statistical convergence of the homogenized mechanical response . This practice provides a crucial link between microstructural detail and continuum-level simulation.",
            "id": "3825950",
            "problem": "You are tasked with constructing a computational procedure to determine the size of a Representative Volume Element (RVE) for plasticity by quantifying how the variance of a homogenized response decreases as the sampled volume size increases, using multiple microstructure realizations. The setting is a two-dimensional domain with scalar elastoplastic behavior under uniaxial strain, with local plastic yield governed by a dislocation-based law. The fundamental base consists of Hooke’s law for linear elasticity, a linear isotropic hardening rule, the Taylor dislocation strengthening relation, and standard homogenization definitions.\n\nBegin from the following principles and definitions:\n- Hooke’s law (linear elastic, one-dimensional): for local strain $\\,\\varepsilon\\,$ and local elastic modulus $\\,E\\,$, the local stress $\\,\\sigma\\,$ is $\\,\\sigma = E\\,\\varepsilon\\,$ until yielding.\n- Linear isotropic hardening: after yielding, the local stress evolves as $\\,\\sigma = \\sigma_y + H\\left(\\varepsilon - \\sigma_y / E\\right)\\,$, where $\\,H\\,$ is the constant plastic tangent modulus and $\\,\\sigma_y\\,$ is the local yield stress.\n- Taylor dislocation strengthening relation: the local yield stress is $\\,\\sigma_y = \\alpha\\,G\\,b\\,\\sqrt{\\rho}\\,$, where $\\,\\alpha\\,$ is a dimensionless constant, $\\,G\\,$ is the shear modulus, $\\,b\\,$ is the magnitude of the Burgers vector, and $\\,\\rho\\,$ is the local dislocation density.\n- Voigt homogenization (uniform strain assumption): the macroscopic stress $\\,\\bar{\\sigma}\\,$ at imposed macroscopic strain $\\,\\bar{\\varepsilon}\\,$ is the spatial average of local stresses, $\\,\\bar{\\sigma} = \\langle \\sigma \\rangle\\,$.\n- Representative Volume Element (RVE): the smallest domain size $\\,L\\,$ such that the coefficient of variation of the homogenized response over independent microstructure realizations falls below a prescribed tolerance $\\,\\epsilon_{\\mathrm{tol}}\\,$, i.e., $\\,\\mathrm{COV}(L) = s(L)/m(L) \\le \\epsilon_{\\mathrm{tol}}\\,$, where $\\,m(L)\\,$ and $\\,s(L)\\,$ are the sample mean and sample standard deviation (with $\\,\\mathrm{ddof}=1\\,$) of $\\,\\bar{\\sigma}\\,$ across realizations for the given domain size $\\,L\\,$.\n\nMicrostructure model:\n- The local dislocation density $\\,\\rho(\\mathbf{x})\\,$ is modeled as a stationary lognormal random field derived from a correlated Gaussian field $\\,g(\\mathbf{x})\\sim\\mathcal{N}(0,1)\\,$ with Gaussian covariance of correlation length $\\,\\ell\\,$. Let $\\,\\rho(\\mathbf{x}) = \\rho_0\\,\\exp\\!\\left(\\sigma_g\\,g(\\mathbf{x}) - \\tfrac{1}{2}\\sigma_g^2 \\right)\\,$, so that $\\,\\mathbb{E}[\\rho] = \\rho_0\\,$. The correlated Gaussian field is generated by spectral filtering of white noise using a Gaussian filter in wavenumber space of width $\\,\\ell\\,$.\n\nLocal constitutive response under imposed macroscopic strain $\\,\\bar{\\varepsilon}\\,$:\n- For each cell with local $\\,\\sigma_y\\,$, compute $\\,\\varepsilon_y = \\sigma_y / E\\,$. Then the local stress is\n$$\n\\sigma(\\mathbf{x};\\bar{\\varepsilon}) = \n\\begin{cases}\nE\\,\\bar{\\varepsilon},  \\bar{\\varepsilon} \\le \\varepsilon_y(\\mathbf{x}),\\\\\n\\sigma_y(\\mathbf{x}) + H\\big(\\bar{\\varepsilon} - \\varepsilon_y(\\mathbf{x})\\big),  \\bar{\\varepsilon} > \\varepsilon_y(\\mathbf{x}).\n\\end{cases}\n$$\nThe macroscopic stress is the spatial average $\\,\\bar{\\sigma} = \\langle \\sigma(\\mathbf{x};\\bar{\\varepsilon}) \\rangle\\,$.\n\nComputational procedure:\n- For each candidate domain size $\\,L\\,$ (square domain of side length), discretize uniformly into a grid with spacing $\\,\\Delta x\\,$, so there are $\\,N = \\lfloor L / \\Delta x \\rfloor\\,$ cells per side. For each realization:\n    1. Generate a correlated Gaussian field $\\,g(\\mathbf{x})\\,$ using spectral filtering of white noise by multiplying its discrete Fourier transform by $\\,\\exp\\!\\big(-\\tfrac{1}{2}\\ell^2\\,\\|\\mathbf{k}\\|^2\\big)\\,$, where $\\,\\mathbf{k}\\,$ is the wavenumber vector and $\\,\\ell\\,$ is in the same length units as $\\,\\Delta x\\,$.\n    2. Construct the dislocation density $\\,\\rho(\\mathbf{x})\\,$ via the lognormal mapping above.\n    3. Compute $\\,\\sigma_y(\\mathbf{x}) = \\alpha\\,G\\,b\\,\\sqrt{\\rho(\\mathbf{x})}\\,$.\n    4. Compute $\\,\\bar{\\sigma}\\,$ by averaging local stresses under $\\,\\bar{\\varepsilon}\\,$ using the piecewise linear rule with $\\,E\\,$ and $\\,H\\,$.\n- Over $\\,n_{\\mathrm{real}}\\,$ realizations, compute the sample mean $\\,m(L)\\,$ and sample standard deviation $\\,s(L)\\,$ and form $\\,\\mathrm{COV}(L) = s(L)/m(L)\\,$.\n- The RVE size is the smallest $\\,L\\,$ in the provided candidate list such that $\\,\\mathrm{COV}(L) \\le \\epsilon_{\\mathrm{tol}}\\,$. If no candidate size satisfies the criterion, return $-1$.\n\nPhysical units and output:\n- Use Pascals (Pa) internally for stress calculations, but report the RVE size in micrometers ($\\mu$m). Strain $\\,\\bar{\\varepsilon}\\,$ is dimensionless. The Burgers vector $\\,b\\,$ must be provided in nanometers (nm) and converted to meters (m). The shear modulus $\\,G\\,$, elastic modulus $\\,E\\,$, and hardening modulus $\\,H\\,$ are provided in gigapascals (GPa) and converted to Pascals (Pa) for computation.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\text{result1},\\text{result2},\\text{result3}]$. Each result must be the selected RVE size in $\\mu$m as a floating-point number, or the integer $-1$ if no candidate size meets the tolerance.\n\nTest suite:\nEvaluate the following four test cases. Each test case is given as an ordered tuple of parameters with units specified. The program must embed these parameters and produce the required outputs.\n\n- Test case 1 (typical heterogeneity, moderate correlation):\n    - $\\,\\Delta x = 1.0\\,\\mu\\mathrm{m}\\,$,\n    - $\\,\\ell = 2.0\\,\\mu\\mathrm{m}\\,$,\n    - $\\,\\sigma_g = 0.5\\,$,\n    - $\\,\\rho_0 = 1.0\\times 10^{14}\\,\\mathrm{m}^{-2}\\,$,\n    - $\\,\\alpha = 0.3\\,$,\n    - $\\,G = 26.0\\,\\mathrm{GPa}\\,$,\n    - $\\,b = 0.286\\,\\mathrm{nm}\\,$,\n    - $\\,E = 70.0\\,\\mathrm{GPa}\\,$,\n    - $\\,H = 1.0\\,\\mathrm{GPa}\\,$,\n    - $\\,\\bar{\\varepsilon} = 0.005\\,$,\n    - Candidate sizes $\\,L \\in [5.0,\\,10.0,\\,20.0,\\,40.0]\\,\\mu\\mathrm{m}\\,$,\n    - $\\,n_{\\mathrm{real}} = 20\\,$,\n    - $\\,\\epsilon_{\\mathrm{tol}} = 0.02\\,$,\n    - Random seed $\\,s = 12345\\,$.\n\n- Test case 2 (stronger heterogeneity, large correlation):\n    - $\\,\\Delta x = 2.0\\,\\mu\\mathrm{m}\\,$,\n    - $\\,\\ell = 10.0\\,\\mu\\mathrm{m}\\,$,\n    - $\\,\\sigma_g = 0.8\\,$,\n    - $\\,\\rho_0 = 1.0\\times 10^{14}\\,\\mathrm{m}^{-2}\\,$,\n    - $\\,\\alpha = 0.3\\,$,\n    - $\\,G = 26.0\\,\\mathrm{GPa}\\,$,\n    - $\\,b = 0.286\\,\\mathrm{nm}\\,$,\n    - $\\,E = 70.0\\,\\mathrm{GPa}\\,$,\n    - $\\,H = 2.0\\,\\mathrm{GPa}\\,$,\n    - $\\,\\bar{\\varepsilon} = 0.005\\,$,\n    - Candidate sizes $\\,L \\in [20.0,\\,40.0,\\,80.0]\\,\\mu\\mathrm{m}\\,$,\n    - $\\,n_{\\mathrm{real}} = 30\\,$,\n    - $\\,\\epsilon_{\\mathrm{tol}} = 0.03\\,$,\n    - Random seed $\\,s = 2468\\,$.\n\n- Test case 3 (strict tolerance, limited realizations; potential failure to meet criterion):\n    - $\\,\\Delta x = 1.0\\,\\mu\\mathrm{m}\\,$,\n    - $\\,\\ell = 5.0\\,\\mu\\mathrm{m}\\,$,\n    - $\\,\\sigma_g = 0.9\\,$,\n    - $\\,\\rho_0 = 1.0\\times 10^{14}\\,\\mathrm{m}^{-2}\\,$,\n    - $\\,\\alpha = 0.3\\,$,\n    - $\\,G = 26.0\\,\\mathrm{GPa}\\,$,\n    - $\\,b = 0.286\\,\\mathrm{nm}\\,$,\n    - $\\,E = 70.0\\,\\mathrm{GPa}\\,$,\n    - $\\,H = 1.5\\,\\mathrm{GPa}\\,$,\n    - $\\,\\bar{\\varepsilon} = 0.005\\,$,\n    - Candidate sizes $\\,L \\in [5.0,\\,10.0,\\,15.0]\\,\\mu\\mathrm{m}\\,$,\n    - $\\,n_{\\mathrm{real}} = 10\\,$,\n    - $\\,\\epsilon_{\\mathrm{tol}} = 0.01\\,$,\n    - Random seed $\\,s = 13579\\,$.\n\n- Test case 4 (weak heterogeneity, short correlation):\n    - $\\,\\Delta x = 0.5\\,\\mu\\mathrm{m}\\,$,\n    - $\\,\\ell = 0.5\\,\\mu\\mathrm{m}\\,$,\n    - $\\,\\sigma_g = 0.4\\,$,\n    - $\\,\\rho_0 = 1.0\\times 10^{14}\\,\\mathrm{m}^{-2}\\,$,\n    - $\\,\\alpha = 0.3\\,$,\n    - $\\,G = 26.0\\,\\mathrm{GPa}\\,$,\n    - $\\,b = 0.286\\,\\mathrm{nm}\\,$,\n    - $\\,E = 70.0\\,\\mathrm{GPa}\\,$,\n    - $\\,H = 1.0\\,\\mathrm{GPa}\\,$,\n    - $\\,\\bar{\\varepsilon} = 0.005\\,$,\n    - Candidate sizes $\\,L \\in [2.0,\\,4.0,\\,8.0]\\,\\mu\\mathrm{m}\\,$,\n    - $\\,n_{\\mathrm{real}} = 25\\,$,\n    - $\\,\\epsilon_{\\mathrm{tol}} = 0.02\\,$,\n    - Random seed $\\,s = 9876\\,$.\n\nYour program must implement the above procedure exactly and return the selected RVE size for each of the four test cases in a single-line output formatted as $[r_1,r_2,r_3,r_4]$, where each $\\,r_i\\,$ is a floating-point number in $\\mu$m or the integer $-1$ if the criterion is not satisfied by any candidate.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of continuum mechanics and computational materials science, is well-posed with a clear objective and a complete set of parameters, and uses objective, formal language. The procedure to determine the Representative Volume Element (RVE) size is a standard methodology in multiscale modeling.\n\nThe solution is constructed by implementing a computational procedure that simulates the mechanical response of a spatially heterogeneous material and analyzes the statistical convergence of its homogenized properties. The core objective is to find the smallest domain size, the RVE, for which the material's effective response is statistically representative. This is quantified by requiring the coefficient of variation (COV) of the homogenized stress across multiple independent microstructure realizations to be below a prescribed tolerance $\\epsilon_{\\mathrm{tol}}$.\n\nThe fundamental steps of the procedure are as follows:\n\n1.  **Modeling Material Heterogeneity:** The source of heterogeneity is the local plastic yield stress, $\\sigma_y(\\mathbf{x})$, which varies spatially. This variation is physically rooted in the non-uniform distribution of crystal defects, specifically dislocations. The local yield stress is governed by the Taylor dislocation strengthening relation:\n    $$\n    \\sigma_y(\\mathbf{x}) = \\alpha G b \\sqrt{\\rho(\\mathbf{x})}\n    $$\n    where $\\alpha$ is a geometric constant, $G$ is the shear modulus, $b$ is the magnitude of the Burgers vector, and $\\rho(\\mathbf{x})$ is the local dislocation density. The dislocation density itself is modeled as a stationary lognormal random field. This choice ensures $\\rho(\\mathbf{x})$ is always positive. A specific form is used:\n    $$\n    \\rho(\\mathbf{x}) = \\rho_0 \\exp\\left(\\sigma_g g(\\mathbf{x}) - \\frac{1}{2}\\sigma_g^2\\right)\n    $$\n    Here, $g(\\mathbf{x})$ is a standardized, correlated Gaussian random field with zero mean and unit variance, $g(\\mathbf{x}) \\sim \\mathcal{N}(0,1)$. The parameter $\\sigma_g$ controls the magnitude of fluctuations, and the form of the expression is chosen such that the expected value of the dislocation density is $\\mathbb{E}[\\rho] = \\rho_0$.\n\n2.  **Generating Correlated Random Fields:** The spatially correlated Gaussian field $g(\\mathbf{x})$ is generated numerically using a spectral method. This standard technique involves filtering white noise in the Fourier (wavenumber) domain.\n    - A grid of uncorrelated random numbers drawn from a standard normal distribution is generated in the spatial domain. This represents white noise.\n    - This grid is transformed into the wavenumber domain using a 2D Fast Fourier Transform (FFT).\n    - In this domain, a multiplicative Gaussian filter is applied:\n      $$\n      F(\\mathbf{k}) = \\exp\\left(-\\frac{1}{2}\\ell^2 \\|\\mathbf{k}\\|^2\\right)\n      $$\n      where $\\mathbf{k}$ is the wavenumber vector and $\\ell$ is the correlation length, which dictates the characteristic size of the microstructure features.\n    - The filtered field is transformed back to the spatial domain using an inverse FFT. The real part of the result is taken.\n    - To ensure the field correctly represents a realization of $g(\\mathbf{x}) \\sim \\mathcal{N}(0,1)$, its values are empirically standardized by subtracting the sample mean and dividing by the sample standard deviation.\n\n3.  **Constitutive Response and Homogenization:** The material's overall behavior is determined by assuming a uniform strain field (Voigt homogenization), where every point in the domain is subjected to the same macroscopic strain, $\\bar{\\varepsilon}$. The local stress $\\sigma(\\mathbf{x})$ is then computed based on a piecewise linear constitutive law.\n    - First, the local elastic strain limit is found: $\\varepsilon_y(\\mathbf{x}) = \\sigma_y(\\mathbf{x}) / E$, where $E$ is the elastic modulus.\n    - If the imposed strain $\\bar{\\varepsilon}$ is less than or equal to the local yield strain, the response is purely elastic (Hooke's Law): $\\sigma(\\mathbf{x}) = E \\bar{\\varepsilon}$.\n    - If the imposed strain exceeds the local yield strain, the material at that point deforms plastically, and the stress is given by a linear isotropic hardening rule: $\\sigma(\\mathbf{x}) = \\sigma_y(\\mathbf{x}) + H(\\bar{\\varepsilon} - \\varepsilon_y(\\mathbf{x}))$, where $H$ is the plastic tangent modulus.\n    - The macroscopic stress, $\\bar{\\sigma}$, is the volume average of the local stress field:\n      $$\n      \\bar{\\sigma} = \\langle \\sigma(\\mathbf{x}; \\bar{\\varepsilon}) \\rangle = \\frac{1}{V} \\int_V \\sigma(\\mathbf{x}; \\bar{\\varepsilon}) \\, dV\n      $$\n      For a discrete grid, this integral becomes a simple arithmetic mean.\n\n4.  **RVE Determination via Statistical Analysis:** The RVE size is determined by evaluating the statistical stability of $\\bar{\\sigma}$ as a function of the domain size $L$.\n    - For each candidate size $L$ from a given list, the domain is discretized into a grid of $N \\times N$ cells, where $N = \\lfloor L / \\Delta x \\rfloor$ and $\\Delta x$ is the fixed grid spacing.\n    - A set of $n_{\\mathrm{real}}$ independent microstructure realizations is generated. For each realization, the corresponding macroscopic stress $\\bar{\\sigma}$ is calculated as described above.\n    - This provides a sample of $n_{\\mathrm{real}}$ values of $\\bar{\\sigma}$ for the domain size $L$. The sample mean $m(L)$ and sample standard deviation $s(L)$ (using a divisor of $n_{\\mathrm{real}}-1$, or $\\mathrm{ddof}=1$) are computed.\n    - The coefficient of variation is calculated: $\\mathrm{COV}(L) = s(L)/m(L)$.\n    - The RVE size is identified as the smallest candidate size $L$ in the list for which $\\mathrm{COV}(L) \\le \\epsilon_{\\mathrm{tol}}$. If no candidate size meets this criterion, it is concluded that an RVE size has not been reached within the tested range.\n\nAll physical quantities with units (moduli, lengths) are converted to a consistent SI base unit system (Pascals, meters) before computation to ensure correctness. The final reported RVE size is converted back to the specified unit of micrometers. The use of a fixed random seed for each test case ensures the computational reproducibility of the results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_single_realization_stress(L, dx, ell, sigma_g, rho_0, alpha, G, b, E, H, bar_epsilon, rng):\n    \"\"\"\n    Computes the homogenized stress for a single microstructure realization.\n    All length units are handled in micrometers for grid setup and passed as SI for calculation.\n    All stress/modulus units are handled in GPa and passed as SI for calculation.\n    \"\"\"\n    # 1. Unit conversions to base SI\n    L_m = L * 1e-6\n    dx_m = dx * 1e-6\n    ell_m = ell * 1e-6\n    G_pa = G * 1e9\n    b_m = b * 1e-9\n    E_pa = E * 1e9\n    H_pa = H * 1e9\n\n    # 2. Grid setup\n    N = int(np.floor(L / dx))\n    if N == 0:\n        return np.nan\n\n    # 3. Generate correlated Gaussian random field g(x)\n    # 3a. Wavenumber grid\n    freq = np.fft.fftfreq(N, d=dx_m)  # Frequencies in cycles/meter\n    kx_grid, ky_grid = np.meshgrid(freq, freq)\n    k_grid_sq = (2 * np.pi * kx_grid)**2 + (2 * np.pi * ky_grid)**2\n\n    # 3b. Gaussian filter in Fourier space\n    gaussian_filter = np.exp(-0.5 * (ell_m**2) * k_grid_sq)\n    \n    # 3c. Generate field from white noise\n    white_noise = rng.standard_normal(size=(N, N))\n    fft_white_noise = np.fft.fft2(white_noise)\n    \n    fft_filtered = fft_white_noise * gaussian_filter\n    g_field_raw = np.fft.ifft2(fft_filtered).real\n\n    # 3d. Normalize the field to have zero mean and unit variance\n    g_field_mean = np.mean(g_field_raw)\n    g_field_std = np.std(g_field_raw)\n    if g_field_std  1e-15:\n        g_field = np.zeros((N, N))\n    else:\n        g_field = (g_field_raw - g_field_mean) / g_field_std\n\n    # 4. Construct dislocation density field rho(x) via lognormal mapping\n    rho_field = rho_0 * np.exp(sigma_g * g_field - 0.5 * sigma_g**2)\n\n    # 5. Compute local yield stress field sigma_y(x) using Taylor relation\n    sigma_y_field = alpha * G_pa * b_m * np.sqrt(rho_field)\n\n    # 6. Compute local stress sigma(x) under imposed strain bar_epsilon\n    epsilon_y_field = sigma_y_field / E_pa\n    \n    sigma_field = np.where(bar_epsilon = epsilon_y_field,\n                           E_pa * bar_epsilon,\n                           sigma_y_field + H_pa * (bar_epsilon - epsilon_y_field))\n\n    # 7. Compute homogenized stress (Voigt average)\n    bar_sigma = np.mean(sigma_field)\n    \n    return bar_sigma\n\ndef find_rve_size(params):\n    \"\"\"\n    Finds the RVE size for a single test case by iterating through candidate sizes.\n    \"\"\"\n    (dx, ell, sigma_g, rho_0, alpha, G, b, E, H, \n     bar_epsilon, L_candidates, n_real, epsilon_tol, seed) = params\n    \n    rng = np.random.default_rng(seed)\n\n    for L in L_candidates:\n        homogenized_stresses = []\n        for _ in range(n_real):\n            bar_sigma = compute_single_realization_stress(\n                L, dx, ell, sigma_g, rho_0, alpha, G, b, E, H, bar_epsilon, rng\n            )\n            homogenized_stresses.append(bar_sigma)\n        \n        homogenized_stresses = np.array(homogenized_stresses)\n        \n        if np.isnan(homogenized_stresses).any():\n            continue\n            \n        # Compute sample mean and sample standard deviation (ddof=1)\n        m_L = np.mean(homogenized_stresses)\n        s_L = np.std(homogenized_stresses, ddof=1)\n        \n        cov_L = s_L / m_L if np.abs(m_L) > 1e-9 else np.inf\n        \n        if cov_L = epsilon_tol:\n            return float(L)\n            \n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the RVE analysis, and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {'dx': 1.0, 'ell': 2.0, 'sigma_g': 0.5, 'rho_0': 1.0e14, 'alpha': 0.3,\n         'G': 26.0, 'b': 0.286, 'E': 70.0, 'H': 1.0, 'bar_epsilon': 0.005,\n         'L_candidates': [5.0, 10.0, 20.0, 40.0], 'n_real': 20, 'epsilon_tol': 0.02,\n         'seed': 12345},\n        # Test case 2\n        {'dx': 2.0, 'ell': 10.0, 'sigma_g': 0.8, 'rho_0': 1.0e14, 'alpha': 0.3,\n         'G': 26.0, 'b': 0.286, 'E': 70.0, 'H': 2.0, 'bar_epsilon': 0.005,\n         'L_candidates': [20.0, 40.0, 80.0], 'n_real': 30, 'epsilon_tol': 0.03,\n         'seed': 2468},\n        # Test case 3\n        {'dx': 1.0, 'ell': 5.0, 'sigma_g': 0.9, 'rho_0': 1.0e14, 'alpha': 0.3,\n         'G': 26.0, 'b': 0.286, 'E': 70.0, 'H': 1.5, 'bar_epsilon': 0.005,\n         'L_candidates': [5.0, 10.0, 15.0], 'n_real': 10, 'epsilon_tol': 0.01,\n         'seed': 13579},\n        # Test case 4\n        {'dx': 0.5, 'ell': 0.5, 'sigma_g': 0.4, 'rho_0': 1.0e14, 'alpha': 0.3,\n         'G': 26.0, 'b': 0.286, 'E': 70.0, 'H': 1.0, 'bar_epsilon': 0.005,\n         'L_candidates': [2.0, 4.0, 8.0], 'n_real': 25, 'epsilon_tol': 0.02,\n         'seed': 9876},\n    ]\n\n    results = []\n    for case in test_cases:\n        params_tuple = (\n            case['dx'], case['ell'], case['sigma_g'], case['rho_0'], case['alpha'],\n            case['G'], case['b'], case['E'], case['H'], case['bar_epsilon'],\n            case['L_candidates'], case['n_real'], case['epsilon_tol'], case['seed']\n        )\n        result = find_rve_size(params_tuple)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}