{
    "hands_on_practices": [
        {
            "introduction": "This first exercise is foundational, designed to build your intuition for how quaternions operate algebraically and what this algebra represents geometrically. By deriving the Hamilton product of two quaternions from first principles, you will see exactly how the rules of rotation composition are encoded. This practice  is crucial for understanding why quaternions are a natural language for rotations, linking the abstract vector cross product term directly to the physical reality that the order of rotations matters.",
            "id": "3838903",
            "problem": "In multiscale materials simulation, the orientation of a mesoscale rigid inclusion (representing a coarse-grained cluster of atoms) is often updated by composing a pre-existing orientation with a small incremental rotation induced by microscale torques. A common representation of three-dimensional rotations is the quaternion formalism, where a quaternion is written as $q = q_{0} + q_{1}\\mathbf{i} + q_{2}\\mathbf{j} + q_{3}\\mathbf{k}$, or equivalently as a scalar-vector split $q = (q_{0}, \\mathbf{q})$ with $\\mathbf{q} = (q_{1}, q_{2}, q_{3}) \\in \\mathbb{R}^{3}$. The quaternion basis obeys Hamilton’s rules $\\mathbf{i}^{2} = \\mathbf{j}^{2} = \\mathbf{k}^{2} = \\mathbf{i}\\mathbf{j}\\mathbf{k} = -1$, and $\\mathbf{i}\\mathbf{j} = \\mathbf{k}$, $\\mathbf{j}\\mathbf{k} = \\mathbf{i}$, $\\mathbf{k}\\mathbf{i} = \\mathbf{j}$, together with anticommutation $\\mathbf{j}\\mathbf{i} = -\\mathbf{k}$, $\\mathbf{k}\\mathbf{j} = -\\mathbf{i}$, $\\mathbf{i}\\mathbf{k} = -\\mathbf{j}$.\n\nLet $p = (p_{0}, \\mathbf{p})$ denote a small incremental rotation (possibly derived from a microscale torque) and let $q = (q_{0}, \\mathbf{q})$ denote the current orientation of a rigid body at the mesoscale. Both $p$ and $q$ are unit quaternions representing elements of the Special Orthogonal Group $\\mathrm{SO}(3)$. The updated orientation is the quaternion product $r = p \\otimes q$, where $\\otimes$ denotes the Hamilton product.\n\nTask: Starting solely from the fundamental quaternion multiplication rules stated above, derive the scalar-vector split expression for $r = p \\otimes q$ in terms of $p_{0}$, $p_{1}$, $p_{2}$, $p_{3}$ and $q_{0}$, $q_{1}$, $q_{2}$, $q_{3}$, and express the components $(r_{0}, r_{1}, r_{2}, r_{3})$ as a single row matrix. Then, interpret the result geometrically in the context of rotation composition of a rigid body: explain what the scalar and vector parts encode about the sequential action of $p$ followed by $q$, and comment on how the structure of the vector part reflects the noncommutativity of three-dimensional rotations.\n\nYour final answer must be the derived analytical expression for $(r_{0}, r_{1}, r_{2}, r_{3})$ as a single row matrix. No rounding is required and no physical units are to be included in the final answer. Angles, if discussed in your interpretation, should be understood in radians.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the established principles of quaternion algebra and its application to rigid body dynamics. The problem is well-posed, objective, self-contained, and asks for a standard derivation and interpretation, which constitutes a valid test of fundamental understanding.\n\nThe task is to derive the components of the quaternion product $r = p \\otimes q$ and provide a geometric interpretation of the result. We are given two quaternions, $p = (p_{0}, \\mathbf{p})$ and $q = (q_{0}, \\mathbf{q})$, which we can write in their full algebraic form as:\n$$p = p_{0} + p_{1}\\mathbf{i} + p_{2}\\mathbf{j} + p_{3}\\mathbf{k}$$\n$$q = q_{0} + q_{1}\\mathbf{i} + q_{2}\\mathbf{j} + q_{3}\\mathbf{k}$$\nThe product $r = p \\otimes q$ is computed by applying the distributive property of multiplication over addition, starting solely from the provided Hamilton's rules: $\\mathbf{i}^{2} = \\mathbf{j}^{2} = \\mathbf{k}^{2} = \\mathbf{i}\\mathbf{j}\\mathbf{k} = -1$, and the cyclic/anticyclic relations for the basis vectors $\\mathbf{i}, \\mathbf{j}, \\mathbf{k}$.\n\nLet $r = r_{0} + r_{1}\\mathbf{i} + r_{2}\\mathbf{j} + r_{3}\\mathbf{k}$. The product $p \\otimes q$ is:\n$$r = (p_{0} + p_{1}\\mathbf{i} + p_{2}\\mathbf{j} + p_{3}\\mathbf{k}) \\otimes (q_{0} + q_{1}\\mathbf{i} + q_{2}\\mathbf{j} + q_{3}\\mathbf{k})$$\nWe expand this product term by term:\n$$r = p_{0}(q_{0} + q_{1}\\mathbf{i} + q_{2}\\mathbf{j} + q_{3}\\mathbf{k}) + p_{1}\\mathbf{i}(q_{0} + q_{1}\\mathbf{i} + q_{2}\\mathbf{j} + q_{3}\\mathbf{k}) + p_{2}\\mathbf{j}(q_{0} + q_{1}\\mathbf{i} + q_{2}\\mathbf{j} + q_{3}\\mathbf{k}) + p_{3}\\mathbf{k}(q_{0} + q_{1}\\mathbf{i} + q_{2}\\mathbf{j} + q_{3}\\mathbf{k})$$\nDistributing each term:\n$$r = (p_{0}q_{0} + p_{0}q_{1}\\mathbf{i} + p_{0}q_{2}\\mathbf{j} + p_{0}q_{3}\\mathbf{k})$$\n$$+ (p_{1}q_{0}\\mathbf{i} + p_{1}q_{1}\\mathbf{i}^{2} + p_{1}q_{2}\\mathbf{i}\\mathbf{j} + p_{1}q_{3}\\mathbf{i}\\mathbf{k})$$\n$$+ (p_{2}q_{0}\\mathbf{j} + p_{2}q_{1}\\mathbf{j}\\mathbf{i} + p_{2}q_{2}\\mathbf{j}^{2} + p_{2}q_{3}\\mathbf{j}\\mathbf{k})$$\n$$+ (p_{3}q_{0}\\mathbf{k} + p_{3}q_{1}\\mathbf{k}\\mathbf{i} + p_{3}q_{2}\\mathbf{k}\\mathbf{j} + p_{3}q_{3}\\mathbf{k}^{2})$$\nNow, we apply the Hamilton's rules to simplify the products of the basis vectors:\n$$r = (p_{0}q_{0} + p_{0}q_{1}\\mathbf{i} + p_{0}q_{2}\\mathbf{j} + p_{0}q_{3}\\mathbf{k})$$\n$$+ (p_{1}q_{0}\\mathbf{i} - p_{1}q_{1} + p_{1}q_{2}\\mathbf{k} - p_{1}q_{3}\\mathbf{j})$$\n$$+ (p_{2}q_{0}\\mathbf{j} - p_{2}q_{1}\\mathbf{k} - p_{2}q_{2} + p_{2}q_{3}\\mathbf{i})$$\n$$+ (p_{3}q_{0}\\mathbf{k} + p_{3}q_{1}\\mathbf{j} - p_{3}q_{2}\\mathbf{i} - p_{3}q_{3})$$\nThe next step is to collect the terms corresponding to the scalar part ($1$) and the vector parts ($\\mathbf{i}, \\mathbf{j}, \\mathbf{k}$).\n\nThe scalar component, $r_{0}$, is the sum of all terms without a vector basis element:\n$$r_{0} = p_{0}q_{0} - p_{1}q_{1} - p_{2}q_{2} - p_{3}q_{3}$$\nThis can be written compactly using the scalar-vector split notation $p = (p_{0}, \\mathbf{p})$ and $q = (q_{0}, \\mathbf{q})$, where $\\mathbf{p} = (p_{1}, p_{2}, p_{3})$ and $\\mathbf{q} = (q_{1}, q_{2}, q_{3})$. The expression for $r_{0}$ is equivalent to:\n$$r_{0} = p_{0}q_{0} - \\mathbf{p} \\cdot \\mathbf{q}$$\nwhere $\\mathbf{p} \\cdot \\mathbf{q}$ is the standard Euclidean dot product.\n\nThe coefficient of $\\mathbf{i}$, which is $r_{1}$, is:\n$$r_{1} = p_{0}q_{1} + p_{1}q_{0} + p_{2}q_{3} - p_{3}q_{2}$$\nThe coefficient of $\\mathbf{j}$, which is $r_{2}$, is:\n$$r_{2} = p_{0}q_{2} - p_{1}q_{3} + p_{2}q_{0} + p_{3}q_{1}$$\nThe coefficient of $\\mathbf{k}$, which is $r_{3}$, is:\n$$r_{3} = p_{0}q_{3} + p_{1}q_{2} - p_{2}q_{1} + p_{3}q_{0}$$\nWe can assemble the vector part of $r$, which is $\\mathbf{r} = (r_{1}, r_{2}, r_{3})$, and recognize its structure in terms of vector operations. Let's re-organize the terms for clarity:\n$$r_{1} = (p_{1}q_{0} + p_{0}q_{1}) + (p_{2}q_{3} - p_{3}q_{2})$$\n$$r_{2} = (p_{2}q_{0} + p_{0}q_{2}) + (p_{3}q_{1} - p_{1}q_{3})$$\n$$r_{3} = (p_{3}q_{0} + p_{0}q_{3}) + (p_{1}q_{2} - p_{2}q_{1})$$\nThe terms in the first parentheses correspond to the components of $q_{0}\\mathbf{p} + p_{0}\\mathbf{q}$. The terms in the second parentheses are the components of the cross product $\\mathbf{p} \\times \\mathbf{q}$. Therefore, the vector part $\\mathbf{r}$ can be written as:\n$$\\mathbf{r} = q_{0}\\mathbf{p} + p_{0}\\mathbf{q} + \\mathbf{p} \\times \\mathbf{q}$$\nCombining the scalar and vector parts, the quaternion product in scalar-vector form is:\n$$r = p \\otimes q = (p_{0}q_{0} - \\mathbf{p} \\cdot \\mathbf{q}, \\quad q_{0}\\mathbf{p} + p_{0}\\mathbf{q} + \\mathbf{p} \\times \\mathbf{q})$$\nThe components $(r_{0}, r_{1}, r_{2}, r_{3})$ are thus identified.\n\nNow for the geometric interpretation. The quaternions $p$ and $q$ are unit quaternions representing rotations. The product $r = p \\otimes q$ represents the composite rotation obtained by first applying the rotation $q$ and then applying the rotation $p$.\nA unit quaternion $q$ that represents a rotation by an angle $\\theta_{q}$ about a unit axis vector $\\mathbf{u}_{q}$ is given by $q = (\\cos(\\theta_{q}/2), \\sin(\\theta_{q}/2)\\mathbf{u}_{q})$. Thus, $q_{0} = \\cos(\\theta_{q}/2)$ and the vector part is $\\mathbf{q} = \\sin(\\theta_{q}/2)\\mathbf{u}_{q}$. A similar representation holds for $p$ with angle $\\theta_{p}$ and axis $\\mathbf{u}_{p}$.\n\nThe scalar part of the composite quaternion, $r_{0} = \\cos(\\theta_{r}/2)$, is:\n$$r_{0} = p_{0}q_{0} - \\mathbf{p} \\cdot \\mathbf{q} = \\cos(\\frac{\\theta_{p}}{2})\\cos(\\frac{\\theta_{q}}{2}) - (\\sin(\\frac{\\theta_{p}}{2})\\mathbf{u}_{p}) \\cdot (\\sin(\\frac{\\theta_{q}}{2})\\mathbf{u}_{q})$$\n$$r_{0} = \\cos(\\frac{\\theta_{p}}{2})\\cos(\\frac{\\theta_{q}}{2}) - \\sin(\\frac{\\theta_{p}}{2})\\sin(\\frac{\\theta_{q}}{2})(\\mathbf{u}_{p} \\cdot \\mathbf{u}_{q})$$\nThis expression, which is a form of the spherical law of cosines, determines the angle $\\theta_{r}$ of the composite rotation. It shows that the resulting angle depends not only on the individual rotation angles $\\theta_{p}$ and $\\theta_{q}$ but also on the relative orientation of their axes, captured by the dot product $\\mathbf{u}_{p} \\cdot \\mathbf{u}_{q}$.\n\nThe vector part, $\\mathbf{r} = \\sin(\\theta_{r}/2)\\mathbf{u}_{r}$, which is $\\mathbf{r} = q_{0}\\mathbf{p} + p_{0}\\mathbf{q} + \\mathbf{p} \\times \\mathbf{q}$, determines the axis $\\mathbf{u}_{r}$ and magnitude $\\sin(\\theta_{r}/2)$ of the composite rotation. The structure of this vector part explicitly demonstrates the noncommutativity of three-dimensional rotations. To see this, consider the product in the reverse order, $q \\otimes p$. The resulting scalar part would be $q_{0}p_{0} - \\mathbf{q} \\cdot \\mathbf{p}$, which is identical to that of $p \\otimes q$ because both scalar multiplication and the dot product are commutative. This means the magnitude of the composite rotation angle, $|\\theta_r|$, is the same regardless of the order of application. However, the vector part of $q \\otimes p$ would be:\n$$\\mathbf{r}' = p_{0}\\mathbf{q} + q_{0}\\mathbf{p} + \\mathbf{q} \\times \\mathbf{p}$$\nComparing this to the vector part of $p \\otimes q$, $\\mathbf{r} = q_{0}\\mathbf{p} + p_{0}\\mathbf{q} + \\mathbf{p} \\times \\mathbf{q}$, we see a difference. Since the cross product is anticommutative, $\\mathbf{q} \\times \\mathbf{p} = -(\\mathbf{p} \\times \\mathbf{q})$. The two vector parts, $\\mathbf{r}$ and $\\mathbf{r}'$, are generally different unless $\\mathbf{p} \\times \\mathbf{q} = \\mathbf{0}$, which only occurs if the rotation axes are parallel ($\\mathbf{u}_{p}$ and $\\mathbf{u}_{q}$ are collinear). The term $\\mathbf{p} \\times \\mathbf{q}$ is therefore the source of noncommutativity in the quaternion product. Swapping the order of multiplication flips the sign of this term, leading to a different vector part, which corresponds to a different composite rotation axis. This algebraic property of quaternion multiplication accurately reflects the fundamental geometric property that finite rotations in three dimensions do not commute.\n\nThe final requested analytical expression for $(r_{0}, r_{1}, r_{2}, r_{3})$ as a single row matrix is constructed from the component expressions derived above.\n$r_{0} = p_{0}q_{0} - p_{1}q_{1} - p_{2}q_{2} - p_{3}q_{3}$\n$r_{1} = p_{1}q_{0} + p_{0}q_{1} + p_{2}q_{3} - p_{3}q_{2}$\n$r_{2} = p_{2}q_{0} + p_{0}q_{2} + p_{3}q_{1} - p_{1}q_{3}$\n$r_{3} = p_{3}q_{0} + p_{0}q_{3} + p_{1}q_{2} - p_{2}q_{1}$\nReordering terms for the final answer to match the order of indices as conventionally presented:\n$r_{1} = p_{0}q_{1} + p_{1}q_{0} + p_{2}q_{3} - p_{3}q_{2}$\n$r_{2} = p_{0}q_{2} - p_{1}q_{3} + p_{2}q_{0} + p_{3}q_{1}$\n$r_{3} = p_{0}q_{3} + p_{1}q_{2} - p_{2}q_{1} + p_{3}q_{0}$\nThe terms are the same, just written in a different order. Both are correct. Let's use a systematic ordering for the final answer.\n\n$r_{0} = p_{0}q_{0} - p_{1}q_{1} - p_{2}q_{2} - p_{3}q_{3}$\n$r_{1} = p_{0}q_{1} + p_{1}q_{0} + p_{2}q_{3} - p_{3}q_{2}$\n$r_{2} = p_{0}q_{2} + p_{2}q_{0} + p_{3}q_{1} - p_{1}q_{3}$\n$r_{3} = p_{0}q_{3} + p_{3}q_{0} + p_{1}q_{2} - p_{2}q_{1}$\nThis form is clear and directly relates to the vector form $\\mathbf{r} = q_{0}\\mathbf{p} + p_{0}\\mathbf{q} + \\mathbf{p} \\times \\mathbf{q}$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} p_{0}q_{0} - p_{1}q_{1} - p_{2}q_{2} - p_{3}q_{3}  p_{0}q_{1} + p_{1}q_{0} + p_{2}q_{3} - p_{3}q_{2}  p_{0}q_{2} + p_{2}q_{0} + p_{3}q_{1} - p_{1}q_{3}  p_{0}q_{3} + p_{3}q_{0} + p_{1}q_{2} - p_{2}q_{1} \\end{pmatrix} } $$"
        },
        {
            "introduction": "In practical applications, it is essential to translate between different representations of orientation. This exercise  tackles the important task of converting a more familiar rotation matrix $\\mathbf{R} \\in \\mathrm{SO}(3)$ into its corresponding unit quaternion. More than just a simple formulaic conversion, this problem challenges you to derive the relationship and confront the issue of numerical stability, a critical consideration in robust computational code, especially for rotations close to $180$ degrees.",
            "id": "3838909",
            "problem": "In a multiscale materials simulation of a rigid crystalline inclusion embedded in a continuum, orientations are carried at the coarse scale by unit quaternions to ensure numerically stable interpolation and time integration. A coarse element reports the following proper orthogonal rotation matrix $\\mathbf{R} \\in \\mathrm{SO}(3)$ that maps the lattice frame to the laboratory frame:\n$$\n\\mathbf{R} \\;=\\;\n\\begin{pmatrix}\n-\\frac{6}{7}  \\frac{2}{7}  \\frac{3}{7} \\\\\n\\frac{2}{7}  -\\frac{3}{7}  \\frac{6}{7} \\\\\n\\frac{3}{7}  \\frac{6}{7}  \\frac{2}{7}\n\\end{pmatrix}.\n$$\nStarting from the fundamental representation of a three-dimensional vector $\\mathbf{v} \\in \\mathbb{R}^{3}$ as a pure imaginary quaternion $(0,\\mathbf{v})$ and the action of a unit quaternion $q = (q_{0},q_{1},q_{2},q_{3})$ on $\\mathbf{v}$ defined by quaternion conjugation $(0,\\mathbf{v}^{\\prime}) = q\\,(0,\\mathbf{v})\\,q^{-1}$, derive the expression of the rotation matrix entries in terms of $q$ and show how the matrix trace can be used to construct $q$ from $\\mathbf{R}$ with appropriate case handling for numerical stability when the trace is not positive. Then, apply your derivation to the given $\\mathbf{R}$ and compute the corresponding unit quaternion $q$.\n\nImpose the sign convention $q_{0} \\ge 0$, and if $q_{0} = 0$, require that the first nonzero component among $(q_{1},q_{2},q_{3})$ be nonnegative. Express your final quaternion as a single row vector $(q_{0},q_{1},q_{2},q_{3})$ in simplest exact radical form. Do not round.",
            "solution": "The problem statement has been validated and found to be scientifically grounded, well-posed, objective, and complete. It describes a standard problem in rigid body dynamics involving the conversion of a rotation matrix from the special orthogonal group $\\mathrm{SO}(3)$ to its corresponding unit quaternion representation. The provided matrix $\\mathbf{R}$ has been verified to be a proper orthogonal matrix, with $\\mathbf{R}^T\\mathbf{R} = \\mathbf{I}$ and $\\det(\\mathbf{R})=1$. The problem requires a derivation from first principles and a subsequent application of the derived formulas, which constitutes a valid and substantive task. We may proceed with the solution.\n\nThe problem is addressed in three parts:\n$1$. The derivation of the rotation matrix $\\mathbf{R}$ from a unit quaternion $q$.\n$2$. The derivation of the inverse relationship, to find $q$ from $\\mathbf{R}$, including handling of special cases for numerical stability.\n$3$. The application of these formulas to the given matrix $\\mathbf{R}$ to find the specific quaternion $q$.\n\nLet a unit quaternion be $q = (q_0, q_1, q_2, q_3) = q_0 + q_1\\mathbf{i} + q_2\\mathbf{j} + q_3\\mathbf{k}$, where $q_0$ is the scalar part and $\\mathbf{q} = (q_1, q_2, q_3)$ is the vector part. The condition of $q$ being a unit quaternion is $q_0^2 + q_1^2 + q_2^2 + q_3^2 = 1$. A vector $\\mathbf{v} \\in \\mathbb{R}^3$ is represented as a pure quaternion $v = (0, \\mathbf{v}) = v_x\\mathbf{i} + v_y\\mathbf{j} + v_z\\mathbf{k}$.\n\n**Part 1: Derivation of $\\mathbf{R}$ from $q$**\n\nThe rotation of a vector $\\mathbf{v}$ to $\\mathbf{v}'$ is given by the quaternion conjugation:\n$$ v' = q v q^{-1} $$\nwhere $v'=(0, \\mathbf{v}')$. For a unit quaternion, the inverse is its conjugate, $q^{-1} = q^* = q_0 - \\mathbf{q}$. The multiplication of two quaternions $a=(a_0, \\mathbf{a})$ and $b=(b_0, \\mathbf{b})$ is $ab = (a_0 b_0 - \\mathbf{a} \\cdot \\mathbf{b}, a_0 \\mathbf{b} + b_0 \\mathbf{a} + \\mathbf{a} \\times \\mathbf{b})$.\n\nFirst, we compute the product $qv$:\n$$ qv = (q_0, \\mathbf{q})(0, \\mathbf{v}) = (q_0(0) - \\mathbf{q} \\cdot \\mathbf{v}, q_0\\mathbf{v} + 0\\mathbf{q} + \\mathbf{q} \\times \\mathbf{v}) = (-\\mathbf{q} \\cdot \\mathbf{v}, q_0\\mathbf{v} + \\mathbf{q} \\times \\mathbf{v}) $$\nNext, we multiply this result by $q^{-1} = (q_0, -\\mathbf{q})$:\n$$ v' = (qv)q^{-1} = (-\\mathbf{q} \\cdot \\mathbf{v}, q_0\\mathbf{v} + \\mathbf{q} \\times \\mathbf{v})(q_0, -\\mathbf{q}) $$\nThe scalar part of $v'$ is:\n$$ s' = (-\\mathbf{q} \\cdot \\mathbf{v})q_0 - (q_0\\mathbf{v} + \\mathbf{q} \\times \\mathbf{v}) \\cdot (-\\mathbf{q}) = -q_0(\\mathbf{q} \\cdot \\mathbf{v}) + q_0(\\mathbf{v} \\cdot \\mathbf{q}) + (\\mathbf{q} \\times \\mathbf{v}) \\cdot \\mathbf{q} = 0 $$\nThis is expected, as a rotated vector must remain a pure quaternion. The vector part $\\mathbf{v}'$ is:\n$$ \\mathbf{v}' = (-\\mathbf{q} \\cdot \\mathbf{v})(-\\mathbf{q}) + q_0(q_0\\mathbf{v} + \\mathbf{q} \\times \\mathbf{v}) + (q_0\\mathbf{v} + \\mathbf{q} \\times \\mathbf{v}) \\times (-\\mathbf{q}) $$\n$$ \\mathbf{v}' = (\\mathbf{q} \\cdot \\mathbf{v})\\mathbf{q} + q_0^2\\mathbf{v} + q_0(\\mathbf{q} \\times \\mathbf{v}) - q_0(\\mathbf{v} \\times \\mathbf{q}) - (\\mathbf{q} \\times \\mathbf{v}) \\times \\mathbf{q} $$\nUsing the anti-commutativity of the cross product, $\\mathbf{v} \\times \\mathbf{q} = -(\\mathbf{q} \\times \\mathbf{v})$, and the vector triple product identity $\\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c}) = (\\mathbf{a}\\cdot\\mathbf{c})\\mathbf{b} - (\\mathbf{a}\\cdot\\mathbf{b})\\mathbf{c}$, we simplify:\n$$ \\mathbf{v}' = (\\mathbf{q} \\cdot \\mathbf{v})\\mathbf{q} + q_0^2\\mathbf{v} + 2q_0(\\mathbf{q} \\times \\mathbf{v}) - [(\\mathbf{q}\\cdot\\mathbf{q})\\mathbf{v} - (\\mathbf{q}\\cdot\\mathbf{v})\\mathbf{q}] $$\n$$ \\mathbf{v}' = (q_0^2 - \\mathbf{q}\\cdot\\mathbf{q})\\mathbf{v} + 2(\\mathbf{q}\\cdot\\mathbf{v})\\mathbf{q} + 2q_0(\\mathbf{q} \\times \\mathbf{v}) $$\nUsing the unit norm condition $q_0^2 + \\mathbf{q}\\cdot\\mathbf{q} = 1$, we can write $q_0^2 - \\mathbf{q}\\cdot\\mathbf{q} = q_0^2 - (1 - q_0^2) = 2q_0^2 - 1$.\nThe transformation is $\\mathbf{v}' = \\mathbf{R}\\mathbf{v}$, where the rotation operator $\\mathbf{R}$ can be expressed in terms of tensor and vector products:\n$$ \\mathbf{R} = (2q_0^2 - 1)\\mathbf{I} + 2\\mathbf{q}\\otimes\\mathbf{q} + 2q_0[\\mathbf{q}]_\\times $$\nHere $\\mathbf{I}$ is the identity matrix, $\\mathbf{q}\\otimes\\mathbf{q}$ is the outer product $\\mathbf{q}\\mathbf{q}^T$, and $[\\mathbf{q}]_\\times$ is the skew-symmetric matrix representation of the cross product with $\\mathbf{q}$. In component form, this gives the rotation matrix:\n$$ \\mathbf{R} = \\begin{pmatrix} q_0^2+q_1^2-q_2^2-q_3^2  2(q_1q_2 - q_0q_3)  2(q_1q_3 + q_0q_2) \\\\ 2(q_1q_2 + q_0q_3)  q_0^2-q_1^2+q_2^2-q_3^2  2(q_2q_3 - q_0q_1) \\\\ 2(q_1q_3 - q_0q_2)  2(q_2q_3 + q_0q_1)  q_0^2-q_1^2-q_2^2+q_3^2 \\end{pmatrix} $$\nAlternatively, using $q_0^2+q_1^2+q_2^2+q_3^2=1$:\n$$ \\mathbf{R} = \\begin{pmatrix} 1-2(q_2^2+q_3^2)  2(q_1q_2 - q_0q_3)  2(q_1q_3 + q_0q_2) \\\\ 2(q_1q_2 + q_0q_3)  1-2(q_1^2+q_3^2)  2(q_2q_3 - q_0q_1) \\\\ 2(q_1q_3 - q_0q_2)  2(q_2q_3 + q_0q_1)  1-2(q_1^2+q_2^2) \\end{pmatrix} $$\n\n**Part 2: Derivation of $q$ from $\\mathbf{R}$**\n\nThe trace of $\\mathbf{R}$ is the sum of its diagonal elements:\n$$ \\mathrm{Tr}(\\mathbf{R}) = R_{11} + R_{22} + R_{33} = (q_0^2+q_1^2-q_2^2-q_3^2) + (q_0^2-q_1^2+q_2^2-q_3^2) + (q_0^2-q_1^2-q_2^2+q_3^2) $$\n$$ \\mathrm{Tr}(\\mathbf{R}) = 3q_0^2 - q_1^2 - q_2^2 - q_3^2 = 3q_0^2 - (1 - q_0^2) = 4q_0^2 - 1 $$\nThis yields a direct expression for $q_0^2$:\n$$ 4q_0^2 = \\mathrm{Tr}(\\mathbf{R}) + 1 \\implies q_0 = \\frac{1}{2}\\sqrt{\\mathrm{Tr}(\\mathbf{R}) + 1} $$\nWe select the positive root due to the problem's sign convention $q_0 \\ge 0$. The other components can be found from the off-diagonal terms:\n$$ R_{32} - R_{23} = 4q_0q_1 \\implies q_1 = \\frac{R_{32} - R_{23}}{4q_0} $$\n$$ R_{13} - R_{31} = 4q_0q_2 \\implies q_2 = \\frac{R_{13} - R_{31}}{4q_0} $$\n$$ R_{21} - R_{12} = 4q_0q_3 \\implies q_3 = \\frac{R_{21} - R_{12}}{4q_0} $$\nThis approach is numerically unstable if $\\mathrm{Tr}(\\mathbf{R})$ is close to $-1$, which corresponds to a rotation angle near $\\pi$, making $q_0$ close to $0$.\n\nFor a numerically stable algorithm, we must handle the case when the trace is not positive. The general strategy is to compute the component of $q$ with the largest magnitude first, then use it to find the others. We construct the following relations from the diagonal elements of $\\mathbf{R}$:\n$$ 4q_0^2 = 1 + R_{11} + R_{22} + R_{33} = 1 + \\mathrm{Tr}(\\mathbf{R}) $$\n$$ 4q_1^2 = 1 + R_{11} - R_{22} - R_{33} $$\n$$ 4q_2^2 = 1 - R_{11} + R_{22} - R_{33} $$\n$$ 4q_3^2 = 1 - R_{11} - R_{22} + R_{33} $$\nThe algorithm proceeds by identifying the largest value among the right-hand sides, which corresponds to the largest component of $q$.\nIf $q_0$ is largest (i.e., $\\mathrm{Tr}(\\mathbf{R})$ is largest among related terms, typically when $\\mathrm{Tr}(\\mathbf{R})0$), we use the formulas above.\nIf $\\mathrm{Tr}(\\mathbf{R}) \\le 0$ and $R_{11}$ is the largest diagonal term, then $|q_1|$ is the largest component. We compute $q_1 = \\frac{1}{2}\\sqrt{1 + R_{11} - R_{22} - R_{33}}$ (choosing a sign based on convention or other values) and then solve for the other components:\n$q_0 = \\frac{R_{32}-R_{23}}{4q_1}$, $q_2 = \\frac{R_{12}+R_{21}}{4q_1}$, $q_3 = \\frac{R_{13}+R_{31}}{4q_1}$.\nAnalogous formulas exist if $R_{22}$ or $R_{33}$ are the largest diagonal elements.\n\n**Part 3: Application to the Given Matrix**\n\nThe given rotation matrix is:\n$$ \\mathbf{R} = \\begin{pmatrix} -\\frac{6}{7}  \\frac{2}{7}  \\frac{3}{7} \\\\ \\frac{2}{7}  -\\frac{3}{7}  \\frac{6}{7} \\\\ \\frac{3}{7}  \\frac{6}{7}  \\frac{2}{7} \\end{pmatrix} $$\nFirst, we compute the trace:\n$$ \\mathrm{Tr}(\\mathbf{R}) = -\\frac{6}{7} - \\frac{3}{7} + \\frac{2}{7} = \\frac{-7}{7} = -1 $$\nThe trace is not positive, indicating a rotation angle of $\\theta = \\pi$. We apply the stable method. From $\\mathrm{Tr}(\\mathbf{R}) = -1$, we find:\n$$ q_0 = \\frac{1}{2}\\sqrt{-1+1} = 0 $$\nSince $q_0=0$, we must use the diagonal elements to find the vector components.\n$$ 4q_1^2 = 1 + R_{11} - R_{22} - R_{33} = 1 - \\frac{6}{7} - (-\\frac{3}{7}) - \\frac{2}{7} = \\frac{7-6+3-2}{7} = \\frac{2}{7} \\implies q_1^2 = \\frac{1}{14} $$\n$$ 4q_2^2 = 1 - R_{11} + R_{22} - R_{33} = 1 - (-\\frac{6}{7}) - \\frac{3}{7} - \\frac{2}{7} = \\frac{7+6-3-2}{7} = \\frac{8}{7} \\implies q_2^2 = \\frac{2}{7} $$\n$$ 4q_3^2 = 1 - R_{11} - R_{22} + R_{33} = 1 - (-\\frac{6}{7}) - (-\\frac{3}{7}) + \\frac{2}{7} = \\frac{7+6+3+2}{7} = \\frac{18}{7} \\implies q_3^2 = \\frac{9}{14} $$\nThe magnitudes are $|q_1| = \\frac{1}{\\sqrt{14}}$, $|q_2| = \\sqrt{\\frac{2}{7}}$, and $|q_3| = \\frac{3}{\\sqrt{14}}$.\nTo determine the signs, we use the off-diagonal elements of $\\mathbf{R}$. With $q_0=0$:\n$$ R_{12} = 2q_1q_2 = \\frac{2}{7} \\implies q_1q_2 = \\frac{1}{7} $$\n$$ R_{13} = 2q_1q_3 = \\frac{3}{7} \\implies q_1q_3 = \\frac{3}{14} $$\n$$ R_{23} = 2q_2q_3 = \\frac{6}{7} \\implies q_2q_3 = \\frac{3}{7} $$\nSince all products $q_iq_j$ are positive, the components $q_1, q_2, q_3$ must all have the same sign (either all positive or all negative).\nThe problem imposes the sign convention: if $q_0=0$, the first nonzero component among $(q_1, q_2, q_3)$ must be nonnegative. Since $q_1$ is nonzero, we must have $q_1  0$. This implies $q_2  0$ and $q_3  0$ as well.\nWe thus take the positive roots for the magnitudes:\n$$ q_1 = \\sqrt{\\frac{1}{14}} = \\frac{1}{\\sqrt{14}} = \\frac{\\sqrt{14}}{14} $$\n$$ q_2 = \\sqrt{\\frac{2}{7}} = \\frac{\\sqrt{2}}{\\sqrt{7}} = \\frac{\\sqrt{14}}{7} $$\n$$ q_3 = \\sqrt{\\frac{9}{14}} = \\frac{3}{\\sqrt{14}} = \\frac{3\\sqrt{14}}{14} $$\nThe final quaternion is $q=(q_0, q_1, q_2, q_3)$.\n$$ q = \\left(0, \\frac{\\sqrt{14}}{14}, \\frac{\\sqrt{14}}{7}, \\frac{3\\sqrt{14}}{14}\\right) $$\nA final check confirms the norm: $q_0^2+q_1^2+q_2^2+q_3^2 = 0 + \\frac{1}{14} + \\frac{2}{7} + \\frac{9}{14} = \\frac{1+4+9}{14} = \\frac{14}{14} = 1$. The solution is consistent.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  \\frac{\\sqrt{14}}{14}  \\frac{\\sqrt{14}}{7}  \\frac{3\\sqrt{14}}{14}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "This final practice serves as a capstone exercise, integrating the quaternion kinematics you've learned with the principles of rigid body dynamics. You will implement a numerical simulation of a torque-free rigid body, coupling the rotational dynamics described by Euler's equations with the kinematic evolution of the orientation quaternion. This task  moves from theory to application, reinforcing your understanding of how to use quaternions to model physical systems and allowing you to verify the conservation of fundamental quantities like energy and angular momentum.",
            "id": "3838888",
            "problem": "Consider a torque-free rigid body whose orientation is represented by a unit quaternion $q(t) \\in \\mathbb{H}$ and whose angular velocity in the body frame is $\\boldsymbol{\\omega}(t) \\in \\mathbb{R}^3$. The principal-axis inertia tensor in the body frame is diagonal, $I = \\mathrm{diag}(I_1, I_2, I_3)$, where $I_1, I_2, I_3  0$ are distinct principal moments of inertia. The fundamental bases for the dynamics are Newton’s second law for rotational motion and the definitions of quaternion kinematics:\n- Newton’s second law for rotational motion in the absence of torque states $\\frac{d \\boldsymbol{H}_{\\text{inertial}}}{dt} = \\boldsymbol{0}$, where $\\boldsymbol{H}_{\\text{inertial}}$ is the angular momentum in the inertial frame.\n- In the body frame, with $I$ constant, the angular momentum is $\\boldsymbol{L} = I \\boldsymbol{\\omega}$, and the torque-free Euler equation is $I \\,\\dot{\\boldsymbol{\\omega}} = \\boldsymbol{L} \\times \\boldsymbol{\\omega}$.\n- For quaternion kinematics, let the unit quaternion be $q = (q_0, \\boldsymbol{q_v})$ with scalar part $q_0 \\in \\mathbb{R}$ and vector part $\\boldsymbol{q_v} \\in \\mathbb{R}^3$. Define the pure quaternion associated with angular velocity $\\boldsymbol{\\omega}$ as $\\omega_q = (0,\\boldsymbol{\\omega})$. The active rotation quaternion mapping body vectors to inertial vectors obeys the first-order Ordinary Differential Equation (ODE) $\\dot{q} = \\frac{1}{2} \\, q \\otimes \\omega_q$, where $\\otimes$ denotes quaternion multiplication.\n\nStarting from these bases, derive the coupled ODEs for $\\dot{\\boldsymbol{\\omega}}(t)$ and $\\dot{q}(t)$. Then, design and implement a numerical algorithm that:\n- Integrates the torque-free rigid body dynamics using the classical fourth-order Runge–Kutta method with a fixed time step, enforcing the unit-norm constraint $\\lVert q(t) \\rVert = 1$ after every step by renormalization.\n- Computes, at a dense set of time samples $t_k$, the kinetic energy $T(t_k) = \\frac{1}{2} \\, \\boldsymbol{\\omega}(t_k)^\\top I \\, \\boldsymbol{\\omega}(t_k)$, the inertial-frame angular momentum vector $\\boldsymbol{H}_{\\text{inertial}}(t_k) = R(q(t_k)) \\, I \\, \\boldsymbol{\\omega}(t_k)$, and its magnitude $\\lVert \\boldsymbol{H}_{\\text{inertial}}(t_k) \\rVert$. Here $R(q)$ is the rotation matrix corresponding to the quaternion $q$ that maps body-frame vectors to inertial-frame vectors, and it is an element of the Special Orthogonal group in three dimensions (SO(3)).\n- Verifies the invariants associated with torque-free motion by computing three scalar diagnostics over the trajectory: the maximum relative deviation of the kinetic energy from its initial value, the maximum relative deviation of the inertial angular momentum magnitude from its initial value, and the maximum relative change of the inertial angular momentum vector relative to its initial magnitude, namely\n$$\n\\Delta_T^{\\max} = \\max_k \\left| \\frac{T(t_k) - T(0)}{T(0)} \\right|, \\quad\n\\Delta_{H\\_n}^{\\max} = \\max_k \\left| \\frac{\\lVert \\boldsymbol{H}_{\\text{inertial}}(t_k) \\rVert - \\lVert \\boldsymbol{H}_{\\text{inertial}}(0) \\rVert}{\\lVert \\boldsymbol{H}_{\\text{inertial}}(0) \\rVert} \\right|, \\quad\n\\Delta_{H\\_v}^{\\max} = \\max_k \\left( \\frac{ \\lVert \\boldsymbol{H}_{\\text{inertial}}(t_k) - \\boldsymbol{H}_{\\text{inertial}}(0) \\rVert }{ \\lVert \\boldsymbol{H}_{\\text{inertial}}(0) \\rVert } \\right).\n$$\nAll angles are to be considered in radians. These diagnostics are dimensionless.\n\nYour program must implement the above algorithm and evaluate it on the following test suite of parameter sets, each specified by $(I_1,I_2,I_3)$, $\\boldsymbol{\\omega}(0)$, $q(0)$, final time $t_{\\mathrm{end}}$, and fixed step size $\\Delta t$:\n- Test case A (general anisotropic body, moderate time): $(I_1,I_2,I_3) = (2.0, 1.0, 0.5)$, $\\boldsymbol{\\omega}(0) = (1.0, 0.2, 0.3)$, $q(0) = (1,0,0,0)$, $t_{\\mathrm{end}} = 1.0$, $\\Delta t = 10^{-3}$.\n- Test case B (near-symmetric about two axes, longer time): $(I_1,I_2,I_3) = (1.0, 1.01, 2.0)$, $\\boldsymbol{\\omega}(0) = (0.7, -0.4, 0.5)$, $q(0) = (1,0,0,0)$, $t_{\\mathrm{end}} = 5.0$, $\\Delta t = 5 \\times 10^{-4}$.\n- Test case C (principal-axis spin, trivial evolution of $\\boldsymbol{\\omega}$): $(I_1,I_2,I_3) = (3.0, 2.0, 1.0)$, $\\boldsymbol{\\omega}(0) = (0.0, 0.0, 3.0)$, $q(0) = (1,0,0,0)$, $t_{\\mathrm{end}} = 2.0$, $\\Delta t = 10^{-3}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where the entry for each test case is a sublist of the three diagnostics in the order $\\left[\\Delta_T^{\\max}, \\Delta_{H\\_n}^{\\max}, \\Delta_{H\\_v}^{\\max}\\right]$. For example, the output format must be exactly of the form\n$[[d_1,d_2,d_3],[d_1',d_2',d_3'],[d_1'',d_2'',d_3'']]$,\nwith no spaces anywhere in the string. Each $d$ must be a decimal floating-point number.",
            "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically grounded in the principles of classical mechanics, mathematically well-posed as an initial value problem, and objectively specified with all necessary data and definitions for a unique solution.\n\nThe problem requires the derivation and numerical implementation of the equations of motion for a torque-free rigid body. The state of the system at any time $t$ is described by a 7-dimensional state vector $y(t) = (\\omega_1(t), \\omega_2(t), \\omega_3(t), q_0(t), q_1(t), q_2(t), q_3(t))^\\top$, which combines the angular velocity vector in the body frame, $\\boldsymbol{\\omega} \\in \\mathbb{R}^3$, and the unit quaternion representing orientation, $q \\in \\mathbb{H}$ with components $(q_0, q_1, q_2, q_3)$. The evolution of this state is governed by a system of first-order ordinary differential equations (ODEs), $\\dot{y} = f(y)$.\n\nThe first part of the system, governing the angular velocity $\\boldsymbol{\\omega}$, is given by the torque-free Euler's equations. The problem states $I \\dot{\\boldsymbol{\\omega}} = \\boldsymbol{L} \\times \\boldsymbol{\\omega}$, where $\\boldsymbol{L} = I\\boldsymbol{\\omega}$ is the angular momentum in the body frame and $I = \\mathrm{diag}(I_1, I_2, I_3)$ is the diagonal inertia tensor. Expanding the cross product gives the component-wise equations for $\\dot{\\boldsymbol{\\omega}}$:\n$$\n\\begin{pmatrix} I_1 \\dot{\\omega}_1 \\\\ I_2 \\dot{\\omega}_2 \\\\ I_3 \\dot{\\omega}_3 \\end{pmatrix}\n=\n\\begin{pmatrix} I_1 \\omega_1 \\\\ I_2 \\omega_2 \\\\ I_3 \\omega_3 \\end{pmatrix}\n\\times\n\\begin{pmatrix} \\omega_1 \\\\ \\omega_2 \\\\ \\omega_3 \\end{pmatrix}\n=\n\\begin{pmatrix} (I_2 - I_3) \\omega_2 \\omega_3 \\\\ (I_3 - I_1) \\omega_3 \\omega_1 \\\\ (I_1 - I_2) \\omega_1 \\omega_2 \\end{pmatrix}\n$$\nSolving for $\\dot{\\boldsymbol{\\omega}}$ yields:\n$$\n\\dot{\\omega}_1 = \\frac{I_2 - I_3}{I_1} \\omega_2 \\omega_3 \\\\\n\\dot{\\omega}_2 = \\frac{I_3 - I_1}{I_2} \\omega_3 \\omega_1 \\\\\n\\dot{\\omega}_3 = \\frac{I_1 - I_2}{I_3} \\omega_1 \\omega_2\n$$\n\nThe second part of the system, governing the orientation quaternion $q$, is given by the kinematic differential equation $\\dot{q} = \\frac{1}{2} q \\otimes \\omega_q$, where $\\omega_q = (0, \\boldsymbol{\\omega})$ is the pure quaternion representing the angular velocity. The quaternion multiplication rule $(a_0, \\boldsymbol{a_v}) \\otimes (b_0, \\boldsymbol{b_v}) = (a_0 b_0 - \\boldsymbol{a_v} \\cdot \\boldsymbol{b_v}, a_0 \\boldsymbol{b_v} + b_0 \\boldsymbol{a_v} + \\boldsymbol{a_v} \\times \\boldsymbol{b_v})$ is applied with $a=q$ and $b=\\omega_q$. This yields:\n$$\n\\dot{q} = \\frac{1}{2} (q_0 \\cdot 0 - \\boldsymbol{q_v} \\cdot \\boldsymbol{\\omega}, q_0 \\boldsymbol{\\omega} + 0 \\cdot \\boldsymbol{q_v} + \\boldsymbol{q_v} \\times \\boldsymbol{\\omega})\n$$\nIn component form, with $q = (q_0, q_1, q_2, q_3)$ and $\\boldsymbol{\\omega} = (\\omega_1, \\omega_2, \\omega_3)$, the equations for $\\dot{q}$ are:\n$$\n\\dot{q}_0 = \\frac{1}{2} (-q_1 \\omega_1 - q_2 \\omega_2 - q_3 \\omega_3) \\\\\n\\dot{q}_1 = \\frac{1}{2} (q_0 \\omega_1 + q_2 \\omega_3 - q_3 \\omega_2) \\\\\n\\dot{q}_2 = \\frac{1}{2} (q_0 \\omega_2 - q_1 \\omega_3 + q_3 \\omega_1) \\\\\n\\dot{q}_3 = \\frac{1}{2} (q_0 \\omega_3 + q_1 \\omega_2 - q_2 \\omega_1)\n$$\nThis can be expressed compactly in matrix form as $\\dot{q} = \\frac{1}{2} \\Omega(\\boldsymbol{\\omega}) q$, where $\\Omega(\\boldsymbol{\\omega})$ is a skew-symmetric matrix dependent on $\\boldsymbol{\\omega}$.\n\nCombining these two sets of equations gives the complete ODE system $\\dot{y} = f(y, I)$ for the 7-dimensional state vector $y$. This initial value problem will be solved numerically using the classical fourth-order Runge-Kutta (RK4) method. Given the state $y_n$ at time $t_n$, the state $y_{n+1}$ at time $t_{n+1} = t_n + \\Delta t$ is computed as:\n$$\ny_{n+1} = y_n + \\frac{1}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n$$\nwhere\n$$\n\\begin{aligned}\nk_1 = \\Delta t \\cdot f(y_n, I) \\\\\nk_2 = \\Delta t \\cdot f(y_n + \\frac{1}{2}k_1, I) \\\\\nk_3 = \\Delta t \\cdot f(y_n + \\frac{1}{2}k_2, I) \\\\\nk_4 = \\Delta t \\cdot f(y_n + k_3, I)\n\\end{aligned}\n$$\nThe RK4 method is not guaranteed to preserve the unit norm of the quaternion. Therefore, after each integration step, the quaternion part of the computed state vector, $q_{n+1}$, must be explicitly renormalized: $q_{n+1} \\leftarrow q_{n+1} / \\lVert q_{n+1} \\rVert$. This projection step ensures the quaternion remains on the unit hypersphere $S^3$, thereby representing a valid rotation.\n\nThe simulation generates a trajectory of states $(y_0, y_1, \\dots, y_N)$. At each step $k$, we compute several physical quantities to monitor the conservation laws. The kinetic energy $T$ is given by:\n$$ T(t_k) = \\frac{1}{2} \\boldsymbol{\\omega}(t_k)^\\top I \\boldsymbol{\\omega}(t_k) = \\frac{1}{2} (I_1 \\omega_1^2(t_k) + I_2 \\omega_2^2(t_k) + I_3 \\omega_3^2(t_k)) $$\nFor torque-free motion, $T$ must be conserved.\nThe angular momentum in the inertial frame, $\\boldsymbol{H}_{\\text{inertial}}$, is constant because there is no external torque. It is computed by transforming the body-frame angular momentum $\\boldsymbol{L}(t_k) = I \\boldsymbol{\\omega}(t_k)$ to the inertial frame using the rotation matrix $R(q(t_k))$:\n$$ \\boldsymbol{H}_{\\text{inertial}}(t_k) = R(q(t_k)) \\boldsymbol{L}(t_k) $$\nThe rotation matrix $R(q)$ that actively rotates vectors from the body frame to the inertial frame for a unit quaternion $q=(q_0, q_1, q_2, q_3)$ is:\n$$\nR(q) =\n\\begin{pmatrix}\n1 - 2(q_2^2 + q_3^2)  2(q_1 q_2 - q_0 q_3)  2(q_1 q_3 + q_0 q_2) \\\\\n2(q_1 q_2 + q_0 q_3)  1 - 2(q_1^2 + q_3^2)  2(q_2 q_3 - q_0 q_1) \\\\\n2(q_1 q_3 - q_0 q_2)  2(q_2 q_3 + q_0 q_1)  1 - 2(q_1^2 + q_2^2)\n\\end{pmatrix}\n$$\nBoth the vector $\\boldsymbol{H}_{\\text{inertial}}$ and its magnitude $\\lVert \\boldsymbol{H}_{\\text{inertial}} \\rVert$ must be conserved.\n\nFinally, after the simulation completes, three diagnostic metrics are computed to quantify the numerical error in these conserved quantities. Using the stored history of $T(t_k)$ and $\\boldsymbol{H}_{\\text{inertial}}(t_k)$, the maximum relative deviations are calculated according to the specified formulas:\n$$\n\\Delta_T^{\\max} = \\max_k \\left| \\frac{T(t_k) - T(0)}{T(0)} \\right|, \\quad\n\\Delta_{H\\_n}^{\\max} = \\max_k \\left| \\frac{\\lVert \\boldsymbol{H}_{\\text{inertial}}(t_k) \\rVert - \\lVert \\boldsymbol{H}_{\\text{inertial}}(0) \\rVert}{\\lVert \\boldsymbol{H}_{\\text{inertial}}(0) \\rVert} \\right|, \\quad\n\\Delta_{H\\_v}^{\\max} = \\max_k \\left( \\frac{ \\lVert \\boldsymbol{H}_{\\text{inertial}}(t_k) - \\boldsymbol{H}_{\\text{inertial}}(0) \\rVert }{ \\lVert \\boldsymbol{H}_{\\text{inertial}}(0) \\rVert } \\right)\n$$\nThese diagnostics provide a measure of the algorithm's accuracy and stability over the integration period.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef q_to_rot_matrix(q):\n    \"\"\"Converts a unit quaternion to a rotation matrix.\"\"\"\n    q0, q1, q2, q3 = q[0], q[1], q[2], q[3]\n    \n    # Per the problem description, this matrix maps body vectors to inertial vectors.\n    r11 = 1.0 - 2.0 * (q2**2 + q3**2)\n    r12 = 2.0 * (q1 * q2 - q0 * q3)\n    r13 = 2.0 * (q1 * q3 + q0 * q2)\n    \n    r21 = 2.0 * (q1 * q2 + q0 * q3)\n    r22 = 1.0 - 2.0 * (q1**2 + q3**2)\n    r23 = 2.0 * (q2 * q3 - q0 * q1)\n    \n    r31 = 2.0 * (q1 * q3 - q0 * q2)\n    r32 = 2.0 * (q2 * q3 + q0 * q1)\n    r33 = 1.0 - 2.0 * (q1**2 + q2**2)\n    \n    return np.array([[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]])\n\ndef derivatives(state, I_vec):\n    \"\"\"\n    Computes the time derivative of the state vector [omega, q].\n    state: 7-element array (w1, w2, w3, q0, q1, q2, q3)\n    I_vec: 3-element array of principal moments of inertia (I1, I2, I3)\n    \"\"\"\n    omega = state[:3]\n    q = state[3:]\n    I1, I2, I3 = I_vec[0], I_vec[1], I_vec[2]\n\n    # Euler's equations for d(omega)/dt\n    omega_dot = np.array([\n        (I2 - I3) / I1 * omega[1] * omega[2],\n        (I3 - I1) / I2 * omega[2] * omega[0],\n        (I1 - I2) / I3 * omega[0] * omega[1]\n    ])\n\n    # Quaternion kinematics for dq/dt\n    # dq/dt = 0.5 * q * omega_q\n    q_dot = 0.5 * np.array([\n        -q[1]*omega[0] - q[2]*omega[1] - q[3]*omega[2],\n         q[0]*omega[0] + q[2]*omega[2] - q[3]*omega[1],\n         q[0]*omega[1] - q[1]*omega[2] + q[3]*omega[0],\n         q[0]*omega[2] + q[1]*omega[1] - q[2]*omega[0]\n    ])\n    \n    return np.concatenate((omega_dot, q_dot))\n\ndef run_simulation(I_vec, omega0, q0, t_end, dt):\n    \"\"\"\n    Integrates rigid body dynamics and computes diagnostic metrics.\n    \"\"\"\n    I_mat = np.diag(I_vec)\n    num_steps = int(round(t_end / dt))\n    \n    # Store trajectory history for post-processing\n    omega_hist = np.zeros((num_steps + 1, 3))\n    q_hist = np.zeros((num_steps + 1, 4))\n    \n    current_state = np.concatenate((omega0, q0))\n    omega_hist[0] = current_state[:3]\n    q_hist[0] = current_state[3:]\n\n    # Main integration loop\n    for i in range(num_steps):\n        # RK4 step\n        k1 = derivatives(current_state, I_vec)\n        k2 = derivatives(current_state + 0.5 * dt * k1, I_vec)\n        k3 = derivatives(current_state + 0.5 * dt * k2, I_vec)\n        k4 = derivatives(current_state + dt * k3, I_vec)\n        \n        current_state += (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n        \n        # Enforce unit-norm constraint on quaternion by renormalization\n        q_part = current_state[3:]\n        norm = np.linalg.norm(q_part)\n        current_state[3:] = q_part / norm if norm  0 else q_part\n        \n        omega_hist[i+1] = current_state[:3]\n        q_hist[i+1] = current_state[3:]\n\n    # Post-processing to calculate diagnostics\n    \n    # Calculate initial values of conserved quantities\n    T0 = 0.5 * omega_hist[0] @ I_mat @ omega_hist[0]\n    L0_body = I_mat @ omega_hist[0]\n    R0 = q_to_rot_matrix(q_hist[0])\n    H0_inertial = R0 @ L0_body\n    H0_norm = np.linalg.norm(H0_inertial)\n\n    # Avoid division by zero if initial state is at rest (not the case here).\n    T0_denom = T0 if T0 != 0 else 1.0\n    H0_norm_denom = H0_norm if H0_norm != 0 else 1.0\n\n    max_dev_T = 0.0\n    max_dev_H_norm = 0.0\n    max_dev_H_vec = 0.0\n    \n    for i in range(1, num_steps + 1):\n        omega_k = omega_hist[i]\n        q_k = q_hist[i]\n        \n        # Kinetic energy deviation\n        T_k = 0.5 * omega_k @ I_mat @ omega_k\n        dev_T = np.abs((T_k - T0) / T0_denom)\n        if dev_T  max_dev_T:\n            max_dev_T = dev_T\n            \n        # Inertial angular momentum deviations\n        L_k_body = I_mat @ omega_k\n        R_k = q_to_rot_matrix(q_k)\n        H_k_inertial = R_k @ L_k_body\n        H_k_norm = np.linalg.norm(H_k_inertial)\n        \n        dev_H_norm = np.abs((H_k_norm - H0_norm) / H0_norm_denom)\n        if dev_H_norm  max_dev_H_norm:\n            max_dev_H_norm = dev_H_norm\n            \n        dev_H_vec = np.linalg.norm(H_k_inertial - H0_inertial) / H0_norm_denom\n        if dev_H_vec  max_dev_H_vec:\n            max_dev_H_vec = dev_H_vec\n            \n    return [max_dev_T, max_dev_H_norm, max_dev_H_vec]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A: General anisotropic body\n        {'I_vec': np.array([2.0, 1.0, 0.5]), 'omega0': np.array([1.0, 0.2, 0.3]), \n         'q0': np.array([1.0, 0.0, 0.0, 0.0]), 't_end': 1.0, 'dt': 1e-3},\n        # Case B: Near-symmetric body\n        {'I_vec': np.array([1.0, 1.01, 2.0]), 'omega0': np.array([0.7, -0.4, 0.5]), \n         'q0': np.array([1.0, 0.0, 0.0, 0.0]), 't_end': 5.0, 'dt': 5e-4},\n        # Case C: Principal-axis spin\n        {'I_vec': np.array([3.0, 2.0, 1.0]), 'omega0': np.array([0.0, 0.0, 3.0]), \n         'q0': np.array([1.0, 0.0, 0.0, 0.0]), 't_end': 2.0, 'dt': 1e-3}\n    ]\n\n    results = []\n    for case in test_cases:\n        diagnostics = run_simulation(\n            case['I_vec'], case['omega0'], case['q0'], case['t_end'], case['dt']\n        )\n        results.append(diagnostics)\n\n    # Format output string exactly as specified: [[d1,d2,d3],[d'1,d'2,d'3],...]\n    sub_lists_str = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(sub_lists_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}