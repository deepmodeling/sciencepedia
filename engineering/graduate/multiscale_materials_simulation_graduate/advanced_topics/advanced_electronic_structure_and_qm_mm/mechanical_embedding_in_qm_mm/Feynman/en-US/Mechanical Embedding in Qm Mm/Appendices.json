{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any molecular simulation is the accurate calculation of forces from a potential energy function. This practice provides a crucial exercise in code verification, a cornerstone of computational science. By deriving the analytical forces for a mechanical embedding coupling term and comparing them against a numerical finite-difference approximation, you will build confidence in your implementation and deepen your understanding of the relationship between energy and force .",
            "id": "3823974",
            "problem": "You are tasked with implementing and validating numerical force calculations for a simplified mechanical embedding scheme in Quantum Mechanics/Molecular Mechanics (QM/MM). Quantum Mechanics/Molecular Mechanics (QM/MM) is a multiscale strategy that partitions a system into a quantum mechanical region and a molecular mechanical region, with an interfacial coupling energy enforcing structural consistency at the boundary. In mechanical embedding, the coupling is purely through mechanical (elastic) terms, without direct electrostatic polarization of the quantum mechanical region by the molecular mechanical region.\n\nConsider two boundary atoms: one quantum mechanical boundary atom with position vector $\\mathbf{r}_{\\mathrm{Q}} \\in \\mathbb{R}^{3}$ and one molecular mechanical boundary atom with position vector $\\mathbf{r}_{\\mathrm{M}} \\in \\mathbb{R}^{3}$. Let $\\mathbf{u} \\in \\mathbb{R}^{3}$ be a fixed unit direction vector taken from the reference boundary bond orientation (assumed normalized), and let $\\Delta \\mathbf{r} = \\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}$ denote the relative displacement. Define the axial projection operator along $\\mathbf{u}$ as $\\mathbf{P}_{\\parallel} = \\mathbf{u}\\mathbf{u}^{\\top}$ and the perpendicular projection operator as $\\mathbf{P}_{\\perp} = \\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}$, where $\\mathbf{I}$ is the identity matrix in $\\mathbb{R}^{3 \\times 3}$.\n\nThe mechanical coupling energy is defined as\n$$\nE_{\\text{couple}}(\\mathbf{r}_{\\mathrm{Q}}, \\mathbf{r}_{\\mathrm{M}}) = \\frac{k_{\\parallel}}{2}\\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right)^2 + \\frac{k_{\\perp}}{2}\\left\\| \\mathbf{P}_{\\perp}\\,\\Delta \\mathbf{r} \\right\\|^2,\n$$\nwhere $k_{\\parallel} > 0$ is the axial stiffness, $k_{\\perp} \\ge 0$ is the transverse stiffness, and $r_0 \\ge 0$ is the target axial separation along $\\mathbf{u}$. Forces are defined by the negative gradient of the energy with respect to Cartesian coordinates, consistent with the work-energy principle and Newton's laws of motion.\n\nYour program must:\n- Compute numerical forces on the quantum mechanical boundary atom and the molecular mechanical boundary atom using central finite differences on the energy $E_{\\text{couple}}$ with a small step size $h$.\n- Derive, implement, and use analytic force expressions based on the definition of $E_{\\text{couple}}$ (you must derive these expressions from first principles; do not use or assume any pre-given gradient formulas beyond core calculus and linear algebra).\n- Verify consistency by comparing numerical and analytic forces and quantifying their discrepancy.\n- Verify Newton’s third law by checking that the sum of the forces on the two boundary atoms is approximately zero.\n\nAll quantities are dimensionless in a reduced unit system, so no physical unit conversion is required. Angles are not used, and no angle units are needed.\n\nNumerical method details:\n- Use central difference for each Cartesian component. For example, the force component on the quantum mechanical boundary atom satisfies $F_{\\mathrm{Q},i} \\approx -\\left(E(\\mathbf{r}_{\\mathrm{Q}}+h\\,\\mathbf{e}_i,\\mathbf{r}_{\\mathrm{M}})-E(\\mathbf{r}_{\\mathrm{Q}}-h\\,\\mathbf{e}_i,\\mathbf{r}_{\\mathrm{M}})\\right)/(2h)$, where $\\mathbf{e}_i$ is the $i$-th standard basis vector in $\\mathbb{R}^{3}$ and $i \\in \\{1,2,3\\}$. An analogous expression applies for the molecular mechanical boundary atom force components with perturbations applied to $\\mathbf{r}_{\\mathrm{M}}$.\n- Use a tolerance $\\tau$ to assess Newton’s third law, checking whether the infinity norm of $\\mathbf{F}_{\\mathrm{Q}} + \\mathbf{F}_{\\mathrm{M}}$ is less than or equal to $\\tau$.\n\nTest suite:\nImplement the computations for the following three test cases, designed to cover diverse geometric and stiffness conditions:\n1. General configuration (happy path):\n   - $\\mathbf{r}_{\\mathrm{Q}} = [0.8, -0.2, 0.3]$, $\\mathbf{r}_{\\mathrm{M}} = [-0.4, 0.5, 0.1]$,\n   - $\\mathbf{u} = [1.0, 1.0, 0.5]$ (use the normalized vector in the computation),\n   - $r_0 = 1.1$, $k_{\\parallel} = 120.0$, $k_{\\perp} = 80.0$.\n2. Pure axial coupling (boundary case with zero transverse stiffness):\n   - $\\mathbf{r}_{\\mathrm{Q}} = [1.0, 0.0, 0.0]$, $\\mathbf{r}_{\\mathrm{M}} = [0.0, 1.0, 0.0]$,\n   - $\\mathbf{u} = [1.0, 0.0, 0.0]$ (use the normalized vector in the computation),\n   - $r_0 = 1.0$, $k_{\\parallel} = 50.0$, $k_{\\perp} = 0.0$.\n3. Degenerate displacement with nonzero target axial separation:\n   - $\\mathbf{r}_{\\mathrm{Q}} = [0.0, 0.0, 0.0]$, $\\mathbf{r}_{\\mathrm{M}} = [0.0, 0.0, 0.0]$,\n   - $\\mathbf{u} = [0.0, 0.0, 1.0]$ (use the normalized vector in the computation),\n   - $r_0 = 0.3$, $k_{\\parallel} = 30.0$, $k_{\\perp} = 10.0$.\n\nAlgorithmic parameters:\n- Use $h = 10^{-6}$ for central differences.\n- Use $\\tau = 10^{-8}$ for the Newton’s third law check.\n\nFor each test case, compute:\n- The maximum absolute component-wise discrepancy between the numerical and analytic forces over both atoms, as a single float.\n- A boolean indicating whether the numerical forces satisfy Newton’s third law within tolerance, i.e., whether $\\left\\|\\mathbf{F}_{\\mathrm{Q}}^{\\text{num}} + \\mathbf{F}_{\\mathrm{M}}^{\\text{num}} \\right\\|_{\\infty} \\le \\tau$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, for each of the three test cases in order, first the float discrepancy and then the boolean for the Newton’s third law check. For example, the output should look like $[\\text{error}_1,\\text{consistent}_1,\\text{error}_2,\\text{consistent}_2,\\text{error}_3,\\text{consistent}_3]$, where $\\text{error}_i$ is a float and $\\text{consistent}_i$ is either True or False.",
            "solution": "The problem is deemed valid as it is scientifically grounded in classical mechanics and linear algebra, well-posed with all necessary parameters provided, and objective in its formulation. We will proceed with a solution.\n\nThe core of the problem is to compute and compare analytic and numerical forces derived from a given potential energy function describing the coupling between a quantum mechanical (QM) atom and a molecular mechanical (MM) atom in a simplified QM/MM mechanical embedding scheme.\n\nThe coupling energy is given by:\n$$\nE_{\\text{couple}}(\\mathbf{r}_{\\mathrm{Q}}, \\mathbf{r}_{\\mathrm{M}}) = \\frac{k_{\\parallel}}{2}\\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right)^2 + \\frac{k_{\\perp}}{2}\\left\\| \\mathbf{P}_{\\perp}\\,\\Delta \\mathbf{r} \\right\\|^2\n$$\nwhere $\\mathbf{r}_{\\mathrm{Q}}$ and $\\mathbf{r}_{\\mathrm{M}}$ are the positions of the QM and MM atoms, $\\Delta \\mathbf{r} = \\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}$ is the relative displacement vector, $\\mathbf{u}$ is a normalized direction vector, $k_{\\parallel}$ and $k_{\\perp}$ are stiffness constants, $r_0$ is a target separation, and $\\mathbf{P}_{\\perp} = \\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}$ is the projection operator onto the plane perpendicular to $\\mathbf{u}$.\n\n### 1. Derivation of Analytic Forces\n\nForces are defined as the negative gradient of the potential energy with respect to the Cartesian coordinates of the atoms. The forces on the QM and MM atoms are, respectively:\n$$\n\\mathbf{F}_{\\mathrm{Q}} = -\\nabla_{\\mathbf{r}_{\\mathrm{Q}}} E_{\\text{couple}}\n$$\n$$\n\\mathbf{F}_{\\mathrm{M}} = -\\nabla_{\\mathbf{r}_{\\mathrm{M}}} E_{\\text{couple}}\n$$\nThe energy function $E_{\\text{couple}}$ depends only on the relative displacement $\\Delta \\mathbf{r} = \\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}$. Using the chain rule for vector differentiation, we have:\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{Q}}} E_{\\text{couple}}(\\Delta \\mathbf{r}) = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} \\cdot \\frac{\\partial (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})}{\\partial \\mathbf{r}_{\\mathrm{Q}}} = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} \\cdot \\mathbf{I} = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}}\n$$\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{M}}} E_{\\text{couple}}(\\Delta \\mathbf{r}) = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} \\cdot \\frac{\\partial (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})}{\\partial \\mathbf{r}_{\\mathrm{M}}} = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} \\cdot (-\\mathbf{I}) = -\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}}\n$$\nThis directly implies that $\\mathbf{F}_{\\mathrm{Q}} = - \\mathbf{F}_{\\mathrm{M}}$, which is a manifestation of Newton's third law for this internal conservative force.\n\nTo find the explicit form of the forces, we compute the gradient of $E_{\\text{couple}}$ with respect to $\\Delta \\mathbf{r}$. The energy is a sum of two terms, $E_{\\text{couple}} = E_{\\parallel} + E_{\\perp}$. We can differentiate them separately.\n\n**Axial Term ($E_{\\parallel}$):**\nThe axial term is $E_{\\parallel} = \\frac{k_{\\parallel}}{2}\\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right)^2$. Let $s(\\Delta \\mathbf{r}) = \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0$. The gradient of $s$ with respect to $\\Delta \\mathbf{r}$ is $\\nabla_{\\Delta \\mathbf{r}} s = \\mathbf{u}$. Using the chain rule:\n$$\n\\nabla_{\\Delta \\mathbf{r}} E_{\\parallel} = \\frac{d E_{\\parallel}}{d s} \\nabla_{\\Delta \\mathbf{r}} s = k_{\\parallel} s \\cdot \\mathbf{u} = k_{\\parallel} \\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u}\n$$\n\n**Transverse Term ($E_{\\perp}$):**\nThe transverse term is $E_{\\perp} = \\frac{k_{\\perp}}{2}\\left\\| \\mathbf{P}_{\\perp}\\,\\Delta \\mathbf{r} \\right\\|^2$. This can be written as a quadratic form. Since the projection operator $\\mathbf{P}_{\\perp}$ is symmetric ($\\mathbf{P}_{\\perp}^{\\top} = \\mathbf{P}_{\\perp}$) and idempotent ($\\mathbf{P}_{\\perp}^2 = \\mathbf{P}_{\\perp}$), we have:\n$$\nE_{\\perp} = \\frac{k_{\\perp}}{2} (\\mathbf{P}_{\\perp} \\Delta \\mathbf{r})^{\\top} (\\mathbf{P}_{\\perp} \\Delta \\mathbf{r}) = \\frac{k_{\\perp}}{2} \\Delta \\mathbf{r}^{\\top} \\mathbf{P}_{\\perp}^{\\top} \\mathbf{P}_{\\perp} \\Delta \\mathbf{r} = \\frac{k_{\\perp}}{2} \\Delta \\mathbf{r}^{\\top} \\mathbf{P}_{\\perp} \\Delta \\mathbf{r}\n$$\nThe gradient of a quadratic form $\\frac{1}{2}\\mathbf{x}^{\\top}\\mathbf{A}\\mathbf{x}$ with a symmetric matrix $\\mathbf{A}$ is $\\mathbf{A}\\mathbf{x}$. Therefore:\n$$\n\\nabla_{\\Delta \\mathbf{r}} E_{\\perp} = k_{\\perp} \\mathbf{P}_{\\perp} \\Delta \\mathbf{r}\n$$\n\n**Total Gradient and Analytic Forces:**\nCombining the gradients of the two terms:\n$$\n\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} = k_{\\parallel} \\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u} + k_{\\perp} \\mathbf{P}_{\\perp} \\Delta \\mathbf{r}\n$$\nSubstituting $\\mathbf{P}_{\\perp} = \\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}$, the full expression for the gradient is:\n$$\n\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} = k_{\\parallel} \\left( (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}) \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u} + k_{\\perp} (\\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}) (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})\n$$\nFinally, the analytic forces on the QM and MM atoms are:\n$$\n\\mathbf{F}_{\\mathrm{Q}}^{\\text{an}} = -\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} = - \\left[ k_{\\parallel} \\left( (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}) \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u} + k_{\\perp} (\\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}) (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}) \\right]\n$$\n$$\n\\mathbf{F}_{\\mathrm{M}}^{\\text{an}} = +\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} = k_{\\parallel} \\left( (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}) \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u} + k_{\\perp} (\\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}) (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})\n$$\n\n### 2. Numerical Force Calculation and Verification\n\nThe numerical forces are computed using the central finite difference approximation for the gradient. For the $i$-th Cartesian component ($i \\in \\{1,2,3\\}$) of the force on the QM atom, we have:\n$$\nF_{\\mathrm{Q},i}^{\\text{num}} \\approx -\\frac{E_{\\text{couple}}(\\mathbf{r}_{\\mathrm{Q}}+h\\,\\mathbf{e}_i, \\mathbf{r}_{\\mathrm{M}}) - E_{\\text{couple}}(\\mathbf{r}_{\\mathrm{Q}}-h\\,\\mathbf{e}_i, \\mathbf{r}_{\\mathrm{M}})}{2h}\n$$\nwhere $\\mathbf{e}_i$ is the $i$-th standard basis vector and $h$ is a small step size. A similar expression holds for $\\mathbf{F}_{\\mathrm{M}}^{\\text{num}}$ by perturbing the coordinates of $\\mathbf{r}_{\\mathrm{M}}$.\n\nThe verification process involves two checks:\n1.  **Consistency Check**: We compute the maximum absolute component-wise discrepancy between the analytic and numerical forces across both atoms.\n    $$\n    \\text{discrepancy} = \\max_{j \\in \\{\\mathrm{Q}, \\mathrm{M}\\}, i \\in \\{1,2,3\\}} \\left| F_{j,i}^{\\text{an}} - F_{j,i}^{\\text{num}} \\right|\n    $$\n2.  **Newton's Third Law Check**: We verify that the sum of the numerical forces is close to zero, which is a property of forces derived from a potential dependent only on relative positions. We check if the infinity norm of the sum is within a given tolerance $\\tau$.\n    $$\n    \\left\\| \\mathbf{F}_{\\mathrm{Q}}^{\\text{num}} + \\mathbf{F}_{\\mathrm{M}}^{\\text{num}} \\right\\|_{\\infty} = \\max_{i \\in \\{1,2,3\\}} \\left| F_{\\mathrm{Q},i}^{\\text{num}} + F_{\\mathrm{M},i}^{\\text{num}} \\right| \\le \\tau\n    $$\nFor a potential $E(\\mathbf{r}_{\\mathrm{Q}}, \\mathbf{r}_{\\mathrm{M}}) = E(\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})$, the central difference approximation yields $F_{\\mathrm{Q},i}^{\\text{num}} + F_{\\mathrm{M},i}^{\\text{num}} = 0$ in exact arithmetic. Any non-zero result is due to floating-point representation errors.\n\nThe implementation will follow these derived formulas and verification procedures for each test case provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the QM/MM mechanical embedding force calculation problem\n    for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"r_Q\": np.array([0.8, -0.2, 0.3]),\n            \"r_M\": np.array([-0.4, 0.5, 0.1]),\n            \"u\": np.array([1.0, 1.0, 0.5]),\n            \"r0\": 1.1,\n            \"k_par\": 120.0,\n            \"k_perp\": 80.0,\n        },\n        {\n            \"r_Q\": np.array([1.0, 0.0, 0.0]),\n            \"r_M\": np.array([0.0, 1.0, 0.0]),\n            \"u\": np.array([1.0, 0.0, 0.0]),\n            \"r0\": 1.0,\n            \"k_par\": 50.0,\n            \"k_perp\": 0.0,\n        },\n        {\n            \"r_Q\": np.array([0.0, 0.0, 0.0]),\n            \"r_M\": np.array([0.0, 0.0, 0.0]),\n            \"u\": np.array([0.0, 0.0, 1.0]),\n            \"r0\": 0.3,\n            \"k_par\": 30.0,\n            \"k_perp\": 10.0,\n        },\n    ]\n\n    h = 1e-6\n    tau = 1e-8\n    results = []\n\n    def coupling_energy(r_Q, r_M, u_norm, r0, k_par, k_perp):\n        \"\"\"Calculates the mechanical coupling energy E_couple.\"\"\"\n        delta_r = r_Q - r_M\n        \n        # Axial term\n        # E_par = (k_par / 2) * ( (delta_r . u) - r0 )^2\n        axial_proj = np.dot(delta_r, u_norm)\n        energy_par = 0.5 * k_par * (axial_proj - r0)**2\n        \n        # Transverse term\n        # E_perp = (k_perp / 2) * || P_perp * delta_r ||^2\n        # P_perp * delta_r = delta_r - u * (u . delta_r)\n        perp_proj_vec = delta_r - u_norm * axial_proj\n        energy_perp = 0.5 * k_perp * np.dot(perp_proj_vec, perp_proj_vec)\n        \n        return energy_par + energy_perp\n\n    for case in test_cases:\n        r_Q, r_M, u, r0, k_par, k_perp = (\n            case[\"r_Q\"], case[\"r_M\"], case[\"u\"], case[\"r0\"], case[\"k_par\"], case[\"k_perp\"]\n        )\n\n        u_norm = u / np.linalg.norm(u)\n        \n        # --- 1. Analytic Forces ---\n        delta_r = r_Q - r_M\n        axial_proj = np.dot(delta_r, u_norm)\n        perp_proj_vec = delta_r - u_norm * axial_proj\n        \n        # Gradient with respect to delta_r\n        grad_delta_r = (k_par * (axial_proj - r0) * u_norm) + (k_perp * perp_proj_vec)\n        \n        F_Q_an = -grad_delta_r\n        F_M_an = grad_delta_r\n        \n        # --- 2. Numerical Forces ---\n        F_Q_num = np.zeros(3)\n        F_M_num = np.zeros(3)\n        \n        for i in range(3):\n            e_i = np.zeros(3)\n            e_i[i] = 1.0\n            \n            # Perturb r_Q\n            r_Q_plus = r_Q + h * e_i\n            r_Q_minus = r_Q - h * e_i\n            E_plus_Q = coupling_energy(r_Q_plus, r_M, u_norm, r0, k_par, k_perp)\n            E_minus_Q = coupling_energy(r_Q_minus, r_M, u_norm, r0, k_par, k_perp)\n            F_Q_num[i] = -(E_plus_Q - E_minus_Q) / (2 * h)\n            \n            # Perturb r_M\n            r_M_plus = r_M + h * e_i\n            r_M_minus = r_M - h * e_i\n            E_plus_M = coupling_energy(r_Q, r_M_plus, u_norm, r0, k_par, k_perp)\n            E_minus_M = coupling_energy(r_Q, r_M_minus, u_norm, r0, k_par, k_perp)\n            F_M_num[i] = -(E_plus_M - E_minus_M) / (2 * h)\n            \n        # --- 3. Verification ---\n        # Discrepancy between analytic and numerical forces\n        diff_Q = np.abs(F_Q_an - F_Q_num)\n        diff_M = np.abs(F_M_an - F_M_num)\n        max_discrepancy = np.max(np.concatenate((diff_Q, diff_M)))\n        \n        # Check Newton's Third Law for numerical forces\n        force_sum = F_Q_num + F_M_num\n        norm_inf_sum = np.max(np.abs(force_sum))\n        newton_check = norm_inf_sum <= tau\n        \n        results.append(max_discrepancy)\n        results.append(newton_check)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "A mechanical model is only as good as its parameters. This exercise addresses the fundamental question of where the parameters for a QM/MM boundary interaction, such as stiffness $k$ and equilibrium position $x_0$, originate. You will perform a common task in multiscale modeling: fitting a simple, classical force model to reference data obtained from more accurate quantum mechanics calculations, thus ensuring the model's physical realism .",
            "id": "3823910",
            "problem": "Consider mechanical embedding in Quantum Mechanics/Molecular Mechanics (QM/MM), where the Mechanical Mechanics (MM) environment exerts boundary forces on the Quantum Mechanics (QM) region. Assume a one-dimensional harmonic mechanical embedding model for a single QM degree of freedom, in which the MM boundary exerts a force on the QM coordinate given by Hooke’s law, $f = -k(x - x_0)$, where $f$ is the force in electronvolt per ångström ($\\mathrm{eV}/\\mathrm{\\AA}$), $x$ is the coordinate in ångström ($\\mathrm{\\AA}$), $k$ is the stiffness in electronvolt per ångström squared ($\\mathrm{eV}/\\mathrm{\\AA}^{2}$), and $x_0$ is the equilibrium position in ångström ($\\mathrm{\\AA}$). Let a set of training configurations provide pairs $\\{(x_j, f_j)\\}_{j=1}^{n}$ derived from Quantum Mechanics force calculations, and a validation set provide pairs $\\{(x^{\\mathrm{val}}_i, f^{\\mathrm{val}}_i)\\}_{i=1}^{m}$ for held-out configurations. Define the reparameterization $b = k x_0$ so that $f_j = -k x_j + b$. The goal is to compute the optimal parameters $(k, x_0)$ in the least-squares sense on the training set and then predict the forces on the validation set to assess accuracy.\n\nStarting from the principle of linear superposition and Hooke’s law, and using the least-squares criterion, derive the optimality conditions for $(k,b)$ that minimize $\\sum_{j=1}^{n} (-k x_j + b - f_j)^2$. Then, implement a robust solver that uses the Moore–Penrose pseudoinverse to obtain the minimum-norm solution for $(k,b)$ even when the training design matrix is rank-deficient. After estimating $(k,b)$, recover $x_0$ via $x_0 = b/k$ when $k \\neq 0$, and define predictions on validation configurations as $f^{\\mathrm{pred}}_i = -k x^{\\mathrm{val}}_i + b$. Evaluate the validation mean absolute error as $\\mathrm{MAE} = \\frac{1}{m} \\sum_{i=1}^{m} | f^{\\mathrm{pred}}_i - f^{\\mathrm{val}}_i |$. All physical quantities must be handled with the specified units: $x$ in $\\mathrm{\\AA}$, $f$ in $\\mathrm{eV}/\\mathrm{\\AA}$, $k$ in $\\mathrm{eV}/\\mathrm{\\AA}^{2}$, and $\\mathrm{MAE}$ in $\\mathrm{eV}/\\mathrm{\\AA}$.\n\nYour program must solve the following three test cases, each containing a training set and a validation set:\n\nTest Case $1$ (well-conditioned training data with small deterministic noise):\n- Training positions $x$: $[0.8, 1.0, 1.2, 1.4]$ $\\mathrm{\\AA}$.\n- Training forces $f$: $[0.41, -0.02, -0.38, -0.81]$ $\\mathrm{eV}/\\mathrm{\\AA}$.\n- Validation positions $x^{\\mathrm{val}}$: $[0.9, 1.3]$ $\\mathrm{\\AA}$.\n- Validation forces $f^{\\mathrm{val}}$: $[0.21, -0.61]$ $\\mathrm{eV}/\\mathrm{\\AA}$.\n\nTest Case $2$ (near-zero stiffness):\n- Training positions $x$: $[-0.5, 0.0, 0.5]$ $\\mathrm{\\AA}$.\n- Training forces $f$: $[0.11, 0.0, -0.09]$ $\\mathrm{eV}/\\mathrm{\\AA}$.\n- Validation positions $x^{\\mathrm{val}}$: $[-1.0, 1.0]$ $\\mathrm{\\AA}$.\n- Validation forces $f^{\\mathrm{val}}$: $[0.19, -0.21]$ $\\mathrm{eV}/\\mathrm{\\AA}$.\n\nTest Case $3$ (rank-deficient training data where all positions are identical):\n- Training positions $x$: $[1.0, 1.0, 1.0, 1.0]$ $\\mathrm{\\AA}$.\n- Training forces $f$: $[-0.75, -0.75, -0.75, -0.75]$ $\\mathrm{eV}/\\mathrm{\\AA}$.\n- Validation positions $x^{\\mathrm{val}}$: $[0.8, 1.2]$ $\\mathrm{\\AA}$.\n- Validation forces $f^{\\mathrm{val}}$: $[-0.45, -1.05]$ $\\mathrm{eV}/\\mathrm{\\AA}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output three numbers in sequence: the estimated stiffness $k$ in $\\mathrm{eV}/\\mathrm{\\AA}^{2}$, the estimated equilibrium position $x_0$ in $\\mathrm{\\AA}$, and the validation mean absolute error in $\\mathrm{eV}/\\mathrm{\\AA}$. All numbers must be rounded to six decimal places, and the full output should therefore contain nine numbers corresponding to all three test cases in order, for example, $[k_1,x_{0,1},\\mathrm{MAE}_1,k_2,x_{0,2},\\mathrm{MAE}_2,k_3,x_{0,3},\\mathrm{MAE}_3]$.",
            "solution": "The problem statement has been meticulously validated and is determined to be **valid**. It is scientifically grounded, well-posed, objective, and internally consistent. It presents a standard problem in computational materials science—parameterizing a classical force field model from quantum mechanical data—and provides all necessary information to derive and implement a robust numerical solution.\n\nThe core of the problem is to determine the optimal parameters $(k, x_0)$ for a one-dimensional harmonic force model, $f = -k(x - x_0)$, based on a set of training data $\\{(x_j, f_j)\\}_{j=1}^{n}$. The model is reparameterized into a linear form $f_j = -k x_j + b$, where $b = k x_0$. This transformation allows us to employ the principles of linear least-squares regression.\n\nThe objective is to find the parameter vector $\\mathbf{p} = \\begin{pmatrix} k \\\\ b \\end{pmatrix}$ that minimizes the sum of squared errors, $S(\\mathbf{p})$, between the model's predictions and the provided training forces $f_j$.\nFor a set of $n$ training points, we can express the problem as an overdetermined system of linear equations:\n$$\n-k x_1 + b \\approx f_1 \\\\\n-k x_2 + b \\approx f_2 \\\\\n\\vdots \\\\\n-k x_n + b \\approx f_n \\\\\n$$\nThis system can be written in matrix form as $\\mathbf{A}\\mathbf{p} \\approx \\mathbf{y}$, where the design matrix $\\mathbf{A}$, the parameter vector $\\mathbf{p}$, and the observation vector $\\mathbf{y}$ are defined as:\n$$\n\\mathbf{A} = \\begin{pmatrix}\n-x_1 & 1 \\\\\n-x_2 & 1 \\\\\n\\vdots & \\vdots \\\\\n-x_n & 1\n\\end{pmatrix}, \\quad\n\\mathbf{p} = \\begin{pmatrix}\nk \\\\\nb\n\\end{pmatrix}, \\quad\n\\mathbf{y} = \\begin{pmatrix}\nf_1 \\\\\nf_2 \\\\\n\\vdots \\\\\nf_n\n\\end{pmatrix}\n$$\nThe least-squares criterion requires minimizing the squared Euclidean norm of the residual vector, $\\mathbf{r} = \\mathbf{A}\\mathbf{p} - \\mathbf{y}$:\n$$\nS(\\mathbf{p}) = \\|\\mathbf{r}\\|^2 = \\|\\mathbf{A}\\mathbf{p} - \\mathbf{y}\\|^2 = (\\mathbf{A}\\mathbf{p} - \\mathbf{y})^T(\\mathbf{A}\\mathbf{p} - \\mathbf{y})\n$$\nTo find the minimum, we set the gradient of $S(\\mathbf{p})$ with respect to $\\mathbf{p}$ to zero:\n$$\n\\nabla_{\\mathbf{p}} S(\\mathbf{p}) = \\nabla_{\\mathbf{p}} (\\mathbf{p}^T\\mathbf{A}^T\\mathbf{A}\\mathbf{p} - 2\\mathbf{p}^T\\mathbf{A}^T\\mathbf{y} + \\mathbf{y}^T\\mathbf{y}) = 2\\mathbf{A}^T\\mathbf{A}\\mathbf{p} - 2\\mathbf{A}^T\\mathbf{y} = \\mathbf{0}\n$$\nThis yields the celebrated normal equations:\n$$\n\\mathbf{A}^T\\mathbf{A}\\mathbf{p} = \\mathbf{A}^T\\mathbf{y}\n$$\nWhen the matrix $\\mathbf{A}^T\\mathbf{A}$ is invertible (i.e., when the columns of $\\mathbf{A}$ are linearly independent), there exists a unique solution for $\\mathbf{p}$:\n$$\n\\mathbf{p} = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T\\mathbf{y}\n$$\nThe problem specifies the use of the Moore-Penrose pseudoinverse, $\\mathbf{A}^+$, to solve for $\\mathbf{p}$. The solution is thus given by $\\mathbf{p} = \\mathbf{A}^+ \\mathbf{y}$. This approach is superior because it provides a unique solution even when $\\mathbf{A}^T\\mathbf{A}$ is singular. The matrix $\\mathbf{A}$ becomes rank-deficient if its columns are linearly dependent, which occurs if and only if all training positions $x_j$ are identical (as in Test Case $3$). In such a scenario, the normal equations admit infinitely many solutions. The Moore-Penrose pseudoinverse formalism resolves this ambiguity by yielding the unique solution vector $\\mathbf{p}$ that has the minimum Euclidean norm, $\\|\\mathbf{p}\\| = \\sqrt{k^2+b^2}$. This ensures a deterministic and robust outcome for any given training set.\n\nThe complete algorithmic procedure is as follows:\n$1$. For a given training set $\\{(x_j, f_j)\\}_{j=1}^{n}$, construct the $n \\times 2$ design matrix $\\mathbf{A}$ and the $n \\times 1$ observation vector $\\mathbf{y}$ as defined above.\n$2$. Compute the parameter vector $\\mathbf{p} = \\begin{pmatrix} k \\\\ b \\end{pmatrix}$ by solving the linear system using the Moore-Penrose pseudoinverse: $\\mathbf{p} = \\mathbf{A}^+ \\mathbf{y}$. The components of $\\mathbf{p}$ are the estimated stiffness $k$ and the intercept $b$.\n$3$. Recover the equilibrium position $x_0$ from the reparameterization $b = k x_0$. If $k \\neq 0$, then $x_0 = b/k$. If $k$ is zero or numerically indistinguishable from zero (e.g., $|k| < \\epsilon$ for a small tolerance $\\epsilon$), the concept of a unique equilibrium position becomes ill-defined as the force is constant, $f=b$. In this case, we assign $x_0 = 0.0$ as a neutral, conventional value.\n$4$. Using the determined parameters $(k, b)$, predict the forces $f^{\\mathrm{pred}}_i$ for each position $x^{\\mathrm{val}}_i$ in the validation set: $f^{\\mathrm{pred}}_i = -k x^{\\mathrm{val}}_i + b$.\n$5$. Evaluate the model's accuracy on the validation set by computing the Mean Absolute Error (MAE): $\\mathrm{MAE} = \\frac{1}{m} \\sum_{i=1}^{m} | f^{\\mathrm{pred}}_i - f^{\\mathrm{val}}_i |$, where $m$ is the number of data points in the validation set.\n\nThis procedure will be applied to each of the three test cases specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the parameters of a 1D harmonic mechanical embedding model\n    for three distinct test cases and evaluates the validation error.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"train_x\": np.array([0.8, 1.0, 1.2, 1.4]),\n            \"train_f\": np.array([0.41, -0.02, -0.38, -0.81]),\n            \"val_x\": np.array([0.9, 1.3]),\n            \"val_f\": np.array([0.21, -0.61]),\n        },\n        {\n            \"train_x\": np.array([-0.5, 0.0, 0.5]),\n            \"train_f\": np.array([0.11, 0.0, -0.09]),\n            \"val_x\": np.array([-1.0, 1.0]),\n            \"val_f\": np.array([0.19, -0.21]),\n        },\n        {\n            \"train_x\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"train_f\": np.array([-0.75, -0.75, -0.75, -0.75]),\n            \"val_x\": np.array([0.8, 1.2]),\n            \"val_f\": np.array([-0.45, -1.05]),\n        },\n    ]\n\n    all_results = []\n    \n    # Set a small tolerance for checking if k is close to zero\n    zero_tolerance = 1e-9\n\n    for case in test_cases:\n        # Extract data for the current case\n        x_train = case[\"train_x\"]\n        f_train = case[\"train_f\"]\n        x_val = case[\"val_x\"]\n        f_val = case[\"val_f\"]\n\n        # 1. Construct the design matrix A and observation vector y\n        # The model is f = -k*x + b, so the system is A * [k, b]^T = f\n        # Column for k has coefficients -x_j\n        # Column for b has coefficients 1\n        A = np.vstack([-x_train, np.ones(len(x_train))]).T\n        y = f_train\n\n        # 2. Solve for parameters [k, b] using the Moore-Penrose pseudoinverse\n        # This provides the minimum-norm least-squares solution, robust to rank deficiency\n        try:\n            p = np.linalg.pinv(A) @ y\n            k, b = p[0], p[1]\n        except np.linalg.LinAlgError:\n            # This case should not be reached with pinv, but as a safeguard\n            k, b = 0.0, 0.0\n\n        # 3. Recover equilibrium position x0\n        # If k is effectively zero, x0 is ill-defined. We set it to 0.0 by convention.\n        if abs(k) < zero_tolerance:\n            x0 = 0.0\n        else:\n            x0 = b / k\n\n        # 4. Predict forces on the validation set\n        f_pred = -k * x_val + b\n\n        # 5. Calculate validation Mean Absolute Error (MAE)\n        mae = np.mean(np.abs(f_pred - f_val))\n\n        # Append results for this case to the main list\n        all_results.extend([k, x0, mae])\n\n    # Format the final results to six decimal places and print in the required format\n    formatted_results = [\"{:.6f}\".format(r) for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Choosing a QM/MM embedding scheme involves a trade-off between computational cost and physical accuracy. This practice moves from implementation to interpretation, allowing you to quantify the physical consequences of selecting the simpler mechanical embedding over the more rigorous electrostatic embedding. By deriving how this choice impacts observables like reaction barriers, you will develop the critical judgment needed to select appropriate models for your research questions .",
            "id": "3823952",
            "problem": "Consider a simplified, first-principles model for comparing mechanical embedding and electrostatic embedding in a hybrid Quantum Mechanics/Molecular Mechanics (QM/MM) calculation. Quantum Mechanics/Molecular Mechanics (QM/MM) is a multiscale approach in which a small region is treated with quantum mechanics and its environment with classical molecular mechanics. In mechanical embedding, the quantum region does not experience the electrostatic field of the molecular mechanics environment; only non-electrostatic mechanical coupling is present. In electrostatic embedding, the quantum region experiences the electrostatic field of the molecular mechanics environment and polarizes in response. Assume a one-dimensional, uniform external electric field of magnitude $\\mathcal{E}$ (in atomic units), aligned with the permanent dipoles of all states so that all vector quantities reduce to signed scalars.\n\nUse the following well-tested physical facts as the fundamental base:\n- The total Born–Oppenheimer energy is the expectation value of the electronic Hamiltonian plus classical molecular mechanics contributions. For observables that are energy differences between two stationary states, any state-independent additive constant cancels.\n- The interaction energy of a permanent dipole $\\mu$ (in atomic units) with a uniform electric field $\\mathcal{E}$ (in atomic units) is $-\\mu\\,\\mathcal{E}$.\n- In linear response, the polarization energy of an isotropic polarizable entity with polarizability $\\alpha$ (in atomic units) in a uniform field $\\mathcal{E}$ is $-\\tfrac{1}{2}\\alpha\\,\\mathcal{E}^{2}$.\n\nAssume that non-electrostatic van der Waals coupling is state-independent for each observable and therefore cancels when computing the energy differences defined below. Let $E_{\\mathrm{ME}}(s)$ denote the energy of state $s$ under mechanical embedding, and let $E_{\\mathrm{EE}}(s)$ denote the energy of state $s$ under electrostatic embedding. For a state $s$, let $\\mu_{s}$ be its permanent dipole (signed scalar, in atomic units) and $\\alpha_{s}$ be its isotropic polarizability (in atomic units).\n\nTwo observables are to be compared:\n- A reaction barrier, defined as the energy difference between a transition state and a reactant, $E_{\\mathrm{barrier}} = E(\\mathrm{TS}) - E(\\mathrm{R})$.\n- A defect formation energy, defined as the energy difference between a defective state and a bulk reference, $E_{\\mathrm{defect}} = E(\\mathrm{D}) - E(\\mathrm{B})$.\n\nYour tasks are:\n1. Using the stated physical facts, derive from first principles an expression for the difference between electrostatic embedding and mechanical embedding for each observable, decomposed into its contributing terms that arise from the permanent dipole interaction and from the polarization energy. Explicitly, you must express the difference between the observable under electrostatic embedding and mechanical embedding in terms of $\\mu_{s}$, $\\alpha_{s}$, and $\\mathcal{E}$ for the relevant pair of states.\n2. Implement a program that, for each test case below, computes:\n   - The reaction barrier difference between electrostatic embedding and mechanical embedding, in Hartree.\n   - The contribution of the permanent dipole interaction to this barrier difference, in Hartree.\n   - The contribution of the polarization energy to this barrier difference, in Hartree.\n   - The defect formation energy difference between electrostatic embedding and mechanical embedding, in Hartree.\n   - The contribution of the permanent dipole interaction to this defect difference, in Hartree.\n   - The contribution of the polarization energy to this defect difference, in Hartree.\n3. The program must aggregate the six numbers per test case into a list in the order given above. It must produce a single line of output containing a list of these per-test-case lists, with each number rounded to eight decimal places, in Hartree.\n\nAll quantities use atomic units. Energy must be reported in Hartree, rounded to eight decimal places.\n\nTest suite (three cases designed for coverage):\n- Case A (boundary: zero field, all differences must vanish):\n  - $\\mathcal{E} = 0.00000000$\n  - $\\mu_{\\mathrm{R}} = 0.50000000$, $\\mu_{\\mathrm{TS}} = 0.70000000$, $\\mu_{\\mathrm{B}} = 0.30000000$, $\\mu_{\\mathrm{D}} = 0.90000000$\n  - $\\alpha_{\\mathrm{R}} = 10.00000000$, $\\alpha_{\\mathrm{TS}} = 9.50000000$, $\\alpha_{\\mathrm{B}} = 8.00000000$, $\\alpha_{\\mathrm{D}} = 12.00000000$\n- Case B (happy path: nonzero field with different permanent dipoles and polarizabilities):\n  - $\\mathcal{E} = 0.01000000$\n  - $\\mu_{\\mathrm{R}} = 0.40000000$, $\\mu_{\\mathrm{TS}} = 1.10000000$, $\\mu_{\\mathrm{B}} = 0.50000000$, $\\mu_{\\mathrm{D}} = 0.20000000$\n  - $\\alpha_{\\mathrm{R}} = 9.00000000$, $\\alpha_{\\mathrm{TS}} = 11.00000000$, $\\alpha_{\\mathrm{B}} = 7.00000000$, $\\alpha_{\\mathrm{D}} = 13.00000000$\n- Case C (edge features: negative field, equal permanent dipoles for the barrier pair, equal polarizabilities for the defect pair):\n  - $\\mathcal{E} = -0.02000000$\n  - $\\mu_{\\mathrm{R}} = 0.60000000$, $\\mu_{\\mathrm{TS}} = 0.60000000$, $\\mu_{\\mathrm{B}} = 1.20000000$, $\\mu_{\\mathrm{D}} = 0.80000000$\n  - $\\alpha_{\\mathrm{R}} = 10.00000000$, $\\alpha_{\\mathrm{TS}} = 14.00000000$, $\\alpha_{\\mathrm{B}} = 9.00000000$, $\\alpha_{\\mathrm{D}} = 9.00000000$\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a six-number list for a test case in the order described above. For example, an output with two hypothetical cases would look like $[[x_{1},x_{2},x_{3},x_{4},x_{5},x_{6}],[y_{1},y_{2},y_{3},y_{4},y_{5},y_{6}]]$, but with actual numbers rounded to eight decimal places. No additional text should be printed.",
            "solution": "The problem statement has been critically validated and is deemed valid. It is scientifically grounded in the principles of multiscale QM/MM simulations, is well-posed with all necessary data and definitions provided, and is expressed in objective, formal language. The problem is self-contained, consistent, and requires the application of fundamental principles to derive and compute specific physical quantities, representing a well-structured exercise in computational physics/chemistry.\n\nThe derivation of the required expressions from first principles proceeds as follows.\n\nLet $E_{0}(s)$ represent the intrinsic energy of the quantum mechanical (QM) system in a given state $s$, as would be calculated in isolation (i.e., in the gas phase). Per the problem statement, we consider two embedding schemes for the QM/MM calculation.\n\nIn **mechanical embedding (ME)**, the QM region is coupled to the molecular mechanics (MM) environment only through non-electrostatic interactions. These are assumed to be described by a state-independent potential energy term $V_{\\mathrm{mech}}$, which cancels when calculating energy differences between states. The total energy of a state $s$ under ME is thus:\n$$E_{\\mathrm{ME}}(s) = E_{0}(s) + V_{\\mathrm{mech}}$$\n\nIn **electrostatic embedding (EE)**, the QM region additionally interacts with the electrostatic field, $\\mathcal{E}$, generated by the MM environment. The problem specifies that this interaction energy consists of two components:\n$1$. The interaction of the state's permanent dipole moment, $\\mu_{s}$, with the field $\\mathcal{E}$, given by the energy term $-\\mu_{s}\\mathcal{E}$.\n$2$. The polarization of the QM system's electron density by the field $\\mathcal{E}$, which results in an energy contribution of $-\\frac{1}{2}\\alpha_{s}\\mathcal{E}^{2}$, where $\\alpha_{s}$ is the state's isotropic polarizability.\n\nTherefore, the total energy of a state $s$ under EE is:\n$$E_{\\mathrm{EE}}(s) = E_{0}(s) + V_{\\mathrm{mech}} - \\mu_{s}\\mathcal{E} - \\frac{1}{2}\\alpha_{s}\\mathcal{E}^{2}$$\n\nThe difference in the description of a single state $s$ between the two embedding schemes is the total electrostatic interaction energy:\n$$\\Delta E(s) = E_{\\mathrm{EE}}(s) - E_{\\mathrm{ME}}(s) = \\left( E_{0}(s) + V_{\\mathrm{mech}} - \\mu_{s}\\mathcal{E} - \\frac{1}{2}\\alpha_{s}\\mathcal{E}^{2} \\right) - \\left( E_{0}(s) + V_{\\mathrm{mech}} \\right)$$\n$$\\Delta E(s) = - \\mu_{s}\\mathcal{E} - \\frac{1}{2}\\alpha_{s}\\mathcal{E}^{2}$$\n\nWe are asked to find the difference in two specific observables: a reaction barrier and a defect formation energy.\n\n**1. Reaction Barrier**\n\nThe reaction barrier is defined as the energy difference $E_{\\mathrm{barrier}} = E(\\mathrm{TS}) - E(\\mathrm{R})$, where $\\mathrm{TS}$ is the transition state and $\\mathrm{R}$ is the reactant state.\n\nUnder ME, the barrier is:\n$$E_{\\mathrm{barrier}}^{\\mathrm{ME}} = E_{\\mathrm{ME}}(\\mathrm{TS}) - E_{\\mathrm{ME}}(\\mathrm{R}) = (E_{0}(\\mathrm{TS}) + V_{\\mathrm{mech}}) - (E_{0}(\\mathrm{R}) + V_{\\mathrm{mech}}) = E_{0}(\\mathrm{TS}) - E_{0}(\\mathrm{R})$$\n\nUnder EE, the barrier is:\n$$E_{\\mathrm{barrier}}^{\\mathrm{EE}} = E_{\\mathrm{EE}}(\\mathrm{TS}) - E_{\\mathrm{EE}}(\\mathrm{R})$$\n$$E_{\\mathrm{barrier}}^{\\mathrm{EE}} = \\left( E_{0}(\\mathrm{TS}) - \\mu_{\\mathrm{TS}}\\mathcal{E} - \\frac{1}{2}\\alpha_{\\mathrm{TS}}\\mathcal{E}^{2} \\right) - \\left( E_{0}(\\mathrm{R}) - \\mu_{\\mathrm{R}}\\mathcal{E} - \\frac{1}{2}\\alpha_{\\mathrm{R}}\\mathcal{E}^{2} \\right)$$\n$$E_{\\mathrm{barrier}}^{\\mathrm{EE}} = (E_{0}(\\mathrm{TS}) - E_{0}(\\mathrm{R})) - (\\mu_{\\mathrm{TS}} - \\mu_{\\mathrm{R}})\\mathcal{E} - \\frac{1}{2}(\\alpha_{\\mathrm{TS}} - \\alpha_{\\mathrm{R}})\\mathcal{E}^{2}$$\n\nThe difference between the barrier calculated with EE and ME is the quantity of interest:\n$$\\Delta(E_{\\mathrm{barrier}}) = E_{\\mathrm{barrier}}^{\\mathrm{EE}} - E_{\\mathrm{barrier}}^{\\mathrm{ME}}$$\n$$\\Delta(E_{\\mathrm{barrier}}) = \\left[ (E_{0}(\\mathrm{TS}) - E_{0}(\\mathrm{R})) - (\\mu_{\\mathrm{TS}} - \\mu_{\\mathrm{R}})\\mathcal{E} - \\frac{1}{2}(\\alpha_{\\mathrm{TS}} - \\alpha_{\\mathrm{R}})\\mathcal{E}^{2} \\right] - [E_{0}(\\mathrm{TS}) - E_{0}(\\mathrm{R})]$$\n$$\\Delta(E_{\\mathrm{barrier}}) = - (\\mu_{\\mathrm{TS}} - \\mu_{\\mathrm{R}})\\mathcal{E} - \\frac{1}{2}(\\alpha_{\\mathrm{TS}} - \\alpha_{\\mathrm{R}})\\mathcal{E}^{2}$$\n\nThis total difference can be decomposed into two contributions as requested:\n- Contribution from permanent dipole interactions: $\\Delta(E_{\\mathrm{barrier}})_{\\mu} = - (\\mu_{\\mathrm{TS}} - \\mu_{\\mathrm{R}})\\mathcal{E}$\n- Contribution from polarization energy: $\\Delta(E_{\\mathrm{barrier}})_{\\alpha} = - \\frac{1}{2}(\\alpha_{\\mathrm{TS}} - \\alpha_{\\mathrm{R}})\\mathcal{E}^{2}$\n\n**2. Defect Formation Energy**\n\nThe defect formation energy is defined as $E_{\\mathrm{defect}} = E(\\mathrm{D}) - E(\\mathrm{B})$, where $\\mathrm{D}$ is the defective state and $\\mathrm{B}$ is the bulk reference state. The derivation is perfectly analogous to that of the reaction barrier.\n\nUnder ME:\n$$E_{\\mathrm{defect}}^{\\mathrm{ME}} = E_{\\mathrm{ME}}(\\mathrm{D}) - E_{\\mathrm{ME}}(\\mathrm{B}) = E_{0}(\\mathrm{D}) - E_{0}(\\mathrm{B})$$\n\nUnder EE:\n$$E_{\\mathrm{defect}}^{\\mathrm{EE}} = E_{\\mathrm{EE}}(\\mathrm{D}) - E_{\\mathrm{EE}}(\\mathrm{B})$$\n$$E_{\\mathrm{defect}}^{\\mathrm{EE}} = (E_{0}(\\mathrm{D}) - E_{0}(\\mathrm{B})) - (\\mu_{\\mathrm{D}} - \\mu_{\\mathrm{B}})\\mathcal{E} - \\frac{1}{2}(\\alpha_{\\mathrm{D}} - \\alpha_{\\mathrm{B}})\\mathcal{E}^{2}$$\n\nThe difference between the defect energy calculated with EE and ME is:\n$$\\Delta(E_{\\mathrm{defect}}) = E_{\\mathrm{defect}}^{\\mathrm{EE}} - E_{\\mathrm{defect}}^{\\mathrm{ME}}$$\n$$\\Delta(E_{\\mathrm{defect}}) = - (\\mu_{\\mathrm{D}} - \\mu_{\\mathrm{B}})\\mathcal{E} - \\frac{1}{2}(\\alpha_{\\mathrm{D}} - \\alpha_{\\mathrm{B}})\\mathcal{E}^{2}$$\n\nThis total difference is decomposed into:\n- Contribution from permanent dipole interactions: $\\Delta(E_{\\mathrm{defect}})_{\\mu} = - (\\mu_{\\mathrm{D}} - \\mu_{\\mathrm{B}})\\mathcal{E}$\n- Contribution from polarization energy: $\\Delta(E_{\\mathrm{defect}})_{\\alpha} = - \\frac{1}{2}(\\alpha_{\\mathrm{D}} - \\alpha_{\\mathrm{B}})\\mathcal{E}^{2}$\n\nThese derived formulas will be implemented to compute the required quantities for the provided test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the QM/MM embedding problem by deriving and applying formulas for the\n    difference between electrostatic and mechanical embedding for two observables.\n    \"\"\"\n    \n    # Test suite data structured for clarity. Each tuple contains:\n    # (E_field, mu_R, mu_TS, mu_B, mu_D, alpha_R, alpha_TS, alpha_B, alpha_D)\n    # All quantities are in atomic units.\n    test_cases = [\n        # Case A (boundary: zero field)\n        (0.00000000, \n         0.50000000, 0.70000000, 0.30000000, 0.90000000, \n         10.00000000, 9.50000000, 8.00000000, 12.00000000),\n        # Case B (happy path: nonzero field)\n        (0.01000000, \n         0.40000000, 1.10000000, 0.50000000, 0.20000000, \n         9.00000000, 11.00000000, 7.00000000, 13.00000000),\n        # Case C (edge features: negative field, specific equalities)\n        (-0.02000000, \n         0.60000000, 0.60000000, 1.20000000, 0.80000000, \n         10.00000000, 14.00000000, 9.00000000, 9.00000000),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        E_field, mu_R, mu_TS, mu_B, mu_D, alpha_R, alpha_TS, alpha_B, alpha_D = case\n        case_results = []\n\n        # --- 1. Reaction Barrier Calculation ---\n        # The observable is E(TS) - E(R)\n        # The states are initial=R, final=TS\n        mu_diff_barrier = mu_TS - mu_R\n        alpha_diff_barrier = alpha_TS - alpha_R\n        \n        # Contribution of the permanent dipole interaction to the barrier difference\n        dipole_contrib_barrier = -mu_diff_barrier * E_field\n        \n        # Contribution of the polarization energy to the barrier difference\n        polarization_contrib_barrier = -0.5 * alpha_diff_barrier * E_field**2\n        \n        # Total reaction barrier difference between EE and ME\n        total_diff_barrier = dipole_contrib_barrier + polarization_contrib_barrier\n        \n        case_results.extend([\n            total_diff_barrier,\n            dipole_contrib_barrier,\n            polarization_contrib_barrier\n        ])\n\n        # --- 2. Defect Formation Energy Calculation ---\n        # The observable is E(D) - E(B)\n        # The states are initial=B, final=D\n        mu_diff_defect = mu_D - mu_B\n        alpha_diff_defect = alpha_D - alpha_B\n        \n        # Contribution of the permanent dipole interaction to the defect difference\n        dipole_contrib_defect = -mu_diff_defect * E_field\n        \n        # Contribution of the polarization energy to the defect difference\n        polarization_contrib_defect = -0.5 * alpha_diff_defect * E_field**2\n        \n        # Total defect formation energy difference between EE and ME\n        total_diff_defect = dipole_contrib_defect + polarization_contrib_defect\n\n        case_results.extend([\n            total_diff_defect,\n            dipole_contrib_defect,\n            polarization_contrib_defect\n        ])\n        \n        all_results.append(case_results)\n\n    # Format the final output string to match the exact requirement:\n    # A list of lists, with each number rounded to 8 decimal places,\n    # and no spaces within the lists. e.g., [[n1,n2,...],[m1,m2,...]]\n    formatted_cases = []\n    for case_res in all_results:\n        # Format each number in the list to a string with 8 decimal places\n        num_strs = [f\"{num:.8f}\" for num in case_res]\n        # Join the numbers with a comma and enclose in brackets\n        case_str = f\"[{','.join(num_strs)}]\"\n        formatted_cases.append(case_str)\n    \n    # Join the formatted case strings with a comma and enclose in brackets\n    final_output = f\"[{','.join(formatted_cases)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}