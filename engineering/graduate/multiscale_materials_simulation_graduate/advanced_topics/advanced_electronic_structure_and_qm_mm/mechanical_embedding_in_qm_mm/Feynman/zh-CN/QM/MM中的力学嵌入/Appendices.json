{
    "hands_on_practices": [
        {
            "introduction": "任何分子模拟的核心都是从势能函数中准确计算力。对于QM/MM方法，连接量子与经典两个区域的耦合项至关重要。本练习提供了一个实施这种耦合的基础实践，通过推导解析力并将其与数值梯度进行比较，您将执行一个关键的验证步骤，以确保任何模拟代码的正确性。这个过程可以培养您在理论推导和实际编程方面的核心技能。",
            "id": "3823974",
            "problem": "你的任务是为量子力学/分子力学 (QM/MM) 中的一个简化机械嵌入方案实现并验证数值力计算。量子力学/分子力学 (QM/MM) 是一种多尺度策略，它将一个系统划分为一个量子力学区域和一个分子力学区域，并通过界面耦合能来保证边界上的结构一致性。在机械嵌入中，耦合纯粹通过机械（弹性）项实现，分子力学区域不对量子力学区域产生直接的静电极化作用。\n\n考虑两个边界原子：一个量子力学边界原子，其位置向量为 $\\mathbf{r}_{\\mathrm{Q}} \\in \\mathbb{R}^{3}$；一个分子力学边界原子，其位置向量为 $\\mathbf{r}_{\\mathrm{M}} \\in \\mathbb{R}^{3}$。设 $\\mathbf{u} \\in \\mathbb{R}^{3}$ 是一个取自参考边界键方向的固定单位方向向量（假定已归一化），并令 $\\Delta \\mathbf{r} = \\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}$ 表示相对位移。定义沿 $\\mathbf{u}$ 方向的轴向投影算符为 $\\mathbf{P}_{\\parallel} = \\mathbf{u}\\mathbf{u}^{\\top}$，垂直投影算符为 $\\mathbf{P}_{\\perp} = \\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}$，其中 $\\mathbf{I}$ 是 $\\mathbb{R}^{3 \\times 3}$ 中的单位矩阵。\n\n机械耦合能定义为\n$$\nE_{\\text{couple}}(\\mathbf{r}_{\\mathrm{Q}}, \\mathbf{r}_{\\mathrm{M}}) = \\frac{k_{\\parallel}}{2}\\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right)^2 + \\frac{k_{\\perp}}{2}\\left\\| \\mathbf{P}_{\\perp}\\,\\Delta \\mathbf{r} \\right\\|^2,\n$$\n其中 $k_{\\parallel} > 0$ 是轴向刚度，$k_{\\perp} \\ge 0$ 是横向刚度，$r_0 \\ge 0$ 是沿 $\\mathbf{u}$ 方向的目标轴向分离距离。力的定义为能量相对于笛卡尔坐标的负梯度，这与功能原理和 Newton 运动定律相一致。\n\n你的程序必须：\n- 使用一个小的步长 $h$，通过对能量 $E_{\\text{couple}}$ 应用中心有限差分法，计算量子力学边界原子和分子力学边界原子上的数值力。\n- 基于 $E_{\\text{couple}}$ 的定义，推导、实现并使用解析力表达式（你必须从第一性原理推导这些表达式；除了核心的微积分和线性代数知识外，不得使用或假设任何预先给定的梯度公式）。\n- 通过比较数值力和解析力并量化其差异，来验证一致性。\n- 通过检查两个边界原子上的力之和是否近似为零，来验证 Newton 第三定律。\n\n所有量在约化单位制中都是无量纲的，因此不需要进行物理单位转换。计算中不使用角度，也不需要角度单位。\n\n数值方法细节：\n- 对每个笛卡尔分量使用中心差分。例如，量子力学边界原子上的力分量满足 $F_{\\mathrm{Q},i} \\approx -\\left(E(\\mathbf{r}_{\\mathrm{Q}}+h\\,\\mathbf{e}_i,\\mathbf{r}_{\\mathrm{M}})-E(\\mathbf{r}_{\\mathrm{Q}}-h\\,\\mathbf{e}_i,\\mathbf{r}_{\\mathrm{M}})\\right)/(2h)$，其中 $\\mathbf{e}_i$ 是 $\\mathbb{R}^{3}$ 中的第 $i$ 个标准基向量，$i \\in \\{1,2,3\\}$。一个类似的表达式适用于分子力学边界原子的力分量，只需对 $\\mathbf{r}_{\\mathrm{M}}$ 施加扰动。\n- 使用一个容差 $\\tau$ 来评估 Newton 第三定律，检查 $\\mathbf{F}_{\\mathrm{Q}} + \\mathbf{F}_{\\mathrm{M}}$ 的无穷范数是否小于或等于 $\\tau$。\n\n测试套件：\n为以下三个测试用例实现计算，这些用例旨在覆盖不同的几何和刚度条件：\n1. 一般配置（理想路径）：\n   - $\\mathbf{r}_{\\mathrm{Q}} = [0.8, -0.2, 0.3]$，$\\mathbf{r}_{\\mathrm{M}} = [-0.4, 0.5, 0.1]$，\n   - $\\mathbf{u} = [1.0, 1.0, 0.5]$ （在计算中使用归一化后的向量），\n   - $r_0 = 1.1$，$k_{\\parallel} = 120.0$，$k_{\\perp} = 80.0$。\n2. 纯轴向耦合（横向刚度为零的边界情况）：\n   - $\\mathbf{r}_{\\mathrm{Q}} = [1.0, 0.0, 0.0]$，$\\mathbf{r}_{\\mathrm{M}} = [0.0, 1.0, 0.0]$，\n   - $\\mathbf{u} = [1.0, 0.0, 0.0]$ （在计算中使用归一化后的向量），\n   - $r_0 = 1.0$，$k_{\\parallel} = 50.0$，$k_{\\perp} = 0.0$。\n3. 目标轴向分离距离不为零的简并位移：\n   - $\\mathbf{r}_{\\mathrm{Q}} = [0.0, 0.0, 0.0]$，$\\mathbf{r}_{\\mathrm{M}} = [0.0, 0.0, 0.0]$，\n   - $\\mathbf{u} = [0.0, 0.0, 1.0]$ （在计算中使用归一化后的向量），\n   - $r_0 = 0.3$，$k_{\\parallel} = 30.0$，$k_{\\perp} = 10.0$。\n\n算法参数：\n- 对于中心差分，使用 $h = 10^{-6}$。\n- 对于 Newton 第三定律的检查，使用 $\\tau = 10^{-8}$。\n\n对于每个测试用例，计算：\n- 数值力和解析力在两个原子上的逐分量最大绝对差异，以单个浮点数表示。\n- 一个布尔值，指示数值力是否在容差范围内满足 Newton 第三定律，即 $\\left\\|\\mathbf{F}_{\\mathrm{Q}}^{\\text{num}} + \\mathbf{F}_{\\mathrm{M}}^{\\text{num}} \\right\\|_{\\infty} \\le \\tau$ 是否成立。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含三个测试用例的每一个的结果，首先是浮点数差异，然后是 Newton 第三定律检查的布尔值。例如，输出应类似于 $[\\text{error}_1,\\text{consistent}_1,\\text{error}_2,\\text{consistent}_2,\\text{error}_3,\\text{consistent}_3]$，其中 $\\text{error}_i$ 是一个浮点数，$\\text{consistent}_i$ 是 True 或 False。",
            "solution": "该问题被认为是有效的，因为它在科学上基于经典力学和线性代数，所有必要的参数都已提供，问题是良定的，并且其表述是客观的。我们将着手提供一个解决方案。\n\n问题的核心是，在一个简化的 QM/MM 机械嵌入方案中，根据一个给定的描述量子力学 (QM) 原子和分子力学 (MM) 原子之间耦合的势能函数，计算并比较解析力和数值力。\n\n耦合能由下式给出：\n$$\nE_{\\text{couple}}(\\mathbf{r}_{\\mathrm{Q}}, \\mathbf{r}_{\\mathrm{M}}) = \\frac{k_{\\parallel}}{2}\\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right)^2 + \\frac{k_{\\perp}}{2}\\left\\| \\mathbf{P}_{\\perp}\\,\\Delta \\mathbf{r} \\right\\|^2\n$$\n其中 $\\mathbf{r}_{\\mathrm{Q}}$ 和 $\\mathbf{r}_{\\mathrm{M}}$ 是 QM 和 MM 原子的位置，$\\Delta \\mathbf{r} = \\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}$ 是相对位移向量，$\\mathbf{u}$ 是一个归一化的方向向量，$k_{\\parallel}$ 和 $k_{\\perp}$ 是刚度常数，$r_0$ 是一个目标分离距离，$\\mathbf{P}_{\\perp} = \\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}$ 是投影到垂直于 $\\mathbf{u}$ 的平面上的投影算符。\n\n### 1. 解析力的推导\n\n力的定义为势能相对于原子笛卡尔坐标的负梯度。QM 和 MM 原子上的力分别为：\n$$\n\\mathbf{F}_{\\mathrm{Q}} = -\\nabla_{\\mathbf{r}_{\\mathrm{Q}}} E_{\\text{couple}}\n$$\n$$\n\\mathbf{F}_{\\mathrm{M}} = -\\nabla_{\\mathbf{r}_{\\mathrm{M}}} E_{\\text{couple}}\n$$\n能量函数 $E_{\\text{couple}}$ 仅取决于相对位移 $\\Delta \\mathbf{r} = \\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}$。使用向量微分的链式法则，我们有：\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{Q}}} E_{\\text{couple}}(\\Delta \\mathbf{r}) = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} \\cdot \\frac{\\partial (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})}{\\partial \\mathbf{r}_{\\mathrm{Q}}} = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} \\cdot \\mathbf{I} = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}}\n$$\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{M}}} E_{\\text{couple}}(\\Delta \\mathbf{r}) = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} \\cdot \\frac{\\partial (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})}{\\partial \\mathbf{r}_{\\mathrm{M}}} = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} \\cdot (-\\mathbf{I}) = -\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}}\n$$\n这直接意味着 $\\mathbf{F}_{\\mathrm{Q}} = - \\mathbf{F}_{\\mathrm{M}}$，这是该内保守力遵循 Newton 第三定律的体现。\n\n为了找到力的显式形式，我们计算 $E_{\\text{couple}}$ 相对于 $\\Delta \\mathbf{r}$ 的梯度。能量是两项之和，$E_{\\text{couple}} = E_{\\parallel} + E_{\\perp}$。我们可以分别对它们进行微分。\n\n**轴向项 ($E_{\\parallel}$):**\n轴向项为 $E_{\\parallel} = \\frac{k_{\\parallel}}{2}\\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right)^2$。令 $s(\\Delta \\mathbf{r}) = \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0$。$s$ 相对于 $\\Delta \\mathbf{r}$ 的梯度是 $\\nabla_{\\Delta \\mathbf{r}} s = \\mathbf{u}$。使用链式法则：\n$$\n\\nabla_{\\Delta \\mathbf{r}} E_{\\parallel} = \\frac{d E_{\\parallel}}{d s} \\nabla_{\\Delta \\mathbf{r}} s = k_{\\parallel} s \\cdot \\mathbf{u} = k_{\\parallel} \\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u}\n$$\n\n**横向项 ($E_{\\perp}$):**\n横向项为 $E_{\\perp} = \\frac{k_{\\perp}}{2}\\left\\| \\mathbf{P}_{\\perp}\\,\\Delta \\mathbf{r} \\right\\|^2$。这可以写成一个二次型。由于投影算符 $\\mathbf{P}_{\\perp}$ 是对称的（$\\mathbf{P}_{\\perp}^{\\top} = \\mathbf{P}_{\\perp}$）和幂等的（$\\mathbf{P}_{\\perp}^2 = \\mathbf{P}_{\\perp}$），我们有：\n$$\nE_{\\perp} = \\frac{k_{\\perp}}{2} (\\mathbf{P}_{\\perp} \\Delta \\mathbf{r})^{\\top} (\\mathbf{P}_{\\perp} \\Delta \\mathbf{r}) = \\frac{k_{\\perp}}{2} \\Delta \\mathbf{r}^{\\top} \\mathbf{P}_{\\perp}^{\\top} \\mathbf{P}_{\\perp} \\Delta \\mathbf{r} = \\frac{k_{\\perp}}{2} \\Delta \\mathbf{r}^{\\top} \\mathbf{P}_{\\perp} \\Delta \\mathbf{r}\n$$\n对于一个对称矩阵 $\\mathbf{A}$，二次型 $\\frac{1}{2}\\mathbf{x}^{\\top}\\mathbf{A}\\mathbf{x}$ 的梯度是 $\\mathbf{A}\\mathbf{x}$。因此：\n$$\n\\nabla_{\\Delta \\mathbf{r}} E_{\\perp} = k_{\\perp} \\mathbf{P}_{\\perp} \\Delta \\mathbf{r}\n$$\n\n**总梯度和解析力：**\n结合这两项的梯度：\n$$\n\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} = k_{\\parallel} \\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u} + k_{\\perp} \\mathbf{P}_{\\perp} \\Delta \\mathbf{r}\n$$\n代入 $\\mathbf{P}_{\\perp} = \\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}$，梯度的完整表达式是：\n$$\n\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} = k_{\\parallel} \\left( (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}) \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u} + k_{\\perp} (\\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}) (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})\n$$\n最后，QM 和 MM 原子上的解析力是：\n$$\n\\mathbf{F}_{\\mathrm{Q}}^{\\text{an}} = -\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} = - \\left[ k_{\\parallel} \\left( (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}) \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u} + k_{\\perp} (\\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}) (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}) \\right]\n$$\n$$\n\\mathbf{F}_{\\mathrm{M}}^{\\text{an}} = +\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} = k_{\\parallel} \\left( (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}) \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u} + k_{\\perp} (\\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}) (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})\n$$\n\n### 2. 数值力计算与验证\n\n数值力是使用梯度的中心有限差分近似来计算的。对于 QM 原子上力的第 $i$ 个笛卡尔分量（$i \\in \\{1,2,3\\}$），我们有：\n$$\nF_{\\mathrm{Q},i}^{\\text{num}} \\approx -\\frac{E_{\\text{couple}}(\\mathbf{r}_{\\mathrm{Q}}+h\\,\\mathbf{e}_i, \\mathbf{r}_{\\mathrm{M}}) - E_{\\text{couple}}(\\mathbf{r}_{\\mathrm{Q}}-h\\,\\mathbf{e}_i, \\mathbf{r}_{\\mathrm{M}})}{2h}\n$$\n其中 $\\mathbf{e}_i$ 是第 $i$ 个标准基向量，$h$ 是一个小的步长。一个类似的表达式通过扰动 $\\mathbf{r}_{\\mathrm{M}}$ 的坐标来计算 $\\mathbf{F}_{\\mathrm{M}}^{\\text{num}}$。\n\n验证过程包括两项检查：\n1.  **一致性检查**：我们计算解析力和数值力在两个原子上的逐分量最大绝对差异。\n    $$\n    \\text{discrepancy} = \\max_{j \\in \\{\\mathrm{Q}, \\mathrm{M}\\}, i \\in \\{1,2,3\\}} \\left| F_{j,i}^{\\text{an}} - F_{j,i}^{\\text{num}} \\right|\n    $$\n2.  **Newton 第三定律检查**：我们验证数值力之和是否接近于零，这是从仅依赖于相对位置的势能推导出的力的一个特性。我们检查该和的无穷范数是否在给定的容差 $\\tau$ 之内。\n    $$\n    \\left\\| \\mathbf{F}_{\\mathrm{Q}}^{\\text{num}} + \\mathbf{F}_{\\mathrm{M}}^{\\text{num}} \\right\\|_{\\infty} = \\max_{i \\in \\{1,2,3\\}} \\left| F_{\\mathrm{Q},i}^{\\text{num}} + F_{\\mathrm{M},i}^{\\text{num}} \\right| \\le \\tau\n    $$\n对于一个势能 $E(\\mathbf{r}_{\\mathrm{Q}}, \\mathbf{r}_{\\mathrm{M}}) = E(\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})$，中心差分近似在精确算术下会得出 $F_{\\mathrm{Q},i}^{\\text{num}} + F_{\\mathrm{M},i}^{\\text{num}} = 0$。任何非零结果都是由浮点表示误差引起的。\n\n实现将针对所提供的每个测试用例，遵循这些推导出的公式和验证程序。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the QM/MM mechanical embedding force calculation problem\n    for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"r_Q\": np.array([0.8, -0.2, 0.3]),\n            \"r_M\": np.array([-0.4, 0.5, 0.1]),\n            \"u\": np.array([1.0, 1.0, 0.5]),\n            \"r0\": 1.1,\n            \"k_par\": 120.0,\n            \"k_perp\": 80.0,\n        },\n        {\n            \"r_Q\": np.array([1.0, 0.0, 0.0]),\n            \"r_M\": np.array([0.0, 1.0, 0.0]),\n            \"u\": np.array([1.0, 0.0, 0.0]),\n            \"r0\": 1.0,\n            \"k_par\": 50.0,\n            \"k_perp\": 0.0,\n        },\n        {\n            \"r_Q\": np.array([0.0, 0.0, 0.0]),\n            \"r_M\": np.array([0.0, 0.0, 0.0]),\n            \"u\": np.array([0.0, 0.0, 1.0]),\n            \"r0\": 0.3,\n            \"k_par\": 30.0,\n            \"k_perp\": 10.0,\n        },\n    ]\n\n    h = 1e-6\n    tau = 1e-8\n    results = []\n\n    def coupling_energy(r_Q, r_M, u_norm, r0, k_par, k_perp):\n        \"\"\"Calculates the mechanical coupling energy E_couple.\"\"\"\n        delta_r = r_Q - r_M\n        \n        # Axial term\n        # E_par = (k_par / 2) * ( (delta_r . u) - r0 )^2\n        axial_proj = np.dot(delta_r, u_norm)\n        energy_par = 0.5 * k_par * (axial_proj - r0)**2\n        \n        # Transverse term\n        # E_perp = (k_perp / 2) * || P_perp * delta_r ||^2\n        # P_perp * delta_r = delta_r - u * (u . delta_r)\n        perp_proj_vec = delta_r - u_norm * axial_proj\n        energy_perp = 0.5 * k_perp * np.dot(perp_proj_vec, perp_proj_vec)\n        \n        return energy_par + energy_perp\n\n    for case in test_cases:\n        r_Q, r_M, u, r0, k_par, k_perp = (\n            case[\"r_Q\"], case[\"r_M\"], case[\"u\"], case[\"r0\"], case[\"k_par\"], case[\"k_perp\"]\n        )\n\n        u_norm = u / np.linalg.norm(u)\n        \n        # --- 1. Analytic Forces ---\n        delta_r = r_Q - r_M\n        axial_proj = np.dot(delta_r, u_norm)\n        perp_proj_vec = delta_r - u_norm * axial_proj\n        \n        # Gradient with respect to delta_r\n        grad_delta_r = (k_par * (axial_proj - r0) * u_norm) + (k_perp * perp_proj_vec)\n        \n        F_Q_an = -grad_delta_r\n        F_M_an = grad_delta_r\n        \n        # --- 2. Numerical Forces ---\n        F_Q_num = np.zeros(3)\n        F_M_num = np.zeros(3)\n        \n        for i in range(3):\n            e_i = np.zeros(3)\n            e_i[i] = 1.0\n            \n            # Perturb r_Q\n            r_Q_plus = r_Q + h * e_i\n            r_Q_minus = r_Q - h * e_i\n            E_plus_Q = coupling_energy(r_Q_plus, r_M, u_norm, r0, k_par, k_perp)\n            E_minus_Q = coupling_energy(r_Q_minus, r_M, u_norm, r0, k_par, k_perp)\n            F_Q_num[i] = -(E_plus_Q - E_minus_Q) / (2 * h)\n            \n            # Perturb r_M\n            r_M_plus = r_M + h * e_i\n            r_M_minus = r_M - h * e_i\n            E_plus_M = coupling_energy(r_Q, r_M_plus, u_norm, r0, k_par, k_perp)\n            E_minus_M = coupling_energy(r_Q, r_M_minus, u_norm, r0, k_par, k_perp)\n            F_M_num[i] = -(E_plus_M - E_minus_M) / (2 * h)\n            \n        # --- 3. Verification ---\n        # Discrepancy between analytic and numerical forces\n        diff_Q = np.abs(F_Q_an - F_Q_num)\n        diff_M = np.abs(F_M_an - F_M_num)\n        max_discrepancy = np.max(np.concatenate((diff_Q, diff_M)))\n        \n        # Check Newton's Third Law for numerical forces\n        force_sum = F_Q_num + F_M_num\n        norm_inf_sum = np.max(np.abs(force_sum))\n        newton_check = norm_inf_sum = tau\n        \n        results.append(max_discrepancy)\n        results.append(newton_check)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "机械嵌入模型中的参数（例如弹簧常数$k$）并非凭空设定；它们必须准确地反映局域的量子力学环境。本练习模拟了多尺度建模中的一个关键工作流程：使用高精度量子数据来参数化经典模型。您将学习如何通过对QM计算出的力进行线性最小二乘拟合来确定最优模型参数，从而连接量子和经典描述，确保MM模型的物理相关性。",
            "id": "3823910",
            "problem": "考虑量子力学/分子力学 (QM/MM) 中的机械嵌入，其中分子力学 (MM) 环境对量子力学 (QM) 区域施加边界力。假设针对单个 QM 自由度采用一维谐波机械嵌入模型，其中 MM 边界根据胡克定律 $f = -k(x - x_0)$ 对 QM 坐标施加力，其中 $f$ 是力，单位为电子伏特每埃 ($\\mathrm{eV}/\\mathrm{\\AA}$)；$x$ 是坐标，单位为埃 ($\\mathrm{\\AA}$)；$k$ 是刚度，单位为电子伏特每平方埃 ($\\mathrm{eV}/\\mathrm{\\AA}^{2}$)；$x_0$ 是平衡位置，单位为埃 ($\\mathrm{\\AA}$)。设有一组训练构型，提供从量子力学力计算中导出的数据对 $\\{(x_j, f_j)\\}_{j=1}^{n}$，以及一个验证集，为保留的构型提供数据对 $\\{(x^{\\mathrm{val}}_i, f^{\\mathrm{val}}_i)\\}_{i=1}^{m}$。定义重参数化 $b = k x_0$，使得 $f_j = -k x_j + b$。目标是在训练集上以最小二乘法计算最优参数 $(k, x_0)$，然后预测验证集上的力以评估准确性。\n\n从线性叠加原理和胡克定律出发，并使用最小二乘准则，推导使 $\\sum_{j=1}^{n} (-k x_j + b - f_j)^2$ 最小化的 $(k,b)$ 的最优性条件。然后，实现一个稳健的求解器，该求解器使用摩尔-彭若斯伪逆来获得 $(k,b)$ 的最小范数解，即使在训练设计矩阵是秩亏的情况下也是如此。在估计出 $(k,b)$ 后，当 $k \\neq 0$ 时通过 $x_0 = b/k$ 恢复 $x_0$，并将验证构型上的预测定义为 $f^{\\mathrm{pred}}_i = -k x^{\\mathrm{val}}_i + b$。将验证平均绝对误差评估为 $\\mathrm{MAE} = \\frac{1}{m} \\sum_{i=1}^{m} | f^{\\mathrm{pred}}_i - f^{\\mathrm{val}}_i |$。所有物理量必须使用指定的单位处理：$x$ 的单位是 $\\mathrm{\\AA}$，$f$ 的单位是 $\\mathrm{eV}/\\mathrm{\\AA}$，$k$ 的单位是 $\\mathrm{eV}/\\mathrm{\\AA}^{2}$，$\\mathrm{MAE}$ 的单位是 $\\mathrm{eV}/\\mathrm{\\AA}$。\n\n您的程序必须解决以下三个测试用例，每个用例包含一个训练集和一个验证集：\n\n测试用例 1（具有微小确定性噪声的良态训练数据）：\n- 训练位置 $x$：$[0.8, 1.0, 1.2, 1.4]$ $\\mathrm{\\AA}$。\n- 训练力 $f$：$[0.41, -0.02, -0.38, -0.81]$ $\\mathrm{eV}/\\mathrm{\\AA}$。\n- 验证位置 $x^{\\mathrm{val}}$：$[0.9, 1.3]$ $\\mathrm{\\AA}$。\n- 验证力 $f^{\\mathrm{val}}$：$[0.21, -0.61]$ $\\mathrm{eV}/\\mathrm{\\AA}$。\n\n测试用例 2（接近零的刚度）：\n- 训练位置 $x$：$[-0.5, 0.0, 0.5]$ $\\mathrm{\\AA}$。\n- 训练力 $f$：$[0.11, 0.0, -0.09]$ $\\mathrm{eV}/\\mathrm{\\AA}$。\n- 验证位置 $x^{\\mathrm{val}}$：$[-1.0, 1.0]$ $\\mathrm{\\AA}$。\n- 验证力 $f^{\\mathrm{val}}$：$[0.19, -0.21]$ $\\mathrm{eV}/\\mathrm{\\AA}$。\n\n测试用例 3（所有位置均相同的秩亏训练数据）：\n- 训练位置 $x$：$[1.0, 1.0, 1.0, 1.0]$ $\\mathrm{\\AA}$。\n- 训练力 $f$：$[-0.75, -0.75, -0.75, -0.75]$ $\\mathrm{eV}/\\mathrm{\\AA}$。\n- 验证位置 $x^{\\mathrm{val}}$：$[0.8, 1.2]$ $\\mathrm{\\AA}$。\n- 验证力 $f^{\\mathrm{val}}$：$[-0.45, -1.05]$ $\\mathrm{eV}/\\mathrm{\\AA}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，按顺序输出三个数字：估计的刚度 $k$（单位 $\\mathrm{eV}/\\mathrm{\\AA}^{2}$）、估计的平衡位置 $x_0$（单位 $\\mathrm{\\AA}$）以及验证平均绝对误差（单位 $\\mathrm{eV}/\\mathrm{\\AA}$）。所有数字必须四舍五入到六位小数，因此完整输出应包含对应于所有三个测试用例的九个数字，顺序如下，例如：$[k_1,x_{0,1},\\mathrm{MAE}_1,k_2,x_{0,2},\\mathrm{MAE}_2,k_3,x_{0,3},\\mathrm{MAE}_3]$。",
            "solution": "问题陈述已经过仔细验证，并被确定为 **有效**。它具有科学依据，问题定义明确，客观且内部一致。它提出了计算材料科学中的一个标准问题——根据量子力学数据参数化经典力场模型——并为推导和实现稳健的数值解提供了所有必要的信息。\n\n问题的核心是，基于一组训练数据 $\\{(x_j, f_j)\\}_{j=1}^{n}$，为一维谐波力模型 $f = -k(x - x_0)$ 确定最优参数 $(k, x_0)$。该模型被重参数化为线性形式 $f_j = -k x_j + b$，其中 $b = k x_0$。这一变换使我们能够运用线性最小二乘回归的原理。\n\n目标是找到参数向量 $\\mathbf{p} = \\begin{pmatrix} k \\\\ b \\end{pmatrix}$，以最小化模型预测与所提供的训练力 $f_j$ 之间的平方误差总和 $S(\\mathbf{p})$。\n对于一组 $n$ 个训练点，我们可以将问题表示为一个超定线性方程组：\n$$\n-k x_1 + b \\approx f_1 \\\\\n-k x_2 + b \\approx f_2 \\\\\n\\vdots \\\\\n-k x_n + b \\approx f_n \\\\\n$$\n该系统可以写成矩阵形式 $\\mathbf{A}\\mathbf{p} \\approx \\mathbf{y}$，其中设计矩阵 $\\mathbf{A}$、参数向量 $\\mathbf{p}$ 和观测向量 $\\mathbf{y}$ 定义如下：\n$$\n\\mathbf{A} = \\begin{pmatrix}\n-x_1  1 \\\\\n-x_2  1 \\\\\n\\vdots  \\vdots \\\\\n-x_n  1\n\\end{pmatrix}, \\quad\n\\mathbf{p} = \\begin{pmatrix}\nk \\\\\nb\n\\end{pmatrix}, \\quad\n\\mathbf{y} = \\begin{pmatrix}\nf_1 \\\\\nf_2 \\\\\n\\vdots \\\\\nf_n\n\\end{pmatrix}\n$$\n最小二乘准则要求最小化残差向量 $\\mathbf{r} = \\mathbf{A}\\mathbf{p} - \\mathbf{y}$ 的欧几里得范数的平方：\n$$\nS(\\mathbf{p}) = \\|\\mathbf{r}\\|^2 = \\|\\mathbf{A}\\mathbf{p} - \\mathbf{y}\\|^2 = (\\mathbf{A}\\mathbf{p} - \\mathbf{y})^T(\\mathbf{A}\\mathbf{p} - \\mathbf{y})\n$$\n为了找到最小值，我们将 $S(\\mathbf{p})$ 相对于 $\\mathbf{p}$ 的梯度设为零：\n$$\n\\nabla_{\\mathbf{p}} S(\\mathbf{p}) = \\nabla_{\\mathbf{p}} (\\mathbf{p}^T\\mathbf{A}^T\\mathbf{A}\\mathbf{p} - 2\\mathbf{p}^T\\mathbf{A}^T\\mathbf{y} + \\mathbf{y}^T\\mathbf{y}) = 2\\mathbf{A}^T\\mathbf{A}\\mathbf{p} - 2\\mathbf{A}^T\\mathbf{y} = \\mathbf{0}\n$$\n这就得到了著名的正规方程组：\n$$\n\\mathbf{A}^T\\mathbf{A}\\mathbf{p} = \\mathbf{A}^T\\mathbf{y}\n$$\n当矩阵 $\\mathbf{A}^T\\mathbf{A}$ 可逆时（即当 $\\mathbf{A}$ 的列线性无关时），$\\mathbf{p}$ 存在唯一解：\n$$\n\\mathbf{p} = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T\\mathbf{y}\n$$\n问题指定使用摩尔-彭若斯伪逆 $\\mathbf{A}^+$ 来求解 $\\mathbf{p}$。因此，解由 $\\mathbf{p} = \\mathbf{A}^+ \\mathbf{y}$ 给出。这种方法更为优越，因为它即使在 $\\mathbf{A}^T\\mathbf{A}$ 是奇异矩阵时也能提供唯一的解。如果矩阵 $\\mathbf{A}$ 的列线性相关，它就会变成秩亏矩阵，这种情况当且仅当所有训练位置 $x_j$ 都相同时才会发生（如测试用例 3）。在这种情况下，正规方程组有无穷多解。摩尔-彭若斯伪逆形式通过产生具有最小欧几里得范数 $\\|\\mathbf{p}\\| = \\sqrt{k^2+b^2}$ 的唯一解向量 $\\mathbf{p}$ 来解决这种模糊性。这确保了对于任何给定的训练集都能得到确定且稳健的结果。\n\n完整的算法流程如下：\n1. 对于给定的训练集 $\\{(x_j, f_j)\\}_{j=1}^{n}$，构建如上定义的 $n \\times 2$ 设计矩阵 $\\mathbf{A}$ 和 $n \\times 1$ 观测向量 $\\mathbf{y}$。\n2. 通过使用摩尔-彭若斯伪逆求解线性系统来计算参数向量 $\\mathbf{p} = \\begin{pmatrix} k \\\\ b \\end{pmatrix}$：$\\mathbf{p} = \\mathbf{A}^+ \\mathbf{y}$。$\\mathbf{p}$ 的分量是估计的刚度 $k$ 和截距 $b$。\n3. 从重参数化 $b = k x_0$ 中恢复平衡位置 $x_0$。如果 $k \\neq 0$，则 $x_0 = b/k$。如果 $k$ 为零或在数值上与零无法区分（例如，对于一个小的容差 $\\epsilon$，有 $|k|  \\epsilon$），则唯一平衡位置的概念变得不明确，因为力是恒定的 $f=b$。在这种情况下，我们按照惯例将 $x_0 = 0.0$ 作为一个中性值。\n4. 使用确定的参数 $(k, b)$，对验证集中的每个位置 $x^{\\mathrm{val}}_i$ 预测力 $f^{\\mathrm{pred}}_i$：$f^{\\mathrm{pred}}_i = -k x^{\\mathrm{val}}_i + b$。\n5. 通过计算平均绝对误差 (MAE) 来评估模型在验证集上的准确性：$\\mathrm{MAE} = \\frac{1}{m} \\sum_{i=1}^{m} | f^{\\mathrm{pred}}_i - f^{\\mathrm{val}}_i |$，其中 $m$ 是验证集中的数据点数量。\n\n此程序将应用于指定的三个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the parameters of a 1D harmonic mechanical embedding model\n    for three distinct test cases and evaluates the validation error.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"train_x\": np.array([0.8, 1.0, 1.2, 1.4]),\n            \"train_f\": np.array([0.41, -0.02, -0.38, -0.81]),\n            \"val_x\": np.array([0.9, 1.3]),\n            \"val_f\": np.array([0.21, -0.61]),\n        },\n        {\n            \"train_x\": np.array([-0.5, 0.0, 0.5]),\n            \"train_f\": np.array([0.11, 0.0, -0.09]),\n            \"val_x\": np.array([-1.0, 1.0]),\n            \"val_f\": np.array([0.19, -0.21]),\n        },\n        {\n            \"train_x\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"train_f\": np.array([-0.75, -0.75, -0.75, -0.75]),\n            \"val_x\": np.array([0.8, 1.2]),\n            \"val_f\": np.array([-0.45, -1.05]),\n        },\n    ]\n\n    all_results = []\n    \n    # Set a small tolerance for checking if k is close to zero\n    zero_tolerance = 1e-9\n\n    for case in test_cases:\n        # Extract data for the current case\n        x_train = case[\"train_x\"]\n        f_train = case[\"train_f\"]\n        x_val = case[\"val_x\"]\n        f_val = case[\"val_f\"]\n\n        # 1. Construct the design matrix A and observation vector y\n        # The model is f = -k*x + b, so the system is A * [k, b]^T = f\n        # Column for k has coefficients -x_j\n        # Column for b has coefficients 1\n        A = np.vstack([-x_train, np.ones(len(x_train))]).T\n        y = f_train\n\n        # 2. Solve for parameters [k, b] using the Moore-Penrose pseudoinverse\n        # This provides the minimum-norm least-squares solution, robust to rank deficiency\n        try:\n            p = np.linalg.pinv(A) @ y\n            k, b = p[0], p[1]\n        except np.linalg.LinAlgError:\n            # This case should not be reached with pinv, but as a safeguard\n            k, b = 0.0, 0.0\n\n        # 3. Recover equilibrium position x0\n        # If k is effectively zero, x0 is ill-defined. We set it to 0.0 by convention.\n        if abs(k)  zero_tolerance:\n            x0 = 0.0\n        else:\n            x0 = b / k\n\n        # 4. Predict forces on the validation set\n        f_pred = -k * x_val + b\n\n        # 5. Calculate validation Mean Absolute Error (MAE)\n        mae = np.mean(np.abs(f_pred - f_val))\n\n        # Append results for this case to the main list\n        all_results.extend([k, x0, mae])\n\n    # Format the final results to six decimal places and print in the required format\n    formatted_results = [\"{:.6f}\".format(r) for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "机械嵌入是一种计算高效的近似方法。为了明智地使用它，我们必须理解其与更严格方案（如静电嵌入）相比的物理局限性。本练习将从代码实现转向批判性分析，通过推导和计算两种嵌入方案对关键可观测量（如反应能垒）的差异，您将定量地理解忽略显式静电相互作用（如永久偶极矩$\\mu$和极化率$\\alpha$的贡献）所带来的物理后果。这种分析对于判断机械嵌入近似是否适用于特定的科学问题至关重要。",
            "id": "3823952",
            "problem": "考虑一个简化的第一性原理模型，用于比较混合量子力学/分子力学 (QM/MM) 计算中的力学嵌入和静电嵌入。量子力学/分子力学 (QM/MM) 是一种多尺度方法，其中一个小区域用量子力学处理，而其环境则用经典分子力学处理。在力学嵌入中，量子区域不受分子力学环境的静电场影响；仅存在非静电力学耦合。在静电嵌入中，量子区域受到分子力学环境的静电场影响，并相应地发生极化。假设存在一个大小为 $\\mathcal{E}$（以原子单位计）的一维匀强外部电场，该电场与所有态的永久偶极子对齐，因此所有矢量都可简化为带符号的标量。\n\n使用以下经过充分检验的物理事实作为基本依据：\n- 总 Born–Oppenheimer 能量是电子哈密顿量的期望值加上经典分子力学贡献。对于作为两个定态之间能量差的可观测量，任何与态无关的加性常数都会被消去。\n- 永久偶极子 $\\mu$（以原子单位计）与匀强电场 $\\mathcal{E}$（以原子单位计）的相互作用能为 $-\\mu\\,\\mathcal{E}$。\n- 在线性响应中，一个极化率为 $\\alpha$（以原子单位计）的各向同性可极化实体在匀强电场 $\\mathcal{E}$ 中的极化能为 $-\\tfrac{1}{2}\\alpha\\,\\mathcal{E}^{2}$。\n\n假设非静电范德华耦合对于每个可观测量都是与态无关的，因此在计算下面定义的能量差时会被消去。令 $E_{\\mathrm{ME}}(s)$ 表示态 $s$ 在力学嵌入下的能量，令 $E_{\\mathrm{EE}}(s)$ 表示态 $s$ 在静电嵌入下的能量。对于一个态 $s$，令 $\\mu_{s}$ 为其永久偶极子（带符号的标量，以原子单位计），$\\alpha_{s}$ 为其各向同性极化率（以原子单位计）。\n\n需要比较两个可观测量：\n- 反应势垒，定义为过渡态与反应物之间的能量差，$E_{\\mathrm{barrier}} = E(\\mathrm{TS}) - E(\\mathrm{R})$。\n- 缺陷形成能，定义为缺陷态与块体参考态之间的能量差，$E_{\\mathrm{defect}} = E(\\mathrm{D}) - E(\\mathrm{B})$。\n\n您的任务是：\n1. 根据所述物理事实，从第一性原理推导每个可观测量在静电嵌入和力学嵌入下的差值表达式，并将其分解为由永久偶极子相互作用和极化能产生的贡献项。具体来说，您必须用相关态对的 $\\mu_{s}$、$\\alpha_{s}$ 和 $\\mathcal{E}$ 来表示可观测量在静电嵌入和力学嵌入下的差值。\n2. 实现一个程序，对下述每个测试用例，计算：\n   - 静电嵌入和力学嵌入之间的反应势垒差，单位为 Hartree。\n   - 永久偶极子相互作用对此势垒差的贡献，单位为 Hartree。\n   - 极化能对此势垒差的贡献，单位为 Hartree。\n   - 静电嵌入和力学嵌入之间的缺陷形成能差，单位为 Hartree。\n   - 永久偶极子相互作用对此缺陷差的贡献，单位为 Hartree。\n   - 极化能对此缺陷差的贡献，单位为 Hartree。\n3. 程序必须将每个测试用例的六个数字按上述顺序聚合到一个列表中。它必须产生单行输出，包含这些按测试用例组织的列表，其中每个数字都以 Hartree 为单位，并四舍五入到八位小数。\n\n所有量均使用原子单位。能量必须以 Hartree 报告，并四舍五入到八位小数。\n\n测试套件（为实现覆盖率而设计的三个用例）：\n- 用例 A（边界情况：零场，所有差值必须为零）：\n  - $\\mathcal{E} = 0.00000000$\n  - $\\mu_{\\mathrm{R}} = 0.50000000$, $\\mu_{\\mathrm{TS}} = 0.70000000$, $\\mu_{\\mathrm{B}} = 0.30000000$, $\\mu_{\\mathrm{D}} = 0.90000000$\n  - $\\alpha_{\\mathrm{R}} = 10.00000000$, $\\alpha_{\\mathrm{TS}} = 9.50000000$, $\\alpha_{\\mathrm{B}} = 8.00000000$, $\\alpha_{\\mathrm{D}} = 12.00000000$\n- 用例 B（正常路径：非零场，具有不同的永久偶极子和极化率）：\n  - $\\mathcal{E} = 0.01000000$\n  - $\\mu_{\\mathrm{R}} = 0.40000000$, $\\mu_{\\mathrm{TS}} = 1.10000000$, $\\mu_{\\mathrm{B}} = 0.50000000$, $\\mu_{\\mathrm{D}} = 0.20000000$\n  - $\\alpha_{\\mathrm{R}} = 9.00000000$, $\\alpha_{\\mathrm{TS}} = 11.00000000$, $\\alpha_{\\mathrm{B}} = 7.00000000$, $\\alpha_{\\mathrm{D}} = 13.00000000$\n- 用例 C（边缘特性：负电场，势垒对的永久偶极子相等，缺陷对的极化率相等）：\n  - $\\mathcal{E} = -0.02000000$\n  - $\\mu_{\\mathrm{R}} = 0.60000000$, $\\mu_{\\mathrm{TS}} = 0.60000000$, $\\mu_{\\mathrm{B}} = 1.20000000$, $\\mu_{\\mathrm{D}} = 0.80000000$\n  - $\\alpha_{\\mathrm{R}} = 10.00000000$, $\\alpha_{\\mathrm{TS}} = 14.00000000$, $\\alpha_{\\mathrm{B}} = 9.00000000$, $\\alpha_{\\mathrm{D}} = 9.00000000$\n\n最终输出格式：\n您的程序应产生单行输出，其中包含一个由方括号括起来的结果列表，列表的每个元素是针对一个测试用例的、包含六个数字的列表，顺序如上所述。例如，包含两个假设用例的输出应如下所示：$[[x_{1},x_{2},x_{3},x_{4},x_{5},x_{6}],[y_{1},y_{2},y_{3},y_{4},y_{5},y_{6}]]$, 但使用四舍五入到八位小数的实际数字。不应打印任何额外文本。",
            "solution": "问题陈述已经过严格验证，并被认为是有效的。其科学基础在于多尺度 QM/MM 模拟的原理，提法明确，提供了所有必要的数据和定义，并以客观、正式的语言表述。该问题是自洽、一致的，并且需要应用基本原理来推导和计算特定的物理量，是计算物理/化学领域一个结构良好的练习。\n\n从第一性原理推导所需表达式的过程如下。\n\n令 $E_{0}(s)$ 表示量子力学 (QM) 系统在给定态 $s$ 下的内禀能量，即在孤立状态下（即在气相中）计算出的能量。根据问题陈述，我们考虑 QM/MM 计算的两种嵌入方案。\n\n在**力学嵌入 (ME)**中，QM 区域仅通过非静电相互作用与分子力学 (MM) 环境耦合。假设这些相互作用由一个与态无关的势能项 $V_{\\mathrm{mech}}$ 描述，该项在计算态间能量差时会被消去。因此，态 $s$ 在 ME 下的总能量为：\n$$E_{\\mathrm{ME}}(s) = E_{0}(s) + V_{\\mathrm{mech}}$$\n\n在**静电嵌入 (EE)**中，QM 区域还与 MM 环境产生的静电场 $\\mathcal{E}$ 相互作用。问题指明，该相互作用能由两个部分组成：\n$1$. 态的永久偶极矩 $\\mu_{s}$ 与电场 $\\mathcal{E}$ 的相互作用，其能量项为 $-\\mu_{s}\\mathcal{E}$。\n$2$. QM 系统电子密度在电场 $\\mathcal{E}$ 作用下的极化，其能量贡献为 $-\\frac{1}{2}\\alpha_{s}\\mathcal{E}^{2}$，其中 $\\alpha_{s}$ 是该态的各向同性极化率。\n\n因此，态 $s$ 在 EE 下的总能量为：\n$$E_{\\mathrm{EE}}(s) = E_{0}(s) + V_{\\mathrm{mech}} - \\mu_{s}\\mathcal{E} - \\frac{1}{2}\\alpha_{s}\\mathcal{E}^{2}$$\n\n两种嵌入方案对单个态 $s$ 的描述差异在于总的静电相互作用能：\n$$\\Delta E(s) = E_{\\mathrm{EE}}(s) - E_{\\mathrm{ME}}(s) = \\left( E_{0}(s) + V_{\\mathrm{mech}} - \\mu_{s}\\mathcal{E} - \\frac{1}{2}\\alpha_{s}\\mathcal{E}^{2} \\right) - \\left( E_{0}(s) + V_{\\mathrm{mech}} \\right)$$\n$$\\Delta E(s) = - \\mu_{s}\\mathcal{E} - \\frac{1}{2}\\alpha_{s}\\mathcal{E}^{2}$$\n\n我们需要求解两个特定可观测量（反应势垒和缺陷形成能）的差值。\n\n**1. 反应势垒**\n\n反应势垒定义为能量差 $E_{\\mathrm{barrier}} = E(\\mathrm{TS}) - E(\\mathrm{R})$，其中 $\\mathrm{TS}$ 是过渡态，$\\mathrm{R}$ 是反应物态。\n\n在 ME 下，势垒为：\n$$E_{\\mathrm{barrier}}^{\\mathrm{ME}} = E_{\\mathrm{ME}}(\\mathrm{TS}) - E_{\\mathrm{ME}}(\\mathrm{R}) = (E_{0}(\\mathrm{TS}) + V_{\\mathrm{mech}}) - (E_{0}(\\mathrm{R}) + V_{\\mathrm{mech}}) = E_{0}(\\mathrm{TS}) - E_{0}(\\mathrm{R})$$\n\n在 EE 下，势垒为：\n$$E_{\\mathrm{barrier}}^{\\mathrm{EE}} = E_{\\mathrm{EE}}(\\mathrm{TS}) - E_{\\mathrm{EE}}(\\mathrm{R})$$\n$$E_{\\mathrm{barrier}}^{\\mathrm{EE}} = \\left( E_{0}(\\mathrm{TS}) - \\mu_{\\mathrm{TS}}\\mathcal{E} - \\frac{1}{2}\\alpha_{\\mathrm{TS}}\\mathcal{E}^{2} \\right) - \\left( E_{0}(\\mathrm{R}) - \\mu_{\\mathrm{R}}\\mathcal{E} - \\frac{1}{2}\\alpha_{\\mathrm{R}}\\mathcal{E}^{2} \\right)$$\n$$E_{\\mathrm{barrier}}^{\\mathrm{EE}} = (E_{0}(\\mathrm{TS}) - E_{0}(\\mathrm{R})) - (\\mu_{\\mathrm{TS}} - \\mu_{\\mathrm{R}})\\mathcal{E} - \\frac{1}{2}(\\alpha_{\\mathrm{TS}} - \\alpha_{\\mathrm{R}})\\mathcal{E}^{2}$$\n\n用 EE 和 ME 计算的势垒之差即为我们关注的量：\n$$\\Delta(E_{\\mathrm{barrier}}) = E_{\\mathrm{barrier}}^{\\mathrm{EE}} - E_{\\mathrm{barrier}}^{\\mathrm{ME}}$$\n$$\\Delta(E_{\\mathrm{barrier}}) = \\left[ (E_{0}(\\mathrm{TS}) - E_{0}(\\mathrm{R})) - (\\mu_{\\mathrm{TS}} - \\mu_{\\mathrm{R}})\\mathcal{E} - \\frac{1}{2}(\\alpha_{\\mathrm{TS}} - \\alpha_{\\mathrm{R}})\\mathcal{E}^{2} \\right] - [E_{0}(\\mathrm{TS}) - E_{0}(\\mathrm{R})]$$\n$$\\Delta(E_{\\mathrm{barrier}}) = - (\\mu_{\\mathrm{TS}} - \\mu_{\\mathrm{R}})\\mathcal{E} - \\frac{1}{2}(\\alpha_{\\mathrm{TS}} - \\alpha_{\\mathrm{R}})\\mathcal{E}^{2}$$\n\n根据要求，这个总差值可以分解为两个贡献：\n- 来自永久偶极子相互作用的贡献：$\\Delta(E_{\\mathrm{barrier}})_{\\mu} = - (\\mu_{\\mathrm{TS}} - \\mu_{\\mathrm{R}})\\mathcal{E}$\n- 来自极化能的贡献：$\\Delta(E_{\\mathrm{barrier}})_{\\alpha} = - \\frac{1}{2}(\\alpha_{\\mathrm{TS}} - \\alpha_{\\mathrm{R}})\\mathcal{E}^{2}$\n\n**2. 缺陷形成能**\n\n缺陷形成能定义为 $E_{\\mathrm{defect}} = E(\\mathrm{D}) - E(\\mathrm{B})$，其中 $\\mathrm{D}$ 是缺陷态，$\\mathrm{B}$ 是块体参考态。其推导过程与反应势垒的推导完全类似。\n\n在 ME 下：\n$$E_{\\mathrm{defect}}^{\\mathrm{ME}} = E_{\\mathrm{ME}}(\\mathrm{D}) - E_{\\mathrm{ME}}(\\mathrm{B}) = E_{0}(\\mathrm{D}) - E_{0}(\\mathrm{B})$$\n\n在 EE 下：\n$$E_{\\mathrm{defect}}^{\\mathrm{EE}} = E_{\\mathrm{EE}}(\\mathrm{D}) - E_{\\mathrm{EE}}(\\mathrm{B})$$\n$$E_{\\mathrm{defect}}^{\\mathrm{EE}} = (E_{0}(\\mathrm{D}) - E_{0}(\\mathrm{B})) - (\\mu_{\\mathrm{D}} - \\mu_{\\mathrm{B}})\\mathcal{E} - \\frac{1}{2}(\\alpha_{\\mathrm{D}} - \\alpha_{\\mathrm{B}})\\mathcal{E}^{2}$$\n\n用 EE 和 ME 计算的缺陷能之差为：\n$$\\Delta(E_{\\mathrm{defect}}) = E_{\\mathrm{defect}}^{\\mathrm{EE}} - E_{\\mathrm{defect}}^{\\mathrm{ME}}$$\n$$\\Delta(E_{\\mathrm{defect}}) = - (\\mu_{\\mathrm{D}} - \\mu_{\\mathrm{B}})\\mathcal{E} - \\frac{1}{2}(\\alpha_{\\mathrm{D}} - \\alpha_{\\mathrm{B}})\\mathcal{E}^{2}$$\n\n这个总差值分解为：\n- 来自永久偶极子相互作用的贡献：$\\Delta(E_{\\mathrm{defect}})_{\\mu} = - (\\mu_{\\mathrm{D}} - \\mu_{\\mathrm{B}})\\mathcal{E}$\n- 来自极化能的贡献：$\\Delta(E_{\\mathrm{defect}})_{\\alpha} = - \\frac{1}{2}(\\alpha_{\\mathrm{D}} - \\alpha_{\\mathrm{B}})\\mathcal{E}^{2}$\n\n这些推导出的公式将被用于实现程序，以计算所提供测试用例所需的量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the QM/MM embedding problem by deriving and applying formulas for the\n    difference between electrostatic and mechanical embedding for two observables.\n    \"\"\"\n    \n    # Test suite data structured for clarity. Each tuple contains:\n    # (E_field, mu_R, mu_TS, mu_B, mu_D, alpha_R, alpha_TS, alpha_B, alpha_D)\n    # All quantities are in atomic units.\n    test_cases = [\n        # Case A (boundary: zero field)\n        (0.00000000, \n         0.50000000, 0.70000000, 0.30000000, 0.90000000, \n         10.00000000, 9.50000000, 8.00000000, 12.00000000),\n        # Case B (happy path: nonzero field)\n        (0.01000000, \n         0.40000000, 1.10000000, 0.50000000, 0.20000000, \n         9.00000000, 11.00000000, 7.00000000, 13.00000000),\n        # Case C (edge features: negative field, specific equalities)\n        (-0.02000000, \n         0.60000000, 0.60000000, 1.20000000, 0.80000000, \n         10.00000000, 14.00000000, 9.00000000, 9.00000000),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        E_field, mu_R, mu_TS, mu_B, mu_D, alpha_R, alpha_TS, alpha_B, alpha_D = case\n        case_results = []\n\n        # --- 1. Reaction Barrier Calculation ---\n        # The observable is E(TS) - E(R)\n        # The states are initial=R, final=TS\n        mu_diff_barrier = mu_TS - mu_R\n        alpha_diff_barrier = alpha_TS - alpha_R\n        \n        # Contribution of the permanent dipole interaction to the barrier difference\n        dipole_contrib_barrier = -mu_diff_barrier * E_field\n        \n        # Contribution of the polarization energy to the barrier difference\n        polarization_contrib_barrier = -0.5 * alpha_diff_barrier * E_field**2\n        \n        # Total reaction barrier difference between EE and ME\n        total_diff_barrier = dipole_contrib_barrier + polarization_contrib_barrier\n        \n        case_results.extend([\n            total_diff_barrier,\n            dipole_contrib_barrier,\n            polarization_contrib_barrier\n        ])\n\n        # --- 2. Defect Formation Energy Calculation ---\n        # The observable is E(D) - E(B)\n        # The states are initial=B, final=D\n        mu_diff_defect = mu_D - mu_B\n        alpha_diff_defect = alpha_D - alpha_B\n        \n        # Contribution of the permanent dipole interaction to the defect difference\n        dipole_contrib_defect = -mu_diff_defect * E_field\n        \n        # Contribution of the polarization energy to the defect difference\n        polarization_contrib_defect = -0.5 * alpha_diff_defect * E_field**2\n        \n        # Total defect formation energy difference between EE and ME\n        total_diff_defect = dipole_contrib_defect + polarization_contrib_defect\n\n        case_results.extend([\n            total_diff_defect,\n            dipole_contrib_defect,\n            polarization_contrib_defect\n        ])\n        \n        all_results.append(case_results)\n\n    # Format the final output string to match the exact requirement:\n    # A list of lists, with each number rounded to 8 decimal places,\n    # and no spaces within the lists. e.g., [[n1,n2,...],[m1,m2,...]]\n    formatted_cases = []\n    for case_res in all_results:\n        # Format each number in the list to a string with 8 decimal places\n        num_strs = [f\"{num:.8f}\" for num in case_res]\n        # Join the numbers with a comma and enclose in brackets\n        case_str = f\"[{','.join(num_strs)}]\"\n        formatted_cases.append(case_str)\n    \n    # Join the formatted case strings with a comma and enclose in brackets\n    final_output = f\"[{','.join(formatted_cases)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}