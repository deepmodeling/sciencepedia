{
    "hands_on_practices": [
        {
            "introduction": "在机械嵌入方法中，QM/MM 边界的相互作用依赖于经典的力场模型。本练习旨在解决一个基本问题：这些经典参数是如何得到的？我们以高精度的量子力学计算得到的力作为“基准”数据，通过将一个简单的经典模型（例如谐振子）拟合到这些数据上，就可以确定最优的力场参数。这项练习提供了多尺度建模核心工作流程的动手经验：通过线性最小二乘回归进行力场参数化，并介绍了在处理真实数据时至关重要的稳健数值技术 。",
            "id": "3823910",
            "problem": "考虑量子力学/分子力学 (QM/MM) 中的机械嵌入，其中分子力学 (MM) 环境对量子力学 (QM) 区域施加边界力。假设一个针对单个 QM 自由度的一维谐振子机械嵌入模型，其中 MM 边界根据胡克定律 (Hooke’s law) $f = -k(x - x_0)$ 对 QM 坐标施加一个力，其中 $f$ 是力，单位为电子伏特每埃 ($\\mathrm{eV}/\\mathrm{\\AA}$)；$x$ 是坐标，单位为埃 ($\\mathrm{\\AA}$)；$k$ 是刚度，单位为电子伏特每埃平方 ($\\mathrm{eV}/\\mathrm{\\AA}^{2}$)；$x_0$ 是平衡位置，单位为埃 ($\\mathrm{\\AA}$)。设有一组训练构型，提供从量子力学力计算中派生出的数据对 $\\{(x_j, f_j)\\}_{j=1}^{n}$，以及一个验证集，为留出构型提供数据对 $\\{(x^{\\mathrm{val}}_i, f^{\\mathrm{val}}_i)\\}_{i=1}^{m}$。定义重参数化 $b = k x_0$，使得 $f_j = -k x_j + b$。目标是在训练集上以最小二乘意义计算最优参数 $(k, x_0)$，然后预测验证集上的力以评估准确性。\n\n从线性叠加原理和胡克定律 (Hooke’s law) 出发，并使用最小二乘准则，推导出使 $\\sum_{j=1}^{n} (-k x_j + b - f_j)^2$ 最小化的 $(k,b)$ 的最优性条件。然后，实现一个使用 Moore-Penrose 伪逆的鲁棒求解器，以获得 $(k,b)$ 的最小范数解，即使在训练设计矩阵是秩亏的情况下也是如此。在估计出 $(k,b)$ 后，当 $k \\neq 0$ 时通过 $x_0 = b/k$ 恢复 $x_0$，并将验证构型上的预测定义为 $f^{\\mathrm{pred}}_i = -k x^{\\mathrm{val}}_i + b$。将验证平均绝对误差评估为 $\\mathrm{MAE} = \\frac{1}{m} \\sum_{i=1}^{m} | f^{\\mathrm{pred}}_i - f^{\\mathrm{val}}_i |$。所有物理量必须使用指定的单位处理：$x$ 以 $\\mathrm{\\AA}$ 为单位，$f$ 以 $\\mathrm{eV}/\\mathrm{\\AA}$ 为单位，$k$ 以 $\\mathrm{eV}/\\mathrm{\\AA}^{2}$ 为单位，$\\mathrm{MAE}$ 以 $\\mathrm{eV}/\\mathrm{\\AA}$ 为单位。\n\n您的程序必须解决以下三个测试用例，每个用例包含一个训练集和一个验证集：\n\n测试用例 $1$ (带有小确定性噪声的良态训练数据)：\n- 训练位置 $x$: $[0.8, 1.0, 1.2, 1.4]$ $\\mathrm{\\AA}$。\n- 训练力 $f$: $[0.41, -0.02, -0.38, -0.81]$ $\\mathrm{eV}/\\mathrm{\\AA}$。\n- 验证位置 $x^{\\mathrm{val}}$: $[0.9, 1.3]$ $\\mathrm{\\AA}$。\n- 验证力 $f^{\\mathrm{val}}$: $[0.21, -0.61]$ $\\mathrm{eV}/\\mathrm{\\AA}$。\n\n测试用例 $2$ (刚度接近零)：\n- 训练位置 $x$: $[-0.5, 0.0, 0.5]$ $\\mathrm{\\AA}$。\n- 训练力 $f$: $[0.11, 0.0, -0.09]$ $\\mathrm{eV}/\\mathrm{\\AA}$。\n- 验证位置 $x^{\\mathrm{val}}$: $[-1.0, 1.0]$ $\\mathrm{\\AA}$。\n- 验证力 $f^{\\mathrm{val}}$: $[0.19, -0.21]$ $\\mathrm{eV}/\\mathrm{\\AA}$。\n\n测试用例 $3$ (所有位置都相同的秩亏训练数据)：\n- 训练位置 $x$: $[1.0, 1.0, 1.0, 1.0]$ $\\mathrm{\\AA}$。\n- 训练力 $f$: $[-0.75, -0.75, -0.75, -0.75]$ $\\mathrm{eV}/\\mathrm{\\AA}$。\n- 验证位置 $x^{\\mathrm{val}}$: $[0.8, 1.2]$ $\\mathrm{\\AA}$。\n- 验证力 $f^{\\mathrm{val}}$: $[-0.45, -1.05]$ $\\mathrm{eV}/\\mathrm{\\AA}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，按顺序输出三个数字：估计的刚度 $k$ (单位 $\\mathrm{eV}/\\mathrm{\\AA}^{2}$)，估计的平衡位置 $x_0$ (单位 $\\mathrm{\\AA}$)，以及验证平均绝对误差 (单位 $\\mathrm{eV}/\\mathrm{\\AA}$)。所有数字必须四舍五入到六位小数，因此完整输出应包含对应所有三个测试用例的九个数字，顺序如下，例如：$[k_1,x_{0,1},\\mathrm{MAE}_1,k_2,x_{0,2},\\mathrm{MAE}_2,k_3,x_{0,3},\\mathrm{MAE}_3]$。",
            "solution": "问题陈述已经过仔细验证，并被确定为 **有效**。它具有科学依据、是良构的、客观的且内部一致。它提出了计算材料科学中的一个标准问题——从量子力学数据中参数化经典力场模型——并提供了推导和实现一个鲁棒数值解所需的所有必要信息。\n\n问题的核心是基于一组训练数据 $\\{(x_j, f_j)\\}_{j=1}^{n}$，为一个一维谐振子力模型 $f = -k(x - x_0)$ 确定最优参数 $(k, x_0)$。该模型被重参数化为线性形式 $f_j = -k x_j + b$，其中 $b = k x_0$。这一变换使我们能够运用线性最小二乘回归的原理。\n\n目标是找到参数向量 $\\mathbf{p} = \\begin{pmatrix} k \\\\ b \\end{pmatrix}$，以最小化模型预测值与所提供的训练力 $f_j$ 之间的平方误差和 $S(\\mathbf{p})$。\n对于一组 $n$ 个训练点，我们可以将问题表达为一个超定线性方程组：\n$$\n-k x_1 + b \\approx f_1 \\\\\n-k x_2 + b \\approx f_2 \\\\\n\\vdots \\\\\n-k x_n + b \\approx f_n \\\\\n$$\n该系统可以写成矩阵形式 $\\mathbf{A}\\mathbf{p} \\approx \\mathbf{y}$，其中设计矩阵 $\\mathbf{A}$、参数向量 $\\mathbf{p}$ 和观测向量 $\\mathbf{y}$ 定义如下：\n$$\n\\mathbf{A} = \\begin{pmatrix}\n-x_1 & 1 \\\\\n-x_2 & 1 \\\\\n\\vdots & \\vdots \\\\\n-x_n & 1\n\\end{pmatrix}, \\quad\n\\mathbf{p} = \\begin{pmatrix}\nk \\\\\nb\n\\end{pmatrix}, \\quad\n\\mathbf{y} = \\begin{pmatrix}\nf_1 \\\\\nf_2 \\\\\n\\vdots \\\\\nf_n\n\\end{pmatrix}\n$$\n最小二乘准则要求最小化残差向量 $\\mathbf{r} = \\mathbf{A}\\mathbf{p} - \\mathbf{y}$ 的欧几里得范数的平方：\n$$\nS(\\mathbf{p}) = \\|\\mathbf{r}\\|^2 = \\|\\mathbf{A}\\mathbf{p} - \\mathbf{y}\\|^2 = (\\mathbf{A}\\mathbf{p} - \\mathbf{y})^T(\\mathbf{A}\\mathbf{p} - \\mathbf{y})\n$$\n为求最小值，我们将 $S(\\mathbf{p})$ 关于 $\\mathbf{p}$ 的梯度设为零：\n$$\n\\nabla_{\\mathbf{p}} S(\\mathbf{p}) = \\nabla_{\\mathbf{p}} (\\mathbf{p}^T\\mathbf{A}^T\\mathbf{A}\\mathbf{p} - 2\\mathbf{p}^T\\mathbf{A}^T\\mathbf{y} + \\mathbf{y}^T\\mathbf{y}) = 2\\mathbf{A}^T\\mathbf{A}\\mathbf{p} - 2\\mathbf{A}^T\\mathbf{y} = \\mathbf{0}\n$$\n这就得到了著名的正规方程：\n$$\n\\mathbf{A}^T\\mathbf{A}\\mathbf{p} = \\mathbf{A}^T\\mathbf{y}\n$$\n当矩阵 $\\mathbf{A}^T\\mathbf{A}$ 可逆时（即当 $\\mathbf{A}$ 的列线性无关时），$\\mathbf{p}$ 存在唯一解：\n$$\n\\mathbf{p} = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T\\mathbf{y}\n$$\n问题指定使用 Moore-Penrose 伪逆 $\\mathbf{A}^+$ 来求解 $\\mathbf{p}$。因此，解由 $\\mathbf{p} = \\mathbf{A}^+ \\mathbf{y}$ 给出。这种方法更为优越，因为它即使在 $\\mathbf{A}^T\\mathbf{A}$ 是奇异的情况下也能提供唯一解。如果矩阵 $\\mathbf{A}$ 的列线性相关，它就会变得秩亏，这种情况当且仅当所有训练位置 $x_j$ 都相同时发生（如测试用例 $3$ 所示）。在这种情况下，正规方程有无穷多解。Moore-Penrose 伪逆形式体系通过产生具有最小欧几里得范数 $\\|\\mathbf{p}\\| = \\sqrt{k^2+b^2}$ 的唯一解向量 $\\mathbf{p}$ 来解决这种模糊性。这确保了对于任何给定的训练集，都能得到一个确定性且鲁棒的结果。\n\n完整的算法流程如下：\n$1$. 对于给定的训练集 $\\{(x_j, f_j)\\}_{j=1}^{n}$，构建如上定义的 $n \\times 2$ 设计矩阵 $\\mathbf{A}$ 和 $n \\times 1$ 观测向量 $\\mathbf{y}$。\n$2$. 通过使用 Moore-Penrose 伪逆求解线性系统来计算参数向量 $\\mathbf{p} = \\begin{pmatrix} k \\\\ b \\end{pmatrix}$：$\\mathbf{p} = \\mathbf{A}^+ \\mathbf{y}$。$\\mathbf{p}$ 的分量是估计的刚度 $k$ 和截距 $b$。\n$3$. 从重参数化 $b = k x_0$ 中恢复平衡位置 $x_0$。如果 $k \\neq 0$，则 $x_0 = b/k$。如果 $k$ 为零或在数值上与零无法区分（例如，对于一个小的容差 $\\epsilon$，$|k| < \\epsilon$），则唯一平衡位置的概念变得不明确，因为力是恒定的 $f=b$。在这种情况下，我们将 $x_0 = 0.0$ 作为一个中性的、常规的值。\n$4$. 使用确定的参数 $(k, b)$，为验证集中的每个位置 $x^{\\mathrm{val}}_i$ 预测力 $f^{\\mathrm{pred}}_i$：$f^{\\mathrm{pred}}_i = -k x^{\\mathrm{val}}_i + b$。\n$5$. 通过计算平均绝对误差 (MAE) 来评估模型在验证集上的准确性：$\\mathrm{MAE} = \\frac{1}{m} \\sum_{i=1}^{m} | f^{\\mathrm{pred}}_i - f^{\\mathrm{val}}_i |$，其中 $m$ 是验证集中的数据点数量。\n\n此流程将应用于指定的三个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the parameters of a 1D harmonic mechanical embedding model\n    for three distinct test cases and evaluates the validation error.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"train_x\": np.array([0.8, 1.0, 1.2, 1.4]),\n            \"train_f\": np.array([0.41, -0.02, -0.38, -0.81]),\n            \"val_x\": np.array([0.9, 1.3]),\n            \"val_f\": np.array([0.21, -0.61]),\n        },\n        {\n            \"train_x\": np.array([-0.5, 0.0, 0.5]),\n            \"train_f\": np.array([0.11, 0.0, -0.09]),\n            \"val_x\": np.array([-1.0, 1.0]),\n            \"val_f\": np.array([0.19, -0.21]),\n        },\n        {\n            \"train_x\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"train_f\": np.array([-0.75, -0.75, -0.75, -0.75]),\n            \"val_x\": np.array([0.8, 1.2]),\n            \"val_f\": np.array([-0.45, -1.05]),\n        },\n    ]\n\n    all_results = []\n    \n    # Set a small tolerance for checking if k is close to zero\n    zero_tolerance = 1e-9\n\n    for case in test_cases:\n        # Extract data for the current case\n        x_train = case[\"train_x\"]\n        f_train = case[\"train_f\"]\n        x_val = case[\"val_x\"]\n        f_val = case[\"val_f\"]\n\n        # 1. Construct the design matrix A and observation vector y\n        # The model is f = -k*x + b, so the system is A * [k, b]^T = f\n        # Column for k has coefficients -x_j\n        # Column for b has coefficients 1\n        A = np.vstack([-x_train, np.ones(len(x_train))]).T\n        y = f_train\n\n        # 2. Solve for parameters [k, b] using the Moore-Penrose pseudoinverse\n        # This provides the minimum-norm least-squares solution, robust to rank deficiency\n        try:\n            p = np.linalg.pinv(A) @ y\n            k, b = p[0], p[1]\n        except np.linalg.LinAlgError:\n            # This case should not be reached with pinv, but as a safeguard\n            k, b = 0.0, 0.0\n\n        # 3. Recover equilibrium position x0\n        # If k is effectively zero, x0 is ill-defined. We set it to 0.0 by convention.\n        if abs(k)  zero_tolerance:\n            x0 = 0.0\n        else:\n            x0 = b / k\n\n        # 4. Predict forces on the validation set\n        f_pred = -k * x_val + b\n\n        # 5. Calculate validation Mean Absolute Error (MAE)\n        mae = np.mean(np.abs(f_pred - f_val))\n\n        # Append results for this case to the main list\n        all_results.extend([k, x0, mae])\n\n    # Format the final results to six decimal places and print in the required format\n    formatted_results = [\"{:.6f}\".format(r) for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为 QM/MM 耦合定义了势能函数后，其正确实现对于任何模拟的有效性都至关重要。一个标准的验证程序是比较解析推导的力与数值计算的力。力是势能的负梯度，即 $\\mathbf{F} = -\\nabla E$。这个基本关系使我们能够推导出力的解析表达式，并与通常使用有限差分法计算出的数值近似值进行核对。本练习将强化分子模拟中能量与力之间的本质联系，通过同时实现解析和数值梯度计算，您将掌握计算科学中代码开发和调试的一项关键技能 。",
            "id": "3823974",
            "problem": "您的任务是为量子力学/分子力学 (QM/MM) 中的一种简化机械嵌入方案，实现并验证数值力计算。量子力学/分子力学 (QM/MM) 是一种多尺度策略，它将一个系统划分为量子力学区域和分子力学区域，并通过界面耦合能来保证边界处的结构一致性。在机械嵌入中，耦合完全通过机械（弹性）项实现，分子力学区域不会对量子力学区域产生直接的静电极化。\n\n考虑两个边界原子：一个量子力学边界原子，其位置向量为 $\\mathbf{r}_{\\mathrm{Q}} \\in \\mathbb{R}^{3}$；一个分子力学边界原子，其位置向量为 $\\mathbf{r}_{\\mathrm{M}} \\in \\mathbb{R}^{3}$。设 $\\mathbf{u} \\in \\mathbb{R}^{3}$ 是从参考边界键方向获取的固定单位方向向量（假定已归一化），并令 $\\Delta \\mathbf{r} = \\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}$ 表示相对位移。定义沿 $\\mathbf{u}$ 的轴向投影算符为 $\\mathbf{P}_{\\parallel} = \\mathbf{u}\\mathbf{u}^{\\top}$，垂直投影算符为 $\\mathbf{P}_{\\perp} = \\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}$，其中 $\\mathbf{I}$ 是 $\\mathbb{R}^{3 \\times 3}$ 中的单位矩阵。\n\n机械耦合能定义为\n$$\nE_{\\text{couple}}(\\mathbf{r}_{\\mathrm{Q}}, \\mathbf{r}_{\\mathrm{M}}) = \\frac{k_{\\parallel}}{2}\\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right)^2 + \\frac{k_{\\perp}}{2}\\left\\| \\mathbf{P}_{\\perp}\\,\\Delta \\mathbf{r} \\right\\|^2,\n$$\n其中 $k_{\\parallel}  0$ 是轴向刚度，$k_{\\perp} \\ge 0$ 是横向刚度，$r_0 \\ge 0$ 是沿 $\\mathbf{u}$ 的目标轴向分离距离。力定义为能量相对于笛卡尔坐标的负梯度，这与功能原理和牛顿运动定律一致。\n\n您的程序必须：\n- 使用中心有限差分法，对能量 $E_{\\text{couple}}$ 以一个小的步长 $h$ 计算量子力学边界原子和分子力学边界原子上的数值力。\n- 基于 $E_{\\text{couple}}$ 的定义，推导、实现并使用解析力表达式（您必须从第一性原理推导这些表达式；除了核心微积分和线性代数知识外，不要使用或假设任何预先给定的梯度公式）。\n- 通过比较数值力和解析力并量化它们的差异来验证一致性。\n- 通过检查两个边界原子上的力之和是否近似为零来验证牛顿第三定律。\n\n在简化单位制中，所有量都是无量纲的，因此不需要进行物理单位转换。未使用角度，也不需要角度单位。\n\n数值方法细节：\n- 对每个笛卡尔分量使用中心差分。例如，量子力学边界原子上的力分量满足 $F_{\\mathrm{Q},i} \\approx -\\left(E(\\mathbf{r}_{\\mathrm{Q}}+h\\,\\mathbf{e}_i,\\mathbf{r}_{\\mathrm{M}})-E(\\mathbf{r}_{\\mathrm{Q}}-h\\,\\mathbf{e}_i,\\mathbf{r}_{\\mathrm{M}})\\right)/(2h)$，其中 $\\mathbf{e}_i$ 是 $\\mathbb{R}^{3}$ 中的第 $i$ 个标准基向量，$i \\in \\{1,2,3\\}$。对分子力学边界原子的力分量，应用一个类似的表达式，其中微扰施加在 $\\mathbf{r}_{\\mathrm{M}}$ 上。\n- 使用容差 $\\tau$ 来评估牛顿第三定律，检查 $\\mathbf{F}_{\\mathrm{Q}} + \\mathbf{F}_{\\mathrm{M}}$ 的无穷范数是否小于或等于 $\\tau$。\n\n测试套件：\n为以下三个测试用例实现计算，这些用例旨在覆盖不同的几何和刚度条件：\n1. 一般构型（理想情况）：\n   - $\\mathbf{r}_{\\mathrm{Q}} = [0.8, -0.2, 0.3]$, $\\mathbf{r}_{\\mathrm{M}} = [-0.4, 0.5, 0.1]$,\n   - $\\mathbf{u} = [1.0, 1.0, 0.5]$ （在计算中使用归一化后的向量），\n   - $r_0 = 1.1$, $k_{\\parallel} = 120.0$, $k_{\\perp} = 80.0$.\n2. 纯轴向耦合（横向刚度为零的边界情况）：\n   - $\\mathbf{r}_{\\mathrm{Q}} = [1.0, 0.0, 0.0]$, $\\mathbf{r}_{\\mathrm{M}} = [0.0, 1.0, 0.0]$,\n   - $\\mathbf{u} = [1.0, 0.0, 0.0]$ （在计算中使用归一化后的向量），\n   - $r_0 = 1.0$, $k_{\\parallel} = 50.0$, $k_{\\perp} = 0.0$.\n3. 目标轴向分离距离非零的简并位移：\n   - $\\mathbf{r}_{\\mathrm{Q}} = [0.0, 0.0, 0.0]$, $\\mathbf{r}_{\\mathrm{M}} = [0.0, 0.0, 0.0]$,\n   - $\\mathbf{u} = [0.0, 0.0, 1.0]$ （在计算中使用归一化后的向量），\n   - $r_0 = 0.3$, $k_{\\parallel} = 30.0$, $k_{\\perp} = 10.0$.\n\n算法参数：\n- 中心差分使用 $h = 10^{-6}$。\n- 牛顿第三定律检查使用 $\\tau = 10^{-8}$。\n\n对于每个测试用例，计算：\n- 两个原子上数值力和解析力之间的最大绝对分量级差异，以单个浮点数表示。\n- 一个布尔值，指示数值力是否在容差范围内满足牛顿第三定律，即 $\\left\\|\\mathbf{F}_{\\mathrm{Q}}^{\\text{num}} + \\mathbf{F}_{\\mathrm{M}}^{\\text{num}} \\right\\|_{\\infty} \\le \\tau$ 是否成立。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于三个测试用例中的每一个，该列表必须按顺序首先包含浮点数差异，然后是牛顿第三定律检查的布尔值。例如，输出应类似于 $[\\text{error}_1,\\text{consistent}_1,\\text{error}_2,\\text{consistent}_2,\\text{error}_3,\\text{consistent}_3]$，其中 $\\text{error}_i$ 是一个浮点数，$\\text{consistent}_i$ 是 True 或 False。",
            "solution": "该问题被认为是有效的，因为它在科学上基于经典力学和线性代数，问题陈述清晰且提供了所有必要的参数，其表述是客观的。我们将继续提供解答。\n\n问题的核心是，在一个简化的 QM/MM 机械嵌入方案中，根据一个给定的势能函数计算并比较一个量子力学 (QM) 原子和一个分子力学 (MM) 原子之间的耦合所产生的解析力和数值力。\n\n耦合能由以下公式给出：\n$$\nE_{\\text{couple}}(\\mathbf{r}_{\\mathrm{Q}}, \\mathbf{r}_{\\mathrm{M}}) = \\frac{k_{\\parallel}}{2}\\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right)^2 + \\frac{k_{\\perp}}{2}\\left\\| \\mathbf{P}_{\\perp}\\,\\Delta \\mathbf{r} \\right\\|^2\n$$\n其中 $\\mathbf{r}_{\\mathrm{Q}}$ 和 $\\mathbf{r}_{\\mathrm{M}}$ 分别是 QM 和 MM 原子的位置，$\\Delta \\mathbf{r} = \\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}$ 是相对位移向量，$\\mathbf{u}$ 是一个归一化的方向向量，$k_{\\parallel}$ 和 $k_{\\perp}$ 是刚度常数，$r_0$ 是一个目标分离距离，$\\mathbf{P}_{\\perp} = \\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}$ 是投影到垂直于 $\\mathbf{u}$ 的平面上的投影算符。\n\n### 1. 解析力的推导\n\n力定义为势能相对于原子笛卡尔坐标的负梯度。QM 和 MM 原子上的力分别为：\n$$\n\\mathbf{F}_{\\mathrm{Q}} = -\\nabla_{\\mathbf{r}_{\\mathrm{Q}}} E_{\\text{couple}}\n$$\n$$\n\\mathbf{F}_{\\mathrm{M}} = -\\nabla_{\\mathbf{r}_{\\mathrm{M}}} E_{\\text{couple}}\n$$\n能量函数 $E_{\\text{couple}}$ 仅依赖于相对位移 $\\Delta \\mathbf{r} = \\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}$。使用向量微分的链式法则，我们有：\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{Q}}} E_{\\text{couple}}(\\Delta \\mathbf{r}) = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} \\cdot \\frac{\\partial (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})}{\\partial \\mathbf{r}_{\\mathrm{Q}}} = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} \\cdot \\mathbf{I} = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}}\n$$\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{M}}} E_{\\text{couple}}(\\Delta \\mathbf{r}) = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} \\cdot \\frac{\\partial (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})}{\\partial \\mathbf{r}_{\\mathrm{M}}} = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} \\cdot (-\\mathbf{I}) = -\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}}\n$$\n这直接意味着 $\\mathbf{F}_{\\mathrm{Q}} = - \\mathbf{F}_{\\mathrm{M}}$，这是牛顿第三定律在这种内保守力情况下的体现。\n\n为了找到力的显式形式，我们计算 $E_{\\text{couple}}$ 相对于 $\\Delta \\mathbf{r}$ 的梯度。能量是两项之和，$E_{\\text{couple}} = E_{\\parallel} + E_{\\perp}$。我们可以分别对它们进行微分。\n\n**轴向项 ($E_{\\parallel}$):**\n轴向项是 $E_{\\parallel} = \\frac{k_{\\parallel}}{2}\\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right)^2$。令 $s(\\Delta \\mathbf{r}) = \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0$。$s$ 相对于 $\\Delta \\mathbf{r}$ 的梯度是 $\\nabla_{\\Delta \\mathbf{r}} s = \\mathbf{u}$。使用链式法则：\n$$\n\\nabla_{\\Delta \\mathbf{r}} E_{\\parallel} = \\frac{d E_{\\parallel}}{d s} \\nabla_{\\Delta \\mathbf{r}} s = k_{\\parallel} s \\cdot \\mathbf{u} = k_{\\parallel} \\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u}\n$$\n\n**横向项 ($E_{\\perp}$):**\n横向项是 $E_{\\perp} = \\frac{k_{\\perp}}{2}\\left\\| \\mathbf{P}_{\\perp}\\,\\Delta \\mathbf{r} \\right\\|^2$。这可以写成一个二次型。由于投影算符 $\\mathbf{P}_{\\perp}$ 是对称的（$\\mathbf{P}_{\\perp}^{\\top} = \\mathbf{P}_{\\perp}$）和幂等的（$\\mathbf{P}_{\\perp}^2 = \\mathbf{P}_{\\perp}$），我们有：\n$$\nE_{\\perp} = \\frac{k_{\\perp}}{2} (\\mathbf{P}_{\\perp} \\Delta \\mathbf{r})^{\\top} (\\mathbf{P}_{\\perp} \\Delta \\mathbf{r}) = \\frac{k_{\\perp}}{2} \\Delta \\mathbf{r}^{\\top} \\mathbf{P}_{\\perp}^{\\top} \\mathbf{P}_{\\perp} \\Delta \\mathbf{r} = \\frac{k_{\\perp}}{2} \\Delta \\mathbf{r}^{\\top} \\mathbf{P}_{\\perp} \\Delta \\mathbf{r}\n$$\n对于对称矩阵 $\\mathbf{A}$，二次型 $\\frac{1}{2}\\mathbf{x}^{\\top}\\mathbf{A}\\mathbf{x}$ 的梯度是 $\\mathbf{A}\\mathbf{x}$。因此：\n$$\n\\nabla_{\\Delta \\mathbf{r}} E_{\\perp} = k_{\\perp} \\mathbf{P}_{\\perp} \\Delta \\mathbf{r}\n$$\n\n**总梯度和解析力：**\n结合两项的梯度：\n$$\n\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} = k_{\\parallel} \\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u} + k_{\\perp} \\mathbf{P}_{\\perp} \\Delta \\mathbf{r}\n$$\n代入 $\\mathbf{P}_{\\perp} = \\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}$，梯度的完整表达式为：\n$$\n\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} = k_{\\parallel} \\left( (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}) \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u} + k_{\\perp} (\\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}) (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})\n$$\n最后，QM 和 MM 原子上的解析力为：\n$$\n\\mathbf{F}_{\\mathrm{Q}}^{\\text{an}} = -\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} = - \\left[ k_{\\parallel} \\left( (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}) \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u} + k_{\\perp} (\\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}) (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}) \\right]\n$$\n$$\n\\mathbf{F}_{\\mathrm{M}}^{\\text{an}} = +\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} = k_{\\parallel} \\left( (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}) \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u} + k_{\\perp} (\\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}) (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})\n$$\n\n### 2. 数值力计算与验证\n\n数值力是使用梯度的中心有限差分近似来计算的。对于 QM 原子上力的第 $i$ 个笛卡尔分量（$i \\in \\{1,2,3\\}$），我们有：\n$$\nF_{\\mathrm{Q},i}^{\\text{num}} \\approx -\\frac{E_{\\text{couple}}(\\mathbf{r}_{\\mathrm{Q}}+h\\,\\mathbf{e}_i, \\mathbf{r}_{\\mathrm{M}}) - E_{\\text{couple}}(\\mathbf{r}_{\\mathrm{Q}}-h\\,\\mathbf{e}_i, \\mathbf{r}_{\\mathrm{M}})}{2h}\n$$\n其中 $\\mathbf{e}_i$ 是第 $i$ 个标准基向量，$h$ 是一个小的步长。通过对 $\\mathbf{r}_{\\mathrm{M}}$ 的坐标进行微扰，可以得到一个关于 $\\mathbf{F}_{\\mathrm{M}}^{\\text{num}}$ 的类似表达式。\n\n验证过程包括两个检查：\n1.  **一致性检查**：我们计算两个原子上解析力和数值力之间的最大绝对分量级差异。\n    $$\n    \\text{discrepancy} = \\max_{j \\in \\{\\mathrm{Q}, \\mathrm{M}\\}, i \\in \\{1,2,3\\}} \\left| F_{j,i}^{\\text{an}} - F_{j,i}^{\\text{num}} \\right|\n    $$\n2.  **牛顿第三定律检查**：我们验证数值力之和是否接近于零，这是仅依赖于相对位置的势所导出力的一个属性。我们检查其和的无穷范数是否在给定的容差 $\\tau$ 之内。\n    $$\n    \\left\\| \\mathbf{F}_{\\mathrm{Q}}^{\\text{num}} + \\mathbf{F}_{\\mathrm{M}}^{\\text{num}} \\right\\|_{\\infty} = \\max_{i \\in \\{1,2,3\\}} \\left| F_{\\mathrm{Q},i}^{\\text{num}} + F_{\\mathrm{M},i}^{\\text{num}} \\right| \\le \\tau\n    $$\n对于一个势能 $E(\\mathbf{r}_{\\mathrm{Q}}, \\mathbf{r}_{\\mathrm{M}}) = E(\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})$，在精确算术中，中心差分近似会得出 $F_{\\mathrm{Q},i}^{\\text{num}} + F_{\\mathrm{M},i}^{\\text{num}} = 0$。任何非零结果都是由浮点表示误差引起的。\n\n实现将遵循这些推导出的公式和验证程序，对提供的每个测试用例进行计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the QM/MM mechanical embedding force calculation problem\n    for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"r_Q\": np.array([0.8, -0.2, 0.3]),\n            \"r_M\": np.array([-0.4, 0.5, 0.1]),\n            \"u\": np.array([1.0, 1.0, 0.5]),\n            \"r0\": 1.1,\n            \"k_par\": 120.0,\n            \"k_perp\": 80.0,\n        },\n        {\n            \"r_Q\": np.array([1.0, 0.0, 0.0]),\n            \"r_M\": np.array([0.0, 1.0, 0.0]),\n            \"u\": np.array([1.0, 0.0, 0.0]),\n            \"r0\": 1.0,\n            \"k_par\": 50.0,\n            \"k_perp\": 0.0,\n        },\n        {\n            \"r_Q\": np.array([0.0, 0.0, 0.0]),\n            \"r_M\": np.array([0.0, 0.0, 0.0]),\n            \"u\": np.array([0.0, 0.0, 1.0]),\n            \"r0\": 0.3,\n            \"k_par\": 30.0,\n            \"k_perp\": 10.0,\n        },\n    ]\n\n    h = 1e-6\n    tau = 1e-8\n    results = []\n\n    def coupling_energy(r_Q, r_M, u_norm, r0, k_par, k_perp):\n        \"\"\"Calculates the mechanical coupling energy E_couple.\"\"\"\n        delta_r = r_Q - r_M\n        \n        # Axial term\n        # E_par = (k_par / 2) * ( (delta_r . u) - r0 )^2\n        axial_proj = np.dot(delta_r, u_norm)\n        energy_par = 0.5 * k_par * (axial_proj - r0)**2\n        \n        # Transverse term\n        # E_perp = (k_perp / 2) * || P_perp * delta_r ||^2\n        # P_perp * delta_r = delta_r - u * (u . delta_r)\n        perp_proj_vec = delta_r - u_norm * axial_proj\n        energy_perp = 0.5 * k_perp * np.dot(perp_proj_vec, perp_proj_vec)\n        \n        return energy_par + energy_perp\n\n    for case in test_cases:\n        r_Q, r_M, u, r0, k_par, k_perp = (\n            case[\"r_Q\"], case[\"r_M\"], case[\"u\"], case[\"r0\"], case[\"k_par\"], case[\"k_perp\"]\n        )\n\n        u_norm = u / np.linalg.norm(u)\n        \n        # --- 1. Analytic Forces ---\n        delta_r = r_Q - r_M\n        axial_proj = np.dot(delta_r, u_norm)\n        perp_proj_vec = delta_r - u_norm * axial_proj\n        \n        # Gradient with respect to delta_r\n        grad_delta_r = (k_par * (axial_proj - r0) * u_norm) + (k_perp * perp_proj_vec)\n        \n        F_Q_an = -grad_delta_r\n        F_M_an = grad_delta_r\n        \n        # --- 2. Numerical Forces ---\n        F_Q_num = np.zeros(3)\n        F_M_num = np.zeros(3)\n        \n        for i in range(3):\n            e_i = np.zeros(3)\n            e_i[i] = 1.0\n            \n            # Perturb r_Q\n            r_Q_plus = r_Q + h * e_i\n            r_Q_minus = r_Q - h * e_i\n            E_plus_Q = coupling_energy(r_Q_plus, r_M, u_norm, r0, k_par, k_perp)\n            E_minus_Q = coupling_energy(r_Q_minus, r_M, u_norm, r0, k_par, k_perp)\n            F_Q_num[i] = -(E_plus_Q - E_minus_Q) / (2 * h)\n            \n            # Perturb r_M\n            r_M_plus = r_M + h * e_i\n            r_M_minus = r_M - h * e_i\n            E_plus_M = coupling_energy(r_Q, r_M_plus, u_norm, r0, k_par, k_perp)\n            E_minus_M = coupling_energy(r_Q, r_M_minus, u_norm, r0, k_par, k_perp)\n            F_M_num[i] = -(E_plus_M - E_minus_M) / (2 * h)\n            \n        # --- 3. Verification ---\n        # Discrepancy between analytic and numerical forces\n        diff_Q = np.abs(F_Q_an - F_Q_num)\n        diff_M = np.abs(F_M_an - F_M_num)\n        max_discrepancy = np.max(np.concatenate((diff_Q, diff_M)))\n        \n        # Check Newton's Third Law for numerical forces\n        force_sum = F_Q_num + F_M_num\n        norm_inf_sum = np.max(np.abs(force_sum))\n        newton_check = norm_inf_sum = tau\n        \n        results.append(max_discrepancy)\n        results.append(newton_check)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "当在 QM/MM 边界切断共价键时，通常会引入一个“连接原子”（通常是氢）来饱和 QM 原子的价态。连接原子的放置是一项精细的任务，因为不当的位置会给 QM 计算带来显著的人为影响。本练习通过一个简化的能量模型，将连接原子的能量景观模拟为维持理想价键几何与沿原始断裂键轴向排列之间的竞争。通过将问题简化为单位球面上的约束优化问题，我们可以找到使这些能量惩罚最小化的最优连接原子位置。这项实践展示了如何通过几何洞察和解析推理，优雅地解决一个看似复杂的多维优化问题，从而更深入地理解处理 QM/MM 模拟中共价边界的实际挑战和解决方案 。",
            "id": "3823953",
            "problem": "一个机械嵌入的量子力学/分子力学 (QM/MM) 边界通过一个碳-碳 (C-C) 键进行切割，该键连接量子力学区域中的一个边界碳原子和分子力学区域中的一个分子力学碳原子。为了在量子力学区域中保持价态，在量子力学一侧添加了一个氢连接原子。机械嵌入仅通过几何约束将量子力学区域的几何结构与分子力学区域耦合，而不通过外部电荷修改量子哈密顿量。\n\n假设边界碎片的量子力学能量遵循以下简化的、物理上一致的模型。设边界碳原子位于原点，单位向量 $u$ 从边界碳原子指向量子力学区域中最近的内部碳原子。设单位向量 $v$ 从边界碳原子指向被切割的原始分子力学碳原子。氢连接原子被放置在一个固定的碳-氢键长 $r_{\\mathrm{CH}}$ 处，其方向为一个单位方向 $x$，该方向必须满足球面约束 $\\lVert x \\rVert = 1$，因此连接原子的位置相对于边界碳原子为 $r_{\\mathrm{CH}} x$。碳-氢键长被约束为 $r_{\\mathrm{CH}} = 1.09$ Å，这意味着对能量的键伸缩贡献为零。\n\n将边界碎片的机械嵌入量子力学能量定义为由胡克定律控制的旋转谐波角惩罚之和。以弧度为单位，设 $\\theta(x) = \\arccos(u \\cdot x)$ 为内部量子力学方向与连接原子方向之间的键角，设 $\\phi(x) = \\arccos(v \\cdot x)$ 为原始分子力学边界方向与连接原子方向之间的角度。目标价角为 $\\theta_0$（以弧度为单位）。对于给定的方向 $x$，能量为\n$$\nE(x) = \\tfrac{1}{2} k_a \\left(\\theta(x) - \\theta_0\\right)^2 + \\tfrac{1}{2} k_d \\left(\\phi(x)\\right)^2,\n$$\n其中 $k_a$ 是角力常数，用于惩罚碳-氢键角偏离目标价角 $\\theta_0$ 的情况，$k_d$ 是一个方向耦合常数，用于惩罚氢连接方向偏离指向分子力学区域的原始碳-碳键轴的情况。$k_a$ 和 $k_d$ 的单位均为 $\\mathrm{kJ\\,mol^{-1}\\,rad^{-2}}$，角度单位为弧度。约束条件为 $\\lVert x \\rVert = 1$。\n\n由连接原子放置引起的量子力学能量变化定义为\n$$\n\\Delta E = E_{\\min} - E_{\\mathrm{ref}},\n$$\n其中 $E_{\\min}$ 是 $E(x)$ 在所有单位方向 $x$ 上的最小值，而 $E_{\\mathrm{ref}}$ 是在没有与分子力学区域方向耦合（即 $k_d = 0$）时的参考最小能量。在此模型中，$E_{\\mathrm{ref}} = 0$，因为可以通过单位球面上的适当 $x$ 来实现角度目标 $\\theta(x) = \\theta_0$。\n\n从机械嵌入和经典谐波角模型出发，推导一个通过在单位球面上对 $x$ 进行约束几何优化来计算 $\\Delta E$ 的算法。您的程序必须实现此计算，并为以下测试套件生成数值结果。所有向量输入均以相对于原点边界碳的埃（ångström）坐标给出，并且必须归一化为单位向量以获得 $u$ 和 $v$。所有能量必须以 $\\mathrm{kJ/mol}$ 表示。角度必须以弧度进行解释和计算。\n\n测试套件（每个案例是一个元组 $(C_{\\mathrm{int}}, C_{\\mathrm{MM}}, k_a, k_d, \\theta_0)$）：\n- 案例1（一般折衷）：$C_{\\mathrm{int}} = (0, 0, 1.54)$，$C_{\\mathrm{MM}} = (\\sin(1.0471975512), 0, \\cos(1.0471975512))$，$k_a = 50.0$，$k_d = 20.0$，$\\theta_0 = 1.91113553093$。\n- 案例2（无方向耦合）：$C_{\\mathrm{int}} = (0, 0, 1.54)$，$C_{\\mathrm{MM}} = (\\sin(1.0471975512), 0, \\cos(1.0471975512))$，$k_a = 50.0$，$k_d = 0.0$，$\\theta_0 = 1.91113553093$。\n- 案例3（强未对准）：$C_{\\mathrm{int}} = (0, 0, 1.0)$，$C_{\\mathrm{MM}} = (0, 0, -1.0)$，$k_a = 50.0$，$k_d = 200.0$，$\\theta_0 = 1.91113553093$。\n- 案例4（完美sp2对准）：$C_{\\mathrm{int}} = (0, 0, 1.54)$，$C_{\\mathrm{MM}} = (\\sin(2.09439510239), 0, \\cos(2.09439510239))$，$k_a = 100.0$，$k_d = 100.0$，$\\theta_0 = 2.09439510239$。\n\n您的程序必须：\n- 将 $C_{\\mathrm{int}}$ 和 $C_{\\mathrm{MM}}$ 归一化为单位向量 $u$ 和 $v$。\n- 计算方向间夹角 $\\psi = \\arccos(u \\cdot v)$（以弧度为单位）。\n- 在单位球面上对 $x$ 执行约束几何优化，以找到 $E_{\\min}$，从而计算出 $\\Delta E$（单位为 $\\mathrm{kJ/mol}$）。\n- 将每个 $\\Delta E$ 四舍五入到六位小数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3,result4]\"），每个结果都是一个以 $\\mathrm{kJ/mol}$ 为单位、四舍五入到六位小数的浮点数。",
            "solution": "首先验证该问题是科学上合理的、良态的且客观的。它为使用连接原子的量子力学/分子力学（QM/MM）边界处理提供了一个简化但物理上一致的模型。所有参数都定义清晰，目标是一个可形式化的最小化问题。该问题是有效的。\n\n目标是计算能量位移 $\\Delta E = E_{\\min} - E_{\\mathrm{ref}}$，其中 $E_{\\min}$ 是能量函数\n$$\nE(x) = \\tfrac{1}{2} k_a \\left(\\theta(x) - \\theta_0\\right)^2 + \\tfrac{1}{2} k_d \\left(\\phi(x)\\right)^2\n$$\n在约束条件 $x$ 为单位向量 $\\lVert x \\rVert_2 = 1$ 下的最小值。角度定义为 $\\theta(x) = \\arccos(u \\cdot x)$ 和 $\\phi(x) = \\arccos(v \\cdot x)$，其中 $u$ 和 $v$ 是固定的单位向量。参考能量 $E_{\\mathrm{ref}}$ 是在 $k_d = 0$ 情况下的最小能量，给定为 $E_{\\mathrm{ref}} = 0$。因此，问题简化为寻找 $E_{\\min}$。\n\n这是一个约束优化问题。我们可以通过寻找拉格朗日函数 $\\mathcal{L}(x, \\lambda) = E(x) - \\lambda(\\lVert x \\rVert_2^2 - 1)$ 的驻点来解决它。在极值点，拉格朗日函数关于 $x$ 的梯度必须为零：$\\nabla_x \\mathcal{L} = \\nabla_x E(x) - 2\\lambda x = 0$。这意味着在最小值点，能量函数梯度 $\\nabla_x E(x)$ 必须与位置向量 $x$ 共线。\n\n让我们计算 $E(x)$ 的梯度。使用链式法则和导数 $\\frac{d}{dc}\\arccos(c) = -1/\\sqrt{1-c^2}$：\n$$\n\\nabla_x E(x) = k_a(\\theta(x) - \\theta_0) \\left(\\frac{-1}{\\sqrt{1 - (u \\cdot x)^2}}\\right) \\nabla_x(u \\cdot x) + k_d(\\phi(x)) \\left(\\frac{-1}{\\sqrt{1 - (v \\cdot x)^2}}\\right) \\nabla_x(v \\cdot x)\n$$\n由于 $\\nabla_x(u \\cdot x) = u$ 且 $\\nabla_x(v \\cdot x) = v$，梯度为：\n$$\n\\nabla_x E(x) = -k_a \\frac{\\theta(x) - \\theta_0}{\\sin(\\theta(x))} u - k_d \\frac{\\phi(x)}{\\sin(\\phi(x))} v\n$$\n梯度 $\\nabla_x E(x)$ 是向量 $u$ 和 $v$ 的线性组合。因此，条件 $\\nabla_x E(x) = 2\\lambda x$ 意味着最优向量 $x$ 也必须是 $u$ 和 $v$ 的线性组合。这证明了最优方向 $x$ 位于由向量 $u$ 和 $v$ 张成的平面内。\n\n这一几何洞见极大地简化了问题。我们可以用一个单一的角度 $\\alpha$ 来参数化 $u,v$ 平面中的任何单位向量 $x$，$\\alpha$ 表示 $x$ 和 $u$ 之间的夹角。让我们定义一个坐标系，使得 $u$ 沿着 $z$ 轴，而 $v$ 位于 $xz$ 平面。设 $\\psi = \\arccos(u \\cdot v)$ 是 $u$ 和 $v$ 之间的夹角。在这个坐标系中，$x$ 可以写为 $x = (\\sin\\alpha, 0, \\cos\\alpha)$，其中 $\\alpha \\in [0, \\pi]$。\n\n点积变为：\n$u \\cdot x = \\cos\\alpha \\implies \\theta(x) = \\alpha$。\n$v \\cdot x = \\cos(\\alpha - \\psi)$（或 $\\cos(\\psi-\\alpha)$，没有影响） $\\implies \\phi(x) = |\\alpha - \\psi|$。\n\n现在能量函数是单变量 $\\alpha$ 的函数：\n$$\nE(\\alpha) = \\tfrac{1}{2} k_a (\\alpha - \\theta_0)^2 + \\tfrac{1}{2} k_d (|\\alpha - \\psi|)^2\n$$\n由于第二项是平方项，绝对值是多余的，即 $(|\\alpha - \\psi|)^2 = (\\alpha - \\psi)^2$。需要最小化的函数是一个关于 $\\alpha$ 的简单二次函数：\n$$\nE(\\alpha) = \\tfrac{1}{2} k_a (\\alpha - \\theta_0)^2 + \\tfrac{1}{2} k_d (\\alpha - \\psi)^2\n$$\n为了找到最小值，我们将关于 $\\alpha$ 的导数设为零：\n$$\n\\frac{dE}{d\\alpha} = k_a(\\alpha - \\theta_0) + k_d(\\alpha - \\psi) = 0\n$$\n解出 $\\alpha$：\n$$\n(k_a + k_d) \\alpha = k_a \\theta_0 + k_d \\psi\n$$\n最优角度 $\\alpha^*$ 是 $\\theta_0$ 和 $\\psi$ 的加权平均：\n$$\n\\alpha^* = \\frac{k_a \\theta_0 + k_d \\psi}{k_a + k_d}\n$$\n由于 $\\theta_0 \\in (0, \\pi)$ 且 $\\psi \\in [0, \\pi]$，并且权重是非负的，$\\alpha^*$ 保证在有效范围 $[0, \\pi]$ 内。将 $\\alpha^*$ 代入能量函数即可得到最小能量 $E_{\\min}$。\n能量表达式中的各项变为：\n$\\alpha^* - \\theta_0 = \\frac{k_a \\theta_0 + k_d \\psi - (k_a+k_d)\\theta_0}{k_a + k_d} = \\frac{k_d(\\psi - \\theta_0)}{k_a + k_d}$\n$\\alpha^* - \\psi = \\frac{k_a \\theta_0 + k_d \\psi - (k_a+k_d)\\psi}{k_a + k_d} = \\frac{k_a(\\theta_0 - \\psi)}{k_a + k_d}$\n\n将这些代入 $E(\\alpha^*)$：\n$$\nE_{\\min} = \\tfrac{1}{2} k_a \\left(\\frac{k_d(\\psi - \\theta_0)}{k_a + k_d}\\right)^2 + \\tfrac{1}{2} k_d \\left(\\frac{k_a(\\theta_0 - \\psi)}{k_a + k_d}\\right)^2\n$$\n$$\nE_{\\min} = \\frac{(\\theta_0 - \\psi)^2}{2(k_a + k_d)^2} \\left[ k_a k_d^2 + k_d k_a^2 \\right] = \\frac{(\\theta_0 - \\psi)^2}{2(k_a + k_d)^2} \\left[ k_a k_d (k_a + k_d) \\right]\n$$\n这可以简化为最小能量的最终闭式表达式：\n$$\nE_{\\min} = \\frac{1}{2} \\frac{k_a k_d}{k_a + k_d} (\\theta_0 - \\psi)^2\n$$\n由于 $\\Delta E = E_{\\min} - E_{\\mathrm{ref}}$ 且 $E_{\\mathrm{ref}} = 0$，我们有 $\\Delta E = E_{\\min}$。这个公式在 $k_a+k_d  0$ 时有效。如果 $k_d=0$，该公式正确地得出 $E_{\\min}=0$。\n\n算法如下：\n1. 对于每个测试案例，取输入向量 $C_{\\mathrm{int}}$ 和 $C_{\\mathrm{MM}}$ 并将它们归一化以获得单位向量 $u$ 和 $v$。\n2. 计算点积 $u \\cdot v$。为防止数值误差，将该值限制在 $[-1.0, 1.0]$ 范围内。\n3. 计算角度 $\\psi = \\arccos(u \\cdot v)$。\n4. 使用推导出的公式计算 $\\Delta E = \\frac{1}{2} \\frac{k_a k_d}{k_a + k_d} (\\theta_0 - \\psi)^2$。\n5. 将结果四舍五入到 $6$ 位小数。\n\n这个解析解构成了所要求的约束几何优化的最有效算法。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the QM/MM link atom energy problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (general compromise)\n        (\n            (0, 0, 1.54),\n            (np.sin(1.0471975512), 0, np.cos(1.0471975512)),\n            50.0, 20.0, 1.91113553093\n        ),\n        # Case 2 (no directional coupling)\n        (\n            (0, 0, 1.54),\n            (np.sin(1.0471975512), 0, np.cos(1.0471975512)),\n            50.0, 0.0, 1.91113553093\n        ),\n        # Case 3 (strong misalignment)\n        (\n            (0, 0, 1.0),\n            (0, 0, -1.0),\n            50.0, 200.0, 1.91113553093\n        ),\n        # Case 4 (perfect sp2 alignment)\n        (\n            (0, 0, 1.54),\n            (np.sin(2.09439510239), 0, np.cos(2.09439510239)),\n            100.0, 100.0, 2.09439510239\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        C_int_tuple, C_MM_tuple, k_a, k_d, theta_0 = case\n        \n        # Convert tuples to numpy arrays\n        C_int = np.array(C_int_tuple, dtype=float)\n        C_MM = np.array(C_MM_tuple, dtype=float)\n\n        # Step 1: Normalize C_int and C_MM to unit vectors u and v.\n        norm_C_int = np.linalg.norm(C_int)\n        if norm_C_int == 0:\n            # Handle the unlikely case of a zero vector\n            u = np.zeros(3)\n        else:\n            u = C_int / norm_C_int\n\n        norm_C_MM = np.linalg.norm(C_MM)\n        if norm_C_MM == 0:\n            v = np.zeros(3)\n        else:\n            v = C_MM / norm_C_MM\n            \n        # Step 2: Compute the inter-direction angle psi = arccos(u . v).\n        dot_uv = np.dot(u, v)\n        # Clip to handle potential floating point inaccuracies\n        dot_uv = np.clip(dot_uv, -1.0, 1.0)\n        psi = np.arccos(dot_uv)\n\n        # Step 3: Compute E_min (which is Delta E) using the derived formula.\n        # Delta_E = 0.5 * (k_a * k_d) / (k_a + k_d) * (theta_0 - psi)^2\n        # This formula holds even if k_d is 0.\n        # If k_a + k_d is 0 (i.e., both are 0), the result is 0.\n        denominator = k_a + k_d\n        if denominator == 0.0:\n            delta_E = 0.0\n        else:\n            effective_k = (k_a * k_d) / denominator\n            delta_E = 0.5 * effective_k * (theta_0 - psi)**2\n            \n        results.append(delta_E)\n\n    # Format the output as a comma-separated list of floats rounded to 6 decimal places,\n    # enclosed in square brackets.\n    output_str = \"[\" + \",\".join(f\"{res:.6f}\" for res in results) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}