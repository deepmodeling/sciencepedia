{
    "hands_on_practices": [
        {
            "introduction": "The essence of mechanical embedding is to represent the influence of the classical MM region on the quantum QM boundary with a simple, classical potential. This exercise tackles the foundational step of this process: parameterization. Using reference force data obtained from high-fidelity QM calculations, we will determine the optimal parameters for a simple harmonic model, $f = -k(x - x_0)$, that describes the boundary interaction. This practice of fitting a classical potential to quantum data is a cornerstone of building robust multiscale models.",
            "id": "3823910",
            "problem": "Consider mechanical embedding in Quantum Mechanics/Molecular Mechanics (QM/MM), where the Molecular Mechanics (MM) environment exerts boundary forces on the Quantum Mechanics (QM) region. Assume a one-dimensional harmonic mechanical embedding model for a single QM degree of freedom, in which the MM boundary exerts a force on the QM coordinate given by Hooke’s law, $f = -k(x - x_0)$, where $f$ is the force in electronvolt per ångström ($\\mathrm{eV}/\\mathrm{\\AA}$), $x$ is the coordinate in ångström ($\\mathrm{\\AA}$), $k$ is the stiffness in electronvolt per ångström squared ($\\mathrm{eV}/\\mathrm{\\AA}^{2}$), and $x_0$ is the equilibrium position in ångström ($\\mathrm{\\AA}$). Let a set of training configurations provide pairs $\\{(x_j, f_j)\\}_{j=1}^{n}$ derived from Quantum Mechanics force calculations, and a validation set provide pairs $\\{(x^{\\mathrm{val}}_i, f^{\\mathrm{val}}_i)\\}_{i=1}^{m}$ for held-out configurations. Define the reparameterization $b = k x_0$ so that $f_j = -k x_j + b$. The goal is to compute the optimal parameters $(k, x_0)$ in the least-squares sense on the training set and then predict the forces on the validation set to assess accuracy.\n\nStarting from the principle of linear superposition and Hooke’s law, and using the least-squares criterion, derive the optimality conditions for $(k,b)$ that minimize $\\sum_{j=1}^{n} (-k x_j + b - f_j)^2$. Then, implement a robust solver that uses the Moore–Penrose pseudoinverse to obtain the minimum-norm solution for $(k,b)$ even when the training design matrix is rank-deficient. After estimating $(k,b)$, recover $x_0$ via $x_0 = b/k$ when $k \\neq 0$, and define predictions on validation configurations as $f^{\\mathrm{pred}}_i = -k x^{\\mathrm{val}}_i + b$. Evaluate the validation mean absolute error as $\\mathrm{MAE} = \\frac{1}{m} \\sum_{i=1}^{m} | f^{\\mathrm{pred}}_i - f^{\\mathrm{val}}_i |$. All physical quantities must be handled with the specified units: $x$ in $\\mathrm{\\AA}$, $f$ in $\\mathrm{eV}/\\mathrm{\\AA}$, $k$ in $\\mathrm{eV}/\\mathrm{\\AA}^{2}$, and $\\mathrm{MAE}$ in $\\mathrm{eV}/\\mathrm{\\AA}$.\n\nYour program must solve the following three test cases, each containing a training set and a validation set:\n\nTest Case $1$ (well-conditioned training data with small deterministic noise):\n- Training positions $x$: $[0.8, 1.0, 1.2, 1.4]$ $\\mathrm{\\AA}$.\n- Training forces $f$: $[0.41, -0.02, -0.38, -0.81]$ $\\mathrm{eV}/\\mathrm{\\AA}$.\n- Validation positions $x^{\\mathrm{val}}$: $[0.9, 1.3]$ $\\mathrm{\\AA}$.\n- Validation forces $f^{\\mathrm{val}}$: $[0.21, -0.61]$ $\\mathrm{eV}/\\mathrm{\\AA}$.\n\nTest Case $2$ (near-zero stiffness):\n- Training positions $x$: $[-0.5, 0.0, 0.5]$ $\\mathrm{\\AA}$.\n- Training forces $f$: $[0.11, 0.0, -0.09]$ $\\mathrm{eV}/\\mathrm{\\AA}$.\n- Validation positions $x^{\\mathrm{val}}$: $[-1.0, 1.0]$ $\\mathrm{\\AA}$.\n- Validation forces $f^{\\mathrm{val}}$: $[0.19, -0.21]$ $\\mathrm{eV}/\\mathrm{\\AA}$.\n\nTest Case $3$ (rank-deficient training data where all positions are identical):\n- Training positions $x$: $[1.0, 1.0, 1.0, 1.0]$ $\\mathrm{\\AA}$.\n- Training forces $f$: $[-0.75, -0.75, -0.75, -0.75]$ $\\mathrm{eV}/\\mathrm{\\AA}$.\n- Validation positions $x^{\\mathrm{val}}$: $[0.8, 1.2]$ $\\mathrm{\\AA}$.\n- Validation forces $f^{\\mathrm{val}}$: $[-0.45, -1.05]$ $\\mathrm{eV}/\\mathrm{\\AA}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output three numbers in sequence: the estimated stiffness $k$ in $\\mathrm{eV}/\\mathrm{\\AA}^{2}$, the estimated equilibrium position $x_0$ in $\\mathrm{\\AA}$, and the validation mean absolute error in $\\mathrm{eV}/\\mathrm{\\AA}$. All numbers must be rounded to six decimal places, and the full output should therefore contain nine numbers corresponding to all three test cases in order, for example, $[k_1,x_{0,1},\\mathrm{MAE}_1,k_2,x_{0,2},\\mathrm{MAE}_2,k_3,x_{0,3},\\mathrm{MAE}_3]$.",
            "solution": "The problem statement has been meticulously validated and is determined to be **valid**. It is scientifically grounded, well-posed, objective, and internally consistent. It presents a standard problem in computational materials science—parameterizing a classical force field model from quantum mechanical data—and provides all necessary information to derive and implement a robust numerical solution.\n\nThe core of the problem is to determine the optimal parameters $(k, x_0)$ for a one-dimensional harmonic force model, $f = -k(x - x_0)$, based on a set of training data $\\{(x_j, f_j)\\}_{j=1}^{n}$. The model is reparameterized into a linear form $f_j = -k x_j + b$, where $b = k x_0$. This transformation allows us to employ the principles of linear least-squares regression.\n\nThe objective is to find the parameter vector $\\mathbf{p} = \\begin{pmatrix} k \\\\ b \\end{pmatrix}$ that minimizes the sum of squared errors, $S(\\mathbf{p})$, between the model's predictions and the provided training forces $f_j$.\nFor a set of $n$ training points, we can express the problem as an overdetermined system of linear equations:\n$$\n-k x_1 + b \\approx f_1 \\\\\n-k x_2 + b \\approx f_2 \\\\\n\\vdots \\\\\n-k x_n + b \\approx f_n \\\\\n$$\nThis system can be written in matrix form as $\\mathbf{A}\\mathbf{p} \\approx \\mathbf{y}$, where the design matrix $\\mathbf{A}$, the parameter vector $\\mathbf{p}$, and the observation vector $\\mathbf{y}$ are defined as:\n$$\n\\mathbf{A} = \\begin{pmatrix}\n-x_1 & 1 \\\\\n-x_2 & 1 \\\\\n\\vdots & \\vdots \\\\\n-x_n & 1\n\\end{pmatrix}, \\quad\n\\mathbf{p} = \\begin{pmatrix}\nk \\\\\nb\n\\end{pmatrix}, \\quad\n\\mathbf{y} = \\begin{pmatrix}\nf_1 \\\\\nf_2 \\\\\n\\vdots \\\\\nf_n\n\\end{pmatrix}\n$$\nThe least-squares criterion requires minimizing the squared Euclidean norm of the residual vector, $\\mathbf{r} = \\mathbf{A}\\mathbf{p} - \\mathbf{y}$:\n$$\nS(\\mathbf{p}) = \\|\\mathbf{r}\\|^2 = \\|\\mathbf{A}\\mathbf{p} - \\mathbf{y}\\|^2 = (\\mathbf{A}\\mathbf{p} - \\mathbf{y})^T(\\mathbf{A}\\mathbf{p} - \\mathbf{y})\n$$\nTo find the minimum, we set the gradient of $S(\\mathbf{p})$ with respect to $\\mathbf{p}$ to zero:\n$$\n\\nabla_{\\mathbf{p}} S(\\mathbf{p}) = \\nabla_{\\mathbf{p}} (\\mathbf{p}^T\\mathbf{A}^T\\mathbf{A}\\mathbf{p} - 2\\mathbf{p}^T\\mathbf{A}^T\\mathbf{y} + \\mathbf{y}^T\\mathbf{y}) = 2\\mathbf{A}^T\\mathbf{A}\\mathbf{p} - 2\\mathbf{A}^T\\mathbf{y} = \\mathbf{0}\n$$\nThis yields the celebrated normal equations:\n$$\n\\mathbf{A}^T\\mathbf{A}\\mathbf{p} = \\mathbf{A}^T\\mathbf{y}\n$$\nWhen the matrix $\\mathbf{A}^T\\mathbf{A}$ is invertible (i.e., when the columns of $\\mathbf{A}$ are linearly independent), there exists a unique solution for $\\mathbf{p}$:\n$$\n\\mathbf{p} = (\\mathbf{A}^T\\mathbf{A})^{-1}\\mathbf{A}^T\\mathbf{y}\n$$\nThe problem specifies the use of the Moore-Penrose pseudoinverse, $\\mathbf{A}^+$, to solve for $\\mathbf{p}$. The solution is thus given by $\\mathbf{p} = \\mathbf{A}^+ \\mathbf{y}$. This approach is superior because it provides a unique solution even when $\\mathbf{A}^T\\mathbf{A}$ is singular. The matrix $\\mathbf{A}$ becomes rank-deficient if its columns are linearly dependent, which occurs if and only if all training positions $x_j$ are identical (as in Test Case $3$). In such a scenario, the normal equations admit infinitely many solutions. The Moore-Penrose pseudoinverse formalism resolves this ambiguity by yielding the unique solution vector $\\mathbf{p}$ that has the minimum Euclidean norm, $\\|\\mathbf{p}\\| = \\sqrt{k^2+b^2}$. This ensures a deterministic and robust outcome for any given training set.\n\nThe complete algorithmic procedure is as follows:\n$1$. For a given training set $\\{(x_j, f_j)\\}_{j=1}^{n}$, construct the $n \\times 2$ design matrix $\\mathbf{A}$ and the $n \\times 1$ observation vector $\\mathbf{y}$ as defined above.\n$2$. Compute the parameter vector $\\mathbf{p} = \\begin{pmatrix} k \\\\ b \\end{pmatrix}$ by solving the linear system using the Moore-Penrose pseudoinverse: $\\mathbf{p} = \\mathbf{A}^+ \\mathbf{y}$. The components of $\\mathbf{p}$ are the estimated stiffness $k$ and the intercept $b$.\n$3$. Recover the equilibrium position $x_0$ from the reparameterization $b = k x_0$. If $k \\neq 0$, then $x_0 = b/k$. If $k$ is zero or numerically indistinguishable from zero (e.g., $|k| < \\epsilon$ for a small tolerance $\\epsilon$), the concept of a unique equilibrium position becomes ill-defined as the force is constant, $f=b$. In this case, we assign $x_0 = 0.0$ as a neutral, conventional value.\n$4$. Using the determined parameters $(k, b)$, predict the forces $f^{\\mathrm{pred}}_i$ for each position $x^{\\mathrm{val}}_i$ in the validation set: $f^{\\mathrm{pred}}_i = -k x^{\\mathrm{val}}_i + b$.\n$5$. Evaluate the model's accuracy on the validation set by computing the Mean Absolute Error (MAE): $\\mathrm{MAE} = \\frac{1}{m} \\sum_{i=1}^{m} | f^{\\mathrm{pred}}_i - f^{\\mathrm{val}}_i |$, where $m$ is the number of data points in the validation set.\n\nThis procedure will be applied to each of the three test cases specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the parameters of a 1D harmonic mechanical embedding model\n    for three distinct test cases and evaluates the validation error.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"train_x\": np.array([0.8, 1.0, 1.2, 1.4]),\n            \"train_f\": np.array([0.41, -0.02, -0.38, -0.81]),\n            \"val_x\": np.array([0.9, 1.3]),\n            \"val_f\": np.array([0.21, -0.61]),\n        },\n        {\n            \"train_x\": np.array([-0.5, 0.0, 0.5]),\n            \"train_f\": np.array([0.11, 0.0, -0.09]),\n            \"val_x\": np.array([-1.0, 1.0]),\n            \"val_f\": np.array([0.19, -0.21]),\n        },\n        {\n            \"train_x\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"train_f\": np.array([-0.75, -0.75, -0.75, -0.75]),\n            \"val_x\": np.array([0.8, 1.2]),\n            \"val_f\": np.array([-0.45, -1.05]),\n        },\n    ]\n\n    all_results = []\n    \n    # Set a small tolerance for checking if k is close to zero\n    zero_tolerance = 1e-9\n\n    for case in test_cases:\n        # Extract data for the current case\n        x_train = case[\"train_x\"]\n        f_train = case[\"train_f\"]\n        x_val = case[\"val_x\"]\n        f_val = case[\"val_f\"]\n\n        # 1. Construct the design matrix A and observation vector y\n        # The model is f = -k*x + b, so the system is A * [k, b]^T = f\n        # Column for k has coefficients -x_j\n        # Column for b has coefficients 1\n        A = np.vstack([-x_train, np.ones(len(x_train))]).T\n        y = f_train\n\n        # 2. Solve for parameters [k, b] using the Moore-Penrose pseudoinverse\n        # This provides the minimum-norm least-squares solution, robust to rank deficiency\n        try:\n            p = np.linalg.pinv(A) @ y\n            k, b = p[0], p[1]\n        except np.linalg.LinAlgError:\n            # This case should not be reached with pinv, but as a safeguard\n            k, b = 0.0, 0.0\n\n        # 3. Recover equilibrium position x0\n        # If k is effectively zero, x0 is ill-defined. We set it to 0.0 by convention.\n        if abs(k) < zero_tolerance:\n            x0 = 0.0\n        else:\n            x0 = b / k\n\n        # 4. Predict forces on the validation set\n        f_pred = -k * x_val + b\n\n        # 5. Calculate validation Mean Absolute Error (MAE)\n        mae = np.mean(np.abs(f_pred - f_val))\n\n        # Append results for this case to the main list\n        all_results.extend([k, x0, mae])\n\n    # Format the final results to six decimal places and print in the required format\n    formatted_results = [\"{:.6f}\".format(r) for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once a coupling energy function is defined for the QM/MM boundary, its correct implementation is paramount for accurate simulations. This practice focuses on the crucial verification step of comparing analytically derived forces with their numerical counterparts obtained through finite differences. Such \"gradient checks\" are a standard procedure in computational science to ensure that the forces, which drive molecular dynamics and geometry optimization, are a faithful representation of the chosen energy model. Furthermore, this exercise verifies the conservation of momentum by confirming that the action-reaction principle (Newton's third law) holds for the internal QM-MM forces.",
            "id": "3823974",
            "problem": "You are tasked with implementing and validating numerical force calculations for a simplified mechanical embedding scheme in Quantum Mechanics/Molecular Mechanics (QM/MM). Quantum Mechanics/Molecular Mechanics (QM/MM) is a multiscale strategy that partitions a system into a quantum mechanical region and a molecular mechanical region, with an interfacial coupling energy enforcing structural consistency at the boundary. In mechanical embedding, the coupling is purely through mechanical (elastic) terms, without direct electrostatic polarization of the quantum mechanical region by the molecular mechanical region.\n\nConsider two boundary atoms: one quantum mechanical boundary atom with position vector $\\mathbf{r}_{\\mathrm{Q}} \\in \\mathbb{R}^{3}$ and one molecular mechanical boundary atom with position vector $\\mathbf{r}_{\\mathrm{M}} \\in \\mathbb{R}^{3}$. Let $\\mathbf{u} \\in \\mathbb{R}^{3}$ be a fixed unit direction vector taken from the reference boundary bond orientation (assumed normalized), and let $\\Delta \\mathbf{r} = \\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}$ denote the relative displacement. Define the axial projection operator along $\\mathbf{u}$ as $\\mathbf{P}_{\\parallel} = \\mathbf{u}\\mathbf{u}^{\\top}$ and the perpendicular projection operator as $\\mathbf{P}_{\\perp} = \\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}$, where $\\mathbf{I}$ is the identity matrix in $\\mathbb{R}^{3 \\times 3}$.\n\nThe mechanical coupling energy is defined as\n$$\nE_{\\text{couple}}(\\mathbf{r}_{\\mathrm{Q}}, \\mathbf{r}_{\\mathrm{M}}) = \\frac{k_{\\parallel}}{2}\\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right)^2 + \\frac{k_{\\perp}}{2}\\left\\| \\mathbf{P}_{\\perp}\\,\\Delta \\mathbf{r} \\right\\|^2,\n$$\nwhere $k_{\\parallel} > 0$ is the axial stiffness, $k_{\\perp} \\ge 0$ is the transverse stiffness, and $r_0 \\ge 0$ is the target axial separation along $\\mathbf{u}$. Forces are defined by the negative gradient of the energy with respect to Cartesian coordinates, consistent with the work-energy principle and Newton's laws of motion.\n\nYour program must:\n- Compute numerical forces on the quantum mechanical boundary atom and the molecular mechanical boundary atom using central finite differences on the energy $E_{\\text{couple}}$ with a small step size $h$.\n- Derive, implement, and use analytic force expressions based on the definition of $E_{\\text{couple}}$ (you must derive these expressions from first principles; do not use or assume any pre-given gradient formulas beyond core calculus and linear algebra).\n- Verify consistency by comparing numerical and analytic forces and quantifying their discrepancy.\n- Verify Newton’s third law by checking that the sum of the forces on the two boundary atoms is approximately zero.\n\nAll quantities are dimensionless in a reduced unit system, so no physical unit conversion is required. Angles are not used, and no angle units are needed.\n\nNumerical method details:\n- Use central difference for each Cartesian component. For example, the force component on the quantum mechanical boundary atom satisfies $F_{\\mathrm{Q},i} \\approx -\\left(E(\\mathbf{r}_{\\mathrm{Q}}+h\\,\\mathbf{e}_i,\\mathbf{r}_{\\mathrm{M}})-E(\\mathbf{r}_{\\mathrm{Q}}-h\\,\\mathbf{e}_i,\\mathbf{r}_{\\mathrm{M}})\\right)/(2h)$, where $\\mathbf{e}_i$ is the $i$-th standard basis vector in $\\mathbb{R}^{3}$ and $i \\in \\{1,2,3\\}$. An analogous expression applies for the molecular mechanical boundary atom force components with perturbations applied to $\\mathbf{r}_{\\mathrm{M}}$.\n- Use a tolerance $\\tau$ to assess Newton’s third law, checking whether the infinity norm of $\\mathbf{F}_{\\mathrm{Q}} + \\mathbf{F}_{\\mathrm{M}}$ is less than or equal to $\\tau$.\n\nTest suite:\nImplement the computations for the following three test cases, designed to cover diverse geometric and stiffness conditions:\n1. General configuration (happy path):\n   - $\\mathbf{r}_{\\mathrm{Q}} = [0.8, -0.2, 0.3]$, $\\mathbf{r}_{\\mathrm{M}} = [-0.4, 0.5, 0.1]$,\n   - $\\mathbf{u} = [1.0, 1.0, 0.5]$ (use the normalized vector in the computation),\n   - $r_0 = 1.1$, $k_{\\parallel} = 120.0$, $k_{\\perp} = 80.0$.\n2. Pure axial coupling (boundary case with zero transverse stiffness):\n   - $\\mathbf{r}_{\\mathrm{Q}} = [1.0, 0.0, 0.0]$, $\\mathbf{r}_{\\mathrm{M}} = [0.0, 1.0, 0.0]$,\n   - $\\mathbf{u} = [1.0, 0.0, 0.0]$ (use the normalized vector in the computation),\n   - $r_0 = 1.0$, $k_{\\parallel} = 50.0$, $k_{\\perp} = 0.0$.\n3. Degenerate displacement with nonzero target axial separation:\n   - $\\mathbf{r}_{\\mathrm{Q}} = [0.0, 0.0, 0.0]$, $\\mathbf{r}_{\\mathrm{M}} = [0.0, 0.0, 0.0]$,\n   - $\\mathbf{u} = [0.0, 0.0, 1.0]$ (use the normalized vector in the computation),\n   - $r_0 = 0.3$, $k_{\\parallel} = 30.0$, $k_{\\perp} = 10.0$.\n\nAlgorithmic parameters:\n- Use $h = 10^{-6}$ for central differences.\n- Use $\\tau = 10^{-8}$ for the Newton’s third law check.\n\nFor each test case, compute:\n- The maximum absolute component-wise discrepancy between the numerical and analytic forces over both atoms, as a single float.\n- A boolean indicating whether the numerical forces satisfy Newton’s third law within tolerance, i.e., whether $\\left\\|\\mathbf{F}_{\\mathrm{Q}}^{\\text{num}} + \\mathbf{F}_{\\mathrm{M}}^{\\text{num}} \\right\\|_{\\infty} \\le \\tau$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, for each of the three test cases in order, first the float discrepancy and then the boolean for the Newton’s third law check. For example, the output should look like $[\\text{error}_1,\\text{consistent}_1,\\text{error}_2,\\text{consistent}_2,\\text{error}_3,\\text{consistent}_3]$, where $\\text{error}_i$ is a float and $\\text{consistent}_i$ is either True or False.",
            "solution": "The problem is deemed valid as it is scientifically grounded in classical mechanics and linear algebra, well-posed with all necessary parameters provided, and objective in its formulation. We will proceed with a solution.\n\nThe core of the problem is to compute and compare analytic and numerical forces derived from a given potential energy function describing the coupling between a quantum mechanical (QM) atom and a molecular mechanical (MM) atom in a simplified QM/MM mechanical embedding scheme.\n\nThe coupling energy is given by:\n$$\nE_{\\text{couple}}(\\mathbf{r}_{\\mathrm{Q}}, \\mathbf{r}_{\\mathrm{M}}) = \\frac{k_{\\parallel}}{2}\\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right)^2 + \\frac{k_{\\perp}}{2}\\left\\| \\mathbf{P}_{\\perp}\\,\\Delta \\mathbf{r} \\right\\|^2\n$$\nwhere $\\mathbf{r}_{\\mathrm{Q}}$ and $\\mathbf{r}_{\\mathrm{M}}$ are the positions of the QM and MM atoms, $\\Delta \\mathbf{r} = \\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}$ is the relative displacement vector, $\\mathbf{u}$ is a normalized direction vector, $k_{\\parallel}$ and $k_{\\perp}$ are stiffness constants, $r_0$ is a target separation, and $\\mathbf{P}_{\\perp} = \\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}$ is the projection operator onto the plane perpendicular to $\\mathbf{u}$.\n\n### 1. Derivation of Analytic Forces\n\nForces are defined as the negative gradient of the potential energy with respect to the Cartesian coordinates of the atoms. The forces on the QM and MM atoms are, respectively:\n$$\n\\mathbf{F}_{\\mathrm{Q}} = -\\nabla_{\\mathbf{r}_{\\mathrm{Q}}} E_{\\text{couple}}\n$$\n$$\n\\mathbf{F}_{\\mathrm{M}} = -\\nabla_{\\mathbf{r}_{\\mathrm{M}}} E_{\\text{couple}}\n$$\nThe energy function $E_{\\text{couple}}$ depends only on the relative displacement $\\Delta \\mathbf{r} = \\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}$. Using the chain rule for vector differentiation, we have:\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{Q}}} E_{\\text{couple}}(\\Delta \\mathbf{r}) = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} \\cdot \\frac{\\partial (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})}{\\partial \\mathbf{r}_{\\mathrm{Q}}} = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} \\cdot \\mathbf{I} = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}}\n$$\n$$\n\\nabla_{\\mathbf{r}_{\\mathrm{M}}} E_{\\text{couple}}(\\Delta \\mathbf{r}) = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} \\cdot \\frac{\\partial (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})}{\\partial \\mathbf{r}_{\\mathrm{M}}} = \\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} \\cdot (-\\mathbf{I}) = -\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}}\n$$\nThis directly implies that $\\mathbf{F}_{\\mathrm{Q}} = - \\mathbf{F}_{\\mathrm{M}}$, which is a manifestation of Newton's third law for this internal conservative force.\n\nTo find the explicit form of the forces, we compute the gradient of $E_{\\text{couple}}$ with respect to $\\Delta \\mathbf{r}$. The energy is a sum of two terms, $E_{\\text{couple}} = E_{\\parallel} + E_{\\perp}$. We can differentiate them separately.\n\n**Axial Term ($E_{\\parallel}$):**\nThe axial term is $E_{\\parallel} = \\frac{k_{\\parallel}}{2}\\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right)^2$. Let $s(\\Delta \\mathbf{r}) = \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0$. The gradient of $s$ with respect to $\\Delta \\mathbf{r}$ is $\\nabla_{\\Delta \\mathbf{r}} s = \\mathbf{u}$. Using the chain rule:\n$$\n\\nabla_{\\Delta \\mathbf{r}} E_{\\parallel} = \\frac{d E_{\\parallel}}{d s} \\nabla_{\\Delta \\mathbf{r}} s = k_{\\parallel} s \\cdot \\mathbf{u} = k_{\\parallel} \\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u}\n$$\n\n**Transverse Term ($E_{\\perp}$):**\nThe transverse term is $E_{\\perp} = \\frac{k_{\\perp}}{2}\\left\\| \\mathbf{P}_{\\perp}\\,\\Delta \\mathbf{r} \\right\\|^2$. This can be written as a quadratic form. Since the projection operator $\\mathbf{P}_{\\perp}$ is symmetric ($\\mathbf{P}_{\\perp}^{\\top} = \\mathbf{P}_{\\perp}$) and idempotent ($\\mathbf{P}_{\\perp}^2 = \\mathbf{P}_{\\perp}$), we have:\n$$\nE_{\\perp} = \\frac{k_{\\perp}}{2} (\\mathbf{P}_{\\perp} \\Delta \\mathbf{r})^{\\top} (\\mathbf{P}_{\\perp} \\Delta \\mathbf{r}) = \\frac{k_{\\perp}}{2} \\Delta \\mathbf{r}^{\\top} \\mathbf{P}_{\\perp}^{\\top} \\mathbf{P}_{\\perp} \\Delta \\mathbf{r} = \\frac{k_{\\perp}}{2} \\Delta \\mathbf{r}^{\\top} \\mathbf{P}_{\\perp} \\Delta \\mathbf{r}\n$$\nThe gradient of a quadratic form $\\frac{1}{2}\\mathbf{x}^{\\top}\\mathbf{A}\\mathbf{x}$ with a symmetric matrix $\\mathbf{A}$ is $\\mathbf{A}\\mathbf{x}$. Therefore:\n$$\n\\nabla_{\\Delta \\mathbf{r}} E_{\\perp} = k_{\\perp} \\mathbf{P}_{\\perp} \\Delta \\mathbf{r}\n$$\n\n**Total Gradient and Analytic Forces:**\nCombining the gradients of the two terms:\n$$\n\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} = k_{\\parallel} \\left( \\Delta \\mathbf{r} \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u} + k_{\\perp} \\mathbf{P}_{\\perp} \\Delta \\mathbf{r}\n$$\nSubstituting $\\mathbf{P}_{\\perp} = \\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}$, the full expression for the gradient is:\n$$\n\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} = k_{\\parallel} \\left( (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}) \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u} + k_{\\perp} (\\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}) (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})\n$$\nFinally, the analytic forces on the QM and MM atoms are:\n$$\n\\mathbf{F}_{\\mathrm{Q}}^{\\text{an}} = -\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} = - \\left[ k_{\\parallel} \\left( (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}) \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u} + k_{\\perp} (\\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}) (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}) \\right]\n$$\n$$\n\\mathbf{F}_{\\mathrm{M}}^{\\text{an}} = +\\nabla_{\\Delta \\mathbf{r}} E_{\\text{couple}} = k_{\\parallel} \\left( (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}}) \\cdot \\mathbf{u} - r_0 \\right) \\mathbf{u} + k_{\\perp} (\\mathbf{I} - \\mathbf{u}\\mathbf{u}^{\\top}) (\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})\n$$\n\n### 2. Numerical Force Calculation and Verification\n\nThe numerical forces are computed using the central finite difference approximation for the gradient. For the $i$-th Cartesian component ($i \\in \\{1,2,3\\}$) of the force on the QM atom, we have:\n$$\nF_{\\mathrm{Q},i}^{\\text{num}} \\approx -\\frac{E_{\\text{couple}}(\\mathbf{r}_{\\mathrm{Q}}+h\\,\\mathbf{e}_i, \\mathbf{r}_{\\mathrm{M}}) - E_{\\text{couple}}(\\mathbf{r}_{\\mathrm{Q}}-h\\,\\mathbf{e}_i, \\mathbf{r}_{\\mathrm{M}})}{2h}\n$$\nwhere $\\mathbf{e}_i$ is the $i$-th standard basis vector and $h$ is a small step size. A similar expression holds for $\\mathbf{F}_{\\mathrm{M}}^{\\text{num}}$ by perturbing the coordinates of $\\mathbf{r}_{\\mathrm{M}}$.\n\nThe verification process involves two checks:\n1.  **Consistency Check**: We compute the maximum absolute component-wise discrepancy between the analytic and numerical forces across both atoms.\n    $$\n    \\text{discrepancy} = \\max_{j \\in \\{\\mathrm{Q}, \\mathrm{M}\\}, i \\in \\{1,2,3\\}} \\left| F_{j,i}^{\\text{an}} - F_{j,i}^{\\text{num}} \\right|\n    $$\n2.  **Newton's Third Law Check**: We verify that the sum of the numerical forces is close to zero, which is a property of forces derived from a potential dependent only on relative positions. We check if the infinity norm of the sum is within a given tolerance $\\tau$.\n    $$\n    \\left\\| \\mathbf{F}_{\\mathrm{Q}}^{\\text{num}} + \\mathbf{F}_{\\mathrm{M}}^{\\text{num}} \\right\\|_{\\infty} = \\max_{i \\in \\{1,2,3\\}} \\left| F_{\\mathrm{Q},i}^{\\text{num}} + F_{\\mathrm{M},i}^{\\text{num}} \\right| \\le \\tau\n    $$\nFor a potential $E(\\mathbf{r}_{\\mathrm{Q}}, \\mathbf{r}_{\\mathrm{M}}) = E(\\mathbf{r}_{\\mathrm{Q}} - \\mathbf{r}_{\\mathrm{M}})$, the central difference approximation yields $F_{\\mathrm{Q},i}^{\\text{num}} + F_{\\mathrm{M},i}^{\\text{num}} = 0$ in exact arithmetic. Any non-zero result is due to floating-point representation errors.\n\nThe implementation will follow these derived formulas and verification procedures for each test case provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the QM/MM mechanical embedding force calculation problem\n    for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"r_Q\": np.array([0.8, -0.2, 0.3]),\n            \"r_M\": np.array([-0.4, 0.5, 0.1]),\n            \"u\": np.array([1.0, 1.0, 0.5]),\n            \"r0\": 1.1,\n            \"k_par\": 120.0,\n            \"k_perp\": 80.0,\n        },\n        {\n            \"r_Q\": np.array([1.0, 0.0, 0.0]),\n            \"r_M\": np.array([0.0, 1.0, 0.0]),\n            \"u\": np.array([1.0, 0.0, 0.0]),\n            \"r0\": 1.0,\n            \"k_par\": 50.0,\n            \"k_perp\": 0.0,\n        },\n        {\n            \"r_Q\": np.array([0.0, 0.0, 0.0]),\n            \"r_M\": np.array([0.0, 0.0, 0.0]),\n            \"u\": np.array([0.0, 0.0, 1.0]),\n            \"r0\": 0.3,\n            \"k_par\": 30.0,\n            \"k_perp\": 10.0,\n        },\n    ]\n\n    h = 1e-6\n    tau = 1e-8\n    results = []\n\n    def coupling_energy(r_Q, r_M, u_norm, r0, k_par, k_perp):\n        \"\"\"Calculates the mechanical coupling energy E_couple.\"\"\"\n        delta_r = r_Q - r_M\n        \n        # Axial term\n        # E_par = (k_par / 2) * ( (delta_r . u) - r0 )^2\n        axial_proj = np.dot(delta_r, u_norm)\n        energy_par = 0.5 * k_par * (axial_proj - r0)**2\n        \n        # Transverse term\n        # E_perp = (k_perp / 2) * || P_perp * delta_r ||^2\n        # P_perp * delta_r = delta_r - u * (u . delta_r)\n        perp_proj_vec = delta_r - u_norm * axial_proj\n        energy_perp = 0.5 * k_perp * np.dot(perp_proj_vec, perp_proj_vec)\n        \n        return energy_par + energy_perp\n\n    for case in test_cases:\n        r_Q, r_M, u, r0, k_par, k_perp = (\n            case[\"r_Q\"], case[\"r_M\"], case[\"u\"], case[\"r0\"], case[\"k_par\"], case[\"k_perp\"]\n        )\n\n        u_norm = u / np.linalg.norm(u)\n        \n        # --- 1. Analytic Forces ---\n        delta_r = r_Q - r_M\n        axial_proj = np.dot(delta_r, u_norm)\n        perp_proj_vec = delta_r - u_norm * axial_proj\n        \n        # Gradient with respect to delta_r\n        grad_delta_r = (k_par * (axial_proj - r0) * u_norm) + (k_perp * perp_proj_vec)\n        \n        F_Q_an = -grad_delta_r\n        F_M_an = grad_delta_r\n        \n        # --- 2. Numerical Forces ---\n        F_Q_num = np.zeros(3)\n        F_M_num = np.zeros(3)\n        \n        for i in range(3):\n            e_i = np.zeros(3)\n            e_i[i] = 1.0\n            \n            # Perturb r_Q\n            r_Q_plus = r_Q + h * e_i\n            r_Q_minus = r_Q - h * e_i\n            E_plus_Q = coupling_energy(r_Q_plus, r_M, u_norm, r0, k_par, k_perp)\n            E_minus_Q = coupling_energy(r_Q_minus, r_M, u_norm, r0, k_par, k_perp)\n            F_Q_num[i] = -(E_plus_Q - E_minus_Q) / (2 * h)\n            \n            # Perturb r_M\n            r_M_plus = r_M + h * e_i\n            r_M_minus = r_M - h * e_i\n            E_plus_M = coupling_energy(r_Q, r_M_plus, u_norm, r0, k_par, k_perp)\n            E_minus_M = coupling_energy(r_Q, r_M_minus, u_norm, r0, k_par, k_perp)\n            F_M_num[i] = -(E_plus_M - E_minus_M) / (2 * h)\n            \n        # --- 3. Verification ---\n        # Discrepancy between analytic and numerical forces\n        diff_Q = np.abs(F_Q_an - F_Q_num)\n        diff_M = np.abs(F_M_an - F_M_num)\n        max_discrepancy = np.max(np.concatenate((diff_Q, diff_M)))\n        \n        # Check Newton's Third Law for numerical forces\n        force_sum = F_Q_num + F_M_num\n        norm_inf_sum = np.max(np.abs(force_sum))\n        newton_check = norm_inf_sum <= tau\n        \n        results.append(max_discrepancy)\n        results.append(newton_check)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "When the QM/MM partition cuts across a covalent bond, a \"link atom\" is typically introduced to saturate the valence of the QM boundary atom, preventing unrealistic electronic structures. The placement of this link atom is a delicate balancing act; it must satisfy the geometric preferences of the QM fragment while respecting the mechanical constraint imposed by the connection to the MM region. This exercise explores this compromise by using a simplified energy model to find the optimal position of a hydrogen link atom. Solving this constrained optimization problem provides direct insight into the energy cost and structural consequences of creating a covalent bond boundary in a QM/MM simulation.",
            "id": "3823953",
            "problem": "A mechanically embedded Quantum Mechanics/Molecular Mechanics (QM/MM) boundary cut is made through a carbon–carbon (C–C) bond between a boundary carbon in the quantum mechanics region and a molecular mechanics carbon in the molecular mechanics region. To preserve valence in the quantum mechanics region, a hydrogen link atom is added on the quantum mechanics side. The mechanical embedding couples the geometry of the quantum mechanics region to the molecular mechanics region only through geometric constraints, without modifying the quantum Hamiltonian by external charges.\n\nAssume the following simplified, physically consistent model of the quantum mechanics energy for the boundary fragment. Let the boundary carbon be at the origin, and let the unit vector $u$ point from the boundary carbon toward the nearest internal carbon in the quantum mechanics region. Let the unit vector $v$ point from the boundary carbon toward the original molecular mechanics carbon that was cut. The hydrogen link atom is placed at a fixed carbon–hydrogen bond length $r_{\\mathrm{CH}}$ along a unit direction $x$ that must satisfy the spherical constraint $\\lVert x \\rVert = 1$, so the link atom position is $r_{\\mathrm{CH}} x$ relative to the boundary carbon. The carbon–hydrogen bond length is constrained to $r_{\\mathrm{CH}} = 1.09$ Å, which implies a zero bond-stretch contribution to the energy.\n\nDefine the mechanically embedded quantum mechanics energy of the boundary fragment as a sum of harmonic angular penalties governed by Hooke’s law for rotations. In radians, let $\\theta(x) = \\arccos(u \\cdot x)$ be the bond angle between the internal quantum mechanics direction and the link atom direction, and let $\\phi(x) = \\arccos(v \\cdot x)$ be the angle between the original molecular mechanics boundary direction and the link atom direction. The target valence angle is $\\theta_0$ (in radians). The energy for a given direction $x$ is\n$$\nE(x) = \\tfrac{1}{2} k_a \\left(\\theta(x) - \\theta_0\\right)^2 + \\tfrac{1}{2} k_d \\left(\\phi(x)\\right)^2,\n$$\nwhere $k_a$ is the angle force constant that penalizes deviation of the carbon–hydrogen bond angle from the target valence angle $\\theta_0$, and $k_d$ is a directional coupling constant that penalizes deviation of the hydrogen link direction from the original carbon–carbon bond axis pointing into the molecular mechanics region. Both $k_a$ and $k_d$ are in units of $\\mathrm{kJ\\,mol^{-1}\\,rad^{-2}}$, and angles are in radians. The constraint is $\\lVert x \\rVert = 1$.\n\nThe shift in the quantum mechanics energy due to the link atom placement is defined as\n$$\n\\Delta E = E_{\\min} - E_{\\mathrm{ref}},\n$$\nwhere $E_{\\min}$ is the minimum of $E(x)$ over all unit directions $x$, and $E_{\\mathrm{ref}}$ is the reference minimum energy in the absence of directional coupling to the molecular mechanics region (that is, with $k_d = 0$). In this model, $E_{\\mathrm{ref}} = 0$ because the angular target $\\theta(x) = \\theta_0$ can be achieved by an appropriate $x$ on the unit sphere.\n\nStarting from the mechanical embedding and classical harmonic angle model, derive an algorithm to compute $\\Delta E$ via constrained geometry optimization of $x$ on the unit sphere. Your program must implement this computation and produce numerical results for the following test suite. All vector inputs are given in ångström coordinates relative to the boundary carbon at the origin, and must be normalized to unit vectors to obtain $u$ and $v$. All energies must be expressed in $\\mathrm{kJ/mol}$. Angles must be interpreted and computed in radians.\n\nTest suite (each case is a tuple $(C_{\\mathrm{int}}, C_{\\mathrm{MM}}, k_a, k_d, \\theta_0)$):\n- Case 1 (general compromise): $C_{\\mathrm{int}} = (0, 0, 1.54)$, $C_{\\mathrm{MM}} = (\\sin(1.0471975512), 0, \\cos(1.0471975512))$, $k_a = 50.0$, $k_d = 20.0$, $\\theta_0 = 1.91113553093$.\n- Case 2 (no directional coupling): $C_{\\mathrm{int}} = (0, 0, 1.54)$, $C_{\\mathrm{MM}} = (\\sin(1.0471975512), 0, \\cos(1.0471975512))$, $k_a = 50.0$, $k_d = 0.0$, $\\theta_0 = 1.91113553093$.\n- Case 3 (strong misalignment): $C_{\\mathrm{int}} = (0, 0, 1.0)$, $C_{\\mathrm{MM}} = (0, 0, -1.0)$, $k_a = 50.0$, $k_d = 200.0$, $\\theta_0 = 1.91113553093$.\n- Case 4 (perfect sp2 alignment): $C_{\\mathrm{int}} = (0, 0, 1.54)$, $C_{\\mathrm{MM}} = (\\sin(2.09439510239), 0, \\cos(2.09439510239))$, $k_a = 100.0$, $k_d = 100.0$, $\\theta_0 = 2.09439510239$.\n\nYour program must:\n- Normalize $C_{\\mathrm{int}}$ and $C_{\\mathrm{MM}}$ to unit vectors $u$ and $v$.\n- Compute the inter-direction angle $\\psi = \\arccos(u \\cdot v)$ in radians.\n- Perform the constrained geometry optimization of $x$ on the unit sphere to find $E_{\\min}$ and hence $\\Delta E$ in $\\mathrm{kJ/mol}$.\n- Round each $\\Delta E$ to six decimal places.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is a float rounded to six decimal places in units of $\\mathrm{kJ/mol}$.",
            "solution": "The problem is first validated to be scientifically grounded, well-posed, and objective. It presents a simplified but physically consistent model for a Quantum Mechanics/Molecular Mechanics (QM/MM) boundary treatment using a link atom. All parameters are clearly defined, and the goal is a formalizable minimization problem. The problem is valid.\n\nThe objective is to compute the energy shift $\\Delta E = E_{\\min} - E_{\\mathrm{ref}}$, where $E_{\\min}$ is the minimum of the energy function\n$$\nE(x) = \\tfrac{1}{2} k_a \\left(\\theta(x) - \\theta_0\\right)^2 + \\tfrac{1}{2} k_d \\left(\\phi(x)\\right)^2\n$$\nsubject to the constraint that $x$ is a unit vector, $\\lVert x \\rVert_2 = 1$. The angles are defined as $\\theta(x) = \\arccos(u \\cdot x)$ and $\\phi(x) = \\arccos(v \\cdot x)$, where $u$ and $v$ are fixed unit vectors. The reference energy $E_{\\mathrm{ref}}$ is the minimum energy for the case $k_d = 0$, which is given as $E_{\\mathrm{ref}} = 0$. Therefore, the problem reduces to finding $E_{\\min}$.\n\nThis is a constrained optimization problem. We can solve it by finding the stationary points of the Lagrangian $\\mathcal{L}(x, \\lambda) = E(x) - \\lambda(\\lVert x \\rVert_2^2 - 1)$. At an extremum, the gradient of the Lagrangian with respect to $x$ must be zero: $\\nabla_x \\mathcal{L} = \\nabla_x E(x) - 2\\lambda x = 0$. This implies that at the minimum, the gradient of the energy function, $\\nabla_x E(x)$, must be collinear with the position vector $x$.\n\nLet's compute the gradient of $E(x)$. Using the chain rule and the derivative $\\frac{d}{dc}\\arccos(c) = -1/\\sqrt{1-c^2}$:\n$$\n\\nabla_x E(x) = k_a(\\theta(x) - \\theta_0) \\left(\\frac{-1}{\\sqrt{1 - (u \\cdot x)^2}}\\right) \\nabla_x(u \\cdot x) + k_d(\\phi(x)) \\left(\\frac{-1}{\\sqrt{1 - (v \\cdot x)^2}}\\right) \\nabla_x(v \\cdot x)\n$$\nSince $\\nabla_x(u \\cdot x) = u$ and $\\nabla_x(v \\cdot x) = v$, the gradient is:\n$$\n\\nabla_x E(x) = -k_a \\frac{\\theta(x) - \\theta_0}{\\sin(\\theta(x))} u - k_d \\frac{\\phi(x)}{\\sin(\\phi(x))} v\n$$\nThe gradient $\\nabla_x E(x)$ is a linear combination of the vectors $u$ and $v$. The condition $\\nabla_x E(x) = 2\\lambda x$ thus implies that the optimal vector $x$ must also be a linear combination of $u$ and $v$. This proves that the optimal direction $x$ lies in the plane spanned by the vectors $u$ and $v$.\n\nThis geometric insight simplifies the problem immensely. We can parameterize any unit vector $x$ in the $u,v$-plane by a single angle, $\\alpha$, representing the angle between $x$ and $u$. Let us define a coordinate system such that $u$ is along the $z$-axis and $v$ lies in the $xz$-plane. Let $\\psi = \\arccos(u \\cdot v)$ be the angle between $u$ and $v$. In this frame, $x$ can be written as $x = (\\sin\\alpha, 0, \\cos\\alpha)$, where $\\alpha \\in [0, \\pi]$.\n\nThe dot products become:\n$u \\cdot x = \\cos\\alpha \\implies \\theta(x) = \\alpha$.\n$v \\cdot x = \\cos(\\alpha - \\psi)$ (or $\\cos(\\psi-\\alpha)$, it does not matter) $\\implies \\phi(x) = |\\alpha - \\psi|$.\n\nThe energy function is now a function of a single variable $\\alpha$:\n$$\nE(\\alpha) = \\tfrac{1}{2} k_a (\\alpha - \\theta_0)^2 + \\tfrac{1_2}{2} k_d (|\\alpha - \\psi|)^2\n$$\nSince the second term is squared, the absolute value is redundant, i.e., $(|\\alpha - \\psi|)^2 = (\\alpha - \\psi)^2$. The function to minimize is a simple quadratic in $\\alpha$:\n$$\nE(\\alpha) = \\tfrac{1}{2} k_a (\\alpha - \\theta_0)^2 + \\tfrac{1}{2} k_d (\\alpha - \\psi)^2\n$$\nTo find the minimum, we set the derivative with respect to $\\alpha$ to zero:\n$$\n\\frac{dE}{d\\alpha} = k_a(\\alpha - \\theta_0) + k_d(\\alpha - \\psi) = 0\n$$\nSolving for $\\alpha$:\n$$\n(k_a + k_d) \\alpha = k_a \\theta_0 + k_d \\psi\n$$\nThe optimal angle $\\alpha^*$ is the weighted average of $\\theta_0$ and $\\psi$:\n$$\n\\alpha^* = \\frac{k_a \\theta_0 + k_d \\psi}{k_a + k_d}\n$$\nSince $\\theta_0 \\in (0, \\pi)$ and $\\psi \\in [0, \\pi]$, and the weights are non-negative, $\\alpha^*$ is guaranteed to be in the valid range $[0, \\pi]$. Substituting $\\alpha^*$ back into the energy function gives the minimum energy $E_{\\min}$.\nThe terms in the energy expression become:\n$\\alpha^* - \\theta_0 = \\frac{k_a \\theta_0 + k_d \\psi - (k_a+k_d)\\theta_0}{k_a + k_d} = \\frac{k_d(\\psi - \\theta_0)}{k_a + k_d}$\n$\\alpha^* - \\psi = \\frac{k_a \\theta_0 + k_d \\psi - (k_a+k_d)\\psi}{k_a + k_d} = \\frac{k_a(\\theta_0 - \\psi)}{k_a + k_d}$\n\nSubstituting these into $E(\\alpha^*)$:\n$$\nE_{\\min} = \\tfrac{1}{2} k_a \\left(\\frac{k_d(\\psi - \\theta_0)}{k_a + k_d}\\right)^2 + \\tfrac{1}{2} k_d \\left(\\frac{k_a(\\theta_0 - \\psi)}{k_a + k_d}\\right)^2\n$$\n$$\nE_{\\min} = \\frac{(\\theta_0 - \\psi)^2}{2(k_a + k_d)^2} \\left[ k_a k_d^2 + k_d k_a^2 \\right] = \\frac{(\\theta_0 - \\psi)^2}{2(k_a + k_d)^2} \\left[ k_a k_d (k_a + k_d) \\right]\n$$\nThis simplifies to a final closed-form expression for the minimum energy:\n$$\nE_{\\min} = \\frac{1}{2} \\frac{k_a k_d}{k_a + k_d} (\\theta_0 - \\psi)^2\n$$\nSince $\\Delta E = E_{\\min} - E_{\\mathrm{ref}}$ and $E_{\\mathrm{ref}} = 0$, we have $\\Delta E = E_{\\min}$. This formula is valid for $k_a+k_d > 0$. If $k_d=0$, the formula correctly yields $E_{\\min}=0$.\n\nThe algorithm is as follows:\n1. For each test case, take the input vectors $C_{\\mathrm{int}}$ and $C_{\\mathrm{MM}}$ and normalize them to obtain unit vectors $u$ and $v$.\n2. Calculate the dot product $u \\cdot v$. To prevent numerical errors, clamp this value to the range $[-1.0, 1.0]$.\n3. Compute the angle $\\psi = \\arccos(u \\cdot v)$.\n4. Use the derived formula to calculate $\\Delta E = \\frac{1}{2} \\frac{k_a k_d}{k_a + k_d} (\\theta_0 - \\psi)^2$.\n5. Round the result to $6$ decimal places.\n\nThis analytical solution constitutes the most efficient algorithm for the constrained geometry optimization requested.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the QM/MM link atom energy problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (general compromise)\n        (\n            (0, 0, 1.54),\n            (np.sin(1.0471975512), 0, np.cos(1.0471975512)),\n            50.0, 20.0, 1.91113553093\n        ),\n        # Case 2 (no directional coupling)\n        (\n            (0, 0, 1.54),\n            (np.sin(1.0471975512), 0, np.cos(1.0471975512)),\n            50.0, 0.0, 1.91113553093\n        ),\n        # Case 3 (strong misalignment)\n        (\n            (0, 0, 1.0),\n            (0, 0, -1.0),\n            50.0, 200.0, 1.91113553093\n        ),\n        # Case 4 (perfect sp2 alignment)\n        (\n            (0, 0, 1.54),\n            (np.sin(2.09439510239), 0, np.cos(2.09439510239)),\n            100.0, 100.0, 2.09439510239\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        C_int_tuple, C_MM_tuple, k_a, k_d, theta_0 = case\n        \n        # Convert tuples to numpy arrays\n        C_int = np.array(C_int_tuple, dtype=float)\n        C_MM = np.array(C_MM_tuple, dtype=float)\n\n        # Step 1: Normalize C_int and C_MM to unit vectors u and v.\n        norm_C_int = np.linalg.norm(C_int)\n        if norm_C_int == 0:\n            # Handle the unlikely case of a zero vector\n            u = np.zeros(3)\n        else:\n            u = C_int / norm_C_int\n\n        norm_C_MM = np.linalg.norm(C_MM)\n        if norm_C_MM == 0:\n            v = np.zeros(3)\n        else:\n            v = C_MM / norm_C_MM\n            \n        # Step 2: Compute the inter-direction angle psi = arccos(u . v).\n        dot_uv = np.dot(u, v)\n        # Clip to handle potential floating point inaccuracies\n        dot_uv = np.clip(dot_uv, -1.0, 1.0)\n        psi = np.arccos(dot_uv)\n\n        # Step 3: Compute E_min (which is Delta E) using the derived formula.\n        # Delta_E = 0.5 * (k_a * k_d) / (k_a + k_d) * (theta_0 - psi)^2\n        # This formula holds even if k_d is 0.\n        # If k_a + k_d is 0 (i.e., both are 0), the result is 0.\n        denominator = k_a + k_d\n        if denominator == 0.0:\n            delta_E = 0.0\n        else:\n            effective_k = (k_a * k_d) / denominator\n            delta_E = 0.5 * effective_k * (theta_0 - psi)**2\n            \n        results.append(delta_E)\n\n    # Format the output as a comma-separated list of floats rounded to 6 decimal places,\n    # enclosed in square brackets.\n    output_str = \"[\" + \",\".join(f\"{res:.6f}\" for res in results) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}