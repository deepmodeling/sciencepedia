{
    "hands_on_practices": [
        {
            "introduction": "虽然含时密度泛函理论（TD-DFT）是计算电子激发态的有力工具，但其标准近似形式存在一些众所周知且严重的系统性缺陷。本练习将通过一个简化的、但物理意义明确的模型，揭示其中最著名的一个局限：对长程电荷转移（CT）激发的灾难性错误描述。理解这一问题对于正确解读和评估TD-DFT计算结果至关重要，并为理解为何需要发展远程校正泛函等更高级方法奠定了基础。",
            "id": "2466214",
            "problem": "你需要编写一个完整、可运行的程序，在一个最小但有科学依据的模型中，演示含时密度泛函理论（TD-DFT）如何在使用标准广义梯度近似（GGA）泛函时，错误地预测一个空间分离的给体-受体对中存在虚假的低能荷转移激发。你的程序必须从第一性原理出发，实现以下逻辑。\n\n从密度泛函理论（DFT）中电离势和电子亲和能的基本定义，以及分离电荷间的静电相互作用出发。利用这些原理，推导出大间距下最低的给体-受体荷转移激发能的表达式。然后，使用线性响应TD-DFT以及一个事实，即对于空间上不重叠的轨道，绝热半局域哈特里-交换-关联核产生的耦合可以忽略不计，推导出半局域GGA泛函所作出的相应预测。最后，通过引入导数不连续性，将Kohn–Sham轨道能量差与基本带隙联系起来。在推导过程中，不要使用或引用任何已有的简化公式；相反，仅从以下基本依据进行推理：\n- 基本定义：通过总能量差定义的电离势$I$和电子亲和能$A$，以及两个相距为$R$的单位电荷之间的静电相互作用能。\n- 线性响应理论核心思想：激发能来自一个由非相互作用跃迁能和耦合项决定的响应极点，并且对于轨道重叠可忽略的空间分离片段间的荷转移，局域和绝热的核函数提供的长程耦合可忽略不计。\n- 一个经过充分检验的概念性事实：多体基本带隙通过导数不连续性与Kohn–Sham带隙相关联。\n\n为每个测试用例实现一个包含以下参数的最小双片段模型：\n- 给体电离势$I_D$（单位为Hartree）。\n- 受体电子亲和能$A_A$（单位为Hartree）。\n- 中心间距$R$（单位为bohr）。\n- 一个有效的正导数不连续性参数$\\Delta_{\\mathrm{xc}}$（单位为Hartree），该参数捕捉了半局域GGA泛函所特有的带隙低估特征。\n\n对于每个测试用例，计算：\n1. 基于上述原理的、物理上合理的的大间距荷转移激发能，以Hartree为单位，此处记为$E_{\\mathrm{true}}$。\n2. 绝热半局域GGA TD-DFT对相同荷转移激发的预测值，以Hartree为单位，此处记为$E_{\\mathrm{GGA}}$。\n3. 符号误差$\\Delta E = E_{\\mathrm{GGA}} - E_{\\mathrm{true}}$（单位为Hartree）。\n4. 一个布尔标志，当且仅当GGA的预测值虚假地低时（由严格不等式$E_{\\mathrm{GGA}}  E_{\\mathrm{true}}$定义）为真。\n\n你的程序必须使用以下固定的参数元组$(I_D,A_A,R,\\Delta_{\\mathrm{xc}})$测试套件，单位为原子单位（能量为Hartree，距离为bohr）：\n- 测试1（普通分离对）：$(0.30, 0.08, 30.0, 0.12)$。\n- 测试2（极大间距）：$(0.30, 0.08, 200.0, 0.12)$。\n- 测试3（导致GGA激发能接近零的小基本带隙）：$(0.20, 0.08, 25.0, 0.12)$。\n- 测试4（在该$R$处，低估值等于缺失的静电相互作用的数值平衡点）：$(0.25, 0.05, 8.\\overline{3}, 0.12)$，其中$8.\\overline{3}$表示$25/3$ bohr。\n\n所有能量必须以Hartree表示并四舍五入到六位小数。对于每个测试用例，你的程序必须按顺序输出$E_{\\mathrm{true}}$、$E_{\\mathrm{GGA}}$、$\\Delta E$和布尔标志这四个值。将所有测试用例的结果汇总到一个扁平列表中。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,...]”）。\n\n不涉及角度单位。不允许外部输入；程序必须完全自包含，并在执行时产生所需的单行输出。",
            "solution": "该问题陈述具有科学依据、提法明确，并包含了推导出唯一解所需的所有信息。它描述了常见密度泛函近似的一种众所周知的失效模式。因此，该问题被认为是有效的，并将基于所提供的第一性原理构建解决方案。\n\n我们首先推导物理上正确的、大间距下的荷转移（$CT$）激发能的表达式，记为$E_{\\mathrm{true}}$。一个$CT$激发过程涉及将一个电子从给体分子$D$移动到相距为$R$的受体分子$A$。这个过程可以表示为$D^0A^0 \\rightarrow D^+A^-$。此激发的能量$\\omega_{CT}$是最终态和初始态总能量之差：\n$$ \\omega_{CT} = E(D^+A^-) - E(D^0A^0) $$\n在$R$很大的极限下，组合体系的能量可以近似为其非相互作用的组成片段的能量之和，再加上它们的经典静电相互作用能。对于初始的中性态，能量为：\n$$ E(D^0A^0) \\approx E(D^0) + E(A^0) $$\n对于最终的离子态，能量包括新形成的离子之间的静电吸引力：\n$$ E(D^+A^-) \\approx E(D^+) + E(A^-) + E_{\\mathrm{int}} $$\n这里，$E(X)$表示物种$X$的总能量。根据库仑定律，位于$D^+$上的$+1e$点电荷和位于$A^-$上的$-1e$点电荷之间的相互作用能$E_{\\mathrm{int}}$为。在原子单位制中，能量单位为Hartree，距离单位为bohr，该能量为：\n$$ E_{\\mathrm{int}} = -\\frac{1}{R} $$\n将这些表达式代入$\\omega_{CT}$的方程中，我们得到：\n$$ \\omega_{CT} \\approx \\left( E(D^+) + E(A^-) - \\frac{1}{R} \\right) - \\left( E(D^0) + E(A^0) \\right) $$\n按物种重新整理各项，得到：\n$$ \\omega_{CT} \\approx \\left( E(D^+) - E(D^0) \\right) + \\left( E(A^-) - E(A^0) \\right) - \\frac{1}{R} $$\n括号中的项对应于基本定义。给体的电离势$I_D$是移除一个电子所需的能量：\n$$ I_D = E(D^+) - E(D^0) $$\n受体的电子亲和能$A_A$是捕获一个电子所释放的能量，定义为：\n$$ A_A = E(A^0) - E(A^-) $$\n根据这个定义，可以得出$E(A^-) - E(A^0) = -A_A$。将$I_D$和$A_A$的这些定义代入，我们便得到了真实的大间距荷转移激发能的表达式：\n$$ E_{\\mathrm{true}} = I_D - A_A - \\frac{1}{R} $$\n\n接下来，我们推导绝热半局域含时密度泛函理论（$TD-DFT$）的相应预测值，记为$E_{\\mathrm{GGA}}$。在线性响应$TD-DFT$中，激发能$\\omega$是作为矩阵方程的本征值获得的。对于从一个占据的Kohn-Sham（$KS$）轨道$\\phi_i$到虚拟$KS$轨道$\\phi_a$的单次激发，在绝热近似下，激发能由下式给出：\n$$ \\omega_{ia} = \\varepsilon_a - \\varepsilon_i + K_{ia,ia} $$\n其中$\\varepsilon_i$和$\\varepsilon_a$是$KS$轨道的能量，$K_{ia,ia}$是耦合矩阵元。该矩阵元依赖于哈特里-交换-关联（$HXC$）核$f_{HXC}$：\n$$ K_{ia,ia} = \\iint \\phi_i^*(\\mathbf{r})\\phi_a(\\mathbf{r}) f_{HXC}(\\mathbf{r}, \\mathbf{r}') \\phi_a^*(\\mathbf{r}')\\phi_i(\\mathbf{r}') d\\mathbf{r} d\\mathbf{r}' $$\n对于我们所考虑的$CT$激发，占据轨道$\\phi_i$是给体的最高占据分子轨道（$HOMO_D$），虚拟轨道$\\phi_a$是受体的最低未占分子轨道（$LUMO_A$）。在大间距$R$下，这些轨道在空间上是孤立的，它们的重叠乘积$\\phi_i(\\mathbf{r})\\phi_a(\\mathbf{r})$对于所有$\\mathbf{r}$都可忽略不计。\n对于像广义梯度近似（$GGA$）这样的半局域泛函，其核$f_{HXC}^{GGA}(\\mathbf{r}, \\mathbf{r}')$实际上是局域的，意味着它随着距离$|\\mathbf{r} - \\mathbf{r}'|$的增加而迅速衰减为零。局域核与可忽略的轨道重叠相结合，导致耦合积分$K_{ia,ia}$变为零：\n$$ K_{ia,ia}^{GGA} \\approx 0 $$\n因此，$TD-GGA$激发能虚假地简化为所涉及的$KS$轨道能量的简单差值：\n$$ E_{\\mathrm{GGA}} = \\omega_{CT}^{GGA} \\approx \\varepsilon_{LUMO,A} - \\varepsilon_{HOMO,D} $$\n为了使这个表达式有用，我们必须将这个$KS$轨道能量差与物理量$I_D$和$A_A$联系起来。组合的$D-A$体系的多体基本带隙是$E_{gap} = I_D - A_A$。相应的$KS$带隙是$\\varepsilon_{gap}^{KS} = \\varepsilon_{LUMO,A} - \\varepsilon_{HOMO,D}$。对于精确的泛函，这些量通过交换关联势的导数不连续性$\\Delta_{xc}$相关联：\n$$ E_{gap} = \\varepsilon_{gap}^{KS} + \\Delta_{xc} \\implies I_D - A_A = (\\varepsilon_{LUMO,A} - \\varepsilon_{HOMO,D}) + \\Delta_{xc} $$\n像$GGA$这样的近似泛函存在一个系统性误差，这个误差实际上相当于一个缺失的导数不连续性。问题提供了一个有效的参数$\\Delta_{\\mathrm{xc}}  0$来模拟这种缺陷。在$GGA$框架下，对$KS$带隙的方程进行重新排列，得到：\n$$ \\varepsilon_{LUMO,A}^{GGA} - \\varepsilon_{HOMO,D}^{GGA} = (I_D - A_A) - \\Delta_{\\mathrm{xc}} $$\n这为$TD-GGA$荷转移激发能提供了最终表达式：\n$$ E_{\\mathrm{GGA}} = I_D - A_A - \\Delta_{\\mathrm{xc}} $$\n这个结果错误地显示激发能在大$R$时趋于一个常数值，完全忽略了正确的$-1/R$渐近行为。\n\n最后，我们计算符号误差$\\Delta E$并建立虚假低预测的条件。误差是$GGA$值与真实值之差：\n$$ \\Delta E = E_{\\mathrm{GGA}} - E_{\\mathrm{true}} = (I_D - A_A - \\Delta_{\\mathrm{xc}}) - \\left(I_D - A_A - \\frac{1}{R}\\right) $$\n$$ \\Delta E = \\frac{1}{R} - \\Delta_{\\mathrm{xc}} $$\n$GGA$的预测是虚假地低，当且仅当$E_{\\mathrm{GGA}}  E_{\\mathrm{true}}$，这意味着$\\Delta E  0$。这给出了条件：\n$$ \\frac{1}{R} - \\Delta_{\\mathrm{xc}}  0 \\implies \\frac{1}{R}  \\Delta_{\\mathrm{xc}} $$\n随着间距$R$的增加，$1/R$减小。对于任何具有非零带隙低估误差（$\\Delta_{\\mathrm{xc}}  0$）的体系，都存在一个间距，超过该间距后此不等式成立，这证明了绝热半局域泛函在描述长程荷转移方面的根本性失败。以下程序实现了这些推导出的公式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the true and TD-GGA charge-transfer excitation energies for a\n    series of donor-acceptor pairs to demonstrate the failure of semilocal DFT.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple is (I_D, A_A, R, delta_xc) in atomic units.\n    test_cases = [\n        # Test 1: General separated pair\n        (0.30, 0.08, 30.0, 0.12),\n        # Test 2: Very large separation\n        (0.30, 0.08, 200.0, 0.12),\n        # Test 3: Small fundamental gap\n        (0.20, 0.08, 25.0, 0.12),\n        # Test 4: Numerical balance point\n        (0.25, 0.05, 25.0/3.0, 0.12),\n    ]\n\n    results = []\n    for case in test_cases:\n        I_D, A_A, R, delta_xc = case\n        \n        # 1. Calculate the physically motivated charge-transfer energy, E_true.\n        # This is derived from E_true = I_D - A_A - 1/R.\n        E_true = I_D - A_A - 1.0/R\n        \n        # 2. Calculate the adiabatic semilocal GGA TD-DFT prediction, E_GGA.\n        # This is derived from E_GGA = I_D - A_A - delta_xc.\n        E_gga = I_D - A_A - delta_xc\n        \n        # 3. Calculate the signed error, delta_E.\n        # This is delta_E = E_GGA - E_true, which simplifies to 1/R - delta_xc.\n        delta_E = 1.0/R - delta_xc\n\n        # 4. Determine if the GGA prediction is spuriously low.\n        # This is true if E_GGA  E_true.\n        is_spurious = E_gga  E_true\n\n        # Append the four required results for this test case.\n        # Energies are rounded to six decimal places.\n        results.append(np.round(E_true, 6))\n        results.append(np.round(E_gga, 6))\n        results.append(np.round(delta_E, 6))\n        results.append(is_spurious)\n        \n    # Final print statement in the exact required format.\n    # The boolean `True`/`False` is converted to string \"True\"/\"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了标准TD-DFT的理论局限后，我们将深入其实际执行的核心——求解含时Kohn-Sham（TDKS）方程。本练习将指导您从第一性原理出发，构建一个单步时间传播子，这是任何实时TD-DFT模拟的基础。通过实现并比较两种经典的二阶精度积分方案（Crank-Nicolson和Magnus方法），您将对数值求解TDKS方程的细节和挑战获得具体而深入的理解。",
            "id": "2932905",
            "problem": "要求你从第一性原理出发，实现含时密度泛函理论 (TDDFT) 中 Kohn–Sham 轨道的一步实时演化。该演化使用哈密顿量的二阶中点评估，并采用两种不同的传播子：Crank–Nicolson 格式和二阶 Magnus 指数。完全在原子单位下进行计算，因此电子质量、基本电荷、约化普朗克常数和库仑常数均等于 $1$。从含时 Kohn–Sham 方程出发\n$$\n\\mathrm{i}\\,\\frac{\\partial}{\\partial t}\\,\\phi_j(x,t)\\;=\\;\\hat{H}_{\\mathrm{s}}[n(\\cdot,t)]\\,\\phi_j(x,t),\n$$\n其中 Slater 行列式由占据轨道 $\\{\\phi_j\\}_{j=1}^{N_{\\mathrm{occ}}}$ 构建，密度为\n$$\nn(x,t)\\;=\\;\\sum_{j=1}^{N_{\\mathrm{occ}}}\\lvert \\phi_j(x,t)\\rvert^2.\n$$\n在本问题中，Kohn–Sham 哈密顿量模型为\n$$\n\\hat{H}_{\\mathrm{s}}[n]\\;=\\;-\\frac{1}{2}\\frac{d^2}{dx^2}\\;+\\;v_{\\mathrm{ext}}(x)\\;+\\;v_{\\mathrm{xc}}(n(x)),\n$$\n其中 $v_{\\mathrm{ext}}(x)$ 是一个静态谐振子囚禁势，$v_{\\mathrm{xc}}(n)$ 是一个绝热局域密度近似 (ALDA) 交换关联势。为保持模型完全局域和自洽，忽略 Hartree 势并使用以下形式：\n- 谐振子外势\n$$\nv_{\\mathrm{ext}}(x)\\;=\\;\\frac{1}{2}\\,\\omega^2\\,x^2,\n$$\n角频率为 $\\omega$。\n- 局域 ALDA 型交换关联势\n$$\nv_{\\mathrm{xc}}(n)\\;=\\;-\\,\\alpha\\,C\\,n^{1/3},\\quad C=\\left(\\frac{3}{\\pi}\\right)^{1/3},\n$$\n其中 $\\alpha$ 是一个无量纲缩放参数。\n\n将区间 $[-L/2,L/2)$ 上的空间离散化为一个包含 $N$ 个点的均匀周期性网格，格点间距为 $\\Delta x=L/N$，并使用带周期性边界条件的二阶中心有限差分拉普拉斯算子来近似动能算符。时间 $t=0$ 时的初始占据 Kohn–Sham 轨道取为频率为 $\\omega$ 的最低阶谐振子本征函数（在连续谱下），将其截断到网格上，然后在网格上进行正交归一化。当 $N_{\\mathrm{occ}}=1$ 时，取基态\n$$\n\\phi_0(x)\\;=\\;\\left(\\frac{\\omega}{\\pi}\\right)^{1/4}\\exp\\!\\left(-\\frac{\\omega}{2}x^2\\right).\n$$\n当 $N_{\\mathrm{occ}}=2$ 时，取上述 $\\phi_0(x)$ 和第一激发态\n$$\n\\phi_1(x)\\;=\\;\\sqrt{2\\,\\omega}\\,x\\,\\phi_0(x).\n$$\n在 $t=0$ 时施加一个弱脉冲电场，该电场通过所谓的 $\\delta$-踢 来建模，这导致每个轨道被乘以一个相位因子，\n$$\n\\phi_j(x,0^+)\\;=\\;\\exp\\!\\big(-\\mathrm{i}\\,k\\,x\\big)\\,\\phi_j(x,0^-),\n$$\n其中 $k$ 很小以保持在线性响应范围内。然后，对于大小为 $\\Delta t$ 的单个时间步，使用预测-校正策略构建一个中点哈密顿量 $\\hat{H}_{\\mathrm{s}}[n(t+\\Delta t/2)]$：\n- 预测步：使用时间 $t$ 处的哈密顿量将系统从 $t$ 演化到 $t+\\Delta t/2$，以获得预测的中点密度 $n(x,t+\\Delta t/2)$。\n- 校正步：利用 $v_{\\mathrm{xc}}(n(x,t+\\Delta t/2))$ 构建中点哈密顿量，并将其用于最终的 $t\\to t+\\Delta t$ 演化。\n\n使用相同的中点哈密顿量实现以下两种二阶传播子：\n- Crank–Nicolson (CN)：求解\n$$\n\\Big(\\mathbf{I}+\\frac{\\mathrm{i}\\,\\Delta t}{2}\\,\\mathbf{H}_{\\mathrm{mid}}\\Big)\\,\\Phi(t+\\Delta t)\\;=\\;\\Big(\\mathbf{I}-\\frac{\\mathrm{i}\\,\\Delta t}{2}\\,\\mathbf{H}_{\\mathrm{mid}}\\Big)\\,\\Phi(t),\n$$\n其中粗体符号表示在网格上的矩阵表示，$\\Phi$ 是将占据轨道作为列堆叠而成的矩阵。对每一列分别求解。\n- 二阶 Magnus (指数中点)：\n$$\n\\Phi(t+\\Delta t)\\;=\\;\\exp\\!\\big(-\\mathrm{i}\\,\\Delta t\\,\\mathbf{H}_{\\mathrm{mid}}\\big)\\,\\Phi(t).\n$$\n演化后，根据离散内积 $\\langle f,g\\rangle=\\sum_\\ell \\overline{f_\\ell}\\,g_\\ell\\,\\Delta x$ 对占据轨道进行重新正交归一化。从每个演化后的 Slater 行列式计算密度，并报告两种格式之间密度差的加权 $\\mathrm{L}^2$-范数，\n$$\nD\\;=\\;\\Bigg(\\sum_{\\ell=1}^{N}\\big(n_{\\mathrm{CN}}(x_\\ell)-n_{\\mathrm{Mag}}(x_\\ell)\\big)^2\\,\\Delta x\\Bigg)^{1/2}.\n$$\n\n你的程序必须从第一性原理实现上述过程，并为以下测试套件生成结果，每个测试由元组 $(N,L,\\Delta t,\\omega,\\alpha,k,N_{\\mathrm{occ}})$ 指定：\n- 测试 1：$(N,L,\\Delta t,\\omega,\\alpha,k,N_{\\mathrm{occ}})=(\\,128,\\,20,\\,0.05,\\,0.5,\\,0.8,\\,0.001,\\,1\\,)$。\n- 测试 2：$(N,L,\\Delta t,\\omega,\\alpha,k,N_{\\mathrm{occ}})=(\\,128,\\,20,\\,0.005,\\,0.5,\\,0.8,\\,0.001,\\,1\\,)$。\n- 测试 3：$(N,L,\\Delta t,\\omega,\\alpha,k,N_{\\mathrm{occ}})=(\\,128,\\,20,\\,0.10,\\,0.5,\\,0.8,\\,0.001,\\,1\\,)$。\n- 测试 4：$(N,L,\\Delta t,\\omega,\\alpha,k,N_{\\mathrm{occ}})=(\\,128,\\,20,\\,0.05,\\,0.5,\\,0.8,\\,0.0005,\\,2\\,)$。\n\n所有量均采用原子单位。角度和相位以弧度为单位。你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是对应上述测试用例的 $D$ 的浮点值。不应打印任何额外文本。",
            "solution": "该问题要求实现一个一维系统的含时密度泛函理论 (TDDFT) 模拟中的单步时间演化。我们的任务是使用一种针对含时势的预测-校正方法，来比较两种二阶传播格式：Crank-Nicolson 和 Magnus 指数。分析过程如下。\n\n首先，我们必须在空间网格上为该问题建立一个离散表示。连续空间坐标 $x$ 在定义域 $[-L/2, L/2)$ 上被离散为 $N$ 个点 $x_\\ell = -L/2 + \\ell \\Delta x$（$\\ell = 0, 1, \\dots, N-1$），网格间距为 $\\Delta x = L/N$。量子态（轨道）$\\phi(x)$ 由其在这些网格点上的值构成的列向量 $\\boldsymbol{\\phi}$ 表示，即 $\\phi_\\ell = \\phi(x_\\ell)$。两个态 $\\phi$ 和 $\\psi$ 之间的内积通过离散求和来近似：$\\langle\\phi|\\psi\\rangle = \\sum_{\\ell=0}^{N-1} \\overline{\\phi_\\ell} \\psi_\\ell \\Delta x$。\n\nKohn-Sham 哈密顿量 $\\hat{H}_{\\mathrm{s}} = \\hat{T} + \\hat{V}$ 由动能部分 $\\hat{T} = -\\frac{1}{2}\\frac{d^2}{dx^2}$ 和势能部分 $\\hat{V} = v_{\\mathrm{ext}}(x) + v_{\\mathrm{xc}}(n(x))$ 组成。势算符 $\\hat{V}$ 在位置空间中是局域作用的，因此其矩阵表示 $\\mathbf{V}$ 是对角的，矩阵元为 $V_{\\ell\\ell} = v_{\\mathrm{ext}}(x_\\ell) + v_{\\mathrm{xc}}(n(x_\\ell))$。动能算符 $\\hat{T}$ 使用带有周期性边界条件的二阶中心有限差分公式来近似拉普拉斯算子：\n$$\n(\\hat{T} \\phi)_\\ell \\approx -\\frac{1}{2\\Delta x^2} \\big( \\phi_{\\ell+1} - 2\\phi_\\ell + \\phi_{\\ell-1} \\big)\n$$\n其中下标对 $N$ 取模。这将得到一个大小为 $N \\times N$ 的实对称循环矩阵 $\\mathbf{T}$。给定时间的完整哈密顿量则由稠密矩阵 $\\mathbf{H} = \\mathbf{T} + \\mathbf{V}$ 表示。\n\n时间 $t=0^-$ 的初始态由所提供的谐振子本征函数的解析形式构建。对于 $N_{\\mathrm{occ}}$ 个占据轨道，我们通过在网格上计算这些函数的值来形成一个大小为 $N \\times N_{\\mathrm{occ}}$ 的矩阵 $\\Phi_{cont}$。这些连续函数相对于积分是正交归一的，但它们的离散对应物相对于离散内积不一定是正交归一的。因此，我们必须执行一次网格上的正交归一化。这可以通过对矩阵 $\\sqrt{\\Delta x} \\Phi_{cont}$ 应用 Gram-Schmidt 过程（或更稳健的 QR 分解）来实现，其列向量在标准欧几里得意义下是正交归一的。将得到的正交归一矩阵乘以 $1/\\sqrt{\\Delta x}$ 的比例因子，即可得到在网格上正确正交归一化的初始轨道 $\\Phi(0^-)$。\n\n在 $t=0$ 时，施加一个脉冲电场（$\\delta$-踢）。这给电子赋予了一个动量踢 $k$，在位置空间中对应于将每个轨道乘以一个相位因子：\n$$\n\\Phi(x,0^+) = \\exp(-\\mathrm{i}kx) \\Phi(x,0^-)\n$$\n这个操作是幺正的，并保持轨道的正交归一性。所得的状态矩阵 $\\Phi(0) \\equiv \\Phi(0^+)$ 作为时间演化的初始条件。\n\n问题的核心在于从 $t=0$ 到 $t=\\Delta t$ 的单步演化。哈密顿量通过 $v_{\\mathrm{xc}}(n(x,t))$ 项依赖于密度，因此是含时的。为了在时间步长 $\\Delta t$ 上保持二阶精度，采用了一种预测-校正格式来近似区间中点的哈密顿量 $\\mathbf{H}_{\\mathrm{mid}} \\approx \\mathbf{H}(t+\\Delta t/2)$。\n\n预测步：我们首先估计中点处的轨道 $\\Phi_{pred}(\\Delta t/2)$。这是通过使用初始时刻的哈密顿量 $\\mathbf{H}_0 = \\mathbf{H}[n(0)]$，将初始态 $\\Phi(0)$ 演化半个时间步长 $\\Delta t/2$ 来完成的。我们使用一个幺正指数传播子进行此预测：\n$$\n\\Phi_{pred}(\\Delta t/2) = \\exp(-\\mathrm{i} \\frac{\\Delta t}{2} \\mathbf{H}_0) \\Phi(0)\n$$\n从这些预测的轨道，我们计算出预测的中点密度 $n_{pred}(\\Delta t/2) = \\sum_j |\\phi_{j,pred}(\\Delta t/2)|^2$。\n\n校正步：使用这个预测的密度，我们构建中点交换关联势 $v_{\\mathrm{xc,mid}} = v_{\\mathrm{xc}}(n_{pred}(\\Delta t/2))$ 以及相应的中点哈密顿量 $\\mathbf{H}_{\\mathrm{mid}} = \\mathbf{T} + \\mathbf{V}_{\\mathrm{ext}} + \\mathrm{diag}(v_{\\mathrm{xc,mid}})$。现在，这个哈密顿量在整个时间步 $[0, \\Delta t]$ 内被视为常数。\n\n使用固定的中点哈密顿量 $\\mathbf{H}_{\\mathrm{mid}}$，我们采用两种不同的方法执行从 $t=0$ 到 $t=\\Delta t$ 的演化：\n\n1.  Crank-Nicolson (CN)：这种隐式方法基于指数传播子的二阶 Padé 近似 $\\exp(-z) \\approx (1-z/2)/(1+z/2)$。时间演化方程变成了一个关于新时刻状态 $\\Phi(\\Delta t)$ 的线性方程组：\n    $$\n    \\left(\\mathbf{I} + \\frac{\\mathrm{i}\\Delta t}{2} \\mathbf{H}_{\\mathrm{mid}}\\right) \\Phi_{\\mathrm{CN}}(\\Delta t) = \\left(\\mathbf{I} - \\frac{\\mathrm{i}\\Delta t}{2} \\mathbf{H}_{\\mathrm{mid}}\\right) \\Phi(0)\n    $$\n    我们对矩阵 $\\Phi_{\\mathrm{CN}}(\\Delta t)$ 中的每个轨道求解此方程组。虽然此方法对于线性问题是无条件稳定的，但其传播子并不完全幺正，这可能导致轻微的模偏差。\n\n2.  二阶 Magnus (指数中点)：此方法使用中点哈密顿量的精确指数作为传播子。对于不含时的 $\\mathbf{H}_{\\mathrm{mid}}$，它是完全幺正的：\n    $$\n    \\Phi_{\\mathrm{Mag}}(\\Delta t) = \\exp(-\\mathrm{i} \\Delta t \\mathbf{H}_{\\mathrm{mid}}) \\Phi(0)\n    $$\n    矩阵指数是数值计算的，例如，使用 `scipy.linalg.expm` 中实现的基于 Padé 近似的算法。\n\n用两种格式演化轨道后，我们得到 $\\Phi_{\\mathrm{CN}}(\\Delta t)$ 和 $\\Phi_{\\mathrm{Mag}}(\\Delta t)$。作为最后一步，我们分别为每种方法重新正交归一化占据轨道集，以校正任何数值漂移，并确保密度是从一个正交归一的集合计算得出的。从正交归一化的轨道，我们计算最终密度 $n_{\\mathrm{CN}}(\\Delta t)$ 和 $n_{\\mathrm{Mag}}(\\Delta t)$。\n\n最终结果是两种密度之差的加权 $L^2$-范数，它量化了在给定参数集下两种传播格式之间的差异：\n$$\nD = \\left( \\sum_{\\ell=0}^{N-1} \\left( n_{\\mathrm{CN}}(x_\\ell) - n_{\\mathrm{Mag}}(x_\\ell) \\right)^2 \\Delta x \\right)^{1/2}\n$$\n对每个测试用例执行此过程以生成所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm, solve as linsolve\n\ndef run_one_step(N, L, dt, omega, alpha, k, N_occ):\n    \"\"\"\n    Implements a one-step real-time TDDFT propagation using Crank-Nicolson\n    and Magnus propagators and computes the density difference.\n    \"\"\"\n    # 1. Grid and constants setup\n    dx = L / N\n    x = np.arange(N) * dx - L / 2\n    C = (3 / np.pi)**(1/3)\n\n    # 2. Kinetic energy operator matrix (T) from 2nd-order finite difference\n    diag_val = -2.0 / dx**2\n    off_diag_val = 1.0 / dx**2\n    \n    D2 = np.diag(np.full(N, diag_val)) + \\\n         np.diag(np.full(N - 1, off_diag_val), k=1) + \\\n         np.diag(np.full(N - 1, off_diag_val), k=-1)\n    \n    # Periodic boundary conditions\n    D2[0, N - 1] = off_diag_val\n    D2[N - 1, 0] = off_diag_val\n    \n    T = -0.5 * D2\n\n    # 3. Initial Kohn-Sham orbitals (at t = 0^-)\n    phi_mat_0_minus = np.zeros((N, N_occ), dtype=np.complex128)\n    \n    phi0_analytic = (omega / np.pi)**(0.25) * np.exp(-0.5 * omega * x**2)\n    phi_mat_0_minus[:, 0] = phi0_analytic\n    \n    if N_occ == 2:\n        phi1_analytic = np.sqrt(2 * omega) * x * phi0_analytic\n        phi_mat_0_minus[:, 1] = phi1_analytic\n        \n    # Orthonormalize initial orbitals on the grid using QR decomposition\n    Q, _ = np.linalg.qr(phi_mat_0_minus * np.sqrt(dx))\n    phi_mat_0_minus = Q / np.sqrt(dx)\n\n    # 4. Apply delta-kick at t=0 to get initial state for propagation (t=0^+)\n    kick_phase = np.exp(-1j * k * x)\n    phi_mat_0 = phi_mat_0_minus * kick_phase[:, np.newaxis]\n\n    # 5. Predictor-Corrector step for midpoint Hamiltonian\n    # Predictor: Evolve to dt/2 with H(t=0)\n    n_0 = np.sum(np.abs(phi_mat_0)**2, axis=1)\n    v_xc_0 = -alpha * C * np.power(n_0, 1/3, where=n_0>0, out=np.zeros_like(n_0))\n    v_ext = 0.5 * omega**2 * x**2\n    V_0 = np.diag(v_ext + v_xc_0)\n    H_0 = T + V_0\n    \n    U_pred = expm(-1j * H_0 * dt / 2.0)\n    phi_pred_half = U_pred @ phi_mat_0\n    \n    # Corrector: Build H_mid using density at dt/2\n    n_pred_half = np.sum(np.abs(phi_pred_half)**2, axis=1)\n    v_xc_mid = -alpha * C * np.power(n_pred_half, 1/3, where=n_pred_half>0, out=np.zeros_like(n_pred_half))\n    V_mid = np.diag(v_ext + v_xc_mid)\n    H_mid = T + V_mid\n\n    # 6. Propagate from t=0 to t=dt using H_mid\n    # Method 1: Crank-Nicolson\n    A_cn = np.eye(N, dtype=np.complex128) + 0.5j * dt * H_mid\n    B_cn = np.eye(N, dtype=np.complex128) - 0.5j * dt * H_mid\n    phi_mat_cn_dt = np.zeros_like(phi_mat_0)\n    for j in range(N_occ):\n        phi_mat_cn_dt[:, j] = linsolve(A_cn, B_cn @ phi_mat_0[:, j])\n\n    # Method 2: Magnus (Exponential Midpoint)\n    U_mag = expm(-1j * H_mid * dt)\n    phi_mat_mag_dt = U_mag @ phi_mat_0\n\n    # 7. Re-orthonormalize final states\n    Q_cn, _ = np.linalg.qr(phi_mat_cn_dt * np.sqrt(dx))\n    phi_mat_cn_final = Q_cn / np.sqrt(dx)\n\n    Q_mag, _ = np.linalg.qr(phi_mat_mag_dt * np.sqrt(dx))\n    phi_mat_mag_final = Q_mag / np.sqrt(dx)\n\n    # 8. Compute final densities and their difference\n    n_cn = np.sum(np.abs(phi_mat_cn_final)**2, axis=1)\n    n_mag = np.sum(np.abs(phi_mat_mag_final)**2, axis=1)\n    \n    diff_norm_sq = np.sum((n_cn - n_mag)**2) * dx\n    D = np.sqrt(diff_norm_sq)\n\n    return D\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        (128, 20, 0.05, 0.5, 0.8, 0.001, 1),\n        (128, 20, 0.005, 0.5, 0.8, 0.001, 1),\n        (128, 20, 0.10, 0.5, 0.8, 0.001, 1),\n        (128, 20, 0.05, 0.5, 0.8, 0.0005, 2),\n    ]\n\n    results = [run_one_step(*params) for params in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了如何传播Kohn-Sham轨道之后，下一个关键问题是如何从这些时间演化的信息中提取可观测的物理量。本练习将时间传播与光谱学直接联系起来，演示如何通过计算偶极矩的实时动力学来获得分子的吸收光谱。您将学习到如何通过傅里叶变换将时域信号转换为频域光谱，并将其与线性响应理论（Casida方法）的结果进行比较，从而贯通TD-DFT的两种主要计算范式。",
            "id": "2932976",
            "problem": "本问题给定一个简化的、完全指定的线性响应场景，旨在模拟实时含时密度泛函理论 (TDDFT) 模拟如何在微小脉冲电场（“delta 脉冲”）作用后产生吸收光谱，以及如何将该光谱与 Casida 方程的结果进行比较。您的任务是构建一个完整的程序，该程序针对一组预设的测试用例，从合成的时域偶极矩轨迹中重构振子强度分布，并将恢复的峰位和强度与参考的 Casida 激发能和振子强度进行比较。最终输出必须将所有测试用例的误差指标汇总为单行，具体格式如下所述。\n\n推导和算法设计的基本原理：\n- 在线性响应中，一个弱的含时外场会感应出由 Kubo 响应函数描述的偶极矩。频率依赖极化率 $ \\alpha(\\omega) $ 表征了在频率空间中感应偶极矩与外场之间的比例关系。\n- 在含时密度泛函理论 (TDDFT) 的绝热近似下，对于给定方向（假设脉冲和偶极矩平行对齐），Casida 方程可得出一组离散的激发能 $ \\{\\omega_k\\} $ 和振子强度 $ \\{f_k\\} $。这些振子强度是无量纲的，并且在完备基组极限下满足 Thomas–Reiche–Kuhn 求和规则。\n- 在线性区域内，吸收光谱与 $ \\omega \\,\\mathrm{Im}\\,\\alpha(\\omega) $ 成正比。一个标准的、经过充分检验的关系将振子强度分布与动态极化率联系起来，即 $ S(\\omega) = \\dfrac{2}{\\pi}\\,\\omega\\,\\mathrm{Im}\\,\\alpha(\\omega) $，其中 $ S(\\omega) $ 积分后得到总振子强度，并且在理想的、无限时间、零阻尼极限下，简化为 delta 峰的总和 $ \\sum_k f_k \\,\\delta(\\omega-\\omega_k) $。\n\n为解决此问题，假设在严格的线性区域内，以下模型选择是有效的：\n- 在时间 $ t=0 $ 时的“delta-kick”产生一个合成的含时偶极矩轨迹，其模型为有限个指数阻尼正弦波之和：\n  $$ d(t) = \\sum_{k=1}^{K} \\frac{2 f_k}{\\omega_k}\\,\\sin(\\omega_k t)\\,e^{-\\eta t}, \\quad t \\ge 0, $$\n  其中 $ \\eta $ 是一个正的阻尼参数，用于模拟退相干并提供光谱展宽。所有量均采用原子单位：角频率 $ \\omega $ 以 Hartree 为单位，时间 $ t $ 以原子时间单位为单位，$ \\eta $ 以 Hartree 为单位。\n- 振子强度密度是通过对 $ \\alpha(\\omega) $ 的单边离散傅里叶变换近似从时间信号中重构的，\n  $$ \\alpha(\\omega) \\approx \\int_{0}^{T} d(t)\\,e^{i \\omega t}\\,dt, $$\n  随后通过下式计算：\n  $$ S(\\omega) = \\frac{2}{\\pi}\\,\\omega\\,\\mathrm{Im}\\,\\alpha(\\omega). $$\n  在数值计算中，$ T $ 是有限的，并且积分被替换为在均匀时间网格 $ t_n = n\\,\\Delta t $（$ n=0,\\dots,N-1 $）上的黎曼和。\n\n程序要求：\n1. 输入是隐式的：将下面列出的三个测试用例直接在代码中实现。不允许用户输入或文件 I/O。\n2. 对于每个测试用例，执行以下所有操作：\n   - 使用提供的 $ \\Delta t $、$ N $、$ \\eta $、$ \\{\\omega_k\\} $ 和 $ \\{f_k\\} $ 在均匀网格上构建 $ d(t) $。\n   - 计算单边离散傅里叶变换近似，以在与变换相关的非负角频率网格上恢复 $ \\alpha(\\omega) $。由此，通过 $ S(\\omega) = \\dfrac{2}{\\pi}\\,\\omega\\,\\mathrm{Im}\\,\\alpha(\\omega) $ 计算 $ S(\\omega) $。\n   - 仅使用 $ S(\\omega) $，为每个预设的参考峰 $ \\omega_k $ 提取以下信息：\n     a) 峰位估计值 $ \\widehat{\\omega}_k $，计算方法是在围绕 $ \\omega_k $ 的非重叠区间上的谱质心。将区间边界定义为相邻参考 $ \\omega_k $ 值之间的中点，第一个区间的下限设置为 $ \\omega_1 - 6\\eta $，最后一个区间的上限设置为 $ \\omega_K + 6\\eta $。将任何低于 $ 0 $ 的边界裁剪为 $ 0 $。在计算 $ \\widehat{\\omega}_k $ 时，仅使用每个区间内的数据：\n     $$ \\widehat{\\omega}_k = \\frac{\\int_{\\mathrm{interval}_k} \\omega\\,S(\\omega)\\,d\\omega}{\\int_{\\mathrm{interval}_k} S(\\omega)\\,d\\omega}. $$\n     b) 峰强度估计值 $ \\widehat{f}_k $，计算方法是 $ S(\\omega) $ 在同一区间下的面积：\n     $$ \\widehat{f}_k = \\int_{\\mathrm{interval}_k} S(\\omega)\\,d\\omega. $$\n   - 计算以下误差指标：\n     a) 测试中所有峰的最大绝对峰位误差：\n     $$ \\varepsilon_{\\omega}^{\\max} = \\max_k \\left| \\widehat{\\omega}_k - \\omega_k \\right|, $$\n     以 Hartree 表示。\n     b) 按如下方式汇总的峰强度误差。对于每个 $ f_k  0 $ 的 $ k $，定义相对误差\n     $$ \\varepsilon_{f,k}^{\\mathrm{rel}} = \\frac{\\left|\\widehat{f}_k - f_k\\right|}{f_k}. $$\n     对于任何 $ f_k = 0 $ 的 $ k $，定义绝对面积误差\n     $$ \\varepsilon_{f,k}^{\\mathrm{abs0}} = \\left|\\widehat{f}_k\\right|. $$\n     将测试的单个最差情况峰强度误差报告为\n     $$ \\varepsilon_{f}^{\\max} = \\max\\Big(\\{\\varepsilon_{f,k}^{\\mathrm{rel}}: f_k0\\}\\cup\\{\\varepsilon_{f,k}^{\\mathrm{abs0}}: f_k=0\\}\\Big). $$\n3. 输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。具体来说，对于下面的三个测试，打印\n   $$ [\\varepsilon_{\\omega,1}^{\\max},\\varepsilon_{f,1}^{\\max},\\varepsilon_{\\omega,2}^{\\max},\\varepsilon_{f,2}^{\\max},\\varepsilon_{\\omega,3}^{\\max},\\varepsilon_{f,3}^{\\max}] $$\n   不带任何附加文本。$ \\varepsilon_{\\omega}^{\\max} $ 的单位是 Hartree，峰强度误差条目是十进制数，不带任何百分号。\n\n测试套件（将这些硬编码到您的程序中）：\n- 测试 1（分离良好的谱线）：\n  - $ \\omega = [0.30,\\,0.55,\\,0.90] $ (Hartree),\n  - $ f = [0.20,\\,0.06,\\,0.12] $ (无量纲),\n  - $ \\eta = 0.006 $ (Hartree),\n  - $ \\Delta t = 0.2 $ (原子时间单位),\n  - $ N = 16384 $ (整数).\n- 测试 2（近简并双峰）：\n  - $ \\omega = [0.500,\\,0.515,\\,0.82] $ (Hartree),\n  - $ f = [0.10,\\,0.08,\\,0.02] $,\n  - $ \\eta = 0.004 $,\n  - $ \\Delta t = 0.2 $,\n  - $ N = 16384 $.\n- 测试 3（包含一个暗态）：\n  - $ \\omega = [0.40,\\,0.70,\\,0.95] $ (Hartree),\n  - $ f = [0.15,\\,0.00,\\,0.04] $,\n  - $ \\eta = 0.006 $,\n  - $ \\Delta t = 0.2 $,\n  - $ N = 16384 $.\n\n实现说明：\n- 所有计算均以原子单位进行。明确地以 Hartree 报告 $ \\varepsilon_{\\omega}^{\\max} $，并将峰强度误差值报告为十进制数（无百分号）。\n- 使用梯形法则在离散频率网格上进行数值积分，以实现所有 $ \\omega $ 域积分。\n- 确保所有按所述方式构建的峰区间不重叠，并被裁剪到 $ \\omega \\ge 0 $。\n- 算法必须对谱线重叠和有限时间窗口误差具有鲁棒性，测试套件探讨了一个典型情况、一个近简并情况以及存在暗（禁戒）跃迁的情况。最终的数值输出必须是浮点数。",
            "solution": "所提出的问题是一个定义明确的计算任务，它基于线性响应范围内的含时密度泛函理论（TDDFT）原理。它要求实现一个标准的工作流程：从一组已知的电子激发中生成时域偶极信号，通过数值傅里叶变换获得吸收光谱，然后分析该光谱以恢复原始的激发特性。该问题在科学上是合理的、内部一致且完整的。所有参数、模型和过程都得到了明确的规定。因此，该问题被认为是有效的，并将构建一个完整的解决方案。\n\n算法设计为对每个测试用例遵循规定的操作序列。所有计算均以原子单位进行。\n\n首先，在离散时间网格上构建合成的含时偶极矩，记为 $d(t)$。问题指定了在时间 $t=0$ 时对 delta 函数电场脉冲的偶极响应模型，该模型是 $K$ 个电子跃迁的总和：\n$$\nd(t) = \\sum_{k=1}^{K} \\frac{2 f_k}{\\omega_k}\\,\\sin(\\omega_k t)\\,e^{-\\eta t}, \\quad t \\ge 0\n$$\n这里，$\\{\\omega_k\\}$ 是参考激发能，$\\{f_k\\}$ 是无量纲振子强度，$\\eta$ 是一个唯象的阻尼参数，它将谱线展宽为洛伦兹线型。时间网格是均匀的，由 $t_n = n\\,\\Delta t$ 定义，其中 $n = 0, 1, \\dots, N-1$，$\\Delta t$ 是时间步长，$N$ 是总点数。对于给定的测试用例，通过对每个具有非零振子强度 $f_k  0$ 的跃迁的贡献求和，来计算信号 $d(t_n)$。\n\n其次，吸收光谱由频率依赖的极化率 $\\alpha(\\omega)$ 推导得出。问题定义了一个单边傅里叶变换来从时域信号中近似 $\\alpha(\\omega)$：\n$$\n\\alpha(\\omega) \\approx \\int_{0}^{T} d(t)\\,e^{i \\omega t}\\,dt\n$$\n其中积分上限 $T$ 对应于总模拟时间，$T = N \\Delta t$。该积分使用离散傅里叶变换进行数值评估。具体来说，计算表达式 $\\sum_{n=0}^{N-1} d(t_n) e^{i \\omega_m t_n} \\Delta t$，其中离散频率为 $\\omega_m = 2\\pi m / (N \\Delta t)$。这个特定的和对应于逆离散傅里叶变换 (IDFT)，并按总时间长度 $N\\Delta t$ 进行缩放。我们使用 `numpy.fft.ifft` 计算 IDFT，然后进行缩放。该计算在离散频率网格上得出 $\\alpha(\\omega)$。我们只保留对应于非负频率 $\\omega \\ge 0$ 的分量。由此，使用提供的关系式计算振子强度密度 $S(\\omega)$：\n$$\nS(\\omega) = \\frac{2}{\\pi}\\,\\omega\\,\\mathrm{Im}\\,\\alpha(\\omega)\n$$\n\n第三，对计算出的光谱 $S(\\omega)$ 进行分析，以提取峰位 $\\widehat{\\omega}_k$ 和峰强度 $\\widehat{f}_k$ 的估计值。这需要将频率轴划分为一组 $K$ 个不重叠的区间，每个区间对应一个参考峰 $\\omega_k$。这些区间的边界定义为相邻参考频率之间的中点，即 $(\\omega_i + \\omega_{i+1})/2$。第一个区间从 $\\omega_1 - 6\\eta$ 开始，最后一个区间在 $\\omega_K + 6\\eta$ 结束。所有区间边界都被裁剪为非负值。在每个区间 $k$ 内，估计的峰位 $\\widehat{\\omega}_k$ 计算为谱质心，而估计的强度 $\\widehat{f}_k$ 是谱线下方的总面积：\n$$\n\\widehat{\\omega}_k = \\frac{\\int_{\\mathrm{interval}_k} \\omega\\,S(\\omega)\\,d\\omega}{\\int_{\\mathrm{interval}_k} S(\\omega)\\,d\\omega}, \\quad \\widehat{f}_k = \\int_{\\mathrm{interval}_k} S(\\omega)\\,d\\omega\n$$\n这些积分使用梯形法则在离散频率网格上进行数值计算，由 `scipy.integrate.trapezoid` 函数指定。\n\n最后，为每个测试用例计算两个误差指标，以量化恢复过程的准确性。最大绝对峰位误差 $\\varepsilon_{\\omega}^{\\max}$ 是估计峰位与其参考值之间的最大偏差：\n$$\n\\varepsilon_{\\omega}^{\\max} = \\max_k |\\widehat{\\omega}_k - \\omega_k|\n$$\n最大峰强度误差 $\\varepsilon_{f}^{\\max}$ 以混合方式定义，以处理亮态（$f_k  0$）和暗态（$f_k = 0$）。对于亮态，使用相对误差 $\\varepsilon_{f,k}^{\\mathrm{rel}} = |\\widehat{f}_k - f_k|/f_k$。对于暗态，使用绝对面积误差 $\\varepsilon_{f,k}^{\\mathrm{abs0}} = |\\widehat{f}_k|$。最终的指标是所有这些单个误差中的最大值：\n$$\n\\varepsilon_{f}^{\\max} = \\max\\Big(\\{\\varepsilon_{f,k}^{\\mathrm{rel}}: f_k0\\}\\cup\\{\\varepsilon_{f,k}^{\\mathrm{abs0}}: f_k=0\\}\\Big)\n$$\n程序处理所有3个测试用例，将每个用例的2个误差指标汇总到一个列表中，并以要求的格式打印结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import trapezoid\n\ndef process_case(case_params):\n    \"\"\"\n    Processes a single test case to compute spectral reconstruction errors.\n\n    Args:\n        case_params (tuple): A tuple containing the parameters for the test case:\n            (ref_omegas, ref_fs, eta, delta_t, N).\n\n    Returns:\n        tuple: A tuple containing the two error metrics (eps_omega_max, eps_f_max).\n    \"\"\"\n    ref_omegas, ref_fs, eta, delta_t, N = case_params\n\n    # Step 1: Construct the time-dependent dipole moment d(t)\n    t = np.arange(N) * delta_t\n    d_t = np.zeros(N, dtype=np.float64)\n    for omega_k, f_k in zip(ref_omegas, ref_fs):\n        # The model formula involves 1/omega_k, so we only add terms for non-zero frequencies\n        if omega_k > 0 and f_k > 0:\n            d_t += (2.0 * f_k / omega_k) * np.sin(omega_k * t) * np.exp(-eta * t)\n\n    # Step 2: Compute the spectrum S(omega) via Fourier Transform\n    # The required transform is integral[d(t) * exp(i*omega*t)] dt.\n    # This corresponds to N * dt * ifft(d_t).\n    alpha_omega_full = N * delta_t * np.fft.ifft(d_t)\n    omega_grid_full = np.fft.fftfreq(N, delta_t) * 2.0 * np.pi\n\n    # For robustness, fftshift to get a monotonic frequency axis.\n    alpha_omega_shifted = np.fft.fftshift(alpha_omega_full)\n    omega_grid_shifted = np.fft.fftshift(omega_grid_full)\n    \n    # Keep only the non-negative frequency part of the spectrum.\n    zero_idx = np.searchsorted(omega_grid_shifted, 0.0)\n    omega_grid = omega_grid_shifted[zero_idx:]\n    alpha_omega_nonneg = alpha_omega_shifted[zero_idx:]\n\n    # Calculate the oscillator strength density S(omega)\n    S_omega = (2.0 / np.pi) * omega_grid * np.imag(alpha_omega_nonneg)\n\n    # Step 3: Analyze peaks by integrating over specified intervals\n    K = len(ref_omegas)\n    if K > 1:\n        midpoints = (ref_omegas[:-1] + ref_omegas[1:]) / 2.0\n        bounds = np.concatenate(\n            ([ref_omegas[0] - 6.0 * eta], midpoints, [ref_omegas[-1] + 6.0 * eta])\n        )\n    else: # Handle case with a single peak\n        bounds = np.array([ref_omegas[0] - 6.0 * eta, ref_omegas[0] + 6.0 * eta])\n        \n    bounds = np.maximum(0.0, bounds)\n\n    omega_hats = []\n    f_hats = []\n\n    for k in range(K):\n        w_min, w_max = bounds[k], bounds[k + 1]\n\n        # Find the slice of the frequency grid corresponding to the interval\n        start_idx = np.searchsorted(omega_grid, w_min, side='left')\n        end_idx = np.searchsorted(omega_grid, w_max, side='right')\n\n        # Ensure we have at least two points for trapezoidal rule\n        if end_idx > start_idx:\n            omega_sub = omega_grid[start_idx:end_idx]\n            S_sub = S_omega[start_idx:end_idx]\n\n            # Numerically integrate using the trapezoidal rule\n            area = trapezoid(S_sub, omega_sub)\n            centroid_numerator = trapezoid(omega_sub * S_sub, omega_sub)\n            \n            f_hat = area\n            if np.abs(area)  1e-15:\n                # Avoid division by zero for dark states or empty intervals\n                omega_hat = (w_min + w_max) / 2.0\n            else:\n                omega_hat = centroid_numerator / area\n        else: # Interval contains less than 2 points\n            omega_hat = (w_min + w_max) / 2.0\n            f_hat = 0.0\n\n        omega_hats.append(omega_hat)\n        f_hats.append(f_hat)\n\n    omega_hats = np.array(omega_hats)\n    f_hats = np.array(f_hats)\n\n    # Step 4: Compute error metrics\n    eps_omega_max = np.max(np.abs(omega_hats - ref_omegas))\n    \n    f_errors = []\n    for k in range(K):\n        if ref_fs[k] > 0:\n            error = np.abs(f_hats[k] - ref_fs[k]) / ref_fs[k]\n        else:  # For dark states (f_k = 0)\n            error = np.abs(f_hats[k])\n        f_errors.append(error)\n    \n    eps_f_max = np.max(f_errors)\n    \n    return eps_omega_max, eps_f_max\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (well-separated lines)\n        (np.array([0.30, 0.55, 0.90]), np.array([0.20, 0.06, 0.12]), 0.006, 0.2, 16384),\n        # Test 2 (near-degenerate doublet)\n        (np.array([0.500, 0.515, 0.82]), np.array([0.10, 0.08, 0.02]), 0.004, 0.2, 16384),\n        # Test 3 (includes a dark state)\n        (np.array([0.40, 0.70, 0.95]), np.array([0.15, 0.00, 0.04]), 0.006, 0.2, 16384),\n    ]\n\n    results = []\n    for case in test_cases:\n        # To ensure robustness, sort peaks by frequency for interval calculation logic\n        omegas, fs, eta, dt, N = case\n        sort_indices = np.argsort(omegas)\n        sorted_case = (omegas[sort_indices], fs[sort_indices], eta, dt, N)\n        \n        eps_omega_max, eps_f_max = process_case(sorted_case)\n        results.append(eps_omega_max)\n        results.append(eps_f_max)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}