{
    "hands_on_practices": [
        {
            "introduction": "任何实时模拟的核心都是时间传播算法。为了模拟电子动力学，我们需要逐步求解含时Kohn-Sham方程。本练习将聚焦于实现一个至关重要的时间步长，通过在一个简化的非线性模型中比较两种标准的数值方法（Crank-Nicolson和Magnus方法），让您掌握实时TD-DFT模拟的基础技能。完成此练习将有助于理解在真实代码中处理非线性、自洽的含时哈密顿量的复杂性。",
            "id": "2932905",
            "problem": "要求您从第一性原理出发，实现 Kohn–Sham 轨道在含时密度泛函理论 (TDDFT) 中的一步实时传播，其中哈密顿算符采用二阶中点评估，并使用两种不同的传播子：Crank–Nicolson 格式和二阶 Magnus 指数。完全在原子单位下进行计算，因此电子质量、基本电荷、约化普朗克常数和库仑常数都等于 $1$。从含时 Kohn-Sham 方程开始\n$$\n\\mathrm{i}\\,\\frac{\\partial}{\\partial t}\\,\\phi_j(x,t)\\;=\\;\\hat{H}_{\\mathrm{s}}[n(\\cdot,t)]\\,\\phi_j(x,t),\n$$\n其中 Slater 行列式由占据轨道 $\\{\\phi_j\\}_{j=1}^{N_{\\mathrm{occ}}}$ 构建，密度为\n$$\nn(x,t)\\;=\\;\\sum_{j=1}^{N_{\\mathrm{occ}}}\\lvert \\phi_j(x,t)\\rvert^2.\n$$\n在本问题中，Kohn-Sham 哈密顿算符的模型为\n$$\n\\hat{H}_{\\mathrm{s}}[n]\\;=\\;-\\frac{1}{2}\\frac{d^2}{dx^2}\\;+\\;v_{\\mathrm{ext}}(x)\\;+\\;v_{\\mathrm{xc}}(n(x)),\n$$\n其中 $v_{\\mathrm{ext}}(x)$ 是一个静态谐波禁闭势，$v_{\\mathrm{xc}}(n)$ 是一个绝热局域密度近似 (ALDA) 交换相关势。为保持模型完全局域和自洽，忽略 Hartree 势并使用以下形式：\n- 谐波外势\n$$\nv_{\\mathrm{ext}}(x)\\;=\\;\\frac{1}{2}\\,\\omega^2\\,x^2,\n$$\n其中 $\\omega$ 是角频率。\n- 局域 ALDA 型交换相关势\n$$\nv_{\\mathrm{xc}}(n)\\;=\\;-\\,\\alpha\\,C\\,n^{1/3},\\quad C=\\left(\\frac{3}{\\pi}\\right)^{1/3},\n$$\n其中 $\\alpha$ 是一个无量纲缩放参数。\n\n在区间 $[-L/2,L/2)$ 上，将空间离散化为一个包含 $N$ 个点的均匀周期性网格，格点间距为 $\\Delta x=L/N$，并使用具有周期性边界条件的二阶中心有限差分拉普拉斯算符来近似动能算符。时间 $t=0$ 时的初始占据 Kohn-Sham 轨道取为频率为 $\\omega$ 的最低谐振子本征函数（在连续谱下），将其截断到网格上，然后在网格上进行正交归一化。对于 $N_{\\mathrm{occ}}=1$，取基态\n$$\n\\phi_0(x)\\;=\\;\\left(\\frac{\\omega}{\\pi}\\right)^{1/4}\\exp\\!\\left(-\\frac{\\omega}{2}x^2\\right).\n$$\n对于 $N_{\\mathrm{occ}}=2$，取上述的 $\\phi_0(x)$ 和第一激发态\n$$\n\\phi_1(x)\\;=\\;\\sqrt{2\\,\\omega}\\,x\\,\\phi_0(x).\n$$\n在 $t=0$ 时施加一个弱脉冲电场，该电场通过所谓的 $\\delta$-踢 来建模，这导致每个轨道乘以一个相位因子，\n$$\n\\phi_j(x,0^+)\\;=\\;\\exp\\!\\big(-\\mathrm{i}\\,k\\,x\\big)\\,\\phi_j(x,0^-),\n$$\n其中 $k$ 很小，以保持在线性响应范围内。然后，对于大小为 $\\Delta t$ 的单个时间步，使用预测-校正策略构建一个中点哈密顿算符 $\\hat{H}_{\\mathrm{s}}[n(t+\\Delta t/2)]$：\n- 预测步：使用时间 $t$ 时的哈密顿算符从 $t$ 传播到 $t+\\Delta t/2$，以获得预测的中点密度 $n(x,t+\\Delta t/2)$。\n- 校正步：用 $v_{\\mathrm{xc}}(n(x,t+\\Delta t/2))$ 构成中点哈密顿算符，并将其用于最终的 $t\\to t+\\Delta t$ 传播。\n\n使用相同的中点哈密顿算符实现以下两种二阶传播子：\n- Crank–Nicolson (CN)：求解\n$$\n\\Big(\\mathbf{I}+\\frac{\\mathrm{i}\\,\\Delta t}{2}\\,\\mathbf{H}_{\\mathrm{mid}}\\Big)\\,\\Phi(t+\\Delta t)\\;=\\;\\Big(\\mathbf{I}-\\frac{\\mathrm{i}\\,\\Delta t}{2}\\,\\mathbf{H}_{\\mathrm{mid}}\\Big)\\,\\Phi(t),\n$$\n其中粗体符号表示在网格上的矩阵表示，$\\Phi$ 将占据轨道按列堆叠。对每一列分别求解。\n- 二阶 Magnus（指数中点）：\n$$\n\\Phi(t+\\Delta t)\\;=\\;\\exp\\!\\big(-\\mathrm{i}\\,\\Delta t\\,\\mathbf{H}_{\\mathrm{mid}}\\big)\\,\\Phi(t).\n$$\n传播后，相对于离散内积 $\\langle f,g\\rangle=\\sum_\\ell \\overline{f_\\ell}\\,g_\\ell\\,\\Delta x$ 重新正交归一化占据轨道。从每个传播后的 Slater 行列式计算密度，并报告两种格式之间密度差的加权 $\\mathrm{L}^2$-范数，\n$$\nD\\;=\\;\\Bigg(\\sum_{\\ell=1}^{N}\\big(n_{\\mathrm{CN}}(x_\\ell)-n_{\\mathrm{Mag}}(x_\\ell)\\big)^2\\,\\Delta x\\Bigg)^{1/2}.\n$$\n\n您的程序必须从第一性原理出发实现以上内容，并为以下测试套件生成结果，每个测试由元组 $(N,L,\\Delta t,\\omega,\\alpha,k,N_{\\mathrm{occ}})$ 指定：\n- 测试 1：$(N,L,\\Delta t,\\omega,\\alpha,k,N_{\\mathrm{occ}})=(\\,128,\\,20,\\,0.05,\\,0.5,\\,0.8,\\,0.001,\\,1\\,)$。\n- 测试 2：$(N,L,\\Delta t,\\omega,\\alpha,k,N_{\\mathrm{occ}})=(\\,128,\\,20,\\,0.005,\\,0.5,\\,0.8,\\,0.001,\\,1\\,)$。\n- 测试 3：$(N,L,\\Delta t,\\omega,\\alpha,k,N_{\\mathrm{occ}})=(\\,128,\\,20,\\,0.10,\\,0.5,\\,0.8,\\,0.001,\\,1\\,)$。\n- 测试 4：$(N,L,\\Delta t,\\omega,\\alpha,k,N_{\\mathrm{occ}})=(\\,128,\\,20,\\,0.05,\\,0.5,\\,0.8,\\,0.0005,\\,2\\,)$。\n\n所有量均以原子单位表示。角度和相位以弧度表示。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是上述相应测试用例的 $D$ 的浮点数值。不应打印任何额外文本。",
            "solution": "该问题要求为一维系统实现含时密度泛函理论 (TDDFT) 模拟中的单个时间步。我们的任务是使用预测-校正方法处理含时势，比较两种二阶传播格式：Crank-Nicolson 和 Magnus 指数。分析过程如下。\n\n首先，我们必须在空间网格上为问题建立一个离散表示。在定义域 $[-L/2, L/2)$ 上的连续空间坐标 $x$ 被离散化为 $N$ 个点 $x_\\ell = -L/2 + \\ell \\Delta x$，其中 $\\ell = 0, 1, \\dots, N-1$，网格间距为 $\\Delta x = L/N$。一个量子态（轨道）$\\phi(x)$ 由其在这些网格点上的值构成的列向量 $\\boldsymbol{\\phi}$ 表示，$\\phi_\\ell = \\phi(x_\\ell)$。两个态 $\\phi$ 和 $\\psi$ 之间的内积通过离散求和 $\\langle\\phi|\\psi\\rangle = \\sum_{\\ell=0}^{N-1} \\overline{\\phi_\\ell} \\psi_\\ell \\Delta x$ 来近似。\n\nKohn-Sham 哈密顿算符 $\\hat{H}_{\\mathrm{s}} = \\hat{T} + \\hat{V}$ 由动能部分 $\\hat{T} = -\\frac{1}{2}\\frac{d^2}{dx^2}$ 和势能部分 $\\hat{V} = v_{\\mathrm{ext}}(x) + v_{\\mathrm{xc}}(n(x))$ 组成。势算符 $\\hat{V}$ 在位置空间中是局域的，因此其矩阵表示 $\\mathbf{V}$ 是对角的，其元素为 $V_{\\ell\\ell} = v_{\\mathrm{ext}}(x_\\ell) + v_{\\mathrm{xc}}(n(x_\\ell))$。动能算符 $\\hat{T}$ 使用具有周期性边界条件的二阶中心有限差分公式来近似拉普拉斯算符：\n$$\n(\\hat{T} \\phi)_\\ell \\approx -\\frac{1}{2\\Delta x^2} \\big( \\phi_{\\ell+1} - 2\\phi_\\ell + \\phi_{\\ell-1} \\big)\n$$\n其中索引对 $N$ 取模。这会产生一个大小为 $N \\times N$ 的实对称循环矩阵 $\\mathbf{T}$。那么，在给定时间的完整哈密顿算符由稠密矩阵 $\\mathbf{H} = \\mathbf{T} + \\mathbf{V}$ 表示。\n\n时间 $t=0^-$ 时的初始态是根据所提供的谐振子本征函数的解析形式构建的。对于 $N_{\\mathrm{occ}}$ 个占据轨道，我们通过在网格上计算函数值来构建一个大小为 $N \\times N_{\\mathrm{occ}}$ 的矩阵 $\\Phi_{cont}$。这些连续函数是关于积分正交归一的，但它们在离散形式下不一定相对于离散内积是正交归一的。因此，我们必须在网格上进行正交归一化。这可以通过对矩阵 $\\sqrt{\\Delta x} \\Phi_{cont}$ 应用 Gram-Schmidt 过程（或更稳健的 QR 分解）来实现，其列在标准欧几里得意义下是正交归一的。得到的正交归一矩阵在乘以 $1/\\sqrt{\\Delta x}$ 后，便得到在网格上正确正交归一化的初始轨道 $\\Phi(0^-)$。\n\n在 $t=0$ 时，施加一个脉冲电场（$\\delta$-踢）。这会给电子一个动量踢 $k$，在位置空间中对应于给每个轨道乘以一个相位因子：\n$$\n\\Phi(x,0^+) = \\exp(-\\mathrm{i}kx) \\Phi(x,0^-)\n$$\n这个操作是酉操作，并保持了轨道的正交归一性。得到的态矩阵 $\\Phi(0) \\equiv \\Phi(0^+)$ 作为时间传播的初始条件。\n\n问题的核心在于从 $t=0$ 到 $t=\\Delta t$ 的单步传播。哈密顿算符通过 $v_{\\mathrm{xc}}(n(x,t))$ 项依赖于密度，因此是含时的。为了在时间步 $\\Delta t$ 上保持二阶精度，采用预测-校正格式来近似区间中点 $t+\\Delta t/2$ 的哈密顿算符 $\\mathbf{H}_{\\mathrm{mid}} \\approx \\mathbf{H}(t+\\Delta t/2)$。\n\n预测步：我们首先估计中点处的轨道 $\\Phi_{pred}(\\Delta t/2)$。这是通过使用初始时间的哈密顿算符 $\\mathbf{H}_0 = \\mathbf{H}[n(0)]$ 将初始态 $\\Phi(0)$ 传播半个时间步 $\\Delta t/2$ 来完成的。我们使用酉指数传播子进行此预测：\n$$\n\\Phi_{pred}(\\Delta t/2) = \\exp(-\\mathrm{i} \\frac{\\Delta t}{2} \\mathbf{H}_0) \\Phi(0)\n$$\n根据这些预测的轨道，我们计算出预测的中点密度 $n_{pred}(\\Delta t/2) = \\sum_j |\\phi_{j,pred}(\\Delta t/2)|^2$。\n\n校正步：使用这个预测的密度，我们构建中点交换相关势 $v_{\\mathrm{xc,mid}} = v_{\\mathrm{xc}}(n_{pred}(\\Delta t/2))$ 以及相应的中点哈密顿算符 $\\mathbf{H}_{\\mathrm{mid}} = \\mathbf{T} + \\mathbf{V}_{\\mathrm{ext}} + \\mathrm{diag}(v_{\\mathrm{xc,mid}})$。现在，这个哈密顿算符在整个时间步 $[0, \\Delta t]$ 内被视为常数。\n\n使用固定的中点哈密顿算符 $\\mathbf{H}_{\\mathrm{mid}}$，我们采用两种不同的方法执行从 $t=0$ 到 $t=\\Delta t$ 的传播：\n\n1.  Crank-Nicolson (CN)：这种隐式方法基于传播子的二阶 Padé 近似 $\\exp(-z) \\approx (1-z/2)/(1+z/2)$。时间演化方程变成了一个关于新时刻 $\\Phi(\\Delta t)$ 状态的线性方程组：\n    $$\n    \\left(\\mathbf{I} + \\frac{\\mathrm{i}\\Delta t}{2} \\mathbf{H}_{\\mathrm{mid}}\\right) \\Phi_{\\mathrm{CN}}(\\Delta t) = \\left(\\mathbf{I} - \\frac{\\mathrm{i}\\Delta t}{2} \\mathbf{H}_{\\mathrm{mid}}\\right) \\Phi(0)\n    $$\n    我们对矩阵 $\\Phi_{\\mathrm{CN}}(\\Delta t)$ 中的每个轨道求解此方程组。虽然这种方法对于线性问题是无条件稳定的，但其传播子并非精确酉的，这可能导致轻微的范数偏差。\n\n2.  二阶 Magnus（指数中点）：此方法使用中点哈密顿算符的精确指数作为传播子。对于不含时的 $\\mathbf{H}_{\\mathrm{mid}}$，它是精确酉的：\n    $$\n    \\Phi_{\\mathrm{Mag}}(\\Delta t) = \\exp(-\\mathrm{i} \\Delta t \\mathbf{H}_{\\mathrm{mid}}) \\Phi(0)\n    $$\n    矩阵指数可以通过数值计算，例如，使用 `scipy.linalg.expm` 中实现的基于 Padé 近似的算法。\n\n用两种格式传播轨道后，我们得到 $\\Phi_{\\mathrm{CN}}(\\Delta t)$ 和 $\\Phi_{\\mathrm{Mag}}(\\Delta t)$。作为最后一步，我们对每种方法得到的占据轨道集分别进行重新正交归一化，以校正任何数值漂移并确保密度是从一个正交归一的集合计算出来的。从正交归一化的轨道中，我们计算最终密度 $n_{\\mathrm{CN}}(\\Delta t)$ 和 $n_{\\mathrm{Mag}}(\\Delta t)$。\n\n最终结果是两种密度之间差异的加权 $L^2$-范数，它量化了在给定参数集下两种传播格式之间的差异：\n$$\nD = \\left( \\sum_{\\ell=0}^{N-1} \\left( n_{\\mathrm{CN}}(x_\\ell) - n_{\\mathrm{Mag}}(x_\\ell) \\right)^2 \\Delta x \\right)^{1/2}\n$$\n对每个测试用例执行此过程，以生成所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm, solve as linsolve\n\ndef run_one_step(N, L, dt, omega, alpha, k, N_occ):\n    \"\"\"\n    Implements a one-step real-time TDDFT propagation using Crank-Nicolson\n    and Magnus propagators and computes the density difference.\n    \"\"\"\n    # 1. Grid and constants setup\n    dx = L / N\n    x = np.arange(N) * dx - L / 2\n    C = (3 / np.pi)**(1/3)\n\n    # 2. Kinetic energy operator matrix (T) from 2nd-order finite difference\n    diag_val = -2.0 / dx**2\n    off_diag_val = 1.0 / dx**2\n    \n    # Laplacian matrix (D2)\n    D2 = np.diag(np.full(N, diag_val)) + \\\n         np.diag(np.full(N - 1, off_diag_val), k=1) + \\\n         np.diag(np.full(N - 1, off_diag_val), k=-1)\n    \n    # Periodic boundary conditions\n    D2[0, N - 1] = off_diag_val\n    D2[N - 1, 0] = off_diag_val\n    \n    T = -0.5 * D2\n\n    # 3. Initial Kohn-Sham orbitals (at t = 0^-)\n    phi_mat_0_minus = np.zeros((N, N_occ), dtype=np.complex128)\n    \n    # Ground state of harmonic oscillator\n    phi0_analytic = (omega / np.pi)**(0.25) * np.exp(-0.5 * omega * x**2)\n    phi_mat_0_minus[:, 0] = phi0_analytic\n    \n    if N_occ == 2:\n        # First excited state of harmonic oscillator\n        phi1_analytic = np.sqrt(2 * omega) * x * phi0_analytic\n        phi_mat_0_minus[:, 1] = phi1_analytic\n        \n    # Orthonormalize initial orbitals on the grid using QR decomposition\n    \n```"
        },
        {
            "introduction": "在掌握了如何随时间传播系统之后，我们能如何利用得到的轨迹呢？本练习将展示，由一个微小的电场“脉冲”所诱导的系统偶极矩的时间演化，可通过傅里叶变换得到光学吸收光谱。这个过程将抽象的时间传播与可实验观测的物理量联系起来，并揭示了光谱学中时域与频域之间的深刻联系，同时也让您练习从数值光谱中提取峰位和强度的关键数据分析技术。",
            "id": "2932976",
            "problem": "给定一个简化的、完全指定的线性响应情景，旨在模拟实时含时密度泛函理论 (TDDFT) 模拟在受到一个微小脉冲电场（“delta 踢”）后如何产生吸收光谱，以及如何将该光谱与 Casida 方程的结果进行比较。你的任务是构建一个完整的程序，该程序针对一组预设的测试用例，从一个合成的时间域偶极矩轨迹中重构振子强度分布，并将恢复的峰位和强度与参考的 Casida 激发能和振子强度进行比较。最终输出必须将所有测试用例的误差指标汇总到单行中，具体格式如下文所述。\n\n推导和算法设计的基本依据：\n- 在线性响应中，一个弱的含时外场会感生一个偶极矩，该偶极矩由 Kubo 响应函数描述。频率依赖的极化率 $ \\alpha(\\omega) $ 表征了在频域中感生偶极矩与外场之间的比例关系。\n- 在含时密度泛函理论 (TDDFT) 的绝热近似下，Casida 方程会为给定方向（假设踢和偶极矩平行排列）产生一组离散的激发能 $ \\{\\omega_k\\} $ 和振子强度 $ \\{f_k\\} $。这些振子强度是无量纲的，并且在完备基组极限下满足 Thomas–Reiche–Kuhn 求和规则。\n- 在线性区域，吸收光谱与 $ \\omega \\,\\mathrm{Im}\\,\\alpha(\\omega) $ 成正比。一个标准的、经过充分检验的关系将振子强度分布与动态极化率联系起来，即 $ S(\\omega) = \\dfrac{2}{\\pi}\\,\\omega\\,\\mathrm{Im}\\,\\alpha(\\omega) $，其中 $ S(\\omega) $ 积分后得到总振子强度，并在理想的、无限时间、零阻尼极限下简化为 delta 峰的总和 $ \\sum_k f_k \\,\\delta(\\omega-\\omega_k) $。\n\n为了本问题的目的，假设以下建模选择在严格的线性区域内是有效的：\n- 在时间 $ t=0 $ 时的一个“delta 踢”产生了一个合成的含时偶极矩轨迹，建模为指数衰减正弦函数的有限和\n  $$ d(t) = \\sum_{k=1}^{K} \\frac{2 f_k}{\\omega_k}\\,\\sin(\\omega_k t)\\,e^{-\\eta t}, \\quad t \\ge 0, $$\n  其中 $ \\eta $ 是一个正的阻尼参数，用于模拟退相干并提供光谱展宽。所有量均使用原子单位：角频率 $ \\omega $ 的单位是 Hartree，时间 $ t $ 的单位是原子时间单位，$ \\eta $ 的单位是 Hartree。\n- 振子强度密度是通过对 $ \\alpha(\\omega) $ 进行单边离散傅里叶变换近似，从时间信号中重构得出的，\n  $$ \\alpha(\\omega) \\approx \\int_{0}^{T} d(t)\\,e^{i \\omega t}\\,dt, $$\n  接着是\n  $$ S(\\omega) = \\frac{2}{\\pi}\\,\\omega\\,\\mathrm{Im}\\,\\alpha(\\omega). $$\n  在数值计算中，$ T $ 是有限的，积分被替换为在均匀时间网格 $ t_n = n\\,\\Delta t $, $ n=0,\\dots,N-1 $ 上的黎曼和。\n\n程序要求：\n1. 输入是隐式的：直接在代码中实现下面列出的三个测试用例。不允许任何用户输入或文件 I/O。\n2. 对每个测试用例，执行以下所有操作：\n   - 使用提供的 $ \\Delta t $、$ N $、$ \\eta $、$ \\{\\omega_k\\} $ 和 $ \\{f_k\\} $ 在均匀网格上构建 $ d(t) $。\n   - 计算单边离散傅里叶变换近似，以在与该变换相关的非负角频率网格上恢复 $ \\alpha(\\omega) $。据此，通过 $ S(\\omega) = \\dfrac{2}{\\pi}\\,\\omega\\,\\mathrm{Im}\\,\\alpha(\\omega) $ 计算 $ S(\\omega) $。\n   - 仅使用 $ S(\\omega) $，为每个预设的参考峰 $ \\omega_k $ 提取以下信息：\n     a) 峰位估计值 $ \\widehat{\\omega}_k $，其计算方法是在围绕 $ \\omega_k $ 的一个不重叠区间上的谱质心。将区间边界定义为相邻参考 $ \\omega_k $ 值之间的中点，第一个区间的下界设为 $ \\omega_1 - 6\\eta $，最后一个区间的上界设为 $ \\omega_K + 6\\eta $。将任何小于 $ 0 $ 的边界截断为 $ 0 $。在计算 $ \\widehat{\\omega}_k $ 时，仅使用每个区间内的数据：\n     $$ \\widehat{\\omega}_k = \\frac{\\int_{\\mathrm{interval}_k} \\omega\\,S(\\omega)\\,d\\omega}{\\int_{\\mathrm{interval}_k} S(\\omega)\\,d\\omega}. $$\n     b) 峰强度估计值 $ \\widehat{f}_k $，其计算方法是 $ S(\\omega) $ 在相同区间下的面积：\n     $$ \\widehat{f}_k = \\int_{\\mathrm{interval}_k} S(\\omega)\\,d\\omega. $$\n   - 计算以下误差指标：\n     a) 测试中所有峰的最大绝对峰位误差：\n     $$ \\varepsilon_{\\omega}^{\\max} = \\max_k \\left| \\widehat{\\omega}_k - \\omega_k \\right|, $$\n     以 Hartree 为单位表示。\n     b) 峰强度误差按如下方式汇总。对于每个 $f_k > 0$ 的 $k$，定义一个相对误差\n     $$ \\varepsilon_{f,k}^{\\mathrm{rel}} = \\frac{\\left|\\widehat{f}_k - f_k\\right|}{f_k}. $$\n     对于任何 $f_k = 0$ 的 $k$，定义一个绝对面积误差\n     $$ \\varepsilon_{f,k}^{\\mathrm{abs0}} = \\left|\\widehat{f}_k\\right|. $$\n     将测试中单个最差情况的峰强度误差报告为\n     $$ \\varepsilon_{f}^{\\max} = \\max\\Big(\\{\\varepsilon_{f,k}^{\\mathrm{rel}}: f_k>0\\}\\cup\\{\\varepsilon_{f,k}^{\\mathrm{abs0}}: f_k=0\\}\\Big). $$\n3. 输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。具体来说，对于下面的三个测试，打印\n   $$ [\\varepsilon_{\\omega,1}^{\\max},\\varepsilon_{f,1}^{\\max},\\varepsilon_{\\omega,2}^{\\max},\\varepsilon_{f,2}^{\\max},\\varepsilon_{\\omega,3}^{\\max},\\varepsilon_{f,3}^{\\max}] $$\n   不含任何附加文本。$ \\varepsilon_{\\omega}^{\\max} $ 的单位是 Hartree，峰强度误差项是不带百分号的小数。\n\n测试套件（将这些硬编码到你的程序中）：\n- 测试 1（良好分离的谱线）：\n  - $ \\omega = [0.30,\\,0.55,\\,0.90] $ (Hartree),\n  - $ f = [0.20,\\,0.06,\\,0.12] $ (无量纲),\n  - $ \\eta = 0.006 $ (Hartree),\n  - $ \\Delta t = 0.2 $ (原子时间单位),\n  - $ N = 16384 $ (整数).\n- 测试 2（近简并双峰）：\n  - $ \\omega = [0.500,\\,0.515,\\,0.82] $ (Hartree),\n  - $ f = [0.10,\\,0.08,\\,0.02] $,\n  - $ \\eta = 0.004 $,\n  - $ \\Delta t = 0.2 $,\n  - $ N = 16384 $.\n- 测试 3（包含一个暗态）：\n  - $ \\omega = [0.40,\\,0.70,\\,0.95] $ (Hartree),\n  - $ f = [0.15,\\,0.00,\\,0.04] $,\n  - $ \\eta = 0.006 $,\n  - $ \\Delta t = 0.2 $,\n  - $ N = 16384 $.\n\n实现说明：\n- 所有计算均使用原子单位。明确以 Hartree 报告 $ \\varepsilon_{\\omega}^{\\max} $，并将峰强度误差值报告为小数（不带百分号）。\n- 在离散频率网格上使用梯形法则进行数值积分，以实现所有 $ \\omega $ 域积分。\n- 确保所有按所述方式构建的峰区间不重叠，并被截断到 $ \\omega \\ge 0 $。\n- 该算法必须对谱线重叠和有限时间窗口误差具有鲁棒性，测试套件探讨了一个典型情况、一个近简并情况以及一个暗态（禁戒）跃迁的存在。最终的数值输出必须是浮点数。",
            "solution": "所提出的问题是一个适定的计算任务，其原理基于线性响应机制下的含时密度泛函理论 (TDDFT)。它要求实现一个标准的工作流程：从一组已知的电子激发生成时域偶极信号，通过数值傅里叶变换获得吸收光谱，然后对该光谱进行分析以恢复原始的激发属性。该问题在科学上是合理的、内部一致且完整的。所有参数、模型和程序都得到了明确无误的指定。因此，该问题被视为有效，并将构建一个完整的解决方案。\n\n该算法旨在对每个测试用例遵循规定的操作序列。所有计算均以原子单位进行。\n\n首先，在离散时间网格上构建合成的含时偶极矩，记为 $d(t)$。问题指定了偶极矩对 $t=0$ 时刻 delta 函数电场脉冲的响应模型，该模型是 K 个电子跃迁的总和：\n$$\nd(t) = \\sum_{k=1}^{K} \\frac{2 f_k}{\\omega_k}\\,\\sin(\\omega_k t)\\,e^{-\\eta t}, \\quad t \\ge 0\n$$\n此处，$\\{\\omega_k\\}$ 是参考激发能，$\\{f_k\\}$ 是无量纲的振子强度，$\\eta$ 是一个唯象阻尼参数，它将谱线展宽为洛伦兹线型。时间网格是均匀的，由 $t_n = n\\,\\Delta t$ 定义，其中 $n = 0, 1, \\dots, N-1$，$ \\Delta t $ 是时间步长，$N$ 是总点数。对于给定的测试用例，信号 $d(t_n)$ 是通过对每个具有非零振子强度 $f_k > 0$ 的跃迁的贡献求和来计算的。\n\n其次，吸收光谱由频率依赖的极化率 $\\alpha(\\omega)$ 推导得出。问题定义了一个单边傅里叶变换，用于从时域信号近似计算 $\\alpha(\\omega)$：\n$$\n\\alpha(\\omega) \\approx \\int_{0}^{T} d(t)\\,e^{i \\omega t}\\,dt\n$$\n其中积分上限 $T$ 对应于总模拟时间 $T = N \\Delta t$。该积分使用离散傅里叶变换进行数值计算。具体来说，计算表达式 $\\sum_{n=0}^{N-1} d(t_n) e^{i \\omega_m t_n} \\Delta t$，其中离散频率为 $\\omega_m = 2\\pi m / (N \\Delta t)$。这个特定的和对应于离散傅里叶逆变换 (IDFT)，并按总时间长度 $N\\Delta t$ 进行了缩放。我们使用 `numpy.fft.ifft` 来计算 IDFT，然后执行缩放。该计算在离散频率网格上得到 $\\alpha(\\omega)$。我们只保留对应于非负频率 $\\omega \\ge 0$ 的分量。据此，使用给定的关系式计算振子强度密度 $S(\\omega)$：\n$$\nS(\\omega) = \\frac{2}{\\pi}\\,\\omega\\,\\mathrm{Im}\\,\\alpha(\\omega)\n$$\n\n第三，分析计算出的光谱 $S(\\omega)$ 以提取峰位估计值 $\\widehat{\\omega}_k$ 和峰强度估计值 $\\widehat{f}_k$。这需要将频率轴划分为一组 $K$ 个不重叠的区间，每个参考峰 $\\omega_k$ 对应一个区间。这些区间的边界定义为相邻参考频率之间的中点，即 $(\\omega_i + \\omega_{i+1})/2$。第一个区间的起始点为 $\\omega_1 - 6\\eta$，最后一个区间的结束点为 $\\omega_K + 6\\eta$。所有区间边界都被截断为非负值。在每个区间 $k$ 内，估计的峰位 $\\widehat{\\omega}_k$ 计算为谱质心，而估计的强度 $\\widehat{f}_k$ 是谱线下方的总面积：\n$$\n\\widehat{\\omega}_k = \\frac{\\int_{\\mathrm{interval}_k} \\omega\\,S(\\omega)\\,d\\omega}{\\int_{\\mathrm{interval}_k} S(\\omega)\\,d\\omega}, \\quad \\widehat{f}_k = \\int_{\\mathrm{interval}_k} S(\\omega)\\,d\\omega\n$$\n这些积分在离散频率网格上使用梯形法则进行数值计算，具体由 `scipy.integrate.trapezoid` 函数指定。\n\n最后，对每个测试用例，计算两个误差指标以量化恢复过程的准确性。最大绝对峰位误差 $\\varepsilon_{\\omega}^{\\max}$ 是估计峰位与其参考值之间的最大偏差：\n$$\n\\varepsilon_{\\omega}^{\\max} = \\max_k |\\widehat{\\omega}_k - \\omega_k|\n$$\n最大峰强度误差 $\\varepsilon_{f}^{\\max}$ 以混合方式定义，以处理亮态 ($f_k > 0$) 和暗态 ($f_k = 0$)。对于亮态，使用相对误差 $\\varepsilon_{f,k}^{\\mathrm{rel}} = |\\widehat{f}_k - f_k|/f_k$。对于暗态，使用绝对面积误差 $\\varepsilon_{f,k}^{\\mathrm{abs0}} = |\\widehat{f}_k|$。最终指标是所有这些单个误差中的最大值：\n$$\n\\varepsilon_{f}^{\\max} = \\max\\Big(\\{\\varepsilon_{f,k}^{\\mathrm{rel}}: f_k>0\\}\\cup\\{\\varepsilon_{f,k}^{\\mathrm{abs0}}: f_k=0\\}\\Big)\n$$\n程序处理所有 3 个测试用例，将每个测试用例的 2 个误差指标汇总到一个列表中，并以所需格式打印结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import trapezoid\n\ndef process_case(case_params):\n    \"\"\"\n    Processes a single test case to compute spectral reconstruction errors.\n\n    Args:\n        case_params (tuple): A tuple containing the parameters for the test case:\n            (ref_omegas, ref_fs, eta, delta_t, N).\n\n    Returns:\n        tuple: A tuple containing the two error metrics (eps_omega_max, eps_f_max).\n    \"\"\"\n    ref_omegas, ref_fs, eta, delta_t, N = case_params\n\n    # Step 1: Construct the time-dependent dipole moment d(t)\n    t = np.arange(N) * delta_t\n    d_t = np.zeros(N, dtype=np.float64)\n    for omega_k, f_k in zip(ref_omegas, ref_fs):\n        # The model formula involves 1/omega_k, so we only add terms for non-zero frequencies\n        if omega_k > 0 and f_k > 0:\n            d_t += (2.0 * f_k / omega_k) * np.sin(omega_k * t) * np.exp(-eta * t)\n\n    # Step 2: Compute the spectrum S(omega) via Fourier Transform\n    # The required transform is integral[d(t) * exp(i*omega*t)] dt.\n    # This corresponds to N * dt * ifft(d_t).\n    alpha_omega_full = N * delta_t * np.fft.ifft(d_t)\n    omega_grid_full = np.fft.fftfreq(N, delta_t) * 2.0 * np.pi\n\n    # For robustness, fftshift to get a monotonic frequency axis.\n    alpha_omega_shifted = np.fft.fftshift(alpha_omega_full)\n    omega_grid_shifted = np.fft.fftshift(omega_grid_full)\n    \n    # Keep only the non-negative frequency part of the spectrum.\n    zero_idx = np.searchsorted(omega_grid_shifted, 0.0)\n    omega_grid = omega_grid_shifted[zero_idx:]\n    alpha_omega_nonneg = alpha_omega_shifted[zero_idx:]\n\n    # Calculate the oscillator strength density S(omega)\n    S_omega = (2.0 / np.pi) * omega_grid * np.imag(alpha_omega_nonneg)\n\n    # Step 3: Analyze peaks by integrating over specified intervals\n    K = len(ref_omegas)\n    if K > 1:\n        midpoints = (ref_omegas[:-1] + ref_omegas[1:]) / 2.0\n        bounds = np.concatenate(\n            ([ref_omegas[0] - 6.0 * eta], midpoints, [ref_omegas[-1] + 6.0 * eta])\n        )\n    else: # Handle case with a single peak\n        bounds = np.array([ref_omegas[0] - 6.0 * eta, ref_omegas[0] + 6.0 * eta])\n        \n    bounds = np.maximum(0.0, bounds)\n\n    omega_hats = []\n    f_hats = []\n\n    for k in range(K):\n        w_min, w_max = bounds[k], bounds[k + 1]\n\n        # Find the slice of the frequency grid corresponding to the interval\n        start_idx = np.searchsorted(omega_grid, w_min, side='left')\n        end_idx = np.searchsorted(omega_grid, w_max, side='right')\n\n        # Ensure we have at least two points for trapezoidal rule\n        if end_idx > start_idx:\n            omega_sub = omega_grid[start_idx:end_idx]\n            S_sub = S_omega[start_idx:end_idx]\n\n            # Numerically integrate using the trapezoidal rule\n            area = trapezoid(S_sub, omega_sub)\n            centroid_numerator = trapezoid(omega_sub * S_sub, omega_sub)\n            \n            f_hat = area\n            if np.abs(area)  1e-15:\n                # Avoid division by zero for dark states or empty intervals\n                omega_hat = (w_min + w_max) / 2.0\n            else:\n                omega_hat = centroid_numerator / area\n        else: # Interval contains less than 2 points\n            omega_hat = (w_min + w_max) / 2.0\n            f_hat = 0.0\n\n        omega_hats.append(omega_hat)\n        f_hats.append(f_hat)\n\n    omega_hats = np.array(omega_hats)\n    f_hats = np.array(f_hats)\n\n    # Step 4: Compute error metrics\n    eps_omega_max = np.max(np.abs(omega_hats - ref_omegas))\n    \n    f_errors = []\n    for k in range(K):\n        if ref_fs[k] > 0:\n            error = np.abs(f_hats[k] - ref_fs[k]) / ref_fs[k]\n        else:  # For dark states (f_k = 0)\n            error = np.abs(f_hats[k])\n        f_errors.append(error)\n    \n    eps_f_max = np.max(f_errors)\n    \n    return eps_omega_max, eps_f_max\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (well-separated lines)\n        (np.array([0.30, 0.55, 0.90]), np.array([0.20, 0.06, 0.12]), 0.006, 0.2, 16384),\n        # Test 2 (near-degenerate doublet)\n        (np.array([0.500, 0.515, 0.82]), np.array([0.10, 0.08, 0.02]), 0.004, 0.2, 16384),\n        # Test 3 (includes a dark state)\n        (np.array([0.40, 0.70, 0.95]), np.array([0.15, 0.00, 0.04]), 0.006, 0.2, 16384),\n    ]\n\n    results = []\n    for case in test_cases:\n        # To ensure robustness, sort peaks by frequency for interval calculation logic\n        omegas, fs, eta, dt, N = case\n        sort_indices = np.argsort(omegas)\n        sorted_case = (omegas[sort_indices], fs[sort_indices], eta, dt, N)\n        \n        eps_omega_max, eps_f_max = process_case(sorted_case)\n        results.append(eps_omega_max)\n        results.append(eps_f_max)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在学会执行和解读TD-DFT计算后，理解该方法的局限性是至关重要的。本练习将引导您推导并展示标准TD-DFT近似最著名的失效案例之一：对电荷转移激发能的错误预测。通过一个简化的模型，您将从第一性原理的层面深刻理解为何标准（半局域）泛函会遗漏长程库仑相互作用的关键项 $ -1/R $，以及为何必须使用更高级的泛函来准确描述这类体系。",
            "id": "2466214",
            "problem": "要求您编写一个完整、可运行的程序，该程序在一个最小但有科学依据的模型中，演示含时密度泛函理论 (TD-DFT) 如何在使用标准广义梯度近似 (GGA) 泛函时，会错误地预测空间分离的给体-受体对中虚假的低能量电荷转移激发。您的程序必须从第一性原理出发，实现以下逻辑。\n\n从密度泛函理论 (DFT) 中电离势和电子亲和能的基本定义，以及分离电荷的静电相互作用出发。使用这些原理推导在远距离下最低的给体到受体电荷转移激发能的表达式。然后，利用线性响应 TD-DFT 以及对于空间无重叠轨道，绝热半局域 Hartree-交换-相关核的耦合项趋于零这一事实，推导由半局域 GGA 泛函做出的相应预测。最后，通过引入导数不连续性，将 Kohn–Sham 轨道能量差与基本能隙联系起来。在推导过程中，请勿使用或引用任何已有的简化公式；相反，仅根据以下基本依据进行推理：\n- 基本定义：通过总能量差定义的电离势 $I$ 和电子亲和能 $A$，以及相距为 $R$ 的两个单位电荷的静电相互作用能。\n- 线性响应理论核心思想：激发能源于一个由非相互作用跃迁能和耦合项决定的响应极点，并且对于轨道重叠可忽略的空间分离片段之间的电荷转移，局域和绝热的核函数提供的长程耦合可忽略不计。\n- 经过充分检验的概念性事实：多体基本能隙通过导数不连续性与 Kohn–Sham 能隙相关联。\n\n为每个测试用例实现一个最小的双片段模型，参数如下：\n- 给体电离势 $I_D$ (单位 Hartree)。\n- 受体电子亲和能 $A_A$ (单位 Hartree)。\n- 中心间距 $R$ (单位 bohr)。\n- 一个有效的正值导数不连续性参数 $\\Delta_{\\mathrm{xc}}$ (单位 Hartree)，用于捕捉半局域 GGA 泛函所特有的能隙低估特征。\n\n对于每个测试用例，计算：\n1. 基于上述原理的、有物理动机的远距离电荷转移激发能，以 Hartree 为单位表示，此处记为 $E_{\\mathrm{true}}$。\n2. 绝热半局域 GGA TD-DFT 对相同电荷转移激发的预测值，以 Hartree 为单位表示，此处记为 $E_{\\mathrm{GGA}}$。\n3. 符号误差 $\\Delta E = E_{\\mathrm{GGA}} - E_{\\mathrm{true}}$ (单位 Hartree)。\n4. 一个布尔标志，当且仅当 GGA 预测值虚假地偏低时为真，定义为严格不等式 $E_{\\mathrm{GGA}}  E_{\\mathrm{true}}$。\n\n您的程序必须使用以下固定的参数元组 $(I_D,A_A,R,\\Delta_{\\mathrm{xc}})$ 测试套件，单位为原子单位 (能量为 Hartree，距离为 bohr)：\n- 测试 1 (一般分离对)：$(0.30, 0.08, 30.0, 0.12)$。\n- 测试 2 (极大分离距离)：$(0.30, 0.08, 200.0, 0.12)$。\n- 测试 3 (小基本能隙导致接近于零的 GGA 激发)：$(0.20, 0.08, 25.0, 0.12)$。\n- 测试 4 (数值平衡点，即低估值在此 $R$ 处等于缺失的静电项)：$(0.25, 0.05, 8.\\overline{3}, 0.12)$，其中 $8.\\overline{3}$ 表示 $25/3$ bohr。\n\n所有能量必须以 Hartree 为单位表示，并四舍五入到六位小数。对于每个测试用例，您的程序必须按顺序输出 $E_{\\mathrm{true}}$、$E_{\\mathrm{GGA}}$、$\\Delta E$ 和布尔标志这四个值。将所有测试用例的结果汇总到一个扁平列表中。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表 (例如：\"[result1,result2,result3,...]\")。\n\n不涉及角度单位。不允许外部输入；程序必须完全自包含，并在执行时产生所需的单行输出。",
            "solution": "问题陈述具有科学依据、提法明确，并包含了推导唯一解所需的所有信息。它描述了常见密度泛函近似的一种众所周知的失效模式。因此，该问题被认为是有效的，并将基于所提供的第一性原理构建解决方案。\n\n我们首先推导在远距离下物理上正确的电荷转移 ($CT$) 激发能的表达式，记为 $E_{\\mathrm{true}}$。一个 $CT$ 激发过程涉及将一个电子从给体分子 $D$ 移动到受体分子 $A$，两者相距为 $R$。这个过程可以表示为 $D^0A^0 \\rightarrow D^+A^-$。此激发的能量 $\\omega_{CT}$ 是最终态和初始态总能量之差：\n$$ \\omega_{CT} = E(D^+A^-) - E(D^0A^0) $$\n在远距离 $R$ 的极限下，组合系统的能量可以近似为其非相互作用组分片段的能量之和，再加上它们的经典静电相互作用能。对于初始中性态，其能量为：\n$$ E(D^0A^0) \\approx E(D^0) + E(A^0) $$\n对于最终的离子态，其能量包括新形成的离子之间的静电吸引能：\n$$ E(D^+A^-) \\approx E(D^+) + E(A^-) + E_{\\mathrm{int}} $$\n此处，$E(X)$ 代表物种 $X$ 的总能量。$D^+$ 上的 $+1e$ 点电荷与 $A^-$ 上的 $-1e$ 点电荷之间的相互作用能 $E_{\\mathrm{int}}$ 由库仑定律给出。在原子单位制中，能量单位为 Hartree，距离单位为 bohr，该能量为：\n$$ E_{\\mathrm{int}} = -\\frac{1}{R} $$\n将这些表达式代入 $\\omega_{CT}$ 的方程，我们得到：\n$$ \\omega_{CT} \\approx \\left( E(D^+) + E(A^-) - \\frac{1}{R} \\right) - \\left( E(D^0) + E(A^0) \\right) $$\n重新整理各项，按物种分组可得：\n$$ \\omega_{CT} \\approx \\left( E(D^+) - E(D^0) \\right) + \\left( E(A^-) - E(A^0) \\right) - \\frac{1}{R} $$\n括号中的各项对应于基本定义。给体的电离势 $I_D$ 是移除一个电子所需的能量：\n$$ I_D = E(D^+) - E(D^0) $$\n受体的电子亲和能 $A_A$ 是捕获一个电子时释放的能量，定义为：\n$$ A_A = E(A^0) - E(A^-) $$\n根据该定义，可以得出 $E(A^-) - E(A^0) = -A_A$。通过代入 $I_D$ 和 $A_A$ 的这些定义，我们得到真实的远距离电荷转移激发能的表达式：\n$$ E_{\\mathrm{true}} = I_D - A_A - \\frac{1}{R} $$\n\n接下来，我们推导绝热半局域含时密度泛函理论 ($TD-DFT$) 的相应预测值，记为 $E_{\\mathrm{GGA}}$。在线性响应 $TD-DFT$ 框架内，激发能 $\\omega$ 是通过一个矩阵方程的本征值得到的。对于从一个占据的 Kohn-Sham ($KS$) 轨道 $\\phi_i$ 到一个未占据的 $KS$ 轨道 $\\phi_a$ 的单重激发，在绝热近似下的激发能由下式给出：\n$$ \\omega_{ia} = \\varepsilon_a - \\varepsilon_i + K_{ia,ia} $$\n其中 $\\varepsilon_i$ 和 $\\varepsilon_a$ 是 $KS$ 轨道的能量，而 $K_{ia,ia}$ 是耦合矩阵元。该矩阵元依赖于 Hartree-交换-相关 ($HXC$) 核 $f_{HXC}$：\n$$ K_{ia,ia} = \\iint \\phi_i^*(\\mathbf{r})\\phi_a(\\mathbf{r}) f_{HXC}(\\mathbf{r}, \\mathbf{r}') \\phi_a^*(\\mathbf{r}')\\phi_i(\\mathbf{r}') d\\mathbf{r} d\\mathbf{r}' $$\n对于我们所考虑的 $CT$ 激发，占据轨道 $\\phi_i$ 是给体的最高占据分子轨道 ($HOMO_D$)，未占据轨道 $\\phi_a$ 是受体的最低未占据分子轨道 ($LUMO_A$)。在远距离 $R$ 处，这些轨道在空间上是孤立的，它们的重叠乘积 $\\phi_i(\\mathbf{r})\\phi_a(\\mathbf{r})$ 对于所有 $\\mathbf{r}$ 都可以忽略不计。\n对于一个半局域泛函，例如广义梯度近似 ($GGA$)，其核函数 $f_{HXC}^{GGA}(\\mathbf{r}, \\mathbf{r}')$ 实际上是局域的，这意味着它随着距离 $|\\mathbf{r} - \\mathbf{r}'|$ 的增加而迅速衰减为零。局域核与消失的轨道重叠相结合，导致耦合积分 $K_{ia,ia}$ 变为零：\n$$ K_{ia,ia}^{GGA} \\approx 0 $$\n因此，$TD-GGA$ 激发能虚假地简化为所涉及的 $KS$ 轨道的能量差：\n$$ E_{\\mathrm{GGA}} = \\omega_{CT}^{GGA} \\approx \\varepsilon_{LUMO,A} - \\varepsilon_{HOMO,D} $$\n为了使这个表达式有用，我们必须将这个 $KS$ 轨道能隙与物理量 $I_D$ 和 $A_A$ 联系起来。组合的 $D-A$ 系统的基本多体能隙是 $E_{gap} = I_D - A_A$。相应的 $KS$ 能隙是 $\\varepsilon_{gap}^{KS} = \\varepsilon_{LUMO,A} - \\varepsilon_{HOMO,D}$。对于一个精确的泛函，这些量通过交换相关势的导数不连续性 $\\Delta_{xc}$ 相关联：\n$$ E_{gap} = \\varepsilon_{gap}^{KS} + \\Delta_{xc} \\implies I_D - A_A = (\\varepsilon_{LUMO,A} - \\varepsilon_{HOMO,D}) + \\Delta_{xc} $$\n像 $GGA$ 这样的近似泛函，众所周知存在一个系统性误差，该误差实际上对应于一个缺失的导数不连续性。该问题提供了一个有效参数 $\\Delta_{\\mathrm{xc}}  0$ 来模拟这一缺陷。在 $GGA$ 框架下，重新整理 $KS$ 能隙的方程可得：\n$$ \\varepsilon_{LUMO,A}^{GGA} - \\varepsilon_{HOMO,D}^{GGA} = (I_D - A_A) - \\Delta_{\\mathrm{xc}} $$\n这就给出了 $TD-GGA$ 电荷转移激发能的最终表达式：\n$$ E_{\\mathrm{GGA}} = I_D - A_A - \\Delta_{\\mathrm{xc}} $$\n这个结果错误地显示激发能在 $R$ 很大时趋于一个常数值，完全没有体现正确的 $-1/R$ 渐进行为。\n\n最后，我们计算符号误差 $\\Delta E$ 并建立虚假低预测值的条件。误差是 $GGA$ 值与真实值之间的差值：\n$$ \\Delta E = E_{\\mathrm{GGA}} - E_{\\mathrm{true}} = (I_D - A_A - \\Delta_{\\mathrm{xc}}) - \\left(I_D - A_A - \\frac{1}{R}\\right) $$\n$$ \\Delta E = \\frac{1}{R} - \\Delta_{\\mathrm{xc}} $$\n$GGA$ 预测值是虚假地偏低当且仅当 $E_{\\mathrm{GGA}}  E_{\\mathrm{true}}$，这意味着 $\\Delta E  0$。这给出了条件：\n$$ \\frac{1}{R} - \\Delta_{\\mathrm{xc}}  0 \\implies \\frac{1}{R}  \\Delta_{\\mathrm{xc}} $$\n随着间距 $R$ 的增加，$1/R$ 减小。对于任何存在非零能隙低估误差 ($\\Delta_{\\mathrm{xc}} > 0$) 的系统，都存在一个间距，超过该间距后上述不等式便成立，这证明了绝热半局域泛函在描述长程电荷转移方面的根本性失败。下面的程序实现了这些推导出的公式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the true and TD-GGA charge-transfer excitation energies for a\n    series of donor-acceptor pairs to demonstrate the failure of semilocal DFT.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple is (I_D, A_A, R, delta_xc) in atomic units.\n    test_cases = [\n        # Test 1: General separated pair\n        (0.30, 0.08, 30.0, 0.12),\n        # Test 2: Very large separation\n        (0.30, 0.08, 200.0, 0.12),\n        # Test 3: Small fundamental gap\n        (0.20, 0.08, 25.0, 0.12),\n        # Test 4: Numerical balance point\n        (0.25, 0.05, 25.0/3.0, 0.12),\n    ]\n\n    results = []\n    for case in test_cases:\n        I_D, A_A, R, delta_xc = case\n        \n        # 1. Calculate the physically motivated charge-transfer energy, E_true.\n        # This is derived from E_true = I_D - A_A - 1/R.\n        E_true = I_D - A_A - 1.0/R\n        \n        # 2. Calculate the adiabatic semilocal GGA TD-DFT prediction, E_GGA.\n        # This is derived from E_GGA = I_D - A_A - delta_xc.\n        E_gga = I_D - A_A - delta_xc\n        \n        # 3. Calculate the signed error, delta_E.\n        # This is delta_E = E_GGA - E_true, which simplifies to 1/R - delta_xc.\n        delta_E = 1.0/R - delta_xc\n\n        # 4. Determine if the GGA prediction is spuriously low.\n        # This is true if E_GGA  E_true.\n        is_spurious = E_gga  E_true\n\n        # Append the four required results for this test case.\n        # Energies are rounded to six decimal places.\n        results.append(np.round(E_true, 6))\n        results.append(np.round(E_gga, 6))\n        results.append(np.round(delta_E, 6))\n        results.append(is_spurious)\n        \n    # Final print statement in the exact required format.\n    # The boolean `True`/`False` is converted to string \"True\"/\"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}