{
    "hands_on_practices": [
        {
            "introduction": "Understanding how to quantify finite deformation is the first step in continuum mechanics. This practice grounds the abstract definitions of kinematic tensors in a simple, intuitive physical scenario: uniaxial stretching. By deriving the deformation gradient $\\mathbf{F}$, the right Cauchy–Green tensor $\\mathbf{C}$, and the Green–Lagrange strain tensor $\\mathbf{E}$ for this fundamental case, you will build the essential mathematical vocabulary needed to describe any complex material motion .",
            "id": "3798588",
            "problem": "A homogeneous deformation mapping in three dimensions describes a uniaxial stretch along the material basis direction $\\mathbf{e}_{1}$ by a stretch ratio $\\lambda>0$, while leaving the transverse directions unchanged. Let the reference position be $\\mathbf{X}=X_{1}\\mathbf{e}_{1}+X_{2}\\mathbf{e}_{2}+X_{3}\\mathbf{e}_{3}$ and the motion be defined by $\\boldsymbol{\\varphi}:\\mathbf{X}\\mapsto \\mathbf{x}$ with $\\mathbf{x}=\\boldsymbol{\\varphi}(\\mathbf{X})=\\lambda X_{1}\\mathbf{e}_{1}+X_{2}\\mathbf{e}_{2}+X_{3}\\mathbf{e}_{3}$.\n\nStarting from the fundamental definitions in finite deformation kinematics, construct the deformation gradient $\\mathbf{F}$ associated with this mapping and, from it, derive the Right Cauchy–Green deformation tensor $\\mathbf{C}$, the Green–Lagrange strain tensor $\\mathbf{E}$, and the Jacobian determinant $J$.\n\nReport your final answer as a single row matrix containing, in this order, the diagonal components of $\\mathbf{C}$, the diagonal components of $\\mathbf{E}$, and $J$, that is,\n$\\left(C_{11},\\,C_{22},\\,C_{33},\\,E_{11},\\,E_{22},\\,E_{33},\\,J\\right)$.\n\nNo numerical rounding is required; leave your answer in exact symbolic form in terms of $\\lambda$.",
            "solution": "The deformation mapping is given by $\\mathbf{x}=\\boldsymbol{\\varphi}(\\mathbf{X})=\\lambda X_{1}\\mathbf{e}_{1}+X_{2}\\mathbf{e}_{2}+X_{3}\\mathbf{e}_{3}$. The deformation gradient $\\mathbf{F}$ is defined as the material gradient of the motion,\n$$\n\\mathbf{F}=\\nabla_{\\! \\mathbf{X}}\\boldsymbol{\\varphi}(\\mathbf{X}) \\, ,\n$$\nwith components $F_{iJ}=\\partial x_{i}/\\partial X_{J}$ in a fixed orthonormal basis $\\{\\mathbf{e}_{1},\\mathbf{e}_{2},\\mathbf{e}_{3}\\}$. From the mapping components $x_{1}=\\lambda X_{1}$, $x_{2}=X_{2}$, $x_{3}=X_{3}$, we compute\n$$\n\\frac{\\partial x_{1}}{\\partial X_{1}}=\\lambda,\\quad \\frac{\\partial x_{2}}{\\partial X_{2}}=1,\\quad \\frac{\\partial x_{3}}{\\partial X_{3}}=1,\n$$\nand all mixed partial derivatives vanish. Therefore,\n$$\n\\mathbf{F}=\\mathrm{diag}\\!\\left(\\lambda,\\,1,\\,1\\right).\n$$\n\nThe Right Cauchy–Green deformation tensor is defined by\n$$\n\\mathbf{C}=\\mathbf{F}^\\top\\mathbf{F}.\n$$\nFor a diagonal $\\mathbf{F}$, we have $\\mathbf{F}^\\top=\\mathbf{F}$ and the product is diagonal with squared entries:\n$$\n\\mathbf{C}=\\mathrm{diag}\\!\\left(\\lambda^{2},\\,1,\\,1\\right).\n$$\n\nThe Green–Lagrange strain tensor is defined as\n$$\n\\mathbf{E}=\\frac{1}{2}\\left(\\mathbf{C}-\\mathbf{I}\\right),\n$$\nwhere $\\mathbf{I}$ is the identity tensor. Substituting the $\\mathbf{C}$ just obtained,\n$$\n\\mathbf{E}=\\frac{1}{2}\\,\\mathrm{diag}\\!\\left(\\lambda^{2}-1,\\,0,\\,0\\right)=\\mathrm{diag}\\!\\left(\\frac{\\lambda^{2}-1}{2},\\,0,\\,0\\right).\n$$\n\nThe Jacobian determinant is the determinant of the deformation gradient,\n$$\nJ=\\det\\mathbf{F}.\n$$\nFor a diagonal matrix, the determinant is the product of the diagonal entries. Hence,\n$$\nJ=\\lambda\\cdot 1\\cdot 1=\\lambda.\n$$\n\nCollecting the requested quantities in the specified order, the diagonal components are $C_{11}=\\lambda^{2}$, $C_{22}=1$, $C_{33}=1$, $E_{11}=(\\lambda^{2}-1)/2$, $E_{22}=0$, $E_{33}=0$, and the Jacobian is $J=\\lambda$.",
            "answer": "$$\\boxed{\\begin{pmatrix}\\lambda^{2} & 1 & 1 & \\frac{\\lambda^{2}-1}{2} & 0 & 0 & \\lambda\\end{pmatrix}}$$"
        },
        {
            "introduction": "A correct description of deformation is necessary but not sufficient for building predictive material models; physical laws must also be independent of the observer's reference frame. This exercise provides a powerful hands-on demonstration of the principle of material objectivity by asking you to quantify the failure of a physically naive constitutive law under a rigid body rotation. By working through this counterexample, you will gain a tangible appreciation for why material response must be formulated in terms of objective tensors like $\\mathbf{C}$ or $\\mathbf{B}$, not the deformation gradient $\\mathbf{F}$ directly .",
            "id": "3798635",
            "problem": "In multiscale materials simulation, a common pitfall arises when proposing phenomenological constitutive mappings that depend explicitly on the deformation gradient $\\mathbf{F}$ rather than on the right Cauchy–Green tensor $\\mathbf{C} = \\mathbf{F}^{\\top}\\mathbf{F}$ or the left Cauchy–Green tensor $\\mathbf{B} = \\mathbf{F}\\mathbf{F}^{\\top}$. Starting from the principle of material objectivity (frame indifference), any constitutive law for the Cauchy stress $\\boldsymbol{\\sigma}$ must be invariant under a superposed rigid body motion. Specifically, if a motion is augmented by a time-dependent proper orthogonal rotation $\\mathbf{Q}(t)$, the deformation gradient transforms as $\\mathbf{F} \\mapsto \\mathbf{Q}\\mathbf{F}$ and the Cauchy stress must transform according to $\\boldsymbol{\\sigma}(\\mathbf{Q}\\mathbf{F}) = \\mathbf{Q}\\,\\boldsymbol{\\sigma}(\\mathbf{F})\\,\\mathbf{Q}^{\\top}$.\n\nConsider the following counterexample mapping intended to represent a naive micro-to-macro closure that aligns the Cauchy stress directly with the deformation gradient:\n$$\n\\boldsymbol{\\sigma}(\\mathbf{F}) = k\\,\\mathbf{F},\n$$\nwhere $k$ is a constant with units of Pascals. Define the violation residual under a superposed rigid rotation $\\mathbf{Q}$ as\n$$\n\\mathbf{D}(\\mathbf{Q},\\mathbf{F}) := \\boldsymbol{\\sigma}(\\mathbf{Q}\\mathbf{F}) - \\mathbf{Q}\\,\\boldsymbol{\\sigma}(\\mathbf{F})\\,\\mathbf{Q}^{\\top}.\n$$\n\nUsing the deformation gradient\n$$\n\\mathbf{F} = \\mathrm{diag}(2,\\,1,\\,1),\n$$\nand the proper orthogonal rotation about the $z$-axis by angle $\\theta = \\pi/2$,\n$$\n\\mathbf{Q} = \\begin{pmatrix}\n\\cos\\theta & -\\sin\\theta & 0 \\\\\n\\sin\\theta & \\cos\\theta & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix},\n$$\nwith $k = 1\\,\\mathrm{Pa}$, compute the Frobenius norm of the violation residual $\\|\\mathbf{D}(\\mathbf{Q},\\mathbf{F})\\|_{F}$. Express your final answer in Pascals. No rounding is required; report the exact value.",
            "solution": "The goal is to test the proposed constitutive law $\\boldsymbol{\\sigma}(\\mathbf{F}) = k\\,\\mathbf{F}$ against the principle of material objectivity. This principle requires that the Cauchy stress transforms as $\\boldsymbol{\\sigma}(\\mathbf{Q}\\mathbf{F}) = \\mathbf{Q}\\,\\boldsymbol{\\sigma}(\\mathbf{F})\\,\\mathbf{Q}^\\top$ under a superposed rigid rotation $\\mathbf{Q}$. We will compute the violation residual $\\mathbf{D}(\\mathbf{Q},\\mathbf{F}) = \\boldsymbol{\\sigma}(\\mathbf{Q}\\mathbf{F}) - \\mathbf{Q}\\,\\boldsymbol{\\sigma}(\\mathbf{F})\\,\\mathbf{Q}^\\top$ and its Frobenius norm.\n\nFirst, we establish the given matrices with $k=1\\,\\mathrm{Pa}$ and $\\theta=\\pi/2$:\nThe deformation gradient is:\n$$\n\\mathbf{F} = \\begin{pmatrix} 2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nThe rotation matrix is:\n$$\n\\mathbf{Q} = \\begin{pmatrix} \\cos(\\pi/2) & -\\sin(\\pi/2) & 0 \\\\ \\sin(\\pi/2) & \\cos(\\pi/2) & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 0 & -1 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n\nNext, we compute the first term of the residual, $\\boldsymbol{\\sigma}(\\mathbf{Q}\\mathbf{F})$. We begin with the product $\\mathbf{Q}\\mathbf{F}$:\n$$\n\\mathbf{Q}\\mathbf{F} = \\begin{pmatrix} 0 & -1 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 0 & -1 & 0 \\\\ 2 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nApplying the constitutive law with $k=1\\,\\mathrm{Pa}$:\n$$\n\\boldsymbol{\\sigma}(\\mathbf{Q}\\mathbf{F}) = k\\,(\\mathbf{Q}\\mathbf{F}) = 1 \\cdot \\begin{pmatrix} 0 & -1 & 0 \\\\ 2 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 0 & -1 & 0 \\\\ 2 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n\nThen, we compute the second term, $\\mathbf{Q}\\,\\boldsymbol{\\sigma}(\\mathbf{F})\\,\\mathbf{Q}^\\top$. First, we find $\\boldsymbol{\\sigma}(\\mathbf{F})$:\n$$\n\\boldsymbol{\\sigma}(\\mathbf{F}) = k\\,\\mathbf{F} = 1 \\cdot \\begin{pmatrix} 2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\nNow, we perform the frame transformation on this stress:\n$$\n\\mathbf{Q}\\,\\boldsymbol{\\sigma}(\\mathbf{F})\\,\\mathbf{Q}^\\top = \\begin{pmatrix} 0 & -1 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 2 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0 & 1 & 0 \\\\ -1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} 0 & -1 & 0 \\\\ 2 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 0 & 1 & 0 \\\\ -1 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 2 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}\n$$\n\nNow, we compute the violation residual tensor $\\mathbf{D}$ by subtracting the two terms:\n$$\n\\mathbf{D} = \\boldsymbol{\\sigma}(\\mathbf{Q}\\mathbf{F}) - \\mathbf{Q}\\,\\boldsymbol{\\sigma}(\\mathbf{F})\\,\\mathbf{Q}^\\top = \\begin{pmatrix} 0 & -1 & 0 \\\\ 2 & 0 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} - \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 2 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} = \\begin{pmatrix} -1 & -1 & 0 \\\\ 2 & -2 & 0 \\\\ 0 & 0 & 0 \\end{pmatrix}\n$$\n\nFinally, we compute the Frobenius norm of $\\mathbf{D}$, defined as $\\|\\mathbf{D}\\|_{F} = \\sqrt{\\sum_{i,j} D_{ij}^2}$:\n$$\n\\|\\mathbf{D}\\|_{F}^2 = (-1)^2 + (-1)^2 + 0^2 + 2^2 + (-2)^2 + 0^2 + 0^2 + 0^2 + 0^2\n$$\n$$\n\\|\\mathbf{D}\\|_{F}^2 = 1 + 1 + 4 + 4 = 10\n$$\n$$\n\\|\\mathbf{D}\\|_{F} = \\sqrt{10}\n$$\nSince $k$ had units of Pascals, the final result is $\\sqrt{10}\\,\\mathrm{Pa}$.",
            "answer": "$$\n\\boxed{\\sqrt{10}}\n$$"
        },
        {
            "introduction": "In materials simulation, we often track how deformations evolve over time, which requires integrating the kinematic rate equation $\\dot{\\mathbf{F}}=\\mathbf{L}(t)\\mathbf{F}$. This computational practice challenges you to implement and compare different numerical schemes, moving from theory to the practical art of building a simulation tool. By analyzing the performance of a simple explicit integrator against a more robust structure-preserving method, you will confront key issues in numerical accuracy and stability that are paramount in simulations involving large rotations and deformations .",
            "id": "3798581",
            "problem": "You are given the rate equation of the deformation gradient in continuum kinematics, which arises from the motion mapping of a deforming body in multiscale materials simulation. Let $\\boldsymbol{\\varphi}(\\mathbf{X},t)$ denote the motion mapping from the reference configuration to the current configuration, where $\\mathbf{x}=\\boldsymbol{\\varphi}(\\mathbf{X},t)$. The deformation gradient is defined as $\\mathbf{F}(\\mathbf{X},t)=\\partial \\mathbf{x}/\\partial \\mathbf{X}$, and the spatial velocity is $\\mathbf{v}(\\mathbf{x},t)=\\partial \\boldsymbol{\\varphi}/\\partial t$. The spatial velocity gradient is $\\mathbf{L}(\\mathbf{x},t)=\\nabla \\mathbf{v}(\\mathbf{x},t)$. Under the usual smoothness assumptions, the transport of $\\mathbf{F}$ satisfies the ordinary differential equation (ODE) $\\dot{\\mathbf{F}}=\\mathbf{L}(t)\\mathbf{F}$ along material trajectories.\n\nYour task is to develop a program that numerically integrates the matrix ODE $\\dot{\\mathbf{F}}=\\mathbf{L}(t)\\mathbf{F}$ for specified time-dependent and time-independent $\\mathbf{L}(t)$, and computes well-defined accuracy and structure-preservation metrics. You must implement two distinct time-stepping schemes:\n- A first-order explicit scheme based on a forward time discretization at $t_k$.\n- A second-order structure-preserving scheme that uses the matrix exponential evaluated at the midpoint $t_{k+\\frac{1}{2}}$.\n\nYou may use a standard matrix exponential routine for the second-order scheme. You must derive your implementation from core definitions and properties of $\\mathbf{F}$ and $\\mathbf{L}$, without assuming any shortcut formulas not implied by those definitions.\n\nAngles must be treated in radians, and time in seconds. All physical quantities in the test suite below use these units.\n\nDefine the skew-symmetric matrix $\\mathbf{W}(\\boldsymbol{\\omega})$ associated with an angular velocity vector $\\boldsymbol{\\omega}=[\\omega_x,\\omega_y,\\omega_z]^T$ by\n$$\n\\mathbf{W}(\\boldsymbol{\\omega})=\\begin{bmatrix}\n0 & -\\omega_z & \\omega_y \\\\\n\\omega_z & 0 & -\\omega_x \\\\\n-\\omega_y & \\omega_x & 0\n\\end{bmatrix}.\n$$\n\nImplement the following three test cases with the initial condition $\\mathbf{F}(0)=\\mathbf{I}$, where $\\mathbf{I}$ is the identity matrix. In all cases, use a uniform time step $\\Delta t=T/N$.\n\n- Test Case $1$ (pure large rotation, time-independent): Let $\\boldsymbol{\\omega}(t)=[0,0,\\omega]^T$ with $\\omega$ constant. Set $\\omega=200\\,\\text{rad/s}$, $T=0.05\\,\\text{s}$, and $N=200$. Define $\\mathbf{L}(t)=\\mathbf{W}(\\boldsymbol{\\omega})$. Compute the final deformation gradient $\\mathbf{F}(T)$ by both schemes. For a time-independent $\\mathbf{L}$, the exact solution is $\\mathbf{F}_{\\text{exact}}(T)=\\exp(T\\mathbf{L})$. For this test, compute the Frobenius norm errors $e_{\\mathrm{E}}=\\lVert \\mathbf{F}_{\\mathrm{E}}(T)-\\mathbf{F}_{\\text{exact}}(T)\\rVert_F$ and $e_{\\mathrm{M}}=\\lVert \\mathbf{F}_{\\mathrm{M}}(T)-\\mathbf{F}_{\\text{exact}}(T)\\rVert_F$, where $\\mathbf{F}_{\\mathrm{E}}$ and $\\mathbf{F}_{\\mathrm{M}}$ denote the forward explicit and exponential-midpoint solutions, respectively.\n\n- Test Case $2$ (combined rotation and stretch, time-independent): Let $\\boldsymbol{\\omega}(t)=[0,0,\\omega]^T$ with $\\omega=120\\,\\text{rad/s}$, and let $\\mathbf{D}=\\mathrm{diag}(0.3,-0.15,-0.15)\\,\\text{s}^{-1}$, which is symmetric and has zero trace. Define $\\mathbf{L}(t)=\\mathbf{W}(\\boldsymbol{\\omega})+\\mathbf{D}$. Set $T=0.03\\,\\text{s}$ and $N=300$. Compute $\\mathbf{F}(T)$ by both schemes and the exact solution $\\mathbf{F}_{\\text{exact}}(T)=\\exp(T\\mathbf{L})$. Report $e_{\\mathrm{E}}=\\lVert \\mathbf{F}_{\\mathrm{E}}(T)-\\mathbf{F}_{\\text{exact}}(T)\\rVert_F$ and $e_{\\mathrm{M}}=\\lVert \\mathbf{F}_{\\mathrm{M}}(T)-\\mathbf{F}_{\\text{exact}}(T)\\rVert_F$.\n\n- Test Case $3$ (time-dependent large rotation with volume-preserving stretch): Let $\\boldsymbol{\\omega}(t)=[0,0,\\omega_0\\cos(\\alpha t)]^T$ with $\\omega_0=180\\,\\text{rad/s}$ and $\\alpha=60\\,\\text{s}^{-1}$. Let $\\mathbf{D}(t)=\\mathrm{diag}(d(t),-d(t)/2,-d(t)/2)$ with $d(t)=0.4\\cos(20 t)\\,\\text{s}^{-1}$. Define $\\mathbf{L}(t)=\\mathbf{W}(\\boldsymbol{\\omega}(t))+\\mathbf{D}(t)$. Set $T=0.05\\,\\text{s}$ and $N=1000$. For this time-dependent and traceless $\\mathbf{L}(t)$, the exact Jacobian determinant satisfies $\\det\\mathbf{F}(T)=1$ if integrated exactly. Compute the determinant deviations $\\delta_{\\mathrm{E}}=\\lvert \\det\\mathbf{F}_{\\mathrm{E}}(T)-1\\rvert$ and $\\delta_{\\mathrm{M}}=\\lvert \\det\\mathbf{F}_{\\mathrm{M}}(T)-1\\rvert$.\n\nYour program must produce a single line of output containing the results for all three tests and both schemes as a comma-separated list enclosed in square brackets:\n$[e_{\\mathrm{E}}^{(1)},e_{\\mathrm{M}}^{(1)},e_{\\mathrm{E}}^{(2)},e_{\\mathrm{M}}^{(2)},\\delta_{\\mathrm{E}}^{(3)},\\delta_{\\mathrm{M}}^{(3)}]$.\nHere, the superscripts denote the test case number. Each entry must be a floating-point number. Angles must be in radians and time in seconds. No other text should be printed.",
            "solution": "The core of the problem is the numerical integration of the matrix ordinary differential equation (ODE) governing the evolution of the deformation gradient, $\\mathbf{F}$:\n$$\n\\frac{d\\mathbf{F}}{dt} = \\dot{\\mathbf{F}} = \\mathbf{L}(t)\\mathbf{F}(t)\n$$\nwith the initial condition $\\mathbf{F}(0) = \\mathbf{I}$. We implement two numerical schemes over $N$ uniform time steps of size $\\Delta t = T/N$. Let $\\mathbf{F}_k$ be the approximation of $\\mathbf{F}$ at time $t_k = k\\Delta t$.\n\n**Scheme 1: First-Order Explicit Forward Time Discretization**\nThis scheme, also known as the forward Euler method, approximates the time derivative using a first-order forward difference:\n$$\n\\frac{\\mathbf{F}_{k+1} - \\mathbf{F}_k}{\\Delta t} \\approx \\mathbf{L}(t_k)\\mathbf{F}_k\n$$\nThis yields the iterative update rule, where $\\mathbf{L}_k = \\mathbf{L}(t_k)$:\n$$\n\\mathbf{F}_{k+1} = (\\mathbf{I} + \\Delta t \\, \\mathbf{L}_k)\\mathbf{F}_k\n$$\nThis method is computationally simple but generally does not preserve the geometric structure of the solution. For instance, it fails to keep $\\mathbf{F}$ in the special linear group $SL(3)$ for volume-preserving flows.\n\n**Scheme 2: Second-Order Structure-Preserving Midpoint Scheme**\nThis scheme uses the matrix exponential, approximating the solution over the interval $[t_k, t_{k+1}]$ by evaluating $\\mathbf{L}$ at the midpoint $t_{k+1/2} = t_k + \\Delta t/2$. The update rule is:\n$$\n\\mathbf{F}_{k+1} = \\exp(\\Delta t \\, \\mathbf{L}_{k+1/2}) \\mathbf{F}_k\n$$\nThis method is second-order accurate and structure-preserving. For example, if $\\mathrm{tr}(\\mathbf{L})=0$, then $\\det(\\exp(\\Delta t \\, \\mathbf{L}_{k+1/2})) = \\exp(\\mathrm{tr}(\\Delta t \\, \\mathbf{L}_{k+1/2})) = 1$, ensuring that the numerical solution remains volume-preserving ($\\det \\mathbf{F}_{k+1} = \\det \\mathbf{F}_k$), a property the forward Euler method lacks.\n\n**Application to Test Cases**\nThe provided Python code implements these two schemes to solve the three test cases.\n- For **Test Cases 1 and 2**, $\\mathbf{L}$ is time-independent. The exact solution is $\\mathbf{F}_{\\text{exact}}(T) = \\exp(T\\mathbf{L})$. The code calculates the Frobenius norm error of each scheme's final result $\\mathbf{F}(T)$ against this exact solution. The exponential midpoint scheme is exact for constant $\\mathbf{L}$, so its error is expected to be near machine precision.\n- For **Test Case 3**, $\\mathbf{L}(t)$ is time-dependent and traceless, meaning the exact flow is volume-preserving ($\\det\\mathbf{F}(T) = 1$). The code calculates the determinant deviation, $\\delta = |\\det(\\mathbf{F}(T)) - 1|$, for each scheme to test their ability to preserve this geometric property.\n\nThe final numerical results are generated by running the provided Python code, which executes these steps for the given parameters and computes the requested metrics.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    # Helper function to create the skew-symmetric matrix W\n    def make_W(omega_vec):\n        wx, wy, wz = omega_vec\n        return np.array([\n            [0.0, -wz, wy],\n            [wz, 0.0, -wx],\n            [-wy, wx, 0.0]\n        ])\n\n    def solve_case_1():\n        \"\"\"\n        Solves Test Case 1: pure large rotation, time-independent.\n        \"\"\"\n        omega_val = 200.0\n        T = 0.05\n        N = 200\n        dt = T / N\n\n        omega_vec = np.array([0.0, 0.0, omega_val])\n        L = make_W(omega_vec)\n\n        # Scheme 1: Forward Explicit (FE)\n        F_E = np.identity(3)\n        integrator_E = np.identity(3) + dt * L\n        for _ in range(N):\n            F_E = integrator_E @ F_E\n\n        # Scheme 2: Exponential Midpoint (EM)\n        F_M = np.identity(3)\n        integrator_M = expm(dt * L)\n        for _ in range(N):\n            F_M = integrator_M @ F_M\n\n        # Exact Solution\n        F_exact = expm(T * L)\n\n        # Compute Frobenius norm errors\n        e_E = np.linalg.norm(F_E - F_exact, 'fro')\n        e_M = np.linalg.norm(F_M - F_exact, 'fro')\n\n        return e_E, e_M\n\n    def solve_case_2():\n        \"\"\"\n        Solves Test Case 2: combined rotation and stretch, time-independent.\n        \"\"\"\n        omega_val = 120.0\n        D = np.diag([0.3, -0.15, -0.15])\n        T = 0.03\n        N = 300\n        dt = T / N\n\n        omega_vec = np.array([0.0, 0.0, omega_val])\n        W = make_W(omega_vec)\n        L = W + D\n\n        # Scheme 1: Forward Explicit (FE)\n        F_E = np.identity(3)\n        integrator_E = np.identity(3) + dt * L\n        for _ in range(N):\n            F_E = integrator_E @ F_E\n\n        # Scheme 2: Exponential Midpoint (EM)\n        F_M = np.identity(3)\n        integrator_M = expm(dt * L)\n        for _ in range(N):\n            F_M = integrator_M @ F_M\n        \n        # Exact Solution\n        F_exact = expm(T * L)\n\n        # Compute Frobenius norm errors\n        e_E = np.linalg.norm(F_E - F_exact, 'fro')\n        e_M = np.linalg.norm(F_M - F_exact, 'fro')\n\n        return e_E, e_M\n\n    def solve_case_3():\n        \"\"\"\n        Solves Test Case 3: time-dependent rotation and volume-preserving stretch.\n        \"\"\"\n        omega0 = 180.0\n        alpha = 60.0\n        d_amp = 0.4\n        d_freq = 20.0\n        T = 0.05\n        N = 1000\n        dt = T / N\n\n        # Define L(t) as a function\n        def get_L(t):\n            wz_t = omega0 * np.cos(alpha * t)\n            d_t = d_amp * np.cos(d_freq * t)\n            omega_vec_t = np.array([0.0, 0.0, wz_t])\n            W_t = make_W(omega_vec_t)\n            D_t = np.diag([d_t, -d_t / 2.0, -d_t / 2.0])\n            return W_t + D_t\n\n        # Scheme 1: Forward Explicit (FE)\n        F_E = np.identity(3)\n        for k in range(N):\n            t_k = k * dt\n            L_k = get_L(t_k)\n            F_E = (np.identity(3) + dt * L_k) @ F_E\n\n        # Scheme 2: Exponential Midpoint (EM)\n        F_M = np.identity(3)\n        for k in range(N):\n            t_k_half = (k + 0.5) * dt\n            L_k_half = get_L(t_k_half)\n            F_M = expm(dt * L_k_half) @ F_M\n\n        # Compute determinant deviations\n        delta_E = abs(np.linalg.det(F_E) - 1.0)\n        delta_M = abs(np.linalg.det(F_M) - 1.0)\n\n        return delta_E, delta_M\n\n    # Run all test cases\n    e_E1, e_M1 = solve_case_1()\n    e_E2, e_M2 = solve_case_2()\n    delta_E3, delta_M3 = solve_case_3()\n    \n    # Collate results\n    results = [e_E1, e_M1, e_E2, e_M2, delta_E3, delta_M3]\n    \n    # Print in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}