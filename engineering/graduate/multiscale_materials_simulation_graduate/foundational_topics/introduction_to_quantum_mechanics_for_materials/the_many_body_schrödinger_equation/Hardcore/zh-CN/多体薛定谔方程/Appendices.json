{
    "hands_on_practices": [
        {
            "introduction": "我们从最简单的多体系统——无相互作用的费米子——开始。这种理想化的情景使我们能够精确地构建多体波函数，为理解更复杂的系统奠定基础。这项练习的核心在于应用泡利不相容原理，并学习如何从单粒子态出发，通过构建斯莱特行列式来构造反对称波函数 。通过这个基本练习，您将搭建起从单粒子量子力学到多体物理学的桥梁，并巩固粒子统计性质如何决定基态结构和能量的核心概念。",
            "id": "5303426",
            "problem": "考虑$N$个质量为$m$的全同无自旋费米子，被限制在长度为$L$的一维无限深方势阱中，边界条件为硬壁边界。多体哈密顿量为\n$$\n\\hat{H} \\;=\\; \\sum_{i=1}^{N}\\left[-\\frac{\\hbar^{2}}{2m}\\frac{\\partial^{2}}{\\partial x_{i}^{2}} + V(x_{i})\\right],\n$$\n其中，当 $0 < x < L$ 时，$V(x) = 0$，否则为无穷大。多体薛定谔方程为 $\\hat{H}\\,\\Psi(x_{1},x_{2},\\dots,x_{N}) = E\\,\\Psi(x_{1},x_{2},\\dots,x_{N})$。该体系的基态波函数 $\\Psi_0$ 对于任意两个粒子的交换必须是反对称的。根据这些信息，推导出该体系的基态能量 $E_0$ 的解析表达式，该表达式应是关于粒子数 $N$ 和势阱长度 $L$ 的函数。请提供精确的闭合形式表达式，而非近似值或级数展开。",
            "solution": "给定的多体哈密顿量$\\hat{H}$是单粒子哈密顿量$\\hat{h}_i$的和：\n$$\n\\hat{H} = \\sum_{i=1}^{N} \\hat{h}_i, \\quad \\text{其中} \\quad \\hat{h}_i = -\\frac{\\hbar^{2}}{2m}\\frac{\\partial^{2}}{\\partial x_{i}^{2}} + V(x_{i})\n$$\n由于粒子是无相互作用的，多体波函数可以由单粒子薛定谔方程的解来构造：\n$$\n\\hat{h}\\phi(x) = \\epsilon\\phi(x)\n$$\n对于长度为$L$的一维无限深方势阱，当$x \\in (0, L)$时势能$V(x)=0$，否则为无穷大。阱内单粒子哈密顿量为$\\hat{h} = -\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2}$。边界条件为$\\phi(0) = 0$和$\\phi(L) = 0$。\n\n这个单粒子问题的解是众所周知的归一化本征函数及其对应的能量本征值：\n$$\n\\phi_{n}(x) = \\sqrt{\\frac{2}{L}} \\sin\\left(\\frac{n\\pi x}{L}\\right)\n$$\n$$\n\\epsilon_{n} = \\frac{\\hbar^{2}k_{n}^{2}}{2m} = \\frac{\\hbar^{2}\\pi^{2}n^{2}}{2mL^{2}}\n$$\n其中$n=1, 2, 3, \\dots$是主量子数。\n\n该问题涉及$N$个全同无自旋费米子。根据泡利不相容原理，任意两个全同费米子不能占据相同的量子态。由于这些费米子是无自旋的，它们的态仅由量子数$n$定义。因此，每个费米子必须占据一个不同的单粒子轨道$\\phi_n$。\n\n为了找到$N$粒子体系的基态，我们必须填充能量最低的单粒子态。这些态对应于量子数$n=1, 2, \\dots, N$。\n\n费米子的多体波函数对于任意两个粒子坐标的交换必须是完全反对称的。对于一个无相互作用的费米子体系，正确归一化的反对称波函数由已占据的单粒子轨道构成的斯莱特行列式给出。\n\n对于基态，已占据的轨道是$\\{\\phi_1, \\phi_2, \\dots, \\phi_N\\}$。因此，基态多体波函数$\\Psi_{0}(x_{1},\\dots,x_{N})$为：\n$$\n\\Psi_{0}(x_{1},x_{2},\\dots,x_{N}) = \\frac{1}{\\sqrt{N!}}\n\\begin{vmatrix}\n\\phi_{1}(x_{1})  & \\phi_{2}(x_{1})  & \\cdots  & \\phi_{N}(x_{1}) \\\\\n\\phi_{1}(x_{2})  & \\phi_{2}(x_{2})  & \\cdots  & \\phi_{N}(x_{2}) \\\\\n\\vdots            & \\vdots           & \\ddots  & \\vdots           \\\\\n\\phi_{1}(x_{N})  & \\phi_{2}(x_{N})  & \\cdots  & \\phi_{N}(x_{N})\n\\end{vmatrix}\n$$\n其中每个$\\phi_n(x_i)$由$\\phi_{n}(x_{i}) = \\sqrt{\\frac{2}{L}} \\sin\\left(\\frac{n\\pi x_{i}}{L}\\right)$给出。前置因子$\\frac{1}{\\sqrt{N!}}$确保了多体波函数的归一化，因为单粒子轨道$\\{\\phi_n\\}$构成一个标准正交集，即$\\int_{0}^{L} \\phi_{n}^{*}(x)\\phi_{m}(x)dx = \\delta_{nm}$。\n\n接下来，我们确定总基态能量$E_0$。由于哈密顿量是单粒子算符的和，且粒子间无相互作用，总能量是已占据的单粒子态能量的总和：\n$$\nE_{0} = \\sum_{n=1}^{N} \\epsilon_{n}\n$$\n代入单粒子能量本征值$\\epsilon_n$的表达式：\n$$\nE_{0}(N,L) = \\sum_{n=1}^{N} \\frac{\\hbar^{2}\\pi^{2}n^{2}}{2mL^{2}}\n$$\n我们可以将不依赖于求和指标$n$的常数提取出来：\n$$\nE_{0}(N,L) = \\frac{\\hbar^{2}\\pi^{2}}{2mL^{2}} \\sum_{n=1}^{N} n^{2}\n$$\n前$N$个平方数的和由著名的闭式表达式（福尔哈伯公式）给出：\n$$\n\\sum_{n=1}^{N} n^{2} = \\frac{N(N+1)(2N+1)}{6}\n$$\n将此和代回基态能量的表达式中，得到：\n$$\nE_{0}(N,L) = \\frac{\\hbar^{2}\\pi^{2}}{2mL^{2}} \\left( \\frac{N(N+1)(2N+1)}{6} \\right)\n$$\n合并数值因子，我们得到基态能量的最终精确闭式表达式：\n$$\nE_{0}(N,L) = \\frac{\\hbar^{2}\\pi^{2}N(N+1)(2N+1)}{12mL^{2}}\n$$\n这个表达式给出了总基态能量，它是粒子数$N$、势阱长度$L$、粒子质量$m$和普朗克常数$\\hbar$的函数。",
            "answer": "$$\n\\boxed{\\frac{\\hbar^{2}\\pi^{2}N(N+1)(2N+1)}{12mL^{2}}}\n$$"
        },
        {
            "introduction": "在掌握了无相互作用的系统之后，我们现在引入电子间的相互作用，这是多体物理学的核心挑战。哈伯德模型 (Hubbard model) 是研究这种相互作用的经典模型。这项实践旨在探索动能（电子跃迁，$t$）与势能（在位排斥，$U$）之间的竞争，并演示如何利用自旋对称性将哈密顿量矩阵块对角化 。通过精确对角化一个双点哈伯德模型，您将亲身体验处理关联电子基本模型的过程，并理解单重态-三重态能隙等现象的物理起源。",
            "id": "5303435",
            "problem": "考虑具有两个电子的双格点哈伯德模型（哈伯德二聚体）。时不变多体薛定谔方程指出，一个定态 $\\lvert \\Psi \\rangle$ 满足 $H \\lvert \\Psi \\rangle = E \\lvert \\Psi \\rangle$。二次量子化的哈伯德二聚体哈密顿量为\n$$\nH \\;=\\; -\\,t \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\left( c_{1\\sigma}^{\\dagger} c_{2\\sigma} + c_{2\\sigma}^{\\dagger} c_{1\\sigma} \\right) \\;+\\; U \\sum_{i=1}^{2} n_{i\\uparrow} n_{i\\downarrow},\n$$\n其中 $t$ 是最近邻跃迁振幅，$U$ 是在位相互作用，$c_{i\\sigma}^{\\dagger}$ 在格点 $i$ 上产生一个自旋为 $\\sigma$ 的电子，且 $n_{i\\sigma} = c_{i\\sigma}^{\\dagger} c_{i\\sigma}$。\n\n从多体薛定谔方程和上述哈密顿量出发，在半填充（即两个电子）的扇区内进行研究，并利用总自旋的对称性考虑将哈密顿量块对角化为单重态和三重态扇区。对得到的块进行严格对角化，并将单重态-三重态能隙定义为 $\\Delta_{ST} = E_{T} - E_{S}$，其中 $E_{T}$ 是最低三重态能量，$E_{S}$ 是最低单重态能量。将 $\\Delta_{ST}$ 的最终答案表示为关于无量纲比率 $U/t$ 的闭合形式解析表达式。不要采用任何极限近似；请提供精确表达式。不需要进行数值舍入，并以无单位的形式报告最终表达式。",
            "solution": "为了求解双格点、双电子哈伯德模型，我们首先构建系统的基矢，然后利用总自旋对称性将哈密顿量矩阵进行块对角化。\n\n**1. 构建基矢**\n两个电子在两个格点（四个自旋-轨道）上共有 $\\binom{4}{2}=6$ 种可能的组态。这些组态可以根据总自旋量子数 $S$ 分为三重态（$S=1$）和单重态（$S=0$）。\n\n**2. 三重态扇区 ($S=1$)**\n三重态具有对称的自旋波函数，共有三个：\n$$ |T_+\\rangle = c_{1\\uparrow}^\\dagger c_{2\\uparrow}^\\dagger|0\\rangle, \\quad |T_-\\rangle = c_{1\\downarrow}^\\dagger c_{2\\downarrow}^\\dagger|0\\rangle, \\quad |T_0\\rangle = \\frac{1}{\\sqrt{2}}(c_{1\\uparrow}^\\dagger c_{2\\downarrow}^\\dagger + c_{1\\downarrow}^\\dagger c_{2\\uparrow}^\\dagger)|0\\rangle $$\n在这些态中，每个格点最多只有一个电子，因此在位排斥项 $U \\sum_i n_{i\\uparrow}n_{i\\downarrow}$ 的期望值为零。同时，跃迁项 $-t\\sum_\\sigma(c_{1\\sigma}^\\dagger c_{2\\sigma} + c_{2\\sigma}^\\dagger c_{1\\sigma})$ 作用在这些态上也会得到零，因为泡利不相容原理禁止一个电子跃迁到已被相同自旋电子占据的格点上。因此，所有三个三重态的能量都是简并的，为 $E_T = 0$。\n\n**3. 单重态扇区 ($S=0$)**\n剩下的三个态属于单重态。我们可以选择一个方便的基矢来表示这个子空间。一个包含共价（单占据）和离子（双占据）特征的基矢是：\n$$ |C\\rangle = \\frac{1}{\\sqrt{2}}(c_{1\\uparrow}^\\dagger c_{2\\downarrow}^\\dagger - c_{1\\downarrow}^\\dagger c_{2\\uparrow}^\\dagger)|0\\rangle \\quad (\\text{共价态}) $$\n$$ |D\\rangle = \\frac{1}{\\sqrt{2}}(c_{1\\uparrow}^\\dagger c_{1\\downarrow}^\\dagger + c_{2\\uparrow}^\\dagger c_{2\\downarrow}^\\dagger)|0\\rangle \\quad (\\text{对称离子态}) $$\n第三个单重态是反对称离子态 $|A\\rangle = \\frac{1}{\\sqrt{2}}(c_{1\\uparrow}^\\dagger c_{1\\downarrow}^\\dagger - c_{2\\uparrow}^\\dagger c_{2\\downarrow}^\\dagger)|0\\rangle$。\n\n在这个基矢下，哈密顿量是块对角化的。$|A\\rangle$ 是一个能量为 $U$ 的本征态，且不与 $|C\\rangle$ 和 $|D\\rangle$ 耦合。\n在 $\\{|C\\rangle, |D\\rangle\\}$ 张成的子空间中，哈密顿量矩阵为：\n$$ H_S = \\begin{pmatrix} \\langle C|H|C \\rangle & \\langle C|H|D \\rangle \\\\ \\langle D|H|C \\rangle & \\langle D|H|D \\rangle \\end{pmatrix} = \\begin{pmatrix} 0 & -2t \\\\ -2t & U \\end{pmatrix} $$\n对角化这个 $2 \\times 2$ 矩阵，求解特征方程 $\\det(H_S - E \\cdot I) = 0$：\n$$ (-E)(U-E) - (-2t)^2 = 0 \\implies E^2 - UE - 4t^2 = 0 $$\n解得两个单重态能量：\n$$ E_{S,\\pm} = \\frac{U \\pm \\sqrt{U^2 + 16t^2}}{2} $$\n最低的单重态能量（即基态能量）为：\n$$ E_S = \\frac{U - \\sqrt{U^2 + 16t^2}}{2} $$\n\n**4. 计算单重态-三重态能隙**\n单重态-三重态能隙 $\\Delta_{ST}$ 定义为最低三重态能量 $E_T$ 与最低单重态能量 $E_S$ 之差：\n$$ \\Delta_{ST} = E_T - E_S = 0 - \\left( \\frac{U - \\sqrt{U^2 + 16t^2}}{2} \\right) = \\frac{\\sqrt{U^2 + 16t^2} - U}{2} $$\n为了将结果表示为关于无量纲比率 $U/t$ 的函数，我们提出因子 $t$：\n$$ \\Delta_{ST} = \\frac{t\\sqrt{(U/t)^2 + 16} - t(U/t)}{2} $$",
            "answer": "$$\\boxed{\\frac{t}{2} \\left[ \\sqrt{\\left(\\frac{U}{t}\\right)^2 + 16} - \\frac{U}{t} \\right]}$$"
        },
        {
            "introduction": "对于真实的多体系统，精确解是极其罕见的，我们必须转向强大的数值方法。兰索斯算法 (Lanczos algorithm) 是求解多体问题中常见的大型稀疏哈密顿量极端本征值的首选技术之一。该练习基于将哈密顿算符投影到一个较小的克雷洛夫子空间 (Krylov subspace) 上的思想，该子空间能高效地捕捉完整算符的极端谱特性 。这个问题将理论推导与实际编程相结合，为您提供了解决原本棘手问题的前沿计算工具，让您直接参与到计算多体物理学的核心实践中。",
            "id": "5303433",
            "problem": "考虑在一个由 $L$ 个自旋-$\\tfrac{1}{2}$ 自由度构成的格子上，有限维希尔伯特空间中的时间无关多体薛定谔方程 $H \\lvert \\Psi \\rangle = E \\lvert \\Psi \\rangle$。该计算问题可简化为对一个作用于维度为 $N = 2^L$ 的向量空间上的实对称（厄米）矩阵 $H$ 的谱分析。在此背景下，克雷洛夫子空间方法生成一系列 $H$ 的低维投影，其极端本征值可近似 $H$ 的极端本征值。兰索斯算法为克雷洛夫子空间构建一个标准正交基，并在此基上生成 $H$ 的一个对称三对角表示。\n\n您的任务是：\n- 从厄米算符、由非零向量 $\\lvert v_1 \\rangle$ 生成的克雷洛夫子空间以及格拉姆-施密特正交化过程的定义出发，推导出一个唯一的实数标量序列和标准正交向量序列的存在性。这个序列强制执行一个三项递推关系，从而在克雷洛夫基上得到 $H$ 的对称三对角表示。您的推导必须明确说明关于 $H$ 的假设、基向量的标准正交条件，以及由厄米性所暗示的、约束该递推关系结构的正交性质。不要引用任何现成的公式；从第一性原理出发进行推导。\n- 实现一个程序，应用带完全重正交化的兰索斯算法，为几个多体自旋模型近似计算 $H$ 的最小和最大本征值。该程序必须：\n  - 为下面测试套件中列出的每个模型，在开放边界条件下，将 $H$ 构建为稀疏矩阵。\n  - 使用一个可复现的随机初始向量来生成克雷洛夫子空间。\n  - 构建对称三对角投影，并提取极端的里兹值作为 $H$ 的极端本征值的近似。\n  - 为了验证，通过密集对角化计算 $H$ 的精确最小和最大本征值，并报告兰索斯近似值与精确值之间的绝对误差。所有能量都是无量纲的，并以交换耦合常数 $J$ 等于 $1$ 的单位进行度量。\n- 数值细节与约束：\n  - 所有构建的哈密顿量必须是实对称的。\n  - 角度（如果在中间推理中出现）应以弧度表示，但下面给出的模型不涉及显式的角度参数。\n  - 为每个极端本征值返回的绝对误差必须是浮点数。\n\n模型与算符：\n- 令 $\\sigma^x, \\sigma^y, \\sigma^z$ 表示泡利矩阵，且 $S^\\mu = \\tfrac{1}{2} \\sigma^\\mu$ ($\\mu \\in \\{x,y,z\\}$)。开放边界条件意味着最近邻求和的范围是从格点 $i = 1$ 到 $i = L-1$。\n- 将使用三种模型：\n  - 海森堡模型: $H = J \\sum_{i=1}^{L-1} \\left( S_i^x S_{i+1}^x + S_i^y S_{i+1}^y + S_i^z S_{i+1}^z \\right)$。\n  - 横向场伊辛模型: $H = - J \\sum_{i=1}^{L-1} \\sigma_i^z \\sigma_{i+1}^z - g \\sum_{i=1}^{L} \\sigma_i^x$。\n  - 各向异性XXZ模型: $H = J \\sum_{i=1}^{L-1} \\left( S_i^x S_{i+1}^x + S_i^y S_{i+1}^y + \\Delta S_i^z S_{i+1}^z \\right)$。\n- 在所有情况下均使用 $J = 1$。在这些单位中，能量必须被视为无量纲数。\n\n测试套件：\n- 情况 1 (理想情况，精确三对角化)：海森堡模型，$L = 4$，$J = 1$。使用等于 $N = 2^L$ 的兰索斯子空间维度。\n- 情况 2 (近似子空间，非可积场)：横向场伊辛模型，$L = 6$，$J = 1$，$g = 1.1$。使用兰索斯子空间维度 $m = 50$。\n- 情况 3 (各向异性，精确三对角化)：XXZ模型，$L = 5$，$J = 1$，$\\Delta = 0.5$。使用等于 $N = 2^L$ 的兰索斯子空间维度。\n- 情况 4 (小尺寸链)：海森堡模型，$L = 2$，$J = 1$。使用等于 $N = 2^L$ 的兰索斯子空间维度。\n\n答案规格：\n- 对于每种情况，计算两个绝对误差：最小里兹值与精确最小本征值之间的绝对差，以及最大里兹值与精确最大本征值之间的绝对差。两者都必须以浮点数形式报告。\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的浮点数列表，顺序为 $[\\text{err}_{\\min}^{(1)}, \\text{err}_{\\max}^{(1)}, \\text{err}_{\\min}^{(2)}, \\text{err}_{\\max}^{(2)}, \\text{err}_{\\min}^{(3)}, \\text{err}_{\\max}^{(3)}, \\text{err}_{\\min}^{(4)}, \\text{err}_{\\max}^{(4)}]$。不应打印任何其他文本。\n- 不允许用户输入；所有参数均由上述测试套件固定。",
            "solution": "### 第 1 部分：兰索斯递推关系的推导\n\n给定一个实对称（因此是厄米）的算符 $H$，它作用于一个维度为 $N$ 的有限维实向量空间 $V$ 上，该空间配有内积 $\\langle v \\mid w \\rangle = v^T w$。目标是为克雷洛夫子空间 $\\mathcal{K}_m(H, \\lvert v_1 \\rangle)$ 找到一个标准正交基，在该基中 $H$ 的表示是一个对称三对角矩阵。\n\n**定义与假设：**\n1.  **厄米算符**：$H$ 是 $V$ 上的一个线性算符，对于所有 $\\lvert v \\rangle, \\lvert w \\rangle \\in V$ 满足 $\\langle H v \\mid w \\rangle = \\langle v \\mid H w \\rangle$。由于我们被告知 $H$ 是实对称的，对于标准的实内积，即 $(H v)^T w = v^T H^T w = v^T H w$，此条件是满足的。\n2.  **克雷洛夫子空间**：对于一个给定的非零起始向量 $\\lvert v_1 \\rangle$，第 $m$ 个克雷洛夫子空间定义为\n    $$\n    \\mathcal{K}_m(H, \\lvert v_1 \\rangle) = \\text{span}\\{ \\lvert v_1 \\rangle, H\\lvert v_1 \\rangle, H^2\\lvert v_1 \\rangle, \\dots, H^{m-1}\\lvert v_1 \\rangle \\}\n    $$\n    我们假设 $m$ 小于或等于 $\\lvert v_1 \\rangle$ 相对于 $H$ 的级数，因此向量 $\\{\\lvert v_1 \\rangle, \\dots, H^{m-1}\\lvert v_1 \\rangle\\}$ 是线性无关的，并且 $\\dim(\\mathcal{K}_m) = m$。\n3.  **格拉姆-施密特过程**：一种从一组线性无关向量构造标准正交基的算法。\n\n**推导：**\n我们的目标是通过一个类似于格拉姆-施密特过程的程序，为 $\\mathcal{K}_m$ 构建一个标准正交基 $\\{\\lvert q_1 \\rangle, \\lvert q_2 \\rangle, \\dots, \\lvert q_m \\rangle\\}$。设这个基由一个矩阵 $Q_m = [\\lvert q_1 \\rangle, \\lvert q_2 \\rangle, \\dots, \\lvert q_m \\rangle]$ 的列向量表示。标准正交条件是 $\\langle q_i \\mid q_j \\rangle = \\delta_{ij}$，或 $Q_m^T Q_m = I_m$。投影到该子空间上的 $H$ 的表示是 $m \\times m$ 矩阵 $T_m = Q_m^T H Q_m$。该矩阵的元素是 $(T_m)_{ij} = \\langle q_i \\mid H \\mid q_j \\rangle$。\n\n让我们逐步构建基 $\\{\\lvert q_j \\rangle\\}$。\n\n**第 1 步：初始化**\n从归一化给定的向量 $\\lvert v_1 \\rangle$ 开始。\n$$\n\\lvert q_1 \\rangle = \\frac{\\lvert v_1 \\rangle}{\\lVert \\lvert v_1 \\rangle \\rVert}\n$$\n根据构造，$\\langle q_1 \\mid q_1 \\rangle = 1$ 并且 $\\text{span}\\{\\lvert q_1 \\rangle\\} = \\text{span}\\{\\lvert v_1 \\rangle\\} = \\mathcal{K}_1$。\n\n**第 2 步：第一个递推关系**\n考虑向量 $H \\lvert q_1 \\rangle$。该向量是 $\\mathcal{K}_2 = \\text{span}\\{\\lvert v_1 \\rangle, H\\lvert v_1 \\rangle\\} = \\text{span}\\{\\lvert q_1 \\rangle, H\\lvert q_1 \\rangle\\}$ 的一个元素。我们可以将 $H \\lvert q_1 \\rangle$ 分解为一个平行于 $\\lvert q_1 \\rangle$ 的分量和一个与其正交的分量。\n平行分量由 $H \\lvert q_1 \\rangle$ 在 $\\lvert q_1 \\rangle$ 上的投影给出：\n$$\n\\lvert w_{\\parallel} \\rangle = \\langle q_1 \\mid H \\mid q_1 \\rangle \\lvert q_1 \\rangle\n$$\n我们定义标量系数 $\\alpha_1 = \\langle q_1 \\mid H \\mid q_1 \\rangle$。注意由于 $H$ 是实对称的，$\\alpha_1$ 是实数。\n正交分量则是：\n$$\n\\lvert r_1 \\rangle = H \\lvert q_1 \\rangle - \\alpha_1 \\lvert q_1 \\rangle\n$$\n根据构造，这个向量 $\\lvert r_1 \\rangle$ 与 $\\lvert q_1 \\rangle$ 正交：$\\langle q_1 \\mid r_1 \\rangle = \\langle q_1 \\mid H \\mid q_1 \\rangle - \\alpha_1 \\langle q_1 \\mid q_1 \\rangle = \\alpha_1 - \\alpha_1 = 0$。\n为了获得下一个标准正交基向量，我们归一化 $\\lvert r_1 \\rangle$：\n$$\n\\lvert q_2 \\rangle = \\frac{\\lvert r_1 \\rangle}{\\beta_1}, \\quad \\text{其中} \\quad \\beta_1 = \\lVert \\lvert r_1 \\rangle \\rVert = \\sqrt{\\langle r_1 \\mid r_1 \\rangle}\n$$\n如果 $\\beta_1 = 0$，算法终止，意味着 $\\mathcal{K}_2 = \\mathcal{K}_1$。假设 $\\beta_1 > 0$，我们找到了第二个标准正交向量 $\\lvert q_2 \\rangle$。集合 $\\{\\lvert q_1 \\rangle, \\lvert q_2 \\rangle\\}$ 是 $\\mathcal{K}_2$ 的一个标准正交基。\n重新整理定义，我们得到第一个递推关系：\n$$\nH \\lvert q_1 \\rangle = \\alpha_1 \\lvert q_1 \\rangle + \\beta_1 \\lvert q_2 \\rangle\n$$\n\n**第 3 步：一般三项递推关系**\n让我们将其推广。假设我们已经构建了一个标准正交集 $\\{\\lvert q_1 \\rangle, \\dots, \\lvert q_j \\rangle\\}$，它构成了 $\\mathcal{K}_j$ 的一个基。向量 $\\lvert q_j \\rangle$ 是一个作用于 $\\lvert q_1 \\rangle$ 上的 $H$ 的 $j-1$ 次多项式。因此，$H\\lvert q_j \\rangle$ 是一个作用于 $\\lvert q_1 \\rangle$ 上的 $H$ 的 $j$ 次多项式，这意味着 $H\\lvert q_j \\rangle \\in \\mathcal{K}_{j+1}$。\n我们可以将 $H \\lvert q_j \\rangle$ 表示为：\n$$\nH \\lvert q_j \\rangle = \\sum_{k=1}^{j+1} c_k \\lvert q_k \\rangle\n$$\n系数 $c_k$ 通过与 $\\lvert q_k \\rangle$ 取内积得到：$c_k = \\langle q_k \\mid H \\mid q_j \\rangle$。这些正是矩阵 $T_m$ 的元素。让我们利用 $H$ 的厄米性来分析这些系数。\n\n向量 $H \\lvert q_k \\rangle$ 位于 $\\mathcal{K}_{k+1} = \\text{span}\\{\\lvert q_1 \\rangle, \\dots, \\lvert q_{k+1} \\rangle\\}$ 中。因此，$H \\lvert q_k \\rangle$ 与任何 $i > k+1$ 的 $\\lvert q_i \\rangle$ 正交。\n$$\n\\langle q_i \\mid H \\mid q_k \\rangle = 0 \\quad \\text{对于} \\quad i > k+1\n$$\n利用 $H$ 的厄米性，$\\langle q_i \\mid H \\mid q_k \\rangle = \\langle H q_i \\mid q_k \\rangle$。这意味着 $\\langle q_k \\mid H \\mid q_i \\rangle = 0$ 对于 $k > i+1$。\n结合这两点，矩阵元素 $(T_m)_{ik} = \\langle q_i \\mid H \\mid q_k \\rangle$ 在 $|i-k| > 1$ 时为零。这证明了矩阵 $T_m$ 是三对角的。\n\n由于 $T_m$ 是三对角的，$H \\lvert q_j \\rangle$ 的展开式大大简化。唯一非零的系数 $c_k = \\langle q_k \\mid H \\mid q_j \\rangle$ 只在 $k \\in \\{j-1, j, j+1\\}$ 时出现。所以，这个展开式是一个三项递推关系：\n$$\nH \\lvert q_j \\rangle = \\langle q_{j-1} \\mid H \\mid q_j \\rangle \\lvert q_{j-1} \\rangle + \\langle q_j \\mid H \\mid q_j \\rangle \\lvert q_j \\rangle + \\langle q_{j+1} \\mid H \\mid q_j \\rangle \\lvert q_{j+1} \\rangle\n$$\n让我们用标准方式定义这些系数：\n1.  对角元素：$\\alpha_j = \\langle q_j \\mid H \\mid q_j \\rangle$。由于 $H$ 是实对称的，且基向量 $\\lvert q_j \\rangle$ 是实的，$\\alpha_j$ 是实数。\n2.  非对角元素：令 $\\beta_j = \\langle q_{j+1} \\mid H \\mid q_j \\rangle$。\n\n现在，我们需要证明这个结构是一致的。从第 $(j-1)$ 步，我们有关系式：\n$$\nH \\lvert q_{j-1} \\rangle = \\beta_{j-2} \\lvert q_{j-2} \\rangle + \\alpha_{j-1} \\lvert q_{j-1} \\rangle + \\beta_{j-1} \\lvert q_j \\rangle\n$$\n其中我们定义了 $\\beta_{j-1} = \\langle q_j \\mid H \\mid q_{j-1} \\rangle$。根据厄米性，$\\langle q_{j-1} \\mid H \\mid q_j \\rangle = \\langle H q_{j-1} \\mid q_j \\rangle = \\langle q_j \\mid H \\mid q_{j-1} \\rangle^*$。由于 $H$ 是实对称的，且向量是实的，$\\langle q_{j-1} \\mid H \\mid q_j \\rangle = \\langle q_j \\mid H \\mid q_{j-1} \\rangle = \\beta_{j-1}$。这证实了三对角矩阵 $T_m$ 是对称的。\n\n最终得到的三项递推关系是：\n$$\nH \\lvert q_j \\rangle = \\beta_{j-1} \\lvert q_{j-1} \\rangle + \\alpha_j \\lvert q_j \\rangle + \\beta_j \\lvert q_{j+1} \\rangle\n$$\n这里我们定义 $\\lvert q_0 \\rangle = 0$ 和 $\\beta_0 = 0$。\n\n这个递推关系提供了一个构造性算法（兰索斯算法）。\n给定 $\\lvert q_j \\rangle$ 和 $\\lvert q_{j-1} \\rangle$：\n1.  计算 $\\lvert w_j \\rangle = H \\lvert q_j \\rangle$。\n2.  计算对角元素 $\\alpha_j = \\langle q_j \\mid w_j \\rangle$。\n3.  构建残差向量 $\\lvert r_j \\rangle = \\lvert w_j \\rangle - \\alpha_j \\lvert q_j \\rangle - \\beta_{j-1} \\lvert q_{j-1} \\rangle$。\n4.  计算范数 $\\beta_j = \\lVert \\lvert r_j \\rangle \\rVert$。\n5.  如果 $\\beta_j \\approx 0$，过程终止。否则，归一化得到下一个基向量：$\\lvert q_{j+1} \\rangle = \\lvert r_j \\rangle / \\beta_j$。\n\n实数标量序列 $(\\alpha_1, \\dots, \\alpha_m)$ 和 $(\\beta_1, \\dots, \\beta_{m-1})$ 以及标准正交向量序列 $(\\lvert q_1 \\rangle, \\dots, \\lvert q_m \\rangle)$ 由 $\\lvert v_1 \\rangle$ 的选择唯一确定（在相位上，对于实向量固定为 $+1$）。这个过程生成了对称三对角矩阵 $T_m$：\n$$\nT_m = \\begin{pmatrix}\n\\alpha_1  &\\beta_1  &0  &\\dots  &0 \\\\\n\\beta_1  &\\alpha_2  &\\beta_2  &\\dots  &0 \\\\\n0  &\\beta_2  &\\alpha_3  &\\ddots  &\\vdots \\\\\n\\vdots  &\\vdots  &\\ddots  &\\ddots  &\\beta_{m-1} \\\\\n0  &0  &\\dots  &\\beta_{m-1}  &\\alpha_m\n\\end{pmatrix}\n$$\n$T_m$ 的本征值，称为里兹值，提供了对 $H$ 的本征值的近似。特别是，极端的里兹值是 $H$ 的极端本征值的极好近似。",
            "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.linalg import eigh_tridiagonal, eigh\nfrom functools import reduce\n\ndef build_op_on_site(op, i, L):\n    \"\"\"\n    Constructs a sparse operator acting on site i of a chain of length L.\n    The operator is built as I ⊗ ... ⊗ I ⊗ op ⊗ I ⊗ ... ⊗ I.\n    \"\"\"\n    ident = sparse.identity(2, format='csr')\n    op_list = [ident] * L\n    if i  0 or i >= L:\n        raise ValueError(\"Site index i is out of bounds.\")\n    op_list[i] = op\n    # Use reduce with a starting value of 1 for the case L=0\n    return reduce(sparse.kron, op_list, sparse.csr_matrix([[1]]))\n\ndef build_heisenberg(L, J=1.0):\n    \"\"\"Builds the Heisenberg model Hamiltonian for a spin-1/2 chain.\"\"\"\n    N = 2**L\n    H = sparse.csr_matrix((N, N), dtype=np.float64)\n    \n    s_p = sparse.csr_matrix([[0, 1], [0, 0]], dtype=np.float64)\n    s_m = sparse.csr_matrix([[0, 0], [1, 0]], dtype=np.float64)\n    s_z = sparse.csr_matrix([[0.5, 0], [0, -0.5]], dtype=np.float64)\n\n    for i in range(L - 1):\n        # S_i^x S_{i+1}^x + S_i^y S_{i+1}^y = 0.5 * (S_i^+ S_{i+1}^- + S_i^- S_{i+1}^+)\n        sp_i = build_op_on_site(s_p, i, L)\n        sm_i1 = build_op_on_site(s_m, i + 1, L)\n        sm_i = build_op_on_site(s_m, i, L)\n        sp_i1 = build_op_on_site(s_p, i + 1, L)\n        H += 0.5 * J * (sp_i @ sm_i1 + sm_i @ sp_i1)\n\n        # S_i^z S_{i+1}^z\n        sz_i = build_op_on_site(s_z, i, L)\n        sz_i1 = build_op_on_site(s_z, i + 1, L)\n        H += J * (sz_i @ sz_i1)\n    return H\n\ndef build_tfi(L, J=1.0, g=1.0):\n    \"\"\"Builds the Transverse-Field Ising model Hamiltonian.\"\"\"\n    N = 2**L\n    H = sparse.csr_matrix((N, N), dtype=np.float64)\n\n    sigma_z = sparse.csr_matrix([[1, 0], [0, -1]], dtype=np.float64)\n    sigma_x = sparse.csr_matrix([[0, 1], [1, 0]], dtype=np.float64)\n\n    # Interaction term: -J * sum(sigma_z_i * sigma_z_{i+1})\n    for i in range(L - 1):\n        sz_i = build_op_on_site(sigma_z, i, L)\n        sz_i1 = build_op_on_site(sigma_z, i + 1, L)\n        H += -J * (sz_i @ sz_i1)\n    \n    # Field term: -g * sum(sigma_x_i)\n    for i in range(L):\n        sx_i = build_op_on_site(sigma_x, i, L)\n        H += -g * sx_i\n    return H\n\ndef build_xxz(L, J=1.0, Delta=1.0):\n    \"\"\"Builds the anisotropic XXZ model Hamiltonian.\"\"\"\n    N = 2**L\n    H = sparse.csr_matrix((N, N), dtype=np.float64)\n\n    s_p = sparse.csr_matrix([[0, 1], [0, 0]], dtype=np.float64)\n    s_m = sparse.csr_matrix([[0, 0], [1, 0]], dtype=np.float64)\n    s_z = sparse.csr_matrix([[0.5, 0], [0, -0.5]], dtype=np.float64)\n    \n    for i in range(L - 1):\n        # S_i^x S_{i+1}^x + S_i^y S_{i+1}^y = 0.5 * (S_i^+ S_{i+1}^- + S_i^- S_{i+1}^+)\n        sp_i = build_op_on_site(s_p, i, L)\n        sm_i1 = build_op_on_site(s_m, i + 1, L)\n        sm_i = build_op_on_site(s_m, i, L)\n        sp_i1 = build_op_on_site(s_p, i + 1, L)\n        H += 0.5 * J * (sp_i @ sm_i1 + sm_i @ sp_i1)\n\n        # Delta * S_i^z S_{i+1}^z\n        sz_i = build_op_on_site(s_z, i, L)\n        sz_i1 = build_op_on_site(s_z, i + 1, L)\n        H += J * Delta * (sz_i @ sz_i1)\n    return H\n\ndef lanczos_reorth(H, v_start, m):\n    \"\"\"\n    Performs the Lanczos algorithm with full reorthogonalization.\n    \"\"\"\n    N = H.shape[0]\n    \n    # Ensure m is not larger than matrix dimension\n    m = min(m, N)\n    \n    Q = np.zeros((N, m))\n    alphas = np.zeros(m)\n    betas = np.zeros(m - 1)\n    \n    # Initialize first vector\n    q = v_start / np.linalg.norm(v_start)\n    Q[:, 0] = q\n    \n    w_prime = H @ q\n    alphas[0] = q.T @ w_prime\n    w = w_prime - alphas[0] * q\n    \n    for j in range(1, m):\n        beta = np.linalg.norm(w)\n        \n        if beta  1e-12:\n            m_eff = j\n            alphas_trunc = alphas[:m_eff]\n            betas_trunc = betas[:m_eff-1]\n            eigvals, _ = eigh_tridiagonal(alphas_trunc, betas_trunc, select='a')\n            return min(eigvals), max(eigvals)\n            \n        betas[j-1] = beta\n        \n        q_prev = q\n        q = w / beta\n        \n        # Full reorthogonalization against all previous vectors\n        for i_reorth in range(j):\n            q = q - (Q[:, i_reorth].T @ q) * Q[:, i_reorth]\n        # Renormalize after correction\n        q = q / np.linalg.norm(q)\n        \n        Q[:, j] = q\n        \n        w_prime = H @ q\n        alphas[j] = q.T @ w_prime\n        w = w_prime - alphas[j] * q - betas[j-1] * q_prev\n\n    eigvals, _ = eigh_tridiagonal(alphas, betas, select='a')\n    return min(eigvals), max(eigvals)\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases.\n    \"\"\"\n    test_cases = [\n        {'model': 'heisenberg', 'L': 4, 'params': {'J': 1.0}, 'm': 16},\n        {'model': 'tfi', 'L': 6, 'params': {'J': 1.0, 'g': 1.1}, 'm': 50},\n        {'model': 'xxz', 'L': 5, 'params': {'J': 1.0, 'Delta': 0.5}, 'm': 32},\n        {'model': 'heisenberg', 'L': 2, 'params': {'J': 1.0}, 'm': 4},\n    ]\n\n    results = []\n    # Use a fixed seed for the random initial vector for reproducibility\n    rng = np.random.default_rng(seed=12345)\n\n    for case in test_cases:\n        L = case['L']\n        m = case['m']\n        N = 2**L\n        \n        if case['model'] == 'heisenberg':\n            H_sparse = build_heisenberg(L, **case['params'])\n        elif case['model'] == 'tfi':\n            H_sparse = build_tfi(L, **case['params'])\n        elif case['model'] == 'xxz':\n            H_sparse = build_xxz(L, **case['params'])\n        \n        # Generate reproducible random initial vector\n        v_start = rng.random(size=N, dtype=np.float64)\n\n        # Lanczos calculation\n        min_ritz, max_ritz = lanczos_reorth(H_sparse, v_start, m)\n\n        # Exact diagonalization for verification\n        H_dense = H_sparse.toarray()\n        exact_eigvals = eigh(H_dense, eigvals_only=True)\n        exact_min, exact_max = exact_eigvals[0], exact_eigvals[-1]\n\n        # Calculate absolute errors\n        err_min = abs(min_ritz - exact_min)\n        err_max = abs(max_ritz - exact_max)\n        \n        results.extend([err_min, err_max])\n\n    # Format output as a list of floating-point numbers\n    output_str = f\"[{','.join(f'{r:.15e}' for r in results)}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}