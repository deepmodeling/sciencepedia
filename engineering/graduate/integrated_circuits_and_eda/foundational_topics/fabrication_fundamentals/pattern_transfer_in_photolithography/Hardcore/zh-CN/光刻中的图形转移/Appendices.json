{
    "hands_on_practices": [
        {
            "introduction": "曝光剂量与最终关键尺寸（CD）之间的关系是光刻工艺的基础。这种关系通常是非线性的，可以通过一个S型（sigmoidal）模型来描述，其特征在于光刻胶的对比度（$\\gamma$）和阈值能量（$E_T$）。镜头散射等引入的杂散光或“耀斑”（flare, $F$），会形成一个背景曝光，同样影响最终的CD。这项实践将指导你如何将实验数据拟合到物理模型中，以提取这些关键参数。它还突出了计量学中的一个关键挑战：参数的可辨识性（identifiability），展示了数据质量（例如所用剂量范围）如何影响模型校准的可靠性。",
            "id": "4288243",
            "problem": "在光刻技术中，基于光刻胶的图形转移将光学曝光剂量转换为显影后的特征尺寸。在密集线区域，当线状开口内部的空间像近乎均匀时，线状特征的中心剂量（单位面积的剂量）控制着光刻胶的开关非线性。从以下基本依据出发：\n\n- 驱动溶解度变化的有效能量密度是时间积分强度，称为曝光剂量，记为 $E$，单位为 $\\mathrm{mJ/cm^2}$。\n- 来自透镜散射和晶圆形貌的杂散光（耀斑）增加了一个空间上近乎均匀的背景，其一阶近似可以很好地建模为一个附加的、剂量等效的常数 $F$，单位为 $\\mathrm{mJ/cm^2}$，因此有效剂量为 $E_{\\mathrm{eff}} = E + F$。\n- 正性化学放大光刻胶的清除过程是 $E_{\\mathrm{eff}}$ 的单调函数，并表现出一个有限的过渡宽度，该宽度由光刻胶对比度（斜率）（记为 $\\gamma$）和特征阈值剂量 $E_T$（单位为 $\\mathrm{mJ/cm^2}$）决定。\n- 对于一个在剂量扫描中标称掩模开口保持不变的线状特征，其显影后的关键尺寸可以归一化为一个无量纲分数 $y \\in [0,1]$，该分数随 $E_{\\mathrm{eff}}$ 单调增加，并且在与 $\\log E_{\\mathrm{eff}}$ 的关系图中呈现S形曲线。\n\n基于这些依据以及标准的单调性和量纲一致性论证，推导出一个关于归一化关键尺寸 $y$ 的S形响应模型。该模型应仅依赖于无量纲比率 $E_{\\mathrm{eff}} / E_T$ 和对比度 $\\gamma$，并与极限条件 $y \\to 0$（当 $E_{\\mathrm{eff}} \\ll E_T$ 时）和 $y \\to 1$（当 $E_{\\mathrm{eff}} \\gg E_T$ 时）保持一致。使用此模型进行非线性最小二乘拟合，从无噪声数据集中提取 $\\gamma$ 和 $E_T$。然后，在耀斑 $F$ 未知且必须被共同估计的情况下，评估参数的可辨识性。使用基于雅可比矩阵的局部可辨识性诊断方法：关于拟合参数的灵敏度矩阵（雅可比矩阵）必须具有一个良态的格拉姆矩阵；如果雅可比矩阵的条件数超过一个固定的阈值，则声明参数为可辨识性差。\n\n实现一个程序，对指定的测试套件执行以下任务。在下述所有项目中，剂量单位为 $\\mathrm{mJ/cm^2}$，角度不出现。报告任何拟合的 $E_T$ 值时，单位为 $\\mathrm{mJ/cm^2}$，报告 $\\gamma$ 为无量纲值。当要求输出布尔值时，输出字面上的 True 或 False。所有浮点数输出必须四舍五入到六位小数。\n\n- 测试用例A（无耀斑，在已知 $F$ 的情况下拟合 $\\gamma$ 和 $E_T$）：使用真实参数 $\\gamma = 3.0$，$E_T = 20.0\\,\\mathrm{mJ/cm^2}$，$F = 0.0\\,\\mathrm{mJ/cm^2}$。使用剂量样本 $E \\in \\left[ 5, 10, 15, 20, 25, 30, 40, 60 \\right]\\,\\mathrm{mJ/cm^2}$。根据您推导的S形模型生成相应的无噪声归一化关键尺寸数据 $y$，并在保持 $F$ 固定为已知值的情况下，仅拟合 $\\gamma$ 和 $E_T$。将此用例的拟合 $\\gamma$ 和拟合 $E_T$ 作为两个浮点数输出。\n\n- 测试用例B（已知耀斑，拟合 $\\gamma$ 和 $E_T$）：使用真实参数 $\\gamma = 2.0$，$E_T = 30.0\\,\\mathrm{mJ/cm^2}$，$F = 5.0\\,\\mathrm{mJ/cm^2}$。使用剂量样本 $E \\in \\left[ 0, 5, 10, 15, 20, 30, 50 \\right]\\,\\mathrm{mJ/cm^2}$。生成无噪声数据 $y$，并在保持 $F$ 固定为已知值的情况下，仅拟合 $\\gamma$ 和 $E_T$。将此用例的拟合 $\\gamma$ 和拟合 $E_T$ 作为两个浮点数输出。\n\n- 测试用例C（未知耀斑，仅使用高剂量数据，可辨识性检查）：使用真实参数 $\\gamma = 2.0$，$E_T = 30.0\\,\\mathrm{mJ/cm^2}$，$F = 5.0\\,\\mathrm{mJ/cm^2}$。使用高剂量样本 $E \\in \\left[ 50, 100, 150, 200 \\right]\\,\\mathrm{mJ/cm^2}$。生成无噪声数据 $y$，并同时拟合参数三元组 $\\left( \\gamma, E_T, F \\right)$。计算模型残差相对于在解处评估的拟合参数的雅可比矩阵，并将其条件数计算为其最大奇异值与最小奇异值之比。如果此雅可比矩阵条件数超过 $10^8$，则声明该三元组为可辨识性差。为此用例输出一个布尔值：如果可辨识性差，则为 True，否则为 False。\n\n- 测试用例D（未知耀斑，包含低剂量数据，可辨识性检查）：使用真实参数 $\\gamma = 2.0$，$E_T = 30.0\\,\\mathrm{mJ/cm^2}$，$F = 5.0\\,\\mathrm{mJ/cm^2}$。使用剂量 $E \\in \\left[ 0, 2, 4, 6, 8, 10, 20, 40 \\right]\\,\\mathrm{mJ/cm^2}$。生成无噪声数据 $y$，并拟合参数三元组 $\\left( \\gamma, E_T, F \\right)$。如上计算雅可比矩阵条件数，如果超过 $10^8$，则声明为可辨识性差。为此用例输出一个布尔值。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为\n$\\left[ \\widehat{\\gamma}_A, \\widehat{E_T}_A, \\widehat{\\gamma}_B, \\widehat{E_T}_B, \\mathrm{poorID}_C, \\mathrm{poorID}_D \\right]$，\n其中 $\\widehat{\\gamma}_A$ 和 $\\widehat{E_T}_A$ 是测试用例A的拟合值，$\\widehat{\\gamma}_B$ 和 $\\widehat{E_T}_B$ 是测试用例B的拟合值，而 $\\mathrm{poorID}_C$、$\\mathrm{poorID}_D$ 分别是测试用例C和D的布尔值。在打印的浮点数值中，任何 $E_T$ 都应以 $\\mathrm{mJ/cm^2}$ 为单位表示，并四舍五入到六位小数。不得打印任何其他文本。",
            "solution": "从剂量到归一化关键尺寸的映射植根于光刻胶的清除物理学。首先，控制去保护反应的有效曝光剂量是强度的时间积分，而杂散光为此剂量贡献了一个近乎均匀的常数。因此，有效剂量为 $E_{\\mathrm{eff}} = E + F$，其中 $E$ 是设定的剂量，$F$ 是耀斑背景，单位均为 $\\mathrm{mJ/cm^2}$。\n\n其次，由于随机的去保护反应、猝灭剂的消耗以及显影动力学，正性化学放大光刻胶在清除分数与 $\\log E_{\\mathrm{eff}}$ 的关系图上呈现出S形过渡。光刻胶对比度 $\\gamma$ 表征了此过渡的陡峭程度，而特征阈值剂量 $E_T$ 则设定了清除发生的尺度。量纲一致性和单调性要求归一化响应 $y$ 是无量纲组合 $E_{\\mathrm{eff}} / E_T$ 的函数，并且当 $E_{\\mathrm{eff}} / E_T \\to 0$ 时 $y \\to 0$，当 $E_{\\mathrm{eff}} / E_T \\to \\infty$ 时 $y \\to 1$。\n\n满足这些要求并在实践中广泛使用的一个最小模型是根据比率 $E_{\\mathrm{eff}} / E_T$ 和对比度 $\\gamma$ 写出的Hill型S曲线：\n$$\ny(E; \\gamma, E_T, F) \\;=\\; \\frac{1}{1 + \\left( \\frac{E_T}{E + F} \\right)^{\\gamma}},\n$$\n对于有限的 $E + F > 0$，有 $0 < y < 1$；当 $E + F \\ll E_T$ 时，$y \\to 0$；当 $E + F \\gg E_T$ 时，$y \\to 1$。该模型抓住了核心物理原理：$y$ 随 $E_{\\mathrm{eff}}$ 单调增加，过渡的尺度由 $E_T$ 控制，陡峭程度由 $\\gamma$ 控制。\n\n对于参数估计，我们建立一个非线性最小二乘问题。给定剂量 $\\{ E_i \\}_{i=1}^N$ 和观测值 $\\{ y_i \\}_{i=1}^N$，定义残差\n$$\nr_i(\\boldsymbol{\\theta}) = y(E_i; \\boldsymbol{\\theta}) - y_i,\n$$\n其中当 $F$ 已知时，$\\boldsymbol{\\theta} = (\\gamma, E_T)$；当 $F$ 未知时，$\\boldsymbol{\\theta} = (\\gamma, E_T, F)$。最小二乘估计在满足正性约束条件 $\\gamma > 0$，$E_T > 0$ 和 $F \\ge 0$ 的情况下，最小化 $\\frac{1}{2} \\sum_{i=1}^N r_i(\\boldsymbol{\\theta})^2$。\n\n为了在拟合所有三个参数时评估局部可辨识性，需要考察雅可比矩阵 $J \\in \\mathbb{R}^{N \\times p}$，其元素为在解处计算的 $J_{i,j} = \\partial r_i / \\partial \\theta_j$，其中 $p$ 是参数的数量。由于 $r_i = y_i(\\boldsymbol{\\theta}) - y_i^{\\text{obs}}$ 且 $y_i^{\\text{obs}}$ 是常数，因此 $J_{i,j} = \\partial y(E_i; \\boldsymbol{\\theta}) / \\partial \\theta_j$。使用上述Hill模型，引入 $E_{\\mathrm{eff},i} = E_i + F$ 和 $r_i^\\star = \\left(\\frac{E_T}{E_{\\mathrm{eff},i}}\\right)^\\gamma$。那么\n$$\ny_i = \\frac{1}{1 + r_i^\\star}, \\quad \\frac{\\partial y_i}{\\partial \\gamma} = - \\frac{r_i^\\star \\ln\\left(\\frac{E_T}{E_{\\mathrm{eff},i}}\\right)}{(1 + r_i^\\star)^2}, \\quad \\frac{\\partial y_i}{\\partial E_T} = - \\frac{\\gamma \\, r_i^\\star}{E_T \\, (1 + r_i^\\star)^2}, \\quad \\frac{\\partial y_i}{\\partial F} = \\frac{\\gamma \\, r_i^\\star}{E_{\\mathrm{eff},i} \\, (1 + r_i^\\star)^2}.\n$$\n对于同方差高斯噪声，费雪信息矩阵与 $J^\\top J$ 成正比，因此局部可辨识性的一个必要条件是 $J$ 为满列秩且具有一个适中的条件数。我们通过计算 $J$ 的奇异值 $\\sigma_{\\max} \\ge \\cdots \\ge \\sigma_{\\min} > 0$ 并构造条件数 $\\kappa(J) = \\sigma_{\\max} / \\sigma_{\\min}$ 来诊断可辨识性差的问题。如果 $\\kappa(J)$ 超过一个大阈值（例如 $10^8$），则 $J$ 的列向量近似线性相关，这表明存在强烈的参数相关性和较差的局部可辨识性。\n\n在四个测试用例中：\n\n- 在测试用例A中，当 $F = 0$ 已知且剂量范围跨越 $E_T$ 上下时，双参数拟合是良态的，当数据无噪声时，估计值 $\\widehat{\\gamma}$ 和 $\\widehat{E_T}$ 能够恢复生成数据的真实值。\n\n- 在测试用例B中，当 $F = 5.0$ 已知且剂量网格包含 $E = 0$ 时，双参数拟合同样能得到生成数据的真实参数。\n\n- 在测试用例C中，当仅使用高剂量 $E \\gg F$ 并且共同估计 $F$ 时，$y$ 对 $F$ 的灵敏度被抑制，因为 $E + F \\approx E$，所以 $\\partial y / \\partial F \\approx 0$ 在所有样本上都成立。此外，$E_T$ 的变化可以补偿 $F$ 的微小变化，使得雅可比矩阵的列向量近似共线。因此，$J$ 是病态的，$\\kappa(J)$ 很大，触发了可辨识性差的标志。\n\n- 在测试用例D中，由于包含了 $E = 0$ 和其他低剂量，模型在 $E_{\\mathrm{eff}} \\sim E_T$ 的强非线性区域进行采样。在此区域，$\\partial y / \\partial F$ 的值很可观，并且在性质上与 $\\partial y / \\partial E_T$ 和 $\\partial y / \\partial \\gamma$ 有明显区别，从而恢复了可辨识性，并得到一个适中的 $\\kappa(J)$。\n\n从算法上讲，该程序：\n\n1. 定义Hill模型 $y(E; \\gamma, E_T, F)$。\n2. 对每个测试用例，使用指定的真实参数和 $E$ 值生成无噪声的 $y$ 数据。\n3. 使用初始猜测值和正性边界来求解约束非线性最小二乘问题，在 $F$ 已知时拟合 $(\\gamma, E_T)$，否则拟合 $(\\gamma, E_T, F)$。\n4. 在拟合参数处解析地计算雅可比矩阵，并评估三参数拟合的可辨识性指标 $\\kappa(J)$。\n5. 以要求的聚合格式打印输出，将浮点数四舍五入到六位小数，并在 $E_T$ 值中隐式使用 $\\mathrm{mJ/cm^2}$ 单位。\n\n由于数据是无噪声的，并且用于拟合的模型与生成数据的模型相匹配，因此在测试用例A和B中，拟合的 $\\widehat{\\gamma}$ 和 $\\widehat{E_T}$ 在数值公差范围内精确地恢复了真实值。在测试用例C中，雅可比矩阵条件数超过 $10^8$，表明可辨识性差；而在测试用例D中则没有超过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef hill_cd(E, gamma, ET, F):\n    # Normalized CD: 1 / (1 + (ET / (E + F))^gamma)\n    Eeff = E + F\n    # Avoid divide-by-zero for any Eeff = 0\n    if np.any(Eeff = 0):\n        # Handle cases where E+F could be non-positive, though problem constraints should prevent this\n        # Return a large value to guide optimizer away\n        return np.full_like(E, 1e6)\n    r = (ET / Eeff) ** gamma\n    y = 1.0 / (1.0 + r)\n    return y\n\ndef residuals_two_params(x, E, y_obs, F_fixed):\n    gamma, ET = x\n    y_pred = hill_cd(E, gamma, ET, F_fixed)\n    return y_pred - y_obs\n\ndef residuals_three_params(x, E, y_obs):\n    gamma, ET, F = x\n    y_pred = hill_cd(E, gamma, ET, F)\n    return y_pred - y_obs\n\ndef jacobian_y_wrt_params(E, gamma, ET, F, fit_F):\n    # Compute analytic Jacobian of y wrt parameters at given params.\n    # If fit_F is False: return Nx2 Jacobian for params [gamma, ET]\n    # If fit_F is True: return Nx3 Jacobian for params [gamma, ET, F]\n    Eeff = E + F\n    # Add a small epsilon to avoid log(0) or division by zero in derivatives\n    epsilon = 1e-15\n    Eeff[Eeff = 0] = epsilon\n    ET = max(ET, epsilon)\n\n    r = (ET / Eeff) ** gamma\n    denom = (1.0 + r) ** 2\n    \n    # Partial derivatives\n    # dy/dgamma\n    dyg = - (r * np.log(ET / Eeff)) / denom\n    # dy/dET\n    dyET = - (gamma * r) / (ET * denom)\n    \n    J_cols = [dyg, dyET]\n    if fit_F:\n        # dy/dF\n        dyF = (gamma * r) / (Eeff * denom)\n        J_cols.append(dyF)\n\n    J = np.vstack(J_cols).T\n    return J\n\ndef condition_number_of_jacobian(E, gamma, ET, F):\n    # Jacobian of residuals equals Jacobian of y since y_obs is constant\n    J = jacobian_y_wrt_params(E, gamma, ET, F, fit_F=True)\n    # Compute condition number via SVD\n    # Add a tiny epsilon to avoid 0 division if singular (though that would also indicate poor ID)\n    try:\n        U, svals, Vt = np.linalg.svd(J, full_matrices=False)\n        smax = np.max(svals) if svals.size > 0 else 0.0\n        smin = np.min(svals) if svals.size > 0 else 0.0\n        if smin == 0.0:\n            return np.inf\n        return float(smax / smin)\n    except np.linalg.LinAlgError:\n        return np.inf\n\n\ndef fit_two_params(E, y_obs, F_fixed):\n    # Bounds: gamma in (1e-4, 50), ET in (1e-3, 1e3)\n    bounds = ([1e-4, 1e-3], [50.0, 1e3])\n    # Initial guess: gamma=2, ET ~ median(E+F)\n    ET0 = max(1e-3, np.median(E + F_fixed))\n    x0 = np.array([2.0, ET0], dtype=float)\n    res = least_squares(residuals_two_params, x0, bounds=bounds, args=(E, y_obs, F_fixed), xtol=1e-14, ftol=1e-14, gtol=1e-14, max_nfev=10000)\n    return res.x\n\ndef fit_three_params(E, y_obs):\n    # Bounds: gamma in (1e-4, 50), ET in (1e-3, 1e3), F in [0, 1e3]\n    bounds = ([1e-4, 1e-3, 0.0], [50.0, 1e3, 1e3])\n    # Initial guess: gamma=2, ET ~ median(E+1), F=1\n    ET0 = max(1e-3, np.median(E + 1.0))\n    x0 = np.array([2.0, ET0, 1.0], dtype=float)\n    res = least_squares(residuals_three_params, x0, bounds=bounds, args=(E, y_obs), xtol=1e-14, ftol=1e-14, gtol=1e-14, max_nfev=20000)\n    return res.x\n\ndef fmt(x):\n    if isinstance(x, (float, np.floating)):\n        return f\"{x:.6f}\"\n    if isinstance(x, (bool, np.bool_)):\n        return \"True\" if bool(x) else \"False\"\n    if isinstance(x, (int, np.integer)):\n        return str(int(x))\n    return str(x)\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    results = []\n\n    # Test case A: gamma=3.0, ET=20.0, F=0.0; E=[5,10,15,20,25,30,40,60]; fit gamma and ET with F fixed\n    gamma_A_true = 3.0\n    ET_A_true = 20.0\n    F_A = 0.0\n    E_A = np.array([5.0, 10.0, 15.0, 20.0, 25.0, 30.0, 40.0, 60.0])\n    y_A = hill_cd(E_A, gamma_A_true, ET_A_true, F_A)\n    gamma_A_hat, ET_A_hat = fit_two_params(E_A, y_A, F_A)\n    results.extend([gamma_A_hat, ET_A_hat])\n\n    # Test case B: gamma=2.0, ET=30.0, F=5.0; E=[0,5,10,15,20,30,50]; fit gamma and ET with F fixed\n    gamma_B_true = 2.0\n    ET_B_true = 30.0\n    F_B = 5.0\n    E_B = np.array([0.0, 5.0, 10.0, 15.0, 20.0, 30.0, 50.0])\n    y_B = hill_cd(E_B, gamma_B_true, ET_B_true, F_B)\n    gamma_B_hat, ET_B_hat = fit_two_params(E_B, y_B, F_B)\n    results.extend([gamma_B_hat, ET_B_hat])\n\n    # Test case C: gamma=2.0, ET=30.0, F=5.0; E=[50,100,150,200]; fit gamma, ET, F and check identifiability\n    gamma_C_true = 2.0\n    ET_C_true = 30.0\n    F_C_true = 5.0\n    E_C = np.array([50.0, 100.0, 150.0, 200.0])\n    y_C = hill_cd(E_C, gamma_C_true, ET_C_true, F_C_true)\n    gamma_C_hat, ET_C_hat, F_C_hat = fit_three_params(E_C, y_C)\n    kappa_C = condition_number_of_jacobian(E_C, gamma_C_hat, ET_C_hat, F_C_hat)\n    poorID_C = (kappa_C > 1e8)\n    results.append(poorID_C)\n\n    # Test case D: gamma=2.0, ET=30.0, F=5.0; E=[0,2,4,6,8,10,20,40]; fit gamma, ET, F and check identifiability\n    gamma_D_true = 2.0\n    ET_D_true = 30.0\n    F_D_true = 5.0\n    E_D = np.array([0.0, 2.0, 4.0, 6.0, 8.0, 10.0, 20.0, 40.0])\n    y_D = hill_cd(E_D, gamma_D_true, ET_D_true, F_D_true)\n    gamma_D_hat, ET_D_hat, F_D_hat = fit_three_params(E_D, y_D)\n    kappa_D = condition_number_of_jacobian(E_D, gamma_D_hat, ET_D_hat, F_D_hat)\n    poorID_D = (kappa_D > 1e8)\n    results.append(poorID_D)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(fmt(r) for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在曝光形成潜像之后，显影步骤会物理上溶解光刻胶，从而形成最终的图形。这是一个动态过程，其结果决定了特征的最终形状和尺寸。我们可以使用移动边界模型来模拟这个过程，其中边界的溶解速度取决于光刻胶中被保护基团的局部浓度。这项练习让你能够构建一个简单的光刻胶显影模拟器。更重要的是，它展示了如何使用此类模型来优化工艺的稳健性，特别是通过寻找一个最佳显影时间，以最小化最终CD对初始潜像中噪声的敏感度。这是设计稳定制造工艺的核心概念。",
            "id": "4288258",
            "problem": "您需要实现一个一维移动边界模型，用于模拟光刻胶线条的显影过程，并计算关键尺寸（CD）如何依赖于显影时间和潜像噪声。目标是确定能够使关键尺寸对小幅度潜像噪声敏感度最小化的显影时间。该问题的背景是集成电路和电子设计自动化（EDA）中的光刻图形转移。关键尺寸（CD）定义为显影后抗蚀剂特征的最终线宽。\n\n基本原理：\n- 在正性光刻胶中，溶解速率随去保护比例的增加而增加。设 $c(x)$ 为曝光和曝光后烘烤（PEB）之后位置 $x$ 处的去保护比例，其中 $c(x) \\in [0,1]$。\n- 移动边界模型假设横向溶解前沿位置 $x_b(t)$ 从初始边缘向内移动，其局部速度等于在边界处评估的溶解速率。具体来说，右边缘的边界初始化为 $x_b(0) = W_0/2$，其中 $W_0$ 是初始线宽，并根据以下公式演化：\n$$\n\\frac{dx_b}{dt} = - R\\big(c(x_b(t))\\big),\n$$\n在时间 $t$ 的最终关键尺寸由下式给出：\n$$\n\\mathrm{CD}(t) = \\max\\left(0,\\,2\\,x_b(t)\\right).\n$$\n- 使用 S 型溶解速率模型（在化学放大抗蚀剂中经过充分验证），其中 $R(c)$ 为：\n$$\nR(c) = R_{\\min} + \\left(R_{\\max} - R_{\\min}\\right)\\,\\frac{c^n}{c^n + c_{\\mathrm{th}}^n},\n$$\n其中 $R_{\\min}  0$，$R_{\\max}  R_{\\min}$，$n \\geq 1$ 且 $c_{\\mathrm{th}} \\in (0,1)$。\n\n潜像模型：\n- 线条上的基准去保护比例轮廓是从线条内部的低值平滑过渡到外部的高值：\n$$\nc_0(x) = c_{\\min} + \\left(c_{\\max} - c_{\\min}\\right)\\,\\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{|x| - W_0/2}{\\sigma}\\right)\\right),\n$$\n其中 $c_{\\min} \\in [0,1)$，$c_{\\max} \\in (0,1]$，且 $\\sigma  0$ 控制边缘斜率。\n- 潜像噪声被建模为添加到 $c_0(x)$ 上并裁剪到 $[0,1]$ 范围内的小幅度空间正弦波：\n$$\nc(x;A) = \\mathrm{clip}\\left(c_0(x) + A \\cos\\left(\\frac{2\\pi x}{\\lambda}\\right),\\,0,\\,1\\right),\n$$\n其中 $A$ 是噪声幅度（无量纲），$\\lambda  0$ 是空间周期（单位为 $\\mathrm{nm}$）。\n\n灵敏度定义：\n- 对于固定的 $t$，通过围绕零幅度的中心差分来定义 CD 对潜像噪声幅度的灵敏度：\n$$\nS(t) \\approx \\frac{\\mathrm{CD}(t; +A) - \\mathrm{CD}(t; -A)}{2\\,A},\n$$\n其中 $\\mathrm{CD}(t; A)$ 是使用 $c(x;A)$ 计算出的时间 $t$ 处的 CD。\n\n任务：\n- 对于每个测试用例，模拟三种幅度 $A \\in \\{0, +A_0, -A_0\\}$ 下的边界运动，获得作为时间 $t$ 函数的 $\\mathrm{CD}(t)$，并为一组离散时间点 $t_k$ 计算 $S(t)$。\n- 将最小化域限制在 $t \\in [0, T_{\\mathrm{clear}}]$，其中 $T_{\\mathrm{clear}}$ 是使 $\\mathrm{CD}(t; 0) = 0$ 的最早时间。如果线条在给定的最大模拟时间 $T_{\\max}$ 之前没有被完全清除，则使用 $T_{\\mathrm{clear}} = T_{\\max}$。\n- 在离散集合中确定使 $|S(t)|$ 最小化的时间 $t^\\star$。报告 $t^\\star$（单位为 $\\mathrm{s}$），$\\mathrm{CD}(t^\\star;0)$（单位为 $\\mathrm{nm}$）和 $S(t^\\star)$（单位为 $\\mathrm{nm}$ 每单位噪声幅度）。\n\n数值实现要求：\n- 对移动边界常微分方程使用固定时间步长积分，时间步长 $\\Delta t = 10^{-3}\\,\\mathrm{s}$。\n- 在每个步骤中计算并存储 $x_b(t)$ 和 $\\mathrm{CD}(t)$，直到达到 $T_{\\max}$ 或 $x_b(t) \\le 0$。\n- 在步长为 $\\Delta t_{\\mathrm{samp}} = 5 \\times 10^{-2}\\,\\mathrm{s}$ 的均匀采样网格上评估 $S(t)$。\n- 确保在每次边界评估时将 $c(x;A)$ 裁剪到 $[0,1]$ 范围内。\n\n单位：\n- 显影时间以秒（$\\mathrm{s}$）为单位报告。\n- 关键尺寸以纳米（$\\mathrm{nm}$）为单位报告。\n- 灵敏度以纳米每单位幅度（$\\mathrm{nm}$）为单位报告。\n\n测试套件：\n为以下三个科学上合理的测试用例提供结果：\n\n1. 典型特征：\n   - $W_0 = 40\\,\\mathrm{nm}$，$\\sigma = 5\\,\\mathrm{nm}$，$A_0 = 0.02$，$\\lambda = 8\\,\\mathrm{nm}$，\n   - $R_{\\min} = 0.2\\,\\mathrm{nm/s}$，$R_{\\max} = 5.0\\,\\mathrm{nm/s}$，$c_{\\mathrm{th}} = 0.5$，$n=4$，\n   - $c_{\\min} = 0.05$，$c_{\\max} = 0.95$，$T_{\\max} = 12\\,\\mathrm{s}$。\n\n2. 边缘更陡、噪声更高的较窄特征：\n   - $W_0 = 20\\,\\mathrm{nm}$，$\\sigma = 3\\,\\mathrm{nm}$，$A_0 = 0.03$，$\\lambda = 6\\,\\mathrm{nm}$，\n   - $R_{\\min} = 0.2\\,\\mathrm{nm/s}$，$R_{\\max} = 5.0\\,\\mathrm{nm/s}$，$c_{\\mathrm{th}} = 0.5$，$n=4$，\n   - $c_{\\min} = 0.05$，$c_{\\max} = 0.95$，$T_{\\max} = 8\\,\\mathrm{s}$。\n\n3. 边缘更平滑、噪声更低的较宽特征：\n   - $W_0 = 60\\,\\mathrm{nm}$，$\\sigma = 7\\,\\mathrm{nm}$，$A_0 = 0.015$，$\\lambda = 12\\,\\mathrm{nm}$，\n   - $R_{\\min} = 0.2\\,\\mathrm{nm/s}$，$R_{\\max} = 5.0\\,\\mathrm{nm/s}$，$c_{\\mathrm{th}} = 0.5$，$n=4$，\n   - $c_{\\min} = 0.05$，$c_{\\max} = 0.95$，$T_{\\max} = 16\\,\\mathrm{s}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的结果，形式为三个列表的列表：\n$$\n\\left[\\left[t^\\star_1,\\ \\mathrm{CD}_1(t^\\star_1),\\ S_1(t^\\star_1)\\right],\\ \\left[t^\\star_2,\\ \\mathrm{CD}_2(t^\\star_2),\\ S_2(t^\\star_2)\\right],\\ \\left[t^\\star_3,\\ \\mathrm{CD}_3(t^\\star_3),\\ S_3(t^\\star_3)\\right]\\right],\n$$\n包含数值。不应打印任何额外文本。使用上述指定的单位；数值应作为不带单位符号的纯数字输出，并统一四舍五入到六位小数。",
            "solution": "该问题已根据指定标准进行验证，并被确定为一个有效的科学问题。\n\n### 步骤 1：提取已知条件\n- **边界演化常微分方程**：$\\frac{dx_b}{dt} = - R\\big(c(x_b(t))\\big)$，初始条件为 $x_b(0) = W_0/2$。\n- **关键尺寸 (CD)**：$\\mathrm{CD}(t) = \\max\\left(0,\\,2\\,x_b(t)\\right)$。\n- **溶解速率模型**：$R(c) = R_{\\min} + \\left(R_{\\max} - R_{\\min}\\right)\\,\\frac{c^n}{c^n + c_{\\mathrm{th}}^n}$。\n- **基准潜像轮廓**：$c_0(x) = c_{\\min} + \\left(c_{\\max} - c_{\\min}\\right)\\,\\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{|x| - W_0/2}{\\sigma}\\right)\\right)$。\n- **含噪声的潜像轮廓**：$c(x;A) = \\mathrm{clip}\\left(c_0(x) + A \\cos\\left(\\frac{2\\pi x}{\\lambda}\\right),\\,0,\\,1\\right)$。\n- **CD 灵敏度**：$S(t) \\approx \\frac{\\mathrm{CD}(t; +A_0) - \\mathrm{CD}(t; -A_0)}{2\\,A_0}$。\n- **最小化任务**：在 $[0, T_{\\mathrm{clear}}]$ 内的离散采样时间点集合中，找到使 $|S(t)|$ 最小化的 $t^\\star$。$T_{\\mathrm{clear}}$ 是 $\\mathrm{CD}(t; 0)=0$ 的时刻。\n- **数值参数**：积分时间步长 $\\Delta t = 10^{-3}\\ \\mathrm{s}$，灵敏度采样时间步长 $\\Delta t_{\\mathrm{samp}} = 5\\times 10^{-2}\\ \\mathrm{s}$。\n- **测试用例**：提供了三组参数 $(W_0, \\sigma, A_0, \\lambda, T_{\\max})$，以及共同参数 $(R_{\\min}, R_{\\max}, c_{\\mathrm{th}}, n, c_{\\min}, c_{\\max})$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据、良定性且客观。\n- **科学依据**：该模型基于光刻工艺模拟中的既定原理。移动边界模型是程函方程的一维简化，S 型溶解速率函数是广泛使用的 Mack 模型的一种变体，双曲正切函数是潜像轮廓的标准表示方法。\n- **良定性**：该问题已用所有必要的方程、参数和数值程序完全指定。控制边界运动的常微分方程定义明确，所涉及的函数是连续且有界的，确保了稳定的解。寻找数值计算函数的最小值的任务是一个标准的计算问题。\n- **客观性**：该问题使用精确的数学语言定义，没有歧义或主观论断。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将按照指定的方法学开发一个解决方案。\n\n### 解决方案设计\n\n该问题要求模拟光刻胶线条的显影过程，并分析其对潜像噪声的敏感度。解决方案分为三个主要部分：边界演化的数值模拟、关键尺寸（CD）敏感度的计算以及为找到最小敏感度时间而进行的优化。\n\n**1. 数学模型构建**\n\n模型的核心是光刻胶线条右侧边界 $x_b(t)$ 的演化，它从 $x_b(0) = W_0/2$ 开始向内移动。其速度由局部溶解速率决定，而溶解速率又取决于局部的去保护比例 $c(x)$。这由以下一阶常微分方程（ODE）描述：\n$$ \\frac{dx_b}{dt} = - R\\big(c(x_b(t))\\big) $$\n\n去保护比例 $c(x)$ 包括一个基准轮廓 $c_0(x)$ 和一个振幅为 $A$、空间周期为 $\\lambda$ 的正弦噪声项。组合后的轮廓被裁剪到物理上有意义的范围 $[0, 1]$ 内：\n$$ c(x;A) = \\mathrm{clip}\\left( c_{\\min} + \\left(c_{\\max} - c_{\\min}\\right)\\,\\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{|x| - W_0/2}{\\sigma}\\right)\\right) + A \\cos\\left(\\frac{2\\pi x}{\\lambda}\\right),\\,0,\\,1 \\right) $$\n\n溶解速率 $R(c)$ 由一个 S 型函数给出，这是化学放大抗蚀剂的特征：\n$$ R(c) = R_{\\min} + \\left(R_{\\max} - R_{\\min}\\right)\\,\\frac{c^n}{c^n + c_{\\mathrm{th}}^n} $$\n该函数为低 $c$ 值提供缓慢的蚀刻速率（$R_{\\min}$），为高 $c$ 值提供快速的蚀刻速率（$R_{\\max}$），其间的急剧转变由阈值 $c_{\\mathrm{th}}$ 和对比度参数 $n$ 控制。\n\n**2. 数值模拟算法**\n\n为了求解 $x_b(t)$ 的常微分方程，我们采用显式前向欧拉法，鉴于给定的固定小时间步长 $\\Delta t = 10^{-3} \\ \\mathrm{s}$，这是一个直接且合适的选择。迭代更新规则为：\n$$ x_b(t_{k+1}) = x_b(t_k) - \\Delta t \\cdot R\\big(c(x_b(t_k); A)\\big) $$\n其中 $t_{k+1} = t_k + \\Delta t$。从 $x_b(0) = W_0/2$ 开始，重复此过程，直到边界完全退回（$x_b(t) \\le 0$）或达到最大模拟时间 $T_{\\max}$。\n\n对于每个测试用例，此模拟执行三次，以获得 CD 随时间的演化，$\\mathrm{CD}(t) = 2x_b(t)$（对于 $x_b(t)  0$），对应于三种噪声情景：\n- $\\mathrm{CD}(t; 0)$，用于基准情况（$A=0$）。\n- $\\mathrm{CD}(t; +A_0)$，用于正噪声幅度。\n- $\\mathrm{CD}(t; -A_0)$，用于负噪声幅度。\n\n每个模拟的时间序列数据 $(t, \\mathrm{CD}(t))$ 都被存储起来。\n\n**3. 灵敏度分析与优化**\n\n最后一步是计算灵敏度 $S(t)$，并找到使其幅度最小化的显影时间 $t^\\star$。\n\n首先，我们确定分析的有效时间域。即 $[0, T_{\\mathrm{clear}}]$，其中 $T_{\\mathrm{clear}}$ 是基准情况（$A=0$）下光刻胶的清除时间，定义为使 $\\mathrm{CD}(t; 0) = 0$ 的最早时间 $t$。如果光刻胶线条在 $T_{\\max}$ 之前没有被清除，我们设置 $T_{\\mathrm{clear}} = T_{\\max}$。\n\n接下来，我们在区间 $[0, T_{\\mathrm{clear}}]$ 上建立一个时间 $t_k$ 的均匀采样网格，步长为 $\\Delta t_{\\mathrm{samp}} = 5 \\times 10^{-2} \\ \\mathrm{s}$。在更精细的网格 $\\Delta t$ 上生成的三条模拟 CD 轨迹，通过线性插值重采样到这个公共网格上。设插值后的值为 $\\mathrm{CD}_{\\mathrm{samp}}(t_k; A)$。\n\n然后使用中心差分公式近似计算每个采样点的灵敏度 $S(t_k)$：\n$$ S(t_k) = \\frac{\\mathrm{CD}_{\\mathrm{samp}}(t_k; +A_0) - \\mathrm{CD}_{\\mathrm{samp}}(t_k; -A_0)}{2\\,A_0} $$\n这就得到了一系列离散的灵敏度值 $S(t_k)$。\n\n最后，我们找到使灵敏度绝对值 $|S(t_k)|$ 最小化的索引 $k^\\star$。最佳显影时间为 $t^\\star = t_{k^\\star}$。附带的指标是此时的基准 CD，$\\mathrm{CD}(t^\\star; 0) = \\mathrm{CD}_{\\mathrm{samp}}(t_{k^\\star}; 0)$，以及灵敏度本身，$S(t^\\star) = S(t_{k^\\star})$。这三个值——$(t^\\star, \\mathrm{CD}(t^\\star; 0), S(t^\\star))$——构成一个测试用例的结果。对所有三个提供的测试用例重复整个过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run simulations for all test cases and print the results.\n    \"\"\"\n\n    # Common parameters for all test cases\n    R_min = 0.2  # nm/s\n    R_max = 5.0  # nm/s\n    c_th = 0.5   # dimensionless\n    n = 4.0      # dimensionless\n    c_min = 0.05 # dimensionless\n    c_max = 0.95 # dimensionless\n    \n    # Numerical method parameters\n    dt = 1e-3    # s\n    dt_samp = 5e-2 # s\n\n    test_cases = [\n        {\n            \"W0\": 40.0, \"sigma\": 5.0, \"A0\": 0.02, \"lambda_val\": 8.0, \n            \"T_max\": 12.0\n        },\n        {\n            \"W0\": 20.0, \"sigma\": 3.0, \"A0\": 0.03, \"lambda_val\": 6.0, \n            \"T_max\": 8.0\n        },\n        {\n            \"W0\": 60.0, \"sigma\": 7.0, \"A0\": 0.015, \"lambda_val\": 12.0, \n            \"T_max\": 16.0\n        },\n    ]\n\n    all_results = []\n\n    for case_params in test_cases:\n        # Define model functions for the current case\n        def c0(x, p):\n            arg = (np.abs(x) - p[\"W0\"] / 2.0) / p[\"sigma\"]\n            return c_min + (c_max - c_min) * 0.5 * (1.0 + np.tanh(arg))\n\n        def c_noisy(x, A, p):\n            val = c0(x, p) + A * np.cos(2.0 * np.pi * x / p[\"lambda_val\"])\n            return np.clip(val, 0.0, 1.0)\n        \n        def R(c_val):\n            return R_min + (R_max - R_min) * (c_val**n) / (c_val**n + c_th**n)\n        \n        def simulate_cd_evolution(A, p):\n            \"\"\"Simulates the boundary evolution for a given noise amplitude A.\"\"\"\n            t = 0.0\n            xb = p[\"W0\"] / 2.0\n            \n            # Using lists for dynamic size, pre-allocation is possible but more complex\n            t_series = [t]\n            xb_series = [xb]\n\n            max_steps = int(p[\"T_max\"] / dt)\n            for _ in range(max_steps):\n                c_at_boundary = c_noisy(xb, A, p)\n                rate = R(c_at_boundary)\n                xb -= rate * dt\n                t += dt\n\n                if xb = 0:\n                    xb = 0.0\n                    t_series.append(t)\n                    xb_series.append(xb)\n                    break \n                \n                t_series.append(t)\n                xb_series.append(xb)\n\n            t_series_np = np.array(t_series)\n            cd_series_np = np.maximum(0.0, 2.0 * np.array(xb_series))\n            \n            return t_series_np, cd_series_np\n\n        # Run simulations for A=0, +A0, -A0\n        A0 = case_params[\"A0\"]\n        t_0, cd_0 = simulate_cd_evolution(0.0, case_params)\n        t_pA, cd_pA = simulate_cd_evolution(A0, case_params)\n        t_nA, cd_nA = simulate_cd_evolution(-A0, case_params)\n\n        # Determine T_clear\n        clear_indices = np.where(cd_0 == 0.0)[0]\n        if len(clear_indices) > 0:\n            T_clear = t_0[clear_indices[0]]\n        else:\n            T_clear = case_params[\"T_max\"]\n\n        # Create sampling grid\n        t_samples = np.arange(0, T_clear, dt_samp)\n        if T_clear not in t_samples and t_samples.size > 0 and t_samples[-1]  T_clear:\n             t_samples = np.append(t_samples, T_clear)\n        if t_samples.size == 0:\n            t_samples = np.array([0, T_clear])\n\n        # Interpolate CD values onto the sampling grid\n        cd_samp_0 = np.interp(t_samples, t_0, cd_0)\n        cd_samp_pA = np.interp(t_samples, t_pA, cd_pA)\n        cd_samp_nA = np.interp(t_samples, t_nA, cd_nA)\n        \n        # Calculate sensitivity\n        # Avoid division by zero if A0 is zero, though not the case here.\n        if A0 == 0.0:\n            S_values = np.zeros_like(t_samples)\n        else:\n            S_values = (cd_samp_pA - cd_samp_nA) / (2.0 * A0)\n\n        # Find time of minimum absolute sensitivity\n        if len(S_values) == 0:\n            k_star = 0\n            t_star = 0.0\n            cd_star = case_params[\"W0\"]\n            s_star_val = (np.interp([0], t_pA, cd_pA) - np.interp([0], t_nA, cd_nA)) / (2.0*A0)\n            s_star = s_star_val[0]\n        else:\n            k_star = np.argmin(np.abs(S_values))\n            t_star = t_samples[k_star]\n            cd_star = cd_samp_0[k_star]\n            s_star = S_values[k_star]\n\n        all_results.append([t_star, cd_star, s_star])\n\n    # Format output string\n    formatted_results = []\n    for res in all_results:\n        inner_list_str = [f\"{v:.6f}\" for v in res]\n        formatted_results.append(f\"[{','.join(inner_list_str)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "由于衍射效应，投影到晶圆上的光强分布图（即“航空影像”）会发生扭曲。一个“孤立”线条特征的衍射方式与“密集”周期性阵列中的线条不同，导致它们最终印刷的尺寸也不同，这种现象被称为“疏密偏差”（iso-dense bias）。我们可以通过在孤立线条附近放置不被印刷的亚分辨率辅助图形（SRAF）来补偿这种效应。本实践采用基于傅里叶光学的标量成像模型来模拟航空影像。你将通过一次虚拟实验，寻找SRAF的最佳尺寸和位置，从而使孤立线条的光学环境与密集线条相匹配，这直接解决了掩模设计中的一个实际挑战，也是对光学邻近校正（OPC）这一关键分辨率增强技术（RET）的入门实践。",
            "id": "4288223",
            "problem": "在部分相干照明下，二元光学掩模上的孤立线通常表现出与密集周期性图形中的嵌入线不同的衍射图像环境。可以在孤立线附近添加亚分辨率辅助图形（Sub-Resolution Assist Features, SRAF），以调整其衍射图像环境。考虑与部分相干成像的 Hopkins 公式相一致的一维标量成像。使用以下基本依据：瞳函数截止空间频率为 $f_{\\mathrm{c}} = \\mathrm{NA}/\\lambda$，部分相干光源被建模为点光源的均匀一维分布，每个点光源具有空间频率偏移 $k_{\\mathrm{s}} \\in [-\\sigma f_{\\mathrm{c}}, \\sigma f_{\\mathrm{c}}]$，并且部分相干衍射图像是来自每个光源点的相干图像的非相干平均。对于单个光源点，相干图像振幅是瞳函数与经 $k_{\\mathrm{s}}$ 偏移的物体频谱之乘积的傅里叶逆变换，其中真实空间中的空间调制 $\\exp\\left(i 2\\pi k_{\\mathrm{s}} x\\right)$ 实现了频谱偏移。\n\n将掩模透射率 $t(x)$ 建模为一维二元函数。对于密集图形，构建一个周期性的线条-间隙掩模，其线宽为 $W$，周期为 $P$，并以 $x=0$ 处有一条线的方式为中心。对于带 SRAF 的孤立图形，构建一条宽度为 $W$ 的孤立主特征线，中心位于 $x=0$，以及两条宽度为 $w$ 的相同 SRAF 线，对称放置于中心位置 $x = \\pm \\left(\\frac{W}{2} + d + \\frac{w}{2}\\right)$，其中 $d$ 是主特征线边缘与最近的 SRAF 边缘之间的间隙。使用标量成像模型，其一维实值圆形光瞳由 $P(f) = 1$（对于 $|f| \\le f_{\\mathrm{c}}$）和 $P(f) = 0$（其他情况）给出。对于每个光源点 $k_{\\mathrm{s}}$，形成调制后的物场 $u(x) = t(x)\\exp\\left(i 2\\pi k_{\\mathrm{s}} x\\right)$，进行傅里叶变换得到 $U(f)$，应用光瞳 $U(f)P(f)$，然后进行傅里叶逆变换得到相干振幅 $a_{k_{\\mathrm{s}}}(x)$。对于 $N_{\\mathrm{s}}$ 个均匀间隔的光源样本，部分相干衍射图像为 $I(x) = \\frac{1}{N_{\\mathrm{s}}}\\sum_{k_{\\mathrm{s}}} \\left|a_{k_{\\mathrm{s}}}(x)\\right|^{2}$。\n\n将环境等效性目标定义为，在关于 $x=0$ 的对称窗口 $[-L_{\\mathrm{w}}, L_{\\mathrm{w}}]$ 内，带 SRAF 的孤立掩模和密集掩模的归一化衍射图像之间的均方差。归一化操作是将每个图像除以其在窗口内的最大值。通过要求每个 SRAF 中心的归一化光强严格小于阈值 $I_{\\mathrm{th}}$ 来施加非成像约束；否则，向目标函数增加一个大的惩罚项。在候选 SRAF 宽度 $w$ 和偏移量 $d$ 的离散网格上进行搜索，并选择使带惩罚的目标函数最小化的配对 $(d^{\\star}, w^{\\star})$。\n\n使用以下科学上真实的参数和单位，并以纳米（nm）表示所有掩模尺寸和输出。不使用角度。计算空间采样步长必须为 $dx = 1\\,\\mathrm{nm}$，域长度必须为 $N \\cdot dx$，其中 $N = 2048$ 个样本。瞳函数截止频率的单位是周期/纳米。使用 $N_{\\mathrm{s}} = 11$ 个均匀间隔的光源样本，范围覆盖 $[-\\sigma f_{\\mathrm{c}}, \\sigma f_{\\mathrm{c}}]$。如果违反非成像约束，则向目标函数增加 $J_{\\mathrm{pen}} = 1000$ 的惩罚。密集掩模是周期性的，周期为 $P$，并在整个计算域上实现。孤立掩模仅包含主特征线和两条 SRAF 线。\n\n测试套件：\n- 案例 1：波长 $\\lambda = 193\\,\\mathrm{nm}$，数值孔径 (NA) $\\mathrm{NA} = 0.85$，部分相干因子 $\\sigma = 0.30$，主特征线宽 $W = 90\\,\\mathrm{nm}$，密集周期 $P = 220\\,\\mathrm{nm}$，窗口半宽 $L_{\\mathrm{w}} = 400\\,\\mathrm{nm}$，SRAF 候选宽度 $w \\in \\{12, 16, 20, 24, 28\\}\\,\\mathrm{nm}$，SRAF 候选偏移量 $d \\in \\{60, 70, 80, 90, 100, 110, 120, 130, 140, 150\\}\\,\\mathrm{nm}$，非成像阈值 $I_{\\mathrm{th}} = 0.35$。\n- 案例 2：$\\lambda = 193\\,\\mathrm{nm}$, $\\mathrm{NA} = 0.85$, $\\sigma = 0.60$, $W = 90\\,\\mathrm{nm}$, $P = 220\\,\\mathrm{nm}$, $L_{\\mathrm{w}} = 400\\,\\mathrm{nm}$, $w \\in \\{12, 16, 20, 24, 28\\}\\,\\mathrm{nm}$, $d \\in \\{60, 70, 80, 90, 100, 110, 120, 130, 140, 150\\}\\,\\mathrm{nm}$, $I_{\\mathrm{th}} = 0.35$。\n- 案例 3：$\\lambda = 193\\,\\mathrm{nm}$, $\\mathrm{NA} = 0.85$, $\\sigma = 0.20$, $W = 70\\,\\mathrm{nm}$, $P = 200\\,\\mathrm{nm}$, $L_{\\mathrm{w}} = 400\\,\\mathrm{nm}$, $w \\in \\{12, 16, 20, 24, 28\\}\\,\\mathrm{nm}$, $d \\in \\{60, 70, 80, 90, 100, 110, 120, 130, 140, 150\\}\\,\\mathrm{nm}$, $I_{\\mathrm{th}} = 0.35$。\n- 案例 4：$\\lambda = 193\\,\\mathrm{nm}$, $\\mathrm{NA} = 0.85$, $\\sigma = 0.80$, $W = 100\\,\\mathrm{nm}$, $P = 240\\,\\mathrm{nm}$, $L_{\\mathrm{w}} = 400\\,\\mathrm{nm}$, $w \\in \\{12, 16, 20, 24, 28\\}\\,\\mathrm{nm}$, $d \\in \\{60, 70, 80, 90, 100, 110, 120, 130, 140, 150\\}\\,\\mathrm{nm}$, $I_{\\mathrm{th}} = 0.35$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个结果是对应测试案例的一个双元素列表 $[d^{\\star}, w^{\\star}]$，以纳米为单位表示为浮点数。例如，输出格式为 $[[d_1,w_1],[d_2,w_2],[d_3,w_3],[d_4,w_4]]$，不含任何附加文本。\n\n所有计算必须遵循所述模型和单位。在输出前，将每个报告的 $d^{\\star}$ 和 $w^{\\star}$ 四舍五入到一位小数。",
            "solution": "问题陈述经评估有效。它在科学上基于傅里叶光学和部分相干成像的原理，特别是 Hopkins 公式，这是光刻仿真中的一个标准模型。该问题定义良好，提供了明确的目标函数、确定的搜索空间以及所有必要的物理和计算参数。术语精确，设置自洽且无矛盾。给定的参数对于现代半导体制造工艺是符合实际的。\n\n解决方案首先构建一维标量成像系统的计算模型。这包括定义空间域和频率域、光学光瞳以及部分相干光源。随后，我们模拟两种掩模的衍射图像：一种是作为参考的密集图形，另一种是增加了亚分辨率辅助图形（SRAF）的孤立图形。目标是找到能使孤立线的衍射图像与密集线的衍射图像最匹配的 SRAF 几何形状（宽度 $w$ 和位置 $d$），同时满足 SRAF 本身不成像的约束条件。\n\n解决方案的核心是计算部分相干衍射图像 $I(x)$，这基于 Hopkins 模型。光源被离散化为 $N_{\\mathrm{s}}$ 个点光源，每个点光源由其空间频率偏移 $k_{\\mathrm{s}}$ 索引。对每个光源点执行相干成像计算，最终的部分相干图像是来自所有光源点的光强之和。\n\n过程如下：\n\n1.  **系统设置**：\n    建立一个一维空间域，坐标为 $x$，包含 $N = 2048$ 个样本，步长为 $dx = 1$ nm。范围从 $-1024$ nm 到 $1023$ nm。相应的频率域，坐标为 $f$，是利用离散傅里叶变换的性质确定的。瞳函数截止频率计算为 $f_{\\mathrm{c}} = \\mathrm{NA}/\\lambda$。瞳函数 $P(f)$ 被定义为一个二元滤波器，对于 $|f| \\le f_{\\mathrm{c}}$ 时为 $1$，否则为 $0$。部分相干光源被建模为在频率范围 $[-\\sigma f_{\\mathrm{c}}, \\sigma f_{\\mathrm{c}}]$ 内均匀分布的 $N_{\\mathrm{s}} = 11$ 个离散点光源。\n\n2.  **掩模透射率函数**：\n    掩模图形由二元透射率函数 $t(x)$ 表示，其中 $t(x)=1$ 表示透光区域（清晰），$t(x)=0$ 表示不透光区域。\n    -   **密集掩模** ($t_{\\mathrm{dense}}(x)$)：在整个计算域上创建一个周期为 $P$、线宽为 $W$ 的周期性线条-间隙图形。一条线位于 $x=0$ 中心。\n    -   **孤立-SRAF 掩模** ($t_{\\mathrm{iso}}(x)$)：对于来自候选网格的每对 SRAF 参数 $(d, w)$，构造一个掩模。它由一个宽度为 $W$ 的中心主特征和两个宽度为 $w$ 的 SRAF 组成。SRAF 对称于原点放置，中心位置为 $x_{\\mathrm{sraf}} = \\pm \\left(\\frac{W}{2} + d + \\frac{w}{2}\\right)$。\n\n3.  **衍射图像计算**：\n    实现一个函数来计算给定掩模透射率 $t(x)$ 的衍射图像 $I(x)$。\n    - 该过程遍历每个光源点 $k_{\\mathrm{s}}$。\n    - 对于每个 $k_{\\mathrm{s}}$，物场通过离轴照明相位因子进行调制：$u_{k_{\\mathrms}}}(x) = t(x) \\exp(i 2\\pi k_{\\mathrms}} x)$。\n    - 计算此调制场的傅里叶变换，$U_{k_{\\mathrms}}}(f) = \\mathcal{F}\\{u_{k_{\\mathrms}}}(x)\\}$。这等效于将物体频谱 $\\mathcal{F}\\{t(x)\\}$ 偏移 $k_{\\mathrms}}$。\n    - 然后通过瞳函数对频谱进行滤波：$U_{\\mathrm{filtered}}(f) = U_{k_{\\mathrms}}}(f) \\cdot P(f)$。\n    - 滤波后频谱的傅里叶逆变换产生相干图像振幅：$a_{k_{\\mathrms}}}(x) = \\mathcal{F}^{-1}\\{U_{\\mathrm{filtered}}(f)\\}$。\n    - 来自此光源点的光强 $|a_{k_{\\mathrms}}}(x)|^2$ 被累加到一个运行总和中。\n    - 在累加完所有光源点的贡献后，对总光强进行平均：$I(x) = \\frac{1}{N_{\\mathrms}}} \\sum_{k_{\\mathrms}}} |a_{k_{\\mathrms}}}(x)|^2$。\n    快速傅里叶变换（FFT）算法用于数值计算，并使用适当的移位（`fftshift`、`ifftshift`）来处理中心化坐标系。\n\n4.  **通过网格搜索进行优化**：\n    最优的 SRAF 参数 ($d^{\\star}, w^{\\star}$) 是通过在提供的 $(d, w)$ 值的离散网格上最小化一个带惩罚的目标函数来确定的。\n    - 首先，计算密集图形的衍射图像 $I_{\\mathrm{dense}}(x)$，并将其作为目标。\n    - 优化循环遍历每个候选对 $(d, w)$。\n    - 对于每对参数，生成相应的孤立-SRAF 掩模 $t_{\\mathrm{iso}}(x)$，并计算其衍射图像 $I_{\\mathrm{iso}}(x)$。\n    - $I_{\\mathrm{dense}}(x)$ 和 $I_{\\mathrm{iso}}(x)$ 都通过除以各自在评估窗口 $[-L_{\\mathrm{w}}, L_{\\mathrm{w}}]$ 内的最大值进行归一化。记为 $I_{\\mathrm{dense,norm}}(x)$ 和 $I_{\\mathrm{iso,norm}}(x)$。\n    - **非成像约束**：SRAF 在其中心处的归一化光强 $I_{\\mathrm{iso,norm}}(x_{\\mathrm{sraf}})$ 必须小于阈值 $I_{\\mathrm{th}} = 0.35$。\n    - **目标函数**：主要目标是窗口内两个归一化图像之间的均方误差（MSE）：\n      $$ \\text{MSE} = \\frac{1}{M} \\sum_{x_j \\in [-L_{\\mathrm{w}}, L_{\\mathrm{w}}]} \\left( I_{\\mathrm{iso,norm}}(x_j) - I_{\\mathrm{dense,norm}}(x_j) \\right)^2 $$\n      其中 $M$ 是窗口中的样本点数。\n    - 如果违反非成像约束，则向 MSE 增加一个大的惩罚项 $J_{\\mathrm{pen}} = 1000$。\n    - 产生最小带惩罚目标的配对 $(d, w)$ 被选为给定测试案例的最优解 $(d^{\\star}, w^{\\star})$。\n\n对指定的四个测试案例中的每一个重复此过程，并收集最终的最佳配对结果，格式化后输出。",
            "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef calculate_aerial_image(t, x, f_shifted, pupil, ks_list):\n    \"\"\"\n    Calculates the partially coherent aerial image using the Hopkins model.\n    \"\"\"\n    N = len(x)\n    total_intensity = np.zeros(N, dtype=np.float64)\n\n    for ks in ks_list:\n        # 1. Modulate object field by the source\n        illumination_phase = np.exp(1j * 2 * np.pi * ks * x)\n        u_ks = t * illumination_phase\n\n        # 2. Compute object spectrum (FFT)\n        # Use ifftshift before FFT for centered spatial input\n        U_ks = fft.fftshift(fft.fft(fft.ifftshift(u_ks)))\n\n        # 3. Apply pupil filter\n        U_filtered = U_ks * pupil\n\n        # 4. Compute coherent image amplitude (IFFT)\n        # Use ifftshift before IFFT for centered spectral input\n        a_ks = fft.fftshift(fft.ifft(fft.ifftshift(U_filtered)))\n        \n        # 5. Accumulate intensity\n        total_intensity += np.abs(a_ks)**2\n        \n    # 6. Average intensity over all source points\n    return total_intensity / len(ks_list)\n\ndef solve():\n    \"\"\"\n    Main function to solve the SRAF optimization problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'lambda': 193.0, 'NA': 0.85, 'sigma': 0.30, 'W': 90.0, 'P': 220.0, 'Lw': 400.0,\n         'w_cand': [12.0, 16.0, 20.0, 24.0, 28.0],\n         'd_cand': [60.0, 70.0, 80.0, 90.0, 100.0, 110.0, 120.0, 130.0, 140.0, 150.0],\n         'I_th': 0.35},\n        # Case 2\n        {'lambda': 193.0, 'NA': 0.85, 'sigma': 0.60, 'W': 90.0, 'P': 220.0, 'Lw': 400.0,\n         'w_cand': [12.0, 16.0, 20.0, 24.0, 28.0],\n         'd_cand': [60.0, 70.0, 80.0, 90.0, 100.0, 110.0, 120.0, 130.0, 140.0, 150.0],\n         'I_th': 0.35},\n        # Case 3\n        {'lambda': 193.0, 'NA': 0.85, 'sigma': 0.20, 'W': 70.0, 'P': 200.0, 'Lw': 400.0,\n         'w_cand': [12.0, 16.0, 20.0, 24.0, 28.0],\n         'd_cand': [60.0, 70.0, 80.0, 90.0, 100.0, 110.0, 120.0, 130.0, 140.0, 150.0],\n         'I_th': 0.35},\n        # Case 4\n        {'lambda': 193.0, 'NA': 0.85, 'sigma': 0.80, 'W': 100.0, 'P': 240.0, 'Lw': 400.0,\n         'w_cand': [12.0, 16.0, 20.0, 24.0, 28.0],\n         'd_cand': [60.0, 70.0, 80.0, 90.0, 100.0, 110.0, 120.0, 130.0, 140.0, 150.0],\n         'I_th': 0.35}\n    ]\n\n    # Global computational parameters\n    N = 2048\n    dx = 1.0\n    Ns = 11\n    J_pen = 1000.0\n\n    # Spatial and frequency coordinates\n    x = (np.arange(N) - N / 2) * dx\n    f = fft.fftfreq(N, d=dx)\n    f_shifted = fft.fftshift(f)\n\n    all_results = []\n\n    for case in test_cases:\n        # Unpack parameters\n        lambda_ = case['lambda']\n        NA = case['NA']\n        sigma = case['sigma']\n        W = case['W']\n        P = case['P']\n        Lw = case['Lw']\n        w_cand = case['w_cand']\n        d_cand = case['d_cand']\n        I_th = case['I_th']\n\n        # System parameters\n        f_c = NA / lambda_\n        ks_list = np.linspace(-sigma * f_c, sigma * f_c, Ns)\n        \n        # Pupil function\n        pupil = np.zeros(N, dtype=np.float64)\n        pupil[np.abs(f_shifted) = f_c] = 1.0\n\n        # Create and simulate dense (target) mask\n        t_dense = (np.abs((x + P / 2) % P - P / 2) = W / 2).astype(np.float64)\n        I_dense = calculate_aerial_image(t_dense, x, f_shifted, pupil, ks_list)\n        \n        # Normalize target image\n        window_mask = np.abs(x) = Lw\n        max_I_dense = np.max(I_dense[window_mask])\n        I_dense_norm = I_dense / max_I_dense if max_I_dense > 0 else I_dense\n\n        min_objective = float('inf')\n        best_d, best_w = None, None\n\n        # Grid search for optimal d and w\n        for w in w_cand:\n            for d in d_cand:\n                # Create isolated-SRAF mask\n                t_iso = np.zeros_like(x)\n                t_iso[np.abs(x) = W / 2] = 1.0\n                sraf_center = W / 2 + d + w / 2\n                t_iso[np.abs(x - sraf_center) = w / 2] = 1.0\n                t_iso[np.abs(x + sraf_center) = w / 2] = 1.0\n                \n                # Calculate aerial image\n                I_iso = calculate_aerial_image(t_iso, x, f_shifted, pupil, ks_list)\n                \n                # Normalize and check constraint\n                max_I_iso = np.max(I_iso[window_mask])\n                I_iso_norm = I_iso / max_I_iso if max_I_iso > 0 else I_iso\n\n                sraf_center_idx = np.argmin(np.abs(x - sraf_center))\n                I_sraf = I_iso_norm[sraf_center_idx]\n                \n                is_printing = I_sraf >= I_th\n                \n                # Calculate objective function\n                mse = np.mean((I_iso_norm[window_mask] - I_dense_norm[window_mask])**2)\n                objective = mse + J_pen if is_printing else mse\n\n                # Update best parameters\n                if objective  min_objective:\n                    min_objective = objective\n                    best_d, best_w = d, w\n        \n        all_results.append([round(best_d, 1), round(best_w, 1)])\n\n    # Format and print the final results\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}