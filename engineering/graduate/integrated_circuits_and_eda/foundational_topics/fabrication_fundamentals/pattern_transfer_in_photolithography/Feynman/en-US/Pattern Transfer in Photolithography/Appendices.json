{
    "hands_on_practices": [
        {
            "introduction": "The optical behavior of a feature on a photomask is highly dependent on its surroundings, a phenomenon known as a proximity effect. An isolated line, for example, will print differently than an identical line in a dense, periodic pattern. This exercise  introduces a core technique in Optical Proximity Correction (OPC) to mitigate this: the use of Sub-Resolution Assist Features (SRAFs). You will use a scalar imaging model to find the optimal size and placement of SRAFs that best match the aerial image of an isolated line to that of a target dense line, providing a hands-on introduction to computational lithography and pattern fidelity optimization.",
            "id": "4288223",
            "problem": "An isolated line on a binary optical mask often exhibits an aerial image environment different from that of a line embedded in a dense periodic pattern under partially coherent illumination. Sub-Resolution Assist Features (SRAF) can be added near the isolated line to adjust its aerial image environment. Consider one-dimensional scalar imaging consistent with the Hopkins formulation of partially coherent imaging. Use the following fundamental base: the pupil cutoff spatial frequency is $f_{\\mathrm{c}} = \\mathrm{NA}/\\lambda$, the partially coherent source is modeled as a uniform one-dimensional distribution of point sources each with spatial frequency shift $k_{\\mathrm{s}} \\in [-\\sigma f_{\\mathrm{c}}, \\sigma f_{\\mathrm{c}}]$, and the partially coherent aerial image is the incoherent average of coherent images from each source point. For a single source point, the coherent image amplitude is the inverse Fourier transform of the product of the pupil function and the object spectrum shifted by $k_{\\mathrm{s}}$, where a spatial modulation by $\\exp\\left(i 2\\pi k_{\\mathrm{s}} x\\right)$ in real space implements the spectrum shift.\n\nModel the mask transmittance $t(x)$ as a binary function in one dimension. For the dense pattern, construct a periodic line-space mask with line width $W$ and pitch $P$ centered so that a line is at $x=0$. For the isolated pattern with SRAF, construct an isolated main line of width $W$ centered at $x=0$, and two identical SRAF lines of width $w$ placed symmetrically at centers $x = \\pm \\left(\\frac{W}{2} + d + \\frac{w}{2}\\right)$, where $d$ is the gap between the main line edge and the nearest SRAF edge. Use a scalar imaging model with a real, circular pupil in one dimension given by $P(f) = 1$ for $|f| \\le f_{\\mathrm{c}}$ and $P(f) = 0$ otherwise. For each source point $k_{\\mathrm{s}}$, form the modulated object field $u(x) = t(x)\\exp\\left(i 2\\pi k_{\\mathrm{s}} x\\right)$, take the Fourier transform $U(f)$, apply the pupil $U(f)P(f)$, and inverse transform to get the coherent amplitude $a_{k_{\\mathrm{s}}}(x)$. The partially coherent aerial image is $I(x) = \\frac{1}{N_{\\mathrm{s}}}\\sum_{k_{\\mathrm{s}}} \\left|a_{k_{\\mathrm{s}}}(x)\\right|^{2}$ for $N_{\\mathrm{s}}$ uniformly spaced source samples.\n\nDefine the environment-equality objective as the mean squared difference between the normalized aerial images of the isolated-with-SRAF and dense masks inside a symmetric window $[-L_{\\mathrm{w}}, L_{\\mathrm{w}}]$ about $x=0$, where normalization divides each image by its maximum inside the window. Impose a non-printing constraint by requiring the normalized intensity at each SRAF center to be strictly less than a threshold $I_{\\mathrm{th}}$; otherwise, add a large penalty to the objective. Search over a discrete grid of candidate SRAF widths $w$ and offsets $d$ and select the pair $(d^{\\star}, w^{\\star})$ that minimizes the penalized objective.\n\nUse the following scientifically realistic parameters and units, and express all mask dimensions and outputs in nanometers (nm). Angles are not used. The computational spatial sampling step must be $dx = 1$ nm, and the domain length must be $N \\cdot dx$ with $N = 2048$ samples. The pupil cutoff frequency is in cycles per nanometer. Use $N_{\\mathrm{s}} = 11$ equally spaced source samples spanning $[-\\sigma f_{\\mathrm{c}}, \\sigma f_{\\mathrm{c}}]$. Use a penalty of $J_{\\mathrm{pen}} = 1000$ added to the objective if the non-printing constraint is violated. The dense mask is periodic with pitch $P$, implemented across the entire computational domain. The isolated mask contains only the main line and the two SRAF lines.\n\nTest Suite:\n- Case $1$: Wavelength $\\lambda = 193$ nm, Numerical Aperture $\\mathrm{NA} = 0.85$, partial coherence $\\sigma = 0.30$, main line width $W = 90$ nm, dense pitch $P = 220$ nm, window half-width $L_{\\mathrm{w}} = 400$ nm, SRAF width candidates $w \\in \\{12, 16, 20, 24, 28\\}$ nm, SRAF offset candidates $d \\in \\{60, 70, 80, 90, 100, 110, 120, 130, 140, 150\\}$ nm, non-printing threshold $I_{\\mathrm{th}} = 0.35$.\n- Case $2$: $\\lambda = 193$ nm, $\\mathrm{NA} = 0.85$, $\\sigma = 0.60$, $W = 90$ nm, $P = 220$ nm, $L_{\\mathrm{w}} = 400$ nm, $w \\in \\{12, 16, 20, 24, 28\\}$ nm, $d \\in \\{60, 70, 80, 90, 100, 110, 120, 130, 140, 150\\}$ nm, $I_{\\mathrm{th}} = 0.35$.\n- Case $3$: $\\lambda = 193$ nm, $\\mathrm{NA} = 0.85$, $\\sigma = 0.20$, $W = 70$ nm, $P = 200$ nm, $L_{\\mathrm{w}} = 400$ nm, $w \\in \\{12, 16, 20, 24, 28\\}$ nm, $d \\in \\{60, 70, 80, 90, 100, 110, 120, 130, 140, 150\\}$ nm, $I_{\\mathrm{th}} = 0.35$.\n- Case $4$: $\\lambda = 193$ nm, $\\mathrm{NA} = 0.85$, $\\sigma = 0.80$, $W = 100$ nm, $P = 240$ nm, $L_{\\mathrm{w}} = 400$ nm, $w \\in \\{12, 16, 20, 24, 28\\}$ nm, $d \\in \\{60, 70, 80, 90, 100, 110, 120, 130, 140, 150\\}$ nm, $I_{\\mathrm{th}} = 0.35$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is a two-element list $[d^{\\star}, w^{\\star}]$ for the corresponding test case, expressed in nanometers as floating-point numbers. For example, the output format is $[[d_1,w_1],[d_2,w_2],[d_3,w_3],[d_4,w_4]]$ with no additional text.\n\nAll calculations must adhere to the stated model and units. Round each reported $d^{\\star}$ and $w^{\\star}$ to one decimal place before output.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of Fourier optics and partially coherent imaging, specifically the Hopkins formulation, which is a standard model in photolithography simulation. The problem is well-posed, providing a clear objective function, a defined search space, and all necessary physical and computational parameters. The terminology is precise, and the setup is self-contained and free of contradictions. The given parameters are realistic for modern semiconductor manufacturing processes.\n\nThe solution proceeds by first constructing a computational model of the one-dimensional scalar imaging system. This involves defining the spatial and frequency domains, the optical pupil, and the partially coherent light source. Subsequently, we simulate the aerial images for two types of masks: a reference dense pattern and an isolated pattern augmented with Sub-Resolution Assist Features (SRAFs). The goal is to find the SRAF geometry (width $w$ and placement $d$) that makes the aerial image of the isolated line most closely match that of the dense line, subject to the constraint that the SRAFs themselves do not print.\n\nThe core of the solution is the calculation of the partially coherent aerial image $I(x)$, which is based on the Hopkins model. The source is discretized into $N_{\\mathrm{s}}$ point sources, each indexed by its spatial frequency shift $k_{\\mathrm{s}}$. For each source point, a coherent imaging calculation is performed, and the final partially coherent image is the sum of the intensities from all source points.\n\nThe procedure is as follows:\n\n1.  **System Setup**:\n    A one-dimensional spatial domain is established with coordinate $x$, consisting of $N = 2048$ samples with a step size of $dx = 1$ nm. This spans from $-1024$ nm to $1023$ nm. The corresponding frequency domain, with coordinate $f$, is determined using the properties of the Discrete Fourier Transform. The pupil cutoff frequency is calculated as $f_{\\mathrm{c}} = \\mathrm{NA}/\\lambda$. The pupil function $P(f)$ is defined as a binary filter, being $1$ for $|f| \\le f_{\\mathrm{c}}$ and $0$ otherwise. The partially coherent source is modeled as $N_{\\mathrm{s}} = 11$ discrete point sources uniformly distributed in the frequency range $[-\\sigma f_{\\mathrm{c}}, \\sigma f_{\\mathrm{c}}]$.\n\n2.  **Mask Transmittance Functions**:\n    The mask patterns are represented by binary transmittance functions, $t(x)$, where $t(x)=1$ for transmissive areas (clear) and $t(x)=0$ for opaque areas.\n    -   **Dense Mask** ($t_{\\mathrm{dense}}(x)$): A periodic line-space pattern with pitch $P$ and line width $W$ is created across the entire computational domain. A line is centered at $x=0$.\n    -   **Isolated-SRAF Mask** ($t_{\\mathrm{iso}}(x)$): For each pair of SRAF parameters $(d, w)$ from the candidate grids, a mask is constructed. It consists of a central main feature of width $W$ and two SRAFs of width $w$. The SRAFs are placed symmetrically about the origin at center positions $x_{\\mathrm{sraf}} = \\pm \\left(\\frac{W}{2} + d + \\frac{w}{2}\\right)$.\n\n3.  **Aerial Image Calculation**:\n    A function is implemented to calculate the aerial image $I(x)$ for a given mask transmittance $t(x)$.\n    - The process iterates through each source point $k_{\\mathrm{s}}$.\n    - For each $k_{\\mathrm{s}}$, the object field is modulated by the off-axis illumination phase factor: $u_{k_{\\mathrm{s}}}(x) = t(x) \\exp(i 2\\pi k_{\\mathrm{s}} x)$.\n    - The Fourier Transform of this modulated field, $U_{k_{\\mathrm{s}}}(f) = \\mathcal{F}\\{u_{k_{\\mathrm{s}}}(x)\\}$, is computed. This is equivalent to shifting the object spectrum, $\\mathcal{F}\\{t(x)\\}$, by $k_{\\mathrm{s}}$.\n    - The spectrum is then filtered by the pupil function: $U_{\\mathrm{filtered}}(f) = U_{k_{\\mathrm{s}}}(f) \\cdot P(f)$.\n    - The Inverse Fourier Transform of the filtered spectrum yields the coherent image amplitude: $a_{k_{\\mathrm{s}}}(x) = \\mathcal{F}^{-1}\\{U_{\\mathrm{filtered}}(f)\\}$.\n    - The intensity $|a_{k_{\\mathrm{s}}}(x)|^2$ from this source point is added to a running total.\n    - After summing contributions from all source points, the total intensity is averaged: $I(x) = \\frac{1}{N_{\\mathrm{s}}} \\sum_{k_{\\mathrm{s}}} |a_{k_{\\mathrm{s}}}(x)|^2$.\n    The Fast Fourier Transform (FFT) algorithm is used for numerical computation, with appropriate shifting (`fftshift`, `ifftshift`) to handle centered coordinate systems.\n\n4.  **Optimization via Grid Search**:\n    The optimal SRAF parameters ($d^{\\star}, w^{\\star}$) are determined by minimizing a penalized objective function over the provided discrete grid of $(d, w)$ values.\n    - First, the aerial image for the dense pattern, $I_{\\mathrm{dense}}(x)$, is calculated and serves as the target.\n    - The optimization loop iterates through each candidate pair $(d, w)$.\n    - For each pair, the corresponding isolated-SRAF mask $t_{\\mathrm{iso}}(x)$ is generated, and its aerial image $I_{\\mathrm{iso}}(x)$ is calculated.\n    - Both $I_{\\mathrm{dense}}(x)$ and $I_{\\mathrm{iso}}(x)$ are normalized by dividing each by its own maximum value within the evaluation window $[-L_{\\mathrm{w}}, L_{\\mathrm{w}}]$. Let these be $I_{\\mathrm{dense,norm}}(x)$ and $I_{\\mathrm{iso,norm}}(x)$.\n    - **Non-Printing Constraint**: The normalized intensity of the SRAF, evaluated at its center, $I_{\\mathrm{iso,norm}}(x_{\\mathrm{sraf}})$, must be less than the threshold $I_{\\mathrm{th}} = 0.35$.\n    - **Objective Function**: The primary objective is the mean squared error (MSE) between the two normalized images within the window:\n      $$ \\text{MSE} = \\frac{1}{M} \\sum_{x_j \\in [-L_{\\mathrm{w}}, L_{\\mathrm{w}}]} \\left( I_{\\mathrm{iso,norm}}(x_j) - I_{\\mathrm{dense,norm}}(x_j) \\right)^2 $$\n      where $M$ is the number of sample points in the window.\n    - A large penalty, $J_{\\mathrm{pen}} = 1000$, is added to the MSE if the non-printing constraint is violated.\n    - The pair $(d, w)$ that yields the minimum penalized objective is selected as the optimal solution $(d^{\\star}, w^{\\star})$ for the given test case.\n\nThis procedure is repeated for each of the four test cases specified, and the resulting optimal pairs are collected and formatted for the final output.",
            "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef calculate_aerial_image(t, x, f_shifted, pupil, ks_list):\n    \"\"\"\n    Calculates the partially coherent aerial image using the Hopkins model.\n    \"\"\"\n    N = len(x)\n    total_intensity = np.zeros(N, dtype=np.float64)\n\n    for ks in ks_list:\n        # 1. Modulate object field by the source\n        illumination_phase = np.exp(1j * 2 * np.pi * ks * x)\n        u_ks = t * illumination_phase\n\n        # 2. Compute object spectrum (FFT)\n        # Use ifftshift before FFT for centered spatial input\n        U_ks = fft.fftshift(fft.fft(fft.ifftshift(u_ks)))\n\n        # 3. Apply pupil filter\n        U_filtered = U_ks * pupil\n\n        # 4. Compute coherent image amplitude (IFFT)\n        # Use ifftshift before IFFT for centered spectral input\n        a_ks = fft.fftshift(fft.ifft(fft.ifftshift(U_filtered)))\n        \n        # 5. Accumulate intensity\n        total_intensity += np.abs(a_ks)**2\n        \n    # 6. Average intensity over all source points\n    return total_intensity / len(ks_list)\n\ndef solve():\n    \"\"\"\n    Main function to solve the SRAF optimization problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'lambda': 193.0, 'NA': 0.85, 'sigma': 0.30, 'W': 90.0, 'P': 220.0, 'Lw': 400.0,\n         'w_cand': [12.0, 16.0, 20.0, 24.0, 28.0],\n         'd_cand': [60.0, 70.0, 80.0, 90.0, 100.0, 110.0, 120.0, 130.0, 140.0, 150.0],\n         'I_th': 0.35},\n        # Case 2\n        {'lambda': 193.0, 'NA': 0.85, 'sigma': 0.60, 'W': 90.0, 'P': 220.0, 'Lw': 400.0,\n         'w_cand': [12.0, 16.0, 20.0, 24.0, 28.0],\n         'd_cand': [60.0, 70.0, 80.0, 90.0, 100.0, 110.0, 120.0, 130.0, 140.0, 150.0],\n         'I_th': 0.35},\n        # Case 3\n        {'lambda': 193.0, 'NA': 0.85, 'sigma': 0.20, 'W': 70.0, 'P': 200.0, 'Lw': 400.0,\n         'w_cand': [12.0, 16.0, 20.0, 24.0, 28.0],\n         'd_cand': [60.0, 70.0, 80.0, 90.0, 100.0, 110.0, 120.0, 130.0, 140.0, 150.0],\n         'I_th': 0.35},\n        # Case 4\n        {'lambda': 193.0, 'NA': 0.85, 'sigma': 0.80, 'W': 100.0, 'P': 240.0, 'Lw': 400.0,\n         'w_cand': [12.0, 16.0, 20.0, 24.0, 28.0],\n         'd_cand': [60.0, 70.0, 80.0, 90.0, 100.0, 110.0, 120.0, 130.0, 140.0, 150.0],\n         'I_th': 0.35}\n    ]\n\n    # Global computational parameters\n    N = 2048\n    dx = 1.0\n    Ns = 11\n    J_pen = 1000.0\n\n    # Spatial and frequency coordinates\n    x = (np.arange(N) - N / 2) * dx\n    f = fft.fftfreq(N, d=dx)\n    f_shifted = fft.fftshift(f)\n\n    all_results = []\n\n    for case in test_cases:\n        # Unpack parameters\n        lambda_ = case['lambda']\n        NA = case['NA']\n        sigma = case['sigma']\n        W = case['W']\n        P = case['P']\n        Lw = case['Lw']\n        w_cand = case['w_cand']\n        d_cand = case['d_cand']\n        I_th = case['I_th']\n\n        # System parameters\n        f_c = NA / lambda_\n        ks_list = np.linspace(-sigma * f_c, sigma * f_c, Ns)\n        \n        # Pupil function\n        pupil = np.zeros(N, dtype=np.float64)\n        pupil[np.abs(f_shifted) <= f_c] = 1.0\n\n        # Create and simulate dense (target) mask\n        t_dense = (np.abs((x + P / 2) % P - P / 2) <= W / 2).astype(np.float64)\n        I_dense = calculate_aerial_image(t_dense, x, f_shifted, pupil, ks_list)\n        \n        # Normalize target image\n        window_mask = np.abs(x) <= Lw\n        max_I_dense = np.max(I_dense[window_mask])\n        I_dense_norm = I_dense / max_I_dense if max_I_dense > 0 else I_dense\n\n        min_objective = float('inf')\n        best_d, best_w = None, None\n\n        # Grid search for optimal d and w\n        for w in w_cand:\n            for d in d_cand:\n                # Create isolated-SRAF mask\n                t_iso = np.zeros_like(x)\n                t_iso[np.abs(x) <= W / 2] = 1.0\n                sraf_center = W / 2 + d + w / 2\n                t_iso[np.abs(x - sraf_center) <= w / 2] = 1.0\n                t_iso[np.abs(x + sraf_center) <= w / 2] = 1.0\n                \n                # Calculate aerial image\n                I_iso = calculate_aerial_image(t_iso, x, f_shifted, pupil, ks_list)\n                \n                # Normalize and check constraint\n                max_I_iso = np.max(I_iso[window_mask])\n                I_iso_norm = I_iso / max_I_iso if max_I_iso > 0 else I_iso\n\n                sraf_center_idx = np.argmin(np.abs(x - sraf_center))\n                I_sraf = I_iso_norm[sraf_center_idx]\n                \n                is_printing = I_sraf >= I_th\n                \n                # Calculate objective function\n                mse = np.mean((I_iso_norm[window_mask] - I_dense_norm[window_mask])**2)\n                objective = mse + J_pen if is_printing else mse\n\n                # Update best parameters\n                if objective < min_objective:\n                    min_objective = objective\n                    best_d, best_w = d, w\n        \n        all_results.append([round(best_d, 1), round(best_w, 1)])\n\n    # Format and print the final results\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond shaping the aerial image, the pattern transfer process offers other levers for optimization, particularly during resist development. This stage is not instantaneous; it is a kinetic process where the final Critical Dimension (CD) evolves over time. In this practice , you will implement a one-dimensional moving boundary model to simulate resist dissolution. Your goal is to analyze the trade-offs involved and identify the optimal development time that minimizes the final CD's sensitivity to small variations, or 'noise', in the latent image, a critical step in ensuring process robustness.",
            "id": "4288258",
            "problem": "You are to implement a one-dimensional moving boundary model for the development of a photoresist line and to compute how the Critical Dimension (CD) depends on development time and latent image noise. The goal is to determine the development time that minimizes the sensitivity of the CD to small-amplitude latent image noise. The context is pattern transfer in photolithography within Integrated Circuits and Electronic Design Automation (EDA). Critical Dimension (CD) is defined as the final linewidth of the resist feature after development.\n\nFundamental base:\n- In a positive tone resist, dissolution rate increases with deprotected fraction. Let $c(x)$ be the deprotected fraction at position $x$ after exposure and Post-Exposure Bake (PEB), with $c(x) \\in [0,1]$.\n- The moving boundary model assumes the lateral dissolution front position $x_b(t)$ moves inward from the original edge with a local velocity equal to the dissolution rate evaluated at the boundary. Specifically, the boundary for the right edge is initialized at $x_b(0) = W_0/2$, where $W_0$ is the initial linewidth, and evolves according to:\n$$\n\\frac{dx_b}{dt} = - R\\big(c(x_b(t))\\big),\n$$\nwith the final Critical Dimension at time $t$ given by:\n$$\n\\mathrm{CD}(t) = \\max\\left(0,\\,2\\,x_b(t)\\right).\n$$\n- Use a sigmoidal dissolution rate model (well-tested in chemically amplified resists), where $R(c)$ is:\n$$\nR(c) = R_{\\min} + \\left(R_{\\max} - R_{\\min}\\right)\\,\\frac{c^n}{c^n + c_{\\mathrm{th}}^n},\n$$\nwith $R_{\\min} > 0$, $R_{\\max} > R_{\\min}$, $n \\geq 1$ and $c_{\\mathrm{th}} \\in (0,1)$.\n\nLatent image model:\n- The baseline deprotected fraction profile across the line is a smooth transition from a low value inside the line to a high value outside:\n$$\nc_0(x) = c_{\\min} + \\left(c_{\\max} - c_{\\min}\\right)\\,\\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{|x| - W_0/2}{\\sigma}\\right)\\right),\n$$\nwith $c_{\\min} \\in [0,1)$, $c_{\\max} \\in (0,1]$, and $\\sigma > 0$ controlling the edge slope.\n- Latent image noise is modeled as a small-amplitude spatial sinusoid added to $c_0(x)$ and clipped to $[0,1]$:\n$$\nc(x;A) = \\mathrm{clip}\\left(c_0(x) + A \\cos\\left(\\frac{2\\pi x}{\\lambda}\\right),\\,0,\\,1\\right),\n$$\nwhere $A$ is the noise amplitude (dimensionless) and $\\lambda > 0$ is the spatial period in $\\mathrm{nm}$.\n\nSensitivity definition:\n- For a fixed $t$, define the CD sensitivity to latent image noise amplitude via a central difference around zero amplitude:\n$$\nS(t) \\approx \\frac{\\mathrm{CD}(t; +A) - \\mathrm{CD}(t; -A)}{2\\,A},\n$$\nwhere $\\mathrm{CD}(t; A)$ is the CD at time $t$ computed using $c(x;A)$.\n\nTask:\n- For each test case, simulate the boundary motion for three amplitudes $A \\in \\{0, +A_0, -A_0\\}$, obtain $\\mathrm{CD}(t)$ as a function of $t$, and compute $S(t)$ for a discrete set of times $t_k$.\n- Restrict the minimization domain to $t \\in [0, T_{\\mathrm{clear}}]$, where $T_{\\mathrm{clear}}$ is the earliest time such that $\\mathrm{CD}(t; 0) = 0$. If the line does not clear before the provided maximum simulation time $T_{\\max}$, use $T_{\\mathrm{clear}} = T_{\\max}$.\n- Determine the time $t^\\star$ in the discrete set that minimizes $|S(t)|$. Report $t^\\star$ in $\\mathrm{s}$, $\\mathrm{CD}(t^\\star;0)$ in $\\mathrm{nm}$, and $S(t^\\star)$ in $\\mathrm{nm}$ per unit noise amplitude.\n\nNumerical implementation requirements:\n- Use a fixed time step integration for the moving boundary ordinary differential equation with time step $\\Delta t = 10^{-3}$ s.\n- Compute and store $x_b(t)$ and $\\mathrm{CD}(t)$ at each step up to $T_{\\max}$ or until $x_b(t) \\le 0$.\n- Evaluate $S(t)$ on a uniform sampling grid with step $\\Delta t_{\\mathrm{samp}} = 5\\times 10^{-2}$ s.\n- Ensure $c(x;A)$ is clipped into $[0,1]$ at every boundary evaluation.\n\nUnits:\n- Report development time in seconds ($\\mathrm{s}$).\n- Report Critical Dimension in nanometers ($\\mathrm{nm}$).\n- Report sensitivity in nanometers per unit amplitude ($\\mathrm{nm}$).\n\nTest suite:\nProvide results for the following three scientifically plausible test cases:\n\n1. Typical feature:\n   - $W_0 = 40$ nm, $\\sigma = 5$ nm, $A_0 = 0.02$, $\\lambda = 8$ nm,\n   - $R_{\\min} = 0.2$ nm/s, $R_{\\max} = 5.0$ nm/s, $c_{\\mathrm{th}} = 0.5$, $n=4$,\n   - $c_{\\min} = 0.05$, $c_{\\max} = 0.95$, $T_{\\max} = 12$ s.\n\n2. Narrower feature with steeper edge and higher noise:\n   - $W_0 = 20$ nm, $\\sigma = 3$ nm, $A_0 = 0.03$, $\\lambda = 6$ nm,\n   - $R_{\\min} = 0.2$ nm/s, $R_{\\max} = 5.0$ nm/s, $c_{\\mathrm{th}} = 0.5$, $n=4$,\n   - $c_{\\min} = 0.05$, $c_{\\max} = 0.95$, $T_{\\max} = 8$ s.\n\n3. Wider feature with smoother edge and lower noise:\n   - $W_0 = 60$ nm, $\\sigma = 7$ nm, $A_0 = 0.015$, $\\lambda = 12$ nm,\n   - $R_{\\min} = 0.2$ nm/s, $R_{\\max} = 5.0$ nm/s, $c_{\\mathrm{th}} = 0.5$, $n=4$,\n   - $c_{\\min} = 0.05$, $c_{\\max} = 0.95$, $T_{\\max} = 16$ s.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the three test cases as a list of three lists:\n$$\n\\left[\\left[t^\\star_1, \\mathrm{CD}_1(t^\\star_1), S_1(t^\\star_1)\\right], \\left[t^\\star_2, \\mathrm{CD}_2(t^\\star_2), S_2(t^\\star_2)\\right], \\left[t^\\star_3, \\mathrm{CD}_3(t^\\star_3), S_3(t^\\star_3)\\right]\\right],\n$$\nwith numeric values. No extra text should be printed. Use the units specified above; the numeric values should be output as plain numbers without unit symbols and rounded consistently to six decimal places.",
            "solution": "The problem has been validated against the specified criteria and is determined to be a valid scientific problem.\n\n### Step 1: Extract Givens\n- **Boundary Evolution ODE**: $\\frac{dx_b}{dt} = - R\\big(c(x_b(t))\\big)$ with initial condition $x_b(0) = W_0/2$.\n- **Critical Dimension (CD)**: $\\mathrm{CD}(t) = \\max\\left(0,\\,2\\,x_b(t)\\right)$.\n- **Dissolution Rate Model**: $R(c) = R_{\\min} + \\left(R_{\\max} - R_{\\min}\\right)\\,\\frac{c^n}{c^n + c_{\\mathrm{th}}^n}$.\n- **Baseline Latent Image Profile**: $c_0(x) = c_{\\min} + \\left(c_{\\max} - c_{\\min}\\right)\\,\\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{|x| - W_0/2}{\\sigma}\\right)\\right)$.\n- **Noisy Latent Image Profile**: $c(x;A) = \\mathrm{clip}\\left(c_0(x) + A \\cos\\left(\\frac{2\\pi x}{\\lambda}\\right),\\,0,\\,1\\right)$.\n- **CD Sensitivity**: $S(t) \\approx \\frac{\\mathrm{CD}(t; +A_0) - \\mathrm{CD}(t; -A_0)}{2\\,A_0}$.\n- **Minimization Task**: Find $t^\\star$ in the discrete set of sample times within $[0, T_{\\mathrm{clear}}]$ that minimizes $|S(t)|$. $T_{\\mathrm{clear}}$ is the time when $\\mathrm{CD}(t; 0)=0$.\n- **Numerical Parameters**: Integration time step $\\Delta t = 10^{-3}$ s, sensitivity sampling time step $\\Delta t_{\\mathrm{samp}} = 5\\times 10^{-2}$ s.\n- **Test Cases**: Three sets of parameters are provided for $(W_0, \\sigma, A_0, \\lambda, T_{\\max})$ with common parameters $(R_{\\min}, R_{\\max}, c_{\\mathrm{th}}, n, c_{\\min}, c_{\\max})$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective.\n- **Scientific Grounding**: The model is based on established principles in photolithography process simulation. The moving boundary model is a 1D simplification of the Eikonal equation, the sigmoidal dissolution rate function is a variant of the widely used Mack model, and the hyperbolic tangent is a standard representation for latent image profiles.\n- **Well-Posedness**: The problem is fully specified with all necessary equations, parameters, and numerical procedures. The ODE governing the boundary motion is well-defined, and the functions involved are continuous and bounded, ensuring a stable solution. The task to find a minimum of a numerically computed function is a standard computational problem.\n- **Objectivity**: The problem is defined using precise mathematical language, free from ambiguity or subjective claims.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be developed following the specified methodology.\n\n### Solution Design\n\nThe problem requires simulating the development of a photoresist line and analyzing its sensitivity to latent image noise. The solution is structured into three main parts: numerical simulation of the boundary evolution, calculation of the Critical Dimension (CD) sensitivity, and optimization to find the time of minimum sensitivity.\n\n**1. Mathematical Model Formulation**\n\nThe core of the model is the evolution of the right-side boundary of the resist line, $x_b(t)$, which starts at $x_b(0) = W_0/2$ and moves inward. Its velocity is determined by the local dissolution rate, which in turn depends on the local deprotected fraction, $c(x)$. This is described by the first-order ordinary differential equation (ODE):\n$$ \\frac{dx_b}{dt} = - R\\big(c(x_b(t))\\big) $$\n\nThe deprotected fraction $c(x)$ includes a baseline profile $c_0(x)$ and a sinusoidal noise term of amplitude $A$ and spatial period $\\lambda$. The combined profile is clipped to the physically meaningful range $[0, 1]$:\n$$ c(x;A) = \\mathrm{clip}\\left( c_{\\min} + \\left(c_{\\max} - c_{\\min}\\right)\\,\\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{|x| - W_0/2}{\\sigma}\\right)\\right) + A \\cos\\left(\\frac{2\\pi x}{\\lambda}\\right),\\,0,\\,1 \\right) $$\n\nThe dissolution rate $R(c)$ is given by a sigmoidal function, characteristic of chemically amplified resists:\n$$ R(c) = R_{\\min} + \\left(R_{\\max} - R_{\\min}\\right)\\,\\frac{c^n}{c^n + c_{\\mathrm{th}}^n} $$\nThis function provides a slow etch rate for low $c$ ($R_{\\min}$) and a fast etch rate for high $c$ ($R_{\\max}$), with a sharp transition controlled by the threshold $c_{\\mathrm{th}}$ and the contrast parameter $n$.\n\n**2. Numerical Simulation Algorithm**\n\nTo solve the ODE for $x_b(t)$, we employ the explicit Forward Euler method, a straightforward and suitable choice for this problem given the small, fixed time step $\\Delta t = 10^{-3} \\ \\mathrm{s}$. The iterative update rule is:\n$$ x_b(t_{k+1}) = x_b(t_k) - \\Delta t \\cdot R\\big(c(x_b(t_k); A)\\big) $$\nwhere $t_{k+1} = t_k + \\Delta t$. Starting from $x_b(0) = W_0/2$, this process is repeated until either the boundary has fully receded ($x_b(t) \\le 0$) or the maximum simulation time $T_{\\max}$ is reached.\n\nFor each test case, this simulation is performed three times to obtain the CD evolution over time, $\\mathrm{CD}(t) = 2x_b(t)$ (for $x_b(t) > 0$), corresponding to three noise scenarios:\n- $\\mathrm{CD}(t; 0)$ for the baseline case ($A=0$).\n- $\\mathrm{CD}(t; +A_0)$ for positive noise amplitude.\n- $\\mathrm{CD}(t; -A_0)$ for negative noise amplitude.\n\nThe time series data $(t, \\mathrm{CD}(t))$ are stored for each simulation.\n\n**3. Sensitivity Analysis and Optimization**\n\nThe final step is to calculate the sensitivity $S(t)$ and find the development time $t^\\star$ that minimizes its magnitude.\n\nFirst, we determine the valid time domain for the analysis. This is $[0, T_{\\mathrm{clear}}]$, where $T_{\\mathrm{clear}}$ is the resist clear time for the baseline case ($A=0$), defined as the earliest time $t$ at which $\\mathrm{CD}(t; 0) = 0$. If the resist line does not clear by $T_{\\max}$, we set $T_{\\mathrm{clear}} = T_{\\max}$.\n\nNext, we establish a uniform sampling grid of times $t_k$ over the interval $[0, T_{\\mathrm{clear}}]$ with a step of $\\Delta t_{\\mathrm{samp}} = 5 \\times 10^{-2} \\ \\mathrm{s}$. The three simulated CD trajectories, which were generated on a finer grid $\\Delta t$, are resampled onto this common grid using linear interpolation. Let the interpolated values be $\\mathrm{CD}_{\\mathrm{samp}}(t_k; A)$.\n\nThe sensitivity $S(t_k)$ at each sampling point is then approximated using a central difference formula:\n$$ S(t_k) = \\frac{\\mathrm{CD}_{\\mathrm{samp}}(t_k; +A_0) - \\mathrm{CD}_{\\mathrm{samp}}(t_k; -A_0)}{2\\,A_0} $$\nThis yields a discrete series of sensitivity values $S(t_k)$.\n\nFinally, we find the index $k^\\star$ that minimizes the absolute value of the sensitivity, $|S(t_k)|$. The optimal development time is $t^\\star = t_{k^\\star}$. The acompanying metrics are the baseline CD at this time, $\\mathrm{CD}(t^\\star; 0) = \\mathrm{CD}_{\\mathrm{samp}}(t_{k^\\star}; 0)$, and the sensitivity itself, $S(t^\\star) = S(t_{k^\\star})$. These three values—$(t^\\star, \\mathrm{CD}(t^\\star; 0), S(t^\\star))$—constitute the result for one test case. This entire procedure is repeated for all three test cases provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run simulations for all test cases and print the results.\n    \"\"\"\n\n    # Common parameters for all test cases\n    R_min = 0.2  # nm/s\n    R_max = 5.0  # nm/s\n    c_th = 0.5   # dimensionless\n    n = 4.0      # dimensionless\n    c_min = 0.05 # dimensionless\n    c_max = 0.95 # dimensionless\n    \n    # Numerical method parameters\n    dt = 1e-3    # s\n    dt_samp = 5e-2 # s\n\n    test_cases = [\n        {\n            \"W0\": 40.0, \"sigma\": 5.0, \"A0\": 0.02, \"lambda_val\": 8.0, \n            \"T_max\": 12.0\n        },\n        {\n            \"W0\": 20.0, \"sigma\": 3.0, \"A0\": 0.03, \"lambda_val\": 6.0, \n            \"T_max\": 8.0\n        },\n        {\n            \"W0\": 60.0, \"sigma\": 7.0, \"A0\": 0.015, \"lambda_val\": 12.0, \n            \"T_max\": 16.0\n        },\n    ]\n\n    all_results = []\n\n    for case_params in test_cases:\n        # Define model functions for the current case\n        def c0(x, p):\n            arg = (np.abs(x) - p[\"W0\"] / 2.0) / p[\"sigma\"]\n            return c_min + (c_max - c_min) * 0.5 * (1.0 + np.tanh(arg))\n\n        def c_noisy(x, A, p):\n            val = c0(x, p) + A * np.cos(2.0 * np.pi * x / p[\"lambda_val\"])\n            return np.clip(val, 0.0, 1.0)\n        \n        def R(c_val):\n            return R_min + (R_max - R_min) * (c_val**n) / (c_val**n + c_th**n)\n        \n        def simulate_cd_evolution(A, p):\n            \"\"\"Simulates the boundary evolution for a given noise amplitude A.\"\"\"\n            t = 0.0\n            xb = p[\"W0\"] / 2.0\n            \n            # Using lists for dynamic size, pre-allocation is possible but more complex\n            t_series = [t]\n            xb_series = [xb]\n\n            while t < p[\"T_max\"]:\n                c_at_boundary = c_noisy(xb, A, p)\n                rate = R(c_at_boundary)\n                xb -= rate * dt\n                t += dt\n\n                if xb <= 0:\n                    xb = 0.0\n                    t_series.append(t)\n                    xb_series.append(xb)\n                    break \n                \n                t_series.append(t)\n                xb_series.append(xb)\n\n            t_series_np = np.array(t_series)\n            cd_series_np = np.maximum(0.0, 2.0 * np.array(xb_series))\n            \n            return t_series_np, cd_series_np\n\n        # Run simulations for A=0, +A0, -A0\n        A0 = case_params[\"A0\"]\n        t_0, cd_0 = simulate_cd_evolution(0.0, case_params)\n        t_pA, cd_pA = simulate_cd_evolution(A0, case_params)\n        t_nA, cd_nA = simulate_cd_evolution(-A0, case_params)\n\n        # Determine T_clear\n        clear_indices = np.where(cd_0 == 0.0)[0]\n        if len(clear_indices) > 0:\n            T_clear = t_0[clear_indices[0]]\n        else:\n            T_clear = case_params[\"T_max\"]\n\n        # Create sampling grid\n        t_samples = np.arange(0, T_clear, dt_samp)\n        if T_clear not in t_samples:\n             t_samples = np.append(t_samples, T_clear)\n\n        # Interpolate CD values onto the sampling grid\n        cd_samp_0 = np.interp(t_samples, t_0, cd_0)\n        cd_samp_pA = np.interp(t_samples, t_pA, cd_pA)\n        cd_samp_nA = np.interp(t_samples, t_nA, cd_nA)\n        \n        # Calculate sensitivity\n        # Avoid division by zero if A0 is zero, though not the case here.\n        if A0 == 0.0:\n            S_values = np.zeros_like(t_samples)\n        else:\n            S_values = (cd_samp_pA - cd_samp_nA) / (2.0 * A0)\n\n        # Find time of minimum absolute sensitivity\n        if len(S_values) == 0:\n            # This edge case might happen if T_clear is very small\n            # and no sample points are generated.\n            # In that case, we can assume the result is at t=0.\n            k_star = 0\n            t_star = 0.0\n            cd_star = case_params[\"W0\"]\n            s_star = (np.interp([0], t_pA, cd_pA)[0] - np.interp([0], t_nA, cd_nA)[0]) / (2.0*A0)\n        else:\n            k_star = np.argmin(np.abs(S_values))\n            t_star = t_samples[k_star]\n            cd_star = cd_samp_0[k_star]\n            s_star = S_values[k_star]\n\n        all_results.append([t_star, cd_star, s_star])\n\n    # Format output string\n    formatted_results = []\n    for res in all_results:\n        inner_list_str = [f\"{v:.6f}\" for v in res]\n        formatted_results.append(f\"[{','.join(inner_list_str)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "Effective lithography must deliver reliable patterns not just at a single nominal setting, but across the entire process window of expected focus and dose variations. This requires moving beyond simple optimization to robust optimization. This advanced exercise  tasks you with formulating and solving a robust Source-Mask Optimization (SMO) problem. You will construct a min-max objective function that captures the worst-case patterning error across a set of focus-dose corners and implement a projected subgradient descent method to find a mask solution that is maximally resilient to these process variations.",
            "id": "4288255",
            "problem": "You are tasked with formalizing and solving a robust Source Mask Optimization (SMO) problem for pattern transfer in photolithography under focus and dose variations, using a simplified yet scientifically grounded optical imaging model. The model and objective must be expressed rigorously from first principles, and your solution must implement a subgradient-based worst-case error reduction update.\n\nFundamental base:\n- Under the Hopkins partially coherent imaging model with the Transmission Cross Coefficient (TCC), the aerial image intensity at pixel $p$ for a given focus setting is modeled by a quadratic form in the mask transmission vector $\\mathbf{m} \\in \\mathbb{R}^n$, namely $I_p = \\mathbf{m}^\\top \\mathbf{T}^{(p)} \\mathbf{m}$, where $\\mathbf{T}^{(p)} \\in \\mathbb{R}^{n \\times n}$ is symmetric positive semidefinite and depends on focus. The dose $D$ scales the intensity linearly, so $I_p(D) = D \\cdot \\mathbf{m}^\\top \\mathbf{T}^{(p)} \\mathbf{m}$.\n- The target aerial image at pixel $p$ is denoted $t_p$.\n- Robustness against variations is captured via a min-max objective across a finite set of focus-dose corners.\n\nProblem setup:\n- Let the corner set be $\\mathcal{K} = \\{(z_i, D_j)\\}$, where $z_i$ indexes focus states and $D_j$ indexes dose values. For each corner $k \\in \\mathcal{K}$ and each pixel $p$, define $\\mathbf{T}_{k}^{(p)}$ as the TCC matrix at that focus state. Define the per-corner objective\n$$\nJ_k(\\mathbf{m}) = \\frac{1}{2} \\sum_{p=1}^{P} \\left(D_k \\cdot \\mathbf{m}^\\top \\mathbf{T}_{k}^{(p)} \\mathbf{m} - t_p\\right)^2 \\;+\\; \\frac{\\lambda}{2} \\, \\|\\mathbf{m}\\|_2^2,\n$$\nwhere $D_k$ is the dose associated to corner $k$, $\\lambda \\ge 0$ is a regularization parameter, and $P$ is the number of pixels in the target image. The robust objective is\n$$\ng(\\mathbf{m}) = \\max_{k \\in \\mathcal{K}} J_k(\\mathbf{m}).\n$$\n- The worst-case subgradient-based update with projection onto the box constraints is given by\n$$\n\\mathbf{m}^{(t+1)} = \\Pi_{[0,1]^n}\\left( \\mathbf{m}^{(t)} - \\alpha \\cdot \\mathbf{g}^{(t)} \\right),\n$$\nwhere $\\Pi_{[0,1]^n}$ denotes projection onto the hypercube $[0,1]^n$, $\\alpha > 0$ is a step size, and $\\mathbf{g}^{(t)}$ is any subgradient of $g$ at $\\mathbf{m}^{(t)}$. When the maximizing corner is unique, $\\mathbf{g}^{(t)} = \\nabla J_{k^\\star}(\\mathbf{m}^{(t)})$, and when multiple corners tie, any convex combination of $\\{\\nabla J_k(\\mathbf{m}^{(t)}) : k \\in \\mathcal{K}^\\star\\}$ is a valid subgradient, where $\\mathcal{K}^\\star$ is the set of active maximizers.\n\nYour tasks:\n- Formulate $g(\\mathbf{m})$ and derive the explicit expression for $\\nabla J_k(\\mathbf{m})$ in terms of $\\mathbf{T}_{k}^{(p)}$, $D_k$, and $t_p$, starting from the stated fundamental base.\n- Implement a program that:\n  1. Constructs the corner set $\\mathcal{K}$ from given focus-state matrices and dose values.\n  2. Initializes $\\mathbf{m}^{(0)}$.\n  3. Computes $g(\\mathbf{m}^{(0)})$.\n  4. Performs $N$ projected subgradient iterations to obtain $\\mathbf{m}^{(N)}$.\n  5. Computes the worst-case objective reduction $g(\\mathbf{m}^{(0)}) - g(\\mathbf{m}^{(N)})$.\n\nImplementation details:\n- Use and only use the parameters supplied in the test suite below.\n- For each focus state $z_i$ and pixel $p$, the TCC matrix $\\mathbf{T}_{z_i}^{(p)}$ must be constructed as $\\mathbf{T}_{z_i}^{(p)} = \\mathbf{A}_{z_i}^{(p)\\top} \\mathbf{A}_{z_i}^{(p)}$, ensuring symmetry and positive semidefiniteness. All matrices $\\mathbf{A}_{z_i}^{(p)}$ are given explicitly below.\n- The per-pixel residuals are $r_{k,p}(\\mathbf{m}) = D_k \\cdot \\mathbf{m}^\\top \\mathbf{T}_{k}^{(p)} \\mathbf{m} - t_p$.\n- The gradient for corner $k$ is\n$$\n\\nabla J_k(\\mathbf{m}) = \\sum_{p=1}^{P} r_{k,p}(\\mathbf{m}) \\cdot D_k \\cdot \\left(\\mathbf{T}_{k}^{(p)} + \\mathbf{T}_{k}^{(p)\\top}\\right) \\mathbf{m} + \\lambda \\mathbf{m}.\n$$\n- At each iteration, identify the set of active corners $\\mathcal{K}^\\star = \\{k : J_k(\\mathbf{m}) \\ge \\max_{k'} J_{k'}(\\mathbf{m}) - \\tau\\}$ for a small tolerance $\\tau$, and use the average of $\\{\\nabla J_k(\\mathbf{m}) : k \\in \\mathcal{K}^\\star\\}$ as the subgradient.\n\nTest suite:\n- Case $1$:\n  - $n = 3$, $P = 2$, focus states $z_0$ and $z_1$.\n  - $\\mathbf{A}_{z_0}^{(1)} = \\begin{bmatrix} 1.0 & 0.1 & 0.0 \\\\ 0.0 & 0.9 & 0.1 \\\\ 0.0 & 0.0 & 0.8 \\end{bmatrix}$, $\\mathbf{A}_{z_0}^{(2)} = \\begin{bmatrix} 0.7 & 0.1 & 0.0 \\\\ 0.0 & 0.8 & 0.1 \\\\ 0.0 & 0.0 & 0.9 \\end{bmatrix}$.\n  - $\\mathbf{A}_{z_1}^{(1)} = \\begin{bmatrix} 0.95 & 0.08 & 0.0 \\\\ 0.0 & 0.85 & 0.08 \\\\ 0.0 & 0.0 & 0.75 \\end{bmatrix}$, $\\mathbf{A}_{z_1}^{(2)} = \\begin{bmatrix} 0.65 & 0.08 & 0.0 \\\\ 0.0 & 0.75 & 0.08 \\\\ 0.0 & 0.0 & 0.85 \\end{bmatrix}$.\n  - Doses: $\\{0.9, 1.1\\}$, target $\\mathbf{t} = \\begin{bmatrix} 0.8 \\\\ 0.6 \\end{bmatrix}$.\n  - Regularization $\\lambda = 0.01$, step size $\\alpha = 0.05$, iterations $N = 50$, tolerance $\\tau = 10^{-12}$, initialization $\\mathbf{m}^{(0)} = \\begin{bmatrix} 0.5 \\\\ 0.5 \\\\ 0.5 \\end{bmatrix}$.\n- Case $2$:\n  - $n = 3$, $P = 3$, focus states $z_0$ and $z_1$.\n  - $\\mathbf{A}_{z_0}^{(1)} = \\begin{bmatrix} 1.1 & 0.2 & 0.0 \\\\ 0.0 & 0.9 & 0.15 \\\\ 0.0 & 0.0 & 0.7 \\end{bmatrix}$, $\\mathbf{A}_{z_0}^{(2)} = \\begin{bmatrix} 0.9 & 0.15 & 0.0 \\\\ 0.0 & 0.85 & 0.1 \\\\ 0.0 & 0.0 & 0.65 \\end{bmatrix}$, $\\mathbf{A}_{z_0}^{(3)} = \\begin{bmatrix} 0.6 & 0.1 & 0.0 \\\\ 0.0 & 0.7 & 0.1 \\\\ 0.0 & 0.0 & 0.9 \\end{bmatrix}$.\n  - $\\mathbf{A}_{z_1}^{(1)} = \\begin{bmatrix} 1.0 & 0.18 & 0.0 \\\\ 0.0 & 0.85 & 0.12 \\\\ 0.0 & 0.0 & 0.65 \\end{bmatrix}$, $\\mathbf{A}_{z_1}^{(2)} = \\begin{bmatrix} 0.85 & 0.12 & 0.0 \\\\ 0.0 & 0.8 & 0.09 \\\\ 0.0 & 0.0 & 0.6 \\end{bmatrix}$, $\\mathbf{A}_{z_1}^{(3)} = \\begin{bmatrix} 0.55 & 0.09 & 0.0 \\\\ 0.0 & 0.65 & 0.08 \\\\ 0.0 & 0.0 & 0.85 \\end{bmatrix}$.\n  - Doses: $\\{0.8, 1.2\\}$, target $\\mathbf{t} = \\begin{bmatrix} 0.9 \\\\ 0.7 \\\\ 0.5 \\end{bmatrix}$.\n  - Regularization $\\lambda = 0.02$, step size $\\alpha = 0.05$, iterations $N = 60$, tolerance $\\tau = 10^{-12}$, initialization $\\mathbf{m}^{(0)} = \\begin{bmatrix} 0.5 \\\\ 0.5 \\\\ 0.5 \\end{bmatrix}$.\n- Case $3$ (tie edge case):\n  - $n = 3$, $P = 1$, focus states $z_0$ and $z_1$ (identical).\n  - $\\mathbf{A}_{z_0}^{(1)} = \\begin{bmatrix} 0.8 & 0.1 & 0.0 \\\\ 0.0 & 0.8 & 0.1 \\\\ 0.0 & 0.0 & 0.8 \\end{bmatrix}$, $\\mathbf{A}_{z_1}^{(1)} = \\begin{bmatrix} 0.8 & 0.1 & 0.0 \\\\ 0.0 & 0.8 & 0.1 \\\\ 0.0 & 0.0 & 0.8 \\end{bmatrix}$.\n  - Doses: $\\{1.0, 1.0\\}$, target $\\mathbf{t} = \\begin{bmatrix} 0.5 \\end{bmatrix}$.\n  - Regularization $\\lambda = 0.0$, step size $\\alpha = 0.1$, iterations $N = 100$, tolerance $\\tau = 10^{-12}$, initialization $\\mathbf{m}^{(0)} = \\begin{bmatrix} 0.5 \\\\ 0.5 \\\\ 0.5 \\end{bmatrix}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the worst-case objective reductions for the cases $1$, $2$, and $3$, as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3]$), where each $r_i$ is a floating-point number representing $g(\\mathbf{m}^{(0)}) - g(\\mathbf{m}^{(N)})$ for the corresponding case.",
            "solution": "The problem statement has been rigorously validated and is determined to be valid. It is scientifically grounded in the principles of optical imaging for photolithography, well-posed as a convex optimization problem, and provides a complete, unambiguous, and consistent set of definitions, parameters, and objectives. The task is to formalize and implement a subgradient-based optimization algorithm for robust Source Mask Optimization (SMO).\n\n### 1. Formal Problem Formulation and Gradient Derivation\n\nThe core of the problem is to minimize a worst-case objective function $g(\\mathbf{m})$ over a set of process corners, where $\\mathbf{m} \\in [0, 1]^n$ represents the mask transmission values.\n\n**Objective Function:**\nThe system is evaluated over a set of process corners $\\mathcal{K} = \\{(z_i, D_j)\\}$, where $z_i$ denotes a focus state and $D_j$ a dose value. For each corner $k \\in \\mathcal{K}$ with its associated dose $D_k$ and focus-dependent Transmission Cross-Coefficient (TCC) matrices $\\mathbf{T}_k^{(p)}$, the per-corner objective function $J_k(\\mathbf{m})$ is defined as:\n$$\nJ_k(\\mathbf{m}) = \\frac{1}{2} \\sum_{p=1}^{P} \\left(D_k \\cdot \\mathbf{m}^\\top \\mathbf{T}_{k}^{(p)} \\mathbf{m} - t_p\\right)^2 \\;+\\; \\frac{\\lambda}{2} \\, \\|\\mathbf{m}\\|_2^2\n$$\nHere, $P$ is the number of pixels being evaluated, $t_p$ is the target aerial image intensity at pixel $p$, and $\\lambda \\ge 0$ is a Tikhonov regularization parameter.\n\nThe robust objective function $g(\\mathbf{m})$ is the maximum of the per-corner objectives, representing the worst-case error across all process conditions:\n$$\ng(\\mathbf{m}) = \\max_{k \\in \\mathcal{K}} J_k(\\mathbf{m})\n$$\nThis function $g(\\mathbf{m})$ is convex, as it is the pointwise maximum of a set of convex functions $J_k(\\mathbf{m})$. Each $J_k(\\mathbf{m})$ is convex because it is the sum of squares of quadratic functions and a squared L2-norm, ensuring its Hessian is positive semidefinite for $\\lambda \\ge 0$.\n\n**Gradient of the Per-Corner Objective:**\nTo perform gradient-based optimization, we must derive the gradient of $J_k(\\mathbf{m})$ with respect to $\\mathbf{m}$. Let's denote the per-pixel residual as $r_{k,p}(\\mathbf{m}) = D_k \\cdot \\mathbf{m}^\\top \\mathbf{T}_{k}^{(p)} \\mathbf{m} - t_p$. The objective can be written as:\n$$\nJ_k(\\mathbf{m}) = \\frac{1}{2} \\sum_{p=1}^{P} [r_{k,p}(\\mathbf{m})]^2 + \\frac{\\lambda}{2} \\mathbf{m}^\\top \\mathbf{m}\n$$\nThe gradient $\\nabla J_k(\\mathbf{m})$ is obtained by applying the chain rule:\n$$\n\\nabla J_k(\\mathbf{m}) = \\sum_{p=1}^{P} r_{k,p}(\\mathbf{m}) \\cdot \\nabla_{\\mathbf{m}} r_{k,p}(\\mathbf{m}) + \\lambda \\mathbf{m}\n$$\nThe gradient of the residual term $\\nabla_{\\mathbf{m}} r_{k,p}(\\mathbf{m})$ is found using the identity for the gradient of a quadratic form $\\nabla_{\\mathbf{x}} (\\mathbf{x}^\\top \\mathbf{A} \\mathbf{x}) = (\\mathbf{A} + \\mathbf{A}^\\top)\\mathbf{x}$:\n$$\n\\nabla_{\\mathbf{m}} r_{k,p}(\\mathbf{m}) = \\nabla_{\\mathbf{m}} \\left( D_k \\cdot \\mathbf{m}^\\top \\mathbf{T}_{k}^{(p)} \\mathbf{m} - t_p \\right) = D_k \\left( \\mathbf{T}_{k}^{(p)} + (\\mathbf{T}_{k}^{(p)})^\\top \\right) \\mathbf{m}\n$$\nSubstituting this back, we obtain the full gradient expression, which matches the one provided in the problem statement:\n$$\n\\nabla J_k(\\mathbf{m}) = \\sum_{p=1}^{P} r_{k,p}(\\mathbf{m}) \\cdot D_k \\cdot \\left( \\mathbf{T}_{k}^{(p)} + (\\mathbf{T}_{k}^{(p)})^\\top \\right) \\mathbf{m} + \\lambda \\mathbf{m}\n$$\nSince the problem specifies that $\\mathbf{T}_{k}^{(p)}$ is constructed as $\\mathbf{A}^\\top\\mathbf{A}$, it is symmetric, meaning $(\\mathbf{T}_{k}^{(p)})^\\top = \\mathbf{T}_{k}^{(p)}$. The expression simplifies to $2\\mathbf{T}_{k}^{(p)}$, but we will use the more general form for absolute correctness.\n\n### 2. Algorithmic Procedure: Projected Subgradient Method\n\nThe function $g(\\mathbf{m})$ is non-differentiable at points where the maximum in $\\max_{k \\in \\mathcal{K}} J_k(\\mathbf{m})$ is achieved for more than one corner $k$. The subgradient method is the appropriate optimization technique.\n\n**Subgradient Calculation:**\nThe subdifferential $\\partial g(\\mathbf{m})$ of $g$ at $\\mathbf{m}$ is the convex hull of the gradients of the active-set objectives. The active set is $\\mathcal{K}^\\star(\\mathbf{m}) = \\{ k \\in \\mathcal{K} \\mid J_k(\\mathbf{m}) = g(\\mathbf{m}) \\}$. A subgradient $\\mathbf{g} \\in \\partial g(\\mathbf{m})$ can be any convex combination of the gradients from the active set:\n$$\n\\mathbf{g} = \\sum_{k \\in \\mathcal{K}^\\star(\\mathbf{m})} c_k \\nabla J_k(\\mathbf{m}), \\quad \\text{where } c_k \\ge 0 \\text{ and } \\sum_{k \\in \\mathcal{K}^\\star(\\mathbf{m})} c_k = 1\n$$\nFor numerical stability, the active set is relaxed using a small tolerance $\\tau > 0$:\n$$\n\\mathcal{K}^\\star(\\mathbf{m}) = \\{ k \\in \\mathcal{K} \\mid J_k(\\mathbf{m}) \\ge g(\\mathbf{m}) - \\tau \\}\n$$\nThe problem specifies using the average of these gradients, corresponding to $c_k = 1/|\\mathcal{K}^\\star(\\mathbf{m})|$ for all $k \\in \\mathcal{K}^\\star(\\mathbf{m})$.\n\n**Iterative Update:**\nThe mask vector $\\mathbf{m}$ is updated iteratively according to the projected subgradient descent algorithm. Starting with an initial mask $\\mathbf{m}^{(0)}$, the update rule for iteration $t$ is:\n$$\n\\mathbf{m}^{(t+1)} = \\Pi_{[0,1]^n}\\left( \\mathbf{m}^{(t)} - \\alpha \\cdot \\mathbf{g}^{(t)} \\right)\n$$\nwhere $\\alpha > 0$ is the step size, $\\mathbf{g}^{(t)}$ is the computed subgradient at $\\mathbf{m}^{(t)}$, and $\\Pi_{[0,1]^n}$ is the projection operator onto the hypercube $[0,1]^n$. This projection enforces the physical constraint that mask transmission values must be between $0$ and $1$.\n\n**Overall Algorithm:**\nThe complete algorithm to find the optimized mask $\\mathbf{m}^{(N)}$ and calculate the objective reduction is as follows:\n\n1.  **Initialization:**\n    a. Construct the set of corners $\\mathcal{K}$ from the given focus states and dose values.\n    b. For each focus state $z_i$ and pixel $p$, compute the TCC matrix $\\mathbf{T}_{z_i}^{(p)} = \\mathbf{A}_{z_i}^{(p)\\top} \\mathbf{A}_{z_i}^{(p)}$.\n    c. Set the initial mask vector $\\mathbf{m} = \\mathbf{m}^{(0)}$.\n\n2.  **Initial Objective Calculation:** Compute $g(\\mathbf{m}^{(0)}) = \\max_{k \\in \\mathcal{K}} J_k(\\mathbf{m}^{(0)})$.\n\n3.  **Iterative Optimization:** For $t$ from $0$ to $N-1$:\n    a. **Compute All Per-Corner Objectives:** For each $k \\in \\mathcal{K}$, calculate $J_k(\\mathbf{m}^{(t)})$.\n    b. **Find Active Set:** Determine the maximum objective value $g_{max} = \\max_k J_k(\\mathbf{m}^{(t)})$ and identify the active set $\\mathcal{K}^\\star = \\{k \\mid J_k(\\mathbf{m}^{(t)}) \\ge g_{max} - \\tau\\}$.\n    c. **Compute Subgradient:**\n        i. Initialize the subgradient vector $\\mathbf{g}^{(t)} = \\mathbf{0}$.\n        ii. For each $k \\in \\mathcal{K}^\\star$, compute the gradient $\\nabla J_k(\\mathbf{m}^{(t)})$.\n        iii. Sum the computed gradients: $\\mathbf{g}_{sum} = \\sum_{k \\in \\mathcal{K}^\\star} \\nabla J_k(\\mathbf{m}^{(t)})$.\n        iv. Average the gradients to find the subgradient: $\\mathbf{g}^{(t)} = \\mathbf{g}_{sum} / |\\mathcal{K}^\\star|$.\n    d. **Update and Project:**\n        i. Perform the gradient descent step: $\\mathbf{m}_{temp} = \\mathbf{m}^{(t)} - \\alpha \\cdot \\mathbf{g}^{(t)}$.\n        ii. Project the result onto the valid range: $\\mathbf{m}^{(t+1)} = \\Pi_{[0,1]^n}(\\mathbf{m}_{temp})$.\n\n4.  **Final Objective Calculation:** After $N$ iterations, compute the final objective value $g(\\mathbf{m}^{(N)}) = \\max_{k \\in \\mathcal{K}} J_k(\\mathbf{m}^{(N)})$.\n\n5.  **Result:** The final output is the reduction in the worst-case objective function: $g(\\mathbf{m}^{(0)}) - g(\\mathbf{m}^{(N)})$.",
            "answer": "```python\nimport numpy as np\n\ndef run_smo_optimization(n, P, A_matrices_by_focus, doses, t, lambda_reg, alpha, N, tau, m0):\n    \"\"\"\n    Solves the robust Source Mask Optimization problem for a single test case.\n    \"\"\"\n    \n    # 1. Setup corners and pre-compute T-matrices\n    num_focus_states = len(A_matrices_by_focus)\n    focus_indices = list(range(num_focus_states))\n    unique_doses = sorted(list(set(doses)))\n\n    corners = []\n    for z_idx in focus_indices:\n        for D_val in unique_doses:\n            corners.append({'z_idx': z_idx, 'D': D_val})\n    \n    T_matrices = []\n    for z_idx in range(num_focus_states):\n        T_p_list = [A.T @ A for A in A_matrices_by_focus[z_idx]]\n        T_matrices.append(T_p_list)\n\n    # Helper function to compute the objective J_k(m) for a single corner k.\n    def compute_Jk(m, corner_params, all_T_mats, t_vec, lam):\n        z_idx = corner_params['z_idx']\n        Dk = corner_params['D']\n        T_mats_for_focus = all_T_mats[z_idx]\n        \n        image_error = 0.0\n        for p in range(P):\n            T_kp = T_mats_for_focus[p]\n            I_p = Dk * (m @ T_kp @ m)\n            residual_p = I_p - t_vec[p]\n            image_error += residual_p**2\n        \n        reg_term = lam * np.sum(m**2)\n        \n        return 0.5 * (image_error + reg_term)\n\n    # Helper function to compute the robust objective g(m) = max_k J_k(m).\n    def compute_g(m, all_corners, all_T_mats, t_vec, lam):\n        Jk_values = [compute_Jk(m, c, all_T_mats, t_vec, lam) for c in all_corners]\n        return np.max(Jk_values) if Jk_values else 0.0\n\n    # Helper function to compute the gradient of J_k(m).\n    def compute_grad_Jk(m, corner_params, all_T_mats, t_vec, lam):\n        z_idx = corner_params['z_idx']\n        Dk = corner_params['D']\n        T_mats_for_focus = all_T_mats[z_idx]\n        \n        grad = np.zeros_like(m)\n        for p in range(P):\n            T_kp = T_mats_for_focus[p]\n            I_p = Dk * (m @ T_kp @ m)\n            residual_p = I_p - t_vec[p]\n            # Gradient of quadratic form m.T @ T @ m is (T + T.T) @ m\n            grad += residual_p * Dk * (T_kp + T_kp.T) @ m\n        \n        grad += lam * m\n        return grad\n\n    # 2. Main Algorithm\n    m_current = np.array(m0, dtype=float)\n    t_vec = np.array(t, dtype=float)\n    \n    # Compute initial objective g(m_0)\n    g0 = compute_g(m_current, corners, T_matrices, t_vec, lambda_reg)\n\n    # 3. Perform N iterations of projected subgradient descent\n    for _ in range(N):\n        # Compute J_k for all corners\n        Jk_values = np.array([compute_Jk(m_current, c, T_matrices, t_vec, lambda_reg) for c in corners])\n        \n        # Identify the active set K*\n        max_Jk = np.max(Jk_values)\n        active_indices = np.where(Jk_values >= max_Jk - tau)[0]\n        \n        # Compute the subgradient (average of gradients from active set)\n        subgradient = np.zeros_like(m_current)\n        for idx in active_indices:\n            grad_k = compute_grad_Jk(m_current, corners[idx], T_matrices, t_vec, lambda_reg)\n            subgradient += grad_k\n        \n        if len(active_indices) > 0:\n            subgradient /= len(active_indices)\n\n        # Update and project m\n        m_temp = m_current - alpha * subgradient\n        m_current = np.clip(m_temp, 0.0, 1.0)\n    \n    # 4. Compute final objective g(m_N)\n    gN = compute_g(m_current, corners, T_matrices, t_vec, lambda_reg)\n    \n    # 5. Return the objective reduction\n    return g0 - gN\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"n\": 3, \"P\": 2,\n            \"A_matrices_by_focus\": [\n                [np.array([[1.0, 0.1, 0.0], [0.0, 0.9, 0.1], [0.0, 0.0, 0.8]]),\n                 np.array([[0.7, 0.1, 0.0], [0.0, 0.8, 0.1], [0.0, 0.0, 0.9]])],\n                [np.array([[0.95, 0.08, 0.0], [0.0, 0.85, 0.08], [0.0, 0.0, 0.75]]),\n                 np.array([[0.65, 0.08, 0.0], [0.0, 0.75, 0.08], [0.0, 0.0, 0.85]])]\n            ],\n            \"doses\": [0.9, 1.1], \"t\": [0.8, 0.6],\n            \"lambda_reg\": 0.01, \"alpha\": 0.05, \"N\": 50, \"tau\": 1e-12,\n            \"m0\": [0.5, 0.5, 0.5]\n        },\n        # Case 2\n        {\n            \"n\": 3, \"P\": 3,\n            \"A_matrices_by_focus\": [\n                [np.array([[1.1, 0.2, 0.0], [0.0, 0.9, 0.15], [0.0, 0.0, 0.7]]),\n                 np.array([[0.9, 0.15, 0.0], [0.0, 0.85, 0.1], [0.0, 0.0, 0.65]]),\n                 np.array([[0.6, 0.1, 0.0], [0.0, 0.7, 0.1], [0.0, 0.0, 0.9]])],\n                [np.array([[1.0, 0.18, 0.0], [0.0, 0.85, 0.12], [0.0, 0.0, 0.65]]),\n                 np.array([[0.85, 0.12, 0.0], [0.0, 0.8, 0.09], [0.0, 0.0, 0.6]]),\n                 np.array([[0.55, 0.09, 0.0], [0.0, 0.65, 0.08], [0.0, 0.0, 0.85]])]\n            ],\n            \"doses\": [0.8, 1.2], \"t\": [0.9, 0.7, 0.5],\n            \"lambda_reg\": 0.02, \"alpha\": 0.05, \"N\": 60, \"tau\": 1e-12,\n            \"m0\": [0.5, 0.5, 0.5]\n        },\n        # Case 3\n        {\n            \"n\": 3, \"P\": 1,\n            \"A_matrices_by_focus\": [\n                [np.array([[0.8, 0.1, 0.0], [0.0, 0.8, 0.1], [0.0, 0.0, 0.8]])],\n                [np.array([[0.8, 0.1, 0.0], [0.0, 0.8, 0.1], [0.0, 0.0, 0.8]])]\n            ],\n            \"doses\": [1.0, 1.0], \"t\": [0.5],\n            \"lambda_reg\": 0.0, \"alpha\": 0.1, \"N\": 100, \"tau\": 1e-12,\n            \"m0\": [0.5, 0.5, 0.5]\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_smo_optimization(**params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}