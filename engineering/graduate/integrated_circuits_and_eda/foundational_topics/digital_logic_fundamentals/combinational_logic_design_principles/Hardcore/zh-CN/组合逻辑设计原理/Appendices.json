{
    "hands_on_practices": [
        {
            "introduction": "任何组合逻辑函数都可以由一个通用门集（如与非门）来构建，这是数字电路设计的一个基本原则。本练习将引导您完成从抽象的函数定义（真值表）到具体的物理实现的全过程，涵盖逻辑最小化和工艺映射这两个核心环节。通过这个实践，您将掌握如何将理论上的布尔表达式转化为实际、高效的门级电路 。",
            "id": "4261387",
            "problem": "考虑一个布尔函数 $f(x,y,z)$，它有三个二进制输入 $x$、$y$、$z$ 和一个二进制输出 $f$。$f$ 的真值表由以下映射指定：\n$$\n\\begin{aligned}\nf(0,0,0)=0,\\quad f(0,0,1)=1,\\quad f(0,1,0)=0,\\quad f(0,1,1)=1,\\\\\nf(1,0,0)=0,\\quad f(1,0,1)=0,\\quad f(1,1,0)=1,\\quad f(1,1,1)=1.\n\\end{aligned}\n$$\n要求您仅使用双输入 $\\mathrm{NAND}$ 门（与非门）来综合 $f$，并遵循以下约束条件：\n- 所有原始输入仅以其原变量形式提供。\n- 任何逻辑反相必须通过将其两个输入端短接的双输入 $\\mathrm{NAND}$ 门来实现。\n- 每个门的扇入数限制为 $2$；扇出数无限制。\n- 中间结果可以共享，不产生额外成本。\n- 成本度量是所使用的双输入 $\\mathrm{NAND}$ 门的总数。\n\n仅从布尔代数公理、Shannon 协因子原理和 De Morgan 定律出发，推导出一个能最小化双输入 $\\mathrm{NAND}$ 门总数的实现方案。证明在所述约束条件下，您的门数量是最小的。请提供您的最终答案，该答案为一个整数，等于所需的双输入 $\\mathrm{NAND}$ 门的最小数量。无需四舍五入，也无需单位。",
            "solution": "该问题要求在特定约束条件下，使用最少数量的双输入 $\\mathrm{NAND}$ 门来综合布尔函数 $f(x,y,z)$。该函数由一个真值表定义。综合过程将首先为 $f$ 找到一个最小布尔表达式，然后仅使用双输入 $\\mathrm{NAND}$ 门来实现它，同时遵守所有既定约束。最后，必须正式证明所得实现的最小性。\n\n首先，我们通过从提供的真值表中推导 $f(x,y,z)$ 的布尔表达式来形式化问题。对于以下输入组合（最小项），函数的输出为 $1$：\n- $(x,y,z) = (0,0,1)$，对应于最小项 $\\bar{x}\\bar{y}z$。\n- $(x,y,z) = (0,1,1)$，对应于最小项 $\\bar{x}yz$。\n- $(x,y,z) = (1,1,0)$，对应于最小项 $xy\\bar{z}$。\n- $(x,y,z) = (1,1,1)$，对应于最小项 $xyz$。\n\n$f$ 的“积之和”(SOP) 表达式是这些最小项的逻辑和：\n$$f(x,y,z) = \\bar{x}\\bar{y}z + \\bar{x}yz + xy\\bar{z} + xyz$$\n为了找到一个最小 SOP 表达式，我们可以使用布尔代数公理，特别是邻接律 ($ab+a\\bar{b}=a$)。应用此方法的一种系统性方式是通过卡诺图 (Karnaugh map)。$f(x,y,z)$ 的卡诺图如下：\n$$\n\\begin{array}{c|cccc}\n\\large{f}  yz=00  yz=01  yz=11  yz=10 \\\\\n\\hline\nx=0  0  1  1  0 \\\\\nx=1  0  0  1  1 \\\\\n\\end{array}\n$$\n我们对相邻的 $1$ 进行分组以简化表达式。\n1. 在行 $x=0$ 中，位于列 $yz=01$ 和 $yz=11$ 的两个 $1$ 可以被分为一组。这对应于 $(\\bar{x}\\bar{y}z + \\bar{x}yz)$，可简化为 $\\bar{x}z(\\bar{y}+y) = \\bar{x}z$。\n2. 在行 $x=1$ 中，位于列 $yz=11$ 和 $yz=10$ 的两个 $1$ 可以被分为一组。这对应于 $(xyz + xy\\bar{z})$，可简化为 $xy(z+\\bar{z}) = xy$。\n\n这两个分组覆盖了所有使 $f=1$ 的最小项。因此，该函数的最小“积之和”表达式为：\n$$f(x,y,z) = xy + \\bar{x}z$$\n接下来，我们必须仅使用双输入 $\\mathrm{NAND}$ 门来实现这个表达式。一个两级 SOP 表达式可以直接转换为一个两级 $\\mathrm{NAND}$-$\\mathrm{NAND}$ 实现。我们使用对合律 ($a=\\bar{\\bar{a}}$) 和 De Morgan 定律 ($\\overline{a+b}=\\bar{a}\\bar{b}$)：\n$$f = xy + \\bar{x}z = \\overline{\\overline{(xy + \\bar{x}z)}} = \\overline{(\\overline{xy}) \\cdot (\\overline{\\bar{x}z})}$$\n假设输入 $x$、$y$、$z$ 和 $\\bar{x}$ 均可用，此表达式可以用三个 $\\mathrm{NAND}$ 门实现：\n1. 一个门计算 $\\overline{xy} = \\mathrm{NAND}(x, y)$。\n2. 第二个门计算 $\\overline{\\bar{x}z} = \\mathrm{NAND}(\\bar{x}, z)$。\n3. 第三个门计算最终输出 $f = \\mathrm{NAND}(\\overline{xy}, \\overline{\\bar{x}z})$。\n\n然而，题目陈述了两个关键约束：\n1. 原始输入仅以其原变量形式 ($x, y, z$) 提供。\n2. 任何逻辑反相必须通过将其输入端短接的双输入 $\\mathrm{NAND}$ 门来实现，例如 $\\bar{x} = \\mathrm{NAND}(x,x)$。\n\n我们的表达式需要反相输入 $\\bar{x}$。因此，我们必须使用一个 $\\mathrm{NAND}$ 门从 $x$ 显式地生成 $\\bar{x}$。完整的实现如下：\n- 门 1: $g_1 = \\mathrm{NAND}(x, x) = \\bar{x}$\n- 门 2: $g_2 = \\mathrm{NAND}(x, y) = \\overline{xy}$\n- 门 3: $g_3 = \\mathrm{NAND}(g_1, z) = \\mathrm{NAND}(\\bar{x}, z) = \\overline{\\bar{x}z}$\n- 门 4: $f = \\mathrm{NAND}(g_2, g_3) = \\mathrm{NAND}(\\overline{xy}, \\overline{\\bar{x}z}) = xy + \\bar{x}z$\n\n这个实现总共使用了四个双输入 $\\mathrm{NAND}$ 门。\n\n最后一步是证明这个四门方案是最小的。\n1. 最小 SOP 表达式 $f = xy + \\bar{x}z$ 和最小“和之积”(POS) 表达式 $f = (x+z)(\\bar{x}+y)$ 都需要文字 $\\bar{x}$。由于只提供原变量输入，必须至少使用一个门作为反相器来生成 $\\bar{x} = \\mathrm{NAND}(x,x)$。这就确定了一个门的必要成本。\n\n2. 让我们分析假设 $x, y, z$ 和 $\\bar{x}$ 均作为输入可用的情况下，仍需实现的函数 $g = xy + \\bar{x}z$。我们需要确定实现 $g$ 所需的 $\\mathrm{NAND}$ 门的最小数量。\n   - 单个 $\\mathrm{NAND}$ 门只能实现 $\\overline{ab}$ 形式的函数。函数 $g$ 是一个积之和，不等价于 $\\overline{ab}$。\n   - $g$ 能否用两个 $\\mathrm{NAND}$ 门实现？一个双门 $\\mathrm{NAND}$ 电路可以实现 $h_1 = \\mathrm{NAND}(a, \\mathrm{NAND}(b,c)) = \\overline{a(\\overline{bc})} = \\bar{a}+bc$ 或 $h_2 = \\mathrm{NAND}(\\mathrm{NAND}(a,b), c) = \\overline{(\\overline{ab})c} = ab+\\bar{c}$ 形式的函数。我们需要检查 $g=xy+\\bar{x}z$ 是否能通过将输入 $\\{x,y,z,\\bar{x}\\}$ 的某个赋值赋给 $\\{a,b,c\\}$ 来匹配这两种形式中的任何一种。\n     - 将 $g$ 与 $h_1=\\bar{a}+bc$ 匹配：我们需要 $\\bar{a}+bc = xy+\\bar{x}z$。这需要两个乘积项之和。实现这一点的唯一方法是，例如，$\\bar{a}=xy$，这意味着 $a=\\overline{xy}$。这不是一个原始输入，而是一个门的输出，这将违反实现 $g$ 的两门限制。或者，如果 $\\bar{a}$ 是单个文字，例如 $\\bar{a}=\\bar{x}$，那么 $a=x$。函数变为 $h_1 = \\bar{x}+bc$。我们需要 $\\bar{x}+bc = xy+\\bar{x}z$。使用性质 $A+\\bar{A}B=A+B$，我们有 $xy+\\bar{x}z = y+\\bar{x}z$。所以我们需要 $\\bar{x}+bc = y+\\bar{x}z$。这意味着 $bc$ 必须等于 $y$ 并引入对 $z$ 的依赖关系，这是不可能的。例如，如果 $x=1$，我们需要 $bc=y$；如果 $x=0$，我们需要 $1+bc = 1$，这永远成立，并且没有将 $bc$ 约束为等于 $z$。用这种形式实现是不可能的。\n     - 将 $g$ 与 $h_2=ab+\\bar{c}$ 匹配：我们需要 $ab+\\bar{c} = xy+\\bar{x}z$。这种形式有两个乘积项，但其中一个是单个反相文字。要使 $ab+\\bar{c}$ 匹配 $xy+\\bar{x}z$，这些项必须等价。这是不可能的，因为 $xy$ 和 $\\bar{x}z$ 都是两个文字的乘积。\n\n3. 由于 $g$ 无法用一个或两个 $\\mathrm{NAND}$ 门实现，它至少需要三个 $\\mathrm{NAND}$ 门。我们的实现 $g = \\mathrm{NAND}(\\mathrm{NAND}(x, y), \\mathrm{NAND}(\\bar{x}, z))$ 正好使用了三个门。\n\n4. 因此，门的总数的最小值为反相器所需的最小门数与剩余逻辑所需的最小门数之和：$1$ (用于 $\\bar{x}$) + $3$ (用于 $xy+\\bar{x}z$) = $4$。\n\n我们构建的电路使用了四个门，这与已证明的下限相匹配。因此，该实现是最小的。",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "现实世界的设计中，某些输入组合可能永远不会出现，或者在某些输入下输出是无关紧要的。本练习引入了“无关项”（don't-care）的概念，并演示了如何策略性地利用这种设计自由度来获得更简洁、更高效的电路实现。掌握无关项的优化方法，对于在实际工程中减小芯片面积和功耗至关重要 。",
            "id": "4261341",
            "problem": "在集成电路的电子设计自动化（EDA）背景下，考虑一个关于变量 $x_1,x_2,x_3,x_4$ 的不完全指定的布尔函数 $f:\\{0,1\\}^4 \\to \\{0,1\\}$。该函数由其 on-set（导通集）$\\mathcal{F}$、off-set（关断集）$\\mathcal{R}$ 和 do not care set（无关项集）$\\mathcal{D}$ 指定，这些集合基于常规的二进制到整数映射 $m = 8x_1 + 4x_2 + 2x_3 + x_4$ 进行索引。这些集合是：\n$\\mathcal{F} = \\{m_0, m_1, m_2, m_5, m_8, m_9, m_{10}, m_{13}\\}$，\n$\\mathcal{D} = \\{m_3, m_{11}, m_{15}\\}$，\n$\\mathcal{R} = \\{m_4, m_6, m_7, m_{12}, m_{14}\\}$。\n从不完全指定的布尔函数、蕴含项、素蕴含项以及“积之和”（SOP）与“和之积”（POS）之间的对偶性的基本定义出发，通过策略性地使用集合 $\\mathcal{D}$ 来最小化表达式形式，同时不覆盖 $\\mathcal{R}$ 中的任何元素，推导出一个最小SOP和一个最小POS。对于文字计数，将SOP文字计数 $L_{\\mathrm{SOP}}$ 定义为SOP中所有乘积项中文字的总出现次数，将POS文字计数 $L_{\\mathrm{POS}}$ 定义为POS中所有和子句中文字的总出现次数。此处，变量以原变量或反变量形式每出现一次，就算作一个文字。计算差值 $\\Delta = L_{\\mathrm{POS}} - L_{\\mathrm{SOP}}$。将最终答案表示为单个实数值。无需四舍五入，不涉及单位。",
            "solution": "我们从定义开始：一个不完全指定的布尔函数为 on-set（导通集）$\\mathcal{F}$ 中的最小项分配输出1，为 off-set（关断集）$\\mathcal{R}$ 中的最小项分配输出0，并允许为 do not care set（无关项集）$\\mathcal{D}$ 中的最小项任意分配（0或1）。在最小化中，$f$ 的SOP的蕴含项可以覆盖 $\\mathcal{F}$ 和 $\\mathcal{D}$ 中的最小项，但绝不能覆盖 $\\mathcal{R}$ 中的任何最小项；对于 $\\overline{f}$ 的SOP，蕴含项可以覆盖 $\\mathcal{R}$ 和 $\\mathcal{D}$ 中的最小项，但绝不能覆盖 $\\mathcal{F}$ 中的任何最小项。素蕴含项是一个蕴含项，它不能在不覆盖允许集合之外的最小项的情况下被扩大（通过删除文字）。SOP和POS之间的对偶性由布尔代数中的德摩根定律和分配律给出。\n\n步骤 $1$：识别 $\\mathcal{F}$ 中能形成 $f$ 的SOP的大蕴含项的结构规律。列举 $\\mathcal{F}$ 和 $\\mathcal{D}$ 中的最小项及其位模式 $(x_1,x_2,x_3,x_4)$：\n$m_0=(0,0,0,0)$, $m_1=(0,0,0,1)$, $m_2=(0,0,1,0)$, $m_5=(0,1,0,1)$, $m_8=(1,0,0,0)$, $m_9=(1,0,0,1)$, $m_{10}=(1,0,1,0)$, $m_{13}=(1,1,0,1)$, 且 $\\mathcal{D}$ 包含 $m_3=(0,0,1,1)$, $m_{11}=(1,0,1,1)$, $m_{15}=(1,1,1,1)$。\n\n观察到所有 $x_2=0$ 的最小项要么在 $\\mathcal{F}$ 中，要么在 $\\mathcal{D}$ 中：集合 $\\{m_0,m_1,m_2,m_3,m_8,m_9,m_{10},m_{11}\\}$ 对应于所有 $(x_1,x_3,x_4)$ 组合下 $x_2=0$ 的情况。这些最小项中没有一个在 $\\mathcal{R}$ 中，因为所列出的每个 $m \\in \\mathcal{R}$ 都具有 $x_2=1$。因此，蕴含项 $\\overline{x_2}$（一个固定 $x_2 = 0$ 的单文字蕴含项）是有效的，它覆盖了 $\\mathcal{F}$ 中的 $m_0,m_1,m_2,m_8,m_9,m_{10}$，并使用了 $\\mathcal{D}$ 中的 $m_3,m_{11}$，将该蕴含项扩展为其最大范围，成为一个素蕴含项。\n\n步骤 $2$：覆盖未被 $\\overline{x_2}$ 覆盖的剩余 on-set 最小项 $m_5=(0,1,0,1)$ 和 $m_{13}=(1,1,0,1)$。这两个仅在 $x_1$ 上不同，并共享 $x_2=1$, $x_3=0$, $x_4=1$，因此它们形成一个蕴含项 $x_2 \\overline{x_3} x_4$。这个蕴含项不覆盖 $\\mathcal{R}$ 中的任何最小项，因为固定 $(x_2,x_3,x_4)=(1,0,1)$ 会产生集合 $\\{m_5,m_{13}\\}$（如果 $x_3$ 为 $1$ 则可能包含 $\\{m_7,m_{15}\\}$，但这里 $x_3=0$ 排除了这种可能性）。$m_5$ 和 $m_{13}$ 都在 $\\mathcal{F}$ 中。\n\n步骤 $3$：通过吸收律简化SOP。使用布尔代数，对于任何项 $T$，有 $(\\overline{x_2} + x_2 T) = \\overline{x_2} + T$，因为\n$\\overline{x_2} + x_2 T = (\\overline{x_2} + T)(\\overline{x_2} + x_2) = (\\overline{x_2} + T)\\cdot 1 = \\overline{x_2} + T$。\n取 $T = \\overline{x_3} x_4$，我们得到\n$\\overline{x_2} + x_2 \\overline{x_3} x_4 = \\overline{x_2} + \\overline{x_3} x_4$。\n因此，一个最小SOP是\n$$f_{\\mathrm{SOP}} = \\overline{x_2} + \\overline{x_3} x_4$$\n为确认其最小性，注意到 $\\overline{x_2}$ 是一个素蕴含项，它跨越了所有 $x_2=0$ 的允许最小项，并且需要 $\\overline{x_3} x_4$ 来覆盖未被 $\\overline{x_2}$ 覆盖的 $m_5,m_{13}$。没有单个蕴含项可以在避免 $m_7 \\in \\mathcal{R}$ 的同时覆盖 $m_5$，除非它固定 $\\overline{x_3}=1$ 和 $x_4=1$，并且 $x_2$ 要么固定为 $1$ 要么保持自由；让 $x_2$ 自由会包含 $m_1 \\in \\mathcal{F}$（可接受）和 $m_9 \\in \\mathcal{F}$（可接受），但仍然无法覆盖 $m_{13}$，除非包含 $x_2=1$，从而得出所选的 $\\overline{x_3} x_4$ 蕴含项是与避免 $\\mathcal{R}$ 相一致的最小扩展。\n\n步骤 $4$：通过对偶性推导最小POS。在 $\\mathcal{R} \\cup \\mathcal{D}$ 上最小化补函数 $\\overline{f}$ 的SOP，同时避免 $\\mathcal{F}$。off-set 最小项是 $m_4=(0,1,0,0)$, $m_6=(0,1,1,0)$, $m_7=(0,1,1,1)$, $m_{12}=(1,1,0,0)$, $m_{14}=(1,1,1,0)$，无关项是 $m_3=(0,0,1,1)$, $m_{11}=(1,0,1,1)$, $m_{15}=(1,1,1,1)$。我们识别出 $\\overline{f}$ 的两个大蕴含项：\n- $x_2 \\overline{x_4}$ 覆盖 $\\{m_4,m_6,m_{12},m_{14}\\}$，它们都在 $\\mathcal{R}$ 中，且不与 $\\mathcal{F}$ 相交。\n- $x_2 x_3$ 覆盖 $\\{m_6,m_7,m_{14},m_{15}\\}$，其中 $\\{m_6,m_7,m_{14}\\} \\subset \\mathcal{R}$ 且 $m_{15} \\in \\mathcal{D}$，且不与 $\\mathcal{F}$ 相交。\n这两个蕴含项覆盖了所有的 $\\mathcal{R}$。因此 $\\overline{f}$ 的一个最小SOP是\n$$\\overline{f}_{\\mathrm{SOP}} = x_2 \\overline{x_4} + x_2 x_3$$\n根据德摩根定律，\n$$f = \\overline{(\\overline{f})} = \\overline{(x_2 \\overline{x_4} + x_2 x_3)} = \\overline{(x_2 \\overline{x_4})} \\cdot \\overline{(x_2 x_3)} = (\\overline{x_2} + x_4)\\cdot(\\overline{x_2} + \\overline{x_3})$$\n得到一个POS\n$$f_{\\mathrm{POS}} = (\\overline{x_2} + x_4)(\\overline{x_2} + \\overline{x_3})$$\n可选地，我们可以通过分配律 $x + yz = (x + y)(x + z)$ 来验证其等价性，取 $x = \\overline{x_2}$, $y = \\overline{x_3}$, $z = x_4$，这将 $\\overline{x_2} + \\overline{x_3} x_4$ 转换为 $(\\overline{x_2} + \\overline{x_3})(\\overline{x_2} + x_4)$，与推导出的POS相匹配。\n\n步骤 $5$：计算文字数。对于SOP, $f_{\\mathrm{SOP}} = \\overline{x_2} + \\overline{x_3} x_4$ 由一个含1个文字的项和一个含2个文字的项组成，所以\n$$L_{\\mathrm{SOP}} = 1 + 2 = 3$$\n对于POS, $f_{\\mathrm{POS}} = (\\overline{x_2} + x_4)(\\overline{x_2} + \\overline{x_3})$ 由两个各含2个文字的子句组成，所以\n$$L_{\\mathrm{POS}} = 2 + 2 = 4$$\n因此，所求的差值为\n$$\\Delta = L_{\\mathrm{POS}} - L_{\\mathrm{SOP}} = 4 - 3 = 1$$\n\n无需四舍五入或单位，结果是一个单一的实数值。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "理论上最简的两级逻辑形式（积之和或和之积）虽然易于推导，但未必是速度最快的实现方案。本练习旨在探讨电路结构与性能（特别是延迟）之间的关键权衡。通过对比奇偶校验函数的两级和多级实现，您将亲身体会到为什么逻辑分解是设计高速数字电路不可或缺的技术 。",
            "id": "4261369",
            "problem": "在电子设计自动化（EDA）的背景下，考虑在扇入约束下组合网络的延迟优化。假设门库由2输入与门（$\\land$）、2输入或门（$\\lor$）和非门（$\\neg$）组成。假设采用一种技术无关延迟模型，其中每个门的延迟为1个归一化时间单位，导线延迟可忽略不计，关键路径延迟定义为从任意主输入到主输出的最长拓扑路径上门延迟的总和。进一步假设每个主输入的原变量和反变量（即$x_i$和$\\neg x_i$）都可以直接使用，没有额外的延迟。\n\n定义布尔函数 $P_{64}(x_1,\\dots,x_{64})$ 为64个输入的奇偶校验函数，即 $P_{64}(x_1,\\dots,x_{64}) = x_1 \\oplus x_2 \\oplus \\cdots \\oplus x_{64}$，其中 $\\oplus$ 表示异或。考虑以下两种遵循最大扇入为2的约束的 $P_{64}$ 实现方案：\n\n1. 两级最小积之和范式：奇偶校验函数的ON-set中所有最小项的析取。在扇入约束下，每个64文字的合取项通过一个由2输入与门构成的平衡二叉树实现，所有乘积项的析取通过一个由2输入或门构成的平衡二叉树实现。\n\n2. 因子分解的多级网络：一个由2输入$\\oplus$算子构成的平衡二叉树，将64个输入归约为1个输出。每个2输入异或门通过恒等式 $x \\oplus y = (x \\lor y) \\land \\neg(x \\land y)$ 仅使用与门、或门和非门来实现。\n\n仅使用所述定义和延迟模型，推导实现方案(1)的精确关键路径延迟$D_{\\mathrm{SOP}}$和实现方案(2)的精确关键路径延迟$D_{\\mathrm{XOR}}$。然后计算延迟优势$\\Delta = D_{\\mathrm{SOP}} - D_{\\mathrm{XOR}}$。将最终答案表示为单个实数值，无需四舍五入。",
            "solution": "用户提供了一个问题陈述，在尝试求解之前，必须首先验证其正确性、完整性和科学依据。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- **门库：**2输入与门（$\\land$）、2输入或门（$\\lor$）和非门（$\\neg$）。\n- **扇入约束：**最大扇入为2。\n- **延迟模型：**\n    - 任何门（$\\land$, $\\lor$, $\\neg$）的延迟为1个归一化时间单位。\n    - 导线延迟可忽略不计。\n    - 关键路径延迟是沿最长路径的门延迟之和。\n- **主输入：**原变量$x_i$和反变量$\\neg x_i$在时间0时均可用。\n- **待实现的函数：**$P_{64}(x_1, \\dots, x_{64}) = x_1 \\oplus x_2 \\oplus \\cdots \\oplus x_{64}$。\n- **实现方案(1) - 积之和范式：**\n    - 结构：两级最小积之和（SOP）范式。\n    - 与平面：每个最小项（一个64文字的合取）由一个2输入与门构成的平衡二叉树实现。\n    - 或平面：所有乘积项的析取由一个2输入或门构成的平衡二叉树实现。\n- **实现方案(2) - 异或树范式：**\n    - 结构：一个由2输入$\\oplus$算子构成的平衡二叉树。\n    - 异或实现：每个2输入$\\oplus$门使用恒等式 $x \\oplus y = (x \\lor y) \\land \\neg(x \\land y)$ 来实现。\n- **目标：**\n    - 计算实现方案(1)的关键路径延迟$D_{\\mathrm{SOP}}$。\n    - 计算实现方案(2)的关键路径延迟$D_{\\mathrm{XOR}}$。\n    - 计算延迟优势$\\Delta = D_{\\mathrm{SOP}} - D_{\\mathrm{XOR}}$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题在科学上基于数字逻辑设计和电子设计自动化的原理。其模型和假设（单位门延迟、无导线延迟、互补输入可用性、扇入约束）是入门分析中使用的标准简化方法。奇偶校验函数是电路复杂度和延迟分析的经典基准。该问题定义明确，提供了推导所需延迟的所有必要信息。术语精确且客观。电路的构建虽然涉及非常大量的门（特别是对于积之和范式），但对于理论延迟计算而言，在概念上是合理的。该问题不违反任何基本原则，没有歧义，并且需要进行实质性的计算。\n\n**步骤3：结论与行动**\n该问题被判定为**有效**。将推导解答。\n\n### 解答推导\n\n**计算实现方案(1)的$D_{\\mathrm{SOP}}$**\n\n积之和范式实现的关键路径是穿过与平面（形成最小项）的最大延迟和穿过或平面（对所有最小项求和）的最大延迟之和。\n\n1.  **与平面延迟：**每个最小项是64个文字的合取。要使用2输入与门构成的平衡二叉树来实现一个64输入的与函数，树中的门级数决定了延迟。具有$N$个输入的平衡二叉树的深度为$\\lceil \\log_2(N) \\rceil$。\n    对于与平面，我们有$N = 64$个文字作为输入来形成每个最小项。\n    每个与树的深度为 $d_{\\land} = \\lceil \\log_2(64) \\rceil$。\n    因为 $64 = 2^6$，我们有 $d_{\\land} = \\log_2(2^6) = 6$。\n    穿过与平面的延迟是 $d_{\\land} \\times 1 = 6$ 个时间单位。\n\n2.  **或平面延迟：**函数 $P_{64}$ 是64个变量的异或。这是一个奇校验函数。一个$n$变量奇偶校验函数（奇或偶）的ON-set由$2^{n-1}$个最小项组成。奇偶校验函数的素蕴含项就是最小项本身，因此最小积之和范式是ON-set中所有最小项的析取。\n    对于$n=64$，最小项的数量$M$为$M = 2^{64-1} = 2^{63}$。\n    这$M$个项必须使用一个由2输入或门构成的平衡二叉树来组合。该树的深度为：\n    $d_{\\lor} = \\lceil \\log_2(M) \\rceil = \\lceil \\log_2(2^{63}) \\rceil = 63$。\n    穿过或平面的延迟是$d_{\\lor} \\times 1 = 63$个时间单位。\n\n3.  **总SOP延迟：**总关键路径延迟$D_{\\mathrm{SOP}}$是与平面延迟和或平面延迟之和。\n    $$D_{\\mathrm{SOP}} = d_{\\land} + d_{\\lor} = 6 + 63 = 69$$\n\n**计算实现方案(2)的$D_{\\mathrm{XOR}}$**\n\n该实现方案使用基于2输入$\\oplus$模块的平衡二叉树的多级结构。\n\n1.  **异或模块延迟 ($d_{\\oplus}$):** 首先，我们必须计算单个2输入$\\oplus$模块的延迟，该模块实现为$x \\oplus y = (x \\lor y) \\land \\neg(x \\land y)$。输入$x$和$y$在时间$t=0$时可用。\n    - $x \\lor y$ 门的输出在 $t=1$ 时可用。\n    - $x \\land y$ 门的输出在 $t=1$ 时可用。\n    - $\\neg(x \\land y)$ 门的输出，它以$\\land$门的输出为输入，在 $t = 1 + 1 = 2$ 时可用。\n    - 最终的$\\land$门以$(x \\lor y)$（在$t=1$时可用）和$\\neg(x \\land y)$（在$t=2$时可用）作为输入。该门的输出在时间$\\max(1, 2) + 1 = 2 + 1 = 3$时稳定。\n    因此，一个2输入$\\oplus$模块的延迟为$d_{\\oplus} = 3$个时间单位。\n\n2.  **异或树延迟：** 整体函数 $P_{64}$ 被实现为这些$\\oplus$模块构成的平衡二叉树。为组合64个输入，该树的深度为：\n    $d_{\\text{tree}} = \\lceil \\log_2(64) \\rceil = 6$。\n    关键路径在每级都穿过一个$\\oplus$模块，共6级。总延迟是树的深度与单个模块延迟的乘积。\n    $$D_{\\mathrm{XOR}} = d_{\\text{tree}} \\times d_{\\oplus} = 6 \\times 3 = 18$$\n\n**计算延迟优势 $\\Delta$**\n\n延迟优势是两个计算出的延迟之差。\n$$\\Delta = D_{\\mathrm{SOP}} - D_{\\mathrm{XOR}} = 69 - 18 = 51$$\n延迟优势为51个归一化时间单位。",
            "answer": "$$\\boxed{51}$$"
        }
    ]
}