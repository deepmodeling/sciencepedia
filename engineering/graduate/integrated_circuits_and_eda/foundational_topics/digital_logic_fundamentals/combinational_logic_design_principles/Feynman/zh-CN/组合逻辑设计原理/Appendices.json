{
    "hands_on_practices": [
        {
            "introduction": "在实际的电路设计中，我们常常会遇到某些输入组合永远不会出现，或者其输出对后续逻辑无关紧要的情况。这些情况被称为“无关项”($don't-cares$)，为逻辑化简提供了宝贵的自由度。本练习  将指导你如何通过策略性地利用这些无关项来同时优化逻辑函数的“与或式”($SOP$)和“或与式”($POS$)这两种标准形式，从而找到文字量最少的实现，这是设计面积高效的组合逻辑电路的基本功。",
            "id": "4261341",
            "problem": "在集成电路的电子设计自动化（EDA）背景下，考虑一个关于变量 $x_1,x_2,x_3,x_4$ 的不完全指定布尔函数 $f:\\{0,1\\}^4 \\to \\{0,1\\}$。该函数由其开集 $\\mathcal{F}$、关集 $\\mathcal{R}$ 和无关项集 $\\mathcal{D}$ 定义，这些集合是基于通过常规二进制到整数映射 $m = 8x_1 + 4x_2 + 2x_3 + x_4$ 索引的最小项。这些集合是：\n$\\mathcal{F} = \\{m_0, m_1, m_2, m_5, m_8, m_9, m_{10}, m_{13}\\}$，\n$\\mathcal{D} = \\{m_3, m_{11}, m_{15}\\}$，\n$\\mathcal{R} = \\{m_4, m_6, m_7, m_{12}, m_{14}\\}$。\n从不完全指定布尔函数、蕴含项、主蕴含项以及积之和（SOP）与和之积（POS）之间的对偶性的基本定义出发，通过策略性地使用集合 $\\mathcal{D}$ 来最小化表达式形式，且不覆盖 $\\mathcal{R}$ 中的任何元素，推导出 $f$ 的一个最小SOP和一个最小POS。对于文字计数，将SOP文字数 $L_{\\mathrm{SOP}}$ 定义为SOP中所有乘积项中文字的总出现次数，将POS文字数 $L_{\\mathrm{POS}}$ 定义为POS中所有和子句中文字的总出现次数。在此，变量以其原变量或反变量形式每出现一次，就算作一个文字。计算差值 $\\Delta = L_{\\mathrm{POS}} - L_{\\mathrm{SOP}}$。将最终答案表示为一个单一的实数。无需四舍五入，也不涉及单位。",
            "solution": "我们从定义开始：一个不完全指定布尔函数将输出 $1$ 赋给开集 $\\mathcal{F}$ 中的最小项，将输出 $0$ 赋给关集 $\\mathcal{R}$ 中的最小项，并允许对无关项集 $\\mathcal{D}$ 中的最小项进行任意赋值（$0$ 或 $1$）。在最小化过程中，$f$ 的SOP的蕴含项可以覆盖 $\\mathcal{F}$ 和 $\\mathcal{D}$ 中的最小项，但绝不能覆盖 $\\mathcal{R}$ 中的任何最小项；对于 $\\overline{f}$ 的SOP，蕴含项可以覆盖 $\\mathcal{R}$ 和 $\\mathcal{D}$ 中的最小项，但绝不能覆盖 $\\mathcal{F}$ 中的任何最小项。主蕴含项是一个蕴含项，它不能在不覆盖允许集合之外的最小项的情况下被扩大（通过删除文字）。SOP和POS之间的对偶性由布尔代数中的德摩根定律和分配律给出。\n\n步骤 $1$：识别 $\\mathcal{F}$ 中的结构规律，以在 $f$ 的SOP中形成大的蕴含项。用其比特模式 $(x_1,x_2,x_3,x_4)$ 列举 $\\mathcal{F}$ 和 $\\mathcal{D}$ 中的最小项：\n$m_0=(0,0,0,0)$，$m_1=(0,0,0,1)$，$m_2=(0,0,1,0)$，$m_5=(0,1,0,1)$，$m_8=(1,0,0,0)$，$m_9=(1,0,0,1)$，$m_{10}=(1,0,1,0)$，$m_{13}=(1,1,0,1)$，以及 $\\mathcal{D}$ 中的 $m_3=(0,0,1,1)$，$m_{11}=(1,0,1,1)$，$m_{15}=(1,1,1,1)$。\n\n观察到所有 $x_2=0$ 的最小项要么在 $\\mathcal{F}$ 中，要么在 $\\mathcal{D}$ 中：集合 $\\{m_0,m_1,m_2,m_3,m_8,m_9,m_{10},m_{11}\\}$ 对应于所有 $(x_1,x_3,x_4)$ 组合下的 $x_2=0$。这些最小项中没有一个在 $\\mathcal{R}$ 中，因为所列出的每个 $m \\in \\mathcal{R}$ 都具有 $x_2=1$。因此，蕴含项 $\\overline{x_2}$（一个将 $x_2$ 固定为 $0$ 的单文字蕴含项）是有效的，它覆盖了 $\\mathcal{F}$ 中的 $m_0,m_1,m_2,m_8,m_9,m_{10}$，并使用了 $\\mathcal{D}$ 中的 $m_3,m_{11}$ 将该蕴含项扩展到其作为主蕴含项的最大范围。\n\n步骤 $2$：覆盖剩余的开集最小项 $m_5=(0,1,0,1)$ 和 $m_{13}=(1,1,0,1)$，它们未被 $\\overline{x_2}$ 覆盖。这两个最小项仅在 $x_1$ 上不同，并共享 $x_2=1, x_3=0, x_4=1$，因此它们形成一个蕴含项 $x_2 \\overline{x_3} x_4$。这个蕴含项不覆盖 $\\mathcal{R}$ 中的任何最小项，因为固定 $(x_2,x_3,x_4)=(1,0,1)$ 产生集合 $\\{m_5,m_{13}\\}$（如果 $x_3$ 是 $1$，则可能还包括 $\\{m_7,m_{15}\\}$，但这里 $x_3=0$ 排除了这种可能性）。$m_5$ 和 $m_{13}$ 都在 $\\mathcal{F}$ 中。\n\n步骤 $3$：通过吸收律简化SOP。使用布尔代数，对于任何项 $T$，有 $(\\overline{x_2} + x_2 T) = \\overline{x_2} + T$，因为\n$\\overline{x_2} + x_2 T = (\\overline{x_2} + T)(\\overline{x_2} + x_2) = (\\overline{x_2} + T)\\cdot 1 = \\overline{x_2} + T$。\n取 $T = \\overline{x_3} x_4$，我们有\n$\\overline{x_2} + x_2 \\overline{x_3} x_4 = \\overline{x_2} + \\overline{x_3} x_4$。\n因此，一个最小SOP是\n$f_{\\mathrm{SOP}} = \\overline{x_2} + \\overline{x_3} x_4$。\n为了确认其最小性，注意到 $\\overline{x_2}$ 是一个主蕴含项，它覆盖了所有 $x_2=0$ 的允许最小项，而 $\\overline{x_3} x_4$ 是覆盖 $m_5,m_{13}$ 所必需的，因为它们未被 $\\overline{x_2}$ 覆盖。没有单个蕴含项可以在覆盖 $m_5$ 的同时避免 $m_7 \\in \\mathcal{R}$，除非它将 $\\overline{x_3}$ 固定为 $1$ 且 $x_4$ 固定为 $1$，并且 $x_2$ 要么固定为 $1$ 要么不固定；不固定 $x_2$ 将会包括 $m_1 \\in \\mathcal{F}$（可接受）和 $m_9 \\in \\mathcal{F}$（可接受），但除非包含 $x_2=1$，否则仍然无法覆盖 $m_{13}$，这就产生了所选择的 $\\overline{x_3} x_4$ 蕴含项，作为与避免 $\\mathcal{R}$ 相一致的最小扩展。\n\n步骤 $4$：通过对偶性推导最小POS。在 $\\mathcal{R} \\cup \\mathcal{D}$ 上最小化补函数 $\\overline{f}$ 的SOP，同时避免 $\\mathcal{F}$。关集最小项是 $m_4=(0,1,0,0)$, $m_6=(0,1,1,0)$, $m_7=(0,1,1,1)$, $m_{12}=(1,1,0,0)$, $m_{14}=(1,1,1,0)$，无关项是 $m_3=(0,0,1,1)$, $m_{11}=(1,0,1,1)$, $m_{15}=(1,1,1,1)$。我们为 $\\overline{f}$ 识别出两个大的蕴含项：\n- $x_2 \\overline{x_4}$ 覆盖 $\\{m_4,m_6,m_{12},m_{14}\\}$，它们都在 $\\mathcal{R}$ 中，且不与 $\\mathcal{F}$ 相交。\n- $x_2 x_3$ 覆盖 $\\{m_6,m_7,m_{14},m_{15}\\}$，其中 $\\{m_6,m_7,m_{14}\\} \\subset \\mathcal{R}$ 且 $m_{15} \\in \\mathcal{D}$，并且不与 $\\mathcal{F}$ 相交。\n这两个蕴含项覆盖了 $\\mathcal{R}$ 的所有成员。因此，$\\overline{f}$ 的一个最小SOP是\n$\\overline{f}_{\\mathrm{SOP}} = x_2 \\overline{x_4} + x_2 x_3$。\n根据德摩根定律，\n$f = \\overline{(\\overline{f})} = \\overline{(x_2 \\overline{x_4} + x_2 x_3)} = \\overline{(x_2 \\overline{x_4})} \\cdot \\overline{(x_2 x_3)} = (\\overline{x_2} + x_4)\\cdot(\\overline{x_2} + \\overline{x_3})$，\n得到一个POS\n$f_{\\mathrm{POS}} = (\\overline{x_2} + x_4)(\\overline{x_2} + \\overline{x_3})$。\n可选地，我们可以通过取 $x = \\overline{x_2}$, $y = \\overline{x_3}$, $z = x_4$，使用分配律 $x + yz = (x + y)(x + z)$ 来验证等价性，这将 $\\overline{x_2} + \\overline{x_3} x_4$ 转换为 $(\\overline{x_2} + \\overline{x_3})(\\overline{x_2} + x_4)$，与推导出的POS相匹配。\n\n步骤 $5$：计算文字数。对于SOP，$f_{\\mathrm{SOP}} = \\overline{x_2} + \\overline{x_3} x_4$ 包含一个有 $1$ 个文字的项和一个有 $2$ 个文字的项，所以\n$L_{\\mathrm{SOP}} = 1 + 2 = 3$。\n对于POS，$f_{\\mathrm{POS}} = (\\overline{x_2} + x_4)(\\overline{x_2} + \\overline{x_3})$ 包含两个子句，每个子句有 $2$ 个文字，所以\n$L_{\\mathrm{POS}} = 2 + 2 = 4$。\n因此，所求的差值为\n$\\Delta = L_{\\mathrm{POS}} - L_{\\mathrm{SOP}} = 4 - 3 = 1$。\n\n无需四舍五入或单位，结果是一个单一的实数。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "两级逻辑最小化（如最小$SOP$形式）在理论上很简洁，但对于多输入函数，它可能导致巨大的扇入和严重的路径延迟，从而成为性能瓶颈。本练习  通过一个经典的奇偶校验函数的例子，鲜明地对比了两级逻辑实现和多级因子分解实现（$XOR$树）在延迟上的巨大差异。这个思想实验揭示了在高速电路设计中，为何必须超越两级逻辑的局限，通过多级网络结构来优化关键路径延迟。",
            "id": "4261369",
            "problem": "在电子设计自动化（EDA）的背景下，考虑在扇入约束下组合网络的延迟优化。假设门库由双输入$\\land$门、双输入$\\lor$门和$\\neg$门组成。假设采用一种技术无关延迟模型，其中每个门的延迟为1个归一化时间单位，导线延迟可忽略不计，关键路径延迟定义为从任何主输入到主输出的最长拓扑路径上的门延迟之和。进一步假设每个主输入的两种极性（即$x_i$和$\\neg x_i$）均可直接使用，无需额外延迟。\n\n定义布尔函数$P_{64}(x_1,\\dots,x_{64})$为64个输入的奇偶校验，即$P_{64}(x_1,\\dots,x_{64}) = x_1 \\oplus x_2 \\oplus \\cdots \\oplus x_{64}$，其中$\\oplus$表示异或。考虑以下两种满足最大扇入为2的$P_{64}$实现方式：\n\n1. 一个两级最小积之和覆盖：奇偶校验函数on-set中所有最小项的析取。在扇入约束下，每个包含64个文字的合取项通过一个由双输入$\\land$门构成的平衡二叉树实现，所有乘积项的析取通过一个由双输入$\\lor$门构成的平衡二叉树实现。\n\n2. 一个因子化的多级网络：一个由双输入$\\oplus$算子构成的平衡二叉树，将64个输入归约为1个输出。每个双输入异或门仅使用$\\land$、$\\lor$和$\\neg$门通过恒等式$x \\oplus y = (x \\lor y) \\land \\neg(x \\land y)$实现。\n\n仅使用给定的定义和延迟模型，推导实现（1）的精确关键路径延迟$D_{\\mathrm{SOP}}$和实现（2）的精确关键路径延迟$D_{\\mathrm{XOR}}$。然后计算延迟优势$\\Delta = D_{\\mathrm{SOP}} - D_{\\mathrm{XOR}}$。将最终答案表示为单个实数值，无需四舍五入。",
            "solution": "SOP实现的关键路径是穿过与平面（形成最小项）的最大延迟和穿过或平面（对所有最小项求和）的最大延迟之和。\n\n1.  **与平面延迟：** 每个最小项是64个文字的合取。要使用双输入$\\land$门的平衡二叉树实现一个64输入的与函数，树中的门级数决定了延迟。具有$N$个输入的平衡二叉树的深度为$\\lceil \\log_2(N) \\rceil$。\n    对于与平面，我们有$N = 64$个文字作为输入来形成每个最小项。\n    每个与门树的深度是$d_{\\land} = \\lceil \\log_2(64) \\rceil$。\n    因为$64 = 2^6$，所以我们有$d_{\\land} = \\log_2(2^6) = 6$。\n    穿过与平面的延迟是$d_{\\land} \\times 1 = 6$个时间单位。\n\n2.  **或平面延迟：** 函数$P_{64}$是64个变量的异或。这是一个奇校验函数。一个n变量奇偶校验函数（奇校验或偶校验）的on-set包含$2^{n-1}$个最小项。奇偶校验函数的主蕴含项就是最小项本身，因此最小SOP形式是on-set中所有最小项的析取。\n    对于$n=64$，最小项的数量$M$为$M = 2^{64-1} = 2^{63}$。这$M$个项必须使用一个双输入$\\lor$门的平衡二叉树来组合。该树的深度是：\n    $d_{\\lor} = \\lceil \\log_2(M) \\rceil = \\lceil \\log_2(2^{63}) \\rceil = 63$。\n    穿过或平面的延迟是$d_{\\lor} \\times 1 = 63$个时间单位。\n\n3.  **总SOP延迟：** 总关键路径延迟$D_{\\mathrm{SOP}}$是与平面延迟和或平面延迟之和。\n    $$D_{\\mathrm{SOP}} = d_{\\land} + d_{\\lor} = 6 + 63 = 69$$\n\n该实现使用一个基于双输入$\\oplus$模块的平衡二叉树的多级结构。\n\n1.  **异或模块延迟 ($d_{\\oplus}$):** 首先，我们必须计算单个双输入$\\oplus$模块的延迟，该模块实现为$x \\oplus y = (x \\lor y) \\land \\neg(x \\land y)$。输入$x$和$y$在时间$t=0$时可用。\n    - $x \\lor y$门的输出在$t=1$时可用。\n    - $x \\land y$门的输出在$t=1$时可用。\n    - $\\neg(x \\land y)$门的输出，它以$\\land$门的输出作为输入，在$t = 1 + 1 = 2$时可用。\n    - 最后的$\\land$门以$(x \\lor y)$（在$t=1$时可用）和$\\neg(x \\land y)$（在$t=2$时可用）作为输入。该门的输出在时间$\\max(1, 2) + 1 = 2 + 1 = 3$时稳定。\n    因此，一个双输入$\\oplus$模块的延迟是$d_{\\oplus} = 3$个时间单位。\n\n2.  **异或树延迟：** 整个函数$P_{64}$是通过这些$\\oplus$模块构成的平衡二叉树实现的。为了组合64个输入，该树的深度为：\n    $d_{\\text{tree}} = \\lceil \\log_2(64) \\rceil = 6$。\n    关键路径在每个级别上都穿过一个$\\oplus$模块。总延迟是树的深度与单个模块延迟的乘积。\n    $$D_{\\mathrm{XOR}} = d_{\\text{tree}} \\times d_{\\oplus} = 6 \\times 3 = 18$$\n\n延迟优势是两个计算出的延迟之差。\n$$\\Delta = D_{\\mathrm{SOP}} - D_{\\mathrm{XOR}} = 69 - 18 = 51$$\n延迟优势为$51$个归一化时间单位。",
            "answer": "$$\\boxed{51}$$"
        },
        {
            "introduction": "在对电路进行优化（例如，从两级逻辑重构为多级逻辑）后，我们必须确保其功能与原始设计完全等价。传统的仿真测试可能遗漏关键的角落情况，因此现代EDA流程严重依赖于形式化验证。本实践  将引导你构建一个“比较器”($miter$)电路，并结合布尔可满足性（$SAT$）求解器这一强大工具，来从数学上证明或反证两个电路设计的功能等价性。这是确保现代复杂芯片设计正确性的基石技术。",
            "id": "4261359",
            "problem": "给定一个组合逻辑块的两个门级描述版本。目标是构建一个 Miter 电路以检测行为差异，将 Miter 和两个版本编码为合取范式 (CNF)，调用布尔可满足性问题 (SAT) 求解器以找到一个反例输入赋值（如果存在），然后在该赋值下追踪两个版本之间相应的不同内部信号。\n\n此任务的基本依据必须从组合逻辑和电子设计自动化 (EDA) 中以下经过充分测试的事实和核心定义开始：\n- 一个组合电路是一个无环有向图，其节点代表逻辑门，其边代表信号连接；对于任何输入赋值，该电路都确定性地将主输入映射到输出。\n- 布尔可满足性问题 (SAT) 询问是否存在对布尔变量的赋值，使得给定的布尔公式为真。\n- Miter 是一种结构，给定两个关于相同输入向量的布尔函数，它输出其相应输出的异或的析取；当且仅当两个版本在所选输入上不同时，其值为真。\n- 任何布尔网络都可以通过使用辅助变量来表示门输出，从而转换为 CNF，这样既保留了网络语义，又能保证当且仅当网络约束被满足时，生成的 CNF 是可满足的。\n\n您的程序必须从这些基础出发，执行以下步骤：\n1. 将组合逻辑块的每个版本解释为一组门。每个门计算其扇入信号的布尔函数。两个版本共享输入，但在 SAT 编码中必须独立处理两个版本的内部信号和输出信号，以避免意外等同。\n2. 通过对两个版本的每一对相应输出进行异或操作，然后对这些异或结果进行析取，来构建一个 Miter 电路，从而获得一个表示不匹配的单一 Miter 输出。在 SAT 实例中强制此 Miter 输出为真，以搜索反例输入向量。\n3. 将两个版本的门级网络连同 Miter 结构一起转换为 CNF，为每个门输出和任何辅助 Miter 节点使用新的布尔变量，同时在两个版本之间共享主输入的相同变量。\n4. 调用 SAT 求解器，以产生一个满足赋值或报告不可满足性。如果可满足，则提取输入赋值，并在此赋值下仿真两个版本，以获得所有已定义的内部信号和输出的真值。报告在该赋值下两个版本产生不同值的信号标识符集合。\n\n程序必须是完全自包含的，必须在不使用任何外部工具的情况下构建 CNF 并求解 SAT，并且必须处理下面描述的所有测试用例。\n\n电路表示和测试套件：\n- 每个电路版本由以下内容描述：\n  - $n$ 个主输入，信号标识符为 $\\{1,2,\\dots,n\\}$。\n  - 一个门列表，每个门由一个目标信号标识符 $t$ 和一个门类型（来自 $\\{\\text{AND}, \\text{OR}, \\text{XOR}, \\text{NOT}\\}$）及其扇入信号标识符指定。该门列表是拓扑排序的，因此一个门的所有扇入要么是主输入，要么是更早出现的门的目标。\n  - 一个输出信号标识符列表。\n- 两个版本共享相同的主输入标识符集。内部和输出信号标识符在版本之间进行数值对齐以定义追踪的对应关系，但它们在 SAT 编码中是不同的变量，以防止语义混淆。\n- 角度单位不适用，也没有物理单位，因此不需要单位转换。\n\n您必须实现并评估以下测试套件。对于每个测试用例，构建 Miter，求解 SAT 实例，并追踪不同的内部信号。\n\n测试用例 $1$（相同版本，预期 Miter 不可满足）：\n- 输入：$n=3$，标识符为 $\\{1,2,3\\}$。\n- 版本 A 的门：\n  - $(t=4,\\ \\text{AND},\\ [1,2])$,\n  - $(t=5,\\ \\text{NOT},\\ [3])$,\n  - $(t=6,\\ \\text{OR},\\ [4,5])$.\n- 版本 A 的输出：$[6]$。\n- 版本 B 的门：\n  - $(t=4,\\ \\text{AND},\\ [1,2])$,\n  - $(t=5,\\ \\text{NOT},\\ [3])$,\n  - $(t=6,\\ \\text{OR},\\ [4,5])$.\n- 版本 B 的输出：$[6]$。\n\n测试用例 $2$（因门改变导致的单输出差异）：\n- 输入：$n=3$，标识符为 $\\{1,2,3\\}$。\n- 版本 A 的门：\n  - $(t=4,\\ \\text{AND},\\ [1,2])$,\n  - $(t=5,\\ \\text{OR},\\ [4,3])$.\n- 版本 A 的输出：$[5]$。\n- 版本 B 的门：\n  - $(t=4,\\ \\text{AND},\\ [1,2])$,\n  - $(t=5,\\ \\text{XOR},\\ [4,3])$.\n- 版本 B 的输出：$[5]$。\n\n测试用呈例 $3$（两个输出，其中一个因内部逻辑门改变而不同）：\n- 输入：$n=4$，标识符为 $\\{1,2,3,4\\}$。\n- 版本 A 的门：\n  - $(t=5,\\ \\text{XOR},\\ [1,2])$,\n  - $(t=6,\\ \\text{AND},\\ [3,4])$,\n  - $(t=7,\\ \\text{OR},\\ [5,6])$,\n  - $(t=8,\\ \\text{AND},\\ [5,6])$.\n- 版本 A 的输出：$[7,8]$。\n- 版本 B 的门：\n  - $(t=5,\\ \\text{XOR},\\ [1,2])$,\n  - $(t=6,\\ \\text{OR},\\ [3,4])$,\n  - $(t=7,\\ \\text{OR},\\ [5,6])$,\n  - $(t=8,\\ \\text{AND},\\ [5,6])$.\n- 版本 B 的输出：$[7,8]$。\n\n最终输出格式：\n- 对于每个测试用例，您的程序必须输出一个形式为 $[\\text{sat}, \\text{input\\_bits}, \\text{diff\\_signals}]$ 的结果，其中：\n  - $\\text{sat}$ 是一个布尔值，表示是否找到了反例（如果 Miter 可满足则为 true，否则为 false）。\n  - $\\text{input\\_bits}$ 是一个布尔值列表，表示按输入标识符 $\\{1,2,\\dots,n\\}$ 顺序排列的反例输入赋值；如果不可满足，则此列表必须为空。\n  - $\\text{diff\\_signals}$ 是一个整数列表，包含在该反例赋值下两个版本产生不同真值的信号标识符（包括内部和输出标识符）；如果不可满足，则此列表必须为空。\n- 您的程序应生成一行输出，其中包含所有测试用例的结果，形式为逗号分隔的列表并用方括号括起，例如：$[r_1,r_2,r_3]$，其中每个 $r_k$ 是上述的用例结果。输出不得包含任何其他文本。",
            "solution": "目标是为两个门级逻辑电路版本（指定为 A 和 B）执行组合等价性检查。这是电子设计自动化 (EDA) 中的一项基本任务，用于验证逻辑优化或修改没有改变电路的指定行为。所采用的方法将是构建一个 Miter 电路，将其转换为合取范式 (CNF) 表示，并应用布尔可满足性 (SAT) 求解器来寻找一个区分性输入向量（如果存在）。\n\n解决方案系统地通过以下阶段进行：\n\n**1. 变量映射和电路表示**\n我们必须首先将两个电路版本的信号标识符转换为一组适用于 SAT 求解器的唯一布尔变量。\n- 设主输入数量为 $n$。主输入信号的标识符为 $\\{1, 2, \\dots, n\\}$，由两个电路共享。我们将它们映射到一组 $n$ 个布尔变量 $\\{v_1, v_2, \\dots, v_n\\}$。\n- 对于版本 A 中标识符为 $k$ 的每个内部和输出信号，我们引入一个唯一的布尔变量 $v_{k,A}$。\n- 同样，对于版本 B 中标识符为 $k$ 的每个信号，我们引入一个变量 $v_{k,B}$。这一点至关重要：即使在两个版本中产生信号 $k$ 的子电路完全相同，它们对应的 SAT 变量也必须是不同的，以允许求解器检测潜在的行为差异。\n一个映射数据结构将维护一个信号（例如，（标识符，版本））与其在 SAT 问题中的整数变量索引之间的对应关系。\n\n**2. 合取范式 (CNF) 编码**\n整个系统，包括两个电路，都必须转换为单一的 CNF 布尔公式。CNF 公式是子句的合取（AND），其中每个子句是文字（一个变量或其否定）的析取（OR）。我们使用 Tseitin 变换，为每个门的输出引入辅助变量，以创建一组子句，这些子句当且仅当电路的逻辑得到遵守时才是可满足的。\n\n对于输出变量为 $o$、输入变量为 $i_1, i_2, \\dots, i_m$ 的门，关系 $o \\Leftrightarrow f(i_1, \\dots, i_m)$ 被转换为 CNF。\n- **NOT 门**：$o \\Leftrightarrow \\neg i_1$。这等价于 $(o \\lor i_1) \\land (\\neg o \\lor \\neg i_1)$。\n- **AND 门**：$o \\Leftrightarrow i_1 \\land i_2$。这转换为 $(\\neg o \\lor i_1) \\land (\\neg o \\lor i_2) \\land (o \\lor \\neg i_1 \\lor \\neg i_2)$。\n- **OR 门**：$o \\Leftrightarrow i_1 \\lor i_2$。这转换为 $(o \\lor \\neg i_1) \\land (o \\lor \\neg i_2) \\land (\\neg o \\lor i_1 \\lor i_2)$。\n- **XOR 门**：$o \\Leftrightarrow i_1 \\oplus i_2$。这转换为 $(\\neg o \\lor i_1 \\lor i_2) \\land (\\neg o \\lor \\neg i_1 \\lor \\neg i_2) \\land (o \\lor i_1 \\lor \\neg i_2) \\land (o \\lor \\neg i_1 \\lor i_2)$。\n\n这些变换应用于版本 A 和版本 B 中的每个门，使用各自映射的变量，生成一大组子句。\n\n**3. Miter 电路构建和编码**\n构建一个 Miter 电路来检测两个电路版本输出之间的任何差异。\n- 设版本 A 的主输出为 $\\{out_{1,A}, \\dots, out_{p,A}\\}$，版本 B 的主输出为 $\\{out_{1,B}, \\dots, out_{p,B}\\}$。\n- 对于每对相应的输出信号 $(out_{j,A}, out_{j,B})$，我们使用异或 (XOR) 操作计算它们的差异：$d_j \\Leftrightarrow out_{j,A} \\oplus out_{j,B}$。为每个这样的差异引入一个新的辅助变量 $d_j$。此 XOR 关系的 CNF 子句被添加到我们的公式中。\n- 最终的 Miter 输出 $M$ 是所有单个差异信号的析取（OR）：$M \\Leftrightarrow d_1 \\lor d_2 \\lor \\dots \\lor d_p$。此关系也转换为 CNF 子句。\n- 为了找到一个反例，我们必须找到一个使电路产生差异的输入赋值。这等同于找到一个使 Miter 输出 $M$ 为真的赋值。我们通过向 CNF 公式添加一个单位子句 $(M)$ 来强制执行这一点。该子句仅包含对应于 $M$ 变量的单个正文字。\n\n合并后的 CNF 公式现在包括两个版本中所有门的约束以及 Miter 逻辑。该公式是可满足的，当且仅当存在对主输入变量 $\\{v_1, \\dots, v_n\\}$ 的赋值，导致至少有一对相应输出具有不同的值。\n\n**4. 布尔可满足性 (SAT) 求解**\n生成的 CNF 公式使用 SAT 求解器进行求解。对于此问题，需要一个 Davis-Putnam-Logemann-Loveland (DPLL) 算法的自包含实现。DPLL 是一种基于回溯的搜索算法，它系统地探索变量赋值的空间。\n核心算法操作如下：\n1.  **简化**：根据当前赋值简化公式。\n2.  **单位传播**：如果任何子句已简化为单个未赋值的文字（“单位子句”），则该文字必须为真。相应的变量被赋值，并进一步简化公式。此过程重复进行，直到找不到更多的单位子句。如果简化导致空子句（所有文字都为假的子句），则表示冲突，算法必须回溯。\n3.  **决策**：如果公式尚未求解或证明为不可满足，则选择一个未赋值的变量并赋予其一个试验值（例如，真）。然后算法递归。\n4.  **回溯**：如果递归调用导致冲突（UNSAT），算法会回溯，撤销上一个试验赋值，并尝试相反的值。如果两个值都导致冲突，则公式在当前赋值级别上是不可满足的。\n\n如果算法找到一个满足所有子句的完整赋值，则原始公式是可满足的（SAT）。如果探索了所有搜索空间分支而没有找到解，则公式是不可满足的（UNSAT）。\n\n**5. 结果解释和信号追踪**\nSAT 求解器的结果决定了电路的等价性。\n- **UNSATISFIABLE (不可满足)**：没有任何赋值可以使 Miter 输出为真。这证明对于所有可能的输入，版本 A 和版本 B 的输出都是相同的。电路是等价的。该测试用例的结果将表明没有找到反例。\n- **SATISFIABLE (可满足)**：求解器返回一个满足赋值（一个“模型”）。该模型为所有变量（包括主输入）提供了真值。这个输入赋值是一个展示行为差异的反例。为了完成分析，我们必须追踪哪些信号不同。\n    - 从模型中提取主输入变量 $\\{v_1, \\dots, v_n\\}$ 的值。\n    - 然后我们使用这个特定的输入向量对版本 A 和版本 B 进行正向仿真。这涉及按拓扑顺序计算每个门输出的真值。\n    - 通过比较版本 A 与版本 B 中每个信号标识符 $k$ 的计算值，我们可以编制一个在反例条件下表现出不同逻辑值的所有信号（内部和输出）的列表。\n    - 该测试用例的最终结果将包括可满足性结果、反例输入向量以及不同信号标识符的集合。",
            "answer": "```\n[[False,[],[]],[True,[True,True,True],[5]],[True,[True,False,True,False],[6,8]]]\n```"
        }
    ]
}