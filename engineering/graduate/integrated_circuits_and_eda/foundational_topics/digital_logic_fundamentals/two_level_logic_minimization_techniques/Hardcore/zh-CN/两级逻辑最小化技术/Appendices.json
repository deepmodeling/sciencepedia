{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在通过Quine-McCluskey (QM) 算法进行严格的训练，这是为实现精确双层逻辑最小化而开发的首个算法方法。通过系统地生成素蕴涵项并解决覆盖问题，您将对支撑现代EDA综合工具的原理获得深刻的机械性理解。掌握这种列表法是理解逻辑优化中计算挑战与解决方案的关键。",
            "id": "4307032",
            "problem": "考虑一个包含5个二进制变量 $\\mathbf{x} = (A,B,C,D,E) \\in \\{0,1\\}^{5}$ 的布尔函数 $f$，其表示采用标准最小项索引排序 $i(A,B,C,D,E) = 16A + 8B + 4C + 2D + E$。其 on-set (使得 $f=1$ 的最小项索引集合) 为\n$$\\mathcal{M} = \\{3,7,11,15,19,20,21,22,23,27,28,29,30,31\\},$$\n且没有无关项 (无关项集为空)。在电子设计自动化 (EDA) 的两级逻辑最小化背景下，使用 Quine–McCluskey 列表法推导素蕴含项并执行精确覆盖。两级“积之和”实现的成本定义为总文字量，即在一个有效覆盖中，所有乘积项中互补或非互补变量出现的总数。\n\n从布尔代数的基础（最小项、蕴含项、素蕴含项和精确覆盖的集合论描述）出发，执行列表法机制以获得 $f$ 的最小成本覆盖，并计算 $f$ 的任何有效两级“积之和”实现的最小文字量 $L_{\\min}(f)$。\n\n将最终答案表示为单个实数值。无需四舍五入。",
            "solution": "该问题要求找到给定5变量布尔函数 $f(A,B,C,D,E)$ 的最小成本两级“积之和”(SOP) 实现及其对应的最小文字量 $L_{\\min}(f)$。解决方案通过系统地应用 Quine-McCluskey 算法来展开。\n\n### 步骤 1：生成素蕴含项\n\n首先，我们将 on-set $\\mathcal{M}$ 中的最小项以其5位二进制表示 $(A,B,C,D,E)$ 列出，并根据 '1' 的数量（汉明权重）进行分组。\n\n**初始最小项列表 (0-立方体)**\n-   **第2组** (权重 2):\n    -   $3$: $00011$\n    -   $20$: $10100$\n-   **第3组** (权重 3):\n    -   $7$: $00111$\n    -   $11$: $01011$\n    -   $19$: $10011$\n    -   $21$: $10101$\n    -   $22$: $10110$\n    -   $28$: $11100$\n-   **第4组** (权重 4):\n    -   $15$: $01111$\n    -   $23$: $10111$\n    -   $27$: $11011$\n    -   $29$: $11101$\n    -   $30$: $11110$\n-   **第5组** (权重 5):\n    -   $31$: $11111$\n\n**生成 1-立方体 (4-文字项)**\n我们将相邻组中仅相差一个比特的最小项对进行合并。不同的比特位用破折号 ($-$) 替代。\n-   **合并第2组和第3组：**\n    -   $m(3,7) \\implies 00-11$\n    -   $m(3,19) \\implies -0011$\n    -   $m(20,21) \\implies 1010-$\n    -   $m(20,22) \\implies 101-0$\n    -   $m(20,28) \\implies 1-100$\n-   **合并第3组和第4组：**\n    -   $m(7,15) \\implies 0-111$\n    -   $m(7,23) \\implies -0111$\n    -   $m(11,15) \\implies 01-11$\n    -   $m(11,27) \\implies -1011$\n    -   $m(19,23) \\implies 10-11$\n    -   $m(19,27) \\implies 1-011$\n    -   $m(21,23) \\implies 101-1$\n    -   $m(21,29) \\implies 1-101$\n    -   $m(22,23) \\implies 1011-$\n    -   $m(22,30) \\implies 1-110$\n    -   $m(28,29) \\implies 1110-$\n    -   $m(28,30) \\implies 111-0$\n-   **合并第4组和第5组：**\n    -   $m(15,31) \\implies -1111$\n    -   $m(23,31) \\implies 1-111$\n    -   $m(27,31) \\implies 11-11$\n    -   $m(29,31) \\implies 111-1$\n    -   $m(30,31) \\implies 1111-$\n\n初始表中的所有最小项都至少用于一次合并，因此没有最小项是素蕴含项。\n\n**生成 2-立方体 (3-文字项)**\n我们将破折号位置相同且仅相差一个其他比特的 1-立方体对进行合并。\n-   $m(3,7)$  $m(19,23) \\implies m(3,7,19,23) = -0-11$\n-   $m(3,19)$  $m(11,27) \\implies m(3,19,11,27) = --011$\n-   $m(20,21)$  $m(22,23) \\implies m(20,21,22,23) = 101--$\n-   $m(20,22)$  $m(28,30) \\implies m(20,22,28,30) = 1-1-0$\n-   $m(7,15)$  $m(23,31) \\implies m(7,15,23,31) = --111$\n-   $m(7,23)$  $m(15,31) \\implies m(7,23,15,31) = --111$ (重复)\n-   $m(11,15)$  $m(27,31) \\implies m(11,15,27,31) = -1-11$\n-   $m(21,23)$  $m(29,31) \\implies m(21,23,29,31) = 1-1-1$\n-   $m(21,29)$  $m(23,31) \\implies m(21,29,23,31) = 1-1-1$ (重复)\n-   $m(28,29)$  $m(30,31) \\implies m(28,29,30,31) = 111--$\n\n系统检查确认每个 1-立方体都用于形成一个 2-立方体。因此，不存在包含4个文字的素蕴含项。\n\n**生成 3-立方体 (2-文字项)**\n我们将破折号位置匹配的 2-立方体对进行合并。\n-   $m(3,7,19,23)=-0-11$  $m(11,15,27,31)=-1-11 \\implies m(3,7,11,15,19,23,27,31) = ---11$\n-   $m(3,19,11,27)=--011$  $m(7,15,23,31)=--111 \\implies m(3,7,11,15,19,23,27,31) = ---11$ (重复)\n-   $m(20,21,22,23)=101--$  $m(28,29,30,31)=111-- \\implies m(20,21,22,23,28,29,30,31) = 1-1--$\n-   $m(20,22,28,30)=1-1-0$  $m(21,23,29,31)=1-1-1 \\implies m(20,21,22,23,28,29,30,31) = 1-1--$ (重复)\n\n系统检查确认每个 2-立方体都用于形成一个 3-立方体。因此，不存在包含3个文字的素蕴含项。\n\n**素蕴含项最终列表**\n由于两个 3-立方体无法进一步合并，该过程终止。这些就是函数 $f$ 的素蕴含项 (PI)。\n-   $PI_1: 1-1-- \\implies AC$\n-   $PI_2: ---11 \\implies DE$\n\n所有素蕴含项的集合是 $\\{AC, DE\\}$。\n\n### 步骤 2：用于精确覆盖的素蕴含项表\n\n我们构建一个 PI 表来寻找最小覆盖。行是 PI，列是 on-set $\\mathcal{M}$ 中的最小项。'X' 标记表示一个 PI 覆盖了一个最小项。\n\n| 素蕴含项 | 成本 | 3 | 7 | 11 | 15 | 19 | 20 | 21 | 22 | 23 | 27 | 28 | 29 | 30 | 31 |\n|---------|:----:|:-:|:-:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n| $AC$    | 2    |   |   |    |    |    | X  | X  | X  | X  |    | X  | X  | X  | X  |\n| $DE$    | 2    | X | X | X  | X  | X  |    |    |    | X  | X  |    |    |    | X  |\n\n本质素蕴含项 (EPI) 是为一个或多个最小项提供唯一覆盖的 PI。我们通过查找只有一个 'X' 的列来识别 EPI。\n-   最小项 $3$ 仅由 $DE$ 覆盖。因此，$DE$ 是一个 EPI。\n-   最小项 $20$ 仅由 $AC$ 覆盖。因此，$AC$ 是一个 EPI。\n\n由于 $AC$ 和 $DE$ 都是本质的，它们必须包含在最小覆盖中。EPI 的集合是 $\\{AC, DE\\}$。我们来检查这个集合是否覆盖了整个 on-set $\\mathcal{M}$。\n\n-   $AC$ 覆盖的最小项：$\\{20,21,22,23,28,29,30,31\\}$\n-   $DE$ 覆盖的最小项：$\\{3,7,11,15,19,23,27,31\\}$\n\n这两个集合的并集是 $\\{3,7,11,15,19,20,21,22,23,27,28,29,30,31\\}$，这恰好是 on-set $\\mathcal{M}$。因此，EPI 集合构成了一个完整且最小的覆盖。\n\n### 步骤 3：最小成本计算\n\n唯一的最小 SOP 表达式是 $f(A,B,C,D,E) = AC + DE$。\n成本是总文字量：\n-   项 $AC$ 包含 $2$ 个文字。\n-   项 $DE$ 包含 $2$ 个文字。\n\n最小文字量是 $L_{\\min}(f) = 2 + 2 = 4$。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "现实世界的数字系统通常包含不可能出现的输入条件，或者其输出无关紧要。本练习  介绍了“无关项”的概念，并演示了如何有效地利用它们来进一步简化逻辑表达式。通过本次实践，您将学会如何在形成素蕴涵项时策略性地包含无关最小项，从而实现更具成本效益的双层逻辑实现。",
            "id": "4307033",
            "problem": "考虑为集成电路设计自动化（也称为电子设计自动化，EDA）中出现的一个不完全指定布尔函数 $F(a,b,c,d,e)$ 综合一个二阶积之和（SOP）表达式的任务。函数 $F$ 将 $\\{0,1\\}^5$ 映射到 $\\{0,1\\}$，并由其开集 $\\mathcal{O}$ 和无关项集 $\\mathcal{D}$ 指定，而关集 $\\mathcal{Z}$ 定义为 $\\mathcal{O} \\cup \\mathcal{D}$ 在 $\\{0,1\\}^5$ 中的补集。设最小项索引为 $m = 16a + 8b + 4c + 2d + e$，$a$ 为最高有效位。\n\n开集和无关项集由下式给出\n$$\n\\mathcal{O} = \\{6,7,14,16,18,20,22,30\\}, \\quad \\mathcal{D} = \\{15,17,19,21,23,31\\}.\n$$\n关集为 $\\mathcal{Z} = \\{0,1,\\dots,31\\} \\setminus (\\mathcal{O} \\cup \\mathcal{D})$。\n\n从布尔代数中蕴含项和质蕴含项的基本定义出发，并利用一个乘积项可以扩展以包含无关最小项而不违反其在 $\\mathcal{O}$ 和 $\\mathcal{Z}$ 上正确性的原理，推导出一个覆盖 $\\mathcal{O}$ 中所有最小项且不覆盖 $\\mathcal{Z}$ 中任何最小项的 $F$ 的最小成本二阶SOP表达式。使用以下成本度量：主要目标是最小化乘积项的数量；若数量相同，则最小化总文字数。\n\n最终的SOP表达式应使用 $+$ 表示逻辑或，并列表示逻辑与，并用上划线表示文字的逻辑非。最终答案必须是一个单一的封闭形式布尔表达式。",
            "solution": "该问题要求为一个5变量不完全指定布尔函数 $F(a,b,c,d,e)$ 推导一个最小成本的二阶积之和（SOP）表达式。该函数由其开集 $\\mathcal{O}$ 和无关项集 $\\mathcal{D}$ 定义。\n\n### 1. 理论框架\n\n如果对于任何使乘积项值为1的输入组合，函数 $F$ 的值也为1或是无关项，则该乘积项是函数 $F$ 的一个**蕴含项**。蕴含项不得覆盖关集 $\\mathcal{Z}$ 中的任何最小项。\n\n**质蕴含项 (PI)** 是一个不被任何其他具有更少文字的单一蕴含项所“包含”的蕴含项。最大化地利用无关项可以创建更大的蕴含项（即文字更少），这是找到最小SOP表达式的关键。\n\n**最小SOP表达式** 是一个质蕴含项之和，它覆盖了开集 $\\mathcal{O}$ 中的所有最小项，且不覆盖关集 $\\mathcal{Z}$ 中的任何最小项，同时满足给定的成本度量。\n\n**必需质蕴含项 (EPI)** 是一个覆盖了至少一个任何其他质蕴含项都未覆盖的开集最小项的质蕴含项。所有EPI都必须包含在任何最小SOP解中。\n\n### 2. 卡诺图表示\n\n为了系统地找到所有质蕴含项，我们使用一个5变量卡诺图（K-map）。它由两个 $4 \\times 4$ 的网格组成，一个用于 $a=0$（最小项 $0-15$），另一个用于 $a=1$（最小项 $16-31$）。行由 $bc$ 索引，列由 $de$ 按格雷码顺序（$00, 01, 11, 10$）索引。\n\n函数开集 $\\mathcal{O}$ 的最小项标记为‘1’，无关项集 $\\mathcal{D}$ 的最小项标记为‘X’。未指定的单元格属于关集 $\\mathcal{Z}$，并默认为‘0’。\n\n填充后的卡诺图如下：\n\n**$a=0$ 的卡诺图**\n$$\n\\begin{array}{c|c|c|c|c|}\n\\multicolumn{1}{c}{}  \\multicolumn{4}{c}{de} \\\\\n\\cline{2-5}\n\\textit{bc}   00  01  11  10 \\\\\n\\cline{2-5}\n00  m_0=0  m_1=0  m_3=0  m_2=0 \\\\\n\\cline{2-5}\n01  m_4=0  m_5=0  m_7=1  m_6=1 \\\\\n\\cline{2-5}\n11  m_{12}=0  m_{13}=0  m_{15}=\\text{X}  m_{14}=1 \\\\\n\\cline{2-5}\n10  m_8=0  m_9=0  m_{11}=0  m_{10}=0 \\\\\n\\cline{2-5}\n\\end{array}\n$$\n\n**$a=1$ 的卡诺图**\n$$\n\\begin{array}{c|c|c|c|c|}\n\\multicolumn{1}{c}{}  \\multicolumn{4}{c}{de} \\\\\n\\cline{2-5}\n\\textit{bc}  00  01  11  10 \\\\\n\\cline{2-5}\n00  m_{16}=1  m_{17}=\\text{X}  m_{19}=\\text{X}  m_{18}=1 \\\\\n\\cline{2-5}\n01  m_{20}=1  m_{21}=\\text{X}  m_{23}=\\text{X}  m_{22}=1 \\\\\n\\cline{2-5}\n11  m_{28}=0  m_{29}=0  m_{31}=\\text{X}  m_{30}=1 \\\\\n\\cline{2-5}\n10  m_{24}=0  m_{25}=0  m_{27}=0  m_{26}=0 \\\\\n\\cline{2-5}\n\\end{array}\n$$\n\n### 3. 质蕴含项的识别\n\n我们寻找由1和X组成的最大可能矩形组，其中组的大小是2的幂。\n\n-   **组 1**：在 $a=1$ 的图中可以看到一个包含8个最小项的块，覆盖了顶部的两行。这个组对应于最小项 $\\{16, 17, 18, 19, 20, 21, 22, 23\\}$。对于这个组，$a=1$ 且 $b=0$。变量 $c, d, e$ 在块内变化，因此被消去。得到的乘积项是 $a\\bar{b}$。这是一个质蕴含项，因为它无法进一步扩展成一个包含16个项的组（例如，去掉 $a$ 将包含最小项 $m_8=0$，去掉 $\\bar{b}$ 将包含最小项 $m_{28}=0$）。我们称之为 $P_1 = a\\bar{b}$。\n\n-   **组 2**：通过寻找跨越两个图的邻接关系，可以形成第二个包含8个项的组。当 $c=1$ 和 $d=1$ 时的单元格被1或X覆盖。\n    -   在 $a=0$ 的图上：$\\{m_6, m_7, m_{14}, m_{15}\\}$。\n    -   在 $a=1$ 的图上：$\\{m_{22}, m_{23}, m_{30}, m_{31}\\}$。\n    这8个最小项 $\\{6, 7, 14, 15, 22, 23, 30, 31\\}$ 形成一个有效的蕴含项。在这个组中，$c=1$ 且 $d=1$，而 $a, b, e$ 发生变化。得到的乘积项是 $cd$。这是一个质蕴含项，因为通过去掉 $c$ 或 $d$ 来扩展它将需要包含关集中的最小项（例如，去掉 $c$ 将包含 $m_4=0$，去掉 $d$ 将包含 $m_2=0$）。我们称之为 $P_2 = cd$。\n\n-   进一步搜索没有发现其他质蕴含项。任何由1和X组成的更小组都完全包含在 $P_1$ 或 $P_2$ 中。例如，组 $\\{6, 7, 14, 15\\}$ 得到 $\\bar{a}cd$，它被 $cd$ 所包含。\n\n$F$ 的所有质蕴含项集合为 $\\{a\\bar{b}, cd\\}$。\n\n### 4. 质蕴含项表和解的推导\n\n我们构建一个质蕴含项表来选择覆盖开集 $\\mathcal{O}=\\{6, 7, 14, 16, 18, 20, 22, 30\\}$ 所需的PI。\n\n| PI | $m_6$ | $m_7$ | $m_{14}$ | $m_{16}$ | $m_{18}$ | $m_{20}$ | $m_{22}$ | $m_{30}$ |\n|:---|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\n| $P_1=a\\bar{b}$ | | | | $\\mathbf{X}$ | $\\mathbf{X}$ | $\\mathbf{X}$ | $\\text{X}$ | |\n| $P_2=cd$ | $\\mathbf{X}$ | $\\mathbf{X}$ | $\\mathbf{X}$ | | | | $\\text{X}$ | $\\mathbf{X}$ |\n\n\n-   最小项 $m_{16}$ 仅由 $P_1$ 覆盖。因此，$P_1 = a\\bar{b}$ 是一个必需质蕴含项。这同样适用于 $m_{18}$ 和 $m_{20}$。\n-   最小项 $m_6$ 仅由 $P_2$ 覆盖。因此，$P_2 = cd$ 是一个必需质蕴含项。这同样适用于 $m_7$, $m_{14}$ 和 $m_{30}$。\n\n由于质蕴含项 $P_1$ 和 $P_2$ 都是必需的，它们都必须是任何最小解的一部分。我们来验证它们的和是否覆盖了整个开集：\n-   $P_1$ 覆盖开集最小项 $\\{16, 18, 20, 22\\}$。\n-   $P_2$ 覆盖开集最小项 $\\{6, 7, 14, 22, 30\\}$。\n-   这两个集合的并集是 $\\{6, 7, 14, 16, 18, 20, 22, 30\\}$，这正是开集 $\\mathcal{O}$。\n\n由于两个必需质蕴含项为开集提供了完全覆盖，因此最小SOP表达式是它们的和。\n\n### 5. 最终最小表达式\n\n最小SOP表达式为 $F(a,b,c,d,e) = a\\bar{b} + cd$。\n\n我们来检查成本：\n-   乘积项数量：$2$。这是可能的最小值，因为我们有两个EPI。\n-   总文字数：$2 (\\text{来自 } a\\bar{b}) + 2 (\\text{来自 } cd) = 4$。\n\n根据指定的成本度量，该解是唯一的且最小的。",
            "answer": "$$\\boxed{a\\bar{b} + cd}$$"
        },
        {
            "introduction": "与一次仅优化一个输出来说，通过同时考虑系统的多个输出可以获得显著的效率提升。本次实践  探讨了多输出最小化技术，该技术通过在多个函数间共享乘积项来降低总体实现成本。这一原则对于设计高效的可编程逻辑阵列 (PLA) 和其他结构化逻辑器件至关重要。",
            "id": "4307028",
            "problem": "考虑一个在电子设计自动化（EDA）背景下的、针对一组三个布尔输出函数的、风格类似于可编程逻辑阵列（PLA）的两级积之和（SOP）实现。输入变量为 $A$、$B$、$C$ 和 $D$，每个变量的取值范围为 $\\{0,1\\}$。最小项由 $i = 8A + 4B + 2C + D$ 索引，其中 $(A,B,C,D)$ 按从最高有效位到最低有效位的顺序排列。输出 $f_1$、$f_2$ 和 $f_3$ 由其 on-set（使函数值为 $1$ 的最小项索引集合）指定。任何输出都没有无关最小项。\n\n- $f_1$ on-set: $\\{10, 11, 14, 15\\}$。\n- $f_2$ on-set: $\\{10, 11, 12, 13, 14, 15\\}$。\n- $f_3$ on-set: $\\{9, 10, 11, 13, 14, 15\\}$。\n\n使用一个共享的乘积项库实现所有输出，其中每个乘积项是取自 $\\{A, B, C, D\\}$ 及其补的文字的合取，并且可以连接到一个或多个输出。设实现的成本为\n$$\nJ = J_{\\mathrm{AND}} + J_{\\mathrm{OR}},\n$$\n其中 $J_{\\mathrm{AND}}$ 是在共享库中实现的所有不同乘积项中文字出现的总数，$J_{\\mathrm{OR}}$ 是从乘积项到输出的总连接数（从一个乘积项到一个输出的每个连接对 $J_{\\mathrm{OR}}$ 的贡献为 $1$）。例如，乘积项 $A C$ 对 $J_{\\mathrm{AND}}$ 的贡献为 $2$，如果这个单独的乘积项供给两个输出，它对 $J_{\\mathrm{OR}}$ 的贡献为 $2$。\n\n使用两级逻辑最小化原理，并允许乘积项在输出之间共享，确定 $J$ 的最小可能值。将您的最终答案表示为一个精确整数，无需四舍五入，也无物理单位。",
            "solution": "为了找到最小成本的多输出实现，我们必须识别可用于单个函数和函数组合的质蕴含项（PI），然后选择一个成本最低的乘积项集合来覆盖所有必需的 on-set 最小项。\n\n### 1. 识别各函数及其乘积的质蕴含项\n\n我们使用卡诺图来识别每个函数以及它们两两乘积的质蕴含项。这些项构成了可以在输出间共享的候选乘积项库。\n\n-   **$f_1$ (On-set: {10, 11, 14, 15})**:\n    卡诺图显示一个由4个1组成的方块，对应于唯一的质蕴含项 $AC$。\n    因此，$f_1$ 的PI集合为 $\\{AC\\}$。\n-   **$f_2$ (On-set: {10, 11, 12, 13, 14, 15})**:\n    卡诺图显示两个质蕴含项：$AC$（覆盖{10, 11, 14, 15}）和 $AB$（覆盖{12, 13, 14, 15}）。\n    因此，$f_2$ 的PI集合为 $\\{AC, AB\\}$。\n-   **$f_3$ (On-set: {9, 10, 11, 13, 14, 15})**:\n    卡诺图显示两个质蕴含项：$AC$（覆盖{10, 11, 14, 15}）和 $AD$（覆盖{9, 11, 13, 15}）。\n    因此，$f_3$ 的PI集合为 $\\{AC, AD\\}$。\n\n通过检查这些函数的乘积（交集），我们可以识别出额外的共享项。然而，在本例中，单个函数的PI集合已经包含了所有潜在的共享项。因此，整个系统的候选乘积项库是 $\\{AC, AB, AD\\}$。\n\n### 2. 求解多输出覆盖问题\n\n我们现在需要从候选库 $\\{AC, AB, AD\\}$ 中选择一个子集，以最低的总成本 $J = J_{\\mathrm{AND}} + J_{\\mathrm{OR}}$ 覆盖所有三个函数的 on-set。\n\n首先，我们寻找每个函数的本质项：\n-   对于 $f_2$：最小项 $m_{12}$ 只能被 $AB$ 覆盖。因此，**$AB$ 是 $f_2$ 的本质项**。我们必须在库中实现 $AB$ 并将其连接到 $f_2$。\n-   对于 $f_3$：最小项 $m_9$ 只能被 $AD$ 覆盖。因此，**$AD$ 是 $f_3$ 的本质项**。我们必须在库中实现 $AD$ 并将其连接到 $f_3$。\n\n这些本质选择构成了我们解的一部分。\n-   **已选择的项**: $\\{AB, AD\\}$\n-   **已建立的连接**: $AB \\to f_2$, $AD \\to f_3$\n\n接下来，我们确定在做出这些本质选择后仍需覆盖的最小项：\n-   **$f_1$ 待覆盖**: $\\{10, 11, 14, 15\\}$\n-   **$f_2$ 待覆盖**: $AB$ 覆盖了 $\\{12, 13, 14, 15\\}$。剩下 $\\{10, 11\\}$ 需要覆盖。\n-   **$f_3$ 待覆盖**: $AD$ 覆盖了 $\\{9, 11, 13, 15\\}$。剩下 $\\{10, 14\\}$ 需要覆盖。\n\n现在，我们需要以最低成本覆盖所有这些剩余的最小项。所有剩余项 $\\{10, 11, 14\\}$ 都被质蕴含项 $AC$ 覆盖。这是一个高效的选择，因为它是一个可以在所有三个函数之间共享的单一项。\n\n-   **添加新项**: 将 $AC$ 添加到我们的库中。\n-   **添加新连接**:\n    -   $AC \\to f_1$ (覆盖 $\\{10, 11, 14, 15\\}$)\n    -   $AC \\to f_2$ (覆盖 $\\{10, 11\\}$)\n    -   $AC \\to f_3$ (覆盖 $\\{10, 14\\}$)\n\n### 3. 计算最小成本\n\n最终的实现方案如下：\n-   **共享乘积项库**: $\\{AC, AB, AD\\}$\n-   **输出函数**:\n    -   $f_1 = AC$\n    -   $f_2 = AB + AC$\n    -   $f_3 = AD + AC$\n\n我们根据成本函数 $J = J_{\\mathrm{AND}} + J_{\\mathrm{OR}}$ 计算总成本：\n-   **$J_{\\mathrm{AND}}$ (文字成本)**:\n    -   $AC$: 2个文字\n    -   $AB$: 2个文字\n    -   $AD$: 2个文字\n    -   $J_{\\mathrm{AND}} = 2 + 2 + 2 = 6$\n-   **$J_{\\mathrm{OR}}$ (连接成本)**:\n    -   $f_1$ 使用1个项 ($AC$) $\\implies$ 1个连接\n    -   $f_2$ 使用2个项 ($AB, AC$) $\\implies$ 2个连接\n    -   $f_3$ 使用2个项 ($AD, AC$) $\\implies$ 2个连接\n    -   $J_{\\mathrm{OR}} = 1 + 2 + 2 = 5$\n\n总成本 $J = J_{\\mathrm{AND}} + J_{\\mathrm{OR}} = 6 + 5 = 11$。\n由于该解是通过优先选择本质项并为剩余部分找到最有效的共享覆盖来构建的，因此这是最小可能成本。",
            "answer": "$$\n\\boxed{11}\n$$"
        }
    ]
}