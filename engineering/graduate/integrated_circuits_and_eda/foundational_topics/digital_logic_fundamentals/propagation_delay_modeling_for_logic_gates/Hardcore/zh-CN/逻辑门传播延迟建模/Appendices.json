{
    "hands_on_practices": [
        {
            "introduction": "本练习将带您从第一性原理出发，推导逻辑门的关键性能指标——逻辑努力（Logical Effort）。通过运用晶体管的简化RC模型，您将亲手计算标准NAND和NOR门的逻辑努力值，并将其与基准反相器进行归一化比较。这项实践旨在揭示栅极拓扑结构如何从根本上决定其延迟特性和驱动能力，为您后续进行路径延迟优化打下坚实的理论基础。",
            "id": "4291543",
            "problem": "考虑一个用于电子设计自动化 (EDA) 时序优化的互补金属氧化物半导体 (CMOS) 逻辑库。假设采用电阻-电容 (RC) 延迟模型，其中传播延迟与有效导通电阻和电容负载的乘积成正比。使用金属氧化物半导体场效应晶体管 (MOSFET) 导电的第一性原理，对最小长度晶体管的导通电阻随器件宽度的缩放进行如下建模：一个 $n$ 沟道器件的导通电阻按 $r_{n}/W$ 缩放，一个 $p$ 沟道器件的导通电阻按 $r_{p}/W$ 缩放，其中 $r_{n}$ 和 $r_{p}$ 是单位宽度的导通电阻，$W$ 是器件宽度。设 $n$ 沟道和 $p$ 沟道晶体管的单位宽度栅极电容均为 $c_{g}$。\n\n在 RC 模型下，通过均衡其下拉和上拉有效导通电阻来定义参考反相器的尺寸。设 $n$ 沟道反相器的宽度为 $W_{n,\\text{inv}}=1$，并根据等电阻条件定义 $p$ 沟道宽度 $W_{p,\\text{inv}}$。引入比率 $\\rho = r_{p}/r_{n}$，并用 $\\rho$ 表示 $W_{p,\\text{inv}}$。以此为参考，考虑一个 $k$ 输入与非门和一个 $k$ 输入或非门，它们的尺寸均被设计为使其最坏情况下的下拉和上拉有效导通电阻与参考反相器相匹配。假设串联堆叠的电阻相加，并联支路不改变导电路径的电阻，并假设每个输入在其各自的网络中精确控制一个 $n$ 沟道和一个 $p$ 沟道器件。\n\n使用逻辑努力的正式定义，将给定门输入的有效逻辑努力 $g$ 定义为该输入的输入电容与参考反相器的输入电容之比，其约束条件是该门和反相器在相应转换中提供相同的输出驱动能力（即具有匹配的最坏情况有效导通电阻）。推导 $k$ 输入与非门和 $k$ 输入或非门的有效逻辑努力的闭式解析表达式，仅用 $k$ 和 $\\rho$ 表示。\n\n将最终答案表示为两个无量纲的解析表达式。无需进行数值计算或四舍五入。",
            "solution": "在进行求解之前，首先对问题陈述的有效性进行正式评估。\n\n### 步骤 1：提取已知条件\n- **模型**：电阻-电容 (RC) 延迟模型。\n- **延迟缩放**：与有效导通电阻和电容负载的乘积成正比。\n- **导通电阻缩放**：\n  - $n$ 沟道 MOSFET：$r_{n}/W$。\n  - $p$ 沟道 MOSFET：$r_{p}/W$。\n- **常量和变量**：\n  - $r_{n}$：$n$ 沟道器件的单位宽度导通电阻。\n  - $r_{p}$：$p$ 沟道器件的单位宽度导通电阻。\n  - $c_{g}$：$n$ 沟道和 $p$ 沟道晶体管的单位宽度栅极电容。\n  - $W$：器件宽度。\n  - $k$：与非门和或非门的输入数量。\n  - $\\rho = r_{p}/r_{n}$。\n- **参考反相器尺寸设计**：\n  - 均衡下拉和上拉有效导通电阻。\n  - $n$ 沟道宽度，$W_{n,\\text{inv}} = 1$。\n  - $p$ 沟道宽度，$W_{p,\\text{inv}}$，待确定。\n- **与非门/或非门尺寸设计**：\n  - 一个 $k$ 输入与非门和一个 $k$ 输入或非门的尺寸被设计为使其最坏情况下的下拉和上拉有效导通电阻与参考反相器相匹配。\n- **简化假设**：\n  - 串联堆叠电阻相加。\n  - 并联支路不改变导电路径的电阻（解释为最坏情况下的电阻是单个支路的电阻）。\n  - 每个输入精确控制一个 $n$ 沟道和一个 $p$ 沟道器件。\n- **逻辑努力 ($g$) 的定义：**\n  - $g = \\frac{\\text{门输入的输入电容}}{\\text{参考反相器的输入电容}}$。\n  - 该比率是在门和反相器提供相同输出驱动能力（匹配的最坏情况有效导通电阻）的条件下计算的。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题很好地立足于数字集成电路设计的原理，特别是使用一阶 RC 延迟模型和逻辑努力的概念，这些是 EDA 中进行时序分析和优化的标准范式。电阻和电容的模型（$R \\propto 1/W$, $C \\propto W$）是标准的简化方法。\n- **适定性**：该问题是适定的。它提供了所有必要的定义、约束（匹配的电阻）和明确的目标（推导逻辑努力 $g$ 的表达式）。信息是自洽的，足以推导出唯一的解析解。\n- **客观性**：问题以精确、客观、技术性的语言陈述，没有任何模糊或主观的论断。\n\n### 步骤 3：结论与行动\n问题是 **有效的**。它代表了 VLSI 设计领域中一个标准的、尽管是简化的学术问题。其假设陈述清晰，并与一阶分析一致。求解过程开始。\n\n### 求解推导\n\n推导过程分为四个部分：1. 表征参考反相器。2. 分析 $k$ 输入与非门。3. 分析 $k$ 输入或非门。4. 计算逻辑努力。\n\n**1. 参考反相器表征**\n\n参考反相器的尺寸被设计为具有相等的上拉和下拉电阻。\n下拉电阻 $R_{\\text{pd,inv}}$ 由单个宽度为 $W_{n,\\text{inv}}$ 的 $n$ 沟道晶体管提供。\n$$R_{\\text{pd,inv}} = \\frac{r_n}{W_{n,\\text{inv}}}$$\n给定 $W_{n,\\text{inv}} = 1$，下拉电阻为：\n$$R_{\\text{pd,inv}} = \\frac{r_n}{1} = r_n$$\n上拉电阻 $R_{\\text{pu,inv}}$ 由单个宽度为 $W_{p,\\text{inv}}$ 的 $p$ 沟道晶体管提供。\n$$R_{\\text{pu,inv}} = \\frac{r_p}{W_{p,\\text{inv}}}$$\n尺寸设计条件是 $R_{\\text{pu,inv}} = R_{\\text{pd,inv}}$。\n$$\\frac{r_p}{W_{p,\\text{inv}}} = r_n$$\n求解 $p$ 沟道宽度 $W_{p,\\text{inv}}$：\n$$W_{p,\\text{inv}} = \\frac{r_p}{r_n}$$\n使用给定的定义 $\\rho = r_p/r_n$，我们得到：\n$$W_{p,\\text{inv}} = \\rho$$\n参考反相器的匹配驱动强度，或有效导通电阻，为 $R_{\\text{inv}} = r_n$。\n\n参考反相器的输入电容 $C_{\\text{in,inv}}$ 是其两个晶体管的栅极电容之和。一个晶体管的栅极电容是 $c_g W$。\n$$C_{\\text{in,inv}} = c_g W_{n,\\text{inv}} + c_g W_{p,\\text{inv}} = c_g(W_{n,\\text{inv}} + W_{p,\\text{inv}})$$\n代入宽度值：\n$$C_{\\text{in,inv}} = c_g(1 + \\rho)$$\n\n**2. $k$ 输入与非门分析**\n\n一个 $k$ 输入与非门由下拉网络 (PDN) 中的 $k$ 个串联 $n$ 沟道晶体管和上拉网络 (PUN) 中的 $k$ 个并联 $p$ 沟道晶体管组成。设每个晶体管的宽度分别为 $W_{n,\\text{nand}}$ 和 $W_{p,\\text{nand}}$。\n\n最坏情况下的下拉电阻发生在所有 $k$ 个串联 $n$ 沟道晶体管都导通时。总电阻是各个电阻之和。\n$$R_{\\text{pd,nand}} = \\sum_{i=1}^{k} \\frac{r_n}{W_{n,\\text{nand}}} = k \\frac{r_n}{W_{n,\\text{nand}}}$$\n为匹配反相器的驱动强度，我们设定 $R_{\\text{pd,nand}} = R_{\\text{inv}} = r_n$。\n$$k \\frac{r_n}{W_{n,\\text{nand}}} = r_n \\implies W_{n,\\text{nand}} = k$$\n\n最坏情况下的上拉电阻发生在 $k$ 个并联 $p$ 沟道晶体管中只有一个导通时。\n$$R_{\\text{pu,nand}} = \\frac{r_p}{W_{p,\\text{nand}}}$$\n为匹配反相器的驱动强度，我们设定 $R_{\\text{pu,nand}} = R_{\\text{inv}} = r_n$。\n$$\\frac{r_p}{W_{p,\\text{nand}}} = r_n \\implies W_{p,\\text{nand}} = \\frac{r_p}{r_n} = \\rho$$\n\n与非门单个输入的输入电容 $C_{\\text{in,nand}}$ 连接到一个 $n$ 沟道和一个 $p$ 沟道晶体管。\n$$C_{\\text{in,nand}} = c_g W_{n,\\text{nand}} + c_g W_{p,\\text{nand}} = c_g(k + \\rho)$$\n\n与非门的逻辑努力 $g_{\\text{nand}}$ 是其输入电容与参考反相器输入电容之比。\n$$g_{\\text{nand}} = \\frac{C_{\\text{in,nand}}}{C_{\\text{in,inv}}} = \\frac{c_g(k + \\rho)}{c_g(1 + \\rho)} = \\frac{k + \\rho}{1 + \\rho}$$\n\n**3. $k$ 输入或非门分析**\n\n一个 $k$ 输入或非门由下拉网络 (PDN) 中的 $k$ 个并联 $n$ 沟道晶体管和上拉网络 (PUN) 中的 $k$ 个串联 $p$ 沟道晶体管组成。设宽度分别为 $W_{n,\\text{nor}}$ 和 $W_{p,\\text{nor}}$。\n\n最坏情况下的下拉电阻发生在 $k$ 个并联 $n$ 沟道晶体管中只有一个导通时。\n$$R_{\\text{pd,nor}} = \\frac{r_n}{W_{n,\\text{nor}}}$$\n为匹配反相器的驱动强度，我们设定 $R_{\\text{pd,nor}} = R_{\\text{inv}} = r_n$。\n$$\\frac{r_n}{W_{n,\\text{nor}}} = r_n \\implies W_{n,\\text{nor}} = 1$$\n\n最坏情况下的上拉电阻发生在所有 $k$ 个串联 $p$ 沟道晶体管都导通时。总电阻是各个电阻之和。\n$$R_{\\text{pu,nor}} = \\sum_{i=1}^{k} \\frac{r_p}{W_{p,\\text{nor}}} = k \\frac{r_p}{W_{p,\\text{nor}}}$$\n为匹配反相器的驱动强度，我们设定 $R_{\\text{pu,nor}} = R_{\\text{inv}} = r_n$。\n$$k \\frac{r_p}{W_{p,\\text{nor}}} = r_n \\implies W_{p,\\text{nor}} = k \\frac{r_p}{r_n} = k\\rho$$\n\n或非门单个输入的输入电容 $C_{\\text{in,nor}}$ 连接到一个 $n$ 沟道和一个 $p$ 沟道晶体管。\n$$C_{\\text{in,nor}} = c_g W_{n,\\text{nor}} + c_g W_{p,\\text{nor}} = c_g(1 + k\\rho)$$\n\n或非门的逻辑努力 $g_{\\text{nor}}$ 是其输入电容与参考反相器输入电容之比。\n$$g_{\\text{nor}} = \\frac{C_{\\text{in,nor}}}{C_{\\text{in,inv}}} = \\frac{c_g(1 + k\\rho)}{c_g(1 + \\rho)} = \\frac{1 + k\\rho}{1 + \\rho}$$\n\n因此，建立了 $k$ 输入与非门和或非门的逻辑努力关于 $k$ 和 $\\rho$ 的最终表达式。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{k+\\rho}{1+\\rho} & \\frac{1+k\\rho}{1+\\rho}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在掌握了基本的RC模型后，我们进阶到工业界广泛应用的先进延迟建模技术。本练习要求您对比两种主流的宏模型：非线性延迟模型（NLDM）和复合电流源模型（CCS）。您将通过为一个给定的下拉网络构建等效电流源，并利用电荷守恒定律积分计算输出延迟，然后将其与基于NLDM的电阻模型预测值进行比较，从而深入理解不同抽象层次模型间的差异与精度权衡。",
            "id": "4291614",
            "problem": "一个互补金属氧化物半导体逆变器在特定的输入转换和负载条件下，对其输出下降延迟进行了表征。考虑了两种工业标准的宏模型方法：非线性延迟模型 (NLDM) 和复合电流源 (CCS)。NLDM（非线性延迟模型）将驱动器抽象为一个压控电阻，而 CCS（复合电流源）则将驱动器抽象为一个电压相关电流源。你需要为下拉网络构建一个具有物理意义的等效电流源，并计算在给定容性负载下输出下降到中间电平的延迟，然后与在参考负载下校准的 NLDM 风格电阻抽象模型所预测的延迟进行比较。\n\n假设以下表征上下文和数据对于给定的逆变器和输入转换是有效且自洽的：\n- 电源电压为 $V_{\\mathrm{DD}} = 1.0 \\,\\mathrm{V}$。\n- 输出负载是一个集总电容 $C_{L} = 20 \\,\\mathrm{fF}$。\n- 此处的输出下降延迟定义为 $V_{\\mathrm{out}}$ 仅因与输出相关的放电动态过程而从 $V_{\\mathrm{DD}}$ 转换到 $0.5\\,V_{\\mathrm{DD}}$ 所需的时间；通过下面使用的抽象模型的构建，与输入相关的固有延迟贡献被排除在外。\n- NLDM 校准点：对于参考容性负载 $C_{\\mathrm{ref}} = 10 \\,\\mathrm{fF}$，在相同的输入转换下，测得的与输出相关的下降延迟为 $t_{\\mathrm{ref}} = 4.0 \\,\\mathrm{ps}$。在用于预测 $V_{\\mathrm{out}}$ 衰减时，将 NLDM 驱动器视为在此范围内与负载无关的单一有效电阻。\n- 相同输入转换下的 CCS 下拉电流源构建：传递到负载的等效下拉电流被建模为瞬时输出电压 $V_{\\mathrm{out}}(t)$ 的一个物理上合理的函数，由下式给出\n$$\nI_{\\mathrm{CCS}}(V_{\\mathrm{out}}) = \n\\begin{cases}\nI_{0}, & 0.7 \\leq V_{\\mathrm{out}} \\leq 1.0, \\\\\nI_{0}\\,\\dfrac{V_{\\mathrm{out}}}{0.7}, & 0 \\leq V_{\\mathrm{out}} < 0.7,\n\\end{cases}\n$$\n其中 $I_{0} = 1.5 \\,\\mathrm{mA}$。这种构建方式编码了在大漏源电压下的高电场饱和行为，以及随着 $V_{\\mathrm{out}}$ 接近地电位向准线性区的过渡。\n\n仅从电荷守恒和电路定律出发，计算：\n1. 对于给定的 $C_{L}$，NLDM 预测的到 $0.5\\,V_{\\mathrm{DD}}$ 的输出下降延迟。\n2. 对于给定的 $C_{L}$，使用提供的 $I_{\\mathrm{CCS}}(V_{\\mathrm{out}})$，CCS 预测的到 $0.5\\,V_{\\mathrm{DD}}$ 的输出下降延迟。\n\n将两个延迟都以皮秒为单位表示，并将你的答案四舍五入到四位有效数字。最终答案中只提供最终数值，不含中间步骤或单位。",
            "solution": "该问题是有效的，因为它科学上基于标准的集成电路延迟建模技术（NLDM 和 CCS），问题适定，具有充分且一致的数据，并且表述客观。\n\n根据要求，解答分为两部分。\n\n第 1 部分：NLDM 预测的输出下降延迟\n\n非线性延迟模型（NLDM）将逆变器的下拉网络近似为单一的有效电阻 $R_{\\mathrm{eff}}$。在输出下降转换期间，电路被建模为电容器 $C_{L}$ 通过该电阻 $R_{\\mathrm{eff}}$ 向地放电。电容器上的初始电压为 $V_{\\mathrm{out}}(0) = V_{\\mathrm{DD}}$。\n\n输出节点电压 $V_{\\mathrm{out}}(t)$ 遵循 RC 电路放电方程：\n$$\nV_{\\mathrm{out}}(t) = V_{\\mathrm{DD}} \\exp\\left(-\\frac{t}{R_{\\mathrm{eff}} C_{L}}\\right)\n$$\n输出下降延迟 $t_{\\mathrm{NLDM}}$ 定义为 $V_{\\mathrm{out}}(t)$ 达到 $0.5 V_{\\mathrm{DD}}$ 的时间。我们设定 $V_{\\mathrm{out}}(t_{\\mathrm{NLDM}}) = 0.5 V_{\\mathrm{DD}}$：\n$$\n0.5 V_{\\mathrm{DD}} = V_{\\mathrm{DD}} \\exp\\left(-\\frac{t_{\\mathrm{NLDM}}}{R_{\\mathrm{eff}} C_{L}}\\right)\n$$\n$$\n0.5 = \\exp\\left(-\\frac{t_{\\mathrm{NLDM}}}{R_{\\mathrm{eff}} C_{L}}\\right)\n$$\n对两边取自然对数：\n$$\n\\ln(0.5) = -\\frac{t_{\\mathrm{NLDM}}}{R_{\\mathrm{eff}} C_{L}}\n$$\n使用性质 $\\ln(0.5) = -\\ln(2)$，我们求解 $t_{\\mathrm{NLDM}}$：\n$$\nt_{\\mathrm{NLDM}} = R_{\\mathrm{eff}} C_{L} \\ln(2)\n$$\n该方程表明，在 NLDM 模型中，延迟与负载电容 $C_{L}$ 成正比。题目说明 $R_{\\mathrm{eff}}$ 与负载无关。我们可以使用提供的校准点（对于 $C_{\\mathrm{ref}} = 10 \\,\\mathrm{fF}$ 时 $t_{\\mathrm{ref}} = 4.0 \\,\\mathrm{ps}$）来计算目标负载 $C_{L} = 20 \\,\\mathrm{fF}$ 的延迟。\n\n关系是线性的：\n$$\n\\frac{t_{\\mathrm{NLDM}}}{C_{L}} = \\frac{t_{\\mathrm{ref}}}{C_{\\mathrm{ref}}} = R_{\\mathrm{eff}}\\ln(2)\n$$\n因此，我们可以通过缩放参考延迟来计算 $t_{\\mathrm{NLDM}}$：\n$$\nt_{\\mathrm{NLDM}} = t_{\\mathrm{ref}} \\frac{C_{L}}{C_{\\mathrm{ref}}}\n$$\n代入给定值：\n$$\nt_{\\mathrm{NLDM}} = (4.0 \\,\\mathrm{ps}) \\frac{20 \\,\\mathrm{fF}}{10 \\,\\mathrm{fF}} = 4.0 \\times 2 \\,\\mathrm{ps} = 8.0 \\,\\mathrm{ps}\n$$\n四舍五入到四位有效数字，NLDM 预测的延迟为 $8.000 \\,\\mathrm{ps}$。\n\n第 2 部分：CCS 预测的输出下降延迟\n\n复合电流源（CCS）模型将下拉网络近似为一个电压相关的电流源 $I_{\\mathrm{CCS}}(V_{\\mathrm{out}})$。来自该源的电流对负载电容 $C_{L}$ 放电。其控制微分方程源于电容的定义 $I = C \\frac{dV}{dt}$。从节点流出的放电电流为 $I_{\\mathrm{CCS}}$，因此：\n$$\nI_{\\mathrm{CCS}}(V_{\\mathrm{out}}) = -C_{L} \\frac{dV_{\\mathrm{out}}}{dt}\n$$\n为了求出下降延迟 $t_{\\mathrm{CCS}}$，我们分离变量并进行积分。该延迟是 $V_{\\mathrm{out}}$ 从 $V_{\\mathrm{DD}} = 1.0 \\,\\mathrm{V}$ 下降到 $0.5 V_{\\mathrm{DD}} = 0.5 \\,\\mathrm{V}$ 所需的时间。\n$$\ndt = -C_{L} \\frac{dV_{\\mathrm{out}}}{I_{\\mathrm{CCS}}(V_{\\mathrm{out}})}\n$$\n从 $t=0$ 积分到 $t=t_{\\mathrm{CCS}}$：\n$$\nt_{\\mathrm{CCS}} = \\int_{0}^{t_{\\mathrm{CCS}}} dt = \\int_{V_{\\mathrm{DD}}}^{0.5V_{\\mathrm{DD}}} -C_{L} \\frac{dV_{\\mathrm{out}}}{I_{\\mathrm{CCS}}(V_{\\mathrm{out}})} = C_{L} \\int_{0.5V_{\\mathrm{DD}}}^{V_{\\mathrm{DD}}} \\frac{dV_{\\mathrm{out}}}{I_{\\mathrm{CCS}}(V_{\\mathrm{out}})}\n$$\n提供的电流模型是 $V_{\\mathrm{out}}$（单位为伏特）的分段函数：\n$$\nI_{\\mathrm{CCS}}(V_{\\mathrm{out}}) = \n\\begin{cases}\nI_{0}, & 0.7 \\leq V_{\\mathrm{out}} \\leq 1.0, \\\\\nI_{0}\\,\\dfrac{V_{\\mathrm{out}}}{0.7}, & 0 \\leq V_{\\mathrm{out}} < 0.7,\n\\end{cases}\n$$\n我们的积分范围是从 $0.5 \\,\\mathrm{V}$ 到 $1.0 \\,\\mathrm{V}$。函数定义在 $V_{\\mathrm{out}} = 0.7 \\,\\mathrm{V}$ 处发生变化，因此我们必须在该点分割积分：\n$$\nt_{\\mathrm{CCS}} = C_{L} \\left[ \\int_{0.5}^{0.7} \\frac{dV_{\\mathrm{out}}}{I_{\\mathrm{CCS}}(V_{\\mathrm{out}})} + \\int_{0.7}^{1.0} \\frac{dV_{\\mathrm{out}}}{I_{\\mathrm{CCS}}(V_{\\mathrm{out}})} \\right]\n$$\n现在，我们将 $I_{\\mathrm{CCS}}(V_{\\mathrm{out}})$ 在每个区间对应的表达式代入：\n$$\nt_{\\mathrm{CCS}} = C_{L} \\left[ \\int_{0.5}^{0.7} \\frac{dV_{\\mathrm{out}}}{I_{0}\\,\\frac{V_{\\mathrm{out}}}{0.7}} + \\int_{0.7}^{1.0} \\frac{dV_{\\mathrm{out}}}{I_{0}} \\right]\n$$\n提出常数 $1/I_{0}$：\n$$\nt_{\\mathrm{CCS}} = \\frac{C_{L}}{I_{0}} \\left[ \\int_{0.5}^{0.7} \\frac{0.7}{V_{\\mathrm{out}}} dV_{\\mathrm{out}} + \\int_{0.7}^{1.0} 1 \\, dV_{\\mathrm{out}} \\right]\n$$\n计算积分：\n$$\n\\int_{0.5}^{0.7} \\frac{0.7}{V_{\\mathrm{out}}} dV_{\\mathrm{out}} = 0.7 \\left[\\ln|V_{\\mathrm{out}}|\\right]_{0.5}^{0.7} = 0.7 (\\ln(0.7) - \\ln(0.5)) = 0.7 \\ln\\left(\\frac{0.7}{0.5}\\right) = 0.7 \\ln(1.4)\n$$\n$$\n\\int_{0.7}^{1.0} 1 \\, dV_{\\mathrm{out}} = \\left[V_{\\mathrm{out}}\\right]_{0.7}^{1.0} = 1.0 - 0.7 = 0.3\n$$\n将这些结果代回 $t_{\\mathrm{CCS}}$ 的表达式中：\n$$\nt_{\\mathrm{CCS}} = \\frac{C_{L}}{I_{0}} \\left[ 0.7 \\ln(1.4) + 0.3 \\right]\n$$\n现在我们代入数值：$C_{L} = 20 \\,\\mathrm{fF} = 20 \\times 10^{-15} \\,\\mathrm{F}$ 和 $I_{0} = 1.5 \\,\\mathrm{mA} = 1.5 \\times 10^{-3} \\,\\mathrm{A}$。\n$$\n\\frac{C_{L}}{I_{0}} = \\frac{20 \\times 10^{-15} \\,\\mathrm{F}}{1.5 \\times 10^{-3} \\,\\mathrm{A}} = \\frac{40}{3} \\times 10^{-12} \\,\\mathrm{s} = \\frac{40}{3} \\,\\mathrm{ps}\n$$\n$$\nt_{\\mathrm{CCS}} = \\frac{40}{3} \\left[ 0.7 \\ln(1.4) + 0.3 \\right] \\,\\mathrm{ps}\n$$\n使用 $\\ln(1.4) \\approx 0.3364722$：\n$$\nt_{\\mathrm{CCS}} \\approx \\frac{40}{3} \\left[ 0.7 \\times 0.3364722 + 0.3 \\right] \\,\\mathrm{ps}\n$$\n$$\nt_{\\mathrm{CCS}} \\approx \\frac{40}{3} \\left[ 0.23553054 + 0.3 \\right] \\,\\mathrm{ps}\n$$\n$$\nt_{\\mathrm{CCS}} \\approx \\frac{40}{3} \\left[ 0.53553054 \\right] \\,\\mathrm{ps}\n$$\n$$\nt_{\\mathrm{CCS}} \\approx 7.1404072 \\,\\mathrm{ps}\n$$\n四舍五入到四位有效数字，CCS 预测的延迟为 $7.140 \\,\\mathrm{ps}$。\n\n最终计算值为 $t_{\\mathrm{NLDM}} = 8.000 \\,\\mathrm{ps}$ 和 $t_{\\mathrm{CCS}} = 7.140 \\,\\mathrm{ps}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n8.000 & 7.140\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "最后一个练习将理论知识应用于一个系统级的实际设计挑战：为长互连线优化缓冲器（buffer）插入方案。您需要首先使用解析模型（Elmore延迟）来确定最佳的缓冲器数量和尺寸，以最小化总延迟。接着，您将通过构建并求解描述RC梯形网络的微分方程来进行数值瞬态仿真，以验证您设计方案的实际性能，完整体验从分析、优化到仿真验证的数字集成电路设计流程。",
            "id": "4291545",
            "problem": "给定一个由逻辑缓冲链驱动的长互连线，该互连线被建模为分布式阻容网络。目标是通过比较解析延迟预测与模拟分段线性 RC 网络的 Simulation Program with Integrated Circuit Emphasis (SPICE) 行为的数值瞬态解，来验证一个优化的缓冲器设计。\n\n基本原理：\n- 互连线被建模为分布式线路的集总近似：每个级联被划分为 $N$ 个部分，每个部分具有串联电阻 $r_{\\mathrm{seg}}$ 和到地的并联电容 $c_{\\mathrm{seg}}$。这产生了一个遵循电荷守恒定律和欧姆定律的线性时不变网络。其节点动力学满足\n$$\\mathbf{C}\\,\\frac{d\\mathbf{v}}{dt} + \\mathbf{G}\\,\\mathbf{v} = \\mathbf{s}(t),$$\n其中 $\\mathbf{C}$ 是电容对角矩阵，$\\mathbf{G}$ 是由串联电阻和驱动器输出电阻构成的电导矩阵，$\\mathbf{s}(t)$ 是由一个驱动器引起的源向量，该驱动器被建模为通过输出电阻 $R_{\\mathrm{out}}$ 提供理想电压阶跃 $V_{\\mathrm{DD}}$ 的 Thevenin 源。\n- 对于 RC 树上的单个宿点，解析延迟采用 Elmore 延迟（一阶矩近似）。对于从源点经过一系列电阻到宿点的路径，Elmore 延迟定义为\n$$t_{\\mathrm{Elmore}} = \\sum_{j} R_{\\mathrm{up}}(j) \\, C_j,$$\n其中 $C_j$ 是路径上到地的电容（包括宿点电容），$R_{\\mathrm{up}}(j)$ 是从源点到唯一路径上电容 $C_j$ 上游节点的电阻。\n- 中继器（缓冲器）被建模为一个反相器，其特征为单位尺寸输出电阻 $R_0$、输入电容 $C_0$ 和内在延迟 $\\tau_{\\mathrm{int}}$。尺寸为 $s$ 的缓冲器具有输出电阻 $R_0/s$ 和输入电容 $s\\,C_0$。内在延迟 $\\tau_{\\mathrm{int}}$ 被认为是与尺寸无关的。电源电压为 $V_{\\mathrm{DD}}$，开关阈值设置为 $V_{\\mathrm{th}} = 0.5\\,V_{\\mathrm{DD}}$，用于确定 $50\\%$ 阶跃穿越时间。\n- 该链路由沿线插入的 $M$ 个缓冲器和源缓冲器组成，从而产生由等长导线段分隔的 $M+1$ 个驱动级。最终的宿点是一个容性接收器负载 $C_{\\mathrm{L}}$。\n\n设计与验证任务：\n1. 对于给定的互连线长度 $L$ 和接收器负载 $C_{\\mathrm{L}}$，选择插入的缓冲器数量 $M \\in \\{0,1,2,3\\}$ 和一个统一的缓冲器尺寸 $s \\in \\{1,2,4,8,12,16\\}$（应用于源缓冲器和所有插入的缓冲器），以最小化解析预测的总延迟。该解析预测是各级导线级的 Elmore 延迟与源缓冲器和所有插入的缓冲器的内在延迟之和。形式上，如果 $L_{\\mathrm{stage}} = L/(M+1)$，$N$ 是每级的段数，$r_{\\mathrm{seg}} = r' \\cdot L_{\\mathrm{stage}}/N$，$c_{\\mathrm{seg}} = c' \\cdot L_{\\mathrm{stage}}/N$，$R_{\\mathrm{driver}} = R_0/s$，并且对于中间级，$C_{\\mathrm{load}}$ 为 $s\\,C_0$，对于末级，$C_{\\mathrm{load}}$ 为 $C_{\\mathrm{L}}$，那么\n$$t_{\\mathrm{pred}}(M,s) = \\sum_{i=1}^{M+1} \\left( \\sum_{j=1}^{N} \\left( R_{\\mathrm{driver}} + j\\,r_{\\mathrm{seg}} \\right) c_{\\mathrm{seg}} \\;+\\; \\left( R_{\\mathrm{driver}} + N\\,r_{\\mathrm{seg}} \\right) C_{\\mathrm{load},i} \\right) \\;+\\; (M+1)\\,\\tau_{\\mathrm{int}}.$$\n选择使 $t_{\\mathrm{pred}}(M,s)$ 最小化的 $(M,s)$。\n2. 对于选定的 $(M,s)$，计算数值瞬态阶跃响应以获得到最终宿点的模拟总延迟 $t_{\\mathrm{sim}}$，定义为从输入激励断言到远端节点穿越 $V_{\\mathrm{th}}$ 的时刻。数值瞬态是通过依次模拟每个级联来构建的：\n   - 对于级联 $i$ ($i=1,\\dots,M+1$)，建立由通过 $R_{\\mathrm{driver}}$ 的阶跃驱动的该级 RC 梯形网络的节点微分方程；使用数值积分器找到该级最后一个节点穿越 $V_{\\mathrm{th}}$ 的时间 $t_i$。\n   - 将第一级的起始时间初始化为 $\\tau_{\\mathrm{int}}$（源内在延迟）。对于每个中间缓冲器，将 $\\tau_{\\mathrm{int}}$ 添加到下一级的起始时间。那么，模拟的总延迟为\n   $$t_{\\mathrm{sim}} = \\tau_{\\mathrm{int}} + \\sum_{i=1}^{M} \\left( t_i + \\tau_{\\mathrm{int}} \\right) + t_{M+1}。$$\n3. 通过检查解析预测和数值瞬态是否在指定容差内一致来验证优化的缓冲器设计。使用分数容差 $\\delta = 0.25$，并将测试用例的验证布尔值定义为 $\\left|t_{\\mathrm{sim}} - t_{\\mathrm{pred}}\\right| \\le \\delta \\cdot t_{\\mathrm{sim}}$。\n\n互连线和缓冲器参数（请精确使用以下值）：\n- 单位长度导线电阻 $r' = 100~\\Omega/\\mathrm{mm}$。\n- 单位长度导线电容 $c' = 200~\\mathrm{fF}/\\mathrm{mm}$。\n- 单位反相器输出电阻 $R_0 = 5000~\\Omega$。\n- 单位反相器输入电容 $C_0 = 2~\\mathrm{fF}$。\n- 反相器内在延迟 $\\tau_{\\mathrm{int}} = 10~\\mathrm{ps}$。\n- 电源电压 $V_{\\mathrm{DD}} = 1~\\mathrm{V}$。\n- 阈值电压 $V_{\\mathrm{th}} = 0.5~\\mathrm{V}$。\n- 每级梯形网络段数 $N = 40$。\n\n测试套件：\n- 案例 1（正常路径）：$L = 10~\\mathrm{mm}$，$C_{\\mathrm{L}} = 20~\\mathrm{fF}$。\n- 案例 2（短线边界）：$L = 1~\\mathrm{mm}$，$C_{\\mathrm{L}} = 20~\\mathrm{fF}$。\n- 案例 3（超长线）：$L = 50~\\mathrm{mm}$，$C_{\\mathrm{L}} = 20~\\mathrm{fF}$。\n- 案例 4（重负载）：$L = 10~\\mathrm{mm}$，$C_{\\mathrm{L}} = 100~\\mathrm{fF}$。\n\n单位：所有延迟量必须以秒为单位计算。验证容差是无单位的（$t_{\\mathrm{sim}}$ 的一个分数）。不使用角度。不得使用百分比；容差以小数表示。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含四个测试用例的验证结果，形式为方括号括起来的逗号分隔的布尔值列表（例如，“[True,False,True,True]”）。",
            "solution": "我们从一个被建模为阻容梯形网络的互连线的线性时不变描述开始。一个用串联电阻和到地并联电容建模的均匀导线段，其节点方程为\n$$\\mathbf{C}\\,\\frac{d\\mathbf{v}}{dt} + \\mathbf{G}\\,\\mathbf{v} = \\mathbf{s}(t),$$\n其中 $\\mathbf{v}(t)$ 是节点电压向量，$\\mathbf{C}$ 是对角矩阵，其对角元等于并联电容，$\\mathbf{G}$ 是从段间电阻和驱动器输出电阻导出的电导矩阵。驱动器是一个具有串联电阻 $R_{\\mathrm{driver}}$ 的 Thevenin 源，源向量为\n$$\\mathbf{s}(t) = \\mathbf{b}\\,V_{\\mathrm{src}}(t), \\quad \\text{with} \\quad \\mathbf{b} = \\mathbf{C}^{-1} \\mathbf{g},$$\n其中 $\\mathbf{g}$ 编码了连接到第一个节点的 Thevenin 源所引起的注入。在源端出现阶跃后，解在所有节点上单调地趋向于稳态 $V_{\\mathrm{DD}}$，因为没有到地的直接电阻路径；充电是通过驱动器电阻进入电容器的。\n\n通过 Elmore 延迟进行解析预测：\n对于具有单个宿点的 RC 树，Elmore 延迟 $t_{\\mathrm{Elmore}}$ 定义为冲激响应的一阶矩，由下式给出\n$$t_{\\mathrm{Elmore}} = \\sum_{j} R_{\\mathrm{up}}(j)\\, C_j,$$\n其中 $C_j$ 是路径上的接地电容，$R_{\\mathrm{up}}(j)$ 是从源点到 $C_j$ 位置的上游电阻。对于一个由 $N$ 段组成的均匀梯形网络，其段电阻为 $r_{\\mathrm{seg}}$，段电容为 $c_{\\mathrm{seg}}$，通过电阻 $R_{\\mathrm{driver}}$ 驱动，并在最终节点处有负载电容 $C_{\\mathrm{load}}$，该级的 Elmore 延迟为\n$$t_{\\mathrm{Elmore,stage}} = \\sum_{j=1}^{N} \\left( R_{\\mathrm{driver}} + j\\,r_{\\mathrm{seg}} \\right) c_{\\mathrm{seg}} \\;+\\; \\left( R_{\\mathrm{driver}} + N\\,r_{\\mathrm{seg}} \\right) C_{\\mathrm{load}}.$$\n一个带有 $M$ 个插入缓冲器的缓冲链引入了 $M+1$ 个级联。总的解析预测是各级 Elmore 延迟和内在缓冲器延迟的聚合。计算源和 $M$ 个插入的缓冲器，内在延迟贡献了 $(M+1)\\,\\tau_{\\mathrm{int}}$。因此，\n$$t_{\\mathrm{pred}}(M,s) = \\sum_{i=1}^{M+1} t_{\\mathrm{Elmore,stage}}^{(i)} \\;+\\; (M+1)\\,\\tau_{\\mathrm{int}},$$\n其中 $R_{\\mathrm{driver}}= R_0/s$，$c_{\\mathrm{seg}} = c' \\cdot L/(N(M+1))$，$r_{\\mathrm{seg}} = r' \\cdot L/(N(M+1))$，并且对于中间级，$C_{\\mathrm{load}}$ 等于 $s\\,C_0$，对于末级，$C_{\\mathrm{load}}$ 等于 $C_{\\mathrm{L}}$。我们采用这种来自互连线理论的、经过充分检验的一阶矩近似。\n\n优化：\n在某些简化条件下，存在闭式解形式的最佳中继器数量和尺寸，但为了保持设计的通用性并强制执行约束，我们对 $M \\in \\{0,1,2,3\\}$ 和 $s \\in \\{1,2,4,8,12,16\\}$ 进行离散搜索。对于每一对 $(M,s)$，我们计算 $t_{\\mathrm{pred}}(M,s)$ 并选择使其最小化的对。\n\n数值瞬态（类 SPICE）验证：\n我们通过每级的瞬态数值解来验证预测，使用节点形式的线性常微分方程\n$$\\frac{d\\mathbf{v}}{dt} = -\\mathbf{C}^{-1}\\mathbf{G}\\,\\mathbf{v} + \\mathbf{C}^{-1}\\mathbf{g}\\,V_{\\mathrm{src}}(t)。$$\n对于每个级联，我们如下构造 $\\mathbf{C}$ 和 $\\mathbf{G}$：\n- $\\mathbf{C}$ 是对角矩阵，对角元为 $c_{\\mathrm{seg}}$，但在最后一个节点处，对角元为 $c_{\\mathrm{seg}} + C_{\\mathrm{load}}$。\n- $\\mathbf{G}$ 聚合了节点间的电导：对于第 $i$ 个节点，为每个连接到相邻节点的电阻添加 $1/r_{\\mathrm{seg}}$（对邻居的非对角元为 $-1/r_{\\mathrm{seg}}$），并为第一个节点添加 $1/R_{\\mathrm{driver}}$ 以表示驱动器连接。注入向量 $\\mathbf{g}$ 在第一个节点处为 $(1/R_{\\mathrm{driver}})$，其他地方为零。\n\n我们模拟在级联开始时从 $0$ 上升到 $V_{\\mathrm{DD}}$ 的阶跃输入 $V_{\\mathrm{src}}(t)$。反相器的内在延迟通过平移级联的起始时间来考虑：\n- 初始化 $t_{\\mathrm{start}} = \\tau_{\\mathrm{int}}$（源内在延迟）。\n- 对于级联 $i$，在输入阶跃 $t=0$ 时从 $0$ 开始模拟，计算最后一个节点穿越 $V_{\\mathrm{th}} = 0.5\\,V_{\\mathrm{DD}}$ 的时间 $t_i$；然后对于中间缓冲器，更新 $t_{\\mathrm{start}} \\gets t_{\\mathrm{start}} + t_i + \\tau_{\\mathrm{int}}$。对于末级，只加上 $t_{M+1}$ 而不加最后的 $\\tau_{\\mathrm{int}}$，得到\n$$t_{\\mathrm{sim}} = \\tau_{\\mathrm{int}} + \\sum_{i=1}^{M} (t_i + \\tau_{\\mathrm{int}}) + t_{M+1}。$$\n\n验证标准：\n我们为每个测试用例定义验证布尔值为\n$$\\left|t_{\\mathrm{sim}} - t_{\\mathrm{pred}}\\right| \\le \\delta \\cdot t_{\\mathrm{sim}},$$\n其中 $\\delta = 0.25$。这个分数容差反映了模型简化以及与完整瞬态响应相比，Elmore 延迟固有的近似性。\n\n算法设计：\n- 枚举候选 $(M,s)$ 对，计算 $t_{\\mathrm{pred}}(M,s)$。\n- 选择使 $t_{\\mathrm{pred}}$ 最小化的 $(M,s)$。\n- 对于选定的设计，构建每个级联的 $\\mathbf{C}$ 和 $\\mathbf{G}$ 矩阵，使用带有事件检测功能的刚性求解器模拟阶跃响应，以找到级联输出节点处的 $50\\%$ 穿越时间。\n- 如上所述，将各级的 $t_{\\mathrm{sim}}$ 和内在延迟聚合起来。\n- 根据容差比较 $t_{\\mathrm{sim}}$ 和 $t_{\\mathrm{pred}}$，并为每个测试用例返回一个布尔值。\n\n单位和测试套件：\n所有延迟均使用给定的参数值以秒为单位计算。构建了四个测试用例，以在典型长度、短线边界、极端长线情况和重负载条件下检验该模型。最终输出为一行，包含按顺序排列的四个布尔值，用方括号括起并用逗号分隔。\n\n该方法从基本电路定律（电荷守恒和欧姆定律）出发构建动力学模型，使用经过充分检验的一阶矩延迟近似进行解析预测，并采用与电子设计自动化（EDA）实践一致的数值积分进行瞬态验证，从而满足了对有原则的推导和全面验证的高阶研究生要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Parameters (SI units)\nr_per_mm = 100.0  # ohm/mm\nc_per_mm = 200e-15  # F/mm\nR0 = 5000.0  # ohm\nC0 = 2e-15  # F\ntau_int = 10e-12  # s\nVdd = 1.0  # V\nVth = 0.5 * Vdd\nN_seg = 40  # segments per stage\ntolerance_frac = 0.25\n\n# Candidate design space\nM_candidates = [0, 1, 2, 3]\ns_candidates = [1, 2, 4, 8, 12, 16]\n\ndef stage_elmore_delay(L_stage, R_driver, C_load):\n    # Compute Elmore delay for one stage with uniform ladder of N_seg\n    r_seg = (r_per_mm * (L_stage * 1e3)) / N_seg  # ohm, convert L_stage m to mm\n    c_seg = (c_per_mm * (L_stage * 1e3)) / N_seg  # F\n    # Upstream resistance to cap j is R_driver + j*r_seg\n    # Sum over j=1..N_seg: (R_driver + j*r_seg) * c_seg\n    j = np.arange(1, N_seg + 1, dtype=float)\n    sum_line = np.sum((R_driver + j * r_seg) * c_seg)\n    R_up_N = R_driver + N_seg * r_seg\n    sum_load = R_up_N * C_load\n    return sum_line + sum_load\n\ndef predict_total_delay(L, CL, M, s):\n    L_stage = L / (M + 1)\n    R_driver = R0 / s\n    total = 0.0\n    # Intermediate stages: load is buffer input capacitance s*C0\n    for i in range(1, M + 1):\n        total += stage_elmore_delay(L_stage, R_driver, s * C0)\n    # Final stage: load is CL\n    total += stage_elmore_delay(L_stage, R_driver, CL)\n    # Add intrinsic delays: source + M buffers\n    total += (M + 1) * tau_int\n    return total\n\ndef build_stage_matrices(L_stage, R_driver, C_load):\n    # Build C and G matrices for one stage ladder\n    r_seg = (r_per_mm * (L_stage * 1e3)) / N_seg  # ohm\n    c_seg = (c_per_mm * (L_stage * 1e3)) / N_seg  # F\n    N = N_seg\n    C = np.zeros((N, N))\n    for i in range(N - 1):\n        C[i, i] = c_seg\n    C[N - 1, N - 1] = c_seg + C_load\n    G = np.zeros((N, N))\n    # Resistive connections between nodes: r_seg\n    for i in range(N):\n        if i > 0:\n            G[i, i] += 1.0 / r_seg\n            G[i, i - 1] -= 1.0 / r_seg\n        if i < N - 1:\n            G[i, i] += 1.0 / r_seg\n            G[i, i + 1] -= 1.0 / r_seg\n    # Driver connection at node 0:\n    G[0, 0] += 1.0 / R_driver\n    # Source vector corresponds to Vsrc/R_driver at node 0\n    g = np.zeros(N)\n    g[0] = 1.0 / R_driver\n    # Precompute A and b for dv/dt = A v + b*Vsrc(t)\n    # Use solve_ivp with step starting at t=0, so Vsrc(t) is piecewise: 0->Vdd, but we start at 0 time with Vsrc=Vdd\n    # Therefore, treat Vsrc(t) = Vdd constant for t >= 0\n    # dv/dt = -C^{-1} G v + C^{-1} g Vdd\n    # To avoid explicit inverse, solve linear systems\n    # We'll compute A v + u with u = C^{-1} g Vdd on the fly using solves\n    return C, G, g\n\ndef stage_cross_time(L_stage, R_driver, C_load, Vth, Vdd):\n    C, G, g = build_stage_matrices(L_stage, R_driver, C_load)\n    N = C.shape[0]\n    # Define function for dv/dt = -C^{-1} G v + C^{-1} g * Vdd\n    # We'll use linear solves with LU factorization via numpy.linalg.solve (sufficient for small N)\n    # Precompute factorization: but numpy doesn't expose LU; solve each call due to small N\n    def rhs(t, v):\n        # Compute w = G v - g * Vdd\n        w = G.dot(v) - g * Vdd\n        # dv/dt = - C^{-1} w\n        # Solve C x = -w\n        return np.linalg.solve(C, -w)\n\n    def event_out(t, v):\n        return v[-1] - Vth\n\n    event_out.terminal = True\n    event_out.direction = 1.0\n\n    v0 = np.zeros(N)\n    # Rough t_max estimate from Elmore stage delay:\n    # Use R_up_N and total cap as a heuristic upper bound multiplier\n    r_seg = (r_per_mm * (L_stage * 1e3)) / N_seg\n    c_seg = (c_per_mm * (L_stage * 1e3)) / N_seg\n    R_up_N = R_driver + N_seg * r_seg\n    C_total = (N_seg - 1) * c_seg + (c_seg + C_load)\n    t_guess = R_up_N * C_total\n    t_max = max(5.0 * t_guess, 1e-12)  # ensure nonzero\n    sol = solve_ivp(rhs, (0.0, t_max), v0, method='BDF', rtol=1e-6, atol=1e-9, events=event_out)\n    if sol.t_events[0].size == 0:\n        # If no event detected, assume fully charged; set crossing to t_max\n        return t_max\n    return sol.t_events[0][0]\n\ndef optimize_design(L, CL):\n    best = None\n    best_pred = None\n    for M in M_candidates:\n        for s in s_candidates:\n            t_pred = predict_total_delay(L, CL, M, s)\n            if best is None or t_pred < best_pred:\n                best = (M, s)\n                best_pred = t_pred\n    return best, best_pred\n\ndef simulate_total_delay(L, CL, M, s):\n    L_stage = L / (M + 1)\n    R_driver = R0 / s\n    t_total = tau_int  # source intrinsic delay before stage 1 starts\n    # Intermediate stages leading to buffers\n    for i in range(1, M + 1):\n        t_i = stage_cross_time(L_stage, R_driver, s * C0, Vth, Vdd)\n        t_total += t_i + tau_int\n    # Final stage to receiver\n    t_last = stage_cross_time(L_stage, R_driver, CL, Vth, Vdd)\n    t_total += t_last\n    return t_total\n\ndef validate_case(L_mm, CL_fF):\n    L = L_mm * 1e-3  # convert mm to meters\n    CL = CL_fF * 1e-15  # F\n    (M_opt, s_opt), t_pred = optimize_design(L, CL)\n    t_sim = simulate_total_delay(L, CL, M_opt, s_opt)\n    return abs(t_sim - t_pred) <= tolerance_frac * t_sim\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (L_mm, CL_fF)\n    test_cases = [\n        (10.0, 20.0),   # Case 1\n        (1.0, 20.0),    # Case 2\n        (50.0, 20.0),   # Case 3\n        (10.0, 100.0),  # Case 4\n    ]\n\n    results = []\n    for L_mm, CL_fF in test_cases:\n        ok = validate_case(L_mm, CL_fF)\n        results.append(ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}