{
    "hands_on_practices": [
        {
            "introduction": "Logical effort provides a simple yet powerful framework for estimating and optimizing delay in digital circuits without resorting to complex simulations. To truly master this technique, it is essential to understand its physical basis. This exercise guides you through a first-principles derivation of the logical effort for NAND and NOR gates, showing how this key metric arises from fundamental transistor sizing rules designed to achieve a target drive strength relative to a reference inverter. ",
            "id": "4291543",
            "problem": "Consider a Complementary Metal-Oxide-Semiconductor (CMOS) logic library intended for Electronic Design Automation (EDA) timing optimization. Assume the Resistive-Capacitive (RC) delay model, where the propagation delay scales proportionally to the product of an effective on-resistance and the capacitive load. Use first principles of Metal-Oxide-Semiconductor Field-Effect Transistor (MOSFET) conduction to model the on-resistance scaling with device width for minimum-length transistors as follows: the on-resistance of an $n$-channel device scales as $r_n/W$ and that of a $p$-channel device scales as $r_p/W$, where $r_n$ and $r_p$ are per-unit-width on-resistances and $W$ is the device width. Let the gate capacitance per unit width for both $n$-channel and $p$-channel transistors be $c_g$.\n\nDefine the sizing of a reference inverter by equalizing its pull-down and pull-up effective on-resistances under the RC model. Let the $n$-channel inverter width be $W_{n,\\text{inv}}=1$ and define the $p$-channel width $W_{p,\\text{inv}}$ from the equal-resistance condition. Introduce the ratio $\\rho = r_p/r_n$, and express $W_{p,\\text{inv}}$ in terms of $\\rho$. Using this reference, consider a $k$-input NAND gate and a $k$-input NOR gate, each sized so that their worst-case pull-down and pull-up effective on-resistances match those of the reference inverter. Assume series stacks sum resistances and parallel branches do not change the conducting path resistance, and assume each input controls exactly one $n$-channel and one $p$-channel device in its respective network.\n\nUsing the formal definition of logical effort, define the effective logical effort $g$ of a given input of a gate as the ratio of the input capacitance of that input to the input capacitance of the reference inverter, under the constraint that the gate and the inverter deliver the same output drive (i.e., have matched worst-case effective on-resistance) for the corresponding transition. Derive closed-form analytical expressions, in terms of $k$ and $\\rho$ only, for the effective logical effort of a $k$-input NAND gate and a $k$-input NOR gate.\n\nExpress your final answers as two dimensionless analytical expressions. No numerical evaluation or rounding is required.",
            "solution": "The problem statement is formally evaluated for validity before proceeding to a solution.\n\n### Step 1: Extract Givens\n- **Model**: Resistive-Capacitive (RC) delay model.\n- **Delay Scaling**: Proportional to the product of effective on-resistance and capacitive load.\n- **On-resistance Scaling**:\n  - $n$-channel MOSFET: $r_{n}/W$.\n  - $p$-channel MOSFET: $r_{p}/W$.\n- **Constants and Variables**:\n  - $r_{n}$: per-unit-width on-resistance of an $n$-channel device.\n  - $r_{p}$: per-unit-width on-resistance of a $p$-channel device.\n  - $c_{g}$: gate capacitance per unit width for both $n$-channel and $p$-channel transistors.\n  - $W$: device width.\n  - $k$: number of inputs for NAND and NOR gates.\n  - $\\rho = r_{p}/r_{n}$.\n- **Reference Inverter Sizing**:\n  - Equalize pull-down and pull-up effective on-resistances.\n  - $n$-channel width, $W_{n,\\text{inv}} = 1$.\n  - $p$-channel width, $W_{p,\\text{inv}}$, is to be determined.\n- **NAND/NOR Gate Sizing**:\n  - A $k$-input NAND and a $k$-input NOR gate are sized so that their worst-case pull-down and pull-up effective on-resistances match those of the reference inverter.\n- **Simplifying Assumptions**:\n  - Series stacks sum resistances.\n  - Parallel branches do not change the conducting path resistance (interpreted as worst-case resistance is that of a single branch).\n  - Each input controls exactly one $n$-channel and one $p$-channel device.\n- **Definition of Logical Effort ($g$):**\n  - $g = \\frac{\\text{Input capacitance of gate input}}{\\text{Input capacitance of reference inverter}}$.\n  - This ratio is calculated under the condition that the gate and the inverter deliver the same output drive (matched worst-case effective on-resistance).\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is well-grounded in the principles of digital integrated circuit design, specifically using the first-order RC delay model and the concept of logical effort, which are standard paradigms in EDA for timing analysis and optimization. The models for resistance and capacitance ($R \\propto 1/W$, $C \\propto W$) are standard simplifications.\n- **Well-Posedness**: The problem is well-posed. It provides all necessary definitions, constraints (matched resistance), and a clear objective (derive expressions for logical effort $g$). The information is self-contained and sufficient for deriving a unique analytical solution.\n- **Objectivity**: The problem is stated in precise, objective, and technical language, free from any ambiguity or subjective claims.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It represents a standard, albeit simplified, academic problem in the field of VLSI design. The assumptions are clearly stated and consistent with first-order analysis. The solution process is initiated.\n\n### Solution Derivation\n\nThe derivation proceeds in four parts: 1. Characterize the reference inverter. 2. Analyze the $k$-input NAND gate. 3. Analyze the $k$-input NOR gate. 4. Compute the logical efforts.\n\n**1. Reference Inverter Characterization**\n\nThe reference inverter is sized to have equal pull-up and pull-down resistances.\nThe pull-down resistance, $R_{\\text{pd,inv}}$, is provided by a single $n$-channel transistor of width $W_{n,\\text{inv}}$.\n$$R_{\\text{pd,inv}} = \\frac{r_n}{W_{n,\\text{inv}}}$$\nGiven $W_{n,\\text{inv}} = 1$, the pull-down resistance is:\n$$R_{\\text{pd,inv}} = \\frac{r_n}{1} = r_n$$\nThe pull-up resistance, $R_{\\text{pu,inv}}$, is provided by a single $p$-channel transistor of width $W_{p,\\text{inv}}$.\n$$R_{\\text{pu,inv}} = \\frac{r_p}{W_{p,\\text{inv}}}$$\nThe sizing condition is $R_{\\text{pu,inv}} = R_{\\text{pd,inv}}$.\n$$\\frac{r_p}{W_{p,\\text{inv}}} = r_n$$\nSolving for the $p$-channel width, $W_{p,\\text{inv}}$:\n$$W_{p,\\text{inv}} = \\frac{r_p}{r_n}$$\nUsing the given definition $\\rho = r_p/r_n$, we have:\n$$W_{p,\\text{inv}} = \\rho$$\nThe matched drive strength, or effective on-resistance, of the reference inverter is $R_{\\text{inv}} = r_n$.\n\nThe input capacitance of the reference inverter, $C_{\\text{in,inv}}$, is the sum of the gate capacitances of its two transistors. The gate capacitance of a transistor is $c_g W$.\n$$C_{\\text{in,inv}} = c_g W_{n,\\text{inv}} + c_g W_{p,\\text{inv}} = c_g(W_{n,\\text{inv}} + W_{p,\\text{inv}})$$\nSubstituting the widths:\n$$C_{\\text{in,inv}} = c_g(1 + \\rho)$$\n\n**2. $k$-Input NAND Gate Analysis**\n\nA $k$-input NAND gate consists of $k$ $n$-channel transistors in series in the pull-down network (PDN) and $k$ $p$-channel transistors in parallel in the pull-up network (PUN). Let the widths be $W_{n,\\text{nand}}$ and $W_{p,\\text{nand}}$, respectively for each transistor.\n\nThe worst-case pull-down resistance occurs when all $k$ series $n$-channel transistors are conducting. The total resistance is the sum of individual resistances.\n$$R_{\\text{pd,nand}} = \\sum_{i=1}^{k} \\frac{r_n}{W_{n,\\text{nand}}} = k \\frac{r_n}{W_{n,\\text{nand}}}$$\nTo match the inverter's drive strength, we set $R_{\\text{pd,nand}} = R_{\\text{inv}} = r_n$.\n$$k \\frac{r_n}{W_{n,\\text{nand}}} = r_n \\implies W_{n,\\text{nand}} = k$$\n\nThe worst-case pull-up resistance occurs when only one of the $k$ parallel $p$-channel transistors is conducting.\n$$R_{\\text{pu,nand}} = \\frac{r_p}{W_{p,\\text{nand}}}$$\nTo match the inverter's drive strength, we set $R_{\\text{pu,nand}} = R_{\\text{inv}} = r_n$.\n$$\\frac{r_p}{W_{p,\\text{nand}}} = r_n \\implies W_{p,\\text{nand}} = \\frac{r_p}{r_n} = \\rho$$\n\nThe input capacitance of a single input of the NAND gate, $C_{\\text{in,nand}}$, connects to one $n$-channel and one $p$-channel transistor.\n$$C_{\\text{in,nand}} = c_g W_{n,\\text{nand}} + c_g W_{p,\\text{nand}} = c_g(k + \\rho)$$\n\nThe logical effort of the NAND gate, $g_{\\text{nand}}$, is the ratio of its input capacitance to that of the reference inverter.\n$$g_{\\text{nand}} = \\frac{C_{\\text{in,nand}}}{C_{\\text{in,inv}}} = \\frac{c_g(k + \\rho)}{c_g(1 + \\rho)} = \\frac{k + \\rho}{1 + \\rho}$$\n\n**3. $k$-Input NOR Gate Analysis**\n\nA $k$-input NOR gate consists of $k$ $n$-channel transistors in parallel in the PDN and $k$ $p$-channel transistors in series in the PUN. Let the widths be $W_{n,\\text{nor}}$ and $W_{p,\\text{nor}}$, respectively.\n\nThe worst-case pull-down resistance occurs when only one of the $k$ parallel $n$-channel transistors is conducting.\n$$R_{\\text{pd,nor}} = \\frac{r_n}{W_{n,\\text{nor}}}$$\nTo match the inverter's drive strength, we set $R_{\\text{pd,nor}} = R_{\\text{inv}} = r_n$.\n$$\\frac{r_n}{W_{n,\\text{nor}}} = r_n \\implies W_{n,\\text{nor}} = 1$$\n\nThe worst-case pull-up resistance occurs when all $k$ series $p$-channel transistors are conducting. The total resistance is the sum of individual resistances.\n$$R_{\\text{pu,nor}} = \\sum_{i=1}^{k} \\frac{r_p}{W_{p,\\text{nor}}} = k \\frac{r_p}{W_{p,\\text{nor}}}$$\nTo match the inverter's drive strength, we set $R_{\\text{pu,nor}} = R_{\\text{inv}} = r_n$.\n$$k \\frac{r_p}{W_{p,\\text{nor}}} = r_n \\implies W_{p,\\text{nor}} = k \\frac{r_p}{r_n} = k\\rho$$\n\nThe input capacitance of a single input of the NOR gate, $C_{\\text{in,nor}}$, connects to one $n$-channel and one $p$-channel transistor.\n$$C_{\\text{in,nor}} = c_g W_{n,\\text{nor}} + c_g W_{p,\\text{nor}} = c_g(1 + k\\rho)$$\n\nThe logical effort of the NOR gate, $g_{\\text{nor}}$, is the ratio of its input capacitance to that of the reference inverter.\n$$g_{\\text{nor}} = \\frac{C_{\\text{in,nor}}}{C_{\\text{in,inv}}} = \\frac{c_g(1 + k\\rho)}{c_g(1 + \\rho)} = \\frac{1 + k\\rho}{1 + \\rho}$$\n\nThe final expressions for the logical efforts of the $k$-input NAND and NOR gates are therefore established in terms of $k$ and $\\rho$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{k+\\rho}{1+\\rho} & \\frac{1+k\\rho}{1+\\rho}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While logical effort is excellent for initial design, production static timing analysis (STA) relies on more sophisticated, pre-characterized models. Two dominant paradigms are the Non-Linear Delay Model (NLDM), which uses a resistive abstraction, and the Composite Current Source (CCS) model, which uses a current-source abstraction. This practice provides a hands-on comparison by asking you to compute a gate's delay using both approaches, revealing how a more physically accurate piecewise current-source model captures non-linear transistor behavior that a simple resistor model averages out. ",
            "id": "4291614",
            "problem": "A complementary metal–oxide–semiconductor inverter is characterized for output fall delay under a specific input transition and loading condition. Two industry-standard macromodeling approaches are considered: the Non-Linear Delay Model (NLDM) and the Composite Current Source (CCS). The NLDM (Non-Linear Delay Model) abstracts the driver as a voltage-controlled resistor, whereas the CCS (Composite Current Source) abstracts the driver as a voltage-dependent current source. You will construct a physically meaningful equivalent current source for the pull-down network and compute the output fall delay to the mid-level under a given capacitive load, then compare to the delay predicted by an NLDM-style resistive abstraction calibrated at a reference load.\n\nAssume the following characterization context and data are valid and self-consistent for the given inverter and input transition:\n- Supply voltage is $V_{\\mathrm{DD}} = 1.0 \\,\\mathrm{V}$.\n- The output load is a lumped capacitance $C_{L} = 20 \\,\\mathrm{fF}$.\n- The output fall delay is defined here as the time for $V_{\\mathrm{out}}$ to transition from $V_{\\mathrm{DD}}$ to $0.5\\,V_{\\mathrm{DD}}$ due solely to the output-dependent discharge dynamics; input-related intrinsic delay contributions are excluded by construction of the abstractions used below.\n- NLDM calibration point: For a reference capacitive load $C_{\\mathrm{ref}} = 10 \\,\\mathrm{fF}$ under the same input transition, the measured output-dependent fall delay is $t_{\\mathrm{ref}} = 4.0 \\,\\mathrm{ps}$. Treat the NLDM driver as a single effective resistance that is load-independent over this range when used to predict $V_{\\mathrm{out}}$ decay.\n- CCS pull-down current source construction for the same input transition: the equivalent pull-down current delivered to the load is modeled as a physically plausible function of the instantaneous output voltage $V_{\\mathrm{out}}(t)$, given by\n$$\nI_{\\mathrm{CCS}}(V_{\\mathrm{out}}) = \n\\begin{cases}\nI_{0}, & 0.7 \\leq V_{\\mathrm{out}} \\leq 1.0, \\\\\nI_{0}\\,\\dfrac{V_{\\mathrm{out}}}{0.7}, & 0 \\leq V_{\\mathrm{out}} < 0.7,\n\\end{cases}\n$$\nwith $I_{0} = 1.5 \\,\\mathrm{mA}$. This construction encodes the high-field saturation behavior at large drain-to-source voltage and a transition to a quasi-linear regime as $V_{\\mathrm{out}}$ approaches ground.\n\nStarting only from charge conservation and circuit laws, compute:\n1. The NLDM-predicted output fall delay to $0.5\\,V_{\\mathrm{DD}}$ for the given $C_{L}$.\n2. The CCS-predicted output fall delay to $0.5\\,V_{\\mathrm{DD}}$ for the given $C_{L}$, using the provided $I_{\\mathrm{CCS}}(V_{\\mathrm{out}})$.\n\nExpress both delays in picoseconds and round your answers to four significant figures. Provide your final numeric values only, with no intermediate steps or units in the final answer.",
            "solution": "The problem is valid as it is scientifically grounded in standard integrated circuit delay modeling techniques (NLDM and CCS), well-posed with sufficient and consistent data, and objectively formulated.\n\nThe solution is determined in two parts as requested.\n\nPart 1: NLDM-predicted output fall delay\n\nThe Non-Linear Delay Model (NLDM) approximates the pull-down network of the inverter as a single effective resistance, $R_{\\mathrm{eff}}$. The circuit during the output fall transition is modeled as a capacitor $C_{L}$ discharging to ground through this resistor $R_{\\mathrm{eff}}$. The initial voltage on the capacitor is $V_{\\mathrm{out}}(0) = V_{\\mathrm{DD}}$.\n\nThe voltage at the output node, $V_{\\mathrm{out}}(t)$, follows the equation for an RC circuit discharge:\n$$\nV_{\\mathrm{out}}(t) = V_{\\mathrm{DD}} \\exp\\left(-\\frac{t}{R_{\\mathrm{eff}} C_{L}}\\right)\n$$\nThe output fall delay, $t_{\\mathrm{NLDM}}$, is defined as the time for $V_{\\mathrm{out}}(t)$ to reach $0.5 V_{\\mathrm{DD}}$. We set $V_{\\mathrm{out}}(t_{\\mathrm{NLDM}}) = 0.5 V_{\\mathrm{DD}}$:\n$$\n0.5 V_{\\mathrm{DD}} = V_{\\mathrm{DD}} \\exp\\left(-\\frac{t_{\\mathrm{NLDM}}}{R_{\\mathrm{eff}} C_{L}}\\right)\n$$\n$$\n0.5 = \\exp\\left(-\\frac{t_{\\mathrm{NLDM}}}{R_{\\mathrm{eff}} C_{L}}\\right)\n$$\nTaking the natural logarithm of both sides:\n$$\n\\ln(0.5) = -\\frac{t_{\\mathrm{NLDM}}}{R_{\\mathrm{eff}} C_{L}}\n$$\nUsing the property $\\ln(0.5) = -\\ln(2)$, we solve for $t_{\\mathrm{NLDM}}$:\n$$\nt_{\\mathrm{NLDM}} = R_{\\mathrm{eff}} C_{L} \\ln(2)\n$$\nThis equation shows that in the NLDM model, the delay is directly proportional to the load capacitance $C_{L}$. The problem states that $R_{\\mathrm{eff}}$ is load-independent. We can use the provided calibration point ($t_{\\mathrm{ref}} = 4.0 \\,\\mathrm{ps}$ for $C_{\\mathrm{ref}} = 10 \\,\\mathrm{fF}$) to find the delay for the target load $C_{L} = 20 \\,\\mathrm{fF}$.\n\nThe relationship is linear:\n$$\n\\frac{t_{\\mathrm{NLDM}}}{C_{L}} = \\frac{t_{\\mathrm{ref}}}{C_{\\mathrm{ref}}} = R_{\\mathrm{eff}}\\ln(2)\n$$\nTherefore, we can calculate $t_{\\mathrm{NLDM}}$ by scaling the reference delay:\n$$\nt_{\\mathrm{NLDM}} = t_{\\mathrm{ref}} \\frac{C_{L}}{C_{\\mathrm{ref}}}\n$$\nSubstituting the given values:\n$$\nt_{\\mathrm{NLDM}} = (4.0 \\,\\mathrm{ps}) \\frac{20 \\,\\mathrm{fF}}{10 \\,\\mathrm{fF}} = 4.0 \\times 2 \\,\\mathrm{ps} = 8.0 \\,\\mathrm{ps}\n$$\nRounding to four significant figures, the NLDM-predicted delay is $8.000 \\,\\mathrm{ps}$.\n\nPart 2: CCS-predicted output fall delay\n\nThe Composite Current Source (CCS) model approximates the pull-down network as a voltage-dependent current source, $I_{\\mathrm{CCS}}(V_{\\mathrm{out}})$. The current from this source discharges the load capacitor $C_{L}$. The governing differential equation is derived from the definition of capacitance, $I = C \\frac{dV}{dt}$. The discharge current flowing out of the node is $I_{\\mathrm{CCS}}$, so:\n$$\nI_{\\mathrm{CCS}}(V_{\\mathrm{out}}) = -C_{L} \\frac{dV_{\\mathrm{out}}}{dt}\n$$\nTo find the fall delay, $t_{\\mathrm{CCS}}$, we separate variables and integrate. The delay is the time for $V_{\\mathrm{out}}$ to fall from $V_{\\mathrm{DD}} = 1.0 \\,\\mathrm{V}$ to $0.5 V_{\\mathrm{DD}} = 0.5 \\,\\mathrm{V}$.\n$$\ndt = -C_{L} \\frac{dV_{\\mathrm{out}}}{I_{\\mathrm{CCS}}(V_{\\mathrm{out}})}\n$$\nIntegrating from $t=0$ to $t=t_{\\mathrm{CCS}}$:\n$$\nt_{\\mathrm{CCS}} = \\int_{0}^{t_{\\mathrm{CCS}}} dt = \\int_{V_{\\mathrm{DD}}}^{0.5V_{\\mathrm{DD}}} -C_{L} \\frac{dV_{\\mathrm{out}}}{I_{\\mathrm{CCS}}(V_{\\mathrm{out}})} = C_{L} \\int_{0.5V_{\\mathrm{DD}}}^{V_{\\mathrm{DD}}} \\frac{dV_{\\mathrm{out}}}{I_{\\mathrm{CCS}}(V_{\\mathrm{out}})}\n$$\nThe provided current model is a piecewise function of $V_{\\mathrm{out}}$ (in volts):\n$$\nI_{\\mathrm{CCS}}(V_{\\mathrm{out}}) = \n\\begin{cases}\nI_{0}, & 0.7 \\leq V_{\\mathrm{out}} \\leq 1.0, \\\\\nI_{0}\\,\\dfrac{V_{\\mathrm{out}}}{0.7}, & 0 \\leq V_{\\mathrm{out}} < 0.7,\n\\end{cases}\n$$\nOur integration range is from $0.5 \\,\\mathrm{V}$ to $1.0 \\,\\mathrm{V}$. The function definition changes at $V_{\\mathrm{out}} = 0.7 \\,\\mathrm{V}$, so we must split the integral at this point:\n$$\nt_{\\mathrm{CCS}} = C_{L} \\left[ \\int_{0.5}^{0.7} \\frac{dV_{\\mathrm{out}}}{I_{\\mathrm{CCS}}(V_{\\mathrm{out}})} + \\int_{0.7}^{1.0} \\frac{dV_{\\mathrm{out}}}{I_{\\mathrm{CCS}}(V_{\\mathrm{out}})} \\right]\n$$\nNow, we substitute the corresponding expression for $I_{\\mathrm{CCS}}(V_{\\mathrm{out}})$ in each interval:\n$$\nt_{\\mathrm{CCS}} = C_{L} \\left[ \\int_{0.5}^{0.7} \\frac{dV_{\\mathrm{out}}}{I_{0}\\,\\frac{V_{\\mathrm{out}}}{0.7}} + \\int_{0.7}^{1.0} \\frac{dV_{\\mathrm{out}}}{I_{0}} \\right]\n$$\nFactoring out the constant $1/I_{0}$:\n$$\nt_{\\mathrm{CCS}} = \\frac{C_{L}}{I_{0}} \\left[ \\int_{0.5}^{0.7} \\frac{0.7}{V_{\\mathrm{out}}} dV_{\\mathrm{out}} + \\int_{0.7}^{1.0} 1 \\, dV_{\\mathrm{out}} \\right]\n$$\nEvaluating the integrals:\n$$\n\\int_{0.5}^{0.7} \\frac{0.7}{V_{\\mathrm{out}}} dV_{\\mathrm{out}} = 0.7 \\left[\\ln|V_{\\mathrm{out}}|\\right]_{0.5}^{0.7} = 0.7 (\\ln(0.7) - \\ln(0.5)) = 0.7 \\ln\\left(\\frac{0.7}{0.5}\\right) = 0.7 \\ln(1.4)\n$$\n$$\n\\int_{0.7}^{1.0} 1 \\, dV_{\\mathrm{out}} = \\left[V_{\\mathrm{out}}\\right]_{0.7}^{1.0} = 1.0 - 0.7 = 0.3\n$$\nSubstituting these results back into the expression for $t_{\\mathrm{CCS}}$:\n$$\nt_{\\mathrm{CCS}} = \\frac{C_{L}}{I_{0}} \\left[ 0.7 \\ln(1.4) + 0.3 \\right]\n$$\nNow we substitute the numerical values: $C_{L} = 20 \\,\\mathrm{fF} = 20 \\times 10^{-15} \\,\\mathrm{F}$ and $I_{0} = 1.5 \\,\\mathrm{mA} = 1.5 \\times 10^{-3} \\,\\mathrm{A}$.\n$$\n\\frac{C_{L}}{I_{0}} = \\frac{20 \\times 10^{-15} \\,\\mathrm{F}}{1.5 \\times 10^{-3} \\,\\mathrm{A}} = \\frac{40}{3} \\times 10^{-12} \\,\\mathrm{s} = \\frac{40}{3} \\,\\mathrm{ps}\n$$\n$$\nt_{\\mathrm{CCS}} = \\frac{40}{3} \\left[ 0.7 \\ln(1.4) + 0.3 \\right] \\,\\mathrm{ps}\n$$\nUsing $\\ln(1.4) \\approx 0.3364722$:\n$$\nt_{\\mathrm{CCS}} \\approx \\frac{40}{3} \\left[ 0.7 \\times 0.3364722 + 0.3 \\right] \\,\\mathrm{ps}\n$$\n$$\nt_{\\mathrm{CCS}} \\approx \\frac{40}{3} \\left[ 0.23553054 + 0.3 \\right] \\,\\mathrm{ps}\n$$\n$$\nt_{\\mathrm{CCS}} \\approx \\frac{40}{3} \\left[ 0.53553054 \\right] \\,\\mathrm{ps}\n$$\n$$\nt_{\\mathrm{CCS}} \\approx 7.1404072 \\,\\mathrm{ps}\n$$\nRounding to four significant figures, the CCS-predicted delay is $7.140 \\,\\mathrm{ps}$.\n\nFinal computed values are $t_{\\mathrm{NLDM}} = 8.000 \\,\\mathrm{ps}$ and $t_{\\mathrm{CCS}} = 7.140 \\,\\mathrm{ps}$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n8.000 & 7.140\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "The abstract models used in timing analysis, such as effective current ($I_{\\text{eff}}$) models, are not arbitrary; they are built by characterizing detailed transistor-level simulations. This programming exercise simulates this characterization process, offering a deep, practical understanding of how factors like input slew affect a gate's real-world performance. You will implement a simple transient simulator to generate a discharge waveform and then analyze it to extract an effective current metric, bridging the gap between physical simulation and abstract modeling. ",
            "id": "4291527",
            "problem": "You are tasked with designing and implementing a principled numerical procedure that, given a transient discharge of a logic gate output node driven by a Metal-Oxide-Semiconductor Field-Effect Transistor (MOSFET), extracts an effective current metric as a function of input slew and uses it to estimate propagation delay. This exercise is situated within the domain of Integrated Circuits and Electronic Design Automation (EDA) and focuses on propagation delay modeling for logic gates. The waveform to be analyzed is generated by a physically plausible ordinary differential equation derived from charge and current conservation. The goal is to start from first principles and construct an algorithm that determines an effective discharge current over a defined output voltage window for a falling output transition, and then uses this effective current to estimate delay.\n\nUse the following fundamental base:\n- The Simulation Program with Integrated Circuit Emphasis (SPICE) transient is governed by conservation of charge: if a load capacitor of value $C_{L}$ is connected to the output node, the node voltage $V_{\\text{out}}(t)$ obeys $C_{L}\\,\\frac{d V_{\\text{out}}(t)}{d t} = - I_{n}(t)$ during a falling transition, where $I_{n}(t)$ is the instantaneous discharge current through the conducting network.\n- Electric charge satisfies $Q(t) = C_{L} V_{\\text{out}}(t)$ on the ideal capacitor and electric current satisfies $I(t) = dQ(t)/dt$.\n\nConstruct a self-contained program that:\n- Synthesizes a physically plausible transient for a logic gate output falling from $V_{\\text{DD}}$ to $0$ under the action of a single n-type MOSFET (NMOS) discharging a load capacitor. The input voltage $V_{\\text{in}}(t)$ is a ramp from $0$ to $V_{\\text{DD}}$ with a specified slew $S_{\\text{in}}$, interpreted as the time to go from $0$ to $V_{\\text{DD}}$.\n- Uses a piecewise device current model for the NMOS discharge current $I_{n}$ based on the gate-to-source voltage $V_{\\text{GS}}(t)$ and the drain-to-source voltage $V_{\\text{DS}}(t)$:\n  - If $V_{\\text{GS}}(t) \\le V_{\\text{th}}$, set $I_{n}(t) = 0$.\n  - If $V_{\\text{GS}}(t) > V_{\\text{th}}$ and $V_{\\text{DS}}(t) \\ge V_{\\text{GS}}(t) - V_{\\text{th}}$, use a velocity-saturation inspired $\\alpha$-power saturation model $I_{n}(t) = k_{\\alpha}\\,\\big(V_{\\text{GS}}(t) - V_{\\text{th}}\\big)^{\\alpha}$ where $\\alpha > 1$.\n  - If $V_{\\text{GS}}(t) > V_{\\text{th}}$ and $V_{\\text{DS}}(t) < V_{\\text{GS}}(t) - V_{\\text{th}}$, use a triode (linear) region model $I_{n}(t) = k_{\\text{lin}}\\,\\Big(\\big(V_{\\text{GS}}(t) - V_{\\text{th}}\\big)\\,V_{\\text{DS}}(t) - \\frac{1}{2} V_{\\text{DS}}(t)^{2}\\Big)$, clipped to be nonnegative.\n- Numerically integrates the differential equation $C_{L}\\,\\frac{d V_{\\text{out}}(t)}{d t} = - I_{n}(t)$ using a stable explicit time-stepping method to obtain $V_{\\text{out}}(t)$ and $I_{n}(t)$ over time for each test case.\n- Defines an extraction window for the output voltage $V_{\\text{out}}(t)$ from $0.9\\,V_{\\text{DD}}$ down to $0.1\\,V_{\\text{DD}}$. Over this window, computes an effective current $I_{\\text{eff}}(S_{\\text{in}})$ as the time-average of $I_{n}(t)$ restricted to the time interval in which $V_{\\text{out}}(t)$ is within the window, i.e., $I_{\\text{eff}} = \\frac{1}{\\Delta t}\\int I_{n}(t)\\,dt$, where $\\Delta t$ is the time spent by $V_{\\text{out}}(t)$ within the window. Use appropriate handling for crossing events to avoid discretization bias when $V_{\\text{out}}(t)$ enters and leaves the window mid-step.\n- From charge conservation, derive and use an approximate relationship between the propagation delay $t_{p}$ and the effective current $I_{\\text{eff}}$ by reasoning from $Q = C_{L} V$ and $I = dQ/dt$ without introducing any shortcut formulas in the problem statement. Implement this relationship to compute a delay estimate in seconds, and in your final program output report this estimate rounded to increments of $10^{-12}\\,\\mathrm{s}$ for each test case.\n\nAngle units are not relevant; physical units must be consistent with `V` for voltage, `A` for current, `F` for capacitance, and `s` for time. Express all final delay estimates in `s`, rounded to the nearest $10^{-12}\\,\\mathrm{s}$.\n\nUse the following test suite of parameter sets to exercise different facets of the solution. Each test case is a tuple $(C_{L}, V_{\\text{DD}}, V_{\\text{th}}, k_{\\alpha}, \\alpha, k_{\\text{lin}}, S_{\\text{in}})$ with units $\\mathrm{F}$, $\\mathrm{V}$, $\\mathrm{V}$, $\\mathrm{A}\\cdot \\mathrm{V}^{-\\alpha}$, unitless, $\\mathrm{A}\\cdot \\mathrm{V}^{-2}$, and $\\mathrm{s}$ respectively:\n- Case $1$ (general case): $\\big(2.0\\times 10^{-15}, 0.8, 0.2, 1.0\\times 10^{-3}, 1.3, 2.0\\times 10^{-3}, 1.0\\times 10^{-11}\\big)$.\n- Case $2$ (fast input slew boundary): $\\big(2.0\\times 10^{-15}, 0.8, 0.2, 1.0\\times 10^{-3}, 1.3, 2.0\\times 10^{-3}, 1.0\\times 10^{-12}\\big)$.\n- Case $3$ (slow input slew boundary): $\\big(2.0\\times 10^{-15}, 0.8, 0.2, 1.0\\times 10^{-3}, 1.3, 2.0\\times 10^{-3}, 5.0\\times 10^{-11}\\big)$.\n- Case $4$ (large load capacitance edge): $\\big(1.0\\times 10^{-14}, 0.8, 0.2, 1.0\\times 10^{-3}, 1.3, 2.0\\times 10^{-3}, 1.0\\times 10^{-11}\\big)$.\n- Case $5$ (lower threshold voltage variation): $\\big(2.0\\times 10^{-15}, 0.8, 0.15, 1.0\\times 10^{-3}, 1.3, 2.0\\times 10^{-3}, 1.0\\times 10^{-11}\\big)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\big[$result1,result2,result3$\\big]$), where each entry is the estimated propagation delay $t_{p}$ in $\\mathrm{s}$, rounded to the nearest $10^{-12}\\,\\mathrm{s}$, corresponding to the cases listed above in order.",
            "solution": "The problem requires the design and implementation of a numerical procedure to estimate the propagation delay of a logic gate's falling transition. This involves simulating the discharge of a load capacitor through an n-type MOSFET (NMOS) and analyzing the resulting voltage waveform. The solution is constructed from first principles, starting with the fundamental equation for charge conservation and employing a physically-based model for the transistor's behavior.\n\n**1. Foundational Physical Model**\n\nThe core of the transient simulation is the differential equation governing the output node voltage, $V_{\\text{out}}(t)$. The output node is modeled as a load capacitor, $C_{L}$, being discharged by the NMOS transistor. The principle of conservation of charge dictates that the rate of change of charge on the capacitor, $dQ/dt$, is equal to the current flowing out of it. Since $Q(t) = C_{L}V_{\\text{out}}(t)$ and the discharge current is $I_n(t)$, we have:\n$$\nC_{L}\\,\\frac{d V_{\\text{out}}(t)}{d t} = - I_{n}(t)\n$$\nThe initial condition for a falling transition is that the output starts at the supply voltage, $V_{\\text{out}}(0) = V_{\\text{DD}}$.\n\nThe discharge current $I_n(t)$ depends on the state of the NMOS transistor, which is controlled by its gate-to-source voltage, $V_{\\text{GS}}(t)$, and its drain-to-source voltage, $V_{\\text{DS}}(t)$. For this setup, $V_{\\text{GS}}(t)$ is the input ramp voltage $V_{\\text{in}}(t)$, and $V_{\\text{DS}}(t)$ is the output voltage $V_{\\text{out}}(t)$. The input voltage $V_{\\text{in}}(t)$ is a linear ramp defined by its slew time $S_{\\text{in}}$:\n$$\nV_{\\text{in}}(t) = \n\\begin{cases} \n(V_{\\text{DD}}/S_{\\text{in}}) \\cdot t & \\text{if } 0 \\le t < S_{\\text{in}} \\\\\nV_{\\text{DD}} & \\text{if } t \\ge S_{\\text{in}}\n\\end{cases}\n$$\nThe NMOS current $I_n(t)$ is described by a piecewise model based on the device's operating region, determined by $V_{\\text{GS}}(t)$ and $V_{\\text{DS}}(t)$ relative to the threshold voltage $V_{\\text{th}}$:\n- **Cutoff Region:** For $V_{\\text{GS}}(t) \\le V_{\\text{th}}$, the transistor is off, and $I_n(t) = 0$.\n- **Saturation Region:** For $V_{\\text{GS}}(t) > V_{\\text{th}}$ and $V_{\\text{DS}}(t) \\ge V_{\\text{GS}}(t) - V_{\\text{th}}$, the current is modeled by the $\\alpha$-power law, which accounts for velocity saturation effects:\n$$\nI_n(t) = k_{\\alpha} \\left( V_{\\text{GS}}(t) - V_{\\text{th}} \\right)^{\\alpha}\n$$\n- **Triode (Linear) Region:** For $V_{\\text{GS}}(t) > V_{\\text{th}}$ and $0 \\le V_{\\text{DS}}(t) < V_{\\text{GS}}(t) - V_{\\text{th}}$, the current is given by:\n$$\nI_n(t) = k_{\\text{lin}} \\left( (V_{\\text{GS}}(t) - V_{\\text{th}})V_{\\text{DS}}(t) - \\frac{1}{2}V_{\\text{DS}}(t)^2 \\right)\n$$\n\n**2. Numerical Integration**\n\nTo obtain the transient waveform $V_{\\text{out}}(t)$, we solve the ordinary differential equation (ODE) numerically. We employ the explicit Forward Euler method, a simple and stable time-stepping scheme for a sufficiently small time step, $\\Delta t_{\\text{sim}}$. The voltage at step $i+1$ is updated from the value at step $i$ as follows:\n$$\nV_{\\text{out}}(t_{i+1}) = V_{\\text{out}}(t_i) + \\frac{d V_{\\text{out}}}{dt}\\bigg|_{t_i} \\Delta t_{\\text{sim}} = V_{\\text{out}}(t_i) - \\frac{I_n(t_i)}{C_{L}} \\Delta t_{\\text{sim}}\n$$\nwhere $t_i = i \\cdot \\Delta t_{\\text{sim}}$ and $I_n(t_i)$ is calculated using the NMOS model with $V_{\\text{GS}}(t_i)$ and $V_{\\text{DS}}(t_i)=V_{\\text{out}}(t_i)$. The simulation runs from $t=0$ until the output voltage has fully transitioned.\n\n**3. Waveform Analysis and Metric Extraction**\n\nAfter the simulation yields time-series data for $V_{\\text{out}}(t)$ and $I_n(t)$, we analyze the output waveform to extract key metrics. The problem defines an extraction window for $V_{\\text{out}}(t)$ from a high threshold $V_{\\text{high}} = 0.9\\,V_{\\text{DD}}$ to a low threshold $V_{\\text{low}} = 0.1\\,V_{\\text{DD}}$.\n\nTo avoid discretization bias, the precise times at which $V_{\\text{out}}(t)$ crosses these thresholds, denoted $t_{\\text{start}}$ and $t_{\\text{end}}$, are found using linear interpolation. If the simulation time step $i$ is the last step where $V_{\\text{out}}(t_i) > V_{\\text{high}}$, the start time $t_{\\text{start}}$ is found by interpolating between $(t_i, V_{\\text{out}}(t_i))$ and $(t_{i+1}, V_{\\text{out}}(t_{i+1}))$. A similar procedure is used to find $t_{\\text{end}}$. The duration of this fall-time window is $\\Delta t = t_{\\text{end}} - t_{\\text{start}}$.\n\n**4. Effective Current and Propagation Delay Estimation**\n\nThe problem specifies a two-step process for estimating the propagation delay. First, we compute an effective current, $I_{\\text{eff}}$, defined as the time-average of the discharge current $I_n(t)$ over the window $[\\,t_{\\text{start}}, t_{\\text{end}}\\,]$:\n$$\nI_{\\text{eff}} = \\frac{1}{\\Delta t} \\int_{t_{\\text{start}}}^{t_{\\text{end}}} I_n(t) \\,dt\n$$\nThe integral, which represents the total charge removed during the window, is computed numerically using the trapezoidal rule. To ensure accuracy, we construct a specific set of points for integration: the interpolated start and end times, and all the discrete simulation time points that fall between them. The required current values at the interpolated endpoints $I_n(t_{\\text{start}})$ and $I_n(t_{\\text{end}})$ are calculated directly from the NMOS current equations.\n\nSecond, we derive a relationship for the delay. The total charge $\\Delta Q$ removed from the capacitor to cause the voltage to drop from $V_{\\text{high}}$ to $V_{\\text{low}}$ is, by definition, $\\Delta Q = C_{L} (V_{\\text{high}} - V_{\\text{low}}) = C_{L}(0.8\\,V_{\\text{DD}})$. If we approximate the complex, time-varying discharge current $I_n(t)$ with a single constant effective current $I_{\\text{eff}}$, then the time taken to remove this charge is simply $\\Delta t_{\\text{model}} = \\Delta Q / I_{\\text{eff}}$. The problem asks to use this as the propagation delay estimate, $t_p$. Therefore, the estimation formula is:\n$$\nt_p = \\frac{C_L (0.8\\,V_{\\text{DD}})}{I_{\\text{eff}}}\n$$\nThis procedure uses the detailed simulated current waveform to find an effective average value, which is then used in a simplified analytical model to produce a delay estimate.\n\n**5. Algorithmic Implementation**\n\nThe final algorithm processes each test case as follows:\n1. Initialize parameters and set up a time grid for simulation.\n2. Run the iterative time-stepping loop using the Forward Euler method to generate the $V_{\\text{out}}(t)$ and $I_n(t)$ waveforms.\n3. Find the interpolated crossing times $t_{\\text{start}}$ and $t_{\\text{end}}$ for the $0.9\\,V_{\\text{DD}}$ and $0.1\\,V_{\\text{DD}}$ thresholds.\n4. Compute the integrated charge $\\int_{t_{\\text{start}}}^{t_{\\text{end}}} I_n(t) \\,dt$ using the trapezoidal rule on a precisely constructed set of points.\n5. Calculate the effective current $I_{\\text{eff}}$ by dividing the integrated charge by the window duration $\\Delta t = t_{\\text{end}} - t_{\\text{start}}$.\n6. Calculate the final propagation delay estimate $t_p$ using the derived formula.\n7. Round the result to the nearest picosecond ($10^{-12}\\,\\mathrm{s}$) and append it to the list of results.\n8. After processing all cases, format the results into the specified string format.\n\nThis principled approach ensures that the solution is physically grounded, numerically sound, and directly addresses all requirements of the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_nmos_current(v_gs, v_ds, v_th, k_alpha, alpha, k_lin):\n    \"\"\"\n    Calculates the NMOS drain current based on a piecewise model.\n    \n    Args:\n        v_gs (float): Gate-to-source voltage.\n        v_ds (float): Drain-to-source voltage.\n        v_th (float): Threshold voltage.\n        k_alpha (float): Saturation current coefficient.\n        alpha (float): Alpha-power law exponent.\n        k_lin (float): Linear/triode region coefficient.\n\n    Returns:\n        float: The discharge current I_n.\n    \"\"\"\n    if v_gs = v_th:\n        return 0.0\n    \n    # Saturation region condition\n    if v_ds >= v_gs - v_th:\n        return k_alpha * (v_gs - v_th)**alpha\n    # Triode (linear) region condition\n    else:\n        current = k_lin * ((v_gs - v_th) * v_ds - 0.5 * v_ds**2)\n        return max(0.0, current)\n\ndef process_case(C_L, V_DD, V_th, k_alpha, alpha, k_lin, S_in):\n    \"\"\"\n    Simulates a single test case and computes the estimated propagation delay.\n\n    Args:\n        C_L, V_DD, V_th, k_alpha, alpha, k_lin, S_in: Physical and model parameters for the case.\n\n    Returns:\n        float: The estimated propagation delay in seconds, rounded to the nearest 1e-12 s.\n    \"\"\"\n    # Simulation parameters\n    dt_sim = 1e-15      # Time step in seconds (1 femtosecond)\n    t_max_sim = 500e-12 # Maximum simulation time in seconds (500 picoseconds)\n    num_steps = int(t_max_sim / dt_sim)\n    \n    # Arrays to store time-domain waveforms\n    t_series = np.linspace(0, t_max_sim, num_steps + 1)\n    v_out_series = np.zeros(num_steps + 1)\n    i_n_series = np.zeros(num_steps + 1)\n    \n    # Initial Condition\n    v_out_series[0] = V_DD\n    \n    # Forward Euler time-stepping simulation\n    for i in range(num_steps):\n        current_t = t_series[i]\n        current_v_out = v_out_series[i]\n        \n        # Determine input voltage V_in (which is V_gs for the NMOS)\n        v_gs = (V_DD / S_in) * current_t if current_t  S_in else V_DD\n        \n        # V_ds for the NMOS is the output voltage\n        v_ds = current_v_out\n        \n        # Calculate discharge current for the current step\n        current_i_n = get_nmos_current(v_gs, v_ds, V_th, k_alpha, alpha, k_lin)\n        i_n_series[i] = current_i_n\n        \n        # Update output voltage for the next step\n        dv_out = -(current_i_n / C_L) * dt_sim\n        v_out_series[i+1] = current_v_out + dv_out\n\n    # Calculate final current value at the end of the simulation\n    v_gs_final = V_DD\n    i_n_series[-1] = get_nmos_current(v_gs_final, v_out_series[-1], V_th, k_alpha, alpha, k_lin)\n    \n    # Post-simulation analysis\n    v_high = 0.9 * V_DD\n    v_low = 0.1 * V_DD\n    \n    # Find crossing times with linear interpolation for accuracy\n    try:\n        # Find index right before the V_high crossing\n        idx_start_cross = np.where(v_out_series = v_high)[0][0] - 1\n        # Find index right before the V_low crossing\n        idx_end_cross = np.where(v_out_series = v_low)[0][0] - 1\n    except IndexError:\n        # This occurs if the simulation doesn't complete the transition in t_max_sim\n        return np.nan\n\n    # Interpolate for t_start (crossing V_high)\n    v1_start, v2_start = v_out_series[idx_start_cross], v_out_series[idx_start_cross + 1]\n    t1_start, t2_start = t_series[idx_start_cross], t_series[idx_start_cross + 1]\n    t_start = t1_start + dt_sim * (v1_start - v_high) / (v1_start - v2_start)\n    \n    # Interpolate for t_end (crossing V_low)\n    v1_end, v2_end = v_out_series[idx_end_cross], v_out_series[idx_end_cross + 1]\n    t1_end, t2_end = t_series[idx_end_cross], t_series[idx_end_cross + 1]\n    t_end = t1_end + dt_sim * (v1_end - v_low) / (v1_end - v2_end)\n    \n    window_duration = t_end - t_start\n    if window_duration = 0: return np.nan\n    \n    # Calculate effective current by numerically integrating I_n(t) from t_start to t_end\n    # First, calculate I_n at the exact start and end points\n    v_gs_at_start = (V_DD / S_in) * t_start if t_start  S_in else V_DD\n    i_n_at_start = get_nmos_current(v_gs_at_start, v_high, V_th, k_alpha, alpha, k_lin)\n    \n    v_gs_at_end = (V_DD / S_in) * t_end if t_end  S_in else V_DD\n    i_n_at_end = get_nmos_current(v_gs_at_end, v_low, V_th, k_alpha, alpha, k_lin)\n    \n    # Prepare points for precise trapezoidal integration\n    # Handle the case where the whole window is within a single time step\n    if idx_start_cross == idx_end_cross:\n        t_integration_points = np.array([t_start, t_end])\n        i_n_integration_points = np.array([i_n_at_start, i_n_at_end])\n    else:\n        t_integration_points = np.concatenate([\n            [t_start],\n            t_series[idx_start_cross + 1 : idx_end_cross + 1],\n            [t_end]\n        ])\n        i_n_integration_points = np.concatenate([\n            [i_n_at_start],\n            i_n_series[idx_start_cross + 1 : idx_end_cross + 1],\n            [i_n_at_end]\n        ])\n\n    total_discharged_charge = np.trapz(i_n_integration_points, x=t_integration_points)\n    i_eff = total_discharged_charge / window_duration\n    \n    if i_eff = 0: return np.nan\n\n    # Estimate propagation delay using the derived formula\n    delta_q_analytical = C_L * 0.8 * V_DD\n    t_p_estimate = delta_q_analytical / i_eff\n    \n    # Round to the nearest picosecond (1e-12 s)\n    t_p_rounded = np.round(t_p_estimate * 1e12) / 1e12\n    \n    return t_p_rounded\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Test cases: (C_L, V_DD, V_th, k_alpha, alpha, k_lin, S_in)\n    test_cases = [\n        (2.0e-15, 0.8, 0.2, 1.0e-3, 1.3, 2.0e-3, 1.0e-11),  # Case 1: General\n        (2.0e-15, 0.8, 0.2, 1.0e-3, 1.3, 2.0e-3, 1.0e-12),  # Case 2: Fast input\n        (2.0e-15, 0.8, 0.2, 1.0e-3, 1.3, 2.0e-3, 5.0e-11),  # Case 3: Slow input\n        (1.0e-14, 0.8, 0.2, 1.0e-3, 1.3, 2.0e-3, 1.0e-11),  # Case 4: Large C_L\n        (2.0e-15, 0.8, 0.15, 1.0e-3, 1.3, 2.0e-3, 1.0e-11), # Case 5: Low V_th\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(*case)\n        results.append(str(result))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}