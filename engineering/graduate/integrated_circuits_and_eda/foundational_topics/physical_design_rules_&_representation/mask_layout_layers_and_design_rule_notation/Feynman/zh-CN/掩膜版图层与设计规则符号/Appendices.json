{
    "hands_on_practices": [
        {
            "introduction": "本练习将抽象的设计规则与其在制造过程中的物理来源联系起来。通过考虑现实世界中的工艺变化，如套刻偏移和刻蚀偏差，你将学习如何通过计算最小金属包围来确保电路的电气连续性 。这项实践强调了最差情况分析，这是确保芯片良率和可靠性的关键工程方法。",
            "id": "4281460",
            "problem": "在先进的集成电路电子设计自动化（EDA）中，掩模版图层会受到套准和刻蚀工艺变化的影响，这些变化必须在设计规则表示法中加以考虑，以保证电学连续性。考虑一个连接两个金属层的过孔层。在过孔掩模版上，该过孔被绘制为一个水平边长为 $V_{x}$、垂直边长为 $V_{y}$ 的矩形。用于包围该过孔的金属多边形在绘制时，其每条边到过孔对应边的距离即为金属包围量。由于工艺变化，会发生以下效应：\n\n1. 过孔层与金属层之间的套准偏差会导致过孔中心相对于金属多边形发生相对位移，水平方向最大可达 $O_{x}$，垂直方向最大可达 $O_{y}$。\n2. 金属层的刻蚀偏差会导致金属多边形边缘向内收缩，每条垂直边缘收缩 $b_{m,x}$，每条水平边缘收缩 $b_{m,y}$。\n3. 过孔开口的刻蚀偏差会改变过孔的边长。最终的过孔边长变为 $V_{x}^{\\prime} = V_{x} + \\beta_{x} V_{x}$ 和 $V_{y}^{\\prime} = V_{y} + \\beta_{y} V_{y}$，其中 $\\beta_{x}$ 和 $\\beta_{y}$ 是分数偏差（正值表示扩大，负值表示收缩）。\n\n在这些效应的影响下，保证电学连续性的条件是，在套准和刻蚀偏差的最坏情况组合下，最终的过孔开口完全位于最终的金属多边形内部。将左、右、上、下四个方向上绘制的金属包围量分别定义为 $E_{\\text{left}}$、$E_{\\text{right}}$、$E_{\\text{top}}$ 和 $E_{\\text{bottom}}$，其测量基准为从绘制的过孔边缘到绘制的金属边缘。假设最坏情况下的未对准使过孔边缘尽可能地靠近各对应的金属边缘，且工艺偏差会减小可用裕度。\n\n给定以下科学上真实且自洽的参数：\n- 过孔绘制尺寸：$V_{x} = 36\\,\\mathrm{nm}$，$V_{y} = 28\\,\\mathrm{nm}$。\n- 套准预算：$O_{x} = 3.5\\,\\mathrm{nm}$，$O_{y} = 2.8\\,\\mathrm{nm}$。\n- 金属刻蚀偏差（每边向内）：$b_{m,x} = 4.2\\,\\mathrm{nm}$，$b_{m,y} = 5.1\\,\\mathrm{nm}$。\n- 过孔分数刻蚀偏差：$\\beta_{x} = 0.02$，$\\beta_{y} = 0.01$。\n\n计算在最坏情况的套准和刻蚀偏差下，为保证工艺处理后过孔仍被金属完全覆盖，每条边所需的最小绘制金属包围量 $E_{\\text{left}}$、$E_{\\text{right}}$、$E_{\\text{top}}$ 和 $E_{\\text{bottom}}$。请用纳米表示最终的包围量值。无需四舍五入；请提供由给定参数所导出的精确值。",
            "solution": "该问题要求计算在最坏工艺变化情况下，为确保电学连续性，过孔周围所需的最小绘制金属包围量（$E_{\\text{left}}$、$E_{\\text{right}}$、$E_{\\text{top}}$、$E_{\\text{bottom}}$）。连续性的条件是，工艺处理后的最终过孔多边形必须完全位于工艺处理后的最终金属多边形内部。这可以表述为一组在套准误差和刻蚀偏差的最不利组合下必须成立的几何约束。\n\n让我们建立一个坐标系，其原点 $(0, 0)$ 位于*绘制*的过孔中心。该过孔是一个与坐标轴对齐的矩形。\n\n*绘制*的过孔边缘位于：\n- 左边缘：$x = -\\frac{V_x}{2}$\n- 右边缘：$x = +\\frac{V_x}{2}$\n- 下边缘：$y = -\\frac{V_y}{2}$\n- 上边缘：$y = +\\frac{V_y}{2}$\n\n包围过孔的*绘制*金属多边形边缘位于：\n- 左边缘：$x = -\\frac{V_x}{2} - E_{\\text{left}}$\n- 右边缘：$x = +\\frac{V_x}{2} + E_{\\text{right}}$\n- 下边缘：$y = -\\frac{V_y}{2} - E_{\\text{bottom}}$\n- 上边缘：$y = +\\frac{V_y}{2} + E_{\\text{top}}$\n\n接下来，我们对指定的工艺变化对过孔和金属最终几何形状的影响进行建模。\n\n1.  **最终过孔几何形状**：\n    - 过孔尺寸因分数刻蚀偏差而改变。最终边长 $V_x'$ 和 $V_y'$ 为：\n      $$V_x' = V_x + \\beta_x V_x = V_x(1 + \\beta_x)$$\n      $$V_y' = V_y + \\beta_y V_y = V_y(1 + \\beta_y)$$\n      由于给定的 $\\beta_x = 0.02$ 和 $\\beta_y = 0.01$ 均为正值，过孔会扩大。这种扩大将过孔边缘向外推，从而减小了裕度。\n    - 过孔中心因套准偏差 $(\\delta_x, \\delta_y)$ 而发生位移，其中最大位移为 $|\\delta_x| \\le O_x$ 和 $|\\delta_y| \\le O_y$。\n    - 中心位于 $(\\delta_x, \\delta_y)$ 的*最终*过孔的边缘位置如下：\n      - 左边缘，$x_{v, \\text{left}} = \\delta_x - \\frac{V_x'}{2}$\n      - 右边缘，$x_{v, \\text{right}} = \\delta_x + \\frac{V_x'}{2}$\n      - 下边缘，$y_{v, \\text{bottom}} = \\delta_y - \\frac{V_y'}{2}$\n      - 上边缘，$y_{v, \\text{top}} = \\delta_y + \\frac{V_y'}{2}$\n\n2.  **最终金属几何形状**：\n    - 金属边缘会经历向内收缩（刻蚀偏差）。垂直边缘的偏差为 $b_{m,x}$，水平边缘的偏差为 $b_{m,y}$。\n    - *最终*金属多边形的边缘位置如下：\n      - 左边缘，$x_{m, \\text{left}} = \\left(-\\frac{V_x}{2} - E_{\\text{left}}\\right) + b_{m,x}$\n      - 右边缘，$x_{m, \\text{right}} = \\left(+\\frac{V_x}{2} + E_{\\text{right}}\\right) - b_{m,x}$\n      - 下边缘，$y_{m, \\text{bottom}} = \\left(-\\frac{V_y}{2} - E_{\\text{bottom}}\\right) + b_{m,y}$\n      - 上边缘，$y_{m, \\text{top}} = \\left(+\\frac{V_y}{2} + E_{\\text{top}}\\right) - b_{m,y}$\n\n完全包围的条件是，对于每一边，最终的过孔边缘不得超出相应的最终金属边缘。这产生了四个不等式，它们必须在给定预算内的所有可能的工艺变化下都成立。\n\n**左侧包围量 $E_{\\text{left}}$ 的分析**：\n包含条件为 $x_{v, \\text{left}} \\ge x_{m, \\text{left}}$。\n$$\\delta_x - \\frac{V_x'}{2} \\ge -\\frac{V_x}{2} - E_{\\text{left}} + b_{m,x}$$\n我们重新整理以求解所需的包围量 $E_{\\text{left}}$：\n$$E_{\\text{left}} \\ge -\\frac{V_x}{2} + b_{m,x} - \\delta_x + \\frac{V_x'}{2}$$\n为找到所需的最小 $E_{\\text{left}}$，我们必须考虑使不等式右侧最大化的最坏情况。这种情况发生在：\n- 过孔尽可能向左移动：$\\delta_x = -O_x$。\n- 由于刻蚀偏差，过孔扩大（因为 $\\beta_x > 0$）：$V_x' = V_x(1 + \\beta_x)$。\n代入这些最坏情况的值：\n$$E_{\\text{left}} \\ge -\\frac{V_x}{2} + b_{m,x} - (-O_x) + \\frac{V_x(1 + \\beta_x)}{2}$$\n$$E_{\\text{left}} \\ge -\\frac{V_x}{2} + b_{m,x} + O_x + \\frac{V_x}{2} + \\frac{\\beta_x V_x}{2}$$\n$$E_{\\text{left}} \\ge O_x + b_{m,x} + \\frac{\\beta_x V_x}{2}$$\n因此，左侧所需的最小包围量为 $E_{\\text{left, min}} = O_x + b_{m,x} + \\frac{\\beta_x V_x}{2}$。\n\n**右侧包围量 $E_{\\text{right}}$ 的分析**：\n包含条件为 $x_{v, \\text{right}} \\le x_{m, \\text{right}}$。\n$$\\delta_x + \\frac{V_x'}{2} \\le \\frac{V_x}{2} + E_{\\text{right}} - b_{m,x}$$\n$$E_{\\text{right}} \\ge \\delta_x + \\frac{V_x'}{2} - \\frac{V_x}{2} + b_{m,x}$$\n最坏情况发生在过孔向右移动时：$\\delta_x = +O_x$。\n$$E_{\\text{right}} \\ge O_x + \\frac{V_x(1 + \\beta_x)}{2} - \\frac{V_x}{2} + b_{m,x}$$\n$$E_{\\text{right}} \\ge O_x + \\frac{\\beta_x V_x}{2} + b_{m,x}$$\n所需的最小包围量为 $E_{\\text{right, min}} = O_x + b_{m,x} + \\frac{\\beta_x V_x}{2}$。\n\n根据水平方向上工艺效应的对称性，有 $E_{\\text{left, min}} = E_{\\text{right, min}}$。\n\n**顶部包围量 $E_{\\text{top}}$ 的分析**：\n包含条件为 $y_{v, \\text{top}} \\le y_{m, \\text{top}}$。遵循类似的推导：\n$$E_{\\text{top}} \\ge \\delta_y + \\frac{V_y'}{2} - \\frac{V_y}{2} + b_{m,y}$$\n最坏情况是过孔向上移动：$\\delta_y = +O_y$。\n$$E_{\\text{top}} \\ge O_y + \\frac{V_y(1 + \\beta_y)}{2} - \\frac{V_y}{2} + b_{m,y}$$\n所需的最小包围量为 $E_{\\text{top, min}} = O_y + b_{m,y} + \\frac{\\beta_y V_y}{2}$。\n\n**底部包围量 $E_{\\text{bottom}}$ 的分析**：\n包含条件为 $y_{v, \\text{bottom}} \\ge y_{m, \\text{bottom}}$。遵循类似的推导：\n$$E_{\\text{bottom}} \\ge -\\frac{V_y}{2} + b_{m,y} - \\delta_y + \\frac{V_y'}{2}$$\n最坏情况是过孔向下移动：$\\delta_y = -O_y$。\n$$E_{\\text{bottom}} \\ge -\\frac{V_y}{2} + b_{m,y} - (-O_y) + \\frac{V_y(1 + \\beta_y)}{2}$$\n所需的最小包围量为 $E_{\\text{bottom, min}} = O_y + b_{m,y} + \\frac{\\beta_y V_y}{2}$。\n\n根据垂直方向上的对称性，有 $E_{\\text{top, min}} = E_{\\text{bottom, min}}$。\n\n现在我们代入给定的数值：\n- $V_x = 36\\,\\mathrm{nm}$，$O_x = 3.5\\,\\mathrm{nm}$，$b_{m,x} = 4.2\\,\\mathrm{nm}$，$\\beta_x = 0.02$。\n- $V_y = 28\\,\\mathrm{nm}$，$O_y = 2.8\\,\\mathrm{nm}$，$b_{m,y} = 5.1\\,\\mathrm{nm}$，$\\beta_y = 0.01$。\n\n最小水平包围量：\n$$E_{\\text{left, min}} = E_{\\text{right, min}} = 3.5 + 4.2 + \\frac{0.02 \\times 36}{2}$$\n$$E_{\\text{left, min}} = E_{\\text{right, min}} = 7.7 + \\frac{0.72}{2}$$\n$$E_{\\text{left, min}} = E_{\\text{right, min}} = 7.7 + 0.36 = 8.06\\,\\mathrm{nm}$$\n\n最小垂直包围量：\n$$E_{\\text{top, min}} = E_{\\text{bottom, min}} = 2.8 + 5.1 + \\frac{0.01 \\times 28}{2}$$\n$$E_{\\text{top, min}} = E_{\\text{bottom, min}} = 7.9 + \\frac{0.28}{2}$$\n$$E_{\\text{top, min}} = E_{\\text{bottom, min}} = 7.9 + 0.14 = 8.04\\,\\mathrm{nm}$$\n\n每条边所需的最小绘制金属包围量是：\n- $E_{\\text{left}} = 8.06\\,\\mathrm{nm}$\n- $E_{\\text{right}} = 8.06\\,\\mathrm{nm}$\n- $E_{\\text{top}} = 8.04\\,\\mathrm{nm}$\n- $E_{\\text{bottom}} = 8.04\\,\\mathrm{nm}$",
            "answer": "$$\\boxed{\\begin{pmatrix}8.06  8.06  8.04  8.04\\end{pmatrix}}$$"
        },
        {
            "introduction": "在掌握了单个特征的稳健性设计后，我们进入更复杂的领域：验证不同版图对象之间的规则。本练习介绍了一种强大的计算方法，该方法在现代设计规则检查（DRC）工具中广泛用于高效检查邻近效应违规 。你将把形态学运算的抽象数学概念与基于网格的实用算法联系起来，从而深入理解DRC引擎的核心原理。",
            "id": "4281470",
            "problem": "给定两个集成电路掩模版图层，它们在笛卡尔平面中被建模为平面集。令 $A \\subset \\mathbb{R}^2$ 和 $B \\subset \\mathbb{R}^2$ 表示这两个图层所占据的区域。其基本基础是欧几里得度量，其中对于 $x \\in \\mathbb{R}^2$ 和集合 $S \\subset \\mathbb{R}^2$，最短欧几里得距离定义为 $\\mathrm{dist}(x,S) = \\inf\\{\\lVert x - y \\rVert_2 : y \\in S\\}$。一条基于邻近性的设计规则可以使用与半径为 $d$ 的闭圆盘（表示为 $D_d = \\{ z \\in \\mathbb{R}^2 : \\lVert z \\rVert_2 \\le d \\}$）的闵可夫斯基和以及形态学膨胀 $B \\oplus D_d = \\{ b + z : b \\in B, z \\in D_d \\} = \\{ x \\in \\mathbb{R}^2 : \\mathrm{dist}(x,B) \\le d \\}$ 来表示。\n\n构造一个以 $A$、$B$ 和 $d$ 为参数的布尔表达式，用于检测图层 $A$ 在欧几里得距离 $d$ 内与图层 $B$ 重叠的位置。从上述定义出发，推导该表达式。然后，概述一种算法，通过以均匀分辨率对平面进行采样，在离散化网格上计算检测掩模。该算法必须可在不使用多边形裁剪的情况下实现，仅使用二元掩模和欧几里得距离变换。距离必须以微米 (µm) 为单位进行处理。网格采样分辨率必须为 $r = 0.1$ 微米/像素。\n\n您的程序必须实现该算法，并针对以下参数化案例的测试套件评估检测条件。在每个案例中，计算域为正方形 $[0,L] \\times [0,L]$，其中 $L = 20$ 微米，采样分辨率为 $r = 0.1$ 微米/像素。矩形是轴对齐的，并由其左下角和右上角的坐标（以微米为单位）指定。欧几里得邻近阈值 $d$ 以微米为单位给出。对于每个案例，报告一个布尔值，指示是否存在 $A$ 中的任何点位于 $B$ 的距离 $d$ 之内，即检测掩模是否含有任何真值元素。\n\n测试套件：\n- 案例1（正常路径）：$A$ 是角点为 $(3,3)$ 和 $(8,7)$ 的矩形，$B$ 是角点为 $(10,3)$ 和 $(14,7)$ 的矩形，$d = 2.5$。\n- 案例2（零距离下的重叠规则边界）：$A$ 是角点为 $(12,4)$ 和 $(13,6)$ 的矩形，$B$ 是角点为 $(10,3)$ 和 $(14,7)$ 的矩形，$d = 0$。\n- 案例3（显著边缘情况：远距离分离）：$A$ 是角点为 $(0,0)$ 和 $(2,2)$ 的矩形，$B$ 是角点为 $(10,3)$ 和 $(14,7)$ 的矩形，$d = 1.0$。\n- 案例4（对角线邻近）：$A$ 是角点为 $(8,7.6)$ 和 $(11,8.0)$ 的矩形，$B$ 是角点为 $(10,3)$ 和 $(14,7)$ 的矩形，$d = 0.6$。\n\n要求的输出格式：您的程序应生成单行输出，其中包含一个由方括号括起的逗号分隔列表（例如，\"[result1,result2,result3,result4]\"），其中每个结果是对应案例的布尔值，按给定顺序排列。",
            "solution": "我们使用欧几里得几何和与电子设计自动化（EDA）相关的集合运算中的定义，来形式化两个掩模版图层之间的邻近性检测。关键对象是代表图层的两个集合 $A \\subset \\mathbb{R}^2$ 和 $B \\subset \\mathbb{R}^2$，以及对于点 $x \\in \\mathbb{R}^2$ 和集合 $S \\subset \\mathbb{R}^2$ 定义的欧几里得距离 $\\mathrm{dist}(x,S) = \\inf\\{\\lVert x - y \\rVert_2 : y \\in S\\}$。\n\n从基本定义出发，以原点为中心、半径为 $d$ 的闭圆盘为 $D_d = \\{ z \\in \\mathbb{R}^2 : \\lVert z \\rVert_2 \\le d \\}$。集合 $B$ 与 $D_d$ 的闵可夫斯基和为 $B \\oplus D_d = \\{ b + z : b \\in B, z \\in D_d \\}$。一个经过充分验证的事实是 $B \\oplus D_d = \\{ x \\in \\mathbb{R}^2 : \\mathrm{dist}(x,B) \\le d \\}$，这意味着将 $B$ 用半径为 $d$ 的圆盘进行膨胀，得到的是与 $B$ 的距离至多为 $d$ 的所有点的集合。\n\n我们寻求一个布尔表达式，来指示 $A$ 在距离 $d$ 内与 $B$ 重叠的位置。因此，检测掩模 $M$ 推导如下：\n$$\nM = A \\cap (B \\oplus D_d) = \\{ x \\in \\mathbb{R}^2 : x \\in A \\ \\text{and} \\ \\mathrm{dist}(x,B) \\le d \\}.\n$$\n等价地，对于一个当 $x \\in S$ 时为 $1$ 否则为 $0$ 的指示函数 $I_S(x)$，采用逐点布尔表示法，我们有\n$$\nI_M(x) = I_A(x) \\land \\big( \\mathrm{dist}(x,B) \\le d \\big).\n$$\n对于给定的 $A$、$B$ 和 $d$，全局检测结果是判断 $M$ 是否为非空，即 \n$$\n\\text{exists\\_proximity}(A,B,d) = \\big( M \\ne \\emptyset \\big).\n$$\n这就是所求的布尔条件。\n\n为了在适合数值实现的离散化网格上计算它，我们以每像素 $r$ 微米的分辨率在均匀格点上对平面进行采样。设计算域为 $[0,L] \\times [0,L]$，其中 $L = 20$ 且 $r = 0.1$，从而在每个轴上产生一个包含 $N = L / r$ 个样本的网格。我们将 $A$ 和 $B$ 表示为此网格上的二元掩模，其中当且仅当像素中心位于相应形状内部时，该像素为真。为了数值上实现 $\\mathrm{dist}(x,B)$，我们使用 $B$ 的补集的欧几里得距离变换：\n$$\n\\mathrm{DT}(x) = \\mathrm{dist}_{\\text{grid}}(x,B) \\approx \\mathrm{dist}(x,B),\n$$\n对于每个像素中心 $x$，它会计算到属于 $B$ 的最近像素的欧几里得距离。在实践中，对二元数组进行的欧几里得距离变换返回以像素为单位的距离，因此我们乘以 $r$ 将其转换为微米。然后通过对此距离进行阈值处理来实现类似膨胀的测试：\n$$\nI_{\\text{band}}(x) = \\big( \\mathrm{DT}(x) \\le d \\big).\n$$\n检测掩模通过逐点计算得出：\n$$\nI_M(x) = I_A(x) \\land I_{\\text{band}}(x),\n$$\n全局结果为：\n$$\n\\text{exists\\_proximity}(A,B,d) = \\left( \\sum_x I_M(x) \\ge 1 \\right).\n$$\n\n算法概述：\n1. 选择网格分辨率 $r = 0.1$ 微米/像素和域大小 $L = 20$ 微米，形成每轴 $N = L/r$ 个样本的网格。对于整数 $i,j$，像素中心位于坐标 $\\left( (i + \\tfrac{1}{2}) r, (j + \\tfrac{1}{2}) r \\right)$。\n2. 通过将指定几何形状内的每个像素中心标记为真，将图层 $A$ 栅格化为二元掩模 $A_{\\text{mask}}$。\n3. 类似地，将图层 $B$ 栅格化为二元掩模 $B_{\\text{mask}}$。\n4. 对 $B_{\\text{mask}}$ 的补集计算欧几里得距离变换，即以像素为单位的 $\\mathrm{DT} = \\text{distance\\_transform\\_edt}(\\lnot B_{\\text{mask}})$，并通过 $\\mathrm{DT}_\\mu = r \\cdot \\mathrm{DT}$ 转换为微米。\n5. 对距离图进行阈值处理以形成带状掩模 $I_{\\text{band}}$，其中如果 $\\mathrm{DT}_\\mu(x) \\le d$，则 $I_{\\text{band}}(x)$ 为真。\n6. 形成检测掩模 $M_{\\text{mask}} = A_{\\text{mask}} \\land I_{\\text{band}}$，如果其中任何元素为真，则计算布尔结果为真。\n7. 对每个测试案例及其指定的 $A$、$B$ 和 $d$ 重复此过程。\n\n边缘情况和边界条件：\n- 当 $d = 0$ 时，检测简化为测试 $A$ 和 $B$ 是否直接重叠，即 $A \\cap B \\ne \\emptyset$。\n- 对于严格大于 $d$ 的间距，检测掩模将为空。\n- 由于离散化，距离是在像素中心评估的；使用 $r = 0.1$ 微米可以使近似误差相对于测试套件中选择的距离保持较小。\n\n程序实现了上述算法，并按顺序输出一行包含四个指定案例的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Execution environment: Python 3.12, numpy 1.23.5, scipy 1.11.4\nimport numpy as np\nfrom scipy.ndimage import distance_transform_edt\n\ndef rasterize_rectangle(mask_shape, rect, r, L):\n    \"\"\"\n    Rasterize an axis-aligned rectangle into a boolean mask on a grid.\n    mask_shape: (Ny, Nx) tuple for the grid.\n    rect: (x0, y0, x1, y1) in micrometers.\n    r: grid resolution in micrometers per pixel.\n    L: domain size in micrometers (assumed square [0, L] x [0, L]).\n    Returns: boolean array of shape mask_shape with True where the rectangle covers pixel centers.\n    \"\"\"\n    Ny, Nx = mask_shape\n    # Pixel center coordinates\n    xs = (np.arange(Nx) + 0.5) * r\n    ys = (np.arange(Ny) + 0.5) * r\n    X, Y = np.meshgrid(xs, ys)\n\n    x0, y0, x1, y1 = rect\n    # Clamp rectangle to domain to avoid out-of-bounds artifacts\n    x0c = max(0.0, min(L, x0))\n    y0c = max(0.0, min(L, y0))\n    x1c = max(0.0, min(L, x1))\n    y1c = max(0.0, min(L, y1))\n\n    # Mask of pixel centers inside the rectangle\n    return (X >= x0c) & (X < x1c) & (Y >= y0c) & (Y < y1c)\n\ndef detect_proximity_boolean(A_mask, B_mask, d_um, r):\n    \"\"\"\n    Compute whether any point in A lies within Euclidean distance d_um of B.\n    A_mask, B_mask: boolean arrays on the same grid (True where layer is present).\n    d_um: distance threshold in micrometers.\n    r: grid resolution (micrometers per pixel).\n    Returns: boolean\n    \"\"\"\n    # Distance transform of complement of B: each pixel gets distance to nearest B pixel\n    dt_pixels = distance_transform_edt(~B_mask)\n    dt_um = dt_pixels * r\n    band = dt_um <= d_um\n    M = A_mask & band\n    return bool(M.any())\n\ndef solve():\n    # Grid and domain parameters\n    L_um = 20.0         # domain size in micrometers\n    r_um = 0.1          # resolution in micrometers per pixel\n    Nx = int(round(L_um / r_um))\n    Ny = Nx\n    mask_shape = (Ny, Nx)\n\n    # Define test cases: (A_rect, B_rect, d_um)\n    test_cases = [\n        # Case 1: A near B, d large enough -> True\n        ((3.0, 3.0, 8.0, 7.0), (10.0, 3.0, 14.0, 7.0), 2.5),\n        # Case 2: d = 0, A overlaps B -> True\n        ((12.0, 4.0, 13.0, 6.0), (10.0, 3.0, 14.0, 7.0), 0.0),\n        # Case 3: A far from B, d too small -> False\n        ((0.0, 0.0, 2.0, 2.0), (10.0, 3.0, 14.0, 7.0), 1.0),\n        # Case 4: Diagonal proximity, d sufficient -> True\n        ((8.0, 7.6, 11.0, 8.0), (10.0, 3.0, 14.0, 7.0), 0.6),\n    ]\n\n    results = []\n    for A_rect, B_rect, d_um in test_cases:\n        A_mask = rasterize_rectangle(mask_shape, A_rect, r_um, L_um)\n        B_mask = rasterize_rectangle(mask_shape, B_rect, r_um, L_um)\n        result = detect_proximity_boolean(A_mask, B_mask, d_um, r_um)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Booleans will print as True/False; join them into a single list string.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本节的高级实践将挑战版图设计中的一个常见难题：解决相互作用甚至相互矛盾的设计规则网络。本练习展示了如何运用数学优化，特别是线性规划（Linear Programming），来系统性地寻找一个“全局最优”的修复方案 。这标志着我们从简单的违规检查，迈向了更高级的自动化版图校正技术。",
            "id": "4281520",
            "problem": "考虑在电子设计自动化 (EDA) 中，验证和修复单个金属层及其相关过孔层上特征的交互式掩膜版图规则。使用以下基本依据：实数线上的欧几里得几何、标准不等式约束和线性规划 (LP) 可行性。第一金属层（表示为 $M1$）上的掩膜版图特征表示为沿 $x$ 轴的一维区间，对于特征 $i$，其左右边缘坐标分别为 $L_i$ 和 $R_i$，其中 $i \\in \\{0,1,\\dots,n-1\\}$ 且 $L_i < R_i$。校正操作是沿 $x$ 轴的平移，位移量为 $\\delta_i$，产生新的边缘 $L_i + \\delta_i$ 和 $R_i + \\delta_i$。设 $S_{\\min}$ 表示连续特征之间的最小间距要求，设 $E_k$ 表示过孔 $k$ 被其关联的 $M1$ 特征包围的最小包围要求。每次位移都受最大移动预算的限制，因此 $|\\delta_i| \\le D_i$。\n\n有序对 $(i,j)$（其中 $i<j$）之间的间距约束表示为 $(R_i + \\delta_i) + S_{\\min} \\le L_j + \\delta_j$。位于 $M1$ 特征 $i$ 内坐标为 $v_k$ 处的过孔 $k$ 的包围约束表示为 $L_i + \\delta_i \\le v_k - E_k$ 且 $R_i + \\delta_i \\ge v_k + E_k$。目标是找到一组位移 $\\{\\delta_i\\}$，使得最小化总绝对移动量 $\\sum_i |\\delta_i|$，同时满足所有间距、包围和移动预算约束。\n\n通过构建一个线性规划 (LP) 来形式化该问题。通过引入辅助变量 $t_i \\ge |\\delta_i|$ 将目标函数线性化。您的程序必须实现该 LP 问题的求解器，并针对以下参数化案例的测试套件计算最小总绝对移动量。如果任何案例无解（即不可行），则该案例的输出应为 -1.0。\n\n测试套件：\n- 案例 A：3 个特征，2 个间距约束，1 个过孔，可行解。特征：$[(0,2), (2.7,4.7), (7.5,9.5)]$。间距对：$[(0,1), (1,2)]$，$S_{\\min}=1$。过孔：$[(1, 3.3, 0.3)]$。移动预算：$[1, 1, 1]$。\n- 案例 B：2 个特征，1 个间距约束，1 个过孔，不可行。特征：$[(0,2), (3,5)]$。间距对：$[(0,1)]$，$S_{\\min}=1$。过孔：$[(1, 3.8, 0.5)]$。移动预算：$[0.5, 0.5]$。\n- 案例 C：与案例 A 相同，但过孔包围要求更高，使得其不可行。特征：$[(0,2), (2.7,4.7), (7.5,9.5)]$。间距对：$[(0,1), (1,2)]$，$S_{\\min}=1$。过孔：$[(1, 3.3, 0.5)]$。移动预算：$[1, 1, 1]$。\n- 案例 D：4 个特征，多个约束，可行解。特征：$[(0,1.8), (2.5,4.0), (4.7,6.0), (6.6,8.0)]$。间距对：$[(0,1), (1,2), (2,3)]$，$S_{\\min}=0.8$。过孔：$[(1, 2.9, 0.4), (2, 5.8, 0.05), (3, 6.9, 0.2)]$。移动预算：$[0.4, 0.5, 0.5, 0.5]$。\n\n要求的输出格式：您的程序应生成单行输出，其中包含一个由方括号括起的逗号分隔列表（例如，“[result1,result2,result3,result4]”），其中每个结果是对应案例的最小总移动量，格式化为浮点数，保留一位小数。",
            "solution": "用户提供了一个问题，要求通过构建并求解一个线性规划 (LP) 来验证和修复掩膜版图设计规则。任务是计算版图特征的最小总绝对移动量，以满足所有的间距、包围和移动预算约束。\n\n### 步骤 1：问题验证\n\n首先根据既定标准对问题陈述进行验证。\n\n#### 步骤 1.1：提取已知条件\n\n- **特征**：金属层 $M1$ 上的一组 $n$ 个一维特征。特征 $i$ 是一个区间 $[L_i, R_i]$，其中 $L_i < R_i$。\n- **操作**：对特征 $i$ 进行位移量为 $\\delta_i$ 的校正性平移，得到新区间 $[L_i + \\delta_i, R_i + \\delta_i]$。\n- **变量**：\n    - $\\delta_i$：特征 $i$ 的位移量，其中 $i \\in \\{0, 1, \\dots, n-1\\}$。\n    - $t_i$：每个特征的辅助变量，满足 $t_i \\ge |\\delta_i|$。\n- **约束**：\n    1.  **间距**：对于指定的有序对 $(i,j)$ 且 $i<j$，$(R_i + \\delta_i) + S_{\\min} \\le L_j + \\delta_j$，整理后得到 $\\delta_i - \\delta_j \\le L_j - R_i - S_{\\min}$。\n    2.  **包围**：对于位于特征 $i$ 内坐标为 $v_k$ 处的过孔 $k$，$L_i + \\delta_i \\le v_k - E_k$ 且 $R_i + \\delta_i \\ge v_k + E_k$。整理后得到：\n        - $\\delta_i \\le v_k - L_i - E_k$\n        - $-\\delta_i \\le R_i - v_k - E_k$\n    3.  **绝对值线性化**：$t_i \\ge |\\delta_i|$ 等价于 $\\delta_i - t_i \\le 0$ 和 $-\\delta_i - t_i \\le 0$。\n    4.  **移动预算**：$|\\delta_i| \\le D_i$，即 $-D_i \\le \\delta_i \\le D_i$。\n- **目标函数**：最小化 $\\sum_i t_i$。\n\n问题陈述、约束和目标函数在科学上是自洽的，并正确地形式化为一个线性规划问题。\n\n### 步骤 2：解算器实现\n\n解决方案要求编写一个 Python 程序，该程序使用 `scipy.optimize.linprog` 函数来求解为每个测试案例构建的 LP 问题。程序必须为每个案例构建相应的系数矩阵 $A_{\\mathrm{ub}}$、边界向量 $b_{\\mathrm{ub}}$ 和变量边界。\n\n对于一个有 $n$ 个特征的系统，优化变量向量将是 $x = [\\delta_0, \\dots, \\delta_{n-1}, t_0, \\dots, t_{n-1}]$，总共有 $2n$ 个变量。\n\n- **目标函数 `c`**：一个长度为 $2n$ 的向量，其中前 $n$ 个元素（对应于 $\\delta_i$）为 0，后 $n$ 个元素（对应于 $t_i$）为 1。\n- **不等式约束 `A_ub` 和 `b_ub`**：\n    - 每个**间距约束** $\\delta_i - \\delta_j \\le L_j - R_i - S_{\\min}$ 增加一行到 $A_{\\mathrm{ub}}$。\n    - 每个**包围约束**为 $\\delta_i$ 增加两个不等式，从而为 $A_{\\mathrm{ub}}$ 增加两行。\n    - $n$ 个特征的**绝对值线性化**为每个特征 $i$ 增加两个不等式 $\\delta_i - t_i \\le 0$ 和 $-\\delta_i - t_i \\le 0$，总共为 $A_{\\mathrm{ub}}$ 增加 $2n$ 行。\n- **变量边界**：\n    - 对于每个 $\\delta_i$，边界是 $[-D_i, D_i]$。\n    - 对于每个 $t_i$，边界是 $[0, \\infty)$。\n\n如果 `linprog` 返回 `res.success = True`，则最优目标函数值 `res.fun` 是最小总移动量。如果 `res.success = False`，则问题是不可行的（或无界的，但在本问题中不可能），解算器将返回 -1.0。\n\n以下 Python 代码实现了该逻辑。它循环遍历每个测试案例，构建并求解相应的 LP，并以指定的格式打印结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_layout_lp(features, spacing_pairs, s_min, vias, movement_bounds):\n    \"\"\"\n    Solves the layout repair LP for a given test case.\n\n    Args:\n        features (list of tuples): List of (L_i, R_i) for each feature.\n        spacing_pairs (list of tuples): List of (i, j) for spacing constraints.\n        s_min (float): Minimum spacing requirement.\n        vias (list of tuples): List of (feature_idx, v_k, E_k) for vias.\n        movement_bounds (list of floats): List of D_i for each feature.\n\n    Returns:\n        float: The minimum total absolute movement, or -1.0 if infeasible.\n    \"\"\"\n    n = len(features)\n    \n    # Variables are [delta_0, ..., delta_{n-1}, t_0, ..., t_{n-1}]\n    # Objective: minimize sum(t_i)\n    c = np.zeros(2 * n)\n    c[n:] = 1.0\n\n    # Initialize lists for inequality constraints A_ub * x = b_ub\n    A_ub_rows = []\n    b_ub_vals = []\n\n    # 1. Spacing constraints: delta_i - delta_j = L_j - R_i - S_min\n    for i, j in spacing_pairs:\n        l_j, _ = features[j]\n        _, r_i = features[i]\n        row = np.zeros(2 * n)\n        row[i] = 1.0\n        row[j] = -1.0\n        A_ub_rows.append(row)\n        b_ub_vals.append(l_j - r_i - s_min)\n\n    # 2. Enclosure constraints for vias\n    for feature_idx, v_k, e_k in vias:\n        l_i, r_i = features[feature_idx]\n        \n        # a) delta_i = v_k - L_i - E_k\n        row_a = np.zeros(2 * n)\n        row_a[feature_idx] = 1.0\n        A_ub_rows.append(row_a)\n        b_ub_vals.append(v_k - l_i - e_k)\n        \n        # b) -delta_i = R_i - v_k - E_k\n        row_b = np.zeros(2 * n)\n        row_b[feature_idx] = -1.0\n        A_ub_rows.append(row_b)\n        b_ub_vals.append(r_i - v_k - e_k)\n\n    # 3. Auxiliary variable constraints: t_i >= |delta_i|\n    #    a) delta_i - t_i = 0\n    #    b) -delta_i - t_i = 0\n    for i in range(n):\n        row_a = np.zeros(2 * n)\n        row_a[i] = 1.0\n        row_a[n + i] = -1.0\n        A_ub_rows.append(row_a)\n        b_ub_vals.append(0.0)\n\n        row_b = np.zeros(2 * n)\n        row_b[i] = -1.0\n        row_b[n + i] = -1.0\n        A_ub_rows.append(row_b)\n        b_ub_vals.append(0.0)\n    \n    A_ub = np.array(A_ub_rows)\n    b_ub = np.array(b_ub_vals)\n\n    # 4. Bounds for variables\n    # -D_i = delta_i = D_i\n    # t_i >= 0\n    bounds = []\n    for i in range(n):\n        bounds.append((-movement_bounds[i], movement_bounds[i]))\n    for i in range(n):\n        bounds.append((0, None))\n\n    # Solve the LP\n    # The 'highs' method is recommended for its robustness.\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    if res.success:\n        return res.fun\n    else:\n        # According to scipy docs, status 2 indicates infeasibility.\n        # res.success is False for infeasible problems.\n        return -1.0\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {\n            \"features\": [(0.0, 2.0), (2.7, 4.7), (7.5, 9.5)],\n            \"spacing_pairs\": [(0, 1), (1, 2)],\n            \"s_min\": 1.0,\n            \"vias\": [(1, 3.3, 0.3)],\n            \"movement_bounds\": [1.0, 1.0, 1.0]\n        },\n        # Test Case B\n        {\n            \"features\": [(0.0, 2.0), (3.0, 5.0)],\n            \"spacing_pairs\": [(0, 1)],\n            \"s_min\": 1.0,\n            \"vias\": [(1, 3.8, 0.5)],\n            \"movement_bounds\": [0.5, 0.5]\n        },\n        # Test Case C\n        {\n            \"features\": [(0.0, 2.0), (2.7, 4.7), (7.5, 9.5)],\n            \"spacing_pairs\": [(0, 1), (1, 2)],\n            \"s_min\": 1.0,\n            \"vias\": [(1, 3.3, 0.5)],\n            \"movement_bounds\": [1.0, 1.0, 1.0]\n        },\n        # Test Case D\n        {\n            \"features\": [(0.0, 1.8), (2.5, 4.0), (4.7, 6.0), (6.6, 8.0)],\n            \"spacing_pairs\": [(0, 1), (1, 2), (2, 3)],\n            \"s_min\": 0.8,\n            \"vias\": [(1, 2.9, 0.4), (2, 5.8, 0.05), (3, 6.9, 0.2)],\n            \"movement_bounds\": [0.4, 0.5, 0.5, 0.5]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_layout_lp(\n            case[\"features\"],\n            case[\"spacing_pairs\"],\n            case[\"s_min\"],\n            case[\"vias\"],\n            case[\"movement_bounds\"]\n        )\n        results.append(result)\n\n    # Format output as a list of floats\n    print(f\"[{','.join(map('{:.1f}'.format, results))}]\")\n\nsolve()\n```"
        }
    ]
}