{
    "hands_on_practices": [
        {
            "introduction": "摩尔定律的核心在于通过缩小晶体管尺寸来提升其性能。本练习将探究一个基本关系：缩减关键物理尺寸——栅极氧化层厚度——如何提高跨导，而跨导是衡量晶体管放大能力和驱动能力的主要指标。通过这个实践，你将从第一性原理出发，推导出尺寸缩减如何直接转化为性能增益，从而理解驱动摩尔定律发展的根本动力。",
            "id": "4283586",
            "problem": "一个长沟道n型金属-氧化物-半导体场效应晶体管 (MOSFET) 在强反型区工作，其栅源电压 $V_{\\text{GS}}$ 固定，漏源电压 $V_{\\text{DS}}$ 足够大，以致在渐变沟道近似下，速度限制效应可以忽略不计，并确保电流饱和。栅极电介质是二氧化硅，其介电常数为 $\\varepsilon_{\\text{ox}}$。初始氧化层厚度为 $t_{\\text{ox},0}$，工艺按比例缩小，使得新的氧化层厚度为 $t_{\\text{ox}}' = t_{\\text{ox},0}/\\kappa$，其中 $\\kappa > 1$ 是一个无量纲的缩放因子。器件的几何尺寸 $(W,L)$、有效载流子迁移率 $\\mu$、衬底掺杂和偏置（因此费米势 $\\phi_{F}$）以及平带电压 $V_{\\text{FB}}$ 在缩放过程中保持不变。假设阈值状态下单位面积的耗尽电荷大小 $|Q_{B}|$ 主要由衬底特性和表面电势决定，并且在此缩放步骤中可以视为相对于 $t_{\\text{ox}}$ 不变。忽略串联电阻、由垂直电场引起的迁移率退化、量子电容和沟道长度调制效应。\n\n仅使用静电学第一性原理和长沟道MOSFET的电荷控制模型，并取饱和区固定 $V_{\\text{DS}}$ 下的跨导为 $g_{m} = \\partial I_{D}/\\partial V_{\\text{GS}}$，推导缩放后跨导 $g_{m}'$ 关于 $\\mu$、$\\varepsilon_{\\text{ox}}$、$t_{\\text{ox},0}$、$\\kappa$、$W$、$L$、$V_{\\text{GS}}$、$V_{\\text{FB}}$、$\\phi_{F}$ 和 $|Q_{B}|$ 的精确闭合形式解析表达式。您的最终表达式必须是单一的闭合形式解析表达式。不需要进行数值计算或四舍五入，最终表达式中也不应包含单位。",
            "solution": "该问题被认为是有效的，因为它基于已建立的半导体器件物理学，具有科学依据；问题设定良好，给出的条件完整且一致；并且其表述是客观的。问题要求推导长沟道n-MOSFET缩放后的跨导 $g_{m}'$。我们从MOSFET工作的基本原理开始。\n\n对于长沟道n-MOSFET，当速度饱和效应可以忽略时，其饱和区的漏极电流 $I_{D}$ 由平方律模型描述，这是渐变沟道近似的直接结果：\n$$\nI_{D} = \\frac{1}{2}\\mu C_{\\text{ox}}\\frac{W}{L}(V_{\\text{GS}} - V_{th})^2\n$$\n在此方程中，$\\mu$ 是有效载流子迁移率，$W$ 和 $L$ 分别是沟道宽度和长度，$V_{\\text{GS}}$ 是栅源电压，$V_{th}$ 是阈值电压，$C_{\\text{ox}}$ 是单位面积的栅氧化层电容。\n\n单位面积的栅氧化层电容定义为：\n$$\nC_{\\text{ox}} = \\frac{\\varepsilon_{\\text{ox}}}{t_{\\text{ox}}}\n$$\n其中 $\\varepsilon_{\\text{ox}}$ 是栅氧化层（二氧化硅）的介电常数，$t_{\\text{ox}}$ 是氧化层厚度。\n\n阈值电压 $V_{th}$ 由以下表达式给出：\n$$\nV_{th} = V_{\\text{FB}} + 2\\phi_{F} - \\frac{Q_{B}}{C_{\\text{ox}}}\n$$\n对于n沟道MOSFET，衬底是p型的，耗尽电荷 $Q_{B}$ 是负值。使用阈值状态下单位面积的耗尽电荷大小 $|Q_{B}| = -Q_{B}$，表达式变为：\n$$\nV_{th} = V_{\\text{FB}} + 2\\phi_{F} + \\frac{|Q_{B}|}{C_{\\text{ox}}}\n$$\n这里，$V_{\\text{FB}}$ 是平带电压，$\\phi_{F}$ 是p型衬底的费米势。\n\n跨导 $g_{m}$ 定义为在固定的漏源电压下，漏极电流相对于栅源电压的变化率：\n$$\ng_{m} = \\frac{\\partial I_{D}}{\\partial V_{\\text{GS}}}\n$$\n对于处于饱和区的器件，我们对饱和电流表达式求导。由于在此模型中 $V_{th}$ 不依赖于 $V_{\\text{GS}}$，求导过程很简单：\n$$\ng_{m} = \\frac{\\partial}{\\partial V_{\\text{GS}}}\\left[\\frac{1}{2}\\mu C_{\\text{ox}}\\frac{W}{L}(V_{\\text{GS}} - V_{th})^2\\right] = \\mu C_{\\text{ox}}\\frac{W}{L}(V_{\\text{GS}} - V_{th})\n$$\n该表达式也可以用沟道反型电荷密度 $Q_{I}$ 来表示，即 $g_m = \\mu \\frac{W}{L} |Q_I|$，其中 $|Q_I| = C_{ox}(V_{GS}-V_{th})$。\n\n问题指定了一个缩放场景，其中氧化层厚度减小一个因子 $\\kappa > 1$。初始氧化层厚度为 $t_{\\text{ox},0}$，缩放后（新）的氧化层厚度为 $t_{\\text{ox}}'$：\n$$\nt_{\\text{ox}}' = \\frac{t_{\\text{ox},0}}{\\kappa}\n$$\n根据问题陈述，参数 $\\mu$、$W$、$L$、$V_{\\text{FB}}$、$\\phi_{F}$ 和 $|Q_{B}|$ 在此缩放步骤中保持不变。\n\n首先，我们确定缩放后的氧化层电容 $C_{\\text{ox}}'$：\n$$\nC_{\\text{ox}}' = \\frac{\\varepsilon_{\\text{ox}}}{t_{\\text{ox}}'} = \\frac{\\varepsilon_{\\text{ox}}}{t_{\\text{ox},0}/\\kappa} = \\kappa \\frac{\\varepsilon_{\\text{ox}}}{t_{\\text{ox},0}}\n$$\n接下来，我们确定缩放后的阈值电压 $V_{th}'$。它依赖于已经改变的 $C_{\\text{ox}}'$：\n$$\nV_{th}' = V_{\\text{FB}} + 2\\phi_{F} + \\frac{|Q_{B}|}{C_{\\text{ox}}'}\n$$\n代入 $C_{\\text{ox}}'$ 的表达式：\n$$\nV_{th}' = V_{\\text{FB}} + 2\\phi_{F} + \\frac{|Q_{B}|}{\\kappa \\frac{\\varepsilon_{\\text{ox}}}{t_{\\text{ox},0}}} = V_{\\text{FB}} + 2\\phi_{F} + \\frac{|Q_{B}| t_{\\text{ox},0}}{\\kappa \\varepsilon_{\\text{ox}}}\n$$\n现在我们可以使用 $g_{m}$ 的通用公式以及缩放后的参数 $C_{\\text{ox}}'$ 和 $V_{th}'$ 来写出缩放后跨导 $g_{m}'$ 的表达式。栅源电压 $V_{\\text{GS}}$ 是固定的。\n$$\ng_{m}' = \\mu C_{\\text{ox}}'\\frac{W}{L}(V_{\\text{GS}} - V_{th}')\n$$\n我们代入 $C_{\\text{ox}}'$ 和 $V_{th}'$ 的表达式：\n$$\ng_{m}' = \\mu \\left(\\kappa \\frac{\\varepsilon_{\\text{ox}}}{t_{\\text{ox},0}}\\right)\\frac{W}{L}\\left[V_{\\text{GS}} - \\left(V_{\\text{FB}} + 2\\phi_{F} + \\frac{|Q_{B}| t_{\\text{ox},0}}{\\kappa \\varepsilon_{\\text{ox}}}\\right)\\right]\n$$\n为了得到最终的单一闭合形式表达式，我们将项 $\\mu \\left(\\kappa \\frac{\\varepsilon_{\\text{ox}}}{t_{\\text{ox},0}}\\right)\\frac{W}{L}$ 分配到括号内：\n$$\ng_{m}' = \\mu \\frac{W}{L} \\left[ \\left(\\kappa \\frac{\\varepsilon_{\\text{ox}}}{t_{\\text{ox},0}}\\right) (V_{\\text{GS}} - V_{\\text{FB}} - 2\\phi_{F}) - \\left(\\kappa \\frac{\\varepsilon_{\\text{ox}}}{t_{\\text{ox},0}}\\right) \\left(\\frac{|Q_{B}| t_{\\text{ox},0}}{\\kappa \\varepsilon_{\\text{ox}}}\\right) \\right]\n$$\n方括号内的第二项可以简化，因为因子 $\\kappa$、$\\varepsilon_{\\text{ox}}$ 和 $t_{\\text{ox},0}$ 会消掉：\n$$\n\\left(\\kappa \\frac{\\varepsilon_{\\text{ox}}}{t_{\\text{ox},0}}\\right) \\left(\\frac{|Q_{B}| t_{\\text{ox},0}}{\\kappa \\varepsilon_{\\text{ox}}}\\right) = |Q_{B}|\n$$\n因此，缩放后跨导 $g_{m}'$ 的最终表达式是：\n$$\ng_{m}' = \\mu \\frac{W}{L} \\left[ \\frac{\\kappa \\varepsilon_{\\text{ox}}}{t_{\\text{ox},0}}(V_{\\text{GS}} - V_{\\text{FB}} - 2\\phi_{F}) - |Q_{B}| \\right]\n$$\n该表达式即为所求的闭合形式解析结果，仅用问题陈述中提供的基本参数和常数表示。",
            "answer": "$$\n\\boxed{\\mu \\frac{W}{L} \\left[\\frac{\\kappa \\varepsilon_{\\text{ox}}}{t_{\\text{ox},0}}(V_{\\text{GS}} - V_{\\text{FB}} - 2\\phi_{F}) - |Q_{B}|\\right]}\n$$"
        },
        {
            "introduction": "随着晶体管速度的飞速提升，“互连线延迟的暴政”问题日益凸显，连接晶体管的导线延迟成为了性能的主要限制因素。本练习将深入探讨这一关键挑战，通过建立互连线延迟的缩放模型，并引入一个重要的实际物理效应——纳米尺度下导线电阻率随线宽减小而增大的尺寸效应——来分析问题。这个实践将帮助你理解为什么在先进工艺节点中，信号完整性和时序收敛变得如此困难。",
            "id": "4283537",
            "problem": "在电子设计自动化（EDA）的集成电路互连设计中，线几何尺寸在通常称为摩尔定律的趋势下的缩放会改变电阻和电容，从而改变信号延迟。考虑一根布线在连续参考平面上方的长而均匀的全局互连线。该互连线的初始宽度为 $W_{0}$，厚度为 $T_{0}$，长度为 $L_{0}$，与参考平面之间的电介质间距为 $D$。该电介质的介电常数为 $\\epsilon$。随着技术的缩放，通过引入一个无量纲比例因子 $s \\in (0,1)$ 来对几何变化进行建模，使得宽度按 $W(s) = s\\,W_{0}$ 缩放，厚度按 $T(s) = s^{\\beta} T_{0}$（对于某个实数指数 $\\beta$）缩放，长度按 $L(s) = s^{\\gamma} L_{0}$（对于某个实数指数 $\\gamma$）缩放。假设在所考虑的缩放范围内，$D$ 和 $\\epsilon$ 与 $s$ 无关。\n\n在纳米级线宽下，电子边界散射会增加有效电阻率。采用广泛使用的有效电阻率尺寸效应模型，\n$$\\rho_{\\text{eff}}(W) = \\rho_{0}\\left(1 + \\frac{\\lambda}{W}\\right),$$\n其中 $\\rho_{0}$ 是体电阻率，$\\lambda$ 是一个正的长度参数，用于表征平均自由程或表面散射长度尺度。\n\n从第一性原理出发：\n- 使用电阻的定义 $R = \\rho\\,\\frac{L}{A}$（其中 $A$ 是横截面积），并定义缩放后导线的单位长度电阻 $r(s)$。\n- 使用平行板电容近似来定义导线与参考平面之间的单位长度电容 $c(s)$，用 $W(s)$、$D$ 和 $\\epsilon$ 表示。\n- 将导线建模为由低阻抗源驱动的均匀分布电阻-电容（RC）线，并将远端延迟定义为冲激响应的一阶矩（Elmore延迟）。\n\n推导缩放后导线远端延迟 $t_{d}(s)$ 的闭式解析表达式，用 $s$、$\\rho_{0}$、$\\lambda$、$W_{0}$、$T_{0}$、$L_{0}$、$D$、$\\epsilon$、$\\beta$ 和 $\\gamma$ 表示。你的最终延迟必须以秒为单位表示。你的最终答案必须是单一的符号表达式。不需要进行数值计算。",
            "solution": "问题陈述已经过验证，被认为是有效的。这是一个在集成电路互连建模领域中适定的、有科学依据的问题。\n\n目标是推导缩放后互连线远端信号延迟 $t_{d}(s)$ 的闭式表达式。该延迟使用均匀分布RC线的Elmore延迟进行建模。推导过程首先确定缩放后的电阻和电容，然后将它们组合起来。\n\n首先，我们将互连线的缩放后几何参数定义为无量纲比例因子 $s$ 的函数。\n初始宽度为 $W_{0}$，厚度为 $T_{0}$，长度为 $L_{0}$。\n缩放后的宽度由 $W(s) = s W_{0}$ 给出。\n缩放后的厚度由 $T(s) = s^{\\beta} T_{0}$ 给出。\n缩放后的长度由 $L(s) = s^{\\gamma} L_{0}$ 给出。\n由此，缩放后的横截面积 $A(s)$ 是缩放后宽度和厚度的乘积：\n$$A(s) = W(s) T(s) = (s W_{0})(s^{\\beta} T_{0}) = s^{1+\\beta} W_{0} T_{0}$$\n\n接下来，我们确定考虑了尺寸效应的有效电阻率 $\\rho_{\\text{eff}}(s)$。问题提供了以下模型：\n$$\\rho_{\\text{eff}}(W) = \\rho_{0}\\left(1 + \\frac{\\lambda}{W}\\right)$$\n将缩放后的宽度 $W(s)$ 代入此模型，得到缩放后的有效电阻率：\n$$\\rho_{\\text{eff}}(s) = \\rho_{0}\\left(1 + \\frac{\\lambda}{W(s)}\\right) = \\rho_{0}\\left(1 + \\frac{\\lambda}{s W_{0}}\\right)$$\n\n单位长度电阻 $r(s)$ 定义为电阻率除以横截面积，$r = \\rho/A$。使用缩放后的参数：\n$$r(s) = \\frac{\\rho_{\\text{eff}}(s)}{A(s)} = \\frac{\\rho_{0}\\left(1 + \\frac{\\lambda}{s W_{0}}\\right)}{s^{1+\\beta} W_{0} T_{0}}$$\n为清晰起见，可以展开此表达式：\n$$r(s) = \\frac{\\rho_{0}}{W_{0} T_{0}} s^{-(1+\\beta)} \\left(1 + \\frac{\\lambda}{s W_{0}}\\right) = \\frac{\\rho_{0}}{W_{0} T_{0}} \\left( s^{-1-\\beta} + \\frac{\\lambda}{W_{0}} s^{-2-\\beta} \\right)$$\n\n现在，我们确定单位长度电容 $c(s)$。问题指定使用平行板电容近似。对于宽度为 $W$、距离参考平面为 $D$、介电常数为 $\\epsilon$ 的导线，其单位长度电容为 $c = \\epsilon W / D$。\n代入缩放后的宽度 $W(s)$：\n$$c(s) = \\frac{\\epsilon W(s)}{D} = \\frac{\\epsilon (s W_{0})}{D} = \\frac{\\epsilon W_{0}}{D} s$$\n\n问题将互连线建模为均匀分布的RC线。对于这样的线路，远端Elmore延迟 $t_{d}$ 是冲激响应的一阶矩，由以下表达式给出：\n$$t_{d} = \\frac{1}{2} R_{\\text{total}} C_{\\text{total}} = \\frac{1}{2} (r L) (c L) = \\frac{1}{2} r c L^2$$\n现在，我们可以通过代入 $r(s)$、$c(s)$ 和 $L(s)$ 的表达式来求得缩放后的延迟 $t_{d}(s)$：\n$$t_{d}(s) = \\frac{1}{2} r(s) c(s) [L(s)]^2$$\n代入推导出的表达式：\n$$t_{d}(s) = \\frac{1}{2} \\left[ \\frac{\\rho_{0}\\left(1 + \\frac{\\lambda}{s W_{0}}\\right)}{s^{1+\\beta} W_{0} T_{0}} \\right] \\left[ \\frac{\\epsilon W_{0}}{D} s \\right] \\left[ s^{\\gamma} L_{0} \\right]^2$$\n我们可以简化这个表达式。$W_{0}$ 项被消去。长度项变为 $s^{2\\gamma}L_{0}^{2}$。\n$$t_{d}(s) = \\frac{1}{2} \\frac{\\rho_{0} \\epsilon L_{0}^{2}}{T_{0} D} \\left[ \\frac{1 + \\frac{\\lambda}{s W_{0}}}{s^{1+\\beta}} \\right] s \\cdot s^{2\\gamma}$$\n现在，我们合并比例因子 $s$ 的幂：\n$$t_{d}(s) = \\frac{1}{2} \\frac{\\rho_{0} \\epsilon L_{0}^{2}}{T_{0} D} \\left(1 + \\frac{\\lambda}{s W_{0}}\\right) s^{ - (1+\\beta) + 1 + 2\\gamma }$$\n$s$ 的指数简化为 $ -1 - \\beta + 1 + 2\\gamma = 2\\gamma - \\beta$。\n$$t_{d}(s) = \\frac{1}{2} \\frac{\\rho_{0} \\epsilon L_{0}^{2}}{T_{0} D} \\left(1 + \\frac{\\lambda}{s W_{0}}\\right) s^{2\\gamma - \\beta}$$\n为了得到最终表达式，我们将 $s^{2\\gamma - \\beta}$ 项分配到括号内：\n$$t_{d}(s) = \\frac{1}{2} \\frac{\\rho_{0} \\epsilon L_{0}^{2}}{T_{0} D} \\left( s^{2\\gamma - \\beta} + \\frac{\\lambda}{s W_{0}} s^{2\\gamma - \\beta} \\right)$$\n$$t_{d}(s) = \\frac{\\rho_{0} \\epsilon L_{0}^{2}}{2 T_{0} D} \\left( s^{2\\gamma - \\beta} + \\frac{\\lambda}{W_{0}} s^{2\\gamma - \\beta - 1} \\right)$$\n这个最终表达式给出了远端延迟 $t_d(s)$ 作为比例因子 $s$ 以及基本物理和几何参数的函数。单位分析证实该表达式得出的结果单位为秒，因为 $[\\Omega \\cdot m] \\cdot [F/m] \\cdot [m^2] / ([m] \\cdot [m]) = [\\Omega \\cdot F] = [s]$。",
            "answer": "$$\n\\boxed{\\frac{\\rho_{0} \\epsilon L_{0}^{2}}{2 T_{0} D} \\left( s^{2\\gamma - \\beta} + \\frac{\\lambda}{W_{0}} s^{2\\gamma - \\beta - 1} \\right)}\n$$"
        },
        {
            "introduction": "要在物理上制造出摩尔定律所要求的不断缩小的器件特征，是一项巨大的挑战。当特征尺寸小于光刻波长时，必须采用多重曝光等计算光刻技术。本练习将视角从分析物理学转向计算问题求解，要求你解决一个为多重曝光技术（LELELE）进行版图分解的优化问题。这个问题被抽象为一个图着色问题，是电子设计自动化（EDA）中解决先进工艺制造难题的典型方法。",
            "id": "4283571",
            "problem": "在技术缩放和摩尔定律的背景下，集成电路中特征尺寸的缩小增加了使用多重曝光以满足光刻间距约束的需求。光刻-蚀刻-光刻-蚀刻-光刻-蚀刻 (LELELE) 三重曝光将目标层分解为三个掩模，这一过程被建模为一个图着色问题，其中违反最小间距的相邻特征不能共享同一个掩模。电子设计自动化 (EDA) 的公式化方法通过一个冲突图来捕捉此问题，该图的顶点代表可印刷的线段，边代表最小距离冲突。为了在多边形被分割时保持图形保真度，可以引入可选的“缝合点” (stitch)；当属于同一个原始多边形的两个线段被分配到不同的掩模时，就会产生一个缝合点，并且由于套准和线端可变性的风险，它会带来惩罚。\n\n你需要实现一个程序，为每个提供的测试用例，通过解决一个带有冲突和缝合点的三色图着色实例，来计算 LELELE 三重曝光下版图分解的可行性，并量化缝合点惩罚。\n\n定义和基本原理：\n- 令冲突图表示为 $G=(V,E_c)$，其中 $V=\\{0,1,\\dots,n-1\\}$ 是可印刷线段的集合，而 $E_c \\subseteq V \\times V$ 是代表最小距离冲突的无序对集合。掩模分配是一个函数 $x:V \\to \\{0,1,2\\}$，对应于 $k=3$ 个掩模。当且仅当 $x(u)=x(v)$ 时，一条边 $(u,v) \\in E_c$ 上发生冲突。\n- 令缝合点对集合为 $S \\subseteq V \\times V$，其中每个 $(u,v) \\in S$ 表示最初属于同一个多边形的两个线段，它们可以被印刷在不同的掩模上。当且仅当 $x(u)\\neq x(v)$ 时，一对 $(u,v)\\in S$ 上发生缝合。\n- 缝合点惩罚权重是一个标量 $\\alpha>0$。对于一个分配 $x$，缝合点数量为 $N_{\\text{st}}(x)=\\sum_{(u,v)\\in S} [x(u)\\neq x(v)]$，缝合点惩罚为 $P(x)=\\alpha \\cdot N_{\\text{st}}(x)$，其中 $[\\cdot]$ 是指示函数，当条件为真时等于 $1$，否则等于 $0$。\n- 可行性定义为存在一个分配 $x$，使得冲突总数 $C(x)=\\sum_{(u,v)\\in E_c} [x(u)=x(v)]$ 等于 $0$。\n\n对于每个测试用例，你的程序必须：\n- 确定布尔可行性 $\\mathrm{feas}$，定义为：如果存在 $x$ 使得 $C(x)=0$，则 $\\mathrm{feas}=\\text{True}$，否则 $\\mathrm{feas}=\\text{False}$。\n- 如果 $\\mathrm{feas}=\\text{True}$，在所有满足 $C(x)=0$ 的分配 $x$ 中，计算最小缝合点惩罚 $P^*=\\min P(x)$ 和对应的缝合点数量 $N_{\\text{st}}^*$。报告元组 $[\\mathrm{feas},0,P^*,N_{\\text{st}}^*]$。\n- 如果 $\\mathrm{feas}=\\text{False}$，在所有分配中计算最小冲突数 $C^*=\\min_x C(x)$，然后在达到 $C^*$ 的分配中，计算最小缝合点惩罚 $P^*=\\min P(x)$ 和对应的缝合点数量 $N_{\\text{st}}^*$。报告元组 $[\\mathrm{feas},C^*,P^*,N_{\\text{st}}^*]$。\n\n你必须通过对分配 $x:V\\to\\{0,1,2\\}$ 进行穷举搜索，以纯粹的算法方式解决此问题。鉴于下面测试套件中的图规模较小，这种方法是可接受的。没有需要报告的物理单位。\n\n测试套件：\n- 案例 1 (理想情况，无缝合点):\n  - $n=4$\n  - $E_c=\\{(0,1),(1,2),(2,3)\\}$\n  - $S=\\emptyset$\n  - $\\alpha=0.5$\n- 案例 2 (可行，但需要至少一个缝合点来满足冲突约束):\n  - $n=5$\n  - 令顶点 0,1,2 形成一个三角形：$E_c$ 包括 (0,1),(1,2),(0,2)。\n  - 在顶点3和4之间引入一个缝合点对：$S=\\{(3,4)\\}$。\n  - 额外的冲突边：$(3,0),(3,1),(4,0),(4,2)$。\n  - $\\alpha=0.2$。\n- 案例 3 (由于一个需要超过三种颜色的完全子图而不可行):\n  - $n=6$\n  - $E_c$ 包含顶点 0,1,2,3 之间的所有对（一个完全图 $K_4$）：$(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)$。\n  - $S=\\{(4,5)\\}$，且没有与顶点4或5关联的冲突边。\n  - $\\alpha=1.0$。\n\n最终输出格式：\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果是一个 $[\\mathrm{feas},C^*,P^*,N_{\\text{st}}^*]$ 顺序的列表。例如，对于两个用例，一个有效的输出格式是 $[[\\text{True},0,0.0,0],[\\text{False},1,0.0,0]]$。\n- 程序必须是自包含的，且不得读取任何输入；它必须使用上述测试套件作为内部数据。",
            "solution": "所呈现的问题是一个形式化的优化任务，源于集成电路的电子设计自动化 (EDA) 领域，具体涉及三重曝光光刻 (LELELE) 的版图分解。该任务旨在确定版图分解的可行性，并从光刻冲突和图案化缝合点的角度量化相关惩罚。这被建模为图 $k$-着色问题的一个变体，其中 $k=3$。\n\n解决方案将通过穷举搜索算法来开发，鉴于所提供测试套件中的图规模较小，该算法在计算上是可行的。该问题定义明确，在其背景下具有科学依据，并且内部一致。\n\n**1. 形式化问题定义**\n\n令一个版图由图 $G=(V, E_c)$ 表示，其中 $V=\\{0, 1, \\dots, n-1\\}$ 是一个包含 $n$ 个可印刷线段的集合，而 $E_c$ 是一个冲突边集合。掩模分配是一个函数 $x: V \\to \\{0, 1, 2\\}$，它为每个线段分配三个掩模中的一个。\n\n-   **冲突**：当一条边 $(u, v) \\in E_c$ 所连接的线段被分配了相同的掩模时，即 $x(u) = x(v)$，就会发生冲突。对于一个分配 $x$，总冲突数为 $C(x) = \\sum_{(u,v) \\in E_c} [x(u) = x(v)]$，其中 $[\\cdot]$ 是艾佛森括号。\n-   **缝合点**：缝合点是两个属于同一个原始多边形的线段 $(u, v) \\in S$ 之间的可选制造连接点。当这些线段被分配了不同的掩模时，即 $x(u) \\neq x(v)$，缝合点就会实现。总缝合点数为 $N_{\\text{st}}(x) = \\sum_{(u,v) \\in S} [x(u) \\neq x(v)]$。\n-   **缝合点惩罚**：每个缝合点都会产生一个由标量 $\\alpha > 0$ 加权的惩罚。总缝合点惩罚为 $P(x) = \\alpha \\cdot N_{\\text{st}}(x)$。\n\n**2. 优化目标**\n\n该问题指定了一个两级优化目标：\n1.  首先，最小化冲突数。令最小可能冲突数为 $C^* = \\min_{x} C(x)$。\n2.  其次，在所有达到此最小冲突数（即 $C(x) = C^*$）的分配 $x$ 中，找到一个能最小化缝合点惩罚的分配。令此最小惩罚为 $P^* = \\min_{x | C(x)=C^*} P(x)$，对应的缝合点数为 $N_{\\text{st}}^* = P^* / \\alpha$。\n\n可行性定义为存在无冲突分配的情况，即 $C^*=0$。程序必须为每个测试用例报告一个元组 $[\\mathrm{feas}, C^*, P^*, N_{\\text{st}}^*]$。\n\n**3. 算法方法：穷举搜索**\n\n鉴于顶点数 $n$ 很小，我们可以探索所有可能的掩模分配的整个搜索空间。对于一个有 $n$ 个顶点和 $k=3$ 个掩模（颜色）的图，存在 $k^n = 3^n$ 个唯一的分配。算法对每个测试用例按以下步骤进行：\n\n1.  **生成所有分配**：系统地生成每个可能的函数 $x: V \\to \\{0, 1, 2\\}$。这可以通过将每个分配看作一个长度为 $n$ 的三进制数来实现。例如，在 Python 中使用 `itertools.product`，我们可以生成所有长度为 $n$ 且元素来自 $\\{0, 1, 2\\}$ 的元组，其中每个元组代表一个唯一的着色方案。\n\n2.  **评估每个分配**：对于每个生成的分配 $x$：\n    a.  初始化冲突数 $c_x = 0$ 和缝合点数 $s_x = 0$。\n    b.  遍历每个冲突边 $(u, v) \\in E_c$。如果 $x(u) = x(v)$，则增加 $c_x$。\n    c.  遍历每个缝合点对 $(u, v) \\in S$。如果 $x(u) \\neq x(v)$，则增加 $s_x$。\n    d.  存储该分配 $x$ 得到的结果对 $(c_x, s_x)$。\n\n3.  **确定最优值**：在评估完所有 $3^n$ 个分配后：\n    a.  通过取所有存储的冲突数的最小值来找到全局最小冲突数 $C^*$。\n    b.  确定可行性：$\\mathrm{feas} = (C^* == 0)$。\n    c.  筛选结果，只考虑那些达到最小冲突数 $C^*$ 的分配。\n    d.  从这个筛选后的集合中，找到最小缝合点数 $N_{\\text{st}}^*$。\n    e.  计算最小缝合点惩罚为 $P^* = \\alpha \\cdot N_{\\text{st}}^*$。\n\n4.  **格式化输出**：将最终报告组装成一个列表：$[\\mathrm{feas}, C^*, P^*, N_{\\text{st}}^*]$。\n\n**4. 实现细节**\n\n该实现将处理一个测试用例列表。每个测试用例提供参数 $n$、$E_c$、$S$ 和 $\\alpha$。\n-   冲突边 $E_c$ 和缝合点对 $S$ 表示为元组列表。\n-   核心逻辑被封装在一个函数中，该函数接受这些参数并返回结果元组。\n-   脚本的主要部分遍历测试套件，调用求解器函数，并收集结果。\n-   最后，将收集到的结果格式化为问题陈述中指定的单个字符串。使用 NumPy 对于逻辑来说并非必需，但其对象可用于表示分配以符合指定的环境。Python 标准库的 `itertools.product` 对于生成分配非常高效。\n\n这种系统性的暴力方法通过探索整个解空间，保证了能找到 $C^*$ 和 $P^*$ 的真正最优解，这对于给定的问题约束是可行的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the LELELE decomposition problem for a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (happy path, no stitches):\n        {\n            \"n\": 4,\n            \"Ec\": {(0, 1), (1, 2), (2, 3)},\n            \"S\": set(),\n            \"alpha\": 0.5\n        },\n        # Case 2 (feasible but requiring at least one stitch):\n        {\n            \"n\": 5,\n            \"Ec\": {(0, 1), (1, 2), (0, 2), (3, 0), (3, 1), (4, 0), (4, 2)},\n            \"S\": {(3, 4)},\n            \"alpha\": 0.2\n        },\n        # Case 3 (infeasible due to a K4 subgraph):\n        {\n            \"n\": 6,\n            \"Ec\": {(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)},\n            \"S\": {(4, 5)},\n            \"alpha\": 1.0\n        }\n    ]\n\n    results = [solve_case(**case) for case in test_cases]\n\n    # Final print statement in the exact required format.\n    # The str() of a list produces the required format '[...]'.\n    # The join then combines them like '[...],[...]'\n    # The f-string wraps the whole thing in one more pair of brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_case(n: int, Ec: set, S: set, alpha: float) -> list:\n    \"\"\"\n    Computes the feasibility and optimal penalties for a single graph coloring instance.\n\n    Args:\n        n: Number of vertices.\n        Ec: Set of conflict edges represented as tuples.\n        S: Set of stitch pairs represented as tuples.\n        alpha: Stitch penalty weight.\n\n    Returns:\n        A list containing [feas, C*, P*, N_st*].\n    \"\"\"\n    num_masks = 3\n    all_assignments = itertools.product(range(num_masks), repeat=n)\n    \n    evaluated_assignments = []\n\n    for assignment in all_assignments:\n        # assignment is a tuple representing the coloring x, e.g., (0, 1, 0, 2)\n        \n        # Calculate conflicts\n        conflict_count = 0\n        for u, v in Ec:\n            if assignment[u] == assignment[v]:\n                conflict_count += 1\n        \n        # Calculate stitches\n        stitch_count = 0\n        for u, v in S:\n            if assignment[u] != assignment[v]:\n                stitch_count += 1\n        \n        evaluated_assignments.append({\n            \"conflicts\": conflict_count,\n            \"stitches\": stitch_count\n        })\n\n    # Find the minimum conflict count C*\n    if not evaluated_assignments:\n        # Handle the case of n=0, though not in test suite.\n        min_conflicts = 0\n    else:\n        min_conflicts = min(res[\"conflicts\"] for res in evaluated_assignments)\n\n    # Determine feasibility\n    feasibility = (min_conflicts == 0)\n\n    # Filter for assignments that achieve C*\n    optimal_conflict_assignments = [\n        res for res in evaluated_assignments \n        if res[\"conflicts\"] == min_conflicts\n    ]\n\n    # Among those, find the minimum stitch count N_st*\n    if not optimal_conflict_assignments:\n        min_stitches = 0\n    else:\n        min_stitches = min(res[\"stitches\"] for res in optimal_conflict_assignments)\n\n    # Calculate the minimum stitch penalty P*\n    min_penalty = alpha * min_stitches\n\n    return [feasibility, min_conflicts, min_penalty, min_stitches]\n\nsolve()\n```"
        }
    ]
}