{
    "hands_on_practices": [
        {
            "introduction": "This first exercise delves into the structural axis of the Y-chart, examining the process of refinement between the logic and circuit levels of abstraction. You will analyze two distinct paths for implementing a single logical function: a direct, custom approach versus a hierarchical decomposition constrained by a standard-cell library. By calculating the resulting transistor count for each path , you will gain a concrete understanding of how early architectural choices can have significant impacts on the final physical implementation and its efficiency.",
            "id": "4264793",
            "problem": "An advanced design team is refining a gate-level netlist within the framework of the Gajski-Kuhn Y-chart, moving between abstraction levels and domains. Consider a node in the netlist that is a $k$-input logical NAND, where $k \\geq 2$. Two refinement paths are considered from the structural, logic-level description down to the structural, circuit-level description in Complementary Metal-Oxide-Semiconductor (CMOS) technology.\n\nPath A: Direct refinement to a single static Complementary Metal-Oxide-Semiconductor (CMOS) gate. The transistor-level schematic is constructed using the complementary pull-down network and pull-up network method: the pull-down network is realized with series-parallel networks of n-channel metal-oxide-semiconductor field-effect transistors (NMOS) corresponding to the conditions under which the output must be logic low, and the pull-up network is the dual network of p-channel metal-oxide-semiconductor field-effect transistors (PMOS) corresponding to the logical complement of those conditions. Assume minimum, series-parallel static CMOS without transmission gates, without factoring, and without any duplication or redundancy. Ignore well taps, body ties, routing devices, and any upsizing for performance; count only functional transistors.\n\nPath B: Hierarchical refinement constrained by a standard-cell composition rule at the logic level before circuit mapping: only $2$-input NAND cells are available at the gate level. The $k$ inputs must be combined by a binary tree whose internal nodes compute logical AND, except that the root produces logical NAND so that the overall function is the $k$-input NAND. Logical AND at each non-root internal node must be constructed using only $2$-input NAND gates and inverters. An inverter must be realized using a $2$-input NAND with its two inputs tied together. After this logic-level decomposition, each $2$-input NAND is refined to its static CMOS implementation as in Path A. As above, ignore well taps, body ties, routing devices, and upsizing, and count only functional transistors.\n\nStart from fundamental Boolean algebra and the standard static CMOS complementary pull-up/pull-down construction rule, and derive closed-form expressions, as functions of $k$, for the total number of transistors obtained by Path A and by Path B. Finally, define $D(k)$ to be the difference between the Path B transistor count and the Path A transistor count, and provide $D(k)$ as a single simplified symbolic expression in terms of $k$. No numerical substitution is required. Your final answer must be the single expression for $D(k)$.",
            "solution": "The problem will first be validated against the specified criteria before a solution is attempted.\n\n### Step 1: Extract Givens\n- **Function**: A $k$-input logical NAND, for integer $k \\geq 2$.\n- **Context**: Refinement from structural, logic-level to structural, circuit-level on the Gajski-Kuhn Y-chart.\n- **Technology**: Complementary Metal-Oxide-Semiconductor (CMOS).\n- **Path A (Direct Refinement)**:\n    - The $k$-input NAND is implemented as a single static CMOS gate.\n    - Construction is via a complementary Pull-Down Network (PDN) of n-channel metal-oxide-semiconductor field-effect transistors (NMOS) and a Pull-Up Network (PUN) of p-channel metal-oxide-semiconductor field-effect transistors (PMOS).\n    - The implementation is minimum, series-parallel static CMOS.\n    - Exclusions for counting: transmission gates, factoring, duplication, redundancy, well taps, body ties, routing devices, and transistor upsizing. Only functional transistors are counted.\n- **Path B (Hierarchical Refinement)**:\n    - Logic-level constraint: only $2$-input NAND cells are available.\n    - Decomposition: The $k$-input NAND is implemented as a binary tree. Internal nodes compute logical AND, except the root which computes logical NAND.\n    - Realization of AND: A $2$-input logical AND is constructed using only $2$-input NAND gates and inverters.\n    - Realization of Inverter: An inverter is constructed from a $2$-input NAND gate with its inputs tied together.\n    - Circuit-level mapping: Each $2$-input NAND cell is refined to its static CMOS implementation as described for Path A.\n    - Exclusions for counting: same as Path A.\n- **Goal**:\n    - Derive a closed-form expression for the total transistor count for Path A, denoted $T_A(k)$.\n    - Derive a closed-form expression for the total transistor count for Path B, denoted $T_B(k)$.\n    - Define $D(k) = T_B(k) - T_A(k)$.\n    - Provide a single simplified symbolic expression for $D(k)$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed for validity:\n- **Scientifically Grounded**: The problem is rooted in fundamental principles of digital logic design (Boolean algebra, logic gate decomposition) and VLSI circuit design (static CMOS gate topology). These are standard, well-established concepts in electrical engineering and computer science. The problem is scientifically sound.\n- **Well-Posed**: The problem provides a clear and complete set of rules for constructing and analyzing the circuits in both paths. The definitions for implementing AND gates and inverters in Path B are unambiguous. The objective is to find a specific mathematical expression, for which a unique solution can be derived from the given constraints. The problem is well-posed.\n- **Objective**: The problem is stated using precise, technical language devoid of subjectivity, opinion, or bias.\n- **Other Flaws**: The problem does not violate any other criteria. It is not based on false premises, it is formalizable, it is self-contained, its assumptions are standard simplifications in textbook analysis, and it is not trivial.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A complete, reasoned solution will be provided.\n\n### Solution Derivation\n\nThe solution requires deriving the transistor counts for two different implementation paths of a $k$-input NAND gate and then finding their difference.\n\n**1. Transistor Count for Path A: $T_A(k)$**\n\nIn Path A, a $k$-input NAND gate is implemented as a single, static CMOS logic gate. The Boolean function is $Y = \\overline{I_1 \\cdot I_2 \\cdot \\ldots \\cdot I_k}$, where $I_1, \\ldots, I_k$ are the inputs.\n\nAccording to the rules of static complementary CMOS design:\n- The Pull-Down Network (PDN) connects the output to ground ($V_{SS}$) and must be conducting when the output is logic low. The output $Y$ is low if and only if all inputs are high, i.e., $I_1 \\cdot I_2 \\cdot \\ldots \\cdot I_k = 1$. An AND function in the PDN is realized by placing NMOS transistors in series. Therefore, the PDN consists of $k$ NMOS transistors connected in series, one for each input.\n- The Pull-Up Network (PUN) connects the output to the power supply ($V_{DD}$) and must be conducting when the output is logic high. This occurs when the condition for the PDN is false, i.e., $\\overline{I_1 \\cdot I_2 \\cdot \\ldots \\cdot I_k} = 1$. The PUN is the logical and topological dual of the PDN. A series connection of NMOS transistors in the PDN corresponds to a parallel connection of PMOS transistors in the PUN. Therefore, the PUN consists of $k$ PMOS transistors connected in parallel, one for each input.\n\nThe total number of functional transistors is the sum of transistors in the PDN and the PUN.\n$$T_A(k) = (\\text{Number of NMOS}) + (\\text{Number of PMOS}) = k + k = 2k$$\n\n**2. Transistor Count for Path B: $T_B(k)$**\n\nIn Path B, the $k$-input NAND function is first decomposed into a network of $2$-input NAND gates. The problem specifies a binary tree structure. A binary tree with $k$ leaves (inputs) has $k-1$ internal nodes (gates). The problem states that the root node is a $2$-input NAND gate, and the remaining $k-2$ internal nodes are $2$-input AND gates.\n\nFirst, we determine the number of primitive $2$-input NAND cells required to build this structure.\n- A $2$-input AND gate must be constructed from $2$-input NAND gates and inverters. The standard construction is based on De Morgan's laws: $A \\cdot B = \\overline{\\overline{A \\cdot B}}$. This requires one $2$-input NAND gate followed by an inverter.\n- An inverter, in turn, is specified to be implemented using a $2$-input NAND gate with its inputs tied together. This is considered one primitive $2$-input NAND cell.\n- Therefore, a $2$-input AND gate requires $1$ NAND cell for the initial NAND operation and $1$ NAND cell for the subsequent inversion, for a total of $2$ primitive $2$-input NAND cells.\n\nThe total number of primitive $2$-input NAND cells required for the $k$-input function in Path B is the sum of cells for all the component gates:\n- Number of $2$-input AND gates: $k-2$\n- Number of $2$-input NAND gates (the root): $1$\n\nTotal cells = (Number of AND gates $\\times$ cells per AND) + (Number of NAND gates $\\times$ cells per NAND)\nTotal cells = $(k-2) \\times 2 + 1 \\times 1 = 2k - 4 + 1 = 2k - 3$\n\nNext, we find the transistor count for each primitive $2$-input NAND cell. Using the same static CMOS design principles as in Path A, but for $k=2$, a $2$-input NAND gate has:\n- A PDN with $2$ NMOS transistors in series.\n- A PUN with $2$ PMOS transistors in parallel.\nThis gives a total of $2+2=4$ transistors per $2$-input NAND cell.\n\nThe total transistor count for Path B, $T_B(k)$, is the total number of primitive cells multiplied by the number of transistors per cell.\n$$T_B(k) = (2k-3) \\times 4 = 8k - 12$$\n\n**3. Calculation of the Difference $D(k)$**\n\nThe problem defines $D(k)$ as the difference between the transistor count of Path B and Path A.\n$$D(k) = T_B(k) - T_A(k)$$\nSubstituting the expressions derived above:\n$$D(k) = (8k - 12) - (2k)$$\nSimplifying the expression yields:\n$$D(k) = 6k - 12$$\nThis expression is valid for $k \\geq 2$. For $k=2$, $T_A(2) = 2(2) = 4$ and $T_B(2) = 8(2)-12 = 4$, so $D(2)=0$. This is correct, as for $k=2$ both paths describe a simple $2$-input NAND gate. For $k > 2$, Path B is less efficient in terms of transistor count.",
            "answer": "$$\\boxed{6k-12}$$"
        },
        {
            "introduction": "This practice moves to the interface between the behavioral and structural domains, focusing on the fundamental task of scheduling in High-Level Synthesis (HLS). Given a behavioral specification as a data-flow graph, you will map it onto a specific hardware resource over time, a process that defines the design's microarchitecture. By manually performing list scheduling , you will grapple with resource constraints and precedence dependencies to create a deterministic, cycle-accurate execution plan, which is a critical step in translating an algorithm into hardware.",
            "id": "4264767",
            "problem": "In the spirit of Electronic Design Automation (EDA) and within the Gajski-Kuhn Y-chart view, scheduling at the behavioral domain must respect precedence at the algorithmic level while mapping to a single structural resource and a geometric time axis. Consider a computation described at the behavior domain by a Directed Acyclic Graph (DAG) of operations $\\{O_1,\\dots,O_9\\}$, each with an integer operation latency $L_i$ measured in cycles. The structural domain provides a single fully pipelined functional unit with initiation interval $1$ cycle, which enforces a single-issue constraint: at most one operation can be initiated per integer cycle. The geometric domain is a discrete-time grid of integer cycles starting at cycle $0$.\n\nThe operation latencies are: $L_1=2$, $L_2=3$, $L_3=1$, $L_4=2$, $L_5=3$, $L_6=2$, $L_7=1$, $L_8=4$, $L_9=2$. Precedence constraints are given by edges $O_1 \\to O_3$, $O_1 \\to O_4$, $O_2 \\to O_4$, $O_3 \\to O_5$, $O_3 \\to O_6$, $O_4 \\to O_7$, $O_5 \\to O_7$, $O_6 \\to O_8$, $O_7 \\to O_9$, $O_8 \\to O_9$.\n\nYou must derive, from first principles, the earliest unconstrained start times at the behavior domain and then a list-scheduled start-time assignment at the structure/geometry domains under the single-issue resource constraint, resolving resource conflicts using a critical-path priority consistent with latency-weighted behavior-to-structure mapping.\n\nStart from core definitions: an operation $O_i$ may start at cycle $t$ only if all of its immediate predecessors have completed by $t$, where completion of $O_i$ started at $s_i$ occurs at $s_i+L_i$. First, compute the earliest unconstrained start times $e_i$ (ignoring the single-issue constraint) based solely on precedence and latencies. Then, compute a list schedule under the single-issue constraint as follows: at each integer cycle $t$, among all ready and not-yet-started operations, select a single operation to initiate; break ties and resolve conflicts by selecting the operation with the largest latency-weighted critical-path priority $W_i$, defined recursively by\n$$\nW_i=\n\\begin{cases}\nL_i, & \\text{if $O_i$ has no successors (sink)}\\\\\nL_i+\\max\\limits_{O_j \\in \\mathrm{succ}(i)} W_j, & \\text{otherwise,}\n\\end{cases}\n$$\nwhere $\\mathrm{succ}(i)$ denotes the set of immediate successors of $O_i$.\n\nProvide your final schedule as the start-time vector $s=[s_1,\\dots,s_9]$ in cycles (ordered as $(O_1,\\dots,O_9)$) together with the overall latency $T=\\max_i(s_i+L_i)$, expressed in cycles. Express all cycles as integers; no rounding is required. Present the final answer as a single row matrix containing $s_1,\\dots,s_9,T$ in that order.",
            "solution": "The problem statement has been critically examined and found to be valid. It presents a well-posed, self-contained resource-constrained scheduling problem, grounded in the standard principles of high-level synthesis and electronic design automation. The concepts of a Directed Acyclic Graph (DAG) for behavioral specification, operation latencies, precedence constraints, a single-issue resource constraint, and list scheduling with a critical-path-based priority function are all standard and formally defined. The problem is objective and requires a deterministic, verifiable calculation.\n\nThe task is to map a behavioral specification onto a structural and geometric implementation, a process modeled by the Gajski-Kuhn Y-chart. We are given a set of operations $\\{O_1, \\dots, O_9\\}$ with specified integer latencies $L_i$ and a DAG defining precedence constraints. The structural domain provides a single-issue resource, meaning at most one operation can be initiated per cycle. The geometric domain is a discrete integer timeline.\n\nThe solution proceeds in three stages:\n1.  Determination of the earliest possible start times, $e_i$, in an unconstrained (purely behavioral) context.\n2.  Calculation of the latency-weighted critical-path priority, $W_i$, for each operation. This priority metric will guide the scheduling decisions.\n3.  Execution of a list scheduling algorithm to determine the resource-constrained start times, $s_i$, and the total schedule latency, $T$.\n\nFirst, we compute the earliest unconstrained start times, $e_i$. These are also known as the As-Soon-As-Possible (ASAP) times. An operation can only start after all its predecessors have completed. The start time $e_i$ for operation $O_i$ is given by:\n$$e_i = \\max_{O_j \\in \\mathrm{pred}(i)} \\{e_j + L_j\\}$$\nwhere $\\mathrm{pred}(i)$ is the set of immediate predecessors of $O_i$. For source nodes with no predecessors, $e_i=0$. The computation follows a topological sort of the DAG.\nThe given latencies are $L=[2, 3, 1, 2, 3, 2, 1, 4, 2]$.\nThe predecessor sets are:\n$\\mathrm{pred}(1) = \\emptyset, \\mathrm{pred}(2) = \\emptyset, \\mathrm{pred}(3) = \\{O_1\\}, \\mathrm{pred}(4) = \\{O_1, O_2\\}, \\mathrm{pred}(5) = \\{O_3\\}, \\mathrm{pred}(6) = \\{O_3\\}, \\mathrm{pred}(7) = \\{O_4, O_5\\}, \\mathrm{pred}(8) = \\{O_6\\}, \\mathrm{pred}(9) = \\{O_7, O_8\\}$.\n\n$e_1 = 0$\n$e_2 = 0$\n$e_3 = e_1 + L_1 = 0 + 2 = 2$\n$e_4 = \\max(e_1 + L_1, e_2 + L_2) = \\max(0 + 2, 0 + 3) = 3$\n$e_5 = e_3 + L_3 = 2 + 1 = 3$\n$e_6 = e_3 + L_3 = 2 + 1 = 3$\n$e_7 = \\max(e_4 + L_4, e_5 + L_5) = \\max(3 + 2, 3 + 3) = \\max(5, 6) = 6$\n$e_8 = e_6 + L_6 = 3 + 2 = 5$\n$e_9 = \\max(e_7 + L_7, e_8 + L_8) = \\max(6 + 1, 5 + 4) = \\max(7, 9) = 9$\n\nSecond, we compute the priority weights, $W_i$, for the list scheduling algorithm. The weight $W_i$ represents the length of the longest path from the start of operation $O_i$ to any sink of the graph, where path length is the sum of latencies of the operations on the path. The recursive definition is:\n$$W_i = L_i + \\max_{O_j \\in \\mathrm{succ}(i)} \\{W_j\\}$$\nwhere $\\mathrm{succ}(i)$ is the set of immediate successors of $O_i$. For sink nodes with no successors, $W_i = L_i$. This calculation is performed by traversing the DAG in reverse topological order.\nThe successor sets are:\n$\\mathrm{succ}(1) = \\{O_3, O_4\\}, \\mathrm{succ}(2) = \\{O_4\\}, \\mathrm{succ}(3) = \\{O_5, O_6\\}, \\mathrm{succ}(4) = \\{O_7\\}, \\mathrm{succ}(5) = \\{O_7\\}, \\mathrm{succ}(6) = \\{O_8\\}, \\mathrm{succ}(7) = \\{O_9\\}, \\mathrm{succ}(8) = \\{O_9\\}, \\mathrm{succ}(9) = \\emptyset$.\n\n$W_9 = L_9 = 2$\n$W_8 = L_8 + W_9 = 4 + 2 = 6$\n$W_7 = L_7 + W_9 = 1 + 2 = 3$\n$W_6 = L_6 + W_8 = 2 + 6 = 8$\n$W_5 = L_5 + W_7 = 3 + 3 = 6$\n$W_4 = L_4 + W_7 = 2 + 3 = 5$\n$W_3 = L_3 + \\max(W_5, W_6) = 1 + \\max(6, 8) = 1 + 8 = 9$\n$W_2 = L_2 + W_4 = 3 + 5 = 8$\n$W_1 = L_1 + \\max(W_3, W_4) = 2 + \\max(9, 5) = 2 + 9 = 11$\nThe priority list of operations, from highest to lowest $W_i$, is: $O_1(11), O_3(9), O_2(8), O_6(8), O_5(6), O_8(6), O_4(5), O_7(3), O_9(2)$. Where ties in $W_i$ exist (e.g., $W_2=W_6=8$ and $W_5=W_8=6$), we apply a deterministic tie-breaking rule of choosing the operation with the lower index. The sorted priority list is: $O_1, O_3, O_2, O_6, O_5, O_8, O_4, O_7, O_9$.\n\nThird, we perform list scheduling. We iterate through time cycles $t=0, 1, 2, \\dots$. At each cycle, we build a `ReadyList` of all unscheduled operations whose predecessors have completed. If the `ReadyList` is not empty, we select the operation with the highest priority and schedule it at the current cycle $t$.\n- **Cycle $t=0$**: `ReadyList` = $\\{O_1, O_2\\}$. $O_1$ has higher priority ($W_1=11 > W_2=8$). Schedule $O_1$. $s_1=0$.\n- **Cycle $t=1$**: `ReadyList` = $\\{O_2\\}$. Schedule $O_2$. $s_2=1$.\n- **Cycle $t=2$**: $O_1$ completes ($0+2=2$). $O_3$ becomes ready. `ReadyList` = $\\{O_3\\}$. Schedule $O_3$. $s_3=2$.\n- **Cycle $t=3$**: $O_3$ completes ($2+1=3$). $O_5$ and $O_6$ become ready. `ReadyList` = $\\{O_5, O_6\\}$. $O_6$ has higher priority ($W_6=8 > W_5=6$). Schedule $O_6$. $s_6=3$.\n- **Cycle $t=4$**: $O_2$ completes ($1+3=4$). $O_4$ becomes ready. The `ReadyList`, sorted by priority, is $\\{O_5, O_4\\}$ ($W_5=6 > W_4=5$). Schedule $O_5$. $s_5=4$.\n- **Cycle $t=5$**: $O_6$ completes ($3+2=5$). $O_8$ becomes ready. The `ReadyList`, sorted by priority, is $\\{O_8, O_4\\}$ ($W_8=6 > W_4=5$). Schedule $O_8$. $s_8=5$.\n- **Cycle $t=6$**: `ReadyList` = $\\{O_4\\}$. Schedule $O_4$. $s_4=6$.\n- **Cycle $t=7$**: $O_5$ completes ($4+3=7$). $O_7$ is not yet ready, as it awaits $O_4$ (which completes at $6+2=8$). `ReadyList` is empty. This is an idle cycle.\n- **Cycle $t=8$**: $O_4$ completes ($6+2=8$). $O_7$ becomes ready (predecessors $O_4, O_5$ are complete). `ReadyList` = $\\{O_7\\}$. Schedule $O_7$. $s_7=8$.\n- **Cycle $t=9$**: $O_7$ and $O_8$ both complete (at $8+1=9$ and $5+4=9$, respectively). $O_9$ becomes ready. `ReadyList` = $\\{O_9\\}$. Schedule $O_9$. $s_9=9$.\n\nThe final scheduled start times are $s=[s_1, s_2, s_3, s_4, s_5, s_6, s_7, s_8, s_9] = [0, 1, 2, 6, 4, 3, 8, 5, 9]$.\n\nThe overall latency $T$ is the completion time of the last operation. The completion time of an operation $O_i$ is $c_i = s_i + L_i$.\n$c_1 = 0+2=2$\n$c_2 = 1+3=4$\n$c_3 = 2+1=3$\n$c_4 = 6+2=8$\n$c_5 = 4+3=7$\n$c_6 = 3+2=5$\n$c_7 = 8+1=9$\n$c_8 = 5+4=9$\n$c_9 = 9+2=11$\nThe total latency is $T = \\max_i(c_i) = 11$ cycles.\nThe final result comprises the start-time vector $s$ and the total latency $T$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 0 & 1 & 2 & 6 & 4 & 3 & 8 & 5 & 9 & 11 \\end{pmatrix} } $$"
        },
        {
            "introduction": "Successful IC design often involves navigating a landscape of conflicting objectives. This final exercise models the crucial trade-offs that occur at the intersection of the behavioral, structural, and physical domains during placement. You will develop and solve a simplified optimization problem that seeks to balance the competing goals of minimizing wirelength (a physical cost) and satisfying timing performance (a behavioral requirement) . This practice demonstrates how mathematical optimization is used to find a suitable compromise, a core challenge in modern Electronic Design Automation (EDA).",
            "id": "4264757",
            "problem": "In the context of Integrated Circuit (IC) design using Electronic Design Automation (EDA), the Gajski-Kuhn Y-chart organizes the design space along three complementary axes: behavioral (timing and functionality), structural (netlist and hierarchy), and physical (geometry and placement). Consider a hierarchical block where a single movable standard cell at the structural level connects to three nets. The physical axis allows the cell to be displaced along a single row by a scalar displacement $\\delta$, which changes each net’s Manhattan wirelength linearly with $\\delta$. The behavioral axis mandates timing closure, which we model by linearizing each net’s delay sensitivity with respect to wirelength using a first-order Elmore delay approximation.\n\nAssume that for net $i \\in \\{1,2,3\\}$, the wirelength changes as $l_i(\\delta) = l_i^{0} + a_i \\delta$, where $a_i$ is a known geometry factor (in units of length change per unit displacement). The incremental timing penalty per unit change in wirelength for net $i$ is a constant sensitivity $s_i$ (in time per unit length), obtained from a local linearization of Elmore delay around the current operating point. A common multi-objective placement objective that balances behavioral timing and physical wirelength is a convex combination with weight $\\lambda \\in [0,1]$:\n$$\nJ(\\delta;\\lambda) = \\lambda \\sum_{i=1}^{3} s_i\\, l_i(\\delta) + (1-\\lambda)\\sum_{i=1}^{3} l_i(\\delta).\n$$\nTo focus on the trade-off and avoid irrelevant constants, consider the incremental objective relative to the current placement, which removes terms independent of $\\delta$.\n\nYou are given three nets with geometry factors and timing sensitivities:\n$$\na_1 = 1,\\quad a_2 = -2,\\quad a_3 = \\frac{1}{2},\\qquad s_1 = 4,\\quad s_2 = 1,\\quad s_3 = 2.\n$$\nThe displacement is physically bounded by placement constraints as $\\delta \\in [-\\Delta,\\Delta]$ for some $\\Delta > 0$, but the bound is not needed to determine the weight at which timing and wirelength are exactly balanced in the simplified linear model.\n\nStarting from well-tested facts and core definitions appropriate to the Y-chart axes (Manhattan wirelength, first-order Elmore delay linearization, and convex multi-objective weighting), formulate the incremental objective and determine the value of the trade-off weight $\\lambda^{\\star}$ for which the linear coefficient of $\\delta$ in the incremental objective vanishes. This value represents the exact balance between timing and wirelength so that the optimum does not push to the boundaries $-\\Delta$ or $\\Delta$ under the linear model.\n\nExpress your final answer for $\\lambda^{\\star}$ as a single exact number. No units are required.",
            "solution": "The problem requires finding the trade-off weight $\\lambda^{\\star}$ that balances the linear contributions of timing and wirelength to a multi-objective cost function in integrated circuit placement. This balance is achieved when the derivative of the cost function with respect to the displacement $\\delta$ is zero, or equivalently, when the linear coefficient of $\\delta$ in the incremental objective function vanishes.\n\nThe total objective function $J(\\delta;\\lambda)$ is given as a convex combination of a timing-related term and a wirelength-related term:\n$$\nJ(\\delta;\\lambda) = \\lambda \\sum_{i=1}^{3} s_i\\, l_i(\\delta) + (1-\\lambda)\\sum_{i=1}^{3} l_i(\\delta)\n$$\nwhere $\\lambda \\in [0,1]$ is the trade-off weight, $l_i(\\delta)$ is the wirelength of net $i$, and $s_i$ is its timing sensitivity.\n\nThe wirelength for each net $i$ is modeled as a linear function of the displacement $\\delta$:\n$$\nl_i(\\delta) = l_i^{0} + a_i \\delta\n$$\nHere, $l_i^{0}$ is the initial wirelength at $\\delta=0$, and $a_i$ is the geometric factor representing the change in wirelength per unit displacement.\n\nWe substitute the expression for $l_i(\\delta)$ into the objective function $J(\\delta;\\lambda)$:\n$$\nJ(\\delta;\\lambda) = \\lambda \\sum_{i=1}^{3} s_i (l_i^{0} + a_i \\delta) + (1-\\lambda)\\sum_{i=1}^{3} (l_i^{0} + a_i \\delta)\n$$\nWe can distribute the sums and separate terms that are constant with respect to $\\delta$ from those that are linear in $\\delta$:\n$$\nJ(\\delta;\\lambda) = \\lambda \\left( \\sum_{i=1}^{3} s_i l_i^{0} + \\delta \\sum_{i=1}^{3} s_i a_i \\right) + (1-\\lambda) \\left( \\sum_{i=1}^{3} l_i^{0} + \\delta \\sum_{i=1}^{3} a_i \\right)\n$$\nRearranging the terms to group coefficients of $\\delta$:\n$$\nJ(\\delta;\\lambda) = \\left( \\lambda \\sum_{i=1}^{3} s_i l_i^{0} + (1-\\lambda) \\sum_{i=1}^{3} l_i^{0} \\right) + \\delta \\left( \\lambda \\sum_{i=1}^{3} s_i a_i + (1-\\lambda) \\sum_{i=1}^{3} a_i \\right)\n$$\nThe first term is the value of the objective function at $\\delta=0$, which is $J(0;\\lambda)$. The incremental objective, which captures the change from the initial state, is the term linear in $\\delta$. The problem states we are looking for the value of $\\lambda$, denoted $\\lambda^{\\star}$, for which the linear coefficient of $\\delta$ vanishes. Let's call this coefficient $C(\\lambda)$:\n$$\nC(\\lambda) = \\lambda \\sum_{i=1}^{3} s_i a_i + (1-\\lambda) \\sum_{i=1}^{3} a_i\n$$\nSetting this coefficient to zero, $C(\\lambda^{\\star}) = 0$, gives the condition for the balance point:\n$$\n\\lambda^{\\star} \\sum_{i=1}^{3} s_i a_i + (1-\\lambda^{\\star}) \\sum_{i=1}^{3} a_i = 0\n$$\nTo solve for $\\lambda^{\\star}$, we first compute the two sums using the provided data:\nThe geometric factors are $a_1=1$, $a_2=-2$, and $a_3=\\frac{1}{2}$.\nThe timing sensitivities are $s_1=4$, $s_2=1$, and $s_3=2$.\n\nFirst, we compute the sum of the geometric factors, $\\sum_{i=1}^{3} a_i$:\n$$\n\\sum_{i=1}^{3} a_i = a_1 + a_2 + a_3 = 1 + (-2) + \\frac{1}{2} = -1 + \\frac{1}{2} = -\\frac{1}{2}\n$$\nNext, we compute the weighted sum $\\sum_{i=1}^{3} s_i a_i$:\n$$\n\\sum_{i=1}^{3} s_i a_i = s_1 a_1 + s_2 a_2 + s_3 a_3 = (4)(1) + (1)(-2) + (2)\\left(\\frac{1}{2}\\right) = 4 - 2 + 1 = 3\n$$\nNow, we substitute these numerical values back into the equation for $\\lambda^{\\star}$:\n$$\n\\lambda^{\\star} (3) + (1-\\lambda^{\\star}) \\left(-\\frac{1}{2}\\right) = 0\n$$\nWe solve this linear equation for $\\lambda^{\\star}$:\n$$\n3\\lambda^{\\star} - \\frac{1}{2} + \\frac{1}{2}\\lambda^{\\star} = 0\n$$\n$$\n\\left(3 + \\frac{1}{2}\\right)\\lambda^{\\star} = \\frac{1}{2}\n$$\n$$\n\\left(\\frac{6}{2} + \\frac{1}{2}\\right)\\lambda^{\\star} = \\frac{1}{2}\n$$\n$$\n\\frac{7}{2}\\lambda^{\\star} = \\frac{1}{2}\n$$\n$$\n\\lambda^{\\star} = \\frac{1}{2} \\cdot \\frac{2}{7} = \\frac{1}{7}\n$$\nThis value $\\lambda^{\\star} = \\frac{1}{7}$ is within the valid range $[0,1]$. It represents the specific weighting where the linear drive from the timing objective is exactly cancelled by the linear drive from the wirelength objective, resulting in a stationary point at $\\delta=0$ within this simplified linear model.",
            "answer": "$$\\boxed{\\frac{1}{7}}$$"
        }
    ]
}