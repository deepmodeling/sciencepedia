{
    "hands_on_practices": [
        {
            "introduction": "A critical task in IC design is ensuring the logic can operate at the target clock frequency, $f_{\\text{clk}}$. This often involves pipelining, the insertion of registers to break up long combinational logic paths. This practice  challenges you to apply the fundamental setup timing equation to determine the minimum number of pipeline registers needed to meet a given performance target, a core skill in high-performance digital design.",
            "id": "4276652",
            "problem": "In a synchronous Integrated Circuit (IC) synthesized and implemented using Electronic Design Automation (EDA) tools, consider a single-clock-domain combinational block that is currently placed between upstream launch registers and a single downstream capture register. The block is purely combinational and can be split by inserting edge-triggered pipeline registers with negligible wire and insertion overhead. All pipeline registers are identical and characterized by setup time $t_{\\mathrm{su}}$ and clock-to-$Q$ delay $t_{\\mathrm{cq}}$. Global clock uncertainty (including skew and jitter) is $u$. Hold timing is guaranteed by separate means and may be ignored. The target clock has frequency $f_{\\mathrm{clk}}$ (period $T = 1/f_{\\mathrm{clk}}$). The block will be pipelined so that each inter-register segment satisfies single-cycle setup timing under the same clock.\n\nYou are given:\n- Target frequency $f_{\\mathrm{clk}} = 1.25\\,\\text{GHz}$.\n- Register setup time $t_{\\mathrm{su}} = 0.03\\,\\text{ns}$.\n- Register clock-to-$Q$ delay $t_{\\mathrm{cq}} = 0.05\\,\\text{ns}$.\n- Global clock uncertainty $u = 0.04\\,\\text{ns}$.\n- Total combinational delay of the block $D_{\\mathrm{block}} = 1.65\\,\\text{ns}$.\n- Three block inputs arrive from upstream launch registers with known input arrival times at the block boundary relative to the active clock edge: $a_1 = 0.15\\,\\text{ns}$, $a_2 = 0.22\\,\\text{ns}$, $a_3 = 0.18\\,\\text{ns}$. Assume logical effort and reconvergence effects have been properly back-annotated into these arrival times, and that the downstream capture register is the only pre-existing register after the block.\n\nAssume you may place pipeline registers at arbitrary cut points within the block such that the sum of segment delays equals $D_{\\mathrm{block}}$, and that the first segment is driven directly by the block inputs. Using the first principles of synchronous timing (arrival time plus combinational delay plus setup time must not exceed the available clock period after subtracting uncertainty and upstream register latency, where appropriate), derive from these fundamentals the condition for per-stage timing, and compute the minimum number of pipeline registers that must be inserted inside the block so that all inter-register segments meet single-cycle setup timing at $f_{\\mathrm{clk}}$. Provide your final answer as a single integer equal to this minimum number of inserted pipeline registers. No rounding instruction is necessary because the answer is an integer. Do not include any units in your final answer.",
            "solution": "The user-provided problem will first be validated for correctness, consistency, and completeness.\n\n### Step 1: Extract Givens\n-   Target clock frequency: $f_{\\mathrm{clk}} = 1.25\\,\\text{GHz}$\n-   Register setup time: $t_{\\mathrm{su}} = 0.03\\,\\text{ns}$\n-   Register clock-to-Q delay: $t_{\\mathrm{cq}} = 0.05\\,\\text{ns}$\n-   Global clock uncertainty: $u = 0.04\\,\\text{ns}$\n-   Total combinational delay of the block: $D_{\\mathrm{block}} = 1.65\\,\\text{ns}$\n-   Input arrival times at block boundary: $a_1 = 0.15\\,\\text{ns}$, $a_2 = 0.22\\,\\text{ns}$, $a_3 = 0.18\\,\\text{ns}$\n-   Hold timing is guaranteed and may be ignored.\n-   Pipeline registers can be inserted at arbitrary cut points.\n-   The number of registers to be inserted is the quantity to be determined.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is based on the fundamental principles of synchronous digital circuit timing analysis, specifically setup time constraints in pipelined architectures. All concepts ($f_{\\mathrm{clk}}$, $t_{\\mathrm{su}}$, $t_{\\mathrm{cq}}$, clock uncertainty, pipelining) are standard in the field of IC design and EDA.\n2.  **Well-Posed**: The problem is well-posed. It provides all necessary parameters to calculate a unique, integer-valued answer for the minimum number of pipeline registers.\n3.  **Objective**: The language is precise, quantitative, and free of subjective or ambiguous terminology.\n4.  **Completeness and Consistency**: The problem is self-contained and all given values are consistent. There are no contradictions. The assumptions, such as negligible overhead for register insertion, are explicitly stated.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A full, reasoned solution will be provided.\n\n### Solution Derivation\nThe core principle governing the maximum operating frequency of a synchronous circuit is the setup timing constraint. For a data path between a launching register and a capturing register, the total delay of the path must be less than or equal to the available time in one clock cycle.\n\nThe clock period, $T$, is the reciprocal of the clock frequency, $f_{\\mathrm{clk}}$:\n$$T = \\frac{1}{f_{\\mathrm{clk}}} = \\frac{1}{1.25 \\times 10^9\\,\\text{Hz}} = 0.8\\,\\text{ns}$$\n\nLet $N$ be the minimum number of pipeline registers to be inserted. Inserting $N$ registers divides the combinational block of total delay $D_{\\mathrm{block}}$ into $N+1$ segments. Let the delays of these segments be $D_1, D_2, \\dots, D_{N+1}$ such that:\n$$\\sum_{i=1}^{N+1} D_i = D_{\\mathrm{block}} = 1.65\\,\\text{ns}$$\n\nWe must derive the timing constraint for each segment.\n\n**1. Timing Constraint for Internal and Final Segments**\nConsider a segment of combinational logic with delay $D_i$ (for $i \\ge 2$) situated between two registers (an inserted pipeline register launching the data and another register capturing it). The signal is launched from the first register after the clock edge, propagates through the logic, and must arrive at the second register's input and be stable for the setup time $t_{\\mathrm{su}}$ before the next clock edge arrives. The standard setup timing equation is:\n$$t_{\\mathrm{cq}} + D_i + t_{\\mathrm{su}} + u \\le T$$\nHere, $t_{\\mathrm{cq}}$ is the clock-to-Q delay of the launching register, $D_i$ is the combinational path delay, $t_{\\mathrm{su}}$ is the setup time of the capturing register, and $u$ is the clock uncertainty which reduces the effective clock period. This constraint applies to all segments from the first inserted register onwards, i.e., for $i=2, 3, \\dots, N+1$.\n\nFrom this, we can calculate the maximum allowable combinational delay for these segments, which we denote as $D_{\\mathrm{int, max}}$:\n$$D_{\\mathrm{int, max}} = T - t_{\\mathrm{cq}} - t_{\\mathrm{su}} - u$$\n$$D_{\\mathrm{int, max}} = 0.8\\,\\text{ns} - 0.05\\,\\text{ns} - 0.03\\,\\text{ns} - 0.04\\,\\text{ns} = 0.68\\,\\text{ns}$$\n\n**2. Timing Constraint for the First Segment**\nThe first segment, with delay $D_1$, is different. It is not driven by one of the inserted pipeline registers. Instead, its inputs are the primary inputs to the block, which arrive at specified times after the clock edge. The worst-case (latest) arrival time at the block's input pins determines the timing constraint. Let this be $a_{\\max}$.\n$$a_{\\max} = \\max(a_1, a_2, a_3) = \\max(0.15\\,\\text{ns}, 0.22\\,\\text{ns}, 0.18\\,\\text{ns}) = 0.22\\,\\text{ns}$$\nThis arrival time $a_{\\max}$ effectively replaces the $t_{\\mathrm{cq}}$ of a launching register in the timing-path calculation. The signal arrives at the input of the first pipeline register at time $a_{\\max} + D_1$ relative to the clock edge. The setup constraint for this first capture register is:\n$$(a_{\\max} + D_1) + t_{\\mathrm{su}} + u \\le T$$\nThe maximum allowable delay for this first segment, $D_{1, \\max}$, is therefore:\n$$D_{1, \\max} = T - a_{\\max} - t_{\\mathrm{su}} - u$$\n$$D_{1, \\max} = 0.8\\,\\text{ns} - 0.22\\,\\text{ns} - 0.03\\,\\text{ns} - 0.04\\,\\text{ns} = 0.51\\,\\text{ns}$$\n\n**3. Calculating the Minimum Number of Registers**\nWe need to partition the total block delay $D_{\\mathrm{block}} = 1.65\\,\\text{ns}$ into $N+1$ segments, where the first segment has a maximum delay of $D_{1, \\max} = 0.51\\,\\text{ns}$, and the subsequent $N$ segments each have a maximum delay of $D_{\\mathrm{int, max}} = 0.68\\,\\text{ns}$.\nTo successfully pipeline the block, the sum of the maximum possible delays of the $N+1$ segments must be greater than or equal to the total block delay.\n$$D_{\\mathrm{block}} \\le D_{1, \\max} + N \\times D_{\\mathrm{int, max}}$$\nWe can now solve for the minimum integer $N$:\n$$1.65 \\le 0.51 + N \\times 0.68$$\n$$1.65 - 0.51 \\le N \\times 0.68$$\n$$1.14 \\le N \\times 0.68$$\n$$N \\ge \\frac{1.14}{0.68}$$\n$$N \\ge 1.67647...$$\nSince a fractional number of registers cannot be inserted, we must take the ceiling of this value. The minimum integer number of registers required is:\n$$N = \\lceil 1.67647... \\rceil = 2$$\n\nTherefore, a minimum of $2$ pipeline registers must be inserted. This creates $3$ combinational segments. We can verify this is possible:\n-   Segment 1 delay: $D_1 \\le 0.51\\,\\text{ns}$\n-   Segment 2 delay: $D_2 \\le 0.68\\,\\text{ns}$\n-   Segment 3 delay: $D_3 \\le 0.68\\,\\text{ns}$\nTotal delay required: $D_1+D_2+D_3 = 1.65\\,\\text{ns}$.\nA valid partitioning exists, for example: $D_1=0.51\\,\\text{ns}$, $D_2=0.68\\,\\text{ns}$, and $D_3 = 1.65 - 0.51 - 0.68 = 0.46\\,\\text{ns}$. Since $0.46\\,\\text{ns} \\le 0.68\\,\\text{ns}$, this is a valid solution.",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "Once the logic is synthesized, the next major step is physical design, beginning with cell placement. This hands-on exercise  guides you through implementing a quadratic placement algorithm, a cornerstone of modern Electronic Design Automation (EDA) tools. You will model the netlist as a system of springs and use convex optimization to find cell locations that minimize a proxy for wirelength, providing a tangible understanding of how an abstract netlist is transformed into a physical layout.",
            "id": "4276612",
            "problem": "You are given a simplified placement subproblem that appears in the physical implementation stage of the Integrated Circuit (IC) design flow from specification to Graphic Data System II (GDSII). In Electronic Design Automation (EDA), quadratic placement is a well-studied convex optimization approach for minimizing a proxy for wirelength, informed by timing-critical net weights. Starting from first principles, you must derive a convex quadratic formulation and compute updated cell coordinates that minimize the weighted wirelength proxy under anchoring constraints.\n\nFundamental base and assumptions:\n- The placement cost is modeled by connecting pairs of cells with linear springs. By Hooke’s law, the elastic potential energy of a spring is proportional to the square of its extension. This motivates a quadratic energy term for each pairwise connection between cells.\n- The total cost function is the sum of quadratic energy terms over all pairwise connections and quadratic anchor terms that softly tie cells to fixed coordinates. You may assume all connection weights are nonnegative to ensure convexity.\n- The convexity of a quadratic form is determined by the positive semidefiniteness of its Hessian. For a graph-based quadratic energy generated by a nonnegative weighted adjacency, the corresponding graph Laplacian is positive semidefinite. Adding nonnegative diagonal anchor weights yields a positive definite matrix when at least one anchor exists per connected component, ensuring a unique minimizer.\n- You must derive the minimizer by setting the gradient of the total cost to zero and solving the resulting linear system for both spatial dimensions independently.\n\nDefinitions:\n- Let there be $n$ movable cells indexed as $i \\in \\{0,1,\\dots,n-1\\}$ with unknown coordinates $(x_i,y_i)$ in micrometers.\n- Let $\\mathcal{E}$ be the set of undirected pairwise connections $(i,j)$ with timing-critical net weights $w_{ij} \\ge 0$. Each pair contributes a quadratic term that penalizes the squared distance between cells.\n- Let $\\alpha_i \\ge 0$ be the anchor weight for cell $i$, and $(x_i^\\star,y_i^\\star)$ be the preferred anchor position in micrometers. The anchor term penalizes deviation from this target position.\n\nTasks:\n1. Using Hooke’s law for spring energy and the properties of convex quadratic forms, derive a placement objective as a sum of quadratic terms for pairwise connections and anchors. Prove the objective is convex under the stated assumptions.\n2. Derive the necessary conditions for optimality by setting the gradient of the objective to zero. Show that the optimal coordinates must satisfy a linear system in each dimension. Explain under what conditions the system has a unique solution.\n3. Implement a program that, for the provided test suite, constructs the appropriate linear systems for $x$- and $y$-coordinates and computes the minimizers. Express all coordinates in micrometers. Round every reported coordinate to six decimal places.\n\nInput representation for the test suite (hard-coded in your program):\n- Each test case is a tuple $(n, \\text{edges}, \\text{anchors})$ where:\n  - $n$ is the number of cells (an integer).\n  - $\\text{edges}$ is a list of triples $(i,j,w)$ with $i \\ne j$, $0 \\le i,j < n$, and $w \\ge 0$ representing pairwise connections and their weights.\n  - $\\text{anchors}$ is a list of quadruples $(i,\\alpha,x_i^\\star,y_i^\\star)$ with $0 \\le i < n$, $\\alpha \\ge 0$, and $(x_i^\\star,y_i^\\star)$ in micrometers.\n\nTest suite:\n- Test case 1 (connected graph, endpoints anchored):\n  - $n = 4$\n  - $\\text{edges} = [(0,1,3.0),(1,2,2.0),(2,3,4.0),(0,3,0.5)]$\n  - $\\text{anchors} = [(0,10.0,0.0,0.0),(3,10.0,100.0,0.0)]$\n- Test case 2 (disconnected graph with one anchor per component):\n  - $n = 5$\n  - $\\text{edges} = [(0,1,5.0),(2,3,1.0),(3,4,1.0)]$\n  - $\\text{anchors} = [(0,20.0,0.0,0.0),(2,20.0,50.0,50.0)]$\n- Test case 3 (heavy timing-critical weight dominating geometry):\n  - $n = 3$\n  - $\\text{edges} = [(0,1,100.0),(1,2,1.0)]$\n  - $\\text{anchors} = [(0,5.0,0.0,0.0),(2,5.0,200.0,0.0)]$\n\nOutput requirements:\n- For each test case, output the list of cell coordinates in ascending cell index order, with each coordinate pair $[x_i,y_i]$ rounded to six decimal places. Units must be micrometers.\n- Aggregate the results of all test cases into a single line in the exact format: a comma-separated list enclosed in square brackets, where each element is itself a list of coordinate pairs for one test case. There must be no whitespace characters in the output. For example, a valid output structure is:\n  - $[[[x_0,y_0],[x_1,y_1],\\dots],[[x_0,y_0],\\dots],[[x_0,y_0],\\dots]]$\n- All numbers must be represented as decimals, rounded to six decimal places.\n\nYour program must produce the single line of output containing the aggregated results in the specified format and must not read any input. The program must be complete and runnable.",
            "solution": "We begin by modeling the placement cost using springs between connected cells and soft anchors tying certain cells to preferred positions. The fundamental base is Hooke’s law, which states that the elastic potential energy stored in a spring is proportional to the square of the extension. For a connection between cell $i$ and cell $j$ with weight $w_{ij} \\ge 0$, the energy term for the $x$-coordinates is $w_{ij}(x_i - x_j)^2$, and similarly for the $y$-coordinates is $w_{ij}(y_i - y_j)^2$. For anchoring, a soft penalty is added that penalizes the deviation from the preferred coordinates $(x_i^\\star, y_i^\\star)$ using weights $\\alpha_i \\ge 0$, resulting in $\\alpha_i (x_i - x_i^\\star)^2$ and $\\alpha_i (y_i - y_i^\\star)^2$.\n\nLet $x \\in \\mathbb{R}^n$ collect the $x$-coordinates and $y \\in \\mathbb{R}^n$ collect the $y$-coordinates. The total objective function is the sum over the graph edges and anchors in each dimension. For the $x$-dimension,\n$$\nF_x(x) = \\sum_{(i,j)\\in \\mathcal{E}} w_{ij}(x_i - x_j)^2 + \\sum_{i=0}^{n-1} \\alpha_i (x_i - x_i^\\star)^2.\n$$\nSimilarly for the $y$-dimension,\n$$\nF_y(y) = \\sum_{(i,j)\\in \\mathcal{E}} w_{ij}(y_i - y_j)^2 + \\sum_{i=0}^{n-1} \\alpha_i (y_i - y_i^\\star)^2.\n$$\nThe full cost is $F(x,y) = F_x(x) + F_y(y)$, and the two dimensions decouple, so each can be minimized independently.\n\nConvexity: Each term $w_{ij}(x_i - x_j)^2$ is a convex quadratic because $w_{ij}\\ge 0$. Summing convex functions preserves convexity. The anchor terms $\\alpha_i (x_i - x_i^\\star)^2$ are also convex when $\\alpha_i \\ge 0$. Therefore $F_x$ and $F_y$ are convex. In matrix form, define the weighted graph Laplacian $L \\in \\mathbb{R}^{n \\times n}$ built from the pairwise weights:\n- $L_{ii} = \\sum_{j:(i,j)\\in \\mathcal{E}} w_{ij}$,\n- $L_{ij} = -w_{ij}$ for $i \\ne j$ and $(i,j)\\in \\mathcal{E}$, otherwise $0$.\nAdd the diagonal anchor matrix $A = \\operatorname{diag}(\\alpha_0,\\dots,\\alpha_{n-1})$ to the Laplacian to capture anchors. The Hessian of $F_x$ is $H_x = 2(L + A)$ and analogously $H_y = 2(L + A)$. Graph Laplacians with nonnegative weights are positive semidefinite. Adding the nonnegative diagonal $A$ keeps positive semidefiniteness and becomes positive definite when for each connected component at least one $\\alpha_i > 0$. Positive definiteness implies strict convexity and a unique minimizer.\n\nOptimality conditions: Set the gradient to zero. For $F_x$,\n$$\n\\nabla F_x(x) = 2(L + A)x - 2b_x = 0,\n$$\nwhere $b_x = A x^\\star$ and $x^\\star$ collects anchor targets $(x_i^\\star)$. Therefore, the normal equations are\n$$\n(L + A)x = b_x.\n$$\nSimilarly, for $F_y$,\n$$\n(L + A)y = b_y,\n$$\nwith $b_y = A y^\\star$. When $L + A$ is positive definite (for example, one anchor per connected component), these linear systems have unique solutions.\n\nAlgorithmic design:\n1. Construct the Laplacian $L$ from the edge list. Initialize $L$ as a zero matrix. For each edge $(i,j,w)$ with $w \\ge 0$, update $L_{ii} \\mathrel{+}= w$, $L_{jj} \\mathrel{+}= w$, and $L_{ij} \\mathrel{-}= w$, $L_{ji} \\mathrel{-}= w$.\n2. Construct the anchor matrix $A$ as a diagonal with entries $\\alpha_i$. Also form the vectors $x^\\star$ and $y^\\star$ of anchor positions, and compute $b_x = A x^\\star$ and $b_y = A y^\\star$.\n3. Form $M = L + A$ and solve the two linear systems $Mx = b_x$ and $My = b_y$. Solve using a direct solver, since $M$ is symmetric positive definite under the stated conditions. Round each coordinate to six decimal places.\n4. Repeat for each test case, collect the ordered list of coordinate pairs $[x_i,y_i]$ for $i=0,\\dots,n-1$, and aggregate them into the specified single-line output format without spaces.\n\nUniqueness conditions: If a connected component has no anchors (all $\\alpha_i = 0$), then $M$ is singular on that component because the Laplacian has a nullspace spanned by the constant vector on the component. At least one $\\alpha_i > 0$ per component ensures $M$ is positive definite and the solution is unique.\n\nUnits and formatting: All coordinates are in micrometers. The final output must be a single line containing a comma-separated list of test case results enclosed in square brackets. Each test case result is itself a list of $n$ coordinate pairs $[x_i,y_i]$ in ascending cell index order, with numbers rounded to six decimal places, and no whitespace characters anywhere in the output line.\n\nThis procedure produces updated cell coordinates that minimize the convex quadratic proxy for weighted wirelength under timing-guided weights and soft anchoring, consistent with quadratic placement in the IC design flow from specification to Graphic Data System II (GDSII).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_quadratic_placement(n, edges, anchors):\n    \"\"\"\n    Solve (L + A) x = A x_star and (L + A) y = A y_star for placement coordinates.\n    n: number of cells\n    edges: list of (i, j, w) with w >= 0\n    anchors: list of (i, alpha, x_star, y_star)\n    Returns: list of [x_i, y_i] for i=0..n-1, rounded to 6 decimals\n    \"\"\"\n    # Build Laplacian L\n    L = np.zeros((n, n), dtype=float)\n    for i, j, w in edges:\n        if i == j:\n            continue\n        # Nonnegative weights expected; enforce nonnegativity for robustness\n        w = float(max(0.0, w))\n        L[i, i] += w\n        L[j, j] += w\n        L[i, j] -= w\n        L[j, i] -= w\n\n    # Build anchor matrix A and target vectors x_star, y_star\n    A_diag = np.zeros(n, dtype=float)\n    x_star = np.zeros(n, dtype=float)\n    y_star = np.zeros(n, dtype=float)\n    for i, alpha, xs, ys in anchors:\n        a = float(max(0.0, alpha))\n        A_diag[i] += a\n        x_star[i] = float(xs)\n        y_star[i] = float(ys)\n\n    # Form M = L + A\n    M = L.copy()\n    for i in range(n):\n        M[i, i] += A_diag[i]\n\n    # Right hand sides b_x = A x_star, b_y = A y_star\n    b_x = A_diag * x_star\n    b_y = A_diag * y_star\n\n    # Solve linear systems; M should be positive definite if each component is anchored\n    # Use numpy.linalg.solve; for safety, if singular is detected, add tiny regularization\n    def safe_solve(M, b):\n        try:\n            return np.linalg.solve(M, b)\n        except np.linalg.LinAlgError:\n            eps = 1e-9\n            M_reg = M + np.eye(M.shape[0]) * eps\n            return np.linalg.solve(M_reg, b)\n\n    x = safe_solve(M, b_x)\n    y = safe_solve(M, b_y)\n\n    # Round to six decimals and return as list of [x_i, y_i]\n    coords = [[float(f\"{xi:.6f}\"), float(f\"{yi:.6f}\")] for xi, yi in zip(x, y)]\n    return coords\n\ndef format_no_spaces(nested):\n    \"\"\"\n    Format a nested Python list into a string with no spaces,\n    preserving brackets and commas, with numbers as decimals.\n    \"\"\"\n    def format_elem(e):\n        if isinstance(e, list):\n            return \"[\" + \",\".join(format_elem(x) for x in e) + \"]\"\n        else:\n            # Ensure float formatting to exactly six decimals if float\n            if isinstance(e, float):\n                return f\"{e:.6f}\"\n            elif isinstance(e, int):\n                return str(e)\n            else:\n                # Fallback: try float conversion\n                try:\n                    val = float(e)\n                    return f\"{val:.6f}\"\n                except Exception:\n                    return str(e)\n    return format_elem(nested)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: connected graph, endpoints anchored\n        (\n            4,\n            [(0, 1, 3.0), (1, 2, 2.0), (2, 3, 4.0), (0, 3, 0.5)],\n            [(0, 10.0, 0.0, 0.0), (3, 10.0, 100.0, 0.0)]\n        ),\n        # Test case 2: disconnected graph with one anchor per component\n        (\n            5,\n            [(0, 1, 5.0), (2, 3, 1.0), (3, 4, 1.0)],\n            [(0, 20.0, 0.0, 0.0), (2, 20.0, 50.0, 50.0)]\n        ),\n        # Test case 3: heavy timing-critical weight dominating geometry\n        (\n            3,\n            [(0, 1, 100.0), (1, 2, 1.0)],\n            [(0, 5.0, 0.0, 0.0), (2, 5.0, 200.0, 0.0)]\n        ),\n    ]\n\n    results = []\n    for n, edges, anchors in test_cases:\n        coords = solve_quadratic_placement(n, edges, anchors)\n        results.append(coords)\n\n    # Final print statement in the exact required format (no whitespace).\n    print(format_no_spaces(results))\n\nsolve()\n```"
        },
        {
            "introduction": "After a design is physically routed, its timing must be verified in a process called Static Timing Analysis (STA), which accounts for the delay of the physical wires. This practice  delves into this stage by asking you to calculate the interconnect delay using the Elmore delay model. This exercise provides a concrete understanding of how the resistance ($R$) and capacitance ($C$) of wires contribute to the total path delay, a critical factor in signing off a chip for manufacturing.",
            "id": "4276646",
            "problem": "In a post-route Static Timing Analysis (STA) stage of an Integrated Circuit (IC) design flow leading to Graphic Data System II (GDSII) tapeout within Electronic Design Automation (EDA), consider a single-source, single-sink interconnect modeled as a linear resistor-capacitor tree driven by a logic gate that is abstracted as a Thevenin source with output resistance. The delay metric used for the interconnect is defined as the first moment of the impulse response at the sink node of the linear time-invariant network. The routed net is a chain with series resistances and shunt capacitances to ground at intermediate nodes and the sink input.\n\nAssume the following model and data are obtained from signoff parasitic extraction:\n- The driver is modeled by an equivalent Thevenin resistance $R_{0}$ at the source node, with $R_{0} = 120$.\n- The wire is segmented into three series resistors $R_{1}$, $R_{2}$, $R_{3}$ along the unique path to the sink, with $R_{1} = 35$, $R_{2} = 50$, $R_{3} = 20$.\n- The shunt capacitances to ground at the nodes after $R_{1}$, after $R_{2}$, and at the sink are $C_{1} = 15 \\times 10^{-15}$, $C_{2} = 28 \\times 10^{-15}$, and $C_{3} = 52 \\times 10^{-15}$, respectively.\n- The intrinsic input-to-output propagation delay of the driving logic cell is $t_{\\text{drv,int}} = 23 \\times 10^{-12}$, and the intrinsic propagation delay of the receiving logic cell (from its input pin to its output pin, excluding interconnect) is $t_{\\text{snk,int}} = 21 \\times 10^{-12}$.\n\nStarting from the definition of the first moment of the impulse response of a linear resistor-capacitor network at the sink node (no shortcut formulas are to be used in the problem statement), derive an analytical expression for the interconnect delay of this topology using only fundamental properties of linear time-invariant networks and the tree structure of the interconnect. Then evaluate this interconnect delay numerically in seconds and compare it to the sum of the two cell intrinsic delays on the critical path by forming the ratio\n$$\n\\rho \\equiv \\frac{t_{\\text{wire}}}{t_{\\text{drv,int}} + t_{\\text{snk,int}}}.\n$$\nReport only the single number $\\rho$ as a unitless decimal, rounded to four significant figures.",
            "solution": "The problem requires the calculation of a ratio $\\rho$ involving the interconnect delay of a specified RC network. The interconnect delay, $t_{\\text{wire}}$, is defined as the first moment of the impulse response at the sink node. This problem is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. Therefore, the problem is valid.\n\nThe interconnect is modeled as a linear resistor-capacitor (RC) chain driven by a Thevenin equivalent source. The network consists of a source resistance $R_{0}$, followed by three segments of wire with resistances $R_{1}$, $R_{2}$, and $R_{3}$. Shunt capacitances $C_{1}$, $C_{2}$, and $C_{3}$ are located at the nodes following $R_{1}$, $R_{2}$, and $R_{3}$ (the sink), respectively.\n\nLet the nodes of the interconnect be numbered as follows: node $1$ is the junction between $R_{1}$ and $R_{2}$ (where $C_{1}$ is connected), node $2$ is the junction between $R_{2}$ and $R_{3}$ (where $C_{2}$ is connected), and node $3$ is the sink node (where $C_{3}$ is connected). The input source is connected to the beginning of the chain, and its resistance $R_{0}$ is considered part of the signal path.\n\nThe interconnect delay, $t_{\\text{wire}}$, is defined as the first moment of the impulse response, $h_3(t)$, at the sink (node $3$). Mathematically, this is expressed as:\n$$\nt_{\\text{wire}} = \\int_{0}^{\\infty} t h_3(t) dt\n$$\nFor a linear time-invariant (LTI) system, the first moment of the impulse response can be calculated from its Laplace-domain transfer function, $H(s)$. If $H_3(s)$ is the transfer function from the input of the network to the voltage at node $3$, then the first moment is given by:\n$$\nt_{\\text{wire}} = - \\frac{dH_3(s)}{ds} \\bigg|_{s=0}\n$$\nThis quantity is known as the Elmore delay. A fundamental result for RC tree networks, established by W. C. Elmore, states that the delay at a specific node $i$ is given by the sum of the products of each capacitance in the network and the resistance of the path from the source that is common to both that capacitor's node and node $i$.\n\nFor the given linear chain topology, which is a special case of a tree, the sink is node $3$. We apply the Elmore delay formula to find $t_{\\text{wire}}$. The formula for the delay at node $i$ is $\\tau_i = \\sum_{k} R_{ik} C_k$, where $C_k$ is the capacitance at node $k$ and $R_{ik}$ is the resistance of the common path from the source to both node $i$ and node $k$. In our case, $i=3$.\n\nThe path resistances for each capacitor are as follows:\n$1.$ The capacitor is $C_{1}$ at node $1$. The path from the source to node $3$ is through resistances $R_{0}$, $R_{1}$, $R_{2}$, and $R_{3}$. The path from the source to node $1$ is through resistances $R_{0}$ and $R_{1}$. The common path resistance is $R_{31} = R_{0} + R_{1}$.\n$2.$ The capacitor is $C_{2}$ at node $2$. The path from the source to node $3$ is through $R_{0}$, $R_{1}$, $R_{2}$, and $R_{3}$. The path from the source to node $2$ is through $R_{0}$, $R_{1}$, and $R_{2}$. The common path resistance is $R_{32} = R_{0} + R_{1} + R_{2}$.\n$3.$ The capacitor is $C_{3}$ at node $3$. The path from the source to node $3$ is through $R_{0}$, $R_{1}$, $R_{2}$, and $R_{3}$. The path from the source to node $3$ is itself. The common path resistance is $R_{33} = R_{0} + R_{1} + R_{2} + R_{3}$.\n\nThus, the analytical expression for the interconnect delay $t_{\\text{wire}}$ is:\n$$\nt_{\\text{wire}} = R_{31} C_{1} + R_{32} C_{2} + R_{33} C_{3}\n$$\n$$\nt_{\\text{wire}} = (R_{0} + R_{1})C_{1} + (R_{0} + R_{1} + R_{2})C_{2} + (R_{0} + R_{1} + R_{2} + R_{3})C_{3}\n$$\nNow we substitute the given numerical values. All calculations will be performed in base SI units (Ohms, Farads, Seconds).\nGiven:\n$R_{0} = 120$\n$R_{1} = 35$\n$R_{2} = 50$\n$R_{3} = 20$\n$C_{1} = 15 \\times 10^{-15}$\n$C_{2} = 28 \\times 10^{-15}$\n$C_{3} = 52 \\times 10^{-15}$\n$t_{\\text{drv,int}} = 23 \\times 10^{-12}$\n$t_{\\text{snk,int}} = 21 \\times 10^{-12}$\n\nFirst, calculate the path resistances:\n$R_{31} = R_{0} + R_{1} = 120 + 35 = 155$\n$R_{32} = R_{0} + R_{1} + R_{2} = 120 + 35 + 50 = 205$\n$R_{33} = R_{0} + R_{1} + R_{2} + R_{3} = 120 + 35 + 50 + 20 = 225$\n\nNext, calculate the individual delay components:\nTerm $1$: $(155) \\times (15 \\times 10^{-15}) = 2325 \\times 10^{-15} = 2.325 \\times 10^{-12}$\nTerm $2$: $(205) \\times (28 \\times 10^{-15}) = 5740 \\times 10^{-15} = 5.740 \\times 10^{-12}$\nTerm $3$: $(225) \\times (52 \\times 10^{-15}) = 11700 \\times 10^{-15} = 11.700 \\times 10^{-12}$\n\nSumming these components gives the total interconnect delay $t_{\\text{wire}}$:\n$$\nt_{\\text{wire}} = (2.325 + 5.740 + 11.700) \\times 10^{-12} = 19.765 \\times 10^{-12}\n$$\nThe problem asks for the ratio $\\rho = \\frac{t_{\\text{wire}}}{t_{\\text{drv,int}} + t_{\\text{snk,int}}}$.\nFirst, calculate the denominator, which is the sum of the intrinsic cell delays:\n$$\nt_{\\text{drv,int}} + t_{\\text{snk,int}} = (23 \\times 10^{-12}) + (21 \\times 10^{-12}) = 44 \\times 10^{-12}\n$$\nNow, compute the ratio $\\rho$:\n$$\n\\rho = \\frac{19.765 \\times 10^{-12}}{44 \\times 10^{-12}} = \\frac{19.765}{44} \\approx 0.449204545...\n$$\nRounding the result to four significant figures, as requested, gives:\n$$\n\\rho \\approx 0.4492\n$$\nThis dimensionless ratio compares the delay penalty imposed by the physical interconnect to the intrinsic switching speed of the logic cells themselves. A value less than $1$ indicates that the wire delay is smaller than the combined intrinsic cell delays on this path segment.",
            "answer": "$$\\boxed{0.4492}$$"
        }
    ]
}