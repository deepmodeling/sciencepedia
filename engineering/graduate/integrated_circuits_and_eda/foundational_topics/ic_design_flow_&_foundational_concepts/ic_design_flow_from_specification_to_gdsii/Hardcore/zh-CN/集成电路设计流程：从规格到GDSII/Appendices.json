{
    "hands_on_practices": [
        {
            "introduction": "成功的集成电路设计始于一个稳健的寄存器传输级（RTL）描述。本练习  深入探讨了RTL编码的一个基本方面：阻塞赋值与非阻塞赋值之间的区别。通过分析仿真器如何对同步硬件的并发特性进行建模，您将深刻理解为何非阻塞赋值对于创建可预测且无竞争冒险的时序逻辑至关重要，从而确保您的设计行为与最终的硬件实现相匹配。",
            "id": "4276659",
            "problem": "在从规范到图形数据系统II (GDSII) 的集成电路设计流程中，以硬件描述语言 (HDL) 编写的寄存器传输级 (RTL) 描述必须忠实地实现同步时序逻辑的语义，以便电子设计自动化 (EDA) 工具能够生成与预期行为一致的门级表示。考虑一个同步机，它由一个有限的寄存器集合 $\\{r_i\\}_{i=1}^N$、一个全局时钟信号以及将当前寄存器向量和主输入映射到下一个寄存器输入的组合逻辑组成。设寄存器向量表示为 $\\mathbf{r}(t)$，定义于时间 $t$，并假设在时间 $t_k$ 发生一个上升沿。同步逻辑的一个基本模型要求，对于每个寄存器 $r_i$，其在时钟沿的更新由下式给出\n$$\nr_i(t_k^+) = u_i(t_k^-),\n$$\n其中 $u_i$ 是寄存器 $i$ 的组合输入，作为 $\\mathbf{r}(t)$ 和主输入的函数，而 $t_k^-$ 和 $t_k^+$ 分别表示时钟转换前后的瞬间。组合网络计算\n$$\n\\mathbf{u}(t) = F\\big(\\mathbf{r}(t), \\mathbf{x}(t)\\big),\n$$\n其中 $F$ 是一个定义良好的函数，$\\mathbf{x}(t)$ 是主输入向量，并且所有寄存器在时钟沿并发更新。\n\n在 HDL 中，时钟进程内的赋值语义用于对此硬件行为进行建模。存在两种不同的赋值风格：阻塞式和非阻塞式。它们的仿真语义区别在于，左侧 (LHS) 是在求值后立即更新，还是分别推迟到时钟事件结束时更新。考虑一个包含寄存器 $r_a$ 和 $r_b$ 的两级流水线，由单个上升沿时钟驱动，其预期的次态关系为\n$$\nr_a(t_k^+) = f_a\\big(\\mathbf{r}(t_k^-), \\mathbf{x}(t_k^-)\\big), \\quad r_b(t_k^+) = r_a(t_k^-).\n$$\n在硬件中，$r_b$ 应该在时钟沿捕获 $r_a$ 的前一个值，而不是在同一时钟沿上新计算出的 $r_a$ 的值。\n\n哪个选项正确地阐释了在时序逻辑中使用非阻塞赋值以防止竞争条件，并推导了仿真中所需的排序语义，以保证无论 HDL 进程内部或跨进程的文本顺序如何，所有寄存器 $i$ 都能满足寄存器传输行为\n$$\nr_i(t_k^+) = \\text{rhs}_i\\big(\\mathbf{r}(t_k^-), \\mathbf{x}(t_k^-)\\big)\n$$\n？\n\nA. 非阻塞赋值在每个时钟沿强制执行一个两阶段事件排序：所有右侧 (RHS) 使用 $\\mathbf{r}(t_k^-)$ 和 $\\mathbf{x}(t_k^-)$ 进行采样并排队，而不会立即更新左侧 (LHS)，然后所有 LHS 同时提交以产生 $\\mathbf{r}(t_k^+)$；这将仿真与同步硬件规则 $r_i(t_k^+) = u_i(t_k^-)$ 对齐，并消除了由文本顺序引起的竞争条件。\n\nB. 阻塞赋值是足够的，因为综合工具会将时钟赋值映射到触发器，并且由于门是并发的，仿真器的立即 LHS 更新不影响功能正确性；语句间的文本顺序无关紧要。\n\nC. 在每个时钟进程内对时序赋值进行确定性的拓扑排序（先对上游寄存器赋值，再对下游寄存器赋值）可以再现预期的流水线行为；因此，只要仔细维持排序，非阻塞赋值就是不必要的。\n\nD. 引入故意的时钟偏斜，使得上游寄存器在下游寄存器之前更新，可以让阻塞赋值在仿真过程中匹配硬件行为；这种偏斜保留了逐周期的传输，并在不改变逻辑功能的情况下消除了竞争。\n\nE. 在使用阻塞赋值的同时，通过推断透明锁存器作为级间存储来防止竞争，因为它可以在时钟沿期间保持先前的值；这维持了寄存器传输行为，并使非阻塞语义变得多余。",
            "solution": "问题陈述经严格验证是合理的。它在科学上基于同步数字逻辑设计和硬件描述语言 (HDL) 仿真语义的既定理论。该问题提法得当、客观，并为回答问题提供了完整、自洽的定义和背景。该问题探讨了数字设计中一个重要且基本的概念：如何在顺序执行的仿真环境中正确地为并发硬件行为建模。问题是有效的，并且可以推导出解决方案。\n\n同步时序电路的基本原理是，在一个离散的时钟沿，比如时间 $t_k$，所有状态保持元件（寄存器）同时更新其值。任何给定寄存器的新值 $r_i(t_k^+)$ 仅取决于时钟沿*之前*瞬间的电路寄存器状态 $\\mathbf{r}(t_k^-)$ 和主输入 $\\mathbf{x}(t_k^-)$。这可以正式表述为：\n$$\nr_i(t_k^+) = u_i(t_k^-) = F_i\\big(\\mathbf{r}(t_k^-), \\mathbf{x}(t_k^-)\\big)\n$$\n对于所有寄存器 $i=1, \\dots, N$。关键在于，为每个寄存器 $r_i$ 求其次态函数 $F_i$ 时，使用的是*相同*、一致的“沿前”状态向量 $\\mathbf{r}(t_k^-)$。在同一个时钟周期内，一个寄存器 $r_j$ 更新为 $r_j(t_k^+)$ 不会影响另一个寄存器 $r_i$ 更新为 $r_i(t_k^+)$。\n\nHDL 仿真器作为一个软件程序，是顺序执行语句的。这为模拟硬件的并发性带来了挑战。问题描述了两种赋值类型：阻塞式和非阻塞式。\n\n让我们分析所提供的两级流水线示例，其预期行为是 $r_a(t_k^+) = f_a(\\dots)$ 和 $r_b(t_k^+) = r_a(t_k^-)$。\n如果 HDL 进程中使用阻塞赋值（`=`），左侧 (LHS) 变量会立即更新。考虑以下看似合理但错误的代码：\n`r_a = f_a(...)`\n`r_b = r_a`\n仿真器按顺序执行这些行。\n1. 第一行的右侧 (RHS) 使用沿前值（$\\mathbf{r}(t_k^-)$）进行求值。然后，变量 `r_a` 在仿真器的内存中立即更新为其新值 $r_a(t_k^+)$。\n2. 仿真器前进到第二行。它对 RHS，也就是 `r_a` 进行求值。由于是阻塞赋值，它读取的是 `r_a` *新更新*的值。\n3. 因此，`r_b` 被赋以 $r_a(t_k^+)$ 的值。仿真得到的行为是 $r_b(t_k^+) = r_a(t_k^+)$，这是一个组合逻辑的直通，而不是寄存器传输。这与预期的硬件行为 $r_b(t_k^+) = r_a(t_k^-)$ 相矛盾，并表现为一种仿真竞争条件：结果取决于语句的文本顺序。\n\n非阻塞赋值（`=`）解决了这个问题。HDL 仿真标准（例如，Verilog 的标准）规定了一种分层事件队列机制。对于时钟进程内的非阻塞赋值，在每个时钟事件上实际上会执行一个两阶段的更新：\n1.  **求值阶段**：仿真器对由时钟事件触发的所有非阻塞赋值的 RHS 进行求值。所有 RHS 表达式都使用在仿真时间步开始时（即在 $t_k^-$ 时）存在的变量值进行求值。这些求值的结果被安排更新，但尚未应用。\n    - 对于 `r_a = f_a(...)`，RHS 使用 $\\mathbf{r}(t_k^-)$ 进行求值，结果 $r_a(t_k^+)$ 被调度。\n    - 对于 `r_b = r_a`，RHS `r_a` 被求值。由于尚未提交任何更新，其值仍然是 $r_a(t_k^-)$。该值被调度为 `r_b` 的新值。\n2.  **提交/更新阶段**：在当前时间步中所有 RHS 求值完成后，仿真器将所有已调度的更新提交到各自的 LHS 变量。`r_a` 变为 $r_a(t_k^+)$，`r_b` 变为 $r_a(t_k^-)$。\n\n这种两阶段机制确保了在同一时钟周期内的所有更新看起来是并发发生的，完美地模拟了对所有 $i$ 的同步硬件规则 $r_i(t_k^+) = u_i(t_k^-)$。仿真结果变得与时钟进程内非阻塞赋值的文本顺序无关，从而消除了竞争条件。\n\n现在，我们基于这个推导来评估各个选项。\n\n**A. 非阻塞赋值在每个时钟沿强制执行一个两阶段事件排序：所有右侧 (RHS) 使用 $\\mathbf{r}(t_k^-)$ 和 $\\mathbf{x}(t_k^-)$ 进行采样并排队，而不会立即更新左侧 (LHS)，然后所有 LHS 同时提交以产生 $\\mathbf{r}(t_k^+)$；这将仿真与同步硬件规则 $r_i(t_k^+) = u_i(t_k^-)$ 对齐，并消除了由文本顺序引起的竞争条件。**\n这个选项精确地描述了非阻塞赋值的两阶段仿真语义（求值/采样后跟更新/提交）。它正确地指出所有 RHS 都使用沿前状态 $\\mathbf{r}(t_k^-)$ 进行求值，从而使仿真与由 $r_i(t_k^+) = u_i(t_k^-)$ 定义的物理硬件行为保持一致。它正确地得出结论，这消除了依赖于文本顺序的竞争条件。\n**结论：正确。**\n\n**B. 阻塞赋值是足够的，因为综合工具会将时钟赋值映射到触发器，并且由于门是并发的，仿真器的立即 LHS 更新不影响功能正确性；语句间的文本顺序无关紧要。**\n这个选项犯了一个关键错误，混淆了综合和仿真。虽然综合工具会正确地将时钟块中的 `r_a = f_a(...)` 解释为触发器，但如上所示，这段代码的仿真在功能上是不正确的。RTL 仿真的目的是在综合*之前*验证逻辑行为。不正确的仿真无法提供这种验证。声称立即更新不影响仿真中的功能正确性是错误的。\n**结论：不正确。**\n\n**C. 在每个时钟进程内对时序赋值进行确定性的拓扑排序（先对上游寄存器赋值，再对下游寄存器赋值）可以再现预期的流水线行为；因此，只要仔细维持排序，非阻塞赋值就是不必要的。**\n这建议使用阻塞赋值并通过仔细排序来解决问题（例如 `r_b = r_a; r_a = f_a(...)`）。虽然这种特定的排序可能对简单的两级流水线有效，但这是一种脆弱、易错的做法，违反了问题中要求解决方案“无论文本顺序如何”都能工作的要求。对于更复杂的逻辑，比如并行交换（`a = b; b = a;`），这种方法在没有临时变量的情况下会失败，而非阻塞赋值（`a = b; b = a;`）则能优雅且正确地模拟硬件交换。这种方法在现代 HDL 设计中是一种反模式。\n**结论：不正确。**\n\n**D. 引入故意的时钟偏斜，使得上游寄存器在下游寄存器之前更新，可以让阻塞赋值在仿真过程中匹配硬件行为；这种偏斜保留了逐周期的传输，并在不改变逻辑功能的情况下消除了竞争。**\n这个选项错误地将物理层实现概念（时钟偏斜）引入到关于 RTL 仿真语义的讨论中。标准的 RTL 仿真假设时钟是理想的，没有偏斜。问题在于源代码中的逻辑建模，而非物理时序。依赖像时钟偏斜这样的物理现象来修复逻辑建模错误是一种根本上有缺陷的设计方法。逻辑必须首先是正确的。\n**结论：不正确。**\n\n**E. 在使用阻塞赋值的同时，通过推断透明锁存器作为级间存储来防止竞争，因为它可以在时钟沿期间保持先前的值；这维持了寄存器传输行为，并使非阻塞语义变得多余。**\n这个选项建议将硬件元件从边沿触发的寄存器（触发器）更改为电平敏感的锁存器。这从根本上改变了电路类型和时序范式。问题明确是关于基于寄存器和单个时钟沿的“同步时序逻辑”，这意味着使用触发器。用锁存器来迁就不正确的 HDL 编码实践是错误的。目标是为预期的硬件（边沿触发寄存器）建模，而不是改变硬件以适应有缺陷的建模风格。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在集成电路设计流程中，满足性能目标是一个关键挑战，这通常需要进行流水线（pipelining）等架构级优化。本实践问题  提供了一个动手场景，您必须计算出所需的最小流水线寄存器数量，以使一个较慢的组合逻辑路径满足高频率时钟的目标。该练习将巩固您对同步时序约束的理解，并掌握如何策略性地划分逻辑以实现时序收敛。",
            "id": "4276652",
            "problem": "在一个使用电子设计自动化（EDA）工具进行综合与实现的同步集成电路（IC）中，考虑一个单时钟域组合逻辑块，该逻辑块当前位于上游触发寄存器和单个下游捕获寄存器之间。该逻辑块是纯组合逻辑，可以通过插入边沿触发的流水线寄存器来分割，其走线和插入开销可忽略不计。所有流水线寄存器都是相同的，其特性为建立时间 $t_{\\mathrm{su}}$ 和时钟到Q端延迟 $t_{\\mathrm{cq}}$。全局时钟不确定性（包括时钟偏斜和抖动）为 $u$。保持时间已通过其他方式保证，可以忽略。目标时钟频率为 $f_{\\mathrm{clk}}$（周期 $T = 1/f_{\\mathrm{clk}}$）。该逻辑块将被流水线化，以使每个寄存器间段在同一时钟下单周期建立时序均得到满足。\n\n给定：\n- 目标频率 $f_{\\mathrm{clk}} = 1.25\\,\\text{GHz}$。\n- 寄存器建立时间 $t_{\\mathrm{su}} = 0.03\\,\\text{ns}$。\n- 寄存器时钟到Q端延迟 $t_{\\mathrm{cq}} = 0.05\\,\\text{ns}$。\n- 全局时钟不确定性 $u = 0.04\\,\\text{ns}$。\n- 逻辑块总组合延迟 $D_{\\mathrm{block}} = 1.65\\,\\text{ns}$。\n- 三个模块输入来自上游触发寄存器，其在模块边界相对于有效时钟沿的输入到达时间已知：$a_1 = 0.15\\,\\text{ns}$，$a_2 = 0.22\\,\\text{ns}$，$a_3 = 0.18\\,\\text{ns}$。假设逻辑努力和重收敛效应已正确反向标注到这些到达时间中，并且下游捕获寄存器是该逻辑块之后唯一预先存在的寄存器。\n\n假设您可以在逻辑块内的任意切割点放置流水线寄存器，使得各段延迟之和等于 $D_{\\mathrm{block}}$，并且第一段由模块输入直接驱动。运用同步时序的基本原理（到达时间加上组合逻辑延迟再加上建立时间，不得超过减去不确定性和适当的上游寄存器延迟后的可用时钟周期），从这些基本原理推导出每个阶段的时序条件，并计算必须在模块内部插入的流水线寄存器的最小数量，以使所有寄存器间段在 $f_{\\mathrm{clk}}$ 频率下满足单周期建立时序。请将您的最终答案以等于此最小插入流水线寄存器数量的单个整数形式提供。答案是整数，无需进行取整说明。最终答案中不要包含任何单位。",
            "solution": "首先将对用户提供的问题进行正确性、一致性和完整性验证。\n\n### 步骤1：提取已知条件\n-   目标时钟频率：$f_{\\mathrm{clk}} = 1.25\\,\\text{GHz}$\n-   寄存器建立时间：$t_{\\mathrm{su}} = 0.03\\,\\text{ns}$\n-   寄存器时钟到Q端延迟：$t_{\\mathrm{cq}} = 0.05\\,\\text{ns}$\n-   全局时钟不确定性：$u = 0.04\\,\\text{ns}$\n-   逻辑块总组合延迟：$D_{\\mathrm{block}} = 1.65\\,\\text{ns}$\n-   模块边界的输入到达时间：$a_1 = 0.15\\,\\text{ns}$，$a_2 = 0.22\\,\\text{ns}$，$a_3 = 0.18\\,\\text{ns}$\n-   保持时间已保证，可忽略。\n-   流水线寄存器可以插入在任意切割点。\n-   待求量是需要插入的寄存器数量。\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学依据充足**：该问题基于同步数字电路时序分析的基本原理，特别是流水线架构中的建立时间约束。所有概念（$f_{\\mathrm{clk}}$、$t_{\\mathrm{su}}$、$t_{\\mathrm{cq}}$、时钟不确定性、流水线）都是IC设计和EDA领域的标准概念。\n2.  **提法恰当**：问题提法恰当。它提供了计算最小流水线寄存器数量所需的所有必要参数，答案是唯一的整数值。\n3.  **客观**：语言精确、量化，没有主观或模糊的术语。\n4.  **完整性和一致性**：问题是自洽的，所有给定值都一致。没有矛盾之处。诸如寄存器插入开销可忽略不计等假设都已明确说明。\n\n### 步骤3：结论与行动\n问题被判定为**有效**。将提供一个完整的、有理有据的解答。\n\n### 解题推导\n控制同步电路最高工作频率的核心原理是建立时序约束。对于一个从触发寄存器到捕获寄存器的数据路径，该路径的总延迟必须小于或等于一个时钟周期内的可用时间。\n\n时钟周期 $T$ 是时钟频率 $f_{\\mathrm{clk}}$ 的倒数：\n$$T = \\frac{1}{f_{\\mathrm{clk}}} = \\frac{1}{1.25 \\times 10^9\\,\\text{Hz}} = 0.8\\,\\text{ns}$$\n\n设 $N$ 为需要插入的流水线寄存器的最小数量。插入 $N$ 个寄存器会将总延迟为 $D_{\\mathrm{block}}$ 的组合逻辑块划分为 $N+1$ 段。设这些段的延迟为 $D_1, D_2, \\dots, D_{N+1}$，使得：\n$$\\sum_{i=1}^{N+1} D_i = D_{\\mathrm{block}} = 1.65\\,\\text{ns}$$\n\n我们必须为每个段推导时序约束。\n\n**1. 内部段和最终段的时序约束**\n考虑一个延迟为 $D_i$（对于 $i \\ge 2$）的组合逻辑段，它位于两个寄存器之间（一个触发数据的插入流水线寄存器和另一个捕获它的寄存器）。信号在时钟沿之后从第一个寄存器触发，通过逻辑电路传播，必须在下一个时钟沿到达之前到达第二个寄存器的输入端，并稳定 $t_{\\mathrm{su}}$ 的建立时间。标准的建立时序方程是：\n$$t_{\\mathrm{cq}} + D_i + t_{\\mathrm{su}} + u \\le T$$\n这里，$t_{\\mathrm{cq}}$ 是触发寄存器的时钟到Q端延迟，$D_i$ 是组合路径延迟，$t_{\\mathrm{su}}$ 是捕获寄存器的建立时间，$u$ 是时钟不确定性，它减少了有效时钟周期。这个约束适用于从第一个插入的寄存器开始的所有段，即对于 $i=2, 3, \\dots, N+1$。\n\n由此，我们可以计算出这些段的最大允许组合逻辑延迟，我们将其表示为 $D_{\\mathrm{int, max}}$：\n$$D_{\\mathrm{int, max}} = T - t_{\\mathrm{cq}} - t_{\\mathrm{su}} - u$$\n$$D_{\\mathrm{int, max}} = 0.8\\,\\text{ns} - 0.05\\,\\text{ns} - 0.03\\,\\text{ns} - 0.04\\,\\text{ns} = 0.68\\,\\text{ns}$$\n\n**2. 第一段的时序约束**\n第一段的延迟为 $D_1$，情况有所不同。它不是由插入的流水线寄存器之一驱动的。相反，它的输入是该模块的主输入，这些输入在时钟沿之后的指定时间到达。模块输入引脚的最坏情况（最晚）到达时间决定了时序约束。设此时间为 $a_{\\max}$。\n$$a_{\\max} = \\max(a_1, a_2, a_3) = \\max(0.15\\,\\text{ns}, 0.22\\,\\text{ns}, 0.18\\,\\text{ns}) = 0.22\\,\\text{ns}$$\n在时序路径计算中，这个到达时间 $a_{\\max}$ 有效地替代了触发寄存器的 $t_{\\mathrm{cq}}$。信号相对于时钟沿在 $a_{\\max} + D_1$ 时刻到达第一个流水线寄存器的输入端。对此第一个捕获寄存器的建立时间约束是：\n$$(a_{\\max} + D_1) + t_{\\mathrm{su}} + u \\le T$$\n因此，这第一段的最大允许延迟 $D_{1, \\max}$ 为：\n$$D_{1, \\max} = T - a_{\\max} - t_{\\mathrm{su}} - u$$\n$$D_{1, \\max} = 0.8\\,\\text{ns} - 0.22\\,\\text{ns} - 0.03\\,\\text{ns} - 0.04\\,\\text{ns} = 0.51\\,\\text{ns}$$\n\n**3. 计算最小寄存器数量**\n我们需要将总模块延迟 $D_{\\mathrm{block}} = 1.65\\,\\text{ns}$ 划分为 $N+1$ 段，其中第一段的最大延迟为 $D_{1, \\max} = 0.51\\,\\text{ns}$，随后的 $N$ 段每段的最大延迟为 $D_{\\mathrm{int, max}} = 0.68\\,\\text{ns}$。\n为了成功地对模块进行流水线化，这 $N+1$ 段的最大可能延迟之和必须大于或等于总模块延迟。\n$$D_{\\mathrm{block}} \\le D_{1, \\max} + N \\times D_{\\mathrm{int, max}}$$\n我们现在可以求解最小整数 $N$：\n$$1.65 \\le 0.51 + N \\times 0.68$$\n$$1.65 - 0.51 \\le N \\times 0.68$$\n$$1.14 \\le N \\times 0.68$$\n$$N \\ge \\frac{1.14}{0.68}$$\n$$N \\ge 1.67647...$$\n由于不能插入小数个寄存器，我们必须对这个值取上整。所需的最小整数寄存器数量是：\n$$N = \\lceil 1.67647... \\rceil = 2$$\n\n因此，必须最少插入2个流水线寄存器。这将产生3个组合逻辑段。我们可以验证这是可行的：\n-   第1段延迟：$D_1 \\le 0.51\\,\\text{ns}$\n-   第2段延迟：$D_2 \\le 0.68\\,\\text{ns}$\n-   第3段延迟：$D_3 \\le 0.68\\,\\text{ns}$\n所需总延迟：$D_1+D_2+D_3 = 1.65\\,\\text{ns}$。\n一个有效的划分是存在的，例如：$D_1=0.51\\,\\text{ns}$，$D_2=0.68\\,\\text{ns}$，以及 $D_3 = 1.65 - 0.51 - 0.68 = 0.46\\,\\text{ns}$。由于 $0.46\\,\\text{ns} \\le 0.68\\,\\text{ns}$，这是一个有效的解。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "当设计从逻辑表示走向物理版图时，互连线的延迟贡献变得至关重要。最后一个练习  聚焦于布线后的分析阶段，要求您计算一个被建模为RC链的布线网络的埃尔莫尔延迟（Elmore delay）。通过从基本原理出发推导延迟，您将学习到EDA工具在时序分析中使用的一项关键技术，并体会到互连线为何会成为路径总延迟的主导因素。",
            "id": "4276646",
            "problem": "在电子设计自动化（EDA）中，集成电路（IC）设计流程通向图形数据系统II（GDSII）流片的布线后静态时序分析（STA）阶段，考虑一个由逻辑门驱动的单源、单汇互连线，该逻辑门被抽象为一个具有输出电阻的Thevenin源，而互连线则被建模为一个线性电阻-电容树。用于该互连线的延迟度量被定义为该线性时不变网络在汇节点的脉冲响应的一阶矩。该布线网络是一个链状结构，在中间节点和汇输入端具有串联电阻和到地的并联电容。\n\n假设以下模型和数据从签核寄生参数提取中获得：\n- 驱动器在源节点处被建模为一个等效Thevenin电阻 $R_{0}$，其值为 $R_{0} = 120\\,\\Omega$。\n- 导线沿着到汇的唯一路径被分割成三个串联电阻 $R_{1}$、$R_{2}$、$R_{3}$，其值分别为 $R_{1} = 35\\,\\Omega$，$R_{2} = 50\\,\\Omega$，$R_{3} = 20\\,\\Omega$。\n- 在 $R_{1}$ 之后、$R_{2}$ 之后的节点以及汇节点处的到地并联电容分别为 $C_{1} = 15 \\times 10^{-15}\\,\\text{F}$、$C_{2} = 28 \\times 10^{-15}\\,\\text{F}$ 和 $C_{3} = 52 \\times 10^{-15}\\,\\text{F}$。\n- 驱动逻辑单元的固有输入到输出传播延迟为 $t_{\\text{drv,int}} = 23 \\times 10^{-12}\\,\\text{s}$，接收逻辑单元的固有传播延迟（从其输入引脚到其输出引脚，不包括互连线）为 $t_{\\text{snk,int}} = 21 \\times 10^{-12}\\,\\text{s}$。\n\n从线性电阻-电容网络在汇节点的脉冲响应一阶矩的定义出发（问题陈述中不使用任何简化公式），仅使用线性时不变网络的基本性质和互连线的树状结构，推导该拓扑的互连延迟的解析表达式。然后，以秒为单位数值计算该互连延迟，并通过计算比率\n$$\n\\rho \\equiv \\frac{t_{\\text{wire}}}{t_{\\text{drv,int}} + t_{\\text{snk,int}}}.\n$$\n将其与关键路径上两个单元的固有延迟之和进行比较。\n只报告单个数值 $\\rho$，作为一个无单位小数，并四舍五入到四位有效数字。",
            "solution": "该问题要求计算一个比率 $\\rho$，其中涉及到指定RC网络的互连延迟。互连延迟 $t_{\\text{wire}}$ 被定义为汇节点的脉冲响应的一阶矩。此问题具有科学依据，提法明确，客观，并包含得出唯一解所需的所有信息。因此，该问题是有效的。\n\n互连线被建模为一个由Thevenin等效源驱动的线性电阻-电容（RC）链。该网络由一个源电阻 $R_{0}$ 和三段串联的导线电阻 $R_{1}$、$R_{2}$ 和 $R_{3}$ 组成。并联电容 $C_{1}$、$C_{2}$ 和 $C_{3}$ 分别位于 $R_{1}$ 之后、$R_{2}$ 之后和 $R_{3}$ 之后（即汇点）的节点上。\n\n设互连线的节点编号如下：节点1是 $R_{1}$ 和 $R_{2}$ 之间的连接点（$C_{1}$ 连接于此），节点2是 $R_{2}$ 和 $R_{3}$ 之间的连接点（$C_{2}$ 连接于此），节点3是汇节点（$C_{3}$ 连接于此）。输入源连接到链的起始端，其电阻 $R_{0}$ 被视为信号路径的一部分。\n\n互连延迟 $t_{\\text{wire}}$ 定义为在汇点（节点3）处的脉冲响应 $h_3(t)$ 的一阶矩。在数学上，这表示为：\n$$\nt_{\\text{wire}} = \\int_{0}^{\\infty} t h_3(t) dt\n$$\n对于一个线性时不变（LTI）系统，其脉冲响应的一阶矩可以从其拉普拉斯域传递函数 $H(s)$ 计算得出。如果 $H_3(s)$ 是从网络输入到节点3电压的传递函数，那么一阶矩由下式给出：\n$$\nt_{\\text{wire}} = - \\frac{dH_3(s)}{ds} \\bigg|_{s=0}\n$$\n这个量被称为Elmore延迟。由 W. C. Elmore 建立的关于RC树网络的一个基本结果表明，特定节点 $i$ 处的延迟由网络中每个电容与从源到该电容节点和节点 $i$ 的公共路径上的电阻的乘积之和给出。\n\n对于给定的线性链式拓扑（它是树的一种特殊情况），汇节点是节点3。我们应用Elmore延迟公式来求解 $t_{\\text{wire}}$。节点 $i$ 处的延迟公式为 $\\tau_i = \\sum_{k} R_{ik} C_k$，其中 $C_k$ 是节点 $k$ 处的电容，$R_{ik}$ 是从源到节点 $i$ 和节点 $k$ 的公共路径的电阻。在我们的情况下，$i=3$。\n\n每个电容的路径电阻如下：\n1. 电容是位于节点1的 $C_{1}$。从源到节点3的路径经过电阻 $R_{0}$、$R_{1}$、$R_{2}$ 和 $R_{3}$。从源到节点1的路径经过电阻 $R_{0}$ 和 $R_{1}$。公共路径电阻为 $R_{31} = R_{0} + R_{1}$。\n2. 电容是位于节点2的 $C_{2}$。从源到节点3的路径经过 $R_{0}$、$R_{1}$、$R_{2}$ 和 $R_{3}$。从源到节点2的路径经过 $R_{0}$、$R_{1}$ 和 $R_{2}$。公共路径电阻为 $R_{32} = R_{0} + R_{1} + R_{2}$。\n3. 电容是位于节点3的 $C_{3}$。从源到节点3的路径经过 $R_{0}$、$R_{1}$、$R_{2}$ 和 $R_{3}$。从源到节点3的路径就是它本身。公共路径电阻为 $R_{33} = R_{0} + R_{1} + R_{2} + R_{3}$。\n\n因此，互连延迟 $t_{\\text{wire}}$ 的解析表达式为：\n$$\nt_{\\text{wire}} = R_{31} C_{1} + R_{32} C_{2} + R_{33} C_{3}\n$$\n$$\nt_{\\text{wire}} = (R_{0} + R_{1})C_{1} + (R_{0} + R_{1} + R_{2})C_{2} + (R_{0} + R_{1} + R_{2} + R_{3})C_{3}\n$$\n现在我们代入给定的数值。所有计算都将以国际单位制（SI）的基本单位（欧姆、法拉、秒）进行。\n已知：\n$R_{0} = 120\\,\\Omega$\n$R_{1} = 35\\,\\Omega$\n$R_{2} = 50\\,\\Omega$\n$R_{3} = 20\\,\\Omega$\n$C_{1} = 15 \\times 10^{-15}\\,\\text{F}$\n$C_{2} = 28 \\times 10^{-15}\\,\\text{F}$\n$C_{3} = 52 \\times 10^{-15}\\,\\text{F}$\n$t_{\\text{drv,int}} = 23 \\times 10^{-12}\\,\\text{s}$\n$t_{\\text{snk,int}} = 21 \\times 10^{-12}\\,\\text{s}$\n\n首先，计算路径电阻：\n$R_{31} = R_{0} + R_{1} = 120 + 35 = 155\\,\\Omega$\n$R_{32} = R_{0} + R_{1} + R_{2} = 120 + 35 + 50 = 205\\,\\Omega$\n$R_{33} = R_{0} + R_{1} + R_{2} + R_{3} = 120 + 35 + 50 + 20 = 225\\,\\Omega$\n\n接下来，计算各个延迟分量：\n第1项：$(155\\,\\Omega) \\times (15 \\times 10^{-15}\\,\\text{F}) = 2325 \\times 10^{-15}\\,\\text{s} = 2.325 \\times 10^{-12}\\,\\text{s}$\n第2项：$(205\\,\\Omega) \\times (28 \\times 10^{-15}\\,\\text{F}) = 5740 \\times 10^{-15}\\,\\text{s} = 5.740 \\times 10^{-12}\\,\\text{s}$\n第3项：$(225\\,\\Omega) \\times (52 \\times 10^{-15}\\,\\text{F}) = 11700 \\times 10^{-15}\\,\\text{s} = 11.700 \\times 10^{-12}\\,\\text{s}$\n\n将这些分量相加得到总互连延迟 $t_{\\text{wire}}$：\n$$\nt_{\\text{wire}} = (2.325 + 5.740 + 11.700) \\times 10^{-12}\\,\\text{s} = 19.765 \\times 10^{-12}\\,\\text{s}\n$$\n问题要求计算比率 $\\rho = \\frac{t_{\\text{wire}}}{t_{\\text{drv,int}} + t_{\\text{snk,int}}}$。首先，计算分母，即固有单元延迟之和：\n$$\nt_{\\text{drv,int}} + t_{\\text{snk,int}} = (23 \\times 10^{-12}\\,\\text{s}) + (21 \\times 10^{-12}\\,\\text{s}) = 44 \\times 10^{-12}\\,\\text{s}\n$$\n现在，计算比率 $\\rho$：\n$$\n\\rho = \\frac{19.765 \\times 10^{-12}\\,\\text{s}}{44 \\times 10^{-12}\\,\\text{s}} = \\frac{19.765}{44} \\approx 0.449204545...\n$$\n按要求将结果四舍五入到四位有效数字，得到：\n$$\n\\rho \\approx 0.4492\n$$\n这个无量纲比率比较了物理互连所带来的延迟代价与逻辑单元本身的固有开关速度。小于1的值表明，在该路径段上，导线延迟小于组合的固有单元延迟。",
            "answer": "$$\\boxed{0.4492}$$"
        }
    ]
}