{
    "hands_on_practices": [
        {
            "introduction": "The design process in Electronic Design Automation (EDA) often begins at a high level of abstraction, where complex behaviors can be described concisely. This first exercise  guides you through a crucial step in this process: refining a non-synthesizable behavioral model into a synthesizable Register-Transfer Level (RTL) equivalent. By translating a `fork/join_any` construct into an explicit Finite-State Machine (FSM), you will gain practical insight into how abstract concurrency is mapped onto concrete, resource-bounded hardware, a fundamental skill in digital design.",
            "id": "4294393",
            "problem": "You are given a high-level behavioral description in a Hardware Description Language (HDL) of a concurrent operation that uses a dynamic array of task latencies and a fork/join_any construct to launch tasks simultaneously and to complete as soon as any task finishes. The purpose is to refactor this behavioral description into an equivalent synthesizable Register-Transfer Level (RTL) implementation that uses explicit finite-state machine control and bounded, static resources, and to validate equivalence via simulation at the cycle level.\n\nFundamental base definitions to be used:\n- A Hardware Description Language (HDL) is a formal language for describing synchronous digital systems, where behavioral constructs denote concurrency and temporal evolution in discrete time.\n- Register-Transfer Level (RTL) is an abstraction in which data flow between registers is driven by clocked control logic; synthesizable RTL requires fixed resource bounds and static data sizes.\n- Electronic Design Automation (EDA) is the tool-supported process for specifying, simulating, and synthesizing digital systems across abstraction levels.\n- Discrete-event simulation semantics: independent tasks launched at time $t=0$ with deterministic latencies $\\{L_i\\}$ complete at absolute times $t_i = L_i$; a fork/join\\_any completes at $t^\\star = \\min_i L_i$, returning the index $i^\\star$ of the earliest finishing task. If multiple tasks tie at the minimum latency, select the smallest index.\n\nBehavioral model to formalize:\n- The dynamic array contains $N$ task latencies $\\{L_0,L_1,\\dots,L_{N-1}\\}$ (in cycles).\n- A fork/join\\_any semantics: all $N$ tasks start at $t=0$ concurrently; the completion time is $t^\\star = \\min_{0\\le i  N} L_i$ and the selected index is $i^\\star = \\arg\\min_{0\\le i  N} L_i$, with ties broken in favor of the smallest index.\n- For the boundary case $N=0$, define the result as $i^\\star=-1$ and $t^\\star=0$ cycles, representing \"no task\".\n\nSynthesizable RTL refactoring constraints:\n- Fixed maximum capacity $N_{\\max}$ bounds the dynamic array; the actual number of tasks $N$ satisfies $0\\le N\\le N_{\\max}$, and unused slots are deactivated by a mask.\n- Bounded parallel resources: at most $P$ parallel worker slots exist, with $P\\ge 1$, but to preserve fork/join\\_any semantics without speculative resource overcommitment, only the selected $\\arg\\min$ task is executed while the others are canceled (i.e., never started in hardware).\n- Explicit finite-state control must be used. A minimal control can be specified by states: $\\mathrm{IDLE}\\to\\mathrm{SCAN}\\to\\mathrm{RUN}\\to\\mathrm{DONE}$. In $\\mathrm{SCAN}$, the controller computes $i^\\star$ by sequentially scanning the $N$ entries and selecting the minimum with deterministic tie-breaking. In $\\mathrm{RUN}$, it executes only the selected task for $L_{i^\\star}$ cycles. Define the reported completion time to exclude the $\\mathrm{SCAN}$ cycles and equal the execution latency $L_{i^\\star}$, so that equivalence to behavioral fork/join\\_any is assessed in terms of task-execution cycles. This models the common EDA practice of separating combinational or multi-cycle selection control from the measured execution interval when comparing abstraction-level behaviors.\n\nYour program must:\n1. Implement a behavioral simulator that, given a list of latencies $\\{L_i\\}$, returns the pair $(i^\\star,t^\\star)$ under fork/join\\_any semantics with the tie-breaking specified above.\n2. Implement an RTL finite-state control simulator that, given the same list, a bound $N_{\\max}$, and the number of parallel worker slots $P$, realizes the state sequence $\\mathrm{IDLE}\\to\\mathrm{SCAN}\\to\\mathrm{RUN}\\to\\mathrm{DONE}$, cancels all non-selected tasks, and returns the pair $(\\hat{i},\\hat{t})$ with $\\hat{i}$ equal to the selected index and $\\hat{t}$ equal to $L_{\\hat{i}}$ in cycles.\n3. Validate equivalence by returning a boolean for each test case indicating whether $(i^\\star,t^\\star)=(\\hat{i},\\hat{t})$.\n\nUnits and conventions:\n- All latencies $L_i$ and reported times $t^\\star,\\hat{t}$ must be expressed in cycles as integers.\n- For $N=0$, use $i^\\star=-1$ and $t^\\star=0$ cycles.\n\nTest suite:\nUse the following test cases, each specified by $(\\{L_i\\}, N_{\\max}, P)$.\n- Case A (happy path): $\\{L_i\\} = [\\,7,\\,2,\\,5,\\,4\\,]$, $N_{\\max}=8$, $P=2$. Expected minimum latency $2$ at index $1$.\n- Case B (tie): $\\{L_i\\} = [\\,3,\\,3,\\,5\\,]$, $N_{\\max}=8$, $P=4$. Expected minimum latency $3$ with tie broken to index $0$.\n- Case C (zero latency present): $\\{L_i\\} = [\\,0,\\,4,\\,0,\\,2\\,]$, $N_{\\max}=8$, $P=3$. Expected minimum latency $0$ at index $0$ due to tie-breaking.\n- Case D (single task): $\\{L_i\\} = [\\,9\\,]$, $N_{\\max}=4$, $P=1$. Expected minimum latency $9$ at index $0$.\n- Case E (empty set): $\\{L_i\\} = [\\,\\,]$ (i.e., $N=0$), $N_{\\max}=4$, $P=1$. Expected $i^\\star=-1$, $t^\\star=0$.\n- Case F (larger array with multiple ties): $\\{L_i\\} = [\\,6,\\,5,\\,12,\\,3,\\,11,\\,7,\\,8,\\,3,\\,9,\\,10\\,]$, $N_{\\max}=16$, $P=4$. Expected minimum latency $3$ at the smallest index among ties, which is index $3$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), where each result is a boolean indicating equivalence for the corresponding test case. No other text should be printed.",
            "solution": "The problem has been validated and found to be self-contained, scientifically grounded in the principles of digital design and Electronic Design Automation (EDA), and well-posed. It presents a standard verification task: confirming the behavioral equivalence between a high-level concurrent model and a more concrete, sequentially controlled Register-Transfer Level (RTL) implementation.\n\nThe solution proceeds by first implementing two distinct simulators as specified: one for the behavioral model and one for the RTL model. Then, it compares their outputs for a given set of test cases to validate their equivalence.\n\n1.  **Behavioral Model Simulation**\n    The behavioral model describes an ideal concurrent execution based on a fork/join\\_any semantic. Given a list of $N$ task latencies $\\{L_0, L_1, \\dots, L_{N-1}\\}$, all $N$ tasks are conceptually launched simultaneously at time $t=0$. The operation as a whole completes when the first task finishes.\n\n    -   The completion time, $t^\\star$, is therefore the minimum of all task latencies:\n        $$ t^\\star = \\min_{0 \\le i  N} L_i $$\n    -   The identity of the completed task, $i^\\star$, is the index corresponding to this minimum latency:\n        $$ i^\\star = \\arg\\min_{0 \\le i  N} L_i $$\n    -   The problem specifies a deterministic tie-breaking rule: if multiple tasks share the same minimum latency, the task with the smallest index is selected. Standard library functions for finding the index of a minimum value typically adhere to this rule implicitly.\n    -   A special boundary condition is defined for an empty set of tasks ($N=0$), where the result is $(i^\\star, t^\\star) = (-1, 0)$.\n\n    The implementation of the behavioral simulator directly formalizes these rules. It first checks if the input list of latencies is empty to handle the boundary case. If not, it computes the minimum value in the list and finds the first index at which this minimum occurs. This yields the pair $(i^\\star, t^\\star)$.\n\n2.  **RTL Model Simulation**\n    The RTL model represents a synthesizable hardware implementation. As synthesizable logic requires fixed resources and explicit control, the ideal concurrency of the behavioral model is refactored into a sequential process governed by a Finite-State Machine (FSM). The FSM states are specified as $\\mathrm{IDLE} \\to \\mathrm{SCAN} \\to \\mathrm{RUN} \\to \\mathrm{DONE}$.\n\n    -   The parameters $N_{\\max}$ (maximum number of tasks) and $P$ (number of parallel worker units) define the bounds of the physical hardware. However, the specified control logic simplifies the simulation: \"only the selected $\\arg\\min$ task is executed while the others are canceled.\" This implies that even if $P  1$ workers are available, only one is ever used for execution. The logic for selecting the task to run is independent of $P$ and $N_{\\max}$ (provided $N \\le N_{\\max}$).\n    -   In the $\\mathrm{SCAN}$ state, the controller sequentially inspects the $N$ task latencies to identify the task that would finish first. This is algorithmically identical to finding the minimum latency and its corresponding index, $\\hat{i}$, with the same tie-breaking rule as the behavioral model.\n        $$ \\hat{i} = \\arg\\min_{0 \\le i  N} L_i $$\n    -   In the $\\mathrm{RUN}$ state, the machine executes *only* the single task selected in the $\\mathrm{SCAN}$ state. The duration of this state is equal to the latency of that task, $L_{\\hat{i}}$.\n    -   A crucial element of the problem is the definition of equivalence. The reported completion time for the RTL model, $\\hat{t}$, is specified to be the \"execution latency $L_{\\hat{i}}$\", explicitly excluding the time spent in the $\\mathrm{SCAN}$ state.\n        $$ \\hat{t} = L_{\\hat{i}} $$\n    -   Therefore, the output of the RTL model simulation is the pair $(\\hat{i}, \\hat{t})$. For the $N=0$ case, the model correctly produces $(-1, 0)$.\n\n3.  **Equivalence Validation**\n    By design, the core logic of the RTL model is structured to produce a result that is behaviorally equivalent to the fork/join\\_any model. The `SCAN` phase computes the exact same index $\\hat{i}$ as the behavioral model's $i^\\star$. The reported time $\\hat{t}$ is defined as the latency of that task, $L_{\\hat{i}}$, which is identical to the behavioral model's $t^\\star$.\n    $$ \\hat{i} = i^\\star $$\n    $$ \\hat{t} = L_{\\hat{i}} = L_{i^\\star} = t^\\star $$\n    The program validates this by executing both simulators on each test case and comparing the resulting tuples, $(i^\\star, t^\\star)$ and $(\\hat{i}, \\hat{t})$. The implementation confirms this logical equivalence, which is expected to hold for all test cases. The provided Python code implements these two simulators and performs the specified validation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef behavioral_simulator(latencies):\n    \"\"\"\n    Implements the behavioral simulator for a fork/join_any construct.\n\n    Args:\n        latencies (list[int]): A list of task latencies in cycles.\n\n    Returns:\n        tuple[int, int]: A pair (i_star, t_star) representing the index\n                         of the winning task and its latency.\n    \"\"\"\n    num_tasks = len(latencies)\n\n    # Handle the boundary case where there are no tasks.\n    if num_tasks == 0:\n        return -1, 0\n\n    # Under fork/join_any semantics, the completion time is the minimum latency.\n    # The numpy.argmin function finds the index of the first occurrence of the\n    # minimum value, which satisfies the specified tie-breaking rule.\n    i_star = np.argmin(latencies)\n    t_star = latencies[i_star]\n\n    return int(i_star), int(t_star)\n\ndef rtl_simulator(latencies, N_max, P):\n    \"\"\"\n    Implements the synthesizable RTL finite-state control simulator.\n\n    Args:\n        latencies (list[int]): A list of task latencies.\n        N_max (int): The maximum number of tasks the hardware can support.\n        P (int): The number of parallel worker slots available in hardware.\n\n    Returns:\n        tuple[int, int]: A pair (i_hat, t_hat) representing the selected\n                         task index and its execution latency.\n    \"\"\"\n    num_tasks = len(latencies)\n    \n    # The parameters N_max and P are contextual for a physical hardware\n    # implementation but do not affect the simulation logic as specified.\n    # The RTL logic is defined to first scan for the minimum latency task\n    # and then execute only that one, cancelling others. The reported time\n    # explicitly excludes the scan time.\n\n    # FSM State: IDLE - SCAN\n    # In the SCAN phase, the controller finds the task to execute.\n    if num_tasks == 0:\n        # If no tasks, SCAN phase finds nothing, FSM proceeds to DONE.\n        # The result is defined by the boundary condition.\n        return -1, 0\n\n    # The scan identifies the task with the minimum latency.\n    # np.argmin adheres to the tie-breaking rule (smallest index).\n    i_hat = np.argmin(latencies)\n    selected_task_latency = latencies[i_hat]\n\n    # FSM State: SCAN - RUN\n    # In the RUN phase, only the selected task is executed. Its duration is\n    # its latency. The problem specifies the reported time is this latency.\n    t_hat = selected_task_latency\n\n    # FSM State: RUN - DONE\n    return int(i_hat), int(t_hat)\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all test cases and validates equivalence.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path)\n        {'latencies': [7, 2, 5, 4], 'N_max': 8, 'P': 2},\n        # Case B (tie)\n        {'latencies': [3, 3, 5], 'N_max': 8, 'P': 4},\n        # Case C (zero latency present)\n        {'latencies': [0, 4, 0, 2], 'N_max': 8, 'P': 3},\n        # Case D (single task)\n        {'latencies': [9], 'N_max': 4, 'P': 1},\n        # Case E (empty set)\n        {'latencies': [], 'N_max': 4, 'P': 1},\n        # Case F (larger array with multiple ties)\n        {'latencies': [6, 5, 12, 3, 11, 7, 8, 3, 9, 10], 'N_max': 16, 'P': 4}\n    ]\n\n    results = []\n    for case in test_cases:\n        latencies = case['latencies']\n        n_max = case['N_max']\n        p = case['P']\n        \n        # Run the behavioral simulation\n        i_star, t_star = behavioral_simulator(latencies)\n        \n        # Run the RTL simulation\n        i_hat, t_hat = rtl_simulator(latencies, n_max, p)\n        \n        # Validate that the results are equivalent\n        is_equivalent = (i_star, t_star) == (i_hat, t_hat)\n        results.append(is_equivalent)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Having descended to the Register-Transfer Level (RTL), precision in modeling synchronous hardware becomes paramount. This practice  explores one of the most critical and often misunderstood aspects of HDL syntax: the distinction between blocking and non-blocking assignments. By simulating a simple pipeline, you will discover how these two assignment types create fundamentally different behaviors, providing a clear illustration of how to correctly model the concurrent state updates that define synchronous systems.",
            "id": "4294389",
            "problem": "Consider a cycle-accurate Register-Transfer Level (RTL) model of a three-stage synchronous pipeline in the context of Electronic Design Automation (EDA) using a Hardware Description Language (HDL). The pipeline consists of three registers $s_1$, $s_2$, and $s_3$ clocked by a single global clock with rising-edge triggering. All registers are initialized to zero at cycle $t=0$, so $s_1[0]=0$, $s_2[0]=0$, and $s_3[0]=0$. The pipeline processes a scalar input stream $x[t]$ sampled at each clock cycle, where the input is defined by the discrete-time function $x[t]=4t-1$ for all integer cycles $t \\geq 1$. The pipelineâ€™s per-stage transformations are an increment by $k=2$ at stage $2$ and a multiplication by $m=3$ at stage $3$.\n\nYou will analyze two HDL assignment semantics at the RTL abstraction level:\n\n1. Blocking semantics: Within a single synchronous update block, assignments execute in program order and update the target variables immediately. Model this by the same-cycle ordered updates\n$\n\\begin{aligned}\ns_1[t] = x[t],\\\\\ns_2[t] = s_1[t] + k,\\\\\ns_3[t] = m \\cdot s_2[t].\n\\end{aligned}\n$\nDefine the observable pipeline output as $y_{\\mathrm{B}}[t] = s_3[t]$ under blocking semantics.\n\n2. Non-blocking semantics: Within a single synchronous update block, all assignments schedule updates to occur concurrently at the end of the clock tick, so right-hand sides read values from the previous cycle. Model this by the concurrent updates\n$\n\\begin{aligned}\ns_1[t] = x[t],\\\\\ns_2[t] = s_1[t-1] + k,\\\\\ns_3[t] = m \\cdot s_2[t-1].\n\\end{aligned}\n$\nDefine the observable pipeline output as $y_{\\mathrm{NB}}[t] = s_3[t]$ under non-blocking semantics.\n\nStarting from these definitions and the initialization at $t=0$, compute the cycle-by-cycle outputs $y_{\\mathrm{B}}[t]$ and $y_{\\mathrm{NB}}[t]$ for $t=1,2,\\dots,10$. Then compute the scalar quantity\n$\nD=\\sum_{t=1}^{10}\\left(y_{\\mathrm{B}}[t]-y_{\\mathrm{NB}}[t]\\right).\n$\nExpress the final numerical value of $D$ with no units. No rounding is required.",
            "solution": "The problem requires simulating and comparing the outputs of a three-stage pipeline implemented with two different Hardware Description Language (HDL) assignment semantics: blocking and non-blocking. The core of the problem lies in understanding how these semantics affect the data flow and timing within a synchronous system.\n\n**1. Input and Parameters**\n\nFirst, let's define the constants and the input function:\n- Stage 2 increment: $k = 2$\n- Stage 3 multiplier: $m = 3$\n- Input stream: $x[t] = 4t - 1$ for $t \\ge 1$\n- Initial conditions at $t=0$: $s_1[0]=0$, $s_2[0]=0$, $s_3[0]=0$\n\n**2. Analysis of Blocking Semantics**\n\nBlocking assignments (`=`) are executed sequentially within a single time step. The result of one assignment is immediately visible to the next. This models a combinational dataflow rather than a pipeline.\n\nFor any cycle $t \\ge 1$:\n- $s_1[t] = x[t]$\n- $s_2[t] = s_1[t] + k = x[t] + k$  (uses the *new* value of $s_1[t]$)\n- $s_3[t] = m \\cdot s_2[t] = m \\cdot (x[t] + k)$ (uses the *new* value of $s_2[t]$)\n\nThe output $y_{\\mathrm{B}}[t]$ is therefore a combinational function of the current input $x[t]$:\n$y_{\\mathrm{B}}[t] = 3 \\cdot ((4t - 1) + 2) = 3 \\cdot (4t + 1) = 12t + 3$.\n\n**3. Analysis of Non-Blocking Semantics**\n\nNon-blocking assignments (`=`) schedule updates to happen at the end of the time step. All right-hand sides are evaluated using the values from the *previous* time step. This correctly models a synchronous pipeline.\n\nFor any cycle $t \\ge 1$:\n- $s_1[t] = x[t]$\n- $s_2[t] = s_1[t-1] + k$\n- $s_3[t] = m \\cdot s_2[t-1]$\n\nThe output $y_{\\mathrm{NB}}[t]$ depends on the state from previous cycles. We must compute the first few cycles manually using the initial conditions.\n\n- **t=1**: $y_{\\mathrm{NB}}[1] = m \\cdot s_2[0] = 3 \\cdot 0 = 0$.\n- **t=2**:\n  - We need $s_2[1]$ to compute $s_3[2]$. $s_2[1] = s_1[0] + k = 0 + 2 = 2$.\n  - $y_{\\mathrm{NB}}[2] = m \\cdot s_2[1] = 3 \\cdot 2 = 6$.\n- **t=3**:\n  - We need $s_2[2]$ to compute $s_3[3]$. $s_1[1] = x[1] = 4(1)-1=3$. $s_2[2] = s_1[1] + k = 3 + 2 = 5$.\n  - $y_{\\mathrm{NB}}[3] = m \\cdot s_2[2] = 3 \\cdot 5 = 15$.\n\nFor $t \\ge 3$, the output is a function of the input from two cycles prior:\n$y_{\\mathrm{NB}}[t] = m \\cdot s_2[t-1] = m \\cdot (s_1[t-2] + k) = m \\cdot (x[t-2] + k)$.\n$y_{\\mathrm{NB}}[t] = 3 \\cdot ((4(t-2)-1) + 2) = 3 \\cdot (4t - 8 - 1 + 2) = 3 \\cdot (4t - 7) = 12t - 21$.\n\n**4. Calculation of the Sum**\n\nWe need to compute $D=\\sum_{t=1}^{10}\\left(y_{\\mathrm{B}}[t]-y_{\\mathrm{NB}}[t]\\right)$.\n\n- $t=1: y_{\\mathrm{B}}[1] = 12(1)+3=15$. $y_{\\mathrm{NB}}[1]=0$. Difference = $15 - 0 = 15$.\n- $t=2: y_{\\mathrm{B}}[2] = 12(2)+3=27$. $y_{\\mathrm{NB}}[2]=6$. Difference = $27 - 6 = 21$.\n- For $t \\in [3, 10]$ (8 terms), the difference is constant:\n  $(12t + 3) - (12t - 21) = 24$.\n- The sum for these 8 terms is $8 \\times 24 = 192$.\n\nTotal sum $D = (15) + (21) + (192) = 36 + 192 = 228$.\n\nThe final result is 228, which confirms the validity of the provided answer.",
            "answer": "$$ \\boxed{228} $$"
        },
        {
            "introduction": "The RTL model is not the only abstraction used in verification; it is often analyzed by different tools that make different assumptions. This final exercise  illuminates a critical discrepancy between event-driven simulation and formal equivalence checking: the handling of unknown states. You will programmatically explore how a four-state simulation, which models the unknown value $X$, can reveal behaviors that are invisible in a two-state formal model, particularly in designs with incompletely reset logic. This practice highlights the importance of understanding the underlying assumptions of your EDA tools to prevent subtle but significant design bugs.",
            "id": "4294432",
            "problem": "Construct a self-contained programmatic experiment that formalizes the difference between two-state semantics, typical of certain formal equivalence checks in Electronic Design Automation (EDA), and four-state simulation semantics used by Hardware Description Languages (HDLs) such as Verilog when registers power up to an unknown value $X$. Consider a minimal Register Transfer Level (RTL) design that explicitly models a commonly encountered scenario: a register that is not reset, whose value is gated at the output by the reset line. The behavior is specified by the following mathematical model over discrete time steps $t \\in \\{0,1,\\dots,T-1\\}$ for a data width of $W$ bits.\n\nDefine the state register $q_t \\in \\{0,1,X\\}^W$, the asynchronous active-low reset signal represented as $rst\\_n_t \\in \\{0,1\\}$, a load-enable $sel_t \\in \\{0,1\\}$, and input data $d_t \\in \\{0,1\\}^W$. The design has no explicit reset on $q_t$; only the output is gated by reset. The output and next-state equations are:\n$$\ny_t = rst\\_n_t \\land q_t, \\quad q_{t+1} = \\begin{cases}\nd_t  \\text{if } sel_t = 1, \\\\\nq_t  \\text{if } sel_t = 0.\n\\end{cases}\n$$\nIn four-state simulation semantics (used by Hardware Description Languages (HDLs)), the initial condition is $q_0 = X^W$, meaning all bits of $q_0$ are $X$. The logical operators follow four-state rules with controlling values, specifically for the output equation with an $AND$: if $rst\\_n_t = 0$ then $y_t = 0^W$; if $rst\\_n_t = 1$ then $y_t = q_t$. In two-state semantics (typical of certain formal equivalence modes), all values are in $\\{0,1\\}$ and the initial register state is assumed to be a known constant $b \\in \\{0,1\\}$, that is $q_0^{(2)} = b^W$, with the same next-state update equation.\n\nTime semantics are as follows: the output $y_t$ is computed from the current state $q_t$ and $rst\\_n_t$; afterwards, the state is updated to $q_{t+1}$ using $sel_t$ and $d_t$. This models synchronous state updates driven by a clock, where $y_t$ is observed prior to the state transition at time $t$.\n\nDefine $y_t^{(4)}$ as the output under four-state semantics and $y_t^{(2)}$ as the output under two-state semantics. A time-step mismatch indicator $M(t)$ is defined as:\n$$\nM(t) = \\begin{cases}\n1  \\text{if any bit of } y_t^{(4)} \\text{ is } X \\text{ or if } y_t^{(4)} \\neq y_t^{(2)} \\text{ bitwise}, \\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\nThe quantity of interest is the total number of mismatch time steps:\n$$\n\\mathrm{mismatch\\_count} = \\sum_{t=0}^{T-1} M(t).\n$$\n\nWrite a program that, for each test case, simulates both semantics over $T$ cycles, with $rst\\_n_t = 0$ for the first $R$ cycles and $rst\\_n_t = 1$ thereafter, and computes $\\mathrm{mismatch\\_count}$.\n\nYour program must implement:\n- Four-state values for $q_t$ and $y_t$ as per the above definition, including $X$ propagation at the output when $rst\\_n_t = 1$ and $q_t$ contains $X$.\n- Two-state values with an assumed power-up bit $b \\in \\{0,1\\}$ for $q_0^{(2)}$, with all logic in $\\{0,1\\}$.\n- The synchronous timing model where $y_t$ is computed from $q_t$ and $rst\\_n_t$ prior to computing $q_{t+1}$.\n\nUse the following test suite, each specified as $(W, T, R, b, sel, d)$:\n- Test $1$: $W = 1$, $T = 6$, $R = 2$, $b = 0$, $sel = [0,0,0,0,1,0]$, $d = [1,1,1,1,1,1]$.\n- Test $2$: $W = 8$, $T = 8$, $R = 3$, $b = 0$, $sel = [0,0,0,0,0,1,0,0]$, $d = [170,85,255,0,1,2,3,4]$.\n- Test $3$: $W = 4$, $T = 3$, $R = 3$, $b = 0$, $sel = [1,0,1]$, $d = [5,10,15]$.\n- Test $4$: $W = 2$, $T = 6$, $R = 1$, $b = 0$, $sel = [0,1,0,0,1,0]$, $d = [3,1,2,0,3,1]$.\n\nAll list entries are integers, and for $d$ entries the values must be interpreted as $W$-bit binary words. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3,result4]$). Each $resulti$ must be an integer equal to $\\mathrm{mismatch\\_count}$ for the corresponding test case. No physical units are involved. All angles, if any, must be in radians. All ratios must be expressed as decimals or fractions, not percentages.",
            "solution": "The problem statement has been analyzed and is deemed valid. It is scientifically grounded in the principles of digital logic design and Electronic Design Automation (EDA), well-posed with a clear and complete set of definitions and constraints, and objective in its formulation. The problem correctly models a common scenario where the divergence between a four-state simulation (typical of Hardware Description Languages like Verilog) and a two-state formal model becomes apparent, specifically concerning uninitialized registers.\n\nThe task is to construct a computational experiment to quantify the difference in behavior between these two semantic models for a given Register Transfer Level (RTL) design. The quantity of interest is the $\\mathrm{mismatch\\_count}$, defined as the total number of time steps where the outputs of the two models diverge.\n\nThe solution proceeds by simulating the system dynamics for both the four-state and two-state models over a discrete time horizon $t \\in \\{0, 1, \\dots, T-1\\}$.\n\nFirst, we must establish a concrete representation for the logical values. The two-state model utilizes the set $\\{0, 1\\}$, which can be directly represented by standard integers. The four-state model requires values from $\\{0, 1, X\\}$. We will represent these as integers, where $0$ corresponds to logical $0$, $1$ corresponds to logical $1$, and $-1$ is used to represent the unknown state $X$. All multibit vectors, such as the state register $q_t$ and data inputs $d_t$, are modeled as arrays of these integer representations. The input data $d_t$, provided as integers, must be converted to their $W$-bit binary vector equivalents.\n\nThe simulation proceeds iteratively for each time step $t$ from $0$ to $T-1$, following the specified synchronous timing model where outputs are computed from the current state before the state is updated for the next cycle.\n\nAt each time step $t$:\n1.  The value of the active-low reset signal, $rst\\_n_t$, is determined. As specified, $rst\\_n_t = 0$ for $t  R$ and $rst\\_n_t = 1$ for $t \\ge R$.\n\n2.  The output of the four-state model, $y_t^{(4)}$, is computed based on the equation $y_t = rst\\_n_t \\land q_t$. The logical AND operation adheres to four-state logic with controlling values. If $rst\\_n_t = 0$, its controlling nature forces the output to a known state, thus $y_t^{(4)} = 0^W$. If $rst\\_n_t = 1$, which is a non-controlling value for an AND gate, the output passes the register's value through, i.e., $y_t^{(4)} = q_t^{(4)}$.\n\n3.  The output of the two-state model, $y_t^{(2)}$, is computed similarly. The operation $rst\\_n_t \\land q_t^{(2)}$ results in $y_t^{(2)} = 0^W$ if $rst\\_n_t = 0$ and $y_t^{(2)} = q_t^{(2)}$ if $rst\\_n_t = 1$. Since all values are in $\\{0, 1\\}$, this is a standard bitwise operation.\n\n4.  The mismatch indicator $M(t)$ is evaluated. A mismatch occurs if the four-state output contains any unknown bits, or if it is fully defined but differs from the two-state output. Formally, $M(t)=1$ if any bit of $y_t^{(4)}$ is $X$ (represented by $-1$) or if $y_t^{(4)}$ and $y_t^{(2)}$ are not bitwise identical. Otherwise, $M(t)=0$. The total $\\mathrm{mismatch\\_count}$ is incremented if $M(t)=1$.\n\n5.  The next state for both models, $q_{t+1}^{(4)}$ and $q_{t+1}^{(2)}$, is determined by the next-state equation:\n    $$\n    q_{t+1} = \\begin{cases}\n    d_t  \\text{if } sel_t = 1, \\\\\n    q_t  \\text{if } sel_t = 0.\n    \\end{cases}\n    $$\n    If the load-enable signal $sel_t = 1$, both state registers $q_t^{(4)}$ and $q_t^{(2)}$ are updated with the value of the input data vector $d_t$. This action can clear the unknown state $X$ from $q_t^{(4)}$. If $sel_t = 0$, both registers retain their current values.\n\nThis entire procedure is encapsulated within a function that takes a test case's parameters $(W, T, R, b, sel, d)$ and returns the final computed $\\mathrm{mismatch\\_count}$. The initial conditions are set at $t=0$: $q_0^{(4)} = X^W$ and $q_0^{(2)} = b^W$. The simulation is then executed for all specified test cases to produce the required list of results.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the simulation for all test cases and print the results.\n    \"\"\"\n    # Test cases defined as (W, T, R, b, sel, d)\n    test_cases = [\n        (1, 6, 2, 0, [0, 0, 0, 0, 1, 0], [1, 1, 1, 1, 1, 1]),\n        (8, 8, 3, 0, [0, 0, 0, 0, 0, 1, 0, 0], [170, 85, 255, 0, 1, 2, 3, 4]),\n        (4, 3, 3, 0, [1, 0, 1], [5, 10, 15]),\n        (2, 6, 1, 0, [0, 1, 0, 0, 1, 0], [3, 1, 2, 0, 3, 1]),\n    ]\n\n    results = []\n    for W, T, R, b, sel, d in test_cases:\n        result = run_simulation(W, T, R, b, sel, d)\n        results.append(result)\n\n    # Print the final results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef int_to_bits(n, width):\n    \"\"\"\n    Converts an integer to its W-bit binary representation as a NumPy array.\n    \"\"\"\n    if n  0:\n        raise ValueError(\"Input data must be non-negative.\")\n    binary_string = format(n, f'0{width}b')\n    return np.array([int(bit) for bit in binary_string], dtype=int)\n\ndef run_simulation(W, T, R, b, sel, d):\n    \"\"\"\n    Simulates the RTL design for a single test case under both 4-state and 2-state semantics.\n\n    Args:\n        W (int): Data width in bits.\n        T (int): Total number of time steps (cycles).\n        R (int): Number of initial cycles where reset is active.\n        b (int): Initial value (0 or 1) for the 2-state register bits.\n        sel (list): List of load-enable signals for each time step.\n        d (list): List of input data values for each time step.\n\n    Returns:\n        int: The total number of mismatch time steps.\n    \"\"\"\n    # A constant to represent the unknown 'X' state.\n    X_STATE = -1\n    mismatch_count = 0\n\n    # 1. Initialize states\n    # Four-state model: register starts at all 'X'\n    q_4 = np.full(W, X_STATE, dtype=int)\n    # Two-state model: register starts at a known constant 'b'\n    q_2 = np.full(W, b, dtype=int)\n\n    # Convert integer data inputs to W-bit NumPy arrays\n    d_bits_vectors = [int_to_bits(val, W) for val in d]\n\n    # 2. Loop through time steps t = 0 to T-1\n    for t in range(T):\n        # Determine rst_n_t based on the time step t and reset duration R\n        rst_n_t = 0 if t  R else 1\n\n        # 3. Calculate outputs y_t for both models\n        # Four-state output y_t^(4)\n        if rst_n_t == 0:\n            # The controlling '0' on the AND gate makes the output '0'\n            y_4 = np.zeros(W, dtype=int)\n        else:\n            # The '1' on the AND gate passes the register value through\n            y_4 = q_4.copy()\n\n        # Two-state output y_t^(2)\n        if rst_n_t == 0:\n            y_2 = np.zeros(W, dtype=int)\n        else:\n            y_2 = q_2.copy()\n            \n        # 4. Check for mismatch M(t)\n        # Mismatch if y_4 has any 'X' bits\n        has_x = np.any(y_4 == X_STATE)\n        if has_x:\n            mismatch_count += 1\n        else:\n            # Or if y_4 is a known value but differs from y_2\n            if not np.array_equal(y_4, y_2):\n                mismatch_count += 1\n\n        # 5. Calculate next states q_{t+1}\n        sel_t = sel[t]\n        d_t_bits = d_bits_vectors[t]\n\n        if sel_t == 1:\n            # Update both registers with the input data if sel_t is 1\n            q_4 = d_t_bits.copy()\n            q_2 = d_t_bits.copy()\n        # If sel_t is 0, registers q_4 and q_2 retain their old values (no update needed)\n\n    return mismatch_count\n\n# Execute the main function\nsolve()\n```"
        }
    ]
}