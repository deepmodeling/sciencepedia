{
    "hands_on_practices": [
        {
            "introduction": "本练习聚焦于 RTL 设计中最关键的区别：阻塞赋值 (`=`) 与非阻塞赋值 (`=`)。理解这一点对于正确地为流水线等并发硬件建模以及避免仿真与综合不匹配至关重要。通过本练习，您将手动追踪一个简单的流水线，观察这两种赋值方式如何导致截然不同的硬件结构和行为 。",
            "id": "4294389",
            "problem": "考虑一个在电子设计自动化 (EDA) 背景下，使用硬件描述语言 (HDL) 描述的三级同步流水线的周期精确寄存器传输级 (RTL) 模型。该流水线由三个寄存器 $s_1$、 $s_2$ 和 $s_3$ 组成，由一个具有上升沿触发的单一全局时钟进行同步。所有寄存器在周期 $t=0$ 时初始化为零，因此 $s_1[0]=0$、$s_2[0]=0$ 和 $s_3[0]=0$。该流水线处理一个在每个时钟周期采样的标量输入流 $x[t]$，其中输入由离散时间函数 $x[t]=4t-1$ 定义，适用于所有整数周期 $t \\geq 1$。流水线每个阶段的变换是在第 2 阶段增加 $k=2$ 和在第 3 阶段乘以 $m=3$。\n\n您将分析 RTL 抽象级别下的两种 HDL 赋值语义：\n\n1. 阻塞赋值语义：在单个同步更新块内，赋值按程序顺序执行，并立即更新目标变量。通过同一周期内的有序更新对此进行建模：\n$\n\\begin{aligned}\ns_1[t] = x[t],\\\\\ns_2[t] = s_1[t] + k,\\\\\ns_3[t] = m \\cdot s_2[t].\n\\end{aligned}\n$\n将在阻塞赋值语义下，可观察的流水线输出定义为 $y_{\\mathrm{B}}[t] = s_3[t]$。\n\n2. 非阻塞赋值语义：在单个同步更新块内，所有赋值都会调度更新，使其在时钟节拍结束时并发发生，因此右侧表达式读取的是前一个周期的值。通过并发更新对此进行建模：\n$\n\\begin{aligned}\ns_1[t] = x[t],\\\\\ns_2[t] = s_1[t-1] + k,\\\\\ns_3[t] = m \\cdot s_2[t-1].\n\\end{aligned}\n$\n将在非阻塞赋值语义下，可观察的流水线输出定义为 $y_{\\mathrm{NB}}[t] = s_3[t]$。\n\n从这些定义和 $t=0$ 时的初始化开始，计算 $t=1,2,\\dots,10$ 时逐周期的输出 $y_{\\mathrm{B}}[t]$ 和 $y_{\\mathrm{NB}}[t]$。然后计算标量\n$\nD=\\sum_{t=1}^{10}\\left(y_{\\mathrm{B}}[t]-y_{\\mathrm{NB}}[t]\\right).\n$\n用无单位的最终数值表示 $D$。无需四舍五入。",
            "solution": "我们分步计算两种赋值语义下的输出，并最终求和。设 $k=2$，$m=3$，$x[t]=4t-1$。初始条件为 $s_1[0]=s_2[0]=s_3[0]=0$。\n\n**1. 阻塞赋值 ($y_{\\mathrm{B}}[t]$)**\n在阻塞赋值下，更新在同一时钟周期内按顺序发生。\n$s_1[t] = x[t]$\n$s_2[t] = s_1[t] + k = x[t] + 2$\n$y_{\\mathrm{B}}[t] = s_3[t] = m \\cdot s_2[t] = 3 \\cdot (x[t] + 2) = 3 \\cdot ((4t-1) + 2) = 3(4t+1) = 12t+3$。\n该公式适用于所有 $t \\ge 1$。\n\n**2. 非阻塞赋值 ($y_{\\mathrm{NB}}[t]$)**\n在非阻塞赋值下，更新是并发的，右侧读取的是前一个周期的值。\n$s_1[t] = x[t]$\n$s_2[t] = s_1[t-1] + k$\n$y_{\\mathrm{NB}}[t] = s_3[t] = m \\cdot s_2[t-1]$\n我们追踪前几个周期：\n-   **t=1**:\n    $s_1[1] = x[1] = 3$\n    $s_2[1] = s_1[0] + k = 0 + 2 = 2$\n    $y_{\\mathrm{NB}}[1] = s_3[1] = m \\cdot s_2[0] = 3 \\cdot 0 = 0$\n-   **t=2**:\n    $s_1[2] = x[2] = 7$\n    $s_2[2] = s_1[1] + k = 3 + 2 = 5$\n    $y_{\\mathrm{NB}}[2] = s_3[2] = m \\cdot s_2[1] = 3 \\cdot 2 = 6$\n-   **对于 $t \\ge 3$**:\n    $y_{\\mathrm{NB}}[t] = m \\cdot s_2[t-1] = m \\cdot (s_1[t-2] + k) = m \\cdot (x[t-2] + k)$\n    $y_{\\mathrm{NB}}[t] = 3 \\cdot ((4(t-2)-1) + 2) = 3 \\cdot (4t - 8 - 1 + 2) = 3(4t-7) = 12t-21$\n\n**3. 计算差值之和 D**\n$D = \\sum_{t=1}^{10} (y_{\\mathrm{B}}[t] - y_{\\mathrm{NB}}[t])$\n-   $t=1$: $y_{\\mathrm{B}}[1] - y_{\\mathrm{NB}}[1] = (12 \\cdot 1 + 3) - 0 = 15$\n-   $t=2$: $y_{\\mathrm{B}}[2] - y_{\\mathrm{NB}}[2] = (12 \\cdot 2 + 3) - 6 = 27 - 6 = 21$\n-   $t=3$ 到 $t=10$ (共8个周期):\n    $y_{\\mathrm{B}}[t] - y_{\\mathrm{NB}}[t] = (12t+3) - (12t-21) = 24$\n-   将所有差值相加：\n    $D = 15 + 21 + (8 \\times 24) = 36 + 192 = 228$",
            "answer": "$$ \\boxed{228} $$"
        },
        {
            "introduction": "在了解了不同 HDL 赋值语句的*效果*之后，我们现在将探究仿真器*如何*处理它们。本练习揭示了抽象层之下的机制，带您了解每个 HDL 仿真器核心的事件驱动引擎，包括增量周期 (delta cycle) 这一关键概念。通过手动单步执行仿真，您将深刻体会到仿真器如何在单个时间步内解决依赖关系并达到稳定状态 。",
            "id": "4294418",
            "problem": "在一个用于电子设计自动化 (EDA) 领域中简单硬件描述语言 (HDL) 的事件驱动仿真框架中，考虑如下定义的离散时间、delta周期仿真语义。仿真时间被建模为 $t \\in \\mathbb{R}_{\\ge 0}$，并带有一个以整型纳秒为索引的事件轮。在固定的时间戳 $t$ 内，存在一个有序的delta周期序列 $\\delta \\in \\mathbb{N}$，该序列会一直进行直到达到静止状态。仿真器维护：\n- 一个活动进程队列 $\\mathcal{A}_{t,\\delta}$，用于存放在时间 $t$ 的delta周期 $\\delta$ 期间要执行的进程。\n- 一个零延迟更新多重集 $\\mathcal{U}_{t,\\delta}$，其中包含待在时间 $t$ 的delta周期 $\\delta$ 结束时提交的信号更新。\n- 一个时间轮 $\\mathcal{T}[t']$，对于 $t'  t$，其中包含将在时间 $t'$ 的 $\\delta = 0$ 时提交的非零延迟事务。\n\n执行语义如下：\n- 在给定的时间 $t$，delta周期 $\\delta = 0$ 开始时，将 $\\mathcal{T}[t]$ 中的所有事务（如果有）作为初始的零延迟更新集 $\\mathcal{U}_{t,0}$。在 $\\delta = 0$ 时的第一次提交之前，没有进程会被触发。\n- 在固定时间 $t$ 的任何delta周期 $\\delta$ 结束时，$\\mathcal{U}_{t,\\delta}$ 中的所有更新都被提交，从而产生信号事件。任何其敏感性列表包含发生了事件的信号的进程，都会被加入队列 $\\mathcal{A}_{t,\\delta+1}$。同时，在进程执行期间遇到的任何非零延迟赋值都会被附加到其目标时间 $t'  t$ 对应的 $\\mathcal{T}[t']$ 中。\n- 在一个delta周期内，$\\mathcal{A}_{t,\\delta}$ 中的所有进程都按照进程标识符递增的确定性顺序（即 $P_1$ 在 $P_2$ 之前）执行至完成。由一个进程在 $\\delta$ 期间执行的零延迟赋值会向 $\\mathcal{U}_{t,\\delta}$ 添加条目，以便在同一个 $\\delta$ 结束时提交。\n- 如果在提交 $\\mathcal{U}_{t,\\delta}$ 之后没有新入队的进程，则时间 $t$ 达到静止状态，仿真推进到最小的 $t'  t$ 且 $\\mathcal{T}[t']$ 非空的时刻。\n\n考虑以下小型HDL，它包含两个并发进程和一个显式激励，所有这些都作用于布尔信号 $x$ 和 $y$ 上，初始值为 $x = 0$ 和 $y = 0$：\n- 进程 $P_1$：敏感性列表 $\\{x\\}$。在时间 $t$ 每当 $x$ 发生事件时，执行一个零延迟赋值 $y \\leftarrow \\lnot y$（即，调度一个对 $y$ 的更新，无惯性延迟，将在当前delta周期结束时提交）。\n- 进程 $P_2$：敏感性列表 $\\{y\\}$。在时间 $t$ 每当 $y$ 发生事件时，执行一个传输延迟赋值 $x \\leftarrow y$，延迟为 $2$ 纳秒（即，使用执行 $P_2$ 时观察到的 $y$ 值，将对 $x$ 的更新调度到 $\\mathcal{T}[t+2\\,\\mathrm{ns}]}$ 中）。\n- 外部激励 $S$：调度对 $x$ 的两个零延迟更新，即在 $t = 0\\,\\mathrm{ns}$ 时 $x \\leftarrow 1$ 和在 $t = 1\\,\\mathrm{ns}$ 时 $x \\leftarrow 0$。每个这样的调度更新在对应的时间 $t$ 进入 $\\mathcal{U}_{t,0}$。\n\n假设不存在其他进程或激励，并且唯一由敏感性引发的触发就是上述描述的那些。应用delta周期语义，对系统从 $t = 0\\,\\mathrm{ns}$ 到 $t = 3\\,\\mathrm{ns}$（含）进行仿真。对于每个时间戳 $t \\in \\{0\\,\\mathrm{ns}, 1\\,\\mathrm{ns}, 2\\,\\mathrm{ns}, 3\\,\\mathrm{ns}\\}$ 和每个实际发生的delta周期 $\\delta$，列出 $\\mathcal{U}_{t,\\delta}$ 的内容、触发的 $\\mathcal{A}_{t,\\delta}$ 中的进程，以及添加到 $\\mathcal{T}[t']$ 中的任何条目。然后计算在这四个时间戳内执行的delta周期的累积数量 $N$（计算在给定时间 $t$ 开始的每个 $\\delta$，直到在那个 $t$ 达到静止状态）。以无单位的单个整数形式提供 $N$ 的最终答案。",
            "solution": "该问题陈述是有效的。它在科学上基于数字逻辑仿真的原理，具有确定性的规则集，问题设定良好，并且陈述客观。我们可以对系统进行逐步仿真。\n\n在时间 $t=0$ 时，系统的初始状态为 $x=0$ 和 $y=0$。外部激励 $S$ 用两个初始事务填充时间轮 $\\mathcal{T}$：\n- $\\mathcal{T}[0] = \\{(x, 1)\\}$\n- $\\mathcal{T}[1] = \\{(x, 0)\\}$\n$\\mathcal{T}$ 中所有其他的时间槽最初都是空的。仿真开始时，推进到第一个非空的时间槽，即 $t=0\\,\\mathrm{ns}$。\n\n**$t=0\\,\\mathrm{ns}$ 的仿真追踪**\n此时间步开始时的信号值为 $x=0, y=0$。\n\n- **Delta周期 $\\delta=0$**：\n    - 仿真在 $t=0, \\delta=0$ 开始。来自 $\\mathcal{T}[0]$ 的事务被移至零延迟更新多重集：$\\mathcal{U}_{0,0} = \\{(x, 1)\\}$。\n    - 根据规则，活动进程队列为空：$\\mathcal{A}_{0,0} = \\emptyset$。没有进程被执行。\n    - 在delta周期结束时，$\\mathcal{U}_{0,0}$ 中的更新被提交。信号 $x$ 从 $0$ 变为 $1$。这构成了 $x$ 上的一个事件。\n    - 新的信号值为 $x=1, y=0$。\n    - 进程 $P_1$ 对 $x$ 上的事件敏感，因此它被加入到下一个delta周期的队列中：$\\mathcal{A}_{0,1} = \\{P_1\\}$。\n    - 系统不是静止的。\n\n- **Delta周期 $\\delta=1$**：\n    - 活动进程队列为 $\\mathcal{A}_{0,1} = \\{P_1\\}$。更新多重集初始为空：$\\mathcal{U}_{0,1} = \\emptyset$。\n    - 进程 $P_1$ 被执行。它执行一个零延迟赋值 $y \\leftarrow \\lnot y$。$y$ 的当前值为 $0$，所以赋值为 $y \\leftarrow 1$。这向当前的更新多重集添加一个条目：$\\mathcal{U}_{0,1} = \\{(y, 1)\\}$。\n    - 在delta周期结束时，$\\mathcal{U}_{0,1}$ 中的更新被提交。信号 $y$ 从 $0$ 变为 $1$。这构成了 $y$ 上的一个事件。\n    - 新的信号值为 $x=1, y=1$。\n    - 进程 $P_2$ 对 $y$ 上的事件敏感，因此它被加入到下一个delta周期的队列中：$\\mathcal{A}_{0,2} = \\{P_2\\}$。\n    - 系统不是静止的。\n\n- **Delta周期 $\\delta=2$**：\n    - 活动进程队列为 $\\mathcal{A}_{0,2} = \\{P_2\\}$。更新多重集初始为空：$\\mathcal{U}_{0,2} = \\emptyset$。\n    - 进程 $P_2$ 被执行。它调度一个传输延迟赋值 $x \\leftarrow y$，延迟为 $2\\,\\mathrm{ns}$。执行时 $y$ 的值为 $1$。该事务被调度在时间 $t+2 = 0+2 = 2\\,\\mathrm{ns}$。\n    - 一个条目被添加到时间轮：$\\mathcal{T}[2] \\leftarrow \\mathcal{T}[2] \\cup \\{(x, 1)\\}$。\n    - 没有生成零延迟更新，所以 $\\mathcal{U}_{0,2}$ 保持为空。\n    - 在delta周期结束时，$\\mathcal{U}_{0,2}$ 被提交。由于它为空，没有信号改变，也没有事件生成。\n    - 下一个delta周期的活动进程队列为空：$\\mathcal{A}_{0,3} = \\emptyset$。\n    - 系统在时间 $t=0$ 达到静止状态。\n\n在 $t=0\\,\\mathrm{ns}$ 共发生了 $3$ 个delta周期（$\\delta=0, 1, 2$）。\n\n**$t=1\\,\\mathrm{ns}$ 的仿真追踪**\n仿真器推进到下一个非空的时间槽，$t=1\\,\\mathrm{ns}$。此时间步开始时的信号值为 $x=1, y=1$。\n\n- **Delta周期 $\\delta=0$**：\n    - $\\mathcal{U}_{1,0} = \\{(x, 0)\\}$ 由 $\\mathcal{T}[1]$ 形成。$\\mathcal{A}_{1,0} = \\emptyset$。\n    - 更新被提交。信号 $x$ 从 $1$ 变为 $0$，产生一个事件。\n    - 新的信号值为 $x=0, y=1$。\n    - $P_1$ 被入队：$\\mathcal{A}_{1,1} = \\{P_1\\}$。不是静止的。\n\n- **Delta周期 $\\delta=1$**：\n    - $\\mathcal{A}_{1,1} = \\{P_1\\}$。\n    - $P_1$ 执行 $y \\leftarrow \\lnot y$。由于 $y=1$，赋值为 $y \\leftarrow 0$。此更新被添加到 $\\mathcal{U}_{1,1} = \\{(y, 0)\\}$。\n    - 更新被提交。信号 $y$ 从 $1$ 变为 $0$，产生一个事件。\n    - 新的信号值为 $x=0, y=0$。\n    - $P_2$ 被入队：$\\mathcal{A}_{1,2} = \\{P_2\\}$。不是静止的。\n\n- **Delta周期 $\\delta=2$**：\n    - $\\mathcal{A}_{1,2} = \\{P_2\\}$。\n    - $P_2$ 执行 $x \\leftarrow y$，延迟为 $2\\,\\mathrm{ns}$。$y$ 的值为 $0$。该事务用于 $t+2 = 1+2 = 3\\,\\mathrm{ns}$。\n    - 一个条目被添加到时间轮：$\\mathcal{T}[3] \\leftarrow \\mathcal{T}[3] \\cup \\{(x, 0)\\}$。\n    - $\\mathcal{U}_{1,2}$ 为空。提交时没有事件产生。\n    - $\\mathcal{A}_{1,3} = \\emptyset$。系统在 $t=1$ 时达到静止状态。\n\n在 $t=1\\,\\mathrm{ns}$ 共发生了 $3$ 个delta周期（$\\delta=0, 1, 2$）。\n\n**$t=2\\,\\mathrm{ns}$ 的仿真追踪**\n仿真器推进到 $t=2\\,\\mathrm{ns}$。信号值为 $x=0, y=0$。\n\n- **Delta周期 $\\delta=0$**：\n    - $\\mathcal{U}_{2,0} = \\{(x, 1)\\}$ 由 $\\mathcal{T}[2]$ 形成。$\\mathcal{A}_{2,0} = \\emptyset$。\n    - 更新被提交。信号 $x$ 从 $0$ 变为 $1$，产生一个事件。\n    - 新的信号值为 $x=1, y=0$。\n    - $P_1$ 被入队：$\\mathcal{A}_{2,1} = \\{P_1\\}$。不是静止的。\n\n- **Delta周期 $\\delta=1$**：\n    - $\\mathcal{A}_{2,1} = \\{P_1\\}$。\n    - $P_1$ 执行 $y \\leftarrow \\lnot y$。由于 $y=0$，赋值为 $y \\leftarrow 1$。此更新被添加到 $\\mathcal{U}_{2,1} = \\{(y, 1)\\}$。\n    - 更新被提交。信号 $y$ 从 $0$ 变为 $1$，产生一个事件。\n    - 新的信号值为 $x=1, y=1$。\n    - $P_2$ 被入队：$\\mathcal{A}_{2,2} = \\{P_2\\}$。不是静止的。\n\n- **Delta周期 $\\delta=2$**：\n    - $\\mathcal{A}_{2,2} = \\{P_2\\}$。\n    - $P_2$ 执行 $x \\leftarrow y$，延迟为 $2\\,\\mathrm{ns}$。$y$ 的值为 $1$。该事务用于 $t+2 = 2+2 = 4\\,\\mathrm{ns}$。\n    - 一个条目被添加到时间轮：$\\mathcal{T}[4] \\leftarrow \\mathcal{T}[4] \\cup \\{(x, 1)\\}$。\n    - $\\mathcal{U}_{2,2}$ 为空。没有事件产生。\n    - $\\mathcal{A}_{2,3} = \\emptyset$。系统在 $t=2$ 时达到静止状态。\n\n在 $t=2\\,\\mathrm{ns}$ 共发生了 $3$ 个delta周期（$\\delta=0, 1, 2$）。\n\n**$t=3\\,\\mathrm{ns}$ 的仿真追踪**\n仿真器推进到 $t=3\\,\\mathrm{ns}$。信号值为 $x=1, y=1$。\n\n- **Delta周期 $\\delta=0$**：\n    - $\\mathcal{U}_{3,0} = \\{(x, 0)\\}$ 由 $\\mathcal{T}[3]$ 形成。$\\mathcal{A}_{3,0} = \\emptyset$。\n    - 更新被提交。信号 $x$ 从 $1$ 变为 $0$，产生一个事件。\n    - 新的信号值为 $x=0, y=1$。\n    - $P_1$ 被入队：$\\mathcal{A}_{3,1} = \\{P_1\\}$。不是静止的。\n\n- **Delta周期 $\\delta=1$**：\n    - $\\mathcal{A}_{3,1} = \\{P_1\\}$。\n    - $P_1$ 执行 $y \\leftarrow \\lnot y$。由于 $y=1$，赋值为 $y \\leftarrow 0$。此更新被添加到 $\\mathcal{U}_{3,1} = \\{(y, 0)\\}$。\n    - 更新被提交。信号 $y$ 从 $1$ 变为 $0$，产生一个事件。\n    - 新的信号值为 $x=0, y=0$。\n    - $P_2$ 被入队：$\\mathcal{A}_{3,2} = \\{P_2\\}$。不是静止的。\n\n- **Delta周期 $\\delta=2$**：\n    - $\\mathcal{A}_{3,2} = \\{P_2\\}$。\n    - $P_2$ 执行 $x \\leftarrow y$，延迟为 $2\\,\\mathrm{ns}$。$y$ 的值为 $0$。该事务用于 $t+2 = 3+2 = 5\\,\\mathrm{ns}$。\n    - 一个条目被添加到时间轮：$\\mathcal{T}[5] \\leftarrow \\mathcal{T}[5] \\cup \\{(x, 0)\\}$。\n    - $\\mathcal{U}_{3,2}$ 为空。没有事件产生。\n    - $\\mathcal{A}_{3,3} = \\emptyset$。系统在 $t=3$ 时达到静止状态。\n\n在 $t=3\\,\\mathrm{ns}$ 共发生了 $3$ 个delta周期（$\\delta=0, 1, 2$）。\n\n**累计计数**\ndelta周期的累积数量 $N$ 是每个时间戳的计数总和。\n$N = (\\text{在 } t=0 \\text{ 的周期数}) + (\\text{在 } t=1 \\text{ 的周期数}) + (\\text{在 } t=2 \\text{ 的周期数}) + (\\text{在 } t=3 \\text{ 的周期数})$\n$N = 3 + 3 + 3 + 3 = 12$。",
            "answer": "$$\\boxed{12}$$"
        },
        {
            "introduction": "HDL 仿真并非我们分析设计的唯一方法；形式验证是另一种关键的 EDA 工具，但它通常使用不同的抽象级别。本练习探讨了仿真中使用的四值逻辑 ($0$, $1$, $X$, $Z$) 与形式等价性检查中常见的二值逻辑 ($0$, $1$) 之间的实际差异。您将通过编程方式证明，未初始化的寄存器如何导致这两个世界之间的行为不匹配，这对于实现稳健的验证至关重要 。",
            "id": "4294432",
            "problem": "构建一个独立的编程实验，以形式化地描述两态语义与四态仿真语义之间的差异。两态语义是电子设计自动化（EDA）中某些形式等效性检查的典型特征，而四态仿真语义则用于像 Verilog 这样的硬件描述语言（HDL），其中寄存器上电时可能处于未知值 $X$。考虑一个最小的寄存器传输级（RTL）设计，该设计明确地模拟了一个常见场景：一个没有复位的寄存器，其输出值由复位线进行门控。对于 $W$ 位的数据宽度，其行为由以下在离散时间步 $t \\in \\{0,1,\\dots,T-1\\}$ 上的数学模型指定。\n\n定义状态寄存器 $q_t \\in \\{0,1,X\\}^W$，表示为 $rst\\_n_t \\in \\{0,1\\}$ 的异步低电平有效复位信号，加载使能信号 $sel_t \\in \\{0,1\\}$，以及输入数据 $d_t \\in \\{0,1\\}^W$。设计中对 $q_t$ 没有显式复位；只有输出由复位信号进行门控。输出和次态方程如下：\n$$\ny_t = rst\\_n_t \\land q_t, \\quad q_{t+1} = \\begin{cases}\nd_t  \\text{if } sel_t = 1, \\\\\nq_t  \\text{if } sel_t = 0.\n\\end{cases}\n$$\n在四态仿真语义（硬件描述语言 (HDL) 使用）中，初始条件为 $q_0 = X^W$，意味着 $q_0$ 的所有位均为 $X$。逻辑运算符遵循带有控制值的四态规则，特别是对于带有与（AND）运算的输出方程：如果 $rst\\_n_t = 0$，则 $y_t = 0^W$；如果 $rst\\_n_t = 1$，则 $y_t = q_t$。在两态语义（某些形式等效性模式的典型特征）中，所有值都在 $\\{0,1\\}$ 集合中，并且初始寄存器状态被假定为一个已知常数 $b \\in \\{0,1\\}$，即 $q_0^{(2)} = b^W$，次态更新方程相同。\n\n时序语义如下：输出 $y_t$ 由当前状态 $q_t$ 和 $rst\\_n_t$ 计算得出；之后，使用 $sel_t$ 和 $d_t$ 将状态更新为 $q_{t+1}$。这模拟了由时钟驱动的同步状态更新，其中在时间 $t$ 的状态转换之前观察到 $y_t$。\n\n定义 $y_t^{(4)}$ 为四态语义下的输出，$y_t^{(2)}$ 为两态语义下的输出。定义时间步不匹配指示器 $M(t)$ 如下：\n$$\nM(t) = \\begin{cases}\n1  \\text{if any bit of } y_t^{(4)} \\text{ is } X \\text{ or if } y_t^{(4)} \\neq y_t^{(2)} \\text{ bitwise}, \\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\n关注量是不匹配时间步的总数：\n$$\n\\mathrm{mismatch\\_count} = \\sum_{t=0}^{T-1} M(t).\n$$\n\n编写一个程序，对每个测试用例，在 $T$ 个周期内仿真两种语义，其中前 $R$ 个周期 $rst\\_n_t = 0$，之后 $rst\\_n_t = 1$，并计算 $\\mathrm{mismatch\\_count}$。\n\n您的程序必须实现：\n- 根据上述定义，$q_t$ 和 $y_t$ 的四态值，包括当 $rst\\_n_t = 1$ 且 $q_t$ 包含 $X$ 时在输出端的 $X$ 传播。\n- 带有假定上电位 $b \\in \\{0,1\\}$ 的 $q_0^{(2)}$ 的两态值，所有逻辑都在 $\\{0,1\\}$ 中。\n- 同步时序模型，其中 $y_t$ 在计算 $q_{t+1}$ 之前由 $q_t$ 和 $rst\\_n_t$ 计算得出。\n\n使用以下测试套件，每个测试用例指定为 $(W, T, R, b, sel, d)$：\n- 测试 1：$W = 1$, $T = 6$, $R = 2$, $b = 0$, $sel = [0,0,0,0,1,0]$, $d = [1,1,1,1,1,1]$。\n- 测试 2：$W = 8$, $T = 8$, $R = 3$, $b = 0$, $sel = [0,0,0,0,0,1,0,0]$, $d = [170,85,255,0,1,2,3,4]$。\n- 测试 3：$W = 4$, $T = 3$, $R = 3$, $b = 0$, $sel = [1,0,1]$, $d = [5,10,15]$。\n- 测试 4：$W = 2$, $T = 6$, $R = 1$, $b = 0$, $sel = [0,1,0,0,1,0]$, $d = [3,1,2,0,3,1]$。\n\n所有列表条目均为整数，对于 $d$ 条目，其值必须解释为 $W$ 位二进制字。您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[result1,result2,result3,result4]$）。每个 $resulti$ 必须是对应测试用例的 $\\mathrm{mismatch\\_count}$ 的整数值。不涉及物理单位。所有角度（如有）必须以弧度为单位。所有比率必须表示为小数或分数，而不是百分比。",
            "solution": "问题陈述已经过分析，并被认为是有效的。它在科学上基于数字逻辑设计和电子设计自动化（EDA）的原理，定义和约束清晰完整，问题提出得当，并且其表述是客观的。该问题正确地模拟了一个常见场景，在该场景中，四态仿真（如 Verilog 等硬件描述语言的典型特征）与两态形式化模型之间的差异变得明显，特别是在未初始化寄存器方面。\n\n任务是构建一个计算实验，以量化对于给定的寄存器传输级（RTL）设计，这两种语义模型在行为上的差异。关注量是 $\\mathrm{mismatch\\_count}$，定义为两个模型的输出发生分歧的时间步总数。\n\n解决方案通过在离散时间范围 $t \\in \\{0, 1, \\dots, T-1\\}$ 上仿真四态和两态模型的系统动态来进行。\n\n首先，我们必须为逻辑值建立一个具体的表示方法。两态模型使用集合 $\\{0, 1\\}$，这可以直接用标准整数表示。四态模型需要来自 $\\{0, 1, X\\}$ 的值。我们将这些值表示为整数，其中 $0$ 对应逻辑 $0$，$1$ 对应逻辑 $1$，并使用 $-1$ 来表示未知状态 $X$。所有的多位向量，如状态寄存器 $q_t$ 和数据输入 $d_t$，都被建模为这些整数表示的数组。以整数形式提供的输入数据 $d_t$ 必须转换为其等效的 $W$ 位二进制向量。\n\n仿真对每个时间步 $t$ 从 $0$到 $T-1$ 迭代进行，遵循指定的同步时序模型，其中输出在状态为下一个周期更新之前根据当前状态计算。\n\n在每个时间步 $t$：\n1.  确定低电平有效复位信号 $rst\\_n_t$ 的值。根据规定，$t  R$ 时 $rst\\_n_t = 0$，而 $t \\ge R$ 时 $rst\\_n_t = 1$。\n\n2.  四态模型的输出 $y_t^{(4)}$ 基于方程 $y_t = rst\\_n_t \\land q_t$ 计算。逻辑与（AND）运算遵循带有控制值的四态逻辑。如果 $rst\\_n_t = 0$，其控制特性会强制输出为已知状态，因此 $y_t^{(4)} = 0^W$。如果 $rst\\_n_t = 1$，这是与门（AND gate）的非控制值，输出将传递寄存器的值，即 $y_t^{(4)} = q_t^{(4)}$。\n\n3.  两态模型的输出 $y_t^{(2)}$ 以类似方式计算。运算 $rst\\_n_t \\land q_t^{(2)}$ 在 $rst\\_n_t = 0$ 时得到 $y_t^{(2)} = 0^W$，在 $rst\\_n_t = 1$ 时得到 $y_t^{(2)} = q_t^{(2)}$。由于所有值都在 $\\{0, 1\\}$ 中，这是一个标准的按位运算。\n\n4.  评估不匹配指示器 $M(t)$。如果不匹配发生，则四态输出包含任何未知位，或者它已完全定义但与两态输出不同。形式上，如果 $y_t^{(4)}$ 的任何位是 $X$（用 $-1$ 表示），或者 $y_t^{(4)}$ 和 $y_t^{(2)}$ 按位不相同，则 $M(t)=1$。否则，$M(t)=0$。如果 $M(t)=1$，则总 $\\mathrm{mismatch\\_count}$ 增加。\n\n5.  两个模型的次态 $q_{t+1}^{(4)}$ 和 $q_{t+1}^{(2)}$ 由次态方程确定：\n    $$\n    q_{t+1} = \\begin{cases}\n    d_t  \\text{if } sel_t = 1, \\\\\n    q_t  \\text{if } sel_t = 0.\n    \\end{cases}\n    $$\n    如果加载使能信号 $sel_t = 1$，状态寄存器 $q_t^{(4)}$ 和 $q_t^{(2)}$ 都会用输入数据向量 $d_t$ 的值进行更新。这个操作可以清除 $q_t^{(4)}$ 中的未知状态 $X$。如果 $sel_t = 0$，两个寄存器都保持其当前值。\n\n整个过程被封装在一个函数中，该函数接受一个测试用例的参数 $(W, T, R, b, sel, d)$ 并返回最终计算出的 $\\mathrm{mismatch\\_count}$。在 $t=0$ 时设置初始条件：$q_0^{(4)} = X^W$ 和 $q_0^{(2)} = b^W$。然后对所有指定的测试用例执行仿真，以生成所需的结果列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the simulation for all test cases and print the results.\n    \"\"\"\n    # Test cases defined as (W, T, R, b, sel, d)\n    test_cases = [\n        (1, 6, 2, 0, [0, 0, 0, 0, 1, 0], [1, 1, 1, 1, 1, 1]),\n        (8, 8, 3, 0, [0, 0, 0, 0, 0, 1, 0, 0], [170, 85, 255, 0, 1, 2, 3, 4]),\n        (4, 3, 3, 0, [1, 0, 1], [5, 10, 15]),\n        (2, 6, 1, 0, [0, 1, 0, 0, 1, 0], [3, 1, 2, 0, 3, 1]),\n    ]\n\n    results = []\n    for W, T, R, b, sel, d in test_cases:\n        result = run_simulation(W, T, R, b, sel, d)\n        results.append(result)\n\n    # Print the final results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef int_to_bits(n, width):\n    \"\"\"\n    Converts an integer to its W-bit binary representation as a NumPy array.\n    \"\"\"\n    if n  0:\n        raise ValueError(\"Input data must be non-negative.\")\n    binary_string = format(n, f'0{width}b')\n    return np.array([int(bit) for bit in binary_string], dtype=int)\n\ndef run_simulation(W, T, R, b, sel, d):\n    \"\"\"\n    Simulates the RTL design for a single test case under both 4-state and 2-state semantics.\n\n    Args:\n        W (int): Data width in bits.\n        T (int): Total number of time steps (cycles).\n        R (int): Number of initial cycles where reset is active.\n        b (int): Initial value (0 or 1) for the 2-state register bits.\n        sel (list): List of load-enable signals for each time step.\n        d (list): List of input data values for each time step.\n\n    Returns:\n        int: The total number of mismatch time steps.\n    \"\"\"\n    # A constant to represent the unknown 'X' state.\n    X_STATE = -1\n    mismatch_count = 0\n\n    # 1. Initialize states\n    # Four-state model: register starts at all 'X'\n    q_4 = np.full(W, X_STATE, dtype=int)\n    # Two-state model: register starts at a known constant 'b'\n    q_2 = np.full(W, b, dtype=int)\n\n    # Convert integer data inputs to W-bit NumPy arrays\n    d_bits_vectors = [int_to_bits(val, W) for val in d]\n\n    # 2. Loop through time steps t = 0 to T-1\n    for t in range(T):\n        # Determine rst_n_t based on the time step t and reset duration R\n        rst_n_t = 0 if t  R else 1\n\n        # 3. Calculate outputs y_t for both models\n        # Four-state output y_t^(4)\n        if rst_n_t == 0:\n            # The controlling '0' on the AND gate makes the output '0'\n            y_4 = np.zeros(W, dtype=int)\n        else:\n            # The '1' on the AND gate passes the register value through\n            y_4 = q_4.copy()\n\n        # Two-state output y_t^(2)\n        if rst_n_t == 0:\n            y_2 = np.zeros(W, dtype=int)\n        else:\n            y_2 = q_2.copy()\n            \n        # 4. Check for mismatch M(t)\n        # Mismatch if y_4 has any 'X' bits\n        has_x = np.any(y_4 == X_STATE)\n        if has_x:\n            mismatch_count += 1\n        else:\n            # Or if y_4 is a known value but differs from y_2\n            if not np.array_equal(y_4, y_2):\n                mismatch_count += 1\n\n        # 5. Calculate next states q_{t+1}\n        sel_t = sel[t]\n        d_t_bits = d_bits_vectors[t]\n\n        if sel_t == 1:\n            # Update both registers with the input data if sel_t is 1\n            q_4 = d_t_bits.copy()\n            q_2 = d_t_bits.copy()\n        # If sel_t is 0, registers q_4 and q_2 retain their old values (no update needed)\n\n    return mismatch_count\n\n# Execute the main function\nsolve()\n```"
        }
    ]
}