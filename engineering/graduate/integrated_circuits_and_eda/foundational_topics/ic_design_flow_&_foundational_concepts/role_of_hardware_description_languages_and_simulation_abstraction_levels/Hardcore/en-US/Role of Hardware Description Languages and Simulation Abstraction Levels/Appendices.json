{
    "hands_on_practices": [
        {
            "introduction": "At the heart of Register-Transfer Level (RTL) design is the challenge of accurately describing parallel hardware using a sequential language. This exercise explores the most fundamental aspect of this challenge: the distinction between blocking and non-blocking assignments. By simulating a simple pipeline using both semantics, you will gain a concrete understanding of why non-blocking assignments are essential for modeling synchronous logic and how blocking assignments can incorrectly describe hardware behavior, leading to simulation results that do not match the intended pipelined structure .",
            "id": "4294389",
            "problem": "Consider a cycle-accurate Register-Transfer Level (RTL) model of a three-stage synchronous pipeline in the context of Electronic Design Automation (EDA) using a Hardware Description Language (HDL). The pipeline consists of three registers $s_1$, $s_2$, and $s_3$ clocked by a single global clock with rising-edge triggering. All registers are initialized to zero at cycle $t=0$, so $s_1[0]=0$, $s_2[0]=0$, and $s_3[0]=0$. The pipeline processes a scalar input stream $x[t]$ sampled at each clock cycle, where the input is defined by the discrete-time function $x[t]=4t-1$ for all integer cycles $t \\geq 1$. The pipeline's per-stage transformations are an increment by $k=2$ at stage $2$ and a multiplication by $m=3$ at stage $3$.\n\nYou will analyze two HDL assignment semantics at the RTL abstraction level:\n\n1. Blocking semantics: Within a single synchronous update block, assignments execute in program order and update the target variables immediately. Model this by the same-cycle ordered updates\n$\n\\begin{aligned}\ns_1[t] = x[t],\\\\\ns_2[t] = s_1[t] + k,\\\\\ns_3[t] = m \\cdot s_2[t].\n\\end{aligned}\n$\nDefine the observable pipeline output as $y_{\\mathrm{B}}[t] = s_3[t]$ under blocking semantics.\n\n2. Non-blocking semantics: Within a single synchronous update block, all assignments schedule updates to occur concurrently at the end of the clock tick, so right-hand sides read values from the previous cycle. Model this by the concurrent updates\n$\n\\begin{aligned}\ns_1[t] = x[t],\\\\\ns_2[t] = s_1[t-1] + k,\\\\\ns_3[t] = m \\cdot s_2[t-1].\n\\end{aligned}\n$\nDefine the observable pipeline output as $y_{\\mathrm{NB}}[t] = s_3[t]$ under non-blocking semantics.\n\nStarting from these definitions and the initialization at $t=0$, compute the cycle-by-cycle outputs $y_{\\mathrm{B}}[t]$ and $y_{\\mathrm{NB}}[t]$ for $t=1,2,\\dots,10$. Then compute the scalar quantity\n$\nD=\\sum_{t=1}^{10}\\left(y_{\\mathrm{B}}[t]-y_{\\mathrm{NB}}[t]\\right).\n$\nExpress the final numerical value of $D$ with no units. No rounding is required.",
            "solution": "...",
            "answer": "$$ \\boxed{228} $$"
        },
        {
            "introduction": "Building upon the semantics of individual assignments, we now zoom out to understand how an HDL simulator orchestrates an entire design. This practice demystifies the event-driven simulation engine by having you manually trace its core components: the event queue, process scheduling, and delta cycles. By stepping through the execution of interacting processes within a single timestamp, you will see how simulators deterministically resolve chains of zero-delay events to reach a stable state, a concept fundamental to understanding complex feedback loops and concurrent behavior in digital systems .",
            "id": "4294418",
            "problem": "In an event-driven simulation framework for a simple Hardware Description Language (HDL) in the domain of Electronic Design Automation (EDA), consider a discrete-time, delta-cycle simulation semantics defined as follows. Simulation time is modeled as $t \\in \\mathbb{R}_{\\ge 0}$ with an event wheel indexed by integer nanoseconds. Within a fixed timestamp $t$, there is an ordered sequence of delta cycles $\\delta \\in \\mathbb{N}$ that proceed until quiescence. The simulator maintains:\n- An active-process queue $\\mathcal{A}_{t,\\delta}$ for processes to be executed during delta cycle $\\delta$ at time $t$.\n- A zero-delay update multiset $\\mathcal{U}_{t,\\delta}$ that contains pending signal updates to be committed at the end of delta cycle $\\delta$ at time $t$.\n- A time-wheel $\\mathcal{T}[t']$ for $t'  t$ containing nonzero-delay transactions to be committed at $\\delta = 0$ of time $t'$.\n\nExecution semantics are:\n- At a given time $t$, delta cycle $\\delta = 0$ begins by taking all transactions in $\\mathcal{T}[t]$ (if any) as the initial zero-delay update set $\\mathcal{U}_{t,0}$. No processes fire before the first commit at $\\delta = 0$.\n- At the end of any delta cycle $\\delta$ at fixed time $t$, all updates in $\\mathcal{U}_{t,\\delta}$ are committed, generating signal events. Any process whose sensitivity list includes a signal that had an event is enqueued into $\\mathcal{A}_{t,\\delta+1}$. Simultaneously, any nonzero-delay assignments encountered during process execution are appended to the appropriate $\\mathcal{T}[t']$ for their target times $t'  t$.\n- Within a delta cycle, all processes in $\\mathcal{A}_{t,\\delta}$ are executed to completion in a deterministic order by increasing process identifier (i.e., $P_1$ before $P_2$). Zero-delay assignments performed by a process during $\\delta$ add entries to $\\mathcal{U}_{t,\\delta}$ to be committed at the end of that same $\\delta$.\n- If after committing $\\mathcal{U}_{t,\\delta}$ there are no newly enqueued processes, the time $t$ is quiescent and simulation advances to the smallest $t'  t$ such that $\\mathcal{T}[t']$ is nonempty.\n\nConsider the following small HDL with two concurrent processes and one explicit stimulus, all operating over boolean signals $x$ and $y$ with initial values $x = 0$ and $y = 0$:\n- Process $P_1$: sensitivity list $\\{x\\}$. On every event of $x$ at time $t$, execute a zero-delay assignment $y \\leftarrow \\lnot y$ (that is, schedule an update to $y$ with no inertial delay, to be committed at the end of the current delta cycle).\n- Process $P_2$: sensitivity list $\\{y\\}$. On every event of $y$ at time $t$, execute a transport-delay assignment $x \\leftarrow y$ with a nonzero delay of $2$ nanoseconds (that is, schedule an update to $x$ into $\\mathcal{T}[t+2\\,\\mathrm{ns}]}$ using the value of $y$ observed when $P_2$ is executed).\n- External stimulus $S$: schedules two zero-delay updates to $x$, namely $x \\leftarrow 1$ at $t = 0\\,\\mathrm{ns}$ and $x \\leftarrow 0$ at $t = 1\\,\\mathrm{ns}$. Each such scheduled update enters $\\mathcal{U}_{t,0}$ at the corresponding time $t$.\n\nAssume that no other processes or stimuli exist, and that the only sensitivity-induced firings are those described above. Simulate the system from $t = 0\\,\\mathrm{ns}$ through $t = 3\\,\\mathrm{ns}$ inclusive, applying the delta-cycle semantics. For each timestamp $t \\in \\{0\\,\\mathrm{ns}, 1\\,\\mathrm{ns}, 2\\,\\mathrm{ns}, 3\\,\\mathrm{ns}\\}$ and each delta cycle $\\delta$ that actually occurs, list the contents of $\\mathcal{U}_{t,\\delta}$, the processes in $\\mathcal{A}_{t,\\delta}$ that fire, and any entries added to $\\mathcal{T}[t']$. Then compute the cumulative number $N$ of delta cycles executed across these four timestamps (counting each $\\delta$ that begins at a given $t$ until quiescence at that $t$). Provide your final answer as a single integer for $N$ with no units.",
            "solution": "The problem statement is valid. It is scientifically grounded in the principles of digital logic simulation, well-posed with a deterministic set of rules, and objectively stated. We can proceed with a step-by-step simulation of the system.\n\nThe initial state of the system at time $t  0$ is $x=0$ and $y=0$. The external stimulus $S$ populates the time-wheel $\\mathcal{T}$ with two initial transactions:\n- $\\mathcal{T}[0] = \\{(x, 1)\\}$\n- $\\mathcal{T}[1] = \\{(x, 0)\\}$\nAll other time slots in $\\mathcal{T}$ are initially empty. The simulation begins by advancing to the first non-empty time slot, which is $t=0\\,\\mathrm{ns}$.\n\n**Simulation Trace for $t=0\\,\\mathrm{ns}$**\nThe signal values at the beginning of this time step are $x=0, y=0$.\n\n- **Delta Cycle $\\delta=0$**:\n    - The simulation starts at $t=0, \\delta=0$. The transaction from $\\mathcal{T}[0]$ is moved to the zero-delay update multiset: $\\mathcal{U}_{0,0} = \\{(x, 1)\\}$.\n    - The active-process queue is empty by rule: $\\mathcal{A}_{0,0} = \\emptyset$. No processes are executed.\n    - At the end of the delta cycle, the update in $\\mathcal{U}_{0,0}$ is committed. The signal $x$ changes from $0$ to $1$. This constitutes an event on $x$.\n    - The new signal values are $x=1, y=0$.\n    - Process $P_1$ is sensitive to events on $x$, so it is enqueued for the next delta cycle: $\\mathcal{A}_{0,1} = \\{P_1\\}$.\n    - The system is not quiescent.\n\n- **Delta Cycle $\\delta=1$**:\n    - The active-process queue is $\\mathcal{A}_{0,1} = \\{P_1\\}$. The update multiset is initially empty: $\\mathcal{U}_{0,1} = \\emptyset$.\n    - Process $P_1$ is executed. It performs a zero-delay assignment $y \\leftarrow \\lnot y$. The current value of $y$ is $0$, so the assignment is $y \\leftarrow 1$. This adds an entry to the current update multiset: $\\mathcal{U}_{0,1} = \\{(y, 1)\\}$.\n    - At the end of the delta cycle, the update in $\\mathcal{U}_{0,1}$ is committed. The signal $y$ changes from $0$ to $1$. This constitutes an event on $y$.\n    - The new signal values are $x=1, y=1$.\n    - Process $P_2$ is sensitive to events on $y$, so it is enqueued for the next delta cycle: $\\mathcal{A}_{0,2} = \\{P_2\\}$.\n    - The system is not quiescent.\n\n- **Delta Cycle $\\delta=2$**:\n    - The active-process queue is $\\mathcal{A}_{0,2} = \\{P_2\\}$. The update multiset is initially empty: $\\mathcal{U}_{0,2} = \\emptyset$.\n    - Process $P_2$ is executed. It schedules a transport-delay assignment $x \\leftarrow y$ with a delay of $2\\,\\mathrm{ns}$. The value of $y$ at the time of execution is $1$. The transaction is scheduled for time $t+2 = 0+2 = 2\\,\\mathrm{ns}$.\n    - An entry is added to the time-wheel: $\\mathcal{T}[2] \\leftarrow \\mathcal{T}[2] \\cup \\{(x, 1)\\}$.\n    - No zero-delay updates are generated, so $\\mathcal{U}_{0,2}$ remains empty.\n    - At the end of the delta cycle, $\\mathcal{U}_{0,2}$ is committed. Since it is empty, no signals change and no events are generated.\n    - The active-process queue for the next delta cycle is empty: $\\mathcal{A}_{0,3} = \\emptyset$.\n    - The system is quiescent at time $t=0$.\n\nA total of $3$ delta cycles ($\\delta=0, 1, 2$) occurred at $t=0\\,\\mathrm{ns}$.\n\n**Simulation Trace for $t=1\\,\\mathrm{ns}$**\nThe simulator advances to the next non-empty time slot, $t=1\\,\\mathrm{ns}$. The signal values at the beginning of this time step are $x=1, y=1$.\n\n- **Delta Cycle $\\delta=0$**:\n    - $\\mathcal{U}_{1,0} = \\{(x, 0)\\}$ is formed from $\\mathcal{T}[1]$. $\\mathcal{A}_{1,0} = \\emptyset$.\n    - The update is committed. Signal $x$ changes from $1$ to $0$, generating an event.\n    - New signal values: $x=0, y=1$.\n    - $P_1$ is enqueued: $\\mathcal{A}_{1,1} = \\{P_1\\}$. Not quiescent.\n\n- **Delta Cycle $\\delta=1$**:\n    - $\\mathcal{A}_{1,1} = \\{P_1\\}$.\n    - $P_1$ executes $y \\leftarrow \\lnot y$. Since $y=1$, the assignment is $y \\leftarrow 0$. This update is added to $\\mathcal{U}_{1,1} = \\{(y, 0)\\}$.\n    - The update is committed. Signal $y$ changes from $1$ to $0$, generating an event.\n    - New signal values: $x=0, y=0$.\n    - $P_2$ is enqueued: $\\mathcal{A}_{1,2} = \\{P_2\\}$. Not quiescent.\n\n- **Delta Cycle $\\delta=2$**:\n    - $\\mathcal{A}_{1,2} = \\{P_2\\}$.\n    - $P_2$ executes $x \\leftarrow y$ with a $2\\,\\mathrm{ns}$ delay. The value of $y$ is $0$. The transaction is for $t+2 = 1+2 = 3\\,\\mathrm{ns}$.\n    - An entry is added to the time-wheel: $\\mathcal{T}[3] \\leftarrow \\mathcal{T}[3] \\cup \\{(x, 0)\\}$.\n    - $\\mathcal{U}_{1,2}$ is empty. No events are generated upon commit.\n    - $\\mathcal{A}_{1,3} = \\emptyset$. The system is quiescent at $t=1$.\n\nA total of $3$ delta cycles ($\\delta=0, 1, 2$) occurred at $t=1\\,\\mathrm{ns}$.\n\n**Simulation Trace for $t=2\\,\\mathrm{ns}$**\nThe simulator advances to $t=2\\,\\mathrm{ns}$. The signal values are $x=0, y=0$.\n\n- **Delta Cycle $\\delta=0$**:\n    - $\\mathcal{U}_{2,0} = \\{(x, 1)\\}$ is formed from $\\mathcal{T}[2]$. $\\mathcal{A}_{2,0} = \\emptyset$.\n    - The update is committed. Signal $x$ changes from $0$ to $1$, generating an event.\n    - New signal values: $x=1, y=0$.\n    - $P_1$ is enqueued: $\\mathcal{A}_{2,1} = \\{P_1\\}$. Not quiescent.\n\n- **Delta Cycle $\\delta=1$**:\n    - $\\mathcal{A}_{2,1} = \\{P_1\\}$.\n    - $P_1$ executes $y \\leftarrow \\lnot y$. Since $y=0$, the assignment is $y \\leftarrow 1$. This update is added to $\\mathcal{U}_{2,1} = \\{(y, 1)\\}$.\n    - The update is committed. Signal $y$ changes from $0$ to $1$, generating an event.\n    - New signal values: $x=1, y=1$.\n    - $P_2$ is enqueued: $\\mathcal{A}_{2,2} = \\{P_2\\}$. Not quiescent.\n\n- **Delta Cycle $\\delta=2$**:\n    - $\\mathcal{A}_{2,2} = \\{P_2\\}$.\n    - $P_2$ executes $x \\leftarrow y$ with a $2\\,\\mathrm{ns}$ delay. The value of $y$ is $1$. The transaction is for $t+2 = 2+2 = 4\\,\\mathrm{ns}$.\n    - An entry is added to the time-wheel: $\\mathcal{T}[4] \\leftarrow \\mathcal{T}[4] \\cup \\{(x, 1)\\}$.\n    - $\\mathcal{U}_{2,2}$ is empty. No events are generated.\n    - $\\mathcal{A}_{2,3} = \\emptyset$. The system is quiescent at $t=2$.\n\nA total of $3$ delta cycles ($\\delta=0, 1, 2$) occurred at $t=2\\,\\mathrm{ns}$.\n\n**Simulation Trace for $t=3\\,\\mathrm{ns}$**\nThe simulator advances to $t=3\\,\\mathrm{ns}$. The signal values are $x=1, y=1$.\n\n- **Delta Cycle $\\delta=0$**:\n    - $\\mathcal{U}_{3,0} = \\{(x, 0)\\}$ is formed from $\\mathcal{T}[3]$. $\\mathcal{A}_{3,0} = \\emptyset$.\n    - The update is committed. Signal $x$ changes from $1$ to $0$, generating an event.\n    - New signal values: $x=0, y=1$.\n    - $P_1$ is enqueued: $\\mathcal{A}_{3,1} = \\{P_1\\}$. Not quiescent.\n\n- **Delta Cycle $\\delta=1$**:\n    - $\\mathcal{A}_{3,1} = \\{P_1\\}$.\n    - $P_1$ executes $y \\leftarrow \\lnot y$. Since $y=1$, the assignment is $y \\leftarrow 0$. This update is added to $\\mathcal{U}_{3,1} = \\{(y, 0)\\}$.\n    - The update is committed. Signal $y$ changes from $1$ to $0$, generating an event.\n    - New signal values: $x=0, y=0$.\n    - $P_2$ is enqueued: $\\mathcal{A}_{3,2} = \\{P_2\\}$. Not quiescent.\n\n- **Delta Cycle $\\delta=2$**:\n    - $\\mathcal{A}_{3,2} = \\{P_2\\}$.\n    - $P_2$ executes $x \\leftarrow y$ with a $2\\,\\mathrm{ns}$ delay. The value of $y$ is $0$. The transaction is for $t+2 = 3+2 = 5\\,\\mathrm{ns}$.\n    - An entry is added to the time-wheel: $\\mathcal{T}[5] \\leftarrow \\mathcal{T}[5] \\cup \\{(x, 0)\\}$.\n    - $\\mathcal{U}_{3,2}$ is empty. No events are generated.\n    - $\\mathcal{A}_{3,3} = \\emptyset$. The system is quiescent at $t=3$.\n\nA total of $3$ delta cycles ($\\delta=0, 1, 2$) occurred at $t=3\\,\\mathrm{ns}$.\n\n**Cumulative Count**\nThe cumulative number of delta cycles, $N$, is the sum of the counts for each timestamp.\n$N = (\\text{cycles at } t=0) + (\\text{cycles at } t=1) + (\\text{cycles at } t=2) + (\\text{cycles at } t=3)$\n$N = 3 + 3 + 3 + 3 = 12$.",
            "answer": "$$\\boxed{12}$$"
        },
        {
            "introduction": "Understanding simulation semantics is not just an academic exercise; it is a critical skill for debugging real-world hardware designs. This final practice applies your knowledge of process scheduling to diagnose a classic HDL pitfall: race conditions caused by incomplete sensitivity lists in combinational logic. You will simulate a scenario where the final output depends on the non-deterministic evaluation order of processes, and then see how modern HDL constructs like SystemVerilog's `always_comb` eliminate this ambiguity by guaranteeing re-evaluation, thus ensuring that the simulation correctly models the intended logic regardless of the simulator's internal scheduling .",
            "id": "4294440",
            "problem": "Consider a simplified, discrete-event simulation of two interacting Hardware Description Language (HDL) always blocks within an Electronic Design Automation (EDA) flow. The goal is to demonstrate how incomplete sensitivity lists at a Register-Transfer Level (RTL) abstraction can produce a race condition that depends on the evaluation order in a delta cycle, and how adopting complete sensitivity (as enforced by SystemVerilog's always-comb) eliminates the race by ensuring re-evaluation on all read signal changes.\n\nFundamental base and core definitions:\n- A Hardware Description Language (HDL) such as Verilog or SystemVerilog is simulated by an event-driven kernel that proceeds in discrete time steps, each decomposed into delta cycles. Within a delta cycle, processes (always blocks) whose sensitivity sets intersect with the set of signals that changed in the current step are eligible to run. Processes that execute use blocking assignment semantics for combinational blocks and produce updates that may trigger further processes in subsequent delta cycles until a fixed point is reached.\n- Let the signal set be $S = \\{a, b, c, y\\}$, where $a$ and $c$ are primary inputs driven exogenously at time step boundaries, and $y$ and $b$ are internal combinational signals driven by the always blocks.\n- Define two processes:\n  1. Process $A$: compute $y := a \\land b$.\n  2. Process $B$: compute $b := c$.\n- In the incomplete sensitivity configuration, the sensitivity sets are $\\mathcal{S}_A^{\\text{incomplete}} = \\{a\\}$ and $\\mathcal{S}_B = \\{c\\}$. In the complete sensitivity configuration, adopt SystemVerilog always-comb semantics for process $A$, so $\\mathcal{S}_A^{\\text{complete}} = \\{a, b\\}$, while process $B$ remains with $\\mathcal{S}_B = \\{c\\}$ because it reads only $c$.\n- Delta-cycle semantics: At the start of a time step, exogenous changes set new values for $a$ and $c$. Let $E_0 \\subseteq \\{a, c\\}$ denote the set of inputs that actually changed values versus their previous state. Within a delta cycle, choose an evaluation order $\\sigma$ over $\\{A, B\\}$ and, for each process in that order, run it if its sensitivity set intersects the current changed set $E_k$. A process update immediately changes its driven signal (blocking assignment), creating a new changed set $E_{k+1}$. Repeat until a delta cycle completes with no changes, yielding a stable fixed point for that time step.\n\nTask:\n- Implement a program that simulates one time step given:\n  - An initial state $(a_0, b_0, c_0)$, with $y_0$ defined as $y_0 := a_0 \\land b_0$ to ensure internal consistency at the start of the step.\n  - A new input state $(a_1, c_1)$ applied at the beginning of the time step.\n- Compute the final stable values under three configurations:\n  1. Incomplete sensitivity, evaluation order $\\sigma_1 = [A, B]$.\n  2. Incomplete sensitivity, evaluation order $\\sigma_2 = [B, A]$.\n  3. Complete sensitivity (always-comb for $A$), evaluation order can be either $\\sigma_1$ or $\\sigma_2$; by design it must converge to the same fixed point for both, so compute once with $\\sigma_1$.\n- For each test case, report whether a race is observed under incomplete sensitivity, defined as whether $y$ differs between $\\sigma_1$ and $\\sigma_2$. Express the race indicator as an integer $0$ or $1$, where $1$ means a race is present and $0$ means no race.\n\nSimulation abstraction-level assumptions:\n- Blocking assignment semantics for combinational processes apply: when a process runs, its driven signal updates immediately and is visible to subsequent processes in the same delta cycle.\n- Each always block is purely combinational at the RTL abstraction, and the complete sensitivity configuration for $A$ reflects always-comb semantics that include all signals read in the right-hand side ($a$ and $b$).\n- There is no clock, no nonblocking assignments, and no propagation delays; the model is purely event-driven combinational evaluation until a fixed point per time step.\n\nTest suite:\nProvide the following three test cases. For each, the program must initialize $(a_0, b_0, c_0)$, compute $y_0 := a_0 \\land b_0$, then apply $(a_1, c_1)$ at the start of the single time step.\n\n- Case $1$ (simultaneous changes causing a race with incomplete sensitivity):\n  - Initial: $(a_0, b_0, c_0) = (0, 0, 0)$.\n  - Applied: $(a_1, c_1) = (1, 1)$.\n- Case $2$ (boundary case: only $a$ changes, no race):\n  - Initial: $(a_0, b_0, c_0) = (0, 1, 0)$.\n  - Applied: $(a_1, c_1) = (1, 0)$.\n- Case $3$ (edge case: only $c$ changes, demonstrating the benefit of complete sensitivity):\n  - Initial: $(a_0, b_0, c_0) = (1, 0, 0)$.\n  - Applied: $(a_1, c_1) = (1, 1)$.\n\nRequired final output format:\n- For each test case, output a list of four integers in the form $[\\text{race}, y_{\\text{incomplete}, \\sigma_1}, y_{\\text{incomplete}, \\sigma_2}, y_{\\text{complete}}]$, where each integer is either $0$ or $1$.\n- Aggregate the results of all test cases into a single line printed as a comma-separated list enclosed in square brackets. For example, the final output must look like $[[r_1, y_{11}, y_{12}, y_{1c}], [r_2, y_{21}, y_{22}, y_{2c}], [r_3, y_{31}, y_{32}, y_{3c}]]$ with literal brackets and commas.\n\nAll numbers must be integers ($0$ or $1$). Angles and physical units are not involved in this problem. The program must produce the single line of output exactly as specified and must not require any user input or external files.",
            "solution": "The problem statement is scientifically sound, well-posed, and provides a complete and unambiguous definition of a discrete-event simulation model. It accurately describes a simplified but correct scenario from digital logic simulation, where incomplete sensitivity lists in an HDL can lead to race conditions dependent on the simulator's process evaluation order. The concepts of delta cycles, blocking assignments, and sensitivity lists are fundamental to EDA tools. The problem is therefore valid, and a solution can be constructed.\n\nThe solution involves implementing a deterministic, discrete-event simulator that adheres to the specified rules. The state of the system is the set of values for the signals $\\{a, b, c, y\\}$. A simulation step begins with a set of changed signals, $E_0$, caused by new primary inputs. The simulation proceeds in delta cycles. In each delta cycle, the simulator iterates through the processes $\\{A, B\\}$ in a given evaluation order $\\sigma$. A process is executed if its sensitivity list intersects with the current set of changed signals, $E_k$. An executed process may update its output signal, and if the signal's value changes, the signal is added to the set of changes for the next delta cycle, $E_{k+1}$. The simulation for the time step reaches a fixed point and terminates when a delta cycle completes with an empty set of changes ($E_{k+1} = \\emptyset$).\n\nThe two processes are defined as:\n- Process $A$: $y := a \\land b$\n- Process $B$: $b := c$\n\nThe sensitivity lists vary by configuration:\n- Incomplete: $\\mathcal{S}_A^{\\text{incomplete}} = \\{a\\}$, $\\mathcal{S}_B = \\{c\\}$\n- Complete: $\\mathcal{S}_A^{\\text{complete}} = \\{a, b\\}$, $\\mathcal{S}_B = \\{c\\}$\n\nWe will trace the simulation for each test case.\n\n### Case 1\n- Initial state: $(a_0, b_0, c_0) = (0, 0, 0)$. This implies an initial value for $y_0$ of $y_0 := a_0 \\land b_0 = 0 \\land 0 = 0$.\n- Applied inputs: $(a_1, c_1) = (1, 1)$.\n- State at start of time step: $(a, b, c, y) = (1, 0, 1, 0)$.\n- Initial changed set: $E_0 = \\{a, c\\}$.\n\n**1. Incomplete Sensitivity, Order $\\sigma_1 = [A, B]$**\n- **Delta 1** ($E=\\{a,c\\}$):\n  - Process $A$ is sensitive to $a \\in E$. It executes: $y := a \\land b = 1 \\land 0 = 0$. The value of $y$ does not change.\n  - Process $B$ is sensitive to $c \\in E$. It executes: $b := c = 1$. The value of $b$ changes from $0$ to $1$.\n  - The changed set for the next delta cycle is $E_1 = \\{b\\}$. Current state: $(a,b,c,y)=(1,1,1,0)$.\n- **Delta 2** ($E=\\{b\\}$):\n  - Process $A$ is not sensitive, as its list $\\mathcal{S}_A^{\\text{incomplete}} = \\{a\\}$ does not contain $b$. It does not execute, despite its input $b$ having changed.\n  - Process $B$ is not sensitive to $b$.\n  - The changed set for the next delta cycle is $E_2 = \\emptyset$.\n- Simulation stabilizes. The final value is $y_{\\text{incomplete}, \\sigma_1} = 0$.\n\n**2. Incomplete Sensitivity, Order $\\sigma_2 = [B, A]$**\n- **Delta 1** ($E=\\{a,c\\}$):\n  - Process $B$ is sensitive to $c \\in E$. It executes: $b := c = 1$. The value of $b$ changes from $0$ to $1$. Current state becomes $(a,b,c,y)=(1,1,1,0)$.\n  - Process $A$ is sensitive to $a \\in E$. It executes using the *updated* state: $y := a \\land b = 1 \\land 1 = 1$. The value of $y$ changes from $0$ to $1$.\n  - The changed set for the next delta cycle is $E_1 = \\{b, y\\}$.\n- **Delta 2** ($E=\\{b,y\\}$):\n  - No process is sensitive to $b$ or $y$.\n  - The changed set for the next delta cycle is $E_2 = \\emptyset$.\n- Simulation stabilizes. The final value is $y_{\\text{incomplete}, \\sigma_2} = 1$.\n\n**3. Complete Sensitivity, Order $\\sigma_1 = [A, B]$**\n- **Delta 1** ($E=\\{a,c\\}$):\n  - Process $A$ (sensitivity $\\mathcal{S}_A^{\\text{complete}} = \\{a, b\\}$) is sensitive to $a \\in E$. It executes: $y := a \\land b = 1 \\land 0 = 0$. No change to $y$.\n  - Process $B$ is sensitive to $c \\in E$. It executes: $b := c = 1$. The value of $b$ changes from $0$ to $1$.\n  - Changed set for next delta cycle is $E_1 = \\{b\\}$. Current state: $(a,b,c,y)=(1,1,1,0)$.\n- **Delta 2** ($E=\\{b\\}$):\n  - Process $A$ is now sensitive to $b \\in E$. It re-executes: $y := a \\land b = 1 \\land 1 = 1$. The value of $y$ changes from $0$ to $1$.\n  - Process $B$ is not sensitive to $b$.\n  - Changed set for next delta cycle is $E_2 = \\{y\\}$.\n- **Delta 3** ($E=\\{y\\}$): No process is sensitive to $y$. $E_3 = \\emptyset$.\n- Simulation stabilizes. The final value is $y_{\\text{complete}} = 1$.\n\n**Case 1 Result**: A race is observed ($0 \\neq 1$), so race=$1$. The output is $[1, 0, 1, 1]$.\n\n### Case 2\n- Initial state: $(a_0, b_0, c_0) = (0, 1, 0)$. Implies $y_0 = 0 \\land 1 = 0$.\n- Applied inputs: $(a_1, c_1) = (1, 0)$.\n- State at start of time step: $(a, b, c, y) = (1, 1, 0, 0)$.\n- Initial changed set: $E_0 = \\{a\\}$ (since $c$ did not change).\n\n**All Configurations**:\n- **Delta 1** ($E=\\{a\\}$):\n  - Process $A$ is sensitive to $a$. It executes: $y := a \\land b = 1 \\land 1 = 1$. The value of $y$ changes from $0$ to $1$.\n  - Process $B$ is not sensitive to $a$.\n  - The evaluation order does not matter as only Process $A$ is triggered initially. The changed set for the next delta cycle is $E_1 = \\{y\\}$.\n- **Delta 2** ($E=\\{y\\}$): No process is sensitive to $y$. $E_2 = \\emptyset$.\n- Simulation stabilizes. The final value is $y=1$ for all three configurations.\n\n**Case 2 Result**: No race is observed ($1 = 1$), so race=$0$. The output is $[0, 1, 1, 1]$.\n\n### Case 3\n- Initial state: $(a_0, b_0, c_0) = (1, 0, 0)$. Implies $y_0 = 1 \\land 0 = 0$.\n- Applied inputs: $(a_1, c_1) = (1, 1)$.\n- State at start of time step: $(a, b, c, y) = (1, 0, 1, 0)$.\n- Initial changed set: $E_0 = \\{c\\}$ (since $a$ did not change).\n\n**1.  2. Incomplete Sensitivity, Orders $\\sigma_1 = [A, B]$ and $\\sigma_2 = [B, A]$**\n- **Delta 1** ($E=\\{c\\}$):\n  - Process $A$ (sensitivity $\\mathcal{S}_A^{\\text{incomplete}} = \\{a\\}$) is not sensitive to $c$.\n  - Process $B$ is sensitive to $c$. It executes: $b := c = 1$. The value of $b$ changes from $0$ to $1$.\n  - The evaluation order does not matter. The changed set for the next delta cycle is $E_1 = \\{b\\}$. Current state: $(a,b,c,y)=(1,1,1,0)$.\n- **Delta 2** ($E=\\{b\\}$):\n  - Process $A$ is not sensitive to $b$. It does not re-evaluate.\n  - Process $B$ is not sensitive to $b$.\n  - The changed set for the next delta cycle is $E_2 = \\emptyset$.\n- Simulation stabilizes. The final value is $y_{\\text{incomplete}, \\sigma_1} = y_{\\text{incomplete}, \\sigma_2} = 0$.\n\n**3. Complete Sensitivity, Order $\\sigma_1 = [A, B]$**\n- **Delta 1** ($E=\\{c\\}$):\n  - Process $A$ (sensitivity $\\mathcal{S}_A^{\\text{complete}} = \\{a, b\\}$) is not sensitive to $c$.\n  - Process $B$ is sensitive to $c$. It executes: $b := c = 1$. The value of $b$ changes from $0$ to $1$.\n  - Changed set for next delta cycle is $E_1 = \\{b\\}$. Current state: $(a,b,c,y)=(1,1,1,0)$.\n- **Delta 2** ($E=\\{b\\}$):\n  - Process $A$ is now sensitive to $b$. It re-executes: $y := a \\land b = 1 \\land 1 = 1$. The value of $y$ changes from $0$ to $1$.\n  - Process $B$ is not sensitive to $b$.\n  - Changed set for next delta cycle is $E_2 = \\{y\\}$.\n- **Delta 3** ($E=\\{y\\}$): No process is sensitive to $y$. $E_3 = \\emptyset$.\n- Simulation stabilizes. Final value is $y_{\\text complete} = 1$.\n\n**Case 3 Result**: No race is observed in the incomplete case ($0 = 0$), so race=$0$. The complete sensitivity model produces the correct combinational logic result, highlighting the inadequacy of the incomplete model. The output is $[0, 0, 0, 1]$.\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np # Note: This problem does not require numpy, but it is listed in the environment.\n\ndef _simulate_hdl_step(initial_state, applied_inputs, sens_A, sens_B, eval_order):\n    \"\"\"\n    Simulates a single time step of the HDL model.\n    \"\"\"\n    # Initialize signal values from the provided tuple.\n    # The dictionary 'state' will hold the current values of all signals.\n    a0, b0, c0 = initial_state\n    state = {\n        'a': a0,\n        'b': b0,\n        'c': c0,\n        'y': a0  b0,\n    }\n\n    # Apply new inputs and determine the initial set of changed signals (events).\n    a1, c1 = applied_inputs\n    events = set()\n    if a1 != state['a']:\n        state['a'] = a1\n        events.add('a')\n    if c1 != state['c']:\n        state['c'] = c1\n        events.add('c')\n\n    # Main delta-cycle loop. Continues as long as there are new events.\n    while events:\n        # Prepare to collect events for the next delta cycle.\n        next_events = set()\n\n        # Iterate through processes A and B in the specified evaluation order.\n        for process_name in eval_order:\n            if process_name == 'A':\n                # Check if Process A is sensitive to any current event.\n                if not events.isdisjoint(sens_A):\n                    # Execute Process A: y := a  b\n                    y_new = state['a']  state['b']\n                    if y_new != state['y']:\n                        state['y'] = y_new\n                        next_events.add('y')\n            elif process_name == 'B':\n                # Check if Process B is sensitive to any current event.\n                if not events.isdisjoint(sens_B):\n                    # Execute Process B: b := c\n                    b_new = state['c']\n                    if b_new != state['b']:\n                        state['b'] = b_new\n                        next_events.add('b')\n        \n        # The events for the next delta cycle are those collected in this one.\n        events = next_events\n\n    # Return the final, stable value of the output signal 'y'.\n    return state['y']\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Initial state (a0, b0, c0), Applied inputs (a1, c1))\n        ((0, 0, 0), (1, 1)),  # Case 1\n        ((0, 1, 0), (1, 0)),  # Case 2\n        ((1, 0, 0), (1, 1)),  # Case 3\n    ]\n\n    # Define sensitivity sets for the two configurations.\n    sens_A_incomplete = {'a'}\n    sens_A_complete = {'a', 'b'}\n    sens_B = {'c'}\n\n    # Define the two possible evaluation orders.\n    order_AB = ['A', 'B']\n    order_BA = ['B', 'A']\n\n    all_results = []\n    \n    for initial, applied in test_cases:\n        # 1. Incomplete sensitivity, order [A, B]\n        y_incomplete_ab = _simulate_hdl_step(initial, applied, sens_A_incomplete, sens_B, order_AB)\n\n        # 2. Incomplete sensitivity, order [B, A]\n        y_incomplete_ba = _simulate_hdl_step(initial, applied, sens_A_incomplete, sens_B, order_BA)\n\n        # 3. Complete sensitivity (order does not matter, use [A, B] as per spec)\n        y_complete = _simulate_hdl_step(initial, applied, sens_A_complete, sens_B, order_AB)\n\n        # Determine if a race condition was observed (y values differ)\n        race_observed = 1 if y_incomplete_ab != y_incomplete_ba else 0\n\n        # Collect results for this test case\n        case_result = [race_observed, y_incomplete_ab, y_incomplete_ba, y_complete]\n        all_results.append(case_result)\n\n    # Format the final output string to be exactly as required, e.g., [[1,0,1,1],[0,1,1,1],...].\n    # The default string representation of a list of lists in Python includes spaces,\n    # so we remove them to match the specification.\n    final_output_string = str(all_results).replace(\" \", \"\")\n\n    print(final_output_string)\n\nsolve()\n```",
            "answer": "[[1,0,1,1],[0,1,1,1],[0,0,0,1]]"
        }
    ]
}