{
    "hands_on_practices": [
        {
            "introduction": "在深入研究晶体管级的复杂功耗之前，我们首先通过一个基本练习来巩固基础。这个实践探讨了电荷共享现象中的能量耗散，这是动态功耗的一个基本来源。通过从第一性原理出发进行推导，您将揭示当电荷在不同电位之间重新分配时能量损失的必然性，并理解为何这个损失与电荷转移的具体路径无关()。",
            "id": "4267507",
            "problem": "在一个互补金属氧化物半导体（CMOS）数字集成电路中，两个隔离的节点 $\\mathcal{N}_1$ 和 $\\mathcal{N}_2$ 分别被建模为理想的集总电容 $C_1$ 和 $C_2$，它们相对于一个公共参考点的初始电压分别为 $V_1$ 和 $V_2$。在时间 $t=0$ 时，一个传输晶体管导通，并被建模为在 $\\mathcal{N}_1$ 和 $\\mathcal{N}_2$ 之间的一个阻值为 $R$ 的纯电阻连接。假设在此事件中没有其他电源，没有电感，并且唯一的导电路径是通过电阻 $R$。系统在 $t \\to \\infty$ 时弛豫至其最终平衡状态，之后晶体管关断，两个节点保持隔离。仅使用基本物理原理，包括电荷守恒、Kirchhoff 定律以及电容器储能的定义，推导出在整个暂态过程中电阻器消耗的总能量，并用 $C_1$、$C_2$、$V_1$ 和 $V_2$ 来表示。将最终能量以焦耳为单位，表示为一个单一的闭式解析表达式。不要假设 $V_1$ 和 $V_2$ 之间有任何特殊关系，并且不要引用未从所述原理推导出的结果。最终答案必须是一个单一的解析表达式。",
            "solution": "用户希望找到连接两个初始充电至不同电压的电容器的电阻器所耗散的总能量。\n\n### 步骤 1：提取已知条件\n- 两个理想集总电容，$C_1$ 和 $C_2$。\n- 时间 $t=0$ 时的初始电压：$v_1(0) = V_1$ 和 $v_2(0) = V_2$。\n- 一个阻值为 $R$ 的电阻器在 $t=0$ 时连接两个电容器。\n- 系统在其他方面是隔离的（没有其他电源或导电路径）。\n- 系统在 $t \\to \\infty$ 时弛豫至平衡状态。\n- 任务是使用电荷守恒、Kirchhoff 定律和电容器储能的定义，推导电阻器中耗散的总能量 $E_{dissipated}$。结果必须是用 $C_1$、$C_2$、$V_1$ 和 $V_2$ 表示的闭式表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题描述了一个经典的 RC 电路，这是电气工程和物理学中的一个基本课题。理想电容器和电阻器的模型是一种标准且有效的物理近似。所引用的原理（电荷守恒、Kirchhoff 定律、电容能量）是电磁学的基石定律。该问题在科学上是合理的。\n- **适定性**：问题定义清晰，包含了所有必要的初始条件和元件属性，足以确定系统的最终状态以及初始和最终状态之间的能量差。存在一个唯一的、稳定的平衡状态，因此可以计算出耗散总能量的唯一值。\n- **客观性**：问题以精确、技术性和无歧义的语言陈述，不含主观内容。\n- **缺陷检查表**：该问题没有违反任何指定的无效标准。它在科学上是合理的、可形式化的、完整的、物理上现实的（在理想元件模型内）、适定的、非平凡的和可验证的。\n\n### 步骤 3：结论与行动\n该问题是 **有效的**。将按要求从第一性原理推导解答。\n\n### 推导过程\n电阻器中耗散的总能量 $E_{dissipated}$ 可以通过应用能量守恒定律找到。孤立系统的总能量由储存在电容器中的静电能和在电阻器中耗散的热量组成。由于在 $t=0$ 之后没有能量供给系统，因此以热量形式耗散的能量必须等于从初始状态（$t=0$）到最终平衡状态（$t \\to \\infty$）电容器中储存的总静电能的减少量。\n\n设 $E_{initial}$ 为 $t=0$ 时储存在电容器中的总能量，而 $E_{final}$ 为 $t \\to \\infty$ 时储存的总能量。那么，在电阻器中耗散的能量是：\n$$E_{dissipated} = E_{initial} - E_{final}$$\n\n**1. 初始状态能量**\n一个电容为 $C$、两端电压为 $V$ 的电容器中储存的能量由 $E = \\frac{1}{2} C V^2$ 给出。\n在时间 $t=0$ 时，电容器 $C_1$ 上的电压为 $V_1$，电容器 $C_2$ 上的电压为 $V_2$。总的初始储存能量是每个电容器中能量的总和：\n$$E_{initial} = \\frac{1}{2} C_1 V_1^2 + \\frac{1}{2} C_2 V_2^2$$\n\n**2. 最终状态能量**\n在 $t=0$ 时开关闭合后，电荷通过电阻器 $R$ 在两个电容器之间流动。这个过程一直持续到系统达到一个新的静电平衡。当通过电阻器的电流 $i(t)$ 变为零时，系统达到平衡。根据欧姆定律 $i = (v_1 - v_2)/R$，只有当电阻器两端的电压差为零时，电流才为零。这意味着两个电容器上的最终电压相等。设这个最终平衡电压为 $V_f$。\n$$v_1(t \\to \\infty) = v_2(t \\to \\infty) = V_f$$\n由两个电容器和电阻器组成的系统是电隔离的。因此，在整个过程中总电荷必须守恒。\n初始总电荷 $Q_{initial}$ 是每个电容器上电荷的总和：\n$$Q_{initial} = C_1 V_1 + C_2 V_2$$\n平衡时的最终总电荷 $Q_{final}$ 是：\n$$Q_{final} = C_1 V_f + C_2 V_f = (C_1 + C_2) V_f$$\n根据电荷守恒原理，$Q_{initial} = Q_{final}$：\n$$C_1 V_1 + C_2 V_2 = (C_1 + C_2) V_f$$\n由此，我们解出最终平衡电压 $V_f$：\n$$V_f = \\frac{C_1 V_1 + C_2 V_2}{C_1 + C_2}$$\n储存在电容器中的总最终能量 $E_{final}$ 是：\n$$E_{final} = \\frac{1}{2} C_1 V_f^2 + \\frac{1}{2} C_2 V_f^2 = \\frac{1}{2} (C_1 + C_2) V_f^2$$\n代入 $V_f$ 的表达式：\n$$E_{final} = \\frac{1}{2} (C_1 + C_2) \\left( \\frac{C_1 V_1 + C_2 V_2}{C_1 + C_2} \\right)^2 = \\frac{1}{2} \\frac{(C_1 V_1 + C_2 V_2)^2}{C_1 + C_2}$$\n\n**3. 总耗散能量**\n现在我们可以通过从初始能量中减去最终能量来计算电阻器中耗散的总能量：\n$$E_{dissipated} = E_{initial} - E_{final} = \\left( \\frac{1}{2} C_1 V_1^2 + \\frac{1}{2} C_2 V_2^2 \\right) - \\frac{1}{2} \\frac{(C_1 V_1 + C_2 V_2)^2}{C_1 + C_2}$$\n提出因子 $\\frac{1}{2}$ 并将各项通分，分母为 $(C_1 + C_2)$：\n$$E_{dissipated} = \\frac{1}{2} \\left[ \\frac{(C_1 V_1^2 + C_2 V_2^2)(C_1 + C_2) - (C_1 V_1 + C_2 V_2)^2}{C_1 + C_2} \\right]$$\n展开分子：\n第一项：$(C_1 V_1^2 + C_2 V_2^2)(C_1 + C_2) = C_1^2 V_1^2 + C_1 C_2 V_1^2 + C_1 C_2 V_2^2 + C_2^2 V_2^2$\n第二项：$(C_1 V_1 + C_2 V_2)^2 = C_1^2 V_1^2 + 2 C_1 C_2 V_1 V_2 + C_2^2 V_2^2$\n从第一项中减去第二项：\n分子 = $(C_1^2 V_1^2 + C_1 C_2 V_1^2 + C_1 C_2 V_2^2 + C_2^2 V_2^2) - (C_1^2 V_1^2 + 2 C_1 C_2 V_1 V_2 + C_2^2 V_2^2)$\n$C_1^2 V_1^2$ 和 $C_2^2 V_2^2$ 项相消，剩下：\n分子 = $C_1 C_2 V_1^2 + C_1 C_2 V_2^2 - 2 C_1 C_2 V_1 V_2$\n提出公因式 $C_1 C_2$：\n分子 = $C_1 C_2 (V_1^2 - 2 V_1 V_2 + V_2^2)$\n这是一个完全平方三项式：\n分子 = $C_1 C_2 (V_1 - V_2)^2$\n将这个简化后的分子代回 $E_{dissipated}$ 的表达式中：\n$$E_{dissipated} = \\frac{1}{2} \\frac{C_1 C_2 (V_1 - V_2)^2}{C_1 + C_2}$$\n这就是电阻器中耗散的总能量的最终闭式表达式。它仅取决于给定的电容和初始电压值，并且值得注意的是，它与电阻 $R$ 无关。电阻值只决定了该能量耗散的速率，而不决定总能量的大小。",
            "answer": "$$\\boxed{\\frac{C_1 C_2 (V_1 - V_2)^2}{2(C_1 + C_2)}}$$"
        },
        {
            "introduction": "现在，我们将理论应用于数字逻辑的核心单元——CMOS反相器。这个动手实践要求您构建一个简单的电路瞬态模拟器，以观察和量化反相器开关过程中的能量消耗()。通过对电源电流进行数值积分，您将学会如何将总动态能耗分解为电容充放电能耗和短路能耗两个部分，从而深入理解输入信号压摆率等参数对功耗的影响。",
            "id": "4267558",
            "problem": "一个互补金属氧化物半导体（CMOS）反相器由一个单端输入驱动，该输入以受控的线性斜率从逻辑高电平转换到逻辑低电平。该反相器驱动一个纯电容性负载。电源电压是一个恒定源。目标是将电源提供的能量分离为一个与负载电容充电相关的能量分量，以及一个与过渡期间上拉和下拉晶体管同时导通所致的短路传导相关的能量分量。\n\n使用以下基本定义来构建计算：\n- 电源提供的瞬时功率为 $p(t) = i(t) v(t)$。\n- 在时间间隔内提供的能量为 $E = \\int_{t_0}^{t_1} p(t)\\, dt$。\n- 电容器的本构关系为 $i_C(t) = C \\frac{d v_C(t)}{dt}$。\n- 对于CMOS反相器中的晶体管对，输出节点电压 $v_{\\text{out}}(t)$ 受基尔霍夫电流定律（KCL）在输出节点的支配：$C_L \\frac{d v_{\\text{out}}(t)}{dt} = i_p(t) - i_n(t)$，其中 $i_p(t)$ 是从电源流入节点的上拉晶体管电流，$i_n(t)$ 是从节点流向地的下拉晶体管电流。\n\n您必须构建一个单端CMOS反相器的时域模型，该模型能够捕捉在下降输入（以线性斜坡从 $V_{DD}$ 降至 $0$）期间上拉和下拉器件的重叠导通现象。电源电流定义为 $i_{VDD}(t) = i_p(t)$，电源电压为恒定的 $v_{VDD}(t) = V_{DD}$。输出节点驱动一个纯电容 $C_L$。\n\n使用带有沟道长度调制的Shichman–Hodges强反型分段模型来建模晶体管电流，该模型广泛用于手动分析，并且对于本任务可作为数值器件定律的近似：\n- 对于下拉（n沟道金属氧化物半导体）晶体管，定义 $V_{GS,n}(t) = v_{\\text{in}}(t)$，$V_{DS,n}(t) = v_{\\text{out}}(t)$，以及阈值电压 $V_{TN}$。如果 $V_{GS,n}(t) \\le V_{TN}$，则 $i_n(t) = 0$。否则，\n  - 如果 $V_{DS,n}(t)  V_{GS,n}(t) - V_{TN}$，则 $i_n(t) = k_n \\left( (V_{GS,n}(t) - V_{TN}) V_{DS,n}(t) - \\tfrac{1}{2} V_{DS,n}(t)^2 \\right) \\left( 1 + \\lambda V_{DS,n}(t) \\right)$。\n  - 否则， $i_n(t) = \\tfrac{1}{2} k_n \\left( V_{GS,n}(t) - V_{TN} \\right)^2 \\left( 1 + \\lambda V_{DS,n}(t) \\right)$。\n- 对于上拉（p沟道金属氧化物半导体）晶体管，定义 $V_{SG,p}(t) = V_{DD} - v_{\\text{in}}(t)$，$V_{SD,p}(t) = V_{DD} - v_{\\text{out}}(t)$，以及阈值电压 $|V_{TP}|$。如果 $V_{SG,p}(t) \\le |V_{TP}|$，则 $i_p(t) = 0$。否则，\n  - 如果 $V_{SD,p}(t)  V_{SG,p}(t) - |V_{TP}|$，则 $i_p(t) = k_p \\left( (V_{SG,p}(t) - |V_{TP}|) V_{SD,p}(t) - \\tfrac{1}{2} V_{SD,p}(t)^2 \\right) \\left( 1 + \\lambda V_{SD,p}(t) \\right)$。\n  - 否则，$i_p(t) = \\tfrac{1}{2} k_p \\left( V_{SG,p}(t) - |V_{TP}| \\right)^2 \\left( 1 + \\lambda V_{SD,p}(t) \\right)$。\n\n输入电压是一个线性下降斜坡 $v_{\\text{in}}(t) = V_{DD} \\max\\left( 1 - \\frac{t}{t_{\\text{slew}}}, 0 \\right)$，并且当 $t \\ge t_{\\text{slew}}$ 时，$v_{\\text{in}}(t)$ 保持为 $0$。假设反相器初始驱动输出为低电平，因此 $v_{\\text{out}}(0) = 0$。\n\n任务：\n1. 在一个足够长的时间窗口内对输出节点动态方程 $C_L \\frac{d v_{\\text{out}}(t)}{dt} = i_p(t) - i_n(t)$ 进行数值积分，以使输出在输入转换后能够稳定下来。在整个仿真过程中，使用上面指定的器件定律模型来计算作为 $v_{\\text{in}}(t)$ 和 $v_{\\text{out}}(t)$ 函数的 $i_p(t)$ 和 $i_n(t)$。\n2. 计算在仿真窗口内由电源提供的总能量，定义为 $E_{\\text{total}} = \\int i_{VDD}(t) v_{VDD}(t)\\, dt$，其中 $i_{VDD}(t) = i_p(t)$ 且 $v_{VDD}(t) = V_{DD}$。\n3. 计算在输出上升期间归因于为负载电容充电的能量，定义为 $E_{\\text{cap}} = \\int u(t)\\, i_C(t)\\, v_{VDD}(t)\\, dt$，其中 $i_C(t) = C_L \\frac{d v_{\\text{out}}(t)}{dt}$ 且 $u(t)$ 是单位阶跃函数，当 $i_C(t) \\ge 0$ 时 $u(t) = 1$ 而当 $i_C(t)  0$ 时 $u(t) = 0$。该积分仅将正向的电容充电归因于电源。注意 $v_{VDD}(t) = V_{DD}$ 是恒定的。\n4. 将短路能量定义为 $E_{\\text{sc}} = E_{\\text{total}} - E_{\\text{cap}}$。\n\n所有能量均以焦耳表示。您的程序必须对每个测试用例执行上述计算，并为每个用例生成 $E_{\\text{sc}}$。\n\n测试套件：\n对五个具有现实、自洽值的测试用例使用以下参数值集：\n- 案例1（快速输入）：$V_{DD} = 1.0\\ \\text{V}$，$C_L = 30 \\times 10^{-15}\\ \\text{F}$，$t_{\\text{slew}} = 10 \\times 10^{-12}\\ \\text{s}$，$k_n = 200 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$k_p = 120 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$V_{TN} = 0.35\\ \\text{V}$，$|V_{TP}| = 0.35\\ \\text{V}$，$\\lambda = 0.05\\ \\text{V}^{-1}$。\n- 案例2（中等输入）：$V_{DD} = 1.0\\ \\text{V}$，$C_L = 30 \\times 10^{-15}\\ \\text{F}$，$t_{\\text{slew}} = 50 \\times 10^{-12}\\ \\text{s}$，$k_n = 200 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$k_p = 120 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$V_{TN} = 0.35\\ \\text{V}$，$|V_{TP}| = 0.35\\ \\text{V}$，$\\lambda = 0.05\\ \\text{V}^{-1}$。\n- 案例3（慢速输入）：$V_{DD} = 1.0\\ \\text{V}$，$C_L = 30 \\times 10^{-15}\\ \\text{F}$，$t_{\\text{slew}} = 200 \\times 10^{-12}\\ \\text{s}$，$k_n = 200 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$k_p = 120 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$V_{TN} = 0.35\\ \\text{V}$，$|V_{TP}| = 0.35\\ \\text{V}$，$\\lambda = 0.05\\ \\text{V}^{-1}$。\n- 案例4（极慢输入）：$V_{DD} = 1.0\\ \\text{V}$，$C_L = 30 \\times 10^{-15}\\ \\text{F}$，$t_{\\text{slew}} = 1.0 \\times 10^{-9}\\ \\text{s}$，$k_n = 200 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$k_p = 120 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$V_{TN} = 0.35\\ \\text{V}$，$|V_{TP}| = 0.35\\ \\text{V}$，$\\lambda = 0.05\\ \\text{V}^{-1}$。\n- 案例5（较重负载）：$V_{DD} = 1.0\\ \\text{V}$，$C_L = 100 \\times 10^{-15}\\ \\text{F}$，$t_{\\text{slew}} = 50 \\times 10^{-12}\\ \\text{s}$，$k_n = 200 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$k_p = 120 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$，$V_{TN} = 0.35\\ \\text{V}$，$|V_{TP}| = 0.35\\ \\text{V}$，$\\lambda = 0.05\\ \\text{V}^{-1}$。\n\n答案规格和输出格式：\n- 对于每个测试用例，以浮点数形式计算短路能量 $E_{\\text{sc}}$（单位为焦耳）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，顺序与上述案例一致（例如，$\\left[ e_1, e_2, e_3, e_4, e_5 \\right]$）。所有条目都必须以焦耳为单位。",
            "solution": "该问题要求计算CMOS反相器在由高到低输入斜坡触发的低到高输出转换期间的短路能量耗散 $E_{\\text{sc}}$。这通过对电路进行时域瞬态仿真，并将从电源获取的总能量分离为用于为负载电容充电和用于短路传导的分量来完成。\n\n分析的核心在于求解控制输出节点电压 $v_{\\text{out}}(t)$ 的微分方程。该方程由输出节点的基尔霍夫电流定律（KCL）导出：\n$$\nC_L \\frac{d v_{\\text{out}}(t)}{dt} = i_p(t) - i_n(t)\n$$\n这里，$C_L$ 是负载电容，$i_p(t)$ 是来自上拉p沟道晶体管的电流，$i_n(t)$ 是由下拉n沟道晶体管吸收的电流。初始条件给定为 $v_{\\text{out}}(0) = 0\\ \\text{V}$，对应于输入转换开始前的稳定低电平输出。\n\n晶体管电流 $i_p(t)$ 和 $i_n(t)$ 是其端电压的高度非线性函数，而这些端电压又取决于输入电压 $v_{\\text{in}}(t)$ 和输出电压 $v_{\\text{out}}(t)$。问题指定使用Shichman–Hodges模型来计算这些电流。\n\n对于n沟道晶体管（下拉）：\n栅源电压是 $V_{GS,n}(t) = v_{\\text{in}}(t)$，漏源电压是 $V_{DS,n}(t) = v_{\\text{out}}(t)$。如果 $V_{GS,n}(t) \\le V_{TN}$，晶体管处于截止区（$i_n(t) = 0$）。否则，如果 $V_{DS,n}(t)  V_{GS,n}(t) - V_{TN}$，它处于线性区，如果 $V_{DS,n}(t) \\ge V_{GS,n}(t) - V_{TN}$，则处于饱和区。这些区域的电流方程在问题陈述中提供。\n\n对于p沟道晶体管（上拉）：\n源栅电压是 $V_{SG,p}(t) = V_{DD} - v_{\\text{in}}(t)$，源漏电压是 $V_{SD,p}(t) = V_{DD} - v_{\\text{out}}(t)$。如果 $V_{SG,p}(t) \\le |V_{TP}|$，晶体管处于截止区（$i_p(t) = 0$）。否则，如果 $V_{SD,p}(t)  V_{SG,p}(t) - |V_{TP}|$，它处于线性区，如果 $V_{SD,p}(t) \\ge V_{SG,p}(t) - |V_{TP}|$，则处于饱和区。\n\n输入电压 $v_{\\text{in}}(t)$ 是一个在 $t_{\\text{slew}}$ 持续时间内从 $V_{DD}$ 下降到 $0$ 的线性斜坡：\n$$\nv_{\\text{in}}(t) = V_{DD} \\max\\left( 1 - \\frac{t}{t_{\\text{slew}}}, 0 \\right)\n$$\n根据这些定义，KCL方程成为一个关于 $v_{\\text{out}}(t)$ 的一阶非线性常微分方程（ODE）：\n$$\n\\frac{d v_{\\text{out}}(t)}{dt} = \\frac{1}{C_L} \\left( i_p\\left(v_{\\text{in}}(t), v_{\\text{out}}(t)\\right) - i_n\\left(v_{\\text{in}}(t), v_{\\text{out}}(t)\\right) \\right)\n$$\n这个ODE使用适当的求解器（如SciPy库中的`solve_ivp`函数）进行数值求解。仿真在一个足够长的时间间隔内运行，以使输出稳定到其最终的高电平状态（接近 $V_{DD}$）。这会产生输出电压波形 $v_{\\text{out}}(t)$。\n\n一旦在仿真时间网格上知道了函数 $v_{\\text{in}}(t)$ 和 $v_{\\text{out}}(t)$，就可以在每个时间步计算随时间变化的电流 $i_p(t)$ 和 $i_n(t)$。根据这些，通过数值积分（例如，使用梯形法则）计算所需的能量分量。\n\n1.  **来自电源的总能量 ($E_{\\text{total}}$)**：电源电压 $v_{VDD}(t)$ 是一个常数 $V_{DD}$，电源电流是 $i_{VDD}(t) = i_p(t)$。总能量是瞬时功率 $p(t) = v_{VDD}(t) i_{VDD}(t)$ 的时间积分。\n    $$\n    E_{\\text{total}} = \\int_0^{t_{\\text{final}}} V_{DD} i_p(t) \\, dt = V_{DD} \\int_0^{t_{\\text{final}}} i_p(t) \\, dt\n    $$\n\n2.  **电容充电能量 ($E_{\\text{cap}}$)**：问题将此定义为当电容电流为正时，用于为电容器充电的那部分电源能量。电容电流为 $i_C(t) = C_L \\frac{d v_{\\text{out}}(t)}{dt} = i_p(t) - i_n(t)$。\n    $$\n    E_{\\text{cap}} = \\int_0^{t_{\\text{final}}} u(t) i_C(t) v_{VDD}(t) \\, dt = V_{DD} \\int_0^{t_{\\text{final}}} \\max(i_p(t) - i_n(t), 0) \\, dt\n    $$\n    其中 $u(t)$ 是一个单位阶跃函数，当 $i_C(t) \\ge 0$ 时为 $1$，否则为 $0$。此积分分离出了从电源获取并导致输出电压上升的能量。\n\n3.  **短路能量 ($E_{\\text{sc}}$)**：这是剩余的能量，当两个晶体管同时导通时，电流直接从电源通过它们流向地，这部分能量以热量的形式耗散掉。\n    $$\n    E_{\\text{sc}} = E_{\\text{total}} - E_{\\text{cap}}\n    $$\n该算法通过遍历每个测试用例，设置参数，求解 $v_{\\text{out}}(t)$ 的常微分方程，计算电流的时间序列，执行数值积分以找到 $E_{\\text{total}}$ 和 $E_{\\text{cap}}$，最后计算它们的差值以获得 $E_{\\text{sc}}$。最终结果以焦耳为单位呈现。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Computes the short-circuit energy dissipation in a CMOS inverter for several test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (fast input)\n        {\"VDD\": 1.0, \"CL\": 30e-15, \"tslew\": 10e-12, \"kn\": 200e-6, \"kp\": 120e-6, \"VTN\": 0.35, \"VTP_mag\": 0.35, \"lam\": 0.05},\n        # Case 2 (moderate input)\n        {\"VDD\": 1.0, \"CL\": 30e-15, \"tslew\": 50e-12, \"kn\": 200e-6, \"kp\": 120e-6, \"VTN\": 0.35, \"VTP_mag\": 0.35, \"lam\": 0.05},\n        # Case 3 (slow input)\n        {\"VDD\": 1.0, \"CL\": 30e-15, \"tslew\": 200e-12, \"kn\": 200e-6, \"kp\": 120e-6, \"VTN\": 0.35, \"VTP_mag\": 0.35, \"lam\": 0.05},\n        # Case 4 (very slow input)\n        {\"VDD\": 1.0, \"CL\": 30e-15, \"tslew\": 1.0e-9, \"kn\": 200e-6, \"kp\": 120e-6, \"VTN\": 0.35, \"VTP_mag\": 0.35, \"lam\": 0.05},\n        # Case 5 (heavier load)\n        {\"VDD\": 1.0, \"CL\": 100e-15, \"tslew\": 50e-12, \"kn\": 200e-6, \"kp\": 120e-6, \"VTN\": 0.35, \"VTP_mag\": 0.35, \"lam\": 0.05},\n    ]\n\n    results = []\n\n    t_sim_end = 4.0e-9\n    num_points = 4001\n    t_eval = np.linspace(0, t_sim_end, num_points)\n\n    for params in test_cases:\n        VDD, CL, tslew, kn, kp, VTN, VTP_mag, lam = (\n            params[\"VDD\"], params[\"CL\"], params[\"tslew\"], params[\"kn\"],\n            params[\"kp\"], params[\"VTN\"], params[\"VTP_mag\"], params[\"lam\"]\n        )\n\n        def get_in(v_in, v_out):\n            Vgs_n = v_in\n            Vds_n = v_out\n            if Vgs_n = VTN:\n                return 0.0\n            \n            Vds_n = max(Vds_n, 0.0)\n            Vov_n = Vgs_n - VTN\n            if Vds_n  Vov_n:  # Linear\n                i_n = kn * (Vov_n * Vds_n - 0.5 * Vds_n**2) * (1 + lam * Vds_n)\n            else:  # Saturation\n                i_n = 0.5 * kn * Vov_n**2 * (1 + lam * Vds_n)\n            return i_n\n\n        def get_ip(v_in, v_out):\n            Vsg_p = VDD - v_in\n            Vsd_p = VDD - v_out\n            if Vsg_p = VTP_mag:\n                return 0.0\n\n            Vsd_p = max(Vsd_p, 0.0)\n            Vov_p = Vsg_p - VTP_mag\n            if Vsd_p  Vov_p:  # Linear\n                i_p = kp * (Vov_p * Vsd_p - 0.5 * Vsd_p**2) * (1 + lam * Vsd_p)\n            else:  # Saturation\n                i_p = 0.5 * kp * Vov_p**2 * (1 + lam * Vsd_p)\n            return i_p\n\n        def get_vin_scalar(t):\n            return VDD * max(1 - t / tslew, 0.0)\n\n        def model(t, y):\n            v_out = y[0]\n            v_in = get_vin_scalar(t)\n            v_out_clipped = np.clip(v_out, 0, VDD)\n            ip = get_ip(v_in, v_out_clipped)\n            in_ = get_in(v_in, v_out_clipped)\n            dv_out_dt = (ip - in_) / CL\n            return [dv_out_dt]\n\n        v_out_initial = [0.0]\n        t_span = (0, t_sim_end)\n\n        sol = solve_ivp(\n            fun=model,\n            t_span=t_span,\n            y0=v_out_initial,\n            method='RK45',\n            t_eval=t_eval,\n            atol=1e-12,\n            rtol=1e-9\n        )\n\n        t_points = sol.t\n        v_out_points = sol.y[0]\n\n        v_in_points = VDD * np.maximum(1 - t_points / tslew, 0)\n        \n        ip_points = np.zeros_like(t_points)\n        in_points = np.zeros_like(t_points)\n        v_out_clipped_points = np.clip(v_out_points, 0, VDD)\n\n        for i in range(len(t_points)):\n            ip_points[i] = get_ip(v_in_points[i], v_out_clipped_points[i])\n            in_points[i] = get_in(v_in_points[i], v_out_clipped_points[i])\n            \n        E_total = VDD * np.trapz(ip_points, t_points)\n\n        i_C_points = ip_points - in_points\n        i_C_charging_points = np.maximum(i_C_points, 0)\n        E_cap = VDD * np.trapz(i_C_charging_points, t_points)\n        \n        E_sc = E_total - E_cap\n        results.append(E_sc)\n\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将视角从单个逻辑门提升到系统级。这个练习模拟了现代EDA（电子设计自动化）工具中的静态功耗分析流程()。您将开发一个算法，根据寄生电容提取数据和单元库模型，计算网络级别的总动态功耗，并学习如何系统地考虑互连线寄生效应（如密勒效应）和信号的统计开关行为。",
            "id": "4267551",
            "problem": "您将获得一个综合后的互补金属氧化物半导体（CMOS）数字设计的抽象视图。该设计在网表级别上表示，包含通过电子设计自动化（EDA）提取的寄生电容和来自单元模型的输入引脚电容。您的任务是构建一个算法，用于计算每条网线的等效电容负载，并由此计算在指定的开关因子和对齐参数下的总动态功耗。要求的输出是包含每个场景总动态功耗的单行文本。\n\n用于推导的基本原理：电容器中存储的能量以及功率作为单位时间能量的定义。避免在问题陈述中使用捷径或目标公式。必须从基于这些基本原理的第一性原理出发来构建和解决问题。\n\n输入和数据表示：\n- 一组网线 $\\mathcal{N} = \\{N_0, N_1, N_2\\}$。\n- 对于每条网线 $N_i$，一个导线对地电容 $C_{g,i}$（单位为法拉）以及一个作为负载连接的单元输入引脚电容列表 $\\{C_{pin,i,k}\\}$（单位为法拉）。\n- 对于每对耦合网线无序对 $(N_i, N_j)$（其中 $i \\ne j$），一个耦合电容 $C_{c,ij}$（单位为法拉）。\n- 对于每条网线 $N_i$，一个开关因子 $\\alpha_i$（无量纲小数，单位为次/周期），表示该网线上每个时钟周期内发生 $0 \\rightarrow 1$ 翻转的期望次数，且约束为 $0 \\le \\alpha_i \\le 1$。\n- 对于每对无序对 $(N_i, N_j)$，一个攻击者-受害者方向对齐系数 $\\delta_{ij}$，其取值范围为 $-1 \\le \\delta_{ij} \\le 1$。其中 $\\delta_{ij} = 1$ 表示强同向同时翻转，$\\delta_{ij} = -1$ 表示强反向同时翻转，$\\delta_{ij} = 0$ 表示不相关方向。该系数用于根据翻转的相对方向，以物理上合理的方式偏置开关期间的期望耦合贡献。\n- 电源电压 $V_{dd}$（单位为伏特）和时钟频率 $f$（单位为赫兹）。\n\n不使用捷径公式的高级算法要求：\n1. 从电容器中能量的定义以及关于电荷和电势差的物理推理出发，推导如何将对地电容、引脚电容和耦合电容聚合成一个等效负载 $C_{eff,i}$，该负载是网线 $N_i$ 的驱动器在开关过程中必须充电和放电的。\n2. 展示每个相邻网线的耦合贡献如何依赖于由 $\\alpha_j$ 和 $\\delta_{ij}$ 编码的网线间翻转的统计对齐，从而得出 $C_{c,ij}$ 对 $C_{eff,i}$ 的期望等效贡献。\n3. 使用从开关因子和时钟频率派生出的每次翻转能量和每秒翻转次数，求得所有网线的总动态功耗。\n\n单位和输出规范：\n- 所有电容均以法拉为单位，为了在数据规范中便于阅读，可以方便地表示为飞法（femtofarads）。\n- 电源电压 $V_{dd}$ 以伏特为单位。\n- 时钟频率 $f$ 以赫兹为单位。\n- 最终答案必须以瓦特为单位，表示为浮点数。没有四舍五入的要求，但根据标准双精度浮点运算，数值必须精确。\n- 本问题不使用角度和三角函数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $\\texttt{[r_1,r_2,r_3]}$，其中每个 $r_k$ 是测试用例 $k$ 的总动态功耗（单位为瓦特）。\n\n设计数据（所有场景固定）：\n- 网线和对地电容：\n  - $N_0$: $C_{g,0} = 120 \\times 10^{-15}$。\n  - $N_1$: $C_{g,1} = 80 \\times 10^{-15}$。\n  - $N_2$: $C_{g,2} = 150 \\times 10^{-15}$。\n- 连接到每条网线的单元输入引脚电容：\n  - $N_0$: $\\{3 \\times 10^{-15}, 2 \\times 10^{-15}\\}$。\n  - $N_1$: $\\{4 \\times 10^{-15}\\}$。\n  - $N_2$: $\\{2 \\times 10^{-15}, 2 \\times 10^{-15}, 3 \\times 10^{-15}\\}$。\n- 网线间的耦合电容（无序对）：\n  - $(N_0, N_1)$: $C_{c,01} = 30 \\times 10^{-15}$。\n  - $(N_0, N_2)$: $C_{c,02} = 20 \\times 10^{-15}$。\n  - $(N_1, N_2)$: $C_{c,12} = 25 \\times 10^{-15}$。\n\n测试套件：\n- 场景 $1$（正常路径）：\n  - 电源和时钟：$V_{dd} = 0.9$, $f = 5.0 \\times 10^{8}$。\n  - 开关因子：$\\alpha_0 = 0.2$, $\\alpha_1 = 0.35$, $\\alpha_2 = 0.1$。\n  - 对齐系数：$\\delta_{01} = -0.6$, $\\delta_{02} = 0.2$, $\\delta_{12} = 0.0$。\n- 场景 $2$（边界情况：一条网线不翻转）：\n  - 电源和时钟：$V_{dd} = 1.0$, $f = 2.0 \\times 10^{8}$。\n  - 开关因子：$\\alpha_0 = 0.4$, $\\alpha_1 = 0.15$, $\\alpha_2 = 0.0$。\n  - 对齐系数：$\\delta_{01} = 1.0$, $\\delta_{02} = -1.0$, $\\delta_{12} = -1.0$。\n- 场景 $3$（边界情况：零频率）：\n  - 电源和时钟：$V_{dd} = 0.8$, $f = 0.0$。\n  - 开关因子：$\\alpha_0 = 0.5$, $\\alpha_1 = 0.5$, $\\alpha_2 = 0.5$。\n  - 对齐系数：$\\delta_{01} = 0.0$, $\\delta_{02} = 0.0$, $\\delta_{12} = 0.0$。\n- 场景 $4$（边界情况：全速率翻转下的最大反向对齐）：\n  - 电源和时钟：$V_{dd} = 1.1$, $f = 3.0 \\times 10^{8}$。\n  - 开关因子：$\\alpha_0 = 1.0$, $\\alpha_1 = 1.0$, $\\alpha_2 = 1.0$。\n  - 对齐系数：$\\delta_{01} = -1.0$, $\\delta_{02} = -1.0$, $\\delta_{12} = -1.0$。\n\n程序要求：\n- 实现一个算法，在每个场景中，使用对地电容、由 $N_i$ 驱动的引脚电容之和，以及从 $\\alpha_j$ 和 $\\delta_{ij}$ 派生出的每个相邻网线的期望耦合贡献，来聚合每条网线 $N_i$ 的等效电容 $C_{eff,i}$。\n- 根据物理推导的能量和事件率关系，计算所有网线的总动态功耗（单位为瓦特）。\n- 生成单行输出，包含场景 1 到 4 的总功耗，按所列顺序排列，格式为 $\\texttt{[r_1,r_2,r_3,r_4]}$，不含空格。",
            "solution": "该问题是有效的。它在科学上基于电气工程的原理，特别是与CMOS数字电路中的功耗相关。问题是适定的，提供了足够的信息来推导出唯一的解。参数及其数值在物理上是现实的。\n\n解决方案首先按照要求从基本原理推导出总动态功耗的公式，然后将该公式应用于所提供的测试场景。\n\n### 第1步：从第一性原理推导动态功耗\n\nCMOS数字电路消耗的动态功耗是在网线寄生电容充放电期间耗散的功率。我们从电容器的能量出发，推导该功耗的表达式。\n\n一个电容为 $C$ 的电容器，其极板间电压差为 $V$ 时，存储的能量 $E$ 由下式给出：\n$$E = \\frac{1}{2} C V^2$$\n\n在标准的轨到轨CMOS逻辑电路中，网线电压 $V_{net}$ 在地（$0$）和电源电压（$V_{dd}$）之间切换。考虑一条总等效电容为 $C_{eff,i}$ 的网线 $N_i$，其驱动器必须对其进行充电或放电。\n\n在 $0 \\to V_{dd}$ 翻转（充电）期间，驱动器的上拉网络将网线连接到电源 $V_{dd}$。从电源汲取的总电荷为 $Q_i = C_{eff,i} V_{dd}$。从电源汲取的能量为：\n$$E_{supply,i} = Q_i V_{dd} = (C_{eff,i} V_{dd}) V_{dd} = C_{eff,i} V_{dd}^2$$\n在这部分能量中，一半存储在电容器中（$\\frac{1}{2} C_{eff,i} V_{dd}^2$），另一半则在上拉网络的电阻性元件中以热量形式耗散。\n\n在随后的 $V_{dd} \\to 0$ 翻转（放电）期间，驱动器的下拉网络将网线连接到地。存储在电容器中的能量 $\\frac{1}{2} C_{eff,i} V_{dd}^2$ 在下拉网络中以热量形式耗散。在此阶段，电源断开，不提供能量。\n\n因此，对于一个完整的充放电周期（$0 \\to V_{dd} \\to 0$），从电源汲取的总能量为 $C_{eff,i} V_{dd}^2$。\n\n功率定义为单位时间的能量（$P = dE/dt$）。平均动态功耗是单位时间内消耗的总能量。问题将开关因子 $\\alpha_i$ 定义为网线 $N_i$ 上每个时钟周期的平均 $0 \\to 1$ 翻转次数。给定一个时钟频率 $f$（单位为周期/秒，或赫兹），网线 $N_i$ 的充电事件速率为 $\\alpha_i f$。\n\n网线 $N_i$ 的动态功耗 $P_{dyn,i}$ 是每次充电事件的能量乘以这些事件的速率：\n$$P_{dyn,i} = E_{supply,i} \\times (\\alpha_i f) = (C_{eff,i} V_{dd}^2) (\\alpha_i f) = \\alpha_i f C_{eff,i} V_{dd}^2$$\n\n系统的总动态功耗是所有网线消耗的功耗之和：\n$$P_{dyn,total} = \\sum_{i \\in \\mathcal{N}} P_{dyn,i} = \\sum_{i \\in \\mathcal{N}} \\alpha_i f C_{eff,i} V_{dd}^2 = f V_{dd}^2 \\sum_{i \\in \\mathcal{N}} \\alpha_i C_{eff,i}$$\n\n### 第2步：等效电容（$C_{eff,i}$）的推导\n\n等效电容 $C_{eff,i}$ 是网线 $N_i$ 的驱动器在 $0 \\to V_{dd}$ 翻转期间必须充电的总电容。它是对地电容和耦合电容贡献的总和。\n\n1.  **对地电容**：这些包括导线对地电容 $C_{g,i}$ 和由网线 $N_i$ 驱动的单元的输入引脚电容 $\\{C_{pin,i,k}\\}$。这些电容都连接在网线和地（或稳定参考点）之间。它们的贡献是一个简单的总和：\n    $$C_{gnd,i} = C_{g,i} + \\sum_k C_{pin,i,k}$$\n\n2.  **耦合电容**：耦合电容 $C_{c,ij}$ 连接网线 $N_i$（受害者）和相邻网线 $N_j$（攻击者）。$N_i$ 的驱动器为 $C_{c,ij}$ 充电所需的电荷量取决于网线 $N_j$ 上的同步电压变化。$N_i$ 的驱动器必须向其连接的电容器极板提供的电荷变化量 $\\Delta Q_{ij}$ 由下式给出：\n    $$\\Delta Q_{ij} = C_{c,ij} \\Delta(V_i - V_j) = C_{c,ij} (\\Delta V_i - \\Delta V_j)$$\n    对于网线 $N_i$ 上的 $0 \\to V_{dd}$ 翻转，$\\Delta V_i = V_{dd}$。方程变为：\n    $$\\Delta Q_{ij} = C_{c,ij} (V_{dd} - \\Delta V_j)$$\n    此处，$\\Delta V_j$ 是在 $N_i$ 翻转期间网线 $N_j$ 上的电压摆幅。由于翻转是统计性的，我们必须考虑在网线 $N_i$ 向上翻转的条件下 $\\Delta V_j$ 的期望值：$E[\\Delta V_j | i \\uparrow]$。期望电荷为 $E[\\Delta Q_{ij}] = C_{c,ij} (V_{dd} - E[\\Delta V_j | i \\uparrow])$。\n\n    问题提供了参数 $\\alpha_j$（攻击者 $N_j$ 的活动因子）和 $\\delta_{ij}$（方向对齐）来对此效应建模。我们可以定义一个等效米勒因子 $k_{ij} = E[\\Delta V_j | i \\uparrow] / V_{dd}$。与参数定义一致的、一个简单的、物理上合理的该因子线性模型是：\n    $$k_{ij} = \\delta_{ij} \\alpha_j$$\n    该模型正确地反映了此效应与攻击者的活动（$\\alpha_j$）成正比，并受方向相关性（$\\delta_{ij}$）的偏置。例如，如果 $N_j$ 是静态的（$\\alpha_j=0$），则 $k_{ij}=0$。如果翻转不相关（$\\delta_{ij}=0$），则 $k_{ij}=0$。对于全速率活动（$\\alpha_j=1$）的完全反相关翻转（$\\delta_{ij}=-1$），$k_{ij}=-1$，使电荷需求最大化。\n\n    现在可以用等效电容贡献来表示期望电荷。电荷为 $C_{c,ij}(1 - k_{ij})V_{dd}$，因此来自 $C_{c,ij}$ 的等效电容贡献为 $C_{c,ij}(1 - k_{ij})$。\n    $$C_{c,ij,eff} = C_{c,ij} (1 - \\delta_{ij}\\alpha_j)$$\n    请注意，在计算 $C_{eff,i}$ 时，相邻网线是 $N_j$，所以我们使用 $\\alpha_j$ 和 $\\delta_{ij}$。问题陈述为无序对给出了 $\\delta_{ij}$，这意味着 $\\delta_{ij} = \\delta_{ji}$。\n\n3.  **总等效电容**：将对地电容和等效耦合电容的贡献相加，我们得到网线 $N_i$ 的总等效电容：\n    $$C_{eff,i} = \\left(C_{g,i} + \\sum_k C_{pin,i,k}\\right) + \\sum_{j \\ne i, j \\in \\mathcal{N}} C_{c,ij} (1 - \\delta_{ij}\\alpha_j)$$\n\n### 总动态功耗的最终公式\n\n通过将 $C_{eff,i}$ 的表达式代入功耗公式，我们得到总动态功耗的完整方程：\n$$P_{dyn,total} = f V_{dd}^2 \\sum_{i \\in \\mathcal{N}} \\alpha_i \\left[ \\left(C_{g,i} + \\sum_k C_{pin,i,k}\\right) + \\sum_{j \\ne i, j \\in \\mathcal{N}} C_{c,ij} (1 - \\delta_{ij}\\alpha_j) \\right]$$\n\n此公式将被实现，以解决每个给定测试场景中的总动态功耗。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used from scipy or other external packages.\n\ndef solve():\n    \"\"\"\n    Computes the total dynamic power for a CMOS digital design across multiple scenarios.\n    \"\"\"\n    \n    # Design data (fixed across all scenarios)\n    # All capacitances are in Farads (F).\n    C_g = {\n        0: 120e-15,  # C_g,0 for Net N_0\n        1: 80e-15,   # C_g,1 for Net N_1\n        2: 150e-15,  # C_g,2 for Net N_2\n    }\n    \n    C_pin = {\n        0: [3e-15, 2e-15],        # Pin loads on Net N_0\n        1: [4e-15],               # Pin loads on Net N_1\n        2: [2e-15, 2e-15, 3e-15], # Pin loads on Net N_2\n    }\n    \n    # Sum of pin capacitances per net for convenience\n    C_pin_sum = {net: sum(caps) for net, caps in C_pin.items()}\n    \n    C_c = {\n        (0, 1): 30e-15, # Coupling between N_0 and N_1\n        (0, 2): 20e-15, # Coupling between N_0 and N_2\n        (1, 2): 25e-15, # Coupling between N_1 and N_2\n    }\n    # Symmetrize the coupling capacitance matrix for easier lookup\n    C_c.update({(j, i): val for (i, j), val in C_c.items()})\n\n    nets = [0, 1, 2]\n    \n    # Test suite with multiple scenarios\n    test_cases = [\n        { # Scenario 1\n            \"V_dd\": 0.9,\n            \"f\": 5.0e8,\n            \"alpha\": {0: 0.2, 1: 0.35, 2: 0.1},\n            \"delta\": {(0, 1): -0.6, (0, 2): 0.2, (1, 2): 0.0},\n        },\n        { # Scenario 2\n            \"V_dd\": 1.0,\n            \"f\": 2.0e8,\n            \"alpha\": {0: 0.4, 1: 0.15, 2: 0.0},\n            \"delta\": {(0, 1): 1.0, (0, 2): -1.0, (1, 2): -1.0},\n        },\n        { # Scenario 3\n            \"V_dd\": 0.8,\n            \"f\": 0.0,\n            \"alpha\": {0: 0.5, 1: 0.5, 2: 0.5},\n            \"delta\": {(0, 1): 0.0, (0, 2): 0.0, (1, 2): 0.0},\n        },\n        { # Scenario 4\n            \"V_dd\": 1.1,\n            \"f\": 3.0e8,\n            \"alpha\": {0: 1.0, 1: 1.0, 2: 1.0},\n            \"delta\": {(0, 1): -1.0, (0, 2): -1.0, (1, 2): -1.0},\n        },\n    ]\n\n    total_power_results = []\n\n    for case in test_cases:\n        V_dd = case[\"V_dd\"]\n        f = case[\"f\"]\n        alpha = case[\"alpha\"]\n        delta = case[\"delta\"]\n        # Symmetrize delta for easier lookup\n        delta.update({(j, i): val for (i, j), val in delta.items()})\n\n        total_power = 0.0\n\n        if f == 0.0:\n            total_power_results.append(0.0)\n            continue\n        \n        # Calculate power contribution from each net\n        for i in nets:\n            # Power on net i is zero if it doesn't switch\n            if alpha[i] == 0.0:\n                continue\n\n            # 1. Sum of grounded capacitances\n            C_grounded_i = C_g[i] + C_pin_sum[i]\n\n            # 2. Sum of effective coupling capacitances\n            C_coupling_eff_i = 0.0\n            for j in nets:\n                if i == j:\n                    continue\n                \n                # Miller factor k_ij = delta_ij * alpha_j\n                # Effective coupling cap = C_c,ij * (1 - k_ij)\n                k_ij = delta[(i, j)] * alpha[j]\n                C_coupling_eff_i += C_c[(i, j)] * (1.0 - k_ij)\n            \n            # 3. Total effective capacitance for net i\n            C_eff_i = C_grounded_i + C_coupling_eff_i\n\n            # 4. Dynamic power for net i\n            P_dyn_i = alpha[i] * f * C_eff_i * (V_dd ** 2)\n            \n            total_power += P_dyn_i\n            \n        total_power_results.append(total_power)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, total_power_results))}]\")\n\nsolve()\n```"
        }
    ]
}