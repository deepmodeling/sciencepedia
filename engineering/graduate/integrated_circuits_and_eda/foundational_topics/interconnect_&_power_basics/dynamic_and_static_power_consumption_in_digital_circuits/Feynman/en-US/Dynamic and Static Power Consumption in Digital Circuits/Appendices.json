{
    "hands_on_practices": [
        {
            "introduction": "To build a robust understanding of power dissipation, we first isolate a fundamental physical process: charge sharing. Whenever charge redistributes between two capacitive nodes at different potentials, energy is inevitably lost as heat, a principle that has significant implications for the design of dynamic logic and bus architectures. This exercise challenges you to derive this energy loss from first principles of charge and energy conservation, revealing the insightful and perhaps counter-intuitive result that the total dissipated energy is independent of the resistance of the connecting path .",
            "id": "4267507",
            "problem": "In a Complementary Metal-Oxide-Semiconductor (CMOS) digital integrated circuit, two isolated nodes $\\mathcal{N}_1$ and $\\mathcal{N}_2$ are each modeled as ideal lumped capacitors $C_1$ and $C_2$, respectively, with initial voltages $V_1$ and $V_2$ relative to a common reference. At time $t=0$, a pass transistor turns on and is modeled as a purely resistive connection of resistance $R$ between $\\mathcal{N}_1$ and $\\mathcal{N}_2$. Assume there are no other sources, no inductances, and the only conduction path during the event is through the resistor $R$. The system is allowed to relax to its final equilibrium as $t \\to \\infty$, after which the transistor turns off and both nodes remain isolated. Using only fundamental physical principles, including charge conservation, Kirchhoff’s laws, and the definition of energy stored in a capacitor, derive the total energy dissipated in the resistor during the entire transient in terms of $C_1$, $C_2$, $V_1$, and $V_2$. Express your final energy in Joules as a single closed-form analytic expression. Do not assume any special relationship between $V_1$ and $V_2$, and do not invoke results that have not been derived from the stated principles. The final answer must be a single analytical expression.",
            "solution": "The user wants to find the total energy dissipated in a resistor connecting two capacitors that were initially charged to different voltages.\n\n### Step 1: Extract Givens\n- Two ideal lumped capacitors, $C_1$ and $C_2$.\n- Initial voltages at time $t=0$: $v_1(0) = V_1$ and $v_2(0) = V_2$.\n- A resistor of resistance $R$ connects the two capacitors at $t=0$.\n- The system is otherwise isolated (no other sources or conduction paths).\n- The system relaxes to equilibrium as $t \\to \\infty$.\n- The task is to derive the total dissipated energy in the resistor, $E_{dissipated}$, using charge conservation, Kirchhoff's laws, and the definition of energy stored in a capacitor. The result must be a closed-form expression in terms of $C_1$, $C_2$, $V_1$, and $V_2$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem describes a classic RC circuit, a fundamental topic in electrical engineering and physics. The model of ideal capacitors and resistors is a standard and valid physical approximation. The principles cited (charge conservation, Kirchhoff's laws, capacitor energy) are cornerstone laws of electromagnetism. The problem is scientifically sound.\n- **Well-Posed**: The problem is clearly defined with all necessary initial conditions and component properties to determine the final state of the system and the energy difference between the initial and final states. A unique, stable equilibrium state exists, and thus a unique value for the total dissipated energy can be calculated.\n- **Objective**: The problem is stated using precise, technical, and unambiguous language, free from subjective content.\n- **Flaw Checklist**: The problem does not violate any of the specified criteria for invalidity. It is scientifically sound, formalizable, complete, physically realistic (within the ideal component model), well-posed, non-trivial, and verifiable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be derived from first principles as requested.\n\n### Derivation\nThe total energy dissipated in the resistor, $E_{dissipated}$, can be found by applying the law of conservation of energy. The total energy of the isolated system is composed of the electrostatic energy stored in the capacitors and the heat dissipated in the resistor. Since no energy is supplied to the system after $t=0$, the energy dissipated as heat must equal the reduction in the total electrostatic energy stored in the capacitors from the initial state ($t=0$) to the final equilibrium state ($t \\to \\infty$).\n\nLet $E_{initial}$ be the total energy stored in the capacitors at $t=0$, and $E_{final}$ be the total energy stored at $t \\to \\infty$. Then, the energy dissipated in the resistor is:\n$$E_{dissipated} = E_{initial} - E_{final}$$\n\n**1. Initial State Energy**\nThe energy stored in a capacitor $C$ with voltage $V$ across its terminals is given by $E = \\frac{1}{2} C V^2$.\nAt time $t=0$, the voltage on capacitor $C_1$ is $V_1$ and the voltage on capacitor $C_2$ is $V_2$. The total initial stored energy is the sum of the energies in each capacitor:\n$$E_{initial} = \\frac{1}{2} C_1 V_1^2 + \\frac{1}{2} C_2 V_2^2$$\n\n**2. Final State Energy**\nAfter the switch closes at $t=0$, charge flows between the capacitors through the resistor $R$. This process continues until the system reaches a new electrostatic equilibrium. Equilibrium is reached when the current $i(t)$ through the resistor becomes zero. According to Ohm's law, $i = (v_1 - v_2)/R$, the current is zero only when the voltage difference across the resistor is zero. This implies that the final voltages on the two capacitors are equal. Let this final equilibrium voltage be $V_f$.\n$$v_1(t \\to \\infty) = v_2(t \\to \\infty) = V_f$$\nThe system consisting of the two capacitors and the resistor is electrically isolated. Therefore, the total electric charge must be conserved throughout the process.\nThe initial total charge $Q_{initial}$ is the sum of the charges on each capacitor:\n$$Q_{initial} = C_1 V_1 + C_2 V_2$$\nThe final total charge $Q_{final}$ at equilibrium is:\n$$Q_{final} = C_1 V_f + C_2 V_f = (C_1 + C_2) V_f$$\nBy the principle of charge conservation, $Q_{initial} = Q_{final}$:\n$$C_1 V_1 + C_2 V_2 = (C_1 + C_2) V_f$$\nFrom this, we solve for the final equilibrium voltage $V_f$:\n$$V_f = \\frac{C_1 V_1 + C_2 V_2}{C_1 + C_2}$$\nThe total final energy $E_{final}$ stored in the capacitors is:\n$$E_{final} = \\frac{1}{2} C_1 V_f^2 + \\frac{1}{2} C_2 V_f^2 = \\frac{1}{2} (C_1 + C_2) V_f^2$$\nSubstituting the expression for $V_f$:\n$$E_{final} = \\frac{1}{2} (C_1 + C_2) \\left( \\frac{C_1 V_1 + C_2 V_2}{C_1 + C_2} \\right)^2 = \\frac{1}{2} \\frac{(C_1 V_1 + C_2 V_2)^2}{C_1 + C_2}$$\n\n**3. Total Dissipated Energy**\nNow we can compute the total energy dissipated in the resistor by subtracting the final energy from the initial energy:\n$$E_{dissipated} = E_{initial} - E_{final} = \\left( \\frac{1}{2} C_1 V_1^2 + \\frac{1}{2} C_2 V_2^2 \\right) - \\frac{1}{2} \\frac{(C_1 V_1 + C_2 V_2)^2}{C_1 + C_2}$$\nFactor out the $\\frac{1}{2}$ and place the terms over a common denominator $(C_1 + C_2)$:\n$$E_{dissipated} = \\frac{1}{2} \\left[ \\frac{(C_1 V_1^2 + C_2 V_2^2)(C_1 + C_2) - (C_1 V_1 + C_2 V_2)^2}{C_1 + C_2} \\right]$$\nExpand the numerator:\nFirst term: $(C_1 V_1^2 + C_2 V_2^2)(C_1 + C_2) = C_1^2 V_1^2 + C_1 C_2 V_1^2 + C_1 C_2 V_2^2 + C_2^2 V_2^2$\nSecond term: $(C_1 V_1 + C_2 V_2)^2 = C_1^2 V_1^2 + 2 C_1 C_2 V_1 V_2 + C_2^2 V_2^2$\nSubtracting the second term from the first:\nNumerator = $(C_1^2 V_1^2 + C_1 C_2 V_1^2 + C_1 C_2 V_2^2 + C_2^2 V_2^2) - (C_1^2 V_1^2 + 2 C_1 C_2 V_1 V_2 + C_2^2 V_2^2)$\nThe terms $C_1^2 V_1^2$ and $C_2^2 V_2^2$ cancel, leaving:\nNumerator = $C_1 C_2 V_1^2 + C_1 C_2 V_2^2 - 2 C_1 C_2 V_1 V_2$\nFactor out the common term $C_1 C_2$:\nNumerator = $C_1 C_2 (V_1^2 - 2 V_1 V_2 + V_2^2)$\nThis is a perfect square trinomial:\nNumerator = $C_1 C_2 (V_1 - V_2)^2$\nSubstituting this simplified numerator back into the expression for $E_{dissipated}$:\n$$E_{dissipated} = \\frac{1}{2} \\frac{C_1 C_2 (V_1 - V_2)^2}{C_1 + C_2}$$\nThis is the final closed-form expression for the total energy dissipated in the resistor. It depends only on the given capacitance and initial voltage values, and notably not on the resistance $R$. The resistance value only determines the rate at which this energy is dissipated, not the total amount.",
            "answer": "$$\\boxed{\\frac{C_1 C_2 (V_1 - V_2)^2}{2(C_1 + C_2)}}$$"
        },
        {
            "introduction": "Moving from an idealized model to the workhorse of digital logic, the CMOS inverter, we explore the two primary components of its dynamic power consumption: capacitive switching and short-circuit current. While we often use the simplified formula $P = C V_{DD}^2 f$, a more detailed view shows that a temporary direct path from supply to ground during input transitions also consumes significant power. This computational exercise guides you through building a transient simulation from the ground up, using device models to solve for the circuit's behavior over time and precisely separating the total energy drawn from the supply into its capacitive and short-circuit components . This practice demystifies the transient events inside a logic gate and quantifies their impact on power.",
            "id": "4267558",
            "problem": "A complementary metal–oxide–semiconductor (CMOS) inverter is driven by a single-ended input that transitions from a logic high to a logic low with a controlled linear slew. The inverter drives a purely capacitive load. The supply voltage is a constant source. The goal is to separate the energy delivered from the supply into an energy component associated with charging the load capacitor and an energy component associated with short-circuit conduction through the simultaneous conduction of the pull-up and pull-down transistors during the transition.\n\nUse the following foundational definitions to construct the computation:\n- The instantaneous power delivered by a source is $p(t) = i(t) v(t)$.\n- The energy delivered over a time interval is $E = \\int_{t_0}^{t_1} p(t)\\, dt$.\n- The capacitor constitutive relation is $i_C(t) = C \\frac{d v_C(t)}{dt}$.\n- For a transistor pair in a CMOS inverter, the node voltage $v_{\\text{out}}(t)$ is governed by Kirchhoff's current law (KCL) at the output node: $C_L \\frac{d v_{\\text{out}}(t)}{dt} = i_p(t) - i_n(t)$, where $i_p(t)$ is the pull-up transistor current from the supply into the node, and $i_n(t)$ is the pull-down transistor current from the node to ground.\n\nYou must construct a time-domain model of a single-ended CMOS inverter that captures the overlapping conduction of the pull-up and pull-down devices during a falling input (from $V_{DD}$ to $0$ with a linear ramp). The supply current is defined as $i_{VDD}(t) = i_p(t)$, and the supply voltage is a constant $v_{VDD}(t) = V_{DD}$. The output node drives a pure capacitor $C_L$.\n\nModel the transistor currents with the Shichman–Hodges strong-inversion piecewise model with channel-length modulation, which is widely used for hand analysis and is acceptable as a numerical device-law approximation for this task:\n- For the pull-down (n-channel metal–oxide–semiconductor) transistor, define $V_{GS,n}(t) = v_{\\text{in}}(t)$, $V_{DS,n}(t) = v_{\\text{out}}(t)$, and threshold $V_{TN}$. If $V_{GS,n}(t) \\le V_{TN}$, then $i_n(t) = 0$. Otherwise,\n  - If $V_{DS,n}(t) < V_{GS,n}(t) - V_{TN}$, then $i_n(t) = k_n \\left( (V_{GS,n}(t) - V_{TN}) V_{DS,n}(t) - \\tfrac{1}{2} V_{DS,n}(t)^2 \\right) \\left( 1 + \\lambda V_{DS,n}(t) \\right)$.\n  - Else, $i_n(t) = \\tfrac{1}{2} k_n \\left( V_{GS,n}(t) - V_{TN} \\right)^2 \\left( 1 + \\lambda V_{DS,n}(t) \\right)$.\n- For the pull-up (p-channel metal–oxide–semiconductor) transistor, define $V_{SG,p}(t) = V_{DD} - v_{\\text{in}}(t)$, $V_{SD,p}(t) = V_{DD} - v_{\\text{out}}(t)$, and threshold $|V_{TP}|$. If $V_{SG,p}(t) \\le |V_{TP}|$, then $i_p(t) = 0$. Otherwise,\n  - If $V_{SD,p}(t) < V_{SG,p}(t) - |V_{TP}|$, then $i_p(t) = k_p \\left( (V_{SG,p}(t) - |V_{TP}|) V_{SD,p}(t) - \\tfrac{1}{2} V_{SD,p}(t)^2 \\right) \\left( 1 + \\lambda V_{SD,p}(t) \\right)$.\n  - Else, $i_p(t) = \\tfrac{1}{2} k_p \\left( V_{SG,p}(t) - |V_{TP}| \\right)^2 \\left( 1 + \\lambda V_{SD,p}(t) \\right)$.\n\nThe input voltage is a linear falling ramp $v_{\\text{in}}(t) = V_{DD} \\max\\left( 1 - \\frac{t}{t_{\\text{slew}}}, 0 \\right)$, and $v_{\\text{in}}(t)$ is held at $0$ for $t \\ge t_{\\text{slew}}$. Assume the inverter initially drives the output low, so $v_{\\text{out}}(0) = 0$.\n\nTasks:\n1. Numerically integrate the output node dynamic equation $C_L \\frac{d v_{\\text{out}}(t)}{dt} = i_p(t) - i_n(t)$ over a time window sufficiently long for the output to settle after the input transition. Use the specified device-law model above to compute $i_p(t)$ and $i_n(t)$ as functions of $v_{\\text{in}}(t)$ and $v_{\\text{out}}(t)$ throughout the simulation.\n2. Compute the total energy delivered by the supply over the simulated window, defined by $E_{\\text{total}} = \\int i_{VDD}(t) v_{VDD}(t)\\, dt$ with $i_{VDD}(t) = i_p(t)$ and $v_{VDD}(t) = V_{DD}$.\n3. Compute the energy attributable to charging the load capacitor during the rising output, defined by $E_{\\text{cap}} = \\int u(t)\\, i_C(t)\\, v_{VDD}(t)\\, dt$, where $i_C(t) = C_L \\frac{d v_{\\text{out}}(t)}{dt}$ and $u(t)$ is the unit step $u(t) = 1$ when $i_C(t) \\ge 0$ and $u(t) = 0$ when $i_C(t) < 0$. This integral attributes only positive capacitor charging to the supply. Note that $v_{VDD}(t) = V_{DD}$ is constant.\n4. Define the short-circuit energy as $E_{\\text{sc}} = E_{\\text{total}} - E_{\\text{cap}}$.\n\nExpress all energies in joules. Your program must carry out the above computations for each test case and produce $E_{\\text{sc}}$ for each case.\n\nTest Suite:\nUse the following set of parameter values for five test cases with realistic, self-consistent values:\n- Case 1 (fast input): $V_{DD} = 1.0\\ \\text{V}$, $C_L = 30 \\times 10^{-15}\\ \\text{F}$, $t_{\\text{slew}} = 10 \\times 10^{-12}\\ \\text{s}$, $k_n = 200 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$, $k_p = 120 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$, $V_{TN} = 0.35\\ \\text{V}$, $|V_{TP}| = 0.35\\ \\text{V}$, $\\lambda = 0.05\\ \\text{V}^{-1}$.\n- Case 2 (moderate input): $V_{DD} = 1.0\\ \\text{V}$, $C_L = 30 \\times 10^{-15}\\ \\text{F}$, $t_{\\text{slew}} = 50 \\times 10^{-12}\\ \\text{s}$, $k_n = 200 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$, $k_p = 120 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$, $V_{TN} = 0.35\\ \\text{V}$, $|V_{TP}| = 0.35\\ \\text{V}$, $\\lambda = 0.05\\ \\text{V}^{-1}$.\n- Case 3 (slow input): $V_{DD} = 1.0\\ \\text{V}$, $C_L = 30 \\times 10^{-15}\\ \\text{F}$, $t_{\\text{slew}} = 200 \\times 10^{-12}\\ \\text{s}$, $k_n = 200 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$, $k_p = 120 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$, $V_{TN} = 0.35\\ \\text{V}$, $|V_{TP}| = 0.35\\ \\text{V}$, $\\lambda = 0.05\\ \\text{V}^{-1}$.\n- Case 4 (very slow input): $V_{DD} = 1.0\\ \\text{V}$, $C_L = 30 \\times 10^{-15}\\ \\text{F}$, $t_{\\text{slew}} = 1.0 \\times 10^{-9}\\ \\text{s}$, $k_n = 200 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$, $k_p = 120 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$, $V_{TN} = 0.35\\ \\text{V}$, $|V_{TP}| = 0.35\\ \\text{V}$, $\\lambda = 0.05\\ \\text{V}^{-1}$.\n- Case 5 (heavier load): $V_{DD} = 1.0\\ \\text{V}$, $C_L = 100 \\times 10^{-15}\\ \\text{F}$, $t_{\\text{slew}} = 50 \\times 10^{-12}\\ \\text{s}$, $k_n = 200 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$, $k_p = 120 \\times 10^{-6}\\ \\text{A}/\\text{V}^2$, $V_{TN} = 0.35\\ \\text{V}$, $|V_{TP}| = 0.35\\ \\text{V}$, $\\lambda = 0.05\\ \\text{V}^{-1}$.\n\nAnswer Specification and Output Format:\n- For each test case, compute the short-circuit energy $E_{\\text{sc}}$ in joules as a floating-point number.\n- Your program should produce a single line of output containing the list of results as a comma-separated list enclosed in square brackets, in the order of the cases above (for example, $\\left[ e_1, e_2, e_3, e_4, e_5 \\right]$). All entries must be in joules.",
            "solution": "The problem requires the calculation of the short-circuit energy dissipation, $E_{\\text{sc}}$, in a CMOS inverter during a low-to-high output transition triggered by a high-to-low input ramp. This is accomplished by performing a time-domain transient simulation of the circuit and separating the total energy drawn from the supply into components for charging the load capacitor and for short-circuit conduction.\n\nThe core of the analysis rests on solving the differential equation governing the output node voltage, $v_{\\text{out}}(t)$. This equation is derived from Kirchhoff's Current Law (KCL) at the output node:\n$$\nC_L \\frac{d v_{\\text{out}}(t)}{dt} = i_p(t) - i_n(t)\n$$\nHere, $C_L$ is the load capacitance, $i_p(t)$ is the current from the pull-up p-channel transistor, and $i_n(t)$ is the current sunk by the pull-down n-channel transistor. The initial condition is given as $v_{\\text{out}}(0) = 0\\ \\text{V}$, corresponding to a stable low output before the input transition begins.\n\nThe transistor currents $i_p(t)$ and $i_n(t)$ are highly nonlinear functions of their terminal voltages, which in turn depend on the input voltage $v_{\\text{in}}(t)$ and the output voltage $v_{\\text{out}}(t)$. The problem specifies the use of the Shichman–Hodges model for these currents.\n\nFor the n-channel transistor (pull-down):\nThe gate-source voltage is $V_{GS,n}(t) = v_{\\text{in}}(t)$ and the drain-source voltage is $V_{DS,n}(t) = v_{\\text{out}}(t)$. The transistor is in cutoff ($i_n(t) = 0$) if $V_{GS,n}(t) \\le V_{TN}$. Otherwise, it is in the linear region if $V_{DS,n}(t) < V_{GS,n}(t) - V_{TN}$ and in the saturation region if $V_{DS,n}(t) \\ge V_{GS,n}(t) - V_{TN}$. The current equations for these regions are provided in the problem statement.\n\nFor the p-channel transistor (pull-up):\nThe source-gate voltage is $V_{SG,p}(t) = V_{DD} - v_{\\text{in}}(t)$ and the source-drain voltage is $V_{SD,p}(t) = V_{DD} - v_{\\text{out}}(t)$. The transistor is in cutoff ($i_p(t) = 0$) if $V_{SG,p}(t) \\le |V_{TP}|$. Otherwise, it is in the linear region if $V_{SD,p}(t) < V_{SG,p}(t) - |V_{TP}|$ and in saturation if $V_{SD,p}(t) \\ge V_{SG,p}(t) - |V_{TP}|$.\n\nThe input voltage $v_{\\text{in}}(t)$ is a linear ramp falling from $V_{DD}$ to $0$ over a duration $t_{\\text{slew}}$:\n$$\nv_{\\text{in}}(t) = V_{DD} \\max\\left( 1 - \\frac{t}{t_{\\text{slew}}}, 0 \\right)\n$$\nGiven these definitions, the KCL equation becomes a first-order, nonlinear ordinary differential equation (ODE) for $v_{\\text{out}}(t)$:\n$$\n\\frac{d v_{\\text{out}}(t)}{dt} = \\frac{1}{C_L} \\left( i_p\\left(v_{\\text{in}}(t), v_{\\text{out}}(t)\\right) - i_n\\left(v_{\\text{in}}(t), v_{\\text{out}}(t)\\right) \\right)\n$$\nThis ODE is solved numerically using an appropriate solver, such as the `solve_ivp` function from the SciPy library. The simulation is run over a time interval sufficient for the output to settle to its final high state (close to $V_{DD}$). This yields the output voltage waveform $v_{\\text{out}}(t)$.\n\nOnce the functions $v_{\\text{in}}(t)$ and $v_{\\text{out}}(t)$ are known over the simulation time grid, the time-dependent currents $i_p(t)$ and $i_n(t)$ can be computed at each time step. From these, the required energy components are calculated via numerical integration (e.g., using the trapezoidal rule).\n\n1.  **Total Energy from Supply ($E_{\\text{total}}$)**: The supply voltage $v_{VDD}(t)$ is a constant $V_{DD}$, and the supply current is $i_{VDD}(t) = i_p(t)$. The total energy is the time integral of the instantaneous power $p(t) = v_{VDD}(t) i_{VDD}(t)$.\n    $$\n    E_{\\text{total}} = \\int_0^{t_{\\text{final}}} V_{DD} i_p(t) \\, dt = V_{DD} \\int_0^{t_{\\text{final}}} i_p(t) \\, dt\n    $$\n\n2.  **Capacitive Charging Energy ($E_{\\text{cap}}$)**: The problem defines this as the portion of the supply energy that contributes to charging the capacitor when its current is positive. The capacitor current is $i_C(t) = C_L \\frac{d v_{\\text{out}}(t)}{dt} = i_p(t) - i_n(t)$.\n    $$\n    E_{\\text{cap}} = \\int_0^{t_{\\text{final}}} u(t) i_C(t) v_{VDD}(t) \\, dt = V_{DD} \\int_0^{t_{\\text{final}}} \\max(i_p(t) - i_n(t), 0) \\, dt\n    $$\n    where $u(t)$ is a unit step function that is $1$ when $i_C(t) \\ge 0$ and $0$ otherwise. This integral isolates the energy drawn from the supply that results in a rising output voltage.\n\n3.  **Short-Circuit Energy ($E_{\\text{sc}}$)**: This is the remaining energy, which is dissipated as heat due to the current flowing directly from the supply through both transistors to ground when they are simultaneously conducting.\n    $$\n    E_{\\text{sc}} = E_{\\text{total}} - E_{\\text{cap}}\n    $$\nThe algorithm proceeds by iterating through each test case, setting the parameters, solving the ODE for $v_{\\text{out}}(t)$, calculating the time-series for the currents, performing the numerical integrations to find $E_{\\text{total}}$ and $E_{\\text{cap}}$, and finally computing their difference to obtain $E_{\\text{sc}}$. The final results are presented in joules.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Computes the short-circuit energy dissipation in a CMOS inverter for several test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (fast input)\n        {\"VDD\": 1.0, \"CL\": 30e-15, \"tslew\": 10e-12, \"kn\": 200e-6, \"kp\": 120e-6, \"VTN\": 0.35, \"VTP_mag\": 0.35, \"lam\": 0.05},\n        # Case 2 (moderate input)\n        {\"VDD\": 1.0, \"CL\": 30e-15, \"tslew\": 50e-12, \"kn\": 200e-6, \"kp\": 120e-6, \"VTN\": 0.35, \"VTP_mag\": 0.35, \"lam\": 0.05},\n        # Case 3 (slow input)\n        {\"VDD\": 1.0, \"CL\": 30e-15, \"tslew\": 200e-12, \"kn\": 200e-6, \"kp\": 120e-6, \"VTN\": 0.35, \"VTP_mag\": 0.35, \"lam\": 0.05},\n        # Case 4 (very slow input)\n        {\"VDD\": 1.0, \"CL\": 30e-15, \"tslew\": 1.0e-9, \"kn\": 200e-6, \"kp\": 120e-6, \"VTN\": 0.35, \"VTP_mag\": 0.35, \"lam\": 0.05},\n        # Case 5 (heavier load)\n        {\"VDD\": 1.0, \"CL\": 100e-15, \"tslew\": 50e-12, \"kn\": 200e-6, \"kp\": 120e-6, \"VTN\": 0.35, \"VTP_mag\": 0.35, \"lam\": 0.05},\n    ]\n\n    results = []\n\n    t_sim_end = 4.0e-9\n    num_points = 4001\n    t_eval = np.linspace(0, t_sim_end, num_points)\n\n    for params in test_cases:\n        VDD, CL, tslew, kn, kp, VTN, VTP_mag, lam = (\n            params[\"VDD\"], params[\"CL\"], params[\"tslew\"], params[\"kn\"],\n            params[\"kp\"], params[\"VTN\"], params[\"VTP_mag\"], params[\"lam\"]\n        )\n\n        def get_in(v_in, v_out):\n            Vgs_n = v_in\n            Vds_n = v_out\n            if Vgs_n <= VTN:\n                return 0.0\n            \n            Vds_n = max(Vds_n, 0.0)\n            Vov_n = Vgs_n - VTN\n            if Vds_n < Vov_n:  # Linear\n                i_n = kn * (Vov_n * Vds_n - 0.5 * Vds_n**2) * (1 + lam * Vds_n)\n            else:  # Saturation\n                i_n = 0.5 * kn * Vov_n**2 * (1 + lam * Vds_n)\n            return i_n\n\n        def get_ip(v_in, v_out):\n            Vsg_p = VDD - v_in\n            Vsd_p = VDD - v_out\n            if Vsg_p <= VTP_mag:\n                return 0.0\n\n            Vsd_p = max(Vsd_p, 0.0)\n            Vov_p = Vsg_p - VTP_mag\n            if Vsd_p < Vov_p:  # Linear\n                i_p = kp * (Vov_p * Vsd_p - 0.5 * Vsd_p**2) * (1 + lam * Vsd_p)\n            else:  # Saturation\n                i_p = 0.5 * kp * Vov_p**2 * (1 + lam * Vsd_p)\n            return i_p\n\n        def get_vin_scalar(t):\n            return VDD * max(1 - t / tslew, 0.0) if t <= tslew else 0.0\n\n        def model(t, y):\n            v_out = y[0]\n            v_in = get_vin_scalar(t)\n            v_out_clipped = np.clip(v_out, 0, VDD)\n            ip = get_ip(v_in, v_out_clipped)\n            in_ = get_in(v_in, v_out_clipped)\n            dv_out_dt = (ip - in_) / CL\n            return [dv_out_dt]\n\n        v_out_initial = [0.0]\n        t_span = (0, t_sim_end)\n\n        sol = solve_ivp(\n            fun=model,\n            t_span=t_span,\n            y0=v_out_initial,\n            method='RK45',\n            t_eval=t_eval,\n            atol=1e-12,\n            rtol=1e-9\n        )\n\n        t_points = sol.t\n        v_out_points = sol.y[0]\n\n        v_in_points = VDD * np.maximum(1 - t_points / tslew, 0)\n        \n        ip_points = np.zeros_like(t_points)\n        in_points = np.zeros_like(t_points)\n        v_out_clipped_points = np.clip(v_out_points, 0, VDD)\n\n        for i in range(len(t_points)):\n            ip_points[i] = get_ip(v_in_points[i], v_out_clipped_points[i])\n            in_points[i] = get_in(v_in_points[i], v_out_clipped_points[i])\n            \n        E_total = VDD * np.trapz(ip_points, t_points)\n\n        i_C_points = ip_points - in_points\n        i_C_charging_points = np.maximum(i_C_points, 0)\n        E_cap = VDD * np.trapz(i_C_charging_points, t_points)\n        \n        E_sc = E_total - E_cap\n        results.append(E_sc)\n\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Analyzing a single gate is crucial, but real-world power estimation must account for the complexity of an entire synthesized design. Full transient simulation of millions of gates is computationally prohibitive, necessitating the more abstract and efficient methods used by Electronic Design Automation (EDA) tools. This practice elevates our analysis to the netlist level, where you will develop an algorithm to compute total dynamic power from extracted parasitic capacitances and statistical switching data . You will learn to calculate the effective capacitance, $C_{eff}$, for each net by considering not only its capacitance to ground but also the intricate effects of crosstalk from neighboring nets, a phenomenon modeled by the Miller effect, providing a realistic glimpse into modern power analysis methodologies.",
            "id": "4267551",
            "problem": "You are given an abstracted view of a synthesized Complementary Metal-Oxide-Semiconductor (CMOS) digital design. The design is represented at the net level with parasitic capacitances from an Electronic Design Automation (EDA) extraction and input pin capacitances from cell models. Your task is to construct an algorithm to compute the effective capacitive load per net and thereby the total dynamic power under specified switching factors and alignment parameters. The required output is a single line containing the total dynamic power per scenario.\n\nFundamental base to be used for derivation: energy stored in a capacitor and the definition of power as energy per unit time. Avoid using shortcut or target formulas in the problem statement. The scenario must be framed and solved from first principles grounded in these fundamentals.\n\nInputs and data representation:\n- A set of nets $\\mathcal{N} = \\{N_0, N_1, N_2\\}$.\n- For each net $N_i$, a wire ground capacitance $C_{g,i}$ (in farads) and a list of cell input pin capacitances attached as loads, $\\{C_{pin,i,k}\\}$ (in farads).\n- For each unordered pair of coupled nets $(N_i, N_j)$ with $i \\ne j$, a coupling capacitance $C_{c,ij}$ (in farads).\n- For each net $N_i$, a switching factor $\\alpha_i$ (dimensionless decimal per cycle) that represents the expected number of $0 \\rightarrow 1$ transitions per clock cycle on that net, and is constrained to $0 \\le \\alpha_i \\le 1$.\n- For each unordered pair $(N_i, N_j)$, an aggressor-victim directional alignment coefficient $\\delta_{ij}$ with $-1 \\le \\delta_{ij} \\le 1$, where $\\delta_{ij} = 1$ means strongly same-direction simultaneous switching, $\\delta_{ij} = -1$ means strongly opposite-direction simultaneous switching, and $\\delta_{ij} = 0$ means uncorrelated directions. This coefficient is used to bias the expected coupling contribution during switching in a physically justifiable way based on the relative direction of transitions.\n- A supply voltage $V_{dd}$ (in volts) and a clock frequency $f$ (in hertz).\n\nHigh-level algorithmic requirements without shortcut formulas:\n1. Starting from the definition of energy in a capacitor and physical reasoning about charge and potential difference, derive how to aggregate ground capacitances, pin capacitances, and coupling capacitances into an effective load $C_{eff,i}$ that the driver of net $N_i$ must charge and discharge under switching.\n2. Show how the coupling contribution per neighbor depends on the statistical alignment of transitions between the nets as encoded by $\\alpha_j$ and $\\delta_{ij}$, resulting in an expected effective contribution for $C_{c,ij}$ to $C_{eff,i}$.\n3. Using the energy-per-transition and transitions-per-second derived from the switching factor and clock frequency, obtain the total dynamic power across all nets.\n\nUnits and output specification:\n- All capacitances are given in farads, which may be conveniently expressed in femtofarads for readability within the data specification.\n- Supply voltage $V_{dd}$ is in volts.\n- Clock frequency $f$ is in hertz.\n- The final answer must be expressed in watts as floating-point numbers. No rounding requirement is imposed, but the values must be numerically exact according to standard double-precision floating-point arithmetic.\n- Angles and trigonometric functions are not used in this problem.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\\texttt{[r_1,r_2,r_3]}$ where each $r_k$ is the total dynamic power for test case $k$ in watts.\n\nDesign data (fixed across all scenarios):\n- Nets and ground capacitances:\n  - $N_0$: $C_{g,0} = 120 \\times 10^{-15}$.\n  - $N_1$: $C_{g,1} = 80 \\times 10^{-15}$.\n  - $N_2$: $C_{g,2} = 150 \\times 10^{-15}$.\n- Cell input pin capacitances attached to each net:\n  - $N_0$: $\\{3 \\times 10^{-15}, 2 \\times 10^{-15}\\}$.\n  - $N_1$: $\\{4 \\times 10^{-15}\\}$.\n  - $N_2$: $\\{2 \\times 10^{-15}, 2 \\times 10^{-15}, 3 \\times 10^{-15}\\}$.\n- Coupling capacitances between nets (unordered pairs):\n  - $(N_0, N_1)$: $C_{c,01} = 30 \\times 10^{-15}$.\n  - $(N_0, N_2)$: $C_{c,02} = 20 \\times 10^{-15}$.\n  - $(N_1, N_2)$: $C_{c,12} = 25 \\times 10^{-15}$.\n\nTest suite:\n- Scenario $1$ (happy path):\n  - Supply and clock: $V_{dd} = 0.9$, $f = 5.0 \\times 10^{8}$.\n  - Switching factors: $\\alpha_0 = 0.2$, $\\alpha_1 = 0.35$, $\\alpha_2 = 0.1$.\n  - Alignment coefficients: $\\delta_{01} = -0.6$, $\\delta_{02} = 0.2$, $\\delta_{12} = 0.0$.\n- Scenario $2$ (edge: one net does not switch):\n  - Supply and clock: $V_{dd} = 1.0$, $f = 2.0 \\times 10^{8}$.\n  - Switching factors: $\\alpha_0 = 0.4$, $\\alpha_1 = 0.15$, $\\alpha_2 = 0.0$.\n  - Alignment coefficients: $\\delta_{01} = 1.0$, $\\delta_{02} = -1.0$, $\\delta_{12} = -1.0$.\n- Scenario $3$ (boundary: zero frequency):\n  - Supply and clock: $V_{dd} = 0.8$, $f = 0.0$.\n  - Switching factors: $\\alpha_0 = 0.5$, $\\alpha_1 = 0.5$, $\\alpha_2 = 0.5$.\n  - Alignment coefficients: $\\delta_{01} = 0.0$, $\\delta_{02} = 0.0$, $\\delta_{12} = 0.0$.\n- Scenario $4$ (boundary: maximal opposite-direction alignment with full-rate switching):\n  - Supply and clock: $V_{dd} = 1.1$, $f = 3.0 \\times 10^{8}$.\n  - Switching factors: $\\alpha_0 = 1.0$, $\\alpha_1 = 1.0$, $\\alpha_2 = 1.0$.\n  - Alignment coefficients: $\\delta_{01} = -1.0$, $\\delta_{02} = -1.0$, $\\delta_{12} = -1.0$.\n\nProgram requirements:\n- Implement an algorithm that, for each scenario, aggregates the effective capacitance $C_{eff,i}$ per net $N_i$ using the ground capacitance, the sum of the pin capacitances driven by $N_i$, and an expected coupling contribution per neighbor derived from $\\alpha_j$ and $\\delta_{ij}$.\n- Compute the total dynamic power across all nets in watts from the physically derived energy and event-rate relationships.\n- Produce a single line of output containing the totals for scenarios $1$ through $4$, ordered as listed, formatted as $\\texttt{[r_1,r_2,r_3,r_4]}$ with no spaces.",
            "solution": "The problem is valid. It is scientifically grounded in the principles of electrical engineering, specifically relating to power consumption in CMOS digital circuits. It is well-posed, with sufficient information to derive a unique solution. The parameters and their values are physically realistic.\n\nThe solution proceeds by first deriving the formula for total dynamic power from fundamental principles as requested, and then applying this formula to the provided test scenarios.\n\n### Step 1: Derivation of Dynamic Power from First Principles\n\nThe dynamic power consumed by a CMOS digital circuit is the power dissipated during the charging and discharging of the parasitic capacitances of the nets. We derive the expression for this power starting from the energy of a capacitor.\n\nThe energy $E$ stored in a capacitor with capacitance $C$ charged to a voltage difference $V$ across its plates is given by:\n$$E = \\frac{1}{2} C V^2$$\n\nIn a standard rail-to-rail CMOS logic circuit, a net's voltage $V_{net}$ switches between ground ($0$) and the supply voltage ($V_{dd}$). Consider a single net $N_i$ with a total effective capacitance $C_{eff,i}$ that its driver must charge or discharge.\n\nDuring a $0 \\to V_{dd}$ transition (charging), the driver's pull-up network connects the net to the supply $V_{dd}$. A total charge $Q_i = C_{eff,i} V_{dd}$ is drawn from the supply. The energy drawn from the supply is:\n$$E_{supply,i} = Q_i V_{dd} = (C_{eff,i} V_{dd}) V_{dd} = C_{eff,i} V_{dd}^2$$\nOf this energy, half is stored in the capacitor ($\\frac{1}{2} C_{eff,i} V_{dd}^2$) and the other half is dissipated as heat in the resistive components of the pull-up network.\n\nDuring a subsequent $V_{dd} \\to 0$ transition (discharging), the driver's pull-down network connects the net to ground. The energy stored in the capacitor, $\\frac{1}{2} C_{eff,i} V_{dd}^2$, is dissipated as heat in the pull-down network. The power supply is disconnected during this phase and provides no energy.\n\nThus, for one complete charge-discharge cycle ($0 \\to V_{dd} \\to 0$), the total energy drawn from the supply is $C_{eff,i} V_{dd}^2$.\n\nPower is defined as energy per unit time ($P = dE/dt$). The average dynamic power is the total energy consumed per unit time. The problem defines the switching factor $\\alpha_i$ as the average number of $0 \\to 1$ transitions on net $N_i$ per clock cycle. Given a clock frequency $f$ (in cycles per second, or hertz), the rate of charging events for net $N_i$ is $\\alpha_i f$.\n\nThe dynamic power $P_{dyn,i}$ for net $N_i$ is the energy per charging event multiplied by the rate of these events:\n$$P_{dyn,i} = E_{supply,i} \\times (\\alpha_i f) = (C_{eff,i} V_{dd}^2) (\\alpha_i f) = \\alpha_i f C_{eff,i} V_{dd}^2$$\n\nThe total dynamic power for the system is the sum of the power consumed by all nets:\n$$P_{dyn,total} = \\sum_{i \\in \\mathcal{N}} P_{dyn,i} = \\sum_{i \\in \\mathcal{N}} \\alpha_i f C_{eff,i} V_{dd}^2 = f V_{dd}^2 \\sum_{i \\in \\mathcal{N}} \\alpha_i C_{eff,i}$$\n\n### Step 2: Derivation of Effective Capacitance ($C_{eff,i}$)\n\nThe effective capacitance $C_{eff,i}$ is the total capacitance that the driver of net $N_i$ must charge during a $0 \\to V_{dd}$ transition. It is the sum of contributions from grounded capacitances and coupling capacitances.\n\n1.  **Grounded Capacitances**: These include the wire's capacitance to ground $C_{g,i}$ and the input pin capacitances $\\{C_{pin,i,k}\\}$ of the cells driven by net $N_i$. These are all connected between the net and ground (or a stable reference). Their contribution is a simple sum:\n    $$C_{gnd,i} = C_{g,i} + \\sum_k C_{pin,i,k}$$\n\n2.  **Coupling Capacitances**: A coupling capacitor $C_{c,ij}$ connects net $N_i$ (the victim) to a neighboring net $N_j$ (the aggressor). The charge required from the driver of $N_i$ to charge $C_{c,ij}$ depends on the simultaneous voltage change on net $N_j$. The change in charge $\\Delta Q_{ij}$ that the driver of $N_i$ must supply to the capacitor plate connected to it is given by:\n    $$\\Delta Q_{ij} = C_{c,ij} \\Delta(V_i - V_j) = C_{c,ij} (\\Delta V_i - \\Delta V_j)$$\n    For a $0 \\to V_{dd}$ transition on net $N_i$, $\\Delta V_i = V_{dd}$. The equation becomes:\n    $$\\Delta Q_{ij} = C_{c,ij} (V_{dd} - \\Delta V_j)$$\n    Here, $\\Delta V_j$ is the voltage swing on net $N_j$ during the transition of $N_i$. As transitions are statistical, we must consider the expected value of $\\Delta V_j$, conditioned on net $N_i$ transitioning up: $E[\\Delta V_j | i \\uparrow]$.\n    The expected charge is $E[\\Delta Q_{ij}] = C_{c,ij} (V_{dd} - E[\\Delta V_j | i \\uparrow])$.\n\n    The problem provides parameters $\\alpha_j$ (activity factor of aggressor $N_j$) and $\\delta_{ij}$ (directional alignment) to model this effect. We can define an effective Miller factor $k_{ij} = E[\\Delta V_j | i \\uparrow] / V_{dd}$. A simple, physically justifiable linear model for this factor, consistent with the definition of the parameters, is:\n    $$k_{ij} = \\delta_{ij} \\alpha_j$$\n    This model correctly reflects that the effect is proportional to the aggressor's activity ($\\alpha_j$) and is biased by the directional correlation ($\\delta_{ij}$). For example, if $N_j$ is static ($\\alpha_j=0$), $k_{ij}=0$. If switching is uncorrelated ($\\delta_{ij}=0$), $k_{ij}=0$. For fully anti-correlated switching ($\\delta_{ij}=-1$) with full-rate activity ($\\alpha_j=1$), $k_{ij}=-1$, maximizing the charge requirement.\n\n    The expected charge can now be written in terms of an effective capacitance contribution. The charge is $C_{c,ij}(1 - k_{ij})V_{dd}$, so the effective capacitance contribution from $C_{c,ij}$ is $C_{c,ij}(1 - k_{ij})$.\n    $$C_{c,ij,eff} = C_{c,ij} (1 - \\delta_{ij}\\alpha_j)$$\n    Note that when calculating $C_{eff,i}$, the neighbor is $N_j$, so we use $\\alpha_j$ and $\\delta_{ij}$. The problem statement gives $\\delta_{ij}$ for an unordered pair, which implies $\\delta_{ij} = \\delta_{ji}$.\n\n3.  **Total Effective Capacitance**: Summing the grounded and effective coupling contributions, we get the total effective capacitance for net $N_i$:\n    $$C_{eff,i} = \\left(C_{g,i} + \\sum_k C_{pin,i,k}\\right) + \\sum_{j \\ne i, j \\in \\mathcal{N}} C_{c,ij} (1 - \\delta_{ij}\\alpha_j)$$\n\n### Final Formula for Total Dynamic Power\n\nBy substituting the expression for $C_{eff,i}$ into the power formula, we arrive at the complete equation for total dynamic power:\n$$P_{dyn,total} = f V_{dd}^2 \\sum_{i \\in \\mathcal{N}} \\alpha_i \\left[ \\left(C_{g,i} + \\sum_k C_{pin,i,k}\\right) + \\sum_{j \\ne i, j \\in \\mathcal{N}} C_{c,ij} (1 - \\delta_{ij}\\alpha_j) \\right]$$\n\nThis formula will be implemented to solve for the total dynamic power in each of the given test scenarios.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used from scipy or other external packages.\n\ndef solve():\n    \"\"\"\n    Computes the total dynamic power for a CMOS digital design across multiple scenarios.\n    \"\"\"\n    \n    # Design data (fixed across all scenarios)\n    # All capacitances are in Farads (F).\n    C_g = {\n        0: 120e-15,  # C_g,0 for Net N_0\n        1: 80e-15,   # C_g,1 for Net N_1\n        2: 150e-15,  # C_g,2 for Net N_2\n    }\n    \n    C_pin = {\n        0: [3e-15, 2e-15],        # Pin loads on Net N_0\n        1: [4e-15],               # Pin loads on Net N_1\n        2: [2e-15, 2e-15, 3e-15], # Pin loads on Net N_2\n    }\n    \n    # Sum of pin capacitances per net for convenience\n    C_pin_sum = {net: sum(caps) for net, caps in C_pin.items()}\n    \n    C_c = {\n        (0, 1): 30e-15, # Coupling between N_0 and N_1\n        (0, 2): 20e-15, # Coupling between N_0 and N_2\n        (1, 2): 25e-15, # Coupling between N_1 and N_2\n    }\n    # Symmetrize the coupling capacitance matrix for easier lookup\n    C_c.update({(j, i): val for (i, j), val in C_c.items()})\n\n    nets = [0, 1, 2]\n    \n    # Test suite with multiple scenarios\n    test_cases = [\n        { # Scenario 1\n            \"V_dd\": 0.9,\n            \"f\": 5.0e8,\n            \"alpha\": {0: 0.2, 1: 0.35, 2: 0.1},\n            \"delta\": {(0, 1): -0.6, (0, 2): 0.2, (1, 2): 0.0},\n        },\n        { # Scenario 2\n            \"V_dd\": 1.0,\n            \"f\": 2.0e8,\n            \"alpha\": {0: 0.4, 1: 0.15, 2: 0.0},\n            \"delta\": {(0, 1): 1.0, (0, 2): -1.0, (1, 2): -1.0},\n        },\n        { # Scenario 3\n            \"V_dd\": 0.8,\n            \"f\": 0.0,\n            \"alpha\": {0: 0.5, 1: 0.5, 2: 0.5},\n            \"delta\": {(0, 1): 0.0, (0, 2): 0.0, (1, 2): 0.0},\n        },\n        { # Scenario 4\n            \"V_dd\": 1.1,\n            \"f\": 3.0e8,\n            \"alpha\": {0: 1.0, 1: 1.0, 2: 1.0},\n            \"delta\": {(0, 1): -1.0, (0, 2): -1.0, (1, 2): -1.0},\n        },\n    ]\n\n    total_power_results = []\n\n    for case in test_cases:\n        V_dd = case[\"V_dd\"]\n        f = case[\"f\"]\n        alpha = case[\"alpha\"]\n        delta = case[\"delta\"]\n        # Symmetrize delta for easier lookup\n        delta.update({(j, i): val for (i, j), val in delta.items()})\n\n        total_power = 0.0\n\n        if f == 0.0:\n            total_power_results.append(0.0)\n            continue\n        \n        # Calculate power contribution from each net\n        for i in nets:\n            # Power on net i is zero if it doesn't switch\n            if alpha[i] == 0.0:\n                continue\n\n            # 1. Sum of grounded capacitances\n            C_grounded_i = C_g[i] + C_pin_sum[i]\n\n            # 2. Sum of effective coupling capacitances\n            C_coupling_eff_i = 0.0\n            for j in nets:\n                if i == j:\n                    continue\n                \n                # Miller factor k_ij = delta_ij * alpha_j\n                # Effective coupling cap = C_c,ij * (1 - k_ij)\n                k_ij = delta[(i, j)] * alpha[j]\n                C_coupling_eff_i += C_c[(i, j)] * (1.0 - k_ij)\n            \n            # 3. Total effective capacitance for net i\n            C_eff_i = C_grounded_i + C_coupling_eff_i\n\n            # 4. Dynamic power for net i\n            P_dyn_i = alpha[i] * f * C_eff_i * (V_dd ** 2)\n            \n            total_power += P_dyn_i\n            \n        total_power_results.append(total_power)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, total_power_results))}]\")\n\nsolve()\n```"
        }
    ]
}