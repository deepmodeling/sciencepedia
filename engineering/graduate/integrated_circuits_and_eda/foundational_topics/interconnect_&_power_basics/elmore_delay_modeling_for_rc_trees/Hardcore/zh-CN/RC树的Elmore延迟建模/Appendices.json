{
    "hands_on_practices": [
        {
            "introduction": "理论的基石在于深刻理解其物理本质。本练习将引导我们从第一性原理出发，推导一个简单但具有代表性的分支RC树的Elmore延迟。通过运用电荷守恒和基尔霍夫定律等基本概念，我们将揭示Elmore延迟模型背后直观的物理图像——即下游电容充电过程如何通过共享的电阻路径累积延迟。这项实践不仅旨在计算一个数值，更重要的是建立起对延迟来源的深刻洞察力。",
            "id": "4269384",
            "problem": "一个单输入阻容树由一个幅值为 $V_{\\text{DD}}$ 且源电阻为零的理想电压阶跃源驱动。该源通过一个串联电阻 $R_{0}$ 连接到内部节点 $0$。从节点 $0$ 分出两个支路：一个支路通过电阻 $R_{a}$ 连接到叶节点 $a$，另一个支路通过电阻 $R_{b}$ 连接到叶节点 $b$。每个节点 $i \\in \\{0,a,b\\}$ 都有一个到地的集总电容 $C_{i}$。不存在其他到地的电阻，没有耦合电容，并且所有互连电容都集总到 $C_{0}$、$C_{a}$ 和 $C_{b}$ 中。假设电路具有线性时不变行为，且电阻器构成的图是一个树形结构。仅使用基尔霍夫定律、电荷守恒原理以及线性阻容树冲激响应一阶矩的定义，从第一性原理推导到叶节点 $a$ 的Elmore延迟表达式，然后使用以下参数值进行计算：$R_{0}=50\\,\\Omega$，$R_{a}=100\\,\\Omega$，$R_{b}=200\\,\\Omega$，$C_{0}=5\\,\\text{fF}$，$C_{a}=15\\,\\text{fF}$，以及 $C_{b}=25\\,\\text{fF}$。将节点 $a$ 的最终延迟以皮秒为单位表示，并将结果四舍五入到三位有效数字。",
            "solution": "本题要求从第一性原理推导到叶节点 $a$ 的Elmore延迟，然后进行数值计算。推导过程必须基于基尔霍夫定律、电荷守恒原理以及冲激响应一阶矩的定义。\n\n首先，我们来定义Elmore延迟。对于一个线性时不变（LTI）系统，输出节点 $i$ 的延迟可以用该节点冲激响应 $h_i(t)$ 的一阶矩来表征。Elmore延迟 $\\tau_{Di}$ 定义为：\n$$ \\tau_{Di} = \\int_{0}^{\\infty} t h_i(t) dt $$\n其中冲激响应是归一化的，使其在所有时间上的积分为1，即 $\\int_{0}^{\\infty} h_i(t) dt = 1$。\n\n题目描述了一个幅值为 $V_{\\text{DD}}$ 的电压阶跃输入。设 $v_i(t)$ 是节点 $i$ 对该阶跃输入 $v_{\\text{in}}(t) = V_{\\text{DD}} u(t)$ 的电压响应，其中 $u(t)$ 是亥维赛阶跃函数。对于一个LTI系统，冲激响应是阶跃响应对时间的导数，并按输入阶跃的幅值进行缩放。对于我们的电路（一个RC树），任意节点 $i$ 的最终稳态电压为 $V_{\\text{DD}}$。因此，归一化的冲激响应为 $h_i(t) = \\frac{1}{V_{\\text{DD}}} \\frac{d v_i(t)}{dt}$。\n\n将此代入节点 $a$ 的Elmore延迟定义中：\n$$ \\tau_{Da} = \\int_{0}^{\\infty} t \\left( \\frac{1}{V_{\\text{DD}}} \\frac{d v_a(t)}{dt} \\right) dt = \\frac{1}{V_{\\text{DD}}} \\int_{0}^{\\infty} t \\frac{d v_a(t)}{dt} dt $$\n我们可以使用分部积分法 $\\int u \\, dv = uv - \\int v \\, du$ 来计算该积分。令 $u=t$ 且 $dv = \\frac{d v_a(t)}{dt} dt$。则 $du=dt$ 且 $v=v_a(t)$。\n$$ \\int_{0}^{\\infty} t \\frac{d v_a(t)}{dt} dt = \\left[ t v_a(t) \\right]_{0}^{\\infty} - \\int_{0}^{\\infty} v_a(t) dt $$\n边界项 $\\left[ t v_a(t) \\right]_{0}^{\\infty}$ 需要仔细计算。在 $t=0$ 时，该项为 $0$。当 $t \\rightarrow \\infty$ 时，$v_a(t)$ 趋近其稳态值 $V_{\\text{DD}}$。一个稳定RC电路的瞬态响应呈指数衰减，因此我们可以写成 $v_a(t) = V_{\\text{DD}} - f(t)$，其中 $f(t)$ 包含诸如 $e^{-t/\\tau_{\\text{pole}}}$ 的项，这些项比 $1/t$更快地趋近于零。因此，$\\lim_{t\\to\\infty} t(V_{\\text{DD}} - v_a(t)) = 0$。\n可以建立如下积分恒等式：\n$$ \\int_{0}^{\\infty} (V_{\\text{DD}} - v_a(t)) dt = \\int_{0}^{\\infty} t \\frac{d v_a(t)}{dt} dt $$\n此公式将冲激响应的一阶矩与阶跃响应曲线与稳态值之间的面积联系起来。因此，Elmore延迟可以表示为：\n$$ \\tau_{Da} = \\frac{1}{V_{\\text{DD}}} \\int_{0}^{\\infty} (V_{\\text{DD}} - v_a(t)) dt $$\n现在，我们应用基尔霍夫电压定律（KVL）。电压差 $V_{\\text{DD}} - v_a(t)$ 是从输入源到节点 $a$ 的唯一电阻路径上的总电压降。电路拓扑如下：源 $\\rightarrow R_0 \\rightarrow$ 节点 $0 \\rightarrow R_a \\rightarrow$ 节点 $a$。\n设 $I_{R0}(t)$ 是流过 $R_0$ 的电流（从源到节点 $0$），$I_{Ra}(t)$ 是流过 $R_a$ 的电流（从节点 $0$ 到节点 $a$）。电压降由欧姆定律给出。\n对于 $t>0$，$v_{\\text{in}}(t) = V_{\\text{DD}}$。\n$$ V_{\\text{DD}} - v_a(t) = (V_{\\text{DD}} - v_0(t)) + (v_0(t) - v_a(t)) = I_{R0}(t)R_0 + I_{Ra}(t)R_a $$\n将此代入 $\\tau_{Da}$ 的积分表达式中：\n$$ \\tau_{Da} = \\frac{1}{V_{\\text{DD}}} \\int_{0}^{\\infty} \\left( I_{R0}(t)R_0 + I_{Ra}(t)R_a \\right) dt $$\n$$ \\tau_{Da} = \\frac{1}{V_{\\text{DD}}} \\left( R_0 \\int_{0}^{\\infty} I_{R0}(t) dt + R_a \\int_{0}^{\\infty} I_{Ra}(t) dt \\right) $$\n接下来，我们应用电荷守恒原理。电流对时间的积分 $\\int_{0}^{\\infty} I(t) dt$ 代表流过的总电荷量 $Q$。这些电荷必须在电容器上累积，以将其电压从初始状态（$0$）改变到最终状态（$V_{\\text{DD}}$）。电容器上的电荷为 $Q = CV$。\n\n流过电阻 $R_0$ 的电流 $I_{R0}(t)$ 提供了为树中所有电容器（$C_0$、$C_a$ 和 $C_b$）充电所需的电荷。供应的总电荷为：\n$$ \\int_{0}^{\\infty} I_{R0}(t) dt = Q_{\\text{total}} = C_0 \\Delta V_0 + C_a \\Delta V_a + C_b \\Delta V_b $$\n因为 $\\Delta V_0 = \\Delta V_a = \\Delta V_b = V_{\\text{DD}} - 0 = V_{\\text{DD}}$，我们有：\n$$ \\int_{0}^{\\infty} I_{R0}(t) dt = (C_0 + C_a + C_b) V_{\\text{DD}} $$\n流过电阻 $R_a$ 的电流 $I_{Ra}(t)$ 只为节点 $a$ 处的电容器提供电荷，因为它是一个叶节点。\n$$ \\int_{0}^{\\infty} I_{Ra}(t) dt = C_a \\Delta V_a = C_a V_{\\text{DD}} $$\n现在，我们将这些电荷表达式代回到 $\\tau_{Da}$ 的方程中：\n$$ \\tau_{Da} = \\frac{1}{V_{\\text{DD}}} \\left[ R_0 (C_0 + C_a + C_b) V_{\\text{DD}} + R_a (C_a V_{\\text{DD}}) \\right] $$\n$V_{\\text{DD}}$ 项相互抵消，得到节点 $a$ 的Elmore延迟的最终表达式：\n$$ \\tau_{Da} = R_0 (C_0 + C_a + C_b) + R_a C_a $$\n至此完成了从第一性原理的推导。\n\n现在，我们使用给定的参数值计算该表达式：\n$R_{0}=50\\,\\Omega$\n$R_{a}=100\\,\\Omega$\n$C_{0}=5\\,\\text{fF} = 5 \\times 10^{-15}\\,\\text{F}$\n$C_{a}=15\\,\\text{fF} = 15 \\times 10^{-15}\\,\\text{F}$\n$C_{b}=25\\,\\text{fF} = 25 \\times 10^{-15}\\,\\text{F}$\n\n将这些值代入推导出的公式中：\n$$ \\tau_{Da} = (50\\,\\Omega) (5 \\times 10^{-15}\\,\\text{F} + 15 \\times 10^{-15}\\,\\text{F} + 25 \\times 10^{-15}\\,\\text{F}) + (100\\,\\Omega) (15 \\times 10^{-15}\\,\\text{F}) $$\n$$ \\tau_{Da} = (50\\,\\Omega) (45 \\times 10^{-15}\\,\\text{F}) + (100\\,\\Omega) (15 \\times 10^{-15}\\,\\text{F}) $$\n欧姆和法拉的乘积单位是秒 ($\\Omega \\cdot \\text{F} = \\frac{V}{I} \\cdot \\frac{Q}{V} = \\frac{Q}{I} = \\frac{I \\cdot t}{I} = t$)。\n$$ \\tau_{Da} = (50 \\times 45 \\times 10^{-15})\\,\\text{s} + (100 \\times 15 \\times 10^{-15})\\,\\text{s} $$\n$$ \\tau_{Da} = (2250 \\times 10^{-15})\\,\\text{s} + (1500 \\times 10^{-15})\\,\\text{s} $$\n$$ \\tau_{Da} = 3750 \\times 10^{-15}\\,\\text{s} $$\n题目要求答案以皮秒（$1\\,\\text{ps} = 10^{-12}\\,\\text{s}$）为单位，并四舍五入到三位有效数字。\n$$ \\tau_{Da} = 3750 \\times 10^{-15}\\,\\text{s} = 3.750 \\times 10^{-12}\\,\\text{s} = 3.75\\,\\text{ps} $$\n结果 $3.75$ 已经是三位有效数字。",
            "answer": "$$\\boxed{3.75}$$"
        },
        {
            "introduction": "在电路设计中，仅仅预测延迟是不够的，更关键的是要理解如何优化它。本练习将我们的关注点从延迟计算转向延迟分析，引入了灵敏度的概念。通过推导Elmore延迟对特定电阻值的偏导数，我们将量化改变电路参数对时序性能的影响。这项实践是连接理论分析与实际时序优化的桥梁，其结果——延迟灵敏度等于下游电容之和——是许多自动时序优化算法的基础。",
            "id": "4269377",
            "problem": "在电子设计自动化（EDA）时序分析的背景下，考虑一个线性的、无源的、集总电阻-电容（RC）树，它将互连线建模为一个由零源电阻的理想电压源驱动的三段梯形网络。源位于节点 $0$。电阻 $R_{1}$ 连接节点 $0$ 和节点 $1$，电阻 $R_{2}$ 连接节点 $1$ 和节点 $2$，电阻 $R_{3}$ 连接节点 $2$ 和节点 $3$。在节点 $1$、$2$ 和 $3$ 处分别连接了到地的并联电容器，其值分别为 $C_{1}$、$C_{2}$ 和 $C_{3}$。一个额外的负载电容 $C_{L}$ 从节点 $3$ 连接到地。各元件的数值为 $R_{1}=100\\,\\Omega$，$R_{2}=150\\,\\Omega$，$R_{3}=50\\,\\Omega$，$C_{1}=10\\,\\text{fF}$，$C_{2}=40\\,\\text{fF}$，$C_{3}=20\\,\\text{fF}$，以及 $C_{L}=30\\,\\text{fF}$。\n\n该互连线由节点 $0$ 处的一个单位幅度的阶跃电压驱动。将到负载节点（节点 $3$）的Elmore延迟定义为在节点 $3$ 观测到的、相对于驱动源的冲激响应的一阶矩。从线性时不变RC网络冲激响应一阶矩的基本定义出发，仅利用网络的线性特性和RC树的特性（唯一路径、电荷守恒），推导出节点 $3$ 的Elmore延迟关于该树的电阻和电容的表达式，然后计算灵敏度 $\\partial t_{d}/\\partial R_{2}$。\n\n提供 $\\partial t_{d}/\\partial R_{2}$ 的最终数值，四舍五入到 $4$ 位有效数字，并以飞秒每欧姆 $\\left(\\text{fs}/\\Omega\\right)$ 为单位表示。",
            "solution": "互连线的结构是一个三段式RC梯形网络。源位于节点 $0$。电路元件如下：\n- 电阻 $R_1$ 在节点 $0$ 和节点 $1$ 之间。\n- 电阻 $R_2$ 在节点 $1$ 和节点 $2$ 之间。\n- 电阻 $R_3$ 在节点 $2$ 和节点 $3$ 之间。\n- 电容 $C_1$ 从节点 $1$ 到地。\n- 电容 $C_2$ 从节点 $2$ 到地。\n- 电容 $C_3$ 从节点 $3$ 到地。\n- 负载电容 $C_L$ 从节点 $3$ 到地。\n\n节点 $3$ 处的总电容为 $C_{3T} = C_3 + C_L$。电路在节点 $0$ 处由单位幅度的阶跃电压驱动，即 $v_0(t) = u(t)$，其中 $u(t)$ 是亥维赛阶跃函数。对于一个稳定的线性时不变（LTI）RC网络，任意节点 $k$ 的最终电压将是 $v_k(\\infty)=1$。\n\n节点 $k$ 的Elmore延迟 $t_{d_k}$ 定义为该节点处冲激响应 $h_k(t)$ 的一阶矩：\n$$t_{d_k} = \\int_0^\\infty t h_k(t) dt$$\n将冲激响应 $h_k(t)$ 与传递函数 $H_k(s) = V_k(s)/V_{in}(s)$ 联系起来的一个关键性质是，$h_k(t)$ 的各阶矩可以从 $H_k(s)$ 的麦克劳林级数展开中导出：\n$$H_k(s) = \\int_0^\\infty h_k(t) e^{-st} dt = \\int_0^\\infty h_k(t) \\left(1 - st + \\frac{s^2t^2}{2} - \\dots\\right) dt$$\n$$H_k(s) = m_0 - m_1 s + \\frac{m_2}{2}s^2 - \\dots$$\n其中 $m_n = \\int_0^\\infty t^n h_k(t) dt$。零阶矩 $m_0$ 是直流增益，对于这个低通RC网络，其值为 $1$，因此 $H_k(0) = 1$。一阶矩 $m_1$ 就是Elmore延迟 $t_{d_k}$。通过比较系数，我们发现：\n$$t_{d_k} = m_1 = - \\left. \\frac{d H_k(s)}{ds} \\right|_{s=0}$$\n这提供了一种从网络传递函数推导Elmore延迟表达式的方法，而传递函数本身是使用网络分析原理（线性）推导出来的。\n\n让我们在拉普拉斯域中写出节点分析方程。设 $V_k(s)$ 为节点 $k$ 处电压的拉普拉斯变换。输入为 $V_{in}(s) = \\mathcal{L}\\{u(t)\\} = 1/s$。传递函数为 $H_k(s) = V_k(s)/V_{in}(s) = sV_k(s)$。为简单起见，我们可以设 $V_{in}(s)=1$ 并求出 $V_k(s)$，它将等于 $H_k(s)$。\n节点方程为：\n1. 节点 $1$：$\\frac{V_1(s) - V_{in}(s)}{R_1} + sC_1 V_1(s) + \\frac{V_1(s) - V_2(s)}{R_2} = 0$\n2. 节点 $2$：$\\frac{V_2(s) - V_1(s)}{R_2} + sC_2 V_2(s) + \\frac{V_2(s) - V_3(s)}{R_3} = 0$\n3. 节点 $3$：$\\frac{V_3(s) - V_2(s)}{R_3} + s(C_3+C_L)V_3(s) = 0$\n\n设 $V_{in}(s)=1$，这些方程定义了传递函数 $H_k(s)=V_k(s)$。\n设 $C_{3T}=C_3+C_L$。\n1. $\\frac{H_1(s) - 1}{R_1} + sC_1 H_1(s) + \\frac{H_1(s) - H_2(s)}{R_2} = 0$\n2. $\\frac{H_2(s) - H_1(s)}{R_2} + sC_2 H_2(s) + \\frac{H_2(s) - H_3(s)}{R_3} = 0$\n3. $\\frac{H_3(s) - H_2(s)}{R_3} + sC_{3T} H_3(s) = 0$\n\n我们重新整理这些方程，用电流来表示电压降：\n1. $1 - H_1(s) = R_1 \\left( sC_1 H_1(s) + \\frac{H_1(s) - H_2(s)}{R_2} \\right) = R_1 \\left( sC_1 H_1(s) + sC_2 H_2(s) + sC_{3T} H_3(s) \\right)$\n2. $H_1(s) - H_2(s) = R_2 \\left( sC_2 H_2(s) + \\frac{H_2(s) - H_3(s)}{R_3} \\right) = R_2 \\left( sC_2 H_2(s) + sC_{3T} H_3(s) \\right)$\n3. $H_2(s) - H_3(s) = R_3 (sC_{3T} H_3(s))$\n\n现在我们对每个方程关于 $s$ 求导，然后在 $s=0$ 处求值。设 $H'_k = \\left. \\frac{d H_k(s)}{ds} \\right|_{s=0}$。我们使用乘法法则以及对于所有节点 $k=1,2,3$ 都有 $H_k(0) = 1$ 这一事实。\n\n对等式3求导：\n$$H'_2 - H'_3 = R_3 \\left( C_{3T} H_3(s) + sC_{3T} H'_3(s) \\right) \\bigg|_{s=0} = R_3 C_{3T} H_3(0) = R_3 C_{3T}$$\n对等式2求导：\n$$H'_1 - H'_2 = R_2 \\left( C_2 H_2(s) + sC_2 H'_2(s) + C_{3T} H_3(s) + sC_{3T} H'_3(s) \\right) \\bigg|_{s=0} = R_2 (C_2 H_2(0) + C_{3T} H_3(0)) = R_2(C_2+C_{3T})$$\n对等式1求导：\n$$-H'_1 = R_1 \\left( C_1 H_1(s) + sC_1 H'_1(s) + C_2 H_2(s) + sC_2 H'_2(s) + C_{3T} H_3(s) + sC_{3T} H'_3(s) \\right) \\bigg|_{s=0}$$\n$$-H'_1 = R_1(C_1 H_1(0) + C_2 H_2(0) + C_{3T} H_3(0)) = R_1(C_1+C_2+C_{3T})$$\n\n我们得到一个关于 $H'_1$、$H'_2$ 和 $H'_3$ 的线性方程组：\n(A) $-H'_1 = R_1(C_1+C_2+C_{3T})$\n(B) $H'_1 - H'_2 = R_2(C_2+C_{3T})$\n(C) $H'_2 - H'_3 = R_3 C_{3T}$\n\n节点 $3$ 的Elmore延迟为 $t_{d_3} = -H'_3$。我们可以通过将这三个方程相加来求得 $-H'_3$：\n$$(-H'_1) + (H'_1 - H'_2) + (H'_2 - H'_3) = R_1(C_1+C_2+C_{3T}) + R_2(C_2+C_{3T}) + R_3 C_{3T}$$\n$$-H'_3 = R_1(C_1+C_2+C_{3T}) + R_2(C_2+C_{3T}) + R_3 C_{3T}$$\n代入 $C_{3T} = C_3+C_L$，我们得到节点 $3$ Elmore延迟的表达式：\n$$t_{d_3} = R_1(C_1+C_2+C_3+C_L) + R_2(C_2+C_3+C_L) + R_3(C_3+C_L)$$\n这个公式对应着众所周知的路径电阻求和方法，即路径中每个电阻贡献的延迟分量等于其电阻值乘以其下游的总电容。\n\n接下来，我们计算延迟 $t_{d_3}$ 相对于电阻 $R_2$ 的灵敏度，即偏导数 $\\frac{\\partial t_{d_3}}{\\partial R_2}$。\n$$\\frac{\\partial t_{d_3}}{\\partial R_2} = \\frac{\\partial}{\\partial R_2} \\left[ R_1(C_1+C_2+C_3+C_L) + R_2(C_2+C_3+C_L) + R_3(C_3+C_L) \\right]$$\n涉及 $R_1$ 和 $R_3$ 的项在对 $R_2$ 求导时被视为常数。\n$$\\frac{\\partial t_{d_3}}{\\partial R_2} = 0 + \\frac{\\partial}{\\partial R_2} [R_2(C_2+C_3+C_L)] + 0$$\n$$\\frac{\\partial t_{d_3}}{\\partial R_2} = C_2+C_3+C_L$$\n灵敏度是电阻 $R_2$ 下游所有电容的总和（包括下一段“近端”节点的电容）。\n\n最后，我们代入给定的数值来求结果。\n$C_1 = 10\\,\\text{fF}$\n$C_2 = 40\\,\\text{fF}$\n$C_3 = 20\\,\\text{fF}$\n$C_L = 30\\,\\text{fF}$\n$$\\frac{\\partial t_{d_3}}{\\partial R_2} = 40\\,\\text{fF} + 20\\,\\text{fF} + 30\\,\\text{fF} = 90\\,\\text{fF}$$\n电容的单位法拉（F）等效于秒每欧姆（$\\text{s}/\\Omega$），因为时间常数 $\\tau=RC$ 的单位是秒。因此，$1\\,\\text{fF} = 1\\,\\text{fs}/\\Omega$。\n计算出的灵敏度是 $90\\,\\text{fs}/\\Omega$。题目要求答案四舍五入到 $4$ 位有效数字。\n$$90.00\\,\\text{fs}/\\Omega$$",
            "answer": "$$\\boxed{90.00}$$"
        },
        {
            "introduction": "当我们将目光从单个路径转向整个复杂的互连网络时，计算效率成为了核心挑战。现代集成电路包含数百万个节点的庞大RC树，逐点计算延迟是不可行的。本练习要求我们设计一个线性时间复杂度的算法，以高效地计算树中所有叶节点的Elmore延迟。这模拟了电子设计自动化（EDA）工具中时序分析引擎的核心任务，它将理论模型转化为能够处理真实世界规模问题的强大算法，完美体现了理论与工程实践的结合。",
            "id": "4269394",
            "problem": "在电子设计自动化（EDA）中，电阻-电容（RC）树用于模拟集成电路中的互连。该树以一个驱动节点为根，其边为电阻，节点为接地电容。对于在根部的单位阶跃激励，叶节点的阶跃响应可以通过 Elmore 延迟来近似，Elmore 延迟是相应线性时不变系统脉冲响应的一阶矩。从基尔霍夫电流定律（KCL）、基尔霍夫电压定律（KVL）和线性时不变性出发，Elmore 延迟可以推导为路径上各项贡献的累加，这些贡献结合了上游电阻和下游电容。目标是高效地计算到每个叶节点的 Elmore 延迟。\n\n设计一个基于单次深度优先搜索（DFS）的线性时间算法，计算所有叶节点的延迟 $t_{d}$。该算法必须遍历树一次，累加上游电阻信息和每条边的下游电容总和，并确保每个边和节点被处理常数次。您的方法必须从脉冲响应的一阶矩确定有效延迟的原理出发，并解释为什么在边上聚合上游电阻和下游电容足以计算叶节点的 $t_{d}$ 而无需重新遍历树。\n\n您的程序必须实现此算法，并将其应用于以下测试套件。在每种情况下，将给定的结构视为一个有根树，具有指定的根节点索引、边电阻和节点电容。所有延迟均以秒（s）表示。输出应为单行，包含一个列表的列表；每个内部列表应包含该测试用例的叶节点延迟，按叶节点索引升序排列。所有数值结果必须表示为以秒为单位的浮点数。打印输出中不应出现单位；此处的单位规范对解释具有约束力。\n\n测试套件：\n\n- 案例 $1$（平衡分支）：\n  - 节点：索引 $0$ 到 $6$，根节点为 $0$。\n  - 边及其电阻（单位：欧姆 $\\Omega$）：$(0\\rightarrow 1, R=100)$、$(0\\rightarrow 2, R=80)$、$(1\\rightarrow 3, R=50)$、$(1\\rightarrow 4, R=70)$、$(2\\rightarrow 5, R=60)$、$(2\\rightarrow 6, R=90)$。\n  - 节点电容（单位：法拉 $\\mathrm{F}$）：$C_0=0.2\\times 10^{-12}$、$C_1=0.3\\times 10^{-12}$、$C_2=0.25\\times 10^{-12}$、$C_3=1.0\\times 10^{-12}$、$C_4=0.6\\times 10^{-12}$、$C_5=0.9\\times 10^{-12}$、$C_6=0.5\\times 10^{-12}$。\n  - 叶节点：节点 $3,4,5,6$。\n\n- 案例 $2$（单链边界情况）：\n  - 节点：索引 $0$ 到 $2$，根节点为 $0$。\n  - 边及其电阻（单位：$\\Omega$）：$(0\\rightarrow 1, R=120)$、$(1\\rightarrow 2, R=130)$。\n  - 节点电容（单位：$\\mathrm{F}$）：$C_0=0.1\\times 10^{-12}$、$C_1=0.2\\times 10^{-12}$、$C_2=1.5\\times 10^{-12}$。\n  - 叶节点：节点 $2$。\n\n- 案例 $3$（内部零电容边界情况）：\n  - 节点：索引 $0$ 到 $3$，根节点为 $0$。\n  - 边及其电阻（单位：$\\Omega$）：$(0\\rightarrow 1, R=200)$、$(1\\rightarrow 2, R=50)$、$(1\\rightarrow 3, R=60)$。\n  - 节点电容（单位：$\\mathrm{F}$）：$C_0=0.2\\times 10^{-12}$、$C_1=0.0\\times 10^{-12}$、$C_2=0.8\\times 10^{-12}$、$C_3=0.4\\times 10^{-12}$。\n  - 叶节点：节点 $2,3$。\n\n- 案例 $4$（异构分支与深度）：\n  - 节点：索引 $0$ 到 $9$，根节点为 $0$。\n  - 边及其电阻（单位：$\\Omega$）：$(0\\rightarrow 1, R=75)$、$(1\\rightarrow 2, R=40)$、$(2\\rightarrow 3, R=30)$、$(1\\rightarrow 4, R=55)$、$(0\\rightarrow 5, R=65)$、$(5\\rightarrow 6, R=45)$、$(5\\rightarrow 7, R=35)$、$(7\\rightarrow 8, R=25)$、$(7\\rightarrow 9, R=20)$。\n  - 节点电容（单位：$\\mathrm{F}$）：$C_0=0.15\\times 10^{-12}$、$C_1=0.2\\times 10^{-12}$、$C_2=0.05\\times 10^{-12}$、$C_3=1.2\\times 10^{-12}$、$C_4=0.7\\times 10^{-12}$、$C_5=0.25\\times 10^{-12}$、$C_6=0.9\\times 10^{-12}$、$C_7=0.1\\times 10^{-12}$、$C_8=0.4\\times 10^{-12}$、$C_9=0.3\\times 10^{-12}$。\n  - 叶节点：节点 $3,4,6,8,9$。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，并用方括号括起来，例如 $[\\,[d_{1,1},d_{1,2},\\dots],\\,[d_{2,1},\\dots],\\dots\\,]$，其中每个 $d_{i,j}$ 是一个以秒为单位的浮点数，对应于第 $i$ 个测试用例的第 $j$ 个叶节点的 Elmore 延迟。每个测试用例的结果必须按叶节点索引的升序排列叶节点延迟。",
            "solution": "计算电阻-电容（RC）树叶节点的 Elmore 延迟是电气工程中一个明确定义的问题，特别是在集成电路互连分析领域。问题陈述具有科学依据、自成体系且客观。因此，我们可以进行形式化的求解。\n\n**1. Elmore 延迟的理论基础**\n\nElmore 延迟是 RC 电路延迟的一阶近似。对于一个线性时不变（LTI）系统，其在时间 $t=0$ 时对单位阶跃输入的响应与其脉冲响应相关。节点 $i$ 的 Elmore 延迟 $t_{Di}$ 定义为该节点脉冲响应 $h_i(t)$ 的一阶矩：\n$$ t_{Di} = \\int_0^\\infty t h_i(t) dt $$\n可以证明，该定义等价于从电路分析中推导出的表达式。对于一个以节点 $0$ 为根并由电压源驱动的 RC 树，任意节点 $i$ 的 Elmore 延迟由下式给出：\n$$ t_{Di} = \\sum_{k=0}^{N-1} R_{ik} C_k $$\n其中 $N$ 是树中的节点数，$C_k$ 是节点 $k$ 的电容，$R_{ik}$ 是从根节点出发到节点 $i$ 和到节点 $k$ 的路径所共有的那部分路径的电阻。我们可以将 $R_{ik}$ 表示为共享路径上各边 $e_j$ 的电阻之和：\n$$ R_{ik} = \\sum_{e_j \\in \\text{path}(0,i) \\cap \\text{path}(0,k)} R_j $$\n其中 $R_j$ 是边 $e_j$ 的电阻。\n\n**2. 线性时间算法的推导**\n\n对所有节点对 $(i, k)$ 进行求和的二次复杂度使得上述公式对于大型电路而言效率低下。通过重构求和顺序，可以推导出一个更高效的线性时间算法。通过交换求和次序，我们可以按电阻而不是电容来分组各项：\n$$ t_{Di} = \\sum_{k=0}^{N-1} C_k \\left( \\sum_{e_j \\in \\text{path}(0,i) \\cap \\text{path}(0,k)} R_j \\right) = \\sum_{e_j} R_j \\left( \\sum_{k \\text{ s.t. } e_j \\in \\text{path}(0,i) \\cap \\text{path}(0,k)} C_k \\right) $$\n假设一条边 $e_j$ 连接父节点 $u_j$ 和子节点 $v_j$。条件 $e_j \\in \\text{path}(0, i) \\cap \\text{path}(0, k)$ 意味着两件事：\n1.  边 $e_j$ 必须在从根到节点 $i$ 的路径上。\n2.  边 $e_j$ 也必须在从根到节点 $k$ 的路径上。这意味着节点 $k$ 必须位于以 $v_j$ 为根的子树中。\n\n因此，对于到节点 $i$ 路径上的给定边 $e_j=(u_j, v_j)$，内层求和累加了其子节点 $v_j$ 的子树中所有节点 $k$ 的电容。这个和恰好是节点 $v_j$ 的“下游电容”，我们记为 $C_{\\text{down}}(v_j)$。\n$$ C_{\\text{down}}(v_j) = \\sum_{k \\in \\text{subtree}(v_j)} C_k $$\n将其代回，节点 $i$ 的 Elmore 延迟是从根到 $i$ 的路径上每条边的电阻与其下游总电容的乘积之和：\n$$ t_{Di} = \\sum_{e_j=(u_j,v_j) \\in \\text{path}(0,i)} R_j \\cdot C_{\\text{down}}(v_j) $$\n该表达式是线性时间算法的核心。它直接对应于问题描述中的“路径上各项贡献的累加，这些贡献结合了上游电阻和下游电容”。\n\n**3. 算法设计**\n\n$t_{Di}$ 的公式揭示了一个清晰的计算依赖关系。要计算任何节点的延迟，我们需要：\n1.  路径上各个节点 $v$ 的下游电容 $C_{\\text{down}}(v)$。\n2.  路径结构本身。\n\n这表明需要一个两遍算法，在对树的数据结构进行单次遍历的过程中执行，这与问题要求的“单次深度优先搜索”且每个边被处理常数次的要求一致。\n\n**第一遍：后序遍历计算下游电容**\n后序遍历（一种 DFS 形式）天然地支持自下而上计算下游电容。当访问一个节点 $u$ 时，我们首先递归地访问其所有子节点。从递归调用返回后，所有子节点的下游电容都是已知的。然后，节点 $u$ 的下游电容可以计算为其自身电容加上其所有子节点下游电容的总和：\n$$ C_{\\text{down}}(u) = C_u + \\sum_{v \\in \\text{children}(u)} C_{\\text{down}}(v) $$\n这一遍从叶节点开始，向上移动到根节点，填充树中每个节点的 $C_{\\text{down}}$ 值数组。\n\n**第二遍：前序遍历计算 Elmore 延迟**\n在所有 $C_{\\text{down}}$ 值都预先计算好的情况下，前序遍历（另一种 DFS 形式）可以自上而下地计算延迟。Elmore 延迟 $t_{Di}$ 可以递归地表示。根节点的延迟 $t_{D0}$ 为 $0$。对于任何其他父节点为 $p$ 的节点 $i$，到 $i$ 的路径是到 $p$ 的路径加上边 $(p,i)$。因此：\n$$ t_{Di} = t_{Dp} + R_{pi} \\cdot C_{\\text{down}}(i) $$\n其中 $R_{pi}$ 是从 $p$ 到 $i$ 的边的电阻。这个递归公式允许我们通过取其父节点的延迟，并加上来自连接边的新贡献，来计算每个节点的延迟。从根节点开始，初始延迟为 $0$ 的前序遍历完美地实现了这种自上而下的累加。\n\n**算法总结**\n1.  使用邻接表表示 RC 树，其中对于每个父节点，我们存储其子节点列表及相应的边电阻。\n2.  从根节点开始执行一次后序 DFS 遍历，为每个节点 $u$ 计算并存储其下游电容 $C_{\\text{down}}(u)$。\n3.  从根节点开始执行一次前序 DFS 遍历，使用递归延迟公式和预先计算的 $C_{\\text{down}}$ 值，为每个节点 $u$ 计算并存储其 Elmore 延迟 $t_{Du}$。\n4.  对于每个测试用例，提取指定叶节点的计算延迟，并按节点索引升序排列。\n\n每一遍访问每个节点和每条边一次。总时间复杂度为 $O(N+E)$，其中 $N$ 是节点数，$E$ 是边数。对于树来说，$E=N-1$，所以复杂度为 $O(N)$，满足线性时间的要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solving of all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (balanced branching)\n        {\n            \"num_nodes\": 7,\n            \"root\": 0,\n            \"edges\": [(0, 1, 100), (0, 2, 80), (1, 3, 50), (1, 4, 70), (2, 5, 60), (2, 6, 90)],\n            \"capacitances\": [0.2e-12, 0.3e-12, 0.25e-12, 1.0e-12, 0.6e-12, 0.9e-12, 0.5e-12],\n            \"leaves\": [3, 4, 5, 6]\n        },\n        # Case 2 (single chain boundary)\n        {\n            \"num_nodes\": 3,\n            \"root\": 0,\n            \"edges\": [(0, 1, 120), (1, 2, 130)],\n            \"capacitances\": [0.1e-12, 0.2e-12, 1.5e-12],\n            \"leaves\": [2]\n        },\n        # Case 3 (internal zero capacitance edge case)\n        {\n            \"num_nodes\": 4,\n            \"root\": 0,\n            \"edges\": [(0, 1, 200), (1, 2, 50), (1, 3, 60)],\n            \"capacitances\": [0.2e-12, 0.0, 0.8e-12, 0.4e-12],\n            \"leaves\": [2, 3]\n        },\n        # Case 4 (heterogeneous branching and depth)\n        {\n            \"num_nodes\": 10,\n            \"root\": 0,\n            \"edges\": [(0, 1, 75), (1, 2, 40), (2, 3, 30), (1, 4, 55), (0, 5, 65), (5, 6, 45), (5, 7, 35), (7, 8, 25), (7, 9, 20)],\n            \"capacitances\": [0.15e-12, 0.2e-12, 0.05e-12, 1.2e-12, 0.7e-12, 0.25e-12, 0.9e-12, 0.1e-12, 0.4e-12, 0.3e-12],\n            \"leaves\": [3, 4, 6, 8, 9]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        delays = calculate_elmore_delays(\n            case[\"num_nodes\"],\n            case[\"edges\"],\n            case[\"capacitances\"],\n            case[\"root\"],\n            case[\"leaves\"]\n        )\n        all_results.append(delays)\n\n    # Format the final output string as specified\n    formatted_results = [f\"[{','.join(f'{d:.16g}' for d in res)}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_elmore_delays(num_nodes, edges, capacitances_list, root, leaves):\n    \"\"\"\n    Computes Elmore delays for specified a RC tree and its leaf nodes.\n    \n    The algorithm uses a two-pass DFS approach:\n    1. A post-order DFS to calculate the downstream capacitance for each node.\n    2. A pre-order DFS to calculate the Elmore delay for each node.\n    \n    Args:\n        num_nodes (int): The number of nodes in the tree (indexed 0 to num_nodes-1).\n        edges (list of tuples): Each tuple represents an edge (parent, child, resistance).\n        capacitances_list (list of float): Capacitance value for each node.\n        root (int): The index of the root node.\n        leaves (list of int): A list of indices of the leaf nodes.\n\n    Returns:\n        list of float: The Elmore delays for the leaf nodes, sorted by node index.\n    \"\"\"\n    # Adjacency list representation: adj[parent] = [(child, resistance), ...]\n    adj = [[] for _ in range(num_nodes)]\n    for parent, child, resistance in edges:\n        adj[parent].append((child, resistance))\n    \n    capacitances = np.array(capacitances_list, dtype=float)\n    downstream_capacitances = np.zeros(num_nodes, dtype=float)\n    elmore_delays = np.zeros(num_nodes, dtype=float)\n\n    # --- Pass 1: Post-order DFS to compute downstream capacitances ---\n    # Stack for iterative DFS to avoid deep recursion issues (though not critical here)\n    # The order of nodes pushed ensures post-order processing\n    visited_capacitance = [False] * num_nodes\n    dfs_order = []\n    stack = [root]\n    while stack:\n        u = stack.pop()\n        if not visited_capacitance[u]:\n            visited_capacitance[u] = True\n            dfs_order.append(u)\n            for v, _ in adj[u]:\n                stack.append(v)\n    \n    # Process nodes in reverse order of discovery (post-order traversal)\n    for u in reversed(dfs_order):\n        cap_sum = capacitances[u]\n        for v, _ in adj[u]:\n            cap_sum += downstream_capacitances[v]\n        downstream_capacitances[u] = cap_sum\n\n    # --- Pass 2: Pre-order DFS to compute Elmore delays ---\n    # Stack for iterative pre-order DFS: (node, parent_delay)\n    stack = [(root, 0.0)]\n    visited_delay = [False] * num_nodes\n    \n    while stack:\n        u, parent_delay = stack.pop()\n        \n        if visited_delay[u]:\n            continue\n        visited_delay[u] = True\n        \n        elmore_delays[u] = parent_delay\n        \n        # Add children to stack for next iteration in reverse to maintain order\n        for v, resistance in reversed(adj[u]):\n            child_delay = parent_delay + resistance * downstream_capacitances[v]\n            stack.append((v, child_delay))\n\n    # Extract delays for leaf nodes, ordered by ascending leaf index\n    leaf_delays = [elmore_delays[leaf_idx] for leaf_idx in sorted(leaves)]\n    \n    return leaf_delays\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}