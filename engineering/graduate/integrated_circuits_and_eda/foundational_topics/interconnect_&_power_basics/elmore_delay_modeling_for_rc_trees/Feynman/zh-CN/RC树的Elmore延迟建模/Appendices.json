{
    "hands_on_practices": [
        {
            "introduction": "我们从最基本的情况入手：一个线性的RC梯形网络。这个练习旨在巩固Elmore延迟的基础计算方法。通过这个实践，你将学会如何应用核心公式——将每个电容的值与其上游路径的总电阻相乘，然后将所有这些乘积相加，从而得到节点的总延迟。这是掌握Elmore延迟模型的第一步。",
            "id": "4269413",
            "problem": "在电子设计自动化 (EDA) 中，集成电路上的互连线常被建模为阻容 (RC) 树，以预测信号传播时延。考虑一个线性RC树（一个串联梯形网络），由一个理想阶跃电压源驱动，其戴维南 (Thevenin) 电阻可忽略不计。该树由三个串联电阻和三个到地的并联电容组成：电阻 $R_1$ 连接电源与节点 $1$，电阻 $R_2$ 连接节点 $1$ 与节点 $2$，电阻 $R_3$ 连接节点 $2$ 与节点 $3$（远端叶节点输出）。电容 $C_1$ 从节点 $1$ 连接到地，电容 $C_2$ 从节点 $2$ 连接到地，电容 $C_3$ 从节点 $3$ 连接到地。假设没有其他负载，并且从输入到远端叶节点输出的直流增益为1，因此输出电压会渐近地达到输入电压。\n\n从线性时不变RC网络的脉冲响应 $h(t)$ 的定义以及矩的定义 $m_1 = \\int_{0}^{\\infty} t\\,h(t)\\,dt$ 出发，推导此RC树远端叶节点输出延迟的表达式，该延迟定义为脉冲响应的一阶矩，并用网络中的电阻和电容表示。然后，在参数值为 $R_1 = 100\\,\\Omega$, $R_2 = 150\\,\\Omega$, $R_3 = 200\\,\\Omega$, $C_1 = 10\\,\\text{fF}$, $C_2 = 20\\,\\text{fF}$, 以及 $C_3 = 30\\,\\text{fF}$ 的情况下，计算该延迟的值。\n\n最终数值答案以皮秒为单位表示，并四舍五入到四位有效数字。",
            "solution": "该问题提法明确，具有科学依据，并包含了获得唯一解所需的所有信息。RC树模型和Elmore延迟是集成电路分析中的标准基本概念。因此，该问题是有效的。\n\n目标是推导给定的三级RC梯形网络的远端叶节点输出延迟的表达式，然后计算其数值。延迟被定义为脉冲响应 $h(t)$ 的一阶矩 $m_1$。\n\n设 $H(s)$ 是线性时不变 (LTI) 网络的传递函数，它是脉冲响应 $h(t)$ 的拉普拉斯变换：\n$$H(s) = \\mathcal{L}\\{h(t)\\} = \\int_{0}^{\\infty} h(t) e^{-st} dt$$\n脉冲响应的矩 $m_k$ 定义为 $m_k = \\int_{0}^{\\infty} t^k h(t) dt$。传递函数 $H(s)$ 可以在 $s=0$ 附近展开为麦克劳林级数：\n$$H(s) = \\sum_{k=0}^{\\infty} \\frac{1}{k!} \\frac{d^k H(s)}{ds^k}\\bigg|_{s=0} s^k$$\n通过对 $H(s)$ 关于 $s$ 求导，我们找到了其在 $s=0$ 处的导数与矩之间的关系：\n$$\\frac{d^k H(s)}{ds^k} = \\int_{0}^{\\infty} (-t)^k h(t) e^{-st} dt$$\n$$\\frac{d^k H(s)}{ds^k}\\bigg|_{s=0} = (-1)^k \\int_{0}^{\\infty} t^k h(t) dt = (-1)^k m_k$$\n将此代回麦克劳林级数，得到传递函数的矩展开式：\n$$H(s) = m_0 - m_1 s + \\frac{m_2}{2} s^2 - \\dots$$\n问题说明直流增益为1，这意味着 $H(0)=1$。从展开式可知，$H(0) = m_0$。因此，$m_0 = \\int_{0}^{\\infty} h(t) dt = 1$。\n延迟被定义为一阶矩 $m_1$。从级数中我们可以看到，对于小的 $s$，有 $H(s) \\approx 1 - m_1 s$。这意味着 $m_1 = - \\frac{dH(s)}{ds}\\big|_{s=0}$。\n\n为了求得 $m_1$，我们必须首先确定给定RC梯形网络的传递函数 $H(s) = V_3(s) / V_{in}(s)$。我们可以使用拉普拉斯域中的节点分析法。设 $V_1(s)$, $V_2(s)$ 和 $V_3(s)$ 为节点电压。电容的阻抗分别为 $1/(sC_1)$, $1/(sC_2)$ 和 $1/(sC_3)$。\n\n节点方程为：\n在节点1: $\\frac{V_1(s) - V_{in}(s)}{R_1} + \\frac{V_1(s) - V_2(s)}{R_2} + sC_1 V_1(s) = 0$\n在节点2: $\\frac{V_2(s) - V_1(s)}{R_2} + \\frac{V_2(s) - V_3(s)}{R_3} + sC_2 V_2(s) = 0$\n在节点3: $\\frac{V_3(s) - V_2(s)}{R_3} + sC_3 V_3(s) = 0$\n\n我们可以找到 $H(s)$ 在 $s$ 很小时的一阶近似，而无需完全求解该方程组。\n从节点3的方程：\n$V_3(s) \\left(\\frac{1}{R_3} + sC_3\\right) = \\frac{V_2(s)}{R_3} \\implies V_3(s) = V_2(s) \\frac{1}{1+sR_3C_3}$\n对于小的 $s$，使用近似 $(1+x)^{-1} \\approx 1-x$：\n$V_3(s) \\approx V_2(s) (1 - sR_3C_3)$\n\n将此代入节点2的方程：\n$\\frac{V_2(s) - V_1(s)}{R_2} + \\frac{V_2(s) - V_2(s)(1 - sR_3C_3)}{R_3} + sC_2 V_2(s) = 0$\n$\\frac{V_2(s)}{R_2} - \\frac{V_1(s)}{R_2} + \\frac{sR_3C_3 V_2(s)}{R_3} + sC_2 V_2(s) = 0$\n$V_2(s) \\left(\\frac{1}{R_2} + sC_3 + sC_2\\right) = \\frac{V_1(s)}{R_2}$\n$V_2(s) = V_1(s) \\frac{1/R_2}{1/R_2 + s(C_2+C_3)} = V_1(s) \\frac{1}{1+sR_2(C_2+C_3)}$\n对于小的 $s$：\n$V_2(s) \\approx V_1(s) (1 - sR_2(C_2+C_3))$\n\n将此代入节点1的方程：\n$\\frac{V_1(s) - V_{in}(s)}{R_1} + \\frac{V_1(s) - V_1(s)(1 - sR_2(C_2+C_3))}{R_2} + sC_1 V_1(s) = 0$\n$\\frac{V_1(s)}{R_1} - \\frac{V_{in}(s)}{R_1} + \\frac{sR_2(C_2+C_3)V_1(s)}{R_2} + sC_1 V_1(s) = 0$\n$V_1(s) \\left(\\frac{1}{R_1} + s(C_2+C_3) + sC_1\\right) = \\frac{V_{in}(s)}{R_1}$\n$V_1(s) = V_{in}(s) \\frac{1/R_1}{1/R_1 + s(C_1+C_2+C_3)} = V_{in}(s) \\frac{1}{1+sR_1(C_1+C_2+C_3)}$\n对于小的 $s$：\n$V_1(s) \\approx V_{in}(s) (1-sR_1(C_1+C_2+C_3))$\n\n现在，组合这些近似以求得 $H(s) = V_3(s) / V_{in}(s)$：\n$V_3(s) \\approx V_2(s)(1-sR_3C_3) \\approx [V_1(s)(1-sR_2(C_2+C_3))](1-sR_3C_3)$\n$V_3(s) \\approx [V_{in}(s)(1-sR_1(C_1+C_2+C_3))](1-sR_2(C_2+C_3))(1-sR_3C_3)$\n展开并保留到 $s$ 的一阶项：\n$H(s) = \\frac{V_3(s)}{V_{in}(s)} \\approx 1 - sR_1(C_1+C_2+C_3) - sR_2(C_2+C_3) - sR_3C_3$\n$H(s) \\approx 1 - s [R_1(C_1+C_2+C_3) + R_2(C_2+C_3) + R_3C_3]$\n按电容对各项进行分组，我们得到Elmore延迟表达式：\n$H(s) \\approx 1 - s [R_1C_1 + (R_1+R_2)C_2 + (R_1+R_2+R_3)C_3]$\n将此与 $H(s) \\approx 1 - m_1 s$ 相比较，延迟 $m_1$（我们记为 $\\tau_{D3}$）为：\n$$\\tau_{D3} = R_1C_1 + (R_1+R_2)C_2 + (R_1+R_2+R_3)C_3$$\n这个公式表示节点3处的Elmore延迟。每一项都是一个电容 $C_k$ 与从电源到节点3和节点k的公共路径上的总电阻 $R_{3k}$ 的乘积。\n\n现在，我们使用给定的参数值计算这个表达式：\n$R_1 = 100\\,\\Omega$\n$R_2 = 150\\,\\Omega$\n$R_3 = 200\\,\\Omega$\n$C_1 = 10\\,\\text{fF} = 10 \\times 10^{-15}\\,\\text{F}$\n$C_2 = 20\\,\\text{fF} = 20 \\times 10^{-15}\\,\\text{F}$\n$C_3 = 30\\,\\text{fF} = 30 \\times 10^{-15}\\,\\text{F}$\n\n计算电阻之和：\n$R_1 = 100\\,\\Omega$\n$R_1 + R_2 = 100\\,\\Omega + 150\\,\\Omega = 250\\,\\Omega$\n$R_1 + R_2 + R_3 = 100\\,\\Omega + 150\\,\\Omega + 200\\,\\Omega = 450\\,\\Omega$\n\n将这些值代入延迟表达式：\n$\\tau_{D3} = (100\\,\\Omega)(10 \\times 10^{-15}\\,\\text{F}) + (250\\,\\Omega)(20 \\times 10^{-15}\\,\\text{F}) + (450\\,\\Omega)(30 \\times 10^{-15}\\,\\text{F})$\n$\\tau_{D3} = (1000 \\times 10^{-15})\\,\\text{s} + (5000 \\times 10^{-15})\\,\\text{s} + (13500 \\times 10^{-15})\\,\\text{s}$\n$\\tau_{D3} = (1000 + 5000 + 13500) \\times 10^{-15}\\,\\text{s}$\n$\\tau_{D3} = 19500 \\times 10^{-15}\\,\\text{s}$\n$\\tau_{D3} = 19.5 \\times 10^{-12}\\,\\text{s}$\n因为 $1$ 皮秒 ($ps$) 等于 $10^{-12}$ 秒，所以延迟为：\n$\\tau_{D3} = 19.5\\,\\text{ps}$\n\n题目要求答案四舍五入到四位有效数字。\n$19.50\\,\\text{ps}$",
            "answer": "$$\\boxed{19.50}$$"
        },
        {
            "introduction": "现实世界中的互连线很少是简单的直线，它们通常会分支出多个路径。这个练习引入了一个分支拓扑结构，旨在帮助你建立对“共享路径电阻”这一关键概念的直观理解。你将通过分析发现，位于一个分支上的电容是如何通过它们与目标节点共有的电阻路径，来影响另一个分支上的信号延迟的。",
            "id": "4269384",
            "problem": "一个单输入阻容树由一个幅值为 $V_{\\text{DD}}$、源电阻为零的理想阶跃电压源驱动。该电压源通过一个串联电阻 $R_{0}$ 连接到内部节点 $0$。从节点 $0$ 分出两个支路：一个支路通过电阻 $R_{a}$ 连接到叶节点 $a$，另一个支路通过电阻 $R_{b}$ 连接到叶节点 $b$。每个节点 $i \\in \\{0,a,b\\}$ 都有一个到地的集总电容 $C_{i}$。不存在其他到地的电阻，没有耦合电容，并且所有互连电容都集总在 $C_{0}$、$C_{a}$ 和 $C_{b}$ 中。假设电路具有线性时不变行为，并且电阻器构成的图是一个树形结构。仅使用基尔霍夫定律、电荷守恒定律以及线性阻容树的冲激响应一阶时间矩的定义，从第一性原理出发，推导到叶节点 $a$ 的Elmore延迟表达式，然后用以下参数值进行计算：$R_{0}=50\\,\\Omega$，$R_{a}=100\\,\\Omega$，$R_{b}=200\\,\\Omega$，$C_{0}=5\\,\\text{fF}$，$C_{a}=15\\,\\text{fF}$，以及 $C_{b}=25\\,\\text{fF}$。将节点 $a$ 的最终延迟以皮秒为单位表示，并将结果四舍五入到三位有效数字。",
            "solution": "该问题要求从第一性原理出发，推导到叶节点 $a$ 的Elmore延迟，然后进行数值计算。推导过程必须基于基尔霍夫定律、电荷守恒定律以及冲激响应一阶时间矩的定义。\n\n首先，我们来定义Elmore延迟。对于一个线性时不变（LTI）系统，其输出节点 $i$ 的延迟可以用该节点冲激响应 $h_i(t)$ 的一阶矩来表征。Elmore延迟 $\\tau_{Di}$ 定义为：\n$$ \\tau_{Di} = \\int_{0}^{\\infty} t h_i(t) dt $$\n其中冲激响应被归一化，使其在所有时间上的积分为1，即 $\\int_{0}^{\\infty} h_i(t) dt = 1$。\n\n问题描述了一个幅值为 $V_{\\text{DD}}$ 的阶跃电压输入。设 $v_i(t)$ 是节点 $i$ 对该阶跃输入 $v_{\\text{in}}(t) = V_{\\text{DD}} u(t)$ 的电压响应，其中 $u(t)$ 是亥维赛阶跃函数。对于一个LTI系统，冲激响应是阶跃响应对时间的导数，并由输入阶跃的幅值进行缩放。对于我们的电路（一个RC树），任意节点 $i$ 的最终稳态电压为 $V_{\\text{DD}}$。因此，归一化的冲激响应为 $h_i(t) = \\frac{1}{V_{\\text{DD}}} \\frac{d v_i(t)}{dt}$。\n\n将此式代入节点 $a$ 的Elmore延迟定义中：\n$$ \\tau_{Da} = \\int_{0}^{\\infty} t \\left( \\frac{1}{V_{\\text{DD}}} \\frac{d v_a(t)}{dt} \\right) dt = \\frac{1}{V_{\\text{DD}}} \\int_{0}^{\\infty} t \\frac{d v_a(t)}{dt} dt $$\n我们可以使用分部积分法 $\\int u \\, dv = uv - \\int v \\, du$ 来计算该积分。令 $u=t$ 且 $dv = \\frac{d v_a(t)}{dt} dt$。则 $du=dt$ 且 $v=v_a(t)$。\n$$ \\int_{0}^{\\infty} t \\frac{d v_a(t)}{dt} dt = \\left[ t v_a(t) \\right]_{0}^{\\infty} - \\int_{0}^{\\infty} v_a(t) dt $$\n边界项 $\\left[ t v_a(t) \\right]_{0}^{\\infty}$ 需要仔细计算。当 $t=0$ 时，该项为 $0$。当 $t \\rightarrow \\infty$ 时，$v_a(t)$ 趋近于其稳态值 $V_{\\text{DD}}$。一个稳定的RC电路的瞬态响应呈指数衰减，因此我们可以写出 $v_a(t) = V_{\\text{DD}} - f(t)$，其中 $f(t)$ 包含诸如 $e^{-t/\\tau_{\\text{pole}}}$ 的项，这些项比 $1/t$更快地趋近于零。因此，$\\lim_{t\\to\\infty} t(V_{\\text{DD}} - v_a(t)) = 0$。\n可以建立如下积分恒等式：\n$$ \\int_{0}^{\\infty} (V_{\\text{DD}} - v_a(t)) dt = \\int_{0}^{\\infty} t \\frac{d v_a(t)}{dt} dt $$\n此公式将冲激响应的一阶矩与阶跃响应瞬态之上所围的面积联系起来。因此，Elmore延迟可以表示为：\n$$ \\tau_{Da} = \\frac{1}{V_{\\text{DD}}} \\int_{0}^{\\infty} (V_{\\text{DD}} - v_a(t)) dt $$\n现在，我们应用基尔霍夫电压定律（KVL）。电压差 $V_{\\text{DD}} - v_a(t)$ 是从输入源到节点 $a$ 的唯一电阻路径上的总电压降。电路拓扑如下：源 $\\rightarrow R_0 \\rightarrow$ 节点 $0 \\rightarrow R_a \\rightarrow$ 节点 $a$。\n设 $I_{R0}(t)$ 为流过 $R_0$ 的电流（从源到节点 $0$），$I_{Ra}(t)$ 为流过 $R_a$ 的电流（从节点 $0$ 到节点 $a$）。电压降由欧姆定律给出。\n当 $t>0$ 时，$v_{\\text{in}}(t) = V_{\\text{DD}}$。\n$$ V_{\\text{DD}} - v_a(t) = (V_{\\text{DD}} - v_0(t)) + (v_0(t) - v_a(t)) = I_{R0}(t)R_0 + I_{Ra}(t)R_a $$\n将此式代入 $\\tau_{Da}$ 的积分表达式中：\n$$ \\tau_{Da} = \\frac{1}{V_{\\text{DD}}} \\int_{0}^{\\infty} \\left( I_{R0}(t)R_0 + I_{Ra}(t)R_a \\right) dt $$\n$$ \\tau_{Da} = \\frac{1}{V_{\\text{DD}}} \\left( R_0 \\int_{0}^{\\infty} I_{R0}(t) dt + R_a \\int_{0}^{\\infty} I_{Ra}(t) dt \\right) $$\n接下来，我们援引电荷守恒原理。电流对时间的积分 $\\int_{0}^{\\infty} I(t) dt$ 代表流过的总电荷量 $Q$。这些电荷必须在电容器上累积，以将其电压从初始状态（$0$）改变到最终状态（$V_{\\text{DD}}$）。电容器上的电荷为 $Q = CV$。\n\n流过电阻 $R_0$ 的电流 $I_{R0}(t)$ 提供了为树中所有电容器（$C_0$、$C_a$ 和 $C_b$）充电所需的电荷。供应的总电荷为：\n$$ \\int_{0}^{\\infty} I_{R0}(t) dt = Q_{\\text{total}} = C_0 \\Delta V_0 + C_a \\Delta V_a + C_b \\Delta V_b $$\n由于 $\\Delta V_0 = \\Delta V_a = \\Delta V_b = V_{\\text{DD}} - 0 = V_{\\text{DD}}$，我们有：\n$$ \\int_{0}^{\\infty} I_{R0}(t) dt = (C_0 + C_a + C_b) V_{\\text{DD}} $$\n流过电阻 $R_a$ 的电流 $I_{Ra}(t)$ 仅为节点 $a$ 处的电容器提供电荷，因为其是一个叶节点。\n$$ \\int_{0}^{\\infty} I_{Ra}(t) dt = C_a \\Delta V_a = C_a V_{\\text{DD}} $$\n现在，我们将这些电荷表达式代回到 $\\tau_{Da}$ 的方程中：\n$$ \\tau_{Da} = \\frac{1}{V_{\\text{DD}}} \\left[ R_0 (C_0 + C_a + C_b) V_{\\text{DD}} + R_a (C_a V_{\\text{DD}}) \\right] $$\n$V_{\\text{DD}}$ 项相互抵消，得到节点 $a$ 的Elmore延迟的最终表达式：\n$$ \\tau_{Da} = R_0 (C_0 + C_a + C_b) + R_a C_a $$\n这样就完成了从第一性原理的推导。\n\n现在，我们使用给定的参数值来计算这个表达式：\n$R_{0}=50\\,\\Omega$\n$R_{a}=100\\,\\Omega$\n$C_{0}=5\\,\\text{fF} = 5 \\times 10^{-15}\\,\\text{F}$\n$C_{a}=15\\,\\text{fF} = 15 \\times 10^{-15}\\,\\text{F}$\n$C_{b}=25\\,\\text{fF} = 25 \\times 10^{-15}\\,\\text{F}$\n\n将这些值代入推导出的公式中：\n$$ \\tau_{Da} = (50\\,\\Omega) (5 \\times 10^{-15}\\,\\text{F} + 15 \\times 10^{-15}\\,\\text{F} + 25 \\times 10^{-15}\\,\\text{F}) + (100\\,\\Omega) (15 \\times 10^{-15}\\,\\text{F}) $$\n$$ \\tau_{Da} = (50\\,\\Omega) (45 \\times 10^{-15}\\,\\text{F}) + (100\\,\\Omega) (15 \\times 10^{-15}\\,\\text{F}) $$\n欧姆和法拉的乘积单位是秒 ($\\Omega \\cdot \\text{F} = \\frac{V}{I} \\cdot \\frac{Q}{V} = \\frac{Q}{I} = \\frac{I \\cdot t}{I} = t$)。\n$$ \\tau_{Da} = (50 \\times 45 \\times 10^{-15})\\,\\text{s} + (100 \\times 15 \\times 10^{-15})\\,\\text{s} $$\n$$ \\tau_{Da} = (2250 \\times 10^{-15})\\,\\text{s} + (1500 \\times 10^{-15})\\,\\text{s} $$\n$$ \\tau_{Da} = 3750 \\times 10^{-15}\\,\\text{s} $$\n问题要求答案以皮秒（$1\\,\\text{ps} = 10^{-12}\\,\\text{s}$）为单位，并四舍五入到三位有效数字。\n$$ \\tau_{Da} = 3750 \\times 10^{-15}\\,\\text{s} = 3.750 \\times 10^{-12}\\,\\text{s} = 3.75\\,\\text{ps} $$\n结果 $3.75$ 已经有三位有效数字。",
            "answer": "$$\\boxed{3.75}$$"
        },
        {
            "introduction": "对于现代大规模集成电路中包含数百万个晶体管的复杂互连网络，手动计算延迟是完全不可行的。这项高级练习旨在连接理论公式与在电子设计自动化（EDA）工具中的实际应用。你将设计并实现一个线性时间复杂度的算法，用以高效计算任意RC树中所有叶节点的Elmore延迟，这是静态时序分析中的一项核心任务。",
            "id": "4269394",
            "problem": "在电子设计自动化 (EDA) 中，阻容 (RC) 树用于模拟集成电路中的互连线。该树以一个驱动节点为根，其边为电阻，节点为接地电容。对于根节点的单位阶跃激励，叶节点的阶跃响应可通过 Elmore 延迟来近似，Elmore 延迟是相应线性时不变系统冲激响应的一阶矩。从基尔霍夫电流定律 (KCL)、基尔霍夫电压定律 (KVL) 和线性时不变性出发，Elmore 延迟可以推导为上游电阻与下游电容相结合的贡献值的路径累加。目标是高效地计算到每个叶节点的 Elmore 延迟。\n\n设计一个基于单次深度优先搜索 (DFS) 的线性时间算法，计算所有叶节点的延迟 $t_{d}$。该算法必须遍历树一次，累加每条边的上游电阻信息和下游电容总和，并确保每个边和节点被处理常数次。你的方法必须从冲激响应的一阶矩决定有效延迟这一原理出发，并解释为什么在边上聚合上游电阻和下游电容足以计算叶节点的 $t_{d}$ 而无需重新遍历树。\n\n你的程序必须实现此算法，并将其应用于以下测试套件。在每种情况下，将给定的结构视为一个有根树，具有指定的根节点索引、边电阻和节点电容。所有延迟以秒 (s) 为单位表示。输出应为单行，包含一个列表的列表；每个内部列表应包含该测试用例的叶节点延迟，按叶节点索引升序排列。所有数值结果必须表示为以秒为单位的浮点数。打印输出中不应出现单位；此处的单位规范对结果的解释具有约束力。\n\n测试套件：\n\n- 情况 $1$ (平衡分支):\n  - 节点：索引 $0$ 到 $6$，根节点为 $0$。\n  - 边及其电阻 (单位：欧姆 $\\Omega$)：$(0\\rightarrow 1, R=100)$、$(0\\rightarrow 2, R=80)$、$(1\\rightarrow 3, R=50)$、$(1\\rightarrow 4, R=70)$、$(2\\rightarrow 5, R=60)$、$(2\\rightarrow 6, R=90)$。\n  - 节点电容 (单位：法拉 $\\mathrm{F}$)：$C_0=0.2\\times 10^{-12}$、$C_1=0.3\\times 10^{-12}$、$C_2=0.25\\times 10^{-12}$、$C_3=1.0\\times 10^{-12}$、$C_4=0.6\\times 10^{-12}$、$C_5=0.9\\times 10^{-12}$、$C_6=0.5\\times 10^{-12}$。\n  - 叶节点：节点 $3,4,5,6$。\n\n- 情况 $2$ (单链边界):\n  - 节点：索引 $0$ 到 $2$，根节点为 $0$。\n  - 边及其电阻 (单位：$\\Omega$)：$(0\\rightarrow 1, R=120)$、$(1\\rightarrow 2, R=130)$。\n  - 节点电容 (单位：$\\mathrm{F}$)：$C_0=0.1\\times 10^{-12}$、$C_1=0.2\\times 10^{-12}$、$C_2=1.5\\times 10^{-12}$。\n  - 叶节点：节点 $2$。\n\n- 情况 $3$ (内部零电容边缘情况):\n  - 节点：索引 $0$ 到 $3$，根节点为 $0$。\n  - 边及其电阻 (单位：$\\Omega$)：$(0\\rightarrow 1, R=200)$、$(1\\rightarrow 2, R=50)$、$(1\\rightarrow 3, R=60)$。\n  - 节点电容 (单位：$\\mathrm{F}$)：$C_0=0.2\\times 10^{-12}$、$C_1=0.0\\times 10^{-12}$、$C_2=0.8\\times 10^{-12}$、$C_3=0.4\\times 10^{-12}$。\n  - 叶节点：节点 $2,3$。\n\n- 情况 $4$ (异构分支与深度):\n  - 节点：索引 $0$ 到 $9$，根节点为 $0$。\n  - 边及其电阻 (单位：$\\Omega$)：$(0\\rightarrow 1, R=75)$、$(1\\rightarrow 2, R=40)$、$(2\\rightarrow 3, R=30)$、$(1\\rightarrow 4, R=55)$、$(0\\rightarrow 5, R=65)$、$(5\\rightarrow 6, R=45)$、$(5\\rightarrow 7, R=35)$、$(7\\rightarrow 8, R=25)$、$(7\\rightarrow 9, R=20)$。\n  - 节点电容 (单位：$\\mathrm{F}$)：$C_0=0.15\\times 10^{-12}$、$C_1=0.2\\times 10^{-12}$、$C_2=0.05\\times 10^{-12}$、$C_3=1.2\\times 10^{-12}$、$C_4=0.7\\times 10^{-12}$、$C_5=0.25\\times 10^{-12}$、$C_6=0.9\\times 10^{-12}$、$C_7=0.1\\times 10^{-12}$、$C_8=0.4\\times 10^{-12}$、$C_9=0.3\\times 10^{-12}$。\n  - 叶节点：节点 $3,4,6,8,9$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的列表的列表，例如 $[\\,[d_{1,1},d_{1,2},\\dots],\\,[d_{2,1},\\dots],\\dots\\,]$，其中每个 $d_{i,j}$ 是一个浮点数，表示第 $i$ 个测试用例的第 $j$ 个叶节点的 Elmore 延迟（以秒为单位）。每个测试用例的结果必须按叶节点索引的升序列出叶节点延迟。",
            "solution": "计算阻容 (RC) 树叶节点的 Elmore 延迟是电气工程领域，特别是在集成电路互连分析中，一个明确定义的问题。问题陈述具有科学依据、内容完整且客观。因此，我们可以着手提供一个正式的解决方案。\n\n**1. Elmore 延迟的理论基础**\n\nElmore 延迟是 RC 电路延迟的一阶近似。对于一个线性时不变 (LTI) 系统，其在时间 $t=0$ 时对单位阶跃输入的响应与其冲激响应相关。节点 $i$ 处的 Elmore 延迟 $t_{Di}$ 定义为该节点冲激响应 $h_i(t)$ 的一阶矩：\n$$ t_{Di} = \\int_0^\\infty t h_i(t) dt $$\n可以证明，该定义等价于从电路分析中推导出的表达式。对于一个以节点 0 为根并由电压源驱动的 RC 树，任意节点 $i$ 的 Elmore 延迟由下式给出：\n$$ t_{Di} = \\sum_{k=0}^{N-1} R_{ik} C_k $$\n其中 $N$ 是树中的节点数，$C_k$ 是节点 $k$ 的电容，$R_{ik}$ 是从根节点到节点 $i$ 的路径与到节点 $k$ 的路径的公共部分的电阻。我们可以将 $R_{ik}$ 表示为共享路径上所有边 $e_j$ 的电阻之和：\n$$ R_{ik} = \\sum_{e_j \\in \\text{path}(0,i) \\cap \\text{path}(0,k)} R_j $$\n其中 $R_j$ 是边 $e_j$ 的电阻。\n\n**2. 线性时间算法的推导**\n\n对所有节点对 $(i, k)$ 进行求和的二次复杂度使得上述公式对于大型电路效率低下。通过重构求和顺序，可以推导出一个更高效的线性时间算法。通过交换求和顺序，我们可以按电阻而不是电容对项进行分组：\n$$ t_{Di} = \\sum_{k=0}^{N-1} C_k \\left( \\sum_{e_j \\in \\text{path}(0,i) \\cap \\text{path}(0,k)} R_j \\right) = \\sum_{e_j} R_j \\left( \\sum_{k \\text{ s.t. } e_j \\in \\text{path}(0,i) \\cap \\text{path}(0,k)} C_k \\right) $$\n假设一条边 $e_j$ 连接父节点 $u_j$ 和子节点 $v_j$。条件 $e_j \\in \\text{path}(0, i) \\cap \\text{path}(0, k)$ 意味着两件事：\n1.  边 $e_j$ 必须在从根节点到节点 $i$ 的路径上。\n2.  边 $e_j$ 也必须在从根节点到节点 $k$ 的路径上。这意味着节点 $k$ 必须在以 $v_j$ 为根的子树中。\n\n因此，对于到节点 $i$ 路径上的一条给定边 $e_j=(u_j, v_j)$，内部求和累加了其子节点 $v_j$ 的子树中所有节点 $k$ 的电容。这个和恰好是节点 $v_j$ 的“下游电容”，我们记作 $C_{\\text{down}}(v_j)$。\n$$ C_{\\text{down}}(v_j) = \\sum_{k \\in \\text{subtree}(v_j)} C_k $$\n将其代回，节点 $i$ 的 Elmore 延迟是从根到 $i$ 的路径上每条边的电阻与该边下游总电容的乘积之和：\n$$ t_{Di} = \\sum_{e_j=(u_j,v_j) \\in \\text{path}(0,i)} R_j \\cdot C_{\\text{down}}(v_j) $$\n这个表达式是线性时间算法的核心。它直接对应于问题描述中的“上游电阻与下游电容相结合的贡献值的路径累加”。\n\n**3. 算法设计**\n\n$t_{Di}$ 的公式揭示了一个清晰的计算依赖关系。要计算任何节点的延迟，我们需要：\n1.  路径上各个节点 $v$ 的下游电容 $C_{\\text{down}}(v)$。\n2.  路径结构本身。\n\n这表明可以采用一种在树的数据结构上进行单次遍历的两遍扫描算法，这与问题要求的“处理每个边常数次的单次深度优先搜索”相符。\n\n**第一遍：后序遍历计算下游电容**\n后序遍历（一种 DFS）天然地支持自下而上地计算下游电容。当访问一个节点 $u$ 时，我们首先递归地访问其所有子节点。从递归调用返回后，所有子节点的下游电容便已知。然后，节点 $u$ 的下游电容可以计算为其自身电容加上其所有子节点的下游电容之和：\n$$ C_{\\text{down}}(u) = C_u + \\sum_{v \\in \\text{children}(u)} C_{\\text{down}}(v) $$\n这一遍从叶节点开始，向上移动到根节点，为树中的每个节点填充 $C_{\\text{down}}$ 值的数组。\n\n**第二遍：前序遍历计算 Elmore 延迟**\n在所有 $C_{\\text{down}}$ 值都预先计算好的情况下，前序遍历（另一种 DFS）可以自上而下地计算延迟。Elmore 延迟 $t_{Di}$ 可以递归地表示。根节点的延迟 $t_{D0}$ 为 $0$。对于任何其他父节点为 $p$ 的节点 $i$，到 $i$ 的路径是到 $p$ 的路径加上边 $(p,i)$ 的延伸。因此：\n$$ t_{Di} = t_{Dp} + R_{pi} \\cdot C_{\\text{down}}(i) $$\n其中 $R_{pi}$ 是从 $p$ 到 $i$ 的边的电阻。这个递归公式允许我们通过获取其父节点的延迟并加上连接边的新贡献来计算每个节点的延迟。从根节点开始，初始延迟为 $0$ 的前序遍历完美地实现了这种自上而下的累加。\n\n**算法总结**\n1.  使用邻接表表示 RC 树，其中对于每个父节点，我们存储其子节点列表及相应的边电阻。\n2.  从根节点开始执行后序 DFS 遍历，为每个节点 $u$ 计算并存储下游电容 $C_{\\text{down}}(u)$。\n3.  从根节点开始执行前序 DFS 遍历，使用递归延迟公式和预先计算的 $C_{\\text{down}}$ 值，为每个节点 $u$ 计算并存储 Elmore 延迟 $t_{Du}$。\n4.  对于每个测试用例，提取指定叶节点的计算延迟，并按节点索引升序排列。\n\n每一遍遍历每个节点和每条边一次。总时间复杂度为 $O(N+E)$，其中 $N$ 是节点数，$E$ 是边数。对于树来说，$E=N-1$，所以复杂度为 $O(N)$，满足线性时间的要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solving of all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (balanced branching)\n        {\n            \"num_nodes\": 7,\n            \"root\": 0,\n            \"edges\": [(0, 1, 100), (0, 2, 80), (1, 3, 50), (1, 4, 70), (2, 5, 60), (2, 6, 90)],\n            \"capacitances\": [0.2e-12, 0.3e-12, 0.25e-12, 1.0e-12, 0.6e-12, 0.9e-12, 0.5e-12],\n            \"leaves\": [3, 4, 5, 6]\n        },\n        # Case 2 (single chain boundary)\n        {\n            \"num_nodes\": 3,\n            \"root\": 0,\n            \"edges\": [(0, 1, 120), (1, 2, 130)],\n            \"capacitances\": [0.1e-12, 0.2e-12, 1.5e-12],\n            \"leaves\": [2]\n        },\n        # Case 3 (internal zero capacitance edge case)\n        {\n            \"num_nodes\": 4,\n            \"root\": 0,\n            \"edges\": [(0, 1, 200), (1, 2, 50), (1, 3, 60)],\n            \"capacitances\": [0.2e-12, 0.0, 0.8e-12, 0.4e-12],\n            \"leaves\": [2, 3]\n        },\n        # Case 4 (heterogeneous branching and depth)\n        {\n            \"num_nodes\": 10,\n            \"root\": 0,\n            \"edges\": [(0, 1, 75), (1, 2, 40), (2, 3, 30), (1, 4, 55), (0, 5, 65), (5, 6, 45), (5, 7, 35), (7, 8, 25), (7, 9, 20)],\n            \"capacitances\": [0.15e-12, 0.2e-12, 0.05e-12, 1.2e-12, 0.7e-12, 0.25e-12, 0.9e-12, 0.1e-12, 0.4e-12, 0.3e-12],\n            \"leaves\": [3, 4, 6, 8, 9]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        delays = calculate_elmore_delays(\n            case[\"num_nodes\"],\n            case[\"edges\"],\n            case[\"capacitances\"],\n            case[\"root\"],\n            case[\"leaves\"]\n        )\n        all_results.append(delays)\n\n    # Format the final output string as specified\n    formatted_results = [f\"[{','.join(f'{d:.16g}' for d in res)}]\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_elmore_delays(num_nodes, edges, capacitances_list, root, leaves):\n    \"\"\"\n    Computes Elmore delays for specified a RC tree and its leaf nodes.\n    \n    The algorithm uses a two-pass DFS approach:\n    1. A post-order DFS to calculate the downstream capacitance for each node.\n    2. A pre-order DFS to calculate the Elmore delay for each node.\n    \n    Args:\n        num_nodes (int): The number of nodes in the tree (indexed 0 to num_nodes-1).\n        edges (list of tuples): Each tuple represents an edge (parent, child, resistance).\n        capacitances_list (list of float): Capacitance value for each node.\n        root (int): The index of the root node.\n        leaves (list of int): A list of indices of the leaf nodes.\n\n    Returns:\n        list of float: The Elmore delays for the leaf nodes, sorted by node index.\n    \"\"\"\n    # Adjacency list representation: adj[parent] = [(child, resistance), ...]\n    adj = [[] for _ in range(num_nodes)]\n    for parent, child, resistance in edges:\n        adj[parent].append((child, resistance))\n    \n    capacitances = np.array(capacitances_list, dtype=float)\n    downstream_capacitances = np.zeros(num_nodes, dtype=float)\n    elmore_delays = np.zeros(num_nodes, dtype=float)\n\n    # --- Pass 1: Post-order DFS to compute downstream capacitances ---\n    # Stack for iterative DFS to avoid deep recursion issues (though not critical here)\n    # The order of nodes pushed ensures post-order processing\n    visited_capacitance = [False] * num_nodes\n    dfs_order = []\n    stack = [root]\n    while stack:\n        u = stack.pop()\n        if not visited_capacitance[u]:\n            visited_capacitance[u] = True\n            dfs_order.append(u)\n            for v, _ in adj[u]:\n                stack.append(v)\n    \n    # Process nodes in reverse order of discovery (post-order traversal)\n    for u in reversed(dfs_order):\n        cap_sum = capacitances[u]\n        for v, _ in adj[u]:\n            cap_sum += downstream_capacitances[v]\n        downstream_capacitances[u] = cap_sum\n\n    # --- Pass 2: Pre-order DFS to compute Elmore delays ---\n    # Stack for iterative pre-order DFS: (node, parent_delay)\n    stack = [(root, 0.0)]\n    visited_delay = [False] * num_nodes\n    \n    while stack:\n        u, parent_delay = stack.pop()\n        \n        if visited_delay[u]:\n            continue\n        visited_delay[u] = True\n        \n        elmore_delays[u] = parent_delay\n        \n        # Add children to stack for next iteration in reverse to maintain order\n        for v, resistance in reversed(adj[u]):\n            child_delay = parent_delay + resistance * downstream_capacitances[v]\n            stack.append((v, child_delay))\n\n    # Extract delays for leaf nodes, ordered by ascending leaf index\n    leaf_delays = [elmore_delays[leaf_idx] for leaf_idx in sorted(leaves)]\n    \n    return leaf_delays\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}