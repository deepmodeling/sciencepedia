{
    "hands_on_practices": [
        {
            "introduction": "Understanding the relationship between Integral Nonlinearity ($I(k)$) and Differential Nonlinearity ($D(k)$) is fundamental to diagnosing a DAC's static performance. This first practice provides a focused, analytical exercise to solidify this connection. Using a set of hypothetical measured INL data points, you will calculate the corresponding DNL and assess the DAC for non-monotonicity, directly applying the principle that DNL is the discrete derivative of INL .",
            "id": "4262902",
            "problem": "A Digital-to-Analog Converter (DAC) of resolution $N$ codes exhibits static nonlinearity when measured under steady-state conditions. Let $V_{\\text{actual}}(k)$ denote the measured DAC output at code $k \\in \\{0,1,\\dots,2^{N}-1\\}$, and let the endpoint-fit reference line be defined by $V_{\\text{fit}}(k) = V_{\\text{actual}}(0) + k \\cdot \\text{LSB}_{e}$ where $\\text{LSB}_{e} = \\dfrac{V_{\\text{actual}}(2^{N}-1) - V_{\\text{actual}}(0)}{2^{N}-1}$. Define the Integral Nonlinearity (INL) as $I(k) = \\dfrac{V_{\\text{actual}}(k) - V_{\\text{fit}}(k)}{\\text{LSB}_{e}}$ and the Differential Nonlinearity (DNL) as $D(k) = \\dfrac{V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1)}{\\text{LSB}_{e}} - 1$, for $k \\geq 1$. These quantities are normalized to the endpoint-fit Least Significant Bit (LSB), so their units are $\\mathrm{LSB}$.\n\nConsider a $N=12$ DAC for which the measured Integral Nonlinearity (INL) values (normalized to $\\text{LSB}_{e}$) around a suspected non-monotonic region are given at the following contiguous codes:\n- $k=2045$: $I(2045)=0.1843$\n- $k=2046$: $I(2046)=0.1402$\n- $k=2047$: $I(2047)=0.0975$\n- $k=2048$: $I(2048)=-1.2389$\n- $k=2049$: $I(2049)=-1.2103$\n- $k=2050$: $I(2050)=-1.1837$\n\nStarting only from the above endpoint-fit definitions of INL and DNL, use discrete differentiation of the measured INL to determine the minimum possible Differential Nonlinearity over $k \\in \\{2046,2047,2048,2049,2050\\}$. Then assess whether any DNL must be below $-1$ $\\mathrm{LSB}$, explaining the reasoning from first principles. Report the single numeric value of the minimum DNL in $\\mathrm{LSB}$. Round your final numeric answer to four significant figures, and express the final number in $\\mathrm{LSB}$.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of Digital-to-Analog Converter (DAC) characterization, is well-posed with sufficient information for a unique solution, and is objective in its language. The definitions for Integral Nonlinearity (INL) and Differential Nonlinearity (DNL) are standard in the field of electronics and integrated circuits.\n\nThe task is to find the minimum Differential Nonlinearity, $D(k)$, for a specified range of digital codes $k$, given a set of Integral Nonlinearity, $I(k)$, values. The relationship between $D(k)$ and $I(k)$ must be derived from the provided definitions.\n\nThe definition for INL is given as:\n$$I(k) = \\frac{V_{\\text{actual}}(k) - V_{\\text{fit}}(k)}{\\text{LSB}_{e}}$$\nwhere $V_{\\text{actual}}(k)$ is the measured output voltage at code $k$, and $V_{\\text{fit}}(k)$ is the ideal voltage on an endpoint-fit line. $\\text{LSB}_{e}$ is the least significant bit size for the endpoint-fit line. From this definition, we can express the actual output voltage as:\n$$V_{\\text{actual}}(k) = I(k) \\cdot \\text{LSB}_{e} + V_{\\text{fit}}(k)$$\nThe endpoint-fit line is defined as $V_{\\text{fit}}(k) = V_{\\text{actual}}(0) + k \\cdot \\text{LSB}_{e}$. Substituting this into the expression for $V_{\\text{actual}}(k)$ yields:\n$$V_{\\text{actual}}(k) = I(k) \\cdot \\text{LSB}_{e} + V_{\\text{actual}}(0) + k \\cdot \\text{LSB}_{e}$$\nThe definition for DNL for code $k$ (where $k \\ge 1$) is given as:\n$$D(k) = \\frac{V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1)}{\\text{LSB}_{e}} - 1$$\nTo establish the relationship between $D(k)$ and $I(k)$, we first express the voltage step $V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1)$ using the expression for $V_{\\text{actual}}(k)$ derived above. For code $k$, we have:\n$$V_{\\text{actual}}(k) = I(k) \\cdot \\text{LSB}_{e} + V_{\\text{actual}}(0) + k \\cdot \\text{LSB}_{e}$$\nFor code $k-1$, we have:\n$$V_{\\text{actual}}(k-1) = I(k-1) \\cdot \\text{LSB}_{e} + V_{\\text{actual}}(0) + (k-1) \\cdot \\text{LSB}_{e}$$\nSubtracting the second equation from the first gives the voltage difference, noting that the $V_{\\text{actual}}(0)$ terms cancel:\n$$V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1) = (I(k) \\cdot \\text{LSB}_{e} - I(k-1) \\cdot \\text{LSB}_{e}) + (k \\cdot \\text{LSB}_{e} - (k-1) \\cdot \\text{LSB}_{e})$$\nFactoring out $\\text{LSB}_{e}$:\n$$V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1) = (I(k) - I(k-1)) \\cdot \\text{LSB}_{e} + (k - (k-1)) \\cdot \\text{LSB}_{e}$$\n$$V_{\\text{actual}}(k) - V_{\\text{actual}}(k-1) = (I(k) - I(k-1)) \\cdot \\text{LSB}_{e} + 1 \\cdot \\text{LSB}_{e}$$\nNow, we substitute this expression back into the definition of $D(k)$:\n$$D(k) = \\frac{(I(k) - I(k-1)) \\cdot \\text{LSB}_{e} + \\text{LSB}_{e}}{\\text{LSB}_{e}} - 1$$\nDividing the numerator by $\\text{LSB}_{e}$:\n$$D(k) = (I(k) - I(k-1)) + 1 - 1$$\nThis simplifies to the fundamental relationship between DNL and INL, which represents a discrete differentiation:\n$$D(k) = I(k) - I(k-1)$$\nWe can now use this relationship to calculate the DNL values for the specified codes $k \\in \\{2046, 2047, 2048, 2049, 2050\\}$ using the provided INL data.\n\nThe given INL data points (in units of $\\mathrm{LSB}_{e}$) are:\n$I(2045) = 0.1843$\n$I(2046) = 0.1402$\n$I(2047) = 0.0975$\n$I(2048) = -1.2389$\n$I(2049) = -1.2103$\n$I(2050) = -1.1837$\n\nWe calculate the DNL values as follows:\nFor $k=2046$:\n$D(2046) = I(2046) - I(2045) = 0.1402 - 0.1843 = -0.0441$\nFor $k=2047$:\n$D(2047) = I(2047) - I(2046) = 0.0975 - 0.1402 = -0.0427$\nFor $k=2048$:\n$D(2048) = I(2048) - I(2047) = -1.2389 - 0.0975 = -1.3364$\nFor $k=2049$:\n$D(2049) = I(2049) - I(2048) = -1.2103 - (-1.2389) = -1.2103 + 1.2389 = 0.0286$\nFor $k=2050$:\n$D(2050) = I(2050) - I(2049) = -1.1837 - (-1.2103) = -1.1837 + 1.2103 = 0.0266$\n\nThe calculated DNL values (in $\\mathrm{LSB}_{e}$) are:\n$D(2046) = -0.0441$\n$D(2047) = -0.0427$\n$D(2048) = -1.3364$\n$D(2049) = 0.0286$\n$D(2050) = 0.0266$\n\nThe problem asks for the minimum possible DNL over the specified range. By comparing the calculated values, the minimum is:\n$$\\min\\{D(k)\\} = D(2048) = -1.3364$$\nThe problem also asks to assess whether any DNL must be below $-1$ $\\mathrm{LSB}$. A DAC is guaranteed to be monotonic if its DNL is always greater than or equal to $-1$ LSB for all codes, i.e., $D(k) \\geq -1$. A DNL value less than $-1$ indicates non-monotonic behavior, where the analog output voltage decreases as the digital input code is incremented. In this case, at code $k=2048$, the DNL is $D(2048) = -1.3364$, which is less than $-1$. This confirms that the DAC is non-monotonic at this transition. The voltage step from code $2047$ to $2048$ is $V_{\\text{actual}}(2048) - V_{\\text{actual}}(2047) = (D(2048) + 1) \\cdot \\text{LSB}_e = (-1.3364 + 1) \\cdot \\text{LSB}_e = -0.3364 \\cdot \\text{LSB}_e$, which is a negative change.\n\nThe final task is to report the single numeric value of the minimum DNL, rounded to four significant figures. The minimum DNL is $-1.3364$. Rounding to four significant figures gives $-1.336$.",
            "answer": "$$\n\\boxed{-1.336}\n$$"
        },
        {
            "introduction": "While local analysis is useful, a complete picture of DAC performance requires characterizing errors across the entire code range. This computational practice challenges you to model and analyze the DNL for a full 12-bit DAC under various simulated non-ideal conditions. By generating bin widths based on different error profiles—from smooth variations to abrupt defects like a missing code—you will develop a practical feel for how different physical error sources manifest in the final DNL specification .",
            "id": "4262832",
            "problem": "Consider a Digital-to-Analog Converter (DAC) with $N$ bits, producing $2^N$ discrete output codes. Let the analog output range be from $V_{\\min}$ to $V_{\\max}$, and let the measured code transition levels be the increasing sequence $\\{T_i\\}_{i=0}^{2^N}$ where $T_0 = V_{\\min}$ and $T_{2^N} = V_{\\max}$. Code $k$ corresponds to the analog interval $\\left[T_k, T_{k+1}\\right)$ for $k \\in \\{0,1,\\dots,2^N-1\\}$. Define the ideal least significant bit (LSB) voltage resolution as $V_{\\text{LSB}} = \\dfrac{V_{\\max} - V_{\\min}}{2^N}$. The measured bin width for code $k$ is $w_k = T_{k+1} - T_k$. Differential Nonlinearity (DNL) is defined for each code $k$ as the normalized deviation of $w_k$ from the ideal bin width $V_{\\text{LSB}}$, expressed as a dimensionless number (in LSB units). You must construct the full $DNL$ array and then identify:\n- The code index $k$ with the largest positive $DNL$ value (if multiple codes share the largest value, choose the smallest $k$).\n- The code index $k$ with the largest negative $DNL$ value (i.e., the most negative; if multiple codes share it, choose the smallest $k$).\n\nUse only the canonical definitions of $V_{\\text{LSB}}$, code bin widths $\\{w_k\\}$, and the interpretation of $DNL$ as a deviation normalized by $V_{\\text{LSB}}$. Your algorithm must be derived from these definitions without relying on any additional shortcut formulas. All $DNL$ values in the final outputs must be decimal numbers in LSB units (dimensionless), not percentages.\n\nImplement the program to handle the following test suite, where each test case specifies $N$, $V_{\\min}$, $V_{\\max}$, and a generative rule for $\\{T_i\\}$ via bin widths $\\{w_k\\}$; you must construct $\\{T_i\\}$ by cumulative summation $T_0 = V_{\\min}$ and $T_{i+1} = T_i + w_i$ for all $i \\in \\{0,1,\\dots,2^N-1\\}$.\n\nTest Case $1$ (happy path, smooth variation):\n- $N = 12$.\n- $V_{\\min} = 0.0$ volts.\n- $V_{\\max} = 2.5$ volts.\n- For each $k \\in \\{0,1,\\dots,2^N-1\\}$, define $w_k = V_{\\text{LSB}} \\left(1 + 0.15 \\sin\\left(\\dfrac{2\\pi k}{1024}\\right)\\right)$. This produces $4$ complete sinusoidal cycles over $2^N = 4096$ bins and preserves $\\sum_{k=0}^{2^N-1} w_k = V_{\\max} - V_{\\min}$.\n\nTest Case $2$ (boundary condition with a missing code):\n- $N = 12$.\n- $V_{\\min} = 0.0$ volts.\n- $V_{\\max} = 1.0$ volts.\n- For each $k \\in \\{0,1,\\dots,2^N-1\\}$, initialize $w_k = V_{\\text{LSB}}$. Then set $w_{1000} = 0.0$ volts and $w_{1001} = 2 V_{\\text{LSB}}$. All other $w_k$ remain $V_{\\text{LSB}}$. This preserves $\\sum_{k=0}^{2^N-1} w_k = V_{\\max} - V_{\\min}$ while introducing one zero-width bin and one double-width bin.\n\nTest Case $3$ (edge-focused nonuniformity with mean correction):\n- $N = 12$.\n- $V_{\\min} = -0.02$ volts.\n- $V_{\\max} = 1.02$ volts.\n- For each $k \\in \\{0,1,\\dots,2^N-1\\}$, define an unnormalized modulation $a(k) = 0.20 \\exp\\left(-\\left(\\dfrac{k}{256}\\right)^2\\right) - 0.20 \\exp\\left(-\\left(\\dfrac{k - (2^N - 1)}{256}\\right)^2\\right)$. Define its sample mean $\\bar{a} = \\dfrac{1}{2^N} \\sum_{j=0}^{2^N-1} a(j)$. Then set $w_k = V_{\\text{LSB}} \\left(1 + a(k) - \\bar{a}\\right)$. This subtraction enforces $\\sum_{k=0}^{2^N-1} w_k = V_{\\max} - V_{\\min}$, and the chosen amplitude keeps $w_k$ strictly positive.\n\nYour program must compute, for each test case:\n- The complete $DNL$ array from the constructed $\\{T_i\\}$.\n- The code index with the largest positive $DNL$ value and that value.\n- The code index with the most negative $DNL$ value and that value.\n\nAngle units are not applicable in this problem. All physical quantities in inputs are in volts. Report the $DNL$ values in LSB units as decimal numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list of four items: $\\left[k_{\\text{max}}, d_{\\text{max}}, k_{\\text{min}}, d_{\\text{min}}\\right]$. For readability, round each $DNL$ value to $6$ decimal places. For example, the final output format should be $\\left[\\left[k_1,d_1,k'_1,d'_1\\right],\\left[k_2,d_2,k'_2,d'_2\\right],\\left[k_3,d_3,k'_3,d'_3\\right]\\right]$.",
            "solution": "The user-provided problem is valid and will be addressed by deriving a solution from first principles as stipulated. The problem asks for the computation of Differential Nonlinearity (DNL) for a Digital-to-Analog Converter (DAC) and the identification of codes with maximum positive and maximum negative DNL for three distinct test cases.\n\nThe solution is predicated on the canonical definitions of DAC static performance metrics. We will first formalize these definitions and then outline the computational procedure.\n\n### Fundamental Definitions\n\n1.  **Ideal LSB Voltage ($V_{\\text{LSB}}$):** For a DAC with $N$ bits of resolution, there are $M = 2^N$ discrete output codes. The analog output spans a voltage range from $V_{\\min}$ to $V_{\\max}$. The ideal step size, or Least Significant Bit (LSB) voltage, is the total range divided by the number of codes:\n    $$V_{\\text{LSB}} = \\frac{V_{\\max} - V_{\\min}}{2^N}$$\n    This represents the uniform width of each code bin in an ideal DAC.\n\n2.  **Measured Bin Width ($w_k$):** In a non-ideal DAC, the actual analog voltage step for each digital code $k$ (where $k \\in \\{0, 1, \\dots, 2^N-1\\}$) can vary. If $\\{T_i\\}_{i=0}^{2^N}$ represents the sequence of measured transition voltages where $T_0 = V_{\\min}$ and $T_{2^N} = V_{\\max}$, the width of the bin for code $k$ is:\n    $$w_k = T_{k+1} - T_k$$\n    The problem provides direct generative rules for the sequence of bin widths $\\{w_k\\}$, which is the fundamental input for DNL calculation.\n\n3.  **Differential Nonlinearity (DNL):** DNL measures the deviation of each measured bin width, $w_k$, from the ideal bin width, $V_{\\text{LSB}}$. This deviation is normalized to $V_{\\text{LSB}}$ to yield a dimensionless quantity expressed in units of LSB. The DNL for code $k$ is defined as:\n    $$DNL_k = \\frac{w_k - V_{\\text{LSB}}}{V_{\\text{LSB}}} = \\frac{w_k}{V_{\\text{LSB}}} - 1$$\n    A positive $DNL_k$ indicates that code $k$ occupies a wider-than-ideal analog voltage range, while a negative $DNL_k$ indicates a narrower range. A $DNL_k = -1$ LSB implies $w_k = 0$, a \"missing code\".\n\n### Algorithmic Procedure\n\nFor each test case, the following computational steps are executed:\n\n1.  **Parameter Initialization:** The parameters $N$, $V_{\\min}$, and $V_{\\max}$ are defined.\n2.  **Constant Calculation:** The number of codes, $M = 2^N$, and the ideal LSB voltage, $V_{\\text{LSB}}$, are computed.\n3.  **Bin Width Array Construction:** The array of measured bin widths, $\\{w_k\\}_{k=0}^{M-1}$, is generated according to the specific rule provided in the test case. All calculations are performed using high-precision floating-point arithmetic.\n4.  **DNL Array Calculation:** The DNL array, $\\{DNL_k\\}_{k=0}^{M-1}$, is computed element-wise using the formula $DNL_k = (w_k / V_{\\text{LSB}}) - 1$.\n5.  **Identification of Extrema:**\n    - The maximum positive DNL value, $d_{\\text{max}}$, is found in the DNL array. The corresponding index, $k_{\\text{max}}$, is identified. If multiple codes share the same maximum value, the smallest index is chosen as per the problem's tie-breaking rule.\n    - Similarly, the most negative DNL value, $d_{\\text{min}}$, and its corresponding smallest index, $k_{\\text{min}}$, are found.\n6.  **Result Aggregation:** The four resulting values, $[k_{\\text{max}}, d_{\\text{max}}, k_{\\text{min}}, d_{\\text{min}}]$, are collected for each test case, with the DNL values rounded to $6$ decimal places as required.\n\n### Analysis of Test Cases\n\n**Test Case 1:**\n- Parameters: $N=12$, $V_{\\min}=0.0$ V, $V_{\\max}=2.5$ V.\n- Number of codes: $2^{12} = 4096$.\n- Ideal LSB: $V_{\\text{LSB}} = (2.5 - 0.0) / 4096 \\approx 6.1035 \\times 10^{-4}$ V.\n- Bin width rule: $w_k = V_{\\text{LSB}} \\left(1 + 0.15 \\sin\\left(\\frac{2\\pi k}{1024}\\right)\\right)$.\n- DNL calculation:\n  $$DNL_k = \\frac{w_k}{V_{\\text{LSB}}} - 1 = \\frac{V_{\\text{LSB}} \\left(1 + 0.15 \\sin\\left(\\frac{2\\pi k}{1024}\\right)\\right)}{V_{\\text{LSB}}} - 1 = 0.15 \\sin\\left(\\frac{2\\pi k}{1024}\\right)$$\n- Extrema: $d_{\\text{max}}$ occurs when the sine term is $1$, giving $DNL = 0.15$. This occurs when $\\frac{2\\pi k}{1024} = \\frac{\\pi}{2}$, so $k = 256$. $d_{\\text{min}}$ occurs when the sine term is $-1$, giving $DNL = -0.15$. This occurs when $\\frac{2\\pi k}{1024} = \\frac{3\\pi}{2}$, so $k = 768$.\n- Expected result: $k_{\\text{max}}=256, d_{\\text{max}}=0.15, k_{\\text{min}}=768, d_{\\text{min}}=-0.15$.\n\n**Test Case 2:**\n- Parameters: $N=12$, $V_{\\min}=0.0$ V, $V_{\\max}=1.0$ V.\n- Number of codes: $2^{12} = 4096$.\n- Ideal LSB: $V_{\\text{LSB}} = (1.0 - 0.0) / 4096 \\approx 2.4414 \\times 10^{-4}$ V.\n- Bin width rule: $w_k = V_{\\text{LSB}}$ for $k \\notin \\{1000, 1001\\}$, $w_{1000} = 0.0$ V, and $w_{1001} = 2V_{\\text{LSB}}$.\n- DNL calculation:\n  - For $k \\notin \\{1000, 1001\\}$: $DNL_k = \\frac{V_{\\text{LSB}}}{V_{\\text{LSB}}} - 1 = 0$.\n  - For $k = 1000$: $DNL_{1000} = \\frac{0.0}{V_{\\text{LSB}}} - 1 = -1.0$.\n  - For $k = 1001$: $DNL_{1001} = \\frac{2V_{\\text{LSB}}}{V_{\\text{LSB}}} - 1 = 1.0$.\n- Extrema: The maximum DNL is uniquely $1.0$ at $k=1001$. The minimum DNL is uniquely $-1.0$ at $k=1000$.\n- Expected result: $k_{\\text{max}}=1001, d_{\\text{max}}=1.0, k_{\\text{min}}=1000, d_{\\text{min}}=-1.0$.\n\n**Test Case 3:**\n- Parameters: $N=12$, $V_{\\min}=-0.02$ V, $V_{\\max}=1.02$ V.\n- Total range: $1.02 - (-0.02) = 1.04$ V.\n- Number of codes: $2^{12} = 4096$.\n- Ideal LSB: $V_{\\text{LSB}} = 1.04 / 4096 = 2.5390625 \\times 10^{-4}$ V.\n- Bin width rule: $w_k = V_{\\text{LSB}} (1 + a(k) - \\bar{a})$, where $a(k) = 0.20 \\exp\\left(-\\left(\\frac{k}{256}\\right)^2\\right) - 0.20 \\exp\\left(-\\left(\\frac{k - 4095}{256}\\right)^2\\right)$ and $\\bar{a}$ is the mean of $a(k)$.\n- DNL calculation:\n  $$DNL_k = \\frac{w_k}{V_{\\text{LSB}}} - 1 = \\frac{V_{\\text{LSB}} (1 + a(k) - \\bar{a})}{V_{\\text{LSB}}} - 1 = a(k) - \\bar{a}$$\n- Extrema: The function $a(k)$ is a superposition of a positive Gaussian-like term centered at $k=0$ and a negative Gaussian-like term centered at $k=4095$. Maxima are sought by numerical evaluation of the full $DNL_k$ array. Due to the properties of the exponential function, the maximum of $a(k)$ will occur at $k=0$ and the minimum at $k=4095$. The mean $\\bar{a}$ can be shown to be zero due to the antisymmetry of $a(k)$ about the midpoint of the code range, although the implementation will compute it numerically for precision.\n- Expected result:\n  - $k_{\\text{max}}=0$, $d_{\\text{max}} = a(0) - \\bar{a}$.\n  - $k_{\\text{min}}=4095$, $d_{\\text{min}} = a(4095) - \\bar{a}$.\n  Numerical computation is required for the exact values.\n\nThe following Python program implements this procedure.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DAC DNL problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 12,\n            \"V_min\": 0.0,\n            \"V_max\": 2.5,\n            \"type\": \"sinusoidal\"\n        },\n        {\n            \"N\": 12,\n            \"V_min\": 0.0,\n            \"V_max\": 1.0,\n            \"type\": \"missing_code\"\n        },\n        {\n            \"N\": 12,\n            \"V_min\": -0.02,\n            \"V_max\": 1.02,\n            \"type\": \"edge_nonuniformity\"\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case[\"N\"]\n        V_min = case[\"V_min\"]\n        V_max = case[\"V_max\"]\n        \n        num_codes = 2**N\n        v_lsb = (V_max - V_min) / num_codes\n        \n        k = np.arange(num_codes)\n        \n        # 1. Generate the array of measured bin widths (w_k)\n        if case[\"type\"] == \"sinusoidal\":\n            # For each k in {0,1,...,2^N-1}, define w_k = V_LSB * (1 + 0.15 * sin(2*pi*k/1024)).\n            w_k = v_lsb * (1 + 0.15 * np.sin(2 * np.pi * k / 1024))\n        \n        elif case[\"type\"] == \"missing_code\":\n            # Initialize w_k = V_LSB. Then set w_1000 = 0.0 V and w_1001 = 2 * V_LSB.\n            w_k = np.full(num_codes, v_lsb)\n            w_k[1000] = 0.0\n            w_k[1001] = 2 * v_lsb\n            \n        elif case[\"type\"] == \"edge_nonuniformity\":\n            # Define an unnormalized modulation a(k)\n            a_k = 0.20 * np.exp(-((k / 256.0)**2)) - 0.20 * np.exp(-(((k - (num_codes - 1)) / 256.0)**2))\n            # Define its sample mean a_bar\n            a_bar = np.mean(a_k)\n            # Then set w_k = V_LSB * (1 + a(k) - a_bar).\n            w_k = v_lsb * (1 + a_k - a_bar)\n        \n        # 2. Calculate the DNL array\n        # DNL_k = (w_k - V_LSB) / V_LSB = w_k / V_LSB - 1\n        dnl_k = w_k / v_lsb - 1\n        \n        # 3. Find the code with the largest positive DNL\n        d_max = np.max(dnl_k)\n        k_max = np.argmax(dnl_k) # argmax returns the first index of the maximum value\n        \n        # 4. Find the code with the largest negative (most negative) DNL\n        d_min = np.min(dnl_k)\n        k_min = np.argmin(dnl_k) # argmin returns the first index of the minimum value\n        \n        # Append results for this case\n        results.append([k_max, d_max, k_min, d_min])\n\n    # Final print statement in the exact required format.\n    # [[k_1_max, d_1_max, k_1_min, d_1_min],[k_2_max, d_2_max, k_2_min, d_2_min],...]\n    # DNL values rounded to 6 decimal places.\n    inner_strings = [\n        f\"[{item[0]},{item[1]:.6f},{item[2]},{item[3]:.6f}]\" \n        for item in results\n    ]\n    print(f\"[{','.join(inner_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Static errors like INL do not exist in a vacuum; they directly degrade the dynamic performance of a DAC when it processes a time-varying signal. This final, integrative practice bridges the gap between the static and dynamic domains. You will use a given INL error profile to simulate a DAC's time-domain output for a sinusoidal input, and then employ Fourier analysis to predict the resulting harmonic distortion, demonstrating how static nonlinearity generates unwanted spectral spurs .",
            "id": "4262912",
            "problem": "A unipolar Digital-to-Analog Converter (DAC) with resolution of $N$ bits maps a digital input code $m \\in \\{0,1,\\dots,2^N-1\\}$ to an analog output. Let the full-scale output be normalized to $V_{\\mathrm{FS}} = 1$ (dimensionless unit), so that the ideal least significant bit size is $V_{\\mathrm{LSB}} = \\dfrac{V_{\\mathrm{FS}}}{2^N-1}$. A measured best-fit Integral Nonlinearity (INL) is provided as a dimensionless array $E[m]$ in units of least significant bits (LSBs), for each code $m$. The actual static transfer characteristic is modeled as\n$$\nv(m) = V_{\\mathrm{LSB}} \\cdot \\big(m + E[m]\\big).\n$$\nConsider a discrete-time periodic stimulus that drives the DAC with a quantized digital sine wave at $f_0$ that is coherent with the record length. Let the record have $L$ samples per period, and suppose there are $k$ sinusoidal cycles within $L$ samples. The input code sequence $m[n]$ is formed by quantizing a centered sinusoid with amplitude specified as a fraction $a$ of the half-scale range in units of codes:\n$$\nm_{\\mathrm{mid}} = \\dfrac{2^N - 1}{2}, \\quad A_{\\mathrm{codes}} = a \\cdot \\dfrac{2^N - 1}{2},\n$$\n$$\nm[n] = \\mathrm{clip}\\Big(\\mathrm{round}\\big(m_{\\mathrm{mid}} + A_{\\mathrm{codes}}\\cdot \\sin(2\\pi k n / L)\\big),\\,0,\\,2^N-1\\Big),\n$$\nfor $n = 0,1,\\dots,L-1$. The corresponding discrete-time DAC output sequence is\n$$\nx[n] = V_{\\mathrm{LSB}} \\cdot \\big(m[n] + E[m[n]]\\big).\n$$\nTo approximate the continuous-time Zero-Order Hold (ZOH) output, use discrete-time convolution by first upsampling $x[n]$ by an integer factor $U$ via zero-stuffing to obtain $x_{\\uparrow}[n]$ and then convolving with a rectangular kernel $h[n]$ of length $U$ with unity coefficients:\n$$\nx_{\\uparrow}[n] = \\begin{cases}\nx[n/U], & \\text{if } n \\text{ is a multiple of } U,\\\\\n0, & \\text{otherwise},\n\\end{cases}\n\\quad\nh[n] = \\begin{cases}\n1, & 0 \\le n \\le U-1,\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nUse circular convolution to preserve periodicity:\n$$\ny[n] = (x_{\\uparrow} \\circledast h)[n],\n$$\nwith period $L_{\\uparrow} = L\\cdot U$, producing a length-$L_{\\uparrow}$ sequence $y[n]$. Remove the mean from $y[n]$ and compute the Discrete Fourier Transform (DFT) over one period. Let the fundamental bin index be $k_0 = k$ and the $i$-th harmonic bin index be $i\\cdot k_0$. For $i \\in \\{1,2,3,4,5\\}$, estimate the linear amplitude $A_i$ of the $i$-th harmonic (as a fraction of $V_{\\mathrm{FS}}$) from the DFT magnitude by\n$$\nA_i = \\dfrac{2}{L_{\\uparrow}} \\cdot \\left|Y[i\\cdot k_0]\\right|.\n$$\nYour task is to implement this procedure and return the first five harmonic amplitudes for several parameter sets. Express all amplitudes as dimensionless linear fractions of $V_{\\mathrm{FS}}$ (no unit, and not as percentages).\n\nUse the following test suite. For each case, use the specified resolution $N$, record length $L$, cycles per record $k$, amplitude fraction $a$, upsampling factor $U$, and best-fit INL $E[m]$ defined for all integer codes $m \\in \\{0,1,\\dots,2^N-1\\}$:\n\n- Test case A:\n  - $N = 6$, $L = 1024$, $k = 13$, $a = 0.49$, $U = 8$.\n  - $E[m]$ given by the formula\n    $$\n    E_A[m] = 0.35\\cdot \\sin\\!\\Big(\\dfrac{2\\pi m}{64}\\Big) + 0.08\\cdot \\sin\\!\\Big(\\dfrac{2\\pi \\cdot 7 \\, m}{64}\\Big) - 0.02,\n    $$\n    for $m = 0,1,\\dots,63$.\n\n- Test case B:\n  - $N = 6$, $L = 1024$, $k = 17$, $a = 0.4375$, $U = 8$.\n  - $E[m]$ given by the formula\n    $$\n    E_B[m] = 0.30\\cdot \\cos\\!\\Big(\\dfrac{2\\pi m}{64}\\Big) + 0.12\\cdot \\sin\\!\\Big(\\dfrac{2\\pi \\cdot 3 \\, m}{64}\\Big) - 0.06\\cdot \\sin\\!\\Big(\\dfrac{2\\pi \\cdot 2 \\, m}{64}\\Big),\n    $$\n    for $m = 0,1,\\dots,63$.\n\n- Test case C:\n  - $N = 6$, $L = 1024$, $k = 31$, $a = 0.25$, $U = 8$.\n  - $E[m]$ given by\n    $$\n    E_C[m] = 0,\n    $$\n    for $m = 0,1,\\dots,63$.\n\nYour program should compute $[A_1,A_2,A_3,A_4,A_5]$ for each test case using the procedure described above. The final output must be a single line containing a list of three lists, each inner list containing the five harmonic amplitudes (in the order $i=1$ to $i=5$), formatted as a comma-separated list enclosed in square brackets, for example:\n$$\n\\big[\\,[A^{(A)}_1,A^{(A)}_2,A^{(A)}_3,A^{(A)}_4,A^{(A)}_5],\\,[A^{(B)}_1,A^{(B)}_2,A^{(B)}_3,A^{(B)}_4,A^{(B)}_5],\\,[A^{(C)}_1,A^{(C)}_2,A^{(C)}_3,A^{(C)}_4,A^{(C)}_5]\\,\\big].\n$$",
            "solution": "The task is to predict harmonic amplitudes of a Digital-to-Analog Converter (DAC) output subjected to a quantized sinusoidal code sequence in the presence of measured best-fit Integral Nonlinearity (INL). The solution must begin from the fundamental definitions of resolution, least significant bit size, static transfer, and the relation between the discrete-time Fourier transform and sinusoidal amplitudes.\n\n1. Fundamental quantities. For a unipolar $N$-bit DAC, the code range is $m \\in \\{0,1,\\dots,2^N-1\\}$. With $V_{\\mathrm{FS}} = 1$, the ideal least significant bit size is\n$$\nV_{\\mathrm{LSB}} = \\dfrac{V_{\\mathrm{FS}}}{2^N - 1}.\n$$\nA best-fit Integral Nonlinearity $E[m]$ given in units of LSBs perturbs the ideal transfer such that the actual static output when code $m$ is applied is\n$$\nv(m) = V_{\\mathrm{LSB}}\\cdot\\big(m + E[m]\\big).\n$$\n\n2. Input code sequence for a coherent sinusoid. A discrete-time sinusoid that completes $k$ cycles over $L$ samples has argument $2\\pi k n/L$ at sample index $n$. To center the code sequence around midscale and avoid clipping, use\n$$\nm_{\\mathrm{mid}} = \\dfrac{2^N - 1}{2}, \\quad A_{\\mathrm{codes}} = a \\cdot \\dfrac{2^N - 1}{2},\n$$\nwhere $a$ is the desired amplitude as a fraction of half-scale. The ideal real-valued code before quantization is $m_{\\mathrm{mid}} + A_{\\mathrm{codes}}\\sin(2\\pi k n/L)$. The applied code sequence is obtained by rounding to the nearest integer and clipping to the valid range:\n$$\nm[n] = \\mathrm{clip}\\Big(\\mathrm{round}\\big(m_{\\mathrm{mid}} + A_{\\mathrm{codes}}\\sin(2\\pi k n / L)\\big),\\,0,\\,2^N-1\\Big).\n$$\nThis choice ensures coherent sampling, i.e., an integer number of cycles $k$ within $L$ samples, leading to discrete spectral lines precisely on DFT bins.\n\n3. Static DAC output sequence. The actual discrete-time output sequence that includes INL is\n$$\nx[n] = V_{\\mathrm{LSB}} \\cdot \\big(m[n] + E[m[n]]\\big).\n$$\nThis expression follows directly from the static transfer characteristic applied to the time-varying code $m[n]$.\n\n4. Zero-Order Hold (ZOH) via discrete-time convolution. The continuous-time reconstruction by a hold circuit can be approximated in discrete-time by upsampling and convolution with a rectangular kernel. First, upsample by inserting $U-1$ zeros between samples (zero-stuffing), defining\n$$\nx_{\\uparrow}[n] = \\begin{cases}\nx[n/U], & n \\equiv 0 \\ (\\mathrm{mod}\\ U),\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nThen convolve with a length-$U$ rectangular kernel\n$$\nh[n] = \\begin{cases}\n1, & 0 \\le n \\le U-1,\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nLinear convolution with $h[n]$ creates a sequence of constant plateaus of length $U$ samples equal to each original sample, which is the discrete-time analog of zero-order hold. To maintain periodicity and avoid spectral leakage, use circular convolution over a period of $L_{\\uparrow} = L\\cdot U$. A practical way to implement circular convolution is to compute the full linear convolution $x_{\\uparrow} * h$ of length $L_{\\uparrow} + U - 1$, then fold the trailing $U - 1$ samples back into the beginning by addition:\n$$\ny[n] = \\big((x_{\\uparrow} * h)[n]\\big) + \\big((x_{\\uparrow} * h)[n + L_{\\uparrow}]\\big), \\quad 0 \\le n \\le L_{\\uparrow}-1,\n$$\nsince $(x_{\\uparrow} * h)[n]$ is zero outside the range $0 \\le n \\le L_{\\uparrow} + U - 2$.\n\n5. Harmonic amplitude estimation from the Discrete Fourier Transform. The mean (direct current) is removed to isolate alternating components:\n$$\n\\tilde{y}[n] = y[n] - \\dfrac{1}{L_{\\uparrow}} \\sum_{n=0}^{L_{\\uparrow}-1} y[n].\n$$\nCompute the Discrete Fourier Transform (DFT) of $\\tilde{y}[n]$ to obtain $Y[\\ell]$ for frequency bins $\\ell = 0,1,\\dots,L_{\\uparrow}-1$. Because the stimulus completes $k$ cycles in $L$ samples before upsampling, it also completes $k$ cycles in $L_{\\uparrow}$ samples after upsampling by $U$, so the fundamental bin index is $k_0 = k$. The $i$-th harmonic occurs at bin index $i\\cdot k_0$ for $i \\in \\{1,2,3,4,5\\}$. For a coherent sinusoid, the single-tone amplitude in linear units is related to the DFT magnitude by\n$$\nA_i = \\dfrac{2}{L_{\\uparrow}} \\cdot \\left| Y[i\\cdot k_0] \\right|.\n$$\nThis follows from the standard property that for a real sinusoid $s[n] = A \\sin(2\\pi k_0 n/L_{\\uparrow})$, the DFT satisfies $\\left|S[k_0]\\right| = \\dfrac{A L_{\\uparrow}}{2}$ in the absence of windowing. Since $x[n]$ is expressed in units of $V_{\\mathrm{FS}}$ and $V_{\\mathrm{FS}} = 1$, the amplitudes $A_i$ are already dimensionless fractions of full-scale.\n\n6. Algorithmic steps.\n- For each test case, construct $E[m]$ from the given formula for all $m$ in the code range.\n- Generate $m[n]$ for $n = 0,1,\\dots,L-1$ using rounding and clipping of the centered sinusoid.\n- Compute $x[n]$ using $V_{\\mathrm{LSB}} = 1/(2^N - 1)$ and the INL lookup $E[m[n]]$.\n- Perform discrete-time ZOH by zero-stuffing $x[n]$ by factor $U$ to create $x_{\\uparrow}[n]$, then convolving with $h[n]$ and folding the tail to implement circular convolution, resulting in $y[n]$ of length $L_{\\uparrow} = L\\cdot U$.\n- Subtract the mean of $y[n]$, compute the DFT (a real-valued fast Fourier transform can be used), and extract $A_i$ at bins $i\\cdot k_0$ for $i = 1,\\dots,5$ using $A_i = \\dfrac{2}{L_{\\uparrow}} \\cdot \\left| Y[i\\cdot k_0] \\right|$.\n- Return the list $[A_1,A_2,A_3,A_4,A_5]$ for each test case.\n\n7. Edge and coverage considerations. Coherent sampling with integer $k$ and $L$ avoids spectral leakage, enabling exact bin picking. The case with $E[m] = 0$ isolates quantization-induced distortion and ZOH effects. Nonzero $E[m]$ introduces additional static nonlinearity that generally produces both even and odd harmonics. Using $U > 1$ models the ZOH bandwidth limitation via the rectangular convolution, shaping the harmonic amplitudes.\n\nThe final program follows these steps precisely and prints a single line containing a list of three lists with five floating-point amplitudes each, one inner list per test case, in the required order and units.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_inl(case_name: str, N_bits: int) -> np.ndarray:\n    \"\"\"\n    Generate best-fit INL E[m] in LSB units for all codes m=0..2^N-1\n    according to the formulas specified in the problem statement.\n    \"\"\"\n    max_code = (1 << N_bits) - 1\n    m = np.arange(max_code + 1, dtype=float)\n    if case_name == 'A':\n        # E_A[m] = 0.35*sin(2*pi*m/64) + 0.08*sin(2*pi*7*m/64) - 0.02\n        E = 0.35 * np.sin(2.0 * np.pi * m / 64.0) \\\n            + 0.08 * np.sin(2.0 * np.pi * 7.0 * m / 64.0) \\\n            - 0.02\n    elif case_name == 'B':\n        # E_B[m] = 0.30*cos(2*pi*m/64) + 0.12*sin(2*pi*3*m/64) - 0.06*sin(2*pi*2*m/64)\n        E = 0.30 * np.cos(2.0 * np.pi * m / 64.0) \\\n            + 0.12 * np.sin(2.0 * np.pi * 3.0 * m / 64.0) \\\n            - 0.06 * np.sin(2.0 * np.pi * 2.0 * m / 64.0)\n    elif case_name == 'C':\n        E = np.zeros_like(m)\n    else:\n        raise ValueError(\"Unknown case name\")\n    return E\n\ndef generate_code_sequence(N_bits: int, L: int, k: int, a: float) -> np.ndarray:\n    \"\"\"\n    Generate quantized code sequence m[n] for a centered sinusoidal stimulus.\n    \"\"\"\n    max_code = (1 << N_bits) - 1\n    m_mid = max_code / 2.0\n    A_codes = a * (max_code / 2.0)\n    n = np.arange(L, dtype=float)\n    m_float = m_mid + A_codes * np.sin(2.0 * np.pi * k * n / L)\n    m_quant = np.rint(m_float)  # round to nearest integer\n    m_quant = np.clip(m_quant, 0, max_code)\n    return m_quant.astype(int)\n\ndef dac_output_sequence(m_seq: np.ndarray, E: np.ndarray, N_bits: int) -> np.ndarray:\n    \"\"\"\n    Map code sequence to DAC output including INL, normalized to FS=1.\n    v[n] = V_LSB * (m[n] + E[m[n]]), with V_LSB = 1/(2^N - 1).\n    \"\"\"\n    V_LSB = 1.0 / ((1 << N_bits) - 1)\n    # Lookup INL for each code in sequence\n    inl_vals = E[m_seq]\n    v = V_LSB * (m_seq.astype(float) + inl_vals)\n    return v\n\ndef zoh_via_circular_convolution(x: np.ndarray, U: int) -> np.ndarray:\n    \"\"\"\n    Implement ZOH by zero-stuffing factor U and circular convolution\n    with a rectangular kernel of length U with ones.\n    Returns y of length L_up = len(x)*U.\n    \"\"\"\n    L = x.shape[0]\n    L_up = L * U\n    # Zero-stuff upsampling: non-zeros at positions n*U\n    x_up = np.zeros(L_up, dtype=float)\n    x_up[::U] = x\n    # Rectangular kernel of ones\n    h = np.ones(U, dtype=float)\n    # Linear convolution full length\n    conv_full = np.convolve(x_up, h, mode='full')  # length L_up + U - 1\n    # Fold tail to implement circular convolution over period L_up\n    y = conv_full[:L_up].copy()\n    tail = conv_full[L_up:]\n    if tail.size > 0:\n        y[:tail.size] += tail\n    return y\n\ndef harmonic_amplitudes(y: np.ndarray, k0: int, num_harmonics: int) -> list:\n    \"\"\"\n    Compute first num_harmonics harmonic amplitudes from sequence y using DFT.\n    Remove mean, then compute real FFT and pick bins i*k0.\n    \"\"\"\n    # Remove DC\n    y0 = y - np.mean(y)\n    N = y0.shape[0]\n    Y = np.fft.rfft(y0)\n    amps = []\n    for i in range(1, num_harmonics + 1):\n        idx = i * k0\n        if idx <= N // 2:\n            mag = np.abs(Y[idx])\n            A_i = (2.0 * mag) / N\n        else:\n            # If harmonic index exceeds Nyquist, return 0.0\n            A_i = 0.0\n        amps.append(float(A_i))\n    return amps\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (case_name, N_bits, L, k, a, U)\n    test_cases = [\n        ('A', 6, 1024, 13, 0.49, 8),\n        ('B', 6, 1024, 17, 0.4375, 8),\n        ('C', 6, 1024, 31, 0.25, 8),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_name, N_bits, L, k, a, U = case\n        # Generate INL\n        E = generate_inl(case_name, N_bits)\n        # Code sequence\n        m_seq = generate_code_sequence(N_bits, L, k, a)\n        # DAC output including INL\n        x = dac_output_sequence(m_seq, E, N_bits)\n        # ZOH via circular convolution\n        y = zoh_via_circular_convolution(x, U)\n        # Harmonic amplitudes\n        amps = harmonic_amplitudes(y, k0=k, num_harmonics=5)\n        results.append(amps)\n\n    # Final print statement in the exact required format.\n    # Nested list printed in Python list syntax.\n    print(str(results).replace(' ', ''))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}