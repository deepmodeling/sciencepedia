{
    "hands_on_practices": [
        {
            "introduction": "A deep understanding of any circuit begins with its fundamental equations. This practice challenges you to derive the expression for a bandgap reference voltage and analyze its sensitivity to key design parameters through symbolic differentiation. By performing this analysis (), you will gain crucial insights into how factors like resistor ratios, BJT device geometry, and amplifier gain influence the final output, forming the theoretical bedrock for robust design.",
            "id": "4257169",
            "problem": "An analog bandgap reference in an integrated circuit is built from two matched Bipolar Junction Transistors (BJT) biased at different current densities and a resistor network, closed by a high-gain operational amplifier. In the conventional topology, one BJT operates at current density scaled by an emitter-area ratio, producing a difference in base-emitter voltage that is exploited to generate a Proportional To Absolute Temperature (PTAT) voltage, which is then scaled by a resistor ratio and summed with a base-emitter voltage to synthesize a temperature-insensitive reference. Consider the following modeling assumptions, grounded in first principles and well-tested formulas.\n\n1. The thermal voltage is $V_{T} = \\frac{k_{B} T}{q}$, where $k_{B}$ is the Boltzmann constant, $q$ is the elementary charge, and $T$ is the absolute temperature. Throughout this problem, treat $T$ as fixed.\n\n2. The BJT base-emitter voltage follows $V_{BE} = V_{T} \\ln\\!\\left(\\frac{I_{C}}{I_{S}}\\right)$, where $I_{C}$ is the collector current and $I_{S}$ is the saturation current. Assume $I_{C}$ is fixed by a bias network independent of the parameters varied here.\n\n3. The PTAT generator uses two BJTs with emitter-area ratio $N$ (with $N > 1$), producing $\\Delta V_{BE} = V_{T} \\ln(N)$ across a resistor $R_{1}$, thereby setting a current $I_{PTAT} = \\frac{V_{T} \\ln(N)}{R_{1}}$. The PTAT voltage developed across $R_{2}$ is $V_{PTAT} = I_{PTAT} R_{2}$. Define the resistor ratio $m = \\frac{R_{2}}{R_{1}}$.\n\n4. The operational amplifier has finite Direct Current (DC) gain $A_{0}$, and the PTAT path is arranged in a near-unity-gain feedback configuration such that the closed-loop scaling of the PTAT term is reduced by the canonical factor $\\alpha(A_{0}) = \\frac{A_{0}}{1 + A_{0}}$. This approximation is appropriate for a high-gain amplifier in a unity-feedback-like loop, and neglects higher-order effects such as finite bandwidth and output resistance.\n\nUnder these assumptions, the reference voltage can be modeled as the sum of a base-emitter voltage and a scaled PTAT term. Starting from the physical definitions above, first derive the functional dependence of the reference voltage $V_{ref}$ on the parameters $m$, $N$, $I_{S}$, and $A_{0}$, keeping $T$ and $I_{C}$ fixed. Then, perform a symbolic sensitivity analysis: compute the four partial derivatives $\\frac{\\partial V_{ref}}{\\partial m}$, $\\frac{\\partial V_{ref}}{\\partial N}$, $\\frac{\\partial V_{ref}}{\\partial I_{S}}$, and $\\frac{\\partial V_{ref}}{\\partial A_{0}}$.\n\nExpress the final result as a single row vector containing these four partial derivatives in the order $\\left(\\frac{\\partial V_{ref}}{\\partial m}, \\frac{\\partial V_{ref}}{\\partial N}, \\frac{\\partial V_{ref}}{\\partial I_{S}}, \\frac{\\partial V_{ref}}{\\partial A_{0}}\\right)$. No numerical evaluation is required. No rounding is required. Do not include units in the final expressions.",
            "solution": "The problem has been validated and is deemed scientifically grounded, well-posed, and objective. All assumptions and definitions are standard in the field of analog integrated circuit design and form a self-contained, consistent set of statements. The problem requires a standard sensitivity analysis, which is a formalizable and meaningful task. Therefore, I will proceed with the derivation of the solution.\n\nThe objective is to first derive the expression for the reference voltage $V_{ref}$ and then compute its partial derivatives with respect to the parameters $m$, $N$, $I_{S}$, and $A_{0}$.\n\nFirst, we construct the expression for the reference voltage, $V_{ref}$. The problem states that $V_{ref}$ is the sum of a base-emitter voltage, $V_{BE}$, and a scaled Proportional To Absolute Temperature (PTAT) term.\n\nThe base-emitter voltage is given by the standard BJT model:\n$$V_{BE} = V_{T} \\ln\\left(\\frac{I_{C}}{I_{S}}\\right)$$\nwhere $V_{T} = \\frac{k_{B} T}{q}$ is the thermal voltage, $I_{C}$ is the collector current, and $I_{S}$ is the saturation current. Both $V_{T}$ and $I_{C}$ are treated as fixed parameters for this analysis.\n\nNext, we construct the PTAT voltage term, $V_{PTAT}$. It is generated from the difference in base-emitter voltages of two BJTs with an emitter-area ratio $N$. This difference is given as:\n$$\\Delta V_{BE} = V_{T} \\ln(N)$$\nThis voltage is applied across a resistor $R_{1}$ to generate a PTAT current:\n$$I_{PTAT} = \\frac{\\Delta V_{BE}}{R_{1}} = \\frac{V_{T} \\ln(N)}{R_{1}}$$\nThis current then flows through a resistor $R_{2}$ to produce the PTAT voltage:\n$$V_{PTAT} = I_{PTAT} R_{2} = \\left(\\frac{V_{T} \\ln(N)}{R_{1}}\\right) R_{2}$$\nUsing the defined resistor ratio $m = \\frac{R_{2}}{R_{1}}$, the expression for $V_{PTAT}$ simplifies to:\n$$V_{PTAT} = m V_{T} \\ln(N)$$\nThe problem specifies that this PTAT voltage is scaled by a factor $\\alpha(A_{0})$ due to the finite DC gain $A_{0}$ of the operational amplifier. The scaling factor is provided as:\n$$\\alpha(A_{0}) = \\frac{A_{0}}{1 + A_{0}}$$\nThe scaled PTAT term is therefore $\\alpha(A_{0}) V_{PTAT}$.\n\nThe total reference voltage $V_{ref}$ is the sum of $V_{BE}$ and the scaled $V_{PTAT}$:\n$$V_{ref} = V_{BE} + \\alpha(A_{0}) V_{PTAT}$$\nSubstituting the expressions for each component, we obtain the full functional dependence of $V_{ref}$ on the specified parameters:\n$$V_{ref}(m, N, I_{S}, A_{0}) = V_{T} \\ln\\left(\\frac{I_{C}}{I_{S}}\\right) + \\frac{A_{0}}{1 + A_{0}} m V_{T} \\ln(N)$$\nThis expression can be expanded for easier differentiation:\n$$V_{ref} = V_{T} \\left( \\ln(I_{C}) - \\ln(I_{S}) \\right) + \\frac{A_{0}}{1 + A_{0}} m V_{T} \\ln(N)$$\n\nNow, we perform the sensitivity analysis by computing the four required partial derivatives.\n\n1.  Partial derivative with respect to $m$:\nIn this differentiation, all other variables ($N$, $I_{S}$, $A_{0}$) and constants ($V_{T}$, $I_{C}$) are held constant.\n$$\\frac{\\partial V_{ref}}{\\partial m} = \\frac{\\partial}{\\partial m} \\left[ V_{T} \\left( \\ln(I_{C}) - \\ln(I_{S}) \\right) + \\frac{A_{0}}{1 + A_{0}} m V_{T} \\ln(N) \\right]$$\nThe first term is independent of $m$, so its derivative is $0$.\n$$\\frac{\\partial V_{ref}}{\\partial m} = \\frac{A_{0}}{1 + A_{0}} V_{T} \\ln(N) \\frac{\\partial}{\\partial m}(m) = \\frac{A_{0}}{1 + A_{0}} V_{T} \\ln(N)$$\n\n2.  Partial derivative with respect to $N$:\nHere, we treat $m$, $I_{S}$, and $A_{0}$ as constants.\n$$\\frac{\\partial V_{ref}}{\\partial N} = \\frac{\\partial}{\\partial N} \\left[ V_{T} \\left( \\ln(I_{C}) - \\ln(I_{S}) \\right) + \\frac{A_{0}}{1 + A_{0}} m V_{T} \\ln(N) \\right]$$\nThe first term is independent of $N$. We use the rule $\\frac{d}{dx}\\ln(x) = \\frac{1}{x}$.\n$$\\frac{\\partial V_{ref}}{\\partial N} = \\frac{A_{0}}{1 + A_{0}} m V_{T} \\frac{\\partial}{\\partial N}(\\ln(N)) = \\frac{A_{0}}{1 + A_{0}} m V_{T} \\frac{1}{N}$$\n$$\\frac{\\partial V_{ref}}{\\partial N} = \\frac{m V_{T} A_{0}}{N(1 + A_{0})}$$\n\n3.  Partial derivative with respect to $I_{S}$:\nHere, we treat $m$, $N$, and $A_{0}$ as constants.\n$$\\frac{\\partial V_{ref}}{\\partial I_{S}} = \\frac{\\partial}{\\partial I_{S}} \\left[ V_{T} \\left( \\ln(I_{C}) - \\ln(I_{S}) \\right) + \\frac{A_{0}}{1 + A_{0}} m V_{T} \\ln(N) \\right]$$\nThe second term is independent of $I_{S}$.\n$$\\frac{\\partial V_{ref}}{\\partial I_{S}} = V_{T} \\frac{\\partial}{\\partial I_{S}}( \\ln(I_{C}) - \\ln(I_{S}) ) = V_{T} \\left( 0 - \\frac{1}{I_{S}} \\right)$$\n$$\\frac{\\partial V_{ref}}{\\partial I_{S}} = -\\frac{V_{T}}{I_{S}}$$\n\n4.  Partial derivative with respect to $A_{0}$:\nHere, we treat $m$, $N$, and $I_{S}$ as constants.\n$$\\frac{\\partial V_{ref}}{\\partial A_{0}} = \\frac{\\partial}{\\partial A_{0}} \\left[ V_{T} \\left( \\ln(I_{C}) - \\ln(I_{S}) \\right) + \\frac{A_{0}}{1 + A_{0}} m V_{T} \\ln(N) \\right]$$\nThe first term is independent of $A_{0}$. The differentiation requires the quotient rule for the term $\\frac{A_{0}}{1 + A_{0}}$.\nLet $u = A_{0}$ and $v = 1 + A_{0}$. Then $u' = 1$ and $v' = 1$.\n$$\\frac{\\partial}{\\partial A_{0}}\\left( \\frac{A_{0}}{1 + A_{0}} \\right) = \\frac{u'v - uv'}{v^{2}} = \\frac{1(1 + A_{0}) - A_{0}(1)}{(1 + A_{0})^{2}} = \\frac{1}{(1 + A_{0})^{2}}$$\nSubstituting this back into the expression for the partial derivative of $V_{ref}$:\n$$\\frac{\\partial V_{ref}}{\\partial A_{0}} = m V_{T} \\ln(N) \\left( \\frac{1}{(1 + A_{0})^{2}} \\right)$$\n$$\\frac{\\partial V_{ref}}{\\partial A_{0}} = \\frac{m V_{T} \\ln(N)}{(1 + A_{0})^{2}}$$\n\nThe four partial derivatives have been computed. The final result is the row vector containing these expressions in the specified order.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{A_{0} V_{T} \\ln(N)}{1 + A_{0}} & \\frac{m V_{T} A_{0}}{N(1 + A_{0})} & -\\frac{V_{T}}{I_{S}} & \\frac{m V_{T} \\ln(N)}{(1 + A_{0})^{2}}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While theory provides an ideal starting point, real-world circuits are subject to manufacturing variations that must be corrected to meet specifications. This exercise moves from the ideal model to the practical implementation of post-fabrication trimming. You will analyze a digital trimming system to calculate its fundamental limitation—the quantization error—which sets a floor on the achievable accuracy (). Mastering this concept is vital for specifying and designing high-performance analog references.",
            "id": "4257162",
            "problem": "A silicon bandgap voltage reference employs the canonical sum of a base-emitter voltage and a scaled proportional-to-absolute-temperature term, with the scale factor denoted by $m$. In production, $m$ is trimmed digitally using a $6$-bit electronic fuse (eFuse) ladder that adjusts $m$ in uniform fractional steps of $0.1\\%$ relative to a nominal design value $m_0$. The digital trim code $c \\in \\{-32,-31,\\dots,+31\\}$ realizes\n$$\nm(c) = m_0\\left(1 + s\\,c\\right),\n$$\nwhere the fractional step size is $s = 10^{-3}$. Due to process variation, the untrimmed scale factor deviates from $m_0$ by an unknown fractional offset $\\delta$, so that the target after correction is $m_{\\mathrm{target}} = m_0(1+\\delta)$ with $|\\delta| \\le B$, where the bound is $B = 3.0\\times 10^{-2}$. The trim algorithm chooses $c$ to minimize the absolute error $|m_{\\mathrm{target}} - m(c)|$ by rounding to the nearest available code, subject to clipping at the endpoints.\n\nStarting from the definitions of uniform quantization and the discrete code range, derive the worst-case residual fractional error\n$$\n\\epsilon_{\\max} = \\max_{|\\delta|\\le B}\\left|\\frac{m_{\\mathrm{target}} - m(c^{\\star}(\\delta))}{m_0}\\right|,\n$$\nwhere $c^{\\star}(\\delta)$ is the selected trim code for the given $\\delta$. Assume the uniform quantization model is valid whenever the bound $B$ lies strictly within the realizable fractional range of the ladder. Express your final answer as a single decimal fraction without using a percentage sign. No rounding is required.",
            "solution": "The problem is validated as self-contained, scientifically grounded, and well-posed. All provided data, definitions, and conditions are consistent and sufficient for deriving a unique solution. The scenario described is a standard problem in the design of digitally trimmed analog circuits, specifically analyzing the quantization error of a linear trim system.\n\n**Step 1: Extract Givens**\n-   Trimmed scale factor: $m(c) = m_0(1 + sc)$\n-   Digital trim code: $c \\in \\{-32, -31, \\dots, +31\\}$, a set of $64$ integer values.\n-   Fractional step size: $s = 10^{-3}$, which corresponds to $0.1\\%$.\n-   Target scale factor: $m_{\\mathrm{target}} = m_0(1+\\delta)$, where $\\delta$ is an unknown fractional offset.\n-   Bound on the offset: $|\\delta| \\le B$, with $B = 3.0 \\times 10^{-2}$.\n-   Trimming objective: Minimize the absolute error $|m_{\\mathrm{target}} - m(c)|$ by choosing the optimal integer code $c^{\\star}$. The method is rounding to the nearest available code.\n-   Clipping: The selected code is clipped to the endpoints of the available range if the ideal code falls outside.\n-   Quantity to find: The worst-case residual fractional error, $\\epsilon_{\\max} = \\max_{|\\delta|\\le B}\\left|\\frac{m_{\\mathrm{target}} - m(c^{\\star}(\\delta))}{m_0}\\right|$.\n-   Assumption: The uniform quantization model is valid as the bound $B$ lies strictly within the realizable fractional range of the trimming ladder.\n\n**Step 2: Problem Analysis and Solution Derivation**\nThe residual fractional error, denoted as $\\epsilon(\\delta)$, is defined as:\n$$\n\\epsilon(\\delta) = \\left|\\frac{m_{\\mathrm{target}} - m(c^{\\star}(\\delta))}{m_0}\\right|\n$$\nSubstituting the given expressions for $m_{\\mathrm{target}}$ and $m(c)$:\n$$\n\\epsilon(\\delta) = \\left|\\frac{m_0(1+\\delta) - m_0(1+sc^{\\star})}{m_0}\\right|\n$$\nThe common factor $m_0$ can be canceled, simplifying the expression to:\n$$\n\\epsilon(\\delta) = |(1+\\delta) - (1+sc^{\\star})| = |\\delta - sc^{\\star}|\n$$\nThe problem states that the trim algorithm selects the integer code $c^{\\star}$ to minimize this error, $|\\delta - sc^{\\star}|$. This is equivalent to minimizing the distance $| \\frac{\\delta}{s} - c^{\\star} |$. For an integer code $c^{\\star}$, this distance is minimized when $c^{\\star}$ is the integer closest to the continuous value $\\frac{\\delta}{s}$. This process is known as rounding.\n$$\nc^{\\star}(\\delta) = \\text{round}\\left(\\frac{\\delta}{s}\\right)\n$$\nWe must now consider the effect of the finite range of the trim code $c \\in \\{-32, \\dots, +31\\}$ and the possibility of clipping. The range of the initial fractional offset is given by $|\\delta| \\le B$, which is $\\delta \\in [-3.0 \\times 10^{-2}, 3.0 \\times 10^{-2}]$. Let's determine the corresponding range for the \"ideal\" continuous code, $\\frac{\\delta}{s}$:\n$$\n\\frac{\\delta}{s} \\in \\left[\\frac{-3.0 \\times 10^{-2}}{10^{-3}}, \\frac{3.0 \\times 10^{-2}}{10^{-3}}\\right] = [-30, 30]\n$$\nThe available integer codes are in the set $\\{-32, -31, \\dots, +30, +31\\}$. The ideal code $\\frac{\\delta}{s}$ is always within the range $[-30, 30]$. When any real number in this interval is rounded to the nearest integer, the result will also lie within the integer interval $[-30, 30]$. Since the interval of rounded codes $[-30, 30]$ is a strict subset of the available codes $\\{-32, \\dots, +31\\}$, the selected code $c^{\\star}$ will never need to be clipped to the endpoints for any $\\delta$ under consideration. This confirms the problem's assumption about the validity of the uniform quantization model.\n\nWith clipping ruled out, the problem reduces to a standard analysis of uniform quantization error. The residual fractional error is given by:\n$$\n\\epsilon(\\delta) = \\left|\\delta - s \\cdot \\text{round}\\left(\\frac{\\delta}{s}\\right)\\right|\n$$\nWe can factor out the step size $s$:\n$$\n\\epsilon(\\delta) = s \\left|\\frac{\\delta}{s} - \\text{round}\\left(\\frac{\\delta}{s}\\right)\\right|\n$$\nLet the variable $x = \\frac{\\delta}{s}$. The expression for the error becomes $s|x - \\text{round}(x)|$. The term $|x - \\text{round}(x)|$ is the magnitude of the quantization error for a standard rounding operation. The maximum value of this term is $0.5$. This worst case occurs when $x$ is exactly halfway between two integers, i.e., $x = k + 0.5$ for some integer $k$.\n\nFor example, consider the case where $x = 0.5$. This corresponds to an initial offset $\\delta = x \\cdot s = 0.5 \\times 10^{-3} = 0.0005$. This value of $\\delta$ is within the allowed bound, since $|0.0005| \\le 0.03$. For this $\\delta$, the optimal code $c^{\\star}$ would be either $0$ or $1$, depending on the tie-breaking rule for rounding.\n- If $c^{\\star} = 0$, the error is $|\\delta - s \\cdot 0| = |0.0005| = 0.0005$.\n- If $c^{\\star} = 1$, the error is $|\\delta - s \\cdot 1| = |0.0005 - 0.001| = |-0.0005| = 0.0005$.\nIn both cases, the magnitude of the error is the same.\n\nThe worst-case residual fractional error, $\\epsilon_{\\max}$, is the maximum value of $\\epsilon(\\delta)$ over the entire range of $\\delta$. This occurs when the quantization error term is maximized:\n$$\n\\epsilon_{\\max} = \\max_{|\\delta|\\le B} \\left(s \\left|\\frac{\\delta}{s} - \\text{round}\\left(\\frac{\\delta}{s}\\right)\\right|\\right) = s \\cdot \\max_{x} |x - \\text{round}(x)|\n$$\n$$\n\\epsilon_{\\max} = s \\cdot (0.5)\n$$\nSubstituting the value of $s = 10^{-3}$:\n$$\n\\epsilon_{\\max} = 10^{-3} \\times 0.5 = 0.0005\n$$\nThis represents the maximum possible fractional error remaining after the trimming process is complete, which corresponds to half of the smallest trim step.",
            "answer": "$$\n\\boxed{0.0005}\n$$"
        },
        {
            "introduction": "Modern integrated circuit design is a complex optimization problem with competing objectives. This capstone practice synthesizes the concepts of the core BGR model, manufacturing variations, and trimming into a realistic design automation task. By implementing a corner-aware optimization routine (), you will learn how engineers use computational methods to navigate the trade-offs between accuracy, power consumption, and silicon area, ultimately identifying a set of Pareto-optimal designs.",
            "id": "4257125",
            "problem": "You are tasked with implementing a corner-aware optimization for a bandgap voltage reference that combines a complementary-to-absolute-temperature (CTAT) silicon bipolar junction transistor base-emitter voltage with a proportional-to-absolute-temperature (PTAT) voltage. The objective is to select resistor geometrical areas and operational amplifier bias current to minimize the worst-case reference voltage error after trimming across a set of process-temperature corners while interpreting the Pareto trade-offs between area, power, and error. Your program must be a complete, runnable program that computes and aggregates the results for a specified test suite.\n\nBegin from the following fundamental base:\n- The thermal voltage is $V_{t}(T) = \\dfrac{k_B T}{q}$, where $k_B$ is the Boltzmann constant and $q$ is the elementary charge.\n- The PTAT generator produces a voltage difference $\\Delta V_{\\mathrm{PTAT}}(T) = V_{t}(T)\\,\\ln(N)$ using two bipolar junction transistors with emitter area ratio $N$, where $\\ln(\\cdot)$ denotes the natural logarithm.\n- The base-emitter voltage is modeled as $V_{BE}(T) = V_{BE}(T_{0}) + \\beta\\,(T - T_{0})$ with $T_{0}$ as the trim temperature and $\\beta$ as the first-order temperature coefficient. This approximation is widely used and empirically validated for design calculations in bandgap references over moderate temperature ranges.\n- The bandgap reference combines the CTAT and PTAT components with a resistor ratio $r = R_{2}/R_{1}$ to form $V_{\\mathrm{ref}}(T)$, where trimming adjusts $R_{2}$ in discrete steps. Trimming is performed only at the trim temperature $T_{0}$.\n- Resistor mismatch follows Pelgrom’s law: the fractional standard deviation of each resistor value is $\\sigma_{R}/R = A_{R}/\\sqrt{A}$, where $A$ is the resistor’s geometrical area and $A_{R}$ is the technology mismatch constant. Assuming independence, the ratio mismatch standard deviation for $r = R_{2}/R_{1}$ is $\\sigma_{r} \\approx \\sqrt{\\left(\\dfrac{A_{R}}{\\sqrt{A_{1}}}\\right)^{2} + \\left(\\dfrac{A_{R}}{\\sqrt{A_{2}}}\\right)^{2}}$ for areas $A_{1}$ and $A_{2}$.\n- The operational amplifier input-referred offset standard deviation scales approximately with bias current as $\\sigma_{v_{\\mathrm{os}}} = \\dfrac{K_{\\mathrm{vos}}}{\\sqrt{I_{\\mathrm{bias}}/1\\,\\mu\\mathrm{A}}}$, where $K_{\\mathrm{vos}}$ is a technology constant and $I_{\\mathrm{bias}}$ is the bias current. This is a well-tested heuristic grounded in device noise-area-current scalings.\n- The op-amp enforces the PTAT current through $R_{1}$ by sensing $\\Delta V_{\\mathrm{PTAT}}(T)$; its input-referred offset adds an error to the PTAT current, which propagates through $R_{2}$ as an additive term. Trimming $R_{2}$ changes the PTAT gain and consequently both the offset correction and the temperature slope.\n\nDesign model to use in your program:\n- The reference voltage is modeled as\n$$\nV_{\\mathrm{ref}}(T) = V_{BE}(T) + r\\,\\Delta V_{\\mathrm{PTAT}}(T) + r\\,v_{\\mathrm{os}},\n$$\nwhere $r$ is the effective resistor ratio after mismatch and trimming, and $v_{\\mathrm{os}}$ is the operational amplifier offset (modeled as a constant for a given instance).\n- The nominal ratio $r_{\\mathrm{nom}}$ is chosen to null the first-order temperature coefficient at a nominal $\\beta_{\\mathrm{nom}}$ via $r_{\\mathrm{nom}}\\,\\ln(N) \\approx -\\beta_{\\mathrm{nom}}\\,\\dfrac{q}{k_B}$, which comes from setting $\\dfrac{d}{dT}\\left(V_{BE}(T) + r\\,V_{t}(T)\\,\\ln(N)\\right) \\approx 0$ at the first order.\n- Mismatch perturbs the ratio as $r_{\\mathrm{pre}} = r_{\\mathrm{nom}}\\,(1 + \\varepsilon)$, where $\\varepsilon$ is a ratio error. The trimming modifies $R_{2}$ by a discrete fractional step to yield $r = r_{\\mathrm{pre}}\\,(1 + c\\,s)$, where $c$ is the integer trim code within a bounded range and $s$ is the fractional step size per code.\n- Trimming is performed at $T_{0}$, selecting $c$ to minimize $\\left|V_{\\mathrm{ref}}(T_{0}) - V_{\\mathrm{ref,target}}\\right|$ for the given corner, mismatch, and offset, subject to the discrete trim step and code bounds.\n\nCorner-aware worst-case evaluation:\n- Consider process-temperature corners $\\{(V_{BE}(T_{0}), \\beta)\\}$ and temperatures $T \\in \\{T_{\\min}, T_{0}, T_{\\max}\\}$.\n- For each design, for each corner, and for each extreme of mismatch and op-amp offset (use $\\pm 3\\sigma$ for both), select the trim code at $T_{0}$ that minimizes the error at $T_{0}$. With this trim code fixed, compute the absolute error at all temperatures in the set. The worst-case error for the design is the maximum absolute error over all corners, mismatch extremes, offset extremes, and temperatures.\n\nCost metrics and Pareto interpretation:\n- The total area is $A_{\\mathrm{tot}} = A_{1} + A_{2}$.\n- The total power is modeled as $P_{\\mathrm{tot}} = V_{\\mathrm{DD}}\\,\\left(I_{\\mathrm{bias}} + I_{\\mathrm{PTAT}}(T_{0})\\right)$, where $I_{\\mathrm{PTAT}}(T_{0}) = \\dfrac{\\Delta V_{\\mathrm{PTAT}}(T_{0})}{R_{1}}$ and $R_{1}$ is a fixed nominal resistance value. Express power in $\\mu\\mathrm{W}$ and area in $\\mu\\mathrm{m}^{2}$.\n- A design A dominates design B if it is no worse in all metrics $\\left(\\text{worst-case error}, A_{\\mathrm{tot}}, P_{\\mathrm{tot}}\\right)$ and strictly better in at least one. The Pareto set is the set of non-dominated designs.\n\nYour program must:\n- Enumerate candidate designs from specified discrete sets of resistor areas and op-amp bias currents.\n- For each candidate design, compute the worst-case error after trimming as described above, as well as the total area and total power.\n- Compute the Pareto set of non-dominated designs for each test case.\n- For each test case, output a list with four entries: the minimal worst-case error across all designs (in $\\mathrm{mV}$, rounded to three decimals), the number of Pareto-optimal designs (an integer), the minimal total area among Pareto-optimal designs (in $\\mu\\mathrm{m}^{2}$, rounded to one decimal), and the minimal total power among Pareto-optimal designs (in $\\mu\\mathrm{W}$, rounded to three decimals).\n\nYou must use the following test suite. All symbols and numbers must be treated exactly as specified.\n\nGlobal constants and trimming configuration:\n- Boltzmann constant $k_B = 1.380649\\times 10^{-23}\\,\\mathrm{J/K}$.\n- Elementary charge $q = 1.602176634\\times 10^{-19}\\,\\mathrm{C}$.\n- Trim temperature $T_{0} = 298.15\\,\\mathrm{K}$.\n- Temperatures for evaluation $T_{\\min} = 233.15\\,\\mathrm{K}$ (which is $-40\\,^{\\circ}\\mathrm{C}$), $T_{0} = 298.15\\,\\mathrm{K}$, and $T_{\\max} = 398.15\\,\\mathrm{K}$ (which is $125\\,^{\\circ}\\mathrm{C}$).\n- Emitter area ratio $N = 8$, so $\\ln(N)$ is used accordingly.\n- Target reference voltage $V_{\\mathrm{ref,target}} = 1.21\\,\\mathrm{V}$.\n- Supply voltage $V_{\\mathrm{DD}} = 1.8\\,\\mathrm{V}$.\n- Resistor $R_{1} = 10\\,\\mathrm{k}\\Omega$ at $T_{0}$.\n- Trim fractional step $s$ and code bounds as per each test case below.\n- Nominal temperature coefficient $\\beta_{\\mathrm{nom}} = -1.8\\times 10^{-3}\\,\\mathrm{V/K}$.\n\nProcess-temperature corners:\n- Typical corner: $(V_{BE}(T_{0}), \\beta) = (0.85\\,\\mathrm{V}, -1.8\\times 10^{-3}\\,\\mathrm{V/K})$.\n- Fast corner: $(V_{BE}(T_{0}), \\beta) = (0.84\\,\\mathrm{V}, -2.0\\times 10^{-3}\\,\\mathrm{V/K})$.\n- Slow corner: $(V_{BE}(T_{0}), \\beta) = (0.86\\,\\mathrm{V}, -1.6\\times 10^{-3}\\,\\mathrm{V/K})$.\n\nMismatch and offset extremes:\n- Use $\\varepsilon \\in \\{\\,-3\\sigma_{r}, +3\\sigma_{r}\\,\\}$ and $v_{\\mathrm{os}} \\in \\{\\,-3\\sigma_{v_{\\mathrm{os}}}, +3\\sigma_{v_{\\mathrm{os}}}\\,\\}$.\n\nTest cases:\n- Test case $1$ (general case):\n    - Resistor mismatch constant $A_{R} = 0.001$.\n    - Operational amplifier offset constant $K_{\\mathrm{vos}} = 0.5\\times 10^{-3}\\,\\mathrm{V}\\cdot\\sqrt{\\mu\\mathrm{A}}$.\n    - Resistor areas $A_{1}, A_{2} \\in \\{1000, 4000, 10000\\}\\,\\mu\\mathrm{m}^{2}$.\n    - Op-amp bias currents $I_{\\mathrm{bias}} \\in \\{20\\times 10^{-6}, 50\\times 10^{-6}, 100\\times 10^{-6}\\}\\,\\mathrm{A}$.\n    - Trim fractional step $s = 0.003125$.\n    - Trim code bounds $c \\in \\{-16, -15, \\dots, +15\\}$.\n- Test case $2$ (power constrained):\n    - Resistor mismatch constant $A_{R} = 0.001$.\n    - Operational amplifier offset constant $K_{\\mathrm{vos}} = 0.5\\times 10^{-3}\\,\\mathrm{V}\\cdot\\sqrt{\\mu\\mathrm{A}}$.\n    - Resistor areas $A_{1}, A_{2} \\in \\{1000, 4000, 10000\\}\\,\\mu\\mathrm{m}^{2}$.\n    - Op-amp bias currents $I_{\\mathrm{bias}} \\in \\{5\\times 10^{-6}, 10\\times 10^{-6}, 20\\times 10^{-6}\\}\\,\\mathrm{A}$.\n    - Trim fractional step $s = 0.003125$.\n    - Trim code bounds $c \\in \\{-16, -15, \\dots, +15\\}$.\n- Test case $3$ (poor resistor matching, finer trim):\n    - Resistor mismatch constant $A_{R} = 0.003$.\n    - Operational amplifier offset constant $K_{\\mathrm{vos}} = 0.5\\times 10^{-3}\\,\\mathrm{V}\\cdot\\sqrt{\\mu\\mathrm{A}}$.\n    - Resistor areas $A_{1}, A_{2} \\in \\{1000, 2000, 4000, 8000, 16000\\}\\,\\mu\\mathrm{m}^{2}$.\n    - Op-amp bias currents $I_{\\mathrm{bias}} \\in \\{20\\times 10^{-6}, 50\\times 10^{-6}, 100\\times 10^{-6}\\}\\,\\mathrm{A}$.\n    - Trim fractional step $s = 0.002$.\n    - Trim code bounds $c \\in \\{-16, -15, \\dots, +15\\}$.\n\nYour program must compute, for each test case, the four outputs described above and then produce a single line of output containing a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of four values in the order specified. Specifically, the output must be of the form\n$[\\,[e_{1},p_{1},a_{1},w_{1}],\\,[e_{2},p_{2},a_{2},w_{2}],\\,[e_{3},p_{3},a_{3},w_{3}]\\,]$,\nwhere $e_{i}$ is the minimal worst-case error (in $\\mathrm{mV}$, rounded to three decimals), $p_{i}$ is the number of Pareto-optimal designs (an integer), $a_{i}$ is the minimal Pareto area (in $\\mu\\mathrm{m}^{2}$, rounded to one decimal), and $w_{i}$ is the minimal Pareto power (in $\\mu\\mathrm{W}$, rounded to three decimals). No additional text should be printed.\n\nAll numerical outputs must be rounded as specified, and physical units must be as required above. Angles are not involved in this problem. Percentages that appear in internal computations (for example, trim fractional steps) should remain as decimals in calculations; only the specified outputs are printed.",
            "solution": "The problem requires a corner-aware, multi-objective optimization of a bandgap voltage reference (BGR) circuit. The goal is to explore a discrete design space defined by resistor areas ($A_1$, $A_2$) and operational amplifier (op-amp) bias current ($I_{\\mathrm{bias}}$), and identify a set of non-dominated (Pareto-optimal) designs. The objectives are to minimize the worst-case voltage error after a simulated trimming process, total silicon area, and total power consumption.\n\nThe solution is developed by algorithmically formalizing the provided physical models and evaluation criteria. The core of the methodology is a systematic exploration of the design space, where each candidate design is subjected to a rigorous worst-case analysis.\n\n**1. Foundational BGR Model**\n\nThe BGR voltage, $V_{\\mathrm{ref}}$, is generated by summing a complementary-to-absolute-temperature (CTAT) voltage, represented by a bipolar junction transistor's (BJT) base-emitter voltage $V_{BE}(T)$, and a proportional-to-absolute-temperature (PTAT) voltage. The model is given as:\n$$\nV_{\\mathrm{ref}}(T) = V_{BE}(T) + r\\,\\Delta V_{\\mathrm{PTAT}}(T) + r\\,v_{\\mathrm{os}}\n$$\nHere, $V_{BE}(T)$ is approximated by a first-order Taylor expansion around a trim temperature $T_0$:\n$$\nV_{BE}(T) = V_{BE}(T_{0}) + \\beta\\,(T - T_{0})\n$$\nwhere $\\beta$ is the temperature coefficient. The PTAT voltage, $\\Delta V_{\\mathrm{PTAT}}(T)$, is generated from the difference in $V_{BE}$ of two BJTs with an emitter area ratio of $N$:\n$$\n\\Delta V_{\\mathrm{PTAT}}(T) = V_t(T) \\, \\ln(N) = \\frac{k_B T}{q} \\ln(N)\n$$\nwhere $V_t(T)$ is the thermal voltage, with $k_B$ as the Boltzmann constant and $q$ as the elementary charge. The term $v_{\\mathrm{os}}$ represents the op-amp's input-referred offset voltage, which introduces a systematic error. The resistor ratio $r = R_2/R_1$ scales the PTAT component.\n\n**2. First-Order Temperature Compensation**\n\nThe principle of a BGR is to make $V_{\\mathrm{ref}}$ independent of temperature, at least to the first order. This is achieved by choosing a nominal ratio, $r_{\\mathrm{nom}}$, that cancels the temperature dependence. Differentiating $V_{\\mathrm{ref}}(T)$ with respect to $T$ (ignoring the $v_{\\mathrm{os}}$ term for this nominal calculation) and setting the result to zero yields:\n$$\n\\frac{d V_{\\mathrm{ref}}(T)}{dT} \\approx \\frac{d}{dT} \\left( V_{BE}(T_0) + \\beta(T-T_0) \\right) + r_{\\mathrm{nom}} \\frac{d}{dT} \\left( \\frac{k_B T}{q} \\ln(N) \\right) = \\beta + r_{\\mathrm{nom}} \\frac{k_B}{q} \\ln(N) = 0\n$$\nThis gives the formula for the nominal ratio based on the nominal temperature coefficient, $\\beta_{\\mathrm{nom}}$:\n$$\nr_{\\mathrm{nom}} = -\\beta_{\\mathrm{nom}} \\frac{q}{k_B \\ln(N)}\n$$\n\n**3. Algorithmic Design for Design Space Exploration**\n\nThe solution involves a nested-loop algorithm that evaluates each candidate design. A design is uniquely defined by the triplet $(A_1, A_2, I_{\\mathrm{bias}})$.\n\n**3.1. Design Cost Metrics**\n\nFor each design $(A_1, A_2, I_{\\mathrm{bias}})$, we first compute its intrinsic cost metrics: total area and power.\n- **Total Area ($A_{\\mathrm{tot}}$)**: This is the sum of the resistor areas, a direct measure of the silicon footprint.\n$$A_{\\mathrm{tot}} = A_1 + A_2$$\n- **Total Power ($P_{\\mathrm{tot}}$)**: This is the power drawn from the supply $V_{\\mathrm{DD}}$. It consists of the op-amp bias current and the PTAT current flowing through $R_1$ at the reference temperature $T_0$.\n$$P_{\\mathrm{tot}} = V_{\\mathrm{DD}} \\left( I_{\\mathrm{bias}} + I_{\\mathrm{PTAT}}(T_0) \\right) = V_{\\mathrm{DD}} \\left( I_{\\mathrm{bias}} + \\frac{\\Delta V_{\\mathrm{PTAT}}(T_0)}{R_1} \\right)$$\n\n**3.2. Worst-Case Error Evaluation**\n\nThe performance metric is the worst-case voltage error. This is the most complex part of the evaluation, requiring simulation over all specified process corners, manufacturing variations (mismatch and offset), and the full temperature range.\n\nFor a given design $(A_1, A_2, I_{\\mathrm{bias}})$, we first determine its susceptibility to random variations:\n- **Resistor Ratio Mismatch ($\\sigma_r$)**: Using Pelgrom's Law, the standard deviation of the ratio $r=R_2/R_1$ is determined by the mismatch constant $A_R$ and the resistor areas $A_1$ and $A_2$.\n$$ \\sigma_r = A_R \\sqrt{\\frac{1}{A_1} + \\frac{1}{A_2}} $$\n- **Op-amp Offset Mismatch ($\\sigma_{v_{\\mathrm{os}}}$)**: The standard deviation of the op-amp offset is determined by the technology constant $K_{\\mathrm{vos}}$ and the bias current $I_{\\mathrm{bias}}$ (in $\\mu\\mathrm{A}$).\n$$ \\sigma_{v_{\\mathrm{os}}} = \\frac{K_{\\mathrm{vos}}}{\\sqrt{I_{\\mathrm{bias}} / (1\\,\\mu\\mathrm{A})}} $$\n\nThe algorithm then executes a worst-case sweep:\nAn outer loop iterates through all $N_d$ designs. Inside, a variable `max_error_for_design` is initialized to $0$. A series of nested loops traverse all $N_c$ process corners (Typical, Fast, Slow), $N_\\epsilon=2$ mismatch extremes ($\\varepsilon = \\pm 3 \\sigma_r$), and $N_{vos}=2$ offset extremes ($v_{\\mathrm{os}} = \\pm 3\\sigma_{v_{\\mathrm{os}}}$). This defines a total of $N_c \\times N_\\epsilon \\times N_{vos}$ \"scenarios\" for each design.\n\nFor each scenario:\n1.  **Simulate Trimming at $T_0$**: The as-fabricated, pre-trim resistor ratio is $r_{\\mathrm{pre}} = r_{\\mathrm{nom}}(1 + \\varepsilon)$. Trimming adjusts this ratio to $r = r_{\\mathrm{pre}}(1+cs)$, where $c$ is an integer trim code and $s$ is the step size. The optimal trim code, $c_{\\mathrm{opt}}$, is found by selecting the integer $c$ from its allowed range that minimizes the voltage error at the trim temperature $T_0$:\n$$\nc_{\\mathrm{opt}} = \\underset{c \\in [c_{\\min}, c_{\\max}]}{\\operatorname{argmin}} \\left| V_{\\mathrm{ref}}(T_0, c) - V_{\\mathrm{ref,target}} \\right|\n$$\nwhere $V_{\\mathrm{ref}}(T_0, c) = V_{BE}(T_0) + r_{\\mathrm{pre}}(1+cs)(\\Delta V_{\\mathrm{PTAT}}(T_0) + v_{\\mathrm{os}})$. This step is implemented by exhaustively checking all possible integer values of $c$.\n\n2.  **Evaluate Error across Temperature**: With $c_{\\mathrm{opt}}$ fixed for the current scenario, the final trimmed ratio is $r_{\\mathrm{final}} = r_{\\mathrm{pre}}(1+c_{\\mathrm{opt}}s)$. The voltage error is then calculated at each evaluation temperature $T \\in \\{T_{\\min}, T_0, T_{\\max}\\}$.\n$$\n\\text{error}(T) = \\left| V_{BE}(T) + r_{\\mathrminal}(\\Delta V_{\\mathrm{PTAT}}(T) + v_{\\mathrm{os}}) - V_{\\mathrm{ref,target}} \\right|\n$$\nThe maximum of these errors is the worst-case error for this single scenario. `max_error_for_design` is updated with the maximum error found across all scenarios.\n\nAfter iterating through all scenarios, `max_error_for_design` holds the worst-case error for the design $(A_1, A_2, I_{\\mathrm{bias}})$. The triplet $(\\text{worst-case error}, A_{\\mathrm{tot}}, P_{\\mathrm{tot}})$ is stored.\n\n**3.3. Pareto Front Identification**\n\nAfter evaluating all candidate designs, we perform a Pareto analysis. A design `A` with metrics $(e_A, a_A, p_A)$ is said to dominate design `B` with metrics $(e_B, a_B, p_B)$ if it is no worse in any objective and strictly better in at least one:\n$$\n(e_A \\le e_B) \\land (a_A \\le a_B) \\land (p_A \\le p_B) \\land ((e_A < e_B) \\lor (a_A < a_B) \\lor (p_A < p_B))\n$$\nThe Pareto-optimal set is the collection of all designs that are not dominated by any other design in the set. The algorithm identifies this set by pair-wise comparison of all evaluated designs.\n\n**4. Final Output Metrics**\n\nFinally, for each test case, the required metrics are computed:\n1.  The global minimal worst-case error across all designs.\n2.  The total number of designs in the Pareto-optimal set.\n3.  The minimal total area among the designs in the Pareto set.\n4.  The minimal total power among the designs in the Pareto set.\n\nThese values are then formatted and presented as specified, providing a concise summary of the trade-offs for the given design space.",
            "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    # Global constants and configuration\n    K_BOLTZMANN = 1.380649e-23  # J/K\n    Q_ECHARGE = 1.602176634e-19  # C\n    T0 = 298.15  # K\n    TEMPS = [233.15, 298.15, 398.15]  # K (T_min, T0, T_max)\n    N_RATIO = 8\n    LN_N = np.log(N_RATIO)\n    V_REF_TARGET = 1.21  # V\n    V_DD = 1.8  # V\n    R1_NOMINAL = 10e3  # Ohms\n    BETA_NOM = -1.8e-3  # V/K\n\n    # Derived constants\n    K_OVER_Q = K_BOLTZMANN / Q_ECHARGE\n    R_NOM = -BETA_NOM / (K_OVER_Q * LN_N)\n    DELTA_VPTAT_T0 = K_OVER_Q * T0 * LN_N\n    I_PTAT_T0 = DELTA_VPTAT_T0 / R1_NOMINAL\n\n    # Process-temperature corners\n    CORNERS = {\n        'typical': {'vbe_t0': 0.85, 'beta': -1.8e-3},\n        'fast': {'vbe_t0': 0.84, 'beta': -2.0e-3},\n        'slow': {'vbe_t0': 0.86, 'beta': -1.6e-3},\n    }\n\n    # Test suite definition\n    test_suite = [\n        {\n            'A_R': 0.001,\n            'K_vos': 0.5e-3,\n            'A_vals': [1000, 4000, 10000],\n            'Ibias_vals': [20e-6, 50e-6, 100e-6],\n            's_trim': 0.003125,\n            'c_range': range(-16, 16),\n        },\n        {\n            'A_R': 0.001,\n            'K_vos': 0.5e-3,\n            'A_vals': [1000, 4000, 10000],\n            'Ibias_vals': [5e-6, 10e-6, 20e-6],\n            's_trim': 0.003125,\n            'c_range': range(-16, 16),\n        },\n        {\n            'A_R': 0.003,\n            'K_vos': 0.5e-3,\n            'A_vals': [1000, 2000, 4000, 8000, 16000],\n            'Ibias_vals': [20e-6, 50e-6, 100e-6],\n            's_trim': 0.002,\n            'c_range': range(-16, 16),\n        }\n    ]\n\n    final_results = []\n\n    for case_params in test_suite:\n        A_R = case_params['A_R']\n        K_vos = case_params['K_vos']\n        A_vals = case_params['A_vals']\n        Ibias_vals = case_params['Ibias_vals']\n        s_trim = case_params['s_trim']\n        c_range = case_params['c_range']\n\n        design_space = list(itertools.product(A_vals, A_vals, Ibias_vals))\n        evaluated_designs = []\n\n        # Iterate through each candidate design\n        for A1, A2, Ibias in design_space:\n            # Calculate design-specific parameters (mismatch, offset, area, power)\n            sigma_r = A_R * np.sqrt(1/A1 + 1/A2)\n            sigma_vos = K_vos / np.sqrt(Ibias * 1e6)\n            \n            A_tot = float(A1 + A2)\n            P_tot = V_DD * (Ibias + I_PTAT_T0)\n            \n            max_error_for_design = 0.0\n\n            # Iterate through all worst-case scenarios (corners, mismatch, offset)\n            for corner in CORNERS.values():\n                vbe_t0_corner = corner['vbe_t0']\n                beta_corner = corner['beta']\n\n                for eps_sign in [-1, 1]:\n                    eps = eps_sign * 3 * sigma_r\n                    r_pre = R_NOM * (1 + eps)\n                    \n                    for vos_sign in [-1, 1]:\n                        vos = vos_sign * 3 * sigma_vos\n\n                        # Find optimal trim code c_opt at T0\n                        min_error_at_t0 = float('inf')\n                        c_opt = 0\n                        # Term for V_ref expression at T0\n                        ptat_plus_os_t0 = DELTA_VPTAT_T0 + vos\n                        \n                        for c in c_range:\n                            r_eff = r_pre * (1 + c * s_trim)\n                            vref_at_t0 = vbe_t0_corner + r_eff * ptat_plus_os_t0\n                            error_at_t0 = abs(vref_at_t0 - V_REF_TARGET)\n                            if error_at_t0 < min_error_at_t0:\n                                min_error_at_t0 = error_at_t0\n                                c_opt = c\n\n                        r_final = r_pre * (1 + c_opt * s_trim)\n\n                        # Evaluate error across temperatures with the fixed optimal trim code\n                        for T in TEMPS:\n                            v_be = vbe_t0_corner + beta_corner * (T - T0)\n                            delta_v_ptat = K_OVER_Q * T * LN_N\n                            v_ref = v_be + r_final * (delta_v_ptat + vos)\n                            error = abs(v_ref - V_REF_TARGET)\n                            if error > max_error_for_design:\n                                max_error_for_design = error\n            \n            evaluated_designs.append({'error': max_error_for_design, 'area': A_tot, 'power': P_tot})\n\n        # Pareto Analysis\n        pareto_set = []\n        for i, design1 in enumerate(evaluated_designs):\n            is_dominated = False\n            for j, design2 in enumerate(evaluated_designs):\n                if i == j:\n                    continue\n                # Check if design2 dominates design1\n                if (design2['error'] <= design1['error'] and\n                    design2['area'] <= design1['area'] and\n                    design2['power'] <= design1['power'] and\n                    (design2['error'] < design1['error'] or\n                     design2['area'] < design1['area'] or\n                     design2['power'] < design1['power'])):\n                    is_dominated = True\n                    break\n            if not is_dominated:\n                pareto_set.append(design1)\n\n        # Calculate final metrics for the test case\n        min_worst_case_error = min(d['error'] for d in evaluated_designs)\n        num_pareto_designs = len(pareto_set)\n        \n        if not pareto_set: # Handle case of empty pareto set, although unlikely here\n            min_pareto_area = 0.0\n            min_pareto_power = 0.0\n        else:\n            min_pareto_area = min(d['area'] for d in pareto_set)\n            min_pareto_power = min(d['power'] for d in pareto_set)\n\n        # Format results as required\n        e_mV = round(min_worst_case_error * 1000, 3)\n        p_count = num_pareto_designs\n        a_um2 = round(min_pareto_area, 1)\n        w_uW = round(min_pareto_power * 1e6, 3)\n        \n        final_results.append([e_mV, p_count, a_um2, w_uW])\n\n    # Print the final output in the exact specified format\n    results_str_list = [f\"[{','.join(map(str, res))}]\" for res in final_results]\n    print(f\"[{','.join(results_str_list)}]\")\n\n\nsolve()\n```"
        }
    ]
}