{
    "hands_on_practices": [
        {
            "introduction": "为了深入理解共模抑制比（CMRR）的物理根源，我们首先从差分放大器的核心——有源差分对入手。这项练习  将指导你通过小信号分析，推导共模增益与负载失配及尾电流源非理想性之间的直接关系。通过探索尾电阻 $R_{t}$ 在两个极端情况（趋近于零和无穷大）下的渐进行为，你将建立起关于理想电流源如何实现高 CMRR 的深刻直觉。",
            "id": "4261577",
            "problem": "考虑一个用作电阻负载放大器的对称金属-氧化物-半导体（MOS）差分对。每个晶体管的小信号跨导为 $g_{m}$，输出电阻可忽略不计。两个漏极分别通过电阻 $R_{D1}$ 和 $R_{D2}$ 连接到一个稳定电源。两个源极短接在一起，通过一个有限的尾电阻 $R_{t}$ 接地，该电阻模拟了尾电流源的非理想输出电阻。负载电阻存在一个小的失配，模型为 $R_{D1} = R(1+\\alpha)$ 和 $R_{D2} = R(1-\\alpha)$，其中 $R > 0$ 且 $|\\alpha| \\ll 1$。一个纯共模小信号输入 $v_{cm}$ 被同等地施加到两个栅极上。设差分输出电压为 $v_{od} = v_{o1} - v_{o2}$，并将共模到差模转换增益 $A_{cd}$ 定义为 $A_{cd} = v_{od}/v_{cm}$。在小信号体系下进行分析，并假设系统具有线性时不变行为。\n\n从基本电路关系（Kirchhoff定律、线性小信号跨导和欧姆定律）出发，对任意的 $R_{t}$、$g_{m}$、$R$ 和 $\\alpha$ 符号推导 $A_{cd}$，然后确定当 $R_{t} \\to \\infty$ 和 $R_{t} \\to 0$ 时 $A_{cd}$ 的极限行为。讨论这些渐近极限对于该电路的共模抑制比（CMRR）的物理意义，CMRR定义为差模增益与共模到差模转换增益的幅值之比。\n\n将您的最终答案表示为由两个极限组成的有序对 $\\left(\\lim_{R_{t}\\to\\infty} A_{cd},\\ \\lim_{R_{t}\\to 0} A_{cd}\\right)$，形式为闭式代数表达式。不需要进行数值计算或四舍五入。",
            "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于标准的小信号电路理论，是适定的，提供了所有必要的信息，并以客观、无歧义的语言表达。因此，我们可以进行形式化解答。\n\n问题要求推导带有有限尾电阻 $R_t$ 和失配负载电阻 $R_{D1}$ 和 $R_{D2}$ 的电阻负载MOS差分对的共模到差模转换增益 $A_{cd}$。我们将使用小信号等效电路模型。\n\n设两个晶体管为 $M_1$ 和 $M_2$。每个晶体管的小信号跨导为 $g_m$。一个共模输入电压 $v_{cm}$ 被施加到两个栅极上，因此 $v_{g1} = v_{g2} = v_{cm}$。$M_1$ 和 $M_2$ 的源极连接到一个电压为 $v_s$ 的节点。这个公共源极节点通过尾电阻 $R_t$ 接地。晶体管的输出电阻可忽略不计。\n\n$M_1$ 和 $M_2$ 的小信号栅源电压是相同的：\n$$v_{gs1} = v_{g1} - v_s = v_{cm} - v_s$$\n$$v_{gs2} = v_{g2} - v_s = v_{cm} - v_s$$\n因此，小信号漏极电流也是相同的，由线性跨导关系给出：\n$$i_{d1} = g_m v_{gs1} = g_m (v_{cm} - v_s)$$\n$$i_{d2} = g_m v_{gs2} = g_m (v_{cm} - v_s)$$\n所以，$i_{d1} = i_{d2}$。\n\n漏极通过电阻 $R_{D1}$ 和 $R_{D2}$ 连接到交流地（稳定电源）。输出电压 $v_{o1}$ 和 $v_{o2}$ 由欧姆定律确定：\n$$v_{o1} = -i_{d1} R_{D1}$$\n$$v_{o2} = -i_{d2} R_{D2}$$\n\n为了求出公共源极节点电压 $v_s$，我们对该节点应用Kirchhoff电流定律（KCL）。两个源极电流之和（对于MOS晶体管，源极电流等于其各自的漏极电流）流过尾电阻 $R_t$。\n$$i_{d1} + i_{d2} = \\frac{v_s}{R_t}$$\n因为 $i_{d1} = i_{d2}$，这变为：\n$$2 i_{d1} = \\frac{v_s}{R_t}$$\n现在我们代入 $i_{d1}$ 的表达式：\n$$2 g_m (v_{cm} - v_s) = \\frac{v_s}{R_t}$$\n我们现在可以求解用 $v_{cm}$ 表示的 $v_s$：\n$$2 g_m R_t (v_{cm} - v_s) = v_s$$\n$$2 g_m R_t v_{cm} - 2 g_m R_t v_s = v_s$$\n$$2 g_m R_t v_{cm} = v_s (1 + 2 g_m R_t)$$\n$$v_s = \\frac{2 g_m R_t}{1 + 2 g_m R_t} v_{cm}$$\n\n为了求出漏极电流，我们首先用 $v_{cm}$ 表示栅源电压 $v_{cm} - v_s$：\n$$v_{cm} - v_s = v_{cm} - \\left( \\frac{2 g_m R_t}{1 + 2 g_m R_t} \\right) v_{cm} = v_{cm} \\left( 1 - \\frac{2 g_m R_t}{1 + 2 g_m R_t} \\right)$$\n$$v_{cm} - v_s = v_{cm} \\left( \\frac{1 + 2 g_m R_t - 2 g_m R_t}{1 + 2 g_m R_t} \\right) = \\frac{1}{1 + 2 g_m R_t} v_{cm}$$\n因此，漏极电流 $i_{d1}$ 为：\n$$i_{d1} = g_m (v_{cm} - v_s) = \\frac{g_m}{1 + 2 g_m R_t} v_{cm}$$\n并且由于 $i_{d1}=i_{d2}$，我们对 $i_{d2}$ 有相同的表达式。\n\n差分输出电压定义为 $v_{od} = v_{o1} - v_{o2}$。代入输出电压的表达式：\n$$v_{od} = (-i_{d1} R_{D1}) - (-i_{d2} R_{D2}) = -i_{d1} (R_{D1} - R_{D2})$$\n现在，代入 $i_{d1}$ 的表达式：\n$$v_{od} = -\\left( \\frac{g_m}{1 + 2 g_m R_t} v_{cm} \\right) (R_{D1} - R_{D2})$$\n共模到差模转换增益 $A_{cd}$ 定义为 $A_{cd} = v_{od} / v_{cm}$：\n$$A_{cd} = \\frac{-g_m (R_{D1} - R_{D2})}{1 + 2 g_m R_t}$$\n接下来，我们使用给定的失配电阻模型：$R_{D1} = R(1+\\alpha)$ 和 $R_{D2} = R(1-\\alpha)$。它们的差是：\n$$R_{D1} - R_{D2} = R(1+\\alpha) - R(1-\\alpha) = R + R\\alpha - R + R\\alpha = 2R\\alpha$$\n将此代入 $A_{cd}$ 的表达式中：\n$$A_{cd} = \\frac{-g_m (2R\\alpha)}{1 + 2 g_m R_t} = \\frac{-2g_m R \\alpha}{1 + 2 g_m R_t}$$\n这就是共模到差模转换增益的符号表达式。\n\n现在，我们计算所要求的极限。\n首先，当 $R_t \\to \\infty$ 时的极限：\n$$\\lim_{R_t\\to\\infty} A_{cd} = \\lim_{R_t\\to\\infty} \\frac{-2g_m R \\alpha}{1 + 2 g_m R_t}$$\n当 $R_t$ 趋于无穷大时，分母 $1 + 2 g_m R_t$ 趋于无穷大。对于任何有限的分子，该分数趋于零。\n$$\\lim_{R_t\\to\\infty} A_{cd} = 0$$\n\n其次，当 $R_t \\to 0$ 时的极限：\n$$\\lim_{R_t\\to 0} A_{cd} = \\frac{-2g_m R \\alpha}{1 + 2 g_m (0)} = \\frac{-2g_m R \\alpha}{1}$$\n$$\\lim_{R_t\\to 0} A_{cd} = -2g_m R \\alpha$$\n\n这对共模抑制比（CMRR）的物理意义是显著的。CMRR 定义为差模增益 $A_d$ 与共模到差模转换增益 $A_{cd}$ 的幅值之比：\n$$CMRR = \\left| \\frac{A_d}{A_{cd}} \\right|$$\n差模增益（假设匹配）为 $A_d \\approx -g_m R$。\n那么 CMRR 是：\n$$CMRR = \\left| \\frac{-g_m R}{\\frac{-2g_m R \\alpha}{1 + 2 g_m R_t}} \\right| = \\left| \\frac{1 + 2 g_m R_t}{2\\alpha} \\right| = \\frac{1 + 2 g_m R_t}{2|\\alpha|}$$\n- 对于 $R_t \\to \\infty$：$A_{cd} \\to 0$ 且 $CMRR \\to \\infty$。大的尾阻抗（接近理想电流源）迫使晶体管电流之和保持恒定（交流为零）。这提供了强大的负反馈，抑制了源极节点上的任何共模电压变化，从而使信号电流趋于零。因此，即使存在电阻失配，共模输入也不会产生差分输出，导致无限大的CMRR。这是理想的工作条件。\n- 对于 $R_t \\to 0$：$A_{cd} \\to -2g_m R \\alpha$ 且 $CMRR \\to \\frac{1}{2|\\alpha|}$。当尾阻抗为零时，两个晶体管作为独立的共源放大器工作。共模输入 $v_{cm}$ 被每个晶体管放大。差分输出 $v_{od}$ 不为零完全是由于负载电阻的失配 $\\alpha$。电路失去了由尾电流源提供的共模抑制能力，CMRR 变为有限值，受元件匹配精度的限制。较大的失配 $\\alpha$ 会导致较大的 $A_{cd}$，从而导致较小（更差）的CMRR。\n\n最终答案要求给出 $A_{cd}$ 的两个极限的有序对。\n当 $R_t \\to \\infty$ 时的极限是 $0$。\n当 $R_t \\to 0$ 时的极限是 $-2g_m R \\alpha$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0 & -2 g_{m} R \\alpha \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "理论分析为我们提供了基础，但在实际集成电路中，CMRR 的表现与频率密切相关。本练习  将引导你编写一个数值程序，通过节点分析法从零开始构建一个小型电路仿真器，以计算差分放大器在不同频率下的性能。你将运用奇偶模激励法来精确分离和计算差模增益 $A_d(\\omega)$ 与共模到差模转换增益 $A_{cd}(\\omega)$，从而直观地观察到寄生电容等因素是如何在高频时降低 CMRR 的。",
            "id": "4261578",
            "problem": "给定一个适用于频域分析的差分放大器的小信号线性模型。目标是使用奇偶模激励，计算作为角频率函数的差模增益幅度（表示为 $A_d(\\omega)$）和共模到差模转换增益幅度 $A_{cd}(\\omega)$。然后，对这些量进行后处理，以获得作为频率函数的共模抑制比（CMRR）的幅值，表示为 $\\mathrm{CMRR}(\\omega) = \\left|\\frac{A_d(\\omega)}{A_{cd}(\\omega)}\\right|$。您必须将计算实现为一个数值程序，通过频域中的节点分析来求解该小信号电路。\n\n小信号电路定义如下。\n\n- 两个输出节点，电压分别为 $v_{o+}$ 和 $v_{o-}$，以及一个尾节点，电压为 $v_t$。\n- 两个跨导器，将电流从每个输出节点注入到尾节点。它们的小信号跨导分别为 $g_{m1}$ 和 $g_{m2}$，小信号栅源电压分别为 $v_{gs1} = v_{g+} - v_t$ 和 $v_{gs2} = v_{g-} - v_t$。从每个输出节点注入尾节点的小信号电流分别为 $i_{gm1} = g_{m1} v_{gs1}$ 和 $i_{gm2} = g_{m2} v_{gs2}$。\n- 每个输出节点都有一个到地的负载电阻和电容：$+$ 侧为 $R_{L+}$ 和 $C_{L+}$，$-$ 侧为 $R_{L-}$ 和 $C_{L-}$。\n- 每个输出节点分别通过小信号输出电阻 $r_{o+}$ 和 $r_{o-}$ 连接到尾节点。\n- 尾节点通过并联的尾电阻 $R_t$ 和尾电容 $C_t$ 接地（两者均到地）。\n- 假设所有栅极节点都是高阻抗且不吸取电流。\n\n频域节点方程遵循基尔霍夫电流定律和电容的阻抗特性。设 $s = j\\omega$ 且 $\\omega = 2\\pi f$，其中 $f$ 的单位是赫兹。对于每个频率，将未知节点电压组合成一个向量 $\\mathbf{v} = [v_{o+}, v_{o-}, v_t]^T$。栅极激励电压 $v_{g+}$ 和 $v_{g-}$ 是外部施加的源，用于形成奇偶模激励。\n\n定义以下测量约定：\n\n- 用于差模增益的奇模激励：施加 $v_{g+} = +\\frac{1}{2}$ 和 $v_{g-} = -\\frac{1}{2}$，这会产生单位差分输入幅度 $v_{id} = v_{g+} - v_{g-} = 1$。计算差分输出 $v_{od} = v_{o+} - v_{o-}$ 并设置 $A_d(\\omega) = \\frac{v_{od}}{v_{id}} = v_{o+} - v_{o-}$。\n- 用于共模到差模转换增益的偶模激励：施加 $v_{g+} = v_{g-} = 1$，这会产生单位共模输入幅度 $v_{icm} = \\frac{v_{g+} + v_{g-}}{2} = 1$。计算差分输出 $v_{od} = v_{o+} - v_{o-}$ 并设置 $A_{cd}(\\omega) = \\frac{v_{od}}{v_{icm}} = v_{o+} - v_{o-}$。\n\n您必须从第一性原理出发，使用节点分析实现频域解：\n\n- 对于每个频率，通过对流经无源元件到地和节点间的电流求和，并包括来自跨导器的受控源电流，写出每个节点对应的线性方程。使用电容导纳 $s C$。\n- 对每种激励（奇模和偶模），求解得到的 $3 \\times 3$ 线性系统，以获得未知节点电压。\n- 使用解出的节点电压，计算 $A_d(\\omega)$ 和 $A_{cd}(\\omega)$，然后计算 $\\left|\\frac{A_d(\\omega)}{A_{cd}(\\omega)}\\right|$ 并通过 $20 \\log_{10}\\left(\\left|\\frac{A_d(\\omega)}{A_{cd}(\\omega)}\\right|\\right)$ 将其表示为分贝。\n\n通过扰动器件和负载参数来引入失配效应：\n\n- 设标称跨导为 $g_m$。则 $g_{m1} = g_m (1 + \\delta_{gm})$ 且 $g_{m2} = g_m (1 - \\delta_{gm})$。\n- 设标称负载电阻为 $R_L$。则 $R_{L+} = R_L (1 + \\delta_{RL})$ 且 $R_{L-} = R_L (1 - \\delta_{RL})$。\n- 除非另有说明，否则假设 $r_{o+} = r_{o-} = r_o$ 且 $C_{L+} = C_{L-} = C_L$。\n\n使用以下测试套件。对于每个测试用例，计算在指定频率下 $\\mathrm{CMRR}(\\omega)$ 的分贝幅值。最终输出必须是浮点数，单位为分贝。\n\n频率（单位：赫兹）：\n- $f \\in \\{10^2, 10^4, 10^6, 10^8\\}$。\n\n测试用例（所有电阻单位为欧姆，电容单位为法拉，跨导单位为西门子）：\n1. 具有小失配和有限尾部阻抗的常规情况：\n   - $g_m = 5 \\times 10^{-3}$, $r_o = 2 \\times 10^5$, $R_L = 10^4$, $C_L = 2 \\times 10^{-12}$, $R_t = 10^5$, $C_t = 1 \\times 10^{-12}$, $\\delta_{gm} = 0.02$, $\\delta_{RL} = 0.01$。\n2. 近理想电流源尾级，无失配：\n   - $g_m = 2 \\times 10^{-3}$, $r_o = 5 \\times 10^5$, $R_L = 2 \\times 10^4$, $C_L = 1 \\times 10^{-12}$, $R_t = 10^9$, $C_t = 1 \\times 10^{-12}$, $\\delta_{gm} = 0.0$, $\\delta_{RL} = 0.0$。\n3. 强失配和中等尾部阻抗：\n   - $g_m = 3 \\times 10^{-3}$, $r_o = 1.5 \\times 10^5$, $R_L = 8 \\times 10^3$, $C_L = 2 \\times 10^{-12}$, $R_t = 8 \\times 10^4$, $C_t = 1 \\times 10^{-12}$, $\\delta_{gm} = 0.1$, $\\delta_{RL} = 0.1$。\n4. 较重电容性负载和适度失配：\n   - $g_m = 4 \\times 10^{-3}$, $r_o = 2 \\times 10^5$, $R_L = 5 \\times 10^3$, $C_L = 1 \\times 10^{-11}$, $R_t = 2 \\times 10^5$, $C_t = 5 \\times 10^{-12}$, $\\delta_{gm} = 0.03$, $\\delta_{RL} = 0.0$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按测试用例和频率升序排列。具体来说，列出测试用例1在 $10^2, 10^4, 10^6, 10^8$ 赫兹下的 $20 \\log_{10}\\left(\\left|\\frac{A_d(\\omega)}{A_{cd}(\\omega)}\\right|\\right)$ 值，然后是测试用例2在相同频率下的值，依此类推，直到测试用例3和4。\n- 将结果表示为分贝值的小数，每个值四舍五入到三位小数。\n\n所有答案都是无量纲的分贝值。不应打印百分比或其他额外文本。程序必须完全自包含，且不得要求任何用户输入。输出必须只有一行，并采用所描述的精确格式（例如，“[x1,x2,...,x16]”）。",
            "solution": "## 问题验证\n\n### 步骤1：提取已知条件\n- **电路节点**：三个未知电压节点：$v_{o+}$, $v_{o-}$, $v_t$。\n- **输入节点**：两个外部栅极电压源：$v_{g+}$, $v_{g-}$。\n- **跨导器**：\n  - $g_{m1}$, $v_{gs1} = v_{g+} - v_t$，电流 $i_{gm1} = g_{m1} v_{gs1}$ 从 $v_{o+}$ 到 $v_t$。\n  - $g_{m2}$, $v_{gs2} = v_{g-} - v_t$，电流 $i_{gm2} = g_{m2} v_{gs2}$ 从 $v_{o-}$ 到 $v_t$。\n- **无源元件**：\n  - $v_{o+}$ 处的负载：$R_{L+}$ 和 $C_{L+}$ 并联到地。\n  - $v_{o-}$ 处的负载：$R_{L-}$ 和 $C_{L-}$ 并联到地。\n  - 输出电阻：$r_{o+}$（在 $v_{o+}$ 和 $v_t$ 之间），$r_{o-}$（在 $v_{o-}$ 和 $v_t$ 之间）。\n  - 尾部阻抗：$R_t$ 和 $C_t$ 从节点 $v_t$ 并联到地。\n- **分析方法**：频域中的节点分析，其中 $s = j\\omega = j2\\pi f$。该系统是关于 $\\mathbf{v} = [v_{o+}, v_{o-}, v_t]^T$ 的 $3 \\times 3$ 线性系统。\n- **测量定义**：\n  - **奇模（用于 $A_d$）**：输入 $v_{g+} = +1/2$, $v_{g-} = -1/2$。差分输入 $v_{id} = 1$。差模增益 $A_d(\\omega) = v_{o+} - v_{o-}$。\n  - **偶模（用于 $A_{cd}$）**：输入 $v_{g+} = v_{g-} = 1$。共模输入 $v_{icm} = 1$。共模到差模转换增益 $A_{cd}(\\omega) = v_{o+} - v_{o-}$。\n- **输出量**：共模抑制比（CMRR），单位为分贝：$\\mathrm{CMRR}_{dB}(\\omega) = 20 \\log_{10}\\left(\\left|\\frac{A_d(\\omega)}{A_{cd}(\\omega)}\\right|\\right)$。\n- **失配模型**：\n  - $g_{m1} = g_m (1 + \\delta_{gm})$, $g_{m2} = g_m (1 - \\delta_{gm})$。\n  - $R_{L+} = R_L (1 + \\delta_{RL})$, $R_{L-} = R_L (1 - \\delta_{RL})$。\n  - 指定 $r_{o+} = r_{o-} = r_o$ 且 $C_{L+} = C_{L-} = C_L$。\n- **分析频率**：$f \\in \\{10^2, 10^4, 10^6, 10^8\\}$ Hz。\n- **测试用例**：\n  1. $g_m = 5 \\times 10^{-3}$, $r_o = 2 \\times 10^5$, $R_L = 10^4$, $C_L = 2 \\times 10^{-12}$, $R_t = 10^5$, $C_t = 1 \\times 10^{-12}$, $\\delta_{gm} = 0.02$, $\\delta_{RL} = 0.01$。\n  2. $g_m = 2 \\times 10^{-3}$, $r_o = 5 \\times 10^5$, $R_L = 2 \\times 10^4$, $C_L = 1 \\times 10^{-12}$, $R_t = 10^9$, $C_t = 1 \\times 10^{-12}$, $\\delta_{gm} = 0.0$, $\\delta_{RL} = 0.0$。\n  3. $g_m = 3 \\times 10^{-3}$, $r_o = 1.5 \\times 10^5$, $R_L = 8 \\times 10^3$, $C_L = 2 \\times 10^{-12}$, $R_t = 8 \\times 10^4$, $C_t = 1 \\times 10^{-12}$, $\\delta_{gm} = 0.1$, $\\delta_{RL} = 0.1$。\n  4. $g_m = 4 \\times 10^{-3}$, $r_o = 2 \\times 10^5$, $R_L = 5 \\times 10^3$, $C_L = 1 \\times 10^{-11}$, $R_t = 2 \\times 10^5$, $C_t = 5 \\times 10^{-12}$, $\\delta_{gm} = 0.03$, $\\delta_{RL} = 0.0$。\n\n### 步骤2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估：\n- **科学依据**：该问题描述了对差分放大器标准小信号线性模型的分析，这是模拟集成电路设计的基石。所引用的原理（Kirchhoff电流定律、节点分析、使用复阻抗的频域分析）是电气工程的基础。参数值对于典型的CMOS或BJT技术是符合实际的。\n- **适定性**：该问题是适定的。它要求解一个 $3 \\times 3$ 线性方程组，对于任何物理上现实的非零无源元件值集合，该方程组都有唯一解。输入激励、输出测量和最终量（CMRR）的定义都是精确且无歧义的。\n- **客观性**：问题以客观、正式的语言陈述。所有参数和目标都进行了定量定义。\n- **完整性**：问题是自包含的。它提供了完整的电路拓扑、所有元件模型（包括失配）、测试用例的所有数值、感兴趣的频率以及所需输出的精确定义。没有缺少任何信息。\n- **一致性**：问题陈述中没有矛盾之处。定义和模型在内部是一致的。\n\n### 步骤3：结论与行动\n问题是有效的。这是一个标准的、定义明确的模拟电路分析练习，可以从第一性原理出发通过算法解决。\n\n## 解决方案\n\n解决方案要求在频域中对给定的小信号电路模型进行节点分析。我们建立一个 $3 \\times 3$ 线性方程组 $\\mathbf{Y}\\mathbf{v} = \\mathbf{i}$，其中 $\\mathbf{v} = [v_{o+}, v_{o-}, v_t]^T$ 是未知节点电压的向量，$\\mathbf{Y}$ 是复导纳矩阵，$\\mathbf{i}$ 是流入节点的电流源向量。复频率由 $s = j\\omega$ 给出。\n\n在三个未知节点中的每一个节点上应用基尔霍夫电流定律（KCL），该定律指出离开每个节点的电流总和为零。\n\n**$v_{o+}$ 节点的KCL：**\n离开节点 $v_{o+}$ 的电流流经负载阻抗（$R_{L+}$ 和 $C_{L+}$）、输出电阻 $r_{o+}$ 和受控电流源 $i_{gm1}$。\n$$\nv_{o+} \\left( \\frac{1}{R_{L+}} + sC_{L+} \\right) + (v_{o+} - v_t) \\frac{1}{r_{o+}} + i_{gm1} = 0\n$$\n代入 $i_{gm1} = g_{m1}v_{gs1} = g_{m1}(v_{g+} - v_t)$：\n$$\nv_{o+} \\left( \\frac{1}{R_{L+}} + sC_{L+} + \\frac{1}{r_{o+}} \\right) - v_t \\left( \\frac{1}{r_{o+}} + g_{m1} \\right) = -g_{m1} v_{g+}\n$$\n这构成了我们线性系统的第一行。\n\n**$v_{o-}$ 节点的KCL：**\n对于负侧输出，分析是相同的：\n$$\nv_{o-} \\left( \\frac{1}{R_{L-}} + sC_{L-} \\right) + (v_{o-} - v_t) \\frac{1}{r_{o-}} + i_{gm2} = 0\n$$\n代入 $i_{gm2} = g_{m2}v_{gs2} = g_{m2}(v_{g-} - v_t)$：\n$$\nv_{o-} \\left( \\frac{1}{R_{L-}} + sC_{L-} + \\frac{1}{r_{o-}} \\right) - v_t \\left( \\frac{1}{r_{o-}} + g_{m2} \\right) = -g_{m2} v_{g-}\n$$\n这构成了第二行。\n\n**$v_t$ 节点的KCL：**\n电流通过尾阻抗（$R_t, C_t$）离开节点 $v_t$，并通过 $r_{o+}$ 和 $r_{o-}$ 返回输出节点。受控电流 $i_{gm1}$ 和 $i_{gm2}$流入此节点。\n$$\nv_t \\left( \\frac{1}{R_t} + sC_t \\right) + (v_t - v_{o+})\\frac{1}{r_{o+}} + (v_t - v_{o-})\\frac{1}{r_{o-}} - i_{gm1} - i_{gm2} = 0\n$$\n代入 $i_{gm1}$ 和 $i_{gm2}$ 的表达式：\n$$\n-v_{o+}\\left(\\frac{1}{r_{o+}}\\right) - v_{o-}\\left(\\frac{1}{r_{o-}}\\right) + v_t \\left( \\frac{1}{R_t} + sC_t + \\frac{1}{r_{o+}} + \\frac{1}{r_{o-}} + g_{m1} + g_{m2} \\right) = g_{m1}v_{g+} + g_{m2}v_{g-}\n$$\n这构成了第三行。\n\n系统 $\\mathbf{Y}\\mathbf{v} = \\mathbf{i}$ 定义如下：\n导纳矩阵 $\\mathbf{Y}$：\n$$\n\\mathbf{Y} =\n\\begin{pmatrix}\n\\frac{1}{R_{L+}} + sC_{L+} + \\frac{1}{r_{o+}} & 0 & -(\\frac{1}{r_{o+}} + g_{m1}) \\\\\n0 & \\frac{1}{R_{L-}} + sC_{L-} + \\frac{1}{r_{o-}} & -(\\frac{1}{r_{o-}} + g_{m2}) \\\\\n-\\frac{1}{r_{o+}} & -\\frac{1}{r_{o-}} & \\frac{1}{R_t} + sC_t + \\frac{1}{r_{o+}} + \\frac{1}{r_{o-}} + g_{m1} + g_{m2}\n\\end{pmatrix}\n$$\n源向量 $\\mathbf{i}$，它取决于输入激励 $v_{g+}$ 和 $v_{g-}$：\n$$\n\\mathbf{i} =\n\\begin{pmatrix}\n-g_{m1} v_{g+} \\\\\n-g_{m2} v_{g-} \\\\\ng_{m1}v_{g+} + g_{m2}v_{g-}\n\\end{pmatrix}\n$$\n\n对于每个测试用例和频率，我们执行以下步骤：\n1.  计算所有电路参数的数值，包括失配：$g_{m1}, g_{m2}, R_{L+}, R_{L-}$ 等。\n2.  计算复频率 $s = j2\\pi f$。\n3.  构建复数值矩阵 $\\mathbf{Y}$。\n\n4.  **差模增益 ($A_d$) 计算**：\n    - 施加奇模激励：$v_{g+} = +0.5$ V, $v_{g-} = -0.5$ V。这对应于差分输入 $v_{id} = v_{g+} - v_{g-} = 1$ V。\n    - 构建相应的源向量 $\\mathbf{i}_{odd}$。\n    - 求解线性系统 $\\mathbf{Y}\\mathbf{v}_{odd} = \\mathbf{i}_{odd}$ 以获得节点电压向量 $\\mathbf{v}_{odd} = [v_{o+,odd}, v_{o-,odd}, v_{t,odd}]^T$。\n    - 差模增益为 $A_d(\\omega) = \\frac{v_{o+,odd} - v_{o-,odd}}{v_{id}} = v_{o+,odd} - v_{o-,odd}$。\n\n5.  **共模到差模转换增益 ($A_{cd}$) 计算**：\n    - 施加偶模激励：$v_{g+} = v_{g-} = 1$ V。这对应于共模输入 $v_{icm} = \\frac{v_{g+} + v_{g-}}{2} = 1$ V。\n    - 构建相应的源向量 $\\mathbf{i}_{even}$。\n    - 求解线性系统 $\\mathbf{Y}\\mathbf{v}_{even} = \\mathbf{i}_{even}$ 以获得 $\\mathbf{v}_{even} = [v_{o+,even}, v_{o-,even}, v_{t,even}]^T$。\n    - 共模到差模转换增益为 $A_{cd}(\\omega) = \\frac{v_{o+,even} - v_{o-,even}}{v_{icm}} = v_{o+,even} - v_{o-,even}$。\n\n6.  **CMRR 计算**：\n    - CMRR幅值计算为复数增益幅值的比率：$\\mathrm{CMRR}(\\omega) = \\left|\\frac{A_d(\\omega)}{A_{cd}(\\omega)}\\right|$。\n    - 将其转换为分贝：$\\mathrm{CMRR}_{dB}(\\omega) = 20 \\log_{10}(\\mathrm{CMRR}(\\omega))$。\n\n对每个测试用例参数和频率的组合，以数值方式实现此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the CMRR of a differential amplifier for multiple test cases\n    and frequencies using nodal analysis.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (gm, ro, RL, CL, Rt, Ct, delta_gm, delta_RL)\n        (5e-3, 2e5, 1e4, 2e-12, 1e5, 1e-12, 0.02, 0.01),\n        (2e-3, 5e5, 2e4, 1e-12, 1e9, 1e-12, 0.0, 0.0),\n        (3e-3, 1.5e5, 8e3, 2e-12, 8e4, 1e-12, 0.1, 0.1),\n        (4e-3, 2e5, 5e3, 1e-11, 2e5, 5e-12, 0.03, 0.0),\n    ]\n\n    # Frequencies in Hz\n    frequencies = [1e2, 1e4, 1e6, 1e8]\n\n    results = []\n    \n    for case_params in test_cases:\n        gm, ro, RL, CL, Rt, Ct, delta_gm, delta_RL = case_params\n        \n        for f in frequencies:\n            # Complex angular frequency\n            s = 1j * 2 * np.pi * f\n\n            # Apply mismatch to parameters\n            gm1 = gm * (1 + delta_gm)\n            gm2 = gm * (1 - delta_gm)\n            RL_plus = RL * (1 + delta_RL)\n            RL_minus = RL * (1 - delta_RL)\n            \n            # Per the problem, ro and CL have no specified mismatch\n            ro_plus = ro\n            ro_minus = ro\n            CL_plus = CL\n            CL_minus = CL\n\n            # Component admittances and conductances\n            go_plus = 1.0 / ro_plus\n            go_minus = 1.0 / ro_minus\n            \n            Y_L_plus = (1.0 / RL_plus) + s * CL_plus if RL_plus != 0 else s * CL_plus\n            Y_L_minus = (1.0 / RL_minus) + s * CL_minus if RL_minus != 0 else s * CL_minus\n            Y_t = (1.0 / Rt) + s * Ct if Rt != 0 else s * Ct\n\n            # Construct the 3x3 admittance matrix Y\n            Y = np.zeros((3, 3), dtype=np.complex128)\n            \n            # Row 1 (Node v_o+)\n            Y[0, 0] = Y_L_plus + go_plus\n            Y[0, 1] = 0\n            Y[0, 2] = -(go_plus + gm1)\n            \n            # Row 2 (Node v_o-)\n            Y[1, 0] = 0\n            Y[1, 1] = Y_L_minus + go_minus\n            Y[1, 2] = -(go_minus + gm2)\n            \n            # Row 3 (Node v_t)\n            Y[2, 0] = -go_plus\n            Y[2, 1] = -go_minus\n            Y[2, 2] = Y_t + go_plus + go_minus + gm1 + gm2\n            \n            # === Differential-Mode Gain (Ad) Calculation ===\n            # Excitation: vg+ = +0.5, vg- = -0.5\n            vg_plus_odd = 0.5\n            vg_minus_odd = -0.5\n            \n            # Construct current source vector i_odd\n            i_odd = np.array([\n                -gm1 * vg_plus_odd,\n                -gm2 * vg_minus_odd,\n                gm1 * vg_plus_odd + gm2 * vg_minus_odd\n            ], dtype=np.complex128)\n            \n            # Solve for node voltages v_odd\n            v_odd = np.linalg.solve(Y, i_odd)\n            vo_plus_odd, vo_minus_odd = v_odd[0], v_odd[1]\n            \n            # Ad = (vo+ - vo-)/vid, where vid = 1\n            Ad = vo_plus_odd - vo_minus_odd\n\n            # === Common-Mode to Differential-Mode Gain (Acd) Calculation ===\n            # Excitation: vg+ = 1.0, vg- = 1.0\n            vg_plus_even = 1.0\n            vg_minus_even = 1.0\n            \n            # Construct current source vector i_even\n            i_even = np.array([\n                -gm1 * vg_plus_even,\n                -gm2 * vg_minus_even,\n                gm1 * vg_plus_even + gm2 * vg_minus_even\n            ], dtype=np.complex128)\n            \n            # Solve for node voltages v_even\n            v_even = np.linalg.solve(Y, i_even)\n            vo_plus_even, vo_minus_even = v_even[0], v_even[1]\n\n            # Acd = vod/vicm = (vo+ - vo-)/1, where vicm = 1\n            Acd = vo_plus_even - vo_minus_even\n            \n            # === CMRR Calculation ===\n            cmrr_mag = np.abs(Ad / Acd) if np.abs(Acd) > 1e-18 else np.inf\n            cmrr_db = 20 * np.log10(cmrr_mag)\n            \n            results.append(f\"{cmrr_db:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "分析和仿真揭示了失配的影响，但在现实世界中，工程师还需要主动校正这些非理想性。这项高级练习  将带你进入现代集成电路设计的核心挑战之一：通过数字校准来优化模拟性能。你将学习如何根据测量数据估计电路的内在失配参数，并构建一个线性规划（Linear Program, LP）模型，以在满足功耗和面积等实际约束的条件下，计算出最佳的修调（trim）设置，从而最大限度地提高 CMRR。",
            "id": "4261536",
            "problem": "考虑一个全差分放大器，其理想行为表现为零共模增益和较大的差模增益。由于器件失配，该放大器产生了非零的共模转换。一个校准网络提供了可调的修调（trim），这些修调线性地影响失配参数。目标是根据测量值估计失配，并计算修调设置，以在修调施加的功率和面积约束下，最大化共模抑制比（CMRR）。\n\n假设使用以下数学模型。设失配参数向量为 $u \\in \\mathbb{R}^{n}$，测得的输出残差（减去在所施加激励下的已知理想响应后）为 $r \\in \\mathbb{R}^{m}$。残差建模为 $r = A u + \\varepsilon$，其中 $A \\in \\mathbb{R}^{m \\times n}$ 是一个已知的测量灵敏度矩阵，$\\varepsilon \\in \\mathbb{R}^{m}$ 是测量噪声。共模增益灵敏度由向量 $c \\in \\mathbb{R}^{n}$ 表示，因此共模增益为 $A_{\\mathrm{c}}(u) = c^{\\mathsf{T}} u$。差模增益灵敏度为 $d \\in \\mathbb{R}^{n}$，理想差模增益为 $G_{\\mathrm{d0}} \\in \\mathbb{R}$，因此差模增益为 $A_{\\mathrm{d}}(u) = G_{\\mathrm{d0}} + d^{\\mathsf{T}} u$。修调 $t \\in \\mathbb{R}^{q}$ 通过 $T \\in \\mathbb{R}^{n \\times q}$ 映射为对失配的校正，因此校正后的失配为 $u_{\\mathrm{corr}} = \\hat{u} - T t$，其中 $\\hat{u}$ 是从测量中获得的 $u$ 的估计值。\n\n对修调的功率和面积约束分别由非负权重 $p \\in \\mathbb{R}^{q}$ 和 $a \\in \\mathbb{R}^{q}$ 以及预算 $P_{\\max} \\in \\mathbb{R}$ 和 $A_{\\max} \\in \\mathbb{R}$ 建模，强制要求 $\\sum_{i=1}^{q} p_{i} \\lvert t_{i} \\rvert \\leq P_{\\max}$ 和 $\\sum_{i=1}^{q} a_{i} \\lvert t_{i} \\rvert \\leq A_{\\max}$。每个修调元件的量值受 $t_{\\max} \\in \\mathbb{R}^{q}_{\\ge 0}$ 限制，强制要求对所有 $i$ 都有 $\\lvert t_{i} \\rvert \\leq t_{\\max,i}$。校准旨在最大化 CMRR，其定义为 $ \\mathrm{CMRR} = \\left\\lvert \\frac{A_{\\mathrm{d}}(u_{\\mathrm{corr}})}{A_{\\mathrm{c}}(u_{\\mathrm{corr}})} \\right\\rvert$。以分贝（dB）报告 CMRR，计算公式为 $20 \\log_{10}(\\mathrm{CMRR})$，四舍五入到三位小数。为避免当 $A_{\\mathrm{c}}(u_{\\mathrm{corr}})$ 为零时出现非有限值，对分母使用一个数值下限 $\\epsilon = 10^{-12}$。\n\n从上述定义和测量模型 $r = A u + \\varepsilon$ 出发，任务如下：\n- 通过最小化平方误差 $\\lVert A u - r \\rVert_{2}^{2}$ 来计算失配估计值 $\\hat{u}$，不假设 $A^{\\mathsf{T}} A$ 是可逆的。\n- 使用可作为线性规划求解的公式，计算修调向量 $t$，该向量在功率和面积预算以及修调范围的约束下，最小化校正后共模增益的量值 $\\lvert A_{\\mathrm{c}}(u_{\\mathrm{corr}}) \\rvert$。\n- 使用校正后的增益 $A_{\\mathrm{d}}(u_{\\mathrm{corr}})$ 和 $A_{\\mathrm{c}}(u_{\\mathrm{corr}})$ 计算最终的 CMRR（以 dB 为单位）。\n\n您的程序必须实现此校准过程，并将其应用于以下测试套件。在所有情况下，最终答案都以 dB 表示，并四舍五入到三位小数。最终输出必须是单行，包含一个用方括号括起来的逗号分隔列表形式的结果。\n\n测试套件：\n- 情况 1（一般良态情况）：\n  - $n = 3$, $m = 5$, $q = 3$。\n  - $A = \\begin{bmatrix} 0.9  0.1  0.0 \\\\ 1.0  -0.2  0.05 \\\\ 0.8  0.15  -0.05 \\\\ 1.1  -0.1  0.02 \\\\ 0.95  0.05  -0.01 \\end{bmatrix}$。\n  - $r = \\begin{bmatrix} -0.02 \\\\ -0.015 \\\\ -0.018 \\\\ -0.017 \\\\ -0.016 \\end{bmatrix}$。\n  - $c = \\begin{bmatrix} 0.04 \\\\ -0.02 \\\\ 0.5 \\end{bmatrix}$，$d = \\begin{bmatrix} 0.01 \\\\ 0.005 \\\\ 0.0 \\end{bmatrix}$，$G_{\\mathrm{d0}} = 80$。\n  - $T = I_{3}$（$3 \\times 3$ 单位矩阵）。\n  - $p = \\begin{bmatrix} 0.4 \\\\ 0.3 \\\\ 0.1 \\end{bmatrix}$，$a = \\begin{bmatrix} 0.2 \\\\ 0.5 \\\\ 0.1 \\end{bmatrix}$。\n  - $P_{\\max} = 0.05$，$A_{\\max} = 0.04$，$t_{\\max} = \\begin{bmatrix} 0.1 \\\\ 0.1 \\\\ 0.2 \\end{bmatrix}$。\n- 情况 2（预算充足，可实现近乎完美的抵消）：\n  - $n = 3$, $m = 5$, $q = 3$。\n  - $A = \\begin{bmatrix} 0.9  0.1  0.0 \\\\ 1.0  -0.2  0.05 \\\\ 0.8  0.15  -0.05 \\\\ 1.1  -0.1  0.02 \\\\ 0.95  0.05  -0.01 \\end{bmatrix}$。\n  - $r = \\begin{bmatrix} -0.02 \\\\ -0.015 \\\\ -0.018 \\\\ -0.017 \\\\ -0.016 \\end{bmatrix}$。\n  - $c = \\begin{bmatrix} 0.04 \\\\ -0.02 \\\\ 0.5 \\end{bmatrix}$，$d = \\begin{bmatrix} 0.01 \\\\ 0.005 \\\\ 0.0 \\end{bmatrix}$，$G_{\\mathrm{d0}} = 80$。\n  - $T = I_{3}$。\n  - $p = \\begin{bmatrix} 0.4 \\\\ 0.3 \\\\ 0.1 \\end{bmatrix}$，$a = \\begin{bmatrix} 0.2 \\\\ 0.5 \\\\ 0.1 \\end{bmatrix}$。\n  - $P_{\\max} = 0.5$，$A_{\\max} = 0.5$，$t_{\\max} = \\begin{bmatrix} 1.0 \\\\ 1.0 \\\\ 1.0 \\end{bmatrix}$。\n- 情况 3（病态测量和紧张预算）：\n  - $n = 3$, $m = 5$, $q = 3$。\n  - $A = \\begin{bmatrix} 1.0  0.999  1.001 \\\\ 0.999  1.0  1.001 \\\\ 1.001  1.002  1.999 \\\\ 1.0  0.999  1.001 \\\\ 0.999  1.0  1.001 \\end{bmatrix}$。\n  - $r = \\begin{bmatrix} -0.001 \\\\ -0.0015 \\\\ -0.002 \\\\ -0.0012 \\\\ -0.0013 \\end{bmatrix}$。\n  - $c = \\begin{bmatrix} 0.02 \\\\ -0.01 \\\\ 0.4 \\end{bmatrix}$，$d = \\begin{bmatrix} 0.008 \\\\ 0.004 \\\\ 0.0 \\end{bmatrix}$，$G_{\\mathrm{d0}} = 60$。\n  - $T = I_{3}$。\n  - $p = \\begin{bmatrix} 1.0 \\\\ 1.0 \\\\ 1.0 \\end{bmatrix}$，$a = \\begin{bmatrix} 1.0 \\\\ 1.0 \\\\ 1.0 \\end{bmatrix}$。\n  - $P_{\\max} = 0.001$，$A_{\\max} = 0.001$，$t_{\\max} = \\begin{bmatrix} 0.0005 \\\\ 0.0005 \\\\ 0.0005 \\end{bmatrix}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $\\left[ \\mathrm{result}_{1}, \\mathrm{result}_{2}, \\mathrm{result}_{3} \\right]$），其中每个 $\\mathrm{result}_{i}$ 是相应测试用例的 CMRR（以 dB 为单位），四舍五入到三位小数。",
            "solution": "用户提供的问题已经过严格验证，并被确定为有效。它在科学上基于模拟集成电路设计和线性系统理论的原理，问题定义明确、客观，并包含获得唯一解所需的所有必要信息。\n\n该问题要求对每个测试用例执行一个三步过程：\n1.  估计失配参数向量 $\\hat{u}$。\n2.  通过求解约束优化问题来计算最优修调向量 $t$。\n3.  计算最终的共模抑制比（CMRR），以分贝（dB）为单位。\n\n每个步骤的方法详述如下。\n\n### 步骤 1：失配参数估计\n\n测量的输出残差 $r \\in \\mathbb{R}^{m}$ 与失配参数向量 $u \\in \\mathbb{R}^{n}$ 之间的关系由线性模型 $r = A u + \\varepsilon$ 给出，其中 $A \\in \\mathbb{R}^{m \\times n}$ 是灵敏度矩阵，$\\varepsilon$ 是测量噪声。任务是通过最小化残差误差的欧几里得范数平方来计算真实失配向量 $u$ 的估计值 $\\hat{u}$，即求解最小二乘问题：\n$$\n\\min_{u \\in \\mathbb{R}^{n}} \\lVert A u - r \\rVert_{2}^{2}\n$$\n问题陈述正确地指出矩阵 $A^{\\mathsf{T}} A$ 可能不可逆，这种情况可能在 $A$ 的列线性无关或系统欠定时发生。该问题的最通用解由 $A$ 的 Moore-Penrose 伪逆给出，记作 $A^{+}$。该解在所有最小化残差的向量中提供了最小范数解。因此，估计值 $\\hat{u}$ 计算如下：\n$$\n\\hat{u} = A^{+} r\n$$\n\n### 步骤 2：最优修调向量计算\n\n下一步是确定最优修调向量 $t \\in \\mathbb{R}^{q}$，以最大化 CMRR。由于 $\\mathrm{CMRR} = |A_{\\mathrm{d}}/A_{\\mathrm{c}}|$，且差模增益 $A_{\\mathrm{d}}$ 通常很大并且随小校正变化不大，因此最大化 CMRR 近似等同于最小化共模增益的量值 $|A_{\\mathrm{c}}|$。校正后的失配为 $u_{\\mathrm{corr}} = \\hat{u} - T t$，其中 $T \\in \\mathbb{R}^{n \\times q}$ 是修调映射矩阵。校正后的共模增益为：\n$$\nA_{\\mathrm{c}}(u_{\\mathrm{corr}}) = c^{\\mathsf{T}} u_{\\mathrm{corr}} = c^{\\mathsf{T}}(\\hat{u} - T t) = c^{\\mathsf{T}}\\hat{u} - (c^{\\mathsf{T}}T)t\n$$\n优化问题是找到修调向量 $t$ 以最小化 $|A_{\\mathrm{c}}(u_{\\mathrm{corr}})|$，并满足一组约束条件：\n1.  功率约束：$\\sum_{i=1}^{q} p_{i} \\lvert t_{i} \\rvert \\leq P_{\\max}$\n2.  面积约束：$\\sum_{i=1}^{q} a_{i} \\lvert t_{i} \\rvert \\leq A_{\\max}$\n3.  修调范围约束：对 $i=1, \\dots, q$，有 $\\lvert t_{i} \\rvert \\leq t_{\\max,i}$\n\n目标函数 $\\min_t |c^{\\mathsf{T}}\\hat{u} - (c^{\\mathsf{T}}T)t|$ 是非线性的。这个问题可以被重新表述为一个线性规划（LP）问题。我们引入一个新的非负标量变量 $z$，我们的目标是最小化它。目标变为 $\\min z$，受限于原始约束和一个附加约束 $|c^{\\mathsf{T}}\\hat{u} - (c^{\\mathsf{T}}T)t| \\le z$。这等价于两个线性不等式：\n$$\nc^{\\mathsf{T}}\\hat{u} - (c^{\\mathsf{T}}T)t \\le z \\quad \\text{和} \\quad c^{\\mathsf{T}}\\hat{u} - (c^{\\mathsf{T}}T)t \\ge -z\n$$\n涉及 $t_i$ 绝对值的约束也是非线性的。我们通过为 $i=1, \\dots, q$ 引入 $q$ 个新的非负变量 $\\tau_i$ 来将其线性化，使得 $\\tau_i \\ge |t_i|$。这个单一条件被替换为两个线性不等式：$t_i \\le \\tau_i$ 和 $-t_i \\le \\tau_i$。功率和面积约束在 $\\tau_i$ 方面变为线性的：$\\sum p_i \\tau_i \\leq P_{\\max}$ 和 $\\sum a_i \\tau_i \\leq A_{\\max}$。\n\n完整的 LP 公式如下：\n\n-   **优化变量**：$t \\in \\mathbb{R}^q$, $\\tau \\in \\mathbb{R}^q$, $z \\in \\mathbb{R}$。\n-   **目标函数**：最小化 $z$。\n-   **约束条件**：\n    1.  $(c^{\\mathsf{T}}T)t + z \\ge c^{\\mathsf{T}}\\hat{u}$\n    2.  $-(c^{\\mathsf{T}}T)t + z \\ge -c^{\\mathsf{T}}\\hat{u}$\n    3.  $p^{\\mathsf{T}}\\tau \\le P_{\\max}$\n    4.  $a^{\\mathsf{T}}\\tau \\le A_{\\max}$\n    5.  对 $i=1, \\dots, q$，有 $t_i - \\tau_i \\le 0$\n    6.  对 $i=1, \\dots, q$，有 $-t_i - \\tau_i \\le 0$\n    7.  对 $i=1, \\dots, q$，有 $-t_{\\max,i} \\le t_i \\le t_{\\max,i}$\n    8.  对 $i=1, \\dots, q$，有 $\\tau_i \\ge 0$\n    9.  $z \\ge 0$\n\n这个 LP 可以使用标准求解器求解，以找到最优修调向量 $t$。\n\n### 步骤 3：CMRR 计算\n\n利用步骤 2 中得到的最优修调向量 $t$，计算最终的校准性能。\n1.  计算校正后的失配向量：\n    $$\n    u_{\\mathrm{corr}} = \\hat{u} - T t\n    $$\n2.  计算校正后的共模增益和差模增益：\n    $$\n    A_{\\mathrm{c,corr}} = c^{\\mathsf{T}} u_{\\mathrm{corr}}\n    $$\n    $$\n    A_{\\mathrm{d,corr}} = G_{\\mathrm{d0}} + d^{\\mathsf{T}} u_{\\mathrm{corr}}\n    $$\n3.  计算 CMRR 值。为处理 $A_{\\mathrm{c,corr}}$ 为零或接近零的情况，对分母的量值使用一个数值下限 $\\epsilon = 10^{-12}$：\n    $$\n    \\mathrm{CMRR} = \\frac{\\lvert A_{\\mathrm{d,corr}} \\rvert}{\\max(\\epsilon, \\lvert A_{\\mathrm{c,corr}} \\rvert)}\n    $$\n4.  将结果转换为分贝（dB）并四舍五入到三位小数：\n    $$\n    \\mathrm{CMRR}_{\\mathrm{dB}} = 20 \\log_{10}(\\mathrm{CMRR})\n    $$\n\n此三步过程被实现并应用于问题中指定的每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the CMRR calibration problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general well-conditioned case)\n        {\n            \"n\": 3, \"m\": 5, \"q\": 3,\n            \"A\": np.array([\n                [0.9, 0.1, 0.0],\n                [1.0, -0.2, 0.05],\n                [0.8, 0.15, -0.05],\n                [1.1, -0.1, 0.02],\n                [0.95, 0.05, -0.01]\n            ]),\n            \"r\": np.array([-0.02, -0.015, -0.018, -0.017, -0.016]),\n            \"c\": np.array([0.04, -0.02, 0.5]),\n            \"d\": np.array([0.01, 0.005, 0.0]),\n            \"G_d0\": 80.,\n            \"T\": np.identity(3),\n            \"p\": np.array([0.4, 0.3, 0.1]),\n            \"a\": np.array([0.2, 0.5, 0.1]),\n            \"P_max\": 0.05,\n            \"A_max\": 0.04,\n            \"t_max\": np.array([0.1, 0.1, 0.2])\n        },\n        # Case 2 (ample budgets enabling near-perfect cancellation)\n        {\n            \"n\": 3, \"m\": 5, \"q\": 3,\n            \"A\": np.array([\n                [0.9, 0.1, 0.0],\n                [1.0, -0.2, 0.05],\n                [0.8, 0.15, -0.05],\n                [1.1, -0.1, 0.02],\n                [0.95, 0.05, -0.01]\n            ]),\n            \"r\": np.array([-0.02, -0.015, -0.018, -0.017, -0.016]),\n            \"c\": np.array([0.04, -0.02, 0.5]),\n            \"d\": np.array([0.01, 0.005, 0.0]),\n            \"G_d0\": 80.,\n            \"T\": np.identity(3),\n            \"p\": np.array([0.4, 0.3, 0.1]),\n            \"a\": np.array([0.2, 0.5, 0.1]),\n            \"P_max\": 0.5,\n            \"A_max\": 0.5,\n            \"t_max\": np.array([1.0, 1.0, 1.0])\n        },\n        # Case 3 (ill-conditioned measurements and tight budgets)\n        {\n            \"n\": 3, \"m\": 5, \"q\": 3,\n            \"A\": np.array([\n                [1.0, 0.999, 1.001],\n                [0.999, 1.0, 1.001],\n                [1.001, 1.002, 1.999],\n                [1.0, 0.999, 1.001],\n                [0.999, 1.0, 1.001]\n            ]),\n            \"r\": np.array([-0.001, -0.0015, -0.002, -0.0012, -0.0013]),\n            \"c\": np.array([0.02, -0.01, 0.4]),\n            \"d\": np.array([0.008, 0.004, 0.0]),\n            \"G_d0\": 60.,\n            \"T\": np.identity(3),\n            \"p\": np.array([1.0, 1.0, 1.0]),\n            \"a\": np.array([1.0, 1.0, 1.0]),\n            \"P_max\": 0.001,\n            \"A_max\": 0.001,\n            \"t_max\": np.array([0.0005, 0.0005, 0.0005])\n        }\n    ]\n\n    results = []\n    epsilon = 1e-12\n\n    for case in test_cases:\n        # Step 1: Mismatch Parameter Estimation\n        u_hat = np.linalg.pinv(case[\"A\"]) @ case[\"r\"]\n\n        # Step 2: Optimal Trim Vector Computation via Linear Programming\n        q = case[\"q\"]\n        \n        # LP variable vector: x = [t_1,..,t_q, tau_1,..,tau_q, z]\n        # Total variables = 2q + 1\n        \n        # Objective: minimize z. Cost vector c_lp has 1 at the last position.\n        c_lp = np.zeros(2 * q + 1)\n        c_lp[-1] = 1.0\n\n        # Inequality constraints: A_ub * x = b_ub\n        # Let v = T.T @ c\n        v = case[\"T\"].T @ case[\"c\"]\n        k = case[\"c\"].T @ u_hat\n\n        # Number of inequality constraints: 2 (for z) + 2 (p, a) + 2q (for tau)\n        A_ub = np.zeros((4 + 2 * q, 2 * q + 1))\n        b_ub = np.zeros(4 + 2 * q)\n\n        # Constraint 1: c.T@u_hat - (c.T@T)@t = z  => -(c.T@T)@t - z = -c.T@u_hat\n        A_ub[0, 0:q] = -v\n        A_ub[0, -1] = -1.0\n        b_ub[0] = -k\n        \n        # Constraint 2: c.T@u_hat - (c.T@T)@t >= -z => (c.T@T)@t - z = c.T@u_hat\n        A_ub[1, 0:q] = v\n        A_ub[1, -1] = -1.0\n        b_ub[1] = k\n\n        # Constraint 3: p.T @ tau = P_max\n        A_ub[2, q:2*q] = case[\"p\"]\n        b_ub[2] = case[\"P_max\"]\n        \n        # Constraint 4: a.T @ tau = A_max\n        A_ub[3, q:2*q] = case[\"a\"]\n        b_ub[3] = case[\"A_max\"]\n\n        # Constraints 5 and 6: t_i = tau_i and -t_i = tau_i for i=1..q\n        for i in range(q):\n            # t_i - tau_i = 0\n            A_ub[4 + i, i] = 1.0\n            A_ub[4 + i, q + i] = -1.0\n            b_ub[4 + i] = 0.0\n            # -t_i - tau_i = 0\n            A_ub[4 + q + i, i] = -1.0\n            A_ub[4 + q + i, q + i] = -1.0\n            b_ub[4 + q + i] = 0.0\n\n        # Bounds on variables\n        bounds = []\n        for i in range(q): # Bounds for t_i\n            bounds.append((-case[\"t_max\"][i], case[\"t_max\"][i]))\n        for i in range(q): # Bounds for tau_i\n            bounds.append((0, None))\n        bounds.append((0, None)) # Bound for z\n\n        # Solve the LP\n        # method='highs' is the default and recommended solver in recent SciPy versions\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        t_opt = res.x[0:q]\n\n        # Step 3: CMRR Calculation\n        u_corr = u_hat - case[\"T\"] @ t_opt\n        Ac_corr = case[\"c\"].T @ u_corr\n        Ad_corr = case[\"G_d0\"] + case[\"d\"].T @ u_corr\n        \n        cmrr_val = np.abs(Ad_corr) / max(epsilon, np.abs(Ac_corr))\n        cmrr_db = 20 * np.log10(cmrr_val)\n        \n        results.append(round(cmrr_db, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}