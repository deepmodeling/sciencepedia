{
    "hands_on_practices": [
        {
            "introduction": "The MOS differential pair is the fundamental building block of most differential amplifiers. This practice delves into how two key non-idealities, mismatched load resistors and the finite impedance of the tail current source, work together to convert undesirable common-mode signals into differential errors. By analyzing the circuit's behavior in its asymptotic limits , we can develop a deep physical intuition for the critical role the tail current source plays in achieving a high Common-Mode Rejection Ratio (CMRR).",
            "id": "4261577",
            "problem": "Consider a symmetric Metal–Oxide–Semiconductor (MOS) differential pair used as a resistively loaded amplifier. Each transistor has small-signal transconductance $g_{m}$ and negligible output resistance. The two drains are connected to a stiff supply through resistors $R_{D1}$ and $R_{D2}$, respectively. The two sources are shorted together and connected to ground through a finite tail resistance $R_{t}$ that models the non-ideal output resistance of the tail current source. The load resistors have a small mismatch modeled by $R_{D1} = R(1+\\alpha)$ and $R_{D2} = R(1-\\alpha)$, where $R > 0$ and $|\\alpha| \\ll 1$. A pure common-mode small-signal input $v_{cm}$ is applied equally to both gates. Let the differential output voltage be $v_{od} = v_{o1} - v_{o2}$, and define the common-mode gain $A_{c}$ as $A_{c} = v_{od}/v_{cm}$. Work in the small-signal regime and assume linear time-invariant behavior.\n\nStarting from fundamental circuit relations (Kirchhoff’s laws, linear small-signal transconductance, and Ohm’s law), derive $A_{c}$ symbolically for arbitrary $R_{t}$, $g_{m}$, $R$, and $\\alpha$, and then determine the limiting behavior of $A_{c}$ as $R_{t} \\to \\infty$ and as $R_{t} \\to 0$. Discuss the physical implications of these asymptotic limits for the Common-Mode Rejection Ratio (CMRR), defined as the magnitude ratio of differential-mode gain to common-mode gain, for this circuit.\n\nExpress your final answer as the ordered pair consisting of the two limits $\\left(\\lim_{R_{t}\\to\\infty} A_{c},\\ \\lim_{R_{t}\\to 0} A_{c}\\right)$ as closed-form algebraic expressions. No numerical evaluation or rounding is required.",
            "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in standard small-signal circuit theory, is well-posed with all necessary information provided, and is expressed in objective, unambiguous language. We may therefore proceed with a formal solution.\n\nThe problem asks for the derivation of the common-mode gain $A_c$ for a resistively loaded MOS differential pair with a finite tail resistance $R_t$ and mismatched load resistors $R_{D1}$ and $R_{D2}$. We will use a small-signal equivalent circuit model.\n\nLet the two transistors be $M_1$ and $M_2$. The small-signal transconductance of each is $g_m$. A common-mode input voltage $v_{cm}$ is applied to both gates, so $v_{g1} = v_{g2} = v_{cm}$. The sources of $M_1$ and $M_2$ are connected together at a node with voltage $v_s$. This common source node is connected to ground through the tail resistance $R_t$. The transistor output resistances are negligible.\n\nThe small-signal gate-to-source voltages for $M_1$ and $M_2$ are identical:\n$$v_{gs1} = v_{g1} - v_s = v_{cm} - v_s$$\n$$v_{gs2} = v_{g2} - v_s = v_{cm} - v_s$$\nConsequently, the small-signal drain currents are also identical, given by the linear transconductance relation:\n$$i_{d1} = g_m v_{gs1} = g_m (v_{cm} - v_s)$$\n$$i_{d2} = g_m v_{gs2} = g_m (v_{cm} - v_s)$$\nSo, $i_{d1} = i_{d2}$.\n\nThe drains are connected to the AC ground (the stiff supply) through resistors $R_{D1}$ and $R_{D2}$. The output voltages $v_{o1}$ and $v_{o2}$ are determined by Ohm's law:\n$$v_{o1} = -i_{d1} R_{D1}$$\n$$v_{o2} = -i_{d2} R_{D2}$$\n\nTo find the common source node voltage $v_s$, we apply Kirchhoff's Current Law (KCL) at this node. The sum of the two source currents, which are equal to their respective drain currents for MOS transistors, flows through the tail resistor $R_t$.\n$$i_{d1} + i_{d2} = \\frac{v_s}{R_t}$$\nSince $i_{d1} = i_{d2}$, this becomes:\n$$2 i_{d1} = \\frac{v_s}{R_t}$$\nNow we substitute the expression for $i_{d1}$:\n$$2 g_m (v_{cm} - v_s) = \\frac{v_s}{R_t}$$\nWe can now solve for $v_s$ in terms of $v_{cm}$:\n$$2 g_m R_t (v_{cm} - v_s) = v_s$$\n$$2 g_m R_t v_{cm} - 2 g_m R_t v_s = v_s$$\n$$2 g_m R_t v_{cm} = v_s (1 + 2 g_m R_t)$$\n$$v_s = \\frac{2 g_m R_t}{1 + 2 g_m R_t} v_{cm}$$\n\nTo find the drain currents, we first express the gate-to-source voltage $v_{cm} - v_s$ in terms of $v_{cm}$:\n$$v_{cm} - v_s = v_{cm} - \\left( \\frac{2 g_m R_t}{1 + 2 g_m R_t} \\right) v_{cm} = v_{cm} \\left( 1 - \\frac{2 g_m R_t}{1 + 2 g_m R_t} \\right)$$\n$$v_{cm} - v_s = v_{cm} \\left( \\frac{1 + 2 g_m R_t - 2 g_m R_t}{1 + 2 g_m R_t} \\right) = \\frac{1}{1 + 2 g_m R_t} v_{cm}$$\nThe drain current $i_{d1}$ is therefore:\n$$i_{d1} = g_m (v_{cm} - v_s) = \\frac{g_m}{1 + 2 g_m R_t} v_{cm}$$\nAnd since $i_{d1}=i_{d2}$, we have the same expression for $i_{d2}$.\n\nThe differential output voltage is defined as $v_{od} = v_{o1} - v_{o2}$. Substituting the expressions for the output voltages:\n$$v_{od} = (-i_{d1} R_{D1}) - (-i_{d2} R_{D2}) = -i_{d1} (R_{D1} - R_{D2})$$\nNow, substitute the expression for $i_{d1}$:\n$$v_{od} = -\\left( \\frac{g_m}{1 + 2 g_m R_t} v_{cm} \\right) (R_{D1} - R_{D2})$$\nThe common-mode gain $A_c$ is defined as $A_c = v_{od} / v_{cm}$:\n$$A_c = \\frac{-g_m (R_{D1} - R_{D2})}{1 + 2 g_m R_t}$$\nNext, we use the given models for the mismatched resistors: $R_{D1} = R(1+\\alpha)$ and $R_{D2} = R(1-\\alpha)$. The difference is:\n$$R_{D1} - R_{D2} = R(1+\\alpha) - R(1-\\alpha) = R + R\\alpha - R + R\\alpha = 2R\\alpha$$\nSubstituting this into the expression for $A_c$:\n$$A_c = \\frac{-g_m (2R\\alpha)}{1 + 2 g_m R_t} = \\frac{-2g_m R \\alpha}{1 + 2 g_m R_t}$$\nThis is the symbolic expression for the common-mode gain.\n\nNow, we evaluate the required limits.\nFirst, the limit as $R_t \\to \\infty$:\n$$\\lim_{R_t\\to\\infty} A_{c} = \\lim_{R_t\\to\\infty} \\frac{-2g_m R \\alpha}{1 + 2 g_m R_t}$$\nAs $R_t$ approaches infinity, the denominator $1 + 2 g_m R_t$ approaches infinity. For any finite numerator, the fraction approaches zero.\n$$\\lim_{R_t\\to\\infty} A_{c} = 0$$\n\nSecond, the limit as $R_t \\to 0$:\n$$\\lim_{R_t\\to 0} A_{c} = \\frac{-2g_m R \\alpha}{1 + 2 g_m (0)} = \\frac{-2g_m R \\alpha}{1}$$\n$$\\lim_{R_t\\to 0} A_{c} = -2g_m R \\alpha$$\n\nThe physical implications for the Common-Mode Rejection Ratio (CMRR) are significant. The CMRR is defined as the magnitude ratio of the differential-mode gain, $A_d$, to the common-mode gain, $A_c$:\n$$CMRR = \\left| \\frac{A_d}{A_c} \\right|$$\nFirst, let's find $A_d = v_{od} / v_{id}$, where $v_{id} = v_{g1} - v_{g2}$. We set $v_{g1} = v_{id}/2$ and $v_{g2} = -v_{id}/2$. In this case, $i_{d1} = -i_{d2}$ and $v_s = 0$ (virtual ground). The output voltage is $v_{od} = v_{o1} - v_{o2} = -i_{d1} R_{D1} - (-i_{d1} R_{D2}) = i_{d1}(R_{D2} - R_{D1})$. However, the standard definition of $A_d$ assumes matched components, or at least it characterizes the primary differential amplification. The differential gain is $A_d = -g_m R_D$ where $R_D$ is the load resistance. Taking the average load $R$, we have $A_d \\approx -g_m R$. More precisely, $v_{od} = -g_m(v_{g1}-v_s)R_{D1} - (-g_m(v_{g2}-v_s)R_{D2}) = -g_m(R_{D1}v_{g1}+R_{D2}v_{g2})$ with $v_s = 0$. So $v_{od} = -g_m(R_{D1}v_{id}/2 + R_{D2}(-v_{id}/2)) = -\\frac{g_m v_{id}}{2}(R_{D1}-R_{D2}) = -g_m R \\alpha v_{id}$. Wait, this is the differential gain's sensitivity to mismatch. The main differential gain is $A_d = v_{od}/v_{id} = -(g_m/2)(R_{D1}+R_{D2}) = -g_m R$. So, $|A_d| = g_m R$.\nThe CMRR is then:\n$$CMRR = \\left| \\frac{-g_m R}{\\frac{-2g_m R \\alpha}{1 + 2 g_m R_t}} \\right| = \\left| \\frac{1 + 2 g_m R_t}{2\\alpha} \\right| = \\frac{1 + 2 g_m R_t}{2|\\alpha|}$$\n- For $R_t \\to \\infty$: $A_c \\to 0$ and $CMRR \\to \\infty$. A large tail impedance (approaching an ideal current source) forces the sum of the transistor currents to be constant (AC zero). This provides strong negative feedback that suppresses any common-mode voltage variations at the source node, driving the signal currents to zero. Consequently, even with resistor mismatch, the common-mode input does not produce a differential output, leading to infinite CMRR. This is the ideal operating condition.\n- For $R_t \\to 0$: $A_c \\to -2g_m R \\alpha$ and $CMRR \\to \\frac{1}{2|\\alpha|}$. With zero tail impedance, the two transistors act as independent common-source amplifiers. The common-mode input $v_{cm}$ is amplified by each. The differential output $v_{od}$ is non-zero solely due to the mismatch $\\alpha$ in the load resistors. The circuit loses its common-mode rejection capability provided by the tail current source, and the CMRR becomes finite, limited by the precision of component matching. A larger mismatch $\\alpha$ results in a larger $A_c$ and thus a smaller (worse) CMRR.\n\nThe final answer requires the ordered pair of the two limits for $A_c$.\nThe limit as $R_t \\to \\infty$ is $0$.\nThe limit as $R_t \\to 0$ is $-2g_m R \\alpha$.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0 & -2 g_{m} R \\alpha \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Building on our intuition about mismatch, this exercise addresses a crucial design challenge: translating a high-level performance specification into a physical manufacturing requirement. We will analyze the classic four-resistor difference amplifier to derive a direct, quantitative link between a target CMRR and the necessary resistor matching tolerance . This practice is essential for any designer, as it demonstrates how abstract system goals are grounded in the concrete realities of component precision in integrated circuits.",
            "id": "4261609",
            "problem": "A monolithic difference amplifier is implemented in an integrated circuit environment within Electronic Design Automation (EDA). The amplifier uses a single operational amplifier with a four-resistor network: resistor $R_1$ connects input $v_1$ to the inverting input, resistor $R_2$ provides feedback from the output to the inverting input, resistor $R_3$ connects input $v_2$ to the non-inverting input, and resistor $R_4$ connects the non-inverting input to ground. Assume the operational amplifier is ideal, and the only source of common-mode gain arises from resistor mismatch in the gain-setting network. The nominal design is symmetric with $R_1 = R_3 = 10\\,\\mathrm{k}\\Omega$ and $R_2 = R_4 = 100\\,\\mathrm{k}\\Omega$, so the intended differential gain is $k = R_2/R_1 = 10$.\n\nLet the actual resistors be $R_i(1+\\Delta_i)$ for $i \\in \\{1,2,3,4\\}$, where each $\\Delta_i$ is an unknown fractional deviation due to mismatch. For layout-matched devices, you may assume the worst-case bound $|\\Delta_i| \\leq t$, where $t$ is the matching specification to be determined. Define the Common-Mode Rejection Ratio (CMRR) as the magnitude ratio of differential gain to common-mode gain of the overall amplifier. The target is to ensure a minimum $\\mathrm{CMRR_{dB}}$ of $96$ decibels across all mismatch combinations satisfying $|\\Delta_i| \\leq t$.\n\nStarting from the ideal operational amplifier constraints and resistor network laws, derive the first-order sensitivity of the Common-Mode Rejection Ratio (CMRR) to small mismatch in the resistor ratios. Then, using a worst-case deterministic bound on the mismatch, determine the minimal matching specification $t$ (as a decimal fraction) such that the worst-case $\\mathrm{CMRR_{dB}}$ is at least $96$ decibels for the given nominal values. Express the final tolerance $t$ as a decimal fraction and round your answer to three significant figures. Do not use a percentage sign in your final expression.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- Circuit: Monolithic difference amplifier with a single ideal operational amplifier (op-amp).\n- Resistor Network: $R_1$ from input $v_1$ to inverting input, $R_2$ from output to inverting input, $R_3$ from input $v_2$ to non-inverting input, $R_4$ from non-inverting input to ground.\n- Op-amp Model: Ideal.\n- Nominal Resistor Values: $R_1 = R_3 = 10\\,\\mathrm{k}\\Omega$, $R_2 = R_4 = 100\\,\\mathrm{k}\\Omega$.\n- Nominal Differential Gain: $k = R_2/R_1 = 10$.\n- Actual Resistor Values: $R_i' = R_i(1+\\Delta_i)$ for $i \\in \\{1,2,3,4\\}$, where $\\Delta_i$ is the fractional deviation.\n- Mismatch Bound: $|\\Delta_i| \\leq t$ for all $i$.\n- CMRR Definition: $\\mathrm{CMRR} = |A_d / A_{cm}|$, where $A_d$ is the differential gain and $A_{cm}$ is the common-mode gain.\n- Performance Target: Minimum $\\mathrm{CMRR_{dB}} \\geq 96$ decibels.\n- Objective: Determine the minimal matching specification, $t$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is based on fundamental principles of analog circuit theory, specifically the analysis of a difference amplifier. The model for resistor mismatch and the definition of CMRR are standard in the field of integrated circuit design. The use of an ideal op-amp is a common and appropriate simplification for this type of first-order analysis. The problem is scientifically sound.\n- **Well-Posedness**: The problem provides all necessary information: the circuit topology, component values, a model for non-idealities (mismatch), and a clear performance target. It asks for a specific, calculable quantity ($t$). The problem is well-posed.\n- **Objectivity**: The problem is stated in precise, technical language, free of ambiguity or subjective claims.\n\n### Step 3: Verdict and Action\nThe problem is valid. The solution process will proceed.\n\n### Derivation of the Solution\nThe output voltage $v_{out}$ of the difference amplifier is determined by the resistor network and the ideal op-amp constraints. For an ideal op-amp, the differential input voltage is zero, so the voltage at the inverting input ($v_-$) equals the voltage at the non-inverting input ($v_+$).\n\nThe voltage at the non-inverting input, $v_+$, is determined by the voltage divider formed by the actual resistors $R_3'$ and $R_4'$:\n$$v_+ = v_2 \\frac{R_4'}{R_3' + R_4'}$$\nDue to the ideal op-amp assumption ($v_- = v_+$) and zero input current, the relationship between the inputs and output at the inverting terminal is given by a standard inverting amplifier configuration, but with $v_-$ as the reference:\n$$\\frac{v_1 - v_-}{R_1'} = \\frac{v_- - v_{out}}{R_2'}$$\nSolving for $v_{out}$:\n$$v_{out} R_1' = v_-(R_1' + R_2') - v_1 R_2'$$\n$$v_{out} = v_- \\left(1 + \\frac{R_2'}{R_1'}\\right) - v_1 \\frac{R_2'}{R_1'}$$\nSubstituting the expression for $v_-$ (since $v_-=v_+$):\n$$v_{out} = v_2 \\frac{R_4'}{R_3' + R_4'} \\left(1 + \\frac{R_2'}{R_1'}\\right) - v_1 \\frac{R_2'}{R_1'}$$\nThis is the general expression for the output voltage. To find the differential and common-mode gains, we express $v_{out}$ in terms of the differential input $v_d = v_2 - v_1$ and the common-mode input $v_{cm} = (v_1 + v_2)/2$. The output is $v_{out} = A_d v_d + A_{cm} v_{cm}$.\n\nThe common-mode gain, $A_{cm}$, is the output voltage when $v_1 = v_2 = v_{cm}$ ($v_d=0$):\n$$A_{cm} = \\frac{v_{out}}{v_{cm}} = \\frac{R_4'}{R_3' + R_4'} \\left(1 + \\frac{R_2'}{R_1'}\\right) - \\frac{R_2'}{R_1'}$$\nThis can be simplified by finding a common denominator:\n$$A_{cm} = \\frac{R_4'(R_1' + R_2') - R_2'(R_3' + R_4')}{R_1'(R_3' + R_4')} = \\frac{R_1'R_4' - R_2'R_3'}{R_1'(R_3' + R_4')}$$\nFor perfect matching, the resistor ratios are equal, $R_2/R_1 = R_4/R_3$, which implies $R_1R_4 = R_2R_3$, and thus $A_{cm}=0$. Mismatch in the resistors causes a non-zero $A_{cm}$.\n\nLet's substitute the actual resistor values $R_i' = R_i(1+\\Delta_i)$ and the nominal design values $R_1 = R_3 = R_A$ and $R_2 = R_4 = R_B$. The nominal gain is $k=R_B/R_A$.\n$$R_1'R_4' - R_2'R_3' = R_A(1+\\Delta_1)R_B(1+\\Delta_4) - R_B(1+\\Delta_2)R_A(1+\\Delta_3)$$\n$$= R_A R_B \\left[ (1+\\Delta_1)(1+\\Delta_4) - (1+\\Delta_2)(1+\\Delta_3) \\right]$$\nFor small mismatches ($|\\Delta_i| \\ll 1$), we retain only first-order terms:\n$$R_1'R_4' - R_2'R_3' \\approx R_A R_B \\left[ (1+\\Delta_1+\\Delta_4) - (1+\\Delta_2+\\Delta_3) \\right] = R_A R_B (\\Delta_1 - \\Delta_2 - \\Delta_3 + \\Delta_4)$$\nThe denominator of $A_{cm}$ is $R_1'(R_3' + R_4')$. To first-order, this is approximately its nominal value:\n$$R_1'(R_3' + R_4') \\approx R_A(R_A + R_B) = R_A^2(1+k)$$\nSo, the first-order approximation for the common-mode gain is:\n$$A_{cm} \\approx \\frac{R_A R_B (\\Delta_1 - \\Delta_2 - \\Delta_3 + \\Delta_4)}{R_A^2(1+k)} = \\frac{(R_B/R_A)}{1+k} (\\Delta_1 - \\Delta_2 - \\Delta_3 + \\Delta_4)$$\n$$A_{cm} \\approx \\frac{k}{1+k} (\\Delta_1 - \\Delta_2 - \\Delta_3 + \\Delta_4)$$\nThe differential gain $A_d$ is nominally $k = R_2/R_1$. The mismatches $\\Delta_i$ cause small deviations in $A_d$. However, for the CMRR calculation, which is the ratio of $A_d$ to $A_{cm}$, the dominant effect is the change in $A_{cm}$ from zero to a small value. The fractional change in $A_d$ is a higher-order effect on the CMRR. Thus, we can approximate $A_d \\approx k$. This is the basis of the first-order sensitivity analysis.\n\nThe Common-Mode Rejection Ratio is then:\n$$\\mathrm{CMRR} = \\left|\\frac{A_d}{A_{cm}}\\right| \\approx \\left| \\frac{k}{\\frac{k}{1+k}(\\Delta_1 - \\Delta_2 - \\Delta_3 + \\Delta_4)} \\right| = \\left| \\frac{1+k}{\\Delta_1 - \\Delta_2 - \\Delta_3 + \\Delta_4} \\right|$$\nTo guarantee a minimum CMRR, we must consider the worst-case scenario. The CMRR is minimized when the denominator $|\\Delta_1 - \\Delta_2 - \\Delta_3 + \\Delta_4|$ is maximized. Given the constraint $|\\Delta_i| \\leq t$, we can maximize this term by choosing a specific combination of mismatches. Let $\\Delta_1 = t$, $\\Delta_4 = t$, $\\Delta_2 = -t$, and $\\Delta_3 = -t$. All these satisfy the bound. The denominator becomes:\n$$|\\Delta_1 - \\Delta_2 - \\Delta_3 + \\Delta_4|_{max} = |t - (-t) - (-t) + t| = |4t| = 4t$$\nSo, the minimum (worst-case) CMRR for a given matching specification $t$ is:\n$$\\mathrm{CMRR_{min}} = \\frac{1+k}{4t}$$\nThe problem requires a minimum $\\mathrm{CMRR_{dB}}$ of $96\\,\\mathrm{dB}$. The conversion from a linear ratio to decibels is $\\mathrm{CMRR_{dB}} = 20 \\log_{10}(\\mathrm{CMRR})$.\n$$20 \\log_{10}(\\mathrm{CMRR_{min}}) \\geq 96$$\n$$\\log_{10}(\\mathrm{CMRR_{min}}) \\geq \\frac{96}{20} = 4.8$$\n$$\\mathrm{CMRR_{min}} \\geq 10^{4.8}$$\nSubstituting our expression for $\\mathrm{CMRR_{min}}$:\n$$\\frac{1+k}{4t} \\geq 10^{4.8}$$\nThe question asks for the minimal matching specification $t$ that ensures this condition. This corresponds to the largest value of $t$ that satisfies the inequality, which we find by taking the equality:\n$$t = \\frac{1+k}{4 \\times 10^{4.8}}$$\nWe are given the nominal gain $k=10$. Substituting this value:\n$$t = \\frac{1+10}{4 \\times 10^{4.8}} = \\frac{11}{4 \\times 10^{4.8}}$$\nNow, we compute the numerical value:\n$$10^{4.8} \\approx 63095.734$$\n$$t = \\frac{11}{4 \\times 63095.734} = \\frac{11}{252382.937} \\approx 0.000043585$$\nThe problem asks to round the answer to three significant figures.\n$$t \\approx 0.0000436$$\nThis is the maximum fractional deviation $t$ that can be tolerated in the resistors while still achieving a worst-case CMRR of at least $96\\,\\mathrm{dB}$.",
            "answer": "$$\\boxed{0.0000436}$$"
        },
        {
            "introduction": "While careful design and layout are the first lines of defense against mismatch, achieving the highest levels of performance often requires active, post-fabrication calibration. This advanced practice introduces a modern, system-level methodology for maximizing CMRR . We will first model the process of estimating unknown mismatch parameters from circuit measurements, and then formulate a constrained optimization problem to find the ideal settings for on-chip trim elements, effectively nullifying the common-mode gain under realistic power and area budgets.",
            "id": "4261536",
            "problem": "Consider a fully differential amplifier whose ideal behavior exhibits zero common-mode gain and a large differential gain. Due to device mismatch, the amplifier acquires nonzero common-mode conversion. A calibration network provides tunable trims that linearly affect the mismatch parameters. The goal is to estimate the mismatch from measurements and to compute trim settings that maximize the Common-Mode Rejection Ratio (CMRR), subject to power and area constraints imposed by the trims.\n\nAssume the following mathematical model. Let the mismatch parameter vector be $u \\in \\mathbb{R}^{n}$, and let the measured output residuals (after subtracting the known ideal response under the applied stimuli) be $r \\in \\mathbb{R}^{m}$. The residuals are modeled as $r = A u + \\varepsilon$, where $A \\in \\mathbb{R}^{m \\times n}$ is a known measurement sensitivity matrix and $\\varepsilon \\in \\mathbb{R}^{m}$ is measurement noise. The common-mode gain sensitivity is represented by a vector $c \\in \\mathbb{R}^{n}$, such that the common-mode gain is $A_{\\mathrm{c}}(u) = c^{\\mathsf{T}} u$. The differential gain sensitivity is $d \\in \\mathbb{R}^{n}$, and the ideal differential gain is $G_{\\mathrm{d0}} \\in \\mathbb{R}$, so the differential gain is $A_{\\mathrm{d}}(u) = G_{\\mathrm{d0}} + d^{\\mathsf{T}} u$. Trims $t \\in \\mathbb{R}^{q}$ are mapped to corrections of the mismatch by $T \\in \\mathbb{R}^{n \\times q}$, so the corrected mismatch is $u_{\\mathrm{corr}} = \\hat{u} - T t$, where $\\hat{u}$ is the estimate of $u$ obtained from the measurements.\n\nPower and area constraints on trims are modeled by nonnegative weights $p \\in \\mathbb{R}^{q}$ and $a \\in \\mathbb{R}^{q}$ with budgets $P_{\\max} \\in \\mathbb{R}$ and $A_{\\max} \\in \\mathbb{R}$, respectively, enforcing $\\sum_{i=1}^{q} p_{i} \\lvert t_{i} \\rvert \\leq P_{\\max}$ and $\\sum_{i=1}^{q} a_{i} \\lvert t_{i} \\rvert \\leq A_{\\max}$. Each trim element is bounded in magnitude by $t_{\\max} \\in \\mathbb{R}^{q}_{\\ge 0}$, enforcing $\\lvert t_{i} \\rvert \\leq t_{\\max,i}$ for all $i$. Calibration aims to maximize CMRR, defined as $ \\mathrm{CMRR} = \\left\\lvert \\frac{A_{\\mathrm{d}}(u_{\\mathrm{corr}})}{A_{\\mathrm{c}}(u_{\\mathrm{corr}})} \\right\\rvert$. Report CMRR in decibels (dB), computed as $20 \\log_{10}(\\mathrm{CMRR})$, rounded to three decimal places. To avoid non-finite values when $A_{\\mathrm{c}}(u_{\\mathrm{corr}})$ vanishes, use a numerical floor $\\epsilon = 10^{-12}$ for the denominator.\n\nStarting from the definitions above and the measurement model $r = A u + \\varepsilon$, the tasks are:\n- Compute the mismatch estimate $\\hat{u}$ by minimizing the squared error $\\lVert A u - r \\rVert_{2}^{2}$ without assuming that $A^{\\mathsf{T}} A$ is invertible.\n- Compute the trim vector $t$ that minimizes the magnitude of the corrected common-mode gain $\\lvert A_{\\mathrm{c}}(u_{\\mathrm{corr}}) \\rvert$ subject to the power and area budgets and trim bounds, using a formulation that is solvable as a linear program.\n- Compute the resulting CMRR in dB using the corrected gains $A_{\\mathrm{d}}(u_{\\mathrm{corr}})$ and $A_{\\mathrm{c}}(u_{\\mathrm{corr}})$.\n\nYour program must implement this calibration procedure and apply it to the following test suite. In all cases, express the final answers in dB and round to three decimal places. The final output must be a single line containing the results as a comma-separated list enclosed in square brackets.\n\nTest Suite:\n- Case $1$ (general well-conditioned case):\n  - $n = 3$, $m = 5$, $q = 3$.\n  - $A = \\begin{bmatrix} 0.9 & 0.1 & 0.0 \\\\ 1.0 & -0.2 & 0.05 \\\\ 0.8 & 0.15 & -0.05 \\\\ 1.1 & -0.1 & 0.02 \\\\ 0.95 & 0.05 & -0.01 \\end{bmatrix}$.\n  - $r = \\begin{bmatrix} -0.02 \\\\ -0.015 \\\\ -0.018 \\\\ -0.017 \\\\ -0.016 \\end{bmatrix}$.\n  - $c = \\begin{bmatrix} 0.04 \\\\ -0.02 \\\\ 0.5 \\end{bmatrix}$, $d = \\begin{bmatrix} 0.01 \\\\ 0.005 \\\\ 0.0 \\end{bmatrix}$, $G_{\\mathrm{d0}} = 80$.\n  - $T = I_{3}$ (the $3 \\times 3$ identity matrix).\n  - $p = \\begin{bmatrix} 0.4 \\\\ 0.3 \\\\ 0.1 \\end{bmatrix}$, $a = \\begin{bmatrix} 0.2 \\\\ 0.5 \\\\ 0.1 \\end{bmatrix}$.\n  - $P_{\\max} = 0.05$, $A_{\\max} = 0.04$, $t_{\\max} = \\begin{bmatrix} 0.1 \\\\ 0.1 \\\\ 0.2 \\end{bmatrix}$.\n- Case $2$ (ample budgets enabling near-perfect cancellation):\n  - $n = 3$, $m = 5$, $q = 3$.\n  - $A = \\begin{bmatrix} 0.9 & 0.1 & 0.0 \\\\ 1.0 & -0.2 & 0.05 \\\\ 0.8 & 0.15 & -0.05 \\\\ 1.1 & -0.1 & 0.02 \\\\ 0.95 & 0.05 & -0.01 \\end{bmatrix}$.\n  - $r = \\begin{bmatrix} -0.02 \\\\ -0.015 \\\\ -0.018 \\\\ -0.017 \\\\ -0.016 \\end{bmatrix}$.\n  - $c = \\begin{bmatrix} 0.04 \\\\ -0.02 \\\\ 0.5 \\end{bmatrix}$, $d = \\begin{bmatrix} 0.01 \\\\ 0.005 \\\\ 0.0 \\end{bmatrix}$, $G_{\\mathrm{d0}} = 80$.\n  - $T = I_{3}$.\n  - $p = \\begin{bmatrix} 0.4 \\\\ 0.3 \\\\ 0.1 \\end{bmatrix}$, $a = \\begin{bmatrix} 0.2 \\\\ 0.5 \\\\ 0.1 \\end{bmatrix}$.\n  - $P_{\\max} = 0.5$, $A_{\\max} = 0.5$, $t_{\\max} = \\begin{bmatrix} 1.0 \\\\ 1.0 \\\\ 1.0 \\end{bmatrix}$.\n- Case $3$ (ill-conditioned measurements and tight budgets):\n  - $n = 3$, $m = 5$, $q = 3$.\n  - $A = \\begin{bmatrix} 1.0 & 0.999 & 1.001 \\\\ 0.999 & 1.0 & 1.001 \\\\ 1.001 & 1.002 & 1.999 \\\\ 1.0 & 0.999 & 1.001 \\\\ 0.999 & 1.0 & 1.001 \\end{bmatrix}$.\n  - $r = \\begin{bmatrix} -0.001 \\\\ -0.0015 \\\\ -0.002 \\\\ -0.0012 \\\\ -0.0013 \\end{bmatrix}$.\n  - $c = \\begin{bmatrix} 0.02 \\\\ -0.01 \\\\ 0.4 \\end{bmatrix}$, $d = \\begin{bmatrix} 0.008 \\\\ 0.004 \\\\ 0.0 \\end{bmatrix}$, $G_{\\mathrm{d0}} = 60$.\n  - $T = I_{3}$.\n  - $p = \\begin{bmatrix} 1.0 \\\\ 1.0 \\\\ 1.0 \\end{bmatrix}$, $a = \\begin{bmatrix} 1.0 \\\\ 1.0 \\\\ 1.0 \\end{bmatrix}$.\n  - $P_{\\max} = 0.001$, $A_{\\max} = 0.001$, $t_{\\max} = \\begin{bmatrix} 0.0005 \\\\ 0.0005 \\\\ 0.0005 \\end{bmatrix}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[ \\mathrm{result}_{1}, \\mathrm{result}_{2}, \\mathrm{result}_{3} \\right]$), where each $\\mathrm{result}_{i}$ is the CMRR in dB for the corresponding test case, rounded to three decimal places.",
            "solution": "The user-provided problem has been rigorously validated and is determined to be valid. It is scientifically grounded in the principles of analog integrated circuit design and linear systems theory, well-posed, objective, and contains all necessary information for a unique solution.\n\nThe problem requires a three-step procedure for each test case:\n1.  Estimate the mismatch parameter vector $\\hat{u}$.\n2.  Compute the optimal trim vector $t$ by solving a constrained optimization problem.\n3.  Calculate the resulting Common-Mode Rejection Ratio (CMRR) in decibels (dB).\n\nThe methodology for each step is detailed below.\n\n### Step 1: Mismatch Parameter Estimation\n\nThe relationship between the measured output residuals $r \\in \\mathbb{R}^{m}$ and the mismatch parameter vector $u \\in \\mathbb{R}^{n}$ is given by the linear model $r = A u + \\varepsilon$, where $A \\in \\mathbb{R}^{m \\times n}$ is the sensitivity matrix and $\\varepsilon$ is measurement noise. The task is to compute an estimate $\\hat{u}$ of the true mismatch vector $u$ by minimizing the squared Euclidean norm of the residual error, i.e., solving the least-squares problem:\n$$\n\\min_{u \\in \\mathbb{R}^{n}} \\lVert A u - r \\rVert_{2}^{2}\n$$\nThe problem statement correctly specifies that the matrix $A^{\\mathsf{T}} A$ may not be invertible, which can occur if the columns of $A$ are not linearly independent or if the system is underdetermined. The most general solution to this problem, which provides the minimum-norm solution among all possible vectors that minimize the residual, is given by the Moore-Penrose pseudoinverse of $A$, denoted as $A^{+}$. The estimate $\\hat{u}$ is therefore computed as:\n$$\n\\hat{u} = A^{+} r\n$$\n\n### Step 2: Optimal Trim Vector Computation\n\nThe next step is to determine the optimal trim vector $t \\in \\mathbb{R}^{q}$ that maximizes the CMRR. Since $\\mathrm{CMRR} = |A_{\\mathrm{d}}/A_{\\mathrm{c}}|$, and the differential gain $A_{\\mathrm{d}}$ is typically large and varies little with small corrections, maximizing CMRR is approximately equivalent to minimizing the magnitude of the common-mode gain, $|A_{\\mathrm{c}}|$. The corrected mismatch is $u_{\\mathrm{corr}} = \\hat{u} - T t$, where $T \\in \\mathbb{R}^{n \\times q}$ is the trim mapping matrix. The corrected common-mode gain is:\n$$\nA_{\\mathrm{c}}(u_{\\mathrm{corr}}) = c^{\\mathsf{T}} u_{\\mathrm{corr}} = c^{\\mathsf{T}}(\\hat{u} - T t) = c^{\\mathsf{T}}\\hat{u} - (c^{\\mathsf{T}}T)t\n$$\nThe optimization problem is to find the trim vector $t$ that minimizes $|A_{\\mathrm{c}}(u_{\\mathrm{corr}})|$ subject to a set of constraints:\n1.  Power constraint: $\\sum_{i=1}^{q} p_{i} \\lvert t_{i} \\rvert \\leq P_{\\max}$\n2.  Area constraint: $\\sum_{i=1}^{q} a_{i} \\lvert t_{i} \\rvert \\leq A_{\\max}$\n3.  Trim range constraint: $\\lvert t_{i} \\rvert \\leq t_{\\max,i}$ for $i=1, \\dots, q$\n\nThe objective function $\\min_t |c^{\\mathsf{T}}\\hat{u} - (c^{\\mathsf{T}}T)t|$ is non-linear. This problem can be reformulated as a Linear Program (LP). We introduce a new non-negative scalar variable $z$, which we aim to minimize. The objective becomes $\\min z$, subject to the original constraints and an additional constraint $|c^{\\mathsf{T}}\\hat{u} - (c^{\\mathsf{T}}T)t| \\le z$. This is equivalent to two linear inequalities:\n$$\nc^{\\mathsf{T}}\\hat{u} - (c^{\\mathsf{T}}T)t \\le z \\quad \\text{and} \\quad c^{\\mathsf{T}}\\hat{u} - (c^{\\mathsf{T}}T)t \\ge -z\n$$\nThe constraints involving absolute values of $t_i$ are also non-linear. We linearize them by introducing $q$ new non-negative variables $\\tau_i$ for $i=1, \\dots, q$, such that $\\tau_i \\ge |t_i|$. This single condition is replaced by two linear inequalities: $t_i \\le \\tau_i$ and $-t_i \\le \\tau_i$. The power and area constraints become linear in terms of $\\tau_i$: $\\sum p_i \\tau_i \\leq P_{\\max}$ and $\\sum a_i \\tau_i \\leq A_{\\max}$.\n\nThe complete LP formulation is as follows:\n\n-   **Optimization Variables**: $t \\in \\mathbb{R}^q$, $\\tau \\in \\mathbb{R}^q$, $z \\in \\mathbb{R}$.\n-   **Objective Function**: Minimize $z$.\n-   **Subject to Constraints**:\n    1.  $(c^{\\mathsf{T}}T)t + z \\ge c^{\\mathsf{T}}\\hat{u}$\n    2.  $-(c^{\\mathsf{T}}T)t + z \\ge -c^{\\mathsf{T}}\\hat{u}$\n    3.  $p^{\\mathsf{T}}\\tau \\le P_{\\max}$\n    4.  $a^{\\mathsf{T}}\\tau \\le A_{\\max}$\n    5.  $t_i - \\tau_i \\le 0$ for $i=1, \\dots, q$\n    6.  $-t_i - \\tau_i \\le 0$ for $i=1, \\dots, q$\n    7.  $-t_{\\max,i} \\le t_i \\le t_{\\max,i}$ for $i=1, \\dots, q$\n    8.  $\\tau_i \\ge 0$ for $i=1, \\dots, q$\n    9.  $z \\ge 0$\n\nThis LP can be solved using standard solvers to find the optimal trim vector $t$.\n\n### Step 3: CMRR Calculation\n\nWith the optimal trim vector $t$ from Step 2, the final calibrated performance is calculated.\n1.  Compute the corrected mismatch vector:\n    $$\n    u_{\\mathrm{corr}} = \\hat{u} - T t\n    $$\n2.  Compute the corrected common-mode and differential gains:\n    $$\n    A_{\\mathrm{c,corr}} = c^{\\mathsf{T}} u_{\\mathrm{corr}}\n    $$\n    $$\n    A_{\\mathrm{d,corr}} = G_{\\mathrm{d0}} + d^{\\mathsf{T}} u_{\\mathrm{corr}}\n    $$\n3.  Calculate the CMRR value. To handle the case where $A_{\\mathrm{c,corr}}$ is zero or close to zero, a numerical floor $\\epsilon = 10^{-12}$ is used for the denominator's magnitude:\n    $$\n    \\mathrm{CMRR} = \\frac{\\lvert A_{\\mathrm{d,corr}} \\rvert}{\\max(\\epsilon, \\lvert A_{\\mathrm{c,corr}} \\rvert)}\n    $$\n4.  Convert the result to decibels (dB) and round to three decimal places:\n    $$\n    \\mathrm{CMRR}_{\\mathrm{dB}} = 20 \\log_{10}(\\mathrm{CMRR})\n    $$\n\nThis three-step procedure is implemented and applied to each test case specified in the problem.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the CMRR calibration problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general well-conditioned case)\n        {\n            \"n\": 3, \"m\": 5, \"q\": 3,\n            \"A\": np.array([\n                [0.9, 0.1, 0.0],\n                [1.0, -0.2, 0.05],\n                [0.8, 0.15, -0.05],\n                [1.1, -0.1, 0.02],\n                [0.95, 0.05, -0.01]\n            ]),\n            \"r\": np.array([-0.02, -0.015, -0.018, -0.017, -0.016]),\n            \"c\": np.array([0.04, -0.02, 0.5]),\n            \"d\": np.array([0.01, 0.005, 0.0]),\n            \"G_d0\": 80.,\n            \"T\": np.identity(3),\n            \"p\": np.array([0.4, 0.3, 0.1]),\n            \"a\": np.array([0.2, 0.5, 0.1]),\n            \"P_max\": 0.05,\n            \"A_max\": 0.04,\n            \"t_max\": np.array([0.1, 0.1, 0.2])\n        },\n        # Case 2 (ample budgets enabling near-perfect cancellation)\n        {\n            \"n\": 3, \"m\": 5, \"q\": 3,\n            \"A\": np.array([\n                [0.9, 0.1, 0.0],\n                [1.0, -0.2, 0.05],\n                [0.8, 0.15, -0.05],\n                [1.1, -0.1, 0.02],\n                [0.95, 0.05, -0.01]\n            ]),\n            \"r\": np.array([-0.02, -0.015, -0.018, -0.017, -0.016]),\n            \"c\": np.array([0.04, -0.02, 0.5]),\n            \"d\": np.array([0.01, 0.005, 0.0]),\n            \"G_d0\": 80.,\n            \"T\": np.identity(3),\n            \"p\": np.array([0.4, 0.3, 0.1]),\n            \"a\": np.array([0.2, 0.5, 0.1]),\n            \"P_max\": 0.5,\n            \"A_max\": 0.5,\n            \"t_max\": np.array([1.0, 1.0, 1.0])\n        },\n        # Case 3 (ill-conditioned measurements and tight budgets)\n        {\n            \"n\": 3, \"m\": 5, \"q\": 3,\n            \"A\": np.array([\n                [1.0, 0.999, 1.001],\n                [0.999, 1.0, 1.001],\n                [1.001, 1.002, 1.999],\n                [1.0, 0.999, 1.001],\n                [0.999, 1.0, 1.001]\n            ]),\n            \"r\": np.array([-0.001, -0.0015, -0.002, -0.0012, -0.0013]),\n            \"c\": np.array([0.02, -0.01, 0.4]),\n            \"d\": np.array([0.008, 0.004, 0.0]),\n            \"G_d0\": 60.,\n            \"T\": np.identity(3),\n            \"p\": np.array([1.0, 1.0, 1.0]),\n            \"a\": np.array([1.0, 1.0, 1.0]),\n            \"P_max\": 0.001,\n            \"A_max\": 0.001,\n            \"t_max\": np.array([0.0005, 0.0005, 0.0005])\n        }\n    ]\n\n    results = []\n    epsilon = 1e-12\n\n    for case in test_cases:\n        # Step 1: Mismatch Parameter Estimation\n        u_hat = np.linalg.pinv(case[\"A\"]) @ case[\"r\"]\n\n        # Step 2: Optimal Trim Vector Computation via Linear Programming\n        q = case[\"q\"]\n        \n        # LP variable vector: x = [t_1,..,t_q, tau_1,..,tau_q, z]\n        # Total variables = 2q + 1\n        \n        # Objective: minimize z. Cost vector c_lp has 1 at the last position.\n        c_lp = np.zeros(2 * q + 1)\n        c_lp[-1] = 1.0\n\n        # Inequality constraints: A_ub * x <= b_ub\n        # Let v = T.T @ c\n        v = case[\"T\"].T @ case[\"c\"]\n        k = case[\"c\"].T @ u_hat\n\n        # Number of inequality constraints: 2 (for z) + 2 (p, a) + 2q (for tau)\n        A_ub = np.zeros((4 + 2 * q, 2 * q + 1))\n        b_ub = np.zeros(4 + 2 * q)\n        \n        # Linearization of z >= |k - v.T @ t|\n        # -(k - v.T @ t) = z  =>  v.T @ t - z = k\n        A_ub[0, :q] = v\n        A_ub[0, -1] = -1.0\n        b_ub[0] = k\n        #  (k - v.T @ t) = z  => -v.T @ t - z = -k\n        A_ub[1, :q] = -v\n        A_ub[1, -1] = -1.0\n        b_ub[1] = -k\n\n        # Constraint 3: p.T @ tau = P_max\n        A_ub[2, q:2*q] = case[\"p\"]\n        b_ub[2] = case[\"P_max\"]\n        \n        # Constraint 4: a.T @ tau = A_max\n        A_ub[3, q:2*q] = case[\"a\"]\n        b_ub[3] = case[\"A_max\"]\n\n        # Constraints 5 and 6: t_i = tau_i and -t_i = tau_i for i=1..q\n        for i in range(q):\n            # t_i - tau_i = 0\n            A_ub[4 + i, i] = 1.0\n            A_ub[4 + i, q + i] = -1.0\n            b_ub[4 + i] = 0.0\n            # -t_i - tau_i = 0\n            A_ub[4 + q + i, i] = -1.0\n            A_ub[4 + q + i, q + i] = -1.0\n            b_ub[4 + q + i] = 0.0\n\n        # Bounds on variables\n        bounds = []\n        for i in range(q): # Bounds for t_i\n            bounds.append((-case[\"t_max\"][i], case[\"t_max\"][i]))\n        for i in range(q): # Bounds for tau_i\n            bounds.append((0, None))\n        bounds.append((0, None)) # Bound for z\n\n        # Solve the LP\n        # method='highs' is the default and recommended solver in recent SciPy versions\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        t_opt = res.x[0:q]\n\n        # Step 3: CMRR Calculation\n        u_corr = u_hat - case[\"T\"] @ t_opt\n        Ac_corr = case[\"c\"].T @ u_corr\n        Ad_corr = case[\"G_d0\"] + case[\"d\"].T @ u_corr\n        \n        cmrr_val = np.abs(Ad_corr) / max(epsilon, np.abs(Ac_corr))\n        cmrr_db = 20 * np.log10(cmrr_val)\n        \n        results.append(round(cmrr_db, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}