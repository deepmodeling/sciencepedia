{
    "hands_on_practices": [
        {
            "introduction": "We begin with a foundational analysis of the classic four-resistor difference amplifier, a cornerstone of analog design. This exercise  establishes the direct and critical link between a high-level performance metric, the Common-Mode Rejection Ratio ($CMRR$), and a fundamental physical constraint: the matching tolerance of the passive components. By performing a first-order, worst-case analysis, you will develop the skill to translate a system specification into a required manufacturing precision, a crucial step in robust circuit implementation.",
            "id": "4261609",
            "problem": "A monolithic difference amplifier is implemented in an integrated circuit environment within Electronic Design Automation (EDA). The amplifier uses a single operational amplifier with a four-resistor network: resistor $R_1$ connects input $v_1$ to the inverting input, resistor $R_2$ provides feedback from the output to the inverting input, resistor $R_3$ connects input $v_2$ to the non-inverting input, and resistor $R_4$ connects the non-inverting input to ground. Assume the operational amplifier is ideal, and the only source of common-mode gain arises from resistor mismatch in the gain-setting network. The nominal design is symmetric with $R_1 = R_3 = 10\\,\\mathrm{k}\\Omega$ and $R_2 = R_4 = 100\\,\\mathrm{k}\\Omega$, so the intended differential gain is $k = R_2/R_1 = 10$.\n\nLet the actual resistors be $R_i(1+\\Delta_i)$ for $i \\in \\{1,2,3,4\\}$, where each $\\Delta_i$ is an unknown fractional deviation due to mismatch. For layout-matched devices, you may assume the worst-case bound $|\\Delta_i| \\leq t$, where $t$ is the matching specification to be determined. Define the Common-Mode Rejection Ratio (CMRR) as the magnitude ratio of differential gain to common-mode gain of the overall amplifier. The target is to ensure a minimum $\\mathrm{CMRR_{dB}}$ of $96$ decibels across all mismatch combinations satisfying $|\\Delta_i| \\leq t$.\n\nStarting from the ideal operational amplifier constraints and resistor network laws, derive the first-order sensitivity of the Common-Mode Rejection Ratio (CMRR) to small mismatch in the resistor ratios. Then, using a worst-case deterministic bound on the mismatch, determine the minimal matching specification $t$ (as a decimal fraction) such that the worst-case $\\mathrm{CMRR_{dB}}$ is at least $96$ decibels for the given nominal values. Express the final tolerance $t$ as a decimal fraction and round your answer to three significant figures. Do not use a percentage sign in your final expression.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- Circuit: Monolithic difference amplifier with a single ideal operational amplifier (op-amp).\n- Resistor Network: $R_1$ from input $v_1$ to inverting input, $R_2$ from output to inverting input, $R_3$ from input $v_2$ to non-inverting input, $R_4$ from non-inverting input to ground.\n- Op-amp Model: Ideal.\n- Nominal Resistor Values: $R_1 = R_3 = 10\\,\\mathrm{k}\\Omega$, $R_2 = R_4 = 100\\,\\mathrm{k}\\Omega$.\n- Nominal Differential Gain: $k = R_2/R_1 = 10$.\n- Actual Resistor Values: $R_i' = R_i(1+\\Delta_i)$ for $i \\in \\{1,2,3,4\\}$, where $\\Delta_i$ is the fractional deviation.\n- Mismatch Bound: $|\\Delta_i| \\leq t$ for all $i$.\n- CMRR Definition: $\\mathrm{CMRR} = |A_d / A_{cm}|$, where $A_d$ is the differential gain and $A_{cm}$ is the common-mode gain.\n- Performance Target: Minimum $\\mathrm{CMRR_{dB}} \\geq 96$ decibels.\n- Objective: Determine the minimal matching specification, $t$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding**: The problem is based on fundamental principles of analog circuit theory, specifically the analysis of a difference amplifier. The model for resistor mismatch and the definition of CMRR are standard in the field of integrated circuit design. The use of an ideal op-amp is a common and appropriate simplification for this type of first-order analysis. The problem is scientifically sound.\n- **Well-Posedness**: The problem provides all necessary information: the circuit topology, component values, a model for non-idealities (mismatch), and a clear performance target. It asks for a specific, calculable quantity ($t$). The problem is well-posed.\n- **Objectivity**: The problem is stated in precise, technical language, free of ambiguity or subjective claims.\n\n### Step 3: Verdict and Action\nThe problem is valid. The solution process will proceed.\n\n### Derivation of the Solution\nThe output voltage $v_{out}$ of the difference amplifier is determined by the resistor network and the ideal op-amp constraints. For an ideal op-amp, the differential input voltage is zero, so the voltage at the inverting input ($v_-$) equals the voltage at the non-inverting input ($v_+$).\n\nThe voltage at the non-inverting input, $v_+$, is determined by the voltage divider formed by the actual resistors $R_3'$ and $R_4'$:\n$$v_+ = v_2 \\frac{R_4'}{R_3' + R_4'}$$\nDue to the ideal op-amp assumption ($v_- = v_+$) and zero input current, the relationship between the inputs and output at the inverting terminal is given by a standard inverting amplifier configuration, but with $v_-$ as the reference:\n$$\\frac{v_1 - v_-}{R_1'} = \\frac{v_- - v_{out}}{R_2'}$$\nSolving for $v_{out}$:\n$$v_{out} R_1' = v_-(R_1' + R_2') - v_1 R_2'$$\n$$v_{out} = v_- \\left(1 + \\frac{R_2'}{R_1'}\\right) - v_1 \\frac{R_2'}{R_1'}$$\nSubstituting the expression for $v_-$ (since $v_-=v_+$):\n$$v_{out} = v_2 \\frac{R_4'}{R_3' + R_4'} \\left(1 + \\frac{R_2'}{R_1'}\\right) - v_1 \\frac{R_2'}{R_1'}$$\nThis is the general expression for the output voltage. To find the differential and common-mode gains, we express $v_{out}$ in terms of the differential input $v_d = v_2 - v_1$ and the common-mode input $v_{cm} = (v_1 + v_2)/2$. The output is $v_{out} = A_d v_d + A_{cm} v_{cm}$.\n\nThe common-mode gain, $A_{cm}$, is the output voltage when $v_1 = v_2 = v_{cm}$ ($v_d=0$):\n$$A_{cm} = \\frac{v_{out}}{v_{cm}} = \\frac{R_4'}{R_3' + R_4'} \\left(1 + \\frac{R_2'}{R_1'}\\right) - \\frac{R_2'}{R_1'}$$\nThis can be simplified by finding a common denominator:\n$$A_{cm} = \\frac{R_4'(R_1' + R_2') - R_2'(R_3' + R_4')}{R_1'(R_3' + R_4')} = \\frac{R_1'R_4' - R_2'R_3'}{R_1'(R_3' + R_4')}$$\nFor perfect matching, the resistor ratios are equal, $R_2/R_1 = R_4/R_3$, which implies $R_1R_4 = R_2R_3$, and thus $A_{cm}=0$. Mismatch in the resistors causes a non-zero $A_{cm}$.\n\nLet's substitute the actual resistor values $R_i' = R_i(1+\\Delta_i)$ and the nominal design values $R_1 = R_3 = R_A$ and $R_2 = R_4 = R_B$. The nominal gain is $k=R_B/R_A$.\n$$R_1'R_4' - R_2'R_3' = R_A(1+\\Delta_1)R_B(1+\\Delta_4) - R_B(1+\\Delta_2)R_A(1+\\Delta_3)$$\n$$= R_A R_B \\left[ (1+\\Delta_1)(1+\\Delta_4) - (1+\\Delta_2)(1+\\Delta_3) \\right]$$\nFor small mismatches ($|\\Delta_i| \\ll 1$), we retain only first-order terms:\n$$R_1'R_4' - R_2'R_3' \\approx R_A R_B \\left[ (1+\\Delta_1+\\Delta_4) - (1+\\Delta_2+\\Delta_3) \\right] = R_A R_B (\\Delta_1 - \\Delta_2 - \\Delta_3 + \\Delta_4)$$\nThe denominator of $A_{cm}$ is $R_1'(R_3' + R_4')$. To first-order, this is approximately its nominal value:\n$$R_1'(R_3' + R_4') \\approx R_A(R_A + R_B) = R_A^2(1+k)$$\nSo, the first-order approximation for the common-mode gain is:\n$$A_{cm} \\approx \\frac{R_A R_B (\\Delta_1 - \\Delta_2 - \\Delta_3 + \\Delta_4)}{R_A^2(1+k)} = \\frac{(R_B/R_A)}{1+k} (\\Delta_1 - \\Delta_2 - \\Delta_3 + \\Delta_4)$$\n$$A_{cm} \\approx \\frac{k}{1+k} (\\Delta_1 - \\Delta_2 - \\Delta_3 + \\Delta_4)$$\nThe differential gain $A_d$ is nominally $k = R_2/R_1$. The mismatches $\\Delta_i$ cause small deviations in $A_d$. However, for the CMRR calculation, which is the ratio of $A_d$ to $A_{cm}$, the dominant effect is the change in $A_{cm}$ from zero to a small value. The fractional change in $A_d$ is a higher-order effect on the CMRR. Thus, we can approximate $A_d \\approx k$. This is the basis of the first-order sensitivity analysis.\n\nThe Common-Mode Rejection Ratio is then:\n$$\\mathrm{CMRR} = \\left|\\frac{A_d}{A_{cm}}\\right| \\approx \\left| \\frac{k}{\\frac{k}{1+k}(\\Delta_1 - \\Delta_2 - \\Delta_3 + \\Delta_4)} \\right| = \\left| \\frac{1+k}{\\Delta_1 - \\Delta_2 - \\Delta_3 + \\Delta_4} \\right|$$\nTo guarantee a minimum CMRR, we must consider the worst-case scenario. The CMRR is minimized when the denominator $|\\Delta_1 - \\Delta_2 - \\Delta_3 + \\Delta_4|$ is maximized. Given the constraint $|\\Delta_i| \\leq t$, we can maximize this term by choosing a specific combination of mismatches. Let $\\Delta_1 = t$, $\\Delta_4 = t$, $\\Delta_2 = -t$, and $\\Delta_3 = -t$. All these satisfy the bound. The denominator becomes:\n$$|\\Delta_1 - \\Delta_2 - \\Delta_3 + \\Delta_4|_{max} = |t - (-t) - (-t) + t| = |4t| = 4t$$\nSo, the minimum (worst-case) CMRR for a given matching specification $t$ is:\n$$\\mathrm{CMRR_{min}} = \\frac{1+k}{4t}$$\nThe problem requires a minimum $\\mathrm{CMRR_{dB}}$ of $96\\,\\mathrm{dB}$. The conversion from a linear ratio to decibels is $\\mathrm{CMRR_{dB}} = 20 \\log_{10}(\\mathrm{CMRR})$.\n$$20 \\log_{10}(\\mathrm{CMRR_{min}}) \\geq 96$$\n$$\\log_{10}(\\mathrm{CMRR_{min}}) \\geq \\frac{96}{20} = 4.8$$\n$$\\mathrm{CMRR_{min}} \\geq 10^{4.8}$$\nSubstituting our expression for $\\mathrm{CMRR_{min}}$:\n$$\\frac{1+k}{4t} \\geq 10^{4.8}$$\nThe question asks for the minimal matching specification $t$ that ensures this condition. This corresponds to the largest value of $t$ that satisfies the inequality, which we find by taking the equality:\n$$t = \\frac{1+k}{4 \\times 10^{4.8}}$$\nWe are given the nominal gain $k=10$. Substituting this value:\n$$t = \\frac{1+10}{4 \\times 10^{4.8}} = \\frac{11}{4 \\times 10^{4.8}}$$\nNow, we compute the numerical value:\n$$10^{4.8} \\approx 63095.734$$\n$$t = \\frac{11}{4 \\times 63095.734} = \\frac{11}{252382.937} \\approx 0.000043585$$\nThe problem asks to round the answer to three significant figures.\n$$t \\approx 0.0000436$$\nThis is the maximum fractional deviation $t$ that can be tolerated in the resistors while still achieving a worst-case CMRR of at least $96\\,\\mathrm{dB}$.",
            "answer": "$$\\boxed{0.0000436}$$"
        },
        {
            "introduction": "While DC analysis provides essential insights, real-world circuits must perform across a spectrum of frequencies where parasitic elements dictate behavior. This practice  transitions from static analysis to a dynamic, frequency-domain perspective, guiding you to build a numerical simulation from first principles using nodal analysis. You will investigate how parasitic capacitances, even with small asymmetries, inevitably cause $CMRR$ to degrade at higher frequencies, a critical phenomenon that must be managed in high-speed analog and RF design.",
            "id": "4261578",
            "problem": "You are given a small-signal linear model of a differential amplifier suitable for frequency-domain analysis. The goal is to compute the differential-mode gain amplitude as a function of angular frequency, denoted by $A_d(\\omega)$, and the common-mode gain amplitude $A_c(\\omega)$, using even–odd mode excitations. Then, post-process these quantities to obtain the magnitude of the Common-Mode Rejection Ratio (CMRR) as a function of frequency, denoted $\\mathrm{CMRR}(\\omega) = \\left|\\frac{A_d(\\omega)}{A_c(\\omega)}\\right|$. You must implement the computation as a numerical program that solves the small-signal circuit via nodal analysis in the frequency domain.\n\nThe small-signal circuit is defined as follows.\n\n- Two output nodes with voltages $v_{o+}$ and $v_{o-}$, and one tail node with voltage $v_t$.\n- Two transconductors that inject currents from each output node to the tail node. Their small-signal transconductances are $g_{m1}$ and $g_{m2}$, and the small-signal gate–source voltages are $v_{gs1} = v_{g+} - v_t$ and $v_{gs2} = v_{g-} - v_t$. The small-signal currents sourced from each output node into the tail node are $i_{gm1} = g_{m1} v_{gs1}$ and $i_{gm2} = g_{m2} v_{gs2}$.\n- Each output node has a load resistor and capacitor to ground: $R_{L+}$ with $C_{L+}$ on the $+$ side, and $R_{L-}$ with $C_{L-}$ on the $-$ side.\n- Each output node is connected to the tail node through a small-signal output resistance $r_{o+}$ and $r_{o-}$ respectively.\n- The tail node is connected to ground through a tail resistance $R_t$ and a tail capacitance $C_t$ in parallel (both to ground).\n- Assume all gate nodes are high impedance and do not draw current.\n\nThe frequency-domain nodal equations follow from Kirchhoff’s Current Law and the impedance of capacitors. Let $s = j\\omega$ and $\\omega = 2\\pi f$ with $f$ in hertz. For each frequency, let the unknown node voltages be assembled as a vector $\\mathbf{v} = [v_{o+}, v_{o-}, v_t]^T$. The gate excitation voltages $v_{g+}$ and $v_{g-}$ are externally applied sources used to form even–odd mode excitations.\n\nDefine the following measurement conventions:\n\n- Odd-mode excitation for differential gain: apply $v_{g+} = +\\frac{1}{2}$ and $v_{g-} = -\\frac{1}{2}$, which yields a unit differential input amplitude $v_{id} = v_{g+} - v_{g-} = 1$. Compute the differential output $v_{od} = v_{o+} - v_{o-}$ and set $A_d(\\omega) = \\frac{v_{od}}{v_{id}} = v_{o+} - v_{o-}$.\n- Even-mode excitation for common-mode gain: apply $v_{g+} = v_{g-} = 1$, which yields a unit common-mode input amplitude $v_{icm} = \\frac{v_{g+} + v_{g-}}{2} = 1$. Compute the common-mode output $v_{ocm} = \\frac{v_{o+} + v_{o-}}{2}$ and set $A_c(\\omega) = \\frac{v_{ocm}}{v_{icm}} = \\frac{v_{o+} + v_{o-}}{2}$.\n\nYou must implement the frequency-domain solution using nodal analysis from first principles:\n\n- For each frequency, write the linear equations corresponding to each node by summing currents through passive elements to ground and between nodes, and including the controlled-source currents from the transconductors. Use the capacitor admittance $s C$.\n- Solve the resulting $3 \\times 3$ linear system for the unknown node voltages for each excitation (odd and even).\n- Using the solved node voltages, compute $A_d(\\omega)$ and $A_c(\\omega)$, then compute $\\left|\\frac{A_d(\\omega)}{A_c(\\omega)}\\right|$ and express this as decibels via $20 \\log_{10}\\left(\\left|\\frac{A_d(\\omega)}{A_c(\\omega)}\\right|\\right)$.\n\nMismatch effects are introduced by perturbing the device and load parameters:\n\n- Let the nominal transconductance be $g_m$. Then $g_{m1} = g_m (1 + \\delta_{gm})$ and $g_{m2} = g_m (1 - \\delta_{gm})$.\n- Let the nominal load resistance be $R_L$. Then $R_{L+} = R_L (1 + \\delta_{RL})$ and $R_{L-} = R_L (1 - \\delta_{RL})$.\n- Assume $r_{o+} = r_{o-} = r_o$ and $C_{L+} = C_{L-} = C_L$ unless otherwise specified.\n\nUse the following test suite. For each test case, compute the decibel magnitude of $\\mathrm{CMRR}(\\omega)$ at the specified frequencies. The final outputs must be floats in decibels.\n\nFrequencies (in hertz):\n- $f \\in \\{10^2, 10^4, 10^6, 10^8\\}$.\n\nTest cases (all resistances in ohms, capacitances in farads, transconductance in siemens):\n1. Happy-path with small mismatch and finite tail:\n   - $g_m = 5 \\times 10^{-3}$, $r_o = 2 \\times 10^5$, $R_L = 10^4$, $C_L = 2 \\times 10^{-12}$, $R_t = 10^5$, $C_t = 1 \\times 10^{-12}$, $\\delta_{gm} = 0.02$, $\\delta_{RL} = 0.01$.\n2. Near-ideal current source tail, no mismatch:\n   - $g_m = 2 \\times 10^{-3}$, $r_o = 5 \\times 10^5$, $R_L = 2 \\times 10^4$, $C_L = 1 \\times 10^{-12}$, $R_t = 10^9$, $C_t = 1 \\times 10^{-12}$, $\\delta_{gm} = 0.0$, $\\delta_{RL} = 0.0$.\n3. Strong mismatch and moderate tail:\n   - $g_m = 3 \\times 10^{-3}$, $r_o = 1.5 \\times 10^5$, $R_L = 8 \\times 10^3$, $C_L = 2 \\times 10^{-12}$, $R_t = 8 \\times 10^4$, $C_t = 1 \\times 10^{-12}$, $\\delta_{gm} = 0.1$, $\\delta_{RL} = 0.1$.\n4. Heavier capacitive load and modest mismatch:\n   - $g_m = 4 \\times 10^{-3}$, $r_o = 2 \\times 10^5$, $R_L = 5 \\times 10^3$, $C_L = 1 \\times 10^{-11}$, $R_t = 2 \\times 10^5$, $C_t = 5 \\times 10^{-12}$, $\\delta_{gm} = 0.03$, $\\delta_{RL} = 0.0$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by test case and frequency in ascending order. Specifically, list the $20 \\log_{10}\\left(\\left|\\frac{A_d(\\omega)}{A_c(\\omega)}\\right|\\right)$ values for test case 1 at $10^2, 10^4, 10^6, 10^8$ hertz, followed by test case 2 at the same frequencies, and so on for test cases 3 and 4.\n- Express the results as decimal numbers in decibels, each rounded to three decimal places.\n\nAll answers are dimensionless decibels. No percentages or additional text should be printed. The program must be completely self-contained and must not require any user input. The output must be one line only, in the exact format described (e.g., \"[x1,x2,...,x16]\").",
            "solution": "## PROBLEM VALIDATION\n\n### Step 1: Extract Givens\n- **Circuit Nodes**: Three unknown voltage nodes: $v_{o+}$, $v_{o-}$, $v_t$.\n- **Input Nodes**: Two external gate voltage sources: $v_{g+}$, $v_{g-}$.\n- **Transconductors**:\n  - $g_{m1}$, $v_{gs1} = v_{g+} - v_t$, current $i_{gm1} = g_{m1} v_{gs1}$ from $v_{o+}$ to $v_t$.\n  - $g_{m2}$, $v_{gs2} = v_{g-} - v_t$, current $i_{gm2} = g_{m2} v_{gs2}$ from $v_{o-}$ to $v_t$.\n- **Passive Components**:\n  - Load at $v_{o+}$: $R_{L+}$ and $C_{L+}$ in parallel to ground.\n  - Load at $v_{o-}$: $R_{L-}$ and $C_{L-}$ in parallel to ground.\n  - Output resistances: $r_{o+}$ (between $v_{o+}$ and $v_t$), $r_{o-}$ (between $v_{o-}$ and $v_t$).\n  - Tail impedance: $R_t$ and $C_t$ in parallel to ground from node $v_t$.\n- **Analysis Method**: Nodal analysis in the frequency domain with $s = j\\omega = j2\\pi f$. The system is a $3 \\times 3$ linear system for $\\mathbf{v} = [v_{o+}, v_{o-}, v_t]^T$.\n- **Measurement Definitions**:\n  - **Odd-mode (for $A_d$)**: Input $v_{g+} = +1/2$, $v_{g-} = -1/2$. Differential input $v_{id} = 1$. Differential gain $A_d(\\omega) = v_{o+} - v_{o-}$.\n  - **Even-mode (for $A_c$)**: Input $v_{g+} = v_{g-} = 1$. Common-mode input $v_{icm} = 1$. Common-mode gain $A_c(\\omega) = (v_{o+} + v_{o-})/2$.\n- **Output Quantity**: Common-Mode Rejection Ratio (CMRR) in decibels: $\\mathrm{CMRR}_{dB}(\\omega) = 20 \\log_{10}\\left(\\left|\\frac{A_d(\\omega)}{A_c(\\omega)}\\right|\\right)$.\n- **Mismatch Model**:\n  - $g_{m1} = g_m (1 + \\delta_{gm})$, $g_{m2} = g_m (1 - \\delta_{gm})$.\n  - $R_{L+} = R_L (1 + \\delta_{RL})$, $R_{L-} = R_L (1 - \\delta_{RL})$.\n  - It is specified that $r_{o+} = r_{o-} = r_o$ and $C_{L+} = C_{L-} = C_L$.\n- **Frequencies for Analysis**: $f \\in \\{10^2, 10^4, 10^6, 10^8\\}$ Hz.\n- **Test Cases**:\n  1. $g_m = 5 \\times 10^{-3}$, $r_o = 2 \\times 10^5$, $R_L = 10^4$, $C_L = 2 \\times 10^{-12}$, $R_t = 10^5$, $C_t = 1 \\times 10^{-12}$, $\\delta_{gm} = 0.02$, $\\delta_{RL} = 0.01$.\n  2. $g_m = 2 \\times 10^{-3}$, $r_o = 5 \\times 10^5$, $R_L = 2 \\times 10^4$, $C_L = 1 \\times 10^{-12}$, $R_t = 10^9$, $C_t = 1 \\times 10^{-12}$, $\\delta_{gm} = 0.0$, $\\delta_{RL} = 0.0$.\n  3. $g_m = 3 \\times 10^{-3}$, $r_o = 1.5 \\times 10^5$, $R_L = 8 \\times 10^3$, $C_L = 2 \\times 10^{-12}$, $R_t = 8 \\times 10^4$, $C_t = 1 \\times 10^{-12}$, $\\delta_{gm} = 0.1$, $\\delta_{RL} = 0.1$.\n  4. $g_m = 4 \\times 10^{-3}$, $r_o = 2 \\times 10^5$, $R_L = 5 \\times 10^3$, $C_L = 1 \\times 10^{-11}$, $R_t = 2 \\times 10^5$, $C_t = 5 \\times 10^{-12}$, $\\delta_{gm} = 0.03$, $\\delta_{RL} = 0.0$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria:\n- **Scientifically Grounded**: The problem describes the analysis of a standard small-signal linear model of a differential amplifier, a cornerstone of analog integrated circuit design. The principles invoked (Kirchhoff's Current Law, nodal analysis, frequency domain analysis using complex impedances) are fundamental to electrical engineering. The parameter values are realistic for typical CMOS or BJT technologies.\n- **Well-Posed**: The problem is well-posed. It requests the solution of a $3 \\times 3$ linear system of equations, which, for any physically realistic set of non-zero passive component values, will have a unique solution. The definitions of input excitations, output measurements, and the final quantity (CMRR) are precise and unambiguous.\n- **Objective**: The problem is stated in objective, formal language. All parameters and goals are quantitatively defined.\n- **Completeness**: The problem is self-contained. It provides the full circuit topology, all component models (including mismatches), all numerical values for test cases, the frequencies of interest, and the exact definition of the required output. No information is missing.\n- **Consistency**: There are no contradictions in the problem statement. The definitions and models are internally consistent. The definition of CMRR as the ratio of differential gain to common-mode gain is a standard one, and the problem is consistent in how these gains are to be calculated from specific input excitations.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a standard, well-defined exercise in analog circuit analysis that can be solved algorithmically from first principles.\n\n## SOLUTION\n\nThe solution requires performing nodal analysis on the given small-signal circuit model in the frequency domain. We formulate a $3 \\times 3$ linear system of equations, $\\mathbf{Y}\\mathbf{v} = \\mathbf{i}$, where $\\mathbf{v} = [v_{o+}, v_{o-}, v_t]^T$ is the vector of unknown node voltages, $\\mathbf{Y}$ is the complex admittance matrix, and $\\mathbf{i}$ is the vector of current sources entering the nodes. The complex frequency is given by $s = j\\omega$.\n\nKirchhoff's Current Law (KCL) is applied at each of the three unknown nodes, stating that the sum of currents leaving each node is zero.\n\n**KCL at node $v_{o+}$:**\nThe currents leaving node $v_{o+}$ are through the load impedance ($R_{L+}$ and $C_{L+}$), the output resistance $r_{o+}$, and the controlled current source $i_{gm1}$.\n$$\nv_{o+} \\left( \\frac{1}{R_{L+}} + sC_{L+} \\right) + (v_{o+} - v_t) \\frac{1}{r_{o+}} + i_{gm1} = 0\n$$\nSubstituting $i_{gm1} = g_{m1}v_{gs1} = g_{m1}(v_{g+} - v_t)$:\n$$\nv_{o+} \\left( \\frac{1}{R_{L+}} + sC_{L+} + \\frac{1}{r_{o+}} \\right) - v_t \\left( \\frac{1}{r_{o+}} + g_{m1} \\right) = -g_{m1} v_{g+}\n$$\nThis forms the first row of our linear system.\n\n**KCL at node $v_{o-}$:**\nThe analysis is identical for the negative-side output:\n$$\nv_{o-} \\left( \\frac{1}{R_{L-}} + sC_{L-} \\right) + (v_{o-} - v_t) \\frac{1}{r_{o-}} + i_{gm2} = 0\n$$\nSubstituting $i_{gm2} = g_{m2}v_{gs2} = g_{m2}(v_{g-} - v_t)$:\n$$\nv_{o-} \\left( \\frac{1}{R_{L-}} + sC_{L-} + \\frac{1}{r_{o-}} \\right) - v_t \\left( \\frac{1}{r_{o-}} + g_{m2} \\right) = -g_{m2} v_{g-}\n$$\nThis forms the second row.\n\n**KCL at node $v_t$:**\nCurrents leave node $v_t$ through the tail impedance ($R_t, C_t$) and back to the output nodes through $r_{o+}$ and $r_{o-}$. The controlled currents $i_{gm1}$ and $i_{gm2}$ enter this node.\n$$\nv_t \\left( \\frac{1}{R_t} + sC_t \\right) + (v_t - v_{o+})\\frac{1}{r_{o+}} + (v_t - v_{o-})\\frac{1}{r_{o-}} - i_{gm1} - i_{gm2} = 0\n$$\nSubstituting the expressions for $i_{gm1}$ and $i_{gm2}$:\n$$\n-v_{o+}\\left(\\frac{1}{r_{o+}}\\right) - v_{o-}\\left(\\frac{1}{r_{o-}}\\right) + v_t \\left( \\frac{1}{R_t} + sC_t + \\frac{1}{r_{o+}} + \\frac{1}{r_{o-}} + g_{m1} + g_{m2} \\right) = g_{m1}v_{g+} + g_{m2}v_{g-}\n$$\nThis forms the third row.\n\nThe system $\\mathbf{Y}\\mathbf{v} = \\mathbf{i}$ is defined by:\nThe admittance matrix $\\mathbf{Y}$:\n$$\n\\mathbf{Y} =\n\\begin{pmatrix}\n\\frac{1}{R_{L+}} + sC_{L+} + \\frac{1}{r_{o+}} & 0 & -(\\frac{1}{r_{o+}} + g_{m1}) \\\\\n0 & \\frac{1}{R_{L-}} + sC_{L-} + \\frac{1}{r_{o-}} & -(\\frac{1}{r_{o-}} + g_{m2}) \\\\\n-\\frac{1}{r_{o+}} & -\\frac{1}{r_{o-}} & \\frac{1}{R_t} + sC_t + \\frac{1}{r_{o+}} + \\frac{1}{r_{o-}} + g_{m1} + g_{m2}\n\\end{pmatrix}\n$$\nThe source vector $\\mathbf{i}$, which depends on the input excitations $v_{g+}$ and $v_{g-}$:\n$$\n\\mathbf{i} =\n\\begin{pmatrix}\n-g_{m1} v_{g+} \\\\\n-g_{m2} v_{g-} \\\\\ng_{m1}v_{g+} + g_{m2}v_{g-}\n\\end{pmatrix}\n$$\n\nFor each test case and frequency, we perform the following steps:\n1.  Calculate numerical values for all circuit parameters, including mismatches: $g_{m1}, g_{m2}, R_{L+}, R_{L-}$, etc.\n2.  Calculate the complex frequency $s = j2\\pi f$.\n3.  Construct the complex-valued matrix $\\mathbf{Y}$.\n\n4.  **Differential-Mode Gain ($A_d$) Calculation**:\n    - Apply odd-mode excitation: $v_{g+} = +0.5$ V, $v_{g-} = -0.5$ V. This corresponds to a differential input $v_{id} = v_{g+} - v_{g-} = 1$ V.\n    - Construct the corresponding source vector $\\mathbf{i}_{odd}$.\n    - Solve the linear system $\\mathbf{Y}\\mathbf{v}_{odd} = \\mathbf{i}_{odd}$ for the node voltage vector $\\mathbf{v}_{odd} = [v_{o+,odd}, v_{o-,odd}, v_{t,odd}]^T$.\n    - The differential-mode gain is $A_d(\\omega) = \\frac{v_{o+,odd} - v_{o-,odd}}{v_{id}} = v_{o+,odd} - v_{o-,odd}$.\n\n5.  **Common-Mode Gain ($A_c$) Calculation**:\n    - Apply even-mode excitation: $v_{g+} = v_{g-} = 1$ V. This corresponds to a common-mode input $v_{icm} = \\frac{v_{g+} + v_{g-}}{2} = 1$ V.\n    - Construct the corresponding source vector $\\mathbf{i}_{even}$.\n    - Solve the linear system $\\mathbf{Y}\\mathbf{v}_{even} = \\mathbf{i}_{even}$ for $\\mathbf{v}_{even} = [v_{o+,even}, v_{o-,even}, v_{t,even}]^T$.\n    - The common-mode gain is $A_c(\\omega) = \\frac{(v_{o+,even} + v_{o-,even})/2}{v_{icm}} = \\frac{v_{o+,even} + v_{o-,even}}{2}$.\n\n6.  **CMRR Calculation**:\n    - The CMRR magnitude is computed as the ratio of the magnitudes of the complex gains: $\\mathrm{CMRR}(\\omega) = \\left|\\frac{A_d(\\omega)}{A_c(\\omega)}\\right|$.\n    - This is converted to decibels: $\\mathrm{CMRR}_{dB}(\\omega) = 20 \\log_{10}(\\mathrm{CMRR}(\\omega))$.\n\nThis procedure is implemented numerically for each combination of test case parameters and frequency.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the CMRR of a differential amplifier for multiple test cases\n    and frequencies using nodal analysis.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (gm, ro, RL, CL, Rt, Ct, delta_gm, delta_RL)\n        (5e-3, 2e5, 1e4, 2e-12, 1e5, 1e-12, 0.02, 0.01),\n        (2e-3, 5e5, 2e4, 1e-12, 1e9, 1e-12, 0.0, 0.0),\n        (3e-3, 1.5e5, 8e3, 2e-12, 8e4, 1e-12, 0.1, 0.1),\n        (4e-3, 2e5, 5e3, 1e-11, 2e5, 5e-12, 0.03, 0.0),\n    ]\n\n    # Frequencies in Hz\n    frequencies = [1e2, 1e4, 1e6, 1e8]\n\n    results = []\n    \n    for case_params in test_cases:\n        gm, ro, RL, CL, Rt, Ct, delta_gm, delta_RL = case_params\n        \n        for f in frequencies:\n            # Complex angular frequency\n            s = 1j * 2 * np.pi * f\n\n            # Apply mismatch to parameters\n            gm1 = gm * (1 + delta_gm)\n            gm2 = gm * (1 - delta_gm)\n            RL_plus = RL * (1 + delta_RL)\n            RL_minus = RL * (1 - delta_RL)\n            \n            # Per the problem, ro and CL have no specified mismatch\n            ro_plus = ro\n            ro_minus = ro\n            CL_plus = CL\n            CL_minus = CL\n\n            # Component admittances and conductances\n            go_plus = 1.0 / ro_plus\n            go_minus = 1.0 / ro_minus\n            \n            Y_L_plus = (1.0 / RL_plus) + s * CL_plus if RL_plus != 0 else s * CL_plus\n            Y_L_minus = (1.0 / RL_minus) + s * CL_minus if RL_minus != 0 else s * CL_minus\n            Y_t = (1.0 / Rt) + s * Ct if Rt != 0 else s * Ct\n\n            # Construct the 3x3 admittance matrix Y\n            Y = np.zeros((3, 3), dtype=np.complex128)\n            \n            # Row 1 (Node v_o+)\n            Y[0, 0] = Y_L_plus + go_plus\n            Y[0, 1] = 0\n            Y[0, 2] = -(go_plus + gm1)\n            \n            # Row 2 (Node v_o-)\n            Y[1, 0] = 0\n            Y[1, 1] = Y_L_minus + go_minus\n            Y[1, 2] = -(go_minus + gm2)\n            \n            # Row 3 (Node v_t)\n            Y[2, 0] = -go_plus\n            Y[2, 1] = -go_minus\n            Y[2, 2] = Y_t + go_plus + go_minus + gm1 + gm2\n            \n            # === Differential-Mode Gain (Ad) Calculation ===\n            # Excitation: vg+ = +0.5, vg- = -0.5\n            vg_plus_odd = 0.5\n            vg_minus_odd = -0.5\n            \n            # Construct current source vector i_odd\n            i_odd = np.array([\n                -gm1 * vg_plus_odd,\n                -gm2 * vg_minus_odd,\n                gm1 * vg_plus_odd + gm2 * vg_minus_odd\n            ], dtype=np.complex128)\n            \n            # Solve for node voltages v_odd\n            v_odd = np.linalg.solve(Y, i_odd)\n            vo_plus_odd, vo_minus_odd = v_odd[0], v_odd[1]\n            \n            # Ad = (vo+ - vo-)/vid, where vid = 1\n            Ad = vo_plus_odd - vo_minus_odd\n\n            # === Common-Mode Gain (Ac) Calculation ===\n            # Excitation: vg+ = 1.0, vg- = 1.0\n            vg_plus_even = 1.0\n            vg_minus_even = 1.0\n            \n            # Construct current source vector i_even\n            i_even = np.array([\n                -gm1 * vg_plus_even,\n                -gm2 * vg_minus_even,\n                gm1 * vg_plus_even + gm2 * vg_minus_even\n            ], dtype=np.complex128)\n            \n            # Solve for node voltages v_even\n            v_even = np.linalg.solve(Y, i_even)\n            vo_plus_even, vo_minus_even = v_even[0], v_even[1]\n\n            # Ac = vocm/vicm, where vicm = 1\n            Ac = (vo_plus_even + vo_minus_even) / 2.0\n            \n            # === CMRR Calculation ===\n            cmrr_mag = np.abs(Ad / Ac) if np.abs(Ac) > 1e-18 else np.inf\n            cmrr_db = 20 * np.log10(cmrr_mag)\n            \n            results.append(f\"{cmrr_db:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Passive matching through careful layout has its limits. To meet the stringent demands of modern high-performance systems, designers increasingly turn to active mismatch cancellation through calibration. This advanced exercise  introduces this system-level solution, where you will frame the task of maximizing $CMRR$ as a constrained optimization problem. By using linear programming, you will learn to compute optimal digital trim settings that correct for device mismatches while adhering to practical power and area budgets, reflecting the interdisciplinary nature of contemporary IC design.",
            "id": "4261536",
            "problem": "Consider a fully differential amplifier whose ideal behavior exhibits zero common-mode gain and a large differential gain. Due to device mismatch, the amplifier acquires nonzero common-mode conversion. A calibration network provides tunable trims that linearly affect the mismatch parameters. The goal is to estimate the mismatch from measurements and to compute trim settings that maximize the Common-Mode Rejection Ratio (CMRR), subject to power and area constraints imposed by the trims.\n\nAssume the following mathematical model. Let the mismatch parameter vector be $u \\in \\mathbb{R}^{n}$, and let the measured output residuals (after subtracting the known ideal response under the applied stimuli) be $r \\in \\mathbb{R}^{m}$. The residuals are modeled as $r = A u + \\varepsilon$, where $A \\in \\mathbb{R}^{m \\times n}$ is a known measurement sensitivity matrix and $\\varepsilon \\in \\mathbb{R}^{m}$ is measurement noise. The common-mode gain sensitivity is represented by a vector $c \\in \\mathbb{R}^{n}$, such that the common-mode gain is $A_{\\mathrm{c}}(u) = c^{\\mathsf{T}} u$. The differential gain sensitivity is $d \\in \\mathbb{R}^{n}$, and the ideal differential gain is $G_{\\mathrm{d0}} \\in \\mathbb{R}$, so the differential gain is $A_{\\mathrm{d}}(u) = G_{\\mathrm{d0}} + d^{\\mathsf{T}} u$. Trims $t \\in \\mathbb{R}^{q}$ are mapped to corrections of the mismatch by $T \\in \\mathbb{R}^{n \\times q}$, so the corrected mismatch is $u_{\\mathrm{corr}} = \\hat{u} - T t$, where $\\hat{u}$ is the estimate of $u$ obtained from the measurements.\n\nPower and area constraints on trims are modeled by nonnegative weights $p \\in \\mathbb{R}^{q}$ and $a \\in \\mathbb{R}^{q}$ with budgets $P_{\\max} \\in \\mathbb{R}$ and $A_{\\max} \\in \\mathbb{R}$, respectively, enforcing $\\sum_{i=1}^{q} p_{i} \\lvert t_{i} \\rvert \\leq P_{\\max}$ and $\\sum_{i=1}^{q} a_{i} \\lvert t_{i} \\rvert \\leq A_{\\max}$. Each trim element is bounded in magnitude by $t_{\\max} \\in \\mathbb{R}^{q}_{\\ge 0}$, enforcing $\\lvert t_{i} \\rvert \\leq t_{\\max,i}$ for all $i$. Calibration aims to maximize CMRR, defined as $ \\mathrm{CMRR} = \\left\\lvert \\frac{A_{\\mathrm{d}}(u_{\\mathrm{corr}})}{A_{\\mathrm{c}}(u_{\\mathrm{corr}})} \\right\\rvert$. Report CMRR in decibels (dB), computed as $20 \\log_{10}(\\mathrm{CMRR})$, rounded to three decimal places. To avoid non-finite values when $A_{\\mathrm{c}}(u_{\\mathrm{corr}})$ vanishes, use a numerical floor $\\epsilon = 10^{-12}$ for the denominator.\n\nStarting from the definitions above and the measurement model $r = A u + \\varepsilon$, the tasks are:\n- Compute the mismatch estimate $\\hat{u}$ by minimizing the squared error $\\lVert A u - r \\rVert_{2}^{2}$ without assuming that $A^{\\mathsf{T}} A$ is invertible.\n- Compute the trim vector $t$ that minimizes the magnitude of the corrected common-mode gain $\\lvert A_{\\mathrm{c}}(u_{\\mathrm{corr}}) \\rvert$ subject to the power and area budgets and trim bounds, using a formulation that is solvable as a linear program.\n- Compute the resulting CMRR in dB using the corrected gains $A_{\\mathrm{d}}(u_{\\mathrm{corr}})$ and $A_{\\mathrm{c}}(u_{\\mathrm{corr}})$.\n\nYour program must implement this calibration procedure and apply it to the following test suite. In all cases, express the final answers in dB and round to three decimal places. The final output must be a single line containing the results as a comma-separated list enclosed in square brackets.\n\nTest Suite:\n- Case $1$ (general well-conditioned case):\n  - $n = 3$, $m = 5$, $q = 3$.\n  - $A = \\begin{bmatrix} 0.9 & 0.1 & 0.0 \\\\ 1.0 & -0.2 & 0.05 \\\\ 0.8 & 0.15 & -0.05 \\\\ 1.1 & -0.1 & 0.02 \\\\ 0.95 & 0.05 & -0.01 \\end{bmatrix}$.\n  - $r = \\begin{bmatrix} -0.02 \\\\ -0.015 \\\\ -0.018 \\\\ -0.017 \\\\ -0.016 \\end{bmatrix}$.\n  - $c = \\begin{bmatrix} 0.04 \\\\ -0.02 \\\\ 0.5 \\end{bmatrix}$, $d = \\begin{bmatrix} 0.01 \\\\ 0.005 \\\\ 0.0 \\end{bmatrix}$, $G_{\\mathrm{d0}} = 80$.\n  - $T = I_{3}$ (the $3 \\times 3$ identity matrix).\n  - $p = \\begin{bmatrix} 0.4 \\\\ 0.3 \\\\ 0.1 \\end{bmatrix}$, $a = \\begin{bmatrix} 0.2 \\\\ 0.5 \\\\ 0.1 \\end{bmatrix}$.\n  - $P_{\\max} = 0.05$, $A_{\\max} = 0.04$, $t_{\\max} = \\begin{bmatrix} 0.1 \\\\ 0.1 \\\\ 0.2 \\end{bmatrix}$.\n- Case $2$ (ample budgets enabling near-perfect cancellation):\n  - $n = 3$, $m = 5$, $q = 3$.\n  - $A = \\begin{bmatrix} 0.9 & 0.1 & 0.0 \\\\ 1.0 & -0.2 & 0.05 \\\\ 0.8 & 0.15 & -0.05 \\\\ 1.1 & -0.1 & 0.02 \\\\ 0.95 & 0.05 & -0.01 \\end{bmatrix}$.\n  - $r = \\begin{bmatrix} -0.02 \\\\ -0.015 \\\\ -0.018 \\\\ -0.017 \\\\ -0.016 \\end{bmatrix}$.\n  - $c = \\begin{bmatrix} 0.04 \\\\ -0.02 \\\\ 0.5 \\end{bmatrix}$, $d = \\begin{bmatrix} 0.01 \\\\ 0.005 \\\\ 0.0 \\end{bmatrix}$, $G_{\\mathrm{d0}} = 80$.\n  - $T = I_{3}$.\n  - $p = \\begin{bmatrix} 0.4 \\\\ 0.3 \\\\ 0.1 \\end{bmatrix}$, $a = \\begin{bmatrix} 0.2 \\\\ 0.5 \\\\ 0.1 \\end{bmatrix}$.\n  - $P_{\\max} = 0.5$, $A_{\\max} = 0.5$, $t_{\\max} = \\begin{bmatrix} 1.0 \\\\ 1.0 \\\\ 1.0 \\end{bmatrix}$.\n- Case $3$ (ill-conditioned measurements and tight budgets):\n  - $n = 3$, $m = 5$, $q = 3$.\n  - $A = \\begin{bmatrix} 1.0 & 0.999 & 1.001 \\\\ 0.999 & 1.0 & 1.001 \\\\ 1.001 & 1.002 & 1.999 \\\\ 1.0 & 0.999 & 1.001 \\\\ 0.999 & 1.0 & 1.001 \\end{bmatrix}$.\n  - $r = \\begin{bmatrix} -0.001 \\\\ -0.0015 \\\\ -0.002 \\\\ -0.0012 \\\\ -0.0013 \\end{bmatrix}$.\n  - $c = \\begin{bmatrix} 0.02 \\\\ -0.01 \\\\ 0.4 \\end{bmatrix}$, $d = \\begin{bmatrix} 0.008 \\\\ 0.004 \\\\ 0.0 \\end{bmatrix}$, $G_{\\mathrm{d0}} = 60$.\n  - $T = I_{3}$.\n  - $p = \\begin{bmatrix} 1.0 \\\\ 1.0 \\\\ 1.0 \\end{bmatrix}$, $a = \\begin{bmatrix} 1.0 \\\\ 1.0 \\\\ 1.0 \\end{bmatrix}$.\n  - $P_{\\max} = 0.001$, $A_{\\max} = 0.001$, $t_{\\max} = \\begin{bmatrix} 0.0005 \\\\ 0.0005 \\\\ 0.0005 \\end{bmatrix}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[ \\mathrm{result}_{1}, \\mathrm{result}_{2}, \\mathrm{result}_{3} \\right]$), where each $\\mathrm{result}_{i}$ is the CMRR in dB for the corresponding test case, rounded to three decimal places.",
            "solution": "The user-provided problem has been rigorously validated and is determined to be valid. It is scientifically grounded in the principles of analog integrated circuit design and linear systems theory, well-posed, objective, and contains all necessary information for a unique solution.\n\nThe problem requires a three-step procedure for each test case:\n1.  Estimate the mismatch parameter vector $\\hat{u}$.\n2.  Compute the optimal trim vector $t$ by solving a constrained optimization problem.\n3.  Calculate the resulting Common-Mode Rejection Ratio (CMRR) in decibels (dB).\n\nThe methodology for each step is detailed below.\n\n### Step 1: Mismatch Parameter Estimation\n\nThe relationship between the measured output residuals $r \\in \\mathbb{R}^{m}$ and the mismatch parameter vector $u \\in \\mathbb{R}^{n}$ is given by the linear model $r = A u + \\varepsilon$, where $A \\in \\mathbb{R}^{m \\times n}$ is the sensitivity matrix and $\\varepsilon$ is measurement noise. The task is to compute an estimate $\\hat{u}$ of the true mismatch vector $u$ by minimizing the squared Euclidean norm of the residual error, i.e., solving the least-squares problem:\n$$\n\\min_{u \\in \\mathbb{R}^{n}} \\lVert A u - r \\rVert_{2}^{2}\n$$\nThe problem statement correctly specifies that the matrix $A^{\\mathsf{T}} A$ may not be invertible, which can occur if the columns of $A$ are not linearly independent or if the system is underdetermined. The most general solution to this problem, which provides the minimum-norm solution among all possible vectors that minimize the residual, is given by the Moore-Penrose pseudoinverse of $A$, denoted as $A^{+}$. The estimate $\\hat{u}$ is therefore computed as:\n$$\n\\hat{u} = A^{+} r\n$$\n\n### Step 2: Optimal Trim Vector Computation\n\nThe next step is to determine the optimal trim vector $t \\in \\mathbb{R}^{q}$ that maximizes the CMRR. Since $\\mathrm{CMRR} = |A_{\\mathrm{d}}/A_{\\mathrm{c}}|$, and the differential gain $A_{\\mathrm{d}}$ is typically large and varies little with small corrections, maximizing CMRR is approximately equivalent to minimizing the magnitude of the common-mode gain, $|A_{\\mathrm{c}}|$. The corrected mismatch is $u_{\\mathrm{corr}} = \\hat{u} - T t$, where $T \\in \\mathbb{R}^{n \\times q}$ is the trim mapping matrix. The corrected common-mode gain is:\n$$\nA_{\\mathrm{c}}(u_{\\mathrm{corr}}) = c^{\\mathsf{T}} u_{\\mathrm{corr}} = c^{\\mathsf{T}}(\\hat{u} - T t) = c^{\\mathsf{T}}\\hat{u} - (c^{\\mathsf{T}}T)t\n$$\nThe optimization problem is to find the trim vector $t$ that minimizes $|A_{\\mathrm{c}}(u_{\\mathrm{corr}})|$ subject to a set of constraints:\n1.  Power constraint: $\\sum_{i=1}^{q} p_{i} \\lvert t_{i} \\rvert \\leq P_{\\max}$\n2.  Area constraint: $\\sum_{i=1}^{q} a_{i} \\lvert t_{i} \\rvert \\leq A_{\\max}$\n3.  Trim range constraint: $\\lvert t_{i} \\rvert \\leq t_{\\max,i}$ for $i=1, \\dots, q$\n\nThe objective function $\\min_t |c^{\\mathsf{T}}\\hat{u} - (c^{\\mathsf{T}}T)t|$ is non-linear. This problem can be reformulated as a Linear Program (LP). We introduce a new non-negative scalar variable $z$, which we aim to minimize. The objective becomes $\\min z$, subject to the original constraints and an additional constraint $|c^{\\mathsf{T}}\\hat{u} - (c^{\\mathsf{T}}T)t| \\le z$. This is equivalent to two linear inequalities:\n$$\nc^{\\mathsf{T}}\\hat{u} - (c^{\\mathsf{T}}T)t \\le z \\quad \\text{and} \\quad c^{\\mathsf{T}}\\hat{u} - (c^{\\mathsf{T}}T)t \\ge -z\n$$\nThe constraints involving absolute values of $t_i$ are also non-linear. We linearize them by introducing $q$ new non-negative variables $\\tau_i$ for $i=1, \\dots, q$, such that $\\tau_i \\ge |t_i|$. This single condition is replaced by two linear inequalities: $t_i \\le \\tau_i$ and $-t_i \\le \\tau_i$. The power and area constraints become linear in terms of $\\tau_i$: $\\sum p_i \\tau_i \\leq P_{\\max}$ and $\\sum a_i \\tau_i \\leq A_{\\max}$.\n\nThe complete LP formulation is as follows:\n\n-   **Optimization Variables**: $t \\in \\mathbb{R}^q$, $\\tau \\in \\mathbb{R}^q$, $z \\in \\mathbb{R}$.\n-   **Objective Function**: Minimize $z$.\n-   **Subject to Constraints**:\n    1.  $(c^{\\mathsf{T}}T)t + z \\ge c^{\\mathsf{T}}\\hat{u}$\n    2.  $-(c^{\\mathsf{T}}T)t + z \\ge -c^{\\mathsf{T}}\\hat{u}$\n    3.  $p^{\\mathsf{T}}\\tau \\le P_{\\max}$\n    4.  $a^{\\mathsf{T}}\\tau \\le A_{\\max}$\n    5.  $t_i - \\tau_i \\le 0$ for $i=1, \\dots, q$\n    6.  $-t_i - \\tau_i \\le 0$ for $i=1, \\dots, q$\n    7.  $-t_{\\max,i} \\le t_i \\le t_{\\max,i}$ for $i=1, \\dots, q$\n    8.  $\\tau_i \\ge 0$ for $i=1, \\dots, q$\n    9.  $z \\ge 0$\n\nThis LP can be solved using standard solvers to find the optimal trim vector $t$.\n\n### Step 3: CMRR Calculation\n\nWith the optimal trim vector $t$ from Step 2, the final calibrated performance is calculated.\n1.  Compute the corrected mismatch vector:\n    $$\n    u_{\\mathrm{corr}} = \\hat{u} - T t\n    $$\n2.  Compute the corrected common-mode and differential gains:\n    $$\n    A_{\\mathrm{c,corr}} = c^{\\mathsf{T}} u_{\\mathrm{corr}}\n    $$\n    $$\n    A_{\\mathrm{d,corr}} = G_{\\mathrm{d0}} + d^{\\mathsf{T}} u_{\\mathrm{corr}}\n    $$\n3.  Calculate the CMRR value. To handle the case where $A_{\\mathrm{c,corr}}$ is zero or close to zero, a numerical floor $\\epsilon = 10^{-12}$ is used for the denominator's magnitude:\n    $$\n    \\mathrm{CMRR} = \\frac{\\lvert A_{\\mathrm{d,corr}} \\rvert}{\\max(\\epsilon, \\lvert A_{\\mathrm{c,corr}} \\rvert)}\n    $$\n4.  Convert the result to decibels (dB) and round to three decimal places:\n    $$\n    \\mathrm{CMRR}_{\\mathrm{dB}} = 20 \\log_{10}(\\mathrm{CMRR})\n    $$\n\nThis three-step procedure is implemented and applied to each test case specified in the problem.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the CMRR calibration problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general well-conditioned case)\n        {\n            \"n\": 3, \"m\": 5, \"q\": 3,\n            \"A\": np.array([\n                [0.9, 0.1, 0.0],\n                [1.0, -0.2, 0.05],\n                [0.8, 0.15, -0.05],\n                [1.1, -0.1, 0.02],\n                [0.95, 0.05, -0.01]\n            ]),\n            \"r\": np.array([-0.02, -0.015, -0.018, -0.017, -0.016]),\n            \"c\": np.array([0.04, -0.02, 0.5]),\n            \"d\": np.array([0.01, 0.005, 0.0]),\n            \"G_d0\": 80.,\n            \"T\": np.identity(3),\n            \"p\": np.array([0.4, 0.3, 0.1]),\n            \"a\": np.array([0.2, 0.5, 0.1]),\n            \"P_max\": 0.05,\n            \"A_max\": 0.04,\n            \"t_max\": np.array([0.1, 0.1, 0.2])\n        },\n        # Case 2 (ample budgets enabling near-perfect cancellation)\n        {\n            \"n\": 3, \"m\": 5, \"q\": 3,\n            \"A\": np.array([\n                [0.9, 0.1, 0.0],\n                [1.0, -0.2, 0.05],\n                [0.8, 0.15, -0.05],\n                [1.1, -0.1, 0.02],\n                [0.95, 0.05, -0.01]\n            ]),\n            \"r\": np.array([-0.02, -0.015, -0.018, -0.017, -0.016]),\n            \"c\": np.array([0.04, -0.02, 0.5]),\n            \"d\": np.array([0.01, 0.005, 0.0]),\n            \"G_d0\": 80.,\n            \"T\": np.identity(3),\n            \"p\": np.array([0.4, 0.3, 0.1]),\n            \"a\": np.array([0.2, 0.5, 0.1]),\n            \"P_max\": 0.5,\n            \"A_max\": 0.5,\n            \"t_max\": np.array([1.0, 1.0, 1.0])\n        },\n        # Case 3 (ill-conditioned measurements and tight budgets)\n        {\n            \"n\": 3, \"m\": 5, \"q\": 3,\n            \"A\": np.array([\n                [1.0, 0.999, 1.001],\n                [0.999, 1.0, 1.001],\n                [1.001, 1.002, 1.999],\n                [1.0, 0.999, 1.001],\n                [0.999, 1.0, 1.001]\n            ]),\n            \"r\": np.array([-0.001, -0.0015, -0.002, -0.0012, -0.0013]),\n            \"c\": np.array([0.02, -0.01, 0.4]),\n            \"d\": np.array([0.008, 0.004, 0.0]),\n            \"G_d0\": 60.,\n            \"T\": np.identity(3),\n            \"p\": np.array([1.0, 1.0, 1.0]),\n            \"a\": np.array([1.0, 1.0, 1.0]),\n            \"P_max\": 0.001,\n            \"A_max\": 0.001,\n            \"t_max\": np.array([0.0005, 0.0005, 0.0005])\n        }\n    ]\n\n    results = []\n    epsilon = 1e-12\n\n    for case in test_cases:\n        # Step 1: Mismatch Parameter Estimation\n        u_hat = np.linalg.pinv(case[\"A\"]) @ case[\"r\"]\n\n        # Step 2: Optimal Trim Vector Computation via Linear Programming\n        q = case[\"q\"]\n        \n        # LP variable vector: x = [t_1,..,t_q, tau_1,..,tau_q, z]\n        # Total variables = 2q + 1\n        \n        # Objective: minimize z. Cost vector c_lp has 1 at the last position.\n        c_lp = np.zeros(2 * q + 1)\n        c_lp[-1] = 1.0\n\n        # Inequality constraints: A_ub * x <= b_ub\n        # Let v = T.T @ c\n        v = case[\"T\"].T @ case[\"c\"]\n        k = case[\"c\"].T @ u_hat\n\n        # Number of inequality constraints: 2 (for z) + 2 (p, a) + 2q (for tau)\n        A_ub = np.zeros((4 + 2 * q, 2 * q + 1))\n        b_ub = np.zeros(4 + 2 * q)\n\n        # Constraint 1: v.T @ t - z <= k  =>  v.T@t - z <= c.T @ u_hat\n        A_ub[0, 0:q] = v\n        A_ub[0, -1] = -1.0\n        b_ub[0] = k\n        \n        # Constraint 2: -v.T @ t - z <= -k => -v.T@t - z <= -c.T @ u_hat\n        A_ub[1, 0:q] = -v\n        A_ub[1, -1] = -1.0\n        b_ub[1] = -k\n\n        # Constraint 3: p.T @ tau <= P_max\n        A_ub[2, q:2*q] = case[\"p\"]\n        b_ub[2] = case[\"P_max\"]\n        \n        # Constraint 4: a.T @ tau <= A_max\n        A_ub[3, q:2*q] = case[\"a\"]\n        b_ub[3] = case[\"A_max\"]\n\n        # Constraints 5 and 6: t_i <= tau_i and -t_i <= tau_i for i=1..q\n        for i in range(q):\n            # t_i - tau_i <= 0\n            A_ub[4 + i, i] = 1.0\n            A_ub[4 + i, q + i] = -1.0\n            b_ub[4 + i] = 0.0\n            # -t_i - tau_i <= 0\n            A_ub[4 + q + i, i] = -1.0\n            A_ub[4 + q + i, q + i] = -1.0\n            b_ub[4 + q + i] = 0.0\n\n        # Bounds on variables\n        bounds = []\n        for i in range(q): # Bounds for t_i\n            bounds.append((-case[\"t_max\"][i], case[\"t_max\"][i]))\n        for i in range(q): # Bounds for tau_i\n            bounds.append((0, None))\n        bounds.append((0, None)) # Bound for z\n\n        # Solve the LP\n        # method='highs' is the default and recommended solver in recent SciPy versions\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        t_opt = res.x[0:q]\n\n        # Step 3: CMRR Calculation\n        u_corr = u_hat - case[\"T\"] @ t_opt\n        Ac_corr = case[\"c\"].T @ u_corr\n        Ad_corr = case[\"G_d0\"] + case[\"d\"].T @ u_corr\n        \n        cmrr_val = np.abs(Ad_corr) / max(epsilon, np.abs(Ac_corr))\n        cmrr_db = 20 * np.log10(cmrr_val)\n        \n        results.append(round(cmrr_db, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}