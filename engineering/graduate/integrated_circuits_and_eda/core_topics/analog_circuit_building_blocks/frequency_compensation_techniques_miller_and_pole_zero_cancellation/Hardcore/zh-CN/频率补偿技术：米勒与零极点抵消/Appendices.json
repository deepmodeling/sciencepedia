{
    "hands_on_practices": [
        {
            "introduction": "理解频率补偿技术的第一步是推导放大器的传递函数。本练习将引导您严格推导一个带调零电阻（$R_z$）的两级放大器的传递函数。通过这个过程，您将清晰地看到 $R_z$ 是如何引入一个左半平面零点，并分析它对放大器频率响应的影响，从而为稳定性分析奠定坚实的数学基础。",
            "id": "4273420",
            "problem": "考虑一个用于集成电路和电子设计自动化 (EDA) 流程的 $2$ 级运算放大器。第一级是一个跨导器，其小信号跨导为 $g_{m1}$，输出电阻为 $r_{o1}$，产生节点电压 $v_{x}$。第二级是一个跨导器，其小信号跨导为 $g_{m2}$，输出电阻为 $r_{o2}$，产生输出电压 $v_{o}$。输出节点通过一个电容 $C_{L}$ 接地作为负载。在输出节点和中间节点之间，连接了一个由串联电阻 $R_{z}$ 和电容 $C_{c}$ 组成的补偿支路。假设反馈因子是一个与频率无关的实常数 $\\beta$。\n\n从基尔霍夫电流定律 (KCL)、线性小信号跨导关系 $i = g_{m} v$ 和电容导纳 $Y_{C} = s C$ 出发，推导该放大器的精确开环传递函数 $A(s) = \\frac{v_{o}}{v_{i}}$，其形式为关于 $s$ 的有理函数，并明确展示 $R_{z}$ 如何出现在表达式中。使用您推导出的 $A(s)$，分析环路传输函数 $T(s) = \\beta A(s)$。\n\n然后，通过对您的表达式取适当的低频极限，证明 $R_{z}$ 是否影响低频环路传输函数 $T(0)$。此外，确定由补偿支路引入的左半平面零点（作为电路参数的函数），并解释该零点如何改变高频环路传输函数的幅度和相位。最后，基于第一性原理，定性评估引入 $R_{z}$ 是否会改变由补偿电容和级限制充电电流决定的压摆率。\n\n您最终报告的量必须是存在 $R_{z}$ 时的低频环路传输函数与 $R_{z} = 0$ 时的低频环路传输函数之比，表示为单个精确值。无需四舍五入。该比值为无量纲量；最终答案中不要包含任何单位。",
            "solution": "该问题要求推导和分析一个带有特定频率补偿网络的 $2$ 级运算放大器的传递函数。对问题陈述的验证证实，其基于集成电路设计中使用的标准小信号模型，具有科学依据、问题明确且客观。因此，我们可以开始求解。\n\n首先，我们建立小信号模型。该放大器由两级组成。第一级输入电压为 $v_i$，是一个跨导器，其产生的电流是 $v_i$ 的函数。该级的跨导为 $g_{m1}$，输出电阻为 $r_{o1}$。第二级输入电压为 $v_x$（第一级的输出），是一个跨导器，其跨导为 $g_{m2}$，输出电阻为 $r_{o2}$。其输出是整个放大器的输出 $v_o$。一个负载电容 $C_L$ 从输出节点 $v_o$ 连接到地。由电容 $C_c$ 和电阻 $R_z$ 串联组成的补偿网络连接在中间节点 $v_x$ 和输出节点 $v_o$ 之间。该补偿支路的导纳由 $Y_c(s) = \\frac{1}{R_z + 1/(sC_c)} = \\frac{sC_c}{1+sR_z C_c}$ 给出。\n\n我们将在节点 $v_x$ 和 $v_o$ 处使用基尔霍夫电流定律 (KCL)。我们假设采用两级反相放大器的标准惯例，即跨导级吸收电流。\n\n在中间节点 $v_x$ 处的 KCL (离开节点的电流总和为零)：\n第一级吸收的电流为 $g_{m1}v_i$。流过其输出电阻的电流为 $v_x/r_{o1}$。流过补偿支路的电流为 $(v_x - v_o)Y_c(s)$。\n$$g_{m1}v_i + \\frac{v_x}{r_{o1}} + (v_x - v_o)Y_c(s) = 0$$\n整理此方程，我们得到：\n$$v_x\\left(\\frac{1}{r_{o1}} + Y_c(s)\\right) - v_o Y_c(s) = -g_{m1}v_i \\quad (*)$$\n\n在输出节点 $v_o$ 处的 KCL (离开节点的电流总和为零)：\n第二级吸收的电流为 $g_{m2}v_x$。流过其输出电阻的电流为 $v_o/r_{o2}$。流过负载电容的电流为 $v_o s C_L$。流过补偿支路的电流为 $(v_o - v_x)Y_c(s)$。\n$$g_{m2}v_x + \\frac{v_o}{r_{o2}} + v_o s C_L + (v_o - v_x)Y_c(s) = 0$$\n整理此方程以求解 $v_x$：\n$$v_x(g_{m2} - Y_c(s)) + v_o\\left(\\frac{1}{r_{o2}} + sC_L + Y_c(s)\\right) = 0$$\n$$v_x = -v_o \\frac{\\frac{1}{r_{o2}} + sC_L + Y_c(s)}{g_{m2} - Y_c(s)} \\quad (**)$$\n\n现在，我们将 $(**)$ 中的 $v_x$ 表达式代入 $(*)$：\n$$-v_o \\frac{\\frac{1}{r_{o2}} + sC_L + Y_c(s)}{g_{m2} - Y_c(s)} \\left(\\frac{1}{r_{o1}} + Y_c(s)\\right) - v_o Y_c(s) = -g_{m1}v_i$$\n为了求得开环传递函数 $A(s) = \\frac{v_o}{v_i}$，我们两边除以 $-v_o$ 和 $g_{m1}$，然后取倒数：\n$$A(s) = \\frac{v_o}{v_i} = \\frac{g_{m1}}{\\frac{\\left(\\frac{1}{r_{o2}} + sC_L + Y_c(s)\\right)\\left(\\frac{1}{r_{o1}} + Y_c(s)\\right)}{g_{m2} - Y_c(s)} + Y_c(s)}$$\n$$A(s) = \\frac{g_{m1}(g_{m2} - Y_c(s))}{\\left(\\frac{1}{r_{o2}} + sC_L + Y_c(s)\\right)\\left(\\frac{1}{r_{o1}} + Y_c(s)\\right) + Y_c(s)(g_{m2} - Y_c(s))}$$\n展开分母：\n$$D(s) = \\left(\\frac{1}{r_{o1}r_{o2}} + \\frac{Y_c(s)}{r_{o2}} + \\frac{sC_L}{r_{o1}} + sC_L Y_c(s) + \\frac{Y_c(s)}{r_{o1}} + Y_c(s)^2\\right) + (g_{m2}Y_c(s) - Y_c(s)^2)$$\n$$D(s) = \\frac{1}{r_{o1}r_{o2}} + \\frac{sC_L}{r_{o1}} + Y_c(s)\\left(\\frac{1}{r_{o1}} + \\frac{1}{r_{o2}} + sC_L + g_{m2}\\right)$$\n传递函数为：\n$$A(s) = \\frac{g_{m1}(g_{m2} - Y_c(s))}{D(s)} = \\frac{g_{m1}(g_{m2} - Y_c(s))}{\\frac{1}{r_{o1}r_{o2}} + \\frac{sC_L}{r_{o1}} + Y_c(s)\\left(g_{m2} + \\frac{1}{r_{o1}} + \\frac{1}{r_{o2}} + sC_L\\right)}$$\n现在，我们代入 $Y_c(s) = \\frac{sC_c}{1+sR_z C_c}$：\n分子变为：\n$$N(s) = g_{m1}\\left(g_{m2} - \\frac{sC_c}{1+sR_z C_c}\\right) = g_{m1}\\frac{g_{m2}(1+sR_z C_c) - sC_c}{1+sR_z C_c} = g_{m1}g_{m2}\\frac{1+sC_c(R_z - 1/g_{m2})}{1+sR_z C_c}$$\n分母变为：\n$$D(s) = \\frac{1}{r_{o1}r_{o2}} + \\frac{sC_L}{r_{o1}} + \\frac{sC_c}{1+sR_z C_c}\\left(g_{m2} + \\frac{1}{r_{o1}} + \\frac{1}{r_{o2}} + sC_L\\right)$$\n将它们组合起来，并对分子和分母同乘以 $(1+sR_z C_c)$：\n$$A(s) = \\frac{g_{m1}g_{m2}(1+sC_c(R_z - 1/g_{m2}))}{\\left(\\frac{1}{r_{o1}r_{o2}} + \\frac{sC_L}{r_{o1}}\\right)(1+sR_z C_c) + sC_c\\left(g_{m2} + \\frac{1}{r_{o1}} + \\frac{1}{r_{o2}} + sC_L\\right)}$$\n展开分母：\n$$D_{full}(s) = \\frac{1}{r_{o1}r_{o2}} + s\\frac{C_c R_z}{r_{o1}r_{o2}} + \\frac{sC_L}{r_{o1}} + s^2\\frac{C_L C_c R_z}{r_{o1}} + sC_c g_{m2} + \\frac{sC_c}{r_{o1}} + \\frac{sC_c}{r_{o2}} + s^2 C_c C_L$$\n按 $s$ 的幂次合并同类项：\n$$D_{full}(s) = \\frac{1}{r_{o1}r_{o2}} + s\\left[C_c\\left(g_{m2} + \\frac{1}{r_{o1}} + \\frac{1}{r_{o2}} + \\frac{R_z}{r_{o1}r_{o2}}\\right) + \\frac{C_L}{r_{o1}}\\right] + s^2\\left[C_c C_L\\left(1 + \\frac{R_z}{r_{o1}}\\right)\\right]$$\n精确的开环传递函数是：\n$$A(s) = \\frac{g_{m1}g_{m2}(1+sC_c(R_z - 1/g_{m2}))}{\\frac{1}{r_{o1}r_{o2}} + s\\left[C_c\\left(g_{m2} + \\frac{1}{r_{o1}} + \\frac{1}{r_{o2}} + \\frac{R_z}{r_{o1}r_{o2}}\\right) + \\frac{C_L}{r_{o1}}\\right] + s^2 C_c C_L\\left(1 + \\frac{R_z}{r_{o1}}\\right)}$$\n该表达式明确地显示了 $R_z$ 如何进入传递函数，符合题意。\n\n接下来，我们分析环路传输函数 $T(s) = \\beta A(s)$。问题询问 $R_z$ 是否影响低频环路传输函数 $T(0)$。我们通过在 $T(s)$ 的表达式中令 $s=0$ 来求得 $T(0)$：\n$$T(0) = \\beta A(0) = \\beta \\frac{g_{m1}g_{m2}(1+0)}{\\frac{1}{r_{o1}r_{o2}} + 0 + 0} = \\beta g_{m1}g_{m2}r_{o1}r_{o2}$$\n$T(0)$ 的表达式不包含 $R_z$。因此，我们证明了 $R_z$ 不影响低频环路传输函数。\n\n传递函数的零点可以通过将分子设为零来求得：\n$$1+s_z C_c(R_z - 1/g_{m2}) = 0$$\n求解 $s_z$：\n$$s_z = -\\frac{1}{C_c(R_z - 1/g_{m2})}$$\n要使其成为左半平面 (LHP) 零点，$s_z$ 必须是负实数。由于 $C_c  0$，我们需要 $R_z - 1/g_{m2}  0$，即 $R_z  1/g_{m2}$。\n\n左半平面零点会改变高频环路传输函数。位于频率 $\\omega_z = |s_z| = \\frac{1}{C_c(R_z - 1/g_{m2})}$ 的零点对波特图的影响如下：\n1.  幅度：对于频率 $\\omega  \\omega_z$，幅度图的斜率增加 $+20$ dB/decade。这种效应可以用来抵消由极点引起的 $-20$ dB/decade 斜率，从而有效地使单位增益频率附近的幅度响应变得平坦。\n2.  相位：在 $\\omega_z$ 附近的频率（大约从 $0.1\\omega_z$ 到 $10\\omega_z$），该零点贡献一个正相移（相位超前），最大可达 $+90^\\circ$。在 $\\omega = \\omega_z$ 处，相位超前为 $+45^\\circ$。这是引入满足 $R_z  1/g_{m2}$ 的 $R_z$ 的主要好处。放大器的极点会贡献相位滞后。特别是第二个极点，它可能将相位裕度降低到不可接受的水平。来自左半平面零点的相位超前补偿了部分由极点引起的相位滞后，从而增加了相位裕度，并改善了闭环放大器的稳定性。这种技术被称为极点-零点对消，即通过放置左半平面零点来抵消放大器第二个极点的影响。\n\n最后，我们对 $R_z$ 对压摆率的影响进行定性评估。压摆率是一种大信号现象，由可用于对电容充电的最大电流决定。在该电路中，压摆率通常受限于第一级的最大可用输出电流（其尾电流 $I_{tail1}$）对补偿电容 $C_c$ 的充电能力。输出端的压摆率为 $SR = \\frac{dV_o}{dt}|_{max}$。在压摆期间，第一级被过驱动，并向补偿支路提供或吸取一个恒定电流 $I_{tail1}$。该电流必须流过 $R_z$ 和 $C_c$ 的串联组合。电容 $C_c$ *两端* 的电压变化率仍然由 $\\frac{dV_{Cc}}{dt} = \\frac{I_{tail1}}{C_c}$ 给出。在压摆期间，反馈环路是开路的，第二级也处于饱和状态，导致其输入电压 $v_x$ 被钳位在几乎恒定的饱和水平。输出电压 $v_o$ 通过补偿支路与 $v_x$ 相关。基本的限制过程是有限电流 $I_{tail1}$ 对 $C_c$ 的充电。串联的 $R_z$ 的存在不会改变这个限制电流或 $C_c$ 的值。它会在压摆开始时在节点 $v_x$ 处引起一个 $I_{tail1}R_z$ 的瞬时电压阶跃，但不会改变随后输出端电压的稳态变化率。因此，在一阶近似下，引入 $R_z$ 不会改变大信号压摆率，其值仍为 $SR \\approx \\frac{I_{tail1}}{C_c}$。\n\n最终要求的量是存在 $R_z$ 时的低频环路传输函数与 $R_z=0$ 时的低频环路传输函数之比。\n如前所述，低频环路传输函数为 $T(0) = \\beta g_{m1}g_{m2}r_{o1}r_{o2}$，它与 $R_z$ 无关。\n设 $T(0)|_{R_z}$ 为存在非零 $R_z$ 时的 $T(0)$，$T(0)|_{R_z=0}$ 为 $R_z=0$ 时的 $T(0)$。\n$$T(0)|_{R_z} = \\beta g_{m1}g_{m2}r_{o1}r_{o2}$$\n$$T(0)|_{R_z=0} = \\beta g_{m1}g_{m2}r_{o1}r_{o2}$$\n该比值为：\n$$\\frac{T(0)|_{R_z}}{T(0)|_{R_z=0}} = \\frac{\\beta g_{m1}g_{m2}r_{o1}r_{o2}}{\\beta g_{m1}g_{m2}r_{o1}r_{o2}} = 1$$",
            "answer": "$$\n\\boxed{1}\n$$"
        },
        {
            "introduction": "在设计了理想的补偿网络之后，关键的下一步是了解其在真实场景中的局限性。本练习探讨了当放大器的负载条件发生变化时（这在集成电路中很常见）会发生什么。通过计算输出极点的偏移，我们可以定量地评估负载变化如何破坏极点-零点对消的精妙平衡，从而加深对补偿方案鲁棒性的理解。",
            "id": "4273330",
            "problem": "考虑一个用于电子设计自动化 (EDA) 精密应用的单端两级运算放大器。其第二级可在其输出节点处建模为一个诺顿等效电路，该电路由一个驱动输出电阻 $R_o$ 和负载电容 $C_L$ 并联组合的小信号电流源组成。频率补偿通过在米勒路径中使用串联阻容网络实现极点-零点对消技术，调整该网络使得在输出端仅存在 $C_L$ 时，引入的左半平面零点恰好抵消输出极点。随后，一个阻性负载 $R_L$ 与 $C_L$ 在输出节点并联（例如，由于下游的测量或接口仪器）。\n\n从基尔霍夫电流定律以及电容器和电阻器的本构关系出发，将输出节点建模为线性时不变单端口，并确定：\n\n- 在 $C_L$ 上并联 $R_L$ 后，新的输出极点角频率。\n- 极点偏移乘法因子 $S$，定义为 $S = \\omega_{p,\\text{new}} / \\omega_{p,\\text{old}}$，其中 $\\omega_{p,\\text{old}}$ 是添加 $R_L$ 前的输出极点角频率，$\\omega_{p,\\text{new}}$ 是添加 $R_L$ 后的输出极点角频率。\n- 当添加 $R_L$ 时，原始的极点-零点对消是否仍然成立，假设补偿零点的频率不因添加 $R_L$ 而改变。\n\n将你的最终答案表示为偏移因子 $S$ 的闭式解析表达式。无需进行数值计算。最终答案是无量纲的。不要四舍五入。",
            "solution": "该问题要求分析两级运算放大器的输出级，以确定添加阻性负载 $R_L$ 对输出极点频率的影响。我们需要求出新的极点频率、极点偏移因子，并评论原始极点-零点对消的有效性。分析将基于从第一性原理出发，将输出节点建模为线性时不变 (LTI) 单端口系统。\n\n首先，我们分析添加阻性负载 $R_L$ **之前**的电路配置。输出节点被建模为诺顿等效电路，它包含一个小信号电流源（我们将其输出电流表示为 $i_{in}(t)$），驱动放大器的固有输出电阻 $R_o$ 和负载电容 $C_L$ 的并联组合。设 $v_o(t)$ 为输出节点的小信号电压。\n\n在输出节点应用基尔霍夫电流定律 (KCL)，来自电流源的总电流必须等于流过并联元件的电流之和：\n$$i_{in}(t) = i_{R_o}(t) + i_{C_L}(t)$$\n根据电阻和电容的本构关系，我们有 $i_{R_o}(t) = v_o(t) / R_o$ 和 $i_{C_L}(t) = C_L \\frac{dv_o(t)}{dt}$。将这些代入 KCL 方程，得到控制输出节点的一阶线性常微分方程：\n$$i_{in}(t) = \\frac{v_o(t)}{R_o} + C_L \\frac{dv_o(t)}{dt}$$\n为了找到系统的极点，我们将此方程变换到拉普拉斯域。设 $I_{in}(s)$ 和 $V_o(s)$ 分别是 $i_{in}(t)$ 和 $v_o(t)$ 的拉普拉斯变换。假设零初始条件，导数的变换为 $sV_o(s)$。方程变为：\n$$I_{in}(s) = \\frac{V_o(s)}{R_o} + s C_L V_o(s) = V_o(s) \\left(\\frac{1}{R_o} + s C_L\\right)$$\n从输入电流到输出电压的传递函数是输出阻抗 $Z_{o,\\text{old}}(s)$：\n$$Z_{o,\\text{old}}(s) = \\frac{V_o(s)}{I_{in}(s)} = \\frac{1}{\\frac{1}{R_o} + s C_L} = \\frac{R_o}{1 + s R_o C_L}$$\n极点是使传递函数幅值趋于无穷大的复频率变量 $s$ 的值。这发生在分母为零时。极点 $s_{p,\\text{old}}$ 位于：\n$$1 + s_{p,\\text{old}} R_o C_L = 0 \\implies s_{p,\\text{old}} = -\\frac{1}{R_o C_L}$$\n输出极点的角频率 $\\omega_{p,\\text{old}}$ 定义为此极点位置的幅值（或等效地，系统时间常数 $\\tau = R_o C_L$ 的倒数）。\n$$\\omega_{p,\\text{old}} = \\frac{1}{R_o C_L}$$\n这是添加 $R_L$ 之前的输出极点频率。\n\n接下来，我们分析在 $C_L$ 和 $R_o$ 上并联阻性负载 $R_L$ **之后**的电路配置。输出节点的 KCL 方程被更新以包含流过 $R_L$ 的电流：\n$$i_{in}(t) = i_{R_o}(t) + i_{R_L}(t) + i_{C_L}(t)$$\n使用本构关系，$i_{R_L}(t) = v_o(t) / R_L$。微分方程变为：\n$$i_{in}(t) = \\frac{v_o(t)}{R_o} + \\frac{v_o(t)}{R_L} + C_L \\frac{dv_o(t)}{dt} = v_o(t) \\left(\\frac{1}{R_o} + \\frac{1}{R_L}\\right) + C_L \\frac{dv_o(t)}{dt}$$\n我们可以定义一个等效电阻 $R_{eq}$，作为 $R_o$ 和 $R_L$ 的并联组合：\n$$R_{eq} = R_o \\parallel R_L = \\left(\\frac{1}{R_o} + \\frac{1}{R_L}\\right)^{-1} = \\frac{R_o R_L}{R_o + R_L}$$\n将 $R_{eq}$ 代入微分方程，可将其简化为与原始情况类似的形式：\n$$i_{in}(t) = \\frac{v_o(t)}{R_{eq}} + C_L \\frac{dv_o(t)}{dt}$$\n在拉普拉斯域中遵循相同的步骤，新的输出阻抗 $Z_{o,\\text{new}}(s)$ 为：\n$$Z_{o,\\text{new}}(s) = \\frac{R_{eq}}{1 + s R_{eq} C_L}$$\n通过将分母设为零，找到新的极点 $s_{p, \\text{new}}$：\n$$1 + s_{p, \\text{new}} R_{eq} C_L = 0 \\implies s_{p, \\text{new}} = -\\frac{1}{R_{eq} C_L}$$\n因此，新的输出极点角频率 $\\omega_{p,\\text{new}}$ 为：\n$$\\omega_{p,\\text{new}} = \\frac{1}{R_{eq} C_L} = \\frac{1}{\\left(\\frac{R_o R_L}{R_o + R_L}\\right) C_L} = \\frac{R_o + R_L}{R_o R_L C_L}$$\n这是第一个要求的结果。\n\n第二个任务是求出极点偏移乘法因子 $S$，定义为 $S = \\omega_{p,\\text{new}} / \\omega_{p,\\text{old}}$。使用上面推导出的表达式：\n$$S = \\frac{\\omega_{p,\\text{new}}}{\\omega_{p,\\text{old}}} = \\frac{\\frac{R_o + R_L}{R_o R_L C_L}}{\\frac{1}{R_o C_L}}$$\n简化表达式：\n$$S = \\frac{R_o + R_L}{R_o R_L C_L} \\cdot (R_o C_L) = \\frac{R_o + R_L}{R_L}$$\n这可以写成：\n$$S = 1 + \\frac{R_o}{R_L}$$\n这就是偏移因子 $S$ 的闭式表达式。\n\n最后的任务是确定原始的极点-零点对消是否仍然成立。最初，补偿零点（设其频率为 $\\omega_z$）被调整为抵消输出极点。这意味着：\n$$\\omega_z = \\omega_{p,\\text{old}}$$\n问题陈述中假设 $\\omega_z$ 不因添加 $R_L$ 而改变。新的极点频率为 $\\omega_{p,\\text{new}} = S \\cdot \\omega_{p,\\text{old}}$。为了使对消仍然成立，我们需要 $\\omega_z = \\omega_{p,\\text{new}}$。这要求 $\\omega_{p,\\text{old}} = \\omega_{p,\\text{new}}$，意味着 $S$ 必须等于 $1$。\n根据我们的表达式 $S = 1 + \\frac{R_o}{R_L}$，只有当 $\\frac{R_o}{R_L} = 0$ 时，$S=1$ 的条件才能满足。由于 $R_o$ 代表一个物理电阻且不为零（否则就不会有初始的有限频率极点需要抵消），这个条件要求 $R_L \\to \\infty$。$R_L \\to \\infty$ 的条件意味着没有添加阻性负载，这与前提相矛盾。对于任何有限、非零的 $R_L$，我们有 $\\frac{R_o}{R_L}  0$，因为电阻是正值。\n因此，$S  1$，这意味着 $\\omega_{p,\\text{new}}  \\omega_{p,\\text{old}}$。\n由于 $\\omega_z = \\omega_{p,\\text{old}}$ 且 $\\omega_{p,\\text{new}}  \\omega_{p,\\text{old}}$，所以可以明确地得出 $\\omega_z \\neq \\omega_{p,\\text{new}}$。添加阻性负载 $R_L$ 会将输出极点移至更高频率，从而破坏了极点-零点对消。这会在放大器的传递函数中产生一个极点-零点偶极子，可能会降低其瞬态建立性能。",
            "answer": "$$\\boxed{1 + \\frac{R_o}{R_L}}$$"
        },
        {
            "introduction": "我们使用的分析模型通常是对更复杂电路的简化。这项计算实践旨在弥合简化理论模型与EDA工具中遇到的高阶系统之间的鸿沟。通过实现一个模型降阶算法，您将学习如何从复杂系统中提取决定稳定性的关键极点和零点，从而验证我们专注于主导和次主导极点的分析方法是一种有效且强大的设计策略。",
            "id": "4273336",
            "problem": "给定一组参数化的、严格真分数的、单输入单输出的线性时不变传递函数，这些函数用于对一个经过补偿的两级运算放大器进行建模。每个高阶传递函数都表示为一个由一阶因子构成的有理函数，这些因子代表以弧度/秒为单位的物理极点和零点位置。设传递函数表示为 $H(s)$，其构造如下：\n$$\nH(s) \\;=\\; k \\cdot \\frac{\\prod_{i=1}^{n_z} (s - z_i)}{\\prod_{j=1}^{n_p} (s - p_j)},\n$$\n其中，$k \\in \\mathbb{R}$ 是一个标量增益，$\\{p_j\\}$ 是满足 $\\operatorname{Re}(p_j)  0$ 的极点，$\\{z_i\\}$ 是满足 $\\operatorname{Re}(z_i)  0$ 的零点。为了进行补偿分析，电路被设计成在 $s = -\\omega_z$ 处有一个补偿零点，该零点被放置在 $s = -p_2$ 处的非主导极点附近，以在补偿环路中实现极零点对消。我们关注的主导极点和非主导极点满足 $0  p_1 \\ll p_2$，并且所有极点都是实数且互不相同。频率 $p_1$、$p_2$ 和 $\\omega_z$ 以弧度/秒表示。\n\n根据基础线性电路理论，对无源和有源线性元件进行节点分析会得到线性微分方程，这些方程可以写在拉普拉斯域中，从而产生有理传递函数，其极点和零点由特征多项式的根决定。极点对应于分母 $\\prod_{j=1}^{n_p} (s - p_j)$ 的根，零点对应于分子 $\\prod_{i=1}^{n_z}(s - z_i)$ 的根。\n\n您的任务是实现一个有原则的模型降阶过程，将每个高阶模型降阶为一个适合补偿设计的低阶模型，同时保留与 Miller 补偿和极零点对消相关的关键特性。具体来说，对于每个测试用例：\n1. 根据提供的极点和零点规格构造高阶传递函数 $H(s)$。\n2. 通过按频率绝对值的升序对极点进行排序，从分母多项式的根中确定两个最小幅值的极点频率 $p_1$ 和 $p_2$（使用 $p_j = -\\operatorname{Re}(p_j)$ 报告以弧度/秒为单位的频率），并从分子多项式的根中提取补偿零点频率 $\\omega_z = -\\operatorname{Re}(z)$。\n3. 应用模型降阶，通过仅保留原始高阶模型中的主导极点 $p_1$、非主导极点 $p_2$ 和补偿零点 $\\omega_z$ 来生成一个为补偿分析设计的降阶传递函数 $H_{\\mathrm{red}}(s)$。降阶传递函数必须是严格真分数的，且形式如下：\n$$\nH_{\\mathrm{red}}(s) \\;=\\; k \\cdot \\frac{(s - z^\\star)}{(s - p_1^\\star)(s - p_2^\\star)},\n$$\n其中 $p_1^\\star$、$p_2^\\star$ 和 $z^\\star$ 是如上所述从原始模型中获得的保留的极点和零点位置。这个降阶模型捕捉了频率补偿设计的基本动态特性。\n4. 通过使用指定的容差，将 $p_1^\\star$、$p_2^\\star$ 和 $z^\\star$ 与相应的原始 $p_1$、$p_2$ 和 $\\omega_z$ 进行比较，以验证降阶模型是否保留了目标特性。使用相对误差度量 $\\varepsilon(x,y) = |x - y|/|y|$。\n\n您的程序必须为每个测试用例计算三个布尔值结果，指示降阶模型是否在提供的容差范围内保留了 $p_1$、$p_2$ 和 $\\omega_z$。为每个测试用例按 $[b_{p_1}, b_{p_2}, b_{\\omega_z}]$ 的顺序返回布尔值，如果相对误差小于或等于容差，则每个布尔值为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n您的程序必须生成一行输出，其中包含所有测试用例的结果，格式为方括号括起来的逗号分隔列表，例如，\"[[true1,true2,true3],[...],...]\"。请使用Python布尔字面量格式。\n\n物理单位说明：所有极点和零点频率必须以弧度/秒为单位进行处理和比较。\n\n角度单位：不适用；仅使用以弧度/秒为单位的频率。\n\n测试套件：\n对于每个测试用例，您将获得 $(k, \\{p_j\\}_{j=1}^{n_p}, \\omega_z, \\tau_{p_1}, \\tau_{p_2}, \\tau_{z})$，其中 $\\tau_{p_1}$、$\\tau_{p_2}$ 和 $\\tau_{z}$ 分别是 $p_1$、$p_2$ 和 $\\omega_z$ 的相对误差容差。每个测试用例都构造一个具有一个补偿零点和五个极点的高阶传递函数。\n\n- 测试用例1（理想情况，主导极点分离良好且零点靠近非主导极点）：\n    - $k = 1.0$\n    - 极点：$[10^3, 5\\times 10^4, 2\\times 10^6, 10^7, 5\\times 10^7]$\n    - 补偿零点：$\\omega_z = 0.98 \\times 5\\times 10^4$\n    - 容差：$\\tau_{p_1} = 10^{-8}$，$\\tau_{p_2} = 10^{-8}$，$\\tau_{z} = 10^{-8}$\n\n- 测试用例2（边界条件，主导和非主导极点间距很近，零点非常靠近非主导极点）：\n    - $k = 0.8$\n    - 极点：$[1.0\\times 10^4, 1.2\\times 10^4, 3.0\\times 10^6, 1.0\\times 10^7, 6.0\\times 10^7]$\n    - 补偿零点：$\\omega_z = 1.001 \\times 1.2\\times 10^4$\n    - 容差：$\\tau_{p_1} = 10^{-8}$，$\\tau_{p_2} = 10^{-8}$，$\\tau_{z} = 10^{-8}$\n\n- 测试用例3（边缘情况，$p_1$ 和 $p_2$ 之间分离极宽，零点靠近非主导极点）：\n    - $k = 1.5$\n    - 极点：$[5.0\\times 10^2, 8.0\\times 10^5, 5.0\\times 10^6, 2.0\\times 10^7, 8.0\\times 10^7]$\n    - 补偿零点：$\\omega_z = 1.02 \\times 8.0\\times 10^5$\n    - 容差：$\\tau_{p_1} = 10^{-8}$，$\\tau_{p_2} = 10^{-8}$，$\\tau_{z} = 10^{-8}$\n\n最终输出格式：\n您的程序应生成一行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，每个测试用例贡献一个包含三个Python布尔值的列表，并按指定顺序排列。例如：\"[[True,True,True],[True,False,True],[False,True,True]]\"。",
            "solution": "该问题基于线性时不变电路理论，该理论通过拉普拉斯域中的有理传递函数来建模运算放大器级及其补偿网络。基本的节点分析法和基尔霍夫定律可得出线性微分方程，当通过拉普拉斯变换进行转换时，这些方程会变成有理函数，其极点和零点决定了动态行为。\n\n原理：\n1. 一个线性时不变传递函数 $H(s)$ 可以表示为由一阶因子乘积构成的有理函数。分母的根（在 $s$ 域）对应于系统极点，分子的根对应于系统零点。对于位于 $s^\\star$ 的极点，其以弧度/秒为单位的频率解释通过 $p = -\\operatorname{Re}(s^\\star)$ 获得；类似地，对于位于 $s^\\dagger$ 的零点，其频率为 $\\omega_z = -\\operatorname{Re}(s^\\dagger)$，这里假设系统稳定，极点和零点的实部为负。\n\n2. 在使用调零电阻的 Miller 补偿中，一个左半平面零点被引入到非主导极点附近，以减轻相位滞后并实现更高的闭环带宽。对于极零点对消，将一个零点放置在一个棘手的极点附近可以减少其对环路响应的影响。\n\n3. 模型降阶旨在推导出一个能保留显著行为同时降低复杂性的低阶模型。对于面向补偿的设计，其基本特征是主导极点 $p_1$、非主导极点 $p_2$ 和补偿零点 $\\omega_z$。对此类情况的一种有原则的降阶方法是，通过构建一个仅包含这些因子的降阶传递函数来保留这些特征，从而得到一个二阶分母和一阶分子，该函数是严格真分数的，并能捕捉到基本的补偿动态。\n\n算法设计：\n- 构造：给定 $k$、一个极点频率列表 $\\{p_j\\}$ 和补偿零点频率 $\\omega_z$，使用位于 $s = -p_j$ 和 $s = -\\omega_z$ 的根来构造 $H(s)$ 的多项式系数。使用 $\\texttt{numpy.poly}$，如果期望的根被收集在列表 $\\{r_\\ell\\}$ 中，则 $\\texttt{numpy.poly}(\\{r_\\ell\\})$ 返回首一多项式 $\\prod_{\\ell}(s - r_\\ell)$ 的系数。对于分子，乘以 $k$ 以施加增益。\n\n- 提取：使用 $\\texttt{numpy.roots}$ 计算分母和分子多项式的根。对于分母的根 $r_j$，极点频率通过 $p_j = -\\operatorname{Re}(r_j)$ 获得；对于分子的根 $z$，补偿零点频率为 $\\omega_z = -\\operatorname{Re}(z)$。按绝对值对极点进行排序，以识别两个最小幅值的极点。\n\n- 降阶：通过构造一个分母多项式（其根为保留的极点 $s = -p_1^\\star$ 和 $s = -p_2^\\star$）和一个分子多项式（其具有位于 $s = -z^\\star$ 的补偿零点，并由 $k$ 缩放）来形成降阶传递函数 $H_{\\mathrm{red}}(s)$。这是一个捕捉 Miller 补偿和极零点对消在环路主导动态中效果的最小模型。\n\n- 验证：为了验证保留性，使用相对误差度量 $\\varepsilon(x,y) = |x - y|/|y|$，将从降阶模型中提取的 $p_1^\\star$、$p_2^\\star$ 和 $z^\\star$ 与原始的 $p_1$、$p_2$ 和 $\\omega_z$ 进行比较。如果每个相对误差都小于或等于其对应的容差，则将布尔值设置为 $\\mathrm{True}$；否则，设置为 $\\mathrm{False}$。\n\n理论依据：\n保留 $p_1$、$p_2$ 和 $\\omega_z$ 对于目标应用是合适的，因为补偿设计决策围绕这些特征展开。高频极点对低频行为和单位增益频率附近的相位裕度贡献较小，可以在不显著改变补偿动态的情况下被截断，这与标准设计实践一致。这种方法与第一性原理的理解相一致：主导极点决定了长的时间常数，非主导极点影响相位裕度，而补偿零点是为实现对消而明确设计的。降阶表示是最小的，但对于补偿分析而言是足够的。\n\n边缘情况和数值考虑：\n- 间距很近的极点需要按幅值仔细排序；使用 $-\\operatorname{Re}(\\cdot)$ 的绝对值同时确保稳定性可以避免错误分类。\n- 当 $\\omega_z \\approx p_2$ 时的近似对消通过保留位置来处理，而不是进行精确的代数对消；模型降阶的目标是保留位置，而非代数简化。\n- 所有计算都以弧度/秒为单位进行，多项式计算使用双精度浮点运算。\n\n最终程序为指定的测试套件实现了此过程，并以所需的单行格式打印汇总的布尔结果。",
            "answer": "```python\nimport numpy as np\n\ndef construct_transfer_polynomials(k, poles, omega_z):\n    \"\"\"\n    Construct numerator and denominator polynomials for H(s) = k * (s + omega_z) / prod_j (s + p_j)\n    using roots at -omega_z for numerator and -p_j for denominator.\n    Returns (num_coeffs, den_coeffs).\n    \"\"\"\n    # Roots for numerator and denominator\n    num_roots = np.array([-omega_z], dtype=np.float64)\n    den_roots = -np.array(poles, dtype=np.float64)\n\n    # Construct monic polynomials from roots\n    num_poly = np.poly(num_roots)  # leading coefficient 1\n    den_poly = np.poly(den_roots)  # leading coefficient 1\n\n    # Apply gain to numerator\n    num_poly = k * num_poly\n    return num_poly, den_poly\n\ndef extract_poles_zeros(num_poly, den_poly):\n    \"\"\"\n    From polynomial coefficients, compute poles and zeros (frequencies in rad/s).\n    Returns (pole_freqs, zero_freqs).\n    \"\"\"\n    # Compute roots\n    den_roots = np.roots(den_poly)\n    num_roots = np.roots(num_poly)\n\n    # Frequencies are -Re(root) for stable LHP roots\n    pole_freqs = -np.real(den_roots)\n    zero_freqs = -np.real(num_roots)\n\n    # Sort for consistency\n    pole_freqs_sorted = np.sort(np.abs(pole_freqs))\n    zero_freqs_sorted = np.sort(np.abs(zero_freqs))\n\n    return pole_freqs_sorted, zero_freqs_sorted\n\ndef reduce_model(k, orig_poles, orig_zero):\n    \"\"\"\n    Reduce the model by retaining the two smallest-magnitude poles and the compensation zero.\n    Returns reduced (num_poly, den_poly).\n    \"\"\"\n    # Retain two smallest poles\n    p_sorted = np.sort(np.abs(orig_poles))\n    p1_star, p2_star = p_sorted[0], p_sorted[1]\n    # Compensation zero (only one)\n    z_star = np.abs(orig_zero[0])\n\n    # Construct reduced polynomials from retained roots\n    num_roots_red = np.array([-z_star], dtype=np.float64)\n    den_roots_red = np.array([-p1_star, -p2_star], dtype=np.float64)\n\n    num_poly_red = k * np.poly(num_roots_red)\n    den_poly_red = np.poly(den_roots_red)\n\n    return num_poly_red, den_poly_red\n\ndef relative_error(x, y):\n    if y == 0:\n        return np.inf if x != 0 else 0\n    return abs(x - y) / abs(y)\n\ndef run_test_case(k, poles, omega_z, tol_p1, tol_p2, tol_z):\n    \"\"\"\n    Build original model, extract features, reduce model, re-extract, and verify preservation.\n    Returns [bool_p1, bool_p2, bool_z].\n    \"\"\"\n    # Construct original transfer function\n    num_poly, den_poly = construct_transfer_polynomials(k, poles, omega_z)\n\n    # Extract poles and zeros from original\n    orig_poles, orig_zeros = extract_poles_zeros(num_poly, den_poly)\n\n    # Identify original p1 and p2 (two smallest magnitudes) and omega_z\n    p1_orig, p2_orig = orig_poles[0], orig_poles[1]\n    omega_z_orig = orig_zeros[0]\n\n    # Reduce the model\n    num_poly_red, den_poly_red = reduce_model(k, orig_poles, orig_zeros)\n\n    # Extract poles and zeros from reduced model\n    red_poles, red_zeros = extract_poles_zeros(num_poly_red, den_poly_red)\n    p1_red, p2_red = red_poles[0], red_poles[1]\n    omega_z_red = red_zeros[0]\n\n    # Compare with tolerances\n    b_p1 = relative_error(p1_red, p1_orig) = tol_p1\n    b_p2 = relative_error(p2_red, p2_orig) = tol_p2\n    b_z = relative_error(omega_z_red, omega_z_orig) = tol_z\n\n    return [b_p1, b_p2, b_z]\n\ndef solve():\n    # Define the test cases as specified in the problem statement.\n    test_cases = [\n        # (k, poles, omega_z, tol_p1, tol_p2, tol_z)\n        (1.0, [1.0e3, 5.0e4, 2.0e6, 1.0e7, 5.0e7], 0.98 * 5.0e4, 1e-8, 1e-8, 1e-8),\n        (0.8, [1.0e4, 1.2e4, 3.0e6, 1.0e7, 6.0e7], 1.001 * 1.2e4, 1e-8, 1e-8, 1e-8),\n        (1.5, [5.0e2, 8.0e5, 5.0e6, 2.0e7, 8.0e7], 1.02 * 8.0e5, 1e-8, 1e-8, 1e-8),\n    ]\n\n    results = []\n    for case in test_cases:\n        k, poles, omega_z, tol_p1, tol_p2, tol_z = case\n        result = run_test_case(k, poles, omega_z, tol_p1, tol_p2, tol_z)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Python prints booleans as True/False without quotes, which matches the required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}