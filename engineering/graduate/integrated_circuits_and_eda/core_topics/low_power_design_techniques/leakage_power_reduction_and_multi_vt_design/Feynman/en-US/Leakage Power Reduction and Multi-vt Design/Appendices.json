{
    "hands_on_practices": [
        {
            "introduction": "To effectively manage leakage power, we must first understand its primary source: subthreshold conduction. This fundamental exercise will guide you through the first-principles derivation of subthreshold current, connecting it to the measurable subthreshold slope ($S$) and its dependence on temperature. Mastering this relationship is crucial as it forms the physical basis for why multi-threshold voltage ($V_t$) design is an effective strategy for power reduction. ",
            "id": "4278908",
            "problem": "An Electronic Design Automation (EDA) flow for leakage-aware synthesis targets a multi-threshold-voltage complementary metal-oxide-semiconductor (CMOS) library where each transistor’s off-state leakage is estimated from fundamental subthreshold physics. Consider an n-channel metal-oxide-semiconductor field-effect transistor (nMOSFET) operated in the subthreshold regime with drain-to-source voltage sufficiently high that the drain current is independent of the drain-to-source voltage in this regime, negligible drain-induced barrier lowering, and long-channel behavior. In diffusion-dominated subthreshold conduction, the channel carrier density follows a Boltzmann relation, and the gate-to-channel coupling yields a slope factor that produces an exponential dependence of drain current on gate-to-source voltage. Define the thermal voltage as $V_T = kT/q$, where $k$ is the Boltzmann constant, $T$ is the absolute temperature, and $q$ is the elementary charge. The subthreshold slope $S$ (in $\\text{V/dec}$) is defined by $S \\equiv \\left( \\frac{d V_{gs}}{d \\log_{10} I_D} \\right)$, and the temperature dependence of $S$ arises through $V_T$.\n\nLet $I_0$ denote the reference subthreshold current at $V_{gs} = V_t$, where $V_t$ is the threshold voltage. Assume that the ideality factor associated with the gate-to-channel coupling is temperature-invariant over the temperature range of interest. At a reference temperature $T_0 = 300 \\text{ K}$, the device has threshold voltage $V_t = 0.35 \\text{ V}$ and measured subthreshold slope $S_0 = 70 \\text{ mV/dec}$.\n\nUsing only the diffusion-dominated subthreshold exponential law, the definition of $S$, and $V_T = kT/q$ as the temperature-dependent quantity, perform the following:\n\n1. Starting from first principles of diffusion-dominated subthreshold conduction, express the drain current $I_D$ in terms of $I_0$, $V_{gs}$, $V_t$, the ideality factor, and $V_T$, and from this definition derive the relation between the subthreshold slope $S$ and $V_T$.\n2. Eliminate the ideality factor by combining your expressions to write a closed-form analytic expression for the off-state current $I_{\\text{off}}(T) \\equiv I_D$ at $V_{gs} = 0$ as a function of $I_0$, $V_t$, $S_0$, $T$, and $T_0$, assuming the ideality factor is temperature-invariant.\n3. Evaluate your expression at $T = T_0$ with the given numerical values $V_t = 0.35 \\text{ V}$ and $S_0 = 70 \\text{ mV/dec}$, and express the final result as a multiple of $I_0$.\n\nProvide your final answer as a single expression in terms of $I_0$ only, with no units attached. No rounding is required. Express any intermediate slopes in $\\text{V/dec}$ and any temperatures in $\\text{K}$. The final boxed answer must be a single expression in terms of $I_0$.",
            "solution": "The problem statement has been validated and is found to be scientifically grounded, well-posed, and objective. It presents a standard problem in semiconductor device physics, specifically modeling MOSFET subthreshold leakage current. All necessary data and definitions are provided, and the assumptions are physically reasonable for an idealized model. Therefore, a solution will be provided.\n\nThe solution proceeds in three parts as requested by the problem statement.\n\nPart 1: Derivation of the drain current expression and the relation between subthreshold slope $S$ and thermal voltage $V_T$.\n\nIn the subthreshold regime, the channel carrier concentration follows a Boltzmann distribution, and the conduction mechanism is dominated by diffusion. The drain current $I_D$ has an exponential dependence on the gate-to-source voltage $V_{gs}$. The standard expression for the subthreshold current, incorporating the gate-to-channel coupling through an ideality factor $n$, is given by:\n$$ I_D = I_{\\text{spec}} \\exp\\left(\\frac{V_{gs} - V_t}{n V_T}\\right) $$\nHere, $V_t$ is the threshold voltage, $V_T = kT/q$ is the thermal voltage, and $I_{\\text{spec}}$ is a process- and geometry-dependent current parameter. The problem defines $I_0$ as the current when $V_{gs} = V_t$. Substituting this condition into the equation gives $I_D(V_{gs}=V_t) = I_{\\text{spec}}\\exp(0) = I_{\\text{spec}}$. Thus, $I_{\\text{spec}}$ is equivalent to $I_0$. The expression for the drain current is:\n$$ I_D(V_{gs}) = I_0 \\exp\\left(\\frac{V_{gs} - V_t}{n V_T}\\right) $$\nThis is the first required expression.\n\nNext, we derive the relation for the subthreshold slope $S$. The definition is given as $S \\equiv \\left( \\frac{d V_{gs}}{d \\log_{10} I_D} \\right)$. To compute this derivative, we first express $V_{gs}$ as a function of $I_D$ by rearranging the current equation:\n$$ \\frac{I_D}{I_0} = \\exp\\left(\\frac{V_{gs} - V_t}{n V_T}\\right) $$\nTaking the natural logarithm of both sides:\n$$ \\ln\\left(\\frac{I_D}{I_0}\\right) = \\frac{V_{gs} - V_t}{n V_T} $$\nSolving for $V_{gs}$:\n$$ V_{gs} = V_t + n V_T \\ln\\left(\\frac{I_D}{I_0}\\right) $$\nTo compute the derivative with respect to $\\log_{10} I_D$, we use the change of base formula for logarithms, $\\ln(x) = \\ln(10) \\log_{10}(x)$:\n$$ V_{gs} = V_t + n V_T \\ln(10) \\log_{10}\\left(\\frac{I_D}{I_0}\\right) $$\n$$ V_{gs} = V_t + n V_T \\ln(10) \\left(\\log_{10}(I_D) - \\log_{10}(I_0)\\right) $$\nNow, we can differentiate $V_{gs}$ with respect to $\\log_{10}(I_D)$:\n$$ S = \\frac{d V_{gs}}{d \\log_{10} I_D} = \\frac{d}{d \\log_{10} I_D} \\left[ V_t + n V_T \\ln(10) \\left(\\log_{10}(I_D) - \\log_{10}(I_0)\\right) \\right] $$\nSince $V_t$, $n$, $V_T$, and $I_0$ are treated as constants in this differentiation:\n$$ S = n V_T \\ln(10) $$\nThis is the required relationship between the subthreshold slope $S$, the ideality factor $n$, and the thermal voltage $V_T$.\n\nPart 2: Derivation of the off-state current $I_{\\text{off}}(T)$.\n\nThe off-state current $I_{\\text{off}}$ is defined as the drain current $I_D$ when $V_{gs} = 0$. Using the expression for $I_D$ from Part 1:\n$$ I_{\\text{off}}(T) = I_D(V_{gs}=0) = I_0 \\exp\\left(\\frac{0 - V_t}{n V_T}\\right) = I_0 \\exp\\left(-\\frac{V_t}{n V_T}\\right) $$\nThis expression contains the ideality factor $n$, which we must eliminate. From the relationship $S = n V_T \\ln(10)$ derived in Part 1, we can write the term $n V_T$ as:\n$$ n V_T = \\frac{S}{\\ln(10)} $$\nSubstituting this into the exponent of the $I_{\\text{off}}(T)$ expression:\n$$ I_{\\text{off}}(T) = I_0 \\exp\\left(-\\frac{V_t}{S / \\ln(10)}\\right) = I_0 \\exp\\left(-\\frac{V_t \\ln(10)}{S}\\right) $$\nThis can be written more conveniently using base $10$ exponentiation, since $\\exp(x \\ln(10)) = 10^x$:\n$$ I_{\\text{off}}(T) = I_0 \\cdot 10^{-V_t/S} $$\nThe problem states that the ideality factor $n$ is temperature-invariant. The relation $S = n V_T \\ln(10)$ implies that the ratio $S/V_T$ is constant with temperature:\n$$ \\frac{S(T)}{V_T(T)} = n \\ln(10) = \\text{constant} $$\nWe can relate the slope $S(T)$ at any temperature $T$ to the known slope $S_0$ at the reference temperature $T_0$:\n$$ \\frac{S(T)}{V_T(T)} = \\frac{S_0}{V_T(T_0)} $$\nSubstituting $V_T = kT/q$:\n$$ \\frac{S(T)}{k T / q} = \\frac{S_0}{k T_0 / q} \\implies S(T) = S_0 \\frac{T}{T_0} $$\nNow, we substitute this expression for $S(T)$ into our equation for $I_{\\text{off}}(T)$:\n$$ I_{\\text{off}}(T) = I_0 \\cdot 10^{-V_t/S(T)} = I_0 \\cdot 10^{-V_t / (S_0 \\frac{T}{T_0})} $$\n$$ I_{\\text{off}}(T) = I_0 \\cdot 10^{\\left(-\\frac{V_t}{S_0}\\frac{T_0}{T}\\right)} $$\nThis is the final closed-form expression for $I_{\\text{off}}(T)$ as a function of the specified parameters, assuming $V_t$ and $I_0$ have no specified temperature dependence.\n\nPart 3: Evaluation of the expression at $T = T_0$.\n\nWe are asked to evaluate $I_{\\text{off}}$ at the reference temperature $T = T_0$ and express the result as a multiple of $I_0$.\nSetting $T=T_0$ in the expression from Part 2:\n$$ I_{\\text{off}}(T_0) = I_0 \\cdot 10^{\\left(-\\frac{V_t}{S_0}\\frac{T_0}{T_0}\\right)} = I_0 \\cdot 10^{-V_t/S_0} $$\nThe given numerical values are:\n$V_t = 0.35 \\text{ V}$\n$T_0 = 300 \\text{ K}$\n$S_0 = 70 \\text{ mV/dec} = 0.070 \\text{ V/dec}$\n\nWe compute the exponent:\n$$ -\\frac{V_t}{S_0} = -\\frac{0.35 \\text{ V}}{0.070 \\text{ V/dec}} $$\nThe units $\\text{V} / (\\text{V/dec})$ correctly result in a dimensionless exponent in decades (`dec`).\n$$ -\\frac{0.35}{0.070} = -\\frac{350}{70} = -5 $$\nSubstituting this value back into the expression for $I_{\\text{off}}(T_0)$:\n$$ I_{\\text{off}}(T_0) = I_0 \\cdot 10^{-5} $$\nThe off-state current at the reference temperature is $10^{-5}$ times the reference current $I_0$.",
            "answer": "$$\n\\boxed{10^{-5} I_{0}}\n$$"
        },
        {
            "introduction": "In modern scaled transistors, the ideal behavior described by simple models is complicated by short-channel effects. This practice focuses on one of the most significant of these: Drain-Induced Barrier Lowering (DIBL), which causes the threshold voltage to decrease at higher drain voltages, thereby increasing leakage. You will implement a standard industry technique to model DIBL and extract its coefficient from simulated device data, providing a practical link between device physics and the characterization needed for accurate circuit analysis. ",
            "id": "4278892",
            "problem": "You are given the task of deriving and validating a first-order model for drain-induced barrier lowering (DIBL) in a metal-oxide-semiconductor field-effect transistor (MOSFET) and using it to estimate the DIBL coefficient from current-voltage data for multiple transistors. The context is leakage power reduction and multi-threshold voltage (multi-$V_{\\mathrm{t}}$) design in Electronic Design Automation (EDA).\n\nStart from the following fundamental base:\n- In the subthreshold regime of a MOSFET, the drain current can be modeled as an exponential function of the surface potential barrier difference. A widely used and well-tested relation is that the drain current $I_{\\mathrm{d}}$ increases approximately exponentially with the effective gate overdrive in the subthreshold regime, represented by\n$$\nI_{\\mathrm{d}} \\propto \\exp\\left(\\frac{V_{\\mathrm{gs}} - V_{\\mathrm{t,eff}}(V_{\\mathrm{ds}},L)}{n V_T}\\right),\n$$\nwhere $V_{\\mathrm{gs}}$ is the gate-to-source voltage, $V_{\\mathrm{ds}}$ is the drain-to-source voltage, $V_{\\mathrm{t,eff}}$ is the effective threshold voltage that depends on $V_{\\mathrm{ds}}$ and channel length $L$, $n$ is the subthreshold slope factor, and $V_T$ is the thermal voltage.\n- The thermal voltage $V_T$ at temperature $T$ is defined by fundamental constants as $V_T = k T / q$, where $k$ is the Boltzmann constant and $q$ is the elementary charge.\n\nUsing electrostatic reasoning about short-channel effects, explain qualitatively why $V_{\\mathrm{t,eff}}$ decreases as $V_{\\mathrm{ds}}$ increases (drain-induced barrier lowering (DIBL)), and why a first-order linear dependence on $V_{\\mathrm{ds}}$ is a reasonable approximation over a moderate range of $V_{\\mathrm{ds}}$. Construct a linear-in-$V_{\\mathrm{ds}}$ model for $V_{\\mathrm{t,eff}}$ whose slope encodes the DIBL strength. Then, given current-voltage data, estimate the DIBL coefficient for each device by:\n- Defining the threshold voltage at a given $V_{\\mathrm{ds}}$ using the constant-current method: $V_{\\mathrm{t,eff}}(V_{\\mathrm{ds}})$ is the value of $V_{\\mathrm{gs}}$ at which $I_{\\mathrm{d}}$ equals a specified reference current per unit width multiplied by the device width.\n- Performing a linear regression of the extracted $V_{\\mathrm{t,eff}}$ versus $V_{\\mathrm{ds}}$ to determine the slope magnitude as the DIBL coefficient.\n\nAssume the following physical constants and settings:\n- Boltzmann constant $k = 1.380649\\times 10^{-23}\\,\\mathrm{J/K}$.\n- Elementary charge $q = 1.602176634\\times 10^{-19}\\,\\mathrm{C}$.\n- Temperature $T = 300\\,\\mathrm{K}$, hence $V_T = kT/q$.\n- Subthreshold slope factor $n = 1.40$ (dimensionless).\n- Reference current per unit width $I_{\\mathrm{ref}}^{(\\mu\\mathrm{m})} = 1.0\\times 10^{-7}\\,\\mathrm{A}/\\mu\\mathrm{m}$.\n- For each dataset, the measured gate voltages are sampled uniformly as $V_{\\mathrm{gs}} \\in \\{0.00, 0.01, 0.02, \\dots, 0.80\\}\\,\\mathrm{V}$.\n\nThe measured drain current for each case is provided implicitly by the following rule (serving as the measurement data generator within the specified operating range):\n$$\nI_{\\mathrm{d}}(V_{\\mathrm{gs}}, V_{\\mathrm{ds}}; W, L) = \\left(I_{\\mathrm{ref}}^{(\\mu\\mathrm{m})} \\cdot W_{\\mu\\mathrm{m}}\\right) \\cdot \\exp\\left(\\frac{V_{\\mathrm{gs}} - V_{\\mathrm{t,eff}}(V_{\\mathrm{ds}},L)}{n V_T}\\right),\n$$\nwhere $W_{\\mu\\mathrm{m}}$ is the device width expressed in micrometers. This relation represents the subthreshold region behavior and is valid for the provided sampling range.\n\nYour program must:\n- For each device and each listed $V_{\\mathrm{ds}}$, compute $I_{\\mathrm{d}}$ at the specified $V_{\\mathrm{gs}}$ samples using the above rule.\n- For each $V_{\\mathrm{ds}}$, extract $V_{\\mathrm{t,eff}}(V_{\\mathrm{ds}})$ via the constant-current method with reference current $I_{\\mathrm{ref}} = I_{\\mathrm{ref}}^{(\\mu\\mathrm{m})} \\cdot W_{\\mu\\mathrm{m}}$, using interpolation in the semi-log domain (linear interpolation in $V_{\\mathrm{gs}}$ versus $\\ln I_{\\mathrm{d}}$).\n- Fit a straight line to $V_{\\mathrm{t,eff}}$ versus $V_{\\mathrm{ds}}$ (least-squares fit) and return the magnitude of the slope as the DIBL coefficient for that device.\n\nUnit instructions:\n- All voltages must be in $\\mathrm{V}$, currents in $\\mathrm{A}$, widths in $\\mu\\mathrm{m}$, and lengths in $\\mathrm{nm}$ as specified.\n- The DIBL coefficient is dimensionless (volts per volt) and must be reported as a decimal number rounded to six digits after the decimal point.\n\nTest suite (four devices spanning long-channel/high-threshold to short-channel/low-threshold cases):\n- Device A (nominal $L$): width $W = 1.0\\,\\mu\\mathrm{m}$, length $L = 90\\,\\mathrm{nm}$, zero-drain threshold $V_{\\mathrm{t0}} = 0.45\\,\\mathrm{V}$, DIBL strength parameter chosen in the data generator corresponding to a moderate short-channel effect. Drain biases $V_{\\mathrm{ds}} \\in \\{0.50, 0.80, 1.00\\}\\,\\mathrm{V}$.\n- Device B (short channel): width $W = 1.0\\,\\mu\\mathrm{m}$, length $L = 45\\,\\mathrm{nm}$, zero-drain threshold $V_{\\mathrm{t0}} = 0.42\\,\\mathrm{V}$, stronger DIBL in the data generator. Drain biases $V_{\\mathrm{ds}} \\in \\{0.50, 0.80, 1.00\\}\\,\\mathrm{V}$.\n- Device C (very short channel, low threshold): width $W = 0.5\\,\\mu\\mathrm{m}$, length $L = 22\\,\\mathrm{nm}$, zero-drain threshold $V_{\\mathrm{t0}} = 0.38\\,\\mathrm{V}$, strong DIBL in the data generator. Drain biases $V_{\\mathrm{ds}} \\in \\{0.50, 0.80, 1.00\\}\\,\\mathrm{V}$.\n- Device D (long channel, high threshold): width $W = 2.0\\,\\mu\\mathrm{m}$, length $L = 130\\,\\mathrm{nm}$, zero-drain threshold $V_{\\mathrm{t0}} = 0.52\\,\\mathrm{V}$, weak DIBL in the data generator. Drain biases $V_{\\mathrm{ds}} \\in \\{0.50, 0.80, 1.00\\}\\,\\mathrm{V}$.\n\nFor the purpose of data generation only, the linear-in-$V_{\\mathrm{ds}}$ dependence of $V_{\\mathrm{t,eff}}$ is instantiated internally using the following device-specific choices for the DIBL slope magnitude (not directly available to the estimator): Device A uses $0.06$, Device B uses $0.16$, Device C uses $0.28$, Device D uses $0.03$.\n\nFinal output format:\n- Your program should produce a single line of output containing the estimated DIBL coefficients for Devices A, B, C, D, respectively, as a comma-separated list enclosed in square brackets, each rounded to six digits after the decimal point, for example, $\\left[\\dots\\right]$.\n\nYour task is to write a complete, runnable program that carries out the above steps and prints the final result in the exact format: a single line with the list, no additional text.",
            "solution": "The problem presented is valid. It is scientifically grounded in the principles of semiconductor device physics, specifically the operation of MOSFETs in the subthreshold regime and the modeling of short-channel effects like Drain-Induced Barrier Lowering (DIBL). The problem is well-posed, providing a clear objective, a complete set of data and parameters, and a precisely defined methodology for parameter extraction. It represents a standard task in device characterization and modeling within the field of electronic design automation (EDA).\n\nThe solution proceeds in two parts. First, a qualitative explanation of the DIBL phenomenon and its linear approximation is provided as requested. Second, a detailed description of the computational algorithm to solve the problem is outlined.\n\n**Qualitative Model of Drain-Induced Barrier Lowering (DIBL)**\n\nIn a Metal-Oxide-Semiconductor Field-Effect Transistor (MOSFET), the flow of current between the source and drain terminals is controlled by the electric field established by the gate-to-source voltage, $V_{\\mathrm{gs}}$. This voltage modulates the height of a potential energy barrier in the semiconductor channel that separates the source and drain. The threshold voltage, $V_{\\mathrm{t}}$, is defined as the gate voltage at which this barrier is lowered sufficiently to allow a significant drain current, $I_{\\mathrm{d}}$, to flow.\n\nIn an ideal, long-channel transistor, the channel potential is governed almost exclusively by the gate. However, in modern short-channel devices, the physical proximity of the source and drain regions means that the drain potential also exerts a significant influence on the channel. The drain is biased at a positive potential relative to the source ($V_{\\mathrm{ds}} > 0$ for an n-channel MOSFET), creating an electric field that penetrates the channel region. This field from the drain provides an additional mechanism for lowering the potential barrier that impedes electron flow from the source.\n\nAs the drain-to-source voltage, $V_{\\mathrm{ds}}$, is increased, the influence of the drain's electric field becomes stronger, leading to a further reduction in the barrier height. This phenomenon is termed Drain-Induced Barrier Lowering (DIBL). Because the drain voltage assists the gate in lowering the barrier, a smaller gate voltage is needed to induce the same level of channel conductivity. Consequently, the effective threshold voltage, $V_{\\mathrm{t,eff}}$, is observed to decrease as $V_{\\mathrm{ds}}$ increases.\n\nFor a moderate range of $V_{\\mathrm{ds}}$, the complex two-dimensional electrostatic interaction can be effectively approximated by a first-order Taylor series expansion of $V_{\\mathrm{t,eff}}$ with respect to $V_{\\mathrm{ds}}$. This justifies the construction of a linear model:\n$$\nV_{\\mathrm{t,eff}}(V_{\\mathrm{ds}}) = V_{\\mathrm{t0}} - \\lambda V_{\\mathrm{ds}}\n$$\nHere, $V_{\\mathrm{t0}}$ represents the threshold voltage at zero drain bias ($V_{\\mathrm{ds}} = 0\\,\\mathrm{V}$), and $\\lambda$ is the DIBL coefficient, a positive dimensionless parameter representing the strength of the DIBL effect. The coefficient is formally defined as the negative rate of change of the threshold voltage with respect to the drain voltage:\n$$\n\\lambda = - \\frac{\\partial V_{\\mathrm{t,eff}}}{\\partial V_{\\mathrm{ds}}}\n$$\nA larger value of $\\lambda$ signifies a more severe DIBL effect, which is a key challenge in short-channel devices as it contributes to increased off-state leakage current.\n\n**Algorithmic Procedure for DIBL Coefficient Extraction**\n\nThe DIBL coefficient for each device will be estimated by following the precise numerical procedure specified in the problem statement. The steps are as follows:\n\n1.  **Initialization**: Define the physical constants: Boltzmann constant $k = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$, elementary charge $q = 1.602176634 \\times 10^{-19}\\,\\mathrm{C}$, and temperature $T = 300\\,\\mathrm{K}$. Calculate the thermal voltage $V_T = kT/q$. Define the model parameter: subthreshold slope factor $n = 1.40$.\n\n2.  **Data Generation**: For each device (A, B, C, D) and for each specified drain bias $V_{\\mathrm{ds}}$:\n    a. Determine the reference current $I_{\\mathrm{ref}}$ for the constant-current method: $I_{\\mathrm{ref}} = I_{\\mathrm{ref}}^{(\\mu\\mathrm{m})} \\cdot W_{\\mu\\mathrm{m}}$, where $I_{\\mathrm{ref}}^{(\\mu\\mathrm{m})} = 1.0\\times 10^{-7}\\,\\mathrm{A}/\\mu\\mathrm{m}$ and $W_{\\mu\\mathrm{m}}$ is the device width in micrometers.\n    b. Calculate the \"true\" effective threshold voltage, $V_{\\mathrm{t,eff,true}}$, using the provided linear model and device-specific parameters: $V_{\\mathrm{t,eff,true}} = V_{\\mathrm{t0}} - \\lambda_{\\text{true}} V_{\\mathrm{ds}}$.\n    c. Generate the \"measured\" drain current data $I_{\\mathrm{d}}(V_{\\mathrm{gs}})$ for the discrete sweep of $V_{\\mathrm{gs}}$ from $0.00\\,\\mathrm{V}$ to $0.80\\,\\mathrm{V}$ in $0.01\\,\\mathrm{V}$ increments using the subthreshold current formula:\n       $$\n       I_{\\mathrm{d}}(V_{\\mathrm{gs}}) = I_{\\mathrm{ref}} \\cdot \\exp\\left(\\frac{V_{\\mathrm{gs}} - V_{\\mathrm{t,eff,true}}}{n V_T}\\right)\n       $$\n\n3.  **Threshold Voltage Extraction**: For each generated $I_{\\mathrm{d}}-V_{\\mathrm{gs}}$ curve (corresponding to a specific device and $V_{\\mathrm{ds}}$):\n    a. The task is to find the value of $V_{\\mathrm{gs}}$ for which $I_{\\mathrm{d}} = I_{\\mathrm{ref}}$. The problem specifies using linear interpolation in the semi-log domain, i.e., treating $V_{\\mathrm{gs}}$ as a linear function of $\\ln(I_{\\mathrm{d}})$.\n    b. Given the data generation formula, it can be inverted to show that $V_{\\mathrm{gs}} = V_{\\mathrm{t,eff,true}} + n V_T \\ln(I_{\\mathrm{d}}/I_{\\mathrm{ref}})$. This confirms that $V_{\\mathrm{gs}}$ is perfectly linear with respect to $\\ln(I_{\\mathrm{d}})$.\n    c. We can therefore use a standard one-dimensional linear interpolation function to find the value of $V_{\\mathrm{gs}}$ that corresponds to $\\ln(I_{\\mathrm{d}}) = \\ln(I_{\\mathrm{ref}})$. Let the discrete data points be $(V_{\\mathrm{gs},i}, \\ln(I_{\\mathrm{d},i}))$. The interpolation function will find the $V_{\\mathrm{gs}}$ value on the line segment connecting the two points that bracket $\\ln(I_{\\mathrm{ref}})$. Due to the perfect linearity of the underlying model, this numerically extracted threshold voltage, $V_{\\mathrm{t,ext}}$, will be exactly equal to $V_{\\mathrm{t,eff,true}}$.\n    d. Store the extracted pair $(V_{\\mathrm{ds}}, V_{\\mathrm{t,ext}})$ for each drain bias.\n\n4.  **Linear Regression and DIBL Coefficient Calculation**: After calculating $V_{\\mathrm{t,ext}}$ for all specified $V_{\\mathrm{ds}}$ values for a single device, we will have a set of points $(V_{\\mathrm{ds},j}, V_{\\mathrm{t,ext},j})$.\n    a. Perform a least-squares linear regression on these points to fit the model $V_{\\mathrm{t,ext}} = a + b V_{\\mathrm{ds}}$. The slope parameter is $b$.\n    b. The estimated DIBL coefficient, $\\lambda_{\\text{est}}$, is the magnitude of the slope: $\\lambda_{\\text{est}} = |b|$. Since $V_{\\mathrm{t,ext}}$ decreases with $V_{\\mathrm{ds}}$, the slope $b$ will be negative, so $\\lambda_{\\text{est}} = -b$.\n    c. Because the data points for the regression are themselves generated from a perfect linear model, the regression will recover the slope $\\lambda_{\\text{true}}$ with high precision, limited only by floating-point arithmetic accuracy.\n\n5.  **Final Output**: Collect the estimated DIBL coefficients for all four devices, round each to six decimal places, and format them into the specified string format `[a,b,c,d]`.\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and validates a first-order DIBL model and estimates the DIBL\n    coefficient from simulated current-voltage data for multiple MOSFETs.\n    \"\"\"\n    \n    # Define physical constants and simulation settings\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n    q_e = 1.602176634e-19 # Elementary charge in C\n    T = 300.0  # Temperature in K\n    n_factor = 1.40  # Subthreshold slope factor (dimensionless)\n    I_ref_per_um = 1.0e-7  # Reference current per unit width in A/µm\n\n    # Calculate thermal voltage\n    V_T = k_B * T / q_e\n\n    # Define the test cases from the problem statement.\n    # The 'dibl_true' key holds the parameter used for data generation.\n    test_cases = [\n        {\n            \"name\": \"Device A\", \n            \"W_um\": 1.0, \"L_nm\": 90, \"Vt0\": 0.45, \"dibl_true\": 0.06, \n            \"Vds_points\": [0.50, 0.80, 1.00]\n        },\n        {\n            \"name\": \"Device B\", \n            \"W_um\": 1.0, \"L_nm\": 45, \"Vt0\": 0.42, \"dibl_true\": 0.16, \n            \"Vds_points\": [0.50, 0.80, 1.00]\n        },\n        {\n            \"name\": \"Device C\", \n            \"W_um\": 0.5, \"L_nm\": 22, \"Vt0\": 0.38, \"dibl_true\": 0.28, \n            \"Vds_points\": [0.50, 0.80, 1.00]\n        },\n        {\n            \"name\": \"Device D\", \n            \"W_um\": 2.0, \"L_nm\": 130, \"Vt0\": 0.52, \"dibl_true\": 0.03, \n            \"Vds_points\": [0.50, 0.80, 1.00]\n        },\n    ]\n\n    # Vgs sweep range as per problem statement\n    v_gs_sweep = np.arange(0.00, 0.80 + 1e-9, 0.01)\n\n    estimated_dibl_coeffs = []\n\n    for device in test_cases:\n        # Unpack device parameters\n        W_um = device[\"W_um\"]\n        Vt0 = device[\"Vt0\"]\n        dibl_true = device[\"dibl_true\"]\n        vds_points = np.array(device[\"Vds_points\"])\n        \n        # Calculate the reference current for this device\n        I_ref = I_ref_per_um * W_um\n        \n        extracted_vt_points = []\n\n        # Iterate through each Vds point to extract the effective threshold voltage\n        for vds in vds_points:\n            # Step 1: Generate synthetic I-V data for the current Vds.\n            # The 'true' effective threshold voltage used for data generation.\n            vt_eff_true = Vt0 - dibl_true * vds\n            \n            # Generate the drain current sweep using the provided anaytical model.\n            id_sweep = I_ref * np.exp((v_gs_sweep - vt_eff_true) / (n_factor * V_T))\n            \n            # Step 2: Extract Vt_eff using the constant-current method with interpolation.\n            # We need to find the Vgs at which Id equals I_ref.\n            # This is done by linear interpolation of Vgs as a function of log(Id).\n            \n            # Take the natural log of the current sweep.\n            log_id_sweep = np.log(id_sweep)\n            \n            # The target log-current value for interpolation.\n            log_I_ref_target = np.log(I_ref)\n            \n            # `np.interp` performs linear interpolation. It finds the `y` value for a new `x`\n            # given existing `(x_pts, y_pts)`.\n            # Here, x is log_id and y is Vgs.\n            # We want to find Vgs (y) for `log_I_ref_target` (x).\n            # The `log_id_sweep` array is guaranteed to be monotonically increasing\n            # because `id_sweep` is exponential in `v_gs_sweep`.\n            vt_extracted = np.interp(log_I_ref_target, log_id_sweep, v_gs_sweep)\n            \n            extracted_vt_points.append(vt_extracted)\n        \n        # Step 3: Perform linear regression on the extracted (Vds, Vt) points.\n        # We fit a line Vt_extracted = intercept + slope * Vds.\n        # The `polyfit` function with degree 1 is used for least-squares regression.\n        # It returns coefficients [slope, intercept].\n        slope, _ = np.polyfit(vds_points, np.array(extracted_vt_points), 1)\n        \n        # The DIBL coefficient is the magnitude of the slope. Since the slope is\n        # negative, this is equivalent to -slope.\n        dibl_estimated = -slope\n        estimated_dibl_coeffs.append(dibl_estimated)\n\n    # Format the results for the final output.\n    # Each coefficient must be rounded to six decimal places.\n    formatted_results = [f\"{coef:.6f}\" for coef in estimated_dibl_coeffs]\n    \n    # The final print statement must be in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```",
            "answer": "[0.060000,0.160000,0.280000,0.030000]"
        },
        {
            "introduction": "This capstone exercise synthesizes your understanding of leakage mechanisms and applies it to a realistic circuit-level optimization problem. You will step into the role of an Electronic Design Automation (EDA) tool developer, tasked with minimizing a design's total leakage power by strategically selecting from a library of Low-Threshold Voltage (LVT) and High-Threshold Voltage (HVT) cells. By calibrating performance and power models from characterization data and implementing an efficient greedy algorithm, you will directly confront the fundamental trade-off between speed and power that defines modern low-power design. ",
            "id": "4278869",
            "problem": "You are given Liberty-format characterization samples for Low-Threshold Voltage (LVT) and High-Threshold Voltage (HVT) standard cells. The task is to calibrate timing and leakage models that are suitable for large-scale optimization in Electronic Design Automation (EDA). Low-Threshold Voltage (LVT) and High-Threshold Voltage (HVT) refer to device flavors with different threshold voltages, trading off speed and leakage. You must derive piecewise-convex approximations for delay as a function of load and linear leakage models as a function of cell width, grounded in physically justified approximations and convex modeling, and then use these models to solve a leakage minimization problem under a global delay budget by an efficient method.\n\nFundamental base and underlying facts: In standard-cell design, subthreshold leakage current scales approximately proportionally with device width for a fixed threshold-voltage class and operating condition, and is higher for lower threshold voltage. Interconnect and output load add delay monotonically and increasingly due to resistive-capacitive effects, which can be well approximated by convex functions of load over a practical range. You must start from these widely accepted facts and calibrate models from data.\n\nCalibration inputs (Liberty-like sample points at a single input slew):\n- For delay, the following load points (in femtofarads) and measured delays (in picoseconds) are provided for two device flavors:\n  - LVT delay samples: loads $[2,5,10,20,40]$ and delays $[12,15,19,27,45]$.\n  - HVT delay samples: loads $[2,5,10,20,40]$ and delays $[16,20,26,36,60]$.\n- For leakage versus width (width in micrometers and leakage in nanoamperes) at nominal corner:\n  - LVT leakage samples: widths $[1,2,3,4,6]$ and leakage currents $[9.5,19.8,30.1,39.6,59.4]$.\n  - HVT leakage samples: widths $[1,2,3,4,6]$ and leakage currents $[3.8,7.9,11.6,15.4,22.9]$.\n\nModel requirements:\n1) Fit a convex, piecewise-linear delay approximation $\\hat d^{(T)}(C)$ for each threshold flavor $T \\in \\{\\mathrm{LVT}, \\mathrm{HVT}\\}$ over load $C$ by minimizing squared error at the given load samples subject to nondecreasing segment slopes. Convexity must be enforced via nondecreasing slopes between successive load intervals. The fitted function must be evaluable for arbitrary $C$ by linear interpolation within the convex piecewise structure and linear extrapolation outside the sample range using endpoint slopes. All loads are in femtofarads and all delays must be in picoseconds.\n\n2) Fit a linear leakage model $I^{(T)}(w) \\approx k_T \\cdot w$ via least squares for each threshold flavor, where $w$ is width in micrometers and leakage is in nanoamperes. Report only the fitted coefficient $k_T$ through your solution logic; the program will use it internally.\n\nOptimization task:\nGiven a design block consisting of $N$ instances indexed by $i$, each instance has a known output load $C_i$ (in femtofarads) and width $w_i$ (in micrometers). You must decide for each instance whether it uses LVT or HVT to minimize total leakage subject to a global total delay budget. The total leakage is $\\sum_i I^{(x_i)}(w_i)$ and the total delay is $\\sum_i \\hat d^{(x_i)}(C_i)$, where the choice $x_i \\in \\{\\mathrm{LVT}, \\mathrm{HVT}\\}$. Using your piecewise-convex delay models and linear leakage models, derive the continuous relaxation and solve it efficiently, and then round to a discrete assignment. The program should implement the following relaxation: let $r_i \\in [0,1]$ denote the fraction selecting LVT for instance $i$, with $r_i = 1$ meaning LVT and $r_i = 0$ meaning HVT. The constraint becomes $\\sum_i r_i \\cdot \\Delta d_i \\ge S$ where $\\Delta d_i = \\hat d^{(\\mathrm{HVT})}(C_i) - \\hat d^{(\\mathrm{LVT})}(C_i)$ and $S = \\sum_i \\hat d^{(\\mathrm{HVT})}(C_i) - D_{\\text{target}}$, and the objective becomes minimizing $\\sum_i r_i \\cdot \\Delta I_i$ where $\\Delta I_i = (k_{\\mathrm{LVT}} - k_{\\mathrm{HVT}}) \\cdot w_i$. Implement the optimal greedy selection based on the ratio rule for the continuous relaxation, and then produce a discrete assignment by setting selected instances to LVT until the delay requirement is met and the rest to HVT.\n\nTest suite:\nYour program must use the following three test cases for instances and budgets. All delays are in picoseconds, loads in femtofarads, widths in micrometers, and leakages in nanoamperes.\n\n- Test case $1$: instances with loads $[5,10,15,25]$ and widths $[2,3,2,4]$, with a delay budget $D_{\\text{target}} = 100$. This is a typical case where the budget is tighter than all-HVT but looser than all-LVT.\n\n- Test case $2$: the same instances as in test case $1$ but with delay budget $D_{\\text{target}}$ set equal to $\\sum_i \\hat d^{(\\mathrm{LVT})}(C_i)$ evaluated from your calibrated LVT delay model. This boundary case should push selection toward all-LVT if the convex fit is consistent.\n\n- Test case $3$: the same instances as in test case $1$ but with delay budget $D_{\\text{target}} = \\sum_i \\hat d^{(\\mathrm{HVT})}(C_i) + 6$. This boundary case should allow all-HVT since the budget is looser than the all-HVT sum.\n\nFinal output specification:\nYour program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets. Each test case’s result must be a list of integers of equal length to the number of instances, where $1$ denotes selecting LVT and $0$ denotes selecting HVT for that instance. For example, your program must print an output of the form $[[a_1,a_2,\\dots],[b_1,b_2,\\dots],[c_1,c_2,\\dots]]$, using only integers and square brackets with commas and without any additional text. No units are included in the final output because the outputs are discrete choices.",
            "solution": "The problem requires a multi-step process: first, to calibrate models for cell delay and leakage power based on provided sample data for Low-Threshold Voltage (LVT) and High-Threshold Voltage (HVT) devices; second, to use these models to solve a circuit optimization problem. The optimization goal is to minimize total leakage power for a given digital logic block by selecting the appropriate device type (LVT or HVT) for each cell, subject to a maximum total path delay constraint. The solution will be developed by first establishing the physical models, then formulating the optimization problem, and finally describing the algorithm to solve it.\n\n### Step 1: Model Calibration\n\n#### Leakage Power Model\nThe problem states that subthreshold leakage current is approximately proportional to the device width for a fixed threshold voltage. This relationship is modeled as a linear function passing through the origin:\n$$\nI^{(T)}(w) = k_T \\cdot w\n$$\nwhere $I^{(T)}$ is the leakage current for threshold type $T \\in \\{\\text{LVT}, \\text{HVT}\\}$, $w$ is the cell width, and $k_T$ is the leakage coefficient for that threshold type. Given a set of sample points $(w_j, I_j)$, the coefficient $k_T$ is determined using linear least squares regression constrained to pass through the origin. The formula that minimizes the sum of squared errors is:\n$$\nk_T = \\frac{\\sum_{j} w_j I_j}{\\sum_{j} w_j^2}\n$$\nUsing the provided data:\n-   LVT leakage samples: widths $w = [1, 2, 3, 4, 6] \\, \\mu\\text{m}$ and leakage currents $I_{\\text{LVT}} = [9.5, 19.8, 30.1, 39.6, 59.4] \\, \\text{nA}$.\n-   HVT leakage samples: widths $w = [1, 2, 3, 4, 6] \\, \\mu\\text{m}$ and leakage currents $I_{\\text{HVT}} = [3.8, 7.9, 11.6, 15.4, 22.9] \\, \\text{nA}$.\n\nFor both LVT and HVT, the sum of squared widths is $\\sum w_j^2 = 1^2 + 2^2 + 3^2 + 4^2 + 6^2 = 1 + 4 + 9 + 16 + 36 = 66 \\, (\\mu\\text{m})^2$.\n\nFor LVT, the sum of products is $\\sum w_j I_j = 1(9.5) + 2(19.8) + 3(30.1) + 4(39.6) + 6(59.4) = 654.2 \\, \\text{nA}\\cdot\\mu\\text{m}$.\nThus, the LVT leakage coefficient is $k_{\\text{LVT}} = \\frac{654.2}{66} \\approx 9.9121 \\, \\text{nA}/\\mu\\text{m}$.\n\nFor HVT, the sum of products is $\\sum w_j I_j = 1(3.8) + 2(7.9) + 3(11.6) + 4(15.4) + 6(22.9) = 253.4 \\, \\text{nA}\\cdot\\mu\\text{m}$.\nThus, the HVT leakage coefficient is $k_{\\text{HVT}} = \\frac{253.4}{66} \\approx 3.8394 \\, \\text{nA}/\\mu\\text{m}$.\n\nThe increase in leakage when switching a cell of width $w_i$ from HVT to LVT is $\\Delta I_i = (k_{\\text{LVT}} - k_{\\text{HVT}}) \\cdot w_i$.\n\n#### Cell Delay Model\nThe delay of a standard cell is a function of the capacitive load $C$ at its output. The problem requires fitting a convex, piecewise-linear function $\\hat{d}^{(T)}(C)$ to the provided delay samples $(C_j, d_j)$. The function is defined by its values $\\hat{d}_j$ at the given sample loads $C_j$. The fitting process aims to find the set of values $\\{\\hat{d}_1, \\hat{d}_2, \\ldots, \\hat{d}_n\\}$ that minimizes the sum of squared errors with respect to the measured delays $\\{d_1, d_2, \\ldots, d_n\\}$, subject to convexity constraints.\n\nThe objective is to minimize:\n$$\n\\text{Error} = \\sum_{j=1}^{n} (d_j - \\hat{d}_j)^2\n$$\nThe convexity constraint for a piecewise-linear function is that the slopes of successive segments must be non-decreasing. For segments between load points $(C_j, \\hat{d}_j)$, $(C_{j+1}, \\hat{d}_{j+1})$ and $(C_{j+1}, \\hat{d}_{j+1})$, $(C_{j+2}, \\hat{d}_{j+2})$, the constraint is:\n$$\ns_j \\le s_{j+1} \\implies \\frac{\\hat{d}_{j+1} - \\hat{d}_j}{C_{j+1} - C_j} \\le \\frac{\\hat{d}_{j+2} - \\hat{d}_{j+1}}{C_{j+2} - C_{j+1}}\n$$\nAdditionally, physical realism requires the delay function to be monotonically non-decreasing, so $\\hat{d}_{j+1} \\ge \\hat{d}_j$ for all $j$. This set of constraints can be formulated as a system of linear inequalities. The overall problem is a Quadratic Program (QP), which can be solved numerically.\n\nOnce the fitted delay values $\\hat{\\mathbf{d}}^{(T)}$ are found for the sample loads $\\mathbf{C}$, the delay for an arbitrary load $C_{\\text{new}}$ is computed via linear interpolation within the range $[\\min(\\mathbf{C}), \\max(\\mathbf{C})]$ and linear extrapolation outside this range using the slopes of the first and last segments, respectively.\n\n### Step 2: Optimization Formulation and Algorithm\n\nThe task is to choose a threshold voltage type $x_i \\in \\{\\text{LVT}, \\text{HVT}\\}$ for each of $N$ cell instances to minimize the total leakage power, while keeping the total delay within a budget $D_{\\text{target}}$.\n-   **Objective**: Minimize $L_{\\text{total}} = \\sum_{i=1}^{N} I^{(x_i)}(w_i) = \\sum_{i=1}^{N} k_{x_i} \\cdot w_i$\n-   **Constraint**: $D_{\\text{total}} = \\sum_{i=1}^{N} \\hat{d}^{(x_i)}(C_i) \\le D_{\\text{target}}$\n\nThis is a variant of the 0/1 knapsack problem. The problem statement guides us to solve its continuous relaxation using a greedy approach. We begin with the configuration that has the minimum possible leakage: all cells are HVT. The total delay for this configuration is $D_{\\text{all-HVT}} = \\sum_{i=1}^{N} \\hat{d}^{(\\text{HVT})}(C_i)$.\n\nIf $D_{\\text{all-HVT}} \\le D_{\\text{target}}$, this is the optimal solution, as it meets the timing constraint with the lowest possible leakage.\n\nIf $D_{\\text{all-HVT}} > D_{\\text{target}}$, we must swap some cells from HVT to the faster but leakier LVT to meet the delay budget. Each swap of cell $i$ from HVT to LVT provides a delay saving of $\\Delta d_i = \\hat{d}^{(\\text{HVT})}(C_i) - \\hat{d}^{(\\text{LVT})}(C_i)$ at a leakage penalty of $\\Delta I_i = I^{(\\text{LVT})}(w_i) - I^{(\\text{HVT})}(w_i) = (k_{\\text{LVT}} - k_{\\text{HVT}})w_i$.\n\nTo perform the swaps most efficiently, we should prioritize cells that offer the largest delay reduction per unit increase in leakage. This leads to a greedy strategy based on the efficiency ratio:\n$$\n\\rho_i = \\frac{\\Delta d_i}{\\Delta I_i}\n$$\nThe algorithm is as follows:\n1.  Calibrate leakage models to find $k_{\\text{LVT}}$ and $k_{\\text{HVT}}$.\n2.  Calibrate delay models to create the evaluation functions $\\hat{d}^{(\\text{LVT})}(C)$ and $\\hat{d}^{(\\text{HVT})}(C)$.\n3.  For a given test case (instance loads $C_i$, widths $w_i$, and budget $D_{\\text{target}}$):\n    a. Initialize the solution with all cells as HVT (e.g., a selection vector of all $0$s).\n    b. Calculate the initial total delay $D_{\\text{current}} = \\sum_i \\hat{d}^{(\\text{HVT})}(C_i)$.\n    c. For each cell $i$, compute the potential delay saving $\\Delta d_i$ and leakage penalty $\\Delta I_i$ for an HVT-to-LVT swap, and their ratio $\\rho_i$.\n    d. Create a list of cell indices sorted in descending order of their efficiency ratio $\\rho_i$.\n    e. Iterate through the sorted list of cells. For each cell $j$ in the sorted list:\n        i. If $D_{\\text{current}} > D_{\\text{target}}$, swap cell $j$ to LVT.\n        ii. Update the total delay: $D_{\\text{current}} \\leftarrow D_{\\text{current}} - \\Delta d_j$.\n        iii. Update the selection vector for cell $j$ to indicate LVT (e.g., set to $1$).\n    f. The final selection vector is the solution for the test case.\n\nThis greedy algorithm provides an optimal solution to the continuous relaxation of the problem (where a fraction of a cell can be swapped) and is a standard, effective heuristic for the discrete 0/1 problem. The implementation will follow this logic for the three provided test cases.\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate model calibration and optimization.\n    \"\"\"\n\n    # --- Step 1: Data Definition ---\n    # Calibration inputs for LVT and HVT standard cells\n    lvt_delay_samples = {'loads': np.array([2, 5, 10, 20, 40]), 'delays': np.array([12, 15, 19, 27, 45])}\n    hvt_delay_samples = {'loads': np.array([2, 5, 10, 20, 40]), 'delays': np.array([16, 20, 26, 36, 60])}\n    \n    lvt_leakage_samples = {'widths': np.array([1, 2, 3, 4, 6]), 'currents': np.array([9.5, 19.8, 30.1, 39.6, 59.4])}\n    hvt_leakage_samples = {'widths': np.array([1, 2, 3, 4, 6]), 'currents': np.array([3.8, 7.9, 11.6, 15.4, 22.9])}\n\n    # Test suite: lists of (loads, widths, delay_budget)\n    test_cases_defs = [\n        {'loads': np.array([5, 10, 15, 25]), 'widths': np.array([2, 3, 2, 4]), 'budget': 100},\n        {'loads': np.array([5, 10, 15, 25]), 'widths': np.array([2, 3, 2, 4]), 'budget': None}, # T2, budget to be calculated\n        {'loads': np.array([5, 10, 15, 25]), 'widths': np.array([2, 3, 2, 4]), 'budget': None}, # T3, budget to be calculated\n    ]\n\n    # --- Step 2: Model Calibration ---\n    \n    def calibrate_leakage(widths, currents):\n        \"\"\"Fits a linear model I = k*w through the origin via least squares.\"\"\"\n        k = np.sum(widths * currents) / np.sum(widths**2)\n        return k\n\n    k_lvt = calibrate_leakage(lvt_leakage_samples['widths'], lvt_leakage_samples['currents'])\n    k_hvt = calibrate_leakage(hvt_leakage_samples['widths'], hvt_leakage_samples['currents'])\n\n    def calibrate_delay(loads, delays):\n        \"\"\"\n        Fits a convex, piecewise-linear delay model using Quadratic Programming.\n        The variables are the fitted delay values at the sample load points.\n        \"\"\"\n        n_points = len(loads)\n        \n        # Objective function: minimize sum of squared errors\n        def objective(d_hat):\n            return np.sum((delays - d_hat)**2)\n\n        # Constraints for convexity (non-decreasing slopes) and monotonicity\n        constraints = []\n        # Monotonicity: d_hat[j] >= d_hat[j-1]\n        for j in range(1, n_points):\n            constraints.append({'type': 'ineq', 'fun': lambda d_hat, j=j: d_hat[j] - d_hat[j-1]})\n        \n        # Convexity: slope[j] >= slope[j-1]\n        for j in range(n_points - 2):\n            c_j, c_jp1, c_jp2 = loads[j], loads[j+1], loads[j+2]\n            # (d_jp2 - d_jp1)/(c_jp2 - c_jp1) - (d_jp1 - d_j)/(c_jp1 - c_j) >= 0\n            # This is a linear inequality in terms of d_hat variables\n            fun = (lambda d_hat, j=j, c_j=c_j, c_jp1=c_jp1, c_jp2=c_jp2: \n                     (d_hat[j+2] - d_hat[j+1]) / (c_jp2 - c_jp1) - \n                     (d_hat[j+1] - d_hat[j]) / (c_jp1 - c_j))\n            constraints.append({'type': 'ineq', 'fun': fun})\n\n        # Initial guess for the optimizer\n        d0 = delays.copy()\n        \n        result = minimize(objective, d0, method='SLSQP', constraints=constraints)\n        \n        if not result.success:\n            raise RuntimeError(f\"Delay model calibration failed: {result.message}\")\n        \n        return result.x\n\n    fitted_delays_lvt = calibrate_delay(lvt_delay_samples['loads'], lvt_delay_samples['delays'])\n    fitted_delays_hvt = calibrate_delay(hvt_delay_samples['loads'], hvt_delay_samples['delays'])\n\n    def evaluate_pwl_delay(C, sample_loads, fitted_delays):\n        \"\"\"Evaluates the piecewise-linear delay model for a given load C.\"\"\"\n        if C < sample_loads[0]:\n            slope = (fitted_delays[1] - fitted_delays[0]) / (sample_loads[1] - sample_loads[0])\n            return fitted_delays[0] - slope * (sample_loads[0] - C)\n        elif C > sample_loads[-1]:\n            slope = (fitted_delays[-1] - fitted_delays[-2]) / (sample_loads[-1] - sample_loads[-2])\n            return fitted_delays[-1] + slope * (C - sample_loads[-1])\n        else:\n            return np.interp(C, sample_loads, fitted_delays)\n\n    # Vectorized evaluation for efficiency\n    vec_eval_lvt = np.vectorize(lambda c: evaluate_pwl_delay(c, lvt_delay_samples['loads'], fitted_delays_lvt))\n    vec_eval_hvt = np.vectorize(lambda c: evaluate_pwl_delay(c, hvt_delay_samples['loads'], fitted_delays_hvt))\n    \n    # --- Step 3: Complete Test Case Definitions ---\n    \n    # Calculate delays for all instances to set budgets for T2 and T3\n    all_instance_loads = test_cases_defs[0]['loads']\n    all_instance_delays_lvt = vec_eval_lvt(all_instance_loads)\n    all_instance_delays_hvt = vec_eval_hvt(all_instance_loads)\n    \n    total_delay_lvt = np.sum(all_instance_delays_lvt)\n    total_delay_hvt = np.sum(all_instance_delays_hvt)\n    \n    test_cases_defs[1]['budget'] = total_delay_lvt\n    test_cases_defs[2]['budget'] = total_delay_hvt + 6\n\n    # --- Step 4: Run Optimization for each Test Case ---\n    \n    results = []\n    for case in test_cases_defs:\n        loads = case['loads']\n        widths = case['widths']\n        d_target = case['budget']\n        num_instances = len(loads)\n        \n        # Calculate delays for each instance using the calibrated models\n        d_lvt = all_instance_delays_lvt\n        d_hvt = all_instance_delays_hvt\n        \n        # Calculate delay savings and leakage penalties\n        delta_d = d_hvt - d_lvt\n        delta_I = (k_lvt - k_hvt) * widths\n        \n        # Avoid division by zero if delta_I is zero for some reason\n        # (not expected here, but good practice).\n        # A small epsilon is added to the denominator.\n        efficiency_ratio = delta_d / (delta_I + 1e-12)\n        \n        # Sort instance indices by efficiency ratio in descending order\n        sorted_indices = np.argsort(efficiency_ratio)[::-1]\n        \n        # Start with all HVT solution\n        selection = np.zeros(num_instances, dtype=int)\n        current_delay = total_delay_hvt\n        \n        # Greedily swap to LVT to meet timing\n        if current_delay > d_target:\n            for idx in sorted_indices:\n                current_delay -= delta_d[idx]\n                selection[idx] = 1\n                if current_delay <= d_target:\n                    break\n        \n        results.append(selection.tolist())\n\n    # --- Step 5: Final Output ---\n    # Format the output as [[a,b,...],[c,d,...],[e,f,...]]\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, res))}]' for res in results])}]\"\n    print(output_str)\n\nsolve()\n\n```",
            "answer": "[[0,1,0,1],[1,1,1,1],[0,0,0,0]]"
        }
    ]
}