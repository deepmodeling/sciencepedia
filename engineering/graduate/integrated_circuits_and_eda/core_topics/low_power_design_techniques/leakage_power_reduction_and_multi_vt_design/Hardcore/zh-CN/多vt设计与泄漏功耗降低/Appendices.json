{
    "hands_on_practices": [
        {
            "introduction": "要有效地减少漏电，首先必须深刻理解其物理根源。本练习聚焦于最主要的漏电来源——亚阈值漏电。通过该练习，您将从基本物理原理出发，推导经典的亚阈值电流指数模型，并将其与可测量的亚阈值摆幅（$S$）建立联系，从而加深对器件物理与实际参数之间关键关系的理解。",
            "id": "4278908",
            "problem": "一个用于漏电感知合成的电子设计自动化（EDA）流程，其目标是一个多阈值电压互补金属氧化物半导体（CMOS）库，其中每个晶体管的关态漏电是根据基本的亚阈值物理学估算的。考虑一个在亚阈值区工作的n沟道金属氧化物半导体场效应晶体管（nMOSFET），其漏源电压足够高，以至于在该区域内漏极电流与漏源电压无关，漏致势垒降低效应可忽略不计，且表现为长沟道行为。在以扩散为主的亚阈值导电中，沟道载流子密度遵循玻尔兹曼关系 (Boltzmann relation)，栅极到沟道的耦合产生一个斜率因子，该因子导致漏极电流对栅源电压呈指数依赖关系。定义热电压为 $V_T = kT/q$，其中 $k$ 是玻尔兹曼常数 (Boltzmann constant)，$T$ 是绝对温度，$q$ 是基本电荷。亚阈值斜率 $S$（单位为 $\\text{V/dec}$）定义为 $S \\equiv \\left( \\frac{d V_{gs}}{d \\log_{10} I_D} \\right)$，并且 $S$ 的温度依赖性通过 $V_T$ 产生。\n\n设 $I_0$ 表示当 $V_{gs} = V_t$ 时的参考亚阈值电流，其中 $V_t$ 是阈值电压。假设与栅极到沟道耦合相关的理想因子在所关注的温度范围内不随温度变化。在参考温度 $T_0 = 300 \\text{ K}$ 时，该器件的阈值电压为 $V_t = 0.35 \\text{ V}$，测得的亚阈值斜率为 $S_0 = 70 \\text{ mV/dec}$。\n\n仅使用以扩散为主的亚阈值指数定律、$S$ 的定义以及 $V_T = kT/q$ 作为随温度变化的量，执行以下操作：\n\n1. 从以扩散为主的亚阈值导电的第一性原理出发，用 $I_0$、$V_{gs}$、$V_t$、理想因子和 $V_T$ 表示漏极电流 $I_D$，并由此定义推导出亚阈值斜率 $S$ 和 $V_T$ 之间的关系。\n2. 假设理想因子不随温度变化，通过组合您的表达式来消除理想因子，写出关态电流 $I_{\\text{off}}(T) \\equiv I_D$ 在 $V_{gs} = 0$ 时作为 $I_0$、$V_t$、$S_0$、$T$ 和 $T_0$ 的函数的闭式解析表达式。\n3. 在 $T = T_0$ 时，使用给定的数值 $V_t = 0.35 \\text{ V}$ 和 $S_0 = 70 \\text{ mV/dec}$ 来评估您的表达式，并将最终结果表示为 $I_0$ 的倍数。\n\n最终答案需仅以 $I_0$ 的单一表达式形式提供，不附带单位。无需四舍五入。任何中间斜率以 $\\text{V/dec}$ 表示，任何温度以 $\\text{K}$ 表示。最终方框内的答案必须是仅包含 $I_0$ 的单一表达式。",
            "solution": "题目陈述已经过验证，被认为是科学上合理的、问题定义清晰且客观的。它提出了一个半导体器件物理中的标准问题，特别是关于MOSFET亚阈值漏电流的建模。所有必要的数据和定义都已提供，且对于一个理想化模型来说，其假设是物理上合理的。因此，将提供解答。\n\n解答过程按题目要求分为三个部分。\n\n第1部分：推导漏极电流表达式以及亚阈值斜率 $S$ 与热电压 $V_T$ 之间的关系。\n\n在亚阈值区，沟道载流子浓度遵循玻尔兹曼分布 (Boltzmann distribution)，导电机制以扩散为主。漏极电流 $I_D$ 对栅源电压 $V_{gs}$ 呈指数依赖关系。包含通过理想因子 $n$ 体现的栅极到沟道耦合的亚阈值电流标准表达式为：\n$$ I_D = I_{\\text{spec}} \\exp\\left(\\frac{V_{gs} - V_t}{n V_T}\\right) $$\n此处，$V_t$ 是阈值电压，$V_T = kT/q$ 是热电压，$I_{\\text{spec}}$ 是一个与工艺和几何形状相关的电流参数。题目将 $I_0$ 定义为当 $V_{gs} = V_t$ 时的电流。将此条件代入方程得到 $I_D(V_{gs}=V_t) = I_{\\text{spec}}\\exp(0) = I_{\\text{spec}}$。因此，$I_{\\text{spec}}$ 等同于 $I_0$。漏极电流的表达式为：\n$$ I_D(V_{gs}) = I_0 \\exp\\left(\\frac{V_{gs} - V_t}{n V_T}\\right) $$\n这是第一个要求的表达式。\n\n接下来，我们推导亚阈值斜率 $S$ 的关系式。其定义为 $S \\equiv \\left( \\frac{d V_{gs}}{d \\log_{10} I_D} \\right)$。为了计算这个导数，我们首先通过重新整理电流方程，将 $V_{gs}$ 表示为 $I_D$ 的函数：\n$$ \\frac{I_D}{I_0} = \\exp\\left(\\frac{V_{gs} - V_t}{n V_T}\\right) $$\n对两边取自然对数：\n$$ \\ln\\left(\\frac{I_D}{I_0}\\right) = \\frac{V_{gs} - V_t}{n V_T} $$\n解出 $V_{gs}$：\n$$ V_{gs} = V_t + n V_T \\ln\\left(\\frac{I_D}{I_0}\\right) $$\n为了计算关于 $\\log_{10} I_D$ 的导数，我们使用对数的换底公式 $\\ln(x) = \\ln(10) \\log_{10}(x)$：\n$$ V_{gs} = V_t + n V_T \\ln(10) \\log_{10}\\left(\\frac{I_D}{I_0}\\right) $$\n$$ V_{gs} = V_t + n V_T \\ln(10) \\left(\\log_{10}(I_D) - \\log_{10}(I_0)\\right) $$\n现在，我们可以对 $V_{gs}$ 关于 $\\log_{10}(I_D)$ 求导：\n$$ S = \\frac{d V_{gs}}{d \\log_{10} I_D} = \\frac{d}{d \\log_{10} I_D} \\left[ V_t + n V_T \\ln(10) \\left(\\log_{10}(I_D) - \\log_{10}(I_0)\\right) \\right] $$\n由于在此微分中 $V_t$、$n$、$V_T$ 和 $I_0$ 被视为常数：\n$$ S = n V_T \\ln(10) $$\n这就是所要求的亚阈值斜率 $S$、理想因子 $n$ 和热电压 $V_T$ 之间的关系。\n\n第2部分：推导关态电流 $I_{\\text{off}}(T)$。\n\n关态电流 $I_{\\text{off}}$ 定义为当 $V_{gs} = 0$ 时的漏极电流 $I_D$。使用第1部分中的 $I_D$ 表达式：\n$$ I_{\\text{off}}(T) = I_D(V_{gs}=0) = I_0 \\exp\\left(\\frac{0 - V_t}{n V_T}\\right) = I_0 \\exp\\left(-\\frac{V_t}{n V_T}\\right) $$\n这个表达式包含理想因子 $n$，我们必须将其消除。从第1部分推导出的关系式 $S = n V_T \\ln(10)$，我们可以将 $n V_T$ 项写为：\n$$ n V_T = \\frac{S}{\\ln(10)} $$\n将此代入 $I_{\\text{off}}(T)$ 表达式的指数中：\n$$ I_{\\text{off}}(T) = I_0 \\exp\\left(-\\frac{V_t}{S / \\ln(10)}\\right) = I_0 \\exp\\left(-\\frac{V_t \\ln(10)}{S}\\right) $$\n使用以10为底的指数可以更方便地写出此式，因为 $\\exp(x \\ln(10)) = 10^x$：\n$$ I_{\\text{off}}(T) = I_0 \\cdot 10^{-V_t/S} $$\n题目指出理想因子 $n$ 不随温度变化。关系式 $S = n V_T \\ln(10)$ 意味着比率 $S/V_T$ 不随温度变化：\n$$ \\frac{S(T)}{V_T(T)} = n \\ln(10) = \\text{constant} $$\n我们可以将任意温度 $T$ 下的斜率 $S(T)$ 与参考温度 $T_0$ 下的已知斜率 $S_0$ 联系起来：\n$$ \\frac{S(T)}{V_T(T)} = \\frac{S_0}{V_T(T_0)} $$\n代入 $V_T = kT/q$：\n$$ \\frac{S(T)}{k T / q} = \\frac{S_0}{k T_0 / q} \\implies S(T) = S_0 \\frac{T}{T_0} $$\n现在，我们将 $S(T)$ 的这个表达式代入我们的 $I_{\\text{off}}(T)$ 方程中：\n$$ I_{\\text{off}}(T) = I_0 \\cdot 10^{-V_t/S(T)} = I_0 \\cdot 10^{-V_t / (S_0 \\frac{T}{T_0})} $$\n$$ I_{\\text{off}}(T) = I_0 \\cdot 10^{\\left(-\\frac{V_t}{S_0}\\frac{T_0}{T}\\right)} $$\n这是 $I_{\\text{off}}(T)$ 作为指定参数函数的最终闭式表达式，假设 $V_t$ 和 $I_0$ 没有指定的温度依赖性。\n\n第3部分：在 $T = T_0$ 时对表达式求值。\n\n我们被要求在参考温度 $T = T_0$ 时评估 $I_{\\text{off}}$，并将结果表示为 $I_0$ 的倍数。\n在第2部分的表达式中令 $T=T_0$：\n$$ I_{\\text{off}}(T_0) = I_0 \\cdot 10^{\\left(-\\frac{V_t}{S_0}\\frac{T_0}{T_0}\\right)} = I_0 \\cdot 10^{-V_t/S_0} $$\n给定的数值是：\n$V_t = 0.35 \\text{ V}$\n$T_0 = 300 \\text{ K}$\n$S_0 = 70 \\text{ mV/dec} = 0.070 \\text{ V/dec}$\n\n我们计算指数：\n$$ -\\frac{V_t}{S_0} = -\\frac{0.35 \\text{ V}}{0.070 \\text{ V/dec}} $$\n单位 $\\text{V} / (\\text{V/dec})$ 正确地得出了以“decades”（`dec`）为单位的无量纲指数。\n$$ -\\frac{0.35}{0.070} = -\\frac{350}{70} = -5 $$\n将此值代回 $I_{\\text{off}}(T_0)$ 的表达式中：\n$$ I_{\\text{off}}(T_0) = I_0 \\cdot 10^{-5} $$\n在参考温度下的关态电流是参考电流 $I_0$ 的 $10^{-5}$ 倍。",
            "answer": "$$\n\\boxed{10^{-5} I_{0}}\n$$"
        },
        {
            "introduction": "理想化的器件模型在现代晶体管中会因真实的物理效应而变得复杂。本练习将探讨一个关键的短沟道效应——漏致势垒降低（DIBL），即漏极电压会调制阈值电压，从而影响漏电。您的任务是为DIBL效应建立一个一阶线性模型，并从给定的电流-电压（I-V）数据中提取其系数，这展示了在EDA工具开发中一项核心的器件表征技能。",
            "id": "4278892",
            "problem": "您的任务是推导并验证金属-氧化物-半导体场效应晶体管 (MOSFET) 中漏致势垒降低 (DIBL) 的一阶模型，并利用该模型根据多个晶体管的电流-电压数据估算 DIBL 系数。具体背景是电子设计自动化 (EDA) 中的漏电功率降低和多阈值电压 (multi-$V_{\\mathrm{t}}$) 设计。\n\n从以下基本原理开始：\n- 在 MOSFET 的亚阈值区，漏极电流可以建模为表面势垒差的指数函数。一个被广泛使用且经过充分检验的关系是，在亚阈值区，漏极电流 $I_{\\mathrm{d}}$ 随着有效栅极过驱动电压近似呈指数增长，表示为\n$$\nI_{\\mathrm{d}} \\propto \\exp\\left(\\frac{V_{\\mathrm{gs}} - V_{\\mathrm{t,eff}}(V_{\\mathrm{ds}},L)}{n V_T}\\right)\n$$,\n其中 $V_{\\mathrm{gs}}$ 是栅源电压，$V_{\\mathrm{ds}}$ 是漏源电压，$V_{\\mathrm{t,eff}}$ 是依赖于 $V_{\\mathrm{ds}}$ 和沟道长度 $L$ 的有效阈值电压，$n$ 是亚阈值斜率因子，$V_T$ 是热电压。\n- 温度为 $T$ 时的热电压 $V_T$ 由基本常数定义为 $V_T = k T / q$，其中 $k$ 是玻尔兹曼常数，$q$ 是元电荷。\n\n利用关于短沟道效应的静电学推理，定性解释为什么当 $V_{\\mathrm{ds}}$ 增加时 $V_{\\mathrm{t,eff}}$ 会减小（漏致势垒降低 (DIBL)），以及为什么在适度的 $V_{\\mathrm{ds}}$ 范围内，关于 $V_{\\mathrm{ds}}$ 的一阶线性依赖关系是一个合理的近似。构建一个关于 $V_{\\mathrm{ds}}$ 的线性模型来表示 $V_{\\mathrm{t,eff}}$，其斜率用于表征 DIBL 强度。然后，给定电流-电压数据，通过以下方法估算每个器件的 DIBL 系数：\n- 使用恒流法定义给定 $V_{\\mathrm{ds}}$ 下的阈值电压：$V_{\\mathrm{t,eff}}(V_{\\mathrm{ds}})$ 是指当 $I_{\\mathrm{d}}$ 等于指定的单位宽度参考电流乘以器件宽度时的 $V_{\\mathrm{gs}}$ 值。\n- 对提取的 $V_{\\mathrm{t,eff}}$ 与 $V_{\\mathrm{ds}}$ 进行线性回归，以确定斜率的绝对值作为 DIBL 系数。\n\n假设使用以下物理常数和设置：\n- 玻尔兹曼常数 $k = 1.380649\\times 10^{-23}\\,\\mathrm{J/K}$。\n- 元电荷 $q = 1.602176634\\times 10^{-19}\\,\\mathrm{C}$。\n- 温度 $T = 300\\,\\mathrm{K}$，因此 $V_T = kT/q$。\n- 亚阈值斜率因子 $n = 1.40$（无量纲）。\n- 单位宽度参考电流 $I_{\\mathrm{ref}}^{(\\mu\\mathrm{m})} = 1.0\\times 10^{-7}\\,\\mathrm{A}/\\mu\\mathrm{m}$。\n- 对于每个数据集，测量的栅极电压在 $V_{\\mathrm{gs}} \\in \\{0.00, 0.01, 0.02, \\dots, 0.80\\}\\,\\mathrm{V}$ 范围内均匀采样。\n\n每种情况下的测量漏极电流由以下规则隐式提供（在指定工作范围内作为测量数据生成器）：\n$$\nI_{\\mathrm{d}}(V_{\\mathrm{gs}}, V_{\\mathrm{ds}}; W, L) = \\left(I_{\\mathrm{ref}}^{(\\mu\\mathrm{m})} \\cdot W_{\\mu\\mathrm{m}}\\right) \\cdot \\exp\\left(\\frac{V_{\\mathrm{gs}} - V_{\\mathrm{t,eff}}(V_{\\mathrm{ds}},L)}{n V_T}\\right),\n$$\n其中 $W_{\\mu\\mathrm{m}}$ 是以微米表示的器件宽度。此关系代表了亚阈值区的行为，并在提供的采样范围内有效。\n\n您的程序必须：\n- 对于每个器件和每个列出的 $V_{\\mathrm{ds}}$，使用上述规则计算指定 $V_{\\mathrm{gs}}$ 采样点上的 $I_{\\mathrm{d}}$。\n- 对于每个 $V_{\\mathrm{ds}}$，通过恒流法提取 $V_{\\mathrm{t,eff}}(V_{\\mathrm{ds}})$，参考电流为 $I_{\\mathrm{ref}} = I_{\\mathrm{ref}}^{(\\mu\\mathrm{m})} \\cdot W_{\\mu\\mathrm{m}}$，在半对数域中进行插值（即在 $V_{\\mathrm{gs}}$ 对 $\\ln I_{\\mathrm{d}}$ 的坐标系中进行线性插值）。\n- 对 $V_{\\mathrm{t,eff}}$ 与 $V_{\\mathrm{ds}}$ 的关系进行直线拟合（最小二乘法拟合），并返回斜率的绝对值作为该器件的 DIBL 系数。\n\n单位说明：\n- 所有电压单位必须为 $\\mathrm{V}$，电流单位为 $\\mathrm{A}$，宽度单位为 $\\mu\\mathrm{m}$，长度单位为 $\\mathrm{nm}$，如指定。\n- DIBL 系数是无量纲的（伏特/伏特），必须报告为小数点后保留六位的小数。\n\n测试套件（四个器件，涵盖从长沟道/高阈值到短沟道/低阈值的情况）：\n- 器件 A（标称 $L$）：宽度 $W = 1.0\\,\\mu\\mathrm{m}$，长度 $L = 90\\,\\mathrm{nm}$，零漏极偏压阈值 $V_{\\mathrm{t0}} = 0.45\\,\\mathrm{V}$，数据生成器中选择的 DIBL 强度参数对应于中等短沟道效应。漏极偏压 $V_{\\mathrm{ds}} \\in \\{0.50, 0.80, 1.00\\}\\,\\mathrm{V}$。\n- 器件 B（短沟道）：宽度 $W = 1.0\\,\\mu\\mathrm{m}$，长度 $L = 45\\,\\mathrm{nm}$，零漏极偏压阈值 $V_{\\mathrm{t0}} = 0.42\\,\\mathrm{V}$，数据生成器中具有更强的 DIBL。漏极偏压 $V_{\\mathrm{ds}} \\in \\{0.50, 0.80, 1.00\\}\\,\\mathrm{V}$。\n- 器件 C（极短沟道，低阈值）：宽度 $W = 0.5\\,\\mu\\mathrm{m}$，长度 $L = 22\\,\\mathrm{nm}$，零漏极偏压阈值 $V_{\\mathrm{t0}} = 0.38\\,\\mathrm{V}$，数据生成器中具有强 DIBL。漏极偏压 $V_{\\mathrm{ds}} \\in \\{0.50, 0.80, 1.00\\}\\,\\mathrm{V}$。\n- 器件 D（长沟道，高阈值）：宽度 $W = 2.0\\,\\mu\\mathrm{m}$，长度 $L = 130\\,\\mathrm{nm}$，零漏极偏压阈值 $V_{\\mathrm{t0}} = 0.52\\,\\mathrm{V}$，数据生成器中具有弱 DIBL。漏极偏压 $V_{\\mathrm{ds}} \\in \\{0.50, 0.80, 1.00\\}\\,\\mathrm{V}$。\n\n仅为数据生成目的，在内部，$V_{\\mathrm{t,eff}}$ 对 $V_{\\mathrm{ds}}$ 的线性依赖关系通过以下特定于器件的 DIBL 斜率绝对值来实例化（估算器无法直接获取）：器件 A 使用 $0.06$，器件 B 使用 $0.16$，器件 C 使用 $0.28$，器件 D 使用 $0.03$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含设备 A、B、C、D 的估算 DIBL 系数，形式为用方括号括起来的逗号分隔列表，每个系数都四舍五入到小数点后六位，例如 $\\left[\\dots\\right]$。\n\n您的任务是编写一个完整、可运行的程序，执行上述步骤并以精确的格式打印最终结果：一行列表，无附加文本。",
            "solution": "所提出的问题是有效的。它在科学上基于半导体器件物理学的原理，特别是 MOSFET 在亚阈值区的操作以及像漏致势垒降低（DIBL）这样的短沟道效应的建模。该问题提法明确，提供了清晰的目标、一套完整的数据和参数，以及一个精确定义的参数提取方法。它代表了电子设计自动化（EDA）领域内器件表征和建模的标准任务。\n\n解决方案分两部分进行。首先，根据要求对 DIBL 现象及其线性近似进行定性解释。其次，概述解决该问题的详细计算算法。\n\n**漏致势垒降低 (DIBL) 的定性模型**\n\n在金属-氧化物-半导体场效应晶体管 (MOSFET) 中，源极和漏极端子之间的电流流动由栅源电压 $V_{\\mathrm{gs}}$ 建立的电场控制。该电压调制了半导体沟道中分隔源极和漏极的势垒高度。阈值电压 $V_{\\mathrm{t}}$ 定义为栅极电压，当栅极电压达到该值时，势垒被充分降低，以允许显著的漏极电流 $I_{\\mathrm{d}}$ 流通。\n\n在理想的长沟道晶体管中，沟道电位几乎完全由栅极控制。然而，在现代短沟道器件中，源区和漏区的物理接近意味着漏极电位也对沟道产生显著影响。漏极相对于源极被偏置在正电位（对于 n 沟道 MOSFET，$V_{\\mathrm{ds}}  0$），产生一个渗透到沟道区域的电场。来自漏极的这个电场提供了另一种降低阻碍电子从源极流动的势垒的机制。\n\n随着漏源电压 $V_{\\mathrm{ds}}$ 的增加，漏极电场的影响变得更强，导致势垒高度进一步降低。这种现象被称为漏致势垒降低 (DIBL)。因为漏极电压辅助栅极降低势垒，所以需要较小的栅极电压来感应相同水平的沟道电导率。因此，观察到有效阈值电压 $V_{\\mathrm{t,eff}}$ 随着 $V_{\\mathrm{ds}}$ 的增加而减小。\n\n对于适度的 $V_{\\mathrm{ds}}$ 范围，复杂的二维静电相互作用可以有效地通过 $V_{\\mathrm{t,eff}}$ 关于 $V_{\\mathrm{ds}}$ 的一阶泰勒级数展开来近似。这证明了构建一个线性模型的合理性：\n$$\nV_{\\mathrm{t,eff}}(V_{\\mathrm{ds}}) = V_{\\mathrm{t0}} - \\lambda V_{\\mathrm{ds}}\n$$\n在这里，$V_{\\mathrm{t0}}$ 代表零漏极偏压（$V_{\\mathrm{ds}} = 0\\,\\mathrm{V}$）下的阈值电压，$\\lambda$ 是 DIBL 系数，一个表示 DIBL 效应强度的正无量纲参数。该系数正式定义为阈值电压相对于漏极电压变化的负速率：\n$$\n\\lambda = - \\frac{\\partial V_{\\mathrm{t,eff}}}{\\partial V_{\\mathrm{ds}}}\n$$\n较大的 $\\lambda$ 值表示更严重的 DIBL 效应，这是短沟道器件中的一个关键挑战，因为它会导致关态漏电流增加。\n\n**DIBL 系数提取的算法流程**\n\n将按照问题陈述中指定的精确数值程序来估算每个器件的 DIBL 系数。步骤如下：\n\n1.  **初始化**：定义物理常数：玻尔兹曼常数 $k = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$，元电荷 $q = 1.602176634 \\times 10^{-19}\\,\\mathrm{C}$，以及温度 $T = 300\\,\\mathrm{K}$。计算热电压 $V_T = kT/q$。定义模型参数：亚阈值斜率因子 $n = 1.40$。\n\n2.  **数据生成**：对于每个器件（A、B、C、D）和每个指定的漏极偏压 $V_{\\mathrm{ds}}$：\n    a. 确定恒流法的参考电流 $I_{\\mathrm{ref}}$：$I_{\\mathrm{ref}} = I_{\\mathrm{ref}}^{(\\mu\\mathrm{m})} \\cdot W_{\\mu\\mathrm{m}}$，其中 $I_{\\mathrm{ref}}^{(\\mu\\mathrm{m})} = 1.0\\times 10^{-7}\\,\\mathrm{A}/\\mu\\mathrm{m}$，$W_{\\mu\\mathrm{m}}$ 是以微米为单位的器件宽度。\n    b. 使用提供的线性模型和特定于器件的参数计算“真实”的有效阈值电压 $V_{\\mathrm{t,eff,true}}$：$V_{\\mathrm{t,eff,true}} = V_{\\mathrm{t0}} - \\lambda_{\\text{true}} V_{\\mathrm{ds}}$。\n    c. 使用亚阈值电流公式，为从 $0.00\\,\\mathrm{V}$ 到 $0.80\\,\\mathrm{V}$，步长为 $0.01\\,\\mathrm{V}$ 的离散 $V_{\\mathrm{gs}}$ 扫描生成“测量”的漏极电流数据 $I_{\\mathrm{d}}(V_{\\mathrm{gs}})$：\n       $$\n       I_{\\mathrm{d}}(V_{\\mathrm{gs}}) = I_{\\mathrm{ref}} \\cdot \\exp\\left(\\frac{V_{\\mathrm{gs}} - V_{\\mathrm{t,eff,true}}}{n V_T}\\right)\n       $$\n\n3.  **阈值电压提取**：对于每个生成的 $I_{\\mathrm{d}}-V_{\\mathrm{gs}}$ 曲线（对应于特定的器件和 $V_{\\mathrm{ds}}$）：\n    a. 任务是找到使 $I_{\\mathrm{d}} = I_{\\mathrm{ref}}$ 的 $V_{\\mathrm{gs}}$ 值。问题指定在半对数域中使用线性插值，即，将 $V_{\\mathrm{gs}}$ 视为 $\\ln(I_{\\mathrm{d}})$ 的线性函数。\n    b. 根据数据生成公式，可以反解出 $V_{\\mathrm{gs}} = V_{\\mathrm{t,eff,true}} + n V_T \\ln(I_{\\mathrm{d}}/I_{\\mathrm{ref}})$。这证实了 $V_{\\mathrm{gs}}$ 与 $\\ln(I_{\\mathrm{d}})$ 是完全线性的。\n    c. 因此，我们可以使用标准的一维线性插值函数来找到对应于 $\\ln(I_{\\mathrm{d}}) = \\ln(I_{\\mathrm{ref}})$ 的 $V_{\\mathrm{gs}}$ 值。设离散数据点为 $(V_{\\mathrm{gs},i}, \\ln(I_{\\mathrm{d},i}))$。插值函数将在连接包围 $\\ln(I_{\\mathrm{ref}})$ 的两个点的线段上找到 $V_{\\mathrm{gs}}$ 值。由于基础模型的完全线性，这个数值上提取的阈值电压 $V_{\\mathrm{t,ext}}$ 将完全等于 $V_{\\mathrm{t,eff,true}}$。\n    d. 为每个漏极偏压存储提取的配对 $(V_{\\mathrm{ds}}, V_{\\mathrm{t,ext}})$。\n\n4.  **线性回归与 DIBL 系数计算**：在为单个器件计算完所有指定的 $V_{\\mathrm{ds}}$ 值的 $V_{\\mathrm{t,ext}}$ 后，我们将得到一组点 $(V_{\\mathrm{ds},j}, V_{\\mathrm{t,ext},j})$。\n    a. 对这些点执行最小二乘线性回归，以拟合模型 $V_{\\mathrm{t,ext}} = a + b V_{\\mathrm{ds}}$。斜率参数为 $b$。\n    b. 估算的 DIBL 系数 $\\lambda_{\\text{est}}$ 是斜率的绝对值：$\\lambda_{\\text{est}} = |b|$。由于 $V_{\\mathrm{t,ext}}$ 随 $V_{\\mathrm{ds}}$ 减小，斜率 $b$ 将为负，因此 $\\lambda_{\\text{est}} = -b$。\n    c. 因为用于回归的数据点本身是由一个完美的线性模型生成的，回归将以高精度恢复斜率 $\\lambda_{\\text{true}}$，仅受浮点运算精度的限制。\n\n5.  **最终输出**：收集所有四个器件的估算 DIBL 系数，将每个系数四舍五入到六位小数，并将其格式化为指定的字符串格式 `[a,b,c,d]`。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and validates a first-order DIBL model and estimates the DIBL\n    coefficient from simulated current-voltage data for multiple MOSFETs.\n    \"\"\"\n    \n    # Define physical constants and simulation settings\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n    q_e = 1.602176634e-19 # Elementary charge in C\n    T = 300.0  # Temperature in K\n    n_factor = 1.40  # Subthreshold slope factor (dimensionless)\n    I_ref_per_um = 1.0e-7  # Reference current per unit width in A/µm\n\n    # Calculate thermal voltage\n    V_T = k_B * T / q_e\n\n    # Define the test cases from the problem statement.\n    # The 'dibl_true' key holds the parameter used for data generation.\n    test_cases = [\n        {\n            \"name\": \"Device A\", \n            \"W_um\": 1.0, \"L_nm\": 90, \"Vt0\": 0.45, \"dibl_true\": 0.06, \n            \"Vds_points\": [0.50, 0.80, 1.00]\n        },\n        {\n            \"name\": \"Device B\", \n            \"W_um\": 1.0, \"L_nm\": 45, \"Vt0\": 0.42, \"dibl_true\": 0.16, \n            \"Vds_points\": [0.50, 0.80, 1.00]\n        },\n        {\n            \"name\": \"Device C\", \n            \"W_um\": 0.5, \"L_nm\": 22, \"Vt0\": 0.38, \"dibl_true\": 0.28, \n            \"Vds_points\": [0.50, 0.80, 1.00]\n        },\n        {\n            \"name\": \"Device D\", \n            \"W_um\": 2.0, \"L_nm\": 130, \"Vt0\": 0.52, \"dibl_true\": 0.03, \n            \"Vds_points\": [0.50, 0.80, 1.00]\n        },\n    ]\n\n    # Vgs sweep range as per problem statement\n    v_gs_sweep = np.arange(0.00, 0.80 + 1e-9, 0.01)\n\n    estimated_dibl_coeffs = []\n\n    for device in test_cases:\n        # Unpack device parameters\n        W_um = device[\"W_um\"]\n        Vt0 = device[\"Vt0\"]\n        dibl_true = device[\"dibl_true\"]\n        vds_points = np.array(device[\"Vds_points\"])\n        \n        # Calculate the reference current for this device\n        I_ref = I_ref_per_um * W_um\n        \n        extracted_vt_points = []\n\n        # Iterate through each Vds point to extract the effective threshold voltage\n        for vds in vds_points:\n            # Step 1: Generate synthetic I-V data for the current Vds.\n            # The 'true' effective threshold voltage used for data generation.\n            vt_eff_true = Vt0 - dibl_true * vds\n            \n            # Generate the drain current sweep using the provided anaytical model.\n            id_sweep = I_ref * np.exp((v_gs_sweep - vt_eff_true) / (n_factor * V_T))\n            \n            # Step 2: Extract Vt_eff using the constant-current method with interpolation.\n            # We need to find the Vgs at which Id equals I_ref.\n            # This is done by linear interpolation of Vgs as a function of log(Id).\n            \n            # Take the natural log of the current sweep.\n            log_id_sweep = np.log(id_sweep)\n            \n            # The target log-current value for interpolation.\n            log_I_ref_target = np.log(I_ref)\n            \n            # `np.interp` performs linear interpolation. It finds the `y` value for a new `x`\n            # given existing `(x_pts, y_pts)`.\n            # Here, x is log_id and y is Vgs.\n            # We want to find Vgs (y) for `log_I_ref_target` (x).\n            # The `log_id_sweep` array is guaranteed to be monotonically increasing\n            # because `id_sweep` is exponential in `v_gs_sweep`.\n            vt_extracted = np.interp(log_I_ref_target, log_id_sweep, v_gs_sweep)\n            \n            extracted_vt_points.append(vt_extracted)\n        \n        # Step 3: Perform linear regression on the extracted (Vds, Vt) points.\n        # We fit a line Vt_extracted = intercept + slope * Vds.\n        # The `polyfit` function with degree 1 is used for least-squares regression.\n        # It returns coefficients [slope, intercept].\n        slope, _ = np.polyfit(vds_points, np.array(extracted_vt_points), 1)\n        \n        # The DIBL coefficient is the magnitude of the slope. Since the slope is\n        # negative, this is equivalent to -slope.\n        dibl_estimated = -slope\n        estimated_dibl_coeffs.append(dibl_estimated)\n\n    # Format the results for the final output.\n    # Each coefficient must be rounded to six decimal places.\n    formatted_results = [f\"{coef:.6f}\" for coef in estimated_dibl_coeffs]\n    \n    # The final print statement must be in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了器件物理和建模方法后，我们便可以将这些知识应用于更高层级的电路优化。本练习模拟了一个真实的电子设计自动化（EDA）优化任务，即利用不同阈值电压（$V_t$）在速度和漏电之间的权衡。您需要从标准单元库的采样数据中校准性能和功耗模型，并实现一个贪心算法，在满足严格时序预算的前提下最小化总漏电，从而展示多阈值电压（multi-$V_t$）设计的实际应用价值。",
            "id": "4278869",
            "problem": "给定低阈值电压（LVT）和高阈值电压（HVT）标准单元的 Liberty 格式表征样本。任务是校准适用于电子设计自动化（EDA）中大规模优化的时序和漏电模型。低阈值电压（LVT）和高阈值电压（HVT）指的是具有不同阈值电压的器件类型，它们在速度和漏电之间进行权衡。您必须基于物理上合理的近似和凸建模，推导出延迟作为负载函数的分段凸近似模型，以及漏电作为单元宽度的线性模型。然后，使用这些模型，通过一种高效的方法在全局延迟预算下解决漏电最小化问题。\n\n基本原理和既定事实：在标准单元设计中，对于固定的阈值电压类别和工作条件，亚阈值漏电流大致与器件宽度成正比，且阈值电压越低，漏电流越高。由于阻容效应，互连和输出负载会单调增加延迟，这在实际范围内可以很好地用负载的凸函数来近似。您必须从这些广泛接受的事实出发，并根据数据校准模型。\n\n校准输入（单一输入转换率下的类 Liberty 样本点）：\n- 对于延迟，为两种器件类型提供了以下负载点（单位：飞法）和测量延迟（单位：皮秒）：\n  - LVT 延迟样本：负载 $[2,5,10,20,40]$，延迟 $[12,15,19,27,45]$。\n  - HVT 延迟样本：负载 $[2,5,10,20,40]$，延迟 $[16,20,26,36,60]$。\n- 在标称工艺角下，漏电与宽度的关系（宽度单位：微米，漏电单位：纳安）：\n  - LVT 漏电样本：宽度 $[1,2,3,4,6]$，漏电流 $[9.5,19.8,30.1,39.6,59.4]$。\n  - HVT 漏电样本：宽度 $[1,2,3,4,6]$，漏电流 $[3.8,7.9,11.6,15.4,22.9]$。\n\n模型要求：\n1) 对每种阈值类型 $T \\in \\{\\mathrm{LVT}, \\mathrm{HVT}\\}$，拟合一个关于负载 $C$ 的凸分段线性延迟近似函数 $\\hat d^{(T)}(C)$。拟合过程需在给定负载样本点上最小化平方误差，并满足分段斜率非递减的约束。必须通过连续负载区间之间斜率非递减来强制实现凸性。拟合后的函数必须能够通过在凸分段结构内进行线性插值，以及使用端点斜率在样本范围外进行线性外插，来对任意 $C$ 进行求值。所有负载单位为飞法，所有延迟单位必须为皮秒。\n\n2) 对每种阈值类型，通过最小二乘法拟合一个线性漏电模型 $I^{(T)}(w) \\approx k_T \\cdot w$，其中 $w$ 是宽度（单位：微米），漏电是（单位：纳安）。只需通过您的求解逻辑报告拟合出的系数 $k_T$；程序将在内部使用它。\n\n优化任务：\n给定一个由 $N$ 个实例组成的设计模块，实例索引为 $i$，每个实例具有已知的输出负载 $C_i$（单位：飞法）和宽度 $w_i$（单位：微米）。您必须为每个实例决定是使用 LVT 还是 HVT，以在满足全局总延迟预算的前提下最小化总漏电。总漏电为 $\\sum_i I^{(x_i)}(w_i)$，总延迟为 $\\sum_i \\hat d^{(x_i)}(C_i)$，其中选择 $x_i \\in \\{\\mathrm{LVT}, \\mathrm{HVT}\\}$。使用您的分段凸延迟模型和线性漏电模型，推导其连续松弛形式并高效求解，然后舍入为离散分配。程序应实现以下松弛：令 $r_i \\in [0,1]$ 表示实例 $i$ 选择 LVT 的比例，其中 $r_i = 1$ 表示 LVT，$r_i = 0$ 表示 HVT。约束变为 $\\sum_i r_i \\cdot \\Delta d_i \\ge S$，其中 $\\Delta d_i = \\hat d^{(\\mathrm{HVT})}(C_i) - \\hat d^{(\\mathrm{LVT})}(C_i)$，$S = \\sum_i \\hat d^{(\\mathrm{HVT})}(C_i) - D_{\\text{target}}$；目标是最小化 $\\sum_i r_i \\cdot \\Delta I_i$，其中 $\\Delta I_i = (k_{\\mathrm{LVT}} - k_{\\mathrm{HVT}}) \\cdot w_i$。实现基于比率法则的连续松弛最优贪婪选择算法，然后通过将选定的实例设置为 LVT 直到满足延迟要求，其余实例设置为 HVT，来生成离散分配。\n\n测试套件：\n您的程序必须使用以下三个实例和预算的测试用例。所有延迟单位为皮秒，负载单位为飞法，宽度单位为微米，漏电单位为纳安。\n\n- 测试用例 1：实例负载为 $[5,10,15,25]$，宽度为 $[2,3,2,4]$，延迟预算 $D_{\\text{target}} = 100$。这是一个典型情况，预算比全 HVT 配置更紧，但比全 LVT 配置更松。\n\n- 测试用例 2：与测试用例 1 相同的实例，但延迟预算 $D_{\\text{target}}$ 设置为根据您校准的 LVT 延迟模型计算出的 $\\sum_i \\hat d^{(\\mathrm{LVT})}(C_i)$。如果凸拟合是一致的，这个边界情况应该会推动选择趋向于全 LVT 配置。\n\n- 测试用例 3：与测试用例 1 相同的实例，但延迟预算 $D_{\\text{target}} = \\sum_i \\hat d^{(\\mathrm{HVT})}(C_i) + 6$。这个边界情况应该允许全 HVT 配置，因为预算比全 HVT 配置的总和更松。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含三个测试用例的结果，格式为方括号括起来的逗号分隔列表。每个测试用例的结果必须是一个整数列表，其长度与实例数量相等，其中 $1$ 表示为该实例选择 LVT，$0$ 表示选择 HVT。例如，您的程序必须打印形如 $[[a_1,a_2,\\dots],[b_1,b_2,\\dots],[c_1,c_2,\\dots]]$ 的输出，只使用整数、方括号和逗号，不包含任何额外文本。最终输出不包含单位，因为输出是离散选择。",
            "solution": "该问题需要一个多步骤过程：首先，根据提供的低阈值电压（LVT）和高阈值电压（HVT）器件的样本数据，校准单元延迟和漏电功率模型；其次，使用这些模型解决电路优化问题。优化目标是通过为给定数字逻辑块中的每个单元选择合适的器件类型（LVT或HVT），在满足最大总路径延迟约束的前提下，最小化总漏电功率。解决方案的开发将首先建立物理模型，然后构建优化问题，最后描述解决该问题的算法。\n\n### 步骤 1：模型校准\n\n#### 漏电功率模型\n问题指出，对于固定的阈值电压，亚阈值漏电流约与器件宽度成正比。这种关系被建模为一个通过原点的线性函数：\n$$\nI^{(T)}(w) = k_T \\cdot w\n$$\n其中，$I^{(T)}$ 是阈值类型 $T \\in \\{\\text{LVT}, \\text{HVT}\\}$ 的漏电流，$w$ 是单元宽度，$k_T$ 是该阈值类型的漏电系数。给定一组样本点 $(w_j, I_j)$，系数 $k_T$ 通过约束为通过原点的线性最小二乘回归来确定。最小化平方误差和的公式是：\n$$\nk_T = \\frac{\\sum_{j} w_j I_j}{\\sum_{j} w_j^2}\n$$\n使用所提供的数据：\n-   LVT 漏电样本：宽度 $w = [1, 2, 3, 4, 6] \\, \\mu\\text{m}$，漏电流 $I_{\\text{LVT}} = [9.5, 19.8, 30.1, 39.6, 59.4] \\, \\text{nA}$。\n-   HVT 漏电样本：宽度 $w = [1, 2, 3, 4, 6] \\, \\mu\\text{m}$，漏电流 $I_{\\text{HVT}} = [3.8, 7.9, 11.6, 15.4, 22.9] \\, \\text{nA}$。\n\n对于 LVT 和 HVT，宽度平方和为 $\\sum w_j^2 = 1^2 + 2^2 + 3^2 + 4^2 + 6^2 = 1 + 4 + 9 + 16 + 36 = 66 \\, (\\mu\\text{m})^2$。\n\n对于 LVT，乘积之和为 $\\sum w_j I_j = 1(9.5) + 2(19.8) + 3(30.1) + 4(39.6) + 6(59.4) = 654.2 \\, \\text{nA}\\cdot\\mu\\text{m}$。\n因此，LVT 漏电系数为 $k_{\\text{LVT}} = \\frac{654.2}{66} \\approx 9.9121 \\, \\text{nA}/\\mu\\text{m}$。\n\n对于 HVT，乘积之和为 $\\sum w_j I_j = 1(3.8) + 2(7.9) + 3(11.6) + 4(15.4) + 6(22.9) = 253.4 \\, \\text{nA}\\cdot\\mu\\text{m}$。\n因此，HVT 漏电系数为 $k_{\\text{HVT}} = \\frac{253.4}{66} \\approx 3.8394 \\, \\text{nA}/\\mu\\text{m}$。\n\n当一个宽度为 $w_i$ 的单元从 HVT 切换到 LVT 时，漏电的增加量为 $\\Delta I_i = (k_{\\text{LVT}} - k_{\\text{HVT}}) \\cdot w_i$。\n\n#### 单元延迟模型\n标准单元的延迟是其输出端电容负载 $C$ 的函数。问题要求将一个凸分段线性函数 $\\hat{d}^{(T)}(C)$ 拟合到提供的延迟样本 $(C_j, d_j)$。该函数由其在给定样本负载 $C_j$ 处的值 $\\hat{d}_j$ 定义。拟合过程旨在找到一组值 $\\{\\hat{d}_1, \\hat{d}_2, \\ldots, \\hat{d}_n\\}$，以最小化相对于测量延迟 $\\{d_1, d_2, \\ldots, d_n\\}$ 的平方误差和，同时满足凸性约束。\n\n目标是最小化：\n$$\n\\text{Error} = \\sum_{j=1}^{n} (d_j - \\hat{d}_j)^2\n$$\n对于分段线性函数，凸性约束是连续线段的斜率必须非递减。对于负载点 $(C_j, \\hat{d}_j)$、$(C_{j+1}, \\hat{d}_{j+1})$ 和 $(C_{j+1}, \\hat{d}_{j+1})$、$(C_{j+2}, \\hat{d}_{j+2})$ 之间的线段，约束为：\n$$\ns_j \\le s_{j+1} \\implies \\frac{\\hat{d}_{j+1} - \\hat{d}_j}{C_{j+1} - C_j} \\le \\frac{\\hat{d}_{j+2} - \\hat{d}_{j+1}}{C_{j+2} - C_{j+1}}\n$$\n此外，物理真实性要求延迟函数是单调非递减的，因此对所有 $j$ 都有 $\\hat{d}_{j+1} \\ge \\hat{d}_j$。这组约束可以表述为一个线性不等式系统。整个问题是一个二次规划（QP）问题，可以进行数值求解。\n\n一旦找到了样本负载 $\\mathbf{C}$ 对应的拟合延迟值 $\\hat{\\mathbf{d}}^{(T)}$，就可以通过在范围 $[\\min(\\mathbf{C}), \\max(\\mathbf{C})]$ 内进行线性插值，以及在此范围外使用第一段和最后一段的斜率进行线性外插，来计算任意负载 $C_{\\text{new}}$ 的延迟。\n\n### 步骤 2：优化公式和算法\n\n任务是为 $N$ 个单元实例中的每一个选择阈值电压类型 $x_i \\in \\{\\text{LVT}, \\text{HVT}\\}$，以最小化总漏电功率，同时将总延迟保持在预算 $D_{\\text{target}}$ 之内。\n-   **目标**：最小化 $L_{\\text{total}} = \\sum_{i=1}^{N} I^{(x_i)}(w_i) = \\sum_{i=1}^{N} k_{x_i} \\cdot w_i$\n-   **约束**：$D_{\\text{total}} = \\sum_{i=1}^{N} \\hat{d}^{(x_i)}(C_i) \\le D_{\\text{target}}$\n\n这是 0/1 背包问题的一个变体。问题陈述指导我们使用贪婪方法来解决其连续松弛问题。我们从具有最小可能漏电的配置开始：所有单元均为 HVT。此配置的总延迟为 $D_{\\text{all-HVT}} = \\sum_{i=1}^{N} \\hat{d}^{(\\text{HVT})}(C_i)$。\n\n如果 $D_{\\text{all-HVT}} \\le D_{\\text{target}}$，这就是最优解，因为它在满足时序约束的同时具有最低的可能漏电。\n\n如果 $D_{\\text{all-HVT}}  D_{\\text{target}}$，我们必须将一些单元从 HVT 替换为更快但漏电更大的 LVT，以满足延迟预算。每次将单元 $i$ 从 HVT 替换为 LVT，会带来 $\\Delta d_i = \\hat{d}^{(\\text{HVT})}(C_i) - \\hat{d}^{(\\text{LVT})}(C_i)$ 的延迟节省，代价是 $\\Delta I_i = I^{(\\text{LVT})}(w_i) - I^{(\\text{HVT})}(w_i) = (k_{\\text{LVT}} - k_{\\text{HVT}})w_i$ 的漏电惩罚。\n\n为了最高效地执行替换，我们应该优先考虑那些每单位漏电增加能提供最大延迟减少的单元。这导出了一个基于效率比的贪婪策略：\n$$\n\\rho_i = \\frac{\\Delta d_i}{\\Delta I_i}\n$$\n算法如下：\n1.  校准漏电模型以找到 $k_{\\text{LVT}}$ 和 $k_{\\text{HVT}}$。\n2.  校准延迟模型以创建求值函数 $\\hat{d}^{(\\text{LVT})}(C)$ 和 $\\hat{d}^{(\\text{HVT})}(C)$。\n3.  对于给定的测试用例（实例负载 $C_i$、宽度 $w_i$ 和预算 $D_{\\text{target}}$）：\n    a. 初始化解决方案，将所有单元设为 HVT（例如，一个全为 $0$ 的选择向量）。\n    b. 计算初始总延迟 $D_{\\text{current}} = \\sum_i \\hat{d}^{(\\text{HVT})}(C_i)$。\n    c. 对每个单元 $i$，计算从 HVT 替换为 LVT 的潜在延迟节省 $\\Delta d_i$ 和漏电惩罚 $\\Delta I_i$，以及它们的比率 $\\rho_i$。\n    d. 创建一个单元索引列表，按其效率比 $\\rho_i$ 的降序排列。\n    e. 遍历排序后的单元列表。对于排序列表中的每个单元 $j$：\n        i. 如果 $D_{\\text{current}}  D_{\\text{target}}$，则将单元 $j$ 替换为 LVT。\n        ii. 更新总延迟：$D_{\\text{current}} \\leftarrow D_{\\text{current}} - \\Delta d_j$。\n        iii. 更新单元 $j$ 的选择向量以表示 LVT（例如，设置为 $1$）。\n    f. 最终的选择向量即为该测试用例的解。\n\n这个贪婪算法为问题的连续松弛（其中可以替换单元的一部分）提供了最优解，并且是离散 0/1 问题的标准有效启发式方法。实现将遵循此逻辑来处理三个提供的测试用例。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate model calibration and optimization.\n    \"\"\"\n\n    # --- Step 1: Data Definition ---\n    # Calibration inputs for LVT and HVT standard cells\n    lvt_delay_samples = {'loads': np.array([2, 5, 10, 20, 40]), 'delays': np.array([12, 15, 19, 27, 45])}\n    hvt_delay_samples = {'loads': np.array([2, 5, 10, 20, 40]), 'delays': np.array([16, 20, 26, 36, 60])}\n    \n    lvt_leakage_samples = {'widths': np.array([1, 2, 3, 4, 6]), 'currents': np.array([9.5, 19.8, 30.1, 39.6, 59.4])}\n    hvt_leakage_samples = {'widths': np.array([1, 2, 3, 4, 6]), 'currents': np.array([3.8, 7.9, 11.6, 15.4, 22.9])}\n\n    # Test suite: lists of (loads, widths, delay_budget)\n    test_cases_defs = [\n        {'loads': np.array([5, 10, 15, 25]), 'widths': np.array([2, 3, 2, 4]), 'budget': 100},\n        {'loads': np.array([5, 10, 15, 25]), 'widths': np.array([2, 3, 2, 4]), 'budget': None}, # T2, budget to be calculated\n        {'loads': np.array([5, 10, 15, 25]), 'widths': np.array([2, 3, 2, 4]), 'budget': None}, # T3, budget to be calculated\n    ]\n\n    # --- Step 2: Model Calibration ---\n    \n    def calibrate_leakage(widths, currents):\n        \"\"\"Fits a linear model I = k*w through the origin via least squares.\"\"\"\n        k = np.sum(widths * currents) / np.sum(widths**2)\n        return k\n\n    k_lvt = calibrate_leakage(lvt_leakage_samples['widths'], lvt_leakage_samples['currents'])\n    k_hvt = calibrate_leakage(hvt_leakage_samples['widths'], hvt_leakage_samples['currents'])\n\n    def calibrate_delay(loads, delays):\n        \"\"\"\n        Fits a convex, piecewise-linear delay model using Quadratic Programming.\n        The variables are the fitted delay values at the sample load points.\n        \"\"\"\n        n_points = len(loads)\n        \n        # Objective function: minimize sum of squared errors\n        def objective(d_hat):\n            return np.sum((delays - d_hat)**2)\n\n        # Constraints for convexity (non-decreasing slopes) and monotonicity\n        constraints = []\n        # Monotonicity: d_hat[j] = d_hat[j-1]\n        for j in range(1, n_points):\n            constraints.append({'type': 'ineq', 'fun': lambda d_hat, j=j: d_hat[j] - d_hat[j-1]})\n        \n        # Convexity: slope[j] = slope[j-1]\n        for j in range(n_points - 2):\n            c_j, c_jp1, c_jp2 = loads[j], loads[j+1], loads[j+2]\n            # (d_jp2 - d_jp1)/(c_jp2 - c_jp1) - (d_jp1 - d_j)/(c_jp1 - c_j) = 0\n            # This is a linear inequality in terms of d_hat variables\n            fun = (lambda d_hat, j=j, c_j=c_j, c_jp1=c_jp1, c_jp2=c_jp2: \n                     (d_hat[j+2] - d_hat[j+1]) / (c_jp2 - c_jp1) - \n                     (d_hat[j+1] - d_hat[j]) / (c_jp1 - c_j))\n            constraints.append({'type': 'ineq', 'fun': fun})\n\n        # Initial guess for the optimizer\n        d0 = delays.copy()\n        \n        result = minimize(objective, d0, method='SLSQP', constraints=constraints)\n        \n        if not result.success:\n            raise RuntimeError(f\"Delay model calibration failed: {result.message}\")\n        \n        return result.x\n\n    fitted_delays_lvt = calibrate_delay(lvt_delay_samples['loads'], lvt_delay_samples['delays'])\n    fitted_delays_hvt = calibrate_delay(hvt_delay_samples['loads'], hvt_delay_samples['delays'])\n\n    def evaluate_pwl_delay(C, sample_loads, fitted_delays):\n        \"\"\"Evaluates the piecewise-linear delay model for a given load C.\"\"\"\n        if C  sample_loads[0]:\n            slope = (fitted_delays[1] - fitted_delays[0]) / (sample_loads[1] - sample_loads[0])\n            return fitted_delays[0] - slope * (sample_loads[0] - C)\n        elif C  sample_loads[-1]:\n            slope = (fitted_delays[-1] - fitted_delays[-2]) / (sample_loads[-1] - sample_loads[-2])\n            return fitted_delays[-1] + slope * (C - sample_loads[-1])\n        else:\n            return np.interp(C, sample_loads, fitted_delays)\n\n    # Vectorized evaluation for efficiency\n    vec_eval_lvt = np.vectorize(lambda c: evaluate_pwl_delay(c, lvt_delay_samples['loads'], fitted_delays_lvt))\n    vec_eval_hvt = np.vectorize(lambda c: evaluate_pwl_delay(c, hvt_delay_samples['loads'], fitted_delays_hvt))\n    \n    # --- Step 3: Complete Test Case Definitions ---\n    \n    # Calculate delays for all instances to set budgets for T2 and T3\n    all_instance_loads = test_cases_defs[0]['loads']\n    all_instance_delays_lvt = vec_eval_lvt(all_instance_loads)\n    all_instance_delays_hvt = vec_eval_hvt(all_instance_loads)\n    \n    total_delay_lvt = np.sum(all_instance_delays_lvt)\n    total_delay_hvt = np.sum(all_instance_delays_hvt)\n    \n    test_cases_defs[1]['budget'] = total_delay_lvt\n    test_cases_defs[2]['budget'] = total_delay_hvt + 6\n\n    # --- Step 4: Run Optimization for each Test Case ---\n    \n    results = []\n    for case in test_cases_defs:\n        loads = case['loads']\n        widths = case['widths']\n        d_target = case['budget']\n        num_instances = len(loads)\n        \n        # Calculate delays for each instance using the calibrated models\n        d_lvt = all_instance_delays_lvt\n        d_hvt = all_instance_delays_hvt\n        \n        # Calculate delay savings and leakage penalties\n        delta_d = d_hvt - d_lvt\n        delta_I = (k_lvt - k_hvt) * widths\n        \n        # Avoid division by zero if delta_I is zero for some reason\n        # (not expected here, but good practice).\n        # A small epsilon is added to the denominator.\n        efficiency_ratio = delta_d / (delta_I + 1e-12)\n        \n        # Sort instance indices by efficiency ratio in descending order\n        sorted_indices = np.argsort(efficiency_ratio)[::-1]\n        \n        # Start with all HVT solution\n        selection = np.zeros(num_instances, dtype=int)\n        current_delay = total_delay_hvt\n        \n        # Greedily swap to LVT to meet timing\n        if current_delay  d_target:\n            for idx in sorted_indices:\n                current_delay -= delta_d[idx]\n                selection[idx] = 1\n                if current_delay = d_target:\n                    break\n        \n        results.append(selection.tolist())\n\n    # --- Step 5: Final Output ---\n    # Format the output as [[a,b,...],[c,d,...],[e,f,...]]\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, res))}]' for res in results])}]\"\n    print(output_str)\n\nsolve()\n\n```"
        }
    ]
}