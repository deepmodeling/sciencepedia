{
    "hands_on_practices": [
        {
            "introduction": "At the heart of any power-gating strategy lies the sleep switch, a transistor that acts as a gatekeeper for the domain's power supply. Designing this switch involves a critical trade-off: it must be conductive enough to allow the domain to wake up quickly and operate correctly under load, yet not so large that it consumes excessive area and leakage power. This practice  challenges you to determine the optimal size of a sleep switch, represented by its on-resistance, by balancing the transient wake-up time against the steady-state voltage drop, using foundational circuit analysis techniques like Elmore delay.",
            "id": "4290469",
            "problem": "A power-gated Complementary Metal-Oxide-Semiconductor (CMOS) island in an Electronic Design Automation (EDA) context is supplied by the main rail at voltage $V_{\\text{DD}}$ through a header sleep switch whose on-state is modeled as a linear resistor $R_{\\text{sw}}$. The island’s virtual rail is distributed through two grid segments modeled as resistors $R_{1}$ and $R_{2}$ in series from the sleep switch toward deeper regions of the island. Three lumped decoupling capacitors are connected to the virtual rail at progressively deeper nodes: $C_{1}$ at the entry node immediately after the sleep switch, $C_{2}$ after the segment $R_{1}$, and $C_{3}$ after the segment $R_{2}$.\n\nUpon wake-up at time $t=0$, the sleep switch is enabled and the main rail steps from $0$ to $V_{\\text{DD}}$. The requirement is that the virtual rail reaches at least $V_{\\text{DD}}(1-\\epsilon)$ by time $t_{s}$, and in steady state the direct-current (DC) drop between the main rail and the virtual rail under the constant retention current $I_{\\text{ret}}$ must be no more than $\\epsilon V_{\\text{DD}}$. Model the transient settling of the virtual rail using the Elmore delay approximation for an $R\\!C$ tree, and model the steady-state drop using Ohm’s law.\n\nGiven the following parameters: $V_{\\text{DD}}=0.8$ V, $\\epsilon=0.01$, $t_{s}=10 \\times 10^{-9}$ s, $I_{\\text{ret}}=5 \\times 10^{-3}$ A, $R_{1}=0.02$ $\\Omega$, $R_{2}=0.03$ $\\Omega$, $C_{1}=10 \\times 10^{-9}$ F, $C_{2}=20 \\times 10^{-9}$ F, and $C_{3}=15 \\times 10^{-9}$ F, determine the maximum allowable sleep-switch resistance $R_{\\text{sw}}$ that simultaneously satisfies both the transient and DC requirements. Round your answer to four significant figures and express it in ohms.",
            "solution": "The virtual rail charging in an $R\\!C$ network can be approximated by a first-order response characterized by an effective time constant derived from the Elmore delay. For an $R\\!C$ tree excited by a step at the source, the Elmore delay $t_{E}$ to the root node is the first moment of the impulse response and is computed by summing, over each resistor, the product of that resistor and the total capacitance downstream of it. For the topology described, the resistors on the path from the source to the virtual rail are $R_{\\text{sw}}$, $R_{1}$, and $R_{2}$, and the downstream capacitances for each segment are:\n- For $R_{\\text{sw}}$: the downstream capacitance is $C_{1}+C_{2}+C_{3}$.\n- For $R_{1}$: the downstream capacitance is $C_{2}+C_{3}$.\n- For $R_{2}$: the downstream capacitance is $C_{3}$.\n\nThus, the Elmore delay is\n$$\nt_{E} \\;=\\; R_{\\text{sw}}\\,(C_{1}+C_{2}+C_{3}) \\;+\\; R_{1}\\,(C_{2}+C_{3}) \\;+\\; R_{2}\\,C_{3}.\n$$\nApproximating the virtual-rail step response as $v(t) = V_{\\text{DD}}\\bigl(1 - \\exp(-t/t_{E})\\bigr)$, the requirement $v(t_{s}) \\geq V_{\\text{DD}}(1-\\epsilon)$ becomes\n$$\n1 - \\exp\\!\\bigl(-t_{s}/t_{E}\\bigr) \\;\\geq\\; 1 - \\epsilon \\quad\\Longrightarrow\\quad \\exp\\!\\bigl(-t_{s}/t_{E}\\bigr) \\;\\leq\\; \\epsilon.\n$$\nTaking the natural logarithm,\n$$\n-\\frac{t_{s}}{t_{E}} \\;\\leq\\; \\ln(\\epsilon) \\quad\\Longrightarrow\\quad t_{E} \\;\\leq\\; \\frac{t_{s}}{\\ln(1/\\epsilon)}.\n$$\nSubstituting the Elmore expression and isolating $R_{\\text{sw}}$ gives the transient-settling bound\n$$\nR_{\\text{sw}} \\;\\leq\\; \\frac{\\dfrac{t_{s}}{\\ln(1/\\epsilon)} \\;-\\; R_{1}\\,(C_{2}+C_{3}) \\;-\\; R_{2}\\,C_{3}}{C_{1}+C_{2}+C_{3}}.\n$$\n\nSeparately, the steady-state DC drop between the main rail and the virtual rail under current $I_{\\text{ret}}$ is set by Ohm’s law. The total series resistance seen from the source to the virtual rail is $R_{\\text{sw}} + R_{1} + R_{2}$, so the drop is\n$$\nV_{\\text{drop,dc}} \\;=\\; I_{\\text{ret}}\\,(R_{\\text{sw}} + R_{1} + R_{2}).\n$$\nThe requirement $V_{\\text{drop,dc}} \\leq \\epsilon V_{\\text{DD}}$ yields the DC bound\n$$\nI_{\\text{ret}}\\,(R_{\\text{sw}} + R_{1} + R_{2}) \\;\\leq\\; \\epsilon V_{\\text{DD}}\n\\quad\\Longrightarrow\\quad\nR_{\\text{sw}} \\;\\leq\\; \\frac{\\epsilon V_{\\text{DD}}}{I_{\\text{ret}}} \\;-\\; (R_{1} + R_{2}).\n$$\n\nThe maximum allowable sleep-switch resistance is the minimum of the two bounds:\n$$\nR_{\\text{sw,max}} \\;=\\; \\min\\!\\left\\{\n\\frac{\\dfrac{t_{s}}{\\ln(1/\\epsilon)} \\;-\\; R_{1}\\,(C_{2}+C_{3}) \\;-\\; R_{2}\\,C_{3}}{C_{1}+C_{2}+C_{3}}\n\\;,\\;\n\\frac{\\epsilon V_{\\text{DD}}}{I_{\\text{ret}}} \\;-\\; (R_{1} + R_{2})\n\\right\\}.\n$$\n\nNow substitute the given numerical values. First compute the transient bound. The required time constant is\n$$\n\\frac{t_{s}}{\\ln(1/\\epsilon)} \\;=\\; \\frac{10 \\times 10^{-9}}{\\ln(100)} \\;\\approx\\; \\frac{10 \\times 10^{-9}}{4.605170186} \\;\\approx\\; 2.17147241 \\times 10^{-9}.\n$$\nThe constant Elmore contribution from $R_{1}$ and $R_{2}$ is\n$$\nR_{1}(C_{2}+C_{3}) \\;+\\; R_{2}C_{3}\n\\;=\\; 0.02\\,(20 \\times 10^{-9} + 15 \\times 10^{-9}) \\;+\\; 0.03\\,(15 \\times 10^{-9})\n$$\n$$\n=\\; 0.02 \\times 35 \\times 10^{-9} \\;+\\; 0.03 \\times 15 \\times 10^{-9}\n\\;=\\; 0.7 \\times 10^{-9} \\;+\\; 0.45 \\times 10^{-9}\n\\;=\\; 1.15 \\times 10^{-9}.\n$$\nThe total capacitance is\n$$\nC_{1}+C_{2}+C_{3} \\;=\\; (10 + 20 + 15) \\times 10^{-9} \\;=\\; 45 \\times 10^{-9}.\n$$\nTherefore the transient bound is\n$$\nR_{\\text{sw}} \\;\\leq\\; \\frac{2.17147241 \\times 10^{-9} \\;-\\; 1.15 \\times 10^{-9}}{45 \\times 10^{-9}}\n\\;=\\; \\frac{1.02147241 \\times 10^{-9}}{45 \\times 10^{-9}}\n\\;\\approx\\; 0.022699387.\n$$\n\nNext compute the DC bound:\n$$\n\\frac{\\epsilon V_{\\text{DD}}}{I_{\\text{ret}}} \\;-\\; (R_{1} + R_{2})\n\\;=\\; \\frac{0.01 \\times 0.8}{5 \\times 10^{-3}} \\;-\\; (0.02 + 0.03)\n\\;=\\; \\frac{0.008}{0.005} \\;-\\; 0.05\n\\;=\\; 1.6 \\;-\\; 0.05\n\\;=\\; 1.55.\n$$\n\nTaking the minimum,\n$$\nR_{\\text{sw,max}} \\;=\\; \\min\\{\\,0.022699387\\,,\\,1.55\\,\\} \\;=\\; 0.022699387.\n$$\nRounded to four significant figures and expressed in ohms, the maximum allowable sleep-switch resistance is $0.02270$.",
            "answer": "$$\\boxed{0.02270}$$"
        },
        {
            "introduction": "While power gating saves leakage energy, the processes of saving and restoring the circuit's state are not instantaneous and introduce latency overhead. This practice  moves from the circuit-level design of the switch to the architectural implications of state retention, asking you to analyze the performance of the control system that manages state-retention flip-flops. By calculating the total time required for a save and restore sequence based on bus bandwidth and protocol overheads, you will develop skills in system-level performance modeling and learn to evaluate whether a design meets its latency budget.",
            "id": "4290459",
            "problem": "A power-gated subsystem in an Electronic Design Automation (EDA) flow uses State Retention Flip-Flops (SRFFs) to preserve architectural state during sleep transitions. The SRFFs are controlled by an always-on retention control bus that delivers a save (capture) enable vector and, later, a restore (release) vector. The bus is $w$-bit wide and operates at an aggregate bit rate of $B$ bits per second. Due to time-division multiplexing across subsystems, this domain is allocated a fixed share $\\beta$ of the bus, so its effective bit rate is $\\beta B$. The protocol imposes a per-beat handshake overhead of $t_{p}$ seconds, which must be incurred for each $w$-bit beat transmitted. Each SRFF requires $t_{s}$ seconds from the arrival of its corresponding control bit to complete the local save (and similarly $t_{s}$ to complete the local restore); the control beats are scheduled sequentially, and each beat carries $w$ control bits that simultaneously trigger $w$ distinct SRFFs. The overall save (or restore) latency is defined by the time to deliver all beats plus the local time for the last SRFF to complete.\n\nAssume the subsystem contains $N$ SRFFs, with the following parameters:\n- $N = 3072$\n- $w = 96$ bits\n- $B = 2.4 \\times 10^{9}$ bits per second\n- $\\beta = 0.5$\n- $t_{p} = 2.5 \\times 10^{-9}$ seconds\n- $t_{s} = 3.2 \\times 10^{-9}$ seconds\n\nStarting from first principles of throughput and latency (for example, that transmitting $x$ bits over a channel of rate $R$ bits per second takes $x/R$ seconds), derive an expression for the total latency overhead $T_{\\text{total}}$ of a full save followed by a full restore, accounting for bus transmission and per-flip-flop local completion. Then evaluate $T_{\\text{total}}$ numerically. The system performance target specifies that a full save+restore sequence must complete within $T_{\\text{budget}} = 5.00$ microseconds. Determine, based on your computed $T_{\\text{total}}$, whether the performance target is met. Express the final latency $T_{\\text{total}}$ in microseconds and round your answer to four significant figures.",
            "solution": "The task is to derive an expression for the total latency overhead $T_{\\text{total}}$ of a full save-and-restore cycle and to determine if this latency meets the performance budget $T_{\\text{budget}}$.\n\nFirst, we establish the fundamental quantities based on the provided parameters.\n\nThe total number of SRFFs is $N = 3072$. The control bus is $w = 96$ bits wide, meaning it can trigger $w$ SRFFs simultaneously with each $w$-bit \"beat\" of data. The total number of beats required to control all $N$ SRFFs for one operation (either save or restore) is:\n$$N_{\\text{beats}} = \\frac{N}{w}$$\nSubstituting the given values:\n$$N_{\\text{beats}} = \\frac{3072}{96} = 32$$\n\nThe aggregate bit rate of the bus is $B = 2.4 \\times 10^{9}$ bits/s. The subsystem is allocated a share $\\beta = 0.5$, so the effective bit rate $R_{\\text{eff}}$ for this domain is:\n$$R_{\\text{eff}} = \\beta B$$\nNumerically:\n$$R_{\\text{eff}} = 0.5 \\times (2.4 \\times 10^{9} \\text{ s}^{-1}) = 1.2 \\times 10^{9} \\text{ s}^{-1}$$\n\nEach beat consists of $w$ bits. The time required to transmit the data for a single beat, $T_{\\text{tx\\_beat}}$, is the beat width divided by the effective bit rate:\n$$T_{\\text{tx\\_beat}} = \\frac{w}{R_{\\text{eff}}} = \\frac{w}{\\beta B}$$\n\nThe protocol imposes a handshake overhead of $t_p$ for each beat. Therefore, the total time to process one beat, $T_{\\text{beat}}$, is the sum of its transmission time and the handshake overhead:\n$$T_{\\text{beat}} = T_{\\text{tx\\_beat}} + t_p = \\frac{w}{\\beta B} + t_p$$\n\nSince the beats are transmitted sequentially, the total time to deliver all $N_{\\text{beats}}$, denoted as $T_{\\text{delivery}}$, is:\n$$T_{\\text{delivery}} = N_{\\text{beats}} \\times T_{\\text{beat}} = \\frac{N}{w} \\left( \\frac{w}{\\beta B} + t_p \\right) = \\frac{N}{\\beta B} + \\frac{N t_p}{w}$$\n\nThe problem defines the overall latency for a single operation (save or restore), let's call it $T_{\\text{op}}$, as the time to deliver all beats plus the local completion time $t_s$ for the last set of SRFFs. This is because the local operation for the last group of $w$ SRFFs can only begin after their control bits have fully arrived.\n$$T_{\\text{op}} = T_{\\text{delivery}} + t_s = \\frac{N}{\\beta B} + \\frac{N t_p}{w} + t_s$$\n\nThe total latency $T_{\\text{total}}$ is for a full save followed by a full restore. Assuming the restore process is symmetric to the save process, it will have the same latency $T_{\\text{op}}$.\n$$T_{\\text{total}} = T_{\\text{save}} + T_{\\text{restore}} = 2 T_{\\text{op}}$$\nSubstituting the expression for $T_{\\text{op}}$, we obtain the general formula for the total latency:\n$$T_{\\text{total}} = 2 \\left( \\frac{N}{\\beta B} + \\frac{N t_p}{w} + t_s \\right)$$\n\nNow, we substitute the numerical values into this expression.\nThe three time components for a single operation are:\n1.  Total data transmission time: $\\frac{N}{\\beta B} = \\frac{3072}{0.5 \\times 2.4 \\times 10^{9} \\text{ s}^{-1}} = \\frac{3072}{1.2 \\times 10^{9} \\text{ s}^{-1}} = 2560 \\times 10^{-9} \\text{ s} = 2.56 \\times 10^{-6} \\text{ s}$.\n2.  Total handshake overhead: $\\frac{N t_p}{w} = \\frac{3072 \\times (2.5 \\times 10^{-9} \\text{ s})}{96} = 32 \\times (2.5 \\times 10^{-9} \\text{ s}) = 80 \\times 10^{-9} \\text{ s} = 0.08 \\times 10^{-6} \\text{ s}$.\n3.  Local completion time: $t_s = 3.2 \\times 10^{-9} \\text{ s} = 0.0032 \\times 10^{-6} \\text{ s}$.\n\nThe latency for one operation $T_{\\text{op}}$ is the sum of these components:\n$$T_{\\text{op}} = (2.56 \\times 10^{-6} + 0.08 \\times 10^{-6} + 0.0032 \\times 10^{-6}) \\text{ s} = 2.6432 \\times 10^{-6} \\text{ s}$$\n\nThe total latency for the save and restore cycle is:\n$$T_{\\text{total}} = 2 \\times T_{\\text{op}} = 2 \\times 2.6432 \\times 10^{-6} \\text{ s} = 5.2864 \\times 10^{-6} \\text{ s}$$\n\nThe problem requires the answer in microseconds, rounded to four significant figures.\n$$1 \\text{ µs} = 10^{-6} \\text{ s}$$\nThus, $T_{\\text{total}} = 5.2864$ µs.\nRounding to four significant figures gives $T_{\\text{total}} \\approx 5.286$ µs.\n\nFinally, we compare the calculated total latency to the performance budget $T_{\\text{budget}} = 5.00$ µs.\nSince $T_{\\text{total}} = 5.286$ µs, which is greater than $T_{\\text{budget}} = 5.00$ µs, the performance target is not met.",
            "answer": "$$\\boxed{5.286}$$"
        },
        {
            "introduction": "Having designed the power gating hardware and analyzed its state-retention overhead, the ultimate question becomes: when is it actually beneficial to gate a power domain? This advanced practice  elevates the analysis to the level of dynamic control policy, where you will use a Markov chain to model workload behavior and evaluate a predictive power-gating strategy. By accounting for prediction errors and calculating expected energy savings versus system stability, you will learn to formalize and solve the complex decision-making problem at the core of intelligent power management.",
            "id": "4290447",
            "problem": "You are tasked with designing and analyzing a runtime power-gating policy for a digital domain in the context of Electronic Design Automation (EDA). The domain alternates between an Active state and an Idle state. Workload behavior is modeled as a time-homogeneous, discrete-time Markov chain with two states: Active and Idle. Let $W_t \\in \\{\\mathrm{A},\\mathrm{I}\\}$ denote the workload state at discrete time step $t$. The Markov chain transition probabilities are: $\\mathbb{P}(W_{t+1}=\\mathrm{I}\\mid W_t=\\mathrm{A})=p_{AI}$ and $\\mathbb{P}(W_{t+1}=\\mathrm{A}\\mid W_t=\\mathrm{I})=p_{IA}$. A power-gating controller may turn the domain OFF (with state retention) or keep it ON. State retention ensures that the logical state is preserved during OFF, with a retention leakage energy cost.\n\nFundamental base assumptions and definitions:\n- A run length in the Idle state is defined as the number of consecutive Idle steps until the next transition to Active; under the Markov model, this Idle run length is geometrically distributed with parameter $p_{IA}$ and has expected value $1/p_{IA}$ steps.\n- Similarly, an Active run length is geometrically distributed with parameter $p_{AI}$ and has expected value $1/p_{AI}$ steps.\n- Per-step energy when ON in Idle is leakage $L_{\\mathrm{on}}$ (Joules per step). Per-step energy when ON in Active is dynamic plus leakage, $D + L_{\\mathrm{on}}$ (Joules per step). Per-step energy when OFF with state retention is $L_{\\mathrm{ret}}$ (Joules per step). Power-gating incurs a gate overhead energy $E_g$ (Joules per event) upon turning OFF and a wake overhead energy $E_w$ (Joules per event) upon turning ON.\n- The break-even condition is the minimum Idle run length (in steps) above which gating yields a nonnegative net energy benefit, derived by comparing gate and wake overheads against the difference between ON leakage and retention leakage over the run length. Let this minimum number of steps be denoted $B$, to be derived from the stated parameters.\n\nPolicy and prediction error model:\n- At the start of each Idle run, a predictor classifies the run as “long” if it believes the run will last at least $B$ steps and “short” otherwise.\n- If the run is actually long (length $\\ge B$), the predictor may fail to gate with probability $\\varepsilon_{\\mathrm{FN}}$ (false negative); otherwise, it gates with probability $1 - \\varepsilon_{\\mathrm{FN}}$.\n- If the run is actually short (length $< B$), the predictor may gate erroneously with probability $\\varepsilon_{\\mathrm{FP}}$ (false positive); otherwise, it does not gate with probability $1 - \\varepsilon_{\\mathrm{FP}}$.\n- When a run is gated, the controller turns OFF at the start of the Idle run and wakes ON at the end of that Idle run as the state transitions to Active. No gating is performed during Active runs.\n\nObjectives:\n- From the above base, derive the expected energy per step under the policy and compare it against the baseline that never gates (always ON). Compute the expected energy savings per step, expressed in Joules per step.\n- Define a stability metric as the expected number of power-state toggles per step. Each gated Idle run induces exactly $2$ toggles (one gate and one wake). A system is considered stable if this toggle rate is less than or equal to a given threshold $\\tau_{\\max}$ (in toggles per step). Output stability as a boolean.\n- You must derive $B$ and all required probabilities and expectations from first principles of the Markov chain and geometric distributions without shortcut formulas provided in the problem statement.\n\nRequired outputs:\n- For each test case, produce a list of two elements: the expected energy savings per step in Joules (a float) and the stability boolean (true if stable, false otherwise).\n- Express the expected energy savings in Joules per step as a float, with no unit symbol in the output. Stability must be a boolean.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a list of two elements in order $\\left[\\text{energy\\_savings\\_per\\_step}, \\text{stability\\_boolean}\\right]$.\n\nTest suite:\nProvide results for the following parameter sets. All energies are in Joules and per-step energies are in Joules per step. All error probabilities are dimensionless.\n\n- Case $1$ (happy path):\n  - $p_{IA} = 0.05$, $p_{AI} = 0.10$\n  - $L_{\\mathrm{on}} = 2 \\times 10^{-6}$, $L_{\\mathrm{ret}} = 0.2 \\times 10^{-6}$, $D = 5 \\times 10^{-6}$\n  - $E_g = 10 \\times 10^{-6}$, $E_w = 12 \\times 10^{-6}$\n  - $\\varepsilon_{\\mathrm{FP}} = 0.05$, $\\varepsilon_{\\mathrm{FN}} = 0.10$\n  - $\\tau_{\\max} = 0.04$\n\n- Case $2$ (high false positives, potential chattering):\n  - $p_{IA} = 0.20$, $p_{AI} = 0.20$\n  - $L_{\\mathrm{on}} = 2 \\times 10^{-6}$, $L_{\\mathrm{ret}} = 0.5 \\times 10^{-6}$, $D = 6 \\times 10^{-6}$\n  - $E_g = 8 \\times 10^{-6}$, $E_w = 8 \\times 10^{-6}$\n  - $\\varepsilon_{\\mathrm{FP}} = 0.60$, $\\varepsilon_{\\mathrm{FN}} = 0.10$\n  - $\\tau_{\\max} = 0.10$\n\n- Case $3$ (perfect predictor):\n  - $p_{IA} = 0.10$, $p_{AI} = 0.05$\n  - $L_{\\mathrm{on}} = 3 \\times 10^{-6}$, $L_{\\mathrm{ret}} = 0.3 \\times 10^{-6}$, $D = 7 \\times 10^{-6}$\n  - $E_g = 12 \\times 10^{-6}$, $E_w = 10 \\times 10^{-6}$\n  - $\\varepsilon_{\\mathrm{FP}} = 0.0$, $\\varepsilon_{\\mathrm{FN}} = 0.0$\n  - $\\tau_{\\max} = 0.03$\n\n- Case $4$ (near-indifferent leakage, break-even very large):\n  - $p_{IA} = 0.05$, $p_{AI} = 0.05$\n  - $L_{\\mathrm{on}} = 0.5 \\times 10^{-6}$, $L_{\\mathrm{ret}} = 0.49 \\times 10^{-6}$, $D = 8 \\times 10^{-6}$\n  - $E_g = 2 \\times 10^{-6}$, $E_w = 2 \\times 10^{-6}$\n  - $\\varepsilon_{\\mathrm{FP}} = 0.10$, $\\varepsilon_{\\mathrm{FN}} = 0.10$\n  - $\\tau_{\\max} = 0.02$\n\n- Case $5$ (very short idle runs):\n  - $p_{IA} = 0.80$, $p_{AI} = 0.20$\n  - $L_{\\mathrm{on}} = 2 \\times 10^{-6}$, $L_{\\mathrm{ret}} = 0.2 \\times 10^{-6}$, $D = 5 \\times 10^{-6}$\n  - $E_g = 3 \\times 10^{-6}$, $E_w = 3 \\times 10^{-6}$\n  - $\\varepsilon_{\\mathrm{FP}} = 0.02$, $\\varepsilon_{\\mathrm{FN}} = 0.10$\n  - $\\tau_{\\max} = 0.05$",
            "solution": "The problem requires the derivation of the expected energy savings per step and a stability metric for a power-gating policy applied to a digital domain. The analysis is based on a discrete-time Markov chain model for the workload's state.\n\nThe core of the analysis will leverage renewal theory, where a cycle is defined as one complete sequence of an Active run followed by an Idle run. We will compute the expected energy and event counts over such a cycle and then normalize by the expected cycle duration to find the per-step averages.\n\n**1. Markov Chain and Renewal Cycle Properties**\n\nThe workload state $W_t$ follows a two-state Markov chain with states $\\{\\mathrm{A}, \\mathrm{I}\\}$. The transition probabilities are given as $p_{AI} = \\mathbb{P}(W_{t+1}=\\mathrm{I}\\mid W_t=\\mathrm{A})$ and $p_{IA} = \\mathbb{P}(W_{t+1}=\\mathrm{A}\\mid W_t=\\mathrm{I})$.\n\nThe duration of a run in a given state is geometrically distributed.\n-   The length of an Active run, $L_A$, is a geometric random variable with success probability $p_{AI}$. Its probability mass function is $\\mathbb{P}(L_A=k) = (1-p_{AI})^{k-1}p_{AI}$ for $k \\ge 1$. The expected length is $\\mathbb{E}[L_A] = 1/p_{AI}$.\n-   The length of an Idle run, $L_I$, is a geometric random variable with success probability $p_{IA}$. Its probability mass function is $\\mathbb{P}(L_I=k) = (1-p_{IA})^{k-1}p_{IA}$ for $k \\ge 1$. The expected length is $\\mathbb{E}[L_I] = 1/p_{IA}$.\n\nA renewal cycle consists of one Active run followed by one Idle run. The expected length of a cycle is the sum of the expected run lengths:\n$$ \\mathbb{E}[L_{\\text{cycle}}] = \\mathbb{E}[L_A] + \\mathbb{E}[L_I] = \\frac{1}{p_{AI}} + \\frac{1}{p_{IA}} $$\n\nThe steady-state probabilities of being in the Active state, $\\pi_A$, and Idle state, $\\pi_I$, can be found from the balance equation $\\pi_A p_{AI} = \\pi_I p_{IA}$ and the normalization condition $\\pi_A + \\pi_I = 1$. This yields:\n$$ \\pi_A = \\frac{p_{IA}}{p_{AI} + p_{IA}}, \\quad \\pi_I = \\frac{p_{AI}}{p_{AI} + p_{IA}} $$\nThese represent the long-term fraction of time spent in each state, and are consistent with the cycle-based view: $\\pi_A = \\mathbb{E}[L_A] / \\mathbb{E}[L_{\\text{cycle}}]$ and $\\pi_I = \\mathbb{E}[L_I] / \\mathbb{E}[L_{\\text{cycle}}]$.\n\n**2. Break-Even Point ($B$) Derivation**\n\nThe break-even point $B$ is the minimum Idle run length for which power gating provides a non-negative energy benefit. For an Idle run of length $k$ steps:\n- Energy if kept ON: $E_{\\text{on}}(k) = k \\cdot L_{\\mathrm{on}}$.\n- Energy if gated OFF: $E_{\\text{off}}(k) = k \\cdot L_{\\mathrm{ret}} + E_g + E_w$.\n\nThe energy saving is $\\Delta E(k) = E_{\\text{on}}(k) - E_{\\text{off}}(k) = k(L_{\\mathrm{on}} - L_{\\mathrm{ret}}) - (E_g + E_w)$.\nFor a non-negative benefit, we require $\\Delta E(k) \\ge 0$. Assuming $L_{\\mathrm{on}} > L_{\\mathrm{ret}}$ (otherwise gating is never beneficial on a per-step basis), we solve for $k$:\n$$ k(L_{\\mathrm{on}} - L_{\\mathrm{ret}}) \\ge E_g + E_w \\implies k \\ge \\frac{E_g + E_w}{L_{\\mathrm{on}} - L_{\\mathrm{ret}}} $$\nSince $k$ must be an integer, the minimum number of steps $B$ is the smallest integer satisfying this condition, which is the ceiling of the expression:\n$$ B = \\left\\lceil \\frac{E_g + E_w}{L_{\\mathrm{on}} - L_{\\mathrm{ret}}} \\right\\rceil $$\n\n**3. Expected Energy Savings Per Step**\n\nThe expected energy savings per step is the expected energy saved per cycle divided by the expected cycle length. Savings only occur during Idle runs. The expected saving per cycle is therefore the expected energy saving over a single Idle run.\n\nLet $I_{\\text{gate}}$ be an indicator random variable which is $1$ if an Idle run is gated, and $0$ otherwise. The energy saving for an Idle run of length $L_I$ is $\\Delta E(L_I) = I_{\\text{gate}} \\cdot [L_I(L_{\\mathrm{on}} - L_{\\mathrm{ret}}) - (E_g + E_w)]$.\nThe expected saving per run (and per cycle) is:\n$$ \\mathbb{E}[\\Delta E_{\\text{run}}] = \\mathbb{E}[I_{\\text{gate}} \\cdot L_I](L_{\\mathrm{on}} - L_{\\mathrm{ret}}) - \\mathbb{E}[I_{\\text{gate}}](E_g + E_w) $$\nHere, $\\mathbb{E}[I_{\\text{gate}}] = P(\\text{gate})$.\n\nThe probability of gating depends on whether the run is \"long\" ($L_I \\ge B$) or \"short\" ($L_I < B$).\nThe probability of a long run is:\n$$ P(\\text{long}) = \\mathbb{P}(L_I \\ge B) = \\sum_{k=B}^{\\infty} (1-p_{IA})^{k-1}p_{IA} = (1-p_{IA})^{B-1} $$\nThe total probability of gating an Idle run is given by the law of total probability:\n$$ P(\\text{gate}) = P(\\text{gate}|\\text{long})P(\\text{long}) + P(\\text{gate}|\\text{short})P(\\text{short}) $$\n$$ P(\\text{gate}) = (1-\\varepsilon_{\\mathrm{FN}})(1-p_{IA})^{B-1} + \\varepsilon_{\\mathrm{FP}}(1 - (1-p_{IA})^{B-1}) $$\n\nNext, we evaluate $\\mathbb{E}[I_{\\text{gate}} \\cdot L_I]$. Using the law of total expectation:\n$$ \\mathbb{E}[L_I \\cdot I_{\\text{gate}}] = \\mathbb{E}[\\mathbb{E}[L_I \\cdot I_{\\text{gate}}|L_I]] = \\mathbb{E}[L_I \\cdot \\mathbb{E}[I_{\\text{gate}}|L_I]] $$\nThe inner expectation is $\\mathbb{E}[I_{\\text{gate}}|L_I=k]$, which is the probability of gating for a run of length $k$: $1-\\varepsilon_{\\mathrm{FN}}$ if $k \\ge B$, and $\\varepsilon_{\\mathrm{FP}}$ if $k < B$.\n$$ \\mathbb{E}[L_I \\cdot I_{\\text{gate}}] = \\sum_{k=1}^{B-1} k \\cdot \\varepsilon_{\\mathrm{FP}} \\cdot \\mathbb{P}(L_I=k) + \\sum_{k=B}^{\\infty} k \\cdot (1-\\varepsilon_{\\mathrm{FN}}) \\cdot \\mathbb{P}(L_I=k) $$\nLet $E_S(B) = \\sum_{k=1}^{B-1} k \\cdot \\mathbb{P}(L_I=k)$ and $E_L(B) = \\sum_{k=B}^{\\infty} k \\cdot \\mathbb{P}(L_I=k)$. Then $\\mathbb{E}[L_I \\cdot I_{\\text{gate}}] = \\varepsilon_{\\mathrm{FP}} E_S(B) + (1-\\varepsilon_{\\mathrm{FN}}) E_L(B)$.\nNote that $E_S(B) + E_L(B) = \\mathbb{E}[L_I] = 1/p_{IA}$.\nThe truncated sum $E_S(B)$ can be computed using the formula for the sum of a finite arithmetico-geometric series, which yields:\n$$ E_S(B) = \\sum_{k=1}^{B-1} k \\cdot p_{IA}(1-p_{IA})^{k-1} = \\frac{1-(1-p_{IA})^{B-1}}{p_{IA}} - (B-1)(1-p_{IA})^{B-1} $$\nAnd $E_L(B)$ is then $E_L(B) = 1/p_{IA} - E_S(B)$.\n\nThe expected energy savings per run is:\n$$ E_{\\text{savings\\_run}} = (L_{\\mathrm{on}} - L_{\\mathrm{ret}})(\\varepsilon_{\\mathrm{FP}} E_S(B) + (1-\\varepsilon_{\\mathrm{FN}}) E_L(B)) - (E_g + E_w)P(\\text{gate}) $$\nFinally, the expected energy savings per step is this value normalized by the cycle length:\n$$ E_{\\text{savings\\_step}} = \\frac{E_{\\text{savings\\_run}}}{\\mathbb{E}[L_{\\text{cycle}}]} = \\frac{E_{\\text{savings\\_run}}}{1/p_{AI} + 1/p_{IA}} $$\n\n**4. Stability Metric**\n\nThe stability metric is the expected number of power-state toggles per step. A gated Idle run involves one OFF transition (gate) and one ON transition (wake), for a total of $2$ toggles.\nThe expected number of toggles per cycle is $2$ times the probability of gating an Idle run:\n$$ \\mathbb{E}[\\text{toggles per cycle}] = 2 \\cdot P(\\text{gate}) $$\nThe toggle rate $\\mathcal{T}$, in toggles per step, is the expected number of toggles per cycle divided by the expected cycle length:\n$$ \\mathcal{T} = \\frac{2 \\cdot P(\\text{gate})}{\\mathbb{E}[L_{\\text{cycle}}]} = \\frac{2 \\cdot P(\\text{gate})}{1/p_{AI} + 1/p_{IA}} $$\nThe system is deemed stable if this rate does not exceed a given threshold $\\tau_{\\max}$:\n$$ \\text{Stability} \\iff \\mathcal{T} \\le \\tau_{\\max} $$\nThis completes the derivations required to solve the problem.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the power-gating analysis problem for a set of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"p_ia\": 0.05, \"p_ai\": 0.10,\n            \"l_on\": 2e-6, \"l_ret\": 0.2e-6, \"d\": 5e-6,\n            \"e_g\": 10e-6, \"e_w\": 12e-6,\n            \"eps_fp\": 0.05, \"eps_fn\": 0.10,\n            \"tau_max\": 0.04\n        },\n        # Case 2 (high false positives, potential chattering)\n        {\n            \"p_ia\": 0.20, \"p_ai\": 0.20,\n            \"l_on\": 2e-6, \"l_ret\": 0.5e-6, \"d\": 6e-6,\n            \"e_g\": 8e-6, \"e_w\": 8e-6,\n            \"eps_fp\": 0.60, \"eps_fn\": 0.10,\n            \"tau_max\": 0.10\n        },\n        # Case 3 (perfect predictor)\n        {\n            \"p_ia\": 0.10, \"p_ai\": 0.05,\n            \"l_on\": 3e-6, \"l_ret\": 0.3e-6, \"d\": 7e-6,\n            \"e_g\": 12e-6, \"e_w\": 10e-6,\n            \"eps_fp\": 0.0, \"eps_fn\": 0.0,\n            \"tau_max\": 0.03\n        },\n        # Case 4 (near-indifferent leakage, break-even very large)\n        {\n            \"p_ia\": 0.05, \"p_ai\": 0.05,\n            \"l_on\": 0.5e-6, \"l_ret\": 0.49e-6, \"d\": 8e-6,\n            \"e_g\": 2e-6, \"e_w\": 2e-6,\n            \"eps_fp\": 0.10, \"eps_fn\": 0.10,\n            \"tau_max\": 0.02\n        },\n        # Case 5 (very short idle runs)\n        {\n            \"p_ia\": 0.80, \"p_ai\": 0.20,\n            \"l_on\": 2e-6, \"l_ret\": 0.2e-6, \"d\": 5e-6,\n            \"e_g\": 3e-6, \"e_w\": 3e-6,\n            \"eps_fp\": 0.02, \"eps_fn\": 0.10,\n            \"tau_max\": 0.05\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p_ia = case[\"p_ia\"]\n        p_ai = case[\"p_ai\"]\n        l_on = case[\"l_on\"]\n        l_ret = case[\"l_ret\"]\n        e_g = case[\"e_g\"]\n        e_w = case[\"e_w\"]\n        eps_fp = case[\"eps_fp\"]\n        eps_fn = case[\"eps_fn\"]\n        tau_max = case[\"tau_max\"]\n\n        # 1. Calculate break-even point B\n        delta_l = l_on - l_ret\n        if delta_l <= 0:\n            # Gating is never beneficial, B is effectively infinite.\n            # In Python, we can represent this with a very large number.\n            B = float('inf')\n        else:\n            B = int(np.ceil((e_g + e_w) / delta_l))\n\n        # 2. Renewal cycle properties\n        exp_L_cycle = (1 / p_ai) + (1 / p_ia)\n\n        # 3. Probabilities related to idle run length\n        # Let q = 1 - p_ia\n        q_ia = 1.0 - p_ia\n        \n        # P(long) = P(L_I >= B) = (1 - p_ia)^(B-1)\n        # Handle B=inf case; pow will be 0.\n        prob_long = q_ia ** (B - 1) if B > 0 and q_ia > 0 else 0.0 \n        \n        prob_short = 1.0 - prob_long\n\n        # 4. Probability of gating an idle run\n        prob_gate = (1 - eps_fn) * prob_long + eps_fp * prob_short\n\n        # 5. Expected energy savings calculation\n        # E_S(B) = sum_{k=1}^{B-1} k * P(L_I=k)\n        if B == 1:\n            E_S_B = 0.0\n        elif B == float('inf'):\n            E_S_B = 1.0 / p_ia\n        else:\n            q_pow_B_minus_1 = q_ia ** (B-1)\n            E_S_B = (1.0 - q_pow_B_minus_1) / p_ia - (B - 1) * q_pow_B_minus_1\n\n        # E_L(B) = sum_{k=B}^{\\infty} k * P(L_I=k)\n        E_L_B = (1.0 / p_ia) - E_S_B\n        \n        # Expected value of L_I * I_gate\n        exp_L_I_gated = eps_fp * E_S_B + (1 - eps_fn) * E_L_B\n\n        # Expected energy savings per idle run\n        exp_savings_run = delta_l * exp_L_I_gated - (e_g + e_w) * prob_gate\n        \n        # Expected energy savings per step\n        exp_savings_step = exp_savings_run / exp_L_cycle\n\n        # 6. Stability metric calculation\n        toggle_rate = (2 * prob_gate) / exp_L_cycle\n        is_stable = toggle_rate <= tau_max\n\n        results.append([exp_savings_step, is_stable])\n    \n    # Custom string formatting to match problem specification (no spaces between elements)\n    result_strings = []\n    for res_pair in results:\n        # Format the float to a reasonable precision in scientific notation\n        float_str = f\"{res_pair[0]:.6g}\"\n        # Python's str(bool) is 'True' or 'False'. If 'true'/'false' is needed, use .lower()\n        bool_str = str(res_pair[1]).lower()\n        result_strings.append(f\"[{float_str},{bool_str}]\")\n\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}