{
    "hands_on_practices": [
        {
            "introduction": "第一个练习将引导你逐步应用经典的D算法。你将跟踪如何激活一个固定型故障，并将其错误信号（用符号 $D$ 表示）通过电路传播到主输出，从而展示这一开创性ATPG方法的核心机制。",
            "id": "4265509",
            "problem": "考虑一个组合逻辑网络，其主输入为 $a$、$b$、$c$、$d$，单个主输出为 $z$。内部信号定义为 $u=\\text{AND}(a,b)$、$v=\\text{OR}(u,c)$ 和 $z=\\text{NAND}(v,d)$，其中 $\\text{AND}$、$\\text{OR}$ 和 $\\text{NAND}$ 表示标准的布尔运算。假设在信号线 $u$ 上存在一个单一的固定为0故障（$u \\text{ s-a-0}$）。\n\n运用自动测试码生成（ATPG）的原理，特别是D算法的确定性方法（其精神与面向路径的决策（PODEM）算法形成对比，尽管在此不作要求），从第一性原理出发，推导出一个施加于主输入的测试向量，该向量既能激活在 $u$ 处的故障，又能保证其传播到主输出 $z$。您的推导必须从基本定义开始：差异符号 $D$（表示在无故障电路中为值 $1$，在故障电路中为值 $0$）及其补码 $\\overline{D}$（表示在无故障电路中为值 $0$，在故障电路中为值 $1$）的语义、门电路的控制值和非控制值，以及D-前沿（$D$-frontier）和J-前沿（$J$-frontier，即合理化前沿）的概念。请展示在您所赋的输入值下，$D$ 是如何出现在 $u$ 处并随后传播到 $z$ 的。\n\n请以单行矩阵的形式，按输入顺序 $(a,b,c,d)$ 提供最终的测试向量。无需进行数值舍入，也不涉及物理单位。",
            "solution": "此问题要求使用D算法的原理，为组合逻辑电路中的单个固定型故障推导一个测试向量。该过程涉及故障激活和故障传播。\n\n首先，我们定义基本概念。D算法使用一个5值逻辑系统进行操作：\n- $0$：在无故障（好）电路和故障电路中均表示逻辑 $0$。\n- $1$：在无故障（好）电路和故障电路中均表示逻辑 $1$。\n- $D$：在好电路中表示逻辑 $1$，在故障电路中表示逻辑 $0$。我们将其表示为对偶值 $(1,0)$。\n- $\\overline{D}$：在好电路中表示逻辑 $0$，在故障电路中表示逻辑 $1$。我们将其表示为对偶值 $(0,1)$。\n- $X$：表示未知值或“无关”值。\n\n如果一个测试向量能在主输出端产生 $D$ 或 $\\overline{D}$，则该测试向量是成功的。这通过两个主要阶段实现：\n1.  **故障激活**：为主输入（PIs）赋值，以迫使故障信号线在好电路和故障电路中具有不同的值。这会在故障点产生一个初始的 $D$ 或 $\\overline{D}$。\n2.  **故障传播**：将此差异信号通过电路传播到至少一个主输出（PO）。这需要将传播路径上各门电路的其他输入设置为其非控制值。\n\n门输入的非控制值是指允许其他输入决定门输出的值。控制值则是指能单独决定门输出的值，而不管其他输入如何。\n- 对于与门/与非门（AND/NAND），控制值为 $0$，非控制值为 $1$。\n- 对于或门/或非门（OR/NOR），控制值为 $1$，非控制值为 $0$。\n\nD算法维护两个前沿：\n- **D-前沿**：其输入有 $D$ 或 $\\overline{D}$ 但其输出仍为 $X$ 的门电路集合。算法的目标是通过其中一个门来传播故障。\n- **J-前沿（合理化前沿）**：其输出有要求的值，但其输入尚未被赋值以产生该值的门电路集合。算法必须通过设置主输入值来合理化这些内部值。\n\n现在，我们将此过程应用于给定问题。\n\n**电路与故障：**\n- 主输入：$a$, $b$, $c$, $d$。\n- 逻辑：$u=\\text{AND}(a,b)$, $v=\\text{OR}(u,c)$, $z=\\text{NAND}(v,d)$。\n- 故障：$u$ 固定为$0$（$u \\text{ s-a-0}$）。\n\n**第1步：故障激活**\n故障为 $u \\text{ s-a-0}$。为了激活此故障，好电路中的信号 $u$ 必须被强制为相反的值，即 $1$。\n- 好电路中 $u$ 的值：$u_{good} = 1$。\n- 故障电路中 $u$ 的值：$u_{faulty} = 0$（由于固定为0的故障）。\n这就产生了差异信号 $u=(u_{good}, u_{faulty}) = (1,0)$，根据定义即为 $D$。因此，我们设定目标 $u=D$。\n\n为了在好电路中实现 $u=1$，我们必须满足门 $u=\\text{AND}(a,b)$ 的条件。要使与门的输出为 $1$，其所有输入都必须为 $1$。这构成了一个合理化要求。\n- 设置 $a=1$ 且 $b=1$。\n\n通过此赋值，故障被激活：在好电路中 $u = \\text{AND}(1,1) = 1$，而故障迫使在故障电路中 $u=0$。因此，$u=D$。初始的合理化已完成，J-前沿为空。D-前沿现在由以 $u$ 为输入的门组成，即产生 $v$ 的或门。\n\n**第2步：从 $u$ 到 $v$ 的故障传播**\n现在的任务是将差异信号 $D$ 从门 $v=\\text{OR}(u,c)$ 的输入 $u$ 传播到其输出 $v$。\n为了从或门的输入 $u$ 传播信号，另一个输入 $c$ 必须设置为非控制值。\n- 或门的控制值为 $1$。\n- 或门的非控制值为 $0$。\n因此，我们必须设置 $c=0$。\n\n我们来计算当 $u=D$ 且 $c=0$ 时 $v$ 的值：\n- 好电路：$v_{good} = u_{good} \\lor c = 1 \\lor 0 = 1$。\n- 故障电路：$v_{faulty} = u_{faulty} \\lor c = 0 \\lor 0 = 0$。\n结果信号为 $v = (v_{good}, v_{faulty}) = (1,0)$，即 $D$。\n故障已成功传播到信号线 $v$。D-前沿现在推进到产生 $z$ 的与非门。\n\n**第3步：从 $v$ 到 $z$ 的故障传播**\n任务是将差异信号 $D$ 从门 $z=\\text{NAND}(v,d)$ 的输入 $v$ 传播到主输出 $z$。\n为了从与非门的输入 $v$ 传播信号，另一个输入 $d$ 必须设置为非控制值。\n- 与非门的控制值为 $0$。\n- 与非门的非控制值为 $1$。\n因此，我们必须设置 $d=1$。\n\n我们来计算当 $v=D$ 且 $d=1$ 时主输出 $z$ 的值：\n- 好电路：$z_{good} = \\overline{v_{good} \\land d} = \\overline{1 \\land 1} = \\overline{1} = 0$。\n- 故障电路：$z_{faulty} = \\overline{v_{faulty} \\land d} = \\overline{0 \\land 1} = \\overline{0} = 1$。\n结果信号为 $z = (z_{good}, z_{faulty}) = (0,1)$，即 $\\overline{D}$。\n\n由于差异（$\\overline{D}$）现已出现在主输出 $z$ 上，该故障是可检测的。过程完成。\n\n**结论：**\n对主输入所做的赋值如下：\n- $a=1$ （用于故障激活）\n- $b=1$ （用于故障激活）\n- $c=0$ （用于通过或门传播）\n- $d=1$ （用于通过与非门传播）\n\n最终的测试向量是 $(a,b,c,d) = (1,1,0,1)$。\n- 在无故障电路中，使用此输入， $u=\\text{AND}(1,1)=1$, $v=\\text{OR}(1,0)=1$, 且 $z=\\text{NAND}(1,1)=0$。\n- 在故障电路中（$u\\ s\\text{-}a\\text{-}0$），$u=0$, $v=\\text{OR}(0,0)=0$, 且 $z=\\text{NAND}(0,1)=1$。\n输出 $z$ 不同（$0$ 对比 $1$），这证实了该测试向量可以检测到此故障。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  1  0  1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "接下来，我们将从D算法转向PODEM算法，该算法通过将路径传播目标与输入合理化过程分离来改进搜索过程。本练习将引导你体验PODEM特有的“目标-回溯-蕴含”循环，展示它如何有效地在搜索空间中导航以找到测试向量。",
            "id": "4265518",
            "problem": "考虑一个单输出组合电路，其主输入为 $a$、$b$、$c$ 和 $d$，主输出 $z$ 定义为\n$$\nz=\\mathrm{OR}\\!\\big(\\mathrm{NAND}(a,b),\\,\\mathrm{AND}(c,d)\\big),\n$$\n其中 $\\mathrm{NAND}(x,y)=\\neg(x\\wedge y)$，$\\mathrm{AND}(x,y)=x\\wedge y$，以及 $\\mathrm{OR}(x,y)=x\\vee y$。假设输入线 $b$ 上存在一个值为 $1$ 的单一固定型故障（表示为 $b \\text{ s-a-1}$）。使用面向路径决策 (PODEM) 算法，在标准五值代数 $\\{0,1,X,D,D'\\}$ 下，为主输出 $z$ 生成一个检测测试。其中 $D$ 表示在无故障电路中为 $1$、在故障电路中为 $0$ 的逻辑值，$D'$ 表示在无故障电路中为 $0$、在故障电路中为 $1$ 的逻辑值。假设使用通常的可控性和可观测性定义，以及门控值和非门控值：对于 $\\mathrm{OR}$ 门，控制值为 $1$，非控制值为 $0$；对于 $\\mathrm{AND}$ 门，控制值为 $0$，非控制值为 $1$。\n\n采用以下确定性的 PODEM 关系打破和计数约定：\n- 当存在多种理由将 $\\mathrm{AND}(c,d)$ 的输出强制为 $0$ 时，回溯过程优先选择 $c$ 而非 $d$。\n- 每次从目标到主输入的回溯，如果导致一个主输入赋值，则计为一个回溯步骤。\n- 前向蕴含不计入回溯步骤数。\n- 如果存在检测到故障的一致性赋值，则不发生决策回退。\n\n从所有主输入均为 $X$ 开始，推导激活故障效应并将其传播到 $z$ 所需的 PODEM 目标、回溯和蕴含。在这些约定下，计算达到第一个检测赋值所需的最小回溯步骤总数。请以单个整数形式提供您的最终答案。无需四舍五入。",
            "solution": "该问题要求应用面向路径决策 (PODEM) 算法，为给定组合逻辑电路中的特定固定型故障生成一个测试图形。目标是遵循一套预定的确定性规则，确定找到第一个此类测试图形所需的最小回溯步骤数。\n\n首先，我们形式化电路结构。主输入为 $a, b, c, d$，主输出为 $z$。逻辑函数为 $z=\\mathrm{OR}\\!\\big(\\mathrm{NAND}(a,b),\\,\\mathrm{AND}(c,d)\\big)$。我们定义两个中间网络节点 $g_1$ 和 $g_2$ 来表示内部逻辑门的输出：\n$$ g_1 = \\mathrm{NAND}(a, b) = \\neg(a \\wedge b) $$\n$$ g_2 = \\mathrm{AND}(c, d) = c \\wedge d $$\n主输出 $z$ 则由下式给出：\n$$ z = \\mathrm{OR}(g_1, g_2) = g_1 \\vee g_2 $$\n待检测的故障是输入线 $b$ 上的固定为1故障，表示为 $b \\text{ s-a-1}$。我们将使用五值逻辑系统 $\\{0, 1, X, D, D'\\}$，其中 $X$ 是未知值，$D$ 代表正常电路/故障电路的值对 $1/0$，$D'$ 代表 $0/1$。\n\nPODEM 算法通过设置目标（内部节点上的值赋值）并回溯到主输入来满足这些目标。当故障效应（$D$ 或 $D'$）传播到主输出时，就找到了一个测试。该过程从所有输入设置为 $X$ 开始。回溯步骤数根据问题的约定进行计数。\n\n**初始化 (步骤 0):**\n电路的初始状态是所有主输入以及因此所有内部节点都处于未知状态 $X$。\n- 主输入 (PI) 值: $(a, b, c, d) = (X, X, X, X)$。\n- 内部节点值: $g_1 = X$, $g_2 = X$, $z = X$。\n- 回溯步骤计数初始化为 $0$。\n\n**迭代 1: 故障激活**\nPODEM 的第一阶段是激活故障。对于故障 $b \\text{ s-a-1}$，激活需要将输入线 $b$ 设置为与固定值相反的值。\n- **目标:** 目标是设置 $b=0$。\n- **回溯:** 节点 $b$ 是一个主输入。从目标 $(b, 0)$ 开始的回溯在主输入 $b$ 自身处终止。\n- **PI 赋值:** 此回溯步骤导致赋值 $b=0$。\n- **回溯步骤计数:** 这是导致 PI 赋值的第一个回溯步骤。计数增加到 $1$。\n- **前向蕴含:** 在 $b=0$ 的情况下，我们将此值在电路中传播。\n    - 在故障点 $b$ 处，正常电路的值为 $0$，而故障电路固定为 $1$。复合值为 $0/1$，表示为 $D'$。\n    - 此时输入的状态为 $(a, b, c, d) = (X, 0, X, X)$。\n    - 门 $g_1 = \\mathrm{NAND}(a,b)$ 的输入为 $(X, D')$。输出 $g_1$ 为 $\\mathrm{NAND}(X, 0/1)$。对于正常电路，$g_{1,good} = \\mathrm{NAND}(X,0) = 1$。对于故障电路，$g_{1,faulty} = \\mathrm{NAND}(X,1)$，其值取决于 $a$，因此是未知的 ($X$)。输出 $g_1$ 是 $1/X$，这在我们的五值代数中不是一个单一值，所以 $g_1$ 保持为 $X$。\n    - D边界 (D-frontier) 是指其输入端有故障效应但输出端尚未体现的门的集合，它由门 $g_1$ 组成。\n    - 所有其他节点，$g_2$ 和 $z$，保持为 $X$。\n\n**迭代 2: 从 $g_1$ 传播故障**\n下一个目标是从 D 边界传播故障效应。D 边界当前仅包含门 $g_1$。\n- **目标:** 为了从门 $g_1 = \\mathrm{NAND}(a,b)$ 的输入 $b$ 传播 $D'$，另一个输入 $a$ 必须被设置为该门的非控制值。对于 NAND 门，非控制值是 $1$。因此，目标是 $(a, 1)$。\n- **回溯:** 节点 $a$ 是一个主输入。从 $(a, 1)$ 开始的回溯在主输入 $a$ 处终止。\n- **PI 赋值:** 此步骤导致赋值 $a=1$。\n- **回溯步骤计数:** 这是第二个回溯步骤。计数增加到 $1+1=2$。\n- **前向蕴含:** 在主输入为 $(a, b, c, d) = (1, 0, X, X)$ 的情况下，我们重新评估电路。\n    - $a=1$ 且 $b=D'$ ($0/1$)。\n    - $g_1 = \\mathrm{NAND}(a,b) = \\mathrm{NAND}(1, D')$。\n        - 正常电路: $g_{1,good} = \\mathrm{NAND}(1,0) = 1$。\n        - 故障电路: $g_{1,faulty} = \\mathrm{NAND}(1,1) = 0$。\n        - 复合输出为 $1/0$，即 $D$。故障效应现在位于 $g_1$。\n    - $g_2 = \\mathrm{AND}(c,d) = \\mathrm{AND}(X,X) = X$。\n    - $z = \\mathrm{OR}(g_1,g_2) = \\mathrm{OR}(D,X)$。输出 $z$ 仍然未知。\n    - D 边界现在是门 $z$，因为它有一个输入（$g_1$）为 $D$，而其输出尚不是 $D$ 或 $D'$。\n\n**迭代 3: 从 $z$ 传播故障**\n最后一步是通过主输出门 $z$ 传播故障效应。\n- **目标:** 为了从门 $z = \\mathrm{OR}(g_1,g_2)$ 的输入 $g_1$ 传播 $D$，另一个输入 $g_2$ 必须被设置为该门的非控制值。对于 OR 门，非控制值是 $0$。目标是 $(g_2, 0)$。\n- **回溯:** 节点 $g_2$ 不是主输入。我们必须从 $g_2$ 回溯，以找到一个能实现 $g_2=0$ 的主输入赋值。该门是 $g_2 = \\mathrm{AND}(c,d)$。要将其输出设置为 $0$，我们可以设置 $c=0$ 或 $d=0$。问题提供了一个关系打破规则：“回溯过程优先选择 $c$ 而非 $d$”。因此，我们选择目标 $(c, 0)$。节点 $c$ 是一个主输入，所以回溯终止。\n- **PI 赋值:** 此步骤导致赋值 $c=0$。\n- **回溯步骤计数:** 这是第三个回溯步骤。计数增加到 $2+1=3$。\n- **前向蕴含:** 在主输入为 $(a, b, c, d) = (1, 0, 0, X)$ 的情况下，我们进行最终评估。\n    - 根据之前的赋值，$g_1$ 仍然是 $D$。\n    - $g_2 = \\mathrm{AND}(c,d) = \\mathrm{AND}(0,X) = 0$。\n    - $z = \\mathrm{OR}(g_1,g_2) = \\mathrm{OR}(D,0)$。\n        - 正常电路: $z_{good} = \\mathrm{OR}(1,0) = 1$。\n        - 故障电路: $z_{faulty} = \\mathrm{OR}(0,0) = 0$。\n        - 复合输出为 $1/0$，即 $D$。\n- **结论:** 故障效应 $D$ 已到达主输出 $z$。故障被检测到。主输入向量 $(a,b,c,d) = (1,0,0,X)$ 是该算法找到的第一个检测测试图形。过程成功终止。\n\n回溯步骤的总数是每次主输入赋值计数的总和。在此过程中，共有三个这样的步骤。\n1. 目标 $(b,0)$ 导致主输入赋值 $b=0$。（$1$ 步）\n2. 目标 $(a,1)$ 导致主输入赋值 $a=1$。（$1$ 步）\n3. 目标 $(g_2,0)$ 导致子目标 $(c,0)$，进而导致主输入赋值 $c=0$。（$1$ 步）\n\n所需的最小回溯步骤总数为 $3$。",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "最后的练习将探讨测试生成中的一个关键概念：故障的不可检测性。你将分析一个带有重构扇出的电路，这种结构因导致故障屏蔽而臭名昭著，即故障效应在到达输出之前就相互抵消了。这个练习说明了为什么某些故障本质上是不可测试的，并突显了ATPG算法的一个基本局限性。",
            "id": "4265573",
            "problem": "考虑一个组合电路片段，它具有主输入$c$和$d$以及一个由$u = c \\land d$定义的内部信号$u$。信号$u$馈入一个再收敛扇出：它分裂成两条姊妹线$x$和$y$，它们是简单的缓冲器连接$x = u$和$y = u$，这两条姊妹线通过一个异或门在主输出$z$处再收敛，即$z = x \\oplus y$。假设在$u$处存在一个单一固定型故障，具体为$u$固定于$0$（$u \\text{ stuck-at-0}$）。使用D算法的基本五值代数（其中$D$表示正常电路中的值为$1$而故障电路中的值为$0$，$D'$表示正常电路中的值为$0$而故障电路中的值为$1$），以及面向路径的决策（PODEM）过程的目标/回溯范式。仅从固定型故障的激励和传播的核心定义以及$\\land$和$\\oplus$门的真值表（包括控制值和非控制值的概念）出发，推导在$z$处观测到故障效应所需的对姊妹线$x$和$y$的传播要求，并说明这些要求如何冲突并在$u$处产生矛盾。然后，计算能够检测到$z$处$u$固定于$0$故障的主输入赋值$(c,d) \\in \\{0,1\\}^{2}$的数量。将最终答案表示为一个整数。无需四舍五入。",
            "solution": "该问题是有效的，因为它具有科学依据，定义明确，客观且一致。它展示了带有再收敛扇出的电路中故障屏蔽的一个经典例子，这是电子设计自动化（EDA）和集成电路测试领域的一个基本课题。\n\n对给定电路的指定故障（$u$固定于$0$）的分析，需要一个对所有确定性ATPG（自动测试向量生成）算法都至关重要的两步过程：故障激励和故障传播。我们将使用五值代数$\\{0, 1, D, D', X\\}$，其中$D$代表正常电路中的逻辑$1$和故障电路中的逻辑$0$（$1/0$），$D'$代表正常电路中的逻辑$0$和故障电路中的逻辑$1$（$0/1$）。\n\n**1. 故障激励**\n\n故障被指定为内部信号线$u$固定于$0$。为了激励此故障，我们必须建立一个输入条件，在无故障（正常）电路中迫使信号$u$变为相反的值，即$1$。如果在正常电路中$u$为$1$，那么固定于$0$的故障将使其在故障电路中变为$0$。这个差异由复合符号$D$来表示。\n\n信号$u$由与门$u = c \\land d$定义。要使一个与门的输出为$1$，其所有输入都必须为$1$。\n$$ u_{\\text{good}} = 1 \\iff (c=1 \\text{ and } d=1) $$\n这是故障激励条件。当此条件满足时，节点$u$处的信号为：\n$$ u = u_{\\text{good}} / u_{\\text{faulty}} = 1/0 = D $$\n对于$(c,d)$的任何其他输入赋值，即$(0,0)$、$(0,1)$或$(1,0)$，都会导致$u_{\\text{good}} = 0$。在这些情况下，正常电路的值与固定于$0$的值相匹配，故障未被激励。因此，唯一可能检测到$u$固定于$0$故障的主输入赋值是$(c,d) = (1,1)$。\n\n**2. 故障传播与矛盾分析**\n\n一旦故障被激励，故障效应（现在由节点$u$处的信号$D$表示）必须被传播到一个主输出。在这个电路中，主输出是$z$。信号$u=D$扇出到两条姊妹线$x$和$y$。由于$x$和$y$是从$u$引出的简单缓冲器连接，故障信号直接传播到它们：\n$$ x = u = D $$\n$$ y = u = D $$\n这两个信号$x$和$y$在一个异或（XOR）门处再收敛，该门计算主输出$z = x \\oplus y$。\n\n传播的核心任务是使门的输出对其某个输入上的故障敏感。对于一个异或门$z = A \\oplus B$，如果输入$B$保持在一个恒定值（$0$或$1$），则输出$z$将反映输入$A$上的故障。具体来说：\n- 如果$B=0$，则$z = A \\oplus 0 = A$。$A$处的信号传播到$z$。\n- 如果$B=1$，则$z = A \\oplus 1 = \\neg A$。$A$处的反转信号传播到$z$。输入端的信号$D$在输出端会变成$D'$。\n\n遵循这一原则，为了将故障效应从输入$x$传播到输出$z$，要求输入$y$被设置为一个恒定值，即$0$或$1$。让我们以PODEM算法的风格将此形式化为一个目标。\n\n**目标：** 将故障传播到$z$。这意味着$z$必须是$D$或$D'$。\n\n为了从门$z=x \\oplus y$得到$z=D$或$z=D'$，我们必须将一个输入设置为携带故障信号（例如，$x=D$），并将另一个输入设置为一个敏化的、恒定的值（例如，$y=0$或$y=1$）。让我们将传播目标设定为：\n$$ \\text{Objective: } (x=D) \\land (y=0) $$\n这代表了通过用$y=0$来敏化路径，从而尝试通过$x$传播故障信号。\n\n现在，我们必须通过回溯到主输入来论证这些值的合理性。\n- 要求$x=D$意味着$u=D$。如故障激励阶段所确立的，这要求主输入赋值为$(c,d) = (1,1)$。\n- 现在我们检查第二个要求$y=0$是否与此赋值一致。对于$(c,d) = (1,1)$，我们已经确定$u=D$。由于$y$连接到$u$，这意味着$y=D$。\n\n矛盾就在于此。传播目标要求$y=0$。然而，唯一满足目标第一部分（$x=D$）的输入赋值同时迫使$y=D$。值$y$不能同时既是$0$（即$0/0$）又是$D$（即$1/0$）。这两个要求是相互排斥的。\n\n让我们检查另一种敏化可能性，$y=1$：\n$$ \\text{Objective: } (x=D) \\land (y=1) $$\n同样，$x=D$要求$(c,d)=(1,1)$，这又迫使$y=D$。这与要求$y=1$相矛盾。\n\n这种要求上的冲突表明，不可能敏化一条从故障位置到主输出的路径。再收敛扇出结构导致故障效应出现在异或门的两个输入端。当相同的故障信号到达一个异或门时，它们会相互抵消。这种现象被称为故障屏蔽。\n\n让我们为输入赋值$(c,d)=(1,1)$明确地计算$z$的值：\n- 在正常电路中：$c=1, d=1 \\implies u=1 \\implies x=1, y=1$。因此，$z_{\\text{good}} = x_{\\text{good}} \\oplus y_{\\text{good}} = 1 \\oplus 1 = 0$。\n- 在故障电路中：$u$固定于$0$，所以$u=0 \\implies x=0, y=0$。因此，$z_{\\text{faulty}} = x_{\\text{faulty}} \\oplus y_{\\text{faulty}} = 0 \\oplus 0 = 0$。\n\n在正常电路和故障电路中，输出$z$均为$0$。复合信号为$z = z_{\\text{good}} / z_{\\text{faulty}} = 0/0 = 0$。故障在$z$处不可观测。\n\n**3. 计算可检测故障的输入赋值数量**\n\n我们已经确定了以下几点：\n1. 唯一能够激励$u$固定于$0$故障的输入赋值是$(c,d)=(1,1)$。\n2. 对于这个特定的输入赋值，由于再收敛扇出结构，故障效应在主输出$z$处被屏蔽。\n3. 所有其他输入赋值——$(0,0)$、$(0,1)$和$(1,0)$——都不会激励该故障，因此正常电路和故障电路的行为完全相同。\n\n因此，在集合$\\{0,1\\}^2$中，没有任何主输入赋值能够检测到主输出$z$处的$u$固定于$0$故障。此类赋值的数量为$0$。",
            "answer": "$$ \\boxed{0} $$"
        }
    ]
}