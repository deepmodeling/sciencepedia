{
    "hands_on_practices": [
        {
            "introduction": "为开启我们的实践探索，我们将首先在一个简单的组合电路中应用基础的 D-算法。这个练习将引导你逐步体验自动测试向量生成（ATPG）的核心机制：激活一个故障，并将其效应（用符号 $D$ 表示）传播到一个可观测的输出端。掌握这一过程是理解更复杂的确定性 ATPG 方法的第一步。",
            "id": "4265509",
            "problem": "考虑一个组合逻辑网络，其主输入为 $a$、$b$、$c$、$d$，单一主输出为 $z$。其内部信号定义为 $u=\\text{AND}(a,b)$、$v=\\text{OR}(u,c)$ 和 $z=\\text{NAND}(v,d)$，其中 $\\text{AND}$、$\\text{OR}$ 和 $\\text{NAND}$ 表示标准的布尔运算。假设在信号线 $u$ 上存在一个单一固定型故障 $u\\ s\\text{-}a\\text{-}0$。\n\n使用自动测试图形生成（ATPG）的原理，特别是D算法（D-Algorithm）的确定性方法（与路径导向决策（PODEM）在思想上形成对比，但此处不作要求），从第一性原理出发，推导出一个施加于主输入的测试向量，该向量既能在 $u$ 处激活故障，又能保证其传播到主输出 $z$。您的推导必须从基本定义开始：差异符号 $D$（表示在无故障电路中为值 $1$，在故障电路中为值 $0$）及其补码 $\\overline{D}$（表示在无故障电路中为值 $0$，在故障电路中为值 $1$）的语义、门电路的控制值和非控制值，以及 $D$-边界（$D$-frontier）和合理化边界（$J$-frontier）的概念。请展示在您指定的输入下，$D$ 是如何在 $u$ 处出现并随后传播到 $z$ 的。\n\n请以单行矩阵的形式提供最终的测试向量，输入顺序为 $(a,b,c,d)$。无需数值取整，不涉及物理单位。",
            "solution": "该问题要求使用D算法的原理，为一个组合逻辑电路中的单一固定型故障推导一个测试向量。该过程涉及故障激活和故障传播。\n\n首先，我们定义基本概念。D算法使用一个5值逻辑系统进行操作：\n- $0$：表示在无故障（良好）电路和故障电路中均为逻辑 $0$。\n- $1$：表示在无故障（良好）电路和故障电路中均为逻辑 $1$。\n- $D$：表示在良好电路中为逻辑 $1$，在故障电路中为逻辑 $0$。我们将其表示为数对 $(1,0)$。\n- $\\overline{D}$：表示在良好电路中为逻辑 $0$，在故障电路中为逻辑 $1$。我们将其表示为数对 $(0,1)$。\n- $X$：表示未知值或“无关”值。\n\n如果一个测试向量能够在主输出端产生 $D$ 或 $\\overline{D}$，则该测试向量是成功的。这通过两个主要阶段实现：\n1.  **故障激活**：为主输入（PIs）赋值，以迫使故障信号线在良好电路和故障电路中具有不同的值。这会在故障点上产生一个初始的 $D$ 或 $\\overline{D}$。\n2.  **故障传播**：将此差异信号通过电路传播到至少一个主输出（PO）。这需要将传播路径上各门电路的其他输入设置为其非控制值。\n\n门输入的非控制值是指允许其他输入决定该门输出的值。控制值是指能够独立决定该门输出的值，而不管其他输入为何值。\n- 对于与门（AND）/与非门（NAND），控制值为 $0$，非控制值为 $1$。\n- 对于或门（OR）/或非门（NOR），控制值为 $1$，非控制值为 $0$。\n\nD算法维护两个边界：\n- **D-边界**（D-frontier）：其输入包含 $D$ 或 $\\overline{D}$ 但输出仍为 $X$ 的门电路集合。该算法的目标是通过其中一个门来传播故障。\n- **J-边界**（Justification frontier，合理化边界）：其输出具有所需值，但其输入尚未被赋值以产生该输出的门电路集合。该算法必须通过设置主输入值来合理化这些内部值。\n\n现在，我们将此过程应用于给定问题。\n\n**电路与故障：**\n- 主输入：$a$, $b$, $c$, $d$。\n- 逻辑：$u=\\text{AND}(a,b)$, $v=\\text{OR}(u,c)$, $z=\\text{NAND}(v,d)$。\n- 故障：$u$ 固定为 $0$ ($u\\ s\\text{-}a\\text{-}0$）。\n\n**步骤1：故障激活**\n故障为 $u\\ s\\text{-}a\\text{-}0$。为了激活此故障，良好电路中的信号 $u$ 必须被强制设为其相反值，即 $1$。\n- 良好电路中 $u$ 的值：$u_{good} = 1$。\n- 故障电路中 $u$ 的值：$u_{faulty} = 0$（由于固定为0的故障）。\n这产生了差异信号 $u=(u_{good}, u_{faulty}) = (1,0)$，根据定义即为 $D$。因此，我们设定目标 $u=D$。\n\n为了在良好电路中实现 $u=1$，我们必须满足门 $u=\\text{AND}(a,b)$ 的条件。要使一个与门的输出为 $1$，其所有输入都必须为 $1$。这构成一个合理化要求。\n- 设置 $a=1$ 且 $b=1$。\n\n通过此赋值，故障被激活：在良好电路中，$u = \\text{AND}(1,1) = 1$，而故障迫使 $u=0$。因此，$u=D$。初始的合理化完成。J-边界为空。D-边界现在由以 $u$ 为输入的门组成，即产生 $v$ 的或门。\n\n**步骤2：从 $u$ 到 $v$ 的故障传播**\n现在的任务是将差异信号 $D$ 从门 $v=\\text{OR}(u,c)$ 的输入 $u$ 传播到其输出 $v$。\n要从或门的输入 $u$ 传播信号，另一个输入 $c$ 必须被设置为非控制值。\n- 或门的控制值为 $1$。\n- 或门的非控制值为 $0$。\n因此，我们必须设置 $c=0$。\n\n我们来计算当 $u=D$ 且 $c=0$ 时 $v$ 的值：\n- 良好电路：$v_{good} = u_{good} \\lor c = 1 \\lor 0 = 1$。\n- 故障电路：$v_{faulty} = u_{faulty} \\lor c = 0 \\lor 0 = 0$。\n结果信号为 $v = (v_{good}, v_{faulty}) = (1,0)$，即 $D$。\n故障已成功传播到信号线 $v$。D-边界现在前移至产生 $z$ 的与非门。\n\n**步骤3：从 $v$ 到 $z$ 的故障传播**\n任务是将差异信号 $D$ 从门 $z=\\text{NAND}(v,d)$ 的输入 $v$ 传播到主输出 $z$。\n要从与非门的输入 $v$ 传播信号，另一个输入 $d$ 必须被设置为非控制值。\n- 与非门的控制值为 $0$。\n- 与非门的非控制值为 $1$。\n因此，我们必须设置 $d=1$。\n\n我们来计算当 $v=D$ 且 $d=1$ 时主输出 $z$ 的值：\n- 良好电路：$z_{good} = \\overline{v_{good} \\land d} = \\overline{1 \\land 1} = \\overline{1} = 0$。\n- 故障电路：$z_{faulty} = \\overline{v_{faulty} \\land d} = \\overline{0 \\land 1} = \\overline{0} = 1$。\n结果信号为 $z = (z_{good}, z_{faulty}) = (0,1)$，即 $\\overline{D}$。\n\n由于差异（$\\overline{D}$）现在出现在主输出 $z$ 上，该故障是可检测的。过程完成。\n\n**结论：**\n对主输入进行的赋值为：\n- $a=1$（用于故障激活）\n- $b=1$（用于故障激活）\n- $c=0$（用于通过或门传播）\n- $d=1$（用于通过与非门传播）\n\n最终的测试向量是 $(a,b,c,d) = (1,1,0,1)$。\n- 在无故障电路中，使用此输入，$u=\\text{AND}(1,1)=1$，$v=\\text{OR}(1,0)=1$，$z=\\text{NAND}(1,1)=0$。\n- 在故障电路（$u\\ s\\text{-}a\\text{-}0$）中，$u=0$，$v=\\text{OR}(0,0)=0$，$z=\\text{NAND}(0,1)=1$。\n输出 $z$ 不同（$0$ vs. $1$），确认该测试向量可检测到此故障。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  1  0  1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在 D-算法原理的基础上，PODEM 算法通过在主输入端进行决策，提供了一种更高效、面向路径的方法。这个实践问题将挑战你使用 PODEM 的“目标-回溯-推导”序列来寻找一个测试向量。通过这个练习，你将深入了解 PODEM 如何智能地在搜索空间中导航以达成测试生成的目标。",
            "id": "4265518",
            "problem": "考虑一个具有主输入 $a$、$b$、$c$ 和 $d$ 以及主输出 $z$ 的单输出组合电路，其定义如下：\n$$\nz=\\mathrm{OR}\\!\\big(\\mathrm{NAND}(a,b),\\,\\mathrm{AND}(c,d)\\big),\n$$\n其中 $\\mathrm{NAND}(x,y)=\\neg(x\\wedge y)$，$\\mathrm{AND}(x,y)=x\\wedge y$ 且 $\\mathrm{OR}(x,y)=x\\vee y$。假设在输入线 $b$ 上存在一个值为 $1$ 的单一固定型故障（记为 $b\\,s\\text{-}a\\text{-}1$）。使用面向路径的决策（PODEM）算法，在主输出 $z$ 处生成一个检测测试。该算法在标准五值代数 $\\{0,1,X,D,\\overline{D}\\}$ 下运行，其中 $D$ 表示在无故障电路中为 $1$、在故障电路中为 $0$ 的逻辑值，$\\overline{D}$ 表示在无故障电路中为 $0$、在故障电路中为 $1$ 的逻辑值。假设使用通常的可控性和可观测性定义，以及门的门控值和非门控值：对于 $\\mathrm{OR}$ 门，门控值为 $1$，非门控值为 $0$；对于 $\\mathrm{AND}$ 门，门控值为 $0$，非门控值为 $1$。\n\n采用以下确定性的 PODEM 冲突解决和计数约定：\n- 当存在多种赋值方案可将 $\\mathrm{AND}(c,d)$ 的输出强制为 $0$ 时，回溯过程优先选择 $c$ 而不是 $d$。\n- 每次从目标到主输入的回溯，如果导致了一次主输入赋值，则计为一步回溯。\n- 前向推导不计入回溯步数。\n- 如果存在能够检测到故障的一致性赋值，则不发生（路径）回溯。\n\n从所有主输入均为 $X$ 的状态开始，推导激活故障并将其效应传播到 $z$ 所需的 PODEM 目标、回溯和推导过程。计算在这些约定下，达到第一个检测赋值所需的最小总回溯步数。请以单个整数形式给出最终答案。无需四舍五入。",
            "solution": "该问题要求应用面向路径的决策（PODEM）算法，为给定组合逻辑电路中的特定固定型故障生成测试图形。目标是遵循一套预定的确定性规则，确定找到第一个此类测试图形所需的最小回溯步数。\n\n首先，我们形式化电路结构。主输入为 $a、b、c、d$，主输出为 $z$。逻辑函数为 $z=\\mathrm{OR}\\!\\big(\\mathrm{NAND}(a,b),\\,\\mathrm{AND}(c,d)\\big)$。我们定义两个中间节点 $g_1$ 和 $g_2$ 来表示内部逻辑门的输出：\n$$ g_1 = \\mathrm{NAND}(a, b) = \\neg(a \\wedge b) $$\n$$ g_2 = \\mathrm{AND}(c, d) = c \\wedge d $$\n主输出 $z$ 则由下式给出：\n$$ z = \\mathrm{OR}(g_1, g_2) = g_1 \\vee g_2 $$\n待检测的故障是输入线 $b$ 上的固定于1故障，记为 $b \\text{ s-a-1}$。我们将使用五值逻辑系统 $\\{0, 1, X, D, \\overline{D}\\}$，其中 $X$ 是未知值，$D$ 代表正常电路/故障电路的值对 $1/0$，$\\overline{D}$ 代表 $0/1$。\n\nPODEM 算法通过设置目标（内部节点上的值赋值）并回溯到主输入来满足这些目标。当故障效应（$D$ 或 $\\overline{D}$）被传播到主输出时，就找到了一个测试。该过程从所有输入都设置为 $X$ 开始。回溯步数根据问题的约定进行计数。\n\n**初始化 (第 0 步):**\n电路的初始状态是所有主输入以及因此所有内部节点都处于未知状态 $X$。\n- 主输入 (PI) 值： $(a, b, c, d) = (X, X, X, X)$。\n- 内部节点值：$g_1 = X$，$g_2 = X$，$z = X$。\n- 回溯步数初始化为 $0$。\n\n**迭代 1：故障激活**\nPODEM 的第一阶段是激活故障。对于故障 $b \\text{ s-a-1}$，激活需要将输入线 $b$ 设置为与固定值相反的值。\n- **目标：** 目标是设置 $b=0$。\n- **回溯：** 节点 $b$ 是一个主输入。从目标 $(b, 0)$ 开始的回溯在主输入 $b$ 本身处终止。\n- **PI 赋值：** 此回溯步骤导致赋值 $b=0$。\n- **回溯步数：** 这是导致 PI 赋值的第一个回溯步骤。计数增加到 $1$。\n- **前向推导：** 当 $b=0$ 时，我们将这个值在电路中进行传播。\n    - 在故障点 $b$，正常电路的值为 $0$，而故障电路固定为 $1$。复合值为 $0/1$，用 $\\overline{D}$ 表示。\n    - 输入的状态现在是 $(a, b, c, d) = (X, 0, X, X)$。\n    - 门 $g_1 = \\mathrm{NAND}(a,b)$ 的输入是 $(X, \\overline{D})$。输出 $g_1$ 是 $\\mathrm{NAND}(X, 0/1)$。对于正常电路，$g_{1,good} = \\mathrm{NAND}(X,0) = 1$。对于故障电路，$g_{1,faulty} = \\mathrm{NAND}(X,1)$，这取决于 $a$，因此是未知的 ($X$)。输出 $g_1$ 是 $1/X$，这在我们的五值代数中不是一个单一值，所以 $g_1$ 保持为 $X$。\n    - D-边界，即输入存在故障效应但输出尚未出现故障效应的门的集合，包含门 $g_1$。\n    - 所有其他节点，$g_2$ 和 $z$，保持为 $X$。\n\n**迭代 2：从 $g_1$ 开始的故障传播**\n下一个目标是从 D-边界传播故障效应。D-边界目前只包含门 $g_1$。\n- **目标：** 为了从门 $g_1 = \\mathrm{NAND}(a,b)$ 的输入 $b$ 传播 $\\overline{D}$，另一个输入 $a$ 必须被设置为该门的非控值。对于 NAND 门，非控值为 $1$。因此，目标是 $(a, 1)$。\n- **回溯：** 节点 $a$ 是一个主输入。从 $(a, 1)$ 开始的回溯在主输入 $a$ 处终止。\n- **PI 赋值：** 此步骤导致赋值 $a=1$。\n- **回溯步数：** 这是第二个回溯步骤。计数增加到 $1+1=2$。\n- **前向推导：** 当 PI 为 $(a, b, c, d) = (1, 0, X, X)$ 时，我们重新评估电路。\n    - $a=1$ 且 $b=\\overline{D}$ ($0/1$)。\n    - $g_1 = \\mathrm{NAND}(a,b) = \\mathrm{NAND}(1, \\overline{D})$。\n        - 正常电路：$g_{1,good} = \\mathrm{NAND}(1,0) = 1$。\n        - 故障电路：$g_{1,faulty} = \\mathrm{NAND}(1,1) = 0$。\n        - 复合输出为 $1/0$，即 $D$。故障效应现在位于 $g_1$。\n    - $g_2 = \\mathrm{AND}(c,d) = \\mathrm{AND}(X,X) = X$。\n    - $z = \\mathrm{OR}(g_1,g_2) = \\mathrm{OR}(D,X)$。输出 $z$ 仍然是未知的。\n    - D-边界现在是门 $z$，因为它的一个输入 ($g_1$) 上有 $D$，而其输出还不是 $D$ 或 $\\overline{D}$。\n\n**迭代 3：从 $z$ 开始的故障传播**\n最后一步是通过主输出门 $z$ 传播故障效应。\n- **目标：** 为了从门 $z = \\mathrm{OR}(g_1,g_2)$ 的输入 $g_1$ 传播 $D$，另一个输入 $g_2$ 必须被设置为该门的非控值。对于 OR 门，非控值为 $0$。目标是 $(g_2, 0)$。\n- **回溯：** 节点 $g_2$ 不是主输入。我们必须从 $g_2$ 回溯，以找到一个能实现 $g_2=0$ 的主输入赋值。该门是 $g_2 = \\mathrm{AND}(c,d)$。要将其输出设置为 $0$，我们可以设置 $c=0$ 或 $d=0$。问题提供了一个冲突解决规则：“回溯过程优先选择 $c$ 而不是 $d$”。因此，我们选择目标 $(c, 0)$。节点 $c$ 是一个主输入，所以回溯终止。\n- **PI 赋值：** 此步骤导致赋值 $c=0$。\n- **回溯步数：** 这是第三个回溯步骤。计数增加到 $2+1=3$。\n- **前向推导：** 当 PI 为 $(a, b, c, d) = (1, 0, 0, X)$ 时，我们进行最终评估。\n    - $g_1$ 根据之前的赋值仍然是 $D$。\n    - $g_2 = \\mathrm{AND}(c,d) = \\mathrm{AND}(0,X) = 0$。\n    - $z = \\mathrm{OR}(g_1,g_2) = \\mathrm{OR}(D,0)$。\n        - 正常电路：$z_{good} = \\mathrm{OR}(1,0) = 1$。\n        - 故障电路：$z_{faulty} = \\mathrm{OR}(0,0) = 0$。\n        - 复合输出为 $1/0$，即 $D$。\n- **结论：** 故障效应 $D$ 已到达主输出 $z$。故障被检测到。PI 向量 $(a,b,c,d) = (1,0,0,X)$ 是该算法找到的第一个检测测试图形。过程成功终止。\n\n回溯步骤的总数是每次 PI 赋值计数的总和。在此过程中，共有三个这样的步骤。\n1. 目标 $(b,0)$ 导致 PI 赋值 $b=0$。（1 步）\n2. 目标 $(a,1)$ 导致 PI 赋值 $a=1$。（1 步）\n3. 目标 $(g_2,0)$ 导致子目标 $(c,0)$，后者导致 PI 赋值 $c=0$。（1 步）\n\n所需的最小总回溯步数为 $3$。",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "确定性算法虽然强大，但也可能遇到严峻的挑战，尤其是在具有重聚扇出的电路中。最后一个练习展示了一个经典的故障屏蔽案例，其中沿多条路径传播的故障效应会自我抵消。通过分析这一场景，你将理解局部传播规则的一个根本局限性，并体会到为何 ATPG 必须考虑电路的全局拓扑结构。",
            "id": "4265573",
            "problem": "考虑一个组合电路片段，其主输入为 $c$ 和 $d$，一个内部信号 $u$ 定义为 $u = c \\land d$。信号 $u$馈入一个重聚扇出结构：它分裂成两个兄弟信号 $x$ 和 $y$，这两个信号是简单的缓冲器连接 $x = u$ 和 $y = u$。这两个兄弟信号通过一个异或门在主输出 $z$ 处重聚，即 $z = x \\oplus y$。假设在 $u$ 处存在一个单一固定型故障，具体为 $u$ 固定于$0$。使用D算法的基本五值代数（其中 $D$ 表示正常电路中的值为 $1$ 而故障电路中为 $0$，$\\overline{D}$ 表示正常电路中为 $0$ 而故障电路中为 $1$），以及面向路径的决策（PODEM）过程的目标/回溯范式。仅从固定型故障的激励和传播的核心定义，以及 $\\land$ 和 $\\oplus$ 门的真值表（包括控制值和非控制值的概念）出发，推导在 $z$ 处观测到故障效应所需的对兄弟信号 $x$ 和 $y$ 的传播要求，并说明这些要求如何冲突从而在 $u$ 处产生矛盾。然后，计算能够检测到在 $z$ 处的 $u$ 固定于$0$ 故障的主输入赋值 $(c,d) \\in \\{0,1\\}^{2}$ 的数量。以整数形式表示最终答案。无需四舍五入。",
            "solution": "该问题是有效的，因为它具有科学依据、提法明确、客观且一致。它展示了带有重聚扇出的电路中故障屏蔽的一个经典例子，这是电子设计自动化（EDA）和集成电路测试领域的一个基本主题。\n\n对于指定的故障 $u$ 固定于 $0$，分析给定电路需要一个两步过程，这对于所有确定性ATPG（自动测试图形生成）算法都是基础的：故障激励和故障传播。我们将使用五值代数 $\\{0, 1, D, \\overline{D}, X\\}$，其中 $D$ 代表正常电路中的逻辑 $1$ 和故障电路中的逻辑 $0$（$1/0$），而 $\\overline{D}$ 代表正常电路中的逻辑 $0$ 和故障电路中的逻辑 $1$（$0/1$）。\n\n**1. 故障激励**\n\n该故障被指定为内部信号线 $u$ 固定于 $0$。为激励此故障，我们必须建立一个输入条件，在无故障（正常）电路中迫使信号 $u$ 达到相反的值，即 $1$。如果正常电路中 $u$ 为 $1$，则固定于 $0$ 的故障将使其在故障电路中变为 $0$。这种差异由复合符号 $D$ 捕获。\n\n信号 $u$ 由与门 $u = c \\land d$ 定义。为了使与门的输出为 $1$，其所有输入都必须为 $1$。\n$$ u_{\\text{good}} = 1 \\iff (c=1 \\text{ and } d=1) $$\n这就是故障激励条件。当满足此条件时，节点 $u$ 处的信号为：\n$$ u = u_{\\text{good}} / u_{\\text{faulty}} = 1/0 = D $$\n对于 $(c,d)$ 的任何其他输入赋值，即 $(0,0)$、$(0,1)$ 或 $(1,0)$，都会导致 $u_{\\text{good}} = 0$。在这些情况下，正常电路的值与固定于 $0$ 的值相匹配，故障未被激励。因此，唯一可能检测到 $u$ 固定于 $0$ 故障的主输入赋值是 $(c,d) = (1,1)$。\n\n**2. 故障传播与矛盾分析**\n\n一旦故障被激励，故障效应（现在由节点 $u$ 处的信号 $D$ 表示）必须被传播到一个主输出。在这个电路中，主输出是 $z$。信号 $u=D$ 扇出到两个兄弟信号 $x$ 和 $y$。由于 $x$ 和 $y$ 是从 $u$ 出发的简单缓冲器连接，故障信号直接传播到它们：\n$$ x = u = D $$\n$$ y = u = D $$\n这两个信号 $x$ 和 $y$ 在计算主输出 $z = x \\oplus y$ 的异或（XOR）门处重聚。\n\n传播的核心任务是使门的输出对其中一个输入上的故障敏感。对于一个异或门 $z = A \\oplus B$，如果输入 $B$ 保持在一个恒定值（$0$ 或 $1$），那么输出 $z$ 将反映输入 $A$ 上的故障。具体来说：\n- 如果 $B=0$，那么 $z = A \\oplus 0 = A$。$A$ 处的信号传播到 $z$。\n- 如果 $B=1$，那么 $z = A \\oplus 1 = \\neg A$。$A$ 处的反相信号传播到 $z$。输入端的信号 $D$ 在输出端会变成 $\\overline{D}$。\n\n遵循这一原则，要将故障效应从输入 $x$ 传播到输出 $z$，要求将输入 $y$ 设置为一个恒定值，即 $0$ 或 $1$。让我们以 PODEM 算法的风格将此形式化为一个目标。\n\n**目标：** 将故障传播到 $z$。这意味着 $z$ 必须是 $D$ 或 $\\overline{D}$。\n\n为了从门 $z=x \\oplus y$ 得到 $z=D$ 或 $z=\\overline{D}$，我们必须将一个输入设置为携带故障信号（例如 $x=D$），并将另一个输入设置为一个敏化的、恒定的值（例如 $y=0$ 或 $y=1$）。让我们将传播目标设定为：\n$$ \\text{Objective: } (x=D) \\land (y=0) $$\n这代表了通过用 $y=0$ 来敏化路径，从而尝试通过 $x$ 传播故障信号。\n\n现在，我们必须通过回溯到主输入来证明这些值的合理性。\n- 要求 $x=D$ 意味着 $u=D$。正如在故障激励阶段所确定的，这需要主输入赋值为 $(c,d) = (1,1)$。\n- 现在我们检查第二个要求 $y=0$ 是否与此赋值一致。当 $(c,d) = (1,1)$ 时，我们已经确定 $u=D$。由于 $y$ 连接到 $u$，这意味着 $y=D$。\n\n矛盾就在于此。传播目标要求 $y=0$。然而，唯一满足目标第一部分（$x=D$）的输入赋值同时迫使 $y=D$。值 $y$ 不能同时是 $0$（即 $0/0$）和 $D$（即 $1/0$）。这两个要求是相互排斥的。\n\n让我们检查另一种敏化可能性，$y=1$：\n$$ \\text{Objective: } (x=D) \\land (y=1) $$\n同样，$x=D$ 需要 $(c,d)=(1,1)$，这反过来又迫使 $y=D$。这与要求 $y=1$ 相矛盾。\n\n这种要求的冲突表明，不可能敏化一条从故障位置到主输出的路径。重聚扇出结构导致故障效应出现在异或门的两个输入端。当相同的故障信号到达一个异或门时，它们会相互抵消。这种现象被称为故障屏蔽。\n\n让我们为输入赋值 $(c,d)=(1,1)$ 明确地计算 $z$ 的值：\n- 在正常电路中：$c=1, d=1 \\implies u=1 \\implies x=1, y=1$。因此，$z_{\\text{good}} = x_{\\text{good}} \\oplus y_{\\text{good}} = 1 \\oplus 1 = 0$。\n- 在故障电路中：$u$ 固定于 $0$，所以 $u=0 \\implies x=0, y=0$。因此，$z_{\\text{faulty}} = x_{\\text{faulty}} \\oplus y_{\\text{faulty}} = 0 \\oplus 0 = 0$。\n\n输出 $z$ 在正常和故障电路中都为 $0$。复合信号是 $z = z_{\\text{good}} / z_{\\text{faulty}} = 0/0 = 0$。该故障在 $z$ 处是不可观测的。\n\n**3. 计算能检测到故障的输入赋值数量**\n\n我们已经确定了以下几点：\n1. 唯一能激励 $u$ 固定于 $0$ 故障的输入赋值是 $(c,d)=(1,1)$。\n2. 对于这个特定的输入赋值，由于重聚扇出结构，故障效应在主输出 $z$ 处被屏蔽了。\n3. 所有其他的输入赋值——$(0,0)$、$(0,1)$ 和 $(1,0)$——都不能激励该故障，因此正常电路和故障电路的行为完全相同。\n\n因此，在集合 $\\{0,1\\}^2$ 中，没有任何主输入赋值能够检测到在主输出 $z$ 处的 $u$ 固定于 $0$ 故障。这样的赋值数量为 $0$。",
            "answer": "$$ \\boxed{0} $$"
        }
    ]
}