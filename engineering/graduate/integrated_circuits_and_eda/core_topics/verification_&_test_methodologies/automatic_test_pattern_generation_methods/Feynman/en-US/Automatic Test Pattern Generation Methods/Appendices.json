{
    "hands_on_practices": [
        {
            "introduction": "To truly grasp the fundamentals of Automatic Test Pattern Generation (ATPG), there is no substitute for walking through the mechanics of a foundational algorithm. This first practice requires you to manually derive a test vector using the D-Algorithm, a pioneering method that established the core ATPG principles of fault activation, propagation, and justification . Working through this process step-by-step will build a strong intuition for the deterministic logic required to make a fault visible at a circuit's output.",
            "id": "4256794",
            "problem": "Consider a combinational circuit used in Automatic Test Pattern Generation (ATPG) within Electronic Design Automation (EDA). The circuit has primary inputs $\\{a,b,c,d,e\\}$, one internal fault site, and a single primary output $y$. The gate-level structure is defined by the following Boolean functions:\n$$n_{1} = \\operatorname{NAND}(a,b), \\quad n_{2} = \\operatorname{NAND}(c,d), \\quad n_{3} = \\operatorname{XOR}(n_{1},e),$$\n$$n_{4} = \\operatorname{AND}(n_{2},n_{3}), \\quad n_{5} = \\operatorname{OR}(b,n_{4}), \\quad y = \\operatorname{AND}(n_{5},a).$$\nAssume a single stuck-at fault model with a fault at line $n_{2}$ of type stuck-at-$1$. Use the D-Algorithm with five-valued logic $\\{0,1,X,D,\\overline{D}\\}$, where $D$ denotes a value of $1$ in the fault-free circuit and $0$ in the faulty circuit, and $\\overline{D}$ denotes a value of $0$ in the fault-free circuit and $1$ in the faulty circuit. Using only fundamental definitions of stuck-at fault activation and propagation, and the notions of controlling and non-controlling values of standard logic gates (for example, for $\\operatorname{AND}$ the controlling value is $0$ and the non-controlling value is $1$; for $\\operatorname{OR}$ the controlling value is $1$ and the non-controlling value is $0$), perform constraint propagation and justification to derive a complete primary input assignment that detects the stuck-at-$1$ fault at $n_{2}$ at the primary output $y$. Explicitly reason about fault activation at $n_{2}$, sensitization of the path to $y$, and justification back to the primary inputs.\n\nExpress your final primary input vector in the order $\\left[a,b,c,d,e\\right]$ as a row matrix containing only the numeric values $0$ and $1$. No rounding is required, and there are no physical units to report.",
            "solution": "The problem requires the derivation of a test vector for a single stuck-at-1 fault at line $n_{2}$ in a given combinational circuit. The methodology to be employed is the D-Algorithm, which involves three fundamental steps: fault activation, fault propagation, and line justification. We will use the five-valued logic alphabet $\\{0, 1, X, D, \\overline{D}\\}$, where $D$ represents a $1$ in the fault-free circuit and a $0$ in the faulty circuit, and $\\overline{D}$ represents a $0$ in the fault-free circuit and a $1$ in the faulty circuit.\n\nThe circuit is defined by the Boolean functions:\n$$n_{1} = \\operatorname{NAND}(a,b)$$\n$$n_{2} = \\operatorname{NAND}(c,d)$$\n$$n_{3} = \\operatorname{XOR}(n_{1},e)$$\n$$n_{4} = \\operatorname{AND}(n_{2},n_{3})$$\n$$n_{5} = \\operatorname{OR}(b,n_{4})$$\n$$y = \\operatorname{AND}(n_{5},a)$$\nThe fault is specified as $n_{2}$ stuck-at-1 (s-a-1).\n\n**Step 1: Fault Activation**\n\nTo activate the stuck-at-1 fault at line $n_{2}$, we must drive the line to the opposite value, $0$, in the fault-free circuit. The gate driving line $n_{2}$ is $n_{2} = \\operatorname{NAND}(c,d)$. For the output of a $\\operatorname{NAND}$ gate to be $0$, both of its inputs must be set to the value $1$.\nTherefore, we must set the primary inputs $c=1$ and $d=1$.\n\nWith this assignment, in the fault-free circuit, $n_{2} = \\operatorname{NAND}(1,1) = 0$.\nIn the faulty circuit, line $n_{2}$ is stuck at $1$.\nThus, the composite value at line $n_{2}$ is $(0,1)$, which corresponds to the logic value $\\overline{D}$.\nThis action comprises the D-frontier. The initial primary input assignments are $c=1$ and $d=1$.\n\n**Step 2: Fault Propagation**\n\nThe fault effect, represented by $\\overline{D}$ at line $n_{2}$, must be propagated to the primary output $y$ through a sensitized path. The path from $n_{2}$ to $y$ is $n_{2} \\to n_{4} \\to n_{5} \\to y$.\n\nPropagation from $n_{2}$ to $n_{4}$:\nThe gate is $n_{4} = \\operatorname{AND}(n_{2}, n_{3})$. To propagate the value on line $n_{2}$ through this $\\operatorname{AND}$ gate, the other input, $n_{3}$, must be set to its non-controlling value, which is $1$.\nSetting $n_{3} = 1$, the output of the gate becomes $n_{4} = \\operatorname{AND}(\\overline{D}, 1)$.\nIn the fault-free circuit: $n_{4} = \\operatorname{AND}(0, 1) = 0$.\nIn the faulty circuit: $n_{4} = \\operatorname{AND}(1, 1) = 1$.\nThe composite value at line $n_{4}$ is $(0,1)$, which is $\\overline{D}$. The D-frontier has advanced to $n_{4}$. We have a new objective: $n_{3}=1$.\n\nPropagation from $n_{4}$ to $n_{5}$:\nThe gate is $n_{5} = \\operatorname{OR}(b, n_{4})$. To propagate the value on line $n_{4}$ through this $\\operatorname{OR}$ gate, the other input, $b$, must be set to its non-controlling value, which is $0$.\nSetting primary input $b=0$, the output of the gate becomes $n_{5} = \\operatorname{OR}(0, \\overline{D})$.\nIn the fault-free circuit: $n_{5} = \\operatorname{OR}(0, 0) = 0$.\nIn the faulty circuit: $n_{5} = \\operatorname{OR}(0, 1) = 1$.\nThe composite value at line $n_{5}$ is $(0,1)$, which is $\\overline{D}$. The D-frontier has advanced to $n_{5}$. We have a new primary input assignment: $b=0$.\n\nPropagation from $n_{5}$ to $y$:\nThe gate is $y = \\operatorname{AND}(n_{5}, a)$. To propagate the value on line $n_{5}$ to the primary output $y$, the other input, $a$, must be set to its non-controlling value, which is $1$.\nSetting primary input $a=1$, the output of the gate becomes $y = \\operatorname{AND}(\\overline{D}, 1)$.\nIn the fault-free circuit: $y = \\operatorname{AND}(0, 1) = 0$.\nIn the faulty circuit: $y = \\operatorname{AND}(1, 1) = 1$.\nThe composite value at the primary output $y$ is $(0,1)$, or $\\overline{D}$. The fault is now observable. We have a new primary input assignment: $a=1$.\n\nThe propagation phase is complete. The current set of constraints and assignments is:\n- Primary input assignments: $a=1, b=0, c=1, d=1$.\n- Internal line objective: $n_{3}=1$.\n\n**Step 3: Justification**\n\nThe final step is to justify the values set on internal lines by finding a consistent assignment for the remaining primary inputs. The only unjustified value is $n_{3}=1$.\nThe gate is $n_{3} = \\operatorname{XOR}(n_{1}, e)$. To achieve an output of $1$ from an $\\operatorname{XOR}$ gate, its inputs must be different. So, $(n_1, e)$ must be either $(0,1)$ or $(1,0)$.\n\nWe must first determine the value of $n_{1}$, as its inputs $a$ and $b$ have already been assigned.\n$n_{1} = \\operatorname{NAND}(a,b) = \\operatorname{NAND}(1,0) = 1$.\nThe value of $n_{1}$ is fixed to $1$ by a prior decision.\n\nNow, we substitute this value back into the objective for $n_{3}$. We require $n_{3} = \\operatorname{XOR}(1, e) = 1$.\nFor this equation to hold, the input $e$ must be $0$.\nThis sets the final primary input: $e=0$.\n\nAll internal line values are now justified by assignments to primary inputs without any contradictions.\n\nThe complete and consistent primary input vector is $[a,b,c,d,e]$.\n- From propagation: $a = 1, b = 0$.\n- From activation: $c = 1, d = 1$.\n- From justification: $e = 0$.\n\nThe resulting test vector is $[1, 0, 1, 1, 0]$.\nTo verify, under this input, the fault-free output is $y=0$ and the faulty output is $y=1$. The fault is detected.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1 & 0 & 1 & 1 & 0 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Moving from a procedural to a formal perspective, this exercise explores the complete set of solutions for a given fault. You will derive the necessary and sufficient Boolean conditions that define every possible test vector, framing the ATPG problem in a declarative way . This approach provides a powerful vantage point from which to understand and compare different ATPG algorithms, revealing that methods like the D-Algorithm and PODEM, despite their different search strategies, are both designed to find a solution within this formally defined space.",
            "id": "4256795",
            "problem": "Consider a full-scan design in which all sequential elements are rendered controllable and observable by scan, so that Automatic Test Pattern Generation (ATPG) reduces to a combinational problem on the scan-captured time frame. Let the combinational block have primary inputs $x_{1}, x_{2}, x_{3}, x_{4}, x_{5}$ and a single primary output $y$. The logic is defined by\n$$\nn_{1} = x_{1} \\land x_{2}, \\quad n_{2} = \\lnot x_{1} \\land x_{3}, \\quad n_{3} = n_{1} \\lor n_{2}, \\quad n_{4} = x_{4} \\oplus x_{5}, \\quad y = (n_{3} \\land n_{4}) \\lor (x_{2} \\land x_{5}).\n$$\nAssume the single stuck-at fault model and consider the fault where line $n_{3}$ is stuck-at-$0$. Using only first principles of the stuck-at fault model, the five-valued $D$-calculus (with symbols $0, 1, X, D, \\overline{D}$ denoting, respectively, logic $0$, logic $1$, unknown, $1/0$, and $0/1$ values in good/faulty circuits), and the definitions of controlling and non-controlling values of logic gates, do the following:\n\n- Derive, from first principles, the necessary and sufficient Boolean conditions on the primary inputs for the above fault to be detected at $y$ under full scan. You must start from the definitions of fault activation and fault effect propagation and do not use any prepackaged ATPG templates.\n- Justify, using the foundational semantics of the $D$-Algorithm (Detection Algorithm) and Path-Oriented Decision Making (PODEM), why under the full-scan assumption these two methods are equivalent in terms of the set of primary input assignments they can produce to detect the fault in this circuit.\n\nFinally, compute the exact number of distinct primary input assignments $(x_{1}, x_{2}, x_{3}, x_{4}, x_{5}) \\in \\{0,1\\}^{5}$ that detect the stuck-at-$0$ fault at $n_{3}$ and thus satisfy the derived necessary and sufficient conditions. Express your final answer as an exact integer. No rounding is required and no units are involved.",
            "solution": "The problem is assessed to be valid. It is a well-posed, scientifically grounded problem within the domain of digital logic testing, free of ambiguity or contradiction.\n\nThe problem asks for three distinct deliverables:\n1.  The derivation of the necessary and sufficient Boolean conditions on the primary inputs $(x_{1}, x_{2}, x_{3}, x_{4}, x_{5})$ to detect the stuck-at-$0$ fault at line $n_{3}$.\n2.  A justification for the equivalence of the D-Algorithm and PODEM in generating the set of test vectors for this fault under the full-scan assumption.\n3.  The exact number of distinct primary input assignments that constitute the complete test set for this fault.\n\nWe will address these in sequence, adhering to first principles as stipulated.\n\n**Part 1: Derivation of Necessary and Sufficient Conditions**\n\nThe detection of a single stuck-at fault requires two fundamental conditions to be met simultaneously:\n- **Fault Activation**: The input vector must force the faulty line to a value opposite to the stuck-at value in the good (fault-free) circuit.\n- **Fault Propagation**: The effect of the fault (the difference in signal value between the good and faulty circuit) must be propagated from the fault site to at least one primary output.\n\nThe fault under consideration is $n_{3}$ stuck-at-$0$ (SA0).\n\n**1. Fault Activation Condition**\nTo activate the $n_{3}$ SA0 fault, the value of line $n_{3}$ in the good circuit must be logic $1$. Let $n_{3, good}$ denote the value of $n_3$ in the good circuit. The activation condition is:\n$$\nn_{3, good} = 1\n$$\nThe logic for $n_{3}$ is given by $n_{3} = n_{1} \\lor n_{2}$, where $n_{1} = x_{1} \\land x_{2}$ and $n_{2} = \\lnot x_{1} \\land x_{3}$. Substituting these into the activation condition, we obtain the first part of our overall detection condition, expressed in terms of primary inputs:\n$$\n(x_{1} \\land x_{2}) \\lor (\\lnot x_{1} \\land x_{3}) = 1\n$$\n\n**2. Fault Propagation Condition**\nWith the fault activated, the value at line $n_{3}$ is $1$ in the good circuit and $0$ in the faulty circuit. Using the $D$-calculus, this is represented as $n_{3} = D$, where $D$ denotes a $1$ in the good circuit and a $0$ in the faulty circuit. This fault effect, $D$, must be propagated to the primary output $y$.\n\nThe output $y$ is defined as $y = (n_{3} \\land n_{4}) \\lor (x_{2} \\land x_{5})$. For the fault effect at $n_{3}$ to propagate to $y$, the output $y$ must be sensitive to the value of $n_{3}$. This can be formalized by requiring the Boolean partial derivative of $y$ with respect to $n_{3}$ to be $1$:\n$$\n\\frac{\\partial y}{\\partial n_{3}} = 1\n$$\nBy definition, the Boolean partial derivative is $y(n_{3}=1) \\oplus y(n_{3}=0)$, where $\\oplus$ is the exclusive-OR (XOR) operation.\nFirst, we evaluate $y$ for $n_{3}=1$ and $n_{3}=0$:\n$$\ny(n_{3}=1) = (1 \\land n_{4}) \\lor (x_{2} \\land x_{5}) = n_{4} \\lor (x_{2} \\land x_{5})\n$$\n$$\ny(n_{3}=0) = (0 \\land n_{4}) \\lor (x_{2} \\land x_{5}) = 0 \\lor (x_{2} \\land x_{5}) = x_{2} \\land x_{5}\n$$\nNow, we compute the XOR:\n$$\n\\frac{\\partial y}{\\partial n_{3}} = \\left( n_{4} \\lor (x_{2} \\land x_{5}) \\right) \\oplus (x_{2} \\land x_{5})\n$$\nUsing the identity $A \\oplus (A \\lor B) = \\lnot A \\land B$, we let $A = x_{2} \\land x_{5}$ and $B = n_{4}$. Then:\n$$\n\\frac{\\partial y}{\\partial n_{3}} = \\lnot (x_{2} \\land x_{5}) \\land n_{4}\n$$\nThe propagation condition is therefore:\n$$\nn_{4} \\land \\lnot(x_{2} \\land x_{5}) = 1\n$$\nThis single equation implies two sub-conditions that must hold simultaneously:\n1.  $n_{4} = 1$\n2.  $x_{2} \\land x_{5} = 0$, which is equivalent to $\\lnot(x_{2} \\land x_{5}) = 1$.\n\nThis can also be understood using the concepts of controlling and non-controlling values. For the $D$ at $n_3$ to propagate through the AND gate with $n_4$, $n_4$ must be at its non-controlling value, which is $1$. This gives $n_4=1$. The output of this AND gate is then $(D \\land 1) = D$. For this $D$ to propagate through the final OR gate, the other input, $(x_2 \\land x_5)$, must be at its non-controlling value, which is $0$. This gives $x_2 \\land x_5 = 0$. This confirms the derivation.\n\nSubstituting $n_{4} = x_{4} \\oplus x_{5}$, the propagation condition in terms of primary inputs is:\n$$\n(x_{4} \\oplus x_{5} = 1) \\land (x_{2} \\land x_{5} = 0)\n$$\n\n**3. Complete Necessary and Sufficient Condition**\nThe fault is detected if and only if both the activation and propagation conditions are met. Let $T(x_1, x_2, x_3, x_4, x_5)$ be the Boolean function representing the complete test set. This function is the logical AND of all derived conditions:\n$$\nT = \\left( (x_{1} \\land x_{2}) \\lor (\\lnot x_{1} \\land x_{3}) \\right) \\land (x_{4} \\oplus x_{5}) \\land \\lnot(x_{2} \\land x_{5})\n$$\nAn input vector $(x_{1}, x_{2}, x_{3}, x_{4}, x_{5})$ detects the fault $n_3$ SA0 if and only if $T(x_1, x_2, x_3, x_4, x_5) = 1$.\n\n**Part 2: Equivalence of D-Algorithm and PODEM**\n\nUnder the full-scan assumption, the circuit under test is purely combinational. For combinational circuits, both the D-Algorithm and PODEM are *complete* algorithms. Completeness means that if a test vector exists for a given fault, the algorithm is guaranteed to find one.\n\n- The **D-Algorithm** operates on the gate-level netlist. It first generates a $D$ or $\\overline{D}$ at the fault site (activation) and then propagates this fault effect forward along a sensitized path to a primary output. Concurrently, it performs a justification step, working backward from the internal line values required for propagation to determine a consistent set of primary input values. Decisions are made on internal nodes, and conflicts are resolved via backtracking.\n\n- The **Path-Oriented Decision Making (PODEM)** algorithm operates differently. It makes decisions exclusively on the primary inputs (PIs). It uses a backtracing procedure to identify a PI assignment that will help achieve a goal (e.g., set an internal node to a required value) and then simulates forward to observe the consequences. It backtracks on PI assignments if they lead to a conflict or fail to progress toward the objective of activating and propagating the fault.\n\nThe equivalence in the set of solutions they can produce stems from their shared goal and completeness:\n1.  **Shared Objective**: Both algorithms are designed to find a PI assignment that satisfies the activation and propagation requirements for a fault. This set of requirements defines the space of all possible solutions (test vectors).\n2.  **Completeness on Combinational Circuits**: Since both algorithms are complete for combinational logic, they are both capable of finding any and all existing test vectors. The set of all valid test vectors is an inherent property of the circuit and the fault, defined by the Boolean function $T$ derived above. It is independent of the search strategy used to find a member of that set.\n3.  **Search Space vs. Search Strategy**: The D-Algorithm and PODEM differ in their *search strategy* for navigating the solution space. The D-Algorithm's search space involves internal node assignments, whereas PODEM's is restricted to PI assignments. However, the final output of both is a PI vector. Since both are complete, the union of all possible PI vectors that each algorithm *could* find is identical and corresponds to the complete test set. The differences are in computational efficiency and memory usage (PODEM is generally more efficient as it avoids the complex justification step of the D-algorithm), not in the logical scope of the solutions they can generate.\n\nThus, for this combinational problem, the set of primary input assignments that the D-Algorithm can produce is identical to the set that PODEM can produce.\n\n**Part 3: Calculation of the Number of Test Vectors**\n\nWe must count the number of 5-bit input vectors $(x_1, x_2, x_3, x_4, x_5)$ that cause the test function $T$ to evaluate to $1$.\n$$\nT = \\underbrace{\\left( (x_{1} \\land x_{2}) \\lor (\\lnot x_{1} \\land x_{3}) \\right)}_{C_1} \\land \\underbrace{(x_{4} \\oplus x_{5})}_{C_2} \\land \\underbrace{\\lnot(x_{2} \\land x_{5})}_{C_3} = 1\n$$\nLet's analyze the conditions. The variables $(x_1, x_3)$ are only in $C_1$, while $(x_4)$ is only in $C_2$. The variable $x_2$ appears in $C_1$ and $C_3$, and $x_5$ appears in $C_2$ and $C_3$. We can systematically count the satisfying assignments. Let's first combine conditions $C_2$ and $C_3$:\n$$\nC_{23} = (x_{4} \\oplus x_{5}) \\land \\lnot(x_{2} \\land x_{5}) = 1\n$$\nWe expand this expression:\n$$\nC_{23} = (x_{4}\\lnot x_{5} \\lor \\lnot x_{4}x_{5}) \\land (\\lnot x_{2} \\lor \\lnot x_{5})\n$$\n$$\n= (x_{4}\\lnot x_{5} \\land \\lnot x_{2}) \\lor (x_{4}\\lnot x_{5} \\land \\lnot x_{5}) \\lor (\\lnot x_{4}x_{5} \\land \\lnot x_{2}) \\lor (\\lnot x_{4}x_{5} \\land \\lnot x_{5})\n$$\nThe last term $(\\lnot x_{4}x_{5} \\land \\lnot x_{5})$ is $0$. The second term simplifies to $x_{4}\\lnot x_{5}$. By the absorption law ($A \\lor (A \\land B) = A$), the first two terms simplify to $x_{4}\\lnot x_{5}$.\n$$\nC_{23} = x_{4}\\lnot x_{5} \\lor \\lnot x_{2}\\lnot x_{4}x_{5}\n$$\nWe can count the satisfying assignments for $(x_2, x_4, x_5)$:\n- If $x_{4}=1, x_{5}=0$: The term $x_{4}\\lnot x_{5}$ is $1$, so $C_{23}=1$. This is true for any $x_2$. This gives two solutions for $(x_2, x_4, x_5)$: $(0,1,0)$ and $(1,1,0)$.\n- If this term is $0$, we need $\\lnot x_{2}\\lnot x_{4}x_{5}=1$. This requires $x_2=0, x_4=0, x_5=1$. This gives one solution: $(0,0,1)$.\nIn total, there are $2+1=3$ satisfying assignments for $(x_2, x_4, x_5)$: $(0,1,0)$, $(1,1,0)$, and $(0,0,1)$.\n\nNow we must satisfy condition $C_1 = (x_{1} \\land x_{2}) \\lor (\\lnot x_{1} \\land x_{3}) = 1$ for each of these cases. $C_1$ depends on $x_1, x_2, x_3$. The number of solutions for $(x_1, x_3)$ depends on the value of $x_2$.\n- If $x_2 = 0$: $C_1$ becomes $(x_1 \\land 0) \\lor (\\lnot x_1 \\land x_3) = \\lnot x_1 \\land x_3 = 1$. This has exactly one solution: $(x_1, x_3) = (0,1)$.\n- If $x_2 = 1$: $C_1$ becomes $(x_1 \\land 1) \\lor (\\lnot x_1 \\land x_3) = x_1 \\lor (\\lnot x_1 \\land x_3)$. Using the identity $A \\lor (\\lnot A \\land B) = A \\lor B$, this is $x_1 \\lor x_3 = 1$. This has three solutions for $(x_1, x_3)$: $(0,1)$, $(1,0)$, and $(1,1)$.\n\nWe can now find the total count by summing the contributions from the three valid $(x_2, x_4, x_5)$ tuples:\n1.  For $(x_2, x_4, x_5) = (0,1,0)$: Here $x_2=0$. The number of ways to satisfy $C_1$ is $1$. Total vectors: $1$.\n2.  For $(x_2, x_4, x_5) = (1,1,0)$: Here $x_2=1$. The number of ways to satisfy $C_1$ is $3$. Total vectors: $3$.\n3.  For $(x_2, x_4, x_5) = (0,0,1)$: Here $x_2=0$. The number of ways to satisfy $C_1$ is $1$. Total vectors: $1$.\n\nThe total number of distinct primary input assignments is the sum of these counts: $1 + 3 + 1 = 5$.\n\nThe five test vectors are:\n1.  $(x_1,x_3)=(0,1)$ and $(x_2,x_4,x_5)=(0,1,0) \\implies (0,0,1,1,0)$\n2.  $(x_1,x_3)=(0,1)$ and $(x_2,x_4,x_5)=(1,1,0) \\implies (0,1,1,1,0)$\n3.  $(x_1,x_3)=(1,0)$ and $(x_2,x_4,x_5)=(1,1,0) \\implies (1,1,0,1,0)$\n4.  $(x_1,x_3)=(1,1)$ and $(x_2,x_4,x_5)=(1,1,0) \\implies (1,1,1,1,0)$\n5.  $(x_1,x_3)=(0,1)$ and $(x_2,x_4,x_5)=(0,0,1) \\implies (0,0,1,0,1)$\n\nThe final count is 5.",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "This final practice tackles the challenges of testing in modern System-on-Chip (SoC) designs, which often integrate complex third-party intellectual property (IP) cores as black boxes. You will construct a probabilistic model to determine the required test length, accounting for real-world factors like test wrappers, random pattern resistance, and response compaction using a Multiple-Input Signature Register (MISR) . This problem illustrates how fundamental ATPG concepts are adapted to assess and ensure test quality in large, heterogeneous systems where a complete structural view is unavailable.",
            "id": "4256847",
            "problem": "Consider a system-on-chip that integrates a third-party macro treated as a black box during Automatic Test Pattern Generation (ATPG). The macro is accessed through a wrapper that applies constrained pseudo-random stimuli at its inputs and compacts its responses with a Multiple-Input Signature Register (MISR). Assume the following foundational definitions and modeling assumptions, all of which are standard and well tested in integrated circuits and Electronic Design Automation (EDA):\n\n1. For each internal single stuck-at fault inside the macro, a pattern detects the fault if three independent events occur at the macro boundary: a legal input assignment is applied, the fault is activated by that input, and the fault effect propagates to at least one macro output. Let the probability that a randomly generated top-level pattern produces a legal assignment at the macro inputs be $r$. Conditional on legality, let the activation probability for a fault from class $\\mathcal{C}_{1}$ be $a_{1}$ and its propagation probability be $g_{1}$; likewise, for a fault from class $\\mathcal{C}_{2}$, let the activation and propagation probabilities be $a_{2}$ and $g_{2}$.\n2. The wrapper includes an output masking mechanism that independently masks each macro output bit with probability $x$ on any given pattern due to unknown (do-not-care) values. For a detected fault effect that manifests on exactly one macro output bit on a given pattern, the effect survives masking with probability $(1 - x)$.\n3. The macro responses are compacted by an $m$-bit MISR. For a fault that produces at least one unmasked response difference across a test sequence, the probability that the final MISR signature aliases to the fault-free signature is $2^{-m}$.\n4. Patterns are applied independently, and the above events are independent across patterns.\n\nThe fault population inside the macro is modeled as a mixture: a fraction $\\alpha$ belongs to class $\\mathcal{C}_{1}$ and a fraction $(1 - \\alpha)$ belongs to class $\\mathcal{C}_{2}$. All faults within a class share the same per-pattern detectability parameters. Let $N$ denote the number of patterns applied to the macro via the wrapper.\n\nStarting from the definitions above and the independence assumptions, derive the exact analytic expression for the expected effective fault coverage after $N$ patterns, where “effective” means the probability that the final MISR signature differs from the fault-free signature for a randomly selected fault from the population. Then, using the parameter values\n$r = 0.4$, $x = 0.1$, $m = 8$, $\\alpha = 0.7$, $a_{1} = 0.2$, $g_{1} = 0.6$, $a_{2} = 0.05$, $g_{2} = 0.3$, and a target effective coverage of $0.95$, determine the minimal integer $N$ that achieves at least the target effective coverage. Express your final answer as the minimal integer $N$; no rounding by significant figures is required since $N$ is an exact count.",
            "solution": "The problem requires the derivation of an expression for the expected effective fault coverage for a mixed population of faults and then the calculation of the minimum number of test patterns, $N$, to achieve a target coverage.\n\nFirst, I will derive the analytic expression for the expected effective fault coverage, $FC_{eff}(N)$.\nThe effective fault coverage is defined as the probability that the final Multiple-Input Signature Register (MISR) signature differs from the fault-free signature for a randomly selected fault. The fault population is a mixture of two classes, $\\mathcal{C}_{1}$ and $\\mathcal{C}_{2}$.\nLet $C_1$ be the event that a randomly selected fault belongs to class $\\mathcal{C}_{1}$, and $C_2$ be the event that it belongs to class $\\mathcal{C}_{2}$. We are given $P(C_1) = \\alpha$ and $P(C_2) = 1-\\alpha$.\nLet $D$ be the event that the final MISR signature is different from the fault-free signature.\nThe expected effective fault coverage is $FC_{eff}(N) = P(D)$.\nBy the law of total probability, we can write:\n$$FC_{eff}(N) = P(D|C_1)P(C_1) + P(D|C_2)P(C_2)$$\n$$FC_{eff}(N) = \\alpha P(D|C_1) + (1-\\alpha) P(D|C_2)$$\n\nNow, let's determine $P(D|C_i)$ for a generic fault class $\\mathcal{C}_i$, where $i \\in \\{1, 2\\}$.\nA different signature is produced if two conditions are met:\n1. The fault effect is observed at the MISR input at least once over the $N$ patterns. Let's call this event $O_i$. An observed effect is one that is detected at the macro outputs and is not masked by the wrapper.\n2. The MISR does not alias. The problem states that the aliasing probability, conditional on at least one observed fault effect, is $2^{-m}$.\n\nSo, the event $D$ for a fault from class $\\mathcal{C}_i$ is the intersection of $O_i$ and the event of no aliasing.\n$$P(D|C_i) = P(O_i \\cap \\text{no alias}) = P(\\text{no alias}|O_i) P(O_i)$$\nWe are given $P(\\text{alias}|O_i) = 2^{-m}$, so $P(\\text{no alias}|O_i) = 1 - 2^{-m}$.\nThus, $P(D|C_i) = P(O_i)(1 - 2^{-m})$.\n\nNext, we must find $P(O_i)$, the probability that a fault from class $\\mathcal{C}_i$ is observed at least once in $N$ patterns. It is easier to calculate the probability of the complementary event, i.e., that the fault is *never* observed in $N$ patterns.\nLet $p_{\\text{obs},i}$ be the probability that a fault from class $\\mathcal{C}_i$ is observed on a single, randomly applied pattern.\nSince patterns are applied independently, the probability of the fault never being observed in $N$ patterns is $(1 - p_{\\text{obs},i})^N$.\nTherefore, $P(O_i) = 1 - (1 - p_{\\text{obs},i})^N$.\n\nNow we must determine $p_{\\text{obs},i}$. According to the problem statement, for a fault effect to be observed, a sequence of independent events must occur for a single pattern:\n1. A legal input assignment is applied to the macro. The probability is $p_L = r$.\n2. The fault is activated. Conditional on a legal input, the probability is $p_{A|L,i} = a_i$.\n3. The fault effect propagates to a macro output. Conditional on a legal input, the probability is $p_{G|L,i} = g_i$. The problem implies activation and propagation are conditionally independent given a legal input.\n4. The propagated fault effect is not masked by the wrapper. The survival probability is $p_S = 1 - x$.\n\nThe probability of a fault from class $\\mathcal{C}_i$ being detected at the macro outputs is the probability of a legal input, activation, and propagation:\n$$p_{\\text{detect},i} = P(L \\cap A_i \\cap G_i) = P(A_i \\cap G_i|L)P(L) = P(A_i|L)P(G_i|L)P(L) = a_i g_i r$$\nThe probability of this detected effect being observed after the masking stage is:\n$$p_{\\text{obs},i} = p_{\\text{detect},i} \\times p_S = r a_i g_i (1-x)$$\n\nCombining these results, we get:\n$$P(D|C_i) = \\left[1 - (1 - r a_i g_i (1-x))^N\\right](1 - 2^{-m})$$\n\nSubstituting this back into the expression for $FC_{eff}(N)$:\n$$FC_{eff}(N) = \\left( \\alpha \\left[1 - (1 - p_{\\text{obs},1})^N\\right] + (1-\\alpha) \\left[1 - (1 - p_{\\text{obs},2})^N\\right] \\right) (1 - 2^{-m})$$\nwhere $p_{\\text{obs},1} = r a_1 g_1 (1-x)$ and $p_{\\text{obs},2} = r a_2 g_2 (1-x)$.\nThis expression can be simplified:\n$$FC_{eff}(N) = \\left( \\alpha - \\alpha(1-p_{\\text{obs},1})^N + 1 - \\alpha - (1-\\alpha)(1-p_{\\text{obs},2})^N \\right) (1 - 2^{-m})$$\n$$FC_{eff}(N) = \\left( 1 - \\left[\\alpha(1-p_{\\text{obs},1})^N + (1-\\alpha)(1-p_{\\text{obs},2})^N\\right] \\right) (1 - 2^{-m})$$\nThis is the required analytic expression for the expected effective fault coverage.\n\nNow, we must find the minimal integer $N$ that achieves a target coverage of $0.95$.\nThe parameter values are:\n$r = 0.4$, $x = 0.1$, $m = 8$, $\\alpha = 0.7$, $a_{1} = 0.2$, $g_{1} = 0.6$, $a_{2} = 0.05$, $g_{2} = 0.3$.\nTarget $FC_{eff} \\ge 0.95$.\n\nFirst, calculate the single-pattern observation probabilities:\n$$1 - x = 1 - 0.1 = 0.9$$\n$$p_{\\text{obs},1} = r a_1 g_1 (1-x) = (0.4)(0.2)(0.6)(0.9) = 0.0432$$\n$$p_{\\text{obs},2} = r a_2 g_2 (1-x) = (0.4)(0.05)(0.3)(0.9) = 0.0054$$\n\nNext, calculate the non-aliasing factor:\n$$1 - 2^{-m} = 1 - 2^{-8} = 1 - \\frac{1}{256} = \\frac{255}{256}$$\n\nThe inequality to solve for $N$ is:\n$$FC_eff(N) = \\left( 1 - \\left[0.7(1-0.0432)^N + 0.3(1-0.0054)^N\\right] \\right) \\frac{255}{256} \\ge 0.95$$\nLet's rearrange the inequality to solve for the term containing $N$:\n$$1 - \\left[0.7(0.9568)^N + 0.3(0.9946)^N\\right] \\ge 0.95 \\cdot \\frac{256}{255}$$\nThe right-hand side is $0.95 \\cdot \\frac{256}{255} = \\frac{19}{20} \\cdot \\frac{256}{255} = \\frac{4864}{5100} = \\frac{1216}{1275}$.\n$$0.7(0.9568)^N + 0.3(0.9946)^N \\le 1 - \\frac{1216}{1275}$$\n$$0.7(0.9568)^N + 0.3(0.9946)^N \\le \\frac{59}{1275}$$\nThe threshold value is $\\frac{59}{1275} \\approx 0.0462745$.\nLet $f(N) = 0.7(0.9568)^N + 0.3(0.9946)^N$. We need to find the smallest integer $N$ for which $f(N) \\le \\frac{59}{1275}$.\nThe function $f(N)$ is a sum of two positive, strictly decreasing functions of $N$, so $f(N)$ is also strictly decreasing. We can find the minimal $N$ by testing integer values.\n\nFor large $N$, the term $(0.9946)^N$ will dominate because it decays more slowly. A lower bound for $N$ can be estimated by considering this term alone:\n$$0.3(0.9946)^N < \\frac{59}{1275}$$\n$$(0.9946)^N < \\frac{59}{1275 \\cdot 0.3} = \\frac{59}{382.5} \\approx 0.15425$$\n$$N \\ln(0.9946) < \\ln(0.15425)$$\n$$N > \\frac{\\ln(0.15425)}{\\ln(0.9946)} \\approx \\frac{-1.869}{-0.005415} \\approx 345.15$$\nThis suggests $N$ will be close to $346$. Let's test $N=345$ and $N=346$.\n\nFor $N = 345$:\n$$f(345) = 0.7(0.9568)^{345} + 0.3(0.9946)^{345}$$\nUsing a calculator for higher precision:\n$$(0.9568)^{345} \\approx 2.1852 \\times 10^{-7}$$\n$$(0.9946)^{345} \\approx 0.15439$$\n$$f(345) \\approx 0.7(2.1852 \\times 10^{-7}) + 0.3(0.15439) \\approx 1.5296 \\times 10^{-7} + 0.046317 \\approx 0.0463171$$\nWe compare this to the threshold: $f(345) \\approx 0.0463171 > \\frac{59}{1275} \\approx 0.0462745$.\nThe condition is not met for $N = 345$.\n\nFor $N = 346$:\n$$f(346) = 0.7(0.9568)^{346} + 0.3(0.9946)^{346}$$\n$$f(346) = f(345) \\text{ with exponents incremented by 1}$$\n$$(0.9568)^{346} \\approx (2.1852 \\times 10^{-7}) \\cdot 0.9568 \\approx 2.0906 \\times 10^{-7}$$\n$$(0.9946)^{346} \\approx (0.15439) \\cdot 0.9946 \\approx 0.15355$$\n$$f(346) \\approx 0.7(2.0906 \\times 10^{-7}) + 0.3(0.15355) \\approx 1.4634 \\times 10^{-7} + 0.046065 \\approx 0.0460651$$\nWe compare this to the threshold: $f(346) \\approx 0.0460651 < \\frac{59}{1275} \\approx 0.0462745$.\nThe condition is met for $N = 346$.\n\nSince $f(N)$ is a strictly decreasing function of $N$, the minimal integer value of $N$ that satisfies the inequality is $346$.",
            "answer": "$$\\boxed{346}$$"
        }
    ]
}