{
    "hands_on_practices": [
        {
            "introduction": "This exercise provides a foundational, step-by-step application of the D-Algorithm, one of the pioneering methods in Automatic Test Pattern Generation (ATPG). By manually working through the distinct phases of fault activation, propagation, and line justification, you will gain a concrete understanding of how test vectors are systematically derived for combinational circuits. This hands-on process is crucial for visualizing the core logic that underpins more complex, automated ATPG tools .",
            "id": "4256794",
            "problem": "Consider a combinational circuit used in Automatic Test Pattern Generation (ATPG) within Electronic Design Automation (EDA). The circuit has primary inputs $\\{a,b,c,d,e\\}$, one internal fault site, and a single primary output $y$. The gate-level structure is defined by the following Boolean functions:\n$$n_{1} = \\operatorname{NAND}(a,b), \\quad n_{2} = \\operatorname{NAND}(c,d), \\quad n_{3} = \\operatorname{XOR}(n_{1},e),$$\n$$n_{4} = \\operatorname{AND}(n_{2},n_{3}), \\quad n_{5} = \\operatorname{OR}(b,n_{4}), \\quad y = \\operatorname{AND}(n_{5},a).$$\nAssume a single stuck-at fault model with a fault at line $n_{2}$ of type stuck-at-$1$. Use the D-Algorithm with five-valued logic $\\{0,1,X,D,\\overline{D}\\}$, where $D$ denotes a value of $1$ in the fault-free circuit and $0$ in the faulty circuit, and $\\overline{D}$ denotes a value of $0$ in the fault-free circuit and $1$ in the faulty circuit. Using only fundamental definitions of stuck-at fault activation and propagation, and the notions of controlling and non-controlling values of standard logic gates (for example, for $\\operatorname{AND}$ the controlling value is $0$ and the non-controlling value is $1$; for $\\operatorname{OR}$ the controlling value is $1$ and the non-controlling value is $0$), perform constraint propagation and justification to derive a complete primary input assignment that detects the stuck-at-$1$ fault at $n_{2}$ at the primary output $y$. Explicitly reason about fault activation at $n_{2}$, sensitization of the path to $y$, and justification back to the primary inputs.\n\nExpress your final primary input vector in the order $\\left[a,b,c,d,e\\right]$ as a row matrix containing only the numeric values $0$ and $1$. No rounding is required, and there are no physical units to report.",
            "solution": "The problem requires the derivation of a test vector for a single stuck-at-1 fault at line $n_{2}$ in a given combinational circuit. The methodology to be employed is the D-Algorithm, which involves three fundamental steps: fault activation, fault propagation, and line justification. We will use the five-valued logic alphabet $\\{0, 1, X, D, \\overline{D}\\}$, where $D$ represents a $1$ in the fault-free circuit and a $0$ in the faulty circuit, and $\\overline{D}$ represents a $0$ in the fault-free circuit and a $1$ in the faulty circuit.\n\nThe circuit is defined by the Boolean functions:\n$$n_{1} = \\operatorname{NAND}(a,b)$$\n$$n_{2} = \\operatorname{NAND}(c,d)$$\n$$n_{3} = \\operatorname{XOR}(n_{1},e)$$\n$$n_{4} = \\operatorname{AND}(n_{2},n_{3})$$\n$$n_{5} = \\operatorname{OR}(b,n_{4})$$\n$$y = \\operatorname{AND}(n_{5},a)$$\nThe fault is specified as $n_{2}$ stuck-at-1 (s-a-1).\n\n**Step 1: Fault Activation**\n\nTo activate the stuck-at-1 fault at line $n_{2}$, we must drive the line to the opposite value, $0$, in the fault-free circuit. The gate driving line $n_{2}$ is $n_{2} = \\operatorname{NAND}(c,d)$. For the output of a $\\operatorname{NAND}$ gate to be $0$, both of its inputs must be set to the value $1$.\nTherefore, we must set the primary inputs $c=1$ and $d=1$.\n\nWith this assignment, in the fault-free circuit, $n_{2} = \\operatorname{NAND}(1,1) = 0$.\nIn the faulty circuit, line $n_{2}$ is stuck at $1$.\nThus, the composite value at line $n_{2}$ is $(0,1)$, which corresponds to the logic value $\\overline{D}$.\nThis action comprises the D-frontier. The initial primary input assignments are $c=1$ and $d=1$.\n\n**Step 2: Fault Propagation**\n\nThe fault effect, represented by $\\overline{D}$ at line $n_{2}$, must be propagated to the primary output $y$ through a sensitized path. The path from $n_{2}$ to $y$ is $n_{2} \\to n_{4} \\to n_{5} \\to y$.\n\nPropagation from $n_{2}$ to $n_{4}$:\nThe gate is $n_{4} = \\operatorname{AND}(n_{2}, n_{3})$. To propagate the value on line $n_{2}$ through this $\\operatorname{AND}$ gate, the other input, $n_{3}$, must be set to its non-controlling value, which is $1$.\nSetting $n_{3} = 1$, the output of the gate becomes $n_{4} = \\operatorname{AND}(\\overline{D}, 1)$.\nIn the fault-free circuit: $n_{4} = \\operatorname{AND}(0, 1) = 0$.\nIn the faulty circuit: $n_{4} = \\operatorname{AND}(1, 1) = 1$.\nThe composite value at line $n_{4}$ is $(0,1)$, which is $\\overline{D}$. The D-frontier has advanced to $n_{4}$. We have a new objective: $n_{3}=1$.\n\nPropagation from $n_{4}$ to $n_{5}$:\nThe gate is $n_{5} = \\operatorname{OR}(b, n_{4})$. To propagate the value on line $n_{4}$ through this $\\operatorname{OR}$ gate, the other input, $b$, must be set to its non-controlling value, which is $0$.\nSetting primary input $b=0$, the output of the gate becomes $n_{5} = \\operatorname{OR}(0, \\overline{D})$.\nIn the fault-free circuit: $n_{5} = \\operatorname{OR}(0, 0) = 0$.\nIn the faulty circuit: $n_{5} = \\operatorname{OR}(0, 1) = 1$.\nThe composite value at line $n_{5}$ is $(0,1)$, which is $\\overline{D}$. The D-frontier has advanced to $n_{5}$. We have a new primary input assignment: $b=0$.\n\nPropagation from $n_{5}$ to $y$:\nThe gate is $y = \\operatorname{AND}(n_{5}, a)$. To propagate the value on line $n_{5}$ to the primary output $y$, the other input, $a$, must be set to its non-controlling value, which is $1$.\nSetting primary input $a=1$, the output of the gate becomes $y = \\operatorname{AND}(\\overline{D}, 1)$.\nIn the fault-free circuit: $y = \\operatorname{AND}(0, 1) = 0$.\nIn the faulty circuit: $y = \\operatorname{AND}(1, 1) = 1$.\nThe composite value at the primary output $y$ is $(0,1)$, or $\\overline{D}$. The fault is now observable. We have a new primary input assignment: $a=1$.\n\nThe propagation phase is complete. The current set of constraints and assignments is:\n- Primary input assignments: $a=1, b=0, c=1, d=1$.\n- Internal line objective: $n_{3}=1$.\n\n**Step 3: Justification**\n\nThe final step is to justify the values set on internal lines by finding a consistent assignment for the remaining primary inputs. The only unjustified value is $n_{3}=1$.\nThe gate is $n_{3} = \\operatorname{XOR}(n_{1}, e)$. To achieve an output of $1$ from an $\\operatorname{XOR}$ gate, its inputs must be different. So, $(n_1, e)$ must be either $(0,1)$ or $(1,0)$.\n\nWe must first determine the value of $n_{1}$, as its inputs $a$ and $b$ have already been assigned.\n$n_{1} = \\operatorname{NAND}(a,b) = \\operatorname{NAND}(1,0) = 1$.\nThe value of $n_{1}$ is fixed to $1$ by a prior decision.\n\nNow, we substitute this value back into the objective for $n_{3}$. We require $n_{3} = \\operatorname{XOR}(1, e) = 1$.\nFor this equation to hold, the input $e$ must be $0$.\nThis sets the final primary input: $e=0$.\n\nAll internal line values are now justified by assignments to primary inputs without any contradictions.\n\nThe complete and consistent primary input vector is $[a,b,c,d,e]$.\n- From propagation: $a = 1, b = 0$.\n- From activation: $c = 1, d = 1$.\n- From justification: $e = 0$.\n\nThe resulting test vector is $[1, 0, 1, 1, 0]$.\nTo verify, under this input, the fault-free output is $y=0$ and the faulty output is $y=1$. The fault is detected.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 1 & 0 & 1 & 1 & 0 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "Moving beyond the search for a single test vector, this problem challenges you to characterize the entire set of solutions for a given fault. You will derive the complete Boolean conditions for fault detection and, in doing so, explore why different but complete algorithms like the D-Algorithm and Path-Oriented Decision Making (PODEM) ultimately converge on the same solution space. This practice elevates your understanding from procedural application to a more rigorous analysis of testability and algorithmic completeness .",
            "id": "4256795",
            "problem": "Consider a full-scan design in which all sequential elements are rendered controllable and observable by scan, so that Automatic Test Pattern Generation (ATPG) reduces to a combinational problem on the scan-captured time frame. Let the combinational block have primary inputs $x_{1}, x_{2}, x_{3}, x_{4}, x_{5}$ and a single primary output $y$. The logic is defined by\n$$\nn_{1} = x_{1} \\land x_{2}, \\quad n_{2} = \\lnot x_{1} \\land x_{3}, \\quad n_{3} = n_{1} \\lor n_{2}, \\quad n_{4} = x_{4} \\oplus x_{5}, \\quad y = (n_{3} \\land n_{4}) \\lor (x_{2} \\land x_{5}).\n$$\nAssume the single stuck-at fault model and consider the fault where line $n_{3}$ is stuck-at-$0$. Using only first principles of the stuck-at fault model, the five-valued $D$-calculus (with symbols $0, 1, X, D, \\overline{D}$ denoting, respectively, logic $0$, logic $1$, unknown, $1/0$, and $0/1$ values in good/faulty circuits), and the definitions of controlling and non-controlling values of logic gates, do the following:\n\n- Derive, from first principles, the necessary and sufficient Boolean conditions on the primary inputs for the above fault to be detected at $y$ under full scan. You must start from the definitions of fault activation and fault effect propagation and do not use any prepackaged ATPG templates.\n- Justify, using the foundational semantics of the $D$-Algorithm (Detection Algorithm) and Path-Oriented Decision Making (PODEM), why under the full-scan assumption these two methods are equivalent in terms of the set of primary input assignments they can produce to detect the fault in this circuit.\n\nFinally, compute the exact number of distinct primary input assignments $(x_{1}, x_{2}, x_{3}, x_{4}, x_{5}) \\in \\{0,1\\}^{5}$ that detect the stuck-at-$0$ fault at $n_{3}$ and thus satisfy the derived necessary and sufficient conditions. Express your final answer as an exact integer. No rounding is required and no units are involved.",
            "solution": "The problem is assessed to be valid. It is a well-posed, scientifically grounded problem within the domain of digital logic testing, free of ambiguity or contradiction.\n\nThe problem asks for three distinct deliverables:\n1.  The derivation of the necessary and sufficient Boolean conditions on the primary inputs $(x_{1}, x_{2}, x_{3}, x_{4}, x_{5})$ to detect the stuck-at-$0$ fault at line $n_{3}$.\n2.  A justification for the equivalence of the D-Algorithm and PODEM in generating the set of test vectors for this fault under the full-scan assumption.\n3.  The exact number of distinct primary input assignments that constitute the complete test set for this fault.\n\nWe will address these in sequence, adhering to first principles as stipulated.\n\n**Part 1: Derivation of Necessary and Sufficient Conditions**\n\nThe detection of a single stuck-at fault requires two fundamental conditions to be met simultaneously:\n- **Fault Activation**: The input vector must force the faulty line to a value opposite to the stuck-at value in the good (fault-free) circuit.\n- **Fault Propagation**: The effect of the fault (the difference in signal value between the good and faulty circuit) must be propagated from the fault site to at least one primary output.\n\nThe fault under consideration is $n_{3}$ stuck-at-$0$ (SA0).\n\n**1. Fault Activation Condition**\nTo activate the $n_{3}$ SA0 fault, the value of line $n_{3}$ in the good circuit must be logic $1$. Let $n_{3, good}$ denote the value of $n_3$ in the good circuit. The activation condition is:\n$$\nn_{3, good} = 1\n$$\nThe logic for $n_{3}$ is given by $n_{3} = n_{1} \\lor n_{2}$, where $n_{1} = x_{1} \\land x_{2}$ and $n_{2} = \\lnot x_{1} \\land x_{3}$. Substituting these into the activation condition, we obtain the first part of our overall detection condition, expressed in terms of primary inputs:\n$$\n(x_{1} \\land x_{2}) \\lor (\\lnot x_{1} \\land x_{3}) = 1\n$$\n\n**2. Fault Propagation Condition**\nWith the fault activated, the value at line $n_{3}$ is $1$ in the good circuit and $0$ in the faulty circuit. Using the $D$-calculus, this is represented as $n_{3} = D$, where $D$ denotes a $1$ in the good circuit and a $0$ in the faulty circuit. This fault effect, $D$, must be propagated to the primary output $y$.\n\nThe output $y$ is defined as $y = (n_{3} \\land n_{4}) \\lor (x_{2} \\land x_{5})$. For the fault effect at $n_{3}$ to propagate to $y$, the output $y$ must be sensitive to the value of $n_{3}$. This can be formalized by requiring the Boolean partial derivative of $y$ with respect to $n_{3}$ to be $1$:\n$$\n\\frac{\\partial y}{\\partial n_{3}} = 1\n$$\nBy definition, the Boolean partial derivative is $y(n_{3}=1) \\oplus y(n_{3}=0)$, where $\\oplus$ is the exclusive-OR (XOR) operation.\nFirst, we evaluate $y$ for $n_{3}=1$ and $n_{3}=0$:\n$$\ny(n_{3}=1) = (1 \\land n_{4}) \\lor (x_{2} \\land x_{5}) = n_{4} \\lor (x_{2} \\land x_{5})\n$$\n$$\ny(n_{3}=0) = (0 \\land n_{4}) \\lor (x_{2} \\land x_{5}) = 0 \\lor (x_{2} \\land x_{5}) = x_{2} \\land x_{5}\n$$\nNow, we compute the XOR:\n$$\n\\frac{\\partial y}{\\partial n_{3}} = \\left( n_{4} \\lor (x_{2} \\land x_{5}) \\right) \\oplus (x_{2} \\land x_{5})\n$$\nUsing the identity $A \\oplus (A \\lor B) = \\lnot A \\land B$, we let $A = x_{2} \\land x_{5}$ and $B = n_{4}$. Then:\n$$\n\\frac{\\partial y}{\\partial n_{3}} = \\lnot (x_{2} \\land x_{5}) \\land n_{4}\n$$\nThe propagation condition is therefore:\n$$\nn_{4} \\land \\lnot(x_{2} \\land x_{5}) = 1\n$$\nThis single equation implies two sub-conditions that must hold simultaneously:\n1.  $n_{4} = 1$\n2.  $x_{2} \\land x_{5} = 0$, which is equivalent to $\\lnot(x_{2} \\land x_{5}) = 1$.\n\nThis can also be understood using the concepts of controlling and non-controlling values. For the $D$ at $n_3$ to propagate through the AND gate with $n_4$, $n_4$ must be at its non-controlling value, which is $1$. This gives $n_4=1$. The output of this AND gate is then $(D \\land 1) = D$. For this $D$ to propagate through the final OR gate, the other input, $(x_2 \\land x_5)$, must be at its non-controlling value, which is $0$. This gives $x_2 \\land x_5 = 0$. This confirms the derivation.\n\nSubstituting $n_{4} = x_{4} \\oplus x_{5}$, the propagation condition in terms of primary inputs is:\n$$\n(x_{4} \\oplus x_{5} = 1) \\land (x_{2} \\land x_{5} = 0)\n$$\n\n**3. Complete Necessary and Sufficient Condition**\nThe fault is detected if and only if both the activation and propagation conditions are met. Let $T(x_1, x_2, x_3, x_4, x_5)$ be the Boolean function representing the complete test set. This function is the logical AND of all derived conditions:\n$$\nT = \\left( (x_{1} \\land x_{2}) \\lor (\\lnot x_{1} \\land x_{3}) \\right) \\land (x_{4} \\oplus x_{5}) \\land \\lnot(x_{2} \\land x_{5})\n$$\nAn input vector $(x_{1}, x_{2}, x_{3}, x_{4}, x_{5})$ detects the fault $n_3$ SA0 if and only if $T(x_1, x_2, x_3, x_4, x_5) = 1$.\n\n**Part 2: Equivalence of D-Algorithm and PODEM**\n\nUnder the full-scan assumption, the circuit under test is purely combinational. For combinational circuits, both the D-Algorithm and PODEM are *complete* algorithms. Completeness means that if a test vector exists for a given fault, the algorithm is guaranteed to find one.\n\n- The **D-Algorithm** operates on the gate-level netlist. It first generates a $D$ or $\\overline{D}$ at the fault site (activation) and then propagates this fault effect forward along a sensitized path to a primary output. Concurrently, it performs a justification step, working backward from the internal line values required for propagation to determine a consistent set of primary input values. Decisions are made on internal nodes, and conflicts are resolved via backtracking.\n\n- The **Path-Oriented Decision Making (PODEM)** algorithm operates differently. It makes decisions exclusively on the primary inputs (PIs). It uses a backtracing procedure to identify a PI assignment that will help achieve a goal (e.g., set an internal node to a required value) and then simulates forward to observe the consequences. It backtracks on PI assignments if they lead to a conflict or fail to progress toward the objective of activating and propagating the fault.\n\nThe equivalence in the set of solutions they can produce stems from their shared goal and completeness:\n1.  **Shared Objective**: Both algorithms are designed to find a PI assignment that satisfies the activation and propagation requirements for a fault. This set of requirements defines the space of all possible solutions (test vectors).\n2.  **Completeness on Combinational Circuits**: Since both algorithms are complete for combinational logic, they are both capable of finding any and all existing test vectors. The set of all valid test vectors is an inherent property of the circuit and the fault, defined by the Boolean function $T$ derived above. It is independent of the search strategy used to find a member of that set.\n3.  **Search Space vs. Search Strategy**: The D-Algorithm and PODEM differ in their *search strategy* for navigating the solution space. The D-Algorithm's search space involves internal node assignments, whereas PODEM's is restricted to PI assignments. However, the final output of both is a PI vector. Since both are complete, the union of all possible PI vectors that each algorithm *could* find is identical and corresponds to the complete test set. The differences are in computational efficiency and memory usage (PODEM is generally more efficient as it avoids the complex justification step of the D-algorithm), not in the logical scope of the solutions they can generate.\n\nThus, for this combinational problem, the set of primary input assignments that the D-Algorithm can produce is identical to the set that PODEM can produce.\n\n**Part 3: Calculation of the Number of Test Vectors**\n\nWe must count the number of 5-bit input vectors $(x_1, x_2, x_3, x_4, x_5)$ that cause the test function $T$ to evaluate to $1$.\n$$\nT = \\underbrace{\\left( (x_{1} \\land x_{2}) \\lor (\\lnot x_{1} \\land x_{3}) \\right)}_{C_1} \\land \\underbrace{(x_{4} \\oplus x_{5})}_{C_2} \\land \\underbrace{\\lnot(x_{2} \\land x_{5})}_{C_3} = 1\n$$\nLet's analyze the conditions. The variables $(x_1, x_3)$ are only in $C_1$, while $(x_4)$ is only in $C_2$. The variable $x_2$ appears in $C_1$ and $C_3$, and $x_5$ appears in $C_2$ and $C_3$. We can systematically count the satisfying assignments. Let's first combine conditions $C_2$ and $C_3$:\n$$\nC_{23} = (x_{4} \\oplus x_{5}) \\land \\lnot(x_{2} \\land x_{5}) = 1\n$$\nWe expand this expression:\n$$\nC_{23} = (x_{4}\\lnot x_{5} \\lor \\lnot x_{4}x_{5}) \\land (\\lnot x_{2} \\lor \\lnot x_{5})\n$$\n$$\n= (x_{4}\\lnot x_{5} \\land \\lnot x_{2}) \\lor (x_{4}\\lnot x_{5} \\land \\lnot x_{5}) \\lor (\\lnot x_{4}x_{5} \\land \\lnot x_{2}) \\lor (\\lnot x_{4}x_{5} \\land \\lnot x_{5})\n$$\nThe last term $(\\lnot x_{4}x_{5} \\land \\lnot x_{5})$ is $0$. The second term simplifies to $x_{4}\\lnot x_{5}$. By the absorption law ($A \\lor (A \\land B) = A$), the first two terms simplify to $x_{4}\\lnot x_{5}$.\n$$\nC_{23} = x_{4}\\lnot x_{5} \\lor \\lnot x_{2}\\lnot x_{4}x_{5}\n$$\nWe can count the satisfying assignments for $(x_2, x_4, x_5)$:\n- If $x_{4}=1, x_{5}=0$: The term $x_{4}\\lnot x_{5}$ is $1$, so $C_{23}=1$. This is true for any $x_2$. This gives two solutions for $(x_2, x_4, x_5)$: $(0,1,0)$ and $(1,1,0)$.\n- If this term is $0$, we need $\\lnot x_{2}\\lnot x_{4}x_{5}=1$. This requires $x_2=0, x_4=0, x_5=1$. This gives one solution: $(0,0,1)$.\nIn total, there are $2+1=3$ satisfying assignments for $(x_2, x_4, x_5)$: $(0,1,0)$, $(1,1,0)$, and $(0,0,1)$.\n\nNow we must satisfy condition $C_1 = (x_{1} \\land x_{2}) \\lor (\\lnot x_{1} \\land x_{3}) = 1$ for each of these cases. $C_1$ depends on $x_1, x_2, x_3$. The number of solutions for $(x_1, x_3)$ depends on the value of $x_2$.\n- If $x_2 = 0$: $C_1$ becomes $(x_1 \\land 0) \\lor (\\lnot x_1 \\land x_3) = \\lnot x_1 \\land x_3 = 1$. This has exactly one solution: $(x_1, x_3) = (0,1)$.\n- If $x_2 = 1$: $C_1$ becomes $(x_1 \\land 1) \\lor (\\lnot x_1 \\land x_3) = x_1 \\lor (\\lnot x_1 \\land x_3)$. Using the identity $A \\lor (\\lnot A \\land B) = A \\lor B$, this is $x_1 \\lor x_3 = 1$. This has three solutions for $(x_1, x_3)$: $(0,1)$, $(1,0)$, and $(1,1)$.\n\nWe can now find the total count by summing the contributions from the three valid $(x_2, x_4, x_5)$ tuples:\n1.  For $(x_2, x_4, x_5) = (0,1,0)$: Here $x_2=0$. The number of ways to satisfy $C_1$ is $1$. Total vectors: $1$.\n2.  For $(x_2, x_4, x_5) = (1,1,0)$: Here $x_2=1$. The number of ways to satisfy $C_1$ is $3$. Total vectors: $3$.\n3.  For $(x_2, x_4, x_5) = (0,0,1)$: Here $x_2=0$. The number of ways to satisfy $C_1$ is $1$. Total vectors: $1$.\n\nThe total number of distinct primary input assignments is the sum of these counts: $1 + 3 + 1 = 5$.\n\nThe five test vectors are:\n1.  $(x_1,x_3)=(0,1)$ and $(x_2,x_4,x_5)=(0,1,0) \\implies (0,0,1,1,0)$\n2.  $(x_1,x_3)=(0,1)$ and $(x_2,x_4,x_5)=(1,1,0) \\implies (0,1,1,1,0)$\n3.  $(x_1,x_3)=(1,0)$ and $(x_2,x_4,x_5)=(1,1,0) \\implies (1,1,0,1,0)$\n4.  $(x_1,x_3)=(1,1)$ and $(x_2,x_4,x_5)=(1,1,0) \\implies (1,1,1,1,0)$\n5.  $(x_1,x_3)=(0,1)$ and $(x_2,x_4,x_5)=(0,0,1) \\implies (0,0,1,0,1)$\n\nThe final count is 5.",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "The ultimate test of understanding a concept is often the ability to implement it. This practice guides you through building a simple fault simulator from first principles, which serves as the core engine for validating ATPG-generated patterns. By translating the theory of fault excitation and propagation into functional code, you will solidify your grasp of how these abstract principles are operationalized in real-world Electronic Design Automation (EDA) tools .",
            "id": "4256830",
            "problem": "You are given a directed acyclic combinational logic network model and a set of Automatic Test Pattern Generation (ATPG) patterns to validate. Automatic Test Pattern Generation (ATPG) patterns may include unspecified bits denoted by the unknown symbol, which we will write as $X$. The logic network consists of logic gates with types from the set $\\{\\mathrm{AND}, \\mathrm{OR}, \\mathrm{NOT}\\}$, wired together as a directed acyclic graph. Primary Inputs (PI) are source nodes, and Primary Outputs (PO) are sink nodes. A Single Stuck-At (SSA) fault is modeled as a permanent forcing of a logic net to either $0$ (stuck-at-$0$) or $1$ (stuck-at-$1$).\n\nFundamental base:\n- Boolean circuits compute a Boolean function $F: \\{0,1\\}^{n} \\to \\{0,1\\}^{m}$ via composition of primitive gate functions $g \\in \\{\\mathrm{AND}, \\mathrm{OR}, \\mathrm{NOT}\\}$ along a directed acyclic graph.\n- A SSA fault on net $f$ with stuck value $s \\in \\{0,1\\}$ yields a modified Boolean function $F_{f=s}$ where the value of net $f$ is forced to $s$ for all time, regardless of upstream inputs.\n- A test pattern detects a SSA fault if and only if there exists at least one primary output $y \\in \\mathrm{PO}$ such that the good circuit output value $F(\\mathbf{u})[y]$ differs from the faulty circuit output value $F_{f=s}(\\mathbf{u})[y]$ for the same input assignment $\\mathbf{u} \\in \\{0,1\\}^{n}$.\n\nYou must implement a pattern validation and fault simulation flow that uses these principles to determine, for each test case, whether the provided ATPG pattern detects the specified SSA fault. If the ATPG pattern contains $X$ entries for some primary inputs, treat $X$ as an unspecified input bit and validate detection under existential completion: the pattern is considered detecting if there exists any assignment of $0$ or $1$ to each $X$ such that the detection criterion holds (i.e., any completion produces a primary output mismatch between good and faulty circuits). Your algorithm must:\n- Construct a topological evaluation order for the gates so that each gate’s inputs are available before its output is evaluated.\n- Evaluate the good circuit output values by propagating PI values through the gates in topological order.\n- Evaluate the faulty circuit output values by propagating PI values while forcing the faulted net $f$ to the stuck value $s$ at the point where $f$ is defined (or at the PI if $f$ is a primary input).\n- For patterns with $X$, enumerate all binary completions of the $X$ positions and apply the detection check for each completion; report detection as true if any completion detects.\n\nMathematical formalization:\n- Let $\\mathcal{N}$ denote the set of nets in the circuit, $\\mathrm{PI} \\subset \\mathcal{N}$ the primary inputs, and $\\mathrm{PO} \\subset \\mathcal{N}$ the primary outputs. Each gate is a tuple $(\\text{type}, \\text{inputs}, \\text{output})$ where $\\text{type} \\in \\{\\mathrm{AND}, \\mathrm{OR}, \\mathrm{NOT}\\}$, $\\text{inputs} \\subset \\mathcal{N}$, and $\\text{output} \\in \\mathcal{N}$.\n- Define the good valuation function $V: \\mathcal{N} \\to \\{0,1\\}$ induced by PI assignment $\\mathbf{u}$ via topological evaluation using Boolean gate semantics: $\\mathrm{AND}(x_1,x_2)=x_1 \\wedge x_2$, $\\mathrm{OR}(x_1,x_2)=x_1 \\vee x_2$, $\\mathrm{NOT}(x)=\\neg x$.\n- Define the faulty valuation $V_{f=s}: \\mathcal{N} \\to \\{0,1\\}$ for the same $\\mathbf{u}$ by forcing $V_{f=s}(f)=s$ at or before any downstream evaluation and otherwise using the same gate semantics.\n- The detection criterion for a given completion $\\mathbf{u}$ is $\\exists y \\in \\mathrm{PO}: V(y) \\neq V_{f=s}(y)$, and for patterns with $X$, the pattern is detecting if $\\exists \\mathbf{u} \\in \\{0,1\\}^{n}$ consistent with the specified non-$X$ bits such that the criterion holds.\n\nInput specification is internal to the program. Use the following test suite of circuits, faults, and patterns:\n\n- Test case $1$ (happy path): Circuit $C_1$ with $\\mathrm{PI}=\\{a,b\\}$, gates $\\{(\\mathrm{AND}, [a,b], n_1)\\}$, $\\mathrm{PO}=\\{n_1\\}$. Fault $(f=n_1, s=0)$. Pattern $a=1$, $b=1$. Expected result: detection true.\n- Test case $2$ (masking): Circuit $C_2$ with $\\mathrm{PI}=\\{a,b,c\\}$, gates $\\{(\\mathrm{AND}, [a,b], n_1), (\\mathrm{OR}, [n_1,c], y)\\}$, $\\mathrm{PO}=\\{y\\}$. Fault $(f=n_1, s=0)$. Pattern $a=1$, $b=1$, $c=1$. Expected result: detection false due to output masking by the $\\mathrm{OR}$ gate’s controlling input.\n- Test case $3$ (no excitation): Circuit $C_1$ as above. Fault $(f=n_1, s=0)$. Pattern $a=0$, $b=1$. Expected result: detection false because the fault is not excited ($n_1$ is already $0$ in the good circuit).\n- Test case $4$ (existential $X$ completion detects): Circuit $C_2$ as above. Fault $(f=n_1, s=0)$. Pattern $a=1$, $b=X$, $c=0$. Expected result: detection true because the completion $b=1$ detects while $b=0$ does not.\n- Test case $5$ (fault on primary input): Circuit $C_3$ with $\\mathrm{PI}=\\{a\\}$, gates $\\{(\\mathrm{NOT}, [a], y)\\}$, $\\mathrm{PO}=\\{y\\}$. Fault $(f=a, s=1)$. Pattern $a=0$. Expected result: detection true.\n\nYour program must implement the described validation and simulation flow and produce, for the above test suite, a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result}_1,\\text{result}_2,\\dots]$), where each result is a boolean indicating whether the pattern detects the specified fault in its circuit. No physical units or angles are involved. The program must be self-contained, accept no external input, and strictly follow the output format.",
            "solution": "The problem statement has been critically reviewed and is deemed valid. It is scientifically grounded in the fundamental principles of digital logic design and fault analysis, well-posed with a clear objective and constraints, and formulated with objective, unambiguous language. The task is to implement a fault simulator for combinational logic circuits to validate if given test patterns, potentially containing unspecified bits ($X$), can detect a specified Single Stuck-At (SSA) fault.\n\nThe solution is implemented by adhering to the following principled, step-by-step procedure:\n\n1.  **Circuit Representation and Topological Ordering**:\n    A combinational logic network is a directed acyclic graph (DAG), where nodes represent logic signals (nets) and directed edges represent data flow through logic gates. To simulate the circuit, we must evaluate the gates in an order that ensures all of a gate's input values are known before we compute its output value. This is achieved by performing a topological sort on the nets of the circuit. The algorithm begins with the Primary Inputs ($\\mathrm{PI}$), which have no dependencies within the circuit, and proceeds through the network layer by layer.\n\n    Let $\\mathcal{N}$ be the set of all nets. A topological sort produces an ordered list of nets $(v_1, v_2, \\dots, v_{|\\mathcal{N}|})$ such that for any gate with inputs $\\{i_1, \\dots, i_k\\}$ and output $o$, the inputs all appear before the output in the sorted list. This order guarantees a correct signal propagation simulation. We can implement this using Kahn's algorithm, which systematically processes nodes with an in-degree of $0$.\n\n2.  **Logic Simulation for a Fully Specified Input Pattern**:\n    Given a complete input vector $\\mathbf{u} \\in \\{0,1\\}^{n}$ where $n=|\\mathrm{PI}|$, we simulate the circuit's behavior by propagating the input values through the gates in the determined topological order. This process is performed twice: once for the 'good' (fault-free) circuit and once for the 'faulty' circuit.\n\n    *   **Good Circuit Simulation**: We compute a valuation function $V: \\mathcal{N} \\to \\{0,1\\}$ for all nets.\n        - For each primary input $p_i \\in \\mathrm{PI}$, its value is set from the input vector: $V(p_i) = u_i$.\n        - For each subsequent net $o$ in the topological order, which is the output of a gate $g$ with inputs $\\{i_1, \\dots, i_k\\}$, its value is computed by applying the gate's Boolean function to the already computed values of its inputs: $V(o) = g(V(i_1), \\dots, V(i_k))$. The gate functions are standard: $V(o) = V(i_1) \\wedge V(i_2)$ for an $\\mathrm{AND}$ gate, $V(o) = V(i_1) \\vee V(i_2)$ for an $\\mathrm{OR}$ gate, and $V(o) = \\neg V(i_1)$ for a $\\mathrm{NOT}$ gate.\n\n    *   **Faulty Circuit Simulation**: We model a Single Stuck-At fault on a net $f$ with a stuck value $s \\in \\{0,1\\}$. We compute a faulty valuation function $V_{f=s}: \\mathcal{N} \\to \\{0,1\\}$.\n        - The simulation proceeds identically to the good circuit simulation, with one critical exception: when the faulted net $f$ is encountered in the topological evaluation order, its value is forcibly set to the stuck value $s$, i.e., $V_{f=s}(f) = s$. This value is then used for all downstream gate evaluations. If the fault is on a primary input, its value is overridden at the very beginning of the simulation.\n\n3.  **Fault Detection Criterion**:\n    A test pattern $\\mathbf{u}$ successfully detects the fault $(f, s)$ if and only if the output of the good circuit differs from the output of the faulty circuit for at least one Primary Output ($\\mathrm{PO}$). Formally, detection occurs if:\n    $$ \\exists y \\in \\mathrm{PO} \\text{ such that } V(y) \\neq V_{f=s}(y) $$\n    This requires two conditions to be met simultaneously by the test pattern:\n    - **Fault Excitation**: The pattern must produce a value on the fault site $f$ in the good circuit that is opposite to the stuck-at value. That is, $V(f) \\neq s$. If this condition is not met, the fault has no effect on the circuit's state.\n    - **Fault Propagation**: The effect of the fault (the discrepancy at net $f$) must propagate through the downstream logic to at least one primary output. If the fault effect is masked by the logic (e.g., an $\\mathrm{AND}$ gate input being stuck-at-$0$ is masked if another input is $0$), it will not be observable.\n\n4.  **Handling Unspecified Inputs ($X$)**:\n    An ATPG pattern may contain unspecified inputs, denoted by $X$. The problem specifies that detection holds under *existential completion*. This means the pattern is considered to detect the fault if there exists *any* assignment of binary values ($0$ or $1$) to the $X$ inputs that satisfies the detection criterion.\n\n    To implement this, we enumerate all possible binary completions of the pattern. If a pattern has $k$ inputs specified as $X$, there are $2^k$ possible complete input vectors. For each of these $2^k$ vectors, we perform the full good-circuit and faulty-circuit simulation and check the detection criterion. If even one of these completions results in detection, the overall pattern is validated as detecting the fault, and the search can terminate for that test case. If all $2^k$ completions fail to detect the fault, the pattern is declared non-detecting.\n\n**Example Walkthrough**\n\nLet's illustrate the process with Test Case $4$:\n- **Circuit**: $C_2$ with $\\mathrm{PI}=\\{a,b,c\\}$, gates $\\{(\\mathrm{AND}, [a,b], n_1), (\\mathrm{OR}, [n_1,c], y)\\}$, $\\mathrm{PO}=\\{y\\}$.\n- **Fault**: $(f=n_1, s=0)$.\n- **Pattern**: $(a=1, b=X, c=0)$.\n\nThe pattern has one unspecified input, $b=X$. We must test two completions: $(b=0)$ and $(b=1)$.\n\n**Completion 1: $b=0$. Input vector is $(a=1, b=0, c=0)$.**\n- **Good Circuit Simulation**:\n    - $V(a)=1, V(b)=0, V(c)=0$.\n    - $V(n_1) = \\mathrm{AND}(V(a), V(b)) = \\mathrm{AND}(1, 0) = 0$.\n    - $V(y) = \\mathrm{OR}(V(n_1), V(c)) = \\mathrm{OR}(0, 0) = 0$.\n    - Primary Output value: $V(y)=0$.\n- **Faulty Circuit Simulation** (fault $n_1$ stuck-at-$0$):\n    - $V_{f=s}(a)=1, V_{f=s}(b)=0, V_{f=s}(c)=0$.\n    - The value of $n_1$ is forced: $V_{f=s}(n_1) = 0$.\n    - $V_{f=s}(y) = \\mathrm{OR}(V_{f=s}(n_1), V_{f=s}(c)) = \\mathrm{OR}(0, 0) = 0$.\n    - Primary Output value: $V_{f=s}(y)=0$.\n- **Detection Check**: $V(y) = 0$ and $V_{f=s}(y) = 0$. They are equal. This completion does not detect the fault.\n\n**Completion 2: $b=1$. Input vector is $(a=1, b=1, c=0)$.**\n- **Good Circuit Simulation**:\n    - $V(a)=1, V(b)=1, V(c)=0$.\n    - $V(n_1) = \\mathrm{AND}(V(a), V(b)) = \\mathrm{AND}(1, 1) = 1$. (Fault is excited).\n    - $V(y) = \\mathrm{OR}(V(n_1), V(c)) = \\mathrm{OR}(1, 0) = 1$. (Fault effect propagates).\n    - Primary Output value: $V(y)=1$.\n- **Faulty Circuit Simulation** (fault $n_1$ stuck-at-$0$):\n    - $V_{f=s}(a)=1, V_{f=s}(b)=1, V_{f=s}(c)=0$.\n    - The value of $n_1$ is forced: $V_{f=s}(n_1) = 0$.\n    - $V_{f=s}(y) = \\mathrm{OR}(V_{f=s}(n_1), V_{f=s}(c)) = \\mathrm{OR}(0, 0) = 0$.\n    - Primary Output value: $V_{f=s}(y)=0$.\n- **Detection Check**: $V(y) = 1$ and $V_{f=s}(y) = 0$. They are not equal. This completion detects the fault.\n\nSince there exists a completion (namely, $b=1$) that detects the fault, the pattern $(a=1, b=X, c=0)$ is considered a detecting pattern. The result for this test case is true. The provided code implements this complete flow for all specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and print results for all test cases.\n    \"\"\"\n    \n    # Test case definitions\n    # Each case: (circuit_dict, fault_tuple, pattern_dict)\n    test_cases = [\n        # Test case 1 (happy path)\n        (\n            {\n                'PI': ['a', 'b'], 'PO': ['n1'],\n                'gates': [('AND', ['a', 'b'], 'n1')],\n            },\n            ('n1', 0),\n            {'a': 1, 'b': 1}\n        ),\n        # Test case 2 (masking)\n        (\n            {\n                'PI': ['a', 'b', 'c'], 'PO': ['y'],\n                'gates': [('AND', ['a', 'b'], 'n1'), ('OR', ['n1', 'c'], 'y')],\n            },\n            ('n1', 0),\n            {'a': 1, 'b': 1, 'c': 1}\n        ),\n        # Test case 3 (no excitation)\n        (\n            {\n                'PI': ['a', 'b'], 'PO': ['n1'],\n                'gates': [('AND', ['a', 'b'], 'n1')],\n            },\n            ('n1', 0),\n            {'a': 0, 'b': 1}\n        ),\n        # Test case 4 (existential X completion detects)\n        (\n            {\n                'PI': ['a', 'b', 'c'], 'PO': ['y'],\n                'gates': [('AND', ['a', 'b'], 'n1'), ('OR', ['n1', 'c'], 'y')],\n            },\n            ('n1', 0),\n            {'a': 1, 'b': 'X', 'c': 0}\n        ),\n        # Test case 5 (fault on primary input)\n        (\n            {\n                'PI': ['a'], 'PO': ['y'],\n                'gates': [('NOT', ['a'], 'y')],\n            },\n            ('a', 1),\n            {'a': 0}\n        )\n    ]\n\n    results = []\n    for circuit, fault, pattern in test_cases:\n        results.append(check_detection(circuit, fault, pattern))\n\n    # Format output as specified: [true,false,...]\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\ndef topological_sort(circuit):\n    \"\"\"\n    Performs a topological sort of the circuit nets using Kahn's algorithm.\n    Returns an ordered list of nets for evaluation.\n    \"\"\"\n    in_degree = collections.defaultdict(int)\n    graph = collections.defaultdict(list)\n    all_nets = set(circuit['PI'])\n\n    for _, inputs, output in circuit['gates']:\n        all_nets.add(output)\n        for net in inputs:\n            all_nets.add(net)\n\n    # Build graph and in-degrees for output nets\n    for _, inputs, output in circuit['gates']:\n        in_degree[output] = len(inputs)\n        for input_net in inputs:\n            graph[input_net].append(output)\n\n    # Queue for nodes with in-degree 0 (only PIs initially)\n    queue = collections.deque([net for net in circuit['PI']])\n    \n    topo_order = []\n    while queue:\n        net = queue.popleft()\n        topo_order.append(net)\n        for neighbor in graph[net]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    # Check for cycles\n    gate_outputs = {g[2] for g in circuit['gates']}\n    # The order should contain PIs and all gate outputs\n    if len(topo_order) != len(circuit['PI']) + len(gate_outputs):\n         # This should not happen in a valid combinational circuit\n         raise ValueError(\"Cycle detected or disconnected graph\")\n         \n    return topo_order\n\ndef simulate(circuit, full_pattern, sorted_nets, fault=None):\n    \"\"\"\n    Simulates the circuit for a given full input pattern and an optional fault.\n    \"\"\"\n    net_values = {}\n    fault_net, fault_val = (None, None) if fault is None else fault\n\n    # Define gate logic\n    gate_logic = {\n        'AND': lambda inputs: int(all(inputs)),\n        'OR':  lambda inputs: int(any(inputs)),\n        'NOT': lambda inputs: int(not inputs[0])\n    }\n    \n    gate_map = {output: (op_type, inputs) for op_type, inputs, output in circuit['gates']}\n\n    for net in sorted_nets:\n        if net in circuit['PI']:\n            if net == fault_net:\n                net_values[net] = fault_val  # PI stuck-at fault\n            else:\n                net_values[net] = full_pattern[net]\n        else: # It's a gate output\n            if net == fault_net:\n                net_values[net] = fault_val  # Internal net stuck-at fault\n                continue\n            \n            op_type, inputs = gate_map[net]\n            input_values = [net_values[i] for i in inputs]\n            net_values[net] = gate_logic[op_type](input_values)\n\n    return net_values\n\ndef check_detection(circuit, fault, pattern):\n    \"\"\"\n    Checks if a pattern (potentially with 'X') detects a fault.\n    \"\"\"\n    x_inputs = [pi for pi, val in pattern.items() if val == 'X']\n    fixed_inputs = {pi: val for pi, val in pattern.items() if val != 'X'}\n    \n    num_x = len(x_inputs)\n    \n    # Generate all binary completions for 'X' inputs\n    completions = itertools.product([0, 1], repeat=num_x)\n\n    topo_order = topological_sort(circuit)\n    \n    for completion in completions:\n        current_pattern = fixed_inputs.copy()\n        for i, pi_name in enumerate(x_inputs):\n            current_pattern[pi_name] = completion[i]\n\n        # Simulate good and faulty circuits\n        good_vals = simulate(circuit, current_pattern, topo_order)\n        faulty_vals = simulate(circuit, current_pattern, topo_order, fault)\n        \n        # Check for detection at any Primary Output\n        detected = False\n        for po in circuit['PO']:\n            if good_vals.get(po) != faulty_vals.get(po):\n                detected = True\n                break\n        \n        if detected:\n            return True # Existential completion: one is enough\n\n    return False # No completion detected the fault\n\n# Run the solver\nsolve()\n```"
        }
    ]
}