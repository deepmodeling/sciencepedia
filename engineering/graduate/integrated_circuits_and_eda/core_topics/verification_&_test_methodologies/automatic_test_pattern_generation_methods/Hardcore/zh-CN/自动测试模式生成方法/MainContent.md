## 引言
随着集成电路（IC）的复杂性与日俱增，确保每一颗出厂芯片的功能完整性和物理可靠性成为半导体行业面临的核心挑战。制造过程中不可避免的物理缺陷，要求我们必须拥有一套高效、系统化的测试流程来筛选出有问题的“坏电路”。自动测试码生成（Automatic Test Pattern Generation, ATPG）正是为应对这一挑战而生的关键技术，其根本任务是在庞大的输入可能性中，智能地生成一小组高效的测试向量，以最大限度地暴露潜在的制造缺陷。本文旨在为读者提供一个关于ATPG方法的全面而深入的理解，从其理论基石到前沿应用。

在接下来的章节中，我们将系统性地剖析ATPG的世界：
- **第一章：原理与机制** 将奠定理论基础，从最核心的[故障模型](@entry_id:1124860)和[故障检测](@entry_id:270968)原则讲起，逐步深入到衡量测试难度的可测试性分析，并详细拆解D算法、PODEM、[基于SAT的ATPG](@entry_id:1131207)以及序贯电路测试等关键算法的内部工作机制。
- **第二章：应用与跨学科连接** 将视野从理论转向实践，探索ATPG技术如何在现实世界中解决关键工程问题，包括如何优化测试成本与功耗、通过高级[故障模型](@entry_id:1124860)提升测试质量、提高故障诊断的精度，以及在复杂的片上系统（SoC）和硬件安全领域中的创新应用。
- **第三章：动手实践** 将通过一系列精心设计的编程与分析练习，帮助读者将理论知识转化为解决实际问题的能力，加深对核心算法和概念的理解。

通过这一结构化的学习路径，本文将引导您不仅理解ATPG“是什么”和“如何工作”，更能领会其在现代电子系统[质量保证](@entry_id:202984)中所扮演的不可或缺的角色。

## 原理与机制

在[集成电路](@entry_id:265543)制造完成后，我们必须确保其功能与设计意图一致。然而，复杂的制造过程不可避免地会引入物理缺陷。自动测试码生成（Automatic Test Pattern Generation, ATPG）的核心任务，便是系统性地生成一组输入激励（即测试码），以区分功能完好的电路（“好电路”）与存在制造缺陷的电路（“坏电路”）。本章将深入探讨支持ATPG的基础原理和核心机制，从[故障模型](@entry_id:1124860)的基础，到复杂的测试生成算法。

### [故障检测](@entry_id:270968)的基本原则

为了使测试生成过程易于处理，我们必须首先对物理缺陷进行抽象。最广泛使用的模型是**[单固定型故障](@entry_id:1131708)（Single Stuck-At, SSA）模型**。该模型假设电路中仅存在一个缺陷，且该缺陷表现为某条信号线永久性地固定于逻辑`0`（stuck-at-0, SA0）或逻辑`1`（stuck-at-1, SA1）。尽管这是一个简化模型，但它在检测大量真实物理缺陷方面非常有效。

在S[SA模型](@entry_id:1131238)下，一个输入测试向量要成功检测到特定故障，必须同时满足两个条件：**故障激活（fault activation）**和**[故障传播](@entry_id:1124821)（fault propagation）**。

1.  **故障激活**：测试向量必须在故障点产生一个与“固定”值相反的逻辑值。例如，要检测一条线上的SA0故障，该测试向量必须使这条线在无故障电路中的值为`1`。反之，检测SA1故障则需要在线上产生`0`。这个过程在故障点制造了一个“错误信号”。

2.  **[故障传播](@entry_id:1124821)**：在故障点产生的错误信号必须沿着一条或多条路径传播到电路的某个**主输出（Primary Output, PO）**。为了让错误信号通过一个[逻辑门](@entry_id:178011)，该门的其他输入（称为“旁路输入”）必须被设置为**非控制值（non-controlling value）**。一个[逻辑门](@entry_id:178011)的控制值是指当该值出现在任一输入端时，仅凭此输入即可决定输出值（例如，AND/NAND门的控制值为`0`，OR/NOR门的控制值为`1`）。而非控制值则是其反面（AND/NAND的非控制值为`1`，OR/NOR的非控制值为`0`）。

考虑一个简单的[组合逻辑](@entry_id:265083)电路，其功能为 $y = (a \land b) \lor (c \land d)$。我们令中间节点 $u = a \land b$ 和 $v = c \land d$。现在，假设我们要检测节点 $u$ 上的SA0故障。
*   **激活**：我们必须在好电路中使 $u=1$。根据AND门的定义，这要求输入 $(a,b) = (1,1)$。
*   **传播**：故障效应在 $u$ 点产生，好电路为`1`，坏电路为`0`。为了将这个差异从 $u$ 传播到输出 $y = u \lor v$，OR门的旁路输入 $v$ 必须被设置为其非控制值`0`。要使 $v = c \land d = 0$，输入 $(c,d)$ 不能同时为`1`。
*   因此，任何形如 $(1,1,c,d)$ 且 $(c,d) \neq (1,1)$ 的输入向量都是该SA0故障的一个有效测试码。例如，$(1,1,0,1)$ 就是一个测试码。

这个激活与传播的范式是所有ATPG算法的基础。一个测试向量对一个故障的**检测概率（detection probability）**，就是随机生成该向量时，它恰好满足该故障激活与传播条件的概率。

### 可测试性：[可控性与可观测性](@entry_id:174003)

并非电路中的所有节点都同样易于测试。**可测试性（testability）**这一概念旨在量化测试的难度。它通常被分解为两个相互关联的度量：**可控性（controllability）**和**可观测性（observability）**。

*   **[可控性](@entry_id:148402)**：指通过控制主输入（Primary Inputs, PIs），将电路内部一个节点设置为特定逻辑值（`0`或`1`）的难易程度。
*   **可观测性**：指将电路内部一个节点的逻辑值或其上的故障效应传播到一个主输出（PO）的难易程度。

一个节点的测试难度与其[可控性](@entry_id:148402)和[可观测性](@entry_id:152062)直接相关。例如，要检测节点的SA0故障，我们必须能够相对容易地将其“控制”为`1`（激活），并且能够相对容易地将其效应“观测”到输出（传播）。

**SCOAP（Sandia Controllability/Observability Analysis Program）**是一种经典的、基于结构的静态可测试性分析方法。它为每个节点计算一组数值，量化其[可控性](@entry_id:148402)和可观测性“成本”。在SCOAP中，成本被定义为最小的“努力”。

*   **组合可控性（Combinational Controllability）**：$CC0(L)$ 和 $CC1(L)$ 分别表示将线路 $L$ 设置为`0`和`1`的成本。主输入的成本定义为`1`。对于一个[逻辑门](@entry_id:178011)的输出，其可控性成本通过其输入的成本计算得出。例如，对于一个输出为 $Y = A \land B$ 的AND门：
    *   要使 $Y=1$，必须使 $A=1$ 且 $B=1$。因此，$CC1(Y) = CC1(A) + CC1(B) + 1$ (加`1`代表通过门的成本)。
    *   要使 $Y=0$，只需使 $A=0$ 或 $B=0$。SCOAP选择成本最低的方案，因此 $CC0(Y) = \min(CC0(A), CC0(B)) + 1$。
*   **组合[可观测性](@entry_id:152062)（Combinational Observability）**：$CO(L)$ 表示将线路 $L$ 的值传播到主输出的成本。主输出的可观测性成本定义为`0`。要观测一个[逻辑门](@entry_id:178011)的某个输入，不仅需要将该门输出的效应传播出去，还必须将所有旁路输入设置为非控制值。例如，对于AND门 $Y=A \land B$，要观测输入 $A$，必须将旁路输入 $B$ 设置为`1`。因此，其成本为：
    *   $CO(A) = CO(Y) + CC1(B) + 1$。

通过从PIs[前向计算](@entry_id:193086)[可控性](@entry_id:148402)，再从POs后向计算[可观测性](@entry_id:152062)，SCOAP为整个电路提供了一张“测试难度地图”，这对于指导ATPG算法的搜索决策非常有价值。例如，检测某节点SA1故障的总成本可以近似为 $CC0(\text{node}) + CO(\text{node})$ 。

### 确定性ATPG算法

ATPG的本质是一个大规模的[搜索问题](@entry_id:270436)：在 $2^n$ 个可能的输入向量中（$n$ 是PI的数量），找到一个能检测到目标故障的向量。确定性ATPG算法通过系统性的搜索来解决这个问题。

#### D-演算：表达故障效应

确定性算法需要在单次遍览中同时推理好电路和坏电路的行为。如果我们只使用[三值逻辑](@entry_id:153539)（$\{0, 1, X\}$，其中 $X$ 代表未知），当好电路和坏电路在某条线上出现差异时（例如，好电路为`1`，坏电路为`0`），我们只能将该线的值记为 $X$。然而，这会丢失关键信息，因为 $X$ 也可能代表其他不确定的情况。例如，当这个 $X$ 信号作为OR门的一个输入，且另一个输入为`0`时（$X \lor 0$），输出结果也是 $X$，我们无法确定故障效应是否成功传播。

为了解决这个问题，Roth引入了**D-演算（D-calculus）**，这是一个五值逻辑系统：$\{0, 1, X, D, \bar{D}\}$。其中 $D$ 和 $\bar{D}$ 是复合值，专门用于表示故障效应：
*   $D$ 代表该线在好电路中为`1`，在坏电路中为`0`，即 $D \equiv (1, 0)$。
*   $\bar{D}$ 代表该线在好电路中为`0`，在坏电路中为`1`，即 $\bar{D} \equiv (0, 1)$。

这个系统本质上是在单个电[路图](@entry_id:274599)上进行双路并行的仿真，极大地提高了推理效率 。当 $D$ 或 $\bar{D}$ 信号成功传播到主输出时，我们便确认找到了一个测试码。

#### D-算法

**D-算法**是第一个完整的ATPG算法，它直接利用D-演算。其基本流程如下：
1.  **激活**：在故障点注入一个 $D$ 或 $\bar{D}$。例如，对于SA0故障，将该线的值设为 $D$。
2.  **传播**：算法维护一个**D-边界（D-frontier）**，即输入端有 $D$ 或 $\bar{D}$ 但输出端尚未确定的[逻辑门](@entry_id:178011)集合。算法选择D-边界中的一个门，并设置其旁路输入为非控制值，从而将 $D$ 或 $\bar{D}$ 传播到该门输出。这个过程重复进行，直到故障效应抵达主输出。
3.  **合理化（Justification）**：在传播过程中所做的所有内部节点赋值，都必须通过反向传播（从门输出到门输入）找到一组一致的主输入赋值。

例如，在传播故障信号通过一个[XOR门](@entry_id:162892)时，由于XOR的特性（$A \oplus 0 = A$, $A \oplus 1 = \neg A$），无论旁路输入是`0`还是`1`，故障效应（$D$ 或 $\bar{D}$）总能传播过去，只是可能会发生反转（$D \to \bar{D}$）。D-算法的挑战在于，它在内部节点上做决策，如果发生冲突，可能需要大量的回溯。

#### PODEM（Path-Oriented Decision Making）

**PODEM**是对D-算法的一个重要改进。其核心思想是，所有决策都只在**主输入**上进行。这极大地简化了回溯过程。PODEM的流程是目标驱动的：
1.  **设置目标**：从激活故障或传播故障效应的需要出发，设定一个目标（例如，将线 $L$ 设置为值 $V$）。
2.  **回溯追踪（Backtracing）**：从目标节点开始，向主输入方向回溯，但不进行[逻辑赋值](@entry_id:635440)。回溯的目的是为了找到一个“最容易”影响目标节点的PI。
3.  **PI赋值与前向蕴涵**：对选定的PI赋一个值，然后立即进行一次全电路的前向[逻辑蕴涵](@entry_id:273592)（implication），确定该赋值带来的所有后果。
4.  **检查目标**：如果目标达成，则设置下一个目标（例如，从激活转向传播）。如果蕴涵导致冲突，则回溯，撤销上一个PI赋值并尝试相反的值。

PODEM通过将[决策空间](@entry_id:1123459)限制在PI上，结构化了搜索过程，并且避免了D-算法复杂的合理化步骤。一个PODEM生成的测试码通常不是一个完整的输入向量，而是一个**测试立方体（test cube）**，其中只包含了生成测试所必需的最少PI赋值，其余PIs则为“无关”（don't-care）。

### 先进ATPG方法

#### [基于SAT的ATPG](@entry_id:1131207)

一种更现代的方法是将ATPG问题转化为一个**[布尔可满足性](@entry_id:136675)（Boolean Satisfiability, SAT）**问题。[SAT问题](@entry_id:150669)询问是否存在一组变量赋值能够满足给定的[合取范式](@entry_id:148377)（Conjunctive Normal Form, CNF）公式。
其转换过程如下：
1.  **[电路建模](@entry_id:263743)**：创建两个电路的CNF模型：一个好电路模型和一个坏电路模型。每个[逻辑门](@entry_id:178011)的功能都被转换成一组CNF子句。两个模型的PI变量是共享的。
2.  **约束添加**：
    *   **故障激活与注入**：以SA0故障为例，添加两个单元子句：$f_{good}=1$ 和 $f_{faulty}=0$。
    *   **[故障传播](@entry_id:1124821)**：添加一个大的析取子句，要求至少有一个主输出在好电路和坏电路中的值不同：$(PO_{1,good} \oplus PO_{1,faulty}) \lor (PO_{2,good} \oplus PO_{2,faulty}) \lor \dots = 1$。
3.  **求解**：将这个巨大的CNF公式交给一个现代的[SAT求解器](@entry_id:152216)（如CDCL求解器）。
    *   如果求解器返回“可满足”（SAT），那么其给出的PI变量赋值就是一个有效的测试码。
    *   如果求解器返回“不可满足”（UNSAT），则证明该故障是**不可测的（untestable）**。这提供了一个强有力的[数学证明](@entry_id:137161)，这是传统[搜索算法](@entry_id:272182)难以做到的。

[基于SAT的ATPG](@entry_id:1131207)将整个问题全局性地表达出来，求解器能够通过子句学习等高级技术高效地处理**重构[扇出](@entry_id:173211)（reconvergent fanout）**等导致传统算法困难的电路结构。

#### 序贯ATPG

对于包含记忆元件（如触发器）的序贯电路，单个测试向量是不够的。测试变成了一个序列。**时序帧扩展法（Time-Frame Expansion）**是将序贯ATPG问题转化为组合ATPG问题的标准方法。
该方法将序贯电路在时间上“展开”成多个（$N$个）相同的组合逻辑块，每个块代表一个时钟周期。第 $t$ 帧的触发器输出连接到第 $t+1$ 帧的触发器输入。这样，一个深度为 $N$ 的序贯测试问题就变成了一个 $N$ 倍大的[组合电路](@entry_id:174695)测试问题。生成一个测试序列通常需要：
1.  一个输入序列，将电路从初始状态引导到一个可以**激活**故障的状态。
2.  一个后续序列，将储存在触发器中的故障效应**传播**到主输出。

这使得序贯ATPG的复杂度远高于组合ATPG。一个故障可能需要多个时钟周期才能被检测到。

### 实践考量与复杂度

#### [算法复杂度](@entry_id:137716)

[组合电路](@entry_id:174695)的ATPG问题是一个经典的**[NP完全](@entry_id:145638)（NP-complete）**问题。这意味着在最坏情况下，任何已知的完备ATPG算法都需要指数级的时间来找到一个测试码或证明故障不可测（假设 $P \neq NP$）。这种复杂性的根源在于电路中的**重构扇出**结构，即从一个节点[扇出](@entry_id:173211)的多条路径在下游重新汇合。这种结构使得对一条路径的赋值可能会与另一条路径的赋值产生冲突，导致算法需要大量回溯。

然而，对于没有[扇出](@entry_id:173211)或没有重构[扇出](@entry_id:173211)的**树形电路**，ATPG问题是线性的，可以在[多项式时间](@entry_id:263297)内解决。这解释了为何[启发式算法](@entry_id:176797)在许多实际电路中表现良好，因为这些电路的“棘手”部分通常是局部的。

#### 未知值（X值）的处理

在真实的芯片测试中，由于未初始化的存储器、总线竞争或[跨时钟域](@entry_id:173614)等原因，一些扫描链的输出可能是未知的（$X$ 值）。这些 $X$ 值如果进入测试响应压缩器（如空间压缩器），可能会污染确定的`0`或`1`的签名，导致良品被误判为次品。一种有效的处理方法是**屏蔽（masking）**。在压缩之前，一个可编程的屏蔽向量可以被用来选择性地“关闭”那些可能产生 $X$ 值的扫描链输出，确保只有确定的值被用于最终的通过/失败决策。

#### 其他[故障模型](@entry_id:1124860)

尽管[单固定型故障模型](@entry_id:1131709)是基础，但它无法覆盖所有的缺陷类型。例如，**转换故障（Transition Fault）**模型用于[模拟电路](@entry_id:274672)中的延迟缺陷，即信号从`0`到`1`或从`1`到`0`的转换速度过慢。检测转换故障需要一个**双码测试（two-pattern test）**：第一个码用于初始化节点状态，第二个码在下一个时钟周期以额定速度施加，用于触发转换并捕获其是否在规定时间内完成。

综上所述，ATPG是一个涉及逻辑、算法和[计算复杂性理论](@entry_id:272163)的丰富领域。从基本的激活-传播原则到先进的基于SAT的方法，ATPG工具的发展使得现代超大规模[集成电路](@entry_id:265543)的[质量保证](@entry_id:202984)成为可能。