{
    "hands_on_practices": [
        {
            "introduction": "Before generating test patterns, it is crucial to assess a circuit's inherent testability. Testability analysis provides quantitative metrics that predict the difficulty of controlling internal nodes and observing their state at the outputs. This practice () guides you through the manual calculation of SCOAP (Sandia Controllability/Observability Analysis Program) metrics, offering a foundational understanding of how these values are derived from gate-level topology and logic.",
            "id": "4264468",
            "problem": "Consider the following single-clock-domain combinational network specified at the gate level. The design context is Design for Testability (DFT) within Electronic Design Automation (EDA). The network has Primary Inputs (PI) $a$, $b$, $c$, $d$, $e$, $f$, $g$ and Primary Outputs (PO) $y_1$, $y_2$. Internal nodes are $n_1$, $n_2$, $n_3$, $n_4$, $n_5$, $n_6$, $n_7$. All gates have unit cost, meaning each gate contributes a cost of $1$ when a signal value is forced through it or when an effect is propagated through it.\n\nThe network is defined as follows:\n- $n_1 = \\mathrm{NAND}(a,b)$\n- $n_2 = \\mathrm{OR}(c,d)$\n- $n_3 = \\mathrm{AND}(n_1,n_2)$\n- $n_4 = \\mathrm{XOR}(n_3,e)$\n- $n_5 = \\mathrm{NOR}(f,g)$\n- $n_6 = \\mathrm{AND}(n_4,n_5)$\n- $n_7 = \\mathrm{NOT}(n_2)$\n- $y_1 = \\mathrm{OR}(n_6,n_7)$\n- $y_2 = \\mathrm{AND}(n_1,e)$\n\nUsing the Sandia Controllability/Observability Analysis Program (SCOAP) framework, compute the controllability metrics $CC0$ and $CC1$ and the observability metric $CO$ for every node in the network. Base your derivation on the core definitions:\n- Controllability $CC0(x)$ and $CC1(x)$ quantify the minimum effort to force node $x$ to logic $0$ or logic $1$, respectively, starting from the primary inputs and accounting for gate semantics and required side-input assignments.\n- Observability $CO(x)$ quantifies the minimum effort to propagate a logic difference at node $x$ to at least one primary output, accounting for path sensitization from $x$ to a primary output.\n\nAssume the baseline costs are $CC0(x)=CC1(x)=1$ for any primary input $x$ and $CO(y)=0$ for any primary output $y$. Do not assume closed-form gate-specific SCOAP recurrences; instead derive them from first principles using Boolean semantics and path sensitization.\n\nAfter computing $CC0$, $CC1$, and $CO$ for all nodes, define the worst-case stuck-at detection cost for a node $v$ as\n$$D(v) = \\max\\!\\big(CC0(v) + CO(v),\\; CC1(v) + CO(v)\\big).$$\nAmong all nodes in the network (including primary inputs and internal nodes, but noting that primary outputs already have $CO=0$), determine the maximum value\n$$D_{\\max} = \\max_{v} D(v).$$\n\nReport only $D_{\\max}$ as your final answer. The final answer must be a single real-valued number. No rounding is required.",
            "solution": "We begin from the core definitions of controllability and observability. Controllability $CC0(x)$ is the minimal cost to force node $x$ to logic $0$ from the primary inputs, and $CC1(x)$ is the minimal cost to force node $x$ to logic $1$. Observability $CO(x)$ is the minimal cost to propagate a logic difference at node $x$ to a primary output. All costs count gate traversals and necessary side-input assignments, each with unit cost $1$.\n\nBaseline initialization follows from the definitions:\n- For any primary input $p$, forcing $p$ to $0$ or $1$ is a direct assignment with cost $1$, so $CC0(p)=1$ and $CC1(p)=1$.\n- For any primary output $y$, the difference is already at the output, so $CO(y)=0$.\n\nWe derive gate-wise controllability from Boolean semantics:\n- For $\\mathrm{AND}$: output $0$ occurs if any input is $0$, so $CC0(\\mathrm{AND}) = 1 + \\min\\big(CC0(\\text{inputs})\\big)$. Output $1$ requires all inputs $1$, so $CC1(\\mathrm{AND}) = 1 + \\sum CC1(\\text{inputs})$.\n- For $\\mathrm{OR}$: output $0$ requires all inputs $0$, so $CC0(\\mathrm{OR}) = 1 + \\sum CC0(\\text{inputs})$. Output $1$ occurs if any input is $1$, so $CC1(\\mathrm{OR}) = 1 + \\min\\big(CC1(\\text{inputs})\\big)$.\n- For $\\mathrm{NAND}$ is the inversion of $\\mathrm{AND}$: to get output $0$, its pre-inversion $\\mathrm{AND}$ must be $1$, so $CC0(\\mathrm{NAND}) = 1 + \\sum CC1(\\text{inputs})$. To get output $1$, its pre-inversion $\\mathrm{AND}$ must be $0$, so $CC1(\\mathrm{NAND}) = 1 + \\min\\big(CC0(\\text{inputs})\\big)$.\n- For $\\mathrm{NOR}$ is the inversion of $\\mathrm{OR}$: $CC0(\\mathrm{NOR}) = 1 + \\min\\big(CC1(\\text{inputs})\\big)$ and $CC1(\\mathrm{NOR}) = 1 + \\sum CC0(\\text{inputs})$.\n- For $\\mathrm{NOT}$: $CC0(\\mathrm{NOT}(x)) = 1 + CC1(x)$ and $CC1(\\mathrm{NOT}(x)) = 1 + CC0(x)$.\n- For two-input $\\mathrm{XOR}(u,v)$: output $0$ requires $u=v$, achievable either by $u=0,v=0$ or $u=1,v=1$, hence $CC0(\\mathrm{XOR}) = 1 + \\min\\big(CC0(u)+CC0(v),\\; CC1(u)+CC1(v)\\big)$. Output $1$ requires $u\\neq v$, achievable either by $u=0,v=1$ or $u=1,v=0$, hence $CC1(\\mathrm{XOR}) = 1 + \\min\\big(CC0(u)+CC1(v),\\; CC1(u)+CC0(v)\\big)$.\n\nWe derive gate-wise observability from path sensitization:\n- For $\\mathrm{AND}$ with output $y$ and input $x_i$, to observe $x_i$ at $y$ the other inputs must be $1$, and traversal through the gate adds $1$, so $CO(x_i) = 1 + CO(y) + \\sum_{j\\neq i} CC1(x_j)$.\n- For $\\mathrm{OR}$, to observe $x_i$ the other inputs must be $0$, so $CO(x_i) = 1 + CO(y) + \\sum_{j\\neq i} CC0(x_j)$.\n- For $\\mathrm{NAND}$ and $\\mathrm{NOR}$, the inversion at the output does not change side-input sensitization; observability through them matches the corresponding $\\mathrm{AND}$ or $\\mathrm{OR}$ case: $\\mathrm{NAND}$ uses $CC1$ of other inputs, $\\mathrm{NOR}$ uses $CC0$ of other inputs.\n- For $\\mathrm{NOT}$, $CO(\\text{input}) = 1 + CO(\\text{output})$.\n- For two-input $\\mathrm{XOR}$, to observe one input through the output, the other input must be sensitized to either $0$ or $1$, whichever is easier; thus $CO(u) = 1 + CO(\\text{output}) + \\min\\big(CC0(v), CC1(v)\\big)$ and symmetrically for $v$.\n- For fanout, the observability of a node is the minimum over its fanout branches: $CO(x) = \\min_{\\text{fanout } f} CO_f(x)$.\n\nWe now apply these to the given network. Initialize the PIs:\n- $CC0(a)=CC1(a)=CC0(b)=CC1(b)=\\cdots=CC0(g)=CC1(g)=1$.\n\nCompute forward controllability:\n\n$\\,\\bullet\\,$ $n_1=\\mathrm{NAND}(a,b)$:\n- $CC0(n_1) = 1 + CC1(a) + CC1(b) = 1 + 1 + 1 = 3$.\n- $CC1(n_1) = 1 + \\min\\big(CC0(a), CC0(b)\\big) = 1 + \\min(1,1) = 2$.\n\n$\\,\\bullet\\,$ $n_2=\\mathrm{OR}(c,d)$:\n- $CC0(n_2) = 1 + CC0(c) + CC0(d) = 1 + 1 + 1 = 3$.\n- $CC1(n_2) = 1 + \\min\\big(CC1(c), CC1(d)\\big) = 1 + \\min(1,1) = 2$.\n\n$\\,\\bullet\\,$ $n_3=\\mathrm{AND}(n_1,n_2)$:\n- $CC0(n_3) = 1 + \\min\\big(CC0(n_1), CC0(n_2)\\big) = 1 + \\min(3,3) = 4$.\n- $CC1(n_3) = 1 + CC1(n_1) + CC1(n_2) = 1 + 2 + 2 = 5$.\n\n$\\,\\bullet\\,$ $n_4=\\mathrm{XOR}(n_3,e)$:\n- $CC0(n_4) = 1 + \\min\\big(CC0(n_3)+CC0(e),\\; CC1(n_3)+CC1(e)\\big) = 1 + \\min(4+1,\\; 5+1) = 1 + \\min(5,6) = 6$.\n- $CC1(n_4) = 1 + \\min\\big(CC0(n_3)+CC1(e),\\; CC1(n_3)+CC0(e)\\big) = 1 + \\min(4+1,\\; 5+1) = 6$.\n\n$\\,\\bullet\\,$ $n_5=\\mathrm{NOR}(f,g)$:\n- $CC0(n_5) = 1 + \\min\\big(CC1(f), CC1(g)\\big) = 1 + \\min(1,1) = 2$.\n- $CC1(n_5) = 1 + CC0(f) + CC0(g) = 1 + 1 + 1 = 3$.\n\n$\\,\\bullet\\,$ $n_6=\\mathrm{AND}(n_4,n_5)$:\n- $CC0(n_6) = 1 + \\min\\big(CC0(n_4), CC0(n_5)\\big) = 1 + \\min(6,2) = 3$.\n- $CC1(n_6) = 1 + CC1(n_4) + CC1(n_5) = 1 + 6 + 3 = 10$.\n\n$\\,\\bullet\\,$ $n_7=\\mathrm{NOT}(n_2)$:\n- $CC0(n_7) = 1 + CC1(n_2) = 1 + 2 = 3$.\n- $CC1(n_7) = 1 + CC0(n_2) = 1 + 3 = 4$.\n\n$\\,\\bullet\\,$ $y_1=\\mathrm{OR}(n_6,n_7)$:\n- $CC0(y_1) = 1 + CC0(n_6) + CC0(n_7) = 1 + 3 + 3 = 7$.\n- $CC1(y_1) = 1 + \\min\\big(CC1(n_6), CC1(n_7)\\big) = 1 + \\min(10,4) = 5$.\n\n$\\,\\bullet\\,$ $y_2=\\mathrm{AND}(n_1,e)$:\n- $CC0(y_2) = 1 + \\min\\big(CC0(n_1), CC0(e)\\big) = 1 + \\min(3,1) = 2$.\n- $CC1(y_2) = 1 + CC1(n_1) + CC1(e) = 1 + 2 + 1 = 4$.\n\nCompute backward observability. Initialize POs:\n- $CO(y_1)=0$, $CO(y_2)=0$.\n\n$\\,\\bullet\\,$ Through $y_1=\\mathrm{OR}(n_6,n_7)$:\n- $CO(n_6) = 1 + CO(y_1) + CC0(n_7) = 1 + 0 + 3 = 4$.\n- $CO(n_7) = 1 + CO(y_1) + CC0(n_6) = 1 + 0 + 3 = 4$.\n\n$\\,\\bullet\\,$ Through $y_2=\\mathrm{AND}(n_1,e)$:\n- $CO(n_1)$ via this branch $= 1 + CO(y_2) + CC1(e) = 1 + 0 + 1 = 2$.\n- $CO(e)$ via this branch $= 1 + CO(y_2) + CC1(n_1) = 1 + 0 + 2 = 3$.\n\n$\\,\\bullet\\,$ Through $n_6=\\mathrm{AND}(n_4,n_5)$:\n- $CO(n_4) = 1 + CO(n_6) + CC1(n_5) = 1 + 4 + 3 = 8$.\n- $CO(n_5) = 1 + CO(n_6) + CC1(n_4) = 1 + 4 + 6 = 11$.\n\n$\\,\\bullet\\,$ Through $n_7=\\mathrm{NOT}(n_2)$:\n- $CO(n_2)$ via this branch $= 1 + CO(n_7) = 1 + 4 = 5$.\n\n$\\,\\bullet\\,$ Through $n_4=\\mathrm{XOR}(n_3,e)$:\n- $CO(n_3) = 1 + CO(n_4) + \\min\\big(CC0(e), CC1(e)\\big) = 1 + 8 + \\min(1,1) = 10$.\n- $CO(e)$ via this branch $= 1 + CO(n_4) + \\min\\big(CC0(n_3), CC1(n_3)\\big) = 1 + 8 + \\min(4,5) = 13$.\n\nCombine fanouts for $e$: $e$ has fanouts to $y_2$ and $n_4$, so $CO(e) = \\min(3,13) = 3$.\n\n$\\,\\bullet\\,$ Through $n_3=\\mathrm{AND}(n_1,n_2)$:\n- $CO(n_1)$ via this branch $= 1 + CO(n_3) + CC1(n_2) = 1 + 10 + 2 = 13$.\n- $CO(n_2)$ via this branch $= 1 + CO(n_3) + CC1(n_1) = 1 + 10 + 2 = 13$.\n\nCombine fanouts:\n- $n_1$ fans out to $y_2$ and $n_3$, so $CO(n_1) = \\min(2,13) = 2$.\n- $n_2$ fans out to $n_7$ and $n_3$, so $CO(n_2) = \\min(5,13) = 5$.\n\n$\\,\\bullet\\,$ Through $n_1=\\mathrm{NAND}(a,b)$:\n- $CO(a) = 1 + CO(n_1) + CC1(b) = 1 + 2 + 1 = 4$.\n- $CO(b) = 1 + CO(n_1) + CC1(a) = 1 + 2 + 1 = 4$.\n\n$\\,\\bullet\\,$ Through $n_2=\\mathrm{OR}(c,d)$:\n- $CO(c) = 1 + CO(n_2) + CC0(d) = 1 + 5 + 1 = 7$.\n- $CO(d) = 1 + CO(n_2) + CC0(c) = 7$.\n\n$\\,\\bullet\\,$ Through $n_5=\\mathrm{NOR}(f,g)$:\n- $CO(f) = 1 + CO(n_5) + CC0(g) = 1 + 11 + 1 = 13$.\n- $CO(g) = 1 + CO(n_5) + CC0(f) = 13$.\n\nWe summarize $CC0$, $CC1$, $CO$:\n- $a$: $CC0=1$, $CC1=1$, $CO=4$.\n- $b$: $CC0=1$, $CC1=1$, $CO=4$.\n- $c$: $CC0=1$, $CC1=1$, $CO=7$.\n- $d$: $CC0=1$, $CC1=1$, $CO=7$.\n- $e$: $CC0=1$, $CC1=1$, $CO=3$.\n- $f$: $CC0=1$, $CC1=1$, $CO=13$.\n- $g$: $CC0=1$, $CC1=1$, $CO=13$.\n- $n_1$: $CC0=3$, $CC1=2$, $CO=2$.\n- $n_2$: $CC0=3$, $CC1=2$, $CO=5$.\n- $n_3$: $CC0=4$, $CC1=5$, $CO=10$.\n- $n_4$: $CC0=6$, $CC1=6$, $CO=8$.\n- $n_5$: $CC0=2$, $CC1=3$, $CO=11$.\n- $n_6$: $CC0=3$, $CC1=10$, $CO=4$.\n- $n_7$: $CC0=3$, $CC1=4$, $CO=4$.\n- $y_1$: $CC0=7$, $CC1=5$, $CO=0$.\n- $y_2$: $CC0=2$, $CC1=4$, $CO=0$.\n\nIdentify nodes limiting fault activation and propagation qualitatively:\n- Largest activation difficulty $CC1$ occurs at $n_6$ with $CC1(n_6)=10$ and at $n_4$ with $CC1(n_4)=6$; largest $CC0$ occurs at $n_4$ with $CC0(n_4)=6$ and at $y_1$ with $CC0(y_1)=7$.\n- Largest propagation difficulty $CO$ occurs at $f$ and $g$ with $CO=13$, and at $n_5$ with $CO=11$, and at $n_3$ with $CO=10$.\n\nCompute the worst-case stuck-at detection cost $D(v) = \\max\\big(CC0(v)+CO(v),\\; CC1(v)+CO(v)\\big)$ for each node:\n- $D(a) = \\max(1+4,\\; 1+4) = 5$.\n- $D(b) = 5$.\n- $D(c) = \\max(1+7,\\; 1+7) = 8$.\n- $D(d) = 8$.\n- $D(e) = \\max(1+3,\\; 1+3) = 4$.\n- $D(f) = \\max(1+13,\\; 1+13) = 14$.\n- $D(g) = 14$.\n- $D(n_1) = \\max(3+2,\\; 2+2) = 5$.\n- $D(n_2) = \\max(3+5,\\; 2+5) = 8$.\n- $D(n_3) = \\max(4+10,\\; 5+10) = \\max(14,\\; 15) = 15$.\n- $D(n_4) = \\max(6+8,\\; 6+8) = 14$.\n- $D(n_5) = \\max(2+11,\\; 3+11) = \\max(13,\\; 14) = 14$.\n- $D(n_6) = \\max(3+4,\\; 10+4) = \\max(7,\\; 14) = 14$.\n- $D(n_7) = \\max(3+4,\\; 4+4) = 8$.\n- $D(y_1) = \\max(7+0,\\; 5+0) = 7$.\n- $D(y_2) = \\max(2+0,\\; 4+0) = 4$.\n\nTherefore, the maximum worst-case detection cost is\n$$D_{\\max} = 15,$$\nachieved at node $n_3$.",
            "answer": "$$\\boxed{15}$$"
        },
        {
            "introduction": "Detecting timing-related defects requires testing a circuit at its operational speed, a practice known as at-speed testing. This introduces stringent timing constraints that are not present in slower, static tests. This exercise () puts you in the role of a DFT engineer making a critical decision between two common at-speed test schemes, Launch-on-Shift (LOS) and Launch-on-Capture (LOC), based on a careful analysis of path delays and clock skew.",
            "id": "4264467",
            "problem": "A synchronous integrated circuit is being prepared for at-speed scan testing within the domain of Electronic Design Automation (EDA). Two at-speed test strategies are under consideration: Launch-on-Shift (LOS) and Launch-on-Capture (LOC). Launch-on-Shift (LOS) launches the transition with the final scan shift clock edge and captures with the functional clock edge; Launch-on-Capture (LOC) launches and captures with consecutive functional clock edges after scan enable is deasserted. The design-for-testability decision must be based on timing feasibility at the target clock period.\n\nAssume the following scientifically realistic and self-consistent conditions:\n- The at-speed test clock period is $600\\,\\text{ps}$.\n- The capture flip-flop setup time is $30\\,\\text{ps}$.\n- The additional worst-case launch-to-capture clock skew attributable to the test clock distribution is $20\\,\\text{ps}$ for Launch-on-Capture (LOC) and $90\\,\\text{ps}$ for Launch-on-Shift (LOS).\n- Ignore clock jitter and treat hold constraints as non-limiting under both methods due to balanced clock trees and appropriate scan enable timing; focus on setup-limited feasibility.\n- Eight representative near-critical combinational path propagation delays (launch-to-capture) under test-mode constraints are measured as:\n  $480\\,\\text{ps}$, $510\\,\\text{ps}$, $530\\,\\text{ps}$, $550\\,\\text{ps}$, $570\\,\\text{ps}$, $590\\,\\text{ps}$, $610\\,\\text{ps}$, $640\\,\\text{ps}$.\n\nStarting only from the fundamental definition of synchronous setup timing feasibility, determine, for each method (LOS and LOC), the fraction of the listed paths that can be tested at-speed without incurring setup-time violations. Express each fraction as an exact rational number in simplest terms. Then recommend the method that maximizes coverage without violating timing; encode the recommendation as a numeric method code, with $0$ representing Launch-on-Capture (LOC) and $1$ representing Launch-on-Shift (LOS).\n\nYour final answer must be a single row matrix containing three entries in the following order:\n- The coverage for LOS (as an exact fraction).\n- The coverage for LOC (as an exact fraction).\n- The recommended method code ($0$ for LOC or $1$ for LOS).\n\nNo rounding is required. Do not include any units in the final answer.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of synchronous digital circuit timing, is well-posed with sufficient and consistent data, and is expressed in objective, standard terminology of the field of Electronic Design Automation (EDA) and Design for Testability (DFT).\n\nThe fundamental principle governing the at-speed testability of a synchronous path is the setup timing constraint. For a signal transition launched from one flip-flop to be correctly captured by another one clock cycle later, the total propagation delay must be less than or equal to the available time within the clock period. This can be expressed by the following inequality:\n$$T_{\\text{path\\_delay}} \\le T_{\\text{clk}} - T_{\\text{skew}} - T_{\\text{setup}}$$\nwhere:\n- $T_{\\text{path\\_delay}}$ is the propagation delay of the combinational logic path between the launch and capture flip-flops.\n- $T_{\\text{clk}}$ is the clock period.\n- $T_{\\text{skew}}$ is the clock skew, defined as the difference in arrival times of the clock edge at the capture and launch flip-flops. A positive skew in this context means the capture clock arrives later than the launch clock, which reduces the effective time budget for the path. The problem provides worst-case skew values which must be subtracted from the clock period.\n- $T_{\\text{setup}}$ is the setup time of the capture flip-flop, which is the minimum time the data signal must be stable at the flip-flop's input before the capturing clock edge arrives.\n\nThe provided data is:\n- At-speed test clock period, $T_{\\text{clk}} = 600\\,\\text{ps}$.\n- Capture flip-flop setup time, $T_{\\text{setup}} = 30\\,\\text{ps}$.\n- Worst-case clock skew for Launch-on-Capture (LOC), $T_{\\text{skew,LOC}} = 20\\,\\text{ps}$.\n- Worst-case clock skew for Launch-on-Shift (LOS), $T_{\\text{skew,LOS}} = 90\\,\\text{ps}$.\n- A set of $8$ near-critical path delays, $D = \\{480, 510, 530, 550, 570, 590, 610, 640\\}\\,\\text{ps}$.\n\nWe must determine the maximum allowable path delay ($T_{\\text{max\\_delay}}$) for each test method to identify which paths are testable.\n\nFor the Launch-on-Capture (LOC) method:\nThe maximum allowable path delay is calculated by substituting the LOC-specific values into the timing equation:\n$$T_{\\text{max\\_delay,LOC}} = T_{\\text{clk}} - T_{\\text{skew,LOC}} - T_{\\text{setup}}$$\n$$T_{\\text{max\\_delay,LOC}} = 600\\,\\text{ps} - 20\\,\\text{ps} - 30\\,\\text{ps} = 550\\,\\text{ps}$$\nWe compare each path delay in the set $D$ against this limit. A path is testable with LOC if its delay is less than or equal to $550\\,\\text{ps}$.\n- $480\\,\\text{ps} \\le 550\\,\\text{ps}$ (Pass)\n- $510\\,\\text{ps} \\le 550\\,\\text{ps}$ (Pass)\n- $530\\,\\text{ps} \\le 550\\,\\text{ps}$ (Pass)\n- $550\\,\\text{ps} \\le 550\\,\\text{ps}$ (Pass)\n- $570\\,\\text{ps} > 550\\,\\text{ps}$ (Fail)\n- $590\\,\\text{ps} > 550\\,\\text{ps}$ (Fail)\n- $610\\,\\text{ps} > 550\\,\\text{ps}$ (Fail)\n- $640\\,\\text{ps} > 550\\,\\text{ps}$ (Fail)\nThere are $4$ passing paths out of a total of $8$. The coverage fraction for LOC is $\\frac{4}{8} = \\frac{1}{2}$.\n\nFor the Launch-on-Shift (LOS) method:\nThe maximum allowable path delay is calculated using the LOS-specific skew:\n$$T_{\\text{max\\_delay,LOS}} = T_{\\text{clk}} - T_{\\text{skew,LOS}} - T_{\\text{setup}}$$\n$$T_{\\text{max\\_delay,LOS}} = 600\\,\\text{ps} - 90\\,\\text{ps} - 30\\,\\text{ps} = 480\\,\\text{ps}$$\nWe compare each path delay in the set $D$ against this more stringent limit. A path is testable with LOS if its delay is less than or equal to $480\\,\\text{ps}$.\n- $480\\,\\text{ps} \\le 480\\,\\text{ps}$ (Pass)\n- $510\\,\\text{ps} > 480\\,\\text{ps}$ (Fail)\n- $530\\,\\text{ps} > 480\\,\\text{ps}$ (Fail)\n- $550\\,\\text{ps} > 480\\,\\text{ps}$ (Fail)\n- $570\\,\\text{ps} > 480\\,\\text{ps}$ (Fail)\n- $590\\,\\text{ps} > 480\\,\\text{ps}$ (Fail)\n- $610\\,\\text{ps} > 480\\,\\text{ps}$ (Fail)\n- $640\\,\\text{ps} > 480\\,\\text{ps}$ (Fail)\nThere is only $1$ passing path out of a total of $8$. The coverage fraction for LOS is $\\frac{1}{8}$.\n\nTo recommend the method that maximizes coverage, we compare the coverage fractions:\n- LOS coverage: $\\frac{1}{8}$\n- LOC coverage: $\\frac{1}{2}$\nSince $\\frac{1}{2} > \\frac{1}{8}$, the Launch-on-Capture (LOC) method provides higher test coverage for the given set of paths without incurring setup-time violations.\nThe problem specifies a numeric method code: $0$ for LOC and $1$ for LOS. Therefore, the recommended method code is $0$.\n\nThe final results are:\n- LOS coverage: $\\frac{1}{8}$\n- LOC coverage: $\\frac{1}{2}$\n- Recommended method code: $0$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{1}{8} & \\frac{1}{2} & 0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While the stuck-at fault model is a cornerstone of DFT, real-world physical defects in CMOS technology are often more complex. The stuck-open fault, for example, can introduce sequential behavior into combinational logic, requiring a multi-vector test sequence for detection. This advanced practice () challenges you to reason from the transistor-level operation of a CMOS gate to derive the necessary and sufficient conditions for detecting such a fault, moving beyond abstract models to the underlying circuit physics.",
            "id": "4264533",
            "problem": "Consider a Complementary Metal-Oxide-Semiconductor (CMOS) $2$-input NAND gate implemented with a Pull-Up Network (PUN) consisting of two parallel p-channel Metal-Oxide-Semiconductor Field-Effect Transistors (pMOSFETs) driven by inputs $A$ and $B$, and a Pull-Down Network (PDN) consisting of two series n-channel Metal-Oxide-Semiconductor Field-Effect Transistors (nMOSFETs). The upper nMOSFET (connected to the output node $Y$) is driven by input $A$, and the lower nMOSFET (connected to ground) is driven by input $B$. Let the intermediate node between the two series nMOSFETs be denoted by $N$. The Boolean function is $Y=\\overline{A \\land B}$.\n\nAssume a stuck-open fault in the lower nMOSFET driven by $B$, meaning that its channel never conducts for any input condition. Assume realistic parasitic capacitances at nodes $Y$ and $N$ so that charge can be stored across vector applications. There is no significant leakage during the time scale of the two-vector test, and the observation is performed immediately after the application of the second test vector. There are no other defects or sources of contention in the gate or the fanout network.\n\nStarting only from the Boolean switching behavior of $Y=\\overline{A \\land B}$ and the transistor-level conduction rules for CMOS devices (nMOSFET conducts when its gate is at logic $1$, pMOSFET conducts when its gate is at logic $0$), derive necessary and sufficient activation and observation conditions on a two-vector test $\\langle (A_1,B_1),(A_2,B_2)\\rangle$ that will detect the stuck-open fault in the lower nMOSFET. Your derivation must explicitly account for the charge initialization of the nodes $Y$ and $N$ in the first vector, the attempted transition and conduction path in the second vector, and the absence of alternative discharge paths in the faulty circuit. Do not invoke any pre-derived testability formulas; reason from the stated fundamentals.\n\nThen, suppose a random test is applied where the first-vector inputs $(A_1,B_1)$ are jointly independent with $\\Pr(A_1=1)=\\alpha_1$ and $\\Pr(B_1=1)=\\beta_1$, and the second-vector inputs $(A_2,B_2)$ are jointly independent with $\\Pr(A_2=1)=\\alpha_2$ and $\\Pr(B_2=1)=\\beta_2$. Assume independence between the first and second vectors as well. Under these assumptions, compute the exact probability of detecting the stuck-open fault by a single two-vector application, expressed as a closed-form analytic expression in terms of $\\alpha_1$, $\\beta_1$, $\\alpha_2$, and $\\beta_2$.\n\nExpress the final probability as a single analytic expression. No rounding is required.",
            "solution": "The problem requires the derivation of necessary and sufficient conditions for a two-vector test to detect a stuck-open fault in a specific CMOS NAND gate, followed by the calculation of the detection probability under a random testing paradigm. The analysis must be performed from first principles.\n\nThe circuit under consideration is a $2$-input CMOS NAND gate with inputs $A$ and $B$, and output $Y$. The Boolean function is $Y = \\overline{A \\land B}$. The Pull-Up Network (PUN) consists of two parallel pMOSFETs, which conducts and pulls $Y$ to logic $1$ if $A=0$ or $B=0$. The Pull-Down Network (PDN) consists of two series nMOSFETs. The upper nMOSFET, connected between $Y$ and an intermediate node $N$, is controlled by $A$. The lower nMOSFET, connected between $N$ and ground, is controlled by $B$. The PDN conducts and pulls $Y$ to logic $0$ only if $A=1$ and $B=1$. The fault is a stuck-open fault in the lower nMOSFET, meaning the connection from node $N$ to ground is permanently broken.\n\nA stuck-open fault in a static CMOS gate requires a sequence of two test vectors, $\\langle V_1, V_2 \\rangle = \\langle (A_1, B_1), (A_2, B_2) \\rangle$, for detection. The first vector, $V_1$, initializes the output node, and the second vector, $V_2$, attempts to activate the fault and propagate its effect to the output.\n\nFirst, let us determine the conditions for the second vector, $V_2=(A_2, B_2)$. The purpose of $V_2$ is to test the integrity of a specific path in the PDN. To do this, $V_2$ must create a condition where the fault-free gate and the faulty gate produce different output values. The fault prevents the PDN from pulling the output down. Therefore, $V_2$ must be an input vector that causes the PDN to conduct in a fault-free circuit. The PDN conducts only when both series nMOSFETs are turned on, which requires $A=1$ and $B=1$. For any other input, the PDN is non-conducting, the PUN is conducting, and the output $Y$ is $1$ in both the fault-free and faulty circuits, leading to no detection. Thus, a necessary condition for fault detection is that the second vector must be $V_2=(A_2, B_2) = (1,1)$. Under this input, the fault-free output is $Y_{\\text{good}} = \\overline{1 \\land 1} = 0$.\n\nNext, we determine the conditions for the first vector, $V_1=(A_1, B_1)$. The purpose of $V_1$ is to initialize the output node $Y$ to a state that is opposite to the state the fault-free circuit would transition to under $V_2$. Since the fault-free output for $V_2=(1,1)$ is $Y_{\\text{good}}=0$, the output must be pre-charged to logic $1$ by $V_1$. So, we must have $Y(V_1)=1$. This occurs when $\\overline{A_1 \\land B_1} = 1$, which means $(A_1, B_1) \\neq (1,1)$. The possible choices for $V_1$ are $(0,0)$, $(0,1)$, and $(1,0)$.\n\nWith the application of $V_2=(1,1)$ to the faulty circuit, the PUN is turned off. The PDN path is broken due to the stuck-open fault at the lower nMOSFET. Consequently, the output node $Y$ becomes electrically isolated (floating). Due to the parasitic capacitance at node $Y$, it will retain its previously charged state, which is logic $1$. Hence, the faulty output is $Y_{\\text{faulty}}=1$. Since $Y_{\\text{good}}=0$ and $Y_{\\text{faulty}}=1$, the fault is detected.\n\nHowever, the problem specifies the existence of an intermediate node $N$ with parasitic capacitance. This introduces the possibility of fault masking due to charge sharing, which a robust test must prevent. We must analyze the state of node $N$ after the application of $V_1$.\n\nCase 1: $V_1 = (0,0)$ or $V_1 = (0,1)$. In both cases, $A_1=0$. The upper nMOSFET (controlled by $A$) is OFF. This isolates node $N$ from node $Y$. Since the lower nMOSFET is also OFF (either by input $B_1=0$ or by the fault itself), node $N$ is floating. Its voltage is determined by the circuit's history prior to the test. If node $N$ was at or near ground potential (logic $0$), it will remain so. When vector $V_2=(1,1)$ is applied, the upper nMOSFET turns ON, connecting the capacitance at $Y$ (charged to logic $1$) to the capacitance at $N$ (at logic $0$). The charge will redistribute between the two capacitances, causing the voltage at $Y$ to drop to a value $V_Y = V_{DD} \\frac{C_Y}{C_Y+C_N}$. If this voltage falls below the logic high threshold of subsequent gates, it may be interpreted as a logic $0$, masking the fault. Therefore, test sequences starting with $(0,0)$ or $(0,1)$ are not robust.\n\nCase 2: $V_1 = (1,0)$. Here, $A_1=1$ and $B_1=0$. The PUN is ON because $B_1=0$, charging $Y$ to logic $1$. In the PDN, the upper nMOSFET (controlled by $A_1=1$) is ON, while the lower nMOSFET (controlled by $B_1=0$) is OFF. This establishes a conducting path between $Y$ and $N$, but isolates $N$ from ground. As $Y$ is charged to logic $1$, node $N$ is also charged to logic $1$ (or close to it, $V_{DD}-V_{tn}$), since it is connected to $Y$. When the vector $V_2=(1,1)$ is applied, the upper nMOSFET remains ON. The entire conductive segment from $Y$ to $N$ has been pre-charged high. Since the faulty lower nMOSFET prevents discharge to ground, the nodes $Y$ and $N$ remain at logic $1$. This ensures that the output is unambiguously logic $1$, and detection is guaranteed regardless of capacitance ratios.\n\nTherefore, the necessary and sufficient condition for a robust two-vector test to detect the specified stuck-open fault is the specific sequence $\\langle (A_1, B_1), (A_2, B_2) \\rangle = \\langle (1,0), (1,1) \\rangle$.\n\nNow, we compute the probability of detecting the fault with a single random two-vector test. The inputs $(A_1, B_1)$ and $(A_2, B_2)$ are drawn randomly according to the given probabilities. The inputs $A_1$, $B_1$, $A_2$, and $B_2$ are all mutually independent. The given probabilities are $\\Pr(A_1=1)=\\alpha_1$, $\\Pr(B_1=1)=\\beta_1$, $\\Pr(A_2=1)=\\alpha_2$, and $\\Pr(B_2=1)=\\beta_2$. From these, we have $\\Pr(A_1=0)=1-\\alpha_1$ and $\\Pr(B_1=0)=1-\\beta_1$.\n\nThe fault is detected if and only if the random two-vector sequence is $\\langle (1,0), (1,1) \\rangle$. Let $P_{\\text{detect}}$ be the probability of this event.\n$$P_{\\text{detect}} = \\Pr\\left( (A_1,B_1)=(1,0) \\text{ and } (A_2,B_2)=(1,1) \\right)$$\nDue to the independence between the first and second vectors, we can write:\n$$P_{\\text{detect}} = \\Pr((A_1,B_1)=(1,0)) \\times \\Pr((A_2,B_2)=(1,1))$$\nDue to the independence of inputs within each vector, we have:\n$$\\Pr((A_1,B_1)=(1,0)) = \\Pr(A_1=1) \\times \\Pr(B_1=0)$$\n$$\\Pr((A_2,B_2)=(1,1)) = \\Pr(A_2=1) \\times \\Pr(B_2=1)$$\nSubstituting the given probability values:\n$$\\Pr(A_1=1) = \\alpha_1$$\n$$\\Pr(B_1=0) = 1 - \\beta_1$$\n$$\\Pr(A_2=1) = \\alpha_2$$\n$$\\Pr(B_2=1) = \\beta_2$$\nCombining these results, the detection probability is:\n$$P_{\\text{detect}} = (\\alpha_1 \\times (1-\\beta_1)) \\times (\\alpha_2 \\times \\beta_2)$$\n$$P_{\\text{detect}} = \\alpha_1 \\alpha_2 \\beta_2 (1-\\beta_1)$$\nThis is the final closed-form expression for the probability of detecting the stuck-open fault.",
            "answer": "$$\n\\boxed{\\alpha_1 \\alpha_2 \\beta_2 (1-\\beta_1)}\n$$"
        }
    ]
}