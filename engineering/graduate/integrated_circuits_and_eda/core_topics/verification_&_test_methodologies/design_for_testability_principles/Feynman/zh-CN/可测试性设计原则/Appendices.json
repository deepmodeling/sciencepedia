{
    "hands_on_practices": [
        {
            "introduction": "要设计一个可测试的电路，我们首先必须能够衡量其可测试性。本练习介绍了桑迪亚可控性/可观测性分析程序 (SCOAP)，这是一种量化数字电路中信号控制和观测难度的基础方法。通过从第一性原理出发计算每个节点的 SCOAP 指标，您将对电路拓扑如何影响故障检测获得具体的理解，并学会如何在设计流程的早期识别潜在的测试瓶颈 。",
            "id": "4264468",
            "problem": "考虑以下在门级指定的单时钟域组合网络。设计背景为电子设计自动化 (EDA) 中的可测试性设计 (DFT)。该网络有主输入 (PI) $a$、$b$、$c$、$d$、$e$、$f$、$g$ 和主输出 (PO) $y_1$、$y_2$。内部节点为 $n_1$、$n_2$、$n_3$、$n_4$、$n_5$、$n_6$、$n_7$。所有门的成本均为单位成本，意味着当一个信号值被强制通过一个门或当一个效应通过它传播时，每个门贡献的成本为 $1$。\n\n该网络定义如下：\n- $n_1 = \\mathrm{NAND}(a,b)$\n- $n_2 = \\mathrm{OR}(c,d)$\n- $n_3 = \\mathrm{AND}(n_1,n_2)$\n- $n_4 = \\mathrm{XOR}(n_3,e)$\n- $n_5 = \\mathrm{NOR}(f,g)$\n- $n_6 = \\mathrm{AND}(n_4,n_5)$\n- $n_7 = \\mathrm{NOT}(n_2)$\n- $y_1 = \\mathrm{OR}(n_6,n_7)$\n- $y_2 = \\mathrm{AND}(n_1,e)$\n\n使用 Sandia 可控性/可观测性分析程序 (SCOAP) 框架，计算网络中每个节点的可控性度量 $CC0$ 和 $CC1$ 以及可观测性度量 $CO$。请基于核心定义进行推导：\n- 可控性 $CC0(x)$ 和 $CC1(x)$ 分别量化了从主输入开始，将节点 $x$ 强制为逻辑 $0$ 或逻辑 $1$ 所需的最小代价，其中考虑了门的语义和所需的旁路输入赋值。\n- 可观测性 $CO(x)$ 量化了将节点 $x$ 处的逻辑差异传播到至少一个主输出所需的最小代价，其中考虑了从 $x$ 到主输出的路径敏化。\n\n假设任何主输入 $x$ 的基准成本为 $CC0(x)=CC1(x)=1$，任何主输出 $y$ 的基准成本为 $CO(y)=0$。不要假设门特定的 SCOAP 闭式递推关系；相反，应使用布尔语义和路径敏化从第一性原理推导它们。\n\n在计算完所有节点的 $CC0$、$CC1$ 和 $CO$ 后，将节点 $v$ 的最坏情况固定型故障检测成本定义为\n$$D(v) = \\max\\!\\big(CC0(v) + CO(v),\\; CC1(v) + CO(v)\\big).$$\n在网络中的所有节点中（包括主输入和内部节点，但注意主输出的 $CO$ 已为 $0$），确定最大值\n$$D_{\\max} = \\max_{v} D(v).$$\n\n仅报告 $D_{\\max}$ 作为你的最终答案。最终答案必须是一个实数值。不需要四舍五入。",
            "solution": "我们从可控性和可观测性的核心定义开始。可控性 $CC0(x)$ 是从主输入将节点 $x$ 强制为逻辑 $0$ 的最小成本，而 $CC1(x)$ 是将节点 $x$ 强制为逻辑 $1$ 的最小成本。可观测性 $CO(x)$ 是将节点 $x$ 处的逻辑差异传播到主输出的最小成本。所有成本都计算了门遍历和必要的旁路输入赋值，每个成本均为单位成本 $1$。\n\n基准初始化遵循定义：\n- 对于任何主输入 $p$，将其强制为 $0$ 或 $1$ 是成本为 $1$ 的直接赋值，因此 $CC0(p)=1$ 且 $CC1(p)=1$。\n- 对于任何主输出 $y$，差异已在输出端，因此 $CO(y)=0$。\n\n我们从布尔语义推导逐门的可控性：\n- 对于 $\\mathrm{AND}$：如果任何输入为 $0$，则输出为 $0$，因此 $CC0(\\mathrm{AND}) = 1 + \\min\\big(CC0(\\text{inputs})\\big)$。输出为 $1$ 需要所有输入都为 $1$，因此 $CC1(\\mathrm{AND}) = 1 + \\sum CC1(\\text{inputs})$。\n- 对于 $\\mathrm{OR}$：输出为 $0$ 需要所有输入都为 $0$，因此 $CC0(\\mathrm{OR}) = 1 + \\sum CC0(\\text{inputs})$。如果任何输入为 $1$，则输出为 $1$，因此 $CC1(\\mathrm{OR}) = 1 + \\min\\big(CC1(\\text{inputs})\\big)$。\n- $\\mathrm{NAND}$ 是 $\\mathrm{AND}$ 的反相：要得到输出 $0$，其反相前的 $\\mathrm{AND}$ 必须为 $1$，因此 $CC0(\\mathrm{NAND}) = 1 + \\sum CC1(\\text{inputs})$。要得到输出 $1$，其反相前的 $\\mathrm{AND}$ 必须为 $0$，因此 $CC1(\\mathrm{NAND}) = 1 + \\min\\big(CC0(\\text{inputs})\\big)$。\n- $\\mathrm{NOR}$ 是 $\\mathrm{OR}$ 的反相：$CC0(\\mathrm{NOR}) = 1 + \\min\\big(CC1(\\text{inputs})\\big)$ 且 $CC1(\\mathrm{NOR}) = 1 + \\sum CC0(\\text{inputs})$。\n- 对于 $\\mathrm{NOT}$：$CC0(\\mathrm{NOT}(x)) = 1 + CC1(x)$ 且 $CC1(\\mathrm{NOT}(x)) = 1 + CC0(x)$。\n- 对于双输入 $\\mathrm{XOR}(u,v)$：输出为 $0$ 需要 $u=v$，可以通过 $u=0,v=0$ 或 $u=1,v=1$ 实现，因此 $CC0(\\mathrm{XOR}) = 1 + \\min\\big(CC0(u)+CC0(v),\\; CC1(u)+CC1(v)\\big)$。输出为 $1$ 需要 $u\\neq v$，可以通过 $u=0,v=1$ 或 $u=1,v=0$ 实现，因此 $CC1(\\mathrm{XOR}) = 1 + \\min\\big(CC0(u)+CC1(v),\\; CC1(u)+CC0(v)\\big)$。\n\n我们从路径敏化推导逐门的可观测性：\n- 对于输出为 $y$、输入为 $x_i$ 的 $\\mathrm{AND}$ 门，要在 $y$ 处观测到 $x_i$，其他输入必须为 $1$，并且通过该门的遍历增加成本 $1$，因此 $CO(x_i) = 1 + CO(y) + \\sum_{j\\neq i} CC1(x_j)$。\n- 对于 $\\mathrm{OR}$ 门，要观测到 $x_i$，其他输入必须为 $0$，因此 $CO(x_i) = 1 + CO(y) + \\sum_{j\\neq i} CC0(x_j)$。\n- 对于 $\\mathrm{NAND}$ 和 $\\mathrm{NOR}$，输出端的反相不改变旁路输入的敏化；通过它们的可观测性与相应的 $\\mathrm{AND}$ 或 $\\mathrm{OR}$ 情况相匹配：$\\mathrm{NAND}$ 使用其他输入的 $CC1$，$\\mathrm{NOR}$ 使用其他输入的 $CC0$。\n- 对于 $\\mathrm{NOT}$：$CO(\\text{input}) = 1 + CO(\\text{output})$。\n- 对于双输入 $\\mathrm{XOR}$，要通过输出观测一个输入，另一个输入必须被敏化为 $0$ 或 $1$，取较容易者；因此 $CO(u) = 1 + CO(\\text{output}) + \\min\\big(CC0(v), CC1(v)\\big)$，对 $v$ 亦对称。\n- 对于扇出，一个节点的可观测性是其所有扇出分支中的最小值：$CO(x) = \\min_{\\text{fanout } f} CO_f(x)$。\n\n我们现在将这些应用到给定的网络。初始化主输入 (PIs)：\n- $CC0(a)=CC1(a)=CC0(b)=CC1(b)=\\cdots=CC0(g)=CC1(g)=1$。\n\n计算前向可控性：\n\n$\\,\\bullet\\,$ $n_1=\\mathrm{NAND}(a,b)$:\n- $CC0(n_1) = 1 + CC1(a) + CC1(b) = 1 + 1 + 1 = 3$。\n- $CC1(n_1) = 1 + \\min\\big(CC0(a), CC0(b)\\big) = 1 + \\min(1,1) = 2$。\n\n$\\,\\bullet\\,$ $n_2=\\mathrm{OR}(c,d)$:\n- $CC0(n_2) = 1 + CC0(c) + CC0(d) = 1 + 1 + 1 = 3$。\n- $CC1(n_2) = 1 + \\min\\big(CC1(c), CC1(d)\\big) = 1 + \\min(1,1) = 2$。\n\n$\\,\\bullet\\,$ $n_3=\\mathrm{AND}(n_1,n_2)$:\n- $CC0(n_3) = 1 + \\min\\big(CC0(n_1), CC0(n_2)\\big) = 1 + \\min(3,3) = 4$。\n- $CC1(n_3) = 1 + CC1(n_1) + CC1(n_2) = 1 + 2 + 2 = 5$。\n\n$\\,\\bullet\\,$ $n_4=\\mathrm{XOR}(n_3,e)$:\n- $CC0(n_4) = 1 + \\min\\big(CC0(n_3)+CC0(e),\\; CC1(n_3)+CC1(e)\\big) = 1 + \\min(4+1,\\; 5+1) = 1 + \\min(5,6) = 6$。\n- $CC1(n_4) = 1 + \\min\\big(CC0(n_3)+CC1(e),\\; CC1(n_3)+CC0(e)\\big) = 1 + \\min(4+1,\\; 5+1) = 6$。\n\n$\\,\\bullet\\,$ $n_5=\\mathrm{NOR}(f,g)$:\n- $CC0(n_5) = 1 + \\min\\big(CC1(f), CC1(g)\\big) = 1 + \\min(1,1) = 2$。\n- $CC1(n_5) = 1 + CC0(f) + CC0(g) = 1 + 1 + 1 = 3$。\n\n$\\,\\bullet\\,$ $n_6=\\mathrm{AND}(n_4,n_5)$:\n- $CC0(n_6) = 1 + \\min\\big(CC0(n_4), CC0(n_5)\\big) = 1 + \\min(6,2) = 3$。\n- $CC1(n_6) = 1 + CC1(n_4) + CC1(n_5) = 1 + 6 + 3 = 10$。\n\n$\\,\\bullet\\,$ $n_7=\\mathrm{NOT}(n_2)$:\n- $CC0(n_7) = 1 + CC1(n_2) = 1 + 2 = 3$。\n- $CC1(n_7) = 1 + CC0(n_2) = 1 + 3 = 4$。\n\n$\\,\\bullet\\,$ $y_1=\\mathrm{OR}(n_6,n_7)$:\n- $CC0(y_1) = 1 + CC0(n_6) + CC0(n_7) = 1 + 3 + 3 = 7$。\n- $CC1(y_1) = 1 + \\min\\big(CC1(n_6), CC1(n_7)\\big) = 1 + \\min(10,4) = 5$。\n\n$\\,\\bullet\\,$ $y_2=\\mathrm{AND}(n_1,e)$:\n- $CC0(y_2) = 1 + \\min\\big(CC0(n_1), CC0(e)\\big) = 1 + \\min(3,1) = 2$。\n- $CC1(y_2) = 1 + CC1(n_1) + CC1(e) = 1 + 2 + 1 = 4$。\n\n计算后向可观测性。初始化主输出 (POs)：\n- $CO(y_1)=0$, $CO(y_2)=0$。\n\n$\\,\\bullet\\,$ 通过 $y_1=\\mathrm{OR}(n_6,n_7)$:\n- $CO(n_6) = 1 + CO(y_1) + CC0(n_7) = 1 + 0 + 3 = 4$。\n- $CO(n_7) = 1 + CO(y_1) + CC0(n_6) = 1 + 0 + 3 = 4$。\n\n$\\,\\bullet\\,$ 通过 $y_2=\\mathrm{AND}(n_1,e)$:\n- $CO(n_1) = 1 + CO(y_2) + CC1(e) = 1 + 0 + 1 = 2$。\n- $CO(e) = 1 + CO(y_2) + CC1(n_1) = 1 + 0 + 2 = 3$。\n\n$\\,\\bullet\\,$ 通过 $n_6=\\mathrm{AND}(n_4,n_5)$:\n- $CO(n_4) = 1 + CO(n_6) + CC1(n_5) = 1 + 4 + 3 = 8$。\n- $CO(n_5) = 1 + CO(n_6) + CC1(n_4) = 1 + 4 + 6 = 11$。\n\n$\\,\\bullet\\,$ 通过 $n_7=\\mathrm{NOT}(n_2)$:\n- $CO(n_2)$ 通过此分支 $= 1 + CO(n_7) = 1 + 4 = 5$。\n\n$\\,\\bullet\\,$ 通过 $n_4=\\mathrm{XOR}(n_3,e)$:\n- $CO(n_3) = 1 + CO(n_4) + \\min\\big(CC0(e), CC1(e)\\big) = 1 + 8 + \\min(1,1) = 10$。\n- $CO(e)$ 通过此分支 $= 1 + CO(n_4) + \\min\\big(CC0(n_3), CC1(n_3)\\big) = 1 + 8 + \\min(4,5) = 13$。\n\n合并 $e$ 的扇出：$e$ 扇出到 $y_2$ 和 $n_4$，所以 $CO(e) = \\min(3,13) = 3$。\n\n$\\,\\bullet\\,$ 通过 $n_3=\\mathrm{AND}(n_1,n_2)$:\n- $CO(n_1)$ 通过此分支 $= 1 + CO(n_3) + CC1(n_2) = 1 + 10 + 2 = 13$。\n- $CO(n_2)$ 通过此分支 $= 1 + CO(n_3) + CC1(n_1) = 1 + 10 + 2 = 13$。\n\n合并扇出：\n- $n_1$ 扇出到 $y_2$ 和 $n_3$，所以 $CO(n_1) = \\min(2,13) = 2$。\n- $n_2$ 扇出到 $n_7$ 和 $n_3$，所以 $CO(n_2) = \\min(5,13) = 5$。\n\n$\\,\\bullet\\,$ 通过 $n_1=\\mathrm{NAND}(a,b)$:\n- $CO(a) = 1 + CO(n_1) + CC1(b) = 1 + 2 + 1 = 4$。\n- $CO(b) = 1 + CO(n_1) + CC1(a) = 1 + 2 + 1 = 4$。\n\n$\\,\\bullet\\,$ 通过 $n_2=\\mathrm{OR}(c,d)$:\n- $CO(c) = 1 + CO(n_2) + CC0(d) = 1 + 5 + 1 = 7$。\n- $CO(d) = 1 + CO(n_2) + CC0(c) = 7$。\n\n$\\,\\bullet\\,$ 通过 $n_5=\\mathrm{NOR}(f,g)$:\n- $CO(f) = 1 + CO(n_5) + CC0(g) = 1 + 11 + 1 = 13$。\n- $CO(g) = 1 + CO(n_5) + CC0(f) = 13$。\n\n我们总结 $CC0$、$CC1$、$CO$：\n- $a$：$CC0=1$, $CC1=1$, $CO=4$。\n- $b$：$CC0=1$, $CC1=1$, $CO=4$。\n- $c$：$CC0=1$, $CC1=1$, $CO=7$。\n- $d$：$CC0=1$, $CC1=1$, $CO=7$。\n- $e$：$CC0=1$, $CC1=1$, $CO=3$。\n- $f$：$CC0=1$, $CC1=1$, $CO=13$。\n- $g$：$CC0=1$, $CC1=1$, $CO=13$。\n- $n_1$：$CC0=3$, $CC1=2$, $CO=2$。\n- $n_2$：$CC0=3$, $CC1=2$, $CO=5$。\n- $n_3$：$CC0=4$, $CC1=5$, $CO=10$。\n- $n_4$：$CC0=6$, $CC1=6$, $CO=8$。\n- $n_5$：$CC0=2$, $CC1=3$, $CO=11$。\n- $n_6$：$CC0=3$, $CC1=10$, $CO=4$。\n- $n_7$：$CC0=3$, $CC1=4$, $CO=4$。\n- $y_1$：$CC0=7$, $CC1=5$, $CO=0$。\n- $y_2$：$CC0=2$, $CC1=4$, $CO=0$。\n\n定性地识别限制故障激活和传播的节点：\n- 最大的激活难度 $CC1$ 出现在 $n_6$（$CC1(n_6)=10$）和 $n_4$（$CC1(n_4)=6$）；最大的 $CC0$ 出现在 $n_4$（$CC0(n_4)=6$）和 $y_1$（$CC0(y_1)=7$）。\n- 最大的传播难度 $CO$ 出现在 $f$ 和 $g$（$CO=13$），以及 $n_5$（$CO=11$）和 $n_3$（$CO=10$）。\n\n计算每个节点的最坏情况固定型故障检测成本 $D(v) = \\max\\big(CC0(v)+CO(v),\\; CC1(v)+CO(v)\\big)$：\n- $D(a) = \\max(1+4,\\; 1+4) = 5$。\n- $D(b) = 5$。\n- $D(c) = \\max(1+7,\\; 1+7) = 8$。\n- $D(d) = 8$。\n- $D(e) = \\max(1+3,\\; 1+3) = 4$。\n- $D(f) = \\max(1+13,\\; 1+13) = 14$。\n- $D(g) = 14$。\n- $D(n_1) = \\max(3+2,\\; 2+2) = 5$。\n- $D(n_2) = \\max(3+5,\\; 2+5) = 8$。\n- $D(n_3) = \\max(4+10,\\; 5+10) = \\max(14,\\; 15) = 15$。\n- $D(n_4) = \\max(6+8,\\; 6+8) = 14$。\n- $D(n_5) = \\max(2+11,\\; 3+11) = \\max(13,\\; 14) = 14$。\n- $D(n_6) = \\max(3+4,\\; 10+4) = \\max(7,\\; 14) = 14$。\n- $D(n_7) = \\max(3+4,\\; 4+4) = 8$。\n- $D(y_1) = \\max(7+0,\\; 5+0) = 7$。\n- $D(y_2) = \\max(2+0,\\; 4+0) = 4$。\n\n因此，最大最坏情况检测成本为\n$$D_{\\max} = 15,$$\n在节点 $n_3$ 处达到。",
            "answer": "$$\\boxed{15}$$"
        },
        {
            "introduction": "在识别出可测试性问题后，下一个挑战是系统地生成能够检测特定故障的输入模式，即测试向量。本练习将引导您手动实践面向路径的决策 (PODEM) 算法，这是一种经典的自动测试图形生成 (ATPG) 方法。通过亲手执行该算法以寻找一个固定型故障的测试向量，您将掌握构成所有现代 ATPG 工具基础的故障激活和传播等核心概念 。",
            "id": "4264494",
            "problem": "考虑一个在电子设计自动化（EDA）和可测试性设计（DFT）背景下的组合逻辑模块，其主输入为 $a$、$b$、$c$、$d$、$e$、$f$，以及一个单一主输出 $o$。内部信号由以下布尔关系定义：\n$$x = \\neg(a \\land b),$$\n$$y = c \\oplus d,$$\n$$z = y \\lor e,$$\n$$m = x \\land z,$$\n$$n = x \\lor f,$$\n$$t = \\neg(n \\oplus m),$$\n且主输出为\n$$o = t.$$\n假设采用单一固定型故障模型，目标故障为线路 $z$（产生 $z$ 的 $\\lor$ 门的输出）上的固定于$0$（stuck-at-$0$）故障。使用面向路径的决策（PODEM）算法，为有序输入 $(a,b,c,d,e,f)$ 计算一个完整的测试向量，以在主输出 $o$ 处检测到此故障。您的推导必须从基本定义开始：单一固定型故障模型、五值逻辑 $\\{0,1,X,D,D'\\}$（其中 $D$ 表示无故障电路中的值为 $1$ 而故障电路中为 $0$，$D'$ 表示无故障电路中的值为 $0$ 而故障电路中为 $1$），以及门级的可控性和可观测性原理（$\\land$、$\\lor$、$\\oplus$ 和 $\\operatorname{XNOR}$ 的控制值和非控制值）。\n\n您必须证明 PODEM 目标选择、到主输入的回溯以及前向蕴含步骤的合理性，并通过证明无故障电路和故障电路中最终的主输出值不同（即 $o_{\\text{good}} \\neq o_{\\text{faulty}}$）来证明其正确性。请以对应于 $(a,b,c,d,e,f)$ 的单个有序 $6$-元组形式提供最终答案。由于答案是一个二进制向量，因此不需要四舍五入或单位说明。您的最终向量必须完全赋值，其值在 $\\{0,1\\}$ 集合中。",
            "solution": "目标是找到一个测试向量 $(a,b,c,d,e,f)$，用于检测单一固定型故障 $z/0$，即线路 $z$ 永久固定在逻辑值 $0$。我们将使用 PODEM 算法，该算法通过系统地对主输入（PI）进行赋值，以满足故障检测的两个条件：故障激活和故障传播。逻辑值使用五值代数 $\\{0,1,X,D,D'\\}$ 表示，其中 $D$ 代表正常电路值为 $1$、故障电路值为 $0$，而 $X$ 表示未知或未指定的值。\n\n**1. 故障激活**\n\n为了检测线路 $z$ 上的固定于 $0$ 故障，我们必须首先在无故障（正常）电路中将线路 $z$ 驱动为逻辑 $1$。这是故障激活条件。这会在故障点产生一个复合值 $D$，因为 $z_{\\text{good}}=1$ 而 $z_{\\text{faulty}}=0$。\n\n因此，PODEM 的初始目标是设置 $z=1$。\n产生 $z$ 的门由布尔表达式 $z = y \\lor e$ 定义。要将一个 $\\lor$ 门的输出强制为 $1$，我们必须将其至少一个输入设置为 $1$。PODEM 算法必须选择满足条件的其中一个输入。我们可以选择 $y=1$ 或 $e=1$。一个常见的启发式方法是选择一个更容易满足的目标，这通常意味着选择一个更靠近主输入的输入。由于 $e$ 是一个主输入，设置目标 $(e,1)$ 是一个直接的选择。\n\n**回溯步骤 1：**\n初始目标 $(z,1)$ 通过回溯穿过 $\\lor$ 门，转换为其输入之一。我们选择目标 $(e,1)$。由于 $e$ 是主输入，回溯阶段完成，我们进行主输入赋值 $e=1$。\n\n**前向蕴含步骤 1：**\n在赋值 $e=1$ 且所有其他主输入设置为 $X$ 的情况下，我们通过电路向前传播已知值。\n现在 $z$ 的值为 $z = y \\lor e = X \\lor 1 = 1$。\n此赋值满足了故障激活条件。线路 $z$ 上的信号现在是 $D$（在正常电路中值为 $1$，在故障电路中值为 $0$）。\n\n**2. 故障传播**\n\n下一阶段是将故障效应（由 $D$ 表示）从故障点 $z$ 传播到主输出 $o$。传播路径经过门 $m$ 和 $t$，即 $z \\rightarrow m \\rightarrow t \\rightarrow o$。\n\n要将故障效应从一个门的输入传播到其输出，该门的所有其他输入必须设置为它们的非控制值。\n\n**新目标（通过门 $m$ 传播）：**\n门 $m$ 由 $m = x \\land z$ 定义。要通过这个 $\\land$ 门从输入 $z$ 传播值，另一个输入 $x$ 必须被设置为 $\\land$ 门的非控制值，即 $1$。因此，PODEM 的新目标是 $(x,1)$。\n\n**回溯步骤 2：**\n目标是 $(x,1)$。信号 $x$ 由门 $x = \\neg(a \\land b)$ 产生，这是一个与非门（NAND gate）。要使与非门的输出为 $1$，其输入不能同时为 $1$；也就是说，$a \\land b$ 必须等于 $0$。这可以通过设置 $a=0$ 或 $b=0$ 来实现。我们选择设置目标 $(a,0)$。由于 $a$ 是主输入，回溯完成，得到主输入赋值 $a=0$。\n\n**前向蕴含步骤 2：**\n当前的主输入赋值是 $a=0$ 和 $e=1$。其他主输入保持为 $X$。我们重新评估电路。\n- $x = \\neg(a \\land b) = \\neg(0 \\land X) = \\neg(0) = 1$。目标 $(x,1)$ 已满足。\n- 现在我们检查 $D$ 的传播。在门 $m$ 处，我们有输入 $x=1$ 和 $z=D$。\n  - $m_{\\text{good}} = x_{\\text{good}} \\land z_{\\text{good}} = 1 \\land 1 = 1$。\n  - $m_{\\text{faulty}} = x_{\\text{faulty}} \\land z_{\\text{faulty}} = 1 \\land 0 = 0$。\n  - 因此，门 $m$ 的输出是 $D$。故障效应已成功传播到线路 $m$。\n\n**新目标（通过门 $t$ 传播）：**\n路径中的下一个门是 $t = \\neg(n \\oplus m)$，这是一个异或非门（XNOR gate）。要通过异或门（XOR）或异或非门从输入 $m$ 传播故障效应，我们必须通过将另一个输入 $n$ 设置为已知值（$0$ 或 $1$）来敏化路径。让我们评估 $n$。\n- $n = x \\lor f$。根据我们之前的赋值，我们有 $x=1$。\n- 因此，$n = 1 \\lor f = 1$，无论 $f$ 的值是多少。通过现有的主输入赋值，$n$ 的值已经被确定为 $1$。不需要新的目标。\n\n**最终前向蕴含：**\n门 $t$ 的输入是 $n=1$ 和 $m=D$。\n- $t_{\\text{good}} = \\neg(n_{\\text{good}} \\oplus m_{\\text{good}}) = \\neg(1 \\oplus 1) = \\neg(0) = 1$。\n- $t_{\\text{faulty}} = \\neg(n_{\\text{faulty}} \\oplus m_{\\text{faulty}}) = \\neg(1 \\oplus 0) = \\neg(1) = 0$。\n- 因此，门 $t$ 的输出是 $D$。\n主输出是 $o=t$。因此，$o = D$。\n\n在主输出处出现 $D$（或 $D'$）值表示故障被检测到。PODEM 算法已找到一组检测故障 $z/0$ 的主输入赋值。所做的赋值是 $a=0$ 和 $e=1$。对于此测试，其他主输入（$b,c,d,f$）是“无关项”（$X$）。为了提供一个完整的、完全指定的测试向量，我们可以为它们赋任何二进制值。一个常规的选择是将所有未指定的输入设置为 $0$。\n\n这得出了测试向量 $(a,b,c,d,e,f) = (0,0,0,0,1,0)$。\n\n**3. 测试向量的验证**\n\n我们必须证明向量 $(0,0,0,0,1,0)$ 能够检测到故障 $z/0$。\n\n**无故障（正常）电路仿真：**\n- 输入：$a=0, b=0, c=0, d=0, e=1, f=0$。\n- $x = \\neg(a \\land b) = \\neg(0 \\land 0) = \\neg(0) = 1$。\n- $y = c \\oplus d = 0 \\oplus 0 = 0$。\n- $z = y \\lor e = 0 \\lor 1 = 1$。\n- $m = x \\land z = 1 \\land 1 = 1$。\n- $n = x \\lor f = 1 \\lor 0 = 1$。\n- $t = \\neg(n \\oplus m) = \\neg(1 \\oplus 1) = \\neg(0) = 1$。\n- 主输出：$o_{\\text{good}} = t = 1$。\n\n**故障电路仿真（$z$ 固定于 $0$）：**\n- 输入：$a=0, b=0, c=0, d=0, e=1, f=0$。\n- 故障点之前的节点值与正常电路中相同。\n- $x = 1$。\n- 线路 $z$ 被强制为 $0$，所以 $z_{\\text{faulty}} = 0$。\n- $m = x \\land z = 1 \\land 0 = 0$。\n- $n = x \\lor f = 1 \\lor 0 = 1$。\n- $t = \\neg(n \\oplus m) = \\neg(1 \\oplus 0) = \\neg(1) = 0$。\n- 主输出：$o_{\\text{faulty}} = t = 0$。\n\n**验证结论：**\n由于 $o_{\\text{good}} = 1$ 且 $o_{\\text{faulty}} = 0$，主输出值不同。测试向量 $(0,0,0,0,1,0)$ 成功检测到故障 $z/0$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  0  0  0  1  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "测试向量的实际应用涉及将其加载到芯片中，这会消耗自动测试设备 (ATE) 的时间和资源。本练习通过分析测试应用时间、扫描链数量和 ATE 引脚利用率之间的关系，探讨了扫描测试的经济学。通过计算和比较单扫描链与多扫描链架构的效率，您将学会量化在设计高性价比测试策略时所涉及的基本权衡 。",
            "id": "4264470",
            "problem": "一个同步可测试性设计扫描架构被应用于一个大型数字片上系统，以使用自动测试设备（ATE）进行结构化测试。该扫描方法通过将激励比特移入扫描触发器，施加一个捕获周期，然后将响应比特移出来运行。在重叠扫描输入/扫描输出执行模型下，一旦第一个测试图形加载完毕，当前测试图形的卸载将与下一个测试图形的加载同时进行，并假设每个测试图形有一个捕获周期。设扫描触发器的总数为 $N_{\\text{ff}}$，测试图形的数量为 $P$，扫描移位频率为 $f_{\\text{shift}}$，扫描链的数量为 $k$。假设扫描链是完全平衡的，因此最长链的长度为 $L_{k} = N_{\\text{ff}}/k$。\n\n考虑两种配置：\n- 基准单链配置，$k = 1$。\n- 并行多链配置，$k = 10$。\n\n假设 $N_{\\text{ff}} = 1{,}000{,}000$，$P = 5{,}000$，$f_{\\text{shift}} = 50 \\times 10^{6}$ Hz，且每个测试图形有一个捕获周期。ATE 有 $C = 1{,}024$ 个可用通道。该设备需要 $p_{\\text{func}} = 300$ 个功能性 I/O 通道和 $p_{\\text{ctrl}} = 4$ 个测试控制通道（用于诸如扫描使能、测试时钟、模式和复位等项目）。每个扫描链消耗一个扫描输入和一个扫描输出 ATE 通道。将配置 $k$ 的 ATE 引脚利用率定义为该配置下设备使用的 ATE 通道所占的比例 $U_{k}$。\n\n令 $T_{k}$ 为在配置 $k$ 下使用重叠执行模型应用所有 $P$ 个测试图形的总 ATE 时间，令 $U_{k}$ 为相应的 ATE 引脚利用率。定义效率指数\n$$\\Phi = \\frac{T_{1}/T_{10}}{U_{10}/U_{1}}.$$\n该指数用于量化当配置从 $k=1$ 变为 $k=10$ 时，测试时间缩减与 ATE 引脚利用率增加的比率。\n\n计算给定参数下的 $\\Phi$。最终答案以纯数字形式表示，不带单位，并四舍五入到四位有效数字。",
            "solution": "本问题要求计算一个效率指数 $\\Phi$，该指数关联了从单扫描链配置（$k=1$）变为并行多链配置（$k=10$）时，测试时间的缩减与 ATE 引脚利用率的增加。该效率指数定义为：\n$$ \\Phi = \\frac{T_{1}/T_{10}}{U_{10}/U_{1}} $$\n其中，$T_k$ 是具有 $k$ 条扫描链的配置的总测试时间，$U_k$ 是其 ATE 引脚利用率。\n\n首先，我们必须推导出总 ATE 测试时间 $T_k$ 的表达式。\n测试应用过程遵循一个重叠扫描输入/扫描输出模型，每个测试图形有一个捕获周期。设 $L_k$ 为最长扫描链的长度，$P$ 为测试图形的数量，$f_{\\text{shift}}$ 为扫描移位频率。\n\n应用 $P$ 个测试图形所需的总周期数为：\n$$ N_{\\text{cycles},k} = (P+1)L_k + P $$\n问题陈述扫描链是完全平衡的，所以 $L_k = N_{\\text{ff}}/k$。将此代入周期数表达式中：\n$$ N_{\\text{cycles},k} = (P+1)\\frac{N_{\\text{ff}}}{k} + P $$\n总测试时间 $T_k$ 是总周期数除以移位频率 $f_{\\text{shift}}$：\n$$ T_k = \\frac{N_{\\text{cycles},k}}{f_{\\text{shift}}} = \\frac{(P+1)\\frac{N_{\\text{ff}}}{k} + P}{f_{\\text{shift}}} $$\n\n接下来，我们推导 ATE 引脚利用率 $U_k$ 的表达式。\n设备使用的 ATE 通道总数是功能性 I/O 通道（$p_{\\text{func}}$）、测试控制通道（$p_{\\text{ctrl}}$）和扫描链通道的总和。$k$ 条扫描链中的每一条都需要一个扫描输入和一个扫描输出通道，因此扫描链消耗 $2k$ 个通道。\n配置 $k$ 中使用的引脚总数为：\n$$ p_{\\text{total},k} = p_{\\text{func}} + p_{\\text{ctrl}} + 2k $$\n引脚利用率 $U_k$ 是所使用的 ATE 通道数占总可用通道数（$C$）的比例：\n$$ U_k = \\frac{p_{\\text{total},k}}{C} = \\frac{p_{\\text{func}} + p_{\\text{ctrl}} + 2k}{C} $$\n\n现在，我们可以计算 $\\Phi$ 所需的比率。\n测试时间的比率为：\n$$ \\frac{T_1}{T_{10}} = \\frac{\\frac{(P+1)\\frac{N_{\\text{ff}}}{1} + P}{f_{\\text{shift}}}}{\\frac{(P+1)\\frac{N_{\\text{ff}}}{10} + P}{f_{\\text{shift}}}} = \\frac{(P+1)N_{\\text{ff}} + P}{(P+1)\\frac{N_{\\text{ff}}}{10} + P} $$\n引脚利用率的比率为：\n$$ \\frac{U_{10}}{U_1} = \\frac{\\frac{p_{\\text{func}} + p_{\\text{ctrl}} + 2(10)}{C}}{\\frac{p_{\\text{func}} + p_{\\text{ctrl}} + 2(1)}{C}} = \\frac{p_{\\text{func}} + p_{\\text{ctrl}} + 20}{p_{\\text{func}} + p_{\\text{ctrl}} + 2} $$\n\n我们现在代入给定的数值：\n$N_{\\text{ff}} = 1{,}000{,}000 = 10^6$\n$P = 5{,}000$\n$p_{\\text{func}} = 300$\n$p_{\\text{ctrl}} = 4$\n$C = 1{,}024$\n\n首先，计算测试时间比率：\n$P+1 = 5001$。\n$$ \\frac{T_1}{T_{10}} = \\frac{(5001)(10^6) + 5000}{(5001)\\frac{10^6}{10} + 5000} = \\frac{5001000000 + 5000}{500100000 + 5000} = \\frac{5001005000}{500105000} \\approx 9.99991001 $$\n\n接下来，计算引脚利用率比率：\n$$ \\frac{U_{10}}{U_1} = \\frac{300 + 4 + 20}{300 + 4 + 2} = \\frac{324}{306} $$\n这个分数可以简化。分子和分母都能被 $18$ 整除：\n$$ \\frac{324}{18} = 18 \\quad \\text{和} \\quad \\frac{306}{18} = 17 $$\n所以，\n$$ \\frac{U_{10}}{U_1} = \\frac{18}{17} \\approx 1.05882353 $$\n\n最后，我们计算效率指数 $\\Phi$：\n$$ \\Phi = \\frac{T_{1}/T_{10}}{U_{10}/U_{1}} = \\frac{5001005000/500105000}{18/17} = \\frac{9.99991001...}{1.05882353...} \\approx 9.44436589 $$\n将结果四舍五入到四位有效数字，得到 $9.444$。",
            "answer": "$$\\boxed{9.444}$$"
        }
    ]
}