{
    "hands_on_practices": [
        {
            "introduction": "在可测性设计（DFT）流程中，首要步骤是进行可测性分析。在投入昂贵的测试生成过程之前，我们需要一种方法来量化电路内部节点被控制和观测的难度。SCOAP（Sandia Controllability/Observability Analysis Program）是一种经典的、计算高效的度量方法，它能够估算测试难度，从而指导设计者在必要之处（例如，在控制性或观测性差的节点）添加测试点以改善可测性。本练习  将引导你从第一性原理出发，亲手计算一个电路的SCOAP值，从而深入理解可测性的量化过程。",
            "id": "4264468",
            "problem": "考虑以下在门级指定的单时钟域组合网络。设计背景是电子设计自动化 (EDA) 中的可测试性设计 (DFT)。该网络有主输入 (PI) $a$、$b$、$c$、$d$、$e$、$f$、$g$ 和主输出 (PO) $y_1$、$y_2$。内部节点为 $n_1$、$n_2$、$n_3$、$n_4$、$n_5$、$n_6$、$n_7$。所有门的成本均为单位成本，意味着当一个信号值被强制通过门或当一个效应通过门传播时，每个门贡献的成本为 $1$。\n\n网络定义如下：\n- $n_1 = \\mathrm{NAND}(a,b)$\n- $n_2 = \\mathrm{OR}(c,d)$\n- $n_3 = \\mathrm{AND}(n_1,n_2)$\n- $n_4 = \\mathrm{XOR}(n_3,e)$\n- $n_5 = \\mathrm{NOR}(f,g)$\n- $n_6 = \\mathrm{AND}(n_4,n_5)$\n- $n_7 = \\mathrm{NOT}(n_2)$\n- $y_1 = \\mathrm{OR}(n_6,n_7)$\n- $y_2 = \\mathrm{AND}(n_1,e)$\n\n使用 Sandia Controllability/Observability Analysis Program (SCOAP) 框架，计算网络中每个节点的可控性度量 $CC0$ 和 $CC1$ 以及可观测性度量 $CO$。基于以下核心定义进行推导：\n- 可控性 $CC0(x)$ 和 $CC1(x)$ 分别量化了从主输入开始，将节点 $x$ 强制为逻辑 $0$ 或逻辑 $1$ 的最小成本，同时考虑了门的语义和所需的旁路输入赋值。\n- 可观测性 $CO(x)$ 量化了将节点 $x$ 处的逻辑差异传播到至少一个主输出的最小成本，同时考虑了从 $x$ 到主输出的路径敏化。\n\n假设基准成本为：对于任何主输入 $x$，$CC0(x)=CC1(x)=1$；对于任何主输出 $y$，$CO(y)=0$。不要假设门特定的 SCOAP 封闭形式递推关系；而是使用布尔语义和路径敏化从第一性原理进行推导。\n\n在计算完所有节点的 $CC0$、$CC1$ 和 $CO$ 后，将节点 $v$ 的最坏情况固定型故障检测成本定义为\n$$D(v) = \\max\\!\\big(CC0(v) + CO(v),\\; CC1(v) + CO(v)\\big).$$\n在网络中的所有节点（包括主输入和内部节点，但注意主输出的 $CO$ 已经为 $0$）中，确定最大值\n$$D_{\\max} = \\max_{v} D(v).$$\n\n仅报告 $D_{\\max}$ 作为最终答案。最终答案必须是单个实数值。无需四舍五入。",
            "solution": "我们从可控性和可观测性的核心定义开始。可控性 $CC0(x)$ 是从主输入将节点 $x$ 强制为逻辑 $0$ 的最小成本，而 $CC1(x)$ 是将节点 $x$ 强制为逻辑 $1$ 的最小成本。可观测性 $CO(x)$ 是将节点 $x$ 处的逻辑差异传播到主输出的最小成本。所有成本都计算门遍历和必要的旁路输入赋值，每个成本单位为 $1$。\n\n基线初始化遵循定义：\n- 对于任何主输入 $p$，将 $p$ 强制为 $0$ 或 $1$ 是一个直接赋值，成本为 $1$，所以 $CC0(p)=1$ 且 $CC1(p)=1$。\n- 对于任何主输出 $y$，差异已经位于输出端，所以 $CO(y)=0$。\n\n我们从布尔语义推导门级的可控性：\n- 对于 $\\mathrm{AND}$：若任一输入为 $0$，则输出为 $0$，所以 $CC0(\\mathrm{AND}) = 1 + \\min\\big(CC0(\\text{inputs})\\big)$。输出为 $1$ 要求所有输入为 $1$，所以 $CC1(\\mathrm{AND}) = 1 + \\sum CC1(\\text{inputs})$。\n- 对于 $\\mathrm{OR}$：输出为 $0$ 要求所有输入为 $0$，所以 $CC0(\\mathrm{OR}) = 1 + \\sum CC0(\\text{inputs})$。若任一输入为 $1$，则输出为 $1$，所以 $CC1(\\mathrm{OR}) = 1 + \\min\\big(CC1(\\text{inputs})\\big)$。\n- 对于 $\\mathrm{NAND}$，它是 $\\mathrm{AND}$ 的反相：要得到输出 $0$，其反相前的 $\\mathrm{AND}$ 必须为 $1$，所以 $CC0(\\mathrm{NAND}) = 1 + \\sum CC1(\\text{inputs})$。要得到输出 $1$，其反相前的 $\\mathrm{AND}$ 必须为 $0$，所以 $CC1(\\mathrm{NAND}) = 1 + \\min\\big(CC0(\\text{inputs})\\big)$。\n- 对于 $\\mathrm{NOR}$，它是 $\\mathrm{OR}$ 的反相：$CC0(\\mathrm{NOR}) = 1 + \\min\\big(CC1(\\text{inputs})\\big)$ 且 $CC1(\\mathrm{NOR}) = 1 + \\sum CC0(\\text{inputs})$。\n- 对于 $\\mathrm{NOT}$：$CC0(\\mathrm{NOT}(x)) = 1 + CC1(x)$ 且 $CC1(\\mathrm{NOT}(x)) = 1 + CC0(x)$。\n- 对于双输入 $\\mathrm{XOR}(u,v)$：输出为 $0$ 要求 $u=v$，可通过 $u=0,v=0$ 或 $u=1,v=1$ 实现，因此 $CC0(\\mathrm{XOR}) = 1 + \\min\\big(CC0(u)+CC0(v),\\; CC1(u)+CC1(v)\\big)$。输出为 $1$ 要求 $u\\neq v$，可通过 $u=0,v=1$ 或 $u=1,v=0$ 实现，因此 $CC1(\\mathrm{XOR}) = 1 + \\min\\big(CC0(u)+CC1(v),\\; CC1(u)+CC0(v)\\big)$。\n\n我们从路径敏化推导门级的可观测性：\n- 对于输出为 $y$、输入为 $x_i$ 的 $\\mathrm{AND}$ 门，要在 $y$ 处观测到 $x_i$，其他输入必须为 $1$，且通过该门的遍历增加成本 $1$，所以 $CO(x_i) = 1 + CO(y) + \\sum_{j\\neq i} CC1(x_j)$。\n- 对于 $\\mathrm{OR}$ 门，要观测到 $x_i$，其他输入必须为 $0$，所以 $CO(x_i) = 1 + CO(y) + \\sum_{j\\neq i} CC0(x_j)$。\n- 对于 $\\mathrm{NAND}$ 和 $\\mathrm{NOR}$ 门，输出端的反相不改变旁路输入的敏化要求；通过它们的可观测性与相应的 $\\mathrm{AND}$ 或 $\\mathrm{OR}$ 情况相匹配：$\\mathrm{NAND}$ 使用其他输入的 $CC1$，$\\mathrm{NOR}$ 使用其他输入的 $CC0$。\n- 对于 $\\mathrm{NOT}$ 门，$CO(\\text{input}) = 1 + CO(\\text{output})$。\n- 对于双输入 $\\mathrm{XOR}$ 门，要通过输出观测一个输入，另一个输入必须被敏化为 $0$ 或 $1$ 中较容易的一个；因此 $CO(u) = 1 + CO(\\text{output}) + \\min\\big(CC0(v), CC1(v)\\big)$，对 $v$ 也对称。\n- 对于扇出，节点的可观测性是其所有扇出分支中可观测性的最小值：$CO(x) = \\min_{\\text{fanout } f} CO_f(x)$。\n\n现在我们将这些应用到给定的网络。初始化主输入(PI)：\n- $CC0(a)=CC1(a)=CC0(b)=CC1(b)=\\cdots=CC0(g)=CC1(g)=1$。\n\n计算前向可控性：\n\n$\\,\\bullet\\,$ $n_1=\\mathrm{NAND}(a,b)$:\n- $CC0(n_1) = 1 + CC1(a) + CC1(b) = 1 + 1 + 1 = 3$.\n- $CC1(n_1) = 1 + \\min\\big(CC0(a), CC0(b)\\big) = 1 + \\min(1,1) = 2$.\n\n$\\,\\bullet\\,$ $n_2=\\mathrm{OR}(c,d)$:\n- $CC0(n_2) = 1 + CC0(c) + CC0(d) = 1 + 1 + 1 = 3$.\n- $CC1(n_2) = 1 + \\min\\big(CC1(c), CC1(d)\\big) = 1 + \\min(1,1) = 2$.\n\n$\\,\\bullet\\,$ $n_3=\\mathrm{AND}(n_1,n_2)$:\n- $CC0(n_3) = 1 + \\min\\big(CC0(n_1), CC0(n_2)\\big) = 1 + \\min(3,3) = 4$.\n- $CC1(n_3) = 1 + CC1(n_1) + CC1(n_2) = 1 + 2 + 2 = 5$.\n\n$\\,\\bullet\\,$ $n_4=\\mathrm{XOR}(n_3,e)$:\n- $CC0(n_4) = 1 + \\min\\big(CC0(n_3)+CC0(e),\\; CC1(n_3)+CC1(e)\\big) = 1 + \\min(4+1,\\; 5+1) = 1 + \\min(5,6) = 6$.\n- $CC1(n_4) = 1 + \\min\\big(CC0(n_3)+CC1(e),\\; CC1(n_3)+CC0(e)\\big) = 1 + \\min(4+1,\\; 5+1) = 6$.\n\n$\\,\\bullet\\,$ $n_5=\\mathrm{NOR}(f,g)$:\n- $CC0(n_5) = 1 + \\min\\big(CC1(f), CC1(g)\\big) = 1 + \\min(1,1) = 2$.\n- $CC1(n_5) = 1 + CC0(f) + CC0(g) = 1 + 1 + 1 = 3$.\n\n$\\,\\bullet\\,$ $n_6=\\mathrm{AND}(n_4,n_5)$:\n- $CC0(n_6) = 1 + \\min\\big(CC0(n_4), CC0(n_5)\\big) = 1 + \\min(6,2) = 3$.\n- $CC1(n_6) = 1 + CC1(n_4) + CC1(n_5) = 1 + 6 + 3 = 10$.\n\n$\\,\\bullet\\,$ $n_7=\\mathrm{NOT}(n_2)$:\n- $CC0(n_7) = 1 + CC1(n_2) = 1 + 2 = 3$.\n- $CC1(n_7) = 1 + CC0(n_2) = 1 + 3 = 4$.\n\n$\\,\\bullet\\,$ $y_1=\\mathrm{OR}(n_6,n_7)$:\n- $CC0(y_1) = 1 + CC0(n_6) + CC0(n_7) = 1 + 3 + 3 = 7$.\n- $CC1(y_1) = 1 + \\min\\big(CC1(n_6), CC1(n_7)\\big) = 1 + \\min(10,4) = 5$.\n\n$\\,\\bullet\\,$ $y_2=\\mathrm{AND}(n_1,e)$:\n- $CC0(y_2) = 1 + \\min\\big(CC0(n_1), CC0(e)\\big) = 1 + \\min(3,1) = 2$.\n- $CC1(y_2) = 1 + CC1(n_1) + CC1(e) = 1 + 2 + 1 = 4$.\n\n计算后向可观测性。初始化主输出(PO)：\n- $CO(y_1)=0$, $CO(y_2)=0$。\n\n$\\,\\bullet\\,$ 通过 $y_1=\\mathrm{OR}(n_6,n_7)$:\n- $CO(n_6) = 1 + CO(y_1) + CC0(n_7) = 1 + 0 + 3 = 4$.\n- $CO(n_7) = 1 + CO(y_1) + CC0(n_6) = 1 + 0 + 3 = 4$.\n\n$\\,\\bullet\\,$ 通过 $y_2=\\mathrm{AND}(n_1,e)$:\n- $CO(n_1) = 1 + CO(y_2) + CC1(e) = 1 + 0 + 1 = 2$.\n- $CO(e) = 1 + CO(y_2) + CC1(n_1) = 1 + 0 + 2 = 3$.\n\n$\\,\\bullet\\,$ 通过 $n_6=\\mathrm{AND}(n_4,n_5)$:\n- $CO(n_4) = 1 + CO(n_6) + CC1(n_5) = 1 + 4 + 3 = 8$.\n- $CO(n_5) = 1 + CO(n_6) + CC1(n_4) = 1 + 4 + 6 = 11$.\n\n$\\,\\bullet\\,$ 通过 $n_7=\\mathrm{NOT}(n_2)$:\n- 此分支的 $CO(n_2) = 1 + CO(n_7) = 1 + 4 = 5$.\n\n$\\,\\bullet\\,$ 通过 $n_4=\\mathrm{XOR}(n_3,e)$:\n- $CO(n_3) = 1 + CO(n_4) + \\min\\big(CC0(e), CC1(e)\\big) = 1 + 8 + \\min(1,1) = 10$.\n- 此分支的 $CO(e) = 1 + CO(n_4) + \\min\\big(CC0(n_3), CC1(n_3)\\big) = 1 + 8 + \\min(4,5) = 13$.\n\n合并 $e$ 的扇出：$e$ 扇出到 $y_2$ 和 $n_4$，所以 $CO(e) = \\min(3,13) = 3$。\n\n$\\,\\bullet\\,$ 通过 $n_3=\\mathrm{AND}(n_1,n_2)$:\n- 此分支的 $CO(n_1) = 1 + CO(n_3) + CC1(n_2) = 1 + 10 + 2 = 13$.\n- 此分支的 $CO(n_2) = 1 + CO(n_3) + CC1(n_1) = 1 + 10 + 2 = 13$.\n\n合并扇出：\n- $n_1$ 扇出到 $y_2$ 和 $n_3$，所以 $CO(n_1) = \\min(2,13) = 2$。\n- $n_2$ 扇出到 $n_7$ 和 $n_3$，所以 $CO(n_2) = \\min(5,13) = 5$。\n\n$\\,\\bullet\\,$ 通过 $n_1=\\mathrm{NAND}(a,b)$:\n- $CO(a) = 1 + CO(n_1) + CC1(b) = 1 + 2 + 1 = 4$.\n- $CO(b) = 1 + CO(n_1) + CC1(a) = 1 + 2 + 1 = 4$.\n\n$\\,\\bullet\\,$ 通过 $n_2=\\mathrm{OR}(c,d)$:\n- $CO(c) = 1 + CO(n_2) + CC0(d) = 1 + 5 + 1 = 7$.\n- $CO(d) = 1 + CO(n_2) + CC0(c) = 7$.\n\n$\\,\\bullet\\,$ 通过 $n_5=\\mathrm{NOR}(f,g)$:\n- $CO(f) = 1 + CO(n_5) + CC0(g) = 1 + 11 + 1 = 13$.\n- $CO(g) = 1 + CO(n_5) + CC0(f) = 13$.\n\n我们总结 $CC0$、$CC1$、$CO$：\n- $a$: $CC0=1$, $CC1=1$, $CO=4$.\n- $b$: $CC0=1$, $CC1=1$, $CO=4$.\n- $c$: $CC0=1$, $CC1=1$, $CO=7$.\n- $d$: $CC0=1$, $CC1=1$, $CO=7$.\n- $e$: $CC0=1$, $CC1=1$, $CO=3$.\n- $f$: $CC0=1$, $CC1=1$, $CO=13$.\n- $g$: $CC0=1$, $CC1=1$, $CO=13$.\n- $n_1$: $CC0=3$, $CC1=2$, $CO=2$.\n- $n_2$: $CC0=3$, $CC1=2$, $CO=5$.\n- $n_3$: $CC0=4$, $CC1=5$, $CO=10$.\n- $n_4$: $CC0=6$, $CC1=6$, $CO=8$.\n- $n_5$: $CC0=2$, $CC1=3$, $CO=11$.\n- $n_6$: $CC0=3$, $CC1=10$, $CO=4$.\n- $n_7$: $CC0=3$, $CC1=4$, $CO=4$.\n- $y_1$: $CC0=7$, $CC1=5$, $CO=0$.\n- $y_2$: $CC0=2$, $CC1=4$, $CO=0$.\n\n定性地识别限制故障激活和传播的节点：\n- 最大的激活难度 $CC1$ 出现在 $n_6$，其 $CC1(n_6)=10$；以及 $n_4$，其 $CC1(n_4)=6$。最大的 $CC0$ 出现在 $n_4$，其 $CC0(n_4)=6$；以及 $y_1$，其 $CC0(y_1)=7$。\n- 最大的传播难度 $CO$ 出现在 $f$ 和 $g$，其 $CO=13$；以及 $n_5$，其 $CO=11$；以及 $n_3$，其 $CO=10$。\n\n计算每个节点的最坏情况固定型故障检测成本 $D(v) = \\max\\big(CC0(v)+CO(v),\\; CC1(v)+CO(v)\\big)$：\n- $D(a) = \\max(1+4,\\; 1+4) = 5$.\n- $D(b) = 5$.\n- $D(c) = \\max(1+7,\\; 1+7) = 8$.\n- $D(d) = 8$.\n- $D(e) = \\max(1+3,\\; 1+3) = 4$.\n- $D(f) = \\max(1+13,\\; 1+13) = 14$.\n- $D(g) = 14$.\n- $D(n_1) = \\max(3+2,\\; 2+2) = 5$.\n- $D(n_2) = \\max(3+5,\\; 2+5) = 8$.\n- $D(n_3) = \\max(4+10,\\; 5+10) = \\max(14,\\; 15) = 15$.\n- $D(n_4) = \\max(6+8,\\; 6+8) = 14$.\n- $D(n_5) = \\max(2+11,\\; 3+11) = \\max(13,\\; 14) = 14$.\n- $D(n_6) = \\max(3+4,\\; 10+4) = \\max(7,\\; 14) = 14$.\n- $D(n_7) = \\max(3+4,\\; 4+4) = 8$.\n- $D(y_1) = \\max(7+0,\\; 5+0) = 7$.\n- $D(y_2) = \\max(2+0,\\; 4+0) = 4$.\n\n因此，最大最坏情况检测成本为\n$$D_{\\max} = 15,$$\n在节点 $n_3$ 处达到。",
            "answer": "$$\\boxed{15}$$"
        },
        {
            "introduction": "在识别出难以测试的故障点后，下一步便是生成能够暴露这些故障的特定输入激励（即测试向量）。这个任务由自动测试向量生成（ATPG）算法完成。PODEM（Path-Oriented Decision Making）是一种基础性的ATPG算法，它通过一种基于决策树的系统化搜索方法，有效地寻找测试向量。本练习  将带你逐步完成PODEM算法的核心流程，为一个指定的固定型故障（stuck-at fault）推导出一个有效的测试向量，让你亲身体验ATPG的精髓。",
            "id": "4264494",
            "problem": "考虑在电子设计自动化（EDA）和可测试性设计（DFT）背景下的一个组合逻辑块，其主输入为 $a$、$b$、$c$、$d$、$e$、$f$，以及单个主输出 $o$。内部信号由以下布尔关系定义：\n$$x = \\neg(a \\land b),$$\n$$y = c \\oplus d,$$\n$$z = y \\lor e,$$\n$$m = x \\land z,$$\n$$n = x \\lor f,$$\n$$t = \\neg(n \\oplus m),$$\n主输出为\n$$o = t.$$\n假设采用单固定型故障模型，目标故障为线路 $z$（产生 $z$ 的 $\\lor$ 门的输出）上的固定为 $0$ 故障。使用面向路径的决策（PODEM）方法，为有序输入 $(a,b,c,d,e,f)$ 计算一个完整的测试向量，以在主输出 $o$ 处检测到此故障。你的推导必须从基本定义开始：单固定型故障模型、五值逻辑 $\\{0,1,X,D,D'\\}$（其中 $D$ 表示在无故障电路中值为 $1$，在故障电路中值为 $0$，$D'$ 表示在无故障电路中值为 $0$，在故障电路中值为 $1$），以及门级可控性和可观测性原则（$\\land$、$\\lor$、$\\oplus$ 和 $\\operatorname{XNOR}$ 的控制值和非控制值）。\n\n你必须论证 PODEM 的目标选择、回溯到主输入以及前向蕴涵步骤，并通过证明无故障电路和故障电路中得到的主输出值不同（即 $o_{\\text{good}} \\neq o_{\\text{faulty}}$）来证明其正确性。将最终答案以一个对应于 $(a,b,c,d,e,f)$ 的有序六元组的形式给出。由于答案是二进制向量，因此无需四舍五入或指定单位。你的最终向量必须完全赋值为 $\\{0,1\\}$ 中的值。",
            "solution": "所述问题是有效的。它在科学上基于数字逻辑设计和可测试性的原理，特别是使用了单固定型故障模型和面向路径的决策（PODEM）算法，这些都是电子设计自动化（EDA）领域的标准课题。该问题是适定的，具有完整的电路定义和明确的目标。在领域背景下，所有术语都是标准的且无歧义的。\n\n目标是找到一个测试向量 $(a,b,c,d,e,f)$ 来检测单固定型故障 $z/0$，即线路 z 被永久固定在逻辑值 0。我们将使用 PODEM 算法，该算法系统地对主输入（PIs）进行赋值，以满足故障检测的两个条件：故障激活和故障传播。逻辑值使用五值代数 $\\{0,1,X,D,D'\\}$ 表示，其中 $D$ 表示良好电路值为 $1$ 和故障电路值为 $0$，$X$ 表示未知或未指定的值。\n\n**1. 故障激活**\n\n为了检测线路 z 上的固定为 0 故障，我们必须首先在无故障（良好）电路中将线路 z 驱动为逻辑 1。这是故障激活条件。这在故障点创建了一个复合值 $D$，因为 $z_{\\text{good}}=1$ 且 $z_{\\text{faulty}}=0$。\n\n因此，PODEM 的初始目标是设置 $z=1$。\n产生 $z$ 的门由布尔表达式 $z = y \\lor e$ 定义。要将一个 $\\lor$ 门的输出强制为 $1$，我们必须将其至少一个输入设置为 $1$。PODEM 算法必须选择满足其中一个输入。我们可以选择 $y=1$ 或 $e=1$。一个常见的启发式方法是选择一个更容易满足的目标，这通常意味着选择一个更靠近主输入的输入。由于 $e$ 是一个主输入，设置目标 $(e,1)$ 是一个直接的选择。\n\n**回溯步骤 1：**\n初始目标 $(z,1)$ 通过 $\\lor$ 门回溯到其输入之一来进行转换。我们选择目标 $(e,1)$。由于 $e$ 是一个主输入，回溯阶段完成，我们进行主输入赋值 $e=1$。\n\n**前向蕴涵步骤 1：**\n在赋值 $e=1$ 且所有其他主输入设置为 $X$ 的情况下，我们在电路中前向传播已知值。\n$z$ 的值现在是 $z = y \\lor e = X \\lor 1 = 1$。\n这个赋值满足了故障激活条件。线路 z 上的信号现在是 $D$（在良好电路中值为 $1$，在故障电路中值为 $0$）。\n\n**2. 故障传播**\n\n下一阶段是将由 $D$ 表示的故障效应从故障点 $z$ 传播到主输出 $o$。传播路径经过门 $m$ 和 $t$，即 $z \\rightarrow m \\rightarrow t \\rightarrow o$。\n\n要将故障效应从一个门的输入传播到其输出，该门的所有其他输入必须被设置为它们的非控制值。\n\n**新目标（通过门 $m$ 传播）：**\n门 $m$ 由 $m = x \\land z$ 定义。要将值从输入 $z$ 通过这个 $\\land$ 门传播，另一个输入 $x$ 必须被设置为 $\\land$ 门的非控制值，即 $1$。因此，PODEM 的新目标是 $(x,1)$。\n\n**回溯步骤 2：**\n目标是 $(x,1)$。信号 $x$ 由门 $x = \\neg(a \\land b)$ 产生，这是一个与非门（NAND gate）。要使与非门的输出等于 $1$，其输入不能同时为 $1$；也就是说，$a \\land b$ 必须等于 $0$。这可以通过设置 $a=0$ 或 $b=0$ 来实现。我们选择设置目标 $(a,0)$。由于 $a$ 是一个主输入，回溯完成，得到主输入赋值 $a=0$。\n\n**前向蕴涵步骤 2：**\n当前的主输入赋值是 $a=0$ 和 $e=1$。其他主输入保持为 $X$。我们重新评估电路。\n- $x = \\neg(a \\land b) = \\neg(0 \\land X) = \\neg(0) = 1$。目标 $(x,1)$ 已满足。\n- 现在我们检查 $D$ 的传播。在门 $m$ 处，我们有输入 $x=1$ 和 $z=D$。\n  - $m_{\\text{good}} = x_{\\text{good}} \\land z_{\\text{good}} = 1 \\land 1 = 1$。\n  - $m_{\\text{faulty}} = x_{\\text{faulty}} \\land z_{\\text{faulty}} = 1 \\land 0 = 0$。\n  - 因此，门 $m$ 的输出是 $D$。故障效应已成功传播到线路 $m$。\n\n**新目标（通过门 $t$ 传播）：**\n路径中的下一个门是 $t = \\neg(n \\oplus m)$，这是一个异或非门（XNOR gate）。要将故障效应从输入 $m$ 通过异或门（XOR）或异或非门（XNOR）传播，我们必须通过将另一个输入 $n$ 设置为一个已知值（$0$ 或 $1$）来敏化路径。让我们评估 $n$。\n- $n = x \\lor f$。根据我们之前的赋值，我们有 $x=1$。\n- 因此，$n = 1 \\lor f = 1$，无论 $f$ 的值是多少。根据现有的主输入赋值，n 的值已经确定为 $1$。不需要新的目标。\n\n**最终前向蕴涵：**\n门 $t$ 的输入是 $n=1$ 和 $m=D$。\n- $t_{\\text{good}} = \\neg(n_{\\text{good}} \\oplus m_{\\text{good}}) = \\neg(1 \\oplus 1) = \\neg(0) = 1$。\n- $t_{\\text{faulty}} = \\neg(n_{\\text{faulty}} \\oplus m_{\\text{faulty}}) = \\neg(1 \\oplus 0) = \\neg(1) = 0$。\n- 因此，门 $t$ 的输出是 $D$。\n主输出是 $o=t$。因此，$o = D$。\n\n主输出上的值 $D$（或 $D'$）表示检测到了故障。PODEM 算法已经找到了一组检测故障 $z/0$ 的主输入赋值。所做的赋值是 $a=0$ 和 $e=1$。对于这个测试，其他主输入（$b,c,d,f$）是“无关项”（$X$）。为了提供一个完整的、完全指定的测试向量，我们可以给它们赋任何二进制值。一个常规的选择是将所有未指定的输入设置为 0。\n\n这得出了测试向量 $(a,b,c,d,e,f) = (0,0,0,0,1,0)$。\n\n**3. 测试向量的验证**\n\n我们必须证明向量 $(0,0,0,0,1,0)$ 检测到了故障 $z/0$。\n\n**无故障（良好）电路仿真：**\n- 输入：$a=0, b=0, c=0, d=0, e=1, f=0$。\n- $x = \\neg(a \\land b) = \\neg(0 \\land 0) = \\neg(0) = 1$。\n- $y = c \\oplus d = 0 \\oplus 0 = 0$。\n- $z = y \\lor e = 0 \\lor 1 = 1$。\n- $m = x \\land z = 1 \\land 1 = 1$。\n- $n = x \\lor f = 1 \\lor 0 = 1$。\n- $t = \\neg(n \\oplus m) = \\neg(1 \\oplus 1) = \\neg(0) = 1$。\n- 主输出：$o_{\\text{good}} = t = 1$。\n\n**故障电路仿真（z 固定为 0）：**\n- 输入：$a=0, b=0, c=0, d=0, e=1, f=0$。\n- 故障点之前的节点值与良好电路中相同。\n- $x = 1$。\n- 线路 $z$ 被强制为 $0$，所以 $z_{\\text{faulty}} = 0$。\n- $m = x \\land z = 1 \\land 0 = 0$。\n- $n = x \\lor f = 1 \\lor 0 = 1$。\n- $t = \\neg(n \\oplus m) = \\neg(1 \\oplus 0) = \\neg(1) = 0$。\n- 主输出：$o_{\\text{faulty}} = t = 0$。\n\n**验证结论：**\n由于 $o_{\\text{good}} = 1$ 且 $o_{\\text{faulty}} = 0$，主输出值不同。测试向量 $(0,0,0,0,1,0)$ 成功检测到故障 $z/0$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  0  0  0  1  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "测试向量生成后，必须通过自动测试设备（ATE）高效地施加到芯片上。扫描链设计是实现大规模电路可测试性的核心技术，但它也带来了测试时间和测试数据量的开销。本练习  聚焦于衡量和优化测试应用效率，这是一个在实际生产中至关重要的经济问题。通过计算和比较不同扫描链架构下的测试时间与ATE引脚利用率，你将学会量化分析在测试成本和硬件资源之间的关键权衡。",
            "id": "4264470",
            "problem": "一种同步可测性设计扫描架构被应用于一个大型数字片上系统，以使用自动测试设备（ATE）进行结构化测试。该扫描方法的操作方式是将激励比特移入扫描触发器，施加一个捕获周期，然后将响应比特移出。在重叠扫描输入/扫描输出执行模型下，一旦第一个测试图形加载完成，当前测试图形的卸载将与下一个测试图形的加载同时进行，并假设每个测试图形有一个捕获周期。设扫描触发器的总数为 $N_{\\text{ff}}$，扫描测试图形的数量为 $P$，扫描移位频率为 $f_{\\text{shift}}$，扫描链的数量为 $k$。假设扫描链是完全平衡的，因此最长链的长度为 $L_{k} = N_{\\text{ff}}/k$。\n\n考虑两种配置：\n- 基准单链配置，$k = 1$。\n- 并行多链配置，$k = 10$。\n\n假设 $N_{\\text{ff}} = 1{,}000{,}000$，$P = 5{,}000$，$f_{\\text{shift}} = 50 \\times 10^{6}$，并且每个测试图形有一个捕获周期。ATE 有 $C = 1{,}024$ 个可用通道。该器件需要 $p_{\\text{func}} = 300$ 个功能性 I/O 通道和 $p_{\\text{ctrl}} = 4$ 个测试控制通道（用于扫描使能、测试时钟、模式和复位等项目）。每条扫描链消耗一个扫描输入和一个扫描输出 ATE 通道。将配置 $k$ 的 ATE 引脚利用率定义为在该配置中器件所使用的 ATE 通道占总通道的比例 $U_{k}$。\n\n设 $T_{k}$ 为在配置 $k$ 中使用重叠执行模型施加所有 $P$ 个测试图形所需的总 ATE 时间，并设 $U_{k}$ 为相应的 ATE 引脚利用率。定义效率指数\n$$\\Phi = \\frac{T_{1}/T_{10}}{U_{10}/U_{1}}.$$\n该指数用于量化当配置从 $k=1$ 变为 $k=10$ 时，每单位 ATE 引脚利用率增加所带来的测试时间缩减。\n\n根据给定参数计算 $\\Phi$。将最终答案表示为一个无单位的纯数，并四舍五入到四位有效数字。",
            "solution": "该问题要求计算效率指数 $\\Phi$，该指数关联了从单扫描链配置（$k=1$）变为并行多扫描链配置（$k=10$）时，测试时间的缩减与 ATE 引脚利用率的增加之间的关系。效率指数定义为：\n$$ \\Phi = \\frac{T_{1}/T_{10}}{U_{10}/U_{1}} $$\n其中 $T_k$ 是具有 $k$ 条扫描链的配置的总测试时间，$U_k$ 是 ATE 引脚利用率。\n\n首先，我们必须推导出总 ATE 测试时间 $T_k$ 的表达式。\n测试施加过程遵循重叠扫描输入/扫描输出模型，每个测试图形有一个捕获周期。设 $L_k$ 为最长扫描链的长度，$P$ 为测试图形的数量，$f_{\\text{shift}}$ 为扫描移位频率。\n\n施加 $P$ 个测试图形的操作序列如下：\n1.  **初始加载**：将第一个测试图形的激励移入扫描链。这需要 $L_k$ 个移位周期。\n2.  **首次捕获**：施加一个捕获周期。此时，已经过了 $L_k + 1$ 个周期。\n3.  **重叠执行**：对于其后的每个测试图形 $i$（从 $i=2$ 到 $P$），测试图形 $i$ 的激励移入与测试图形 $i-1$ 的响应移出同时进行。这需要 $L_k$ 个周期，然后是测试图形 $i$ 的一个捕获周期。这个 $(L_k+1)$ 周期的块对测试图形 $2, 3, \\dots, P$ 重复。\n4.  **最终卸载**：在第 P 个测试图形的捕获周期之后，其响应驻留在扫描触发器中。这个响应必须被移出。这个最终卸载操作需要 $L_k$ 个周期。\n\n让我们计算总周期数 $N_{\\text{cycles},k}$：\n完成第一个测试图形捕获的时间是 $L_k+1$ 个周期。其后的 $P-1$ 个测试图形中的每一个都额外增加 $L_k+1$ 个周期。因此，最后一个测试图形 $P$ 的捕获在总共经过 $P \\times (L_k+1)$ 个周期时完成。在这次最终捕获之后，测试图形 $P$ 的响应必须完全从扫描链中移出，这需要额外的 $L_k$ 个周期。\n因此，施加所有 $P$ 个测试图形所需的总周期数为：\n$$ N_{\\text{cycles},k} = P(L_k + 1) + L_k = PL_k + P + L_k = (P+1)L_k + P $$\n问题陈述扫描链是完全平衡的，所以 $L_k = N_{\\text{ff}}/k$。将此代入周期数表达式：\n$$ N_{\\text{cycles},k} = (P+1)\\frac{N_{\\text{ff}}}{k} + P $$\n总测试时间 $T_k$ 是总周期数除以移位频率 $f_{\\text{shift}}$：\n$$ T_k = \\frac{N_{\\text{cycles},k}}{f_{\\text{shift}}} = \\frac{(P+1)\\frac{N_{\\text{ff}}}{k} + P}{f_{\\text{shift}}} $$\n\n接下来，我们推导 ATE 引脚利用率 $U_k$ 的表达式。\n器件使用的 ATE 通道总数是功能性 I/O 通道（$p_{\\text{func}}$）、测试控制通道（$p_{\\text{ctrl}}$）和扫描链通道的总和。$k$ 条扫描链中的每一条都需要一个扫描输入和一个扫描输出通道，因此扫描链消耗 $2k$ 个通道。\n配置 $k$ 中使用的引脚总数为：\n$$ p_{\\text{total},k} = p_{\\text{func}} + p_{\\text{ctrl}} + 2k $$\n引脚利用率 $U_k$ 是所使用的 ATE 通道数占总可用通道数（$C$）的比例：\n$$ U_k = \\frac{p_{\\text{total},k}}{C} = \\frac{p_{\\text{func}} + p_{\\text{ctrl}} + 2k}{C} $$\n\n现在，我们可以计算 $\\Phi$ 所需的比率。\n测试时间的比率为：\n$$ \\frac{T_1}{T_{10}} = \\frac{\\frac{(P+1)\\frac{N_{\\text{ff}}}{1} + P}{f_{\\text{shift}}}}{\\frac{(P+1)\\frac{N_{\\text{ff}}}{10} + P}{f_{\\text{shift}}}} = \\frac{(P+1)N_{\\text{ff}} + P}{(P+1)\\frac{N_{\\text{ff}}}{10} + P} $$\n引脚利用率的比率为：\n$$ \\frac{U_{10}}{U_1} = \\frac{\\frac{p_{\\text{func}} + p_{\\text{ctrl}} + 2(10)}{C}}{\\frac{p_{\\text{func}} + p_{\\text{ctrl}} + 2(1)}{C}} = \\frac{p_{\\text{func}} + p_{\\text{ctrl}} + 20}{p_{\\text{func}} + p_{\\text{ctrl}} + 2} $$\n\n现在我们代入给定的数值：\n$N_{\\text{ff}} = 1{,}000{,}000 = 10^6$\n$P = 5{,}000$\n$p_{\\text{func}} = 300$\n$p_{\\text{ctrl}} = 4$\n$C = 1{,}024$\n\n首先，计算测试时间比率：\n$P+1 = 5001$。\n$$ \\frac{T_1}{T_{10}} = \\frac{(5001)(10^6) + 5000}{(5001)\\frac{10^6}{10} + 5000} = \\frac{5001000000 + 5000}{500100000 + 5000} = \\frac{5001005000}{500105000} \\approx 9.99991001 $$\n\n接下来，计算引脚利用率比率：\n$$ \\frac{U_{10}}{U_1} = \\frac{300 + 4 + 20}{300 + 4 + 2} = \\frac{324}{306} $$\n这个分数可以被化简。分子分母都可以被 $18$ 整除：\n$$ \\frac{324}{18} = 18 \\quad \\text{和} \\quad \\frac{306}{18} = 17 $$\n所以，\n$$ \\frac{U_{10}}{U_1} = \\frac{18}{17} \\approx 1.05882353 $$\n\n最后，我们计算效率指数 $\\Phi$：\n$$ \\Phi = \\frac{T_{1}/T_{10}}{U_{10}/U_{1}} = \\frac{5001005000/500105000}{18/17} = \\frac{9.99991001...}{1.05882353...} \\approx 9.44436589 $$\n将结果四舍五入到四位有效数字，得到 $9.444$。",
            "answer": "$$\\boxed{9.444}$$"
        }
    ]
}