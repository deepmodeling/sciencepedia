{
    "hands_on_practices": [
        {
            "introduction": "Mastery of the Joint Test Action Group (JTAG) infrastructure begins with understanding how to navigate its core engine, the Test Access Port (TAP) controller. This state machine is manipulated using the Test Mode Select ($TMS$) signal on each rising edge of the Test Clock ($TCK$). This first practice provides a focused exercise in designing a minimal $TMS$ sequence to guide the TAP controller through a common path, building a foundational understanding of state transitions. ",
            "id": "4258516",
            "problem": "In the Institute of Electrical and Electronics Engineers (IEEE) Standard 1149.1 Boundary-Scan architecture, commonly known as Joint Test Action Group (JTAG), the Test Access Port (TAP) controller is a finite state machine whose next state is determined by sampling the Test Mode Select ($TMS$) signal on the rising edge of the Test Clock ($TCK$). Consider the Data Register (DR) scan path with the following canonical next-state rules (expressed for the states relevant to this problem). On each rising edge of $TCK$, the TAP controller transitions according to the current state and the sampled value of $TMS$:\n\n- From `Run-Test/Idle` ($RTI$): $TMS=0 \\rightarrow RTI$, $TMS=1 \\rightarrow Select-DR-Scan$.\n- From `Select-DR-Scan`: $TMS=0 \\rightarrow Capture-DR$, $TMS=1 \\rightarrow Select-IR-Scan$.\n- From `Capture-DR`: $TMS=0 \\rightarrow Shift-DR$, $TMS=1 \\rightarrow Exit1-DR$.\n- From `Shift-DR`: $TMS=0 \\rightarrow Shift-DR$, $TMS=1 \\rightarrow Exit1-DR$.\n- From `Exit1-DR`: $TMS=0 \\rightarrow Pause-DR$, $TMS=1 \\rightarrow Update-DR$.\n- From `Update-DR`: $TMS=0 \\rightarrow RTI$, $TMS=1 \\rightarrow Select-DR-Scan$.\n\nAssume the TAP controller starts in $RTI$. You are to design a deterministic $TMS$ waveform, consisting of a sequence of $TMS$ values applied and sampled on consecutive rising edges of $TCK$, that moves the TAP controller from $RTI$ to `Shift-DR`, then to `Update-DR`, and finally back to $RTI$. Your design must minimize the number of $TCK$ pulses required to accomplish this sequence of state visits. Assume no data shifting is required beyond visiting `Shift-DR` (i.e., exit `Shift-DR` immediately upon entry without performing any shifts).\n\nUsing only the fundamental rules above and first principles of finite-state control, determine the minimal number of $TCK$ pulses required to complete the sequence $RTI \\rightarrow Shift-DR \\rightarrow Update-DR \\rightarrow RTI$. Provide your final answer as a single integer. No rounding is needed, and no units are required.",
            "solution": "The Test Access Port (TAP) controller is a finite state machine driven by the Test Mode Select ($TMS$) signal sampled at the rising edge of the Test Clock ($TCK$). The next-state behavior is fully determined from the current state and the value of $TMS$ on the rising edge of $TCK$. We use the canonical Data Register (DR) path transitions listed in the problem statement, which are standard facts from IEEE Standard 1149.1 and serve as the foundational base.\n\nWe must visit the states in the order `Run-Test/Idle` ($RTI$) to `Shift-DR`, then to `Update-DR`, and finally back to $RTI$, while minimizing the number of $TCK$ pulses. Each transition occurs only on a rising edge of $TCK$, so minimizing transitions equates to minimizing the number of sampled $TMS$ events.\n\nStep 1: Move from $RTI$ to `Shift-DR`.\n- From $RTI$, the only way to enter the Data Register (DR) path is via `Select-DR-Scan`, which requires $TMS=1$ on the next $TCK$ rising edge:\n  - $RTI \\xrightarrow{TMS=1} Select-DR-Scan$.\n- From `Select-DR-Scan`, to go into DR capture, we must set $TMS=0$:\n  - $Select-DR-Scan \\xrightarrow{TMS=0} Capture-DR$.\n- From `Capture-DR`, to enter `Shift-DR`, we must set $TMS=0$ again:\n  - $Capture-DR \\xrightarrow{TMS=0} Shift-DR$.\n\nThus, the minimal sequence to reach `Shift-DR` from $RTI$ is three $TCK$ pulses with $TMS$ values $1, 0, 0$ on consecutive rising edges. At this point, we have used $3$ pulses.\n\nStep 2: Move from `Shift-DR` to `Update-DR` with no data shifting.\n- While in `Shift-DR`, remaining in `Shift-DR` requires $TMS=0$; exiting requires $TMS=1$. To minimize pulses and avoid data shifting, we exit immediately:\n  - `Shift-DR \\xrightarrow{TMS=1} Exit1-DR$.\n- From `Exit1-DR`, to go to `Update-DR` directly, we set $TMS=1$:\n  - `Exit1-DR \\xrightarrow{TMS=1} Update-DR$.\n\nThis takes $2$ additional pulses with $TMS$ values $1, 1$. The cumulative count is now $3 + 2 = 5$ pulses.\n\nStep 3: Move from `Update-DR` back to $RTI$.\n- From `Update-DR`, returning to $RTI$ requires $TMS=0$:\n  - `Update-DR \\xrightarrow{TMS=0} RTI$.\n\nThis requires $1$ more pulse. The total number of pulses is $5 + 1 = 6$.\n\nTherefore, the minimal number of $TCK$ pulses to accomplish the sequence $RTI \\rightarrow Shift-DR \\rightarrow Update-DR \\rightarrow RTI$ is $6$. A deterministic minimal $TMS$ waveform sampled on consecutive rising edges of $TCK$ that achieves this is the sequence $1, 0, 0, 1, 1, 0$.\n\nTo establish minimality, observe:\n- Entering the DR path from $RTI$ necessarily requires passing through `Select-DR-Scan` and `Capture-DR` to reach `Shift-DR`, which is at least $3$ transitions because $RTI \\rightarrow Select-DR-Scan$ requires $TMS=1$, then `Select-DR-Scan` $\\rightarrow$ `Capture-DR` requires $TMS=0$, and `Capture-DR` $\\rightarrow$ `Shift-DR` requires $TMS=0$.\n- From `Shift-DR`, there is no direct transition to `Update-DR`; the shortest path is `Shift-DR` $\\rightarrow$ `Exit1-DR` $\\rightarrow$ `Update-DR`, which requires exactly $2$ transitions ($TMS=1$ twice).\n- From `Update-DR`, returning to $RTI$ in the fewest steps is a single transition with $TMS=0$.\n\nNo alternative path can reduce any of these counts without violating the TAP transition rules; any detour (e.g., entering `Pause-DR` or `Select-IR-Scan`) would strictly increase the number of transitions. Hence, $6$ is minimal.",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "Building upon the fundamentals of state machine navigation, we can analyze the timing of complete JTAG operations, a critical skill for estimating test application time and ensuring correct protocol execution. This practice requires you to calculate the precise number of Test Clock ($TCK$) cycles for a composite operation—loading an instruction and then scanning a data register—by tracing the minimal path through the TAP state machine. This exercise connects the abstract state diagram to concrete performance metrics. ",
            "id": "4258496",
            "problem": "A digital integrated circuit implements the boundary-scan architecture defined by the Institute of Electrical and Electronics Engineers (IEEE) Standard $1149.1$, with a standard Test Access Port (TAP) controller. You are to determine the exact number of Test Clock (TCK) rising edges required to perform the following composite operation under minimal-overhead control of the Test Mode Select (TMS) signal.\n\nAssume the following operational constraints and definitions:\n- The circuit starts in the TAP state Run-Test/Idle and must finish in Run-Test/Idle after the entire composite operation is complete.\n- First, an $m$-bit Instruction Register (IR) load is performed. Then, immediately afterward, a specific $n$-bit Data Register (DR) is shifted out through Test Data Out (TDO).\n- All state transitions follow the IEEE Standard $1149.1$ TAP state machine. The path taken through the states must be minimal and legal, with no pausing and no extra idling beyond what is strictly necessary to enter and exit the required shift operations and to return to Run-Test/Idle upon completion.\n- Each rising edge of the Test Clock (TCK) advances the TAP state machine according to the current TMS value and performs one shift of the currently selected shift register in the Shift-IR or Shift-DR states.\n- During the $m$-bit and $n$-bit shifts, exactly one bit is shifted per rising edge of $TCK$. The final bit of each shift operation is clocked while asserting TMS to exit the corresponding shift state on that same edge.\n- No asynchronous resets are applied. No transitions to Test-Logic-Reset are invoked. No pauses are inserted.\n\nUnder these assumptions, derive a closed-form analytic expression, as a function of $m$ and $n$, for the total number of $TCK$ rising edges required to:\n$1)$ load the $m$-bit IR, and $2)$ shift out the $n$-bit DR, starting in Run-Test/Idle and ending in Run-Test/Idle, using the minimal legal sequence of TAP state transitions. Your final answer must be a single analytic expression in terms of $m$ and $n$ with no units. Do not approximate or round.",
            "solution": "To determine the total number of TCK rising edges, we must sum the cycles for each phase of the composite operation by tracing the minimal legal path through the 16-state TAP state machine. The operation starts and ends in `Run-Test/Idle`.\n\n1.  **Phase 1: Load the Instruction Register (IR)**\n    *   **Navigate to `Shift-IR`**: Starting from `Run-Test/Idle`, the minimal path is:\n        *   `Run-Test/Idle` $\\xrightarrow{\\text{TMS=1}}$ `Select-DR-Scan` (1 TCK)\n        *   `Select-DR-Scan` $\\xrightarrow{\\text{TMS=1}}$ `Select-IR-Scan` (1 TCK)\n        *   `Select-IR-Scan` $\\xrightarrow{\\text{TMS=0}}$ `Capture-IR` (1 TCK)\n        *   `Capture-IR` $\\xrightarrow{\\text{TMS=0}}$ `Shift-IR` (1 TCK)\n        This navigation takes **4 TCK cycles**.\n    *   **Shift `m` bits**:\n        *   Shifting the first $m-1$ bits requires holding TMS=0, taking $m-1$ TCK cycles.\n        *   Shifting the final $m$-th bit requires TMS=1 to exit the shift state, taking 1 TCK cycle.\n        This shift operation takes a total of **`m` TCK cycles**.\n    *   At the end of this phase, the TAP controller is in the `Exit1-IR` state.\n\n2.  **Phase 2: Transition from IR path to DR path**\n    *   **Navigate from `Exit1-IR` to `Shift-DR`**: After the IR is loaded, we must navigate to the `Shift-DR` state to begin the data scan. The minimal path is:\n        *   `Exit1-IR` $\\xrightarrow{\\text{TMS=1}}$ `Update-IR` (1 TCK)\n        *   `Update-IR` $\\xrightarrow{\\text{TMS=1}}$ `Select-DR-Scan` (1 TCK)\n        *   `Select-DR-Scan` $\\xrightarrow{\\text{TMS=0}}$ `Capture-DR` (1 TCK)\n        *   `Capture-DR` $\\xrightarrow{\\text{TMS=0}}$ `Shift-DR` (1 TCK)\n        This transition takes **4 TCK cycles**.\n\n3.  **Phase 3: Scan the Data Register (DR)**\n    *   **Shift `n` bits**: Similar to the IR shift, this takes:\n        *   $n-1$ TCK cycles for the first $n-1$ bits (TMS=0).\n        *   1 TCK cycle for the final bit (TMS=1).\n        This shift operation takes a total of **`n` TCK cycles**.\n    *   At the end of this phase, the TAP controller is in the `Exit1-DR` state.\n\n4.  **Phase 4: Return to `Run-Test/Idle`**\n    *   **Navigate from `Exit1-DR`**: The minimal path back to the starting state is:\n        *   `Exit1-DR` $\\xrightarrow{\\text{TMS=1}}$ `Update-DR` (1 TCK)\n        *   `Update-DR` $\\xrightarrow{\\text{TMS=0}}$ `Run-Test/Idle` (1 TCK)\n        This return path takes **2 TCK cycles**.\n\n**Total Cycle Count:**\nSumming the cycles from all four phases gives the total number of TCK rising edges:\nTotal TCKs = (Navigate to `Shift-IR`) + (IR Shift) + (Transition to `Shift-DR`) + (DR Shift) + (Return to `Run-Test/Idle`)\nTotal TCKs = $4 + m + 4 + n + 2 = m + n + 10$.",
            "answer": "$$\n\\boxed{m+n+10}\n$$"
        },
        {
            "introduction": "Beyond mechanics and timing, the practical application of JTAG involves strategic thinking to ensure system safety, particularly when interfacing with a live board. A primary concern is preventing bus contention, where multiple drivers attempt to control the same net, potentially causing hardware damage. This final practice challenges you to apply your knowledge of JTAG instructions like `SAMPLE/PRELOAD` and `EXTEST` to devise a robust sequence for safely entering an internal test mode without creating electrical conflicts. ",
            "id": "4258533",
            "problem": "A system-on-chip integrates multiple bus masters and shared peripheral interfaces. During normal operation, on-chip pads may drive a shared bus. You are asked to enter the Joint Test Action Group (JTAG) Internal Test (INTEST) mode to perform core-isolated testing without causing bus contention on off-chip nets. Consider an Institute of Electrical and Electronics Engineers (IEEE) $1149.1$ compliant boundary-scan architecture with a Boundary Scan Register (BSR) composed of output data cells and output control cells that drive the Output Enable (OE) of pad drivers. Assume the following foundational facts:\n\n- In $1149.1$, the BSR consists of shift, capture, and update elements, where Update-DR latches drive values to their effect points only when the BSR is selected by the current instruction.\n- The Joint Test Action Group (JTAG) Test Access Port (TAP) state machine only modifies the contents of the shift path on entering Capture-DR; latching into effect points occurs at Update-DR.\n- The `SAMPLE/PRELOAD` instruction selects the BSR for shifting and capture but does not drive pins; the system logic continues to control pad drivers.\n- The `EXTEST` instruction selects the BSR to drive pins; output control cells set pad driver OE, and output data cells set pad driver data; tri-stating requires $OE=0$ in the corresponding control cells.\n- The `INTEST` instruction selects the BSR to drive core inputs and capture core outputs; safe entry requires pad drivers to be disabled to avoid contention with external drivers.\n- The `HIGHZ` instruction, if implemented, forces outputs to a high-impedance state but typically selects the `BYPASS` register and does not allow BSR access for readback.\n- The `CLAMP` instruction, if implemented, applies the preloaded BSR update values to pads while selecting the `BYPASS` register; it maintains pad states without permitting BSR scanning.\n\nYour goal is to construct an instruction-and-state sequence that guarantees the following before selecting `INTEST`: pad drivers are disabled by forcing all relevant output control cells to $OE=0$, and the disabled OE states are confirmed via BSR readback. The sequence must be free of transient contention hazards introduced by instruction changes or TAP transitions and must use only the semantics above. Choose the option that most rigorously satisfies these constraints when starting in Run-Test/Idle (RTI) under normal operation.\n\nWhich sequence is correct?\n\nA. From RTI, load `SAMPLE/PRELOAD` via Shift-IR and Update-IR; Shift-DR to preload all output control bits to $OE=0$, Update-DR; load `EXTEST` via Shift-IR and Update-IR so the BSR controls pad OE; perform Capture-DR and Shift-DR to read back control cell states and verify $OE=0$; then load `INTEST` via Shift-IR and Update-IR to enter core-isolated test with pads remaining disabled.\n\nB. From RTI, load `INTEST` via Shift-IR and Update-IR immediately; then Shift-DR to preload output control bits to $OE=0$; finally Update-DR to apply the tri-state while already in `INTEST`.\n\nC. From RTI, load `HIGHZ` via Shift-IR and Update-IR to force all outputs high-impedance; then load `INTEST` via Shift-IR and Update-IR; assume pads stay disabled during `INTEST` without any BSR readback.\n\nD. From RTI, load `SAMPLE/PRELOAD` via Shift-IR and Update-IR; Shift-DR to preload all output control bits to $OE=0$; perform Capture-DR and Shift-DR to read back the BSR and verify $OE=0$; then Update-DR; finally load `INTEST` via Shift-IR and Update-IR.\n\nE. From RTI, load `SAMPLE/PRELOAD` via Shift-IR and Update-IR; Shift-DR to preload $OE=0$ and Update-DR; load `CLAMP` via Shift-IR and Update-IR to apply the preloaded tri-state; then attempt to confirm $OE=0$ by performing Capture-DR and Shift-DR while remaining in `CLAMP`; finally load `INTEST` via Shift-IR and Update-IR.",
            "solution": "### Problem Validation\n\n**Step 1: Extract Givens**\n\nThe problem statement provides the following definitions, constraints, and objectives:\n- **System**: A system-on-chip with multiple bus masters and shared peripheral interfaces.\n- **Goal**: Enter the Joint Test Action Group (JTAG) Internal Test (`INTEST`) mode for core-isolated testing.\n- **Primary Constraint**: Avoid bus contention on off-chip nets.\n- **Architecture**: Conforms to IEEE $1149.1$ standard for boundary-scan.\n- **Boundary Scan Register (`BSR`)**: Composed of output data cells and output control cells that drive the Output Enable ($OE$) of pad drivers.\n- **Fact 1**: The `BSR` has shift, capture, and update elements. Update-DR latches drive values only when the `BSR` is selected by the current instruction.\n- **Fact 2**: The Test Access Port (`TAP`) state machine modifies the shift path on entering Capture-DR; latching into effect points occurs at Update-DR.\n- **Fact 3 (`SAMPLE/PRELOAD` instruction)**: Selects the `BSR` for shifting and capture but does not drive pins. System logic continues to control pad drivers.\n- **Fact 4 (`EXTEST` instruction)**: Selects the `BSR` to drive pins. Control cells set pad driver $OE$; data cells set pad driver data. Tri-stating requires $OE=0$ in the control cells.\n- **Fact 5 (`INTEST` instruction)**: Selects the `BSR` to drive core inputs and capture core outputs. Safe entry requires pad drivers to be disabled.\n- **Fact 6 (`HIGHZ` instruction)**: If implemented, forces outputs to a high-impedance state, but typically selects the `BYPASS` register and disallows `BSR` access for readback.\n- **Fact 7 (`CLAMP` instruction)**: If implemented, applies preloaded `BSR` update values to pads while selecting the `BYPASS` register; it disallows `BSR` scanning.\n- **Required Sequence Properties**:\n    1.  Guarantees pad drivers are disabled by forcing all relevant output control cells to $OE=0$.\n    2.  Confirms the disabled $OE$ states via `BSR` readback.\n    3.  This must be achieved *before* selecting the `INTEST` instruction.\n    4.  The sequence must be free of transient contention hazards.\n    5.  The starting state is Run-Test/Idle ($RTI$).\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem statement is evaluated against the validation criteria:\n- **Scientifically Grounded**: The problem is based entirely on the IEEE $1149.1$ standard, which governs JTAG boundary-scan architecture and operation. The described behaviors of instructions (`SAMPLE/PRELOAD`, `EXTEST`, `INTEST`, etc.) and `TAP` controller states are consistent with this well-established engineering standard. The issue of preventing bus contention during test mode entry is a fundamental and practical concern in digital circuit design and test.\n- **Well-Posed**: The problem is clearly defined. It specifies a starting state ($RTI$), a goal (safely enter `INTEST`), a set of allowed operations (the described JTAG instructions), and a set of explicit constraints (no contention, must verify pad state via readback). This structure allows for the deduction of a unique, correct sequence of operations.\n- **Objective**: The problem is stated in precise, technical language. The descriptions of the instructions are provided as \"foundational facts,\" removing ambiguity and subjectivity.\n\nThe problem does not exhibit any invalidating flaws. It is not scientifically unsound, non-formalizable, incomplete, unrealistic, or ill-posed. It is a substantive question requiring logical deduction from a given set of formal rules.\n\n**Step 3: Verdict and Action**\n\nThe problem statement is **valid**. Proceeding to the solution.\n\n### Derivation from First Principles\n\nThe objective is to devise a sequence of IEEE $1149.1$ operations to transition from normal operation (represented by the `TAP` state Run-Test/Idle, or $RTI$) into the `INTEST` mode, while guaranteeing that I/O-pad-related bus contention is avoided. This guarantee requires two key actions: first, forcing the pad output drivers into a high-impedance (tri-state) condition, and second, verifying that this state has been successfully established before entering `INTEST`. The tri-state condition is achieved by setting the value of the output enable control bit for each relevant pin to $0$ (i.e., $OE=0$).\n\nLet us construct the required sequence step-by-step based on the provided instruction semantics.\n\n1.  **Isolate the BSR for Safe Preloading**: We start in $RTI$ where the system logic controls the pads. To load a new state into the `BSR` without simultaneously causing it to drive the pads, we must use an instruction that decouples the `BSR` update latches from the pad drivers. The given Fact 3 for the `SAMPLE/PRELOAD` instruction states it \"selects the `BSR` for shifting and capture but does not drive pins.\" This is the correct tool for this step. Therefore, the first action is to load the `SAMPLE/PRELOAD` instruction into the instruction register ($IR$).\n\n2.  **Load the Safe State**: With `SAMPLE/PRELOAD` active, we can now safely manipulate the contents of the `BSR`. The goal is to program all output enable control cells to their disable value ($OE=0$). This is done by traversing the `TAP` state machine to the Shift-DR state and shifting the desired bit pattern into the `BSR`. After the pattern is shifted in, we must transition to the Update-DR state. This action latches the contents of the `BSR` shift path into the `BSR`'s update latches. Critically, because `SAMPLE/PRELOAD` is active, these newly updated values are *not* driven to the pads. The pads remain under the control of the system logic. We have successfully preloaded a \"safe\" pattern.\n\n3.  **Apply the Safe State and Enable Verification**: The preloaded safe state must now be applied to the pads. This requires an instruction that connects the `BSR` update latches to the pad drivers. Fact 4 states that the `EXTEST` instruction \"selects the `BSR` to drive pins.\" By loading the `EXTEST` instruction, the preloaded $OE=0$ values will be applied to the output enable logic of the pads, forcing them into a high-impedance state. This transition is safe because the state of the update latches is determinate and set to a safe value *before* the instruction that applies them becomes active. Once `EXTEST` is the active instruction, the `BSR` is the selected data register, and it is in control of the pads.\n\n4.  **Confirm the Safe State**: The problem explicitly requires confirmation of the $OE=0$ state via `BSR` readback. Now that `EXTEST` is active, the `BSR` is the current data register. We can perform a capture-and-shift operation. By transitioning through Capture-DR, the current state of the boundary scan cells is loaded into their shift-register elements. For an output control cell, a compliant and logical implementation will capture the value of its own update latch, which is currently driving the pad's $OE$ logic. Subsequently, transitioning to Shift-DR allows this captured value to be shifted out for external verification. If the shifted-out bits corresponding to the control cells are all $0$, we have positively confirmed that the `BSR` is commanding all outputs to a high-impedance state.\n\n5.  **Enter the Final Test Mode**: Having confirmed that the pads are safely disabled, we can now transition to the target mode, `INTEST`. This is done by loading the `INTEST` instruction. According to the IEEE $1149.1$ standard, the behavior of the output pins during `INTEST` is specified to be the same as their behavior during `EXTEST`. Since the content of the `BSR` update latches is not altered by an instruction change alone, the pads will remain in the safe, high-impedance state that was established and verified in the previous steps.\n\nThis sequence—preload with `SAMPLE/PRELOAD`, apply and verify with `EXTEST`, then switch to `INTEST`—is a standard, robust, and logically sound procedure that satisfies all the problem's requirements.\n\n### Option-by-Option Analysis\n\n**A. From RTI, load `SAMPLE/PRELOAD` via Shift-IR and Update-IR; Shift-DR to preload all output control bits to $OE=0$, Update-DR; load `EXTEST` via Shift-IR and Update-IR so the BSR controls pad OE; perform Capture-DR and Shift-DR to read back control cell states and verify $OE=0$; then load `INTEST` via Shift-IR and Update-IR to enter core-isolated test with pads remaining disabled.**\n\nThis option perfectly matches the sequence derived from first principles.\n1.  It correctly uses `SAMPLE/PRELOAD` and an Update-DR to safely preload the $OE=0$ state into the BSR update latches.\n2.  It correctly uses `EXTEST` to apply this preloaded safe state to the pads, preventing contention.\n3.  It correctly identifies that while in `EXTEST`, a Capture-DR/Shift-DR sequence can be used to read back the state of the control cells for verification.\n4.  It correctly transitions to `INTEST` only after the safe pad state has been established and verified.\nThe sequence is free of hazards and meets all specified constraints.\n\n**Verdict: Correct**\n\n**B. From RTI, load `INTEST` via Shift-IR and Update-IR immediately; then Shift-DR to preload output control bits to $OE=0$; finally Update-DR to apply the tri-state while already in `INTEST`.**\n\nThis sequence is hazardous. Loading `INTEST` immediately connects the `BSR` to the core and pads. However, the initial contents of the `BSR` update latches are undefined. If these latches contain values that enable the output drivers ($OE=1$), and the system logic is also driving the bus, immediate bus contention will occur at the moment the `INTEST` instruction becomes active in the Update-IR state. Attempting to fix the contention *after* entering `INTEST` is too late; the hazard has already been realized. This violates the core requirement to avoid contention.\n\n**Verdict: Incorrect**\n\n**C. From RTI, load `HIGHZ` via Shift-IR and Update-IR to force all outputs high-impedance; then load `INTEST` via Shift-IR and Update-IR; assume pads stay disabled during `INTEST` without any BSR readback.**\n\nThis option has two critical flaws.\n1.  Fact 6 states that `HIGHZ` \"does not allow `BSR` access for readback.\" This directly violates the problem requirement to \"confirm via `BSR` readback.\"\n2.  Fact 6 also states that `HIGHZ` \"typically selects the `BYPASS` register.\" When the instruction is changed from `HIGHZ` to `INTEST`, the selected data register changes from `BYPASS` to `BSR`. The global tri-stating effect of `HIGHZ` is removed, and control reverts to the `BSR` update latches. As in option B, the contents of these latches are unknown, creating a potential for bus contention.\n\n**Verdict: Incorrect**\n\n**D. From RTI, load `SAMPLE/PRELOAD` via Shift-IR and Update-IR; Shift-DR to preload all output control bits to $OE=0$; perform Capture-DR and Shift-DR to read back the BSR and verify $OE=0$; then Update-DR; finally load `INTEST` via Shift-IR and Update-IR.**\n\nThis sequence is logically flawed. After shifting in the $OE=0$ pattern, it attempts to verify it *before* the Update-DR state. A Capture-DR operation overwrites the contents of the shift-register path with newly captured data. With `SAMPLE/PRELOAD` active, the captured data comes from the system-logic-to-pad interfaces. Therefore, the $OE=0$ pattern that was just shifted in is immediately destroyed and replaced by the current state of the system logic. The subsequent Shift-DR would read out the system's state, not the intended state, failing the verification goal. The sequence of operations is incorrect for verifying the preloaded data.\n\n**Verdict: Incorrect**\n\n**E. From RTI, load `SAMPLE/PRELOAD` via Shift-IR and Update-IR; Shift-DR to preload $OE=0$ and Update-DR; load `CLAMP` via Shift-IR and Update-IR to apply the preloaded tri-state; then attempt to confirm $OE=0$ by performing Capture-DR and Shift-DR while remaining in `CLAMP`; finally load `INTEST` via Shift-IR and Update-IR.**\n\nThis sequence fails for a reason similar to option C. While using `CLAMP` to apply the preloaded value is a valid step, the verification step is impossible. Fact 7 states that the `CLAMP` instruction \"selects the `BYPASS` register\" and does not permit \"`BSR` scanning\". With the `BYPASS` register selected, any attempt to perform a Capture-DR/Shift-DR operation will act on the single-bit `BYPASS` register, not the `BSR`. It is therefore impossible to \"confirm $OE=0$ by performing Capture-DR and Shift-DR\" on the `BSR` while the `CLAMP` instruction is active. This violates the explicit readback requirement.\n\n**Verdict: Incorrect**",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}