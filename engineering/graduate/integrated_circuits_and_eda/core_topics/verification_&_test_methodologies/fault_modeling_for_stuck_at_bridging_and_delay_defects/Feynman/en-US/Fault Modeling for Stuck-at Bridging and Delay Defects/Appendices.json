{
    "hands_on_practices": [
        {
            "introduction": "The foundation of digital circuit testing lies in understanding the single stuck-at fault model. This first exercise guides you through the essential process of enumerating all potential stuck-at faults in a simple combinational circuit. By systematically analyzing each fault from first principles, you will determine which, if any, are logically redundantâ€”meaning they cannot be detected by any input pattern . This practice reinforces the core concepts of fault activation and propagation.",
            "id": "4270967",
            "problem": "A fanout-free combinational network consists of a two-input NAND gate feeding a two-input NOR gate. Let the primary inputs be $A$, $B$, and $C$. The NAND computes $X = \\operatorname{NAND}(A,B)$, and the NOR computes the primary output $Y = \\operatorname{NOR}(X,C)$. Assume the single stuck-at fault model in which a single line (net) is permanently forced to either $0$ or $1$. Work at the line level (i.e., faults are on nets, not within transistor-level details), and assume standard Boolean semantics and the absence of hazards. There is no reconvergent fanout in the network.\n\nStarting strictly from core definitions of Boolean logic and the single stuck-at fault model (no pre-derived shortcuts), do the following:\n\n1. Construct the complete set $\\mathcal{F}$ of all single stuck-at faults on the nets of this network. Treat each distinct net ($A$, $B$, $C$, $X$, $Y$) as a candidate fault site, and include both stuck-at-$0$ and stuck-at-$1$ for each site.\n2. Using Boolean equivalences and the activation/propagation conditions for stuck-at faults, analyze the detectability of each fault in $\\mathcal{F}$ at the primary output $Y$. A fault is redundant if, for all assignments $(A,B,C) \\in \\{0,1\\}^{3}$, the faulty output $Y_{\\text{faulty}}$ equals the good output $Y_{\\text{good}}$, meaning the fault cannot be detected by any test vector. Base your reasoning on logical implication within the network (i.e., whether downstream logic always masks the fault effect).\n3. Determine the cardinality $|\\mathcal{R}|$ of the set $\\mathcal{R} \\subseteq \\mathcal{F}$ of redundant faults.\n\nExpress the final answer as the integer $|\\mathcal{R}|$ with no units. No rounding is required.",
            "solution": "### 1. Define the Good Circuit Behavior\nThe circuit consists of a NAND gate $X = \\overline{A \\cdot B}$ feeding a NOR gate $Y = \\overline{X+C}$. The Boolean function for the primary output $Y$ in terms of the primary inputs $A, B, C$ is:\n$$Y_{\\text{good}} = \\overline{(\\overline{A \\cdot B}) + C}$$\nUsing De Morgan's laws, this simplifies to:\n$$Y_{\\text{good}} = (\\overline{\\overline{A \\cdot B}}) \\cdot \\bar{C} = (A \\cdot B) \\cdot \\bar{C}$$\nThis function evaluates to $1$ only for the input vector $(A,B,C) = (1,1,0)$. For all other seven input vectors, $Y_{\\text{good}}=0$.\n\n### 2. Define the Fault Universe and Redundancy\nThe set of single stuck-at faults, $\\mathcal{F}$, includes a stuck-at-$0$ and stuck-at-$1$ fault for each of the $5$ nets ($A, B, C, X, Y$), for a total of $|\\mathcal{F}| = 10$ faults. A fault is redundant if its presence does not alter the output function, i.e., $Y_{\\text{faulty}}(A,B,C) = Y_{\\text{good}}(A,B,C)$ for all possible input combinations. To prove a fault is *not* redundant (i.e., is detectable), we only need to find one input vector (a test vector) for which $Y_{\\text{faulty}} \\neq Y_{\\text{good}}$.\n\n### 3. Analyze Faults for Detectability\nWe will systematically analyze each of the $10$ faults by deriving the faulty function and finding a test vector.\n\n*   **Faults on Primary Inputs ($A, B, C$)**\n    *   **$A$ stuck-at-$0$ ($A_{\\text{s-a-0}}$):** The faulty function is $Y_{A_{\\text{s-a-0}}} = (0 \\cdot B) \\cdot \\bar{C} = 0$. For the input $(1,1,0)$, $Y_{\\text{good}} = 1$ while $Y_{A_{\\text{s-a-0}}} = 0$. The fault is **detectable**.\n    *   **$A$ stuck-at-$1$ ($A_{\\text{s-a-1}}$):** The faulty function is $Y_{A_{\\text{s-a-1}}} = (1 \\cdot B) \\cdot \\bar{C} = B \\cdot \\bar{C}$. For the input $(0,1,0)$, $Y_{\\text{good}} = 0$ while $Y_{A_{\\text{s-a-1}}} = 1 \\cdot \\bar{0} = 1$. The fault is **detectable**.\n    *   **$B$ stuck-at-$0$ ($B_{\\text{s-a-0}}$):** Symmetric to $A_{\\text{s-a-0}}$. Test vector $(1,1,0)$ yields $Y_{\\text{good}}=1$ and $Y_{B_{\\text{s-a-0}}}=0$. The fault is **detectable**.\n    *   **$B$ stuck-at-$1$ ($B_{\\text{s-a-1}}$):** Symmetric to $A_{\\text{s-a-1}}$. Test vector $(1,0,0)$ yields $Y_{\\text{good}}=0$ and $Y_{B_{\\text{s-a-1}}}=1 \\cdot \\bar{0} = 1$. The fault is **detectable**.\n    *   **$C$ stuck-at-$0$ ($C_{\\text{s-a-0}}$):** The faulty function is $Y_{C_{\\text{s-a-0}}} = (A \\cdot B) \\cdot \\bar{0} = A \\cdot B$. For the input $(1,1,1)$, $Y_{\\text{good}} = 0$ while $Y_{C_{\\text{s-a-0}}} = 1$. The fault is **detectable**.\n    *   **$C$ stuck-at-$1$ ($C_{\\text{s-a-1}}$):** The faulty function is $Y_{C_{\\text{s-a-1}}} = (A \\cdot B) \\cdot \\bar{1} = 0$. For the input $(1,1,0)$, $Y_{\\text{good}} = 1$ while $Y_{C_{\\text{s-a-1}}} = 0$. The fault is **detectable**.\n\n*   **Faults on Internal Net ($X$)**\n    *   **$X$ stuck-at-$0$ ($X_{\\text{s-a-0}}$):** In the faulty circuit, $Y_{X_{\\text{s-a-0}}} = \\overline{0+C} = \\bar{C}$. For the input $(0,1,0)$, $Y_{\\text{good}} = 0$ while $Y_{X_{\\text{s-a-0}}} = \\bar{0} = 1$. The fault is **detectable**.\n    *   **$X$ stuck-at-$1$ ($X_{\\text{s-a-1}}$):** In the faulty circuit, $Y_{X_{\\text{s-a-1}}} = \\overline{1+C} = 0$. For the input $(1,1,0)$, $Y_{\\text{good}} = 1$ while $Y_{X_{\\text{s-a-1}}} = 0$. The fault is **detectable**.\n\n*   **Faults on Primary Output ($Y$)**\n    *   **$Y$ stuck-at-$0$ ($Y_{\\text{s-a-0}}$):** The faulty function is $Y_{Y_{\\text{s-a-0}}} = 0$. For the input $(1,1,0)$, $Y_{\\text{good}} = 1$. The fault is **detectable**.\n    *   **$Y$ stuck-at-$1$ ($Y_{\\text{s-a-1}}$):** The faulty function is $Y_{Y_{\\text{s-a-1}}} = 1$. For the input $(0,0,0)$, $Y_{\\text{good}} = 0$. The fault is **detectable**.\n\n### 4. Conclusion\nA test vector has been found for every fault in the set $\\mathcal{F}$. Therefore, no fault is redundant. The set of redundant faults, $\\mathcal{R}$, is the empty set.\n\nThe number of redundant faults is $|\\mathcal{R}| = 0$.",
            "answer": "$$ \\boxed{0} $$"
        },
        {
            "introduction": "While enumerating all faults is a necessary first step, it often produces a large and unwieldy list. To make test generation practical, we must \"collapse\" this list by identifying and removing faults that are either equivalent to or dominated by others. This practice builds directly on the previous analysis, using the same circuit to demonstrate how fault equivalence and dominance relationships are formally established to create a minimal, irredundant set of faults for testing .",
            "id": "4270927",
            "problem": "Consider a combinational network within the scope of Electronic Design Automation (EDA). The netlist consists of two logic gates connected as follows: gate $G1$ is a two-input NAND gate with inputs $A$ and $B$ and output $X$, i.e., $X = \\overline{A \\cdot B}$; gate $G2$ is a two-input NOR gate with inputs $X$ and $C$ and output $Y$, i.e., $Y = \\overline{X + C}$. All signals $A$, $B$, $C$, $X$, and $Y$ are Boolean-valued. Assume single stuck-at faults can occur on any signal line, with each line susceptible to stuck-at-$0$ and stuck-at-$1$ faults.\n\nUsing only the formal definitions of single stuck-at faults, test detectability at the primary output, fault equivalence, and fault dominance, derive from first principles the complete set of nonredundant, collapsed single stuck-at faults for this network. In your derivation, you must:\n- Start from the Boolean semantics of the network and the definitions of fault detectability at the primary output.\n- Determine detectability conditions for each single stuck-at fault as subsets of primary input assignments.\n- Use these detectability conditions to establish fault equivalence classes and fault dominance relations.\n- Produce the final collapsed set by removing equivalent and dominated faults, ensuring no redundancy remains.\n\nCompute the exact count of nonredundant, collapsed single stuck-at faults and list the collapsed faults explicitly in terms of the original signal names and stuck values. Express the final count as an integer with no units. No rounding is required. Along the way, briefly justify why no faults are logically redundant in this network.",
            "solution": "The solution involves three main steps: 1) deriving the detection set for every possible single stuck-at fault, 2) performing fault collapsing using equivalence relations, and 3) performing further collapsing using dominance relations.\n\n### 1. Derivation of Fault Detection Sets\n\nFirst, we establish the fault-free behavior. The circuit is defined by $X = \\overline{A \\cdot B}$ and $Y = \\overline{X + C}$. The total uncollapsed fault universe consists of $10$ faults (stuck-at-$0$ and stuck-at-$1$ for each of the $5$ nets $A, B, C, X, Y$). Let a fault be denoted by $L_{v}$, where $L$ is the net and $v$ is the stuck value. The detection set $T(L_v)$ for a fault is the set of all primary input vectors $(A,B,C)$ for which the faulty output differs from the good output.\n\nThe good circuit output $Y$ is $1$ only for the input $(1,1,0)$.\n\nThe detection sets for the $10$ faults are:\n1.  **$A_{\\text{s-a-0}}$**: The faulty output is always $0$. Detected when good output is $1$. So, $T(A_{\\text{s-a-0}}) = \\{(1, 1, 0)\\}$.\n2.  **$A_{\\text{s-a-1}}$**: Detected by activating the fault ($A=0$) and propagating it ($B=1, C=0$). So, $T(A_{\\text{s-a-1}}) = \\{(0, 1, 0)\\}$.\n3.  **$B_{\\text{s-a-0}}$**: Symmetrical to $A_{\\text{s-a-0}}$. $T(B_{\\text{s-a-0}}) = \\{(1, 1, 0)\\}$.\n4.  **$B_{\\text{s-a-1}}$**: Symmetrical to $A_{\\text{s-a-1}}$. $T(B_{\\text{s-a-1}}) = \\{(1, 0, 0)\\}$.\n5.  **$C_{\\text{s-a-0}}$**: Detected by activating ($C=1$) and propagating ($X=0$, which needs $A=1, B=1$). So, $T(C_{\\text{s-a-0}}) = \\{(1, 1, 1)\\}$.\n6.  **$C_{\\text{s-a-1}}$**: The faulty output is always $0$. Detected when good output is $1$. So, $T(C_{\\text{s-a-1}}) = \\{(1, 1, 0)\\}$.\n7.  **$X_{\\text{s-a-0}}$**: Detected by activating ($X=1$, i.e., $A=0$ or $B=0$) and propagating ($C=0$). So, $T(X_{\\text{s-a-0}}) = \\{(0, 0, 0), (0, 1, 0), (1, 0, 0)\\}$.\n8.  **$X_{\\text{s-a-1}}$**: The faulty output is always $0$. Detected when good output is $1$. So, $T(X_{\\text{s-a-1}}) = \\{(1, 1, 0)\\}$.\n9.  **$Y_{\\text{s-a-0}}$**: The faulty output is $0$. Detected when good output is $1$. So, $T(Y_{\\text{s-a-0}}) = \\{(1, 1, 0)\\}$.\n10. **$Y_{\\text{s-a-1}}$**: The faulty output is $1$. Detected whenever good output is $0$. This is true for all 7 input vectors except $(1,1,0)$. So, $T(Y_{\\text{s-a-1}}) = \\{(0,0,0), (0,0,1), (0,1,0), (0,1,1), (1,0,0), (1,0,1), (1,1,1)\\}$.\n\nSince all detection sets are non-empty, no faults are logically redundant.\n\n### 2. Fault Collapsing by Equivalence\n\nTwo faults $f_1$ and $f_2$ are equivalent if $T(f_1) = T(f_2)$. We can group equivalent faults into classes and select one representative from each class.\nBy inspecting the detection sets:\n- **Class 1**: $T(A_{\\text{s-a-0}}) = T(B_{\\text{s-a-0}}) = T(C_{\\text{s-a-1}}) = T(X_{\\text{s-a-1}}) = T(Y_{\\text{s-a-0}}) = \\{(1, 1, 0)\\}$.\n- The other five faults each have a unique detection set and form their own singleton classes.\n\nAfter equivalence collapsing, the initial list of $10$ faults is reduced to $6$ representative faults (one from each class):\n$\\{A_{\\text{s-a-0}}, A_{\\text{s-a-1}}, B_{\\text{s-a-1}}, C_{\\text{s-a-0}}, X_{\\text{s-a-0}}, Y_{\\text{s-a-1}}\\}$.\n\n### 3. Fault Collapsing by Dominance\n\nA fault $f_1$ dominates a fault $f_2$ if $T(f_2) \\subseteq T(f_1)$. In this case, any test for $f_2$ also detects $f_1$. To create a minimal test generation fault list, we can remove the dominating fault $f_1$.\n\nLet's examine dominance relationships among the $6$ representative faults:\n- We have $T(A_{\\text{s-a-1}}) = \\{(0, 1, 0)\\}$ and $T(X_{\\text{s-a-0}}) = \\{(0, 0, 0), (0, 1, 0), (1, 0, 0)\\}$. Since $T(A_{\\text{s-a-1}}) \\subset T(X_{\\text{s-a-0}})$, fault $X_{\\text{s-a-0}}$ dominates $A_{\\text{s-a-1}}$.\n- Similarly, since $T(B_{\\text{s-a-1}}) = \\{(1, 0, 0)\\} \\subset T(X_{\\text{s-a-0}})$, fault $X_{\\text{s-a-0}}$ also dominates $B_{\\text{s-a-1}}$.\n- We have $T(C_{\\text{s-a-0}}) = \\{(1, 1, 1)\\}$ and $T(Y_{\\text{s-a-1}}) = \\{(0,0,0), \\dots, (1,1,1)\\}$. Since $T(C_{\\text{s-a-0}}) \\subset T(Y_{\\text{s-a-1}})$, fault $Y_{\\text{s-a-1}}$ dominates $C_{\\text{s-a-0}}$.\n- Further, note that $T(X_{\\text{s-a-0}}) \\subset T(Y_{\\text{s-a-1}})$, so $Y_{\\text{s-a-1}}$ also dominates $X_{\\text{s-a-0}}$.\n\nBased on standard fault collapsing procedures, we remove the dominating faults from our list of representatives. The faults to be removed are $X_{\\text{s-a-0}}$ and $Y_{\\text{s-a-1}}$.\n\nThe final collapsed fault set consists of the remaining representatives:\n$\\{A_{\\text{s-a-0}}, A_{\\text{s-a-1}}, B_{\\text{s-a-1}}, C_{\\text{s-a-0}}\\}$.\n\nThis final set contains $4$ faults. A test set that detects these $4$ faults is guaranteed to detect all $10$ original single stuck-at faults. The specific list of faults in the collapsed set is:\n1. $A$ stuck-at-$0$\n2. $A$ stuck-at-$1$\n3. $B$ stuck-at-$1$\n4. $C$ stuck-at-$0$\n\nThe total number of faults in the final, nonredundant, collapsed set is $4$.",
            "answer": "$$\n\\boxed{4}\n$$"
        },
        {
            "introduction": "Beyond the abstract stuck-at model, modern fault analysis considers defects arising from the physical layout, such as bridging faults between adjacent wires. This exercise explores a wired-OR bridging fault and reveals the critical concept of fault masking. You will discover how the logical function of a gate can prevent a fault's effect from propagating to an output, even when the fault has been successfully excited by the input pattern . This demonstrates that detectability depends on more than just creating a signal difference at the fault site.",
            "id": "4270929",
            "problem": "Consider a combinational logic fragment in an Electronic Design Automation (EDA) context composed of two independent two-input NAND gates driving a single two-input NOR gate. Let the primary inputs be Boolean variables $a$, $b$, $c$, and $d$. The outputs of the NAND gates are $x = \\overline{a \\cdot b}$ and $y = \\overline{c \\cdot d}$, and these form the inputs to the NOR gate whose output is $z = \\overline{x + y}$. Assume a bridging defect between the adjacent nets $x$ and $y$ is modeled by the wired-OR bridging fault model, in which the electrical short resolves to the Boolean value $x^{\\mathrm{f}} = y^{\\mathrm{f}} = x \\lor y$ in the faulty circuit. The observation point is the NOR gate output $z$. Use foundational test principles: excitation of the fault requires $x \\neq y$, and propagation requires that the difference cause a change at the observation point; and use the definition of controlling and noncontrolling values, where for the Boolean OR function the controlling value is $1$ and the noncontrolling value is $0$, and for the Boolean NOR function the input controlling value is $1$ (forcing the output to $0$) and the input noncontrolling value is $0$. Determine, from first principles, the number of distinct primary input assignments $(a,b,c,d) \\in \\{0,1\\}^{4}$ that will detect the wired-OR bridge between $x$ and $y$ at the observation point $z$, and justify whether the creation of a noncontrolling-to-controlling inversion on the NOR inputs due to the bridge produces an observable effect. Express your final answer as an integer count with no units.",
            "solution": "The problem requires determining the number of input vectors that detect a wired-OR bridging fault. This involves comparing the behavior of the good and faulty circuits.\n\n### Circuit and Fault Model Definition\n\nThe good (fault-free) circuit is defined by the Boolean functions:\n- Intermediate signals: $x = \\overline{a \\cdot b}$ and $y = \\overline{c \\cdot d}$\n- Primary output: $z = \\overline{x \\lor y}$\n\nA test vector is an input assignment $(a,b,c,d) \\in \\{0,1\\}^{4}$ that causes the good circuit output, $z$, to differ from the faulty circuit output, $z^{\\mathrm{f}}$.\n\nThe fault is a wired-OR bridge between nets $x$ and $y$. This means the values on the shorted nets in the faulty circuit, $x^{\\mathrm{f}}$ and $y^{\\mathrm{f}}$, are:\n$$x^{\\mathrm{f}} = y^{\\mathrm{f}} = x \\lor y$$\n\nThe output of the faulty circuit is computed using these faulty values:\n$$z^{\\mathrm{f}} = \\overline{x^{\\mathrm{f}} \\lor y^{\\mathrm{f}}} = \\overline{(x \\lor y) \\lor (x \\lor y)}$$\n\nUsing the idempotent property of logical OR ($P \\lor P = P$), we simplify the expression for $z^{\\mathrm{f}}$:\n$$z^{\\mathrm{f}} = \\overline{x \\lor y}$$\n\n### Comparison of Good and Faulty Circuits\n\nBy comparing the expressions for the good and faulty circuit outputs, we find:\n$$z = z^{\\mathrm{f}} = \\overline{x \\lor y}$$\n\nThis identity holds true for all possible values of $x$ and $y$. Since $x$ and $y$ are determined by the primary inputs $(a,b,c,d)$, it follows that $z = z^{\\mathrm{f}}$ for all $16$ possible input vectors. As there is no input vector for which the good and faulty circuit outputs differ, the fault is undetectable. The number of detecting input assignments is $0$.\n\n### Analysis via Fault Excitation and Propagation\n\nThis conclusion can be confirmed using the principles of fault excitation and propagation.\n1.  **Fault Excitation**: The input vector must create different logic values on the shorted nets in the good circuit, i.e., $x \\neq y$. This occurs when $(x,y)$ is either $(0,1)$ or $(1,0)$.\n2.  **Fault Propagation**: The difference must cause the primary output to change, i.e., $z \\neq z^{\\mathrm{f}}$.\n\nLet's analyze the two cases where the fault is excited:\n\n*   **Case 1: $(x, y) = (0, 1)$**\n    *   **Good Circuit**: The NOR gate inputs are $(0, 1)$. Output: $z = \\overline{0 \\lor 1} = \\overline{1} = 0$.\n    *   **Faulty Circuit**: The bridge forces the nets to $x^{\\mathrm{f}} = 0 \\lor 1 = 1$ and $y^{\\mathrm{f}} = 0 \\lor 1 = 1$. The NOR gate inputs become $(1, 1)$. Output: $z^{\\mathrm{f}} = \\overline{1 \\lor 1} = \\overline{1} = 0$.\n    *   **Comparison**: $z = z^{\\mathrm{f}}$. The fault effect is not propagated.\n\n*   **Case 2: $(x, y) = (1, 0)$**\n    *   **Good Circuit**: The NOR gate inputs are $(1, 0)$. Output: $z = \\overline{1 \\lor 0} = \\overline{1} = 0$.\n    *   **Faulty Circuit**: The bridge forces the nets to $x^{\\mathrm{f}} = 1 \\lor 0 = 1$ and $y^{\\mathrm{f}} = 1 \\lor 0 = 1$. The NOR gate inputs become $(1, 1)$. Output: $z^{\\mathrm{f}} = \\overline{1 \\lor 1} = \\overline{1} = 0$.\n    *   **Comparison**: $z = z^{\\mathrm{f}}$. The fault effect is not propagated.\n\nIn both cases where the fault is excited, the propagation condition fails. Since $z = z^{\\mathrm{f}}$ for all inputs, the fault is logically redundant and undetectable.\n\n### Justification of Unobservability\n\nThe second part of the problem asks to justify whether the \"noncontrolling-to-controlling inversion\" on the NOR inputs produces an observable effect.\nFor a NOR gate, the input controlling value is $1$ (forces output to $0$) and the noncontrolling value is $0$.\n\nLet's analyze this for the case $(x,y) = (0,1)$:\n-   In the good circuit, NOR inputs are $(x, y) = (0, 1)$. Input $x$ has the noncontrolling value $0$.\n-   In the faulty circuit, the wired-OR behavior forces the NOR inputs to $(x^{\\mathrm{f}}, y^{\\mathrm{f}}) = (1, 1)$.\n-   The value on net $x$ has changed from $x=0$ (noncontrolling) to $x^{\\mathrm{f}}=1$ (controlling). This is the specified inversion.\n\nThis inversion is **not observable** due to **fault masking**. For the fault to be excited, one of the NOR inputs must already be at the controlling value of $1$. In the $(x,y)=(0,1)$ case, the input $y=1$ already forces the NOR output to $z = 0$ in the good circuit. In the faulty circuit, the input $x$ also becomes $1$, but this has no effect on the output value, which remains $0$. The pre-existing controlling value on one input masks the effect of the fault-induced change on the other input. A symmetric argument holds for the case $(x,y)=(1,0)$.\n\nTherefore, the number of distinct primary input assignments that detect the fault is zero.",
            "answer": "$$\n\\boxed{0}\n$$"
        }
    ]
}