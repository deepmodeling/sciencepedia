## 引言
在现代超大规模集成电路（VLSI）的设计与制造中，确保芯片的可靠性和良率是至关重要的挑战。随着晶体管尺寸的不断缩小和电路复杂度的急剧增加，微小的物理缺陷可能导致整个系统功能失效。[故障建模](@entry_id:1124861)正是连接物理缺陷世界与逻辑测试世界的桥梁，它通过建立精确的数学和逻辑抽象，使得我们能够系统性地分析、检测和诊断这些缺陷。

本文旨在全面而深入地探讨[数字电路](@entry_id:268512)测试中几种最核心的[故障模型](@entry_id:1124860)。文章解决了从抽象的逻辑定义到具体的物理实现，再到高级应用中如何运用这些模型的知识鸿沟。读者将学习到[故障模型](@entry_id:1124860)不仅仅是理论概念，更是贯穿整个芯片生命周期的实用工程工具。

文章将分为三个核心部分展开：第一章“原理与机制”，将从第一性原理出发，详细剖析[固定型故障](@entry_id:171196)、[桥接故障](@entry_id:169089)和延迟故障的逻辑定义、物理基础和检测机制；第二章“应用与跨学科连接”，将展示这些模型如何在可测试性设计（DFT）、自动测试[向量生成](@entry_id:152883)（ATPG）、故障仿真以及与物理制造相结合的良率分析中发挥关键作用；最后，第三章“动手实践”部分将通过具体问题，帮助读者巩固理论知识并应用于实际分析中。通过本次学习，你将构建一个关于[故障建模](@entry_id:1124861)的坚实知识框架，为应对先进半导体技术中的测试挑战做好准备。

## 原理与机制

本章旨在深入探讨[数字电路](@entry_id:268512)测试领域中几种基本而关键的[故障模型](@entry_id:1124860)：[固定型故障](@entry_id:171196)、[桥接故障](@entry_id:169089)和延迟故障。与绪论中对背景的宏观概述不同，本章将从第一性原理出发，系统地阐述这些模型的数学定义、物理基础和在自动化测试设计中所采用的算法机制。我们将逐一剖析每种模型的逻辑抽象、其在现代[CMOS](@entry_id:178661)工艺中的物理对应物，以及用于故障激励、传播和检测的核心概念。本章的目标是为读者构建一个严谨、精确且自洽的知识框架，为后续章节中关于测试生成、故障仿真和诊断等高级主题奠定坚实的基础。

### [固定型故障模型](@entry_id:168854)

**[固定型故障](@entry_id:171196) (Stuck-at Fault)** 模型是最早被提出且至今仍在业界广泛应用的逻辑[故障模型](@entry_id:1124860)。其核心思想在于将复杂的物理缺陷抽象为一个简单的[逻辑错误](@entry_id:140967)：电路中的某一个信号线（net）永久性地固定于逻辑0（称为 **固定于0 (stuck-at-0, s-a-0)**）或逻辑1（称为 **固定于1 (stuck-at-1, s-a-1)**），而不受其驱动源信号的影响。

#### 逻辑定义与检测条件

[固定型故障](@entry_id:171196)的检测依赖于两个基本条件：**故障激活 (fault activation)** 和 **[故障传播](@entry_id:1124821) (fault propagation)**。

要检测一个信号线 $n$ 上的固定于 $v$（$v \in \{0, 1\}$）的故障，测试向量必须首先满足 **[可控性](@entry_id:148402) (controllability)** 条件：在无故障的“良好”电路中，该测试向量必须能驱动信号线 $n$ 的值为 $\bar{v}$。这一步在故障电路和良好电路之间制造了一个逻辑差异，称为故障的 **激活**。例如，要检测一个s-a-0故障，必须将该线驱动为逻辑1。

接下来，这个在 $n$ 处产生的逻辑差异（在良好电路中为 $\bar{v}$，在故障电路中为 $v$）必须通过一条或多条逻辑路径传播到电路的一个 **主输出 (primary output)** 或可观测的寄存器。这被称为 **[可观测性](@entry_id:152062) (observability)** 条件。传播路径上的所有门电路的旁路输入（off-path inputs）都必须被设置为非控制值，以确保故障效应不会被屏蔽。当故障效应到达主输出时，我们便称该故障被 **检测** 到 。

#### [CMOS技术](@entry_id:265278)中的物理基础

虽然[固定型故障](@entry_id:171196)是一个逻辑抽象，但它源于对真实物理缺陷的深刻洞察。在[CMOS](@entry_id:178661)工艺中，一种常见的制造缺陷是信号线与电源轨（$V_{DD}$）或地轨（$GND$）之间形成了一个低阻值的导电通路，即 **硬短路 (hard short)**。

我们可以通过一个简化的直流模型来分析这种短路的电气行为。假设一个[CMOS反相器](@entry_id:264699)的输出节点 $x$ 发生短路。当反相器试图驱动节点 $x$ 时，其导通的上拉PMOS管或下拉NMOS管可以被建模为一个[导通电阻](@entry_id:172635)，分别为 $R_{p,\text{on}}$ 和 $R_{n,\text{on}}$。同时，到电源轨的短路可以建模为一个有限的短路电阻 $r_{s}$ 。

考虑一个到 $V_{DD}$ 的短路（电阻为 $r_{s,H}$），这可能导致一个s-a-1故障。最坏的情况是当反相器试图将节点 $x$ 拉低至 $GND$ 时。此时，NMOS导通，电路形成一个由 $r_{s,H}$ 和 $R_{n,\text{on}}$ 构成的[分压器](@entry_id:275531)。节点 $x$ 的[稳态](@entry_id:139253)电压 $V_x$ 为：
$$ V_x = V_{DD} \frac{R_{n,\text{on}}}{R_{n,\text{on}} + r_{s,H}} $$
为了让后续[逻辑门](@entry_id:178011)将 $V_x$ 可靠地解释为逻辑1，该电压必须高于其输入高电平阈值 $V_{IH,\min}$。这要求 $V_x$ 接近 $V_{DD}$，从而引出一个关键的物理条件：短路电阻必须远小于晶体管的[导通电阻](@entry_id:172635)，即 $r_{s,H} \ll R_{n,\text{on}}$。只有当这个条件满足时，短路才能“压制”正常的驱动行为，使节点表现为固定于1。

同理，对于一个到 $GND$ 的短路（电阻为 $r_{s,L}$），要使其表现为s-a-0故障，必须满足 $r_{s,L} \ll R_{p,\text{on}}$。如果这些电阻关系不成立，节点电压可能会落入逻辑阈值之间的未定区域，形成比[固定型故障](@entry_id:171196)更复杂的故障行为。

#### 故障等效与故障压缩

一个典型的超大规模[集成电路](@entry_id:265543)包含数百万乃至数十亿个晶体管，这意味着潜在的[固定型故障](@entry_id:171196)数量是巨大的。为了有效管理测试过程，**故障压缩 (fault collapsing)** 成为一个必不可少的步骤。其基础是 **故障等效 (fault equivalence)** 的概念：如果两组故障被完全相同的测试向量集所检测，那么它们是等效的。

故障等效性部分源于电路的结构。例如，在一个扇出（fanout）结构中，驱动门输出端的故障与扇出主干（stem）上的故障在物理和逻辑上是无法区分的，因此它们是等效的。同样，扇出分支（branch）上的故障也与其连接的负载门输入端的故障等效 。

另一部分等效性源于[逻辑门](@entry_id:178011)的功能。考虑一个 $k$ 输入的与门（AND gate）。要检测其任何一个输入端的s-a-0故障，我们必须将该输入置为1，并将所有其他输入置为1（AND门的非控制值）以传播故障。这要求输入向量为全1。而要检测与门输出端的s-a-0故障，也必须将所有输入置为1以使无故障输出为1。由于在这两种情况下，激活和传播的条件在门级是相同的，因此 $k$ 输入[与门](@entry_id:166291)的任意输入s-a-0故障都与其输出s-a-0故障等效。然而，输入s-a-1故障与输出s-a-1故障则不是等效的，因为它们的测试集不同。

让我们通过一个具体的例子来理解故障压缩。考虑一个由双输入[与门](@entry_id:166291)驱动一个反相器构成的电路（即一个NAND门的功能），其函数为 $y = \lnot(x_1 \land x_2)$ 。我们可以枚举所有门输入和输出引脚上的共10个潜在[固定型故障](@entry_id:171196)，并推导每个故障下的电路功能：

*   **等效类1 (输出恒为1)**: $y_f = 1$
    *   $x_1$ s-a-0: $y_f = \lnot(0 \land x_2) = 1$
    *   $x_2$ s-a-0: $y_f = \lnot(x_1 \land 0) = 1$
    *   AND门输出 $m$ s-a-0: $y_f = \lnot(0) = 1$
    *   Inverter输入 $m$ s-a-0: $y_f = \lnot(0) = 1$
    *   Inverter输出 $y$ s-a-1: $y_f = 1$

*   **等效类2 (输出恒为0)**: $y_f = 0$
    *   AND门输出 $m$ s-a-1: $y_f = \lnot(1) = 0$
    *   Inverter输入 $m$ s-a-1: $y_f = \lnot(1) = 0$
    *   Inverter输出 $y$ s-a-0: $y_f = 0$

*   **等效类3 (输出为 $\lnot x_2$)**:
    *   $x_1$ s-a-1: $y_f = \lnot(1 \land x_2) = \lnot x_2$

*   **等效类4 (输出为 $\lnot x_1$)**:
    *   $x_2$ s-a-1: $y_f = \lnot(x_1 \land 1) = \lnot x_1$

通过这种分析，最初的10个故障被压缩为4个等效类。测试生成算法只需为每个等效类生成一个测试向量，即可覆盖该类中的所有故障，极大地提高了效率。

#### 算法建模：D-演算

为了在算法层面系统地处理故障的传播，J. Paul Roth 提出了著名的D-演算（D-calculus）。这是一种五值逻辑代数，其符号集为 $\{0, 1, X, D, \overline{D}\}$。每个符号代表一个 (良好电路值/故障电路值) 的[有序对](@entry_id:269702)  ：

*   $0 \leftrightarrow (0, 0)$: 两个电路中值都为0。
*   $1 \leftrightarrow (1, 1)$: 两个电路中值都为1。
*   $D \leftrightarrow (1, 0)$: 故障效应，良好电路为1，故障电路为0。
*   $\overline{D} \leftrightarrow (0, 1)$: 故障效应，良好电路为0，故障电路为1。
*   $X \leftrightarrow (u, u)$: 未知或不关心（'u'）的值。

[逻辑门](@entry_id:178011)的运算被定义为对其输入对的逐元素（component-wise）布尔运算。例如，要计算 $\operatorname{NAND}(D, 1)$：
1.  将输入转换为[有序对](@entry_id:269702)：$D \to (1,0)$ 和 $1 \to (1,1)$。
2.  对“良好”电路分量和“故障”电路分量分别执行NAND运算：
    *   良好电路输出: $\operatorname{NAND}(1, 1) = 0$
    *   故障电路输出: $\operatorname{NAND}(0, 1) = 1$
3.  将结果对 $(0,1)$ 映射回五值逻辑符号，得到 $\overline{D}$。

因此，$\operatorname{NAND}(D, 1) = \overline{D}$。这符合直觉：当一个非反相输入（$D$）通过一个反相门（NAND）传播时，其极性会翻转。如果一个门的输入之一是其控制值（例如NAND门的0），则故障效应会被屏蔽。例如，$\operatorname{NAND}(D, 0)$ 的结果是 $( \operatorname{NAND}(1,0), \operatorname{NAND}(0,0) ) = (1,1)$, 即逻辑1。

#### 高级主题：故障屏蔽与重聚[扇出](@entry_id:173211)

简单的路径敏化思想在包含 **重聚[扇出](@entry_id:173211) (reconvergent fanout)** 的电路中可能会失效。重聚[扇出](@entry_id:173211)是指一个信号线的[扇出](@entry_id:173211)分支通过不同的逻辑路径再次汇合到同一个门。这种结构可能导致 **故障屏蔽 (fault masking)**。

考虑一个典型的[多路选择器](@entry_id:172320)电路 $z = (\overline{x} \cdot a) + (x \cdot b)$，其中 $x$ 存在s-a-1故障 。要激活此故障，必须设置 $x$ 的良好电路值为0。在D-演算中，这意味着 $x$ 的值为 $\overline{D}$ (即 $\langle 0/1 \rangle$)。

*   上半部分路径计算 $y_1 = \overline{x} \cdot a$。信号 $\overline{x}$ 的值为 $\overline{\overline{D}} = D$。
*   下半部分路径计算 $y_2 = x \cdot b$。信号 $x$ 的值为 $\overline{D}$。

现在考虑一个特定的输入向量 $\langle a, b, x_{\text{good}} \rangle = \langle 1, 1, 0 \rangle$。
*   $y_1$ 的值为 $D \cdot 1 = D$。
*   $y_2$ 的值为 $\overline{D} \cdot 1 = \overline{D}$。
*   最终输出 $z$ 的值为 $y_1 + y_2 = D + \overline{D}$。根据D-演算的规则，$D + \overline{D} = \langle 1,0 \rangle + \langle 0,1 \rangle = \langle 1 \lor 0, 0 \lor 1 \rangle = \langle 1,1 \rangle = 1$。

尽管故障被成功激活，并且沿着两条路径都传播了下去，但由于两条重聚路径上的故障效应是互补的（一个$D$，一个$\overline{D}$），它们在重[聚点](@entry_id:177089)（OR门）处相互抵消，导致最终输出在良好电路和故障电路中完全相同。因此，该故障对于这个特定的测试向量是不可见的。这种现象被称为 **故障抵消 (fault cancellation)**，是ATPG算法必须处理的一个重要挑战。

### [桥接故障](@entry_id:169089)模型

**[桥接故障](@entry_id:169089) (Bridging Fault)** 模型用于描述两个或多个本应相互独立的信号线之间形成的意外导电通路。这种故障在物理上对应于制造过程中出现的多余导电材料（如金属溅射）。

#### 有线逻辑行为

当被桥接的信号线被它们各自的驱动门驱动到不同的逻辑值时（一个驱动为1，另一个驱动为0），就会发生 **驱动竞争 (driver contention)**。短路节点上的最终电压由两个驱动器的相对强度决定。这个行为通常被抽象为 **有线逻辑 (wired logic)** 。

假设两个[CMOS](@entry_id:178661)输出级发生桥接，我们可以通过其[上拉电阻](@entry_id:178010) $R_{PU}$ 和下拉电阻 $R_{PD}$ 来分析竞争结果。当一个驱动器试图上拉（通过 $R_{PU}$ 连接到 $V_{DD}$）而另一个试图下拉（通过 $R_{PD}$ 连接到 $GND$）时，桥接节点上的电压 $V_X$ 由以下分压公式决定：
$$ V_X = V_{DD} \frac{R_{PD}}{R_{PU} + R_{PD}} $$

根据这个结果，可以定义两种主要的有线逻辑模型：

1.  **有线与 (Wired-AND)**: 在许多[CMOS](@entry_id:178661)工艺中，NMOS晶体管（下拉）比P[MOS晶体管](@entry_id:273779)（上拉）的驱动能力更强，即 $R_{PD} \ll R_{PU}$。这导致在竞争中，节点电压 $V_X$ 会被拉向接近 $GND$ 的值，被解释为逻辑0。因此，0成为显性值，桥接的逻辑行为等效于一个AND门：只有当所有被桥接的线都被驱动为1时，结果才为1。

2.  **有[线或](@entry_id:170208) (Wired-OR)**: 在某些技术或设计中，如果上拉驱动器明显强于下拉驱动器（$R_{PU} \ll R_{PD}$），则1会成为显性值。桥接的逻辑行为等效于一个OR门：只要有任何一条线被驱动为1，结果就为1。

这些简单的逻辑模型是[桥接故障](@entry_id:169089)仿真的基础，但需要注意的是，它们是基于驱动强度显著不对称的假设。如果驱动强度相当，节点电压可能处于不确定区域，导致更复杂的模拟行为。

### 延迟[故障模型](@entry_id:1124860)

随着集成电路工作频率的不断提高和特征尺寸的不断缩小，信号的传播时间变得至关重要。仅仅保证电路在静态下功能正确是不够的，还必须确保其在指定时钟周期内完成所有操作。延迟[故障模型](@entry_id:1124860)正是为了捕捉这些与时序相关的缺陷。

#### 动机：高速测试的需求

延迟缺陷可能由多种物理原因引起，如电阻或电容的参数偏离、[晶体管性能](@entry_id:1133341)退化等。这些缺陷通常不会导致电路在低速下出现功能错误，但在高速（at-speed）工作时，它们会导致信号转换的延迟超过时钟周期，从而在下一级寄存器中锁存错误的数据。因此，需要专门的 **高速测试 (at-speed testing)** 方法和相应的[故障模型](@entry_id:1124860)。

#### [转移故障模型](@entry_id:1133349) (TFM)

**[转移故障模型](@entry_id:1133349) (Transition Fault Model, TFM)** 是一种简化的延迟[故障模型](@entry_id:1124860)，它将一个节点的延迟缺陷抽象为两种情况：**慢上升 (slow-to-rise, STR)** 或 **慢下降 (slow-to-fall, STF)** 。该模型假设缺陷足够“严重”，以至于任何通过该节点的上升或下降转换都会失败。

TFM的检测需要一个 **双模式测试序列 (two-pattern test)**：
1.  **初始化向量 ($V_1$)**: 在第一个时钟周期施加，用于将故障点初始化为待测转换的起始值。例如，为了测试一个STR故障，必须首先将该节点初始化为0。
2.  **发射向量 ($V_2$)**: 在紧接着的第二个[时钟周期](@entry_id:165839)施加，用于在该节点上发射一个逻辑转换。对于STR故障，就是发射一个 $0 \to 1$ 的转换。

为了观测到这个延迟故障，发射的转换必须沿着一条敏化路径传播到可观测点，并在 **高速时钟 (at-speed clock)** 的下一个捕获沿到达之前完成。如果在捕获时刻，由于延迟过大，信号尚未达到其最[终值](@entry_id:141018)，则寄存器会锁存一个错误的值，从而检测到故障。路径敏化同样要求路径上门的旁路输入被设置为稳定的非控制值。

#### [路径延迟故障模型](@entry_id:1129433) (PDFM)

TFM模型假设延迟集中于单个节点，而 **[路径延迟故障模型](@entry_id:1129433) (Path Delay Fault Model, PDFM)** 则更为精细。它考虑的是一条从输入到输出的特定 **逻辑路径 (logic path)** 上所有门和连线延迟的 **累积效应** 。这使得PDFM能够检测到由多个微小延迟累积而成的[时序违规](@entry_id:177649)，而这些微小延迟可能单独不足以构成一个TFM故障。

PDFM测试同样需要一个双模式序列来发射一个沿特定路径传播的转换。检测条件是该路径的总延迟 $D_f(P)$ 超过了时钟周期 $T_{clk}$。

#### 鲁棒与非鲁棒测试及风险

为一条特定路径创建测试的一个核心挑战是确保观测到的延迟确实来自该路径。这就引出了 **鲁棒 (robust)** 和 **非鲁棒 (non-robust)** 测试的概念。

一个 **鲁棒测试** 能够保证，如果目标路径上存在延迟故障，无论电路中其他部分是否存在其他延迟缺陷，该故障都一定能被检测到。这要求在整个测试窗口内（从发射到捕获），目标路径上所有门的旁路输入都必须稳定地保持在它们的非控制值上。

一个 **非鲁棒测试** 的条件则较弱，它只要求旁路输入在信号转换的瞬间处于非控制值。这种测试的有效性依赖于这样一个假设：旁路输入上的任何转换都不会比主路径上的转换更晚到达。

非鲁棒测试的主要风险在于 **[动态冒险](@entry_id:174889) (dynamic hazards)** 或 **毛刺 (glitches)**，尤其是在存在重聚[扇出](@entry_id:173211)的电路中。考虑一个电路 $Z = (A \land B) \lor C$，我们希望测试路径 $P: A \to X \to Z$ 的延迟 。一个非鲁棒测试可能会使用一个变化的输入 $A$ 来发射转换，并依赖另一个也由 $A$ 驱动的重聚扇出信号 $B$ 来提供AND门的非控制值1。如果产生 $B$ 的路径延迟与主路径不匹配， $B$ 可能会在关键时刻产生一个短暂的0毛刺。这个毛刺会暂时将AND门输出置为0，从而可能掩盖或改变从 $A$ 传播过来的转换时序。结果是，一个原本在理想条件下能够检测到故障的非鲁棒测试，在实际电路中可能会因为毛刺而被无效化，导致故障逃逸。因此，在高质量的延迟测试中，生成鲁棒测试是首选的目标。