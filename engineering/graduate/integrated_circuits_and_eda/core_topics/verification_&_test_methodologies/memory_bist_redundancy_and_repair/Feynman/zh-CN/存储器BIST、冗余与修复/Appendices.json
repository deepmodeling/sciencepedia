{
    "hands_on_practices": [
        {
            "introduction": "要想充分理解存储器修复的价值，我们首先必须了解如何检测故障。本练习将深入探讨 MBIST 的操作核心，通过分析一个标准的测试算法——March C- 来实现。通过将该算法分解为基本的读写操作，您将从第一性原理出发，推导出总测试时间，从而具体理解存储器大小与测试时长之间的线性关系，这是评估真实芯片设计中测试成本的一项基本技能。",
            "id": "4282093",
            "problem": "对一个具有 $n$ 个字地址和字宽为 $b$ 位的单端口静态随机存取存储器 (SRAM) 运行同步内建自测试 (BIST)。该 BIST 采用经典的 March C-minus (March C$^{-}$) 算法。在 March 测试中，每个 March 元素按照指定的地址顺序，对每个地址执行一个固定的读写操作序列。假设 March C$^{-}$ 的定义如下，其中箭头表示地址遍历顺序，每个括号内的列表指定了对每个地址的操作序列：\n- ↑(w0): 按升序扫描地址，并在每个地址上，写入字值 $0$。\n- ↑(r0, w1): 按升序扫描，并在每个地址上，读取字并期望值为 $0$，然后写入 $1$。\n- ↑(r1, w0): 按升序扫描，并在每个地址上，读取 $1$，然后写入 $0$。\n- ↓(r0, w1): 按降序扫描，并在每个地址上，读取 $0$，然后写入 $1$。\n- ↓(r1, w0): 按降序扫描，并在每个地址上，读取 $1$，然后写入 $0$。\n- ↓(r0): 按降序扫描，并在每个地址上，读取 $0$。\n\n假设一个单端口存储器接口，其中字级别的每次读或写操作恰好消耗 $1$ 个时钟周期，且 BIST 以测试时钟频率 $f$（单位为赫兹）运行。一个读周期获取整个 $b$ 位字，一个写周期写入整个 $b$ 位字。\n\n从这些定义出发，且不使用任何预先记忆的复杂度结果，推导：\n- 在整个 March C$^{-}$ 序列中执行的字级读操作和字级写操作的总数，表示为 $n$ 的函数。\n- 位级操作（位级读和位级写的总和）的总数，表示为 $n$ 和 $b$ 的函数。\n- 总 BIST 测试时间 $T$（以秒为单位），表示为 $T = \\frac{O(n)}{f}$ 的形式，其中包含每个 March 元素贡献的显式常数。\n\n给出你的最终答案，形式为仅用 $n$ 和 $f$ 表示的单个闭式表达式。在最终答案中不要包含单位。",
            "solution": "我们从 March 测试和同步单端口存储器访问时序的核心定义开始：\n\n1. 一个 March 元素按升序或降序，对每个地址应用一个固定的读写操作序列，每次遍历恰好一次。对于一个有 $n$ 个地址的存储器，单次遍历会访问 $n$ 个地址。\n\n2. 在单端口同步存储器接口中，一次字的读取消耗 $1$ 个时钟周期，一次字的写入也消耗 $1$ 个时钟周期。读和写不能在同一个周期内发生。因此，对每个地址的 $k$ 个操作序列，每个地址消耗 $k$ 个周期，或者说每次完整遍历 $n$ 个地址消耗 $k n$ 个周期。\n\n3. 每次字级读取并行返回 $b$ 位，每次字级写入并行施加 $b$ 位。因此，位级操作计数等于字级操作数量乘以 $b$。\n\n我们接下来列举 March C$^{-}$ 元素及其每个地址的操作计数：\n\n- 元素 ↑(w0): 对每个地址，序列是单次写入值 $0$。这贡献了每个地址 $1$ 次字级操作，因此该元素总共贡献 $1 \\cdot n$ 次字级操作。其中，读操作为 $0 \\cdot n$ 次，写操作为 $1 \\cdot n$ 次。\n\n- 元素 ↑(r0, w1): 对每个地址，序列是读取期望值 $0$，然后写入 $1$。这贡献了每个地址 $2$ 次字级操作，因此该元素总共贡献 $2 \\cdot n$ 次操作，包括 $1 \\cdot n$ 次读操作和 $1 \\cdot n$ 次写操作。\n\n- 元素 ↑(r1, w0): 类似地，贡献 $2 \\cdot n$ 次字级操作，其中 $1 \\cdot n$ 次读操作和 $1 \\cdot n$ 次写操作。\n\n- 元素 ↓(r0, w1): 贡献 $2 \\cdot n$ 次字级操作，其中 $1 \\cdot n$ 次读操作和 $1 \\cdot n$ 次写操作。\n\n- 元素 ↓(r1, w0): 贡献 $2 \\cdot n$ 次字级操作，其中 $1 \\cdot n$ 次读操作和 $1 \\cdot n$ 次写操作。\n\n- 元素 ↓(r0): 对每个地址，单次读取期望值 $0$，贡献 $1 \\cdot n$ 次字级操作，全部为读操作。\n\n对所有六个元素求和，得到总的字级读写次数：\n\n- 总读操作次数：来自元素 ↑(r0,w1)、↑(r1,w0)、↓(r0,w1)、↓(r1,w0) 和 ↓(r0)，每个贡献 $1 \\cdot n$ 次读操作，我们得到\n$$\nn + n + n + n + n \\;=\\; 5 n.\n$$\n\n- 总写操作次数：来自元素 ↑(w0)、↑(r0,w1)、↑(r1,w0)、↓(r0,w1) 和 ↓(r1,w0)，每个贡献 $1 \\cdot n$ 次写操作，我们得到\n$$\nn + n + n + n + n \\;=\\; 5 n.\n$$\n\n因此，在整个 March C$^{-}$ 过程中，字级存储器访问（读加写）的总数是\n$$\n5 n + 5 n \\;=\\; 10 n.\n$$\n\n根据宽度为 $b$ 位的并行字接口，每次字级访问对应于 $b$ 次位级操作。因此，位级操作的总数是\n$$\n(10 n) \\cdot b \\;=\\; 10 n b.\n$$\n\n对于测试时间，每个周期进行一次字级访问，频率为 $f$，总周期数等于总字级访问次数。因此，\n$$\nT \\;=\\; \\frac{\\text{total cycles}}{f} \\;=\\; \\frac{10 n}{f}.\n$$\n\n为展示每个 March 元素对 $T$ 贡献的显式常数，注意每个元素的周期贡献分别为 $1 \\cdot n$、$2 \\cdot n$、$2 \\cdot n$、$2 \\cdot n$、$2 \\cdot n$ 和 $1 \\cdot n$，总和为 $(1+2+2+2+2+1) n = 10 n$。因此，\n$$\nT \\;=\\; \\frac{(1+2+2+2+2+1)\\,n}{f} \\;=\\; \\frac{10 n}{f}.\n$$\n\n当 $f$ 的单位是赫兹时，此表达式的单位是秒。",
            "answer": "$$\\boxed{\\frac{10 n}{f}}$$"
        },
        {
            "introduction": "抽象的测试算法最终必须通过物理硬件来实现。本练习将指导您基于组件级的成本模型，估算一个完整的 MBIST 及修复逻辑模块所占用的硅片面积（门数）。通过将控制器分解为其子模块——如地址生成器和响应比较器——您将学习到设计选择如何直接转化为硬件成本，这是任何电路设计者都必须面对的关键考量。",
            "id": "4282103",
            "problem": "考虑一个与内存内建自测试（MBIST）一起使用的同步单端口静态随机存取存储器（SRAM）阵列。该阵列存储 $n$ 个字，每个字为 $b$ 位。地址宽度为 $a = \\lceil \\log_{2}(n) \\rceil$。用于此内存的 MBIST 实例由以下子模块构成：一个地址生成器、一个数据模式生成器、一个响应比较器、一个失效地址捕获器，以及用于 $R$ 个备用行和 $C$ 个备用列的冗余与修复资源。列索引宽度为 $w = \\lceil \\log_{2}(b) \\rceil$。设计假设如下。\n\n1. 地址生成器是一个自由运行的加一计数器，实现为一个 $a$ 位寄存器和一个基于行波进位关系的组合增量器。增量器逻辑基于布尔恒等式 $s_{0} = \\neg A_{0}$，$c_{0} = A_{0}$，以及对于 $i \\in \\{1,\\dots,a-1\\}$，$s_{i} = A_{i} \\oplus c_{i-1}$ 和 $c_{i} = A_{i} \\land c_{i-1}$。\n\n2. 数据模式生成器是一个 $b$ 位的斐波那契线性反馈移位寄存器（LFSR），带有两个抽頭（具有 $2$ 个非零系数的本原多项式），使用 $b$ 个存储元件和一个 2 输入异或反馈。该 LFSR 通过每位一个 2:1 的加载多路复用器支持重新置入种子。\n\n3. 响应比较器通过按位异或非（XNOR）操作，然后使用平衡的 2 输入合取（AND）树进行关联归约，来检查 $b$ 位读取数据和预期的 $b$ 位模式是否相等。产生一个单一的失效标志。\n\n4. 失效地址捕获器是一个 $a$ 位寄存器，其每位时钟使能通过在每个数据输入端使用一个 2:1 多路复用器实现。\n\n5. 冗余与修复资源包括 $R$ 个行修复条目，每个条目存储一个 $a$ 位的行地址和一个专用的 $a$ 位行匹配相等比较器；以及 $C$ 个列修复条目，每个条目存储一个 $w$ 位的列索引和一个专用的 $w$ 位列匹配相等比较器。\n\n使用以下门等效模型，以 2 输入与非门（NAND）作为成本单位。对于两级逻辑实现，假设：\n- 一个 2 输入异或门（XOR）的成本为 $k_{\\mathrm{xor}} = 4$ 个 2 输入与非门等效。\n- 一个 2 输入异或非门（XNOR）的成本为 $k_{\\mathrm{xnor}} = 4$。\n- 一个 2 输入合取门（AND）的成本为 $k_{\\land} = 2$。\n- 一个 2:1 多路复用器的成本为 $k_{\\mathrm{mux}} = 4$。\n- 一个逻辑反相器（NOT）的成本为 $k_{\\neg} = 1$，通过将一个 2 输入与非门的输入端连接在一起实现。\n- 一个上升沿触发的数据触发器的成本为 $k_{\\mathrm{dff}} = 20$。\n\n将归约树建模为由 2 输入合取门组成的平衡二叉树，因此归约 $m$ 个输入需要使用 $m-1$ 个 2 输入合取门。\n\n仅使用上述假设和定义，并通过布尔恒等式和结构组合表达所有中间推理过程，推导出一个单一、简化的封闭形式表达式，用于计算整个 MBIST 与修复逻辑的总估算门数（以 2 输入与非门等效为单位），该表达式是关于 $n$、$b$、$R$ 和 $C$ 的函数，其中 $a = \\lceil \\log_{2}(n) \\rceil$ 和 $w = \\lceil \\log_{2}(b) \\rceil$。以一个精确的解析表达式形式提供最终结果。无需四舍五入。",
            "solution": "目标是推导指定内存内建自测试（MBIST）和修复逻辑的总门数 $G_{\\text{total}}$ 的封闭形式表达式，以 2 输入与非门等效为单位进行度量。总成本是其组成子模块成本的总和：\n$$\nG_{\\text{total}} = G_{\\text{addr_gen}} + G_{\\text{data_gen}} + G_{\\text{comp}} + G_{\\text{fail_cap}} + G_{\\text{repair}}\n$$\n我们将根据提供的门等效模型推导每个组件的成本：$k_{\\mathrm{xor}} = 4$，$k_{\\mathrm{xnor}} = 4$，$k_{\\land} = 2$，$k_{\\mathrm{mux}} = 4$，$k_{\\neg} = 1$ 和 $k_{\\mathrm{dff}} = 20$。地址宽度为 $a = \\lceil \\log_{2}(n) \\rceil$，列索引宽度为 $w = \\lceil \\log_{2}(b) \\rceil$。\n\n$1$. **地址生成器成本 ($G_{\\text{addr_gen}}$)**\n地址生成器由一个 $a$ 位寄存器和一个 $a$ 位组合增量器组成。\n- $a$ 位寄存器由 $a$ 个 D 型触发器（DFF）组成。其成本为 $a \\cdot k_{\\mathrm{dff}} = 20a$。\n- 组合增量器的逻辑是给定的。对于最低有效位（$i=0$），逻辑为 $s_0 = \\neg A_0$，需要一个反相器。成本为 $k_{\\neg} = 1$。进位逻辑 $c_0 = A_0$ 是直接连接，不产生门成本。对于剩下的 $a-1$ 位（$i \\in \\{1, \\dots, a-1\\}$），逻辑为 $s_i = A_i \\oplus c_{i-1}$ 和 $c_i = A_i \\land c_{i-1}$。这对应于每一位的一个半加器。这 $a-1$ 个级联中每一级的成本是 $k_{\\mathrm{xor}} + k_{\\land} = 4 + 2 = 6$。增量器的总成本为 $k_{\\neg} + (a-1)(k_{\\mathrm{xor}} + k_{\\land}) = 1 + (a-1) \\cdot 6 = 6a - 5$。\n- 地址生成器的总成本是寄存器和增量器成本之和：\n$$\nG_{\\text{addr_gen}} = a \\cdot k_{\\mathrm{dff}} + (k_{\\neg} + (a-1)(k_{\\mathrm{xor}} + k_{\\land})) = 20a + (1 + 6(a-1)) = 20a + 6a - 5 = 26a - 5\n$$\n\n$2$. **数据模式生成器成本 ($G_{\\text{data_gen}}$)**\n$b$ 位的斐波那契 LFSR 包括 $b$ 个存储元件、反馈逻辑和重新置入种子逻辑。\n- $b$ 个存储元件是 DFF，成本为 $b \\cdot k_{\\mathrm{dff}} = 20b$。\n- 反馈逻辑是一个单一的 2 输入异或门，成本为 $k_{\\mathrm{xor}} = 4$。\n- 重新置入种子逻辑由每位一个 2:1 多路复用器组成，成本为 $b \\cdot k_{\\mathrm{mux}} = 4b$。\n- 数据模式生成器的总成本为：\n$$\nG_{\\text{data_gen}} = b \\cdot k_{\\mathrm{dff}} + k_{\\mathrm{xor}} + b \\cdot k_{\\mathrm{mux}} = 20b + 4 + 4b = 24b + 4\n$$\n\n$3$. **响应比较器成本 ($G_{\\text{comp}}$)**\n比较器执行按位比较并对结果进行归约。\n- 对 $b$ 位读取数据和预期数据的按位比较是使用 $b$ 个异或非门（XNOR）完成的。成本为 $b \\cdot k_{\\mathrm{xnor}} = 4b$。\n- $b$ 个异或非门的输出被送入一个平衡的 2 输入合取（AND）树。这样一个有 $b$ 个输入的树需要 $b-1$ 个门。成本为 $(b-1) \\cdot k_{\\land} = 2(b-1) = 2b-2$。\n- 响应比较器的总成本为：\n$$\nG_{\\text{comp}} = b \\cdot k_{\\mathrm{xnor}} + (b-1) \\cdot k_{\\land} = 4b + 2(b-1) = 4b + 2b - 2 = 6b - 2\n$$\n\n$4$. **失效地址捕获器成本 ($G_{\\text{fail_cap}}$)**\n这是一个带有每位时钟使能的 $a$ 位寄存器。\n- 该寄存器需要 $a$ 个 DFF，成本为 $a \\cdot k_{\\mathrm{dff}} = 20a$。\n- 时钟使能机制是在每个 DFF 的数据输入端使用一个 2:1 多路复用器实现的。这需要 $a$ 个多路复用器，成本为 $a \\cdot k_{\\mathrm{mux}} = 4a$。\n- 失效地址捕获逻辑的总成本为：\n$$\nG_{\\text{fail_cap}} = a \\cdot k_{\\mathrm{dff}} + a \\cdot k_{\\mathrm{mux}} = 20a + 4a = 24a\n$$\n\n$5$. **冗余与修复成本 ($G_{\\text{repair}}$)**\n这包括 $R$ 个行修复条目和 $C$ 个列修复条目。\n- **行修复**：$R$ 个条目中的每一个都包含一个用于存储错误地址的 $a$ 位寄存器和一个 $a$ 位相等比较器。\n  - $a$ 位存储寄存器的成本为 $a \\cdot k_{\\mathrm{dff}} = 20a$。\n  - $a$ 位相等比较器使用 $a$ 个异或非门和一个有 $a-1$ 个门的与门归约树。其成本为 $a \\cdot k_{\\mathrm{xnor}} + (a-1) \\cdot k_{\\land} = 4a + 2(a-1) = 6a - 2$。\n  - 每个行修复条目的成本是 $20a + (6a - 2) = 26a - 2$。\n  - 行修复的总成本是 $G_{\\text{row}} = R \\cdot (26a - 2)$。\n- **列修复**：$C$ 个条目中的每一个都包含一个 $w$ 位寄存器和一个 $w$ 位相等比较器。\n  - $w$ 位存储寄存器的成本为 $w \\cdot k_{\\mathrm{dff}} = 20w$。\n  - $w$ 位相等比较器的成本为 $w \\cdot k_{\\mathrm{xnor}} + (w-1) \\cdot k_{\\land} = 4w + 2(w-1) = 6w - 2$。\n  - 每个列修复条目的成本是 $20w + (6w - 2) = 26w - 2$。\n  - 列修复的总成本是 $G_{\\text{col}} = C \\cdot (26w - 2)$。\n- 冗余与修复的总成本为：\n$$\nG_{\\text{repair}} = G_{\\text{row}} + G_{\\text{col}} = R(26a - 2) + C(26w - 2)\n$$\n\n**总门数 ($G_{\\text{total}}$)**\n我们将所有组件的成本相加：\n$$\nG_{\\text{total}} = G_{\\text{addr_gen}} + G_{\\text{data_gen}} + G_{\\text{comp}} + G_{\\text{fail_cap}} + G_{\\text{repair}}\n$$\n$$\nG_{\\text{total}} = (26a - 5) + (24b + 4) + (6b - 2) + (24a) + (R(26a - 2) + C(26w - 2))\n$$\n按变量分组各项：\n$$\nG_{\\text{total}} = (26a + 24a) + (24b + 6b) + (-5 + 4 - 2) + R(26a - 2) + C(26w - 2)\n$$\n$$\nG_{\\text{total}} = 50a + 30b - 3 + R(26a - 2) + C(26w - 2)\n$$\n最后，我们代入 $a = \\lceil \\log_{2}(n) \\rceil$ 和 $w = \\lceil \\log_{2}(b) \\rceil$，将总门数表示为 $n$、$b$、$R$ 和 $C$ 的函数。\n$$\nG_{\\text{total}} = 50 \\lceil \\log_{2}(n) \\rceil + 30b - 3 + R(26 \\lceil \\log_{2}(n) \\rceil - 2) + C(26 \\lceil \\log_{2}(b) \\rceil - 2)\n$$\n这就是总估算门数的单一、简化的封闭形式表达式。",
            "answer": "$$\n\\boxed{50 \\lceil \\log_{2}(n) \\rceil + 30b - 3 + R(26 \\lceil \\log_{2}(n) \\rceil - 2) + C(26 \\lceil \\log_{2}(b) \\rceil - 2)}\n$$"
        },
        {
            "introduction": "当测试识别出故障后，系统的“大脑”——内置冗余分析（BIRA）单元——必须做出最优的修复决策。这个高级练习要求您将此决策过程建模为一个形式化的约束满足问题，这是一种在众多工程领域中广泛应用的强大技术。您将构建并解决一个修复分配问题，该问题需要在有限的冗余资源和特定修复类型的优先级之间进行权衡，从而揭示自动化自修复背后的算法智能。",
            "id": "4282099",
            "problem": "考虑一个随机存取存储器阵列，该阵列经过存储器内建自测试（MBIST）处理。MBIST报告了一组有限的故障单元坐标，并调用内建自修复（BISR）功能，使用备用行和备用列进行修复。行修复会替换所选物理字线中的所有单元，而列修复会替换所选位线中的所有单元。假设每条备用行仅针对一条物理行，每条备用列仅针对一条物理列，并且被修复的行或列会覆盖其上的所有故障。您需要构建一个约束满足模型，该模型能够处理多故障、多备用资源的分配问题，并体现出行修复优先于列修复的严格偏好。然后，求解一个具体实例以验证其正确性和最优性。\n\n从以下基本定义出发：坐标为 $(i,j)$ 的故障，当其所在的行 $i$ 或列 $j$ 被修复时，该故障即被修复；备用容量限制了可修复的行和列的数量；字典序偏好可以通过一个具有足够大权重的加权目标函数来强制执行。设决策变量为表示是否修复某行或某列的二元指示变量。请精确地陈述所有约束条件和目标函数。\n\n然后，求解以下实例。该存储器的物理行索引集为 $R=\\{1,2,3,4,5,6\\}$，列索引集为 $C=\\{1,2,3,4,5,6\\}$。MBIST报告的故障集为\n$$\nF=\\{(1,2),(1,5),(2,5),(3,1),(3,5),(5,3)\\}.\n$$\n最多有 $S_r=2$ 条备用行和 $S_c=2$ 条备用列可用。为体现对行修复的偏好，请使用加权和作为目标函数，其中列修复数量的权重为 $M=100$，行修复数量的权重为单位权重（1）。请证明对于此实例，所选的 $M$ 值能够强制执行在最小化行修复数量之前优先最小化列修复数量的严格偏好。\n\n计算您构建的模型在给定实例上的最优目标值。最终答案以精确整数形式表示（无单位）。如果多种分配方案达到相同的最小目标值，您无需报告分配方案，只需报告目标值。",
            "solution": "该问题可以被构建为一个整数线性规划（ILP）模型。设 $R_{all}$ 和 $C_{all}$ 分别为存储器阵列中所有物理行和物理列的索引集。设 $F$ 为故障单元的坐标 $(i, j)$ 集合，其中 $i \\in R_{all}$ 且 $j \\in C_{all}$。\n\n我们定义两组二元决策变量：\n- 对于每一行 $i \\in R_{all}$，$r_i \\in \\{0, 1\\}$。如果使用备用行修复行 $i$，则 $r_i = 1$，否则 $r_i = 0$。\n- 对于每一列 $j \\in C_{all}$，$c_j \\in \\{0, 1\\}$。如果使用备用列修复列 $j$，则 $c_j = 1$，否则 $c_j = 0$。\n\n该问题受以下约束条件制约：\n1.  **故障覆盖**：每个报告的故障都必须被修复。位于 $(i, j) \\in F$ 的故障，当其所在的行 $i$ 或列 $j$ 被修复时，该故障即被修复。这可以转化为针对每个故障的约束条件：\n    $$r_i + c_j \\ge 1 \\quad \\forall (i, j) \\in F$$\n2.  **备用行容量**：修复的总行数不能超过可用的备用行数 $S_r$。\n    $$\\sum_{i \\in R_{all}} r_i \\le S_r$$\n3.  **备用列容量**：修复的总列数不能超过可用的备用列数 $S_c$。\n    $$\\sum_{j \\in C_{all}} c_j \\le S_c$$\n\n目标是找到一个满足这些约束条件的修复分配方案，同时遵循行修复优先于列修复的严格偏好。这是一个字典序优化问题，我们旨在最小化修复次数对 $(N_c, N_r)$，其中 $N_c = \\sum c_j$ 是列修复次数，$N_r = \\sum r_i$ 是行修复次数。这可以通过最小化一个加权和目标函数 $Z$ 来实现：\n$$\\text{最小化} \\quad Z = \\sum_{i \\in R_{all}} r_i + M \\sum_{j \\in C_{all}} c_j$$\n其中 $M$ 是一个足够大的权重。\n\n为确保最小化 $Z$ 等价于字典序最小化 $(N_c, N_r)$，所选的 $M$ 值必须使得 $N_c$ 的变化对 $Z$ 的影响大于 $N_r$ 的任何可能变化。考虑两个可行解 $A$ 和 $B$，其修复次数分别为 $(N_{r,A}, N_{c,A})$ 和 $(N_{r,B}, N_{c,B})$。如果我们因为 $N_{c,A} < N_{c,B}$ 而偏好解 $A$，则需要满足 $Z_A < Z_B$。\n$$Z_B - Z_A = (N_{r,B} - N_{r,A}) + M(N_{c,B} - N_{c,A}) > 0$$\n由于 $N_{c,B} - N_{c,A} \\ge 1$（因为它们是整数），该不等式变为 $M(N_{c,B} - N_{c,A}) > N_{r,A} - N_{r,B}$。差值 $N_{r,A} - N_{r,B}$ 的最大可能值受 $N_r$ 的最大可能值限制，即备用行的总数 $S_r$。因此，强制执行严格偏好的一个充分条件是 $M > S_r$。在给定问题中，$S_r=2$。所选权重 $M=100$ 满足 $100 > 2$，因此能够正确地强制执行字典序偏好。\n\n现在，我们求解这个具体实例：\n- 行索引：$R=\\{1,2,3,4,5,6\\}$\n- 列索引：$C=\\{1,2,3,4,5,6\\}$\n- 故障集：$F=\\{(1,2),(1,5),(2,5),(3,1),(3,5),(5,3)\\}$\n- 备用容量：$S_r=2$, $S_c=2$\n- 目标：最小化 $Z = \\sum r_i + 100 \\sum c_j$\n\n我们首先寻找使列修复次数 $N_c$ 最小化的解。\n\n**情况1：$N_c = 0$**\n如果不修复任何列，所有6个故障必须由至多 $S_r=2$ 次行修复来覆盖。这些故障分布在第1、2、3、5行。我们来分析行修复的覆盖情况：\n- $r_1=1$ 覆盖故障 $\\{(1,2), (1,5)\\}$\n- $r_2=1$ 覆盖故障 $\\{(2,5)\\}$\n- $r_3=1$ 覆盖故障 $\\{(3,1), (3,5)\\}$\n- $r_5=1$ 覆盖故障 $\\{(5,3)\\}$\n要覆盖所有故障，我们需要覆盖第1、2、3、5行中的故障。最佳的两行组合是 $\\{r_1, r_3\\}$，它覆盖了 $\\{(1,2), (1,5), (3,1), (3,5)\\}$。故障 $\\{(2,5), (5,3)\\}$ 仍未被覆盖。没有任何2行的组合能够覆盖所有6个故障。因此，当 $N_c=0$ 时不存在可行解。\n\n**情况2：$N_c = 1$**\n我们使用一根备用列。为最大化效益，我们应修复故障最多的列，即第5列。\n- 设 $c_5=1$。这覆盖了故障 $\\{(1,5), (2,5), (3,5)\\}$。\n- 剩余需要覆盖的故障为 $F' = \\{(1,2), (3,1), (5,3)\\}$。\n- 这些故障分布在不同的行（第1、3、5行）和不同的列（第2、1、3列）。要通过行修复来覆盖它们，我们需要设置 $r_1=1$，$r_3=1$ 和 $r_5=1$。这需要 $N_r=3$ 次行修复。然而，我们只有 $S_r=2$。因此，这种方法不可行。其他单列修复的选择效果更差，因为它们每个只能覆盖一个故障。因此，当 $N_c=1$ 时不存在可行解。\n\n**情况3：$N_c = 2$**\n由于 $N_c < 2$ 的解都不可行，因此最小列修复次数必须为 $N_c=2$（前提是存在解）。我们的列修复预算为 $S_c=2$，因此这是可能的。我们现在的目标是找到一个 $N_c=2$ 且使用最少行修复次数 $N_r$ 的解。我们的行修复预算为 $S_r=2$。\n\n我们来考察两列修复的组合：\n- 选择修复第2列和第5列，即 $c_2=1, c_5=1$。\n- 这些修复覆盖了故障 $\\{(1,2)\\}$ 和 $\\{(1,5), (2,5), (3,5)\\}$。\n- 被覆盖的故障集为 $\\{(1,2), (1,5), (2,5), (3,5)\\}$。\n- 剩余的故障为 $F' = \\{(3,1), (5,3)\\}$。\n- 为覆盖这些剩余故障，我们必须修复第3行（针对 $(3,1)$）和第5行（针对 $(5,3)$）。\n- 这需要设置 $r_3=1$ 和 $r_5=1$，意味着 $N_r=2$。\n- 这是一个可行的分配方案：$N_c = 2$ 且 $N_r = 2$。两者都在备用资源预算之内（$S_c=2, S_r=2$）。\n\n我们找到了一个有效的解向量 $(N_c, N_r)=(2,2)$。我们必须验证不存在 $N_c=2$ 且 $N_r < 2$ 的解。\n- 如果 $N_r=1$：我们尝试修复一行和两列。例如，如果我们修复第3行（$r_3=1$），则覆盖了 $\\{(3,1), (3,5)\\}$。剩余的故障是 $\\{(1,2), (1,5), (2,5), (5,3)\\}$。这些故障分布在第2、5、3列。要覆盖它们，将需要三次列修复（$c_2, c_5, c_3$），但我们只有 $S_c=2$。此分析以及对其他单行选择的类似分析证实，不存在 $N_r=1, N_c=2$ 的解。\n- 如果 $N_r=0$：我们必须用2次列修复覆盖所有6个故障。这些故障分布在第1、2、3、5列。选择最好的两列，$c_5$ 和任何其他一列，是不够的。例如，$\\{c_1, c_5\\}$ 覆盖了 $\\{(1,5),(2,5),(3,5),(3,1)\\}$，但留下了 $\\{(1,2), (5,3)\\}$ 未被覆盖。没有任何一对列可以覆盖所有故障。\n\n因此，字典序最小解为 $(N_c, N_r) = (2, 2)$。\n\n最优目标值由这些值计算得出：\n$$Z_{opt} = N_r + M \\times N_c = 2 + 100 \\times 2 = 2 + 200 = 202$$\n存在其他有效的修复分配方案（例如，$\\{r_1, r_5, c_1, c_5\\}$ 或 $\\{r_1, r_3, c_3, c_5\\}$），但它们都导致 $N_r=2, N_c=2$，从而得到相同的最优目标值。",
            "answer": "$$\\boxed{202}$$"
        }
    ]
}