{
    "hands_on_practices": [
        {
            "introduction": "要有效地修复存储器，我们首先必须有一种稳健的方法来检测故障。本练习将深入探讨存储器内建自测试（BIST）的操作核心，通过分析经典的 March C- 算法。通过系统地计算读写操作的数量，您将把一个抽象的测试序列转化为测试时间的具体度量，这是生产测试中的一个关键参数。",
            "id": "4282093",
            "problem": "一个同步内建自测试 (BIST) 在一个具有$n$个字地址和$b$位字宽的单端口静态随机存取存储器 (SRAM) 上运行。该 BIST 采用经典的 March C-minus (March C$^{-}$) 算法。在 March 测试中，每个 March 元素按照指定的地址顺序，对每个地址执行一个固定的读写操作序列。假设 March C$^{-}$ 的定义如下，其中箭头表示地址遍历顺序，每个括号内的列表指定了对每个地址的操作序列：\n- $\\Uparrow(w0)$：按升序扫描地址，并在每个地址上写入字值 $0$。\n- $\\Uparrow(r0, w1)$：按升序扫描，并在每个地址上读取字并期望值为 $0$，然后写入 $1$。\n- $\\Uparrow(r1, w0)$：按升序扫描，并在每个地址上读取 $1$，然后写入 $0$。\n- $\\Downarrow(r0, w1)$：按降序扫描，并在每个地址上读取 $0$，然后写入 $1$。\n- $\\Downarrow(r1, w0)$：按降序扫描，并在每个地址上读取 $1$，然后写入 $0$。\n- $\\Uparrow(r0)$：按升序扫描，并在每个地址上读取 $0$。\n\n假设一个单端口存储器接口，其中每个字级的读或写操作恰好消耗 $1$ 个时钟周期，并且 BIST 以测试时钟频率 $f$ (单位为赫兹) 运行。一个读周期获取整个 $b$ 位字，一个写周期写入整个 $b$ 位字。\n\n从这些定义出发，并且不使用任何预先记忆的复杂度结果，推导出：\n- 在整个 March C$^{-}$ 序列中执行的字级读操作和字级写操作的总数，表示为 $n$ 的函数。\n- 位级操作（位级读操作和位级写操作之和）的总数，表示为 $n$ 和 $b$ 的函数。\n- BIST 测试总时间 $T$ (以秒为单位)，以 $T = \\frac{O(n)}{f}$ 的形式表示，并明确指出每个 March 元素贡献的常数。\n\n请将最终答案表示为仅包含 $n$ 和 $f$ 的单个封闭形式表达式。最终答案中不要包含单位。",
            "solution": "我们从 March 测试和同步单端口存储器访问时序的核心定义开始：\n\n1. 一个 March 元素在每次遍历中，以升序或降序对每个地址施加一次固定的读写操作序列。对于一个有 $n$ 个地址的存储器，单次遍历会访问 $n$ 个地址。\n\n2. 在单端口同步存储器接口中，读取一个字消耗 $1$ 个时钟周期，写入一个字也消耗 $1$ 个时钟周期。读和写不能在同一个周期内发生。因此，对每个地址的包含 $k$ 个操作的序列，每个地址消耗 $k$ 个周期，即每次对 $n$ 个地址的完整遍历消耗 $k n$ 个周期。\n\n3. 每个字级读操作并行返回 $b$ 位，每个字级写操作并行施加 $b$ 位。因此，位级操作的总数等于字级操作的总数乘以 $b$。\n\n我们接下来列举 March C$^{-}$ 元素及其对每个地址的操作数：\n\n- 元素 $\\Uparrow(w0)$：对每个地址，操作序列是单次写入值 $0$。这贡献了每个地址 $1$ 个字级操作，因此该元素总共有 $1 \\cdot n$ 个字级操作。其中，读操作为 $0 \\cdot n$ 个，写操作为 $1 \\cdot n$ 个。\n\n- 元素 $\\Uparrow(r0, w1)$：对每个地址，操作序列是读取期望值 $0$，然后写入 $1$。这贡献了每个地址 $2$ 个字级操作，因此该元素总共有 $2 \\cdot n$ 个操作，包括 $1 \\cdot n$ 次读和 $1 \\cdot n$ 次写。\n\n- 元素 $\\Uparrow(r1, w0)$：类似地贡献 $2 \\cdot n$ 个字级操作，包括 $1 \\cdot n$ 次读和 $1 \\cdot n$ 次写。\n\n- 元素 $\\Downarrow(r0, w1)$：贡献 $2 \\cdot n$ 个字级操作，包括 $1 \\cdot n$ 次读和 $1 \\cdot n$ 次写。\n\n- 元素 $\\Downarrow(r1, w0)$：贡献 $2 \\cdot n$ 个字级操作，包括 $1 \\cdot n$ 次读和 $1 \\cdot n$ 次写。\n\n- 元素 $\\Uparrow(r0)$：对每个地址，单次读取期望值 $0$，贡献 $1 \\cdot n$ 个字级操作，全部为读操作。\n\n将所有六个元素相加，得到字级读和写操作的总数：\n\n- 总读操作数：来自元素 $\\Uparrow(r0,w1)$, $\\Uparrow(r1,w0)$, $\\Downarrow(r0,w1)$, $\\Downarrow(r1,w0)$ 和 $\\Uparrow(r0)$，每个贡献 $1 \\cdot n$ 次读操作，我们得到\n$$\nn + n + n + n + n \\;=\\; 5 n.\n$$\n\n- 总写操作数：来自元素 $\\Uparrow(w0)$, $\\Uparrow(r0,w1)$, $\\Uparrow(r1,w0)$, $\\Downarrow(r0,w1)$ 和 $\\Downarrow(r1,w0)$，每个贡献 $1 \\cdot n$ 次写操作，我们得到\n$$\nn + n + n + n + n \\;=\\; 5 n.\n$$\n\n因此，在整个 March C$^{-}$ 期间，字级存储器访问（读加写）的总数为\n$$\n5 n + 5 n \\;=\\; 10 n.\n$$\n\n根据宽度为 $b$ 位的并行字接口，每个字级访问对应于 $b$ 个位级操作。因此，位级操作的总数为\n$$\n(10 n) \\cdot b \\;=\\; 10 n b.\n$$\n\n对于测试时间，在每个周期进行一次字级访问且频率为 $f$ 的情况下，总周期数等于总字级访问次数。因此，\n$$\nT \\;=\\; \\frac{\\text{总周期数}}{f} \\;=\\; \\frac{10 n}{f}.\n$$\n\n为了展示每个 March 元素对 $T$ 贡献的显式常数，注意到每个元素的周期贡献分别为 $1 \\cdot n$、$2 \\cdot n$、$2 \\cdot n$、$2 \\cdot n$、$2 \\cdot n$ 和 $1 \\cdot n$，总和为 $(1+2+2+2+2+1) n = 10 n$。因此，\n$$\nT \\;=\\; \\frac{(1+2+2+2+2+1)\\,n}{f} \\;=\\; \\frac{10 n}{f}.\n$$\n\n当 $f$ 的单位是赫兹时，这个表达式的单位是秒。",
            "answer": "$$\\boxed{\\frac{10 n}{f}}$$"
        },
        {
            "introduction": "引入备用行和备用列为提高良率提供了一种强大的机制，但这种方法的理论极限是什么？本实践将引导您量化在给定数量的冗余资源下的最大可能修复覆盖范围。通过应用容斥原理，您将推导出最佳情况下的修复能力，并深入了解缺陷聚集情况如何影响修复效率。",
            "id": "4282064",
            "problem": "一个静态随机存取存储器宏单元被组织成一个具有 $M$ 条字线（行）和 $N$ 条位线（列）的矩形位单元阵列。该设计通过 $R$ 个备用行和 $C$ 个备用列来实现冗余。内建自测试 (BIST) 识别单位点缺陷，而内建冗余分析 (BIRA) 在遵循以下实现约束的条件下，执行备用资源的优化分配：当一个备用行（或备用列）被分配给一个故障行（或故障列）时，它会替换整个行（或整个列），从而屏蔽该线上的所有缺陷。假设重映射资源是理想的，因此最多可以替换 $R$ 个不同的行和 $C$ 个不同的列而不会产生地址冲突，并假设备用线是不可区分的，可以针对任意受害线。\n\n从集合计数的首要原则出发，不使用任何预先推导的冗余覆盖公式，推导一个关于 $M$、$N$、$R$ 和 $C$ 的闭式表达式，该表达式表示在缺陷最佳空间排列和最多使用 $R$ 个备用行与 $C$ 个备用列的最佳 BIRA 分配下，可以被变得不可观察（即被覆盖）的单位点缺陷的理论最大数量。您的最终表达式必须只计算可以被覆盖的不同缺陷单元，并且必须考虑到被覆盖行和列之间的任何重叠。\n\n简要论证为何此表达式既是一个上界，又可以通过特定的缺陷排列和相应的备用资源分配来实现。此外，定性解释（无需计算）在相同的 $(R,C)$ 资源下，高度聚集与高度分散的缺陷模式如何影响可被修复的缺陷数量。\n\n以 $M$、$N$、$R$ 和 $C$ 的单个闭式表达式形式提供您的最终结果。不需要单位。不要进行四舍五入。",
            "solution": "问题陈述经评估有效。其科学基础在于集成电路设计与测试的原理，特别是存储器冗余与修复。该问题是适定的、客观的，并包含足够的信息来推导所要求的表达式。它代表了一个用于确定理论最大修复覆盖率的标准的、尽管是理想化的组合问题。我们假设备用资源的数量不超过原始线路的数量，即 $R \\le M$ 和 $C \\le N$。\n\n目标是找到通过分配最多 $R$ 个备用行和 $C$ 个备用列可以覆盖的单位点缺陷的理论最大数量。为实现最大可能的覆盖，我们必须利用所有可用的备用资源，即替换恰好 $R$ 个行和 $C$ 个列。问题于是简化为计算包含在任意 $R$ 行和 $C$ 列集合中的唯一单元的总数。一种最佳情况的缺陷空间排列将涉及在每个可被修复的单元中放置一个缺陷，从而使得可覆盖的缺陷数量等于修复区域中唯一单元的数量。\n\n我们将从集合计数的首要原则，特别是容斥原理，来推导这个计数。\n\n设存储器阵列为一个由 $(i, j)$ 索引的单元集合，其中行索引 $i$ 的范围从 $1$ 到 $M$，列索引 $j$ 的范围从 $1$ 到 $N$。我们选择 $R$ 个特定的行和 $C$ 个特定的列进行替换。由于阵列的对称性，具体选择哪些行和列并不会改变被覆盖单元的总数。\n\n设 $\\mathcal{A}$ 为所选 $R$ 行中包含的所有单元的集合。由于 $R$ 行中的每一行都包含 $N$ 个单元（每列一个），因此该集合中的单元总数为：\n$$|\\mathcal{A}| = R \\times N$$\n\n设 $\\mathcal{B}$ 为所选 $C$ 列中包含的所有单元的集合。由于 $C$ 列中的每一列都包含 $M$ 个单元（每行一个），因此该集合中的单元总数为：\n$$|\\mathcal{B}| = C \\times M$$\n\n修复所覆盖的单元总集合是这两个集合的并集 $\\mathcal{A} \\cup \\mathcal{B}$。如果我们简单地将这两个集合的大小相加，$|\\mathcal{A}| + |\\mathcal{B}|$，我们就会重复计算那些既属于所选行又属于所选列的单元。这些单元位于所选行和所选列的交集处。\n\n这种重叠单元的集合是这两个集合的交集 $\\mathcal{A} \\cap \\mathcal{B}$。这个交集形成一个矩形子网格，其中单元的行索引是 $R$ 个所选行之一，列索引是 $C$ 个所选列之一。因此，这个交集中的单元数量为：\n$$|\\mathcal{A} \\cap \\mathcal{B}| = R \\times C$$\n\n根据两个集合的容斥原理，它们的并集的大小由以下公式给出：\n$$|\\mathcal{A} \\cup \\mathcal{B}| = |\\mathcal{A}| + |\\mathcal{B}| - |\\mathcal{A} \\cap \\mathcal{B}|$$\n\n将这些集合大小的表达式代入，我们得到被覆盖的唯一单元总数的表达式：\n$$|\\mathcal{A} \\cup \\mathcal{B}| = (R \\times N) + (C \\times M) - (R \\times C)$$\n\n这个表达式代表了可以被覆盖的单位点缺陷的理论最大数量。\n\n论证：\n此表达式是一个上界，因为没有任何修复分配可以覆盖比所选 $R$ 行和 $C$ 列内的唯一单元总数更多的单元。该公式正确地计算了这个并集中的每一个唯一单元。该表达式也是可实现的。考虑一种缺陷排列，其中在每个满足 $1 \\le i \\le R$ 或 $1 \\le j \\le C$ 的单元 $(i, j)$ 处放置一个缺陷。此类缺陷的总数恰好是 $R \\times N + C \\times M - R \\times C$。通过将 $R$ 个备用行分配给阵列的前 $R$ 行，并将 $C$ 个备用列分配给前 $C$ 列，所有这些缺陷都被成功覆盖。这表明存在一种缺陷布局和相应的最佳修复分配，能够修复这个最大数量的缺陷。\n\n缺陷模式的定性影响：\n行/列冗余的有效性高度依赖于缺陷的空间分布。\n对于高度聚集的缺陷，修复方案非常高效。例如，如果许多缺陷集中在单一行上，一个备用行就可以修复所有这些缺陷。上述的最佳情况，即所有缺陷都完美地落在由 $R$ 行和 $C$ 列形成的网格内，是给定修复资源下的最佳聚集示例。在这种情况下，可以修复大量的缺陷。\n对于高度分散的缺陷，修复方案效率低下。最坏的情况涉及“对角线”分布，其中 $k$ 个缺陷中的每一个都位于唯一的行和唯一的列中。要修复 $k$ 个此类缺陷，理想情况下需要使用 $k$ 个备用行和 $k$ 个备用列（如果可用）。如果只有 $R$ 个行和 $C$ 个列，最多可以修复 $R+C$ 个此类缺陷（例如，使用 $R$ 行修复 $R$ 个缺陷，使用 $C$ 列修复另外 $C$ 个缺陷）。因此，对于相同数量的缺陷和相同的 $(R,C)$ 资源，与聚集模式相比，高度分散的模式导致可修复的缺陷数量要少得多，从而导致良率更低。",
            "answer": "$$\n\\boxed{R N + C M - R C}\n$$"
        },
        {
            "introduction": "当测试识别出多个故障且备用资源有限时，内建冗余分析（BIRA）必须做出最优的分配决策。这个高级练习挑战您将此决策过程建模为一个正式的约束满足问题。您将学习如何构建一个能够强制执行修复优先级的目标函数，从而一窥驱动智能自修复系统的复杂算法。",
            "id": "4282099",
            "problem": "考虑一个随机存取存储器阵列，该阵列经过存储器内置自测试（MBIST）处理。MBIST报告了一组有限的故障单元坐标，并调用内置自修复（BISR）功能，使用备用行和备用列进行修复。行修复替换选定物理字线中的所有单元，列修复替换选定物理位线中的所有单元。假设每个备用行仅针对一个物理行，每个备用列仅针对一个物理列，并且修复后的行或列会覆盖该行或列上的所有故障。您的任务是构建一个约束满足公式，该公式能捕捉多故障、多备用分配问题，并体现出行修复优先于列修复的严格偏好。然后，求解一个具体实例以验证其正确性和最优性。\n\n从以下基本定义出发：坐标 $(i,j)$ 处的故障在其所在的行 $i$ 或列 $j$ 被修复时即被修复；备用容量限制了可修复的行数和列数；字典序偏好可以通过一个带有足够大权重的加权目标函数来强制执行。设决策变量为表示是否修复某行或某列的二元指示变量。请精确陈述所有约束条件和目标函数。\n\n然后，求解以下实例。该存储器的物理行索引集为 $R=\\{1,2,3,4,5,6\\}$，列索引集为 $C=\\{1,2,3,4,5,6\\}$。MBIST报告的故障集为\n$$\nF=\\{(1,2),(1,5),(2,5),(3,1),(3,5),(5,3)\\}.\n$$\n最多有 $S_r=2$ 个备用行和最多 $S_c=2$ 个备用列可用。为体现对行修复的偏好，请使用一个加权和目标函数，其中列修复数量的乘数为 $M=100$，行修复数量的权重为单位权重。请论证对于此实例，所选的 $M$ 值能够强制执行在最小化行修复数量之前先最小化列修复数量的严格偏好。\n\n计算您对给定实例的公式的最优目标值。请以精确整数形式表示您的最终答案（无单位）。如果多个分配方案达到相同的最小目标值，您无需报告分配方案，只需报告目标值即可。",
            "solution": "该问题陈述是集成电路测试与修复领域中一个有效、适定且有科学依据的问题。它描述了一个经典的组合优化问题，通常称为双边覆盖问题，并要求对其进行公式化并求解一个具体实例。所有必要的数据和约束都已提供，不存在内部矛盾或不科学的前提。\n\n该问题可以公式化为一个整数线性规划（ILP）问题。设 $R_{all}$ 和 $C_{all}$ 分别为存储器阵列中所有物理行和列的索引集。设 $F$ 为故障单元的坐标 $(i, j)$ 的集合，其中 $i \\in R_{all}$ 且 $j \\in C_{all}$。\n\n我们定义两组二元决策变量：\n- 对于每行 $i \\in R_{all}$，有 $r_i \\in \\{0, 1\\}$。如果行 $i$ 使用备用行进行修复，则 $r_i = 1$，否则 $r_i = 0$。\n- 对于每列 $j \\in C_{all}$，有 $c_j \\in \\{0, 1\\}$。如果列 $j$ 使用备用列进行修复，则 $c_j = 1$，否则 $c_j = 0$。\n\n该问题受以下约束条件控制：\n1.  **故障覆盖：** 每个报告的故障都必须被修复。位于 $(i, j) \\in F$ 的故障在其所在的行 $i$ 或列 $j$ 被修复时即被修复。这可以转化为针对每个故障的约束：\n    $$r_i + c_j \\ge 1 \\quad \\forall (i, j) \\in F$$\n2.  **备用行容量：** 修复的总行数不能超过可用的备用行数 $S_r$。\n    $$\\sum_{i \\in R_{all}} r_i \\le S_r$$\n3.  **备用列容量：** 修复的总列数不能超过可用的备用列数 $S_c$。\n    $$\\sum_{j \\in C_{all}} c_j \\le S_c$$\n\n目标是找到一个满足这些约束的修复分配方案，同时遵循行修复优先于列修复的严格偏好。这是一个字典序优化问题，我们寻求最小化数对 $(N_c, N_r)$，其中 $N_c = \\sum c_j$ 是列修复的数量， $N_r = \\sum r_i$ 是行修复的数量。这可以通过最小化一个加权和目标函数 $Z$ 来实现：\n$$\\text{最小化} \\quad Z = \\sum_{i \\in R_{all}} r_i + M \\sum_{j \\in C_{all}} c_j$$\n其中 $M$ 是一个足够大的权重。\n\n为确保最小化 $Z$ 等同于按字典序最小化 $(N_c, N_r)$，$M$ 的选择必须使得 $N_c$ 的变化对 $Z$ 的影响大于 $N_r$ 的任何可能变化。我们考虑两个可行解 $A$ 和 $B$，其修复数量分别为 $(N_{r,A}, N_{c,A})$ 和 $(N_{r,B}, N_{c,B})$。如果我们因为 $N_{c,A} < N_{c,B}$ 而偏好解 $A$，则需要 $Z_A < Z_B$。\n$$Z_B - Z_A = (N_{r,B} - N_{r,A}) + M(N_{c,B} - N_{c,A}) > 0$$\n由于 $N_{c,B} - N_{c,A} \\ge 1$（因为它们是整数），该不等式变为 $M(N_{c,B} - N_{c,A}) > N_{r,A} - N_{r,B}$。差值 $N_{r,A} - N_{r,B}$ 的最大可能值受 $N_r$ 的最大可能值限制，即为可用备用行的总数 $S_r$。因此，强制执行严格偏好的一个充分条件是 $M > S_r$。在给定问题中，$S_r=2$。选择的权重 $M=100$ 满足 $100 > 2$，因此正确地强制执行了字典序偏好。\n\n现在，我们求解这个具体实例：\n- 行索引：$R=\\{1,2,3,4,5,6\\}$\n- 列索引：$C=\\{1,2,3,4,5,6\\}$\n- 故障集：$F=\\{(1,2),(1,5),(2,5),(3,1),(3,5),(5,3)\\}$\n- 备用容量：$S_r=2$, $S_c=2$\n- 目标函数：最小化 $Z = \\sum r_i + 100 \\sum c_j$\n\n我们首先寻求一个能最小化列修复数量 $N_c$ 的解。\n\n**情况1：$N_c = 0$**\n如果没有列被修复，则所有 6 个故障必须由至多 $S_r=2$ 次行修复来覆盖。这些故障位于第 1、2、3 和 5 行。我们来检查行修复的覆盖情况：\n- $r_1=1$ 覆盖故障 $\\{(1,2), (1,5)\\}$\n- $r_2=1$ 覆盖故障 $\\{(2,5)\\}$\n- $r_3=1$ 覆盖故障 $\\{(3,1), (3,5)\\}$\n- $r_5=1$ 覆盖故障 $\\{(5,3)\\}$\n为覆盖所有故障，我们需要覆盖第 1、2、3 和 5 行中的故障。最好的两行组合是 $\\{r_1, r_3\\}$，它覆盖了 $\\{(1,2), (1,5), (3,1), (3,5)\\}$。故障 $\\{(2,5), (5,3)\\}$ 仍然未被覆盖。没有任何两行的组合能够覆盖所有 6 个故障。因此，对于 $N_c=0$ 不存在可行解。\n\n**情况2：$N_c = 1$**\n我们使用一个备用列。为了最大化效益，我们应该修复故障最多的列，即第 5 列。\n- 设 $c_5=1$。这覆盖了故障 $\\{(1,5), (2,5), (3,5)\\}$。\n- 剩余需要覆盖的故障是 $F' = \\{(1,2), (3,1), (5,3)\\}$。\n- 这些故障位于不同的行（1、3 和 5）和不同的列（2、1 和 3）。要用行修复来覆盖它们，我们需要设置 $r_1=1$，$r_3=1$ 和 $r_5=1$。这需要 $N_r=3$ 次行修复。然而，我们只有 $S_r=2$。因此，这种方法是不可行的。选择修复其他单个列的效果更差，因为它们每个只能覆盖一个故障。因此，对于 $N_c=1$ 不存在可行解。\n\n**情况3：$N_c = 2$**\n由于 $N_c < 2$ 的解都不可行，只要存在解，最小列修复数必须为 $N_c=2$。我们的备用列预算为 $S_c=2$，所以这是可能的。我们现在的目标是找到一个 $N_c=2$ 且使用最少行修复数 $N_r$ 的解。我们的行修复预算为 $S_r=2$。\n\n让我们检查两列修复的组合：\n- 选择修复第 2 列和第 5 列。即 $c_2=1, c_5=1$。\n- 这些修复覆盖了故障 $\\{(1,2)\\}$ 和 $\\{(1,5), (2,5), (3,5)\\}$。\n- 已覆盖的故障集为 $\\{(1,2), (1,5), (2,5), (3,5)\\}$。\n- 剩余的故障是 $F' = \\{(3,1), (5,3)\\}$。\n- 为了覆盖这些剩余的故障，我们必须修复第 3 行（针对 $(3,1)$）和第 5 行（针对 $(5,3)$）。\n- 这需要设置 $r_3=1$ 和 $r_5=1$，这意味着 $N_r=2$。\n- 这是一个可行的分配：$N_c = 2$ 且 $N_r = 2$。两者都在备用预算（$S_c=2, S_r=2$）之内。\n\n我们找到了一个有效的解向量 $(N_c, N_r)=(2,2)$。我们必须验证不存在 $N_c=2$ 且 $N_r < 2$ 的解。\n- 如果 $N_r=1$：我们尝试修复一行和两列。例如，如果我们修复第 3 行（$r_3=1$），我们覆盖了 $\\{(3,1), (3,5)\\}$。剩余的故障是 $\\{(1,2), (1,5), (2,5), (5,3)\\}$。这些故障位于第 2、5、3 列。要覆盖它们，我们需要三次列修复（$c_2, c_5, c_3$），但我们只有 $S_c=2$。这个例子以及对其他单行选择的类似分析证实，不存在 $N_r=1, N_c=2$ 的解。\n- 如果 $N_r=0$：我们必须用 2 次列修复覆盖所有 6 个故障。这些故障位于第 1、2、3、5 列。选择最好的两列，$c_5$ 和任何其他一列，是不够的。例如，$\\{c_1, c_5\\}$ 覆盖了 $\\{(1,5),(2,5),(3,5),(3,1)\\}$，留下 $\\{(1,2), (5,3)\\}$ 未被覆盖。没有任何一对列能覆盖所有故障。\n\n因此，字典序最小解是 $(N_c, N_r) = (2, 2)$。\n\n最优目标值由这些值计算得出：\n$$Z_{opt} = N_r + M \\times N_c = 2 + 100 \\times 2 = 2 + 200 = 202$$\n存在其他有效的修复分配方案（例如 $\\{r_1, r_5, c_1, c_5\\}$ 或 $\\{r_1, r_3, c_3, c_5\\}$），但它们都导致 $N_r=2, N_c=2$，从而得出相同的最优目标值。",
            "answer": "$$\\boxed{202}$$"
        }
    ]
}