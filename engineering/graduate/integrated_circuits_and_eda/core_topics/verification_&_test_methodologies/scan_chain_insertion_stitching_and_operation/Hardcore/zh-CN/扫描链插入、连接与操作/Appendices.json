{
    "hands_on_practices": [
        {
            "introduction": "为了提高芯片的可测试性，在设计中插入扫描逻辑是标准做法，但这并非没有代价。本练习将引导你从根本上理解和量化这种权衡，通过分析将功能触发器替换为扫描触发器后，其对关键路径建立时间裕量（setup slack）的直接影响。这是可测试性设计（DFT）插入流程中必须考虑的首要性能指标。",
            "id": "4295557",
            "problem": "考虑一个采用电子设计自动化 (EDA) 方法设计的集成电路中的同步单周期数据路径，其中包含一个启动寄存器和一个捕获寄存器，两者最初都实现为功能性 D 触发器 (DFF)。时钟周期为 $T$，启动寄存器的时钟到 Q 端的传播延迟为 $t_{\\text{clkq}}$，启动寄存器输出与捕获寄存器输入之间的总组合逻辑传播延迟为 $t_{\\text{pd}}$，捕获寄存器的建立时间要求为 $t_{\\text{setup}}$。从启动寄存器时钟引脚到捕获寄存器时钟引脚的时钟偏斜为 $t_{\\text{skew}}$。假设为单时钟域，无重定时 (retiming)，并忽略芯片内变异 (on-chip variation)、抖动以及任何动态电源噪声效应。所有时序量均针对单一的工艺-电压-温度角 (PVT corner)，并被视为常数。\n\n在一个可测试性设计 (DFT) 插入步骤中，捕获寄存器被一个多路复用 D 型扫描触发器 (muxed-D scan flip-flop) 替换。在此扫描触发器中，功能性 D 输入在到达存储元件之前会经过一个内部的双输入多路复用器。在功能模式下（扫描使能信号无效），该多路复用器会为捕获寄存器输入端的数据路径增加一个额外的延迟 $\\Delta t_{\\text{mux}}$。此外，在扫描触发器内部分配和选通扫描使能信号会给捕获寄存器带来建立时间开销，这被建模为相对于原始功能性 DFF 的建立时间要求增加了 $\\Delta t_{\\text{SE}}$。假设此次替换不改变启动寄存器的特性、时钟分布或 $t_{\\text{skew}}$。\n\n从同步建立时序的第一性原理出发，推导建立时间裕量 (setup slack) 的变化量 $\\Delta S$ 的解析表达式。$\\Delta S$ 定义为替换后的建立时间裕量减去替换前的建立时间裕量，并应表示为 $\\Delta t_{\\text{mux}}$ 和 $\\Delta t_{\\text{SE}}$ 的函数。将您的最终答案表示为一个闭式符号表达式，单位为秒。不要对任何量进行数值计算或近似。",
            "solution": "单时钟域中同步单周期路径的建立时序条件，是基于比较捕获寄存器处的要求到达时间与其 D 输入端的实际数据到达时间。建立时间裕量定义为要求时间与到达时间之差，其中正裕量表示满足建立时间约束。\n\n设启动时钟沿为参考。在原始的、扫描插入前的配置中，数据到达捕获寄存器输入端的时间是启动寄存器的时钟到 Q 端延迟与组合逻辑路径延迟之和：\n$$\nt_{\\text{arr,0}} = t_{\\text{clkq}} + t_{\\text{pd}}.\n$$\n考虑到时钟周期 $T$、时钟偏斜 $t_{\\text{skew}}$（定义为捕获时钟到达时间减去启动时钟到达时间）以及捕获寄存器的建立时间要求 $t_{\\text{setup}}$，捕获寄存器输入端的要求到达时间为：\n$$\nt_{\\text{req,0}} = T + t_{\\text{skew}} - t_{\\text{setup}}.\n$$\n因此，原始的建立时间裕量 $S_{0}$ 为：\n$$\nS_{0} = t_{\\text{req,0}} - t_{\\text{arr,0}} = \\left(T + t_{\\text{skew}} - t_{\\text{setup}}\\right) - \\left(t_{\\text{clkq}} + t_{\\text{pd}}\\right).\n$$\n\n将捕获寄存器替换为多路复用 D 型扫描触发器后，功能性 D 输入在到达存储元件之前，在单元内部会产生一个额外的延迟 $\\Delta t_{\\text{mux}}$。这使得数据到达捕获输入端的时间增加了 $\\Delta t_{\\text{mux}}$，得到：\n$$\nt_{\\text{arr,1}} = t_{\\text{clkq}} + t_{\\text{pd}} + \\Delta t_{\\text{mux}}.\n$$\n扫描使能选通开销使建立时间要求增加了 $\\Delta t_{\\text{SE}}$，因此新的要求时间变为：\n$$\nt_{\\text{req,1}} = T + t_{\\text{skew}} - \\left(t_{\\text{setup}} + \\Delta t_{\\text{SE}}\\right).\n$$\n因此，新的建立时间裕量 $S_{1}$ 为：\n$$\nS_{1} = t_{\\text{req,1}} - t_{\\text{arr,1}} = \\left(T + t_{\\text{skew}} - t_{\\text{setup}} - \\Delta t_{\\text{SE}}\\right) - \\left(t_{\\text{clkq}} + t_{\\text{pd}} + \\Delta t_{\\text{mux}}\\right).\n$$\n\n建立时间裕量的变化量，定义为替换后的裕量减去替换前的裕量，即：\n$$\n\\Delta S = S_{1} - S_{0}.\n$$\n代入 $S_{1}$ 和 $S_{0}$ 的表达式：\n$$\n\\Delta S = \\Big[\\left(T + t_{\\text{skew}} - t_{\\text{setup}} - \\Delta t_{\\text{SE}}\\right) - \\left(t_{\\text{clkq}} + t_{\\text{pd}} + \\Delta t_{\\text{mux}}\\right)\\Big] - \\Big[\\left(T + t_{\\text{skew}} - t_{\\text{setup}}\\right) - \\left(t_{\\text{clkq}} + t_{\\text{pd}}\\right)\\Big].\n$$\n化简，公共项 $T$、$t_{\\text{skew}}$、$t_{\\text{setup}}$、$t_{\\text{clkq}}$ 和 $t_{\\text{pd}}$ 被消去：\n$$\n\\Delta S = -\\Delta t_{\\text{SE}} - \\Delta t_{\\text{mux}}.\n$$\n\n该表达式表明，在启动寄存器、时钟分布和偏斜保持不变的假设下，建立时间裕量减少的量等于功能性 D 路径上的多路复用器延迟与扫描使能选通开销所引起的建立时间增加量之和。",
            "answer": "$$\\boxed{-\\left(\\Delta t_{\\text{mux}}+\\Delta t_{\\text{SE}}\\right)}$$"
        },
        {
            "introduction": "在评估了扫描逻辑对功能模式的影响后，我们将注意力转向测试模式本身。在扫描移位期间，相邻扫描单元之间的数据路径可能因物理位置靠近而非常短，这会带来保持时间（hold time）违例的风险，进而导致数据损坏。本练习将从第一性原理出发，推导保持时间违例发生的精确条件，从而定义在需要插入“锁存单元（lock-up latch）”以增加延迟之前，所允许的最大时钟偏斜。",
            "id": "4295616",
            "problem": "考虑在扫描链的移位模式下，两个连续连接的正边沿触发扫描触发器 (FF) $S_L$ (发射) 和 $S_C$ (捕获)。两者都由相同的扫描时钟网络驱动，但由于时钟树偏斜，它们的时钟到达时间不同。设给定的扫描时钟沿到达 $S_L$ 的时间为 $t_L$，到达 $S_C$ 的时间为 $t_C$，并将（有符号）偏斜定义为 $s \\triangleq t_C - t_L$。$S_L$ 的最小 clock-to-Q 延迟为 $t_{\\mathrm{cq}}^{\\min}$，从 $S_L$ 的 $Q$ 端到 $S_C$ 的 $D$ 端的最小数据路径污染延迟（包括扫描多路复用器和互连线）为 $d_{\\mathrm{path}}^{\\min}$，$S_C$ 的保持时间为 $t_h$。此外，扫描时钟在 $S_L$ 和 $S_C$ 之间存在最坏情况下的相对不确定性（包括抖动和建模不确定性）$u$，其定义为在最坏情况下，相对于发射沿，有效捕获沿的到达时间可能比标称值晚最多 $u$。\n\n仅使用保持时间、clock-to-Q 延迟、污染延迟和时钟偏斜/不确定性的基本时序定义，从第一性原理推导在扫描移位期间保证 $S_C$ 不发生保持时间违例的最大允许正偏斜 $s_{\\max}$ 的解析表达式（即，超过该阈值则需要使用锁存闩锁）。然后，根据以下参数值，数值计算这个 $s_{\\max}$：\n- $t_{\\mathrm{cq}}^{\\min} = 0.037\\ \\mathrm{ns}$，\n- $d_{\\mathrm{path}}^{\\min} = 0.126\\ \\mathrm{ns}$，\n- $t_h = 0.081\\ \\mathrm{ns}$，\n- $u = 0.019\\ \\mathrm{ns}$。\n\n给出 $s_{\\max}$ 的最终数值，四舍五入到四位有效数字。最终结果以纳秒为单位表示。",
            "solution": "目标是找到最大正偏斜 $s_{\\max}$，使得捕获触发器 $S_C$ 不发生保持时间违例。如果从 $S_L$ 发射的新数据在 $S_C$ 当前数据位的保持时间窗口结束之前到达 $S_C$ 的输入端，就会发生保持时间违例。\n\n让我们从第一性原理出发，相对于一个全局时间基准，建立关键事件的时序。\n一个正边沿触发事件在时间 $t_L$ 发生在发射触发器 $S_L$ 上。这导致 $S_L$ 的输出 $Q$ 端的数据发生变化。由于触发器内部的 clock-to-Q 延迟，新数据在最早可能的时间 $t_L + t_{\\mathrm{cq}}^{\\min}$ 出现在输出端 $S_L(Q)$。\n\n这个新的数据信号随后通过 $S_L$ 和 $S_C$ 之间的组合逻辑和互连路径传播。该路径的最早（污染）延迟为 $d_{\\mathrm{path}}^{\\min}$。因此，新数据在最早可能的时间到达捕获触发器 $S_C$ 的数据输入端 $D$，我们将其表示为 $T_{\\mathrm{data\\_arrival}}$：\n$$T_{\\mathrm{data\\_arrival}} = t_L + t_{\\mathrm{cq}}^{\\min} + d_{\\mathrm{path}}^{\\min}$$\n\n在 $S_L$ 处引发发射的同一个时钟沿在时间 $t_C$ 到达捕获触发器 $S_C$。这个时钟沿指示 $S_C$ 捕获其输入端 $S_C(D)$ 上当前存在的数据。$S_C$ 的保持时间要求 $t_h$ 规定，在时钟沿到达*之后*，该数据必须在 $t_h$ 的时间内保持稳定不变。因此，旧数据位的保持窗口在时间 $T_{\\mathrm{hold\\_end}}$ 关闭：\n$$T_{\\mathrm{hold\\_end}} = t_C + t_h$$\n\n为防止保持时间违例，从 $S_L$ 传播的新数据必须在该保持窗口关闭之后才能到达 $S_C(D)$。这施加了以下条件：\n$$T_{\\mathrm{data\\_arrival}} \\ge T_{\\mathrm{hold\\_end}}$$\n代入这些时间的表达式，我们得到基本的保持时间不等式：\n$$t_L + t_{\\mathrm{cq}}^{\\min} + d_{\\mathrm{path}}^{\\min} \\ge t_C + t_h$$\n\n问题将时钟偏斜定义为 $s \\triangleq t_C - t_L$。我们可以重新整理这个不等式，用偏斜 $s$ 来表示它：\n$$t_{\\mathrm{cq}}^{\\min} + d_{\\mathrm{path}}^{\\min} - t_h \\ge t_C - t_L$$\n$$s \\le t_{\\mathrm{cq}}^{\\min} + d_{\\mathrm{path}}^{\\min} - t_h$$\n这个不等式定义了在没有时序不确定性的理想系统中的最大允许偏斜。\n\n现在，我们必须考虑最坏情况下的相对时钟不确定性 $u$。这个项代表了由于抖动和建模不准确性等因素导致的时钟到达时间的不可预测变化。对于一个鲁棒的设计，时序检查即使在存在这些变化的情况下也必须通过。在静态时序分析中，这通常通过要求一个至少与不确定性一样大的正时序裕量来处理。保持检查的裕量是数据到达时间与保持要求时间之间的差值。因此，鲁棒的保持条件是：\n$$(\\text{Slack}) = T_{\\mathrm{data\\_arrival}} - T_{\\mathrm{hold\\_end}} \\ge u$$\n代入事件时间的表达式：\n$$(t_L + t_{\\mathrm{cq}}^{\\min} + d_{\\mathrm{path}}^{\\min}) - (t_C + t_h) \\ge u$$\n这等同于将不确定性 $u$ 作为裕量加到所需时间上：\n$$t_L + t_{\\mathrm{cq}}^{\\min} + d_{\\mathrm{path}}^{\\min} \\ge t_C + t_h + u$$\n\n我们现在可以解这个鲁棒不等式，求出最大允许标称偏斜 $s_{\\max}$。\n$$t_{\\mathrm{cq}}^{\\min} + d_{\\mathrm{path}}^{\\min} - t_h - u \\ge t_C - t_L$$\n$$s \\le t_{\\mathrm{cq}}^{\\min} + d_{\\mathrm{path}}^{\\min} - t_h - u$$\n这给出了最大允许正偏斜的解析表达式：\n$$s_{\\max} = t_{\\mathrm{cq}}^{\\min} + d_{\\mathrm{path}}^{\\min} - t_h - u$$\n任何大于此值的正偏斜都会在扫描移位期间带来保持时间违例的风险，因此需要插入一个延迟元件（如锁存闩锁）来增加数据路径延迟。\n\n最后，我们使用提供的参数值对该表达式进行数值计算：\n-   $t_{\\mathrm{cq}}^{\\min} = 0.037\\ \\mathrm{ns}$\n-   $d_{\\mathrm{path}}^{\\min} = 0.126\\ \\mathrm{ns}$\n-   $t_h = 0.081\\ \\mathrm{ns}$\n-   $u = 0.019\\ \\mathrm{ns}$\n\n$$s_{\\max} = 0.037 + 0.126 - 0.081 - 0.019$$\n$$s_{\\max} = 0.163 - (0.081 + 0.019)$$\n$$s_{\\max} = 0.163 - 0.100$$\n$$s_{\\max} = 0.063\\ \\mathrm{ns}$$\n\n问题要求最终答案四舍五入到四位有效数字。计算出的值恰好是 $0.063$，它有两位有效数字。为了用四位有效数字表示，我们可以将其写为 $0.06300$，或者更明确地，用科学记数法表示。\n$$s_{\\max} = 0.06300\\ \\mathrm{ns} = 6.300 \\times 10^{-2}\\ \\mathrm{ns}$$\n最终答案要求以数值形式给出。",
            "answer": "$$\\boxed{6.300 \\times 10^{-2}}$$"
        },
        {
            "introduction": "在掌握了前述的分析方法后，我们从分析转向综合与优化。逻辑上，扫描链中单元的顺序是任意的，这为我们通过重新排序来优化物理和时序特性提供了机会。本练习将扫描链重排序问题构建为一个计算挑战（旅行商问题的变体），并引入一个成本函数，该函数旨在平衡总线长最小化与规避前一练习中所分析的保持时间风险，这体现了理论分析在高级EDA算法中的实际应用。",
            "id": "4295638",
            "problem": "给定一组放置在二维坐标（以微米表示）上的扫描单元，以及代表扫描输入和扫描输出引脚的两个锚点。任务是重新排序这些扫描单元，以形成从扫描输入锚点到扫描输出锚点的单一扫描链路径，并确保每个扫描单元仅被访问一次。路径成本必须反映线长和保持时间风险之间的平衡。请将此重排序问题建模为扫描单元位置上的旅行商问题 (TSP) 的一个带锚点的开放变体，并实现一个近似求解器，以在线长最小化和保持时间风险降低之间实现合理的权衡。\n\n基本原理：\n- 扫描链是在测试期间由扫描时钟驱动的一系列串行连接的扫描单元。顺序扫描单元之间过短的物理连接会增加保持时间违规的概率，因为在时钟偏斜和可变性的影响下，数据路径延迟可能变得过小，无法满足保持时间要求。相反，过长的连接会增加布线拥塞和转换时间。\n- 旅行商问题 (TSP) 是寻找访问一组点的顺序以最小化边成本之和的问题。TSP 的一个“开放”变体寻求的是一条路径而非回路，且具有指定的端点。\n\n定义：\n- 设扫描输入锚点位于坐标 $\\mathbf{s} = (x_s, y_s)$，扫描输出锚点位于坐标 $\\mathbf{t} = (x_t, y_t)$，单位为微米。\n- 设扫描单元集合为 $\\{\\mathbf{p}_i = (x_i, y_i)\\}_{i=1}^N$，单位也为微米。\n- 对于任意两点 $\\mathbf{u} = (x_u, y_u)$ 和 $\\mathbf{v} = (x_v, y_v)$，定义曼哈顿距离（单位：微米）为 $d(\\mathbf{u}, \\mathbf{v}) = |x_u - x_v| + |y_u - y_v|$。\n- 设每条边的成本定义为 $c(\\mathbf{u}, \\mathbf{v}) = \\alpha \\cdot d(\\mathbf{u}, \\mathbf{v}) + \\beta \\cdot \\max(0, d_h - d(\\mathbf{u}, \\mathbf{v}))$，其中 $d_h$ 是一个保持时间安全的最小线长阈值（单位：微米），$\\alpha$ 和 $\\beta$ 是非负权重。项 $\\beta \\cdot \\max(0, d_h - d)$ 用于惩罚短于 $d_h$ 的连接，以降低保持时间风险。\n\n目标：\n- 找到扫描单元的一个排序 $\\pi$，以最小化总路径成本\n$$\nC(\\pi) = c(\\mathbf{s}, \\mathbf{p}_{\\pi(1)}) + \\sum_{k=1}^{N-1} c(\\mathbf{p}_{\\pi(k)}, \\mathbf{p}_{\\pi(k+1)}) + c(\\mathbf{p}_{\\pi(N)}, \\mathbf{t}).\n$$\n\n近似解要求：\n- 实现一个构造性启发式算法，然后进行局部改进。一种有效的方法是多起点贪婪构造，该方法从扫描输入锚点开始，通过迭代添加能最小化增量边成本的下一个未访问扫描单元来构建路径，然后进行适用于带锚点开放路径的 $2$-opt 局部搜索以降低总成本。$2$-opt 移动会反转一个连续的子路径，并用两条替代边替换两条边，同时保持端点处的锚点不变。\n\n数值与单位要求：\n- 距离和阈值的单位为微米，总成本也必须以微米表示。您的程序必须报告每个总成本（以微米为单位），并四舍五入到三位小数。\n\n测试套件：\n对于每个测试用例，都提供了 $\\mathbf{s}$、$\\mathbf{t}$、扫描单元坐标列表以及参数 $\\alpha$、$\\beta$ 和 $d_h$。\n\n- 测试用例 $1$（理想路径）：\n  - $\\mathbf{s} = (0, 0)$, $\\mathbf{t} = (1000, 0)$\n  - 扫描单元： $[(100, 50), (200, 300), (400, 100), (250, 80), (700, 60), (900, 200), (650, 350), (500, 20)]$\n  - $\\alpha = 1.0$, $\\beta = 3.0$, $d_h = 80$\n- 测试用例 $2$（短边风险强调）：\n  - $\\mathbf{s} = (0, 0)$, $\\mathbf{t} = (500, 500)$\n  - 扫描单元： $[(50, 50), (55, 52), (60, 48), (58, 55), (62, 51), (57, 49)]$\n  - $\\alpha = 1.0$, $\\beta = 10.0$, $d_h = 50$\n- 测试用例 $3$（最小非平凡链）：\n  - $\\mathbf{s} = (0, 0)$, $\\mathbf{t} = (1000, 0)$\n  - 扫描单元： $[(100, 0), (900, 0)]$\n  - $\\alpha = 1.0$, $\\beta = 0.5$, $d_h = 10$\n- 测试用例 $4$（网格布局）：\n  - $\\mathbf{s} = (0, 0)$, $\\mathbf{t} = (400, 400)$\n  - 扫描单元： $[(100, 100), (100, 200), (100, 300), (200, 100), (200, 200), (200, 300), (300, 100), (300, 200), (300, 300)]$\n  - $\\alpha = 1.0, \\beta = 1.0, d_h = 40$\n- 测试用例 $5$（锚点远，单元聚集）：\n  - $\\mathbf{s} = (0, 1000)$, $\\mathbf{t} = (1000, 1000)$\n  - 扫描单元： $[(420, 210), (430, 250), (415, 230), (460, 240), (500, 260), (520, 220), (480, 200)]$\n  - $\\alpha = 1.0, \\beta = 2.0, d_h = 60$\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是一个双元素列表，其第一个元素是总成本（以微米为单位，四舍五入到三位小数），第二个元素是扫描链顺序，表示为扫描单元从零开始的索引的整数列表。例如：\n- $[ [123.456,[0,2,1]], [789.000,[1,0]] ]$。",
            "solution": "### 解决方案设计\n\n寻找最优扫描链顺序的问题被建模为一个带锚点的开放式旅行商问题 (TSP)。需要访问的节点集包括所有扫描单元 $\\{\\mathbf{p}_i\\}_{i=1}^N$，路径从一个固定的起始节点 $\\mathbf{s}$ 开始，到一个固定的终止节点 $\\mathbf{t}$ 结束。总路径长度由边成本之和决定，其中成本函数 $c(\\mathbf{u}, \\mathbf{v})$ 独特地包含了对短连接的惩罚，以缓解保持时间风险。\n\n由于 TSP 是 NP-难问题，除了最小的实例外，找到精确解在计算上是不可行的。因此，我们按照要求采用一种标准而有效的两阶段启发式方法：一个构造性启发式算法生成一个良好的初始解，然后通过迭代式局部搜索对其进行优化。\n\n**阶段 1：贪婪构造启发式算法（最近邻）**\n\n初始路径是贪婪地构造的。该方法是最近邻启发式算法的一个变体，它一次构建一个扫描单元的扫描链。\n$1$. 路径从扫描输入锚点 $\\mathbf{s}$ 开始。\n$2$. 从链中最后添加的点（初始为 $\\mathbf{s}$）出发，我们选择具有最小边成本 $c(\\cdot, \\cdot)$ 的未访问扫描单元进行连接。\n$3$. 这个“最近”的单元被附加到链上，重复此过程，直到所有 $N$ 个扫描单元都被访问。\n$4$. 最后，链中的最后一个扫描单元连接到扫描输出锚点 $\\mathbf{t}$，完成路径。\n\n这种贪婪策略倾向于生成一个相当短的路径，为后续的优化阶段提供了一个高质量的起点。对于这个带锚点的问题，确定性的最近邻构造是对“贪婪构造”要求的一个稳健的解释。\n\n**阶段 2：迭代改进（2-Opt 局部搜索）**\n\n2-opt 算法是一种用于改进 TSP 解的强大局部搜索启发式算法。它的工作原理是通过系统地交换边对来查看是否可以形成更短的路径。对于一个带锚点的路径 `(v_0, v_1, ..., v_N, v_{N+1})`，其中 $v_0=\\mathbf{s}$ 且 $v_{N+1}=\\mathbf{t}$，2-opt 移动的调整如下：\n$1$. 选择一个连续的扫描单元子路径 $(v_i, v_{i+1}, ..., v_j)$，其中 $1 \\le i  j \\le N$。该子路径通过边 $(v_{i-1}, v_i)$ 和 $(v_j, v_{j+1})$ 连接到路径的其余部分。\n$2$. 反转子路径的顺序以得到 $(v_j, v_{j-1}, ..., v_i)$。\n$3$. 通过形成新的边 $(v_{i-1}, v_j)$ 和 $(v_i, v_{j+1})$ 来重新连接路径。这就构成了一个 2-opt 移动。\n$4$. 计算总成本的变化：\n$$\n\\Delta C = \\left[ c(v_{i-1}, v_j) + c(v_i, v_{j+1}) \\right] - \\left[ c(v_{i-1}, v_i) + c(v_j, v_{j+1}) \\right].\n$$\n$5$. 如果 $\\Delta C  0$，则新路径更短。接受该移动，并更新路径。\n\n重复此过程，迭代所有可能的待反转子路径，直到找不到任何可以进一步降低成本的 2-opt 移动。此时，算法已达到局部最优并终止。贪婪起始和 2-opt 优化的结合为这个复杂的优化问题提供了一个稳健且高质量的解决方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the scan chain reordering problem for a suite of test cases.\n    The problem is modeled as an anchored open Traveling Salesman Problem (TSP) with a custom cost function.\n    The solution uses a two-phase heuristic:\n    1. A greedy construction (Nearest Neighbor) to create an initial path.\n    2. A 2-opt local search to iteratively improve the path until a local optimum is reached.\n    \"\"\"\n    test_cases = [\n        {\n            \"s\": (0, 0), \"t\": (1000, 0),\n            \"cells\": [(100, 50), (200, 300), (400, 100), (250, 80), (700, 60), (900, 200), (650, 350), (500, 20)],\n            \"alpha\": 1.0, \"beta\": 3.0, \"d_h\": 80\n        },\n        {\n            \"s\": (0, 0), \"t\": (500, 500),\n            \"cells\": [(50, 50), (55, 52), (60, 48), (58, 55), (62, 51), (57, 49)],\n            \"alpha\": 1.0, \"beta\": 10.0, \"d_h\": 50\n        },\n        {\n            \"s\": (0, 0), \"t\": (1000, 0),\n            \"cells\": [(100, 0), (900, 0)],\n            \"alpha\": 1.0, \"beta\": 0.5, \"d_h\": 10\n        },\n        {\n            \"s\": (0, 0), \"t\": (400, 400),\n            \"cells\": [(100, 100), (100, 200), (100, 300), (200, 100), (200, 200), (200, 300), (300, 100), (300, 200), (300, 300)],\n            \"alpha\": 1.0, \"beta\": 1.0, \"d_h\": 40\n        },\n        {\n            \"s\": (0, 1000), \"t\": (1000, 1000),\n            \"cells\": [(420, 210), (430, 250), (415, 230), (460, 240), (500, 260), (520, 220), (480, 200)],\n            \"alpha\": 1.0, \"beta\": 2.0, \"d_h\": 60\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        s_coord, t_coord, cells_coords = case[\"s\"], case[\"t\"], case[\"cells\"]\n        alpha, beta, d_h = case[\"alpha\"], case[\"beta\"], case[\"d_h\"]\n\n        # Consolidate all points: start anchor, cells, end anchor\n        points = [s_coord] + cells_coords + [t_coord]\n        n_cells = len(cells_coords)\n        points_np = np.array(points, dtype=float)\n\n        # Memoization cache for edge costs to speed up calculations\n        cost_cache = {}\n\n        def edge_cost(p1_idx, p2_idx):\n            key = tuple(sorted((p1_idx, p2_idx)))\n            if key in cost_cache:\n                return cost_cache[key]\n            \n            dist = np.sum(np.abs(points_np[p1_idx] - points_np[p2_idx]))\n            cost = alpha * dist + beta * max(0, d_h - dist)\n            cost_cache[key] = cost\n            return cost\n\n        # Phase 1: Greedy Construction (Nearest Neighbor)\n        unvisited_indices = set(range(1, n_cells + 1))\n        initial_path = [0]\n        \n        if n_cells > 0:\n            current_idx = 0\n            while unvisited_indices:\n                last_point_idx = initial_path[-1]\n                \n                best_next_idx = -1\n                min_cost = float('inf')\n                \n                for next_idx in unvisited_indices:\n                    cost = edge_cost(last_point_idx, next_idx)\n                    if cost  min_cost:\n                        min_cost = cost\n                        best_next_idx = next_idx\n                \n                initial_path.append(best_next_idx)\n                unvisited_indices.remove(best_next_idx)\n        \n        initial_path.append(n_cells + 1)\n        \n        # Phase 2: 2-Opt Local Search\n        path = initial_path\n        \n        if n_cells > 1:\n            improved = True\n            while improved:\n                improved = False\n                # The subpath of scan cells to operate on is path[1:n_cells+1]\n                for i in range(1, n_cells):\n                    for j in range(i + 1, n_cells + 1):\n                        v_i_minus_1, v_i = path[i-1], path[i]\n                        v_j, v_j_plus_1 = path[j], path[j+1]\n\n                        current_edge_cost = edge_cost(v_i_minus_1, v_i) + edge_cost(v_j, v_j_plus_1)\n                        new_edge_cost = edge_cost(v_i_minus_1, v_j) + edge_cost(v_i, v_j_plus_1)\n\n                        if new_edge_cost  current_edge_cost:\n                            path[i:j+1] = path[i:j+1][::-1]\n                            improved = True\n                            break\n                    if improved:\n                        break\n        \n        # Final cost calculation for the optimized path\n        total_cost = 0.0\n        for k in range(len(path) - 1):\n            total_cost += edge_cost(path[k], path[k+1])\n            \n        # Convert path indices (referencing `points` array) to original cell indices (0-based)\n        cell_order = [p - 1 for p in path[1:-1]]\n        \n        results.append([f\"{total_cost:.3f}\", cell_order])\n\n    # Format the results into the required string format\n    result_str = \"[\" + \",\".join([f\"[{cost},{order}]\" for cost, order in results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}