{
    "hands_on_practices": [
        {
            "introduction": "The first step in understanding the implications of Design for Test (DFT) is to quantify its impact on the circuit's original functional performance. Replacing a standard flip-flop with a muxed-D scan flop introduces additional delay, which can affect critical path timing. This practice guides you through a first-principles derivation to precisely calculate the change in setup slack, providing a clear, analytical understanding of this fundamental trade-off .",
            "id": "4295557",
            "problem": "Consider a synchronous single-cycle datapath in an integrated circuit designed using Electronic Design Automation (EDA) methods, with a launch register and a capture register, both originally implemented as functional D flip-flops (DFFs). The clock period is $T$, the clock-to-$Q$ propagation delay of the launch register is $t_{\\text{clkq}}$, the total combinational propagation delay between the launch register output and the capture register input is $t_{\\text{pd}}$, and the setup time requirement of the capture register is $t_{\\text{setup}}$. The clock skew from the launch register clock pin to the capture register clock pin is $t_{\\text{skew}}$. Assume a single clock domain, no retiming, and ignore on-chip variation, jitter, and any dynamic power supply noise effects. All timing quantities are for a single process-voltage-temperature corner and are treated as constants.\n\nIn a Design for Test (DFT) insertion step, the capture register is replaced by a muxed-$D$ scan flip-flop, in which the functional $D$ input passes through an internal two-input multiplexer before reaching the storage element. In functional mode (scan enable deasserted), this multiplexer adds an additional delay $\\Delta t_{\\text{mux}}$ to the data path seen at the capture register input. Furthermore, distributing and gating the scan enable signal inside the scan flip-flop adds a setup-time overhead at the capture register, modeled as an increase $\\Delta t_{\\text{SE}}$ in the setup time requirement relative to the original functional DFF. Assume the replacement does not change the launch register characteristics, the clock distribution, or $t_{\\text{skew}}$.\n\nStarting from first principles of synchronous setup timing, derive an analytic expression for the change in setup slack, $\\Delta S$, defined as the setup slack after replacement minus the setup slack before replacement, as a function of $\\Delta t_{\\text{mux}}$ and $\\Delta t_{\\text{SE}}$. Express your final answer as a closed-form symbolic expression in seconds. Do not numerically evaluate or approximate any quantities.",
            "solution": "The setup timing condition for a synchronous single-cycle path in a single clock domain is based on comparing a required arrival time at the capture register with the actual data arrival time at its $D$ input. The setup slack is defined as the difference between the required time and the arrival time, where positive slack indicates the setup constraint is met.\n\nLet the launch clock edge be the reference. The data arrival time at the capture register input in the original, pre-scan configuration is the sum of the launch register clock-to-$Q$ delay and the combinational path delay:\n$$\nt_{\\text{arr,0}} = t_{\\text{clkq}} + t_{\\text{pd}}.\n$$\nThe required arrival time at the capture register input, accounting for the clock period $T$, the clock skew $t_{\\text{skew}}$ (defined as capture clock arrival time minus launch clock arrival time), and the setup time requirement $t_{\\text{setup}}$ of the capture register, is\n$$\nt_{\\text{req,0}} = T + t_{\\text{skew}} - t_{\\text{setup}}.\n$$\nTherefore, the original setup slack $S_{0}$ is\n$$\nS_{0} = t_{\\text{req,0}} - t_{\\text{arr,0}} = \\left(T + t_{\\text{skew}} - t_{\\text{setup}}\\right) - \\left(t_{\\text{clkq}} + t_{\\text{pd}}\\right).\n$$\n\nAfter replacing the capture register with a muxed-$D$ scan flip-flop, the functional $D$ input incurs an additional delay $\\Delta t_{\\text{mux}}$ inside the cell before reaching the storage element. This increases the data arrival time at the capture input by $\\Delta t_{\\text{mux}}$, yielding\n$$\nt_{\\text{arr,1}} = t_{\\text{clkq}} + t_{\\text{pd}} + \\Delta t_{\\text{mux}}.\n$$\nThe scan enable gating overhead increases the setup time requirement by $\\Delta t_{\\text{SE}}$, so the new required time becomes\n$$\nt_{\\text{req,1}} = T + t_{\\text{skew}} - \\left(t_{\\text{setup}} + \\Delta t_{\\text{SE}}\\right).\n$$\nThus, the new setup slack $S_{1}$ is\n$$\nS_{1} = t_{\\text{req,1}} - t_{\\text{arr,1}} = \\left(T + t_{\\text{skew}} - t_{\\text{setup}} - \\Delta t_{\\text{SE}}\\right) - \\left(t_{\\text{clkq}} + t_{\\text{pd}} + \\Delta t_{\\text{mux}}\\right).\n$$\n\nThe change in setup slack, defined as the post-replacement slack minus the pre-replacement slack, is\n$$\n\\Delta S = S_{1} - S_{0}.\n$$\nSubstituting the expressions for $S_{1}$ and $S_{0}$:\n$$\n\\Delta S = \\Big[\\left(T + t_{\\text{skew}} - t_{\\text{setup}} - \\Delta t_{\\text{SE}}\\right) - \\left(t_{\\text{clkq}} + t_{\\text{pd}} + \\Delta t_{\\text{mux}}\\right)\\Big] - \\Big[\\left(T + t_{\\text{skew}} - t_{\\text{setup}}\\right) - \\left(t_{\\text{clkq}} + t_{\\text{pd}}\\right)\\Big].\n$$\nSimplifying, the common terms $T$, $t_{\\text{skew}}$, $t_{\\text{setup}}$, $t_{\\text{clkq}}$, and $t_{\\text{pd}}$ cancel:\n$$\n\\Delta S = -\\Delta t_{\\text{SE}} - \\Delta t_{\\text{mux}}.\n$$\n\nThis expression indicates that the setup slack is reduced by the sum of the multiplexer delay on the functional $D$ path and the increase in setup time caused by the scan enable gating overhead, under the stated assumptions that the launch register, clock distribution, and skew remain unchanged.",
            "answer": "$$\\boxed{-\\left(\\Delta t_{\\text{mux}}+\\Delta t_{\\text{SE}}\\right)}$$"
        },
        {
            "introduction": "After inserting scan cells, we must ensure the scan chain itself can operate reliably at a desired frequency. This involves a rigorous Static Timing Analysis (STA) of the scan path, which presents its own unique challenges, including clock skew and the need to satisfy both setup and hold constraints. This exercise simulates a real-world sign-off scenario, where you will determine the maximum safe scan shift frequency by incorporating practical considerations like process variation derates and clock uncertainty margins .",
            "id": "4295613",
            "problem": "A synchronous digital integrated circuit employs Design for Test (DFT) scan chains built from edge-triggered scan flip-flops implemented with a two-input multiplexer that selects between functional data and scan data. In scan-shift mode, adjacent scan flip-flops are clocked by the same scan clock. The scan data path for two adjacent scan cells consists of the launching flip-flop clock-to-output delay, the scan multiplexer delay, the interconnect delay, and any explicit scan delay buffer(s), feeding the destination flip-flop data input. Let the scan clock edges arrive at the source and destination scan flip-flops with a defined clock skew. Assume single-edge triggering with the same active edge at source and destination. \n\nStarting from the standard synchronous timing definitions, the setup-timing requirement for a correctly sampled next-cycle value and the hold-timing requirement for stability around the active clock edge at the destination must both be satisfied. Process variation is modeled by guardband derates applied multiplicatively to relevant delays for setup and hold analyses, respectively. Clock uncertainty is modeled as an additive margin.\n\nConsider two adjacent scan cells connected in scan-shift mode with the following nominal parameters at the sign-off process-voltage-temperature corner:\n- Source flip-flop nominal maximum clock-to-Q delay $t_{cq,\\max} = 90$ ps and nominal minimum clock-to-Q delay $t_{cq,\\min} = 50$ ps.\n- Destination flip-flop nominal setup time $t_{setup} = 80$ ps and nominal hold time $t_{hold} = 50$ ps.\n- Scan multiplexer (data path) nominal propagation delay $t_{mux,\\max} = 120$ ps and $t_{mux,\\min} = 90$ ps.\n- Interconnect (wire) nominal propagation delay $t_{wire,\\max} = 700$ ps and $t_{wire,\\min} = 500$ ps.\n- One scan delay buffer with nominal propagation delay $t_{buf,\\max} = 150$ ps and $t_{buf,\\min} = 120$ ps.\n- Destination clock arrives earlier than source clock by $|\\Delta| = 300$ ps, i.e., the destination clock leads: define skew as $\\Delta = t_{clk,dest} - t_{clk,src} = -300$ ps.\n- Total scan clock uncertainty (including jitter and modeling) to be marginized in setup analysis is $U_{setup} = 120$ ps. Total scan clock uncertainty to be marginized in hold analysis is $U_{hold} = 40$ ps.\n\nProcess variation guardbands are to be applied as follows:\n- For setup analysis (slow data, pessimistic receiving latch timing): multiply $t_{cq,\\max}$ and all data-path maximum delays by a data derate $r_{su,data} = 1.08$, and multiply $t_{setup}$ by a latch derate $r_{su,latch} = 1.05$.\n- For hold analysis (fast data, pessimistic hold requirement): multiply $t_{cq,\\min}$ by $r_{ho,cq} = 0.95$, multiply all data-path minimum delays by $r_{ho,data} = 0.92$, and multiply $t_{hold}$ by $r_{ho,latch} = 1.05$.\n\nUse the setup and hold definitions as the sole starting point. Determine the maximum safe scan shift frequency $f_{\\max}$ such that both setup and hold constraints are satisfied under the above guardbands and uncertainties. If hold is satisfied for all frequencies, then $f_{\\max}$ is dictated by the setup constraint.\n\nExpress your final frequency in MHz and round your answer to four significant figures.",
            "solution": "The problem requires the determination of the maximum safe scan shift frequency, $f_{\\max}$, for a synchronous digital circuit. This frequency is constrained by two fundamental timing requirements: setup time and hold time. We must analyze both constraints under the specified process variation guardbands (derates) and clock uncertainties.\n\nThe core principle of synchronous timing is that data launched from a source flip-flop must be correctly captured by a destination flip-flop at a subsequent clock cycle.\n\nFirst, let's establish the fundamental timing equations.\nFor setup timing, the data must arrive at the destination flip-flop's data input ($D$) and remain stable for a duration $t_{setup}$ *before* the active clock edge arrives. The arrival time of the data at the destination is the sum of the source clock arrival time, the source flip-flop's clock-to-Q delay ($t_{cq}$), and the combinational path delay ($t_{path}$). The capture clock edge for the next cycle occurs at $t_{clk,dest} + T$, where $T$ is the clock period.\nThe inequality is:\n$$t_{clk,src} + t_{cq} + t_{path} \\le (t_{clk,dest} + T) - t_{setup}$$\nRearranging for the clock period $T$, and introducing the clock skew $\\Delta = t_{clk,dest} - t_{clk,src}$, we get:\n$$T \\ge t_{cq} + t_{path} - \\Delta + t_{setup}$$\n\nFor hold timing, the data from the current launch edge must not interfere with the data being latched from the previous cycle. This means the data must arrive at the destination $D$ input *after* the hold time window $t_{hold}$ around the current capture edge at $t_{clk,dest}$ has passed.\nThe inequality is:\n$$t_{clk,src} + t_{cq} + t_{path} \\ge t_{clk,dest} + t_{hold}$$\nRearranging gives the hold constraint, which is independent of the clock period $T$:\n$$t_{cq} + t_{path} \\ge \\Delta + t_{hold}$$\n\nWe will now analyze each constraint with the provided parameters and derates.\n\n**Setup Timing Analysis**\n\nTo find the minimum clock period, $T_{\\min}$, we must evaluate the setup equation under the worst-case conditions: the longest possible data path delay and the earliest capturing clock edge. This involves using maximum delay values, applying pessimistic derates, and adding the clock uncertainty margin $U_{setup}$. The minimum period is therefore:\n$$T_{\\min} = T_{\\text{launch,max}} - \\Delta + t_{\\text{setup,derated}} + U_{\\text{setup}}$$\nwhere $T_{\\text{launch,max}}$ is the maximum, derated launch path delay.\n\nLet's calculate the terms:\n1. The maximum launch path delay, $T_{\\text{launch,max}}$, is the sum of the maximum clock-to-Q delay and the maximum delays of the scan multiplexer, interconnect, and buffer, all multiplied by the setup data derate $r_{su,data} = 1.08$.\nThe nominal maximum launch path delay is:\n$$t_{launch,nom,\\max} = t_{cq,\\max} + t_{mux,\\max} + t_{wire,\\max} + t_{buf,\\max} = 90 \\text{ ps} + 120 \\text{ ps} + 700 \\text{ ps} + 150 \\text{ ps} = 1060 \\text{ ps}$$\nApplying the derate:\n$$T_{\\text{launch,max}} = t_{launch,nom,\\max} \\times r_{su,data} = 1060 \\text{ ps} \\times 1.08 = 1144.8 \\text{ ps}$$\n\n2. The derated setup time, $t_{\\text{setup,derated}}$, is the nominal setup time multiplied by the setup latch derate $r_{su,latch} = 1.05$.\n$$t_{\\text{setup,derated}} = t_{setup} \\times r_{su,latch} = 80 \\text{ ps} \\times 1.05 = 84 \\text{ ps}$$\n\n3. The problem provides the clock skew $\\Delta = -300$ ps and the setup clock uncertainty $U_{setup} = 120$ ps.\n\nNow, we can compute $T_{\\min}$:\n$$T_{\\min} = 1144.8 \\text{ ps} - (-300 \\text{ ps}) + 84 \\text{ ps} + 120 \\text{ ps}$$\n$$T_{\\min} = 1144.8 + 300 + 84 + 120 = 1648.8 \\text{ ps}$$\n\n**Hold Timing Analysis**\n\nTo verify that the hold constraint is met, we must check for a \"race condition\" under the fastest possible data path conditions. The total minimum data path delay must be greater than the sum of the clock skew, the hold requirement, and the hold uncertainty margin. The hold slack must be non-negative.\n$$\\text{Slack}_{\\text{hold}} = T_{\\text{launch,min}} - \\Delta - t_{\\text{hold,derated}} - U_{\\text{hold}} \\ge 0$$\nwhere $T_{\\text{launch,min}}$ is the minimum, derated launch path delay.\n\nLet's calculate the terms for the hold check:\n1. The minimum launch path delay, $T_{\\text{launch,min}}$, is calculated using minimum delay values and the specific hold derates. The clock-to-Q delay is derated by $r_{ho,cq} = 0.95$, and the rest of the path is derated by $r_{ho,data} = 0.92$.\n$$T_{\\text{launch,min}} = (t_{cq,\\min} \\times r_{ho,cq}) + (t_{mux,\\min} + t_{wire,\\min} + t_{buf,\\min}) \\times r_{ho,data}$$\n$$T_{\\text{launch,min}} = (50 \\text{ ps} \\times 0.95) + (90 \\text{ ps} + 500 \\text{ ps} + 120 \\text{ ps}) \\times 0.92$$\n$$T_{\\text{launch,min}} = 47.5 \\text{ ps} + (710 \\text{ ps}) \\times 0.92 = 47.5 \\text{ ps} + 653.2 \\text{ ps} = 700.7 \\text{ ps}$$\n\n2. The derated hold time, $t_{\\text{hold,derated}}$, is the nominal hold time multiplied by the hold latch derate $r_{ho,latch} = 1.05$.\n$$t_{\\text{hold,derated}} = t_{hold} \\times r_{ho,latch} = 50 \\text{ ps} \\times 1.05 = 52.5 \\text{ ps}$$\n\n3. The problem provides the clock skew $\\Delta = -300$ ps and the hold clock uncertainty $U_{hold} = 40$ ps.\n\nNow, we can compute the hold slack:\n$$\\text{Slack}_{\\text{hold}} = 700.7 \\text{ ps} - (-300 \\text{ ps}) - 52.5 \\text{ ps} - 40 \\text{ ps}$$\n$$\\text{Slack}_{\\text{hold}} = 700.7 + 300 - 52.5 - 40 = 1000.7 - 92.5 = 908.2 \\text{ ps}$$\nSince $\\text{Slack}_{\\text{hold}} = 908.2 \\text{ ps} > 0$, the hold constraint is satisfied. Because the hold check is independent of clock period, it is satisfied for all frequencies.\n\n**Maximum Frequency Calculation**\n\nThe maximum safe scan shift frequency, $f_{\\max}$, is dictated by the setup constraint and is the reciprocal of the minimum clock period $T_{\\min}$.\n$$f_{\\max} = \\frac{1}{T_{\\min}} = \\frac{1}{1648.8 \\text{ ps}} = \\frac{1}{1648.8 \\times 10^{-12} \\text{ s}}$$\n$$f_{\\max} \\approx 606501698 \\text{ Hz} \\approx 606.5017 \\text{ MHz}$$\n\nThe problem requires the answer in MHz, rounded to four significant figures.\n$$f_{\\max} \\approx 606.5 \\text{ MHz}$$",
            "answer": "$$\\boxed{606.5}$$"
        },
        {
            "introduction": "Connecting thousands or millions of scan cells into an efficient chain—a process known as scan stitching—is a complex optimization problem. A naive ordering can lead to excessive wirelength, routing congestion, and an increased risk of timing violations. This problem challenges you to frame scan chain reordering as an anchored variant of the Traveling Salesman Problem (TSP), developing a solution that balances wirelength minimization with the mitigation of hold-time risks, a core task in modern physical design automation .",
            "id": "4295638",
            "problem": "You are given a set of scan cells placed at two-dimensional coordinates expressed in micrometers, and two anchor points representing the scan input and scan output pins. The task is to reorder the scan cells to form a single scan chain path from the scan input anchor to the scan output anchor such that each scan cell is visited exactly once. The path cost must reflect a balance between wirelength and hold-time risk. Formulate this reordering as an anchored open variant of the Traveling Salesman Problem (TSP) over scan cell locations, and implement an approximate solver that achieves a reasonable trade-off between wirelength minimization and hold-time risk reduction.\n\nFundamental base:\n- A scan chain is a sequence of scan cells connected serially, clocked by a scan clock during test. Excessively short physical connections between sequential scan cells increase the probability of hold-time violations, because the data path delay can become too small to satisfy hold requirements under clock skew and variability. Conversely, excessively long connections increase routing congestion and transition time.\n- The Traveling Salesman Problem (TSP) is the problem of finding an order to visit a set of points that minimizes the sum of edge costs. An \"open\" TSP variant seeks a path rather than a cycle, with specified endpoints.\n\nDefinitions:\n- Let the scan input anchor be at coordinates $\\mathbf{s} = (x_s, y_s)$ and the scan output anchor be at coordinates $\\mathbf{t} = (x_t, y_t)$, measured in micrometers.\n- Let the set of scan cells be $\\{\\mathbf{p}_i = (x_i, y_i)\\}_{i=1}^N$, also in micrometers.\n- For any two points $\\mathbf{u} = (x_u, y_u)$ and $\\mathbf{v} = (x_v, y_v)$, define the Manhattan distance in micrometers as $d(\\mathbf{u}, \\mathbf{v}) = |x_u - x_v| + |y_u - y_v|$.\n- Let the per-edge cost be defined as $c(\\mathbf{u}, \\mathbf{v}) = \\alpha \\cdot d(\\mathbf{u}, \\mathbf{v}) + \\beta \\cdot \\max(0, d_h - d(\\mathbf{u}, \\mathbf{v}))$, where $d_h$ is a hold-safe minimum wirelength threshold in micrometers, $\\alpha$ and $\\beta$ are nonnegative weights. The term $\\beta \\cdot \\max(0, d_h - d)$ penalizes connections shorter than $d_h$ to reduce hold risk.\n\nObjective:\n- Find an ordering $\\pi$ of the scan cells that minimizes the total path cost\n$$\nC(\\pi) = c(\\mathbf{s}, \\mathbf{p}_{\\pi(1)}) + \\sum_{k=1}^{N-1} c(\\mathbf{p}_{\\pi(k)}, \\mathbf{p}_{\\pi(k+1)}) + c(\\mathbf{p}_{\\pi(N)}, \\mathbf{t}).\n$$\n\nApproximate solution requirement:\n- Implement a constructive heuristic followed by local improvement. A valid approach is a multi-start greedy construction that builds a path from the scan input anchor through unvisited scan cells by iteratively adding the next scan cell that minimizes incremental edge cost, followed by a $2$-opt local search adapted to the anchored open path to reduce the total cost. The $2$-opt move reverses a contiguous subpath and replaces two edges with two alternative edges, preserving anchors at endpoints.\n\nNumerical and unit requirements:\n- Distances and thresholds are in micrometers, and the total cost must be expressed in micrometers. Your program must report each total cost in micrometers, rounded to three decimal places.\n\nTest suite:\nFor each test case, you are provided with $\\mathbf{s}$, $\\mathbf{t}$, the list of scan cell coordinates, and parameters $\\alpha$, $\\beta$, and $d_h$.\n\n- Test case $1$ (happy path): \n  - $\\mathbf{s} = (0, 0)$, $\\mathbf{t} = (1000, 0)$\n  - Scan cells: $[(100, 50), (200, 300), (400, 100), (250, 80), (700, 60), (900, 200), (650, 350), (500, 20)]$\n  - $\\alpha = 1.0$, $\\beta = 3.0$, $d_h = 80$\n- Test case $2$ (short-edge risk emphasis):\n  - $\\mathbf{s} = (0, 0)$, $\\mathbf{t} = (500, 500)$\n  - Scan cells: $[(50, 50), (55, 52), (60, 48), (58, 55), (62, 51), (57, 49)]$\n  - $\\alpha = 1.0$, $\\beta = 10.0$, $d_h = 50$\n- Test case $3$ (minimum nontrivial chain):\n  - $\\mathbf{s} = (0, 0)$, $\\mathbf{t} = (1000, 0)$\n  - Scan cells: $[(100, 0), (900, 0)]$\n  - $\\alpha = 1.0$, $\\beta = 0.5$, $d_h = 10$\n- Test case $4$ (grid placement):\n  - $\\mathbf{s} = (0, 0)$, $\\mathbf{t} = (400, 400)$\n  - Scan cells: $[(100, 100), (100, 200), (100, 300), (200, 100), (200, 200), (200, 300), (300, 100), (300, 200), (300, 300)]$\n  - $\\alpha = 1.0$, $\\beta = 1.0$, $d_h = 40$\n- Test case $5$ (anchors far, clustered cells):\n  - $\\mathbf{s} = (0, 1000)$, $\\mathbf{t} = (1000, 1000)$\n  - Scan cells: $[(420, 210), (430, 250), (415, 230), (460, 240), (500, 260), (520, 220), (480, 200)]$\n  - $\\alpha = 1.0$, $\\beta = 2.0$, $d_h = 60$\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must itself be a two-element list whose first element is the total cost in micrometers, rounded to three decimal places, and whose second element is the scan chain order as a list of integers denoting the zero-based indices of the scan cells. For example:\n- $[ [123.456,[0,2,1]], [789.000,[1,0]] ]$.",
            "solution": "The user-provided problem statement has been analyzed and validated.\n\n### Step 1: Extracted Givens\n- **Anchors:** Scan input $\\mathbf{s} = (x_s, y_s)$ and scan output $\\mathbf{t} = (x_t, y_t)$, in micrometers.\n- **Scan Cells:** A set of $N$ points $\\{\\mathbf{p}_i = (x_i, y_i)\\}_{i=1}^N$, in micrometers.\n- **Distance Metric:** Manhattan distance, $d(\\mathbf{u}, \\mathbf{v}) = |x_u - x_v| + |y_u - y_v|$.\n- **Edge Cost Function:** $c(\\mathbf{u}, \\mathbf{v}) = \\alpha \\cdot d(\\mathbf{u}, \\mathbf{v}) + \\beta \\cdot \\max(0, d_h - d(\\mathbf{u}, \\mathbf{v}))$, where $\\alpha$ and $\\beta$ are nonnegative weights and $d_h$ is a hold-safe minimum wirelength threshold in micrometers.\n- **Objective:** Find a permutation $\\pi$ of the scan cell indices that minimizes the total path cost:\n$$\nC(\\pi) = c(\\mathbf{s}, \\mathbf{p}_{\\pi(1)}) + \\sum_{k=1}^{N-1} c(\\mathbf{p}_{\\pi(k)}, \\mathbf{p}_{\\pi(k+1)}) + c(\\mathbf{p}_{\\pi(N)}, \\mathbf{t}).\n$$\n- **Solver Requirement:** An approximate solver using a constructive heuristic (multi-start greedy) followed by a local improvement search (2-opt for an anchored path).\n- **Numerical Requirements:** All costs are in micrometers and must be reported rounded to three decimal places.\n- **Test Suite:** Five specific test cases are provided, each with a complete set of parameters.\n\n### Step 2: Validation\n- **Scientific Grounding:** The problem is firmly rooted in the field of Electronic Design Automation (EDA) for Very Large Scale Integration (VLSI) circuits. The concepts of scan chains, wirelength optimization, and hold-time violation mitigation are fundamental challenges in Design-for-Test (DFT). The formulation of scan chain ordering as an anchored open Traveling Salesman Problem (TSP) is a standard and scientifically sound approach. The cost function accurately models the real-world trade-off between minimizing total wirelength (related to the $\\alpha$ term) and avoiding short, fast paths that risk hold-time failures (related to the $\\beta$ term).\n- **Well-Posed and Complete:** The problem is mathematically well-defined. It seeks to find a minimum-cost permutation over a finite (though large) set of possibilities. An optimal solution is guaranteed to exist. Since the problem is NP-hard, the request for an approximate solution via specified heuristics (greedy construction and 2-opt) is appropriate and leads to a determinable outcome. All necessary data ($\\mathbf{s}, \\mathbf{t}, \\{\\mathbf{p}_i\\}, \\alpha, \\beta, d_h$) are provided for each test case, making the problem self-contained and solvable.\n- **Objectivity and Feasibility:** The problem is stated using precise, objective mathematical and engineering terms. The provided numerical values for coordinates and parameters are realistic for integrated circuit design. There are no contradictions, ambiguities, or physically impossible conditions.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-posed, scientifically grounded optimization task relevant to integrated circuit design. A solution will be developed based on the specified algorithmic approach.\n\n### Solution Design\n\nThe problem of finding the optimal scan chain order is formulated as an anchored open Traveling Salesman Problem (TSP). The set of nodes to be visited includes all scan cells $\\{\\mathbf{p}_i\\}_{i=1}^N$, with the path beginning at a fixed start node $\\mathbf{s}$ and ending at a fixed terminal node $\\mathbf{t}$. The total path length is determined by the sum of edge costs, where the cost function $c(\\mathbf{u}, \\mathbf{v})$ uniquely incorporates a penalty for short connections to mitigate hold-time risks.\n\nSince the TSP is NP-hard, finding an exact solution is computationally infeasible for all but the smallest instances. Therefore, we employ a standard and effective two-phase heuristic approach as required: a constructive heuristic to generate a good initial solution, followed by an iterative local search to refine it.\n\n**Phase 1: Greedy Constructive Heuristic (Nearest Neighbor)**\n\nThe initial path is constructed greedily. This method, a variant of the Nearest Neighbor heuristic, builds the scan chain one cell at a time.\n$1$. The path starts at the scan input anchor, $\\mathbf{s}$.\n$2$. From the last point added to the chain (initially $\\mathbf{s}$), we select the unvisited scan cell that can be connected with the minimum edge cost, $c(\\cdot, \\cdot)$.\n$3$. This \"closest\" cell is appended to the chain, and the process repeats until all $N$ scan cells have been visited.\n$4$. Finally, the last scan cell in the chain is connected to the scan output anchor, $\\mathbf{t}$, completing the path.\n\nThis greedy strategy tends to produce a reasonably short path, providing a high-quality starting point for the subsequent optimization phase. For this anchored problem, a deterministic nearest-neighbor construction is a robust interpretation of the \"greedy construction\" requirement.\n\n**Phase 2: Iterative Improvement (2-Opt Local Search)**\n\nThe 2-opt algorithm is a powerful local search heuristic for improving TSP solutions. It works by systematically swapping pairs of edges to see if a shorter path can be formed. For an anchored path $(v_0, v_1, ..., v_N, v_{N+1})$, where $v_0=\\mathbf{s}$ and $v_{N+1}=\\mathbf{t}$, the 2-opt move is adapted as follows:\n$1$. Select a contiguous subpath of scan cells $(v_i, v_{i+1}, ..., v_j)$ where $1 \\le i < j \\le N$. This subpath is connected to the rest of the path by edges $(v_{i-1}, v_i)$ and $(v_j, v_{j+1})$.\n$2$. Reverse the order of the subpath to get $(v_j, v_{j-1}, ..., v_i)$.\n$3$. Reconnect the path by forming new edges $(v_{i-1}, v_j)$ and $(v_i, v_{j+1})$. This constitutes a 2-opt move.\n$4$. Calculate the change in total cost:\n$$\n\\Delta C = \\left[ c(v_{i-1}, v_j) + c(v_i, v_{j+1}) \\right] - \\left[ c(v_{i-1}, v_i) + c(v_j, v_{j+1}) \\right].\n$$\n$5$. If $\\Delta C < 0$, the new path is shorter. The move is accepted, and the path is updated.\n\nThis process is repeated, iterating through all possible subpaths to reverse, until no further cost-reducing 2-opt moves can be found. At this point, the algorithm has reached a local optimum and terminates. The combination of a greedy start and 2-opt refinement provides a robust and high-quality solution to this complex optimization problem.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the scan chain reordering problem for a suite of test cases.\n    The problem is modeled as an anchored open Traveling Salesman Problem (TSP) with a custom cost function.\n    The solution uses a two-phase heuristic:\n    1. A greedy construction (Nearest Neighbor) to create an initial path.\n    2. A 2-opt local search to iteratively improve the path until a local optimum is reached.\n    \"\"\"\n    test_cases = [\n        {\n            \"s\": (0, 0), \"t\": (1000, 0),\n            \"cells\": [(100, 50), (200, 300), (400, 100), (250, 80), (700, 60), (900, 200), (650, 350), (500, 20)],\n            \"alpha\": 1.0, \"beta\": 3.0, \"d_h\": 80\n        },\n        {\n            \"s\": (0, 0), \"t\": (500, 500),\n            \"cells\": [(50, 50), (55, 52), (60, 48), (58, 55), (62, 51), (57, 49)],\n            \"alpha\": 1.0, \"beta\": 10.0, \"d_h\": 50\n        },\n        {\n            \"s\": (0, 0), \"t\": (1000, 0),\n            \"cells\": [(100, 0), (900, 0)],\n            \"alpha\": 1.0, \"beta\": 0.5, \"d_h\": 10\n        },\n        {\n            \"s\": (0, 0), \"t\": (400, 400),\n            \"cells\": [(100, 100), (100, 200), (100, 300), (200, 100), (200, 200), (200, 300), (300, 100), (300, 200), (300, 300)],\n            \"alpha\": 1.0, \"beta\": 1.0, \"d_h\": 40\n        },\n        {\n            \"s\": (0, 1000), \"t\": (1000, 1000),\n            \"cells\": [(420, 210), (430, 250), (415, 230), (460, 240), (500, 260), (520, 220), (480, 200)],\n            \"alpha\": 1.0, \"beta\": 2.0, \"d_h\": 60\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        s_coord, t_coord, cells_coords = case[\"s\"], case[\"t\"], case[\"cells\"]\n        alpha, beta, d_h = case[\"alpha\"], case[\"beta\"], case[\"d_h\"]\n\n        # Consolidate all points: start anchor, cells, end anchor\n        points = [s_coord] + cells_coords + [t_coord]\n        n_cells = len(cells_coords)\n        points_np = np.array(points, dtype=float)\n\n        # Memoization cache for edge costs to speed up calculations\n        cost_cache = {}\n\n        def edge_cost(p1_idx, p2_idx):\n            key = tuple(sorted((p1_idx, p2_idx)))\n            if key in cost_cache:\n                return cost_cache[key]\n            \n            dist = np.sum(np.abs(points_np[p1_idx] - points_np[p2_idx]))\n            cost = alpha * dist + beta * max(0, d_h - dist)\n            cost_cache[key] = cost\n            return cost\n\n        # Phase 1: Greedy Construction (Nearest Neighbor)\n        unvisited_indices = set(range(1, n_cells + 1))\n        initial_path = [0]\n        \n        if n_cells > 0:\n            current_idx = 0\n            while unvisited_indices:\n                last_point_idx = initial_path[-1]\n                \n                best_next_idx = -1\n                min_cost = float('inf')\n                \n                for next_idx in unvisited_indices:\n                    cost = edge_cost(last_point_idx, next_idx)\n                    if cost  min_cost:\n                        min_cost = cost\n                        best_next_idx = next_idx\n                \n                initial_path.append(best_next_idx)\n                unvisited_indices.remove(best_next_idx)\n        \n        initial_path.append(n_cells + 1)\n        \n        # Phase 2: 2-Opt Local Search\n        path = initial_path\n        \n        if n_cells > 1:\n            improved = True\n            while improved:\n                improved = False\n                # The subpath of scan cells to operate on is path[1:n_cells+1]\n                for i in range(1, n_cells):\n                    for j in range(i + 1, n_cells + 1):\n                        v_i_minus_1, v_i = path[i-1], path[i]\n                        v_j, v_j_plus_1 = path[j], path[j+1]\n\n                        current_edge_cost = edge_cost(v_i_minus_1, v_i) + edge_cost(v_j, v_j_plus_1)\n                        new_edge_cost = edge_cost(v_i_minus_1, v_j) + edge_cost(v_i, v_j_plus_1)\n\n                        if new_edge_cost  current_edge_cost:\n                            path[i:j+1] = path[i:j+1][::-1]\n                            improved = True\n                            break\n                    if improved:\n                        break\n        \n        # Final cost calculation for the optimized path\n        total_cost = 0.0\n        for k in range(len(path) - 1):\n            total_cost += edge_cost(path[k], path[k+1])\n            \n        # Convert path indices (referencing `points` array) to original cell indices (0-based)\n        cell_order = [p - 1 for p in path[1:-1]]\n        \n        results.append([f\"{total_cost:.3f}\", cell_order])\n\n    # Format the results into the required string format\n    result_str = \"[\" + \",\".join([f\"[{cost},{order}]\" for cost, order in results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}