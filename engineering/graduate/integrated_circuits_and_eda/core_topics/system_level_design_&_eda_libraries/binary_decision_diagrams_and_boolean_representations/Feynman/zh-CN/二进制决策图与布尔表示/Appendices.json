{
    "hands_on_practices": [
        {
            "introduction": "从布尔公式到其图形表示的转换是处理布尔函数的基石。本练习将引导您完成一个完整的转换流程：从一个电路的合取范式（CNF）表达式开始，通过布尔代数定律将其转换为析取范式（DNF），最终利用香农展开（Shannon decomposition）构建其对应的归约有序二元决策图（ROBDD）。这个过程不仅能加深您对不同布尔表示形式之间关系的理解，也为掌握ROBDD的核心构造算法提供了实践机会。",
            "id": "4258062",
            "problem": "考虑一个在电子设计自动化（EDA）中使用的两位等值比较器。设两位输入为 $A=(a_{1},a_{0})$ 和 $B=(b_{1},b_{0})$。比较器的输出 $E(A,B)$ 是一个布尔函数，其值当且仅当 $A=B$ 时为 $1$。假设 $E$ 以合取范式（CNF）的形式指定为四个子句的合取：\n$$\n(\\neg a_{1} \\vee b_{1}) \\wedge (\\neg b_{1} \\vee a_{1}) \\wedge (\\neg a_{0} \\vee b_{0}) \\wedge (\\neg b_{0} \\vee a_{0}).\n$$\n从这个 CNF 出发：\n- 首先，使用布尔代数和分配律为 $E$ 推导出一个等价的析取范式（DNF），展示所有步骤并仅使用布尔代数的基本定律和恒等式进行论证。\n- 接下来，通过香农分解 $f=(x \\wedge f|_{x=1}) \\vee (\\neg x \\wedge f|_{x=0})$，并使用有序变量序列 $a_{1} \\prec b_{1} \\prec a_{0} \\prec b_{0}$，构建 $E$ 的二元决策图（BDD）。应用标准的规约规则以获得规约有序二元决策图（ROBDD）：合并同构子图（唯一表）并消除冗余测试（一个节点的低位和高位子节点相同时，该节点被旁路）。\n- 详细说明每个分解步骤和应用的每个规约。\n- 对于最终答案，报告在给定变量排序下，最终ROBDD中不同非终端节点的总数。非终端节点是指由决策变量标记的节点；标记为 $0$ 或 $1$ 的终端节点不计算在内。\n\n将最终答案表示为一个无单位的实数值。无需四舍五入。",
            "solution": "首先对问题进行严格的验证过程。\n\n### 步骤 1：提取已知条件\n- **输入**：两个 $2$ 位二进制数，$A=(a_{1},a_{0})$ 和 $B=(b_{1},b_{0})$。\n- **函数定义**：输出 $E(A,B)$ 是一个布尔函数，当且仅当 $A=B$ 时等于 $1$。\n- **初始表示**：函数 $E$ 以合取范式（CNF）给出：\n$$E = (\\neg a_{1} \\vee b_{1}) \\wedge (\\neg b_{1} \\vee a_{1}) \\wedge (\\neg a_{0} \\vee b_{0}) \\wedge (\\neg b_{0} \\vee a_{0})$$\n- **任务 1**：使用布尔代数从给定的 CNF 推导出 $E$ 的等价析取范式（DNF），并展示所有步骤。\n- **任务 2**：为 $E$ 构建规约有序二元决策图（ROBDD）。\n- **变量排序**：BDD 构建的排序指定为 $a_{1} \\prec b_{1} \\prec a_{0} \\prec b_{0}$。\n- **构建方法**：香农分解，$f=(x \\wedge f|_{x=1}) \\vee (\\neg x \\wedge f|_{x=0})$，这等价于 if-then-else 形式 $f = \\text{ITE}(x, f|_{x=1}, f|_{x=0})$。\n- **规约规则**：合并同构子图并消除冗余测试节点。\n- **要求输出**：报告最终 ROBDD 中不同非终端节点的总数。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学基础**：该问题基于布尔代数和数字逻辑设计的基本原理。CNF、DNF、二元决策图（BDD）、香农分解和 ROBDD 等概念是计算机科学和电子设计自动化领域的标准内容。比较器的布尔函数是明确定义的。提供的 $E$ 的 CNF 正确地表示了相等条件。子句 $(\\neg x \\vee y) \\wedge (\\neg y \\vee x)$ 是逻辑等价 $x \\leftrightarrow y$ 的标准 CNF 表示。因此，给定表达式等价于 $(a_1 \\leftrightarrow b_1) \\wedge (a_0 \\leftrightarrow b_0)$，这是两位等值比较器的正确逻辑。该问题具有科学合理性。\n2.  **适定性**：任务陈述清晰。推导 DNF 是一种标准的代数操作。使用固定的变量排序构建 ROBDD 是一个算法过程，会产生唯一的、规范的表示。关于非终端节点数量的最终问题是一个定义明確的、单一的值。\n3.  **客观性**：问题使用形式化的数学符号和术语陈述，没有主观解释的余地。\n4.  **完整性**：所有必要信息，包括函数的初始形式、变量排序以及构建/规约规则，都已提供。问题是自包含的。\n\n### 步骤 3：结论与行动\n该问题具有科学基础、适定性、客观性和完整性，因此是有效的。开始进行求解。\n\n### 第 1 部分：析取范式（DNF）的推导\n给定的布尔函数是：\n$$E = (\\neg a_{1} \\vee b_{1}) \\wedge (\\neg b_{1} \\vee a_{1}) \\wedge (\\neg a_{0} \\vee b_{0}) \\wedge (\\neg b_{0} \\vee a_{0})$$\n这可以分为两部分，每部分对应一位的比较：\n$$E = [(\\neg a_{1} \\vee b_{1}) \\wedge (\\neg b_{1} \\vee a_{1})] \\wedge [(\\neg a_{0} \\vee b_{0}) \\wedge (\\neg b_{0} \\vee a_{0})]$$\n我们定义 $E_1 = (\\neg a_{1} \\vee b_{1}) \\wedge (\\neg b_{1} \\vee a_{1})$ 和 $E_0 = (\\neg a_{0} \\vee b_{0}) \\wedge (\\neg b_{0} \\vee a_{0})$。它们分别表示等价函数 $a_1 \\leftrightarrow b_1$ 和 $a_0 \\leftrightarrow b_0$。\n\n首先，我们使用分配律 $p \\wedge (q \\vee r) = (p \\wedge q) \\vee (p \\wedge r)$ 将 $E_1$ 转换为 DNF：\n$$E_1 = ((\\neg a_1 \\vee b_1) \\wedge \\neg b_1) \\vee ((\\neg a_1 \\vee b_1) \\wedge a_1)$$\n再次应用分配律：\n$$E_1 = (\\neg a_1 \\wedge \\neg b_1) \\vee (b_1 \\wedge \\neg b_1) \\vee (\\neg a_1 \\wedge a_1) \\vee (b_1 \\wedge a_1)$$\n使用互补律 ($p \\wedge \\neg p = 0$) 和同一律 ($p \\vee 0 = p$)：\n$$E_1 = (\\neg a_1 \\wedge \\neg b_1) \\vee 0 \\vee 0 \\vee (a_1 \\wedge b_1)$$\n$$E_1 = (\\neg a_1 \\wedge \\neg b_1) \\vee (a_1 \\wedge b_1)$$\n这是 $a_1=b_1$ 的 DNF。根据相同的逻辑，$E_0$ 的 DNF 是：\n$$E_0 = (\\neg a_0 \\wedge \\neg b_0) \\vee (a_0 \\wedge b_0)$$\n现在我们计算 $E = E_1 \\wedge E_0$：\n$$E = [(\\neg a_1 \\wedge \\neg b_1) \\vee (a_1 \\wedge b_1)] \\wedge [(\\neg a_0 \\wedge \\neg b_0) \\vee (a_0 \\wedge b_0)]$$\n令 $X = (\\neg a_1 \\wedge \\neg b_1)$，$Y = (a_1 \\wedge b_1)$，$Z = (\\neg a_0 \\wedge \\neg b_0)$，以及 $W = (a_0 \\wedge b_0)$。表达式为 $(X \\vee Y) \\wedge (Z \\vee W)$。应用分配律：\n$$E = (X \\wedge Z) \\vee (X \\wedge W) \\vee (Y \\wedge Z) \\vee (Y \\wedge W)$$\n代回原始项：\n$X \\wedge Z = (\\neg a_1 \\wedge \\neg b_1) \\wedge (\\neg a_0 \\wedge \\neg b_0) = \\neg a_1 \\wedge \\neg b_1 \\wedge \\neg a_0 \\wedge \\neg b_0$\n$X \\wedge W = (\\neg a_1 \\wedge \\neg b_1) \\wedge (a_0 \\wedge b_0) = \\neg a_1 \\wedge \\neg b_1 \\wedge a_0 \\wedge b_0$\n$Y \\wedge Z = (a_1 \\wedge b_1) \\wedge (\\neg a_0 \\wedge \\neg b_0) = a_1 \\wedge b_1 \\wedge \\neg a_0 \\wedge \\neg b_0$\n$Y \\wedge W = (a_1 \\wedge b_1) \\wedge (a_0 \\wedge b_0) = a_1 \\wedge b_1 \\wedge a_0 \\wedge b_0$\n\n将这些组合起来，得到 $E$ 的最终 DNF：\n$$E = (\\neg a_1 \\wedge \\neg b_1 \\wedge \\neg a_0 \\wedge \\neg b_0) \\vee (\\neg a_1 \\wedge \\neg b_1 \\wedge a_0 \\wedge b_0) \\vee (a_1 \\wedge b_1 \\wedge \\neg a_0 \\wedge \\neg b_0) \\vee (a_1 \\wedge b_1 \\wedge a_0 \\wedge b_0)$$\n这个 DNF 表示了 $A=B$ 成立的四种情况。\n\n### 第 2 部分：规约有序二元决策图（ROBDD）的构建\n我们按照变量顺序 $a_{1} \\prec b_{1} \\prec a_{0} \\prec b_{0}$ 自顶向下构建 ROBDD。我们将一个非终端节点表示为一个元组 $(v, l, h)$，其中 $v$ 是决策变量，$l$ 是低位子节点 (对应 $v=0$)，$h$ 是高位子节点 (对应 $v=1$)。终端节点为 $0$ 和 $1$。\n\n**第 1 层：对 $a_1$ 进行分解**\n根节点是变量 $a_1$。我们使用香农展开对 $E = (a_1 \\leftrightarrow b_1) \\wedge (a_0 \\leftrightarrow b_0)$ 计算其子函数。\n- 低位子节点 (如果 $a_1=0$)：$E|_{a_1=0} = (0 \\leftrightarrow b_1) \\wedge (a_0 \\leftrightarrow b_0) = \\neg b_1 \\wedge (a_0 \\leftrightarrow b_0)$。我们称此函数为 $f_0$。\n- 高位子节点 (如果 $a_1=1$)：$E|_{a_1=1} = (1 \\leftrightarrow b_1) \\wedge (a_0 \\leftrightarrow b_0) = b_1 \\wedge (a_0 \\leftrightarrow b_0)$。我们称此函数为 $f_1$。\n根节点是 $n_1 = (a_1, f_0, f_1)$。\n\n**第 2 层：对 $b_1$ 进行分解**\n我们现在为 $f_0$ 和 $f_1$ 构建节点。\n- 对于 $f_0 = \\neg b_1 \\wedge (a_0 \\leftrightarrow b_0)$：\n  - 低位子节点 (如果 $b_1=0$)：$f_0|_{b_1=0} = \\neg 0 \\wedge (a_0 \\leftrightarrow b_0) = 1 \\wedge (a_0 \\leftrightarrow b_0) = a_0 \\leftrightarrow b_0$。我们称此函数为 $h$。\n  - 高位子节点 (如果 $b_1=1$)：$f_0|_{b_1=1} = \\neg 1 \\wedge (a_0 \\leftrightarrow b_0) = 0 \\wedge (a_0 \\leftrightarrow b_0) = 0$。\n  所以，$f_0$ 的节点是 $n_2 = (b_1, h, 0)$。\n- 对于 $f_1 = b_1 \\wedge (a_0 \\leftrightarrow b_0)$：\n  - 低位子节点 (如果 $b_1=0$)：$f_1|_{b_1=0} = 0 \\wedge (a_0 \\leftrightarrow b_0) = 0$。\n  - 高位子节点 (如果 $b_1=1$)：$f_1|_{b_1=1} = 1 \\wedge (a_0 \\leftrightarrow b_0) = a_0 \\leftrightarrow b_0 = h$。\n  所以，$f_1$ 的节点是 $n_3 = (b_1, 0, h)$。\n节点 $n_2$ 和 $n_3$ 是不同的，因为它们的子节点元组 $(h, 0)$ 和 $(0, h)$ 不同。在这一层级不可能进行规约。\n\n**第 3 层：对 $a_0$ 进行分解**\n我们需要为函数 $h = a_0 \\leftrightarrow b_0$ 构建一个节点。\n- 低位子节点 (如果 $a_0=0$)：$h|_{a_0=0} = 0 \\leftrightarrow b_0 = \\neg b_0$。称之为 $k_0$。\n- 高位子节点 (如果 $a_0=1$)：$h|_{a_0=1} = 1 \\leftrightarrow b_0 = b_0$。称之为 $k_1$。\n$h$ 的节点是 $n_4 = (a_0, k_0, k_1)$。由于 $k_0 \\neq k_1$，此节点不是冗余的。\n\n**第 4 层：对 $b_0$ 进行分解**\n我们为 $k_0 = \\neg b_0$ 和 $k_1 = b_0$ 构建节点。\n- 对于 $k_0 = \\neg b_0$：\n  - 低位子节点 (如果 $b_0=0$)：$k_0|_{b_0=0} = \\neg 0 = 1$。\n  - 高位子节点 (如果 $b_0=1$)：$k_0|_{b_0=1} = \\neg 1 = 0$。\n  $k_0$ 的节点是 $n_5 = (b_0, 1, 0)$。\n- 对于 $k_1 = b_0$：\n  - 低位子节点 (如果 $b_0=0$)：$k_1|_{b_0=0} = 0$。\n  - 高位子节点 (如果 $b_0=1$)：$k_1|_{b_0=1} = 1$。\n  $k_1$ 的节点是 $n_6 = (b_0, 0, 1)$。\n节点 $n_5$ 和 $n_6$ 是不同的，因为它们的子节点元组 $(1, 0)$ 和 $(0, 1)$ 不同。\n\n**ROBDD 属性的构建后分析**\n通过在每个层级为唯一函数创建节点，构建过程本身就防止了同构子图的创建。我们必须验证没有节点是冗余的（即，低位和高位子节点相同）。\n- $n_1 = (a_1, n_2, n_3)$：不是冗余的，因为 $n_2 \\neq n_3$。\n- $n_2 = (b_1, n_4, 0)$：不是冗余的，因为 $n_4 \\neq 0$。\n- $n_3 = (b_1, 0, n_4)$：不是冗余的，因为 $0 \\neq n_4$。\n- $n_4 = (a_0, n_5, n_6)$：不是冗余的，因为 $n_5 \\neq n_6$。\n- $n_5 = (b_0, 1, 0)$：不是冗余的，因为 $1 \\neq 0$。\n- $n_6 = (b_0, 0, 1)$：不是冗余的，因为 $0 \\neq 1$。\n所有六个非终端节点都是必要的且不同的。\n\n最终的 ROBDD 由以下不同的非终端节点组成：\n1. $n_1$：变量 $a_1$ 的节点，其子节点指向 $n_2$ 和 $n_3$。\n2. $n_2$：变量 $b_1$ 的节点，其子节点指向 $n_4$ 和终端 $0$。\n3. $n_3$：变量 $b_1$ 的节点，其子节点指向终端 $0$ 和 $n_4$。\n4. $n_4$：变量 $a_0$ 的节点，其子节点指向 $n_5$ 和 $n_6$。\n5. $n_5$：变量 $b_0$ 的节点，其子节点指向终端 $1$ 和 $0$。\n6. $n_6$：变量 $b_0$ 的节点，其子节点指向终端 $0$ 和 $1$。\n\n不同的非终端节点的总数为 $6$。",
            "answer": "$$\n\\boxed{6}\n$$"
        },
        {
            "introduction": "在二元决策图的实际应用中，一个至关重要的概念是变量排序。一个好的排序可以得到一个简洁、高效的ROBDD，而一个糟糕的排序可能导致节点数量呈指数级爆炸。本练习以一个常见的多路选择器（MUX）函数为例，旨在通过分析不同变量顺序对ROBDD规模的影响，揭示选择合适的根变量如何能够显著简化图结构。掌握这一原理对于在验证和综合等任务中有效利用BDD至关重要。",
            "id": "4258051",
            "problem": "在电子设计自动化（EDA）中，布尔函数的既约有序二元决策图（ROBDD）表示在组合逻辑优化中扮演着关键角色。考虑一个$2$:$1$多路选择器的布尔函数，定义为 $f(s,x,y)=s x+\\overline{s} y$，其中 $s$ 是选择输入，$x,y$ 是数据输入。二元决策图（BDD）是一个无环有向图，其中每个非终端节点都由一个布尔变量标记，并有两条出边，分别对应于该函数在该变量下的协因子 $f_{v=0}$ 和 $f_{v=1}$；ROBDD 是通过应用两条标准的化简规则得到的：合并同构子图和消除其两个子节点相同的节点。有序BDD固定了一个变量的全序，所有从根到终端的路径都必须遵守这个顺序。使用布尔函数的Shannon分解 $f=v \\cdot f_{v=1}+\\overline{v}\\cdot f_{v=0}$（对于任意变量 $v$），以及所描述的ROBDD化简规则，分析变量排序对 $f(s,x,y)$ 的ROBDD规模的影响。\n\n关于 $f(s,x,y)$ 的最小ROBDD规模以及最优规模表示的根变量选择，哪个陈述是正确的？\n\nA. 当 $s$ 为根节点，其后无论是 $x$ 在 $y$ 之前还是 $y$ 在 $x$ 之前，最小ROBDD恰好有 $3$ 个非终端决策节点，而任何将 $s$ 置于 $x$ 或 $y$ 之后的排序至少有 $4$ 个非终端决策节点。\n\nB. 当 $x$ 为根节点并使用 $x,s,y$ 顺序时，最小ROBDD恰好有 $3$ 个非终端决策节点；将 $s$ 置于根节点会产生 $4$ 个或更多的非终端决策节点。\n\nC. 最小ROBDD规模与变量排序无关，对于所有可能的变量顺序，它都等于 $3$ 个非终端决策节点。\n\nD. 当 $y$ 为根节点且 $x$ 居次时，最小ROBDD恰好有 $3$ 个非终端决策节点；任何以 $s$ 为根的顺序都会产生至少 $5$ 个非终端决策节点。\n\nE. 当 $s$ 为根节点时，通过消除作为冗余节点的 $x$ 和 $y$ 节点，ROBDD会塌缩至恰好 $2$ 个非终端决策节点。",
            "solution": "我们从基本原理开始。对于布尔函数 $f(s,x,y)=s x+\\overline{s} y$，关于变量 $v$ 的Shannon分解是 $f=v \\cdot f_{v=1}+\\overline{v}\\cdot f_{v=0}$，其中 $f_{v=b}$ 是将 $v=b$ 代入 $f$ 中得到的协因子。在二元决策图（BDD）中，一个由 $v$ 标记的节点表示这个分解：高位边指向代表 $f_{v=1}$ 的子图，低位边指向代表 $f_{v=0}$ 的子图。既约有序二元决策图（ROBDD）应用两条化简规则：相同的子图被共享（同构子图被合并），以及其两个子节点相同的节点被消除（冗余测试）。有序BDD约束所有从根到终端的路径遵循一个固定的变量顺序。\n\n我们分析可能的变量顺序，并计算化简后的最小非终端决策节点数。\n\n情况1：$s$ 在最前。考虑顺序 $s,x,y$ 或 $s,y,x$。对 $s$ 使用Shannon分解，\n$$\nf(s,x,y)=s \\cdot f_{s=1}+\\overline{s} \\cdot f_{s=0},\\quad f_{s=1}=x,\\quad f_{s=0}=y.\n$$\nBDD有一个标记为 $s$ 的根节点，其高位子节点代表 $x$，低位子节点代表 $y$。在有序BDD中，子函数不依赖的变量可以通过化简规则跳过：如果一个由某个变量标记的节点，因为子函数不依赖于该变量而导致其两个子节点相同，那么该节点将被消除。因此，在 $s=1$ 分支上，子函数是 $x$，它由一个标记为 $x$ 的单节点表示，其高位边指向终端 $1$，低位边指向终端 $0$。在 $s=0$ 分支上，子函数是 $y$，类似地由一个标记为 $y$ 的单节点表示。$x$ 和 $y$ 节点之间没有进一步的共享，因为它们由不同的变量标记。因此，ROBDD恰好包含 $3$ 个非终端节点：一个 $s$ 节点，一个 $x$ 节点，和一个 $y$ 节点。\n\n情况2：$x$ 在最前，顺序为 $x,s,y$。计算协因子：\n$$\nf_{x=0}=\\overline{s} y,\\quad f_{x=1}=s+\\overline{s} y.\n$$\n根节点是 $x$。对于低位分支 $x=0$，顺序中的下一个变量是 $s$，有\n$$\nf_{x=0,s=1}=0,\\quad f_{x=0,s=0}=y.\n$$\n因此，对于 $x=0$ 的子图以一个标记为 $s$ 的节点开始，其高位边指向终端 $0$，低位边指向一个标记为 $y$ 的节点。对于高位分支 $x=1$，下一个变量同样是 $s$，有\n$$\nf_{x=1,s=1}=1,\\quad f_{x=1,s=0}=y.\n$$\n因此，对于 $x=1$ 的子图以一个标记为 $s$ 的节点开始，其高位边指向终端 $1$，低位边指向与上面相同的标记为 $y$ 的节点。这两个 $s$ 节点不能合并，因为它们的子节点不同：一个的子节点是 $\\{0,y\\}$（顺序为高位 $\\to 0$，低位 $\\to y$），另一个的子节点是 $\\{1,y\\}$（高位 $\\to 1$，低位 $\\to y$）。$y$ 节点被两个子图共享。因此，我们有 $4$ 个非终端节点：根节点 $x$，两个不同的 $s$ 节点，以及一个 $y$ 节点。\n\n情况3：$y$ 在最前，顺序为 $y,s,x$。通过与情况2的对称性，我们得到 $4$ 个非终端节点：根节点 $y$，$y=0$ 和 $y=1$ 分支下两个不同的 $s$ 节点，以及一个共享的 $x$ 节点。\n\n情况4：$s$ 在最后，顺序为 $x,y,s$。计算根节点 $x$ 的协因子：\n$$\nf_{x=0}=\\overline{s} y,\\quad f_{x=1}=s+\\overline{s} y.\n$$\n接下来处理 $y$：\n- 对于 $x=0$，$y=1$ 得到 $f_{x=0,y=1}=\\overline{s}$；$y=0$ 得到 $f_{x=0,y=0}=0$。$x=0$ 的 $y$ 节点的高位边指向一个标记为 $s$ 的节点，其子节点为低位 $\\to 1$，高位 $\\to 0$（代表 $\\overline{s}$），低位边指向终端 $0$。\n- 对于 $x=1$，$y=1$ 得到 $f_{x=1,y=1}=s+\\overline{s}=1$；$y=0$ 得到 $f_{x=1,y=0}=s$。$x=1$ 的 $y$ 节点的高位边指向终端 $1$，低位边指向一个标记为 $s$ 的节点，其子节点为低位 $\\to 0$，高位 $\\to 1$（代表 $s$）。\n\n这两个 $y$ 节点因其子节点不同而不能合并。这两个 $s$ 节点也不同（一个代表 $\\overline{s}$，另一个代表 $s$），所以它们不能合并。因此，我们有 $5$ 个非终端节点：根节点 $x$，两个不同的 $y$ 节点，以及两个不同的 $s$ 节点。对称顺序 $y,x,s$ 通过类似的推理得到相同的计数 $5$。\n\n从这些情况可以看出，当 $s$ 位于根节点时（其后 $x$ 和 $y$ 的顺序任意），可以实现最小的ROBDD规模，恰好产生 $3$ 个非终端决策节点。任何将 $s$ 置于 $x$ 或 $y$ 之后的排序需要至少 $4$ 个非终端决策节点，而将 $s$ 置于最后则需要 $5$ 个。其结构上的原因是，关于 $s$ 的Shannon分解产生的协因子 $f_{s=1}=x$ 和 $f_{s=0}=y$ 各等于一个单一变量，允许通过单节点子图直接表示。相比之下，首先按 $x$ 或 $y$ 分解会产生将 $s$ 与另一个变量混合的协因子，从而在不同分支下创建两个不同的 $s$ 标记节点，增加了节点数。\n\n逐项分析选项：\n- A. 正确。当 $s$ 为根节点时，ROBDD恰好有 $3$ 个非终端节点（$s$, $x$, $y$），而将 $s$ 置于 $x$ 或 $y$ 之后，由于在数据输入根节点下存在两个不同的 $s$ 节点，会产生至少 $4$ 个非终端节点。\n- B. 错误。顺序 $x,s,y$ 产生 $4$ 个非终端节点，而不是 $3$ 个；而将 $s$ 置于根节点得到 $3$ 个，而不是 $4$ 个或更多。\n- C. 错误。ROBDD规模取决于变量排序：$3$（$s$ 在最前），$4$（$x$ 或 $y$ 在最前且 $s$ 居次），和 $5$（$s$ 在最后）。\n- D. 错误。当 $y$ 为根节点且 $x$ 居次时，最小ROBDD有 $4$ 个非终端节点，而不是 $3$ 个；而以 $s$ 为根节点时，它有 $3$ 个，而不是 $5$ 个。\n- E. 错误。当 $s$ 为根节点时，子函数 $f_{s=1}=x$ 和 $f_{s=0}=y$ 各需要一个节点来表示变量 $x$ 和 $y$，因此该图有 $3$ 个非终端节点，而不是 $2$ 个。\n\n因此，正确选项是A。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在逻辑综合的实际场景中，我们常常利用“无关项”（don't-care conditions）来优化和简化布尔函数。本练习探讨了两种强大但语义上截然不同的ROBDD操作：限制（restrict）与约束（constrain）。通过将这两种操作应用于同一个函数和指定的“关心集”（care set），您将亲身体会它们如何以不同的方式利用无关项来简化逻辑，这对于理解高级逻辑优化技术至关重要。",
            "id": "4258033",
            "problem": "考虑一个用于集成电路逻辑综合的布尔函数 $f(x,y,z)$，它在变量顺序 $x \\prec y \\prec z$ 下表示为一个既约有序二元决策图（ROBDD）。该函数定义为\n$$\nf(x,y,z) = (x \\land y) \\lor (\\lnot x \\land z),\n$$\n其行为类似于一个由 $x$ 控制的二对一多路选择器，当 $x$ 为 $1$ 时选择 $y$，当 $x$ 为 $0$ 时选择 $z$。设关心集（约束）为布尔函数\n$$\nC(x,y,z) = y,\n$$\n它指定了仅在 $y=1$ 的赋值上要求 $f$ 的正确性；当 $y=0$ 时，该函数不受约束，可以在不违反规范的情况下进行修改。在基于 ROBDD 的操作中，通常区分两种运算：用 $C$ 对 $f$ 进行限制（restricting）和用 $C$ 对 $f$ 进行约束（constraining）。\n\n请选择一个选项，该选项正确地指出了将这两种运算应用于相同的 $f$ 和 $C$ 时所得到的布尔函数，并准确解释了这两种运算在关心集上与 $f$ 的一致性以及在关心集之外的行为方面的语义差异。\n\nA. 用 $C$ 限制 $f$ 得到 $x \\lor z$，而用 $C$ 约束 $f$ 得到 $y \\land (x \\lor z)$。限制操作确保在 $C=1$ 的地方与 $f$ 一致，并可能为了简化 ROBDD 而修改 $C=0$ 时的函数；而约束操作则全局强制执行 $C$，迫使结果在 $C=0$ 时为 $0$。\n\nB. 用 $C$ 限制 $f$ 得到 $y \\land (x \\lor z)$，而用 $C$ 约束 $f$ 得到 $x \\lor z$。两种运算都保证在所有赋值上都与 $f$ 相等。\n\nC. 用 $C$ 限制 $f$ 得到 $(x \\land y) \\lor (\\lnot x \\land z)$，而用 $C$ 约束 $f$ 得到 $y \\lor z$。限制操作完全保留了 $f$，而约束操作移除了对 $x$ 的依赖。\n\nD. 用 $C$ 限制 $f$ 得到 $x \\lor z$，而用 $C$ 约束 $f$ 也得到 $x \\lor z$。两种运算都去掉了 $y$ 并保留了所有赋值上的值。",
            "solution": "经过严格评估，问题陈述是有效的。它在科学上基于逻辑综合和布尔代数的原理，特别是关于既约有序二元决策图（ROBDD）和无关项优化。函数 $f$ 和 $C$ 的定义、变量顺序以及相关操作的定义都足够明确，足以确定一个唯一的正确答案。尽管术语“restrict”和“constrain”在不同的工具和文献中可能有不同的用法，但该问题的结构要求正确选项必须同时提供正确的语义定义，从而消除了任何歧义。\n\n给定的布尔函数是 $f(x,y,z) = (x \\land y) \\lor (\\lnot x \\land z)$。该函数是一个二对一多路选择器，等效于 If-Then-Else 表达式 $ITE(x, y, z)$。\n关心集由函数 $C(x,y,z) = y$ 给出。这意味着函数 $f$ 的行为仅在输入满足 $y=1$ 时被指定。对于输入满足 $y=0$ 的情况，函数的输出是“无关项”。\n\n我们必须分析两种不同的运算：用 $C$ 约束 $f$ 和用 $C$ 限制 $f$。选项中提供了区分这两种运算的语义描述。在逻辑综合中，与选项一致的标准解释如下：\n\n1.  **用 $C$ 约束 $f$**：该运算可表示为 $f \\land C$，它生成一个在关心集（其中 $C=1$）上与 $f$ 一致，并在无关集（其中 $C=0$）上强制为 $0$ 的函数。\n2.  **用 $C$ 限制 $f$**：该运算通常称为广义余子式，记作 $f|_C$，它生成一个简化的函数 $g$，该函数在关心集上与 $f$ 一致（即 $g \\land C = f \\land C$）。在无关集上 $g$ 的值被选择以实现最大程度的简化（例如，创建一个更小的 ROBDD）。\n\n现在我们来计算每种运算得到的结果函数。\n\n**1. 计算用 $C$ 约束 $f$ 的结果**\n\n约束后的函数，我们称之为 $f_{constrained}$，由 $f$ 和 $C$ 的逻辑与运算给出。\n$$\nf_{constrained}(x,y,z) = f(x,y,z) \\land C(x,y,z)\n$$\n代入给定的函数：\n$$\nf_{constrained} = ((x \\land y) \\lor (\\lnot x \\land z)) \\land y\n$$\n使用 $\\land$ 对 $\\lor$ 的分配律：\n$$\nf_{constrained} = (x \\land y \\land y) \\lor (\\lnot x \\land y \\land z)\n$$\n使用幂等律 ($y \\land y = y$)：\n$$\nf_{constrained} = (x \\land y) \\lor (\\lnot x \\land y \\land z)\n$$\n提取公因式 $y$：\n$$\nf_{constrained} = y \\land (x \\lor (\\lnot x \\land z))\n$$\n应用分配律 $A \\lor (B \\land C) = (A \\lor B) \\land (A \\lor C)$：\n$$\nf_{constrained} = y \\land ((x \\lor \\lnot x) \\land (x \\lor z))\n$$\n使用排中律 ($x \\lor \\lnot x = 1$)：\n$$\nf_{constrained} = y \\land (1 \\land (x \\lor z))\n$$\n使用同一律 ($1 \\land A = A$)：\n$$\nf_{constrained} = y \\land (x \\lor z)\n$$\n所以，用 $C$ 约束 $f$ 得到的函数是 $y \\land (x \\lor z)$。\n\n**2. 计算用 $C$ 限制 $f$ 的结果**\n\n限制后的函数，我们称之为 $f_{restricted}$，必须在 $C=1$ 时与 $f$ 一致。也就是说，对于所有的 $x$ 和 $z$，我们要求 $f_{restricted}(x,1,z) = f(x,1,z)$。对于 $y=0$ 时的行为可以自由选择，以简化整体表达式。\n首先计算 $f$ 在关心集 $y=1$ 上的值：\n$$\nf(x,1,z) = (x \\land 1) \\lor (\\lnot x \\land z)\n$$\n$$\nf(x,1,z) = x \\lor (\\lnot x \\land z)\n$$\n如前一样使用分配律：\n$$\nf(x,1,z) = (x \\lor \\lnot x) \\land (x \\lor z) = 1 \\land (x \\lor z) = x \\lor z\n$$\n当 $y=1$ 时，函数 $f$ 简化为 $x \\lor z$。表达式 $x \\lor z$ 本身不依赖于 $y$。因此，我们可以选择 $f_{restricted}(x,y,z) = x \\lor z$作为我们的简化函数。这个选择满足在关心集上与 $f$ 一致的条件，因为当 $y=1$ 时，$f_{restricted}(x,1,z) = x \\lor z = f(x,1,z)$。它比原始函数 $f$ 更简单，因为它与变量 $y$ 无关。在变量顺序为 $x \\prec y \\prec z$ 的 ROBDD 表示中，所有 $x$ 的节点将直接指向 $z$ 的节点，绕过任何 $y$ 的节点。\n所以，用 $C$ 限制 $f$ 得到的函数是 $x \\lor z$。\n\n**结果总结：**\n-   用 $C$ 限制 $f$ 的结果：$x \\lor z$\n-   用 $C$ 约束 $f$ 的结果：$y \\land (x \\lor z)$\n\n现在，我们根据这些推导出的结果和语义解释来评估每个选项。\n\n**选项 A:**\n-   **函数：**“用 $C$ 限制 $f$ 得到 $x \\lor z$，而用 $C$ 约束 $f$ 得到 $y \\land (x \\lor z)$。”这与我们的计算完全匹配。\n-   **解释：**“限制操作确保在 $C=1$ 的地方与 $f$ 一致，并可能为了简化 ROBDD 而修改 $C=0$ 时的函数；而约束操作则全局强制执行 $C$，迫使结果在 $C=0$ 时为 $0$。”这个解释完美地描述了我们定义和使用的这两种运算的语义。“限制”运算将 $C=0$ 的空间用作无关项以进行简化。“约束”运算是与 $C$ 的逻辑与，根据定义，当 $C=0$ 时，其结果为 $0$。\n-   **结论：正确**。\n\n**选项 B:**\n-   **函数：**“用 $C$ 限制 $f$ 得到 $y \\land (x \\lor z)$，而用 $C$ 约束 $f$ 得到 $x \\lor z$。”这颠倒了结果。\n-   **解释：**“两种运算都保证在所有赋值上都与 $f$ 相等。”这在事实上是错误的。两种运算都在无关集（$y=0$）上改变了函数。\n-   **结论：错误**。\n\n**选项 C:**\n-   **函数：**“用 $C$ 限制 $f$ 得到 $(x \\land y) \\lor (\\lnot x \\land z)$，而用 $C$ 约束 $f$ 得到 $y \\lor z$。”限制操作的结果是原始函数 $f$，这未能执行简化。约束操作的结果是 $y \\lor z$，这是错误的；我们的计算得出的是 $y \\land (x \\lor z)$。\n-   **解释：**“限制操作完全保留了 $f$，而约束操作移除了对 $x$ 的依赖。”解释的两个部分都是错误的。\n-   **结论：错误**。\n\n**选项 D:**\n-   **函数：**“用 $C$ 限制 $f$ 得到 $x \\lor z$，而用 $C$ 约束 $f$ 也得到 $x \\lor z$。”约束操作的结果是错误的。约束后的函数在 $y=0$ 时必须为 $0$，但 $x \\lor z$ 在 $y=0$ 时不一定为 $0$。\n-   **解释：**“两种运算都去掉了 $y$ 并保留了所有赋值上的值。”约束后的函数 $y \\land (x \\lor z)$ 并没有去掉 $y$。并且如选项 B 所述，值并没有在所有赋值上都得到保留。\n-   **结论：错误**。\n\n只有选项 A 正确地指出了两个结果函数以及这两种标准逻辑综合运算之间的语义差异。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}