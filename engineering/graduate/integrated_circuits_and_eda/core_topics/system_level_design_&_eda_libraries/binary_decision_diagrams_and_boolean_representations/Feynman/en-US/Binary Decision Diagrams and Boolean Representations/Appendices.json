{
    "hands_on_practices": [
        {
            "introduction": "This first practice is designed to build your foundational skills by walking through the complete process of creating a Reduced Ordered Binary Decision Diagram (ROBDD). Starting with a standard logic gate, a two-bit comparator, you will first transform its representation from Conjunctive Normal Form (CNF) to Disjunctive Normal Form (DNF). Then, you will apply the fundamental Shannon decomposition step-by-step to construct the final ROBDD, gaining direct experience with the core mechanics of BDD creation and reduction. ",
            "id": "4258062",
            "problem": "Consider a two-bit equality comparator used in Electronic Design Automation (EDA). Let the two-bit inputs be $A=(a_{1},a_{0})$ and $B=(b_{1},b_{0})$. The comparator output $E(A,B)$ is a Boolean function that evaluates to $1$ if and only if $A=B$. Suppose $E$ is specified in Conjunctive Normal Form (CNF) as the conjunction of four clauses:\n$$\n(\\neg a_{1} \\vee b_{1}) \\wedge (\\neg b_{1} \\vee a_{1}) \\wedge (\\neg a_{0} \\vee b_{0}) \\wedge (\\neg b_{0} \\vee a_{0}).\n$$\nStarting from this CNF:\n- First, use Boolean algebra and distributivity to derive an equivalent Disjunctive Normal Form (DNF) for $E$, showing all steps and justifications using only the foundational laws and identities of Boolean algebra.\n- Next, construct the Binary Decision Diagram (BDD) of $E$ via the Shannon decomposition $f=(x \\wedge f|_{x=1}) \\vee (\\neg x \\wedge f|_{x=0})$ with the ordered variable sequence $a_{1} \\prec b_{1} \\prec a_{0} \\prec b_{0}$. Apply the standard reduction rules to obtain the Reduced Ordered Binary Decision Diagram (ROBDD): merge isomorphic subgraphs (unique table) and eliminate redundant tests (a node whose low and high children are identical is bypassed).\n- Detail each decomposition step and every reduction applied. For the final answer, report the total number of distinct non-terminal nodes in the resulting ROBDD under the given variable ordering. Non-terminal nodes are those labeled by decision variables; terminal nodes labeled $0$ or $1$ are not to be counted.\n\nExpress the final answer as a single real-valued number with no units. No rounding is required.",
            "solution": "The problem is first subjected to a rigorous validation process.\n\n### Step 1: Extract Givens\n- **Inputs**: Two $2$-bit binary numbers, $A=(a_{1},a_{0})$ and $B=(b_{1},b_{0})$.\n- **Function Definition**: The output $E(A,B)$ is a Boolean function that equals $1$ if and only if $A=B$.\n- **Initial Representation**: The function $E$ is provided in Conjunctive Normal Form (CNF):\n$$E = (\\neg a_{1} \\vee b_{1}) \\wedge (\\neg b_{1} \\vee a_{1}) \\wedge (\\neg a_{0} \\vee b_{0}) \\wedge (\\neg b_{0} \\vee a_{0})$$\n- **Task 1**: Derive an equivalent Disjunctive Normal Form (DNF) for $E$ from the given CNF using Boolean algebra, showing all steps.\n- **Task 2**: Construct the Reduced Ordered Binary Decision Diagram (ROBDD) for $E$.\n- **Variable Ordering**: The ordering for the BDD construction is specified as $a_{1} \\prec b_{1} \\prec a_{0} \\prec b_{0}$.\n- **Construction Method**: Shannon decomposition, $f=(x \\wedge f|_{x=1}) \\vee (\\neg x \\wedge f|_{x=0})$, which is equivalent to the if-then-else form $f = \\text{ITE}(x, f|_{x=1}, f|_{x=0})$.\n- **Reduction Rules**: Merge isomorphic subgraphs and eliminate redundant test nodes.\n- **Required Output**: Report the total number of distinct non-terminal nodes in the final ROBDD.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientific Grounding**: The problem is grounded in the fundamental principles of Boolean algebra and digital logic design. The concepts of CNF, DNF, Binary Decision Diagrams (BDDs), Shannon decomposition, and ROBDDs are standard in computer science and electronic design automation. The Boolean function for a comparator is well-defined. The provided CNF for $E$ correctly represents the equality condition. The clause $(\\neg x \\vee y) \\wedge (\\neg y \\vee x)$ is the standard CNF representation of the logical equivalence $x \\leftrightarrow y$. Thus, the given expression is equivalent to $(a_1 \\leftrightarrow b_1) \\wedge (a_0 \\leftrightarrow b_0)$, which is the correct logic for a two-bit equality comparator. The problem is scientifically sound.\n2.  **Well-Posedness**: The tasks are clearly stated. Deriving a DNF is a standard algebraic manipulation. Constructing an ROBDD with a fixed variable ordering is an algorithmic process that yields a unique, canonical representation. The final query for the number of non-terminal nodes is a well-defined, singular value.\n3.  **Objectivity**: The problem is stated using formal mathematical notation and terminology, leaving no room for subjective interpretation.\n4.  **Completeness**: All necessary information, including the function's initial form, the variable ordering, and the construction/reduction rules, is provided. The problem is self-contained.\n\n### Step 3: Verdict and Action\nThe problem is valid as it is scientifically grounded, well-posed, objective, and complete. Proceeding with the solution.\n\n### Part 1: Derivation of Disjunctive Normal Form (DNF)\nThe given Boolean function is:\n$$E = (\\neg a_{1} \\vee b_{1}) \\wedge (\\neg b_{1} \\vee a_{1}) \\wedge (\\neg a_{0} \\vee b_{0}) \\wedge (\\neg b_{0} \\vee a_{0})$$\nThis can be grouped into two parts, one for each bit comparison:\n$$E = [(\\neg a_{1} \\vee b_{1}) \\wedge (\\neg b_{1} \\vee a_{1})] \\wedge [(\\neg a_{0} \\vee b_{0}) \\wedge (\\neg b_{0} \\vee a_{0})]$$\nLet's define $E_1 = (\\neg a_{1} \\vee b_{1}) \\wedge (\\neg b_{1} \\vee a_{1})$ and $E_0 = (\\neg a_{0} \\vee b_{0}) \\wedge (\\neg b_{0} \\vee a_{0})$. These represent the equivalence functions $a_1 \\leftrightarrow b_1$ and $a_0 \\leftrightarrow b_0$, respectively.\n\nFirst, we convert $E_1$ to DNF using the distributive law, $p \\wedge (q \\vee r) = (p \\wedge q) \\vee (p \\wedge r)$:\n$$E_1 = ((\\neg a_1 \\vee b_1) \\wedge \\neg b_1) \\vee ((\\neg a_1 \\vee b_1) \\wedge a_1)$$\nApply distributivity again:\n$$E_1 = (\\neg a_1 \\wedge \\neg b_1) \\vee (b_1 \\wedge \\neg b_1) \\vee (\\neg a_1 \\wedge a_1) \\vee (b_1 \\wedge a_1)$$\nUsing the complementary law ($p \\wedge \\neg p = 0$) and the identity law ($p \\vee 0 = p$):\n$$E_1 = (\\neg a_1 \\wedge \\neg b_1) \\vee 0 \\vee 0 \\vee (a_1 \\wedge b_1)$$\n$$E_1 = (\\neg a_1 \\wedge \\neg b_1) \\vee (a_1 \\wedge b_1)$$\nThis is the DNF for $a_1=b_1$. By identical logic, the DNF for $E_0$ is:\n$$E_0 = (\\neg a_0 \\wedge \\neg b_0) \\vee (a_0 \\wedge b_0)$$\nNow we compute $E = E_1 \\wedge E_0$:\n$$E = [(\\neg a_1 \\wedge \\neg b_1) \\vee (a_1 \\wedge b_1)] \\wedge [(\\neg a_0 \\wedge \\neg b_0) \\vee (a_0 \\wedge b_0)]$$\nLet $X = (\\neg a_1 \\wedge \\neg b_1)$, $Y = (a_1 \\wedge b_1)$, $Z = (\\neg a_0 \\wedge \\neg b_0)$, and $W = (a_0 \\wedge b_0)$. The expression is $(X \\vee Y) \\wedge (Z \\vee W)$. Applying distributivity:\n$$E = (X \\wedge Z) \\vee (X \\wedge W) \\vee (Y \\wedge Z) \\vee (Y \\wedge W)$$\nSubstituting back the original terms:\n$X \\wedge Z = (\\neg a_1 \\wedge \\neg b_1) \\wedge (\\neg a_0 \\wedge \\neg b_0) = \\neg a_1 \\wedge \\neg b_1 \\wedge \\neg a_0 \\wedge \\neg b_0$\n$X \\wedge W = (\\neg a_1 \\wedge \\neg b_1) \\wedge (a_0 \\wedge b_0) = \\neg a_1 \\wedge \\neg b_1 \\wedge a_0 \\wedge b_0$\n$Y \\wedge Z = (a_1 \\wedge b_1) \\wedge (\\neg a_0 \\wedge \\neg b_0) = a_1 \\wedge b_1 \\wedge \\neg a_0 \\wedge \\neg b_0$\n$Y \\wedge W = (a_1 \\wedge b_1) \\wedge (a_0 \\wedge b_0) = a_1 \\wedge b_1 \\wedge a_0 \\wedge b_0$\n\nCombining these gives the final DNF for $E$:\n$$E = (\\neg a_1 \\wedge \\neg b_1 \\wedge \\neg a_0 \\wedge \\neg b_0) \\vee (\\neg a_1 \\wedge \\neg b_1 \\wedge a_0 \\wedge b_0) \\vee (a_1 \\wedge b_1 \\wedge \\neg a_0 \\wedge \\neg b_0) \\vee (a_1 \\wedge b_1 \\wedge a_0 \\wedge b_0)$$\nThis DNF represents the four conditions under which $A=B$.\n\n### Part 2: Construction of the Reduced Ordered Binary Decision Diagram (ROBDD)\nWe construct the ROBDD top-down following the variable order $a_{1} \\prec b_{1} \\prec a_{0} \\prec b_{0}$. We will denote a non-terminal node as a tuple $(v, l, h)$, where $v$ is the decision variable, $l$ is the low-child (for $v=0$) and $h$ is the high-child (for $v=1$). The terminal nodes are $0$ and $1$.\n\n**Level 1: Decompose on $a_1$**\nThe root node is for variable $a_1$. We compute its children functions using Shannon's expansion on $E = (a_1 \\leftrightarrow b_1) \\wedge (a_0 \\leftrightarrow b_0)$.\n- Low child (if $a_1=0$): $E|_{a_1=0} = (0 \\leftrightarrow b_1) \\wedge (a_0 \\leftrightarrow b_0) = \\neg b_1 \\wedge (a_0 \\leftrightarrow b_0)$. Let's call this function $f_0$.\n- High child (if $a_1=1$): $E|_{a_1=1} = (1 \\leftrightarrow b_1) \\wedge (a_0 \\leftrightarrow b_0) = b_1 \\wedge (a_0 \\leftrightarrow b_0)$. Let's call this function $f_1$.\nThe root node is $n_1 = (a_1, f_0, f_1)$.\n\n**Level 2: Decompose on $b_1$**\nWe now construct nodes for $f_0$ and $f_1$.\n- For $f_0 = \\neg b_1 \\wedge (a_0 \\leftrightarrow b_0)$:\n  - Low child (if $b_1=0$): $f_0|_{b_1=0} = \\neg 0 \\wedge (a_0 \\leftrightarrow b_0) = 1 \\wedge (a_0 \\leftrightarrow b_0) = a_0 \\leftrightarrow b_0$. Let's call this function $h$.\n  - High child (if $b_1=1$): $f_0|_{b_1=1} = \\neg 1 \\wedge (a_0 \\leftrightarrow b_0) = 0 \\wedge (a_0 \\leftrightarrow b_0) = 0$.\n  So, the node for $f_0$ is $n_2 = (b_1, h, 0)$.\n- For $f_1 = b_1 \\wedge (a_0 \\leftrightarrow b_0)$:\n  - Low child (if $b_1=0$): $f_1|_{b_1=0} = 0 \\wedge (a_0 \\leftrightarrow b_0) = 0$.\n  - High child (if $b_1=1$): $f_1|_{b_1=1} = 1 \\wedge (a_0 \\leftrightarrow b_0) = a_0 \\leftrightarrow b_0 = h$.\n  So, the node for $f_1$ is $n_3 = (b_1, 0, h)$.\nThe nodes $n_2$ and $n_3$ are distinct since their children tuples $(h, 0)$ and $(0, h)$ are different. No reduction is possible at this level.\n\n**Level 3: Decompose on $a_0$**\nWe need to construct a node for the function $h = a_0 \\leftrightarrow b_0$.\n- Low child (if $a_0=0$): $h|_{a_0=0} = 0 \\leftrightarrow b_0 = \\neg b_0$. Call this $k_0$.\n- High child (if $a_0=1$): $h|_{a_0=1} = 1 \\leftrightarrow b_0 = b_0$. Call this $k_1$.\nThe node for $h$ is $n_4 = (a_0, k_0, k_1)$. Since $k_0 \\neq k_1$, this node is not redundant.\n\n**Level 4: Decompose on $b_0$**\nWe construct nodes for $k_0 = \\neg b_0$ and $k_1 = b_0$.\n- For $k_0 = \\neg b_0$:\n  - Low child (if $b_0=0$): $k_0|_{b_0=0} = \\neg 0 = 1$.\n  - High child (if $b_0=1$): $k_0|_{b_0=1} = \\neg 1 = 0$.\n  The node for $k_0$ is $n_5 = (b_0, 1, 0)$.\n- For $k_1 = b_0$:\n  - Low child (if $b_0=0$): $k_1|_{b_0=0} = 0$.\n  - High child (if $b_0=1$): $k_1|_{b_0=1} = 1$.\n  The node for $k_1$ is $n_6 = (b_0, 0, 1)$.\nThe nodes $n_5$ and $n_6$ are distinct, as their children tuples $(1, 0)$ and $(0, 1)$ differ.\n\n**Post-construction Analysis for ROBDD Properties**\nThe construction process, by creating nodes for unique functions at each level, inherently prevents the creation of isomorphic subgraphs. We must verify that no nodes are redundant (i.e., having identical low and high children).\n- $n_1 = (a_1, n_2, n_3)$: Not redundant as $n_2 \\neq n_3$.\n- $n_2 = (b_1, n_4, 0)$: Not redundant as $n_4 \\neq 0$.\n- $n_3 = (b_1, 0, n_4)$: Not redundant as $0 \\neq n_4$.\n- $n_4 = (a_0, n_5, n_6)$: Not redundant as $n_5 \\neq n_6$.\n- $n_5 = (b_0, 1, 0)$: Not redundant as $1 \\neq 0$.\n- $n_6 = (b_0, 0, 1)$: Not redundant as $0 \\neq 1$.\nAll six non-terminal nodes are necessary and distinct.\n\nThe final ROBDD consists of the following distinct non-terminal nodes:\n1. $n_1$: A node for variable $a_1$ with children pointing to $n_2$ and $n_3$.\n2. $n_2$: A node for variable $b_1$ with children pointing to $n_4$ and the terminal $0$.\n3. $n_3$: A node for variable $b_1$ with children pointing to the terminal $0$ and $n_4$.\n4. $n_4$: A node for variable $a_0$ with children pointing to $n_5$ and $n_6$.\n5. $n_5$: A node for variable $b_0$ with children pointing to the terminals $1$ and $0$.\n6. $n_6$: A node for variable $b_0$ with children pointing to the terminals $0$ and $1$.\n\nThe total count of distinct non-terminal nodes is $6$.",
            "answer": "$$\n\\boxed{6}\n$$"
        },
        {
            "introduction": "Now that you have practiced the mechanics of constructing an ROBDD, this exercise focuses on a critical aspect of their efficiency: variable ordering. Using the ubiquitous multiplexer function, you will explore how different orderings of the input variables can lead to dramatically different ROBDD sizes. This practice illuminates why choosing a good variable order is paramount for leveraging the power of BDDs in complex problem-solving. ",
            "id": "4258051",
            "problem": "In Electronic Design Automation (EDA), Reduced Ordered Binary Decision Diagram (ROBDD) representations of Boolean functions play a critical role in combinational logic optimization. Consider the Boolean function for a $2$:$1$ multiplexor, defined as $f(s,x,y)=s x+\\overline{s} y$, where $s$ is the select input and $x,y$ are the data inputs. A Binary Decision Diagram (BDD) is an acyclic directed graph in which each non-terminal node is labeled by a Boolean variable and has two outgoing edges corresponding to the cofactors $f_{v=0}$ and $f_{v=1}$ of the function under that variable; an ROBDD results from applying two standard reduction rules: merging isomorphic subgraphs and eliminating nodes whose two children are identical. An Ordered BDD fixes a total order of variables that must be respected along all root-to-terminal paths. Using the Shannon decomposition for Boolean functions, $f=v \\cdot f_{v=1}+\\overline{v}\\cdot f_{v=0}$ for any variable $v$, and the ROBDD reduction rules described, analyze the effect of variable ordering on the ROBDD size of $f(s,x,y)$.\n\nWhich statement is correct about the minimal ROBDD size and the choice of the root variable for an optimal-size representation of $f(s,x,y)$?\n\nA. With $s$ at the root and either $x$ before $y$ or $y$ before $x$ thereafter, the minimal ROBDD has exactly $3$ non-terminal decision nodes, whereas any ordering that places $s$ after $x$ or $y$ has at least $4$ non-terminal decision nodes.\n\nB. With $x$ at the root using the order $x,s,y$, the minimal ROBDD has exactly $3$ non-terminal decision nodes; placing $s$ at the root yields $4$ or more non-terminal decision nodes.\n\nC. The minimal ROBDD size is independent of variable ordering and equals $3$ non-terminal decision nodes for all possible variable orders.\n\nD. With $y$ at the root and $x$ second, the minimal ROBDD has exactly $3$ non-terminal decision nodes; any order with $s$ at the root produces at least $5$ non-terminal decision nodes.\n\nE. With $s$ at the root, the ROBDD collapses to exactly $2$ non-terminal decision nodes by eliminating both $x$ and $y$ nodes as redundant.",
            "solution": "We begin from first principles. For a Boolean function $f(s,x,y)=s x+\\overline{s} y$, the Shannon decomposition with respect to a variable $v$ is $f=v \\cdot f_{v=1}+\\overline{v}\\cdot f_{v=0}$, where $f_{v=b}$ is the cofactor obtained by substituting $v=b$ into $f$. In a Binary Decision Diagram (BDD), a node labeled by $v$ represents this decomposition: the high edge goes to a subgraph representing $f_{v=1}$ and the low edge goes to a subgraph representing $f_{v=0}$. A Reduced Ordered Binary Decision Diagram (ROBDD) applies two reduction rules: identical subgraphs are shared (isomorphic subgraphs are merged), and nodes whose two children are identical are eliminated (redundant tests). An Ordered BDD constrains all root-to-terminal paths to follow a fixed variable order.\n\nWe analyze possible variable orders and count minimal non-terminal decision nodes after reductions.\n\nCase $1$: $s$ first. Consider either order $s,x,y$ or $s,y,x$. Using Shannon decomposition with respect to $s$,\n$$\nf(s,x,y)=s \\cdot f_{s=1}+\\overline{s} \\cdot f_{s=0},\\quad f_{s=1}=x,\\quad f_{s=0}=y.\n$$\nThe BDD has a root node labeled $s$, with high child representing $x$ and low child representing $y$. In an Ordered BDD, variables not dependent in a subfunction can be skipped via the reduction rule: if a node labeled by a variable would have identical children because the subfunction is independent of that variable, that node is eliminated. Thus, on the $s=1$ branch the subfunction is $x$, which is represented by a single node labeled $x$ with high edge to the terminal $1$ and low edge to the terminal $0$. On the $s=0$ branch the subfunction is $y$, represented similarly by a single node labeled $y$. There is no further sharing between the $x$ and $y$ nodes because they are labeled by different variables. Therefore, the ROBDD contains exactly $3$ non-terminal nodes: one node for $s$, one node for $x$, and one node for $y$.\n\nCase $2$: $x$ first, order $x,s,y$. Compute the cofactors:\n$$\nf_{x=0}=\\overline{s} y,\\quad f_{x=1}=s+\\overline{s} y.\n$$\nThe root node is $x$. For the low branch $x=0$, the next variable in the order is $s$, with\n$$\nf_{x=0,s=1}=0,\\quad f_{x=0,s=0}=y.\n$$\nThus, the subgraph for $x=0$ begins with a node labeled $s$ whose high edge goes to terminal $0$ and low edge goes to a node labeled $y$. For the high branch $x=1$, again the next variable is $s$, with\n$$\nf_{x=1,s=1}=1,\\quad f_{x=1,s=0}=y.\n$$\nThus, the subgraph for $x=1$ begins with a node labeled $s$ whose high edge goes to terminal $1$ and low edge goes to the same node labeled $y$ as above. The two $s$ nodes cannot be merged because their children differ: one has children $\\{0,y\\}$ (ordered as high $\\to 0$, low $\\to y$), and the other has children $\\{1,y\\}$ (high $\\to 1$, low $\\to y$). The $y$ node is shared by both subgraphs. Therefore, we have $4$ non-terminal nodes: the root $x$, two distinct $s$ nodes, and one $y$ node.\n\nCase $3$: $y$ first, order $y,s,x$. By symmetry with Case $2$, we obtain $4$ non-terminal nodes: the root $y$, two distinct $s$ nodes under $y=0$ and $y=1$ branches, and one $x$ node shared.\n\nCase $4$: $s$ last, order $x,y,s$. Compute cofactors at the root $x$:\n$$\nf_{x=0}=\\overline{s} y,\\quad f_{x=1}=s+\\overline{s} y.\n$$\nProceed to $y$ next:\n- For $x=0$, $y=1$ gives $f_{x=0,y=1}=\\overline{s}$; $y=0$ gives $f_{x=0,y=0}=0$. The $y$-node for $x=0$ has high edge to a node labeled $s$ with children low $\\to 1$, high $\\to 0$ (representing $\\overline{s}$), and low edge to terminal $0$.\n- For $x=1$, $y=1$ gives $f_{x=1,y=1}=s+\\overline{s}=1$; $y=0$ gives $f_{x=1,y=0}=s$. The $y$-node for $x=1$ has high edge to terminal $1$ and low edge to a node labeled $s$ with children low $\\to 0$, high $\\to 1$ (representing $s$).\n\nThe two $y$ nodes differ in their children and cannot be merged. The two $s$ nodes also differ (one represents $\\overline{s}$ and the other represents $s$), so they cannot be merged. Thus, we have $5$ non-terminal nodes: the root $x$, two distinct $y$ nodes, and two distinct $s$ nodes. The symmetric order $y,x,s$ yields the same count $5$ by analogous reasoning.\n\nFrom these cases, the minimal ROBDD size is achieved when $s$ is at the root (with either order of $x$ and $y$ thereafter), yielding exactly $3$ non-terminal decision nodes. Any ordering that places $s$ after $x$ or $y$ requires at least $4$ non-terminal decision nodes, and placing $s$ last requires $5$. The structural reason is that Shannon decomposition with respect to $s$ yields cofactors $f_{s=1}=x$ and $f_{s=0}=y$, each equal to a single variable, allowing direct representation by single-node subgraphs. In contrast, decomposing first by $x$ or $y$ produces cofactors that mix $s$ with another variable, creating two distinct $s$-labeled nodes under different branches and increasing the node count.\n\nOption-by-option analysis:\n- A. Correct. With $s$ at the root, the ROBDD has exactly $3$ non-terminal nodes ($s$, $x$, $y$), and placing $s$ after $x$ or $y$ yields at least $4$ non-terminal nodes by the presence of two distinct $s$ nodes under the data-input root.\n- B. Incorrect. The order $x,s,y$ produces $4$ non-terminal nodes, not $3$, and placing $s$ at the root gives $3$, not $4$ or more.\n- C. Incorrect. The ROBDD size depends on variable ordering: $3$ ($s$ first), $4$ ($x$ first or $y$ first with $s$ second), and $5$ ($s$ last).\n- D. Incorrect. With $y$ at the root and $x$ second, the minimal ROBDD has $4$ non-terminal nodes, not $3$, and with $s$ at the root it has $3$, not $5$.\n- E. Incorrect. With $s$ at the root, the subfunctions $f_{s=1}=x$ and $f_{s=0}=y$ require one node each to represent the variables $x$ and $y$, so the diagram has $3$ non-terminal nodes, not $2$.\n\nTherefore, the correct choice is A.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Beyond simply representing Boolean functions, BDDs are powerful tools for logic manipulation and optimization. This final practice delves into a key application in logic synthesis: using don't-care conditions to simplify circuits. By distinguishing between the `restrict` and `constrain` operations, you will see how BDDs can intelligently exploit unspecified behaviors to produce simpler, more efficient logic, a common and vital task in electronic design automation. ",
            "id": "4258033",
            "problem": "Consider a Boolean function $f(x,y,z)$ used in logic synthesis for integrated circuits, represented as a Reduced Ordered Binary Decision Diagram (ROBDD) under the variable order $x \\prec y \\prec z$. The function is defined by\n$$\nf(x,y,z) = (x \\land y) \\lor (\\lnot x \\land z),\n$$\nwhich behaves as a two-to-one multiplexer controlled by $x$, selecting $y$ when $x$ is $1$ and $z$ when $x$ is $0$. Let the care set (constraint) be the Boolean function\n$$\nC(x,y,z) = y,\n$$\nwhich specifies that correctness of $f$ is only required on assignments with $y=1$; when $y=0$, the function is unconstrained and may be altered without violating the specification. In the context of ROBDD-based manipulation, two operations are commonly distinguished: restricting $f$ by $C$ and constraining $f$ by $C$.\n\nSelect the option that correctly identifies the resulting Boolean functions of applying both operations to the same $f$ and $C$, and that accurately explains the semantic difference between the operations with respect to agreement with $f$ on the care set and behavior outside the care set.\n\nA. Restricting $f$ by $C$ yields $x \\lor z$, while constraining $f$ by $C$ yields $y \\land (x \\lor z)$. Restrict ensures agreement with $f$ where $C=1$ and may modify the function for $C=0$ to simplify the ROBDD, whereas constrain enforces $C$ globally, forcing the result to be $0$ whenever $C=0$.\n\nB. Restricting $f$ by $C$ yields $y \\land (x \\lor z)$, while constraining $f$ by $C$ yields $x \\lor z$. Both operations guarantee equality to $f$ on all assignments.\n\nC. Restricting $f$ by $C$ yields $(x \\land y) \\lor (\\lnot x \\land z)$, while constraining $f$ by $C$ yields $y \\lor z$. Restrict preserves $f$ exactly, and constrain removes dependence on $x$.\n\nD. Restricting $f$ by $C$ yields $x \\lor z$, while constraining $f$ by $C$ yields $x \\lor z$. Both operations drop $y$ and preserve values on all assignments.",
            "solution": "The problem statement is critically evaluated and found to be valid. It is scientifically grounded in the principles of logic synthesis and Boolean algebra, specifically concerning Reduced Ordered Binary Decision Diagrams (ROBDDs) and don't-care optimization. The definitions of the functions $f$ and $C$, the variable order, and the operations are sufficiently well-posed to determine a unique, correct answer. While the terms \"restrict\" and \"constrain\" can have varied usage across different tools and texts, the problem is structured such that the correct option must also provide the correct semantic definitions, thereby resolving any ambiguity.\n\nThe given Boolean function is $f(x,y,z) = (x \\land y) \\lor (\\lnot x \\land z)$. This function is a two-to-one multiplexer, equivalent to the If-Then-Else expression $ITE(x, y, z)$.\nThe care set is given by the function $C(x,y,z) = y$. This implies that the behavior of the function $f$ is only specified for inputs where $y=1$. For inputs where $y=0$, the function's output is a \"don't care.\"\n\nWe must analyze two distinct operations: constraining $f$ by $C$ and restricting $f$ by $C$. The options provide semantic descriptions differentiating these two operations. A standard interpretation in logic synthesis, consistent with the options, defines them as follows:\n\n1.  **Constraining $f$ by $C$**: This operation, which can be denoted as $f \\land C$, produces a function that agrees with $f$ on the care set (where $C=1$) and is forced to $0$ on the don't-care set (where $C=0$).\n2.  **Restricting $f$ by $C$**: This operation, often called the generalized cofactor and denoted $f|_C$, produces a simplified function $g$ that agrees with $f$ on the care set (i.e., $g \\land C = f \\land C$). The values of $g$ on the don't-care set are chosen to achieve maximum simplification (e.g., creating a smaller ROBDD).\n\nLet us now compute the resulting function for each operation.\n\n**1. Calculation of Constraining $f$ by $C$**\n\nThe constrained function, let's call it $f_{constrained}$, is given by the logical AND of $f$ and $C$.\n$$\nf_{constrained}(x,y,z) = f(x,y,z) \\land C(x,y,z)\n$$\nSubstituting the given functions:\n$$\nf_{constrained} = ((x \\land y) \\lor (\\lnot x \\land z)) \\land y\n$$\nUsing the distributive law of $\\land$ over $\\lor$:\n$$\nf_{constrained} = (x \\land y \\land y) \\lor (\\lnot x \\land z \\land y)\n$$\nUsing the idempotent law ($y \\land y = y$):\n$$\nf_{constrained} = (x \\land y) \\lor (\\lnot x \\land y \\land z)\n$$\nFactoring out the common term $y$:\n$$\nf_{constrained} = y \\land (x \\lor (\\lnot x \\land z))\n$$\nApplying the distributive law $A \\lor (B \\land C) = (A \\lor B) \\land (A \\lor C)$:\n$$\nf_{constrained} = y \\land ((x \\lor \\lnot x) \\land (x \\lor z))\n$$\nUsing the law of the excluded middle ($x \\lor \\lnot x = 1$):\n$$\nf_{constrained} = y \\land (1 \\land (x \\lor z))\n$$\nUsing the identity law ($1 \\land A = A$):\n$$\nf_{constrained} = y \\land (x \\lor z)\n$$\nSo, constraining $f$ by $C$ yields the function $y \\land (x \\lor z)$.\n\n**2. Calculation of Restricting $f$ by $C$**\n\nThe restricted function, let's call it $f_{restricted}$, must agree with $f$ whenever $C=1$. That is, for all $x$ and $z$, we require $f_{restricted}(x,1,z) = f(x,1,z)$. The behavior for $y=0$ can be chosen freely to simplify the overall expression.\nLet's first compute the value of $f$ on the care set $y=1$:\n$$\nf(x,1,z) = (x \\land 1) \\lor (\\lnot x \\land z)\n$$\n$$\nf(x,1,z) = x \\lor (\\lnot x \\land z)\n$$\nUsing the distributive law as before:\n$$\nf(x,1,z) = (x \\lor \\lnot x) \\land (x \\lor z) = 1 \\land (x \\lor z) = x \\lor z\n$$\nThe function $f$ simplifies to $x \\lor z$ when $y=1$. The expression $x \\lor z$ itself does not depend on $y$. Therefore, we can choose $f_{restricted}(x,y,z) = x \\lor z$ as our simplified function. This choice satisfies the condition of agreeing with $f$ on the care set, since for $y=1$, $f_{restricted}(x,1,z) = x \\lor z = f(x,1,z)$. It is simpler than the original function $f$ because it is independent of the variable $y$. In an ROBDD representation with variable order $x \\prec y \\prec z$, all nodes for $x$ would point directly to nodes for $z$, bypassing any nodes for $y$.\nSo, restricting $f$ by $C$ yields the function $x \\lor z$.\n\n**Summary of Results:**\n-   Result of restricting $f$ by $C$: $x \\lor z$\n-   Result of constraining $f$ by $C$: $y \\land (x \\lor z)$\n\nNow, we evaluate each option based on these derived results and the semantic explanations.\n\n**Option A:**\n-   **Functions:** \"Restricting $f$ by $C$ yields $x \\lor z$, while constraining $f$ by $C$ yields $y \\land (x \\lor z)$.\" This matches our calculations precisely.\n-   **Explanation:** \"Restrict ensures agreement with $f$ where $C=1$ and may modify the function for $C=0$ to simplify the ROBDD, whereas constrain enforces $C$ globally, forcing the result to be $0$ whenever $C=0$.\" This explanation perfectly describes the semantics of the two operations as we have defined and used them. The `restrict` operation uses the $C=0$ space as don't-cares for simplification. The `constrain` operation is a logical AND with $C$, which by definition is $0$ when $C=0$.\n-   **Verdict:** **Correct**.\n\n**Option B:**\n-   **Functions:** \"Restricting $f$ by $C$ yields $y \\land (x \\lor z)$, while constraining $f$ by $C$ yields $x \\lor z$.\" This swaps the results.\n-   **Explanation:** \"Both operations guarantee equality to $f$ on all assignments.\" This is factually incorrect. Both operations alter the function on the don't-care set ($y=0$).\n-   **Verdict:** **Incorrect**.\n\n**Option C:**\n-   **Functions:** \"Restricting $f$ by $C$ yields $(x \\land y) \\lor (\\lnot x \\land z)$, while constraining $f$ by $C$ yields $y \\lor z$.\" The result for restriction is the original function $f$, which fails to perform the simplification. The result for constraining is $y \\lor z$, which is incorrect; our calculation yielded $y \\land (x \\lor z)$.\n-   **Explanation:** \"Restrict preserves $f$ exactly, and constrain removes dependence on $x$.\" Both parts of the explanation are false.\n-   **Verdict:** **Incorrect**.\n\n**Option D:**\n-   **Functions:** \"Restricting $f$ by $C$ yields $x \\lor z$, while constraining $f$ by $C$ yields $x \\lor z$.\" The result for constraining is incorrect. The constrained function must be $0$ when $y=0$, but $x \\lor z$ is not necessarily $0$ when $y=0$.\n-   **Explanation:** \"Both operations drop $y$ and preserve values on all assignments.\" The constrained function $y \\land (x \\lor z)$ does not drop $y$. And as stated for option B, values are not preserved on all assignments.\n-   **Verdict:** **Incorrect**.\n\nOnly option A correctly identifies both the resulting functions and the semantic difference between the two standard logic synthesis operations.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}