{
    "hands_on_practices": [
        {
            "introduction": "Mastering the theory of Binary Decision Diagrams begins with the fundamental skill of constructing them from standard Boolean expressions. This first exercise  provides a complete walkthrough of this process, starting from a logic function for a two-bit comparator. You will first perform algebraic manipulation to convert the function's representation, and then apply the recursive Shannon expansion to build the ROBDD, solidifying your understanding of how this canonical graph form is derived.",
            "id": "4258062",
            "problem": "Consider a two-bit equality comparator used in Electronic Design Automation (EDA). Let the two-bit inputs be $A=(a_{1},a_{0})$ and $B=(b_{1},b_{0})$. The comparator output $E(A,B)$ is a Boolean function that evaluates to $1$ if and only if $A=B$. Suppose $E$ is specified in Conjunctive Normal Form (CNF) as the conjunction of four clauses:\n$$\n(\\neg a_{1} \\vee b_{1}) \\wedge (\\neg b_{1} \\vee a_{1}) \\wedge (\\neg a_{0} \\vee b_{0}) \\wedge (\\neg b_{0} \\vee a_{0}).\n$$\nStarting from this CNF:\n- First, use Boolean algebra and distributivity to derive an equivalent Disjunctive Normal Form (DNF) for $E$, showing all steps and justifications using only the foundational laws and identities of Boolean algebra.\n- Next, construct the Binary Decision Diagram (BDD) of $E$ via the Shannon decomposition $f=(x \\wedge f|_{x=1}) \\vee (\\neg x \\wedge f|_{x=0})$ with the ordered variable sequence $a_{1} \\prec b_{1} \\prec a_{0} \\prec b_{0}$. Apply the standard reduction rules to obtain the Reduced Ordered Binary Decision Diagram (ROBDD): merge isomorphic subgraphs (unique table) and eliminate redundant tests (a node whose low and high children are identical is bypassed).\n- Detail each decomposition step and every reduction applied. For the final answer, report the total number of distinct non-terminal nodes in the resulting ROBDD under the given variable ordering. Non-terminal nodes are those labeled by decision variables; terminal nodes labeled $0$ or $1$ are not to be counted.\n\nExpress the final answer as a single real-valued number with no units. No rounding is required.",
            "solution": "The problem is first subjected to a rigorous validation process.\n\n### Step 1: Extract Givens\n- **Inputs**: Two $2$-bit binary numbers, $A=(a_{1},a_{0})$ and $B=(b_{1},b_{0})$.\n- **Function Definition**: The output $E(A,B)$ is a Boolean function that equals $1$ if and only if $A=B$.\n- **Initial Representation**: The function $E$ is provided in Conjunctive Normal Form (CNF):\n$$E = (\\neg a_{1} \\vee b_{1}) \\wedge (\\neg b_{1} \\vee a_{1}) \\wedge (\\neg a_{0} \\vee b_{0}) \\wedge (\\neg b_{0} \\vee a_{0})$$\n- **Task 1**: Derive an equivalent Disjunctive Normal Form (DNF) for $E$ from the given CNF using Boolean algebra, showing all steps.\n- **Task 2**: Construct the Reduced Ordered Binary Decision Diagram (ROBDD) for $E$.\n- **Variable Ordering**: The ordering for the BDD construction is specified as $a_{1} \\prec b_{1} \\prec a_{0} \\prec b_{0}$.\n- **Construction Method**: Shannon decomposition, $f=(x \\wedge f|_{x=1}) \\vee (\\neg x \\wedge f|_{x=0})$, which is equivalent to the if-then-else form $f = \\text{ITE}(x, f|_{x=1}, f|_{x=0})$.\n- **Reduction Rules**: Merge isomorphic subgraphs and eliminate redundant test nodes.\n- **Required Output**: Report the total number of distinct non-terminal nodes in the final ROBDD.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientific Grounding**: The problem is grounded in the fundamental principles of Boolean algebra and digital logic design. The concepts of CNF, DNF, Binary Decision Diagrams (BDDs), Shannon decomposition, and ROBDDs are standard in computer science and electronic design automation. The Boolean function for a comparator is well-defined. The provided CNF for $E$ correctly represents the equality condition. The clause $(\\neg x \\vee y) \\wedge (\\neg y \\vee x)$ is the standard CNF representation of the logical equivalence $x \\leftrightarrow y$. Thus, the given expression is equivalent to $(a_1 \\leftrightarrow b_1) \\wedge (a_0 \\leftrightarrow b_0)$, which is the correct logic for a two-bit equality comparator. The problem is scientifically sound.\n2.  **Well-Posedness**: The tasks are clearly stated. Deriving a DNF is a standard algebraic manipulation. Constructing an ROBDD with a fixed variable ordering is an algorithmic process that yields a unique, canonical representation. The final query for the number of non-terminal nodes is a well-defined, singular value.\n3.  **Objectivity**: The problem is stated using formal mathematical notation and terminology, leaving no room for subjective interpretation.\n4.  **Completeness**: All necessary information, including the function's initial form, the variable ordering, and the construction/reduction rules, is provided. The problem is self-contained.\n\n### Step 3: Verdict and Action\nThe problem is valid as it is scientifically grounded, well-posed, objective, and complete. Proceeding with the solution.\n\n### Part 1: Derivation of Disjunctive Normal Form (DNF)\nThe given Boolean function is:\n$$E = (\\neg a_{1} \\vee b_{1}) \\wedge (\\neg b_{1} \\vee a_{1}) \\wedge (\\neg a_{0} \\vee b_{0}) \\wedge (\\neg b_{0} \\vee a_{0})$$\nThis can be grouped into two parts, one for each bit comparison:\n$$E = [(\\neg a_{1} \\vee b_{1}) \\wedge (\\neg b_{1} \\vee a_{1})] \\wedge [(\\neg a_{0} \\vee b_{0}) \\wedge (\\neg b_{0} \\vee a_{0})]$$\nLet's define $E_1 = (\\neg a_{1} \\vee b_{1}) \\wedge (\\neg b_{1} \\vee a_{1})$ and $E_0 = (\\neg a_{0} \\vee b_{0}) \\wedge (\\neg b_{0} \\vee a_{0})$. These represent the equivalence functions $a_1 \\leftrightarrow b_1$ and $a_0 \\leftrightarrow b_0$, respectively.\n\nFirst, we convert $E_1$ to DNF using the distributive law, $p \\wedge (q \\vee r) = (p \\wedge q) \\vee (p \\wedge r)$:\n$$E_1 = ((\\neg a_1 \\vee b_1) \\wedge \\neg b_1) \\vee ((\\neg a_1 \\vee b_1) \\wedge a_1)$$\nApply distributivity again:\n$$E_1 = (\\neg a_1 \\wedge \\neg b_1) \\vee (b_1 \\wedge \\neg b_1) \\vee (\\neg a_1 \\wedge a_1) \\vee (b_1 \\wedge a_1)$$\nUsing the complementary law ($p \\wedge \\neg p = 0$) and the identity law ($p \\vee 0 = p$):\n$$E_1 = (\\neg a_1 \\wedge \\neg b_1) \\vee 0 \\vee 0 \\vee (a_1 \\wedge b_1)$$\n$$E_1 = (\\neg a_1 \\wedge \\neg b_1) \\vee (a_1 \\wedge b_1)$$\nThis is the DNF for $a_1=b_1$. By identical logic, the DNF for $E_0$ is:\n$$E_0 = (\\neg a_0 \\wedge \\neg b_0) \\vee (a_0 \\wedge b_0)$$\nNow we compute $E = E_1 \\wedge E_0$:\n$$E = [(\\neg a_1 \\wedge \\neg b_1) \\vee (a_1 \\wedge b_1)] \\wedge [(\\neg a_0 \\wedge \\neg b_0) \\vee (a_0 \\wedge b_0)]$$\nLet $X = (\\neg a_1 \\wedge \\neg b_1)$, $Y = (a_1 \\wedge b_1)$, $Z = (\\neg a_0 \\wedge \\neg b_0)$, and $W = (a_0 \\wedge b_0)$. The expression is $(X \\vee Y) \\wedge (Z \\vee W)$. Applying distributivity:\n$$E = (X \\wedge Z) \\vee (X \\wedge W) \\vee (Y \\wedge Z) \\vee (Y \\wedge W)$$\nSubstituting back the original terms:\n$X \\wedge Z = (\\neg a_1 \\wedge \\neg b_1) \\wedge (\\neg a_0 \\wedge \\neg b_0) = \\neg a_1 \\wedge \\neg b_1 \\wedge \\neg a_0 \\wedge \\neg b_0$\n$X \\wedge W = (\\neg a_1 \\wedge \\neg b_1) \\wedge (a_0 \\wedge b_0) = \\neg a_1 \\wedge \\neg b_1 \\wedge a_0 \\wedge b_0$\n$Y \\wedge Z = (a_1 \\wedge b_1) \\wedge (\\neg a_0 \\wedge \\neg b_0) = a_1 \\wedge b_1 \\wedge \\neg a_0 \\wedge \\neg b_0$\n$Y \\wedge W = (a_1 \\wedge b_1) \\wedge (a_0 \\wedge b_0) = a_1 \\wedge b_1 \\wedge a_0 \\wedge b_0$\n\nCombining these gives the final DNF for $E$:\n$$E = (\\neg a_1 \\wedge \\neg b_1 \\wedge \\neg a_0 \\wedge \\neg b_0) \\vee (\\neg a_1 \\wedge \\neg b_1 \\wedge a_0 \\wedge b_0) \\vee (a_1 \\wedge b_1 \\wedge \\neg a_0 \\wedge \\neg b_0) \\vee (a_1 \\wedge b_1 \\wedge a_0 \\wedge b_0)$$\nThis DNF represents the four conditions under which $A=B$.\n\n### Part 2: Construction of the Reduced Ordered Binary Decision Diagram (ROBDD)\nWe construct the ROBDD top-down following the variable order $a_{1} \\prec b_{1} \\prec a_{0} \\prec b_{0}$. We will denote a non-terminal node as a tuple $(v, l, h)$, where $v$ is the decision variable, $l$ is the low-child (for $v=0$) and $h$ is the high-child (for $v=1$). The terminal nodes are $0$ and $1$.\n\n**Level 1: Decompose on $a_1$**\nThe root node is for variable $a_1$. We compute its children functions using Shannon's expansion on $E = (a_1 \\leftrightarrow b_1) \\wedge (a_0 \\leftrightarrow b_0)$.\n- Low child (if $a_1=0$): $E|_{a_1=0} = (0 \\leftrightarrow b_1) \\wedge (a_0 \\leftrightarrow b_0) = \\neg b_1 \\wedge (a_0 \\leftrightarrow b_0)$. Let's call this function $f_0$.\n- High child (if $a_1=1$): $E|_{a_1=1} = (1 \\leftrightarrow b_1) \\wedge (a_0 \\leftrightarrow b_0) = b_1 \\wedge (a_0 \\leftrightarrow b_0)$. Let's call this function $f_1$.\nThe root node is $n_1 = (a_1, f_0, f_1)$.\n\n**Level 2: Decompose on $b_1$**\nWe now construct nodes for $f_0$ and $f_1$.\n- For $f_0 = \\neg b_1 \\wedge (a_0 \\leftrightarrow b_0)$:\n  - Low child (if $b_1=0$): $f_0|_{b_1=0} = \\neg 0 \\wedge (a_0 \\leftrightarrow b_0) = 1 \\wedge (a_0 \\leftrightarrow b_0) = a_0 \\leftrightarrow b_0$. Let's call this function $h$.\n  - High child (if $b_1=1$): $f_0|_{b_1=1} = \\neg 1 \\wedge (a_0 \\leftrightarrow b_0) = 0 \\wedge (a_0 \\leftrightarrow b_0) = 0$.\n  So, the node for $f_0$ is $n_2 = (b_1, h, 0)$.\n- For $f_1 = b_1 \\wedge (a_0 \\leftrightarrow b_0)$:\n  - Low child (if $b_1=0$): $f_1|_{b_1=0} = 0 \\wedge (a_0 \\leftrightarrow b_0) = 0$.\n  - High child (if $b_1=1$): $f_1|_{b_1=1} = 1 \\wedge (a_0 \\leftrightarrow b_0) = a_0 \\leftrightarrow b_0 = h$.\n  So, the node for $f_1$ is $n_3 = (b_1, 0, h)$.\nThe nodes $n_2$ and $n_3$ are distinct since their children tuples $(h, 0)$ and $(0, h)$ are different. No reduction is possible at this level.\n\n**Level 3: Decompose on $a_0$**\nWe need to construct a node for the function $h = a_0 \\leftrightarrow b_0$.\n- Low child (if $a_0=0$): $h|_{a_0=0} = 0 \\leftrightarrow b_0 = \\neg b_0$. Call this $k_0$.\n- High child (if $a_0=1$): $h|_{a_0=1} = 1 \\leftrightarrow b_0 = b_0$. Call this $k_1$.\nThe node for $h$ is $n_4 = (a_0, k_0, k_1)$. Since $k_0 \\neq k_1$, this node is not redundant.\n\n**Level 4: Decompose on $b_0$**\nWe construct nodes for $k_0 = \\neg b_0$ and $k_1 = b_0$.\n- For $k_0 = \\neg b_0$:\n  - Low child (if $b_0=0$): $k_0|_{b_0=0} = \\neg 0 = 1$.\n  - High child (if $b_0=1$): $k_0|_{b_0=1} = \\neg 1 = 0$.\n  The node for $k_0$ is $n_5 = (b_0, 1, 0)$.\n- For $k_1 = b_0$:\n  - Low child (if $b_0=0$): $k_1|_{b_0=0} = 0$.\n  - High child (if $b_0=1$): $k_1|_{b_0=1} = 1$.\n  The node for $k_1$ is $n_6 = (b_0, 0, 1)$.\nThe nodes $n_5$ and $n_6$ are distinct, as their children tuples $(1, 0)$ and $(0, 1)$ differ.\n\n**Post-construction Analysis for ROBDD Properties**\nThe construction process, by creating nodes for unique functions at each level, inherently prevents the creation of isomorphic subgraphs. We must verify that no nodes are redundant (i.e., having identical low and high children).\n- $n_1 = (a_1, n_2, n_3)$: Not redundant as $n_2 \\neq n_3$.\n- $n_2 = (b_1, n_4, 0)$: Not redundant as $n_4 \\neq 0$.\n- $n_3 = (b_1, 0, n_4)$: Not redundant as $0 \\neq n_4$.\n- $n_4 = (a_0, n_5, n_6)$: Not redundant as $n_5 \\neq n_6$.\n- $n_5 = (b_0, 1, 0)$: Not redundant as $1 \\neq 0$.\n- $n_6 = (b_0, 0, 1)$: Not redundant as $0 \\neq 1$.\nAll six non-terminal nodes are necessary and distinct.\n\nThe final ROBDD consists of the following distinct non-terminal nodes:\n1. $n_1$: A node for variable $a_1$ with children pointing to $n_2$ and $n_3$.\n2. $n_2$: A node for variable $b_1$ with children pointing to $n_4$ and the terminal $0$.\n3. $n_3$: A node for variable $b_1$ with children pointing to the terminal $0$ and $n_4$.\n4. $n_4$: A node for variable $a_0$ with children pointing to $n_5$ and $n_6$.\n5. $n_5$: A node for variable $b_0$ with children pointing to the terminals $1$ and $0$.\n6. $n_6$: A node for variable $b_0$ with children pointing to the terminals $0$ and $1$.\n\nThe total count of distinct non-terminal nodes is $6$.",
            "answer": "$$\n\\boxed{6}\n$$"
        },
        {
            "introduction": "While an ROBDD provides a canonical representation for a Boolean function under a *fixed* variable order, the choice of that order itself is not arbitrary; it critically affects the size and efficiency of the diagram. This practice  uses the essential multiplexer (MUX) circuit to illustrate this pivotal concept. By analyzing different orderings for the MUX's select and data inputs, you will directly observe how a thoughtful choice, guided by the function's structure, leads to a more compact representation.",
            "id": "4258051",
            "problem": "In Electronic Design Automation (EDA), Reduced Ordered Binary Decision Diagram (ROBDD) representations of Boolean functions play a critical role in combinational logic optimization. Consider the Boolean function for a $2$:$1$ multiplexor, defined as $f(s,x,y)=MUX(s,x,y)=s x+\\overline{s} y$, where $s$ is the select input and $x,y$ are the data inputs. A Binary Decision Diagram (BDD) is an acyclic directed graph in which each non-terminal node is labeled by a Boolean variable and has two outgoing edges corresponding to the cofactors $f_{v=0}$ and $f_{v=1}$ of the function under that variable; an ROBDD results from applying two standard reduction rules: merging isomorphic subgraphs and eliminating nodes whose two children are identical. An Ordered BDD fixes a total order of variables that must be respected along all root-to-terminal paths. Using the Shannon decomposition for Boolean functions, $f=v \\cdot f_{v=1}+\\overline{v}\\cdot f_{v=0}$ for any variable $v$, and the ROBDD reduction rules described, analyze the effect of variable ordering on the ROBDD size of $f(s,x,y)$.\n\nWhich statement is correct about the minimal ROBDD size and the choice of the root variable for an optimal-size representation of $f(s,x,y)$?\n\nA. With $s$ at the root and either $x$ before $y$ or $y$ before $x$ thereafter, the minimal ROBDD has exactly $3$ non-terminal decision nodes, whereas any ordering that places $s$ after $x$ or $y$ has at least $4$ non-terminal decision nodes.\n\nB. With $x$ at the root using the order $x,s,y$, the minimal ROBDD has exactly $3$ non-terminal decision nodes; placing $s$ at the root yields $4$ or more non-terminal decision nodes.\n\nC. The minimal ROBDD size is independent of variable ordering and equals $3$ non-terminal decision nodes for all possible variable orders.\n\nD. With $y$ at the root and $x$ second, the minimal ROBDD has exactly $3$ non-terminal decision nodes; any order with $s$ at the root produces at least $5$ non-terminal decision nodes.\n\nE. With $s$ at the root, the ROBDD collapses to exactly $2$ non-terminal decision nodes by eliminating both $x$ and $y$ nodes as redundant.",
            "solution": "We begin from first principles. For a Boolean function $f(s,x,y)=s x+\\overline{s} y$, the Shannon decomposition with respect to a variable $v$ is $f=v \\cdot f_{v=1}+\\overline{v}\\cdot f_{v=0}$, where $f_{v=b}$ is the cofactor obtained by substituting $v=b$ into $f$. In a Binary Decision Diagram (BDD), a node labeled by $v$ represents this decomposition: the high edge goes to a subgraph representing $f_{v=1}$ and the low edge goes to a subgraph representing $f_{v=0}$. A Reduced Ordered Binary Decision Diagram (ROBDD) applies two reduction rules: identical subgraphs are shared (isomorphic subgraphs are merged), and nodes whose two children are identical are eliminated (redundant tests). An Ordered BDD constrains all root-to-terminal paths to follow a fixed variable order.\n\nWe analyze possible variable orders and count minimal non-terminal decision nodes after reductions.\n\nCase $1$: $s$ first. Consider either order $s,x,y$ or $s,y,x$. Using Shannon decomposition with respect to $s$,\n$$\nf(s,x,y)=s \\cdot f_{s=1}+\\overline{s} \\cdot f_{s=0},\\quad f_{s=1}=x,\\quad f_{s=0}=y.\n$$\nThe BDD has a root node labeled $s$, with high child representing $x$ and low child representing $y$. In an Ordered BDD, variables not dependent in a subfunction can be skipped via the reduction rule: if a node labeled by a variable would have identical children because the subfunction is independent of that variable, that node is eliminated. Thus, on the $s=1$ branch the subfunction is $x$, which is represented by a single node labeled $x$ with high edge to the terminal $1$ and low edge to the terminal $0$. On the $s=0$ branch the subfunction is $y$, represented similarly by a single node labeled $y$. There is no further sharing between the $x$ and $y$ nodes because they are labeled by different variables. Therefore, the ROBDD contains exactly $3$ non-terminal nodes: one node for $s$, one node for $x$, and one node for $y$.\n\nCase $2$: $x$ first, order $x,s,y$. Compute the cofactors:\n$$\nf_{x=0}=\\overline{s} y,\\quad f_{x=1}=s+\\overline{s} y.\n$$\nThe root node is $x$. For the low branch $x=0$, the next variable in the order is $s$, with\n$$\nf_{x=0,s=1}=0,\\quad f_{x=0,s=0}=y.\n$$\nThus, the subgraph for $x=0$ begins with a node labeled $s$ whose high edge goes to terminal $0$ and low edge goes to a node labeled $y$. For the high branch $x=1$, again the next variable is $s$, with\n$$\nf_{x=1,s=1}=1,\\quad f_{x=1,s=0}=y.\n$$\nThus, the subgraph for $x=1$ begins with a node labeled $s$ whose high edge goes to terminal $1$ and low edge goes to the same node labeled $y$ as above. The two $s$ nodes cannot be merged because their children differ: one has children $\\{0,y\\}$ (ordered as high $\\to 0$, low $\\to y$), and the other has children $\\{1,y\\}$ (high $\\to 1$, low $\\to y$). The $y$ node is shared by both subgraphs. Therefore, we have $4$ non-terminal nodes: the root $x$, two distinct $s$ nodes, and one $y$ node.\n\nCase $3$: $y$ first, order $y,s,x$. By symmetry with Case $2$, we obtain $4$ non-terminal nodes: the root $y$, two distinct $s$ nodes under $y=0$ and $y=1$ branches, and one $x$ node shared.\n\nCase $4$: $s$ last, order $x,y,s$. Compute cofactors at the root $x$:\n$$\nf_{x=0}=\\overline{s} y,\\quad f_{x=1}=s+\\overline{s} y.\n$$\nProceed to $y$ next:\n- For $x=0$, $y=1$ gives $f_{x=0,y=1}=\\overline{s}$; $y=0$ gives $f_{x=0,y=0}=0$. The $y$-node for $x=0$ has high edge to a node labeled $s$ with children low $\\to 1$, high $\\to 0$ (representing $\\overline{s}$), and low edge to terminal $0$.\n- For $x=1$, $y=1$ gives $f_{x=1,y=1}=s+\\overline{s}=1$; $y=0$ gives $f_{x=1,y=0}=s$. The $y$-node for $x=1$ has high edge to terminal $1$ and low edge to a node labeled $s$ with children low $\\to 0$, high $\\to 1$ (representing $s$).\n\nThe two $y$ nodes differ in their children and cannot be merged. The two $s$ nodes also differ (one represents $\\overline{s}$ and the other represents $s$), so they cannot be merged. Thus, we have $5$ non-terminal nodes: the root $x$, two distinct $y$ nodes, and two distinct $s$ nodes. The symmetric order $y,x,s$ yields the same count $5$ by analogous reasoning.\n\nFrom these cases, the minimal ROBDD size is achieved when $s$ is at the root (with either order of $x$ and $y$ thereafter), yielding exactly $3$ non-terminal decision nodes. Any ordering that places $s$ after $x$ or $y$ requires at least $4$ non-terminal decision nodes, and placing $s$ last requires $5$. The structural reason is that Shannon decomposition with respect to $s$ yields cofactors $f_{s=1}=x$ and $f_{s=0}=y$, each equal to a single variable, allowing direct representation by single-node subgraphs. In contrast, decomposing first by $x$ or $y$ produces cofactors that mix $s$ with another variable, creating two distinct $s$-labeled nodes under different branches and increasing the node count.\n\nOption-by-option analysis:\n- A. Correct. With $s$ at the root, the ROBDD has exactly $3$ non-terminal nodes ($s$, $x$, $y$), and placing $s$ after $x$ or $y$ yields at least $4$ non-terminal nodes by the presence of two distinct $s$ nodes under the data-input root.\n- B. Incorrect. The order $x,s,y$ produces $4$ non-terminal nodes, not $3$, and placing $s$ at the root gives $3$, not $4$ or more.\n- C. Incorrect. The ROBDD size depends on variable ordering: $3$ ($s$ first), $4$ ($x$ first or $y$ first with $s$ second), and $5$ ($s$ last).\n- D. Incorrect. With $y$ at the root and $x$ second, the minimal ROBDD has $4$ non-terminal nodes, not $3$, and with $s$ at the root it has $3$, not $5$.\n- E. Incorrect. With $s$ at the root, the subfunctions $f_{s=1}=x$ and $f_{s=0}=y$ require one node each to represent the variables $x$ and $y$, so the diagram has $3$ non-terminal nodes, not $2$.\n\nTherefore, the correct choice is A.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "The principles of variable ordering scale to more complex, multi-bit functions, where a good choice can mean the difference between a feasible and an intractable representation. This final practice  explores this dramatic effect on a cornerstone of digital design: the binary ripple-carry adder. By comparing the asymptotic ROBDD size for an 'interleaved' versus a 'grouped' variable order, you will uncover why aligning the variable order with the function's data dependency is crucial for representing arithmetic circuits efficiently.",
            "id": "4258038",
            "problem": "Consider the Boolean function $S_k(a_0,\\dots,a_{n-1},b_0,\\dots,b_{n-1})$ that outputs the $k$-th sum bit of adding two $n$-bit unsigned integers $A=\\sum_{i=0}^{n-1} a_i 2^i$ and $B=\\sum_{i=0}^{n-1} b_i 2^i$ using a standard ripple-carry adder with no incoming carry. The $k$-th sum bit can be defined from first principles by the carry recurrence $C_0 = 0$ and\n$$\nC_{i+1} = (a_i \\wedge b_i) \\vee \\big((a_i \\oplus b_i) \\wedge C_i\\big),\\quad S_i = a_i \\oplus b_i \\oplus C_i,\n$$\nwhere $\\wedge$, $\\vee$, and $\\oplus$ represent the Boolean operators $\\text{AND}$, $\\text{OR}$, and $\\text{XOR}$, respectively. A Reduced Ordered Binary Decision Diagram (ROBDD) is the canonical representation of a Boolean function under a fixed variable order constructed via repeated Shannon expansion and reduction, with canonicity and size dependent on the chosen order. In the context of Electronic Design Automation (EDA), ROBDD size is a critical proxy for verification and synthesis complexity.\n\nLet the variable order be either the interleaved order $(a_0,b_0,a_1,b_1,\\dots,a_{n-1},b_{n-1})$ or the grouped order $(a_0,a_1,\\dots,a_{n-1},b_0,b_1,\\dots,b_{n-1})$. Assume $k=\\lfloor n/2 \\rfloor$. Which statement best characterizes the asymptotic number of nodes in the ROBDD of $S_k$ as a function of $n$ under these two orders, and what structural reason underlies the difference?\n\nA. Under the interleaved order, the ROBDD has $\\Theta(n)$ nodes; under the grouped order, it has $\\Omega(2^n)$ nodes. The interleaving aligns Shannon expansion with the local two-state carry propagation, while grouping forces the diagram to encode exponentially many distinct residual functions indexed by the $a$-prefix before any $b$-variables are read.\n\nB. Both orders yield $\\Theta(n)$ nodes, because ROBDD canonicity eliminates dependence on variable ordering for arithmetic functions such as addition.\n\nC. Under the interleaved order, the ROBDD has $\\Theta(n^2)$ nodes; under the grouped order, it has $\\Theta(n\\log n)$ nodes. The grouped order modestly reduces sharing, but arithmetic structure remains polynomial.\n\nD. Under the interleaved order, the ROBDD has $\\Theta(\\log n)$ nodes; under the grouped order, it has $\\Theta(n)$ nodes. Grouping compresses the carry chain by resolving all $a$-bits first, leaving only a linear number of $b$-configurations.",
            "solution": "The problem asks for the asymptotic size of the ROBDD for the $k$-th sum bit, $S_k$, of an $n$-bit ripple-carry adder, where $k=\\lfloor n/2 \\rfloor$. The size depends critically on the variable ordering. The function is $S_k = a_k \\oplus b_k \\oplus C_k$, where the carry bit $C_k$ depends on all lower-order bits $(a_0, b_0, \\dots, a_{k-1}, b_{k-1})$. The complexity of the ROBDD is dominated by the representation of $C_k$.\n\n**Analysis of the Interleaved Order: $(a_0,b_0,a_1,b_1,\\dots)$**\n\nIn this order, variables are processed bit-slice by bit-slice, mirroring the data flow of the physical adder. When constructing the ROBDD, after processing variables $(a_0, b_0, \\dots, a_{i-1}, b_{i-1})$, the entire influence on the rest of the computation is captured by the single carry-out bit, $C_i$. Since $C_i$ can only have two values ($0$ or $1$), at any stage $i$ of the carry chain, there are at most two distinct residual functions to represent. This means the \"width\" of the ROBDD is constant. The overall structure is a linear chain of small, constant-size subgraphs, one for each bit-slice. The total number of nodes is therefore proportional to the number of stages, $k$. Since $k \\approx n/2$, the ROBDD size is linear in $n$, i.e., $\\Theta(n)$.\n\n**Analysis of the Grouped Order: $(a_0,a_1,\\dots,b_0,b_1,\\dots)$**\n\nIn this order, all bits of operand $A$ are processed before any bits of operand $B$. Consider the point in the Shannon expansion after values have been assigned to the variables $(a_0, \\dots, a_{k-1})$. The ROBDD must now represent the residual function, which depends on the $b$-variables. The crucial part of this function is the carry bit $C_k$. Let $A' = \\sum_{i=0}^{k-1} a_i 2^i$ be the integer represented by the prefix of $A$, and $B' = \\sum_{i=0}^{k-1} b_i 2^i$. The carry function $C_k$ is $1$ if and only if $A' + B' \\ge 2^k$. As a function of the $b$-variables, this is $f_{A'}(B') = \\mathbf{1}_{B' \\ge 2^k - A'}$.\n\nFor two different prefixes $A'_1 \\neq A'_2$, the thresholds $T_1 = 2^k - A'_1$ and $T_2 = 2^k - A'_2$ are also different. The functions $\\mathbf{1}_{B' \\ge T_1}$ and $\\mathbf{1}_{B' \\ge T_2}$ are not identical. This means that each of the $2^k$ possible assignments to the prefix $(a_0, \\dots, a_{k-1})$ generates a unique residual function. Consequently, the ROBDD must contain at least $2^k$ distinct nodes at the \"cut\" between the $a$-variables and the $b$-variables to represent these unique functions. Since $k=\\lfloor n/2 \\rfloor$, the number of nodes is at least $2^{\\lfloor n/2 \\rfloor}$. This establishes an exponential lower bound, so the asymptotic size is $\\Omega(2^{n/2})$.\n\n**Evaluation of Options:**\n\n*   A: States $\\Theta(n)$ for interleaved and $\\Omega(2^n)$ for grouped, with the correct structural reasoning. The $\\Theta(n)$ part is correct. The grouped part correctly identifies exponential growth, though $\\Omega(2^n)$ is an overestimate of the true $\\Omega(2^{n/2})$ lower bound. The reasoning is sound.\n*   B: Incorrectly claims both are $\\Theta(n)$ and gives wrong reasoning about canonicity.\n*   C: Incorrectly gives polynomial bounds for both.\n*   D: Incorrectly gives $\\Theta(\\log n)$ and $\\Theta(n)$ bounds.\n\nOption A provides the best characterization. It correctly identifies the linear vs. exponential dichotomy and provides the correct physical intuition for why it occurs, even if its notation for the exponential part is loose.",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}