{
    "hands_on_practices": [
        {
            "introduction": "理论知识是设计高性能加法器的基础，但真正的精通来自于实践。本章节提供了一系列动手实践，旨在将抽象的加法器架构和进位加速技术付诸于实际应用。在设计复杂的加速电路之前，我们必须首先深刻理解问题的根源。这个练习将带您回到最基础的行波进位加法器 (Ripple-Carry Adder)，通过概率论的工具来量化其性能瓶颈——进位链的长度。通过推导在随机输入下进位链长度的期望和方差，您将直观地感受到为何串行进位传播会成为性能的制约因素，从而为学习后续的并行加速技术奠定坚实的动机。",
            "id": "4255489",
            "problem": "考虑一个$n$位行波进位加法器，它对两个独立的随机输入字$\\{a_i\\}_{i=0}^{n-1}$和$\\{b_i\\}_{i=0}^{n-1}$进行操作，其中每个比特$a_i$和$b_i$都独立同分布地服从参数为$1/2$的伯努利随机变量。对于每个比特位置$i$，定义加法中使用的标准产生/传播/终止信号：$g_i = a_i b_i$，$p_i = a_i \\oplus b_i$ 和 $k_i = \\overline{a_i} \\, \\overline{b_i}$。比特级的进位递归遵循布尔关系$c_{i+1} = g_i \\lor (p_i \\land c_i)$，其中$c_i$是输入到位置$i$的进位。\n\n从$\\{1,\\dots,n-2\\}$中均匀随机地选择一个起始位置$i$，以便在$n$很大时可以忽略边界效应。将从位置$i$开始的进位链长度$L$定义为满足$p_j = 1$的连续位置$j \\in \\{i,i+1,\\dots\\}$的数目，该链在第一个$p_j = 0$的位置终止（也就是说，$L$是从$i$开始的连续传播段的长度）。等价地，$L = \\max\\{\\ell \\ge 0 : p_i = p_{i+1} = \\dots = p_{i+\\ell-1} = 1\\}$。\n\n仅从$\\{a_i\\}$和$\\{b_i\\}$的比特级独立性以及上述$g_i$、$p_i$和$k_i$的定义出发，根据第一性原理推导出进位链长度的期望值$\\mathbb{E}[L]$和方差$\\mathrm{Var}(L)$的精确表达式。请以精确值形式给出最终答案，不要四舍五入。",
            "solution": "所述问题具有科学依据，提法得当且客观。它提出了一个计算机算术电路分析中的标准问题，使用了一个定义明确的概率模型。所有必要信息均已提供，问题没有矛盾或歧义。因此，可以推导出解答。\n\n该问题要求计算一个$n$位行波进位加法器中进位链长度$L$的期望值和方差。从比特位置$i$开始的进位链长度被定义为传播信号$p_j = a_j \\oplus b_j$等于$1$的连续比特$j \\ge i$的数目。\n\n首先，我们必须确定传播信号$p_i$的概率分布。输入比特$a_i$和$b_i$是独立同分布(i.i.d.)的，服从参数为$1/2$的伯努利随机变量。这意味着$P(a_i=1) = P(a_i=0) = 1/2$且$P(b_i=1) = P(b_i=0) = 1/2$。$(a_i, b_i)$的四种可能取值对是$(0,0)$、$(0,1)$、$(1,0)$和$(1,1)$，每种情况发生的概率为$(1/2) \\times (1/2) = 1/4$。\n\n传播信号定义为$p_i = a_i \\oplus b_i$。$p_i$的值为$1$当且仅当$a_i \\neq b_i$。这发生在取值对为$(0,1)$和$(1,0)$时。因此，一个比特位置传播进位的概率是：\n$$ P(p_i=1) = P(a_i=0, b_i=1) + P(a_i=1, b_i=0) = \\frac{1}{4} + \\frac{1}{4} = \\frac{1}{2} $$\n如果$a_i = b_i$，$p_i$的值为$0$，这发生在取值对为$(0,0)$和$(1,1)$时。该事件对应于该比特位置产生一个进位（$g_i=1$）或终止该进位（$k_i=1$）。一个比特位置终止进位链的概率是：\n$$ P(p_i=0) = P(a_i=0, b_i=0) + P(a_i=1, b_i=1) = \\frac{1}{4} + \\frac{1}{4} = \\frac{1}{2} $$\n由于输入比特$\\{a_i\\}$和$\\{b_i\\}$都是相互独立的，传播信号$\\{p_i\\}$构成了一个参数为$q \\equiv P(p_i=1) = 1/2$的独立同分布伯努利随机变量序列。问题忽略了边界效应，因此为了分析从位置$i$开始的进位链，我们可以将此序列视为有效无限长。\n\n进位链长度$L$是从位置$i$开始的、等于$1$的连续传播信号的数目。让我们来确定随机变量$L$的概率分布。\n对于$k \\ge 0$，事件$L=k$可以描述如下：\n- 对于$L=0$，第一个比特必须不传播：$p_i=0$。\n- 对于$L=k$（其中$k \\ge 1$），前$k$个比特必须传播，而第$(k+1)$个比特必须不传播：$p_i=1, p_{i+1}=1, \\dots, p_{i+k-1}=1$，且$p_{i+k}=0$。\n\n利用$p_j$变量的独立性，我们可以写出$L$的概率质量函数(PMF)：\n对于$k=0$：\n$$ P(L=0) = P(p_i=0) = 1-q = \\frac{1}{2} $$\n对于$k \\ge 1$：\n$$ P(L=k) = P(p_i=1, \\dots, p_{i+k-1}=1, p_{i+k}=0) = \\left(\\prod_{j=0}^{k-1} P(p_{i+j}=1)\\right) P(p_{i+k}=0) = q^k (1-q) $$\n代入$q=1/2$，对于$k \\ge 1$得到$P(L=k) = (1/2)^k (1/2) = (1/2)^{k+1}$。\n我们可以观察到，对于$k \\ge 1$的公式也适用于$k=0$的情况，因为$q^0(1-q) = 1-q = P(L=0)$。因此，$L$的PMF对于所有整数$k \\ge 0$由下式给出：\n$$ P(L=k) = q^k (1-q) = \\left(\\frac{1}{2}\\right)^{k} \\left(\\frac{1}{2}\\right) = \\left(\\frac{1}{2}\\right)^{k+1} $$\n这是集合$\\{0, 1, 2, \\dots\\}$上的几何分布的PMF。\n\n我们现在从第一性原理推导期望值$\\mathbb{E}[L]$。对于一个非负整数值的随机变量，其期望值可以用尾和公式计算：$\\mathbb{E}[L] = \\sum_{k=1}^{\\infty} P(L \\ge k)$。\n事件$L \\ge k$（对于$k \\ge 1$）意味着至少前$k$个位置都在传播，即$p_i=1, p_{i+1}=1, \\dots, p_{i+k-1}=1$。该事件的概率是：\n$$ P(L \\ge k) = P(p_i=1, \\dots, p_{i+k-1}=1) = \\prod_{j=0}^{k-1} P(p_{i+j}=1) = q^k $$\n现在，我们可以计算期望值：\n$$ \\mathbb{E}[L] = \\sum_{k=1}^{\\infty} P(L \\ge k) = \\sum_{k=1}^{\\infty} q^k $$\n这是一个首项为$q$、公比为$q$的标准几何级数。其和为$\\frac{q}{1-q}$。\n代入$q = 1/2$：\n$$ \\mathbb{E}[L] = \\frac{1/2}{1 - 1/2} = \\frac{1/2}{1/2} = 1 $$\n\n接下来，我们推导方差$\\mathrm{Var}(L)$。我们知道$\\mathrm{Var}(L) = \\mathbb{E}[L^2] - (\\mathbb{E}[L])^2$。我们需要计算$\\mathbb{E}[L^2]$。一个与尾和公式相关的有用公式是$\\mathbb{E}[L^2] = \\sum_{k=1}^{\\infty} (2k-1)P(L \\ge k)$。\n使用$P(L \\ge k) = q^k$：\n$$ \\mathbb{E}[L^2] = \\sum_{k=1}^{\\infty} (2k-1)q^k = 2\\sum_{k=1}^{\\infty} k q^k - \\sum_{k=1}^{\\infty} q^k $$\n我们已经知道第二项的和是$\\mathbb{E}[L] = \\frac{q}{1-q}$。\n第一项的和$S = \\sum_{k=1}^{\\infty} k q^k$是一个著名的级数。它可以按如下方式推导：\n$$ S = q + 2q^2 + 3q^3 + \\dots = q(1+2q+3q^2+\\dots) $$\n括号中的级数是几何级数的导数：\n$$ \\sum_{k=0}^{\\infty} q^k = \\frac{1}{1-q} \\implies \\frac{d}{dq} \\sum_{k=0}^{\\infty} q^k = \\sum_{k=1}^{\\infty} k q^{k-1} = \\frac{1}{(1-q)^2} $$\n乘以$q$得到和$S$：\n$$ S = \\sum_{k=1}^{\\infty} k q^k = \\frac{q}{(1-q)^2} $$\n现在，我们代回到$\\mathbb{E}[L^2]$的表达式中：\n$$ \\mathbb{E}[L^2] = 2\\left(\\frac{q}{(1-q)^2}\\right) - \\frac{q}{1-q} = \\frac{2q - q(1-q)}{(1-q)^2} = \\frac{2q - q + q^2}{(1-q)^2} = \\frac{q+q^2}{(1-q)^2} $$\n最后，我们计算方差：\n$$ \\mathrm{Var}(L) = \\mathbb{E}[L^2] - (\\mathbb{E}[L])^2 = \\frac{q+q^2}{(1-q)^2} - \\left(\\frac{q}{1-q}\\right)^2 = \\frac{q+q^2 - q^2}{(1-q)^2} = \\frac{q}{(1-q)^2} $$\n代入值$q=1/2$：\n$$ \\mathrm{Var}(L) = \\frac{1/2}{(1 - 1/2)^2} = \\frac{1/2}{(1/2)^2} = \\frac{1/2}{1/4} = 2 $$\n\n因此，进位链长度的期望值是$1$，其方差是$2$。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 1  2 \\end{pmatrix} } $$"
        },
        {
            "introduction": "理解了行波进位的问题后，下一步是构建一个高效的解决方案。本练习要求您亲手实现一个经典的并行前缀 (Parallel Prefix) 加法器架构——Ladner-Fischer 加法器。通过编写代码来生成并行前缀图并验证其正确性，您将不仅仅是了解一个抽象的电路图，而是将深入掌握其递归的构建逻辑和核心的组合运算。这项实践是连接理论与算法实现的关键一步，它揭示了如何将线性时间的进位依赖关系转变为对数时间的并行计算。",
            "id": "4255508",
            "problem": "您的任务是在电子设计自动化（EDA）领域内，为应用于二进制加法的 Ladner–Fischer 并行前缀图构建一个算法生成器。目标是使用平衡树分解来计算所有比特位置的前缀进位对，并通过对树结构进行归纳来验证所得网络的正确性。\n\n此任务的基础是单比特全加器的标准传递（propagate）和生成（generate）定义。令 $a_i$ 和 $b_i$ 分别表示两个非负整数 $A$ 和 $B$ 的第 $i$ 个最低有效位，令 $c_i$ 表示进入比特位置 $i$ 的进位，其中 $c_0$ 为初始输入进位。将单比特生成信号和传递信号定义为 $g_i = a_i \\land b_i$ 和 $p_i = a_i \\oplus b_i$。进位递推关系为 $c_{i+1} = g_i \\lor (p_i \\land c_i)$。对于任意连续的比特位置范围 $[l..r]$，将组对 $(G_{l,r}, P_{l,r})$ 定义为满足 $c_{r+1} = G_{l,r} \\lor (P_{l,r} \\land c_l)$ 对所有允许的 $c_l$ 成立的唯一对。对于两个相邻范围 $[l..m]$ 和 $[m+1..r]$，此类组对上的二元运算由范围串联上的进位组合的结合律定义；利用此性质从 $[l..m]$ 和 $[m+1..r]$ 的对构造出 $[l..r]$ 的组对。\n\n您的程序必须：\n- 通过在每一步递归地将索引范围 $[0..n-1]$ 分解为两半，来构建一个 $n$ 比特的 Ladner–Fischer 并行前缀图。具体步骤为：计算左半部分 $[l..m]$ 的前缀，计算右半部分 $[m+1..r]$ 相对于其自身起始索引的局部前缀，然后将左前缀 $[l..m]$ 与每个右局部前缀结合以获得 $[m+1..r]$ 中所有索引的全局前缀。该图应在算法上表示为一个操作列表，其中每个操作将两个先前可用的组对结合以产生一个新的组对。每个节点对应一个输入对 $(g_i, p_i)$ 或两个节点结合的结果；跟踪依赖关系以确保有效的拓扑顺序。\n- 评估构建的图，以获得所有 $i \\in \\{0,1,\\dots,n-1\\}$ 的 $(G_{0,i}, P_{0,i})$。\n- 使用 $c_{i+1} = G_{0,i} \\lor (P_{0,i} \\land c_0)$ 和 $s_i = p_i \\oplus c_i$ 计算所有进位和和位，适用于所有 $i \\in \\{0,1,\\dots,n-1\\}$，其中 $c_0$ 是给定的初始输入进位。将计算出的算术结果构成整数 $S = \\sum_{i=0}^{n-1} s_i \\cdot 2^i + c_n \\cdot 2^n$。\n- 通过将 $S$ 与每个指定测试用例的基准算术和 $A + B + c_0$ 进行比较来验证正确性。\n\n使用纯逻辑表示信号，其中 $a_i$, $b_i$, $g_i$, $p_i$, $c_i$, $G_{l,r}$ 和 $P_{l,r}$ 均被视作布尔值。所有索引和宽度均为整数。不涉及物理单位。\n\n测试套件：\n- 情况 1：$n=1$, $A=1$, $B=1$, $c_0=0$。\n- 情况 2：$n=4$, $A=9$, $B=6$, $c_0=1$。\n- 情况 3：$n=8$, $A=90$, $B=60$, $c_0=0$。\n- 情况 4：$n=8$, $A=255$, $B=1$, $c_0=1$。\n- 情况 5：$n=32$, $A=4042322160$, $B=252645135$, $c_0=0$。\n- 情况 6：$n=32$, $A=2147483648$, $B=2147483648$, $c_0=1$。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[result_1,result_2,\\dots]$）。每个结果必须是一个布尔值，指示计算出的 $S$ 是否等于该测试用例的基准算术和 $A + B + c_0$。输出的格式必须严格为 $[r_1,r_2,r_3,r_4,r_5,r_6]$，不得包含额外的空白或文本。",
            "solution": "所述问题已经过验证。\n\n### 步骤 1：提取已知条件\n- **任务**：为 $n$ 比特二进制加法构建一个 Ladner–Fischer 并行前缀图的算法生成器，以计算前缀进位对。\n- **输入**：整数 $A$、$B$；比特数 $n$；初始输入进位 $c_0$。\n- **比特级信号**：\n    - 输入比特：$a_i$ 和 $b_i$ 是 $A$ 和 $B$ 的第 $i$ 个比特。\n    - 初始进位：$c_0$。\n    - 单比特生成：$g_i = a_i \\land b_i$。\n    - 单比特传递：$p_i = a_i \\oplus b_i$。\n- **进位递推**：$c_{i+1} = g_i \\lor (p_i \\land c_i)$。\n- **组生成/传递**：对于一个范围 $[l..r]$，对 $(G_{l,r}, P_{l,r})$ 满足 $c_{r+1} = G_{l,r} \\lor (P_{l,r} \\land c_l)$。\n- **组合规则**：串联范围 $[l..r]$ 的组对将根据相邻子范围 $[l..m]$ 和 $[m+1..r]$ 的对，利用进位组合的结合律来构建。\n- **算法结构 (Ladner–Fischer)**：递归地将索引范围 $[0..n-1]$ 分解为两半。右半部分的前缀在局部计算，然后与左半部分的总前缀组合。\n- **评估**：必须评估构建的图以找到所有 $i \\in \\{0, 1, \\dots, n-1\\}$ 的前缀对 $(G_{0,i}, P_{0,i})$。\n- **和的计算**：\n    - 进位：$c_{i+1} = G_{0,i} \\lor (P_{0,i} \\land c_0)$。\n    - 和位：$s_i = p_i \\oplus c_i$。\n    - 最终和：$S = \\sum_{i=0}^{n-1} s_i \\cdot 2^i + c_n \\cdot 2^n$。\n- **验证**：计算出的和 $S$ 必须与基准算术和 $A + B + c_0$ 进行比较。\n- **表示**：所有信号均为布尔值。\n- **测试套件**：提供了六个具体的测试用例，包含 $n, A, B, c_0$ 的值。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据指定的验证标准对问题进行分析。\n- **科学依据充分**：该问题牢固地植根于计算机算术和数字逻辑设计的理论。生成（$g_i$）和传递（$p_i$）信号的定义、进位递推关系以及组生成/传递对的概念都是设计快速加法器的标准和基础。Ladner-Fischer 结构是一种著名的并行前缀网络拓扑。所有引用的原理都具有科学合理性。\n- **定义明确**：问题定义清晰。对于任何给定的输入集 $(n, A, B, c_0)$，所述算法会产生唯一的和位集合和最终的进位输出，从而得到一个确定性的整数和 $S$。验证条件 $S = A + B + c_0$ 为正确性提供了明确的标准。\n- **客观**：问题以精确、正式的语言陈述，没有主观性。所有术语如“生成”、“传递”、“并行前缀图”以及逻辑运算符都是标准的，并具有明确的数学或工程定义。\n\n未发现任何缺陷。该问题是连贯的、自洽的、事实正确的，并且可以算法化地形式化。\n\n### 步骤 3：结论与行动\n问题有效。将提供一个解决方案。\n\n---\n\n### 基于原理的设计\n\n该解决方案的核心是并行前缀计算原理，它将一个串行依赖的计算（如进位传播）转换为一个利用结合性二元运算符的并行友好型计算。\n\n**1. 比特级进位传播**\n对于两个 $n$ 比特二进制数 $A = \\sum_{i=0}^{n-1} a_i 2^i$ 和 $B = \\sum_{i=0}^{n-1} b_i 2^i$ 的加法，在比特位置 $i$ 产生的进位 $c_{i+1}$ 取决于该位置的输入 $a_i$、$b_i$ 和输入进位 $c_i$。这种关系由生成信号 $g_i$ 和传递信号 $p_i$ 捕捉。\n- 如果 $a_i$ 和 $b_i$ 均为 $1$，则在位置 $i$ **生成**一个进位：$g_i = a_i \\land b_i$。\n- 如果 $a_i$ 或 $b_i$ 中恰好有一个为 $1$，则一个进位将**通过**位置 $i$ **传递**：$p_i = a_i \\oplus b_i$。\n\n比特 $i$ 的进位输出（表示为 $c_{i+1}$）为 $1$ 的条件是：在当前阶段生成了一个进位，或者一个进位从前一阶段被传递过来。这给出了基本的进位递推关系：\n$$c_{i+1} = g_i \\lor (p_i \\land c_i)$$\n\n**2. 组生成/传递与结合性组合**\n为了并行化进位计算，我们将 $(g, p)$ 的概念推广到比特块。对于从索引 $l$ 到 $r$（含）的任何连续比特范围，我们定义一个组生成/传递对 $(G_{l,r}, P_{l,r})$。该对在该块的输入进位 $c_l$ 和输出进位 $c_{r+1}$ 之间建立了一个直接关系，如下所示：\n$$c_{r+1} = G_{l,r} \\lor (P_{l,r} \\land c_l)$$\n此定义必须对任何有效的输入进位 $c_l$ 都成立。单比特对 $(g_i, p_i)$ 是一个特例：$(G_{i,i}, P_{i,i}) = (g_i, p_i)$。\n\n并行前缀计算的关键在于这种块组合是具有结合性的。考虑两个相邻的块，$[l..m]$ 和 $[m+1..r]$。我们有：\n$$c_{m+1} = G_{l,m} \\lor (P_{l,m} \\land c_l)$$\n$$c_{r+1} = G_{m+1,r} \\lor (P_{m+1,r} \\land c_{m+1})$$\n将 $c_{m+1}$ 的表达式代入 $c_{r+1}$ 的方程中：\n$$c_{r+1} = G_{m+1,r} \\lor (P_{m+1,r} \\land (G_{l,m} \\lor (P_{l,m} \\land c_l)))$$\n应用分配律（这里需要的是 $X \\land (Y \\lor Z) = (X \\land Y) \\lor (X \\land Z)$，而不是 $X \\lor (Y \\land Z) = (X \\lor Y) \\land (X \\lor Z)$）得到：\n$$c_{r+1} = G_{m+1,r} \\lor (P_{m+1,r} \\land G_{l,m}) \\lor (P_{m+1,r} \\land P_{l,m} \\land c_l)$$\n通过对项进行分组并与定义 $c_{r+1} = G_{l,r} \\lor (P_{l,r} \\land c_l)$ 进行比较，我们推导出组合运算符 $\\circ$：\n$$(G_{l,r}, P_{l,r}) = (G_{m+1,r}, P_{m+1,r}) \\circ (G_{l,m}, P_{l,m})$$\n其中组合定义为：\n$$G_{l,r} = G_{m+1,r} \\lor (P_{m+1,r} \\land G_{l,m})$$\n$$P_{l,r} = P_{m+1,r} \\land P_{l,m}$$\n\n**3. 算法构造：递归前缀计算**\n问题描述了一个递归算法，它反映了 Ladner-Fischer 前缀网络的结构。我们的目标是计算所有 $i \\in \\{0, 1, ..., n-1\\}$ 的前缀对 $(G_{0,i}, P_{0,i})$。该算法实现为一个递归函数 `get_prefix_pairs(l, r)`，它计算范围 $[l, r]$ 内所有 $i$ 的前缀对 $(G_{l,i}, P_{l,i})$。\n\n- **基本情况**：如果范围只包含一个比特，$l=r$，唯一的前缀对是初始的 $(g_l, p_l)$。函数返回一个包含这个单对的列表。\n- **递归步骤**：对于一个范围 $[l,r]$，我们找到中点 $m = l + \\lfloor(r-l)/2\\rfloor$。\n    1. 递归计算左半部分的所有前缀：`left_prefixes` = `get_prefix_pairs(l, m)`。这会得到 $\\{(G_{l,i}, P_{l,i}) | i \\in [l,m]\\}$。\n    2. 递归计算右半部分的所有局部前缀：`right_local_prefixes` = `get_prefix_pairs(m+1, r)`。这会得到 $\\{(G_{m+1,j}, P_{m+1,j}) | j \\in [m+1,r]\\}$。\n    3. 索引 $i \\in [l,m]$ 的最终前缀已经存在于 `left_prefixes` 中。\n    4. 为了获得索引 $j \\in [m+1,r]$ 的全局前缀，我们必须将每个局部右前缀与整个左块的总组前缀组合起来。这个总前缀是 $(G_{l,m}, P_{l,m})$，它是 `left_prefixes` 的最后一个元素。\n    5. 对于 `right_local_prefixes` 中的每个 $(G_{m+1,j}, P_{m+1,j})$，我们计算全局前缀 $(G_{0,j}, P_{0,j})$ 为 $(G_{m+1,j}, P_{m+1,j}) \\circ (G_{l,m}, P_{l,m})$。\n    6. 最终结果是左半部分全局前缀和新计算的右半部分全局前缀的串联。\n\n使用记忆化技术来存储每个范围 `(l,r)` 的结果，避免了冗余计算，并有效地模拟了前缀图中子计算的共享。\n\n**4. 最终求和与验证**\n一旦计算出所有 $i \\in \\{0, \\dots, n-1\\}$ 的前缀对 $(G_{0,i}, P_{0,i})$，就可以直接从初始输入进位 $c_0$ 计算出进入下一个比特位置的进位 $c_{i+1}$：\n$$c_{i+1} = G_{0,i} \\lor (P_{0,i} \\land c_0)$$\n进入比特位置 $i$ 的进位是 $c_i$，其中对于 $i>0$，$c_i = G_{0,i-1} \\lor (P_{0,i-1} \\land c_0)$。然后，和位 $s_i$ 是传递信号 $p_i$ 和输入进位 $c_i$ 的异或：\n$$s_i = p_i \\oplus c_i = (a_i \\oplus b_i) \\oplus c_i$$\n最终的整数和 $S$ 由和位和最终的进位输出 $c_n$ 组合而成：\n$$S = \\left(\\sum_{i=0}^{n-1} s_i \\cdot 2^i\\right) + c_n \\cdot 2^n$$\n然后，通过将其与算术上正确的值 $A+B+c_0$ 进行比较来验证这个计算出的和 $S$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the Ladner-Fischer adder.\n    \"\"\"\n    test_cases = [\n        # Case 1: n=1, A=1, B=1, c_0=0\n        (1, 1, 1, 0),\n        # Case 2: n=4, A=9, B=6, c_0=1\n        (4, 9, 6, 1),\n        # Case 3: n=8, A=90, B=60, c_0=0\n        (8, 90, 60, 0),\n        # Case 4: n=8, A=255, B=1, c_0=1\n        (8, 255, 1, 1),\n        # Case 5: n=32, A=4042322160, B=252645135, c_0=0\n        (32, 4042322160, 252645135, 0),\n        # Case 6: n=32, A=2147483648, B=2147483648, c_0=1\n        (32, 2147483648, 2147483648, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, A, B, c_0 = case\n        is_correct = run_ladner_fischer_test(n, A, B, c_0)\n        results.append(is_correct)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_ladner_fischer_test(n, A, B, c_0):\n    \"\"\"\n    Constructs and evaluates a Ladner-Fischer adder for a single test case.\n\n    Args:\n        n (int): The number of bits.\n        A (int): The first integer operand.\n        B (int): The second integer operand.\n        c_0 (int): The initial carry-in (0 or 1).\n\n    Returns:\n        bool: True if the computed sum equals the arithmetic sum, False otherwise.\n    \"\"\"\n    if n == 0:\n        ground_truth = A + B + c_0\n        # For n=0, sum is just the carry-in.\n        S = c_0\n        return S == ground_truth\n\n    # Convert integers to bit arrays (lsb first)\n    a = [(A >> i)  1 for i in range(n)]\n    b = [(B >> i)  1 for i in range(n)]\n    c_0_bool = bool(c_0)\n\n    # 1. Compute initial generate (g) and propagate (p) signals\n    # g_i = a_i AND b_i\n    # p_i = a_i XOR b_i\n    initial_gp = [(bool(a[i]  b[i]), bool(a[i] ^ b[i])) for i in range(n)]\n\n    # Memoization cache for the recursive prefix computation\n    memo = {}\n\n    # 2. Define the associative composition operator for (G, P) pairs\n    def op(gp2, gp1):\n        \"\"\"\n        Computes (G2, P2) o (G1, P1).\n        This corresponds to the group pair for a range formed by concatenating\n        the range of gp1 followed by the range of gp2.\n        \"\"\"\n        G1, P1 = gp1\n        G2, P2 = gp2\n        # G_out = G2 OR (P2 AND G1)\n        # P_out = P2 AND P1\n        return (G2 or (P2 and G1), P2 and P1)\n\n    # 3. Recursive function to compute prefix pairs\n    def get_prefix_pairs(l, r):\n        \"\"\"\n        Recursively computes all prefix (G, P) pairs for the index range [l, r].\n        The i-th element of the returned list is the group pair for the range [l, l+i].\n        \"\"\"\n        if (l, r) in memo:\n            return memo[(l, r)]\n\n        # Base case: a range of a single bit\n        if l == r:\n            result = [initial_gp[l]]\n            memo[(l, r)] = result\n            return result\n\n        # Recursive step: divide and conquer\n        m = l + (r - l) // 2\n        left_prefixes = get_prefix_pairs(l, m)\n        right_local_prefixes = get_prefix_pairs(m + 1, r)\n\n        # The group (G, P) for the entire left block\n        broadcast_gp = left_prefixes[-1]\n\n        # Combine the left block's total group (G, P) with each of the\n        # right block's local prefixes to get global prefixes.\n        right_global_prefixes = [op(rp, broadcast_gp) for rp in right_local_prefixes]\n\n        result = left_prefixes + right_global_prefixes\n        memo[(l, r)] = result\n        return result\n\n    # Compute all prefix pairs (G_{0,i}, P_{0,i}) for i from 0 to n-1\n    prefix_pairs = get_prefix_pairs(0, n - 1)\n\n    # 4. Compute all carries c_1, ..., c_n using the prefix pairs\n    # c_{i+1} = G_{0,i} OR (P_{0,i} AND c_0)\n    carries = [c_0_bool]\n    for i in range(n):\n        G_0_i, P_0_i = prefix_pairs[i]\n        c_i_plus_1 = G_0_i or (P_0_i and c_0_bool)\n        carries.append(c_i_plus_1)\n\n    # 5. Compute sum bits\n    # s_i = p_i XOR c_i\n    sum_bits = []\n    for i in range(n):\n        p_i = initial_gp[i][1]\n        c_i = carries[i]\n        s_i = p_i ^ c_i\n        sum_bits.append(s_i)\n\n    # 6. Compute the final integer sum and verify\n    S = 0\n    for i in range(n):\n        if sum_bits[i]:\n            S += 1  i\n\n    # Add the final carry-out c_n\n    c_n = carries[n]\n    if c_n:\n        S += 1  n\n\n    ground_truth = A + B + c_0\n    \n    return S == ground_truth\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "一个优秀的逻辑架构最终需要通过物理电路来实现其性能优势。本练习将带您走完从逻辑设计到物理实现的“最后一公里”。您将应用逻辑努力 (Logical Effort) 方法，对构成并行前缀网络关键路径的CMOS逻辑门进行精确的延时分析和尺寸优化。通过计算复杂逻辑门的逻辑努力和寄生延时，并为整个路径确定最优的尺寸缩放策略，您将学会如何在晶体管层面权衡速度、功耗和面积，这是通往高性能集成电路设计的核心技能。",
            "id": "4255542",
            "problem": "一个并行前缀进位网络使用黑色前缀单元来加速一个$64$位加法器中的进位。在关键生成路径上，有$N=6$个相同的黑色前缀单元串联。每个黑色单元实现为一个扇入为$4$的静态互补金属氧化物半导体（CMOS）复合门，类型为与或非（AOI）或或与非（OAI）（功能上等同于$\\text{AOI22}$或其对偶$\\text{OAI22}$）。使用逻辑努力法来建模延迟，并采用以下归一化和物理假设：\n\n- 用于归一化的最小反相器，其$n$沟道宽度为$1$，$p$沟道宽度为$2$（如此选择是为了均衡上拉和下拉电阻）。其输入电容表示为$C_{\\text{inv}}$，且与器件宽度的总和成正比。门输入电容与该输入所驱动的晶体管宽度的总和成正比。\n- 上拉或下拉导通路径中的串联器件尺寸被增大，以使其最坏情况下的路径电阻与最小反相器的电阻相等。\n- 门的寄生延迟与其输出端连接的总扩散电容成正比，并相对于反相器的寄生延迟进行归一化；假设输出端每个器件的扩散贡献是线性相加的。\n- 此路径上没有分支（分支努力等于$1$）。\n\n该路径必须驱动一个$C_{L} = 256\\,C_{\\text{inv}}$的最终负载。驱动第一个黑色单元的源不能调整尺寸，这限制了第一个黑色单元所见的输入电容最多为$4\\,C_{\\text{inv}}$。您可以假设第一个黑色单元的尺寸恰好满足此输入电容预算。延迟以逻辑努力延迟单位$\\tau$来衡量。\n\n任务：\n1. 根据上述尺寸调整规则，推导$\\text{AOI22}$/$\\text{OAI22}$黑色单元的逻辑努力$g$和寄生延迟$p$。\n2. 使用逻辑努力法以及给定的负载和输入电容约束，确定每级的最佳努力以及沿路径相应的尺寸变化序列（表示为每级输入电容相对于$C_{\\text{inv}}$的倍数）。\n3. 计算最小路径延迟$D_{\\min}$，单位为$\\tau$。\n\n仅报告$D_{\\min}$的数值（单位为$\\tau$）作为您的最终答案。无需四舍五入。",
            "solution": "用户希望我解决一个关于使用逻辑努力法计算$64$位加法器关键路径最小延迟的问题。\n\n**问题验证**\n\n**第1步：提取已知条件**\n- 串联级数：$N=6$。\n- 单元类型：相同的黑色前缀单元，实现为扇入为$4$的静态CMOS AOI22或OAI22门。\n- 归一化反相器：$n$沟道宽度为$1$，$p$沟道宽度为$2$。其输入电容为$C_{\\text{inv}}$。\n- 尺寸调整规则：串联晶体管的尺寸被增大，以使最坏情况下的路径电阻与归一化反相器的电阻相匹配。\n- 寄生延迟规则：寄生延迟与输出端的总扩散电容成正比，并相对于反相器的寄生延迟进行归一化。\n- 路径分支努力：$B=1$。\n- 总负载电容：$C_{L} = 256\\,C_{\\text{inv}}$。\n- 第一级的输入电容约束：$C_{\\text{in},1} = 4\\,C_{\\text{inv}}$。\n- 目标是求出最小路径延迟$D_{\\min}$，单位为$\\tau$。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据：** 该问题是逻辑努力法的标准应用，逻辑努力法是数字集成电路设计中用于优化路径延迟的既定基本技术。所有概念（AOI门、CMOS尺寸调整、寄生延迟、路径努力）都是该领域的核心内容。\n- **问题定义明确：** 问题定义清晰，提供了计算最小延迟$D_{\\min}$的唯一且有意义的解所需的所有必要参数（$N$、单元类型、尺寸调整规则、$C_L$、$C_{\\text{in},1}$）。\n- **客观性：** 问题以精确、定量且无偏见的技术语言陈述。\n\n该问题不违反任何无效性标准。它是一个在数字电路分析领域中完整、一致且科学合理的问题。\n\n**结论**\n该问题有效。我将开始解答。\n\n**解题推导**\n\n解题过程按照题目要求分为三部分：\n1.  推导黑色前缀单元的逻辑努力$g$和寄生延迟$p$。\n2.  确定每级的最佳努力。\n3.  计算最小路径延迟$D_{\\min}$。\n\n**1. AOI22单元的逻辑努力和寄生延迟**\n\n黑色前缀单元是一个AOI22门，其布尔函数为$F = \\overline{(A \\cdot B) + (C \\cdot D)}$。我们必须首先确定使该门具有与参考反相器相同驱动强度所需的晶体管尺寸。参考反相器有一个宽度为$1$的$n$沟道晶体管和一个宽度为$2$的$p$沟道晶体管。这种尺寸设计可以均衡上拉和下拉电阻，我们将其表示为$R_{\\text{inv}}$。此反相器的输入电容与其栅极宽度的总和$1+2=3$成正比。\n\n**调整AOI22门的尺寸：**\n- **下拉网络 (PDN)：** PDN由两个并联的支路组成，每个支路有两个串联的$n$沟道晶体管（例如，A与B串联）。最坏情况下的下拉电阻发生在只有一个支路导通时。该路径由两个串联的$n$沟道晶体管组成。为了使总电阻等于$R_{\\text{inv}}$，这两个晶体管中的每一个的电阻都必须是$R_{\\text{inv}}/2$。由于电阻与宽度成反比，它们的宽度必须是参考$n$沟道晶体管的两倍。因此，所有$n$沟道晶体管的宽度必须为$2 \\times 1 = 2$。\n- **上拉网络 (PUN)：** PUN是PDN的对偶网络。它由两个串联的模块组成，每个模块包含两个并联的$p$沟道晶体管（例如，A与C并联）。最坏情况下的上拉电阻发生在路径通过每个串联模块中的一个晶体管时。该路径由两个串联的$p$沟道晶体管组成。为了使它们的总电阻等于$R_{\\text{inv}}$，每个晶体管的电阻必须是$R_{\\text{inv}}/2$。参考$p$沟道晶体管的宽度为$2$，电阻为$R_{\\text{inv}}$。因此，为了达到一半的电阻，宽度必须加倍。因此，所有$p$沟道晶体管的宽度必须为$2 \\times 2 = 4$。\n\n**逻辑努力 ($g$)：**\n一个门的逻辑努力是其输入电容与具有相同输出驱动强度的反相器输入电容之比。\n- AOI22门在任一输入端（例如A）的输入电容与其驱动的晶体管（一个$n$沟道，一个$p$沟道）宽度的总和成正比：$C_{\\text{in,AOI22}} \\propto W_n + W_p = 2 + 4 = 6$。\n- 参考反相器的输入电容与$W_{n,\\text{inv}} + W_{p,\\text{inv}} = 1 + 2 = 3$成正比。\n- 逻辑努力$g$是这些电容的比值：\n$$g = \\frac{C_{\\text{in,AOI22}}}{C_{\\text{in,inv}}} = \\frac{6}{3} = 2$$\n对OAI22门的分析会得到相同的结果。\n\n**寄生延迟 ($p$)：**\n寄生延迟是门的输出扩散电容与参考反相器的输出扩散电容之比。扩散电容与连接到输出节点的晶体管漏极的总宽度成正比。\n- **AOI22输出节点：** 输出端连接到两个$n$沟道晶体管和两个$p$沟道晶体管的漏极。（PDN的结构为Y--nA--nB--GND和Y--nC--nD--GND，因此nA和nC的漏极连接到Y。PUN是对偶的，因此存在对称连接）。\n- AOI22输出端的总扩散宽度是这四个晶体管宽度的总和：$W_{\\text{diff,AOI22}} = 2 \\cdot W_n + 2 \\cdot W_p = 2 \\cdot 2 + 2 \\cdot 4 = 4 + 8 = 12$。\n- **反相器输出节点：** 输出端连接到一个$n$沟道和一个$p$沟道晶体管的漏极。总扩散宽度为：$W_{\\text{diff,inv}} = 1 \\cdot W_{n,\\text{inv}} + 1 \\cdot W_{p,\\text{inv}} = 1 \\cdot 1 + 1 \\cdot 2 = 3$。\n- 寄生延迟$p$是这些扩散宽度的比值（假设通过归一化$p_{\\text{inv}}=1$）：\n$$p = \\frac{W_{\\text{diff,AOI22}}}{W_{\\text{diff,inv}}} = \\frac{12}{3} = 4$$\n\n**2. 最佳级努力和路径参数**\n\n该路径由$N=6$个相同的级组成。当每级的努力相同时，路径的延迟最小。级努力为$f_i = g_i h_i$，其中$g_i$是逻辑努力，$h_i$是电学努力。\n- 路径逻辑努力：$G = \\prod_{i=1}^{N} g_i = g^N = 2^6 = 64$。\n- 路径电学努力：$H = \\frac{C_L}{C_{\\text{in},1}}$，其中$C_L$是最终负载，$C_{\\text{in},1}$是第一级的输入电容。\n$$H = \\frac{256\\,C_{\\text{inv}}}{4\\,C_{\\text{inv}}} = 64$$\n- 总路径努力：$F = GBH$。由于分支努力$B=1$，所以$F=GH$。\n$$F = 64 \\times 64 = 4096$$\n最佳级努力$f_{\\text{opt}}$是总路径努力的$N$次根：\n$$f_{\\text{opt}} = F^{1/N} = (4096)^{1/6} = (2^{12})^{1/6} = 2^{12/6} = 2^2 = 4$$\n\n**3. 最小路径延迟 ($D_{\\min}$)**\n\n总路径延迟$D$是各级延迟$d_i = f_i + p_i$的总和。当延迟最小时，所有级努力都等于$f_{\\text{opt}}$。\n最小路径延迟由以下公式给出：\n$$D_{\\min} = N \\cdot f_{\\text{opt}} + P_{\\text{path}}$$\n其中$P_{\\text{path}}$是路径中所有级的寄生延迟之和。\n- 路径寄生延迟：$P_{\\text{path}} = \\sum_{i=1}^{N} p_i = N \\cdot p = 6 \\times 4 = 24$。\n将$N$、$f_{\\text{opt}}$和$P_{\\text{path}}$的值代入：\n$$D_{\\min} = (6 \\times 4) + 24 = 24 + 24 = 48$$\n延迟以$\\tau$为单位测量，这是逻辑努力方法的基本延迟单位。\n各级的尺寸应调整为使得每级的电学努力为$h_i = f_{\\text{opt}} / g = 4 / 2 = 2$。\n这导致输入电容序列为：$C_{\\text{in},1} = 4\\,C_{\\text{inv}}$，$C_{\\text{in},2} = 8\\,C_{\\text{inv}}$，...，$C_{\\text{in},6} = 128\\,C_{\\text{inv}}$。最后一级的输出为$h_6 \\cdot C_{\\text{in},6} = 2 \\cdot 128\\,C_{\\text{inv}} = 256\\,C_{\\text{inv}}$，这与负载$C_L$正确匹配。\n因此，最小延迟为$48\\,\\tau$。",
            "answer": "$$\\boxed{48}$$"
        }
    ]
}