## 引言
在当今数十亿晶体管规模的[集成电路](@entry_id:265543)（IC）设计中，确保每一个信号都能在纳秒甚至皮秒级别的时间窗内准确无误地到达目的地，是决定芯片成败的关键。传统的动态仿真方法虽然精确，但面对海量的逻辑状态和路径，其耗时之长使其无法胜任全芯片的时序验证。[静态时序分析](@entry_id:177351)（Static Timing Analysis, STA）正是在这一背景下应运而生，它已成为数字IC设计流程中不可或缺的基石，提供了一种高效、全面的时序签核（sign-off）手段。

本文旨在系统性地介绍静态时序分析的完整知识体系，从基本原理到高级应用，为读者构建一个坚实的理论与实践框架。文章将解决的核心问题是：STA是如何在不执行逻辑仿真的前提下，验证整个芯片的[时序性](@entry_id:924959)能的？它依赖哪些模型和算法？设计者又该如何通过约束来“指挥”这个强大的分析引擎？

为了循序渐进地解答这些问题，本文将分为三个核心章节。第一章“原理与机制”将深入剖析STA的底层逻辑，从[时序图](@entry_id:1133191)的抽象、单元延迟的建模，到建立与[保持时间](@entry_id:266567)的检查机制，并解释[时钟不确定性](@entry_id:1122497)、[片上变异](@entry_id:164165)（OCV）等高级概念。第二章“应用与跨学科连接”将理论联系实际，展示STA如何在多时钟域设计、低功耗策略（如时钟门控和电源门控）以及物理实现中发挥关键作用，并探讨其与机器学习等前沿领域的交叉。最后，第三章“动手实践”提供了一系列精心设计的练习，帮助读者将理论知识转化为解决实际问题的能力。通过本次学习，您将全面掌握静态时序分析与约束建模的核心技能，为应对复杂的IC[时序收敛](@entry_id:167567)挑战打下坚实的基础。

## 原理与机制

静态时序分析（Static Timing Analysis, STA）是现代数字[集成电路设计流程](@entry_id:1126336)中不可或缺的一环。它提供了一种无需进行全芯片逻辑仿真的高效方法，用于验证设计是否满足时序要求。本章将深入探讨[静态时序分析](@entry_id:177351)的核心原理和关键机制，从电路时序的基本模型出发，逐步解析其算法、约束建模方法以及在复杂设计场景下的高级应用。

### [时序图](@entry_id:1133191)：[数字电路](@entry_id:268512)的抽象模型

静态时序分析的第一步是将复杂的晶体管级电路抽象为一个更易于分析的模型。这个模型就是**[时序图](@entry_id:1133191) (Timing Graph)**，一个有向图 $G=(V, E)$。

在这个图中，**节点 (vertices)** $V$ 代表电路中的“时序点”，通常是标准单元或宏单元的引脚（pins），例如输入引脚、输出引脚、寄存器的数据和时钟引脚，以及设计顶层的主输入/输出端口。**边 (edges)** $E$ 则代表节点之间的“时序弧 (timing arcs)”，它们表示信号在两个节点间传播的因果关系。

时序弧主要分为两类：

1.  **[组合逻辑](@entry_id:265083)弧 (Combinational Arcs)**：表示信号通过组合逻辑单元的路径。例如，一个[与非门](@entry_id:151508)有两个输入引脚 A、B 和一个输出引脚 Z，那么就存在从 A 到 Z 和从 B 到 Z 的两条时序弧。每条弧都带有一个权重，表示信号通过该路径的**[传播延迟](@entry_id:170242) (propagation delay)**。

2.  **时序逻辑弧 (Sequential Arcs)**：与时序元件（如触发器或[锁存器](@entry_id:167607)）相关。最常见的时序弧是**钟到Q延时 (clock-to-Q delay)**，它表示从时钟引脚的有效边沿事件到数据输出引脚 Q 产生新值的延迟。此外，时序元件还引入了建立时间和[保持时间](@entry_id:266567)等约束，这些不是[传播延迟](@entry_id:170242)，而是对输入信号稳定性的要求，我们将在稍后讨论。

通过将整个设计的网表（netlist）转换成一个巨大的[时序图](@entry_id:1133191)，STA 工具就可以将复杂的电路时序验证问题简化为[图论](@entry_id:140799)中的路径[延迟计算](@entry_id:755964)问题。

### 逻辑单元的基本时序参数

[时序图](@entry_id:1133191)中的延迟信息源于对电路中每个基本逻辑单元的精确建模。这些模型被存储在称为“时序库 (timing libraries)”的文件中，通常采用 Liberty (`.lib`) 格式。

#### [传播延迟](@entry_id:170242)与转换时间

一个逻辑单元的**传播延迟 (propagation delay)** 是指从其输入引脚的电压变化（越过某个阈值）到其输出引脚的电压相应变化（越过某个阈值）所经过的时间。**转换时间 (transition time)** 或称**压摆率 (slew rate)**，则描述了信号电压从一个逻辑状态转换到另一个状态所需的时间，通常定义为电压在两个特定百分比（如 10% 和 90%）之间变化的时间。

关键在于，一个单元的延迟和输出转换时间并不是固定值，它们强烈依赖于两个因素：**输入信号的转换时间 ($s_{in}$)** 和 **输出引脚的负载电容 ($C_{out}$)**。 直观地理解，输入信号变化越慢（$s_{in}$ 越大），单元内部的晶体管状态翻转就越慢；输出负载电容越大（$C_{out}$ 越大），驱动该电容充放电所需的时间就越长。这两种情况都会导致更大的[传播延迟](@entry_id:170242)和更慢的输出转换时间。

为了在 STA 中精确计算延迟，时序库提供了对这种[非线性依赖](@entry_id:265776)关系的建模。

*   **[非线性](@entry_id:637147)延迟模型 (NLDM, Non-Linear Delay Model)**：这是最经典的模型之一。NLDM 使用二维[查找表](@entry_id:177908) (Lookup Tables, LUTs) 来描述每个时序弧的延迟和输出转换时间。这些表格以离散的输入转换时间 ($s_{in}$) 和输出负载 ($C_{out}$) 值为索引。 当 STA 工具需要计算一个特定 $(s_{in}, C_{out})$ 组合下的延迟时，如果该点不在表格的格点上，它会使用**[双线性插值](@entry_id:170280) (bilinear interpolation)** 来估算。 例如，对于一个查询点 $(s, C)$，它位于由 $(s_i, C_j)$, $(s_{i+1}, C_j)$, $(s_i, C_{j+1})$, $(s_{i+1}, C_{j+1})$ 四个格点定义的单元格内，其延迟 $D(s, C)$ 可以通过先在 $s$ 轴上进行两次[线性插值](@entry_id:137092)，然后再在 $C$ 轴上进行一次[线性插值](@entry_id:137092)得到。其通用公式为：

    $$D(s, C) = \frac{1}{(s_{i+1} - s_i)(C_{j+1} - C_j)} \left( D_{i,j}(s_{i+1}-s)(C_{j+1}-C) + D_{i+1,j}(s-s_i)(C_{j+1}-C) + D_{i,j+1}(s_{i+1}-s)(C-C_j) + D_{i+1,j+1}(s-s_i)(C-C_j) \right)$$

    其中 $D_{i,j}$ 是在格点 $(s_i, C_j)$ 处的延迟值。这个模型虽然简单高效，但其将负载简化为单个集总电容，限制了其精度。

*   **复合[电流源](@entry_id:275668)模型 (CCS, Composite Current Source)**：为了克服 NLDM 的精度限制，CCS 模型应运而生。它不再直接提供延迟值，而是为驱动器提供一个等效的、随时间变化的[电流源](@entry_id:275668)模型。该模型同样以 $(s_{in}, C_{out})$ 为索引。在分析时，STA 工具使用这个电流源模型来“驱动”实际的下游互连线和接收引脚的[非线性](@entry_id:637147)电容模型，通过求解电路的[微分](@entry_id:158422)方程来动态地重构输出电压波形 $V_{out}(t)$。然后，从这个计算出的波形上测量出实际的延迟和转换时间。这种方法能够更精确地捕捉到由米勒效应等引起的[非线性](@entry_id:637147)负载效应，从而提高[时序分析](@entry_id:178997)的准确性。

#### 时序元件的约束：建立时间与保持时间

与[组合逻辑](@entry_id:265083)单元不同，时序元件（如[边沿触发](@entry_id:172611)的触发器）的核心功能是在时钟的特定时刻“捕获”数据。为了确保数据能够被可靠地捕获并避免进入**亚稳态 (metastability)**，数据输入信号必须在时钟有效边沿附近的一个时间窗口内保持稳定。这个窗口由**[建立时间](@entry_id:167213) ($t_{setup}$)** 和**[保持时间](@entry_id:266567) ($t_{hold}$)** 定义。

*   **建立时间 ($t_{setup}$)**：是指在时钟有效边沿**到达之前**，数据信号必须保持稳定的最小时间。这是为了确保数据有足够的时间在触发器内部的“主[锁存器](@entry_id:167607)”关闭之前传播到位。

*   **保持时间 ($t_{hold}$)**：是指在时钟有效边沿**到达之后**，数据信号必须保持稳定的最小时间。这是为了防止数据在主[锁存器](@entry_id:167607)完全关闭并与输入隔离之前发生变化，从而破坏了刚刚捕获的值。

至关重要的一点是，建立时间和[保持时间](@entry_id:266567)是施加在触发器数据输入 ($D$) 和时钟输入 ($CK$) 之间的**[时序约束](@entry_id:168640) (timing constraints)**，它们本身**不是[传播延迟](@entry_id:170242)**。它们定义了一个数据转换的“[禁区](@entry_id:175956)”。与之相对的**钟到Q延时 ($t_{cq}$)** 则是一个真正的传播延迟，它衡量的是从时钟有效边沿事件发生到输出端 Q 出现新数据所需要的时间。在时序库中，这三种参数 ($t_{setup}$, $t_{hold}$, $t_{cq}$) 都是单元固有的、经过精确表征的特性。

### 静态时序分析：在图中传播时间

有了[时序图](@entry_id:1133191)和单元时序模型，STA 的核心任务就是在图上执行路径[延迟计算](@entry_id:755964)，以检查是否所有路径都满足[时序约束](@entry_id:168640)。这一过程围绕三个核心概念展开：实际到达时间、要求到达时间和时序裕量。

#### 核心概念：AAT、RAT 与 Slack

*   **实际到达时间 (AAT, Actual Arrival Time)**：一个节点上的 AAT 是指信号从某个**起点 (startpoint)**（通常是主输入端口或寄存器的时钟引脚）出发，到达该节点所经历的**最长**（用于建立时间分析）或**最短**（用于[保持时间](@entry_id:266567)分析）的延迟。AAT 是沿着[时序图](@entry_id:1133191)**[前向传播](@entry_id:193086)**的。对于一个节点 $v$，其 AAT（用于[建立时间](@entry_id:167213)分析）由所有指向它的前驱节点 $u$ 的 AAT 加上相应的边延迟 $d_{(u,v)}$ 后的最大值决定：
    $$AAT(v) = \max_{(u,v) \in E} \{AAT(u) + d_{(u,v)}\}$$

*   **要求到达时间 (RAT, Required Arrival Time)**：一个节点上的 RAT 是指为了满足**终点 (endpoint)**（通常是主输出端口或寄存器的数据引脚）的时序约束，信号**必须**到达该节点的最晚（用于[建立时间](@entry_id:167213)分析）或最早（用于保持时间分析）的时刻。RAT 是沿着[时序图](@entry_id:1133191)从终点**[反向传播](@entry_id:199535)**的。对于一个节点 $u$，其 RAT（用于建立时间分析）由其所有后继节点 $v$ 的 RAT 减去相应的边延迟 $d_{(u,v)}$ 后的最小值决定：
    $$RAT(u) = \min_{(u,v) \in E} \{RAT(v) - d_{(u,v)}\}$$

*   **时序裕量 (Slack)**：在任何一个节点上，时序裕量都是要求到达时间与实际到达时间之间的差值。对于建立时间分析：
    $$Slack(v) = RAT(v) - AAT(v)$$
    一个正的 Slack 值意味着信号在该点提前到达，满足时序要求，且有多余的时间裕量。一个负的 Slack 值则意味着信号到达太晚，发生了**建立时间违例 (setup violation)**，这是设计必须修复的关键问题。

#### 实例：寄存器到寄存器的[路径分析](@entry_id:753256)

让我们通过一个具体的例子来理解这些概念。考虑一条从启动寄存器 $R_1$ 到捕获寄存器 $R_2$ 的单周期路径。

假设[时钟周期](@entry_id:165839)为 $T$，[时钟信号](@entry_id:174447)到达 $R_1$ 时钟端的延迟（时钟插入延迟）为 $L_\ell$，到达 $R_2$ 时钟端的延迟为 $L_c$。$R_1$ 的钟到Q延时为 $t_{cq}$，连接 $R_1.Q$ 和 $R_2.D$ 的组合逻辑路径最大延迟为 $T_{logic}$，$R_2$ 的建立时间为 $t_{setup}$，并考虑一个[时钟不确定性](@entry_id:1122497)（见下节）为 $U$。

1.  **计算 AAT**：数据从 $R_1$ 启动的时刻是时钟沿到达 $R_1$ 的时刻，即 $L_\ell$。数据出现在 $R_1.Q$ 的时刻是 $L_\ell + t_{cq}$。经过[组合逻辑](@entry_id:265083)后，数据到达 $R_2.D$ 的**实际到达时间**为：
    $$AAT(R_2.D) = L_\ell + t_{cq} + T_{logic}$$

2.  **计算 RAT**：数据在 $R_2$ 被捕获的[时钟沿](@entry_id:171051)是下一个周期的时钟沿。该时钟沿到达 $R_2$ 的时刻是 $L_c + T$。为了满足[建立时间](@entry_id:167213)约束，数据必须在此时刻之前 $t_{setup}$ 再加上不确定性 $U$ 的时间稳定下来。因此，数据在 $R_2.D$ 的**要求到达时间**为：
    $$RAT(R_2.D) = (L_c + T) - t_{setup} - U$$

3.  **计算 Slack**：该路径在 $R_2.D$ 处的[建立时间裕量](@entry_id:164917)为：
    $$Slack_{setup} = RAT(R_2.D) - AAT(R_2.D) = (L_c + T - t_{setup} - U) - (L_\ell + t_{cq} + T_{logic})$$

这个公式是所有 STA [建立时间](@entry_id:167213)分析的核心。

### 时钟的角色：不确定性与悲观性

在理想世界中，时钟信号会同时到达芯片上的所有寄存器。但在现实中，时钟信号的传播会受到各种非理想因素的影响，这些因素是 STA 必须精确建模的关键。

#### 时钟偏斜、[抖动](@entry_id:200248)与不确定性

*   **[时钟偏斜](@entry_id:177738) (Clock Skew)**：定义为同一个时钟源发出的同一个时钟沿到达两个不同寄存器（例如启动寄存器和捕获寄存器）时钟引脚的**时间差**。若启动寄存器的时钟到达时间为 $L_\ell$，捕获寄存器的时钟到达时间为 $L_c$，则偏斜为 $s = L_c - L_\ell$。[时钟偏斜](@entry_id:177738)对时序有双重影响：对于建立时间，正偏斜（捕获时钟晚于启动时钟）相当于“借用”了时间给数据路径，从而**放宽**了约束；而对于[保持时间](@entry_id:266567)，正偏斜则要求数据路径更快，**收紧**了约束。

*   **时钟抖动 (Clock Jitter)**：指[时钟信号](@entry_id:174447)的边沿相对于其理想位置的随机、短期的变化。这是由电源噪声、相位噪声等物理因素引起的。STA 作为一种静态的最差情况分析，必须考虑[抖动](@entry_id:200248)带来的影响。

*   **[时钟不确定性](@entry_id:1122497) (Clock Uncertainty)**：在 STA 中，为了简化分析并保证稳健性，通常会定义一个**[时钟不确定性](@entry_id:1122497)** ($U$) 参数。这是一个综合性的“[保护带](@entry_id:1125839)”，它包含了[时钟抖动](@entry_id:1133193)、未被精确建模的残余偏斜、以及其他建模误差。在时序计算中，这个不确定性总是以**悲观**的方式被应用：对于[建立时间](@entry_id:167213)检查，它从可用的时间窗口中被减去；对于[保持时间](@entry_id:266567)检查，它被加到要求的[稳定时间](@entry_id:273984)上。因此，[时钟不确定性](@entry_id:1122497)会同时**收紧**建立时间和保持时间约束。

#### [片上变异](@entry_id:164165)与共同时钟路径悲观性移除 (CPPR)

在先进工艺节点下，即使是相邻的两个[逻辑门](@entry_id:178011)，其性能也可能因为制造过程中的微小随机差异（即**[片上变异](@entry_id:164165), On-Chip Variation, OCV**）而有所不同。为了对 OCV 进行建模，STA 通常会对路径延迟应用一个“降额 (derate)”因子，即对某些路径使用更慢的延迟（例如，乘以 1.1），对另一些路径使用更快的延迟（例如，乘以 0.9）。

一个典型的悲观分析场景是：在进行[保持时间](@entry_id:266567)检查时，假设启动时钟路径最慢（max derate），而捕获时钟路径最快（min derate）。然而，启动和捕获时钟路径通常会共享一段从时钟源头开始的**共同路径**，直到某个分支点才分开。 假设同一段物理路径同时既是最慢又是最快，这在物理上是不可能的，从而引入了不必要的分析悲观性。

**共同时钟路径悲观性移除 (CPPR, Common Path Pessimism Removal)** 或称时钟收敛悲观性移除 (CRPR)，就是一种修正这种分析缺陷的技术。它能够识别出启动和捕获时钟路径中的共同部分，并计算出由于对其应用不同降额因子而引入的“伪”时差。然后，在计算时序裕量时，将这个伪时差作为“补偿”加回去，从而得到一个更精确、不那么悲观的分析结果。CPPR 对于建立时间和[保持时间](@entry_id:266567)分析都至关重要。 

### 约束建模：SDC 的语言

STA 的强大之处不仅在于其分析能力，还在于其高度的可配置性。设计者通过**Synopsys 设计约束 (SDC, Synopsys Design Constraints)** 文件来告知 STA 工具设计的意图和性能目标。

#### 定义时钟与I/O时序

*   `create_clock`：这是所有同步时序约束的基石。它在一个端口或引脚上定义一个时钟源，[并指](@entry_id:276731)定其周期和波形。所有后续的同步时序检查都将以此为参考。

*   `set_input_delay` / `set_output_delay`：这些命令用于约束设计的边界。`set_input_delay` 告诉工具，相对于某个时钟，一个输入信号在到达芯片输入端口时已经花费了多少时间（即芯片外部的延迟）。`set_output_delay` 则告诉工具，一个输出信号从芯片输出端口发出后，到达外部捕获寄存器之前需要多少时间。`-max` 选项用于[建立时间](@entry_id:167213)分析（最长外部路径），而 `-min` 选项用于保持时间分析（最短外部路径）。

#### 路径例外：精炼分析

默认情况下，STA 会分析所有拓扑上存在的路径。然而，很多路径在功能上是不可能被激活的，或者其时序要求与默认的单周期假设不同。通过路径例外指令，我们可以让分析更贴近实际。

*   **[伪路径](@entry_id:168255) (False Paths)**：某些拓扑上存在的路径，由于逻辑上的**路径敏化 (path sensitization)** 条件永远无法满足，因此信号的跳变永远无法沿着该路径从头到尾传播。 例如，考虑一个两级[多路选择器](@entry_id:172320)（MUX）电路，其[选择信号](@entry_id:894787)都由同一个[控制信号](@entry_id:747841) $s$ 控制。如果一条拓扑路径需要信号在第一级 MUX 沿着 $s=0$ 的路径通过，而在第二级 MUX 沿着 $s=1$ 的路径通过，那么这条路径的敏化条件就是 $(s=0) \land (s=1)$。这个条件在逻辑上是矛盾的，因此该路径是**功能上不可敏化**的，即为一条伪路径。 使用 `set_false_path` 命令可以将这类路径（以及[异步时钟域](@entry_id:1121164)之间的跨域路径等）从时序分析中排除，避免工具在这些无意义的路径上浪费精力进行优化。

*   **[多周期路径](@entry_id:172527) (Multicycle Paths)**：某些路径在设计上就被允许花费多个[时钟周期](@entry_id:165839)来完成[信号传播](@entry_id:165148)。例如，一个操作需要 3 个周期才能计算出结果。通过 `set_multicycle_path -setup 3` 命令，我们可以告知 STA 工具，将这条路径的建立时间检查的捕获沿向后推迟 $(3-1)=2$ 个周期。 这极大地放宽了[建立时间](@entry_id:167213)约束，允许更长的逻辑延迟。例如，在  的场景中，一个周期为 1.0 ns、初始沿在 0.25 ns 的时钟，对于一个 3 周期的路径，其捕获沿的理想时间将是 $0.25 ns + 3 \times 1.0 ns = 3.25 ns$，相应的 RAT 也会被推迟整整 3 个周期。值得注意的是，简单地设置多周期建立时间约束，通常会不当地放宽[保持时间](@entry_id:266567)约束。因此，往往需要一个相应的 `set_multicycle_path -hold` 命令来将保持时间检查恢复到更符合实际的位置（通常是相对于原始的单周期关系）。

### 高级主题与方法学

随着芯片设计的日益复杂，STA 的方法学也在不断演进，以应对更多的挑战。

#### 多模式多角（MMMC）分析

现代芯片常常需要在多种不同的工作**模式 (Mode)** 下运行（例如，功能模式、测试模式、低功耗模式），并且必须在各种不同的工艺、电压和温度 (PVT) **角 (Corner)** 下都能正常工作。

*   一个**约束模式**定义了一组特定的时序意图，通常由一个 SDC 文件体现，包含时钟定义、I/O 约束和路径例外等。
*   一个**延迟角**则定义了一组特定的物理工作条件和相应的时序库。例如，**慢速角 (slow corner)** 通常对应于低电压、高温度和慢工艺（SS）的组合，它会导致最大的单元和连线延迟，用于进行**建立时间分析**。而**快速角 (fast corner)** 则对应于高电压、低温度和快工艺（FF）的组合，导致最小的延迟，用于进行**[保持时间](@entry_id:266567)分析**。
*   **分析视图 (Analysis View)** 是一个（模式，角）的组合。**多模式多角（MMMC）分析**的核心思想就是对所有这些有意义的分析视图进行全面的时序检查，以确保芯片在所有预期的工作场景下都具有时序稳健性。一个设计需要验证的分析视图总数是模式集合与角[集合的笛卡尔积](@entry_id:156125)。

#### [统计静态时序分析 (SSTA)](@entry_id:1132340)

基于角的分析本质上是检查离散的、最坏情况的几个点。然而，工艺变异是连续和统计性的。**[统计静态时序分析 (SSTA)](@entry_id:1132340)** 是一种更先进的方法，它不再将延迟视为单个数值，而是将其建模为概率分布（例如，均值 $\mu$ 和标准差 $\sigma$）。这种统计信息通常通过**Liberty 变异格式 (LVF)** 的库来提供。 SSTA 能够在整个电路上进行统计延迟的传播和叠加，从而提供对[时序良率](@entry_id:1133194)（yield）的更准确预测，而不仅仅是简单的通过/失败判断。

#### 锁存器[时序分析](@entry_id:178997)

与触发器不同，电平敏感的**[锁存器](@entry_id:167607) (latch)** 在其时钟的某个电平（例如高电平）期间是**透明的 (transparent)**，数据可以直接穿过。这带来了“**时间借用 (time borrowing)**”的特性：如果数据早于锁存器打开沿到达，它可以“借用”锁存器透明窗口的时间继续向前传播。然而，这也可能导致信号在逻辑上形成[组合逻辑](@entry_id:265083)环路，使得传统的 AAT 传播算法失效。

处理这类复杂时序需要高级算法。一种标准方法是构建一个**时间展开图 (time-expanded graph)**，其中图的每个节点都附带一个周期索引 $k$。信号通过[组合逻辑](@entry_id:265083)时保持在同一周期 $k$，而通过时序元件时则会进入下一个周期 $k+1$。这样，[原始图](@entry_id:262918)中的任何环路在展开图中都会变成一条不断前进的无环路径。 此外，为了检查由[透明锁存器](@entry_id:756130)组成的环路是否满足时序约束（即没有“零周期”违例），需要将时[序关系](@entry_id:138937)表示为一个**[差分约束](@entry_id:634030)系统 (system of difference constraints)**，并使用如[图论](@entry_id:140799)中的 **[Bellman-Ford](@entry_id:634399) 算法**来检测是否存在“[负权环](@entry_id:633892)”，[负权环](@entry_id:633892)的存在意味着时序约束本身是不可满足的。

通过这些层层递进的原理和机制，静态时序分析构筑了一个强大而高效的框架，为确保数十亿晶体管的现代芯片能够在设计的速度下可靠运行提供了根本保障。