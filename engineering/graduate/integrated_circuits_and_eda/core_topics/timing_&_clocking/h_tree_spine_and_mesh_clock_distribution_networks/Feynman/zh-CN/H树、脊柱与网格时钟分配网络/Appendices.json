{
    "hands_on_practices": [
        {
            "introduction": "在设计高性能时钟网络时，精确计算信号延迟是至关重要的一步。Elmore 延迟模型为分析大规模 $RC$（电阻-电容）树网络的时序特性提供了坚实的基础。通过从第一性原理出发推导特定节点的延迟，您可以深入理解路径上游的电阻和电容如何共同影响最终的信号到达时间，这是理解和优化时钟树性能的核心技能 。",
            "id": "4274828",
            "problem": "在一个大规模集成电路上，使用一种基于H树和局部网格连接的平衡分层时钟分配网络来驱动同步终端。考虑H树的一个分支，该分支为一个位于节点 $S$ 的终端供电，而一个位于节点 $B$ 的兄弟分支则从上游的一个分支节点分出。驱动器被建模为其戴维南电阻 $R_{s}$，驱动一个阻容 ($RC$) 树。所有的互连电容、缓冲器输入电容和终端负载都在相应节点上建模为到地的电容器。拓扑结构和参数如下，所有元件值均为严格正值：\n- 源（驱动器）节点通过串联电阻 $R_{s}$ 连接到节点 $0$。\n- 从节点 $0$ 开始，一段电阻为 $R_{1}$ 的串联导线段连接到分支节点 $1$。节点 $1$ 处到地的并联电容（代表导线段 $R_{1}$ 的分布电容以及节点 $1$ 处的任何局部缓冲器输入）为 $C_{1}$。\n- 从节点 $1$ 开始，通往目标终端 $S$ 的主路径经过一段电阻为 $R_{2}$ 的串联导线段到达节点 $2$。节点 $2$ 处到地的并联电容为 $C_{2}$，另外一个在节点 $2$ 处的并联电容 $C_{m}$ 用于建模局部网格连接。\n- 从节点 $2$ 开始，一段最后的电阻为 $R_{3}$ 的串联导线段连接到终端节点 $3 \\equiv S$。节点 $3$ 处到地的并联电容为 $C_{3}$，$S$ 处的终端负载为 $C_{L}$。\n- 从节点 $1$ 开始，一个通往终端 $B$ 的兄弟分支包含一个到节点 $b$ 的串联电阻 $R_{b}$，节点 $b$ 有一个并联电容 $C_{b}$（代表兄弟分支上的导线和终端负载）。\n假设网络是线性时不变的，并且驱动器施加一个上升时间足够快的阶跃输入，以至于阻容 ($RC$) 动态特性主导了插入延迟。将终端 $S$ 的插入延迟 $t_{\\mathrm{ins}}(S)$ 定义为该终端冲激响应的一阶矩，即$RC$树的标准Elmore延迟。\n仅使用线性$RC$网络的基本性质和一阶矩的定义（不使用任何预先给出的简化公式），推导一个以 $R_{s}$、$R_{1}$、$R_{2}$、$R_{3}$、$R_{b}$、$C_{1}$、$C_{2}$、$C_{3}$、$C_{m}$、$C_{L}$ 和 $C_{b}$ 表示的 $t_{\\mathrm{ins}}(S)$ 的闭式解析表达式。你的最终答案必须是单个符号表达式。以秒为单位表示答案。无需进行数值计算或四舍五入。",
            "solution": "该问题要求推导一个指定的阻容 ($RC$) 树在终端 $S$ 处的插入延迟（定义为Elmore延迟）的闭式解析表达式。推导过程必须基于基本原理和一阶矩定义，而非预先给出的公式。\n\n首先，我们建立理论基础。节点 $i$ 的插入延迟 $t_{\\mathrm{ins}}(i)$ 定义为该节点冲激响应 $h_i(t)$ 的一阶矩。用数学公式表示为：\n$$t_{\\mathrm{ins}}(i) = \\int_{0}^{\\infty} t h_i(t) dt$$\n拉普拉斯变换的一个基本性质将函数的矩与其变换的导数联系起来。冲激响应的拉普拉斯变换是传递函数，$H_i(s) = \\mathcal{L}\\{h_i(t)\\} = \\int_{0}^{\\infty} h_i(t) e^{-st} dt$。对 $H_i(s)$ 关于 $s$ 求导，得到：\n$$\\frac{dH_i(s)}{ds} = \\int_{0}^{\\infty} (-t) h_i(t) e^{-st} dt$$\n在 $s=0$ 处求值：\n$$\\frac{dH_i(s)}{ds} \\bigg|_{s=0} = \\int_{0}^{\\infty} -t h_i(t) dt = -t_{\\mathrm{ins}}(i)$$\n因此，插入延迟可以计算为：\n$$t_{\\mathrm{ins}}(i) = -\\frac{dH_i(s)}{ds} \\bigg|_{s=0}$$\n\n接下来，我们推导RC树中一个节点的 $H_i(s)$ 的通用表达式。该网络是线性时不变的。设输入电压为 $v_{\\mathrm{in}}(t)$，其拉普拉斯变换为 $V_{\\mathrm{in}}(s)$。任意节点 $i$ 的电压 $V_i(s)$ 等于输入电压减去从输入到节点 $i$ 的唯一路径上各电阻的电压降之和。\n$$V_i(s) = V_{\\mathrm{in}}(s) - \\sum_{j \\in \\text{path(in, i)}} R_j I_j(s)$$\n这里，$R_j$ 是到节点 $i$ 的路径上的一个电阻，$I_j(s)$ 是流过它的电流。在RC树中，流过电阻 $R_j$ 的电流必须为其下游子树中的所有电容器充电。流入单个电容器 $C_k$ 的电流是 $sC_k V_k(s)$。因此，总电流 $I_j(s)$ 是：\n$$I_j(s) = s \\sum_{k \\in \\text{subtree}(R_j)} C_k V_k(s)$$\n将此代入电压方程：\n$$V_i(s) = V_{\\mathrm{in}}(s) - \\sum_{j \\in \\text{path(in, i)}} R_j \\left( s \\sum_{k \\in \\text{subtree}(R_j)} C_k V_k(s) \\right)$$\n传递函数 $H_i(s) = V_i(s) / V_{\\mathrm{in}}(s)$ 为：\n$$H_i(s) = 1 - s \\sum_{j \\in \\text{path(in, i)}} R_j \\left( \\sum_{k \\in \\text{subtree}(R_j)} C_k H_k(s) \\right)$$\n现在，我们使用乘法法则对 $H_i(s)$ 关于 $s$ 求导：\n$$\\frac{dH_i(s)}{ds} = -\\left[ \\sum_{j \\in \\text{path(in, i)}} R_j \\left( \\sum_{k \\in \\text{subtree}(R_j)} C_k H_k(s) \\right) + s \\frac{d}{ds}(\\dots) \\right]$$\n在 $s=0$ 处求值，乘以 $s$ 的项会消失。对于任何RC树，到任意节点的直流增益均为1，所以对于所有 $k$ 都有 $H_k(0) = 1$。\n$$\\frac{dH_i(s)}{ds} \\bigg|_{s=0} = - \\sum_{j \\in \\text{path(in, i)}} R_j \\left( \\sum_{k \\in \\text{subtree}(R_j)} C_k H_k(0) \\right) = - \\sum_{j \\in \\text{path(in, i)}} R_j \\left( \\sum_{k \\in \\text{subtree}(R_j)} C_k \\right)$$\n项 $\\sum_{k \\in \\text{subtree}(R_j)} C_k$ 是电阻 $R_j$ 下游的总电容，我们将其记为 $C_{\\text{downstream}, j}$。\n$$t_{\\mathrm{ins}}(i) = - \\left(-\\sum_{j \\in \\text{path(in, i)}} R_j C_{\\text{downstream}, j}\\right) = \\sum_{j \\in \\text{path(in, i)}} R_j C_{\\text{downstream}, j}$$\n这个推导出的公式也可以通过遍历网络中每个电容器 $C_k$ 来表示。节点 $i$ 的延迟是每个电容 $C_k$ 与从源端到节点 $i$ 和节点 $k$ 的共享路径上的总电阻的乘积之和。将这个共享路径电阻记为 $R_{ik}$，公式为：\n$$t_{\\mathrm{ins}}(i) = \\sum_{\\text{all } k} R_{ik} C_k$$\n我们将使用此公式来计算终端 $S$（节点 $3$）的延迟。\n\n具有电容的节点是 $1$、$2$、$3$（或 $S$）和 $b$。每个节点的总电容为：\n- 节点 $1$：$C_{node1} = C_1$\n- 节点 $2$：$C_{node2} = C_2 + C_m$\n- 节点 $S$：$C_{nodeS} = C_3 + C_L$\n- 节点 $b$：$C_{nodeb} = C_b$\n\n求和是针对这四个电容节点。目标节点是 $i=S$。\n$$t_{\\mathrm{ins}}(S) = R_{S,1}C_{node1} + R_{S,2}C_{node2} + R_{S,S}C_{nodeS} + R_{S,b}C_{nodeb}$$\n\n1.  **来自 $C_{node1} = C_1$ 的贡献**：\n    - 从源到 $S$ 的路径经过电阻 $R_s, R_1, R_2, R_3$。\n    - 从源到节点 $1$ 的路径经过 $R_s, R_1$。\n    - 共享路径电阻 $R_{S,1}$ 是从源到节点 $1$ 的电阻：$R_s + R_1$。\n    - 贡献：$(R_s + R_1)C_1$。\n\n2.  **来自 $C_{node2} = C_2 + C_m$ 的贡献**：\n    - 从源到 $S$ 的路径经过 $R_s, R_1, R_2, R_3$。\n    - 从源到节点 $2$ 的路径经过 $R_s, R_1, R_2$。\n    - 共享路径电阻 $R_{S,2}$ 是从源到节点 $2$ 的电阻：$R_s + R_1 + R_2$。\n    - 贡献：$(R_s + R_1 + R_2)(C_2 + C_m)$。\n\n3.  **来自 $C_{nodeS} = C_3 + C_L$ 的贡献**：\n    - 从源到 $S$ 的路径经过 $R_s, R_1, R_2, R_3$。\n    - 从源到节点 $S$ 的路径是相同的。\n    - 共享路径电阻 $R_{S,S}$ 是到 $S$ 的完整路径电阻：$R_s + R_1 + R_2 + R_3$。\n    - 贡献：$(R_s + R_1 + R_2 + R_3)(C_3 + C_L)$。\n\n4.  **来自 $C_{nodeb} = C_b$ 的贡献**：\n    - 从源到 $S$ 的路径经过 $R_s, R_1, R_2, R_3$。\n    - 从源到节点 $b$ 的路径经过 $R_s, R_1, R_b$。\n    - 分支点是节点 $1$。共享路径电阻 $R_{S,b}$ 是从源到节点 $1$ 的电阻：$R_s + R_1$。\n    - 贡献：$(R_s + R_1)C_b$。\n\n将这四个贡献相加，得到终端 $S$ 的总插入延迟：\n$$t_{\\mathrm{ins}}(S) = (R_s + R_1)C_1 + (R_s + R_1 + R_2)(C_2 + C_m) + (R_s + R_1 + R_2 + R_3)(C_3 + C_L) + (R_s + R_1)C_b$$\n这个表达式可以通过对具有共同路径电阻的项进行分组来重新整理：\n$$t_{\\mathrm{ins}}(S) = (R_s + R_1)(C_1 + C_b) + (R_s + R_1 + R_2)(C_2 + C_m) + (R_s + R_1 + R_2 + R_3)(C_3 + C_L)$$\n这个最终表达式就是终端 $S$ 处插入延迟的闭式解析解。单位是欧姆乘以法拉，正确地得出秒。",
            "answer": "$$\n\\boxed{(R_{s} + R_{1})(C_{1} + C_{b}) + (R_{s} + R_{1} + R_{2})(C_{2} + C_{m}) + (R_{s} + R_{1} + R_{2} + R_{3})(C_{3} + C_{L})}\n$$"
        },
        {
            "introduction": "掌握了延迟分析的基础后，下一步是主动设计一个能确保所有时钟接收端信号同步到达的网络。本练习将引导您从分析转向综合，通过实现经典的“延迟合并嵌入”（Deferred-Merge Embedding, DME）算法来构建一棵零时钟偏移树（Zero Skew Tree）。通过这个编程实践，您将把抽象的算法理论转化为具体的布线策略，体验现代电子设计自动化（EDA）工具在时钟树综合中的核心逻辑 。",
            "id": "4274820",
            "problem": "您的任务是使用延迟合并嵌入 (DME) 方法，在曼哈顿 (直线) 路由下，为一组指定的时钟接收端坐标构建一个零时钟偏移树 (ZST)，并根据 Elmore 延迟模型计算实现零时钟偏移所需的分支长度。该设置适用于时钟分配网络的阻容互连模型，重点是综合树形结构，该结构可以根据接收端的空间分布模拟分层 H 树、线性主干或局部化网格片段的特征。从直线几何和阻容树中 Elmore 延迟的基础定义开始，并推导出在所有接收端强制实现相等到达时间的算法。\n\n定义与要求：\n- 使用曼哈顿 (直线) 路由模型：两点 $(x_1,y_1)$ 和 $(x_2,y_2)$ 之间的距离为 $|x_2-x_1|+|y_2-y_1|$。\n- 导线具有单位长度均匀电阻 $r$ (单位 $\\mathrm{\\Omega/\\mu m}$) 和单位长度均匀电容 $c$ (单位 $\\mathrm{F/\\mu m}$)。每个接收端 $i$ 在其位置 $(x_i,y_i)$ 处具有一个集总电容 $C_i$ (单位 $\\mathrm{F}$)。\n- 您必须使用 DME 构建方法，在每次二元合并时，在两个子锚点的直线中值区域内为新父节点选择一个锚点位置，以最小化基准总曼哈顿长度。然后，如有必要，通过添加蜿蜒走线 (meanders) 来调整分支长度，以精确地使两个子子树的 Elmore 到达时间相等，同时保持曼哈顿路由。当两个子子树的基准 Elmore 延迟不相等时，仅在基准延迟较小的一侧增加蜿蜒走线，选择增加的长度以实现相等。每次合并后，更新等效下游电容和从新父节点到其子树中接收端的公共内部延迟，并向上沿树传播。\n- 通过以贪心方式重复合并节点对来构建最终的 ZST：在每一轮中，按键值 $x+y$ 对当前节点进行排序，并连续配对；如果剩下奇数个节点，则将其不合并地带到下一轮。\n- 您的输出必须是为每个测试用例构建的 ZST 中每条边的分支长度列表。所有分支长度以微米 ($\\mathrm{\\mu m}$) 为单位，表示为四舍五入到三位小数的浮点数。\n\n从以下基本基础开始：\n- 直线几何 (曼哈顿度量)。\n- 由单位长度均匀电阻 $r$ 和单位长度均匀电容 $c$ 建模的阻容互连。\n- 阻容树的 Elmore 延迟定义。\n\n测试套件：\n1. 案例 A (网格，类 H 树)：\n   - $r = 0.05$ $\\mathrm{\\Omega/\\mu m}$， $c = 0.2 \\times 10^{-15}$ $\\mathrm{F/\\mu m}$。\n   - 接收端：$\\{((0,0), 20 \\times 10^{-15}), ((0,200), 20 \\times 10^{-15}), ((200,0), 20 \\times 10^{-15}), ((200,200), 20 \\times 10^{-15})\\}$。\n2. 案例 B (共线，类主干，非平衡负载)：\n   - $r = 0.08$ $\\mathrm{\\Omega/\\mu m}$， $c = 0.3 \\times 10^{-15}$ $\\mathrm{F/\\mu m}$。\n   - 接收端：$\\{((0,0), 15 \\times 10^{-15}), ((150,0), 25 \\times 10^{-15}), ((300,0), 10 \\times 10^{-15})\\}$。\n3. 案例 C (重合接收端，退化情况)：\n   - $r = 0.10$ $\\mathrm{\\Omega/\\mu m}$， $c = 0.1 \\times 10^{-15}$ $\\mathrm{F/\\mu m}$。\n   - 接收端：$\\{((100,100), 20 \\times 10^{-15}), ((100,100), 20 \\times 10^{-15})\\}$。\n4. 案例 D (具有五个接收端的垂直类主干)：\n   - $r = 0.06$ $\\mathrm{\\Omega/\\mu m}$， $c = 0.25 \\times 10^{-15}$ $\\mathrm{F/\\mu m}$。\n   - 接收端：$\\{((0,0), 10 \\times 10^{-15}), ((0,100), 12 \\times 10^{-15}), ((0,200), 15 \\times 10^{-15}), ((0,300), 20 \\times 10^{-15}), ((0,400), 18 \\times 10^{-15})\\}$。\n\n答案规格：\n- 对于每个测试用例，结果是一个浮点数列表（四舍五入到三位小数），表示在构建的 ZST 中每条边的分支长度，按合并的时间顺序排序，并在每次合并内部，按两个子分支的顺序列出。单位是微米 ($\\mathrm{\\mu m}$)。\n- 您的程序应生成一行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表，不含空格。例如：$[[\\ell_{1,1},\\ell_{1,2},\\dots],[\\ell_{2,1},\\ell_{2,2},\\dots],[\\ell_{3,1},\\ell_{3,2},\\dots],[\\ell_{4,1},\\ell_{4,2},\\dots]]$，其中 $\\ell_{k,j}$ 是测试用例 $k$ 的分支长度。",
            "solution": "用户要求使用延迟合并嵌入 (DME) 算法为给定的时钟接收端集合构建一个零时钟偏移树 (ZST)。目标是计算生成树中所有分支的长度，确保根据 Elmore 延迟模型，在接收端实现零时钟偏移。该问题设定在一个具有均匀阻容 ($RC$) 导线模型的直线 (曼哈顿) 路由空间中。\n\n### **1. 基本原理**\n\n**a. 直线几何 (曼哈顿度量)**\n两点 $p_1 = (x_1, y_1)$ 和 $p_2 = (x_2, y_2)$ 之间的距离 $d_M$ 由它们坐标的绝对差之和给出：\n$$d_M(p_1, p_2) = |x_2 - x_1| + |y_2 - y_1|$$\n\n**b. RC 树的 Elmore 延迟模型**\nElmore 延迟是 $RC$ 电路延迟的一阶近似。对于一个长度为 $\\ell$，单位长度均匀电阻为 $r$，单位长度均匀电容为 $c$ 的单段导线，驱动下游负载电容 $C_{load}$，该段上的延迟为：\n$$T_{segment} = (r\\ell) \\left( \\frac{c\\ell}{2} + C_{load} \\right) = \\frac{1}{2}rc\\ell^2 + r\\ell C_{load}$$\n其中 $\\frac{1}{2}rc\\ell^2$ 项考虑了导线自身的分布 RC 特性。\n\n在树形结构中，从根（源）到特定接收端 $i$ 的总 Elmore 延迟是从根到该接收端的唯一路径上所有延迟的总和。该路径中边 $e_k$ 贡献的延迟是其电阻 $R_k = r\\ell_k$ 乘以它驱动的总下游电容 $C_{downstream}(k)$。$C_{downstream}(k)$ 包括连接到该边的子树中所有导线和接收端的电容。\n$$T_{D,i} = \\sum_{e_k \\in \\text{path}(\\text{root} \\to i)} R_k C_{downstream}(k)$$\n\n### **2. 用于零时钟偏移的延迟合并嵌入 (DME) 算法**\n\nDME 算法从接收端开始，自下而上地构建 ZST。在每一步中，它将两个子树合并成一个更大的子树，确保从新根到合并后子树内的所有接收端的延迟相等。\n\n**a. 节点表示**\n在构建过程中的每个节点 $v_i$，无论是接收端还是内部合并点，都具有以下特征：\n1.  一个锚点位置 $(x_i, y_i)$。\n2.  以其为根的子树的总电容 $C_{subtree, i}$。\n3.  从节点锚点到其子树中任何接收端的内部延迟 $T_{internal, i}$。对于 ZST，此延迟对子树中的所有接收端都是恒定的。\n\n最初，对于位于 $(x_i, y_i)$ 且电容为 $C_i$ 的每个接收端 $s_i$，对应的节点具有 $C_{subtree, i} = C_i$ 和 $T_{internal, i} = 0$。\n\n**b. 配对策略**\n问题指定了一种贪心配对启发式算法。在每一轮合并中：\n1.  当前节点集根据键值 $(x+y)$ 进行排序，其中 $(x,y)$ 是锚点位置。为确保过程的确定性，平局则使用 x 坐标，然后是 y 坐标来打破。\n2.  排序后的节点被连续配对：$(v_1, v_2), (v_3, v_4), \\dots$。如果节点数量为奇数，最后一个节点将被带到下一轮。\n\n**c. 合并两个子树**\n考虑合并两个节点 $v_1$ 和 $v_2$ 以形成一个新的父节点 $v_p$。连接 $v_p$ 到 $v_1$ 和 $v_2$ 的分支长度分别为 $\\ell_1$ 和 $\\ell_2$。\n\n**i. 父节点锚点位置与基准长度**\n父锚点 $a_p$ 被放置在子锚点 $a_1=(x_1, y_1)$ 和 $a_2=(x_2, y_2)$ 的直线中值区域内，即边界框 $[min(x_1, x_2), max(x_1, x_2)] \\times [min(y_1, y_2), max(y_1, y_2)]$。此区域内的任何点都能最小化基准总导线长度 $\\ell_{1,0} + \\ell_{2,0} = d_M(a_1, a_2)$。为了确保算法的确定性，我们选择一个规范的锚点。假设 $v_1$ 是排序后配对中出现的第一个节点。我们选择父锚点 $a_p = (x_1, y_2)$。这会创建一条 L 形路径。基准 (曼哈顿) 分支长度为：\n$$\\ell_{1,0} = d_M(a_p, a_1) = |x_1-x_1| + |y_2-y_1| = |y_2-y_1|$$\n$$\\ell_{2,0} = d_M(a_p, a_2) = |x_1-x_2| + |y_2-y_2| = |x_1-x_2|$$\n\n**ii. 延迟平衡**\n从新父节点 $v_p$ 到子节点 $v_i$（对于 $i=1, 2$）子树中任何接收端的延迟为：\n$$T_{p \\to \\text{sinks}(i)} = \\left(\\frac{1}{2}rc\\ell_i^2 + r\\ell_i C_{subtree, i}\\right) + T_{internal, i}$$\n我们首先使用基准长度 $\\ell_{1,0}$ 和 $\\ell_{2,0}$ 计算基准延迟：\n$$T_{base, i} = \\left(\\frac{1}{2}rc\\ell_{i,0}^2 + r\\ell_{i,0} C_{subtree, i}\\right) + T_{internal, i}$$\n为了实现零时钟偏移，最终延迟必须相等：$T_{p \\to \\text{sinks}(1)} = T_{p \\to \\text{sinks}(2)}$。我们只向基准延迟较小的分支增加蜿蜒走线（导线长度）。\n假设 $T_{base, 1}  T_{base, 2}$。我们将分支 2 的最终长度设置为其基准长度 $\\ell_2 = \\ell_{2,0}$，目标延迟变为 $T_{target} = T_{base, 2}$。我们必须为分支 1 找到一个新的长度 $\\ell_1 \\ge \\ell_{1,0}$，使其满足：\n$$\\frac{1}{2}rc\\ell_1^2 + r\\ell_1 C_{subtree, 1} + T_{internal, 1} = T_{target}$$\n这是一个形如 $A\\ell_1^2 + B\\ell_1 + C = 0$ 的二次方程，其中 $A=\\frac{1}{2}rc$，$B=rC_{subtree, 1}$，且 $C=T_{internal, 1} - T_{target}$。$\\ell_1$ 的物理可行解由正根给出：\n$$\\ell_1 = \\frac{-B + \\sqrt{B^2 - 4AC}}{2A}$$\n如果 $T_{base, 2}  T_{base, 1}$，则对 $\\ell_2$ 进行对称计算。如果 $T_{base, 1} = T_{base, 2}$，则不需要蜿蜒走线，因此 $\\ell_1 = \\ell_{1,0}$ 且 $\\ell_2 = \\ell_{2,0}$。\n\n**d. 传播**\n合并后，为下一轮创建新的父节点 $v_p$，其属性如下：\n-   锚点位置：$a_p=(x_1, y_2)$。\n-   内部延迟：$T_{internal, p} = T_{target} = \\max(T_{base, 1}, T_{base, 2})$。\n-   子树电容：这是子子树电容与新导线电容的总和。\n    $$C_{subtree, p} = (c\\ell_1 + C_{subtree, 1}) + (c\\ell_2 + C_{subtree, 2})$$\n\n该算法持续进行，直到只剩下一个节点，即 ZST 的根节点。所需的输出是每次合并中所有计算出的分支长度 $(\\ell_1, \\ell_2)$ 的按时间顺序排列的列表。\n\n以下是实现该算法并为给定测试用例生成结果的 Python 代码：\n```python\nimport numpy as np\n\nclass Node:\n    \"\"\"Represents a node in the clock tree during construction.\"\"\"\n    def __init__(self, x, y, c_sub, t_int):\n        self.x = x\n        self.y = y\n        self.c_sub = c_sub  # Total downstream capacitance from this node's anchor\n        self.t_int = t_int  # Internal delay from this node's anchor to its sinks\n\n    def __repr__(self):\n        return f\"Node(loc=({self.x},{self.y}), C_sub={self.c_sub:.3e}, T_int={self.t_int:.3e})\"\n\ndef solve_dme(r, c, sinks):\n    \"\"\"\n    Constructs a Zero Skew Tree using DME and returns the branch lengths.\n    \"\"\"\n    nodes = [Node(loc[0], loc[1], cap, 0.0) for loc, cap in sinks]\n    all_lengths = []\n    \n    while len(nodes) > 1:\n        nodes.sort(key=lambda n: (n.x + n.y, n.x, n.y))\n        next_round_nodes = []\n        \n        for i in range(len(nodes) // 2):\n            v1 = nodes[2 * i]\n            v2 = nodes[2 * i + 1]\n            \n            p_loc_x, p_loc_y = v1.x, v2.y\n            \n            l1_0 = abs(p_loc_x - v1.x) + abs(p_loc_y - v1.y)\n            l2_0 = abs(p_loc_x - v2.x) + abs(p_loc_y - v2.y)\n            \n            t_base1 = (0.5 * r * c * l1_0**2 + r * l1_0 * v1.c_sub) + v1.t_int\n            t_base2 = (0.5 * r * c * l2_0**2 + r * l2_0 * v2.c_sub) + v2.t_int\n            \n            l1, l2 = 0.0, 0.0\n            \n            if t_base1  t_base2:\n                l2 = l2_0\n                target_delay = t_base2\n                \n                A = 0.5 * r * c\n                B = r * v1.c_sub\n                C_quad = v1.t_int - target_delay\n                \n                discriminant = B**2 - 4 * A * C_quad\n                if discriminant  0: discriminant = 0.0\n                l1 = (-B + np.sqrt(discriminant)) / (2 * A)\n\n            elif t_base2  t_base1:\n                l1 = l1_0\n                target_delay = t_base1\n\n                A = 0.5 * r * c\n                B = r * v2.c_sub\n                C_quad = v2.t_int - target_delay\n                \n                discriminant = B**2 - 4 * A * C_quad\n                if discriminant  0: discriminant = 0.0\n                l2 = (-B + np.sqrt(discriminant)) / (2 * A)\n\n            else:\n                l1 = l1_0\n                l2 = l2_0\n                target_delay = t_base1\n\n            all_lengths.extend([l1, l2])\n            \n            t_internal_p = target_delay\n            c_subtree_p = (c * l1 + v1.c_sub) + (c * l2 + v2.c_sub)\n            v_p = Node(p_loc_x, p_loc_y, c_subtree_p, t_internal_p)\n            \n            next_round_nodes.append(v_p)\n\n        if len(nodes) % 2 != 0:\n            next_round_nodes.append(nodes[-1])\n            \n        nodes = next_round_nodes\n        \n    return all_lengths\n```",
            "answer": "[[200.000,200.000,200.000,200.000,0.000,200.000],[173.580,150.000,150.000,323.238],[0.000,0.000],[100.000,103.882,100.000,108.625,200.000,200.000,100.000,307.728]]"
        },
        {
            "introduction": "一个在名义上完美的零时钟偏移树，在实际芯片中仍可能表现出显著的时钟偏移。本练习探讨了导致这种差异的一个关键现实因素：电源完整性。通过分析为时钟缓冲器供电的电源轨上的 $IR$ 压降（电压降），您将量化电源噪声如何转化为时钟延迟的变化，从而产生非预期的时钟偏移。这个实践将时钟网络设计与电源分配网络（PDN）分析联系起来，揭示了在高性能集成电路设计中进行协同优化的重要性 。",
            "id": "4274800",
            "problem": "一款高性能片上系统采用混合时钟分配方案，该方案由一个 $H$ 树构成，它将时钟扇出到一组相同的网格驱动器，这些驱动器再为局部时钟网格供能。这些网格驱动器由一条水平电源脊柱供电，该脊柱沿 $x$ 轴从 $x=0$ 处的稳压焊盘延伸到 $x=L$ 处的网格区域末端。该电源脊柱被建模为一维阻容 ($RC$) 传输线网格，其单位长度均匀电阻为 $r$，单位长度均匀去耦电容为 $c$。对于本问题，假设以下情景和参数：\n- 脊柱长度为 $L=8\\,\\text{mm}$，位于 $x=0$ 处的电源焊盘电压保持在 $V_{\\text{DD}}=0.8\\,\\text{V}$。\n- 共有 $N=16$ 个相同的网格驱动器，它们沿着脊柱均匀分布，位置为 $x_{k}=(k-\\tfrac{1}{2})\\Delta$，其中 $\\Delta=L/N$，且 $k\\in\\{1,2,\\dots,N\\}$。\n- 在持续时间为 $T_{\\text{edge}}=50\\,\\text{ps}$ 的时钟边沿期间，每个驱动器吸收 $I_{d}=5\\,\\text{mA}$ 的恒定电流，并且所有驱动器同时开关。脊柱的单位长度电阻为 $r=0.2\\,\\Omega/\\text{mm}$，单位长度去耦电容为 $c=0.1\\,\\text{nF}/\\text{mm}$。\n- 到达所有驱动器输入端的时钟路径（即通过 $H$ 树的路径）具有相同的插入延迟；因此，任何时钟偏斜都完全是由电源引起的驱动器延迟差异所导致的。\n- 在标称工作点附近，驱动器延迟对电源电压表现出小信号线性灵敏度，使得延迟变化为 $\\Delta t_{d}\\approx s\\,\\Delta V$，其中 $s=0.02\\,\\text{ps}/\\text{mV}$ 是在 $V_{\\text{DD}}=0.8\\,\\text{V}$ 附近测得的。\n\n使用基于欧姆定律、电流连续性以及 $RC$ 网络在时钟边沿时间内的准静态有效性的第一性原理模型，推导当驱动器吸收指定电流时，沿脊柱的电压降作为位置 $x$ 的函数。然后，确定纯粹由电源 $IR$ 压降导致的最早和最晚到达的网格驱动器之间的最差情况时钟偏斜。将您的最终数值答案四舍五入到四位有效数字。以皮秒 (ps) 为单位表示最终偏斜。\n\n在首次出现时定义任何缩写词。例如，电子设计自动化 (Electronic Design Automation, EDA)。所有数学推理必须基于基本定律和经过检验的公式，而非临时性的捷径。确保所有给定数据的使用一致且符合实际。最终答案必须是一个实数。",
            "solution": "问题要求计算一个高性能片上系统 (system-on-chip, SoC) 的混合时钟分配网络中，网格驱动器之间的最差情况时钟偏斜。该偏斜源于沿电源脊柱的电压变化，这些变化导致了驱动器传播延迟的差异。分析将基于电源脊柱的第一性原理准静态模型。“准静态”一词意味着我们在驱动器吸收电流的瞬间分析系统，将其视为一个直流 (direct current, DC) 问题。因此，电压降是电阻性或 $IR$ 压降，其中 $I$ 代表电流，$R$ 代表电阻。电源脊柱被建模为一维阻容 ($RC$) 传输线。虽然给出了单位长度去耦电容 $c$ 和边沿持续时间 $T_{\\text{edge}}$，但使用基于欧姆定律和电流连续性的准静态模型来计算电压降的指令意味着我们关注的是每个驱动器吸收恒定电流 $I_d$ 所产生的电阻效应。\n\n首先，我们建立物理模型。长度为 $L$ 的电源脊柱沿 $x$ 轴从 $x=0$ 延伸到 $x=L$。在 $x=0$ 处施加恒定的电源电压 $V_{\\text{DD}}$。共有 $N=16$ 个相同的网格驱动器，每个驱动器吸收电流 $I_d$，它们位于 $x_k = (k-\\frac{1}{2})\\Delta$ 的位置，其中 $k \\in \\{1, 2, \\dots, N\\}$ 且 $\\Delta = L/N$。该脊柱具有均匀的单位长度电阻 $r$。\n\n在位置 $x$ 处流过脊柱的电流 $I(x)$ 是所有位于大于 $x$ 的位置的驱动器所吸收电流的总和。由于所有驱动器同时开关，我们可以将 $I(x)$ 确定为一个分段常数函数。\n对于第一段中的位置 $x \\in [0, x_1]$，脊柱必须为所有 $N$ 个驱动器供电。因此，电流为 $I(x) = N I_d$。对于驱动器 $x_k$ 和 $x_{k+1}$ 之间的位置 $x$，即 $x \\in (x_k, x_{k+1}]$，前 $k$ 个驱动器已经吸收了电流。脊柱中的电流为剩余的 $N-k$ 个驱动器供电。因此，对于 $k=1, \\dots, N-1$，$I(x) = (N-k)I_d$。对于 $x > x_N$，没有剩余的驱动器需要供电，因此 $I(x) = 0$。\n\n沿脊柱的电压降由欧姆定律决定。在无穷小长度 $dx$ 上的微分电压降为 $dV = -I(x) r dx$。任意位置 $x$ 处的电压 $V(x)$ 可以通过从 $x=0$ 处的电源焊盘开始对该表达式进行积分得到：\n$$V(x) = V(0) - \\int_0^x r I(\\xi) d\\xi = V_{\\text{DD}} - r \\int_0^x I(\\xi) d\\xi$$\n位置 $x$ 处的电压降为 $\\Delta V(x) = V_{\\text{DD}} - V(x) = r \\int_0^x I(\\xi) d\\xi$。\n\n我们关心的是每个驱动器位置 $V(x_k)$ 处的电压，以及因此产生的电压降 $\\Delta V(x_k)$。让我们计算从一个驱动器到下一个驱动器之间的电压降。驱动器 $j-1$ 和驱动器 $j$ 之间的压降由流经该段的电流决定。\n从 $x=0$ 处的焊盘到 $x_1$ 处的第一个驱动器的电压降为：\n$$\\Delta V(x_1) = r \\int_0^{x_1} I(\\xi)d\\xi = r \\int_0^{\\Delta/2} (N I_d) d\\xi = r N I_d \\frac{\\Delta}{2}$$\n对于 $j \\ge 2$，驱动器 $j-1$（位于 $x_{j-1}$）和驱动器 $j$（位于 $x_j$）之间的电压降取决于段 $(x_{j-1}, x_j]$ 中的电流 $I(x) = (N-(j-1))I_d$。该段的长度为 $x_j - x_{j-1} = ((j-\\frac{1}{2})\\Delta) - ((j-1-\\frac{1}{2})\\Delta) = \\Delta$。此段上的增量电压降为 $r (N-j+1)I_d \\Delta$。\n\n第 $k$ 个驱动器处的总电压降 $\\Delta V(x_k)$ 是到该点为止所有压降的总和：\n$$\\Delta V(x_k) = \\Delta V(x_1) + \\sum_{j=2}^{k} (V(x_{j-1}) - V(x_j))$$\n$$\\Delta V(x_k) = r N I_d \\frac{\\Delta}{2} + \\sum_{j=2}^{k} r (N-j+1) I_d \\Delta = r I_d \\Delta \\left( \\frac{N}{2} + \\sum_{j=2}^{k} (N-j+1) \\right)$$\n该求和是一个等差数列。令 $p = j-1$。求和变为 $\\sum_{p=1}^{k-1} (N-p) = (N-1) + (N-2) + \\dots + (N-k+1)$。\n该数列的和为 $\\frac{k-1}{2}( (N-1) + (N-k+1) ) = \\frac{(k-1)(2N-k)}{2}$。\n将此代回：\n$$\\Delta V(x_k) = r I_d \\Delta \\left( \\frac{N}{2} + \\frac{(k-1)(2N-k)}{2} \\right) = \\frac{r I_d \\Delta}{2} (N + 2Nk - k^2 - 2N + k) = \\frac{r I_d \\Delta}{2}(-k^2 + (2N+1)k - N)$$\n电压降 $\\Delta V(x_k)$ 随 $k$ 增大而增大。离焊盘最近的驱动器 ($k=1$) 经历最高电压（最小压降），而离焊盘最远的驱动器 ($k=N$) 经历最低电压（最大压降）。\n最小电压降发生在 $k=1$ 处：\n$$\\Delta V_{\\text{min}} = \\Delta V(x_1) = \\frac{r I_d \\Delta}{2}(-1 + (2N+1) - N) = \\frac{r I_d \\Delta N}{2}$$\n最大电压降发生在 $k=N$ 处：\n$$\\Delta V_{\\text{max}} = \\Delta V(x_N) = \\frac{r I_d \\Delta}{2}(-N^2 + (2N+1)N - N) = \\frac{r I_d \\Delta}{2}(-N^2 + 2N^2 + N - N) = \\frac{r I_d \\Delta N^2}{2}$$\n任意两个驱动器之间的最大电压差为 $\\Delta V_{\\text{worst-case}} = \\Delta V_{\\text{max}} - \\Delta V_{\\text{min}}$。\n$$\\Delta V_{\\text{worst-case}} = \\frac{r I_d \\Delta N^2}{2} - \\frac{r I_d \\Delta N}{2} = \\frac{r I_d \\Delta}{2}(N^2-N) = \\frac{r I_d N(N-1)\\Delta}{2}$$\n代入 $\\Delta = L/N$：\n$$\\Delta V_{\\text{worst-case}} = \\frac{r I_d N(N-1)}{2} \\frac{L}{N} = \\frac{r I_d L (N-1)}{2}$$\n时钟偏斜是最新到达（最低电压，在 $x_N$ 处）和最早到达（最高电压，在 $x_1$ 处）之间的延迟差异。延迟变化由 $\\Delta t_d \\approx s \\Delta V$ 给出。\n$$\\text{Skew} = t_{d,\\text{late}} - t_{d,\\text{early}} = s(\\Delta V_{\\text{max}} - \\Delta V_{\\text{min}}) = s \\cdot \\Delta V_{\\text{worst-case}}$$\n$$\\text{Skew} = s \\frac{r I_d L (N-1)}{2}$$\n现在，我们代入给定的数值：\n$s = 0.02\\,\\text{ps}/\\text{mV}$\n$r = 0.2\\,\\Omega/\\text{mm}$\n$I_d = 5\\,\\text{mA}$\n$L = 8\\,\\text{mm}$\n$N = 16$\n\n首先，计算最差情况下的电压降 $\\Delta V_{\\text{worst-case}}$。保持单位一致至关重要。我们可以使用毫米 (mm)、毫安 (mA) 和欧姆 ($\\Omega$) 进行计算，这将得到以毫伏 (mV) 为单位的电压。\n$$\\Delta V_{\\text{worst-case}} = \\frac{(0.2\\,\\Omega/\\text{mm}) \\cdot (5\\,\\text{mA}) \\cdot (8\\,\\text{mm}) \\cdot (16-1)}{2}$$\n$$\\Delta V_{\\text{worst-case}} = \\frac{0.2 \\cdot 5 \\cdot 8 \\cdot 15}{2}\\,\\text{mV} = \\frac{1 \\cdot 8 \\cdot 15}{2}\\,\\text{mV} = \\frac{120}{2}\\,\\text{mV} = 60\\,\\text{mV}$$\n现在，我们可以使用灵敏度 $s$ 计算偏斜：\n$$\\text{Skew} = (0.02\\,\\text{ps}/\\text{mV}) \\cdot (60\\,\\text{mV}) = 1.2\\,\\text{ps}$$\n题目要求答案四舍五入到四位有效数字。因此，偏斜为 $1.200\\,\\text{ps}$。",
            "answer": "$$\\boxed{1.200}$$"
        }
    ]
}