{
    "hands_on_practices": [
        {
            "introduction": "To effectively design and analyze clock networks, a solid grasp of the underlying delay models is paramount. The Elmore delay offers a powerful and widely used first-order approximation for the propagation delay in resistive-capacitive ($RC$) trees. This foundational exercise challenges you to derive this critical formula from its definition as the first moment of the impulse response, cementing your understanding of how path resistance and downstream capacitance contribute to timing.",
            "id": "4274828",
            "problem": "A balanced hierarchical clock distribution based on an H-tree with a local mesh tie is used to drive synchronous sinks on a large integrated circuit. Consider one branch of the H-tree that feeds a sink at node $S$ while a sibling branch at node $B$ taps off at an upstream branching node. The driver is modeled by its Thevenin resistance $R_{s}$ driving a resistive-capacitive (RC) tree. All interconnect capacitances, buffer input capacitances, and sink loads are modeled as capacitors to ground at the corresponding nodes. The topology and parameters are as follows, with all components strictly positive:\n- Source (driver) node connected through series resistance $R_{s}$ to node $0$.\n- From node $0$, a series wire segment of resistance $R_{1}$ leads to branching node $1$. The shunt capacitance to ground at node $1$ (representing the distributed capacitance of segment $R_{1}$ and any local buffer input at node $1$) is $C_{1}$.\n- From node $1$, the main path toward the target sink $S$ passes through a series wire segment of resistance $R_{2}$ to node $2$. The shunt capacitance to ground at node $2$ is $C_{2}$, and an additional shunt capacitance $C_{m}$ at node $2$ models the local mesh tie-in.\n- From node $2$, a final series wire segment of resistance $R_{3}$ leads to the sink node $3 \\equiv S$. The shunt capacitance to ground at node $3$ is $C_{3}$, and the sink load at $S$ is $C_{L}$.\n- From node $1$, a sibling branch toward sink $B$ consists of a series resistance $R_{b}$ to node $b$, which has shunt capacitance $C_{b}$ (representing wire and sink load on the sibling branch).\nAssume the network is linear and time-invariant and that the driver applies a step input of sufficiently fast rise time so that the resistive-capacitive (RC) dynamics dominate the insertion delay. Define the insertion delay $t_{\\mathrm{ins}}(S)$ at sink $S$ as the first moment of the sinkâ€™s impulse response, i.e., the standard Elmore delay for RC trees.\nUsing only fundamental properties of linear RC networks and the first-moment definition (no pre-stated shortcut formulas), derive a closed-form analytical expression for $t_{\\mathrm{ins}}(S)$ in terms of $R_{s}$, $R_{1}$, $R_{2}$, $R_{3}$, $R_{b}$, $C_{1}$, $C_{2}$, $C_{3}$, $C_{m}$, $C_{L}$, and $C_{b}$. Your final answer must be a single symbolic expression. Express the answer in seconds. No numerical evaluation or rounding is required.",
            "solution": "The problem asks for a closed-form analytical expression for the insertion delay, defined as the Elmore delay, at sink $S$ of a specified resistive-capacitive (RC) tree. The derivation must be based on fundamental principles and the first-moment definition, not on pre-stated formulas.\n\nFirst, we establish the theoretical foundation. The insertion delay $t_{\\mathrm{ins}}(i)$ at a node $i$ is defined as the first moment of the impulse response, $h_i(t)$, at that node. Mathematically, this is:\n$$t_{\\mathrm{ins}}(i) = \\int_{0}^{\\infty} t h_i(t) dt$$\nA fundamental property of the Laplace transform relates the moments of a function to the derivatives of its transform. The Laplace transform of the impulse response is the transfer function, $H_i(s) = \\mathcal{L}\\{h_i(t)\\} = \\int_{0}^{\\infty} h_i(t) e^{-st} dt$. Differentiating $H_i(s)$ with respect to $s$ gives:\n$$\\frac{dH_i(s)}{ds} = \\int_{0}^{\\infty} (-t) h_i(t) e^{-st} dt$$\nEvaluating this at $s=0$:\n$$\\frac{dH_i(s)}{ds} \\bigg|_{s=0} = \\int_{0}^{\\infty} -t h_i(t) dt = -t_{\\mathrm{ins}}(i)$$\nTherefore, the insertion delay can be calculated as:\n$$t_{\\mathrm{ins}}(i) = -\\frac{dH_i(s)}{ds} \\bigg|_{s=0}$$\n\nNext, we derive a general expression for $H_i(s)$ for a node in an RC tree. The network is linear and time-invariant. Let the input voltage be $v_{\\mathrm{in}}(t)$, with Laplace transform $V_{\\mathrm{in}}(s)$. The voltage at any node $i$, $V_i(s)$, is equal to the input voltage minus the sum of voltage drops across the resistors along the unique path from the input to node $i$.\n$$V_i(s) = V_{\\mathrm{in}}(s) - \\sum_{j \\in \\text{path(in, i)}} R_j I_j(s)$$\nHere, $R_j$ is a resistor on the path to node $i$, and $I_j(s)$ is the current flowing through it. In an RC tree, the current flowing through a resistor $R_j$ must charge all the capacitors in the subtree downstream of it. The current into a single capacitor $C_k$ is $sC_k V_k(s)$. Thus, the total current $I_j(s)$ is:\n$$I_j(s) = s \\sum_{k \\in \\text{subtree}(R_j)} C_k V_k(s)$$\nSubstituting this into the voltage equation:\n$$V_i(s) = V_{\\mathrm{in}}(s) - \\sum_{j \\in \\text{path(in, i)}} R_j \\left( s \\sum_{k \\in \\text{subtree}(R_j)} C_k V_k(s) \\right)$$\nThe transfer function $H_i(s) = V_i(s) / V_{\\mathrm{in}}(s)$ is:\n$$H_i(s) = 1 - s \\sum_{j \\in \\text{path(in, i)}} R_j \\left( \\sum_{k \\in \\text{subtree}(R_j)} C_k H_k(s) \\right)$$\nNow, we differentiate $H_i(s)$ with respect to $s$ using the product rule:\n$$\\frac{dH_i(s)}{ds} = -\\left[ \\sum_{j \\in \\text{path(in, i)}} R_j \\left( \\sum_{k \\in \\text{subtree}(R_j)} C_k H_k(s) \\right) + s \\frac{d}{ds}(\\dots) \\right]$$\nEvaluating at $s=0$, the term multiplied by $s$ vanishes. For any RC tree, the DC gain to any node is unity, so $H_k(0) = 1$ for all $k$.\n$$\\frac{dH_i(s)}{ds} \\bigg|_{s=0} = - \\sum_{j \\in \\text{path(in, i)}} R_j \\left( \\sum_{k \\in \\text{subtree}(R_j)} C_k H_k(0) \\right) = - \\sum_{j \\in \\text{path(in, i)}} R_j \\left( \\sum_{k \\in \\text{subtree}(R_j)} C_k \\right)$$\nThe term $\\sum_{k \\in \\text{subtree}(R_j)} C_k$ is the total capacitance downstream of resistor $R_j$, which we denote as $C_{\\text{downstream}, j}$.\n$$t_{\\mathrm{ins}}(i) = - \\left(-\\sum_{j \\in \\text{path(in, i)}} R_j C_{\\text{downstream}, j}\\right) = \\sum_{j \\in \\text{path(in, i)}} R_j C_{\\text{downstream}, j}$$\nThis derived formula can also be expressed by iterating over each capacitor $C_k$ in the network. The delay at node $i$ is the sum of products of each capacitance $C_k$ and the total resistance of the path from the source that is shared by both node $i$ and node $k$. Denoting this shared path resistance as $R_{ik}$, the formula is:\n$$t_{\\mathrm{ins}}(i) = \\sum_{\\text{all } k} R_{ik} C_k$$\nWe will use this formulation to calculate the delay at sink $S$ (node $3$).\n\nThe nodes with capacitance are $1$, $2$, $3$ (or $S$), and $b$. The total capacitance at each node is:\n- Node $1$: $C_{node1} = C_1$\n- Node $2$: $C_{node2} = C_2 + C_m$\n- Node $S$: $C_{nodeS} = C_3 + C_L$\n- Node $b$: $C_{nodeb} = C_b$\n\nThe summation is over these four capacitive nodes. The target node is $i=S$.\n$$t_{\\mathrm{ins}}(S) = R_{S,1}C_{node1} + R_{S,2}C_{node2} + R_{S,S}C_{nodeS} + R_{S,b}C_{nodeb}$$\n\n1.  **Contribution from $C_{node1} = C_1$**:\n    - The path from the source to $S$ is through resistances $R_s, R_1, R_2, R_3$.\n    - The path from the source to node $1$ is through $R_s, R_1$.\n    - The shared path resistance $R_{S,1}$ is the resistance from the source to node $1$: $R_s + R_1$.\n    - Contribution: $(R_s + R_1)C_1$.\n\n2.  **Contribution from $C_{node2} = C_2 + C_m$**:\n    - The path from the source to $S$ is through $R_s, R_1, R_2, R_3$.\n    - The path from the source to node $2$ is through $R_s, R_1, R_2$.\n    - The shared path resistance $R_{S,2}$ is the resistance from the source to node $2$: $R_s + R_1 + R_2$.\n    - Contribution: $(R_s + R_1 + R_2)(C_2 + C_m)$.\n\n3.  **Contribution from $C_{nodeS} = C_3 + C_L$**:\n    - The path from the source to $S$ is through $R_s, R_1, R_2, R_3$.\n    - The path from the source to node $S$ is the same.\n    - The shared path resistance $R_{S,S}$ is the full path resistance to $S$: $R_s + R_1 + R_2 + R_3$.\n    - Contribution: $(R_s + R_1 + R_2 + R_3)(C_3 + C_L)$.\n\n4.  **Contribution from $C_{nodeb} = C_b$**:\n    - The path from the source to $S$ is through $R_s, R_1, R_2, R_3$.\n    - The path from the source to node $b$ is through $R_s, R_1, R_b$.\n    - The branching point is node $1$. The shared path resistance $R_{S,b}$ is the resistance from the source to node $1$: $R_s + R_1$.\n    - Contribution: $(R_s + R_1)C_b$.\n\nSumming these four contributions gives the total insertion delay at sink $S$:\n$$t_{\\mathrm{ins}}(S) = (R_s + R_1)C_1 + (R_s + R_1 + R_2)(C_2 + C_m) + (R_s + R_1 + R_2 + R_3)(C_3 + C_L) + (R_s + R_1)C_b$$\nThis expression can be rearranged by grouping terms with common path resistances:\n$$t_{\\mathrm{ins}}(S) = (R_s + R_1)(C_1 + C_b) + (R_s + R_1 + R_2)(C_2 + C_m) + (R_s + R_1 + R_2 + R_3)(C_3 + C_L)$$\nThis final expression is the closed-form analytical solution for the insertion delay at sink $S$. The units are Ohms $\\times$ Farads, which correctly yields seconds.",
            "answer": "$$\n\\boxed{(R_{s} + R_{1})(C_{1} + C_{b}) + (R_{s} + R_{1} + R_{2})(C_{2} + C_{m}) + (R_{s} + R_{1} + R_{2} + R_{3})(C_{3} + C_{L})}\n$$"
        },
        {
            "introduction": "Once we can accurately model delay, the next challenge is to synthesize a physical network that achieves the design goal of zero skew. This hands-on coding practice guides you through the implementation of the Deferred-Merge Embedding (DME) algorithm, a classic method for constructing a Zero-Skew Tree (ZST). You will learn how to algorithmically balance path delays by calculating and inserting wire \"meanders,\" gaining insight into the core of modern clock tree synthesis (CTS) tools.",
            "id": "4274820",
            "problem": "You are to construct a Zero Skew Tree (ZST) for a specified set of clock sink coordinates using the Deferred-Merge Embedding (DME) method under Manhattan (rectilinear) routing, and compute the branch lengths required to achieve zero skew according to the Elmore delay metric. The setting is a resistive-capacitive interconnect model appropriate for clock distribution networks, emphasizing the synthesis of tree structures that can emulate features of hierarchical H-tree, linear spine, or localized mesh fragments depending on the spatial distribution of sinks. Begin from the foundational definitions of rectilinear geometry and Elmore delay in resistive-capacitive trees, and derive the algorithm that enforces equal arrival times at all sinks.\n\nDefinitions and requirements:\n- Use the Manhattan (rectilinear) routing model: the distance between two points $(x_1,y_1)$ and $(x_2,y_2)$ is $|x_2-x_1|+|y_2-y_1|$.\n- The wire has uniform resistance per unit length $r$ (in $\\mathrm{\\Omega/\\mu m}$) and uniform capacitance per unit length $c$ (in $\\mathrm{F/\\mu m}$). Each sink $i$ has a lumped capacitance $C_i$ (in $\\mathrm{F}$) at its location $(x_i,y_i)$.\n- You must use a DME construction that, at each binary merge, chooses an anchor location for the new parent inside the rectilinear median region of the two child anchors to minimize the baseline total Manhattan length. Then, adjust branch lengths by adding meanders, if necessary, to exactly equalize the Elmore arrival times at the two child subtrees while preserving Manhattan routing. When two child subtrees have unequal baseline Elmore delays, add meander only to the side with the smaller baseline delay, choosing the added length to achieve equality. After each merge, update the equivalent downstream capacitance and the common internal delay from the new parent to the sinks of its subtree, and propagate up the tree.\n- Construct the final ZST by repeatedly merging pairs of nodes in a greedy manner: in each round, sort the current nodes by the key $x+y$ and pair them consecutively; if an odd node remains, carry it to the next round unmerged.\n- Your output must be the list of branch lengths for every edge in the constructed ZST for each test case. Express all branch lengths in micrometers ($\\mathrm{\\mu m}$) as floats rounded to three decimal places.\n\nStart from the following fundamental base:\n- Rectilinear geometry (Manhattan metric).\n- Resistive-capacitive interconnects modeled by uniform line resistance $r$ and uniform line capacitance $c$.\n- Elmore delay definition for resistive-capacitive trees.\n\nTest suite:\n1. Case A (grid, H-tree-like):\n   - $r = 0.05$ $\\mathrm{\\Omega/\\mu m}$, $c = 0.2 \\times 10^{-15}$ $\\mathrm{F/\\mu m}$.\n   - Sinks: $\\{((0,0), 20 \\times 10^{-15}), ((0,200), 20 \\times 10^{-15}), ((200,0), 20 \\times 10^{-15}), ((200,200), 20 \\times 10^{-15})\\}$.\n2. Case B (collinear, spine-like, unbalanced loads):\n   - $r = 0.08$ $\\mathrm{\\Omega/\\mu m}$, $c = 0.3 \\times 10^{-15}$ $\\mathrm{F/\\mu m}$.\n   - Sinks: $\\{((0,0), 15 \\times 10^{-15}), ((150,0), 25 \\times 10^{-15}), ((300,0), 10 \\times 10^{-15})\\}$.\n3. Case C (coincident sinks, degeneracy):\n   - $r = 0.10$ $\\mathrm{\\Omega/\\mu m}$, $c = 0.1 \\times 10^{-15}$ $\\mathrm{F/\\mu m}$.\n   - Sinks: $\\{((100,100), 20 \\times 10^{-15}), ((100,100), 20 \\times 10^{-15})\\}$.\n4. Case D (vertical spine-like with five sinks):\n   - $r = 0.06$ $\\mathrm{\\Omega/\\mu m}$, $c = 0.25 \\times 10^{-15}$ $\\mathrm{F/\\mu m}$.\n   - Sinks: $\\{((0,0), 10 \\times 10^{-15}), ((0,100), 12 \\times 10^{-15}), ((0,200), 15 \\times 10^{-15}), ((0,300), 20 \\times 10^{-15}), ((0,400), 18 \\times 10^{-15})\\}$.\n\nAnswer specification:\n- For each test case, the result is a list of floats (rounded to three decimal places) representing the branch lengths of every edge in the constructed ZST, ordered by the chronological sequence of merges and, within each merge, in the order of the two child branches. The unit is micrometers ($\\mathrm{\\mu m}$).\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, with no spaces. For example: $[[\\ell_{1,1},\\ell_{1,2},\\dots],[\\ell_{2,1},\\ell_{2,2},\\dots],[\\ell_{3,1},\\ell_{3,2},\\dots],[\\ell_{4,1},\\ell_{4,2},\\dots]]$, where $\\ell_{k,j}$ are the branch lengths for test case $k$.",
            "solution": "The user requests the construction of a Zero Skew Tree (ZST) for given sets of clock sinks using the Deferred-Merge Embedding (DME) algorithm. The objective is to compute the lengths of all branches in the resulting tree, ensuring zero skew at the sinks according to the Elmore delay model. The problem is set in a rectilinear (Manhattan) routing space with a uniform resistive-capacitive ($RC$) wire model.\n\n### **1. Foundational Principles**\n\n**a. Rectilinear Geometry (Manhattan Metric)**\nThe distance $d_M$ between two points $p_1 = (x_1, y_1)$ and $p_2 = (x_2, y_2)$ is given by the sum of the absolute differences of their coordinates:\n$$d_M(p_1, p_2) = |x_2 - x_1| + |y_2 - y_1|$$\n\n**b. Elmore Delay Model for an RC Tree**\nThe Elmore delay is a first-order approximation of the delay in an $RC$ circuit. For a single wire segment of length $\\ell$, uniform resistance per unit length $r$, and uniform capacitance per unit length $c$, driving a downstream load capacitance $C_{load}$, the delay across the segment is:\n$$T_{segment} = (r\\ell) \\left( \\frac{c\\ell}{2} + C_{load} \\right) = \\frac{1}{2}rc\\ell^2 + r\\ell C_{load}$$\nThe term $\\frac{1}{2}rc\\ell^2$ accounts for the wire's own distributed $RC$ characteristics.\n\nIn a tree structure, the total Elmore delay from the root (source) to a specific sink $i$ is the sum of delays along the unique path from the root to that sink. The delay contributed by an edge $e_k$ in this path is its resistance $R_k = r\\ell_k$ multiplied by the total downstream capacitance $C_{downstream}(k)$ it drives. $C_{downstream}(k)$ includes all wire and sink capacitances in the subtree connected to that edge.\n$$T_{D,i} = \\sum_{e_k \\in \\text{path}(\\text{root} \\to i)} R_k C_{downstream}(k)$$\n\n### **2. The Deferred-Merge Embedding (DME) Algorithm for Zero Skew**\n\nThe DME algorithm constructs the ZST bottom-up, starting from the sinks. At each step, it merges two subtrees into a larger one, ensuring that the delays from the new root to all sinks within the merged subtree are equal.\n\n**a. Node Representation**\nEach node $v_i$ in the construction process, whether a sink or an internal merge point, is characterized by:\n1.  An anchor location $(x_i, y_i)$.\n2.  The total capacitance of the subtree rooted at it, $C_{subtree, i}$.\n3.  The internal delay from the node's anchor to any sink in its subtree, $T_{internal, i}$. For a ZST, this delay is constant for all sinks in the subtree.\n\nInitially, for each sink $s_i$ at $(x_i, y_i)$ with capacitance $C_i$, the corresponding node has $C_{subtree, i} = C_i$ and $T_{internal, i} = 0$.\n\n**b. Pairing Strategy**\nThe problem specifies a greedy pairing heuristic. In each round of merging:\n1.  The current set of nodes is sorted based on the key $(x+y)$, where $(x,y)$ is the anchor location. To ensure a deterministic process, ties are broken using the $x$-coordinate, and then the $y$-coordinate.\n2.  The sorted nodes are paired consecutively: $(v_1, v_2), (v_3, v_4), \\dots$. If there is an odd number of nodes, the last one is carried over to the next round.\n\n**c. Merging Two Subtrees**\nConsider merging two nodes, $v_1$ and $v_2$, to form a new parent node $v_p$. The branches connecting $v_p$ to $v_1$ and $v_2$ have lengths $\\ell_1$ and $\\ell_2$.\n\n**i. Parent Anchor Location and Baseline Lengths**\nThe parent anchor $a_p$ is placed within the rectilinear median region of the child anchors $a_1=(x_1, y_1)$ and $a_2=(x_2, y_2)$, which is the bounding box $[min(x_1, x_2), max(x_1, x_2)] \\times [min(y_1, y_2), max(y_1, y_2)]$. Any point within this region minimizes the total baseline wire length $\\ell_{1,0} + \\ell_{2,0} = d_M(a_1, a_2)$. To ensure a deterministic algorithm, we select a canonical anchor point. Let $v_1$ be the node appearing first in the sorted pair. We choose the parent anchor $a_p = (x_1, y_2)$. This creates an L-shaped route. The baseline (Manhattan) branch lengths are:\n$$\\ell_{1,0} = d_M(a_p, a_1) = |x_1-x_1| + |y_2-y_1| = |y_2-y_1|$$\n$$\\ell_{2,0} = d_M(a_p, a_2) = |x_1-x_2| + |y_2-y_2| = |x_1-x_2|$$\n\n**ii. Delay Balancing**\nThe delay from the new parent $v_p$ to any sink in the subtree of child $v_i$ (for $i=1, 2$) is:\n$$T_{p \\to \\text{sinks}(i)} = \\left(\\frac{1}{2}rc\\ell_i^2 + r\\ell_i C_{subtree, i}\\right) + T_{internal, i}$$\nWe first calculate the baseline delays using the baseline lengths $\\ell_{1,0}$ and $\\ell_{2,0}$:\n$$T_{base, i} = \\left(\\frac{1}{2}rc\\ell_{i,0}^2 + r\\ell_{i,0} C_{subtree, i}\\right) + T_{internal, i}$$\nTo achieve zero skew, the final delays must be equal: $T_{p \\to \\text{sinks}(1)} = T_{p \\to \\text{sinks}(2)}$. We only add meander (wire length) to the branch with the smaller baseline delay.\nSuppose $T_{base, 1}  T_{base, 2}$. We set the final length of branch 2 to its baseline, $\\ell_2 = \\ell_{2,0}$, and the target delay becomes $T_{target} = T_{base, 2}$. We must find a new length $\\ell_1 \\ge \\ell_{1,0}$ for branch 1 that satisfies:\n$$\\frac{1}{2}rc\\ell_1^2 + r\\ell_1 C_{subtree, 1} + T_{internal, 1} = T_{target}$$\nThis is a quadratic equation of the form $A\\ell_1^2 + B\\ell_1 + C = 0$, where $A=\\frac{1}{2}rc$, $B=rC_{subtree, 1}$, and $C=T_{internal, 1} - T_{target}$. The physical solution for $\\ell_1$ is given by the positive root:\n$$\\ell_1 = \\frac{-B + \\sqrt{B^2 - 4AC}}{2A}$$\nA symmetric calculation is performed for $\\ell_2$ if $T_{base, 2}  T_{base, 1}$. If $T_{base, 1} = T_{base, 2}$, no meanders are needed, so $\\ell_1 = \\ell_{1,0}$ and $\\ell_2 = \\ell_{2,0}$.\n\n**d. Propagation**\nAfter the merge, the new parent node $v_p$ is created with the following properties for the next round:\n-   Anchor location: $a_p=(x_1, y_2)$.\n-   Internal delay: $T_{internal, p} = T_{target} = \\max(T_{base, 1}, T_{base, 2})$.\n-   Subtree capacitance: This is the sum of the child subtree capacitances and the capacitances of the new wires.\n    $$C_{subtree, p} = (c\\ell_1 + C_{subtree, 1}) + (c\\ell_2 + C_{subtree, 2})$$\n\nThe algorithm continues until only one node, the root of the ZST, remains. The required output is the chronologically ordered list of all computed branch lengths $(\\ell_1, \\ell_2)$ from each merge.",
            "answer": "```python\nimport numpy as np\n\nclass Node:\n    \"\"\"Represents a node in the clock tree during construction.\"\"\"\n    def __init__(self, x, y, c_sub, t_int):\n        self.x = x\n        self.y = y\n        self.c_sub = c_sub  # Total downstream capacitance from this node's anchor\n        self.t_int = t_int  # Internal delay from this node's anchor to its sinks\n\n    def __repr__(self):\n        return f\"Node(loc=({self.x},{self.y}), C_sub={self.c_sub:.3e}, T_int={self.t_int:.3e})\"\n\ndef solve_dme(r, c, sinks):\n    \"\"\"\n    Constructs a Zero Skew Tree using DME and returns the branch lengths.\n\n    Args:\n        r (float): Resistance per unit length (Ohm/um).\n        c (float): Capacitance per unit length (F/um).\n        sinks (list): A list of tuples, where each tuple is ((x, y), C) \n                      representing a sink's location and capacitance.\n\n    Returns:\n        list: A list of floats representing the branch lengths in chronological order.\n    \"\"\"\n    # 1. Initialize leaf nodes from sinks.\n    nodes = [Node(loc[0], loc[1], cap, 0.0) for loc, cap in sinks]\n    \n    all_lengths = []\n    \n    while len(nodes) > 1:\n        # 2a. Sort nodes by key (x+y), with (x, y) as tie-breakers.\n        nodes.sort(key=lambda n: (n.x + n.y, n.x, n.y))\n        \n        next_round_nodes = []\n        \n        # 2c. Iterate through sorted nodes, pairing them consecutively.\n        for i in range(len(nodes) // 2):\n            v1 = nodes[2 * i]\n            v2 = nodes[2 * i + 1]\n            \n            # 2d.i. Determine parent anchor location.\n            # Using (x of child1, y of child2) for a deterministic L-shaped route.\n            p_loc_x, p_loc_y = v1.x, v2.y\n            \n            # 2d.ii. Calculate baseline Manhattan lengths.\n            l1_0 = abs(p_loc_x - v1.x) + abs(p_loc_y - v1.y)\n            l2_0 = abs(p_loc_x - v2.x) + abs(p_loc_y - v2.y)\n            \n            # 2d.iii. Calculate baseline Elmore delays for each branch.\n            t_base1 = (0.5 * r * c * l1_0**2 + r * l1_0 * v1.c_sub) + v1.t_int\n            t_base2 = (0.5 * r * c * l2_0**2 + r * l2_0 * v2.c_sub) + v2.t_int\n            \n            l1, l2 = 0.0, 0.0\n            \n            # 2d.iv-vi. Balance delays by adding meander to the faster branch.\n            if t_base1  t_base2:\n                l2 = l2_0\n                target_delay = t_base2\n                \n                # Solve quadratic for l1: A*l1^2 + B*l1 + C = 0\n                A = 0.5 * r * c\n                B = r * v1.c_sub\n                C = v1.t_int - target_delay\n                \n                discriminant = B**2 - 4 * A * C\n                if discriminant  0: discriminant = 0.0 # Physicality check\n                l1 = (-B + np.sqrt(discriminant)) / (2 * A)\n\n            elif t_base2  t_base1:\n                l1 = l1_0\n                target_delay = t_base1\n\n                # Solve quadratic for l2: A*l2^2 + B*l2 + C = 0\n                A = 0.5 * r * c\n                B = r * v2.c_sub\n                C = v2.t_int - target_delay\n                \n                discriminant = B**2 - 4 * A * C\n                if discriminant  0: discriminant = 0.0\n                l2 = (-B + np.sqrt(discriminant)) / (2 * A)\n\n            else:  # t_base1 == t_base2\n                l1 = l1_0\n                l2 = l2_0\n                target_delay = t_base1\n\n            # 2d.vii. Record the final computed lengths.\n            all_lengths.extend([l1, l2])\n            \n            # 2d.viii. Create the new parent node for the next round.\n            t_internal_p = target_delay\n            c_subtree_p = (c * l1 + v1.c_sub) + (c * l2 + v2.c_sub)\n            v_p = Node(p_loc_x, p_loc_y, c_subtree_p, t_internal_p)\n            \n            # 2d.ix. Add parent node to the list for the next merge round.\n            next_round_nodes.append(v_p)\n\n        # 2e. If there was an odd number of nodes, carry the last one over.\n        if len(nodes) % 2 != 0:\n            next_round_nodes.append(nodes[-1])\n            \n        nodes = next_round_nodes\n        \n    return all_lengths\n\ndef format_list_of_lists(data):\n    \"\"\"Formats a list of lists of floats into the required string format.\"\"\"\n    sublist_strings = []\n    for sublist in data:\n        # Format each float to 3 decimal places\n        formatted_numbers = [f\"{x:.3f}\" for x in sublist]\n        sublist_strings.append(f\"[{','.join(formatted_numbers)}]\")\n    return f\"[{','.join(sublist_strings)}]\"\n    \ndef solve():\n    test_cases = [\n        # Case A (grid, H-tree-like)\n        (0.05, 0.2e-15, [((0, 0), 20e-15), ((0, 200), 20e-15), ((200, 0), 20e-15), ((200, 200), 20e-15)]),\n        # Case B (collinear, spine-like, unbalanced loads)\n        (0.08, 0.3e-15, [((0, 0), 15e-15), ((150, 0), 25e-15), ((300, 0), 10e-15)]),\n        # Case C (coincident sinks, degeneracy)\n        (0.10, 0.1e-15, [((100, 100), 20e-15), ((100, 100), 20e-15)]),\n        # Case D (vertical spine-like with five sinks)\n        (0.06, 0.25e-15, [((0, 0), 10e-15), ((0, 100), 12e-15), ((0, 200), 15e-15), ((0, 300), 20e-15), ((0, 400), 18e-15)]),\n    ]\n\n    results = []\n    for r, c, sinks in test_cases:\n        lengths = solve_dme(r, c, sinks)\n        results.append(lengths)\n\n    # Print the final result in the exact required format.\n    print(format_list_of_lists(results))\n\nsolve()\n```"
        },
        {
            "introduction": "A nominally perfect clock tree will still exhibit skew in silicon due to inevitable manufacturing variations. This final practice transitions from deterministic synthesis to statistical analysis, tasking you with building a Monte Carlo simulator to predict the distribution of clock skew. By modeling random variations in wire geometry, you will explore the practical impact of both global and local process effects on circuit performance, a critical skill for robust high-yield design.",
            "id": "4274750",
            "problem": "You are tasked with building a program to estimate the skew distribution between two sibling branches in a hierarchical H-tree clock distribution network under manufacturing variations, using a Monte Carlo method. The subject context is integrated circuits and Electronic Design Automation (EDA). The objective is to generate a statistically meaningful estimate of the mean and standard deviation of the absolute skew $\\Delta t$ between two equal-length branches when the interconnect wire width and thickness vary randomly.\n\nStart from the following fundamental base:\n\n- Electrical resistance over a uniform conductor of length $L$ is given by $R = \\rho \\dfrac{L}{A}$, where $\\rho$ is the material resistivity and $A$ is the cross-sectional area. For a rectangular cross-section, $A = w\\,t$, with $w$ the wire width and $t$ the wire thickness. Define the per-unit-length resistance as $R' = \\rho/(w\\,t)$.\n- The capacitance of a conductor above a ground plane in a dielectric of thickness $h$ and relative permittivity $\\varepsilon_r$ can be approximated using the permittivity of free space $\\varepsilon_0$ as a sum of a parallel-plate component and a fringe component. Define the per-unit-length capacitance as $C' = \\varepsilon_0\\,\\varepsilon_r\\left(\\dfrac{w}{h} + \\kappa\\,\\dfrac{t}{h}\\right)$, where $\\kappa$ is an empirical non-dimensional factor modeling sidewall fringe effects.\n- For a uniform distributed $RC$ line of length $L$, the first moment (Elmore delay) to the far-end under a step input can be obtained by integrating the product of resistance to a segment and its downstream capacitance over the line; this produces a delay that depends on $R'$, $C'$, and $L$. When a driver of resistance $R_{\\mathrm{drv}}$ drives the line, and the far end sees a lumped sink capacitance $C_{\\mathrm{sink}}$, linear time-invariant circuit principles imply additional contributions to the total propagation delay due to charging the line capacitance and the sink capacitance through $R_{\\mathrm{drv}}$ and the line resistance.\n\nYour program must:\n\n1. Model two sibling H-tree branches, each of length $L$, as identical nominal geometries but subject to random manufacturing variation in wire width $w$ and thickness $t$.\n2. Draw random samples of width and thickness for each branch using a zero-mean Gaussian distribution for deviations about the nominal values, truncated at $\\pm 3$ standard deviations to enforce physically realistic bounds. Let the relative standard deviations (fraction of nominal) be $\\sigma_w$ for width and $\\sigma_t$ for thickness. Model correlation by decomposing the variation into a globally correlated component (shared by both branches) and a locally independent component (unique to each branch). Let the fraction of total variance that is globally correlated be $f_{\\mathrm{glob}} \\in [0,1]$. The remaining fraction $1-f_{\\mathrm{glob}}$ is independent per branch. Ensure sampled widths $w$ and thicknesses $t$ are strictly positive; if necessary, enforce a minimum floor at $0.2$ times the corresponding nominal to maintain physical plausibility.\n3. For each Monte Carlo trial, compute the propagation delay along each branch starting from the above fundamental definitions. Include the contributions of the distributed line and the driver and sink, based on linear circuit theory, without assuming any single-lumped time constant shortcut. Use the permittivity of free space $\\varepsilon_0$ for capacitance and the material resistivity $\\rho$ for resistance. Compute the absolute skew $\\Delta t$ for the trial as the absolute difference between the two branch delays.\n4. Repeat for $N$ trials to form the skew distribution. Compute the sample mean and sample standard deviation of $\\Delta t$ in seconds for each test case.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element must itself be a two-element list $[m,s]$ where $m$ is the mean of $\\Delta t$ and $s$ is the standard deviation of $\\Delta t$, both expressed in seconds as decimal numbers. For example, the output should look like $[[m_1,s_1],[m_2,s_2],\\dots]$ with no spaces.\n\nUse the following test suite. Each test case is a set of parameters $(L,w_{\\mathrm{nom}},t_{\\mathrm{nom}},h,\\varepsilon_r,R_{\\mathrm{drv}},C_{\\mathrm{sink}},\\rho,\\kappa,\\sigma_w,\\sigma_t,f_{\\mathrm{glob}},N)$:\n\n- Happy path case:\n  - $L = 5\\times 10^{-3}\\,\\mathrm{m}$,\n  - $w_{\\mathrm{nom}} = 2\\times 10^{-6}\\,\\mathrm{m}$,\n  - $t_{\\mathrm{nom}} = 5\\times 10^{-7}\\,\\mathrm{m}$,\n  - $h = 4\\times 10^{-7}\\,\\mathrm{m}$,\n  - $\\varepsilon_r = 3.9$,\n  - $R_{\\mathrm{drv}} = 50\\,\\Omega$,\n  - $C_{\\mathrm{sink}} = 5\\times 10^{-14}\\,\\mathrm{F}$,\n  - $\\rho = 1.68\\times 10^{-8}\\,\\Omega\\cdot\\mathrm{m}$,\n  - $\\kappa = 2.0$,\n  - $\\sigma_w = 0.20$,\n  - $\\sigma_t = 0.15$,\n  - $f_{\\mathrm{glob}} = 0.30$,\n  - $N = 20000$.\n- Low-variation boundary:\n  - $L = 5\\times 10^{-3}\\,\\mathrm{m}$,\n  - $w_{\\mathrm{nom}} = 2\\times 10^{-6}\\,\\mathrm{m}$,\n  - $t_{\\mathrm{nom}} = 5\\times 10^{-7}\\,\\mathrm{m}$,\n  - $h = 4\\times 10^{-7}\\,\\mathrm{m}$,\n  - $\\varepsilon_r = 3.9$,\n  - $R_{\\mathrm{drv}} = 50\\,\\Omega$,\n  - $C_{\\mathrm{sink}} = 5\\times 10^{-14}\\,\\mathrm{F}$,\n  - $\\rho = 1.68\\times 10^{-8}\\,\\Omega\\cdot\\mathrm{m}$,\n  - $\\kappa = 2.0$,\n  - $\\sigma_w = 0.01$,\n  - $\\sigma_t = 0.01$,\n  - $f_{\\mathrm{glob}} = 0.00$,\n  - $N = 10000$.\n- High global correlation edge case:\n  - $L = 5\\times 10^{-3}\\,\\mathrm{m}$,\n  - $w_{\\mathrm{nom}} = 2\\times 10^{-6}\\,\\mathrm{m}$,\n  - $t_{\\mathrm{nom}} = 5\\times 10^{-7}\\,\\mathrm{m}$,\n  - $h = 4\\times 10^{-7}\\,\\mathrm{m}$,\n  - $\\varepsilon_r = 3.9$,\n  - $R_{\\mathrm{drv}} = 50\\,\\Omega$,\n  - $C_{\\mathrm{sink}} = 5\\times 10^{-14}\\,\\mathrm{F}$,\n  - $\\rho = 1.68\\times 10^{-8}\\,\\Omega\\cdot\\mathrm{m}$,\n  - $\\kappa = 2.0$,\n  - $\\sigma_w = 0.15$,\n  - $\\sigma_t = 0.15$,\n  - $f_{\\mathrm{glob}} = 0.90$,\n  - $N = 10000$.\n- Longer branch length case:\n  - $L = 1\\times 10^{-2}\\,\\mathrm{m}$,\n  - $w_{\\mathrm{nom}} = 2\\times 10^{-6}\\,\\mathrm{m}$,\n  - $t_{\\mathrm{nom}} = 5\\times 10^{-7}\\,\\mathrm{m}$,\n  - $h = 4\\times 10^{-7}\\,\\mathrm{m}$,\n  - $\\varepsilon_r = 3.9$,\n  - $R_{\\mathrm{drv}} = 50\\,\\Omega$,\n  - $C_{\\mathrm{sink}} = 5\\times 10^{-14}\\,\\mathrm{F}$,\n  - $\\rho = 1.68\\times 10^{-8}\\,\\Omega\\cdot\\mathrm{m}$,\n  - $\\kappa = 2.0$,\n  - $\\sigma_w = 0.20$,\n  - $\\sigma_t = 0.15$,\n  - $f_{\\mathrm{glob}} = 0.30$,\n  - $N = 8000$.\n\nAngle units are not applicable. All times must be expressed in seconds. Your program must produce exactly one line of output in the format $[[m_1,s_1],[m_2,s_2],[m_3,s_3],[m_4,s_4]]$ with no spaces, where $[m_i,s_i]$ are the mean and standard deviation of $\\Delta t$ for the $i$-th test case.",
            "solution": "The problem statement has been critically validated and is determined to be **valid**. It is scientifically grounded in established principles of electrical engineering, well-posed for a numerical Monte Carlo simulation, and presented with objective, formalizable specifications. All necessary parameters and models are provided, and there are no internal contradictions, ambiguities, or physically implausible conditions.\n\nThe task is to estimate the statistical distribution (mean and standard deviation) of clock skew between two sibling H-tree branches subject to manufacturing process variations. This will be accomplished through a Monte Carlo simulation based on physical models of interconnect delay.\n\n### 1. Propagation Delay Model\n\nThe propagation delay for a single branch is modeled using the Elmore delay, a first-moment approximation widely used for RC networks. A branch consists of a driver with resistance $R_{\\mathrm{drv}}$, a uniform distributed RC line of length $L$, and a sink capacitance $C_{\\mathrm{sink}}$.\n\nThe per-unit-length resistance $R'$ and capacitance $C'$ of the interconnect wire are defined as:\n$$ R' = \\frac{\\rho}{A} = \\frac{\\rho}{w\\,t} $$\n$$ C' = \\varepsilon_0\\,\\varepsilon_r\\left(\\frac{w}{h} + \\kappa\\,\\frac{t}{h}\\right) $$\nwhere $w$ is the wire width, $t$ is the wire thickness, $\\rho$ is the material resistivity, $A$ is the cross-sectional area, $h$ is the dielectric thickness, $\\varepsilon_r$ is the relative permittivity, $\\varepsilon_0$ is the permittivity of free space, and $\\kappa$ is an empirical fringe factor.\n\nThe Elmore delay $\\tau_D$ at a target node is calculated by summing, over all capacitances $C_k$ in the circuit, the product of $C_k$ and the resistance of the path from the source to the target node that is also shared by the path to $C_k$. For a continuous line driven by $R_{\\mathrm{drv}}$, this can be formulated as an integral. The delay at the far end of the line (before $C_{\\mathrm{sink}}$) is the sum of contributions from the distributed capacitance of the line itself and the lumped sink capacitance.\n\n1.  **Contribution from the distributed line capacitance**: A small segment of wire of length $dx$ at position $x$ from the driver has a capacitance $dC = C'dx$. The resistance from the source to this point is $R(x) = R_{\\mathrm{drv}} + R'x$. The delay contribution from the entire line is the integral over its length:\n    $$ \\tau_{\\mathrm{line}} = \\int_0^L R(x) \\, dC(x) = \\int_0^L (R_{\\mathrm{drv}} + R'x) C' dx $$\n    $$ \\tau_{\\mathrm{line}} = C' \\left[ R_{\\mathrm{drv}}x + \\frac{1}{2}R'x^2 \\right]_0^L = R_{\\mathrm{drv}}C'L + \\frac{1}{2}R'C'L^2 $$\n\n2.  **Contribution from the sink capacitance**: The total resistance of the path from the source to the sink capacitance $C_{\\mathrm{sink}}$ is $R_{\\mathrm{path}} = R_{\\mathrm{drv}} + R'_{\\mathrm{line}} = R_{\\mathrm{drv}} + R'L$. This contributes:\n    $$ \\tau_{\\mathrm{sink}} = (R_{\\mathrm{drv}} + R'L) C_{\\mathrm{sink}} $$\n\nThe total propagation delay $T_{\\mathrm{delay}}$ is the sum of these components:\n$$ T_{\\mathrm{delay}} = \\tau_{\\mathrm{line}} + \\tau_{\\mathrm{sink}} = (R_{\\mathrm{drv}}C'L + \\frac{1}{2}R'C'L^2) + (R_{\\mathrm{drv}}C_{\\mathrm{sink}} + R'LC_{\\mathrm{sink}}) $$\nRearranging the terms gives the complete delay formula used for each branch:\n$$ T_{\\mathrm{delay}} = R_{\\mathrm{drv}}C_{\\mathrm{sink}} + L(R_{\\mathrm{drv}}C' + R'C_{\\mathrm{sink}}) + \\frac{1}{2}R'C'L^2 $$\n\n### 2. Statistical Variation Model\n\nManufacturing variations in wire width $w$ and thickness $t$ are modeled as random deviations from their nominal values ($w_{\\mathrm{nom}}$, $t_{\\mathrm{nom}}$). For any parameter $p \\in \\{w, t\\}$, its value is given by $p = p_{\\mathrm{nom}}(1 + \\delta_{p})$, where $\\delta_p$ is a zero-mean random fractional deviation.\n\nThis deviation $\\delta_p$ is decomposed into a globally correlated component ($\\delta_{p,g}$), which is common to both sibling branches, and a locally independent component ($\\delta_{p,l}$), which is unique to each branch: $\\delta_p = \\delta_{p,g} + \\delta_{p,l}$.\n\nGiven the relative standard deviation $\\sigma_p$ for parameter $p$ and the fraction of globally correlated variance $f_{\\mathrm{glob}}$, the standard deviations of the components are:\n$$ \\sigma_{p,g} = \\sigma_p \\sqrt{f_{\\mathrm{glob}}} $$\n$$ \\sigma_{p,l} = \\sigma_p \\sqrt{1 - f_{\\mathrm{glob}}} $$\n\nWe generate these deviations by scaling random variates drawn from a standard normal distribution, truncated to the interval $[-3, 3]$ to match the \"$\\pm 3$ standard deviations\" constraint. Let $Z_g$, $Z_{l,1}$, and $Z_{l,2}$ be independent samples from this truncated distribution. The fractional deviations for the two branches ($i=1, 2$) are:\n$$ \\delta_{p,i} = \\sigma_p \\left( \\sqrt{f_{\\mathrm{glob}}} Z_{p,g} + \\sqrt{1 - f_{\\mathrm{glob}}} Z_{p,l,i} \\right) $$\nThe physical parameter values for each branch are then:\n$$ w_i = w_{\\mathrm{nom}}(1 + \\delta_{w,i}), \\quad t_i = t_{\\mathrm{nom}}(1 + \\delta_{t,i}) $$\nTo ensure physical plausibility, a floor is applied: $w_i = \\max(w_i, 0.2 w_{\\mathrm{nom}})$ and $t_i = \\max(t_i, 0.2 t_{\\mathrm{nom}})$.\n\n### 3. Monte Carlo Simulation\n\nA Monte Carlo simulation is performed for each test case to estimate the mean and standard deviation of the absolute skew, $\\Delta t = |T_1 - T_2|$. For $N$ trials, the process is as follows:\n\n1.  **Generate Random Variates**: Generate $N$ samples for each of the six required random inputs: $Z_{w,g}, Z_{t,g}, Z_{w,l,1}, Z_{w,l,2}, Z_{t,l,1}, Z_{t,l,2}$. This is done in a vectorized manner for efficiency.\n2.  **Calculate Branch Parameters**: For each of the $N$ trials, calculate the randomized width and thickness arrays ($w_1, t_1, w_2, t_2$) for both branches using the statistical model.\n3.  **Compute Delays**: Using these parameter arrays, compute the corresponding arrays of per-unit-length resistance ($R'_1, R'_2$) and capacitance ($C'_1, C'_2$). Then, apply the derived propagation delay formula to get the delay arrays $T_1$ and $T_2$.\n4.  **Calculate Skew Distribution**: Compute the absolute skew for each trial: $\\Delta t[k] = |T_1[k] - T_2[k]|$ for $k=1, \\dots, N$.\n5.  **Estimate Statistics**: Calculate the sample mean $\\bar{\\Delta t}$ and sample standard deviation $s_{\\Delta t}$ of the resulting skew distribution array. The sample standard deviation is calculated using a divisor of $N-1$ (Bessel's correction).\n\nThis procedure provides a robust statistical estimate of the skew distribution under the specified process variations.",
            "answer": "```python\nimport numpy as np\nfrom scipy import stats, constants\n\ndef run_monte_carlo_simulation(L, w_nom, t_nom, h, eps_r, R_drv, C_sink, rho, kappa, sigma_w, sigma_t, f_glob, N):\n    \"\"\"\n    Performs a Monte Carlo simulation to estimate clock skew mean and standard deviation.\n\n    Args:\n        L (float): Branch length (m).\n        w_nom (float): Nominal wire width (m).\n        t_nom (float): Nominal wire thickness (m).\n        h (float): Dielectric thickness (m).\n        eps_r (float): Relative permittivity of dielectric.\n        R_drv (float): Driver resistance (Ohm).\n        C_sink (float): Sink capacitance (F).\n        rho (float): Wire resistivity (Ohm*m).\n        kappa (float): Fringe capacitance factor.\n        sigma_w (float): Relative standard deviation of width.\n        sigma_t (float): Relative standard deviation of thickness.\n        f_glob (float): Fraction of globally correlated variance.\n        N (int): Number of Monte Carlo trials.\n\n    Returns:\n        tuple[float, float]: A tuple containing the mean and standard deviation of the absolute skew in seconds.\n    \"\"\"\n    epsilon_0 = constants.epsilon_0\n    \n    # Use a truncated normal distribution for generating random variates.\n    # The standard normal distribution is truncated at +/- 3 sigma.\n    low, high = -3, 3\n    trunc_norm_gen = stats.truncnorm(a=low, b=high, loc=0, scale=1)\n    \n    # Generate all random numbers in a vectorized manner for N trials\n    # 6 random numbers per trial: Z_wg, Z_tg, Z_wl1, Z_wl2, Z_tl1, Z_tl2\n    Z_samples = trunc_norm_gen.rvs(size=(N, 6))\n    Z_wg, Z_tg = Z_samples[:, 0], Z_samples[:, 1]\n    Z_wl1, Z_wl2 = Z_samples[:, 2], Z_samples[:, 3]\n    Z_tl1, Z_tl2 = Z_samples[:, 4], Z_samples[:, 5]\n\n    # Calculate standard deviations for global and local components\n    sqrt_f_glob = np.sqrt(f_glob)\n    sqrt_1_minus_f_glob = np.sqrt(1.0 - f_glob)\n\n    # Calculate fractional deviations for width and thickness for both branches\n    delta_w1 = sigma_w * (sqrt_f_glob * Z_wg + sqrt_1_minus_f_glob * Z_wl1)\n    delta_w2 = sigma_w * (sqrt_f_glob * Z_wg + sqrt_1_minus_f_glob * Z_wl2)\n    delta_t1 = sigma_t * (sqrt_f_glob * Z_tg + sqrt_1_minus_f_glob * Z_tl1)\n    delta_t2 = sigma_t * (sqrt_f_glob * Z_tg + sqrt_1_minus_f_glob * Z_tl2)\n    \n    # Calculate dimensional parameters, applying flooring for physical realism\n    w1 = np.maximum(w_nom * (1.0 + delta_w1), 0.2 * w_nom)\n    w2 = np.maximum(w_nom * (1.0 + delta_w2), 0.2 * w_nom)\n    t1 = np.maximum(t_nom * (1.0 + delta_t1), 0.2 * t_nom)\n    t2 = np.maximum(t_nom * (1.0 + delta_t2), 0.2 * t_nom)\n\n    def calculate_delay(w, t):\n        \"\"\"Calculates propagation delay for given geometry arrays.\"\"\"\n        A = w * t\n        \n        # Handle potential division by zero, although flooring should prevent it.\n        A[A == 0] = 1e-30\n        \n        R_prime = rho / A\n        C_prime = epsilon_0 * eps_r * (w / h + kappa * t / h)\n        \n        # Elmore delay formula\n        term1 = R_drv * C_sink\n        term2 = L * (R_drv * C_prime + R_prime * C_sink)\n        term3 = 0.5 * R_prime * C_prime * L**2\n        \n        return term1 + term2 + term3\n\n    # Calculate delays for both branches across all N trials\n    delay1 = calculate_delay(w1, t1)\n    delay2 = calculate_delay(w2, t2)\n    \n    # Calculate the absolute skew for each trial\n    absolute_skew = np.abs(delay1 - delay2)\n    \n    # Compute sample mean and sample standard deviation (ddof=1 for unbiased estimator)\n    mean_skew = np.mean(absolute_skew)\n    std_dev_skew = np.std(absolute_skew, ddof=1)\n    \n    return mean_skew, std_dev_skew\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, w_nom, t_nom, h, eps_r, R_drv, C_sink, rho, kappa, sigma_w, sigma_t, f_glob, N)\n        (5e-3, 2e-6, 5e-7, 4e-7, 3.9, 50, 5e-14, 1.68e-8, 2.0, 0.20, 0.15, 0.30, 20000),\n        (5e-3, 2e-6, 5e-7, 4e-7, 3.9, 50, 5e-14, 1.68e-8, 2.0, 0.01, 0.01, 0.00, 10000),\n        (5e-3, 2e-6, 5e-7, 4e-7, 3.9, 50, 5e-14, 1.68e-8, 2.0, 0.15, 0.15, 0.90, 10000),\n        (1e-2, 2e-6, 5e-7, 4e-7, 3.9, 50, 5e-14, 1.68e-8, 2.0, 0.20, 0.15, 0.30, 8000),\n    ]\n\n    results = []\n    for case in test_cases:\n        mean, std_dev = run_monte_carlo_simulation(*case)\n        results.append([mean, std_dev])\n\n    # Format the final output string exactly as required, with no spaces.\n    str_results = [f\"[{m},{s}]\" for m, s in results]\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        }
    ]
}