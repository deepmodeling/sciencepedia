## 引言
在[集成电路设计](@entry_id:1126551)从逻辑蓝图走向物理现实的宏伟征程中，版图规划（Floorplanning）扮演着承前启后的关键角色。它如同城市规划师为一座未来的微观都市绘制第一张蓝图，需要在有限的硅片空间内，为成百上千个[功能模块](@entry_id:275097)找到最佳的栖身之所。这一过程远非简单的几何拼图游戏，而是一场在性能、功耗、面积和成本（PPAc）等多重目标之间寻求最佳平衡的复杂博弈。如何精确地描述模块间的相对位置，并在此基础上高效地探索亿万种可能的布局方案，便成为了电子设计自动化（EDA）领域一个核心的知识缺口。

本文旨在深入探讨用于描述和操作版图布局的“语言”——即切分与非切分表示法。通过学习这门语言，您将能够理解自动化布局工具背后的核心思想。
- 在“原理与机制”一章中，我们将从最基本的平铺问题出发，剖析切分式布局的简洁之美与非切分式布局的完备之力，探索如[波兰表达式](@entry_id:1129910)、[序列对](@entry_id:1131501)及B*树等经典表示法的数学精髓。
- 接着，在“应用与交叉学科联系”一章，我们将把这些抽象的表示法置于真实世界的芯片设计场景中，看它们如何与电路的物理特性（如时序和功耗）相结合，并被[模拟退火](@entry_id:144939)等[优化算法](@entry_id:147840)所驾驭。
- 最后，“动手实践”部分将提供具体的练习，让您亲手将理论转化为可计算的步骤，巩固对这些核心概念的理解。

让我们一同揭开这些优雅的组合结构如何编织出驱动数字世界的微观奇迹的神秘面纱。

## 原理与机制

在上一章中，我们已经对芯片版图规划（Floorplanning）有了初步的印象，它就像是在一块空白的画布上，为一众大大小小的矩形电路模块找到各自的安身之所。现在，让我们像物理学家一样，深入到这个问题的核心，去探寻其背后的原理与机制。我们不仅要问“是什么”，更要问“为什么”，并在这个过程中欣赏那些由抽象规则编织出的几何之美。

### 万物之始：平铺问题

想象一下，你有一堆矩形积木，现在需要将它们严丝合缝地拼入一个大的矩形盒子中，既不能重叠，也不能留下任何空隙。这正是版图规划最核心的挑战，我们称这种完美的拼图为一个 **马赛克版图（mosaic floorplan）**。

这个看似简单的游戏，背后却隐藏着严谨的数学约束。对于任意两个不同的模块 $i$ 和 $j$，它们不能“侵犯”彼此的空间。这意味着，模块 $i$ 必须完全位于模块 $j$ 的左侧、右侧、下方或上方。这四种可能性，我们至少要满足其一。同时，所有模块的总面积必须恰好等于大矩形盒子的面积，这保证了没有一寸土地被浪费 。

用数学的语言来说，如果我们用 $(x_i, y_i)$ 表示模块 $i$ 左下角的坐标，用 $w_i$ 和 $h_i$ 表示其宽度和高度，那么对于任意两个模块 $i$ 和 $j$，必须满足以下四个条件之一：
$$ (x_i + w_i \le x_j) \lor (x_j + w_j \le x_i) \lor (y_i + h_i \le y_j) \lor (y_j + h_j \le y_i) $$
这是一个包含“或”逻辑的 **析取约束 (disjunctive constraint)**。当模块数量增多时，这些约束的组合会呈爆炸式增长，使得寻找一个[可行解](@entry_id:634783)变得异常困难。这正是计算科学家和工程师们需要发挥创造力的地方：我们需要一种更聪明的“语言”来描述这些布局，从而简化搜索过程。

### 一个简单的想法：切蛋糕

面对复杂的平铺问题，一个自然而然的想法是“[分而治之](@entry_id:273215)”。想象我们手中的不是一块芯片，而是一块方形的蛋糕。我们该如何将它分给几个朋友？最简单的方法莫过于“一刀切”，我们称之为 **“铡刀式”切割（guillotine cut）**。我们可以先水平切一刀，将蛋糕分成上下两块；或者垂直切一刀，分成左右两块。然后，对得到的每一小块，我们都可以重复这个过程，直到分出足够多的小块。

通过这种递归切割的方式生成的版图，我们称之为 **切分版图（slicing floorplan）**。它的结构非常清晰，具有天然的层次性。然而，这种简单的方法是否万能呢？答案是否定的。存在一些版图结构，它们是无法通过任何“一刀切”的方式得到的。一个经典的例子是“风车”状（pinwheel）的布局，其中五个模块相互“锁定”，使得任何一条横贯或纵贯整个版图的直线都必然会穿过某个模块的内部。这样的版图，我们称之为 **非切分版图（non-slicing floorplan）** 。

这个发现至关重要，它告诉我们，现实世界比我们最初设想的要复杂。切分版图虽然简单直观，但它只是所有可能的马赛克版图中的一个子集。为了探索更广阔的设计空间，我们必须寻找能够描述非切分结构的更强有力的语言。

### 为“切法”编码：切分树、[波兰表达式](@entry_id:1129910)与范式

在我们深入非切分的世界之前，让我们先为优美的切分结构找到一种优雅的表达方式。既然切分过程是递归的，那么用 **树** 结构来描述它就再合适不过了。我们可以构建一棵 **二叉切分树（binary slicing tree）**，其中每个叶节点代表一个电路模块，而每个非[叶节点](@entry_id:266134)则代表一次切割：用 $V$ (Vertical) 表示垂直切割，用 $H$ (Horizontal) 表示水平切割 。

这棵树不仅记录了版图的拓扑结构，还能帮助我们计算整个版图的尺寸。规则非常简单：
- 对于一个 $V$ 节点，其左右子树代表左右两个子版图。这个组合版图的总宽度是两个子版图宽度之和，总高度则是两者高度中的较大值。
- 对于一个 $H$ 节点，其左右子树代表上下两个子版图。这个组合版图的总高度是两个子版图高度之和，总宽度则是两者宽度中的较大值。

通过从[叶节点](@entry_id:266134)（模块自身尺寸已知）开始，自底向上应用这些规则，我们就能算出根节点所代表的整个版图的最小包围盒尺寸 。

为了让计算机更方便地处理这种树结构，我们可以将其“线性化”为一种被称为 **[波兰表达式](@entry_id:1129910)（Polish expression）** 的字符串。通过对切分树进行[后序遍历](@entry_id:273478)，我们就能得到一个由模块名（操作数）和切割符 $H/V$（操作符）组成的序列。例如，表达式 `A B V C H` 就对应着先将 A 和 B 垂直并列，再将这个组合体与 C 水平堆叠的结构。一个合法的[波兰表达式](@entry_id:1129910)必须满足一个优美的“平衡”条件：在从左到右扫描表达式的任何时刻，我们遇到的操作数数量总是要比操作符多，这保证了我们总有足够的“材料”来进行“组合”操作 。

然而，这种表示方法也带来了新的问题：**冗余性**。同一个拓扑结构可能对应着许多不同的[波兰表达式](@entry_id:1129910)。例如，对于三个水平堆叠的模块 A、B、C，表达式 `A B H C H` 和 `A B C H H` 代表的都是 A 在最上、B 居中、C 在最下的布局。这种冗余源于切割操作的 **[结合律](@entry_id:151180)**（associativity）。此外，由于我们通常不区分[镜像对称](@entry_id:158730)的布局，切割操作还表现出 **[交换律](@entry_id:141214)**（commutativity），例如 `A B H` 和 `B A H` 代表的只是同一个布局的上下翻转。

为了让优化算法（如[模拟退火](@entry_id:144939)）不在这些等价的表示之间浪费时间，我们需要一个“标准答案”，即 **范式（canonical form）**。通过引入一些简单的句法规则，例如禁止 `HH` 或 `VV` 这样的连续相同操作符出现，并对同一切割链下的模块按固定顺序排序，我们就能为每一个独特的切分拓扑指定一个唯一的[波兰表达式](@entry_id:1129910)，从而大大提高搜索效率 。

### 超越切分：非切分的世界

既然切分有其局限性，我们如何才能描述像“风车”那样更复杂的结构呢？关键在于转变思路。与其描述“如何切割空间”，不如直接描述“模块之间的相对位置”。

#### 用序列编码相对关系：[序列对](@entry_id:1131501)及其对称性

上世纪90年代，一个绝妙的想法诞生了：用一对排列组合，即 **[序列对](@entry_id:1131501)（sequence pair）**，来捕捉所有模块间的相对位置关系。这听起来有些不可思议，但规则却异常简单。给定两个包含所有模块名的排列 $\pi_x$ 和 $\pi_y$，对于任意两个模块 $i$ 和 $j$：
- 如果在 $\pi_x$ 和 $\pi_y$ 中，$i$ 都出现在 $j$ 的前面，那么在最终的布局中，$i$ 必须在 $j$ 的 **左边**。
- 如果在 $\pi_x$ 中 $i$ 在 $j$ 前面，但在 $\pi_y$ 中 $j$ 在 $i$ 前面，那么 $i$ 必须在 $j$ 的 **下方**。

这两条简单的规则，为任意一对模块都指定了清晰的水平或垂直约束 。当所有这些约束汇集在一起时，它们就形成了一张 **[约束图](@entry_id:267131)（constraint graph）**。计算版图的最小宽度和高度，就等价于在这张图上寻找 **最长路径（longest path）**——这是一个经典的[图论](@entry_id:140799)问题 。这个从纯组合结构到几何布局的转换过程，完美体现了不同数学分支之间的深刻联系。

当然，[序列对](@entry_id:1131501)表示法也存在冗余。一个版图经过旋转或镜像反射后，其拓扑结构并未改变，但描述它的[序列对](@entry_id:1131501)却会完全不同。一个通用的版图，连同它的[旋转和反射](@entry_id:136876)版本，总共对应着8个不同的[序列对](@entry_id:1131501)。这个数字“8”并非巧合，它正是一个正方形的所有[对称变换](@entry_id:144406)（[旋转和反射](@entry_id:136876)）的数量，在数学上被称为 **[二面体群](@entry_id:143875) $D_4$** 。理解这种对称性，对于避免在优化过程中重复探索等价的布局至关重要。

#### 用邻接关系编码：B\*树和天际线算法

除了[序列对](@entry_id:1131501)，还有另一种描述非切分版图的巧妙方法——**B\*树（B\*-tree）**。它同样使用一棵[二叉树](@entry_id:270401)，但其节点的父子关系直接编码了空间邻接性：
- 一个节点的 **左孩子**，将被放置在该节点的 **右侧**。
- 一个节点的 **右孩子**，将被放置在该节点的 **上方**。

与[序列对](@entry_id:1131501)一次性生成所有约束不同，B\*树通常与一个动态的、增量式的打包算法配合使用。这个算法引入了一个非常形象的概念——**天际线（skyline）**。想象你正在从下往上建设一座由矩形建筑构成的城市。天际线就是当前所有已放置建筑物顶部的轮廓线。当要放置一个新模块时，我们首先根据 B\*树的规则确定它的暂定水平位置（$x$ 坐标），然后让它“下落”，直到它的底部接触到下方那段天际线的最高点为止。之后，这个新模块的顶部就成了新的天际线的一部分 。

这个过程就像玩俄罗斯方块，既直观又高效。借助[平衡二叉搜索树](@entry_id:636550)等高级数据结构，我们可以在 $O(n \log n)$ 的时间内完成对 $n$ 个模块的紧凑打包，这在计算效率上是相当出色的。

### [表达能力](@entry_id:149863)的层级

至此，我们已经探索了版图规划的几种核心表示方法。现在，让我们退后一步，从一个更高的视角来审视它们。我们可以根据一种表示法所能描述的版图范围，即它的 **[表达能力](@entry_id:149863)（expressiveness）**，来给它们排个序 。

- **切分版图** 的集合是所有 **马赛克版图** 集合的一个 **[真子集](@entry_id:152276)**。
- **切分树**（及其等价的[波兰表达式](@entry_id:1129910)）的表达能力恰好就是切分版图的集合。它无法表示非切分版图。
- **[序列对](@entry_id:1131501)** 和 **B\*树** 等非切分表示法则更为强大，它们的表达能力覆盖了 **所有** 的马赛克版图，无论是切分的还是非切分的。我们称它们是 **完备的（complete）**。

因此，任何一个可以用切分树表示的版图，也必然可以用[序列对](@entry_id:1131501)来表示，但反之则不然 。这揭示了在选择表示方法时的一种根本权衡：切分表示法结构更简单，约束性更强，易于分析和操作，但牺牲了通用性；非切分表示法虽然更复杂，冗余性也更高，但它们提供了描述任意复杂布局的强大能力，为找到更优的解决方案打开了大门。

从简单的平铺游戏到复杂的数学约束，从直观的“切蛋糕”到抽象的序列编码与[群论对称性](@entry_id:174349)，版图规划的原理与机制展现了一场理论与实践、简洁与完备之间的优美舞蹈。理解这背后的逻辑，正是我们设计出更智能、更高效的自动化工具的关键所在。