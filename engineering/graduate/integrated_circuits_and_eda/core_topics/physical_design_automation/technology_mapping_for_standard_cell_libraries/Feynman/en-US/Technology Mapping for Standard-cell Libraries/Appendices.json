{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of technology mapping is efficient Boolean matching, which relies on the concept of NPN equivalence. This practice explores how a limited set of library cells can cover a multitude of functions through input permutation, input negation, and output negation. By analyzing the NPN classes of standard AOI21 and OAI21 gates, you will gain insight into library characterization and the fundamental limits of matching specific functions like the three-input XOR .",
            "id": "4304195",
            "problem": "Consider a technology mapping scenario in Electronic Design Automation (EDA) for a three-input Boolean network where the available standard-cell library contains the two cells AOI21 and OAI21, and signal inversion is available at no cost. The AOI21 cell realizes the function $f_{\\mathrm{AOI21}}(a,b,c)=\\overline{ab+c}$ and the OAI21 cell realizes the function $f_{\\mathrm{OAI21}}(a,b,c)=\\overline{(a+b)c}$. A mapping solution is allowed to use any negation of inputs, any permutation of inputs, and optional output negation; equivalence under these transformations is called Negation–Permutation–Negation (NPN) equivalence for three-input Boolean functions.\n\nStarting from the core definitions of Boolean functions, NPN equivalence (input negations and permutations, and output negation), and truth-table invariants, determine:\n- the number of distinct NPN equivalence classes that can be covered by the given library when all allowed NPN transformations are applied to its cells, and\n- whether the three-input parity (exclusive-or) function $x(a,b,c)=a\\oplus b\\oplus c$ can be matched by the library under some combination of input permutations, input negations, and optional output negation.\n\nReport your final answer as two quantities in this order: first the number of distinct NPN classes covered, and second an indicator $I_{\\mathrm{XOR}}$ with $I_{\\mathrm{XOR}}=1$ if matching the parity function is possible under NPN transformations and $I_{\\mathrm{XOR}}=0$ otherwise. No rounding is necessary. Express the final answer as a row matrix as specified.",
            "solution": "The problem requires us to analyze a standard-cell library containing two three-input cells, AOI21 and OAI21, under the framework of Negation-Permutation-Negation (NPN) equivalence. We must determine the number of distinct NPN equivalence classes covered by this library and whether the three-input parity function, XOR3, can be implemented by a cell in this library under NPN transformations.\n\nThe Boolean functions realized by the two library cells are given as:\n1.  And-Or-Invert 21 (AOI21): $f_{\\mathrm{AOI21}}(a,b,c) = \\overline{ab+c}$\n2.  Or-And-Invert 21 (OAI21): $f_{\\mathrm{OAI21}}(a,b,c) = \\overline{(a+b)c}$\n\nThe target function to check for matching is the three-input exclusive-OR (parity) function:\n$x(a,b,c) = a \\oplus b \\oplus c$\n\nNPN equivalence defines two functions as equivalent if one can be obtained from the other through any combination of input negation, input permutation, and output negation.\n\nOur first task is to determine if $f_{\\mathrm{AOI21}}$ and $f_{\\mathrm{OAI21}}$ belong to the same NPN equivalence class. If they do, the library covers only one class. If not, it covers two.\n\nA powerful tool for this analysis is the concept of Boolean duality. The dual of a function $f(x_1, \\dots, x_n)$, denoted $f^D(x_1, \\dots, x_n)$, is defined as $f^D(x_1, \\dots, x_n) = \\overline{f(\\overline{x_1}, \\dots, \\overline{x_n})}$. A function $g$ that is the dual of a function $f$ is, by definition, NPN-equivalent to $f$. The transformation involves negating all inputs and negating the output.\n\nLet's compute the dual of $f_{\\mathrm{AOI21}}(a,b,c)$.\n$f_{\\mathrm{AOI21}}^D(a,b,c) = \\overline{f_{\\mathrm{AOI21}}(\\bar{a},\\bar{b},\\bar{c})}$\nSubstituting the definition of $f_{\\mathrm{AOI21}}$:\n$f_{\\mathrm{AOI21}}^D(a,b,c) = \\overline{\\overline{(\\bar{a}\\bar{b}+\\bar{c})}} = \\bar{a}\\bar{b}+\\bar{c}$\nUsing De Morgan's laws, we can rewrite $\\bar{a}\\bar{b}$ as $\\overline{a+b}$.\nSo, $f_{\\mathrm{AOI21}}^D(a,b,c) = \\overline{a+b}+\\bar{c}$.\n\nNow, let's analyze the function $f_{\\mathrm{OAI21}}(a,b,c) = \\overline{(a+b)c}$. Using De Morgan's laws:\n$f_{\\mathrm{OAI21}}(a,b,c) = \\overline{a+b} + \\bar{c}$.\n\nComparing the two results, we see that:\n$f_{\\mathrm{OAI21}}(a,b,c) = f_{\\mathrm{AOI21}}^D(a,b,c)$\nThis identity proves that $f_{\\mathrm{OAI21}}$ is the dual of $f_{\\mathrm{AOI21}}$. Therefore, $f_{\\mathrm{AOI21}}$ and $f_{\\mathrm{OAI21}}$ are NPN-equivalent. They belong to the same NPN class. The specific transformation is $f_{\\mathrm{OAI21}}(a,b,c) = \\overline{f_{\\mathrm{AOI21}}(\\bar{a},\\bar{b},\\bar{c})}$. Since both cells in the library realize functions from the same NPN class, the library covers only $1$ distinct NPN equivalence class.\n\nThe second task is to determine if the parity function $x(a,b,c) = a \\oplus b \\oplus c$ can be matched, i.e., if it belongs to the same NPN class as the library functions.\n\nTo check for NPN equivalence between functions, we can use NPN invariants, which are properties of a function's truth table that remain unchanged under input permutations and negations. One such simple invariant is the number of minterms for which the function evaluates to $1$ (also known as the weight of the function's truth vector). Let $k$ be the weight of a function $f$ with $n$ inputs. Under input permutation and negation, the weight remains $k$. Under output negation, the weight becomes $2^n - k$. Thus, any function in the NPN class of $f$ must have a weight of either $k$ or $2^n - k$.\n\nLet's compute the weights for the functions involved. Here, the number of inputs is $n=3$, so $2^n=8$.\n\nFor $f_{\\mathrm{AOI21}}(a,b,c) = \\overline{ab+c}$, let's construct its truth table. The inputs $(a,b,c)$ are ordered lexicographically from $(0,0,0)$ to $(1,1,1)$.\n$f_{\\mathrm{AOI21}}(0,0,0) = \\overline{0+0} = 1$\n$f_{\\mathrm{AOI21}}(0,0,1) = \\overline{0+1} = 0$\n$f_{\\mathrm{AOI21}}(0,1,0) = \\overline{0+0} = 1$\n$f_{\\mathrm{AOI21}}(0,1,1) = \\overline{0+1} = 0$\n$f_{\\mathrm{AOI21}}(1,0,0) = \\overline{0+0} = 1$\n$f_{\\mathrm{AOI21}}(1,0,1) = \\overline{0+1} = 0$\n$f_{\\mathrm{AOI21}}(1,1,0) = \\overline{1+0} = 0$\n$f_{\\mathrm{AOI21}}(1,1,1) = \\overline{1+1} = 0$\nThe truth vector is $(1,0,1,0,1,0,0,0)$. The weight of $f_{\\mathrm{AOI21}}$ is $k_{\\mathrm{AOI21}} = 3$.\nThe set of possible weights for any function in the NPN class of $f_{\\mathrm{AOI21}}$ is $\\{k_{\\mathrm{AOI21}}, 8 - k_{\\mathrm{AOI21}}\\} = \\{3, 5\\}$.\n(As a check, the weight of $f_{\\mathrm{OAI21}}$, which is in the same class, is $k_{\\mathrm{OAI21}} = 5$, consistent with this set).\n\nNow, let's compute the weight for the parity function $x(a,b,c) = a \\oplus b \\oplus c$. This function is true if and only if an odd number of its inputs are true.\n$x(0,0,0) = 0$\n$x(0,0,1) = 1$\n$x(0,1,0) = 1$\n$x(0,1,1) = 0$\n$x(1,0,0) = 1$\n$x(1,0,1) = 0$\n$x(1,1,0) = 0$\n$x(1,1,1) = 1$\nThe truth vector is $(0,1,1,0,1,0,0,1)$. The weight of $x(a,b,c)$ is $k_x = 4$.\nThe set of possible weights for any function in the NPN class of $x(a,b,c)$ is $\\{k_x, 8 - k_x\\} = \\{4, 4\\} = \\{4\\}$.\n\nTo be NPN-equivalent, the NPN class of the parity function must share a weight with the NPN class of the library functions.\nThe weight set for the library class is $\\{3, 5\\}$.\nThe weight set for the parity function class is $\\{4\\}$.\nThese two sets are disjoint: $\\{3, 5\\} \\cap \\{4\\} = \\emptyset$.\nTherefore, the parity function $x(a,b,c)$ cannot be NPN-equivalent to $f_{\\mathrm{AOI21}}$ or $f_{\\mathrm{OAI21}}$. It is not possible to match the parity function with the given library under the specified transformations.\n\nThe indicator for matching the parity function, $I_{\\mathrm{XOR}}$, is therefore $0$.\n\nIn summary:\n1.  The number of distinct NPN classes covered by the library is $1$.\n2.  The three-input parity function cannot be matched, so $I_{\\mathrm{XOR}} = 0$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1 & 0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Technology mapping is fundamentally an optimization problem, and a common objective is to minimize circuit area. However, the most straightforward approach—making locally optimal choices—can lead to globally suboptimal results. This exercise provides a concrete counterexample to illustrate the pitfalls of a greedy mapping strategy, demonstrating why more sophisticated algorithms that consider larger patterns are necessary for achieving the best area optimization .",
            "id": "4304184",
            "problem": "Consider a technology mapping instance in Electronic Design Automation (EDA) for a Boolean tree with root computing the function $y = \\overline{(a \\cdot b) + (c \\cdot d)}$, where $a$, $b$, $c$, and $d$ are primary inputs, and $\\overline{(\\cdot)}$ denotes Boolean complement, $\\cdot$ denotes Boolean conjunction, and $+$ denotes Boolean disjunction. The tree has the structure of two binary conjunction nodes feeding a binary disjunction node, which then feeds a unary complement at the root.\n\nAssume an additive area cost model: the total area of a mapped tree is the sum of the areas of the selected standard cells that cover its nodes, with patterns not allowed to overlap. The standard-cell library $\\mathcal{L}$ contains the following cells and areas:\n- $AND2(x,y) = x \\cdot y$ with area $\\alpha_{\\text{AND2}} = 4$,\n- $OR2(x,y) = x + y$ with area $\\alpha_{\\text{OR2}} = 3$,\n- $INV(x) = \\overline{x}$ with area $\\alpha_{\\text{INV}} = 1$,\n- $NAND2(x,y) = \\overline{x \\cdot y}$ with area $\\alpha_{\\text{NAND2}} = 2$,\n- $AOI22(x,y,u,v) = \\overline{(x \\cdot y) + (u \\cdot v)}$ with area $\\alpha_{\\text{AOI22}} = 6$.\n\nA greedy bottom-up mapper operates as follows: at each internal node, it selects a locally area-minimizing cover for the subtree rooted at that node, committing to that choice and forbidding any subsequent overlapping cover by an ancestor.\n\nConstruct, within this concrete instance, a counterexample demonstrating that the greedy area-minimizing choice at the two conjunction subtrees leads to a suboptimal total area on the full tree. Specifically, compute the area gap $\\Delta A$ between:\n- the greedy mapping that minimizes each conjunction subtree independently, and\n- the globally optimal mapping of the entire tree.\n\nYour final answer must be the single real-valued number $\\Delta A$. No units are required.",
            "solution": "The user has provided a valid problem statement.\n\nThe problem asks for the area gap, $\\Delta A$, between a mapping produced by a specific greedy algorithm and a globally optimal mapping for a given Boolean function and standard-cell library. The function is $y = \\overline{(a \\cdot b) + (c \\cdot d)}$.\n\nFirst, we represent the function as a subject tree, as specified. Let $n_1$ be the node computing $a \\cdot b$, $n_2$ be the node computing $c \\cdot d$, $n_3$ be the node computing the disjunction of the outputs of $n_1$ and $n_2$, and $n_4$ be the root node computing the complement of the output of $n_3$.\n\nNext, we analyze the greedy mapping procedure. The algorithm is defined as a bottom-up process where, at each internal node, a locally area-minimizing cover for the subtree rooted at that node is chosen and committed. This commitment forbids any ancestor node from creating an overlapping cover.\n\n1.  **Greedy mapping of the conjunction subtrees:**\n    The process begins at the lowest internal nodes, which are the conjunctions $n_1$ and $n_2$.\n    Consider the subtree rooted at $n_1$, which computes $a \\cdot b$. We need to find its minimum-area cover using the provided library $\\mathcal{L}$.\n    -   **Option 1:** Cover the subtree with a single $AND2$ cell. The area is $\\alpha_{\\text{AND2}} = 4$.\n    -   **Option 2:** Cover the subtree by implementing $a \\cdot b$ as $\\overline{\\overline{a \\cdot b}}$. This composition uses one $NAND2$ cell followed by one $INV$ cell. The total area is $\\alpha_{\\text{NAND2}} + \\alpha_{\\text{INV}} = 2 + 1 = 3$.\n\n    The locally area-minimizing choice is Option 2, with an area of $3$. The greedy algorithm commits to this choice. The same logic applies to the symmetric subtree rooted at node $n_2$, which computes $c \\cdot d$. Its minimal local cover also costs $3$.\n    After this step, the lower portion of the tree is covered by two instances of the ($NAND2+INV$) circuit, with a combined area of $3 + 3 = 6$. The outputs of these committed blocks are the signals $s_1 = a \\cdot b$ and $s_2 = c \\cdot d$.\n\n2.  **Greedy mapping of the remaining tree:**\n    The remaining part of the computation is $y = \\overline{s_1 + s_2}$. This corresponds to nodes $n_3$ (OR) and $n_4$ (INV). Since the subtrees for $s_1$ and $s_2$ are already covered and committed, the mapper can only cover the remaining nodes.\n    -   The disjunction $s_1 + s_2$ (node $n_3$) is covered by an $OR2$ cell, with area $\\alpha_{\\text{OR2}} = 3$.\n    -   The final inversion (node $n_4$) is covered by an $INV$ cell, with area $\\alpha_{\\text{INV}} = 1$.\n    The cost for covering the upper part of the tree is $\\alpha_{\\text{OR2}} + \\alpha_{\\text{INV}} = 3 + 1 = 4$.\n\n3.  **Total Area of the Greedy Mapping ($A_{\\text{greedy}}$):**\n    The total area is the sum of the costs of the committed, non-overlapping covers.\n    $$A_{\\text{greedy}} = (\\alpha_{\\text{NAND2}} + \\alpha_{\\text{INV}}) + (\\alpha_{\\text{NAND2}} + \\alpha_{\\text{INV}}) + (\\alpha_{\\text{OR2}} + \\alpha_{\\text{INV}})$$\n    $$A_{\\text{greedy}} = (2 + 1) + (2 + 1) + (3 + 1) = 3 + 3 + 4 = 10$$\n    This demonstrates the suboptimal nature of the greedy choices. The local optimization at the $AND$ nodes (choosing a cover of area $3$ over $4$) leads to a higher total cost.\n\nNext, we determine the globally optimal mapping by finding the cover with the minimum possible total area for the entire tree. We must consider all valid non-overlapping tilings.\n\n1.  **Covering with a complex gate:**\n    The library contains the cell $AOI22(x,y,u,v) = \\overline{(x \\cdot y) + (u \\cdot v)}$. This cell perfectly matches the entire function $y = \\overline{(a \\cdot b) + (c \\cdot d)}$ with the substitution $x=a, y=b, u=c, v=d$.\n    The area for this cover is $\\alpha_{\\text{AOI22}} = 6$.\n\n2.  **Covering with other combinations:**\n    We must ensure no other combination of cells yields a smaller area.\n    -   The greedy solution has an area of $10$.\n    -   An alternative using $AND2$ gates for the subtrees: $A = \\alpha_{\\text{AND2}} + \\alpha_{\\text{AND2}} + \\alpha_{\\text{OR2}} + \\alpha_{\\text{INV}} = 4 + 4 + 3 + 1 = 12$.\n    -   Using De Morgan's law: $y = \\overline{(a \\cdot b) + (c \\cdot d)} = (\\overline{a \\cdot b}) \\cdot (\\overline{c \\cdot d})$. This can be implemented with two $NAND2$ gates feeding into an $AND2$ gate. The total area is $\\alpha_{\\text{NAND2}} + \\alpha_{\\text{NAND2}} + \\alpha_{\\text{AND2}} = 2 + 2 + 4 = 8$.\n    -   A variation on the De Morgan's law implementation, where the final $AND2$ is implemented as a $NAND2$ followed by an $INV$: $A = \\alpha_{\\text{NAND2}} + \\alpha_{\\text{NAND2}} + (\\alpha_{\\text{NAND2}} + \\alpha_{\\text{INV}}) = 2 + 2 + (2 + 1) = 7$.\n\n3.  **Total Area of the Optimal Mapping ($A_{\\text{opt}}$):**\n    Comparing the total areas of all valid covers found: $6$, $7$, $8$, $10$, and $12$. The minimum area is $6$.\n    Therefore, the globally optimal area is $A_{\\text{opt}} = 6$. This is achieved by using the single $AOI22$ cell.\n\nFinally, we compute the area gap $\\Delta A$ as requested.\n$$\\Delta A = A_{\\text{greedy}} - A_{\\text{opt}}$$\n$$\\Delta A = 10 - 6 = 4$$\nThe greedy strategy, by making locally optimal choices at the conjunction nodes, leads to a solution that is suboptimal by an area of $4$ compared to the true global optimum.",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "Beyond area, timing is a critical cost metric in technology mapping. Accurate delay calculation is essential for making informed decisions in performance-driven synthesis. This problem provides hands-on experience with the industry-standard Non-Linear Delay Model (NLDM), where you will use bilinear interpolation to compute a cell's propagation delay based on its input slew and output load, bridging the gap between abstract logic and physical timing reality .",
            "id": "4304146",
            "problem": "In Electronic Design Automation (EDA), technology mapping for standard-cell libraries relies on accurate delay estimation from library timing models. The Non-Linear Delay Model (NLDM) specifies propagation delay tables as functions of input transition slew and output capacitive load, with interpolation required between tabulated breakpoints. Consider a single timing arc of a standard-cell from input pin to output pin with an NLDM propagation delay table. The input slew breakpoints are $20 \\text{ ps}$, $50 \\text{ ps}$, and $120 \\text{ ps}$, and the output load breakpoints are $2 \\text{ fF}$, $6 \\text{ fF}$, and $12 \\text{ fF}$. The tabulated propagation delays $t_{\\text{pd}}$ at the grid of breakpoints (rows indexed by input slew, columns indexed by output load) are given as follows:\n- For input slew $20 \\text{ ps}$: $t_{\\text{pd}}(20 \\text{ ps}, 2 \\text{ fF}) = 10 \\text{ ps}$, $t_{\\text{pd}}(20 \\text{ ps}, 6 \\text{ fF}) = 18 \\text{ ps}$, $t_{\\text{pd}}(20 \\text{ ps}, 12 \\text{ fF}) = 30 \\text{ ps}$.\n- For input slew $50 \\text{ ps}$: $t_{\\text{pd}}(50 \\text{ ps}, 2 \\text{ fF}) = 16 \\text{ ps}$, $t_{\\text{pd}}(50 \\text{ ps}, 6 \\text{ fF}) = 26 \\text{ ps}$, $t_{\\text{pd}}(50 \\text{ ps}, 12 \\text{ fF}) = 40 \\text{ ps}$.\n- For input slew $120 \\text{ ps}$: $t_{\\text{pd}}(120 \\text{ ps}, 2 \\text{ fF}) = 30 \\text{ ps}$, $t_{\\text{pd}}(120 \\text{ ps}, 6 \\text{ fF}) = 42 \\text{ ps}$, $t_{\\text{pd}}(120 \\text{ ps}, 12 \\text{ fF}) = 58 \\text{ ps}$.\n\nAssume NLDM’s standard piecewise bilinear interpolation scheme between breakpoints. Compute the interpolated propagation delay $t_{\\text{pd}}$ for input slew $s_{\\text{in}} = 35 \\text{ ps}$ and output load $C_{\\text{L}} = 8 \\text{ fF}$. Additionally, verify continuity across table breakpoints by showing that the interpolation reduces to one-dimensional linear interpolation when either $s_{\\text{in}}$ or $C_{\\text{L}}$ coincides with a breakpoint, specifically at $s_{\\text{in}} = 50 \\text{ ps}$ with $C_{\\text{L}} = 8 \\text{ fF}$, and at $C_{\\text{L}} = 6 \\text{ fF}$ with $s_{\\text{in}} = 35 \\text{ ps}$.\n\nRound your final computed $t_{\\text{pd}}$ to four significant figures and express the final delay in picoseconds.",
            "solution": "The problem statement is examined for validity.\n\n**Step 1: Extract Givens**\n- **Domain:** Electronic Design Automation (EDA), Non-Linear Delay Model (NLDM), standard-cell library timing.\n- **Interpolation Method:** Piecewise bilinear interpolation.\n- **Input Slew Breakpoints ($s$):** $20 \\text{ ps}$, $50 \\text{ ps}$, $120 \\text{ ps}$.\n- **Output Load Breakpoints ($C$):** $2 \\text{ fF}$, $6 \\text{ fF}$, $12 \\text{ fF}$.\n- **Tabulated Propagation Delays ($t_{\\text{pd}}(s, C)$ in ps):**\n  - $t_{\\text{pd}}(20, 2) = 10$, $t_{\\text{pd}}(20, 6) = 18$, $t_{\\text{pd}}(20, 12) = 30$.\n  - $t_{\\text{pd}}(50, 2) = 16$, $t_{\\text{pd}}(50, 6) = 26$, $t_{\\text{pd}}(50, 12) = 40$.\n  - $t_{\\text{pd}}(120, 2) = 30$, $t_{\\text{pd}}(120, 6) = 42$, $t_{\\text{pd}}(120, 12) = 58$.\n- **Primary Objective:** Compute $t_{\\text{pd}}$ for $s_{\\text{in}} = 35 \\text{ ps}$ and $C_{\\text{L}} = 8 \\text{ fF}$.\n- **Verification Objectives:**\n  1. Show that interpolation reduces to 1D linear interpolation at $s_{\\text{in}} = 50 \\text{ ps}$ and $C_{\\text{L}} = 8 \\text{ fF}$.\n  2. Show that interpolation reduces to 1D linear interpolation at $C_{\\text{L}} = 6 \\text{ fF}$ and $s_{\\text{in}} = 35 \\text{ ps}$.\n- **Final Answer Format:** Round the computed delay to four significant figures and express in picoseconds.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding:** The problem is scientifically grounded. The NLDM model and the use of bilinear interpolation for timing characterization are standard, fundamental practices in the field of digital integrated circuit design and EDA.\n- **Well-Posedness:** The problem is well-posed. All necessary data points (breakpoints and corresponding delays) are provided. The target point for interpolation lies within the grid of breakpoints, and the interpolation method is explicitly defined. This structure guarantees a unique and meaningful solution. The verification tasks are also clearly specified and mathematically tractable.\n- **Objectivity:** The problem is objective, using precise, technical terminology and providing quantitative data without any subjective or ambiguous statements.\n\n**Step 3: Verdict and Action**\n- **Verdict:** The problem is valid. It is a well-defined and standard exercise in applying numerical methods common in electrical engineering and computer science.\n- **Action:** Proceed with the solution.\n\nThe solution is predicated upon the principle of piecewise bilinear interpolation, which is used to estimate the value of a two-variable function at an arbitrary point within a rectangular grid of known values. The procedure involves consecutive linear interpolations.\n\n**Part 1: Computation of $t_{\\text{pd}}$ for $s_{\\text{in}} = 35 \\text{ ps}$ and $C_{\\text{L}} = 8 \\text{ fF}$**\n\nFirst, we identify the rectangular cell in the lookup table that encloses the target point $(s, C) = (35 \\text{ ps}, 8 \\text{ fF})$.\nThe input slew $s = 35 \\text{ ps}$ is bounded by the breakpoints $s_{lo} = 20 \\text{ ps}$ and $s_{hi} = 50 \\text{ ps}$.\nThe output load $C = 8 \\text{ fF}$ is bounded by the breakpoints $C_{lo} = 6 \\text{ fF}$ and $C_{hi} = 12 \\text{ fF}$.\n\nThe four corner points of this interpolation cell and their corresponding delay values $t_{\\text{pd}}$ are:\n- $t_{11} = t_{\\text{pd}}(s_{lo}, C_{lo}) = t_{\\text{pd}}(20 \\text{ ps}, 6 \\text{ fF}) = 18 \\text{ ps}$\n- $t_{12} = t_{\\text{pd}}(s_{lo}, C_{hi}) = t_{\\text{pd}}(20 \\text{ ps}, 12 \\text{ fF}) = 30 \\text{ ps}$\n- $t_{21} = t_{\\text{pd}}(s_{hi}, C_{lo}) = t_{\\text{pd}}(50 \\text{ ps}, 6 \\text{ fF}) = 26 \\text{ ps}$\n- $t_{22} = t_{\\text{pd}}(s_{hi}, C_{hi}) = t_{\\text{pd}}(50 \\text{ ps}, 12 \\text{ fF}) = 40 \\text{ ps}$\n\nBilinear interpolation can be performed in two steps. First, we perform two linear interpolations along one axis (e.g., the output load axis $C$) for the two bounding values of the other axis ($s_{lo}$ and $s_{hi}$).\n\nStep 1.1: Interpolate along the $C$ axis at $s = s_{lo} = 20 \\text{ ps}$ to find the delay at $C = 8 \\text{ fF}$. Let's denote this intermediate value as $t_{s_{lo}}$.\n$$t_{s_{lo}} = t_{11} + (t_{12} - t_{11}) \\frac{C - C_{lo}}{C_{hi} - C_{lo}}$$\n$$t_{s_{lo}} = 18 \\text{ ps} + (30 \\text{ ps} - 18 \\text{ ps}) \\frac{8 \\text{ fF} - 6 \\text{ fF}}{12 \\text{ fF} - 6 \\text{ fF}} = 18 + 12 \\left( \\frac{2}{6} \\right) = 18 + 4 = 22 \\text{ ps}$$\n\nStep 1.2: Interpolate along the $C$ axis at $s = s_{hi} = 50 \\text{ ps}$ to find the delay at $C = 8 \\text{ fF}$. Let's denote this as $t_{s_{hi}}$.\n$$t_{s_{hi}} = t_{21} + (t_{22} - t_{21}) \\frac{C - C_{lo}}{C_{hi} - C_{lo}}$$\n$$t_{s_{hi}} = 26 \\text{ ps} + (40 \\text{ ps} - 26 \\text{ ps}) \\frac{8 \\text{ fF} - 6 \\text{ fF}}{12 \\text{ fF} - 6 \\text{ fF}} = 26 + 14 \\left( \\frac{2}{6} \\right) = 26 + \\frac{14}{3} \\approx 30.667 \\text{ ps}$$\n\nStep 2: Perform the final linear interpolation along the $s$ axis using the two intermediate delay values $t_{s_{lo}}$ and $t_{s_{hi}}$.\n$$t_{\\text{pd}}(s, C) = t_{s_{lo}} + (t_{s_{hi}} - t_{s_{lo}}) \\frac{s - s_{lo}}{s_{hi} - s_{lo}}$$\n$$t_{\\text{pd}}(35 \\text{ ps}, 8 \\text{ fF}) = 22 \\text{ ps} + \\left( \\frac{92}{3} \\text{ ps} - 22 \\text{ ps} \\right) \\frac{35 \\text{ ps} - 20 \\text{ ps}}{50 \\text{ ps} - 20 \\text{ ps}}$$\n$$t_{\\text{pd}}(35 \\text{ ps}, 8 \\text{ fF}) = 22 + \\left( \\frac{92 - 66}{3} \\right) \\frac{15}{30} = 22 + \\left( \\frac{26}{3} \\right) \\left( \\frac{1}{2} \\right) = 22 + \\frac{13}{3} = \\frac{66+13}{3} = \\frac{79}{3} \\text{ ps}$$\nThe exact value is $26.333... \\text{ ps}$. Rounding to four significant figures gives $26.33 \\text{ ps}$.\n\n**Part 2: Verification of Continuity at $s_{\\text{in}} = 50 \\text{ ps}$ and $C_{\\text{L}} = 8 \\text{ fF}$**\n\nHere, the input slew $s = 50 \\text{ ps}$ coincides with a breakpoint, $s = s_{hi}$. The general bilinear interpolation formula for a point $(s, C)$ in the cell $[s_{lo}, s_{hi}] \\times [C_{lo}, C_{hi}]$ is:\n$$t_{\\text{pd}}(s, C) = t_{11}(1-s_{norm})(1-C_{norm}) + t_{12}(1-s_{norm})C_{norm} + t_{21}s_{norm}(1-C_{norm}) + t_{22}s_{norm}C_{norm}$$\nwhere $s_{norm} = \\frac{s - s_{lo}}{s_{hi} - s_{lo}}$ and $C_{norm} = \\frac{C - C_{lo}}{C_{hi} - C_{lo}}$.\n\nWhen $s = s_{hi} = 50 \\text{ ps}$, the normalized slew coordinate is $s_{norm} = \\frac{50 - 20}{50 - 20} = 1$. The term $(1-s_{norm})$ becomes $0$.\nThe general formula simplifies as follows:\n$$t_{\\text{pd}}(s_{hi}, C) = t_{11}(0)(1-C_{norm}) + t_{12}(0)C_{norm} + t_{21}(1)(1-C_{norm}) + t_{22}(1)C_{norm}$$\n$$t_{\\text{pd}}(s_{hi}, C) = t_{21}(1-C_{norm}) + t_{22}C_{norm} = t_{21} + (t_{22} - t_{21})C_{norm}$$\nSubstituting the definition of $C_{norm}$:\n$$t_{\\text{pd}}(s_{hi}, C) = t_{\\text{pd}}(s_{hi}, C_{lo}) + (t_{\\text{pd}}(s_{hi}, C_{hi}) - t_{\\text{pd}}(s_{hi}, C_{lo})) \\frac{C - C_{lo}}{C_{hi} - C_{lo}}$$\nThis is precisely the formula for one-dimensional linear interpolation along the line of constant slew $s=s_{hi}$. As calculated in Step 1.2, for $C=8 \\text{ fF}$, this gives $t_{\\text{pd}}(50, 8) = \\frac{92}{3} \\text{ ps}$. This confirms that the bilinear interpolation is continuous and reduces to a 1D linear interpolation at the boundary.\n\n**Part 3: Verification of Continuity at $C_{\\text{L}} = 6 \\text{ fF}$ and $s_{\\text{in}} = 35 \\text{ ps}$**\n\nHere, the output load $C = 6 \\text{ fF}$ coincides with a breakpoint, $C = C_{lo}$.\nUsing the same interpolation cell and general formula as before, when $C = C_{lo} = 6 \\text{ fF}$, the normalized load coordinate is $C_{norm} = \\frac{6 - 6}{12 - 6} = 0$. The term $(1-C_{norm})$ becomes $1$.\nThe general formula simplifies as follows:\n$$t_{\\text{pd}}(s, C_{lo}) = t_{11}(1-s_{norm})(1) + t_{12}(1-s_{norm})(0) + t_{21}s_{norm}(1) + t_{22}s_{norm}(0)$$\n$$t_{\\text{pd}}(s, C_{lo}) = t_{11}(1-s_{norm}) + t_{21}s_{norm} = t_{11} + (t_{21} - t_{11})s_{norm}$$\nSubstituting the definition of $s_{norm}$:\n$$t_{\\text{pd}}(s, C_{lo}) = t_{\\text{pd}}(s_{lo}, C_{lo}) + (t_{\\text{pd}}(s_{hi}, C_{lo}) - t_{\\text{pd}}(s_{lo}, C_{lo})) \\frac{s - s_{lo}}{s_{hi} - s_{lo}}$$\nThis is the formula for one-dimensional linear interpolation along the line of constant load $C=C_{lo}$.\nFor $s = 35 \\text{ ps}$:\n$$t_{\\text{pd}}(35, 6) = 18 \\text{ ps} + (26 \\text{ ps} - 18 \\text{ ps}) \\frac{35 \\text{ ps} - 20 \\text{ ps}}{50 \\text{ ps} - 20 \\text{ ps}} = 18 + 8 \\left(\\frac{15}{30}\\right) = 18 + 4 = 22 \\text{ ps}$$\nThis result confirms that the bilinear interpolation also reduces to a 1D linear interpolation along the other boundary of the cell, demonstrating continuity.\n\nThe interpolated propagation delay for $s_{\\text{in}} = 35 \\text{ ps}$ and $C_{\\text{L}} = 8 \\text{ fF}$ is $\\frac{79}{3} \\text{ ps}$. Rounding to four significant figures yields $26.33 \\text{ ps}$.",
            "answer": "$$\n\\boxed{26.33}\n$$"
        }
    ]
}