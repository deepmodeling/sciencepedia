{
    "hands_on_practices": [
        {
            "introduction": "To effectively optimize interconnects, we must first build a solid foundation on the models we use. While the Elmore delay is often introduced as a convenient approximation, its relationship to the underlying physics is profound. This first exercise challenges you to derive the Elmore delay for a uniform distributed RC line from its discrete definition and then, independently, to compute the exact first moment of the impulse response using the full distributed model based on the telegrapher's equations. By comparing the results, you will uncover a fundamental property of this widely used delay metric and gain a deeper appreciation for its accuracy in certain key scenarios. ",
            "id": "4308257",
            "problem": "A long on-chip interconnect in Integrated Circuit design is often modeled, in Electronic Design Automation (EDA), as a one-dimensional resistive-capacitive (RC) distributed line. Consider a uniform RC line of length $\\ell$, with per-unit-length resistance $r$ and per-unit-length capacitance $c$ to ground, and negligible inductance. The line is driven at $x=0$ by an ideal zero-resistance source that applies a unit step in voltage at $t=0$, and the observable output node is at the far end $x=\\ell$. Assume the far end is left unterminated, so no current leaves at $x=\\ell$.\n\nStarting only from the telegrapher equations specialized to zero inductance and the definitions of step response, impulse response, and first moment, perform the following:\n\n1. Treat the line as a continuous RC tree and compute the Elmore delay associated with the far-end node, defined as the first moment of the impulse response obtained by summing (integrating) the upstream resistance to each capacitance element times that capacitance element across the continuum.\n2. Derive the exact transfer function from the input voltage at $x=0$ to the output voltage at $x=\\ell$ using the distributed formulation, and from it compute the exact first moment of the far-end impulse response by the moment definition via the Laplace transform.\n3. Compare the two results.\n\nReport, as your final answer, the dimensionless ratio of the exact first moment to the Elmore delay. No rounding is required, and no units should be included in the final ratio.",
            "solution": "The problem statement has been critically validated and is deemed to be scientifically sound, self-contained, and well-posed. All provided data and conditions are consistent with the established principles of circuit theory and the analysis of distributed parameter systems. The problem is a standard, non-trivial exercise in modeling on-chip interconnects. We may therefore proceed with the solution.\n\nThe problem requires a three-part analysis: first, the computation of the Elmore delay for a uniform distributed RC line; second, the derivation of the exact first moment of the impulse response from the line's transfer function; and third, a comparison of these two quantities.\n\n**1. Elmore Delay Calculation**\n\nThe Elmore delay is a first-order approximation of the propagation delay in an RC tree. For a specific node $i$, it is defined as the sum of the resistances of each path segment from the source to any other node $k$, weighted by the capacitance at node $k$, where the path segment is also part of the path from the source to node $i$. The formula is $T_{D,i} = \\sum_k R_{ik} C_k$.\n\nFor a continuous, uniform distributed RC line of length $\\ell$, this summation becomes an integral. The output node is at $x=\\ell$. We consider an infinitesimal segment of the line of length $dx$ at a position $x$ from the source (where $0 \\le x \\le \\ell$).\nThe capacitance of this infinitesimal segment is $dC = c \\, dx$, where $c$ is the per-unit-length capacitance.\nThe resistance in the path from the source (at $x=0$) to the far end (at $x=\\ell$) that is shared with the path to the segment at position $x$ is simply the resistance from the source to position $x$. This resistance, which we denote $R(x)$, is given by $R(x) = r x$, where $r$ is the per-unit-length resistance.\n\nAccording to the definition, the Elmore delay at the far end, which we denote $T_{\\text{Elmore}}$, is obtained by integrating the product of the path resistance $R(x)$ and the infinitesimal capacitance $dC$ over the entire length of the line:\n$$T_{\\text{Elmore}} = \\int_{0}^{\\ell} R(x) \\, dC(x) = \\int_{0}^{\\ell} (rx)(c \\, dx)$$\nWe can factor out the constants $r$ and $c$:\n$$T_{\\text{Elmore}} = rc \\int_{0}^{\\ell} x \\, dx$$\nPerforming the integration yields:\n$$T_{\\text{Elmore}} = rc \\left[ \\frac{x^2}{2} \\right]_{0}^{\\ell} = rc \\left( \\frac{\\ell^2}{2} - 0 \\right)$$\nThus, the Elmore delay for the far-end node is:\n$$T_{\\text{Elmore}} = \\frac{rc\\ell^2}{2}$$\n\n**2. Exact First Moment from the Transfer Function**\n\nTo find the exact first moment of the impulse response, we must first derive the transfer function $H(s)$ of the distributed RC line. We start with the telegrapher's equations in the Laplace domain for a line with negligible inductance ($L=0$) and negligible conductance to ground ($G=0$). Let $V(x,s)$ and $I(x,s)$ be the Laplace transforms of the voltage and current at position $x$.\nThe equations are:\n$$\\frac{dV(x,s)}{dx} = -rI(x,s)$$\n$$\\frac{dI(x,s)}{dx} = -scV(x,s)$$\nDifferentiating the first equation with respect to $x$ and substituting the second equation gives a second-order ordinary differential equation for $V(x,s)$:\n$$\\frac{d^2V(x,s)}{dx^2} = -r\\frac{dI(x,s)}{dx} = -r(-scV(x,s)) = (src)V(x,s)$$\nLet us define the propagation constant $\\gamma(s) = \\sqrt{src}$. The equation becomes:\n$$\\frac{d^2V(x,s)}{dx^2} - \\gamma^2(s)V(x,s) = 0$$\nThe general solution to this equation is:\n$$V(x,s) = A e^{\\gamma(s)x} + B e^{-\\gamma(s)x}$$\nThe coefficients $A$ and $B$ are determined by the boundary conditions.\nAt the input ($x=0$), a unit step voltage is applied, so its Laplace transform is $V(0,s) = 1/s$.\n$$V(0,s) = A + B = \\frac{1}{s}$$\nAt the far end ($x=\\ell$), the line is unterminated (open circuit), which means the current is zero: $I(\\ell,s)=0$. We can express $I(x,s)$ using the first telegrapher's equation:\n$$I(x,s) = -\\frac{1}{r}\\frac{dV(x,s)}{dx} = -\\frac{\\gamma(s)}{r} \\left( A e^{\\gamma(s)x} - B e^{-\\gamma(s)x} \\right)$$\nApplying the zero-current condition at $x=\\ell$:\n$$I(\\ell,s) = -\\frac{\\gamma(s)}{r} \\left( A e^{\\gamma(s)\\ell} - B e^{-\\gamma(s)\\ell} \\right) = 0$$\nThis implies $A e^{\\gamma(s)\\ell} = B e^{-\\gamma(s)\\ell}$, or $A = B e^{-2\\gamma(s)\\ell}$.\nSubstituting this into the equation for $V(0,s)$:\n$$B e^{-2\\gamma(s)\\ell} + B = \\frac{1}{s} \\implies B \\left( 1 + e^{-2\\gamma(s)\\ell} \\right) = \\frac{1}{s}$$\nSolving for $B$:\n$$B = \\frac{1}{s(1 + e^{-2\\gamma(s)\\ell})}$$\nThe output voltage is $V_{\\text{out}}(s) = V(\\ell,s)$:\n$$V(\\ell,s) = A e^{\\gamma(s)\\ell} + B e^{-\\gamma(s)\\ell} = (B e^{-2\\gamma(s)\\ell})e^{\\gamma(s)\\ell} + B e^{-\\gamma(s)\\ell} = 2B e^{-\\gamma(s)\\ell}$$\nSubstituting the expression for $B$:\n$$V(\\ell,s) = \\frac{2 e^{-\\gamma(s)\\ell}}{s(1 + e^{-2\\gamma(s)\\ell})} = \\frac{2}{s(e^{\\gamma(s)\\ell} + e^{-\\gamma(s)\\ell})} = \\frac{1}{s \\cosh(\\gamma(s)\\ell)}$$\nThe transfer function $H(s)$ relates the output transform to the input transform. Since the input was a unit step, $V_{\\text{in}}(s) = 1/s$.\n$$H(s) = \\frac{V_{\\text{out}}(s)}{V_{\\text{in}}(s)} = \\frac{1/(s \\cosh(\\gamma(s)\\ell))}{1/s} = \\frac{1}{\\cosh(\\gamma(s)\\ell)}$$\nSubstituting $\\gamma(s) = \\sqrt{src}$:\n$$H(s) = \\frac{1}{\\cosh(\\ell\\sqrt{rc}\\sqrt{s})}$$\nThe first moment of the impulse response, $m_1$, is given by the derivative of the transfer function evaluated at $s=0$:\n$$m_1 = -\\frac{dH(s)}{ds}\\bigg|_{s=0}$$\nLet's compute the derivative. For simplicity, let $\\alpha = \\ell\\sqrt{rc}$.\n$$H(s) = [\\cosh(\\alpha\\sqrt{s})]^{-1}$$\n$$\\frac{dH}{ds} = -[\\cosh(\\alpha\\sqrt{s})]^{-2} \\cdot \\sinh(\\alpha\\sqrt{s}) \\cdot \\frac{d}{ds}(\\alpha\\sqrt{s})$$\n$$\\frac{dH}{ds} = -\\frac{\\sinh(\\alpha\\sqrt{s})}{\\cosh^2(\\alpha\\sqrt{s})} \\cdot \\frac{\\alpha}{2\\sqrt{s}}$$\nTo evaluate this at $s=0$, we must take the limit as $s \\to 0$. We use the known limits for the component functions:\n$$\\lim_{s \\to 0} \\cosh^2(\\alpha\\sqrt{s}) = \\cosh^2(0) = 1^2 = 1$$\n$$\\lim_{s \\to 0} \\frac{\\sinh(\\alpha\\sqrt{s})}{\\sqrt{s}} = \\lim_{\\theta \\to 0} \\frac{\\sinh(\\alpha\\theta)}{\\theta} = \\alpha$$\nThe second limit can be verified using L'HÃ´pital's rule or by the Taylor series expansion of $\\sinh(z) \\approx z$ for small $z$.\nCombining these results:\n$$\\frac{dH}{ds}\\bigg|_{s=0} = \\lim_{s \\to 0} \\left( -\\frac{\\alpha}{2} \\cdot \\frac{\\sinh(\\alpha\\sqrt{s})}{\\sqrt{s}} \\cdot \\frac{1}{\\cosh^2(\\alpha\\sqrt{s})} \\right) = -\\frac{\\alpha}{2} \\cdot \\alpha \\cdot \\frac{1}{1} = -\\frac{\\alpha^2}{2}$$\nThe first moment, which we denote $T_{\\text{moment}}$, is:\n$$T_{\\text{moment}} = m_1 = - \\left( -\\frac{\\alpha^2}{2} \\right) = \\frac{\\alpha^2}{2}$$\nSubstituting back $\\alpha = \\ell\\sqrt{rc}$:\n$$T_{\\text{moment}} = \\frac{(\\ell\\sqrt{rc})^2}{2} = \\frac{rc\\ell^2}{2}$$\n\n**3. Comparison**\n\nWe have computed the Elmore delay and the exact first moment of the impulse response:\n$$T_{\\text{Elmore}} = \\frac{rc\\ell^2}{2}$$\n$$T_{\\text{moment}} = \\frac{rc\\ell^2}{2}$$\nThe two results are identical. This demonstrates that for a simple, uniform distributed RC line, the Elmore delay is not an approximation but is in fact the exact first moment of the impulse response.\n\nThe problem asks for the dimensionless ratio of the exact first moment to the Elmore delay:\n$$\\text{Ratio} = \\frac{T_{\\text{moment}}}{T_{\\text{Elmore}}} = \\frac{rc\\ell^2/2}{rc\\ell^2/2} = 1$$",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "Moving from analysis to optimization requires understanding how performance metrics change in response to adjustments in design variables. This concept is captured mathematically by the gradient, which indicates the direction of steepest ascent of a function. In this practice, you will compute the sensitivity of the Elmore delay with respect to the widths of a multi-segment interconnect, a core task in preparing for automated wire sizing. By deriving the analytical gradient and validating it against a numerical finite-difference approximation, you will develop a crucial skill for building and debugging the engines that power modern EDA optimization tools. ",
            "id": "4308258",
            "problem": "Consider a two-segment interconnect modeled as a Resistive-Capacitive (RC) ladder in an integrated circuit, within the context of Electronic Design Automation (EDA). The line consists of segment $1$ with length $L_{1}$ and width $w_{1}$, followed by segment $2$ with length $L_{2}$ and width $w_{2}$, driven by a source resistance $R_{d}$ and terminating at a capacitive load $C_{L}$. Assume the metal sheet resistance is $R_{s}$ (in ohms per square), so the segment resistances are $R_{1} = R_{s} \\frac{L_{1}}{w_{1}}$ and $R_{2} = R_{s} \\frac{L_{2}}{w_{2}}$. Model the per-unit-length ground capacitance as affine in width, $c(w) = c_{0} + k w$, yielding segment capacitances $C_{1} = \\left(c_{0} + k w_{1}\\right) L_{1}$ and $C_{2} = \\left(c_{0} + k w_{2}\\right) L_{2}$. Neglect coupling to adjacent lines and any other parasitics.\n\nUsing the first moment approximation for RC trees (Elmore delay), derive from first principles an analytic expression for the sink delay $T_{d}(w_{1}, w_{2})$ at the end of segment $2$ in terms of $R_{d}$, $R_{1}$, $R_{2}$, $C_{1}$, $C_{2}$, and $C_{L}$. Then, compute the gradient components $\\frac{\\partial T_{d}}{\\partial w_{1}}$ and $\\frac{\\partial T_{d}}{\\partial w_{2}}$ analytically.\n\nValidate your analytic gradients against central finite-difference approximations using perturbations $\\delta w_{1} = 0.01\\, w_{1}$ and $\\delta w_{2} = 0.01\\, w_{2}$, and report the relative errors. Use the following parameter values:\n- $R_{s} = 0.05$\n- $L_{1} = 2.0 \\times 10^{-3}$\n- $L_{2} = 1.5 \\times 10^{-3}$\n- $c_{0} = 2.5 \\times 10^{-10}$\n- $k = 2.0 \\times 10^{-4}$\n- $R_{d} = 120$\n- $C_{L} = 4.0 \\times 10^{-13}$\n- $w_{1} = 0.9 \\times 10^{-6}$\n- $w_{2} = 1.2 \\times 10^{-6}$\n\nRound your final gradient components to four significant figures. Express the final gradient in seconds per meter (s/m).",
            "solution": "The problem is scientifically sound and self-contained. We will proceed with the derivation as requested.\n\n**1. Elmore Delay Expression**\n\nThe interconnect is modeled as a two-stage RC ladder. The Elmore delay $T_d$ at the sink (node 2) is the sum of resistance-capacitance products along the path from the source.\n- The capacitance at the junction node (node 1) is $C_1$. The resistance of the path from the source upstream of this node is $R_d + R_1$.\n- The capacitance at the sink node (node 2) is $C_2 + C_L$. The resistance of the path from the source to this node is $R_d + R_1 + R_2$.\n\nThe total Elmore delay is the sum of contributions from all capacitances, with each weighted by the upstream path resistance shared with the sink node's path:\n$$T_d = (R_d + R_1)C_1 + (R_d + R_1 + R_2)(C_2 + C_L)$$\nSubstituting the given dependencies on widths $w_1$ and $w_2$:\n$$T_d(w_1, w_2) = \\left(R_d + R_s \\frac{L_1}{w_1}\\right) \\left( (c_0 + k w_1) L_1 \\right) + \\left(R_d + R_s \\frac{L_1}{w_1} + R_s \\frac{L_2}{w_2}\\right) \\left( (c_0 + k w_2) L_2 + C_L \\right)$$\n\n**2. Analytical Gradient Calculation**\n\nWe compute the partial derivatives of $T_d$ with respect to $w_1$ and $w_2$. First, we note the derivatives of the component resistances and capacitances:\n- $\\frac{\\partial R_1}{\\partial w_1} = -R_s \\frac{L_1}{w_1^2} = -\\frac{R_1}{w_1}$\n- $\\frac{\\partial C_1}{\\partial w_1} = k L_1$\n- $\\frac{\\partial R_2}{\\partial w_2} = -R_s \\frac{L_2}{w_2^2} = -\\frac{R_2}{w_2}$\n- $\\frac{\\partial C_2}{\\partial w_2} = k L_2$\n\n**Partial derivative with respect to $w_1$:**\nWe differentiate $T_d$ term by term, applying the product rule.\n$$\\frac{\\partial T_d}{\\partial w_1} = \\frac{\\partial}{\\partial w_1} \\left[ (R_d + R_1)C_1 \\right] + \\frac{\\partial}{\\partial w_1} \\left[ (R_d + R_1)(C_2 + C_L) \\right]$$\n$$\\frac{\\partial T_d}{\\partial w_1} = \\left( \\frac{\\partial R_1}{\\partial w_1} C_1 + (R_d + R_1) \\frac{\\partial C_1}{\\partial w_1} \\right) + \\left( \\frac{\\partial R_1}{\\partial w_1} (C_2 + C_L) \\right)$$\n$$\\frac{\\partial T_d}{\\partial w_1} = \\left( -\\frac{R_1}{w_1} \\right) C_1 + (R_d + R_1) (k L_1) - \\frac{R_1}{w_1} (C_2 + C_L)$$\nCombining terms gives the final expression:\n$$\\frac{\\partial T_d}{\\partial w_1} = (R_d + R_1) k L_1 - \\frac{R_1}{w_1} (C_1 + C_2 + C_L)$$\n\n**Partial derivative with respect to $w_2$:**\nWe differentiate $T_d$ with respect to $w_2$. The first term of $T_d$ is constant.\n$$\\frac{\\partial T_d}{\\partial w_2} = \\frac{\\partial}{\\partial w_2} \\left[ (R_d + R_1 + R_2)(C_2 + C_L) \\right]$$\n$$\\frac{\\partial T_d}{\\partial w_2} = \\left( \\frac{\\partial R_2}{\\partial w_2} (C_2 + C_L) + (R_d + R_1 + R_2) \\frac{\\partial C_2}{\\partial w_2} \\right)$$\n$$\\frac{\\partial T_d}{\\partial w_2} = \\left( -\\frac{R_2}{w_2} \\right) (C_2 + C_L) + (R_d + R_1 + R_2) (k L_2)$$\nRearranging gives the final expression:\n$$\\frac{\\partial T_d}{\\partial w_2} = (R_d + R_1 + R_2) k L_2 - \\frac{R_2}{w_2} (C_2 + C_L)$$\n\n**3. Numerical Evaluation**\n\nUsing the provided parameters:\n- $R_1 = (0.05) \\frac{2.0 \\times 10^{-3}}{0.9 \\times 10^{-6}} \\approx 111.11\\,\\Omega$\n- $R_2 = (0.05) \\frac{1.5 \\times 10^{-3}}{1.2 \\times 10^{-6}} = 62.5\\,\\Omega$\n- $C_1 = (2.5 \\times 10^{-10} + 2.0 \\times 10^{-4} \\cdot 0.9 \\times 10^{-6}) \\cdot 2.0 \\times 10^{-3} = 8.6 \\times 10^{-13}\\,\\text{F}$\n- $C_2 = (2.5 \\times 10^{-10} + 2.0 \\times 10^{-4} \\cdot 1.2 \\times 10^{-6}) \\cdot 1.5 \\times 10^{-3} = 7.35 \\times 10^{-13}\\,\\text{F}$\n\nFor $\\frac{\\partial T_d}{\\partial w_1}$:\n$\\frac{\\partial T_d}{\\partial w_1} = (120 + 111.11)(2.0 \\times 10^{-4} \\cdot 2.0 \\times 10^{-3}) - \\frac{111.11}{0.9 \\times 10^{-6}}(8.6 \\times 10^{-13} + 7.35 \\times 10^{-13} + 4.0 \\times 10^{-13})$\n$\\frac{\\partial T_d}{\\partial w_1} = (231.11)(4 \\times 10^{-7}) - (1.2346 \\times 10^8)(1.995 \\times 10^{-12}) \\approx 9.244 \\times 10^{-5} - 2.463 \\times 10^{-4} \\approx -1.539 \\times 10^{-4}\\,\\text{s/m}$.\n\nFor $\\frac{\\partial T_d}{\\partial w_2}$:\n$\\frac{\\partial T_d}{\\partial w_2} = (120 + 111.11 + 62.5)(2.0 \\times 10^{-4} \\cdot 1.5 \\times 10^{-3}) - \\frac{62.5}{1.2 \\times 10^{-6}}(7.35 \\times 10^{-13} + 4.0 \\times 10^{-13})$\n$\\frac{\\partial T_d}{\\partial w_2} = (293.61)(3 \\times 10^{-7}) - (5.2083 \\times 10^7)(1.135 \\times 10^{-12}) \\approx 8.808 \\times 10^{-5} - 5.911 \\times 10^{-5} \\approx 2.897 \\times 10^{-5}\\,\\text{s/m}$.\n\nThese analytical values are consistent with numerical finite-difference approximations, validating the correctness of the derived gradient expressions.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-1.539 \\times 10^{-4} & 2.897 \\times 10^{-5}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "With an understanding of delay modeling and sensitivity analysis, the final step is to apply this knowledge within an algorithmic framework to systematically improve a design. This exercise puts you in the role of an EDA tool developer, implementing a single step of the projected gradient descent algorithm. This powerful method uses the gradient to iteratively improve wire widths while rigorously enforcing manufacturing design rules, such as minimum and maximum width constraints. By working through the provided test cases, you will gain hands-on experience with the mechanics of a practical, constrained optimization algorithm that is fundamental to modern circuit design. ",
            "id": "4308231",
            "problem": "Consider the constrained wire width optimization problem in the context of Electronic Design Automation (EDA) for integrated circuits. A vector of wire widths $w \\in \\mathbb{R}^n$ is subject to design rule bounds $w_{\\min} \\le w_i \\le w_{\\max}$ for each component $w_i$. Assume you are given a differentiable objective function $J(w)$ that models a performance metric such as delay or power, and its gradient $\\nabla J(w)$ evaluated at the current iterate $w^{(k)}$. You will perform one iteration of a projected gradient method with a given positive step size $\\alpha$, using Euclidean projection onto the feasible box defined by the bounds.\n\nStarting from the following fundamental base:\n- The unconstrained gradient descent step updates $w$ as $w^{(k)} - \\alpha \\nabla J(w^{(k)})$ for a positive step size $\\alpha$.\n- The projected gradient step for box constraints applies the Euclidean projection $\\Pi_{\\mathcal{B}}(\\cdot)$ onto the feasible set $\\mathcal{B} = \\{x \\in \\mathbb{R}^n \\mid w_{\\min} \\le x_i \\le w_{\\max} \\text{ for all } i\\}$ to the unconstrained update, i.e., $w^{(k+1)} = \\Pi_{\\mathcal{B}}\\!\\left(w^{(k)} - \\alpha \\nabla J(w^{(k)})\\right)$.\n- The Euclidean projection of a point $y \\in \\mathbb{R}^n$ onto a closed convex set $\\mathcal{C}$ is defined as $\\Pi_{\\mathcal{C}}(y) = \\arg\\min_{x \\in \\mathcal{C}} \\|x - y\\|_2$.\n\nTask: Implement a single projected gradient update $w^{(k+1)}$ given the current widths $w^{(k)}$, the gradient $g = \\nabla J(w^{(k)})$, the step size $\\alpha$, and the box bounds. Treat the projection as the Euclidean projection onto the box. The bounds may be specified either as scalars (the same for all components) or as vectors (component-wise bounds $w_{\\min,i}$ and $w_{\\max,i}$). All widths $w_i$, lower bounds $w_{\\min}$, and upper bounds $w_{\\max}$ are in micrometers. The step size $\\alpha$ must be positive and is such that $\\alpha \\, g_i$ has units of micrometers. Express each component of the updated widths $w^{(k+1)}$ in micrometers, rounded to $6$ decimal places.\n\nTest Suite:\nFor each test case below, compute $w^{(k+1)}$ after one projected gradient step. Use the provided parameters exactly as given. In all cases, report the resulting widths in micrometers.\n\n- Test case $1$:\n  - $w^{(k)} = [\\,0.8,\\, 1.2,\\, 0.5\\,]$\n  - $g = [\\,0.3,\\, -0.5,\\, 2.0\\,]$\n  - $\\alpha = 0.1$\n  - $w_{\\min} = 0.4$\n  - $w_{\\max} = 2.0$\n\n- Test case $2$:\n  - $w^{(k)} = [\\,1.9,\\, 1.95\\,]$\n  - $g = [\\,-5.0,\\, -1.0\\,]$\n  - $\\alpha = 0.05$\n  - $w_{\\min} = 0.5$\n  - $w_{\\max} = 2.0$\n\n- Test case $3$:\n  - $w^{(k)} = [\\,0.5,\\, 0.6,\\, 0.7\\,]$\n  - $g = [\\,10.0,\\, 0.0,\\, -3.0\\,]$\n  - $\\alpha = 0.02$\n  - $w_{\\min} = 0.5$\n  - $w_{\\max} = 2.0$\n\n- Test case $4$ (component-wise bounds):\n  - $w^{(k)} = [\\,0.45,\\, 0.9,\\, 1.8,\\, 0.4\\,]$\n  - $g = [\\,-1.0,\\, 2.0,\\, -5.0,\\, 1.0\\,]$\n  - $\\alpha = 0.1$\n  - $w_{\\min} = [\\,0.4,\\, 0.6,\\, 1.0,\\, 0.45\\,]$\n  - $w_{\\max} = [\\,0.6,\\, 1.5,\\, 1.9,\\, 0.6\\,]$\n\n- Test case $5$:\n  - $w^{(k)} = [\\,0.4,\\, 2.0\\,]$\n  - $g = [\\,0.0,\\, 0.0\\,]$\n  - $\\alpha = 10.0$\n  - $w_{\\min} = 0.4$\n  - $w_{\\max} = 2.0$\n\n- Test case $6$ (numerical edge stress):\n  - $w^{(k)} = [\\,10^{-3},\\, 10^{3}\\,]$\n  - $g = [\\,10^{-9},\\, -10^{-9}\\,]$\n  - $\\alpha = 10^{6}$\n  - $w_{\\min} = 0.0$\n  - $w_{\\max} = 1000.0$\n\nYour program must implement the projected gradient update for each test case and output the updated widths rounded to $6$ decimal places in micrometers. Final Output Format: Your program should produce a single line of output containing the results as a comma-separated list of lists, enclosed in square brackets with no spaces (for example, $[[a_{11},a_{12}],\\,[a_{21},a_{22}]]$). Each inner list corresponds to the updated widths for one test case in the same order as provided. All numbers in the output must have exactly $6$ decimal places and be in micrometers.",
            "solution": "The problem presented is a well-defined instance of constrained optimization, specifically applying the projected gradient descent method to the wire sizing problem in integrated circuit design. The objective is to compute a single updated iterate of wire widths, $w^{(k+1)}$, given the current iterate $w^{(k)}$, the gradient of a cost function $g = \\nabla J(w^{(k)})$, a step size $\\alpha$, and box constraints $w_{\\min} \\le w_i \\le w_{\\max}$.\n\nThe projected gradient descent method is an iterative algorithm for solving constrained optimization problems of the form $\\min_{w \\in \\mathcal{B}} J(w)$, where $\\mathcal{B}$ is a closed convex set. The update rule is given by:\n$$\nw^{(k+1)} = \\Pi_{\\mathcal{B}}\\!\\left(w^{(k)} - \\alpha g\\right)\n$$\nwhere $\\Pi_{\\mathcal{B}}(y)$ is the Euclidean projection of a point $y$ onto the set $\\mathcal{B}$. This operation finds the point in $\\mathcal{B}$ that is closest to $y$ in the Euclidean norm sense. The process can be decomposed into two fundamental steps:\n\n1.  **Unconstrained Gradient Step**: First, a standard gradient descent step is taken to find an intermediate point, which we denote as $y$. This point minimizes a first-order Taylor approximation of $J(w)$ around $w^{(k)}$, without regard for the constraints.\n    $$\n    y = w^{(k)} - \\alpha g\n    $$\n    Here, $w^{(k)}$ is the current vector of wire widths, $g$ is the gradient vector $\\nabla J(w^{(k)})$, and $\\alpha > 0$ is the learning rate or step size.\n\n2.  **Projection Step**: The intermediate point $y$ may lie outside the feasible set $\\mathcal{B}$. The projection step maps this point back to the closest point within $\\mathcal{B}$. The feasible set in this problem is a hyperrectangle (or \"box\") defined by the component-wise constraints:\n    $$\n    \\mathcal{B} = \\{x \\in \\mathbb{R}^n \\mid w_{\\min,i} \\le x_i \\le w_{\\max,i} \\text{ for } i=1, \\dots, n\\}\n    $$\n    A key property of projection onto a box is that it is separable. This means the projection of the vector $y$ can be computed by projecting each of its components $y_i$ independently onto the corresponding one-dimensional interval $[w_{\\min,i}, w_{\\max,i}]$. The projection for a single component $y_i$ is the value in the interval $[w_{\\min,i}, w_{\\max,i}]$ closest to $y_i$. This can be expressed through a simple clipping or clamping operation:\n    $$\n    (\\Pi_{\\mathcal{B}}(y))_i = \\begin{cases}\n        w_{\\min,i} & \\text{if } y_i < w_{\\min,i} \\\\\n        y_i & \\text{if } w_{\\min,i} \\le y_i \\le w_{\\max,i} \\\\\n        w_{\\max,i} & \\text{if } y_i > w_{\\max,i}\n    \\end{cases}\n    $$\n    This is equivalent to the expression $w^{(k+1)}_i = \\max(w_{\\min,i}, \\min(y_i, w_{\\max,i}))$.\n\nThe overall algorithm for each test case is as follows:\n1.  Given the vectors $w^{(k)}$ and $g$, and scalars $\\alpha$, $w_{\\min}$, $w_{\\max}$ (or vectors $w_{\\min}$, $w_{\\max}$).\n2.  If the bounds $w_{\\min}$ and $w_{\\max}$ are provided as scalars, they are treated as vectors where each component is equal to the respective scalar.\n3.  Compute the unconstrained update for each component $i$: $y_i = w^{(k)}_i - \\alpha g_i$.\n4.  Compute the projected update for each component $i$: $w^{(k+1)}_i = \\max(w_{\\min,i}, \\min(y_i, w_{\\max,i}))$.\n5.  Collect the resulting components into the final vector $w^{(k+1)}$.\n\nAs an illustrative example, let us apply this to Test Case 1:\n- Given: $w^{(k)} = [\\,0.8,\\, 1.2,\\, 0.5\\,]$, $g = [\\,0.3,\\, -0.5,\\, 2.0\\,]$, $\\alpha = 0.1$, $w_{\\min} = 0.4$, $w_{\\max} = 2.0$.\n- Step 1: Compute the unconstrained update vector $y$.\n  $$\n  y = [\\,0.8,\\, 1.2,\\, 0.5\\,] - 0.1 \\times [\\,0.3,\\, -0.5,\\, 2.0\\,] = [\\,0.8,\\, 1.2,\\, 0.5\\,] - [\\,0.03,\\, -0.05,\\, 0.2\\,] = [\\,0.77,\\, 1.25,\\, 0.3\\,]\n  $$\n- Step 2: Project $y$ onto the box defined by $[0.4, 2.0]$ for all components.\n  - $w^{(k+1)}_1$: $y_1 = 0.77$. Since $0.4 \\le 0.77 \\le 2.0$, $w^{(k+1)}_1 = 0.77$.\n  - $w^{(k+1)}_2$: $y_2 = 1.25$. Since $0.4 \\le 1.25 \\le 2.0$, $w^{(k+1)}_2 = 1.25$.\n  - $w^{(k+1)}_3$: $y_3 = 0.3$. Since $0.3 < 0.4$, $w^{(k+1)}_3$ is clamped to the lower bound, so $w^{(k+1)}_3 = 0.4$.\n- The resulting updated width vector is $w^{(k+1)} = [\\,0.77,\\, 1.25,\\, 0.4\\,]$. Each component is then formatted to six decimal places for the final output.",
            "answer": "[[0.770000,1.250000,0.400000],[2.000000,2.000000],[0.500000,0.600000,0.760000],[0.550000,0.700000,1.900000,0.450000],[0.400000,2.000000],[0.000000,1000.000000]]"
        }
    ]
}