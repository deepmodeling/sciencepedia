{
    "hands_on_practices": [
        {
            "introduction": "在静态时序分析（STA）中，最基本的任务是精确计算信号在组合逻辑路径上的传播时间。本练习将指导您完成数据到达时间的分步计算，重点关注单元的传播延迟和输出转换时间（slew）如何受到输入转换时间和负载电容的影响。通过使用标准的线性化延迟模型，您将掌握进行更复杂时序分析所需的基础技能。",
            "id": "4284051",
            "problem": "在集成电路的多角（multi-corner）多模（multi-mode）静态时序分析中，数据到达某个端点的时间是通过在组合路径上传播时序来确定的，同时需要考虑每个单元的传播延迟和输出转换速率（slew）对其输入转换速率和输出电容负载的依赖性。考虑一个同步流水线路径，在功能模式下，针对 slow-slow（慢-慢）、低电压、高温角（记为 SS，电源电压为 $0.72$ V，温度为 $125^\\circ$C）进行建立时间（setup timing）分析，该角被指定为本设计的建立时间最差（setup-worst）角。该路径从发射寄存器的输出端到捕获寄存器的输入端，经过三个组合逻辑级：\n1. 发射寄存器 $\\text{FF}_\\text{L}$ 的输出 $Q$，\n2. $\\text{INV\\_X2}$，\n3. $\\text{NAND2\\_X1}$，其非控制输入保持为逻辑高电平，以及\n4. $\\text{BUF\\_X4}$，\n最终到达捕获寄存器 $\\text{FF}_\\text{C}$ 的数据输入端 $D$。\n\n在此角下，单元库以围绕相关工作点的线性化非线性延迟模型（NLDM）形式提供。对于每个驱动单元 $g$，传播延迟和输出转换速率被建模为输入转换速率和输出电容负载的仿射函数：\n- 传播延迟：$d_g = d_{0,g} + k_{s,g}\\,S_{\\text{in}} + k_{c,g}\\,C_{\\text{load}}$，\n- 输出转换速率：$S_{\\text{out},g} = s_{0,g} + m_{s,g}\\,S_{\\text{in}} + m_{c,g}\\,C_{\\text{load}}$，\n其中 $S_{\\text{in}}$ 和 $S_{\\text{out},g}$ 的单位是 ns，$C_{\\text{load}}$ 的单位是 fF。对于发射寄存器 $\\text{FF}_\\text{L}$，时钟到Q端延迟和 $Q$ 端输出转换速率由以下公式给出：\n- 时钟到Q端延迟：$d_{\\text{CQ}} = d_{0,\\text{FF}} + k_{c,\\text{FF}}\\,C_{\\text{load,FF}}$，\n- $Q$ 端输出转换速率：$S_{Q} = s_{0,\\text{FF}} + m_{c,\\text{FF}}\\,C_{\\text{load,FF}}$。\n\n使用 SS 角下的以下单元参数：\n- $\\text{FF}_\\text{L}$: $d_{0,\\text{FF}} = 0.080$ ns, $k_{c,\\text{FF}} = 0.0005$ ns/fF, $s_{0,\\text{FF}} = 0.040$ ns, $m_{c,\\text{FF}} = 0.0012$ ns/fF.\n- $\\text{INV\\_X2}$: $d_{0} = 0.020$ ns, $k_{s} = 0.20$, $k_{c} = 0.0010$ ns/fF, $s_{0} = 0.015$ ns, $m_{s} = 0.30$, $m_{c} = 0.0025$ ns/fF.\n- $\\text{NAND2\\_X1}$: $d_{0} = 0.030$ ns, $k_{s} = 0.25$, $k_{c} = 0.0015$ ns/fF, $s_{0} = 0.020$ ns, $m_{s} = 0.35$, $m_{c} = 0.0030$ ns/fF.\n- $\\text{BUF\\_X4}$: $d_{0} = 0.018$ ns, $k_{s} = 0.15$, $k_{c} = 0.0008$ ns/fF, $s_{0} = 0.012$ ns, $m_{s} = 0.25$, $m_{c} = 0.0018$ ns/fF.\n\n接收引脚的电容负载如下：\n- $\\text{INV\\_X2}$ 输入引脚电容：$2.5$ fF,\n- $\\text{NAND2\\_X1}$ 切换输入的输入引脚电容：$3.0$ fF,\n- $\\text{BUF\\_X4}$ 输入引脚电容：$4.0$ fF,\n- $\\text{FF}_\\text{C}$ 数据输入 $D$ 引脚电容：$2.0$ fF.\n\n驱动引脚和接收引脚之间的互连线被建模为集总电容，加到驱动器所见的负载上，其值如下：\n- $\\text{FF}_\\text{L}.Q$ 和 $\\text{INV\\_X2}.A$ 之间：$C_{0} = 6.0$ fF,\n- $\\text{INV\\_X2}.Y$ 和 $\\text{NAND2\\_X1}.A$ 之间：$C_{1} = 7.0$ fF,\n- $\\text{NAND2\\_X1}.Y$ 和 $\\text{BUF\\_X4}.A$ 之间：$C_{2} = 8.0$ fF,\n- $\\text{BUF\\_X4}.Y$ 和 $\\text{FF}_\\text{C}.D$ 之间：$C_{3} = 10.0$ fF.\n\n假设和建模指令：\n- 将所有互连线视为纯电容性，没有显式的电阻延迟；驱动器电阻效应已由上述线性化 NLDM 系数隐式捕获。\n- 对 $\\text{NAND2\\_X1}$ 使用单输入切换，其非切换输入处于非控制逻辑电平。\n- 每个驱动器所见的负载等于其直接扇出的输入引脚电容之和加上该网络上的互连电容。\n- 使用为每个驱动器给出的线性转换速率模型逐级传播转换速率，将前一级的输出转换速率用作下一级的输入转换速率。\n- $\\text{FF}_\\text{L}$ 的发射时钟沿出现在时间 $t = 0$，您应测量相对于此时钟沿的数据到达 $\\text{FF}_\\text{C}.D$ 的时间。\n\n任务：在上述假设下，计算在功能模式下 SS 角的数据到达 $\\text{FF}_\\text{C}.D$ 的时间。明确说明您所做的关于转换速率和负载如何逐级传播的假设。将最终数值答案四舍五入到四位有效数字，并以 ns 为单位表示。您的最终答案必须是一个实数。",
            "solution": "### 步骤 1：提取已知条件\n**路径信息：**\n- 为建立时间分析的同步流水线路径。\n- 角：slow-slow (SS)，低电压，高温。\n- 电源电压：$0.72$ V。\n- 温度：$125^\\circ$C。\n- 模式：功能模式。\n- 路径：发射寄存器 $\\text{FF}_\\text{L}$ 输出 $Q$ $\\rightarrow$ $\\text{INV\\_X2}$ $\\rightarrow$ $\\text{NAND2\\_X1}$ (非控制输入保持高电平) $\\rightarrow$ $\\text{BUF\\_X4}$ $\\rightarrow$ 捕获寄存器 $\\text{FF}_\\text{C}$ 输入 $D$。\n\n**NLDM 模型方程：**\n- 传播延迟：$d_g = d_{0,g} + k_{s,g}\\,S_{\\text{in}} + k_{c,g}\\,C_{\\text{load}}$\n- 输出转换速率：$S_{\\text{out},g} = s_{0,g} + m_{s,g}\\,S_{\\text{in}} + m_{c,g}\\,C_{\\text{load}}$\n- 时钟到Q端延迟：$d_{\\text{CQ}} = d_{0,\\text{FF}} + k_{c,\\text{FF}}\\,C_{\\text{load,FF}}$\n- $Q$ 端输出转换速率：$S_{Q} = s_{0,\\text{FF}} + m_{c,\\text{FF}}\\,C_{\\text{load,FF}}$\n\n**SS 角下的单元参数：**\n- $\\text{FF}_\\text{L}$: $d_{0,\\text{FF}} = 0.080$ ns, $k_{c,\\text{FF}} = 0.0005$ ns/fF, $s_{0,\\text{FF}} = 0.040$ ns, $m_{c,\\text{FF}} = 0.0012$ ns/fF.\n- $\\text{INV\\_X2}$: $d_{0} = 0.020$ ns, $k_{s} = 0.20$, $k_{c} = 0.0010$ ns/fF, $s_{0} = 0.015$ ns, $m_{s} = 0.30$, $m_{c} = 0.0025$ ns/fF.\n- $\\text{NAND2\\_X1}$: $d_{0} = 0.030$ ns, $k_{s} = 0.25$, $k_{c} = 0.0015$ ns/fF, $s_{0} = 0.020$ ns, $m_{s} = 0.35$, $m_{c} = 0.0030$ ns/fF.\n- $\\text{BUF\\_X4}$: $d_{0} = 0.018$ ns, $k_{s} = 0.15$, $k_{c} = 0.0008$ ns/fF, $s_{0} = 0.012$ ns, $m_{s} = 0.25$, $m_{c} = 0.0018$ ns/fF.\n\n**电容负载：**\n- $\\text{INV\\_X2}$ 输入引脚电容：$2.5$ fF。\n- $\\text{NAND2\\_X1}$ 输入引脚电容：$3.0$ fF。\n- $\\text{BUF\\_X4}$ 输入引脚电容：$4.0$ fF。\n- $\\text{FF}_\\text{C}$ 数据输入 $D$ 引脚电容：$2.0$ fF。\n- $\\text{FF}_\\text{L}.Q$ 和 $\\text{INV\\_X2}.A$ 之间的互连线：$C_{0} = 6.0$ fF。\n- $\\text{INV\\_X2}.Y$ 和 $\\text{NAND2\\_X1}.A$ 之间的互连线：$C_{1} = 7.0$ fF。\n- $\\text{NAND2\\_X1}.Y$ 和 $\\text{BUF\\_X4}.A$ 之间的互连线：$C_{2} = 8.0$ fF。\n- $\\text{BUF\\_X4}.Y$ 和 $\\text{FF}_\\text{C}.D$ 之间的互连线：$C_{3} = 10.0$ fF。\n\n**假设和指令：**\n- 互连线是纯电容性的。\n- $\\text{NAND2\\_X1}$ 为单输入切换。\n- 驱动器所见的负载 = 输入引脚电容之和 + 互连电容。\n- 转换速率逐级传播。\n- 发射时钟沿在 $t = 0$。\n- 最终答案四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n所提出的问题是数字集成电路静态时序分析（STA）中的一个标准练习。\n1.  **科学依据**：该问题在数字电路时序原理方面有充分的依据。非线性延迟模型（NLDM），此处以线性化仿射形式呈现，是工业EDA工具中用于建模单元延迟和输出转换时间的广泛使用的标准。参数和路径结构对于现代技术节点是符合实际的。\n2.  **适定性**：该问题是完全指定的。它提供了所有必需的单元库数据（延迟和转换速率系数）、电容负载（引脚和互连线）以及确切的逻辑路径。目标——计算数据到达时间——是明确的，并且所提供的信息足以推导出唯一的数值解。\n3.  **客观性**：该问题使用VLSI设计和EDA领域的精确、客观和标准术语进行陈述。没有主观或含糊不清的陈述。\n\n该问题不违反任何无效性标准。它是一个基于既定工程模型的完整、一致且可解的问题。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供一个完整的、有理有据的解决方案。\n\n任务是计算捕获寄存器 $\\text{FF}_\\text{C}$ 的数据输入引脚 $D$ 处的总数据到达时间，记为 $T_A$。发射寄存器 $\\text{FF}_\\text{L}$ 的发射时钟在时间 $t=0$ 到达。总到达时间是从 $\\text{FF}_\\text{L}$ 的时钟到Q端延迟开始，通过组合路径累积的延迟。\n\n关键原则是，每个逻辑级的时序特性（延迟和输出转换速率）取决于它驱动的输出电容负载及其输入端的信号转换速率。因此，我们必须按顺序在路径中传播时序信息——到达时间和信号转换速率。\n\n按照要求，传播的假设如下：\n1.  驱动器输出端的总电容负载 $C_{\\text{load}}$ 是互连电容与该输出所驱动的单元的输入引脚电容之和。\n2.  给定逻辑级的输入转换速率 $S_{\\text{in}}$ 是前一个驱动级的输出转换速率 $S_{\\text{out}}$。\n3.  某个节点的到达时间是前一个节点的到达时间与中间单元的传播延迟之和。\n\n该路径包括四个延迟累积阶段：\n1.  $\\text{FF}_\\text{L}$ (时钟到Q端延迟)\n2.  $\\text{INV\\_X2}$ (传播延迟)\n3.  $\\text{NAND2\\_X1}$ (传播延迟)\n4.  $\\text{BUF\\_X4}$ (传播延迟)\n\n我们将按顺序计算每个阶段的贡献。所有延迟和转换速率的单位是纳秒 (ns)，电容的单位是飞法 (fF)。\n\n**阶段 1：发射寄存器 ($\\text{FF}_\\text{L}$)**\n第一阶段是发射寄存器 $\\text{FF}_\\text{L}$。其时序由其输出引脚 $Q$ 上的负载决定。\n负载 $C_{\\text{load,FF}}$ 是互连电容 $C_0$ 和反相器 $\\text{INV\\_X2}$ 的输入引脚电容之和。\n$$C_{\\text{load,FF}} = C_0 + C_{\\text{pin,INV}} = 6.0\\,\\text{fF} + 2.5\\,\\text{fF} = 8.5\\,\\text{fF}$$\n使用给定的 $\\text{FF}_\\text{L}$ 模型计算时钟到Q端延迟 ($d_{\\text{CQ}}$) 和 $Q$ 端的输出转换速率 ($S_Q$)：\n$$d_{\\text{CQ}} = d_{0,\\text{FF}} + k_{c,\\text{FF}}\\,C_{\\text{load,FF}} = 0.080 + 0.0005 \\times 8.5 = 0.080 + 0.00425 = 0.08425\\,\\text{ns}$$\n$$S_Q = s_{0,\\text{FF}} + m_{c,\\text{FF}}\\,C_{\\text{load,FF}} = 0.040 + 0.0012 \\times 8.5 = 0.040 + 0.0102 = 0.0502\\,\\text{ns}$$\n到达 $\\text{INV\\_X2}$ 输入端的时间是 $T_{A,0} = d_{\\text{CQ}} = 0.08425\\,\\text{ns}$。\n输出转换速率 $S_Q$ 成为下一级（即 $\\text{INV\\_X2}$）的输入转换速率 $S_{\\text{in,INV}}$。\n\n**阶段 2：反相器 ($\\text{INV\\_X2}$)**\n反相器的输入转换速率是 $S_{\\text{in,INV}} = S_Q = 0.0502\\,\\text{ns}$。\n反相器输出端的负载 $C_{\\text{load,INV}}$ 是互连电容 $C_1$ 和 $\\text{NAND2\\_X1}$ 门的输入引脚电容之和。\n$$C_{\\text{load,INV}} = C_1 + C_{\\text{pin,NAND}} = 7.0\\,\\text{fF} + 3.0\\,\\text{fF} = 10.0\\,\\text{fF}$$\n反相器的传播延迟 ($d_{\\text{INV}}$) 和输出转换速率 ($S_{\\text{out,INV}}$) 是：\n$$d_{\\text{INV}} = d_{0,\\text{INV}} + k_{s,\\text{INV}}\\,S_{\\text{in,INV}} + k_{c,\\text{INV}}\\,C_{\\text{load,INV}}$$\n$$d_{\\text{INV}} = 0.020 + 0.20 \\times 0.0502 + 0.0010 \\times 10.0 = 0.020 + 0.01004 + 0.010 = 0.04004\\,\\text{ns}$$\n$$S_{\\text{out,INV}} = s_{0,\\text{INV}} + m_{s,\\text{INV}}\\,S_{\\text{in,INV}} + m_{c,\\text{INV}}\\,C_{\\text{load,INV}}$$\n$$S_{\\text{out,INV}} = 0.015 + 0.30 \\times 0.0502 + 0.0025 \\times 10.0 = 0.015 + 0.01506 + 0.025 = 0.05506\\,\\text{ns}$$\n到达 $\\text{NAND2\\_X1}$ 输入端的时间是 $T_{A,1} = T_{A,0} + d_{\\text{INV}} = 0.08425 + 0.04004 = 0.12429\\,\\text{ns}$。\n输出转换速率 $S_{\\text{out,INV}}$ 成为下一级（即 $\\text{NAND2\\_X1}$）的输入转换速率 $S_{\\text{in,NAND}}$。\n\n**阶段 3：NAND 门 ($\\text{NAND2\\_X1}$)**\nNAND 门的输入转换速率是 $S_{\\text{in,NAND}} = S_{\\text{out,INV}} = 0.05506\\,\\text{ns}$。\nNAND 门输出端的负载 $C_{\\text{load,NAND}}$ 是互连电容 $C_2$ 和缓冲器 $\\text{BUF\\_X4}$ 的输入引脚电容之和。\n$$C_{\\text{load,NAND}} = C_2 + C_{\\text{pin,BUF}} = 8.0\\,\\text{fF} + 4.0\\,\\text{fF} = 12.0\\,\\text{fF}$$\nNAND 门的传播延迟 ($d_{\\text{NAND}}$) 和输出转换速率 ($S_{\\text{out,NAND}}$) 是：\n$$d_{\\text{NAND}} = d_{0,\\text{NAND}} + k_{s,\\text{NAND}}\\,S_{\\text{in,NAND}} + k_{c,\\text{NAND}}\\,C_{\\text{load,NAND}}$$\n$$d_{\\text{NAND}} = 0.030 + 0.25 \\times 0.05506 + 0.0015 \\times 12.0 = 0.030 + 0.013765 + 0.018 = 0.061765\\,\\text{ns}$$\n$$S_{\\text{out,NAND}} = s_{0,\\text{NAND}} + m_{s,\\text{NAND}}\\,S_{\\text{in,NAND}} + m_{c,\\text{NAND}}\\,C_{\\text{load,NAND}}$$\n$$S_{\\text{out,NAND}} = 0.020 + 0.35 \\times 0.05506 + 0.0030 \\times 12.0 = 0.020 + 0.019271 + 0.036 = 0.075271\\,\\text{ns}$$\n到达 $\\text{BUF\\_X4}$ 输入端的时间是 $T_{A,2} = T_{A,1} + d_{\\text{NAND}} = 0.12429 + 0.061765 = 0.186055\\,\\text{ns}$。\n输出转换速率 $S_{\\text{out,NAND}}$ 成为最后一级（即 $\\text{BUF\\_X4}$）的输入转换速率 $S_{\\text{in,BUF}}$。\n\n**阶段 4：缓冲器 ($\\text{BUF\\_X4}$)**\n缓冲器的输入转换速率是 $S_{\\text{in,BUF}} = S_{\\text{out,NAND}} = 0.075271\\,\\text{ns}$。\n缓冲器输出端的负载 $C_{\\text{load,BUF}}$ 是互连电容 $C_3$ 和捕获寄存器 $\\text{FF}_\\text{C}$ 的数据引脚电容之和。\n$$C_{\\text{load,BUF}} = C_3 + C_{\\text{pin,FF\\_C}} = 10.0\\,\\text{fF} + 2.0\\,\\text{fF} = 12.0\\,\\text{fF}$$\n缓冲器的传播延迟 ($d_{\\text{BUF}}$) 是：\n$$d_{\\text{BUF}} = d_{0,\\text{BUF}} + k_{s,\\text{BUF}}\\,S_{\\text{in,BUF}} + k_{c,\\text{BUF}}\\,C_{\\text{load,BUF}}$$\n$$d_{\\text{BUF}} = 0.018 + 0.15 \\times 0.075271 + 0.0008 \\times 12.0 = 0.018 + 0.01129065 + 0.0096 = 0.03889065\\,\\text{ns}$$\n\n**最终到达时间计算**\n$\\text{FF}_\\text{C}$ 的 $D$ 输入端的最终数据到达时间 $T_A$ 是所有级延迟的总和。\n$$T_A = d_{\\text{CQ}} + d_{\\text{INV}} + d_{\\text{NAND}} + d_{\\text{BUF}}$$\n$$T_A = 0.08425 + 0.04004 + 0.061765 + 0.03889065 = 0.22494565\\,\\text{ns}$$\n这也可以通过计算最后一级输入端的到达时间加上其延迟来得到：$T_A = T_{A,2} + d_{\\text{BUF}} = 0.186055 + 0.03889065 = 0.22494565\\,\\text{ns}$。\n\n问题要求将最终答案四舍五入到四位有效数字。\n计算值为 $0.22494565\\,\\text{ns}$。前四位有效数字是 $2$、$2$、$4$ 和 $9$。第五位数字是 $4$，所以我们向下舍入。\n$$T_A \\approx 0.2249\\,\\text{ns}$$",
            "answer": "$$\\boxed{0.2249}$$"
        },
        {
            "introduction": "在路径延迟计算的基础上，本练习将探讨如何在多角（multi-corner）环境中确定时序裕量（slack）。它演示了为建立时间（setup）和保持时间（hold）分析选择悲观角组合的关键概念，例如，为建立时间分析选择慢速的发射路径与快速的捕获路径。通过这种方式，您将学会如何在设计中找到真正的最差情况时序裕量。",
            "id": "4284013",
            "problem": "一个集成电路中的同步单时钟流水线，在作为电子设计自动化 (EDA) 一部分的多角多模 (MCMM) 流程中，使用静态时序分析 (STA) 进行分析。考虑一个从发射触发器 $FF_{\\mathrm{L}}$ 到捕获触发器 $FF_{\\mathrm{C}}$ 的单条寄存器到寄存器路径。该数据路径包含两个逻辑门和三个互连段。分析必须包含工艺-电压-温度 (PVT) 器件角和电阻-电容 (RC) 布线角。\n\n基本定义：STA 评估信号传播时间和约束。建立时间要求确保数据在有效捕获沿之前一个裕量 $t_{\\mathrm{setup}}$ 到达 $FF_{\\mathrm{C}}$，而保持时间要求确保新发射的数据在同一捕获沿之后的一段持续时间 $t_{\\mathrm{hold}}$ 内不会覆盖已存储的数据。对于每次时序检查，将数据到达时间定义为发射时钟沿时间和数据路径延迟之和，将要求时间定义为由建立或保持裕量调整后的相应捕获沿时间。裕量定义为要求时间减去到达时间。负裕量表示存在违例。\n\n可用器件角：慢-慢 $(\\mathrm{SS})$ 和快-快 $(\\mathrm{FF})$，相对于典型-典型 $(\\mathrm{TT})$，其逻辑门延迟乘数分别为 $1.30$ 和 $0.70$。\n可用RC角：$\\mathrm{RC}_{\\max}$ 和 $\\mathrm{RC}_{\\min}$，相对于 $\\mathrm{TT}$，其互连延迟乘数分别为 $1.40$ 和 $0.60$。\n\n$\\mathrm{TT}$ 下的标称数据路径延迟：\n- 总逻辑门延迟：$100\\,\\mathrm{ps}$（两个逻辑门总计 $100\\,\\mathrm{ps}$）。\n- 总互连延迟：$60\\,\\mathrm{ps}$（三个段总计 $60\\,\\mathrm{ps}$）。\n- 因此标称总数据延迟：$160\\,\\mathrm{ps}$。\n\n时钟网络延迟按模式给出，每个延迟由一个逻辑门部分和一个互连部分组成。逻辑门部分随器件角乘数缩放，互连部分随RC角乘数缩放。\n\n模式 $\\mathcal{A}$：\n- 时钟周期 $T_{\\mathcal{A}} = 1000\\,\\mathrm{ps}$。\n- 发射时钟延迟 $L_{\\mathcal{A},\\mathrm{TT}} = 120\\,\\mathrm{ps}$，由 $60\\%$ 的逻辑门和 $40\\%$ 的互连组成。\n- 捕获时钟延迟 $C_{\\mathcal{A},\\mathrm{TT}} = 150\\,\\mathrm{ps}$，由 $60\\%$ 的逻辑门和 $40\\%$ 的互连组成。\n\n模式 $\\mathcal{B}$：\n- 时钟周期 $T_{\\mathcal{B}} = 2000\\,\\mathrm{ps}$。\n- 发射时钟延迟 $L_{\\mathcal{B},\\mathrm{TT}} = 210\\,\\mathrm{ps}$，由 $60\\%$ 的逻辑门和 $40\\%$ 的互连组成。\n- 捕获时钟延迟 $C_{\\mathcal{B},\\mathrm{TT}} = 230\\,\\mathrm{ps}$，由 $60\\%$ 的逻辑门和 $40\\%$ 的互连组成。\n\n在 $\\mathrm{TT}$ 下，捕获触发器的建立和保持裕量为：\n- $t_{\\mathrm{setup,TT}} = 35\\,\\mathrm{ps}$，\n- $t_{\\mathrm{hold,TT}} = 25\\,\\mathrm{ps}$。\n\n假设捕获触发器约束参数 $t_{\\mathrm{setup}}$ 和 $t_{\\mathrm{hold}}$ 与捕获时钟路径的器件角以与逻辑门延迟相同的方式缩放。\n\n任务：\n1. 使用 STA 的基本原理，为每种模式选择最小化建立时间裕量和最小化保持时间裕量的角组合。该选择必须在科学上与最小化裕量的目标一致，这需要考虑到达时间和要求时间的定义，包括为捕获时钟路径及其相关的 $t_{\\mathrm{setup}}$ 或 $t_{\\mathrm{hold}}$ 分配一致的角。\n2. 分别使用为逻辑门和互连提供的器件和RC乘数，在所选的最差情况角组合下，计算模式 $\\mathcal{A}$ 和模式 $\\mathcal{B}$ 的建立时间裕量和保持时间裕量。\n3. 最后，在四个计算出的裕量（每种模式的建立和保持裕量）中，报告唯一的那个最负的裕量值作为全局最差情况。以 $\\mathrm{ps}$ 为单位表示最终的裕量值，并将您的答案四舍五入到四位有效数字。",
            "solution": "问题陈述已经过验证，被认为是科学可靠、适定且自包含的。它提出了一个在电子设计自动化 (EDA) 背景下的标准（尽管简化了的）静态时序分析 (STA) 问题，要求在多角多模 (MCMM) 条件下计算时序裕量。所有必要的参数、定义和约束均已提供。因此，我们可以进行形式化的求解。\n\nSTA 的核心是评估建立时间和保持时间的时序约束。我们首先根据所提供的原理，将裕量方程形式化。一个时钟周期在时钟源处从时间 $t=0$ 开始。\n\n在捕获触发器 $FF_{\\mathrm{C}}$ 输入端的数据**到达时间** $AT$ 是发射时钟路径延迟 $L$ 和数据路径延迟 $d_{\\mathrm{data}}$ 的和。\n$$AT = L + d_{\\mathrm{data}}$$\n\n对于**建立时间检查**，数据必须在捕获时钟沿到达*之前*至少 $t_{\\mathrm{setup}}$ 的时间到达 $FF_{\\mathrm{C}}$。捕获沿源于时钟源，在时间 $T$（$T$ 是时钟周期）发出，并在时间 $T+C$ 到达 $FF_{\\mathrm{C}}$ 的时钟引脚。因此，建立时间的所需到达时间 $RAT_{\\mathrm{setup}}$ 为：\n$$RAT_{\\mathrm{setup}} = (T + C) - t_{\\mathrm{setup}}$$\n建立时间裕量 $S_{\\mathrm{setup}}$ 是满足此约束的余量：\n$$S_{\\mathrm{setup}} = RAT_{\\mathrm{setup}} - AT = (T + C - t_{\\mathrm{setup}}) - (L + d_{\\mathrm{data}})$$\n$$S_{\\mathrm{setup}} = T + C - L - d_{\\mathrm{data}} - t_{\\mathrm{setup}}$$\n\n对于**保持时间检查**，由一个时钟沿发射的数据不能过快地到达 $FF_{\\mathrm{C}}$，以至于覆盖了由*同一个*时钟沿正在捕获的数据。数据必须在捕获沿到达*之后*保持稳定一段持续时间 $t_{\\mathrm{hold}}$。时钟沿在时间 $C$ 到达 $FF_{\\mathrm{C}}$。保持时间的所需到达时间 $RAT_{\\mathrm{hold}}$ 是新数据被允许到达的最早时间。\n$$RAT_{\\mathrm{hold}} = C + t_{\\mathrm{hold}}$$\n保持时间裕量 $S_{\\mathrm{hold}}$ 是满足此约束的余量：\n$$S_{\\mathrm{hold}} = AT - RAT_{\\mathrm{hold}} = (L + d_{\\mathrm{data}}) - (C + t_{\\mathrm{hold}})$$\n$$S_{\\mathrm{hold}} = L + d_{\\mathrm{data}} - C - t_{\\mathrm{hold}}$$\n\n为了找到最差情况（最小）的裕量，我们必须选择对每次计算产生悲观影响的工艺-电压-温度 (PVT) 和电阻-电容 (RC) 角。乘数如下：\n-   器件慢-慢 (SS): $k_{dev,SS} = 1.30$\n-   器件快-快 (FF): $k_{dev,FF} = 0.70$\n-   RC最大 ($\\mathrm{RC}_{\\max}$): $k_{RC,max} = 1.40$\n-   RC最小 ($\\mathrm{RC}_{\\min}$): $k_{RC,min} = 0.60$\n我们将“慢角”组合定义为 $(\\mathrm{SS}, \\mathrm{RC}_{\\max})$，将“快角”组合定义为 $(\\mathrm{FF}, \\mathrm{RC}_{\\min})$。\n\n**建立时间裕量的最差情况角选择：**\n为了最小化 $S_{\\mathrm{setup}} = T + C - L - d_{\\mathrm{data}} - t_{\\mathrm{setup}}$，我们必须最大化 $L$、$d_{\\mathrm{data}}$ 和 $t_{\\mathrm{setup}}$，并最小化 $C$。\n-   最大化 $L$ 和 $d_{\\mathrm{data}}$ 需要使用慢角。\n-   最小化 $C$ 需要使用快角。\n-   项 $t_{\\mathrm{setup}}$ 随捕获路径器件角缩放。如果我们为 $C$ 使用快角，$t_{\\mathrm{setup}}$ 会变小。如果我们为 $C$ 使用慢角，$C$ 和 $t_{\\mathrm{setup}}$ 都会变大。需要最小化的项是 $(C - t_{\\mathrm{setup}})$。初步计算表明，当捕获路径处于快角时，该项被最小化。\n因此，最悲观的建立时间分析使用慢速的发射路径和数据路径，以及快速的捕获路径。这是一种标准的片上变异 (OCV) 方法。\n-   **建立时间角**：发射/数据路径 = 慢 $(\\mathrm{SS}, \\mathrm{RC}_{\\max})$；捕获路径 = 快 $(\\mathrm{FF}, \\mathrm{RC}_{\\min})$。\n\n**保持时间裕量的最差情况角选择：**\n为了最小化 $S_{\\mathrm{hold}} = L + d_{\\mathrm{data}} - C - t_{\\mathrm{hold}}$，我们必须最小化 $L$ 和 $d_{\\mathrm{data}}$，并最大化 $C$ 和 $t_{\\mathrm{hold}}$。\n-   最小化 $L$ 和 $d_{\\mathrm{data}}$ 需要使用快角。\n-   最大化 $C$ 和 $t_{\\mathrm{hold}}$（与 $C$ 使用相同的器件角缩放）需要使用慢角。\n-   **保持时间角**：发射/数据路径 = 快 $(\\mathrm{FF}, \\mathrm{RC}_{\\min})$；捕获路径 = 慢 $(\\mathrm{SS}, \\mathrm{RC}_{\\max})$。\n\n我们现在对每种模式进行计算。\n标称 (TT) 值：\n-   数据路径逻辑门延迟 $d_{\\mathrm{gate,TT}} = 100\\,\\mathrm{ps}$；互连延迟 $d_{\\mathrm{ic,TT}} = 60\\,\\mathrm{ps}$。\n-   建立时间 $t_{\\mathrm{setup,TT}} = 35\\,\\mathrm{ps}$；保持时间 $t_{\\mathrm{hold,TT}} = 25\\,\\mathrm{ps}$。\n\n各角下数据路径延迟：\n-   慢速数据路径：$d_{\\mathrm{data,s}} = k_{dev,SS} d_{\\mathrm{gate,TT}} + k_{RC,max} d_{\\mathrm{ic,TT}} = 1.30 \\times 100 + 1.40 \\times 60 = 130 + 84 = 214\\,\\mathrm{ps}$。\n-   快速数据路径：$d_{\\mathrm{data,f}} = k_{dev,FF} d_{\\mathrm{gate,TT}} + k_{RC,min} d_{\\mathrm{ic,TT}} = 0.70 \\times 100 + 0.60 \\times 60 = 70 + 36 = 106\\,\\mathrm{ps}$。\n\n各角下约束时间：\n-   快速建立时间：$t_{\\mathrm{setup,f}} = k_{dev,FF} t_{\\mathrm{setup,TT}} = 0.70 \\times 35 = 24.5\\,\\mathrm{ps}$。\n-   慢速保持时间：$t_{\\mathrm{hold,s}} = k_{dev,SS} t_{\\mathrm{hold,TT}} = 1.30 \\times 25 = 32.5\\,\\mathrm{ps}$。\n\n**模式 $\\mathcal{A}$ 的分析 ($T_{\\mathcal{A}} = 1000\\,\\mathrm{ps}$)**\n-   $L_{\\mathcal{A},\\mathrm{TT}} = 120\\,\\mathrm{ps}$ ($72\\,\\mathrm{ps}$ 逻辑门, $48\\,\\mathrm{ps}$ 互连)。\n-   $C_{\\mathcal{A},\\mathrm{TT}} = 150\\,\\mathrm{ps}$ ($90\\,\\mathrm{ps}$ 逻辑门, $60\\,\\mathrm{ps}$ 互连)。\n-   慢速发射延迟 $L_{\\mathcal{A},\\mathrm{s}} = 1.30 \\times 72 + 1.40 \\times 48 = 93.6 + 67.2 = 160.8\\,\\mathrm{ps}$。\n-   快速捕获延迟 $C_{\\mathcal{A},\\mathrm{f}} = 0.70 \\times 90 + 0.60 \\times 60 = 63 + 36 = 99\\,\\mathrm{ps}$。\n-   快速发射延迟 $L_{\\mathcal{A},\\mathrm{f}} = 0.70 \\times 72 + 0.60 \\times 48 = 50.4 + 28.8 = 79.2\\,\\mathrm{ps}$。\n-   慢速捕获延迟 $C_{\\mathcal{A},\\mathrm{s}} = 1.30 \\times 90 + 1.40 \\times 60 = 117 + 84 = 201\\,\\mathrm{ps}$。\n\n模式 $\\mathcal{A}$ 的建立时间裕量：\n$S_{\\mathrm{setup},\\mathcal{A}} = T_{\\mathcal{A}} + C_{\\mathcal{A},\\mathrm{f}} - L_{\\mathcal{A},\\mathrm{s}} - d_{\\mathrm{data,s}} - t_{\\mathrm{setup,f}}$\n$S_{\\mathrm{setup},\\mathcal{A}} = 1000 + 99 - 160.8 - 214 - 24.5 = 699.7\\,\\mathrm{ps}$。\n\n模式 $\\mathcal{A}$ 的保持时间裕量：\n$S_{\\mathrm{hold},\\mathcal{A}} = L_{\\mathcal{A},\\mathrm{f}} + d_{\\mathrm{data,f}} - C_{\\mathcal{A},\\mathrm{s}} - t_{\\mathrm{hold,s}}$\n$S_{\\mathrm{hold},\\mathcal{A}} = 79.2 + 106 - 201 - 32.5 = 185.2 - 233.5 = -48.3\\,\\mathrm{ps}$。\n\n**模式 $\\mathcal{B}$ 的分析 ($T_{\\mathcal{B}} = 2000\\,\\mathrm{ps}$)**\n-   $L_{\\mathcal{B},\\mathrm{TT}} = 210\\,\\mathrm{ps}$ ($126\\,\\mathrm{ps}$ 逻辑门, $84\\,\\mathrm{ps}$ 互连)。\n-   $C_{\\mathcal{B},\\mathrm{TT}} = 230\\,\\mathrm{ps}$ ($138\\,\\mathrm{ps}$ 逻辑门, $92\\,\\mathrm{ps}$ 互连)。\n-   慢速发射延迟 $L_{\\mathcal{B},\\mathrm{s}} = 1.30 \\times 126 + 1.40 \\times 84 = 163.8 + 117.6 = 281.4\\,\\mathrm{ps}$。\n-   快速捕获延迟 $C_{\\mathcal{B},\\mathrm{f}} = 0.70 \\times 138 + 0.60 \\times 92 = 96.6 + 55.2 = 151.8\\,\\mathrm{ps}$。\n-   快速发射延迟 $L_{\\mathcal{B},\\mathrm{f}} = 0.70 \\times 126 + 0.60 \\times 84 = 88.2 + 50.4 = 138.6\\,\\mathrm{ps}$。\n-   慢速捕获延迟 $C_{\\mathcal{B},\\mathrm{s}} = 1.30 \\times 138 + 1.40 \\times 92 = 179.4 + 128.8 = 308.2\\,\\mathrm{ps}$。\n\n模式 $\\mathcal{B}$ 的建立时间裕量：\n$S_{\\mathrm{setup},\\mathcal{B}} = T_{\\mathcal{B}} + C_{\\mathcal{B},\\mathrm{f}} - L_{\\mathcal{B},\\mathrm{s}} - d_{\\mathrm{data,s}} - t_{\\mathrm{setup,f}}$\n$S_{\\mathrm{setup},\\mathcal{B}} = 2000 + 151.8 - 281.4 - 214 - 24.5 = 1631.9\\,\\mathrm{ps}$。\n\n模式 $\\mathcal{B}$ 的保持时间裕量：\n$S_{\\mathrm{hold},\\mathcal{B}} = L_{\\mathcal{B},\\mathrm{f}} + d_{\\mathrm{data,f}} - C_{\\mathcal{B},\\mathrm{s}} - t_{\\mathrm{hold,s}}$\n$S_{\\mathrm{hold},\\mathcal{B}} = 138.6 + 106 - 308.2 - 32.5 = 244.6 - 340.7 = -96.1\\,\\mathrm{ps}$。\n\n**结论**\n四个计算出的裕量值为：\n-   $S_{\\mathrm{setup},\\mathcal{A}} = 699.7\\,\\mathrm{ps}$\n-   $S_{\\mathrm{hold},\\mathcal{A}} = -48.3\\,\\mathrm{ps}$\n-   $S_{\\mathrm{setup},\\mathcal{B}} = 1631.9\\,\\mathrm{ps}$\n-   $S_{\\mathrm{hold},\\mathcal{B}} = -96.1\\,\\mathrm{ps}$\n\n唯一的那个最负的裕量值是这些值中的最小值，即 $-96.1\\,\\mathrm{ps}$。这代表了在两种模式和所有角下，指定路径的全局最差情况时序违例。将此值四舍五入到四位有效数字，得到 $-96.10\\,\\mathrm{ps}$。",
            "answer": "$$\n\\boxed{-96.10}\n$$"
        },
        {
            "introduction": "时序收敛（timing closure）通常是一个解决冲突需求的过程。本练习将探讨一个经典权衡问题：通过增加延迟来修复保持时间（hold）违例，可能会恶化建立时间（setup）的裕量。我们将此挑战构建为一个线性规划问题，为您提供使用优化技术寻找最佳平衡点的实践经验，从而在所有角和模式下最大化整体时序裕量。",
            "id": "4284055",
            "problem": "考虑在电子设计自动化（EDA）中，于多角多模（MCMM）时序分析下的一条同步寄存器到寄存器路径。多角（Multi-corner）指的是不同的工艺-电压-温度（PVT）视图，例如快-快（FF）和慢-慢（SS）。多模（Multi-mode）指的是具有不同时钟周期的不同时钟模式。对于发射寄存器和捕获寄存器之间的单条组合路径，将在工艺角 $c$ 下的最大（最差情况）和最小（最好情况）数据路径延迟分别定义为 $D_{\\max}^{(c)}$ 和 $D_{\\min}^{(c)}$。将每个工艺角的建立裕量（包括寄存器建立时间、偏斜和不确定性的总和）定义为 $U^{(c)}$，将每个工艺角的保持要求（包括寄存器保持时间、偏斜和不确定性）定义为 $H^{(c)}$。对于周期为 $T^{(m)}$ 的模式 $m$，在工艺角 $c$ 下的建立时序裕量由 $T^{(m)} - (D_{\\max}^{(c)} + \\Delta_{\\max}^{(c)}) - U^{(c)}$ 给出，在工艺角 $c$ 下的保持时序裕量由 $(D_{\\min}^{(c)} + \\Delta_{\\min}^{(c)}) - H^{(c)}$ 给出，其中 $\\Delta_{\\max}^{(c)}$ 和 $\\Delta_{\\min}^{(c)}$ 是由一个大小为 $x \\ge 0$ 的可调延迟元件引入的路径延迟变化。\n\n假设每个工艺角都遵循一阶线性延迟灵敏度模型，其中大小为 $x$ 的附加延迟元件会改变最小延迟和最大延迟，即 $\\Delta_{\\min}^{(c)} = \\alpha^{(c)} x$ 和 $\\Delta_{\\max}^{(c)} = \\beta^{(c)} x$，灵敏度为 $\\alpha^{(c)} \\ge 0$ 和 $\\beta^{(c)} \\ge 0$。其物理原理是，增加的元件会减慢路径；在快工艺角下，它通过增加 $D_{\\min}^{(c)}$ 来帮助满足保持要求，但同时通过增加 $D_{\\max}^{(c)}$ 来恶化慢工艺角下的建立要求。\n\n将所有工艺角和模式下的最差情况时序裕量 $t$ 定义为所有建立和保持时序裕量的最小值。优化目标是选择 $x \\ge 0$ 以最大化 $t$，从而在保持时间的改善和建立时间的恶化之间取得平衡。将其表述为一个线性规划问题，目标是最大化 $t$，并遵循从所有工艺角和模式的建立与保持时序裕量定义中推导出的线性不等式约束。\n\n您的任务是实现一个程序，针对每个提供的测试用例，使用线性规划求解最优的附加延迟 $x$（单位为纳秒）和相应的最大化最差情况时序裕量 $t$（单位为纳秒）。使用以下测试套件，其中所有延迟和时钟周期的参数均以纳秒表示。所有数值答案必须以纳秒（ns）表示，并四舍五入到六位小数。\n\n测试用例 1（理想路径，最优 $x$ 位于平衡点）：\n- 工艺角：$c \\in \\{ \\text{FF}, \\text{SS} \\}$。\n- 模式：$m \\in \\{ M_1, M_2 \\}$，其中 $T^{(M_1)} = 1.0$, $T^{(M_2)} = 0.8$。\n- 基本延迟和裕量：\n  - $D_{\\min}^{(\\text{FF})} = 0.07$, $H^{(\\text{FF})} = 0.08$。\n  - $D_{\\min}^{(\\text{SS})} = 0.12$, $H^{(\\text{SS})} = 0.10$。\n  - $D_{\\max}^{(\\text{FF})} = 0.42$, $U^{(\\text{FF})} = 0.06$。\n  - $D_{\\max}^{(\\text{SS})} = 0.62$, $U^{(\\text{SS})} = 0.08$。\n- 灵敏度：\n  - $\\alpha^{(\\text{FF})} = 1.0$, $\\alpha^{(\\text{SS})} = 1.2$。\n  - $\\beta^{(\\text{FF})} = 0.8$, $\\beta^{(\\text{SS})} = 1.4$。\n\n测试用例 2（边界情况，最优解为 $x = 0$）：\n- 工艺角：$c \\in \\{ \\text{FF}, \\text{SS} \\}$。\n- 模式：$m \\in \\{ M_1, M_2 \\}$，其中 $T^{(M_1)} = 1.0$, $T^{(M_2)} = 0.7$。\n- 基本延迟和裕量：\n  - $D_{\\min}^{(\\text{FF})} = 0.20$, $H^{(\\text{FF})} = 0.05$。\n  - $D_{\\min}^{(\\text{SS})} = 0.25$, $H^{(\\text{SS})} = 0.06$。\n  - $D_{\\max}^{(\\text{FF})} = 0.40$, $U^{(\\text{FF})} = 0.05$。\n  - $D_{\\max}^{(\\text{SS})} = 0.60$, $U^{(\\text{SS})} = 0.05$。\n- 灵敏度：\n  - $\\alpha^{(\\text{FF})} = 1.1$, $\\alpha^{(\\text{SS})} = 1.3$。\n  - $\\beta^{(\\text{FF})} = 1.0$, $\\beta^{(\\text{SS})} = 1.5$。\n\n测试用例 3（边缘情况，即使是平衡后的最优解也产生负的最差情况时序裕量）：\n- 工艺角：$c \\in \\{ \\text{FF}, \\text{SS} \\}$。\n- 模式：$m \\in \\{ M_1, M_2 \\}$，其中 $T^{(M_1)} = 1.10$, $T^{(M_2)} = 0.85$。\n- 基本延迟和裕量：\n  - $D_{\\min}^{(\\text{FF})} = 0.02$, $H^{(\\text{FF})} = 0.09$。\n  - $D_{\\min}^{(\\text{SS})} = 0.10$, $H^{(\\text{SS})} = 0.11$。\n  - $D_{\\max}^{(\\text{FF})} = 0.45$, $U^{(\\text{FF})} = 0.06$。\n  - $D_{\\max}^{(\\text{SS})} = 0.70$, $U^{(\\text{SS})} = 0.08$。\n- 灵敏度：\n  - $\\alpha^{(\\text{FF})} = 1.0$, $\\alpha^{(\\text{SS})} = 1.3$。\n  - $\\beta^{(\\text{FF})} = 1.1$, $\\beta^{(\\text{SS})} = 1.6$。\n\n需实现的公式细节：\n- 决策变量为 $x \\ge 0$ 和 $t \\in \\mathbb{R}$。\n- 对每个工艺角 $c$，强制执行保持时序裕量约束：\n  - $D_{\\min}^{(c)} + \\alpha^{(c)} x - H^{(c)} \\ge t$。\n- 对每个工艺角 $c$ 和每个模式 $m$，强制执行建立时序裕量约束：\n  - $T^{(m)} - D_{\\max}^{(c)} - \\beta^{(c)} x - U^{(c)} \\ge t$。\n- 目标：最大化 $t$。\n\n程序要求：\n- 使用线性规划实现优化。\n- 对每个测试用例，计算最优的 $x$ 和相应的最大化最差情况时序裕量 $t$，单位均为纳秒。\n- 将每个数值输出四舍五入到六位小数。\n- 您的程序应生成单行输出，包含一个列表的列表，格式为 $[[x_1,t_1],[x_2,t_2],[x_3,t_3]]$。单位是纳秒，输出行本身不应打印单位符号；数值必须以纳秒为单位进行解释。\n\n所有数值均以纳秒（ns）为单位。不涉及角度。不涉及百分比。",
            "solution": "该问题要求找到一个附加可调延迟 $x \\ge 0$ 的最优值，以最大化数字电路路径在多个工艺角和操作模式下的最差情况时序裕量 $t$。这是一个经典的优化问题，可以表述并作为线性规划（LP）问题来解决。\n\n首先，我们为建立和保持时序检查定义时序裕量。对于给定的工艺角 $c$ 和模式 $m$，建立时序裕量由以下公式给出：\n$$S_{\\text{setup}}^{(c,m)} = T^{(m)} - (D_{\\max}^{(c)} + \\Delta_{\\max}^{(c)}) - U^{(c)}$$\n对于给定的工艺角 $c$，保持时序裕量由以下公式给出：\n$$S_{\\text{hold}}^{(c)} = (D_{\\min}^{(c)} + \\Delta_{\\min}^{(c)}) - H^{(c)}$$\n其中 $T^{(m)}$ 是模式 $m$ 的时钟周期，$D_{\\max}^{(c)}$ 和 $D_{\\min}^{(c)}$ 是工艺角 $c$ 的最大和最小路径延迟，$U^{(c)}$ 和 $H^{(c)}$ 是工艺角 $c$ 的建立和保持裕量要求，而 $\\Delta_{\\max}^{(c)}$ 和 $\\Delta_{\\min}^{(c)}$ 是由于增加了大小为 $x$ 的延迟元件而引起的延迟变化。\n\n问题陈述了一个线性延迟灵敏度模型，其中延迟变化与 $x$ 成正比：\n$$\\Delta_{\\max}^{(c)} = \\beta^{(c)} x$$\n$$\\Delta_{\\min}^{(c)} = \\alpha^{(c)} x$$\n其中灵敏度为非负值 $\\alpha^{(c)} \\ge 0$ 和 $\\beta^{(c)} \\ge 0$。将此模型代入时序裕量方程，我们得到：\n$$S_{\\text{setup}}^{(c,m)} = T^{(m)} - D_{\\max}^{(c)} - U^{(c)} - \\beta^{(c)} x$$\n$$S_{\\text{hold}}^{(c)} = D_{\\min}^{(c)} - H^{(c)} + \\alpha^{(c)} x$$\n\n最差情况时序裕量 $t$ 定义为所有这些独立时序裕量值在所有工艺角 $c$ 和模式 $m$ 中的最小值：\n$$t = \\min_{c,m} \\left\\{ S_{\\text{setup}}^{(c,m)}, S_{\\text{hold}}^{(c)} \\right\\}$$\n优化目标是选择 $x \\ge 0$ 来最大化 $t$。这是一个最大-最小化问题：\n$$\\max_{x \\ge 0} \\left( \\min_{c,m} \\left\\{ T^{(m)} - D_{\\max}^{(c)} - U^{(c)} - \\beta^{(c)} x, \\quad D_{\\min}^{(c)} - H^{(c)} + \\alpha^{(c)} x \\right\\} \\right)$$\n这类问题可以直接转换为一个线性规划问题。我们引入 $t$ 作为一个新的决策变量，我们的目标是最大化它。$t$ 必须是所有时序裕量最小值的条件，是通过一系列约束来强制执行的，这些约束规定 $t$ 必须小于或等于每个独立的时序裕量值。\n\n由此产生的LP公式如下：\n\n**决策变量：**\n待确定的变量是最差情况时序裕量 $t \\in \\mathbb{R}$ 和附加延迟 $x \\in \\mathbb{R}$。\n\n**目标函数：**\n目标是最大化最差情况时序裕量 $t$：\n$$\\text{最大化} \\quad t$$\n\n**约束条件：**\n约束条件确保 $t$ 确实是最小的时序裕量，并且 $x$ 是物理上可实现的（非负）。\n1.  对于每个工艺角 $c$ 和模式 $m$，建立时序裕量约束为：\n    $$t \\le S_{\\text{setup}}^{(c,m)} \\implies t \\le T^{(m)} - D_{\\max}^{(c)} - U^{(c)} - \\beta^{(c)} x$$\n2.  对于每个工艺角 $c$，保持时序裕量约束为：\n    $$t \\le S_{\\text{hold}}^{(c)} \\implies t \\le D_{\\min}^{(c)} - H^{(c)} + \\alpha^{(c)} x$$\n3.  附加延迟必须为非负：\n    $$x \\ge 0$$\n\n为了使用一个标准的LP求解器（通常是最小化一个函数，并遵循 $\\mathbf{A}\\mathbf{z} \\le \\mathbf{b}$ 形式的约束），我们重新整理该问题。最大化 $t$ 等同于最小化 $-t$。设决策变量向量为 $\\mathbf{z} = [t, x]^T$。目标是最小化 $\\mathbf{c}^T \\mathbf{z}$，其中成本向量为 $\\mathbf{c} = [-1, 0]^T$。\n\n将约束条件重新排列，将变量分组到左侧：\n$$t + \\beta^{(c)} x \\le T^{(m)} - D_{\\max}^{(c)} - U^{(c)} \\quad (\\text{对于所有 } c, m)$$\n$$t - \\alpha^{(c)} x \\le D_{\\min}^{(c)} - H^{(c)} \\quad (\\text{对于所有 } c)$$\n非负约束 $x \\ge 0$ 可以通过设置 $x$ 的下界来处理。\n\n对于每个测试用例，我们根据这些不等式、成本向量 $\\mathbf{c}$ 和变量边界来构建矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{b}$。然后使用一个LP求解器来找到满足所有条件的最优 $t$ 和 $x$ 值。对于一个有 $N_c$ 个工艺角和 $N_m$ 个模式的实例，将有 $N_c \\times N_m$ 个建立约束和 $N_c$ 个保持约束，总共产生 $N_c \\cdot (N_m + 1)$ 个关于两个变量 $t$ 和 $x$ 的不等式约束。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the timing optimization problem for a series of test cases\n    using linear programming.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (happy path)\n        {\n            \"corners\": [\"FF\", \"SS\"],\n            \"modes\": {\"M1\": 1.0, \"M2\": 0.8},\n            \"D_min\": {\"FF\": 0.07, \"SS\": 0.12},\n            \"H\": {\"FF\": 0.08, \"SS\": 0.10},\n            \"D_max\": {\"FF\": 0.42, \"SS\": 0.62},\n            \"U\": {\"FF\": 0.06, \"SS\": 0.08},\n            \"alpha\": {\"FF\": 1.0, \"SS\": 1.2},\n            \"beta\": {\"FF\": 0.8, \"SS\": 1.4},\n        },\n        # Test Case 2 (boundary case x=0)\n        {\n            \"corners\": [\"FF\", \"SS\"],\n            \"modes\": {\"M1\": 1.0, \"M2\": 0.7},\n            \"D_min\": {\"FF\": 0.20, \"SS\": 0.25},\n            \"H\": {\"FF\": 0.05, \"SS\": 0.06},\n            \"D_max\": {\"FF\": 0.40, \"SS\": 0.60},\n            \"U\": {\"FF\": 0.05, \"SS\": 0.05},\n            \"alpha\": {\"FF\": 1.1, \"SS\": 1.3},\n            \"beta\": {\"FF\": 1.0, \"SS\": 1.5},\n        },\n        # Test Case 3 (edge case, negative slack)\n        {\n            \"corners\": [\"FF\", \"SS\"],\n            \"modes\": {\"M1\": 1.10, \"M2\": 0.85},\n            \"D_min\": {\"FF\": 0.02, \"SS\": 0.10},\n            \"H\": {\"FF\": 0.09, \"SS\": 0.11},\n            \"D_max\": {\"FF\": 0.45, \"SS\": 0.70},\n            \"U\": {\"FF\": 0.06, \"SS\": 0.08},\n            \"alpha\": {\"FF\": 1.0, \"SS\": 1.3},\n            \"beta\": {\"FF\": 1.1, \"SS\": 1.6},\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        A_ub = []\n        b_ub = []\n\n        # Objective function: maximize t is min -t. Variables are [t, x].\n        c = [-1, 0]\n\n        # Hold constraints: t - alpha*x = D_min - H\n        for corner in case[\"corners\"]:\n            A_ub.append([1, -case[\"alpha\"][corner]])\n            b_ub.append(case[\"D_min\"][corner] - case[\"H\"][corner])\n\n        # Setup constraints: t + beta*x = T - D_max - U\n        for corner in case[\"corners\"]:\n            for mode, T_m in case[\"modes\"].items():\n                A_ub.append([1, case[\"beta\"][corner]])\n                b_ub.append(T_m - case[\"D_max\"][corner] - case[\"U\"][corner])\n        \n        # Bounds for variables [t, x]: t is free, x >= 0\n        bounds = [(None, None), (0, None)]\n\n        # Solve the linear program\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n        if res.success:\n            # res.x contains the optimal values for [t, x]\n            t_opt, x_opt = res.x\n            # Round to six decimal places as required\n            x_out = round(x_opt, 6)\n            t_out = round(t_opt, 6)\n            results.append([x_out, t_out])\n        else:\n            # Handle cases where the solver fails, though not expected for these problems\n            results.append([float('nan'), float('nan')])\n    \n    # Format the final output string exactly as specified: [[x1,t1],[x2,t2],...]\n    # Using repr() and replacing space ensures comma-separation without spaces.\n    # Note: str() on a list adds spaces, so we build the string representation manually.\n    result_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]}]\" for r in results]) + \"]\"\n\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}