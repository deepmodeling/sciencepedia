{
    "hands_on_practices": [
        {
            "introduction": "第一个练习旨在将物理版图问题转化为抽象的图模型，这是整个流程中的基本步骤。你将练习如何从几何特征数据构建冲突图，并应用标准算法检查其是否具备 $2$-可着色性，这是实现无缝合线双重曝光工艺的核心条件。这项练习为你搭建了从物理领域到算法领域的桥梁。",
            "id": "4284553",
            "problem": "在用于集成电路和电子设计自动化的多重曝光光刻技术中，版图着色决定了相邻的特征是否可以在不违反最小间距约束的情况下被分配到不同的掩模上。冲突图的构建捕捉了这些约束：顶点代表特征，如果两个对应的特征距离太近以至于不能同时分配到同一个掩模上，那么连接这两个顶点的边就存在。一个关键的决策过程是判断该图是否允许二着色，这等价于验证该图是否为二分图。考虑一组轴对齐的矩形特征，每个特征由坐标 $\\left(x_{\\min},y_{\\min},x_{\\max},y_{\\max}\\right)$ 给出，其中 $x_{\\min}  x_{\\max}$ 且 $y_{\\min}  y_{\\max}$，所有坐标均以纳米为单位。使用临界间距阈值 $d_c=40\\,\\mathrm{nm}$，构建冲突图，其中如果两个矩形之间的最小边到边欧几里得间距严格小于 $d_c$，则它们之间存在一条无向边。两个闭合矩形 $R_1=[x_{1,\\min},x_{1,\\max}]\\times[y_{1,\\min},y_{1,\\max}]$ 和 $R_2=[x_{2,\\min},x_{2,\\max}]\\times[y_{2,\\min},y_{2,\\max}]$ 之间的最小边到边欧几里得间距定义为：首先计算轴向间距\n$$\n\\Delta x=\\max\\left(0,\\;x_{2,\\min}-x_{1,\\max},\\;x_{1,\\min}-x_{2,\\max}\\right),\\quad\n\\Delta y=\\max\\left(0,\\;y_{2,\\min}-y_{1,\\max},\\;y_{1,\\min}-y_{2,\\max}\\right),\n$$\n然后计算欧几里得距离\n$$\nd(R_1,R_2)=\\sqrt{(\\Delta x)^2+(\\Delta y)^2}.\n$$\n如果 $d(R_1,R_2)d_c$，则两个矩形存在冲突。对于每个测试用例，通过应用基于广度优先搜索 (BFS) 的二着色算法来确定生成的冲突图是否为二分图。其中，广度优先搜索 (BFS) 指的是从每个未访问过的顶点开始，逐层探索图，并为相邻顶点分配交替的颜色。如果在 BFS 过程中发现一条连接相同颜色顶点的边，则该图不是二分图。\n\n本问题中所有的坐标和距离都必须以纳米为单位处理，临界间距阈值也以纳米为单位指定。不涉及角度单位。每个测试用例需要输出一个布尔值，以表明其是否为二分图。\n\n测试套件：\n- 测试用例 $1$ (预期为路径图): 矩形\n  - $R_1:\\;(0,0,40,20)$,\n  - $R_2:\\;(70,0,110,20)$,\n  - $R_3:\\;(140,0,180,20)$,\n  - $R_4:\\;(210,0,250,20)$,\n  $d_c=40\\,\\mathrm{nm}$。\n- 测试用例 $2$ (预期为三角形图): 矩形\n  - $R_1:\\;(0,0,40,40)$,\n  - $R_2:\\;(30,0,70,40)$,\n  - $R_3:\\;(15,30,55,70)$,\n  $d_c=40\\,\\mathrm{nm}$。\n- 测试用例 $3$ (阈值边界，无边): 矩形\n  - $R_1:\\;(0,0,40,40)$,\n  - $R_2:\\;(80,0,120,40)$,\n  - $R_3:\\;(0,100,40,140)$,\n  $d_c=40\\,\\mathrm{nm}$。\n- 测试用例 $4$ (不连通分量：一个路径图和一个三角形图): 矩形\n  - $R_1:\\;(0,0,40,40)$,\n  - $R_2:\\;(70,0,110,40)$,\n  - $R_3:\\;(1000,1000,1040,1040)$,\n  - $R_4:\\;(1030,1000,1070,1040)$,\n  - $R_5:\\;(1015,1030,1055,1070)$,\n  $d_c=40\\,\\mathrm{nm}$。\n- 测试用例 $5$ (长度为四的偶数环): 矩形\n  - $R_1:\\;(0,0,40,40)$,\n  - $R_2:\\;(70,0,110,40)$,\n  - $R_3:\\;(70,70,110,110)$,\n  - $R_4:\\;(0,70,40,110)$,\n  $d_c=40\\,\\mathrm{nm}$。\n\n您的程序应根据上述几何规则为每个案例构建冲突图，并通过基于 BFS 的二着色算法确定其是否为二分图。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$），每个条目是对应测试用例的布尔值结果。",
            "solution": "该问题要求确定从一组矩形电子电路特征派生出的冲突图是否为二分图。这是电子设计自动化 (EDA) 中多重曝光光刻技术的一个基本问题，其中一个可二着色（二分）的冲突图表明，一个版图可以使用双掩模工艺进行制造，而不会违反最小间距规则。\n\n对于每个测试用例，解决方案分两个主要阶段进行：首先，基于几何约束构建冲突图；其次，使用基于广度优先搜索 (BFS) 的二着色算法测试其是否为二分图。\n\n如果一个图的顶点可以被分成两个不相交且独立的集合 $U$ 和 $W$，使得每条边都连接 $U$ 中的一个顶点和 $W$ 中的一个顶点，则该图被定义为二分图。图论中的一个关键定理指出，一个图是二分图当且仅当它不包含奇数长度的环。指定的基于 BFS 的着色算法是检测此类奇数长度环的一种标准且高效的方法。\n\n**1. 冲突图构建**\n\n对于每个测试用例，我们给定一组 $N$ 个轴对齐的矩形和一个临界间距阈值 $d_c = 40\\,\\mathrm{nm}$。冲突图 $G=(V, E)$ 的顶点对应这 $N$ 个矩形。如果矩形 $R_i$ 和矩形 $R_j$ 之间的最小边到边欧几里得间距严格小于 $d_c$，则边集合 $E$ 中存在一条无向边 $(R_i, R_j)$。\n\n两个矩形 $R_1=\\left[x_{1,\\min},x_{1,\\max}\\right]\\times\\left[y_{1,\\min},y_{1,\\max}\\right]$ 和 $R_2=\\left[x_{2,\\min},x_{2,\\max}\\right]\\times\\left[y_{2,\\min},y_{2,\\max}\\right]$ 之间的最小间距 $d(R_1, R_2)$ 由以下公式给出：\n$$\nd(R_1,R_2)=\\sqrt{(\\Delta x)^2+(\\Delta y)^2}\n$$\n其中 $\\Delta x$ 和 $\\Delta y$ 是沿每个轴的间距：\n$$\n\\Delta x=\\max\\left(0,\\;x_{2,\\min}-x_{1,\\max},\\;x_{1,\\min}-x_{2,\\max}\\right)\n$$\n$$\n\\Delta y=\\max\\left(0,\\;y_{2,\\min}-y_{1,\\max},\\;y_{1,\\min}-y_{2,\\max}\\right)\n$$\n这些公式正确地计算了矩形在每个轴上的区间间隙。如果区间重叠，则该轴上的间距为 $0$。\n\n冲突条件是 $d(R_i, R_j)  d_c$。为避免浮点数运算和计算成本更高的平方根操作，我们可以使用距离的平方进行计算。该条件等价于：\n$$\nd(R_i, R_j)^2  d_c^2 \\implies (\\Delta x)^2 + (\\Delta y)^2  d_c^2\n$$\n给定 $d_c = 40\\,\\mathrm{nm}$，临界距离的平方为 $d_c^2 = 40^2 = 1600\\,\\mathrm{nm}^2$。\n\n图构建的算法如下：\n- 为具有 $N$ 个顶点的图初始化一个空的邻接表表示。\n- 对于每一对索引为 $i$ 和 $j$ 的不同矩形 $(R_i, R_j)$（$0 \\le i  j  N$）：\n    - 计算 $\\Delta x$ 和 $\\Delta y$。\n    - 如果 $(\\Delta x)^2 + (\\Delta y)^2  1600$，则在邻接表中于顶点 $i$ 和顶点 $j$ 之间添加一条边。\n\n**2. 通过广度优先搜索 (BFS) 进行二分性测试**\n\n冲突图构建完成后，我们测试其二分性。基于 BFS 的二着色算法系统地探索图，并为每个顶点分配两种颜色之一（例如，颜色 $1$ 和颜色 $-1$）。该过程必须考虑到图可能具有多个不连通分量的情况。\n\n算法如下：\n- 初始化一个大小为 $N$ 的 `colors` 数组，其值为 $0$，表示所有顶点都未着色。\n- 遍历从 $0$ 到 $N-1$ 的每个顶点 $i$：\n    - 如果顶点 $i$ 未着色 (`colors[i] == 0`)，这标志着一个新的连通分量的开始。我们从此顶点开始进行 BFS 遍历。\n        - 创建一个队列并将顶点 $i$ 加入队列。\n        - 为顶点 $i$ 分配一个起始颜色，例如 `colors[i] = 1`。\n        - 当队列不为空时：\n            - 从队列中取出一个顶点 $u$。\n            - 对于 $u$ 的邻接表中的每个邻居 $v$：\n                - 如果顶点 $v$ 未着色 (`colors[v] == 0`)：\n                    - 为其分配与 $u$ 相反的颜色（即 `colors[v] = -colors[u]`）。\n                    - 将顶点 $v$ 加入队列。\n                - 否则，如果顶点 $v$ 的颜色与 $u$ 相同 (`colors[v] == colors[u]`)：\n                    - 一条边连接了两个相同颜色的顶点。这意味着存在一个奇数长度的环。\n                    - 该图不是二分图。当前测试用例的算法终止并返回 `False`。\n- 如果主循环完成而没有发现任何此类颜色冲突，则意味着没有连通分量包含奇数长度的环。因此，整个图是二分图，算法返回 `True`。\n\n这个两阶段过程应用于五个测试用例中的每一个，以确定它们各自的二分性。例如，在测试用例 2 中，三个矩形都相互重叠，导致任意一对之间的距离为 $0$。这形成了一个完全图 $K_3$（一个三角形），它是一个长度为 3 的奇数环，因此不是二分图。相比之下，测试用例 5 形成了一个长度为 4 的环，这是一个偶数环，因此是二分图。该方法能够为所有指定的配置稳健地提供正确的分类。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves the layout coloring problem for the given test cases.\n    \"\"\"\n\n    # Each case is a list of rectangles, where each rectangle is a tuple\n    # (x_min, y_min, x_max, y_max).\n    test_cases = [\n        # Case 1 (path graph expected)\n        [\n            (0, 0, 40, 20),\n            (70, 0, 110, 20),\n            (140, 0, 180, 20),\n            (210, 0, 250, 20),\n        ],\n        # Case 2 (triangle expected)\n        [\n            (0, 0, 40, 40),\n            (30, 0, 70, 40),\n            (15, 30, 55, 70),\n        ],\n        # Case 3 (threshold boundary, no edges)\n        [\n            (0, 0, 40, 40),\n            (80, 0, 120, 40),\n            (0, 100, 40, 140),\n        ],\n        # Case 4 (disconnected components: one path and one triangle)\n        [\n            (0, 0, 40, 40),\n            (70, 0, 110, 40),\n            (1000, 1000, 1040, 1040),\n            (1030, 1000, 1070, 1040),\n            (1015, 1030, 1055, 1070),\n        ],\n        # Case 5 (even cycle of four)\n        [\n            (0, 0, 40, 40),\n            (70, 0, 110, 40),\n            (70, 70, 110, 110),\n            (0, 70, 40, 110),\n        ],\n    ]\n\n    dc = 40.0\n    results = []\n    \n    for rectangles in test_cases:\n        results.append(check_bipartite(rectangles, dc))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef check_bipartite(rectangles: list, dc: float) -> bool:\n    \"\"\"\n    Constructs a conflict graph and checks if it's bipartite.\n\n    Args:\n        rectangles: A list of rectangle coordinates.\n        dc: The critical spacing threshold.\n\n    Returns:\n        True if the graph is bipartite, False otherwise.\n    \"\"\"\n    n = len(rectangles)\n    if n = 1:\n        return True\n\n    adj = [[] for _ in range(n)]\n    dc_sq = dc**2\n\n    # Step 1: Construct the conflict graph\n    for i in range(n):\n        for j in range(i + 1, n):\n            r1 = rectangles[i]\n            r2 = rectangles[j]\n            \n            # Unpack coordinates\n            x1_min, y1_min, x1_max, y1_max = r1\n            x2_min, y2_min, x2_max, y2_max = r2\n\n            # Calculate axis separations\n            delta_x = max(0, x2_min - x1_max, x1_min - x2_max)\n            delta_y = max(0, y2_min - y1_max, y1_min - y2_max)\n            \n            # Check for conflict using squared distance\n            dist_sq = delta_x**2 + delta_y**2\n            if dist_sq  dc_sq:\n                adj[i].append(j)\n                adj[j].append(i)\n\n    # Step 2: Check for bipartiteness using BFS-based 2-coloring\n    colors = np.zeros(n, dtype=int)  # 0: uncolored, 1: color A, -1: color B\n\n    for i in range(n):\n        if colors[i] == 0:  # Start BFS for a new connected component\n            queue = collections.deque([i])\n            colors[i] = 1\n            while queue:\n                u = queue.popleft()\n                for v in adj[u]:\n                    if colors[v] == 0:\n                        colors[v] = -colors[u]\n                        queue.append(v)\n                    elif colors[v] == colors[u]:\n                        return False  # Odd cycle detected, not bipartite\n                        \n    return True  # No odd cycles found, graph is bipartite\n\nsolve()\n```"
        },
        {
            "introduction": "当版图不满足 $2$-可着色性时，必须对其进行修改。本练习将介绍“缝合点”（stitching）作为一种常见的修复技术。你将实现一个算法，以确定使非二分冲突图变得可着色所需的最小缝合点数量，这在图论中等同于求解最小奇圈覆盖问题。",
            "id": "4284591",
            "problem": "在用于多重曝光光刻的电子设计自动化（EDA）中，版图分解的一个标准抽象是冲突图 $G=(V,E)$，其中每个顶点 $v \\in V$ 代表一个多边形版图特征，每条边 $(u,v) \\in E$ 代表一个最小间距约束，该约束禁止为 $u$ 和 $v$ 分配相同的光刻掩模（颜色）。一个 2-可着色的冲突图对应于一个没有缝合点（stitch）的可行双重曝光分配。缝合点是对一个多边形特征进行有意拆分，使其成为两个可以独立着色的子特征。在图抽象层面，这可以建模为将该特征从奇数环的参与中移除。在本问题中，我们将缝合点形式化为选择一个要拆分的集合 $S \\subseteq V$（每个选定的顶点对应一个缝合点），使得剩余的图 $G - S$ 是二分的。根据图论的基本事实——一个图是二分图当且仅当它不包含奇数环——最小缝合点数等于最小奇环横贯集 $S$ 的基数，即一个最小的顶点集，移除该集合后可使 $G$ 成为二分图。\n\n从上述定义出发，推导并实现一个算法。对于小规模图，该算法按基数递增的顺序枚举子集 $S \\subseteq V$，并通过检查 2-着色的可行性来判断 $G - S$ 是否为二分图。该算法必须返回实现二分性所需的最小 $|S|$。你的程序必须实现这种枚举和二分性测试，并为所提供的测试套件中的每个图计算最小缝合点数。\n\n你必须使用纯粹的数学和逻辑推理，并将你的推导建立在以下经过充分检验的事实之上：\n- 图 $G$ 是二分图，当且仅当它允许对 $V$ 进行 2-着色，使得 $E$ 中的每条边都连接不同颜色的顶点。\n- 图 $G$ 是二分图，当且仅当它不包含奇数长度的环。\n- 从 $G$ 中移除一个顶点集 $S$ 会得到诱导子图 $G-S$，该子图是通过删除 $S$ 中的所有顶点以及所有与这些顶点关联的边而得到的。\n\n你的程序应对以下测试套件进行评估。每个测试用例由顶点数 $n$ 和一个边列表 $E$ 指定，顶点用整数标记。对于所有用例，输出最小缝合点数（作为整数）。不涉及物理单位。最终输出格式必须是单行文本，其中包含所有测试用例的结果，结果连接成一个逗号分隔的列表并用方括号括起来，例如 $[r_1,r_2,\\dots,r_k]$。\n\n测试套件：\n- 用例 1：$n=4$，$E=\\{(0,1),(1,2),(2,3)\\}$，一个有 4 个顶点的路径图。\n- 用例 2：$n=3$，$E=\\{(0,1),(1,2),(2,0)\\}$，一个三角形。\n- 用例 3：$n=4$，$E=\\{(0,1),(1,2),(2,3),(3,0)\\}$，一个 4-环（正方形）。\n- 用例 4：$n=4$，$E=\\{(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)\\}$，4 个顶点的完全图。\n- 用例 5：$n=5$，$E=\\{(0,1),(1,2),(2,0),(0,3),(3,4),(4,0)\\}$，两个共享顶点 0 的三角形。\n- 用例 6：$n=6$，$E=\\{(0,1),(1,2),(2,0),(3,4),(4,5),(5,3)\\}$，两个不相交的三角形。\n- 用例 7：$n=5$，$E=\\{(0,1),(1,2),(2,3),(3,4),(4,0)\\}$，一个 5-环。\n- 用例 8：$n=1$，$E=\\{\\}$，一个孤立顶点。\n- 用例 9：$n=6$，$E=\\{(0,1),(0,2),(0,3),(0,4),(0,5)\\}$，一个以顶点 0 为中心的星形图。\n\n你的程序应生成单行输出，其中包含一个逗号分隔的列表形式的结果，并用方括号括起来（例如 $[result_1,result_2,\\dots,result_9]$）。每个 $result_i$ 必须是指定相应案例所需最小缝合点数的整数。",
            "solution": "所陈述的问题是有效的。它在科学上基于图论的既定原则及其在电子设计自动化（EDA）中的应用，特别是针对多重曝光光刻的版图分解问题。该问题提法明确、客观且自成体系，为获得唯一解提供了所有必要的定义和数据。它要求实现一个特定的算法——通过枚举基数递增的顶点子集来找到最小奇环横贯集——这对于解决小规模图问题是一种正确但计算密集的方法。\n\n问题要求找出使冲突图 $G=(V,E)$ 成为二分图所需的最少缝合点数。应用于一个特征（由顶点 $v \\in V$ 表示）的缝合点被建模为从图中移除顶点 $v$。因此，目标是找到一个最小基数的顶点集 $S \\subseteq V$，使得诱导子图 $G-S$ 是二分图。一个图是二分图，当且仅当它不包含奇数长度的环。因此，集合 $S$ 必须是与 $G$ 中每个奇数环都相交的最小顶点集。在图论中，这样的集合被称为最小奇环横贯集。\n\n指定的算法是搜索最小的整数 $k \\geq 0$，使得存在一个子集 $S \\subseteq V$ 且 $|S|=k$，且 $G-S$ 是二分图。这是一种暴力搜索策略，由于它按递增顺序（从 $k=0, 1, 2, \\dots, |V|$）检查子集的基数，因此保证能找到最小的 $k$。\n\n该算法流程如下：\n1.  令 $k$ 为要移除的顶点集 $S$ 的大小（缝合点数）。我们从 $k=0$ 开始。\n2.  对于给定的 $k$，生成所有基数为 $k$ 的不同子集 $S \\subseteq V$。\n3.  对于每个子集 $S$，构造诱导子图 $G-S$。该子图由顶点 $V' = V \\setminus S$ 和原图 $E$ 中两个端点都在 $V'$ 内的所有边组成。\n4.  测试子图 $G-S$ 是否为二分图。如果是，则我们找到了一个大小为 $k$ 的有效缝合点集。由于我们是按递增顺序遍历 $k$ 的，这个 $k$ 必定是所需的最小缝合点数。算法可以终止并返回 $k$。\n5.  如果大小为 $k$ 的子集都不能得到二分图，则将 $k$ 增加 1，并从步骤 2 重复。该过程保证会终止，因为移除所有顶点（即 $S=V$, $k=|V|$）会得到一个空图，而空图显然是二分图。\n\n该算法的核心是针对给定图（或子图）的二分性测试。一个图是二分图，当且仅当其顶点可以被划分为两个不相交的独立集 $U_1$ 和 $U_2$，使得每条边都连接一个在 $U_1$ 中的顶点和一个在 $U_2$ 中的顶点。这等价于检查该图是否是 2-可着色的。一种标准方法是使用图遍历算法，如广度优先搜索 (BFS) 或深度优先搜索 (DFS)。\n\n基于 BFS 的 2-着色算法对图 $G'=(V', E')$ 的工作原理如下：\n1.  创建一个 `color` 数据结构（例如数组或哈希映射）来存储 $V'$ 中每个顶点的颜色。将所有顶点初始化为未着色（例如颜色 0）。设两种颜色为 $1$ 和 $-1$。\n2.  遍历 $V'$ 中的每个顶点 $v$。如果 $v$ 未着色：\n    a. 为 $v$ 分配一个起始颜色，比如颜色 1。\n    b. 从 $v$ 开始进行 BFS 遍历。将 $v$ 添加到队列中。\n    c. 当队列不为空时：\n        i.   从队列中取出一个顶点 $u$。\n        ii.  对于 $u$ 的每个邻居 $w$：\n             - 如果 $w$ 未着色，则为其分配与 $u$ 相反的颜色（即 `color[w] = -color[u]`）并将 $w$ 入队。\n             - 如果 $w$ 已着色且 `color[w] == color[u]`，则说明有一条边连接了两个相同颜色的顶点。这表明存在一个奇数长度的环。该图不是二分图。测试失败。\n3.  如果图的所有连通分量的遍历都完成，且没有发现任何同色邻居，则该图已成功进行 2-着色，因此是二分图。测试成功。\n\n使用邻接表表示法可以高效地实现 BFS 遍历。对于每个测试用例，我们通过其顶点数 $n$ 和边列表 $E$ 来定义图。主循环从 0 到 $n$ 遍历 $k$。一个内循环生成 $k$ 个顶点的所有组合以形成集合 $S$。对于每个 $S$，我们对 $G-S$ 应用二分性测试。第一个使测试通过的 $k$ 值就是该测试用例的解。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It iterates through each test case, finds the minimum number of stitches,\n    and prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Case 1: n=4, E={(0,1),(1,2),(2,3)}\n        (4, [(0, 1), (1, 2), (2, 3)]),\n        # Case 2: n=3, E={(0,1),(1,2),(2,0)}\n        (3, [(0, 1), (1, 2), (2, 0)]),\n        # Case 3: n=4, E={(0,1),(1,2),(2,3),(3,0)}\n        (4, [(0, 1), (1, 2), (2, 3), (3, 0)]),\n        # Case 4: n=4, E={(0,1),(0,2),(0,3),(1,2),(1,3),(2,3)}\n        (4, [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]),\n        # Case 5: n=5, E={(0,1),(1,2),(2,0),(0,3),(3,4),(4,0)}\n        (5, [(0, 1), (1, 2), (2, 0), (0, 3), (3, 4), (4, 0)]),\n        # Case 6: n=6, E={(0,1),(1,2),(2,0),(3,4),(4,5),(5,3)}\n        (6, [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5), (5, 3)]),\n        # Case 7: n=5, E={(0,1),(1,2),(2,3),(3,4),(4,0)}\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)]),\n        # Case 8: n=1, E={}\n        (1, []),\n        # Case 9: n=6, E={(0,1),(0,2),(0,3),(0,4),(0,5)}\n        (6, [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        min_stitches = find_min_stitches(n, edges)\n        results.append(min_stitches)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef is_bipartite(num_vertices, edges, removed_vertices):\n    \"\"\"\n    Checks if the subgraph G-S is bipartite using BFS-based 2-coloring.\n    S is the set of removed_vertices.\n    \"\"\"\n    removed_set = set(removed_vertices)\n    \n    # Adjacency list for the subgraph G-S\n    adj = {i: [] for i in range(num_vertices) if i not in removed_set}\n    if not adj:  # Empty graph is bipartite\n        return True\n\n    for u, v in edges:\n        if u not in removed_set and v not in removed_set:\n            adj[u].append(v)\n            adj[v].append(u)\n    \n    # colors map: 0 for uncolored, 1  -1 for the two colors\n    colors = {}\n    \n    # Iterate through all vertices to handle disconnected components\n    for i in adj:\n        if i not in colors:\n            colors[i] = 1\n            queue = deque([i])\n            \n            while queue:\n                u = queue.popleft()\n                \n                for v in adj[u]:\n                    if v not in colors:\n                        colors[v] = -colors[u]\n                        queue.append(v)\n                    elif colors[v] == colors[u]:\n                        # Found an edge connecting two same-colored vertices,\n                        # which implies an odd cycle.\n                        return False\n    return True\n\n\ndef find_min_stitches(n, edges):\n    \"\"\"\n    Finds the minimum number of stitches (vertices to remove) to make the\n    graph bipartite by enumerating subsets of vertices of increasing size.\n    \"\"\"\n    vertices = list(range(n))\n    \n    # k is the number of stitches (vertices to remove)\n    for k in range(n + 1):\n        # Generate all subsets of vertices of size k\n        for s in itertools.combinations(vertices, k):\n            if is_bipartite(n, edges, s):\n                return k\n    return n # Should not be reached in practice as an empty graph is bipartite\n\nsolve()\n```"
        },
        {
            "introduction": "在实际应用中，并非所有缝合点的影响都相同；有些可能成本更高或引入更大的制造风险。最后的这项练习将引导你进入高级优化领域，要求你将着色和缝合问题建模为一个整数线性规划（ILP）问题。这种方法使你能够找到一个不仅解决所有着色冲突，而且还能最小化加权总缝合成本的方案，从而反映了实际的设计权衡。",
            "id": "4284590",
            "problem": "在电子设计自动化 (EDA) 的双重曝光光刻 (DPL) 的多重曝光技术中，冲突图用于对最小间距违规进行建模：每个顶点对应一个可印刷的多边形特征，每条冲突边表示两个必须分配到不同掩模的特征。一个缝合点 (stitch) 将单个特征分割成两个可印刷的片段，这些片段可以被分配到不同的掩模，但这会引入以代价权重来量化的套准风险。设计目标是在确保所有冲突边都得到满足，并且除非启用缝合点，否则缝合的片段保持物理连续性的前提下，最小化总缝合代价。\n\n考虑一个布局，其特征由集合 $V=\\{1,2,3,4,5\\}$ 索引。冲突边为\n$$E=\\{(1,2),(2,3),(3,4),(4,5),(5,1),(2,5)\\}.$$\n特征 $2$ 是一个预着色锚点，被约束到掩模 $0$，即其二进制颜色变量必须满足 $x_2=0$。二进制颜色变量 $x_i\\in\\{0,1\\}$ 代表每个特征 $i$ 的掩模分配，其中 $0$ 和 $1$ 表示两个不同的掩模。\n\n缝合点可在特征 $1$、$3$ 和 $4$ 上使用。如果在特征 $i\\in\\{1,3,4\\}$ 上插入一个缝合点，该特征被分割成两个可印刷的片段，其二进制颜色变量为 $x_i^{(L)},x_i^{(R)}\\in\\{0,1\\}$，并有一个二进制缝合变量 $s_i\\in\\{0,1\\}$ 来指示是否使用该缝合点（$s_i=1$ 表示使用，$s_i=0$ 表示不使用）。当不使用缝合点时（$s_i=0$），两个片段的颜色必须保持连续。当使用缝合点时（$s_i=1$），两个片段可以取不同的颜色。缝合代价分别为 $\\alpha_1=2$，$\\alpha_3=1$ 和 $\\alpha_4=1.5$，目标是最小化总缝合代价 $\\sum_{i\\in\\{1,3,4\\}}\\alpha_i s_i$。\n\n对于与缝合特征 $i$ 邻接的冲突边，其一侧几何邻居与 $x_i^{(L)}$ 相互作用，另一侧的邻居与 $x_i^{(R)}$ 相互作用：\n- 对于特征 $1$：$(1,2)$ 与 $x_1^{(L)}$ 耦合，$(1,5)$ 与 $x_1^{(R)}$ 耦合。\n- 对于特征 $3$：$(2,3)$ 与 $x_3^{(L)}$ 耦合，$(3,4)$ 与 $x_3^{(R)}$ 耦合。\n- 对于特征 $4$：$(3,4)$ 与 $x_4^{(L)}$ 耦合，$(4,5)$ 与 $x_4^{(R)}$ 耦合。\n\n所有未缝合的特征使用单个变量 $x_i$。所有冲突边必须分配到不同的掩模。所有缝合片段必须遵守连续性，除非缝合变量允许颜色差异。\n\n任务：从二进制掩模分配和缝合片段物理连续性的核心定义出发，用二进制变量 $x_i$、$x_i^{(L)}$、$x_i^{(R)}$ 和 $s_i$ 建立一个整数线性规划 (ILP) 模型，该模型在满足冲突边上的掩模差异约束和缝合片段的连续性约束的条件下，最小化总缝合代价。然后，求解该实例的 ILP，以确定最小可能的目标值\n$$\\sum_{i\\in\\{1,3,4\\}}\\alpha_i s_i.$$\n将最终答案表示为单个实数。无需四舍五入。",
            "solution": "我们从双重曝光光刻 (DPL) 与图的 $2$-着色之间的映射开始：任何冲突边都要求其端点被分配到不同的掩模。使用二进制颜色变量 $x\\in\\{0,1\\}$ 来表示掩模，两个变量不同的要求可以等效地写成 $|x_u - x_v| = 1$，其中 $x_u,x_v\\in\\{0,1\\}$ 是二进制端点。因为 $x_u,x_v$ 是二进制的，所以 $|x_u-x_v|=1$ 等价于 $x_u + x_v = 1$。\n\n对于一个被分割成两个片段的缝合特征 $i$，其二进制变量为 $x_i^{(L)},x_i^{(R)}\\in\\{0,1\\}$，缝合变量为 $s_i\\in\\{0,1\\}$，物理连续性规定当 $s_i=0$ 时，片段必须是相同的颜色，而当 $s_i=1$ 时，允许有颜色差异。此规则的一个标准线性编码是\n$$|x_i^{(L)} - x_i^{(R)}| \\le s_i,$$\n对于二进制变量，这可以由以下一对不等式进行线性化：\n\\begin{align*}\nx_i^{(L)} - x_i^{(R)} \\le s_i,\\\\\nx_i^{(R)} - x_i^{(L)} \\le s_i.\n\\end{align*}\n如果 $s_i=0$，这些约束强制 $x_i^{(L)}=x_i^{(R)}$。如果 $s_i=1$，它们允许 $x_i^{(L)}\\neq x_i^{(R)}$。\n\n我们现在建立整数线性规划 (ILP) 模型。决策变量：\n- 对于未缝合的特征 $i\\in V\\setminus\\{1,3,4\\}$，一个二进制变量 $x_i\\in\\{0,1\\}$。\n- 对于可缝合的特征 $i\\in\\{1,3,4\\}$，二进制片段变量 $x_i^{(L)},x_i^{(R)}\\in\\{0,1\\}$ 和一个二进制缝合变量 $s_i\\in\\{0,1\\}$。\n- 锚点约束固定了 $x_2=0$。\n\n目标函数：\n$$\\min \\sum_{i\\in\\{1,3,4\\}} \\alpha_i s_i \\quad \\text{其中} \\quad \\alpha_1=2,\\ \\alpha_3=1,\\ \\alpha_4=1.5.$$\n\n针对该实例强制执行冲突边约束，采用指定的片段耦合方式：\n- 边 $(1,2)$: $x_1^{(L)} + x_2 = 1$。\n- 边 $(1,5)$: $x_1^{(R)} + x_5 = 1$。\n- 边 $(2,3)$: $x_2 + x_3^{(L)} = 1$。\n- 边 $(3,4)$: $x_3^{(R)} + x_4^{(L)} = 1$。\n- 边 $(4,5)$: $x_4^{(R)} + x_5 = 1$。\n- 边 $(2,5)$: $x_2 + x_5 = 1$。\n\n缝合特征 $i\\in\\{1,3,4\\}$ 的连续性约束：\n\\begin{align*}\nx_i^{(L)} - x_i^{(R)} \\le s_i,\\\\\nx_i^{(R)} - x_i^{(L)} \\le s_i.\n\\end{align*}\n\n我们现在通过从锚点和冲突约束进行传播来解析地求解该 ILP。\n\n从锚点我们有 $x_2=0$。弦边 $(2,5)$ 强制 $x_2 + x_5 = 1$，因此\n$$x_5 = 1.$$\n考虑由边 $(1,2)$、$(2,5)$ 和 $(5,1)$ 形成的三角形。如果在特征 $1$（或特征 $2$ 或 $5$）上没有缝合点，这个三角形就无法进行 $2$-着色，因为它是一个奇数环。由于缝合点只在特征 $1$、$3$ 和 $4$ 上可用，解决这个三角形冲突的唯一方法是在特征 $1$ 上使用缝合点，以便其两个片段可以取不同的颜色。\n\n我们通过显式赋值来验证其必要性和充分性：\n\n- 从 $(1,2)$，$x_1^{(L)} + x_2 = 1$ 得到\n$$x_1^{(L)} = 1.$$\n- 从 $(1,5)$，$x_1^{(R)} + x_5 = 1$ 得到\n$$x_1^{(R)} = 0.$$\n这意味着\n$$|x_1^{(L)} - x_1^{(R)}| = |1 - 0| = 1,$$\n这就强制要求 $s_1 \\ge 1$。由于 $s_1\\in\\{0,1\\}$，我们有\n$$s_1 = 1.$$\n\n沿着链 $2\\to 3\\to 4\\to 5$ 继续：\n- 边 $(2,3)$ 强制 $x_2 + x_3^{(L)} = 1$，所以\n$$x_3^{(L)} = 1.$$\n- 边 $(3,4)$ 强制 $x_3^{(R)} + x_4^{(L)} = 1$。我们尚不知道 $x_3^{(R)}$ 或 $x_4^{(L)}$ 的值，但我们接下来使用来自 $(4,5)$ 的前向约束。\n- 边 $(4,5)$ 强制 $x_4^{(R)} + x_5 = 1$，因此\n$$x_4^{(R)} = 0.$$\n我们还需要满足 $(3,4)$ 的约束。设 $x_4^{(L)}=0$；那么 $(3,4)$ 给出 $x_3^{(R)} + 0 = 1$，所以\n$$x_3^{(R)} = 1.$$\n\n最后，检查缝合特征 $3$ 和 $4$ 的连续性约束：\n- 对于特征 $3$，$x_3^{(L)}=1$ 和 $x_3^{(R)}=1$ 得出 $|x_3^{(L)} - x_3^{(R)}| = 0 \\le s_3$，所以我们可以取 $s_3=0$。\n- 对于特征 $4$，$x_4^{(L)}=0$ 和 $x_4^{(R)}=0$ 得出 $|x_4^{(L)} - x_4^{(R)}| = 0 \\le s_4$，所以我们可以取 $s_4=0$。\n\n所有冲突边都得到满足：\n\\begin{align*}\n(1,2)\\ x_1^{(L)} + x_2 = 1 + 0 = 1,\\\\\n(1,5)\\ x_1^{(R)} + x_5 = 0 + 1 = 1,\\\\\n(2,3)\\ x_2 + x_3^{(L)} = 0 + 1 = 1,\\\\\n(3,4)\\ x_3^{(R)} + x_4^{(L)} = 1 + 0 = 1,\\\\\n(4,5)\\ x_4^{(R)} + x_5 = 0 + 1 = 1,\\\\\n(2,5)\\ x_2 + x_5 = 0 + 1 = 1.\n\\end{align*}\n因此，该分配在 $s_1=1$，$s_3=0$，$s_4=0$ 的情况下是可行的，目标值为\n$$\\sum_{i\\in\\{1,3,4\\}} \\alpha_i s_i = 2\\cdot 1 + 1\\cdot 0 + 1.5\\cdot 0 = 2.$$\n\n为了论证其最小性，我们观察到 $\\{1,2,5\\}$ 上的奇数环必须通过允许其某个顶点上的颜色翻转来打破。由于缝合点只在特征 $1$、$3$ 和 $4$ 上可用，且特征 $3$ 和 $4$ 不在该三角形中，唯一可行的缝合点是在特征 $1$ 上。因此，任何可行的解决方案都必须有 $s_1=1$，并且没有必要引入额外的缝合点。因此，最小可能的目标值恰好是 $2$。",
            "answer": "$$\\boxed{2.0}$$"
        }
    ]
}