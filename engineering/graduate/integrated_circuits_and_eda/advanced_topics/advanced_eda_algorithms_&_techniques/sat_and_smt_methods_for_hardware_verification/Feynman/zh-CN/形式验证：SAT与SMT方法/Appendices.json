{
    "hands_on_practices": [
        {
            "introduction": "将硬件设计转化为布尔可满足性（SAT）问题的第一步是将其编码为合取范式（CNF）。本练习将通过一个全加器电路，让你亲手实践 Tseitin 变换这一基础而关键的技术。完成此练习有助于你深刻理解电路结构与其逻辑公式之间的直接联系。",
            "id": "4295338",
            "problem": "考虑一个一位全加器，它被实现为一个布尔电路，具有三个主输入 $a$、$b$ 和 $c$（其中 $c$ 是进位输入），以及两个主输出 $s$（和位）和 $k$（进位输出位）。在电子设计自动化（EDA）以及用于硬件验证的可满足性（SAT）和可满足性模理论（SMT）方法的背景下，该电路必须被编码为合取范式（CNF），以便与布尔可满足性求解器一起使用。从 $\\land$、$\\lor$ 和 $\\oplus$ 的布尔语义的基本定义、CNF作为文字析取之合取的定义，以及引入辅助变量来表示内部门输出同时保持等可满足性的标准Tseitin变换方法出发。\n\n你的任务是：\n- 推导一位全加器的CNF编码，该编码严格根据布尔电路的含义来强制执行 $s$ 和 $k$ 的语义，并使用Tseitin风格的方法为内部节点引入辅助变量。每个门的功能等价性必须通过CNF子句来捕获，这些子句根据其输入变量来约束其输出变量。\n- 通过为 $(a,b,c)$ 的所有 $2^3$ 种输入组合，展示你的CNF中所有变量（包括任何辅助变量以及输出 $s$ 和 $k$）的至少一个满足赋值来验证其正确性，该赋值与预期的全加器行为一致。\n- 令 $N_{\\mathrm{clauses}}$ 表示你的CNF中子句的总数（每个子句只计算一次），令 $N_{\\mathrm{models}}$ 表示当输入 $a$、$b$ 和 $c$ 不受约束时（即，所有 $2^3$ 种输入组合都被允许且不需要额外约束），CNF中所有变量的满足赋值的总数。计算乘积 $N_{\\mathrm{clauses}} \\cdot N_{\\mathrm{models}}$。\n\n将最终答案表示为单个实数值。无需四舍五入。",
            "solution": "该问题要求使用Tseitin变换推导一位全加器的合取范式（CNF）表示，验证该编码，并计算涉及CNF子句数量和满足模型总数的乘积。\n\n首先，我们必须定义一位全加器的布尔电路。该加法器有三个主输入 $a$、$b$ 和进位输入 $c$，以及两个主输出，和 $s$ 与进位输出 $k$。其逻辑函数为：\n$$s = a \\oplus b \\oplus c$$\n$$k = (a \\land b) \\lor (a \\land c) \\lor (b \\land c)$$\n\n对于Tseitin变换，我们需要一个门级实现。一个标准且高效的实现是使用两个异或门计算和，以及使用与门和或门的组合计算进位。我们用辅助变量为内部节点定义电路如下：\n1.  一个异或门计算 $a$ 和 $b$ 的和：$x_1 = a \\oplus b$。\n2.  第二个异或门计算最终的和：$s = x_1 \\oplus c$。\n3.  一个与门用于计算来自 $a$ 和 $b$ 的进位分量：$x_2 = a \\land b$。\n4.  一个与门用于计算涉及 $c$ 的进位分量：$x_3 = x_1 \\land c$。这是因为 $k = (a \\land b) \\lor (c \\land (a \\oplus b))$。\n5.  一个或门用于组合进位分量：$k = x_2 \\lor x_3$。\n\n我们模型中所有变量的集合是 $\\{a, b, c, x_1, x_2, x_3, s, k\\}$。共有3个主输入，3个辅助变量和2个主输出，总计8个变量。\n\n现在，我们对每个门应用Tseitin变换以推导CNF子句。对于每个输出为 $y$、输入为 $i_1, i_2, \\dots$ 的门，我们为等价关系 $y \\leftrightarrow f(i_1, i_2, \\dots)$ 生成子句，这确保了CNF公式的任何满足赋值都尊重该门的功能。\n\n1.  **门1：$x_1 = a \\oplus b$**\n    等价关系是 $x_1 \\leftrightarrow (a \\oplus b)$。一个双输入异或门 $(y \\leftrightarrow i_1 \\oplus i_2)$ 的标准CNF编码包含4个子句：\n    -   $(\\neg x_1 \\lor a \\lor b)$\n    -   $(\\neg x_1 \\lor \\neg a \\lor \\neg b)$\n    -   $(x_1 \\lor \\neg a \\lor b)$\n    -   $(x_1 \\lor a \\lor \\neg b)$\n\n2.  **门2：$s = x_1 \\oplus c$**\n    等价关系是 $s \\leftrightarrow (x_1 \\oplus c)$。这是另一个双输入异或门，产生4个子句：\n    -   $(\\neg s \\lor x_1 \\lor c)$\n    -   $(\\neg s \\lor \\neg x_1 \\lor \\neg c)$\n    -   $(s \\lor \\neg x_1 \\lor c)$\n    -   $(s \\lor x_1 \\lor \\neg c)$\n\n3.  **门3：$x_2 = a \\land b$**\n    等价关系是 $x_2 \\leftrightarrow (a \\land b)$。一个双输入与门 $(y \\leftrightarrow i_1 \\land i_2)$ 的标准CNF编码包含3个子句：\n    -   $(\\neg x_2 \\lor a)$\n    -   $(\\neg x_2 \\lor b)$\n    -   $(x_2 \\lor \\neg a \\lor \\neg b)$\n\n4.  **门4：$x_3 = x_1 \\land c$**\n    等价关系是 $x_3 \\leftrightarrow (x_1 \\land c)$。这是另一个双输入与门，产生3个子句：\n    -   $(\\neg x_3 \\lor x_1)$\n    -   $(\\neg x_3 \\lor c)$\n    -   $(x_3 \\lor \\neg x_1 \\lor \\neg c)$\n\n5.  **门5：$k = x_2 \\lor x_3$**\n    等价关系是 $k \\leftrightarrow (x_2 \\lor x_3)$。一个双输入或门 $(y \\leftrightarrow i_1 \\lor i_2)$ 的标准CNF编码包含3个子句：\n    -   $(k \\lor \\neg x_2)$\n    -   $(k \\lor \\neg x_3)$\n    -   $(\\neg k \\lor x_2 \\lor x_3)$\n\n全加器的完整CNF编码是所有这些子句的合取。子句的总数 $N_{\\mathrm{clauses}}$ 是每个门的子句数之和：\n$$N_{\\mathrm{clauses}} = 4 + 4 + 3 + 3 + 3 = 17$$\n\n接下来，我们必须验证此编码的正确性。我们通过为 $(a, b, c)$ 的 $2^3 = 8$ 种可能的输入组合中的每一种展示一个满足赋值来做到这一点。对于每个输入赋值，辅助变量和输出变量的值由电路逻辑唯一确定。下表显示了每种输入情况下所有8个变量的唯一满足赋值。$s$ 和 $k$ 的值与标准全加器真值表一致。\n\n| $a$ | $b$ | $c$ | $x_1 = a \\oplus b$ | $x_2 = a \\land b$ | $s = x_1 \\oplus c$ | $x_3 = x_1 \\land c$ | $k = x_2 \\lor x_3$ |\n|---|---|---|---|---|---|---|---|\n| $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ | $0$ |\n| $0$ | $0$ | $1$ | $0$ | $0$ | $1$ | $0$ | $0$ |\n| $0$ | $1$ | $0$ | $1$ | $0$ | $1$ | $0$ | $0$ |\n| $0$ | $1$ | $1$ | $1$ | $0$ | $0$ | $1$ | $1$ |\n| $1$ | $0$ | $0$ | $1$ | $0$ | $1$ | $0$ | $0$ |\n| $1$ | $0$ | $1$ | $1$ | $0$ | $0$ | $1$ | $1$ |\n| $1$ | $1$ | $0$ | $0$ | $1$ | $0$ | $0$ | $1$ |\n| $1$ | $1$ | $1$ | $0$ | $1$ | $1$ | $0$ | $1$ |\n\n此表中的每一行代表对所有8个变量的完整赋值。由于这些值是直接从门定义中派生出来的，并且CNF子句是这些定义的直接编码，因此这8个赋值中的每一个都构成了CNF公式的一个满足模型。这验证了编码的正确性。\n\n最后，我们计算乘积 $N_{\\mathrm{clauses}} \\cdot N_{\\mathrm{models}}$。我们已经确定 $N_{\\mathrm{clauses}} = 17$。$N_{\\mathrm{models}}$ 是在输入 $a$、$b$ 和 $c$ 不受约束的情况下，CNF公式在所有8个变量上的满足赋值（模型）的总数。\n\nTseitin变换确保对于任何给定的门输入赋值，其输出变量的值是唯一确定的，以使该赋值满足相应的子句。因为我们的电路是一个从主输入到主输出的有向无环图（DAG），所以对主输入 $(a, b, c)$ 的赋值通过逻辑传播链唯一地确定了所有内部和输出变量的值。\n\n对于输入 $(a, b, c)$ 的 $2^3 = 8$ 种可能赋值中的每一种，都存在唯一一个对应的其余5个变量 $(x_1, x_2, x_3, s, k)$ 的赋值，该赋值满足所有CNF子句。上面的验证表列出了这8个唯一的赋值。不存在其他满足赋值。例如，如果我们固定 $(a, b, c)$，但为一个内部变量（比如 $x_1$）选择一个与 $x_1=a \\oplus b$ 相矛盾的值，那么CNF中至少会有一个子句被违反。因此，对于不受约束的CNF公式，模型的总数恰好是可能输入组合的数量。\n$$N_{\\mathrm{models}} = 2^3 = 8$$\n\n现在我们计算最终的乘积：\n$$N_{\\mathrm{clauses}} \\cdot N_{\\mathrm{models}} = 17 \\cdot 8 = 136$$",
            "answer": "$$\n\\boxed{136}\n$$"
        },
        {
            "introduction": "现代硬件验证常常超越纯粹的逻辑，需要处理复杂的算术属性，例如整数溢出。本练习将挑战你使用位向量理论（一种重要的 SMT 理论）来形式化定义并分析二进制补码加法的溢出条件。通过这个实践，你将学会如何利用 SMT 求解器来推理处理器和数据通路设计中常见的数据相关行为。",
            "id": "4295387",
            "problem": "设 $w \\ge 2$ 是一个固定的字宽。在可满足性模理论 (Satisfiability Modulo Theories, SMT) 中使用的固定大小位向量的无量词理论中，考虑两个 $w$ 位向量 $a$ 和 $b$，以及它们的模加和 $s = \\mathrm{bvadd}(a,b)$，该运算执行模 $2^{w}$ 的加法。将 $a$、$b$ 和 $s$ 以二进制补码形式解释为范围在 $\\left[-2^{w-1},\\,2^{w-1}-1\\right]$ 内的有符号整数，其中最高有效位是符号位。令 $\\operatorname{msb}(x)$ 表示一个 $w$ 位向量 $x$ 的最高有效位。\n\n你的任务是从二进制补码表示和模加法的核心定义出发，推导出一个用于检测有符号溢出的判定谓词，并从可满足性 (SAT) 和可满足性模理论 (SMT) 的角度分析其可满足性属性。请在允许提取位、使用布尔连接词和操作符 $\\mathrm{bvadd}$ 的位向量署名下进行操作；不要假设除了这些核心定义之外的任何更高级别的算术运算。\n\n任务：\n\n1) 从二进制补码的解释和模加法的定义出发，推导出一个纯位向量断言 $\\mathsf{OVF}_{w}(a,b)$，它当且仅当 $a$ 和 $b$ 的二进制补码加法溢出时为真。你的断言必须只用 $\\operatorname{msb}(a)$、$\\operatorname{msb}(b)$、$\\operatorname{msb}(s)$、布尔连接词以及 $s = \\mathrm{bvadd}(a,b)$ 来表示，不得借助任何更高级别的算术谓词，例如显式的有符号比较。\n\n2) 仅使用推导出的断言和核心定义，刻画 SMT 公式 $\\exists a\\,\\exists b.\\,\\mathsf{OVF}_{w}(a,b)$ 对于给定的 $w$ 何时是可满足的，并给出一个关于 $a$ 和 $b$ 的通用充分条件，当该条件与 $\\mathsf{OVF}_{w}(a,b)$ 联立时，使其不可满足。你的刻画应遵循二进制补码算术的基本原理。\n\n3) 令 $\\#\\mathcal{M}_{w}$ 表示使 $\\mathsf{OVF}_{w}(a,b)$ 为真的 $w$ 位向量有序对 $(a,b)$ 的数量。通过直接从定义中对模型进行计数，推导出 $\\#\\mathcal{M}_{w}$ 作为 $w$ 的函数的封闭形式表达式。你的推导除了在简单区域内对整格点进行基本计数（并从基本原理出发进行证明）之外，不得调用任何预先记忆的计数公式。\n\n请提供你得到的 $\\#\\mathcal{M}_{w}$ 的封闭形式表达式作为最终答案。无需四舍五入。最终答案应表示为以 $w$ 为变量的、不带单位的单一解析表达式。",
            "solution": "我们按顺序处理这三个任务。设 $a$ 和 $b$ 是两个 $w$ 位向量，其中 $w \\ge 2$。令 $a_{i}$ 表示 $a$ 的第 $i$ 位，索引从 $a_{0}$（最低有效位）到 $a_{w-1}$（最高有效位）。最高有效位 $\\operatorname{msb}(x) = x_{w-1}$，在二进制补码表示中作为符号位。位向量 $x$ 的整数值，记为 $\\operatorname{int}(x)$，由下式给出：\n$$\n\\operatorname{int}(x) = -x_{w-1} 2^{w-1} + \\sum_{i=0}^{w-2} x_i 2^i\n$$\n可表示整数的范围是 $\\left[-2^{w-1}, 2^{w-1}-1\\right]$。模加和 $s = \\mathrm{bvadd}(a,b)$ 对应于模 $2^w$ 的无符号整数加法。当且仅当 $\\operatorname{int}(a) + \\operatorname{int}(b)$ 超出可表示范围时，发生有符号溢出。\n\n### 任务1：溢出谓词 $\\mathsf{OVF}_{w}(a,b)$ 的推导\n\n我们通过考虑操作数的符号来分析溢出条件，这些符号由它们的最高有效位决定。令 $a_{w-1} = \\operatorname{msb}(a)$，$b_{w-1} = \\operatorname{msb}(b)$，以及 $s_{w-1} = \\operatorname{msb}(s)$。\n\n1.  **两个正数（或零）相加：**\n    如果 $a_{w-1}=0$ 且 $b_{w-1}=0$，那么 $\\operatorname{int}(a) \\ge 0$ 且 $\\operatorname{int}(b) \\ge 0$。和 $\\operatorname{int}(a) + \\operatorname{int}(b)$ 也是非负的。如果这个和超过了可表示的最大正数值，即 $\\operatorname{int}(a) + \\operatorname{int}(b) > 2^{w-1}-1$，就会发生溢出，具体来说是正溢出。\n    在这种情况下，如果它们的和 $\\operatorname{int}(a) + \\operatorname{int}(b)$ 大于或等于 $2^{w-1}$，那么计算出的结果 $s$ 的最高有效位将是 1，即 $s_{w-1}=1$。这在二进制补码中表示一个负数，对于两个正数之和来说是不正确的。因此，当且仅当结果看起来是负数时，发生溢出。\n    正溢出的条件是：$\\neg a_{w-1} \\land \\neg b_{w-1} \\land s_{w-1}$。\n\n2.  **两个负数相加：**\n    如果 $a_{w-1}=1$ 且 $b_{w-1}=1$，那么 $\\operatorname{int}(a)  0$ 且 $\\operatorname{int}(b)  0$。和 $\\operatorname{int}(a) + \\operatorname{int}(b)$ 也是负的。如果这个和小于可表示的最小负数值，即 $\\operatorname{int}(a) + \\operatorname{int}(b)  -2^{w-1}$，就会发生溢出，具体来说是负溢出。\n    真实和为 $\\operatorname{int}(a) + \\operatorname{int}(b)$。计算出的结果 $\\operatorname{int}(s)$ 通过模运算与真实和相关。如果没有溢出，和保持在有效的负数范围内，结果 $s$ 也必须是负数，因此 $s_{w-1}=1$。如果发生负溢出，和会从最负的值“环绕”到正数范围。这意味着计算出的结果 $s$ 将有 $s_{w-1}=0$，看起来是非负的。\n    负溢出的条件是：$a_{w-1} \\land b_{w-1} \\land \\neg s_{w-1}$。\n\n3.  **符号相反的数相加：**\n    如果 $a_{w-1} \\neq b_{w-1}$，则一个数为非负数，另一个为负数。设 $\\operatorname{int}(a) \\ge 0$ 且 $\\operatorname{int}(b)  0$。\n    我们有 $0 \\le \\operatorname{int}(a) \\le 2^{w-1}-1$ 和 $-2^{w-1} \\le \\operatorname{int}(b) \\le -1$。\n    和的范围是：\n    $$\n    0 + (-2^{w-1}) \\le \\operatorname{int}(a) + \\operatorname{int}(b) \\le (2^{w-1}-1) + (-1)\n    $$\n    $$\n    -2^{w-1} \\le \\operatorname{int}(a) + \\operatorname{int}(b) \\le 2^{w-1}-2\n    $$\n    和 $\\operatorname{int}(a) + \\operatorname{int}(b)$ 总是在可表示的范围 $\\left[-2^{w-1}, 2^{w-1}-1\\right]$ 内。因此，当相加的数符号相反时，不会发生溢出。\n\n结合正溢出和负溢出的条件，我们发现当且仅当操作数的符号相同，而结果的符号不同时，发生溢出。溢出谓词是两个互斥溢出情况的析取：\n$$\n\\mathsf{OVF}_{w}(a,b) \\equiv (\\neg \\operatorname{msb}(a) \\land \\neg \\operatorname{msb}(b) \\land \\operatorname{msb}(s)) \\lor (\\operatorname{msb}(a) \\land \\operatorname{msb}(b) \\land \\neg \\operatorname{msb}(s))\n$$\n这个表达式只使用了指定的位向量操作和布尔连接词。\n\n### 任务2：可满足性与不可满足性分析\n\n**$\\exists a\\,\\exists b.\\,\\mathsf{OVF}_{w}(a,b)$ 的可满足性：**\n我们必须确定是否存在一对 $w$ 位向量 $(a,b)$，对于给定的 $w \\ge 2$ 会导致溢出。我们可以通过构造一个简单的正溢出例子来证明这一点。\n设 $\\operatorname{int}(a) = 1$ 且 $\\operatorname{int}(b) = 2^{w-1}-1$。\n对于 $w \\ge 2$，两者都是有效的正整数。\n$\\operatorname{msb}(a) = 0$ 且 $\\operatorname{msb}(b) = 0$。\n真实和为 $\\operatorname{int}(a) + \\operatorname{int}(b) = 1 + (2^{w-1}-1) = 2^{w-1}$。\n这个和超出了有效范围 $\\left[-2^{w-1}, 2^{w-1}-1\\right]$，因此发生溢出。\n模加和 $s = \\mathrm{bvadd}(a,b)$ 对应于 $2^{w-1}$ 的位模式，即 $100...0$。在二进制补码中，$\\operatorname{int}(s) = -2^{w-1}$。因此，$\\operatorname{msb}(s)=1$。\n符号位元组为 $(\\operatorname{msb}(a), \\operatorname{msb}(b), \\operatorname{msb}(s)) = (0, 0, 1)$，这满足条件 $\\neg \\operatorname{msb}(a) \\land \\neg \\operatorname{msb}(b) \\land \\operatorname{msb}(s)$。\n由于对于任何 $w \\ge 2$ 都可以构造出这样一对 $(a,b)$，因此公式 $\\exists a\\,\\exists b.\\,\\mathsf{OVF}_{w}(a,b)$ 对所有 $w \\ge 2$ 都是可满足的。\n\n**不可满足性的充分条件：**\n我们寻找一个条件 $\\phi(a,b)$，使得公式 $\\phi(a,b) \\land \\mathsf{OVF}_{w}(a,b)$ 是不可满足的。根据我们在任务1中的推导，我们已经确定如果操作数 $a$ 和 $b$ 的符号不同，则不可能发生溢出。这个条件可以表示为 $\\operatorname{msb}(a) \\neq \\operatorname{msb}(b)$，或者使用布尔连接词 $\\operatorname{msb}(a) \\oplus \\operatorname{msb}(b)$。\n如果我们将这个条件与溢出谓词联立：\n$$\n(\\operatorname{msb}(a) \\neq \\operatorname{msb}(b)) \\land \\mathsf{OVF}_{w}(a,b)\n$$\n第一部分要求符号不同。第二部分 $\\mathsf{OVF}_{w}(a,b)$ 只有在符号相同（$\\neg a_{w-1} \\land \\neg b_{w-1}$ 或 $a_{w-1} \\land b_{w-1}$）时才为真。这是一个直接的矛盾。因此，使 $\\mathsf{OVF}_{w}(a,b)$ 在联立时不可满足的关于 $a$ 和 $b$ 的充分条件是 $a$ 和 $b$ 的符号不同，即 $\\operatorname{msb}(a) \\neq \\operatorname{msb}(b)$。\n\n### 任务3：$\\#\\mathcal{M}_{w}$ 的推导\n\n我们需要计算使 $\\mathsf{OVF}_{w}(a,b)$ 为真的 $w$ 位向量有序对 $(a,b)$ 的数量。我们可以将两种不相交的情况的计数相加：正溢出 ($N_{pos}$) 和负溢出 ($N_{neg}$)。令 $N = 2^{w-1}$。\n\n**1. 计数正溢出 ($N_{pos}$):**\n这种情况发生在和过大的非负整数对上。操作数必须满足 $\\operatorname{msb}(a)=0$ 和 $\\operatorname{msb}(b)=0$。这对应于整数值 $\\operatorname{int}(a)=x$ 和 $\\operatorname{int}(b)=y$，其中 $x, y \\in \\{0, 1, \\dots, N-1\\}$。$x$ 有 $N$ 个这样的值，$y$ 也有 $N$ 个，总共有 $N^2$ 对。\n如果 $x+y  N-1$，即 $x+y \\ge N$，则发生溢出。\n计算不溢出的对数（其中 $x+y \\le N-1$），然后从总数中减去，这样更容易。\n对于一个固定的 $x \\in \\{0, \\dots, N-1\\}$，$y$ 必须满足 $0 \\le y \\le N-1-x$。$y$ 的可能值的数量是 $(N-1-x) + 1 = N-x$。\n不溢出的总对数是所有可能的 $x$ 的总和：\n$$\n\\sum_{x=0}^{N-1} (N-x) = N + (N-1) + \\dots + 1 = \\sum_{k=1}^{N} k = \\frac{N(N+1)}{2}\n$$\n溢出的对数是总对数减去不溢出的对数：\n$$\nN_{pos} = N^2 - \\frac{N(N+1)}{2} = \\frac{2N^2 - N^2 - N}{2} = \\frac{N^2 - N}{2} = \\frac{N(N-1)}{2}\n$$\n\n**2. 计数负溢出 ($N_{neg}$):**\n这种情况发生在和过小的负整数对上。操作数必须满足 $\\operatorname{msb}(a)=1$ 和 $\\operatorname{msb}(b)=1$。这对应于整数值 $\\operatorname{int}(a)=x$ 和 $\\operatorname{int}(b)=y$，其中 $x, y \\in \\{-N, \\dots, -1\\}$。$x$ 有 $N$ 个这样的值，$y$ 也有 $N$ 个，总共有 $N^2$ 对。\n如果 $x+y  -N$，则发生溢出。\n为简化计数，我们使用正变量 $x' = -x$ 和 $y' = -y$，其中 $x', y' \\in \\{1, \\dots, N\\}$。溢出条件变为 $-x' - y'  -N$，这等价于 $x' + y'  N$。\n我们需要计算在正方形 $[1, N] \\times [1, N]$ 中满足 $x' + y' \\ge N+1$ 的整数对 $(x', y')$ 的数量。\n对于一个固定的 $x' \\in \\{1, \\dots, N\\}$，$y'$ 必须满足 $y' \\ge N+1-x'$。由于 $y' \\le N$，$y'$ 的可能值的数量是 $N - (N+1-x') + 1 = x'$。\n总计数 $N_{neg}$ 是所有可能的 $x'$ 的总和：\n$$\nN_{neg} = \\sum_{x'=1}^{N} x' = \\frac{N(N+1)}{2}\n$$\n\n**3. 总计数 $\\#\\mathcal{M}_{w}$：**\n溢出对的总数是两种情况的计数之和：\n$$\n\\#\\mathcal{M}_{w} = N_{pos} + N_{neg} = \\frac{N(N-1)}{2} + \\frac{N(N+1)}{2}\n$$\n$$\n\\#\\mathcal{M}_{w} = \\frac{N^2 - N + N^2 + N}{2} = \\frac{2N^2}{2} = N^2\n$$\n将 $N=2^{w-1}$ 代入表达式：\n$$\n\\#\\mathcal{M}_{w} = (2^{w-1})^2 = 2^{2(w-1)} = 2^{2w-2}\n$$\n因此，导致有符号溢出的有序对 $(a,b)$ 的数量是 $2^{2w-2}$。",
            "answer": "$$\\boxed{2^{2w-2}}$$"
        },
        {
            "introduction": "SAT 和 SMT 求解器通常作为更复杂算法（如属性导向可达性分析，PDR）的核心引擎。本练习提供了一个宝贵的机会，通过模拟 PDR 算法的单步执行，来揭示其内部工作机制。你将看到 PDR 如何利用一个不可满足的 SAT 查询来归纳地证明一个时序电路的安全性。",
            "id": "4295406",
            "problem": "考虑一个同步转换系统，该系统为一个由环境控制使能的单锁存器触发器建模。其状态由一个布尔锁存器 $s \\in \\{0,1\\}$ 和一个布尔输入 $en \\in \\{0,1\\}$ 组成。转换关系由下一状态更新公式 $s' = s \\oplus en$ 给出，其中 $\\oplus$ 表示布尔异或。初始条件为 $I(s) \\equiv (s = 0)$。在所有时间步，环境都遵循假设 $A(en) \\equiv (en = 0)$。待验证的安全性质是不变量 $P(s) \\equiv (\\lnot s)$，意味着锁存器 $s$ 在所有可达状态中必须保持为 $0$。\n\n性质导向可达性 (Property Directed Reachability, PDR) 是一种归纳不变量生成方法，它维护一个过近似帧序列 $\\{F_{i}\\}$，满足 $F_{0} \\equiv I$ 和对所有 $i \\geq 1$ 都有 $F_{i} \\subseteq P$，并使用布尔可满足性问题 (SAT) 查询通过前驱分析来阻塞反例。假设第一个帧 $F_{1}$ 最初关于 $s$ 是无约束的（即，它尚未包含强制执行 $P$ 的归纳子句），因此在层级 1 的一个潜在坏立方体 $c$ 是文字 $(s = 1)$，这违反了 $P$。\n\n模拟一次 PDR 迭代，该迭代试图通过检查来自 $F_{0}$ 的前驱来阻塞层级 1 的这个坏立方体 $c$。在转换关系和环境假设下，构建前驱 SAT 查询，\n$$\nI(s) \\,\\land\\, A(en) \\,\\land\\, T(s,en,s') \\,\\land\\, c'(s'),\n$$\n其中 $c'(s')$ 是立方体 $c$ 的下一状态版本，$T(s,en,s')$ 编码了 $s' = s \\oplus en$。确定此查询是否可满足。如果不可满足，则推断出 PDR 添加到 $F_{1}$ 中以阻塞 $c$ 的子句（仅用当前状态变量表示），并将其作为最终答案提供。最终答案必须是单一的 LaTeX 形式的闭式布尔表达式。不需要数值四舍五入，也没有单位适用。",
            "solution": "目标是模拟 PDR 算法的单步操作以阻塞一个坏立方体。坏立方体 $c$ 代表一个违反安全性质 $P(s) \\equiv (\\lnot s)$ 的状态。该性质要求 $s$ 始终为 $0$，因此违反它的状态是 $s=1$ 的状态。给定的坏立方体是 $c \\equiv (s=1)$。\n\nPDR 试图通过检查坏立方体是否可以从前一个帧 $F_0$ 中的某个状态到达，来在层级 1 阻塞这个坏立方体。这个检查被形式化为一个布尔可满足性 (SAT) 问题。该查询确定是否存在一个满足 $F_0$ 条件的状态 $s$、一个满足环境假设 $A(en)$ 的输入 $en$ 和一个满足坏立方体 $c'(s')$ 的下一状态 $s'$，使得 $(s, en, s')$ 是一个根据 $T$ 的有效转换。\n\nSAT 查询的组成部分是：\n$1.$ 初始条件帧 $F_0$：$I(s) \\equiv (s=0)$。\n$2.$ 环境假设：$A(en) \\equiv (en=0)$。\n$3.$ 转换关系：$T(s,en,s') \\equiv (s' = s \\oplus en)$。\n$4.$ 坏立方体的下一状态版本，代表违反性质的目标状态：$c'(s') \\equiv (s'=1)$。\n\n完整的 SAT 查询是这四个谓词的合取：\n$$\n\\Phi \\equiv I(s) \\land A(en) \\land T(s,en,s') \\land c'(s')\n$$\n代入具体的定义，查询变为：\n$$\n\\Phi \\equiv (s=0) \\land (en=0) \\land (s' = s \\oplus en) \\land (s'=1)\n$$\n为了确定 $\\Phi$ 的可满足性，我们可以将变量 $s$、$en$ 和 $s'$ 的约束代入转换关系中。\n从 $I(s)$，我们得到约束 $s=0$。\n从 $A(en)$，我们得到约束 $en=0$。\n从 $c'(s')$，我们得到约束 $s'=1$。\n\n将 $s=0$ 和 $en=0$ 代入转换关系 $s' = s \\oplus en$ 得到：\n$$\ns' = 0 \\oplus 0\n$$\n异或运算 $0 \\oplus 0$ 的结果是 $0$。因此，在这些约束下，转换关系简化为 $s'=0$。\n\n我们现在对下一状态 $s'$ 有两个相互矛盾的要求：\n- 从坏立方体 $c'$，我们要求 $s'=1$。\n- 从一个在 $F_0$ 中且符合环境假设的状态的转换，我们推断出 $s'=0$。\n\n合取 $(s'=1) \\land (s'=0)$ 是一个逻辑矛盾，等价于 `False`。因此，整个公式 $\\Phi$ 是不可满足的。\n\n在 PDR 的背景下，一个不可满足的前驱查询证明了坏立方体 $c$ 不能从帧 $F_0$ 一步到达。这意味着没有满足 $F_0$ 的状态可以转换到满足 $c$ 的状态。因为 $c$ 从 $F_0$ 是不可达的，PDR 可以通过向下一个帧 $F_1$ 添加一个排除 $c$ 的子句来“阻塞”$c$。\n\n坏立方体是 $c \\equiv (s=1)$。一个子句是文字的析取。为了阻塞或排除立方体 $c$，我们将其否定式 $\\lnot c$ 作为一个新子句添加到 $F_1$。\n要添加的子句是：\n$$\n\\lnot c \\equiv \\lnot(s=1)\n$$\n这在逻辑上等价于 $(s=0)$。在这种情况下常用的布尔逻辑表示法中，一个变量代表它为真（即等于 $1$）的命题，这个子句被写作 $\\lnot s$。\n\n这个新子句 $\\lnot s$ 被添加到定义 $F_1$ 的子句集合中。这通过确保任何满足 $F_1$ 条件的状态也必须满足 $\\lnot s$ 来加强 $F_1$，从而防止由 $c$ 代表的性质违规在从 $F_1$ 开始的算法后续步骤中被考虑。\n该子句按要求用当前状态变量 $s$ 表示。",
            "answer": "$$\n\\boxed{\\lnot s}\n$$"
        }
    ]
}