{
    "hands_on_practices": [
        {
            "introduction": "在评估任何调度算法的性能之前，我们首先需要建立一个理论上的“最佳”性能基准。这个练习将指导你计算调度的延迟下界，这是通过两种独立的方法实现的：分析最长数据依赖路径（即关键路径）和评估硬件资源的总需求。通过将启发式算法生成的调度结果与这个严格的下界进行比较，我们可以量化其“最优性差距”，这是衡量调度质量的关键指标 。",
            "id": "4275683",
            "problem": "考虑一个在电子设计自动化 (EDA) 领域的高层次综合 (HLS) 中进行调度的的数据流有向无环图 (DAG)。调度目标是在满足前驱约束和资源容量约束的情况下，以整数时间步为单位，最小化总延迟 (makespan)。所有操作都是不可抢占的，使用整数周期的持续时间，并在其执行区间内独占所需资源。一个周期内不允许链接 (chaining)，多周期操作符不进行流水线化，通信延迟可忽略不计。输入在时间 $0$ 可用。延迟以周期为单位度量，定义为所有操作中的最大完成时间。\n\n资源和容量：\n- 一个乘法器单元（$1$ 个乘法器），\n- 两个加法器单元（$2$ 个加法器），\n- 一个除法器单元（$1$ 个除法器）。\n\n操作类型和持续时间：\n- 乘法操作需要 $3$ 个周期，\n- 加法操作需要 $1$ 个周期，\n- 除法操作需要 $5$ 个周期。\n\n该 DAG 包含以下具有前驱约束的操作：\n\n- $O_{1}$：乘法器，持续时间 $3$，无前驱。\n- $O_{2}$：加法器，持续时间 $1$，无前驱。\n- $O_{3}$：乘法器，持续时间 $3$，前驱为 $O_{2}$。\n- $O_{4}$：加法器，持续时间 $1$，前驱为 $O_{1}$ 和 $O_{3}$。\n- $O_{5}$：除法器，持续时间 $5$，前驱为 $O_{4}$。\n- $O_{6}$：加法器，持续时间 $1$，前驱为 $O_{5}$。\n- $O_{7}$：乘法器，持续时间 $3$，前驱为 $O_{6}$。\n- $O_{8}$：加法器，持续时间 $1$，前驱为 $O_{7}$。\n- $O_{9}$：乘法器，持续时间 $3$，前驱为 $O_{1}$ 和 $O_{8}$。\n- $O_{10}$：加法器，持续时间 $1$，前驱为 $O_{9}$ 和 $O_{3}$。\n\n任务：\n1. 仅使用前驱约束，推导由 DAG 中最长依赖路径所决定的最小延迟下界。\n2. 仅使用资源容量约束，推导由每种资源类型的总占用时间所决定的最小延迟下界。\n3. 结合这两方面的考虑，得出可达到的最紧下界。\n4. 一个启发式列表调度（在所述资源限制下）产生了以下开始时间（每个操作 $O_{i}$ 在时间 $s_{i}$ 开始，运行其持续时间，并在区间 $[s_{i}, s_{i} + \\text{duration})$ 内占用其资源）：\n   - $O_{1}$：$s_{1} = 0$，\n   - $O_{2}$：$s_{2} = 0$，\n   - $O_{3}$：$s_{3} = 3$，\n   - $O_{4}$：$s_{4} = 6$，\n   - $O_{5}$：$s_{5} = 7$，\n   - $O_{6}$：$s_{6} = 12$，\n   - $O_{7}$：$s_{7} = 13$，\n   - $O_{8}$：$s_{8} = 16$，\n   - $O_{9}$：$s_{9} = 17$，\n   - $O_{10}$：$s_{10} = 20$。\n   计算此启发式调度的延迟，并将其与第 $1$–$3$ 部分得到的最紧下界进行比较。\n5. 报告最优性差距，即启发式调度延迟与最紧下界之间的差值，以周期为单位表示。请以单个数字形式提供最终答案。无需四舍五入。",
            "solution": "首先验证问题陈述的正确性和完整性。\n\n**步骤 1：提取已知条件**\n- **目标**：以整数时间步为单位，最小化总延迟 (makespan)。\n- **资源和容量**：一个乘法器单元 ($N_{\\text{mult}} = 1$)，两个加法器单元 ($N_{\\text{add}} = 2$)，一个除法器单元 ($N_{\\text{div}} = 1$)。\n- **操作类型和持续时间**：乘法操作需要 $d_{\\text{mult}} = 3$ 个周期，加法操作需要 $d_{\\text{add}} = 1$ 个周期，除法操作需要 $d_{\\text{div}} = 5$ 个周期。\n- **操作和前驱约束**：\n  - $O_{1}$：乘法器，持续时间 $3$，无前驱。\n  - $O_{2}$：加法器，持续时间 $1$，无前驱。\n  - $O_{3}$：乘法器，持续时间 $3$，前驱为 $O_{2}$。\n  - $O_{4}$：加法器，持续时间 $1$，前驱为 $O_{1}$ 和 $O_{3}$。\n  - $O_{5}$：除法器，持续时间 $5$，前驱为 $O_{4}$。\n  - $O_{6}$：加法器，持续时间 $1$，前驱为 $O_{5}$。\n  - $O_{7}$：乘法器，持续时间 $3$，前驱为 $O_{6}$。\n  - $O_{8}$：加法器，持续时间 $1$，前驱为 $O_{7}$。\n  - $O_{9}$：乘法器，持续时间 $3$，前驱为 $O_{1}$ 和 $O_{8}$。\n  - $O_{10}$：加法器，持续时间 $1$，前驱为 $O_{9}$ 和 $O_{3}$。\n- **启发式调度开始时间**：$s_{1} = 0$, $s_{2} = 0$, $s_{3} = 3$, $s_{4} = 6$, $s_{5} = 7$, $s_{6} = 12$, $s_{7} = 13$, $s_{8} = 16$, $s_{9} = 17$, $s_{10} = 20$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题是电子设计自动化 (EDA) 领域中高层次综合 (HLS) 的一个经典资源受限调度问题。\n- **科学依据**：该问题基于数字电路设计、调度理论和计算机体系结构的既定基本原则。\n- **定义明确**：所有必要信息——资源容量、操作持续时间和前驱约束——均已提供。目标明确陈述，确保每个部分都可以推导出唯一的解。\n- **用语**：问题使用了该领域精确、无歧义的标准术语进行描述。\n该问题完整、一致且科学上合理。未发现任何缺陷。\n\n**步骤 3：结论与行动**\n该问题有效。将推导出一个完整的解答。\n\n**求解过程**\n\n求解过程将按顺序解决五个任务中的每一个。\n\n**1. 基于前驱的延迟下界（关键路径）**\n任何调度的最小延迟都受限于数据流图 (DAG) 中的最长路径，即关键路径。此路径的长度是其构成操作的持续时间之和。我们可以通过计算每个操作的最早开始时间 ($EST$) 和最早完成时间 ($EF$) 来找到它。对于一个持续时间为 $d_i$、前驱集合为 $\\text{preds}(O_i)$ 的操作 $O_i$：\n$$EST(O_i) = \\max_{O_j \\in \\text{preds}(O_i)} \\{EF(O_j)\\}$$\n$$EF(O_i) = EST(O_i) + d_i$$\n对于没有前驱的操作，$EST = 0$。各操作的持续时间为 $d_1=3, d_2=1, d_3=3, d_4=1, d_5=5, d_6=1, d_7=3, d_8=1, d_9=3, d_{10}=1$。\n\n- $O_1$: $EST(O_1) = 0$，因此 $EF(O_1) = 0 + 3 = 3$。\n- $O_2$: $EST(O_2) = 0$，因此 $EF(O_2) = 0 + 1 = 1$。\n- $O_3$ (前驱 $O_2$): $EST(O_3) = EF(O_2) = 1$，因此 $EF(O_3) = 1 + 3 = 4$。\n- $O_4$ (前驱 $O_1, O_3$): $EST(O_4) = \\max(EF(O_1), EF(O_3)) = \\max(3, 4) = 4$，因此 $EF(O_4) = 4 + 1 = 5$。\n- $O_5$ (前驱 $O_4$): $EST(O_5) = EF(O_4) = 5$，因此 $EF(O_5) = 5 + 5 = 10$。\n- $O_6$ (前驱 $O_5$): $EST(O_6) = EF(O_5) = 10$，因此 $EF(O_6) = 10 + 1 = 11$。\n- $O_7$ (前驱 $O_6$): $EST(O_7) = EF(O_6) = 11$，因此 $EF(O_7) = 11 + 3 = 14$。\n- $O_8$ (前驱 $O_7$): $EST(O_8) = EF(O_7) = 14$，因此 $EF(O_8) = 14 + 1 = 15$。\n- $O_9$ (前驱 $O_1, O_8$): $EST(O_9) = \\max(EF(O_1), EF(O_8)) = \\max(3, 15) = 15$，因此 $EF(O_9) = 15 + 3 = 18$。\n- $O_{10}$ (前驱 $O_9, O_3$): $EST(O_{10}) = \\max(EF(O_9), EF(O_3)) = \\max(18, 4) = 18$，因此 $EF(O_{10}) = 18 + 1 = 19$。\n\n关键路径长度是所有操作中的最大最早完成时间。这决定了基于前驱的延迟下界 $L_{\\text{precedence}}$。\n$$L_{\\text{precedence}} = \\max(3, 1, 4, 5, 10, 11, 14, 15, 18, 19) = 19 \\text{ 周期。}$$\n\n**2. 基于资源的延迟下界**\n延迟也受限于每种资源类型的总执行需求。对于每种拥有 $N_k$ 个单元的资源类型 $k$，其下界是该类型所有操作的总持续时间除以 $N_k$，并向上取整（ceiling function）。\n$$L_{\\text{resource}, k} = \\left\\lceil \\frac{\\sum_{i \\in \\text{ops of type } k} d_i}{N_k} \\right\\rceil$$\n\n- **乘法器**：有 $4$ 个乘法操作 ($O_1, O_3, O_7, O_9$)，每个需要 $3$ 个周期。共有 $N_{\\text{mult}} = 1$ 个乘法器。\n$$L_{\\text{mult}} = \\left\\lceil \\frac{4 \\times 3}{1} \\right\\rceil = \\lceil 12 \\rceil = 12 \\text{ 周期。}$$\n- **加法器**：有 $5$ 个加法操作 ($O_2, O_4, O_6, O_8, O_{10}$)，每个需要 $1$ 个周期。共有 $N_{\\text{add}} = 2$ 个加法器。\n$$L_{\\text{add}} = \\left\\lceil \\frac{5 \\times 1}{2} \\right\\rceil = \\lceil 2.5 \\rceil = 3 \\text{ 周期。}$$\n- **除法器**：有 $1$ 个除法操作 ($O_5$)，需要 $5$ 个周期。共有 $N_{\\text{div}} = 1$ 个除法器。\n$$L_{\\text{div}} = \\left\\lceil \\frac{1 \\times 5}{1} \\right\\rceil = \\lceil 5 \\rceil = 5 \\text{ 周期。}$$\n总的基于资源的下界 $L_{\\text{resource}}$ 是这些下界中的最大值。\n$$L_{\\text{resource}} = \\max(L_{\\text{mult}}, L_{\\text{add}}, L_{\\text{div}}) = \\max(12, 3, 5) = 12 \\text{ 周期。}$$\n\n**3. 最紧下界**\n真正的最小延迟必须同时满足前驱约束和资源约束。因此，最紧下界 $L_{\\text{lower\\_bound}}$ 是从这两个独立方面推导出的下界中的最大值。\n$$L_{\\text{lower\\_bound}} = \\max(L_{\\text{precedence}}, L_{\\text{resource}}) = \\max(19, 12) = 19 \\text{ 周期。}$$\n\n**4. 启发式调度的延迟**\n给定启发式调度的延迟是其 makespan，即所有操作中的最大完成时间。操作 $O_i$ 的完成时间 $f_i$ 是其开始时间 $s_i$ 加上其持续时间 $d_i$。\n- $f_1 = s_1 + d_1 = 0 + 3 = 3$。\n- $f_2 = s_2 + d_2 = 0 + 1 = 1$。\n- $f_3 = s_3 + d_3 = 3 + 3 = 6$。\n- $f_4 = s_4 + d_4 = 6 + 1 = 7$。\n- $f_5 = s_5 + d_5 = 7 + 5 = 12$。\n- $f_6 = s_6 + d_6 = 12 + 1 = 13$。\n- $f_7 = s_7 + d_7 = 13 + 3 = 16$。\n- $f_8 = s_8 + d_8 = 16 + 1 = 17$。\n- $f_9 = s_9 + d_9 = 17 + 3 = 20$。\n- $f_{10} = s_{10} + d_{10} = 20 + 1 = 21$。\n该调度的延迟 $L_{\\text{heuristic}}$ 是这些完成时间中的最大值。\n$$L_{\\text{heuristic}} = \\max(3, 1, 6, 7, 12, 13, 16, 17, 20, 21) = 21 \\text{ 周期。}$$\n将其与下界进行比较，$L_{\\text{heuristic}} = 21 > L_{\\text{lower\\_bound}} = 19$，这证实了该调度未被证明是最优的。\n\n**5. 最优性差距**\n最优性差距是启发式调度的延迟与最紧下界之间的差值。\n$$\\text{最优性差距} = L_{\\text{heuristic}} - L_{\\text{lower\\_bound}} = 21 - 19 = 2 \\text{ 周期。}$$\n该值表示启发式解超出理论最小可能延迟的周期数。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "在了解了如何评估调度质量后，下一步是探索如何生成一个高质量的调度。力导向调度（Force-Directed Scheduling, FDS）是一种经典的高级综合启发式算法，它通过在所有时间步上均衡资源使用来优化调度。本练习将带你手动执行FDS算法的核心步骤，通过计算将一个操作安排在不同时间步的“力”，来为该操作选择最佳的调度位置 。",
            "id": "4275720",
            "problem": "考虑一个用于高级综合（HLS）的同步数据流图（DFG），其调度基于以下假设和定义：一个 DFG 是一个有向无环图，其中节点代表操作，边代表优先约束；对于每个节点，根据一个全局延迟界限，定义了其尽早（ASAP）时间和尽晚（ALAP）时间；一个节点的可行时间步构成了其从 ASAP 到 ALAP（含两端）的移动窗口；为每个未调度的节点 $i$ 在其移动窗口内分配一个概率分布 $P_{i}(t)$，使得 $P_{i}(t)$ 在其可行时间步上是均匀分布的，而在其他地方为零；对于每种资源类型 $k$，资源使用分布为 $R_{k}(t) = \\sum_{i \\in \\mathcal{I}_{k}} P_{i}(t)$，其中 $\\mathcal{I}_{k}$ 是类型为 $k$ 的节点集合；并且，调度质量成本是所有资源类型上资源使用量平方的时间总和，$C = \\sum_{k} \\sum_{t=1}^{L} R_{k}(t)^{2}$。力导向调度（FDS）选择一个能最大程度减小 $C$ 的节点-时间分配方案，其方法是使用 $C$ 相对于由在特定时间分配一个节点所引起的分布变化的梯度。这些变化包括对该节点本身的影响，以及通过优先约束引起的移动窗口收紧对其直接前驱和直接后继节点的影响。\n\n给定一个小型 DFG，它有两种资源类型（加法器和乘法器），单位延迟，以及一个全局延迟界限 $L=6$ 个时间步。节点如下：\n- $n_{1}$：乘法，前驱节点无，后继节点 $n_{3}$。\n- $n_{2}$：加法，前驱节点无，后继节点 $n_{3}$。\n- $n_{3}$：加法，前驱节点 $n_{1}, n_{2}$，后继节点 $n_{4}$。\n- $n_{4}$：乘法，前驱节点 $n_{3}$，后继节点无。\n\n所有操作的延迟均为 $1$ 个时间步。在迭代开始时，没有节点被调度；每个节点的初始 $P_{i}(t)$ 在由界限 $L$ 导出的 ASAP-ALAP 窗口上是均匀分布的。如上定义，将资源分布视为每种资源类型的节点分布之和。在评估将 $n_{3}$ 分配到时间 $t$ 的候选方案时，将引起的变化建模为：$n_{3}$ 自身分布的变化，从其窗口上的均匀分布变为在 $t$ 处的一个单位脉冲；收紧其前驱节点的窗口，使其 ALAP 变为 $t-1$（如果这比它们当前的 ALAP 更紧），并收紧其后继节点的窗口，使其 ASAP 变为 $t+1$（如果这比它当前的 ASAP 更紧）；并利用这些收紧的窗口为前驱和后继节点导出更新后的均匀分布，而不完全调度它们。计算在 $n_{3}$ 的每个可行时间 $t$ 上的总力，其计算方式为资源分布变化向量与当前迭代中 $C$ 相对于这些分布的梯度之间的内积。\n\n手动对节点 $n_{3}$ 执行一次力导向调度迭代：计算其 ASAP 和 ALAP，推导初始的 $P_{i}(t)$ 和 $R_{k}(t)$，评估每个可行时间 $t$ 的总力，选择使总力最小化的时间 $t^{\\ast}$，并相应地更新分布。仅报告为 $n_{3}$ 选择的时间步 $t^{\\ast}$。无需四舍五入；以整数形式提供 $t^{\\ast}$。",
            "solution": "该问题陈述是高级综合调度中一个有效且定义明确的练习，特别关注力导向调度（FDS）算法。它提供了一个完整的数据流图（DFG）规范、延迟约束，以及对成本函数和待执行计算步骤的清晰定义。该问题在科学上基于电子设计自动化的原理，没有任何矛盾或歧义。\n\n我们将执行一次 FDS 算法迭代，以确定调度操作 $n_{3}$ 的最佳时间步。这包括以下步骤：\n1.  为所有节点计算初始的尽早（ASAP）和尽晚（ALAP）调度。\n2.  确定每个节点 $i$ 的初始概率分布 $P_{i}(t)$ 以及每种资源类型 $k$ 对应的资源使用分布 $R_{k}(t)$。\n3.  对于节点 $n_{3}$ 移动窗口中的每个可行时间步 $t$，计算与试探性地将 $n_{3}$ 调度在时间 $t$ 相关联的“总力”。总力是成本函数 $C = \\sum_{k} \\sum_{t=1}^{L} R_{k}(t)^{2}$ 预期变化的一种度量。根据规定，我们使用 $C$ 变化的一阶近似来计算这个力，即 $C$ 的梯度与资源分布变化向量的内积。将 $n_3$ 分配到时间 $t$ 的力由 $F(t) = \\sum_{k} \\sum_{t_j=1}^{L} \\frac{\\partial C} {\\partial R_k(t_j)} \\Delta R_k(t_j) = \\sum_{k} \\sum_{t_j=1}^{L} 2R_k(t_j) \\Delta R_k(t_j)$ 给出。\n4.  选择使总力最小化的时间步 $t^{\\ast}$。\n\n首先，我们计算初始的 ASAP 和 ALAP 时间。所有操作的延迟均为 $d_i=1$。全局延迟界限为 $L=6$。\n\nASAP 时间通过从源节点开始的正向遍历计算：\n- $ASAP(n_{1}) = 1$\n- $ASAP(n_{2}) = 1$\n- $ASAP(n_{3}) = \\max(ASAP(n_{1}) + d(n_{1}), ASAP(n_{2}) + d(n_{2})) = \\max(1+1, 1+1) = 2$\n- $ASAP(n_{4}) = ASAP(n_{3}) + d(n_{3}) = 2+1 = 3$\n\nALAP 时间通过从汇点开始的反向遍历计算。一个操作 $i$ 必须在时间 $L$ 之前完成，所以其开始时间 $t$ 必须满足 $t+d(i)-1 \\le L$，即 $t \\le L-d(i)+1$。\n- $ALAP(n_{4}) = L - d(n_{4}) + 1 = 6-1+1 = 6$\n- $ALAP(n_{3}) = ALAP(n_{4}) - d(n_{3}) = 6 - 1 = 5$\n- $ALAP(n_{1}) = ALAP(n_{3}) - d(n_{1}) = 5 - 1 = 4$\n- $ALAP(n_{2}) = ALAP(n_{3}) - d(n_{2}) = 5 - 1 = 4$\n\n初始的移动窗口 $[ASAP_i, ALAP_i]$ 为：\n- $n_{1}$ (乘法器): $[1, 4]$, 移动性 $4$\n- $n_{2}$ (加法器): $[1, 4]$, 移动性 $4$\n- $n_{3}$ (加法器): $[2, 5]$, 移动性 $4$\n- $n_{4}$ (乘法器): $[3, 6]$, 移动性 $4$\n\n初始概率分布 $P_{i}(t)$ 在这些窗口上是均匀的：\n- $P_{1}(t) = 1/4$ 对于 $t \\in [1, 4]$; 否则为 $0$。\n- $P_{2}(t) = 1/4$ 对于 $t \\in [1, 4]$; 否则为 $0$。\n- $P_{3}(t) = 1/4$ 对于 $t \\in [2, 5]$; 否则为 $0$。\n- $P_{4}(t) = 1/4$ 对于 $t \\in [3, 6]$; 否则为 $0$。\n\n初始资源分布 $R_{k}(t)$ 为：\n- 对于乘法器 ($\\mathcal{I}_{mult} = \\{n_1, n_4\\}$): $R_{mult}(t) = P_{1}(t) + P_{4}(t)$。\n  - $R_{mult}(1) = 1/4$, $R_{mult}(2) = 1/4$, $R_{mult}(3) = 1/4+1/4=1/2$, $R_{mult}(4) = 1/4+1/4=1/2$, $R_{mult}(5) = 1/4$, $R_{mult}(6) = 1/4$。\n- 对于加法器 ($\\mathcal{I}_{add} = \\{n_2, n_3\\}$): $R_{add}(t) = P_{2}(t) + P_{3}(t)$。\n  - $R_{add}(1) = 1/4$, $R_{add}(2) = 1/4+1/4=1/2$, $R_{add}(3) = 1/4+1/4=1/2$, $R_{add}(4) = 1/4+1/4=1/2$, $R_{add}(5) = 1/4$, $R_{add}(6) = 0$。\n\n现在，我们为 $n_{3}$ 的每个可行时间步 $t \\in [2, 5]$ 评估其力。\n\n情况 1：尝试性分配 $n_{3} \\to t=2$\n- $n_3$ 被分配到 $t=2$。其前驱节点 $n_1, n_2$ 的 ALAP 变为 $t-1=1$，导致其窗口收缩为 $[1,1]$。其后继节点 $n_4$ 的 ASAP 变为 $t+1=3$，其窗口 $[3,6]$ 无变化。\n- 资源分布变化 $\\Delta R_k = \\sum_{i \\in \\mathcal{I}_k} (P'_i - P_i)$：\n  - $\\Delta R_{mult}(t) = \\Delta P_{1}(t)$: $\\Delta R_{mult}(1)=3/4$; $\\Delta R_{mult}(t)=-1/4$ 对于 $t \\in \\{2,3,4\\}$。\n  - $\\Delta R_{add}(t) = \\Delta P_{2}(t) + \\Delta P_{3}(t)$: $\\Delta R_{add}(1)=3/4$; $\\Delta R_{add}(2)=-1/4+3/4=1/2$; $\\Delta R_{add}(3)=-1/4-1/4=-1/2$; $\\Delta R_{add}(4)=-1/4-1/4=-1/2$; $\\Delta R_{add}(5)=-1/4$。\n- 力计算：\n  - $F_{mult}(2) = 2 \\sum R_{mult}(t_j)\\Delta R_{mult}(t_j) = 2[ (1/4)(3/4) + (1/4)(-1/4) + (1/2)(-1/4) + (1/2)(-1/4) ] = 2[3/16 - 1/16 - 2/16 - 2/16] = 2[-2/16] = -1/4$。\n  - $F_{add}(2) = 2 \\sum R_{add}(t_j)\\Delta R_{add}(t_j) = 2[ (1/4)(3/4) + (1/2)(1/2) + (1/2)(-1/2) + (1/2)(-1/2) + (1/4)(-1/4) ] = 2[3/16 + 1/4 - 1/4 - 1/4 - 1/16] = 2[-2/16] = -1/4$。\n  - 总力 $F(2) = -1/4 - 1/4 = -1/2$。\n\n情况 2：尝试性分配 $n_{3} \\to t=3$\n- $n_1, n_2$ 的 ALAP 变为 $t-1=2$，窗口收缩为 $[1,2]$。$n_4$ 的 ASAP 变为 $t+1=4$，窗口收缩为 $[4,6]$。\n- $\\Delta R_{mult}(t)$: $\\Delta R_{mult}(1)=1/4, \\Delta R_{mult}(2)=1/4, \\Delta R_{mult}(3)=-1/2, \\Delta R_{mult}(4)=-1/6, \\Delta R_{mult}(5)=1/12, \\Delta R_{mult}(6)=1/12$。\n- $\\Delta R_{add}(t)$: $\\Delta R_{add}(1)=1/4, \\Delta R_{add}(2)=0, \\Delta R_{add}(3)=1/2, \\Delta R_{add}(4)=-1/2, \\Delta R_{add}(5)=-1/4$。\n- 力计算：\n  - $F_{mult}(3) = 2[ (1/4)(1/4) + (1/4)(1/4) + (1/2)(-1/2) + (1/2)(-1/6) + (1/4)(1/12) + (1/4)(1/12) ] = 2[(3-6-2+1)/24] = 2[-4/24] = -1/3$。\n  - $F_{add}(3) = 2[ (1/4)(1/4) + (1/2)(0) + (1/2)(1/2) + (1/2)(-1/2) + (1/4)(-1/4) ] = 2[1/16 - 1/16] = 0$。\n  - 总力 $F(3) = -1/3 + 0 = -1/3$。\n\n情况 3：尝试性分配 $n_{3} \\to t=4$\n- $n_1, n_2$ 的 ALAP 变为 $t-1=3$，窗口收缩为 $[1,3]$。$n_4$ 的 ASAP 变为 $t+1=5$，窗口收缩为 $[5,6]$。\n- $\\Delta R_{mult}(t)$: $\\Delta R_{mult}(1)=1/12, \\Delta R_{mult}(2)=1/12, \\Delta R_{mult}(3)=-1/6, \\Delta R_{mult}(4)=-1/2, \\Delta R_{mult}(5)=1/4, \\Delta R_{mult}(6)=1/4$。\n- $\\Delta R_{add}(t)$: $\\Delta R_{add}(1)=1/12, \\Delta R_{add}(2)=-1/6, \\Delta R_{add}(3)=-1/6, \\Delta R_{add}(4)=1/2, \\Delta R_{add}(5)=-1/4$。\n- 力计算：\n  - $F_{mult}(4) = 2[ (1/4)(1/12) + (1/4)(1/12) + (1/2)(-1/6) + (1/2)(-1/2) + (1/4)(1/4) + (1/4)(1/4) ] = 2[(1-2-6+3)/24] = 2[-4/24] = -1/3$。\n  - $F_{add}(4) = 2[ (1/4)(1/12) + (1/2)(-1/6) + (1/2)(-1/6) + (1/2)(1/2) + (1/4)(-1/4) ] = 2[(1-4-4+12-3)/48] = 2[2/48] = 1/12$。\n  - 总力 $F(4) = -1/3 + 1/12 = -4/12 + 1/12 = -3/12 = -1/4$。\n\n情况 4：尝试性分配 $n_{3} \\to t=5$\n- $n_1, n_2$ 的 ALAP 变为 $t-1=4$，窗口 $[1,4]$ 无变化。$n_4$ 的 ASAP 变为 $t+1=6$，窗口收缩为 $[6,6]$。\n- $\\Delta R_{mult}(t) = \\Delta P_{4}(t)$: $\\Delta R_{mult}(3)=-1/4, \\Delta R_{mult}(4)=-1/4, \\Delta R_{mult}(5)=-1/4, \\Delta R_{mult}(6)=3/4$。\n- $\\Delta R_{add}(t) = \\Delta P_{3}(t)$: $\\Delta R_{add}(2)=-1/4, \\Delta R_{add}(3)=-1/4, \\Delta R_{add}(4)=-1/4, \\Delta R_{add}(5)=3/4$。\n- 力计算：\n  - $F_{mult}(5) = 2[ (1/2)(-1/4) + (1/2)(-1/4) + (1/4)(-1/4) + (1/4)(3/4) ] = 2[-1/8 - 1/8 - 1/16 + 3/16] = 2[-1/8] = -1/4$。\n  - $F_{add}(5) = 2[ (1/2)(-1/4) + (1/2)(-1/4) + (1/2)(-1/4) + (1/4)(3/4) ] = 2[-1/8 - 1/8 - 1/8 + 3/16] = 2[-3/16] = -3/8$。\n  - 总力 $F(5) = -1/4 - 3/8 = -5/8$。\n\n力总结：\n- $F(2) = -1/2 = -0.5$\n- $F(3) = -1/3 \\approx -0.333$\n- $F(4) = -1/4 = -0.25$\n- $F(5) = -5/8 = -0.625$\n\n比较这些值，最小的力是 $F(5) = -5/8$。FDS 算法选择导致成本函数下降最大的分配，这对应于最负的力。\n因此，为节点 $n_{3}$ 选择的时间步是 $t^{\\ast}=5$。",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "对于许多计算密集型设计而言，循环是性能的关键所在，因此需要专门的优化技术。模调度（Modulo Scheduling）是一种强大的软件流水线技术，旨在通过重叠执行连续的循环迭代来最大化吞吐率。在这个练习中，你将通过计算资源和递归约束下的最小启动间隔（Initiation Interval, $II$），并构建一个满足所有约束的有效调度方案，从而掌握优化循环性能的核心方法 。",
            "id": "4275730",
            "problem": "给定一个用于高层次综合 (HLS) 的单基本块循环核，需要使用带有模调度的软件流水进行调度。每个迭代索引 $i$ 的循环体包含以下操作：\n- 一个乘法操作 $M_i$，使用一个延迟为 $L_{\\mathrm{mul}}=2$ 的乘法器。\n- 两个加法操作 $A1_i$ 和 $A2_i$，使用一个延迟为 $L_{\\mathrm{add}}=1$ 的加法器。\n- 一个移位操作 $S_i$，使用一个延迟为 $L_{\\mathrm{shf}}=1$ 的移位器。\n\n每个周期可用的资源为一个乘法器、一个加法器和一个移位器。该循环的依赖图具有以下边，其距离以循环迭代次数为单位：\n- 距离为 $0$ 的迭代内依赖：$M_i \\to A1_i$、$A1_i \\to S_i$、$S_i \\to A2_i$。\n- 距离为 $1$ 的循环携带依赖：$A2_i \\to M_{i+1}$。\n\n仅使用以下基本定义：\n- 启动间隔 (II) 是模调度中连续循环迭代开始时间之间的周期数。\n- 资源约束下限由每个资源每次迭代的需求相对于其每个周期的可用性决定。\n- 递归约束下限由最长的数据依赖递归决定，该递归以沿任何依赖环路的总延迟除以迭代距离来衡量。\n- 模调度约束要求，对于每个距离为 $d$ 的依赖边 $u \\to v$，模开始时间 $s(u)$ 和 $s(v)$ 必须满足 $s(v) - s(u) \\geq \\text{latency}(u) - II \\cdot d$，并且在任何模 $II$ 的余数类中，使用给定资源的操作数量不得超过其可用实例数，\n\n请完成以下任务：\n1. 通过计算资源约束和递归约束的下限，并取其中起主导作用的一个，来确定理论上可达到的最小启动间隔。\n2. 在此启动间隔下，通过在 $\\{0,1,\\dots, II-1\\}$ 中分配余数类开始时间 $s(M)$、$s(A1)$、$s(S)$、$s(A2)$ 来构建一个有效的模调度，该调度满足所有模依赖约束，并且不违反每个余数类的资源使用。\n3. 对您选择的余数类开始时间明确地验证这些约束。\n\n在最终答案中，将最小可行启动间隔 $II$ 报告为单个整数。最终答案中不需要中间步骤。无需四舍五入。",
            "solution": "问题陈述经评估有效。它在科学上基于高层次综合的原理，问题设定良好，数据充分且一致，并以客观、正式的语言表达。该问题是模调度中的一个标准练习，没有明显缺陷。因此，我们可以着手解决。\n\n任务是确定给定循环核的理论最小启动间隔 ($II$)，为此 $II$ 构建一个有效的模调度，并验证其正确性。最小 $II$ 由两个下限中更严格的一个决定：资源约束下限 ($ResII$) 和递归约束下限 ($RecII$)。最小可行 $II$ 由 $II_{\\min} = \\max(ResII, RecII)$ 给出。\n\n1.  **确定最小启动间隔 ($II$)**\n\n    a. **资源约束下限 ($ResII$)**\n    $ResII$ 由使用最频繁的资源决定。对于每种资源类型 $R$，其下限是需要该资源的操作数 ($N_R$) 与该类型可用功能单元数 ($C_R$) 之比的向上取整。\n    $ResII_R = \\lceil \\frac{N_R}{C_R} \\rceil$\n\n    -   **乘法器**：有一个乘法操作 ($M_i$)，因此 $N_{\\mathrm{mul}} = 1$。有一个可用的乘法器单元，因此 $C_{\\mathrm{mul}} = 1$。\n        $ResII_{\\mathrm{mul}} = \\lceil \\frac{1}{1} \\rceil = 1$\n    -   **加法器**：有两个加法操作 ($A1_i$ 和 $A2_i$)，因此 $N_{\\mathrm{add}} = 2$。有一个可用的加法器单元，因此 $C_{\\mathrm{add}} = 1$。\n        $ResII_{\\mathrm{add}} = \\lceil \\frac{2}{1} \\rceil = 2$\n    -   **移位器**：有一个移位操作 ($S_i$)，因此 $N_{\\mathrm{shf}} = 1$。有一个可用的移位器单元，因此 $C_{\\mathrm{shf}} = 1$。\n        $ResII_{\\mathrm{shf}} = \\lceil \\frac{1}{1} \\rceil = 1$\n\n    整体的资源约束下限是这些单独下限中的最大值：\n    $ResII = \\max(ResII_{\\mathrm{mul}}, ResII_{\\mathrm{add}}, ResII_{\\mathrm{shf}}) = \\max(1, 2, 1) = 2$。\n\n    b. **递归约束下限 ($RecII$)**\n    $RecII$ 由依赖图中形成环路的数据依赖决定。对于任何递归环路，$II$ 必须足够大，以容纳环路中操作的总延迟，并将其分布在环路的总迭代距离上。公式为 $RecII = \\max_{\\text{cycles } c} \\left( \\lceil \\frac{\\sum_{u \\in c} \\text{latency}(u)}{\\sum_{e \\in c} \\text{distance}(e)} \\rceil \\right)$。\n\n    问题描述了一个单一的递归环路：$M_i \\to A1_i \\to S_i \\to A2_i \\to M_{i+1}$。\n    让我们分析这个环路的属性：\n    -   环路中的依赖边：$M \\to A1$、$A1 \\to S$、$S \\to A2$、$A2 \\to M$。\n    -   总延迟是环路中每个边的源操作延迟之和：\n        $L_{\\text{cycle}} = \\text{latency}(M) + \\text{latency}(A1) + \\text{latency}(S) + \\text{latency}(A2)$。\n        -   边 $M \\to A1$ 的源是 $M$，延迟为 $L_{\\mathrm{mul}} = 2$。\n        -   边 $A1 \\to S$ 的源是 $A1$，延迟为 $L_{\\mathrm{add}} = 1$。\n        -   边 $S \\to A2$ 的源是 $S$，延迟为 $L_{\\mathrm{shf}} = 1$。\n        -   边 $A2 \\to M$ 的源是 $A2$，延迟为 $L_{\\mathrm{add}} = 1$。\n        总延迟：$L_{\\text{cycle}} = 2 + 1 + 1 + 1 = 5$。\n    -   总距离是环路中每个边的迭代距离之和：\n        $D_{\\text{cycle}} = d(M \\to A1) + d(A1 \\to S) + d(S \\to A2) + d(A2 \\to M)$。\n        -   $d(M \\to A1) = 0$ (迭代内)。\n        -   $d(A1 \\to S) = 0$ (迭代内)。\n        -   $d(S \\to A2) = 0$ (迭代内)。\n        -   $d(A2_i \\to M_{i+1}) = 1$ (循环携带)。\n        总距离：$D_{\\text{cycle}} = 0 + 0 + 0 + 1 = 1$。\n\n    该环路的递归约束下限为：\n    $RecII = \\lceil \\frac{L_{\\text{cycle}}}{D_{\\text{cycle}}} \\rceil = \\lceil \\frac{5}{1} \\rceil = 5$。\n\n    c. **最小启动间隔**\n    最小理论 $II$ 是两个下限中的最大值：\n    $II_{\\min} = \\max(ResII, RecII) = \\max(2, 5) = 5$。\n    我们现在尝试为 $II=5$ 寻找一个有效的调度。\n\n2.  **为 $II=5$ 构建模调度**\n\n    我们必须在集合 $\\{0, 1, 2, 3, 4\\}$ 中找到余数类开始时间 $s(M)$、$s(A1)$、$s(S)$、$s(A2)$。这些时间必须同时满足依赖约束和资源约束。\n\n    a. **依赖约束**\n    对于每个距离为 $d$ 的依赖边 $u \\to v$，模开始时间必须满足 $s(v) - s(u) \\geq \\text{latency}(u) - II \\cdot d$。当 $II=5$ 时：\n    -   $M \\to A1$：$d=0$，$\\text{latency}(M)=2 \\implies s(A1) - s(M) \\geq 2$。\n    -   $A1 \\to S$：$d=0$，$\\text{latency}(A1)=1 \\implies s(S) - s(A1) \\geq 1$。\n    -   $S \\to A2$：$d=0$，$\\text{latency}(S)=1 \\implies s(A2) - s(S) \\geq 1$。\n    -   $A2 \\to M$：$d=1$，$\\text{latency}(A2)=1 \\implies s(M) - s(A2) \\geq 1 - 5 \\cdot 1 = -4$。\n\n    b. **资源约束**\n    在任何模5的余数类中，使用某一资源的操作数量不得超过其容量。\n    -   乘法器 (容量 $1$)：$s(M)$ 在所有乘法操作中必须是唯一的。这是显然的，因为只有一个乘法操作。\n    -   加法器 (容量 $1$)：两个加法操作 $A1$ 和 $A2$ 必须被调度在不同的余数类中。$s(A1) \\neq s(A2)$。\n    -   移位器 (容量 $1$)：$s(S)$ 在所有移位操作中必须是唯一的。这是显然的。\n\n    c. **寻找调度**\n    让我们尝试通过为 $M$ 分配一个开始时间并传播约束来调度操作。一个常见的启发式方法是尽早调度操作。设 $s(M)=0$。\n    -   从 $s(A1) - s(M) \\geq 2$ 可得 $s(A1) \\geq 0 + 2 = 2$。我们尝试最早可能的时间，$s(A1)=2$。\n    -   从 $s(S) - s(A1) \\geq 1$ 可得 $s(S) \\geq 2 + 1 = 3$。我们尝试 $s(S)=3$。\n    -   从 $s(A2) - s(S) \\geq 1$ 可得 $s(A2) \\geq 3 + 1 = 4$。我们尝试 $s(A2)=4$。\n\n    我们的候选调度是：$s(M)=0$，$s(A1)=2$，$s(S)=3$，$s(A2)=4$。\n\n3.  **调度验证**\n\n    我们针对 $II=5$ 的所有约束来验证此候选调度。\n    \n    a. **依赖约束验证**：\n    -   $M \\to A1$：$s(A1) - s(M) = 2 - 0 = 2$。约束为 $2 \\geq 2$。**满足。**\n    -   $A1 \\to S$：$s(S) - s(A1) = 3 - 2 = 1$。约束为 $1 \\geq 1$。**满足。**\n    -   $S \\to A2$：$s(A2) - s(S) = 4 - 3 = 1$。约束为 $1 \\geq 1$。**满足。**\n    -   $A2 \\to M$：$s(M) - s(A2) = 0 - 4 = -4$。约束为 $-4 \\geq -4$。**满足。**\n\n    b. **资源约束验证**：\n    -   乘法器：操作 $M$ 被调度在时间 $0$。无冲突。\n    -   加法器：操作 $A1$ 在时间 $2$，操作 $A2$ 在时间 $4$。由于 $s(A1) \\neq s(A2)$ ($2 \\neq 4$)，加法器没有资源冲突。**满足。**\n    -   移位器：操作 $S$ 被调度在时间 $3$。无冲突。\n\n    由于对于 $II=5$ 存在一个有效的调度，并且已经证明 $II$ 不能小于 $5$，因此最小可行启动间隔确实是 $5$。",
            "answer": "$$\\boxed{5}$$"
        }
    ]
}