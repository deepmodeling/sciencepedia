## 引言
高层次综合（High-Level Synthesis, HLS）已成为现代[硬件设计](@entry_id:170759)流程中不可或缺的一环，它通过将高级语言（如C/C++/SystemC）描述的行为自动转换为[寄存器传输级](@entry_id:754197)（RTL）实现，极大地提升了设计效率。在这一转换过程中，**调度（Scheduling）**扮演着至关重要的角色，它负责将算法中的每一个操作精确地安排到特定的[时钟周期](@entry_id:165839)执行。一个优秀的调度方案是实现高性能、低面积、低功耗硬件加速器的关键，但它也面临着在[数据依赖](@entry_id:748197)、[资源限制](@entry_id:192963)和时序目标等多重约束下寻找最优解的巨大挑战。

本文旨在系统性地剖析[HLS调度算法](@entry_id:1126136)的核心理论与实践。我们将从最基本的原理出发，逐步深入到复杂的[优化技术](@entry_id:635438)。在“**原理与机制**”章节中，您将学习调度的数学模型，掌握从无约束的ASAP/ALAP到资源受限的力导向调度等核心算法，并理解处理循环和控制流的高级机制。接着，在“**应用与跨学科联系**”章节中，我们将展示这些理论如何在实际工程问题（如功耗优化、物理感知设计）中发挥作用，并揭示其与编译器、操作系统等领域的深刻联系。最后，通过“**动手实践**”部分，您将有机会亲手应用所学知识解决具体的调度问题。

让我们首先进入第一章，深入探索[调度算法](@entry_id:262670)的底层原理与核心机制，为理解其强大的优化能力奠定坚实的基础。

## 原理与机制

高层次综合（High-Level Synthesis, HLS）的核心任务之一是调度（Scheduling），即将行为描述中的操作（如加法、乘法）映射到具体的[时钟周期](@entry_id:165839)。一个高效的调度方案能够显著优化最终硬件电路的性能（速度）、面积（资源消耗）和功耗。本章节将深入探讨调度的基本原理、核心算法以及处理复杂约束的机制。

### 调度的基础模型

在进行调度之前，我们必须建立一个精确的数学模型来描述计算任务、时[序关系](@entry_id:138937)和可用资源。

#### 计算的图形化表示

调度的第一步是将输入的算法描述转换成一个图形结构，它能明确地表示操作之间的依赖关系。

最基础的表示方法是**[数据流图](@entry_id:1123395)（Data Flow Graph, DFG）**。对于一段没有[控制流](@entry_id:273851)（例如，没有 `if` 语句或 `for` 循环）的直线代码，DFG 是一个[有向无环图](@entry_id:164045) $G = (V, E)$。其中，每个顶点 $v \in V$ 代表一个基本操作（例如，加法、乘法、加载），而每条边 $(o_i, o_j) \in E$ 代表一个**[数据依赖](@entry_id:748197)**。

最重要的一种[数据依赖](@entry_id:748197)是**真依赖（True Dependence）**或称**流依赖（Flow Dependence）**，通常记为“写后读”（Read-After-Write, RAW）。当操作 $o_i$ 的输出结果被操作 $o_j$ 用作输入时，就存在一条从 $o_i$ 到 $o_j$ 的真依赖边。例如，对于代码序列 `a = b + c; d = a * 2;`，第二个操作依赖于第一个操作的结果，因此在 DFG 中会有一条从加法操作到乘法操作的边。

除了真依赖，还存在另外两种由存储资源（如寄存器或内存位置）的复用引起的“伪依赖”：
1.  **反依赖（Anti-Dependence）**：也称为“读[后写](@entry_id:756770)”（Write-After-Read, WAR）。操作 $o_i$ 读取一个位置，随后操作 $o_j$ 写入该位置。为了保证 $o_i$ 能读到正确（旧的）值，必须在其执行完毕后 $o_j$ 才能写入。
2.  **输出依赖（Output Dependence）**：也称为“写[后写](@entry_id:756770)”（Write-After-Write, WAW）。操作 $o_i$ 和 $o_j$ 写入同一位置。为了保证该位置的最终值符合程序意图，$o_j$ 必须在 $o_i$ 之[后写](@entry_id:756770)入。

值得注意的是，反依赖和输出依赖都是**命名依赖（Name Dependences）**，它们并非源于数据的真实流动，而是因为多个操作共享了同一个变量名或存储位置。通过**重命名（Renaming）**技术，例如采用[静态单赋值](@entry_id:755378)（Single Static Assignment, SSA）形式，可以消除这些伪依赖，从而暴露出更多的并行性。因此，用于优化的 DFG 通常只包含必须遵守的真依赖关系。DFG 中的边定义了一个**偏[序关系](@entry_id:138937)**，任何合法的调度都必须满足这个[偏序](@entry_id:145467)，即如果存在一条从 $o_i$ 到 $o_j$ 的路径，则 $o_i$ 的执行必须在 $o_j$ 之前完成 。

当算法包含 `if-else` 或循环等控制结构时，仅有 DFG 是不够的。这时需要使用**控制和[数据流图](@entry_id:1123395)（Control/Data Flow Graph, CDFG）**。CDFG 在 DFG 的基础上增加了**[控制依赖](@entry_id:747830)（Control Dependencies）**。一个操作 $B$ 被认为[控制依赖](@entry_id:747830)于一个条件判断节点 $P$（例如 `if (cond)`），如果 $P$ 的判断结果决定了 $B$ 是否会被执行。形式上，这通常通过**[后支配](@entry_id:753626)关系（Post-dominator Relation）**来定义：若从 $P$ 的一个分支（如 `then` 分支）出发的所有路径都必然经过 $B$，而从 $P$ 的另一个分支（如 `else` 分支）出发存在至少一条路径不经过 $B$，则 $B$ [控制依赖](@entry_id:747830)于 $P$。[控制依赖](@entry_id:747830)的调度含义是，被依赖的操作（如 $B$）必须等待控制条件（如 $P$）评估完成后才能执行。同时，CDFG 明确了不同分支路径之间的**[互斥性](@entry_id:893613)（Mutual Exclusivity）**，这为资源共享提供了关键信息 。

#### 时间与操作模型

HLS 调度是在同步数字系统的离散[时钟周期](@entry_id:165839)模型上进行的。每个操作 $i$ 都关联着一个整数**开始时间** $t_i$（表示其开始执行的周期）和一个整数**延迟** $l_i$（表示完成该操作所需的周期数）。一个操作从第 $t_i$ 周期开始，其结果将在第 $t_i + l_i$ 周期开始时可用。

根据延迟的特性，操作可以分为几类 ：
- **单周期操作（Single-cycle Operation）**：延迟 $l_i=1$。这类操作的[组合逻辑](@entry_id:265083)路径延迟 $d_i$ 必须小于一个[时钟周期](@entry_id:165839) $T_{\text{clk}}$。
- **多周期操作（Multi-cycle Operation）**：延迟 $l_i \ge 2$。这类操作通常内部包含寄存器（即流水线化或状态机实现），其结果在 $l_i$ 个周期后才稳定可用。
- **可变延迟操作（Variable-latency Operation）**：延迟 $l_i$ 在运行时可能变化，例如访问外部存储器或进行[浮点数](@entry_id:173316)除法。这类操作通常需要握手信号来通知消费者数据何时准备就绪。对于[静态调度](@entry_id:755377)，一种保守策略是始终按其最大延迟 $l_i^{\max}$ 来调度后续操作。

对于一个真依赖边 $(i, j)$，最基本的调度约束是**先行约束（Precedence Constraint）**：
$$t_j \ge t_i + l_i$$
这个公式确保了操作 $j$ 只在操作 $i$ 产生结果之后才开始。

一个重要的优化技术是**操作链接（Operation Chaining）**。如果一系列相互依赖的纯[组合逻辑](@entry_id:265083)操作（通常是单周期操作）的总路径延迟小于一个时钟周期 $T_{\text{clk}}$，HLS 工具可以将它们“链接”在一起，在同一个时钟周期内完成。例如，如果存在一个路径 $i_1 \rightarrow i_2 \rightarrow \dots \rightarrow i_k$，并且它们的组合延迟之和 $\sum_{m=1}^{k} d_{i_m} \le T_{\text{clk}}$，那么调度器可以为它们分配相同的开始时间 $t_{i_1} = t_{i_2} = \dots = t_{i_k}$。如果延迟之和超过了 $T_{\text{clk}}$，则必须在链中某个位置断开，插入一个寄存器，这意味着后继操作的开始时间至少要推迟一个周期 。

### 无约束[调度算法](@entry_id:262670)

在只考虑先行约束，不考虑[资源限制](@entry_id:192963)的情况下，我们可以计算出每个操作的最早和最晚执行时间。这两种调度定义了每个操作的调度自由度。

#### ASAP (As Soon As Possible) 调度

ASAP 调度的目标是为每个操作找到其**最早可能的开始时间** $s_i^{\mathrm{ASAP}}$。该算法以[拓扑序](@entry_id:147345)（从输入到输出）遍历 DFG。对于没有任何前驱的源节点，其 ASAP 开始时间为 0。对于其他节点 $i$，其 ASAP 开始时间由其所有前驱节点的最晚完成时间决定：
$$s_i^{\mathrm{ASAP}} = \max_{p \in \mathrm{pred}(i)} \{s_p^{\mathrm{ASAP}} + l_p\}$$
其中 $\mathrm{pred}(i)$ 是节点 $i$ 的所有前驱节点的集合。ASAP 调度给出了整个计算所需的最小总延迟，即[关键路径](@entry_id:265231)的长度。

#### ALAP (As Late As Possible) 调度

与 ASAP 相反，ALAP 调度在给定一个总延迟期限 $L$ 的前提下，计算每个操作**最晚允许的开始时间** $s_i^{\mathrm{ALAP}}$。该算法以反向[拓扑序](@entry_id:147345)（从输出到输入）遍历 DFG。对于没有任何后继的汇点节点 $k$，其最晚完成时间不能超过期限 $L$，因此 $s_k^{\mathrm{ALAP}} + l_k \le L$，取最晚情况即 $s_k^{\mathrm{ALAP}} = L - l_k$。对于其他节点 $i$，其 ALAP 开始时间受其所有后继节点的最早开始时间的限制：
$$s_i^{\mathrm{ALAP}} = \min_{s \in \mathrm{succ}(i)} \{s_s^{\mathrm{ALAP}} - l_i\}$$
其中 $\mathrm{succ}(i)$ 是节点 $i$ 的所有后继节点的集合。

#### 时间范围与机动性

通过 ASAP 和 ALAP 调度，我们可以为每个操作 $i$ 定义一个**时间范围（Time Frame）** 或称为**调度窗口**，即 $[s_i^{\mathrm{ASAP}}, s_i^{\mathrm{ALAP}}]$。任何将操作 $i$ 调度在该窗口内的开始时间，都不会违反先行约束，也不会延长总的计算延迟（在给定的期限 $L$下）。

操作的**机动性（Mobility）**或**浮动（Slack）**定义为 $m_i = s_i^{\mathrm{ALAP}} - s_i^{\mathrm{ASAP}}$。机动性表示一个操作可以在其时间范围[内移](@entry_id:265618)动的周期数，而不影响[关键路径](@entry_id:265231)的长度。机动性为 0 的操作位于[关键路径](@entry_id:265231)上，它们的调度时间是固定的。机动性大于 0 的操作则为[资源受限调度](@entry_id:1130948)算法提供了优化的灵活性 。

### 资源约束调度

在实际的 HLS 问题中，硬件资源（如加法器、乘法器、存储器端口）的数量是有限的。**资源约束调度（Resource-Constrained Scheduling, RCS）**的目标是在给定的资源预算下，最小化总延迟。

#### 资源约束的建模

当两个或多个操作需要使用同一个类型的资源，而该类型资源的实例数量不足时，它们就不能在同一时间周期内执行。例如，如果只有一个乘法器，而两个独立的乘法操作 $o_i$ 和 $o_j$ 都需要执行，那么它们的执行时间区间 $[t_i, t_i+l_i-1]$ 和 $[t_j, t_j+l_j-1]$ 不能重叠。这引入了**析取约束（Disjunctive Constraint）**：
$$ (t_j \ge t_i + l_i) \lor (t_i \ge t_j + l_j) $$
这种“或”关系使得问题变得复杂，因为调度器必须决定这两个操作的执行顺序。一旦顺序确定（例如，决定 $i$ 在 $j$ 之前执行），这个析取约束就变成了一个简单的先行约束 $t_j \ge t_i + l_i$。

这种因资源共享而产生的额外约束，是调度与**绑定（Binding）**（将操作映射到具体硬件单元的过程）相互作用的核心体现。绑定决策会引入新的调度约束，而调度决策又会影响绑定的可行性和成本（如布线和[多路复用器](@entry_id:172320)成本）。

#### 基于[整数线性规划](@entry_id:636600)（ILP）的精确方法

调度问题可以被精确地表述为一个**[整数线性规划](@entry_id:636600)（Integer Linear Programming, ILP）**问题。尽管求解 ILP 是 N[P-难](@entry_id:265298)的，但它为理解问题结构和开发[启发式算法](@entry_id:176797)提供了理论基础。

我们可以将所有先行约束和（已决定的）资源约束都统一表示为**[差分约束](@entry_id:634030)（Difference Constraints）**系统。每个约束都形如：
$$ t_j - t_i \ge c_{ij} $$
例如，先行约束 $(i, j)$ 对应 $t_j - t_i \ge l_i$。一个资源约束（假设 $i$ 先于 $j$）也对应 $t_j - t_i \ge l_i$。整个调度问题就转化为求解一个满足所有[差分约束](@entry_id:634030)的开始时间向量 $\{t_i\}$，并使总延迟最小。

这个问题等价于在一个**[约束图](@entry_id:267131)（Constraint Graph）**上寻找最长路径。图的节点是操作，每条[差分约束](@entry_id:634030) $t_j - t_i \ge c_{ij}$ 对应一条从节点 $i$ 到节点 $j$ 的权重为 $c_{ij}$ 的边。每个操作 $i$ 的最早开始时间就是从一个虚拟的起始节点到节点 $i$ 的最长路径长度。总延迟（makespan）则是到虚拟结束节点的最长路径长度。这类问题可以使用基于[拓扑排序](@entry_id:156507)的[动态规划](@entry_id:141107)方法高效求解 。

#### 启发式[调度算法](@entry_id:262670)：力导向调度

由于精确求解的复杂性，实践中广泛使用[启发式算法](@entry_id:176797)。**力导向调度（Force-Directed Scheduling, FDS）**是一种经典的启发式方法，它试图在所有时间周期内均衡地分配资源使用。

FDS 的核心思想基于一个物理类比：每个操作都受到两种“力”的驱使。一种是“自身力”，将其推向其时间范围内的某个特定周期；另一种是“前驱/后继力”，由相关联的操作施加。算法的目标是找到一个使所有力的总和达到最小的调度方案。

具体来说，FDS 首先计算所有操作的 ASAP 和 ALAP 时间，确定它们的时间范围。然后，它进行以下步骤 ：
1.  **计算概率**：假设一个操作 $i$ 在其时间范围 $[s_i^{\mathrm{ASAP}}, s_i^{\mathrm{ALAP}}]$ 内的每个周期被调度的概率是均匀的，即 $P(S_i=t) = 1 / (m_i+1)$ 对于 $t \in [s_i^{\mathrm{ASAP}}, s_i^{\mathrm{ALAP}}]$。
2.  **构建资源分布图**：对于每种资源类型（如乘法器）和每个时间周期 $t$，计算该资源的**期望使用密度**。这是通过将在周期 $t$ 可能处于活动状态的所有操作的概率相加得到的。一个延迟为 $L_i$ 的操作若在周期 $s$ 开始，它将在 $[s, s+L_i-1]$ 的所有周期内保持活动。
    $$ \text{Density}(t) = \sum_{i} P(\text{操作 } i \text{ 在周期 } t \text{ 活动}) $$
3.  **计算“力”**：当尝试将一个操作 $i$ 安排在特定周期 $j$ 时，FDS会计算一个“力”值。这个力表示该调度决策对系统整体资源均衡性的影响。将操作 $i$ 调度到周期 $j$ 会增加周期 $j$ 到 $j+L_i-1$ 的资源使用密度。这个增量乘以该周期的当前密度，就构成了“自身力”。同时，这个决策可能会压缩其前驱或后继操作的调度范围，从而增加它们在其他周期的资源使用密度，这构成了“前驱/后继力”。
4.  **迭代决策**：FDS 迭代地为每个操作计算在所有可能周期调度的“力”，并选择产生最小总力的调度决策。做出决策后，更新图和时间范围，然后重复此过程，直到所有操作都被调度。

FDS 通过其全局视角，往往能产生比简单的[列表调度](@entry_id:751360)（List Scheduling）更均衡、更优化的调度结果。

### 高级调度机制与理论

#### 处理控制流：预定执行

对于包含 `if-else` 等分支的 CDFG，一种强大的优化技术是**预定执行（Predicated Execution）**或**if-转换**。其核心思想是将[控制依赖](@entry_id:747830)转换为[数据依赖](@entry_id:748197) 。

具体来说，条件分支的结果会生成一组[互斥](@entry_id:752349)的布尔**谓词（Predicates）**，例如 $\pi_T$（真分支）和 $\pi_F$（假分支）。然后，原先在真分支中的所有操作都关联谓词 $\pi_T$，假分支中的操作则关联 $\pi_F$。硬件执行时，一个带谓词的操作只有在其谓词为真时才会提交结果（例如，[写回](@entry_id:756770)寄存器）；否则，其执行结果被丢弃。

这种转换的最大好处是，来自[互斥](@entry_id:752349)分支的操作（例如，一个在 `then` 块中的乘法和一个在 `else` 块中的乘法）现在可以被调度到同一个资源（乘法器）的同一个时间周期。因为我们知道 $\pi_T$ 和 $\pi_F$ 中最多只有一个为真，所以这个资源在任何时候实际上只会被一个操作使用。这极大地提高了资源利用率并缩短了总延迟，尤其是在分支概率不均衡或分支路径延迟差异很大的情况下。

#### 处理内存依赖：别名分析

对内存的访问（加载和存储）给调度带来了巨大挑战，因为编译器或 HLS 工具往往无法静态地确定两个指针或数组索引是否指向同一个内存地址。这种不确定性被称为**别名（Aliasing）** 。

- **Must-alias**：分析可以确定两个内存访问**总是**指向同一个地址。
- **May-alias**：分析无法排除两个内存访问指向同一个地址的**可能性**。

为了保证功能的正确性（[顺序一致性](@entry_id:754699)），调度器必须采取保守策略：任何一对 `may-alias` 的内存访问，只要其中至少一个是写操作，就必须被当作存在依赖关系来处理（即 RAW, WAR, 或 WAW）。这会在 DFG 中增加一条保守的依赖边，即使在实际运行时这两个访问可能永远不会冲突。

这种保守主义会严重限制可挖掘的并行性。例如，一个循环中对 `A[i]` 和 `A[j]` 的访问，如果 `i` 和 `j` 的关系无法静态确定，工具就可能假设它们 `may-alias`，从而不必要地序列化循环迭代。因此，精确的**[别名](@entry_id:146322)分析**是 HLS 中决定性能上限的关键技术之一。

#### 循环流水线化：[模调度](@entry_id:1128078)

对于计算密集型的循环，**[模调度](@entry_id:1128078)（Modulo Scheduling）**是一种强大的流水线化技术，它通过重叠不同循环迭代的执行来最大化吞吐率 。

[模调度](@entry_id:1128078)的核心是确定一个**启动间隔（Initiation Interval, II）**，它表示连续两个循环迭代开始执行之间相隔的[时钟周期](@entry_id:165839)数。我们的目标是找到最小的合法 `II`。

最小 `II` 受两个基本因素的制约：
1.  **递归最小启动间隔（Recurrence-Constrained MII, RecMII）**：由**跨迭代依赖（Loop-carried Dependencies）**构成的环路决定。如果一个循环中，第 $i$ 次迭代的结果被第 $i+d$ 次迭代使用，就存在一个距离为 $d$ 的跨迭代依赖。对于 DFG 中的任何一个环路 $C$，其总延迟为 $L(C)$，跨迭代依赖的总距离为 $D(C)$，则必须满足：
    $$II \ge \frac{L(C)}{D(C)}$$
    RecMII 是所有环路所要求的 $II$ 的最大值：$\mathrm{RecMII} = \max_{C} \lceil \frac{L(C)}{D(C)} \rceil$。

2.  **资源最小启动间隔（Resource-Constrained MII, ResMII）**：由可用资源数量决定。如果在循环体中，类型为 $r$ 的资源需要执行 $T_r$ 个操作，而我们有 $N_r$ 个该类型的硬件单元，则在一个 $II$ 的窗口内，我们最多能启动 $N_r \times II$ 个操作。因此，必须满足 $N_r \times II \ge T_r$。
    ResMII 是所有资源类型所要求的 $II$ 的最大值：$\mathrm{ResMII} = \max_{r} \lceil \frac{T_r}{N_r} \rceil$。

最终，一个可行的启动间隔必须同时满足递归和资源约束，所以最小的 `II` 必须大于等于这两个下界的较大者：
$$II_{\min} \ge \max(\mathrm{RecMII}, \mathrm{ResMII})$$
找到这个最小的 `II` 后，[调度算法](@entry_id:262670)会尝试在这个 `II` 的[模空间](@entry_id:159780)内为循环体内的所有操作找到一个无冲突的调度方案。

#### 调度问题的对偶性

从优化理论的角度看，HLS 调度问题存在两种经典形式 ：
1.  **资源约束调度（RCS）**：在固定的资源数量下，最小化执行延迟（makespan）。
2.  **时间约束调度（TCS）**：在固定的延迟期限内，最小化所需的资源数量（或成本）。

这两种问题是**对偶**的。直观上，它们探索的是同一个“设计空间”的 Pareto 最优边界。这种对偶关系可以通过**[拉格朗日松弛](@entry_id:635609)（Lagrangian Relaxation）**来形式化。通过在 RCS 问题的 ILP 公式中“松弛”资源约束，并为每个约束引入一个[拉格朗日乘子](@entry_id:142696)（即“影子价格”），我们可以推导出其对偶问题。这个对偶问题的结构恰好对应于一个 TCS 问题，其中原问题的资源约束的影子价格变成了[对偶问题](@entry_id:177454)中资源成本的权重。

此外，[差分约束](@entry_id:634030)系统提供了一个判断调度问题是否**可行**的理论工具。一个包含最[后期](@entry_id:165003)限约束的调度问题是可行的，当且仅当其对应的[约束图](@entry_id:267131)中不存在**[负权环](@entry_id:633892)**。[负权环](@entry_id:633892)意味着一组矛盾的约束，例如 “$t_A$ 必须在 $t_B$ 之前， $t_B$ 必须在 $t_C$ 之前，而 $t_C$ 又必须在 $t_A$ 之前”，这显然是不可能满足的。像 [Bellman-Ford](@entry_id:634399) 这样的算法可以有效地检测图中是否存在[负权环](@entry_id:633892)，从而用于验证一个给定的调度问题在特定延迟期限下是否有解 。