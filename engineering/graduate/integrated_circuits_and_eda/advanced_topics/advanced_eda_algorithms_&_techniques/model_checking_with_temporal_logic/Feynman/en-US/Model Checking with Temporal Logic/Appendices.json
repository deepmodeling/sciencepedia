{
    "hands_on_practices": [
        {
            "introduction": "Translating an informal specification into a formal model is the foundational step of model checking. This practice guides you through constructing a Kripke structure for a common hardware handshake protocol. By checking the Computation Tree Logic (CTL) property $AF\\,ack$, you will learn to reason about system correctness across all possible execution paths, including those with non-deterministic environmental delays .",
            "id": "4282897",
            "problem": "Consider a synchronous Register-Transfer Level (RTL) control automaton for a single-request/single-acknowledge handshake in the context of Electronic Design Automation (EDA). The handshake follows the widely used synchronous protocol: when a requester raises a request, a responder eventually raises an acknowledge; the requester then lowers the request, and the responder subsequently lowers the acknowledge, returning the system to idle. The system is clocked and transitions occur on clock edges. The atomic propositions are $req$ and $ack$, representing the Boolean values of the request and acknowledge signals driven by the controller. Assume the environment may nondeterministically choose to start a handshake and the responder may nondeterministically delay the acknowledge.\n\nStarting from the protocol rules and synchronous semantics (every cycle the next state is determined by current state and inputs, and all signals are sampled at clock edges), construct a minimal deterministic control automaton with four distinct control states that realizes the handshake without violating the protocol ordering. Use these handshake-consistent states:\n- Idle ($req$ low, $ack$ low),\n- Request ($req$ high, $ack$ low),\n- Acknowledged ($req$ high, $ack$ high),\n- Release ($req$ low, $ack$ high).\n\nModel this controller as a Kripke structure $K = (S, R, L)$, where $S$ is the finite set of states, $R \\subseteq S \\times S$ is the total transition relation (every state has at least one successor), and $L: S \\to 2^{\\{req, ack\\}}$ labels each state with the set of atomic propositions true in that state. Use the following transition constraints derived from synchronous handshake correctness and nondeterministic environment behaviors:\n- From Idle, either remain Idle or raise $req$ to enter Request in the next cycle.\n- In Request, either remain in Request or have the responder assert $ack$ to enter Acknowledged in the next cycle.\n- In Acknowledged, either remain in Acknowledged or have the requester drop $req$ to enter Release in the next cycle.\n- In Release, either remain in Release or have the responder drop $ack$ to return to Idle in the next cycle.\n\nLabel each state with the appropriate subset of $\\{req, ack\\}$ implied by its signal values. With this Kripke structure, consider the Computation Tree Logic (CTL) property $AF\\,ack$, meaning \"on all paths, eventually $ack$ holds.\" Using only standard definitions of Kripke structures and CTL semantics, determine the number of states $s \\in S$ such that $K, s \\models AF\\,ack$. Express your final answer as a single integer. No rounding is required, and no units are involved.",
            "solution": "The problem requires an evaluation of a Computation Tree Logic (CTL) formula on a Kripke structure representing a synchronous handshake protocol. The first step is to formally define this Kripke structure based on the provided description.\n\nA Kripke structure is a tuple $K = (S, R, L)$, where $S$ is a set of states, $R \\subseteq S \\times S$ is a transition relation, and $L: S \\to 2^{AP}$ is a labeling function mapping states to sets of true atomic propositions from a set $AP$.\n\n**1. Formalizing the Kripke Structure**\n\n**States ($S$):**\nThe problem specifies four distinct control states. Let us denote them as follows:\n- $s_I$: The `Idle` state.\n- $s_Q$: The `Request` state.\n- $s_A$: The `Acknowledged` state.\n- $s_R$: The `Release` state.\nThus, the set of states is $S = \\{s_I, s_Q, s_A, s_R\\}$.\n\n**Atomic Propositions ($AP$) and Labeling Function ($L$):**\nThe atomic propositions are given as $AP = \\{req, ack\\}$. The labeling function $L$ is determined by the signal values in each state:\n- `Idle` ($req$ low, $ack$ low): $L(s_I) = \\emptyset$.\n- `Request` ($req$ high, $ack$ low): $L(s_Q) = \\{req\\}$.\n- `Acknowledged` ($req$ high, $ack$ high): $L(s_A) = \\{req, ack\\}$.\n- `Release` ($req$ low, $ack$ high): $L(s_R) = \\{ack\\}$.\n\n**Transition Relation ($R$):**\nThe transition constraints define the edges of the state graph. The relation must be total, meaning every state has an outgoing transition.\n- From $s_I$ (`Idle`), the system can either remain `Idle` or transition to `Request`. This defines the transitions $(s_I, s_I) \\in R$ and $(s_I, s_Q) \\in R$.\n- From $s_Q$ (`Request`), the system can either remain in `Request` or transition to `Acknowledged`. This defines the transitions $(s_Q, s_Q) \\in R$ and $(s_Q, s_A) \\in R$.\n- From $s_A$ (`Acknowledged`), the system can either remain `Acknowledged` or transition to `Release`. This defines the transitions $(s_A, s_A) \\in R$ and $(s_A, s_R) \\in R$.\n- From $s_R$ (`Release`), the system can either remain in `Release` or transition to `Idle`. This defines the transitions $(s_R, s_R) \\in R$ and $(s_R, s_I) \\in R$.\n\nThe complete transition relation is $R = \\{(s_I, s_I), (s_I, s_Q), (s_Q, s_Q), (s_Q, s_A), (s_A, s_A), (s_A, s_R), (s_R, s_R), (s_R, s_I)\\}$. This relation is total, as each state has at least one successor. The self-loops at each state correspond to the nondeterministic delays mentioned in the problem (e.g., the environment might not raise `req`, or the responder might delay `ack`).\n\n**2. Evaluating the CTL Property $AF\\,ack$**\n\nThe CTL formula to be evaluated is $AF\\,ack$. The semantics of this formula are: \"For all computation paths starting from a given state, there is some future state on the path where the proposition $ack$ is true.\"\n\nA state $s$ satisfies a proposition $p$ (written $s \\models p$) if $p \\in L(s)$.\nFirst, let's identify the set of states that satisfy the proposition $ack$.\nFrom the labeling function $L$:\n- $s_A \\models ack$ because $ack \\in L(s_A) = \\{req, ack\\}$.\n- $s_R \\models ack$ because $ack \\in L(s_R) = \\{ack\\}$.\nThe states $s_I$ and $s_Q$ do not satisfy $ack$, since $ack \\notin L(s_I)$ and $ack \\notin L(s_Q)$.\nLet $S_{ack} = \\{s \\in S \\mid s \\models ack\\} = \\{s_A, s_R\\}$.\n\nNow, we must check for each state $s \\in S$ whether $K, s \\models AF\\,ack$. A state $s$ satisfies $AF\\,ack$ if every infinite path $\\pi = (s_0, s_1, s_2, \\dots)$ starting with $s_0 = s$ contains at least one state $s_i$ such that $s_i \\in S_{ack}$.\n\nLet's analyze each state:\n\n- **State $s_A$ (`Acknowledged`):**\nAny path starting from $s_A$ has $s_A$ as its first state. Since $s_A \\models ack$, the condition \"eventually $ack$\" is satisfied at the very beginning of the path (at time $0$). This holds for all paths starting from $s_A$. Therefore, $K, s_A \\models AF\\,ack$.\n\n- **State $s_R$ (`Release`):**\nSimilarly, any path starting from $s_R$ has $s_R$ as its first state. Since $s_R \\models ack$, the condition is immediately satisfied. This holds for all paths starting from $s_R$. Therefore, $K, s_R \\models AF\\,ack$.\n\n- **State $s_I$ (`Idle`):**\nFrom state $s_I$, there are two possible transitions: to $s_I$ or to $s_Q$. Due to the nondeterministic choice, a valid computation path can be formed by repeatedly choosing the self-loop transition $(s_I, s_I)$. This gives the infinite path $\\pi = (s_I, s_I, s_I, \\dots)$. For every state $s_i$ on this path, $s_i = s_I$, and we know that $s_I \\not\\models ack$. Thus, we have found a path starting from $s_I$ on which $ack$ is never true. Because the $A$ (\"for all paths\") quantifier is not met, the property fails. Therefore, $K, s_I \\not\\models AF\\,ack$.\n\n- **State $s_Q$ (`Request`):**\nFrom state $s_Q$, there are two possible transitions: to $s_Q$ or to $s_A$. Similar to the `Idle` state, a valid computation path can be formed by repeatedly choosing the self-loop transition $(s_Q, s_Q)$. This gives the infinite path $\\pi = (s_Q, s_Q, s_Q, \\dots)$. For every state $s_i$ on this path, $s_i = s_Q$, and we know that $s_Q \\not\\models ack$. This path represents the scenario where the responder never asserts the acknowledge signal. As we have found a path starting from $s_Q$ that never reaches a state where $ack$ is true, the $A$ quantifier is not met. Therefore, $K, s_Q \\not\\models AF\\,ack$.\n\n**Conclusion**\nThe set of states $s$ for which the property $K, s \\models AF\\,ack$ holds is $\\{s_A, s_R\\}$. The problem asks for the *number* of such states. There are two states in this set.\nThe number of states satisfying $AF\\,ack$ is $2$.",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "As systems grow, explicitly representing every state becomes impossible, a challenge known as the state-space explosion. This problem introduces symbolic model checking, a powerful technique that uses data structures like Reduced Ordered Binary Decision Diagrams (ROBDDs) to handle enormous state spaces. You will apply a symbolic algorithm to compute a greatest fixpoint for an $EG(\\varphi)$ property, gaining insight into how industrial model checkers operate .",
            "id": "4282944",
            "problem": "Consider a synchronous two-bit up-counter implemented as a finite-state machine in a typical digital integrated circuit. The counter has two state bits $x_{1}$ (most significant bit) and $x_{0}$ (least significant bit) and increments by one modulo $4$ on each rising clock edge. Model the counter as a Kripke structure with state space given by all valuations of $\\{x_{1}, x_{0}\\}$ and a transition relation from $(x_{1}, x_{0})$ to $(x_{1}', x_{0}')$ defined by the functional next-state logic of the circuit. Use a Reduced Ordered Binary Decision Diagram (ROBDD) to encode the transition relation over Boolean variables $\\{x_{1}, x_{0}, x_{1}', x_{0}'\\}$ with the variable order $x_{1} \\prec x_{0} \\prec x_{1}' \\prec x_{0}'$. You may assume ideal synchronous behavior and no additional inputs.\n\nUsing the standard semantics of Computation Tree Logic (CTL), where $EG\\,\\varphi$ holds at a state if there exists an infinite path starting at that state along which $\\varphi$ holds at every step, and the standard Binary Decision Diagram (BDD) representation of sets of states and relations with existential quantification for image and preimage computations, do the following:\n\n- Construct a Boolean formula for the ROBDD that encodes the transition relation $T(x_{1}, x_{0}, x_{1}', x_{0}')$ of the counter, derived directly from the bit-level addition by one modulo $4$.\n- Let $\\varphi(x_{1}, x_{0})$ be the state predicate expressing that the counter value is not equal to $3$ (i.e., binary $11$). Using the BDD-based fixpoint characterization of $EG\\,\\varphi$ and the transition relation $T$, compute the set of states satisfying $EG(\\varphi)$.\n- Report the cardinality (as an integer) of the set of states that satisfy $EG(\\varphi)$.\n\nExpress the final answer as a single integer with no units. No rounding is required.",
            "solution": "The problem is validated as sound and well-posed. It is a standard exercise in symbolic model checking.\n\nThe system is a synchronous two-bit up-counter. The state is represented by two bits, $x_{1}$ (most significant) and $x_{0}$ (least significant). The state space $S$ consists of four states, which can be identified with the integers $0, 1, 2, 3$:\n- State $0$: $(x_{1}, x_{0}) = (0, 0)$\n- State $1$: $(x_{1}, x_{0}) = (0, 1)$\n- State $2$: $(x_{1}, x_{0}) = (1, 0)$\n- State $3$: $(x_{1}, x_{0}) = (1, 1)$\n\nThe counter increments by one modulo $4$ at each clock cycle. The transition relation is deterministic. Let $(x_{1}', x_{0}')$ be the state at the next clock cycle. The next-state logic is derived from binary addition:\n- The next value of the least significant bit, $x_{0}'$, is the negation of its current value: $x_{0}' = \\neg x_{0}$.\n- The next value of the most significant bit, $x_{1}'$, flips if and only if the current value of $x_{0}$ is $1$: $x_{1}' = x_{1} \\oplus x_{0}$ (exclusive OR).\n\nThe transition relation $T(x_{1}, x_{0}, x_{1}', x_{0}')$ is a Boolean function over the current state variables $\\{x_{1}, x_{0}\\}$ and next state variables $\\{x_{1}', x_{0}'\\}$. This function is true for a tuple of variable assignments if and only if $(x_{1}', x_{0}')$ is the successor of $(x_{1}, x_{0})$. The formula for $T$ is:\n$$T(x_{1}, x_{0}, x_{1}', x_{0}') \\equiv (x_{0}' \\leftrightarrow \\neg x_{0}) \\land (x_{1}' \\leftrightarrow (x_{1} \\oplus x_{0}))$$\nThis single relation encodes all four state transitions:\n- $T(0, 0, 0, 1)$ is true, representing the transition from state $0$ to state $1$.\n- $T(0, 1, 1, 0)$ is true, representing the transition from state $1$ to state $2$.\n- $T(1, 0, 1, 1)$ is true, representing the transition from state $2$ to state $3$.\n- $T(1, 1, 0, 0)$ is true, representing the transition from state $3$ to state $0$.\nIn a BDD-based model checker, this Boolean formula would be compiled into a Reduced Ordered Binary Decision Diagram (ROBDD) using the specified variable order $x_{1} \\prec x_{0} \\prec x_{1}' \\prec x_{0}'$.\n\nThe problem asks for the set of states satisfying the Computation Tree Logic (CTL) formula $EG(\\varphi)$. The state predicate $\\varphi$ is defined as the counter value not being equal to $3$. State $3$ corresponds to $(x_{1}, x_{0}) = (1, 1)$. Thus, the predicate $\\varphi$ is represented by the Boolean formula:\n$$\\varphi(x_{1}, x_{0}) \\equiv \\neg (x_{1} \\land x_{0})$$\nThe set of states satisfying $\\varphi$, which we will denote $S_\\varphi$, is $\\{ (0,0), (0,1), (1,0) \\}$, corresponding to states $\\{0, 1, 2\\}$.\n\nThe set of states satisfying $EG(\\varphi)$ is characterized as the greatest fixpoint of the operator $F(Y) = S_\\varphi \\cap \\text{PreImage}(Y)$, where $\\text{PreImage}(Y)$ is the set of states from which there exists a transition to a state in the set $Y$. This corresponds to the CTL semantics $EG(\\varphi) \\equiv \\nu Z . (\\varphi \\land EX(Z))$. The fixpoint is computed iteratively. Let $Y_k$ be the set of states at iteration $k$.\nThe standard algorithm for a greatest fixpoint starts with the set of all states that satisfy the property $\\varphi$ and repeatedly removes states that cannot remain within this set.\nLet $Y_{0} = S_\\varphi = \\{ (0,0), (0,1), (1,0) \\}$.\nThe iteration proceeds as $Y_{k+1} = Y_k \\cap \\text{PreImage}(Y_k)$. The process stops when $Y_{k+1} = Y_k$.\n\nThe PreImage operation, corresponding to $EX(Y)$, is defined symbolically as:\n$$ \\text{PreImage}(Y) = \\{ s \\mid \\exists s' \\in Y, T(s,s') \\} $$\nIn a BDD-based framework, if $Y(x_1', x_0')$ is the characteristic function of the set $Y$, the pre-image is computed as $\\exists x_{1}', x_{0}' . (T(x_{1}, x_{0}, x_{1}', x_{0}') \\land Y(x_{1}', x_{0}'))$.\n\nLet's perform the iterative computation:\nInitial step:\n$Y_{0} = S_\\varphi = \\{ (0,0), (0,1), (1,0) \\}$.\n\nIteration 1:\nWe compute $\\text{PreImage}(Y_{0})$. This is the set of states that have a successor in $Y_{0} = \\{ (0,0), (0,1), (1,0) \\}$.\n- The predecessor of state $(0,0)$ is $(1,1)$.\n- The predecessor of state $(0,1)$ is $(0,0)$.\n- The predecessor of state $(1,0)$ is $(0,1)$.\nSo, $\\text{PreImage}(Y_{0}) = \\{ (1,1), (0,0), (0,1) \\}$.\nNow we compute $Y_{1} = Y_{0} \\cap \\text{PreImage}(Y_{0})$:\n$$Y_{1} = \\{ (0,0), (0,1), (1,0) \\} \\cap \\{ (1,1), (0,0), (0,1) \\} = \\{ (0,0), (0,1) \\}$$\n\nIteration 2:\nWe compute $\\text{PreImage}(Y_{1})$, where $Y_{1} = \\{ (0,0), (0,1) \\}$.\n- The predecessor of state $(0,0)$ is $(1,1)$.\n- The predecessor of state $(0,1)$ is $(0,0)$.\nSo, $\\text{PreImage}(Y_{1}) = \\{ (1,1), (0,0) \\}$.\nNow we compute $Y_{2} = Y_{1} \\cap \\text{PreImage}(Y_{1})$:\n$$Y_{2} = \\{ (0,0), (0,1) \\} \\cap \\{ (1,1), (0,0) \\} = \\{ (0,0) \\}$$\n\nIteration 3:\nWe compute $\\text{PreImage}(Y_{2})$, where $Y_{2} = \\{ (0,0) \\}$.\n- The predecessor of state $(0,0)$ is $(1,1)$.\nSo, $\\text{PreImage}(Y_{2}) = \\{ (1,1) \\}$.\nNow we compute $Y_{3} = Y_{2} \\cap \\text{PreImage}(Y_{2})$:\n$$Y_{3} = \\{ (0,0) \\} \\cap \\{ (1,1) \\} = \\emptyset$$\n\nIteration 4:\nWe compute $\\text{PreImage}(Y_{3})$, where $Y_{3} = \\emptyset$.\nThe preimage of the empty set is the empty set, so $\\text{PreImage}(Y_{3}) = \\emptyset$.\nNow we compute $Y_{4} = Y_{3} \\cap \\text{PreImage}(Y_{3})$:\n$$Y_{4} = \\emptyset \\cap \\emptyset = \\emptyset$$\n\nSince $Y_{4} = Y_{3}$, the algorithm has reached a fixpoint. The set of states satisfying $EG(\\varphi)$ is the empty set, $\\emptyset$.\n\nThis result is intuitive. The formula $EG(\\varphi)$ holds in a state if there exists an infinite path starting from it that never visits state $3$ (binary $11$). The counter follows a single cycle: $(0,0) \\to (0,1) \\to (1,0) \\to (1,1) \\to (0,0) \\to \\dots$. From any starting state, the system is guaranteed to reach state $(1,1)$ eventually. Therefore, no state can satisfy the property that there exists a path always avoiding state $(1,1)$. The set of states satisfying $EG(\\varphi)$ must be empty.\n\nThe cardinality of the resulting set $\\emptyset$ is $0$.",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "In industrial practice, finding bugs is often as important as proving correctness, and Bounded Model Checking (BMC) is a highly effective and scalable technique for this purpose. This exercise shifts focus to Linear Temporal Logic (LTL) and the search for counterexamples, which are represented as \"lasso-shaped\" paths. You will explore the core logic of BMC by determining the minimal path length needed to find a bug, illustrating how temporal properties can be checked by reduction to a satisfiability problem .",
            "id": "4282914",
            "problem": "Consider a finite-state transition system used to abstract a pipeline control in Electronic Design Automation (EDA). The system is defined as a tuple $M = (S, I, T, \\mathit{error})$, where $S$ is a finite set of states, $I \\subseteq S$ is the set of initial states, $T \\subseteq S \\times S$ is the transition relation, and $\\mathit{error}: S \\to \\{\\mathit{true}, \\mathit{false}\\}$ is a predicate that holds when the control logic is in an error state. The property of interest is expressed in Linear Temporal Logic (LTL) as $F(\\text{error})$, which reads as \"eventually $\\mathit{error}$\". In standard model checking semantics, a counterexample to $F(\\text{error})$ is an infinite execution that never reaches a state where $\\mathit{error}$ holds.\n\nBounded Model Checking (BMC) represents candidate infinite executions by a lasso-shaped path, a finite path segment followed by a loop-back. Formally, for a given bound $k \\in \\mathbb{N}$, a lasso is a sequence $(s_0, s_1, \\dots, s_k)$ with $s_0 \\in I$, $(s_i, s_{i+1}) \\in T$ for all $i$ with $0 \\le i < k$, together with an index $j$ satisfying $0 \\le j \\le k$ and $(s_k, s_j) \\in T$. For the specific counterexample to $F(\\text{error})$, the sequence must satisfy $\\neg \\mathit{error}(s_i)$ for all $i$ with $0 \\le i \\le k$. The loop-back constraint $(s_k, s_j) \\in T$ ensures the existence of an ultimately periodic infinite execution $(s_0, \\dots, s_k, s_j, \\dots, s_k, s_j, \\dots)$ that avoids $\\mathit{error}$ forever. The minimal counterexample length $k_{\\min}$ is the smallest $k$ for which such a lasso exists. If no such lasso exists up to a given maximum bound $K_{\\max}$ (or at all), return $-1$.\n\nYour task is to implement a program that, for each provided test model, computes $k_{\\min}$ subject to the loop-back constraint above. The program must systematically search increasing bounds $k$ from $0$ to $K_{\\max}$ and determine whether there exists a sequence $(s_0, \\dots, s_k)$ with $s_0 \\in I$, $(s_i, s_{i+1}) \\in T$ for $0 \\le i < k$, $\\neg \\mathit{error}(s_i)$ for all $0 \\le i \\le k$, and a loop-back $(s_k, s_j) \\in T$ for some $j$ with $0 \\le j \\le k$.\n\nThe test suite consists of five models. Each model is specified by:\n- A set of states $S = \\{0, 1, \\dots, n-1\\}$.\n- A single initial state $s_{\\mathit{init}} \\in S$.\n- A transition relation $T$ given by adjacency lists mapping each state $x \\in S$ to the list of successors $\\{y \\in S \\mid (x,y) \\in T\\}$.\n- An error predicate $\\mathit{error}$ given by the subset $E \\subseteq S$ where $\\mathit{error}(x)$ holds.\n- A maximum search bound $K_{\\max} \\in \\mathbb{N}$.\n\nThe models are:\n\nModel $1$ (five-stage pipeline with eventual error and no error-free cycle):\n- $S = \\{0, 1, 2, 3, 4, 5\\}$ with labels $0=\\mathit{IF}$, $1=\\mathit{ID}$, $2=\\mathit{EX}$, $3=\\mathit{MEM}$, $4=\\mathit{WB}$, $5=\\mathit{ERR}$.\n- $s_{\\mathit{init}} = 0$.\n- $T(0) = [1]$, $T(1) = [2]$, $T(2) = [3]$, $T(3) = [4]$, $T(4) = [5]$, $T(5) = [5]$.\n- $E = \\{5\\}$.\n- $K_{\\max} = 6$.\nExpected behavior: there is no lasso avoiding $\\mathit{error}$; return $-1$.\n\nModel $2$ (persistent stall due to hazard never clearing; error never occurs; stall self-loop):\n- $S = \\{0, 1, 2\\}$ with labels $0=\\mathit{IF}$, $1=\\mathit{ID}$, $2=\\mathit{STALL}$.\n- $s_{\\mathit{init}} = 0$.\n- $T(0) = [1]$, $T(1) = [2]$, $T(2) = [2]$.\n- $E = \\{\\}$.\n- $K_{\\max} = 5$.\nExpected behavior: minimal lasso at $k = 2$ using loop-back $(2,2)$; return $2$.\n\nModel $3$ (decode–execute two-cycle with no error):\n- $S = \\{0, 1, 2\\}$ with labels $0=\\mathit{IF}$, $1=\\mathit{ID}$, $2=\\mathit{EX}$.\n- $s_{\\mathit{init}} = 0$.\n- $T(0) = [1]$, $T(1) = [2]$, $T(2) = [1]$.\n- $E = \\{\\}$.\n- $K_{\\max} = 5$.\nExpected behavior: minimal lasso at $k = 2$ with loop-back $(2,1)$; return $2$.\n\nModel $4$ (reset–fetch cycle without error; loop-back to earlier state):\n- $S = \\{0, 1\\}$ with labels $0=\\mathit{RESET}$, $1=\\mathit{IF}$.\n- $s_{\\mathit{init}} = 0$.\n- $T(0) = [1]$, $T(1) = [0]$.\n- $E = \\{\\}$.\n- $K_{\\max} = 3$.\nExpected behavior: minimal lasso at $k = 1$ with loop-back $(1,0)$; return $1$.\n\nModel $5$ (five-stage pipeline with a writeback–decode loop avoiding error):\n- $S = \\{0, 1, 2, 3, 4\\}$ with labels $0=\\mathit{IF}$, $1=\\mathit{ID}$, $2=\\mathit{EX}$, $3=\\mathit{MEM}$, $4=\\mathit{WB}$.\n- $s_{\\mathit{init}} = 0$.\n- $T(0) = [1]$, $T(1) = [2]$, $T(2) = [3]$, $T(3) = [4]$, $T(4) = [1]$.\n- $E = \\{\\}$.\n- $K_{\\max} = 5$.\nExpected behavior: minimal lasso at $k = 4$ with loop-back $(4,1)$; return $4$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is the minimal counterexample length $k_{\\min}$ for Model $i$ computed according to the BMC lasso semantics described. No physical units are required, and all answers must be integers.",
            "solution": "The problem statement is formally well-defined, scientifically grounded in the principles of Bounded Model Checking (BMC) for Linear Temporal Logic (LTL), and provides a complete and consistent set of givens for each test case. The problem is therefore deemed valid.\n\nThe task is to find the minimal counterexample length, denoted as $k_{\\min}$, for the LTL property $F(\\text{error})$. A counterexample to this property is an infinite execution of the system that never enters a state where the $\\mathit{error}$ predicate holds. In the context of BMC, such a counterexample is represented by a lasso-shaped path.\n\nA lasso is defined by a bound $k \\in \\mathbb{N}$ and constitutes a path $(s_0, s_1, \\dots, s_k)$ that satisfies the following conditions:\n$1$. The path starts in an initial state: $s_0 \\in I$.\n$2$. The path follows valid transitions: $(s_i, s_{i+1}) \\in T$ for all $i$ where $0 \\le i < k$.\n$3$. All states along the path are non-error states: $\\neg \\mathit{error}(s_i)$ for all $i$ where $0 \\le i \\le k$.\n$4$. A loop-back transition exists from the end of the path to some state within the path: there is an index $j$ with $0 \\le j \\le k$ such that $(s_k, s_j) \\in T$.\n\nOur objective is to find the smallest non-negative integer $k$ for which such a lasso exists, within a given maximum search bound $K_{\\max}$. If no such $k \\le K_{\\max}$ exists, the result is $-1$.\n\nThe algorithmic approach is an iterative search over the path length $k$, starting from $k=0$ and incrementing up to $K_{\\max}$. This method systematically explores for lassos of increasing length.\n\nFirst, we identify the set of \"safe\" states, which are all states $s \\in S$ for which $\\neg \\mathit{error}(s)$ holds. The entire search for paths is constrained to this subset of states. If the initial state $s_{\\mathit{init}}$ is not in the set of safe states, no valid path can be formed, and we can immediately conclude that no counterexample exists.\n\nThe search proceeds as follows:\n\nFor $k=0$:\nA path of length $0$ is simply the initial state $(s_0)$. For a lasso to exist at this length, the path must be safe (i.e., $\\neg \\mathit{error}(s_0)$) and there must be a loop-back. The only possible loop-back is to itself, so the condition is $(s_0, s_0) \\in T$. If both conditions hold, then $k_{\\min} = 0$.\n\nFor $k > 0$:\nThe search is structured as a breadth-first exploration of paths. We maintain a set of all safe paths of a given length.\nLet $\\mathcal{P}_k$ be the set of all safe paths of length $k$. A path $(s_0, \\dots, s_k) \\in \\mathcal{P}_k$ has by definition satisfied conditions $1$, $2$, and $3$ (partially, up to $s_{k-1}$).\n\nAt each step $k$ (from $1$ to $K_{\\max}$), we construct the set of paths $\\mathcal{P}_k$ by extending the paths in $\\mathcal{P}_{k-1}$. For each path $(s_0, \\dots, s_{k-1}) \\in \\mathcal{P}_{k-1}$, we consider all successors $s_k$ of the last state $s_{k-1}$. If a successor $s_k$ is a safe state, we form a new path $(s_0, \\dots, s_{k-1}, s_k)$, which is added to $\\mathcal{P}_k$.\n\nAfter generating all paths in $\\mathcal{P}_k$, we check each new path for the loop-back condition (condition $4$). For each path $p = (s_0, \\dots, s_k) \\in \\mathcal{P}_k$, we check if there exists a transition from its final state $s_k$ to any state $s_j$ already present in the path $p$. That is, we check if there exists a $j \\in \\{0, \\dots, k\\}$ such that $(s_k, s_j) \\in T$.\n\nThe first value of $k$ for which we find a path satisfying this loop-back condition is the minimal counterexample length, $k_{\\min}$. The search then terminates and returns this value of $k$.\n\nIf at any step $k$, the set $\\mathcal{P}_k$ becomes empty, it means no safe paths of length $k$ can be formed. Consequently, no longer safe paths can be formed either, so the search terminates and we conclude no suitable lasso exists.\n\nIf the loop completes for all $k$ from $0$ to $K_{\\max}$ without finding a lasso, we return $-1$.\n\nThis iterative, layer-by-layer construction of paths ensures that we find the lasso with the minimum possible length $k$. The algorithm is implemented below to process each of the five models provided.\n```python\nimport numpy as np\n\ndef find_k_min(n, s_init, T, E, K_max):\n    \"\"\"\n    Computes the minimal counterexample length k_min for the LTL property F error.\n\n    This function implements a Bounded Model Checking (BMC) search for a lasso-shaped\n    counterexample. It iteratively searches for paths of increasing length k.\n\n    Args:\n        n (int): The number of states, S = {0, ..., n-1}.\n        s_init (int): The single initial state.\n        T (dict): The transition relation as an adjacency list (dict of lists).\n        E (set): The set of error states.\n        K_max (int): The maximum search bound for the path length k.\n\n    Returns:\n        int: The minimal counterexample length k_min, or -1 if no such lasso\n             is found up to K_max.\n    \"\"\"\n    safe_states = set(range(n)) - E\n\n    if s_init not in safe_states:\n        return -1\n\n    # Base case: k = 0\n    # A path of length 0 is (s_0). The loop-back must be (s_0, s_0).\n    if s_init in T.get(s_init, []):\n        return 0\n\n    # paths_at_k stores all safe paths of current length k, starting with k=0.\n    # A path is a list of states.\n    paths_at_k = [[s_init]]\n\n    for k in range(1, K_max + 1):\n        paths_at_k_plus_1 = []\n        for path in paths_at_k:\n            last_state = path[-1]\n            for successor in T.get(last_state, []):\n                if successor in safe_states:\n                    new_path = path + [successor] # Create a new path by extending\n                    paths_at_k_plus_1.append(new_path)\n\n        if not paths_at_k_plus_1:\n            # No safe paths of length k could be constructed.\n            # No longer safe paths can exist either.\n            return -1\n\n        paths_at_k = paths_at_k_plus_1\n\n        # For each new path of length k, check the loop-back condition.\n        for path in paths_at_k:\n            s_k = path[-1]\n            \n            # Using a set for efficient membership checking.\n            path_states_set = set(path)\n            \n            for successor in T.get(s_k, []):\n                # The loop-back condition requires (s_k, s_j) in T, where s_j is in the path.\n                if successor in path_states_set:\n                    # A lasso is found. Since we are iterating k upwards,\n                    # this is the minimal k.\n                    return k\n\n    # If the loop finishes without finding a lasso up to K_max.\n    return -1\n\n\ndef solve():\n    \"\"\"\n    Defines the models from the problem statement and computes k_min for each.\n    \"\"\"\n    test_cases = [\n        # Model 1\n        {'n': 6, 's_init': 0, 'T': {0: [1], 1: [2], 2: [3], 3: [4], 4: [5], 5: [5]}, 'E': {5}, 'K_max': 6},\n        # Model 2\n        {'n': 3, 's_init': 0, 'T': {0: [1], 1: [2], 2: [2]}, 'E': set(), 'K_max': 5},\n        # Model 3\n        {'n': 3, 's_init': 0, 'T': {0: [1], 1: [2], 2: [1]}, 'E': set(), 'K_max': 5},\n        # Model 4\n        {'n': 2, 's_init': 0, 'T': {0: [1], 1: [0]}, 'E': set(), 'K_max': 3},\n        # Model 5\n        {'n': 5, 's_init': 0, 'T': {0: [1], 1: [2], 2: [3], 3: [4], 4: [1]}, 'E': set(), 'K_max': 5},\n    ]\n\n    results = []\n    for case in test_cases:\n        k_min = find_k_min(case['n'], case['s_init'], case['T'], case['E'], case['K_max'])\n        results.append(k_min)\n\n    # The problem asks for the output string, which is the answer.\n    # print(f\"[{','.join(map(str, results))}]\")\n\n\n# solve() is not called here, as the pre-computed answer is placed in the answer tag.\n```",
            "answer": "[-1,2,2,1,4]"
        }
    ]
}