{
    "hands_on_practices": [
        {
            "introduction": "模型检验的首要步骤是将待验证的系统（无论是硬件协议还是软件算法）转化为一个精确的数学模型。本练习将带你实践这一关键技能，通过对一个常见的同步握手协议进行建模，你将构建一个Kripke结构来捕捉其动态行为。在此基础上，你将应用计算树逻辑（CTL）来推理该协议的活性属性，例如，判断一个请求是否总能最终获得确认。",
            "id": "4282897",
            "problem": "在电子设计自动化 (EDA) 的背景下，考虑一个用于单请求/单应答握手的同步寄存器传输级 (RTL) 控制自动机。该握手遵循广泛使用的同步协议：当请求方发出请求时，响应方最终会发出应答；然后请求方撤销请求，响应方随后撤销应答，使系统返回空闲状态。该系统是时钟同步的，状态转换在时钟沿发生。原子命题是 $req$ 和 $ack$，表示由控制器驱动的请求和应答信号的布尔值。假设环境可能非确定性地选择开始一次握手，并且响应方可能非确定性地延迟应答。\n\n从协议规则和同步语义（每个周期中，下一状态由当前状态和输入决定，并且所有信号都在时钟沿被采样）出发，构建一个具有四个不同控制状态的最小确定性控制自动机，该自动机能在不违反协议顺序的情况下实现握手。使用以下符合握手协议的状态：\n- 空闲 (Idle) ($req$ 低, $ack$ 低),\n- 请求 (Request) ($req$ 高, $ack$ 低),\n- 已应答 (Acknowledged) ($req$ 高, $ack$ 高),\n- 释放 (Release) ($req$ 低, $ack$ 高).\n\n将此控制器建模为一个 Kripke 结构 $K = (S, R, L)$，其中 $S$ 是有限状态集，$R \\subseteq S \\times S$ 是全转移关系（每个状态至少有一个后继状态），$L: S \\to 2^{\\{req, ack\\}}$ 为每个状态标记在该状态下为真的原子命题集合。使用从同步握手正确性和非确定性环境行为中推导出的以下转移约束：\n- 从空闲状态，可以保持空闲，或在下一周期发出 $req$ 进入请求状态。\n- 在请求状态，可以保持请求状态，或由响应方断言 $ack$ 在下一周期进入已应答状态。\n- 在已应答状态，可以保持已应答状态，或由请求方撤销 $req$ 在下一周期进入释放状态。\n- 在释放状态，可以保持释放状态，或由响应方撤销 $ack$ 在下一周期返回空闲状态。\n\n用其信号值所蕴含的 $\\{req, ack\\}$ 的适当子集来标记每个状态。基于此 Kripke 结构，考虑计算树逻辑 (CTL) 性质 $AF \\ \\text{ack}$，其含义是“在所有路径上，最终 $ack$ 成立”。仅使用 Kripke 结构和 CTL 语义的标准定义，确定满足 $K, s \\models AF \\ \\text{ack}$ 的状态 $s \\in S$ 的数量。请用一个整数表示您的最终答案。无需四舍五入，不涉及单位。",
            "solution": "该问题要求在一个表示同步握手协议的 Kripke 结构上，对一个计算树逻辑 (CTL) 公式进行求值。第一步是根据所给的描述来形式化定义这个 Kripke 结构。\n\n一个 Kripke 结构是一个元组 $K = (S, R, L)$，其中 $S$ 是一个状态集，$R \\subseteq S \\times S$ 是一个转移关系，$L: S \\to 2^{AP}$ 是一个标签函数，它将状态映射到来自集合 $AP$ 的为真的原子命题集。\n\n**1. Kripke 结构的形式化**\n\n**状态 ($S$):**\n问题指明了四个不同的控制状态。我们如下表示它们：\n- $s_I$: `Idle` (空闲) 状态。\n- $s_Q$: `Request` (请求) 状态。\n- $s_A$: `Acknowledged` (已应答) 状态。\n- $s_R$: `Release` (释放) 状态。\n因此，状态集为 $S = \\{s_I, s_Q, s_A, s_R\\}$。\n\n**原子命题 ($AP$) 和标签函数 ($L$):**\n原子命题给定为 $AP = \\{req, ack\\}$。标签函数 $L$ 由每个状态中的信号值确定：\n- `Idle` ($req$ 低, $ack$ 低): $L(s_I) = \\emptyset$。\n- `Request` ($req$ 高, $ack$ 低): $L(s_Q) = \\{req\\}$。\n- `Acknowledged` ($req$ 高, $ack$ 高): $L(s_A) = \\{req, ack\\}$。\n- `Release` ($req$ 低, $ack$ 高): $L(s_R) = \\{ack\\}$。\n\n**转移关系 ($R$):**\n转移约束定义了状态图的边。该关系必须是全转移关系，意味着每个状态都有一个出向转移。\n- 从 $s_I$ (`Idle`)，系统可以保持 `Idle` 或转移到 `Request`。这定义了转移 $(s_I, s_I) \\in R$ 和 $(s_I, s_Q) \\in R$。\n- 从 $s_Q$ (`Request`)，系统可以保持在 `Request` 或转移到 `Acknowledged`。这定义了转移 $(s_Q, s_Q) \\in R$ 和 $(s_Q, s_A) \\in R$。\n- 从 $s_A$ (`Acknowledged`)，系统可以保持 `Acknowledged` 或转移到 `Release`。这定义了转移 $(s_A, s_A) \\in R$ 和 $(s_A, s_R) \\in R$。\n- 从 $s_R$ (`Release`)，系统可以保持在 `Release` 或转移到 `Idle`。这定义了转移 $(s_R, s_R) \\in R$ 和 $(s_R, s_I) \\in R$。\n\n完整的转移关系是 $R = \\{(s_I, s_I), (s_I, s_Q), (s_Q, s_Q), (s_Q, s_A), (s_A, s_A), (s_A, s_R), (s_R, s_R), (s_R, s_I)\\}$。该关系是全转移关系，因为每个状态至少有一个后继状态。每个状态上的自环对应于问题中提到的非确定性延迟（例如，环境可能不发出 `req`，或者响应方可能延迟 `ack`）。\n\n**2. 对 CTL 性质 $AF\\;ack$ 求值**\n\n需要求值的 CTL 公式是 $AF\\;ack$。该公式的语义是：“对于从给定状态开始的所有计算路径，路径上存在某个未来的状态，其中命题 $ack$ 为真。”\n\n如果 $p \\in L(s)$，则状态 $s$ 满足命题 $p$（记作 $s \\models p$）。\n首先，我们来确定满足命题 $ack$ 的状态集合。\n从标签函数 $L$ 可知：\n- $s_A \\models ack$ 因为 $ack \\in L(s_A) = \\{req, ack\\}$。\n- $s_R \\models ack$ 因为 $ack \\in L(s_R) = \\{ack\\}$。\n状态 $s_I$ 和 $s_Q$ 不满足 $ack$，因为 $ack \\notin L(s_I)$ 且 $ack \\notin L(s_Q)$。\n令 $S_{ack} = \\{s \\in S \\mid s \\models ack\\} = \\{s_A, s_R\\}$。\n\n现在，我们必须对每个状态 $s \\in S$ 检查是否 $K, s \\models AF\\;ack$。一个状态 $s$ 满足 $AF\\;ack$ 的条件是，从 $s_0 = s$ 开始的每条无限路径 $\\pi = (s_0, s_1, s_2, \\dots)$ 都至少包含一个状态 $s_i$ 使得 $s_i \\in S_{ack}$。\n\n我们来分析每个状态：\n\n- **状态 $s_A$ (`Acknowledged`):**\n从 $s_A$ 开始的任何路径都以 $s_A$ 作为其第一个状态。由于 $s_A \\models ack$，所以“最终 $ack$”的条件在路径的一开始（在时间 $0$）就得到满足。这对从 $s_A$ 开始的所有路径都成立。因此，$K, s_A \\models AF\\;ack$。\n\n- **状态 $s_R$ (`Release`):**\n类似地，从 $s_R$ 开始的任何路径都以 $s_R$ 作为其第一个状态。由于 $s_R \\models ack$，条件立即得到满足。这对从 $s_R$ 开始的所有路径都成立。因此，$K, s_R \\models AF\\;ack$。\n\n- **状态 $s_I$ (`Idle`):**\n从状态 $s_I$，有两个可能的转移：到 $s_I$ 或到 $s_Q$。由于非确定性的选择，可以通过重复选择自环转移 $(s_I, s_I)$ 来形成一条有效的计算路径。这会产生无限路径 $\\pi = (s_I, s_I, s_I, \\dots)$。对于此路径上的每个状态 $s_i$，$s_i = s_I$，而我们知道 $s_I \\not\\models ack$。因此，我们找到了一个从 $s_I$ 开始但 $ack$ 永远不为真的路径。因为 $A$（“对所有路径”）量词的条件未被满足，所以该性质不成立。因此，$K, s_I \\not\\models AF\\;ack$。\n\n- **状态 $s_Q$ (`Request`):**\n从状态 $s_Q$，有两个可能的转移：到 $s_Q$ 或到 $s_A$。与 `Idle` 状态类似，可以通过重复选择自环转移 $(s_Q, s_Q)$ 来形成一条有效的计算路径。这会产生无限路径 $\\pi = (s_Q, s_Q, s_Q, \\dots)$。对于此路径上的每个状态 $s_i$，$s_i = s_Q$，而我们知道 $s_Q \\not\\models ack$。这条路径代表了响应方永不声明应答信号的场景。由于我们找到了一个从 $s_Q$ 开始且永远不会到达 $ack$ 为真的状态的路径，因此 $A$ 量词的条件未被满足。因此，$K, s_Q \\not\\models AF\\;ack$。\n\n**结论**\n性质 $K, s \\models AF\\;ack$ 成立的状态集合是 $\\{s_A, s_R\\}$。问题要求的是这类状态的*数量*。该集合中有两个状态。\n满足 $AF\\;ack$ 的状态数量是 $2$。",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "虽然显式状态模型检验方法很直观，但它难以应对状态空间随系统规模指数增长的复杂系统。本练习将介绍一种更为强大的技术——符号模型检验，它使用诸如二元决策图（BDD）之类的数据结构来紧凑地表示状态集和转移关系。你将为一个数字计数器建模，并应用一个经典的不动点算法来验证一个安全性属性，从而找出那些能保证系统永远保持安全的初始状态。",
            "id": "4282944",
            "problem": "考虑一个在典型数字集成电路中作为有限状态机实现的同步两位上计数器。该计数器有两个状态位 $x_{1}$（最高有效位）和 $x_{0}$（最低有效位），并在每个时钟上升沿模 $4$ 加一。将该计数器建模为一个Kripke结构，其状态空间由 $\\{x_{1}, x_{0}\\}$ 的所有赋值给出，转移关系从 $(x_{1}, x_{0})$ 到 $(x_{1}', x_{0}')$ 由电路的功能性次态逻辑定义。使用归约有序二元决策图（ROBDD）来编码布尔变量 $\\{x_{1}, x_{0}, x_{1}', x_{0}'\\}$ 上的转移关系，变量顺序为 $x_{1} \\prec x_{0} \\prec x_{1}' \\prec x_{0}'$。您可以假设理想的同步行为且无额外输入。\n\n使用计算树逻辑（CTL）的标准语义，其中 $EG\\,\\varphi$ 在一个状态上成立，如果存在一条从该状态开始的无限路径，在该路径的每一步上 $\\varphi$ 都成立；并使用状态集和关系的二元决策图（BDD）标准表示法，以及用于像和原像计算的存在量化，完成以下任务：\n\n- 为编码计数器转移关系 $T(x_{1}, x_{0}, x_{1}', x_{0}')$ 的ROBDD构建一个布尔公式，该公式直接从位级的模 $4$ 加一运算推导得出。\n- 令 $\\varphi(x_{1}, x_{0})$ 为表示计数值不等于 $3$（即二进制 $11$）的状态谓词。使用基于BDD的 $EG\\,\\varphi$ 不动点刻画和转移关系 $T$，计算满足 $EG(\\varphi)$ 的状态集。\n- 报告满足 $EG(\\varphi)$ 的状态集的基数（以整数形式）。\n\n将最终答案表示为单个整数，不带单位。无需四舍五入。",
            "solution": "该问题经验证是合理且定义明确的。这是符号模型检测中的一个标准练习。\n\n该系统是一个同步两位上计数器。状态由两位表示，$x_{1}$（最高有效位）和 $x_{0}$（最低有效位）。状态空间 $S$ 包含四个状态，可与整数 $0, 1, 2, 3$ 等同：\n- 状态 $0$：$(x_{1}, x_{0}) = (0, 0)$\n- 状态 $1$：$(x_{1}, x_{0}) = (0, 1)$\n- 状态 $2$：$(x_{1}, x_{0}) = (1, 0)$\n- 状态 $3$：$(x_{1}, x_{0}) = (1, 1)$\n\n计数器在每个时钟周期模 $4$ 加一。转移关系是确定性的。令 $(x_{1}', x_{0}')$ 为下一个时钟周期的状态。次态逻辑由二进制加法推导得出：\n- 最低有效位 $x_{0}'$ 的下一个值是其当前值的否定：$x_{0}' = \\neg x_{0}$。\n- 最高有效位 $x_{1}'$ 的下一个值当且仅当 $x_{0}$ 的当前值为 $1$ 时翻转：$x_{1}' = x_{1} \\oplus x_{0}$（异或）。\n\n转移关系 $T(x_{1}, x_{0}, x_{1}', x_{0}')$ 是一个关于当前状态变量 $\\{x_{1}, x_{0}\\}$ 和次态变量 $\\{x_{1}', x_{0}'\\}$ 的布尔函数。当且仅当 $(x_{1}', x_{0}')$ 是 $(x_{1}, x_{0})$ 的后继状态时，该函数对于一组变量赋值为真。$T$ 的公式为：\n$$T(x_{1}, x_{0}, x_{1}', x_{0}') \\equiv (x_{0}' \\leftrightarrow \\neg x_{0}) \\land (x_{1}' \\leftrightarrow (x_{1} \\oplus x_{0}))$$\n这一个关系编码了所有四个状态转移：\n- $T(0, 0, 0, 1)$ 为真，表示从状态 $0$ 到状态 $1$ 的转移。\n- $T(0, 1, 1, 0)$ 为真，表示从状态 $1$ 到状态 $2$ 的转移。\n- $T(1, 0, 1, 1)$ 为真，表示从状态 $2$ 到状态 $3$ 的转移。\n- $T(1, 1, 0, 0)$ 为真，表示从状态 $3$ 到状态 $0$ 的转移。\n在基于BDD的模型检测器中，这个布尔公式将使用指定的变量顺序 $x_{1} \\prec x_{0} \\prec x_{1}' \\prec x_{0}'$ 编译成一个归约有序二元决策图（ROBDD）。\n\n问题要求解满足计算树逻辑（CTL）公式 $EG(\\varphi)$ 的状态集。状态谓词 $\\varphi$ 定义为计数值不等于 $3$。状态 $3$ 对应于 $(x_{1}, x_{0}) = (1, 1)$。因此，谓词 $\\varphi$ 由以下布尔公式表示：\n$$\\varphi(x_{1}, x_{0}) \\equiv \\neg (x_{1} \\land x_{0})$$\n满足 $\\varphi$ 的状态集，我们记为 $S_\\varphi$，是 $\\{ (0,0), (0,1), (1,0) \\}$，对应于状态 $\\{0, 1, 2\\}$。\n\n满足 $EG(\\varphi)$ 的状态集被刻画为算子 $F(Y) = S_\\varphi \\cap \\text{PreImage}(Y)$ 的最大不动点，其中 $\\text{PreImage}(Y)$ 是存在到集合 $Y$ 中某个状态的转移的所有状态的集合。这对应于CTL语义 $EG(\\varphi) \\equiv \\nu Z . (\\varphi \\land EX(Z))$。该不动点通过迭代计算。令 $Y_k$ 为第 $k$ 次迭代时的状态集。\n计算最大不动点的标准算法从所有满足性质 $\\varphi$ 的状态集开始，并重复移除无法保持在该集合内的状态。\n令 $Y_{0} = S_\\varphi = \\{ (0,0), (0,1), (1,0) \\}$。\n迭代过程为 $Y_{k+1} = Y_k \\cap \\text{PreImage}(Y_k)$。当 $Y_{k+1} = Y_k$ 时，过程停止。\n\n$\\text{PreImage}$ 操作，对应于 $EX(Y)$，符号化定义为：\n$$ \\text{PreImage}(Y) = \\{ s \\mid \\exists s' \\in Y, T(s,s') \\} $$\n在基于BDD的框架中，如果 $Y(x_1', x_0')$ 是集合 $Y$ 的特征函数，则原像计算为 $\\exists x_{1}', x_{0}' . (T(x_{1}, x_{0}, x_{1}', x_{0}') \\land Y(x_{1}', x_{0}'))$。\n\n让我们执行迭代计算：\n初始步骤：\n$Y_{0} = S_\\varphi = \\{ (0,0), (0,1), (1,0) \\}$。\n\n迭代 1：\n我们计算 $\\text{PreImage}(Y_{0})$。这是在 $Y_{0} = \\{ (0,0), (0,1), (1,0) \\}$ 中有后继状态的状态集合。\n- 状态 $(0,0)$ 的前驱是 $(1,1)$。\n- 状态 $(0,1)$ 的前驱是 $(0,0)$。\n- 状态 $(1,0)$ 的前驱是 $(0,1)$。\n所以，$\\text{PreImage}(Y_{0}) = \\{ (1,1), (0,0), (0,1) \\}$。\n现在我们计算 $Y_{1} = Y_{0} \\cap \\text{PreImage}(Y_{0})$：\n$$Y_{1} = \\{ (0,0), (0,1), (1,0) \\} \\cap \\{ (1,1), (0,0), (0,1) \\} = \\{ (0,0), (0,1) \\}$$\n\n迭代 2：\n我们计算 $\\text{PreImage}(Y_{1})$，其中 $Y_{1} = \\{ (0,0), (0,1) \\}$。\n- 状态 $(0,0)$ 的前驱是 $(1,1)$。\n- 状态 $(0,1)$ 的前驱是 $(0,0)$。\n所以，$\\text{PreImage}(Y_{1}) = \\{ (1,1), (0,0) \\}$。\n现在我们计算 $Y_{2} = Y_{1} \\cap \\text{PreImage}(Y_{1})$：\n$$Y_{2} = \\{ (0,0), (0,1) \\} \\cap \\{ (1,1), (0,0) \\} = \\{ (0,0) \\}$$\n\n迭代 3：\n我们计算 $\\text{PreImage}(Y_{2})$，其中 $Y_{2} = \\{ (0,0) \\}$。\n- 状态 $(0,0)$ 的前驱是 $(1,1)$。\n所以，$\\text{PreImage}(Y_{2}) = \\{ (1,1) \\}$。\n现在我们计算 $Y_{3} = Y_{2} \\cap \\text{PreImage}(Y_{2})$：\n$$Y_{3} = \\{ (0,0) \\} \\cap \\{ (1,1) \\} = \\emptyset$$\n\n迭代 4：\n我们计算 $\\text{PreImage}(Y_{3})$，其中 $Y_{3} = \\emptyset$。\n空集的原像是空集，所以 $\\text{PreImage}(Y_{3}) = \\emptyset$。\n现在我们计算 $Y_{4} = Y_{3} \\cap \\text{PreImage}(Y_{3})$：\n$$Y_{4} = \\emptyset \\cap \\emptyset = \\emptyset$$\n\n由于 $Y_{4} = Y_{3}$，算法已达到不动点。满足 $EG(\\varphi)$ 的状态集是空集 $\\emptyset$。\n\n这个结果是直观的。公式 $EG(\\varphi)$ 在一个状态上成立，如果存在一条从该状态开始的无限路径，该路径从不访问状态 $3$（二进制 $11$）。计数器遵循一个单一的循环：$(0,0) \\to (0,1) \\to (1,0) \\to (1,1) \\to (0,0) \\to \\dots$。从任何起始状态开始，系统最终都保证会到达状态 $(1,1)$。因此，没有状态可以满足存在一条总是避开状态 $(1,1)$ 的路径这一性质。满足 $EG(\\varphi)$ 的状态集必须为空。\n\n结果集 $\\emptyset$ 的基数是 $0$。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "有时，完整证明一个属性的正确性在计算上非常困难，但找到一个违反该属性的错误（bug）则可能要快得多。有界模型检验（BMC）是一种高效的“错误查找”技术，它在有限的步数内搜索反例。本练习将让你扮演验证工程师的角色，实现一个基础的BMC算法，在几个抽象的流水线模型中，为违反活性（liveness）属性的行为找到最短的“套索形”反例。",
            "id": "4282914",
            "problem": "考虑一个用于在电子设计自动化（EDA）中抽象流水线控制的有限状态转移系统。该系统定义为一个元组 $M = (S, I, T, \\mathit{error})$，其中 $S$ 是一个有限状态集，$I \\subseteq S$ 是初始状态集，$T \\subseteq S \\times S$ 是转移关系，而 $\\mathit{error}: S \\to \\{\\mathit{true}, \\mathit{false}\\}$ 是一个当控制逻辑处于错误状态时成立的谓词。感兴趣的属性以线性时序逻辑（LTL）表示为 $F\\,\\mathit{error}$，读作“最终 $\\mathit{error}$”。在标准模型检测语义中，$F\\,\\mathit{error}$ 的反例是一个永不达到 $\\mathit{error}$ 成立状态的无限执行。\n\n有界模型检测（BMC）通过一个套索形路径（一个有限路径段后跟一个回环）来表示候选的无限执行。形式上，对于给定的界 $k \\in \\mathbb{N}$，套索是一个序列 $(s_0, s_1, \\dots, s_k)$，其中 $s_0 \\in I$，对于所有 $0 \\le i  k$ 都有 $(s_i, s_{i+1}) \\in T$，同时存在一个索引 $j$ 满足 $0 \\le j \\le k$ 且 $(s_k, s_j) \\in T$。对于 $F\\,\\mathit{error}$ 的特定反例，该序列必须满足对于所有 $0 \\le i \\le k$ 都有 $\\neg \\mathit{error}(s_i)$。回环约束 $(s_k, s_j) \\in T$ 确保存在一个最终周期性的无限执行 $(s_0, \\dots, s_k, s_j, \\dots, s_k, s_j, \\dots)$，它永远避免 $\\mathit{error}$。最小反例长度 $k_{\\min}$ 是存在这样套索的最小 $k$ 值。如果在给定的最大界 $K_{\\max}$ 内（或根本）不存在这样的套索，则返回 $-1$。\n\n你的任务是实现一个程序，为每个提供的测试模型计算满足上述回环约束的 $k_{\\min}$。程序必须从 $0$ 到 $K_{\\max}$ 系统地搜索递增的界 $k$，并确定是否存在一个序列 $(s_0, \\dots, s_k)$ 满足 $s_0 \\in I$，对于 $0 \\le i  k$ 有 $(s_i, s_{i+1}) \\in T$，对于所有 $0 \\le i \\le k$ 有 $\\neg \\mathit{error}(s_i)$，并且对于某个 $0 \\le j \\le k$ 存在一个回环 $(s_k, s_j) \\in T$。\n\n测试套件由五个模型组成。每个模型由以下内容指定：\n- 一个状态集 $S = \\{0, 1, \\dots, n-1\\}$。\n- 一个单一初始状态 $s_{\\mathit{init}} \\in S$。\n- 一个转移关系 $T$，由邻接表给出，将每个状态 $x \\in S$ 映射到后继状态列表 $\\{y \\in S \\mid (x,y) \\in T\\}$。\n- 一个错误谓词 $\\mathit{error}$，由子集 $E \\subseteq S$ 给出，其中 $\\mathit{error}(x)$ 成立。\n- 一个最大搜索界 $K_{\\max} \\in \\mathbb{N}$。\n\n这些模型是：\n\n模型 1（五级流水线，最终出错且无无错循环）：\n- $S = \\{0, 1, 2, 3, 4, 5\\}$，标签为 $0=\\mathit{IF}$（取指）, $1=\\mathit{ID}$（译码）, $2=\\mathit{EX}$（执行）, $3=\\mathit{MEM}$（访存）, $4=\\mathit{WB}$（写回）, $5=\\mathit{ERR}$（错误）。\n- $s_{\\mathit{init}} = 0$。\n- $T(0) = [1]$, $T(1) = [2]$, $T(2) = [3]$, $T(3) = [4]$, $T(4) = [5]$, $T(5) = [5]$。\n- $E = \\{5\\}$。\n- $K_{\\max} = 6$。\n预期行为：不存在避免 $\\mathit{error}$ 的套索；返回 $-1$。\n\n模型 2（由于冒险永不清除导致的持续停顿；错误永不发生；停顿自循环）：\n- $S = \\{0, 1, 2\\}$，标签为 $0=\\mathit{IF}$（取指）, $1=\\mathit{ID}$（译码）, $2=\\mathit{STALL}$（停顿）。\n- $s_{\\mathit{init}} = 0$。\n- $T(0) = [1]$, $T(1) = [2]$, $T(2) = [2]$。\n- $E = \\{\\}$。\n- $K_{\\max} = 5$。\n预期行为：在 $k = 2$ 处有最小套索，使用回环 $(2,2)$；返回 $2$。\n\n模型 3（译码-执行两周期循环，无错误）：\n- $S = \\{0, 1, 2\\}$，标签为 $0=\\mathit{IF}$（取指）, $1=\\mathit{ID}$（译码）, $2=\\mathit{EX}$（执行）。\n- $s_{\\mathit{init}} = 0$。\n- $T(0) = [1]$, $T(1) = [2]$, $T(2) = [1]$。\n- $E = \\{\\}$。\n- $K_{\\max} = 5$。\n预期行为：在 $k = 2$ 处有最小套索，回环为 $(2,1)$；返回 $2$。\n\n模型 4（复位-取指循环，无错误；回环到较早状态）：\n- $S = \\{0, 1\\}$，标签为 $0=\\mathit{RESET}$（复位）, $1=\\mathit{IF}$（取指）。\n- $s_{\\mathit{init}} = 0$。\n- $T(0) = [1]$, $T(1) = [0]$。\n- $E = \\{\\}$。\n- $K_{\\max} = 3$。\n预期行为：在 $k = 1$ 处有最小套索，回环为 $(1,0)$；返回 $1$。\n\n模型 5（五级流水线，带有避免错误的写回-译码循环）：\n- $S = \\{0, 1, 2, 3, 4\\}$，标签为 $0=\\mathit{IF}$（取指）, $1=\\mathit{ID}$（译码）, $2=\\mathit{EX}$（执行）, $3=\\mathit{MEM}$（访存）, $4=\\mathit{WB}$（写回）。\n- $s_{\\mathit{init}} = 0$。\n- $T(0) = [1]$, $T(1) = [2]$, $T(2) = [3]$, $T(3) = [4]$, $T(4) = [1]$。\n- $E = \\{\\}$。\n- $K_{\\max} = 5$。\n预期行为：在 $k = 4$ 处有最小套索，回环为 $(4,1)$；返回 $4$。\n\n你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是根据所描述的 BMC 套索语义计算出的模型 $i$ 的最小反例长度 $k_{\\min}$。不需要物理单位，所有答案必须是整数。",
            "solution": "该问题陈述在形式上是定义良好的，科学上基于有界模型检测（BMC）用于线性时序逻辑（LTL）的原理，并为每个测试用例提供了一套完整且一致的给定条件。因此，该问题被认为是有效的。\n\n任务是找到 LTL 属性 $F\\,\\mathit{error}$ 的最小反例长度，表示为 $k_{\\min}$。此属性的一个反例是系统的一次无限执行，它从不进入 $\\mathit{error}$ 谓词成立的状态。在 BMC 的上下文中，这样的反例由一个套索形路径表示。\n\n一个套索由一个界 $k \\in \\mathbb{N}$ 定义，构成一个路径 $(s_0, s_1, \\dots, s_k)$，满足以下条件：\n$1$. 路径从一个初始状态开始：$s_0 \\in I$。\n$2$. 路径遵循有效的转移：对于所有 $0 \\le i  k$ 的 $i$，有 $(s_i, s_{i+1}) \\in T$。\n$3$. 路径上的所有状态都是非错误状态：对于所有 $0 \\le i \\le k$ 的 $i$，有 $\\neg \\mathit{error}(s_i)$。\n$4$. 存在一个从路径末端到路径中某个状态的回环转移：存在一个索引 $j$，满足 $0 \\le j \\le k$，使得 $(s_k, s_j) \\in T$。\n\n我们的目标是在给定的最大搜索界 $K_{\\max}$ 内，找到存在这样一个套索的最小非负整数 $k$。如果在 $k \\le K_{\\max}$ 范围内不存在这样的 $k$，结果为 $-1$。\n\n算法方法是对路径长度 $k$ 进行迭代搜索，从 $k=0$ 开始，递增到 $K_{\\max}$。该方法系统地探索长度递增的套索。\n\n首先，我们确定“安全”状态集，即所有满足 $\\neg \\mathit{error}(s)$ 的状态 $s \\in S$。整个路径搜索都限制在这个状态子集内。如果初始状态 $s_{\\mathit{init}}$ 不在安全状态集中，则无法形成有效路径，我们可以立即得出结论，不存在反例。\n\n搜索过程如下：\n\n对于 $k=0$：\n长度为 $0$ 的路径就是初始状态 $(s_0)$。要在此长度存在套索，路径必须是安全的（即 $\\neg \\mathit{error}(s_0)$），并且必须有一个回环。唯一可能的回环是回到自身，因此条件是 $(s_0, s_0) \\in T$。如果这两个条件都满足，则 $k_{\\min} = 0$。\n\n对于 $k  0$：\n搜索被构造为对路径的广度优先探索。我们维护一个给定长度的所有安全路径的集合。\n设 $\\mathcal{P}_k$ 为所有长度为 $k$ 的安全路径的集合。根据定义，路径 $(s_0, \\dots, s_k) \\in \\mathcal{P}_k$ 已满足条件 1、2 和 3（部分满足，直到 $s_{k-1}$）。\n\n在每个步骤 $k$（从 $1$ 到 $K_{\\max}$），我们通过扩展 $\\mathcal{P}_{k-1}$ 中的路径来构建路径集合 $\\mathcal{P}_k$。对于每个路径 $(s_0, \\dots, s_{k-1}) \\in \\mathcal{P}_{k-1}$，我们考虑最后一个状态 $s_{k-1}$ 的所有后继状态 $s_k$。如果后继状态 $s_k$ 是一个安全状态，我们就形成一个新路径 $(s_0, \\dots, s_{k-1}, s_k)$，并将其添加到 $\\mathcal{P}_k$ 中。\n\n在生成 $\\mathcal{P}_k$ 中的所有路径后，我们检查每个新路径是否满足回环条件（条件 4）。对于每个路径 $p = (s_0, \\dots, s_k) \\in \\mathcal{P}_k$，我们检查是否存在从其最终状态 $s_k$ 到路径 $p$ 中已存在的任何状态 $s_j$ 的转移。也就是说，我们检查是否存在一个 $j \\in \\{0, \\dots, k\\}$ 使得 $(s_k, s_j) \\in T$。\n\n我们找到的第一个满足此回环条件的 $k$ 值就是最小反例长度 $k_{\\min}$。然后搜索终止并返回此 $k$ 值。\n\n如果在任何步骤 $k$，集合 $\\mathcal{P}_k$ 变为空，这意味着无法形成长度为 $k$ 的安全路径。因此，也无法形成更长的安全路径，所以搜索终止，我们得出结论不存在合适的套索。\n\n如果循环在 $0$ 到 $K_{\\max}$ 的所有 $k$ 值上都完成而没有找到套索，我们返回 $-1$。\n\n这种迭代的、逐层构建路径的方法确保我们能找到具有最小可能长度 $k$ 的套索。该算法将在一个函数中实现，该函数处理所提供的五个模型中的每一个。",
            "answer": "```python\nimport numpy as np\n\ndef find_k_min(n, s_init, T, E, K_max):\n    \"\"\"\n    Computes the minimal counterexample length k_min for the LTL property F error.\n\n    This function implements a Bounded Model Checking (BMC) search for a lasso-shaped\n    counterexample. It iteratively searches for paths of increasing length k.\n\n    Args:\n        n (int): The number of states, S = {0, ..., n-1}.\n        s_init (int): The single initial state.\n        T (dict): The transition relation as an adjacency list (dict of lists).\n        E (set): The set of error states.\n        K_max (int): The maximum search bound for the path length k.\n\n    Returns:\n        int: The minimal counterexample length k_min, or -1 if no such lasso\n             is found up to K_max.\n    \"\"\"\n    safe_states = set(range(n)) - E\n\n    if s_init not in safe_states:\n        return -1\n\n    # Base case: k = 0\n    # A path of length 0 is (s_0). The loop-back must be (s_0, s_0).\n    if s_init in T.get(s_init, []):\n        return 0\n\n    # paths_at_k stores all safe paths of current length k, starting with k=0.\n    # A path is a list of states.\n    paths_at_k = [[s_init]]\n\n    for k in range(1, K_max + 1):\n        paths_at_k_plus_1 = []\n        for path in paths_at_k:\n            last_state = path[-1]\n            for successor in T.get(last_state, []):\n                if successor in safe_states:\n                    new_path = path + [successor] # Create a new path by extending\n                    paths_at_k_plus_1.append(new_path)\n\n        if not paths_at_k_plus_1:\n            # No safe paths of length k could be constructed.\n            # No longer safe paths can exist either.\n            return -1\n\n        paths_at_k = paths_at_k_plus_1\n\n        # For each new path of length k, check the loop-back condition.\n        for path in paths_at_k:\n            s_k = path[-1]\n            \n            # Using a set for efficient membership checking.\n            path_states_set = set(path)\n            \n            for successor in T.get(s_k, []):\n                # The loop-back condition requires (s_k, s_j) in T, where s_j is in the path.\n                if successor in path_states_set:\n                    # A lasso is found. Since we are iterating k upwards,\n                    # this is the minimal k.\n                    return k\n\n    # If the loop finishes without finding a lasso up to K_max.\n    return -1\n\n\ndef solve():\n    \"\"\"\n    Defines the models from the problem statement and computes k_min for each.\n    \"\"\"\n    test_cases = [\n        # Model 1\n        {'n': 6, 's_init': 0, 'T': {0: [1], 1: [2], 2: [3], 3: [4], 4: [5], 5: [5]}, 'E': {5}, 'K_max': 6},\n        # Model 2\n        {'n': 3, 's_init': 0, 'T': {0: [1], 1: [2], 2: [2]}, 'E': set(), 'K_max': 5},\n        # Model 3\n        {'n': 3, 's_init': 0, 'T': {0: [1], 1: [2], 2: [1]}, 'E': set(), 'K_max': 5},\n        # Model 4\n        {'n': 2, 's_init': 0, 'T': {0: [1], 1: [0]}, 'E': set(), 'K_max': 3},\n        # Model 5\n        {'n': 5, 's_init': 0, 'T': {0: [1], 1: [2], 2: [3], 3: [4], 4: [1]}, 'E': set(), 'K_max': 5},\n    ]\n\n    results = []\n    for case in test_cases:\n        k_min = find_k_min(case['n'], case['s_init'], case['T'], case['E'], case['K_max'])\n        results.append(k_min)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\nsolve()\n\n```"
        }
    ]
}