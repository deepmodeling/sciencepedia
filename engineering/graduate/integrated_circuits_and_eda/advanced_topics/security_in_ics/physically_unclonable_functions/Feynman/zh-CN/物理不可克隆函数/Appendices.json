{
    "hands_on_practices": [
        {
            "introduction": "物理不可克隆函数（PUF）的核心价值在于其“唯一性”，即便是相同设计的芯片，由于制造过程中不可控的微观差异，也会产生独一无二的响应。为了量化这一关键特性，我们通常从一个理想化的模型出发。本实践旨在通过一个基础的概率计算，帮助您理解理想唯一性的概念。\n\n通过将PUF的每一位响应看作是独立的、概率为 $p=0.5$ 的伯努利试验，您将计算两个独立的PUF对同一激励产生完全相同响应的概率 。这个练习不仅能巩固您对PUF唯一性度量（如芯片间汉明距离）的理解，也揭示了PUF作为硬件安全基石的理论依据。",
            "id": "4289335",
            "problem": "考虑一个实现物理不可克隆函数 (PUF) 的集成电路系列，其中，由于不可控的制造差异，一个固定的挑战（challenge）会确定性地映射到每个芯片的 $n$ 位响应。假设芯片间具有理想的唯一性：对于任何固定的挑战，不同芯片上响应的每一位都是参数为 $0.5$ 的独立同分布的伯努利随机变量，并且位与位之间、芯片与芯片之间都是独立的。同时假设具有完美的可靠性（无测量噪声），因此每个芯片对固定挑战的响应在重复读取中是稳定的。\n\n随机选择两个独立制造的芯片，并用相同的固定挑战查询一次，产生两个 $n$ 位响应。在上述假设下，确定这两个响应按位相同的确切概率。请将您的最终答案表示为 $n$ 的封闭形式函数。无需四舍五入，结果无单位。",
            "solution": "在尝试求解之前，将首先验证问题的科学性和逻辑合理性。\n\n### 步骤 1：提取已知条件\n- 该系统涉及一个具有物理不可克隆函数（PUF）的集成电路系列。\n- 一个固定的挑战映射到一个 $n$ 位响应 $R$。\n- 对于给定的芯片，响应是确定性的，但由于制造过程的原因，不同芯片之间的响应会有所不同。\n- **理想唯一性假设：** 对于一个固定的挑战，不同芯片上响应的每一位都是参数为 $p=0.5$ 的独立同分布（i.i.d.）伯努利随机变量。\n- 在一个响应中，各位之间是独立的。\n- 不同芯片之间的响应是独立的。\n- **完美可靠性假设：** 芯片响应随时间是稳定的（无测量噪声）。\n- 随机独立地选择两个芯片。\n- 用相同的固定挑战查询它们，产生两个 $n$ 位响应。\n- 目标是求出这两个响应按位相同的确切概率。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题基于硬件安全领域中物理不可克隆函数（PUF）的既定概念。所描述的概率模型（参数 $p=0.5$ 的独立同分布伯努利位）是文献中用于分析 PUF“唯一性”属性的标准理想化模型。该模型代表了不可预测性的理论理想，作为建模练习是科学合理的。\n2.  **适定性：** 这是一个适定问题。它提供了一个完整的概率模型，并要求基于该模型计算一个特定的概率。所有必要的参数（$n$ 和概率分布）都已定义，确保存在一个唯一的、稳定的解。\n3.  **客观性：** 问题以精确、客观的数学语言陈述。它没有歧义、主观性或观点。\n4.  **完整性与一致性：** 问题是自洽的，其假设是一致的。位间独立、芯片间独立以及伯努利分布的概念是相互兼容的，并且足以解决该问题。\n5.  **现实性：** 尽管“理想唯一性”和“完美可靠性”的假设是在实践中无法完全满足的理想化情况，但它们是创建易于处理的理论模型的标准和必要条件。问题是在此模型的框架内提出的，因此是有效的。\n\n### 步骤 3：结论与行动\n该问题被认为是有效的，因为其具有科学依据、适定、客观且内部一致。下面将推导解答。\n\n### 解答推导\n设来自两个独立制造的芯片的两个 $n$ 位响应由随机向量 $R_1$ 和 $R_2$ 表示。\n$$R_1 = (B_{1,1}, B_{1,2}, \\dots, B_{1,n})$$\n$$R_2 = (B_{2,1}, B_{2,2}, \\dots, B_{2,n})$$\n这里，$B_{j,i}$ 表示第 $j$ 个芯片响应的第 $i$ 位，其中 $j \\in \\{1, 2\\}$ 且 $i \\in \\{1, 2, \\dots, n\\}$。\n\n根据问题陈述，对于任何固定的挑战：\n1.  每一位 $B_{j,i}$ 都是一个参数为 $p=0.5$ 的伯努利随机变量。即 $P(B_{j,i} = 1) = 0.5$ 且 $P(B_{j,i} = 0) = 0.5$。\n2.  位与位之间是独立的。这意味着对于给定的芯片 $j$，随机变量 $B_{j,1}, B_{j,2}, \\dots, B_{j,n}$ 是相互独立的。\n3.  芯片之间的响应是独立的。这意味着随机向量 $R_1$ 独立于随机向量 $R_2$。因此，第一个芯片的任何位 $B_{1,i}$ 都独立于第二个芯片的任何位 $B_{2,k}$，对于所有的 $i, k$。\n\n我们需要求出两个响应按位相同的概率。这对应于事件 $R_1 = R_2$，可以写成每个位上事件的交集：\n$$E = (B_{1,1} = B_{2,1}) \\cap (B_{1,2} = B_{2,2}) \\cap \\dots \\cap (B_{1,n} = B_{2,n})$$\n我们所求的概率是 $P(E)$。\n\n由于各位之间的独立性，我们可以将交集的概率写为各个概率的乘积：\n$$P(E) = P\\left(\\bigcap_{i=1}^{n} (B_{1,i} = B_{2,i})\\right) = \\prod_{i=1}^{n} P(B_{1,i} = B_{2,i})$$\n\n现在，我们来计算在单个任意位置 $i$ 的位相等的概率，即 $P(B_{1,i} = B_{2,i})$。事件 $B_{1,i} = B_{2,i}$ 发生，当且仅当两位都是 $0$ 或者两位都是 $1$。这是两个互斥事件。\n$$P(B_{1,i} = B_{2,i}) = P( (B_{1,i}=0 \\text{ and } B_{2,i}=0) \\text{ or } (B_{1,i}=1 \\text{ and } B_{2,i}=1) )$$\n$$P(B_{1,i} = B_{2,i}) = P(B_{1,i}=0, B_{2,i}=0) + P(B_{1,i}=1, B_{2,i}=1)$$\n由于芯片是独立的，所以 $B_{1,i}$ 和 $B_{2,i}$ 是独立的随机变量。因此，联合概率可以表示为它们边际概率的乘积：\n$$P(B_{1,i} = B_{2,i}) = P(B_{1,i}=0) P(B_{2,i}=0) + P(B_{1,i}=1) P(B_{2,i}=1)$$\n根据问题陈述，我们知道所有的位都服从参数为 $p=0.5$ 的伯努利分布。为精确起见，我们使用分数 $\\frac{1}{2}$。\n$$P(B_{j,i}=0) = \\frac{1}{2} \\quad \\text{and} \\quad P(B_{j,i}=1) = \\frac{1}{2}$$\n代入这些值：\n$$P(B_{1,i} = B_{2,i}) = \\left(\\frac{1}{2} \\times \\frac{1}{2}\\right) + \\left(\\frac{1}{2} \\times \\frac{1}{2}\\right) = \\frac{1}{4} + \\frac{1}{4} = \\frac{2}{4} = \\frac{1}{2}$$\n在任何单个位位置上匹配的概率是 $\\frac{1}{2}$。对于所有位位置 $i=1, \\dots, n$，这个结果都是相同的。\n\n最后，我们将此结果代回总概率 $P(E)$ 的乘积公式中：\n$$P(E) = \\prod_{i=1}^{n} \\frac{1}{2} = \\left(\\frac{1}{2}\\right)^n$$\n这个表达式表示在给定的理想条件下，两个 $n$ 位响应按位相同的确切概率。它也可以写成 $2^{-n}$。",
            "answer": "$$\\boxed{\\left(\\frac{1}{2}\\right)^n}$$"
        },
        {
            "introduction": "在理想模型之外，现实世界中的PUF必须面对各种物理因素的挑战，如器件老化、温度变化和环境噪声，这些都会影响其响应的“可靠性”。为了构建一个在整个生命周期内都足够稳健的系统，我们必须对这些非理想效应进行建模，并设计相应的补偿机制。\n\n本实践  提供了一个典型的系统级设计问题。您将综合考虑初始工艺偏差、老化效应和噪声的统计模型（通常用高斯分布描述），来估算PUF的比特错误率 $p$。基于此，您将进一步确定所需的纠错码（ECC）强度 $t$，以确保密钥生成失败的概率低于一个极小的阈值 $\\epsilon$，这是将PUF从理论转化为可靠安全应用的关键一步。",
            "id": "4289312",
            "problem": "一个基于静态随机存取存储器 (SRAM) 的物理不可克隆函数 (PUF) 用于派生一个可复现的加密密钥。在注册阶段，每个单元的带符号稳定性裕度 $M_{0}$（通过瞬时环境噪声的标准差进行归一化）被建模为高斯分布，$M_{0} \\sim \\mathcal{N}(\\mu_{0}, \\sigma_{0}^{2})$。在设备生命周期内，老化会引起裕度的加性退化 $A$，其中 $A \\sim \\mathcal{N}(\\mu_{A}, \\sigma_{A}^{2})$，且与 $M_{0}$ 独立。在每次密钥再生过程中，瞬时环境噪声 $N$ 被建模为 $N \\sim \\mathcal{N}(0, \\sigma_{n}^{2})$，且与 $M_{0}$ 和 $A$ 独立。再生比特等于 $M_{0} - A + N$ 的符号，对于一个初始稳定且为正的单元，如果 $M_{0} - A + N  0$，则会发生相对于注册时的比特翻转。\n\n假设一个纠错码 (ECC)，例如 Bose–Chaudhuri–Hocquenghem (BCH) 码，可以纠正长度为 $n$ 比特的 PUF 响应中最多 $t$ 个比特错误。如果比特错误数量超过 $t$，则发生密钥失效。假设以下统计上和物理上一致的参数：\n- $n = 1024$,\n- $\\mu_{0} = 1.4$,\n- $\\sigma_{0} = 0.35$,\n- $\\mu_{A} = 0.25$,\n- $\\sigma_{A} = 0.10$,\n- $\\sigma_{n} = 0.50$.\n\n在所述模型下，假设不同单元之间的比特错误是独立的。密钥失效概率要求是在设备生命周期内，超过 $t$ 个错误的概率最多为 $\\epsilon = 10^{-6}$。\n\n仅使用高斯模型和二项模型的第一性原理概率，确定最小整数 $t$（所需的纠错能力），使得不可纠正错误事件的概率最多为 $\\epsilon$。提供 $t$ 的单个整数值。不需要单位，除了返回满足要求的确切整数外，没有其他舍入指令。",
            "solution": "在尝试给出解决方案之前，所述问题需经过验证过程。\n\n### 步骤 1：提取给定条件\n- 物理不可克隆函数 (PUF) 基于静态随机存取存储器 (SRAM)。\n- 在注册阶段，单元的带符号稳定性裕度 $M_{0}$ 被建模为高斯随机变量：$M_{0} \\sim \\mathcal{N}(\\mu_{0}, \\sigma_{0}^{2})$。\n- 老化引起加性退化 $A$，其中 $A \\sim \\mathcal{N}(\\mu_{A}, \\sigma_{A}^{2})$。\n- 瞬时环境噪声 $N$ 被建模为 $N \\sim \\mathcal{N}(0, \\sigma_{n}^{2})$。\n- 变量 $M_{0}$、$A$ 和 $N$ 相互独立。\n- 再生比特是 $M_{0} - A + N$ 的符号。\n- 对于一个初始为正的单元，如果 $M_{0} - A + N  0$，则发生比特翻转。\n- 纠错码 (ECC) 最多可以纠正 $t$ 个比特错误。\n- PUF 响应长度为 $n$ 比特。\n- 如果比特错误数量超过 $t$，则发生密钥失效。\n- 不同单元之间的比特错误是独立的。\n- 密钥失效的概率必须最多为 $\\epsilon$。\n- 参数：\n  - $n = 1024$\n  - $\\mu_{0} = 1.4$\n  - $\\sigma_{0} = 0.35$\n  - $\\mu_{A} = 0.25$\n  - $\\sigma_{A} = 0.10$\n  - $\\sigma_{n} = 0.50$\n  - $\\epsilon = 10^{-6}$\n- 任务是找到满足密钥失效概率要求的最小整数 $t$。\n\n### 步骤 2：使用提取的给定条件进行验证\n- **科学基础**：该问题在集成电路可靠性和硬件安全领域有充分的依据。使用高斯分布来建模工艺变化 ($M_0$)、老化效应 ($A$) 和环境噪声 ($N$) 是分析 SRAM PUF 的一种标准且物理上合理的方法。该模型是评估 PUF 可靠性的一种公认方法。\n- **问题明确**：问题定义清晰，提供了所有必要的参数和约束。它要求一个唯一的最小整数值 $t$，这可以从给定的信息中确定。\n- **客观性**：问题陈述以精确、量化和无偏见的语言表达，不含主观因素。\n- **缺陷检查**：\n  1. **科学/事实不准确**：无。该模型与电气工程中已建立的原理一致。\n  2. **不可形式化/不相关**：无。该问题是一个与主题直接相关的形式化数学问题。\n  3. **设置不完整/矛盾**：无。该问题是自洽的，没有矛盾。所提供的参数被明确说明为“统计上和物理上一致”。\n  4. **不切实际/不可行**：无。给定的参数值对于现代半导体技术中的归一化裕度是合理的。\n  5. **不适定/结构不良**：无。存在唯一且稳定的解。\n  6. **伪深刻/琐碎**：无。该问题需要多步应用概率论，并非琐碎问题。\n  7. **超出科学可验证范围**：无。结果是可以通过数学推导和验证的。\n\n### 步骤 3：结论与行动\n此问题是**有效的**。将根据所提供的信息推导出解决方案。\n\n### 解题过程\n目标是确定长度为 $n=1024$ 的 PUF 响应所需的最小整数纠错能力 $t$，使得不可纠正错误的概率 $P(\\text{failure})$ 最多为 $\\epsilon = 10^{-6}$。\n\n首先，我们确定单个比特错误的概率，记为 $p$。当再生裕度为负时，一个初始稳定且为正的单元会发生比特错误（或翻转）。再生裕度是一个随机变量 $X$，定义为：\n$$X = M_{0} - A + N$$\n初始比特对应于 $M_{0}$ 的符号。对于一个初始为正的单元，翻转意味着 $M_{0} > 0$ 且 $X  0$。通过假设我们正在分析为密钥选择的单元（这些单元因其稳定性而被选中），问题得以简化。鉴于初始均值 $\\mu_{0} = 1.4$ 和标准差 $\\sigma_{0} = 0.35$ 较高，一个单元初始为负的概率极小 ($P(M_0  0) = \\Phi((0-1.4)/0.35) = \\Phi(-4) \\approx 3.17 \\times 10^{-5}$)。因此，我们可以继续计算翻转概率 $p = P(X  0)$。\n\n由于 $M_{0}$、$A$ 和 $N$ 是独立的高斯随机变量，它们的线性组合 $X$ 也是一个高斯随机变量，$X \\sim \\mathcal{N}(\\mu_{X}, \\sigma_{X}^{2})$。\n\n$X$ 的均值为：\n$$\\mu_{X} = E[M_{0} - A + N] = E[M_{0}] - E[A] + E[N]$$\n$$\\mu_{X} = \\mu_{0} - \\mu_{A} + 0 = 1.4 - 0.25 = 1.15$$\n\n$X$ 的方差为：\n$$\\sigma_{X}^{2} = \\text{Var}(M_{0} - A + N) = \\text{Var}(M_{0}) + \\text{Var}(-A) + \\text{Var}(N)$$\n由于独立性，方差相加。并且，$\\text{Var}(-A) = (-1)^2 \\text{Var}(A) = \\text{Var}(A)$。\n$$\\sigma_{X}^{2} = \\sigma_{0}^{2} + \\sigma_{A}^{2} + \\sigma_{n}^{2}$$\n代入给定值：\n$$\\sigma_{X}^{2} = (0.35)^{2} + (0.10)^{2} + (0.50)^{2} = 0.1225 + 0.0100 + 0.2500 = 0.3825$$\n\n单个比特错误的概率 $p$ 是 $P(X  0)$。为了计算这个概率，我们对变量 $X$ 进行标准化：\n$$p = P(X  0) = P\\left(\\frac{X - \\mu_{X}}{\\sigma_{X}}  \\frac{0 - \\mu_{X}}{\\sigma_{X}}\\right)$$\n令 $Z = (X - \\mu_{X}) / \\sigma_{X}$ 为一个标准正态变量，$Z \\sim \\mathcal{N}(0, 1)$。该概率由标准正态累积分布函数 (CDF) $\\Phi$ 给出：\n$$p = \\Phi\\left(-\\frac{\\mu_{X}}{\\sigma_{X}}\\right) = \\Phi\\left(-\\frac{1.15}{\\sqrt{0.3825}}\\right)$$\n数值上，参数约为 $-1.15 / 0.618466 \\approx -1.85943$。因此，单个比特错误概率为：\n$$p = \\Phi(-1.85943) \\approx 0.031482$$\n\n令 $K$ 为表示 $n$ 比特响应中比特错误总数的随机变量。由于假设比特错误是独立的，$K$ 服从参数为 $n$ 和 $p$ 的二项分布：\n$$K \\sim \\text{Binomial}(n, p)$$\n其中 $n = 1024$ 且 $p \\approx 0.031482$。\n\n如果错误数量 $K$ 大于 ECC 的纠错能力 $t$，则发生密钥失效。此事件的概率必须最多为 $\\epsilon$：\n$$P(K > t) \\le \\epsilon$$\n$$ \\sum_{k=t+1}^{n} \\binom{n}{k} p^k (1-p)^{n-k} \\le 10^{-6}$$\n\n由于 $n$ 很大，我们可以使用正态近似来处理二项分布。该近似是有效的，因为 $np = 1024 \\times 0.031482 \\approx 32.24 > 5$ 且 $n(1-p) \\approx 991.76 > 5$。\n$K$ 的均值为 $\\mu_{K} = np = 32.2378...$\n$K$ 的方差为 $\\sigma_{K}^{2} = np(1-p) = (32.2378...)(1 - 0.031482) \\approx 31.222...$\n$K$ 的标准差为 $\\sigma_{K} = \\sqrt{31.222...} \\approx 5.5876...$\n\n我们应用连续性校正，以使用连续正态分布来近似离散的二项分布：\n$$P(K > t) = P(K \\ge t+1) \\approx P(\\mathcal{N}(\\mu_{K}, \\sigma_{K}^{2}) \\ge t+0.5)$$\n将其标准化，我们得到：\n$$P\\left(Z \\ge \\frac{t + 0.5 - \\mu_{K}}{\\sigma_{K}}\\right) \\le \\epsilon$$\n其中 $Z \\sim \\mathcal{N}(0, 1)$。这可以用累积分布函数 $\\Phi$ 来表示：\n$$1 - \\Phi\\left(\\frac{t + 0.5 - \\mu_{K}}{\\sigma_{K}}\\right) \\le \\epsilon$$\n$$\\Phi\\left(\\frac{t + 0.5 - \\mu_{K}}{\\sigma_{K}}\\right) \\ge 1 - \\epsilon$$\n令 $z_{\\epsilon}$ 为标准正态分布的临界值，使得 $\\Phi(z_{\\epsilon}) = 1 - \\epsilon$。\n$$\\frac{t + 0.5 - \\mu_{K}}{\\sigma_{K}} \\ge z_{\\epsilon} = \\Phi^{-1}(1 - 10^{-6})$$\n$\\Phi^{-1}(0.999999)$ 的值约为 $4.7534$。\n现在我们求解 $t$：\n$$t + 0.5 - \\mu_{K} \\ge z_{\\epsilon} \\sigma_{K}$$\n$$t \\ge z_{\\epsilon} \\sigma_{K} + \\mu_{K} - 0.5$$\n代入数值：\n$$t \\ge (4.7534)(5.5876) + 32.2378 - 0.5$$\n$$t \\ge 26.560 + 32.238 - 0.5$$\n$$t \\ge 58.798 - 0.5$$\n$$t \\ge 58.298$$\n由于 $t$ 必须是整数，满足此条件的最小 $t$ 值是大于或等于 $58.298$ 的最小整数。\n\n因此，所需的最小纠错能力为 $t = 59$。\n\n为了验证，我们可以使用二项累积分布函数检查 $t=58$ 和 $t=59$ 时的失效概率。\n对于 $t=58$，$P(K > 58) \\approx 1.25 \\times 10^{-6}$，大于 $10^{-6}$。\n对于 $t=59$，$P(K > 59) \\approx 6.8 \\times 10^{-7}$，小于 $10^{-6}$。\n计算得到证实。$t$ 的最小整数值为 $59$。",
            "answer": "$$ \\boxed{59} $$"
        },
        {
            "introduction": "对PUF进行参数化建模是现代硬件安全分析中的一项核心技术，它不仅是性能表征的基础，也是评估其对建模攻击脆弱性的关键。特别是对于延迟型PUF，其复杂的物理行为通常可以通过一个线性模型来近似，该模型的系数可以从实验数据中学习得到。\n\n这项编码实践  将带您亲手实现这一过程。您需要利用校准测量数据，通过最小二乘法来估计延迟模型的权重向量 $\\widehat{\\mathbf{w}}$。然后，您将运用这个训练好的模型来预测PUF在特定温度变化下的响应稳定性，从而体验连接电路物理、电子设计自动化（EDA）和机器学习方法的完整工作流程。",
            "id": "4289315",
            "problem": "在集成电路和电子设计自动化 (EDA) 领域，考虑一个基于延迟的物理不可克隆函数 (PUF)。在参考工作点，一个常见的路径延迟参数模型是：具有特征向量 $\\mathbf{x} \\in \\mathbb{R}^n$ 的结构的延迟被建模为一个未知系数向量 $\\mathbf{w} \\in \\mathbb{R}^n$ 的线性泛函，并且对于一个小的温度变化 $\\Delta T$，其温度依赖性可以通过一个已知灵敏度向量 $\\mathbf{s} \\in \\mathbb{R}^n$ 使用一阶灵敏度来近似。形式上，在温度偏移 $\\Delta T$ 处的延迟为\n$$\nd(\\mathbf{x}, \\Delta T) \\approx \\mathbf{x}^\\top \\mathbf{w} + \\Delta T \\cdot \\mathbf{x}^\\top \\mathbf{s},\n$$\n该公式由关于参考温度的一阶泰勒展开得出。\n\nPUF 响应比特是通过比较具有特征向量 $\\mathbf{x}_a$ 和 $\\mathbf{x}_b$ 的两条路径产生的。在参考温度下的标称决策裕度是带符号的差值\n$$\nm_0 = \\left(\\mathbf{x}_a - \\mathbf{x}_b\\right)^\\top \\mathbf{w},\n$$\n其一阶温度引起的偏移为\n$$\n\\Delta m = \\Delta T \\cdot \\left(\\mathbf{x}_a - \\mathbf{x}_b\\right)^\\top \\mathbf{s}.\n$$\n对于给定的 $\\Delta T$，响应的预测稳定性被定义为决策的符号是否保持不变的布尔结果，即 $m_0$ 和 $m_0 + \\Delta m$ 是否具有相同的符号。等价地，当且仅当 $m_0 \\cdot \\left(m_0 + \\Delta m\\right)  0$ 时，宣告为稳定。\n\n从基本原理出发，通过最小化在参考温度下测量的校准延迟与线性模型之间的残差平方和，使用最小二乘准则来估计 $\\mathbf{w}$。使用得到的 $\\widehat{\\mathbf{w}}$、上述准则以及给定的灵敏度向量 $\\mathbf{s}$ 来计算每个测试用例的预测稳定性。所有计算都必须以与所提供数据一致的单位进行。延迟以皮秒为单位，温度以摄氏度为单位。最终输出为布尔值，因此不需要单位。\n\n实现一个程序，对下面的每个测试用例执行以下步骤：\n- 通过提供的校准特征矩阵和在 $\\Delta T = 0$ 时测量的延迟，使用最小二乘法估计 $\\widehat{\\mathbf{w}}$。\n- 计算 $m_0 = \\left(\\mathbf{x}_a - \\mathbf{x}_b\\right)^\\top \\widehat{\\mathbf{w}}$。\n- 计算 $\\Delta m = \\Delta T \\cdot \\left(\\mathbf{x}_a - \\mathbf{x}_b\\right)^\\top \\mathbf{s}$。\n- 返回定义为 $m_0 \\cdot \\left(m_0 + \\Delta m\\right)  0$ 的布尔稳定性结果。\n\n使用以下测试套件。每个测试用例提供：\n- 校准特征矩阵（行为特征向量 $\\mathbf{x}_k$），\n- 在参考温度下测量的校准延迟 $d_k$（单位：皮秒），\n- 灵敏度向量 $\\mathbf{s}$（单位：皮秒/摄氏度），\n- 激励对 $\\mathbf{x}_a$ 和 $\\mathbf{x}_b$，\n- 温度偏移 $\\Delta T$（单位：摄氏度）。\n\n测试用例 $1$（良态，中等 $\\Delta T$）：\n- 校准特征矩阵行：$\\left(1, -0.5, 0.8\\right)$, $\\left(1, 0.2, -1.0\\right)$, $\\left(1, 1.5, 1.2\\right)$, $\\left(1, -1.2, 0.3\\right)$, $\\left(1, 0.7, -0.6\\right)$。\n- 测量的校准延迟：$118.25$, $121.38$, $121.83$, $117.29$, $122.02$ 皮秒。\n- 灵敏度向量：$\\left(0.15, 0.05, -0.02\\right)$ 皮秒/摄氏度。\n- 激励对：$\\mathbf{x}_a = \\left(1, 0.3, 0.4\\right)$, $\\mathbf{x}_b = \\left(1, -0.1, 0.2\\right)$。\n- 温度偏移：$\\Delta T = 20$ 摄氏度。\n\n测试用例 $2$（边界穿越，选择的 $\\Delta T$ 使裕度恰好落在零点）：\n- 校准特征矩阵行：$\\left(1, -0.3, 0.1\\right)$, $\\left(1, 0.8, -0.9\\right)$, $\\left(1, -0.7, -0.4\\right)$, $\\left(1, 1.1, 0.5\\right)$, $\\left(1, 0.0, -1.2\\right)$。\n- 测量的校准延迟：$114.47$, $116.94$, $114.24$, $116.26$, $115.94$ 皮秒。\n- 灵敏度向量：$\\left(0.12, 0.06, -0.03\\right)$ 皮秒/摄氏度。\n- 激励对：$\\mathbf{x}_a = \\left(1, 0.2, -0.1\\right)$, $\\mathbf{x}_b = \\left(1, 0.0, 0.0\\right)$。\n- 温度偏移：$\\Delta T = -25.333333333333332$ 摄氏度。\n\n测试用例 $3$（欠定校准，伪逆行为，较大的 $\\Delta T$）：\n- 校准特征矩阵行：$\\left(1, 0.3, -0.2, 0.5\\right)$, $\\left(1, -0.6, 0.4, -0.1\\right)$, $\\left(1, 0.9, 0.8, 0.3\\right)$。\n- 测量的校准延迟：$129.5$, $130.83$, $129.42$ 皮秒。\n- 灵敏度向量：$\\left(0.10, -0.02, 0.04, 0.01\\right)$ 皮秒/摄氏度。\n- 激励对：$\\mathbf{x}_a = \\left(1, -0.2, 0.6, 0.1\\right)$, $\\mathbf{x}_b = \\left(1, 0.1, 0.5, -0.2\\right)$。\n- 温度偏移：$\\Delta T = 30$ 摄氏度。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$），其中每个条目是相应测试用例的布尔稳定性。不应打印任何附加文本。",
            "solution": "该问题已经过验证，并被确定为是合理的。它在科学上基于集成电路建模的原理，在数学上是适定的，并为其解决提供了完整且一致的数据和指令集。\n\n问题的核心是预测基于延迟的物理不可克隆函数 (PUF) 响应在温度变化下的稳定性。这需要一个两阶段过程：首先是校准阶段，以建立电路行为的模型；其次是预测阶段，将该模型应用于新场景。\n\n该问题使用一阶泰勒近似定义了在距离参考点的温度偏移为 $\\Delta T$ 时，具有特征向量 $\\mathbf{x} \\in \\mathbb{R}^n$ 的电路路径的延迟 $d$：\n$$\nd(\\mathbf{x}, \\Delta T) \\approx \\mathbf{x}^\\top \\mathbf{w} + \\Delta T \\cdot \\mathbf{x}^\\top \\mathbf{s}\n$$\n此处，$\\mathbf{w} \\in \\mathbb{R}^n$ 是一个代表标称延迟的未知系数向量，$\\mathbf{s} \\in \\mathbb{R}^n$ 是一个已知的温度灵敏度向量。\n\n**第一阶段：通过最小二乘估计进行校准**\n\n第一步是估计未知系数向量 $\\mathbf{w}$。我们给定一组 $k$ 个校准测量值，包括特征向量 $\\mathbf{x}_1, \\mathbf{x}_2, \\ldots, \\mathbf{x}_k$ 及其在参考温度（$\\Delta T = 0$）下对应的测量延迟 $d_1, d_2, \\ldots, d_k$。在此参考温度下，模型简化为 $d_i \\approx \\mathbf{x}_i^\\top \\mathbf{w}$。\n\n这可以表示为矩阵形式的线性方程组：\n$$\n\\mathbf{d}_{cal} \\approx X_{cal} \\mathbf{w}\n$$\n其中 $\\mathbf{d}_{cal} \\in \\mathbb{R}^k$ 是测量延迟的向量，而 $X_{cal} \\in \\mathbb{R}^{k \\times n}$ 是校准特征矩阵，其行是特征向量 $\\mathbf{x}_i^\\top$。\n\n问题指定应使用最小二乘准则估计 $\\mathbf{w}$，即寻找一个向量 $\\widehat{\\mathbf{w}}$ 以最小化残差平方和 $\\| X_{cal} \\widehat{\\mathbf{w}} - \\mathbf{d}_{cal} \\|_2^2$。此优化问题的解（表示为 $\\widehat{\\mathbf{w}}$）通过求解正规方程得到。为了计算方便，我们将使用一个标准的数值线性代数例程，该例程能正确处理超定 ($k > n$) 和欠定 ($k  n$) 系统。在欠定的情况下，该例程通过 Moore-Penrose 伪逆计算最小范数解。\n\n**第二阶段：稳定性预测**\n\nPUF 比特是通过比较两条路径 A 和 B 的延迟生成的，它们的特征向量分别为 $\\mathbf{x}_a$ 和 $\\mathbf{x}_b$。在 $\\Delta T = 0$ 时的标称决策裕度是它们延迟的差值：\n$$\nm_0 = d(\\mathbf{x}_a, 0) - d(\\mathbf{x}_b, 0) = (\\mathbf{x}_a - \\mathbf{x}_b)^\\top \\mathbf{w}\n$$\n使用我们的估计值 $\\widehat{\\mathbf{w}}$，我们计算估计的标称裕度：\n$$\nm_0 \\approx (\\mathbf{x}_a - \\mathbf{x}_b)^\\top \\widehat{\\mathbf{w}}\n$$\n\n此裕度的温度引起的偏移 $\\Delta m$ 由一阶近似给出：\n$$\n\\Delta m = \\Delta T \\cdot (\\mathbf{x}_a - \\mathbf{x}_b)^\\top \\mathbf{s}\n$$\n新温度下的预测裕度是 $m_0 + \\Delta m$。稳定性定义为裕度符号不改变的条件，其形式化表述为：\n$$\nm_0 \\cdot (m_0 + \\Delta m) > 0\n$$\n必须对每个测试用例评估此条件。\n\n**测试用例执行：**\n\n**测试用例 1：**\n- 校准矩阵 $X_{cal,1} \\in \\mathbb{R}^{5 \\times 3}$，延迟向量 $\\mathbf{d}_{cal,1} \\in \\mathbb{R}^{5}$。\n- 这是一个超定系统（5个方程，3个未知数）。\n- 通过最小二乘法求解 $X_{cal,1} \\mathbf{w} \\approx \\mathbf{d}_{cal,1}$ 得到估计值 $\\widehat{\\mathbf{w}}_1 \\approx \\begin{pmatrix} 120.00 \\\\ 2.00 \\\\ -1.50 \\end{pmatrix}$。\n- 激励向量为 $\\mathbf{x}_a = (1, 0.3, 0.4)^\\top$ 和 $\\mathbf{x}_b = (1, -0.1, 0.2)^\\top$。\n- 差分向量是 $\\Delta \\mathbf{x}_1 = \\mathbf{x}_a - \\mathbf{x}_b = (0, 0.4, 0.2)^\\top$。\n- 灵敏度向量 $\\mathbf{s}_1 = (0.15, 0.05, -0.02)^\\top$ 和 $\\Delta T_1 = 20$。\n- 标称裕度是 $m_{0,1} = \\Delta \\mathbf{x}_1^\\top \\widehat{\\mathbf{w}}_1 \\approx 0.4 \\cdot (2.00) + 0.2 \\cdot (-1.50) = 0.50$。使用完整精度， $m_{0,1} \\approx 0.49996$。\n- 裕度偏移是 $\\Delta m_1 = \\Delta T_1 \\cdot \\Delta \\mathbf{x}_1^\\top \\mathbf{s}_1 = 20 \\cdot (0.4 \\cdot 0.05 + 0.2 \\cdot (-0.02)) = 20 \\cdot (0.02 - 0.004) = 0.32$。\n- 新的裕度是 $m_{0,1} + \\Delta m_1 \\approx 0.49996 + 0.32 = 0.81996$。\n- $m_{0,1}$ 和 $m_{0,1} + \\Delta m_1$ 两者均为正。稳定性条件 $m_{0,1} \\cdot (m_{0,1} + \\Delta m_1) > 0$ 被满足。\n- 结果：True。\n\n**测试用例 2：**\n- 校准矩阵 $X_{cal,2} \\in \\mathbb{R}^{5 \\times 3}$，延迟向量 $\\mathbf{d}_{cal,2} \\in \\mathbb{R}^{5}$。\n- 这是一个超定系统。\n- 求解 $X_{cal,2} \\mathbf{w} \\approx \\mathbf{d}_{cal,2}$ 得到 $\\widehat{\\mathbf{w}}_2 \\approx \\begin{pmatrix} 115.00 \\\\ 1.80 \\\\ -0.75 \\end{pmatrix}$。\n- 激励向量为 $\\mathbf{x}_a = (1, 0.2, -0.1)^\\top$ 和 $\\mathbf{x}_b = (1, 0.0, 0.0)^\\top$。\n- 差分向量是 $\\Delta \\mathbf{x}_2 = \\mathbf{x}_a - \\mathbf{x}_b = (0, 0.2, -0.1)^\\top$。\n- 灵敏度向量 $\\mathbf{s}_2 = (0.12, 0.06, -0.03)^\\top$ 和 $\\Delta T_2 \\approx -25.333$。\n- 标称裕度是 $m_{0,2} = \\Delta \\mathbf{x}_2^\\top \\widehat{\\mathbf{w}}_2 \\approx 0.2 \\cdot (1.80) - 0.1 \\cdot (-0.75) = 0.435$。使用完整精度， $m_{0,2} \\approx 0.43498$。\n- 裕度偏移是 $\\Delta m_2 = \\Delta T_2 \\cdot \\Delta \\mathbf{x}_2^\\top \\mathbf{s}_2 = -25.333... \\cdot (0.2 \\cdot 0.06 - 0.1 \\cdot (-0.03)) = -25.333... \\cdot (0.015) \\approx -0.38$。\n- 新的裕度是 $m_{0,2} + \\Delta m_2 \\approx 0.43498 - 0.38 = 0.05498$。\n- 用例描述表明最终裕度“恰好落在零点”。我们的计算遵循指定步骤，得出一个小的正值。这种差异可能是由于描述性文本指的是一个理想化的情景，而提供的数值数据导致了这个非零结果。遵守指定的最小二乘法是至关重要的。\n- $m_{0,2}$ 和 $m_{0,2} + \\Delta m_2$ 两者均为正。稳定性条件被满足。\n- 结果：True。\n\n**测试用例 3：**\n- 校准矩阵 $X_{cal,3} \\in \\mathbb{R}^{3 \\times 4}$，延迟向量 $\\mathbf{d}_{cal,3} \\in \\mathbb{R}^{3}$。\n- 这是一个欠定系统（3个方程，4个未知数）。最小二乘求解器将找到 $\\widehat{\\mathbf{w}}_3$ 的最小范数解。\n- 求解 $X_{cal,3} \\mathbf{w} \\approx \\mathbf{d}_{cal,3}$ 得到 $\\widehat{\\mathbf{w}}_3 \\approx \\begin{pmatrix} 129.99 \\\\ -0.55 \\\\ -0.34 \\\\ 0.21 \\end{pmatrix}$。\n- 激励向量为 $\\mathbf{x}_a = (1, -0.2, 0.6, 0.1)^\\top$ 和 $\\mathbf{x}_b = (1, 0.1, 0.5, -0.2)^\\top$。\n- 差分向量是 $\\Delta \\mathbf{x}_3 = \\mathbf{x}_a - \\mathbf{x}_b = (0, -0.3, 0.1, 0.3)^\\top$。\n- 灵敏度向量 $\\mathbf{s}_3 = (0.10, -0.02, 0.04, 0.01)^\\top$ 和 $\\Delta T_3 = 30$。\n- 标称裕度是 $m_{0,3} = \\Delta \\mathbf{x}_3^\\top \\widehat{\\mathbf{w}}_3 \\approx -0.3 \\cdot (-0.55) + 0.1 \\cdot (-0.34) + 0.3 \\cdot (0.21) \\approx 0.194$。使用完整精度， $m_{0,3} \\approx 0.19517$。\n- 裕度偏移是 $\\Delta m_3 = \\Delta T_3 \\cdot \\Delta \\mathbf{x}_3^\\top \\mathbf{s}_3 = 30 \\cdot (-0.3 \\cdot (-0.02) + 0.1 \\cdot 0.04 + 0.3 \\cdot 0.01) = 30 \\cdot (0.006 + 0.004 + 0.003) = 30 \\cdot 0.013 = 0.39$。\n- 新的裕度是 $m_{0,3} + \\Delta m_3 \\approx 0.19517 + 0.39 = 0.58517$。\n- $m_{0,3}$ 和 $m_{0,3} + \\Delta m_3$ 两者均为正。稳定性条件被满足。\n- 结果：True。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the PUF stability problem for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"X_cal\": np.array([\n                [1, -0.5, 0.8],\n                [1, 0.2, -1.0],\n                [1, 1.5, 1.2],\n                [1, -1.2, 0.3],\n                [1, 0.7, -0.6]\n            ]),\n            \"d_cal\": np.array([118.25, 121.38, 121.83, 117.29, 122.02]),\n            \"s\": np.array([0.15, 0.05, -0.02]),\n            \"xa\": np.array([1, 0.3, 0.4]),\n            \"xb\": np.array([1, -0.1, 0.2]),\n            \"Delta_T\": 20.0\n        },\n        {\n            \"X_cal\": np.array([\n                [1, -0.3, 0.1],\n                [1, 0.8, -0.9],\n                [1, -0.7, -0.4],\n                [1, 1.1, 0.5],\n                [1, 0.0, -1.2]\n            ]),\n            \"d_cal\": np.array([114.47, 116.94, 114.24, 116.26, 115.94]),\n            \"s\": np.array([0.12, 0.06, -0.03]),\n            \"xa\": np.array([1, 0.2, -0.1]),\n            \"xb\": np.array([1, 0.0, 0.0]),\n            \"Delta_T\": -25.333333333333332\n        },\n        {\n            \"X_cal\": np.array([\n                [1, 0.3, -0.2, 0.5],\n                [1, -0.6, 0.4, -0.1],\n                [1, 0.9, 0.8, 0.3]\n            ]),\n            \"d_cal\": np.array([129.5, 130.83, 129.42]),\n            \"s\": np.array([0.10, -0.02, 0.04, 0.01]),\n            \"xa\": np.array([1, -0.2, 0.6, 0.1]),\n            \"xb\": np.array([1, 0.1, 0.5, -0.2]),\n            \"Delta_T\": 30.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Estimate w_hat via least-squares from calibration data.\n        # numpy.linalg.lstsq correctly handles over- and under-determined systems.\n        # rcond=None ensures usage of machine epsilon for rank detection,\n        # suppressing a future warning and maintaining precision.\n        w_hat = np.linalg.lstsq(case[\"X_cal\"], case[\"d_cal\"], rcond=None)[0]\n\n        # Define variables for this case for clarity\n        delta_x = case[\"xa\"] - case[\"xb\"]\n        s = case[\"s\"]\n        Delta_T = case[\"Delta_T\"]\n        \n        # Step 2: Compute the nominal decision margin m0.\n        m0 = delta_x.T @ w_hat\n\n        # Step 3: Compute the temperature-induced margin shift Delta_m.\n        delta_m = Delta_T * (delta_x.T @ s)\n\n        # Step 4: Evaluate the stability criterion.\n        # Stability holds if the sign of the margin is preserved.\n        is_stable = m0 * (m0 + delta_m)  0\n        results.append(is_stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}