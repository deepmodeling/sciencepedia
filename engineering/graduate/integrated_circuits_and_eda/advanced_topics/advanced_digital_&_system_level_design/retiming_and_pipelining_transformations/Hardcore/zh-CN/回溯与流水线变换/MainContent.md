## 引言
在追求更高性能的数字[集成电路设计](@entry_id:1126551)中，[时钟频率](@entry_id:747385)是衡量系统速度的核心指标。然而，[时钟频率](@entry_id:747385)的上限受限于电路中最长的[组合逻辑](@entry_id:265083)路径，即“关键路径”。如何有效地缩短这条[关键路径](@entry_id:265231)的延迟，已成为逻辑综合与时序优化的中心任务。本文聚焦于解决这一问题的两种强大技术：[重定时](@entry_id:1130969)（Retiming）与流水线（Pipelining）变换。这两种技术通过对电路中寄存器的策略性重排或增添，从根本上改变了逻辑延迟的分布，从而为突破性能瓶颈提供了系统性的方法论。

本文旨在为读者构建一个关于[重定时与流水线](@entry_id:1130970)变换的完整知识体系。我们将从第一章“原理与机制”开始，深入剖析这两种技术的基本概念、性能影响、形式化数学模型以及核心[优化算法](@entry_id:147840)。随后，在第二章“应用与跨学科连接”中，我们将视野扩展到真实世界，探讨这些技术在高性能处理器、物理设计、编译器和[科学计算](@entry_id:143987)等不同领域中的具体应用与实践挑战。最后，通过第三章“动手实践”提供的精选练习，读者将有机会将理论知识应用于解决具体的工程问题。通过这一学习路径，读者不仅将理解[重定时与流水线](@entry_id:1130970)的“是什么”和“为什么”，更将掌握“如何用”的实践能力，为未来在[高性能计算](@entry_id:169980)领域的深入研究与开发打下坚实基础。

## 原理与机制

在前一章节对电路时序优化的背景和意义进行概述之后，本章将深入探讨两种核心的电路变换技术——流水线（Pipelining）和[重定时](@entry_id:1130969)（Retiming）——的基本原理与底层机制。我们将从它们的功能、性能影响，逐步过渡到其严谨的数学模型和算法实现，最终探讨在现实世界设计中必须考虑的理论与实践边界。本章旨在为读者构建一个系统而深入的知识框架，使其不仅理解“是什么”，更理解“为什么”以及“如何做”。

### 流水线与重定时的基本概念

在同步[数字电路设计](@entry_id:167445)中，系统的最高运行时钟频率由其**[关键路径](@entry_id:265231)（critical path）**的延迟决定。关键路径是指信号在单个时钟周期内必须传播的最长[组合逻辑](@entry_id:265083)路径。为了提升电路性能，即提高时钟频率，核心任务便是缩短这条关键路径的延迟。流水线和[重定时](@entry_id:1130969)是实现这一目标的两种主要变换手段，但它们的策略和代价截然不同。

#### 流水线：通过增加寄存器来分割逻辑

**流水线**是一种结构性变换，它通过在一条较长的[组合逻辑](@entry_id:265083)路径中**插入额外的寄存器**，将其分割成多个较短的、延迟更小的逻辑段。每一段被称为一个**流水线阶段（pipeline stage）**。

其基本原理可以直观地理解：假设一条组合逻辑路径的总延迟为 $D$，这条路径位于两个寄存器之间。在不考虑寄存器本身开销的情况下，电路的最小**时钟周期 (clock period)** $T$ 必须大于等于 $D$。通过在这条路径上均匀地插入 $k$ 个寄存器，我们将原有的单个逻辑块分割成了 $k+1$ 个阶段。理想情况下，每个阶段的[组合逻辑延迟](@entry_id:177382)变为了 $d'_{\mathrm{comb}} = \frac{D}{k+1}$。因此，新的[时钟周期](@entry_id:165839) $T'$ 仅需满足 $T' \ge \frac{D}{k+1}$。显然，$T'$ 远小于原始的 $T$，这意味着电路可以运行在更高的时钟频率下 。

流水线带来的性能影响具有双面性：

1.  **吞吐率 (Throughput) 提升**：**吞吐率**衡量的是系统在单位时间内能够处理的操作数量。由于时钟周期 $T$ 大幅缩短，系统在每个时钟周期都能启动一个新的操作（在[理想流](@entry_id:261917)水线中），因此[稳态](@entry_id:139253)吞吐率与[时钟频率](@entry_id:747385)成正比。将时钟周期从 $T \approx D$ 降低到 $T' \approx \frac{D}{k+1}$，吞吐率理想情况下能提升约 $k+1$ 倍。

2.  **延迟 (Latency) 增加**：**延迟**指的是单个数据从输入到输出所需经历的总时间。在原始电路中，数据经过一个时钟周期即可从输入寄存器传播到输出寄存器，因此延迟为 1 个时钟周期。在插入 $k$ 个寄存器后，数据需要经过全部 $k+1$ 个流水线阶段，每个阶段花费一个[时钟周期](@entry_id:165839)。因此，以时钟周期数计量的延迟变为了 $k+1$ 个周期，净增了 $k$ 个周期 。虽然每个周期的[绝对时间](@entry_id:265046)变短了，但总的[绝对时间](@entry_id:265046)延迟（周期[数乘](@entry_id:155971)以周期时长）通常也会增加。

#### 重定时：通过移动寄存器来均衡逻辑

与流水线不同，**重定时**是一种不改变电路中寄存器总数（在任何一个环路中）的变换。它的核心思想是**重新安置（relocate）**电路中已有的寄存器，将它们从[组合逻辑](@entry_id:265083)的一端“移动”到另一端，以均衡各个流水线阶段之间的逻辑延迟。

重定时的目标是消除时序瓶颈。考虑一个多级流水线，如果其中一个阶段的[组合逻辑延迟](@entry_id:177382)远大于其他阶段，那么该阶段就成为整个电路的关键路径，决定了全局时钟周期。例如，一个三级流水线，其各阶段的[组合逻辑延迟](@entry_id:177382)分别为 $d_1 = 9\,\text{ns}$，$d_2 = 3\,\text{ns}$ 和 $d_3 = 6\,\text{ns}$。假设寄存器开销为 $1\,\text{ns}$，那么初始[时钟周期](@entry_id:165839)由最慢的阶段决定，即 $T = \max(9, 3, 6) + 1 = 10\,\text{ns}$ 。通过[重定时](@entry_id:1130969)，我们可以从第一级逻辑中“借调”一部分逻辑到第二级，从第三级“借调”到第二级，最终可能实现所有阶段的延迟都为 $6\,\text{ns}$。此时，新的时钟周期将缩短为 $T' = 6 + 1 = 7\,\text{ns}$。

[重定时](@entry_id:1130969)对性能的影响如下：

1.  **吞吐率提升**：通过均衡各个阶段的延迟，[重定时](@entry_id:1130969)有效降低了最长阶段的延迟，从而缩短了最小可行时钟周期，提高了电路的吞吐率。

2.  **延迟不变**：[重定时](@entry_id:1130969)的关键特性是它不改变从任何主输入到主输出路径上的寄存器数量。因此，以时钟周期数计量的延迟保持不变。在上述例子中，变换前后的延迟都是 3 个[时钟周期](@entry_id:165839) 。

总结而言，流水线通过增加硬件资源（寄存器）来换取吞吐率的大幅提升，但代价是延迟的增加。而[重定时](@entry_id:1130969)则是在不增加寄存器的情况下，通过优化其布局来提升吞吐率，且不增加延迟。在实际设计中，两者常常结合使用：先通过流水线划分出大致的阶段，再通过[重定时](@entry_id:1130969)对这些阶段进行微调和均衡。

### 性能指标的精确定义

为了进行严谨的分析和优化，我们需要对前文提到的性能指标给出精确的数学定义。

**[时钟周期](@entry_id:165839) ($T$)**：在[同步电路](@entry_id:172403)中，[时钟周期](@entry_id:165839)必须足够长，以保证信号能从一个寄存器（发射寄存器）的输出，经过[组合逻辑](@entry_id:265083)，在下一个[时钟沿](@entry_id:171051)到达之前被下一个寄存器（捕获寄存器）稳定地锁存。这个时序约束可以表示为：
$T \ge d_{\mathrm{comb}} + t_{\mathrm{cq}} + t_{\mathrm{su}} + t_{\mathrm{skew}}$
其中：
- $d_{\mathrm{comb}}$ 是两个寄存器之间的最长[组合逻辑](@entry_id:265083)路径延迟。
- $t_{\mathrm{cq}}$ 是发射寄存器的**时钟-Q延时 (clock-to-Q delay)**，即时钟沿到达后，其输出端（Q）出现有效信号所需的时间。
- $t_{\mathrm{su}}$ 是捕获寄存器的**建立时间 (setup time)**，即数据在[时钟沿](@entry_id:171051)到达前必须保持稳定的最短时间。
- $t_{\mathrm{skew}}$ 是时钟网络的不确定性，包括**[时钟偏斜](@entry_id:177738) (clock skew)**（不同寄存器接收到时钟沿的物理时间差异）和[时钟抖动](@entry_id:1133193)（jitter）。

电路的最小可行时钟周期 $T_{\min}$ 由所有路径中满足上述不等式的最大值决定。例如，对于一个五级流水线，其各级组合延迟分别为 $\{0.75, 0.72, 0.69, 0.71, 0.74\}\,\text{ns}$，且寄存器开销 $t_{cq} = 0.03\,\text{ns}$，$t_{su} = 0.03\,\text{ns}$，$t_{skew} = 0.02\,\text{ns}$，则关键路径的组合延迟为 $\max(d_i) = 0.75\,\text{ns}$。因此，最小周期为 $T_{\min} = 0.75 + 0.03 + 0.03 + 0.02 = 0.83\,\text{ns}$ 。

**吞吐率 ($\Theta$)**：吞吐率是在[稳态](@entry_id:139253)下单位时间内完成的操作数。它与**启动间隔 (Initiation Interval, II)** 密切相关，II 指的是连续两个操作可以被送入流水线的最小间隔周期数。对于一个可以每个时钟周期都接收新数据的“完全流水化”设计，其 $II=1$。在这种情况下，吞吐率就是[时钟频率](@entry_id:747385)的倒数，即 $\Theta = \frac{1}{T}$。更一般地，吞吐率为 $\Theta = \frac{1}{II \cdot T}$。在上述例子中，若 $II=1$，则吞吐率约为 $\frac{1}{0.83\,\text{ns}} \approx 1.205\,\text{GHz}$ 。

**延迟 ($L$)**：延迟是单个数据项从输入端传播到输出端所花费的总时间。它通常用两个维度来衡量：
- **周期延迟 ($L_{\mathrm{cycles}}$)**：指数据需要经过的流水线级数。对于一个深度为 $L$ 的流水线，周期延迟就是 $L$ 个时钟周期。
- **时间延迟 ($L_{\mathrm{time}}$)**：指[绝对时间](@entry_id:265046)，等于周期延迟乘以[时钟周期](@entry_id:165839)，即 $L_{\mathrm{time}} = L_{\mathrm{cycles}} \cdot T$。在上述例子中，流水线深度为 5，因此时间延迟为 $5 \times 0.83\,\text{ns} = 4.15\,\text{ns}$ 。

### [重定时](@entry_id:1130969)的形式化模型

为了系统地研究和应用重定时，我们需要一个精确的数学模型。由 Leiserson 和 Saxe 提出的**形式化模型 (formal model)** 将[同步电路](@entry_id:172403)抽象为一个加权有向图 $G=(V, E)$  。

-   **顶点 ($V$)**：图中的每个顶点 $v \in V$ 代表一个[组合逻辑](@entry_id:265083)块。每个顶点都有一个非负的**延迟 ($d(v)$)**，表示该逻辑块的[传播延迟](@entry_id:170242)。

-   **边 ($E$)**：图中的每条有向边 $(u, v) \in E$ 代表从逻辑块 $u$ 的输出到逻辑块 $v$ 的输入之间的连接。每条边都有一个非负整数**权重 ($w(u, v)$)**，表示这条连接上的寄存器数量。

**重定时函数 ($r(v)$)** 被定义为一个从顶点集合到整数集的映射，$r: V \to \mathbb{Z}$。$r(v)$ 的值可以被直观地理解为从顶点 $v$ 的每个输出边“推入”并从其每个输入边“拉出”的寄存器数量。$r(v)$ 为正值表示寄存器向前移动（“延迟”了该节点的计算结果），为负值表示寄存器向后移动（“提前”了该节点的计算）。

经过[重定时](@entry_id:1130969)后，一条边 $(u, v)$ 上的新寄存器数量 $w_r(u, v)$ 由以下公式给出：
$w_r(u, v) = w(u, v) + r(v) - r(u)$
这个公式的含义是：边 $(u,v)$ 的新权重等于其旧权重，加上从终点 $v$ “推入”的寄存器数，减去从起点 $u$ “推入”的寄存器数（等价于从 $u$ 的输出边移走的寄存器数）。

一个[重定时](@entry_id:1130969)变换是**合法的 (legal)**，当且仅当所有边上的新权重都是非负的，即：
$w_r(u, v) \ge 0 \quad \forall (u,v) \in E$
这个**合法性约束 (legality constraint)** 保证了电路的物理可实现性，因为寄存器的数量不能为负。

例如，考虑一个由四个顶点 $\{v_0, v_1, v_2, v_3\}$ 组成的环路，其初始权重为 $w(v_0,v_1)=0, w(v_1,v_2)=0, w(v_2,v_3)=0, w(v_3,v_0)=2$。如果我们应用一个[重定时](@entry_id:1130969)函数 $r(v_0)=-1, r(v_1)=0, r(v_2)=0, r(v_3)=1$，那么边 $(v_0,v_1)$ 的新权重为 $w_r(v_0,v_1) = w(v_0,v_1) + r(v_1) - r(v_0) = 0 + 0 - (-1) = 1$。通过对所有边进行此计算，可以验证该重定时是合法的 。

### [重定时](@entry_id:1130969)的算法基础

拥有了形式化模型后，我们便可以发展算法来解决两个核心问题：1) 对于一个给定的目标[时钟周期](@entry_id:165839) $T$，是否存在一个合法的重定时方案能够满足该周期要求？（**T-可行性 (T-feasibility)** 问题）2) 如果存在，如何找到它？以及，如何找到可能的最小周期 $T^\star$？

#### T-可行性与约束系统

一个重定时方案能满足目标时钟周期 $T$，意味着在重定时后的电路中，任何没有寄存器的路径（即一条所有边的 $w_r$ 均为 0 的路径）的总[组合逻辑延迟](@entry_id:177382)不能超过 $T$。这个**[时序约束](@entry_id:168640) (timing constraint)** 可以转化为一个关于[重定时](@entry_id:1130969)变量 $r(v)$ 的[线性不等式](@entry_id:174297)系统 。

首先，对于一条从顶点 $s$ 到 $t$ 的路径 $P$，其[重定时](@entry_id:1130969)后的总寄存器数 $W_r(P)$ 与原始寄存器数 $W(P)$ 之间的关系可以表示为一个伸缩求和：
$W_r(P) = \sum_{(u,v) \in P} w_r(u,v) = \sum_{(u,v) \in P} (w(u,v) + r(v) - r(u)) = W(P) + r(t) - r(s)$

时序约束要求：对于任意从 $s$ 到 $t$ 的路径 $P$，如果其总组合延迟 $D(P) > T$，那么重定时后该路径上必须至少有一个寄存器，即 $W_r(P) \ge 1$。将上式代入可得：
$W(P) + r(t) - r(s) \ge 1 \implies r(s) - r(t) \le W(P) - 1$

这个不等式必须对所有延迟超过 $T$ 的路径都成立。为了确保这一点，我们必须满足最严格的那个约束，即由具有最小原始寄存器数 $W(P)$ 的那条“长路径”所施加的约束。因此，对每一对顶点 $(s,t)$，我们只需施加一个约束：
$r(s) - r(t) \le W_T(s,t) - 1$
其中 $W_T(s,t) = \min \{ W(P) \mid \text{P is a path from } s \text{ to } t, D(P) > T \}$ 。

至此，我们将T-可行性问题转化为了求解一个包含两类**[差分约束](@entry_id:634030) (difference constraints)** 的不等式系统：
1.  **合法性约束**：$r(u) - r(v) \le w(u,v)$，对所有边 $(u,v) \in E$ 成立。
2.  **[时序约束](@entry_id:168640)**：$r(s) - r(t) \le W_T(s,t) - 1$，对所有存在延迟超过 $T$ 的路径的顶点对 $(s,t)$ 成立。

#### [约束图](@entry_id:267131)与 [Bellman-Ford](@entry_id:634399) 算法

这种形式的[差分约束](@entry_id:634030)系统可以通过图论方法高效求解。我们可以构建一个**[约束图](@entry_id:267131) (constraint graph)**，其顶点就是原电路的顶点 $V$。对于每一个形如 $r(i) - r(j) \le k$ 的不等式，我们在[约束图](@entry_id:267131)中添加一条从顶点 $j$到顶点 $i$ 的有向边，其权重为 $k$。

这个不等式系统有解的充分必要条件是，构建出的[约束图](@entry_id:267131)中**不包含任何[负权环](@entry_id:633892) (negative-weight cycle)**。**[Bellman-Ford算法](@entry_id:265120) ([Bellman-Ford](@entry_id:634399) algorithm)** 是一种经典的[单源最短路径](@entry_id:636497)算法，它能够处理带负权重的边，并且能够检测图中是否存在[负权环](@entry_id:633892)。因此，我们可以运行 [Bellman-Ford](@entry_id:634399) 算法来判断 T-可行性。如果算法检测到[负权环](@entry_id:633892)，则不存在满足条件的重定时方案，$T$ 是不可行的。反之，如果不存在[负权环](@entry_id:633892)，则 $T$ 是可行的，并且算法还能给出一组满足所有约束的 $r(v)$ 值 。

整个 T-可行性检查的算法流程如下：
1.  对于给定的 $T$，计算所有顶点对 $(s,t)$ 的 $W_T(s,t)$ 值。
2.  构建包含合法性约束和时序约束的[约束图](@entry_id:267131)。
3.  在[约束图](@entry_id:267131)上运行 [Bellman-Ford](@entry_id:634399) 算法。
4.  根据是否检测到[负权环](@entry_id:633892)来判断 $T$ 的可行性。

该算法的复杂度主要由第一步和第三步决定。使用类似所有对最短路径的动态规划方法计算 $W_T$ 矩阵，以及在包含 $O(|V|^2)$ 条边的[约束图](@entry_id:267131)上运行 [Bellman-Ford](@entry_id:634399)，其总复杂度通常为 $O(|V|^3)$ 。

#### 寻找最优时钟周期

T-可行性检查是一个[判定问题](@entry_id:636780)（回答“是”或“否”）。为了找到最小的可行时钟周期 $T^\star$，我们可以利用一个关键性质：**单调性**。如果一个时钟周期 $T$ 是可行的，那么任何比它大的周期 $T' > T$ 也必然是可行的，因为放宽周期只会减少或保持[时序约束](@entry_id:168640)的数量。

这种[单调性](@entry_id:143760)使得我们可以通过**二分搜索 (binary search)** 来高效地寻找最优周期 $T^\star$ 。算法步骤如下：
1.  确定搜索范围的下界 $L$ 和上界 $U$。一个有效的下界是所有顶点中最大的延迟 $L = \max_{v \in V} d(v)$，一个宽松的上界是所有顶点延迟之和 $U = \sum_{v \in V} d(v)$。
2.  在 $L$ 和 $U$ 之间进行二分搜索。在每一步，取中间值 $T_{mid} = (L+U)/2$，并调用前述的 T-可行性检查算法。
3.  如果 $T_{mid}$ 可行，说明最优解可能更小，于是更新上界 $U = T_{mid}$。
4.  如果 $T_{mid}$ 不可行，说明周期必须更大，于是更新下界 $L = T_{mid}$。
5.  重复此过程，直到 $U-L$ 小于一个预设的精度 $\varepsilon$。最终的 $U$ 值就是对 $T^\star$ 的一个高精度近似。

在处理[浮点数](@entry_id:173316)延迟时，需要注意数值精度问题，通常在比较时加入微小的容差，以避免因舍入误差导致的不稳定行为 。

### 重定时的理论与实践边界

虽然[重定时](@entry_id:1130969)是一个强大的自动化工具，但其应用并非毫无限制。理解其理论基础和实践边界，对于正确地使用它至关重要。

#### 功能保持的理论基础

重定时变换之所以是正确的，是因为它保持了电路的**时序等价性 (sequential equivalence)**。这意味着，对于相同的输入序列，重定时前后的电路将产生完全相同的输出序列（可能存在固定的初始延迟）。这一性质可以通过**状态映射 (state mapping)** 来证明 。

令 $y_v(t)$ 为原始电路中顶点 $v$ 在时钟周期 $t$ 的输出值，而 $y'_v(t)$ 为[重定时](@entry_id:1130969)后电路中相应的值。可以证明，存在一个简单的关系：
$y'_v(t) = y_v(t - r(v))$
这表明，重定时后电路中任一节点的行为，都等同于原始电路中该节点行为的一个整数[时钟周期](@entry_id:165839)的延迟。这个延迟量恰好是该节点的[重定时](@entry_id:1130969)值 $r(v)$。这个关系式也隐含了原始状态（寄存器中的值）和[重定时](@entry_id:1130969)后状态之间的映射关系。

为了使电路的外部输入-输出行为在每个时钟周期都完全一致，即 $o'(t) = o(t)$，必须保证在主输入（PI）和主输出（PO）边界上没有发生时间上的偏移。这要求所有属于 PI 或 PO 集合的顶点 $v$ 的重定时值都为零，即 $r(v)=0$ 。如果允许对输出端口进行重定时（例如，$r(v_{out}) > 0$），则输出序列会相对于输入序列产生一个固定的延迟。

#### 与[复位逻辑](@entry_id:162948)的交互

在实际电路中，寄存器通常带有[复位逻辑](@entry_id:162948)，这给[重定时](@entry_id:1130969)带来了重要的限制。

-   **异步复位 (Asynchronous Reset)**：异步复位信号一旦有效，会立即、无视时钟地将寄存器输出强制为预设值。这条从复位引脚到寄存器输出的路径是一条纯粹的[组合逻辑](@entry_id:265083)路径。如果我们将逻辑从寄存器的一端移动到另一端，例如将寄存器向输入方向移动，那么新的寄存器将被复位，其复位值再通过被移动的逻辑块传播。这从根本上改变了复位行为：原本被直接复位的信号，现在变成了被复位的信号经过[组合逻辑](@entry_id:265083)计算后的结果；同时，复位传播的延迟也从寄存器内部的快速路径变成了包含外部[组合逻辑](@entry_id:265083)的更长路径。这种对复位功能和时序语义的破坏，使得[重定时](@entry_id:1130969)**不能合法地跨越带有异步复位的寄存器** 。

-   **[同步复位](@entry_id:177604) (Synchronous Reset)**：[同步复位](@entry_id:177604)只在时钟沿有效时才起作用，它将寄存器的下一状态设置为复位值。从功能上看，[同步复位](@entry_id:177604)信号可以被视为一个具有最高优先级的普通同步数据输入。因此，**[重定时](@entry_id:1130969)可以处理带有[同步复位](@entry_id:177604)的寄存器**，只要保证重定时后，移动的寄存器仍然连接到同一个[同步复位](@entry_id:177604)网络，并且其复位行为（即复位后等效的电路状态）得以保持 。

#### 多时钟系统与[时钟域交叉](@entry_id:173614)

[重定时](@entry_id:1130969)理论的经典模型假设整个电路工作在单一的同步时钟下。当电路包含多个相互**异步的时钟域**时，情况变得更为复杂。

连接不同时钟域的路径被称为**[时钟域交叉](@entry_id:173614) (Clock Domain Crossing, CDC)**。由于两个时钟的相位和频率关系不确定，从一个时钟域发射的数据可能在另一个时钟域的捕获寄存器的[建立时间](@entry_id:167213)和保持时间窗口内发生变化，从而导致**[亚稳态](@entry_id:167515) (metastability)**。为了安全地传输数据，必须在 CDC 路径上使用特殊的**[同步器](@entry_id:175850) (synchronizer)** 电路，例如一个由两级或更多级背靠背、由目标时钟驱动的寄存器链。

同步器是一个具有特定物理结构和时序特性的硬件单元，其目的是将亚稳态发生的概率降低到可接受的水平。它不仅仅是抽象的“寄存器数量”。因此，试图通过[重定时](@entry_id:1130969)来移动构成[同步器](@entry_id:175850)的寄存器，或者将寄存器移入或移出 CDC 路径，是**非法的**。这会破坏[同步器](@entry_id:175850)精心设计的结构，使其失去作用 。

在多时钟域系统中进行合法的重定时，必须遵守以下约束：
1.  **冻结 CDC 路径**：对于任何跨越时钟域的边 $(u,v)$（即 $d(u) \neq d(v)$），必须保证其上的寄存器数量不变。这等价于施加约束 $r(v) = r(u)$。
2.  **域内优化**：重定时只能在每个时钟域的内部独立进行。对于每个时钟域 $\delta$，可以根据其自身的[时钟周期](@entry_id:165839) $T_\delta$ 和内部路径进行优化。

通过将每个时钟域视为一个独立的优化孤岛，并将 CDC 路径作为不可更改的边界，我们可以在保证整个系统功能正确的前提下，安全地应用[重定时](@entry_id:1130969)技术。