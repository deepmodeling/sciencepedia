## 引言
随着集成电路工艺进入深亚微米时代，在单一芯片上集成数十亿晶体管已成为现实，但这也给传统的全[同步设计](@entry_id:163344)方法带来了前所未有的挑战。在整个芯片范围内分发一个高频率、低偏斜的全局时钟变得极其困难且功耗巨大。全球异步、局部同步（GALS）系统作为一种创新的混合设计范式应运而生，它旨在结合[同步设计](@entry_id:163344)的成熟与[异步设计](@entry_id:1121166)的可扩展性，从而系统性地解决这一根本性难题。GALS通过将系统分解为多个内部同步的“岛屿”，并在它们之间采用[异步通信](@entry_id:173592)，为构建未来大规模、高[能效](@entry_id:272127)的[片上系统](@entry_id:1131845)（SoC）提供了优雅的解决方案。

本文将带领读者系统性地掌握GALS设计的核心知识体系。在第一章**“原理与机制”**中，我们将深入探讨GALS的基本架构、[跨时钟域](@entry_id:173614)通信的核心挑战（如[亚稳态](@entry_id:167515)），以及实现可靠[异步通信](@entry_id:173592)的各类协议与技术。随后，在第二章**“应用与跨学科连接”**中，我们将视野扩展到实际应用，展示GALS如何在高级微体系结构、[片上网络](@entry_id:1128532)（NoC）以及电子设计自动化（EDA）流程中发挥关键作用，并揭示其与控制理论、系统生物学等领域的深刻联系。最后，在**“动手实践”**部分，读者将通过解决具体的工程问题，将理论知识转化为解决实际设计挑战的能力。通过这一系列的学习，您将不仅理解GALS是什么，更能领会其作为一种强大设计哲学的精髓。

## 原理与机制

本章旨在深入探讨全球异步、局部同步（GALS）系统的核心设计原理与关键实现机制。继前一章对GALS系统背景与动机的介绍之后，本章将从基本架构定义出发，系统性地剖析其面临的核心挑战——[跨时钟域](@entry_id:173614)（CDC）问题，并详细阐述为应对此挑战而发展的各类[异步通信](@entry_id:173592)协议、数据编码方案以及高级接口技术。最后，我们将视角提升至系统层面，讨论在复杂GALS[互连网络](@entry_id:750720)中必须考虑的[数据完整性](@entry_id:167528)、[死锁](@entry_id:748237)与[活锁](@entry_id:751367)等系统级问题。

### GALS的基本架构原理

全球异步、局部同步（GALS）架构是一种混合设计方法，旨在结合全[同步系统](@entry_id:172214)与全异步系统的优点。其核心思想是将一个复杂的片上系统（SoC）划分为多个独立的、内部采用[同步设计](@entry_id:163344)的模块，这些模块被称为**同步岛（Synchronous Islands）**。而在这些同步岛之间，则采用[异步通信](@entry_id:173592)机制进行数据交换。

#### [GALS架构](@entry_id:1125455)的定义与对比

精确地定义GALS系统，需要从时钟假设、通信语义和[时序收敛](@entry_id:167567)责任三个维度进行剖析 。

在一个GALS系统中：
1.  **时钟假设**：计算被划分到多个[局部时](@entry_id:194383)钟岛中，每个岛拥有自己的时钟周期 $T$、[建立时间](@entry_id:167213) $t_{\text{setup}}$ 和保持时间 $t_{\text{hold}}$ 约束。关键在于，各个岛的时钟之间**不存在固定的频率或相位关系**。它们可以源于不同的振荡器，或者为了[功耗管理](@entry_id:753652)而动态调整频率。
2.  **通信语义**：由于全局没有统一的时间基准，岛间通信必须采用**异步语义**。这意味着通信不依赖于某个公共时钟的边沿进行采样，而是通过事件驱动的[握手协议](@entry_id:174594)（如请求/应答）或能容忍可变延迟的结构（如双时钟先进先出队列，即Dual-Clock FIFO）来完成。这类通信机制天然支持可变延迟，并能提供反压（backpressure）能力。
3.  **[时序收敛](@entry_id:167567)责任**：[时序收敛](@entry_id:167567)（Timing Closure）的责任被清晰地划分。对于**每个同步岛内部**，设计者使用标准的[静态时序分析](@entry_id:177351)（Static Timing Analysis, STA）工具来确保所有由寄存器界定的路径都满足其[局部时](@entry_id:194383)钟的约束。对于**岛间接口**，责任转变为[跨时钟域](@entry_id:173614)（Clock Domain Crossing, CDC）验证。这包括使用[同步器](@entry_id:175850)来处理[异步信号](@entry_id:746555)采样，并通过计算**平均无故障时间（Mean Time Between Failures, MTBF）**来确保其可靠性。

与之相对：
-   **全同步架构**假设存在一个单一的全局时钟，其[时钟偏斜](@entry_id:177738)（skew） $\Delta t$ 在整个芯片范围内有界。通信是周期确定性的，所有数据在时钟边沿被采样。[时序收敛](@entry_id:167567)责任是全局性的，需要对芯片上所有寄存器到寄存器的路径进行端到端的STA。
-   **全异步架构**不使用任何周期性时钟。通信完全由因果关系驱动，通过请求/应答（REQ/ACK）握手和特定的数据编码来定义。其时序正确性不依赖于全局周期 $T$，而是基于无险象（hazard-free）逻辑和延迟不敏感（delay-insensitive）或相对时序假设。

[GALS架构](@entry_id:1125455)的动机在于，它既保留了[同步设计](@entry_id:163344)在[逻辑实现](@entry_id:173626)、工具支持和设计流程上的成熟与便捷，又通过全局异步化避免了在超大规模芯片上分发一个低偏斜、高频率全局时钟的巨大挑战。

### [跨时钟域](@entry_id:173614)（CDC）：核心挑战

GALS设计的精髓与难点均在于其异步接口。任何跨越独立时钟域边界的信号传输，都构成了一次[跨时钟域](@entry_id:173614)（CDC）事件，这也是系统中最脆弱、最容易出错的部分。

#### 时钟域关系分类

要正确处理CDC，首先必须精确地对不同时钟域之间的关系进行分类。假设两个局部同步岛 $A$ 和 $B$ 的时钟相位分别为 $\phi_A(t)$ 和 $\phi_B(t)$，瞬时[角频率](@entry_id:261565)为 $\omega(t) = 2\pi f(t)$。它们之间的相位差 $\Delta \phi(t) = \phi_B(t) - \phi_A(t)$ 的演化行为，决定了它们的关系类型以及适用的通信策略 。

-   **异步（Asynchronous）**：这是最普遍的情况。时钟 $f_A$ 和 $f_B$ 来自完全独立的源，它们之间没有固定的频率关系。因此，相位差 $\Delta \phi(t)$ 会无界地、以不可预测的速率漂移。对于这种情况，必须使用对任意频率差都鲁棒的通信策略，例如基于请求-应答的[握手协议](@entry_id:174594)，或使用带有[格雷码](@entry_id:166435)（Gray-coded）指针和[两级触发器同步器](@entry_id:166595)的双时钟FIFO。

-   **同频（Mesochronous）**：指两个时钟的**长期平均频率完全相等**（即标称频率差 $\Delta f = 0$），但它们的初始相位差 $\Delta \phi(0)$ 是未知的、任意的。在这种情况下，相位差 $\Delta \phi(t)$ 虽然会因[抖动](@entry_id:200248)（jitter）而波动，但不会系统性地累积，而是保持有界。由于没有频率漂移，通信问题简化为处理一个静态的[相位偏移](@entry_id:276073)和有界的[抖动](@entry_id:200248)。这可以通过锁相环（DLL）进行相位对齐（去偏斜），或使用一个较浅的弹性缓冲器来吸收相位不确定性。

-   **准同步（Plesiochronous）**：指两个时钟的标称频率几乎相同，但存在一个微小且有界的频率差 $| \Delta f |$（通常以ppm，即[百万分率](@entry_id:139026)计）。例如，两个来自不同[晶体振荡器](@entry_id:276739)的“相同”频率时钟。由于 $\Delta f \neq 0$，相位差 $\Delta \phi(t)$ 会以 $\Delta \omega \cdot t$ 的形式缓慢地、线性地累积，导致无界的[相位漂移](@entry_id:266077)（wander）。任何固定大小的缓冲器最终都会因这种累积漂移而上溢或[下溢](@entry_id:635171)。因此，通信策略必须包含**速率匹配（rate matching）**机制，例如使用弹性缓冲器并配合周期性的插入/删除（slip/justify）操作来补偿频率差异。

#### 亚稳态：CDC失效的物理根源

当一个[双稳态](@entry_id:269593)元件（如触发器）的输入信号在其采样时钟边沿附近发生变化，从而违反了其建立时间（$t_{\text{setup}}$）或保持时间（$t_{\text{hold}}$）约束时，该元件就可能进入一个非[稳态](@entry_id:139253)的平衡点，即**[亚稳态](@entry_id:167515)（Metastability）** 。

在这种状态下，[锁存器](@entry_id:167607)内部的差分节点电压会徘徊在逻辑阈值附近，既非逻辑0也非逻辑1。电路最终会因[热噪声](@entry_id:139193)等微小扰动而随机地解析到一个稳定状态，但这个**解析时间（resolution time）是无界的，并服从指数分布**。

对亚稳态的[随机建模](@entry_id:261612)是CDC设计的基础。一个[亚稳态](@entry_id:167515)事件的解析过程可以用以下模型描述：

-   **[再生时间常数](@entry_id:1130788) $\tau$**：这是描述双稳态元件在亚稳态点附近小信号行为的关键参数，单位为时间。它决定了内部差分电压[指数增长](@entry_id:141869)的速率，也即解析时间分布的指数衰减速率。$\tau$ 主要由锁存器核心的晶体管[跨导](@entry_id:274251)和节点电容决定，是衡量一个触发器“抗亚稳态能力”的指标，$\tau$ 越小越好。

-   **采样窗参数 $T_0$**：这是一个与器件和[拓扑相](@entry_id:141674)关的常数，单位为时间。它反映了将输入时序误差映射到[亚稳态](@entry_id:167515)[线性区](@entry_id:1127283)域初始条件的有效采样[孔径](@entry_id:172936)。可以理解为，它量化了多大概率一个异步事件会“击中”[亚稳态](@entry_id:167515)窗口。

当一个平均翻转率为 $f_{\text{data}}$ 的异步输入信号被一个频率为 $f_{\text{clk}}$ 的时钟采样，并且第一级触发器有 $T_{\text{res}}$ 的时间来解析亚稳态（例如，在被第二级触发器采样之前），那么[同步器](@entry_id:175850)发生失效（即在 $T_{\text{res}}$ 时间内未能解析）的失效率 $\lambda$（单位：次/秒）可以表示为：
$$ \lambda = f_{\text{clk}} f_{\text{data}} T_0 \exp(-\frac{T_{\text{res}}}{\tau}) $$
平均无故障时间（MTBF）是[失效率](@entry_id:266388)的倒数：
$$ \mathrm{MTBF} = \frac{1}{\lambda} = \frac{\exp(T_{\text{res}}/\tau)}{f_{\text{clk}} f_{\text{data}} T_0} $$
这个公式至关重要，它揭示了MTBF与可用解析时间 $T_{\text{res}}$ 呈**指数关系**。这意味着，在同步器中增加一级触发器（从而将 $T_{\text{res}}$ 增加大约一个时钟周期）可以极大地、指数级地提高系统的可靠性。这就是两级或三级触发器同步器被广泛使用的理论基础。

### [异步通信](@entry_id:173592)机制

为了在GALS系统的同步岛之间可靠地传递数据，必须采用精心设计的[异步通信](@entry_id:173592)机制。这些机制的核心在于如何协调数据与控制信号，以确保数据在被接收方采样时是稳定且有效的。

#### [握手协议](@entry_id:174594)

握手协议是[异步通信](@entry_id:173592)的基石，它通过一对[控制信号](@entry_id:747841)——发送方的**请求（request, req）**和接收方的**应答（acknowledge, ack）**——来协调[数据传输](@entry_id:276754)。

-   **[四相握手](@entry_id:165620)（Four-Phase Handshake）**：也称为**归零（Return-to-Zero）**协议。一次完整的[数据传输](@entry_id:276754)包含四个事件序列 ：
    1.  发送方将有效数据放在[数据总线](@entry_id:167432)上，并断言 $req$（例如，从 $0 \to 1$）。
    2.  接收方捕获数据，并断言 $ack$（$0 \to 1$）以示确认。
    3.  发送方看到 $ack$ 被断言后，撤销 $req$（$1 \to 0$）。
    4.  接收方看到 $req$ 被撤销后，撤销 $ack$（$1 \to 0$），完成一个周期。
    每个控制信号在一次传输中都经历一次上升沿和一次下降沿，且信号必须是单调的（无毛刺）。这种协议逻辑直观，每个状态（如“数据有效”或“空闲”）都对应一个稳定的电平。

-   **两相握手（Two-Phase Handshake）**：也称为**跃迁（Transition Signaling）**协议。它将“事件”定义为信号的任意一次翻转（toggle），而不是特定的上升沿或下降沿 。
    1.  发送方放置数据，并翻转 $req$ 信号。
    2.  接收方捕获数据，并翻转 $ack$ 信号。
    一次传输仅需两次信号翻转，理论上比[四相握手](@entry_id:165620)更高效。然而，其实现逻辑（需要检测边沿而非电平）通常更复杂。同样，控制信号在一次传输中必须是单调的，即只翻转一次。

#### 数据编码策略

数据本身如何与握手信号协同工作，是异步接口设计的核心。主要有两种策略：捆绑数据和延迟不敏感编码。

##### 捆绑数据通道（Bundled-Data Channels）

这是最常见的策略。数据（通常是多位）通过一组普通的单轨（single-rail）线路传输，其有效性由一个单独的 $req$ 信号来“捆绑”宣告。这种方法的正确性依赖于一个严格的相对[时序约束](@entry_id:168640)，即**捆绑约束（Bundling Constraint）** 。

该约束要求，$req$ 信号的到达时间必须晚于所有数据位中最慢一个的到达时间，并且要留出接收方[锁存器](@entry_id:167607)的[建立时间裕量](@entry_id:164917)。考虑工艺、电压和温度（PVT）变化，该约束必须使用最差情况（数据最慢）和最佳情况（控制最快）的延迟来表述：
$$ t_{\mathrm{pd,ctrl}}^{\min} \ge t_{\mathrm{pd,data}}^{\max} + t_{\mathrm{setup,Rx}} + t_{\mathrm{margin}} $$
其中：
-   $t_{\mathrm{pd,ctrl}}^{\min}$ 是[控制路径](@entry_id:747840)（$req$ 信号）的最小[传播延迟](@entry_id:170242)。
-   $t_{\mathrm{pd,data}}^{\max}$ 是数据路径中最慢一位的最大[传播延迟](@entry_id:170242)。
-   $t_{\mathrm{setup,Rx}}$ 是接收方锁存器的[建立时间](@entry_id:167213)。
-   $t_{\mathrm{margin}}$ 是为未建模效应保留的设计安全裕量。

为了满足这个约束，通常采用**匹配延迟（Matched Delay）**的方法：在 $req$ 信号路径上故意插入一个延迟元件，其延迟经过精心设计，以确保即使在最坏的PVT条件下，该延迟也足以覆盖数据路径的最大延迟和裕量。

##### 延迟不敏感编码（Delay-Insensitive Encodings）

与捆绑[数据依赖](@entry_id:748197)时序假设不同，延迟不敏感编码通过数据本身的表示方式来宣告其有效性，从而内在地实现了**[完成检测](@entry_id:1122724)（Completion Detection）**。这种方法对导线间的任意延迟（skew）具有鲁棒性 。

-   **[双轨编码](@entry_id:167964)（Dual-Rail Encoding）**：也称作 $1$-of-$2$ 编码。每个逻辑位由两根物理导线表示，例如 $d_T$ (true) 和 $d_F$ (false)。
    -   逻辑 `1` 表示为 $(d_T, d_F) = (1, 0)$。
    -   逻辑 `0` 表示为 $(d_T, d_F) = (0, 1)$。
    -   还有一个**间隔状态（spacer）**，通常为 $(0, 0)$，表示“无数据”。
    一次[四相握手](@entry_id:165620)的数据传输过程是 `间隔` $\to$ `有效数据` $\to$ `间隔`。接收方可以通过检查每一对导线是否都已脱离 $(0, 0)$ 状态来确定一个完整的数据字是否已到达，而无需一个独立的 $req$ 信号。这种内禀的[完成检测](@entry_id:1122724)特性使其对导线间的延迟差异不敏感。

-   **$m$-of-$n$ 编码**：这是[双轨编码](@entry_id:167964)的推广。一个码字由 $n$ 根导线组成，其中正好有 $m$ 根被断言为高电平来表示一个[有效值](@entry_id:276804)。例如，一个 $2$-of-$7$ 码。间隔状态是所有 $n$ 根线都为低电平。接收方通过计算高电平线的数量来检测完成——当计数达到 $m$ 时，数据有效。

与依赖于匹配延迟的捆绑数据通道相比，$m$-of-$n$ 编码（包括[双轨编码](@entry_id:167964)）对导线内部的延迟偏斜具有天然的鲁棒性。其正确性不依赖于导线间的[固定相](@entry_id:168149)对延迟。

实现这些编码的[完成检测](@entry_id:1122724)逻辑通常使用**[穆勒C元件](@entry_id:170454)（Muller C-element）**。C元件是一个基本的异步[逻辑门](@entry_id:178011)，其输出仅在所有输入相同时才跟随输入变化，否则保持原状态。通过将多个C元件构成树形结构，可以构建一个单调的、无险象的多输入[完成检测](@entry_id:1122724)器。

值得注意的是，虽然这些编码在理论上支持完全的延迟不敏感（DI）通信，但在实际电路实现中，通常会依赖**等时分叉假设（isochronic fork assumption）**，即一个信号[扇出](@entry_id:173211)到多个门时，其到达这些门的时间差可以忽略不计。这种稍弱的模型被称为**准延迟不敏感（Quasi-Delay-Insensitive, QDI）**，它是绝大多数实用[异步电路](@entry_id:169162)遵循的设计模型 。

### 高级 GALS 接口与系统级技术

掌握了基本的通信机制后，我们还需要关注更复杂的接口设计挑战和系统级的行为问题，它们对构建大型、可靠的GALS系统至关重要。

#### 同步器设计与陷阱：重汇聚问题

尽管使用两级或三级触发器链构成的[同步器](@entry_id:175850)是处理CDC信号的基本手段，但当多个独立同步的信号在目标域中重新汇合到一个组合逻辑锥时，会产生一个非常微妙且危险的**重汇聚问题（Reconvergence Problem）** 。

考虑一个场景：源域中有两个相关的控制信号 $a$ 和 $b$，它们本意是同时从 $0 \to 1$ 变化以表示一个逻辑事件。它们通过各自独立的[双触发器同步器](@entry_id:166595)进入目标域，然后输入到一个[异或门](@entry_id:162892)（$z = a_{\text{sync}} \oplus b_{\text{sync}}$）。由于[亚稳态](@entry_id:167515)解析时间的随机性，两个同步器链的有效传播延迟 $E_a$ 和 $E_b$ 是独立的[随机变量](@entry_id:195330)。这会导致 $a_{\text{sync}}$ 和 $b_{\text{sync}}$ 到达[异或门](@entry_id:162892)的时间产生一个随机的**亚稳态诱导偏斜（metastability-induced skew）**，即 $|E_a - E_b|$。

如果这个偏斜大于[异或门](@entry_id:162892)的传播延迟，就会在输出 $z$ 上产生一个短暂的毛刺（glitch）。例如，当 $a_{\text{sync}}$ 先变为 $1$ 而 $b_{\text{sync}}$ 仍为 $0$ 时，$z$ 会短暂地变为 $1$，直到 $b_{\text{sync}}$ 也变为 $1$ 时才回到预期的 $0$。如果这个毛刺恰好被下游的触发器在其采样窗口内捕获，就会导致一次功能性错误。

这个问题的严重性在于，即使每个单独的[同步器](@entry_id:175850)都设计得非常可靠（即MTBF极高），由它们之间的随机延迟差引起的重汇聚失败概率也可能高得令人无法接受。其失败概率 $p$ 可以被量化，它依赖于亚稳态时间常数 $\tau$、[组合逻辑](@entry_id:265083)的[污染延迟](@entry_id:164281) $t_c$ 和捕获触发器的采样窗口 $\sigma$。例如，在一个简化的模型下，失败概率可近似为：
$$ p \approx \frac{\exp(-t_c/\tau)(\tau + \sigma)}{T_D} $$
其中 $T_D$ 是目标[时钟周期](@entry_id:165839)。这表明，重汇聚问题是CDC设计中一个必须被特殊处理的严重隐患。解决方案通常涉及在发送端将多个相关信号编码成单一信息，或者在接收端使用特殊的重汇聚[同步电路](@entry_id:172403)。

#### 封装器设计：实现[安全通信](@entry_id:271655)的接口逻辑

为了将同步岛安全地集成到GALS系统中，通常会在其周围设计一个**封装器（Wrapper）**。封装器的职责是处理所有进出该岛的[异步通信](@entry_id:173592)，将复杂的异步行为转换为该岛能够理解的简单同步接口。

##### 可暂[停时](@entry_id:261799)钟（Pausible Clocking）

这是一种优雅的输入接口技术，它通过**动态调整[局部时](@entry_id:194383)钟**来确保对异步输入的采样安全 。其核心思想是：与其让异步输入信号去“追赶”一个固定不变的采样时钟，不如让时钟“等待”输入信号稳定。

一个可暂[停时](@entry_id:261799)钟生成器能够在外部握手信号的控制下，延迟（拉伸）下一个时钟边沿的到来。当一个异步请求到达时，如果其时序可能违反捕获触发器的建立/保持时间，接口前端的异步逻辑会立即请求时钟暂停。时钟生成器（例如，一个内置了[穆勒C元件](@entry_id:170454)的环形振荡器）会停止相位推进，直到握手信号表明输入已经稳定。此时，时钟暂停被释放，一个安全的时钟边沿被产生出来用于采样。

这种机制通过牺牲一点延迟来换取绝对的采样安全，它允许[亚稳态](@entry_id:167515)有充足的时间来解析，从而极大地提高了接口的MTBF。重要的是，一个设计良好的可暂[停时](@entry_id:261799)钟生成器只会拉伸[时钟周期](@entry_id:165839)，而不会产生毛刺或违反最小脉宽，并且它会均匀地暂停整个时钟域。因此，对于岛内原有的[同步逻辑](@entry_id:176790)而言，[时钟周期](@entry_id:165839)的增加只会放松建立时间约束，而不会影响保持时间约束，从而保证了局部同步时序不被破坏  。

##### [延迟不敏感设计](@entry_id:748287)（Latency-Insensitive Design）

这是一种更高层次的[系统设计](@entry_id:755777)方法论，它通过标准化的**壳（Shell）**和**中继站（Relay Station）**来系统性地解决通信延迟的可变性问题 。

-   **壳（Shell）**：每个同步岛都被一个标准化的“壳”包裹。这个壳将其原始的输入/输出端口转换为遵循**`valid/ready`流控协议**的弹性通道。
-   **`valid/ready`流控**：这是一种简单的双向握手。发送方用 `valid` [信号表示](@entry_id:266189)数据有效，接收方用 `ready` [信号表示](@entry_id:266189)已准备好接收。只有当 `valid` 和 `ready` 同时为高时，数据才在一个[时钟周期](@entry_id:165839)内完成传输。
-   **暂停机制（Stall Mechanism）**：壳的核心功能是生成一个暂停信号 $s(t)$。当任何一个输入通道没有 `valid` 数据，或者任何一个输出通道的下游不 `ready` 时，壳就会断言 $s(t)=1$。这个暂停信号会使同步岛内部的[状态寄存器](@entry_id:755408)保持不变（例如，通过时钟使能），即 $x(t+1) = x(t)$。当所有通信条件满足时 ($s(t)=0$)，岛才执行其正常的同步更新。
-   **中继站（Relay Station）**：它们是遵循相同 `valid/ready` 协议的简单[流水线寄存器](@entry_id:753459)（或小FIFO），可以被任意地插入到通道中。它们的作用是在[物理设计](@entry_id:1129644)阶段打断长线，改善时序，而不改变系统的功能正确性。

通过这种方式，同步岛的内部时序设计（其局部[时钟频率](@entry_id:747385)和路径延迟）与外部的通信延迟完全[解耦](@entry_id:160890)。通信延迟的变化只会影响系统的吞吐率（通过暂停周期的多少），而不会影响其功能正确性或内部[时序约束](@entry_id:168640)。这使得设计流程高度模块化，并极大地简化了大型SoC的[时序收敛](@entry_id:167567)过程。

#### 系统级完整性：死锁与[活锁](@entry_id:751367)

当多个GALS岛通过复杂的网络互连时，必须考虑系统级的并发问题，如**[死锁](@entry_id:748237)（Deadlock）**和**[活锁](@entry_id:751367)（Livelock）** 。这些问题通常可以通过构建**资源依赖图** $G=(V,E)$ 来分析，其中顶点代表处理阶段，有向边代表“等待”关系。

-   **死锁（Deadlock）**：指的是系统中存在一个非空的处理单元集合，其中每个单元都在等待该集合中另一个单元释放资源，从而导致所有相关单元被永久阻塞。[死锁](@entry_id:748237)的**必要条件是存在一个[循环等待](@entry_id:747359)**，即资源依赖图中存在一个有向环。
    -   在基于握手的通道中，[死锁](@entry_id:748237)发生的必要条件是一个**填满的循环（full cycle）**：环路上的每个通道都持有一个数据令牌，没有任何空闲的“气泡”（bubble）。这导致每个上游节点都在等待下游节点接收数据，但下游节点因为自己也无法发送数据而不能接收，从而形成僵局。
    -   在基于信用的流控中，死锁发生的必要条件是一个**零信用循环（zero-credit cycle）**：环路上的每条链路的可用信用 $q_e$ 都为零。这意味着所有下游缓冲区都已满，上游节点无法发送数据，因此下游节点也无法消耗数据来释放缓冲区并返回信用。

-   **[活锁](@entry_id:751367)（Livelock）**：与[死锁](@entry_id:748237)的静态阻塞不同，[活锁](@entry_id:751367)是一种动态的“瞎忙”状态。系统中的组件状态在不断变化，数据包也在移动，但没有任何有用的端到端事务能够完成。例如，数据包可能在一个[子网](@entry_id:156282)络中无休止地循环，而无法到达其最终目的地。[活锁](@entry_id:751367)发生的必要条件是：
    1.  存在一个允许数据移动的循环（即循环不满足[死锁](@entry_id:748237)条件，例如存在气泡或信用）。
    2.  系统的仲裁或路由策略**缺乏饥饿自由（starvation-freedom）**。例如，一个[路由算法](@entry_id:1131127)可能总是优先选择使数据包在环路内偏转的路径，或者一个仲裁器可能总是忽略某个特定请求，导致该请求永远无法获得所需资源以跳出循环。

预防死锁和[活锁](@entry_id:751367)是GALS[互连网络](@entry_id:750720)设计的核心任务，通常通过设计无环路的[路由算法](@entry_id:1131127)，或者实施保证公平性和前进性的仲裁策略来实现。