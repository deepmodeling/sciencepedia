{
    "hands_on_practices": [
        {
            "introduction": "并行乘法器的核心是其压缩树，它负责将大量的局部积行有效地归约为两行。本练习旨在通过对一个 $24 \\times 24$ 乘法器手动综合第一级归约，来直接比较两种经典的压缩树架构：Wallace 树和 Dadda 树。通过这个过程，你将深入理解 Wallace 方法的贪心策略与 Dadda 方法的分阶段约束策略在硬件资源使用上的具体差异，从而为实际设计中的架构选择提供依据。",
            "id": "4275975",
            "problem": "考虑一个有符号乘法单元，在高速乘法器架构（用于集成电路和电子设计自动化EDA）的背景下，使用并行部分积阵列和压缩树来实现一个 $24 \\times 24$ 位的乘积。部分积列由 $k \\in \\{0,1,\\dots,46\\}$ 索引，其列高分布由 $h_k = \\min(k+1, 47-k)$ 给出，这对应于方形乘法器的部分积的三角形分布。\n\n对于第一级化简，考虑两种列压缩策略：\n- Wallace方法，该方法在第一级内贪婪地在每列中尽可能多地应用 $3:2$ 压缩器（全加器），且在该级中不使用任何 $2:1$ 压缩器（半加器）。$3:2$ 压缩器将同一列的三个输入位映射为同一列的一个和位以及下一个更高有效列的一个进位位。\n- Dadda方法，该方法使用Dadda序列计算第一级的最大列高界限 $d$，然后最少地应用 $3:2$ 和 $2:1$ 压缩器，以确保在第一级之后，每列的高度不超过 $d$。在Dadda化简中，一个 $3:2$ 压缩器使当前列的高度减少2，并向下一列产生一个进位；而一个 $2:1$ 压缩器使当前列的高度减少1，并向下一列产生一个进位。在确定每列需要多少压缩器时，必须从最低有效列到最高有效列顺序地考虑该级内产生的进位。\n\n在每种方法下精确地综合一个化简级，并计算该级所需的 $3:2$ 和 $2:1$ 化简的总数。将最终答案表示为一个单行矩阵中的四个数字，顺序为 $\\left(N_{3:2}^{\\text{Wallace}}, N_{2:1}^{\\text{Wallace}}, N_{3:2}^{\\text{Dadda}}, N_{2:1}^{\\text{Dadda}}\\right)$。不需要四舍五入。不需要单位。",
            "solution": "本问题要求根据两种不同的策略（一种类Wallace方法和一种Dadda方法），计算一个 $24 \\times 24$ 乘法器在第一级化简中使用的 $3:2$ 和 $2:1$ 压缩器的数量。\n\n部分积阵列的初始列高分布由 $h_k = \\min(k+1, 47-k)$ 给出，其中列索引 $k \\in \\{0, 1, \\dots, 46\\}$。该阵列的最大高度出现在 $k=23$ 处，此时 $h_{23} = \\min(23+1, 47-23) = 24$。\n\n一个 $3:2$ 压缩器（全加器）从列 $k$ 接收 $3$ 个输入位，并在列 $k$ 中产生一个和位，在列 $k+1$ 中产生一个进位位。这将使列 $k$ 的高度减少 $2$，并使列 $k+1$ 的高度增加 $1$。\n一个 $2:1$ 压缩器（半加器）从列 $k$ 接收 $2$ 个输入位，并在列 $k$ 中产生一个和位，在列 $k+1$ 中产生一个进位位。这将使列 $k$ 的高度减少 $1$，并使列 $k+1$ 的高度增加 $1$。\n\n首先，我们分析Wallace方法。\n指定的Wallace策略是在每个列中贪婪地应用 $3:2$ 压缩器，以在单级内实现最大化简，且在该级中不使用任何 $2:1$ 压缩器。\n对于初始高度为 $h_k$ 的列 $k$，可以应用的 $3:2$ 压缩器的数量为 $n_{3:2, k}^{\\text{Wallace}} = \\lfloor h_k / 3 \\rfloor$。\n问题指出不使用 $2:1$ 压缩器，所以 $N_{2:1}^{\\text{Wallace}} = 0$。\n$3:2$ 压缩器的总数 $N_{3:2}^{\\text{Wallace}}$ 是对所有列求和：\n$$N_{3:2}^{\\text{Wallace}} = \\sum_{k=0}^{46} n_{3:2, k}^{\\text{Wallace}} = \\sum_{k=0}^{46} \\left\\lfloor \\frac{h_k}{3} \\right\\rfloor$$\n列高分布 $h_k$ 是对称的。我们可以将求和拆分：\n$$N_{3:2}^{\\text{Wallace}} = \\sum_{k=0}^{23} \\left\\lfloor \\frac{k+1}{3} \\right\\rfloor + \\sum_{k=24}^{46} \\left\\lfloor \\frac{47-k}{3} \\right\\rfloor$$\n在第一个和式中，令 $j=k+1$。当 $k=0$ 时，$j=1$；当 $k=23$ 时，$j=24$。和式变为 $\\sum_{j=1}^{24} \\lfloor j/3 \\rfloor$。\n这个和可以计算为 $3 \\times (1+2+3+4+5+6+7) + \\lfloor 24/3 \\rfloor = 3 \\times 28 + 8 = 84 + 8 = 92$。\n在第二个和式中，令 $j=47-k$。当 $k=24$ 时，$j=23$；当 $k=46$ 时，$j=1$。和式变为 $\\sum_{j=1}^{23} \\lfloor j/3 \\rfloor$。\n这个和是 $3 \\times (1+2+3+4+5+6+7) = 3 \\times 28 = 84$。\n因此，$3:2$ 压缩器的总数为：\n$$N_{3:2}^{\\text{Wallace}} = 92 + 84 = 176$$\n$2:1$ 压缩器的数量为：\n$$N_{2:1}^{\\text{Wallace}} = 0$$\n\n接下来，我们分析Dadda方法。\nDadda策略要求将列高降低到不超过一个由Dadda序列确定的特定值 $d$。该序列定义为 $d_0 = 2$ 和 $d_{j+1} = \\lfloor 1.5 d_j \\rfloor$。\n该序列为 $d_0=2$, $d_1=3$, $d_2=4$, $d_3=6$, $d_4=9$, $d_5=13$, $d_6=19$, $d_7=28$, ...\n最大初始高度为 $h_{\\max} = 24$。第一级的高度限制 $d$ 是Dadda序列中小于 $h_{\\max}$ 的最大成员。因此，我们有 $d=19$。\n目标是最小化地应用压缩器，使得对于每个列 $k$，化简后的最终高度最多为 $19$。这个过程从最低有效列（$k=0$）到最高有效列（$k=46$）顺序执行，同时考虑前一列产生的进位。\n令 $h_k$ 为列 $k$ 的初始高度，$c_k$ 为从列 $k-1$ 输入的进位位数。列 $k$ 需要考虑的总高度为 $H_k = h_k + c_k$。\n如果 $H_k > 19$，我们必须应用压缩器。为了最小化应用，我们使用 $n_{3:2,k}$ 个全加器和 $n_{2:1,k}$ 个半加器，其中 $n_{3:2,k} = \\lfloor (H_k - 19)/2 \\rfloor$ 且 $n_{2:1,k} = (H_k - 19) \\pmod 2$。产生到列 $k+1$ 的进位数量为 $c_{k+1} = n_{3:2,k} + n_{2:1,k}$。\n\n我们现在开始逐列计算，从 $c_0=0$ 开始。\n对于 $k \\in \\{0, \\dots, 18\\}$，$h_k = k+1 \\le 19$。由于这些列的 $c_k=0$，所以 $H_k \\le 19$。不需要化简。$n_{3:2,k}=0, n_{2:1,k}=0, c_{k+1}=0$。\n对于 $k=19$：$h_{19}=20, c_{19}=0 \\implies H_{19}=20$。$H_{19}-19 = 1$。$n_{3:2,19}=\\lfloor 1/2 \\rfloor = 0$，$n_{2:1,19}=1 \\pmod 2 = 1$。$c_{20}=0+1=1$。\n对于 $k=20$：$h_{20}=21, c_{20}=1 \\implies H_{20}=22$。$H_{20}-19 = 3$。$n_{3:2,20}=\\lfloor 3/2 \\rfloor = 1$，$n_{2:1,20}=3 \\pmod 2 = 1$。$c_{21}=1+1=2$。\n对于 $k=21$：$h_{21}=22, c_{21}=2 \\implies H_{21}=24$。$H_{21}-19 = 5$。$n_{3:2,21}=\\lfloor 5/2 \\rfloor = 2$，$n_{2:1,21}=5 \\pmod 2 = 1$。$c_{22}=2+1=3$。\n对于 $k=22$：$h_{22}=23, c_{22}=3 \\implies H_{22}=26$。$H_{22}-19 = 7$。$n_{3:2,22}=\\lfloor 7/2 \\rfloor = 3$，$n_{2:1,22}=7 \\pmod 2 = 1$。$c_{23}=3+1=4$。\n对于 $k=23$：$h_{23}=24, c_{23}=4 \\implies H_{23}=28$。$H_{23}-19 = 9$。$n_{3:2,23}=\\lfloor 9/2 \\rfloor = 4$，$n_{2:1,23}=9 \\pmod 2 = 1$。$c_{24}=4+1=5$。\n对于 $k=24$：$h_{24}=23, c_{24}=5 \\implies H_{24}=28$。$H_{24}-19 = 9$。$n_{3:2,24}=\\lfloor 9/2 \\rfloor = 4$，$n_{2:1,24}=9 \\pmod 2 = 1$。$c_{25}=4+1=5$。\n对于 $k=25$：$h_{25}=22, c_{25}=5 \\implies H_{25}=27$。$H_{25}-19 = 8$。$n_{3:2,25}=\\lfloor 8/2 \\rfloor = 4$，$n_{2:1,25}=8 \\pmod 2 = 0$。$c_{26}=4+0=4$。\n对于 $k=26$：$h_{26}=21, c_{26}=4 \\implies H_{26}=25$。$H_{26}-19 = 6$。$n_{3:2,26}=\\lfloor 6/2 \\rfloor = 3$，$n_{2:1,26}=6 \\pmod 2 = 0$。$c_{27}=3+0=3$。\n对于 $k=27$：$h_{27}=20, c_{27}=3 \\implies H_{27}=23$。$H_{27}-19 = 4$。$n_{3:2,27}=\\lfloor 4/2 \\rfloor = 2$，$n_{2:1,27}=4 \\pmod 2 = 0$。$c_{28}=2+0=2$。\n对于 $k=28$：$h_{28}=19, c_{28}=2 \\implies H_{28}=21$。$H_{28}-19 = 2$。$n_{3:2,28}=\\lfloor 2/2 \\rfloor = 1$，$n_{2:1,28}=2 \\pmod 2 = 0$。$c_{29}=1+0=1$。\n对于 $k=29$：$h_{29}=18, c_{29}=1 \\implies H_{29}=19$。由于 $H_{29} \\le 19$，不需要化简。$n_{3:2,29}=0, n_{2:1,29}=0, c_{30}=0$。\n对于所有后续列 $k>29$，$h_k  19$ 且 $c_k = 0$，因此在这一级中不再发生化简。\n\nDadda方法的压缩器总数：\n$N_{3:2}^{\\text{Dadda}} = \\sum_{k=0}^{46} n_{3:2,k} = 0+1+2+3+4+4+4+3+2+1 = 24$。\n$N_{2:1}^{\\text{Dadda}} = \\sum_{k=0}^{46} n_{2:1,k} = 1+1+1+1+1+1+0+0+0+0 = 6$。\n\n所需的四个数字是 $\\left(N_{3:2}^{\\text{Wallace}}, N_{2:1}^{\\text{Wallace}}, N_{3:2}^{\\text{Dadda}}, N_{2:1}^{\\text{Dadda}}\\right)$。\n$N_{3:2}^{\\text{Wallace}} = 176$。\n$N_{2:1}^{\\text{Wallace}} = 0$。\n$N_{3:2}^{\\text{Dadda}} = 24$。\n$N_{2:1}^{\\text{Dadda}} = 6$。\n结果是 $(176, 0, 24, 6)$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 176  0  24  6 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在追求速度和面积优化的同时，设计的另一个关键维度是数值精度。在许多实际应用中，保留完整的乘积位数既不必要，成本也过高，因此截断（truncation）成为一种常见选择。本练习将探讨定点乘法中因截断而引入的统计误差，要求你量化分析不同舍入方案——包括纯截断、偏置补偿和无偏置的“舍入到最近偶数”——对结果的影响。这项实践将硬件实现与最终的算术行为直接联系起来，这对于保证定点计算的精度至关重要。",
            "id": "4275921",
            "problem": "考虑一个无符号 $32 \\times 32$ 并行乘法器，该乘法器使用高速部分积压缩网络（例如，华莱士树 (Wallace tree)）实现，产生一个精确的 $64$ 位乘积 $P$。为了减少关键路径延迟和功耗，该设计在最终的进位传播加法器之前，截断了乘积的 $k=8$ 个最低有效位 (LSB)，从而得到一个 $56$ 位的截断乘积。截断误差定义为 $e = \\hat{P} - P$，其中 $\\hat{P}$ 是输出的（近似）乘积。假设操作数在其 $32$ 位范围内均匀分布，因此被丢弃的余数可以很好地建模为均匀分布且与保留的位相独立。\n\n分析三种方案：\n- 纯截断：无校正。\n- 偏置补偿：在截断前加上一个等于截断量子一半的恒定偏移量。\n- 向偶数舍入的无偏最近舍入：解决半量子边界问题，使得在平局情况下的期望误差为零。\n\n对被丢弃的 $8$ 位余数的集合，使用以下误差度量定义：\n- 平均误差 $\\mu = \\mathbb{E}[e]$。\n- 平均绝对误差 $\\eta = \\mathbb{E}[|e|]$。\n- 最坏情况误差幅度 $\\epsilon_{\\max} = \\max |e|$。\n\n将 $64$ 位精确乘积建模为 $P = 256 M + d$，其中 $M \\in \\mathbb{Z}$ 是保留的 $56$ 位部分，而 $d \\in \\{0,1,\\dots,255\\}$ 是被丢弃的余数。对于偏置补偿，在截断前的路径上加上常数 $C = 128$。对于向偶数舍入的无偏舍入，假设 $M$ 的奇偶性是等可能的，因此平局情况贡献的平均误差为零。\n\n计算每种方案的 $\\mu$、$\\eta$ 和 $\\epsilon_{\\max}$，结果表示为原始乘积的整数单位（即 $P$ 的最低有效位的计数）的精确值。将您的最终答案表示为九个数字，顺序为：纯截断 $(\\mu, \\eta, \\epsilon_{\\max})$、偏置补偿 $(\\mu, \\eta, \\epsilon_{\\max})$、无偏舍入 $(\\mu, \\eta, \\epsilon_{\\max})$。不需要进行四舍五入。",
            "solution": "该问题要求分析三种不同定点乘积截断方案的误差特性。精确的 $64$ 位乘积 $P$ 建模为 $P = 256M + d$，其中 $M$ 是要保留的高 $56$ 位部分，而 $d$ 是要丢弃的低 $8$ 位余数。$d$ 的值是集合 $\\{0, 1, 2, \\dots, 255\\}$ 中的一个整数。根据问题陈述，我们将 $d$ 建模为在该集合上均匀分布的离散随机变量。其概率质量函数为 $p(d) = \\frac{1}{256}$，适用于其定义域中的任何 $d$。误差定义为 $e = \\hat{P} - P$，其中 $\\hat{P}$ 是近似的截断乘积。所有误差度量都是以原始乘积 $P$ 的最低有效位 (LSB) 为单位计算的，其权重为 $1$。\n\n余数的任意函数 $f(d)$ 的期望由对所有可能的 $d$ 值求和给出：\n$$ \\mathbb{E}[f(d)] = \\sum_{d=0}^{255} f(d) p(d) = \\frac{1}{256} \\sum_{d=0}^{255} f(d) $$\n我们将使用前 $n$ 个整数求和的公式：$\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}$。可能的余数值之和为：\n$$ \\sum_{d=0}^{255} d = \\frac{255(255+1)}{2} = \\frac{255 \\times 256}{2} = 32640 $$\n\n我们依次分析每种方案，以找到平均误差 $\\mu = \\mathbb{E}[e]$、平均绝对误差 $\\eta = \\mathbb{E}[|e|]$ 和最坏情况误差幅度 $\\epsilon_{\\max} = \\max|e|$。\n\n**方案1：纯截断**\n在纯截断中，简单地丢弃 $8$ 个 LSB。这等效于将乘积除以 $2^8 = 256$ 后取底。保留的部分是 $M$。\n近似乘积为 $\\hat{P} = 256M$。\n因此，误差 $e$ 为：\n$$ e = \\hat{P} - P = 256M - (256M + d) = -d $$\n我们现在可以计算误差度量：\n- **平均误差 ($\\mu_1$)**：\n$$ \\mu_1 = \\mathbb{E}[e] = \\mathbb{E}[-d] = -\\mathbb{E}[d] = -\\frac{1}{256} \\sum_{d=0}^{255} d = -\\frac{32640}{256} = -127.5 $$\n- **平均绝对误差 ($\\eta_1$)**：由于 $d \\ge 0$，所以 $|e| = |-d| = d$。\n$$ \\eta_1 = \\mathbb{E}[|e|] = \\mathbb{E}[d] = \\frac{1}{256} \\sum_{d=0}^{255} d = 127.5 $$\n- **最坏情况误差幅度 ($\\epsilon_{\\max, 1}$)**：\n$$ \\epsilon_{\\max, 1} = \\max_{d \\in \\{0, \\dots, 255\\}} |e| = \\max_{d} |-d| = \\max_{d} d = 255 $$\n\n**方案2：偏置补偿**\n在截断前，给乘积加上一个常数偏移量 $C=128$。待处理的值为 $P' = P + 128 = 256M + d + 128$。\n近似乘积为 $\\hat{P} = 256 \\times \\lfloor \\frac{P'}{256} \\rfloor = 256 \\times \\lfloor \\frac{256M + d + 128}{256} \\rfloor = 256 \\times \\lfloor M + \\frac{d+128}{256} \\rfloor$。\n向下取整函数（floor function）的行为取决于 $d$：\n- 如果 $0 \\le d \\le 127$，那么 $0.5 \\le \\frac{d+128}{256}  1$。因此，$\\lfloor M + \\frac{d+128}{256} \\rfloor = M$。\n  $\\hat{P} = 256M$，误差为 $e = 256M - (256M+d) = -d$。\n- 如果 $128 \\le d \\le 255$，那么 $1 \\le \\frac{d+128}{256}  1.5$。因此，$\\lfloor M + \\frac{d+128}{256} \\rfloor = M+1$。\n  $\\hat{P} = 256(M+1)$，误差为 $e = 256(M+1) - (256M+d) = 256-d$。\n我们通过对 $d$ 的这两个范围求和来计算度量：\n- **平均误差 ($\\mu_2$)**：\n$$ \\mu_2 = \\frac{1}{256} \\left( \\sum_{d=0}^{127} (-d) + \\sum_{d=128}^{255} (256-d) \\right) $$\n第一个和是 $\\sum_{d=0}^{127} (-d) = -\\frac{127 \\times 128}{2} = -8128$。\n令 $j=256-d$。对于第二个和，当 $d$ 从 $128$ 变到 $255$ 时，$j$ 从 $128$ 变到 $1$。所以 $\\sum_{d=128}^{255} (256-d) = \\sum_{j=1}^{128} j = \\frac{128 \\times 129}{2} = 8256$。\n$$ \\mu_2 = \\frac{1}{256} (-8128 + 8256) = \\frac{128}{256} = 0.5 $$\n- **平均绝对误差 ($\\eta_2$)**：\n$$ \\eta_2 = \\frac{1}{256} \\left( \\sum_{d=0}^{127} |-d| + \\sum_{d=128}^{255} |256-d| \\right) = \\frac{1}{256} \\left( \\sum_{d=0}^{127} d + \\sum_{d=128}^{255} (256-d) \\right) $$\n第一个和是 $\\frac{127 \\times 128}{2} = 8128$。第二个和是 $8256$。\n$$ \\eta_2 = \\frac{1}{256} (8128 + 8256) = \\frac{16384}{256} = 64 $$\n- **最坏情况误差幅度 ($\\epsilon_{\\max, 2}$)**：\n当 $d \\in \\{0, \\dots, 127\\}$ 时，误差的幅度为 $|e|=d$，其最大值为 $127$。\n当 $d \\in \\{128, \\dots, 255\\}$ 时，误差的幅度为 $|e|=256-d$，其最大值为 $256-128 = 128$。\n$$ \\epsilon_{\\max, 2} = \\max(127, 128) = 128 $$\n\n**方案3：向偶数舍入的无偏最近舍入**\n该方案将 $P/256 = M + d/256$ 舍入到最近的整数，并对平局情况有特殊规则。\n- 如果 $d/256  0.5$ (即 $0 \\le d \\le 127$)，我们向下舍入。$\\hat{P} = 256M$，所以 $e = -d$。\n- 如果 $d/256 > 0.5$ (即 $129 \\le d \\le 255$)，我们向上舍入。$\\hat{P} = 256(M+1)$，所以 $e = 256-d$。\n- 如果 $d/256 = 0.5$ (即 $d=128$)，则为平局。我们舍入到最近的偶数。\n  - 如果 $M$ 是偶数，我们向下舍入到 $M$。$\\hat{P}=256M$，所以 $e = -128$。\n  - 如果 $M$ 是奇数，我们向上舍入到 $M+1$。$\\hat{P}=256(M+1)$，所以 $e = 256-128 = 128$。\n题目给定 $M$ 是偶数或奇数的可能性相等，所以 $P(M \\text{ 是偶数}) = P(M \\text{ 是奇数}) = 0.5$。\n- **平均误差 ($\\mu_3$)**：现在，对于 $d=128$ 的情况，误差取决于 $M$。我们计算关于 $d$ 和 $M$ 的期望。\n$$ \\mu_3 = \\mathbb{E}_{d,M}[e] = \\frac{1}{256} \\left( \\sum_{d=0, d \\neq 128}^{255} e(d) + \\mathbb{E}_M[e(d=128, M)] \\right) $$\n$\\mathbb{E}_M[e(d=128, M)] = (-128) P(M \\text{ 是偶数}) + (128) P(M \\text{ 是奇数}) = -128(0.5) + 128(0.5) = 0$。\n和为 $\\sum_{d=0}^{127} (-d) + \\sum_{d=129}^{255} (256-d)$。\n第一部分是 $-8128$。对于第二部分，令 $j=256-d$。当 $d$ 从 $129$ 变到 $255$ 时，$j$ 从 $127$ 变到 $1$。所以 $\\sum_{j=1}^{127} j = \\frac{127 \\times 128}{2} = 8128$。\n$$ \\mu_3 = \\frac{1}{256} (-8128 + 0 + 8128) = 0 $$\n- **平均绝对误差 ($\\eta_3$)**：\n$$ \\eta_3 = \\frac{1}{256} \\left( \\sum_{d=0, d \\neq 128}^{255} |e(d)| + \\mathbb{E}_M[|e(d=128, M)|] \\right) $$\n$\\mathbb{E}_M[|e(d=128, M)|] = |-128| P(M \\text{ 是偶数}) + |128| P(M \\text{ 是奇数}) = 128(0.5) + 128(0.5) = 128$。\n和为 $\\sum_{d=0}^{127} d + \\sum_{d=129}^{255} (256-d) = 8128 + 8128 = 16256$。\n$$ \\eta_3 = \\frac{1}{256} (16256 + 128) = \\frac{16384}{256} = 64 $$\n- **最坏情况误差幅度 ($\\epsilon_{\\max, 3}$)**：\n当 $d \\in \\{0, \\dots, 127\\}$ 时，误差幅度为 $|e|=d$ (最大值为 $127$)；当 $d \\in \\{129, \\dots, 255\\}$ 时，误差幅度为 $|e|=256-d$ (最大值为 $127$)；当 $d=128$ 时，误差幅度为 $|e|=128$。\n$$ \\epsilon_{\\max, 3} = \\max(127, 128) = 128 $$\n\n结果总结：\n- 纯截断: $(\\mu_1, \\eta_1, \\epsilon_{\\max, 1}) = (-127.5, 127.5, 255)$。\n- 偏置补偿: $(\\mu_2, \\eta_2, \\epsilon_{\\max, 2}) = (0.5, 64, 128)$。\n- 无偏舍入: $(\\mu_3, \\eta_3, \\epsilon_{\\max, 3}) = (0, 64, 128)$。\n这九个值构成了最终答案。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} -127.5  127.5  255  0.5  64  128  0  64  128 \\end{pmatrix} } $$"
        },
        {
            "introduction": "进位保留（Carry-Save）技术不仅限于初始局部积矩阵的归约，它也是一种用于累加多个数值的强大工具。本练习将上一节的 $3:2$ 压缩思想推广到更通用的场景，即如何将四个输入比特向量（等效于两个进位保留数）有效地压缩为两个。通过分析这个通常被称为 $4:2$ 压缩器的结构，你将学会如何设计和评估在数字信号处理器（DSP）等复杂数据通路中常见的关键构建模块。",
            "id": "4275952",
            "problem": "考虑两个以进位保存（carry-save）编码的无符号 $n$ 位整数，表示为数对 $(S_{1}, C_{1})$ 和 $(S_{2}, C_{2})$，其中每个数对表示整数 $N = \\sum_{i=0}^{n-1} S[i] 2^{i} + \\sum_{i=0}^{n-1} C[i] 2^{i+1}$。任务是仅使用 $3:2$ 压缩器将这两个进位保存数对累加成一个单一的进位保存结果 $(S_{\\mathrm{out}}, C_{\\mathrm{out}})$。一个 $3:2$ 压缩器是一个全加器，它将三个等权重的输入位映射为一个同等权重的和位和一个更高一位权重的进位位。该网络是纯组合逻辑网络，并按层级组织；在某一级别产生的进位输出不能被同一级别的任何压缩器消耗。网络的深度定义为从输入到输出的此类压缩器级别的数量。\n\n假设 $n \\geq 2$，无符号扩展，并且在范围 $[0, n]$ 之外的边界列均为零。在只允许使用 $3:2$ 压缩器的约束下，设计一个最小深度的网络，将由 $(S_{1}, C_{1})$ 和 $(S_{2}, C_{2})$ 产生的初始每列位高降低到每列最多两位（从而产生一个单一的进位保存数对）。然后，计算最小可能深度作为 $n$ 的函数。\n\n提供最终的最小深度，以精确整数形式表示。无需四舍五入，不涉及物理单位。您的答案必须是单个数字。",
            "solution": "问题要求找到一个由 $3:2$ 压缩器组成的组合逻辑网络的最小深度，该网络用于将两个进位保存编码的数 $(S_1, C_1)$ 和 $(S_2, C_2)$ 相加，并产生一个单一的进位保存结果 $(S_{\\mathrm{out}}, C_{\\mathrm{out}})$。深度定义为压缩器的级别数。一个进位保存结果是指每个位列的高度最多为 $2$。\n\n首先，我们必须确定每个列位置的初始位数，即“高度”。一个进位保存数 $(S, C)$ 的值由 $N = \\sum_{i=0}^{n-1} S[i] 2^{i} + \\sum_{i=0}^{n-1} C[i] 2^{i+1}$ 给出。这意味着对于每个位置 $i$，我们有一个权重为 $2^i$ 的和位 $S[i]$ 和一个权重为 $2^{i+1}$ 的进位位 $C[i]$。后者等同于来自位置 $i$ 的一个位 $C[i]$ 被移位到位置 $i+1$。\n\n我们的任务是计算这两个数 $N_1$ 和 $N_2$ 的和：\n$N_1 + N_2 = \\left(\\sum_{i=0}^{n-1} S_1[i] 2^{i} + \\sum_{i=0}^{n-1} C_1[i] 2^{i+1}\\right) + \\left(\\sum_{i=0}^{n-1} S_2[i] 2^{i} + \\sum_{i=0}^{n-1} C_2[i] 2^{i+1}\\right)$\n让我们分析每一列 $k$ 的高度，它对应于权重为 $2^k$ 的位。我们将这个初始高度表示为 $h_k^{(1)}$。\n- 对于列 $k=0$：贡献者是 $S_1[0]$ 和 $S_2[0]$。因此，$h_0^{(1)} = 2$。\n- 对于列 $1 \\le k \\le n-1$：贡献者是 $S_1[k]$、$S_2[k]$（来自和项）和 $C_1[k-1]$、$C_2[k-1]$（来自进位项，它们是从列 $k-1$ 移位过来的）。因此，$h_k^{(1)} = 4$。\n- 对于列 $k=n$：贡献者是 $C_1[n-1]$ 和 $C_2[n-1]$。因此，$h_n^{(1)} = 2$。\n- 对于列 $k > n$：边界条件规定这些列包含零，所以 $h_k^{(1)} = 0$。\n\n第一级压缩前的初始高度分布为：\n$h_k^{(1)} = \\begin{cases} 2   \\text{if } k=0 \\text{ or } k=n \\\\ 4   \\text{if } 1 \\le k \\le n-1 \\\\ 0   \\text{otherwise} \\end{cases}$\n\n一个 $3:2$ 压缩器，或全加器，接收 3 个权重为 $2^k$ 的位，输出 1 个权重为 $2^k$ 的和位和 1 个权重为 $2^{k+1}$ 的进位位。进位不能在同一级使用的约束意味着我们可以将规约过程建模为离散的级别。\n设 $h_k^{(L)}$ 为第 $L$ 级输入处第 $k$ 列的高度。\n在第 $L$ 级中，第 $k$ 列使用的压缩器数量为 $c_k^{(L)} = \\lfloor h_k^{(L)}/3 \\rfloor$。\n这些压缩器产生 $c_k^{(L)}$ 个和位，留在第 $k$ 列，以及 $c_k^{(L)}$ 个进位位，移到第 $k+1$ 列。第 $k$ 列中未压缩的位数是 $h_k^{(L)} \\pmod 3$。\n传递到下一级的第 $k$ 列的位数是 $s_k^{(L)} = (h_k^{(L)} \\pmod 3) + c_k^{(L)}$。\n下一级 $L+1$ 输入处第 $k$ 列的高度是第 $k$ 列传递过来的位数与第 $k-1$ 列生成的进位数之和：\n$h_k^{(L+1)} = s_k^{(L)} + c_{k-1}^{(L)}$\n\n让我们应用这个过程，从 $L=1$ 开始。\n**第 1 级压缩：**\n首先，我们根据初始高度 $h_k^{(1)}$ 计算进位数 $c_k^{(1)}$ 和剩余和位数 $s_k^{(1)}$。\n$c_k^{(1)} = \\lfloor h_k^{(1)}/3 \\rfloor = \\begin{cases} 1   \\text{if } 1 \\le k \\le n-1 \\\\ 0   \\text{otherwise} \\end{cases}$\n$s_k^{(1)} = (h_k^{(1)} \\pmod 3) + c_k^{(1)} = \\begin{cases} (2 \\pmod 3) + 0 = 2   \\text{if } k=0 \\text{ or } k=n \\\\ (4 \\pmod 3) + 1 = 2   \\text{if } 1 \\le k \\le n-1 \\\\ 0   \\text{otherwise} \\end{cases}$\n\n现在，我们计算第 2 级输入的位高分布 $h_k^{(2)}$。\n$h_k^{(2)} = s_k^{(1)} + c_{k-1}^{(1)}$\n- $h_0^{(2)} = s_0^{(1)} + c_{-1}^{(1)} = 2 + 0 = 2$\n- $h_1^{(2)} = s_1^{(1)} + c_0^{(1)} = 2 + 0 = 2$\n- 对于 $2 \\le k \\le n-1$：$h_k^{(2)} = s_k^{(1)} + c_{k-1}^{(1)} = 2 + 1 = 3$。这对 $n \\ge 3$ 成立。如果 $n=2$，这个范围为空。\n- $h_n^{(2)} = s_n^{(1)} + c_{n-1}^{(1)} = 2 + 1 = 3$。\n- $h_{n+1}^{(2)} = s_{n+1}^{(1)} + c_{n}^{(1)} = 0 + 0 = 0$。\n\n第 2 级输入的位高分布 $h_k^{(2)}$ 为：\n$h_k^{(2)} = \\begin{cases} 2   \\text{if } k=0, 1 \\\\ 3   \\text{if } 2 \\le k \\le n \\\\ 0   \\text{otherwise} \\end{cases}$\n这对所有 $n \\ge 2$ 都有效。对于 $n=2$，范围 $2 \\le k \\le n$ 仅为 $k=2$，所以 $h_k^{(2)}$ 是 $\\{2, 2, 3, 0, \\ldots\\}$。\n由于 $\\max(h_k^{(2)}) = 3$，大于 $2$，规约尚未完成。至少还需要一个级别。因此，最小深度大于 $1$。\n\n**第 2 级压缩：**\n我们现在规约位高分布 $h_k^{(2)}$。\n$c_k^{(2)} = \\lfloor h_k^{(2)}/3 \\rfloor = \\begin{cases} 1   \\text{if } 2 \\le k \\le n \\\\ 0   \\text{otherwise} \\end{cases}$\n$s_k^{(2)} = (h_k^{(2)} \\pmod 3) + c_k^{(2)} = \\begin{cases} 2   \\text{if } k=0, 1 \\\\ 1   \\text{if } 2 \\le k \\le n \\\\ 0   \\text{otherwise} \\end{cases}$\n\n现在，我们计算第 3 级输入的位高分布 $h_k^{(3)}$。\n$h_k^{(3)} = s_k^{(2)} + c_{k-1}^{(2)}$\n- $h_0^{(3)} = s_0^{(2)} + c_{-1}^{(2)} = 2 + 0 = 2$\n- $h_1^{(3)} = s_1^{(2)} + c_0^{(2)} = 2 + 0 = 2$\n- $h_2^{(3)} = s_2^{(2)} + c_1^{(2)} = 1 + 0 = 1$\n- 对于 $3 \\le k \\le n$：$h_k^{(3)} = s_k^{(2)} + c_{k-1}^{(2)} = 1 + 1 = 2$。此范围对于 $n \\ge 3$ 非空。\n- $h_{n+1}^{(3)} = s_{n+1}^{(2)} + c_n^{(2)} = 0 + 1 = 1$。\n- 对于 $k \\ge n+2$：$h_k^{(3)} = s_k^{(2)} + c_{k-1}^{(2)} = 0 + 0 = 0$。\n\n第 2 级之后得到的位高分布 $h_k^{(3)}$ 为：\n$h_k^{(3)} = \\begin{cases} 2   \\text{if } k=0, 1 \\\\ 1   \\text{if } k=2 \\\\ 2   \\text{if } 3 \\le k \\le n \\\\ 1   \\text{if } k=n+1 \\\\ 0   \\text{otherwise} \\end{cases}$\n对于所有的 $k$ 值，$h_k^{(3)} \\le 2$。这意味着输出是进位保存格式，不需要进一步压缩。\n\n由于一级压缩不足而两级压缩足够，网络的最小深度为 $2$。这个结果对任何 $n \\ge 2$ 都成立。",
            "answer": "$$\\boxed{2}$$"
        }
    ]
}