{
    "hands_on_practices": [
        {
            "introduction": "高速乘法器的设计始于对不同架构之间基本性能权衡的理解。本练习通过对经典的阵列乘法器和更先进的华莱士树（Wallace Tree）乘法器进行延迟分析，量化了并行压缩技术带来的速度优势。通过计算具体延迟并比较两种设计的加速比，您将对决定乘法器性能的关键路径有更深刻的认识。",
            "id": "1977497",
            "problem": "在设计高速数字信号处理芯片时，一位工程师的任务是评估两种相互竞争的硬件乘法器架构，该乘法器用于计算两个$N$位无符号整数的乘积。每种架构的性能由其关键路径延迟决定，该延迟以基本门延迟$t_{gate}$为单位进行测量。\n\n以下是两种设计通用的组件延迟：\n- 用于生成部分积的双输入与门的延迟为 $t_{AND} = t_{gate}$。\n- 单个全加器（FA）从任意输入到任意输出的延迟为 $t_{FA} = 2.5 t_{gate}$。\n\n**架构A：阵列乘法器**\n这是一种由全加器网格组成的直接、规则的结构。部分积被生成，然后逐行相加。已知一个$N \\times N$阵列乘法器的关键路径延迟可以建模为：\n$$T_{Array} = t_{AND} + (2N-2)t_{FA}$$\n\n**架构B：华莱士树乘法器**\n该架构通过使用更复杂的并行方法来优先考虑速度。它包括两个主要阶段：\n1.  **归约阶段：** 将$N$行部分积压缩为仅两行。这是通过连续多层的保留进位加法器（CSA）实现的。一个CSA是一组并行的全加器，因此一层归约的延迟就是$t_{FA}$。每层中行数根据公式 $N_{i+1} = 2 \\cdot \\lfloor \\frac{N_i}{3} \\rfloor + (N_i \\pmod 3)$ 进行减少，其中$N_i$是第$i$层输入的行数。归约阶段从$N_0 = N$行开始，持续$k$层，直到输出行数$N_k$为2。此阶段的总延迟为$k \\times t_{FA}$。\n2.  **最终加法器阶段：** 使用一个高速的$(2N)$位超前进位加法器（CLA）对归约阶段产生的两行进行求和。一个$M$位CLA的延迟由以下公式给出：\n    $$T_{CLA}(M) = (2 \\log_{4}(M) + 2) t_{gate}$$\n华莱士树乘法器的总延迟$T_{Wallace}$是部分积生成延迟、总归约阶段延迟和最终加法器阶段延迟之和。\n\n对于$N=12$的具体实现，计算华莱士树乘法器相对于阵列乘法器的加速比。加速比定义为较慢架构的总延迟与较快架构的总延迟之比。将你的最终答案四舍五入到三位有效数字。",
            "solution": "问题要求计算在$N=12$的情况下，华莱士树乘法器与阵列乘法器相比的加速比。加速比定义为较长延迟与较短延迟的比值。我们必须首先计算每种架构的总延迟。\n\n**步骤1：计算阵列乘法器的延迟 ($T_{Array}$)**\n\n阵列乘法器的延迟由公式 $T_{Array} = t_{AND} + (2N-2)t_{FA}$ 给出。\n我们已知的参数是：\n$N=12$\n$t_{AND} = t_{gate}$\n$t_{FA} = 2.5 t_{gate}$\n\n将这些值代入公式：\n$$T_{Array} = t_{gate} + (2 \\cdot 12 - 2) \\cdot (2.5 t_{gate})$$\n$$T_{Array} = t_{gate} + (24 - 2) \\cdot (2.5 t_{gate})$$\n$$T_{Array} = t_{gate} + (22) \\cdot (2.5 t_{gate})$$\n$$T_{Array} = t_{gate} + 55 t_{gate}$$\n$$T_{Array} = 56 t_{gate}$$\n\n**步骤2：计算华莱士树乘法器的延迟 ($T_{Wallace}$)**\n\n华莱士树乘法器的总延迟是三个部分之和：部分积生成延迟、归约阶段延迟和最终加法器阶段延迟。\n$$T_{Wallace} = T_{PPgen} + T_{reduction} + T_{final\\_add}$$\n\n**第2a部分：部分积生成延迟 ($T_{PPgen}$)**\n部分积由与门生成。其延迟为：\n$$T_{PPgen} = t_{AND} = t_{gate}$$\n\n**第2b部分：归约阶段延迟 ($T_{reduction}$)**\n我们需要找到将$N=12$行归约到2行所需的归约层数$k$。我们使用给定的递推关系 $N_{i+1} = 2 \\cdot \\lfloor \\frac{N_i}{3} \\rfloor + (N_i \\pmod 3)$，从$N_0 = 12$开始。\n\n-   **第1层：** 输入为 $N_0 = 12$ 行。\n    $N_1 = 2 \\cdot \\lfloor \\frac{12}{3} \\rfloor + (12 \\pmod 3) = 2 \\cdot 4 + 0 = 8$ 行。\n-   **第2层：** 输入为 $N_1 = 8$ 行。\n    $N_2 = 2 \\cdot \\lfloor \\frac{8}{3} \\rfloor + (8 \\pmod 3) = 2 \\cdot 2 + 2 = 6$ 行。\n-   **第3层：** 输入为 $N_2 = 6$ 行。\n    $N_3 = 2 \\cdot \\lfloor \\frac{6}{3} \\rfloor + (6 \\pmod 3) = 2 \\cdot 2 + 0 = 4$ 行。\n-   **第4层：** 输入为 $N_3 = 4$ 行。\n    $N_4 = 2 \\cdot \\lfloor \\frac{4}{3} \\rfloor + (4 \\pmod 3) = 2 \\cdot 1 + 1 = 3$ 行。\n-   **第5层：** 输入为 $N_4 = 3$ 行。\n    $N_5 = 2 \\cdot \\lfloor \\frac{3}{3} \\rfloor + (3 \\pmod 3) = 2 \\cdot 1 + 0 = 2$ 行。\n\n当行数减少到2行时，归约停止，这发生在5层之后。因此，$k=5$。\n归约阶段的总延迟是单层延迟（$t_{FA}$）的$k$倍。\n$$T_{reduction} = k \\cdot t_{FA} = 5 \\cdot (2.5 t_{gate}) = 12.5 t_{gate}$$\n\n**第2c部分：最终加法器阶段延迟 ($T_{final\\_add}$)**\n最终的加法器是一个$(2N)$位的超前进位加法器（CLA）。对于$N=12$，加法器的位宽是$M = 2 \\cdot 12 = 24$位。\n延迟由公式 $T_{CLA}(M) = (2 \\log_{4}(M) + 2) t_{gate}$ 给出。\n代入$M=24$：\n$$T_{final\\_add} = (2 \\log_{4}(24) + 2) t_{gate}$$\n为了计算 $\\log_{4}(24)$，我们可以使用换底公式：$\\log_{b}(x) = \\frac{\\ln(x)}{\\ln(b)}$。\n$$\\log_{4}(24) = \\frac{\\ln(24)}{\\ln(4)} \\approx \\frac{3.17805}{1.38629} \\approx 2.2925$$\n现在，将这个值代回延迟公式：\n$$T_{final\\_add} \\approx (2 \\cdot 2.2925 + 2) t_{gate} = (4.585 + 2) t_{gate} = 6.585 t_{gate}$$\n\n**第2d部分：华莱士树总延迟**\n现在，将三部分的延迟相加：\n$$T_{Wallace} = T_{PPgen} + T_{reduction} + T_{final\\_add}$$\n$$T_{Wallace} \\approx (1 + 12.5 + 6.585) t_{gate} = 20.085 t_{gate}$$\n\n**步骤3：计算加速比**\n\n我们比较两个总延迟：\n$T_{Array} = 56 t_{gate}$\n$T_{Wallace} \\approx 20.085 t_{gate}$\n\n由于$T_{Array} > T_{Wallace}$，阵列乘法器是较慢的架构，而华莱士树乘法器是较快的架构。加速比是较慢延迟与较快延迟的比值。\n$$\\text{加速比} = \\frac{T_{Array}}{T_{Wallace}} \\approx \\frac{56 t_{gate}}{20.085 t_{gate}} \\approx 2.78815$$\n\n问题要求将最终答案四舍五入到三位有效数字。\n$$\\text{加速比} \\approx 2.79$$",
            "answer": "$$\\boxed{2.79}$$"
        },
        {
            "introduction": "在确定了并行压缩的优势之后，下一步是深入研究压缩树的具体实现算法。本练习将带您亲手操作一个 $24 \\times 24$ 位乘法器的部分积缩减过程，对比华莱士（Wallace）和达达（Dadda）这两种主流的缩减策略。您需要为第一级缩减计算所需的 $3{:}2$ 和 $2{:}1$ 压缩器数量，从而体会它们在硬件资源利用和设计策略上的根本差异。",
            "id": "4275975",
            "problem": "考虑一个有符号乘法单元，它在用于集成电路和电子设计自动化 (EDA) 的高速乘法器架构背景下，使用并行部分积阵列和压缩树实现一个 $24 \\times 24$ 位乘积。部分积列由 $k \\in \\{0,1,\\dots,46\\}$ 索引，其列高分布由 $h_k = \\min(k+1, 47-k)$ 给出，这对应于方形乘法器的部分积的三角形分布。\n\n对于第一规约级，考虑两种列压缩策略：\n- 一种 Wallace 方法，该方法在第一级内贪心地在每列中尽可能多地应用$3{:}2$压缩器（全加器），而不在该级使用任何$2{:}1$压缩器（半加器）。$3{:}2$压缩器将同一列中的三个输入位映射到同一列中的一个和位以及下一个更高有效列中的一个进位位。\n- 一种 Dadda 方法，该方法使用 Dadda 序列计算第一阶段最大列高上限$d$，然后最小化地应用$3{:}2$和$2{:}1$压缩器，以确保在第一级之后，每列的高度不超过$d$。在 Dadda 规约中，一个$3{:}2$压缩器将当前列的高度减少$2$并向下一列产生一个进位，而一个$2{:}1$压缩器将当前列的高度减少$1$并向下一列产生一个进位。在确定每列需要多少压缩器时，必须从最低有效列到最高有效列顺序地考虑该级内产生的进位。\n\n在每种方法下精确合成一个规约级，并计算该级所需的$3{:}2$和$2{:}1$规约的总数。将最终答案表示为一个包含四个数字的单行矩阵，排序为 $\\left(N_{3{:}2}^{\\text{Wallace}}, N_{2{:}1}^{\\text{Wallace}}, N_{3{:}2}^{\\text{Dadda}}, N_{2{:}1}^{\\text{Dadda}}\\right)$。无需四舍五入。无需单位。",
            "solution": "本题要求根据两种不同的策略（一种类 Wallace 方法和一种 Dadda 方法），计算一个 $24 \\times 24$ 乘法器在第一规约级中使用的 $3{:}2$ 和 $2{:}1$ 压缩器的数量。\n\n部分积阵列的初始列高分布由 $h_k = \\min(k+1, 47-k)$ 给出，其中列索引 $k \\in \\{0, 1, \\dots, 46\\}$。该阵列的最大高度出现在 $k=23$ 处，此时 $h_{23} = \\min(23+1, 47-23) = 24$。\n\n一个$3{:}2$压缩器（全加器）从列$k$接收$3$个输入位，在列$k$产生一个和位，并在列$k+1$产生一个进位位。这会将列$k$的高度减少$2$，并将列$k+1$的高度增加$1$。\n一个$2{:}1$压缩器（半加器）从列$k$接收$2$个输入位，在列$k$产生一个和位，并在列$k+1$产生一个进位位。这会将列$k$的高度减少$1$，并将列$k+1$的高度增加$1$。\n\n首先，我们分析 Wallace 方法。\n指定的 Wallace 策略是在一个级别内贪婪地在每列应用$3{:}2$压缩器以实现最大规约，而不在该级别使用任何$2{:}1$压缩器。\n对于初始高度为$h_k$的列$k$，可以应用的$3{:}2$压缩器数量为 $n_{3{:}2, k}^{\\text{Wallace}} = \\lfloor h_k / 3 \\rfloor$。\n题目说明不使用$2{:}1$压缩器，因此 $N_{2{:}1}^{\\text{Wallace}} = 0$。\n$3{:}2$压缩器的总数$N_{3{:}2}^{\\text{Wallace}}$是所有列的总和：\n$$N_{3{:}2}^{\\text{Wallace}} = \\sum_{k=0}^{46} n_{3{:}2, k}^{\\text{Wallace}} = \\sum_{k=0}^{46} \\left\\lfloor \\frac{h_k}{3} \\right\\rfloor$$\n列高分布$h_k$是对称的。我们可以将求和拆分为：\n$$N_{3{:}2}^{\\text{Wallace}} = \\sum_{k=0}^{23} \\left\\lfloor \\frac{k+1}{3} \\right\\rfloor + \\sum_{k=24}^{46} \\left\\lfloor \\frac{47-k}{3} \\right\\rfloor$$\n在第一个求和中，令$j=k+1$。当$k=0$时，$j=1$；当$k=23$时，$j=24$。求和变为 $\\sum_{j=1}^{24} \\lfloor j/3 \\rfloor$。\n这个和可以计算为 $3 \\times (1+2+3+4+5+6+7) + \\lfloor 24/3 \\rfloor = 3 \\times \\frac{7 \\times 8}{2} + 8 = 3 \\times 28 + 8 = 84 + 8 = 92$。\n在第二个求和中，令$j=47-k$。当$k=24$时，$j=23$；当$k=46$时，$j=1$。求和变为 $\\sum_{j=1}^{23} \\lfloor j/3 \\rfloor$。\n这个和是 $3 \\times (1+2+3+4+5+6+7) = 3 \\times 28 = 84$。\n因此，$3{:}2$压缩器的总数为：\n$$N_{3{:}2}^{\\text{Wallace}} = 92 + 84 = 176$$\n$2{:}1$压缩器的数量为：\n$$N_{2{:}1}^{\\text{Wallace}} = 0$$\n\n接下来，我们分析 Dadda 方法。\nDadda 策略要求将列高降低至不超过一个由 Dadda 序列确定的特定值$d$。该序列由 $d_0 = 2$ 和 $d_{j+1} = \\lfloor 1.5 d_j \\rfloor$ 定义。\n序列为 $d_0=2, d_1=3, d_2=4, d_3=6, d_4=9, d_5=13, d_6=19, d_7=28, \\dots$\n最大初始高度为$h_{\\max} = 24$。第一阶段的高度上限$d$是 Dadda 序列中小于$h_{\\max}$的最大成员。因此，我们有$d=19$。\n目标是最小化地应用压缩器，使得对于每个列$k$，规约后的最终高度最多为$19$。该过程从最低有效列（$k=0$）到最高有效列（$k=46$）顺序执行，并考虑前一列产生的进位。\n设$h_k$为列$k$的初始高度，$c_k$为从列$k-1$传入的进位位数。列$k$需要考虑的总高度为$H_k = h_k + c_k$。\n如果$H_k > 19$，我们必须应用压缩器。为实现最小化，我们使用$n_{3{:}2,k}$个全加器和$n_{2{:}1,k}$个半加器，其中$n_{3{:}2,k} = \\lfloor (H_k - 19)/2 \\rfloor$且$n_{2{:}1,k} = (H_k - 19) \\pmod 2$。生成到列$k+1$的进位数是$c_{k+1} = n_{3{:}2,k} + n_{2{:}1,k}$。\n\n我们现在从$c_0=0$开始，逐列进行计算。\n对于$k \\in \\{0, \\dots, 18\\}$，$h_k = k+1 \\le 19$。由于这些列的$c_k=0$，因此$H_k \\le 19$。不需要规约。$n_{3{:}2,k}=0, n_{2{:}1,k}=0, c_{k+1}=0$。\n对于$k=19$：$h_{19}=20, c_{19}=0 \\implies H_{19}=20$。$H_{19}-19 = 1$。$n_{3{:}2,19}=\\lfloor 1/2 \\rfloor = 0$，$n_{2{:}1,19}=1 \\pmod 2 = 1$。$c_{20}=0+1=1$。\n对于$k=20$：$h_{20}=21, c_{20}=1 \\implies H_{20}=22$。$H_{20}-19 = 3$。$n_{3{:}2,20}=\\lfloor 3/2 \\rfloor = 1$，$n_{2{:}1,20}=3 \\pmod 2 = 1$。$c_{21}=1+1=2$。\n对于$k=21$：$h_{21}=22, c_{21}=2 \\implies H_{21}=24$。$H_{21}-19 = 5$。$n_{3{:}2,21}=\\lfloor 5/2 \\rfloor = 2$，$n_{2{:}1,21}=5 \\pmod 2 = 1$。$c_{22}=2+1=3$。\n对于$k=22$：$h_{22}=23, c_{22}=3 \\implies H_{22}=26$。$H_{22}-19 = 7$。$n_{3{:}2,22}=\\lfloor 7/2 \\rfloor = 3$，$n_{2{:}1,22}=7 \\pmod 2 = 1$。$c_{23}=3+1=4$。\n对于$k=23$：$h_{23}=24, c_{23}=4 \\implies H_{23}=28$。$H_{23}-19 = 9$。$n_{3{:}2,23}=\\lfloor 9/2 \\rfloor = 4$，$n_{2{:}1,23}=9 \\pmod 2 = 1$。$c_{24}=4+1=5$。\n对于$k=24$：$h_{24}=23, c_{24}=5 \\implies H_{24}=28$。$H_{24}-19 = 9$。$n_{3{:}2,24}=\\lfloor 9/2 \\rfloor = 4$，$n_{2{:}1,24}=9 \\pmod 2 = 1$。$c_{25}=4+1=5$。\n对于$k=25$：$h_{25}=22, c_{25}=5 \\implies H_{25}=27$。$H_{25}-19 = 8$。$n_{3{:}2,25}=\\lfloor 8/2 \\rfloor = 4$，$n_{2{:}1,25}=8 \\pmod 2 = 0$。$c_{26}=4+0=4$。\n对于$k=26$：$h_{26}=21, c_{26}=4 \\implies H_{26}=25$。$H_{26}-19 = 6$。$n_{3{:}2,26}=\\lfloor 6/2 \\rfloor = 3$，$n_{2{:}1,26}=6 \\pmod 2 = 0$。$c_{27}=3+0=3$。\n对于$k=27$：$h_{27}=20, c_{27}=3 \\implies H_{27}=23$。$H_{27}-19 = 4$。$n_{3{:}2,27}=\\lfloor 4/2 \\rfloor = 2$，$n_{2{:}1,27}=4 \\pmod 2 = 0$。$c_{28}=2+0=2$。\n对于$k=28$：$h_{28}=19, c_{28}=2 \\implies H_{28}=21$。$H_{28}-19 = 2$。$n_{3{:}2,28}=\\lfloor 2/2 \\rfloor = 1$，$n_{2{:}1,28}=2 \\pmod 2 = 0$。$c_{29}=1+0=1$。\n对于$k=29$：$h_{29}=18, c_{29}=1 \\implies H_{29}=19$。由于$H_{29} \\le 19$，不需要规约。$n_{3{:}2,29}=0, n_{2{:}1,29}=0, c_{30}=0$。\n对于所有后续列$k>29$，$h_k  19$且$c_k = 0$，因此在此阶段不会发生进一步的规约。\n\nDadda 方法的压缩器总数：\n$N_{3{:}2}^{\\text{Dadda}} = \\sum_{k=0}^{46} n_{3{:}2,k} = 0+1+2+3+4+4+4+3+2+1 = 24$。\n$N_{2{:}1}^{\\text{Dadda}} = \\sum_{k=0}^{46} n_{2{:}1,k} = 1+1+1+1+1+1+0+0+0+0 = 6$。\n\n所需的四个数字是 $\\left(N_{3{:}2}^{\\text{Wallace}}, N_{2{:}1}^{\\text{Wallace}}, N_{3{:}2}^{\\text{Dadda}}, N_{2{:}1}^{\\text{Dadda}}\\right)$。\n$N_{3{:}2}^{\\text{Wallace}} = 176$。\n$N_{2{:}1}^{\\text{Wallace}} = 0$。\n$N_{3{:}2}^{\\text{Dadda}} = 24$。\n$N_{2{:}1}^{\\text{Dadda}} = 6$。\n结果是 $(176, 0, 24, 6)$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 176  0  24  6 \\end{pmatrix}}$$"
        },
        {
            "introduction": "理论上完美的乘法器会产生一个全精度的乘积，但在实际硬件设计中，为了节省面积和功耗，往往需要对结果进行截断。本练习探讨了这种截断所引入的量化误差，并分析了三种不同的处理方案：纯截断、偏差补偿和无偏舍入。通过计算和比较这些方案的平均误差、平均绝对误差和最坏情况误差，您将学会如何在性能和数值精度之间做出明智的权衡。",
            "id": "4275952",
            "problem": "考虑一个无符号 $32 \\times 32$ 并行乘法器，它使用高速部分积压缩网络（例如 Wallace 树）实现，生成一个精确的 $64$ 位乘积 $P$。为了减少关键路径延迟和功耗，该设计在最终的进位传播加法器之前，截断了乘积的 $k=8$ 个最低有效位（LSB），从而得到一个 $56$ 位的截断乘积。截断误差定义为 $e = \\hat{P} - P$，其中 $\\hat{P}$ 是最终得到的（近似）乘积。假设操作数在其 $32$ 位范围内均匀分布，因此被丢弃的余数可以很好地建模为均匀分布，并且与保留的位相独立。\n\n分析三种方案：\n- 纯截断：无校正。\n- 偏差补偿：在截断前，加上一个等于截断量子一半的恒定偏移量。\n- 无偏向的向最近偶数舍入：解决半量子边界问题，使得平局情况下的期望误差为零。\n\n对被丢弃的 $8$ 位余数集合，使用以下误差度量定义：\n- 平均误差 $\\mu = \\mathbb{E}[e]$。\n- 平均绝对误差 $\\eta = \\mathbb{E}[|e|]$。\n- 最坏情况误差幅度 $\\epsilon_{\\max} = \\max |e|$。\n\n将 $64$ 位精确乘积建模为 $P = 256 M + d$，其中 $M \\in \\mathbb{Z}$ 是保留的 $56$ 位部分，而 $d \\in \\{0,1,\\dots,255\\}$ 是被丢弃的余数。对于偏差补偿，在截断前的路径中加上常数 $C = 128$。对于向最近偶数舍入的无偏舍入，假设 $M$ 的奇偶性是等可能的，因此平局情况贡献的平均误差为零。\n\n计算每种方案的 $\\mu$、$\\eta$ 和 $\\epsilon_{\\max}$ 的精确值，以原始乘积的整数单位表示（即，以 $P$ 的最低有效位的数量计）。按以下顺序将你的最终答案表示为九个数字：纯截断 $(\\mu, \\eta, \\epsilon_{\\max})$、偏差补偿 $(\\mu, \\eta, \\epsilon_{\\max})$、无偏舍入 $(\\mu, \\eta, \\epsilon_{\\max})$。无需进行舍入。",
            "solution": "该问题要求分析三种不同定点乘积截断方案的误差特性。精确的 $64$ 位乘积 $P$ 被建模为 $P = 256M + d$，其中 $M$ 是要保留的高 $56$ 位部分，$d$ 是要丢弃的低 $8$ 位余数。$d$ 的值是集合 $\\{0, 1, 2, \\dots, 255\\}$ 中的一个整数。根据题目描述，我们将 $d$ 建模为在此集合上均匀分布的离散随机变量。其概率质量函数为 $p(d) = \\frac{1}{256}$，适用于其定义域中的任何 $d$。误差定义为 $e = \\hat{P} - P$，其中 $\\hat{P}$ 是近似的截断乘积。所有误差度量均以原始乘积 $P$ 的最低有效位 (LSB) 为单位计算，其权重为 $1$。\n\n余数的任意函数 $f(d)$ 的期望由对所有可能的 $d$ 值求和给出：\n$$ \\mathbb{E}[f(d)] = \\sum_{d=0}^{255} f(d) p(d) = \\frac{1}{256} \\sum_{d=0}^{255} f(d) $$\n我们将使用前 $n$ 个整数求和的公式：$\\sum_{i=1}^{n} i = \\frac{n(n+1)}{2}$。可能的余数值之和为：\n$$ \\sum_{d=0}^{255} d = \\frac{255(255+1)}{2} = \\frac{255 \\times 256}{2} = 32640 $$\n\n我们依次分析每种方案，以找出平均误差 $\\mu = \\mathbb{E}[e]$、平均绝对误差 $\\eta = \\mathbb{E}[|e|]$ 和最坏情况误差幅度 $\\epsilon_{\\max} = \\max|e|$。\n\n**方案 1：纯截断**\n在纯截断中，8 个 LSB 被直接丢弃。这等同于对乘积除以 $2^8 = 256$ 的结果取底。保留的部分是 $M$。\n近似乘积为 $\\hat{P} = 256M$。\n因此误差 $e$ 为：\n$$ e = \\hat{P} - P = 256M - (256M + d) = -d $$\n我们现在可以计算误差度量：\n- **平均误差 ($\\mu_1$)**：\n$$ \\mu_1 = \\mathbb{E}[e] = \\mathbb{E}[-d] = -\\mathbb{E}[d] = -\\frac{1}{256} \\sum_{d=0}^{255} d = -\\frac{32640}{256} = -127.5 $$\n- **平均绝对误差 ($\\eta_1$)**：由于 $d \\ge 0$，因此 $|e| = |-d| = d$。\n$$ \\eta_1 = \\mathbb{E}[|e|] = \\mathbb{E}[d] = \\frac{1}{256} \\sum_{d=0}^{255} d = 127.5 $$\n- **最坏情况误差幅度 ($\\epsilon_{\\max, 1}$)**：\n$$ \\epsilon_{\\max, 1} = \\max_{d \\in \\{0, \\dots, 255\\}} |e| = \\max_{d} |-d| = \\max_{d} d = 255 $$\n\n**方案 2：偏差补偿**\n在截断前，向乘积添加一个恒定偏移量 $C=128$。待处理的值为 $P' = P + 128 = 256M + d + 128$。\n近似乘积为 $\\hat{P} = 256 \\times \\lfloor \\frac{P'}{256} \\rfloor = 256 \\times \\lfloor \\frac{256M + d + 128}{256} \\rfloor = 256 \\times \\lfloor M + \\frac{d+128}{256} \\rfloor$。\n取底函数的行为取决于 $d$：\n- 如果 $0 \\le d \\le 127$，那么 $0.5 \\le \\frac{d+128}{256}  1$。因此，$\\lfloor M + \\frac{d+128}{256} \\rfloor = M$。\n  $\\hat{P} = 256M$，误差为 $e = 256M - (256M+d) = -d$。\n- 如果 $128 \\le d \\le 255$，那么 $1 \\le \\frac{d+128}{256}  1.5$。因此，$\\lfloor M + \\frac{d+128}{256} \\rfloor = M+1$。\n  $\\hat{P} = 256(M+1)$，误差为 $e = 256(M+1) - (256M+d) = 256-d$。\n我们通过对 $d$ 的这两个范围求和来计算度量：\n- **平均误差 ($\\mu_2$)**：\n$$ \\mu_2 = \\frac{1}{256} \\left( \\sum_{d=0}^{127} (-d) + \\sum_{d=128}^{255} (256-d) \\right) $$\n第一个和是 $\\sum_{d=0}^{127} (-d) = -\\frac{127 \\times 128}{2} = -8128$。\n设 $j=256-d$。对于第二个和，当 $d$ 从 $128$ 变为 $255$ 时，$j$ 从 $128$ 变为 $1$。所以 $\\sum_{d=128}^{255} (256-d) = \\sum_{j=1}^{128} j = \\frac{128 \\times 129}{2} = 8256$。\n$$ \\mu_2 = \\frac{1}{256} (-8128 + 8256) = \\frac{128}{256} = 0.5 $$\n- **平均绝对误差 ($\\eta_2$)**：\n$$ \\eta_2 = \\frac{1}{256} \\left( \\sum_{d=0}^{127} |-d| + \\sum_{d=128}^{255} |256-d| \\right) = \\frac{1}{256} \\left( \\sum_{d=0}^{127} d + \\sum_{d=128}^{255} (256-d) \\right) $$\n第一个和是 $\\frac{127 \\times 128}{2} = 8128$。第二个和是 $8256$。\n$$ \\eta_2 = \\frac{1}{256} (8128 + 8256) = \\frac{16384}{256} = 64 $$\n- **最坏情况误差幅度 ($\\epsilon_{\\max, 2}$)**：\n当 $d \\in \\{0, \\dots, 127\\}$ 时，误差的幅度为 $|e|=d$，其最大值为 $127$。\n当 $d \\in \\{128, \\dots, 255\\}$ 时，误差的幅度为 $|e|=256-d$，其最大值为 $256-128 = 128$。\n$$ \\epsilon_{\\max, 2} = \\max(127, 128) = 128 $$\n\n**方案 3：无偏向的向最近偶数舍入**\n该方案将 $P/256 = M + d/256$ 舍入到最近的整数，并对平局情况有特殊规则。\n- 如果 $d/256  0.5$（即 $0 \\le d \\le 127$），我们向下舍入。$\\hat{P} = 256M$，所以 $e = -d$。\n- 如果 $d/256 > 0.5$（即 $129 \\le d \\le 255$），我们向上舍入。$\\hat{P} = 256(M+1)$，所以 $e = 256-d$。\n- 如果 $d/256 = 0.5$（即 $d=128$），则为平局。我们舍入到最近的偶数。\n  - 如果 $M$ 是偶数，我们向下舍入到 $M$。$\\hat{P}=256M$，所以 $e = -128$。\n  - 如果 $M$ 是奇数，我们向上舍入到 $M+1$。$\\hat{P}=256(M+1)$，所以 $e = 256-128 = 128$。\n根据题目， $M$ 为偶数或奇数的可能性相等，因此 $P(M \\text{ 是偶数}) = P(M \\text{ 是奇数}) = 0.5$。\n- **平均误差 ($\\mu_3$)**：对于 $d=128$ 的情况，误差现在取决于 $M$。我们计算关于 $d$ 和 $M$ 的期望。\n$$ \\mu_3 = \\mathbb{E}_{d,M}[e] = \\frac{1}{256} \\left( \\sum_{d=0, d \\neq 128}^{255} e(d) + \\mathbb{E}_M[e(d=128, M)] \\right) $$\n$\\mathbb{E}_M[e(d=128, M)] = (-128) P(M \\text{ 是偶数}) + (128) P(M \\text{ 是奇数}) = -128(0.5) + 128(0.5) = 0$。\n和为 $\\sum_{d=0}^{127} (-d) + \\sum_{d=129}^{255} (256-d)$。\n第一部分是 $-8128$。对于第二部分，设 $j=256-d$。当 $d$ 从 $129$ 变为 $255$ 时，$j$ 从 $127$ 变为 $1$。所以 $\\sum_{j=1}^{127} j = \\frac{127 \\times 128}{2} = 8128$。\n$$ \\mu_3 = \\frac{1}{256} (-8128 + 0 + 8128) = 0 $$\n- **平均绝对误差 ($\\eta_3$)**：\n$$ \\eta_3 = \\frac{1}{256} \\left( \\sum_{d=0, d \\neq 128}^{255} |e(d)| + \\mathbb{E}_M[|e(d=128, M)|] \\right) $$\n$\\mathbb{E}_M[|e(d=128, M)|] = |-128| P(M \\text{ 是偶数}) + |128| P(M \\text{ 是奇数}) = 128(0.5) + 128(0.5) = 128$。\n和为 $\\sum_{d=0}^{127} d + \\sum_{d=129}^{255} (256-d) = 8128 + 8128 = 16256$。\n$$ \\eta_3 = \\frac{1}{256} (16256 + 128) = \\frac{16384}{256} = 64 $$\n- **最坏情况误差幅度 ($\\epsilon_{\\max, 3}$)**：\n误差幅度为：当 $d \\in \\{0, \\dots, 127\\}$ 时为 $|e|=d$ (最大值 $127$)，当 $d \\in \\{129, \\dots, 255\\}$ 时为 $|e|=256-d$ (最大值 $127$)，当 $d=128$ 时为 $|e|=128$。\n$$ \\epsilon_{\\max, 3} = \\max(127, 128) = 128 $$\n\n结果总结：\n- 纯截断：$(\\mu_1, \\eta_1, \\epsilon_{\\max, 1}) = (-127.5, 127.5, 255)$。\n- 偏差补偿：$(\\mu_2, \\eta_2, \\epsilon_{\\max, 2}) = (0.5, 64, 128)$。\n- 无偏舍入：$(\\mu_3, \\eta_3, \\epsilon_{\\max, 3}) = (0, 64, 128)$。\n这九个值构成了最终答案。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} -127.5  127.5  255  0.5  64  128  0  64  128 \\end{pmatrix} } $$"
        }
    ]
}