{
    "hands_on_practices": [
        {
            "introduction": "理解内存系统性能的第一步，是对其基本操作进行定量分析。第一个练习将挑战您将DRAM的物理架构——如bank、行大小和数据通路——与传输数据块的高级任务联系起来。通过计算所需的命令数量并估算其所需时间 ，您将为分析DRAM吞吐量和命令开销建立一个基础模型。",
            "id": "4255794",
            "problem": "一个动态随机存取存储器 (DRAM) 系统有 $8$ 个存储体 (bank)，行大小为 $8\\,\\mathrm{KB}$，数据总线宽度为 $x16$，突发长度为 $\\mathrm{BL}8$。在开放页策略下，内存控制器打开一个行，并在关闭该行之前向其发出多个列命令。假设控制器将一个连续的 $64\\,\\mathrm{KB}$ 传输映射到各个存储体，以最小化行激活次数，且每个存储体最多打开一个行，并假设 $1\\,\\mathrm{KB} = 1024\\,\\mathrm{bytes}$。每个读命令返回的数据突发量等于总线宽度和突发长度的乘积。行至列延迟 ($t_{RCD}$) 为 $14$ 个周期，列至列延迟 ($t_{CCD}$) 为 $4$ 个周期。忽略其他时序约束（如激活到激活间距、总线转换和四激活窗口），并假设命令总线上每个周期可以发出一个命令。\n\n从 DRAM 突发传输和开放页调度的基本原理出发，计算传输 $64\\,\\mathrm{KB}$ 数据所需的激活 ($\\mathrm{ACT}$) 命令和读取 ($\\mathrm{READ}$) 命令的数量，并估算从发出第一个命令的周期到发出最后一个 $\\mathrm{READ}$ 命令的周期（含两者）在命令总线上消耗的总命令周期数。将总周期数表示为周期的整数计数。请以三个值的形式提供最终答案：$\\mathrm{ACT}$ 命令的数量、$\\mathrm{READ}$ 命令的数量以及总命令周期数。",
            "solution": "该问题要求计算在特定条件下，从 DRAM 系统传输一个连续的 $64\\,\\mathrm{KB}$ 数据块所需的激活 ($\\mathrm{ACT}$) 命令数量、读取 ($\\mathrm{READ}$) 命令数量以及总命令周期数。\n\n### 步骤1：问题陈述的初步验证\n\n**逐字提取的已知条件：**\n-   存储体数量：$8$\n-   行大小：$8\\,\\mathrm{KB}$\n-   数据总线宽度：$x16$\n-   突发长度：$\\mathrm{BL}8$\n-   内存策略：开放页\n-   总数据传输大小：$64\\,\\mathrm{KB}$\n-   数据映射：连续的 $64\\,\\mathrm{KB}$ 传输跨存储体映射，以最小化行激活次数，每个存储体最多打开一个行。\n-   单位换算：$1\\,\\mathrm{KB} = 1024\\,\\mathrm{bytes}$\n-   行至列延迟 ($t_{RCD}$): $14$ 个周期\n-   列至列延迟 ($t_{CCD}$): $4$ 个周期\n-   命令总线速率：每个周期可发出一个命令\n-   忽略的约束：其他时序约束（如激活到激活间距、总线转换和四激活窗口）。\n\n**验证评估：**\n该问题在科学上基于 DRAM 操作原理和内存控制器设计，这些是计算机体系结构和集成电路工程的核心主题。所有使用的术语（例如，存储体 (banks)、突发长度 (burst length)、$t_{RCD}$、$t_{CCD}$）都是该领域的标准术语。所提供的参数对于一个简化模型是符合实际的，并且明确指示忽略某些复杂的时序约束，使得问题定义良好且可解。目标被清晰地陈述：计算三个特定的量。问题是自洽的，没有矛盾或逻辑缺陷。\n\n**结论：**该问题有效。\n\n### 步骤2：计算所需的 READ 命令数量\n\n首先，我们确定单个 $\\mathrm{READ}$ 命令传输的数据量。这个数据量是数据总线宽度和突发长度的乘积。\n\n数据总线宽度为 $x16$，意味着每次传输 $16$ 位。转换为字节：\n$$ \\text{总线宽度 (字节)} = \\frac{16\\,\\mathrm{bits}}{8\\,\\mathrm{bits/byte}} = 2\\,\\mathrm{bytes} $$\n突发长度 ($\\mathrm{BL}$) 为 $8$，意味着一个 $\\mathrm{READ}$ 命令会引发一次包含 $8$ 个连续数据传输的突发。\n每个 $\\mathrm{READ}$ 命令的总数据量是：\n$$ \\text{每个 READ 的数据量} = (\\text{总线宽度}) \\times (\\text{突发长度}) = 2\\,\\mathrm{bytes} \\times 8 = 16\\,\\mathrm{bytes} $$\n要传输的总数据量是 $64\\,\\mathrm{KB}$。使用给定的转换关系，$1\\,\\mathrm{KB} = 1024\\,\\mathrm{bytes}$：\n$$ \\text{总数据量} = 64\\,\\mathrm{KB} \\times 1024\\,\\mathrm{bytes/KB} = 65536\\,\\mathrm{bytes} $$\n所需的 $\\mathrm{READ}$ 命令总数是总数据大小除以每个命令传输的数据量：\n$$ N_{\\mathrm{READ}} = \\frac{\\text{总数据量}}{\\text{每个 READ 的数据量}} = \\frac{65536\\,\\mathrm{bytes}}{16\\,\\mathrm{bytes/READ}} = 4096\\,\\text{个命令} $$\n\n### 步骤3：计算所需的 ACTIVATE 命令数量\n\n问题陈述，连续的 $64\\,\\mathrm{KB}$ 数据块被映射到各个存储体以最小化行激活次数，每个存储体最多打开一个行。系统有 $8$ 个存储体。最小化激活次数的最有效映射方式是将数据均匀分布到所有可用的存储体上。\n\n映射到每个存储体的数据量是：\n$$ \\text{每个存储体的数据量} = \\frac{\\text{总数据量}}{\\text{存储体数量}} = \\frac{64\\,\\mathrm{KB}}{8} = 8\\,\\mathrm{KB} $$\nDRAM 的行大小给定为 $8\\,\\mathrm{KB}$。由于映射到每个存储体的数据量（$8\\,\\mathrm{KB}$）等于单个行的大小（$8\\,\\mathrm{KB}$），因此每个存储体的全部数据部分都可以从仅一个行中访问。\n\n在开放页策略下，通过一个 $\\mathrm{ACTIVATE}$ ($\\mathrm{ACT}$) 命令来打开一个行。要访问所有 $8$ 个存储体中的数据，我们必须在每个存储体中各打开一个行。\n因此，$\\mathrm{ACT}$ 命令的数量是：\n$$ N_{\\mathrm{ACT}} = 8\\,\\text{个命令} $$\n\n### 步骤4：估算总命令周期数\n\n我们需要确定从发出第一个命令到发出最后一个 $\\mathrm{READ}$ 命令的总时间（以周期为单位）。我们假设第一个命令在周期 $0$ 发出。\n\n内存控制器必须首先激活必要的行。由于问题指示我们忽略激活间的时序约束（如 $t_{RRD}$ 和 $t_{FAW}$），并且命令总线可以在每个周期发出一个命令，因此 $8$ 个 $\\mathrm{ACT}$ 命令可以在连续的周期内发出。\n- 周期 $0$：$\\mathrm{ACT}$ 存储体 $0$\n- 周期 $1$：$\\mathrm{ACT}$ 存储体 $1$\n- ...\n- 周期 $7$：$\\mathrm{ACT}$ 存储体 $7$\n\n对一个新激活的行发出的第一个 $\\mathrm{READ}$ 命令，只能在相应的 $\\mathrm{ACT}$ 命令发出并经过行至列延迟 $t_{RCD} = 14$ 个周期之后才能发出。最早的 $\\mathrm{ACT}$ 命令是在周期 $0$ 发出的（针对存储体 $0$）。因此，可以向存储体 $0$ 发出 $\\mathrm{READ}$ 命令的最早时间是周期 $0 + t_{RCD} = 14$。这将是整个序列中发出的第一个 $\\mathrm{READ}$ 命令。\n\n$$ \\text{第一个 READ 的周期} = 14 $$\n\n在第一个 $\\mathrm{READ}$ 之后，后续的 $\\mathrm{READ}$ 命令（到任何存储体）之间由列至列延迟 $t_{CCD} = 4$ 个周期分隔。由于 $t_{CCD} = 4$ 大于命令总线速率（1 命令/周期），$t_{CCD}$ 是发出 $\\mathrm{READ}$ 命令的限制因素。每隔 $4$ 个周期可以发出一个新的 $\\mathrm{READ}$ 命令。\n\n我们总共需要发出 $N_{\\mathrm{READ}} = 4096$ 个命令。第 $n$ 个 $\\mathrm{READ}$ 命令的周期数 $C_{\\mathrm{READ}}(n)$ 构成一个等差数列：\n$$ C_{\\mathrm{READ}}(n) = (\\text{第一个 READ 的周期}) + (n-1) \\times t_{CCD} $$\n我们需要找到最后一个（即第 $4096$ 个）$\\mathrm{READ}$ 命令的周期数。\n$$ C_{\\mathrm{READ}}(4096) = 14 + (4096 - 1) \\times 4 $$\n$$ C_{\\mathrm{READ}}(4096) = 14 + 4095 \\times 4 $$\n$$ C_{\\mathrm{READ}}(4096) = 14 + 16380 = 16394 $$\n最后一个 $\\mathrm{READ}$ 命令在周期 $16394$ 发出。\n\n问题要求的是从第一个命令发出的周期（周期 $0$）到最后一个 $\\mathrm{READ}$ 命令发出的周期（周期 $16394$）所消耗的总命令周期数，包含首尾。这个持续时间计算如下：\n$$ \\text{总周期数} = (\\text{最后一个周期}) - (\\text{第一个周期}) + 1 $$\n$$ \\text{总周期数} = 16394 - 0 + 1 = 16395 $$\n\n最终的三个值是：\n-   $\\mathrm{ACT}$ 命令数量：$8$\n-   $\\mathrm{READ}$ 命令数量：$4096$\n-   总命令周期：$16395$",
            "answer": "$$ \\boxed{\\begin{pmatrix} 8 & 4096 & 16395 \\end{pmatrix}} $$"
        },
        {
            "introduction": "高性能内存控制器不仅要清楚发出“什么”命令，更要精通“何时”发出。本练习将从静态计算转向命令调度的艺术，您必须在一系列复杂的时间约束（如$t_{RRD}$和$t_{FAW}$）中进行权衡 。您的目标是构建一个最优的命令序列，亲身体验对于最小化延迟至关重要的底层优化。",
            "id": "4255759",
            "problem": "内存控制器通过共享的命令/地址总线向双倍数据速率同步动态随机存取存储器（DDR SDRAM）设备发出命令，该总线每个时钟周期最多可传输一个命令。考虑四个存储体（bank），每个存储体操作不同的行。控制器必须向不同的存储体发出四个激活（ACTIVATE, ACT）命令，以及两个读取（READ）命令，这两个 READ 命令分别发往被前两个 ACT 命令激活的存储体。时间线从周期 $0$ 开始，此时所有存储体都已预充电，总线处于空闲状态。仅应用以下时序约束；忽略存储体组约束、数据总线突发长度、总线转换以及下面未列出的任何时序。\n\n- 行至列延迟（$t_{RCD}$）：对一个存储体发出 ACT 命令后，最早可以在 $t_{RCD}$ 个周期后对该存储体发出 READ 命令。\n- 行预充电时间（$t_{RP}$）：发出 PRECHARGE 命令后预充电一个存储体的最短时间；本任务中不需要 PRECHARGE 命令，但为完整起见提供了该参数。\n- 行有效时间（$t_{RAS}$）：在预充电前，行必须保持有效的最短时间；同样，本任务中不需要 PRECHARGE 命令，但为完整起见提供了该参数。\n- 行至行延迟（$t_{RRD}$）：向不同存储体发出 ACT 命令之间的最短时间。\n- 四激活窗口（$t_{FAW}$）：在任何长度为 $t_{FAW}$ 个周期的滚动窗口内，最多只能发出四个 ACT 命令。\n- 列至列延迟（$t_{CCD}$）：连续的列命令（例如，READ 到 READ）之间的最短时间，无论存储体是否相同。\n\n给定 $t_{RCD}=14$, $t_{RP}=14$, $t_{RAS}=34$, $t_{RRD}=6$, $t_{FAW}=30$, 以及 $t_{CCD}=4$（所有单位均为周期）。两个 READ 命令必须分别访问由第一个和第二个 ACT 命令激活的行。请构建一个有效的命令调度，在满足上述约束的同时，最小化命令总线上的空闲周期。\n\n在一个直到该时间点都最小化命令总线空闲周期的最优调度下，第二个 READ 命令可以被发出的最早周期索引是多少？以整数形式表示您的答案（单位为周期，无需四舍五入）。",
            "solution": "用户希望找到向 DDR SDRAM 设备发出的两个所需 READ 命令中，第二个命令可以被发出的最早周期。该调度必须是最优的，意味着在发出最后一个命令之前，它能最小化命令总线上的空闲周期，同时遵守所有指定的时序约束。\n\n首先，我们确定需要调度的命令序列。问题要求向四个不同的存储体发出四个激活（ACTIVATE, ACT）命令，然后是两个读取（READ）命令。READ 命令必须针对由第一个和第二个 ACT 命令激活的存储体。让我们将这些存储体表示为 $B_0, B_1, B_2, B_3$。我们将分别为这些存储体调度命令 `ACT`$_0$、`ACT`$_1$、`ACT`$_2$、`ACT`$_3$。因此，READ 命令将是 `READ`$_0$ 和 `READ`$_1$。时间线从周期 $0$ 开始。\n\n调度策略将是贪心策略：在任何给定的时钟周期，如果命令总线空闲，并且至少有一个命令的时序依赖关系已满足，我们就会发出该命令。这个策略自然地满足了最小化总线空闲周期的要求。\n\n给定的时序参数是：\n- 行至列延迟：$t_{RCD} = 14$ 个周期\n- 行至行延迟：$t_{RRD} = 6$ 个周期\n- 四激活窗口：$t_{FAW} = 30$ 个周期\n- 列至列延迟：$t_{CCD} = 4$ 个周期\n参数 $t_{RP}=14$ 和 $t_{RAS}=34$ 在此任务中不相关，因为没有发出 PRECHARGE 命令。总线每个周期最多能接受一个命令。\n\n令 $C(cmd)$ 表示命令 $cmd$ 被发出的周期索引。\n\n**步骤 1：调度 ACTIVATE 命令**\n四个 ACT 命令必须向四个不同的存储体发出。管理它们之间间隔的主要约束是行至行延迟，$t_{RRD}$。\n1.  第一个命令 `ACT`$_0$ 可以在最早的可能时间发出，即周期 $0$。\n    $C(\\text{ACT}_0) = 0$。\n2.  第二个命令 `ACT`$_1$ 必须在 `ACT`$_0$ 之后至少 $t_{RRD}$ 个周期发出。\n    $C(\\text{ACT}_1) \\geq C(\\text{ACT}_0) + t_{RRD} = 0 + 6 = 6$。\n    为最小化空闲时间，我们将 `ACT`$_1$ 安排在最早可能的周期：$C(\\text{ACT}_1) = 6$。\n3.  同样，`ACT`$_2$ 必须在 `ACT`$_1$ 之后至少 $t_{RRD}$ 个周期发出。\n    $C(\\text{ACT}_2) \\geq C(\\text{ACT}_1) + t_{RRD} = 6 + 6 = 12$。\n    我们将其安排在 $C(\\text{ACT}_2) = 12$。\n4.  最后，`ACT`$_3$ 必须在 `ACT`$_2$ 之后至少 $t_{RRD}$ 个周期发出。\n    $C(\\text{ACT}_3) \\geq C(\\text{ACT}_2) + t_{RRD} = 12 + 6 = 18$。\n    我们将其安排在 $C(\\text{ACT}_3) = 18$。\n\n这得出了 ACT 命令的以下调度：\n- `ACT`$_0$ 在周期 $0$\n- `ACT`$_1$ 在周期 $6$\n- `ACT`$_2$ 在周期 $12$\n- `ACT`$_3$ 在周期 $18$\n\n我们必须根据四激活窗口约束（$t_{FAW}$）来验证这一点。该约束规定，在任何长度为 $t_{FAW}=30$ 个周期的滚动窗口内，最多只能发出四个 ACT 命令。我们的四个 ACT 命令在周期 $0, 6, 12, 18$ 发出。第一个和第四个 ACT 之间经过的时间是 $C(\\text{ACT}_3) - C(\\text{ACT}_0) = 18 - 0 = 18$ 个周期。由于我们总共只发出四个 ACT 命令，任何后续的 ACT 命令都需要遵守由前四个命令建立的窗口。例如，一个假设的第五个 ACT 命令 `ACT`$_4$ 不能在周期 30 之前发出，因为 $C(\\text{ACT}_4) - C(\\text{ACT}_1)$ 需要 $\\ge t_{FAW}$。因为我们只有四个 ACT 命令，所以我们的调度对于 $t_{FAW}$ 是有效的。\n\n**步骤 2：调度 READ 命令**\n我们需要调度 `READ`$_0$（到存储体 $B_0$）和 `READ`$_1$（到存储体 $B_1$）。\n\n首先，让我们根据行至列延迟 $t_{RCD}$ 来确定每个 READ 命令的最早准备就绪时间。\n-   `READ`$_0$ 只有在对应的存储体被激活并且经过了 $t_{RCD}$ 时间后才能发出。\n    $C(\\text{READ}_0) \\geq C(\\text{ACT}_0) + t_{RCD} = 0 + 14 = 14$。\n    所以，`READ`$_0$ 在周期 $14$ 或之后准备就绪。\n-   `READ`$_1$ 的准备就绪时间也以类似方式确定。\n    $C(\\text{READ}_1) \\geq C(\\text{ACT}_1) + t_{RCD} = 6 + 14 = 20$。\n    所以，`READ`$_1$ 在周期 $20$ 或之后准备就绪。\n\n现在，我们必须将这些命令放置在命令总线上，同时遵守它们的准备就绪时间和总线可用性。\n-   我们可以发出 `READ`$_0$ 的最早周期是周期 $14$。命令总线在周期 $14$ 是可用的（前一个命令是周期 $12$ 的 `ACT`$_2$）。因此，我们将 `READ`$_0$ 安排在它可能的最早时间，以最小化空闲周期：\n    $C(\\text{READ}_0) = 14$。\n\n-   接下来，我们调度 `READ`$_1$。它的发出时间受两个因素约束：\n    1.  它自身基于 $t_{RCD}$ 的准备就绪时间：$C(\\text{READ}_1) \\geq 20$。\n    2.  相对于前一个发出的 READ 命令（`READ`$_0$）的列至列延迟 $t_{CCD}$。\n        $C(\\text{READ}_1) \\geq C(\\text{READ}_0) + t_{CCD} = 14 + 4 = 18$。\n\n    为了满足这两个约束，`READ`$_1$ 的发出时间必须大于或等于这两个下界的最大值：\n    $C(\\text{READ}_1) \\geq \\max(20, 18) = 20$。\n\n    因此，发出 `READ`$_1$ 的最早可能周期是 $20$。我们必须检查命令总线在周期 $20$ 是否可用。到目前为止的命令调度是：\n    - 周期 $0$: `ACT`$_0$\n    - 周期 $6$: `ACT`$_1$\n    - 周期 $12$: `ACT`$_2$\n    - 周期 $14$: `READ`$_0$\n    - 周期 $18$: `ACT`$_3$\n    总线在周期 $20$ 确实是空闲的。因此，我们可以在此时调度 `READ`$_1$。\n    $C(\\text{READ}_1) = 20$。\n\n这构成了一个完整且有效的调度，它遵循了贪心的、最小化空闲的策略。对 $C(\\text{READ}_1)$ 的下界分析表明，更早的时间是不可能的。最终的调度是：\n- 周期 $0$: `ACT`$_0$\n- 周期 $6$: `ACT`$_1$\n- 周期 $12$: `ACT`$_2$\n- 周期 $14$: `READ`$_0$\n- 周期 $18$: `ACT`$_3$\n- 周期 $20$: `READ`$_1$\n\n问题询问第二个 READ 命令可以被发出的最早周期索引。根据我们的最优调度，这是周期 $20$。",
            "answer": "$$\\boxed{20}$$"
        },
        {
            "introduction": "现实世界中的内存访问模式是动态且不可预测的，这要求控制器能够实时做出智能的调度决策。最后一个练习模拟了这种动态环境，要求您将经典的“就绪者优先，先到先服务”(FR-FCFS)策略应用于请求队列 。通过追踪控制器的决策和DRAM bank的状态，您将通过计算行缓冲区命中率，直接衡量一个调度策略的有效性。",
            "id": "4255781",
            "problem": "一个内存控制器调度一个混合读/写流，该流的目标是一个单-rank（single-rank）双倍数据率同步动态随机存取存储器（DDR SDRAM）设备。该设备有 $B=4$ 个bank，索引为 $b \\in \\{0,1,2,3\\}$。每个bank都有一个行缓冲区，用于保存最近被激活的行。在时间 $t=0$ 时的初始状态是所有bank都已预充电（没有打开的行）。共享的命令/地址总线每个周期最多只允许发出一个命令。以下时序适用于每个bank：\n- 预充电需要 $t_{RP}=2$ 个周期，并关闭当前打开的行。\n- 激活需要 $t_{RCD}=2$ 个周期，并打开指定的行。\n- 列访问命令（READ或WRITE）需要 $1$ 个周期；列命令之后，该行保持打开状态。\n\n一个内存请求由 $(t_{i}, \\text{op}_{i}, b_{i}, r_{i})$ 表征，其中 $t_{i}$ 是以周期为单位的到达时间，$\\text{op}_{i} \\in \\{\\text{READ}, \\text{WRITE}\\}$，$b_{i}$ 是bank索引，$r_{i}$ 是行索引。请求流如下：\n- $i=1$: $(t_{1}=0, \\text{READ}, b_{1}=0, r_{1}=10)$\n- $i=2$: $(t_{2}=1, \\text{WRITE}, b_{2}=1, r_{2}=7)$\n- $i=3$: $(t_{3}=2, \\text{READ}, b_{3}=0, r_{3}=10)$\n- $i=4$: $(t_{4}=3, \\text{READ}, b_{4}=2, r_{4}=3)$\n- $i=5$: $(t_{5}=4, \\text{WRITE}, b_{5}=0, r_{5}=12)$\n- $i=6$: $(t_{6}=5, \\text{READ}, b_{6}=1, r_{6}=7)$\n- $i=7$: $(t_{7}=6, \\text{READ}, b_{7}=2, r_{7}=3)$\n- $i=8$: $(t_{8}=7, \\text{WRITE}, b_{8}=3, r_{8}=1)$\n- $i=9$: $(t_{9}=8, \\text{READ}, b_{9}=1, r_{9}=9)$\n- $i=10$: $(t_{10}=9, \\text{READ}, b_{10}=3, r_{10}=1)$\n\n控制器使用“就绪优先，先到先服务”（First-Ready, First-Come, First-Served, FR-FCFS）策略：在总线空闲的每个周期，考虑所有到达时间 $t_{i}$ 不超过当前时间的请求。目标行与其所在bank中当前打开的行相同的请求被认为是“就绪优先”（行缓冲区命中）。在就绪优先的请求中，选择到达时间最早的请求；如果不存在这样的请求，则从所有可用请求中选择到达时间最早的请求。一旦选择了请求，就背靠背地发出服务该请求所需的最短命令序列：如果bank是关闭的，则先发出激活命令，然后是列命令；如果bank中打开了不同的行，则先发出预充电命令，然后是激活命令，最后是列命令；如果所需的行已经打开，则只发出列命令。不要交错处理不同请求的命令。\n\n将FR-FCFS应用于此请求流，以生成请求的发出顺序，并为每个请求在其列命令发出时，确定它是行缓冲区命中还是未命中。计算实现的行缓冲区命中率，其定义为行缓冲区命中的请求数量与总请求数量的比率。将最终命中率表示为小数，并将答案四舍五入到四位有效数字。命中率不需要单位。",
            "solution": "首先验证问题，以确保其提法恰当、有科学依据且完整。\n\n### 步骤1：提取已知条件\n- **内存系统**：单-rank DDR SDRAM设备。\n- **Bank**：$B=4$ 个bank，索引为 $b \\in \\{0,1,2,3\\}$。\n- **行缓冲区**：每个bank有一个行缓冲区。\n- **初始状态**：在时间 $t=0$ 时，所有bank都已预充电。\n- **总线**：共享命令/地址总线，每个周期一个命令。\n- **时序参数**：\n    - 预充电时间：$t_{RP}=2$ 个周期。\n    - 激活时间：$t_{RCD}=2$ 个周期。\n    - 列访问时间（READ或WRITE）：$1$ 个周期。\n- **请求流**：一组10个请求，每个由 $(t_{i}, \\text{op}_{i}, b_{i}, r_{i})$ 定义。\n    - $i=1$: $(t_{1}=0, \\text{READ}, b_{1}=0, r_{1}=10)$\n    - $i=2$: $(t_{2}=1, \\text{WRITE}, b_{2}=1, r_{2}=7)$\n    - $i=3$: $(t_{3}=2, \\text{READ}, b_{3}=0, r_{3}=10)$\n    - $i=4$: $(t_{4}=3, \\text{READ}, b_{4}=2, r_{4}=3)$\n    - $i=5$: $(t_{5}=4, \\text{WRITE}, b_{5}=0, r_{5}=12)$\n    - $i=6$: $(t_{6}=5, \\text{READ}, b_{6}=1, r_{6}=7)$\n    - $i=7$: $(t_{7}=6, \\text{READ}, b_{7}=2, r_{7}=3)$\n    - $i=8$: $(t_{8}=7, \\text{WRITE}, b_{8}=3, r_{8}=1)$\n    - $i=9$: $(t_{9}=8, \\text{READ}, b_{9}=1, r_{9}=9)$\n    - $i=10$: $(t_{10}=9, \\text{READ}, b_{10}=3, r_{10}=1)$\n- **调度策略**：就绪优先，先到先服务 (FR-FCFS)。在总线空闲的每个周期：\n    1. 考虑所有到达时间 $t_i$ 小于或等于当前时间的请求。\n    2. 优先处理“就绪优先”（行缓冲区命中）的请求。如果一个请求的目标行与其所在bank中打开的行匹配，则为命中。\n    3. 在就绪的请求中，选择到达时间最早的那个。\n    4. 如果没有就绪的请求，则从所有可用请求中选择到达时间最早的那个。\n- **命令发出**：背靠背地发出最短的命令序列。\n- **目标**：计算行缓冲区命中率，定义为 (命中数) / (总请求数)，并四舍五入到四位有效数字。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题是计算机体系结构领域（特别是内存系统）中一个明确定义的仿真任务。该模型是DDR SDRAM控制器的一个标准（尽管简化了）的表示。所有参数（$B$, $t_{RP}$, $t_{RCD}$）、初始状态、请求流以及调度算法（FR-FCFS）都已明确无误地定义。该问题是自包含的、有科学依据的且客观的。它没有违反任何基本原则，也不包含矛盾或不完整的信息。因此，该问题是有效的。\n\n### 步骤3：结论与行动\n该问题是有效的。详细解答如下。\n\n通过逐周期模拟内存控制器的操作，并应用FR-FCFS调度策略，可以得出解决方案。我们将跟踪每个bank的状态（预充电或激活并带有特定的打开行）以及总线可用性。\n\n一个请求可能是行缓冲区命中或未命中。命令序列和时间取决于目标bank的状态：\n1.  **行缓冲区命中**：正确的行已经打开。序列是一个列命令（READ/WRITE）。总时间：$1$ 个周期。\n2.  **行缓冲区未命中（空bank）**：bank已预充电。序列是ACTIVATE，然后是列命令。总时间：$t_{RCD} + 1 = 2+1=3$ 个周期。\n3.  **行缓冲区未命中（冲突）**：bank中打开了不同的行。序列是PRECHARGE，然后ACTIVATE，最后是列命令。总时间：$t_{RP} + t_{RCD} + 1 = 2+2+1=5$ 个周期。\n\n让我们追踪执行过程。`t`是当前周期。`Bank State` 对每个bank $\\{0, 1, 2, 3\\}$ 表示为 `(状态, 打开的行)`。`H` 是命中计数，`M` 是未命中计数。\n\n**初始状态 (t=0):**\n- 总线：空闲。\n- Bank状态：B0(PRE, null), B1(PRE, null), B2(PRE, null), B3(PRE, null)。\n- `H=0`, `M=0`。\n\n**调度事件1 (t=0):**\n- 总线空闲。可用请求（在$t=0$或之前到达的）：Req 1 $(t_1=0, \\text{R}, \\text{B0}, r_{10})$。\n- Req 1的目标是Bank 0，该bank已预充电。这是一次未命中。不存在“就绪”请求。\n- **选择Req 1**。这是一次未命中（空bank）。时间成本 = $t_{RCD} + 1 = 3$ 个周期。\n- 命令：`t=0: ACT(B0, r10)`，`t=1: (ACT)`，`t=2: READ(B0, r10)`。\n- 总线忙碌直到 $t=0+3=3$。\n- `M=1`。在 $t=3$ 时，Bank 0 变为 `(ACTIVE, r10)`。\n\n**调度事件2 (t=3):**\n- 总线空闲。可用请求：Req 2 $(t_2=1)$，Req 3 $(t_3=2)$，Req 4 $(t_4=3)$。\n- 检查就绪（命中）请求：\n    - Req 2 (B1, r7)：Bank 1 已预充电。未命中。\n    - Req 3 (B0, r10)：Bank 0 处于ACTIVE状态，打开行为10。**命中**。\n    - Req 4 (B2, r3)：Bank 2 已预充电。未命中。\n- “就绪”集合为 {Req 3}。\n- **选择Req 3**。这是一次命中。时间成本 = $1$ 个周期。\n- 命令：`t=3: READ(B0, r10)`。\n- 总线忙碌直到 $t=3+1=4$。\n- `H=1`, `M=1`。Bank 0 保持 `(ACTIVE, r10)`。\n\n**调度事件3 (t=4):**\n- 总线空闲。可用请求：Req 2 $(t_2=1)$，Req 4 $(t_4=3)$，Req 5 $(t_5=4)$。\n- 检查命中：\n    - Req 2 (B1, r7)：Bank 1 已预充电。未命中。\n    - Req 4 (B2, r3)：Bank 2 已预充电。未命中。\n    - Req 5 (B0, r12)：Bank 0 打开行为10。未命中（冲突）。\n- 没有就绪请求。根据到达时间从所有可用请求中选择（FCFS）：Req 2 最早。\n- **选择Req 2**。这是一次未命中（空bank）。时间成本 = $3$ 个周期。\n- 命令：`t=4: ACT(B1, r7)`，`t=5: (ACT)`，`t=6: WRITE(B1, r7)`。\n- 总线忙碌直到 $t=4+3=7$。\n- `H=1`, `M=2`。在 $t=7$ 时，Bank 1 变为 `(ACTIVE, r7)`。\n\n**调度事件4 (t=7):**\n- 总线空闲。可用请求：Req 4 $(t_4=3)$，Req 5 $(t_5=4)$，Req 6 $(t_6=5)$，Req 7 $(t_7=6)$，Req 8 $(t_8=7)$。\n- 检查命中：\n    - Req 6 (B1, r7)：Bank 1 处于ACTIVE状态，打开行为7。**命中**。\n- “就绪”集合为 {Req 6}。\n- **选择Req 6**。这是一次命中。时间成本 = $1$ 个周期。\n- 命令：`t=7: READ(B1, r7)`。\n- 总线忙碌直到 $t=7+1=8$。\n- `H=2`, `M=2`。Bank 1 保持 `(ACTIVE, r7)`。\n\n**调度事件5 (t=8):**\n- 总线空闲。可用请求：Req 4, 5, 7, 8, 9。\n- 检查命中：所有可用请求都是未命中。\n- 没有就绪请求。选择最早到达的：Req 4 $(t_4=3)$。\n- **选择Req 4**。这是一次未命中（空bank）。时间成本 = $3$ 个周期。\n- 命令：`t=8: ACT(B2, r3)`，`t=9: (ACT)`，`t=10: READ(B2, r3)`。\n- 总线忙碌直到 $t=8+3=11$。\n- `H=2`, `M=3`。在 $t=11$ 时，Bank 2 变为 `(ACTIVE, r3)`。\n\n**调度事件6 (t=11):**\n- 总线空闲。可用请求：Req 5, 7, 8, 9, 10。\n- 检查命中：\n    - Req 7 (B2, r3)：Bank 2 处于ACTIVE状态，打开行为3。**命中**。\n- “就绪”集合为 {Req 7}。\n- **选择Req 7**。这是一次命中。时间成本 = $1$ 个周期。\n- 命令：`t=11: READ(B2, r3)`。\n- 总线忙碌直到 $t=11+1=12$。\n- `H=3`, `M=3`。Bank 2 保持 `(ACTIVE, r3)`。\n\n**调度事件7 (t=12):**\n- 总线空闲。可用请求：Req 5, 8, 9, 10。\n- 检查命中：所有都是未命中。\n- 没有就绪请求。选择最早到达的：Req 5 $(t_5=4)$。\n- **选择Req 5**。这是一次未命中（冲突）。Bank 0 打开行为10，请求需要12。时间成本 = $t_{RP} + t_{RCD} + 1 = 5$ 个周期。\n- 命令：`t=12: PRE(B0)`，`t=13: (PRE)`，`t=14: ACT(B0, r12)`，`t=15: (ACT)`，`t=16: WRITE(B0, r12)`。\n- 总线忙碌直到 $t=12+5=17$。\n- `H=3`, `M=4`。在 $t=17$ 时，Bank 0 变为 `(ACTIVE, r12)`。\n\n**调度事件8 (t=17):**\n- 总线空闲。可用请求：Req 8, 9, 10。\n- 检查命中：所有都是未命中。\n- 没有就绪请求。选择最早到达的：Req 8 $(t_8=7)$。\n- **选择Req 8**。这是一次未命中（空bank）。时间成本 = $3$ 个周期。\n- 命令：`t=17: ACT(B3, r1)`，`t=18: (ACT)`，`t=19: WRITE(B3, r1)`。\n- 总线忙碌直到 $t=17+3=20$。\n- `H=3`, `M=5`。在 $t=20$ 时，Bank 3 变为 `(ACTIVE, r1)`。\n\n**调度事件9 (t=20):**\n- 总线空闲。可用请求：Req 9, 10。\n- 检查命中：\n    - Req 10 (B3, r1)：Bank 3 处于ACTIVE状态，打开行为1。**命中**。\n- “就绪”集合为 {Req 10}。\n- **选择Req 10**。这是一次命中。时间成本 = $1$ 个周期。\n- 命令：`t=20: READ(B3, r1)`。\n- 总线忙碌直到 $t=20+1=21$。\n- `H=4`, `M=5`。Bank 3 保持 `(ACTIVE, r1)`。\n\n**调度事件10 (t=21):**\n- 总线空闲。可用请求：Req 9。\n- 检查命中：Req 9 (B1, r9) 是一次未命中（与打开的行7冲突）。\n- 没有就绪请求。从可用请求中选择：Req 9。\n- **选择Req 9**。这是一次未命中（冲突）。时间成本 = $5$ 个周期。\n- 命令：`t=21: PRE(B1)`，`t=22: (PRE)`，`t=23: ACT(B1, r9)`，`t=24: (ACT)`，`t=25: READ(B1, r9)`。\n- 总线忙碌直到 $t=21+5=26$。\n- `H=4`, `M=6`。在 $t=26$ 时，Bank 1 变为 `(ACTIVE, r9)`。\n\n**总结：**\n- 服务的请求序列是：1, 3, 2, 6, 4, 7, 5, 8, 10, 9。\n- 以下请求是行缓冲区命中：3, 6, 7, 10。\n- 以下请求是行缓冲区未命中：1, 2, 4, 5, 8, 9。\n\n总请求数：$N_{total} = 10$。\n行缓冲区命中数：$N_{hits} = 4$。\n\n行缓冲区命中率计算为命中数与总请求数的比率。\n$$ \\text{命中率} = \\frac{N_{hits}}{N_{total}} = \\frac{4}{10} = 0.4 $$\n问题要求将答案表示为小数并四舍五入到四位有效数字。\n$$ \\text{命中率} = 0.4000 $$",
            "answer": "$$\\boxed{0.4000}$$"
        }
    ]
}