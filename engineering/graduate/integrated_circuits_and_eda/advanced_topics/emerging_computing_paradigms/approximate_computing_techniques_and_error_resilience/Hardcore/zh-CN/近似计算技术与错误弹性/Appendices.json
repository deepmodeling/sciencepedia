{
    "hands_on_practices": [
        {
            "introduction": "近似计算的核心在于权衡功耗与精度。本练习通过一个具体的硬件实例——截断乘法器，让您亲手量化这种权衡关系。您将计算通过简化电路设计所获得的能量节省，并评估由此引入的平均计算误差，从而对能量与误差之间的交换有更深刻的理解。",
            "id": "4256152",
            "problem": "在电子设计自动化（EDA）的背景下，考虑一个为两个独立随机输入实现的、采用互补金属氧化物半导体（CMOS）技术的无符号阵列乘法器。设操作数为 $X$ 和 $Y$，每个操作数的位宽为 $n$ 位，其输入字在不同周期之间是独立同分布的，并且对于 $i,j \\in \\{0,1,\\dots,n-1\\}$，每个比特 $X_i$ 和 $Y_j$ 服从参数为 $1/2$ 的伯努利分布。精确乘法器通过使用双输入与门计算所有部分积 $p_{ij} = X_i Y_j$，并用一个加法网络将它们相加。\n\n一个近似乘法器会截断部分积阵列的 $k$ 个最低有效列。具体来说，近似乘积 $\\tilde{P}$ 是通过仅对权重满足 $2^{i+j} \\ge 2^{k}$ 的部分积 $p_{ij}$ 求和得到的，即忽略所有满足 $i+j  k$ 的 $p_{ij}$。这种截断消除了相应的与门以及与被丢弃的部分积相关的所有后续开关活动。假设一个双输入与门每次翻转的动态能耗是一个已知常数 $E_{\\mathrm{AND}}$（单位为焦耳），并且跨周期的连续输入字是独立的，因此任何 $p_{ij}=X_i Y_j$ 从一个周期到下一个周期的翻转概率可以从概率论的第一性原理推导出来。\n\n在此模型下：\n- 预期平均绝对误差定义为 $\\mathrm{MAE} = \\mathbb{E}\\big[|P - \\tilde{P}|\\big]$，其中 $P = X \\cdot Y$ 是精确乘积。\n- 由于截断带来的每周期预期节能，是被消除的与门所节省的预期动态能耗。\n\n使用CMOS开关的标准动态功耗与能量关系 $E_{\\mathrm{dyn}} = \\alpha C V^{2}$ 每次翻转（对于每个与门，此能量被吸收到常数 $E_{\\mathrm{AND}}$ 中），计算以下参数的每周期预期节能和预期平均绝对误差：\n- 操作数位宽 $n = 16$，\n- 截断 $k = 5$ 列，\n- 每个与门翻转的能耗 $E_{\\mathrm{AND}} = 2.0 \\times 10^{-15}$ 焦耳。\n\n将节能结果以飞焦耳（fJ）为单位表示。将节能和平均绝对误差均四舍五入至四位有效数字。以一个双元素行矩阵的形式提供最终答案，第一个元素是每周期的节能（单位：fJ），第二个元素是原生整数乘积域中的无量纲预期平均绝对误差。",
            "solution": "该问题陈述经评估有效。它在科学上基于数字逻辑设计、CMOS电路能耗建模和概率论的原理。所有术语都得到了明确定义，并提供了必要的数据（$n=16$, $k=5$, $E_{\\mathrm{AND}}=2.0 \\times 10^{-15}$ 焦耳）和统计模型（独立同分布的伯努利比特）。该问题是适定的、客观的、自洽的，因此存在唯一且可验证的解。\n\n求解过程分为两部分：计算预期节能和计算预期平均绝对误差（MAE）。\n\n第1部分：每周期预期节能\n\n每周期预期节能 $\\Delta E$ 是指因截断而被消除的与门本应消耗的能量。截断规则消除了所有满足条件 $i+j  k$ 的部分积与门 $p_{ij} = X_i Y_j$。索引 $i, j$ 的范围是从 $0$ 到 $n-1$。\n\n单个门的动态能耗在其输出翻转时产生。预期节能是每个被消除的门的预期能耗之和。\n$$ \\Delta E = \\sum_{i,j : i+j  k} \\mathbb{E}[\\text{Energy of gate } (i,j)] $$\n单个门的预期能耗是每次翻转的能耗 $E_{\\mathrm{AND}}$ 乘以其输出翻转的概率 $P_{\\mathrm{toggle}}$。\n$$ \\mathbb{E}[\\text{Energy of gate } (i,j)] = E_{\\mathrm{AND}} \\cdot P_{\\mathrm{toggle}}(p_{ij}) $$\n由于输入比特 $X_i$ 和 $Y_j$ 是参数为 $1/2$ 的独立同分布伯努利随机变量，此性质对所有部分积 $p_{ij}$ 均成立。因此，所有门的 $P_{\\mathrm{toggle}}$ 都相同。\n设 $p_{ij}(t)$ 为与门在周期 $t$ 的输出。如果 $p_{ij}(t) \\neq p_{ij}(t-1)$，则发生一次翻转。由于跨周期的输入字是独立的，所以 $p_{ij}(t)$ 和 $p_{ij}(t-1)$ 是独立的随机变量。\n翻转的概率是：\n$$ P_{\\mathrm{toggle}} = P(p_{ij}(t)=1, p_{ij}(t-1)=0) + P(p_{ij}(t)=0, p_{ij}(t-1)=1) $$\n由于独立性，这可以简化为：\n$$ P_{\\mathrm{toggle}} = 2 \\cdot P(p_{ij}=1) \\cdot P(p_{ij}=0) $$\n部分积 $p_{ij} = X_i Y_j$ 为 $1$ 当且仅当 $X_i=1$ 和 $Y_j=1$ 同时成立。鉴于 $P(X_i=1) = 1/2$ 和 $P(Y_j=1) = 1/2$ 以及它们的独立性：\n$$ P(p_{ij}=1) = P(X_i=1) \\cdot P(Y_j=1) = \\frac{1}{2} \\cdot \\frac{1}{2} = \\frac{1}{4} $$\n因此，$P(p_{ij}=0) = 1 - P(p_{ij}=1) = 1 - 1/4 = 3/4$。\n翻转概率为：\n$$ P_{\\mathrm{toggle}} = 2 \\cdot \\frac{1}{4} \\cdot \\frac{3}{4} = \\frac{6}{16} = \\frac{3}{8} $$\n接下来，我们必须计算被消除的与门数量 $N_{\\mathrm{elim}}$。这些门对应于满足 $i,j \\ge 0$ 和 $i+j  k$ 的索引对 $(i,j)$。对于给定的和 $s = i+j$，有 $s+1$ 个这样的索引对：$(0,s), (1,s-1), \\dots, (s,0)$。和 $s$ 的范围是从 $0$ 到 $k-1$。\n$$ N_{\\mathrm{elim}} = \\sum_{s=0}^{k-1} (s+1) = \\frac{k(k+1)}{2} $$\n当 $k=5$ 时：\n$$ N_{\\mathrm{elim}} = \\frac{5(5+1)}{2} = \\frac{30}{2} = 15 $$\n每周期总预期节能是被消除的门数、翻转概率和每次翻转能耗的乘积。\n$$ \\Delta E = N_{\\mathrm{elim}} \\cdot P_{\\mathrm{toggle}} \\cdot E_{\\mathrm{AND}} $$\n代入数值：\n$$ \\Delta E = 15 \\cdot \\frac{3}{8} \\cdot (2.0 \\times 10^{-15} \\text{ J}) = \\frac{45}{8} \\cdot (2.0 \\times 10^{-15} \\text{ J}) = 11.25 \\times 10^{-15} \\text{ J} $$\n问题要求答案以飞焦耳（fJ）为单位，其中 $1 \\text{ fJ} = 10^{-15} \\text{ J}$。\n$$ \\Delta E = 11.25 \\text{ fJ} $$\n该值已是四位有效数字。\n\n第2部分：预期平均绝对误差（MAE）\n\nMAE 定义为 $\\mathrm{MAE} = \\mathbb{E}[|P - \\tilde{P}|]$。精确乘积 $P$ 和近似乘积 $\\tilde{P}$ 分别是：\n$$ P = \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} p_{ij} 2^{i+j} \\quad , \\quad \\tilde{P} = \\sum_{i,j : i+j \\ge k} p_{ij} 2^{i+j} $$\n误差是截断项的总和：\n$$ P - \\tilde{P} = \\sum_{i,j : i+j  k} p_{ij} 2^{i+j} $$\n由于 $p_{ij} \\in \\{0, 1\\}$ 且 $2^{i+j} > 0$，误差项 $P - \\tilde{P}$ 总是非负的。因此， $|P - \\tilde{P}| = P - \\tilde{P}$。\nMAE 是该误差项的期望值：\n$$ \\mathrm{MAE} = \\mathbb{E}\\left[\\sum_{i,j : i+j  k} p_{ij} 2^{i+j}\\right] $$\n根据期望的线性性质：\n$$ \\mathrm{MAE} = \\sum_{i,j : i+j  k} \\mathbb{E}[p_{ij}] 2^{i+j} $$\n伯努利随机变量 $p_{ij}$ 的期望值是其为 $1$ 的概率：\n$$ \\mathbb{E}[p_{ij}] = P(p_{ij}=1) = \\frac{1}{4} $$\n将此代入 MAE 表达式：\n$$ \\mathrm{MAE} = \\frac{1}{4} \\sum_{i,j : i+j  k} 2^{i+j} $$\n设 $S = \\sum_{i,j : i+j  k} 2^{i+j}$。我们可以按和 $s=i+j$ 对各项进行分组。对于从 $0$ 到 $k-1$ 的每个 $s$ 值，有 $s+1$ 个索引对 $(i,j)$ 的和为 $s$。\n$$ S = \\sum_{s=0}^{k-1} (s+1) 2^s $$\n这是一个算术-几何级数。其和可以使用公式 $S_m = \\sum_{i=0}^{m} (i+1)x^i = \\frac{(m+1)x^{m+2} - (m+2)x^{m+1} + x}{(x-1)^2}$ 求得，或者，对于 $x=2$ 的情况，更简单地使用恒等式 $\\sum_{s=0}^{k-1} (s+1) 2^s = (k-1)2^k + 1$。\n对于 $k=5$：\n$$ S = (5-1) 2^5 + 1 = 4 \\cdot 32 + 1 = 128 + 1 = 129 $$\n现在，MAE 为：\n$$ \\mathrm{MAE} = \\frac{1}{4} S = \\frac{129}{4} = 32.25 $$\n该值在乘积的整数域中是无量纲的，并且已是四位有效数字。\n\n需要报告的最终值是节能（单位：fJ）和 MAE。\n- 预期节能：$11.25$ fJ\n- 预期平均绝对误差：$32.25$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n11.25  32.25\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在近似计算中，硬件产生的误差对最终结果的影响并非一成不变，它与所解决问题的“敏感性”密切相关。本练习引入数值分析中的核心概念——后向误差和条件数，来形式化地分析这种敏感性。通过分析一个求解线性方程组的近似加速器，您将学会如何评估一个计算问题对硬件误差的容忍度，这是误差弹性的关键。",
            "id": "4256165",
            "problem": "一个电子设计自动化 (EDA) 团队正在评估一个用于在迭代预处理器中求解小型线性系统的加速器。该加速器使用近似乘法累加 (MAC) 单元来计算线性系统 $A x = b$ 的一个候选解 $\\hat{x}$。为了评估容错性，他们采用以下模型：算法问题是将 $(A,b)$ 映射到 $x = f(A,b)$，其中 $f(A,b)$ 是精确解，而硬件由于算术近似而产生 $\\hat{x}$。他们使用向量和矩阵的 $\\infty$-范数来测量误差。\n\n在一个代表性实例上，精确数据为\n$$\nA = \\begin{bmatrix} 2  1 \\\\ 1  3 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix},\n$$\n加速器返回\n$$\n\\hat{x} = \\begin{bmatrix} 1/5 \\\\ 2/3 \\end{bmatrix}.\n$$\n\n选择所有关于后向误差和条件数的定义及其与分析这种近似硬件实现的相关性的正确陈述。\n\nA. 当将硬件误差建模为在 $A$ 精确的情况下对右端项 $b$ 的有效扰动时，后向误差是满足 $A \\hat{x} = b + \\Delta b$ 的最小 $\\Delta b$。对于给定数据，在 $\\infty$-范数下，相对后向误差等于 $1/10$。\n\nB. 在 $\\infty$-范数下，用于求解 $A x = b$ 的矩阵 $A$ 的条件数是 $\\kappa_{\\infty}(A) = \\|A\\|_{\\infty} \\,\\|A^{-1}\\|_{\\infty} = 16/5$。\n\nC. 如果一个算法是后向稳定的，那么对于每个实例，其相对前向误差都精确等于条件数乘以相对后向误差。\n\nD. 对于此实例，关联前向和后向误差的不等式成立，\n$$\n\\frac{\\|\\hat{x} - x\\|_{\\infty}}{\\|x\\|_{\\infty}} \\le \\kappa_{\\infty}(A)\\, \\frac{\\|b - A \\hat{x}\\|_{\\infty}}{\\|b\\|_{\\infty}},\n$$\n数值上为 $1/9 \\le 8/25$，这说明即使是很小的由硬件引起的残差也可能被问题的条件所放大。\n\nE. 因为在有限维空间中范数是等价的，所以条件数对于范数的选择是不变的，因此对于这个矩阵 $A$，有 $\\kappa_{1}(A) = \\kappa_{\\infty}(A)$。",
            "solution": "问题陈述是内部一致的，在数值线性代数领域有科学依据，并提供了评估给定选项所需的所有信息。该情景是在硬件中实现的数值方法的误差分析的一个标准应用。问题是有效的。我们开始进行求解。\n\n首先，我们根据所提供的数据确定必要的量。\n线性系统为 $A x = b$，其中\n$$\nA = \\begin{bmatrix} 2  1 \\\\ 1  3 \\end{bmatrix}, \\quad b = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}\n$$\n加速器提供了一个近似解\n$$\n\\hat{x} = \\begin{bmatrix} 1/5 \\\\ 2/3 \\end{bmatrix}\n$$\n所有分析都将使用 $\\infty$-范数（记为 $\\|\\cdot\\|_{\\infty}$）进行。\n\n**1. 精确解 $x$**\n为了找到精确解 $x$，我们首先计算 $A$ 的逆矩阵。行列式为 $\\det(A) = (2)(3) - (1)(1) = 5$。\n逆矩阵是\n$$\nA^{-1} = \\frac{1}{\\det(A)} \\begin{bmatrix} 3  -1 \\\\ -1  2 \\end{bmatrix} = \\frac{1}{5} \\begin{bmatrix} 3  -1 \\\\ -1  2 \\end{bmatrix} = \\begin{bmatrix} 3/5  -1/5 \\\\ -1/5  2/5 \\end{bmatrix}\n$$\n精确解是\n$$\nx = A^{-1} b = \\frac{1}{5} \\begin{bmatrix} 3  -1 \\\\ -1  2 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix} = \\frac{1}{5} \\begin{bmatrix} 3(1) - 1(2) \\\\ -1(1) + 2(2) \\end{bmatrix} = \\frac{1}{5} \\begin{bmatrix} 1 \\\\ 3 \\end{bmatrix} = \\begin{bmatrix} 1/5 \\\\ 3/5 \\end{bmatrix}\n$$\n\n**2. 前向误差**\n绝对前向误差是近似解与精确解之差：\n$$\n\\hat{x} - x = \\begin{bmatrix} 1/5 \\\\ 2/3 \\end{bmatrix} - \\begin{bmatrix} 1/5 \\\\ 3/5 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ \\frac{10 - 9}{15} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1/15 \\end{bmatrix}\n$$\n绝对前向误差的 $\\infty$-范数是 $\\|\\hat{x} - x\\|_{\\infty} = \\max(|0|, |1/15|) = 1/15$。\n精确解的 $\\infty$-范数是 $\\|x\\|_{\\infty} = \\max(|1/5|, |3/5|) = 3/5$。\n相对前向误差是\n$$\n\\frac{\\|\\hat{x} - x\\|_{\\infty}}{\\|x\\|_{\\infty}} = \\frac{1/15}{3/5} = \\frac{1}{15} \\cdot \\frac{5}{3} = \\frac{1}{9}\n$$\n\n**3. 残差和后向误差**\n残差向量是 $r = b - A \\hat{x}$。\n首先，我们计算 $A \\hat{x}$：\n$$\nA \\hat{x} = \\begin{bmatrix} 2  1 \\\\ 1  3 \\end{bmatrix} \\begin{bmatrix} 1/5 \\\\ 2/3 \\end{bmatrix} = \\begin{bmatrix} 2(1/5) + 1(2/3) \\\\ 1(1/5) + 3(2/3) \\end{bmatrix} = \\begin{bmatrix} 2/5 + 2/3 \\\\ 1/5 + 2 \\end{bmatrix} = \\begin{bmatrix} (6+10)/15 \\\\ (1+10)/5 \\end{bmatrix} = \\begin{bmatrix} 16/15 \\\\ 11/5 \\end{bmatrix}\n$$\n残差是\n$$\nr = b - A \\hat{x} = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix} - \\begin{bmatrix} 16/15 \\\\ 11/5 \\end{bmatrix} = \\begin{bmatrix} 15/15 - 16/15 \\\\ 10/5 - 11/5 \\end{bmatrix} = \\begin{bmatrix} -1/15 \\\\ -1/5 \\end{bmatrix}\n$$\n残差的 $\\infty$-范数是 $\\|r\\|_{\\infty} = \\|b - A \\hat{x}\\|_{\\infty} = \\max(|-1/15|, |-1/5|) = 1/5$。\n\n现在我们评估每个选项。\n\n**A. 当将硬件误差建模为在 $A$ 精确的情况下对右端项 $b$ 的有效扰动时，后向误差是满足 $A \\hat{x} = b + \\Delta b$ 的最小 $\\Delta b$。对于给定数据，在 $\\infty$-范数下，相对后向误差等于 $1/10$。**\n\n所述的后向误差模型将扰动 $\\Delta b$ 定义为 $\\Delta b = A \\hat{x} - b = -r$。在 $\\infty$-范数下，这种最小扰动是 $\\|\\Delta b\\|_{\\infty} = \\|-r\\|_{\\infty} = \\|r\\|_{\\infty}$。这就是绝对后向误差。根据我们的计算，绝对后向误差是 $\\|r\\|_{\\infty} = 1/5$。\n相对后向误差是绝对后向误差除以原始数据的大小（通常是 $\\|b\\|_{\\infty}$）进行归一化。\n$$\n\\text{相对后向误差} = \\frac{\\|b - A \\hat{x}\\|_{\\infty}}{\\|b\\|_{\\infty}}\n$$\n我们需要 $b$ 的范数：$\\|b\\|_{\\infty} = \\max(|1|, |2|) = 2$。\n代入数值：\n$$\n\\text{相对后向误差} = \\frac{1/5}{2} = \\frac{1}{10}\n$$\n该陈述断言相对后向误差为 $1/10$。这与我们的计算结果相符。\n\n**对 A 的判决：正确**\n\n**B. 在 $\\infty$-范数下，用于求解 $A x = b$ 的矩阵 $A$ 的条件数是 $\\kappa_{\\infty}(A) = \\|A\\|_{\\infty} \\,\\|A^{-1}\\|_{\\infty} = 16/5$。**\n\n条件数的定义是 $\\kappa_{\\infty}(A) = \\|A\\|_{\\infty}\\|A^{-1}\\|_{\\infty}$。\n矩阵的 $\\infty$-范数是最大绝对行和。\n对于 $A = \\begin{bmatrix} 2  1 \\\\ 1  3 \\end{bmatrix}$：\n$\\|A\\|_{\\infty} = \\max(|2|+|1|, |1|+|3|) = \\max(3, 4) = 4$。\n对于 $A^{-1} = \\begin{bmatrix} 3/5  -1/5 \\\\ -1/5  2/5 \\end{bmatrix}$：\n$\\|A^{-1}\\|_{\\infty} = \\max(|3/5|+|-1/5|, |-1/5|+|2/5|) = \\max(4/5, 3/5) = 4/5$。\n条件数是：\n$$\n\\kappa_{\\infty}(A) = \\|A\\|_{\\infty}\\|A^{-1}\\|_{\\infty} = 4 \\times \\frac{4}{5} = \\frac{16}{5}\n$$\n该陈述断言 $\\kappa_{\\infty}(A) = 16/5$。这与我们的计算结果相符。\n\n**对 B 的判决：正确**\n\n**C. 如果一个算法是后向稳定的，那么对于每个实例，其相对前向误差都精确等于条件数乘以相对后向误差。**\n\n该陈述提出了一个普遍的等式：\n$$\n\\frac{\\|\\hat{x}-x\\|}{\\|x\\|} = \\kappa(A) \\frac{\\|b-A\\hat{x}\\|}{\\|b\\|}\n$$\n在数值分析中，正确的关系是一个不等式，它给出了前向误差的界：\n$$\n\\frac{\\|\\hat{x}-x\\|}{\\|x\\|} \\le \\kappa(A) \\frac{\\|b-A\\hat{x}\\|}{\\|b\\|}\n$$\n（当扰动仅在 $b$ 中建模时，这是一种常见的形式）。这个关系不是一个严格的等式。实际的放大因子取决于误差向量与矩阵奇异向量的对齐情况，而条件数代表了最坏情况下的放大。该陈述声称“对于每个实例”都精确相等是错误的。我们可以对当前实例进行验证：\n相对前向误差是 $1/9$。\n条件数乘以相对后向误差是 $\\kappa_{\\infty}(A) \\times \\frac{\\|r\\|_{\\infty}}{\\|b\\|_{\\infty}} = \\frac{16}{5} \\times \\frac{1}{10} = \\frac{16}{50} = \\frac{8}{25}$。\n由于 $1/9 \\approx 0.111$ 且 $8/25 = 0.32$，很明显 $1/9 \\neq 8/25$。该陈述在一般情况下和这个特定案例中都是错误的。\n\n**对 C 的判决：不正确**\n\n**D. 对于此实例，关联前向和后向误差的不等式成立，\n$$\n\\frac{\\|\\hat{x} - x\\|_{\\infty}}{\\|x\\|_{\\infty}} \\le \\kappa_{\\infty}(A)\\, \\frac{\\|b - A \\hat{x}\\|_{\\infty}}{\\|b\\|_{\\infty}},\n$$\n数值上为 $1/9 \\le 8/25$，这说明即使是很小的由硬件引起的残差也可能被问题的条件所放大。**\n\n所呈现的不等式是界定相对前向误差的标准结果。让我们通过代入我们计算出的数值来验证这个数值声明：\n不等式左边 (LHS): $\\frac{\\|\\hat{x} - x\\|_{\\infty}}{\\|x\\|_{\\infty}} = 1/9$。\n不等式右边 (RHS): $\\kappa_{\\infty}(A)\\, \\frac{\\|b - A \\hat{x}\\|_{\\infty}}{\\|b\\|_{\\infty}} = \\frac{16}{5} \\times \\frac{1/5}{2} = \\frac{16}{5} \\times \\frac{1}{10} = \\frac{16}{50} = \\frac{8}{25}$。\n不等式为 $1/9 \\le 8/25$。\n为了检验，我们可以使用公分母 225：$1/9 = 25/225$ 且 $8/25 = 72/225$。\n不等式为 $25/225 \\le 72/225$，这是成立的。\n所提供的解释也是正确的：条件数 $\\kappa_{\\infty}(A) = 16/5 = 3.2$ 充当了从相对后向误差（残差）到相对前向误差的放大因子。不等式成立，数值正确，且解释是标准的。\n\n**对 D 的判决：正确**\n\n**E. 因为在有限维空间中范数是等价的，所以条件数对于范数的选择是不变的，因此对于这个矩阵 $A$，有 $\\kappa_{1}(A) = \\kappa_{\\infty}(A)$。**\n\n这个陈述包含一个严重的逻辑缺陷。前提“在有限维空间中范数是等价的”是正确的。这意味着对于任意两个范数 $\\|\\cdot\\|_a$ 和 $\\|\\cdot\\|_b$，存在正常数 $c_1, c_2$ 使得对于所有向量 $v$ 都有 $c_1 \\|v\\|_a \\le \\|v\\|_b \\le c_2 \\|v\\|_a$。然而，这并不意味着对于给定的向量，范数具有相同的值，也不意味着诱导矩阵范数或条件数是不变的。\n中间结论“条件数对于范数的选择是不变的”通常是错误的。例如，对于大多数大小为 $n>2$ 的矩阵，$\\kappa_1(A) \\ne \\kappa_2(A) \\ne \\kappa_\\infty(A)$。\n我们来检查最终结论“对于这个矩阵 $A$，有 $\\kappa_{1}(A) = \\kappa_{\\infty}(A)$”。\n矩阵的 $1$-范数是最大绝对列和。\n$\\|A\\|_1 = \\max(|2|+|1|, |1|+|3|) = \\max(3, 4) = 4$。\n$\\|A^{-1}\\|_1 = \\max(|3/5|+|-1/5|, |-1/5|+|2/5|) = \\max(4/5, 3/5) = 4/5$。\n因此，$\\kappa_1(A) = \\|A\\|_1 \\|A^{-1}\\|_1 = 4 \\times (4/5) = 16/5$。\n我们之前发现 $\\kappa_\\infty(A) = 16/5$。因此，对于这个特定的矩阵，$\\kappa_1(A) = \\kappa_\\infty(A)$ 恰好成立。（这对于所有可逆的 $2 \\times 2$ 矩阵都成立）。\n然而，整个陈述是一个形式为“R 为真因为 Q 为真”的论证，其中 Q 是一个错误的前提，即“条件数是不变的”。一个基于错误推理的论证在数学或科学中不是一个正确的陈述，即使最终结论对于特定数据恰好是正确的。推理本身也是必须被评估的一部分。\n\n**对 E 的判决：不正确**",
            "answer": "$$\\boxed{ABD}$$"
        },
        {
            "introduction": "在实际设计中，工程师往往面临从众多具有不同能耗和误差特性的近似计算单元中进行选择的挑战。本练习将指导您使用多目标优化的基本工具——帕累托最优（Pareto Optimality）来应对这一挑战。您将通过编程实现一个算法，以识别出所有最优的能量-误差权衡点（即帕累托前沿），并根据给定的预算约束选出最佳设计。",
            "id": "4256172",
            "problem": "考虑一个集成电路中的近似计算单元库，其中每个单元都以其能耗和应用级误差度量为特征。设第 $i$ 个单元由序对 $\\left(E_{i}, \\epsilon_{i}\\right)$ 表示，其中 $E_{i}$ 是以 $\\mathrm{nJ}$（纳焦耳）为单位的能耗，$\\epsilon_{i}$ 是一个在区间 $[0,1]$ 内以小数表示的无量纲归一化误差。目标是在最小化能耗和最小化误差这两个目标下，计算这些单元的帕累托前沿，然后在一个指定的能量预算和误差上限下选择一个可行的设计。\n\n从以下基本依据开始：\n- 能量作为一种物理资源的定义，必须在预算内分配，以及容错性原则要求遵守应用级误差约束。\n- 多目标优化中帕累托支配的数学定义：单元 $i$ 支配单元 $j$ 的条件是 $E_{i} \\le E_{j}$ 且 $\\epsilon_{i} \\le \\epsilon_{j}$，并且至少有一个不等式是严格的。如果没有任何其他单元支配某个单元，则该单元是帕累托有效的（或非支配的）。\n\n基于这些基础，您必须设计一个算法，该算法能够：\n1. 识别所有非支配单元以构成帕累托前沿。\n2. 按能量升序、然后按误差升序、最后按索引升序对帕累托前沿进行排序，以确保确定性的顺序。\n3. 给定一个能量预算 $B$（单位为 $\\mathrm{nJ}$）和一个误差上限 $C$（无量纲小数），从满足 $E_{i} \\le B$ 和 $\\epsilon_{i} \\le C$ 的单元中选择一个。选择必须优先考虑最小能量，通过最小误差来打破平局，然后通过最小索引来打破任何剩余的平局。如果没有单元同时满足这两个约束，则选择应为 $-1$。\n\n所有索引必须视为从 $0$ 开始。如果两个单元具有相同的 $\\left(E_{i}, \\epsilon_{i}\\right)$，则它们都被认为是非支配的，并且都应出现在帕累托前沿中。\n\n您的程序必须嵌入以下参数值的测试套件，并完全按照规定处理它们：\n\n- 测试用例 1：\n  - 单元：$\\left(E_{i}, \\epsilon_{i}\\right)$ 对于 $i \\in \\{0,1,2,3,4,5,6\\}$，由以下给出\n    - $E$：$[1.20, 0.90, 0.85, 1.10, 0.95, 1.50, 0.85]$ $\\mathrm{nJ}$\n    - $\\epsilon$：$[0.040, 0.080, 0.060, 0.030, 0.050, 0.020, 0.030]$\n  - 预算 $B$：$1.00$ $\\mathrm{nJ}$\n  - 误差上限 $C$：$0.050$\n- 测试用例 2：\n  - 单元：$\\left(E_{i}, \\epsilon_{i}\\right)$ 对于 $i \\in \\{0,1,2,3,4\\}$，由以下给出\n    - $E$：$[1.00, 1.00, 0.90, 0.90, 0.80]$ $\\mathrm{nJ}$\n    - $\\epsilon$：$[0.040, 0.040, 0.040, 0.050, 0.060]$\n  - 预算 $B$：$0.90$ $\\mathrm{nJ}$\n  - 误差上限 $C$：$0.040$\n- 测试用例 3：\n  - 单元：$\\left(E_{i}, \\epsilon_{i}\\right)$ 对于 $i \\in \\{0,1,2,3\\}$，由以下给出\n    - $E$：$[0.50, 0.50, 0.50, 0.60]$ $\\mathrm{nJ}$\n    - $\\epsilon$：$[0.040, 0.030, 0.035, 0.025]$\n  - 预算 $B$：$1.00$ $\\mathrm{nJ}$\n  - 误差上限 $C$：$0.040$\n- 测试用例 4：\n  - 单元：$\\left(E_{i}, \\epsilon_{i}\\right)$ 对于 $i \\in \\{0,1,2\\}$，由以下给出\n    - $E$：$[1.20, 1.10, 1.05]$ $\\mathrm{nJ}$\n    - $\\epsilon$：$[0.10, 0.09, 0.08]$\n  - 预算 $B$：$1.00$ $\\mathrm{nJ}$\n  - 误差上限 $C$：$0.05$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。每个测试用例的结果本身必须是一个双元素列表，其第一个元素是按指定排序顺序排列的帕累托前沿索引列表，第二个元素是所选的索引（如果不可行则为 $-1$）。例如，单个测试用例的结果应格式化为 $[[i_{1}, i_{2}, \\dots], s]$，其中 $[i_{1}, i_{2}, \\dots]$ 是帕累托前沿上的索引，$s$ 是所选的索引。\n\n因此，最终的单行应为 $[r_{1}, r_{2}, r_{3}, r_{4}]$ 的形式，其中每个 $r_{k}$ 是上述的双元素列表之一。",
            "solution": "所提出的问题是多目标优化领域的一个经典练习，特别应用于近似计算范式下的集成电路设计领域。任务是平衡最小化能耗（$E$）和最小化计算误差（$\\epsilon$）这两个相互冲突的目标。解决方案要求严格应用帕累托分析以及基于指定约束和优先级的清晰、确定性的选择过程。\n\n基本原则已提供如下：\n1.  **资源约束**：能量（$E$）是一种受预算 $B$ 制约的有限资源，而误差（$\\epsilon$）必须保持在特定应用的容忍上限 $C$ 以下。\n2.  **帕累托支配**：这是在多目标空间中比较解决方案的关键概念。一个由序对 $(E_i, \\epsilon_i)$ 表征的计算单元 $i$，如果它在所有目标上至少与单元 $j$ 一样好，并且在至少一个目标上严格更好，则称其支配单元 $j$。形式上，单元 $i$ 支配单元 $j$ 的条件是（$E_i \\le E_j$ 且 $\\epsilon_i \\le \\epsilon_j$）且（$E_i  E_j$ 或 $\\epsilon_i  \\epsilon_j$）。\n\n一个单元如果设计空间中没有其他可用单元支配它，则被称为**帕累托有效的**（或非支配的）。所有这些非支配单元的集合构成了**帕累托前沿**。该前沿代表了所有最优权衡的集合；对于前沿上的任何一点，都不可能在不降低另一个目标的情况下改善一个目标。\n\n算法解决方案按照问题的要求，分为三个不同且顺序的步骤。\n\n**步骤 1：识别帕累托前沿**\n为了识别所有非支配单元，需要对所有可用单元进行系统性的成对比较。对于每个单元 $i$，我们必须确定是否存在任何其他支配它的单元 $j$。\n算法过程如下：\n对于所有单元集合中的每个单元 $i$：\n- 暂时假设单元 $i$ 是非支配的。\n- 遍历所有其他单元 $j$（其中 $j \\ne i$）。\n- 对于每个 $j$，检查它是否满足对 $i$ 的支配条件：$E_j \\le E_i$ 且 $\\epsilon_j \\le \\epsilon_i$，且至少有一个不等式是严格的。\n- 如果找到这样一个单元 $j$，则单元 $i$ 被确认为受支配。我们可以立即停止对 $i$ 的检查，并断定它不在帕累托前沿上。\n- 如果检查了所有其他单元的集合，没有发现任何单元 $j$ 支配 $i$，那么最初的假设成立，单元 $i$ 是帕累托前沿的一部分。\n\n收集所有被发现是非支配单元的索引，以构成帕累托前沿集合。请注意，如果两个单元 $k$ 和 $l$ 具有相同的特性，即 ($E_k, \\epsilon_k) = (E_l, \\epsilon_l)$，它们不会相互支配。如果没有其他单元支配它们，则两者都包含在帕累托前沿中。\n\n**步骤 2：对帕累托前沿进行排序**\n问题要求对帕累托前沿上的单元进行确定性的排序。这是通过基于多级键对已识别的非支配单元进行排序来实现的。主要排序标准是能耗（$E_i$）升序。能量上的任何平局由次要标准，即误差（$\\epsilon_i$）升序来解决。如果仍然存在平局（即前沿上的两个不同单元具有相同的能量和误差值），则由第三标准，即单元的原始索引（$i$）升序来打破。这确保了帕累托前沿的唯一且一致的排序。此步骤的最终输出是一个排序后的索引列表。\n\n**步骤 3：选择最优可行单元**\n给定一个能量预算 $B$ 和一个误差上限 $C$，最后一步是从*整个*原始单元集中选择一个最优单元，而不仅仅是从帕累托前沿中选择。一个单元 $i$ 如果同时满足两个约束条件：$E_i \\le B$ 和 $\\epsilon_i \\le C$，则被认为是**可行的**。\n\n选择过程如下：\n- 首先，筛选完整的单元集，生成一个仅包含可行单元的子集。\n- 如果这个可行子集为空（即没有单元同时满足预算和上限），则没有可行的解决方案，选择结果用 $-1$ 表示。\n- 如果可行子集非空，则必须根据一个有优先级的选择规则来选择一个单元。所选单元必须是提供最小能耗（$E_i$）的那个。如果多个可行单元共享相同的最小能量，则通过选择其中误差最小（$\\epsilon_i$）的那个来打破平局。如果仍然存在平局，则通过选择具有最小原始索引（$i$）的单元来解决。这种分层排序与用于帕累托前沿的排序相同，确保了在可行选项中有一个唯一的最佳选择。\n\n这个三步过程正确地实现了多目标优化和基于约束的设计选择原则。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the multi-objective optimization problem for a series of test cases.\n    For each case, it finds the Pareto front, sorts it, and selects the\n    best feasible unit according to the specified constraints and criteria.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"E\": [1.20, 0.90, 0.85, 1.10, 0.95, 1.50, 0.85],\n            \"epsilon\": [0.040, 0.080, 0.060, 0.030, 0.050, 0.020, 0.030],\n            \"B\": 1.00,\n            \"C\": 0.050\n        },\n        {\n            \"E\": [1.00, 1.00, 0.90, 0.90, 0.80],\n            \"epsilon\": [0.040, 0.040, 0.040, 0.050, 0.060],\n            \"B\": 0.90,\n            \"C\": 0.040\n        },\n        {\n            \"E\": [0.50, 0.50, 0.50, 0.60],\n            \"epsilon\": [0.040, 0.030, 0.035, 0.025],\n            \"B\": 1.00,\n            \"C\": 0.040\n        },\n        {\n            \"E\": [1.20, 1.10, 1.05],\n            \"epsilon\": [0.10, 0.09, 0.08],\n            \"B\": 1.00,\n            \"C\": 0.05\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        E_vals = case[\"E\"]\n        e_vals = case[\"epsilon\"]\n        B = case[\"B\"]\n        C = case[\"C\"]\n        \n        num_units = len(E_vals)\n        # Store unit data as a list of dictionaries for clarity\n        units = [{'E': E_vals[i], 'e': e_vals[i], 'idx': i} for i in range(num_units)]\n\n        # Step 1: Identify all non-dominated units to form the Pareto front.\n        pareto_indices = []\n        for i in range(num_units):\n            is_dominated = False\n            for j in range(num_units):\n                if i == j:\n                    continue\n                # Check if unit j dominates unit i\n                # Dominance: E_j = E_i AND e_j = e_i AND (E_j  E_i OR e_j  e_i)\n                if (units[j]['E'] = units[i]['E'] and units[j]['e'] = units[i]['e']) and \\\n                   (units[j]['E']  units[i]['E'] or units[j]['e']  units[i]['e']):\n                    is_dominated = True\n                    break\n            if not is_dominated:\n                pareto_indices.append(i)\n\n        # Step 2: Sort the Pareto front.\n        pareto_units_data = [units[i] for i in pareto_indices]\n        # Sort by ascending energy, then ascending error, then ascending index.\n        pareto_units_data.sort(key=lambda u: (u['E'], u['e'], u['idx']))\n        sorted_pareto_indices = [u['idx'] for u in pareto_units_data]\n\n        # Step 3: Select the best feasible unit from the entire set.\n        # A unit is feasible if E = B and epsilon = C.\n        feasible_units = [u for u in units if u['E'] = B and u['e'] = C]\n\n        selected_index = -1\n        if feasible_units:\n            # Sort by minimal energy, then minimal error, then smallest index.\n            feasible_units.sort(key=lambda u: (u['E'], u['e'], u['idx']))\n            selected_index = feasible_units[0]['idx']\n\n        results.append([sorted_pareto_indices, selected_index])\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list includes spaces (e.g., '[1, 2]').\n    # The replace() call removes these spaces to match the compact format '[1,2]'\n    # implied by the problem description's example `[[i_1, i_2, ...], s]`.\n    formatted_results = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}