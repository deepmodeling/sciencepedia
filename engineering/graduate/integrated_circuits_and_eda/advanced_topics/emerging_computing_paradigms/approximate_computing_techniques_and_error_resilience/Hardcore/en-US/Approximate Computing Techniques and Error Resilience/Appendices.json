{
    "hands_on_practices": [
        {
            "introduction": "The essence of approximate computing lies in the deliberate trade-off between computational accuracy and resource efficiency, like energy consumption. To make informed design choices, we must be able to quantify this relationship. This first practice  provides a foundational exercise in this analysis, focusing on a common approximate component: a truncated array multiplier. By deriving the expected energy savings and the mean absolute error from first principles, you will build a concrete understanding of how a specific hardware modification translates directly into quantifiable changes in energy and accuracy.",
            "id": "4256152",
            "problem": "Consider an unsigned array multiplier implemented in complementary metal–oxide–semiconductor (CMOS) for two independent random inputs in the context of Electronic Design Automation (EDA). Let the operands be $X$ and $Y$, each of width $n$ bits, with independent and identically distributed input words across cycles, and each bit $X_i$ and $Y_j$ for $i,j \\in \\{0,1,\\dots,n-1\\}$ follows a Bernoulli distribution with parameter $1/2$. The exact multiplier forms all partial products via $p_{ij} = X_i Y_j$ using two-input AND gates and sums them with an addition network.\n\nAn approximate multiplier truncates the $k$ least significant columns of the partial product array. Specifically, the approximate product $\\tilde{P}$ is obtained by summing only those partial products $p_{ij}$ whose weights satisfy $2^{i+j} \\ge 2^{k}$, i.e., it omits all $p_{ij}$ with $i+j  k$. This truncation eliminates the corresponding AND gates and all subsequent switching activity associated with the dropped partial products. Assume the dynamic energy per toggle of a two-input AND gate is a known constant $E_{\\mathrm{AND}}$ (in joules), and successive input words across cycles are independent, so the toggling probability of any $p_{ij}=X_i Y_j$ from one cycle to the next can be derived from first principles of probability.\n\nUnder this model:\n- The expected mean absolute error is defined as $\\mathrm{MAE} = \\mathbb{E}\\big[|P - \\tilde{P}|\\big]$, where $P = X \\cdot Y$ is the exact product.\n- The expected energy savings per cycle due to truncation is the expected dynamic energy not consumed by the eliminated AND gates.\n\nUsing the standard dynamic power and energy relation for CMOS switching, $E_{\\mathrm{dyn}} = \\alpha C V^{2}$ per toggle (absorbed into the constant $E_{\\mathrm{AND}}$ for each AND gate), compute both the expected energy savings per cycle and the expected mean absolute error for the following parameters:\n- Operand width $n = 16$,\n- Truncation $k = 5$ columns,\n- Energy per AND-gate toggle $E_{\\mathrm{AND}} = 2.0 \\times 10^{-15}$ joules.\n\nExpress the energy savings in femtojoules (fJ). Round both the energy savings and the mean absolute error to four significant figures. Provide the final answer as a two-entry row matrix, with the first entry being the energy savings per cycle in fJ and the second entry being the expected mean absolute error as a dimensionless quantity in the native integer product domain.",
            "solution": "The problem statement is evaluated to be valid. It is scientifically grounded in the principles of digital logic design, CMOS circuit energy modeling, and probability theory. All terms are clearly defined, and the necessary data ($n=16$, $k=5$, $E_{\\mathrm{AND}}=2.0 \\times 10^{-15}$ joules) and statistical models (i.i.d. Bernoulli bits) are provided. The problem is well-posed, objective, and self-contained, allowing for a unique, verifiable solution.\n\nThe solution is divided into two parts: calculation of the expected energy savings and calculation of the expected mean absolute error (MAE).\n\nPart 1: Expected Energy Savings per Cycle\n\nThe expected energy savings per cycle, $\\Delta E$, is the energy that would have been consumed by the AND gates which are eliminated by the truncation. The truncation rule eliminates all partial product AND gates $p_{ij} = X_i Y_j$ for which the condition $i+j  k$ is met. The indices $i, j$ range from $0$ to $n-1$.\n\nThe dynamic energy of a single gate is consumed when its output toggles. The expected energy saving is the sum of the expected energy consumption of each eliminated gate.\n$$ \\Delta E = \\sum_{i,j : i+j  k} \\mathbb{E}[\\text{Energy of gate } (i,j)] $$\nThe expected energy of a single gate is the energy per toggle, $E_{\\mathrm{AND}}$, multiplied by the probability of its output toggling, $P_{\\mathrm{toggle}}$.\n$$ \\mathbb{E}[\\text{Energy of gate } (i,j)] = E_{\\mathrm{AND}} \\cdot P_{\\mathrm{toggle}}(p_{ij}) $$\nSince the input bits $X_i$ and $Y_j$ are independent and identically distributed Bernoulli random variables with parameter $1/2$, this property holds for all partial products $p_{ij}$. Hence, $P_{\\mathrm{toggle}}$ is the same for all gates.\nLet $p_{ij}(t)$ be the output of the AND gate at cycle $t$. A toggle occurs if $p_{ij}(t) \\neq p_{ij}(t-1)$. Since input words across cycles are independent, $p_{ij}(t)$ and $p_{ij}(t-1)$ are independent random variables.\nThe probability of a toggle is:\n$$ P_{\\mathrm{toggle}} = P(p_{ij}(t)=1, p_{ij}(t-1)=0) + P(p_{ij}(t)=0, p_{ij}(t-1)=1) $$\nDue to independence, this simplifies to:\n$$ P_{\\mathrm{toggle}} = 2 \\cdot P(p_{ij}=1) \\cdot P(p_{ij}=0) $$\nThe partial product $p_{ij} = X_i Y_j$ is $1$ if and only if both $X_i=1$ and $Y_j=1$. Given $P(X_i=1) = 1/2$ and $P(Y_j=1) = 1/2$ and their independence:\n$$ P(p_{ij}=1) = P(X_i=1) \\cdot P(Y_j=1) = \\frac{1}{2} \\cdot \\frac{1}{2} = \\frac{1}{4} $$\nConsequently, $P(p_{ij}=0) = 1 - P(p_{ij}=1) = 1 - 1/4 = 3/4$.\nThe toggle probability is:\n$$ P_{\\mathrm{toggle}} = 2 \\cdot \\frac{1}{4} \\cdot \\frac{3}{4} = \\frac{6}{16} = \\frac{3}{8} $$\nNext, we must count the number of eliminated AND gates, $N_{\\mathrm{elim}}$. These are the gates corresponding to pairs of indices $(i,j)$ such that $i,j \\ge 0$ and $i+j  k$. For a given sum $s = i+j$, there are $s+1$ such pairs: $(0,s), (1,s-1), \\dots, (s,0)$. The sum $s$ ranges from $0$ to $k-1$.\n$$ N_{\\mathrm{elim}} = \\sum_{s=0}^{k-1} (s+1) = \\frac{k(k+1)}{2} $$\nWith $k=5$:\n$$ N_{\\mathrm{elim}} = \\frac{5(5+1)}{2} = \\frac{30}{2} = 15 $$\nThe total expected energy savings per cycle is the product of the number of eliminated gates, the toggle probability, and the energy per toggle.\n$$ \\Delta E = N_{\\mathrm{elim}} \\cdot P_{\\mathrm{toggle}} \\cdot E_{\\mathrm{AND}} $$\nSubstituting the values:\n$$ \\Delta E = 15 \\cdot \\frac{3}{8} \\cdot (2.0 \\times 10^{-15} \\text{ J}) = \\frac{45}{8} \\cdot (2.0 \\times 10^{-15} \\text{ J}) = 11.25 \\times 10^{-15} \\text{ J} $$\nThe problem requires the answer in femtojoules (fJ), where $1 \\text{ fJ} = 10^{-15} \\text{ J}$.\n$$ \\Delta E = 11.25 \\text{ fJ} $$\nThis value is already at four significant figures.\n\nPart 2: Expected Mean Absolute Error (MAE)\n\nThe MAE is defined as $\\mathrm{MAE} = \\mathbb{E}[|P - \\tilde{P}|]$. The exact product $P$ and approximate product $\\tilde{P}$ are:\n$$ P = \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} p_{ij} 2^{i+j} \\quad , \\quad \\tilde{P} = \\sum_{i,j : i+j \\ge k} p_{ij} 2^{i+j} $$\nThe error is the sum of the truncated terms:\n$$ P - \\tilde{P} = \\sum_{i,j : i+j  k} p_{ij} 2^{i+j} $$\nSince $p_{ij} \\in \\{0, 1\\}$ and $2^{i+j}  0$, the error term $P - \\tilde{P}$ is always non-negative. Therefore, $|P - \\tilde{P}| = P - \\tilde{P}$.\nThe MAE is the expectation of this error term:\n$$ \\mathrm{MAE} = \\mathbb{E}\\left[\\sum_{i,j : i+j  k} p_{ij} 2^{i+j}\\right] $$\nBy the linearity of expectation:\n$$ \\mathrm{MAE} = \\sum_{i,j : i+j  k} \\mathbb{E}[p_{ij}] 2^{i+j} $$\nThe expected value of the Bernoulli random variable $p_{ij}$ is its probability of being $1$:\n$$ \\mathbb{E}[p_{ij}] = P(p_{ij}=1) = \\frac{1}{4} $$\nSubstituting this into the MAE expression:\n$$ \\mathrm{MAE} = \\frac{1}{4} \\sum_{i,j : i+j  k} 2^{i+j} $$\nLet $S = \\sum_{i,j : i+j  k} 2^{i+j}$. We can group the terms by the sum $s=i+j$. For each value of $s$ from $0$ to $k-1$, there are $s+1$ pairs $(i,j)$ that sum to $s$.\n$$ S = \\sum_{s=0}^{k-1} (s+1) 2^s $$\nThis is an arithmetico-geometric series. The sum can be found using the formula $S_m = \\sum_{i=0}^{m} (i+1)x^i = \\frac{(m+1)x^{m+2} - (m+2)x^{m+1} + x}{(x-1)^2}$ or, more simply for $x=2$, we can use the identity $\\sum_{s=0}^{k-1} (s+1) 2^s = (k-1)2^k + 1$.\nFor $k=5$:\n$$ S = (5-1) 2^5 + 1 = 4 \\cdot 32 + 1 = 128 + 1 = 129 $$\nNow, the MAE is:\n$$ \\mathrm{MAE} = \\frac{1}{4} S = \\frac{129}{4} = 32.25 $$\nThis value is dimensionless in the product's integer domain and is already at four significant figures.\n\nFinal values to be reported are the energy savings in fJ and the MAE.\n- Expected energy savings: $11.25$ fJ\n- Expected mean absolute error: $32.25$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n11.25  32.25\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Analyzing a single approximate design is a crucial first step, but practical engineering involves navigating a vast space of possible designs. Given a library of components, each with a unique energy-error profile, we need a systematic way to identify the most efficient options. This practice  introduces a powerful technique from multi-objective optimization: the Pareto front. You will develop an algorithm to identify the set of non-dominated units, which collectively form the optimal trade-off curve, providing a formal basis for design selection in any resource-constrained scenario.",
            "id": "4256172",
            "problem": "Consider a library of approximate computational units in integrated circuits, where each unit is characterized by an energy consumption and an application-level error metric. Let the $i$-th unit be represented by the pair $\\left(E_{i}, \\epsilon_{i}\\right)$ where $E_{i}$ is the energy consumption in $\\mathrm{nJ}$ (nanojoules) and $\\epsilon_{i}$ is a dimensionless normalized error expressed as a decimal in the interval $[0,1]$. The goal is to compute the Pareto front of these units under the two objectives of minimizing energy and minimizing error, and then select a design that is feasible under a specified energy budget and error cap.\n\nBegin from the following fundamental bases:\n- The definition of energy as a physical resource that must be allocated within a budget, and the principle that error resilience requires adherence to an application-level error constraint.\n- The mathematical definition of Pareto dominance in multi-objective optimization: unit $i$ dominates unit $j$ if $E_{i} \\le E_{j}$ and $\\epsilon_{i} \\le \\epsilon_{j}$ and at least one of the inequalities is strict. A unit is Pareto-efficient (or non-dominated) if no other unit dominates it.\n\nUsing these foundations, you must design an algorithm that:\n1. Identifies all non-dominated units to form the Pareto front.\n2. Sorts the Pareto front by ascending energy, then ascending error, and finally ascending index to ensure a deterministic order.\n3. Given an energy budget $B$ (in $\\mathrm{nJ}$) and an error cap $C$ (dimensionless decimal), selects one unit among those satisfying $E_{i} \\le B$ and $\\epsilon_{i} \\le C$. Selection must prioritize minimal energy, break ties by minimal error, and then break any remaining ties by smallest index. If no unit satisfies both constraints, the selection should be $-1$.\n\nAll indices must be treated as starting from $0$. If two units have identical $\\left(E_{i}, \\epsilon_{i}\\right)$, both are considered non-dominated and should appear in the Pareto front.\n\nYour program must embed the following test suite of parameter values and process them exactly as specified:\n\n- Test case $1$:\n  - Units: $\\left(E_{i}, \\epsilon_{i}\\right)$ for $i \\in \\{0,1,2,3,4,5,6\\}$ given by\n    - $E$: $[1.20, 0.90, 0.85, 1.10, 0.95, 1.50, 0.85]$ $\\mathrm{nJ}$\n    - $\\epsilon$: $[0.040, 0.080, 0.060, 0.030, 0.050, 0.020, 0.030]$\n  - Budget $B$: $1.00$ $\\mathrm{nJ}$\n  - Error cap $C$: $0.050$\n- Test case $2$:\n  - Units: $\\left(E_{i}, \\epsilon_{i}\\right)$ for $i \\in \\{0,1,2,3,4\\}$ given by\n    - $E$: $[1.00, 1.00, 0.90, 0.90, 0.80]$ $\\mathrm{nJ}$\n    - $\\epsilon$: $[0.040, 0.040, 0.040, 0.050, 0.060]$\n  - Budget $B$: $0.90$ $\\mathrm{nJ}$\n  - Error cap $C$: $0.040$\n- Test case $3$:\n  - Units: $\\left(E_{i}, \\epsilon_{i}\\right)$ for $i \\in \\{0,1,2,3\\}$ given by\n    - $E$: $[0.50, 0.50, 0.50, 0.60]$ $\\mathrm{nJ}$\n    - $\\epsilon$: $[0.040, 0.030, 0.035, 0.025]$\n  - Budget $B$: $1.00$ $\\mathrm{nJ}$\n  - Error cap $C$: $0.040$\n- Test case $4$:\n  - Units: $\\left(E_{i}, \\epsilon_{i}\\right)$ for $i \\in \\{0,1,2\\}$ given by\n    - $E$: $[1.20, 1.10, 1.05]$ $\\mathrm{nJ}$\n    - $\\epsilon$: $[0.10, 0.09, 0.08]$\n  - Budget $B$: $1.00$ $\\mathrm{nJ}$\n  - Error cap $C$: $0.05$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must itself be a two-element list, whose first element is the list of Pareto front indices in the specified sorted order, and whose second element is the selected index (or $-1$ if infeasible). For example, an individual test case result should be formatted as $[[i_{1}, i_{2}, \\dots], s]$ where $[i_{1}, i_{2}, \\dots]$ are indices on the Pareto front and $s$ is the selected index.\n\nThe final single line should thus be of the form $[r_{1}, r_{2}, r_{3}, r_{4}]$ where each $r_{k}$ is one of the two-element lists described above.",
            "solution": "The problem presented is a classic exercise in multi-objective optimization, specifically applied to the domain of integrated circuit design under approximate computing paradigms. The task is to balance the conflicting objectives of minimizing energy consumption ($E$) and minimizing computational error ($\\epsilon$). The solution requires a rigorous application of Pareto analysis and a clear, deterministic selection process based on specified constraints and priorities.\n\nThe fundamental principles are provided:\n1.  **Resource Constraints**: Energy ($E$) is a finite resource governed by a budget $B$, while error ($\\epsilon$) must be kept below an application-specific tolerance cap $C$.\n2.  **Pareto Dominance**: A key concept for comparing solutions in a multi-objective space. A computational unit $i$, characterized by the pair $(E_i, \\epsilon_i)$, is said to dominate unit $j$ if it is at least as good in all objectives and strictly better in at least one. Formally, unit $i$ dominates unit $j$ if ($E_i \\le E_j$ and $\\epsilon_i \\le \\epsilon_j$) and ($E_i  E_j$ or $\\epsilon_i  \\epsilon_j$).\n\nA unit is termed **Pareto-efficient** (or non-dominated) if no other available unit in the design space dominates it. The set of all such non-dominated units constitutes the **Pareto front**. This front represents the set of all optimal trade-offs; for any point on the front, it is impossible to improve one objective without degrading the other.\n\nThe algorithmic solution is structured into three distinct, sequential steps as mandated by the problem.\n\n**Step 1: Identification of the Pareto Front**\nTo identify all non-dominated units, a systematic pairwise comparison across all available units is performed. For each unit $i$, we must determine if there exists any other unit $j$ that dominates it.\nThe algorithm proceeds as follows:\nFor each unit $i$ in the set of all units:\n- Assume, provisionally, that unit $i$ is non-dominated.\n- Iterate through every other unit $j$ (where $j \\ne i$).\n- For each $j$, check if it satisfies the dominance condition over $i$: $E_j \\le E_i$ and $\\epsilon_j \\le \\epsilon_i$, with at least one inequality being strict.\n- If such a unit $j$ is found, unit $i$ is confirmed to be dominated. We can immediately cease checking other units against $i$ and conclude it is not on the Pareto front.\n- If the entire set of other units is checked and no unit $j$ is found to dominate $i$, then the initial assumption holds, and unit $i$ is part of the Pareto front.\n\nThe indices of all units that are found to be non-dominated are collected to form the Pareto front set. Note that if two units $k$ and $l$ have identical characteristics, ($E_k, \\epsilon_k) = (E_l, \\epsilon_l)$, they do not dominate each other. If no other unit dominates them, both are included in the Pareto front.\n\n**Step 2: Sorting the Pareto Front**\nThe problem requires a deterministic ordering of the units on the Pareto front. This is achieved by sorting the identified non-dominated units based on a multi-level key. The primary sorting criterion is ascending energy consumption ($E_i$). Any ties in energy are resolved by the secondary criterion, ascending error ($\\epsilon_i$). If a tie persists (i.e., two distinct units on the front have identical energy and error values), it is broken by the tertiary criterion, the ascending original index ($i$) of the unit. This ensures a unique and consistent ordering of the Pareto front. The final output for this step is a sorted list of indices.\n\n**Step 3: Selection of the Optimal Feasible Unit**\nGiven an energy budget $B$ and an error cap $C$, the final step is to select a single optimal unit from the *entire* original set of units, not just from the Pareto front. A unit $i$ is considered **feasible** if it meets both constraints simultaneously: $E_i \\le B$ and $\\epsilon_i \\le C$.\n\nThe selection process is as follows:\n- First, filter the complete set of units to produce a subset containing only the feasible units.\n- If this feasible subset is empty (i.e., no unit satisfies both the budget and cap), then no solution is possible, and the selection result is denoted by $-1$.\n- If the feasible subset is non-empty, a single unit must be chosen based on a prioritized selection rule. The selected unit must be the one that offers the minimum energy consumption ($E_i$). If multiple feasible units share the same minimum energy, the tie is broken by choosing the one among them with the minimum error ($\\epsilon_i$). If a tie still remains, it is resolved by selecting the unit with the smallest original index ($i$). This hierarchical sorting is identical to the one used for the Pareto front, ensuring a unique best choice among the feasible options.\n\nThis three-step process correctly implements the principles of multi-objective optimization and constraint-based design selection.",
            "answer": "[[[6,3,5],6],[[4,2],2],[[1,3],1],[[2],-1]]"
        },
        {
            "introduction": "Modern systems, like deep neural networks, consist of multiple computational layers, each a candidate for approximation. This creates a complex, system-level design challenge: given a total error budget for the entire application, how should that budget be distributed among the individual components to achieve maximum energy savings? This final practice  tackles this classic resource allocation problem. You will implement an optimal greedy algorithm, grounded in the principle of diminishing returns, to learn how to intelligently allocate error to the components that yield the highest \"bang for the buck,\" a crucial skill for an architect of energy-efficient systems.",
            "id": "4256117",
            "problem": "Consider a workload composed of $L$ layers in an integrated circuit, each amenable to approximate computing within a controlled error budget. The goal is to allocate layer-wise error to minimize total energy while respecting a global Quality of Result (QoR) constraint. This problem resides in the domain of integrated circuits and Electronic Design Automation (EDA), focusing on approximate computing techniques and error resilience.\n\nAssume each layer $i \\in \\{1,\\dots,L\\}$ has a baseline energy $E_i^0$ measured in joules and supports a discrete error allocation in units of a normalized error quantum $\\Delta e$. For this problem, take $\\Delta e$ to be $1$ unit. Let $w_i$ be the QoR weight for layer $i$, so that one unit of error allocated to layer $i$ consumes $w_i$ units of the global QoR budget. The global QoR budget is $B$, and the constraint is $\\sum_{i=1}^L w_i e_i \\le B$, where $e_i$ is the integer number of error quanta allocated to layer $i$. The baseline energy $E_i^0$ decreases with $e_i$ due to approximate computing, with diminishing returns.\n\nEach layer $i$ is described by a discrete marginal energy-saving curve, represented as a finite sequence $\\{m_{i,1}, m_{i,2}, \\dots, m_{i,K_i}\\}$, where $m_{i,k}$ is the energy saved (in joules) by assigning the $k$-th unit of error to layer $i$ relative to the previous allocation level. The sequences are non-increasing in $k$ to reflect diminishing returns, and all $m_{i,k} \\ge 0$. The total energy saved for layer $i$ when allocating $e_i$ units is $\\sum_{k=1}^{e_i} m_{i,k}$, and the final energy of the entire workload is $\\sum_{i=1}^L \\left(E_i^0 - \\sum_{k=1}^{e_i} m_{i,k}\\right)$, measured in joules.\n\nTask: Given $(E_i^0)$, $(w_i)$, the marginal energy-saving sequences $(m_{i,k})$, and the global budget $B$, compute the error allocation integers $(e_i)$ that minimize total energy subject to the QoR constraint $\\sum_{i=1}^L w_i e_i \\le B$. The program must implement a principled algorithm grounded in first principles, without using any external optimization packages. The final computed energies must be reported in joules.\n\nFundamental base to use for derivation and algorithm design:\n- Separation of variables across layers where the total energy is the sum of per-layer energies.\n- Convexity and monotonicity concepts for diminishing marginal savings.\n- Lagrange multiplier optimality conditions for continuous separable problems, and their discrete approximation by thresholding marginals.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\text{[result1,result2,result3]}$).\n- Each result must be the final total energy in joules for the corresponding test case, expressed as a floating-point number.\n\nUnits and numerical specifications:\n- Energy must be reported in joules.\n- Error quanta are dimensionless normalized units with $\\Delta e = 1$.\n- The output must be floats.\n\nTest suite:\nImplement your program for the following four test cases. Each test case is a tuple specifying $(E^0, w, M, B)$, where $E^0$ is the list $[E_1^0,\\dots,E_L^0]$ in joules, $w$ is the list $[w_1,\\dots,w_L]$, $M$ is the list of lists of marginal savings per layer (each inner list is $\\{m_{i,1},\\dots\\}$ in joules), and $B$ is the global budget (an integer).\n\n- Test case $1$ (happy path, uniform weights):\n  - $E^0 = [1.2, 1.0, 0.8]$\n  - $w = [1, 1, 1]$\n  - $M = [[0.15, 0.12, 0.08, 0.04], [0.18, 0.10, 0.06], [0.10, 0.07, 0.05, 0.03]]$\n  - $B = 5$\n\n- Test case $2$ (boundary, zero budget):\n  - $E^0 = [0.9, 1.1]$\n  - $w = [1, 1]$\n  - $M = [[0.20, 0.10], [0.30]]$\n  - $B = 0$\n\n- Test case $3$ (weighted QoR costs, heterogeneous layers):\n  - $E^0 = [2.0, 1.5, 1.0]$\n  - $w = [1, 2, 3]$\n  - $M = [[0.50, 0.40, 0.30], [0.90, 0.50], [1.10, 0.60]]$\n  - $B = 5$\n\n- Test case $4$ (budget exceeds capacity, saturation):\n  - $E^0 = [0.5, 0.5]$\n  - $w = [1, 1]$\n  - $M = [[0.10, 0.05], [0.08]]$\n  - $B = 10$\n\nAlgorithmic requirement:\n- The algorithm must allocate error units by selecting discrete increments across layers that maximize energy savings per unit of QoR consumption, i.e., prioritize increments with the highest ratios $m_{i,k} / w_i$, respecting the diminishing returns within each layer and the global budget $B$. If the remaining budget is less than the cost $w_i$ of an increment, the increment cannot be partially taken and must be skipped.\n\nYour program must compute the final total energy for each test case and output them in the specified single-line format as floats in joules.",
            "solution": "The problem presented is a constrained optimization task concerning energy minimization in an integrated circuit through approximate computing. We are asked to determine the optimal allocation of discrete error quanta, $e_i$, to each of $L$ layers to minimize the total energy consumption, subject to a global Quality of Result (QoR) budget, $B$.\n\nFirst, we formalize the problem statement. The total energy of the system is given by:\n$$\nE_{total}(e_1, \\dots, e_L) = \\sum_{i=1}^L \\left(E_i^0 - \\sum_{k=1}^{e_i} m_{i,k}\\right)\n$$\nwhere $E_i^0$ is the baseline energy of layer $i$, and $m_{i,k}$ is the marginal energy saving from applying the $k$-th unit of error to layer $i$. The variables to be determined are the integers $e_i \\ge 0$. Minimizing $E_{total}$ is equivalent to maximizing the total energy savings, $S_{total}$:\n$$\n\\text{Maximize } S_{total}(e_1, \\dots, e_L) = \\sum_{i=1}^L S_i(e_i) = \\sum_{i=1}^L \\left(\\sum_{k=1}^{e_i} m_{i,k}\\right)\n$$\nThis maximization is subject to the linear budget constraint:\n$$\n\\sum_{i=1}^L w_i e_i \\le B\n$$\nwhere $w_i$ is the QoR cost per unit of error for layer $i$.\n\nThis problem structure is a classic discrete resource allocation problem, which can be viewed as a variation of the integer knapsack problem. The objective function, $S_{total}$, is separable, meaning the total saving is a sum of savings from individual layers. Furthermore, the property that the marginal savings $\\{m_{i,k}\\}$ are non-increasing in $k$ ($m_{i,k} \\ge m_{i,k+1}$) implies that each individual savings function $S_i(e_i)$ is a discrete concave function. This property of diminishing returns is crucial.\n\nFor a separable, concave objective function with a single linear budget constraint, a greedy algorithm provides the optimal solution. The theoretical justification for this can be understood through an analogy with the method of Lagrange multipliers for continuous optimization. The optimality condition for a continuous analogue would be to equalize the marginal utility per unit cost across all allocations. That is, for a Lagrange multiplier $\\lambda$, we would have $\\frac{\\partial S_i / \\partial e_i}{w_i} = \\lambda$ for all $i$.\n\nIn our discrete case, the marginal utility (or marginal saving) of applying the $(e_i+1)$-th error unit to layer $i$ is $m_{i, e_i+1}$, and its cost is $w_i$. The ratio $m_{i, e_i+1} / w_i$ represents the \"bang for the buck,\" or the marginal energy saving per unit of QoR budget consumed. The greedy strategy, therefore, is to iteratively apply the error increment that offers the highest possible ratio of $m_{i,k}/w_i$ at each step, until the budget $B$ is exhausted or no further affordable increments exist.\n\nTo implement this strategy efficiently, a max-priority queue (or max-heap) is the ideal data structure. The heap will store the next available error increment for each layer, prioritized by the ratio $m_{i,k}/w_i$. The algorithm proceeds as follows:\n\n1.  Initialize the total accumulated energy saving to $0$ and the budget spent to $0$. The initial total energy is $E_{initial} = \\sum_{i=1}^L E_i^0$.\n2.  Create a max-priority queue. For each layer $i \\in \\{1,\\dots,L\\}$, if its marginal savings list $\\{m_{i,k}\\}$ is non-empty, calculate the ratio for its first error increment, $m_{i,1}/w_i$. Insert this increment, along with its saving $m_{i,1}$, cost $w_i$, layer index $i$, and increment index $k=1$, into the priority queue, with the ratio as its priority.\n3.  Enter a loop that continues as long as the priority queue is not empty.\n4.  In each iteration, extract the element with the highest priority (the highest $m_{i,k}/w_i$ ratio) from the queue. Let this correspond to the $k$-th increment for layer $i$, with saving $m_{i,k}$ and cost $w_i$.\n5.  Check if this increment is affordable by comparing its cost $w_i$ with the remaining budget. If the budget spent so far plus $w_i$ does not exceed the total budget $B$, the increment is taken.\n6.  If affordable, add the saving $m_{i,k}$ to the total accumulated savings and add the cost $w_i$ to the total budget spent. Then, if layer $i$ has a next available error increment (i.e., at index $k+1$), insert this new increment into the priority queue.\n7.  If the extracted increment is not affordable, it is discarded. The algorithm proceeds to the next-highest-priority item in the queue, effectively skipping unaffordable options.\n8.  The loop terminates when the queue is exhausted or when all remaining increments in the queue are individually too expensive for the remaining budget.\n9.  The final minimized total energy is calculated as $E_{final} = E_{initial} - S_{total}$, where $S_{total}$ is the total accumulated saving. This algorithm guarantees an optimal solution due to the problem's mathematical structure.",
            "answer": "[2.35,2.0,3.1,0.77]"
        }
    ]
}