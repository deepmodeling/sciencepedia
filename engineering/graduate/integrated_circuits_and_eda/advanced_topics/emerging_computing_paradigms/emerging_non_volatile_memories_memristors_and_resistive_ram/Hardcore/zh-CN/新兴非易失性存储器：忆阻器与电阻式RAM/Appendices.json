{
    "hands_on_practices": [
        {
            "introduction": "电流-电压（$I-V$）平面上的捏滞回线是忆阻器的标志性特征。本实践练习要求您从一个基础的器件模型出发，推导该回线面积与驱动信号频率之间的关系。通过完成这一分析，您将对忆阻器的动态、频率依赖行为获得更深刻的定量理解。",
            "id": "4269981",
            "problem": "用于阻变随机存取存储器 (ReRAM) 的阻性开关器件，为了进行电路级分析和电子设计自动化 (EDA)，可以被建模为一个电流控制的忆阻器。考虑一个单端口器件，其本构关系为 $v(t)=M(x(t))\\,i(t)$，其中 $v(t)$ 是端电压，$i(t)$ 是端电流，$M(x)$ 是依赖于内部状态 $x(t)$ 的忆阻值。内部状态遵循漂移型演化定律 $dx/dt = k\\,i(t)$，其中 $k$ 是一个由底层离子输运决定的正常数。假设该器件由一个正弦电压源 $v(t)=V_{0}\\,\\sin(\\omega t)$ 驱动，其角频率 $\\omega0$，振幅 $V_{0}0$。在选定的工作点 $x=0$ 附近，假设忆阻值可以由线性展开 $M(x)=M_{0}+\\beta\\,x$ 很好地近似，其中 $M_{0}0$ 是标称忆阻值，$\\beta$ 量化了对状态的敏度。\n\n在低失真极限下进行分析，即忆阻值依赖于状态的变化远小于其标称值，具体来说，对于所有 $t$ 都有 $|\\beta\\,x(t)|\\ll M_{0}$。在此假设下，推导在施加电压的半个周期内（即，对于 $t\\in[0,\\pi/\\omega]$ 且 $v(t)\\ge 0$），电流-电压平面中单个磁滞回线瓣面积的闭合形式领头阶解析表达式。将回线瓣面积定义为环路积分\n$$\nA_{\\text{lobe}} \\equiv \\int_{0}^{\\pi/\\omega} i(t)\\,\\frac{dv(t)}{dt}\\,dt,\n$$\n并忽略小参数 $\\beta$ 的超过一阶的项。\n\n你的最终答案必须是使用 $M_{0}$、$\\beta$、$k$、$V_{0}$ 和 $\\omega$ 表示的单个闭合形式解析表达式。使用物理单位安培-伏特 (A·V)（等效于瓦特 (W)）表示该面积，但不要在方框内的答案中包含单位。不需要进行数值计算或四舍五入。",
            "solution": "目标是在低失真极限 $|\\beta x(t)| \\ll M_{0}$ 下，计算由积分\n$$\nA_{\\text{lobe}} = \\int_{0}^{\\pi/\\omega} i(t)\\,\\frac{dv(t)}{dt}\\,dt\n$$\n定义的磁滞回线瓣面积。该极限意味着参数 $\\beta$ 足够小，可以作为微扰参数处理。我们将计算到 $\\beta$ 的一阶。\n\n施加的电压由 $v(t) = V_{0}\\sin(\\omega t)$ 给出。其时间导数为\n$$\n\\frac{dv(t)}{dt} = \\omega V_{0}\\cos(\\omega t)\n$$\n接下来，我们需要找到电流 $i(t)$ 的表达式。根据本构关系，我们有\n$$\ni(t) = \\frac{v(t)}{M(x(t))} = \\frac{v(t)}{M_{0} + \\beta x(t)} = \\frac{v(t)}{M_{0}\\left(1 + \\frac{\\beta x(t)}{M_{0}}\\right)}\n$$\n在条件 $|\\beta x(t)| \\ll M_{0}$ 下，我们可以对小的 $z$ 使用泰勒展开 $(1+z)^{-1} \\approx 1-z$。这里，$z = \\frac{\\beta x(t)}{M_{0}}$。这给出了一阶 $\\beta$ 的电流：\n$$\ni(t) \\approx \\frac{v(t)}{M_{0}}\\left(1 - \\frac{\\beta x(t)}{M_{0}}\\right) = \\frac{v(t)}{M_{0}} - \\frac{\\beta}{M_{0}^2}v(t)x(t)\n$$\n这个 $i(t)$ 的表达式依赖于状态变量 $x(t)$。为了在我们的阶近似中保持一致性，我们需要找到一个至少精确到 $\\beta$ 零阶的 $x(t)$ 表达式。我们通过在状态演化方程中使用零阶电流 $i_0(t)$ 来获得这个表达式。零阶电流是当 $\\beta=0$ 时的电流，即流过固定电阻 $M_0$ 的电流：\n$$\ni_0(t) = \\frac{v(t)}{M_{0}} = \\frac{V_{0}}{M_{0}}\\sin(\\omega t)\n$$\n现在，我们在状态演化方程 $\\frac{dx}{dt} = k i(t)$ 中使用它。取领头阶，\n$$\n\\frac{dx}{dt} \\approx k i_0(t) = \\frac{k V_{0}}{M_{0}}\\sin(\\omega t)\n$$\n我们对这个方程关于时间积分来求 $x(t)$。假设在 $t=0$ 时有一个初始状态 $x(0)$。\n$$\nx(t) = x(0) + \\int_{0}^{t} \\frac{k V_{0}}{M_{0}}\\sin(\\omega \\tau) d\\tau = x(0) + \\frac{k V_{0}}{M_{0}} \\left[-\\frac{\\cos(\\omega \\tau)}{\\omega}\\right]_{0}^{t}\n$$\n$$\nx(t) = x(0) + \\frac{k V_{0}}{M_{0}\\omega}(1 - \\cos(\\omega t))\n$$\n现在将这个 $x(t)$ 的表达式代回到我们的一阶 $i(t)$ 表达式中：\n$$\ni(t) \\approx \\frac{v(t)}{M_{0}} - \\frac{\\beta}{M_{0}^2}v(t)\\left[x(0) + \\frac{k V_{0}}{M_{0}\\omega}(1 - \\cos(\\omega t))\\right]\n$$\n代入 $v(t)=V_0 \\sin(\\omega t)$：\n$$\ni(t) \\approx \\frac{V_{0}}{M_{0}}\\sin(\\omega t) - \\frac{\\beta V_{0} x(0)}{M_{0}^2}\\sin(\\omega t) - \\frac{\\beta k V_{0}^2}{M_{0}^3 \\omega}\\sin(\\omega t)(1 - \\cos(\\omega t))\n$$\n我们现在可以构建 $A_{\\text{lobe}}$ 的被积函数，即 $i(t) \\frac{dv}{dt}$。我们将 $i(t)$ 的表达式乘以 $\\frac{dv}{dt} = \\omega V_{0}\\cos(\\omega t)$。\n$$\ni(t)\\frac{dv(t)}{dt} \\approx \\left[ \\frac{V_{0}}{M_{0}}\\sin(\\omega t) - \\frac{\\beta V_{0} x(0)}{M_{0}^2}\\sin(\\omega t) - \\frac{\\beta k V_{0}^2}{M_{0}^3 \\omega}\\sin(\\omega t)(1 - \\cos(\\omega t)) \\right] \\omega V_{0}\\cos(\\omega t)\n$$\n展开此表达式，我们得到三项：\n$$\ni(t)\\frac{dv(t)}{dt} \\approx \\frac{\\omega V_{0}^2}{M_{0}}\\sin(\\omega t)\\cos(\\omega t) - \\frac{\\omega \\beta V_{0}^2 x(0)}{M_{0}^2}\\sin(\\omega t)\\cos(\\omega t) - \\frac{\\beta k V_{0}^3}{M_{0}^3}\\sin(\\omega t)\\cos(\\omega t)(1 - \\cos(\\omega t))\n$$\n我们需要将此表达式从 $t=0$ 积分到 $t=\\pi/\\omega$。让我们分析各分量的积分。\n前两项包含乘积 $\\sin(\\omega t)\\cos(\\omega t) = \\frac{1}{2}\\sin(2\\omega t)$。这一项的积分是：\n$$\n\\int_{0}^{\\pi/\\omega} \\sin(2\\omega t) dt = \\left[-\\frac{\\cos(2\\omega t)}{2\\omega}\\right]_{0}^{\\pi/\\omega} = -\\frac{1}{2\\omega}(\\cos(2\\pi) - \\cos(0)) = -\\frac{1}{2\\omega}(1-1) = 0\n$$\n因此，第一项（纯电阻部分）的积分为零，第二项（与初始状态 $x(0)$ 相关）的积分也为零。这方便地表明，第一个半周期的回线瓣面积与初始状态 $x(0)$ 无关。\n\n我们剩下第三项需要积分：\n$$\nA_{\\text{lobe}} = \\int_{0}^{\\pi/\\omega} - \\frac{\\beta k V_{0}^3}{M_{0}^3}\\sin(\\omega t)\\cos(\\omega t)(1 - \\cos(\\omega t)) dt\n$$\n$$\nA_{\\text{lobe}} = -\\frac{\\beta k V_{0}^3}{M_{0}^3} \\int_{0}^{\\pi/\\omega} (\\sin(\\omega t)\\cos(\\omega t) - \\sin(\\omega t)\\cos^2(\\omega t)) dt\n$$\n正如已确定的，$\\sin(\\omega t)\\cos(\\omega t)$ 部分的积分为零。因此，表达式简化为：\n$$\nA_{\\text{lobe}} = -\\frac{\\beta k V_{0}^3}{M_{0}^3} \\int_{0}^{\\pi/\\omega} (-\\sin(\\omega t)\\cos^2(\\omega t)) dt = \\frac{\\beta k V_{0}^3}{M_{0}^3} \\int_{0}^{\\pi/\\omega} \\sin(\\omega t)\\cos^2(\\omega t) dt\n$$\n为了解这个积分，我们进行换元。令 $u = \\cos(\\omega t)$。则 $du = -\\omega \\sin(\\omega t) dt$，这意味着 $\\sin(\\omega t) dt = -\\frac{du}{\\omega}$。积分限变化如下：\n当 $t=0$ 时，$u = \\cos(0) = 1$。\n当 $t=\\pi/\\omega$ 时，$u = \\cos(\\pi) = -1$。\n将这些代入积分中：\n$$\nA_{\\text{lobe}} = \\frac{\\beta k V_{0}^3}{M_{0}^3} \\int_{1}^{-1} u^2 \\left(-\\frac{du}{\\omega}\\right) = \\frac{\\beta k V_{0}^3}{\\omega M_{0}^3} \\int_{-1}^{1} u^2 du\n$$\n$u^2$ 的积分很简单：\n$$\n\\int_{-1}^{1} u^2 du = \\left[\\frac{u^3}{3}\\right]_{-1}^{1} = \\frac{1^3}{3} - \\frac{(-1)^3}{3} = \\frac{1}{3} - \\left(-\\frac{1}{3}\\right) = \\frac{2}{3}\n$$\n将此结果代回，我们得到回线瓣面积的最终表达式：\n$$\nA_{\\text{lobe}} = \\frac{\\beta k V_{0}^3}{\\omega M_{0}^3} \\cdot \\frac{2}{3} = \\frac{2\\beta k V_{0}^3}{3\\omega M_{0}^3}\n$$\n这就是所要求的，在电流-电压平面中半个周期内磁滞回线瓣面积的领头阶解析表达式。它是 $\\beta$ 的一阶项，并用给定的参数表示。",
            "answer": "$$\n\\boxed{\\frac{2\\beta k V_{0}^{3}}{3 M_{0}^{3} \\omega}}\n$$"
        },
        {
            "introduction": "简单的模型虽然实用，但往往在器件工作的物理边界处失效。本实践探讨了“窗口函数”这一关键概念，它对于确保忆阻器的状态变量保持在物理边界内至关重要。通过分析“朴素”模型与引入窗口函数的模型之间的差异，您将掌握构建稳健且精确的紧凑模型的一项基本原则。",
            "id": "4269927",
            "problem": "一个阻性随机存取存储器 (ReRAM) 单元可以被建模为一个忆阻器件，其内部状态为归一化的导电细丝长度 $x \\in [0,1]$，其中 $x=0$ 表示完全未掺杂（高阻）状态，$x=1$ 表示完全掺杂（低阻）状态。一个常见的第一性原理出发点是漂移主导的离子输运，其中平均漂移速度与电场成正比，迁移率为 $\\mu$，并且离子种类的连续性意味着掺杂区的边界以前进的局部漂移速度扩展。在集总近似和按器件长度进行归一化的情况下，一个标准的内部状态降阶模型是\n$$\n\\frac{dx}{dt} = k\\,i(t),\n$$\n其中 $k0$ 是由几何形状和迁移率决定的常数，$i(t)$ 是端点电流。然而，这个朴素的线性漂移方程允许 $x$ 在持续激励下演化到物理边界 $[0,1]$ 之外。为了强制 $x$ 保持在 $[0,1]$ 范围内，电子设计自动化 (EDA) 模型引入了一个窗口函数 $f(x)$，得到\n$$\n\\frac{dx}{dt} = k\\,i(t)\\,f(x),\n$$\n其中 $f(x)$ 的设计旨在减缓边界附近的漂移，并满足 $f(0)=f(1)=0$ 以及对于 $x \\in (0,1)$ 有 $f(x)0$。\n\n假设 $i(t)$ 是有界且分段连续的，$f(x)$ 在 $[0,1]$ 上连续且在 $(0,1)$ 上局部利普希茨。考虑这两个模型的物理动因和数学推论。下列哪个陈述是正确的？\n\nA. 在恒定正电流 $i(t)=I_00$ 下，朴素模型 $\\frac{dx}{dt}=k I_0$ 产生线性增长 $x(t)=x(0)+k I_0 t$，这可能在有限时间内超过 1，这是非物理的，因为掺杂区不能生长到器件之外。相反，如果 $f(0)=f(1)=0$ 且在 $(0,1)$ 上 $f(x)0$，那么对于加窗模型，区间 $[0,1]$ 是前向不变的，从而防止了边界违例。\n\nB. 如果 $f(x)$ 在 $[0,1]$ 上连续，在 $(0,1)$ 上局部利普希茨，$f(0)=f(1)=0$，且对于 $x \\in (0,1)$ 有 $f(x)0$，那么对于任何有界可测电流 $i(t)$ 和任何初始条件 $x(0)\\in[0,1]$，$\\frac{dx}{dt}=k\\,i(t)\\,f(x)$ 的每个 Carathéodory 解在所有 $t\\ge 0$ 时都保持在 $[0,1]$ 内。\n\nC. 窗口函数必须围绕 $x=\\tfrac{1}{2}$ 对称，例如 $f(x)=x(1-x)$，否则忆阻模型必然违反无源性。\n\nD. 在朴素模型 $\\frac{dx}{dt}=k\\,i(t)$ 中，通过在每个积分步后将 $x$ 限幅到 $[0,1]$ 来数值上强制实现硬饱和，在连续时间动力学层面上，这与引入一个满足 $f(0)=f(1)=0$ 的平滑窗口函数是物理等效的。\n\nE. 窗口函数 $f(x)$ 的主要目的是保证忆阻值 $M(x)$ 在整个范围 $x \\in [0,1]$ 上是 $x$ 的线性函数。\n\n选择所有适用项。",
            "solution": "问题陈述提出了两种模型，用于描述忆阻器内部状态变量 $x$ 的时间演化，该变量代表导电细丝的归一化长度。状态 $x$ 在物理上被限制在区间 $[0,1]$ 内。\n\n朴素模型由以下常微分方程 (ODE) 给出：\n$$\n\\frac{dx}{dt} = k\\,i(t)\n$$\n其中 $k  0$ 是一个常数，$i(t)$ 是输入电流。\n\n加窗模型由以下公式给出：\n$$\n\\frac{dx}{dt} = k\\,i(t)\\,f(x)\n$$\n其中 $f(x)$ 是一个具有以下性质的窗口函数：\n1.  $f(x)$ 在 $[0,1]$ 上连续。\n2.  $f(x)$ 在 $(0,1)$ 上局部利普希茨。\n3.  $f(0) = 0$ 且 $f(1) = 0$。\n4.  对于 $x \\in (0,1)$ 有 $f(x)  0$。\n\n输入电流 $i(t)$ 假定为有界且分段连续的。任务是评估比较这些模型及其性质的五个陈述的正确性。\n\n**A. 在恒定正电流 $i(t)=I_00$ 下，朴素模型 $\\frac{dx}{dt}=k I_0$ 产生线性增长 $x(t)=x(0)+k I_0 t$，这可能在有限时间内超过 1，这是非物理的，因为掺杂区不能生长到器件之外。相反，如果 $f(0)=f(1)=0$ 且在 $(0,1)$ 上 $f(x)0$，那么对于加窗模型，区间 $[0,1]$ 是前向不变的，从而防止了边界违例。**\n\n该陈述由两部分组成。第一部分：朴素模型分析。对于 $i(t) = I_0  0$，朴素模型为 $\\frac{dx}{dt} = k I_0$。积分得到 $x(t) = x(0) + k I_0 t$。这是一个时间的线性函数。如果 $x(0)  1$，模型预测 $x(t)$ 将在有限时间内超过1，这是非物理的。陈述的第一部分是正确的。第二部分：加窗模型分析。区间 $[0,1]$ 的前向不变性是核心。对于一个常微分方程 $\\frac{dx}{dt} = G(t,x)$，闭区间 $[a,b]$ 不变性的一个充分条件是矢量场在边界处不指向外部。在边界 $x=0$ 处，$G(t,0) = k\\,i(t)\\,f(0) = 0$。在边界 $x=1$ 处，$G(t,1) = k\\,i(t)\\,f(1) = 0$。由于状态演化在边界处为零，轨迹无法离开该区间。因此，区间 $[0,1]$ 是前向不变的，这防止了非物理的边界违例。陈述的第二部分也是正确的。因此，整个陈述是正确的。\n**结论：正确**\n\n**B. 如果 $f(x)$ 在 $[0,1]$ 上连续，在 $(0,1)$ 上局部利普希茨，$f(0)=f(1)=0$，且对于 $x \\in (0,1)$ 有 $f(x)0$，那么对于任何有界可测电流 $i(t)$ 和任何初始条件 $x(0)\\in[0,1]$，$\\frac{dx}{dt}=k\\,i(t)\\,f(x)$ 的每个 Carathéodory 解在所有 $t\\ge 0$ 时都保持在 $[0,1]$ 内。**\n\n这个陈述是陈述 A 第二部分的一个更数学化的形式。它将“分段连续”电流推广到“有界可测”电流，这使得提及 Carathéodory 解成为必要。然而，核心论点保持不变：集合 $[0,1]$ 的不变性。对 $f(x)$ 和 $i(t)$ 的条件足以保证 Carathéodory 解的存在。不变性论证的关键在于边界处矢量场的行为，正如对选项 A 的分析。矢量场 $G(t,x) = k\\,i(t)\\,f(x)$ 在 $x=0$ 和 $x=1$ 处等于 $0$，这是由于 $f(0)=f(1)=0$ 的性质。这对任何 $t$ 和任何有界电流 $i(t)$ 的值都成立。这确保了没有解可以穿过边界。该陈述是微分方程理论中关于集合不变性的一个标准结果（Nagumo 定理的一个应用）。这是一个严格正确的陈述。\n**结论：正确**\n\n**C. 窗口函数必须围绕 $x=\\tfrac{1}{2}$ 对称，例如 $f(x)=x(1-x)$，否则忆阻模型必然违反无源性。**\n\n该陈述将窗口函数 $f(x)$ 的对称性与忆阻器的无源性联系起来。无源性要求传递给器件的总能量始终为非负。瞬时功率 $p(t) = v(t)i(t) = M(x(t))i(t)^2$。只要忆阻值 $M(x)$ 始终为非负，器件就是无源的。窗口函数 $f(x)$ 控制的是状态动力学 $\\frac{dx}{dt}$，它与忆阻函数 $M(x)$ 是模型的独立部分。$f(x)$ 的对称性与 SET 和 RESET 动力学的对称性有关。一个非对称的 $f(x)$ 可以模型化非对称的开关行为（例如，开启比关闭快），这在实验中很常见，并且不违反无源性。因此，该陈述根本上是错误的。\n**结论：错误**\n\n**D. 在朴素模型 $\\frac{dx}{dt}=k\\,i(t)$ 中，通过在每个积分步后将 $x$ 限幅到 $[0,1]$ 来数值上强制实现硬饱和，在连续时间动力学层面上，这与引入一个满足 $f(0)=f(1)=0$ 的平滑窗口函数是物理等效的。**\n\n该陈述声称两种边界强制方法之间存在等效性。限幅方法对应于一个系统，其中状态在有限时间内到达边界，然后突然停止。相反，对于一个平滑的窗口函数 $f(x)$，当 $x$ 接近边界时，速度 $\\frac{dx}{dt}$ 会平滑地趋近于零。状态通常是渐近地接近边界。由于这两种方法产生的状态演化轨迹 $x(t)$ 是不同的（一种是平滑的，另一种在边界处是连续但不一定可微的），因此这两个模型在物理上或数学上都不是等效的。\n**结论：错误**\n\n**E. 窗口函数 $f(x)$ 的主要目的是保证忆阻值 $M(x)$ 在整个范围 $x \\in [0,1]$ 上是 $x$ 的线性函数。**\n\n该陈述错误地识别了窗口函数的作用。正如问题描述中明确指出的，$f(x)$ 的目的是“为了强制 $x$ 保持在 $[0,1]$ 范围内”。窗口函数修改的是状态动力学方程 $\\frac{dx}{dt}$。忆阻值与状态之间的关系 $M(x)$ 是模型的另一个独立部分。窗口函数的目的不是强制 $M(x)$ 具有任何特定形式。\n**结论：错误**",
            "answer": "$$\\boxed{AB}$$"
        },
        {
            "introduction": "一个理论上合理的模型在电路仿真器（如SPICE）中实现时，还必须保证数值稳定性。本练习旨在解决在直流（DC）工作点分析中常见的“隐藏状态漂移”这一实际挑战，该问题常常困扰着电路仿真。通过设计一个能在零偏压下保证稳定性的状态演化法则，您将获得创建可用于EDA工具集成的、可靠的紧凑模型的实践经验。",
            "id": "4270006",
            "problem": "一个被建模为忆阻器的两端电阻式存储元件，其特性由一个调节其电导的隐藏内部状态变量来描述。设内部状态为标量变量 $x$，受器件物理原理约束在区间 $[0,1]$ 内，端电压为 $v$，端电流为 $i$。基本的器件级关系分别由状态方程和电流-电压关系给出：$ddt(x)=f(v,x)$ 和 $i=v/R(x)$，其中 $ddt(\\cdot)$ 表示 Verilog-A 语言中的时间导数算子，$f(v,x)$ 是一个依赖于电压和状态的演化定律，$R(x)$ 是一个单调电阻函数，满足 $R(0)=R_{\\mathrm{off}}$ 和 $R(1)=R_{\\mathrm{on}}$，且 $R_{\\mathrm{on}}  R_{\\mathrm{off}}$。在直流工作点计算中，例如由 SPICE (集成电路通用模拟程序) 执行的计算，静态条件对应于 $ddt(x)=0$。如果演化定律允许 $f(0,x)\\neq 0$，就会在工作点出现隐藏状态漂移，因为静态 $v=0$ 的情况与一个非零的 $ddt(x)$ 兼容，这在物理上是不一致的，并且对工作点求解在数值上是有害的。\n\n从这些核心定义出发，设计一个数学上一致的策略，通过强制执行 $f(0,x)=0$ 对所有 $x\\in[0,1]$ 成立，来防止静态工作点中的隐藏状态漂移。您的策略必须采用适用于紧凑建模和集成电路仿真的平滑性和无源性考量。然后，通过为 $R(x)$ 和 $f(v,x)$ 选择满足所述约束的特定函数形式来实例化一个具体模型，并构建一个与之对比的“朴素”演化定律，该定律对于一般的 $x$ 值会违反漂移防止条件。这些函数必须在 $x$ 和 $v$ 上可微且物理上合理。电阻 $R(x)$ 必须在 $x$ 上是单调的，并且界于 $R_{\\mathrm{on}}$ 和 $R_{\\mathrm{off}}$ 之间。演化定律 $f(v,x)$ 必须包含一个在物理边界 $x=0$ 和 $x=1$ 处消失的窗口机制，以避免非物理的状态偏移，并且在防止漂移的设计下必须确保对所有 $x$ 都有 $f(0,x)=0$，而朴素演化定律对于 $x\\in(0,1)$ 必须通常产生 $f(0,x)\\neq 0$。\n\n实现一个程序，对于每个提供的测试用例，执行以下计算：\n- 使用一个小的容差 $\\varepsilon$ 评估条件 $|f(0,x)|\\le \\varepsilon$，以判断静态工作点是否避免了隐藏状态漂移。将结果报告为一个布尔值。\n- 使用电阻函数和给定的状态 $x$，在指定的评估电压 $v$ 下计算端电流 $i=v/R(x)$。将电流报告为一个以安培为单位的浮点数。\n\n使用 $\\varepsilon$ 作为一个固定的微小正常数，并在解决方案中证明其选择的合理性。所有物理量必须以国际单位制报告，具体来说，$v$ 的单位是伏特，$i$ 的单位是安培。此问题不涉及角度。您的程序必须生成其最终输出，格式为单行文本，其中包含一个由方括号括起来的、所有测试用例结果的逗号分隔列表，每个测试用例的结果本身是一个形式为 $[drift\\_ok,current]$ 的双元素列表，其中 $drift\\_ok$ 是一个布尔值，$current$ 是一个浮点数，例如 $[[\\mathrm{True},0.1],[\\mathrm{False},0.2]]$。\n\n测试套件规格和覆盖范围：\n- 选择窗口函数 $W(x)$ 为一个平滑函数，满足 $W(0)=0$，$W(1)=0$，且对于 $x\\in(0,1)$ 有 $W(x)0$，并在防止漂移的设计和朴素定律中一致地使用它。使用一个防止漂移的设计，其中 $f(v,x)$ 在 $v$ 上是奇函数并对所有 $x$ 满足 $f(0,x)=0$；以及一个朴素定律，其中对于一般的 $x\\in(0,1)$ 有 $f(0,x)\\neq 0$。\n- 对于电阻函数，使用一个从 $[0,1]$ 到 $[R_{\\mathrm{on}},R_{\\mathrm{off}}]$ 的平滑单调函数。\n- 程序必须评估以下四个测试用例，这些用例共同检验了正常路径、边界行为和一个有问题的漂移场景。在每个案例中，报告布尔漂移指示符和以安培为单位的电流：\n    1. 参数：$R_{\\mathrm{on}}=100\\,\\Omega$，$R_{\\mathrm{off}}=16000\\,\\Omega$，状态 $x=0.3$，防止漂移的演化定律，评估电压 $v=1.0\\,\\mathrm{V}$。\n    2. 参数：$R_{\\mathrm{on}}=100\\,\\Omega$，$R_{\\mathrm{off}}=16000\\,\\Omega$，状态 $x=0.0$，朴素演化定律，评估电压 $v=2.0\\,\\mathrm{V}$。\n    3. 参数：$R_{\\mathrm{on}}=100\\,\\Omega$，$R_{\\mathrm{off}}=16000\\,\\Omega$，状态 $x=1.0$，防止漂移的演化定律，评估电压 $v=0.1\\,\\mathrm{V}$。\n    4. 参数：$R_{\\mathrm{on}}=100\\,\\Omega$，$R_{\\mathrm{off}}=16000\\,\\Omega$，状态 $x=0.5$，朴素演化定律，评估电压 $v=1.0\\,\\mathrm{V}$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔的结果列表（例如，$[[\\mathrm{True},0.0001],[\\mathrm{False},0.02],[\\mathrm{True},6.25\\mathrm{e}{-6}],[\\mathrm{False},0.00012]]$）。",
            "solution": "问题的核心在于忆阻器的状态方程 $ddt(x) = f(v,x)$，其中 $ddt(\\cdot)$ 是时间导数，$x$ 是内部状态变量，$v$ 是端电压。在静态（直流）工作点分析中，正如像 SPICE 这样的仿真器所执行的，所有时间导数都假定为零。因此，一个一致的直流解要求 $ddt(x) = 0$，这意味着 $f(v,x)=0$。当电路处于静态，忆阻器两端电压为零（$v=0$）时，如果状态演化定律仍产生非零的变化率，即 $f(0,x) \\neq 0$，就会出现隐藏状态漂移问题。这是物理上不一致的，因为它意味着器件状态在没有任何外部激励的情况下发生变化，并且这会在数值仿真器试图寻找稳定直流工作点时导致严重的收敛问题。\n\n我们的策略是设计演化定律 $f(v,x)$，通过对所有可能的状态 $x \\in [0,1]$ 强制执行条件 $f(0,x)=0$，来明确地防止这种现象。一个数学上鲁棒且有物理动机的方法是，将 $f(v,x)$ 构建为关于电压 $v$ 的奇函数。如果一个函数 $g(v)$ 是奇函数，它满足 $g(-v) = -g(v)$。对于 $v=0$，这要求 $g(0) = -g(0)$，这意味着 $2g(0)=0$，因此 $g(0)=0$。通过使我们演化定律中依赖电压的部分成为一个奇函数，我们保证了在零偏压下状态演化会停止，从而消除了漂移。\n\n我们现在按要求实例化具体的函数形式。\n\n1.  **电阻函数 $R(x)$**：电阻必须是一个将状态 $x \\in [0,1]$ 映射到电阻范围 $[R_{\\mathrm{on}}, R_{\\mathrm{off}}]$ 的单调函数。我们选择一个与状态定义（$x=0$为高阻态，$x=1$为低阻态）一致的简单线性映射：\n    $$R(x) = R_{\\mathrm{off}}(1-x) + R_{\\mathrm{on}}x$$\n    该函数关于 $x$ 是可微的。它正确地得出 $R(0) = R_{\\mathrm{off}}$ 和 $R(1) = R_{\\mathrm{on}}$。由于问题指定 $R_{\\mathrm{on}}  R_{\\mathrm{off}}$，其导数 $R'(x) = R_{\\mathrm{on}} - R_{\\mathrm{off}}  0$，证实了 $R(x)$ 是一个单调递减函数，即随着导电细丝增长（$x$从0到1），电阻降低。\n\n2.  **窗口函数 $W(x)$**：为了将状态变量 $x$ 限制在其物理区间 $[0,1]$ 内，演化速率 $ddt(x)$ 必须在边界 $x=0$ 和 $x=1$ 处为零。这通过引入一个满足 $W(0)=0$，$W(1)=0$ 且对于 $x \\in (0,1)$ 有 $W(x)0$ 的窗口函数 $W(x)$ 来实现。我们选择一个广泛使用的平滑多项式窗口函数：\n    $$W(x) = 4x(1-x)$$\n    该函数在 $x=0.5$ 处有最大值 $1$，并在边界处为零，符合要求。\n\n3.  **防止漂移的演化定律 $f_{\\text{df}}(v,x)$**：遵循我们的策略，我们将一个电压的奇函数与窗口函数结合起来。最简单的有物理意义的选择是使变化率与施加的电压 $v$ 成正比。我们定义：\n    $$f_{\\text{df}}(v,x) = k \\cdot v \\cdot W(x) = k v \\cdot 4x(1-x)$$\n    此处，$k$ 是一个决定开关速度的常数。就本问题而言，其值不影响漂移特性或在固定状态下的电流计算；我们不失一般性地设 $k=1$。该函数在 $v$ 上显然是奇函数，因此对所有 $x$ 都有 $f_{\\text{df}}(0,x)=0$，从而成功地防止了隐藏状态漂移。\n\n4.  **朴素演化定律 $f_{\\text{naive}}(v,x)$**：为了对比，我们设计一个表现出漂移的定律。一个简单的建模方法是在演化定律中引入一个小的、与电压无关的偏移项 $\\delta$，这可以代表建模误差或寄生物理效应。\n    $$f_{\\text{naive}}(v,x) = (k \\cdot v + \\delta) \\cdot W(x) = (v + \\delta) \\cdot 4x(1-x)$$\n    再次设 $k=1$，并选择一个小的常数 $\\delta = 0.01$，我们发现在零偏压（$v=0$）下，演化速率为 $f_{\\text{naive}}(0,x) = \\delta \\cdot 4x(1-x)$。对于任何 $x \\in (0,1)$，该值都是非零的，因此模拟了一个具有内在状态漂移的器件。\n\n漂移的数值检查通过评估 $|f(0,x)| \\le \\varepsilon$ 来执行。容差 $\\varepsilon$ 是一个小的正数，用于考虑有限精度算术。取 $\\varepsilon=10^{-9}$ 是合适的，因为它足够小，可以被认为是数值上的零，同时又足够大，可以避免由浮点表示错误引起的假阳性。\n\n端电流 $i$ 使用基本关系 $i = v/R(x)$ 来计算。\n\n我们现在继续对指定的测试用例进行计算。对于所有情况，$R_{\\mathrm{on}}=100\\,\\Omega$ 和 $R_{\\mathrm{off}}=16000\\,\\Omega$。电阻函数是 $R(x) = 16000(1-x) + 100x = 16000 - 15900x$。\n\n**测试用例1：** 参数：$x=0.3$，防止漂移定律，$v=1.0\\,\\mathrm{V}$。\n-   漂移检查：$f_{\\text{df}}(0, 0.3) = 1 \\cdot 0 \\cdot 4(0.3)(1-0.3) = 0$。由于 $|0| \\le 10^{-9}$，满足漂移条件。`drift_ok = True`。\n-   电阻：$R(0.3) = 16000 - 15900(0.3) = 16000 - 4770 = 11230\\,\\Omega$。\n-   电流：$i = 1.0\\,\\mathrm{V} / 11230\\,\\Omega \\approx 8.9047195 \\times 10^{-5}\\,\\mathrm{A}$。\n\n**测试用例2：** 参数：$x=0.0$，朴素定律，$v=2.0\\,\\mathrm{V}$。\n-   漂移检查：状态处于边界 $x=0$。窗口函数为 $W(0) = 4(0)(1-0) = 0$。因此，$f_{\\text{naive}}(0, 0.0) = (0.0 + 0.01) \\cdot W(0) = 0$。由于 $|0| \\le 10^{-9}$，满足漂移条件。这表明即使是朴素定律，在状态边界处也受到窗口函数的约束。`drift_ok = True`。\n-   电阻：$R(0.0) = 16000\\,\\Omega$。\n-   电流：$i = 2.0\\,\\mathrm{V} / 16000\\,\\Omega = 0.000125\\,\\mathrm{A}$。\n\n**测试用例3：** 参数：$x=1.0$，防止漂移定律，$v=0.1\\,\\mathrm{V}$。\n-   漂移检查：状态处于边界 $x=1$。窗口函数为 $W(1) = 4(1)(1-1) = 0$。无漂移定律为 $f_{\\text{df}}(0, 1.0) = 1 \\cdot 0 \\cdot W(1) = 0$。由于 $|0| \\le 10^{-9}$，满足漂移条件。`drift_ok = True`。\n-   电阻：$R(1.0) = 100\\,\\Omega$。\n-   电流：$i = 0.1\\,\\mathrm{V} / 100\\,\\Omega = 0.001\\,\\mathrm{A}$。\n\n**测试用例4：** 参数：$x=0.5$，朴素定律，$v=1.0\\,\\mathrm{V}$。\n-   漂移检查：状态为 $x=0.5$，此时窗口函数达到最大值：$W(0.5) = 4(0.5)(1-0.5) = 1$。朴素定律在零偏压下得出 $f_{\\text{naive}}(0, 0.5) = (0.0+0.01) \\cdot W(0.5) = 0.01$。由于 $|0.01|  10^{-9}$，违反了漂移条件。`drift_ok = False`。\n-   电阻：$R(0.5) = 16000 - 15900(0.5) = 16000 - 7950 = 8050\\,\\Omega$。\n-   电流：$i = 1.0\\,\\mathrm{V} / 8050\\,\\Omega \\approx 0.0001242236\\,\\mathrm{A}$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs and evaluates memristor models for hidden-state drift.\n    \"\"\"\n    \n    # Test cases as specified in the problem statement.\n    # Each tuple contains: (R_on, R_off, state_x, eval_v, law_type)\n    test_cases = [\n        (100.0, 16000.0, 0.3, 1.0, 'drift_preventing'),\n        (100.0, 16000.0, 0.0, 2.0, 'naive'),\n        (100.0, 16000.0, 1.0, 0.1, 'drift_preventing'),\n        (100.0, 16000.0, 0.5, 1.0, 'naive'),\n    ]\n\n    # --- Model Definitions ---\n    \n    # Numerical tolerance for checking if a value is zero\n    EPSILON = 1e-9\n    \n    # Drift offset for the naive model\n    DELTA = 0.01\n\n    def R_func(x, R_on, R_off):\n        \"\"\"Monotone resistance function consistent with state definition.\"\"\"\n        return R_off * (1.0 - x) + R_on * x\n\n    def W_func(x):\n        \"\"\"Smooth window function W(x) = 4x(1-x).\"\"\"\n        if not (0.0 = x = 1.0):\n            # The state x must be in [0, 1], but handle out-of-bounds for robustness.\n            return 0.0\n        return 4.0 * x * (1.0 - x)\n\n    def f_drift_preventing(v, x):\n        \"\"\"Drift-preventing evolution law f(v,x) = v * W(x).\"\"\"\n        # The proportionality constant k is taken as 1.\n        return v * W_func(x)\n\n    def f_naive(v, x):\n        \"\"\"Naive evolution law f(v,x) = (v + delta) * W(x).\"\"\"\n        # The proportionality constant k is taken as 1.\n        return (v + DELTA) * W_func(x)\n\n    results = []\n    for R_on, R_off, x, v, law_type in test_cases:\n        # 1. Evaluate drift condition\n        if law_type == 'drift_preventing':\n            f_val_at_zero_v = f_drift_preventing(0.0, x)\n        else: # law_type == 'naive'\n            f_val_at_zero_v = f_naive(0.0, x)\n        \n        drift_ok = abs(f_val_at_zero_v) = EPSILON\n        \n        # 2. Compute terminal current\n        resistance = R_func(x, R_on, R_off)\n        if resistance == 0:\n            # Avoid division by zero, although not expected with given R_on/R_off\n            current = float('inf') if v != 0 else 0.0\n        else:\n            current = v / resistance\n            \n        results.append([drift_ok, current])\n        \n    # Format the final output string to match the problem's example format\n    # e.g., [[True,0.1],[False,0.2]], without spaces from default list-to-string conversion.\n    formatted_results = []\n    for res_pair in results:\n        drift_status_str = 'True' if res_pair[0] else 'False'\n        \n        # Use a representation for the float that is compact for small numbers\n        current_val = res_pair[1]\n        \n        formatted_results.append(f\"[{drift_status_str},{current_val}]\")\n        \n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}