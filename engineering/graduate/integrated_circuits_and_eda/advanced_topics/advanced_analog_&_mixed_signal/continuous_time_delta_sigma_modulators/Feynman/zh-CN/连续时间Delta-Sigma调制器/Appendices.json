{
    "hands_on_practices": [
        {
            "introduction": "连续时间ΔΣ调制器设计的核心在于精心塑造噪声传递函数（NTF），以将量化噪声移出信号频带。本练习将引导您通过一个级联积分前馈（CIFF）架构的实例，系统性地推导环路滤波器系数，从而精确实现一个目标NTF。 掌握这种从传递函数目标反推电路参数的方法，是进行ΔΣ调制器设计的一项基本功。",
            "id": "4261937",
            "problem": "考虑一个三阶连续时间Delta-Sigma调制器，其采用带前馈的积分器级联 (CIFF) 架构和一个非归零 (NRZ) 数模转换器 (DAC)。假设积分器是理想的，采样周期为 $T$，并使用标准的 $z$ 域线性化模型，其中量化器被建模为加性噪声源 $e[n]$。输入序列为 $u[n]$，调制器输出为 $y[n]$，内部积分器输出为 $x_{1}[n]$、$x_{2}[n]$ 和 $x_{3}[n]$。在 NRZ DAC 激励下，连续时间理想积分器的离散时间等效形式由 $I(z) = \\frac{z^{-1}}{1 - z^{-1}}$ 给出。量化器输入端的 CIFF 求和节点为\n$$\nr[n] = c_{0}\\,u[n] + c_{1}\\,x_{1}[n] + c_{2}\\,x_{2}[n] + c_{3}\\,x_{3}[n],\n$$\n来自 $y[n]$ 的反馈以单位权重从每个积分器输入端减去，因此\n$$\nx_{1}(z) = I(z)\\,\\big(u(z) - y(z)\\big),\\quad x_{2}(z) = I(z)\\,\\big(x_{1}(z) - y(z)\\big),\\quad x_{3}(z) = I(z)\\,\\big(x_{2}(z) - y(z)\\big),\n$$\n且量化器输出为 $y(z) = r(z) + e(z)$。从这些关系出发，且不使用任何预先推导的Delta-Sigma传递函数模板，推导前馈系数 $c_{1}$、$c_{2}$ 和 $c_{3}$，以使最终的噪声传递函数 (NTF) 精确满足 $NTF(z) = (1 - z^{-1})^{3}$。此外，通过验证其低频特性来确保信号传递函数在信号频带内近似为1。将您的最终答案表示为前馈系数的三元组精确形式。无需四舍五入。",
            "solution": "该问题要求解三阶 CIFF Delta-Sigma 调制器的前馈系数 $c_1$、$c_2$ 和 $c_3$，这些系数能产生一个特定的噪声传递函数 (NTF)。分析将使用所提供的线性化离散时间模型进行。\n\n首先，我们建立调制器输出 $y(z)$ 与其输入信号 $u(z)$ 和量化噪声 $e(z)$ 之间的关系。该系统由以下 $z$ 域方程组描述：\n量化器输入由下式给出：\n$$r(z) = c_{0}\\,u(z) + c_{1}\\,x_{1}(z) + c_{2}\\,x_{2}(z) + c_{3}\\,x_{3}(z)$$\n量化器输出为：\n$$y(z) = r(z) + e(z)$$\n将这两个式子合并得到：\n$$y(z) = c_{0}\\,u(z) + c_{1}\\,x_{1}(z) + c_{2}\\,x_{2}(z) + c_{3}\\,x_{3}(z) + e(z)$$\n积分器输出由下式给出：\n$$x_{1}(z) = I(z)\\,\\big(u(z) - y(z)\\big)$$\n$$x_{2}(z) = I(z)\\,\\big(x_{1}(z) - y(z)\\big)$$\n$$x_{3}(z) = I(z)\\,\\big(x_{2}(z) - y(z)\\big)$$\n其中 $I(z) = \\frac{z^{-1}}{1 - z^{-1}}$ 是一个延迟积分器的传递函数。\n\n我们需要将积分器输出 $x_k(z)$ 用 $u(z)$ 和 $y(z)$ 表示。\n$$x_{1}(z) = I(z)u(z) - I(z)y(z)$$\n$$x_{2}(z) = I(z)x_{1}(z) - I(z)y(z) = I(z)\\big(I(z)u(z) - I(z)y(z)\\big) - I(z)y(z) = I(z)^2 u(z) - (I(z)^2 + I(z))y(z)$$\n$$x_{3}(z) = I(z)x_{2}(z) - I(z)y(z) = I(z)\\big(I(z)^2 u(z) - (I(z)^2 + I(z))y(z)\\big) - I(z)y(z) = I(z)^3 u(z) - (I(z)^3 + I(z)^2 + I(z))y(z)$$\n\n现在，将这些表达式代回到 $y(z)$ 的方程中：\n$$y(z) = c_{0}u(z) + c_{1}\\big(I(z)u(z) - I(z)y(z)\\big) + c_{2}\\big(I(z)^2 u(z) - (I(z)^2 + I(z))y(z)\\big) + c_{3}\\big(I(z)^3 u(z) - (I(z)^3 + I(z)^2 + I(z))y(z)\\big) + e(z)$$\n我们将包含 $u(z)$、$y(z)$ 和 $e(z)$ 的项进行分组：\n$$y(z) + c_{1}I(z)y(z) + c_{2}(I(z)^2+I(z))y(z) + c_{3}(I(z)^3+I(z)^2+I(z))y(z) = \\dots$$\n$$\\dots = c_{0}u(z) + c_{1}I(z)u(z) + c_{2}I(z)^2 u(z) + c_{3}I(z)^3 u(z) + e(z)$$\n提出公因子 $y(z)$ 和 $u(z)$：\n$$y(z)\\big[1 + (c_{1}+c_{2}+c_{3})I(z) + (c_{2}+c_{3})I(z)^2 + c_{3}I(z)^3\\big] = u(z)\\big[c_{0} + c_{1}I(z) + c_{2}I(z)^2 + c_{3}I(z)^3\\big] + e(z)$$\n调制器输出的一般形式为 $y(z) = STF(z)u(z) + NTF(z)e(z)$。通过观察，噪声传递函数 (NTF) 为：\n$$NTF(z) = \\frac{1}{1 + (c_{1}+c_{2}+c_{3})I(z) + (c_{2}+c_{3})I(z)^2 + c_{3}I(z)^3}$$\n问题要求 $NTF(z) = (1 - z^{-1})^{3}$。我们需要将这个目标 NTF 用 $I(z)$ 来表示。\n根据给定的定义 $I(z) = \\frac{z^{-1}}{1-z^{-1}}$，我们可以写出：\n$$1 + I(z) = 1 + \\frac{z^{-1}}{1-z^{-1}} = \\frac{1-z^{-1}+z^{-1}}{1-z^{-1}} = \\frac{1}{1-z^{-1}}$$\n取倒数得到：\n$$1 - z^{-1} = \\frac{1}{1+I(z)}$$\n因此，目标 NTF 可以写成：\n$$NTF(z) = (1-z^{-1})^3 = \\left(\\frac{1}{1+I(z)}\\right)^3 = \\frac{1}{(1+I(z))^3}$$\n对分母使用二项式展开：\n$$(1+I(z))^3 = 1 + 3I(z) + 3I(z)^2 + I(z)^3$$\n所以，目标 NTF 等价于：\n$$NTF(z) = \\frac{1}{1 + 3I(z) + 3I(z)^2 + I(z)^3}$$\n为了使我们推导的 NTF 等于目标 NTF，它们的分母必须相同。我们将分母作为 $I(z)$ 的多项式进行相等比较：\n$$1 + (c_{1}+c_{2}+c_{3})I(z) + (c_{2}+c_{3})I(z)^2 + c_{3}I(z)^3 = 1 + 3I(z) + 3I(z)^2 + I(z)^3$$\n通过比较 $I(z)$ 各次幂的系数，我们得到一个关于系数 $c_1, c_2, c_3$ 的线性方程组：\n1. $I(z)^3$ 的系数： $c_{3} = 1$\n2. $I(z)^2$ 的系数： $c_{2}+c_{3} = 3$\n3. $I(z)$ 的系数： $c_{1}+c_{2}+c_{3} = 3$\n我们通过回代法求解这个方程组。\n由方程(1)可得 $c_{3} = 1$。\n将 $c_3=1$ 代入方程(2)：\n$c_{2} + 1 = 3 \\implies c_{2} = 2$。\n将 $c_2=2$ 和 $c_3=1$ 代入方程(3)：\n$c_{1} + 2 + 1 = 3 \\implies c_{1} + 3 = 3 \\implies c_{1} = 0$。\n因此，所需的前馈系数为 $c_1 = 0$，$c_2 = 2$ 和 $c_3 = 1$。\n\n最后，我们必须验证所得的信号传递函数 (STF) 在低频时近似为1。STF 由下式给出：\n$$STF(z) = \\frac{c_{0} + c_{1}I(z) + c_{2}I(z)^2 + c_{3}I(z)^3}{1 + (c_{1}+c_{2}+c_{3})I(z) + (c_{2}+c_{3})I(z)^2 + c_{3}I(z)^3}$$\n使用推导出的系数，分母为 $(1+I(z))^3 = (1/(1-z^{-1}))^3$。\n$$STF(z) = \\frac{c_{0} + (0)I(z) + 2I(z)^2 + 1I(z)^3}{(1+I(z))^3} = \\big(c_{0} + 2I(z)^2 + I(z)^3\\big)(1-z^{-1})^3$$\n代入 $I(z) = \\frac{z^{-1}}{1-z^{-1}}$：\n$$STF(z) = \\left(c_{0} + 2\\left(\\frac{z^{-1}}{1-z^{-1}}\\right)^2 + \\left(\\frac{z^{-1}}{1-z^{-1}}\\right)^3\\right)(1-z^{-1})^3$$\n$$STF(z) = c_{0}(1-z^{-1})^3 + 2z^{-2}(1-z^{-1}) + z^{-3}$$\n为了检查低频（直流）特性，我们在 $z=1$（对应于 $z^{-1}=1$）处计算 STF 的值：\n$$STF(1) = c_{0}(1-1)^3 + 2(1)^{-2}(1-1) + (1)^{-3} = c_{0}(0) + 2(0) + 1 = 1$$\nSTF 的直流增益恰好为 $1$，与 $c_0$ 的选择无关。这证实了 STF 在低频时为1，符合要求。\n\n前馈系数为 $c_1=0$，$c_2=2$ 和 $c_3=1$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 0  2  1 \\end{pmatrix}}$$"
        },
        {
            "introduction": "尽管我们常使用线性模型来分析ΔΣ调制器，但其本质上是包含量化器的非线性系统，这会导致一些不期望的确定性行为。本练习将深入探讨“空闲音”的起源，这是一种由量化器输出的重复模式（即极限环）引起的有害音调。 通过从第一性原理出发进行分析，您将推导出维持一个典型极限环所需的输入条件，从而深刻理解调制器的非线性动态特性。",
            "id": "4261938",
            "problem": "考虑一个用于集成电路和电子设计自动化 (EDA) 分析的一阶连续时间 Delta-Sigma 调制器 (DSM)，其带有一个一位量化器和一个非归零 (NRZ) 反馈数模转换器 (DAC)。环路滤波器是一个理想的连续时间积分器，其传递函数为 $H(s) = \\frac{k}{s}$，且量化器在零阈值下工作。该系统以采样频率 $f_{s}$ 进行时钟同步，采样周期为 $T = \\frac{1}{f_{s}}$。设输入为正弦波 $x(t) = A \\sin(2 \\pi f_{\\text{in}} t)$，其中 $A$ 是输入幅度（以与一位 DAC 电平 $\\pm 1$ 相同的归一化单位表示），$f_{\\text{in}}$ 是输入频率。一位量化器的输出为 $y[n] \\in \\{+1, -1\\}$，并通过 NRZ DAC 在每个采样区间 $[nT, (n+1)T)$ 内保持恒定。\n\n已知 Delta-Sigma 调制器中的空闲音源于确定性极限环，在极限环中，量化器输出会重复一个有限长度的模式。在本问题中，请从第一性原理分析此类空闲音的来源，并推导出一个导致调制器输出端出现强音调分量的输入幅度和频率条件。具体来说：\n\n- 从连续时间积分器定律出发，推导在采样時刻 $t=nT$ 的积分器状态 $s[n]$ 在单个采样区间内的离散时间状态更新。\n- 使用此更新方程，考虑量化器输出交替（即 $y[n] = (-1)^{n}$）的最强双采样极限环，并建立积分器状态在两个采样后返回其初始值时对 $f_{\\text{in}}$ 的必要条件。\n- 强制执行量化器一致性要求，即积分器状态 $s[n]$ 的符号在每个采样时刻都与 $y[n]$ 匹配，并确定仍然容许这种交替极限环的最大输入幅度 $A$。\n\n将您的最终答案表示为一个双元素行矩阵，按顺序包含：最大容许幅度 $A$ 和产生最强音调分量的相应输入频率 $f_{\\text{in}}$。频率单位使用赫兹。无需四舍五入；请提供精确表达式。",
            "solution": "问题陈述已经过验证，被认为是可靠、良定且有科学依据的。它提出了一阶连续时间 Delta-Sigma 调制器 (CT-DSM) 的标准分析，这是集成电路领域一个成熟的课题。我们将继续进行求解。\n\n该系统是一个一阶 CT-DSM。系统的状态是积分器的输出，我们将其表示为 $s(t)$。积分器的输入是误差信号 $e(t) = x(t) - y_{dac}(t)$，其中 $x(t)$ 是调制器输入，$y_{dac}(t)$ 是来自数模转换器 (DAC) 的反馈信号。\n\n环路滤波器是一个理想积分器，其传递函数为 $H(s) = \\frac{k}{s}$。在时域中，这对应于微分方程：\n$$ \\frac{ds(t)}{dt} = k \\cdot e(t) = k (x(t) - y_{dac}(t)) $$\n该系统以频率 $f_s$ 进行采样，采样周期为 $T = \\frac{1}{f_s}$。非归零 (NRZ) DAC 在采样区间 $[nT, (n+1)T)$ 内将量化器输出 $y[n]$ 保持恒定。因此，对于 $t \\in [nT, (n+1)T)$，反馈信号为 $y_{dac}(t) = y[n]$。\n\n**1. 离散时间状态更新的推导**\n\n为了找到离散时间状态更新方程，我们将微分方程在一个采样周期内（从 $t=nT$ 到 $t=(n+1)T$）进行积分。令 $s[n] \\equiv s(nT)$ 为采样时刻的积分器状态。\n$$ s((n+1)T) - s(nT) = \\int_{nT}^{(n+1)T} k(x(\\tau) - y_{dac}(\\tau)) d\\tau $$\n根据我们的定义，这变为：\n$$ s[n+1] = s[n] + k \\int_{nT}^{(n+1)T} (A \\sin(2\\pi f_{\\text{in}}\\tau) - y[n]) d\\tau $$\n我们可以将积分分成两部分：\n$$ \\int_{nT}^{(n+1)T} y[n] d\\tau = y[n] \\int_{nT}^{(n+1)T} d\\tau = y[n] T $$\n$$ \\int_{nT}^{(n+1)T} A \\sin(2\\pi f_{\\text{in}}\\tau) d\\tau = A \\left[ -\\frac{\\cos(2\\pi f_{\\text{in}}\\tau)}{2\\pi f_{\\text{in}}} \\right]_{nT}^{(n+1)T} = \\frac{A}{2\\pi f_{\\text{in}}} (\\cos(2\\pi f_{\\text{in}}nT) - \\cos(2\\pi f_{\\text{in}}(n+1)T)) $$\n结合这些结果，离散时间状态更新方程为：\n$$ s[n+1] = s[n] + k \\left( \\frac{A}{2\\pi f_{\\text{in}}} (\\cos(2\\pi f_{\\text{in}}nT) - \\cos(2\\pi f_{\\text{in}}(n+1)T)) - y[n] T \\right) $$\n\n**2. 双采样极限环的条件**\n\n我们被要求分析一个量化器输出交替（即 $y[n] = (-1)^n$）的双采样极限环。对于周期为 2 的周期性行为，系统状态必须在两个采样后返回其初始值，因此 $s[n+2] = s[n]$。\n让我们使用更新规则写出 $s[n+2]$ 的表达式：\n$$ s[n+2] = s[n+1] + k \\int_{(n+1)T}^{(n+2)T} (x(\\tau) - y[n+1]) d\\tau $$\n$$ s[n+2] = \\left( s[n] + k \\int_{nT}^{(n+1)T} (x(\\tau) - y[n]) d\\tau \\right) + k \\int_{(n+1)T}^{(n+2)T} (x(\\tau) - y[n+1]) d\\tau $$\n设 $s[n+2] = s[n]$ 并假设 $k \\neq 0$：\n$$ \\int_{nT}^{(n+1)T} (x(\\tau) - y[n]) d\\tau + \\int_{(n+1)T}^{(n+2)T} (x(\\tau) - y[n+1]) d\\tau = 0 $$\n$$ \\int_{nT}^{(n+2)T} x(\\tau) d\\tau - T y[n] - T y[n+1] = 0 $$\n对于交替序列 $y[n] = (-1)^n$，我们有 $y[n+1] = -y[n]$。该条件简化为：\n$$ \\int_{nT}^{(n+2)T} x(\\tau) d\\tau - T y[n] - T(-y[n]) = 0 \\implies \\int_{nT}^{(n+2)T} x(\\tau) d\\tau = 0 $$\n这意味着输入信号在任意连续两个采样周期内的积分必须为零。让我们对 $x(t) = A \\sin(2\\pi f_{\\text{in}} t)$ 计算这个积分：\n$$ \\int_{nT}^{(n+2)T} A \\sin(2\\pi f_{\\text{in}}\\tau) d\\tau = \\frac{A}{2\\pi f_{\\text{in}}} (\\cos(2\\pi f_{\\text{in}}nT) - \\cos(2\\pi f_{\\text{in}}(n+2)T)) = 0 $$\n这对任何整数 $n$都必须成立。这要求余弦项相等，如果它们参数的差是 $2\\pi$ 的整数倍，则该条件满足：\n$$ 2\\pi f_{\\text{in}}(n+2)T - 2\\pi f_{\\text{in}}nT = m \\cdot 2\\pi, \\quad m \\in \\mathbb{Z} $$\n$$ 4\\pi f_{\\text{in}}T = m \\cdot 2\\pi \\implies 2 f_{\\text{in}} T = m \\implies f_{\\text{in}} = \\frac{m}{2T} = \\frac{m f_s}{2} $$\n当输入频率与交替模式 $y[n]$ 的基频匹配时，将产生最强的音调分量，该模式的周期为 $2T$。因此，基频为 $\\frac{1}{2T} = \\frac{f_s}{2}$。这对应于选择 $m=1$。\n因此，所需的输入频率为 $f_{\\text{in}} = \\frac{f_s}{2}$。\n\n**3. 量化器一致性与最大容许幅度**\n\n当 $f_{\\text{in}} = f_s/2$ 时，输入信号为 $x(t) = A \\sin(\\pi f_s t) = A \\sin(\\frac{\\pi t}{T})$。让我们重新计算输入在一个采样周期 $[nT, (n+1)T]$ 内的积分：\n$$ \\int_{nT}^{(n+1)T} A \\sin\\left(\\frac{\\pi \\tau}{T}\\right) d\\tau = A \\left[ -\\frac{T}{\\pi} \\cos\\left(\\frac{\\pi \\tau}{T}\\right) \\right]_{nT}^{(n+1)T} = -\\frac{AT}{\\pi} (\\cos(\\pi(n+1)) - \\cos(\\pi n)) $$\n$$ = -\\frac{AT}{\\pi} ((-1)^{n+1} - (-1)^n) = -\\frac{AT}{\\pi} (-1)^n(-1-1) = \\frac{2AT}{\\pi}(-1)^n $$\n将此代入极限环 $y[n] = (-1)^n$ 的状态更新方程中：\n$$ s[n+1] = s[n] + k \\left( \\frac{2AT}{\\pi}(-1)^n - (-1)^n T \\right) = s[n] + k T (-1)^n \\left(\\frac{2A}{\\pi} - 1\\right) $$\n一位量化器具有零阈值，其输出为 $y[n] \\in \\{+1, -1\\}$。我们定义 $y[n] = \\text{sgn}(s[n])$，假设对于 $x \\ge 0$ 时 $\\text{sgn}(x) = +1$，对于 $x  0$ 时 $\\text{sgn}(x) = -1$。为了维持极限环 $y[n] = (-1)^n$，状态 $s[n]$ 必须在每一步都满足量化器的符号条件。让我们检查 $n=0$ 和 $n=1$ 的情况。\n\n1.  对于 $n=0$：$y[0] = (-1)^0 = +1$。这要求 $s[0] \\ge 0$。\n2.  对于 $n=1$：$y[1] = (-1)^1 = -1$。这要求 $s[1]  0$。\n\n让我们使用我们推导的更新方程来检查状态 $s[1]$：\n$$ s[1] = s[0] + k T (-1)^0 \\left(\\frac{2A}{\\pi} - 1\\right) = s[0] + k T \\left(\\frac{2A}{\\pi} - 1\\right) $$\n条件 $s[1]  0$ 意味着：\n$$ s[0] + k T \\left(\\frac{2A}{\\pi} - 1\\right)  0 \\implies s[0]  -k T \\left(\\frac{2A}{\\pi} - 1\\right) = k T \\left(1 - \\frac{2A}{\\pi}\\right) $$\n将此与条件 $s[0] \\ge 0$ 结合，我们发现要使极限环存在，必须有一个有效的初始状态 $s[0]$ 满足：\n$$ 0 \\le s[0]  k T \\left(1 - \\frac{2A}{\\pi}\\right) $$\n为使这个可能的 $s[0]$ 值区间非空，上界必须严格大于下界（$0$）。由于 $k > 0$ 且 $T > 0$，这要求：\n$$ 1 - \\frac{2A}{\\pi} > 0 \\implies 1 > \\frac{2A}{\\pi} \\implies A  \\frac{\\pi}{2} $$\n容许此极限环的幅度 $A$ 的集合是 $[0, \\pi/2)$。问题要求的是此类幅度的*最大*值。这对应于该集合的上确界，即有效初始状态 $s[0]$ 的范围缩小到一个点的边界值。\n因此，最大容许幅度为 $A = \\frac{\\pi}{2}$。\n\n最终答案是数对 $(A, f_{\\text{in}})$。\n最大容许幅度：$A = \\frac{\\pi}{2}$。\n相应输入频率：$f_{\\text{in}} = \\frac{f_s}{2}$。",
            "answer": "$$ \\boxed{\n\\begin{pmatrix}\n\\frac{\\pi}{2}  \\frac{f_s}{2}\n\\end{pmatrix}\n} $$"
        },
        {
            "introduction": "在集成电路设计流程中，确保晶体管级电路（由网表描述）与高层行为模型在功能上保持一致是至关重要的验证环节。本练习将理论付诸实践，要求您编写程序来自动完成这一验证过程。 您将通过计算和比较从两种不同状态空间表示中得到的噪声传递函数（NTF）和信号传递函数（STF），来验证模型的等效性，从而将抽象的控制理论与电子设计自动化（EDA）的实际挑战联系起来。",
            "id": "4261902",
            "problem": "你的任务是编写一个完整的、可运行的程序，用于连续时间delta-sigma调制器，通过计算和比较噪声传递函数（NTF）和信号传递函数（STF），验证从电路网表获得的环路滤波器与预期的行为模型之间的一致性。程序必须仅使用本问题中提供的数值数据，不得读取外部文件。\n\n使用的基本原理是线性、时不变、连续时间的状态空间表示和拉普拉斯变换。环路滤波器由一个状态空间系统建模，该系统具有矩阵 $A \\in \\mathbb{R}^{n \\times n}$、$B \\in \\mathbb{R}^{n \\times 1}$、$C \\in \\mathbb{R}^{1 \\times n}$ 和 $D \\in \\mathbb{R}^{1 \\times 1}$，输入为 $r(t)$，输出为 $v(t)$。该环路滤波器的拉普拉斯域传递函数 $F(s)$ 定义为 $F(s) = C (s I - A)^{-1} B + D$，其中 $I$ 是单位矩阵，$s$ 是拉普拉斯变量。delta-sigma调制器使用环路滤波器的输出 $v(t)$ 通过一个量化器产生 $y(t)$，该量化器被一个线性加性噪声模型替代：$y(t)$ 等于环路滤波器输出加上一个加性噪声源 $e(t)$。环路求和节点计算误差 $r(t)$，其值为外部输入 $u(t)$ 与反馈的调制器输出 $y(t)$ 之差。使用这些建模假设和拉普拉斯变换，根据连续时间线性系统中反馈的基本原理，利用 $u(t)$、$e(t)$、$r(t)$、$v(t)$ 和 $y(t)$ 之间的关系，推导出 NTF（噪声传递函数）和 STF（信号传递函数）。\n\n程序必须：\n- 对于每个提供的测试用例，根据指定的频率集，分别从网表提取的矩阵和行为模型矩阵计算 $F(s)$。\n- 从每个 $F(s)$ 中，在给定的频率网格（表示为 $s = j \\omega$，其中 $j$ 是虚数单位）上推导并计算 NTF 和 STF。\n- 在每个频率点上，比较从网表模型和行为模型获得的 NTF 和 STF 的幅度与相位（以弧度为单位）。对于幅度，使用相对误差，其定义为绝对差值除以两个被比较幅度中的较大者，并设一个小的正数下限以避免除以零。对于相位，考虑模 $2 \\pi$ 的相位等效性，并使用以弧度为单位的绝对相位差。\n- 为每个测试用例返回一个布尔值：当且仅当 NTF 和 STF 的幅度和相位在所有频率点上均在指定容差范围内匹配时，返回 $True$，否则返回 $False$。\n\n物理单位和角度单位：\n- 频率以弧度/秒为单位提供，并且必须按此单位处理。相位必须以弧度为单位进行计算和比较。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$ [result\\_1,result\\_2,\\dots] $）。\n\n测试套件：\n- 测试用例 $1$ (一阶积分器环路滤波器)：\n  - 网表矩阵：$A = \\begin{bmatrix} 0.0 \\end{bmatrix}$，$B = \\begin{bmatrix} 2.0 \\end{bmatrix}$，$C = \\begin{bmatrix} 1.0 \\end{bmatrix}$，$D = \\begin{bmatrix} 0.0 \\end{bmatrix}$。\n  - 行为模型矩阵：$A = \\begin{bmatrix} 0.0 \\end{bmatrix}$，$B = \\begin{bmatrix} 2.0 \\end{bmatrix}$，$C = \\begin{bmatrix} 1.0 \\end{bmatrix}$，$D = \\begin{bmatrix} 0.0 \\end{bmatrix}$。\n  - 频率（单位：弧度/秒）：$[10^3, 10^4, 10^5, 10^6]$。\n  - 容差：幅度容差 $= 10^{-9}$，相位容差 $= 10^{-9}$。\n\n- 测试用例 $2$ (带前馈的一阶)：\n  - 网表矩阵：$A = \\begin{bmatrix} 0.0 \\end{bmatrix}$，$B = \\begin{bmatrix} 1.0 \\end{bmatrix}$，$C = \\begin{bmatrix} 1.0 \\end{bmatrix}$，$D = \\begin{bmatrix} 0.5 \\end{bmatrix}$。\n  - 行为模型矩阵：$A = \\begin{bmatrix} 0.0 \\end{bmatrix}$，$B = \\begin{bmatrix} 1.0 \\end{bmatrix}$，$C = \\begin{bmatrix} 1.0 \\end{bmatrix}$，$D = \\begin{bmatrix} 0.5 \\end{bmatrix}$。\n  - 频率（单位：弧度/秒）：$[10^3, 10^4, 10^5, 10^6]$。\n  - 容差：幅度容差 $= 10^{-7}$，相位容差 $= 10^{-7}$。\n\n- 测试用例 $3$ (有意失配)：\n  - 网表矩阵：$A = \\begin{bmatrix} 0.0 \\end{bmatrix}$，$B = \\begin{bmatrix} 1.0 \\end{bmatrix}$，$C = \\begin{bmatrix} 1.0 \\end{bmatrix}$，$D = \\begin{bmatrix} 0.5 \\end{bmatrix}$。\n  - 行为模型矩阵：$A = \\begin{bmatrix} 0.0 \\end{bmatrix}$，$B = \\begin{bmatrix} 1.0 \\end{bmatrix}$，$C = \\begin{bmatrix} 1.0 \\end{bmatrix}$，$D = \\begin{bmatrix} 0.7 \\end{bmatrix}$。\n  - 频率（单位：弧度/秒）：$[10^3, 10^4, 10^5, 10^6]$。\n  - 容差：幅度容差 $= 10^{-6}$，相位容差 $= 10^{-6}$。\n\n- 测试用例 $4$ (可控标准型二阶环路滤波器)：\n  - 网表矩阵：\n    $$A = \\begin{bmatrix} 0.0  1.0 \\\\ -4.0 \\times 10^{10}  -2.0 \\times 10^5 \\end{bmatrix}$$\n    $$B = \\begin{bmatrix} 0.0 \\\\ 1.0 \\end{bmatrix}$$\n    $$C = \\begin{bmatrix} 1.0 \\times 10^6  1.0 \\times 10^3 \\end{bmatrix}$$\n    $$D = \\begin{bmatrix} 0.0 \\end{bmatrix}$$\n  - 行为模型矩阵：\n    $$A = \\begin{bmatrix} 0.0  1.0 \\\\ -4.0 \\times 10^{10}  -2.0 \\times 10^5 \\end{bmatrix}$$\n    $$B = \\begin{bmatrix} 0.0 \\\\ 1.0 \\end{bmatrix}$$\n    $$C = \\begin{bmatrix} 1.0 \\times 10^6  1.0 \\times 10^3 \\end{bmatrix}$$\n    $$D = \\begin{bmatrix} 0.0 \\end{bmatrix}$$\n  - 频率（单位：弧度/秒）：$[10^3, 10^4, 10^5, 10^6]$。\n  - 容差：幅度容差 $= 10^{-8}$，相位容差 $= 10^{-6}$。\n\n你的程序必须为每个测试用例计算布尔结果，检查所有指定频率，并以 $[b\\_1,b\\_2,b\\_3,b\\_4]$ 的确切格式打印单行结果，其中每个 $b\\_i$ 是 $True$ 或 $False$。",
            "solution": "用户要求编写一个程序，用于验证连续时间delta-sigma调制器环路滤波器的网表派生状态空间模型和行为状态空间模型之间的一致性。这将通过计算和比较它们各自的噪声传递函数（NTF）和信号传递函数（STF）来完成。\n\n### 步骤1：问题验证\n\n**已知条件提取：**\n- **系统模型**：\n    - 由状态空间矩阵 $A$、$B$、$C$ 和 $D$ 描述的线性、时不变、连续时间环路滤波器。\n    - 环路滤波器的拉普拉斯域传递函数为 $F(s) = C(sI - A)^{-1}B + D$。\n    - 调制器输出 $Y(s)$ 与环路滤波器输出 $V(s)$ 和加性量化噪声源 $E(s)$ 的关系为 $Y(s) = V(s) + E(s)$。\n    - 环路滤波器输入 $R(s)$ 由反馈结构给出：$R(s) = U(s) - Y(s)$，其中 $U(s)$ 是外部输入。\n- **定义**：\n    - 噪声传递函数 (NTF)：假设 $U(s)=0$ 时，从噪声输入 $E(s)$ 到调制器输出 $Y(s)$ 的传递函数。\n    - 信号传递函数 (STF)：假设 $E(s)=0$ 时，从信号输入 $U(s)$ 到调制器输出 $Y(s)$ 的传递函数。\n- **比较标准**：\n    - 在离散频率 $s = j\\omega$ 处进行比较。\n    - 幅度相对误差：$|\\text{mag}_1 - \\text{mag}_2| / \\max(\\text{mag}_1, \\text{mag}_2)$，分母设有一个下限以防止除以零。\n    - 相位绝对误差：以弧度为单位的绝对差值，考虑相位卷绕（模 $2\\pi$）。\n- **测试数据**：提供了四个测试用例，每个用例都包含网表矩阵、行为模型矩阵、一个以 rad/s 为单位的频率列表、一个幅度容差和一个相位容差。\n\n**验证分析：**\n该问题在科学上和数学上都是合理的。它基于应用于delta-sigma调制器分析的线性系统和控制理论的标准原理，这是集成电路设计中一个成熟的课题。对量化器使用线性化模型是此类分析中一种常见且有效的简化方法。该问题是适定的，提供了得出每个测试用例唯一的、确定性解所需的所有必要矩阵、参数和比较标准。语言客观而精确。所提供的数据，包括矩阵维度和数值，在电子电路建模的背景下是一致且物理上合理的。不存在会使问题无效的矛盾、歧义或信息缺失。\n\n**结论：** 该问题有效。\n\n### 步骤2：NTF和STF的理论推导\n\n在实现之前，我们必须从给定的系统方程推导出 NTF 和 STF 的表达式。设信号的拉普拉斯变换分别为 $U(s)$、$E(s)$、$R(s)$、$V(s)$ 和 $Y(s)$。\n\n该系统由拉普拉斯域中的以下线性方程组描述：\n1.  $V(s) = F(s) R(s)$ (环路滤波器)\n2.  $Y(s) = V(s) + E(s)$ (线性化量化器)\n3.  $R(s) = U(s) - Y(s)$ (求和节点)\n\n我们希望找到用输入 $U(s)$ 和 $E(s)$ 表示输出 $Y(s)$ 的表达式。我们可以通过代入法来实现。\n将 (3) 代入 (1)：\n$V(s) = F(s) (U(s) - Y(s))$\n\n将此结果代入 (2)：\n$Y(s) = [F(s) (U(s) - Y(s))] + E(s)$\n\n现在，我们求解 $Y(s)$：\n$Y(s) = F(s)U(s) - F(s)Y(s) + E(s)$\n$Y(s) + F(s)Y(s) = F(s)U(s) + E(s)$\n$Y(s)(1 + F(s)) = F(s)U(s) + E(s)$\n\n最后，我们分离出 $Y(s)$：\n$$Y(s) = \\left( \\frac{F(s)}{1 + F(s)} \\right) U(s) + \\left( \\frac{1}{1 + F(s)} \\right) E(s)$$\n\n此表达式的形式为 $Y(s) = \\text{STF}(s) U(s) + \\text{NTF}(s) E(s)$。根据定义，我们可以确定 STF 和 NTF：\n- **信号传递函数 (STF)**：\n$$ \\text{STF}(s) = \\frac{Y(s)}{U(s)}\\bigg|_{E(s)=0} = \\frac{F(s)}{1 + F(s)} $$\n- **噪声传递函数 (NTF)**：\n$$ \\text{NTF}(s) = \\frac{Y(s)}{E(s)}\\bigg|_{U(s)=0} = \\frac{1}{1 + F(s)} $$\n\n注意到 $\\text{STF}(s) + \\text{NTF}(s) = \\frac{F(s)}{1+F(s)} + \\frac{1}{1+F(s)} = \\frac{1+F(s)}{1+F(s)} = 1$。这种关系，即 $\\text{STF}(s) = 1 - \\text{NTF}(s)$，对于此调制器拓扑成立，并且可以用于更数值稳定的计算。\n\n### 步骤3：算法实现\n\n程序将为每个测试用例实现以下步骤：\n1.  定义一个计算传递函数的函数。给定状态空间矩阵 $(A, B, C, D)$ 和一个频率列表 $(\\omega_i)$，该函数将：\n    a. 对于每个角频率 $\\omega_i$，设置复频率 $s = j\\omega_i$。\n    b. 计算环路滤波器的频率响应 $F(j\\omega_i) = C(j\\omega_i I - A)^{-1}B + D$。这涉及到在每个频率点进行一次矩阵求逆。\n    c. 使用 $F(j\\omega_i)$ 来计算 $\\text{NTF}(j\\omega_i) = 1 / (1 + F(j\\omega_i))$ 和 $\\text{STF}(j\\omega_i) = 1 - \\text{NTF}(j\\omega_i)$。\n    d. 返回复数 STF 和 NTF 值的列表。\n2.  对于每个测试用例，对网表模型和行为模型都调用步骤1中的函数，以获得它们各自的 STF 和 NTF 频率响应。\n3.  实现一个比较函数，该函数接收两个复数传递函数值（例如，$\\text{NTF}_{\\text{netlist}}(j\\omega_i)$ 和 $\\text{NTF}_{\\text{behavioral}}(j\\omega_i)$）以及指定的容差。该函数将：\n    a. 计算幅度相对误差：$ \\text{err}_{\\text{mag}} = \\frac{|\\text{mag}_1 - \\text{mag}_2|}{\\max(\\text{mag}_1, \\text{mag}_2)} $。如果 $\\max(\\text{mag}_1, \\text{mag}_2) = 0$，则误差为 $0$。\n    b. 计算绝对相位误差，处理 $\\pm\\pi$ 的卷绕问题：$ \\text{err}_{\\text{phase}} = | \\text{mod}(\\Delta\\phi + \\pi, 2\\pi) - \\pi | $，其中 $\\Delta\\phi = \\text{phase}_1 - \\text{phase}_2$。\n    c. 如果两个误差都在各自的容差范围内，则返回 `True`，否则返回 `False`。\n4.  遍历给定测试用例的所有指定频率。在每个频率点上，对 NTF 和 STF 对应用步骤3中的比较函数。\n5.  测试用例的总体结果为 `True` 当且仅当在所有频率点上，NTF 和 STF 的比较都通过。任一传递函数在任一频率点上的首次失败将立即导致该测试用例的结果为 `False`。\n6.  收集所有测试用例的布尔结果，并将其格式化为所需的字符串输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the delta-sigma modulator model verification.\n    \"\"\"\n    \n    test_cases = [\n        # Test Case 1: First-order integrator loop filter\n        {\n            \"netlist\": {\n                \"A\": np.array([[0.0]]),\n                \"B\": np.array([[2.0]]),\n                \"C\": np.array([[1.0]]),\n                \"D\": np.array([[0.0]])\n            },\n            \"behavioral\": {\n                \"A\": np.array([[0.0]]),\n                \"B\": np.array([[2.0]]),\n                \"C\": np.array([[1.0]]),\n                \"D\": np.array([[0.0]])\n            },\n            \"frequencies\": [1e3, 1e4, 1e5, 1e6],\n            \"mag_tol\": 1e-9,\n            \"phase_tol\": 1e-9\n        },\n        # Test Case 2: First-order with feed-through\n        {\n            \"netlist\": {\n                \"A\": np.array([[0.0]]),\n                \"B\": np.array([[1.0]]),\n                \"C\": np.array([[1.0]]),\n                \"D\": np.array([[0.5]])\n            },\n            \"behavioral\": {\n                \"A\": np.array([[0.0]]),\n                \"B\": np.array([[1.0]]),\n                \"C\": np.array([[1.0]]),\n                \"D\": np.array([[0.5]])\n            },\n            \"frequencies\": [1e3, 1e4, 1e5, 1e6],\n            \"mag_tol\": 1e-7,\n            \"phase_tol\": 1e-7\n        },\n        # Test Case 3: Intentional mismatch\n        {\n            \"netlist\": {\n                \"A\": np.array([[0.0]]),\n                \"B\": np.array([[1.0]]),\n                \"C\": np.array([[1.0]]),\n                \"D\": np.array([[0.5]])\n            },\n            \"behavioral\": {\n                \"A\": np.array([[0.0]]),\n                \"B\": np.array([[1.0]]),\n                \"C\": np.array([[1.0]]),\n                \"D\": np.array([[0.7]])\n            },\n            \"frequencies\": [1e3, 1e4, 1e5, 1e6],\n            \"mag_tol\": 1e-6,\n            \"phase_tol\": 1e-6\n        },\n        # Test Case 4: Second-order loop filter\n        {\n            \"netlist\": {\n                \"A\": np.array([[0.0, 1.0], [-4.0e10, -2.0e5]]),\n                \"B\": np.array([[0.0], [1.0]]),\n                \"C\": np.array([[1.0e6, 1.0e3]]),\n                \"D\": np.array([[0.0]])\n            },\n            \"behavioral\": {\n                \"A\": np.array([[0.0, 1.0], [-4.0e10, -2.0e5]]),\n                \"B\": np.array([[0.0], [1.0]]),\n                \"C\": np.array([[1.0e6, 1.0e3]]),\n                \"D\": np.array([[0.0]])\n            },\n            \"frequencies\": [1e3, 1e4, 1e5, 1e6],\n            \"mag_tol\": 1e-8,\n            \"phase_tol\": 1e-6\n        }\n    ]\n\n    def compute_transfer_functions(A, B, C, D, frequencies):\n        \"\"\"\n        Computes NTF and STF for given state-space matrices across a frequency grid.\n        \n        Args:\n            A, B, C, D (np.ndarray): State-space matrices.\n            frequencies (list): List of frequencies in rad/s.\n            \n        Returns:\n            tuple: A tuple containing lists of complex NTF and STF values.\n        \"\"\"\n        n = A.shape[0]\n        I = np.identity(n)\n        ntf_values = []\n        stf_values = []\n\n        for omega in frequencies:\n            s = 1j * omega\n            try:\n                # F(s) = C(sI - A)^-1 B + D\n                F_s_matrix = C @ np.linalg.inv(s * I - A) @ B + D\n                F_s = F_s_matrix[0, 0] # Extract scalar\n                \n                # NTF(s) = 1 / (1 + F(s))\n                ntf = 1.0 / (1.0 + F_s)\n                \n                # STF(s) = F(s) / (1 + F(s)) = 1 - NTF(s)\n                stf = 1.0 - ntf\n                \n                ntf_values.append(ntf)\n                stf_values.append(stf)\n            except np.linalg.LinAlgError:\n                # Handle cases where inversion fails (e.g., s is an eigenvalue)\n                ntf_values.append(np.nan)\n                stf_values.append(np.nan)\n                \n        return ntf_values, stf_values\n\n    def compare_tfs(tf1, tf2, mag_tol, phase_tol):\n        \"\"\"\n        Compares two complex transfer function values for magnitude and phase.\n        \n        Args:\n            tf1, tf2 (complex): The two complex values to compare.\n            mag_tol (float): Relative magnitude tolerance.\n            phase_tol (float): Absolute phase tolerance in radians.\n            \n        Returns:\n            bool: True if both magnitude and phase are within tolerances, False otherwise.\n        \"\"\"\n        if np.isnan(tf1) or np.isnan(tf2):\n            return False\n\n        # Magnitude comparison\n        mag1 = np.abs(tf1)\n        mag2 = np.abs(tf2)\n        denominator = max(mag1, mag2)\n        \n        mag_err = 0.0\n        if denominator  1e-12: # Avoid division by a very small number\n            mag_err = np.abs(mag1 - mag2) / denominator\n        elif np.abs(mag1 - mag2)  1e-12: # If denominator is small, use absolute diff\n             mag_err = np.inf\n        # If both are tiny, their difference should also be tiny. The 0 error is implicitly handled.\n            \n        if mag_err  mag_tol:\n            return False\n\n        # Phase comparison\n        phase1 = np.angle(tf1)\n        phase2 = np.angle(tf2)\n        \n        phase_diff = phase1 - phase2\n        # Wrap phase difference to the interval [-pi, pi]\n        wrapped_phase_diff = (phase_diff + np.pi) % (2 * np.pi) - np.pi\n        phase_err = np.abs(wrapped_phase_diff)\n        \n        if phase_err  phase_tol:\n            return False\n            \n        return True\n\n    results = []\n    for case in test_cases:\n        is_match = True\n        \n        ntf_net, stf_net = compute_transfer_functions(\n            case[\"netlist\"][\"A\"], case[\"netlist\"][\"B\"],\n            case[\"netlist\"][\"C\"], case[\"netlist\"][\"D\"],\n            case[\"frequencies\"]\n        )\n        ntf_beh, stf_beh = compute_transfer_functions(\n            case[\"behavioral\"][\"A\"], case[\"behavioral\"][\"B\"],\n            case[\"behavioral\"][\"C\"], case[\"behavioral\"][\"D\"],\n            case[\"frequencies\"]\n        )\n        \n        mag_tol = case[\"mag_tol\"]\n        phase_tol = case[\"phase_tol\"]\n        \n        for i in range(len(case[\"frequencies\"])):\n            # Compare NTFs\n            if not compare_tfs(ntf_net[i], ntf_beh[i], mag_tol, phase_tol):\n                is_match = False\n                break\n                \n            # Compare STFs\n            if not compare_tfs(stf_net[i], stf_beh[i], mag_tol, phase_tol):\n                is_match = False\n                break\n        \n        results.append(is_match)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}