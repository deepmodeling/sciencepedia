{
    "hands_on_practices": [
        {
            "introduction": "在任何校准流程中，第一步都是精确地测量失配。本练习将聚焦于最关键的失配之一：时间偏斜（timing skew）。我们将探索一种基于相邻通道输出之间互相关的强大技术来估计此偏斜。这项练习不仅提供了一种估计方法，还深入研究了输入信号的特性（特别是其频谱“颜色”）如何对我们的估计引入偏差，这是稳健校准设计中的一个关键考量。",
            "id": "4306058",
            "problem": "考虑一个双通道时间交错模数转换器 (ADC)，它对一个实值广义平稳 (WSS) 随机过程 $x(t)$ 进行采样。总采样周期为 $T$ 秒，因此交错复合输出发生在时刻 $t_n = nT$，其中 $n \\in \\mathbb{Z}$。通道 $\\mathcal{A}$ 的标称采样时刻为 $t = 2kT$，通道 $\\mathcal{B}$ 的标称采样时刻为 $t = (2k+1)T$，其中整数 $k \\ge 0$。由于存在定时偏移，通道 $\\mathcal{A}$ 在 $t = 2kT + \\epsilon_{\\mathcal{A}}$ 时刻采样，通道 $\\mathcal{B}$ 在 $t = (2k+1)T + \\epsilon_{\\mathcal{B}}$ 时刻采样。定义相对偏移为 $\\delta = \\epsilon_{\\mathcal{B}} - \\epsilon_{\\mathcal{A}}$，假设其远小于 $T$。\n\n令 $A[k] = x(2kT + \\epsilon_{\\mathcal{A}})$ 和 $B[k] = x((2k+1)T + \\epsilon_{\\mathcal{B}})$ 为采样序列，其中 $k = 0,1,2,\\dots$。定义相邻通道间的经验互相关\n$$\n\\widehat{C}_{+} = \\frac{1}{K-1} \\sum_{k=1}^{K-1} A[k]\\,B[k], \\quad\n\\widehat{C}_{-} = \\frac{1}{K-1} \\sum_{k=1}^{K-1} A[k]\\,B[k-1],\n$$\n对于某个有限的 $K \\in \\mathbb{N}$，以及通过交错 $A[k]$ 和 $B[k]$ 形成的复合序列 $S[n]$，其中 $S[2k] = A[k]$ 且 $S[2k+1] = B[k]$，对于 $k = 0,1,2,\\dots,K-1$。同时定义经验能量\n$$\n\\widehat{R}_0 = \\frac{1}{2K} \\sum_{n=0}^{2K-1} S[n]^2.\n$$\n\n从以下基础出发：\n- WSS 过程的互相关定义，以及对于实值过程，自相关函数 $R_x(\\tau) = \\mathbb{E}[x(t)\\,x(t+\\tau)]$ 是 $\\tau$ 的偶函数这一性质。\n- 对于足够小的 $\\delta$ 有效的一阶泰勒线性化 $x(t+\\delta) \\approx x(t) + \\delta\\,x'(t)$。\n- 使用延迟 $0$ 和 $2T$ 处的对称差分来近似延迟 $T$ 处的自相关函数导数的离散时间方法。\n\n您必须推导并实现一个基于互相关的偏移估计器，该估计器使用相邻通道的互相关从数据中估计 $\\delta$。然后，在该估计器使用离散时间白噪声输入模型（平坦功率谱密度）对其增益进行归一化的假设下，推导当实际输入频谱为有色（非白色）时估计器的期望偏差。使用自回归 (AR) 一阶模型 $x[n] = a\\,x[n-1] + w[n]$（其中 $|a|  1$，$w[n]$ 是离散时间白噪声）来量化该偏差。该自回归 (AR) 模型定义了一个离散时间 WSS 过程，其自相关呈几何衰减，并允许对偏差进行闭式评估。\n\n您的实现必须使用高速率离散时间仿真来近似连续时间采样。具体来说，设底层仿真网格的时间步长为 $\\Delta t = T/L$，其中整数过采样因子 $L \\ge 1$。序列 $A[k]$ 和 $B[k]$ 是通过在分别最接近 $2kT + \\epsilon_{\\mathcal{A}}$ 和 $(2k+1)T + \\epsilon_{\\mathcal{B}}$ 的索引处对底层离散时间实现 $x[n]$ 进行采样而形成的，这些索引映射到间距为 $\\Delta t$ 的网格上。使用 $K$ 对这样的采样点来估计所需的经验量。\n\n您的任务：\n1. 从上述基础出发，推导一个小型偏移线性估计器，该估计器使用 $\\widehat{C}_{+}$ 和 $\\widehat{C}_{-}$ 以及基于离散时间白噪声输入假设的增益归一化，以秒为单位生成估计值 $\\widehat{\\delta}$。\n2. 对于建模为参数为 $a$ 的 AR($1$) 过程的有色输入，推导估计器的期望偏差，定义为 $\\mathbb{E}[\\widehat{\\delta}] - \\delta$，单位为秒。以 $\\delta$ 和 $a$ 的闭式形式表示该偏差。\n3. 实现一个程序：\n   - 生成参数为 $a$ 且具有离散时间白噪声新息的 AR($1$) 输入，模拟具有小偏移 $\\delta$ 的时间交错 ADC 采样，形成 $A[k]$、$B[k]$ 和 $S[n]$，使用您推导的估计器计算 $\\widehat{C}_{+}$、$\\widehat{C}_{-}$、$\\widehat{R}_0$ 和偏移估计值 $\\widehat{\\delta}$，并计算经验偏差 $\\widehat{\\delta} - \\delta$ 和您推导出的理论偏差。\n   - 使用固定参数 $T = 1\\times 10^{-9}$ 秒，$L = 64$，$\\delta = 12.5\\times 10^{-12}$ 秒，$K = 16384$，以及三个 AR($1$) 参数 $a \\in \\{0.0, 0.6, 0.95\\}$。\n   - 所有输出均以秒为单位表示。\n\n测试套件：\n- 情况 1：$a = 0.0$（离散时间白噪声输入），一个通用验证（理想路径）。\n- 情况 2：$a = 0.6$（中度有色输入），检查一般有色偏差。\n- 情况 3：$a = 0.95$（高度有色输入），一个具有强相关的近边界情况。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于每种情况，以秒为单位输出三元组 $[\\widehat{\\delta}, \\widehat{\\delta}-\\delta, \\text{bias}_{\\text{theory}}]$，将所有情况的结果连接起来，按情况 1 到 3 的顺序生成一个包含 9 个浮点数的扁平列表，单位为秒。",
            "solution": "我们考虑一个总采样周期为 $T$ 的双通道时间交错模数转换器 (ADC)，它在时刻 $t_n = nT$ 生成交错复合输出。两个通道的采样时刻分别为 $t = 2kT + \\epsilon_{\\mathcal{A}}$ 和 $t = (2k+1)T + \\epsilon_{\\mathcal{B}}$，定义了相对偏移 $\\delta = \\epsilon_{\\mathcal{B}} - \\epsilon_{\\mathcal{A}}$，其中 $|\\delta| \\ll T$。我们记 $A[k] = x(2kT + \\epsilon_{\\mathcal{A}})$ 和 $B[k] = x((2k+1)T + \\epsilon_{\\mathcal{B}})$。\n\n我们从实值广义平稳 (WSS) 过程 $x(t)$ 的自相关定义开始：\n$$\nR_x(\\tau) = \\mathbb{E}\\{ x(t) x(t+\\tau) \\},\n$$\n对于实数 $x(t)$，该函数是 $\\tau$ 的偶函数，即 $R_x(-\\tau) = R_x(\\tau)$。相邻通道样本之间的互相关可以用 $R_x(\\tau)$ 和通道时间偏移来表示。使用小偏移泰勒线性化 $x(t+\\delta) \\approx x(t) + \\delta x'(t)$，互相关项在 $\\delta$ 的一阶近似下变为：\n$$\n\\mathbb{E}\\{ A[k] B[k] \\} \\approx R_x(T+\\delta) \\approx R_x(T) + \\delta\\, R_x'(T),\n$$\n$$\n\\mathbb{E}\\{ A[k] B[k-1] \\} \\approx R_x(T-\\delta) \\approx R_x(T) - \\delta\\, R_x'(T),\n$$\n其中 $R_x'(\\tau) = \\frac{d}{d\\tau} R_x(\\tau)$。将两者相减得到差分互相关：\n$$\n\\Delta C \\triangleq \\mathbb{E}\\{ A[k] B[k] \\} - \\mathbb{E}\\{ A[k] B[k-1] \\} \\approx 2 \\delta\\, R_x'(T).\n$$\n这个关系式是根据平稳性、$R_x(\\tau)$ 的偶对称性以及一阶时移线性化得到的核心恒等式。它提供了一种将定时偏移 $\\delta$ 与可测量的互相关差异联系起来的方法。\n\n为了将其转化为一个估计器，我们需要一种方法来通过 $R_x'(T)$ 进行归一化，而 $R_x'(T)$ 取决于输入过程的频谱。在实践中，许多基于互相关的校准方案会基于输入的离散时间白噪声假设来设置增益。在采样间隔为 $T$ 的离散时间模型下，离散时间白噪声输入的自相关为 $R_x[m] = 0$（对于整数 $m \\ne 0$）和 $R_x[0] = \\sigma_x^2$。在 $\\tau = T$ 处导数的对称差分近似为：\n$$\nR_x'(T) \\approx \\frac{R_x(2T) - R_x(0)}{2T}.\n$$\n对于离散时间白噪声输入，$R_x(2T) \\approx 0$ 且 $R_x(0) \\approx \\sigma_x^2$，因此\n$$\nR_x'(T) \\approx -\\frac{\\sigma_x^2}{2T}.\n$$\n代入差分互相关恒等式，得到白噪声归一化估计器：\n$$\n\\widehat{\\delta} \\approx -\\frac{T}{\\sigma_x^2} \\left( \\widehat{C}_{+} - \\widehat{C}_{-} \\right),\n$$\n其中 $\\widehat{C}_{+}$ 和 $\\widehat{C}_{-}$ 是根据数据经验计算得出的。在实现中，$\\sigma_x^2$ 被交错序列的经验能量 $\\widehat{R}_0$ 替代，得到：\n$$\n\\widehat{\\delta} = -\\frac{T}{\\widehat{R}_0} \\left( \\widehat{C}_{+} - \\widehat{C}_{-} \\right).\n$$\n\n我们现在计算当输入频谱为有色而非白色时的偏差。考虑一个离散时间自回归 (AR) 一阶模型：\n$$\nx[n] = a\\,x[n-1] + w[n], \\quad |a|  1,\n$$\n其中 $w[n]$ 是方差为 $\\sigma_w^2$ 的离散时间白噪声。该过程是 WSS 过程，其方差为 $\\sigma_x^2 = \\frac{\\sigma_w^2}{1-a^2}$，自相关为 $R_x[m] = \\sigma_x^2\\,a^{|m|}$。在离散时间意义上，对 $R_x'(T)$ 使用相同的对称差分近似，\n$$\nR_x'(T) \\approx \\frac{R_x(2T) - R_x(0)}{2T} \\approx \\frac{\\sigma_x^2\\,a^2 - \\sigma_x^2}{2T} = -\\frac{\\sigma_x^2 (1 - a^2)}{2T}.\n$$\n期望的差分互相关变为\n$$\n\\mathbb{E}\\{\\widehat{C}_{+} - \\widehat{C}_{-}\\} \\approx 2 \\delta\\, R_x'(T) \\approx 2 \\delta \\left( -\\frac{\\sigma_x^2 (1 - a^2)}{2T} \\right) = -\\delta\\,\\frac{\\sigma_x^2 (1 - a^2)}{T}.\n$$\n将此结果代入白噪声归一化估计器，\n$$\n\\mathbb{E}\\{\\widehat{\\delta}\\} \\approx -\\frac{T}{\\sigma_x^2} \\mathbb{E}\\{\\widehat{C}_{+} - \\widehat{C}_{-}\\}\n= -\\frac{T}{\\sigma_x^2} \\left( -\\delta\\,\\frac{\\sigma_x^2 (1 - a^2)}{T} \\right) = \\delta\\,(1 - a^2).\n$$\n因此，期望偏差为\n$$\n\\text{bias} \\triangleq \\mathbb{E}\\{\\widehat{\\delta}\\} - \\delta = \\delta\\,(1 - a^2) - \\delta = -\\delta\\,a^2.\n$$\n这表明，当实际输入是参数为 $a$ 的 AR($1$) 模型描述的有色信号时，白噪声归一化的互相关偏移估计器会低估真实偏移，低估量与 $\\delta\\,a^2$ 成正比。当 $a = 0$（离散时间白噪声输入）时，偏差消失，并且随着 $a$ 趋近于 1，偏差的幅度增加。\n\n算法设计：\n- 以过采样因子 $L$ 模拟底层过程 $x[n]$，使得仿真时间步长为 $\\Delta t = T/L$。\n- 对于选定的 $a$ 和白噪声新息 $w[n]$，通过 AR($1$) 递归实现 $x[n]$。\n- 对于每个 $k$，在分别最接近 $2kT + \\epsilon_{\\mathcal{A}}$ 和 $(2k+1)T + \\epsilon_{\\mathcal{B}}$ 的过采样索引处采样 $A[k]$ 和 $B[k]$，为了数值对称性，使用 $\\epsilon_{\\mathcal{A}} = -\\delta/2$ 和 $\\epsilon_{\\mathcal{B}} = +\\delta/2$。\n- 形成交错序列 $S[n]$，计算 $\\widehat{R}_0$，为保证稳定性使用匹配的长度 $(K-1)$ 计算 $\\widehat{C}_{+}$ 和 $\\widehat{C}_{-}$，并通过推导的公式以秒为单位计算估计器 $\\widehat{\\delta}$。\n- 计算经验偏差 $\\widehat{\\delta} - \\delta$ 和理论偏差 $-\\delta\\,a^2$。\n- 对测试套件中的情况 $a \\in \\{0.0, 0.6, 0.95\\}$ 重复上述步骤，固定参数为 $T = 1\\times 10^{-9}\\,\\mathrm{s}$，$L = 64$，$\\delta = 12.5\\times 10^{-12}\\,\\mathrm{s}$，$K = 16384$，并为每种情况按顺序 $[\\widehat{\\delta}, \\widehat{\\delta}-\\delta, -\\delta a^2]$ 输出一个包含 9 个浮点数的单行列表，单位为秒。\n\n这个有原则的推导将估计器与 WSS 过程的互相关特性联系起来，并通过 AR($1$) 模型明确地量化了在频谱有色情况下的偏差，而高速率离散时间仿真提供了数值上稳健的估计。",
            "answer": "```python\nimport numpy as np\n\ndef generate_ar1(length, a, sigma_w, rng):\n    \"\"\"\n    Generate an AR(1) process x[n] = a x[n-1] + w[n] with white innovations w[n].\n    \"\"\"\n    x = np.empty(length, dtype=np.float64)\n    w = rng.normal(loc=0.0, scale=sigma_w, size=length)\n    x[0] = w[0]\n    for n in range(1, length):\n        x[n] = a * x[n-1] + w[n]\n    return x\n\ndef simulate_tiadc_and_estimate(a, T, delta, L, K, rng):\n    \"\"\"\n    Simulate two-channel TIADC sampling of an AR(1) input with skew delta,\n    then estimate skew using adjacent-channel cross-correlation with white-noise normalization.\n    Returns (delta_hat, empirical_bias, theoretical_bias), all in seconds.\n    \"\"\"\n    # Oversampled grid step\n    dt = T / L\n\n    # Symmetric assignment of absolute skew to channels to produce relative skew delta\n    eps_A = -delta / 2.0\n    eps_B = +delta / 2.0\n\n    # Precompute oversampled indices for A[k] and B[k]\n    # Index mapping: time t - index n = round(t / dt).\n    k = np.arange(K, dtype=np.int64)\n    offset_A = eps_A / dt\n    offset_B = eps_B / dt\n    idx_A = np.round(2 * k * L + offset_A).astype(np.int64)\n    idx_B = np.round((2 * k + 1) * L + offset_B).astype(np.int64)\n\n    # Ensure the AR(1) sequence length covers the maximum index\n    N_over = int(idx_B[-1] + 2)  # margin\n    # Choose sigma_w so that x variance is O(1). The estimator normalizes by measured energy,\n    # so absolute scale cancels; we can set sigma_w = 1 for simplicity.\n    sigma_w = 1.0\n    x = generate_ar1(N_over, a, sigma_w, rng)\n\n    # Sample A[k] and B[k]\n    A = x[idx_A]\n    B = x[idx_B]\n\n    # Form interleaved composite sequence S[n]: even indices from A, odd from B\n    S = np.empty(2 * K, dtype=np.float64)\n    S[0::2] = A\n    S[1::2] = B\n\n    # Empirical energy (autocorrelation at lag 0)\n    R0_hat = np.mean(S * S)\n\n    # Empirical adjacent-channel cross-correlations with matched lengths\n    # Use k = 1..K-1 for stability and consistent averaging.\n    C_plus_hat = np.mean(A[1:] * B[1:])       # E{A[k] B[k]}\n    C_minus_hat = np.mean(A[1:] * B[:-1])     # E{A[k] B[k-1]}\n    deltaC_hat = C_plus_hat - C_minus_hat\n\n    # White-noise normalized skew estimator: delta_hat = -(T / R0_hat) * deltaC_hat\n    delta_hat = -(T / R0_hat) * deltaC_hat\n\n    # Empirical bias and theoretical bias for AR(1)\n    empirical_bias = delta_hat - delta\n    theoretical_bias = -delta * (a ** 2)\n\n    return float(delta_hat), float(empirical_bias), float(theoretical_bias)\n\ndef solve():\n    rng = np.random.default_rng(123456789)\n\n    # Fixed parameters\n    T = 1.0e-9        # seconds\n    L = 64            # oversampling factor\n    delta = 12.5e-12  # seconds\n    K = 16384         # number of A/B pairs\n\n    # Test suite AR(1) parameters\n    a_values = [0.0, 0.6, 0.95]\n\n    results = []\n    for a in a_values:\n        delta_hat, emp_bias, th_bias = simulate_tiadc_and_estimate(a, T, delta, L, K, rng)\n        # Append in the specified order: [delta_hat, empirical_bias, theoretical_bias]\n        results.extend([delta_hat, emp_bias, th_bias])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在表征了通道失配之后，接下来的挑战是设计能够均衡各通道响应的数字滤波器。本练习将指导您完成一个标准而有效的方法：使用最小二乘法优化来设计FIR均衡器。您将处理一个假设但切合实际的通道脉冲响应模型，使每个通道的性能匹配一个共同的参考目标，从而恢复时间交错ADC的整体性能。",
            "id": "4306021",
            "problem": "时间交错模数转换器 (ADC) 由多个并行通道组成，其各自的线性时不变响应会引入增益和带宽失配，从而降低整体性能。设有 $M$ 个通道，由 $k \\in \\{0,1,\\dots,M-1\\}$ 索引。每个通道被建模为一个离散时间、因果、线性时不变系统，其冲激响应 $h_k[n]$ 在有限窗口 $n \\in \\{0,1,\\dots,L_h-1\\}$ 上测量。目标是为每个通道设计一个长度为 $L_f$ 的有限冲激响应 (FIR) 均衡器 $F_k(z)$（系数为 $f_k[n]$，$n \\in \\{0,1,\\dots,L_f-1\\}$），通过使用测得的冲激响应解决一个最小二乘问题，以最小化指定通带内各通道间的失配。然后，量化均衡后频带内的预期残余失配。\n\n从以下基本定义开始：\n\n1. 离散时间卷积：对于输入 $x[n]$，具有冲激响应 $h[n]$ 的线性时不变系统的输出为 $y[n] = \\sum_{m=-\\infty}^{\\infty} h[m] x[n-m]$。\n2. 在频率样本 $\\omega$ 上的离散时间傅里叶变换：频率响应为 $H(\\mathrm{e}^{j\\omega}) = \\sum_{n=-\\infty}^{\\infty} h[n] \\mathrm{e}^{-j\\omega n}$，此处特指有限的 $n$ 支撑。\n3. 最小二乘最优性：给定复值线性模型 $A \\mathbf{f} \\approx \\mathbf{b}$，其中 $A \\in \\mathbb{C}^{P \\times Q}$，其最小化器由 $\\min_{\\mathbf{f} \\in \\mathbb{R}^{Q}} \\|A \\mathbf{f} - \\mathbf{b}\\|_2^2$ 的解给出，可通过堆叠实部和虚部的实值形式实现。\n\n将各通道测得的冲激响应模型定义为带增益变化和离散极点的一阶低通，外加确定性测量噪声：\n$$\nh_k[n] = g_k (1 - p_k) p_k^{n} + v_k[n], \\quad n \\in \\{0,1,\\dots,L_h-1\\},\n$$\n其中 $g_k  0$ 是无量纲增益，$p_k \\in (0,1)$ 是离散时间极点，$v_k[n]$ 是一个确定性噪声序列\n$$\nv_k[n] = \\sigma \\,\\sin\\!\\left(\\frac{2\\pi (n+1)}{L_h+1}\\right) \\cos\\!\\left(\\frac{2\\pi (k+1)}{M+1}\\right),\n$$\n其中 $\\sigma \\ge 0$ 是一个无量纲噪声幅度。所有角度均以弧度为单位。在频率样本 $\\{\\omega_m\\}_{m=0}^{M_f-1}$ 处的有限长度测量频率响应计算如下\n$$\nH_k(\\mathrm{e}^{j\\omega_m}) = \\sum_{n=0}^{L_h-1} h_k[n]\\, \\mathrm{e}^{-j\\omega_m n}.\n$$\n令公共参考为各通道在每个频率上的平均值\n$$\nH_{\\mathrm{ref}}(\\mathrm{e}^{j\\omega_m}) = \\frac{1}{M} \\sum_{k=0}^{M-1} H_k(\\mathrm{e}^{j\\omega_m}).\n$$\n对于每个通道 $k$，设计一个长度为 $L_f$、系数为 $\\{f_k[n]\\}_{n=0}^{L_f-1}$ 的 FIR 均衡器 $F_k(z)$，其频率响应为\n$$\nF_k(\\mathrm{e}^{j\\omega_m}) = \\sum_{n=0}^{L_f-1} f_k[n]\\, \\mathrm{e}^{-j\\omega_m n},\n$$\n通过求解通带采样点上的最小二乘问题：\n$$\n\\min_{\\{f_k[n]\\}} \\sum_{m=0}^{M_f-1} \\left| F_k(\\mathrm{e}^{j\\omega_m})\\, H_k(\\mathrm{e}^{j\\omega_m}) - H_{\\mathrm{ref}}(\\mathrm{e}^{j\\omega_m}) \\right|^2.\n$$\n这可以通过堆叠实部和虚部来表示为一个实数域的线性系统。\n\n计算均衡器后，定义均衡后的各通道响应\n$$\nG_k(\\mathrm{e}^{j\\omega_m}) = F_k(\\mathrm{e}^{j\\omega_m})\\, H_k(\\mathrm{e}^{j\\omega_m}),\n$$\n并通过均方根归一化误差来量化频带内的残余失配\n$$\nr = \\sqrt{ \\frac{1}{M M_f} \\sum_{k=0}^{M-1} \\sum_{m=0}^{M_f-1} \\left( \\frac{ \\left| G_k(\\mathrm{e}^{j\\omega_m}) - H_{\\mathrm{ref}}(\\mathrm{e}^{j\\omega_m}) \\right| }{ \\max\\left( \\left| H_{\\mathrm{ref}}(\\mathrm{e}^{j\\omega_m}) \\right|, \\varepsilon \\right) } \\right)^2 },\n$$\n其中 $\\varepsilon$ 是一个很小的正数，以避免除以零。角度必须以弧度为单位，所有幅度都是无量纲的。\n\n您的任务是为以下参数集的测试套件实现此计算。对于每种情况，使用指定的参数生成 $\\{h_k[n]\\}$，计算通带内均匀间隔采样点上的 $\\{H_k(\\mathrm{e}^{j\\omega_m})\\}$，通过最小二乘法设计 $\\{F_k\\}$，形成 $\\{G_k\\}$，并返回标量 $r$。\n\n测试套件：\n- 情况 1（理想情况）：$M=4$， $L_h=64$， $L_f=7$， $M_f=257$， $\\Omega_b=0.45\\pi$， $g_k \\in \\{1.00, 1.02, 0.98, 1.01\\}$， $p_k \\in \\{0.90, 0.88, 0.92, 0.91\\}$， $\\sigma=0.0001$。\n- 情况 2（更高失配，更短均衡器）：$M=8$， $L_h=64$， $L_f=3$， $M_f=257$， $\\Omega_b=0.45\\pi$， $g_k \\in \\{1.00, 1.05, 0.95, 1.02, 0.97, 1.03, 0.94, 1.01\\}$， $p_k \\in \\{0.85, 0.90, 0.93, 0.88, 0.92, 0.86, 0.94, 0.89\\}$， $\\sigma=0.0005$。\n- 情况 3（边界，标量增益均衡）：$M=4$， $L_h=64$， $L_f=1$， $M_f=257$， $\\Omega_b=0.40\\pi$， $g_k \\in \\{1.04, 0.96, 1.00, 1.02\\}$， $p_k \\in \\{0.93, 0.89, 0.91, 0.92\\}$， $\\sigma=0.0001$。\n\n频率采样必须在 $[0, \\Omega_b]$ 上均匀分布，其中 $\\omega_m = \\frac{m}{M_f-1} \\Omega_b$，$m \\in \\{0,1,\\dots,M_f-1\\}$。角度以弧度为单位。最终输出应表示为一行，包含上述案例的三个残余失配值，形式为用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是一个浮点数。",
            "solution": "该问题通过结合线性时不变系统理论、离散时间傅里叶分析和最小二乘优化来解决。\n\n基本原理和建模：\n- 每个通道被建模为一个离散时间线性时不变系统，其冲激响应为 $h_k[n]$，其测量样本是有限长度的，并受到确定性测量噪声 $v_k[n]$ 的污染。在一组有限的角度 $\\omega_m$ 上的离散时间频率响应为 $H_k(\\mathrm{e}^{j\\omega_m}) = \\sum_{n=0}^{L_h-1} h_k[n] \\mathrm{e}^{-j\\omega_m n}$。\n- 均衡器是一个长度为 $L_f$、系数为 $f_k[n]$ 的有限冲激响应滤波器 $F_k(z)$，其频率响应为 $F_k(\\mathrm{e}^{j\\omega_m}) = \\sum_{n=0}^{L_f-1} f_k[n] \\mathrm{e}^{-j\\omega_m n}$。每个通道的总均衡响应为 $G_k(\\mathrm{e}^{j\\omega_m}) = F_k(\\mathrm{e}^{j\\omega_m}) H_k(\\mathrm{e}^{j\\omega_m})$。\n- 为对齐各通道，我们将参考 $H_{\\mathrm{ref}}(\\mathrm{e}^{j\\omega_m})$ 定义为在每个频率上各通道测量响应的平均值，这是一种常见的选择，以避免相对于整体的过度放大或衰减。\n\n最小二乘公式：\n- 设计目标是最小化通带采样点上的频域误差平方和：\n$$\nJ_k(\\mathbf{f}_k) = \\sum_{m=0}^{M_f-1} \\left| F_k(\\mathrm{e}^{j\\omega_m}) H_k(\\mathrm{e}^{j\\omega_m}) - H_{\\mathrm{ref}}(\\mathrm{e}^{j\\omega_m}) \\right|^2,\n$$\n其中 $\\mathbf{f}_k = [f_k[0], f_k[1], \\dots, f_k[L_f-1]]^{\\top}$。\n- 引入复值设计矩阵 $A_k \\in \\mathbb{C}^{M_f \\times L_f}$，其元素为\n$$\n[A_k]_{m,n} = H_k(\\mathrm{e}^{j\\omega_m}) \\mathrm{e}^{-j \\omega_m n}.\n$$\n那么，对于每个频率 $m$，模型可表示为\n$$\n\\sum_{n=0}^{L_f-1} [A_k]_{m,n} f_k[n] \\approx H_{\\mathrm{ref}}(\\mathrm{e}^{j\\omega_m}),\n$$\n即 $A_k \\mathbf{f}_k \\approx \\mathbf{b}$，其中 $\\mathbf{b} = [H_{\\mathrm{ref}}(\\mathrm{e}^{j\\omega_0}), \\dots, H_{\\mathrm{ref}}(\\mathrm{e}^{j\\omega_{M_f-1}})]^{\\top}$。\n- 由于系数 $f_k[n]$ 是实数，我们通过堆叠实部和虚部，将复数最小二乘问题重构为实数域问题：\n$$\n\\min_{\\mathbf{f}_k \\in \\mathbb{R}^{L_f}} \\left\\| \n\\begin{bmatrix}\n\\Re\\{A_k\\}\\\\\n\\Im\\{A_k\\}\n\\end{bmatrix} \\mathbf{f}_k - \n\\begin{bmatrix}\n\\Re\\{\\mathbf{b}\\}\\\\\n\\Im\\{\\mathbf{b}\\}\n\\end{bmatrix}\n\\right\\|_2^2.\n$$\n这确保了可以使用标准的实值最小二乘求解器进行计算。\n\n算法步骤：\n1. 对每个测试案例，使用 $\\omega_m = \\frac{m}{M_f-1} \\Omega_b$ 在 $[0, \\Omega_b]$ 上构建 $M_f$ 个均匀间隔的采样点 $\\omega_m$。\n2. 对于 $n \\in \\{0,\\dots,L_h-1\\}$ 和 $k \\in \\{0,\\dots,M-1\\}$，生成测量的冲激响应 $h_k[n] = g_k (1-p_k) p_k^n + v_k[n]$，其中 $v_k[n]$ 按指定方式生成。\n3. 通过 $H_k(\\mathrm{e}^{j\\omega_m}) = \\sum_{n=0}^{L_h-1} h_k[n] \\mathrm{e}^{-j\\omega_m n}$ 直接从测量的 $h_k[n]$ 计算频率响应 $H_k(\\mathrm{e}^{j\\omega_m})$。实现为矩阵-向量乘法，其中矩阵元素为 $\\mathrm{e}^{-j\\omega_m n}$。\n4. 形成 $H_{\\mathrm{ref}}(\\mathrm{e}^{j\\omega_m}) = \\frac{1}{M} \\sum_{k=0}^{M-1} H_k(\\mathrm{e}^{j\\omega_m})$。\n5. 对每个通道 $k$，构建 $A_k$，其元素为 $[A_k]_{m,n} = H_k(\\mathrm{e}^{j\\omega_m}) \\mathrm{e}^{-j \\omega_m n}$，并求解实值最小二乘系统\n$$\n\\begin{bmatrix}\n\\Re\\{A_k\\}\\\\\n\\Im\\{A_k\\}\n\\end{bmatrix} \\mathbf{f}_k \\approx \n\\begin{bmatrix}\n\\Re\\{H_{\\mathrm{ref}}(\\mathrm{e}^{j\\omega_m})\\}\\\\\n\\Im\\{H_{\\mathrm{ref}}(\\mathrm{e}^{j\\omega_m})\\}\n\\end{bmatrix}\n$$\n以获得 FIR 系数 $\\mathbf{f}_k$。\n6. 评估 $F_k(\\mathrm{e}^{j\\omega_m}) = \\sum_{n=0}^{L_f-1} f_k[n] \\mathrm{e}^{-j\\omega_m n}$，然后计算 $G_k(\\mathrm{e}^{j\\omega_m}) = F_k(\\mathrm{e}^{j\\omega_m}) H_k(\\mathrm{e}^{j\\omega_m})$。\n7. 计算残余失配度量\n$$\nr = \\sqrt{ \\frac{1}{M M_f} \\sum_{k=0}^{M-1} \\sum_{m=0}^{M_f-1} \\left( \\frac{ \\left| G_k(\\mathrm{e}^{j\\omega_m}) - H_{\\mathrm{ref}}(\\mathrm{e}^{j\\omega_m}) \\right| }{ \\max\\left( \\left| H_{\\mathrm{ref}}(\\mathrm{e}^{j\\omega_m}) \\right|, \\varepsilon \\right) } \\right)^2 },\n$$\n其中 $\\varepsilon$ 是一个很小的数（例如 $\\varepsilon = 10^{-12}$），以避免除以零。\n\n解释：\n- 如果 $L_f$ 相对于 $H_k(\\mathrm{e}^{j\\omega})$ 在频率上的变化足够大，最小二乘解将紧密逼近 $F_k(\\mathrm{e}^{j\\omega}) \\approx \\frac{H_{\\mathrm{ref}}(\\mathrm{e}^{j\\omega})}{H_k(\\mathrm{e}^{j\\omega})}$，并且残差 $r$ 会很小。\n- 在 $L_f=1$ 的边界情况下，均衡器简化为每个通道的标量增益，因此无法补偿带宽失配，从而增加了 $r$。\n\n程序构建了这三种情况，执行了这些步骤，并按规定输出 $[r_1,r_2,r_3]$，其中角度以弧度为单位，幅度为无量纲。",
            "answer": "```python\nimport numpy as np\n\ndef generate_impulse_responses(M, Lh, g_list, p_list, sigma):\n    \"\"\"\n    Generate measured impulse responses h_k[n] = g_k*(1-p_k)*p_k^n + v_k[n],\n    where v_k[n] is a deterministic \"noise\" sequence per the problem statement.\n    \"\"\"\n    h = np.zeros((M, Lh), dtype=float)\n    n = np.arange(Lh)\n    for k in range(M):\n        gk = g_list[k]\n        pk = p_list[k]\n        ideal = gk * (1.0 - pk) * (pk ** n)\n        # Deterministic noise as specified\n        vk = sigma * np.sin(2.0 * np.pi * (n + 1) / (Lh + 1)) * np.cos(2.0 * np.pi * (k + 1) / (M + 1))\n        h[k, :] = ideal + vk\n    return h\n\ndef frequency_samples(Mf, Omega_b):\n    \"\"\"\n    Uniform frequency sampling over [0, Omega_b] in radians.\n    \"\"\"\n    m = np.arange(Mf)\n    return (m / (Mf - 1)) * Omega_b\n\ndef compute_frequency_response(h, omega):\n    \"\"\"\n    Compute H_k(e^{j omega_m}) = sum_{n=0}^{Lh-1} h_k[n] e^{-j omega_m n}\n    for each channel k and frequency sample omega_m.\n    Returns H of shape (M, Mf) complex.\n    \"\"\"\n    M, Lh = h.shape\n    Mf = omega.shape[0]\n    # Precompute the exponential matrix E[m, n] = e^{-j omega[m] n}\n    n = np.arange(Lh)\n    # Broadcast: omega[:, None] * n[None, :]\n    E = np.exp(-1j * (omega[:, None] * n[None, :]))  # shape (Mf, Lh)\n    # For each channel k, H_k = E @ h_k\n    H = np.zeros((M, Mf), dtype=complex)\n    for k in range(M):\n        H[k, :] = E @ h[k, :]\n    return H\n\ndef design_equalizer_ls(Hk, Href, omega, Lf):\n    \"\"\"\n    For a single channel k, design FIR f_k of length Lf minimizing\n    ||A f - b||^2 where A[m, n] = Hk[m] * e^{-j omega[m] n}, b = Href[m].\n    Returns the real-valued FIR coefficients f_k[n].\n    \"\"\"\n    Mf = omega.shape[0]\n    n = np.arange(Lf)\n    # Build A complex matrix of shape (Mf, Lf)\n    A = (Hk[:, None]) * np.exp(-1j * (omega[:, None] * n[None, :]))\n    b = Href\n    # Stack real and imaginary parts to get real-valued least squares\n    Ar = np.vstack([A.real, A.imag])\n    br = np.hstack([b.real, b.imag])\n    # Solve least squares\n    f, *_ = np.linalg.lstsq(Ar, br, rcond=None)\n    return f  # real-valued coefficients\n\ndef evaluate_equalized_response(f, Hk, omega):\n    \"\"\"\n    Compute F_k(e^{j omega}) from FIR taps f, then G_k = F_k * Hk.\n    \"\"\"\n    Lf = f.shape[0]\n    n = np.arange(Lf)\n    Mf = omega.shape[0]\n    # Compute F_k(e^{j omega}) at samples omega\n    Fw = np.exp(-1j * (omega[:, None] * n[None, :])) @ f\n    Gk = Fw * Hk\n    return Gk, Fw\n\ndef residual_mismatch_metric(G_all, Href, eps=1e-12):\n    \"\"\"\n    Compute r = sqrt( mean_{k,m} ( |G_k - Href| / max(|Href|, eps) )^2 ).\n    G_all: array shape (M, Mf), complex\n    Href: array shape (Mf,), complex\n    \"\"\"\n    M, Mf = G_all.shape\n    denom = np.maximum(np.abs(Href), eps)\n    err_sq = ((np.abs(G_all - Href[None, :]) / denom[None, :]) ** 2)\n    r = np.sqrt(err_sq.mean())\n    return r\n\ndef run_case(M, Lh, Lf, Mf, Omega_b, g_list, p_list, sigma):\n    # Generate measured impulses\n    h = generate_impulse_responses(M, Lh, g_list, p_list, sigma)\n    # Frequency samples\n    omega = frequency_samples(Mf, Omega_b)\n    # Frequency responses per channel\n    H = compute_frequency_response(h, omega)  # shape (M, Mf)\n    # Reference frequency response\n    Href = H.mean(axis=0)\n    # Design equalizers per channel and evaluate equalized responses\n    G_all = np.zeros_like(H)\n    for k in range(M):\n        f_k = design_equalizer_ls(H[k, :], Href, omega, Lf)\n        Gk, _ = evaluate_equalized_response(f_k, H[k, :], omega)\n        G_all[k, :] = Gk\n    # Residual mismatch metric\n    r = residual_mismatch_metric(G_all, Href, eps=1e-12)\n    return float(r)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"M\": 4,\n            \"Lh\": 64,\n            \"Lf\": 7,\n            \"Mf\": 257,\n            \"Omega_b\": np.pi * 0.45,\n            \"g_list\": [1.00, 1.02, 0.98, 1.01],\n            \"p_list\": [0.90, 0.88, 0.92, 0.91],\n            \"sigma\": 1e-4,\n        },\n        # Case 2\n        {\n            \"M\": 8,\n            \"Lh\": 64,\n            \"Lf\": 3,\n            \"Mf\": 257,\n            \"Omega_b\": np.pi * 0.45,\n            \"g_list\": [1.00, 1.05, 0.95, 1.02, 0.97, 1.03, 0.94, 1.01],\n            \"p_list\": [0.85, 0.90, 0.93, 0.88, 0.92, 0.86, 0.94, 0.89],\n            \"sigma\": 5e-4,\n        },\n        # Case 3\n        {\n            \"M\": 4,\n            \"Lh\": 64,\n            \"Lf\": 1,\n            \"Mf\": 257,\n            \"Omega_b\": np.pi * 0.40,\n            \"g_list\": [1.04, 0.96, 1.00, 1.02],\n            \"p_list\": [0.93, 0.89, 0.91, 0.92],\n            \"sigma\": 1e-4,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        r = run_case(\n            M=case[\"M\"],\n            Lh=case[\"Lh\"],\n            Lf=case[\"Lf\"],\n            Mf=case[\"Mf\"],\n            Omega_b=case[\"Omega_b\"],\n            g_list=case[\"g_list\"],\n            p_list=case[\"p_list\"],\n            sigma=case[\"sigma\"],\n        )\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "从理想的滤波器设计到硬件实现的旅程充满了实际挑战，其中有限精度运算是一个主要问题。最后一个练习将深入探讨这一关键方面，分析将滤波器系数进行定点格式量化如何影响性能。您将学习预测由这些量化误差引起的无杂散动态范围（SFDR）的退化，这对于任何旨在在真实ADC中满足严格性能指标的设计师来说都是一项至关重要的技能。",
            "id": "4306031",
            "problem": "给定一个时间交错模数转换器 (ADC) 模型，该模型采用每通道数字校准滤波器。在 $N$ 个交错通道中，每个通道都应用一个有限脉冲响应 (FIR) 校正滤波器，其理想系数为 $\\{h_k[n]\\}_{n=0}^{L-1}$，通道索引 $k \\in \\{0,1,\\dots,N-1\\}$。在定点硬件中，每个系数都以一个有符号定点格式表示，该格式有1个整数位和 $(b-1)$ 个小数位（表示为 $Q1.(b-1)$），使用二补数算术。量化步长为 $q = 2^{-(b-1)}$，可表示范围为 $[-2, 2 - q]$。使用两种量化模式：四舍五入到最近（平局则取偶数）和向零截断。\n\n假设一个单音输入，其角频率为 $\\omega_0 = 2\\pi f_0 / f_s$，满量程幅度归一化为1（无量纲），其中 $f_0$ 是以赫兹为单位的输入音频率，$f_s$ 是以赫兹为单位的总采样频率。设通道 $k$ 在 $\\omega_0$ 处的理想每通道频率响应为\n$$\nH_k(e^{j\\omega_0}) = \\sum_{n=0}^{L-1} h_k[n] e^{-j\\omega_0 n}.\n$$\n通过定点量化，实现的系数为 $\\{\\hat{h}_k[n]\\}$，从而产生实现的响应\n$$\n\\hat{H}_k(e^{j\\omega_0}) = \\sum_{n=0}^{L-1} \\hat{h}_k[n] e^{-j\\omega_0 n}.\n$$\n将 $\\omega_0$ 处的每通道残余乘性误差因子定义为\n$$\nr_k = \\frac{\\hat{H}_k(e^{j\\omega_0})}{H_k(e^{j\\omega_0})},\n$$\n以及周期性误差序列\n$$\n\\varepsilon[k] = r_k - 1, \\quad k = 0,1,\\dots,N-1.\n$$\n由于时间交错在采样索引 $n$ 处应用通道 $k = n \\bmod N$，单音信号会与周期序列 $1+\\varepsilon[n \\bmod N]$ 相乘。产生的频谱在 $f_0 \\pm m \\frac{f_s}{N}$（其中 $m = 1,2,\\dots,N-1$）处包含杂散音（杂散），其复振幅由离散傅里叶级数系数决定\n$$\n\\alpha_m = \\frac{1}{N} \\sum_{k=0}^{N-1} \\varepsilon[k] e^{-j 2\\pi m k / N}, \\quad m = 0,1,\\dots,N-1.\n$$\n最高杂散幅度为 $\\max_{m \\in \\{1,\\dots,N-1\\}} |\\alpha_m|$。仅由定点系数的量化引起的信号音处的无杂散动态范围 (SFDR) 可通过以下公式预测：\n$$\n\\mathrm{SFDR}_{\\mathrm{dBc}} = -20 \\log_{10} \\left( \\max_{m \\in \\{1,\\dots,N-1\\}} |\\alpha_m| \\right).\n$$\n如果 $\\max_{m \\in \\{1,\\dots,N-1\\}} |\\alpha_m|$ 在 $10^{-15}$ 的容差范围内数值上为零，则将 SFDR 报告为 $300.0$ dBc（相对于载波的分贝）。\n\n从上述基于原理的模型和定义出发，编写一个完整的程序，对每个测试用例执行以下操作：\n- 使用指定的定点格式 $Q1.(b-1)$、量化步长 $q = 2^{-(b-1)}$ 以及指定的量化模式（舍入或截断），将每个系数 $h_k[n]$ 量化为 $\\hat{h}_k[n]$。\n- 为每个通道计算 $H_k(e^{j\\omega_0})$ 和 $\\hat{H}_k(e^{j\\omega_0})$。\n- 对 $k=0,\\dots,N-1$，构建序列 $\\varepsilon[k] = \\hat{H}_k(e^{j\\omega_0}) / H_k(e^{j\\omega_0}) - 1$。\n- 计算 $m=1,\\dots,N-1$ 时的 $\\alpha_m$ 并评估 $\\mathrm{SFDR}_{\\mathrm{dBc}}$。\n\n使用以下参数集测试套件。对于所有情况，$f_0$ 和 $f_s$ 的单位均为赫兹 (Hz)。SFDR 结果必须表示为以 dBc 为单位的浮点数。系数以每个通道的列表形式给出。对于对称三阶抽头情况，通道 $k$ 使用 $[a_k, 1-2a_k, a_k]$。\n\n测试套件：\n1. $N=4$，$f_s = 1.00\\times 10^8$ Hz，$f_0 = 1.73\\times 10^7$ Hz，$b=12$，舍入模式，单阶抽头滤波器：\n   - 通道 0：$[1.011]$\n   - 通道 1：$[0.989]$\n   - 通道 2：$[1.025]$\n   - 通道 3：$[0.995]$\n2. 与情况1相同，但使用截断模式。\n3. $N=4$，$f_s = 2.00\\times 10^8$ Hz，$f_0 = 4.80\\times 10^7$ Hz，$b=10$，舍入模式，对称三阶抽头滤波器：\n   - $a = [0.060, 0.045, 0.070, 0.050]$，因此各通道分别为 $[a_k, 1-2a_k, a_k]$。\n4. $N=8$，$f_s = 1.60\\times 10^8$ Hz，$f_0 = 5.70\\times 10^7$ Hz，$b=8$，舍入模式，单阶抽头滤波器：\n   - 各通道：$[1.08], [0.94], [1.12], [0.96], [1.07], [0.93], [1.05], [0.97]$\n5. 与情况4相同，但 $b=24$，舍入模式。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，`[result1,result2,result3]`）。每个结果对应于按给定顺序排列的匹配测试用例的预测 $\\mathrm{SFDR}_{\\mathrm{dBc}}$。所有输出都是以 dBc 为单位的浮点数。如果需要，请使用标准浮点规则进行内部舍入；打印的数值必须是计算出的浮点结果，不带任何单位符号。",
            "solution": "该问题被认为是有效的，因为它在科学上基于数字信号处理和混合信号电路理论的原理，定义良好，提供了所有必要的参数和定义，并以客观、正式的语言陈述。因此，我们可以着手解决。\n\n核心任务是计算时间交错模数转换器 (ADC) 系统中的无杂散动态范围 (SFDR)，其中杂散音是由每通道校准滤波器中系数的定点量化引入的。计算过程通过一系列步骤进行，从量化滤波器系数到分析产生的周期性误差频谱。\n\n**步骤1：系统参数和系数的量化**\n\n首先，我们为每种情况确定参数：通道数 $N$、总采样频率 $f_s$、输入音频率 $f_0$、用于定点表示的比特数 $b$、理想滤波器系数 $\\{h_k[n]\\}$ 以及量化模式。输入音的归一化角频率为 $\\omega_0 = 2\\pi f_0 / f_s$。\n\n滤波器系数以有符号 $Q1.(b-1)$ 定点格式实现。量化步长定义为 $q = 2^{-(b-1)}$。每个理想系数 $h_k[n]$ 都被转换为其量化后的对应值 $\\hat{h}_k[n]$。问题指定了两种量化模式：\n\n1.  **向零截断**：将值乘以 $1/q$ 进行缩放，丢弃小数部分，然后将结果乘以 $q$ 缩放回去。对于一个值 $x$，这表示为 $\\hat{x} = q \\cdot \\mathrm{trunc}(x/q)$，其中 $\\mathrm{trunc}(\\cdot)$ 是截断函数（例如，`-3.7` 变为 `-3`）。\n\n2.  **四舍五入到最近，平局则取偶数**：将值乘以 $1/q$ 进行缩放，四舍五入到最近的整数（以 `.5` 结尾的值四舍五入到最近的偶数），然后将结果乘以 $q$ 缩放回去。对于一个值 $x$，这表示为 $\\hat{x} = q \\cdot \\mathrm{round}(x/q)$。\n\n问题指定的可表示范围为 $[-2, 2-q]$。所有提供的理想系数都在此范围内，因此不需要削波逻辑。\n\n**步骤2：每通道频率响应计算**\n\n对于每个通道 $k \\in \\{0, 1, \\dots, N-1\\}$，理想和实现的 FIR 滤波器在输入音的角频率 $\\omega_0$ 处具有频率响应。这些响应是通过在 $z = e^{j\\omega_0}$ 处计算滤波器系数的离散时间傅里叶变换 (DTFT) 得到的。\n\n通道 $k$ 的理想频率响应为：\n$$\nH_k(e^{j\\omega_0}) = \\sum_{n=0}^{L-1} h_k[n] e^{-j\\omega_0 n}\n$$\n其中 $L$ 是 FIR 滤波器的长度。\n\n同样，使用量化系数的实现频率响应为：\n$$\n\\hat{H}_k(e^{j\\omega_0}) = \\sum_{n=0}^{L-1} \\hat{h}_k[n] e^{-j\\omega_0 n}\n$$\n\n**步骤3：周期性误差序列**\n\n系数的量化会在每个通道的频率响应中引入误差。每个通道的相对误差由乘性误差因子 $r_k$ 捕捉。此因子与1的偏差 $\\varepsilon[k]$ 形成一个长度为 $N$ 的周期序列：\n$$\n\\varepsilon[k] = r_k - 1 = \\frac{\\hat{H}_k(e^{j\\omega_0})}{H_k(e^{j\\omega_0})} - 1, \\quad k = 0, 1, \\dots, N-1\n$$\n这个复值序列 $\\varepsilon[k]$ 代表了将调制输入信号的周期性失配模式，从而产生杂散音。\n\n**步骤4：杂散幅度计算**\n\n误差序列对输入信号的周期性调制导致输出频谱中在频率 $f_0 \\pm m \\frac{f_s}{N}$ 处出现杂散。这些杂散相对于主音的复振幅由误差序列 $\\varepsilon[k]$ 的离散傅里叶级数 (DFS) 系数给出。DFS 在计算上等效于离散傅里叶变换 (DFT)。第 $m$ 个杂散的复振幅 $\\alpha_m$ 为：\n$$\n\\alpha_m = \\frac{1}{N} \\sum_{k=0}^{N-1} \\varepsilon[k] e^{-j 2\\pi m k / N}, \\quad m = 0, 1, \\dots, N-1\n$$\n这可以使用快速傅里叶变换 (FFT) 算法高效地计算：\n$$\n\\alpha = \\frac{1}{N} \\mathrm{FFT}(\\varepsilon)\n$$\n项 $\\alpha_0$ 对应于平均直流误差，不是杂散。杂散对应于 $m \\in \\{1, 2, \\dots, N-1\\}$。\n\n**步骤5：SFDR 计算**\n\n无杂散动态范围 (SFDR) 定义为载波功率与最强杂散音功率之比。用相对幅度表示，它是最大杂散幅度的倒数。SFDR 通常以相对于载波的分贝 (dBc) 表示。\n首先，我们找到所有相关杂散中的最大幅度：\n$$\n\\alpha_{\\max} = \\max_{m \\in \\{1, 2, \\dots, N-1\\}} |\\alpha_m|\n$$\n然后，SFDR 计算如下：\n$$\n\\mathrm{SFDR}_{\\mathrm{dBc}} = -20 \\log_{10}(\\alpha_{\\max})\n$$\n根据问题规范，如果 $\\alpha_{\\max}$ 在数值上为零（即小于 $10^{-15}$ 的容差），则 SFDR 报告为一个有限的大值 $300.0$ dBc，以表示理想校正的情况。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and compute the SFDR.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"N\": 4, \"fs\": 1.00e8, \"f0\": 1.73e7, \"b\": 12, \"mode\": \"rounding\",\n            \"coeffs\": [[1.011], [0.989], [1.025], [0.995]]\n        },\n        {\n            \"N\": 4, \"fs\": 1.00e8, \"f0\": 1.73e7, \"b\": 12, \"mode\": \"truncation\",\n            \"coeffs\": [[1.011], [0.989], [1.025], [0.995]]\n        },\n        {\n            \"N\": 4, \"fs\": 2.00e8, \"f0\": 4.80e7, \"b\": 10, \"mode\": \"rounding\",\n            \"a_vals\": [0.060, 0.045, 0.070, 0.050]\n        },\n        {\n            \"N\": 8, \"fs\": 1.60e8, \"f0\": 5.70e7, \"b\": 8, \"mode\": \"rounding\",\n            \"coeffs\": [[1.08], [0.94], [1.12], [0.96], [1.07], [0.93], [1.05], [0.97]]\n        },\n        {\n            \"N\": 8, \"fs\": 1.60e8, \"f0\": 5.70e7, \"b\": 24, \"mode\": \"rounding\",\n            \"coeffs\": [[1.08], [0.94], [1.12], [0.96], [1.07], [0.93], [1.05], [0.97]]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        sfdr = calculate_sfdr(case)\n        results.append(sfdr)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef quantize(h_values, b, mode):\n    \"\"\"\n    Quantizes floating-point coefficients to a fixed-point representation.\n    \n    Args:\n        h_values (np.ndarray): Array of ideal coefficients.\n        b (int): Total number of bits. Format is Q1.(b-1).\n        mode (str): 'rounding' or 'truncation'.\n        \n    Returns:\n        np.ndarray: Array of quantized coefficients.\n    \"\"\"\n    q = 2.0**(-(b - 1))\n    scaled_h = h_values / q\n    \n    if mode == 'rounding':\n        # np.round rounds to nearest even for .5 cases, matching the spec.\n        quantized_scaled_h = np.round(scaled_h)\n    elif mode == 'truncation':\n        # np.trunc discards the fractional part (truncates toward zero).\n        quantized_scaled_h = np.trunc(scaled_h)\n    else:\n        raise ValueError(\"Invalid quantization mode specified.\")\n        \n    return quantized_scaled_h * q\n\ndef calculate_sfdr(params):\n    \"\"\"\n    Calculates SFDR for a single test case.\n    \"\"\"\n    N = params[\"N\"]\n    fs = params[\"fs\"]\n    f0 = params[\"f0\"]\n    b = params[\"b\"]\n    mode = params[\"mode\"]\n\n    if \"coeffs\" in params:\n        h_ideal = np.array(params[\"coeffs\"], dtype=float)\n    elif \"a_vals\" in params:\n        h_ideal = np.array([[a, 1 - 2*a, a] for a in params[\"a_vals\"]], dtype=float)\n\n    L = h_ideal.shape[1]\n    \n    # 1. Quantize coefficients\n    h_quantized = quantize(h_ideal, b, mode)\n\n    # 2. Calculate frequency responses\n    w0 = 2 * np.pi * f0 / fs\n    n_indices = np.arange(L)\n    exp_vector = np.exp(-1j * w0 * n_indices)\n    \n    H_ideal = np.sum(h_ideal * exp_vector, axis=1)\n    H_quantized = np.sum(h_quantized * exp_vector, axis=1)\n\n    # 3. Form the periodic error sequence\n    epsilon_sequence = H_quantized / H_ideal - 1\n\n    # 4. Compute spur amplitudes using FFT\n    # alpha_m = (1/N) * FFT(epsilon)[m]\n    alpha = np.fft.fft(epsilon_sequence) / N\n\n    # 5. Calculate SFDR\n    # Spurs are at m = 1, 2, ..., N-1\n    if N > 1:\n        spur_mags = np.abs(alpha[1:N])\n        max_spur_mag = np.max(spur_mags)\n    else:\n        # No interleaving spurs for a single channel\n        max_spur_mag = 0.0\n\n    if max_spur_mag  1e-15:\n        sfdr_dbc = 300.0\n    else:\n        sfdr_dbc = -20 * np.log10(max_spur_mag)\n        \n    return sfdr_dbc\n\nsolve()\n```"
        }
    ]
}