{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在探讨均匀缺陷分布（泊松模型）与集聚缺陷（负二项模型）这两种假设之间的关键区别 。通过计算两种模型预测结果产生显著差异的芯片面积，您将深刻理解为何精确的缺陷空间建模对于大面积芯片至关重要。这项实践将巩固您对缺陷限制性成品率的理论基础。",
            "id": "4281279",
            "problem": "一条集成电路生产线在某种情况下运行，其随机致命缺陷可以使用点过程来处理。假设以下建模基础：\n\n- 在空间均匀缺陷的情况下，面积为 $A$ 的芯片上的致命缺陷数量服从均值为 $\\mu = D_{0} A$ 的泊松分布（Poisson distribution），其中 $D_{0}$ 是缺陷密度，单位为“缺陷数/平方厘米”。芯片良率是指芯片上没有致命缺陷的概率。\n\n- 在空间聚集缺陷的情况下，晶圆上的局部缺陷率是异质的：在局部缺陷率为 $\\Lambda$ 的条件下，芯片上的缺陷服从均值为 $\\Lambda A$ 的泊松分布，并且芯片间 $\\Lambda$ 的异质性服从形状参数为 $\\alpha$ 的伽马分布（Gamma distribution），该参数量化了聚集程度。芯片良率是在这种非均匀性上边缘化后的零致命缺陷概率。\n\n严格根据这些定义，推导在均匀（泊松）和聚集（伽马-泊松混合）情况下的芯片良率的闭式表达式，然后确定芯片面积 $A$（单位：$\\mathrm{cm}^{2}$）。在此面积下，对于一个缺陷密度 $D_{0} = 0.3$ 缺陷/平方厘米、聚集参数 $\\alpha = 5$ 的工艺，聚集模型的良率是均匀模型良率的 $1.05$ 倍。将最终的 $A$ 数值结果四舍五入到三位有效数字，并以平方厘米表示。此外，讨论你的结果对预测制造良率以及在聚集情况下成本对芯片尺寸敏感性的实际意义。你的最终答案必须仅为计算出的 $A$ 值。",
            "solution": "用户提供了一个问题陈述，在尝试解答之前需要对其进行验证。\n\n### 步骤 1：提取已知条件\n-   对于均匀缺陷分布，面积为 $A$ 的芯片上的致命缺陷数量服从均值为 $\\mu = D_{0} A$ 的泊松分布。\n-   $D_{0}$ 是缺陷密度。\n-   良率是零致命缺陷的概率。\n-   对于聚集缺陷分布，在局部缺陷率为 $\\Lambda$ 的条件下，面积为 $A$ 的芯片上的致命缺陷数量服从均值为 $\\Lambda A$ 的泊松分布。\n-   局部缺陷率 $\\Lambda$ 服从形状参数为 $\\alpha$ 的伽马分布。\n-   目标是找到芯片面积 $A$（单位：$\\mathrm{cm}^{2}$），使得聚集模型的良率是均匀模型良率的 $1.05$ 倍。\n-   给定参数为 $D_{0} = 0.3 \\text{ 缺陷/cm}^2$ 和 $\\alpha = 5$。\n-   最终的 $A$ 数值结果必须四舍五入到三位有效数字。\n-   解答必须包括对实际意义的讨论。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题陈述具有科学依据，提法恰当且客观。它基于集成电路制造良率的标准且广为接受的统计模型：用于纯随机缺陷的泊松模型和用于聚集缺陷的伽马-泊松（负二项）模型。所提供的参数，$D_{0} = 0.3 \\text{ 缺陷/cm}^2$ 和 $\\alpha = 5$，对于半导体制造工艺是符合实际的。该问题隐含地假设局部缺陷率的伽马分布的均值 $E[\\Lambda]$ 等于全局平均缺陷密度 $D_{0}$。这是对两个模型进行有意义比较的标准且必要条件，并不会使问题无效；相反，这是该领域的标准惯例。该问题是自洽的，可进行数学形式化，并具有唯一且有意义的解。\n\n### 步骤 3：结论与行动\n该问题被认为是有效的。将提供完整的解答。\n\n### 良率模型的推导\n\n首先，我们根据问题中的定义，推导两种模型下芯片良率的闭式表达式。良率 $Y$ 是指芯片上致命缺陷数量为零的概率。\n\n**1. 均匀（泊松）模型**\n\n设 $N$ 为面积为 $A$ 的芯片上致命缺陷数量的随机变量。根据题目，$N$ 服从均值为 $\\mu = D_{0} A$ 的泊松分布。泊松分布的概率质量函数 (PMF) 由下式给出：\n$$\nP(N=k) = \\frac{\\mu^{k} e^{-\\mu}}{k!} = \\frac{(D_{0}A)^{k} \\exp(-D_{0}A)}{k!}\n$$\n我们记为 $Y_{\\text{hom}}$ 的良率，是缺陷数量为零（$k=0$）的概率：\n$$\nY_{\\text{hom}}(A) = P(N=0) = \\frac{(D_{0}A)^{0} \\exp(-D_{0}A)}{0!}\n$$\n由于 $x^{0}=1$ 且 $0!=1$，上式可简化为众所周知的泊松良率模型：\n$$\nY_{\\text{hom}}(A) = \\exp(-D_{0}A)\n$$\n\n**2. 聚集（伽马-泊松）模型**\n\n在此模型中，缺陷密度不是均匀的。局部缺陷密度 $\\Lambda$ 本身是一个服从伽马分布的随机变量。具有形状参数 $\\alpha$ 和尺度参数 $\\theta$ 的伽马分布的概率密度函数 (PDF) 为：\n$$\nf(\\lambda; \\alpha, \\theta) = \\frac{\\lambda^{\\alpha-1} \\exp(-\\lambda/\\theta)}{\\theta^{\\alpha} \\Gamma(\\alpha)} \\quad \\text{for } \\lambda \\ge 0\n$$\n其中 $\\Gamma(\\alpha)$ 是伽马函数。为了使两个模型具有可比性，它们必须具有相同的总体平均缺陷密度。我们将 $\\Lambda$ 的期望值设为等于 $D_{0}$：\n$$\nE[\\Lambda] = \\alpha\\theta = D_{0}\n$$\n由此，我们确定尺度参数 $\\theta = D_{0}/\\alpha$。将其代回 PDF：\n$$\nf(\\lambda) = \\frac{\\lambda^{\\alpha-1} \\exp(-\\lambda\\alpha/D_{0})}{(D_{0}/\\alpha)^{\\alpha} \\Gamma(\\alpha)}\n$$\n在给定特定值 $\\Lambda = \\lambda$ 的条件下，缺陷数量 $N$ 服从均值为 $\\lambda A$ 的泊松分布。零缺陷的条件概率是：\n$$\nP(N=0 | \\Lambda = \\lambda) = \\exp(-\\lambda A)\n$$\n为了求出聚集模型的总良率 $Y_{\\text{clust}}$，我们必须通过对由 $\\Lambda$ 的 PDF 加权的条件概率进行积分，来对所有可能的 $\\lambda$ 值进行边缘化：\n$$\nY_{\\text{clust}}(A) = \\int_{0}^{\\infty} P(N=0 | \\Lambda=\\lambda) f(\\lambda) \\,d\\lambda = \\int_{0}^{\\infty} \\exp(-\\lambda A) \\frac{\\lambda^{\\alpha-1} \\exp(-\\lambda\\alpha/D_{0})}{(D_{0}/\\alpha)^{\\alpha} \\Gamma(\\alpha)} \\,d\\lambda\n$$\n合并指数项并提出常数：\n$$\nY_{\\text{clust}}(A) = \\frac{1}{(D_{0}/\\alpha)^{\\alpha} \\Gamma(\\alpha)} \\int_{0}^{\\infty} \\lambda^{\\alpha-1} \\exp\\left(-\\lambda \\left(A + \\frac{\\alpha}{D_{0}}\\right)\\right) \\,d\\lambda\n$$\n该积分具有伽马函数的形式。使用恒等式 $\\int_{0}^{\\infty} x^{z-1} \\exp(-cx) \\,dx = \\frac{\\Gamma(z)}{c^{z}}$，其中 $z=\\alpha$ 且 $c = A + \\frac{\\alpha}{D_{0}}$，该积分的计算结果为：\n$$\n\\int_{0}^{\\infty} \\lambda^{\\alpha-1} \\exp\\left(-\\lambda \\left(\\frac{AD_{0}+\\alpha}{D_{0}}\\right)\\right) \\,d\\lambda = \\frac{\\Gamma(\\alpha)}{\\left(\\frac{AD_{0}+\\alpha}{D_{0}}\\right)^{\\alpha}}\n$$\n将此结果代回 $Y_{\\text{clust}}(A)$ 的表达式中：\n$$\nY_{\\text{clust}}(A) = \\frac{1}{(D_{0}/\\alpha)^{\\alpha} \\Gamma(\\alpha)} \\cdot \\frac{\\Gamma(\\alpha)}{\\left(\\frac{AD_{0}+\\alpha}{D_{0}}\\right)^{\\alpha}} = \\left(\\frac{\\alpha}{D_{0}}\\right)^{\\alpha} \\left(\\frac{D_{0}}{AD_{0}+\\alpha}\\right)^{\\alpha}\n$$\n这可以简化为负二项良率模型：\n$$\nY_{\\text{clust}}(A) = \\left(\\frac{\\alpha}{AD_{0}+\\alpha}\\right)^{\\alpha} = \\left(1 + \\frac{D_{0}A}{\\alpha}\\right)^{-\\alpha}\n$$\n\n### 求解芯片面积 A\n\n问题要求找到面积 $A$，使得聚集模型的良率是均匀模型良率的 $1.05$ 倍。这个条件表示为：\n$$\nY_{\\text{clust}}(A) = 1.05 \\cdot Y_{\\text{hom}}(A)\n$$\n代入推导出的良率公式：\n$$\n\\left(1 + \\frac{D_{0}A}{\\alpha}\\right)^{-\\alpha} = 1.05 \\cdot \\exp(-D_{0}A)\n$$\n现在，我们代入给定的数值：$D_{0} = 0.3$ 和 $\\alpha = 5$。\n$$\n\\left(1 + \\frac{0.3 A}{5}\\right)^{-5} = 1.05 \\cdot \\exp(-0.3 A)\n$$\n$$\n(1 + 0.06 A)^{-5} = 1.05 \\cdot \\exp(-0.3 A)\n$$\n这是一个必须求解 $A$ 的超越方程。为了便于数值求解，我们可以对两边取自然对数：\n$$\n\\ln\\left((1 + 0.06 A)^{-5}\\right) = \\ln(1.05 \\cdot \\exp(-0.3 A))\n$$\n$$\n-5 \\ln(1 + 0.06 A) = \\ln(1.05) - 0.3 A\n$$\n整理各项，我们寻求函数 $g(A)$ 的根：\n$$\ng(A) = 0.3 A - 5 \\ln(1 + 0.06 A) - \\ln(1.05) = 0\n$$\n我们可以数值求解这个方程。使用数值求解器（例如牛顿-拉夫逊方法或计算工具中的内置求解函数），我们找到 $A$ 的值。让我们对根进行迭代搜索。\n$\\ln(1.05)$ 的值约等于 $0.048790$。\n让我们测试 $A = 2.4$：\n$g(2.4) = 0.3(2.4) - 5\\ln(1 + 0.06 \\times 2.4) - 0.04879 = 0.72 - 5\\ln(1.144) - 0.04879 \\approx 0.72 - 5(0.13456) - 0.04879 = 0.72 - 0.6728 - 0.04879 = -0.00159$。\n让我们测试 $A = 2.44$：\n$g(2.44) = 0.3(2.44) - 5\\ln(1 + 0.06 \\times 2.44) - 0.04879 = 0.732 - 5\\ln(1.1464) - 0.04879 \\approx 0.732 - 5(0.13661) - 0.04879 = 0.732 - 0.68305 - 0.04879 = 0.00016$。\n根在 $A=2.4$ 和 $A=2.44$ 之间。更精确的计算得出 $A \\approx 2.4384$。\n将结果四舍五入到三位有效数字，我们得到 $A = 2.44 \\, \\mathrm{cm}^{2}$。\n\n### 实际意义的讨论\n\n结果表明，对于芯片面积为 $A = 2.44 \\, \\mathrm{cm}^{2}$（对于现代处理器而言是一个相对较大但常见的尺寸），更符合实际的聚集缺陷模型预测的良率比过于简化的均匀泊松模型预测的良率高出 $5\\%$。这有两个主要的实际意义：\n\n1.  **对于预测制造良率：** 简单的泊松模型一贯是悲观的。它假设缺陷是均匀分布的，而实际上缺陷倾向于聚集。这种聚集“保护”了晶圆的某些部分，导致无缺陷芯片的数量比在均匀分布下预期的要多。对于给定的平均缺陷密度 $D_{0}$，实际良率将高于 $\\exp(-D_{0}A)$。准确预测良率对于财务预测和工艺规划至关重要。依赖泊松模型可能导致低估盈利能力并做出错误的决策，例如过早地中止一个有前景但看似低良率的制造工艺。捕获空间统计数据，如聚集参数 $\\alpha$，对于精确的良率建模至关重要。\n\n2.  **对于聚集情况下成本对芯片尺寸的敏感性：** 与均匀模型相比，聚集模型中因芯片尺寸增大而产生的良率损失要小得多。泊松良率 $Y_{\\text{hom}} = \\exp(-D_{0}A)$ 随面积呈指数衰减，这使得非常大的芯片在经济上显得不可行。相比之下，负二项良率 $Y_{\\text{clust}} = (1 + D_{0}A/\\alpha)^{-\\alpha}$ 在 $A$ 较大时按幂律衰减。这种较慢的衰减速率使得更大的芯片（例如，用于高性能计算、GPU 和 FPGA 的芯片）从成本角度来看更为可行。分析表明，比率 $Y_{\\text{clust}}/Y_{\\text{hom}}$ 随 $A$ 的增大而增长，这意味着对于更大、更复杂的芯片，考虑聚集效应的经济优势变得更加显著。这种理解改变了芯片设计中涉及的经济权衡，可能为采用比在简单泊松良率假设下所考虑的更大的芯片尺寸提供了理由。",
            "answer": "$$\n\\boxed{2.44}\n$$"
        },
        {
            "introduction": "真实的制造数据总是包含可预测的系统性趋势（如径向效应）和不可预测的随机噪声 。本练习将指导您完成一个常见的数据分析流程：使用多项式回归对晶圆测量数据中的系统性成分进行建模并将其移除。通过此过程，您将学习如何分离出对于精确参数成品率预测至关重要的随机变量。",
            "id": "4281302",
            "problem": "给定在多个芯片位置收集的单个标量电学参数的晶圆级测量数据集。假设主导的系统性变化是径向对称的，并随归一化半径平滑变化。任务是将测量值分解为一个系统性径向分量和一个随机分量，以适用于参数化良率预测。\n\n从以下基本原理出发：\n- 普通最小二乘法 (OLS) 通过最小化残差平方和来估计线性模型的参数。\n- 对于均值为零、方差为 $\\sigma^{2}$ 的独立同分布高斯噪声，无偏残差方差估计量是将残差平方和除以自由度。\n- 在高斯模型下，通过在规格下限和上限之间对高斯概率密度函数进行积分，可以计算出双边规格窗口内的参数化良率。\n\n对于每个测试用例，给定：\n- 一个归一化半径列表 $\\{r_{i}\\}_{i=1}^{N}$，其中每个 $r_{i} \\in [0, 1]$。\n- 一个对应的标量测量值列表 $\\{x_{i}\\}_{i=1}^{N}$。\n- 一个非负整数多项式次数 $d$，指定系统性分量的径向多项式模型的次数。\n- 一个双边规格区间 $[L, U]$，其中 $L  U$，其单位与测量值相同，均为无量纲单位。\n\n您的程序必须为每个测试用例执行以下操作：\n1. 使用普通最小二乘法将多项式模型 $m(r) = \\sum_{k=0}^{d} a_{k} r^{k}$ 拟合到数据 $\\{(r_{i}, x_{i})\\}$。\n2. 计算残差 $e_{i} = x_{i} - m(r_{i})$，并假设 $N > d + 1$，使用无偏估计量估算随机标准差 $\\hat{\\sigma} = \\sqrt{\\frac{\\sum_{i=1}^{N} e_{i}^{2}}{N - (d + 1)}}$。\n3. 对于每个芯片位置 $i$，假设 $X_{i} \\sim \\mathcal{N}(m(r_{i}), \\hat{\\sigma}^{2})$，计算从随机分量中抽取的新样本 $X_{i}$ 加上拟合均值 $m(r_{i})$ 后落在规格窗口内的概率。这个芯片级接受概率是高斯密度在 $L$ 和 $U$ 之间的积分。如果 $\\hat{\\sigma} = 0$，则当 $L \\le m(r_{i}) \\le U$ 时，定义芯片级接受概率为 $1$，否则为 $0$。\n4. 将晶圆级预测良率报告为所提供位置上芯片级接受概率的算术平均值，表示为 $[0, 1]$ 范围内的小数，并精确到 $6$ 位小数。\n\n所有量均为无量纲。不使用角度。百分比必须以小数形式表示。\n\n测试套件：\n- 案例 $1$（一般二次趋势，中等噪声）：\n  - 半径 $[r_{i}]$: [$0.00$, $0.20$, $0.35$, $0.50$, $0.65$, $0.80$, $0.90$, $1.00$, $0.10$, $0.30$, $0.55$, $0.85$]\n  - 测量值 $[x_{i}]$: [$0.0100$, $-0.0290$, $-0.0636$, $-0.0475$, $-0.0746$, $-0.0600$, $-0.0565$, $-0.0510$, $-0.0125$, $-0.0505$, $-0.0526$, $-0.0686$]\n  - 多项式次数 $d = 2$\n  - 规格 $[L, U] = [-0.08, 0.05]$\n- 案例 $2$（无趋势模型，小随机变异）：\n  - 半径 $[r_{i}]$: [$0.00$, $0.20$, $0.40$, $0.60$, $0.80$, $1.00$, $0.30$, $0.70$]\n  - 测量值 $[x_{i}]$: [$0.0050$, $-0.0030$, $0.0020$, $-0.0100$, $0.0060$, $-0.0040$, $0.0010$, $-0.0090$]\n  - 多项式次数 $d = 0$\n  - 规格 $[L, U] = [-0.02, 0.02]$\n- 案例 $3$（近线性趋势，近零随机变异）：\n  - 半径 $[r_{i}]$: [$0.00$, $0.25$, $0.50$, $0.75$, $1.00$]\n  - 测量值 $[x_{i}]$: [$0.20010$, $0.17480$, $0.15000$, $0.12515$, $0.09995$]\n  - 多项式次数 $d = 1$\n  - 规格 $[L, U] = [0.09, 0.21]$\n- 案例 $4$（样本点少的二次趋势，小噪声）：\n  - 半径 $[r_{i}]$: [$0.00$, $0.50$, $0.80$, $1.00$]\n  - 测量值 $[x_{i}]$: [$-0.0440$, $-0.0380$, $-0.0268$, $-0.0320$]\n  - 多项式次数 $d = 2$\n  - 规格 $[L, U] = [-0.06, -0.02]$\n\n您的程序应生成单行输出，其中包含按上述案例顺序排列的四个晶圆级预测良率，格式为方括号内以逗号分隔的列表，每个良率值精确到六位小数（例如，$[0.987650,0.934210,0.500000,0.123456]$）。",
            "solution": "该问题定义明确，有科学依据，并为获得唯一解提供了所有必要信息。因此，该问题被认为是有效的。解决方案通过实施指定的统计建模和良率预测工作流程来推进。\n\n问题的核心是将一组在给定归一化径向位置 $\\{r_i\\}_{i=1}^{N}$ 上的晶圆级测量值 $\\{x_i\\}_{i=1}^{N}$ 分解为一个系统性径向分量 $m(r)$ 和一个随机分量 $e$。\n\n**1. 系统性分量建模与参数估计**\n\n系统性径向变化由每个案例中指定次数 $d$ 的多项式建模：\n$$\nm(r) = \\sum_{k=0}^{d} a_{k} r^{k} = a_0 + a_1 r + a_2 r^2 + \\dots + a_d r^d\n$$\n未知系数 $\\mathbf{a} = [a_0, a_1, \\dots, a_d]^T$ 通过使用普通最小二乘法 (OLS) 将此模型拟合到测量数据 $\\{(r_i, x_i)\\}_{i=1}^{N}$ 来确定。OLS 过程旨在最小化测量值 $x_i$ 与模型预测值 $m(r_i)$ 之间的平方差之和。\n\n这可以表述为一个线性代数问题。令 $\\mathbf{x}$ 为测量的 $N \\times 1$ 向量，$\\mathbf{a}$ 为系数的 $(d+1) \\times 1$ 向量，$\\mathbf{R}$ 为 $N \\times (d+1)$ 的设计矩阵，在此背景下通常称为范德蒙矩阵 (Vandermonde matrix)：\n$$\n\\mathbf{x} = \n\\begin{pmatrix}\nx_1 \\\\\nx_2 \\\\\n\\vdots \\\\\nx_N\n\\end{pmatrix},\n\\quad\n\\mathbf{R} = \n\\begin{pmatrix}\n1  r_1  r_1^2  \\dots  r_1^d \\\\\n1  r_2  r_2^2  \\dots  r_2^d \\\\\n\\vdots  \\vdots  \\vdots  \\ddots  \\vdots \\\\\n1  r_N  r_N^2  \\dots  r_N^d\n\\end{pmatrix},\n\\quad\n\\mathbf{a} = \n\\begin{pmatrix}\na_0 \\\\\na_1 \\\\\n\\vdots \\\\\na_d\n\\end{pmatrix}\n$$\nOLS 问题旨在找到一个系数向量 $\\hat{\\mathbf{a}}$，以最小化残差向量 $\\mathbf{e} = \\mathbf{x} - \\mathbf{R}\\mathbf{a}$ 的欧几里得范数的平方：\n$$\n\\hat{\\mathbf{a}} = \\arg\\min_{\\mathbf{a}} \\|\\mathbf{x} - \\mathbf{R}\\mathbf{a}\\|^2\n$$\n解由正规方程组给出：$(\\mathbf{R}^T \\mathbf{R})\\hat{\\mathbf{a}} = \\mathbf{R}^T \\mathbf{x}$。假设矩阵 $\\mathbf{R}^T \\mathbf{R}$ 可逆，则解为 $\\hat{\\mathbf{a}} = (\\mathbf{R}^T \\mathbf{R})^{-1} \\mathbf{R}^T \\mathbf{x}$。为了数值稳定性，尤其是在处理高次多项式时，最好使用 QR 分解或奇异值分解 (SVD) 等方法计算解，这些方法已在标准数值线性代数库中实现。\n\n**2. 随机分量表征**\n\n一旦找到系数 $\\hat{\\mathbf{a}}$，我们便计算每个位置的拟合系统性分量 $m(r_i) = \\sum_{k=0}^{d} \\hat{a}_k r_i^k$。然后按如下方式计算残差：\n$$\ne_i = x_i - m(r_i)\n$$\n随机分量被假设为一个均值为零、方差恒为 $\\sigma^2$ 的高斯随机变量。我们根据残差来估计此方差。问题指定使用方差的无偏估计量，该估计量考虑了拟合多项式模型的 $p = d+1$ 个参数所消耗的自由度：\n$$\n\\hat{\\sigma}^2 = \\frac{1}{N - (d+1)} \\sum_{i=1}^{N} e_i^2\n$$\n估计的标准差就是 $\\hat{\\sigma} = \\sqrt{\\hat{\\sigma}^2}$。只要数据点数 $N$ 大于拟合参数的个数，即 $N > d+1$，该估计量就有效，所有测试用例都满足此条件。\n\n**3. 参数化良率预测**\n\n模型完全指定后，给定位置 $i$ 的电学参数值被建模为从高斯分布中抽取的随机变量 $X_i$：\n$$\nX_i \\sim \\mathcal{N}(m(r_i), \\hat{\\sigma}^2)\n$$\n位置 $i$ 处芯片的参数化良率是 $X_i$ 落在双边规格区间 $[L, U]$ 内的概率。该概率 $P_i$ 通过对 $X_i$ 的概率密度函数 (PDF) 从 $L$到 $U$ 积分来计算。最方便的计算方法是使用标准正态分布的累积分布函数 (CDF)，即 $\\Phi(z) = P(Z \\le z)$，其中 $Z \\sim \\mathcal{N}(0, 1)$：\n$$\nP_i = P(L \\le X_i \\le U) = \\Phi\\left(\\frac{U - m(r_i)}{\\hat{\\sigma}}\\right) - \\Phi\\left(\\frac{L - m(r_i)}{\\hat{\\sigma}}\\right)\n$$\n在随机变异为零 ($\\hat{\\sigma} = 0$) 的特殊情况下，分布变为一个以 $m(r_i)$ 为中心的狄拉克δ函数 (Dirac delta function)。此时概率 $P_i$ 是确定性的：如果拟合值 $m(r_i)$ 落在规格窗口 $[L, U]$ 内，则为 $1$，否则为 $0$。\n$$\nP_i = \n\\begin{cases}\n1  \\text{if } L \\le m(r_i) \\le U \\\\\n0  \\text{otherwise}\n\\end{cases}\n\\quad (\\text{for } \\hat{\\sigma} = 0)\n$$\n\n**4. 晶圆级良率计算**\n\n最后，整体的晶圆级预测良率 $Y$ 是 $N$ 个抽样位置上各个芯片级接受概率的算术平均值：\n$$\nY = \\frac{1}{N} \\sum_{i=1}^{N} P_i\n$$\n每个测试用例的最终结果是该值 $Y$，四舍五入到精确的 $6$ 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the parametric yield prediction problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"radii\": [0.00, 0.20, 0.35, 0.50, 0.65, 0.80, 0.90, 1.00, 0.10, 0.30, 0.55, 0.85],\n            \"measurements\": [0.0100, -0.0290, -0.0636, -0.0475, -0.0746, -0.0600, -0.0565, -0.0510, -0.0125, -0.0505, -0.0526, -0.0686],\n            \"degree\": 2,\n            \"spec\": [-0.08, 0.05]\n        },\n        # Case 2\n        {\n            \"radii\": [0.00, 0.20, 0.40, 0.60, 0.80, 1.00, 0.30, 0.70],\n            \"measurements\": [0.0050, -0.0030, 0.0020, -0.0100, 0.0060, -0.0040, 0.0010, -0.0090],\n            \"degree\": 0,\n            \"spec\": [-0.02, 0.02]\n        },\n        # Case 3\n        {\n            \"radii\": [0.00, 0.25, 0.50, 0.75, 1.00],\n            \"measurements\": [0.20010, 0.17480, 0.15000, 0.12515, 0.09995],\n            \"degree\": 1,\n            \"spec\": [0.09, 0.21]\n        },\n        # Case 4\n        {\n            \"radii\": [0.00, 0.50, 0.80, 1.00],\n            \"measurements\": [-0.0440, -0.0380, -0.0268, -0.0320],\n            \"degree\": 2,\n            \"spec\": [-0.06, -0.02]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        r = np.array(case[\"radii\"])\n        x = np.array(case[\"measurements\"])\n        d = case[\"degree\"]\n        L, U = case[\"spec\"]\n        N = len(r)\n\n        # Step 1: Fit the polynomial model using Ordinary Least Squares.\n        # The design matrix R (Vandermonde matrix) has columns for r^0, r^1, ..., r^d.\n        R = np.vander(r, d + 1, increasing=True)\n        \n        # Use np.linalg.lstsq for a numerically stable OLS solution.\n        # It returns coefficients, sum of squared residuals (RSS), rank, and singular values.\n        coeffs, rss, _, _ = np.linalg.lstsq(R, x, rcond=None)\n        \n        # The fitted systematic component m(r_i) at each location.\n        m_r = R @ coeffs\n\n        # Step 2: Estimate the random standard deviation.\n        # Degrees of freedom for the residuals.\n        dof = N - (d + 1)\n        if dof == 0:\n            # This case is precluded by the problem statement (N > d + 1).\n            # If it happened, variance would be undefined or infinite.\n            # Handle defensively.\n            sigma_hat = 0.0 \n        else:\n            # Unbiased variance estimator.\n            variance_hat = rss[0] / dof\n            sigma_hat = np.sqrt(variance_hat)\n\n        # Step 3: Compute die-level acceptance probabilities.\n        # This is the probability that a new draw from N(m(r_i), sigma_hat^2) is in [L, U].\n        if sigma_hat  1e-12:  # Handle the case of zero or near-zero standard deviation.\n            # Probability is 1 if the mean is in spec, 0 otherwise.\n            # The inequalities handle the L = m(r_i) = U condition.\n            p_accept = (m_r >= L)  (m_r = U)\n            p_accept = p_accept.astype(float)\n        else:\n            # Use the CDF of the standard normal distribution.\n            z_upper = (U - m_r) / sigma_hat\n            z_lower = (L - m_r) / sigma_hat\n            p_accept = norm.cdf(z_upper) - norm.cdf(z_lower)\n\n        # Step 4: Compute wafer-level predicted yield.\n        # The yield is the arithmetic mean of the die-level probabilities.\n        wafer_yield = np.mean(p_accept)\n        \n        # Format the result to exactly 6 decimal places.\n        results.append(f\"{wafer_yield:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "成品率模型不仅用于预测，它们还是设计优化的强大工具 。本练习要求您实现一个贪心算法，为芯片设计策略性地增加冗余模块。您的目标是以最小的面积成本达到目标成品率，从而实践“可制造性设计”（Design for Manufacturability, DFM）的一项关键原则。",
            "id": "4281256",
            "problem": "考虑一个电子设计自动化（EDA）领域的芯片级制造良率规划问题。一个芯片由 $n$ 个功能独立的模块组成。每个模块 $i$ 占用的面积为 $a_i$，单位为 $\\text{cm}^2$。缺陷密度是均匀的，等于每 $\\text{cm}^2$ 有 $D_0$ 个缺陷，并假设如果至少有一个缺陷落在模块区域内，将导致该模块的灾难性故障。假设不相交区域上的缺陷事件是相互独立的。\n\n使用的基本原理：\n- 在经典的泊松（Poisson）缺陷模型下，面积为 $a_i$ 的单个模块的良率为 $Y_i = \\exp(-D_0 a_i)$。\n- 根据概率论中独立事件的标准串联组合规则，如果每个所需功能都正常工作，则芯片正常工作。如果一个功能由 $k_i$ 个并联的冗余相同模块实现（每个模块面积为 $a_i$ 且在缺陷方面是独立的），只要 $k_i$ 个模块中至少有一个正常工作，该功能就正常工作。\n\n您可以假设模块副本之间以及不同模块之间的故障事件是独立的。通过复制模块来插入冗余，使得功能 $i$ 由 $k_i \\ge 1$ 个相同的副本实现。功能 $i$ 的物理面积消耗按 $k_i a_i$ 比例增加，因冗余而增加的总面积为 $\\sum_{i=1}^n (k_i - 1) a_i$，单位为 $\\text{cm}^2$。\n\n任务：\n1. 从上述基本原理出发，推导用 $k_i$ 个冗余副本实现的功能的成功概率表达式，以及作为向量 $k = (k_1, \\dots, k_n)$ 函数的整体芯片良率表达式。\n2. 使用概率论和泊松模型从第一性原理出发，推导当 $k_i$ 增加1时整体芯片良率的边际增益，然后推导出用于选择下一个要复制的模块的单位面积边际良率增益决策规则。该决策规则必须表示为一个量，在每次插入一个副本的贪心启发式算法的每一步中，该量都应被最大化。\n3. 设计并实现一个贪心冗余插入启发式算法，该算法：\n   - 初始化为无冗余，即对所有 $i$， $k_i = 1$。\n   - 在每一步中，选择使推导出的单位面积边际良率增益决策规则最大化的模块索引 $i$，将 $k_i$ 增加1，并重复此过程，直到芯片良率达到或超过给定的目标良率 $Y_\\mathrm{target}$（以小数而非百分比表示）。\n   - 如果多个模块具有相同的决策规则值，则通过选择具有较小 $a_i$ 的模块来打破平局；如果仍然平局，则通过最小的索引 $i$ 来打破。\n   - 对于每个测试用例，输出最终的冗余向量 $[k_1, \\dots, k_n]$（整数形式）、总增加面积（$\\text{cm}^2$，浮点数形式）和达成的芯片良率（十进制浮点数形式）。\n\n角度单位与此问题无关。面积严格要求使用物理单位：所有面积值必须以 $\\text{cm}^2$ 处理。所有良率必须是无单位范围 $(0,1)$ 内的小数。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，格式为方括号内以逗号分隔的列表（例如，$[result1,result2,\\dots]$），其中每个 $resultj$ 是形式为 $[k_1,\\dots,k_n,\\text{added\\_area\\_cm2},\\text{achieved\\_yield}]$ 的列表。\n\n测试集：\n为以下参数集 $(D_0, [a_1,\\dots,a_n], Y_\\mathrm{target})$ 提供结果：\n- 情况 A：$D_0 = 0.5$, $[a_1,a_2,a_3] = [0.2, 0.05, 0.1]$, $Y_\\mathrm{target} = 0.85$。\n- 情况 B：$D_0 = 0.1$, $[a_1,a_2,a_3] = [0.3, 0.3, 0.4]$, $Y_\\mathrm{target} = 0.90$。\n- 情况 C：$D_0 = 2.0$, $[a_1,a_2,a_3,a_4,a_5] = [0.02, 0.02, 0.02, 0.02, 0.02]$, $Y_\\mathrm{target} = 0.95$。\n- 情况 D：$D_0 = 0.8$, $[a_1,a_2,a_3] = [0.5, 0.01, 0.01]$, $Y_\\mathrm{target} = 0.75$。\n- 情况 E：$D_0 = 0.3$, $[a_1,a_2] = [0.1, 0.1]$, $Y_\\mathrm{target} = 0.995$。\n\n您的程序必须计算这些情况的冗余向量和输出，并采用指定格式，不应读取任何其他输入。",
            "solution": "问题陈述已经过分析，并被确定为有效。它在科学上是合理的，问题定义清晰，客观，并包含了根据所提供方法推导出唯一解所需的所有必要信息。该问题基于已确立的泊松（Poisson）良率模型和应用于集成电路制造中系统可靠性的基础概率论。\n\n在此，按要求呈现分步推导和算法设计。\n\n### 任务1：良率表达式的推导\n\n目标是推导具有冗余的功能的成功概率以及整体芯片良率。\n\n设 $D_0$ 为缺陷密度，$a_i$ 为模块 $i$ 的面积。\n单个非冗余模块 $i$ 副本的良率，记为 $Y_{\\text{copy},i}$，由泊松模型给出：\n$$Y_{\\text{copy},i} = \\exp(-D_0 a_i)$$\n单个副本的失效率是其良率的补集：\n$$F_{\\text{copy},i} = 1 - Y_{\\text{copy},i} = 1 - \\exp(-D_0 a_i)$$\n一个功能 $i$ 由 $k_i$ 个相同、并联且独立的副本实现。如果这 $k_i$ 个副本中至少有一个是无缺陷的，则该功能正常工作。更直接的方法是首先计算该功能失效的概率。仅当所有 $k_i$ 个副本都失效时，该功能才会失效。由于副本之间的失效事件是独立的，功能 $i$ 的失效率 $F_{\\text{func},i}$ 是各个副本失效率的乘积：\n$$F_{\\text{func},i}(k_i) = (F_{\\text{copy},i})^{k_i} = (1 - \\exp(-D_0 a_i))^{k_i}$$\n功能 $i$ 的成功概率，或称良率，记为 $Y_{\\text{func},i}(k_i)$，是其失效率的补集：\n$$Y_{\\text{func},i}(k_i) = 1 - F_{\\text{func},i}(k_i) = 1 - (1 - \\exp(-D_0 a_i))^{k_i}$$\n芯片由 $n$ 个功能独立的模块组成。只有当所有 $n$ 个功能都正常工作时，芯片才能正常工作。这代表了一个由功能组成的串联系统。总芯片良率 $Y_{\\text{chip}}$ 是所有单个功能良率的乘积。给定一个冗余配置向量 $k = (k_1, k_2, \\dots, k_n)$，芯片良率为：\n$$Y_{\\text{chip}}(k) = \\prod_{i=1}^n Y_{\\text{func},i}(k_i)$$\n代入 $Y_{\\text{func},i}(k_i)$ 的表达式：\n$$Y_{\\text{chip}}(k) = \\prod_{i=1}^n \\left[1 - (1 - \\exp(-D_0 a_i))^{k_i}\\right]$$\n至此完成了第一个任务的推导。\n\n### 任务2：边际增益决策规则的推导\n\n第二个任务是推导向模块 $j$ 添加一个冗余副本所带来的芯片良率边际增益，并为基于单位面积良率增益的贪心启发式算法制定决策规则。\n\n设当前的冗余向量为 $k = (k_1, \\dots, k_j, \\dots, k_n)$。当前的芯片良率为 $Y_{\\text{chip}}(k)$。如果我们将模块 $j$ 的冗余度从 $k_j$ 增加到 $k_j+1$，新的向量为 $k' = (k_1, \\dots, k_j+1, \\dots, k_n)$。芯片良率的边际增益 $\\Delta Y_{\\text{chip}, j}$ 是差值 $Y_{\\text{chip}}(k') - Y_{\\text{chip}}(k)$。\n\n芯片良率可以写成功能 $j$ 的良率与所有其他功能良率的乘积：\n$$Y_{\\text{chip}}(k) = Y_{\\text{func},j}(k_j) \\cdot \\prod_{i \\ne j} Y_{\\text{func},i}(k_i)$$\n新的良率为：\n$$Y_{\\text{chip}}(k') = Y_{\\text{func},j}(k_j+1) \\cdot \\prod_{i \\ne j} Y_{\\text{func},i}(k_i)$$\n因此，边际增益为：\n$$\\Delta Y_{\\text{chip}, j} = \\left[ Y_{\\text{func},j}(k_j+1) - Y_{\\text{func},j}(k_j) \\right] \\cdot \\prod_{i \\ne j} Y_{\\text{func},i}(k_i)$$\n我们来分析方括号中代表功能 $j$ 良率变化的项：\n$$\\Delta Y_{\\text{func},j} = Y_{\\text{func},j}(k_j+1) - Y_{\\text{func},j}(k_j)$$\n$$= \\left[1 - (1 - e^{-D_0 a_j})^{k_j+1}\\right] - \\left[1 - (1 - e^{-D_0 a_j})^{k_j}\\right]$$\n$$= (1 - e^{-D_0 a_j})^{k_j} - (1 - e^{-D_0 a_j})^{k_j+1}$$\n提取公因式 $(1 - e^{-D_0 a_j})^{k_j}$：\n$$= (1 - e^{-D_0 a_j})^{k_j} \\left[1 - (1 - e^{-D_0 a_j})\\right]$$\n$$= (1 - e^{-D_0 a_j})^{k_j} \\cdot e^{-D_0 a_j}$$\n乘积项 $\\prod_{i \\ne j} Y_{\\text{func},i}(k_i)$ 可以表示为 $\\frac{Y_{\\text{chip}}(k)}{Y_{\\text{func},j}(k_j)}$。将这些分量代回 $\\Delta Y_{\\text{chip}, j}$ 的表达式中：\n$$\\Delta Y_{\\text{chip}, j} = \\left[ (1 - e^{-D_0 a_j})^{k_j} e^{-D_0 a_j} \\right] \\cdot \\frac{Y_{\\text{chip}}(k)}{Y_{\\text{func},j}(k_j)}$$\n$$\\Delta Y_{\\text{chip}, j} = Y_{\\text{chip}}(k) \\cdot \\frac{e^{-D_0 a_j} (1 - e^{-D_0 a_j})^{k_j}}{1 - (1 - e^{-D_0 a_j})^{k_j}}$$\n这就是整体芯片良率的边际增益。\n\n此操作的成本是增加的模块副本的面积，即 $a_j$。贪心决策规则应选择能提供每单位增加面积最大边际良率增益的模块。这个度量，我们称之为 $M_j$，是：\n$$M_j = \\frac{\\Delta Y_{\\text{chip}, j}}{a_j} = \\frac{Y_{\\text{chip}}(k)}{a_j} \\cdot \\frac{e^{-D_0 a_j} (1 - e^{-D_0 a_j})^{k_j}}{1 - (1 - e^{-D_0 a_j})^{k_j}}$$\n在贪心算法的任何给定步骤中，当前芯片良率 $Y_{\\text{chip}}(k)$ 对于所有模块 $j$ 都是一个正的常数因子。由于我们只关心找到使 $M_j$ 最大化的索引 $j$，我们可以通过最大化一个移除了这个公共因子的度量 $D_j$ 来简化决策：\n$$D_j = \\frac{1}{a_j} \\cdot \\frac{e^{-D_0 a_j} (1 - e^{-D_0 a_j})^{k_j}}{1 - (1 - e^{-D_0 a_j})^{k_j}}$$\n在每一步中，贪心启发式算法将选择为 $D_j$ 值最大的模块 $j$ 增加 $k_j$。\n\n### 任务3：贪心冗余插入启发式算法设计\n\n算法流程如下：\n\n1.  **初始化**：给定缺陷密度 $D_0$、模块面积向量 $a = [a_1, \\dots, a_n]$ 和目标良率 $Y_{\\text{target}}$。\n    -   将冗余向量 $k$ 初始化为 $[1, 1, \\dots, 1]$，代表无冗余的基准设计。\n    -   使用任务1中推导的公式和初始 $k$ 值计算初始芯片良率 $Y_{\\text{chip}}$。\n\n2.  **贪心迭代**：进入一个循环，只要当前 $Y_{\\text{chip}}$ 小于 $Y_{\\text{target}}$ 就继续。\n    a.  **评估候选模块**：对每个模块 $j \\in \\{1, \\dots, n\\}$，使用任务2中的公式和当前的冗余水平 $k_j$ 计算决策度量 $D_j$。\n    b.  **选择最佳模块**：确定使决策度量 $D_j$ 最大化的模块索引 $j^*$。选择必须遵守指定的平局打破规则：\n        i.  如果多个模块共享相同的最大 $D_j$ 值，则选择面积 $a_j$ 最小的那个。\n        ii. 如果仍然平局（即相同的 $D_j$ 和相同的 $a_j$），则选择索引 $j$ 最小的那个。\n    c.  **更新状态**：为所选模块的冗余计数加一：$k_{j^*} \\leftarrow k_{j^*} + 1$。\n    d.  **重新计算良率**：使用新的冗余向量 $k$ 更新总芯片良率 $Y_{\\text{chip}}$。\n\n3.  **终止**：当 $Y_{\\text{chip}} \\ge Y_{\\text{target}}$ 时，循环终止。由于增加冗余总是会提高良率，因此对于任何 $Y_{\\text{target}}  1$，都可以保证终止。\n    -   终止时，计算总增加面积：增加面积 $= \\sum_{i=1}^n (k_i - 1) a_i$。\n    -   最终输出为最终的冗余向量 $k$、总增加面积和达成的芯片良率 $Y_{\\text{chip}}$。\n\n该算法通过在每一步做出局部最优选择来系统地提高芯片良率，旨在以高效的面积利用率达到目标良率。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run the greedy redundancy insertion heuristic\n    for all specified test cases.\n    \"\"\"\n    # Test suite: (D0, [a1, ..., an], Y_target)\n    test_cases = [\n        # Case A\n        (0.5, [0.2, 0.05, 0.1], 0.85),\n        # Case B\n        (0.1, [0.3, 0.3, 0.4], 0.90),\n        # Case C\n        (2.0, [0.02, 0.02, 0.02, 0.02, 0.02], 0.95),\n        # Case D\n        (0.8, [0.5, 0.01, 0.01], 0.75),\n        # Case E\n        (0.3, [0.1, 0.1], 0.995),\n    ]\n\n    results = []\n    for D0, a_list, Y_target in test_cases:\n        areas = np.array(a_list, dtype=float)\n        n_modules = len(areas)\n        k = np.ones(n_modules, dtype=int)\n        \n        # Pre-calculate constants for each module to speed up iterations\n        # Y_copy_i = exp(-D0 * a_i)\n        # F_copy_i = 1 - Y_copy_i\n        Y_copy = np.exp(-D0 * areas)\n        F_copy = 1.0 - Y_copy\n\n        def calculate_chip_yield(current_k):\n            \"\"\"Calculates total chip yield for a given redundancy vector k.\"\"\"\n            # Y_func_i = 1 - (F_copy_i)^k_i\n            Y_func = 1.0 - np.power(F_copy, current_k)\n            # Y_chip = product of all Y_func_i\n            return np.prod(Y_func)\n\n        # Initial state\n        current_yield = calculate_chip_yield(k)\n\n        # Greedy iteration loop\n        while current_yield  Y_target:\n            decision_metrics = []\n            \n            for i in range(n_modules):\n                # Decision metric D_j = (1/a_j) * (Y_copy_j * F_copy_j^k_j) / (1 - F_copy_j^k_j)\n                # Y_func_j = 1 - F_copy_j^k_j\n                f_copy_i_k = np.power(F_copy[i], k[i])\n                y_func_i = 1.0 - f_copy_i_k\n                \n                # Handle potential numerical instability if y_func_i is near 0.\n                if y_func_i  1e-12: # This would mean chip yield is already extremely low\n                    # In this regime, even a small improvement is huge relatively.\n                    # This metric would be very large, prioritizing this module.\n                    # The formula remains valid.\n                    pass\n\n                numerator = Y_copy[i] * f_copy_i_k\n                denominator = areas[i] * y_func_i\n                \n                metric = numerator / denominator\n                \n                # Store metric with tie-breaking info: (-metric, area, index)\n                # Sorting will maximize metric, then minimize area, then minimize index.\n                decision_metrics.append((-metric, areas[i], i))\n\n            # Sort to find the best candidate according to the rules\n            decision_metrics.sort()\n            \n            # The best module is the first one in the sorted list\n            best_module_index = decision_metrics[0][2]\n            \n            # Update redundancy for the best module\n            k[best_module_index] += 1\n            \n            # Recalculate chip yield\n            current_yield = calculate_chip_yield(k)\n\n        # Calculate final results\n        initial_areas = np.array(a_list, dtype=float)\n        added_area = float(np.sum((k - 1) * initial_areas))\n        achieved_yield = float(current_yield)\n\n        # Format result for the current case: [k1, ..., kn, added_area, yield]\n        final_k_list = k.tolist()\n        result_case = final_k_list + [added_area, achieved_yield]\n        results.append(str(result_case))\n    \n    # Print the final output in the required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}