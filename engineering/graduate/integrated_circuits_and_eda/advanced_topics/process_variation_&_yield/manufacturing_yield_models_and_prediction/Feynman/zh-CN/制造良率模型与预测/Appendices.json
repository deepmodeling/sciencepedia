{
    "hands_on_practices": [
        {
            "introduction": "在制造良率预测领域，建立准确的统计模型是基石。本练习将引导你推导并比较两种最核心的缺陷良率模型：泊松 (Poisson) 模型和负二项 (Negative Binomial) 模型。通过解决这个问题 ，你将亲身体会到缺陷空间分布（均匀分布与聚集分布）的假设如何深刻影响良率预测，尤其是在评估大尺寸芯片的制造成本与可行性时，这种差异至关重要。",
            "id": "4281279",
            "problem": "一条集成电路的生产线在一个特定的条件下运行，其中随机的致命缺陷可以使用点过程来处理。假设以下建模基础：\n\n- 在空间均匀缺陷的情况下，面积为 $A$ 的芯片上的致命缺陷数量服从泊松分布，其均值为 $\\mu = D_{0} A$，其中 $D_{0}$ 是缺陷密度，单位为缺陷数/平方厘米。芯片良率是指一个芯片没有致命缺陷的概率。\n\n- 在空间聚集缺陷的情况下，整个晶圆上的局部缺陷率是异质的：以局部缺陷率 $\\Lambda$ 为条件，一个芯片上的缺陷服从均值为 $\\Lambda A$ 的泊松分布，而芯片间的 $\\Lambda$ 异质性服从伽马分布，其形状参数 $\\alpha$ 用于量化聚集程度。芯片良率是在这种异质性上进行边缘化后得到的零致命缺陷概率。\n\n严格从这些定义出发，推导在均匀（泊松）和聚集（伽马-泊松混合）两种情况下芯片良率的闭式表达式，然后确定芯片面积 $A$（单位为 $\\mathrm{cm}^{2}$）。在此面积下，对于一个缺陷密度 $D_{0} = 0.3$ 缺陷/平方厘米、聚集参数 $\\alpha = 5$ 的工艺，聚集模型的良率是均匀模型良率的 $1.05$ 倍。将你最终的 $A$ 的数值结果四舍五入到三位有效数字，并以平方厘米表示。此外，讨论你的结果在预测制造良率以及在聚集情况下成本对芯片尺寸的敏感性方面的实际意义。你的最终答案必须仅为计算出的 $A$ 值。",
            "solution": "用户提供了一个问题陈述，在尝试解答之前需要进行验证。\n\n### 步骤 1：提取已知条件\n-   对于均匀缺陷分布，面积为 $A$ 的芯片上的致命缺陷数量服从泊松分布，其均值为 $\\mu = D_{0} A$。\n-   $D_{0}$ 是缺陷密度。\n-   良率是零致命缺陷的概率。\n-   对于聚集缺陷分布，以局部缺陷率 $\\Lambda$ 为条件，面积为 $A$ 的芯片上的致命缺陷数量服从泊松分布，其均值为 $\\Lambda A$。\n-   局部缺陷率 $\\Lambda$ 服从伽马分布，其形状参数为 $\\alpha$。\n-   目标是找到芯片面积 $A$（单位为 $\\mathrm{cm}^{2}$），使得聚集模型的良率是均匀模型良率的 $1.05$ 倍。\n-   给定参数为 $D_{0} = 0.3 \\text{ defects/cm}^2$ 和 $\\alpha = 5$。\n-   最终的 $A$ 数值结果必须四舍五入到三位有效数字。\n-   解答必须包括对实际意义的讨论。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述具有科学依据，提法恰当且客观。它基于集成电路制造良率的标准且被广泛接受的统计模型：用于纯随机缺陷的泊松模型和用于聚集缺陷的伽马-泊松（负二项）模型。所提供的参数 $D_{0} = 0.3 \\text{ defects/cm}^2$ 和 $\\alpha = 5$ 对于半导体制造工艺是符合实际的。该问题隐含地假设局部缺陷率的伽马分布均值 $E[\\Lambda]$ 等于全局平均缺陷密度 $D_{0}$。这是在两个模型之间进行有意义比较的一个标准且必要的条件，并不会使问题无效；相反，这是该领域的标准惯例。该问题是自洽的，可以数学形式化，并且有唯一且有意义的解。\n\n### 步骤 3：结论与行动\n问题被判定为有效。将提供完整解答。\n\n### 良率模型的推导\n\n首先，我们根据问题中的定义，推导两种模型下芯片良率的闭式表达式。良率 $Y$ 是指一个芯片有零个致命缺陷的概率。\n\n**1. 均匀（泊松）模型**\n\n设 $N$ 为代表面积为 $A$ 的芯片上致命缺陷数量的随机变量。根据题意，$N$ 服从均值为 $\\mu = D_{0} A$ 的泊松分布。泊松分布的概率质量函数 (PMF) 由下式给出：\n$$\nP(N=k) = \\frac{\\mu^{k} e^{-\\mu}}{k!} = \\frac{(D_{0}A)^{k} \\exp(-D_{0}A)}{k!}\n$$\n良率，我们记为 $Y_{\\text{hom}}$，是存在零缺陷（$k=0$）的概率：\n$$\nY_{\\text{hom}}(A) = P(N=0) = \\frac{(D_{0}A)^{0} \\exp(-D_{0}A)}{0!}\n$$\n由于 $x^{0}=1$ 且 $0!=1$，上式可简化为众所周知的泊松良率模型：\n$$\nY_{\\text{hom}}(A) = \\exp(-D_{0}A)\n$$\n\n**2. 聚集（伽马-泊松）模型**\n\n在此模型中，缺陷密度不是均匀的。局部缺陷密度 $\\Lambda$ 本身是一个服从伽马分布的随机变量。一个形状参数为 $\\alpha$、尺度参数为 $\\theta$ 的伽马分布的概率密度函数 (PDF) 为：\n$$\nf(\\lambda; \\alpha, \\theta) = \\frac{\\lambda^{\\alpha-1} \\exp(-\\lambda/\\theta)}{\\theta^{\\alpha} \\Gamma(\\alpha)} \\quad \\text{for } \\lambda \\ge 0\n$$\n其中 $\\Gamma(\\alpha)$ 是伽马函数。为了使两个模型具有可比性，它们必须具有相同的总体平均缺陷密度。我们将 $\\Lambda$ 的期望值设为等于 $D_{0}$：\n$$\nE[\\Lambda] = \\alpha\\theta = D_{0}\n$$\n由此，我们确定尺度参数 $\\theta = D_{0}/\\alpha$。将其代回 PDF：\n$$\nf(\\lambda) = \\frac{\\lambda^{\\alpha-1} \\exp(-\\lambda\\alpha/D_{0})}{(D_{0}/\\alpha)^{\\alpha} \\Gamma(\\alpha)}\n$$\n以一个特定值 $\\Lambda = \\lambda$ 为条件，缺陷数量 $N$ 服从均值为 $\\lambda A$ 的泊松分布。零缺陷的条件概率是：\n$$\nP(N=0 | \\Lambda = \\lambda) = \\exp(-\\lambda A)\n$$\n为了找到聚集模型下的总良率 $Y_{\\text{clust}}$，我们必须通过对由 $\\Lambda$ 的 PDF 加权的条件概率进行积分，来对 $\\lambda$ 的所有可能值进行边缘化：\n$$\nY_{\\text{clust}}(A) = \\int_{0}^{\\infty} P(N=0 | \\Lambda=\\lambda) f(\\lambda) \\,d\\lambda = \\int_{0}^{\\infty} \\exp(-\\lambda A) \\frac{\\lambda^{\\alpha-1} \\exp(-\\lambda\\alpha/D_{0})}{(D_{0}/\\alpha)^{\\alpha} \\Gamma(\\alpha)} \\,d\\lambda\n$$\n合并指数项并提出常数：\n$$\nY_{\\text{clust}}(A) = \\frac{1}{(D_{0}/\\alpha)^{\\alpha} \\Gamma(\\alpha)} \\int_{0}^{\\infty} \\lambda^{\\alpha-1} \\exp\\left(-\\lambda \\left(A + \\frac{\\alpha}{D_{0}}\\right)\\right) \\,d\\lambda\n$$\n该积分具有伽马函数的形式。使用恒等式 $\\int_{0}^{\\infty} x^{z-1} \\exp(-cx) \\,dx = \\frac{\\Gamma(z)}{c^{z}}$，其中 $z=\\alpha$ 且 $c = A + \\frac{\\alpha}{D_{0}}$，该积分的计算结果为：\n$$\n\\int_{0}^{\\infty} \\lambda^{\\alpha-1} \\exp\\left(-\\lambda \\left(\\frac{AD_{0}+\\alpha}{D_{0}}\\right)\\right) \\,d\\lambda = \\frac{\\Gamma(\\alpha)}{\\left(\\frac{AD_{0}+\\alpha}{D_{0}}\\right)^{\\alpha}}\n$$\n将此结果代回 $Y_{\\text{clust}}(A)$ 的表达式中：\n$$\nY_{\\text{clust}}(A) = \\frac{1}{(D_{0}/\\alpha)^{\\alpha} \\Gamma(\\alpha)} \\cdot \\frac{\\Gamma(\\alpha)}{\\left(\\frac{AD_{0}+\\alpha}{D_{0}}\\right)^{\\alpha}} = \\left(\\frac{\\alpha}{D_{0}}\\right)^{\\alpha} \\left(\\frac{D_{0}}{AD_{0}+\\alpha}\\right)^{\\alpha}\n$$\n这可以简化为负二项良率模型：\n$$\nY_{\\text{clust}}(A) = \\left(\\frac{\\alpha}{AD_{0}+\\alpha}\\right)^{\\alpha} = \\left(1 + \\frac{D_{0}A}{\\alpha}\\right)^{-\\alpha}\n$$\n\n### 求解芯片面积 A\n\n问题要求找到面积 $A$，在该面积下，聚集模型的良率是均匀模型良率的 $1.05$ 倍。该条件表示为：\n$$\nY_{\\text{clust}}(A) = 1.05 \\cdot Y_{\\text{hom}}(A)\n$$\n代入推导出的良率公式：\n$$\n\\left(1 + \\frac{D_{0}A}{\\alpha}\\right)^{-\\alpha} = 1.05 \\cdot \\exp(-D_{0}A)\n$$\n现在，我们代入给定的数值：$D_{0} = 0.3$ 和 $\\alpha = 5$。\n$$\n\\left(1 + \\frac{0.3 A}{5}\\right)^{-5} = 1.05 \\cdot \\exp(-0.3 A)\n$$\n$$\n(1 + 0.06 A)^{-5} = 1.05 \\cdot \\exp(-0.3 A)\n$$\n这是一个必须求解 $A$ 的超越方程。为了便于数值求解，我们可以对两边取自然对数：\n$$\n\\ln\\left((1 + 0.06 A)^{-5}\\right) = \\ln(1.05 \\cdot \\exp(-0.3 A))\n$$\n$$\n-5 \\ln(1 + 0.06 A) = \\ln(1.05) - 0.3 A\n$$\n整理各项，我们需求解函数 $g(A)$ 的根：\n$$\ng(A) = 0.3 A - 5 \\ln(1 + 0.06 A) - \\ln(1.05) = 0\n$$\n我们可以数值求解这个方程。使用数值求解器（例如牛顿-拉夫逊方法或计算工具中的内置求解函数），我们找到 $A$ 的值。让我们对根进行迭代搜索。$\\ln(1.05)$ 的值约等于 $0.048790$。我们测试 $A = 2.4$：$g(2.4) = 0.3(2.4) - 5\\ln(1 + 0.06 \\times 2.4) - 0.04879 = 0.72 - 5\\ln(1.144) - 0.04879 \\approx 0.72 - 5(0.13456) - 0.04879 = 0.72 - 0.6728 - 0.04879 = -0.00159$。我们测试 $A = 2.44$：$g(2.44) = 0.3(2.44) - 5\\ln(1 + 0.06 \\times 2.44) - 0.04879 = 0.732 - 5\\ln(1.1464) - 0.04879 \\approx 0.732 - 5(0.13661) - 0.04879 = 0.732 - 0.68305 - 0.04879 = 0.00016$。根位于 $A=2.4$ 和 $A=2.44$ 之间。更精确的计算得出 $A \\approx 2.4384$。\n将结果四舍五入到三位有效数字，我们得到 $A = 2.44 \\, \\mathrm{cm}^{2}$。\n\n### 实际意义的讨论\n\n结果表明，对于芯片面积为 $A = 2.44 \\, \\mathrm{cm}^{2}$（这对现代处理器来说是一个相对较大但常见的尺寸）的情况，更符合实际的聚集缺陷模型预测的良率比简单化的均匀泊松模型预测的要高 $5\\%$。这有两个主要的实际意义：\n\n1.  **在预测制造良率方面：** 简单的泊松模型总是过于悲观。它假设缺陷是均匀分布的，而实际上它们倾向于聚集。这种聚集“保护”了晶圆的某些部分，导致无缺陷芯片的数量比在均匀分布下预期的要多。对于给定的平均缺陷密度 $D_{0}$，实际良率将高于 $\\exp(-D_{0}A)$。准确预测良率对于财务预测和工艺规划至关重要。依赖泊松模型可能导致低估盈利能力并做出错误的决策，例如过早地终止一个有前途但看似良率低的制造工艺。捕捉空间统计数据，如聚集参数 $\\alpha$，对于精确的良率建模至关重要。\n\n2.  **在聚集情况下成本对芯片尺寸的敏感性方面：** 与均匀模型相比，聚集模型中因增加芯片尺寸而产生的良率损失要小得多。泊松良率 $Y_{\\text{hom}} = \\exp(-D_{0}A)$ 随面积呈指数衰减，使得非常大的芯片在经济上显得不可行。相比之下，负二项良率 $Y_{\\text{clust}} = (1 + D_{0}A/\\alpha)^{-\\alpha}$ 对于大的 $A$ 呈幂律衰减。这种较慢的衰减速率使得更大的芯片（例如，用于高性能计算、GPU 和 FPGA 的芯片）从成本角度来看更具可行性。分析表明，比率 $Y_{\\text{clust}}/Y_{\\text{hom}}$ 随 $A$ 增长，这意味着对于更大、更复杂的芯片，考虑聚集效应的经济优势变得更加显著。这种理解改变了芯片设计中涉及的经济权衡，可能证明采用比在简单泊松良率假设下所考虑的更大的芯片尺寸是合理的。",
            "answer": "$$\n\\boxed{2.44}\n$$"
        },
        {
            "introduction": "从原始测试数据到可靠的良率预测，关键一步是有效分离系统性变化与随机波动。实际晶圆测量值通常混合了可预测的径向趋势和不可预测的随机噪声。此项编程练习  将让你通过多项式回归技术，亲手构建模型来剥离系统性分量，从而准确估算用于参数化良率计算所需的随机分量统计特性（如标准差 $\\hat{\\sigma}$）。",
            "id": "4281302",
            "problem": "给定在多个芯片位置采集的单一标量电学参数的晶圆级测量数据集。假设主要的系统性变化是径向对称的，并随归一化半径平滑变化。任务是将测量数据分解为一个系统性径向分量和一个适用于参数良率预测的随机分量。\n\n从以下基本原理出发：\n- 普通最小二乘法 (OLS) 通过最小化残差平方和来估计线性模型的参数。\n- 对于均值为零、方差为 $\\sigma^{2}$ 的独立同分布高斯噪声，无偏残差方差估计量等于残差平方和除以自由度。\n- 在高斯模型下，双边规格窗口内的参数良率通过在下限和上限之间对高斯概率密度函数进行积分来计算。\n\n对于每个测试案例，给定：\n- 一个归一化半径列表 $\\{r_{i}\\}_{i=1}^{N}$，其中每个 $r_{i} \\in [0, 1]$。\n- 一个对应的测量标量值列表 $\\{x_{i}\\}_{i=1}^{N}$。\n- 一个非负整数多项式次数 $d$，用于指定系统性分量的径向多项式模型的次数。\n- 一个双边规格区间 $[L, U]$，其中 $L  U$，其单位与测量值相同，均为无量纲单位。\n\n您的程序必须为每个测试案例执行以下操作：\n1. 通过普通最小二乘法，将多项式模型 $m(r) = \\sum_{k=0}^{d} a_{k} r^{k}$ 拟合到数据 $\\{(r_{i}, x_{i})\\}$。\n2. 计算残差 $e_{i} = x_{i} - m(r_{i})$，并使用无偏估计量估计随机标准差 $\\hat{\\sigma} = \\sqrt{\\frac{\\sum_{i=1}^{N} e_{i}^{2}}{N - (d + 1)}}$，假设 $N  d + 1$。\n3. 对于每个芯片位置 $i$，假设 $X_{i} \\sim \\mathcal{N}(m(r_{i}), \\hat{\\sigma}^{2})$，计算随机分量的新抽样 $X_{i}$ 加上拟合均值 $m(r_{i})$ 后的值落在规格窗口内的概率。这个芯片级接受概率是高斯密度在 $L$ 和 $U$ 之间的积分。如果 $\\hat{\\sigma} = 0$，则当 $L \\le m(r_{i}) \\le U$ 时，定义芯片级接受概率为 $1$，否则为 $0$。\n4. 报告晶圆级预测良率，即所提供位置上芯片级接受概率的算术平均值，表示为 $[0, 1]$ 内的一个小数，四舍五入到恰好 $6$ 位小数。\n\n所有量均为无量纲。不使用角度。百分比必须表示为小数。\n\n测试套件：\n- 案例 1（一般二次趋势，中等噪声）：\n  - 半径 $[r_{i}]$: [$0.00$, $0.20$, $0.35$, $0.50$, $0.65$, $0.80$, $0.90$, $1.00$, $0.10$, $0.30$, $0.55$, $0.85$]\n  - 测量值 $[x_{i}]$: [$0.0100$, $-0.0290$, $-0.0636$, $-0.0475$, $-0.0746$, $-0.0600$, $-0.0565$, $-0.0510$, $-0.0125$, $-0.0505$, $-0.0526$, $-0.0686$]\n  - 多项式次数 $d = 2$\n  - 规格 $[L, U] = [-0.08, 0.05]$\n- 案例 2（无趋势模型，小随机变化）：\n  - 半径 $[r_{i}]$: [$0.00$, $0.20$, $0.40$, $0.60$, $0.80$, $1.00$, $0.30$, $0.70$]\n  - 测量值 $[x_{i}]$: [$0.0050$, $-0.0030$, $0.0020$, $-0.0100$, $0.0060$, $-0.0040$, $0.0010$, $-0.0090$]\n  - 多项式次数 $d = 0$\n  - 规格 $[L, U] = [-0.02, 0.02]$\n- 案例 3（近线性趋势，近零随机变化）：\n  - 半径 $[r_{i}]$: [$0.00$, $0.25$, $0.50$, $0.75$, $1.00$]\n  - 测量值 $[x_{i}]$: [$0.20010$, $0.17480$, $0.15000$, $0.12515$, $0.09995$]\n  - 多项式次数 $d = 1$\n  - 规格 $[L, U] = [0.09, 0.21]$\n- 案例 4（点数少的二次趋势，小噪声）：\n  - 半径 $[r_{i}]$: [$0.00$, $0.50$, $0.80$, $1.00$]\n  - 测量值 $[x_{i}]$: [$-0.0440$, $-0.0380$, $-0.0268$, $-0.0320$]\n  - 多项式次数 $d = 2$\n  - 规格 $[L, U] = [-0.06, -0.02]$\n\n您的程序应生成单行输出，其中包含按上述案例顺序排列的四个晶圆级预测良率，格式为用方括号括起来的逗号分隔列表，每个良率值四舍五入到恰好六位小数（例如，$[0.987650,0.934210,0.500000,0.123456]$）。",
            "solution": "该问题提法明确，有科学依据，并为获得唯一解提供了所有必要信息。因此，该问题被认定为有效。解题过程通过执行指定的统计建模和良率预测工作流程来进行。\n\n问题的核心是将一组在给定归一化径向位置 $\\{r_i\\}_{i=1}^{N}$ 上的晶圆级测量数据 $\\{x_i\\}_{i=1}^{N}$ 分解为一个系统性径向分量 $m(r)$ 和一个随机分量 $e$。\n\n**1. 系统分量建模与参数估计**\n\n系统性径向变化由一个次数为 $d$ 的多项式建模，具体次数由各案例指定：\n$$\nm(r) = \\sum_{k=0}^{d} a_{k} r^{k} = a_0 + a_1 r + a_2 r^2 + \\dots + a_d r^d\n$$\n未知系数 $\\mathbf{a} = [a_0, a_1, \\dots, a_d]^T$ 通过普通最小二乘法 (OLS) 将此模型拟合到测量数据 $\\{(r_i, x_i)\\}_{i=1}^{N}$ 来确定。OLS 过程旨在最小化测量值 $x_i$ 与模型预测值 $m(r_i)$ 之间的平方差之和。\n\n这可以表述为一个线性代数问题。令 $\\mathbf{x}$ 为 $N \\times 1$ 的测量值向量，$\\mathbf{a}$ 为 $(d+1) \\times 1$ 的系数向量，$\\mathbf{R}$ 为 $N \\times (d+1)$ 的设计矩阵（在此上下文中常称为范德蒙矩阵）：\n$$\n\\mathbf{x} = \n\\begin{pmatrix}\nx_1 \\\\\nx_2 \\\\\n\\vdots \\\\\nx_N\n\\end{pmatrix},\n\\quad\n\\mathbf{R} = \n\\begin{pmatrix}\n1  r_1  r_1^2  \\dots  r_1^d \\\\\n1  r_2  r_2^2  \\dots  r_2^d \\\\\n\\vdots  \\vdots  \\vdots  \\ddots  \\vdots \\\\\n1  r_N  r_N^2  \\dots  r_N^d\n\\end{pmatrix},\n\\quad\n\\mathbf{a} = \n\\begin{pmatrix}\na_0 \\\\\na_1 \\\\\n\\vdots \\\\\na_d\n\\end{pmatrix}\n$$\nOLS 问题旨在寻找系数向量 $\\hat{\\mathbf{a}}$，以最小化残差向量 $\\mathbf{e} = \\mathbf{x} - \\mathbf{R}\\mathbf{a}$ 的欧几里得范数的平方：\n$$\n\\hat{\\mathbf{a}} = \\arg\\min_{\\mathbf{a}} \\|\\mathbf{x} - \\mathbf{R}\\mathbf{a}\\|^2\n$$\n解由正规方程给出：$(\\mathbf{R}^T \\mathbf{R})\\hat{\\mathbf{a}} = \\mathbf{R}^T \\mathbf{x}$。假设矩阵 $\\mathbf{R}^T \\mathbf{R}$ 可逆，则解为 $\\hat{\\mathbf{a}} = (\\mathbf{R}^T \\mathbf{R})^{-1} \\mathbf{R}^T \\mathbf{x}$。为了保证数值稳定性，特别是对于高次多项式，最好使用 QR 分解或奇异值分解 (SVD) 等方法计算解，这些方法已在标准数值线性代数库中实现。\n\n**2. 随机分量表征**\n\n一旦求得系数 $\\hat{\\mathbf{a}}$，我们就可以计算每个位置上的拟合系统分量 $m(r_i) = \\sum_{k=0}^{d} \\hat{a}_k r_i^k$。然后计算残差：\n$$\ne_i = x_i - m(r_i)\n$$\n随机分量被假设为一个均值为零、方差恒为 $\\sigma^2$ 的高斯随机变量。我们根据残差来估计此方差。问题指定使用方差的无偏估计量，该估计量考虑了拟合多项式模型的 $p = d+1$ 个参数所消耗的自由度：\n$$\n\\hat{\\sigma}^2 = \\frac{1}{N - (d+1)} \\sum_{i=1}^{N} e_i^2\n$$\n估计的标准差即为 $\\hat{\\sigma} = \\sqrt{\\hat{\\sigma}^2}$。该估计量在数据点数 $N$ 大于拟合参数个数（即 $N  d+1$）时有效，所有测试案例均满足此条件。\n\n**3. 参数良率预测**\n\n在模型被完全指定后，给定位置 $i$ 的电学参数值被建模为一个从高斯分布中抽取的随机变量 $X_i$：\n$$\nX_i \\sim \\mathcal{N}(m(r_i), \\hat{\\sigma}^2)\n$$\n位置 $i$ 处芯片的参数良率是 $X_i$ 落入双边规格区间 $[L, U]$ 内的概率。该概率 $P_i$ 通过对 $X_i$ 的概率密度函数 (PDF) 从 $L$ 到 $U$ 积分来计算。使用标准正态分布的累积分布函数 (CDF) 来计算最为方便，其中 $\\Phi(z) = P(Z \\le z)$ 且 $Z \\sim \\mathcal{N}(0, 1)$：\n$$\nP_i = P(L \\le X_i \\le U) = \\Phi\\left(\\frac{U - m(r_i)}{\\hat{\\sigma}}\\right) - \\Phi\\left(\\frac{L - m(r_i)}{\\hat{\\sigma}}\\right)\n$$\n在随机变化为零 ($\\hat{\\sigma} = 0$) 的特殊情况下，分布变为一个以 $m(r_i)$ 为中心的狄拉克δ函数。此时，概率 $P_i$ 是确定性的：如果拟合值 $m(r_i)$ 落在规格窗口 $[L, U]$ 内，则为 $1$，否则为 $0$。\n$$\nP_i = \n\\begin{cases}\n1  \\text{if } L \\le m(r_i) \\le U \\\\\n0  \\text{otherwise}\n\\end{cases}\n\\quad (\\text{for } \\hat{\\sigma} = 0)\n$$\n\n**4. 晶圆级良率计算**\n\n最后，整体预测的晶圆级良率 $Y$ 是 $N$ 个采样位置上各个芯片级接受概率的算术平均值：\n$$\nY = \\frac{1}{N} \\sum_{i=1}^{N} P_i\n$$\n每个测试案例的最终结果是该值 $Y$ 四舍五入到恰好 $6$ 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the parametric yield prediction problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"radii\": [0.00, 0.20, 0.35, 0.50, 0.65, 0.80, 0.90, 1.00, 0.10, 0.30, 0.55, 0.85],\n            \"measurements\": [0.0100, -0.0290, -0.0636, -0.0475, -0.0746, -0.0600, -0.0565, -0.0510, -0.0125, -0.0505, -0.0526, -0.0686],\n            \"degree\": 2,\n            \"spec\": [-0.08, 0.05]\n        },\n        # Case 2\n        {\n            \"radii\": [0.00, 0.20, 0.40, 0.60, 0.80, 1.00, 0.30, 0.70],\n            \"measurements\": [0.0050, -0.0030, 0.0020, -0.0100, 0.0060, -0.0040, 0.0010, -0.0090],\n            \"degree\": 0,\n            \"spec\": [-0.02, 0.02]\n        },\n        # Case 3\n        {\n            \"radii\": [0.00, 0.25, 0.50, 0.75, 1.00],\n            \"measurements\": [0.20010, 0.17480, 0.15000, 0.12515, 0.09995],\n            \"degree\": 1,\n            \"spec\": [0.09, 0.21]\n        },\n        # Case 4\n        {\n            \"radii\": [0.00, 0.50, 0.80, 1.00],\n            \"measurements\": [-0.0440, -0.0380, -0.0268, -0.0320],\n            \"degree\": 2,\n            \"spec\": [-0.06, -0.02]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        r = np.array(case[\"radii\"])\n        x = np.array(case[\"measurements\"])\n        d = case[\"degree\"]\n        L, U = case[\"spec\"]\n        N = len(r)\n\n        # Step 1: Fit the polynomial model using Ordinary Least Squares.\n        # The design matrix R (Vandermonde matrix) has columns for r^0, r^1, ..., r^d.\n        R = np.vander(r, d + 1, increasing=True)\n        \n        # Use np.linalg.lstsq for a numerically stable OLS solution.\n        # It returns coefficients, sum of squared residuals (RSS), rank, and singular values.\n        coeffs, rss, _, _ = np.linalg.lstsq(R, x, rcond=None)\n        \n        # The fitted systematic component m(r_i) at each location.\n        m_r = R @ coeffs\n\n        # Step 2: Estimate the random standard deviation.\n        # Degrees of freedom for the residuals.\n        dof = N - (d + 1)\n        if dof == 0:\n            # This case is precluded by the problem statement (N > d + 1).\n            # If it happened, variance would be undefined or infinite.\n            # Handle defensively.\n            sigma_hat = 0.0 \n        else:\n            # Unbiased variance estimator.\n            variance_hat = rss[0] / dof\n            sigma_hat = np.sqrt(variance_hat)\n\n        # Step 3: Compute die-level acceptance probabilities.\n        # This is the probability that a new draw from N(m(r_i), sigma_hat^2) is in [L, U].\n        if sigma_hat  1e-12:  # Handle the case of zero or near-zero standard deviation.\n            # Probability is 1 if the mean is in spec, 0 otherwise.\n            # The inequalities handle the L = m(r_i) = U condition.\n            p_accept = (m_r >= L)  (m_r = U)\n            p_accept = p_accept.astype(float)\n        else:\n            # Use the CDF of the standard normal distribution.\n            z_upper = (U - m_r) / sigma_hat\n            z_lower = (L - m_r) / sigma_hat\n            p_accept = norm.cdf(z_upper) - norm.cdf(z_lower)\n\n        # Step 4: Compute wafer-level predicted yield.\n        # The yield is the arithmetic mean of the die-level probabilities.\n        wafer_yield = np.mean(p_accept)\n        \n        # Format the result to exactly 6 decimal places.\n        results.append(f\"{wafer_yield:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "良率模型不仅用于预测，更是进行可制造性设计 (DFM) 和优化的强大工具。面对工艺变化带来的良率损失，工程师常常通过引入冗余来提升产品的稳健性。这个实践任务  模拟了一个真实的工程决策过程：你将设计并实现一个贪心算法，根据单位面积的边际良率增益来智能地为芯片模块添加冗余副本，最终在最小化面积成本的前提下达成良率目标。",
            "id": "4281256",
            "problem": "考虑电子设计自动化 (EDA) 领域中的一个芯片级制造良率规划问题。一个芯片由 $n$ 个功能独立的模块组成。每个模块 $i$ 占用的面积为 $a_i$，单位为 $\\text{cm}^2$。缺陷密度是均匀的，等于 $D_0$ 个缺陷/$\\text{cm}^2$，并且假设如果至少有一个缺陷落在模块区域内，该缺陷将导致模块发生灾难性失效。假设在不相交的区域内，缺陷事件是相互独立的。\n\n使用的基本原理：\n- 在经典的泊松缺陷模型下，面积为 $a_i$ 的单个模块的良率是 $Y_i = \\exp(-D_0 a_i)$。\n- 根据概率论中针对独立事件的标准串联组合规则，如果每个所需功能都正常工作，则芯片正常工作。如果一个功能由 $k_i$ 个并联冗余的相同模块实现（每个模块面积为 $a_i$，且在缺陷意义上是独立的），那么只要这 $k_i$ 个模块中至少有一个正常工作，该功能就正常工作。\n\n您可以假设模块副本之间以及不同模块之间的失效事件是独立的。通过复制模块来插入冗余，使得功能 $i$ 由 $k_i \\ge 1$ 个相同的副本实现。功能 $i$ 的物理面积消耗与 $k_i a_i$ 成比例，因冗余而增加的总面积为 $\\sum_{i=1}^n (k_i - 1) a_i$，单位为 $\\text{cm}^2$。\n\n任务：\n1. 从上述基本原理出发，推导用 $k_i$ 个冗余副本实现的功能的成功概率表达式，以及整体芯片良率作为向量 $k = (k_1, \\dots, k_n)$ 的函数。\n2. 使用概率和泊松模型，从第一性原理推导当 $k_i$ 增加 1 时整体芯片良率的边际增益，然后推导出用于选择下一个要复制的模块的单位面积边际良率增益决策规则。该决策规则必须表示为一个在贪心启发式算法（每次插入一个副本）的每一步中需要最大化的量。\n3. 设计并实现一个贪心冗余插入启发式算法，该算法：\n   - 以无冗余状态初始化，即对所有 $i$，$k_i = 1$。\n   - 在每一步中，选择使推导出的单位面积边际良率增益决策规则最大化的模块索引 $i$，将 $k_i$ 增加 1，并重复此过程，直到芯片良率达到或超过给定的目标良率 $Y_\\mathrm{target}$（以小数形式表示，而非百分比）。\n   - 如果多个模块具有相等的决策规则值，则通过选择面积 $a_i$ 较小的模块来打破平局；如果仍然平局，则通过最小的索引 $i$ 来打破。\n   - 对于每个测试用例，输出最终的冗余向量 $[k_1, \\dots, k_n]$（整数形式）、总增加面积（$\\text{cm}^2$）（浮点数形式）以及实现的芯片良率（小数浮点数形式）。\n\n角度单位与本问题无关。面积严格要求使用物理单位：所有面积值必须以 $\\text{cm}^2$ 处理。所有良率必须是无量纲范围 $(0,1)$ 内的小数。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，形式为方括号内包含的逗号分隔列表（例如，$[result1,result2,\\dots]$），其中每个 $resultj$ 是一个形式为 $[k_1,\\dots,k_n,\\text{added\\_area\\_cm2},\\text{achieved\\_yield}]$ 的列表。\n\n测试套件：\n为以下参数集 $(D_0, [a_1,\\dots,a_n], Y_\\mathrm{target})$ 提供结果：\n- 案例 A: $D_0 = 0.5$, $[a_1,a_2,a_3] = [0.2, 0.05, 0.1]$, $Y_\\mathrm{target} = 0.85$。\n- 案例 B: $D_0 = 0.1$, $[a_1,a_2,a_3] = [0.3, 0.3, 0.4]$, $Y_\\mathrm{target} = 0.90$。\n- 案例 C: $D_0 = 2.0$, $[a_1,a_2,a_3,a_4,a_5] = [0.02, 0.02, 0.02, 0.02, 0.02]$, $Y_\\mathrm{target} = 0.95$。\n- 案例 D: $D_0 = 0.8$, $[a_1,a_2,a_3] = [0.5, 0.01, 0.01]$, $Y_\\mathrm{target} = 0.75$。\n- 案例 E: $D_0 = 0.3$, $[a_1,a_2] = [0.1, 0.1]$, $Y_\\mathrm{target} = 0.995$。\n\n您的程序必须为这些案例计算冗余向量和输出，并采用指定格式，不应读取任何其他输入。",
            "solution": "问题陈述已经过分析，并被确定为有效。它在科学上是合理的、适定的、客观的，并包含所有必要信息，可以根据所提供的方法推导出唯一解。该问题基于已确立的泊松良率模型和应用于集成电路制造中系统可靠性的基本概率论。\n\n在此，按要求呈现分步推导和算法设计。\n\n### 任务1：良率表达式的推导\n\n目标是推导带有冗余的功能的成功概率以及整体芯片良率。\n\n设 $D_0$ 为缺陷密度，$a_i$ 为模块 $i$ 的面积。\n模块 $i$ 的单个非冗余副本的良率，记为 $Y_{\\text{copy},i}$，由泊松模型给出：\n$$Y_{\\text{copy},i} = \\exp(-D_0 a_i)$$\n单个副本的失效率是其良率的补集：\n$$F_{\\text{copy},i} = 1 - Y_{\\text{copy},i} = 1 - \\exp(-D_0 a_i)$$\n一个功能 $i$ 由 $k_i$ 个相同、并联且独立的副本实现。如果这些 $k_i$ 个副本中至少有一个是无缺陷的，则该功能正常工作。更直接的方法是首先计算该功能失效的概率。只有当所有 $k_i$ 个副本都失效时，该功能才会失效。由于副本之间的失效事件是独立的，功能 $i$ 失效的概率 $F_{\\text{func},i}$ 是各个副本失效率的乘积：\n$$F_{\\text{func},i}(k_i) = (F_{\\text{copy},i})^{k_i} = (1 - \\exp(-D_0 a_i))^{k_i}$$\n功能 $i$ 的成功概率，或称良率，记为 $Y_{\\text{func},i}(k_i)$，是其失效率的补集：\n$$Y_{\\text{func},i}(k_i) = 1 - F_{\\text{func},i}(k_i) = 1 - (1 - \\exp(-D_0 a_i))^{k_i}$$\n芯片由 $n$ 个功能独立的模块组成。只有当所有 $n$ 个功能都正常工作时，芯片才正常工作。这代表了一个由功能组成的串联系统。总芯片良率 $Y_{\\text{chip}}$ 是所有单个功能良率的乘积。给定一个冗余配置向量 $k = (k_1, k_2, \\dots, k_n)$，芯片良率为：\n$$Y_{\\text{chip}}(k) = \\prod_{i=1}^n Y_{\\text{func},i}(k_i)$$\n代入 $Y_{\\text{func},i}(k_i)$ 的表达式：\n$$Y_{\\text{chip}}(k) = \\prod_{i=1}^n \\left[1 - (1 - \\exp(-D_0 a_i))^{k_i}\\right]$$\n至此完成了第一个任务的推导。\n\n### 任务2：边际增益决策规则的推导\n\n第二个任务是推导向模块 $j$ 添加一个冗余副本所带来的芯片良率边际增益，并为基于单位面积良率增益的贪心启发式算法制定决策规则。\n\n设当前冗余向量为 $k = (k_1, \\dots, k_j, \\dots, k_n)$。当前芯片良率为 $Y_{\\text{chip}}(k)$。如果我们将模块 $j$ 的冗余度从 $k_j$ 增加到 $k_j+1$，新向量为 $k' = (k_1, \\dots, k_j+1, \\dots, k_n)$。芯片良率的边际增益 $\\Delta Y_{\\text{chip}, j}$ 是差值 $Y_{\\text{chip}}(k') - Y_{\\text{chip}}(k)$。\n\n芯片良率可以写成功能 $j$ 的良率与所有其他功能良率的乘积：\n$$Y_{\\text{chip}}(k) = Y_{\\text{func},j}(k_j) \\cdot \\prod_{i \\ne j} Y_{\\text{func},i}(k_i)$$\n新的良率为：\n$$Y_{\\text{chip}}(k') = Y_{\\text{func},j}(k_j+1) \\cdot \\prod_{i \\ne j} Y_{\\text{func},i}(k_i)$$\n因此，边际增益为：\n$$\\Delta Y_{\\text{chip}, j} = \\left[ Y_{\\text{func},j}(k_j+1) - Y_{\\text{func},j}(k_j) \\right] \\cdot \\prod_{i \\ne j} Y_{\\text{func},i}(k_i)$$\n我们来分析方括号中代表功能 $j$ 良率变化的项：\n$$\\Delta Y_{\\text{func},j} = Y_{\\text{func},j}(k_j+1) - Y_{\\text{func},j}(k_j)$$\n$$= \\left[1 - (1 - e^{-D_0 a_j})^{k_j+1}\\right] - \\left[1 - (1 - e^{-D_0 a_j})^{k_j}\\right]$$\n$$= (1 - e^{-D_0 a_j})^{k_j} - (1 - e^{-D_0 a_j})^{k_j+1}$$\n提出公因式 $(1 - e^{-D_0 a_j})^{k_j}$：\n$$= (1 - e^{-D_0 a_j})^{k_j} \\left[1 - (1 - e^{-D_0 a_j})\\right]$$\n$$= (1 - e^{-D_0 a_j})^{k_j} \\cdot e^{-D_0 a_j}$$\n乘积项 $\\prod_{i \\ne j} Y_{\\text{func},i}(k_i)$ 可以表示为 $\\frac{Y_{\\text{chip}}(k)}{Y_{\\text{func},j}(k_j)}$。将这些部分代回 $\\Delta Y_{\\text{chip}, j}$ 的表达式中：\n$$\\Delta Y_{\\text{chip}, j} = \\left[ (1 - e^{-D_0 a_j})^{k_j} e^{-D_0 a_j} \\right] \\cdot \\frac{Y_{\\text{chip}}(k)}{Y_{\\text{func},j}(k_j)}$$\n$$\\Delta Y_{\\text{chip}, j} = Y_{\\text{chip}}(k) \\cdot \\frac{e^{-D_0 a_j} (1 - e^{-D_0 a_j})^{k_j}}{1 - (1 - e^{-D_0 a_j})^{k_j}}$$\n这就是整体芯片良率的边际增益。\n\n此操作的成本是增加的模块副本的面积，即 $a_j$。贪心决策规则应选择能提供每单位增加面积最大边际良率增益的模块。这个我们称之为 $M_j$ 的度量标准是：\n$$M_j = \\frac{\\Delta Y_{\\text{chip}, j}}{a_j} = \\frac{Y_{\\text{chip}}(k)}{a_j} \\cdot \\frac{e^{-D_0 a_j} (1 - e^{-D_0 a_j})^{k_j}}{1 - (1 - e^{-D_0 a_j})^{k_j}}$$\n在贪心算法的任何给定步骤中，当前芯片良率 $Y_{\\text{chip}}(k)$ 对于所有模块 $j$ 都是一个正的常数因子。由于我们只关心找到最大化 $M_j$ 的索引 $j$，我们可以通过最大化一个移除了这个公共因子的度量 $D_j$ 来简化决策：\n$$D_j = \\frac{1}{a_j} \\cdot \\frac{e^{-D_0 a_j} (1 - e^{-D_0 a_j})^{k_j}}{1 - (1 - e^{-D_0 a_j})^{k_j}}$$\n在每一步，贪心启发式算法将选择为具有最大 $D_j$ 值的模块 $j$ 增加 $k_j$。\n\n### 任务3：贪心冗余插入启发式算法设计\n\n算法流程如下：\n\n1.  **初始化**：给定缺陷密度 $D_0$、模块面积向量 $a = [a_1, \\dots, a_n]$ 和目标良率 $Y_{\\text{target}}$。\n    -   初始化冗余向量 $k$ 为 $[1, 1, \\dots, 1]$，代表无冗余的基线设计。\n    -   使用任务1中推导的公式和初始 $k$ 值计算初始芯片良率 $Y_{\\text{chip}}$。\n\n2.  **贪心迭代**：进入一个循环，只要当前 $Y_{\\text{chip}}$ 小于 $Y_{\\text{target}}$ 就继续。\n    a.  **评估候选者**：对于每个模块 $j \\in \\{1, \\dots, n\\}$，使用任务2中的公式和当前的冗余水平 $k_j$ 计算决策度量 $D_j$。\n    b.  **选择最佳模块**：确定使决策度量 $D_j$ 最大化的模块索引 $j^*$。选择必须遵守指定的平局打破规则：\n        i.  如果多个模块共享相同的最大 $D_j$ 值，则选择面积 $a_j$ 最小的那个。\n        ii. 如果平局仍然存在（即相同的 $D_j$ 和相同的 $a_j$），则选择索引 $j$ 最小的那个。\n    c.  **更新状态**：为所选模块的冗余计数加一：$k_{j^*} \\leftarrow k_{j^*} + 1$。\n    d.  **重新计算良率**：使用新的冗余向量 $k$ 更新总芯片良率 $Y_{\\text{chip}}$。\n\n3.  **终止**：当 $Y_{\\text{chip}} \\ge Y_{\\text{target}}$ 时循环终止。由于增加冗余总是会提高良率，对于任何 $Y_{\\text{target}}  1$，算法保证会终止。\n    -   终止时，计算总增加面积：增加面积 $= \\sum_{i=1}^n (k_i - 1) a_i$。\n    -   最终输出是最终的冗余向量 $k$、总增加面积和达成的芯片良率 $Y_{\\text{chip}}$。\n\n该算法通过在每一步做出局部最优选择来系统地提高芯片良率，旨在以高效的面积利用率达到目标良率。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run the greedy redundancy insertion heuristic\n    for all specified test cases.\n    \"\"\"\n    # Test suite: (D0, [a1, ..., an], Y_target)\n    test_cases = [\n        # Case A\n        (0.5, [0.2, 0.05, 0.1], 0.85),\n        # Case B\n        (0.1, [0.3, 0.3, 0.4], 0.90),\n        # Case C\n        (2.0, [0.02, 0.02, 0.02, 0.02, 0.02], 0.95),\n        # Case D\n        (0.8, [0.5, 0.01, 0.01], 0.75),\n        # Case E\n        (0.3, [0.1, 0.1], 0.995),\n    ]\n\n    results = []\n    for D0, a_list, Y_target in test_cases:\n        areas = np.array(a_list, dtype=float)\n        n_modules = len(areas)\n        k = np.ones(n_modules, dtype=int)\n        \n        # Pre-calculate constants for each module to speed up iterations\n        # Y_copy_i = exp(-D0 * a_i)\n        # F_copy_i = 1 - Y_copy_i\n        Y_copy = np.exp(-D0 * areas)\n        F_copy = 1.0 - Y_copy\n\n        def calculate_chip_yield(current_k):\n            \"\"\"Calculates total chip yield for a given redundancy vector k.\"\"\"\n            # Y_func_i = 1 - (F_copy_i)^k_i\n            Y_func = 1.0 - np.power(F_copy, current_k)\n            # Y_chip = product of all Y_func_i\n            return np.prod(Y_func)\n\n        # Initial state\n        current_yield = calculate_chip_yield(k)\n\n        # Greedy iteration loop\n        while current_yield  Y_target:\n            decision_metrics = []\n            \n            for i in range(n_modules):\n                # Decision metric D_j = (1/a_j) * (Y_copy_j * F_copy_j^k_j) / (1 - F_copy_j^k_j)\n                # Y_func_j = 1 - F_copy_j^k_j\n                f_copy_i_k = np.power(F_copy[i], k[i])\n                y_func_i = 1.0 - f_copy_i_k\n                \n                # Handle potential numerical instability if y_func_i is near 0.\n                if y_func_i  1e-12: # This would mean chip yield is already extremely low\n                    # In this regime, even a small improvement is huge relatively.\n                    # This metric would be very large, prioritizing this module.\n                    # The formula remains valid.\n                    pass\n\n                numerator = Y_copy[i] * f_copy_i_k\n                denominator = areas[i] * y_func_i\n                \n                metric = numerator / denominator\n                \n                # Store metric with tie-breaking info: (-metric, area, index)\n                # Sorting will maximize metric, then minimize area, then minimize index.\n                decision_metrics.append((-metric, areas[i], i))\n\n            # Sort to find the best candidate according to the rules\n            decision_metrics.sort()\n            \n            # The best module is the first one in the sorted list\n            best_module_index = decision_metrics[0][2]\n            \n            # Update redundancy for the best module\n            k[best_module_index] += 1\n            \n            # Recalculate chip yield\n            current_yield = calculate_chip_yield(k)\n\n        # Calculate final results\n        initial_areas = np.array(a_list, dtype=float)\n        added_area = float(np.sum((k - 1) * initial_areas))\n        achieved_yield = float(current_yield)\n\n        # Format result for the current case: [k1, ..., kn, added_area, yield]\n        final_k_list = k.tolist()\n        result_case = final_k_list + [added_area, achieved_yield]\n        results.append(str(result_case))\n    \n    # Print the final output in the required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}