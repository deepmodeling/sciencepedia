{
    "hands_on_practices": [
        {
            "introduction": "芯片良率是衡量制造成功与否的关键指标，而良率损失通常源于随机的制造缺陷。可制造性设计（DFM）的一个核心任务是量化评估版图对这些缺陷的敏感度。本练习  引入了“关键区域”（Critical Area）这一基本概念，它建立了随机缺陷与特定版图几何形状导致电路失效之间的桥梁。通过从基本原理出发，推导并计算一个简单几何结构的关键区域，您将深入理解EDA工具如何进行大规模良率分析和预测。",
            "id": "4264311",
            "problem": "一个先进的数字集成电路在单个金属层上采用了平行的全局互连线。在电子设计自动化（EDA）中的可制造性设计（DFM）背景下，一个布局对随机颗粒缺陷的敏感性由关键区域来量化。关键区域在概念上定义为：当缺陷尺寸根据已知分布变化时，能够引发特定失效机制的缺陷中心位置的期望面积。考虑两个等宽、共面、平行的长金属矩形，它们之间由均匀的边到边间距隔开，并假设缺陷形状为半径为 $r$ 的圆形。缺陷的中心在平面上均匀随机分布。\n\n从几何概率的基本原理和缺陷半径概率密度函数的定义出发，推导两线间短路关键区域的积分表达式，该表达式应以敏感性函数 $A(r)$ 和归一化的缺陷半径概率密度 $f(r)$ 来表示。您的推导必须基于同时与两个导体相交的缺陷中心的几何轨迹，以及连续分布下的期望法则；不要假定目标公式，也不要使用任何预先记忆的快捷方法。\n\n使用以下科学上真实且自洽的参数：\n- 两条线的长轴方向有共同的长度 $L$，其中 $L = 5000$ $\\mathrm{\\mu m}$，并且其长度足够长，可以忽略末端效应。\n- 两条线内边缘之间的均匀边到边间距为 $s = 0.14$ $\\mathrm{\\mu m}$。\n- 缺陷半径服从归一化指数分布 $f(r) = \\frac{1}{r_{0}}\\exp\\!\\left(-\\frac{r}{r_{0}}\\right)$（$r \\geq 0$），其尺度参数为 $r_{0} = 0.06$ $\\mathrm{\\mu m}$。\n\n任务：\n1. 使用几何推理，确定对于给定的缺陷半径 $r$ 能产生两线间电气短路的缺陷中心位置区域的敏感性函数 $A(r)$。仔细说明 $A(r)$ 非零时 $r$ 所需满足的任何条件。然后，利用 $f(r)$ 将短路关键区域 $A_{\\mathrm{crit}}$ 推导为关于 $r$ 的期望值的积分表达式。\n2. 精确计算该积分，以获得 $A_{\\mathrm{crit}}$ 关于 $L$、$s$ 和 $r_{0}$ 的闭式解析表达式。然后代入所提供的数值并计算 $A_{\\mathrm{crit}}$ 的数值。将您的最终数值四舍五入到四位有效数字。以平方微米表示最终面积。\n3. 简要概述一个科学上合理的数值计算步骤，用于计算任意多边形互连线布局和任意连续 $f(r)$ 分布下的 $A_{\\mathrm{crit}}$，此时 $A(r)$ 可能没有闭式解。您的概述应从几何定义开始，并指出如何近似敏感性函数并执行数值积分。\n\n您的最终答案必须是对应于任务2中指定的四舍五入后的数值的单个实数。",
            "solution": "该问题要求基于几何概率的基本原理，推导和计算两条平行互连线之间的短路关键区域。该问题陈述经确认具有科学依据，提法恰当且客观。它提供了集成电路可制造性设计（DFM）领域的一套自洽的参数和定义。所有必要的数据均已提供，且问题没有矛盾或歧义。\n\n### 任务1：敏感性函数与关键区域积分\n\n关键区域 $A_{\\mathrm{crit}}$ 定义为敏感性函数 $A(r)$ 在缺陷半径概率分布 $f(r)$ 上的期望值。敏感性函数 $A(r)$ 是指对于给定的缺陷半径 $r$，导致短路的缺陷中心的轨迹所构成的面积。\n\n首先，我们确定敏感性函数 $A(r)$。考虑两条长度为 $L$、由均匀边到边间距 $s$ 隔开的平行线。我们可以将这些线的内边缘建模为位于 $x = -s/2$ 和 $x = +s/2$ 处。这些线沿y轴延伸。缺陷是一个半径为 $r$ 的圆。\n\n如果缺陷同时与两条线相交，则会发生电气短路。对于一个圆形缺陷要跨越宽度为 $s$ 的间隙，其直径 $2r$ 必须至少等于间距 $s$。因此，只有在 $2r \\geq s$ 或 $r \\geq s/2$ 时才可能发生短路。\n如果 $r  s/2$，缺陷在几何上不可能同时接触到两条线，因此导致短路的缺陷中心位置的面积为零。\n$$A(r) = 0 \\quad \\text{对于} \\quad r  \\frac{s}{2}$$\n\n如果 $r \\geq s/2$，我们需要找到导致短路的缺陷中心 $(x_c, y_c)$ 的轨迹。\n为了使缺陷接触到位于 $x = -s/2$ 的线，其中心必须与该线的距离在 $r$ 以内。这意味着中心的x坐标 $x_c$ 必须满足：\n$$-s/2 - r \\leq x_c \\leq -s/2 + r$$\n同样，为了使缺陷接触到位于 $x = +s/2$ 的线，$x_c$ 必须满足：\n$$s/2 - r \\leq x_c \\leq s/2 + r$$\n要发生短路，缺陷必须同时接触两条线，因此其中心必须位于这两个x坐标区间的交集内。区间 $[-s/2 - r, -s/2 + r]$ 和 $[s/2 - r, s/2 + r]$ 的交集是：\n$$[s/2 - r, -s/2 + r]$$\n缺陷中心x坐标的这个区域的宽度是 $(-s/2 + r) - (s/2 - r) = 2r - s$。由于我们已经确定 $r \\geq s/2$，这个宽度是非负的。\n\n问题陈述中说明线的长度为 $L$ 且末端效应可以忽略不计。这意味着缺陷中心的y坐标 $y_c$ 的轨迹延伸整个长度 $L$。\n关键缺陷中心区域的面积是x方向上的宽度与y方向上的长度的乘积。\n因此，对于 $r \\geq s/2$ 的敏感性函数是：\n$$A(r) = L(2r - s)$$\n\n综合两种情况，敏感性函数为：\n$$A(r) = \\begin{cases} 0  \\text{若 } r  s/2 \\\\ L(2r-s)  \\text{若 } r \\geq s/2 \\end{cases}$$\n\n关键区域 $A_{\\mathrm{crit}}$ 是 $A(r)$ 关于缺陷半径概率密度函数 $f(r)$ 的期望。半径 $r$ 是一个非负连续随机变量。\n$$ A_{\\mathrm{crit}} = E[A(r)] = \\int_{0}^{\\infty} A(r) f(r) dr $$\n代入 $A(r)$ 的表达式，由于当 $r  s/2$ 时 $A(r)=0$，积分的下限从 $0$ 变为 $s/2$。\n$$ A_{\\mathrm{crit}} = \\int_{s/2}^{\\infty} L(2r - s) f(r) dr $$\n代入给定的归一化指数分布 $f(r) = \\frac{1}{r_{0}}\\exp\\left(-\\frac{r}{r_{0}}\\right)$：\n$$ A_{\\mathrm{crit}} = \\int_{s/2}^{\\infty} L(2r - s) \\frac{1}{r_{0}}\\exp\\left(-\\frac{r}{r_{0}}\\right) dr $$\n这是短路关键区域的积分表达式。\n\n### 任务2：关键区域积分的求值\n\n我们现在对任务1中推导出的积分进行求值，以找到 $A_{\\mathrm{crit}}$ 的闭式解析表达式。\n$$ A_{\\mathrm{crit}} = \\frac{L}{r_0} \\int_{s/2}^{\\infty} (2r - s) \\exp\\left(-\\frac{r}{r_{0}}\\right) dr $$\n我们可以将该积分分成两部分：\n$$ A_{\\mathrm{crit}} = \\frac{L}{r_0} \\left( 2 \\int_{s/2}^{\\infty} r \\exp\\left(-\\frac{r}{r_{0}}\\right) dr - s \\int_{s/2}^{\\infty} \\exp\\left(-\\frac{r}{r_{0}}\\right) dr \\right) $$\n我们先计算第二个更简单的积分：\n$$ \\int_{s/2}^{\\infty} \\exp\\left(-\\frac{r}{r_{0}}\\right) dr = \\left[ -r_0 \\exp\\left(-\\frac{r}{r_{0}}\\right) \\right]_{s/2}^{\\infty} = 0 - \\left(-r_0 \\exp\\left(-\\frac{s}{2r_{0}}\\right)\\right) = r_0 \\exp\\left(-\\frac{s}{2r_{0}}\\right) $$\n第一个积分 $\\int r \\exp(-r/r_0) dr$ 需要使用分部积分法 $\\int u dv = uv - \\int v du$。\n令 $u = r$，则 $du = dr$。令 $dv = \\exp(-r/r_0)dr$，则 $v = -r_0 \\exp(-r/r_0)$。\n\\begin{align*} \\int r \\exp\\left(-\\frac{r}{r_{0}}\\right) dr = r(-r_0 \\exp(-r/r_0)) - \\int (-r_0 \\exp(-r/r_0)) dr \\\\ = -r r_0 \\exp(-r/r_0) + r_0 \\int \\exp(-r/r_0) dr \\\\ = -r r_0 \\exp(-r/r_0) - r_0^2 \\exp(-r/r_0)\\end{align*}\n应用从 $s/2$ 到 $\\infty$ 的定积分限：\n\\begin{align*} \\int_{s/2}^{\\infty} r \\exp\\left(-\\frac{r}{r_{0}}\\right) dr = \\left[ -(r r_0 + r_0^2) \\exp\\left(-\\frac{r}{r_{0}}\\right) \\right]_{s/2}^{\\infty} \\\\ = 0 - \\left( -\\left(\\frac{s}{2}r_0 + r_0^2\\right) \\exp\\left(-\\frac{s}{2r_{0}}\\right) \\right) \\\\ = \\left(\\frac{s}{2}r_0 + r_0^2\\right) \\exp\\left(-\\frac{s}{2r_{0}}\\right)\\end{align*}\n注意，根据洛必达法则，$\\lim_{r\\to\\infty} r \\exp(-r/r_0) = 0$。\n\n现在，我们将两个结果代回 $A_{\\mathrm{crit}}$ 的表达式中：\n\\begin{align*} A_{\\mathrm{crit}} = \\frac{L}{r_0} \\left( 2 \\left(\\frac{s}{2}r_0 + r_0^2\\right) \\exp\\left(-\\frac{s}{2r_{0}}\\right) - s \\left(r_0 \\exp\\left(-\\frac{s}{2r_{0}}\\right)\\right) \\right) \\\\ = \\frac{L}{r_0} \\exp\\left(-\\frac{s}{2r_{0}}\\right) \\left( 2\\left(\\frac{s}{2}r_0 + r_0^2\\right) - s r_0 \\right) \\\\ = \\frac{L}{r_0} \\exp\\left(-\\frac{s}{2r_{0}}\\right) \\left( s r_0 + 2r_0^2 - s r_0 \\right) \\\\ = \\frac{L}{r_0} \\exp\\left(-\\frac{s}{2r_{0}}\\right) (2r_0^2) \\\\ = 2 L r_0 \\exp\\left(-\\frac{s}{2r_{0}}\\right) \\end{align*}\n这是 $A_{\\mathrm{crit}}$ 的闭式解析表达式。\n\n接下来，我们代入数值：$L = 5000$ $\\mathrm{\\mu m}$，$s = 0.14$ $\\mathrm{\\mu m}$，以及 $r_0 = 0.06$ $\\mathrm{\\mu m}$。\n指数项为：\n$$ -\\frac{s}{2r_{0}} = -\\frac{0.14}{2 \\times 0.06} = -\\frac{0.14}{0.12} = -\\frac{14}{12} = -\\frac{7}{6} $$\n现在，我们计算 $A_{\\mathrm{crit}}$：\n$$ A_{\\mathrm{crit}} = 2 \\times 5000 \\times 0.06 \\times \\exp\\left(-\\frac{7}{6}\\right) = 10000 \\times 0.06 \\times \\exp\\left(-\\frac{7}{6}\\right) = 600 \\exp\\left(-\\frac{7}{6}\\right) $$\n使用计算器，$\\exp(-7/6) \\approx 0.3114036$。\n$$ A_{\\mathrm{crit}} \\approx 600 \\times 0.3114036 \\approx 186.84216 \\, \\mathrm{\\mu m}^2 $$\n按要求四舍五入到四位有效数字，结果为 $186.8$ $\\mathrm{\\mu m}^2$。\n\n### 任务3：数值计算步骤概述\n\n对于任意多边形互连线布局和任意连续缺陷尺寸分布 $f(r)$，敏感性函数 $A(r)$ 通常没有闭式表达式。关键区域 $A_{\\mathrm{crit}} = \\int_{0}^{\\infty} A(r) f(r) dr$ 必须进行数值计算。一个科学上合理的步骤如下：\n\n1.  **离散化缺陷半径域**：定义一个相关的缺陷半径范围 $[r_{\\min}, r_{\\max}]$。下限 $r_{\\min}$ 是能够导致指定多边形对之间任意两点短路的最小半径。选择上限 $r_{\\max}$ 使得概率密度函数的积分 $\\int_{r_{\\max}}^{\\infty} f(r) dr$ 可以忽略不计。将此范围离散化为一组 $N+1$ 个采样点 $\\{r_0, r_1, \\dots, r_N\\}$。\n\n2.  **在采样点处计算敏感性函数**：对于集合中的每个采样半径 $r_i$，计算敏感性面积 $A(r_i)$。这是一个计算几何问题：\n    a.  设两个互连线多边形为 $P_1$ 和 $P_2$。一个半径为 $r_i$、中心在点 $c$ 的缺陷如果其体（半径为 $r_i$ 的圆盘）同时与 $P_1$ 和 $P_2$ 相交，则会引起短路。这等效于中心 $c$ 属于每个多边形与一个半径为 $r_i$ 的圆盘的闵可夫斯基和的交集。\n    b.  数值计算膨胀后的多边形 $P'_1(r_i) = P_1 \\oplus D(r_i)$ 和 $P'_2(r_i) = P_2 \\oplus D(r_i)$，其中 $D(r_i)$ 是一个半径为 $r_i$ 的圆盘。此操作也称为形状膨胀或缓冲。\n    c.  计算这两个膨胀后多边形的几何交集：$R(r_i) = P'_1(r_i) \\cap P'_2(r_i)$。这可以使用鲁棒的多边形裁剪算法（例如，Vatti算法、Greiner-Hormann算法）来完成。\n    d.  计算所得交集多边形 $R(r_i)$ 的面积。该值即为 $A(r_i)$。\n\n3.  **执行数值积分（求积）**：利用采样点集 $(r_i, A(r_i))$ 和已知的函数 $f(r)$，近似计算关键区域的积分。\n    $$ A_{\\mathrm{crit}} \\approx \\int_{r_{\\min}}^{r_{\\max}} A(r) f(r) dr $$\n    这可以使用数值求积法则来完成，例如梯形法则：\n    $$ A_{\\mathrm{crit}} \\approx \\sum_{i=1}^{N} \\frac{A(r_i)f(r_i) + A(r_{i-1})f(r_{i-1})}{2}(r_i - r_{i-1}) $$\n    更精确的方法如辛普森法则或自适应求积可以用于获得更高的精度。另一种方法是蒙特卡洛方法，即从分布 $f(r)$ 中随机抽取缺陷半径，为每个样本计算 $A(r)$，最终的关键区域是计算出的 $A(r)$ 值的平均值。",
            "answer": "$$\\boxed{186.8}$$"
        },
        {
            "introduction": "除了随机缺陷，集成电路制造过程本身也可能引入系统性的损伤，影响器件的可靠性。等离子体刻蚀是现代制造中的关键步骤，但它可能导致“天线效应”，即在浮空导体上积累电荷，从而击穿薄栅氧化层。本练习  提供了一个真实的场景，要求您通过仔细追踪制造流程和各金属层上电荷的累积过程，来计算天线规则违例。这是物理验证中的一项关键技能，有助于在设计阶段就预防过程诱导的损伤。",
            "id": "4264269",
            "problem": "集成电路中的一条布线互连网络在一个单镶嵌金属堆叠中，按照既定的刻蚀-沉积顺序进行制造。该分析是在电子设计自动化（EDA）中面向可制造性设计（DFM）的背景下进行的。该网络将一个晶体管栅极连接到位于最高金属层上的一个远程保护二极管。在等离子刻蚀步骤中，电荷会到达悬浮的导体表面；由此产生的栅氧化层应力源于基本关系式：$Q = J A t$（电荷输送到暴露的导体区域），栅极电压 $V_{g} = Q / C_{g}$，以及氧化物电场 $E = V_{g} / t_{\\text{ox}}$，其中栅氧化层电容 $C_{g} = \\epsilon A_{g} / t_{\\text{ox}}$。因此，代工厂通过在每个刻蚀步骤中限制一个有效的面积与栅极面积之比来控制风险。在实践中，该比率通过特定层的严重性因子以及（在适用时）用于多遍或部分连接刻蚀的部分暴露分数，针对每个刻蚀步骤进行校准。\n\n假设以下工艺顺序和物理配置：\n- 步骤 $S_{1}$：形成连接到晶体管栅极和保护二极管扩散区的钨接触。该二极管在拓扑上仅通过金属层 $3$ 上的一个分支连接到网络，因此保护路径只有在金属层 $3$ 段形成并与二极管接触点连通后才生效。\n- 步骤 $S_{2}$：刻蚀金属层 $1$。\n- 步骤 $S_{3}$：刻蚀过孔 $1$（在金属层 $1$ 和金属层 $2$ 之间）。\n- 步骤 $S_{4}$：分两遍刻蚀金属层 $2$；在第一遍刻蚀中，只有一个比例为 $\\beta_{m2}$ 的金属面积被暴露，之后一个临时的落点特征会减少后续的电荷收集。\n- 步骤 $S_{5}$：刻蚀过孔 $2$（在金属层 $2$ 和金属层 $3$ 之间）。\n- 步骤 $S_{6}$：刻蚀金属层 $3$；连接到二极管的网络分支仅在该步骤接近结束时才闭合，因此在保护路径生效之前，有一个比例为 $\\beta_{m3}$ 的金属层 $3$ 面积对充电有贡献。\n\n栅氧化层面积为 $A_{g} = 0.075 \\,\\mu\\text{m}^{2}$。该网络的每层几何面积如下：\n- 金属层 $1$ 面积 $A_{1} = 16.2 \\,\\mu\\text{m}^{2}$，\n- 过孔 $1$ 落点面积 $A_{v1} = 0.012 \\,\\mu\\text{m}^{2}$，\n- 金属层 $2$ 面积 $A_{2} = 13.4 \\,\\mu\\text{m}^{2}$，\n- 过孔 $2$ 落点面积 $A_{v2} = 0.008 \\,\\mu\\text{m}^{2}$，\n- 金属层 $3$ 面积 $A_{3} = 20.0 \\,\\mu\\text{m}^{2}$。\n\n代工厂校准的等离子充电严重性因子（无量纲，与特定步骤的电流密度和持续时间相对于基准的乘积成正比）如下：\n- $k_{m1} = 0.8$，\n- $k_{v1} = 0.6$，\n- $k_{m2} = 0.95$，\n- $k_{v2} = 0.55$，\n- $k_{m3} = 1.2$。\n\n部分暴露分数为 $\\beta_{m2} = 0.5$ 和 $\\beta_{m3} = 0.85$。\n\n对于每个刻蚀步骤 $s \\in \\{S_{2}, S_{3}, S_{4}, S_{5}, S_{6}\\}$，将每步有效天线比 $r(s)$ 定义为该步骤连接到栅极的有效充电面积（由相关 $k$ 因子、该步骤适用的部分暴露分数以及相应的几何面积的乘积给出）与栅氧化层面积 $A_{g}$ 的比值。代工厂规定了每步允许的最大比率：\n- $R_{\\max}(m1) = 150$ 用于 $S_{2}$ 步骤的金属层 $1$ 刻蚀，\n- $R_{\\max}(v1) = 60$ 用于 $S_{3}$ 步骤的过孔 $1$ 刻蚀，\n- $R_{\\max}(m2) = 140$ 用于 $S_{4}$ 步骤的金属层 $2$ 刻蚀，\n- $R_{\\max}(v2) = 55$ 用于 $S_{5}$ 步骤的过孔 $2$ 刻蚀，\n- $R_{\\max}(m3) = 160$ 用于 $S_{6}$ 步骤的金属层 $3$ 刻蚀。\n\n从等离子充电和氧化层应力的基本关系以及上述工艺顺序逻辑出发，推导出一个关于 $k$、$\\beta$ 和面积参数的 $r(s)$ 的通用表达式，该表达式专门针对这种单镶嵌场景，其中在步骤 $s$ 期间只有当前被刻蚀层的暴露导体表面有贡献。然后，计算 $r(s)$ 超过相应 $R_{\\max}$ 的刻蚀步骤数，即天线规则违规的数量。最终答案以无单位的整数形式表示。",
            "solution": "该问题被认为是有效的，因为它科学地基于半导体制造中等离子体诱导损伤的原理，给出了所有必要的数据，问题陈述良好，并且客观地陈述。任务是首先推导每步有效天线比 $r(s)$ 的通用表达式，然后计算该比率超过代工厂规定最大值的制造步骤数量。\n\n首先，我们推导 $r(s)$ 的通用表达式。问题指出，栅氧化层应力与穿过氧化层的电场 $E$ 成正比。提供了基本关系式：收集的电荷 $Q = J A t$，其中 $J$ 是等离子体电流密度，$A$ 是收集电荷的导体面积，$t$ 是暴露时间。栅极电压为 $V_g = Q / C_g$，栅极电容为 $C_g = \\epsilon A_g / t_{\\text{ox}}$，其中 $A_g$ 是栅氧化层面积，$t_{\\text{ox}}$ 是氧化层厚度，$\\epsilon$ 是氧化物介电常数。穿过氧化层的电场为 $E = V_g / t_{\\text{ox}}$。\n\n结合这些关系，我们可以将电场 $E$ 表示为：\n$$E = \\frac{V_g}{t_{\\text{ox}}} = \\frac{Q / C_g}{t_{\\text{ox}}} = \\frac{Q}{C_g t_{\\text{ox}}} = \\frac{J A t}{(\\epsilon A_g / t_{\\text{ox}}) t_{\\text{ox}}} = \\frac{J A t}{\\epsilon A_g}$$\n这表明，对于给定的工艺化学（决定了 $J$ 和 $\\epsilon$）和持续时间（$t$），破坏性电场 $E$ 与电荷收集面积 $A$ 与栅极面积 $A_g$ 的比值成正比。\n\n问题为这个比率定义了一个实用的、经过校准的版本，即给定刻蚀步骤 $s$ 的有效天线比 $r(s)$。它被定义为该步骤的有效充电面积与栅氧化层面积 $A_g$ 的比值。有效充电面积本身由特定层的严重性因子 $k(s)$、部分暴露分数 $\\beta(s)$（如果适用）以及在该步骤中被刻蚀的几何面积 $A(s)$ 的乘积给出。如果没有明确另外说明，部分暴露分数 $\\beta(s)$ 为 $1$。\n\n因此，步骤 $s$ 的有效天线比的通用表达式为：\n$$r(s) = \\frac{k(s) \\beta(s) A(s)}{A_g}$$\n这个表达式将用于评估每个相关制造步骤的天线规则符合性。问题陈述中提到“在步骤 $s$ 期间只有当前被刻蚀层的暴露导体表面有贡献”，这通过忽略先前各层的累积效应简化了计算。\n\n给定的栅氧化层面积为 $A_g = 0.075 \\,\\mu\\text{m}^{2}$。我们现在为五个刻蚀步骤（$S_2$ 到 $S_6$）中的每一个计算 $r(s)$，并对照规定的最大值检查是否存在违规。\n\n步骤 $S_2$：金属层 $1$ 刻蚀。\n相关参数是金属层 $1$ 面积 $A_1 = 16.2 \\,\\mu\\text{m}^{2}$ 和严重性因子 $k_{m1} = 0.8$。没有提到部分暴露，因此 $\\beta=1$。\n$$r(S_2) = \\frac{k_{m1} A_1}{A_g} = \\frac{0.8 \\times 16.2}{0.075} = \\frac{12.96}{0.075} = 172.8$$\n允许的最大比率为 $R_{\\max}(m1) = 150$。由于 $r(S_2) = 172.8 > 150$，此步骤构成违规。\n\n步骤 $S_3$：过孔 $1$ 刻蚀。\n相关参数是过孔 $1$ 落点面积 $A_{v1} = 0.012 \\,\\mu\\text{m}^{2}$ 和严重性因子 $k_{v1} = 0.6$。没有提到部分暴露，因此 $\\beta=1$。\n$$r(S_3) = \\frac{k_{v1} A_{v1}}{A_g} = \\frac{0.6 \\times 0.012}{0.075} = \\frac{0.0072}{0.075} = 0.096$$\n允许的最大比率为 $R_{\\max}(v1) = 60$。由于 $r(S_3) = 0.096  60$，没有违规。\n\n步骤 $S_4$：金属层 $2$ 刻蚀。\n相关参数是金属层 $2$ 面积 $A_2 = 13.4 \\,\\mu\\text{m}^{2}$，严重性因子 $k_{m2} = 0.95$，以及部分暴露分数 $\\beta_{m2} = 0.5$。\n$$r(S_4) = \\frac{k_{m2} \\beta_{m2} A_2}{A_g} = \\frac{0.95 \\times 0.5 \\times 13.4}{0.075} = \\frac{6.365}{0.075} \\approx 84.867$$\n允许的最大比率为 $R_{\\max}(m2) = 140$。由于 $r(S_4) \\approx 84.867  140$，没有违规。\n\n步骤 $S_5$：过孔 $2$ 刻蚀。\n相关参数是过孔 $2$ 落点面积 $A_{v2} = 0.008 \\,\\mu\\text{m}^{2}$ 和严重性因子 $k_{v2} = 0.55$。没有提到部分暴露，因此 $\\beta=1$。\n$$r(S_5) = \\frac{k_{v2} A_{v2}}{A_g} = \\frac{0.55 \\times 0.008}{0.075} = \\frac{0.0044}{0.075} \\approx 0.0587$$\n允许的最大比率为 $R_{\\max}(v2) = 55$。由于 $r(S_5) \\approx 0.0587  55$，没有违规。\n\n步骤 $S_6$：金属层 $3$ 刻蚀。\n相关参数是金属层 $3$ 面积 $A_3 = 20.0 \\,\\mu\\text{m}^{2}$，严重性因子 $k_{m3} = 1.2$，以及部分暴露分数 $\\beta_{m3} = 0.85$。这个分数解释了在保护二极管连接之前的那部分刻蚀步骤。\n$$r(S_6) = \\frac{k_{m3} \\beta_{m3} A_3}{A_g} = \\frac{1.2 \\times 0.85 \\times 20.0}{0.075} = \\frac{20.4}{0.075} = 272$$\n允许的最大比率为 $R_{\\max}(m3) = 160$。由于 $r(S_6) = 272 > 160$，此步骤构成违规。\n\n总而言之，在步骤 $S_2$（金属层 $1$ 刻蚀）和步骤 $S_6$（金属层 $3$ 刻蚀）中发现了违规。其他步骤（$S_3$、$S_4$、$S_5$）符合指定的天线规则。\n\n$r(s)$ 超过相应 $R_{\\max}$ 的刻蚀步骤总数是发现的违规总和。存在两个这样的步骤。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "随着工艺节点进入20纳米及以下，传统光刻技术的物理极限催生了多重曝光（Multi-Patterning）等复杂解决方案。将版图特征分配到不同的掩模版（颜色）以满足严格的间距规则，是可制造性设计面临的前沿挑战。本高级练习  将这个复杂的DFM任务抽象为一个图着色问题，并指导您如何将其构建成一个整数线性规划（ILP）模型。掌握这种方法不仅能解决掩模分配问题，也为您提供了使用高级优化技术来处理EDA领域中其他计算难题的宝贵经验。",
            "id": "4264247",
            "problem": "考虑一个用于集成电路中单个布线层的多重曝光掩模分配的简化数学模型，该模型在可制造性设计 (DFM) 方法学下用于电子设计自动化 (EDA)。其目标是在间距约束下最小化特征着色冲突，同时最小化为跨掩模分割特征而引入的缝合点 (stitch) 数量。该问题被构建为整数线性规划 (ILP)，包含二元决策变量和线性约束。\n\n基本基础：\n- 一个布线层由一组线段组成，这些线段代表待由给定数量的掩模（颜色）之一进行着色的特征。这组线段是一个基数为 $P$ 的有限索引集，由索引 $p \\in \\{0,1,\\ldots,P-1\\}$ 表示。\n- 有 $k$ 个可用掩模（颜色），索引为 $c \\in \\{0,1,\\ldots,k-1\\}$。\n- 间距约束由一个基于线段的无向图表示，其中每条边 $(u,v)$ 表示线段 $u$ 和 $v$ 距离过近，因此必须被分配不同的颜色以避免冲突。然而，如果约束无法被满足，优化过程可以容忍冲突，但会产生代价。\n- 某些特征可能是可缝合的，由属于同一特征的线段对 $(p_1,p_2)$ 表示。一个缝合点允许该线段对中的两个线段被分配不同的颜色，但这会产生一个惩罚。如果没有缝合点，该线段对中的两个线段必须被分配相同的颜色。\n- 在目标函数中，冲突和缝合点带有可加的惩罚。\n\n用于推导的核心定义：\n- 二元颜色分配变量 $x_{p,c} \\in \\{0,1\\}$，表示线段 $p$ 是否使用颜色 $c$。\n- 二元冲突指示变量 $w_{e} \\in \\{0,1\\}$，对于每个间距边 $e = (u,v)$，表示 $u$ 和 $v$ 是否具有相同颜色并因此产生冲突。\n- 二元缝合指示变量 $s_{i} \\in \\{0,1\\}$，对于每个可缝合对 $i = (p_1,p_2)$，表示是否插入了一个缝合点，从而使得 $p_1$ 和 $p_2$ 可以有不同的颜色；如果 $s_i=0$，两者必须使用相同的颜色。\n\n您的任务：\n- 从上述基础出发，推导出一个正确的 ILP 公式，以捕捉以下逻辑要求：\n    - 每个线段恰好选择一种颜色。\n    - 当且仅当两个相邻线段共享相同颜色时，冲突指示变量才被激活。\n    - 缝合指示变量允许线段对中的两个线段颜色不同；否则，两个线段必须共享相同的颜色。\n- 使用标准的混合整数线性规划 (MILP) 例程实现一个求解器，用于计算最小总惩罚（定义为冲突惩罚和缝合惩罚之和）。该求解器必须处理上述二元变量以及为编码逻辑条件所必需的线性化。\n- 对于每个测试用例，返回最小目标函数值（整数）。\n\n角度单位不适用。不涉及物理单位。所有输出必须是数字。\n\n测试套件：\n- 测试用例 1（当线段对受约束时，在奇数环上使用缝合点的好处）：\n    - $k = 2$。\n    - 线段：$P=6$，索引 $0,1,2,3,4,5$。\n    - 可缝合对：$(0,1)$, $(2,3)$, $(4,5)$。\n    - 间距边：$(0,2)$, $(3,4)$, $(5,1)$。\n    - 冲突惩罚权重 $W_{\\text{conflict}} = 10$。\n    - 缝合惩罚权重 $W_{\\text{stitch}} = 1$。\n- 测试用例 2（二分图无缝合点解，理想情况）：\n    - $k = 2$。\n    - 线段：$P=4$，索引 $0,1,2,3$。\n    - 可缝合对：$(0,1)$, $(2,3)$。\n    - 间距边：$(0,2)$, $(1,3)$。\n    - 冲突惩罚权重 $W_{\\text{conflict}} = 10$。\n    - 缝合惩罚权重 $W_{\\text{stitch}} = 5$。\n- 测试用例 3（无缝合点的不可二着色三角形，边界情况）：\n    - $k = 2$。\n    - 线段：$P=3$，索引 $0,1,2$。\n    - 可缝合对：无。\n    - 间距边：$(0,1)$, $(1,2)$, $(2,0)$。\n    - 冲突惩罚权重 $W_{\\text{conflict}} = 3$。\n    - 缝合惩罚权重 $W_{\\text{stitch}} = 0$。\n\n程序输出格式：\n- 您的程序应产生单行输出，其中包含一个方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），其中每个结果是相应测试用例的最小总惩罚，以整数形式表示。\n\n科学真实性和推导要求：\n- 从上述基本定义和变量之间的标准逻辑关系出发。\n- 系统地推导 ILP 约束，避免为目标约束使用快捷公式或预先指定的表达式。\n- 确保公式在数学上是合理的，并且可以被现代 MILP 求解器求解。\n- 程序必须是自包含的，并且不得从任何外部源读取输入。",
            "solution": "所提出的问题是一个有效的优化任务，根植于集成电路的电子设计自动化 (EDA) 领域，特别是解决多重曝光光刻问题。它要求构建并求解一个整数线性规划 (ILP) 来最小化着色冲突和缝合点的使用。该问题是适定的，有科学依据，并为获得关于最小目标值的唯一解提供了所有必要信息。我将首先系统地推导 ILP 公式，然后进行实现。\n\n一个整数线性规划由一个待最小化或最大化的目标函数、一组决策变量以及这些变量必须满足的线性约束系统定义。\n\n**1. 决策变量**\n\n根据问题陈述中的定义，我们有三种类型的二元决策变量：\n-   $x_{p,c} \\in \\{0,1\\}$：如果线段 $p$ 被分配颜色 $c$，则该变量为 $1$，否则为 $0$。这里，$p \\in \\{0, 1, \\ldots, P-1\\}$ 是线段索引，$c \\in \\{0, 1, \\ldots, k-1\\}$ 是颜色索引。\n-   $w_{e} \\in \\{0,1\\}$：对于所有间距边集合 $E$ 中的每条边 $e = (u,v)$，如果发生冲突（即线段 $u$ 和 $v$ 被分配了相同的颜色），则该变量为 $1$，否则为 $0$。\n-   $s_{i} \\in \\{0,1\\}$：对于所有可缝合线段对集合 $S$ 中的每对 $i = (p_1, p_2)$，如果使用了缝合点（允许 $p_1$ 和 $p_2$ 有不同的颜色），则该变量为 $1$，否则为 $0$。\n\n**2. 目标函数**\n\n目标是最小化总惩罚，即所有冲突和所有缝合点产生的惩罚之和。单个冲突的惩罚由权重 $W_{\\text{conflict}}$ 给出，单个缝合点的惩罚由 $W_{\\text{stitch}}$ 给出。因此，目标函数 $Z$ 可以被公式化为 $w_e$ 和 $s_i$ 变量的线性组合：\n$$ \\text{minimize } Z = W_{\\text{conflict}} \\sum_{e \\in E} w_e + W_{\\text{stitch}} \\sum_{i \\in S} s_i $$\n此表达式是线性的，符合 ILP 的要求。\n\n**3. 约束推导**\n\n模型的逻辑要求必须被转化为一组线性的不等式和等式。\n\n**3.1. 唯一颜色分配约束**\n每个线段必须被精确分配一种颜色。对于任何给定的线段 $p$，其分配变量 $x_{p,c}$ 对所有可能的颜色 $c$ 的总和必须等于 $1$。这确保了只有一个 $x_{p,c}$ 等于 $1$。这给了我们一组 $P$ 个线性等式约束：\n$$ \\sum_{c=0}^{k-1} x_{p,c} = 1 \\quad \\forall p \\in \\{0, 1, \\ldots, P-1\\} $$\n\n**3.2. 冲突指示变量约束**\n对于一条边 $e=(u,v)$，其冲突指示变量 $w_e$ 当且仅当线段 $u$ 和 $v$ 被分配相同颜色时必须被激活 ($w_e=1$)。这个逻辑条件需要被线性化。\n“$u$ 和 $v$ 颜色相同”的条件在存在某个颜色 $c$ 使得 $x_{u,c}=1$ 和 $x_{v,c}=1$ 同时成立时为真。对于一个特定的颜色 $c$，$x_{u,c} + x_{v,c}$ 的值可以是 $0$、$1$ 或 $2$。当和为 $2$ 时，就发生了该颜色的冲突。\n\n为了将其与二元变量 $w_e$ 联系起来，我们必须强制要求：如果对于任何颜色 $c$ 有 $x_{u,c} + x_{v,c} = 2$，那么 $w_e$ 必须为 $1$。我们可以通过以下针对每种颜色的不等式来建立这种关系：\n$$ x_{u,c} + x_{v,c} - 1 \\le w_e $$\n我们来验证这个约束。如果线段 $u$ 和 $v$ 被分配了不同的颜色，那么对于任何颜色 $c$，$x_{u,c}$ 和 $x_{v,c}$ 中至多有一个能为 $1$。因此，$x_{u,c} + x_{v,c} \\le 1$，约束变为 $x_{u,c} + x_{v,c} - 1 \\le 0 \\le w_e$。这并不强制 $w_e$ 为 $0$，但由于目标函数是最小化 $w_e$，求解器会在没有冲突时将 $w_e$ 设为 $0$。如果 $u$ 和 $v$ 被分配了相同的颜色 $c^*$，那么 $x_{u,c^*} = 1$ 且 $x_{v,c^*} = 1$。对于 $c^*$ 的约束变为 $1+1-1 \\le w_e$，简化为 $1 \\le w_e$。由于 $w_e$ 是一个二元变量，它被强制为 $1$。\n这个公式正确地捕捉了该逻辑。因此，我们引入 $|E| \\times k$ 个这样的约束：\n$$ x_{u,c} + x_{v,c} - 1 \\le w_e \\quad \\forall e=(u,v) \\in E, \\forall c \\in \\{0, 1, \\ldots, k-1\\} $$\n\n**3.3. 缝合指示变量约束**\n对于一个可缝合对 $i=(p_1, p_2)$，如果没有使用缝合点 ($s_i=0$)，这些线段必须颜色相同。如果使用了缝合点 ($s_i=1$)，它们被允许有不同的颜色。这种条件逻辑必须被线性化。\n\n“必须颜色相同”的条件意味着对于所有颜色 $c$ 都有 $x_{p_1,c} = x_{p_2,c}$。这等价于 $|x_{p_1,c} - x_{p_2,c}| = 0$。“可以有不同颜色”的条件则不施加任何限制。\n\n我们可以使用二元变量 $s_i$ 来对此建模。当 $s_i=0$ 时约束应该激活，当 $s_i=1$ 时约束应该松弛。考虑以下不等式：\n$$ x_{p_1,c} - x_{p_2,c} \\le s_i $$\n$$ x_{p_2,c} - x_{p_1,c} \\le s_i $$\n我们来验证这个公式。如果 $s_i=0$，约束变为 $x_{p_1,c} - x_{p_2,c} \\le 0$ 和 $x_{p_2,c} - x_{p_1,c} \\le 0$。这两者共同意味着对于所有 $c$ 都有 $x_{p_1,c} = x_{p_2,c}$，这正确地强制了相同的颜色分配。如果 $s_i=1$，约束变为 $x_{p_1,c} - x_{p_2,c} \\le 1$ 和 $x_{p_2,c} - x_{p_1,c} \\le 1$。由于 $x_{p,c}$ 变量是二元的，它们的差值只能是 $-1$、$0$ 或 $1$。这些不等式对于任何有效的颜色分配总是成立的，因此正确地松弛了约束。\n这产生了 $|S| \\times k \\times 2$ 个线性不等式：\n$$ x_{p_1, c} - x_{p_2, c} \\le s_i \\quad \\forall i=(p_1, p_2) \\in S, \\forall c \\in \\{0, \\ldots, k-1\\} $$\n$$ x_{p_2, c} - x_{p_1, c} \\le s_i \\quad \\forall i=(p_1, p_2) \\in S, \\forall c \\in \\{0, \\ldots, k-1\\} $$\n\n**4. 完整 ILP 公式总结**\n\n-   **变量**:\n    -   $x_{p,c} \\in \\{0,1\\}$ for $p \\in \\{0, \\ldots, P-1\\}$, $c \\in \\{0, \\ldots, k-1\\}$\n    -   $w_e \\in \\{0,1\\}$ for $e \\in E$\n    -   $s_i \\in \\{0,1\\}$ for $i \\in S$\n-   **目标**:\n    $$ \\text{minimize } Z = W_{\\text{conflict}} \\sum_{e \\in E} w_e + W_{\\text{stitch}} \\sum_{i \\in S} s_i $$\n-   **约束**:\n    1.  $\\sum_{c=0}^{k-1} x_{p,c} = 1 \\quad \\forall p \\in \\{0, \\ldots, P-1\\}$\n    2.  $x_{u,c} + x_{v,c} - 1 \\le w_e \\quad \\forall e=(u,v) \\in E, \\forall c \\in \\{0, \\ldots, k-1\\}$\n    3.  $x_{p_1, c} - x_{p_2, c} \\le s_i \\quad \\forall i=(p_1, p_2) \\in S, \\forall c \\in \\{0, \\ldots, k-1\\}$\n    4.  $x_{p_2, c} - x_{p_1, c} \\le s_i \\quad \\forall i=(p_1, p_2) \\in S, \\forall c \\in \\{0, \\ldots, k-1\\}$\n\n至此，ILP 模型的推导完成。下一步是基于此公式实现一个求解器。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import milp, LinearConstraint, Bounds\n\ndef solve_milp(P, k, stitch_pairs, spacing_edges, W_conflict, W_stitch):\n    \"\"\"\n    Formulates and solves the multi-patterning mask assignment problem as a MILP.\n    \n    Args:\n        P (int): The number of segments.\n        k (int): The number of available masks (colors).\n        stitch_pairs (list of tuples): List of pairs of segments that are stitchable.\n        spacing_edges (list of tuples): List of pairs of segments with spacing constraints.\n        W_conflict (float): The penalty weight for a coloring conflict.\n        W_stitch (float): The penalty weight for inserting a stitch.\n    \n    Returns:\n        int: The minimum total penalty, or -1 if the solver fails.\n    \"\"\"\n    num_segments = P\n    num_colors = k\n\n    # Canonicalize edges and pairs to be sorted tuples for consistent mapping\n    spacing_edges = [tuple(sorted(e)) for e in spacing_edges]\n    stitch_pairs = [tuple(sorted(p)) for p in stitch_pairs]\n\n    edge_map = {edge: i for i, edge in enumerate(spacing_edges)}\n    pair_map = {pair: i for i, pair in enumerate(stitch_pairs)}\n    \n    num_x_vars = num_segments * num_colors\n    num_w_vars = len(spacing_edges)\n    num_s_vars = len(stitch_pairs)\n    num_vars = num_x_vars + num_w_vars + num_s_vars\n\n    # --- Variable Indexing Helper Functions ---\n    def x_idx(p, c): return p * num_colors + c\n    def w_idx(u, v):\n        edge = tuple(sorted((u,v)))\n        return num_x_vars + edge_map[edge]\n    def s_idx(p1, p2):\n        pair = tuple(sorted((p1,p2)))\n        return num_x_vars + num_w_vars + pair_map[pair]\n\n    # --- Objective Function ---\n    c_obj = np.zeros(num_vars)\n    for i in range(num_w_vars):\n        c_obj[num_x_vars + i] = W_conflict\n    for i in range(num_s_vars):\n        c_obj[num_x_vars + num_w_vars + i] = W_stitch\n\n    # --- Variable Properties ---\n    # All variables are binary (integer with bounds [0, 1])\n    integrality = np.ones(num_vars)\n    bounds = Bounds(lb=0, ub=1)\n\n    constraints = []\n    \n    # --- Constraint 1: Each segment gets exactly one color ---\n    # sum(x_pc for c) == 1 for all p\n    if num_segments > 0:\n        A_eq1 = np.zeros((num_segments, num_vars))\n        b_eq1 = np.ones(num_segments)\n        for p in range(num_segments):\n            for c_ in range(num_colors):\n                A_eq1[p, x_idx(p, c_)] = 1\n        constraints.append(LinearConstraint(A_eq1, b_eq1, b_eq1))\n\n    # List to gather all inequality constraint matrices and bounds\n    A_ub_list = []\n    b_ub_list = []\n\n    # --- Constraint 2: Conflict indicator activation ---\n    # x_uc + x_vc - w_e = 1\n    for u, v in spacing_edges:\n        for c_ in range(num_colors):\n            row = np.zeros(num_vars)\n            row[x_idx(u, c_)] = 1\n            row[x_idx(v, c_)] = 1\n            row[w_idx(u,v)] = -1\n            A_ub_list.append(row)\n            b_ub_list.append(1)\n\n    # --- Constraint 3: Stitch indicator logic ---\n    # x_{p1,c} - x_{p2,c} - s_i = 0\n    # x_{p2,c} - x_{p1,c} - s_i = 0\n    for p1, p2 in stitch_pairs:\n        for c_ in range(num_colors):\n            # First inequality\n            row1 = np.zeros(num_vars)\n            row1[x_idx(p1, c_)] = 1\n            row1[x_idx(p2, c_)] = -1\n            row1[s_idx(p1, p2)] = -1\n            A_ub_list.append(row1)\n            b_ub_list.append(0)\n            \n            # Second inequality\n            row2 = np.zeros(num_vars)\n            row2[x_idx(p1, c_)] = -1\n            row2[x_idx(p2, c_)] = 1\n            row2[s_idx(p1, p2)] = -1\n            A_ub_list.append(row2)\n            b_ub_list.append(0)\n\n    if A_ub_list:\n        A_ub = np.vstack(A_ub_list)\n        b_ub = np.array(b_ub_list)\n        constraints.append(LinearConstraint(A_ub, -np.inf, b_ub))\n\n    # --- Solve the MILP ---\n    res = milp(c=c_obj, integrality=integrality, bounds=bounds, constraints=constraints)\n\n    if res.success:\n        # The optimal value should be an integer, round to handle float inaccuracies\n        return int(round(res.fun))\n    else:\n        # Return an error code if solver fails\n        return -1\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: Odd cycle of feature pairs, stitch cost is low\n        {\n            \"k\": 2, \"P\": 6, \"segments\": list(range(6)),\n            \"stitch_pairs\": [(0, 1), (2, 3), (4, 5)],\n            \"spacing_edges\": [(0, 2), (3, 4), (5, 1)],\n            \"W_conflict\": 10, \"W_stitch\": 1\n        },\n        # Test Case 2: Bipartite graph, no stitches or conflicts needed\n        {\n            \"k\": 2, \"P\": 4, \"segments\": list(range(4)),\n            \"stitch_pairs\": [(0, 1), (2, 3)],\n            \"spacing_edges\": [(0, 2), (1, 3)],\n            \"W_conflict\": 10, \"W_stitch\": 5\n        },\n        # Test Case 3: Simple non-2-colorable graph (triangle), no stitches available\n        {\n            \"k\": 2, \"P\": 3, \"segments\": list(range(3)),\n            \"stitch_pairs\": [],\n            \"spacing_edges\": [(0, 1), (1, 2), (2, 0)],\n            \"W_conflict\": 3, \"W_stitch\": 0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_milp(case[\"P\"], case[\"k\"], case[\"stitch_pairs\"],\n                            case[\"spacing_edges\"], case[\"W_conflict\"],\n                            case[\"W_stitch\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}