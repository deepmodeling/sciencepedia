{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在搭建实验电化学与热力学建模之间的桥梁。您将学习如何处理原始的电动势（EMF）数据来计算热力学因子，这是表征电解质特性的关键第一步。本练习还强调了质量摩尔浓度（molality）和物质的量浓度（molarity）这两个浓度标度在实际应用中的重要区别，以及如何在它们之间进行转换。",
            "id": "3957469",
            "problem": "给定盐六氟磷酸锂 (LiPF$_6$) 在混合溶剂碳酸亚乙酯 (EC) 和碳酸二乙酯 (DEC) 中，于固定温度下，电动势 (EMF) 作为质量摩尔浓度的自然对数函数的数据。目标是计算质量摩尔浓度标度下的热力学因子，并量化在体积摩尔浓度标度下进行分析所产生的影响。热力学因子是一个无量纲量，定义为活度对所选浓度度量的对数灵敏度，是自动化电池设计和模拟中输运建模的核心。\n\n基本原理：\n- 离子物种的电化学势由化学势的定义给出，其中活度在电势中以对数形式出现。\n- 能斯特方程将两个溶液之间测得的电动势与活度之比联系起来。\n- 应用了二元电解质的电中性原理和一致的活度定义。\n- 质量摩尔浓度 $m$（单位：$\\mathrm{mol/kg}$ 溶剂）和体积摩尔浓度 $c$（单位：$\\mathrm{mol/L}$ 溶液）是不同的浓度标度，它们通过溶液密度和盐的摩尔质量以科学上一致的方式相关联。\n\n您的程序必须：\n1. 从上述基本原理出发，构建一个算法，该算法在给定固定温度 $T$ 下电动势 $E$ 相对于 $\\ln m$ 的表格数据时，通过对电动势关于 $\\ln m$ 求导并用热力学常数进行归一化，来估计质量摩尔浓度标度下的热力学因子，记为 $\\Theta_m(m)$。\n2. 使用一个显式的、物理上合理的 EC:DEC 与 LiPF$_6$ 溶液的密度模型，通过在 $m$ 和 $c$ 之间应用数学上严格的变量代换，将结果转换为体积摩尔浓度标度 $\\Theta_c(c)$。\n3. 在非均匀网格上使用数值稳定的微分方法，并将导数内插到指定的评估点。\n\n此问题的定义和建模假设：\n- 令 $R$ 表示普适气体常数，$F$ 表示法拉第常数。令 $T$ 为绝对温度，单位为 $\\mathrm{K}$。\n- 令 $\\rho(m)$ 表示溶液密度，单位为 $\\mathrm{kg/L}$，建模为 $m$ 的平滑函数，在测试范围内严格为正。\n- 令 $M_s$ 表示盐的摩尔质量，单位为 $\\mathrm{kg/mol}$。\n- 质量摩尔浓度标度上的热力学因子定义为无量纲导数 $\\Theta_m(m)$，由固定 $T$ 下电动势对 $\\ln m$ 的灵敏度得到。\n- 体积摩尔浓度 $c$ 和质量摩尔浓度 $m$ 的关系为\n$$\nc(m) = \\frac{m \\, \\rho(m)}{1 + m M_s},\n$$\n并且将导数从 $\\ln m$ 转换为 $\\ln c$ 所需的变量代换因子必须通过对 $\\ln c(m)$ 关于 $\\ln m$ 求导来导出。\n- 您必须使用以下物理上合理的 EC:DEC 与溶解的 LiPF$_6$ 的密度模型：\n$$\n\\rho(m) = 1.25 + 0.04 m - 0.002 m^2 \\quad \\text{单位：} \\mathrm{kg/L},\n$$\n在 $m \\in [0.1, 2.0]$ 范围内有效。其关于 $m$ 的导数为\n$$\n\\frac{d\\rho}{dm} = 0.04 - 0.004 m.\n$$\n- 使用 $M_s = 0.1519 \\, \\mathrm{kg/mol}$ (对于 LiPF$_6$) 和 $T = 298.15 \\, \\mathrm{K}$。\n- 电动势值单位为 $\\mathrm{V}$，必须与能斯特关系一致地处理。所有 $\\Theta$ 的输出均为无量纲。\n\n测试套件（三个案例）：\n- 案例1（近理想行为，理想路径）：质量摩尔浓度网格 $m = [0.1, 0.2, 0.5, 1.0, 1.5]$。EMF 数据由下式构建\n$$\nE(m) = E_0 + \\frac{R T}{F} \\ln m,\n$$\n其中 $E_0 = 0.15 \\, \\mathrm{V}$。在 $m^\\star = 1.0$ 处评估 $\\Theta_m$ 和 $\\Theta_c$。\n- 案例2（中度非理想性，中心区域）：质量摩尔浓度网格 $m = [0.2, 0.5, 1.0, 1.3, 1.6]$。EMF 数据由下式构建\n$$\nE(m) = E_0 + \\frac{R T}{F} \\left(\\ln m + \\ln \\gamma_1(m)\\right), \\quad \\ln \\gamma_1(m) = -\\frac{0.5 \\sqrt{m}}{1 + 0.8 m},\n$$\n其中 $E_0 = 0.05 \\, \\mathrm{V}$。在 $m^\\star = 1.0$ 处评估 $\\Theta_m$ 和 $\\Theta_c$。\n- 案例3（较高浓度下的更强非理想性，边界案例）：质量摩尔浓度网格 $m = [0.5, 1.0, 1.5, 2.0]$。EMF 数据由下式构建\n$$\nE(m) = E_0 + \\frac{R T}{F} \\left(\\ln m + \\ln \\gamma_2(m)\\right), \\quad \\ln \\gamma_2(m) = \\frac{0.2 m}{1 + 0.5 m},\n$$\n其中 $E_0 = 0.03 \\, \\mathrm{V}$。在 $m^\\star = 1.5$ 处评估 $\\Theta_m$ 和 $\\Theta_c$。\n\n算法要求：\n- 通过在给定的非均匀网格上使用有限差分，实现对导数 $\\frac{dE}{d \\ln m}$ 的数值稳定估计。为此，使用中心差分（如果可能）和在边界处使用单边差分来计算 $E$ 相对于 $x = \\ln m$ 的导数。如果 $m^\\star$ 不恰好是网格点，则在 $m$ 域上将导数内插到 $m^\\star$。\n- 通过用常数 $R$、$T$ 和 $F$ 适当地归一化导数，来计算质量摩尔浓度热力学因子。\n- 通过解析地将 $\\frac{d \\ln a}{d \\ln c}$ 与 $\\frac{d \\ln a}{d \\ln m}$ 联系起来（通过 $\\ln c(m)$ 相对于 $\\ln m$ 的导数并应用链式法则），来计算体积摩尔浓度热力学因子。明确使用所提供的 $\\rho(m)$ 和 $\\frac{d\\rho}{dm}$。\n\n答案规格：\n- 对于每个案例，返回一个浮点数对 $[\\Theta_m(m^\\star), \\Theta_c(c(m^\\star))]$。\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个条目对应一个案例，其本身是一个双元素列表。例如，一个包含三个案例的输出必须如下所示：\n$$\n\\texttt{[[\\theta\\_m^1,\\theta\\_c^1],[\\theta\\_m^2,\\theta\\_c^2],[\\theta\\_m^3,\\theta\\_c^3]]}\n$$\n- 所有 $\\Theta$ 值必须是无量纲的十进制浮点数。将报告的每个浮点数四舍五入到六位小数。",
            "solution": "该问题陈述经验证具有科学依据、适定、客观且完整。它基于热力学和电化学的基本原理，提供了所有必要的常数、模型和数据，并且表述精确。未发现任何缺陷。\n\n解决方案分三步进行：首先，建立电动势 ($E$) 和质量摩尔浓度热力学因子 ($\\Theta_m$) 之间的理论关系；其次，推导将质量摩尔浓度热力学因子 ($\\Theta_m$) 与体积摩尔浓度热力学因子 ($\\Theta_c$) 相关联的转换因子；第三，概述实现这些计算的数值算法。\n\n**1. 从EMF数据推导质量摩尔浓度热力学因子 ($\\Theta_m$)**\n\n该问题涉及一个浓差电池，其中电动势 ($E$) 是盐 $\\text{LiPF}_6$ 质量摩尔浓度 ($m$) 的函数。盐的化学势 $\\mu$ 决定了电池电势。盐的活度 $a$ 与其质量摩尔浓度 $m$ 和平均质量摩尔活度系数 $\\gamma_\\pm$ 通过 $a = (m \\gamma_\\pm)^\\nu$ 相关，其中 $\\nu$ 是每个盐分子式单元产生的离子数。对于 $\\text{LiPF}_6$，$\\nu=2$。\n\n能斯特方程将电动势与活度联系起来。问题为所讨论的电池提供了这种关系的简化形式：\n$$E(m) = E_0 + \\frac{R T}{F} (\\ln m + \\ln \\gamma(m))$$\n其中 $R$ 是普适气体常数， $T$ 是绝对温度， $F$ 是法拉第常数，$\\gamma(m)$ 代表所测量过程的有效活度系数。项 $\\ln m + \\ln \\gamma(m)$ 等价于 $\\ln a_s$，其中 $a_s$ 是质量摩尔浓度标度下电活性物质的活度。前置因子 $\\frac{RT}{F}$ 表明这是一个单电子过程，这与测量像 $\\text{Li}^+$ 这样的单个离子的活度是一致的。\n\n质量摩尔浓度标度上的热力学因子 $\\Theta_m(m)$ 定义为盐活度相对于质量摩尔浓度的对数导数。虽然形式化定义涉及平均离子活度系数，但问题的结构暗示 $\\Theta_m$ 应从测量的电动势灵敏度推导出来。我们以一种与所提供的电动势表达式相一致的方式来定义 $\\Theta_m$。让我们对 $E$ 关于质量摩尔浓度的自然对数 $x = \\ln m$ 求导：\n$$\\frac{dE}{d \\ln m} = \\frac{d}{d \\ln m} \\left[ E_0 + \\frac{R T}{F} \\ln a_s \\right] = \\frac{R T}{F} \\frac{d \\ln a_s}{d \\ln m}$$\n问题要求通过归一化该导数来获得无量纲的热力学因子 $\\Theta_m(m)$。这种归一化通过乘以 $\\frac{F}{RT}$ 实现：\n$$\\Theta_m(m) = \\frac{F}{RT} \\frac{dE}{d \\ln m}$$\n代入测试案例 EMF 的形式，其中 $a_s = m\\gamma(m)$：\n$$\\Theta_m(m) = \\frac{d \\ln(m\\gamma(m))}{d \\ln m} = \\frac{d(\\ln m + \\ln \\gamma(m))}{d \\ln m} = 1 + \\frac{d \\ln \\gamma(m)}{d \\ln m}$$\n这证实了我们的方法与标准定义是一致的。因此，第一个计算步骤的核心是数值计算 $\\frac{dE}{d \\ln m}$ 并对其进行适当的缩放。\n\n**2. 转换为体积摩尔浓度热力学因子 ($\\Theta_c$)**\n\n第二个任务是将 $\\Theta_m$ 转换为其在体积摩尔浓度标度下的等效值 $\\Theta_c$。体积摩尔浓度 $c$ (单位 $\\mathrm{mol/L}$) 和质量摩尔浓度 $m$ (单位 $\\mathrm{mol/kg}$) 通过溶液密度 $\\rho$ (单位 $\\mathrm{kg/L}$) 和盐的摩尔质量 $M_s$ (单位 $\\mathrm{kg/mol}$) 相关联：\n$$c(m) = \\frac{m \\, \\rho(m)}{1 + m M_s}$$\n基本活度 $a_s$ 是溶液状态的一个属性，与浓度标度的选择无关。因此，定义为活度相对于浓度的对数导数的热力学因子，通过链式法则相关联：\n$$\\Theta_c(c) \\equiv \\frac{d \\ln a_s}{d \\ln c} = \\frac{d \\ln a_s}{d \\ln m} \\cdot \\frac{d \\ln m}{d \\ln c} = \\Theta_m(m) \\left( \\frac{d \\ln c}{d \\ln m} \\right)^{-1}$$\n为了找到转换因子，我们计算导数 $\\frac{d \\ln c}{d \\ln m}$。最方便的方法是从对 $c(m)$ 的表达式取对数开始：\n$$\\ln c = \\ln m + \\ln \\rho(m) - \\ln(1 + m M_s)$$\n现在，我们对 $\\ln m$ 求导。使用关系 $d(\\ln m) = \\frac{1}{m} dm$：\n$$\\frac{d \\ln c}{d \\ln m} = m \\frac{d(\\ln c)}{dm} = m \\frac{d}{dm} \\left[ \\ln m + \\ln \\rho(m) - \\ln(1 + m M_s) \\right]$$\n$$ = m \\left[ \\frac{1}{m} + \\frac{1}{\\rho(m)} \\frac{d\\rho}{dm} - \\frac{M_s}{1 + m M_s} \\right] $$\n$$ = 1 + \\frac{m}{\\rho(m)} \\frac{d\\rho}{dm} - \\frac{m M_s}{1 + m M_s} $$\n此表达式使用所提供的密度模型 $\\rho(m)$ 及其导数 $\\frac{d\\rho}{dm}$ 提供了所需的转换因子。体积摩尔浓度热力学因子则为：\n$$\\Theta_c(c(m)) = \\Theta_m(m) \\left( 1 + \\frac{m}{\\rho(m)} \\frac{d\\rho}{dm} - \\frac{m M_s}{1 + m M_s} \\right)^{-1}$$\n\n**3. 数值算法设计**\n\n完整的算法如下：\n对于每个具有质量摩尔浓度网格 $\\{m_i\\}$、相应 EMF 数据 $\\{E_i\\}$ 和评估质量摩尔浓度 $m^\\star$ 的测试案例：\n1.  **准备数据**：为每个网格点计算 $x_i = \\ln m_i$。数据点为 $(x_i, E_i)$。\n2.  **数值微分**：在每个网格点 $m_i$ 计算导数 $\\frac{dE}{d \\ln m}$。令结果为 $D_i$。\n    - 对于内部点 ($0 < i < N-1$)：使用二阶中心差分公式：\n      $$D_i = \\frac{E_{i+1} - E_{i-1}}{x_{i+1} - x_{i-1}}$$\n    - 对于第一个点 ($i=0$)：使用一阶向前差分公式：\n      $$D_0 = \\frac{E_1 - E_0}{x_1 - x_0}$$\n    - 对于最后一个点 ($i=N-1$)：使用一阶向后差分公式：\n      $$D_{N-1} = \\frac{E_{N-1} - E_{N-2}}{x_{N-1} - x_{N-2}}$$\n3.  **内插**：如果 $m^\\star$ 不是网格点，则在质量摩尔浓度网格 $\\{m_i\\}$ 上对计算出的导数值 $\\{D_i\\}$ 进行线性内插，以找到在 $m^\\star$ 处的导数 $D^\\star$。如果 $m^\\star$ 是网格点，则直接使用相应的 $D_i$。\n4.  **计算 $\\Theta_m(m^\\star)$**：应用第1节中推导的归一化公式：\n    $$\\Theta_m(m^\\star) = D^\\star \\cdot \\frac{F}{R T}$$\n    使用给定常数 $T = 298.15 \\, \\mathrm{K}$，$R = 8.314462618 \\, \\mathrm{J/(mol \\cdot K)}$ 和 $F = 96485.33212 \\, \\mathrm{C/mol}$。\n5.  **计算 $\\Theta_c(c(m^\\star))$**：\n    a. 使用提供的模型评估在 $m^\\star$ 处的密度 $\\rho(m^\\star)$ 及其导数 $\\frac{d\\rho}{dm}(m^\\star)$：\n       $$\\rho(m^\\star) = 1.25 + 0.04 m^\\star - 0.002 (m^\\star)^2$$\n       $$\\frac{d\\rho}{dm}(m^\\star) = 0.04 - 0.004 m^\\star$$\n    b. 使用第2节中的公式计算在 $m^\\star$ 处的转换因子：\n       $$ \\text{factor} = 1 + \\frac{m^\\star}{\\rho(m^\\star)} \\frac{d\\rho}{dm}(m^\\star) - \\frac{m^\\star M_s}{1 + m^\\star M_s} $$\n       其中 $M_s = 0.1519 \\, \\mathrm{kg/mol}$。\n    c. 计算体积摩尔浓度热力学因子：\n       $$ \\Theta_c(c(m^\\star)) = \\frac{\\Theta_m(m^\\star)}{\\text{factor}} $$\n6.  **存储和格式化输出**：存储数值对 $[\\Theta_m(m^\\star), \\Theta_c(c(m^\\star))]$，四舍五入到六位小数，并对所有案例重复此过程。最终输出是这些数值对的列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the thermodynamic factor in molal and molar scales\n    from EMF data for concentrated electrolytes.\n    \"\"\"\n    # Define physical constants\n    R = 8.314462618  # J/(mol.K)\n    F = 96485.33212   # C/mol\n    T = 298.15         # K\n    M_s = 0.1519       # kg/mol for LiPF6\n\n    # Pre-calculate a constant group\n    RT_F = R * T / F  # Volts\n\n    # --- Model Definitions ---\n    def rho(m):\n        \"\"\"Solution density model in kg/L.\"\"\"\n        return 1.25 + 0.04 * m - 0.002 * m**2\n\n    def d_rho_dm(m):\n        \"\"\"Derivative of the density model w.r.t. molality.\"\"\"\n        return 0.04 - 0.004 * m\n\n    # --- Test Case Definitions ---\n    # Case 1: Ideal behavior\n    def E1(m, E0=0.15):\n        return E0 + RT_F * np.log(m)\n\n    # Case 2: Moderate nonideality\n    def E2(m, E0=0.05):\n        ln_gamma = -0.5 * np.sqrt(m) / (1.0 + 0.8 * m)\n        return E0 + RT_F * (np.log(m) + ln_gamma)\n\n    # Case 3: Stronger nonideality\n    def E3(m, E0=0.03):\n        ln_gamma = 0.2 * m / (1.0 + 0.5 * m)\n        return E0 + RT_F * (np.log(m) + ln_gamma)\n\n    test_cases = [\n        {\n            \"m_grid\": np.array([0.1, 0.2, 0.5, 1.0, 1.5]),\n            \"m_star\": 1.0,\n            \"E_func\": E1\n        },\n        {\n            \"m_grid\": np.array([0.2, 0.5, 1.0, 1.3, 1.6]),\n            \"m_star\": 1.0,\n            \"E_func\": E2\n        },\n        {\n            \"m_grid\": np.array([0.5, 1.0, 1.5, 2.0]),\n            \"m_star\": 1.5,\n            \"E_func\": E3\n        }\n    ]\n\n    # --- Main Calculation Loop ---\n    final_results = []\n    for case in test_cases:\n        m_grid = case[\"m_grid\"]\n        m_star = case[\"m_star\"]\n        E_func = case[\"E_func\"]\n\n        # Step 1: Prepare data\n        x_grid = np.log(m_grid)\n        E_grid = E_func(m_grid)\n\n        # Step 2: Numerical Differentiation of E w.r.t. ln(m)\n        dE_dlnm_grid = np.zeros_like(m_grid)\n        n_points = len(m_grid)\n\n        # First point (forward difference)\n        dE_dlnm_grid[0] = (E_grid[1] - E_grid[0]) / (x_grid[1] - x_grid[0])\n\n        # Last point (backward difference)\n        dE_dlnm_grid[-1] = (E_grid[-1] - E_grid[-2]) / (x_grid[-1] - x_grid[-2])\n\n        # Interior points (central difference)\n        for i in range(1, n_points - 1):\n            dE_dlnm_grid[i] = (E_grid[i+1] - E_grid[i-1]) / (x_grid[i+1] - x_grid[i-1])\n\n        # Step 3: Interpolate for the derivative at m_star\n        dE_dlnm_star = np.interp(m_star, m_grid, dE_dlnm_grid)\n\n        # Step 4: Calculate molal thermodynamic factor\n        theta_m = dE_dlnm_star / RT_F\n\n        # Step 5: Calculate molar thermodynamic factor\n        # Evaluate density and its derivative at m_star\n        rho_star = rho(m_star)\n        d_rho_dm_star = d_rho_dm(m_star)\n\n        # Calculate the conversion factor from ln(m) to ln(c) derivative\n        conversion_factor = (\n            1 + (m_star / rho_star) * d_rho_dm_star - (m_star * M_s) / (1 + m_star * M_s)\n        )\n\n        # Calculate theta_c\n        theta_c = theta_m / conversion_factor\n\n        # Round results\n        result_pair = [round(theta_m, 6), round(theta_c, 6)]\n        final_results.append(result_pair)\n\n    # Format final output string\n    output_str_parts = []\n    for pair in final_results:\n        output_str_parts.append(f\"[{pair[0]},{pair[1]}]\")\n    \n    print(f\"[{','.join(output_str_parts)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了获取热力学因子数据的方法后，本练习将专注于创建一个预测模型。您将对离散的 $\\Theta(c)$ 数据点进行拟合，以构建一个平滑、连续的函数，然后使用该模型预测不同浓度下的电动势，并与已知的测量值进行对比验证。这个工作流程是开发和验证仿真所需材料属性的核心。",
            "id": "3957443",
            "problem": "您正在为浓电解质（特别是 Lithium Hexafluorophosphate (LiPF$_6$)）中的热力学因子构建一个小型、独立的评估器，用于自动化电池设计和模拟。该评估器必须将一个平滑函数拟合到热力学因子数据上，然后预测不同浓度下电解质储存池之间的电动势（EMF），并将预测结果与提供的测量值进行比较。\n\n从基本原理出发。使用热力学因子的定义以及浓溶液理论中关于开路、零电流条件下电解质电势的关系式。对于二元电解质，热力学因子定义为无量纲量 $\\Theta(c)$，它调节平均离子活度系数对浓度的响应。在具有相同可逆电极的浓差电池中，电解质电势差由 $\\Theta(c)$ 沿 $\\ln c$ 的积分给出。从浓度 $c_1$ 到 $c_2$ 的目标电动势是通过对一个电势梯度进行积分得到的，该电势梯度源自离子的 Nernst 关系式和浓溶液框架。您绝不能假设任何简化的稀溶液行为或理想性；其响应必须由拟合的平滑函数 $\\hat{\\Theta}(c)$ 驱动。\n\n您的程序必须：\n- 将平滑函数 $\\hat{\\Theta}(c)$ 拟合到在 $T=298.15$ K 时，所研究溶剂中 LiPF$_6$ 的 $\\Theta(c)$ 的给定测量值上，严格使用 $\\ln \\Theta$ 作为 $\\ln c$ 的三次样条函数的平滑表示，以确保正定性和平滑性。\n- 在零电流条件下，使用拟合的 $\\hat{\\Theta}(c)$ 通过对控制积分进行数值积分来预测指定浓度对的电动势值。\n- 将预测的电动势值与提供的测量电动势值进行比较，并报告每种情况下的绝对偏差，以及整个数据集上的最大偏差。\n\n您必须使用的基本关系是：\n- 将热力学因子定义为 $\\Theta(c)$，它进入零电流下电解质电势梯度的浓溶液理论表达式，其中梯度与 $\\Theta(c)\\nabla \\ln c$ 成正比。\n- 对于开路条件下的二元 1:1 电解质，浓度为 $c_1$ 和 $c_2$ 的储存池之间的电动势为\n$$\nE(c_1,c_2) \\;=\\; \\frac{2RT}{F}\\,(1 - t_+)\\,\\int_{\\ln c_1}^{\\ln c_2} \\Theta\\!\\big(c(s)\\big)\\,ds,\n$$\n其中 $R$ 是普适气体常数，$T$ 是绝对温度，$F$ 是法拉第常数，$t_+$ 是阳离子迁移数，$s=\\ln c$ 且 $c(s)=e^s$。将 $E$ 的单位表示为伏特。\n\n使用以下数值常数和数据：\n- $R = 8.314$ J mol$^{-1}$ K$^{-1}$，$T = 298.15$ K，$F = 96485$ C mol$^{-1}$，$t_+ = 0.38$ (无量纲)。\n- 浓度单位: mol m$^{-3}$。\n- 电动势单位: 伏特 (V)。\n- 在 $T=298.15$ K 时提供的 $\\Theta(c)$ 测量值：\n    - $c=200$ mol m$^{-3}$，$\\Theta=1.16706$；\n    - $c=400$ mol m$^{-3}$，$\\Theta=1.41778$；\n    - $c=600$ mol m$^{-3}$，$\\Theta=1.72610$；\n    - $c=800$ mol m$^{-3}$，$\\Theta=2.06182$；\n    - $c=1000$ mol m$^{-3}$，$\\Theta=2.40000$；\n    - $c=1200$ mol m$^{-3}$，$\\Theta=2.72500$；\n    - $c=1400$ mol m$^{-3}$，$\\Theta=3.02800$；\n    - $c=1600$ mol m$^{-3}$，$\\Theta=3.30800$；\n    - $c=1800$ mol m$^{-3}$，$\\Theta=3.56600$。\n- 测试组浓度对及其测量的电动势（在 $T=298.15$ K 下独立计算）：\n    1. $(c_1,c_2)=(400,1200)$，测量 $E=0.068429$ V。\n    2. $(c_1,c_2)=(600,1000)$，测量 $E=0.033229$ V。\n    3. $(c_1,c_2)=(200,1800)$，测量 $E=0.137479$ V。\n    4. $(c_1,c_2)=(800,1400)$，测量 $E=0.044887$ V。\n    5. $(c_1,c_2)=(1000,1000)$，测量 $E=0.000000$ V。\n    6. $(c_1,c_2)=(1600,600)$，测量 $E=-0.075728$ V。\n\n您的算法规范：\n- 对于给定的数据点，进行变换 $x=\\ln c$ 和 $y=\\ln \\Theta$，拟合一个平滑参数为零的三次平滑样条 $y=\\hat{y}(x)$（即精确插值所提供的点），以生成一个平滑、二次连续可微的表示。然后构造 $\\hat{\\Theta}(c)=\\exp\\!\\big(\\hat{y}(\\ln c)\\big)$，该函数严格为正且平滑。\n- 对于每对 $(c_1,c_2)$，通过对下式进行数值计算来计算预测的电动势\n$$\n\\hat{E}(c_1,c_2) \\;=\\; \\frac{2RT}{F}\\,(1 - t_+)\\,\\int_{\\ln c_1}^{\\ln c_2} \\hat{\\Theta}\\!\\big(e^s\\big)\\,ds,\n$$\n使用稳健的一维求积法对 $s$ 进行积分。\n- 对每个测试用例，计算绝对偏差 $|\\,\\hat{E}(c_1,c_2) - E_{\\mathrm{meas}}(c_1,c_2)\\|$。\n- 报告所有测试用例中的最大绝对偏差。\n\n角度单位不适用。不涉及百分比。所有输出必须是以伏特为单位的浮点数。以伏特表示最终偏差，并将每个值四舍五入到六位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表。该列表包含七个条目，分别对应六个测试用例的绝对偏差，以及这些偏差中的最大值，每个值都四舍五入到六位小数。例如，输出格式必须类似于 $[\\mathrm{d}_1,\\mathrm{d}_2,\\mathrm{d}_3,\\mathrm{d}_4,\\mathrm{d}_5,\\mathrm{d}_6,\\max(\\mathrm{d}_i)]$，单位为伏特。",
            "solution": "问题陈述已经过严格验证，并被确定为有效。它在既定的电化学理论中有科学依据，在数学和算法上是适定的、客观的，并为获得唯一解提供了完整且一致的数据和约束集。\n\n该问题要求评估含有二元 1:1 电解质 LiPF$_6$ 的浓差电池中的电动势（EMF）。该解决方案基于浓溶液理论，该理论不同于理想化的稀溶液假设。该模型的核心是热力学因子 $\\Theta(c)$，它是一个无量纲量，通过将平均离子活度系数与浓度变化相关联来解释非理想相互作用。\n\n对于带有对阳离子可逆的电极的电池，在开路（零电流）条件下，两个浓度分别为 $c_1$ 和 $c_2$ 的储存池之间的电动势 $E$ 的基本关系式如下：\n$$\nE(c_1, c_2) = \\frac{2RT}{F}(1 - t_+) \\int_{\\ln c_1}^{\\ln c_2} \\Theta(c(s)) \\, ds\n$$\n其中 $s = \\ln c$。所用常数为：\n- 普适气体常数, $R = 8.314 \\, \\text{J} \\, \\text{mol}^{-1} \\, \\text{K}^{-1}$\n- 绝对温度, $T = 298.15 \\, \\text{K}$\n- 法拉第常数, $F = 96485 \\, \\text{C} \\, \\text{mol}^{-1}$\n- 阳离子迁移数, $t_+ = 0.38$\n\n前置因子 $\\frac{2RT}{F}(1 - t_+)$ 结合了热力学常数和电解质的输运性质。\n\n求解方法分三步进行：\n\n1.  **构造热力学因子函数 $\\hat{\\Theta}(c)$**\n    必须将提供的 $\\Theta(c)$ 的离散测量值转换为一个在感兴趣的浓度范围内有效的连续平滑函数 $\\hat{\\Theta}(c)$。问题指定了一种稳健的方法来确保拟合函数保持严格为正且平滑。我们首先对给定的数据点 $(c_i, \\Theta_i)$ 进行变量替换：\n    $$\n    x_i = \\ln c_i \\\\\n    y_i = \\ln \\Theta_i\n    $$\n    然后将一个三次样条函数 $\\hat{y}(x)$ 拟合到这些变换后的点 $(x_i, y_i)$ 上。具体来说，使用了一个插值三次样条，它对应于平滑参数为零的平滑样条。这确保了样条函数精确地穿过每个变换后的数据点，并且是二次连续可微的 ($C^2$)。通过反变换得到热力学因子的最终连续函数 $\\hat{\\Theta}(c)$：\n    $$\n    \\hat{\\Theta}(c) = \\exp(\\hat{y}(\\ln c))\n    $$\n    这种方法保证了对于所有 $c > 0$，都有 $\\hat{\\Theta}(c) > 0$。\n\n2.  **预测电动势 $\\hat{E}(c_1, c_2)$**\n    在建立了连续函数 $\\hat{\\Theta}(c)$ 后，通过对控制积分进行数值计算，可以为每个给定的浓度对 $(c_1, c_2)$ 计算预测的电动势 $\\hat{E}(c_1, c_2)$。将 $\\hat{\\Theta}(c)$ 代入电动势方程，并使用积分变量 $s = \\ln c$，我们得到：\n    $$\n    \\hat{E}(c_1, c_2) = \\frac{2RT}{F}(1 - t_+) \\int_{\\ln c_1}^{\\ln c_2} \\exp(\\hat{y}(s)) \\, ds\n    $$\n    该定积分使用标准的数值求积算法计算，该算法能为平滑的被积函数（例如从我们的样条模型中导出的函数）提供高精度的近似值。如果 $c_1 = c_2$，积分上下限相同，无需数值积分即可正确预测电动势为 $0 \\, \\text{V}$。如果 $c_1 > c_2$，积分将产生一个负值，从而正确地预测出负电动势。\n\n3.  **计算偏差**\n    对于每个测试用例，计算预测电动势 $\\hat{E}_i$ 与提供的测量电动势 $E_{\\text{meas},i}$ 之间的绝对偏差 $d_i$：\n    $$\n    d_i = |\\hat{E}(c_{1,i}, c_{2,i}) - E_{\\text{meas},i}|\n    $$\n    最后，找出所有测试用例中的最大绝对偏差 $\\max(d_i)$。最终输出由单个偏差列表和最大偏差组成，所有值都四舍五入到指定的精度。\n\n该实现将利用 `numpy` 库进行数值数据处理，利用 `scipy.interpolate.CubicSpline` 执行精确的插值样条拟合，并利用 `scipy.integrate.quad` 进行稳健的数值积分。",
            "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Fits a thermodynamic factor model and predicts EMF for LiPF6 electrolyte.\n    \"\"\"\n    # 1. Define constants and provided data\n    R = 8.314  # J mol^-1 K^-1\n    T = 298.15  # K\n    F = 96485  # C mol^-1\n    t_plus = 0.38  # Cation transference number (dimensionless)\n\n    # Provided thermodynamic factor data (c in mol m^-3)\n    theta_data = np.array([\n        [200, 1.16706],\n        [400, 1.41778],\n        [600, 1.72610],\n        [800, 2.06182],\n        [1000, 2.40000],\n        [1200, 2.72500],\n        [1400, 3.02800],\n        [1600, 3.30800],\n        [1800, 3.56600],\n    ])\n\n    # Test suite: (c1, c2, measured_EMF in V)\n    test_cases = [\n        (400, 1200, 0.068429),\n        (600, 1000, 0.033229),\n        (200, 1800, 0.137479),\n        (800, 1400, 0.044887),\n        (1000, 1000, 0.000000),\n        (1600, 600, -0.075728),\n    ]\n\n    # 2. Construct the thermodynamic factor function using spline interpolation\n    c_values = theta_data[:, 0]\n    theta_values = theta_data[:, 1]\n\n    # Transform data to x = ln(c) and y = ln(Theta)\n    x_data = np.log(c_values)\n    y_data = np.log(theta_values)\n\n    # Create the interpolating cubic spline for y(x) = ln(Theta(ln(c)))\n    # This is equivalent to a smoothing spline with smoothing factor s=0.\n    ln_theta_spline = CubicSpline(x_data, y_data)\n\n    # Define the integrand function for EMF calculation.\n    # The integration variable is s = ln(c).\n    # The integrand is Theta(c(s)) = exp(y(s)).\n    integrand = lambda s: np.exp(ln_theta_spline(s))\n\n    # 3. Predict EMF for each test case and calculate deviations\n    deviations = []\n    prefactor = (2 * R * T / F) * (1 - t_plus)\n\n    for c1, c2, e_meas in test_cases:\n        # Handle the trivial case to avoid unnecessary integration\n        if c1 == c2:\n            integral_val = 0.0\n        else:\n            # Numerically integrate using scipy.integrate.quad\n            # The limits are ln(c1) and ln(c2)\n            integral_val, _ = quad(integrand, np.log(c1), np.log(c2))\n\n        # Calculate predicted EMF\n        e_pred = prefactor * integral_val\n\n        # Calculate absolute deviation\n        deviation = abs(e_pred - e_meas)\n        deviations.append(deviation)\n\n    # 4. Determine the maximum deviation\n    max_deviation = max(deviations) if deviations else 0.0\n\n    # 5. Format and print the final results\n    # The final list contains the 6 deviations plus the max deviation.\n    final_results = deviations + [max_deviation]\n\n    # Format output to six decimal places as required\n    formatted_results = [f\"{res:.6f}\" for res in final_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这最后一个练习将介绍一种基于皮策（Pitzer）方程的精密、物理驱动的建模方法，该方法是电解质热力学领域的标准。您将通过加权非线性回归，将皮策参数与实验活性系数数据进行拟合，并且最关键的是，将实验不确定性传播到您计算的热力学因子中。这个练习代表了一个完整的科研级别工作流程，用于开发具有量化置信度的高保真热力学模型。",
            "id": "3957461",
            "problem": "您的任务是设计一个程序，该程序针对固定温度下水溶液中的对称 $1:1$ 型电解质，从实验平均活度系数数据中推断 Pitzer 相互作用参数，然后将参数不确定性传播到热力学因子。该程序必须实现加权非线性回归并执行线性不确定性传播。\n\n基本原理和定义：\n\n- 在 Pitzer 框架下（基于质量摩尔浓度），对称 $1:1$ 型电解质的平均活度系数 $\\gamma_{\\pm}(m)$ 使用以下经过充分检验的表达式进行建模：\n  $$\\ln \\gamma_{\\pm}(m) = -A_{\\gamma} \\frac{\\sqrt{m}}{1 + b \\sqrt{m}} + 2 m \\left( \\beta^{(0)} + \\beta^{(1)} \\, g(\\alpha \\sqrt{m}) \\right) + 2 m^{2} C_{\\phi},$$\n  其中，$m$ 是质量摩尔浓度，单位为 $\\mathrm{mol}\\,\\mathrm{kg}^{-1}$，$A_{\\gamma}$、$b$ 和 $\\alpha$ 是水在 $T = 298.15\\,\\mathrm{K}$ 时的已知常数，而 $(\\beta^{(0)}, \\beta^{(1)}, C_{\\phi})$ 是待从数据中回归的 Pitzer 参数。\n- Brønsted 函数 $g(x)$ 定义为：\n  $$g(x) = \\frac{1 - e^{-x}}{x}.$$\n- 对于对称 $1:1$ 型电解质，离子强度 $I$ 等于质量摩尔浓度 $m$，因此 $I = m$。\n- 热力学因子 $\\Theta(m)$ 由核心热力学关系定义：\n  $$\\Theta(m) = 1 + m \\, \\frac{d \\ln \\gamma_{\\pm}(m)}{d m},$$\n  其中 $\\Theta(m)$ 是无量纲的。\n\n使用的水在 $T = 298.15\\,\\mathrm{K}$ 时的常数：\n- $A_{\\gamma} = 1.2$（无量纲，自然对数底），\n- $b = 1.2$，单位为 $\\mathrm{kg}^{1/2}\\,\\mathrm{mol}^{-1/2}$，\n- $\\alpha = 2.0$，单位为 $\\mathrm{kg}^{1/2}\\,\\mathrm{mol}^{-1/2}$。\n\n加权非线性回归规范：\n- 给定实验数据对 $\\{ m_i, \\gamma_{\\pm,i}, \\sigma_i \\}$（$i = 1, \\dots, N$），其中 $\\sigma_i$ 表示 $\\gamma_{\\pm,i}$ 的标准不确定度，通过最小化加权平方和来估计 $(\\beta^{(0)}, \\beta^{(1)}, C_{\\phi})$：\n  $$\\chi^2 = \\sum_{i=1}^{N} \\left( \\frac{\\gamma_{\\pm}^{\\text{model}}(m_i; \\beta^{(0)}, \\beta^{(1)}, C_{\\phi}) - \\gamma_{\\pm,i}}{\\sigma_i} \\right)^2,$$\n  其中 $\\gamma_{\\pm}^{\\text{model}}(m) = \\exp\\left( \\ln \\gamma_{\\pm}(m) \\right)$。\n- 使用残差在解处的雅可比矩阵和标准加权最小二乘线性化方法计算参数协方差矩阵 $\\Sigma$：\n  $$\\Sigma = s^2 \\left( J^{\\top} J \\right)^{-1}, \\quad s^2 = \\frac{\\chi^2}{N - P},$$\n  其中 $P = 3$ 是参数数量，$J$ 是残差向量关于参数的雅可比矩阵。\n\n对 $\\Theta(m)$ 的不确定性传播：\n- 使用线性误差分析，通过以下方式将参数不确定性传播到指定 $m^\\star$ 处的 $\\Theta(m)$：\n  $$\\mathrm{Var}\\left[ \\Theta(m^\\star) \\right] = \\mathbf{J}_{\\Theta}(m^\\star) \\, \\Sigma \\, \\mathbf{J}_{\\Theta}(m^\\star)^{\\top},$$\n  其中 $\\mathbf{J}_{\\Theta}(m^\\star) = \\left[ \\frac{\\partial \\Theta}{\\partial \\beta^{(0)}}, \\frac{\\partial \\Theta}{\\partial \\beta^{(1)}}, \\frac{\\partial \\Theta}{\\partial C_{\\phi}} \\right]_{m = m^\\star}$ 是 $\\Theta$ 关于参数的梯度，在拟合参数值和 $m = m^\\star$ 处计算。报告传播的标准不确定度 $u_{\\Theta}(m^\\star) = \\sqrt{\\mathrm{Var}\\left[ \\Theta(m^\\star) \\right]}$。\n\n数据和测试套件：\n- 情况 1（理想路径）：对称 $1:1$ 型电解质的实验数据 $\\{ m_i, \\gamma_{\\pm,i}, \\sigma_i \\}$\n  - $m$ 单位 $\\mathrm{mol}\\,\\mathrm{kg}^{-1}$: $[0.05, 0.10, 0.50, 1.00, 2.00]$,\n  - $\\gamma_{\\pm}$ (无量纲): $[0.835, 0.803, 0.780, 0.846, 1.028]$,\n  - $\\sigma$ (无量纲): $[0.005, 0.005, 0.006, 0.006, 0.010]$,\n  - 目标 $m^{\\star} = 0.20$，单位 $\\mathrm{mol}\\,\\mathrm{kg}^{-1}$。\n- 情况 2（较高 $m$ 处的边界覆盖）：实验数据 $\\{ m_i, \\gamma_{\\pm,i}, \\sigma_i \\}$\n  - $m$: $[0.05, 0.10, 0.50, 1.00, 2.00]$,\n  - $\\gamma_{\\pm}$: $[0.832, 0.799, 0.776, 0.840, 1.036]$,\n  - $\\sigma$: $[0.005, 0.005, 0.006, 0.006, 0.010]$,\n  - 目标 $m^{\\star} = 1.50$，单位 $\\mathrm{mol}\\,\\mathrm{kg}^{-1}$。\n- 情况 3（具有更强短程相互作用的边缘情况）：实验数据 $\\{ m_i, \\gamma_{\\pm,i}, \\sigma_i \\}$\n  - $m$: $[0.05, 0.10, 0.50, 1.00, 2.00]$,\n  - $\\gamma_{\\pm}$: $[0.837, 0.806, 0.789, 0.850, 1.016]$,\n  - $\\sigma$: $[0.005, 0.005, 0.006, 0.006, 0.010]$,\n  - 目标 $m^{\\star} = 0.80$，单位 $\\mathrm{mol}\\,\\mathrm{kg}^{-1}$。\n\n程序要求和输出：\n- 实现上述指定的加权非线性回归和线性不确定性传播。\n- 为每种情况计算数据对 $(\\Theta(m^\\star), u_{\\Theta}(m^\\star))$。这两个量都是无量纲的。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\Theta_1, u_{\\Theta,1}, \\Theta_2, u_{\\Theta,2}, \\Theta_3, u_{\\Theta,3}]$，每个值都四舍五入到六位小数，不显示单位。",
            "solution": "该问题要求实现一个数值程序，用于从对称 $1:1$ 型电解质的实验平均活度系数数据中推断 Pitzer 相互作用参数。在此回归之后，必须将估计参数中的不确定性传播到热力学因子，这是电解质热力学中的一个关键量。该过程涉及用于参数估计的加权非线性最小二乘法和用于不确定性分析的线性误差传播法。\n\n该模型的基础是 Pitzer 方程，它描述了在固定温度（$T = 298.15\\,\\mathrm{K}$）下，对称 $1:1$ 型电解质的平均质量摩尔活度系数 $\\gamma_{\\pm}$ 的自然对数。该方程如下：\n$$\n\\ln \\gamma_{\\pm}(m) = -A_{\\gamma} \\frac{\\sqrt{m}}{1 + b \\sqrt{m}} + 2 m \\left( \\beta^{(0)} + \\beta^{(1)} \\, g(\\alpha \\sqrt{m}) \\right) + 2 m^{2} C_{\\phi}\n$$\n这里，$m$ 是电解质的质量摩尔浓度，单位为 $\\mathrm{mol}\\,\\mathrm{kg}^{-1}$。参数 $A_{\\gamma} = 1.2$、$b = 1.2\\,\\mathrm{kg}^{1/2}\\,\\mathrm{mol}^{-1/2}$ 和 $\\alpha = 2.0\\,\\mathrm{kg}^{1/2}\\,\\mathrm{mol}^{-1/2}$ 是给定的常数。函数 $g(x)$ 是 Brønsted 函数，定义为：\n$$\ng(x) = \\frac{1 - e^{-x}}{x}\n$$\n通过回归确定的参数是 Pitzer 相互作用系数：$\\boldsymbol{p} = [\\beta^{(0)}, \\beta^{(1)}, C_{\\phi}]^{\\top}$。\n\n**1. 加权非线性回归**\n\n给定一组 $N$ 个实验数据点 $\\{ m_i, \\gamma_{\\pm,i}, \\sigma_i \\}$，其中 $\\sigma_i$ 是测量的活度系数 $\\gamma_{\\pm,i}$ 的标准不确定度，参数 $\\boldsymbol{p}$ 通过最小化加权残差平方和 $\\chi^2$ 来估计：\n$$\n\\chi^2(\\boldsymbol{p}) = \\sum_{i=1}^{N} \\left( \\frac{\\gamma_{\\pm}^{\\text{model}}(m_i; \\boldsymbol{p}) - \\gamma_{\\pm,i}}{\\sigma_i} \\right)^2\n$$\n其中 $\\gamma_{\\pm}^{\\text{model}}(m; \\boldsymbol{p}) = \\exp(\\ln \\gamma_{\\pm}(m; \\boldsymbol{p}))$ 是 Pitzer 模型预测的值。这是一个非线性最小二乘问题，可以使用诸如置信域反射法 (Trust Region Reflective method) 之类的迭代算法进行数值求解。此类算法通常需要残差向量关于参数的雅可比矩阵。残差向量的第 $i$ 个分量是 $r_i(\\boldsymbol{p}) = [\\gamma_{\\pm}^{\\text{model}}(m_i; \\boldsymbol{p}) - \\gamma_{\\pm,i}] / \\sigma_i$。\n\n雅可比矩阵 $J$ 的元素为 $J_{ij} = \\partial r_i / \\partial p_j$。使用链式法则：\n$$\n\\frac{\\partial r_i}{\\partial p_j} = \\frac{1}{\\sigma_i} \\frac{\\partial \\gamma_{\\pm}^{\\text{model}}(m_i; \\boldsymbol{p})}{\\partial p_j} = \\frac{1}{\\sigma_i} \\gamma_{\\pm}^{\\text{model}}(m_i; \\boldsymbol{p}) \\frac{\\partial \\ln \\gamma_{\\pm}(m_i; \\boldsymbol{p})}{\\partial p_j}\n$$\n$\\ln \\gamma_{\\pm}$ 关于参数的偏导数是：\n$$\n\\frac{\\partial \\ln \\gamma_{\\pm}}{\\partial \\beta^{(0)}} = 2m\n$$\n$$\n\\frac{\\partial \\ln \\gamma_{\\pm}}{\\partial \\beta^{(1)}} = 2m \\, g(\\alpha \\sqrt{m})\n$$\n$$\n\\frac{\\partial \\ln \\gamma_{\\pm}}{\\partial C_{\\phi}} = 2m^2\n$$\n这些表达式允许解析地构建优化算法所需的雅可比矩阵。\n\n**2. 参数协方差矩阵**\n\n一旦找到最小化 $\\chi^2$ 的最优参数 $\\hat{\\boldsymbol{p}}$，它们的统计不确定性就由协方差矩阵 $\\Sigma$ 描述。在模型在解附近呈线性的假设下，协方差矩阵估计为：\n$$\n\\Sigma = s^2 (J^{\\top} J)^{-1}\n$$\n其中 $J$ 是在最优参数 $\\hat{\\boldsymbol{p}}$ 处计算的雅可比矩阵。量 $s^2$ 是拟合残差的方差，通常估计为约化卡方 (reduced chi-squared)：\n$$\ns^2 = \\frac{\\chi^2(\\hat{\\boldsymbol{p}})}{N - P}\n$$\n其中 $N$ 是数据点数量，$P=3$ 是拟合参数的数量。\n\n**3. 热力学因子和不确定性传播**\n\n热力学因子 $\\Theta(m)$ 是溶液非理想性梯度的一种度量，定义为：\n$$\n\\Theta(m) = 1 + m \\frac{d \\ln \\gamma_{\\pm}(m)}{d m}\n$$\n为了计算 $\\Theta(m)$，我们必须首先求出 $\\ln \\gamma_{\\pm}(m)$ 关于质量摩尔浓度 $m$ 的导数：\n$$\n\\frac{d \\ln \\gamma_{\\pm}}{d m} = \\frac{d}{dm} \\left( -A_{\\gamma} \\frac{\\sqrt{m}}{1 + b \\sqrt{m}} \\right) + \\frac{d}{dm} \\left( 2 m \\beta^{(0)} \\right) + \\frac{d}{dm} \\left( 2 m \\beta^{(1)} g(\\alpha \\sqrt{m}) \\right) + \\frac{d}{dm} \\left( 2 m^2 C_{\\phi} \\right)\n$$\n逐项计算每个导数可得：\n$$\n\\frac{d \\ln \\gamma_{\\pm}}{d m} = -\\frac{A_{\\gamma}}{2\\sqrt{m}(1 + b \\sqrt{m})^2} + 2\\beta^{(0)} + \\beta^{(1)} \\left( g(\\alpha\\sqrt{m}) + e^{-\\alpha\\sqrt{m}} \\right) + 4m C_{\\phi}\n$$\n将此代入 $\\Theta(m)$ 的定义，得到完整表达式：\n$$\n\\Theta(m; \\boldsymbol{p}) = 1 - \\frac{A_{\\gamma}\\sqrt{m}}{2(1+b\\sqrt{m})^2} + 2m\\beta^{(0)} + m\\beta^{(1)}\\left(g(\\alpha\\sqrt{m}) + e^{-\\alpha\\sqrt{m}}\\right) + 4m^2 C_{\\phi}\n$$\n拟合参数 $\\boldsymbol{p}$ 中的不确定性会传播到 $\\Theta(m)$ 的计算值中。使用一阶泰勒展开（线性误差传播），在特定质量摩尔浓度 $m^\\star$ 下 $\\Theta$ 的方差可以近似为：\n$$\n\\mathrm{Var}\\left[ \\Theta(m^\\star) \\right] = \\mathbf{J}_{\\Theta}(m^\\star) \\, \\Sigma \\, \\mathbf{J}_{\\Theta}(m^\\star)^{\\top}\n$$\n这里，$\\mathbf{J}_{\\Theta}(m^\\star)$ 是 $\\Theta$ 关于参数的梯度（一个行向量），在 $\\hat{\\boldsymbol{p}}$ 和 $m=m^\\star$ 处计算：\n$$\n\\mathbf{J}_{\\Theta}(m^\\star) = \\left[ \\frac{\\partial \\Theta}{\\partial \\beta^{(0)}}, \\frac{\\partial \\Theta}{\\partial \\beta^{(1)}}, \\frac{\\partial \\Theta}{\\partial C_{\\phi}} \\right]_{m=m^\\star}\n$$\n偏导数是：\n$$\n\\frac{\\partial \\Theta}{\\partial \\beta^{(0)}} = 2m\n$$\n$$\n\\frac{\\partial \\Theta}{\\partial \\beta^{(1)}} = m \\left( g(\\alpha\\sqrt{m}) + e^{-\\alpha\\sqrt{m}} \\right)\n$$\n$$\n\\frac{\\partial \\Theta}{\\partial C_{\\phi}} = 4m^2\n$$\n那么 $\\Theta(m^\\star)$ 的标准不确定度为 $u_{\\Theta}(m^\\star) = \\sqrt{\\mathrm{Var}\\left[ \\Theta(m^\\star) \\right]}$。\n\n**4. 算法实现**\n\n对于提供的每种情况：\n1.  定义实验数据 $\\{ m_i, \\gamma_{\\pm,i}, \\sigma_i \\}$ 和目标质量摩尔浓度 $m^\\star$。\n2.  使用非线性最小二乘求解器（`scipy.optimize.least_squares`）通过最小化 $\\chi^2$ 来找到最优参数 $\\hat{\\boldsymbol{p}} = [\\hat{\\beta}^{(0)}, \\hat{\\beta}^{(1)}, \\hat{C}_{\\phi}]$。参数的初始猜测值使用 $[0,0,0]$。为了准确性和效率，向求解器提供了解析雅可比矩阵。\n3.  根据解处的雅可比矩阵和约化卡方值计算参数协方差矩阵 $\\Sigma$。\n4.  使用拟合参数 $\\hat{\\boldsymbol{p}}$ 计算热力学因子 $\\Theta(m^\\star)$ 的值。\n5.  计算梯度向量 $\\mathbf{J}_{\\Theta}(m^\\star)$。\n6.  使用线性误差传播公式计算方差 $\\mathrm{Var}[\\Theta(m^\\star)]$ 和标准不确定度 $u_{\\Theta}(m^\\star)$。\n7.  存储数据对 $(\\Theta(m^\\star), u_{\\Theta}(m^\\star))$。\n\n对所有三种测试情况重复此过程，并按要求格式化最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\ndef solve():\n    \"\"\"\n    Solves the Pitzer parameter regression and uncertainty propagation problem.\n    \"\"\"\n    \n    # Constants for water at T = 298.15 K\n    A_gamma = 1.2  # Dimensionless, natural-logarithm base\n    b = 1.2        # kg^(1/2) mol^(-1/2)\n    alpha = 2.0    # kg^(1/2) mol^(-1/2)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"m_data\": np.array([0.05, 0.10, 0.50, 1.00, 2.00]),\n            \"gamma_data\": np.array([0.835, 0.803, 0.780, 0.846, 1.028]),\n            \"sigma_data\": np.array([0.005, 0.005, 0.006, 0.006, 0.010]),\n            \"m_star\": 0.20\n        },\n        {\n            \"m_data\": np.array([0.05, 0.10, 0.50, 1.00, 2.00]),\n            \"gamma_data\": np.array([0.832, 0.799, 0.776, 0.840, 1.036]),\n            \"sigma_data\": np.array([0.005, 0.005, 0.006, 0.006, 0.010]),\n            \"m_star\": 1.50\n        },\n        {\n            \"m_data\": np.array([0.05, 0.10, 0.50, 1.00, 2.00]),\n            \"gamma_data\": np.array([0.837, 0.806, 0.789, 0.850, 1.016]),\n            \"sigma_data\": np.array([0.005, 0.005, 0.006, 0.006, 0.010]),\n            \"m_star\": 0.80\n        }\n    ]\n\n    results = []\n    \n    # --- Model Functions ---\n\n    def g_func(x):\n        \"\"\"Brønsted function g(x) = (1 - exp(-x))/x.\"\"\"\n        # Note: In this problem, m > 0, so x = alpha * sqrt(m) > 0.\n        # No division by zero will occur.\n        return (1.0 - np.exp(-x)) / x\n\n    def ln_gamma_pm_model(m, params):\n        \"\"\"Pitzer model for ln(gamma_pm).\"\"\"\n        beta0, beta1, Cphi = params\n        sqrt_m = np.sqrt(m)\n        term1 = -A_gamma * sqrt_m / (1.0 + b * sqrt_m)\n        term2 = 2.0 * m * (beta0 + beta1 * g_func(alpha * sqrt_m))\n        term3 = 2.0 * m**2 * Cphi\n        return term1 + term2 + term3\n\n    def gamma_pm_model(m, params):\n        \"\"\"Pitzer model for gamma_pm.\"\"\"\n        return np.exp(ln_gamma_pm_model(m, params))\n\n    def residuals(params, m_data, gamma_data, sigma_data):\n        \"\"\"Weighted residuals for least-squares fitting.\"\"\"\n        model_gamma = gamma_pm_model(m_data, params)\n        return (model_gamma - gamma_data) / sigma_data\n\n    def jacobian_residuals(params, m_data, gamma_data, sigma_data):\n        \"\"\"Jacobian of the residuals w.r.t. parameters.\"\"\"\n        N = len(m_data)\n        P = len(params)\n        J = np.zeros((N, P))\n        \n        model_gamma_vals = gamma_pm_model(m_data, params)\n        \n        # Derivatives of ln(gamma_pm) w.r.t. parameters\n        d_ln_gamma_d_beta0 = 2.0 * m_data\n        d_ln_gamma_d_beta1 = 2.0 * m_data * g_func(alpha * np.sqrt(m_data))\n        d_ln_gamma_d_Cphi = 2.0 * m_data**2\n\n        # Jacobian columns\n        J[:, 0] = (1.0 / sigma_data) * model_gamma_vals * d_ln_gamma_d_beta0\n        J[:, 1] = (1.0 / sigma_data) * model_gamma_vals * d_ln_gamma_d_beta1\n        J[:, 2] = (1.0 / sigma_data) * model_gamma_vals * d_ln_gamma_d_Cphi\n        \n        return J\n\n    def theta_model(m, params):\n        \"\"\"Thermodynamic factor Theta(m).\"\"\"\n        beta0, beta1, Cphi = params\n        sqrt_m = np.sqrt(m)\n        x = alpha * sqrt_m\n\n        term1 = -A_gamma * sqrt_m / (2.0 * (1.0 + b * sqrt_m)**2)\n        term2 = 2.0 * m * beta0\n        term3 = m * beta1 * (g_func(x) + np.exp(-x))\n        term4 = 4.0 * m**2 * Cphi\n\n        return 1.0 + term1 + term2 + term3 + term4\n\n    def grad_theta(m):\n        \"\"\"Gradient of Theta(m) w.r.t. parameters.\"\"\"\n        sqrt_m = np.sqrt(m)\n        x = alpha * sqrt_m\n\n        d_theta_d_beta0 = 2.0 * m\n        d_theta_d_beta1 = m * (g_func(x) + np.exp(-x))\n        d_theta_d_Cphi = 4.0 * m**2\n        \n        return np.array([d_theta_d_beta0, d_theta_d_beta1, d_theta_d_Cphi])\n\n    # --- Main Loop ---\n    for case in test_cases:\n        m_data = case[\"m_data\"]\n        gamma_data = case[\"gamma_data\"]\n        sigma_data = case[\"sigma_data\"]\n        m_star = case[\"m_star\"]\n\n        # 1. Perform weighted nonlinear regression\n        p0 = [0.0, 0.0, 0.0]  # Initial guess for parameters\n        ls_result = least_squares(\n            residuals,\n            p0,\n            jac=jacobian_residuals,\n            args=(m_data, gamma_data, sigma_data),\n            method='trf'\n        )\n        \n        p_fit = ls_result.x\n        \n        # 2. Compute parameter covariance matrix\n        J = ls_result.jac\n        N = len(m_data)\n        P = len(p_fit)\n        \n        # The cost is 0.5 * sum(residual^2). chi2 is sum(residual^2).\n        chi2 = 2.0 * ls_result.cost\n        s_squared = chi2 / (N - P)\n        \n        try:\n            cov_matrix = s_squared * np.linalg.inv(J.T @ J)\n        except np.linalg.LinAlgError:\n            # In case of singularity, use pseudo-inverse\n            cov_matrix = s_squared * np.linalg.pinv(J.T @ J)\n\n        # 3. Compute Theta and its uncertainty\n        theta_val = theta_model(m_star, p_fit)\n        \n        # 4. Propagate uncertainty\n        J_theta = grad_theta(m_star)\n        var_theta = J_theta @ cov_matrix @ J_theta.T\n        u_theta = np.sqrt(var_theta)\n\n        results.extend([theta_val, u_theta])\n        \n    # Final print statement in the exact required format.\n    # Format to six decimal places.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```"
        }
    ]
}