{
    "hands_on_practices": [
        {
            "introduction": "将一个物理问题从连续的偏微分方程（PDE）转化为离散的代数方程组，是进行数值模拟的第一个核心步骤。本练习将引导您完成这一完整过程，从一个典型的稳态扩散问题出发，学习如何处理狄利克雷（Dirichlet）和诺伊曼（Neumann）混合边界条件。通过这个实践，您不仅将掌握有限差分法的基本应用，还将推导并实现求解由此产生的三对角线线性系统的关键高效算法——托马斯算法（Thomas algorithm），这是电池建模等领域一项不可或缺的基础技能 。",
            "id": "3914374",
            "problem": "考虑在自动化电池设计模拟中，稳态锂离子在厚度为 $L$ 的一维隔膜的电解质相中输运。在扩散系数 $D$ 恒定且隔膜内部无体积消耗的情况下，稳态锂离子浓度 $c(x)$ 满足守恒定律和 Fick 第一定律：$\\frac{d}{dx}\\left( -D \\frac{dc}{dx} \\right) = 0$ 和 $j = -D \\frac{dc}{dx}$，其中 $j$ 是右边界 $x=L$ 处的恒定摩尔通量。使用包含 $N$ 个内部节点的均匀网格对区域 $[0,L]$ 进行离散化，网格间距为 $h = \\frac{L}{N+1}$，在 $x=0$ 处设置左狄利克雷边界，其值为 $c(0)=c_{0}$，并在右边界施加诺伊曼边界条件 $-D \\frac{dc}{dx}\\big|_{x=L} = j$。对内部节点使用二阶中心差分，并通过在 $x=L+h$ 处设置一个虚拟节点，使用与诺伊曼边界一致的单边有限差分。\n\n1. 从上述定律和离散化得到的有限差分方程出发，写出关于未知数 $c_{1}, c_{2}, \\dots, c_{N}$ 的三对角线性系统。该系统应表示为标准形式 $a_{i} c_{i-1} + b_{i} c_{i} + \\gamma_{i} c_{i+1} = d_{i}$，并约定在通过诺伊曼边界条件消除虚拟节点后，$a_{1}=0$ 和 $\\gamma_{N}=0$。然后，从基本原理出发（通过将高斯消元法应用于三对角矩阵），推导 Thomas 算法，并以闭式形式给出这类一般三对角系统的前向消元和回代步骤。\n\n2. 将您推导的 Thomas 算法应用于具体的隔膜案例，参数为 $N=5$，$L=25 \\times 10^{-6}\\,\\text{m}$，$D=2.0 \\times 10^{-10}\\,\\text{m}^{2}\\,\\text{s}^{-1}$，$c_{0}=1000\\,\\text{mol}\\,\\text{m}^{-3}$，以及 $j=1.0 \\times 10^{-4}\\,\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1}$。计算第三个内部节点处的浓度 $c_{3}$。\n\n将最终数值答案四舍五入至四位有效数字。浓度单位以 $\\text{mol}\\,\\text{m}^{-3}$ 表示。",
            "solution": "### 第 1 部分：线性系统和 Thomas 算法的推导\n\n在扩散系数 $D$ 恒定的情况下，控制方程简化为一维拉普拉斯方程：\n$$ \\frac{d^2c}{dx^2} = 0 $$\n区域 $[0, L]$ 被离散化为节点 $x_i = i h$（$i=0, 1, \\dots, N, N+1$），其中 $h = \\frac{L}{N+1}$，$x_0=0$ 且 $x_{N+1}=L$。未知数是内部节点处的浓度，$c_i = c(x_i)$（$i=1, 2, \\dots, N$）。$c_0 = c(0)$ 的值由狄利克雷边界条件给出。\n\n**内部节点的离散化 ($i=1, \\dots, N-1$)**\n对内部节点 $x_i$ 处的二阶导数使用二阶中心差分近似：\n$$ \\frac{d^2c}{dx^2}\\bigg|_{x_i} \\approx \\frac{c_{i-1} - 2c_i + c_{i+1}}{h^2} $$\n将此代入控制方程得到：\n$$ \\frac{c_{i-1} - 2c_i + c_{i+1}}{h^2} = 0 \\implies c_{i-1} - 2c_i + c_{i+1} = 0 $$\n对于 $i=1$，我们使用已知的边界值 $c_0$：\n$$ c_0 - 2c_1 + c_2 = 0 \\implies -2c_1 + c_2 = -c_0 $$\n\n**右边界的离散化 (节点 $N$)**\n对于节点 $i=N$，中心差分格式涉及未知的 $c_{N+1} = c(L)$。我们必须通过在 $x_{N+2} = L+h = x_{N+1}+h$ 处设置一个虚拟节点来使用诺伊曼边界条件 $-D \\frac{dc}{dx}\\big|_{x=L} = j$。\n边界节点 $x_{N+1} = L$ 处导数的二阶中心差分为：\n$$ \\frac{dc}{dx}\\bigg|_{x_{N+1}} \\approx \\frac{c_{N+2} - c_N}{2h} $$\n应用诺伊曼条件：\n$$ -D \\frac{c_{N+2} - c_N}{2h} = j \\implies c_{N+2} = c_N - \\frac{2hj}{D} $$\n为了消除虚拟节点值 $c_{N+2}$，我们假设控制偏微分方程在边界节点 $x_{N+1}$ 处也成立：\n$$ \\frac{d^2c}{dx^2}\\bigg|_{x_{N+1}} \\approx \\frac{c_N - 2c_{N+1} + c_{N+2}}{h^2} = 0 \\implies c_N - 2c_{N+1} + c_{N+2} = 0 $$\n代入 $c_{N+2}$ 的表达式：\n$$ c_N - 2c_{N+1} + \\left(c_N - \\frac{2hj}{D}\\right) = 0 \\implies 2c_N - 2c_{N+1} = \\frac{2hj}{D} \\implies c_{N+1} = c_N - \\frac{hj}{D} $$\n现在，我们将 $c_{N+1}$ 的这个表达式代入节点 $i=N$ 处的离散化偏微分方程中：\n$$ c_{N-1} - 2c_N + c_{N+1} = 0 \\implies c_{N-1} - 2c_N + \\left(c_N - \\frac{hj}{D}\\right) = 0 $$\n$$ c_{N-1} - c_N = \\frac{hj}{D} $$\n\n**三对角线性系统**\n关于未知数 $c_1, \\dots, c_N$ 的 $N$ 个线性方程组为：\n$$ -2c_1 + c_2 = -c_0 \\quad (i=1) $$\n$$ c_{i-1} - 2c_i + c_{i+1} = 0 \\quad (i=2, \\dots, N-1) $$\n$$ c_{N-1} - c_N = \\frac{hj}{D} \\quad (i=N) $$\n该系统可以写成 $a_{i} c_{i-1} + b_{i} c_{i} + \\gamma_{i} c_{i+1} = d_{i}$ 的形式，其中 $\\gamma_i$ 是 $c_{i+1}$ 的系数。系数为：\n- 对于 $i=1$：$a_1 = 0$，$b_1 = -2$，$\\gamma_1 = 1$，$d_1 = -c_0$。\n- 对于 $i=2, \\dots, N-1$：$a_i = 1$，$b_i = -2$，$\\gamma_i = 1$，$d_i = 0$。\n- 对于 $i=N$：$a_N = 1$，$b_N = -1$，$\\gamma_N = 0$，$d_N = \\frac{hj}{D}$。\n条件 $a_1=0$ 和 $\\gamma_N=0$ 得到满足。\n\n**Thomas 算法的推导**\nThomas 算法是高斯消元法的一种特殊形式，用于求解一般三对角系统 $a_{i} c_{i-1} + b_{i} c_{i} + \\gamma_{i} c_{i+1} = d_{i}$（$i=1, \\dots, N$），其中 $a_1=0$ 和 $\\gamma_N=0$。\n\n**前向消元：** 目标是通过消除次对角线元素 $a_i$，将系统转换为上双对角形式。我们寻求一个形式为 $c_i + \\gamma'_i c_{i+1} = d'_i$ 的转换后系统。\n对于 $i=1$，方程为 $b_1 c_1 + \\gamma_1 c_2 = d_1$。两边除以 $b_1$ 得：\n$c_1 + \\frac{\\gamma_1}{b_1} c_2 = \\frac{d_1}{b_1}$。\n因此，我们定义 $\\gamma'_1 = \\frac{\\gamma_1}{b_1}$ 和 $d'_1 = \\frac{d_1}{b_1}$。\n\n对于 $i > 1$，假设我们有上一步得到的转换后方程：$c_{i-1} + \\gamma'_{i-1} c_i = d'_{i-1}$，可以改写为 $c_{i-1} = d'_{i-1} - \\gamma'_{i-1} c_i$。\n第 $i$ 行的原始方程是 $a_i c_{i-1} + b_i c_i + \\gamma_i c_{i+1} = d_i$。\n代入 $c_{i-1}$ 的表达式：\n$a_i (d'_{i-1} - \\gamma'_{i-1} c_i) + b_i c_i + \\gamma_i c_{i+1} = d_i$\n对含 $c_i$ 的项进行重排：\n$(b_i - a_i \\gamma'_{i-1}) c_i + \\gamma_i c_{i+1} = d_i - a_i d'_{i-1}$\n两边除以 $c_i$ 的新系数：\n$c_i + \\frac{\\gamma_i}{b_i - a_i \\gamma'_{i-1}} c_{i+1} = \\frac{d_i - a_i d'_{i-1}}{b_i - a_i \\gamma'_{i-1}}$\n这给出了修正系数的递推关系：\n$\\gamma'_i = \\frac{\\gamma_i}{b_i - a_i \\gamma'_{i-1}}$ 和 $d'_i = \\frac{d_i - a_i d'_{i-1}}{b_i - a_i \\gamma'_{i-1}}$（对于 $i > 1$）。\n\n前向消元过程如下：\n1. $\\gamma'_1 = \\frac{\\gamma_1}{b_1}$; $d'_1 = \\frac{d_1}{b_1}$。\n2. 对于 $i=2, \\dots, N-1$：\n   $\\gamma'_i = \\frac{\\gamma_i}{b_i - a_i \\gamma'_{i-1}}$\n   $d'_i = \\frac{d_i - a_i d'_{i-1}}{b_i - a_i \\gamma'_{i-1}}$\n\n**回代：** 前向消元后，最后一个方程只涉及 $c_N$。在 $i=N$ 时，$\\gamma_N=0$，所以 $\\gamma'_N=0$。转换后的方程是 $c_N = d'_N$。$i=N$ 的原始方程是 $a_N c_{N-1} + b_N c_N = d_N$。使用 $c_{N-1} = d'_{N-1} - \\gamma'_{N-1} c_N$ 的表达式：\n$a_N (d'_{N-1} - \\gamma'_{N-1} c_N) + b_N c_N = d_N$\n$(b_N - a_N \\gamma'_{N-1}) c_N = d_N - a_N d'_{N-1}$\n$c_N = \\frac{d_N - a_N d'_{N-1}}{b_N - a_N \\gamma'_{N-1}}$。\n一旦 $c_N$ 已知，我们就可以通过向后代入转换后的方程 $c_i = d'_i - \\gamma'_i c_{i+1}$ 来找到其他变量。\n\n回代过程如下：\n1. $c_N = \\frac{d_N - a_N d'_{N-1}}{b_N - a_N \\gamma'_{N-1}}$。\n2. 对于 $i = N-1, N-2, \\dots, 1$：\n   $c_i = d'_i - \\gamma'_i c_{i+1}$。\n\n### 第 2 部分：Thomas 算法的应用\n\n我们将推导出的算法应用于给定的参数：$N=5$，$L=25 \\times 10^{-6}\\,\\text{m}$，$D=2.0 \\times 10^{-10}\\,\\text{m}^{2}\\,\\text{s}^{-1}$，$c_{0}=1000\\,\\text{mol}\\,\\text{m}^{-3}$，以及 $j=1.0 \\times 10^{-4}\\,\\text{mol}\\,\\text{m}^{-2}\\,\\text{s}^{-1}$。\n\n首先，计算网格间距 $h$：\n$$ h = \\frac{L}{N+1} = \\frac{25 \\times 10^{-6}}{5+1} = \\frac{25}{6} \\times 10^{-6}\\,\\text{m} $$\n$5 \\times 5$ 线性系统的系数为：\n- $i=1$: $a_1=0, b_1=-2, \\gamma_1=1, d_1=-c_0 = -1000$。\n- $i=2,3,4$: $a_i=1, b_i=-2, \\gamma_i=1, d_i=0$。\n- $i=5$: $a_5=1, b_5=-1, \\gamma_5=0, d_5=\\frac{hj}{D} = \\frac{(\\frac{25}{6} \\times 10^{-6})(1.0 \\times 10^{-4})}{2.0 \\times 10^{-10}} = \\frac{25 \\times 10^{-10}}{12 \\times 10^{-10}} = \\frac{25}{12}$。\n\n**前向消元：**\n- $i=1$:\n   $\\gamma'_1 = \\frac{\\gamma_1}{b_1} = \\frac{1}{-2} = -0.5$\n   $d'_1 = \\frac{d_1}{b_1} = \\frac{-1000}{-2} = 500$\n- $i=2$:\n   $\\gamma'_2 = \\frac{\\gamma_2}{b_2 - a_2 \\gamma'_1} = \\frac{1}{-2 - 1(-0.5)} = \\frac{1}{-1.5} = -\\frac{2}{3}$\n   $d'_2 = \\frac{d_2 - a_2 d'_1}{b_2 - a_2 \\gamma'_1} = \\frac{0 - 1(500)}{-1.5} = \\frac{1000}{3}$\n- $i=3$:\n   $\\gamma'_3 = \\frac{\\gamma_3}{b_3 - a_3 \\gamma'_2} = \\frac{1}{-2 - 1(-\\frac{2}{3})} = \\frac{1}{-\\frac{4}{3}} = -\\frac{3}{4}$\n   $d'_3 = \\frac{d_3 - a_3 d'_2}{b_3 - a_3 \\gamma'_2} = \\frac{0 - 1(\\frac{1000}{3})}{-\\frac{4}{3}} = \\frac{1000}{4} = 250$\n- $i=4$:\n   $\\gamma'_4 = \\frac{\\gamma_4}{b_4 - a_4 \\gamma'_3} = \\frac{1}{-2 - 1(-\\frac{3}{4})} = \\frac{1}{-\\frac{5}{4}} = -\\frac{4}{5}$\n   $d'_4 = \\frac{d_4 - a_4 d'_3}{b_4 - a_4 \\gamma'_3} = \\frac{0 - 1(250)}{-\\frac{5}{4}} = \\frac{1000}{5} = 200$\n\n**回代：**\n首先，计算 $c_5$：\n$$ c_5 = \\frac{d_5 - a_5 d'_4}{b_5 - a_5 \\gamma'_4} = \\frac{\\frac{25}{12} - 1(200)}{-1 - 1(-\\frac{4}{5})} = \\frac{\\frac{25-2400}{12}}{-\\frac{1}{5}} = \\frac{-\\frac{2375}{12}}{-\\frac{1}{5}} = \\frac{2375 \\times 5}{12} = \\frac{11875}{12} $$\n接下来，计算 $c_4$ 以求得 $c_3$：\n$$ c_4 = d'_4 - \\gamma'_4 c_5 = 200 - (-\\frac{4}{5})\\left(\\frac{11875}{12}\\right) = 200 + \\frac{4 \\times 11875}{5 \\times 12} = 200 + \\frac{11875}{15} = 200 + \\frac{2375}{3} = \\frac{600+2375}{3} = \\frac{2975}{3} $$\n最后，计算 $c_3$：\n$$ c_3 = d'_3 - \\gamma'_3 c_4 = 250 - (-\\frac{3}{4})\\left(\\frac{2975}{3}\\right) = 250 + \\frac{3 \\times 2975}{4 \\times 3} = 250 + \\frac{2975}{4} = \\frac{1000+2975}{4} = \\frac{3975}{4} = 993.75 $$\n题目要求将答案四舍五入至四位有效数字。\n$$ c_3 = 993.75 \\approx 993.8 $$\n浓度单位是 $\\text{mol}\\,\\text{m}^{-3}$。\n该问题的解析解为 $c(x) = c_0 - \\frac{j}{D}x$。对于这种线性分布，该数值方法是精确的，计算出的 $c_3 = c(3h) = 1000 - \\frac{10^{-4}}{2 \\times 10^{-10}} \\times 3 \\times \\frac{25 \\times 10^{-6}}{6} = 1000 - 6.25 = 993.75$ 证实了结果的正确性。",
            "answer": "$$\\boxed{993.8}$$"
        },
        {
            "introduction": "在掌握了稳态问题的求解后，我们自然地转向更复杂的瞬态（时间依赖）问题。然而，在编写了一个求解器之后，我们如何能确信其计算结果是正确的呢？本练习将介绍计算科学中用于代码验证的黄金标准——“人造解法”（Method of Manufactured Solutions, MMS）。您将应用经典的克兰克-尼科尔森（Crank-Nicolson）隐式时间步进格式，并通过人造解法严格地量化您所实现算法的收敛阶，以验证其是否达到了理论精度。这项实践将帮助您从仅仅“实现算法”跨越到“验证并信任算法结果”的关键一步 。",
            "id": "3914357",
            "problem": "考虑锂离子浓度在电解质板中的一维扩散，这是自动化电池设计和仿真中使用的标准简化方法。其控制偏微分方程(PDE)为一维空间中的菲克第二定律，表达式为 $u_t = \\alpha u_{xx}$，定义在空间域 $x \\in [0,L]$ 和时间区间 $t \\in [0,T]$ 上，其中 $u(x,t)$ 是浓度，$\\alpha$ 是扩散系数，$L$ 是板厚度，$T$ 是最终时间。在本问题中，使用人造解(Manufactured Solution, MS)来验证Crank–Nicolson (CN)格式的时间精度，该格式是一种二阶隐式时间步进方法。\n\n您必须构建测试，以使空间离散误差相对于时间误差可以忽略不计。为实现这一点，请使用足够密的空间网格。定义人造解为\n$$\nu(x,t) = \\cos\\!\\left(\\frac{2\\pi x}{L}\\right)\\exp(-\\gamma t),\n$$\n其中\n$$\n\\gamma = \\alpha\\left(\\frac{2\\pi}{L}\\right)^2.\n$$\n此选择可确保 $u_t = \\alpha u_{xx}$ 精确成立，因此不需要源项。施加与人造解一致的狄利克雷(Dirichlet)边界条件，即 $u(0,t) = \\exp(-\\gamma t)$ 和 $u(L,t) = \\exp(-\\gamma t)$，以及初始条件 $u(x,0) = \\cos\\!\\left(\\frac{2\\pi x}{L}\\right)$。\n\n使用均匀网格和二阶中心差分对空间进行离散以逼近 $u_{xx}$，并使用Crank–Nicolson方法对时间进行离散。对于内部网格索引 $j$ 和时间步长 $n$，CN更新格式为\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\alpha\\frac{1}{2}\\left[\\frac{u_{j+1}^{n+1} - 2u_j^{n+1} + u_{j-1}^{n+1}}{\\Delta x^2} + \\frac{u_{j+1}^{n} - 2u_j^{n} + u_{j-1}^{n}}{\\Delta x^2}\\right],\n$$\n其中 $\\Delta x$ 和 $\\Delta t$ 分别是空间和时间步长。在每个时间层级上，对 $j=0$ 和 $j=J$（$J$ 是右边界的索引）使用精确的边界值，因此在每个CN步骤中组装线性系统时，边界贡献被视为已知值。\n\n为评估时间精度，计算最终时间 $t = T$ 时内部节点的离散$\\mathrm{L}^2$误差，\n$$\nE(\\Delta t) = \\sqrt{\\Delta x\\sum_{j=1}^{J-1}\\left(u_j^{\\text{num}}(T) - u(x_j,T)\\right)^2},\n$$\n其中 $u_j^{\\text{num}}(T)$ 是内部网格点上的数值解，$u(x_j,T)$ 是在这些点上计算的精确人造解。通过对模型 $\\log E(\\Delta t) = p \\log \\Delta t + C$（其中 $C$ 为某个常数）进行最小二乘拟合，来估计观测到的时间精度阶 $p$。此拟合过程使用若干次加密的 $\\Delta t$ 值，同时保持 $\\Delta x$ 固定且足够小，以使空间误差可以忽略不计。\n\n您的程序必须实现上述方法，并为下面定义的每个测试用例计算 $p$。空间和时间离散化均带有物理单位量纲，以反映电池相关的工作状态；然而，最终报告的观测阶数 $p$ 是无量纲的。所有带有物理单位的量必须按规定一致使用，但最终输出应为无单位的浮点数。\n\n使用以下测试套件，其设计旨在覆盖典型行为、一个更刚性的情况以及一个更粗糙的空间网格边缘情况：\n- 测试用例 $1$ (基准)：$L = 1\\times 10^{-4}\\,\\text{m}$，$\\alpha = 1\\times 10^{-10}\\,\\text{m}^2/\\text{s}$，$T = 1\\times 10^{-1}\\,\\text{s}$，空间网格点数 $N_x = 401$ (包括边界)，以及时间加密步长 $\\Delta t \\in \\{1.25\\times 10^{-2}, 6.25\\times 10^{-3}, 3.125\\times 10^{-3}, 1.5625\\times 10^{-3}\\}\\,\\text{s}$。\n- 测试用例 $2$ (更刚性的扩散)：$L = 1\\times 10^{-4}\\,\\text{m}$，$\\alpha = 5\\times 10^{-10}\\,\\text{m}^2/\\text{s}$，$T = 1\\times 10^{-1}\\,\\text{s}$，$N_x = 401$，以及与测试用例1相同的时间加密步长。\n- 测试用例 $3$ (更粗糙的空间网格边缘情况)：$L = 1\\times 10^{-4}\\,\\text{m}$，$\\alpha = 1\\times 10^{-10}\\,\\text{m}^2/\\text{s}$，$T = 1\\times 10^{-1}\\,\\text{s}$，$N_x = 101$，以及与测试用例1相同的时间加密步长。\n\n对于每个测试用例，使用在所有指定 $\\Delta t$ 值上对 $(\\log \\Delta t, \\log E(\\Delta t))$ 进行的线性回归，将观测到的阶数 $p$ 计算为单个浮点数。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为测试用例 $1$、$2$ 和 $3$ (例如，$[p_1,p_2,p_3]$)。输出 $p_1$、$p_2$ 和 $p_3$ 必须是无单位的浮点数。角度单位与此问题无关。百分比不适用；仅报告浮点数值。",
            "solution": "此问题的目标是数值验证应用于一维扩散方程的Crank-Nicolson (CN)格式的时间精度阶。这是通过人造解方法(Method of Manufactured Solutions, MMS)实现的，这是一种严格的代码验证技术。浓度 $u(x,t)$ 的控制偏微分方程(PDE)是菲克第二定律：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\n该方程定义在空间域 $x \\in [0, L]$ 和时间 $t \\in [0, T]$ 上。参数 $\\alpha$ 是扩散系数。\n\nCrank-Nicolson格式是一种在时间和空间上均为二阶精度的有限差分法。它是通过对当前时间层 $n$ 和未来时间层 $n+1$ 的空间导数项进行平均来推导的。对于步长为 $\\Delta x$ 的均匀空间网格和步长为 $\\Delta t$ 的均匀时间网格，PDE在内部空间节点 $j$ 的离散化形式为：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\frac{\\alpha}{2} \\left( \\frac{u_{j+1}^{n+1} - 2u_j^{n+1} + u_{j-1}^{n+1}}{\\Delta x^2} + \\frac{u_{j+1}^{n} - 2u_j^{n} + u_{j-1}^{n}}{\\Delta x^2} \\right)\n$$\n其中 $u_j^n \\approx u(x_j, t_n)$。为简化此表达式，我们引入无量纲扩散数 $\\lambda = \\frac{\\alpha \\Delta t}{2 \\Delta x^2}$。然后我们重新排列方程，将所有未知项（在时间层 $n+1$）分组到左侧(LHS)，并将所有已知项（在时间层 $n$）分组到右侧(RHS)：\n$$\n-\\lambda u_{j-1}^{n+1} + (1+2\\lambda) u_j^{n+1} - \\lambda u_{j+1}^{n+1} = \\lambda u_{j-1}^{n} + (1-2\\lambda) u_j^n + \\lambda u_{j+1}^{n}\n$$\n该方程适用于所有内部网格点，即 $j = 1, 2, \\dots, J-1$，其中 $J$ 是最右侧网格点 $x_J = L$ 的索引。这就构成了一个包含 $J-1$ 个未知内部浓度（在时间 $t_{n+1}$）的 $J-1$ 个线性方程的方程组。\n\n该方程组可以写成矩阵形式 $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{b}^n$，其中 $\\mathbf{u}_{\\text{int}}^{n+1}$ 是内部节点上未知浓度的向量，即 $[u_1^{n+1}, u_2^{n+1}, \\dots, u_{J-1}^{n+1}]^T$。矩阵 $A$ 是一个三对角矩阵，主对角线上的元素是 $(1+2\\lambda)$，次对角线和超对角线上的元素是 $-\\lambda$。\n问题指定了狄利克雷(Dirichlet)边界条件 $u(0,t)$ 和 $u(L,t)$，它们是时间的已知函数。在每个时间步，边界值 $u_0^{n+1}$ 和 $u_J^{n+1}$ 是已知的。来自 $j=1$ 和 $j=J-1$ 方程左侧的这些项被移到右侧。得到的右侧向量 $\\mathbf{b}^n$ 由前一时间步的解 $\\mathbf{u}^n$ 以及 $t_n$ 和 $t_{n+1}$ 时的已知边界值构成。由于矩阵 $A$ 在整个仿真过程中是恒定的，它只需构建一次。在每个时间步，计算右侧向量 $\\mathbf{b}^n$，并高效地求解该三对角系统以找到下一时间步的解。\n\n为了验证时间精度，我们采用人造解(MS)：\n$$\nu(x,t) = \\cos\\left(\\frac{2\\pi x}{L}\\right)\\exp(-\\gamma t) \\quad \\text{其中} \\quad \\gamma = \\alpha\\left(\\frac{2\\pi}{L}\\right)^2\n$$\n该函数被构造为PDE $u_t = \\alpha u_{xx}$ 的精确解。此人造解用于为数值仿真推导一致的初始和边界条件：\n- 初始条件：$u(x,0) = \\cos\\left(\\frac{2\\pi x}{L}\\right)$\n- 边界条件：$u(0,t) = u(L,t) = \\exp(-\\gamma t)$\n\n数值仿真从 $t=0$ 运行到最终时间 $T$。然后将得到的数值解 $u_j^{\\text{num}}(T)$ 与精确的人造解 $u(x_j,T)$进行比较。误差通过内部节点上的离散 $L^2$ 范数来量化：\n$$\nE(\\Delta t) = \\sqrt{\\Delta x \\sum_{j=1}^{J-1} \\left(u_j^{\\text{num}}(T) - u(x_j,T)\\right)^2}\n$$\n对于一个时间精度阶为 $p$ 的方法，只要空间误差可以忽略不计，误差预计会表现为 $E(\\Delta t) \\approx C(\\Delta t)^p$，其中 $C$ 为某个常数。通过对这个关系式取对数，我们得到一个线性方程：\n$$\n\\log E(\\Delta t) \\approx \\log C + p \\log \\Delta t\n$$\n观测到的精度阶 $p$ 可以通过对一系列递减时间步长 $\\Delta t$ 的仿真所得到的 $(\\log \\Delta t, \\log E)$ 数据点进行线性拟合，求得的直线斜率来确定。\n\n对于每个测试用例，总体算法如下：\n$1$. 初始化物理和数值参数（$L$、$\\alpha$、$T$、$N_x$ 和一组 $\\Delta t$ 值）。空间网格是固定的。\n$2$. 对于集合中的每个 $\\Delta t$：\n    a. 使用 $t=0$ 时的人造解设置初始条件。\n    b. 构建恒定的三对角左侧矩阵 $A$。\n    c. 从 $t=0$ 到 $t=T$ 进行时间步进。在每一步中，计算右侧向量 $\\mathbf{b}^n$ 并求解线性系统以获得下一时间步的解。\n    d. 在 $t=T$ 时，通过将数值解与人造解进行比较，计算离散 $L^2$ 误差 $E(\\Delta t)$。\n$3$. 收集所有仿真的数据对 $(\\log \\Delta t, \\log E(\\Delta t))$。\n$4$. 对这些数据点执行线性最小二乘回归，以找到斜率，即观测到的精度阶 $p$。\n对三个指定的测试用例重复此过程，这些用例探索了不同的扩散情况和网格分辨率。该问题的设计使得在前两种情况下空间网格足够密集，以便清晰地测量时间阶（对于Crank-Nicolson格式，理论上 $p=2$）。第三种情况使用更粗糙的网格，以研究空间误差污染测量结果的可能性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef compute_order_p(L, alpha, T, Nx, dt_values):\n    \"\"\"\n    Computes the observed temporal order of accuracy for the Crank-Nicolson scheme.\n\n    Args:\n        L (float): Length of the spatial domain.\n        alpha (float): Diffusion coefficient.\n        T (float): Final time.\n        Nx (int): Number of spatial grid points.\n        dt_values (list): List of time step sizes for convergence study.\n\n    Returns:\n        float: The observed order of accuracy, p.\n    \"\"\"\n    # 1. Derived constants and spatial grid setup\n    gamma = alpha * (2 * np.pi / L)**2\n    \n    J = Nx - 1\n    dx = L / J\n    x_coords = np.linspace(0, L, Nx)\n    num_interior_points = Nx - 2\n    \n    log_errors = []\n    log_dts = np.log(np.array(dt_values))\n\n    # Define the Manufactured Solution (MS)\n    def u_exact(x, t):\n        return np.cos(2 * np.pi * x / L) * np.exp(-gamma * t)\n\n    # 2. Loop through each time step size to collect error data\n    for dt in dt_values:\n        # Simulation parameters for the current refinement\n        Nt = int(round(T / dt))\n        lam = alpha * dt / (2 * dx**2)  # Crank-Nicolson parameter\n        \n        # Initial condition from MS at t=0\n        t_current = 0.0\n        u_current = u_exact(x_coords, t_current)\n        \n        # LHS matrix A, in banded format for scipy.linalg.solve_banded\n        # It is constant for all time steps.\n        A_banded = np.zeros((3, num_interior_points))\n        A_banded[0, 1:] = -lam      # Upper diagonal (u_{j+1})\n        A_banded[1, :] = 1 + 2 * lam # Main diagonal (u_j)\n        A_banded[2, :-1] = -lam     # Lower diagonal (u_{j-1})\n        \n        # 3. Time-stepping loop\n        for n in range(Nt):\n            t_next = (n + 1) * dt\n            \n            # Known boundary values at the next time step from MS\n            u0_next = np.exp(-gamma * t_next) # u at x=0\n            uL_next = np.exp(-gamma * t_next) # u at x=L\n\n            # Construct the RHS vector b\n            # Start with the known stencil application on u_current\n            b = lam * u_current[0:-2] + \\\n                (1 - 2 * lam) * u_current[1:-1] + \\\n                lam * u_current[2:]\n            \n            # Add boundary contributions from the implicit part (LHS)\n            b[0] += lam * u0_next\n            b[-1] += lam * uL_next\n            \n            # Solve the tridiagonal system for interior points at t_next\n            u_interior_next = solve_banded((1, 1), A_banded, b)\n            \n            # Update the full solution vector for the next iteration\n            u_current[1:-1] = u_interior_next\n            u_current[0] = u0_next\n            u_current[-1] = uL_next\n            \n        # 4. At final time T, compute the L2 error\n        u_numerical_T = u_current\n        u_exact_T = u_exact(x_coords, T)\n        \n        # Error is computed over interior nodes only\n        diff_interior = u_numerical_T[1:-1] - u_exact_T[1:-1]\n        error = np.sqrt(dx * np.sum(diff_interior**2))\n        log_errors.append(np.log(error))\n\n    # 5. Perform linear regression on (log(dt), log(E)) to find the slope p\n    # np.polyfit with deg=1 returns [slope, intercept]\n    p, _ = np.polyfit(log_dts, log_errors, 1)\n    \n    return p\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    dt_refinements = [1.25e-2, 6.25e-3, 3.125e-3, 1.5625e-3]\n    \n    test_cases = [\n        # (L, alpha, T, Nx, dt_values)\n        (1e-4, 1e-10, 1e-1, 401, dt_refinements),  # Case 1: Baseline\n        (1e-4, 5e-10, 1e-1, 401, dt_refinements),  # Case 2: Stiffer diffusion\n        (1e-4, 1e-10, 1e-1, 101, dt_refinements),  # Case 3: Coarser spatial grid\n    ]\n\n    results = []\n    for case_params in test_cases:\n        p = compute_order_p(*case_params)\n        results.append(p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}