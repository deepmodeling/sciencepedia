{
    "hands_on_practices": [
        {
            "introduction": "Before diving into complex implicit solvers, it is crucial to understand why they are often necessary for battery models. This exercise guides you through a stability analysis of simple explicit schemes, governed by the famous Courant–Friedrichs–Lewy (CFL) condition. By deriving the maximum stable time step for diffusion in both a planar electrolyte and a spherical particle, you will gain a first-hand appreciation for how these physical processes create \"stiff\" systems that render basic explicit methods impractical, motivating the need for more advanced techniques. ",
            "id": "3933767",
            "problem": "A lithium-ion battery design automation tool advances in time with an explicit forward Euler scheme for two coupled subproblems: spherical solid diffusion inside active material particles and one-dimensional electrolyte diffusion across the porous composite. The Courant–Friedrichs–Lewy (CFL) condition governs the maximal stable time step for such explicit schemes. Starting from mass conservation and Fickian transport, derive CFL-like stability bounds for each discretized subproblem and compute the single maximal common safe time step.\n\nThe solid-state lithium concentration $c_{s}(r,t)$ within a spherical particle of radius $R_{s}$ satisfies the spherically symmetric Fickian diffusion equation\n$$\n\\frac{\\partial c_{s}}{\\partial t} \\;=\\; D_{s} \\left( \\frac{\\partial^{2} c_{s}}{\\partial r^{2}} \\;+\\; \\frac{2}{r}\\,\\frac{\\partial c_{s}}{\\partial r} \\right),\n$$\nfor $0 \\le r \\le R_{s}$, where $D_{s}$ is the solid diffusion coefficient. The electrolyte salt concentration $c_{e}(x,t)$ across a porous domain of length $L$ satisfies\n$$\n\\epsilon\\,\\frac{\\partial c_{e}}{\\partial t} \\;=\\; \\frac{\\partial}{\\partial x}\\!\\left( D_{e}^{\\mathrm{eff}}\\,\\frac{\\partial c_{e}}{\\partial x} \\right),\n$$\nfor $0 \\le x \\le L$, where $\\epsilon$ is the porosity and $D_{e}^{\\mathrm{eff}}$ is the effective electrolyte diffusivity. For the purpose of stability analysis, neglect source terms and boundary fluxes, and focus on the interior operators.\n\nBoth subproblems are spatially discretized on uniform grids with second-order central finite differences and advanced in time with explicit forward Euler. The spherical particle is discretized with $N_{r}$ uniformly spaced shells of size $\\Delta r = R_{s}/N_{r}$. The electrolyte domain is discretized with $N_{x}$ intervals of size $\\Delta x = L/N_{x}$. Use the following physically plausible parameter values:\n- $R_{s} = 8.00 \\times 10^{-6}\\,\\mathrm{m}$,\n- $D_{s} = 3.00 \\times 10^{-14}\\,\\mathrm{m^{2}\\,s^{-1}}$,\n- $L = 2.00 \\times 10^{-4}\\,\\mathrm{m}$,\n- $N_{r} = 40$,\n- $N_{x} = 200$,\n- $\\epsilon = 0.35$,\n- $D_{e}^{\\mathrm{eff}} = 1.20 \\times 10^{-10}\\,\\mathrm{m^{2}\\,s^{-1}}$.\n\nFrom first principles, derive CFL-like time step bounds for both discretizations, compute the corresponding safe $\\Delta t$ values, and then determine the single maximal common safe time step $\\Delta t_{\\max}$ that simultaneously satisfies both bounds. Express the final $\\Delta t_{\\max}$ in seconds and round your answer to four significant figures.",
            "solution": "The problem requires the derivation of stability bounds for the explicit forward Euler time integration of two discretized diffusion partial differential equations (PDEs), and the calculation of the maximum permissible time step $\\Delta t_{\\max}$ that satisfies both bounds simultaneously.\n\nThe analysis will be performed for each subproblem separately.\n\n**Part 1: Electrolyte Diffusion Stability Analysis**\n\nThe governing equation for the electrolyte salt concentration, $c_{e}(x,t)$, is given by:\n$$\n\\epsilon\\,\\frac{\\partial c_{e}}{\\partial t} \\;=\\; \\frac{\\partial}{\\partial x}\\!\\left( D_{e}^{\\mathrm{eff}}\\,\\frac{\\partial c_{e}}{\\partial x} \\right)\n$$\nwhere $\\epsilon$ is the porosity and $D_{e}^{\\mathrm{eff}}$ is the effective electrolyte diffusivity. Since a single value for $D_{e}^{\\mathrm{eff}}$ is provided, it is treated as a spatial constant. The equation simplifies to the one-dimensional heat equation:\n$$\n\\frac{\\partial c_{e}}{\\partial t} \\;=\\; \\frac{D_{e}^{\\mathrm{eff}}}{\\epsilon} \\frac{\\partial^{2} c_{e}}{\\partial x^{2}}\n$$\nWe discretize this equation using a forward Euler scheme in time and a second-order central difference scheme in space. Let $c_{e,j}^{n}$ represent the concentration at spatial node $j$ and time step $n$, such that $x = j\\Delta x$ and $t = n\\Delta t$. The finite difference approximation is:\n$$\n\\frac{c_{e,j}^{n+1} - c_{e,j}^{n}}{\\Delta t} \\;=\\; \\frac{D_{e}^{\\mathrm{eff}}}{\\epsilon} \\left( \\frac{c_{e,j+1}^{n} - 2c_{e,j}^{n} + c_{e,j-1}^{n}}{(\\Delta x)^{2}} \\right)\n$$\nRearranging for the concentration at the next time step, $c_{e,j}^{n+1}$, gives the update rule for the explicit scheme:\n$$\nc_{e,j}^{n+1} \\;=\\; c_{e,j}^{n} + \\frac{D_{e}^{\\mathrm{eff}} \\Delta t}{\\epsilon (\\Delta x)^{2}} \\left( c_{e,j+1}^{n} - 2c_{e,j}^{n} + c_{e,j-1}^{n} \\right)\n$$\nLet the dimensionless diffusion number for the electrolyte be $\\mu_{e} = \\frac{D_{e}^{\\mathrm{eff}} \\Delta t}{\\epsilon (\\Delta x)^{2}}$. The equation becomes:\n$$\nc_{e,j}^{n+1} \\;=\\; \\mu_{e} c_{e,j+1}^{n} + (1 - 2\\mu_{e}) c_{e,j}^{n} + \\mu_{e} c_{e,j-1}^{n}\n$$\nFor an explicit finite difference scheme for a parabolic PDE, a sufficient condition for stability (and to avoid non-physical oscillations, ensuring the scheme satisfies a maximum principle) is that all coefficients on the right-hand side are non-negative. The coefficient $\\mu_{e}$ is inherently non-negative. The condition thus falls on the coefficient of $c_{e,j}^{n}$:\n$$\n1 - 2\\mu_{e} \\ge 0 \\implies \\mu_{e} \\le \\frac{1}{2}\n$$\nThis is the well-known Courant–Friedrichs–Lewy (CFL) condition for the one-dimensional heat equation. Substituting the definition of $\\mu_{e}$:\n$$\n\\frac{D_{e}^{\\mathrm{eff}} \\Delta t}{\\epsilon (\\Delta x)^{2}} \\le \\frac{1}{2}\n$$\nThis gives the stability bound for the electrolyte time step, $\\Delta t_{e}$:\n$$\n\\Delta t_{e} \\le \\frac{\\epsilon (\\Delta x)^{2}}{2 D_{e}^{\\mathrm{eff}}}\n$$\nThe spatial step size $\\Delta x$ is given by $\\Delta x = L/N_{x}$. Using the provided values:\n$L = 2.00 \\times 10^{-4}\\,\\mathrm{m}$ and $N_{x} = 200$.\n$$\n\\Delta x = \\frac{2.00 \\times 10^{-4}\\,\\mathrm{m}}{200} = 1.00 \\times 10^{-6}\\,\\mathrm{m}\n$$\nNow, we compute the maximum value for $\\Delta t_{e}$ using $\\epsilon = 0.35$ and $D_{e}^{\\mathrm{eff}} = 1.20 \\times 10^{-10}\\,\\mathrm{m^{2}\\,s^{-1}}$:\n$$\n\\Delta t_{e} \\le \\frac{0.35 \\times (1.00 \\times 10^{-6}\\,\\mathrm{m})^{2}}{2 \\times 1.20 \\times 10^{-10}\\,\\mathrm{m^{2}\\,s^{-1}}} = \\frac{0.35 \\times 1.00 \\times 10^{-12}\\,\\mathrm{m^{2}}}{2.40 \\times 10^{-10}\\,\\mathrm{m^{2}\\,s^{-1}}} \\approx 1.4583 \\times 10^{-3}\\,\\mathrm{s}\n$$\n\n**Part 2: Solid Diffusion Stability Analysis**\n\nThe governing equation for solid-state lithium concentration, $c_{s}(r,t)$, is:\n$$\n\\frac{\\partial c_{s}}{\\partial t} \\;=\\; D_{s} \\left( \\frac{\\partial^{2} c_{s}}{\\partial r^{2}} \\;+\\; \\frac{2}{r}\\,\\frac{\\partial c_{s}}{\\partial r} \\right)\n$$\nThe term $\\frac{2}{r}$ creates a singularity at the center of the sphere, $r=0$. The stability analysis must correctly handle this point, as it often imposes the most restrictive constraint. At $r=0$, due to spherical symmetry, the concentration gradient must be zero: $\\frac{\\partial c_{s}}{\\partial r}\\big|_{r=0} = 0$. We can evaluate the term $\\frac{2}{r}\\frac{\\partial c_{s}}{\\partial r}$ at $r=0$ using L'Hôpital's rule:\n$$\n\\lim_{r\\to 0} \\frac{2}{r}\\frac{\\partial c_{s}}{\\partial r} = \\lim_{r\\to 0} \\frac{2 \\frac{\\partial^{2} c_{s}}{\\partial r^{2}}}{1} = 2 \\frac{\\partial^{2} c_{s}}{\\partial r^{2}}\\bigg|_{r=0}\n$$\nSubstituting this into the PDE, the governing equation at $r=0$ becomes:\n$$\n\\frac{\\partial c_{s}}{\\partial t}\\bigg|_{r=0} = D_{s} \\left( \\frac{\\partial^{2} c_{s}}{\\partial r^{2}}\\bigg|_{r=0} + 2 \\frac{\\partial^{2} c_{s}}{\\partial r^{2}}\\bigg|_{r=0} \\right) = 3 D_{s} \\frac{\\partial^{2} c_{s}}{\\partial r^{2}}\\bigg|_{r=0}\n$$\nLet's discretize this equation at $r=0$. Let $c_{s,i}^{n}$ denote $c_{s}(i\\Delta r, n\\Delta t)$. The center is at $i=0$. The time derivative is approximated by forward Euler. The second spatial derivative at $r=0$ is approximated using a central difference, incorporating the symmetry condition $c_{s,-1}^{n} = c_{s,1}^{n}$:\n$$\n\\frac{\\partial^{2} c_{s}}{\\partial r^{2}}\\bigg|_{r=0} \\approx \\frac{c_{s,1}^{n} - 2c_{s,0}^{n} + c_{s,-1}^{n}}{(\\Delta r)^{2}} = \\frac{2(c_{s,1}^{n} - c_{s,0}^{n})}{(\\Delta r)^{2}}\n$$\nThe fully discretized equation at $r=0$ is:\n$$\n\\frac{c_{s,0}^{n+1} - c_{s,0}^{n}}{\\Delta t} = 3 D_{s} \\left( \\frac{2(c_{s,1}^{n} - c_{s,0}^{n})}{(\\Delta r)^{2}} \\right)\n$$\nRearranging for $c_{s,0}^{n+1}$:\n$$\nc_{s,0}^{n+1} = c_{s,0}^{n} + \\frac{6 D_{s} \\Delta t}{(\\Delta r)^{2}} (c_{s,1}^{n} - c_{s,0}^{n}) = \\left(1 - \\frac{6 D_{s} \\Delta t}{(\\Delta r)^{2}}\\right) c_{s,0}^{n} + \\frac{6 D_{s} \\Delta t}{(\\Delta r)^{2}} c_{s,1}^{n}\n$$\nApplying the same stability criterion of non-negative coefficients, we require:\n$$\n1 - \\frac{6 D_{s} \\Delta t}{(\\Delta r)^{2}} \\ge 0\n$$\nThis yields the stability bound for the solid-phase diffusion time step, $\\Delta t_{s}$:\n$$\n\\Delta t_{s} \\le \\frac{(\\Delta r)^{2}}{6 D_{s}}\n$$\nThis condition at the origin is more restrictive than the condition at interior points $r>0$ (which would be $\\Delta t \\le (\\Delta r)^2 / (2D_s)$), and therefore governs the stability of the entire spherical domain.\nThe spatial step size $\\Delta r$ is given by $\\Delta r = R_{s}/N_{r}$. Using the provided values:\n$R_{s} = 8.00 \\times 10^{-6}\\,\\mathrm{m}$ and $N_{r} = 40$.\n$$\n\\Delta r = \\frac{8.00 \\times 10^{-6}\\,\\mathrm{m}}{40} = 2.00 \\times 10^{-7}\\,\\mathrm{m}\n$$\nNow, we compute the maximum value for $\\Delta t_{s}$ using $D_{s} = 3.00 \\times 10^{-14}\\,\\mathrm{m^{2}\\,s^{-1}}$:\n$$\n\\Delta t_{s} \\le \\frac{(2.00 \\times 10^{-7}\\,\\mathrm{m})^{2}}{6 \\times 3.00 \\times 10^{-14}\\,\\mathrm{m^{2}\\,s^{-1}}} = \\frac{4.00 \\times 10^{-14}\\,\\mathrm{m^{2}}}{18.0 \\times 10^{-14}\\,\\mathrm{m^{2}\\,s^{-1}}} = \\frac{4.00}{18.0}\\,\\mathrm{s} \\approx 0.2222\\,\\mathrm{s}\n$$\n\n**Part 3: Maximal Common Safe Time Step**\n\nThe automation tool must use a single time step $\\Delta t$ that is stable for both subproblems. Therefore, $\\Delta t$ must satisfy both inequalities simultaneously:\n$$\n\\Delta t \\le \\Delta t_{e} \\quad \\text{and} \\quad \\Delta t \\le \\Delta t_{s}\n$$\nThis implies that the single maximal common safe time step, $\\Delta t_{\\max}$, must be the minimum of the two individual bounds:\n$$\n\\Delta t_{\\max} = \\min(\\Delta t_{e}, \\Delta t_{s})\n$$\nSubstituting the calculated values:\n$$\n\\Delta t_{\\max} = \\min(1.4583 \\times 10^{-3}\\,\\mathrm{s}, 0.2222\\,\\mathrm{s})\n$$\nThe smaller value is the bound from the electrolyte diffusion subproblem:\n$$\n\\Delta t_{\\max} = 1.4583 \\times 10^{-3}\\,\\mathrm{s}\n$$\nThe problem requires the final answer to be rounded to four significant figures.\n$$\n\\Delta t_{\\max} \\approx 1.458 \\times 10^{-3}\\,\\mathrm{s}\n$$\nThis is the single largest time step value that guarantees numerical stability for the explicit forward Euler integration of both coupled subproblems.",
            "answer": "$$\n\\boxed{1.458 \\times 10^{-3}}\n$$"
        },
        {
            "introduction": "Implicit methods are the workhorses for solving the stiff PDEs found in battery simulation, but not all are created equal. This practice provides a comparative analysis of three popular time integration schemes: the robust first-order Implicit Euler, the second-order Crank–Nicolson, and the higher-order Backward Differentiation Formula (BDF2). By implementing and testing these methods on a representative electrolyte depletion problem, you will explore the critical trade-offs between accuracy, stability, and the preservation of physical quantities like concentration positivity. ",
            "id": "3933711",
            "problem": "Consider a one-dimensional electrolyte domain governed by mass conservation and Fickian diffusion. Let $c(x,t)$ denote the salt concentration in the electrolyte, measured in $\\mathrm{mol/m^3}$, over the spatial interval $x \\in [0,L]$ and time $t \\in [0,T]$. The evolution of $c(x,t)$ under a charging pulse is modeled by the parabolic partial differential equation (PDE)\n$$\n\\frac{\\partial c}{\\partial t}(x,t) \\;=\\; D \\,\\frac{\\partial^2 c}{\\partial x^2}(x,t) \\;-\\; s(t),\n$$\nwhere $D$ is the diffusion coefficient in $\\mathrm{m^2/s}$ and $s(t)$ is a uniform volumetric sink term in $\\mathrm{mol/(m^3\\cdot s)}$ that represents the net salt consumption during the charging pulse. The boundary conditions are zero-flux (Neumann) conditions,\n$$\n\\frac{\\partial c}{\\partial x}(0,t) \\;=\\; 0, \\qquad \\frac{\\partial c}{\\partial x}(L,t) \\;=\\; 0,\n$$\nand the initial condition is uniform,\n$$\nc(x,0) \\;=\\; c_0.\n$$\nThe charging pulse is represented by a piecewise-constant sink,\n$$\ns(t) \\;=\\; \n\\begin{cases}\ns_0, & t_{\\mathrm{on}} \\le t < t_{\\mathrm{off}},\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nStarting from the above physical laws and definitions, discretize the spatial domain using second-order central differences that enforce the zero-flux boundary conditions and derive the fully discrete time-stepping updates for the following three implicit methods:\n- Implicit Euler,\n- Crank–Nicolson,\n- Backward Differentiation Formula of order two (BDF2, defined as Backward Differentiation Formula (BDF) with polynomial coefficients that yield second-order accuracy).\n\nUse these updates to implement a numerical program that, for each method and each test case, advances the discrete concentration field, detects electrolyte depletion, and computes accuracy and stability metrics.\n\nDefinitions and metrics:\n- The electrolyte depletion threshold $c_{\\min,*}$ is a specified concentration in $\\mathrm{mol/m^3}$. Define the depletion time $\\tau_{\\mathrm{dep}}$ as the earliest time at which the spatial minimum of the discrete concentration first falls below $c_{\\min,*}$, using the discrete time grid. If depletion does not occur within $[0,T]$, set $\\tau_{\\mathrm{dep}}=T$.\n- The final-time relative $L^2$ error for a method $M$ is\n$$\n\\mathcal{E}_{L^2}(M) \\;=\\; \\frac{\\left\\|c_M(\\cdot,T) \\;-\\; c_{\\mathrm{ref}}(\\cdot,T)\\right\\|_2}{\\left\\|c_{\\mathrm{ref}}(\\cdot,T)\\right\\|_2},\n$$\nwhere $c_{\\mathrm{ref}}(\\cdot,T)$ is a high-fidelity reference solution computed by implicit Euler with time step $\\Delta t_{\\mathrm{ref}} = 10^{-3}\\,\\mathrm{s}$.\n- The depletion-time absolute error for a method $M$ is\n$$\n\\left|\\tau_{\\mathrm{dep}}(M) \\;-\\; \\tau_{\\mathrm{dep}}(\\mathrm{ref})\\right| \\quad \\text{in} \\quad \\mathrm{s}.\n$$\n- Positivity violation flag is an integer defined as $0$ if $c(x,t)\\ge 0$ for all nodes and time steps, and $1$ if any node becomes negative at any time step.\n- Monotonicity violation count during the pulse is the number of discrete time steps within the interval $[t_{\\mathrm{on}}, t_{\\mathrm{off}})$ for which the spatial minimum of the discrete concentration increases compared to the previous time step.\n\nScientific and numerical requirements:\n- Express all quantities in the specified units: $c$ in $\\mathrm{mol/m^3}$, $D$ in $\\mathrm{m^2/s}$, $L$ in $\\mathrm{m}$, $t$ in $\\mathrm{s}$, and $s(t)$ in $\\mathrm{mol/(m^3\\cdot s)}$.\n- Derive the discrete operators and updates from the PDE and boundary conditions without invoking shortcut formulas. The spatial operator must be consistent with the second derivative under zero-flux boundaries.\n- The time-stepping implementations must be fully implicit for the diffusion operator. Treat the source term consistently with each method’s temporal discretization.\n\nTest suite:\nImplement the program for the following three test cases, each defined by the tuple $(D, L, N, T, \\Delta t, s_0, t_{\\mathrm{on}}, t_{\\mathrm{off}}, c_0, c_{\\min,*})$:\n- Case $A$: $(2.0\\times 10^{-10},\\, 1.0\\times 10^{-4},\\, 50,\\, 2.0,\\, 0.02,\\, 50.0,\\, 0.5,\\, 1.5,\\, 1000.0,\\, 800.0)$\n- Case $B$: $(1.0\\times 10^{-10},\\, 1.0\\times 10^{-4},\\, 60,\\, 2.0,\\, 0.2,\\, 300.0,\\, 0.4,\\, 1.8,\\, 1000.0,\\, 700.0)$\n- Case $C$: $(5.0\\times 10^{-11},\\, 1.5\\times 10^{-4},\\, 40,\\, 1.5,\\, 0.05,\\, 600.0,\\, 0.2,\\, 0.8,\\, 1200.0,\\, 900.0)$\n\nFor each test case, compute the high-fidelity reference with implicit Euler time step $\\Delta t_{\\mathrm{ref}} = 10^{-3}$ and then run the three methods with the specified $\\Delta t$ for that case. For each method and case, compute:\n- Depletion-time absolute error in $\\mathrm{s}$,\n- Final-time relative $L^2$ error (dimensionless),\n- Positivity violation flag (integer $0$ or $1$),\n- Monotonicity violation count during the pulse (integer).\n\nFinal output specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be ordered by test case ($A$, then $B$, then $C$). Within each test case, order by method: implicit Euler, Crank–Nicolson, BDF2. Within each method, order the metrics as listed above. Concretely, the output should be\n$$\n[\\text{A-IE-dep\\_err},\\text{A-IE-relL2},\\text{A-IE-neg},\\text{A-IE-mono},\\text{A-CN-dep\\_err},\\text{A-CN-relL2},\\text{A-CN-neg},\\text{A-CN-mono},\\text{A-BDF2-dep\\_err},\\text{A-BDF2-relL2},\\text{A-BDF2-neg},\\text{A-BDF2-mono},\\text{B-IE-dep\\_err},\\ldots,\\text{C-BDF2-mono}]\n$$\nwhere the depletion-time errors are in $\\mathrm{s}$, the relative $L^2$ errors are dimensionless floats, and the flags and counts are integers. No additional text should be printed.",
            "solution": "The user wants to solve a one-dimensional reaction-diffusion PDE using three different implicit time-stepping schemes and evaluate their performance based on several metrics.\n\n### Step 1: Problem Validation\n\n**1.1. Extract Givens**\n\n- **PDE**: $\\frac{\\partial c}{\\partial t}(x,t) = D \\,\\frac{\\partial^2 c}{\\partial x^2}(x,t) - s(t)$\n- **Domain**: $x \\in [0,L]$, $t \\in [0,T]$\n- **Variables**: $c(x,t)$ is salt concentration ($\\mathrm{mol/m^3}$), $D$ is diffusion coefficient ($\\mathrm{m^2/s}$), $s(t)$ is a sink term ($\\mathrm{mol/(m^3\\cdot s)}$).\n- **Boundary Conditions (BCs)**: Zero-flux (Neumann), $\\frac{\\partial c}{\\partial x}(0,t) = 0$ and $\\frac{\\partial c}{\\partial x}(L,t) = 0$.\n- **Initial Condition (IC)**: Uniform, $c(x,0) = c_0$.\n- **Sink Term**: Piecewise-constant, $s(t) = s_0$ for $t_{\\mathrm{on}} \\le t < t_{\\mathrm{off}}$, and $0$ otherwise.\n- **Discretization Method**: Second-order central differences for space. Implicit Euler, Crank–Nicolson, and BDF2 for time.\n- **Metrics**:\n    - **Depletion Time $\\tau_{\\mathrm{dep}}$**: Earliest time $t$ where $\\min_x c(x,t) < c_{\\min,*}$. If no depletion, $\\tau_{\\mathrm{dep}} = T$.\n    - **Depletion-Time Absolute Error**: $|\\tau_{\\mathrm{dep}}(M) - \\tau_{\\mathrm{dep}}(\\mathrm{ref})|$.\n    - **Final-Time Relative $L^2$ Error**: $\\mathcal{E}_{L^2}(M) = \\frac{\\left\\|c_M(\\cdot,T) - c_{\\mathrm{ref}}(\\cdot,T)\\right\\|_2}{\\left\\|c_{\\mathrm{ref}}(\\cdot,T)\\right\\|_2}$.\n    - **Positivity Violation Flag**: $1$ if $c(x,t) < 0$ at any point, $0$ otherwise.\n    - **Monotonicity Violation Count**: Number of time steps in $[t_{\\mathrm{on}}, t_{\\mathrm{off}})$ where $\\min_x c(x, t_{k+1}) > \\min_x c(x, t_k)$.\n- **Reference Solution**: Computed with Implicit Euler using $\\Delta t_{\\mathrm{ref}} = 10^{-3}\\,\\mathrm{s}$.\n- **Test Cases**:\n    - A: $(D=2.0\\times 10^{-10}, L=1.0\\times 10^{-4}, N=50, T=2.0, \\Delta t=0.02, s_0=50.0, t_{\\mathrm{on}}=0.5, t_{\\mathrm{off}}=1.5, c_0=1000.0, c_{\\min,*}=800.0)$\n    - B: $(D=1.0\\times 10^{-10}, L=1.0\\times 10^{-4}, N=60, T=2.0, \\Delta t=0.2, s_0=300.0, t_{\\mathrm{on}}=0.4, t_{\\mathrm{off}}=1.8, c_0=1000.0, c_{\\min,*}=700.0)$\n    - C: $(D=5.0\\times 10^{-11}, L=1.5\\times 10^{-4}, N=40, T=1.5, \\Delta t=0.05, s_0=600.0, t_{\\mathrm{on}}=0.2, t_{\\mathrm{off}}=0.8, c_0=1200.0, c_{\\min,*}=900.0)$\n\n**1.2. Validate Using Extracted Givens**\n\n- **Scientifically Grounded**: The problem describes Fickian diffusion with a sink term, a fundamental model in transport phenomena and electrochemistry. It is scientifically valid.\n- **Well-Posed**: The problem is a well-posed parabolic PDE with defined initial and boundary conditions. The numerical tasks are standard.\n- **Objective**: The problem is stated using precise mathematical and physical terminology. The metrics are defined objectively.\n- **Completeness**: All necessary parameters, conditions, and definitions for solving the problem are provided.\n- **Consistency**: All given information is internally consistent.\n\n**1.3. Verdict and Action**\n\nThe problem is valid. We proceed to the solution.\n\n### Step 2: Derivation and Solution\n\n**2.1. Spatial Discretization**\n\nWe discretize the spatial domain $x \\in [0,L]$ into $N$ equally spaced nodes $x_i = i\\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L/(N-1)$. Let $c_i(t)$ be the numerical approximation of $c(x_i, t)$.\n\nThe second spatial derivative $\\frac{\\partial^2 c}{\\partial x^2}$ at an interior node $x_i$ ($1 \\le i \\le N-2$) is approximated using a second-order central difference:\n$$ \\frac{\\partial^2 c}{\\partial x^2}(x_i,t) \\approx \\frac{c_{i+1}(t) - 2c_i(t) + c_{i-1}(t)}{\\Delta x^2} $$\n\nTo enforce the zero-flux boundary conditions, we introduce ghost nodes $c_{-1}(t)$ and $c_{N}(t)$.\nAt the left boundary ($x=0$, $i=0$):\n$$ \\frac{\\partial c}{\\partial x}(0,t) \\approx \\frac{c_1(t) - c_{-1}(t)}{2\\Delta x} = 0 \\implies c_{-1}(t) = c_1(t) $$\nThe PDE at $i=0$ is then discretized as:\n$$ \\frac{d c_0}{d t} = D \\frac{c_1(t) - 2c_0(t) + c_{-1}(t)}{\\Delta x^2} - s(t) = D \\frac{2c_1(t) - 2c_0(t)}{\\Delta x^2} - s(t) $$\nAt the right boundary ($x=L$, $i=N-1$):\n$$ \\frac{\\partial c}{\\partial x}(L,t) \\approx \\frac{c_{N}(t) - c_{N-2}(t)}{2\\Delta x} = 0 \\implies c_{N}(t) = c_{N-2}(t) $$\nThe PDE at $i=N-1$ is discretized as:\n$$ \\frac{d c_{N-1}}{d t} = D \\frac{c_{N}(t) - 2c_{N-1}(t) + c_{N-2}(t)}{\\Delta x^2} - s(t) = D \\frac{2c_{N-2}(t) - 2c_{N-1}(t)}{\\Delta x^2} - s(t) $$\n\nThis method of lines (MOL) approach results in a system of $N$ ordinary differential equations (ODEs), which can be written in matrix form:\n$$ \\frac{d\\mathbf{c}}{dt} = \\mathbf{A}\\mathbf{c}(t) - s(t)\\mathbf{1} $$\nwhere $\\mathbf{c}(t) = [c_0(t), c_1(t), \\dots, c_{N-1}(t)]^T$ is the vector of concentrations, $\\mathbf{1}$ is a vector of ones, and $\\mathbf{A}$ is the $N \\times N$ spatial discretization matrix. Letting $\\alpha = D / \\Delta x^2$, the matrix $\\mathbf{A}$ is:\n$$\n\\mathbf{A} = \\alpha\n\\begin{pmatrix}\n-2 & 2 & 0 & \\dots & & 0 \\\\\n1 & -2 & 1 & 0 & \\dots & 0 \\\\\n0 & 1 & -2 & 1 & \\ddots & \\vdots \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & & 0 \\\\\n0 & \\dots & 0 & 1 & -2 & 1 \\\\\n0 & & \\dots & 0 & 2 & -2\n\\end{pmatrix}\n$$\n\n**2.2. Temporal Discretization**\n\nLet $\\mathbf{c}^k$ denote the numerical solution vector at time $t_k = k\\Delta t$, and let $\\mathbf{s}^k = s(t_k)\\mathbf{1}$. We derive the update rules for the three required implicit methods.\n\n**2.2.1. Implicit Euler (IE)**\nThis first-order method approximates the time derivative at $t_{k+1}$:\n$$ \\frac{\\mathbf{c}^{k+1} - \\mathbf{c}^k}{\\Delta t} = \\mathbf{A}\\mathbf{c}^{k+1} - \\mathbf{s}^{k+1} $$\nRearranging to solve for the unknown $\\mathbf{c}^{k+1}$, we get the linear system:\n$$ (\\mathbf{I} - \\Delta t \\mathbf{A})\\mathbf{c}^{k+1} = \\mathbf{c}^k - \\Delta t \\mathbf{s}^{k+1} $$\nwhere $\\mathbf{I}$ is the identity matrix.\n\n**2.2.2. Crank–Nicolson (CN)**\nThis second-order method is based on the trapezoidal rule, averaging the RHS at $t_k$ and $t_{k+1}$:\n$$ \\frac{\\mathbf{c}^{k+1} - \\mathbf{c}^k}{\\Delta t} = \\frac{1}{2} \\left( (\\mathbf{A}\\mathbf{c}^{k} - \\mathbf{s}^{k}) + (\\mathbf{A}\\mathbf{c}^{k+1} - \\mathbf{s}^{k+1}) \\right) $$\nGrouping terms with $\\mathbf{c}^{k+1}$ on the left-hand side yields the linear system:\n$$ \\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{c}^{k+1} = \\left(\\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{c}^k - \\frac{\\Delta t}{2}(\\mathbf{s}^k + \\mathbf{s}^{k+1}) $$\n\n**2.2.3. Backward Differentiation Formula of order 2 (BDF2)**\nBDF2 is a second-order, two-step method. The formula is:\n$$ \\frac{3\\mathbf{c}^{k+1} - 4\\mathbf{c}^k + \\mathbf{c}^{k-1}}{2\\Delta t} = \\mathbf{A}\\mathbf{c}^{k+1} - \\mathbf{s}^{k+1} $$\nThis is valid for $k \\ge 1$. For the very first step ($k=0$), a one-step method is required to generate $\\mathbf{c}^1$. We will use Implicit Euler for this startup step. For $k \\ge 1$, we rearrange the BDF2 formula to solve for $\\mathbf{c}^{k+1}$:\n$$ (3\\mathbf{I} - 2\\Delta t\\mathbf{A})\\mathbf{c}^{k+1} = 4\\mathbf{c}^k - \\mathbf{c}^{k-1} - 2\\Delta t \\mathbf{s}^{k+1} $$\nThis can be rewritten as:\n$$ \\left(\\mathbf{I} - \\frac{2}{3}\\Delta t\\mathbf{A}\\right)\\mathbf{c}^{k+1} = \\frac{4}{3}\\mathbf{c}^k - \\frac{1}{3}\\mathbf{c}^{k-1} - \\frac{2}{3}\\Delta t \\mathbf{s}^{k+1} $$\n\n**2.3. Algorithmic Implementation**\n\nFor each test case:\n1.  **Reference Solution**: A high-fidelity reference solution is computed using the Implicit Euler method with a very small time step, $\\Delta t_{\\mathrm{ref}} = 10^{-3}\\,\\mathrm{s}$, over the time interval $[0, T]$. During this simulation, the reference depletion time, $\\tau_{\\mathrm{dep}}(\\mathrm{ref})$, is recorded. The final concentration profile, $\\mathbf{c}_{\\mathrm{ref}}(T)$, is stored.\n2.  **Method Evaluation**: For each of the three methods (IE, CN, BDF2), a simulation is run using the time step $\\Delta t$ specified in the test case.\n3.  **Time-Stepping Loop**: For each simulation, an initial concentration vector $\\mathbf{c}^0 = c_0 \\mathbf{1}$ is created. The simulation proceeds in a time loop from $t=0$ to $t=T$. In each step, the appropriate linear system derived above is formed and solved for $\\mathbf{c}^{k+1}$ using a standard linear solver.\n4.  **Metrics Calculation**:\n    - During the simulation loop for a method $M$, we track the earliest time $t_k$ when $\\min(\\mathbf{c}^k) < c_{\\min,*}$ to find $\\tau_{\\mathrm{dep}}(M)$.\n    - We maintain a flag for positivity violation, setting it to $1$ if any component of $\\mathbf{c}^k$ ever becomes negative.\n    - We count monotonicity violations by checking if $\\min(\\mathbf{c}^{k+1}) > \\min(\\mathbf{c}^k)$ during the pulse interval $[t_{\\mathrm{on}}, t_{\\mathrm{off}})$.\n    - After the loop completes, the final concentration $\\mathbf{c}_M(T)$ is obtained. The relative $L^2$ error $\\mathcal{E}_{L^2}(M)$ is computed by comparing $\\mathbf{c}_M(T)$ with $\\mathbf{c}_{\\mathrm{ref}}(T)$ using the discrete vector $2$-norm. The depletion-time absolute error is calculated as $|\\tau_{\\mathrm{dep}}(M) - \\tau_{\\mathrm{dep}}(\\mathrm{ref})|$.\n5.  **Output Aggregation**: The four computed metrics for each method and each test case are collected and formatted into a single comma-separated list as specified.\n\nThe provided numerical parameters for the test cases ensure that the time-stepping loops run for an integer number of steps. The matrices involved in the linear systems are tridiagonal (or nearly so), which allows for efficient solution, although a general-purpose dense solver is sufficient given the small size of $N$.",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(method, D, L, N, T, dt, s0, t_on, t_off, c0, c_min_star):\n    \"\"\"\n    Solves the 1D diffusion-reaction PDE for a given numerical method.\n\n    Returns:\n        tuple: (final concentration profile, depletion time, positivity violation flag, monotonicity violation count)\n    \"\"\"\n    dx = L / (N - 1)\n    \n    # Build the spatial discretization matrix A\n    A = np.diag(np.full(N, -2.0)) + np.diag(np.ones(N - 1), 1) + np.diag(np.ones(N - 1), -1)\n    A[0, 1] = 2.0\n    A[N - 1, N - 2] = 2.0\n    A *= D / (dx**2)\n\n    # Time integration setup\n    num_steps = int(round(T / dt))\n    time_points = np.linspace(0, T, num_steps + 1)\n\n    # Initial condition\n    c_current = np.full(N, c0, dtype=float)\n\n    # Sink term function\n    def s(t):\n        return s0 if t_on = t  t_off else 0.0\n\n    # Initialize metrics\n    depletion_time = T\n    positivity_violation = 0\n    monotonicity_violation_count = 0\n    \n    # Pre-compute matrices for linear solves\n    M_IE, M_CN_L, M_CN_R, M_BDF2 = None, None, None, None\n    if method == \"IE\" or (method == \"BDF2\"): # BDF2 uses IE for startup\n        M_IE = np.identity(N) - dt * A\n    if method == \"CN\":\n        M_CN_L = np.identity(N) - (dt / 2.0) * A\n        M_CN_R = np.identity(N) + (dt / 2.0) * A\n    if method == \"BDF2\":\n        M_BDF2 = np.identity(N) - (2.0 * dt / 3.0) * A\n    \n    c_prev = None  # For BDF2\n\n    # Time-stepping loop\n    for k in range(num_steps):\n        t_current = time_points[k]\n        t_next = time_points[k+1]\n        \n        s_current_val = s(t_current)\n        s_next_val = s(t_next)\n\n        min_c_before_step = np.min(c_current)\n\n        if method == \"IE\":\n            rhs = c_current - dt * s_next_val\n            c_next = np.linalg.solve(M_IE, rhs)\n        \n        elif method == \"CN\":\n            s_avg = (s_current_val + s_next_val) / 2.0\n            rhs = M_CN_R @ c_current - dt * s_avg\n            c_next = np.linalg.solve(M_CN_L, rhs)\n\n        elif method == \"BDF2\":\n            if k == 0:\n                # First step with Implicit Euler\n                rhs_ie = c_current - dt * s_next_val\n                c_next = np.linalg.solve(M_IE, rhs_ie)\n            else:\n                # Subsequent steps with BDF2\n                rhs = (4.0/3.0) * c_current - (1.0/3.0) * c_prev - (2.0 * dt / 3.0) * s_next_val\n                c_next = np.linalg.solve(M_BDF2, rhs)\n            c_prev = c_current.copy()\n        else: # Should not happen\n            c_next = c_current\n\n        # Update state\n        c_current = c_next\n\n        # Check metrics\n        if np.min(c_current)  c_min_star and depletion_time == T:\n            depletion_time = t_next\n        if np.any(c_current  0):\n            positivity_violation = 1\n        \n        if t_on = t_current  t_off:\n            if np.min(c_current) > min_c_before_step:\n                monotonicity_violation_count += 1\n\n    return c_current, depletion_time, positivity_violation, monotonicity_violation_count\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (D, L, N, T, dt, s0, t_on, t_off, c0, c_min_star)\n        (2.0e-10, 1.0e-4, 50, 2.0, 0.02, 50.0, 0.5, 1.5, 1000.0, 800.0), # Case A\n        (1.0e-10, 1.0e-4, 60, 2.0, 0.2, 300.0, 0.4, 1.8, 1000.0, 700.0), # Case B\n        (5.0e-11, 1.5e-4, 40, 1.5, 0.05, 600.0, 0.2, 0.8, 1200.0, 900.0), # Case C\n    ]\n\n    all_results = []\n    \n    for case_params in test_cases:\n        D, L, N, T, dt, s0, t_on, t_off, c0, c_min_star = case_params\n        N = int(N)\n\n        # 1. Compute reference solution\n        dt_ref = 1e-3\n        c_ref_T, tau_dep_ref, _, _ = run_simulation(\n            \"IE\", D, L, N, T, dt_ref, s0, t_on, t_off, c0, c_min_star\n        )\n        norm_c_ref_T = np.linalg.norm(c_ref_T)\n        \n        methods = [\"IE\", \"CN\", \"BDF2\"]\n        for method in methods:\n            # 2. Run simulation for the current method\n            c_M_T, tau_dep_M, pos_viol_M, mono_count_M = run_simulation(\n                method, D, L, N, T, dt, s0, t_on, t_off, c0, c_min_star\n            )\n            \n            # 3. Compute metrics\n            dep_err = abs(tau_dep_M - tau_dep_ref)\n            \n            if norm_c_ref_T > 1e-12:\n                rel_L2_err = np.linalg.norm(c_M_T - c_ref_T) / norm_c_ref_T\n            elif np.linalg.norm(c_M_T - c_ref_T)  1e-12:\n                rel_L2_err = 0.0\n            else: # Should not happen in this problem\n                rel_L2_err = np.linalg.norm(c_M_T - c_ref_T)\n\n            # Append results for this method\n            all_results.extend([dep_err, rel_L2_err, pos_viol_M, mono_count_M])\n\n    # Final print statement\n    formatted_results = [f'{x:.6f}' if isinstance(x, float) else str(x) for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A robust time integration scheme is only one piece of the puzzle; accurate simulation also demands adequate spatial resolution. This practice shifts the focus to the grid, investigating how mesh density affects the solution's accuracy, particularly when capturing steep gradients common near electrode-separator interfaces. By performing a convergence study on a model with a localized concentration sink, you will learn a fundamental technique for verifying that your numerical solution is a faithful representation of the underlying physical phenomenon. ",
            "id": "3933739",
            "problem": "Consider a one-dimensional electrolyte transport problem in a lithium-ion battery domain formulated to capture steep gradients near a separator. Let the spatial domain be $x \\in [0,L]$ with $L$ in meters, and the time domain be $t \\in [0,t_{\\mathrm{peak}}]$ with $t_{\\mathrm{peak}}$ in seconds. The electrolyte concentration field $c_e(x,t)$, in units of $\\mathrm{mol/m^3}$, evolves under mass conservation and Fickian diffusion with a localized volumetric consumption term, governed by the Partial Differential Equation (PDE)\n$$\n\\frac{\\partial c_e}{\\partial t} = D_e \\frac{\\partial^2 c_e}{\\partial x^2} + S(x) f(t),\n$$\nwhere $D_e$ is the electrolyte diffusivity (in $\\mathrm{m^2/s}$), $S(x)$ is a spatially localized source term (in $\\mathrm{mol/(m^3 \\cdot s)}$), and $f(t)$ is a scalar time modulation (dimensionless) representing a transient peak current event. Assume no-flux boundary conditions,\n$$\n\\frac{\\partial c_e}{\\partial x}(0,t) = 0, \\quad \\frac{\\partial c_e}{\\partial x}(L,t) = 0,\n$$\nand uniform initial condition\n$$\nc_e(x,0) = c_0.\n$$\nTo model steep electrolyte gradients near the separator, set the separator location at $x_{\\mathrm{sep}} = L/2$, and define the spatial source profile as a narrow Gaussian centered at $x_{\\mathrm{sep}}$,\n$$\nS(x) = -A_s \\exp\\left( -\\frac{(x - x_{\\mathrm{sep}})^2}{2 \\sigma_x^2} \\right),\n$$\nwith amplitude $A_s$ in $\\mathrm{mol/(m^3 \\cdot s)}$ and spatial width $\\sigma_x$ in meters. The peak current is represented by a time-Gaussian modulation peaked at $t_{\\mathrm{peak}}$,\n$$\nf(t) = \\exp\\left( -\\frac{(t - t_{\\mathrm{peak}})^2}{2 \\sigma_t^2} \\right),\n$$\nwith temporal width $\\sigma_t$ in seconds. This setup produces a physically realistic, localized depletion of $c_e$ near the separator around the peak current time.\n\nStarting from the governing PDE, appropriate boundary and initial conditions, and fundamental definitions (mass conservation, Fickian diffusion flux $J = -D_e \\frac{\\partial c_e}{\\partial x}$), discretize the problem on a uniform spatial grid with spacing $\\Delta x$ and use a time step $\\Delta t$ to integrate from $t=0$ to $t=t_{\\mathrm{peak}}$. Use an unconditionally stable, second-order accurate in time method to advance the solution, and enforce the no-flux conditions consistently in the discrete second-derivative operator. For each spatial resolution $\\Delta x$, compute the electrolyte concentration at the separator location, $c_e(x_{\\mathrm{sep}}, t_{\\mathrm{peak}})$, by linear interpolation on the numerical grid.\n\nDefine the reference solution $c_e^{\\mathrm{ref}}(x_{\\mathrm{sep}}, t_{\\mathrm{peak}})$ as the numerical solution computed with a very fine mesh spacing $\\Delta x_{\\mathrm{ref}}$ and the same time discretization. For each test case mesh spacing $\\Delta x$, compute the absolute error at peak current\n$$\nE(\\Delta x) = \\left| c_e(x_{\\mathrm{sep}}, t_{\\mathrm{peak}}; \\Delta x) - c_e^{\\mathrm{ref}}(x_{\\mathrm{sep}}, t_{\\mathrm{peak}}; \\Delta x_{\\mathrm{ref}}) \\right|.\n$$\nYou must express the final errors $E(\\Delta x)$ in units of $\\mathrm{mol/m^3}$, rounded to six decimal places.\n\nUse the following scientifically plausible parameter values: $L = 1.0 \\times 10^{-4} \\ \\mathrm{m}$, $x_{\\mathrm{sep}} = L/2$, $D_e = 1.0 \\times 10^{-10} \\ \\mathrm{m^2/s}$, $c_0 = 1000 \\ \\mathrm{mol/m^3}$, $A_s = 50 \\ \\mathrm{mol/(m^3 \\cdot s)}$, $\\sigma_x = 5.0 \\times 10^{-6} \\ \\mathrm{m}$, $t_{\\mathrm{peak}} = 10.0 \\ \\mathrm{s}$, $\\sigma_t = 2.0 \\ \\mathrm{s}$, and a uniform time step $\\Delta t = 0.05 \\ \\mathrm{s}$. The reference mesh spacing is $\\Delta x_{\\mathrm{ref}} = 6.25 \\times 10^{-7} \\ \\mathrm{m}$.\n\nTest Suite:\n- Case 1 (happy path): $\\Delta x = 2.0 \\times 10^{-5} \\ \\mathrm{m}$.\n- Case 2 (moderate resolution): $\\Delta x = 1.0 \\times 10^{-5} \\ \\mathrm{m}$.\n- Case 3 (near-gradient-scale): $\\Delta x = 5.0 \\times 10^{-6} \\ \\mathrm{m}$.\n- Case 4 (fine): $\\Delta x = 2.5 \\times 10^{-6} \\ \\mathrm{m}$.\n- Case 5 (very fine): $\\Delta x = 1.25 \\times 10^{-6} \\ \\mathrm{m}$.\n\nAngle units are not applicable. Percentages are not applicable.\n\nYour program should produce a single line of output containing the errors for the five test cases as a comma-separated list enclosed in square brackets, with each error rounded to six decimal places and expressed in $\\mathrm{mol/m^3}$, for example, \"[e1,e2,e3,e4,e5]\".",
            "solution": "The user has provided a well-posed problem statement for a one-dimensional transient diffusion-reaction process, which is scientifically grounded in the physics of electrolyte transport in batteries. The problem is complete, with all necessary parameters, initial conditions, and boundary conditions specified. The task is to perform a numerical convergence study by solving the governing Partial Differential Equation (PDE) for several spatial grid resolutions and comparing the results to a high-resolution reference solution. The problem is valid.\n\nThe governing PDE for the electrolyte concentration $c_e(x,t)$ is:\n$$\n\\frac{\\partial c_e}{\\partial t} = D_e \\frac{\\partial^2 c_e}{\\partial x^2} + S(x) f(t)\n$$\nsubject to the initial condition $c_e(x,0) = c_0$ and no-flux boundary conditions $\\frac{\\partial c_e}{\\partial x}(0,t) = 0$ and $\\frac{\\partial c_e}{\\partial x}(L,t) = 0$.\n\nThe solution approach employs the Method of Lines (MOL), where the spatial domain is first discretized, converting the PDE into a system of coupled Ordinary Differential Equations (ODEs) in time. This system is then integrated using a suitable numerical time-stepping scheme.\n\n**1. Spatial Discretization**\nThe spatial domain $x \\in [0, L]$ is discretized into a uniform grid with $N_x$ intervals of spacing $\\Delta x = L/N_x$. The grid points are $x_i = i \\Delta x$ for $i = 0, 1, \\dots, N_x$. The concentration at a grid point $x_i$ and time $t$ is denoted as $c_i(t) \\approx c_e(x_i, t)$.\n\nThe second spatial derivative, the Laplacian term, is approximated using a second-order accurate central difference stencil:\n$$\n\\frac{\\partial^2 c_e}{\\partial x^2} \\bigg|_{x_i} \\approx \\frac{c_{i-1}(t) - 2c_i(t) + c_{i+1}(t)}{\\Delta x^2}\n$$\nfor the interior grid points $i=1, 2, \\dots, N_x-1$.\n\n**2. Boundary Condition Enforcement**\nThe no-flux (homogeneous Neumann) boundary conditions are enforced using the method of \"ghost points,\" which preserves the second-order accuracy of the spatial scheme.\nAt the left boundary ($x_0=0$), the condition $\\frac{\\partial c_e}{\\partial x}(0,t) = 0$ is discretized as $\\frac{c_1 - c_{-1}}{2\\Delta x} = 0$, implying the ghost point concentration is $c_{-1} = c_1$. Substituting this into the central difference stencil for $i=0$ yields:\n$$\n\\frac{\\partial^2 c_e}{\\partial x^2} \\bigg|_{x_0} \\approx \\frac{c_{-1} - 2c_0 + c_1}{\\Delta x^2} = \\frac{2c_1 - 2c_0}{\\Delta x^2}\n$$\nSimilarly, at the right boundary ($x_{N_x}=L$), the condition implies $c_{N_x+1} = c_{N_x-1}$, leading to the approximation:\n$$\n\\frac{\\partial^2 c_e}{\\partial x^2} \\bigg|_{x_{N_x}} \\approx \\frac{c_{N_x-1} - 2c_{N_x} + c_{N_x+1}}{\\Delta x^2} = \\frac{2c_{N_x-1} - 2c_{N_x}}{\\Delta x^2}\n$$\n\nLetting $\\vec{c}(t) = [c_0(t), c_1(t), \\dots, c_{N_x}(t)]^T$ be the vector of concentrations at the grid points, the discretized PDE system can be written in matrix form:\n$$\n\\frac{d\\vec{c}}{dt} = \\frac{D_e}{\\Delta x^2} \\mathbf{L} \\vec{c} + \\vec{S} f(t)\n$$\nwhere $\\mathbf{L}$ is the $(N_x+1) \\times (N_x+1)$ tridiagonal matrix representing the discrete Laplacian with Neumann boundary conditions, and $\\vec{S}$ is the vector of the spatial source term values at each grid point.\n\n**3. Time Integration**\nThe problem requires an unconditionally stable, second-order accurate method in time. The Crank-Nicolson method is an ideal choice. Applying this method to the semi-discretized system gives:\n$$\n\\frac{\\vec{c}^{n+1} - \\vec{c}^n}{\\Delta t} = \\frac{1}{2} \\left[ \\left(\\mathbf{A}\\vec{c}^{n+1} + \\vec{g}(t^{n+1})\\right) + \\left(\\mathbf{A}\\vec{c}^n + \\vec{g}(t^n)\\right) \\right]\n$$\nwhere $\\vec{c}^n$ is the solution at time $t^n = n\\Delta t$, $\\mathbf{A} = \\frac{D_e}{\\Delta x^2} \\mathbf{L}$, and $\\vec{g}(t) = \\vec{S}f(t)$.\n\nRearranging to solve for the unknown concentration vector $\\vec{c}^{n+1}$ at the next time step, we obtain a linear system of equations:\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right) \\vec{c}^{n+1} = \\left(\\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{A}\\right) \\vec{c}^n + \\frac{\\Delta t}{2} \\left(\\vec{g}(t^{n+1}) + \\vec{g}(t^n)\\right)\n$$\nwhere $\\mathbf{I}$ is the identity matrix. The matrix on the left-hand side, $\\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right)$, is tridiagonal. Such systems can be solved very efficiently at each time step using the Thomas algorithm (tridiagonal matrix algorithm), which is readily available in numerical libraries like SciPy.\n\n**4. Implementation and Error Calculation**\nThe numerical solution is implemented by first setting up the spatial grid and initial concentration profile. The time integration proceeds in a loop from $t=0$ to $t=t_{\\mathrm{peak}}$. In each step, the right-hand side vector is computed, and the tridiagonal linear system is solved to find the concentration for the next time step.\n\nAfter the final time step, the solution vector $\\vec{c}$ represents the concentration profile $c_e(x, t_{\\mathrm{peak}})$. The concentration at the specific location $x_{\\mathrm{sep}} = L/2$ is found using linear interpolation on the final grid values.\n\nA reference solution $c_e^{\\mathrm{ref}}(x_{\\mathrm{sep}}, t_{\\mathrm{peak}})$ is first computed using the very fine reference mesh spacing $\\Delta x_{\\mathrm{ref}}$. Then, for each test case $\\Delta x$, the corresponding numerical solution $c_e(x_{\\mathrm{sep}}, t_{\\mathrm{peak}}; \\Delta x)$ is computed. The absolute error is calculated as specified:\n$$\nE(\\Delta x) = \\left| c_e(x_{\\mathrm{sep}}, t_{\\mathrm{peak}}; \\Delta x) - c_e^{\\mathrm{ref}}(x_{\\mathrm{sep}}, t_{\\mathrm{peak}}; \\Delta x_{\\mathrm{ref}}) \\right|\n$$\nThe resulting errors for the five test cases are then formatted as requested.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves a 1D transient diffusion PDE for a battery electrolyte concentration\n    and computes the numerical error for different spatial resolutions.\n    \"\"\"\n    #\n    # Global Parameters\n    #\n    L = 1.0e-4           # m, domain length\n    D_e = 1.0e-10        # m^2/s, electrolyte diffusivity\n    c_0 = 1000.0         # mol/m^3, initial concentration\n    A_s = 50.0           # mol/(m^3*s), source amplitude\n    sigma_x = 5.0e-6     # m, spatial width of source\n    t_peak = 10.0        # s, peak time\n    sigma_t = 2.0        # s, temporal width of source\n    delta_t = 0.05       # s, time step\n    x_sep = L / 2.0      # m, separator location\n    \n    #\n    # Test Suite Parameters\n    #\n    delta_x_ref = 6.25e-7  # m, reference mesh spacing\n    test_delta_x = [2.0e-5, 1.0e-5, 5.0e-6, 2.5e-6, 1.25e-6]\n\n    #\n    # Helper Functions\n    #\n    def S_func(x):\n        \"\"\"Spatial source term profile.\"\"\"\n        return -A_s * np.exp(-(x - x_sep)**2 / (2 * sigma_x**2))\n\n    def f_func(t):\n        \"\"\"Temporal modulation of the source term.\"\"\"\n        return np.exp(-(t - t_peak)**2 / (2 * sigma_t**2))\n\n    def solve_pde(delta_x):\n        \"\"\"\n        Solves the PDE for a given spatial step dx using Crank-Nicolson method.\n        Returns the interpolated concentration at x_sep and t_peak.\n        \"\"\"\n        # 1. Grid Setup\n        Nx = int(round(L / delta_x))\n        x_grid = np.linspace(0, L, Nx + 1)\n        \n        t_steps = int(round(t_peak / delta_t))\n        \n        # 2. Initial Condition\n        c = np.full(Nx + 1, c_0)\n        \n        # 3. Pre-compute constant terms\n        S_vec = S_func(x_grid)\n        alpha = D_e * delta_t / (2 * delta_x**2)\n        \n        # 4. Construct Crank-Nicolson LHS matrix (for solve_banded)\n        # This matrix is (I - alpha * L), where L is the discrete Laplacian.\n        M_lhs_banded = np.zeros((3, Nx + 1))\n        # Main diagonal\n        M_lhs_banded[1, :] = 1 + 2 * alpha\n        # Upper diagonal\n        M_lhs_banded[0, 1:] = -alpha\n        # Lower diagonal\n        M_lhs_banded[2, :-1] = -alpha\n        # Apply Neumann BCs\n        M_lhs_banded[0, 1] = -2 * alpha\n        M_lhs_banded[2, Nx - 1] = -2 * alpha\n        \n        # 5. Time Integration Loop\n        for n in range(t_steps):\n            t_n = n * delta_t\n            t_n_plus_1 = (n + 1) * delta_t\n            \n            # Construct RHS vector: b = (I + alpha*L)*c_n + source_term\n            # 5a. Diffusion part: (I + alpha*L) * c_n\n            rhs_diff = np.zeros(Nx + 1)\n            # Interior points\n            rhs_diff[1:-1] = alpha * c[:-2] + (1 - 2*alpha) * c[1:-1] + alpha * c[2:]\n            # Boundary points (Neumann)\n            rhs_diff[0]  = (1 - 2*alpha) * c[0] + 2*alpha * c[1]\n            rhs_diff[-1] = 2*alpha * c[-2] + (1 - 2*alpha) * c[-1]\n            \n            # 5b. Source part\n            source_contribution = (delta_t / 2) * S_vec * \\\n                                  (f_func(t_n) + f_func(t_n_plus_1))\n            \n            # 5c. Total RHS\n            b = rhs_diff + source_contribution\n            \n            # 5d. Solve the tridiagonal system for the next time step\n            c = solve_banded((1, 1), M_lhs_banded, b)\n            \n        # 6. Interpolate final result at the separator location\n        c_at_sep = np.interp(x_sep, x_grid, c)\n        \n        return c_at_sep\n\n    #\n    # Main Execution Logic\n    #\n    \n    # Compute the reference solution\n    c_ref = solve_pde(delta_x_ref)\n    \n    results = []\n    # Loop through test cases, compute solution and error\n    for dx in test_delta_x:\n        c_test = solve_pde(dx)\n        error = abs(c_test - c_ref)\n        results.append(error)\n\n    # Format output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}