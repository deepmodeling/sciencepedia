{
    "hands_on_practices": [
        {
            "introduction": "Accurately simulating battery performance often hinges on resolving steep concentration gradients that form near electrodes and separators. This exercise provides hands-on practice in performing a mesh convergence study, a critical skill for validating the spatial accuracy of a numerical model. By analyzing the error in electrolyte concentration as a function of grid spacing, you will develop an intuition for the mesh resolution required to capture localized physical phenomena .",
            "id": "3933739",
            "problem": "Consider a one-dimensional electrolyte transport problem in a lithium-ion battery domain formulated to capture steep gradients near a separator. Let the spatial domain be $x \\in [0,L]$ with $L$ in meters, and the time domain be $t \\in [0,t_{\\mathrm{peak}}]$ with $t_{\\mathrm{peak}}$ in seconds. The electrolyte concentration field $c_e(x,t)$, in units of $\\mathrm{mol/m^3}$, evolves under mass conservation and Fickian diffusion with a localized volumetric consumption term, governed by the Partial Differential Equation (PDE)\n$$\n\\frac{\\partial c_e}{\\partial t} = D_e \\frac{\\partial^2 c_e}{\\partial x^2} + S(x) f(t),\n$$\nwhere $D_e$ is the electrolyte diffusivity (in $\\mathrm{m^2/s}$), $S(x)$ is a spatially localized source term (in $\\mathrm{mol/(m^3 \\cdot s)}$), and $f(t)$ is a scalar time modulation (dimensionless) representing a transient peak current event. Assume no-flux boundary conditions,\n$$\n\\frac{\\partial c_e}{\\partial x}(0,t) = 0, \\quad \\frac{\\partial c_e}{\\partial x}(L,t) = 0,\n$$\nand uniform initial condition\n$$\nc_e(x,0) = c_0.\n$$\nTo model steep electrolyte gradients near the separator, set the separator location at $x_{\\mathrm{sep}} = L/2$, and define the spatial source profile as a narrow Gaussian centered at $x_{\\mathrm{sep}}$,\n$$\nS(x) = -A_s \\exp\\left( -\\frac{(x - x_{\\mathrm{sep}})^2}{2 \\sigma_x^2} \\right),\n$$\nwith amplitude $A_s$ in $\\mathrm{mol/(m^3 \\cdot s)}$ and spatial width $\\sigma_x$ in meters. The peak current is represented by a time-Gaussian modulation peaked at $t_{\\mathrm{peak}}$,\n$$\nf(t) = \\exp\\left( -\\frac{(t - t_{\\mathrm{peak}})^2}{2 \\sigma_t^2} \\right),\n$$\nwith temporal width $\\sigma_t$ in seconds. This setup produces a physically realistic, localized depletion of $c_e$ near the separator around the peak current time.\n\nStarting from the governing PDE, appropriate boundary and initial conditions, and fundamental definitions (mass conservation, Fickian diffusion flux $J = -D_e \\frac{\\partial c_e}{\\partial x}$), discretize the problem on a uniform spatial grid with spacing $\\Delta x$ and use a time step $\\Delta t$ to integrate from $t=0$ to $t=t_{\\mathrm{peak}}$. Use an unconditionally stable, second-order accurate in time method to advance the solution, and enforce the no-flux conditions consistently in the discrete second-derivative operator. For each spatial resolution $\\Delta x$, compute the electrolyte concentration at the separator location, $c_e(x_{\\mathrm{sep}}, t_{\\mathrm{peak}})$, by linear interpolation on the numerical grid.\n\nDefine the reference solution $c_e^{\\mathrm{ref}}(x_{\\mathrm{sep}}, t_{\\mathrm{peak}})$ as the numerical solution computed with a very fine mesh spacing $\\Delta x_{\\mathrm{ref}}$ and the same time discretization. For each test case mesh spacing $\\Delta x$, compute the absolute error at peak current\n$$\nE(\\Delta x) = \\left| c_e(x_{\\mathrm{sep}}, t_{\\mathrm{peak}}; \\Delta x) - c_e^{\\mathrm{ref}}(x_{\\mathrm{sep}}, t_{\\mathrm{peak}}; \\Delta x_{\\mathrm{ref}}) \\right|.\n$$\nYou must express the final errors $E(\\Delta x)$ in units of $\\mathrm{mol/m^3}$, rounded to six decimal places.\n\nUse the following scientifically plausible parameter values: $L = 1.0 \\times 10^{-4} \\ \\mathrm{m}$, $x_{\\mathrm{sep}} = L/2$, $D_e = 1.0 \\times 10^{-10} \\ \\mathrm{m^2/s}$, $c_0 = 1000 \\ \\mathrm{mol/m^3}$, $A_s = 50 \\ \\mathrm{mol/(m^3 \\cdot s)}$, $\\sigma_x = 5.0 \\times 10^{-6} \\ \\mathrm{m}$, $t_{\\mathrm{peak}} = 10.0 \\ \\mathrm{s}$, $\\sigma_t = 2.0 \\ \\mathrm{s}$, and a uniform time step $\\Delta t = 0.05 \\ \\mathrm{s}$. The reference mesh spacing is $\\Delta x_{\\mathrm{ref}} = 6.25 \\times 10^{-7} \\ \\mathrm{m}$.\n\nTest Suite:\n- Case 1 (happy path): $\\Delta x = 2.0 \\times 10^{-5} \\ \\mathrm{m}$.\n- Case 2 (moderate resolution): $\\Delta x = 1.0 \\times 10^{-5} \\ \\mathrm{m}$.\n- Case 3 (near-gradient-scale): $\\Delta x = 5.0 \\times 10^{-6} \\ \\mathrm{m}$.\n- Case 4 (fine): $\\Delta x = 2.5 \\times 10^{-6} \\ \\mathrm{m}$.\n- Case 5 (very fine): $\\Delta x = 1.25 \\times 10^{-6} \\ \\mathrm{m}$.\n\nAngle units are not applicable. Percentages are not applicable.\n\nYour program should produce a single line of output containing the errors for the five test cases as a comma-separated list enclosed in square brackets, with each error rounded to six decimal places and expressed in $\\mathrm{mol/m^3}$, for example, [e1,e2,e3,e4,e5].",
            "solution": "The user has provided a well-posed problem statement for a one-dimensional transient diffusion-reaction process, which is scientifically grounded in the physics of electrolyte transport in batteries. The problem is complete, with all necessary parameters, initial conditions, and boundary conditions specified. The task is to perform a numerical convergence study by solving the governing Partial Differential Equation (PDE) for several spatial grid resolutions and comparing the results to a high-resolution reference solution. The problem is valid.\n\nThe governing PDE for the electrolyte concentration $c_e(x,t)$ is:\n$$\n\\frac{\\partial c_e}{\\partial t} = D_e \\frac{\\partial^2 c_e}{\\partial x^2} + S(x) f(t)\n$$\nsubject to the initial condition $c_e(x,0) = c_0$ and no-flux boundary conditions $\\frac{\\partial c_e}{\\partial x}(0,t) = 0$ and $\\frac{\\partial c_e}{\\partial x}(L,t) = 0$.\n\nThe solution approach employs the Method of Lines (MOL), where the spatial domain is first discretized, converting the PDE into a system of coupled Ordinary Differential Equations (ODEs) in time. This system is then integrated using a suitable numerical time-stepping scheme.\n\n**1. Spatial Discretization**\nThe spatial domain $x \\in [0, L]$ is discretized into a uniform grid with $N_x$ intervals of spacing $\\Delta x = L/N_x$. The grid points are $x_i = i \\Delta x$ for $i = 0, 1, \\dots, N_x$. The concentration at a grid point $x_i$ and time $t$ is denoted as $c_i(t) \\approx c_e(x_i, t)$.\n\nThe second spatial derivative, the Laplacian term, is approximated using a second-order accurate central difference stencil:\n$$\n\\frac{\\partial^2 c_e}{\\partial x^2} \\bigg|_{x_i} \\approx \\frac{c_{i-1}(t) - 2c_i(t) + c_{i+1}(t)}{\\Delta x^2}\n$$\nfor the interior grid points $i=1, 2, \\dots, N_x-1$.\n\n**2. Boundary Condition Enforcement**\nThe no-flux (homogeneous Neumann) boundary conditions are enforced using the method of \"ghost points,\" which preserves the second-order accuracy of the spatial scheme.\nAt the left boundary ($x_0=0$), the condition $\\frac{\\partial c_e}{\\partial x}(0,t) = 0$ is discretized as $\\frac{c_1 - c_{-1}}{2\\Delta x} = 0$, implying the ghost point concentration is $c_{-1} = c_1$. Substituting this into the central difference stencil for $i=0$ yields:\n$$\n\\frac{\\partial^2 c_e}{\\partial x^2} \\bigg|_{x_0} \\approx \\frac{c_{-1} - 2c_0 + c_1}{\\Delta x^2} = \\frac{2c_1 - 2c_0}{\\Delta x^2}\n$$\nSimilarly, at the right boundary ($x_{N_x}=L$), the condition implies $c_{N_x+1} = c_{N_x-1}$, leading to the approximation:\n$$\n\\frac{\\partial^2 c_e}{\\partial x^2} \\bigg|_{x_{N_x}} \\approx \\frac{c_{N_x-1} - 2c_{N_x} + c_{N_x+1}}{\\Delta x^2} = \\frac{2c_{N_x-1} - 2c_{N_x}}{\\Delta x^2}\n$$\n\nLetting $\\vec{c}(t) = [c_0(t), c_1(t), \\dots, c_{N_x}(t)]^T$ be the vector of concentrations at the grid points, the discretized PDE system can be written in matrix form:\n$$\n\\frac{d\\vec{c}}{dt} = \\frac{D_e}{\\Delta x^2} \\mathbf{L} \\vec{c} + \\vec{S} f(t)\n$$\nwhere $\\mathbf{L}$ is the $(N_x+1) \\times (N_x+1)$ tridiagonal matrix representing the discrete Laplacian with Neumann boundary conditions, and $\\vec{S}$ is the vector of the spatial source term values at each grid point.\n\n**3. Time Integration**\nThe problem requires an unconditionally stable, second-order accurate method in time. The Crank-Nicolson method is an ideal choice. Applying this method to the semi-discretized system gives:\n$$\n\\frac{\\vec{c}^{n+1} - \\vec{c}^n}{\\Delta t} = \\frac{1}{2} \\left[ \\left(\\mathbf{A}\\vec{c}^{n+1} + \\vec{g}(t^{n+1})\\right) + \\left(\\mathbf{A}\\vec{c}^n + \\vec{g}(t^n)\\right) \\right]\n$$\nwhere $\\vec{c}^n$ is the solution at time $t^n = n\\Delta t$, $\\mathbf{A} = \\frac{D_e}{\\Delta x^2} \\mathbf{L}$, and $\\vec{g}(t) = \\vec{S}f(t)$.\n\nRearranging to solve for the unknown concentration vector $\\vec{c}^{n+1}$ at the next time step, we obtain a linear system of equations:\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right) \\vec{c}^{n+1} = \\left(\\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{A}\\right) \\vec{c}^n + \\frac{\\Delta t}{2} \\left(\\vec{g}(t^{n+1}) + \\vec{g}(t^n)\\right)\n$$\nwhere $\\mathbf{I}$ is the identity matrix. The matrix on the left-hand side, $\\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right)$, is tridiagonal. Such systems can be solved very efficiently at each time step using the Thomas algorithm (tridiagonal matrix algorithm), which is readily available in numerical libraries like SciPy.\n\n**4. Implementation and Error Calculation**\nThe numerical solution is implemented by first setting up the spatial grid and initial concentration profile. The time integration proceeds in a loop from $t=0$ to $t=t_{\\mathrm{peak}}$. In each step, the right-hand side vector is computed, and the tridiagonal linear system is solved to find the concentration for the next time step.\n\nAfter the final time step, the solution vector $\\vec{c}$ represents the concentration profile $c_e(x, t_{\\mathrm{peak}})$. The concentration at the specific location $x_{\\mathrm{sep}} = L/2$ is found using linear interpolation on the final grid values.\n\nA reference solution $c_e^{\\mathrm{ref}}(x_{\\mathrm{sep}}, t_{\\mathrm{peak}})$ is first computed using the very fine reference mesh spacing $\\Delta x_{\\mathrm{ref}}$. Then, for each test case $\\Delta x$, the corresponding numerical solution $c_e(x_{\\mathrm{sep}}, t_{\\mathrm{peak}}; \\Delta x)$ is computed. The absolute error is calculated as specified:\n$$\nE(\\Delta x) = \\left| c_e(x_{\\mathrm{sep}}, t_{\\mathrm{peak}}; \\Delta x) - c_e^{\\mathrm{ref}}(x_{\\mathrm{sep}}, t_{\\mathrm{peak}}; \\Delta x_{\\mathrm{ref}}) \\right|\n$$\nThe resulting errors for the five test cases are then formatted as requested.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves a 1D transient diffusion PDE for a battery electrolyte concentration\n    and computes the numerical error for different spatial resolutions.\n    \"\"\"\n    #\n    # Global Parameters\n    #\n    L = 1.0e-4           # m, domain length\n    D_e = 1.0e-10        # m^2/s, electrolyte diffusivity\n    c_0 = 1000.0         # mol/m^3, initial concentration\n    A_s = 50.0           # mol/(m^3*s), source amplitude\n    sigma_x = 5.0e-6     # m, spatial width of source\n    t_peak = 10.0        # s, peak time\n    sigma_t = 2.0        # s, temporal width of source\n    delta_t = 0.05       # s, time step\n    x_sep = L / 2.0      # m, separator location\n    \n    #\n    # Test Suite Parameters\n    #\n    delta_x_ref = 6.25e-7  # m, reference mesh spacing\n    test_delta_x = [2.0e-5, 1.0e-5, 5.0e-6, 2.5e-6, 1.25e-6]\n\n    #\n    # Helper Functions\n    #\n    def S_func(x):\n        \"\"\"Spatial source term profile.\"\"\"\n        return -A_s * np.exp(-(x - x_sep)**2 / (2 * sigma_x**2))\n\n    def f_func(t):\n        \"\"\"Temporal modulation of the source term.\"\"\"\n        return np.exp(-(t - t_peak)**2 / (2 * sigma_t**2))\n\n    def solve_pde(delta_x):\n        \"\"\"\n        Solves the PDE for a given spatial step dx using Crank-Nicolson method.\n        Returns the interpolated concentration at x_sep and t_peak.\n        \"\"\"\n        # 1. Grid Setup\n        Nx = int(round(L / delta_x))\n        x_grid = np.linspace(0, L, Nx + 1)\n        \n        t_steps = int(round(t_peak / delta_t))\n        \n        # 2. Initial Condition\n        c = np.full(Nx + 1, c_0)\n        \n        # 3. Pre-compute constant terms\n        S_vec = S_func(x_grid)\n        alpha = D_e * delta_t / (2 * delta_x**2)\n        \n        # 4. Construct Crank-Nicolson LHS matrix (for solve_banded)\n        # This matrix is (I - alpha * L), where L is the discrete Laplacian.\n        M_lhs_banded = np.zeros((3, Nx + 1))\n        # Main diagonal\n        M_lhs_banded[1, :] = 1 + 2 * alpha\n        # Upper diagonal\n        M_lhs_banded[0, 1:] = -alpha\n        # Lower diagonal\n        M_lhs_banded[2, :-1] = -alpha\n        # Apply Neumann BCs\n        M_lhs_banded[0, 1] = -2 * alpha\n        M_lhs_banded[2, Nx - 1] = -2 * alpha\n        \n        # 5. Time Integration Loop\n        for n in range(t_steps):\n            t_n = n * delta_t\n            t_n_plus_1 = (n + 1) * delta_t\n            \n            # Construct RHS vector: b = (I + alpha*L)*c_n + source_term\n            # 5a. Diffusion part: (I + alpha*L) * c_n\n            rhs_diff = np.zeros(Nx + 1)\n            # Interior points\n            rhs_diff[1:-1] = alpha * c[:-2] + (1 - 2*alpha) * c[1:-1] + alpha * c[2:]\n            # Boundary points (Neumann)\n            rhs_diff[0]  = (1 - 2*alpha) * c[0] + 2*alpha * c[1]\n            rhs_diff[-1] = 2*alpha * c[-2] + (1 - 2*alpha) * c[-1]\n            \n            # 5b. Source part\n            source_contribution = (delta_t / 2) * S_vec * \\\n                                  (f_func(t_n) + f_func(t_n_plus_1))\n            \n            # 5c. Total RHS\n            b = rhs_diff + source_contribution\n            \n            # 5d. Solve the tridiagonal system for the next time step\n            c = solve_banded((1, 1), M_lhs_banded, b)\n            \n        # 6. Interpolate final result at the separator location\n        c_at_sep = np.interp(x_sep, x_grid, c)\n        \n        return c_at_sep\n\n    #\n    # Main Execution Logic\n    #\n    \n    # Compute the reference solution\n    c_ref = solve_pde(delta_x_ref)\n    \n    results = []\n    # Loop through test cases, compute solution and error\n    for dx in test_delta_x:\n        c_test = solve_pde(dx)\n        error = abs(c_test - c_ref)\n        results.append(error)\n\n    # Format output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The \"stiff\" nature of battery models, arising from widely varying timescales, makes the choice of a time integration scheme crucial for stability and accuracy. This practice challenges you to implement and compare three popular implicit methods: Implicit Euler, Crank-Nicolson, and BDF2. By evaluating their performance on a representative electrolyte depletion problem, you will gain insight into their respective trade-offs concerning accuracy, numerical stability, and the preservation of physical properties like positivity .",
            "id": "3933711",
            "problem": "Consider a one-dimensional electrolyte domain governed by mass conservation and Fickian diffusion. Let $c(x,t)$ denote the salt concentration in the electrolyte, measured in $\\mathrm{mol/m^3}$, over the spatial interval $x \\in [0,L]$ and time $t \\in [0,T]$. The evolution of $c(x,t)$ under a charging pulse is modeled by the parabolic partial differential equation (PDE)\n$$\n\\frac{\\partial c}{\\partial t}(x,t) \\;=\\; D \\,\\frac{\\partial^2 c}{\\partial x^2}(x,t) \\;-\\; s(t),\n$$\nwhere $D$ is the diffusion coefficient in $\\mathrm{m^2/s}$ and $s(t)$ is a uniform volumetric sink term in $\\mathrm{mol/(m^3\\cdot s)}$ that represents the net salt consumption during the charging pulse. The boundary conditions are zero-flux (Neumann) conditions,\n$$\n\\frac{\\partial c}{\\partial x}(0,t) \\;=\\; 0, \\qquad \\frac{\\partial c}{\\partial x}(L,t) \\;=\\; 0,\n$$\nand the initial condition is uniform,\n$$\nc(x,0) \\;=\\; c_0.\n$$\nThe charging pulse is represented by a piecewise-constant sink,\n$$\ns(t) \\;=\\; \n\\begin{cases}\ns_0, & t_{\\mathrm{on}} \\le t < t_{\\mathrm{off}},\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nStarting from the above physical laws and definitions, discretize the spatial domain using second-order central differences that enforce the zero-flux boundary conditions and derive the fully discrete time-stepping updates for the following three implicit methods:\n- Implicit Euler,\n- Crank–Nicolson,\n- Backward Differentiation Formula of order two (BDF2, defined as Backward Differentiation Formula (BDF) with polynomial coefficients that yield second-order accuracy).\n\nUse these updates to implement a numerical program that, for each method and each test case, advances the discrete concentration field, detects electrolyte depletion, and computes accuracy and stability metrics.\n\nDefinitions and metrics:\n- The electrolyte depletion threshold $c_{\\min,*}$ is a specified concentration in $\\mathrm{mol/m^3}$. Define the depletion time $\\tau_{\\mathrm{dep}}$ as the earliest time at which the spatial minimum of the discrete concentration first falls below $c_{\\min,*}$, using the discrete time grid. If depletion does not occur within $[0,T]$, set $\\tau_{\\mathrm{dep}}=T$.\n- The final-time relative $L^2$ error for a method $M$ is\n$$\n\\mathcal{E}_{L^2}(M) \\;=\\; \\frac{\\left\\|c_M(\\cdot,T) \\;-\\; c_{\\mathrm{ref}}(\\cdot,T)\\right\\|_2}{\\left\\|c_{\\mathrm{ref}}(\\cdot,T)\\right\\|_2},\n$$\nwhere $c_{\\mathrm{ref}}(\\cdot,T)$ is a high-fidelity reference solution computed by implicit Euler with time step $\\Delta t_{\\mathrm{ref}} = 10^{-3}\\,\\mathrm{s}$.\n- The depletion-time absolute error for a method $M$ is\n$$\n\\left|\\tau_{\\mathrm{dep}}(M) \\;-\\; \\tau_{\\mathrm{dep}}(\\mathrm{ref})\\right| \\quad \\text{in} \\quad \\mathrm{s}.\n$$\n- Positivity violation flag is an integer defined as $0$ if $c(x,t)\\ge 0$ for all nodes and time steps, and $1$ if any node becomes negative at any time step.\n- Monotonicity violation count during the pulse is the number of discrete time steps within the interval $[t_{\\mathrm{on}}, t_{\\mathrm{off}})$ for which the spatial minimum of the discrete concentration increases compared to the previous time step.\n\nScientific and numerical requirements:\n- Express all quantities in the specified units: $c$ in $\\mathrm{mol/m^3}$, $D$ in $\\mathrm{m^2/s}$, $L$ in $\\mathrm{m}$, $t$ in $\\mathrm{s}$, and $s(t)$ in $\\mathrm{mol/(m^3\\cdot s)}$.\n- Derive the discrete operators and updates from the PDE and boundary conditions without invoking shortcut formulas. The spatial operator must be consistent with the second derivative under zero-flux boundaries.\n- The time-stepping implementations must be fully implicit for the diffusion operator. Treat the source term consistently with each method’s temporal discretization.\n\nTest suite:\nImplement the program for the following three test cases, each defined by the tuple $(D, L, N, T, \\Delta t, s_0, t_{\\mathrm{on}}, t_{\\mathrm{off}}, c_0, c_{\\min,*})$:\n- Case $A$: $(2.0\\times 10^{-10},\\, 1.0\\times 10^{-4},\\, 50,\\, 2.0,\\, 0.02,\\, 50.0,\\, 0.5,\\, 1.5,\\, 1000.0,\\, 800.0)$\n- Case $B$: $(1.0\\times 10^{-10},\\, 1.0\\times 10^{-4},\\, 60,\\, 2.0,\\, 0.2,\\, 300.0,\\, 0.4,\\, 1.8,\\, 1000.0,\\, 700.0)$\n- Case $C$: $(5.0\\times 10^{-11},\\, 1.5\\times 10^{-4},\\, 40,\\, 1.5,\\, 0.05,\\, 600.0,\\, 0.2,\\, 0.8,\\, 1200.0,\\, 900.0)$\n\nFor each test case, compute the high-fidelity reference with implicit Euler time step $\\Delta t_{\\mathrm{ref}} = 10^{-3}$ and then run the three methods with the specified $\\Delta t$ for that case. For each method and case, compute:\n- Depletion-time absolute error in $\\mathrm{s}$,\n- Final-time relative $L^2$ error (dimensionless),\n- Positivity violation flag (integer $0$ or $1$),\n- Monotonicity violation count during the pulse (integer).\n\nFinal output specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be ordered by test case ($A$, then $B$, then $C$). Within each test case, order by method: implicit Euler, Crank–Nicolson, BDF2. Within each method, order the metrics as listed above. Concretely, the output should be\n$$\n[\\text{A-IE-dep\\_err},\\text{A-IE-relL2},\\text{A-IE-neg},\\text{A-IE-mono},\\text{A-CN-dep\\_err},\\text{A-CN-relL2},\\text{A-CN-neg},\\text{A-CN-mono},\\text{A-BDF2-dep\\_err},\\text{A-BDF2-relL2},\\text{A-BDF2-neg},\\text{A-BDF2-mono},\\text{B-IE-dep\\_err},\\ldots,\\text{C-BDF2-mono}]\n$$\nwhere the depletion-time errors are in $\\mathrm{s}$, the relative $L^2$ errors are dimensionless floats, and the flags and counts are integers. No additional text should be printed.",
            "solution": "The user wants to solve a one-dimensional reaction-diffusion PDE using three different implicit time-stepping schemes and evaluate their performance based on several metrics.\n\n### Step 1: Problem Validation\n\n**1.1. Extract Givens**\n\n- **PDE**: $\\frac{\\partial c}{\\partial t}(x,t) = D \\,\\frac{\\partial^2 c}{\\partial x^2}(x,t) - s(t)$\n- **Domain**: $x \\in [0,L]$, $t \\in [0,T]$\n- **Variables**: $c(x,t)$ is salt concentration ($\\mathrm{mol/m^3}$), $D$ is diffusion coefficient ($\\mathrm{m^2/s}$), $s(t)$ is a sink term ($\\mathrm{mol/(m^3\\cdot s)}$).\n- **Boundary Conditions (BCs)**: Zero-flux (Neumann), $\\frac{\\partial c}{\\partial x}(0,t) = 0$ and $\\frac{\\partial c}{\\partial x}(L,t) = 0$.\n- **Initial Condition (IC)**: Uniform, $c(x,0) = c_0$.\n- **Sink Term**: Piecewise-constant, $s(t) = s_0$ for $t_{\\mathrm{on}} \\le t < t_{\\mathrm{off}}$, and $0$ otherwise.\n- **Discretization Method**: Second-order central differences for space. Implicit Euler, Crank–Nicolson, and BDF2 for time.\n- **Metrics**:\n    - **Depletion Time $\\tau_{\\mathrm{dep}}$**: Earliest time $t$ where $\\min_x c(x,t) < c_{\\min,*}$. If no depletion, $\\tau_{\\mathrm{dep}} = T$.\n    - **Depletion-Time Absolute Error**: $|\\tau_{\\mathrm{dep}}(M) - \\tau_{\\mathrm{dep}}(\\mathrm{ref})|$.\n    - **Final-Time Relative $L^2$ Error**: $\\mathcal{E}_{L^2}(M) = \\frac{\\left\\|c_M(\\cdot,T) - c_{\\mathrm{ref}}(\\cdot,T)\\right\\|_2}{\\left\\|c_{\\mathrm{ref}}(\\cdot,T)\\right\\|_2}$.\n    - **Positivity Violation Flag**: $1$ if $c(x,t) < 0$ at any point, $0$ otherwise.\n    - **Monotonicity Violation Count**: Number of time steps in $[t_{\\mathrm{on}}, t_{\\mathrm{off}})$ where $\\min_x c(x, t_{k+1}) > \\min_x c(x, t_k)$.\n- **Reference Solution**: Computed with Implicit Euler using $\\Delta t_{\\mathrm{ref}} = 10^{-3}\\,\\mathrm{s}$.\n- **Test Cases**:\n    - A: $(D=2.0\\times 10^{-10}, L=1.0\\times 10^{-4}, N=50, T=2.0, \\Delta t=0.02, s_0=50.0, t_{\\mathrm{on}}=0.5, t_{\\mathrm{off}}=1.5, c_0=1000.0, c_{\\min,*}=800.0)$\n    - B: $(D=1.0\\times 10^{-10}, L=1.0\\times 10^{-4}, N=60, T=2.0, \\Delta t=0.2, s_0=300.0, t_{\\mathrm{on}}=0.4, t_{\\mathrm{off}}=1.8, c_0=1000.0, c_{\\min,*}=700.0)$\n    - C: $(D=5.0\\times 10^{-11}, L=1.5\\times 10^{-4}, N=40, T=1.5, \\Delta t=0.05, s_0=600.0, t_{\\mathrm{on}}=0.2, t_{\\mathrm{off}}=0.8, c_0=1200.0, c_{\\min,*}=900.0)$\n\n**1.2. Validate Using Extracted Givens**\n\n- **Scientifically Grounded**: The problem describes Fickian diffusion with a sink term, a fundamental model in transport phenomena and electrochemistry. It is scientifically valid.\n- **Well-Posed**: The problem is a well-posed parabolic PDE with defined initial and boundary conditions. The numerical tasks are standard.\n- **Objective**: The problem is stated using precise mathematical and physical terminology. The metrics are defined objectively.\n- **Completeness**: All necessary parameters, conditions, and definitions for solving the problem are provided.\n- **Consistency**: All given information is internally consistent.\n\n**1.3. Verdict and Action**\n\nThe problem is valid. We proceed to the solution.\n\n### Step 2: Derivation and Solution\n\n**2.1. Spatial Discretization**\n\nWe discretize the spatial domain $x \\in [0,L]$ into $N$ equally spaced nodes $x_i = i\\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = L/(N-1)$. Let $c_i(t)$ be the numerical approximation of $c(x_i, t)$.\n\nThe second spatial derivative $\\frac{\\partial^2 c}{\\partial x^2}$ at an interior node $x_i$ ($1 \\le i \\le N-2$) is approximated using a second-order central difference:\n$$ \\frac{\\partial^2 c}{\\partial x^2}(x_i,t) \\approx \\frac{c_{i+1}(t) - 2c_i(t) + c_{i-1}(t)}{\\Delta x^2} $$\n\nTo enforce the zero-flux boundary conditions, we introduce ghost nodes $c_{-1}(t)$ and $c_{N}(t)$.\nAt the left boundary ($x=0$, $i=0$):\n$$ \\frac{\\partial c}{\\partial x}(0,t) \\approx \\frac{c_1(t) - c_{-1}(t)}{2\\Delta x} = 0 \\implies c_{-1}(t) = c_1(t) $$\nThe PDE at $i=0$ is then discretized as:\n$$ \\frac{d c_0}{d t} = D \\frac{c_1(t) - 2c_0(t) + c_{-1}(t)}{\\Delta x^2} - s(t) = D \\frac{2c_1(t) - 2c_0(t)}{\\Delta x^2} - s(t) $$\nAt the right boundary ($x=L$, $i=N-1$):\n$$ \\frac{\\partial c}{\\partial x}(L,t) \\approx \\frac{c_{N}(t) - c_{N-2}(t)}{2\\Delta x} = 0 \\implies c_{N}(t) = c_{N-2}(t) $$\nThe PDE at $i=N-1$ is discretized as:\n$$ \\frac{d c_{N-1}}{d t} = D \\frac{c_{N}(t) - 2c_{N-1}(t) + c_{N-2}(t)}{\\Delta x^2} - s(t) = D \\frac{2c_{N-2}(t) - 2c_{N-1}(t)}{\\Delta x^2} - s(t) $$\n\nThis method of lines (MOL) approach results in a system of $N$ ordinary differential equations (ODEs), which can be written in matrix form:\n$$ \\frac{d\\mathbf{c}}{dt} = \\mathbf{A}\\mathbf{c}(t) - s(t)\\mathbf{1} $$\nwhere $\\mathbf{c}(t) = [c_0(t), c_1(t), \\dots, c_{N-1}(t)]^T$ is the vector of concentrations, $\\mathbf{1}$ is a vector of ones, and $\\mathbf{A}$ is the $N \\times N$ spatial discretization matrix. Letting $\\alpha = D / \\Delta x^2$, the matrix $\\mathbf{A}$ is:\n$$\n\\mathbf{A} = \\alpha\n\\begin{pmatrix}\n-2 & 2 & 0 & \\dots & & 0 \\\\\n1 & -2 & 1 & 0 & \\dots & 0 \\\\\n0 & 1 & -2 & 1 & \\ddots & \\vdots \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & & 0 \\\\\n0 & \\dots & 0 & 1 & -2 & 1 \\\\\n0 & & \\dots & 0 & 2 & -2\n\\end{pmatrix}\n$$\n\n**2.2. Temporal Discretization**\n\nLet $\\mathbf{c}^k$ denote the numerical solution vector at time $t_k = k\\Delta t$, and let $\\mathbf{s}^k = s(t_k)\\mathbf{1}$. We derive the update rules for the three required implicit methods.\n\n**2.2.1. Implicit Euler (IE)**\nThis first-order method approximates the time derivative at $t_{k+1}$:\n$$ \\frac{\\mathbf{c}^{k+1} - \\mathbf{c}^k}{\\Delta t} = \\mathbf{A}\\mathbf{c}^{k+1} - \\mathbf{s}^{k+1} $$\nRearranging to solve for the unknown $\\mathbf{c}^{k+1}$, we get the linear system:\n$$ (\\mathbf{I} - \\Delta t \\mathbf{A})\\mathbf{c}^{k+1} = \\mathbf{c}^k - \\Delta t \\mathbf{s}^{k+1} $$\nwhere $\\mathbf{I}$ is the identity matrix.\n\n**2.2.2. Crank–Nicolson (CN)**\nThis second-order method is based on the trapezoidal rule, averaging the RHS at $t_k$ and $t_{k+1}$:\n$$ \\frac{\\mathbf{c}^{k+1} - \\mathbf{c}^k}{\\Delta t} = \\frac{1}{2} \\left( (\\mathbf{A}\\mathbf{c}^{k} - \\mathbf{s}^{k}) + (\\mathbf{A}\\mathbf{c}^{k+1} - \\mathbf{s}^{k+1}) \\right) $$\nGrouping terms with $\\mathbf{c}^{k+1}$ on the left-hand side yields the linear system:\n$$ \\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{c}^{k+1} = \\left(\\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{c}^k - \\frac{\\Delta t}{2}(\\mathbf{s}^k + \\mathbf{s}^{k+1}) $$\n\n**2.2.3. Backward Differentiation Formula of order 2 (BDF2)**\nBDF2 is a second-order, two-step method. The formula is:\n$$ \\frac{3\\mathbf{c}^{k+1} - 4\\mathbf{c}^k + \\mathbf{c}^{k-1}}{2\\Delta t} = \\mathbf{A}\\mathbf{c}^{k+1} - \\mathbf{s}^{k+1} $$\nThis is valid for $k \\ge 1$. For the very first step ($k=0$), a one-step method is required to generate $\\mathbf{c}^1$. We will use Implicit Euler for this startup step. For $k \\ge 1$, we rearrange the BDF2 formula to solve for $\\mathbf{c}^{k+1}$:\n$$ (3\\mathbf{I} - 2\\Delta t\\mathbf{A})\\mathbf{c}^{k+1} = 4\\mathbf{c}^k - \\mathbf{c}^{k-1} - 2\\Delta t \\mathbf{s}^{k+1} $$\nThis can be rewritten as:\n$$ \\left(\\mathbf{I} - \\frac{2}{3}\\Delta t\\mathbf{A}\\right)\\mathbf{c}^{k+1} = \\frac{4}{3}\\mathbf{c}^k - \\frac{1}{3}\\mathbf{c}^{k-1} - \\frac{2}{3}\\Delta t \\mathbf{s}^{k+1} $$\n\n**2.3. Algorithmic Implementation**\n\nFor each test case:\n1.  **Reference Solution**: A high-fidelity reference solution is computed using the Implicit Euler method with a very small time step, $\\Delta t_{\\mathrm{ref}} = 10^{-3}\\,\\mathrm{s}$, over the time interval $[0, T]$. During this simulation, the reference depletion time, $\\tau_{\\mathrm{dep}}(\\mathrm{ref})$, is recorded. The final concentration profile, $\\mathbf{c}_{\\mathrm{ref}}(T)$, is stored.\n2.  **Method Evaluation**: For each of the three methods (IE, CN, BDF2), a simulation is run using the time step $\\Delta t$ specified in the test case.\n3.  **Time-Stepping Loop**: For each simulation, an initial concentration vector $\\mathbf{c}^0 = c_0 \\mathbf{1}$ is created. The simulation proceeds in a time loop from $t=0$ to $t=T$. In each step, the appropriate linear system derived above is formed and solved for $\\mathbf{c}^{k+1}$ using a standard linear solver.\n4.  **Metrics Calculation**:\n    - During the simulation loop for a method $M$, we track the earliest time $t_k$ when $\\min(\\mathbf{c}^k) < c_{\\min,*}$ to find $\\tau_{\\mathrm{dep}}(M)$.\n    - We maintain a flag for positivity violation, setting it to $1$ if any component of $\\mathbf{c}^k$ ever becomes negative.\n    - We count monotonicity violations by checking if $\\min(\\mathbf{c}^{k+1}) > \\min(\\mathbf{c}^k)$ during the pulse interval $[t_{\\mathrm{on}}, t_{\\mathrm{off}})$.\n    - After the loop completes, the final concentration $\\mathbf{c}_M(T)$ is obtained. The relative $L^2$ error $\\mathcal{E}_{L^2}(M)$ is computed by comparing $\\mathbf{c}_M(T)$ with $\\mathbf{c}_{\\mathrm{ref}}(T)$ using the discrete vector $2$-norm. The depletion-time absolute error is calculated as $|\\tau_{\\mathrm{dep}}(M) - \\tau_{\\mathrm{dep}}(\\mathrm{ref})|$.\n5.  **Output Aggregation**: The four computed metrics for each method and each test case are collected and formatted into a single comma-separated list as specified.",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(method, D, L, N, T, dt, s0, t_on, t_off, c0, c_min_star):\n    \"\"\"\n    Solves the 1D diffusion-reaction PDE for a given numerical method.\n\n    Returns:\n        tuple: (final concentration profile, depletion time, positivity violation flag, monotonicity violation count)\n    \"\"\"\n    dx = L / (N - 1)\n    \n    # Build the spatial discretization matrix A\n    A = np.diag(np.full(N, -2.0)) + np.diag(np.ones(N - 1), 1) + np.diag(np.ones(N - 1), -1)\n    A[0, 1] = 2.0\n    A[N - 1, N - 2] = 2.0\n    A *= D / (dx**2)\n\n    # Time integration setup\n    num_steps = int(round(T / dt))\n    time_points = np.linspace(0, T, num_steps + 1)\n\n    # Initial condition\n    c_current = np.full(N, c0, dtype=float)\n\n    # Sink term function\n    def s(t):\n        return s0 if t_on <= t < t_off else 0.0\n\n    # Initialize metrics\n    depletion_time = T\n    positivity_violation = 0\n    monotonicity_violation_count = 0\n    \n    # Pre-compute matrices for linear solves\n    M_IE, M_CN_L, M_CN_R, M_BDF2 = None, None, None, None\n    if method == \"IE\" or (method == \"BDF2\"): # BDF2 uses IE for startup\n        M_IE = np.identity(N) - dt * A\n    if method == \"CN\":\n        M_CN_L = np.identity(N) - (dt / 2.0) * A\n        M_CN_R = np.identity(N) + (dt / 2.0) * A\n    if method == \"BDF2\":\n        M_BDF2 = np.identity(N) - (2.0 * dt / 3.0) * A\n    \n    c_prev = None  # For BDF2\n\n    # Time-stepping loop\n    for k in range(num_steps):\n        t_current = time_points[k]\n        t_next = time_points[k+1]\n        \n        s_current_val = s(t_current)\n        s_next_val = s(t_next)\n\n        min_c_before_step = np.min(c_current)\n\n        if method == \"IE\":\n            rhs = c_current - dt * s_next_val\n            c_next = np.linalg.solve(M_IE, rhs)\n        \n        elif method == \"CN\":\n            s_avg = (s_current_val + s_next_val) / 2.0\n            rhs = M_CN_R @ c_current - dt * s_avg\n            c_next = np.linalg.solve(M_CN_L, rhs)\n\n        elif method == \"BDF2\":\n            if k == 0:\n                # First step with Implicit Euler\n                rhs_ie = c_current - dt * s_next_val\n                c_next = np.linalg.solve(M_IE, rhs_ie)\n            else:\n                # Subsequent steps with BDF2\n                rhs = (4.0/3.0) * c_current - (1.0/3.0) * c_prev - (2.0 * dt / 3.0) * s_next_val\n                c_next = np.linalg.solve(M_BDF2, rhs)\n            c_prev = c_current.copy()\n        else: # Should not happen\n            c_next = c_current\n\n        # Update state\n        c_current = c_next\n\n        # Check metrics\n        if np.min(c_current) < c_min_star and depletion_time == T:\n            depletion_time = t_next\n        if np.any(c_current < 0):\n            positivity_violation = 1\n        \n        if t_on <= t_current < t_off:\n            if np.min(c_current) > min_c_before_step:\n                monotonicity_violation_count += 1\n\n    return c_current, depletion_time, positivity_violation, monotonicity_violation_count\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (D, L, N, T, dt, s0, t_on, t_off, c0, c_min_star)\n        (2.0e-10, 1.0e-4, 50, 2.0, 0.02, 50.0, 0.5, 1.5, 1000.0, 800.0), # Case A\n        (1.0e-10, 1.0e-4, 60, 2.0, 0.2, 300.0, 0.4, 1.8, 1000.0, 700.0), # Case B\n        (5.0e-11, 1.5e-4, 40, 1.5, 0.05, 600.0, 0.2, 0.8, 1200.0, 900.0), # Case C\n    ]\n\n    all_results = []\n    \n    for case_params in test_cases:\n        D, L, N, T, dt, s0, t_on, t_off, c0, c_min_star = case_params\n        N = int(N)\n\n        # 1. Compute reference solution\n        dt_ref = 1e-3\n        c_ref_T, tau_dep_ref, _, _ = run_simulation(\n            \"IE\", D, L, N, T, dt_ref, s0, t_on, t_off, c0, c_min_star\n        )\n        norm_c_ref_T = np.linalg.norm(c_ref_T)\n        \n        methods = [\"IE\", \"CN\", \"BDF2\"]\n        for method in methods:\n            # 2. Run simulation for the current method\n            c_M_T, tau_dep_M, pos_viol_M, mono_count_M = run_simulation(\n                method, D, L, N, T, dt, s0, t_on, t_off, c0, c_min_star\n            )\n            \n            # 3. Compute metrics\n            dep_err = abs(tau_dep_M - tau_dep_ref)\n            \n            if norm_c_ref_T > 1e-12:\n                rel_L2_err = np.linalg.norm(c_M_T - c_ref_T) / norm_c_ref_T\n            elif np.linalg.norm(c_M_T - c_ref_T) < 1e-12:\n                rel_L2_err = 0.0\n            else: # Should not happen in this problem\n                rel_L2_err = np.linalg.norm(c_M_T - c_ref_T)\n\n            # Append results for this method\n            all_results.extend([dep_err, rel_L2_err, pos_viol_M, mono_count_M])\n\n    # Final print statement\n    formatted_results = [f'{x:.6f}' if isinstance(x, float) else str(x) for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world battery models couple multiple physical processes, such as diffusion and nonlinear electrochemical kinetics, which can be computationally expensive to solve simultaneously. Operator splitting offers a powerful strategy to tackle this complexity by solving different parts of the model with tailored numerical methods. This exercise guides you through implementing a semi-implicit scheme and, importantly, quantifying the \"splitting error\" to understand the trade-off between computational efficiency and simulation accuracy .",
            "id": "3933651",
            "problem": "Consider a single-particle electrode model in which the intercalant concentration evolves by diffusion in a one-dimensional slab of thickness $L$ with spatial coordinate $x \\in [0,L]$ and time $t \\ge 0$. The governing partial differential equation is Fick's second law, $\\partial c/\\partial t = D \\, \\partial^2 c/\\partial x^2$, where $c(x,t)$ is the solid concentration (in $\\mathrm{mol/m^3}$) and $D$ is the solid-state diffusion coefficient (in $\\mathrm{m^2/s}$). The boundary condition at $x=0$ enforces symmetry, $\\partial c/\\partial x \\vert_{x=0} = 0$. The boundary condition at $x=L$ enforces a specified molar flux $J(t)$ (in $\\mathrm{mol/(m^2 \\cdot s)}$), $-D \\, \\partial c/\\partial x \\vert_{x=L} = J(t)$. Assume the initial condition $c(x,0) = c_0$.\n\nThe applied current density $j(t)$ (in $\\mathrm{A/m^2}$) and the molar flux are related by $j(t) = F \\, J(t)$, where $F$ is the Faraday constant (in $\\mathrm{C/mol}$). The electrode voltage $V(t)$ (in $\\mathrm{V}$) is modeled as the sum of an open-circuit potential $U(c_s)$ evaluated at the surface concentration $c_s(t) \\equiv c(L,t)$, a kinetic overpotential $\\eta(t)$ that enforces the Butler–Volmer kinetics for the given current $j(t)$, and an ohmic drop $R_{\\mathrm{ohm}} \\, j(t)$:\n$$\nV(t) = U(c_s(t)) + \\eta(t) + R_{\\mathrm{ohm}} \\, j(t),\n$$\nwhere $R_{\\mathrm{ohm}}$ is a constant area-specific ohmic resistance (in $\\Omega \\cdot \\mathrm{m^2}$). The open-circuit potential is $U(c_s) = U_0 + \\frac{R T}{F} \\ln\\!\\left(\\frac{c_s}{c_{\\max} - c_s}\\right)$, where $U_0$ is a constant (in $\\mathrm{V}$), $R$ is the universal gas constant (in $\\mathrm{J/(mol \\cdot K)}$), $T$ is the absolute temperature (in $\\mathrm{K}$), and $c_{\\max}$ is the maximum concentration (in $\\mathrm{mol/m^3}$). Assume symmetric electrochemical transfer coefficient and exchange current density $j_0(c_s) = F \\, k_0 \\, \\sqrt{c_e} \\, \\sqrt{c_s \\, (c_{\\max} - c_s)}$ (in $\\mathrm{A/m^2}$), where $k_0$ is a rate constant (in $\\mathrm{m/s}$) and $c_e$ is electrolyte concentration (in $\\mathrm{mol/m^3}$). The Butler–Volmer relation for symmetric transfer coefficient requires the kinetic overpotential $\\eta(t)$ to satisfy $j(t) = 2 j_0(c_s(t)) \\sinh\\!\\left(\\frac{\\alpha F \\eta(t)}{R T}\\right)$, with $\\alpha$ the transfer coefficient (dimensionless).\n\nTask A (Derivation): Starting from the conservation law and boundary conditions, derive a semi-implicit operator-splitting time discretization over time steps of size $\\Delta t$ that treats the diffusion operator implicitly and the kinetic operator explicitly as follows. Let $c^n(x)$ denote the concentration at time $t_n$, and $c^{n+1}(x)$ at time $t_{n+1} = t_n + \\Delta t$. Show how to obtain $c^{n+1}(x)$ by solving the diffusion subproblem implicitly using the flux $J(t_{n+1})$ at the boundary $x=L$, and then compute the voltage $V_{\\mathrm{split}}^{n+1}$ by evaluating $U$ and $j_0$ at the previous surface concentration $c_s^n$. Formulate the corresponding fully coupled reference voltage $V_{\\mathrm{full}}^{n+1}$ by evaluating $U$ and $j_0$ at the updated surface concentration $c_s^{n+1}$. Explicitly derive the linear system arising from a finite-volume backward Euler discretization of the diffusion equation on a uniform grid of $N$ cells, with symmetry at $x=0$ and fixed flux at $x=L$. Your derivation must be based on fundamental conservation and constitutive laws and must clearly distinguish the operator-split voltage from the fully coupled voltage.\n\nTask B (Implementation): Implement the derived scheme in a single, self-contained program. Use a uniform spatial grid with $N$ nodes and backward Euler implicit time stepping for diffusion. Use the following parameter values, all in SI units: $L = 5 \\times 10^{-6}$ m, $D = 1 \\times 10^{-14}$ $\\mathrm{m^2/s}$, $c_{\\max} = 3.1 \\times 10^{4}$ $\\mathrm{mol/m^3}$, $c_0 = 2.0 \\times 10^{4}$ $\\mathrm{mol/m^3}$, $k_0 = 1.0 \\times 10^{-11}$ $\\mathrm{m/s}$, $\\alpha = 0.5$, $c_e = 1.0 \\times 10^{3}$ $\\mathrm{mol/m^3}$, $U_0 = 1.0 \\times 10^{-1}$ $\\mathrm{V}$, $R_{\\mathrm{ohm}} = 1.0 \\times 10^{-2}$ $\\Omega \\cdot \\mathrm{m^2}$, $F = 9.6485 \\times 10^{4}$ $\\mathrm{C/mol}$, $R = 8.314$ $\\mathrm{J/(mol \\cdot K)}$, $T = 298$ $\\mathrm{K}$, and $N = 50$.\n\nTask C (Assessment): For each time step, compute both $V_{\\mathrm{split}}^{n+1}$ and $V_{\\mathrm{full}}^{n+1}$ using the same applied current density $j(t_{n+1})$. Over the full simulation horizon, compute the root-mean-square splitting error in voltage,\n$$\n\\varepsilon_V = \\sqrt{\\frac{1}{M} \\sum_{n=1}^{M} \\left(V_{\\mathrm{split}}^{n} - V_{\\mathrm{full}}^{n}\\right)^2},\n$$\nwhere $M$ is the total number of time steps. Express $\\varepsilon_V$ in volts (V).\n\nTest Suite and Output Specification: Your program must run the following four scientifically distinct test cases, each with its own time horizon and applied current profile $j(t)$, and produce a single-line output listing the four values of $\\varepsilon_V$ as a comma-separated list enclosed in square brackets, in volts and rounded to six decimal places.\n\n- Test 1 (Happy path): $\\Delta t = 1.0 \\times 10^{-1}$ s, $T_{\\mathrm{end}} = 2.0 \\times 10^{2}$ s, $j(t) = 5.0 \\times 10^{-1}$ $\\mathrm{A/m^2}$ for all $t$.\n- Test 2 (Direction-reversing pulses): $\\Delta t = 1.0 \\times 10^{-1}$ s, $T_{\\mathrm{end}} = 2.0 \\times 10^{2}$ s, $j(t)$ is a square wave alternating between $+5.0 \\times 10^{-1}$ $\\mathrm{A/m^2}$ and $-5.0 \\times 10^{-1}$ $\\mathrm{A/m^2}$ with a period of $2.0 \\times 10^{1}$ s and $50\\%$ duty cycle, starting at $+5.0 \\times 10^{-1}$ $\\mathrm{A/m^2}$.\n- Test 3 (Large time step): $\\Delta t = 5.0 \\times 10^{-1}$ s, $T_{\\mathrm{end}} = 2.0 \\times 10^{2}$ s, $j(t) = 5.0 \\times 10^{-1}$ $\\mathrm{A/m^2}$ for all $t$.\n- Test 4 (Small time step baseline): $\\Delta t = 1.0 \\times 10^{-2}$ s, $T_{\\mathrm{end}} = 5.0 \\times 10^{1}$ s, $j(t) = 5.0 \\times 10^{-1}$ $\\mathrm{A/m^2}$ for all $t$.\n\nFinal Output Format: Your program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets, for example, `[v_1,v_2,v_3,v_4]`, where each $v_i$ is the root-mean-square splitting error $\\varepsilon_V$ in volts (V), rounded to six decimal places.",
            "solution": "The problem statement has been meticulously reviewed and is determined to be valid. It is scientifically grounded in the principles of electrochemical engineering and mass transport, mathematically well-posed, objective, and self-contained with all necessary parameters and conditions for a unique solution. The tasks are clearly defined and constitute a standard exercise in the numerical modeling of battery systems.\n\n### Task A: Derivation of the Numerical Scheme\n\nThis task requires the derivation of a semi-implicit operator-splitting scheme for the given single-particle model. We will first discretize the governing diffusion equation in space using the finite volume method and in time using the implicit backward Euler method. Then, we will formulate the expressions for the fully coupled and operator-split voltages.\n\n**1. Spatial Discretization using Finite Volume Method**\n\nThe governing partial differential equation is Fick's second law:\n$$\n\\frac{\\partial c(x,t)}{\\partial t} = D \\frac{\\partial^2 c(x,t)}{\\partial x^2}\n$$\nWe discretize the spatial domain $x \\in [0, L]$ into $N$ uniform control volumes (CVs), each of width $\\Delta x = L/N$. The $i$-th CV, for $i=1, \\dots, N$, is centered at $x_i = (i-0.5)\\Delta x$ and spans the interval $[(i-1)\\Delta x, i\\Delta x]$. Let $c_i(t)$ be the spatially averaged concentration in the $i$-th CV.\n\nWe integrate the PDE over the $i$-th control volume, from $x_{i-1/2} = (i-1)\\Delta x$ to $x_{i+1/2} = i\\Delta x$:\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{\\partial c}{\\partial t} \\, dx = \\int_{x_{i-1/2}}^{x_{i+1/2}} D \\frac{\\partial^2 c}{\\partial x^2} \\, dx\n$$\nApplying Leibniz's rule and the fundamental theorem of calculus:\n$$\n\\frac{d}{dt} \\left( \\int_{x_{i-1/2}}^{x_{i+1/2}} c \\, dx \\right) = D \\left[ \\frac{\\partial c}{\\partial x} \\right]_{x_{i-1/2}}^{x_{i+1/2}}\n$$\nApproximating the integral of concentration by the average concentration $c_i$ multiplied by the volume width $\\Delta x$, we get:\n$$\n\\Delta x \\frac{dc_i}{dt} = D \\left( \\left. \\frac{\\partial c}{\\partial x} \\right|_{x_{i+1/2}} - \\left. \\frac{\\partial c}{\\partial x} \\right|_{x_{i-1/2}} \\right)\n$$\nThe terms on the right can be identified with the molar fluxes at the cell faces, $J_{\\text{face}} = -D \\, \\partial c/\\partial x$.\n$$\n\\frac{dc_i}{dt} = - \\frac{1}{\\Delta x} \\left( J_{i+1/2} - J_{i-1/2} \\right)\n$$\nWe approximate the gradients at the cell faces using central differences between adjacent cell centers:\n$$\n\\left. \\frac{\\partial c}{\\partial x} \\right|_{x_{i+1/2}} \\approx \\frac{c_{i+1}(t) - c_i(t)}{\\Delta x}\n$$\nThis gives the semi-discretized ordinary differential equation (ODE) for an interior cell ($i = 2, \\dots, N-1$):\n$$\n\\frac{dc_i}{dt} = \\frac{D}{\\Delta x^2} \\left( (c_{i+1} - c_i) - (c_i - c_{i-1}) \\right) = \\frac{D}{\\Delta x^2} (c_{i+1} - 2c_i + c_{i-1})\n$$\n\nFor the boundary cells:\n- **At $x=0$ (Cell $i=1$):** The boundary condition is $\\partial c/\\partial x \\vert_{x=0} = 0$, which implies zero flux, $J_{1/2} = 0$.\n  $$\n  \\frac{dc_1}{dt} = - \\frac{1}{\\Delta x} (J_{3/2} - J_{1/2}) = - \\frac{1}{\\Delta x} J_{3/2} = - \\frac{1}{\\Delta x} \\left( -D \\frac{c_2 - c_1}{\\Delta x} \\right) = \\frac{D}{\\Delta x^2} (c_2 - c_1)\n  $$\n- **At $x=L$ (Cell $i=N$):** The boundary condition is $-D \\, \\partial c/\\partial x \\vert_{x=L} = J(t)$. The right face of cell $N$ is at $x_{N+1/2} = L$, so $J_{N+1/2} = J(t)$.\n  $$\n  \\frac{dc_N}{dt} = - \\frac{1}{\\Delta x} (J_{N+1/2} - J_{N-1/2}) = - \\frac{1}{\\Delta x} \\left( J(t) - (-D \\frac{c_N - c_{N-1}}{\\Delta x}) \\right) = \\frac{D}{\\Delta x^2} (c_{N-1} - c_N) - \\frac{J(t)}{\\Delta x}\n  $$\n\n**2. Implicit Time Discretization (Backward Euler)**\n\nWe discretize in time using the backward Euler method, where the time derivative is approximated as $(c_i^{n+1} - c_i^n)/\\Delta t$, and all spatial terms are evaluated at the future time step $t_{n+1}$. Let $\\lambda = D \\Delta t / \\Delta x^2$ be the dimensionless diffusion number.\n\n- **For $i=1$:**\n  $$\n  \\frac{c_1^{n+1} - c_1^n}{\\Delta t} = \\frac{D}{\\Delta x^2}(c_2^{n+1} - c_1^{n+1}) \\implies (1+\\lambda)c_1^{n+1} - \\lambda c_2^{n+1} = c_1^n\n  $$\n- **For $i=2, \\dots, N-1$:**\n  $$\n  \\frac{c_i^{n+1} - c_i^n}{\\Delta t} = \\frac{D}{\\Delta x^2}(c_{i+1}^{n+1} - 2c_i^{n+1} + c_{i-1}^{n+1}) \\implies -\\lambda c_{i-1}^{n+1} + (1+2\\lambda)c_i^{n+1} - \\lambda c_{i+1}^{n+1} = c_i^n\n  $$\n- **For $i=N$:**\n  $$\n  \\frac{c_N^{n+1} - c_N^n}{\\Delta t} = \\frac{D}{\\Delta x^2}(c_{N-1}^{n+1} - c_N^{n+1}) - \\frac{J(t_{n+1})}{\\Delta x} \\implies -\\lambda c_{N-1}^{n+1} + (1+\\lambda)c_N^{n+1} = c_N^n - \\frac{J^{n+1} \\Delta t}{\\Delta x}\n  $$\n  Here, $J^{n+1} = J(t_{n+1}) = j(t_{n+1})/F$.\n\nThese $N$ linear equations form a tridiagonal system $A \\mathbf{c}^{n+1} = \\mathbf{b}$, where $\\mathbf{c}^{n+1} = [c_1^{n+1}, c_2^{n+1}, \\dots, c_N^{n+1}]^T$. The matrix $A$ is an $N \\times N$ matrix with the following structure:\n$$\nA = \\begin{pmatrix}\n1+\\lambda & -\\lambda & 0 & \\dots & 0 & 0 \\\\\n-\\lambda & 1+2\\lambda & -\\lambda & \\dots & 0 & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & \\vdots & \\vdots \\\\\n\\vdots & \\vdots & \\ddots & \\ddots & \\ddots & 0 \\\\\n0 & 0 & \\dots & -\\lambda & 1+2\\lambda & -\\lambda \\\\\n0 & 0 & \\dots & 0 & -\\lambda & 1+\\lambda\n\\end{pmatrix}\n$$\nThe right-hand side vector $\\mathbf{b}$ is:\n$$\n\\mathbf{b} = \\begin{pmatrix} c_1^n \\\\ c_2^n \\\\ \\vdots \\\\ c_{N-1}^n \\\\ c_N^n - \\frac{j^{n+1} \\Delta t}{F \\Delta x} \\end{pmatrix}\n$$\nSolving this linear system at each time step yields the concentration profile $\\mathbf{c}^{n+1}$.\n\n**3. Operator Splitting and Voltage Calculation**\n\nThe problem specifies an operator-splitting scheme where the diffusion is treated implicitly, but the kinetic calculations are performed explicitly with respect to the surface concentration. This means the voltage calculation lags the concentration update. We contrast this with the fully coupled formulation.\n\nThe surface concentration at time $t_n$ is $c_s^n \\equiv c_N^n$. Solving the linear system gives the updated concentration profile $\\mathbf{c}^{n+1}$, from which we obtain the new surface concentration $c_s^{n+1} \\equiv c_N^{n+1}$. The applied current density at the new time step is $j^{n+1} = j(t_{n+1})$.\n\nThe voltage components are:\n- **Open-Circuit Potential:** $U(c_s) = U_0 + \\frac{RT}{F} \\ln\\left(\\frac{c_s}{c_{\\max} - c_s}\\right)$\n- **Exchange Current Density:** $j_0(c_s) = F k_0 \\sqrt{c_e} \\sqrt{c_s (c_{\\max} - c_s)}$\n- **Kinetic Overpotential:** $\\eta(j, c_s) = \\frac{RT}{\\alpha F} \\text{asinh}\\left(\\frac{j}{2 j_0(c_s)}\\right)$\n\n**Fully Coupled Voltage ($V_{\\mathrm{full}}^{n+1}$):**\nThis is the reference voltage, calculated using all quantities evaluated at the new time step $t_{n+1}$.\n$$\nV_{\\mathrm{full}}^{n+1} = U(c_s^{n+1}) + \\eta(j^{n+1}, c_s^{n+1}) + R_{\\mathrm{ohm}} j^{n+1}\n$$\n\n**Operator-Split Voltage ($V_{\\mathrm{split}}^{n+1}$):**\nThis voltage is computed using the surface concentration from the *previous* time step, $c_s^n$, for the potential and kinetic terms, while using the current at the *new* time step. This represents an explicit evaluation of the nonlinear kinetic part of the model.\n$$\nV_{\\mathrm{split}}^{n+1} = U(c_s^{n}) + \\eta(j^{n+1}, c_s^{n}) + R_{\\mathrm{ohm}} j^{n+1}\n$$\nThis explicit treatment of the surface concentration in the voltage calculation introduces a splitting error, which is the quantity to be assessed. The overall algorithm for one time step is:\n1.  Given $\\mathbf{c}^n$, determine $j^{n+1} = j(t_{n+1})$.\n2.  Form the vector $\\mathbf{b}$ using $\\mathbf{c}^n$ and $j^{n+1}$.\n3.  Solve the system $A \\mathbf{c}^{n+1} = \\mathbf{b}$ to find $\\mathbf{c}^{n+1}$.\n4.  Extract the old and new surface concentrations, $c_s^n = c_N^n$ and $c_s^{n+1} = c_N^{n+1}$.\n5.  Calculate $V_{\\mathrm{full}}^{n+1}$ using $c_s^{n+1}$ and $j^{n+1}$.\n6.  Calculate $V_{\\mathrm{split}}^{n+1}$ using $c_s^{n}$ and $j^{n+1}$.\n7.  Store the results and proceed to the next time step.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\nimport math\n\n# The problem asks for a single, self-contained program.\n# All logic is contained within the solve function as requested.\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the simulation for all test cases.\n    \"\"\"\n\n    # --- Task B: Parameter Definition (SI Units) ---\n    params = {\n        'L': 5e-6,         # m\n        'D': 1e-14,        # m^2/s\n        'c_max': 3.1e4,    # mol/m^3\n        'c_0': 2.0e4,      # mol/m^3\n        'k_0': 1.0e-11,    # m/s\n        'alpha': 0.5,      # dimensionless\n        'c_e': 1.0e3,      # mol/m^3\n        'U_0': 1.0e-1,     # V\n        'R_ohm': 1.0e-2,   # Ohm.m^2\n        'F': 96485.0,      # C/mol\n        'R': 8.314,        # J/(mol.K)\n        'T': 298.0,        # K\n        'N': 50            # number of grid cells\n    }\n    \n    # --- Test Suite Definition ---\n    # (dt, T_end, j_func, j_amp, j_period)\n    test_cases = [\n        (1.0e-1, 2.0e2, lambda t, amp, per: amp, 5.0e-1, None), # Test 1\n        (1.0e-1, 2.0e2, lambda t, amp, per: amp if (t % per) < (per / 2.0) else -amp, 5.0e-1, 2.0e1), # Test 2\n        (5.0e-1, 2.0e2, lambda t, amp, per: amp, 5.0e-1, None), # Test 3\n        (1.0e-2, 5.0e1, lambda t, amp, per: amp, 5.0e-1, None)  # Test 4\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        dt, T_end, j_func, j_amp, j_period = case\n        \n        # --- Run one simulation case ---\n        error = run_simulation(params, dt, T_end, j_func, j_amp, j_period)\n        all_results.append(f\"{error:.6f}\")\n\n    print(f\"[{','.join(all_results)}]\")\n\ndef run_simulation(params, dt, T_end, j_func, j_amp, j_period):\n    \"\"\"\n    Executes a single simulation run for a given test case.\n    \"\"\"\n    # Unpack parameters\n    L, D, c_max, c_0, k_0, alpha, c_e, U_0, R_ohm, F, R, T, N = params.values()\n\n    # --- Discretization Setup ---\n    dx = L / N\n    # Dimensionless diffusion number\n    lam = (D * dt) / (dx**2)\n    # Time steps\n    num_steps = int(round(T_end / dt))\n    \n    # --- Tridiagonal Matrix A for the linear system A*c^{n+1} = b ---\n    # Scipy's solve_banded expects bands in a (3, N) array:\n    # row 0: upper diagonal (shifted)\n    # row 1: main diagonal\n    # row 2: lower diagonal (shifted)\n    A_banded = np.zeros((3, N))\n    \n    # Main diagonal\n    A_banded[1, 0] = 1.0 + lam\n    A_banded[1, 1:N-1] = 1.0 + 2.0 * lam\n    A_banded[1, N-1] = 1.0 + lam\n    \n    # Upper diagonal (c_{i+1})\n    A_banded[0, 1:] = -lam\n    \n    # Lower diagonal (c_{i-1})\n    A_banded[2, :-1] = -lam\n\n    # -- Initial condition -- \n    c = np.full(N, c_0)\n\n    squared_errors = []\n\n    # --- Time-stepping loop ---\n    for n in range(num_steps):\n        t_np1 = (n + 1) * dt\n        \n        # Get previous surface concentration\n        c_s_n = c[N-1]\n        \n        # Get current density at new time step\n        j_np1 = j_func(t_np1, j_amp, j_period)\n        \n        # --- Construct RHS vector b ---\n        b = np.copy(c)\n        b[N-1] -= (j_np1 * dt) / (F * dx)\n        \n        # --- Solve diffusion sub-problem for c^{n+1} ---\n        c_np1 = solve_banded((1, 1), A_banded, b)\n        \n        # Get new surface concentration\n        c_s_np1 = c_np1[N-1]\n\n        # --- Calculate Voltages (Task C) ---\n        V_split = calculate_voltage(c_s_n, j_np1, params)\n        V_full = calculate_voltage(c_s_np1, j_np1, params)\n        \n        if V_split is not None and V_full is not None:\n             squared_errors.append((V_split - V_full)**2)\n        \n        # Update concentration for next step\n        c = c_np1\n        \n    # --- Compute RMS Splitting Error ---\n    if not squared_errors:\n        return 0.0 # Avoid division by zero if no valid steps were taken\n    \n    rms_error = np.sqrt(np.mean(squared_errors))\n    return rms_error\n\n\ndef calculate_voltage(c_s, j, params):\n    \"\"\"\n    Calculates the electrode voltage V based on surface concentration and current.\n    \"\"\"\n    # Unpack required parameters\n    c_max, k_0, alpha, c_e, U_0, R_ohm, F, R, T = \\\n        params['c_max'], params['k_0'], params['alpha'], params['c_e'], \\\n        params['U_0'], params['R_ohm'], params['F'], params['R'], params['T']\n\n    # Robustness: Clip c_s to be slightly away from 0 and c_max\n    # to prevent math domain errors in log and sqrt.\n    epsilon = 1e-9\n    c_s_clipped = np.clip(c_s, epsilon, c_max - epsilon)\n    \n    if not (epsilon <= c_s <= c_max - epsilon):\n        # This condition indicates a potential physical or numerical instability.\n        # For the purpose of this problem, we return None to exclude this data point\n        # from the RMS error calculation, though a real simulation might stop or adapt.\n        return None\n\n    # --- Open-Circuit Potential (U) ---\n    # U(c_s) = U_0 + (RT/F) * ln(c_s / (c_max - c_s))\n    U_cs = U_0 + (R * T / F) * math.log(c_s_clipped / (c_max - c_s_clipped))\n    \n    # --- Exchange Current Density (j0) ---\n    # j0(c_s) = F * k_0 * sqrt(c_e) * sqrt(c_s * (c_max - c_s))\n    j0_cs = F * k_0 * math.sqrt(c_e) * math.sqrt(c_s_clipped * (c_max - c_s_clipped))\n    \n    # --- Kinetic Overpotential (eta) ---\n    # j = 2 * j0 * sinh((alpha*F*eta)/(R*T))\n    # eta = (R*T / (alpha*F)) * asinh(j / (2*j0))\n    # Handle j0=0 case\n    if j0_cs > 0:\n        overpotential = (R * T / (alpha * F)) * math.asinh(j / (2.0 * j0_cs))\n    else:\n        # If j0 is zero, overpotential is theoretically infinite for non-zero j.\n        # This should not happen with proper clipping. Return None if it does.\n        return None\n\n    # --- Total Voltage V ---\n    # V = U(c_s) + eta + R_ohm * j\n    V_total = U_cs + overpotential + R_ohm * j\n    \n    return V_total\n\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}