{
    "hands_on_practices": [
        {
            "introduction": "在尝试将模型拟合到实验数据之前，评估模型本身的结构至关重要。此练习通过一个常见的电化学阻抗模型，从根本上揭示了结构可辨识性的概念 。您将通过推导证明，由于模型固有的代数对称性，不同的参数组合可能产生完全相同的阻抗谱，从而使它们在实验上无法区分。这项实践有助于培养在参数估计之前批判性地评估模型有效性的核心技能。",
            "id": "3936955",
            "problem": "一个锂离子电池通过一个线性等效电路进行电化学阻抗谱建模，该电路由一个串联的欧姆电阻和两个串联的并联电阻-电容支路组成。串联元件的电阻为 $R_0$。两个支路为 $(R_1 \\parallel C_1)$ 和 $(R_2 \\parallel C_2)$，其中 $\\parallel$ 表示并联。设复频率为 $s$，其中 $s = \\mathrm{j} \\omega$ 且 $\\mathrm{j}^2 = -1$，并定义支路时间常数 $\\tau_1 = R_1 C_1$ 和 $\\tau_2 = R_2 C_2$。理想电阻的阻抗为 $Z_R(s) = R$，理想电容的阻抗为 $Z_C(s) = 1/(s C)$。使用 Kirchhoff 定律和线性时不变网络组合规则，对于所有实数 $\\omega$，总阻抗 $Z(s)$ 由 $(R_0, R_1, C_1, R_2, C_2)$ 决定。\n\n给定在所有实数角频率上阻抗被完美测量，因此 $Z(s)$ 在虚轴上是完全已知的复解析函数。仅从上述基本定律和定义出发，完成以下任务：\n\n1. 推导 $Z(s)$ 的有理函数形式，其系数为 $s$ 的实系数，并用 $(R_0, R_1, \\tau_1, R_2, \\tau_2)$ 表示。\n2. 通过识别从参数到 $Z(s)$ 的映射中的代数不变量，证明存在不同的参数元组 $(R_0, R_1, \\tau_1, R_2, \\tau_2)$ 和 $(R_0, \\tilde{R}_1, \\tilde{\\tau}_1, \\tilde{R}_2, \\tilde{\\tau}_2)$，它们对于所有实数 $\\omega$ 产生相同的 $Z(s)$。\n3. 证明当 $\\tau_1 \\neq \\tau_2$ 时，唯一非平凡的不可区分性是两个支路的置换；而当 $\\tau_1 = \\tau_2$ 时，存在一个具有相同谱的非平凡的不可区分参数化连续体。用代数等式明确地刻画产生给定 $Z(s)$ 的所有参数元组的集合。\n\n答案要求：作为最终答案，提供一个单行向量，给出参数到阻抗映射的完整代数不变量集，该不变量集根据“对所有实数 $\\omega$ 产生相同的 $Z(s)$”这一关系对等价类进行分类。请用 $(R_0, R_1, \\tau_1, R_2, \\tau_2)$ 符号化表示您的答案。不包括单位。如果您选择一个等效但不同的不变量生成集，它必须在恢复 $Z(s)$ 作为有理函数（直到相同的谱）方面是代数完备且最小的，并且必须表示为单个封闭形式的表达式。",
            "solution": "该问题陈述被评估为具有科学依据、问题明确且客观。它提出了一个应用于常见电化学模型的系统辨识标准问题。所有必要信息均已提供，问题具体且数学上严谨。因此，该问题被认为是有效的，下面提供完整解答。\n\n### 1. 阻抗函数 $Z(s)$ 的推导\n电化学阻抗模型由一个电阻为 $R_0$ 的串联电阻和两个串联的并联电阻-电容 (RC) 支路 $(R_1 \\parallel C_1)$ 和 $(R_2 \\parallel C_2)$ 组成。\n\n电阻 $R$ 的阻抗为 $Z_R(s) = R$。\n电容 $C$ 的阻抗为 $Z_C(s) = \\frac{1}{sC}$。\n复频率为 $s = \\mathrm{j} \\omega$。\n\n第一个并联 RC 支路的阻抗 $Z_1(s)$ 由下式给出：\n$$Z_1(s) = \\frac{1}{\\frac{1}{Z_{R_1}(s)} + \\frac{1}{Z_{C_1}(s)}} = \\frac{1}{\\frac{1}{R_1} + sC_1} = \\frac{R_1}{1 + sR_1C_1}$$\n使用时间常数 $\\tau_1 = R_1 C_1$ 的定义，上式变为：\n$$Z_1(s) = \\frac{R_1}{1 + s\\tau_1}$$\n同样，第二个并联 RC 支路的阻抗 $Z_2(s)$ 为：\n$$Z_2(s) = \\frac{R_2}{1 + s\\tau_2}$$\n其中 $\\tau_2 = R_2 C_2$。\n\n总阻抗 $Z(s)$ 是串联各元件阻抗之和：\n$$Z(s) = Z_{R_0}(s) + Z_1(s) + Z_2(s) = R_0 + \\frac{R_1}{1 + s\\tau_1} + \\frac{R_2}{1 + s\\tau_2}$$\n为了将 $Z(s)$ 表示为有理函数，我们将各项合并到一个共同的分母上：\n$$Z(s) = R_0 \\frac{(1 + s\\tau_1)(1 + s\\tau_2)}{(1 + s\\tau_1)(1 + s\\tau_2)} + \\frac{R_1(1 + s\\tau_2)}{(1 + s\\tau_1)(1 + s\\tau_2)} + \\frac{R_2(1 + s\\tau_1)}{(1 + s\\tau_1)(1 + s\\tau_2)}$$\n$$Z(s) = \\frac{R_0(1 + s\\tau_1)(1 + s\\tau_2) + R_1(1 + s\\tau_2) + R_2(1 + s\\tau_1)}{(1 + s\\tau_1)(1 + s\\tau_2)}$$\n将分子和分母多项式按 $s$ 的幂次展开：\n分母是：\n$$Q(s) = (1 + s\\tau_1)(1 + s\\tau_2) = 1 + s(\\tau_1 + \\tau_2) + s^2(\\tau_1\\tau_2)$$\n分子是：\n$$P(s) = R_0(1 + s(\\tau_1 + \\tau_2) + s^2\\tau_1\\tau_2) + R_1 + sR_1\\tau_2 + R_2 + sR_2\\tau_1$$\n$$P(s) = (R_0 + R_1 + R_2) + s(R_0(\\tau_1 + \\tau_2) + R_1\\tau_2 + R_2\\tau_1) + s^2(R_0\\tau_1\\tau_2)$$\n因此，$Z(s)$ 的有理形式为：\n$$Z(s) = \\frac{(R_0\\tau_1\\tau_2)s^2 + (R_0(\\tau_1 + \\tau_2) + R_1\\tau_2 + R_2\\tau_1)s + (R_0 + R_1 + R_2)}{(\\tau_1\\tau_2)s^2 + (\\tau_1 + \\tau_2)s + 1}$$\n多项式的系数是实数，并用参数集 $(R_0, R_1, \\tau_1, R_2, \\tau_2)$ 表示。\n\n### 2. 参数不可区分性与代数不变量\n我们假设 $Z(s)$ 是精确已知的，这意味着有理函数的系数是已知的。让我们将 $Z(s)$ 写成 $Z(s) = \\frac{a_2 s^2 + a_1 s + a_0}{b_2 s^2 + b_1 s + 1}$。通过与推导出的表达式进行比较，我们确定了五个模型参数 $(R_0, R_1, R_2, \\tau_1, \\tau_2)$ 和五个可观测系数 $(a_0, a_1, a_2, b_1, b_2)$ 之间的以下关系：\n\\begin{align*}\nb_1 = \\tau_1 + \\tau_2 \\\\\nb_2 = \\tau_1\\tau_2 \\\\\na_0 = R_0 + R_1 + R_2 \\\\\na_1 = R_0(\\tau_1 + \\tau_2) + R_1\\tau_2 + R_2\\tau_1 \\\\\na_2 = R_0\\tau_1\\tau_2\n\\end{align*}\n从这些方程中，我们可以尝试求解模型参数。\n从分母的系数来看，$b_1$ 和 $b_2$ 是 $\\tau_1$ 和 $\\tau_2$ 的初等对称多项式。这意味着 $\\tau_1$ 和 $\\tau_2$ 是二次方程 $x^2 - b_1 x + b_2 = 0$ 的两个根。时间常数集合 $\\{\\tau_1, \\tau_2\\}$ 是唯一确定的，但我们无法区分 $\\tau_1$ 和 $\\tau_2$。\n从系数 $a_2$ 和 $b_2$ 中，我们可以唯一确定 $R_0$：\n$$R_0 = \\frac{a_2}{b_2} = \\frac{R_0\\tau_1\\tau_2}{\\tau_1\\tau_2}$$\n这个辨识是唯一的，前提是 $\\tau_1, \\tau_2 \\neq 0$，这是模型为二阶的物理要求。\n\n现在，考虑关于 $R_1$ 和 $R_2$ 的其余方程：\n$$R_1 + R_2 = a_0 - R_0$$\n$$R_1\\tau_2 + R_2\\tau_1 = a_1 - R_0(\\tau_1+\\tau_2) = a_1 - R_0 b_1$$\n这是一个关于 $(R_1, R_2)$ 的线性系统。系数矩阵的行列式是 $\\tau_1 - \\tau_2$。\n\n不可区分性源于两个 RC 支路的置换对称性。表达式 $Z(s) = R_0 + \\frac{R_1}{1 + s\\tau_1} + \\frac{R_2}{1 + s\\tau_2}$ 在同时交换对 $(R_1, \\tau_1)$ 和 $(R_2, \\tau_2)$ 时是不变的。\n这意味着参数元组 $(R_0, R_1, \\tau_1, R_2, \\tau_2)$ 与元组 $(R_0, R_2, \\tau_2, R_1, \\tau_1)$ 在经验上是不可区分的。如果 $(R_1, \\tau_1) \\neq (R_2, \\tau_2)$，这两个元组是不同的，这证明了存在不同的参数集可以产生相同的阻抗函数 $Z(s)$。\n\n### 3. 等价类的刻画\n\n**情况 1：$\\tau_1 \\neq \\tau_2$ (不同的时间常数)**\n当 $\\tau_1 \\neq \\tau_2$ 时，阻抗函数在 $s = -1/\\tau_1$ 和 $s = -1/\\tau_2$ 处的极点是不同的。关于 $(R_1, R_2)$ 的线性系统的行列式非零，对于给定的时间常数（哪个是 $\\tau_1$，哪个是 $\\tau_2$）选择，会产生 $(R_1, R_2)$ 的唯一解。\n让我们为方程 $x^2 - b_1 x + b_2 = 0$ 的两个根选择一个赋值，比如说 $(\\tau_a, \\tau_b)$。\n系统变为：\n$$R_1 + R_2 = S_R \\equiv a_0 - R_0$$\n$$R_1\\tau_b + R_2\\tau_a = P_R \\equiv a_1 - R_0 b_1$$\n解此方程组可得唯一的对 $(R_1, R_2)$。\n如果我们接着将赋值交换为 $(\\tau_b, \\tau_a)$，第二个方程变为 $R_1\\tau_a + R_2\\tau_b = P_R$。这个新系统产生的解中 $R_1$ 和 $R_2$ 的值会互换。\n因此，如果 $\\tau_1 \\neq \\tau_2$，恰好有两个参数元组产生相同的 $Z(s)$：\n$$(R_0, R_1, \\tau_1, R_2, \\tau_2) \\quad \\text{和} \\quad (R_0, R_2, \\tau_2, R_1, \\tau_1)$$\n唯一非平凡的不可区分性是两个不同支路的置换。\n\n**情况 2：$\\tau_1 = \\tau_2 = \\tau$ (相同的时间常数)**\n如果 $\\tau_1 = \\tau_2 = \\tau$，模型退化。阻抗函数变为：\n$$Z(s) = R_0 + \\frac{R_1}{1 + s\\tau} + \\frac{R_2}{1 + s\\tau} = R_0 + \\frac{R_1 + R_2}{1 + s\\tau}$$\n在这种形式下，从阻抗谱中可观察到的参数是 $R_0$、时间常数 $\\tau$ 以及支路电阻之和 $R_{sum} = R_1 + R_2$。$R_1$ 和 $R_2$ 的单个值是不可辨识的。\n任何参数对 $(R_1, R_2)$，只要满足 $R_1 + R_2 = R_{sum}$ (且 $R_1 > 0, R_2 > 0$)，并且它们共享相同的时间常数 $\\tau$，都将产生相同的阻抗函数。这定义了一个等效模型的连续单参数族，形成了一个不可区分参数化的连续体。对于给定的总电阻 $R_{sum}$，我们可以选择任意 $R_1 \\in (0, R_{sum})$，并设 $R_2 = R_{sum} - R_1$。这给出了一个有效的参数集 $(R_0, R_1, \\tau, R_{sum}-R_1, \\tau)$，它与任何其他这样的选择都是不可区分的。\n\n### 完整的代数不变量集\n两个参数元组是等价的，当且仅当它们生成相同的阻抗函数 $Z(s)$。这等价于它们生成相同的系数集 $(a_0, a_1, a_2, b_1, b_2)$。我们寻求一个由原始参数 $(R_0, R_1, \\tau_1, R_2, \\tau_2)$ 构成的最小且完备的函数集，该函数集唯一地确定这些系数。这些函数构成了参数到阻抗映射的不变量的一个基。\n如第 2 节所示，这些系数本身可以表示为原始参数的五个关键组合的函数。这些组合在支路置换下是不变的，并且它们足以重构 $Z(s)$。\n这样一个完备且最小的代数不变量集是：\n1.  $I_1 = R_0$：辨识高频电阻。\n2.  $I_2 = \\tau_1 + \\tau_2$：时间常数之和。\n3.  $I_3 = \\tau_1\\tau_2$：时间常数之积。\n4.  $I_4 = R_1 + R_2$：支路电阻之和。\n5.  $I_5 = R_1\\tau_2 + R_2\\tau_1$：一个耦合了电阻和时间常数的加权和。\n\n这五个量由阻抗谱唯一确定。任何两个参数集 $(R_0, R_1, \\tau_1, R_2, \\tau_2)$ 和 $(R'_0, R'_1, \\tau'_1, R'_2, \\tau'_2)$ 产生相同的阻抗函数，当且仅当这两个集合的这五个不变量具有相同的值。因此，这五个参数函数集完全地对等价类进行了分类。最终答案是由这五个表达式组成的行向量。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nR_0 & \\tau_1 + \\tau_2 & \\tau_1 \\tau_2 & R_1 + R_2 & R_1 \\tau_2 + R_2 \\tau_1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "确保模型结构合理后，我们必须分析参数估计的结果，以诊断实际应用中的可辨识性问题。此练习提供了一种动手实践方法，通过将参数协方差矩阵转换为更直观的相关矩阵来诊断所谓的“实际不可辨识性” 。掌握这种从协方差到相关的分析技巧，使您能够准确定位哪些参数难以独立估计，从而评估模型校准的可靠性。",
            "id": "3936947",
            "problem": "给定一个电池的等效电路模型（ECM），该模型包含两个电阻-电容（RC）支路和一个欧姆电阻。参数向量的顺序为 $\\boldsymbol{\\theta} = [R_0, R_1, C_1, R_2, C_2]^\\top$，其中 $R_0$ 是欧姆电阻，$(R_1,C_1)$ 是第一个RC支路的电阻和电容，$(R_2,C_2)$ 是第二个RC支路的电阻和电容。假设一个系统辨识过程在加性、零均值、高斯测量噪声下，已生成参数协方差矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{5 \\times 5}$ 的一个无偏估计。你的任务是实现一个程序，对于每个给定的测试协方差矩阵：\n- 通过符合数学原理的归一化方法构建参数相关矩阵，\n- 根据绝对相关性的阈值，识别所有“近似相关”的参数索引对，\n- 并通过对 $\\boldsymbol{\\Sigma}$ 中包含的信息进行秩检验，在线性化水平上评估结构可辨识性。\n\n你必须从协方差和相关性的基本定义出发，而不是使用简化公式。请谨慎处理任何零方差的对角线元素：如果 $[\\boldsymbol{\\Sigma}]_{ii} = 0$ 或 $[\\boldsymbol{\\Sigma}]_{jj} = 0$，则涉及索引 $i$ 或 $j$ 的相应相关性条目因归一化而未定义；在你的实现中，应将这类未定义的相关性值设为 $0$，并且不要标记涉及未定义相关性的参数对。\n\n近似相关阈值：设相关性阈值为 $\\tau = 0.95$。如果一对参数 $(i,j)$（其中 $i  j$）的绝对相关性 $|\\rho_{ij}|$ 超过给定阈值，则应将其标记为近似相关。",
            "solution": "该问题要求基于给定的参数协方差矩阵 $\\boldsymbol{\\Sigma}$，对一个5参数电池等效电路模型（ECM）进行参数可辨识性分析。对于每个给定的矩阵，该分析包括三个主要步骤：(1) 计算参数相关矩阵，(2) 识别近似线性相关的参数对，以及 (3) 通过对协方差矩阵进行秩检验来评估结构可辨识性。\n\n设参数向量为 $\\boldsymbol{\\theta} = [\\theta_0, \\theta_1, \\theta_2, \\theta_3, \\theta_4]^\\top$，对应于 $[R_0, R_1, C_1, R_2, C_2]^\\top$。协方差矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{5 \\times 5}$ 提供了关于估计参数不确定性和相互依赖性的信息。元素 $\\Sigma_{ij}$ 表示参数 $\\theta_i$ 和 $\\theta_j$ 之间的协方差。对角线元素 $\\Sigma_{ii}$ 表示每个参数 $\\theta_i$ 的方差，记为 $\\sigma_i^2$。\n\n**1. 相关矩阵计算**\n\n两个参数 $\\theta_i$ 和 $\\theta_j$ 之间的皮尔逊相关系数 $\\rho_{ij}$ 是对其线性关系的归一化度量。它是通过用相应参数的标准差对协方差 $\\Sigma_{ij}$进行归一化得到的。参数 $\\theta_i$ 的标准差为 $\\sigma_i = \\sqrt{\\Sigma_{ii}}$。\n\n相关性 $\\rho_{ij}$ 定义为：\n$$\n\\rho_{ij} = \\frac{\\text{cov}(\\theta_i, \\theta_j)}{\\sigma_i \\sigma_j} = \\frac{\\Sigma_{ij}}{\\sqrt{\\Sigma_{ii}} \\sqrt{\\Sigma_{jj}}}\n$$\n最终得到的相关矩阵 $\\mathbf{P}$ 是一个对称矩阵，其元素为 $\\rho_{ij}$，且 $\\rho_{ii} = 1$。\n\n当参数的方差为零时，即 $\\Sigma_{ii} = 0$，会出现一个关键问题。这意味着该参数已被完全确定或固定，其标准差 $\\sigma_i$ 为 $0$。在这种情况下，相关性公式中的分母为零，导致相关系数在数学上未定义。问题指定了对此情况的实际处理方法：如果 $\\Sigma_{ii}=0$ 或 $\\Sigma_{jj}=0$，则相应的相关性 $\\rho_{ij}$ 应设为 $0$。这确保了这类参数对不会被标记为近似相关。\n\n在矩阵表示法中，相关矩阵 $\\mathbf{P}$ 可以通过一个对角缩放矩阵从协方差矩阵 $\\boldsymbol{\\Sigma}$ 计算得出。令 $\\mathbf{S}$ 为一个对角矩阵，其对角线元素为标准差的倒数：\n$$\nS_{ii} = \\begin{cases} 1/\\sigma_i = 1/\\sqrt{\\Sigma_{ii}}  \\text{if } \\Sigma_{ii} > 0 \\\\ 0  \\text{if } \\Sigma_{ii} = 0 \\end{cases}\n$$\n则相关矩阵由下式给出：\n$$\n\\mathbf{P} = \\mathbf{S} \\boldsymbol{\\Sigma} \\mathbf{S}\n$$\n此操作会正确填充相关矩阵，并将与零方差参数相对应的任何行和列都设置为零。\n\n**2. 近似相关性识别**\n\n两个参数之间的高相关性（即 $|\\rho_{ij}|$ 接近 $1$）表明存在强线性关系。这是系统辨识中的一个常见问题，称为多重共线性或实际不可辨识性。它表明参数无法被独立估计；一个参数的变化可以被另一个参数的线性变化所补偿，而不会显著影响模型输出。这使得参数估计变得敏感且不可靠。\n\n问题将“近似相关”的参数对 $(i,j)$ 定义为绝对相关性 $|\\rho_{ij}|$ 超过给定阈值 $\\tau$ 的参数对。指定的阈值为 $\\tau = 0.95$。分析过程包括遍历所有唯一的参数对 $(i,j)$（其中 $i  j$），并检查它们的绝对相关性是否超过该阈值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the battery parameter identifiability problem for the given test cases.\n    \"\"\"\n\n    # --- Problem Givens ---\n    \n    # Near-dependence threshold\n    tau = 0.95\n    \n    # Parameter dimension\n    n_params = 5\n\n    # Test cases for the covariance matrix Sigma\n    test_cases = [\n        # Case 1 (happy path)\n        np.array([\n            [0.0001, 0.00002, -0.1, 0.000003, 0.0],\n            [0.00002, 0.0004, 3.88, 0.000015, -0.072],\n            [-0.1, 3.88, 40000.0, 0.0, 360.0],\n            [0.000003, 0.000015, 0.0, 0.000225, -2.16],\n            [0.0, -0.072, 360.0, -2.16, 32400.0]\n        ]),\n        # Case 2 (boundary with zero variance)\n        np.array([\n            [0.000064, 0.000006, -0.024, 0.0, 0.0],\n            [0.000006, 0.000225, 2.025, 0.0, -0.18],\n            [-0.024, 2.025, 22500.0, 0.0, -12600.0],\n            [0.0, 0.0, 0.0, 0.0, 0.0],\n            [0.0, -0.18, -12600.0, 0.0, 14400.0]\n        ]),\n        # Case 3 (edge with near-perfect correlations)\n        np.array([\n            [0.000144, 0.00003, 0.264, 0.0, 0.0],\n            [0.00003, 0.000625, 5.4725, -0.000025, 0.0],\n            [0.264, 5.4725, 48400.0, -0.44, 2200.0],\n            [0.0, -0.000025, -0.44, 0.0004, -3.98],\n            [0.0, 0.0, 2200.0, -3.98, 40000.0]\n        ])\n    ]\n\n    all_results = []\n    for sigma in test_cases:\n        # --- 1. Correlation Matrix Calculation ---\n        \n        # Extract variances (diagonal elements)\n        variances = np.diag(sigma)\n        \n        # Calculate standard deviations, handling potential sqrt(0)\n        std_devs = np.sqrt(np.maximum(variances, 0))\n        \n        # Initialize correlation matrix\n        corr_matrix = np.zeros_like(sigma)\n        \n        # Calculate correlation coefficients element-wise\n        for i in range(n_params):\n            for j in range(n_params):\n                denominator = std_devs[i] * std_devs[j]\n                if denominator > 0:\n                    corr_matrix[i, j] = sigma[i, j] / denominator\n                # If denominator is 0, correlation remains 0 as per initialization\n                # and problem specification.\n\n        # --- 2. Near-Dependence Identification ---\n        \n        near_dependent_pairs = []\n        # Iterate over the upper triangle of the correlation matrix (i  j)\n        for i in range(n_params):\n            for j in range(i + 1, n_params):\n                if abs(corr_matrix[i, j]) > tau:\n                    near_dependent_pairs.append([i, j])\n\n        # --- 3. Structural Identifiability Assessment ---\n        \n        # Use numerical rank test on the covariance matrix\n        rank = np.linalg.matrix_rank(sigma)\n        is_identifiable = (rank == n_params)\n        \n        # --- Format Output for Current Case ---\n        \n        case_result = [near_dependent_pairs, is_identifiable]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The default str() representation for lists in Python includes spaces,\n    # which aligns with the use of '\\,' in the problem's LaTeX example.\n    # The provided snippet is followed literally.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "诊断出可辨识性问题自然会引出下一个问题：我们如何设计实验来从一开始就避免这些问题？这项实践深入探讨了优化实验设计的核心，要求您为不同实验条件下的电池模型计算Fisher信息矩阵 (Fisher Information Matrix, FIM) 。通过这个基于仿真的练习，您将直观地理解诸如输入电流波形和采样率等设计选择如何直接影响FIM，并最终决定参数的不确定性和相关性，从而使您能够设计出信息量更丰富的实验。",
            "id": "3936961",
            "problem": "您正在为一个用于基于仿真的设计的简化锂离子电池等效电路模型设计一个自动可辨识性评估工具。必须将实际可辨识性量化为传感器噪声水平和采样率的函数。假设一个带有一个极化支路的阻容戴维南模型，该模型由一个线性时不变状态和一个带有加性高斯噪声的线性输出所控制。目标是计算费雪信息矩阵 (FIM) 和一个拉普拉斯近似的后验集中度，然后为几个测试用例提取可辨识性和相关性度量。\n\n基本原理：\n- 状态变量是极化电压 $x(t)$，其演化过程如下\n$$\\frac{dx}{dt} = -\\frac{1}{R_1 C_1} x(t) + \\frac{1}{C_1} I(t),$$ \n其中 $R_1$ 是以欧姆为单位的极化电阻，$C_1$ 是以法拉为单位的极化电容，而 $I(t)$ 是以安培为单位的施加电流。\n- 输出电压为\n$$y(t) = V_{\\mathrm{OC}} + R_0 I(t) + x(t) + \\varepsilon(t),$$ \n其中 $R_0$ 是以欧姆为单位的欧姆电阻，$V_{\\mathrm{OC}}$ 是以伏特为单位的已知恒定开路电压，而 $\\varepsilon(t)$ 是方差为 $\\sigma^2$ (单位为平方伏特) 的零均值独立高斯传感器噪声。\n- 参数向量为 $\\theta = [R_0, R_1, C_1]^\\top$。\n- 对于独立高斯噪声，费雪信息矩阵为\n$$F(\\theta) = \\frac{1}{\\sigma^2} \\sum_{k=0}^{N-1} J_k^\\top J_k,$$\n其中 $J_k = \\frac{\\partial y(t_k)}{\\partial \\theta}$ 是在采样时间 $t_k$ 评估的输出雅可比矩阵。\n\n灵敏度基础：\n- 令 $S_i(t) = \\frac{\\partial x(t)}{\\partial \\theta_i}$ 为状态相对于参数的灵敏度。对于一个平滑的右侧函数 $f(x,\\theta,t)$，前向灵敏度方程为\n$$\\frac{dS_i}{dt} = \\frac{\\partial f}{\\partial x} S_i + \\frac{\\partial f}{\\partial \\theta_i}.$$\n对于 $f(x,\\theta,t) = -\\frac{1}{R_1 C_1} x + \\frac{1}{C_1} I(t)$，可以得出\n$$\\frac{\\partial f}{\\partial x} = -\\frac{1}{R_1 C_1}, \\quad \\frac{\\partial f}{\\partial R_1} = \\frac{x}{R_1^2 C_1}, \\quad \\frac{\\partial f}{\\partial C_1} = \\frac{x}{R_1 C_1^2} - \\frac{I(t)}{C_1^2}, \\quad \\frac{\\partial f}{\\partial R_0} = 0.$$\n- 因此，输出雅可比矩阵的分量为\n$$\\frac{\\partial y}{\\partial R_0} = I(t), \\quad \\frac{\\partial y}{\\partial R_1} = S_{R_1}(t), \\quad \\frac{\\partial y}{\\partial C_1} = S_{C_1}(t),$$\n其中 $S_{R_1}(t)$ 和 $S_{C_1}(t)$ 是灵敏度微分方程在初始条件 $S_{R_1}(0) = 0$ 和 $S_{C_1}(0) = 0$ 下的解。\n\n后验基础：\n- 在拉普拉斯近似和局部线性化下，给定数据的 $\\theta$ 的后验协方差为\n$$\\Sigma \\approx F(\\theta)^{-1},$$ \n假设 $F(\\theta)$ 是非奇异的；否则使用 Moore–Penrose 伪逆来处理秩亏。\n- 相关矩阵 $C$ 是通过对 $\\Sigma$ 进行归一化得到的：\n$$C_{ij} = \\frac{\\Sigma_{ij}}{\\sqrt{\\Sigma_{ii} \\Sigma_{jj}}}.$$\n\n算法任务：\n- 对于每个测试用例，使用与采样间隔对齐的离散前向 Euler 积分器在固定时间范围内模拟动力学。使用电流输入计算状态 $x(t_k)$ 和灵敏度 $S_{R_1}(t_k)$ 及 $S_{C_1}(t_k)$，构成 $J_k$，并累积 FIM。计算后验协方差和相关性度量，然后提取可辨识性度量。\n\n模型参数和单位：\n- 使用 $R_0 = 0.05$ 欧姆，$R_1 = 0.02$ 欧姆，$C_1 = 2400$ 法拉，以及 $V_{\\mathrm{OC}} = 3.7$ 伏特。这些在仿真中是固定且已知的。\n- 输入电流 $I(t)$ 以安培表示。传感器噪声标准差 $\\sigma$ 以伏特表示。采样率 $f_s$ 以赫兹（每秒采样数）表示。采样间隔为 $\\Delta t = 1/f_s$ 秒。\n- 当需要时，角频率隐式地以弧度/秒表示；角度不会显式出现。\n\n每个测试用例需计算的度量：\n- 费雪信息矩阵的对数行列式：$\\log \\det F$。如果 $F$ 是奇异的或数值上不定的，则将其定义为 $-\\infty$。\n- 最大归一化后验标准差：$\\max_i \\frac{\\sqrt{\\Sigma_{ii}}}{|\\theta_i|}$ (无量纲)。\n- 最大绝对后验相关性：$\\max_{i \\neq j} |C_{ij}|$ (无量纲)。\n- 可辨识性得分：一个浮点数，如果以下所有条件均成立，则等于 $1.0$，否则等于 $0.0$：\n  1. $\\min(\\lambda(F)) / \\max(\\lambda(F)) > 10^{-8}$，其中 $\\lambda(F)$ 表示 $F$ 的特征值。\n  2. $\\max_{i \\neq j} |C_{ij}|  0.95$。\n  3. $\\max_i \\frac{\\sqrt{\\Sigma_{ii}}}{|\\theta_i|}  0.5$。\n\n输入电流定义：\n- 对于测试用例 0 到 3，使用一个确定性的伪随机二进制序列式分段恒定电流，以 1 秒为段，循环通过 $\\{2.0, -1.5, 2.5, -2.0, 1.0, -3.0, 3.0, -1.0\\}$ 安培的电平，并重复此循环。\n- 对于测试用例 4，使用恒定电流 $I(t) = 0.5$ 安培，以说明在非持续激励输入下的结构不可辨识性。\n\n仿真时间范围：\n- 所有情况均使用总时间 $T = 200$ 秒。\n\n测试套件：\n- 情况 0：$\\sigma = 0.01$ 伏特，$f_s = 10$ 赫兹，输入如上定义。\n- 情况 1：$\\sigma = 0.05$ 伏特，$f_s = 10$ 赫兹，输入如上定义。\n- 情况 2：$\\sigma = 0.01$ 伏特，$f_s = 0.5$ 赫兹，输入如上定义。\n- 情况 3：$\\sigma = 0.005$ 伏特，$f_s = 100$ 赫兹，输入如上定义。\n- 情况 4：$\\sigma = 0.01$ 伏特，$f_s = 10$ 赫兹，恒定电流输入如上定义。\n\n数值实现细节：\n- 对状态和灵敏度微分方程均使用步长为 $\\Delta t$ 的前向 Euler 离散化。\n- 初始化 $x(0) = 0$ 伏特和 $S_{R_1}(0) = S_{C_1}(0) = 0$。\n- 在每个采样时间 $t_k$，计算输出雅可比矩阵\n$$J_k = \\begin{bmatrix} I(t_k)  S_{R_1}(t_k)  S_{C_1}(t_k) \\end{bmatrix}.$$\n\n最终输出规格：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。对于从 0 到 4 的每个测试用例，按以下顺序附加四个度量：$[\\log \\det F, \\max_i \\frac{\\sqrt{\\Sigma_{ii}}}{|\\theta_i|}, \\max_{i \\neq j} |C_{ij}|, \\text{可辨识性得分}]$。最终输出是所有五个案例的这些度量的串联，形成一个包含 20 个数字的扁平列表，打印为一行，例如 $[m_{0,1},m_{0,2},m_{0,3},m_{0,4},m_{1,1},\\dots,m_{4,4}]$。",
            "solution": "该问题被评估为**有效**。它在科学上基于系统辨识和状态空间建模的原理，采用了费雪信息矩阵 (FIM) 和灵敏度分析等标准技术。该问题是适定的，提供了所有必要的参数、初始条件和一个清晰、明确的算法-数值任务。所有术语都得到了精确定义，并且测试用例的构建旨在探究参数可辨识性的不同方面，包括一个旨在展示在非持续激励输入下结构不可辨识性的案例。整个设置是自洽、一致且计算上可行的。\n\n解决方案通过实现指定的算法来推进。对于每个测试用例，我们模拟一个简化的锂离子电池 Thevenin 等效电路模型。该模型由一个线性时不变状态空间表示描述。分析的核心在于计算费雪信息矩阵，它量化了实验数据中包含的关于未知参数 $\\theta = [R_0, R_1, C_1]^\\top$ 的信息量。\n\n仿真是使用步长为 $\\Delta t = 1/f_s$ 的前向 Euler 离散化方案进行的，其中 $f_s$ 是采样频率。极化电压 $x(t)$ 的状态方程以及相关的灵敏度方程 $S_{R_1}(t) = \\frac{\\partial x(t)}{\\partial R_1}$ 和 $S_{C_1}(t) = \\frac{\\partial x(t)}{\\partial C_1}$ 被同时积分。\n\n状态和灵敏度的常微分方程 (ODE) 如下：\n$$\n\\frac{dx}{dt} = -\\frac{1}{R_1 C_1} x(t) + \\frac{1}{C_1} I(t)\n$$\n$$\n\\frac{dS_{R_1}}{dt} = -\\frac{1}{R_1 C_1} S_{R_1}(t) + \\frac{x(t)}{R_1^2 C_1}\n$$\n$$\n\\frac{dS_{C_1}}{dt} = -\\frac{1}{R_1 C_1} S_{C_1}(t) + \\frac{x(t)}{R_1 C_1^2} - \\frac{I(t)}{C_1^2}\n$$\n所有变量在 $t=0$ 时初始化为零。使用步长为 $\\Delta t$ 的前向 Euler 方法的离散时间更新规则如下：\n$$\nx_{k+1} = x_k + \\Delta t \\left( -\\frac{x_k}{R_1 C_1} + \\frac{I_k}{C_1} \\right)\n$$\n$$\nS_{R_1, k+1} = S_{R_1, k} + \\Delta t \\left( -\\frac{S_{R_1, k}}{R_1 C_1} + \\frac{x_k}{R_1^2 C_1} \\right)\n$$\n$$\nS_{C_1, k+1} = S_{C_1, k} + \\Delta t \\left( -\\frac{S_{C_1, k}}{R_1 C_1} + \\frac{x_k}{R_1 C_1^2} - \\frac{I_k}{C_1^2} \\right)\n$$\n其中 $I_k = I(t_k)$ 是在时间 $t_k = k \\Delta t$ 时的电流。\n\n在每个时间步 $t_k$，计算输出灵敏度雅可比矩阵 $J_k = \\frac{\\partial y(t_k)}{\\partial \\theta}$。雅可比矩阵的分量为：\n$$\nJ_k = \\begin{bmatrix} \\frac{\\partial y_k}{\\partial R_0}  \\frac{\\partial y_k}{\\partial R_1}  \\frac{\\partial y_k}{\\partial C_1} \\end{bmatrix} = \\begin{bmatrix} I(t_k)  S_{R_1}(t_k)  S_{C_1}(t_k) \\end{bmatrix}\n$$\nFIM 在 $T = 200$ 秒的仿真时间范围内累积，该范围包含 $N = \\lfloor T \\cdot f_s \\rfloor$ 个样本：\n$$\nF(\\theta) = \\frac{1}{\\sigma^2} \\sum_{k=0}^{N-1} J_k^\\top J_k\n$$\n其中 $\\sigma^2$ 是噪声方差。\n\n仿真结束后，从得到的 FIM 计算出四个度量：\n\n1.  **FIM 的对数行列式, $\\log \\det F$**: 该度量量化了信息椭球的总体积。值越大表示信息越多。如果 FIM 是奇异的或数值上不定的（这可能在激励不足时发生），其行列式为非正数。在这种情况下，该值设为 $-\\infty$。这是使用 `numpy.linalg.slogdet` 计算的。\n\n2.  **后验协方差和归一化标准差**: 在 Laplace 近似下，参数的后验协方差矩阵近似为 FIM 的逆，$\\Sigma \\approx F^{-1}$。为了处理潜在的奇异性（不可辨识性），使用 Moore-Penrose 伪逆 $\\Sigma = F^+$。对角元素 $\\Sigma_{ii}$ 表示参数 $\\theta_i$ 的后验方差。最大归一化标准差 $\\max_i \\frac{\\sqrt{\\Sigma_{ii}}}{|\\theta_i|}$ 提供了一个与尺度无关的参数不确定性度量。\n\n3.  **最大绝对后验相关性**: 归一化协方差矩阵的非对角元素 $C_{ij} = \\frac{\\Sigma_{ij}}{\\sqrt{\\Sigma_{ii} \\Sigma_{jj}}}$ 给出参数估计值之间的后验相关性。度量 $\\max_{i \\neq j} |C_{ij}|$ 量化了任意两个参数估计之间最强的线性依赖关系。高相关性（接近 1）是可辨识性差的标志。\n\n4.  **可辨识性得分**: 基于三个量化标准分配一个二元分数（可辨识为 $1.0$，否则为 $0.0$）：\n    a. FIM 必须是良态的：$\\min(\\lambda(F)) / \\max(\\lambda(F)) > 10^{-8}$，其中 $\\lambda(F)$ 是特征值。该比率是条件数的倒数。一个很小的值表示接近奇异。\n    b. 参数估计不能过度相关：$\\max_{i \\neq j} |C_{ij}|  0.95$。\n    c. 每个参数的相对不确定性必须是可接受的：$\\max_i \\frac{\\sqrt{\\Sigma_{ii}}}{|\\theta_i|}  0.5$。\n\n将整个过程应用于五个测试用例，改变传感器噪声 $\\sigma$、采样率 $f_s$ 和输入电流曲线 $I(t)$。最终输出是为五个案例中的每一个计算的四个度量的扁平化列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the identifiability analysis for all test cases.\n    \"\"\"\n\n    # --- Model and Simulation Parameters ---\n    R0_true = 0.05   # Ohms\n    R1_true = 0.02   # Ohms\n    C1_true = 2400.0 # Farads\n    T_horizon = 200.0 # seconds\n\n    theta_true = np.array([R0_true, R1_true, C1_true])\n\n    I_sequence = np.array([2.0, -1.5, 2.5, -2.0, 1.0, -3.0, 3.0, -1.0])\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case 0: Baseline\n        {'sigma': 0.01, 'fs': 10.0, 'input_type': 'piecewise'},\n        # Case 1: Increased noise\n        {'sigma': 0.05, 'fs': 10.0, 'input_type': 'piecewise'},\n        # Case 2: Lower sampling rate\n        {'sigma': 0.01, 'fs': 0.5, 'input_type': 'piecewise'},\n        # Case 3: High resolution (low noise, high fs)\n        {'sigma': 0.005, 'fs': 100.0, 'input_type': 'piecewise'},\n        # Case 4: Non-persistent excitation (constant current)\n        {'sigma': 0.01, 'fs': 10.0, 'input_type': 'constant'},\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        FIM = run_simulation(case_params, R0_true, R1_true, C1_true, T_horizon, I_sequence)\n        metrics = compute_metrics(FIM, theta_true, case_params['sigma'])\n        all_results.extend(metrics)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef run_simulation(params, R0, R1, C1, T, I_seq):\n    \"\"\"\n    Simulates the battery model dynamics and accumulates the Fisher Information Matrix.\n    \"\"\"\n    fs = params['fs']\n    input_type = params['input_type']\n\n    dt = 1.0 / fs\n    num_steps = int(T / dt)\n\n    # Initialize state and sensitivities\n    x, S_R1, S_C1 = 0.0, 0.0, 0.0\n\n    # Initialize FIM accumulator\n    # The FIM is sum(J' * J). We accumulate this sum.\n    FIM_accumulator = np.zeros((3, 3))\n\n    # Pre-calculate expensive constants\n    tau_inv = 1.0 / (R1 * C1)\n    C1_inv = 1.0 / C1\n    R1_sq_C1_inv = 1.0 / (R1**2 * C1)\n    R1_C1_sq_inv = 1.0 / (R1 * C1**2)\n    C1_sq_inv = 1.0 / (C1**2)\n\n    for k in range(num_steps):\n        t_k = k * dt\n        \n        # Determine current I(t_k)\n        if input_type == 'piecewise':\n            I_k = I_seq[int(t_k) % len(I_seq)]\n        else: # 'constant'\n            I_k = 0.5\n\n        # --- Step 1: Form Jacobian at current state ---\n        Jk = np.array([I_k, S_R1, S_C1])\n\n        # --- Step 2: Update FIM accumulator ---\n        FIM_accumulator += np.outer(Jk, Jk)\n        \n        # --- Step 3: Update state and sensitivities using Forward Euler ---\n        # Derivatives\n        dx_dt = -tau_inv * x + C1_inv * I_k\n        dS_R1_dt = -tau_inv * S_R1 + R1_sq_C1_inv * x\n        dS_C1_dt = -tau_inv * S_C1 + R1_C1_sq_inv * x - C1_sq_inv * I_k\n\n        # Update\n        x += dt * dx_dt\n        S_R1 += dt * dS_R1_dt\n        S_C1 += dt * dS_C1_dt\n        \n    return FIM_accumulator\n\ndef compute_metrics(FIM_accumulator, theta, sigma):\n    \"\"\"\n    Computes the four required metrics from the final FIM.\n    \"\"\"\n    # Finalize FIM by scaling with noise variance\n    FIM = FIM_accumulator / (sigma**2)\n\n    # --- Metric 1: Log-determinant of FIM ---\n    sign, logdet = np.linalg.slogdet(FIM)\n    if sign > 0:\n        log_det_F = logdet\n    else:\n        log_det_F = float('-inf')\n\n    # --- Compute Posterior Covariance using Moore-Penrose Pseudoinverse ---\n    # This is numerically stable even for singular/ill-conditioned matrices\n    Sigma = linalg.pinv(FIM)\n\n    # --- Metric 2: Maximum normalized posterior standard deviation ---\n    # We must handle the case where a diagonal element of Sigma is negative\n    # due to numerical inaccuracies with pinv.\n    diag_Sigma = np.diag(Sigma)\n    stdevs = np.sqrt(np.maximum(0, diag_Sigma)) # Avoid sqrt of negative numbers\n    # Also handle theta_i = 0, though not the case here.\n    norm_stdevs = stdevs / np.abs(theta)\n    max_norm_std_dev = np.max(norm_stdevs)\n\n    # --- Metric 3: Maximum absolute posterior correlation ---\n    # C_ij = Sigma_ij / sqrt(Sigma_ii * Sigma_jj)\n    # To avoid division by zero if a variance is zero\n    epsilon = 1e-12\n    inv_stdevs = 1.0 / (stdevs + epsilon)\n    Corr_matrix = Sigma * np.outer(inv_stdevs, inv_stdevs)\n    np.fill_diagonal(Corr_matrix, 0) # We only want off-diagonal elements\n    max_abs_corr = np.max(np.abs(Corr_matrix))\n\n    # --- Metric 4: Identifiability Score ---\n    # Condition 1: FIM is well-conditioned\n    try:\n        eigvals = linalg.eigvalsh(FIM)\n        # eigvalsh guarantees real eigenvalues for a symmetric matrix\n        if eigvals.min() = 0 or eigvals.max() == 0:\n             cond1 = False\n        else:\n             cond1 = (eigvals.min() / eigvals.max()) > 1e-8\n    except linalg.LinAlgError:\n        cond1 = False\n\n    # Condition 2: Correlations are not too high\n    cond2 = max_abs_corr  0.95\n    \n    # Condition 3: Uncertainties are not too high\n    cond3 = max_norm_std_dev  0.5\n    \n    identifiability_score = 1.0 if cond1 and cond2 and cond3 else 0.0\n\n    return [log_det_F, max_norm_std_dev, max_abs_corr, identifiability_score]\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}