{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of any battery charging simulation is the ability to accurately predict the transition between different charging stages. This first practice focuses on the crucial switch from the Constant Current (CC) to the Constant Voltage (CV) phase, using a standard Thevenin equivalent circuit model. This exercise  develops the essential skill of translating a physical model, including circuit dynamics and state-of-charge dependent voltage, into a solvable mathematical condition, providing a robust method for event detection in a dynamic simulation.",
            "id": "3949059",
            "problem": "You are given a physics-based charging model for a rechargeable electrochemical cell described by a Thevenin equivalent with one Resistive–Capacitive (RC) polarization branch. The Constant-Current–Constant-Voltage (CC–CV) charging protocol (Constant-Current–Constant-Voltage (CC–CV)) switches from constant current to constant voltage when the terminal voltage reaches a specified maximum. The task is to determine the exact switching time by solving a nonlinear condition derived from first principles of the Thevenin model and RC dynamics.\n\nAssume the following:\n- The open-circuit voltage $U(z)$ depends on the State of Charge (SOC) $z$ and is modeled as a cubic polynomial with coefficients $(a_0,a_1,a_2,a_3)$:\n$$\nU(z) = a_0 + a_1 z + a_2 z^2 + a_3 z^3.\n$$\n- The SOC evolves under constant charge current $I_{\\text{CC}}$ as\n$$\n\\frac{dz}{dt} = \\frac{I_{\\text{CC}}}{C}, \\quad z(t) = z_0 + \\frac{I_{\\text{CC}}}{C} t,\n$$\nwhere $C$ is the cell capacity in Coulombs and $z_0$ is the initial SOC (dimensionless).\n- The terminal voltage during the CC phase is\n$$\nV_{\\text{term}}(t) = U\\big(z(t)\\big) + I_{\\text{CC}} R_0 + V_1(t),\n$$\nwhere $R_0$ is the ohmic resistance in Ohms and $V_1(t)$ is the polarization voltage contributed by the RC branch.\n- The RC branch polarization voltage $V_1(t)$ obeys a first-order linear differential equation driven by the current input $I_{\\text{CC}}$:\n$$\n\\frac{dV_1}{dt} = -\\frac{1}{R_1 C_1} V_1 + \\frac{I_{\\text{CC}}}{C_1},\n$$\nwith initial condition $V_1(0) = V_{1,0}$, where $R_1$ is the polarization resistance in Ohms and $C_1$ is the polarization capacitance in Farads.\n\nThe CC–CV switching time $t^\\star$ is defined as the smallest $t \\ge 0$ satisfying\n$$\nU\\big(z(t)\\big) + I_{\\text{CC}} R_0 + V_1(t) = V_{\\max},\n$$\nwhere $V_{\\max}$ is the constant-voltage target in Volts. Physically, charging is only meaningful while $z(t) \\le 1$, so $t$ must lie in the interval $[0, t_{\\text{stop}}]$ where\n$$\nt_{\\text{stop}} = \\frac{(1 - z_0) C}{I_{\\text{CC}}}.\n$$\nIf $V_{\\text{term}}(0) \\ge V_{\\max}$, then $t^\\star = 0$. If $V_{\\text{term}}(t)  V_{\\max}$ for all $t \\in [0, t_{\\text{stop}}]$, then the CC–CV transition is unreachable under the given parameters; in this case, return $-1.0$.\n\nDerive and implement an algorithm to compute $t^\\star$ under these assumptions for a given parameter set. Express the final switching time in seconds, as a floating-point number rounded to $10^{-6}$ seconds.\n\nTest Suite:\nUse the following four test cases. In all cases, the open-circuit voltage coefficients are $(a_0,a_1,a_2,a_3) = (3.0, 1.0, -0.2, 0.4)$, with units in Volts.\n\n- Test Case $1$ (general case):\n  - $C = 10800$ Coulombs\n  - $z_0 = 0.2$\n  - $R_0 = 0.05$ Ohms\n  - $R_1 = 0.02$ Ohms\n  - $C_1 = 5000$ Farads\n  - $I_{\\text{CC}} = 3.0$ Amperes\n  - $V_{\\max} = 4.2$ Volts\n  - $V_{1,0} = 0.0$ Volts\n\n- Test Case $2$ (immediate switch due to high initial polarization and SOC):\n  - $C = 10800$ Coulombs\n  - $z_0 = 0.95$\n  - $R_0 = 0.05$ Ohms\n  - $R_1 = 0.02$ Ohms\n  - $C_1 = 5000$ Farads\n  - $I_{\\text{CC}} = 3.0$ Amperes\n  - $V_{\\max} = 4.2$ Volts\n  - $V_{1,0} = 0.4$ Volts\n\n- Test Case $3$ (unreachable CV target within SOC range):\n  - $C = 10800$ Coulombs\n  - $z_0 = 0.2$\n  - $R_0 = 0.05$ Ohms\n  - $R_1 = 0.02$ Ohms\n  - $C_1 = 5000$ Farads\n  - $I_{\\text{CC}} = 3.0$ Amperes\n  - $V_{\\max} = 4.5$ Volts\n  - $V_{1,0} = 0.0$ Volts\n\n- Test Case $4$ (dynamic transient with negative initial polarization):\n  - $C = 7200$ Coulombs\n  - $z_0 = 0.1$\n  - $R_0 = 0.03$ Ohms\n  - $R_1 = 0.015$ Ohms\n  - $C_1 = 3000$ Farads\n  - $I_{\\text{CC}} = 2.5$ Amperes\n  - $V_{\\max} = 4.1$ Volts\n  - $V_{1,0} = -0.1$ Volts\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"). Each result must be a floating-point number in seconds, rounded to $10^{-6}$, following the rules above for immediate switch and unreachable cases.",
            "solution": "The user-provided problem is valid. It is scientifically grounded in standard electrochemical cell modeling, mathematically well-posed, and all necessary parameters and conditions are provided. Proceeding with the solution.\n\nThe problem requires finding the switching time $t^\\star$ from the Constant-Current (CC) phase to the Constant-Voltage (CV) phase in a CC-CV charging protocol for a rechargeable cell. The cell is modeled by a Thevenin equivalent circuit with one RC branch. The switching time $t^\\star$ is defined as the smallest time $t \\ge 0$ where the terminal voltage $V_{\\text{term}}(t)$ reaches a predefined maximum voltage $V_{\\max}$.\n\nThe terminal voltage during the CC phase is given by:\n$$\nV_{\\text{term}}(t) = U\\big(z(t)\\big) + I_{\\text{CC}} R_0 + V_1(t)\n$$\nwhere $U(z)$ is the open-circuit voltage (OCV) dependent on the State of Charge (SOC) $z$, $I_{\\text{CC}}$ is the constant charging current, $R_0$ is the ohmic resistance, and $V_1(t)$ is the polarization voltage across the RC branch.\n\nThe components of this equation must be expressed as explicit functions of time $t$.\n\nFirst, the State of Charge $z(t)$ evolves linearly with time from an initial SOC $z_0$ under a constant current $I_{\\text{CC}}$:\n$$\nz(t) = z_0 + \\frac{I_{\\text{CC}}}{C} t\n$$\nwhere $C$ is the total capacity of the cell in Coulombs.\n\nSecond, the open-circuit voltage $U(z)$ is a cubic polynomial in $z$:\n$$\nU(z) = a_0 + a_1 z + a_2 z^2 + a_3 z^3\n$$\nSubstituting the expression for $z(t)$, we obtain the time-dependent OCV, $U(t)$:\n$$\nU(t) = a_0 + a_1 \\left(z_0 + \\frac{I_{\\text{CC}}}{C} t\\right) + a_2 \\left(z_0 + \\frac{I_{\\text{CC}}}{C} t\\right)^2 + a_3 \\left(z_0 + \\frac{I_{\\text{CC}}}{C} t\\right)^3\n$$\n\nThird, the polarization voltage $V_1(t)$ is governed by the first-order linear ordinary differential equation:\n$$\n\\frac{dV_1}{dt} = -\\frac{1}{R_1 C_1} V_1 + \\frac{I_{\\text{CC}}}{C_1}\n$$\nwith the initial condition $V_1(0) = V_{1,0}$. Let the time constant of the RC branch be $\\tau_1 = R_1 C_1$. The equation becomes:\n$$\n\\frac{dV_1}{dt} + \\frac{1}{\\tau_1} V_1 = \\frac{I_{\\text{CC}}}{C_1}\n$$\nThis is a standard first-order linear ODE whose solution is the sum of a homogeneous solution and a particular solution. The general solution is:\n$$\nV_1(t) = I_{\\text{CC}} R_1 + K e^{-t/\\tau_1}\n$$\nwhere $I_{\\text{CC}} R_1$ is the steady-state voltage and $K$ is a constant determined by the initial condition. At $t=0$:\n$$\nV_1(0) = V_{1,0} = I_{\\text{CC}} R_1 + K \\implies K = V_{1,0} - I_{\\text{CC}} R_1\n$$\nThus, the explicit solution for the polarization voltage is:\n$$\nV_1(t) = I_{\\text{CC}} R_1 + (V_{1,0} - I_{\\text{CC}} R_1) e^{-t/(R_1 C_1)}\n$$\n\nCombining all components, we get the full expression for the terminal voltage $V_{\\text{term}}(t)$:\n$$\nV_{\\text{term}}(t) = \\left( a_0 + a_1 z(t) + a_2 z(t)^2 + a_3 z(t)^3 \\right) + I_{\\text{CC}} R_0 + I_{\\text{CC}} R_1 + (V_{1,0} - I_{\\text{CC}} R_1) e^{-t/(R_1 C_1)}\n$$\nwhere $z(t) = z_0 + (I_{\\text{CC}}/C) t$.\n\nThe switching time $t^\\star$ is the root of the equation $V_{\\text{term}}(t) = V_{\\max}$. We define a function $f(t)$ whose root we seek:\n$$\nf(t) = V_{\\text{term}}(t) - V_{\\max} = 0\n$$\nThis equation is transcendental due to the presence of both polynomial and exponential terms in $t$, and thus must be solved numerically.\n\nThe algorithm to find $t^\\star$ is as follows:\n1.  **Check for immediate switching ($t^\\star=0$)**: Calculate the terminal voltage at $t=0$. If $V_{\\text{term}}(0) \\ge V_{\\max}$, the condition is met immediately, so $t^\\star = 0$.\n    $$\n    V_{\\text{term}}(0) = U(z_0) + I_{\\text{CC}} R_0 + V_{1,0}\n    $$\n\n2.  **Define the valid time interval**: Charging is physically meaningful only for $z(t) \\le 1$. The time to reach full charge ($z=1$) from $z_0$ is:\n    $$\n    t_{\\text{stop}} = \\frac{(1 - z_0) C}{I_{\\text{CC}}}\n    $$\n    The search for $t^\\star$ is confined to the interval $[0, t_{\\text{stop}}]$.\n\n3.  **Check for unreachable target**: Calculate the terminal voltage at the end of the CC charging phase, $V_{\\text{term}}(t_{\\text{stop}})$. The function $V_{\\text{term}}(t)$ is generally monotonically increasing during charging. Therefore, if $V_{\\text{term}}(t_{\\text{stop}})  V_{\\max}$, the target voltage is never reached within the valid SOC range. In this case, the problem specifies returning $-1.0$.\n\n4.  **Numerical root-finding**: If $V_{\\text{term}}(0)  V_{\\max}$ and $V_{\\text{term}}(t_{\\text{stop}}) \\ge V_{\\max}$, the Intermediate Value Theorem guarantees that at least one root $t^\\star$ exists in the interval $(0, t_{\\text{stop}}]$. We can find this root using a numerical method. The Brent-Dekker method (as implemented in `scipy.optimize.brentq`) is an excellent choice as it is robust and guaranteed to find a root within a given bracket $[a, b]$ where $f(a)$ and $f(b)$ have opposite signs. Here, our bracket is $[0, t_{\\text{stop}}]$.\n\nThe final result, $t^\\star$, must be rounded to $10^{-6}$ seconds. The special cases $t^\\star=0$ and the flag $-1.0$ will also be formatted to this precision for consistency of the output.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for the CC-CV switching time for a battery charging model.\n    \"\"\"\n    # Open-circuit voltage polynomial coefficients (a0, a1, a2, a3) in Volts.\n    a_coeffs = (3.0, 1.0, -0.2, 0.4)\n\n    test_cases = [\n        # Test Case 1: General case\n        {'C': 10800.0, 'z0': 0.2, 'R0': 0.05, 'R1': 0.02, 'C1': 5000.0,\n         'I_CC': 3.0, 'V_max': 4.2, 'V1_0': 0.0},\n        # Test Case 2: Immediate switch\n        {'C': 10800.0, 'z0': 0.95, 'R0': 0.05, 'R1': 0.02, 'C1': 5000.0,\n         'I_CC': 3.0, 'V_max': 4.2, 'V1_0': 0.4},\n        # Test Case 3: Unreachable CV target\n        {'C': 10800.0, 'z0': 0.2, 'R0': 0.05, 'R1': 0.02, 'C1': 5000.0,\n         'I_CC': 3.0, 'V_max': 4.5, 'V1_0': 0.0},\n        # Test Case 4: Dynamic transient with negative initial polarization\n        {'C': 7200.0, 'z0': 0.1, 'R0': 0.03, 'R1': 0.015, 'C1': 3000.0,\n         'I_CC': 2.5, 'V_max': 4.1, 'V1_0': -0.1}\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        C, z0, R0, R1, C1, I_CC, V_max, V1_0 = params.values()\n\n        def U(z, coeffs):\n            \"\"\"Calculates open-circuit voltage U(z).\"\"\"\n            a0, a1, a2, a3 = coeffs\n            return a0 + a1 * z + a2 * z**2 + a3 * z**3\n\n        def z_soc(t):\n            \"\"\"Calculates State of Charge z(t).\"\"\"\n            return z0 + (I_CC / C) * t\n\n        def V1_pol(t):\n            \"\"\"Calculates polarization voltage V1(t).\"\"\"\n            tau1 = R1 * C1\n            if tau1 == 0:\n                # If RC components are zero, voltage is at steady state\n                return I_CC * R1\n            return I_CC * R1 + (V1_0 - I_CC * R1) * np.exp(-t / tau1)\n\n        def V_term(t):\n            \"\"\"Calculates terminal voltage V_term(t).\"\"\"\n            current_z = z_soc(t)\n            ocv = U(current_z, a_coeffs)\n            v1 = V1_pol(t)\n            return ocv + I_CC * R0 + v1\n\n        # Define the function f(t) = V_term(t) - V_max whose root is t_star.\n        def f(t):\n            return V_term(t) - V_max\n\n        # 1. Check for immediate switch (t=0)\n        if V_term(0) = V_max:\n            t_star = 0.0\n            results.append(f\"{t_star:.6f}\")\n            continue\n\n        # 2. Define valid time interval and check for unreachable target\n        if I_CC = 0: # Charging current must be positive\n             t_star = -1.0\n             results.append(f\"{t_star:.6f}\")\n             continue\n             \n        t_stop = (1.0 - z0) * C / I_CC\n        \n        if V_term(t_stop)  V_max:\n            t_star = -1.0\n            results.append(f\"{t_star:.6f}\")\n            continue\n\n        # 3. Find the root numerically within the interval [0, t_stop]\n        try:\n            t_star = brentq(f, a=0, b=t_stop)\n            results.append(f\"{t_star:.6f}\")\n        except ValueError:\n            # This case should not be reached due to prior checks,\n            # but is included for robustness.\n            results.append(f\"{-1.0:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world control systems often involve abrupt changes, such as a controller switching modes, which pose a challenge for continuous-time simulators. This practice  explores the fundamental principle of state continuity for energy storage elements (inductors and capacitors) during such an instantaneous event. By analyzing the consequences of a sudden change in the control input, you will learn how to correctly re-initialize a simulation's state derivatives post-event, a critical skill for building stable and physically accurate dynamic models.",
            "id": "3949123",
            "problem": "Consider a single-cell Lithium-ion battery being charged by a step-down converter modeled in the averaged sense. The battery is represented by a Thevenin equivalent with open-circuit voltage $V_{\\text{oc}}$ and series resistance $R_b$. The converter has input voltage $V_{\\text{in}}$, an output filter consisting of an inductor $L$ and capacitor $C$, and control duty ratio $d(t)$ that changes with a digital controller implementing Constant-Current–Constant-Voltage (CC–CV) charging. The averaged dynamics over a PWM period are modeled by the following well-tested relations combined with Kirchhoff’s Current Law (KCL) and Kirchhoff’s Voltage Law (KVL):\n- Inductor dynamics: \n$$\\dot{i}_L(t) = \\frac{1}{L}\\left[d(t)\\,V_{\\text{in}} - V_1(t)\\right],$$\n- Capacitor and battery coupling:\n$$\\dot{V}_1(t) = \\frac{1}{C}\\left[i_L(t) - I(t)\\right], \\quad I(t) = \\frac{V_1(t) - V_{\\text{oc}}}{R_b}.$$\n\nThe CC–CV controller switches from Constant-Current mode to Constant-Voltage mode when the measured output voltage crosses the voltage reference $V_{\\text{ref}}$. An event is detected at $t_s$, just before which the state and parameters are:\n- $V_1(t_s^{-}) = 4.190\\,\\text{V}$,\n- $i_L(t_s^{-}) = 3.000\\,\\text{A}$,\n- $V_{\\text{oc}}(t_s^{-}) = 3.900\\,\\text{V}$,\n- $R_b = 0.100\\,\\Omega$,\n- $V_{\\text{in}} = 12.000\\,\\text{V}$,\n- $L = 100\\,\\mu\\text{H} = 1.00\\times 10^{-4}\\,\\text{H}$,\n- $C = 1000\\,\\mu\\text{F} = 1.00\\times 10^{-3}\\,\\text{F}$,\n- $V_{\\text{ref}} = 4.200\\,\\text{V}$.\n\nDue to the controller mode change at $t_s$, the duty ratio switches instantaneously from $d(t_s^{-}) = 0.35$ to $d(t_s^{+}) = 0.40$. The simulation engine must re-initialize post-event quantities at $t_s^{+}$ to preserve physical consistency. Using fundamental energy storage properties (inductor flux and capacitor charge continuity), and the battery algebraic relation $I = (V_1 - V_{\\text{oc}})/R_b$, analyze the numerical effect of the duty jump on $\\dot{i}_L$ and $\\dot{V}_1$ across $t_s$, and determine which post-event re-initialization scheme keeps the solution physically consistent for the states $V_1$ and $I$. \n\nCompute the pre- and post-event derivatives:\n$$\\dot{i}_L(t_s^{-}) = \\frac{d(t_s^{-})\\,V_{\\text{in}} - V_1(t_s^{-})}{L}, \\quad \\dot{i}_L(t_s^{+}) = \\frac{d(t_s^{+})\\,V_{\\text{in}} - V_1(t_s^{+})}{L},$$\n$$\\dot{V}_1(t_s^{-}) = \\frac{i_L(t_s^{-}) - I(t_s^{-})}{C}, \\quad \\dot{V}_1(t_s^{+}) = \\frac{i_L(t_s^{+}) - I(t_s^{+})}{C},$$\nassuming physically consistent re-initialization of states at $t_s^{+}$, and discuss whether $V_1$ and $I$ can or cannot exhibit instantaneous jumps in an ideal model.\n\nSelect the most physically consistent re-initialization scheme from the options below:\n\nA. At $t_s^{+}$, hard-set $V_1(t_s^{+}) = V_{\\text{ref}}$ and $I(t_s^{+}) = I_{\\text{set}}$ (the previous Constant-Current setpoint), then recompute $i_L(t_s^{+})$ by enforcing $\\dot{V}_1(t_s^{+}) = 0$.\n\nB. Preserve $V_1$ continuity, but project the battery current to the Constant-Voltage boundary by setting $I(t_s^{+}) = \\dfrac{V_{\\text{ref}} - V_{\\text{oc}}}{R_b}$, and allow $i_L$ to jump accordingly.\n\nC. Enforce continuity of the energy-storage states by setting $V_1(t_s^{+}) = V_1(t_s^{-})$ and $i_L(t_s^{+}) = i_L(t_s^{-})$, recompute the algebraic battery current as $I(t_s^{+}) = \\dfrac{V_1(t_s^{+}) - V_{\\text{oc}}}{R_b}$, and update the duty ratio to $d(t_s^{+})$ according to the Constant-Voltage control law without altering the states. Then compute new derivatives from the governing equations.\n\nD. Enforce continuity of $i_L$ only, but snap $V_1(t_s^{+})$ to $V_{\\text{ref}}$, and compute $I(t_s^{+})$ from $I(t_s^{+}) = \\dfrac{V_1(t_s^{+}) - V_{\\text{oc}}}{R_b}$.\n\nWhich option is correct? Provide the numerical values of $\\dot{i}_L(t_s^{-})$, $\\dot{i}_L(t_s^{+})$, $\\dot{V}_1(t_s^{-})$, and $\\dot{V}_1(t_s^{+})$ under the correct scheme to support your answer, and justify which variables may exhibit discontinuities and which must remain continuous in this idealized averaged model.",
            "solution": "The problem statement is first validated for scientific soundness, consistency, and completeness.\n\n### Step 1: Extract Givens\n- **System Model:** Averaged step-down converter charging a Li-ion battery.\n- **Battery Model:** Thevenin equivalent with open-circuit voltage $V_{\\text{oc}}$ and series resistance $R_b$.\n- **Converter Model:** Input voltage $V_{\\text{in}}$, inductor $L$, capacitor $C$, duty ratio $d(t)$.\n- **Governing Equations:**\n$$\n\\dot{i}_L(t) = \\frac{1}{L}\\left[d(t)\\,V_{\\text{in}} - V_1(t)\\right]\n$$\n$$\n\\dot{V}_1(t) = \\frac{1}{C}\\left[i_L(t) - I(t)\\right]\n$$\n$$\nI(t) = \\frac{V_1(t) - V_{\\text{oc}}}{R_b}\n$$\n- **Control:** Constant-Current–Constant-Voltage (CC–CV) charging. A mode-switch event occurs at time $t_s$ when the measured output voltage $V_1(t)$ crosses the reference voltage $V_{\\text{ref}}$.\n- **Pre-event Conditions at $t_s^{-}$:**\n    - $V_1(t_s^{-}) = 4.190\\,\\text{V}$\n    - $i_L(t_s^{-}) = 3.000\\,\\text{A}$\n    - $V_{\\text{oc}}(t_s^{-}) = 3.900\\,\\text{V}$\n    - $R_b = 0.100\\,\\Omega$\n    - $V_{\\text{in}} = 12.000\\,\\text{V}$\n    - $L = 100\\,\\mu\\text{H} = 1.00\\times 10^{-4}\\,\\text{H}$\n    - $C = 1000\\,\\mu\\text{F} = 1.00\\times 10^{-3}\\,\\text{F}$\n    - $V_{\\text{ref}} = 4.200\\,\\text{V}$\n    - $d(t_s^{-}) = 0.35$\n- **Event at $t_s$:** The duty ratio switches instantaneously to $d(t_s^{+}) = 0.40$.\n- **Task:** Determine the physically consistent re-initialization scheme at $t_s^{+}$ and compute the state derivatives $\\dot{i}_L$ and $\\dot{V}_1$ just before and just after the event.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding:** The model is a standard state-space averaged model for a buck converter connected to a Thevenin equivalent load representing a battery. This is a fundamental and widely-accepted model in power electronics and battery simulation. The CC-CV charging protocol is standard for Li-ion batteries. All premises are scientifically sound.\n- **Well-Posedness  Consistency:** The problem provides a system of ordinary differential equations (ODEs) with an algebraic constraint. It defines an event caused by a discontinuous change in the input signal $d(t)$. The question asks for the proper handling of this event based on physical principles, which is a key aspect of simulating such hybrid systems. All necessary parameters are provided.\nTo check consistency, we compute the derivative of the voltage just before the event:\nThe battery current is $I(t_s^{-}) = (V_1(t_s^{-}) - V_{\\text{oc}}(t_s^{-}))/R_b = (4.190\\,\\text{V} - 3.900\\,\\text{V}) / 0.100\\,\\Omega = 2.900\\,\\text{A}$.\nThe capacitor voltage derivative is $\\dot{V}_1(t_s^{-}) = (i_L(t_s^{-}) - I(t_s^{-}))/C = (3.000\\,\\text{A} - 2.900\\,\\text{A}) / (1.00\\times 10^{-3}\\,\\text{F}) = 100\\,\\text{V/s}$.\nSince $\\dot{V}_1(t_s^{-})  0$, the voltage $V_1$ is increasing towards $V_{\\text{ref}}$, which is consistent with the impending event trigger. The problem is internally consistent and well-posed.\n- **Objectivity:** The problem is stated using precise, objective, and technical language.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. The analysis and solution will proceed.\n\n### Solution Derivation\n\nThe core of this problem lies in understanding the behavior of state variables in a physical system when subjected to an instantaneous change in input. The state variables in this system are the inductor current, $i_L(t)$, and the capacitor voltage, $V_1(t)$, because they represent the energy storage elements.\n\n**Fundamental Principle of State Continuity:**\nThe energy stored in an inductor is $E_L(t) = \\frac{1}{2}L\\,i_L(t)^2$, and the energy stored in a capacitor is $E_C(t) = \\frac{1}{2}C\\,V_1(t)^2$. In any physical system, stored energy cannot change instantaneously unless an infinite power is applied. An instantaneous change in inductor current would require an infinite voltage impulse across the inductor ($V_L = L \\frac{di_L}{dt}$). An instantaneous change in capacitor voltage would require an infinite current impulse into the capacitor ($i_C = C \\frac{dV_1}{dt}$).\n\nIn this problem, the input to the system is the duty cycle $d(t)$, which results in an averaged voltage $d(t)V_{\\text{in}}$. At time $t_s$, $d(t)$ undergoes a finite step change from $0.35$ to $0.40$. This causes a finite jump in the input voltage to the LC filter, but it does not introduce any infinite impulses (i.e., Dirac delta functions) into the system. Therefore, the state variables must be continuous across the event at $t_s$.\nThis implies:\n1.  **Continuity of Inductor Current:** $i_L(t_s^{+}) = i_L(t_s^{-})$\n2.  **Continuity of Capacitor Voltage:** $V_1(t_s^{+}) = V_1(t_s^{-})$\n\n**Behavior of Other Variables:**\n- **Battery Current $I(t)$:** This is an algebraic variable, defined by $I(t) = (V_1(t) - V_{\\text{oc}})/R_b$. The open-circuit voltage $V_{\\text{oc}}$ is a function of the state-of-charge (SOC), which is the time integral of the battery current. Since the current $I(t)$ is finite, the SOC is a continuous function of time, and thus $V_{\\text{oc}}(t)$ must also be continuous. As both $V_1(t)$ and $V_{\\text{oc}}(t)$ are continuous at $t_s$, the battery current $I(t)$ must also be continuous, i.e., $I(t_s^{+}) = I(t_s^{-})$.\n- **State Derivatives ($\\dot{i}_L(t), \\dot{V}_1(t)$):** The state derivatives depend directly or indirectly on the input $d(t)$. Since $d(t)$ is discontinuous at $t_s$, the state derivatives are expected to be discontinuous.\n\n**Numerical Calculation:**\n\n**1. Pre-Event Quantities at $t = t_s^{-}$**\n- States: $V_1(t_s^{-}) = 4.190\\,\\text{V}$, $i_L(t_s^{-}) = 3.000\\,\\text{A}$.\n- Input: $d(t_s^{-}) = 0.35$.\n- Battery Current: $I(t_s^{-}) = \\frac{V_1(t_s^{-}) - V_{\\text{oc}}(t_s^{-})}{R_b} = \\frac{4.190\\,\\text{V} - 3.900\\,\\text{V}}{0.100\\,\\Omega} = 2.900\\,\\text{A}$.\n- State Derivatives:\n$$ \\dot{i}_L(t_s^{-}) = \\frac{d(t_s^{-})\\,V_{\\text{in}} - V_1(t_s^{-})}{L} = \\frac{0.35 \\times 12.000\\,\\text{V} - 4.190\\,\\text{V}}{1.00\\times 10^{-4}\\,\\text{H}} = \\frac{4.200\\,\\text{V} - 4.190\\,\\text{V}}{1.00\\times 10^{-4}\\,\\text{H}} = \\frac{0.010\\,\\text{V}}{1.00\\times 10^{-4}\\,\\text{H}} = 100\\,\\text{A/s} $$\n$$ \\dot{V}_1(t_s^{-}) = \\frac{i_L(t_s^{-}) - I(t_s^{-})}{C} = \\frac{3.000\\,\\text{A} - 2.900\\,\\text{A}}{1.00\\times 10^{-3}\\,\\text{F}} = \\frac{0.100\\,\\text{A}}{1.00\\times 10^{-3}\\,\\text{F}} = 100\\,\\text{V/s} $$\n\n**2. Post-Event Re-initialization and Calculation at $t = t_s^{+}$**\n- Applying the principle of state continuity:\n    - $V_1(t_s^{+}) = V_1(t_s^{-}) = 4.190\\,\\text{V}$\n    - $i_L(t_s^{+}) = i_L(t_s^{-}) = 3.000\\,\\text{A}$\n- Input: $d(t_s^{+}) = 0.40$ (given).\n- Other continuous variables: $V_{\\text{oc}}(t_s^{+}) = V_{\\text{oc}}(t_s^{-}) = 3.900\\,\\text{V}$.\n- Re-computed Algebraic Variable:\n    - $I(t_s^{+}) = \\frac{V_1(t_s^{+}) - V_{\\text{oc}}(t_s^{+})}{R_b} = \\frac{4.190\\,\\text{V} - 3.900\\,\\text{V}}{0.100\\,\\Omega} = 2.900\\,\\text{A}$. As predicted, $I(t)$ is continuous.\n- New State Derivatives:\n$$ \\dot{i}_L(t_s^{+}) = \\frac{d(t_s^{+})\\,V_{\\text{in}} - V_1(t_s^{+})}{L} = \\frac{0.40 \\times 12.000\\,\\text{V} - 4.190\\,\\text{V}}{1.00\\times 10^{-4}\\,\\text{H}} = \\frac{4.800\\,\\text{V} - 4.190\\,\\text{V}}{1.00\\times 10^{-4}\\,\\text{H}} = \\frac{0.610\\,\\text{V}}{1.00\\times 10^{-4}\\,\\text{H}} = 6100\\,\\text{A/s} $$\n$$ \\dot{V}_1(t_s^{+}) = \\frac{i_L(t_s^{+}) - I(t_s^{+})}{C} = \\frac{3.000\\,\\text{A} - 2.900\\,\\text{A}}{1.00\\times 10^{-3}\\,\\text{F}} = \\frac{0.100\\,\\text{A}}{1.00\\times 10^{-3}\\,\\text{F}} = 100\\,\\text{V/s} $$\nThe derivative $\\dot{i}_L$ jumps from $100\\,\\text{A/s}$ to $6100\\,\\text{A/s}$ due to the step change in duty cycle. The derivative $\\dot{V}_1$ happens to remain unchanged because the quantities in its governing equation, $i_L$ and $I$, are both continuous.\n\n### Evaluation of Options\n\nA. At $t_s^{+}$, hard-set $V_1(t_s^{+}) = V_{\\text{ref}}$ and $I(t_s^{+}) = I_{\\text{set}}$ (the previous Constant-Current setpoint), then recompute $i_L(t_s^{+})$ by enforcing $\\dot{V}_1(t_s^{+}) = 0$.\n**Analysis:** This procedure is physically incorrect. It violates the principle of capacitor voltage continuity by forcing an instantaneous jump in $V_1$ from $4.190\\,\\text{V}$ to $4.200\\,\\text{V}$. This would require an infinite current impulse. Forcing $\\dot{V}_1(t_s^{+})=0$ is also an artificial constraint not derived from the system physics.\n**Verdict:** Incorrect.\n\nB. Preserve $V_1$ continuity, but project the battery current to the Constant-Voltage boundary by setting $I(t_s^{+}) = \\dfrac{V_{\\text{ref}} - V_{\\text{oc}}}{R_b}$, and allow $i_L$ to jump accordingly.\n**Analysis:** This is incorrect. While it mentions preserving $V_1$ continuity, it incorrectly proposes an artificial jump for the algebraic variable $I$, which must be continuous as it depends on continuous states. It also incorrectly suggests that the state variable $i_L$ is allowed to jump. This violates the principle of inductor flux/current continuity.\n**Verdict:** Incorrect.\n\nC. Enforce continuity of the energy-storage states by setting $V_1(t_s^{+}) = V_1(t_s^{-})$ and $i_L(t_s^{+}) = i_L(t_s^{-})$, recompute the algebraic battery current as $I(t_s^{+}) = \\dfrac{V_1(t_s^{+}) - V_{\\text{oc}}}{R_b}$, and update the duty ratio to $d(t_s^{+})$ according to the Constant-Voltage control law without altering the states. Then compute new derivatives from the governing equations.\n**Analysis:** This option accurately describes the physically consistent procedure. It correctly identifies that the state variables ($i_L$ and $V_1$) associated with energy storage must be continuous. It then correctly states that algebraic variables ($I$) and state derivatives must be recomputed based on the continuous states and the new input value $d(t_s^{+})$. This matches our derivation precisely. The calculations of derivatives based on this scheme are $\\dot{i}_L(t_s^{-}) = 100\\,\\text{A/s}$, $\\dot{V}_1(t_s^{-}) = 100\\,\\text{V/s}$, $\\dot{i}_L(t_s^{+}) = 6100\\,\\text{A/s}$, and $\\dot{V}_1(t_s^{+}) = 100\\,\\text{V/s}$.\n**Verdict:** Correct.\n\nD. Enforce continuity of $i_L$ only, but snap $V_1(t_s^{+})$ to $V_{\\text{ref}}$, and compute $I(t_s^{+})$ from $I(t_s^{+}) = \\dfrac{V_1(t_s^{+}) - V_{\\text{oc}}}{R_b}$.\n**Analysis:** This is physically incorrect. It correctly enforces continuity for $i_L$ but violates continuity for the other state variable, $V_1$, by forcing it to jump (\"snap\") to $V_{\\text{ref}}$. As established, this is physically impossible in this model.\n**Verdict:** Incorrect.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "A simulation can produce numbers, but how do we trust them? Validation against fundamental physical principles is a cornerstone of reliable scientific computing, ensuring that our models reflect reality. This culminating practice  applies the law of conservation of energy to a complete CC-CV charging simulation with dynamic inputs. By implementing the charging logic and simultaneously tracking input energy, stored chemical energy, and dissipated losses, you will learn to use energy balance as a powerful tool to verify your simulation's integrity.",
            "id": "3949106",
            "problem": "You are tasked with implementing and validating a numerical simulation of Constant Current–Constant Voltage (CC–CV) charging with dynamic duty cycles for a single-cell electrochemical battery. The validation must be based on an energy-conservation check, comparing the time-integrated electrical input energy with the sum of the chemically stored energy and ohmic losses. Your implementation must be self-contained and produce results for a specified test suite.\n\nAssume the following idealized but scientifically consistent model:\n\n- The terminal voltage $\\;V(t)\\;$ satisfies the decomposition\n$$\nV(t) \\;=\\; U(z(t)) \\;+\\; I(t)\\,R,\n$$\nwhere $\\;U(z)\\;$ is the open-circuit voltage (OCV) as a function of state-of-charge $\\;z\\in[0,1]\\;$, $\\;I(t)\\;$ is the applied charging current (positive for charging), and $\\;R0\\;$ is a lumped internal resistance.\n\n- The chemically stored energy increases according to\n$$\nE_{\\text{stored}} \\;=\\; \\int U(z)\\,\\mathrm{d}Q \\;=\\; \\int U\\big(z(t)\\big)\\,I(t)\\,\\mathrm{d}t,\n$$\nwhere $\\;Q(t)=\\int_0^t I(\\tau)\\,\\mathrm{d}\\tau\\;$ is charge (in Coulombs). The state-of-charge evolves by\n$$\nz(t) \\;=\\; z(0) \\;+\\; \\frac{Q(t)}{Q_{\\text{nom}}},\n$$\nwith nominal capacity $\\;Q_{\\text{nom}}0\\;$ (in Coulombs).\n\n- The ohmic loss due to internal resistance obeys\n$$\nE_{\\text{loss}} \\;=\\; \\int I^2(t)\\,R\\,\\mathrm{d}t.\n$$\n\n- The electrical input energy satisfies\n$$\nE_{\\text{input}} \\;=\\; \\int V(t)\\,I(t)\\,\\mathrm{d}t.\n$$\n\nUnder these assumptions and exact arithmetic, the identity\n$$\nE_{\\text{input}} \\;=\\; E_{\\text{stored}} \\;+\\; E_{\\text{loss}}\n$$\nshould hold. In any finite-precision numerical simulation, there will be a residual\n$$\n\\Delta E \\;=\\; E_{\\text{input}} \\;-\\; E_{\\text{stored}} \\;-\\; E_{\\text{loss}},\n$$\nand the relative residual\n$$\n\\delta \\;=\\; \\frac{\\lvert \\Delta E \\rvert}{\\max\\big(E_{\\text{input}},\\varepsilon\\big)},\n$$\nwith a small floor $\\;\\varepsilon  0\\;$ to avoid division by zero.\n\nCharging control protocol:\n\n- Constant Current (CC): apply a square-wave current with Pulse-Width Modulation (PWM) duty cycle $\\;d(t)\\in[0,1]\\;$ over a PWM period $\\;T_{\\text{pwm}}0\\;$. The instantaneous CC current is\n$$ I(t) \\;=\\; \\begin{cases} I_{\\text{CC}},  \\text{if } (t \\bmod T_{\\text{pwm}})  d(t)\\,T_{\\text{pwm}},\\\\[6pt] 0,  \\text{otherwise}. \\end{cases} $$\nfor a specified constant $\\;I_{\\text{CC}}0\\;$.\n\n- Transition to Constant Voltage (CV): enter CV mode when the instantaneous on-pulse voltage would reach or exceed the voltage limit $\\;V_{\\text{CV}}$, i.e.,\n$$\nU\\big(z(t)\\big) \\;+\\; I_{\\text{CC}}\\,R \\;\\ge\\; V_{\\text{CV}}.\n$$\n\n- Constant Voltage (CV): hold the terminal voltage at $\\;V_{\\text{CV}}\\;$ by choosing\n$$\nI(t) \\;=\\; \\min\\!\\Big(I_{\\text{CC}},\\;\\max\\!\\big(0,\\;\\frac{V_{\\text{CV}} - U\\big(z(t)\\big)}{R}\\big)\\Big).\n$$\nThis ensures nonnegative current, and current does not exceed $\\;I_{\\text{CC}}\\;$.\n\nOpen-circuit voltage model:\n\n- Use a quadratic OCV function\n$$\nU(z) \\;=\\; a_0 \\;+\\; a_1\\,z \\;+\\; a_2\\,z^2,\n$$\nwith coefficients chosen so that $\\;U(z)\\;$ lies in a physically plausible range for a Lithium-ion cell (approximately $\\;[3.0,4.2]\\;$ $\\mathrm{V}$) over $\\;z\\in[0,1]\\;$.\n\nNumerical method:\n\n- Use explicit time stepping with uniform step $\\;\\Delta t  0\\;$.\n- Update $\\;z\\;$ via $\\;z \\leftarrow z + \\dfrac{I\\,\\Delta t}{Q_{\\text{nom}}}\\;$ and clamp to $\\;[0,1]\\;$ if it exceeds $\\;1\\;$.\n- Accumulate the energies $\\;E_{\\text{input}}, E_{\\text{stored}}, E_{\\text{loss}}\\;$ using Riemann sums:\n$$\nE_{\\text{input}} \\leftarrow E_{\\text{input}} + V\\,I\\,\\Delta t,\\quad\nE_{\\text{stored}} \\leftarrow E_{\\text{stored}} + U(z)\\,I\\,\\Delta t,\\quad\nE_{\\text{loss}} \\leftarrow E_{\\text{loss}} + I^2\\,R\\,\\Delta t.\n$$\n\nTermination:\n\n- Stop when either $\\;t \\ge t_{\\max}\\;$ or $\\;z \\ge 1\\;$.\n\nValidation metric:\n\n- Compute $\\;\\Delta E\\;$ in $\\;\\mathrm{J}\\;$ and $\\;\\delta\\;$ as defined above.\n- Use tolerance $\\;\\tau = 10^{-9}\\;$; declare a pass if $\\;\\delta \\le \\tau\\;$.\n\nUnits:\n\n- Voltages in $\\;\\mathrm{V}\\;$, currents in $\\;\\mathrm{A}\\;$, resistance in $\\;\\Omega\\;$, time in $\\;\\mathrm{s}\\;$, charge in $\\;\\mathrm{C}\\;$, capacity in $\\;\\mathrm{Ah}\\;$ converted internally to Coulombs by multiplying by $\\;3600\\;$, and energy in $\\;\\mathrm{J}\\;$.\n\nTest suite:\n\nImplement the simulation for the following parameter sets. For each case, report the residual energy $\\;\\Delta E\\;$ in $\\;\\mathrm{J}\\;$ and the relative residual $\\;\\delta\\;$ as a decimal, along with the pass boolean $\\;(\\delta \\le \\tau)\\;$.\n\n- Case $1$ (happy path):\n    - $\\;Q_{\\text{nom}} = 3.0\\;$ $\\mathrm{Ah}$, $\\;R = 0.08\\;$ $\\Omega$, $\\;I_{\\text{CC}} = 2.0\\;$ $\\mathrm{A}$, $\\;V_{\\text{CV}} = 4.20\\;$ $\\mathrm{V}$,\n    - $\\;a_0 = 3.00\\;$, $\\;a_1 = 1.25\\;$, $\\;a_2 = -0.05\\;$,\n    - $\\;z(0) = 0.20\\;$, $\\;\\Delta t = 0.05\\;$ $\\mathrm{s}$, $\\;t_{\\max} = 5400\\;$ $\\mathrm{s}$,\n    - PWM: $\\;T_{\\text{pwm}} = 2.0\\;$ $\\mathrm{s}$, duty schedule ramp $\\;d(t) = \\min\\!\\big(0.3 + 0.6\\,t/T_{\\text{ramp}},\\,0.9\\big)\\;$ with $\\;T_{\\text{ramp}} = 1800\\;$ $\\mathrm{s}$.\n\n- Case $2$ (early CV due to high resistance and high initial $\\;z$):\n    - $\\;Q_{\\text{nom}} = 2.0\\;$ $\\mathrm{Ah}$, $\\;R = 0.20\\;$ $\\Omega$, $\\;I_{\\text{CC}} = 3.0\\;$ $\\mathrm{A}$, $\\;V_{\\text{CV}} = 4.10\\;$ $\\mathrm{V}$,\n    - $\\;a_0 = 3.20\\;$, $\\;a_1 = 1.00\\;$, $\\;a_2 = -0.05\\;$,\n    - $\\;z(0) = 0.85\\;$, $\\;\\Delta t = 0.02\\;$ $\\mathrm{s}$, $\\;t_{\\max} = 3600\\;$ $\\mathrm{s}$,\n    - PWM: $\\;T_{\\text{pwm}} = 1.0\\;$ $\\mathrm{s}$, duty schedule ramp $\\;d(t) = \\min\\!\\big(0.4 + 0.4\\,t/T_{\\text{ramp}},\\,0.8\\big)\\;$ with $\\;T_{\\text{ramp}} = 600\\;$ $\\mathrm{s}$.\n\n- Case $3$ (low current with sinusoidal duty modulation):\n    - $\\;Q_{\\text{nom}} = 5.0\\;$ $\\mathrm{Ah}$, $\\;R = 0.03\\;$ $\\Omega$, $\\;I_{\\text{CC}} = 0.5\\;$ $\\mathrm{A}$, $\\;V_{\\text{CV}} = 4.15\\;$ $\\mathrm{V}$,\n    - $\\;a_0 = 3.00\\;$, $\\;a_1 = 1.35\\;$, $\\;a_2 = -0.20\\;$,\n    - $\\;z(0) = 0.10\\;$, $\\;\\Delta t = 0.05\\;$ $\\mathrm{s}$, $\\;t_{\\max} = 7200\\;$ $\\mathrm{s}$,\n    - PWM: $\\;T_{\\text{pwm}} = 0.5\\;$ $\\mathrm{s}$, duty schedule $\\;d(t) = \\mathrm{clip}\\!\\big(0.5 + 0.4\\sin(2\\pi t/T_{\\text{mod}}),\\,0,\\,1\\big)\\;$ with $\\;T_{\\text{mod}} = 2000\\;$ $\\mathrm{s}$.\n\nRequired final output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list of inner lists, each inner list formatted as $\\;[\\Delta E,\\delta,\\text{pass}]\\;$, enclosed in square brackets. For example:\n$$\n\\big[\\,[\\Delta E_1,\\delta_1,\\text{True}],\\,[\\Delta E_2,\\delta_2,\\text{False}],\\,\\ldots\\,\\big].\n$$\nAll energies must be in $\\;\\mathrm{J}\\;$ and all relative residuals as decimals (no percentage sign).",
            "solution": "The objective is to validate energy conservation in a numerical simulation of Constant Current–Constant Voltage (CC–CV) charging with dynamic duty cycles using first principles of circuit decomposition and charge accounting.\n\nFoundational relations:\n\n1. Electrical power is $\\;P(t) = V(t)\\,I(t)\\;$ and energy is the time integral:\n$$\nE_{\\text{input}} \\;=\\; \\int_0^{T} V(t)\\,I(t)\\,\\mathrm{d}t.\n$$\n\n2. For a simple lumped model with internal resistance $\\;R\\;$ and open-circuit voltage $\\;U(z)\\;$, the terminal voltage decomposes as\n$$\nV(t) \\;=\\; U\\big(z(t)\\big) \\;+\\; I(t)\\,R.\n$$\n\n3. The chemically stored energy increases according to the work done against the electrochemical potential:\n$$\nE_{\\text{stored}} \\;=\\; \\int U(z)\\,\\mathrm{d}Q \\;=\\; \\int U\\big(z(t)\\big)\\,I(t)\\,\\mathrm{d}t.\n$$\n\n4. The dissipative ohmic loss is\n$$\nE_{\\text{loss}} \\;=\\; \\int I^2(t)\\,R\\,\\mathrm{d}t.\n$$\n\nCombining these, and substituting $\\;V(t) = U(z(t)) + I(t)R\\;$ into $\\;E_{\\text{input}}\\;$ yields\n$$\nE_{\\text{input}} \\;=\\; \\int \\big(U(z(t)) + I(t)R\\big)\\,I(t)\\,\\mathrm{d}t\n\\;=\\; \\int U(z(t))\\,I(t)\\,\\mathrm{d}t \\;+\\; \\int I^2(t)\\,R\\,\\mathrm{d}t\n\\;=\\; E_{\\text{stored}} \\;+\\; E_{\\text{loss}}.\n$$\nThus, in exact arithmetic, the residual\n$$\n\\Delta E \\;=\\; E_{\\text{input}} - E_{\\text{stored}} - E_{\\text{loss}}\n$$\nis identically $\\;0\\;$.\n\nIn a numerical simulation, we use discrete time stepping with step $\\;\\Delta t\\;$ and compute Riemann sums:\n$$\nE_{\\text{input}} \\approx \\sum_{n} V_n\\,I_n\\,\\Delta t,\\quad\nE_{\\text{stored}} \\approx \\sum_{n} U(z_n)\\,I_n\\,\\Delta t,\\quad\nE_{\\text{loss}} \\approx \\sum_{n} I_n^2\\,R\\,\\Delta t.\n$$\nWe update state-of-charge via\n$$\nz_{n+1} \\;=\\; z_n \\;+\\; \\frac{I_n\\,\\Delta t}{Q_{\\text{nom}}},\n$$\nwith $\\;Q_{\\text{nom}}\\;$ in Coulombs. The identity still holds stepwise when $\\;V_n = U(z_n) + I_n R\\;$, but finite precision and discrete approximations introduce small discrepancies. The relative residual is defined as\n$$\n\\delta \\;=\\; \\frac{\\lvert \\Delta E \\rvert}{\\max\\!\\big(E_{\\text{input}},\\varepsilon\\big)},\n$$\nfor a small $\\;\\varepsilon\\;$ to prevent division by zero. We choose a stringent tolerance $\\;\\tau = 10^{-9}\\;$ for validation, appropriate for double precision and well-conditioned sums over the stated time horizons.\n\nCharging control algorithm:\n\n- In Constant Current (CC), we impose PWM with duty $\\;d(t)\\;$ and period $\\;T_{\\text{pwm}}\\;$. The instantaneous current is\n$$\nI_n \\;=\\; \\begin{cases}\nI_{\\text{CC}},  \\text{if } (t_n \\bmod T_{\\text{pwm}})  d(t_n)\\,T_{\\text{pwm}},\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\nThe CC-to-CV transition is triggered when the on-pulse terminal voltage would reach or exceed the voltage limit:\n$$\nU(z_n) \\;+\\; I_{\\text{CC}}\\,R \\;\\ge\\; V_{\\text{CV}}.\n$$\n\n- In Constant Voltage (CV), we compute the current to hold $\\;V_{\\text{CV}}\\;$:\n$$\nI_n \\;=\\; \\min\\!\\Big(I_{\\text{CC}},\\;\\max\\!\\big(0,\\;\\frac{V_{\\text{CV}} - U(z_n)}{R}\\big)\\Big),\n$$\nwhich enforces nonnegativity and a ceiling at $\\;I_{\\text{CC}}\\;$.\n\nAt each step we compute $\\;U(z_n)\\;$ from the quadratic model\n$$\nU(z) \\;=\\; a_0 \\;+\\; a_1\\,z \\;+\\; a_2\\,z^2,\n$$\nand set\n$$\nV_n \\;=\\; U(z_n) \\;+\\; I_n\\,R,\n$$\nso that CV implies $\\;V_n = V_{\\text{CV}}\\;$ when the current is determined by the CV rule. Energies are accumulated by summation. The simulation halts when either $\\;t \\ge t_{\\max}\\;$ or $\\;z \\ge 1\\;$.\n\nNumerical considerations and residual acceptability:\n\n- With consistent use of $\\;V_n = U(z_n) + I_n R\\;$, the discrete identities match algebraically, and residuals primarily reflect floating-point roundoff error and accumulated summation error.\n- Over thousands to hundreds of thousands of steps, the absolute residual may be nonzero but the relative residual $\\;\\delta\\;$ should remain near machine precision for well-scaled quantities. A tolerance $\\;\\tau = 10^{-9}\\;$ is appropriate for validation in advanced graduate-level simulations under the specified conditions.\n\nImplementation details for the test suite:\n\n- Each case specifies $\\;Q_{\\text{nom}}\\;$ in $\\;\\mathrm{Ah}\\;$; convert to Coulombs by multiplying by $\\;3600\\;$.\n- Duty schedules:\n  - Ramp: $\\;d(t) = \\min\\!\\big(d_0 + (d_1 - d_0)\\,t/T_{\\text{ramp}},\\,d_1\\big)\\;$.\n  - Sinusoidal: $\\;d(t) = \\mathrm{clip}\\!\\big(d_0 + A\\sin(2\\pi t/T_{\\text{mod}}),\\,0,\\,1\\big)\\;$.\n\nOutput specification:\n\n- For each case, return the triple $\\;[\\Delta E,\\delta,\\text{pass}]\\;$ where $\\;\\Delta E\\;$ is in $\\;\\mathrm{J}\\;$, $\\;\\delta\\;$ is a decimal, and $\\;\\text{pass}\\;$ is a boolean indicating whether $\\;\\delta \\le \\tau\\;$.\n- Print a single line containing the list of triples for all cases, as a comma-separated list enclosed in square brackets, e.g.,\n$$\n\\big[\\,[\\Delta E_1,\\delta_1,\\text{True}],\\,[\\Delta E_2,\\delta_2,\\text{True}],\\,[\\Delta E_3,\\delta_3,\\text{True}]\\,\\big].\n$$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef make_duty_function(kind: str, params: dict):\n    \"\"\"\n    Returns a callable d(t) in [0,1] for the specified schedule.\n    kind: 'ramp' or 'sin'\n    params: dictionary with keys depending on kind.\n    \"\"\"\n    if kind == 'ramp':\n        d0 = float(params.get('d0', 0.0))\n        d1 = float(params.get('d1', 1.0))\n        T_ramp = float(params.get('T_ramp', 1.0))\n        def d(t):\n            val = d0 + (d1 - d0) * (t / T_ramp)\n            if val  d1:\n                val = d1\n            if val  0.0:\n                val = 0.0\n            if val  1.0:\n                val = 1.0\n            return val\n        return d\n    elif kind == 'sin':\n        d0 = float(params.get('d0', 0.5))\n        A = float(params.get('A', 0.0))\n        T_mod = float(params.get('T_mod', 1.0))\n        two_pi_over_T = 2.0 * np.pi / T_mod\n        def d(t):\n            val = d0 + A * np.sin(two_pi_over_T * t)\n            # clip to [0,1]\n            if val  0.0:\n                val = 0.0\n            if val  1.0:\n                val = 1.0\n            return val\n        return d\n    else:\n        # default: constant 1.0\n        return lambda t: 1.0\n\ndef simulate_case(case):\n    \"\"\"\n    Simulate CC-CV charging with dynamic duty cycles for a single case.\n    Returns (DeltaE, rel_residual, pass_bool).\n    \"\"\"\n    # Unpack parameters\n    Q_nom_Ah = case['Q_nom_Ah']\n    R = case['R_ohm']\n    I_cc = case['I_cc_A']\n    V_cv = case['V_cv_V']\n    a0, a1, a2 = case['ocv_coeffs']  # quadratic coefficients\n    z0 = case['z0']\n    dt = case['dt_s']\n    t_max = case['t_max_s']\n    T_pwm = case['T_pwm_s']\n    duty_kind = case['duty']['kind']\n    duty_params = case['duty']['params']\n    duty_func = make_duty_function(duty_kind, duty_params)\n\n    # Capacity conversion: Ah to Coulombs\n    Q_nom = Q_nom_Ah * 3600.0\n\n    # Initialize state\n    t = 0.0\n    z = float(z0)\n    in_cv = False\n\n    # Energy accumulators\n    E_input = 0.0\n    E_stored = 0.0\n    E_loss = 0.0\n\n    # Small floor for relative residual\n    eps = 1e-12\n    tau = 1e-9  # validation tolerance\n\n    # Simulation loop\n    # To avoid extremely long runtimes, cap the number of steps by t_max/dt\n    max_steps = int(np.ceil(t_max / dt))\n    for _ in range(max_steps):\n        # Compute OCV at current SOC\n        U = a0 + a1 * z + a2 * z * z\n\n        # Determine current based on mode\n        if not in_cv:\n            # CC PWM current\n            duty = duty_func(t)\n            # Determine if current is ON within PWM cycle\n            on = (t % T_pwm)  (duty * T_pwm)\n            I = I_cc if on else 0.0\n\n            # Check transition condition to CV:\n            # If the on-pulse terminal voltage would exceed V_cv, enter CV.\n            if U + I_cc * R = V_cv:\n                in_cv = True\n                # Compute CV current immediately for this step\n                I = (V_cv - U) / R\n                # Enforce limits: nonnegative and bounded by I_cc\n                if I  0.0:\n                    I = 0.0\n                if I  I_cc:\n                    I = I_cc\n        else:\n            # CV mode\n            I = (V_cv - U) / R\n            if I  0.0:\n                I = 0.0\n            if I  I_cc:\n                I = I_cc\n\n        # Terminal voltage from decomposition\n        V = U + I * R\n\n        # Accumulate energies\n        dE_input = V * I * dt\n        dE_stored = U * I * dt\n        dE_loss = (I * I) * R * dt\n\n        E_input += dE_input\n        E_stored += dE_stored\n        E_loss += dE_loss\n\n        # Update SOC\n        z += (I * dt) / Q_nom\n        if z  1.0:\n            z = 1.0\n\n        # Advance time\n        t += dt\n\n        # Termination conditions\n        if t = t_max or z = 1.0:\n            break\n\n    # Compute residuals\n    DeltaE = E_input - E_stored - E_loss\n    rel = abs(DeltaE) / (E_input if E_input  eps else eps)\n    passed = rel = tau\n\n    return DeltaE, rel, passed\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"Q_nom_Ah\": 3.0,\n            \"R_ohm\": 0.08,\n            \"I_cc_A\": 2.0,\n            \"V_cv_V\": 4.20,\n            \"ocv_coeffs\": (3.00, 1.25, -0.05),\n            \"z0\": 0.20,\n            \"dt_s\": 0.05,\n            \"t_max_s\": 5400.0,\n            \"T_pwm_s\": 2.0,\n            \"duty\": {\"kind\": \"ramp\", \"params\": {\"d0\": 0.3, \"d1\": 0.9, \"T_ramp\": 1800.0}},\n        },\n        {\n            \"Q_nom_Ah\": 2.0,\n            \"R_ohm\": 0.20,\n            \"I_cc_A\": 3.0,\n            \"V_cv_V\": 4.10,\n            \"ocv_coeffs\": (3.20, 1.00, -0.05),\n            \"z0\": 0.85,\n            \"dt_s\": 0.02,\n            \"t_max_s\": 3600.0,\n            \"T_pwm_s\": 1.0,\n            \"duty\": {\"kind\": \"ramp\", \"params\": {\"d0\": 0.4, \"d1\": 0.8, \"T_ramp\": 600.0}},\n        },\n        {\n            \"Q_nom_Ah\": 5.0,\n            \"R_ohm\": 0.03,\n            \"I_cc_A\": 0.5,\n            \"V_cv_V\": 4.15,\n            \"ocv_coeffs\": (3.00, 1.35, -0.20),\n            \"z0\": 0.10,\n            \"dt_s\": 0.05,\n            \"t_max_s\": 7200.0,\n            \"T_pwm_s\": 0.5,\n            \"duty\": {\"kind\": \"sin\", \"params\": {\"d0\": 0.5, \"A\": 0.4, \"T_mod\": 2000.0}},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        DeltaE, rel, passed = simulate_case(case)\n        # Format per required output: [DeltaE,delta,pass]\n        results.append((DeltaE, rel, passed))\n\n    # Final print statement in the exact required format: a single line\n    # containing the list of inner lists [DeltaE,delta,pass] for each case.\n    # Ensure no extra spaces for strictness.\n    inner = []\n    for (de, r, p) in results:\n        # Use repr for booleans and floats to keep consistency\n        inner.append(f\"[{de},{r},{p}]\")\n    print(f\"[{','.join(inner)}]\")\n\nsolve()\n```"
        }
    ]
}