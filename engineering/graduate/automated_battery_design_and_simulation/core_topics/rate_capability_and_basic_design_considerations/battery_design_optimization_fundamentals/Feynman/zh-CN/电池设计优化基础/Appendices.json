{
    "hands_on_practices": [
        {
            "introduction": "要实现电池设计的优化，我们首先需要一个能够将设计参数与性能指标联系起来的模型。本实践将指导您从零开始构建一个基础模型，将电极的微观结构特性（如颗粒大小和孔隙率）与宏观的倍率性能直接关联起来。通过亲手实现这个模型，您将深刻理解那些决定电池充放电速率的物理权衡关系。",
            "id": "3895234",
            "problem": "考虑一个用于锂离子电池的多孔电极，其微观结构通过扫描电子显微镜（SEM）表征，得到离散的粒径分布（PSD），其在液相电解质中的输运由曲折度关联式描述。从以下基本原理出发：(i) 电解质中的欧姆定律，(ii) 应用于有效输运性质的多孔介质中曲折度的定义，(iii) 堆积球体的比表面积的几何关系，以及 (iv) 用于界面电荷转移的 Butler–Volmer 动力学，推导并实现一个程序，用于计算有效离子电导率和比表面积，并预测在电解质欧姆降和界面动力学过电势的独立允许预算下，电极是否能够承受标称两倍容量倍率（2C倍率）的恒流放电。\n\n使用以下基本原理和定义作为推导的起点：\n- 电解质中的欧姆定律：在一维情况下，离子电流密度 $i_{e}$ 通过 $i_{e} = - \\kappa \\, \\frac{d \\phi_{e}}{d x}$ 与电解质电势 $\\phi_{e}$ 相关，其中 $\\kappa$ 是电解质的本征离子电导率，单位为 $\\mathrm{S/m}$，$x$ 是穿过厚度方向的坐标，单位为 $\\mathrm{m}$。在多孔介质中，由于可供电解质通过的横截面积减小和路径长度增加，有效输运会降低。\n- 多孔介质输运标度关系：有效离子电导率 $\\kappa_{\\text{eff}}$ 由地层因子定义，使得 $\\kappa_{\\text{eff}} = \\kappa \\, \\frac{\\varepsilon}{\\tau}$，其中 $\\varepsilon$ 是电解质的体积分数（孔隙率，无量纲），$\\tau$ 是曲折度因子（无量纲）。\n- 曲折度关联式：曲折度因子通过 $\\tau = \\varepsilon^{-\\beta}$ 与孔隙率相关，其中 $\\beta$ 是一个正指数（无量纲）。\n- 堆积球体的比表面积：对于具有基于数量的 PSD 的球形颗粒，单位体积的表面积，即比表面积 $a_{s}$（单位为 $\\mathrm{m^{-1}}$），由 $a_{s} = \\frac{6 \\, \\varepsilon_{s}}{d_{32}}$ 给出，其中 $\\varepsilon_{s}$ 是固相体积分数（无量纲），$d_{32}$ 是 Sauter 平均粒径，其定义为 $d_{32} = \\frac{\\sum_{i} w_{i} d_{i}^{3}}{\\sum_{i} w_{i} d_{i}^{2}}$，其中 $w_{i}$ 是数量分数，$d_{i}$ 是直径（单位为 $\\mathrm{m}$）。\n- 界面电荷转移动力学（Butler–Volmer，对称情况）：单位活性表面积的界面电流密度 $j$（单位为 $\\mathrm{A/m^{2}}$）通过 $j = 2 i_{0} \\, \\sinh\\!\\left(\\frac{F \\eta}{2 R T}\\right)$ 与界面过电势 $\\eta$ 相关，其中 $i_{0}$ 是单位活性表面积的交换电流密度（单位为 $\\mathrm{A/m^{2}}$），$F$ 是法拉第常数（单位为 $\\mathrm{C/mol}$），$R$ 是普适气体常数（单位为 $\\mathrm{J/(mol \\cdot K)}$），$T$ 是绝对温度（单位为 $\\mathrm{K}$）。几何电流密度 $i$（单位为 $\\mathrm{A/m^{2}}$）通过 $i = a_{s} \\, j$ 与 $j$ 相关。\n\n由此，推导：\n- 有效离子电导率 $\\kappa_{\\text{eff}}$（单位为 $\\mathrm{S/m}$），由 $\\kappa_{\\text{eff}} = \\kappa \\, \\frac{\\varepsilon}{\\tau} = \\kappa \\, \\varepsilon^{1+\\beta}$ 得出。\n- 比表面积 $a_{s}$（单位为 $\\mathrm{m^{-1}}$），由 PSD 的 Sauter 平均粒径通过 $a_{s} = \\frac{6 \\varepsilon_{s}}{d_{32}}$ 及 $d_{32} = \\frac{\\sum_{i} w_{i} d_{i}^{3}}{\\sum_{i} w_{i} d_{i}^{2}}$ 得出。\n- 在电极厚度 $L$（单位为 $\\mathrm{m}$）上，可由电解质欧姆预算 $\\Delta \\phi_{e,\\max}$（单位为 $\\mathrm{V}$）和动力学过电势预算 $\\Delta \\phi_{k,\\max}$（单位为 $\\mathrm{V}$）独立支持的最大几何电流密度：\n  - 电解质限制电流：$$i_{\\max}^{(\\text{elec})} = \\frac{\\kappa_{\\text{eff}} \\, \\Delta \\phi_{e,\\max}}{L}.$$\n  - 动力学限制电流：$$i_{\\max}^{(\\text{kin})} = a_{s} \\cdot \\left[ 2 i_{0} \\, \\sinh\\!\\left(\\frac{F \\, \\Delta \\phi_{k,\\max}}{2 R T}\\right) \\right].$$\n- 从面容量 $Q_{A}$（单位为 $\\mathrm{C/m^{2}}$）计算得出的施加的 2C 几何电流密度 $i_{2\\mathrm{C}}$（单位为 $\\mathrm{A/m^{2}}$），即 $i_{2\\mathrm{C}} = \\frac{Q_{A}}{1800}$，因为 2C 放电名义上在 $1800$ 秒内完成。\n- 预测的 2C 倍率裕度 $\\mathcal{R}$，定义为最限制的可持续电流与施加的 2C 电流之比：$$\\mathcal{R} = \\frac{\\min\\!\\left( i_{\\max}^{(\\text{elec})}, \\, i_{\\max}^{(\\text{kin})} \\right)}{i_{2\\mathrm{C}}}.$$\n- 一个指示电极是否能承受 2C 倍率的可行性布尔标志，定义为 $\\mathrm{viable} = (\\mathcal{R} \\geq 1)$。\n\n实现一个程序，针对下面套件中的每个测试用例，计算 $\\kappa_{\\text{eff}}$（单位为 $\\mathrm{S/m}$）、$a_{s}$（单位为 $\\mathrm{m^{-1}}$）和 2C 倍率裕度 $\\mathcal{R}$（无量纲），并同时返回可行性布尔值。所有计算必须在温度 $T = 298 \\, \\mathrm{K}$，法拉第常数 $F = 96485 \\, \\mathrm{C/mol}$ 和普适气体常数 $R = 8.314 \\, \\mathrm{J/(mol \\cdot K)}$ 的条件下进行。使用独立的允许预算 $\\Delta \\phi_{e,\\max} = 0.1 \\, \\mathrm{V}$ 和 $\\Delta \\phi_{k,\\max} = 0.1 \\, \\mathrm{V}$。将 $\\kappa_{\\text{eff}}$（单位为 $\\mathrm{S/m}$）、$a_{s}$（单位为 $\\mathrm{m^{-1}}$）和 $\\mathcal{R}$ 表示为十进制浮点数。可行性必须是布尔值。\n\n测试套件（每个用例是一个参数元组）：\n- 用例 $1$（代表性微观结构）：\n  - 直径 $d_{i}$（单位 $\\mathrm{m}$）：$[6 \\times 10^{-6}, \\, 8 \\times 10^{-6}, \\, 10 \\times 10^{-6}, \\, 12 \\times 10^{-6}]$。\n  - 数量分数 $w_{i}$：$[0.2, \\, 0.3, \\, 0.3, \\, 0.2]$。\n  - 孔隙率 $\\varepsilon = 0.35$。\n  - 曲折度指数 $\\beta = 1.5$。\n  - 电解质本征电导率 $\\kappa = 1.2 \\, \\mathrm{S/m}$。\n  - 电极厚度 $L = 70 \\times 10^{-6} \\, \\mathrm{m}$。\n  - 固相体积分数 $\\varepsilon_{s} = 0.55$。\n  - 交换电流密度 $i_{0} = 3.5 \\, \\mathrm{A/m^{2}}$。\n  - 面容量 $Q_{A} = 144000 \\, \\mathrm{C/m^{2}}$。\n- 用例 $2$（低孔隙率，较厚电极）：\n  - 直径 $d_{i}$（单位 $\\mathrm{m}$）：$[8 \\times 10^{-6}, \\, 12 \\times 10^{-6}, \\, 16 \\times 10^{-6}, \\, 20 \\times 10^{-6}]$。\n  - 数量分数 $w_{i}$：$[0.1, \\, 0.4, \\, 0.3, \\, 0.2]$。\n  - 孔隙率 $\\varepsilon = 0.15$。\n  - 曲折度指数 $\\beta = 2.0$。\n  - 电解质本征电导率 $\\kappa = 0.8 \\, \\mathrm{S/m}$。\n  - 电极厚度 $L = 100 \\times 10^{-6} \\, \\mathrm{m}$。\n  - 固相体积分数 $\\varepsilon_{s} = 0.75$。\n  - 交换电流密度 $i_{0} = 3.0 \\, \\mathrm{A/m^{2}}$。\n  - 面容量 $Q_{A} = 250000 \\, \\mathrm{C/m^{2}}$。\n- 用例 $3$（细颗粒，高孔隙率）：\n  - 直径 $d_{i}$（单位 $\\mathrm{m}$）：$[1.2 \\times 10^{-6}, \\, 1.5 \\times 10^{-6}, \\, 2.0 \\times 10^{-6}]$。\n  - 数量分数 $w_{i}$：$[0.4, \\, 0.4, \\, 0.2]$。\n  - 孔隙率 $\\varepsilon = 0.60$。\n  - 曲折度指数 $\\beta = 1.5$。\n  - 电解质本征电导率 $\\kappa = 1.0 \\, \\mathrm{S/m}$。\n  - 电极厚度 $L = 50 \\times 10^{-6} \\, \\mathrm{m}$。\n  - 固相体积分数 $\\varepsilon_{s} = 0.40$。\n  - 交换电流密度 $i_{0} = 2.0 \\, \\mathrm{A/m^{2}}$。\n  - 面容量 $Q_{A} = 80000 \\, \\mathrm{C/m^{2}}$。\n- 用例 $4$（粗颗粒，中等孔隙率，慢动力学）：\n  - 直径 $d_{i}$（单位 $\\mathrm{m}$）：$[25 \\times 10^{-6}, \\, 30 \\times 10^{-6}, \\, 35 \\times 10^{-6}]$。\n  - 数量分数 $w_{i}$：$[0.3, \\, 0.5, \\, 0.2]$。\n  - 孔隙率 $\\varepsilon = 0.40$。\n  - 曲折度指数 $\\beta = 1.5$。\n  - 电解质本征电导率 $\\kappa = 1.4 \\, \\mathrm{S/m}$。\n  - 电极厚度 $L = 75 \\times 10^{-6} \\, \\mathrm{m}$。\n  - 固相体积分数 $\\varepsilon_{s} = 0.50$。\n  - 交换电流密度 $i_{0} = 1 \\times 10^{-4} \\, \\mathrm{A/m^{2}}$。\n  - 面容量 $Q_{A} = 120000 \\, \\mathrm{C/m^{2}}$。\n\n你的程序应该生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果是一个形如 $[\\kappa_{\\text{eff}}, a_{s}, \\mathcal{R}, \\mathrm{viable}]$ 的列表。单位分别为：$\\kappa_{\\text{eff}}$ 为 $\\mathrm{S/m}$，$a_{s}$ 为 $\\mathrm{m^{-1}}$，$\\mathcal{R}$ 无量纲；可行性是一个布尔值。不应打印任何其他文本。",
            "solution": "我们从基本定律和定义开始。电解质相中离子传导的欧姆定律给出 $i_{e} = - \\kappa \\, \\frac{d \\phi_{e}}{d x}$，其中电解质的本征电导率为 $\\kappa$，单位为 $\\mathrm{S/m}$。在多孔介质中，有效输运会降低，因为只有一部分横截面（分数 $\\varepsilon$）可供电解质通过，并且由于微观结构的复杂性，路径被拉长，这由曲折度因子 $\\tau$ 描述。标准的地层因子标度关系得出有效离子电导率 $\\kappa_{\\text{eff}} = \\kappa \\, \\frac{\\varepsilon}{\\tau}$。一个广泛使用的关于曲折度与孔隙率关系的关联式是 $\\tau = \\varepsilon^{-\\beta}$，其中 $\\beta$ 是一个正指数（通常与 Bruggeman 型指数有关）。结合这些可得\n$$\n\\kappa_{\\text{eff}} = \\kappa \\, \\frac{\\varepsilon}{\\varepsilon^{-\\beta}} = \\kappa \\, \\varepsilon^{1+\\beta}.\n$$\n这表示在多孔电解质中，有效离子电导率是孔隙率和曲折度指数的函数。\n\n接下来，对于堆积球形颗粒的比表面积，我们将单位电极体积的表面积与粒径分布关联起来。对于一个基于数量的分布，其直径为 $\\{d_{i}\\}$，权重为 $\\{w_{i}\\}$ 且 $\\sum_{i} w_{i} = 1$，Sauter 平均粒径 $d_{32}$ 定义为\n$$\nd_{32} = \\frac{\\sum_{i} w_{i} d_{i}^{3}}{\\sum_{i} w_{i} d_{i}^{2}}.\n$$\n对于球形颗粒，单位电极体积的表面积（即比表面积）为\n$$\na_{s} = \\frac{6 \\, \\varepsilon_{s}}{d_{32}},\n$$\n其中 $\\varepsilon_{s}$ 是固相体积分数。这源于单个球体的恒等式：对于直径为 $d$ 的球体，其表面积 $A = \\pi d^{2}$，体积 $V = \\frac{\\pi d^{3}}{6}$，因此 $A/V = 6/d$。此关系可通过使用基于数量的 PSD 来定义适当的平均直径，从而线性推广到颗粒体系。\n\n对于界面动力学，我们使用对称因子为 $\\frac{1}{2}$ 的 Butler–Volmer 方程，得到单位活性表面积的界面电流密度\n$$\nj = 2 i_{0} \\, \\sinh\\!\\left(\\frac{F \\eta}{2 R T} \\right),\n$$\n其中 $i_{0}$ 是单位表面积的交换电流密度。几何电流密度（单位电极几何面积）为 $i = a_{s} \\, j$，它通过有效表面积将总电流与界面通量关联起来。\n\n我们分别为电解质欧姆降和动力学过电势设置独立的允许预算，即 $\\Delta \\phi_{e,\\max}$ 和 $\\Delta \\phi_{k,\\max}$。对于穿过厚度为 $L$ 的电极的一维输运，从欧姆定律在整个厚度上积分，可得到电解质限制的最大几何电流密度，\n$$\ni_{\\max}^{(\\text{elec})} = \\frac{\\kappa_{\\text{eff}} \\, \\Delta \\phi_{e,\\max}}{L}.\n$$\n对于动力学限制的最大几何电流密度，我们使用在过电势预算 $\\Delta \\phi_{k,\\max}$ 下的 Butler–Volmer 表达式，\n$$\ni_{\\max}^{(\\text{kin})} = a_{s} \\cdot \\left[ 2 i_{0} \\, \\sinh\\!\\left(\\frac{F \\, \\Delta \\phi_{k,\\max}}{2 R T} \\right) \\right].\n$$\n然后，我们将这些独立的极限与所需的 2C 电流进行比较。2C 放电在 $1800$ 秒内完成，因此与面容量 $Q_{A}$（单位为 $\\mathrm{C/m^{2}}$）相关的几何电流密度为\n$$\ni_{2\\mathrm{C}} = \\frac{Q_{A}}{1800}.\n$$\n我们定义倍率裕度，\n$$\n\\mathcal{R} = \\frac{\\min\\!\\left( i_{\\max}^{(\\text{elec})}, \\, i_{\\max}^{(\\text{kin})} \\right)}{i_{2\\mathrm{C}}}.\n$$\n如果 $\\mathcal{R} \\geq 1$，电极可以承受 2C 倍率；否则不能。这得出一个布尔值的可行性：$\\mathrm{viable} = (\\mathcal{R} \\geq 1)$。\n\n算法上，每个测试用例的计算过程如下：\n1. 根据给定的直径 $\\{d_{i}\\}$ 和权重 $\\{w_{i}\\}$，通过 $d_{32} = \\frac{\\sum_{i} w_{i} d_{i}^{3}}{\\sum_{i} w_{i} d_{i}^{2}}$ 计算 $d_{32}$。\n2. 计算 $a_{s} = \\frac{6 \\varepsilon_{s}}{d_{32}}$。\n3. 计算 $\\kappa_{\\text{eff}} = \\kappa \\, \\varepsilon^{1+\\beta}$。\n4. 计算 $i_{\\max}^{(\\text{elec})} = \\frac{\\kappa_{\\text{eff}} \\, \\Delta \\phi_{e,\\max}}{L}$。\n5. 计算 $i_{\\max}^{(\\text{kin})} = a_{s} \\cdot \\left[ 2 i_{0} \\, \\sinh\\!\\left(\\frac{F \\, \\Delta \\phi_{k,\\max}}{2 R T} \\right) \\right]$。\n6. 计算 $i_{2\\mathrm{C}} = \\frac{Q_{A}}{1800}$。\n7. 计算 $\\mathcal{R} = \\frac{\\min\\!\\left( i_{\\max}^{(\\text{elec})}, \\, i_{\\max}^{(\\text{kin})} \\right)}{i_{2\\mathrm{C}}}$ 和 $\\mathrm{viable} = (\\mathcal{R} \\geq 1)$。\n\n使用的数值常数为 $F = 96485 \\, \\mathrm{C/mol}$，$R = 8.314 \\, \\mathrm{J/(mol \\cdot K)}$ 和 $T = 298 \\, \\mathrm{K}$。预算为 $\\Delta \\phi_{e,\\max} = 0.1 \\, \\mathrm{V}$ 和 $\\Delta \\phi_{k,\\max} = 0.1 \\, \\mathrm{V}$，并且单位必须一致：直径单位为 $\\mathrm{m}$，厚度单位为 $\\mathrm{m}$，电导率单位为 $\\mathrm{S/m}$，面容量单位为 $\\mathrm{C/m^{2}}$，电流密度单位为 $\\mathrm{A/m^{2}}$。输出为 $\\kappa_{\\text{eff}}$（单位 $\\mathrm{S/m}$），$a_{s}$（单位 $\\mathrm{m^{-1}}$）和无量纲的 $\\mathcal{R}$，以及布尔值的可行性。\n\n将此程序应用于提供的测试套件，将为每个用例生成一个列表 $[\\kappa_{\\text{eff}}, a_{s}, \\mathcal{R}, \\mathrm{viable}]$，并且程序将这些列表汇总为单个输出行，格式为方括号括起来的逗号分隔列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_sauter_mean_diameter(diams, weights):\n    \"\"\"\n    Compute Sauter mean diameter d32 for a number-based PSD.\n    diams: array of diameters [m]\n    weights: array of number fractions (sum to 1)\n    \"\"\"\n    diams = np.array(diams, dtype=float)\n    weights = np.array(weights, dtype=float)\n    # Ensure weights sum to 1 (tolerant normalization)\n    if not np.isclose(weights.sum(), 1.0):\n        weights = weights / weights.sum()\n    num = np.sum(weights * diams**3)\n    den = np.sum(weights * diams**2)\n    return num / den\n\ndef rate_capability_case(psd_diams, psd_weights, eps, beta, kappa, L, eps_s, i0, Q_A,\n                         delta_phi_e_max=0.1, delta_phi_k_max=0.1, T=298.0):\n    \"\"\"\n    Compute kappa_eff [S/m], a_s [1/m], rate margin R, and viability boolean for one case.\n    \"\"\"\n    F = 96485.0  # C/mol\n    Rgas = 8.314  # J/(mol*K)\n\n    # Sauter mean diameter and specific surface area\n    d32 = compute_sauter_mean_diameter(psd_diams, psd_weights)\n    a_s = 6.0 * eps_s / d32  # [1/m]\n\n    # Effective ionic conductivity using kappa_eff = kappa * eps^(1+beta)\n    kappa_eff = kappa * (eps ** (1.0 + beta))\n\n    # Electrolyte-limited current density\n    i_max_elec = (kappa_eff * delta_phi_e_max) / L\n\n    # Kinetics-limited current density\n    arg = (F * delta_phi_k_max) / (2.0 * Rgas * T)\n    i_max_kin = a_s * (2.0 * i0 * np.sinh(arg))\n\n    # Two-C geometric current density\n    i_2C = Q_A / 1800.0\n\n    # Rate margin and viability\n    limiting_i = min(i_max_elec, i_max_kin)\n    rate_margin = limiting_i / i_2C\n    viable = rate_margin >= 1.0\n\n    return kappa_eff, a_s, rate_margin, viable\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"psd_diams\": [6e-6, 8e-6, 10e-6, 12e-6],\n            \"psd_weights\": [0.2, 0.3, 0.3, 0.2],\n            \"eps\": 0.35,\n            \"beta\": 1.5,\n            \"kappa\": 1.2,\n            \"L\": 70e-6,\n            \"eps_s\": 0.55,\n            \"i0\": 3.5,\n            \"Q_A\": 144000.0,\n        },\n        # Case 2\n        {\n            \"psd_diams\": [8e-6, 12e-6, 16e-6, 20e-6],\n            \"psd_weights\": [0.1, 0.4, 0.3, 0.2],\n            \"eps\": 0.15,\n            \"beta\": 2.0,\n            \"kappa\": 0.8,\n            \"L\": 100e-6,\n            \"eps_s\": 0.75,\n            \"i0\": 3.0,\n            \"Q_A\": 250000.0,\n        },\n        # Case 3\n        {\n            \"psd_diams\": [1.2e-6, 1.5e-6, 2.0e-6],\n            \"psd_weights\": [0.4, 0.4, 0.2],\n            \"eps\": 0.60,\n            \"beta\": 1.5,\n            \"kappa\": 1.0,\n            \"L\": 50e-6,\n            \"eps_s\": 0.40,\n            \"i0\": 2.0,\n            \"Q_A\": 80000.0,\n        },\n        # Case 4\n        {\n            \"psd_diams\": [25e-6, 30e-6, 35e-6],\n            \"psd_weights\": [0.3, 0.5, 0.2],\n            \"eps\": 0.40,\n            \"beta\": 1.5,\n            \"kappa\": 1.4,\n            \"L\": 75e-6,\n            \"eps_s\": 0.50,\n            \"i0\": 1e-4,\n            \"Q_A\": 120000.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        kappa_eff, a_s, rate_margin, viable = rate_capability_case(\n            case[\"psd_diams\"],\n            case[\"psd_weights\"],\n            case[\"eps\"],\n            case[\"beta\"],\n            case[\"kappa\"],\n            case[\"L\"],\n            case[\"eps_s\"],\n            case[\"i0\"],\n            case[\"Q_A\"],\n            delta_phi_e_max=0.1,\n            delta_phi_k_max=0.1,\n            T=298.0\n        )\n        results.append([kappa_eff, a_s, rate_margin, viable])\n\n    # Final print statement in the exact required format.\n    # Convert booleans and floats to strings, preserve Python default formatting.\n    def item_to_str(item):\n        if isinstance(item, list):\n            return \"[\" + \",\".join(item_to_str(x) for x in item) + \"]\"\n        else:\n            return str(item)\n\n    print(\"[\" + \",\".join(item_to_str(res) for res in results) + \"]\")\n\nsolve()\n```"
        },
        {
            "introduction": "基于物理的电池模型通常由偏微分方程(PDEs)描述，这些方程必须通过数值方法求解。因此，数值方法的选择对于获得稳定且准确的解至关重要。本练习将带您深入计算建模的核心，通过分析一种常见数值格式的稳定性，揭示为何某些物理现象（如快速的电化学反应）会带来巨大的计算挑战，并阐明为何在处理此类“刚性”系统时，高级的隐式积分方法成为首选。",
            "id": "3895211",
            "problem": "在自动化电池设计与仿真中，多孔电极域中的电解质浓度动力学通常通过一个由物种守恒和菲克输运导出的一维偏微分方程 (PDE) 来建模。考虑电解质浓度 $c(x,t)$ 的线性化反应-扩散模型，\n$$\n\\frac{\\partial c}{\\partial t} \\;=\\; D\\,\\frac{\\partial^{2} c}{\\partial x^{2}} \\;-\\; k\\,c,\n$$\n其中 $D$ 是电解质中锂离子的有效扩散系数，$k$ 是一个线性化反应速率，表示由界面电荷转移引起的净体积汇。假设 $D$ 和 $k$ 在空间和时间上是常数，$D$ 的单位是 $\\mathrm{m^{2}\\,s^{-1}}$，$k$ 的单位是 $\\mathrm{s^{-1}}$。设空间域以网格尺寸 $\\Delta x$（单位为 $\\mathrm{m}$）进行均匀离散化，时间使用时间步长 $\\Delta t$（单位为 $\\mathrm{s}$）的前向欧拉显式格式进行推进，并对拉普拉斯算子使用二阶中心差分近似。假设采用周期性边界条件，以便傅里叶模能构成用于稳定性分析的完备基。\n\n从这些建模和离散化假设所隐含的有限差分更新出发，使用冯·诺依曼 (傅里叶) 稳定性分析，推导出一个稳定性条件，该条件保证了在显式格式下所有空间傅里叶模的线性稳定性。将您的条件表示为最大允许时间步长 $\\Delta t_{\\max}$，形式为包含 $D$、$k$ 和 $\\Delta x$ 的闭式解析表达式。\n\n然后，从特征值谱和稳定域的第一性原理出发，简要论证为什么对于具有大 $k$ 和小 $\\Delta x$ 并可能包含额外快速电容动力学的刚性电化学系统，通常首选如后向欧拉等隐式时间积分格式。您的论证应将刚性与上面推导出的时间步长约束联系起来。\n\n以秒为单位，提供 $\\Delta t_{\\max}$ 的单个闭式表达式作为最终答案。无需进行数值计算，也无需四舍五入。",
            "solution": "该问题要求推导数值格式的稳定性条件，并随后论证为何对刚性系统使用隐式方法。\n\n控制偏微分方程 (PDE) 是关于电解质浓度 $c(x,t)$ 的一维反应-扩散方程：\n$$\n\\frac{\\partial c}{\\partial t} = D\\,\\frac{\\partial^{2} c}{\\partial x^{2}} - k\\,c\n$$\n此处，$D$ 是有效扩散系数，$k$ 是线性化反应速率常数。$D$ 和 $k$ 均为正常数。\n\n我们首先对该方程进行离散化。令 $c_j^n$ 表示在空间位置 $x_j = j \\Delta x$ 和时间 $t_n = n \\Delta t$ 处浓度 $c$ 的数值近似。\n对时间导数使用前向欧拉格式，我们得到：\n$$\n\\frac{\\partial c}{\\partial t} \\approx \\frac{c_j^{n+1} - c_j^n}{\\Delta t}\n$$\n对空间拉普拉斯算子使用二阶中心差分格式，我们得到：\n$$\n\\frac{\\partial^2 c}{\\partial x^2} \\approx \\frac{c_{j+1}^n - 2c_j^n + c_{j-1}^n}{(\\Delta x)^2}\n$$\n反应项在当前时间步 $n$ 进行求值，与显式格式一致：$-k c_j^n$。\n\n将这些近似代入PDE，得到有限差分更新方程：\n$$\n\\frac{c_j^{n+1} - c_j^n}{\\Delta t} = D \\left( \\frac{c_{j+1}^n - 2c_j^n + c_{j-1}^n}{(\\Delta x)^2} \\right) - k c_j^n\n$$\n求解 $c_j^{n+1}$：\n$$\nc_j^{n+1} = c_j^n + \\frac{D \\Delta t}{(\\Delta x)^2} (c_{j+1}^n - 2c_j^n + c_{j-1}^n) - k \\Delta t c_j^n\n$$\n按时间步 $n$ 的空间索引对各项进行分组：\n$$\nc_j^{n+1} = \\left( 1 - \\frac{2 D \\Delta t}{(\\Delta x)^2} - k \\Delta t \\right) c_j^n + \\frac{D \\Delta t}{(\\Delta x)^2} (c_{j+1}^n + c_{j-1}^n)\n$$\n为分析此格式的稳定性，我们进行冯·诺依曼稳定性分析。我们假设解具有单个空间傅里叶模的形式：\n$$\nc_j^n = G^n e^{i \\kappa (j \\Delta x)}\n$$\n其中 $G$ 是每个时间步的放大因子，$\\kappa$ 是傅里叶模的波数，$i = \\sqrt{-1}$。为使格式稳定，对于所有波数 $\\kappa$，放大因子的模长必须小于或等于1，即 $|G| \\leq 1$。\n\n将傅里叶模拟设代入有限差分方程：\n$$\nG^{n+1} e^{i \\kappa j \\Delta x} = \\left( 1 - \\frac{2 D \\Delta t}{(\\Delta x)^2} - k \\Delta t \\right) G^n e^{i \\kappa j \\Delta x} + \\frac{D \\Delta t}{(\\Delta x)^2} \\left( G^n e^{i \\kappa (j+1) \\Delta x} + G^n e^{i \\kappa (j-1) \\Delta x} \\right)\n$$\n将整个方程除以 $G^n e^{i \\kappa j \\Delta x}$，得到 $G$ 的表达式：\n$$\nG = 1 - \\frac{2 D \\Delta t}{(\\Delta x)^2} - k \\Delta t + \\frac{D \\Delta t}{(\\Delta x)^2} \\left( e^{i \\kappa \\Delta x} + e^{-i \\kappa \\Delta x} \\right)\n$$\n使用欧拉恒等式 $e^{i\\theta} + e^{-i\\theta} = 2 \\cos(\\theta)$，其中 $\\theta = \\kappa \\Delta x$：\n$$\nG = 1 - k \\Delta t - \\frac{2 D \\Delta t}{(\\Delta x)^2} + \\frac{2 D \\Delta t}{(\\Delta x)^2} \\cos(\\kappa \\Delta x)\n$$\n提出扩散项的公因子：\n$$\nG = 1 - k \\Delta t - \\frac{2 D \\Delta t}{(\\Delta x)^2} (1 - \\cos(\\kappa \\Delta x))\n$$\n使用三角半角恒等式 $1 - \\cos(\\theta) = 2 \\sin^2(\\theta/2)$：\n$$\nG = 1 - k \\Delta t - \\frac{2 D \\Delta t}{(\\Delta x)^2} \\left( 2 \\sin^2\\left(\\frac{\\kappa \\Delta x}{2}\\right) \\right) = 1 - k \\Delta t - \\frac{4 D \\Delta t}{(\\Delta x)^2} \\sin^2\\left(\\frac{\\kappa \\Delta x}{2}\\right)\n$$\n由于 $D$、$k$、$\\Delta t$ 和 $\\Delta x$ 都是正实数，且 $\\sin^2(\\cdot) \\geq 0$，因此放大因子 $G$ 始终是一个实数。稳定性条件 $|G| \\leq 1$ 变为 $-1 \\leq G \\leq 1$。\n\n首先，我们检查上界 $G \\leq 1$：\n$$\n1 - k \\Delta t - \\frac{4 D \\Delta t}{(\\Delta x)^2} \\sin^2\\left(\\frac{\\kappa \\Delta x}{2}\\right) \\leq 1\n$$\n$$\n- k \\Delta t - \\frac{4 D \\Delta t}{(\\Delta x)^2} \\sin^2\\left(\\frac{\\kappa \\Delta x}{2}\\right) \\leq 0\n$$\n由于左边的所有项都是非正的，这个不等式对于 $\\Delta t \\geq 0$ 总是成立。\n\n接下来，我们检查下界 $G \\geq -1$：\n$$\n1 - k \\Delta t - \\frac{4 D \\Delta t}{(\\Delta x)^2} \\sin^2\\left(\\frac{\\kappa \\Delta x}{2}\\right) \\geq -1\n$$\n$$\n2 \\geq k \\Delta t + \\frac{4 D \\Delta t}{(\\Delta x)^2} \\sin^2\\left(\\frac{\\kappa \\Delta x}{2}\\right)\n$$\n$$\n2 \\geq \\Delta t \\left( k + \\frac{4 D}{(\\Delta x)^2} \\sin^2\\left(\\frac{\\kappa \\Delta x}{2}\\right) \\right)\n$$\n这导出了关于时间步长 $\\Delta t$ 的一个条件：\n$$\n\\Delta t \\leq \\frac{2}{ k + \\frac{4 D}{(\\Delta x)^2} \\sin^2\\left(\\frac{\\kappa \\Delta x}{2}\\right) }\n$$\n这个条件必须对所有可能的波数 $\\kappa$ 成立。为了找到对 $\\Delta t$ 最严格的约束，我们必须找到右侧的最小值，这发生在分母最大化时。当项 $\\sin^2\\left(\\frac{\\kappa \\Delta x}{2}\\right)$ 达到其最大值时，分母被最大化。$\\sin^2(\\cdot)$ 的最大值是 $1$。这发生在网格上可分辨的最高频率模（奈奎斯特频率）处，此时 $\\frac{\\kappa \\Delta x}{2} = \\frac{\\pi}{2}$，即 $\\kappa \\Delta x = \\pi$。\n\n将 $\\sin^2\\left(\\frac{\\kappa \\Delta x}{2}\\right) = 1$ 代入不等式，得到最终的稳定性条件：\n$$\n\\Delta t \\leq \\frac{2}{k + \\frac{4D}{(\\Delta x)^2}}\n$$\n因此，为使格式对所有傅里叶模都稳定，最大允许时间步长 $\\Delta t_{\\max}$ 为：\n$$\n\\Delta t_{\\max} = \\frac{2}{k + \\frac{4D}{(\\Delta x)^2}}\n$$\n\n问题的第二部分要求为刚性电化学系统首选隐式时间积分格式提供论证。\n\n如果一个微分方程组的解包含在差异巨大的时间尺度上发生的多个过程，则该系统被认为是刚性的。在我们模型的背景下，特征时间尺度与反应 $\\tau_{react} \\sim 1/k$ 和扩散 $\\tau_{diff} \\sim (\\Delta x)^2/D$ 相关联。我们为前向欧拉格式推导出的稳定性条件可以重写为：\n$$\n\\Delta t \\leq \\frac{1}{\\frac{k}{2} + \\frac{2D}{(\\Delta x)^2}} \\approx \\frac{1}{\\frac{1}{2\\tau_{react}} + \\frac{2}{\\tau_{diff,grid}}}\n$$\n其中 $\\tau_{diff,grid}$ 是扩散穿过单个网格单元的特征时间。这表明显式格式的稳定时间步长受系统中最快动力学过程的限制。\n\n电化学系统中的刚性通常源于：\n1.  快速的界面反应动力学，对应于大的 $k$ 值，因此 $\\tau_{react}$ 非常小。\n2.  需要解析电极附近非常薄的边界层或陡峭的浓度梯度，这要求非常小的网格尺寸 $\\Delta x$。这使得网格扩散时间尺度 $\\tau_{diff,grid}$ 非常小，因为 $\\tau_{diff,grid} \\propto (\\Delta x)^2$。\n在这类刚性系统中，最快的时间尺度可能比系统整体演化的时间尺度（例如，电池的总充电或放电时间）小几个数量级。\n\n推导出的约束 $\\Delta t_{\\max} = 2 / (k + 4D/(\\Delta x)^2)$ 迫使显式时间步长 $\\Delta t$ 变得极小以确保数值稳定性。这在计算上是不可行的，因为它需要巨大的时间步数来在有意义的持续时间内模拟系统，即使快速动态模态已经衰减到可忽略的振幅并且整体解正在缓慢演化。\n\n这种限制是前向欧拉方法稳定域的一个基本属性。离散化空间算子的特征值都是负实数，范围从大约 $-k$ 到 $-k-4D/(\\Delta x)^2$。前向欧拉的稳定域要求，对于系统矩阵的每个特征值 $\\lambda$，$\\Delta t|\\lambda|$ 必须落在复平面内的一个特定有界区域内。对于此问题，它要求 $\\Delta t \\leq 2/|\\lambda_{\\max}|$，其中 $|\\lambda_{\\max}| \\approx k+4D/(\\Delta x)^2$。\n\n相比之下，像后向欧拉这样的隐式格式具有大得多的稳定域。对于后向欧拉方法，更新方程为 $c_j^{n+1} = c_j^n + \\Delta t (D \\frac{c_{j+1}^{n+1} - 2c_j^{n+1} + c_{j-1}^{n+1}}{(\\Delta x)^2} - k c_j^{n+1})$。放大因子为 $G = 1/(1 + k\\Delta t + \\frac{4D\\Delta t}{(\\Delta x)^2}\\sin^2(\\frac{\\kappa\\Delta x}{2}))$。由于分母中的所有项均为正，对于任何 $\\Delta t > 0$，都有 $|G| \\leq 1$。该方法是无条件稳定的（或A-稳定的）。\n\n因为隐式格式不受与快速动力学相关的稳定性约束的限制，时间步长 $\\Delta t$ 可以根据捕捉较慢、主导的物理过程的精度要求来选择。这允许使用大得多的时间步长，并大大降低了模拟刚性系统的计算成本，使其成为自动化电池设计与仿真中刚性问题常见的首选方法。",
            "answer": "$$\\boxed{\\frac{2}{k + \\frac{4D}{(\\Delta x)^2}}}$$"
        },
        {
            "introduction": "自动化设计的最终目标是系统性地提升电池性能。基于梯度的优化是实现这一目标的强大工具，但它要求我们能高效地计算性能指标相对于设计参数的导数（或称灵敏度）。本实践将介绍两种计算灵敏度的核心技术——切线线性模型和伴随法。通过比较两者的实现过程，您将理解为何伴随法在优化多参数设计问题时是不可或缺的。",
            "id": "3895195",
            "problem": "给定一个简化的、无量纲化的、离散化的伪二维（Pseudo-Two-Dimensional, P2D）模型，该模型描述了在预设脉冲电流测试下的正极区域。任务是针对粒子半径 $R_{p}$ 和电极孔隙率 $\\varepsilon_{p}$ 实现切线线性（前向）灵敏度，并将其与基于伴随方法计算的相同目标的梯度进行比较。所有量均为无量纲；以无量纲单位报告最终结果。\n\n基本基准和模型定义：\n- 固体颗粒中的质量守恒由一个双态线性化球形扩散近似表示，其中 $c_{s,\\mathrm{avg}}$ 表示平均固相浓度，$c_{s,\\mathrm{surf}}$ 表示表面固相浓度。特征固相扩散系数为 $D_{s}$。\n- 电解质中的质量守恒被建模为一个一维扩散方程，该方程横跨离散为 $N$ 个节点的正极厚度，其有效扩散系数为 $D_{e,\\mathrm{eff}} = D_{e} \\varepsilon_{p}^{b}$，其中 $D_{e}$ 是参考电解质扩散系数，$b$ 是 Bruggeman 系数。\n- 界面反应通量 $j(t)$ 通过比表面积 $a_{s} = 3 \\varepsilon_{p}/R_{p}$ 与外加电流 $I(t)$ 相关，得出 $j(t) = I(t) / a_{s} = I(t) R_{p} / (3 \\varepsilon_{p})$。\n- 端电压 $V(t)$ 建模为 $V(t) = U_{0} + \\alpha c_{s,\\mathrm{surf}}(t) - \\delta \\overline{c}_{e}(t)$，其中 $\\overline{c}_{e}(t)$ 是电解质浓度在 $N$ 个节点上的算术平均值。常数 $U_{0}$、$\\alpha$ 和 $\\delta$ 是给定的。\n\n状态空间表示：\n设状态向量为 $x(t) \\in \\mathbb{R}^{2+N}$，其中 $x = [c_{s,\\mathrm{avg}}, c_{s,\\mathrm{surf}}, c_{e,1}, \\ldots, c_{e,N}]^{\\top}$。其动力学方程为：\n- $c_{s,\\mathrm{avg}}'(t) = - j(t)$。\n- $c_{s,\\mathrm{surf}}'(t) = \\frac{D_{s}}{R_{p}^{2}} \\left(c_{s,\\mathrm{avg}}(t) - c_{s,\\mathrm{surf}}(t)\\right) - j(t)$。\n- $c_{e}'(t) = D_{e} \\varepsilon_{p}^{b} L c_{e}(t) - \\gamma j(t) \\mathbf{1}$，其中 $L \\in \\mathbb{R}^{N \\times N}$ 是标准的二阶差分拉普拉斯算子，在离散化区域的两端具有零通量（Neumann）边界条件，$\\mathbf{1}$ 是 $N$ 维全一向量，$\\gamma$ 是一个常数。\n\n初始条件：\n- $c_{s,\\mathrm{avg}}(0) = 0$，$c_{s,\\mathrm{surf}}(0) = 0$，并且对于所有 $i \\in \\{1, \\ldots, N\\}$，$c_{e,i}(0) = 1$。\n\n脉冲电流测试：\n- 设总模拟时间为 $T$，时间步长为 $\\Delta t$，离散时间为 $t_{k} = k \\Delta t$，其中 $k \\in \\{0, 1, \\ldots, K\\}$ 且 $K = T / \\Delta t$。\n- 外加电流在 $t \\in [0, t_{1})$ 时为 $I(t) = 0$，在 $t \\in [t_{1}, t_{2})$ 时为 $I(t) = I_{0}$，在 $t \\in [t_{2}, T]$ 时为 $I(t) = 0$，其中 $t_{1}$ 和 $t_{2}$ 是指定的。\n\n目标泛函：\n- 设参考电压轨迹 $V_{\\mathrm{ref}}(t)$ 由同一模型在基准参数 $(R_{p}^{\\mathrm{ref}}, \\varepsilon_{p}^{\\mathrm{ref}})$ 下生成。需要微分的目标是\n$$\nJ(R_{p}, \\varepsilon_{p}) = \\frac{1}{2} \\sum_{k=0}^{K} w \\left(V(t_{k}) - V_{\\mathrm{ref}}(t_{k})\\right)^{2} \\Delta t,\n$$\n其中 $w$ 是常数权重。\n\n灵敏度和伴随方法要求：\n- 为给定模型的离散时间显式 Euler 积分器实现切线线性灵敏度方程，计算 $\\frac{\\partial J}{\\partial R_{p}}$ 和 $\\frac{\\partial J}{\\partial \\varepsilon_{p}}$。\n- 实现与显式 Euler 时间步进一致的离散伴随方法，以计算相同的梯度。\n- 通过报告每个测试案例中每个参数的绝对差值，来比较两种梯度计算方法。\n\n离散化细节：\n- 使用显式 Euler 时间步进：$x_{k+1} = x_{k} + \\Delta t \\, f(x_{k}, R_{p}, \\varepsilon_{p}, t_{k})$。\n- 在一个单位长度域上，$N$ 个节点的均匀网格上使用具有零通量边界条件的一维拉普拉斯算子 $L$，即网格间距 $d = 1/N$。对于内部节点，使用按 $1/d^{2}$ 缩放的标准二阶差分模板；对于边界节点，使用镜像值来施加零通量条件。\n\n使用的常数：\n- $N = 5$, $D_{s} = 0.1$, $D_{e} = 0.2$, $b = 1.5$, $\\gamma = 0.05$, $U_{0} = 0.0$, $\\alpha = 0.8$, $\\delta = 0.3$。\n- $T = 1.0$, $\\Delta t = 0.001$, $I_{0} = 1.0$, $t_{1} = 0.2$, $t_{2} = 0.7$, $w = 1.0$。\n- 基准参考参数：$R_{p}^{\\mathrm{ref}} = 1.0$, $\\varepsilon_{p}^{\\mathrm{ref}} = 0.5$。\n\n测试套件：\n- 案例1：$R_{p} = 1.0$, $\\varepsilon_{p} = 0.5$（基准“理想路径”）。\n- 案例2：$R_{p} = 0.3$, $\\varepsilon_{p} = 0.5$（小粒子半径）。\n- 案例3：$R_{p} = 1.0$, $\\varepsilon_{p} = 0.9$（高孔隙率）。\n- 案例4：$R_{p} = 1.0$, $\\varepsilon_{p} = 0.1$（低孔隙率）。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序包含切线梯度和伴随梯度的绝对差值，针对参数 $(R_{p}, \\varepsilon_{p})$：\n$$\n[\\left|\\frac{\\partial J}{\\partial R_{p}}\\right|_{\\mathrm{tan}} - \\left|\\frac{\\partial J}{\\partial R_{p}}\\right|_{\\mathrm{adj}}, \\left|\\frac{\\partial J}{\\partial \\varepsilon_{p}}\\right|_{\\mathrm{tan}} - \\left|\\frac{\\partial J}{\\partial \\varepsilon_{p}}\\right|_{\\mathrm{adj}}, \\ldots]\n$$\n针对上面列出的四个案例。将差值表示为原始浮点数（无量纲）。\n\n所有数学实体必须使用美元符号的内联格式以 LaTeX 呈现，并且每个缩略词在首次出现时必须展开。",
            "solution": "该问题要求针对一个简化的电池电极电化学模型，实现并比较两种梯度计算方法——切线线性模型和离散伴随方法。需要计算目标泛函 $J$ 关于固相颗粒半径 $R_p$ 和电极孔隙率 $\\varepsilon_p$ 的梯度。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n- **状态向量**：$x(t) \\in \\mathbb{R}^{2+N}$，其中 $x = [c_{s,\\mathrm{avg}}, c_{s,\\mathrm{surf}}, c_{e,1}, \\ldots, c_{e,N}]^{\\top}$。\n- **状态方程（动力学）**：\n  - $c_{s,\\mathrm{avg}}'(t) = - j(t)$\n  - $c_{s,\\mathrm{surf}}'(t) = \\frac{D_{s}}{R_{p}^{2}} \\left(c_{s,\\mathrm{avg}}(t) - c_{s,\\mathrm{surf}}(t)\\right) - j(t)$\n  - $c_{e}'(t) = D_{e} \\varepsilon_{p}^{b} L c_{e}(t) - \\gamma j(t) \\mathbf{1}$，其中 $c_e = [c_{e,1}, \\ldots, c_{e,N}]^{\\top}$。\n- **模型定义**：\n  - 界面通量：$j(t) = I(t) / a_{s} = I(t) R_{p} / (3 \\varepsilon_{p})$，其中 $a_s = 3 \\varepsilon_{p}/R_{p}$。\n  - 端电压：$V(t) = U_{0} + \\alpha c_{s,\\mathrm{surf}}(t) - \\delta \\overline{c}_{e}(t)$，其中 $\\overline{c}_{e}(t) = \\frac{1}{N} \\sum_{i=1}^{N} c_{e,i}(t)$。\n- **初始条件**：对所有 $i$，$c_{s,\\mathrm{avg}}(0) = 0$，$c_{s,\\mathrm{surf}}(0) = 0$，$c_{e,i}(0) = 1$。\n- **脉冲电流**：$I(t) = I_{0}$ 对于 $t \\in [t_{1}, t_{2})$，其他情况为 $I(t)=0$。\n- **目标泛函**：$J(R_{p}, \\varepsilon_{p}) = \\frac{1}{2} \\sum_{k=0}^{K} w \\left(V(t_{k}) - V_{\\mathrm{ref}}(t_{k})\\right)^{2} \\Delta t$。\n- **离散化**：\n  - 显式 Euler 时间步进：$x_{k+1} = x_{k} + \\Delta t \\, f(x_{k}, R_{p}, \\varepsilon_{p}, t_{k})$。\n  - 拉普拉斯算子 $L$：在单位长度的 $N$ 个节点的均匀网格上的二阶差分（间距 $d=1/N$），通过镜像值实现零通量（Neumann）边界条件。\n- **常数**：\n  - $N = 5$, $D_{s} = 0.1$, $D_{e} = 0.2$, $b = 1.5$, $\\gamma = 0.05$, $U_{0} = 0.0$, $\\alpha = 0.8$, $\\delta = 0.3$。\n  - $T = 1.0$, $\\Delta t = 0.001$, $I_{0} = 1.0$, $t_{1} = 0.2$, $t_{2} = 0.7$, $w = 1.0$。\n- **参考参数**：$R_{p}^{\\mathrm{ref}} = 1.0$, $\\varepsilon_{p}^{\\mathrm{ref}} = 0.5$。\n- **测试案例**：\n  - 案例 1：$R_{p} = 1.0, \\varepsilon_{p} = 0.5$\n  - 案例 2：$R_{p} = 0.3, \\varepsilon_{p} = 0.5$\n  - 案例 3：$R_{p} = 1.0, \\varepsilon_{p} = 0.9$\n  - 案例 4：$R_{p} = 1.0, \\varepsilon_{p} = 0.1$\n- **要求输出**：报告每个案例中 $p \\in \\{R_p, \\varepsilon_p\\}$ 的 $\\left|\\frac{\\partial J}{\\partial p}\\right|_{\\mathrm{tan}} - \\left|\\frac{\\partial J}{\\partial p}\\right|_{\\mathrm{adj}}$ 的值。这里有一个小矛盾：周围的文本指的是“绝对差值”，即 $|\\dots - \\dots|$，而明确的公式没有外层的绝对值。我们遵循更具体的数学公式。\n\n**步骤 2：使用提取的给定信息进行验证**\n该问题描述了对一个简化的伪二维（P2D）电池模型的灵敏度分析。\n- **科学基础**：该模型是锂离子电池动力学的一个公认的简化模型，基于质量守恒（扩散）和电化学反应动力学原理。所有方程和参数都具有物理动机。\n- **适定性**：该问题被构建为计算科学中的一个标准任务：使用两种理论上等效的不同方法计算梯度。常微分方程组（ODEs）在状态变量上是线性的（对于固定参数），并且所选的显式 Euler 格式对于给定参数是稳定的。存在唯一解。\n- **目标**：语言精确，所有术语都有数学定义。\n该问题没有列出的无效性缺陷。注意到输出格式描述中的小矛盾，但这并不影响核心科学任务的有效性，因为两种解释都将测试相同的基础条件（梯度相等）。\n\n**步骤 3：结论与行动**\n该问题是**有效的**。将提供一个完整的解决方案。\n\n### 解决方案\n\n解决方案包括三个主要阶段：首先，随时间正向模拟模型以获得状态和电压轨迹（原始解）；其次，使用切线线性模型计算梯度；第三，使用离散伴随方法计算第二组梯度。\n\n**1. 原始问题：正向模拟**\n\n系统动力学可以写成紧凑形式 $x' = f(x, p, t)$，其中 $p = [R_p, \\varepsilon_p]^{\\top}$ 是参数向量。我们使用显式 Euler 方法在时间网格 $t_k = k \\Delta t$（$k=0, \\ldots, K$）上对此进行离散化：\n$$ x_{k+1} = x_k + \\Delta t \\, f(x_k, p, t_k) $$\n该方程从初始条件 $x_0 = [0, 0, 1, \\ldots, 1]^{\\top}$ 开始迭代求解。在每个时间步 $t_k$，状态 $x_k$ 用于计算电压 $V_k$。完整的历史记录 $x_{\\mathrm{hist}}=[x_0, \\ldots, x_K]$ 和 $V_{\\mathrm{hist}}=[V_0, \\ldots, V_K]$ 被存储起来。此过程首先针对参考参数 $p_{\\mathrm{ref}} = [R_p^{\\mathrm{ref}}, \\varepsilon_p^{\\mathrm{ref}}]^{\\top}$ 执行，以生成 $V_{\\mathrm{ref}}(t_k)$。\n\n**2. 切线线性模型（前向灵敏度分析）**\n\n切线线性模型计算状态向量关于参数 $p_j \\in \\{R_p, \\varepsilon_p\\}$ 的灵敏度，记为 $s^{(j)}_k = \\frac{ d x_k }{ d p_j }$。对 Euler 步进关于 $p_j$ 求导，得到灵敏度的传播规则：\n$$ s^{(j)}_{k+1} = \\frac{d x_{k+1}}{d p_j} = \\frac{d}{d p_j} \\left( x_k + \\Delta t \\, f(x_k, p, t_k) \\right) = \\frac{d x_k}{d p_j} + \\Delta t \\left( \\frac{\\partial f}{\\partial x}\\bigg|_{x_k} \\frac{d x_k}{d p_j} + \\frac{\\partial f}{\\partial p_j}\\bigg|_{x_k} \\right) $$\n$$ s^{(j)}_{k+1} = \\left( I + \\Delta t \\frac{\\partial f}{\\partial x}\\bigg|_{x_k} \\right) s^{(j)}_k + \\Delta t \\frac{\\partial f}{\\partial p_j}\\bigg|_{x_k} $$\n其中 $I$ 是单位矩阵。初始灵敏度为 $s^{(j)}_0 = \\frac{d x_0}{d p_j} = 0$，因为 $x_0$ 是常数。此方程与原始解一起，在时间上从 $k=0$ 到 $K-1$ 正向求解。\n\n目标函数 $J$ 关于 $p_j$ 的全导数由链式法则给出：\n$$ \\frac{d J}{d p_j} = \\sum_{k=0}^{K} \\frac{\\partial J}{\\partial x_k} \\frac{d x_k}{d p_j} = \\sum_{k=0}^{K} \\frac{\\partial J}{\\partial x_k} s^{(j)}_k $$\n其中 $\\frac{\\partial J}{\\partial x_k} = w \\left(V(t_{k}) - V_{\\mathrm{ref}}(t_{k})\\right) \\frac{\\partial V_k}{\\partial x_k} \\Delta t$。项 $\\frac{\\partial V_k}{\\partial x_k}$ 是从电压方程导出的行向量：$\\frac{\\partial V_k}{\\partial x_k} = [0, \\alpha, -\\delta/N, \\ldots, -\\delta/N]$。通过在每个步骤中累积 $\\frac{\\partial J}{\\partial x_k}$ 和 $s^{(j)}_k$ 的点积来计算梯度。\n\n**3. 离散伴随方法（后向灵敏度分析）**\n\n当参数数量很大时，伴随方法提供了一种计算效率更高的方式来计算梯度。我们为每个时间步定义一个伴随向量 $\\lambda_k \\in \\mathbb{R}^{1 \\times (2+N)}$。推导伴随方程是为了将最终目标函数的灵敏度随时间向后传播。对于离散显式 Euler 格式，伴随递推关系为：\n$$ \\lambda_k = \\lambda_{k+1} \\left( I + \\Delta t \\frac{\\partial f}{\\partial x}\\bigg|_{x_k} \\right) + \\frac{\\partial J}{\\partial x_k} $$\n该方程从 $k=K-1$ 向下求解至 $0$。终端条件是 $\\lambda_K = \\frac{\\partial J}{\\partial x_K}$。由于 $J$ 中的求和包含 $k=K$，因此 $\\frac{\\partial J}{\\partial x_K}$ 非零。对于 $k > K$，我们可以认为 $\\lambda_{k>K}=0$。`dJ/dx` 的偏导数与切线方法中的相同。\n\n一旦知道了伴随向量，就可以通过对每个时间步的贡献求和来计算梯度：\n$$ \\frac{d J}{d p_j} = \\sum_{k=0}^{K-1} \\lambda_{k+1} \\left( \\Delta t \\frac{\\partial f}{\\partial p_j}\\bigg|_{x_k} \\right) $$\n这个求和在后向扫描过程中执行。其关键优势在于，一次后向传递可以同时产生所有参数的梯度。\n\n**实现细节**\n\n雅可比矩阵 $\\frac{\\partial f}{\\partial x}$、$\\frac{\\partial f}{\\partial R_p}$ 和 $\\frac{\\partial f}{\\partial \\varepsilon_p}$ 从状态方程解析推导。拉普拉斯算子 $L$ 是为具有零通量边界条件的 $N=5$ 个节点构建的。Python 实现封装了这些原理，为每个测试案例计算梯度，并报告指定的差异，该差异预计接近于零，从而证实两种实现的正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    # Define constants from the problem statement\n    N = 5\n    DS = 0.1\n    DE = 0.2\n    B = 1.5\n    GAMMA = 0.05\n    U0 = 0.0\n    ALPHA = 0.8\n    DELTA = 0.3\n    T = 1.0\n    DT = 0.001\n    I0 = 1.0\n    T1 = 0.2\n    T2 = 0.7\n    W = 1.0\n    RP_REF = 1.0\n    EPSP_REF = 0.5\n\n    # Define test cases\n    test_cases = [\n        (1.0, 0.5), # Case 1: Baseline\n        (0.3, 0.5), # Case 2: Small particle radius\n        (1.0, 0.9), # Case 3: High porosity\n        (1.0, 0.1), # Case 4: Low porosity\n    ]\n\n    # --- Setup ---\n    K = int(T / DT)\n    time_grid = np.linspace(0, T, K + 1)\n    state_dim = 2 + N\n    d = 1.0 / N\n\n    # Construct the 1D Laplacian matrix with zero-flux Neumann boundary conditions\n    L = np.zeros((N, N))\n    fill_val = 1 / (d * d)\n    for i in range(N):\n        if i > 0:\n            L[i, i - 1] = fill_val\n        L[i, i] = -2 * fill_val\n        if i < N - 1:\n            L[i, i + 1] = fill_val\n    L[0, 0] = -1 * fill_val\n    L[N - 1, N - 1] = -1 * fill_val\n    \n    # Pre-compute the current pulse profile\n    I_hist = np.array([I0 if T1 <= t < T2 else 0.0 for t in time_grid])\n\n    # Gradient of voltage V w.r.t. state x (a row vector)\n    dVdx_row = np.zeros(state_dim)\n    dVdx_row[1] = ALPHA\n    dVdx_row[2:] = -DELTA / N\n\n    def get_state_derivatives(x, p, I_val):\n        \"\"\"Computes dx/dt = f(x, p, t) and related quantities.\"\"\"\n        R_p, eps_p = p\n        \n        j = I_val * R_p / (3 * eps_p) if eps_p != 0 else 0.0\n        \n        f = np.zeros(state_dim)\n        f[0] = -j\n        f[1] = (DS / R_p**2) * (x[0] - x[1]) - j if R_p != 0 else -j\n        f[2:] = DE * (eps_p**B) * (L @ x[2:]) - GAMMA * j\n        return f\n\n    def run_forward_model(p):\n        \"\"\"Solves the primal problem x_{k+1} = x_k + dt*f(x_k, p, t_k).\"\"\"\n        R_p, eps_p = p\n        x_hist = np.zeros((K + 1, state_dim))\n        V_hist = np.zeros(K + 1)\n\n        # Initial conditions\n        x_hist[0, 2:] = 1.0\n        V_hist[0] = U0 + ALPHA * x_hist[0, 1] - DELTA * np.mean(x_hist[0, 2:])\n        \n        for k in range(K):\n            f_k = get_state_derivatives(x_hist[k], p, I_hist[k])\n            x_hist[k+1] = x_hist[k] + DT * f_k\n            V_hist[k+1] = U0 + ALPHA * x_hist[k+1, 1] - DELTA * np.mean(x_hist[k+1, 2:])\n        \n        return x_hist, V_hist\n\n    # --- Generate Reference Voltage Trace ---\n    _, V_ref_hist = run_forward_model((RP_REF, EPSP_REF))\n    \n    all_results = []\n    \n    for R_p, eps_p in test_cases:\n        p_case = (R_p, eps_p)\n        \n        # --- 1. Primal Solve ---\n        x_hist, V_hist = run_forward_model(p_case)\n        \n        # Helper function to get Jacobians\n        def get_jacobians(x, p, I_val):\n            R_p, eps_p = p\n            \n            # df/dx\n            dfdx = np.zeros((state_dim, state_dim))\n            if R_p != 0:\n                dfdx[1, 0] = DS / R_p**2\n                dfdx[1, 1] = -DS / R_p**2\n            dfdx[2:, 2:] = DE * (eps_p**B) * L\n\n            # df/dRp\n            dfdRp = np.zeros(state_dim)\n            dj_dRp = I_val / (3 * eps_p) if eps_p != 0 else 0.0\n            if R_p != 0:\n                dfdRp[0] = -dj_dRp\n                dfdRp[1] = -2 * DS * (x[0] - x[1]) / R_p**3 - dj_dRp\n                dfdRp[2:] = -GAMMA * dj_dRp\n            \n            # df/depsp\n            dfdepsp = np.zeros(state_dim)\n            if eps_p != 0:\n                dj_depsp = -I_val * R_p / (3 * eps_p**2)\n                dfdepsp[0] = -dj_depsp\n                dfdepsp[1] = -dj_depsp\n                dfdepsp[2:] = DE * B * (eps_p**(B - 1)) * (L @ x[2:]) - GAMMA * dj_depsp\n\n            return dfdx, dfdRp, dfdepsp\n\n        # --- 2. Tangent Linear Model ---\n        s_Rp = np.zeros(state_dim)\n        s_epsp = np.zeros(state_dim)\n        \n        grad_Rp_tan = 0.0\n        grad_epsp_tan = 0.0\n        \n        Id = np.identity(state_dim)\n        \n        for k in range(K + 1):\n            dJdxk_row = W * (V_hist[k] - V_ref_hist[k]) * DT * dVdx_row\n            grad_Rp_tan += np.dot(dJdxk_row, s_Rp)\n            grad_epsp_tan += np.dot(dJdxk_row, s_epsp)\n            \n            if k < K:\n                dfdx, dfdRp, dfdepsp = get_jacobians(x_hist[k], p_case, I_hist[k])\n                Fk_dx = Id + DT * dfdx\n                \n                s_Rp = Fk_dx @ s_Rp + DT * dfdRp\n                s_epsp = Fk_dx @ s_epsp + DT * dfdepsp\n\n        # --- 3. Discrete Adjoint Method ---\n        grad_Rp_adj = 0.0\n        grad_epsp_adj = 0.0\n\n        dJdxK_row = W * (V_hist[K] - V_ref_hist[K]) * DT * dVdx_row\n        lambda_next = dJdxK_row\n        \n        for k in range(K - 1, -1, -1):\n            dfdx, dfdRp, dfdepsp = get_jacobians(x_hist[k], p_case, I_hist[k])\n            \n            Fk_dRp = DT * dfdRp\n            Fk_depsp = DT * dfdepsp\n\n            # Accumulate gradient contribution from step k\n            grad_Rp_adj += np.dot(lambda_next, Fk_dRp)\n            grad_epsp_adj += np.dot(lambda_next, Fk_depsp)\n            \n            # Update adjoint for next (backward) step\n            Fk_dx = Id + DT * dfdx\n            dJdxk_row = W * (V_hist[k] - V_ref_hist[k]) * DT * dVdx_row\n            lambda_curr = lambda_next @ Fk_dx + dJdxk_row\n            lambda_next = lambda_curr\n\n        # --- 4. Compare and Store Results ---\n        # As per the LaTeX formula: |grad_tan| - |grad_adj|\n        diff_Rp = abs(grad_Rp_tan) - abs(grad_Rp_adj)\n        diff_epsp = abs(grad_epsp_tan) - abs(grad_epsp_adj)\n        all_results.extend([diff_Rp, diff_epsp])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}