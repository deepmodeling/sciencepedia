{
    "hands_on_practices": [
        {
            "introduction": "理解电池单元的动态行为是设计有效均衡系统的第一步。本实践将指导您使用一阶戴维南模型（电池建模的基石）来仿真一个双电芯电池组。通过实施此仿真（），您将直接观察到电芯内阻的差异如何导致它们的端电压在充电状态相同时发生偏离，这是一个使简单的基于电压的均衡策略复杂化的关键现象。",
            "id": "3898809",
            "problem": "考虑一个双电芯锂离子电池包，该电池包采用一阶戴维南等效电路进行建模，其中两个电芯接收相同的电池包电流。采用符号约定，正电流 $I$ 对应充电。每个电芯 $i \\in \\{1,2\\}$ 被建模为一个开路电压源，其开路电压 $U(z_{i})$ 取决于荷电状态 $z_{i}$，一个串联电阻 $R_{s,i}$，以及一个产生瞬态极化电压 $v_{p,i}$ 的单极化支路。电芯 $i$ 的测量端电压为\n$$\nV_{i}(t) = U(z_{i}(t)) + I\\,R_{s,i} + v_{p,i}(t).\n$$\n该模型易于处理且科学上真实，可用于检查瞬态电压差异，这种差异在 $R_{s,1} \\neq R_{s,2}$ 即使 $z_{1}(t) \\approx z_{2}(t)$ 时也可能错误地指示不平衡。\n\n使用以下基本原理：\n1. 容量为 $Q$（单位为库仑）的电芯在充电电流 $I$ 下的荷电状态定义为\n$$\n\\frac{dz_{i}}{dt} = \\frac{I}{Q},\n$$\n其中 $z_{i}\\in[0,1]$ 且 $Q$ 为常数。\n2. 对于极化支路，应用源自基尔霍夫电流定律 (KCL) 的戴维南阻容动态特性。对于由电阻 $R_{t}$ 和电容 $C_{t}$ 组成的支路，极化电压 $v_{p,i}$ 服从\n$$\n\\frac{dv_{p,i}}{dt} = -\\frac{1}{R_{t}C_{t}}\\,v_{p,i} + \\frac{I}{C_{t}}.\n$$\n3. 锂离子电芯的一个平滑且物理上合理的开路电压函数 $U(z)$ 可近似为\n$$\nU(z) = 3.0 + 1.2\\,z + 0.1\\,\\tanh\\!\\left(\\frac{z - 0.5}{0.1}\\right),\n$$\n该函数在 $z \\in [0,1]$ 范围内产生的电压接近典型值。\n\n基于这些原理，推导使用均匀时间步长 $\\Delta t$ 和显式时间步进法在有限时间范围内模拟双电芯电池包所需的离散时间更新方程。您必须实现一个程序，该程序：\n- 使用给定的 $z_{i}(0)$ 和 $v_{p,i}(0)$ 初始化两个电芯。\n- 使用上述关系演化 $z_{i}(t)$、$v_{p,i}(t)$，并计算 $V_{i}(t)$。\n- 为每个指定的参数集计算以下三个量：\n  1. 仿真窗口内的最大绝对端电压差异，单位为伏特。\n     $$\n     \\max_{t\\in[0,T]} \\left| V_{1}(t) - V_{2}(t) \\right| \\quad \\text{in volts}.\n     $$\n  2. 最终有符号端电压差，单位为伏特。\n     $$\n     V_{1}(T) - V_{2}(T) \\quad \\text{in volts}.\n     $$\n  3. 一个以整数（$0$ 或 $1$）表示的误报标志：如果在 $[0,T]$ 内存在任何时间，使得 $\\left|V_{1}(t)-V_{2}(t)\\right| \\geq V_{\\text{th}}$ 同时 $\\left|z_{1}(t)-z_{2}(t)\\right| \\leq \\varepsilon_{z}$，则输出 $1$，否则输出 $0$。这代表一个简易的、基于电压阈值的不平衡检测器在荷电状态差异很小时错误地标记了不平衡。\n\n使用以下明确的单位和约定：\n- 电流 $I$ 单位为安培 ($\\mathrm{A}$)。\n- 电阻 $R_{s,i}$ 和 $R_{t}$ 单位为欧姆 ($\\Omega$)。\n- 电容 $C_{t}$ 单位为法拉 ($\\mathrm{F}$)。\n- 容量 $Q$ 单位为库仑 ($\\mathrm{C}$)。\n- 时间 $T$ 和时间步长 $\\Delta t$ 单位为秒 ($\\mathrm{s}$)。\n- 电压单位为伏特 ($\\mathrm{V}$)。\n- 荷电状态 $z$ 是无量纲的。\n\n使用对于给定参数稳定的显式方法，以均匀时间步长 $\\Delta t$ 离散化连续时间动态模型，并在仿真期间将 $z_{i}(t)$ 约束在区间 $[0,1]$ 内以保持物理合理性。\n\n测试套件：\n实现您的程序以运行以下四个参数集。对于每种情况，按指定的单位和格式生成上述三个输出。\n\n情况1（理想情况：中等串联电阻失配）：\n- $I = 5\\ \\mathrm{A}$, $R_{s,1} = 0.010\\ \\Omega$, $R_{s,2} = 0.020\\ \\Omega$,\n- $R_{t} = 0.015\\ \\Omega$, $C_{t} = 2000\\ \\mathrm{F}$,\n- $Q = 7200\\ \\mathrm{C}$, $T = 100\\ \\mathrm{s}$, $\\Delta t = 0.1\\ \\mathrm{s}$,\n- $z_{1}(0) = 0.5$, $z_{2}(0) = 0.5$, $v_{p,1}(0) = 0.0\\ \\mathrm{V}$, $v_{p,2}(0) = 0.0\\ \\mathrm{V}$,\n- 电压阈值 $V_{\\text{th}} = 0.05\\ \\mathrm{V}$, 荷电状态容差 $\\varepsilon_{z} = 0.001$.\n\n情况2（边界情况：串联电阻相同）：\n- $I = 5\\ \\mathrm{A}$, $R_{s,1} = 0.015\\ \\Omega$, $R_{s,2} = 0.015\\ \\Omega$,\n- $R_{t} = 0.015\\ \\Omega$, $C_{t} = 2000\\ \\mathrm{F}$,\n- $Q = 7200\\ \\mathrm{C}$, $T = 100\\ \\mathrm{s}$, $\\Delta t = 0.1\\ \\mathrm{s}$,\n- $z_{1}(0) = 0.5$, $z_{2}(0) = 0.5$, $v_{p,1}(0) = 0.0\\ \\mathrm{V}$, $v_{p,2}(0) = 0.0\\ \\mathrm{V}$,\n- $V_{\\text{th}} = 0.05\\ \\mathrm{V}$, $\\varepsilon_{z} = 0.001$.\n\n情况3（边缘情况：较大失配和较高电流，时间常数不同）：\n- $I = 10\\ \\mathrm{A}$, $R_{s,1} = 0.005\\ \\Omega$, $R_{s,2} = 0.030\\ \\Omega$,\n- $R_{t} = 0.020\\ \\Omega$, $C_{t} = 1200\\ \\mathrm{F}$,\n- $Q = 7200\\ \\mathrm{C}$, $T = 60\\ \\mathrm{s}$, $\\Delta t = 0.05\\ \\mathrm{s}$,\n- $z_{1}(0) = 0.6$, $z_{2}(0) = 0.6$, $v_{p,1}(0) = 0.0\\ \\mathrm{V}$, $v_{p,2}(0) = 0.0\\ \\mathrm{V}$,\n- $V_{\\text{th}} = 0.05\\ \\mathrm{V}$, $\\varepsilon_{z} = 0.001$.\n\n情况4（边缘情况：零电流基准）：\n- $I = 0\\ \\mathrm{A}$, $R_{s,1} = 0.020\\ \\Omega$, $R_{s,2} = 0.040\\ \\Omega$,\n- $R_{t} = 0.015\\ \\Omega$, $C_{t} = 2000\\ \\mathrm{F}$,\n- $Q = 7200\\ \\mathrm{C}$, $T = 50\\ \\mathrm{s}$, $\\Delta t = 0.1\\ \\mathrm{s}$,\n- $z_{1}(0) = 0.5$, $z_{2}(0) = 0.5$, $v_{p,1}(0) = 0.0\\ \\mathrm{V}$, $v_{p,2}(0) = 0.0\\ \\mathrm{V}$,\n- $V_{\\text{th}} = 0.05\\ \\mathrm{V}$, $\\varepsilon_{z} = 0.001$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的结果，格式为方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是以下形式的列表：\n$$\n\\left[\\max_{t} \\left| V_{1}(t) - V_{2}(t) \\right|,\\; V_{1}(T) - V_{2}(T),\\; \\text{flag}\\right],\n$$\n其中前两项是单位为伏特的浮点数，第三项是整数（$0$ 或 $1$）。例如，您的输出应如下所示\n$$\n[\\,[x_{1},y_{1},b_{1}],\\,[x_{2},y_{2},b_{2}],\\,[x_{3},y_{3},b_{3}],\\,[x_{4},y_{4},b_{4}]\\,],\n$$\n所有数值均由您的仿真按指定单位计算得出。",
            "solution": "用户提供的问题是有效的。它基于成熟的电池建模技术（一阶戴维南等效电路模型），具有科学依据；问题设定适定，为获得唯一解提供了所有必要的参数和初始条件；并且其表述和要求是客观的。该问题要求开发并实现一个双电芯电池包的离散时间仿真，以分析特定条件下的电压差异。\n\n解决方案首先从提供的连续时间模型推导离散时间更新方程，然后概述用于计算所需指标的仿真算法。\n\n### 1. 连续时间模型构建\n\n该系统由两个电芯组成，每个电芯由一个状态向量描述，该向量包含其荷电状态 (SoC)，$z_i(t)$，和其极化电压，$v_{p,i}(t)$。系统的动态特性由一组常微分方程 (ODE) 控制。\n\n电芯 $i$ 的荷电状态 $z_i(t)$ 根据库仑计数原理演化：\n$$\n\\frac{dz_{i}}{dt} = \\frac{I}{Q}\n$$\n其中 $I$ 是电池包电流（充电为正），$Q$ 是电芯的总容量，单位为库仑。\n\n极化电压 $v_{p,i}(t)$ 捕捉了电芯的瞬态响应，并由并联阻容 (RC) 电路的动态特性建模：\n$$\n\\frac{dv_{p,i}}{dt} = -\\frac{1}{R_{t}C_{t}}\\,v_{p,i}(t) + \\frac{I}{C_{t}}\n$$\n其中 $R_t$ 和 $C_t$ 分别是极化支路的电阻和电容。注意到这些参数对两个电芯是相同的。\n\n每个电芯的端电压 $V_i(t)$ 是开路电压 (OCV)、串联电阻上的电压降和极化电压的代数和：\n$$\nV_{i}(t) = U(z_{i}(t)) + I\\,R_{s,i} + v_{p,i}(t)\n$$\n开路电压 $U(z)$ 是荷电状态的非线性函数，由下式给出：\n$$\nU(z) = 3.0 + 1.2\\,z + 0.1\\,\\tanh\\!\\left(\\frac{z - 0.5}{0.1}\\right)\n$$\n\n### 2. 模型离散化\n\n为对系统进行数值仿真，我们使用显式（前向）欧拉法，以均匀时间步长 $\\Delta t$ 对连续时间常微分方程进行离散化。令下标 $k$ 表示变量在时间 $t_k = k \\Delta t$ 的值。\n\n荷电状态 $z_{i,k}$ 的更新方程从其定义推导而来：\n$$\nz_{i,k+1} = z_{i,k} + \\frac{I \\Delta t}{Q}\n$$\n为保持物理真实性，每次更新后将荷电状态约束在区间 $[0, 1]$ 内：\n$$\nz_{i,k+1} = \\max(0, \\min(1, z_{i,k+1}))\n$$\n\n极化电压 $v_{p,i,k}$ 的更新方程也以类似方式推导：\n$$\nv_{p,i,k+1} = v_{p,i,k} + \\Delta t \\left( -\\frac{1}{R_{t}C_{t}} v_{p,i,k} + \\frac{I}{C_t} \\right)\n$$\n整理各项可得最终更新规则：\n$$\nv_{p,i,k+1} = \\left( 1 - \\frac{\\Delta t}{R_{t}C_{t}} \\right) v_{p,i,k} + \\frac{I \\Delta t}{C_{t}}\n$$\n\n在确定了第 $k+1$ 步的状态后，可以使用同一步的状态值计算端电压 $V_{i,k+1}$：\n$$\nV_{i,k+1} = U(z_{i,k+1}) + I R_{s,i} + v_{p,i,k+1}\n$$\n\n### 3. 仿真算法与输出指标\n\n仿真在时间区间 $[0, T]$ 上执行。算法流程如下：\n\n1.  **初始化**：\n    -   为特定测试用例设置参数：$I, R_{s,1}, R_{s,2}, R_t, C_t, Q, T, \\Delta t, V_{\\text{th}}, \\varepsilon_z$。\n    -   将两个电芯的状态变量初始化为给定的初始条件 $t=0$：$z_{1,0}, z_{2,0}, v_{p,1,0}, v_{p,2,0}$。\n    -   初始化输出指标：`max_voltage_divergence = 0.0` 和 `false_positive_flag = 0`。\n    -   确定总仿真步数，$N = \\text{round}(T / \\Delta t)$。\n\n2.  **时间步进循环**：\n    -   对 $k$ 从 $0$ 到 $N$（含）执行一个循环，以覆盖从 $t=0$ 到 $t=T$ 的所有时间点。\n    -   在对应于时间 $t_k = k \\Delta t$ 的每一步 $k$：\n        a.  **计算输出**：使用当前状态值 ($z_{i,k}, v_{p,i,k}$) 计算端电压 $V_{1,k}$ 和 $V_{2,k}$。\n        b.  **更新指标**：\n            i.  计算绝对电压差异 $|V_{1,k} - V_{2,k}|$，如果该值大于当前最大值，则更新 `max_voltage_divergence`。\n            ii. 计算绝对荷电状态差异 $|z_{1,k} - z_{2,k}|$。\n            iii. 检查误报条件：如果 `false_positive_flag` 尚未设置，则评估是否 $|V_{1,k} - V_{2,k}| \\ge V_{\\text{th}}$ 且 $|z_{1,k} - z_{2,k}| \\le \\varepsilon_z$。如果两者都为真，则设置 `false_positive_flag = 1`。\n        c.  **存储最终差异**：如果 $k=N$（最后一步），则将有符号差异 $V_{1,N} - V_{2,N}$ 存储为 `final_voltage_difference`。\n        d.  **更新状态**：如果 $k  N$，则使用上面推导的离散时间更新方程计算下一个状态 $z_{i,k+1}$ 和 $v_{p,i,k+1}$。\n\n3.  **结果汇总**：\n    -   循环完成后，收集计算出的三个指标：`max_voltage_divergence`、`final_voltage_difference` 和 `false_positive_flag`。这三元组构成一个测试用例的结果。\n\n该算法将为四个指定的参数集分别实现，以生成最终输出。对于给定的测试用例，一个关键的观察是，由于两个电芯以相同的状态（$z_1(0)=z_2(0)$, $v_{p1}(0)=v_{p2}(0)$）开始，并且受到相同的动态影响（相同的 $I, Q, R_t, C_t$），它们的状态在整个仿真过程中将保持相同，即 $z_1(t) \\equiv z_2(t)$ 和 $v_{p1}(t) \\equiv v_{p2}(t)$。因此，电压差 $V_1(t) - V_2(t)$ 简化为 $I(R_{s,1} - R_{s,2})$，该值随时间保持不变。尽管如此，实现时仍将按指示执行完整的仿真。",
            "answer": "```python\nimport numpy as np\nimport math\n\n# Adherence to specified library versions (numpy==1.23.5) is assumed.\n# The `math.tanh` function is part of the standard library.\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations for all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path: moderate series resistance mismatch)\n        {\n            \"I\": 5.0, \"Rs1\": 0.010, \"Rs2\": 0.020,\n            \"Rt\": 0.015, \"Ct\": 2000.0,\n            \"Q\": 7200.0, \"T\": 100.0, \"dt\": 0.1,\n            \"z1_0\": 0.5, \"z2_0\": 0.5, \"vp1_0\": 0.0, \"vp2_0\": 0.0,\n            \"V_th\": 0.05, \"epsilon_z\": 0.001,\n        },\n        # Case 2 (boundary: identical series resistances)\n        {\n            \"I\": 5.0, \"Rs1\": 0.015, \"Rs2\": 0.015,\n            \"Rt\": 0.015, \"Ct\": 2000.0,\n            \"Q\": 7200.0, \"T\": 100.0, \"dt\": 0.1,\n            \"z1_0\": 0.5, \"z2_0\": 0.5, \"vp1_0\": 0.0, \"vp2_0\": 0.0,\n            \"V_th\": 0.05, \"epsilon_z\": 0.001,\n        },\n        # Case 3 (edge: larger mismatch and higher current)\n        {\n            \"I\": 10.0, \"Rs1\": 0.005, \"Rs2\": 0.030,\n            \"Rt\": 0.020, \"Ct\": 1200.0,\n            \"Q\": 7200.0, \"T\": 60.0, \"dt\": 0.05,\n            \"z1_0\": 0.6, \"z2_0\": 0.6, \"vp1_0\": 0.0, \"vp2_0\": 0.0,\n            \"V_th\": 0.05, \"epsilon_z\": 0.001,\n        },\n        # Case 4 (edge: zero current baseline)\n        {\n            \"I\": 0.0, \"Rs1\": 0.020, \"Rs2\": 0.040,\n            \"Rt\": 0.015, \"Ct\": 2000.0,\n            \"Q\": 7200.0, \"T\": 50.0, \"dt\": 0.1,\n            \"z1_0\": 0.5, \"z2_0\": 0.5, \"vp1_0\": 0.0, \"vp2_0\": 0.0,\n            \"V_th\": 0.05, \"epsilon_z\": 0.001,\n        },\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_simulation(params)\n        all_results.append(result)\n\n    # Format the final output as a string representing a list of lists.\n    # e.g., [[x1,y1,b1],[x2,y2,b2],...]\n    result_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in all_results]) + \"]\"\n    print(result_str)\n\ndef U_func(z):\n    \"\"\"\n    Computes the Open-Circuit Voltage (OCV) as a function of State of Charge (SoC).\n    U(z) = 3.0 + 1.2*z + 0.1*tanh((z - 0.5)/0.1)\n    \"\"\"\n    return 3.0 + 1.2 * z + 0.1 * math.tanh((z - 0.5) / 0.1)\n\ndef run_simulation(params):\n    \"\"\"\n    Performs a single simulation run for a given set of parameters.\n    \"\"\"\n    # Unpack parameters\n    I, Rs1, Rs2 = params[\"I\"], params[\"Rs1\"], params[\"Rs2\"]\n    Rt, Ct = params[\"Rt\"], params[\"Ct\"]\n    Q, T, dt = params[\"Q\"], params[\"T\"], params[\"dt\"]\n    V_th, epsilon_z = params[\"V_th\"], params[\"epsilon_z\"]\n\n    # Initialize state variables\n    z1, z2 = params[\"z1_0\"], params[\"z2_0\"]\n    vp1, vp2 = params[\"vp1_0\"], params[\"vp2_0\"]\n\n    # Initialize metrics\n    max_voltage_divergence = 0.0\n    final_voltage_difference = 0.0\n    false_positive_flag = 0\n\n    # Simulation setup\n    num_steps = int(round(T / dt))\n    \n    # Pre-calculate constants for the update equations\n    # v_p,k+1 = vp_alpha * v_p,k + vp_beta\n    vp_alpha = 1.0 - dt / (Rt * Ct)\n    vp_beta = (I * dt) / Ct\n    # z_k+1 = z_k + dz\n    dz = (I * dt) / Q\n\n    for k in range(num_steps + 1):\n        # 1. Calculate outputs at the current time step k\n        U1 = U_func(z1)\n        U2 = U_func(z2)\n        \n        V1 = U1 + I * Rs1 + vp1\n        V2 = U2 + I * Rs2 + vp2\n\n        # 2. Update metrics\n        current_voltage_divergence = abs(V1 - V2)\n        if current_voltage_divergence > max_voltage_divergence:\n            max_voltage_divergence = current_voltage_divergence\n\n        current_soc_difference = abs(z1 - z2)\n        if false_positive_flag == 0:\n            if current_voltage_divergence >= V_th and current_soc_difference = epsilon_z:\n                false_positive_flag = 1\n        \n        # 3. Store final difference at the end of the simulation\n        if k == num_steps:\n            final_voltage_difference = V1 - V2\n            break \n            \n        # 4. Update states for the next time step (k+1)\n        # Polarization voltage update\n        vp1 = vp_alpha * vp1 + vp_beta\n        vp2 = vp_alpha * vp2 + vp_beta\n\n        # State of charge update and clamping\n        z1 = z1 + dz\n        z2 = z2 + dz\n        z1 = max(0.0, min(1.0, z1))\n        z2 = max(0.0, min(1.0, z2))\n\n    return [max_voltage_divergence, final_voltage_difference, false_positive_flag]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "虽然仿真提供了对系统动力学的清晰认识，但现实世界的电池管理系统必须应对测量噪声和模型不确定性。本练习介绍了卡尔曼滤波器，这是一种强大的算法，可以从嘈杂的电压数据中估算电池的内部状态，例如充电状态（SoC）。通过实现该滤波器的核心里卡提递归（），您将探索滤波器的估计置信度如何演变，以及它如何智能地平衡其内部模型和传入测量值之间的信任度。",
            "id": "3898745",
            "problem": "您的任务是为一个在均衡系统下的单个锂离子电池进行建模，并推导计算卡尔曼滤波器 (KF) 增益和估计误差协方差演化所需的线性化测量模型。建模背景是电芯均衡系统，其中旁路电流用于调节各电芯的充电状态。目标是推导、实现和分析用于估计误差协方差的里卡提递归，并为在选定工作点附近线性化的含噪电压测量计算 KF 增益。\n\n从以下基本原理开始：\n\n- 电荷守恒：荷电状态 (SoC) 定义为 $z \\in [0,1]$，其演化遵循 $$\\frac{dq}{dt} = -I + b,$$ 其中 $q$ 是以库仑为单位的存储电荷，$I$ 是以安培为单位的电芯电流，$b$ 是以安培为单位的旁路均衡电流。标称容量 $C_{\\mathrm{nom}}$ 通过 $q = C_{\\mathrm{nom}} z$ 在存储电荷和 SoC 之间进行转换，因此 $$\\frac{dz}{dt} = \\frac{-I + b}{C_{\\mathrm{nom}}}.$$\n- 一阶阻容 (RC) 极化电压动态：极化电压 $v_p$ 满足 $$\\frac{dv_p}{dt} = -\\frac{1}{\\tau_p} v_p + \\frac{R_p}{\\tau_p} I,$$ 其中 $\\tau_p$ 是以秒为单位的极化时间常数，$R_p$ 是以欧姆为单位的极化电阻。\n- 开路电压 $U(z)$ 由 SoC 的单调函数建模。对于本问题，使用 $$U(z) = U_{\\mathrm{ref}} + \\alpha_U \\ln(z) - \\beta_U \\ln(1-z),$$ 其中 $U_{\\mathrm{ref}}$ 的单位是伏特，$\\alpha_U, \\beta_U$ 的单位也是伏特。这是一个经过充分检验的经验公式，用于描述在远离端点 $z=0$ 和 $z=1$ 的范围内，开路电压作为 SoC 的函数。\n\n在离散时间步 $k$ 测得的端电压 $V_k$ 为 $$V_k = U(z_k) + v_{p,k} + I_k R_s + w_k,$$ 其中 $R_s$ 是以欧姆为单位的串联电阻，$w_k$ 是零均值测量噪声，其方差为 $R$，单位是 $\\mathrm{V}^2$。\n\n使用采样周期 $\\Delta t$ 秒对动态方程进行离散化，其中对 SoC 使用标准的前向欧拉离散时间近似，对线性 $v_p$ 动态使用精确离散化：\n- $$z_{k+1} = z_k + \\frac{-I_k + b_k}{C_{\\mathrm{nom}}} \\Delta t + \\eta_{z,k},$$\n- $$v_{p,k+1} = \\mathrm{e}^{-\\Delta t/\\tau_p} v_{p,k} + R_p \\left(1-\\mathrm{e}^{-\\Delta t/\\tau_p}\\right) I_k + \\eta_{p,k},$$\n其中 $\\eta_{z,k}$ 和 $\\eta_{p,k}$ 分别是零均值过程噪声，其方差分别为 $Q_z$（对于 SoC 是无量纲的平方）和 $Q_{vp}$（单位是 $\\mathrm{V}^2$）。设状态为 $x_k = [z_k,\\ v_{p,k}]^\\top$。\n\n将测量值 $V_k$ 在工作点 $x^\\star = [z^\\star,\\ v_p^\\star]^\\top$ 附近对状态 $x_k$ 进行线性化。线性化的测量值为 $$V_k \\approx h(x^\\star) + H (x_k - x^\\star) + w_k,$$ 其雅可比矩阵为\n$$H = \\begin{bmatrix} \\frac{dU}{dz}(z^\\star)  1 \\end{bmatrix}, \\quad \\frac{dU}{dz}(z) = \\frac{\\alpha_U}{z} + \\frac{\\beta_U}{1-z}。$$\n线性化的状态转移雅可比矩阵为\n$$F = \\begin{bmatrix} 1  0 \\\\ 0  \\mathrm{e}^{-\\Delta t/\\tau_p} \\end{bmatrix}。$$\n假设过程噪声协方差为 $$Q = \\mathrm{diag}\\left(Q_z,\\ Q_{vp}\\right),$$ 测量噪声方差为 $$R。$$\n\n您的任务：\n\n1. 从第一性原理出发，为线性化系统推导离散时间协方差里卡提递归。清晰地解释 KF 增益如何依赖于先验协方差和测量雅可比矩阵。具体来说，从线性化模型和高斯噪声假设出发，推导预测协方差 $$P_k^- = F P_{k-1} F^\\top + Q,$$ 新息方差 $$S_k = H P_k^- H^\\top + R,$$ KF 增益 $$K_k = P_k^- H^\\top S_k^{-1},$$ 以及后验协方差 $$P_k = (I - K_k H) P_k^-,$$ 其中 $P_k$ 是时间 $k$ 的估计误差协方差，$I$ 是适当维度的单位矩阵，$P_0$ 是给定的初始协方差。\n2. 实现一个程序，该程序使用在指定工作点 $z^\\star$ 和参数下计算的线性化模型，为给定的测试用例计算在 $N$ 个步骤的固定时间范围内 KF 增益 $K_k$ 和后验协方差 $P_k$。程序不应使用任何外部测量；它应仅专注于协方差递归和 KF 增益计算。\n3. 在提供的测试套件中，分析估计误差协方差在不同噪声和动态条件下的演变，特别是 $R$（测量噪声方差）、$Q$（过程噪声协方差）、$\\tau_p$（极化时间常数）和 $\\Delta t$（采样周期）的作用。\n\n单位和数据：\n\n- 所有电压以 $\\mathrm{V}$ 表示，电流以 $\\mathrm{A}$ 表示，电阻以 $\\Omega$ 表示，时间以 $\\mathrm{s}$ 表示，容量以 $\\mathrm{A\\cdot h}$ 为单位用于制表，但在代码中通过 $C_{\\mathrm{nom}}[\\mathrm{C}] = C_{\\mathrm{nom}}[\\mathrm{A\\cdot h}] \\times 3600$ 转换为库仑。SoC $z$ 是无量纲的，必须作为小数处理（例如，$0.6$）。\n- 程序必须严格以浮点数计算和报告结果。\n\n测试套件：\n\n计算 $N$ 个步骤的 KF 增益序列和协方差演化，返回每个案例的最终（$k=N$）KF 增益向量条目和最终后验协方差对角线条目。使用以下三个测试案例：\n\n- 案例 A（标称情况）：\n  - $C_{\\mathrm{nom}} = 2.5\\ \\mathrm{A\\cdot h}$，$\\Delta t = 1.0\\ \\mathrm{s}$，$\\tau_p = 20.0\\ \\mathrm{s}$，$R_p = 0.015\\ \\Omega$，$R_s = 0.010\\ \\Omega$，\n  - $U_{\\mathrm{ref}} = 3.6\\ \\mathrm{V}$，$\\alpha_U = 0.12\\ \\mathrm{V}$，$\\beta_U = 0.12\\ \\mathrm{V}$，\n  - $z^\\star = 0.6$，$I_k = 2.0\\ \\mathrm{A}$（恒定），$b_k = 0.0\\ \\mathrm{A}$（恒定），\n  - $Q_z = 1.0\\times 10^{-9}$，$Q_{vp} = 1.0\\times 10^{-6}\\ \\mathrm{V}^2$，$R = 1.0\\times 10^{-4}\\ \\mathrm{V}^2$，\n  - $P_0 = \\mathrm{diag}(1.0\\times 10^{-4},\\ 1.0\\times 10^{-3})$，$N = 30$。\n- 案例 B（高测量噪声与均衡）：\n  - $C_{\\mathrm{nom}} = 2.5\\ \\mathrm{A\\cdot h}$，$\\Delta t = 1.0\\ \\mathrm{s}$，$\\tau_p = 10.0\\ \\mathrm{s}$，$R_p = 0.020\\ \\Omega$，$R_s = 0.020\\ \\Omega$，\n  - $U_{\\mathrm{ref}} = 3.6\\ \\mathrm{V}$，$\\alpha_U = 0.12\\ \\mathrm{V}$，$\\beta_U = 0.12\\ \\mathrm{V}$，\n  - $z^\\star = 0.5$，$I_k = 5.0\\ \\mathrm{A}$（恒定），$b_k = 0.5\\ \\mathrm{A}$（恒定），\n  - $Q_z = 5.0\\times 10^{-9}$，$Q_{vp} = 5.0\\times 10^{-6}\\ \\mathrm{V}^2$，$R = 4.0\\times 10^{-2}\\ \\mathrm{V}^2$，\n  - $P_0 = \\mathrm{diag}(5.0\\times 10^{-4},\\ 5.0\\times 10^{-3})$，$N = 30$。\n- 案例 C（低测量噪声，快速极化，更高电流和串联电阻）：\n  - $C_{\\mathrm{nom}} = 2.5\\ \\mathrm{A\\cdot h}$，$\\Delta t = 0.5\\ \\mathrm{s}$，$\\tau_p = 2.0\\ \\mathrm{s}$，$R_p = 0.025\\ \\Omega$，$R_s = 0.050\\ \\Omega$，\n  - $U_{\\mathrm{ref}} = 3.6\\ \\mathrm{V}$，$\\alpha_U = 0.12\\ \\mathrm{V}$，$\\beta_U = 0.12\\ \\mathrm{V}$，\n  - $z^\\star = 0.9$，$I_k = 10.0\\ \\mathrm{A}$（恒定），$b_k = 1.0\\ \\mathrm{A}$（恒定），\n  - $Q_z = 1.0\\times 10^{-8}$，$Q_{vp} = 1.0\\times 10^{-5}\\ \\mathrm{V}^2$，$R = 1.0\\times 10^{-6}\\ \\mathrm{V}^2$，\n  - $P_0 = \\mathrm{diag}(1.0\\times 10^{-3},\\ 1.0\\times 10^{-3})$，$N = 30$。\n\n请注意，$I_k R_s$ 不影响关于状态 $x_k$ 的雅可比矩阵 $H$，因此在线性化后的测量模型中它被视为一个已知的偏移量。KF 增益和协方差演化可以仅从 $F$、$Q$、$H$、$R$ 和 $P_0$ 计算得出。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是按顺序排列的四个浮点数列表 $[K_{z,N}, K_{vp,N}, P_{zz,N}, P_{vp\\,vp,N}]$，其中 $K_{z,N}$ 和 $K_{vp,N}$ 是最终 KF 增益向量 $K_N$ 的分量，$P_{zz,N}$ 和 $P_{vp\\,vp,N}$ 是最终后验协方差 $P_N$ 的对角线元素。总输出必须是这些按案例排列的列表的单个列表，例如 $[[\\dots],[\\dots],[\\dots]]$。",
            "solution": "在进行求解之前，对问题陈述的有效性进行评估。\n\n### 步骤 1：提取给定信息\n\n所提供的信息如下：\n\n**状态与动态方程：**\n- 荷电状态 (SoC) 定义：$z \\in [0,1]$。\n- 连续时间电荷动态：$\\frac{dq}{dt} = -I + b$，其中 $q = C_{\\mathrm{nom}} z$。\n- 连续时间 SoC 动态：$\\frac{dz}{dt} = \\frac{-I + b}{C_{\\mathrm{nom}}}$。\n- 连续时间极化电压动态：$\\frac{dv_p}{dt} = -\\frac{1}{\\tau_p} v_p + \\frac{R_p}{\\tau_p} I$。\n- 开路电压 (OCV) 模型：$U(z) = U_{\\mathrm{ref}} + \\alpha_U \\ln(z) - \\beta_U \\ln(1-z)$。\n\n**离散时间模型（采样周期 $\\Delta t$）：**\n- 状态向量：$x_k = [z_k, v_{p,k}]^\\top$。\n- 离散 SoC 动态：$z_{k+1} = z_k + \\frac{-I_k + b_k}{C_{\\mathrm{nom}}} \\Delta t + \\eta_{z,k}$。\n- 离散极化电压动态：$v_{p,k+1} = \\mathrm{e}^{-\\Delta t/\\tau_p} v_{p,k} + R_p \\left(1-\\mathrm{e}^{-\\Delta t/\\tau_p}\\right) I_k + \\eta_{p,k}$。\n- 测量模型：$V_k = U(z_k) + v_{p,k} + I_k R_s + w_k$。\n\n**线性化模型与噪声统计：**\n- 过程噪声源 $\\eta_{z,k}$ 和 $\\eta_{p,k}$ 为零均值，其方差分别为 $Q_z$ 和 $Q_{vp}$。\n- 测量噪声 $w_k$ 为零均值，其方差为 $R$。\n- 过程噪声协方差矩阵：$Q = \\mathrm{diag}(Q_z, Q_{vp})$。\n- 状态转移雅可比矩阵：$F = \\begin{bmatrix} 1  0 \\\\ 0  \\mathrm{e}^{-\\Delta t/\\tau_p} \\end{bmatrix}$。\n- 测量雅可比矩阵（在 $x^\\star = [z^\\star, v_p^\\star]^\\top$ 附近线性化）：$H = \\begin{bmatrix} \\frac{dU}{dz}(z^\\star)  1 \\end{bmatrix}$，其中 $\\frac{dU}{dz}(z) = \\frac{\\alpha_U}{z} + \\frac{\\beta_U}{1-z}$。\n\n**卡尔曼滤波器方程（待推导和使用）：**\n- 初始误差协方差：$P_0$。\n- 预测协方差：$P_k^- = F P_{k-1} F^\\top + Q$。\n- 新息方差：$S_k = H P_k^- H^\\top + R$。\n- 卡尔曼滤波器增益：$K_k = P_k^- H^\\top S_k^{-1}$。\n- 后验协方差：$P_k = (I - K_k H) P_k^-$。\n\n**单位转换与数据：**\n- 容量以 $\\mathrm{A \\cdot h}$ 给出，必须使用 $C_{\\mathrm{nom}}[\\mathrm{C}] = C_{\\mathrm{nom}}[\\mathrm{A\\cdot h}] \\times 3600$ 转换为库仑。\n- 递归的步数为 $N=30$。\n- 提供了三个测试案例（A、B、C），包含所有常数和初始条件的具体参数值。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n- **科学依据：** 该问题基于电气工程（RC 电路）、电化学（电池建模）和控制理论（卡尔曼滤波）的既定原理。电池模型是标准的一阶等效电路模型 (ECM)，应用卡尔曼滤波器进行状态估计是该领域的典型问题。OCV 模型是经过经验验证的。\n- **适定性：** 问题是适定的。它要求计算卡尔曼滤波器增益和协方差演化，这些都由所提供的里卡提递归方程和每个测试案例的完整参数集唯一确定。\n- **客观性：** 问题以精确、客观和数学的语言陈述。没有主观或基于意见的元素。\n- **完整性与一致性：** 问题是自洽的。为三个测试案例中的每一个都提供了所有必要的方程、参数、初始条件和常数。所提供的数据中没有矛盾。\n- **现实性与可行性：** 参数值对于锂离子电池是现实的。计算协方差演化是一项标准且可行的计算任务。\n\n### 步骤 3：结论与行动\n\n该问题是**有效的**。它是工程状态估计领域中一个定义明确的标准问题。将提供一个解决方案。\n\n### 解决方案\n\n任务是推导卡尔曼滤波器 (KF) 的协方差更新方程（离散时间里卡提递归），然后实现一个仿真，为线性化的电池模型计算 KF 增益和误差协方差的演化。\n\n**1. 协方差里卡提递归的推导**\n\n卡尔曼滤波器是用于处理高斯噪声的线性系统的最优估计器。它以一个两步循环进行操作：预测和更新。我们在此关注的是估计误差协方差的传播，它描述了我们状态估计的不确定性。设真实状态为 $x_k$，其估计为 $\\hat{x}_k$。估计误差为 $e_k = x_k - \\hat{x}_k$。误差协方差为 $P_k = E[e_k e_k^\\top]$，其中 $E[\\cdot]$ 是期望算子。\n\n滤波器使用两种估计：先验估计 $\\hat{x}_k^-$，在融合时刻 $k$ 的测量值之前计算；以及后验估计 $\\hat{x}_k$，在融合之后计算。相应的误差协方差是 $P_k^- = E[e_k^- (e_k^-)^\\top]$ 和 $P_k = E[e_k e_k^\\top]$。\n\n**预测步骤：**\n状态根据线性化模型 $x_k = F x_{k-1} + \\text{项} + v_{k-1}$ 演化，其中 $v_{k-1}$ 是协方差为 $Q$ 的过程噪声。时刻 $k$ 的先验状态估计由时刻 $k-1$ 的后验估计预测得出：\n$\\hat{x}_k^- = F \\hat{x}_{k-1} + \\text{已知项}$。\n先验误差 $e_k^- = x_k - \\hat{x}_k^-$ 则为：\n$$e_k^- = (F x_{k-1} + v_{k-1}) - F \\hat{x}_{k-1} = F (x_{k-1} - \\hat{x}_{k-1}) + v_{k-1} = F e_{k-1} + v_{k-1}$$\n该先验误差的协方差为 $P_k^- = E[e_k^- (e_k^-)^\\top]$：\n$$P_k^- = E[(F e_{k-1} + v_{k-1})(F e_{k-1} + v_{k-1})^\\top] = E[F e_{k-1} e_{k-1}^\\top F^\\top + F e_{k-1} v_{k-1}^\\top + v_{k-1} e_{k-1}^\\top F^\\top + v_{k-1} v_{k-1}^\\top]$$\n假设时刻 $k-1$ 的估计误差与时刻 $k-1$ 的过程噪声不相关（即 $E[e_{k-1} v_{k-1}^\\top] = 0$），这简化为：\n$$P_k^- = F E[e_{k-1} e_{k-1}^\\top] F^\\top + E[v_{k-1} v_{k-1}^\\top]$$\n这就得到了第一个里卡提方程，即**预测协方差更新**：\n$$P_k^- = F P_{k-1} F^\\top + Q$$\n\n**更新步骤：**\n时刻 $k$ 的测量由线性化模型 $V_k \\approx h(x^\\star) + H (x_k - x^\\star) + w_k$ 给出。我们定义测量残差，或**新息** $\\tilde{y}_k$，作为实际测量与预测测量之间的差异：\n$$\\tilde{y}_k = V_k - (h(x^\\star) + H(\\hat{x}_k^- - x^\\star))$$\n代入 $V_k$ 的表达式并使用 $x_k = \\hat{x}_k^- + e_k^-$：\n$$\\tilde{y}_k = (h(x^\\star) + H(x_k - x^\\star) + w_k) - (h(x^\\star) + H(\\hat{x}_k^- - x^\\star)) = H(x_k - \\hat{x}_k^-) + w_k = H e_k^- + w_k$$\n新息的方差 $S_k$ 是：\n$$S_k = E[\\tilde{y}_k \\tilde{y}_k^\\top] = E[(H e_k^- + w_k)(H e_k^- + w_k)^\\top]$$\n假设先验误差 $e_k^-$ 和测量噪声 $w_k$ 不相关，这变为：\n$$S_k = H E[e_k^- (e_k^-)^\\top] H^\\top + E[w_k w_k^\\top]$$\n这是**新息方差**方程：\n$$S_k = H P_k^- H^\\top + R$$\n后验状态估计是先验估计和新息的线性组合，由**卡尔曼增益** $K_k$ 加权：\n$$\\hat{x}_k = \\hat{x}_k^- + K_k \\tilde{y}_k$$\n增益 $K_k$ 的选择是为了最小化后验误差协方差 $P_k$ 的迹。最优增益由下式给出：\n$$K_k = E[e_k^- \\tilde{y}_k^\\top] S_k^{-1} = E[e_k^- (H e_k^- + w_k)^\\top] S_k^{-1} = E[e_k^- (e_k^-)^\\top] H^\\top S_k^{-1} = P_k^- H^\\top S_k^{-1}$$\n这是**卡尔曼增益**方程：\n$$K_k = P_k^- H^\\top S_k^{-1}$$\n增益 $K_k$ 在模型预测（嵌入在 $P_k^-$ 中）和新测量（不确定性为 $R$）之间实现了最优的信任平衡。如果先验不确定性 $P_k^-$ 高，增益将很大，从而更侧重于测量。相反，如果测量噪声 $R$ 高，增益将很小，滤波器将更信任其自身的预测。雅可比矩阵 $H$ 将状态不确定性映射到测量不确定性；如果一个状态对测量有很大影响（大的 $H$ 分量），滤波器可以更有效地校正该状态。\n\n最后，我们推导后验误差协方差 $P_k$。后验误差为：\n$$e_k = x_k - \\hat{x}_k = x_k - (\\hat{x}_k^- + K_k \\tilde{y}_k) = (x_k - \\hat{x}_k^-) - K_k (H e_k^- + w_k) = e_k^- - K_k H e_k^- - K_k w_k = (I - K_k H) e_k^- - K_k w_k$$\n协方差 $P_k = E[e_k e_k^\\top]$ 为：\n$$P_k = E[((I - K_k H) e_k^- - K_k w_k)((I - K_k H) e_k^- - K_k w_k)^\\top]$$\n展开并利用 $e_k^-$ 和 $w_k$ 之间的不相关性：\n$$P_k = (I - K_k H) E[e_k^- (e_k^-)^\\top] (I - K_k H)^\\top + K_k E[w_k w_k^\\top] K_k^\\top = (I - K_k H) P_k^- (I - K_k H)^\\top + K_k R K_k^\\top$$\n这是协方差更新的 Joseph 形式，以其数值稳定性而闻名。问题陈述中给出的形式 $P_k = (I - K_k H) P_k^-$，是假设 $K_k$ 是按上述最优方式计算的有效简化。这种简化使得更新在计算上更廉价，并且对于本问题是足够的。\n\n**2. 实现与分析**\n\n推导出的里卡提递归使我们能够在不需要实际测量数据的情况下，计算估计误差协方差 $P_k$ 和相应的卡尔曼增益 $K_k$ 的演化。该逻辑从初始协方差 $P_0$ 开始，对四个推导出的方程迭代 $N$ 步。\n\n**参数对协方差演化影响的分析：**\n- **测量噪声 ($R$)：** 案例 B 的特点是具有非常大的 $R=4.0\\times 10^{-2}\\ \\mathrm{V}^2$。高 $R$ 值表示测量不可靠。因此，卡尔曼增益 $K_k$ 将会很小，因为滤波器正确地降低了含噪测量的权重。这导致更高的稳态误差协方差 $P_k$，因为提取用于校正状态估计的信息较少。\n- **过程噪声 ($Q$)：** 这代表了模型动态的不确定性。更高的 $Q$（如案例 B 和 C 相对于 A）意味着状态预计会更多地偏离模型的预测。这会增加每一步的先验协方差 $P_k^-$，导致滤波器更依赖测量（更大的增益），并导致更高的稳态后验协方差 $P$。\n- **测量灵敏度 ($H$)：** 雅可比矩阵 $H$ 通过 $\\frac{dU}{dz}(z^\\star)$ 依赖于 $z^\\star$。在案例 C 中，$z^\\star = 0.9$，接近 OCV 曲线最陡峭的 SoC 范围末端。这导致一个很大的 $\\frac{dU}{dz}(z^\\star) \\approx 1.33\\ \\mathrm{V}$。大的数值使测量对 SoC ($z_k$) 的变化非常敏感。这种高灵敏度使得滤波器能够以高精度估计 $z_k$，从而导致协方差矩阵中的 $P_{zz,N}$ 分量要小得多，前提是测量是准确的（低 $R$，如案例 C 所示）。\n- **系统动态 ($F$)：** 矩阵 $F$ 受比率 $\\Delta t / \\tau_p$ 的影响。\n  - 在案例 A 中，$\\Delta t / \\tau_p = 1/20 = 0.05$，所以 $F_{22} = e^{-0.05} \\approx 0.951$。极化电压具有高度的持续性。\n  - 在案例 C 中，$\\tau_p$ 非常小（$\\tau_p=2.0\\ \\mathrm{s}$）且 $\\Delta t=0.5\\ \\mathrm{s}$。$\\Delta t / \\tau_p = 0.25$，所以 $F_{22} = e^{-0.25} \\approx 0.779$。这意味着极化电压更快地“忘记”其先前的状态。模型对 $v_{p,k}$ 的预测不太确定，在其他条件相同的情况下，这会倾向于增加误差方差 $P_{vp,vp}$。\n\n提供的代码将通过对每个测试案例的协方差矩阵和增益进行 $N=30$ 步的传播，来数值地展示这些效应。最终值将反映滤波器在指定条件下的稳态或近稳态不确定性行为。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Kalman Filter covariance analysis for all test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (nominal)\n        {\n            \"C_nom_Ah\": 2.5, \"delta_t\": 1.0, \"tau_p\": 20.0,\n            \"alpha_U\": 0.12, \"beta_U\": 0.12, \"z_star\": 0.6,\n            \"Q_z\": 1.0e-9, \"Q_vp\": 1.0e-6, \"R\": 1.0e-4,\n            \"P0_diag\": [1.0e-4, 1.0e-3], \"N\": 30\n        },\n        # Case B (high measurement noise with balancing)\n        {\n            \"C_nom_Ah\": 2.5, \"delta_t\": 1.0, \"tau_p\": 10.0,\n            \"alpha_U\": 0.12, \"beta_U\": 0.12, \"z_star\": 0.5,\n            \"Q_z\": 5.0e-9, \"Q_vp\": 5.0e-6, \"R\": 4.0e-2,\n            \"P0_diag\": [5.0e-4, 5.0e-3], \"N\": 30\n        },\n        # Case C (low measurement noise, fast polarization, higher current and series resistance)\n        {\n            \"C_nom_Ah\": 2.5, \"delta_t\": 0.5, \"tau_p\": 2.0,\n            \"alpha_U\": 0.12, \"beta_U\": 0.12, \"z_star\": 0.9,\n            \"Q_z\": 1.0e-8, \"Q_vp\": 1.0e-5, \"R\": 1.0e-6,\n            \"P0_diag\": [1.0e-3, 1.0e-3], \"N\": 30\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_covariance_recursion(params)\n        results.append(result)\n\n    # Format the results into the exact string representation required.\n    # The format is a list of lists, e.g., [[val1, val2], [val3, val4]]\n    # str(list) in Python produces the correct string for each inner list.\n    output_str = f\"[{','.join([str(res) for res in results])}]\"\n    print(output_str)\n\ndef run_covariance_recursion(params):\n    \"\"\"\n    Computes the KF gain and covariance evolution for a single test case.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the test case.\n\n    Returns:\n        list: A list of four floats [K_z_N, K_vp_N, P_zz_N, P_vp_vp_N].\n    \"\"\"\n    # Extract parameters\n    delta_t = params[\"delta_t\"]\n    tau_p = params[\"tau_p\"]\n    alpha_U = params[\"alpha_U\"]\n    beta_U = params[\"beta_U\"]\n    z_star = params[\"z_star\"]\n    Q_z = params[\"Q_z\"]\n    Q_vp = params[\"Q_vp\"]\n    R = params[\"R\"]\n    P0_diag = params[\"P0_diag\"]\n    N = params[\"N\"]\n\n    # Problem statement mentions C_nom, I_k, b_k but they are not needed for the\n    # covariance recursion itself, only for the state update, which is not part of this task.\n    # R_p, R_s, U_ref are also not needed for the gain/covariance calculation.\n\n    # Construct the constant matrices for the Kalman Filter\n    # State transition Jacobian F\n    F = np.array([\n        [1.0, 0.0],\n        [0.0, np.exp(-delta_t / tau_p)]\n    ])\n\n    # Measurement Jacobian H\n    dU_dz_star = alpha_U / z_star + beta_U / (1.0 - z_star)\n    H = np.array([[dU_dz_star, 1.0]])  # H is a 1x2 row vector\n\n    # Process noise covariance Q\n    Q = np.diag([Q_z, Q_vp])\n\n    # Initialize the posterior covariance matrix P\n    P = np.diag(P0_diag)\n    \n    K = np.zeros((2, 1)) # Initialize K for the case N=0\n\n    # Riccati recursion a fixed number of times\n    for _ in range(N):\n        # 1. Prediction step for covariance\n        P_minus = F @ P @ F.T + Q\n\n        # 2. Innovation variance (S is a 1x1 matrix, effectively a scalar)\n        S = H @ P_minus @ H.T + R\n        \n        # 3. Kalman gain K\n        # S is 1x1, so its inverse is just 1/S. H.T is 2x1. P_minus is 2x2.\n        K = (P_minus @ H.T) / S\n\n        # 4. Update step for covariance\n        # Using the simplified form P = (I - K H) P^-\n        P = (np.eye(2) - K @ H) @ P_minus\n    \n    # Extract final values at step N\n    K_z_N = K[0, 0]\n    K_vp_N = K[1, 0]\n    P_zz_N = P[0, 0]\n    P_vp_vp_N = P[1, 1]\n\n    return [K_z_N, K_vp_N, P_zz_N, P_vp_vp_N]\n\nsolve()\n```"
        },
        {
            "introduction": "在建模动力学和估算状态之后，最后一步是主动控制系统以实现我们的目标。本实践将重点转向最优控制，将电芯均衡问题描述为寻找最佳电流调度方案，以使所有电芯达到统一的充电状态。您将把这一挑战构建为一个线性规划问题（），这是一种强大的优化技术，它可以在尊重致动器的物理限制和整个系统约束的同时，计算出理想的均衡策略。",
            "id": "3898781",
            "problem": "考虑一个由多个电化学电池组成的串联电池组，其中仅施加组内均衡电流，没有净外部电荷注入。设电池 $i$ 的荷电状态 (SoC) 表示为 $z_{i}(t)$，其电荷容量表示为 $Q_{i}$（单位：库仑）。在仅均衡驱动下，电池中存储的电荷满足电荷守恒基本关系和库仑计数法：对于每个电池 $i$，存储的电荷 $q_{i}(t)$ 的演变关系为 $\\mathrm{d} q_{i}/\\mathrm{d} t = i_{i}(t)$，而 SoC 为 $z_{i}(t) = q_{i}(t)/Q_{i}$。因此，SoC 的动态特性为 $Q_{i}\\,\\mathrm{d} z_{i}/\\mathrm{d} t = i_{i}(t)$，或等效地为 $\\mathrm{d} z_{i}/\\mathrm{d} t = i_{i}(t)/Q_{i}$，其中 $i_{i}(t)$ 是施加到电池 $i$ 的均衡电流（当电荷流入电池时为正）。串联电池组中的电荷守恒施加了约束 $\\sum_{i=1}^{N} i_{i}(t) = 0$ 对所有时间 $t$ 成立（均衡期间无净外部电荷流动）。每个执行器服从饱和限制 $|\\lvert i_{i}(t) \\rvert \\le I_{\\max}|$。\n\n性能标准是在截止时间 $t_{f}$ 时，减小各最终 SoC 值围绕电荷加权平均 SoC $\\bar{z}$ 的离散度，$\\bar{z}$ 由总电荷守恒定义为 $\\bar{z} = \\left(\\sum_{i=1}^{N} Q_{i} z_{i}(0)\\right)\\big/\\left(\\sum_{i=1}^{N} Q_{i}\\right)$。控制目标是计算一个可行的均衡电流策略 $\\{ i_{i}(t) \\}_{i=1}^{N}$，以满足 $\\max_{i} \\lvert z_{i}(t_{f}) - \\bar{z} \\rvert \\le \\epsilon$，同时对于所有 $t \\in [0, t_{f}]$，$\\lvert i_{i}(t) \\rvert \\le I_{\\max}$ 和 $\\sum_{i=1}^{N} i_{i}(t) = 0$。\n\n您的任务是使用分段常数控制参数化 $i_{i}(t) = i_{i}[k]$（其中 $t \\in [k \\Delta t, (k+1) \\Delta t)$ 且 $k \\in \\{0, 1, \\dots, M-1\\}$），在 $M$ 个大小为 $\\Delta t = t_{f}/M$ 的相等时间步的离散时间内解决该问题。给定 $N$、容量 $\\{Q_{i}\\}_{i=1}^{N}$（单位：库仑）、初始 SoC $\\{ z_{i}(0) \\}_{i=1}^{N}$（无量纲）、电流限制 $I_{\\max}$（单位：安培）、截止时间 $t_{f}$（单位：秒）和 $M$，您必须计算使最坏情况下的最终偏差最小化的策略 $\\{ i_{i}[k] \\}$\n$$\n\\delta = \\max_{i \\in \\{1,\\dots,N\\}} \\left\\lvert z_{i}(t_{f}) - \\bar{z} \\right\\rvert,\n$$\n并受以下离散化动态模型约束\n$$\nz_{i}(t_{f}) = z_{i}(0) + \\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k],\n$$\n每步执行器饱和约束\n$$\n| i_{i}[k] | \\le I_{\\max} \\quad \\text{for all } i, k,\n$$\n以及每步电池组中性约束\n$$\n\\sum_{i=1}^{N} i_{i}[k] = 0 \\quad \\text{for all } k.\n$$\n\n您必须构建并求解一个以 $\\{ i_{i}[k] \\}$ 和标量 $\\delta \\ge 0$ 为决策变量的有限维优化问题，使得最小化的最优值 $\\delta^{\\star}$ 是在给定约束下可实现的最小最大最终 SoC 偏差。然后，对于每个测试用例，将优化后的 $\\delta^{\\star}$ 作为一个实数（无量纲 SoC）报告，四舍五入到六位小数。您无需输出策略 $\\{ i_{i}[k] \\}$；只需输出 $\\delta^{\\star}$。\n\n使用以下参数值测试套件，每个测试用例由一个元组 $\\left(N, \\{Q_{i}\\}_{i=1}^{N}, \\{ z_{i}(0) \\}_{i=1}^{N}, I_{\\max}, t_{f}, M\\right)$ 指定：\n\n- 测试用例 1 (一般情况):\n  - $N = 4$,\n  - $\\{Q_{i}\\} = [10800, 10800, 10800, 10800]$,\n  - $\\{ z_{i}(0) \\} = [0.6, 0.5, 0.7, 0.4]$,\n  - $I_{\\max} = 2.0$,\n  - $t_{f} = 1800$,\n  - $M = 12$.\n\n- 测试用例 2 (时间和执行器受限):\n  - $N = 3$,\n  - $\\{Q_{i}\\} = [9000, 9000, 9000]$,\n  - $\\{ z_{i}(0) \\} = [0.9, 0.6, 0.3]$,\n  - $I_{\\max} = 0.5$,\n  - $t_{f} = 1800$,\n  - $M = 9$.\n\n- 测试用例 3 (异构容量):\n  - $N = 3$,\n  - $\\{Q_{i}\\} = [10800, 7200, 14400]$,\n  - $\\{ z_{i}(0) \\} = [0.8, 0.5, 0.6]$,\n  - $I_{\\max} = 1.0$,\n  - $t_{f} = 1200$,\n  - $M = 8$.\n\n- 测试用例 4 (短截止时间，近乎静态):\n  - $N = 5$,\n  - $\\{Q_{i}\\} = [10000, 10000, 10000, 10000, 10000]$,\n  - $\\{ z_{i}(0) \\} = [0.52, 0.58, 0.54, 0.60, 0.51]$,\n  - $I_{\\max} = 0.1$,\n  - $t_{f} = 60$,\n  - $M = 6$.\n\n不涉及角度单位。物理单位已在上方指定。将最终最大偏差值作为无量纲 SoC 输出。\n\n最终输出格式要求：您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4]”）。每个结果必须是相应测试用例优化后的 $\\delta^{\\star}$，并四舍五入到六位小数。",
            "solution": "所提出的问题是针对电池单元均衡系统的离散时间最优控制问题。其目标是确定一个控制序列——即均衡电流 $\\{i_{i}[k]\\}$——以最小化在最终时间 $t_{f}$ 的最大状态偏差。系统状态是电池荷电状态 (SoC) 的向量 $\\{z_i\\}$。该问题可以严格地形式化并作为线性规划 (LP) 问题来求解。\n\n首先，我们定义系统参数和变量。该系统由 $N$ 个串联电池组成。对于每个电池 $i \\in \\{1, \\dots, N\\}$，我们给定其电荷容量 $Q_{i}$ 和初始 SoC $z_{i}(0)$。控制输入是均衡电流 $i_i(t)$，受最大幅值 $I_{\\max}$ 的约束。系统运行持续时间为 $t_f$。控制策略在 $M$ 个持续时间为 $\\Delta t = t_f/M$ 的区间上是分段常数。在时间间隔 $[k\\Delta t, (k+1)\\Delta t)$ 内，电池 $i$ 的电流表示为 $i_i[k]$。\n\n当使用前向欧拉法进行离散化时，电池 $i$ 的 SoC 动态特性由下式给出：\n$$\nz_{i}[k+1] = z_{i}[k] + \\frac{\\Delta t}{Q_i} i_i[k]\n$$\n将此递推关系从 $k=0$ 展开到 $k=M-1$，在时间 $t_f = M \\Delta t$ 的最终 SoC 为：\n$$\nz_{i}(t_{f}) = z_{i}(0) + \\sum_{k=0}^{M-1} \\frac{\\Delta t}{Q_{i}} i_{i}[k] = z_{i}(0) + \\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k]\n$$\n该方程将最终状态与初始状态和控制动作联系起来。\n\n控制目标是最小化最终 SoC 相对于其电荷加权平均值 $\\bar{z}$ 的最坏情况偏差。平均 SoC $\\bar{z}$ 是一个由初始条件和容量决定的常数，确保了电池组中总电荷的守恒：\n$$\n\\bar{z} = \\frac{\\sum_{i=1}^{N} Q_{i} z_{i}(0)}{\\sum_{i=1}^{N} Q_{i}}\n$$\n待最小化的量是标量 $\\delta$，定义为：\n$$\n\\delta = \\max_{i \\in \\{1, \\dots, N\\}} | z_i(t_f) - \\bar{z} |\n$$\n这是一个极小化极大优化问题。通过引入 $\\delta$ 作为决策变量并添加约束，可以将其转化为一个标准的最小化问题。在 $\\delta$ 定义的约束下最小化 $\\delta$ 等效于：\n$$\n\\text{minimize} \\quad \\delta\n$$\n约束条件为：\n$$\n|z_i(t_f) - \\bar{z}| \\le \\delta \\quad \\text{for all } i \\in \\{1, \\dots, N\\}\n$$\n这 $N$ 个不等式约束可以展开为 $2N$ 个线性不等式：\n$$\nz_i(t_f) - \\bar{z} \\le \\delta \\quad \\text{and} \\quad -(z_i(t_f) - \\bar{z}) \\le \\delta\n$$\n代入 $z_i(t_f)$ 的表达式，我们得到：\n$$\n\\left( z_{i}(0) + \\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] \\right) - \\bar{z} \\le \\delta \\quad \\implies \\quad \\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] - \\delta \\le \\bar{z} - z_i(0)\n$$\n$$\n-\\left( z_{i}(0) + \\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] \\right) + \\bar{z} \\le \\delta \\quad \\implies \\quad -\\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] - \\delta \\le z_i(0) - \\bar{z}\n$$\n\n该问题还受到对控制输入 $i_i[k]$ 的物理和操作约束：\n1.  执行器饱和：每个电流的幅值都受到限制。\n    $$\n    |i_i[k]| \\le I_{\\max} \\quad \\text{for all } i \\in \\{1, \\dots, N\\}, k \\in \\{0, \\dots, M-1\\}\n    $$\n    这等效于线性边界 $-I_{\\max} \\le i_i[k] \\le I_{\\max}$。\n\n2.  电池组中性：每个时间步的电流总和必须为零，反映了没有外部连接。\n    $$\n    \\sum_{i=1}^{N} i_i[k] = 0 \\quad \\text{for all } k \\in \\{0, \\dots, M-1\\}\n    $$\n\n这个完整的问题是一个线性规划 (LP)。决策变量是 $N \\times M$ 个电流 $\\{i_i[k]\\}$ 和标量变量 $\\delta$。所有约束都是线性不等式或等式，目标函数是线性的。\n\n为了进行计算求解，我们将其形式化为标准 LP 形式：\n$$\n\\begin{aligned}\n\\text{minimize} \\quad  \\mathbf{c}^T \\mathbf{x} \\\\\n\\text{subject to} \\quad  \\mathbf{A}_{\\text{ub}} \\mathbf{x} \\le \\mathbf{b}_{\\text{ub}} \\\\\n \\mathbf{A}_{\\text{eq}} \\mathbf{x} = \\mathbf{b}_{\\text{eq}} \\\\\n \\mathbf{l} \\le \\mathbf{x} \\le \\mathbf{u}\n\\end{aligned}\n$$\n决策向量 $\\mathbf{x}$ 是通过堆叠所有 $N \\times M$ 个电流和变量 $\\delta$ 构造的。为了实现方便，使用基于0的索引（$i \\in \\{0,\\dots,N-1\\}, k \\in \\{0,\\dots,M-1\\}$），一个方便的排序是：\n$$\n\\mathbf{x} = [i_0[0], \\dots, i_{N-1}[0], i_0[1], \\dots, i_{N-1}[1], \\dots, i_0[M-1], \\dots, i_{N-1}[M-1], \\delta]^T\n$$\n决策变量的总数是 $NM+1$。$i_i[k]$ 的索引是 $k \\cdot N + i$，$\\delta$ 的索引是 $NM$。\n\nLP 的组成部分如下：\n- **成本向量 $\\mathbf{c}$**：我们最小化 $\\delta$，因此 $\\mathbf{c}$ 是一个在与 $\\delta$ 对应的最后一个位置为 1，其余位置为 0 的向量。\n$$\n\\mathbf{c} = [0, \\dots, 0, 1]^T\n$$\n- **边界**：电流受 $[-I_{\\max}, I_{\\max}]$ 限制，$\\delta$ 是非负的（$\\delta \\ge 0$）。这些被指定为对 $\\mathbf{x}$ 的箱式约束。\n\n- **等式约束 $\\mathbf{A}_{\\text{eq}}, \\mathbf{b}_{\\text{eq}}$**：这些代表 $M$ 个电池组中性约束。对于每个时间步 $k \\in \\{0, \\dots, M-1\\}$，$\\sum_{i=0}^{N-1} i_i[k] = 0$。矩阵 $\\mathbf{A}_{\\text{eq}}$ 的维度是 $M \\times (NM+1)$。每一行 $k$ 对应于时间步 $k$ 的约束。对于变量 $i_0[k], \\dots, i_{N-1}[k]$，其条目为 1，其他为 0。向量 $\\mathbf{b}_{\\text{eq}}$ 是一个长度为 $M$ 的零向量。\n\n- **不等式约束 $\\mathbf{A}_{\\text{ub}}, \\mathbf{b}_{\\text{ub}}$**：这些代表来自极小化极大形式的 $2N$ 个约束。矩阵 $\\mathbf{A}_{\\text{ub}}$ 的维度为 $2N \\times (NM+1)$。对于每个电池 $i$，有两行。第 $2i$ 行对应于 $\\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] - \\delta \\le \\bar{z} - z_i(0)$。其条目对于变量 $i_i[k]$（对所有 $k$）为 $\\frac{\\Delta t}{Q_i}$，对于 $\\delta$ 为 $-1$，其他为 0。$\\mathbf{b}_{\\text{ub}}$ 中的对应值为 $\\bar{z} - z_i(0)$。第 $2i+1$ 行对应于 $-\\frac{\\Delta t}{Q_{i}} \\sum_{k=0}^{M-1} i_{i}[k] - \\delta \\le z_i(0) - \\bar{z}$。其条目对于变量 $i_i[k]$（对所有 $k$）为 $-\\frac{\\Delta t}{Q_i}$，对于 $\\delta$ 为 $-1$，其他为 0。$\\mathbf{b}_{\\text{ub}}$ 中的对应值为 $z_i(0) - \\bar{z}$。\n\n通过这种形式化，可以使用一个标准的 LP 求解器，例如 `scipy.optimize.linprog`，来为每个测试用例找到最优值 $\\delta^\\star$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of battery cell balancing optimization problems.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, Q_i, z_i(0), I_max, t_f, M)\n    test_cases = [\n        (4, np.array([10800, 10800, 10800, 10800]), np.array([0.6, 0.5, 0.7, 0.4]), 2.0, 1800, 12),\n        (3, np.array([9000, 9000, 9000]), np.array([0.9, 0.6, 0.3]), 0.5, 1800, 9),\n        (3, np.array([10800, 7200, 14400]), np.array([0.8, 0.5, 0.6]), 1.0, 1200, 8),\n        (5, np.array([10000, 10000, 10000, 10000, 10000]), np.array([0.52, 0.58, 0.54, 0.60, 0.51]), 0.1, 60, 6),\n    ]\n\n    results = []\n    for case in test_cases:\n        delta_star = solve_balancing_lp(case)\n        results.append(f\"{delta_star:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_balancing_lp(case):\n    \"\"\"\n    Formulates and solves the cell balancing problem as a Linear Program (LP).\n\n    Args:\n        case (tuple): A tuple containing the problem parameters\n                      (N, Q, z0, I_max, tf, M).\n\n    Returns:\n        float: The optimized minimum worst-case final deviation delta_star.\n    \"\"\"\n    N, Q, z0, I_max, tf, M = case\n\n    # -- 1. Calculate problem constants --\n    dt = tf / M\n    z_bar = np.sum(Q * z0) / np.sum(Q)\n\n    # -- 2. Define the LP structure --\n    # Decision variables x = [i_0[0], ..., i_{N-1}[0], ..., i_{N-1}[M-1], delta]^T\n    # Total number of variables is N*M currents + 1 delta\n    num_vars = N * M + 1\n    num_currents = N * M\n\n    # -- 3. Objective function: minimize delta --\n    # c vector is [0, 0, ..., 0, 1]\n    c = np.zeros(num_vars)\n    c[-1] = 1.0\n\n    # -- 4. Equality constraints: sum(i_i[k]) = 0 for each k --\n    # A_eq has M rows (one for each time step) and num_vars columns.\n    A_eq = np.zeros((M, num_vars))\n    for k in range(M):\n        start_col = k * N\n        end_col = start_col + N\n        A_eq[k, start_col:end_col] = 1.0\n    b_eq = np.zeros(M)\n    \n    # -- 5. Inequality constraints: |z_i(tf) - z_bar| = delta for each i --\n    # This gives 2*N constraints.\n    # A_ub has 2*N rows and num_vars columns.\n    A_ub = np.zeros((2 * N, num_vars))\n    b_ub = np.zeros(2 * N)\n    \n    for i in range(N):\n        # Constraint 1: (dt/Q_i) * sum(i_i[k]) - delta = z_bar - z0_i\n        # Constraint 2: -(dt/Q_i) * sum(i_i[k]) - delta = z0_i - z_bar\n\n        # Coefficients for sum(i_i[k])\n        current_coeffs = np.zeros(num_currents)\n        for k in range(M):\n            # Index of i_i[k] in the decision vector\n            current_idx = k * N + i\n            current_coeffs[current_idx] = dt / Q[i]\n            \n        # Row for constraint 1\n        A_ub[2 * i, :num_currents] = current_coeffs\n        A_ub[2 * i, -1] = -1.0  # Coefficient for delta\n        b_ub[2 * i] = z_bar - z0[i]\n        \n        # Row for constraint 2\n        A_ub[2 * i + 1, :num_currents] = -current_coeffs\n        A_ub[2 * i + 1, -1] = -1.0  # Coefficient for delta\n        b_ub[2 * i + 1] = z0[i] - z_bar\n\n    # -- 6. Bounds on decision variables --\n    # -I_max = i_i[k] = I_max\n    # delta >= 0\n    current_bounds = (-I_max, I_max)\n    delta_bounds = (0, None)\n    bounds = [current_bounds] * num_currents + [delta_bounds]\n\n    # -- 7. Solve the LP --\n    # The 'highs' method is generally robust and efficient for this type of problem.\n    result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n    if result.success:\n        # The optimal value of the objective function is delta_star\n        return result.fun\n    else:\n        # This should not happen for a well-posed problem.\n        raise RuntimeError(f\"LP solver failed: {result.message}\")\n\nsolve()\n```"
        }
    ]
}