{
    "hands_on_practices": [
        {
            "introduction": "Effective cell balancing begins with understanding the fundamental trade-offs between balancing speed and hardware capability. This first practice provides a foundational calculation to determine the minimum current required to correct a specified State of Charge (SOC) imbalance within a given timeframe. Mastering this core relationship  is the first step in sizing components for any passive balancing system and appreciating the physical limits of the balancing process.",
            "id": "3898804",
            "problem": "A Battery Management System (BMS) supervises passive shunt cell balancing in a series string of lithium-ion cells. Assume a single cell has rated capacity $Q$ measured in ampere-hours and is at rest during balancing, with no external charge or discharge applied. The state of charge (SOC) $z$ is defined as $z = q/Q$, where $q$ is the available charge within the cell. During balancing with a constant shunt current, the cell’s available charge decreases at a rate proportional to the balancing current and time. The worst-case SOC imbalance to be corrected for one cell, relative to the pack mean, is a positive fraction $\\Delta z_{\\max}$, and the balancing must reduce this SOC excess essentially to zero within a required time window $t_{\\text{req}}$. Neglect self-discharge, leakage, and any voltage dependence of the shunt current; treat the shunt as a constant-current sink equal to its rating $I_{\\text{bal}}$ over the interval $[0, t_{\\text{req}}]$, and assume the capacity $Q$ does not vary over this interval.\n\nGiven $Q = 8.0\\,\\mathrm{Ah}$, $\\Delta z_{\\max} = 0.10$, and $t_{\\text{req}} = 1.5\\,\\mathrm{h}$, determine the minimum balancing current rating $I_{\\text{bal}}$ required to guarantee correction of the worst-case SOC imbalance within the specified time. Express the final answer in amperes ($\\mathrm{A}$) and round your answer to four significant figures.",
            "solution": "The problem statement is first subjected to a rigorous validation process.\n\nThe givens are explicitly stated:\n- Rated cell capacity: $Q = 8.0\\,\\mathrm{Ah}$\n- Worst-case initial SOC excess: $\\Delta z_{\\max} = 0.10$\n- Required balancing time window: $t_{\\text{req}} = 1.5\\,\\mathrm{h}$\n- The state of charge $z$ is defined as the ratio of available charge $q$ to rated capacity $Q$: $z = q/Q$.\n- Balancing is performed by a constant shunt current $I_{\\text{bal}}$.\n- All other effects such as self-discharge, leakage, and voltage-dependent effects are to be neglected.\n\nThe problem is deemed valid. It is scientifically grounded in the fundamental principles of electrochemistry and circuit theory, specifically the relationship between charge, current, and time ($I = dq/dt$). It is well-posed, providing all necessary information ($Q$, $\\Delta z_{\\max}$, $t_{\\text{req}}$) to determine a unique value for the minimum required balancing current $I_{\\text{bal}}$. The problem is objective and uses clear, unambiguous terminology standard in the field of battery engineering. The provided numerical values are physically realistic for lithium-ion cells. The simplifying assumptions are explicitly stated and are standard for first-order engineering models.\n\nThe objective is to determine the minimum constant balancing current, $I_{\\text{bal}}$, required to remove a specified amount of excess charge within a given time frame.\n\nThe relationship between the state of charge $z$, the available charge $q$, and the rated capacity $Q$ is given by:\n$$z = \\frac{q}{Q}$$\nA change in the state of charge, $\\Delta z$, corresponds to a change in the stored charge, $\\Delta q$, according to:\n$$\\Delta z = \\frac{\\Delta q}{Q}$$\nThe problem states that the balancing process must correct a worst-case SOC imbalance of $\\Delta z_{\\max}$. This means an amount of charge, $\\Delta q_{\\text{excess}}$, corresponding to this SOC excess must be removed from the cell. Rearranging the previous equation, this excess charge is:\n$$\\Delta q_{\\text{excess}} = Q \\cdot \\Delta z_{\\max}$$\nThe balancing is achieved by drawing a constant current $I_{\\text{bal}}$ from the cell. The total charge removed by a constant current over a time interval is the product of the current and the time duration. The charge removed, $\\Delta q_{\\text{removed}}$, over the required time window $t_{\\text{req}}$ is:\n$$\\Delta q_{\\text{removed}} = I_{\\text{bal}} \\cdot t_{\\text{req}}$$\nTo guarantee that the balancing is completed within the specified time, the amount of charge removed must be at least equal to the excess charge that needs to be dissipated:\n$$\\Delta q_{\\text{removed}} \\geq \\Delta q_{\\text{excess}}$$\nSubstituting the expressions for $\\Delta q_{\\text{removed}}$ and $\\Delta q_{\\text{excess}}$:\n$$I_{\\text{bal}} \\cdot t_{\\text{req}} \\geq Q \\cdot \\Delta z_{\\max}$$\nThe problem asks for the minimum balancing current required. This minimum value corresponds to the equality condition:\n$$I_{\\text{bal, min}} \\cdot t_{\\text{req}} = Q \\cdot \\Delta z_{\\max}$$\nSolving for $I_{\\text{bal, min}}$:\n$$I_{\\text{bal, min}} = \\frac{Q \\cdot \\Delta z_{\\max}}{t_{\\text{req}}}$$\nNow, we substitute the provided numerical values into this expression. The rated capacity is $Q = 8.0\\,\\mathrm{Ah}$, the SOC imbalance is $\\Delta z_{\\max} = 0.10$ (a dimensionless quantity), and the required time is $t_{\\text{req}} = 1.5\\,\\mathrm{h}$.\n$$I_{\\text{bal, min}} = \\frac{(8.0\\,\\mathrm{Ah}) \\cdot (0.10)}{1.5\\,\\mathrm{h}}$$\nThe product in the numerator is:\n$$(8.0\\,\\mathrm{Ah}) \\cdot (0.10) = 0.80\\,\\mathrm{Ah}$$\nSo the expression for the current becomes:\n$$I_{\\text{bal, min}} = \\frac{0.80\\,\\mathrm{Ah}}{1.5\\,\\mathrm{h}}$$\nThe units of ampere-hours ($\\mathrm{Ah}$) divided by hours ($\\mathrm{h}$) correctly yield amperes ($\\mathrm{A}$), the unit of current.\n$$I_{\\text{bal, min}} = \\frac{0.80}{1.5}\\,\\mathrm{A} = \\frac{8}{15}\\,\\mathrm{A}$$\nPerforming the division gives:\n$$I_{\\text{bal, min}} \\approx 0.533333...\\,\\mathrm{A}$$\nThe problem requires the final answer to be rounded to four significant figures.\n$$I_{\\text{bal, min}} \\approx 0.5333\\,\\mathrm{A}$$\nThis is the minimum balancing current rating required to meet the specified performance criteria.",
            "answer": "$$\\boxed{0.5333}$$"
        },
        {
            "introduction": "While simple calculations provide a starting point, real-world battery cells exhibit complex dynamic behaviors. This exercise moves beyond static assumptions by using a first-order Thevenin equivalent circuit model to simulate a two-cell pack. By exploring how differences in internal resistance affect terminal voltage during charging , you will see firsthand why voltage alone can be a misleading indicator of SOC imbalance, motivating the need for more advanced estimation models.",
            "id": "3898809",
            "problem": "Consider a two-cell lithium-ion pack modeled by a first-order Thevenin equivalent circuit, where both cells receive the same pack current. Adopt the sign convention that a positive current $I$ corresponds to charging. Each cell $i \\in \\{1,2\\}$ is modeled as an open-circuit voltage source with open-circuit voltage $U(z_{i})$ that depends on the state of charge $z_{i}$, a series resistance $R_{s,i}$, and a single polarization branch that produces a transient polarization voltage $v_{p,i}$. The measured terminal voltage of cell $i$ is\n$$\nV_{i}(t) = U(z_{i}(t)) + I\\,R_{s,i} + v_{p,i}(t).\n$$\nThis model is tractable yet scientifically realistic for inspecting transient voltage divergence that can falsely indicate imbalance when $R_{s,1} \\neq R_{s,2}$ even if $z_{1}(t) \\approx z_{2}(t)$.\n\nUse the following fundamental bases:\n1. The definition of state of charge for a cell of capacity $Q$ (in coulombs) under charging current $I$ is \n$$\n\\frac{dz_{i}}{dt} = \\frac{I}{Q},\n$$\nwith $z_{i}\\in[0,1]$ and $Q$ constant.\n2. For the polarization branch, apply the Thevenin resistor-capacitor dynamics derived from Kirchhoff’s Current Law (KCL). For a branch composed of resistor $R_{t}$ and capacitor $C_{t}$, the polarization voltage $v_{p,i}$ obeys\n$$\n\\frac{dv_{p,i}}{dt} = -\\frac{1}{R_{t}C_{t}}\\,v_{p,i} + \\frac{I}{C_{t}}.\n$$\n3. A smooth and physically plausible open-circuit voltage function $U(z)$ for a lithium-ion cell can be approximated by\n$$\nU(z) = 3.0 + 1.2\\,z + 0.1\\,\\tanh\\!\\left(\\frac{z - 0.5}{0.1}\\right),\n$$\nwhich produces a voltage range near typical values for $z \\in [0,1]$.\n\nStarting from these bases, derive the discrete-time update equations necessary to simulate the two-cell pack over a finite horizon using a uniform time step $\\Delta t$ and explicit time-stepping. You must implement a program that:\n- Initializes both cells with given $z_{i}(0)$ and $v_{p,i}(0)$.\n- Evolves $z_{i}(t)$, $v_{p,i}(t)$, and computes $V_{i}(t)$ using the above relationships.\n- Computes, for each specified parameter set, the following three quantities:\n  1. The maximum absolute terminal voltage divergence over the simulation window,\n     $$\n     \\max_{t\\in[0,T]} \\left| V_{1}(t) - V_{2}(t) \\right| \\quad \\text{in volts}.\n     $$\n  2. The final signed terminal voltage difference,\n     $$\n     V_{1}(T) - V_{2}(T) \\quad \\text{in volts}.\n     $$\n  3. A false-positive flag expressed as an integer ($0$ or $1$): output $1$ if there exists any time within $[0,T]$ at which $\\left|V_{1}(t)-V_{2}(t)\\right| \\geq V_{\\text{th}}$ while simultaneously $\\left|z_{1}(t)-z_{2}(t)\\right| \\leq \\varepsilon_{z}$, and output $0$ otherwise. This represents a naive voltage-threshold-based imbalance detector falsely flagging imbalance when the state of charge difference is small.\n\nUse the following explicit units and conventions:\n- Current $I$ in amperes ($\\mathrm{A}$).\n- Resistances $R_{s,i}$ and $R_{t}$ in ohms ($\\Omega$).\n- Capacitance $C_{t}$ in farads ($\\mathrm{F}$).\n- Capacity $Q$ in coulombs ($\\mathrm{C}$).\n- Time $T$ and time step $\\Delta t$ in seconds ($\\mathrm{s}$).\n- Voltages in volts ($\\mathrm{V}$).\n- State of charge $z$ is dimensionless.\n\nDiscretize the continuous-time dynamics with a uniform time step $\\Delta t$ using an explicit method that is stable for the given parameters, and clamp $z_{i}(t)$ to the interval $[0,1]$ during simulation to maintain physical plausibility.\n\nTest Suite:\nImplement your program to run the following four parameter sets. For each case, produce the three outputs described above, in the specified units and format.\n\nCase $1$ (happy path: moderate series resistance mismatch):\n- $I = 5\\ \\mathrm{A}$, $R_{s,1} = 0.010\\ \\Omega$, $R_{s,2} = 0.020\\ \\Omega$,\n- $R_{t} = 0.015\\ \\Omega$, $C_{t} = 2000\\ \\mathrm{F}$,\n- $Q = 7200\\ \\mathrm{C}$, $T = 100\\ \\mathrm{s}$, $\\Delta t = 0.1\\ \\mathrm{s}$,\n- $z_{1}(0) = 0.5$, $z_{2}(0) = 0.5$, $v_{p,1}(0) = 0.0\\ \\mathrm{V}$, $v_{p,2}(0) = 0.0\\ \\mathrm{V}$,\n- Voltage threshold $V_{\\text{th}} = 0.05\\ \\mathrm{V}$, state of charge tolerance $\\varepsilon_{z} = 0.001$.\n\nCase $2$ (boundary: identical series resistances):\n- $I = 5\\ \\mathrm{A}$, $R_{s,1} = 0.015\\ \\Omega$, $R_{s,2} = 0.015\\ \\Omega$,\n- $R_{t} = 0.015\\ \\Omega$, $C_{t} = 2000\\ \\mathrm{F}$,\n- $Q = 7200\\ \\mathrm{C}$, $T = 100\\ \\mathrm{s}$, $\\Delta t = 0.1\\ \\mathrm{s}$,\n- $z_{1}(0) = 0.5$, $z_{2}(0) = 0.5$, $v_{p,1}(0) = 0.0\\ \\mathrm{V}$, $v_{p,2}(0) = 0.0\\ \\mathrm{V}$,\n- $V_{\\text{th}} = 0.05\\ \\mathrm{V}$, $\\varepsilon_{z} = 0.001$.\n\nCase $3$ (edge: larger mismatch and higher current with different time constants):\n- $I = 10\\ \\mathrm{A}$, $R_{s,1} = 0.005\\ \\Omega$, $R_{s,2} = 0.030\\ \\Omega$,\n- $R_{t} = 0.020\\ \\Omega$, $C_{t} = 1200\\ \\mathrm{F}$,\n- $Q = 7200\\ \\mathrm{C}$, $T = 60\\ \\mathrm{s}$, $\\Delta t = 0.05\\ \\mathrm{s}$,\n- $z_{1}(0) = 0.6$, $z_{2}(0) = 0.6$, $v_{p,1}(0) = 0.0\\ \\mathrm{V}$, $v_{p,2}(0) = 0.0\\ \\mathrm{V}$,\n- $V_{\\text{th}} = 0.05\\ \\mathrm{V}$, $\\varepsilon_{z} = 0.001$.\n\nCase $4$ (edge: zero current baseline):\n- $I = 0\\ \\mathrm{A}$, $R_{s,1} = 0.020\\ \\Omega$, $R_{s,2} = 0.040\\ \\Omega$,\n- $R_{t} = 0.015\\ \\Omega$, $C_{t} = 2000\\ \\mathrm{F}$,\n- $Q = 7200\\ \\mathrm{C}$, $T = 50\\ \\mathrm{s}$, $\\Delta t = 0.1\\ \\mathrm{s}$,\n- $z_{1}(0) = 0.5$, $z_{2}(0) = 0.5$, $v_{p,1}(0) = 0.0\\ \\mathrm{V}$, $v_{p,2}(0) = 0.0\\ \\mathrm{V}$,\n- $V_{\\text{th}} = 0.05\\ \\mathrm{V}$, $\\varepsilon_{z} = 0.001$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets. Each test case’s result must itself be a list of the form\n$$\n\\left[\\max_{t} \\left| V_{1}(t) - V_{2}(t) \\right|,\\; V_{1}(T) - V_{2}(T),\\; \\text{flag}\\right],\n$$\nwhere the first two entries are floats in volts, and the third entry is an integer ($0$ or $1$). For example, your output should look like\n$$\n[\\,[x_{1},y_{1},b_{1}],\\,[x_{2},y_{2},b_{2}],\\,[x_{3},y_{3},b_{3}],\\,[x_{4},y_{4},b_{4}]\\,],\n$$\nwith all numerical values computed by your simulation in the specified units.",
            "solution": "The user-provided problem is valid. It is scientifically grounded in established battery modeling techniques (first-order Thevenin equivalent circuit model), well-posed with all necessary parameters and initial conditions for a unique solution, and objective in its formulation and requirements. The problem asks for the development and implementation of a discrete-time simulation for a two-cell battery pack to analyze voltage divergence under specific conditions.\n\nThe solution proceeds by first deriving the discrete-time update equations from the provided continuous-time model and then outlining the simulation algorithm designed to compute the required metrics.\n\n### 1. Continuous-Time Model Formulation\n\nThe system consists of two cells, each described by a state vector comprising its state of charge (SoC), $z_i(t)$, and its polarization voltage, $v_{p,i}(t)$. The dynamics of the system are governed by a set of ordinary differential equations (ODEs).\n\nThe state of charge $z_i(t)$ for cell $i$ evolves according to the principle of Coulomb counting:\n$$\n\\frac{dz_{i}}{dt} = \\frac{I}{Q}\n$$\nwhere $I$ is the pack current (positive for charging) and $Q$ is the total capacity of the cell in Coulombs.\n\nThe polarization voltage $v_{p,i}(t)$ captures the transient response of the cell and is modeled by the dynamics of a parallel resistor-capacitor (RC) circuit:\n$$\n\\frac{dv_{p,i}}{dt} = -\\frac{1}{R_{t}C_{t}}\\,v_{p,i}(t) + \\frac{I}{C_{t}}\n$$\nwhere $R_t$ and $C_t$ are the resistance and capacitance of the polarization branch, respectively. It is noted that these parameters are identical for both cells.\n\nThe terminal voltage of each cell, $V_i(t)$, is the algebraic sum of the open-circuit voltage (OCV), the voltage drop across the series resistance, and the polarization voltage:\n$$\nV_{i}(t) = U(z_{i}(t)) + I\\,R_{s,i} + v_{p,i}(t)\n$$\nThe OCV, $U(z)$, is a nonlinear function of the state of charge, given by:\n$$\nU(z) = 3.0 + 1.2\\,z + 0.1\\,\\tanh\\!\\left(\\frac{z - 0.5}{0.1}\\right)\n$$\n\n### 2. Discretization of the Model\n\nTo simulate the system numerically, we discretize the continuous-time ODEs using the explicit (forward) Euler method with a uniform time step $\\Delta t$. Let the subscript $k$ denote the evaluation of a variable at time $t_k = k \\Delta t$.\n\nThe update equation for the state of charge $z_{i,k}$ is derived from its definition:\n$$\nz_{i,k+1} = z_{i,k} + \\frac{I \\Delta t}{Q}\n$$\nTo maintain physical realism, the state of charge is clamped to the interval $[0, 1]$ after each update:\n$$\nz_{i,k+1} = \\max(0, \\min(1, z_{i,k+1}))\n$$\n\nThe update equation for the polarization voltage $v_{p,i,k}$ is similarly derived:\n$$\nv_{p,i,k+1} = v_{p,i,k} + \\Delta t \\left( -\\frac{1}{R_{t}C_{t}} v_{p,i,k} + \\frac{I}{C_t} \\right)\n$$\nRearranging the terms yields the final update rule:\n$$\nv_{p,i,k+1} = \\left( 1 - \\frac{\\Delta t}{R_{t}C_{t}} \\right) v_{p,i,k} + \\frac{I \\Delta t}{C_{t}}\n$$\n\nWith the states at step $k+1$ determined, the terminal voltage $V_{i,k+1}$ can be calculated using the values of the states at that same step:\n$$\nV_{i,k+1} = U(z_{i,k+1}) + I R_{s,i} + v_{p,i,k+1}\n$$\n\n### 3. Simulation Algorithm and Output Metrics\n\nThe simulation is performed over the time interval $[0, T]$. The algorithm proceeds as follows:\n\n1.  **Initialization**:\n    -   Set the parameters for the specific test case: $I, R_{s,1}, R_{s,2}, R_t, C_t, Q, T, \\Delta t, V_{\\text{th}}, \\varepsilon_z$.\n    -   Initialize the state variables for both cells to their given initial conditions at $t=0$: $z_{1,0}, z_{2,0}, v_{p,1,0}, v_{p,2,0}$.\n    -   Initialize the output metrics: `max_voltage_divergence = 0.0` and `false_positive_flag = 0`.\n    -   Determine the total number of simulation steps, $N = \\text{round}(T / \\Delta t)$.\n\n2.  **Time-Stepping Loop**:\n    -   Execute a loop for $k$ from $0$ to $N$ (inclusive) to cover all time points from $t=0$ to $t=T$.\n    -   At each step $k$, corresponding to time $t_k = k \\Delta t$:\n        a.  **Calculate Outputs**: Compute the terminal voltages $V_{1,k}$ and $V_{2,k}$ using the current state values ($z_{i,k}, v_{p,i,k}$).\n        b.  **Update Metrics**:\n            i.  Calculate the absolute voltage divergence $|V_{1,k} - V_{2,k}|$ and update `max_voltage_divergence` if this value is greater than the current maximum.\n            ii. Calculate the absolute SoC difference $|z_{1,k} - z_{2,k}|$.\n            iii. Check for the false-positive condition: if `false_positive_flag` is not yet set, evaluate if $|V_{1,k} - V_{2,k}| \\ge V_{\\text{th}}$ and $|z_{1,k} - z_{2,k}| \\le \\varepsilon_z$. If both are true, set `false_positive_flag = 1`.\n        c.  **Store Final Difference**: If $k=N$ (the final step), store the signed difference $V_{1,N} - V_{2,N}$ as `final_voltage_difference`.\n        d.  **Update States**: If $k < N$, compute the next states $z_{i,k+1}$ and $v_{p,i,k+1}$ using the discrete-time update equations derived above.\n\n3.  **Result Aggregation**:\n    -   After the loop completes, collect the three computed metrics: `max_voltage_divergence`, `final_voltage_difference`, and `false_positive_flag`. This triplet constitutes the result for one test case.\n\nThis algorithm is implemented for each of the four specified parameter sets to generate the final output. A crucial observation for the given test cases is that since both cells start with identical states ($z_1(0)=z_2(0)$, $v_{p1}(0)=v_{p2}(0)$) and are subjected to identical dynamics (same $I, Q, R_t, C_t$), their states will remain identical throughout the simulation, i.e., $z_1(t) \\equiv z_2(t)$ and $v_{p1}(t) \\equiv v_{p2}(t)$. Consequently, the voltage difference $V_1(t) - V_2(t)$ simplifies to $I(R_{s,1} - R_{s,2})$, which is constant over time. The implementation will nevertheless perform the full simulation as instructed.",
            "answer": "```python\nimport numpy as np\nimport math\n\n# Adherence to specified library versions (numpy==1.23.5) is assumed.\n# The `math.tanh` function is part of the standard library.\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations for all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path: moderate series resistance mismatch)\n        {\n            \"I\": 5.0, \"Rs1\": 0.010, \"Rs2\": 0.020,\n            \"Rt\": 0.015, \"Ct\": 2000.0,\n            \"Q\": 7200.0, \"T\": 100.0, \"dt\": 0.1,\n            \"z1_0\": 0.5, \"z2_0\": 0.5, \"vp1_0\": 0.0, \"vp2_0\": 0.0,\n            \"V_th\": 0.05, \"epsilon_z\": 0.001,\n        },\n        # Case 2 (boundary: identical series resistances)\n        {\n            \"I\": 5.0, \"Rs1\": 0.015, \"Rs2\": 0.015,\n            \"Rt\": 0.015, \"Ct\": 2000.0,\n            \"Q\": 7200.0, \"T\": 100.0, \"dt\": 0.1,\n            \"z1_0\": 0.5, \"z2_0\": 0.5, \"vp1_0\": 0.0, \"vp2_0\": 0.0,\n            \"V_th\": 0.05, \"epsilon_z\": 0.001,\n        },\n        # Case 3 (edge: larger mismatch and higher current)\n        {\n            \"I\": 10.0, \"Rs1\": 0.005, \"Rs2\": 0.030,\n            \"Rt\": 0.020, \"Ct\": 1200.0,\n            \"Q\": 7200.0, \"T\": 60.0, \"dt\": 0.05,\n            \"z1_0\": 0.6, \"z2_0\": 0.6, \"vp1_0\": 0.0, \"vp2_0\": 0.0,\n            \"V_th\": 0.05, \"epsilon_z\": 0.001,\n        },\n        # Case 4 (edge: zero current baseline)\n        {\n            \"I\": 0.0, \"Rs1\": 0.020, \"Rs2\": 0.040,\n            \"Rt\": 0.015, \"Ct\": 2000.0,\n            \"Q\": 7200.0, \"T\": 50.0, \"dt\": 0.1,\n            \"z1_0\": 0.5, \"z2_0\": 0.5, \"vp1_0\": 0.0, \"vp2_0\": 0.0,\n            \"V_th\": 0.05, \"epsilon_z\": 0.001,\n        },\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_simulation(params)\n        all_results.append(result)\n\n    # Format the final output as a string representing a list of lists.\n    # e.g., [[x1,y1,b1],[x2,y2,b2],...]\n    result_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in all_results]) + \"]\"\n    print(result_str)\n\ndef U_func(z):\n    \"\"\"\n    Computes the Open-Circuit Voltage (OCV) as a function of State of Charge (SoC).\n    U(z) = 3.0 + 1.2*z + 0.1*tanh((z - 0.5)/0.1)\n    \"\"\"\n    return 3.0 + 1.2 * z + 0.1 * math.tanh((z - 0.5) / 0.1)\n\ndef run_simulation(params):\n    \"\"\"\n    Performs a single simulation run for a given set of parameters.\n    \"\"\"\n    # Unpack parameters\n    I, Rs1, Rs2 = params[\"I\"], params[\"Rs1\"], params[\"Rs2\"]\n    Rt, Ct = params[\"Rt\"], params[\"Ct\"]\n    Q, T, dt = params[\"Q\"], params[\"T\"], params[\"dt\"]\n    V_th, epsilon_z = params[\"V_th\"], params[\"epsilon_z\"]\n\n    # Initialize state variables\n    z1, z2 = params[\"z1_0\"], params[\"z2_0\"]\n    vp1, vp2 = params[\"vp1_0\"], params[\"vp2_0\"]\n\n    # Initialize metrics\n    max_voltage_divergence = 0.0\n    final_voltage_difference = 0.0\n    false_positive_flag = 0\n\n    # Simulation setup\n    num_steps = int(round(T / dt))\n    \n    # Pre-calculate constants for the update equations\n    # v_p,k+1 = vp_alpha * v_p,k + vp_beta\n    vp_alpha = 1.0 - dt / (Rt * Ct)\n    vp_beta = (I * dt) / Ct\n    # z_k+1 = z_k + dz\n    dz = (I * dt) / Q\n\n    for k in range(num_steps + 1):\n        # 1. Calculate outputs at the current time step k\n        U1 = U_func(z1)\n        U2 = U_func(z2)\n        \n        V1 = U1 + I * Rs1 + vp1\n        V2 = U2 + I * Rs2 + vp2\n\n        # 2. Update metrics\n        current_voltage_divergence = abs(V1 - V2)\n        if current_voltage_divergence > max_voltage_divergence:\n            max_voltage_divergence = current_voltage_divergence\n\n        current_soc_difference = abs(z1 - z2)\n        if false_positive_flag == 0:\n            if current_voltage_divergence >= V_th and current_soc_difference = epsilon_z:\n                false_positive_flag = 1\n        \n        # 3. Store final difference at the end of the simulation\n        if k == num_steps:\n            final_voltage_difference = V1 - V2\n            break \n            \n        # 4. Update states for the next time step (k+1)\n        # Polarization voltage update\n        vp1 = vp_alpha * vp1 + vp_beta\n        vp2 = vp_alpha * vp2 + vp_beta\n\n        # State of charge update and clamping\n        z1 = z1 + dz\n        z2 = z2 + dz\n        z1 = max(0.0, min(1.0, z1))\n        z2 = max(0.0, min(1.0, z2))\n\n    return [max_voltage_divergence, final_voltage_difference, false_positive_flag]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Having established that direct voltage measurement is insufficient, we now turn to a powerful technique for estimating a cell's internal states: the Kalman Filter. This practice challenges you to model the uncertainty in both the system dynamics and the measurements to compute the filter's behavior. By implementing the core Riccati recursion equations , you will understand how the filter gains and error covariance evolve, providing a robust foundation for designing state-of-the-art SOC estimators.",
            "id": "3898745",
            "problem": "You are tasked with modeling a single lithium-ion cell under a balancing system and deriving the linearized measurement model needed to compute the Kalman Filter (KF) gains and the estimation error covariance evolution. The modeling context is the cell balancing system, where the bypass current is used to regulate the charge state across cells. The goal is to derive, implement, and analyze the Riccati recursion for the estimation error covariance and compute the KF gains for a noisy voltage measurement linearized around a chosen operating point.\n\nBegin from the following fundamental base:\n\n- Conservation of electric charge: the State of Charge (SoC) is defined as $z \\in [0,1]$ and evolves according to $$\\frac{dq}{dt} = -I + b,$$ where $q$ is the stored charge in Coulombs, $I$ is cell current in Amperes, and $b$ is bypass balancing current in Amperes. The nominal capacity $C_{\\mathrm{nom}}$ converts between stored charge and SoC via $q = C_{\\mathrm{nom}} z$, so that $$\\frac{dz}{dt} = \\frac{-I + b}{C_{\\mathrm{nom}}}.$$\n- First-order Resistor-Capacitor (RC) polarization voltage dynamics: the polarization voltage $v_p$ satisfies $$\\frac{dv_p}{dt} = -\\frac{1}{\\tau_p} v_p + \\frac{R_p}{\\tau_p} I,$$ where $\\tau_p$ is the polarization time constant in seconds and $R_p$ is the polarization resistance in Ohms.\n- The open-circuit voltage $U(z)$ is modeled by a monotone function of the SoC. For this problem, use $$U(z) = U_{\\mathrm{ref}} + \\alpha_U \\ln(z) - \\beta_U \\ln(1-z)$$ where $U_{\\mathrm{ref}}$ is in Volts and $\\alpha_U,\\beta_U$ are in Volts. This is a well-tested empirical form for open-circuit voltage as a function of SoC in a range away from the endpoints $z=0$ and $z=1$.\n\nThe measured terminal voltage $V_k$ at discrete time step $k$ is $$V_k = U(z_k) + v_{p,k} + I_k R_s + w_k,$$ where $R_s$ is the series resistance in Ohms, and $w_k$ is zero-mean measurement noise with variance $R$ in $\\mathrm{V}^2$.\n\nDiscretize the dynamics with sampling period $\\Delta t$ seconds using a standard forward-Euler discrete-time approximation for the SoC and an exact discretization of the linear $v_p$ dynamics:\n- $$z_{k+1} = z_k + \\frac{-I_k + b_k}{C_{\\mathrm{nom}}} \\Delta t + \\eta_{z,k},$$\n- $$v_{p,k+1} = \\mathrm{e}^{-\\Delta t/\\tau_p} v_{p,k} + R_p \\left(1-\\mathrm{e}^{-\\Delta t/\\tau_p}\\right) I_k + \\eta_{p,k},$$\nwhere $\\eta_{z,k}$ and $\\eta_{p,k}$ are zero-mean process noises with variances $Q_z$ (dimensionless squared for SoC) and $Q_{vp}$ (in $\\mathrm{V}^2$), respectively. Let the state be $x_k = [z_k,\\ v_{p,k}]^\\top$.\n\nLinearize the measurement $V_k$ with respect to the state $x_k$ around an operating point $x^\\star = [z^\\star,\\ v_p^\\star]^\\top$. The linearized measurement is $$V_k \\approx h(x^\\star) + H (x_k - x^\\star) + w_k,$$ with Jacobian\n$$H = \\begin{bmatrix} \\frac{dU}{dz}(z^\\star)  1 \\end{bmatrix}, \\quad \\frac{dU}{dz}(z) = \\frac{\\alpha_U}{z} + \\frac{\\beta_U}{1-z}.$$\nThe linearized state transition Jacobian is\n$$F = \\begin{bmatrix} 1  0 \\\\ 0  \\mathrm{e}^{-\\Delta t/\\tau_p} \\end{bmatrix}.$$\nAssume the process noise covariance is $$Q = \\mathrm{diag}\\left(Q_z,\\ Q_{vp}\\right),$$ and measurement noise variance is $$R.$$\n\nYour tasks:\n\n1. Derive from first principles the discrete-time covariance Riccati recursion for the linearized system. Explain clearly how the KF gain depends on the prior covariance and the measurement Jacobian. Specifically, from the linearized model and the Gaussian noise assumptions, derive the prediction covariance $$P_k^- = F P_{k-1} F^\\top + Q,$$ the innovation variance $$S_k = H P_k^- H^\\top + R,$$ the KF gain $$K_k = P_k^- H^\\top S_k^{-1},$$ and the posterior covariance $$P_k = (I - K_k H) P_k^-,$$ where $P_k$ is the estimation error covariance at time $k$, $I$ is the identity matrix of appropriate dimension, and $P_0$ is a given initial covariance.\n2. Implement a program that computes the KF gains $K_k$ and the posterior covariance $P_k$ over a fixed horizon of $N$ steps for the given test cases, using the linearized model computed at the specified operating point $z^\\star$ and parameters. The program should not use any external measurements; it should focus solely on the covariance recursion and KF gain computation.\n3. Analyze how the estimation error covariance evolves under different noise and dynamics conditions, especially the roles of $R$ (measurement noise variance), $Q$ (process noise covariance), $\\tau_p$ (polarization time constant), and $\\Delta t$ (sampling period), in the provided test suite.\n\nUnits and data:\n\n- Express all voltages in $\\mathrm{V}$, currents in $\\mathrm{A}$, resistances in $\\Omega$, time in $\\mathrm{s}$, capacity in $\\mathrm{A\\cdot h}$ for tabulation but convert to Coulombs in the code via $C_{\\mathrm{nom}}[\\mathrm{C}] = C_{\\mathrm{nom}}[\\mathrm{A\\cdot h}] \\times 3600$. SoC $z$ is dimensionless and must be treated as a decimal (e.g., $0.6$).\n- The program must compute and report results strictly in floating-point numbers.\n\nTest suite:\n\nCompute the KF gain sequence and covariance evolution for $N$ steps, returning the final ($k=N$) KF gain vector entries and the final posterior covariance diagonal entries for each case. Use the following three test cases:\n\n- Case A (nominal): \n  - $C_{\\mathrm{nom}} = 2.5\\ \\mathrm{A\\cdot h}$, $\\Delta t = 1.0\\ \\mathrm{s}$, $\\tau_p = 20.0\\ \\mathrm{s}$, $R_p = 0.015\\ \\Omega$, $R_s = 0.010\\ \\Omega$,\n  - $U_{\\mathrm{ref}} = 3.6\\ \\mathrm{V}$, $\\alpha_U = 0.12\\ \\mathrm{V}$, $\\beta_U = 0.12\\ \\mathrm{V}$,\n  - $z^\\star = 0.6$, $I_k = 2.0\\ \\mathrm{A}$ (constant), $b_k = 0.0\\ \\mathrm{A}$ (constant),\n  - $Q_z = 1.0\\times 10^{-9}$, $Q_{vp} = 1.0\\times 10^{-6}\\ \\mathrm{V}^2$, $R = 1.0\\times 10^{-4}\\ \\mathrm{V}^2$,\n  - $P_0 = \\mathrm{diag}(1.0\\times 10^{-4},\\ 1.0\\times 10^{-3})$, $N = 30$.\n- Case B (high measurement noise with balancing): \n  - $C_{\\mathrm{nom}} = 2.5\\ \\mathrm{A\\cdot h}$, $\\Delta t = 1.0\\ \\mathrm{s}$, $\\tau_p = 10.0\\ \\mathrm{s}$, $R_p = 0.020\\ \\Omega$, $R_s = 0.020\\ \\Omega$,\n  - $U_{\\mathrm{ref}} = 3.6\\ \\mathrm{V}$, $\\alpha_U = 0.12\\ \\mathrm{V}$, $\\beta_U = 0.12\\ \\mathrm{V}$,\n  - $z^\\star = 0.5$, $I_k = 5.0\\ \\mathrm{A}$ (constant), $b_k = 0.5\\ \\mathrm{A}$ (constant),\n  - $Q_z = 5.0\\times 10^{-9}$, $Q_{vp} = 5.0\\times 10^{-6}\\ \\mathrm{V}^2$, $R = 4.0\\times 10^{-2}\\ \\mathrm{V}^2$,\n  - $P_0 = \\mathrm{diag}(5.0\\times 10^{-4},\\ 5.0\\times 10^{-3})$, $N = 30$.\n- Case C (low measurement noise, fast polarization, higher current and series resistance): \n  - $C_{\\mathrm{nom}} = 2.5\\ \\mathrm{A\\cdot h}$, $\\Delta t = 0.5\\ \\mathrm{s}$, $\\tau_p = 2.0\\ \\mathrm{s}$, $R_p = 0.025\\ \\Omega$, $R_s = 0.050\\ \\Omega$,\n  - $U_{\\mathrm{ref}} = 3.6\\ \\mathrm{V}$, $\\alpha_U = 0.12\\ \\mathrm{V}$, $\\beta_U = 0.12\\ \\mathrm{V}$,\n  - $z^\\star = 0.9$, $I_k = 10.0\\ \\mathrm{A}$ (constant), $b_k = 1.0\\ \\mathrm{A}$ (constant),\n  - $Q_z = 1.0\\times 10^{-8}$, $Q_{vp} = 1.0\\times 10^{-5}\\ \\mathrm{V}^2$, $R = 1.0\\times 10^{-6}\\ \\mathrm{V}^2$,\n  - $P_0 = \\mathrm{diag}(1.0\\times 10^{-3},\\ 1.0\\times 10^{-3})$, $N = 30$.\n\nNote that $I_k R_s$ does not affect the Jacobian $H$ with respect to the state $x_k$, so it is treated as a known offset in the measurement model after linearization. The KF gain and covariance evolution can be computed solely from $F$, $Q$, $H$, $R$, and $P_0$.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a list of four floating-point numbers in the order $[K_{z,N}, K_{vp,N}, P_{zz,N}, P_{vp\\,vp,N}]$, where $K_{z,N}$ and $K_{vp,N}$ are the components of the final KF gain vector $K_N$, and $P_{zz,N}$ and $P_{vp\\,vp,N}$ are the diagonal entries of the final posterior covariance $P_N$. The overall output must be a single list of these per-case lists, for example, $[[\\dots],[\\dots],[\\dots]]$.",
            "solution": "The problem statement is evaluated for validity before proceeding to a solution.\n\n### Step 1: Extract Givens\n\nThe provided information is as follows:\n\n**State and Dynamics Equations:**\n- State of Charge (SoC) definition: $z \\in [0,1]$.\n- Continuous-time charge dynamics: $\\frac{dq}{dt} = -I + b$, with $q = C_{\\mathrm{nom}} z$.\n- Continuous-time SoC dynamics: $\\frac{dz}{dt} = \\frac{-I + b}{C_{\\mathrm{nom}}}$.\n- Continuous-time polarization voltage dynamics: $\\frac{dv_p}{dt} = -\\frac{1}{\\tau_p} v_p + \\frac{R_p}{\\tau_p} I$.\n- Open-circuit voltage (OCV) model: $U(z) = U_{\\mathrm{ref}} + \\alpha_U \\ln(z) - \\beta_U \\ln(1-z)$.\n\n**Discrete-Time Model (Sampling Period $\\Delta t$):**\n- State vector: $x_k = [z_k, v_{p,k}]^\\top$.\n- Discrete SoC dynamics: $z_{k+1} = z_k + \\frac{-I_k + b_k}{C_{\\mathrm{nom}}} \\Delta t + \\eta_{z,k}$.\n- Discrete polarization voltage dynamics: $v_{p,k+1} = \\mathrm{e}^{-\\Delta t/\\tau_p} v_{p,k} + R_p \\left(1-\\mathrm{e}^{-\\Delta t/\\tau_p}\\right) I_k + \\eta_{p,k}$.\n- Measurement model: $V_k = U(z_k) + v_{p,k} + I_k R_s + w_k$.\n\n**Linearized Model and Noise Statistics:**\n- Process noise sources $\\eta_{z,k}$ and $\\eta_{p,k}$ are zero-mean with variances $Q_z$ and $Q_{vp}$, respectively.\n- Measurement noise $w_k$ is zero-mean with variance $R$.\n- Process noise covariance matrix: $Q = \\mathrm{diag}(Q_z, Q_{vp})$.\n- State transition Jacobian: $F = \\begin{bmatrix} 1  0 \\\\ 0  \\mathrm{e}^{-\\Delta t/\\tau_p} \\end{bmatrix}$.\n- Measurement Jacobian (linearized around $x^\\star = [z^\\star, v_p^\\star]^\\top$): $H = \\begin{bmatrix} \\frac{dU}{dz}(z^\\star)  1 \\end{bmatrix}$, where $\\frac{dU}{dz}(z) = \\frac{\\alpha_U}{z} + \\frac{\\beta_U}{1-z}$.\n\n**Kalman Filter Equations (to be derived and used):**\n- Initial error covariance: $P_0$.\n- Prediction covariance: $P_k^- = F P_{k-1} F^\\top + Q$.\n- Innovation variance: $S_k = H P_k^- H^\\top + R$.\n- Kalman Filter gain: $K_k = P_k^- H^\\top S_k^{-1}$.\n- Posterior covariance: $P_k = (I - K_k H) P_k^-$.\n\n**Unit Conversions and Data:**\n- Capacity is given in $\\mathrm{A \\cdot h}$ and must be converted to Coulombs using $C_{\\mathrm{nom}}[\\mathrm{C}] = C_{\\mathrm{nom}}[\\mathrm{A\\cdot h}] \\times 3600$.\n- The number of steps for the recursion is $N=30$.\n- Three test cases (A, B, C) are provided with specific parameter values for all constants and initial conditions.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded:** The problem is based on established principles of electrical engineering (RC circuits), electrochemistry (battery modeling), and control theory (Kalman filtering). The battery model is a standard first-order equivalent circuit model (ECM), and the application of a Kalman filter for state estimation is a canonical problem in this field. The model for OCV is empirically validated.\n- **Well-Posed:** The problem is well-posed. It asks for the computation of Kalman filter gains and covariance evolution, which are uniquely determined by the provided Riccati recursion equations and a complete set of parameters for each test case.\n- **Objective:** The problem is stated in precise, objective, and mathematical language. There are no subjective or opinion-based elements.\n- **Completeness and Consistency:** The problem is self-contained. All necessary equations, parameters, initial conditions, and constants are provided for each of the three test cases. There are no contradictions in the provided data.\n- **Realism and Feasibility:** The parameter values are realistic for lithium-ion cells. The task of computing the covariance evolution is a standard and feasible computational task.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. It is a well-defined and standard problem in engineering state estimation. A solution will be provided.\n\n### Solution\n\nThe task is to derive the Kalman Filter (KF) covariance update equations (the discrete-time Riccati recursion) and then implement a simulation to compute the KF gain and error covariance evolution for a linearized battery model.\n\n**1. Derivation of the Covariance Riccati Recursion**\n\nThe Kalman Filter is an optimal estimator for linear systems with Gaussian noise. It operates in a two-step cycle: prediction and update. We are concerned here with the propagation of the estimation error covariance, which describes the uncertainty of our state estimate. Let the true state be $x_k$ and its estimate be $\\hat{x}_k$. The estimation error is $e_k = x_k - \\hat{x}_k$. The error covariance is $P_k = E[e_k e_k^\\top]$, where $E[\\cdot]$ is the expectation operator.\n\nThe filter uses two estimates: the a priori estimate $\\hat{x}_k^-$, calculated before the measurement at time $k$ is incorporated, and the a posteriori estimate $\\hat{x}_k$, calculated after. The corresponding error covariances are $P_k^- = E[e_k^- (e_k^-)^\\top]$ and $P_k = E[e_k e_k^\\top]$.\n\n**Prediction Step:**\nThe state evolves according to the linearized model $x_k = F x_{k-1} + \\text{terms} + v_{k-1}$, where $v_{k-1}$ is the process noise with covariance $Q$. The a priori state estimate at time $k$ is predicted from the a posteriori estimate at time $k-1$:\n$\\hat{x}_k^- = F \\hat{x}_{k-1} + \\text{known terms}$.\nThe a priori error $e_k^- = x_k - \\hat{x}_k^-$ is then:\n$$e_k^- = (F x_{k-1} + v_{k-1}) - F \\hat{x}_{k-1} = F (x_{k-1} - \\hat{x}_{k-1}) + v_{k-1} = F e_{k-1} + v_{k-1}$$\nThe covariance of this a priori error is $P_k^- = E[e_k^- (e_k^-)^\\top]$:\n$$P_k^- = E[(F e_{k-1} + v_{k-1})(F e_{k-1} + v_{k-1})^\\top] = E[F e_{k-1} e_{k-1}^\\top F^\\top + F e_{k-1} v_{k-1}^\\top + v_{k-1} e_{k-1}^\\top F^\\top + v_{k-1} v_{k-1}^\\top]$$\nAssuming the estimation error at time $k-1$ is uncorrelated with the process noise at time $k-1$ (i.e., $E[e_{k-1} v_{k-1}^\\top] = 0$), this simplifies to:\n$$P_k^- = F E[e_{k-1} e_{k-1}^\\top] F^\\top + E[v_{k-1} v_{k-1}^\\top]$$\nThis yields the first Riccati equation, the **prediction covariance update**:\n$$P_k^- = F P_{k-1} F^\\top + Q$$\n\n**Update Step:**\nThe measurement at time $k$ is given by the linearized model $V_k \\approx h(x^\\star) + H (x_k - x^\\star) + w_k$. Let's define the measurement residual, or **innovation**, $\\tilde{y}_k$, as the difference between the actual measurement and the predicted measurement:\n$$\\tilde{y}_k = V_k - (h(x^\\star) + H(\\hat{x}_k^- - x^\\star))$$\nSubstituting the expression for $V_k$ and using $x_k = \\hat{x}_k^- + e_k^-$:\n$$\\tilde{y}_k = (h(x^\\star) + H(x_k - x^\\star) + w_k) - (h(x^\\star) + H(\\hat{x}_k^- - x^\\star)) = H(x_k - \\hat{x}_k^-) + w_k = H e_k^- + w_k$$\nThe variance of the innovation, $S_k$, is:\n$$S_k = E[\\tilde{y}_k \\tilde{y}_k^\\top] = E[(H e_k^- + w_k)(H e_k^- + w_k)^\\top]$$\nAssuming the a priori error $e_k^-$ and measurement noise $w_k$ are uncorrelated, this becomes:\n$$S_k = H E[e_k^- (e_k^-)^\\top] H^\\top + E[w_k w_k^\\top]$$\nThis is the **innovation variance** equation:\n$$S_k = H P_k^- H^\\top + R$$\nThe a posteriori state estimate is a linear combination of the a priori estimate and the innovation, weighted by the **Kalman gain** $K_k$:\n$$\\hat{x}_k = \\hat{x}_k^- + K_k \\tilde{y}_k$$\nThe gain $K_k$ is chosen to minimize the trace of the a posteriori error covariance $P_k$. The optimal gain is given by:\n$$K_k = E[e_k^- \\tilde{y}_k^\\top] S_k^{-1} = E[e_k^- (H e_k^- + w_k)^\\top] S_k^{-1} = E[e_k^- (e_k^-)^\\top] H^\\top S_k^{-1} = P_k^- H^\\top S_k^{-1}$$\nThis is the **Kalman gain** equation:\n$$K_k = P_k^- H^\\top S_k^{-1}$$\nThe gain $K_k$ optimally balances trust between the model prediction (embedded in $P_k^-$) and the new measurement (with uncertainty $R$). If the prior uncertainty $P_k^-$ is high, the gain will be large, putting more weight on the measurement. Conversely, if measurement noise $R$ is high, the gain will be small, and the filter will trust its own prediction more. The Jacobian $H$ maps state uncertainty into measurement uncertainty; if a state has a large effect on the measurement (large $H$ component), the filter can correct that state more effectively.\n\nFinally, we derive the a posteriori error covariance $P_k$. The posterior error is:\n$$e_k = x_k - \\hat{x}_k = x_k - (\\hat{x}_k^- + K_k \\tilde{y}_k) = (x_k - \\hat{x}_k^-) - K_k (H e_k^- + w_k) = e_k^- - K_k H e_k^- - K_k w_k = (I - K_k H) e_k^- - K_k w_k$$\nThe covariance $P_k = E[e_k e_k^\\top]$ is:\n$$P_k = E[((I - K_k H) e_k^- - K_k w_k)((I - K_k H) e_k^- - K_k w_k)^\\top]$$\nExpanding and using the uncorrelation between $e_k^-$ and $w_k$:\n$$P_k = (I - K_k H) E[e_k^- (e_k^-)^\\top] (I - K_k H)^\\top + K_k E[w_k w_k^\\top] K_k^\\top = (I - K_k H) P_k^- (I - K_k H)^\\top + K_k R K_k^\\top$$\nThis is the Joseph form of the covariance update, which is known for its numerical stability. The form given in the problem statement, $P_k = (I - K_k H) P_k^-$, is a valid simplification assuming $K_k$ was computed optimally as above. This simplification makes the update computationally cheaper and is sufficient for this problem.\n\n**2. Implementation and Analysis**\n\nThe derived Riccati recursion allows us to compute the evolution of the estimation error covariance $P_k$ and the corresponding Kalman gain $K_k$ without needing actual measurement data. The logic iterates the four derived equations for $N$ steps, starting from an initial covariance $P_0$.\n\n**Analysis of Parameter Effects on Covariance Evolution:**\n- **Measurement Noise ($R$):** Case B features a very large $R=4.0\\times 10^{-2}\\ \\mathrm{V}^2$. A high $R$ signifies an unreliable measurement. Consequently, the Kalman gain $K_k$ will be small, as the filter correctly discounts the noisy measurement. This leads to a higher steady-state error covariance $P_k$, as less information is extracted to correct the state estimates.\n- **Process Noise ($Q$):** This represents the uncertainty in the model dynamics. Higher $Q$ (as in Cases B and C compared to A) implies the state is expected to deviate more from the model's prediction. This increases the a priori covariance $P_k^-$ in each step, causing the filter to rely more on measurements (larger gain) and resulting in a higher steady-state posterior covariance $P$.\n- **Measurement Sensitivity ($H$):** The Jacobian $H$ depends on $z^\\star$ via $\\frac{dU}{dz}(z^\\star)$. In Case C, $z^\\star = 0.9$, which is near the end of the SoC range where the OCV curve is steepest. This yields a large $\\frac{dU}{dz}(z^\\star) \\approx 1.33\\ \\mathrm{V}$. A large value makes the measurement very sensitive to changes in SoC ($z_k$). This high sensitivity allows the filter to estimate $z_k$ with high precision, leading to a much smaller $P_{zz,N}$ component in the covariance matrix, provided the measurement is accurate (low $R$, as is the case in C).\n- **System Dynamics ($F$):** The matrix $F$ is influenced by the ratio $\\Delta t / \\tau_p$.\n  - In Case A, $\\Delta t / \\tau_p = 1/20 = 0.05$, so $F_{22} = e^{-0.05} \\approx 0.951$. The polarization voltage is highly persistent.\n  - In Case C, $\\tau_p$ is very small ($\\tau_p=2.0\\ \\mathrm{s}$) and $\\Delta t=0.5\\ \\mathrm{s}$. $\\Delta t / \\tau_p = 0.25$, so $F_{22} = e^{-0.25} \\approx 0.779$. This means the polarization voltage \"forgets\" its previous state more quickly. The model prediction for $v_{p,k}$ is less certain, which, all else being equal, would tend to increase the error variance $P_{vp,vp}$.\n\nThe provided code will numerically demonstrate these effects by propagating the covariance matrix and gain for each test case over $N=30$ steps. The final values will reflect the steady-state or near-steady-state behavior of the filter's uncertainty under the specified conditions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Kalman Filter covariance analysis for all test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (nominal)\n        {\n            \"C_nom_Ah\": 2.5, \"delta_t\": 1.0, \"tau_p\": 20.0,\n            \"alpha_U\": 0.12, \"beta_U\": 0.12, \"z_star\": 0.6,\n            \"Q_z\": 1.0e-9, \"Q_vp\": 1.0e-6, \"R\": 1.0e-4,\n            \"P0_diag\": [1.0e-4, 1.0e-3], \"N\": 30\n        },\n        # Case B (high measurement noise with balancing)\n        {\n            \"C_nom_Ah\": 2.5, \"delta_t\": 1.0, \"tau_p\": 10.0,\n            \"alpha_U\": 0.12, \"beta_U\": 0.12, \"z_star\": 0.5,\n            \"Q_z\": 5.0e-9, \"Q_vp\": 5.0e-6, \"R\": 4.0e-2,\n            \"P0_diag\": [5.0e-4, 5.0e-3], \"N\": 30\n        },\n        # Case C (low measurement noise, fast polarization, higher current and series resistance)\n        {\n            \"C_nom_Ah\": 2.5, \"delta_t\": 0.5, \"tau_p\": 2.0,\n            \"alpha_U\": 0.12, \"beta_U\": 0.12, \"z_star\": 0.9,\n            \"Q_z\": 1.0e-8, \"Q_vp\": 1.0e-5, \"R\": 1.0e-6,\n            \"P0_diag\": [1.0e-3, 1.0e-3], \"N\": 30\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_covariance_recursion(params)\n        results.append(result)\n\n    # Format the results into the exact string representation required.\n    # The format is a list of lists, e.g., [[val1, val2], [val3, val4]]\n    # str(list) in Python produces the correct string for each inner list.\n    output_str = f\"[{','.join([str(res) for res in results])}]\"\n    print(output_str)\n\ndef run_covariance_recursion(params):\n    \"\"\"\n    Computes the KF gain and covariance evolution for a single test case.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the test case.\n\n    Returns:\n        list: A list of four floats [K_z_N, K_vp_N, P_zz_N, P_vp_vp_N].\n    \"\"\"\n    # Extract parameters\n    delta_t = params[\"delta_t\"]\n    tau_p = params[\"tau_p\"]\n    alpha_U = params[\"alpha_U\"]\n    beta_U = params[\"beta_U\"]\n    z_star = params[\"z_star\"]\n    Q_z = params[\"Q_z\"]\n    Q_vp = params[\"Q_vp\"]\n    R = params[\"R\"]\n    P0_diag = params[\"P0_diag\"]\n    N = params[\"N\"]\n\n    # Problem statement mentions C_nom, I_k, b_k but they are not needed for the\n    # covariance recursion itself, only for the state update, which is not part of this task.\n    # R_p, R_s, U_ref are also not needed for the gain/covariance calculation.\n\n    # Construct the constant matrices for the Kalman Filter\n    # State transition Jacobian F\n    F = np.array([\n        [1.0, 0.0],\n        [0.0, np.exp(-delta_t / tau_p)]\n    ])\n\n    # Measurement Jacobian H\n    dU_dz_star = alpha_U / z_star + beta_U / (1.0 - z_star)\n    H = np.array([[dU_dz_star, 1.0]])  # H is a 1x2 row vector\n\n    # Process noise covariance Q\n    Q = np.diag([Q_z, Q_vp])\n\n    # Initialize the posterior covariance matrix P\n    P = np.diag(P0_diag)\n    \n    K = np.zeros((2, 1)) # Initialize K for the case N=0\n\n    # Riccati recursion a fixed number of times\n    for _ in range(N):\n        # 1. Prediction step for covariance\n        P_minus = F @ P @ F.T + Q\n\n        # 2. Innovation variance (S is a 1x1 matrix, effectively a scalar)\n        S = H @ P_minus @ H.T + R\n        \n        # 3. Kalman gain K\n        # S is 1x1, so its inverse is just 1/S. H.T is 2x1. P_minus is 2x2.\n        K = (P_minus @ H.T) / S\n\n        # 4. Update step for covariance\n        # Using the simplified form P = (I - K H) P^-\n        P = (np.eye(2) - K @ H) @ P_minus\n    \n    # Extract final values at step N\n    K_z_N = K[0, 0]\n    K_vp_N = K[1, 0]\n    P_zz_N = P[0, 0]\n    P_vp_vp_N = P[1, 1]\n\n    return [K_z_N, K_vp_N, P_zz_N, P_vp_vp_N]\n\nsolve()\n```"
        }
    ]
}