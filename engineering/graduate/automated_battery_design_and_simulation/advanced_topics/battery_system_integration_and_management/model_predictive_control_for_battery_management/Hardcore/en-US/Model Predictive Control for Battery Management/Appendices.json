{
    "hands_on_practices": [
        {
            "introduction": "Model Predictive Control relies on a mathematical model to predict future system behavior. However, physical battery models are often nonlinear and too complex for real-time optimization. This first practice tackles the fundamental task of creating a control-oriented model by linearizing a nonlinear open-circuit voltage (OCV) function. By constructing this simplified affine model and quantifying its accuracy against the original nonlinear model, you will gain hands-on experience with a core trade-off in MPC design and understand how factors like current magnitude affect prediction accuracy .",
            "id": "3928848",
            "problem": "You are asked to construct and evaluate an affine terminal-voltage model suitable for Model Predictive Control (MPC), starting from a physically grounded battery model and quantifying linearization error with respect to current magnitude. Use only the information and requirements in this statement to derive, implement, and test your solution.\n\nThe physical base and definitions are as follows. Let $x \\in [0,1]$ denote the state of charge (SOC), defined as the fraction of the usable capacity remaining. The SOC dynamics under a constant applied current are given by the conservation of charge, where $u$ is the applied current (positive for discharge, negative for charge), $\\eta$ is the charge-transfer efficiency, $Q_{\\mathrm{nom}}$ is the nominal capacity in ampere-second, and $\\Delta t$ is the sampling time in second. The discrete-time SOC update for a constant-current segment is\n$$\nx_{k+1} = x_k - \\frac{\\eta \\Delta t}{Q_{\\mathrm{nom}}} u_k,\n$$\nwith saturation to keep $x_k$ within $[0,1]$ after each update. The terminal voltage $V$ is defined as the open-circuit potential minus the instantaneous ohmic drop, that is,\n$$\nV = E(x) - R u,\n$$\nwhere $R$ is the internal ohmic resistance in ohm and $E(x)$ is the open-circuit potential as a function of SOC.\n\nFor simulation and testing, use a widely accepted sigmoidal open-circuit potential function that captures the monotonic and saturating behavior of typical Lithium-ion cells:\n$$\nE(x) = E_{\\min} + \\frac{\\Delta E}{1 + \\exp(-k(x - x_{\\mathrm{mid}}))},\n$$\nwhere $E_{\\min}$ is the lower asymptote in volt, $E_{\\max}$ is the upper asymptote in volt, $\\Delta E = E_{\\max} - E_{\\min}$, $k$ is a dimensionless slope parameter, and $x_{\\mathrm{mid}}$ is the mid-SOC at which the curve transitions most rapidly.\n\nTask requirements:\n- Derive the first-order Taylor linearization of $E(x)$ around a nominal SOC $x^\\star$ and use it to construct an affine approximation $V_{\\mathrm{lin}}$ that is suitable for MPC design. Do not write down the final linearized expression in the problem statement; you must derive it from first principles in your solution.\n- Implement a program that, for each test case, performs a forward simulation over a fixed horizon of $N$ steps with constant current $u$, computes both the exact nonlinear terminal voltage $V_k$ and the affine-linearized voltage $V_{\\mathrm{lin},k}$ at each step, and returns the root-mean-square error (RMSE) in volt, defined as\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{k=1}^{N}\\left(V_k - V_{\\mathrm{lin},k}\\right)^2}.\n$$\n- Use a saturating SOC integrator that enforces $x_k \\in [0,1]$ at every step.\n- Express each RMSE in volt and report it to six decimal places.\n\nModel Predictive Control (MPC) accuracy in this context is assessed by the magnitude of the linearization error over the prediction horizon under different current magnitudes. Larger currents change SOC more rapidly and can increase linearization error due to nonlinearity in $E(x)$.\n\nParameter values and units:\n- Use $Q_{\\mathrm{nom}}$ in ampere-second, with $Q_{\\mathrm{nom}}$ derived from ampere-hour by multiplying by $3600$.\n- Use $u$ in ampere, $R$ in ohm, $E$ and $V$ in volt, $\\Delta t$ in second.\n- The sigmoidal OCV parameters are $E_{\\min}$ in volt, $E_{\\max}$ in volt, $k$ dimensionless, and $x_{\\mathrm{mid}}$ dimensionless.\n\nYour program must evaluate the following test suite of parameter sets. Each test case is given as a tuple containing `(Q_{\\mathrm{Ah}}, \\Delta t, N, u, R, x^\\star, x_0, E_{\\min}, E_{\\max}, k, x_{\\mathrm{mid}}, \\eta)`, where $Q_{\\mathrm{Ah}}$ is the nominal capacity in ampere-hour and $Q_{\\mathrm{nom}} = 3600 \\cdot Q_{\\mathrm{Ah}}$ is computed internally:\n- Test case $1$: $(5, 1, 600, 0, 0.05, 0.5, 0.5, 3.0, 4.2, 0.8, 0.5, 1.0)$.\n- Test case $2$: $(5, 1, 600, 2, 0.05, 0.5, 0.5, 3.0, 4.2, 0.8, 0.5, 1.0)$.\n- Test case $3$: $(5, 1, 600, -4, 0.05, 0.9, 0.9, 3.0, 4.2, 0.8, 0.5, 1.0)$.\n- Test case $4$: $(5, 1, 600, 20, 0.05, 0.2, 0.2, 3.0, 4.2, 0.8, 0.5, 1.0)$.\n\nThe required final output format is a single line containing a comma-separated list enclosed in square brackets, where each entry is the RMSE for the corresponding test case expressed in volt and formatted to six decimal places, for example, $[0.000123,0.001234,0.012345,0.123456]$. Your program must produce exactly this single line with no additional text.",
            "solution": "We begin from foundational principles that govern rechargeable cell behavior in the regime relevant to Model Predictive Control (MPC). The terminal voltage $V$ is modeled as the sum of the open-circuit potential and instantaneous ohmic effects, with the physically grounded relationship $V = E(x) - R u$. The state of charge (SOC) $x$ evolves according to conservation of charge: with current $u$ defined positive for discharge, the rate of change is $\\dot{x} = -\\frac{\\eta}{Q_{\\mathrm{nom}}}u$, where $\\eta$ is the charge-transfer efficiency and $Q_{\\mathrm{nom}}$ is the nominal capacity in ampere-second. In discrete time with uniform sampling interval $\\Delta t$, the SOC update is $x_{k+1} = x_k - \\frac{\\eta \\Delta t}{Q_{\\mathrm{nom}}}u_k$, and the physical state constraint $x_k \\in [0,1]$ is enforced by saturation. This is consistent with the definition $x \\in [0,1]$ as a fraction of the usable charge and is a well-tested approximation in electrochemical modeling for control.\n\nFor advanced control design and prediction, MPC often requires an affine model in the variables of interest, here the terminal voltage as a function of state and input. The nonlinear component is the open-circuit potential function $E(x)$. We are given a sigmoidal form that captures the qualitative behavior of Lithium-ion open-circuit voltage:\n$$\nE(x) = E_{\\min} + \\frac{\\Delta E}{1 + \\exp(-k(x - x_{\\mathrm{mid}}))}, \\quad \\Delta E = E_{\\max} - E_{\\min}.\n$$\nThis function is monotone increasing in $x$, saturating near $E_{\\min}$ as $x \\to 0$ and near $E_{\\max}$ as $x \\to 1$. The derivative is needed for linearization. Define the logistic fraction $s(x) = \\frac{1}{1 + \\exp(-k(x - x_{\\mathrm{mid}}))}$. Then $E(x) = E_{\\min} + \\Delta E s(x)$ and the chain rule gives $E'(x) = \\Delta E s'(x)$ with\n$$\ns'(x) = \\frac{\\mathrm{d}}{\\mathrm{d}x}\\left(\\frac{1}{1 + e^{-k(x - x_{\\mathrm{mid}})}}\\right) = \\frac{k e^{-k(x - x_{\\mathrm{mid}})}}{\\left(1 + e^{-k(x - x_{\\mathrm{mid}})}\\right)^2} = k s(x) (1 - s(x)).\n$$\nHence,\n$$\nE'(x) = \\Delta E k s(x) (1 - s(x)).\n$$\n\nTo construct the affine approximation required for MPC, we perform a first-order Taylor linearization of $E(x)$ around a chosen nominal SOC $x^\\star$. The Taylor expansion of a differentiable function $E(x)$ at $x^\\star$ gives $E(x) \\approx E(x^\\star) + E'(x^\\star)(x - x^\\star)$ for $x$ near $x^\\star$. Substituting this into the voltage expression $V = E(x) - R u$, we obtain an affine function in $(x,u)$, which has a constant term and a term linear in the state deviation $(x - x^\\star)$ and the input $u$. This affine model is what MPC uses to predict voltages under small deviations from the nominal point, while respecting the input-through-resistance term $-R u$.\n\nTo quantify linearization error with respect to current magnitude, we propagate the SOC with a constant current $u$ over a horizon of $N$ steps and compute at each step both the exact nonlinear voltage $V_k$ and the affine-linearized voltage $V_{\\mathrm{lin},k}$ constructed from the linearization at $x^\\star$. The error at step $k$ is $\\delta V_k = V_k - V_{\\mathrm{lin},k}$. Because the ohmic term $-R u$ appears in both $V_k$ and $V_{\\mathrm{lin},k}$, the error is entirely governed by the nonlinearity in $E(x)$,\n$$\n\\delta V_k = E(x_k) - (E(x^\\star) + E'(x^\\star)(x_k - x^\\star)).\n$$\nThe root-mean-square error (RMSE) over the horizon is\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{k=1}^{N}\\left(\\delta V_k\\right)^2}.\n$$\nThis metric increases with current magnitude because larger $|u|$ changes $x_k$ more quickly, moving the state further from $x^\\star$ and increasing the contribution of higher-order terms neglected by the first-order approximation.\n\nAlgorithmic design for the program:\n- Convert $Q_{\\mathrm{Ah}}$ to $Q_{\\mathrm{nom}}$ in ampere-second via $Q_{\\mathrm{nom}} = 3600 \\cdot Q_{\\mathrm{Ah}}$.\n- Initialize $x_0$ and set $x^\\star$ for the linearization point. Compute the derivative $E'(x^\\star)$ from the sigmoidal $E(x)$ expression using $E'(x^\\star) = \\Delta E k s(x^\\star)(1 - s(x^\\star))$ and $s(x^\\star) = \\frac{1}{1 + \\exp(-k(x^\\star - x_{\\mathrm{mid}}))}$.\n- For $k$ from $1$ to $N$, propagate SOC using $x_{k} = \\operatorname{clip}(x_{k-1} - \\frac{\\eta \\Delta t}{Q_{\\mathrm{nom}}} u, 0, 1)$, where $\\operatorname{clip}$ enforces saturation to the interval $[0,1]$.\n- At each step, compute $V_k = E(x_k) - R u$ and $V_{\\mathrm{lin},k} = (E(x^\\star) + E'(x^\\star)(x_k - x^\\star)) - R u$, accumulate $\\left(V_k - V_{\\mathrm{lin},k}\\right)^2$, and finally compute the RMSE.\n- Repeat for each test case and report the list of RMSE values in volt, each to six decimal places, as a single line in the specified format.\n\nInterpretation for MPC accuracy: When $u = 0$, SOC is constant and the linearization at $x^\\star$ is exact locally, so the RMSE is zero. As $|u|$ increases, SOC deviates from $x^\\star$ and the sigmoidal curvature of $E(x)$ contributes higher-order terms, increasing the RMSE. Near SOC boundaries, saturation and the low curvature region of the sigmoid can alter the error growth; however, the first-order affine approximation remains a useful local model for MPC provided the RMSE remains small over the prediction horizon relative to control and measurement tolerances. The program quantifies this behavior numerically under scientifically plausible parameters and units.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ocv_sigmoid(x, Emin, Emax, k, xmid):\n    \"\"\"\n    Open-circuit voltage E(x) using a logistic sigmoid between Emin and Emax.\n\n    E(x) = Emin + (Emax - Emin) / (1 + exp(-k*(x - xmid)))\n\n    Parameters:\n        x: SOC in [0,1]\n        Emin: lower asymptote (V)\n        Emax: upper asymptote (V)\n        k: slope parameter (dimensionless)\n        xmid: mid-SOC (dimensionless)\n    Returns:\n        E: voltage (V)\n    \"\"\"\n    dE = Emax - Emin\n    return Emin + dE / (1.0 + np.exp(-k * (x - xmid)))\n\ndef docv_dx_sigmoid(x, Emin, Emax, k, xmid):\n    \"\"\"\n    Derivative dE/dx for the OCV sigmoid model.\n\n    Using s(x) = 1 / (1 + exp(-k*(x - xmid))), then\n    dE/dx = (Emax - Emin) * k * s * (1 - s)\n    \"\"\"\n    dE = Emax - Emin\n    s = 1.0 / (1.0 + np.exp(-k * (x - xmid)))\n    return dE * k * s * (1.0 - s)\n\ndef rmse_linearization_error(params):\n    \"\"\"\n    Compute RMSE between nonlinear V(x) and affine-linearized V around x_star.\n\n    params: tuple (Q_Ah, dt, N, u, R, x_star, x0, Emin, Emax, k, xmid, eta)\n    Returns:\n        rmse (float, volts)\n    \"\"\"\n    Q_Ah, dt, N, u, R, x_star, x0, Emin, Emax, k, xmid, eta = params\n    Q_nom = Q_Ah * 3600.0  # Ampere-second\n    # Precompute linearization constants at x_star\n    E_star = ocv_sigmoid(x_star, Emin, Emax, k, xmid)\n    dE_dx_star = docv_dx_sigmoid(x_star, Emin, Emax, k, xmid)\n\n    # Initialize SOC\n    x = float(x0)\n\n    # Accumulate squared error\n    se = 0.0\n\n    # Small epsilon to avoid numerical issues at exact boundaries\n    eps = 0.0  # boundaries are acceptable for sigmoid as defined\n\n    for _ in range(int(N)):\n        # SOC update with saturation to [0,1]\n        x = x - (eta * dt / Q_nom) * u\n        if x < 0.0:\n            x = 0.0\n        elif x > 1.0:\n            x = 1.0\n\n        # Nonlinear terminal voltage\n        V_true = ocv_sigmoid(x, Emin, Emax, k, xmid) - R * u\n\n        # Affine-linearized terminal voltage around x_star\n        E_lin = E_star + dE_dx_star * (x - x_star)\n        V_lin = E_lin - R * u\n\n        err = V_true - V_lin\n        se += err * err\n\n    rmse = np.sqrt(se / float(N))\n    return float(rmse)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (Q_Ah, dt, N, u, R, x_star, x0, Emin, Emax, k, xmid, eta)\n    test_cases = [\n        (5.0, 1.0, 600, 0.0, 0.05, 0.5, 0.5, 3.0, 4.2, 0.8, 0.5, 1.0),\n        (5.0, 1.0, 600, 2.0, 0.05, 0.5, 0.5, 3.0, 4.2, 0.8, 0.5, 1.0),\n        (5.0, 1.0, 600, -4.0, 0.05, 0.9, 0.9, 3.0, 4.2, 0.8, 0.5, 1.0),\n        (5.0, 1.0, 600, 20.0, 0.05, 0.2, 0.2, 3.0, 4.2, 0.8, 0.5, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = rmse_linearization_error(case)\n        # Format to six decimal places as required\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from modeling to control, a primary function of any advanced battery management system is to ensure safe operation. This practice demonstrates how MPC can be used for active thermal management, a critical safety function. You will design and tune an MPC controller for a two-node electro-thermal model to prevent temperature overshoot, exploring the classic trade-off between aggressive performance (high current tracking) and maintaining the battery within its safe thermal operating window . This exercise provides direct insight into how MPC's predictive nature allows it to anticipate and mitigate constraint violations.",
            "id": "3928791",
            "problem": "You are given a physically realistic, two-node lumped electro-thermal battery model and must implement a Model Predictive Control (MPC) strategy to mitigate temperature overshoot under a step current input while maintaining performance. The task requires deriving the discrete-time thermal dynamics from first principles and formulating a finite-horizon MPC that balances current tracking with thermal regulation. You must compute the worst-case temperature overshoot under an open-loop step current, then design MPC weights to reduce the overshoot subject to a performance constraint. All answers must be expressed numerically and produced by a complete, runnable program.\n\nThe fundamental base consists of the following well-tested physical laws and definitions:\n- Joule heating: the power generated internally by resistive losses is $P = I^2 R$, where $I$ is current and $R$ is internal resistance.\n- Lumped thermal energy balance: for a node with thermal capacitance $C$, the temperature dynamics obey $C \\, \\frac{dT}{dt} = \\text{net heat inflow}$.\n- Two-node thermal network with a core and a surface:\n  - Core node temperature $T_c$ with thermal capacitance $C_c$ and conduction to surface with thermal conductance $h_{cs}$.\n  - Surface node temperature $T_s$ with thermal capacitance $C_s$, conduction from core with thermal conductance $h_{cs}$, and convection to ambient temperature $T_{\\text{amb}}$ with thermal conductance $h_{sa}$.\n- The continuous-time model is\n  $$C_c \\frac{dT_c}{dt} = - h_{cs} (T_c - T_s) + \\eta I^2,$$\n  $$C_s \\frac{dT_s}{dt} = h_{cs} (T_c - T_s) - h_{sa} (T_s - T_{\\text{amb}}),$$\n  where $\\eta$ is the fraction of resistive heating applied to the core (for a simple Joule model $\\eta = R$).\n\nDiscretize the above dynamics using forward Euler with sample time $\\Delta t$ to obtain the affine, discrete-time dynamics\n$$\n\\begin{bmatrix}\nT_{c,k+1} \\\\\nT_{s,k+1}\n\\end{bmatrix}\n=\n\\left(I_2 + \\Delta t \\, A\\right)\n\\begin{bmatrix}\nT_{c,k} \\\\\nT_{s,k}\n\\end{bmatrix}\n+ \\Delta t \\, B \\, w_k + \\Delta t \\, g,\n$$\nwhere $w_k = I_k^2$, $A = \\begin{bmatrix} -\\frac{h_{cs}}{C_c} & \\frac{h_{cs}}{C_c} \\\\ \\frac{h_{cs}}{C_s} & -\\frac{h_{cs} + h_{sa}}{C_s} \\end{bmatrix}$, $B = \\begin{bmatrix} \\frac{\\eta}{C_c} \\\\ 0 \\end{bmatrix}$, and $g = \\begin{bmatrix} 0 \\\\ \\frac{h_{sa}}{C_s} T_{\\text{amb}} \\end{bmatrix}$.\n\nDefine the step current command as $I_d$ (assume $I_d \\ge 0$), and the squared-current input bound as $w_{\\max} = I_d^2$. The open-loop step input applies $w_k = w_{\\max}$ for all $k$ over the finite horizon of $N$ steps.\n\nDefine the worst-case temperature overshoot relative to a temperature limit $T_{\\max}$ as\n$$\n\\Delta T_{\\text{overshoot}} = \\max\\left(0, \\max_{0 \\le k \\le N} \\left( T_{s,k} - T_{\\max} \\right) \\right),\n$$\nexpressed in degrees Celsius (°C).\n\nFormulate a finite-horizon MPC with decision variables $w_0, w_1, \\dots, w_{N-1}$ subject to bounds $0 \\le w_k \\le w_{\\max}$ to minimize the objective\n$$\nJ = \\sum_{k=0}^{N-1} \\left[ Q \\left(w_k - w_d\\right)^2 + R \\left(w_k - w_{k-1}\\right)^2 + S \\left( \\max\\left(0, T_{s,k} - T_{\\max}\\right) \\right)^2 \\right],\n$$\nwhere $w_d = I_d^2$, $Q \\ge 0$ is the tracking weight, $R \\ge 0$ is the smoothness weight, $S \\ge 0$ is the temperature penalty weight, and $w_{-1}$ is defined as $w_{-1} = w_d$ for the first step. The MPC is evaluated in an open-loop predictive manner using the given discrete-time thermal model.\n\nPerformance is measured as the root mean square error (RMSE) of the current tracking:\n$$\n\\text{RMSE}_I = \\sqrt{ \\frac{1}{N} \\sum_{k=0}^{N-1} \\left( \\sqrt{w_k} - I_d \\right)^2 },\n$$\nexpressed in amperes (A). The design requirement is to select weights $(Q, S)$ from a candidate grid with a fixed $R$ such that $\\Delta T_{\\text{overshoot}}$ is minimized subject to $\\text{RMSE}_I \\le \\varepsilon$, where $\\varepsilon$ is a performance threshold.\n\nImplement the following algorithm for each test case:\n- Step $1$: Compute the open-loop worst-case temperature overshoot under the step input $w_k = w_{\\max}$.\n- Step $2$: For each $(Q, S)$ pair in the candidate grid, solve the bounded optimization for $w_{0:N-1}$ using the discrete-time model and objective $J$, then compute the resulting overshoot and $\\text{RMSE}_I$.\n- Step $3$: Among candidates satisfying $\\text{RMSE}_I \\le \\varepsilon$, select the one with the smallest overshoot; in case of ties, select the one with the smallest $S$; if none satisfy the constraint, select the candidate with the smallest overshoot and report its $\\text{RMSE}_I$.\n- Step $4$: Report the open-loop overshoot, the MPC overshoot at the selected weights, the $\\text{RMSE}_I$, and the selected $(Q, S)$.\n\nUnits and numerical requirements:\n- Temperatures must be handled in degrees Celsius; report overshoot in degrees Celsius, rounded to three decimal places.\n- Currents must be in amperes; report $\\text{RMSE}_I$ in amperes, rounded to three decimal places.\n- Angles do not apply in this problem.\n- All times are in seconds.\n\nTest suite:\n- Case A (happy path): $C_c = 4000$, $C_s = 2000$, $h_{cs} = 10$, $h_{sa} = 5$, $\\eta = 0.02$, $\\Delta t = 1$, $N = 120$, $T_{\\text{amb}} = 25$, $T_{c,0} = 25$, $T_{s,0} = 25$, $I_d = 100$, $T_{\\max} = 35$, $\\varepsilon = 10$, $R = 0.01$, candidate $Q \\in \\{0.1, 1.0, 10.0\\}$, candidate $S \\in \\{0.1, 1.0, 10.0, 100.0\\}$.\n- Case B (boundary near limit): $C_c = 4000$, $C_s = 2000$, $h_{cs} = 10$, $h_{sa} = 5$, $\\eta = 0.02$, $\\Delta t = 1$, $N = 120$, $T_{\\text{amb}} = 25$, $T_{c,0} = 34$, $T_{s,0} = 34$, $I_d = 100$, $T_{\\max} = 35$, $\\varepsilon = 10$, $R = 0.01$, candidate $Q \\in \\{0.1, 1.0, 10.0\\}$, candidate $S \\in \\{0.1, 1.0, 10.0, 100.0\\}$.\n- Case C (high ambient, lower current): $C_c = 4000$, $C_s = 2000$, $h_{cs} = 10$, $h_{sa} = 5$, $\\eta = 0.02$, $\\Delta t = 1$, $N = 120$, $T_{\\text{amb}} = 35$, $T_{c,0} = 35$, $T_{s,0} = 35$, $I_d = 80$, $T_{\\max} = 40$, $\\varepsilon = 8$, $R = 0.01$, candidate $Q \\in \\{0.1, 1.0, 10.0\\}$, candidate $S \\in \\{0.1, 1.0, 10.0, 100.0\\}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a bracketed comma-separated list of five floats in the order: $[\\Delta T_{\\text{overshoot,open}}, \\Delta T_{\\text{overshoot,MPC}}, \\text{RMSE}_I, Q, S]$. For example: $[[1.234,0.987,2.345,1.0,10.0],[...],[...]]$.",
            "solution": "The user has provided a problem that requires the design and evaluation of a Model Predictive Control (MPC) strategy for the thermal management of a battery. The problem is to be solved for a set of test cases.\n\n### Step 1: Extract Givens\n\nThe givens for this problem are:\n- **System Model**: A two-node lumped electro-thermal battery model.\n  - Core temperature: $T_c$, Surface temperature: $T_s$.\n  - Thermal capacitances: $C_c$, $C_s$.\n  - Thermal conductances: $h_{cs}$ (core-surface), $h_{sa}$ (surface-ambient).\n  - Ambient temperature: $T_{\\text{amb}}$.\n  - Resistive heating fraction: $\\eta$. The problem text states \"for a simple Joule model $\\eta = R$,\" where $R$ would be internal resistance. Here, $\\eta$ is given as a numerical value, representing the lumped effect of resistance and the fraction of heat generated in the core.\n  - Current: $I$.\n- **Continuous-Time Dynamics**:\n  $$C_c \\frac{dT_c}{dt} = - h_{cs} (T_c - T_s) + \\eta I^2$$\n  $$C_s \\frac{dT_s}{dt} = h_{cs} (T_c - T_s) - h_{sa} (T_s - T_{\\text{amb}})$$\n- **Discrete-Time Dynamics**: A forward Euler discretization with sample time $\\Delta t$.\n  $$\n  \\begin{bmatrix}\n  T_{c,k+1} \\\\\n  T_{s,k+1}\n  \\end{bmatrix}\n  =\n  \\mathbf{A_d}\n  \\begin{bmatrix}\n  T_{c,k} \\\\\n  T_{s,k}\n  \\end{bmatrix}\n  + \\mathbf{B_d} \\, w_k + \\mathbf{g_d}\n  $$\n  where $w_k = I_k^2$, and the matrices are defined as:\n  $$ \\mathbf{A_d} = I_2 + \\Delta t \\, A, \\quad \\mathbf{B_d} = \\Delta t \\, B, \\quad \\mathbf{g_d} = \\Delta t \\, g $$\n  $$ A = \\begin{bmatrix} -\\frac{h_{cs}}{C_c} & \\frac{h_{cs}}{C_c} \\\\ \\frac{h_{cs}}{C_s} & -\\frac{h_{cs} + h_{sa}}{C_s} \\end{bmatrix}, \\quad B = \\begin{bmatrix} \\frac{\\eta}{C_c} \\\\ 0 \\end{bmatrix}, \\quad g = \\begin{bmatrix} 0 \\\\ \\frac{h_{sa}}{C_s} T_{\\text{amb}} \\end{bmatrix} $$\n- **Control Problem**:\n  - Desired current: $I_d \\ge 0$. Desired squared-current: $w_d = I_d^2$.\n  - Control input bounds: $0 \\le w_k \\le w_{\\max}$, where $w_{\\max} = I_d^2$.\n  - Prediction horizon: $N$ steps.\n- **Metrics**:\n  - Worst-case temperature overshoot: $\\Delta T_{\\text{overshoot}} = \\max\\left(0, \\max_{0 \\le k \\le N} \\left( T_{s,k} - T_{\\max} \\right) \\right)$, where $T_{\\max}$ is a temperature limit.\n  - Current tracking RMSE: $\\text{RMSE}_I = \\sqrt{ \\frac{1}{N} \\sum_{k=0}^{N-1} \\left( \\sqrt{w_k} - I_d \\right)^2 }$.\n- **MPC Objective Function**:\n  $$ J = \\sum_{k=0}^{N-1} \\left[ Q \\left(w_k - w_d\\right)^2 + R \\left(w_k - w_{k-1}\\right)^2 + S \\left( \\max\\left(0, T_{s,k} - T_{\\max}\\right) \\right)^2 \\right] $$\n  - Weights: $Q$ (tracking), $R$ (smoothness), $S$ (temperature penalty).\n  - Initial condition for smoothness term: $w_{-1} = w_d$.\n- **Design Task**: Find weights $(Q, S)$ from a given grid that minimize $\\Delta T_{\\text{overshoot}}$ subject to a performance constraint $\\text{RMSE}_I \\le \\varepsilon$.\n- **Selection Logic**:\n  1.  Filter candidates satisfying $\\text{RMSE}_I \\le \\varepsilon$.\n  2.  From the filtered set, select the one with the smallest $\\Delta T_{\\text{overshoot}}$.\n  3.  Break ties using the smallest $S$.\n  4.  If no candidate satisfies the constraint, select the one with the overall smallest $\\Delta T_{\\text{overshoot}}$.\n- **Test Cases**: Three distinct test cases (A, B, C) are provided with all necessary numerical parameters.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is based on fundamental principles of thermodynamics and control theory. The two-node thermal model is a standard and physically realistic simplification for battery analysis. The MPC formulation is a canonical approach to constrained optimal control.\n2.  **Well-Posed**: The problem is well-posed. The system dynamics are linear and time-invariant (affine), the objective function is convex (as it is a sum of squared terms and squared hinge loss terms), and the constraints are simple bounds. This structure guarantees that a unique optimal solution exists for the MPC optimization subproblem. The overall task is a search over a discrete grid of parameters, which is also well-defined.\n3.  **Objective**: The problem is stated in precise mathematical and algorithmic terms, free of subjectivity or ambiguity.\n4.  **Completeness**: All required data, constants, initial conditions, and parameter grids are provided for each test case, making the problem self-contained.\n5.  **Consistency**: There are no contradictions in the problem statement. The definitions, equations, and algorithmic steps are logically consistent.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. It is a well-defined and scientifically sound problem in the domain of control engineering applied to battery systems. I will proceed with the full solution.\n\n### Principle-Based Solution Derivation\n\nThe solution will be implemented by adhering to the four-step algorithm specified in the problem description for each test case.\n\n**1. System Discretization**:\nFirst, for each test case, the continuous-time system matrices $A$ and vectors $B, g$ are constructed using the given physical parameters ($C_c, C_s, h_{cs}, h_{sa}, \\eta, T_{\\text{amb}}$). The discrete-time system matrices $\\mathbf{A_d}$, $\\mathbf{B_d}$, and vector $\\mathbf{g_d}$ are then computed using the forward Euler method with the specified sampling time $\\Delta t$.\n\n**2. Open-Loop Analysis (Step 1)**:\nThe open-loop response is simulated by applying a constant step input of squared-current $w_k = w_{\\max} = I_d^2$ for the entire horizon $k=0, \\dots, N-1$. Starting from the initial state $(T_{c,0}, T_{s,0})$, the state trajectory is propagated for $N$ steps using the discrete-time equation:\n$$ \\begin{bmatrix} T_{c,k+1} \\\\ T_{s,k+1} \\end{bmatrix} = \\mathbf{A_d} \\begin{bmatrix} T_{c,k} \\\\ T_{s,k} \\end{bmatrix} + \\mathbf{B_d} w_{\\max} + \\mathbf{g_d} $$\nThe simulation yields a sequence of surface temperatures $T_{s,0}, T_{s,1}, \\dots, T_{s,N}$. The open-loop overshoot, $\\Delta T_{\\text{overshoot,open}}$, is then calculated as the maximum temperature reached above the limit $T_{\\max}$ over this trajectory.\n\n**3. MPC Formulation and Optimization (Step 2)**:\nThis step involves solving a series of optimization problems, one for each pair of weights $(Q, S)$ in the provided candidate grid. For each pair, the goal is to find the optimal sequence of control inputs $w_0, \\dots, w_{N-1}$ that minimizes the objective function $J$.\n\nThe objective function $J$ is a weighted sum representing three competing goals:\n- **Tracking**: The term $Q(w_k - w_d)^2$ penalizes deviation of the applied (squared) current $w_k$ from the desired (squared) current $w_d = I_d^2$. A higher $Q$ prioritizes performance.\n- **Smoothness**: The term $R(w_k - w_{k-1})^2$ penalizes large changes in the control input between consecutive time steps, preventing aggressive control actions.\n- **Thermal Safety**: The term $S(\\max(0, T_{s,k} - T_{\\max}))^2$ applies a heavy penalty if the predicted surface temperature $T_{s,k}$ exceeds the safety limit $T_{\\max}$. A higher $S$ prioritizes thermal regulation.\n\nThis is a constrained nonlinear optimization problem, which can be stated as:\n$$ \\underset{w_0, \\dots, w_{N-1}}{\\text{minimize}} \\quad J(w_0, \\dots, w_{N-1}) $$\n$$ \\text{subject to} \\quad 0 \\le w_k \\le w_{\\max} \\quad \\text{for } k=0, \\dots, N-1 $$\n\nTo solve this, a numerical optimizer is required. The `scipy.optimize.minimize` function with the Sequential Least Squares Programming (`SLSQP`) method is well-suited for this task, as it can handle nonlinear objectives with bounds. The objective function passed to the optimizer must, for a given trial sequence of inputs `w`, internally simulate the system dynamics to calculate the state trajectory $T_{s,k}$ needed for the penalty term.\n\n**4. Performance Evaluation and Candidate Selection (Step 3)**:\nAfter obtaining the optimal input sequence $w_{\\text{opt}}$ for a given $(Q, S)$ pair, the system is simulated one last time with this input to find the resulting temperature trajectory. From this trajectory, the controlled overshoot $\\Delta T_{\\text{overshoot,MPC}}$ and the current tracking error $\\text{RMSE}_I$ are calculated. This process is repeated for all $(Q, S)$ pairs.\n\nFinally, the best pair is selected according to the specified logic:\n- First, we identify a subset of solutions that meet the performance criterion, $\\text{RMSE}_I \\le \\varepsilon$.\n- If this subset is non-empty, we sort it first by ascending $\\Delta T_{\\text{overshoot}}$, and then by ascending $S$ to break ties. The top entry is the chosen solution.\n- If no solution meets the performance criterion, we sort all solutions by ascending $\\Delta T_{\\text{overshoot}}$ and choose the top one, regardless of its $\\text{RMSE}_I$.\n\n**5. Reporting (Step 4)**:\nFor each test case, the final result is a list containing the open-loop overshoot, the best-found MPC overshoot, the corresponding $\\text{RMSE}_I$, and the values of $Q$ and $S$ that achieved this result. These are then formatted as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the battery MPC problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: Happy path\n        {\n            'params': {'Cc': 4000, 'Cs': 2000, 'hcs': 10, 'hsa': 5, 'eta': 0.02, 'dt': 1, 'N': 120, 'Tamb': 25, 'Tc0': 25, 'Ts0': 25},\n            'spec': {'Id': 100, 'Tmax': 35, 'epsilon': 10, 'R': 0.01},\n            'grid': {'Q': [0.1, 1.0, 10.0], 'S': [0.1, 1.0, 10.0, 100.0]}\n        },\n        # Case B: Boundary near limit\n        {\n            'params': {'Cc': 4000, 'Cs': 2000, 'hcs': 10, 'hsa': 5, 'eta': 0.02, 'dt': 1, 'N': 120, 'Tamb': 25, 'Tc0': 34, 'Ts0': 34},\n            'spec': {'Id': 100, 'Tmax': 35, 'epsilon': 10, 'R': 0.01},\n            'grid': {'Q': [0.1, 1.0, 10.0], 'S': [0.1, 1.0, 10.0, 100.0]}\n        },\n        # Case C: High ambient, lower current\n        {\n            'params': {'Cc': 4000, 'Cs': 2000, 'hcs': 10, 'hsa': 5, 'eta': 0.02, 'dt': 1, 'N': 120, 'Tamb': 35, 'Tc0': 35, 'Ts0': 35},\n            'spec': {'Id': 80, 'Tmax': 40, 'epsilon': 8, 'R': 0.01},\n            'grid': {'Q': [0.1, 1.0, 10.0], 'S': [0.1, 1.0, 10.0, 100.0]}\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        p = case['params']\n        s = case['spec']\n        g = case['grid']\n\n        # Unpack parameters\n        Cc, Cs, hcs, hsa, eta, dt, N, Tamb, Tc0, Ts0 = p.values()\n        Id, Tmax, epsilon, R = s.values()\n        Q_grid, S_grid = g.values()\n\n        # Define system matrices\n        A_cont = np.array([\n            [-hcs / Cc, hcs / Cc],\n            [hcs / Cs, -(hcs + hsa) / Cs]\n        ])\n        B_cont = np.array([[eta / Cc], [0]])\n        g_cont = np.array([[0], [hsa * Tamb / Cs]])\n\n        # Discretize using Forward Euler\n        I_2 = np.identity(2)\n        Ad = I_2 + dt * A_cont\n        Bd_vec = dt * B_cont\n        gd_vec = dt * g_cont\n\n        w_d = Id**2\n        w_max = Id**2\n\n        # --- Step 1: Open-loop overshoot ---\n        T_ol = np.zeros((N + 1, 2))\n        T_ol[0] = [Tc0, Ts0]\n        for k in range(N):\n            T_ol[k+1] = Ad @ T_ol[k] + (Bd_vec * w_max + gd_vec).flatten()\n        Ts_ol = T_ol[:, 1]\n        overshoot_ol = max(0, np.max(Ts_ol) - Tmax)\n\n        # --- Steps 2 & 3: MPC Optimization and Selection ---\n        w_initial = np.full(N, w_d)\n        bounds = [(0, w_max) for _ in range(N)]\n        w_minus_1 = w_d\n\n        mpc_results = []\n        for Q in Q_grid:\n            for S in S_grid:\n                \n                def objective_func(w):\n                    T_pred = np.zeros((N + 1, 2))\n                    T_pred[0] = [Tc0, Ts0]\n                    for k in range(N):\n                        T_pred[k+1] = Ad @ T_pred[k] + (Bd_vec * w[k] + gd_vec).flatten()\n\n                    J_tracking = Q * np.sum((w - w_d)**2)\n                    \n                    w_lagged = np.insert(w[:-1], 0, w_minus_1)\n                    J_smoothness = R * np.sum((w - w_lagged)**2)\n\n                    Ts_for_J = T_pred[:N, 1]\n                    overshoot_terms = np.maximum(0, Ts_for_J - Tmax)\n                    J_temp_penalty = S * np.sum(overshoot_terms**2)\n                    \n                    return J_tracking + J_smoothness + J_temp_penalty\n\n                opt_res = minimize(\n                    objective_func,\n                    w_initial,\n                    method='SLSQP',\n                    bounds=bounds,\n                    options={'maxiter': 200, 'ftol': 1e-6}\n                )\n                w_opt = opt_res.x\n\n                # Evaluate performance with optimal control sequence\n                T_mpc = np.zeros((N + 1, 2))\n                T_mpc[0] = [Tc0, Ts0]\n                for k in range(N):\n                    T_mpc[k+1] = Ad @ T_mpc[k] + (Bd_vec * w_opt[k] + gd_vec).flatten()\n                \n                Ts_mpc = T_mpc[:, 1]\n                overshoot_mpc = max(0, np.max(Ts_mpc) - Tmax)\n                \n                w_opt_safe = np.maximum(0, w_opt)\n                rmse_I = np.sqrt(np.mean((np.sqrt(w_opt_safe) - Id)**2))\n                \n                mpc_results.append({\n                    'overshoot': overshoot_mpc,\n                    'rmse': rmse_I,\n                    'Q': Q,\n                    'S': S\n                })\n\n        # Select best candidate\n        valid_candidates = [r for r in mpc_results if r['rmse'] <= epsilon]\n\n        if valid_candidates:\n            # Sort by overshoot, then by S\n            best_candidate = sorted(valid_candidates, key=lambda x: (x['overshoot'], x['S']))[0]\n        else:\n            # If no candidate is valid, sort all by overshoot\n            best_candidate = sorted(mpc_results, key=lambda x: x['overshoot'])[0]\n\n        # --- Step 4: Report ---\n        final_result = [\n            round(overshoot_ol, 3),\n            round(best_candidate['overshoot'], 3),\n            round(best_candidate['rmse'], 3),\n            float(best_candidate['Q']),\n            float(best_candidate['S'])\n        ]\n        all_results.append(final_result)\n    \n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world battery systems consist of many cells connected in series, and inherent cell-to-cell variations pose a significant control challenge. This final practice scales the problem up to a multi-cell battery pack, introducing cell balancing currents as additional degrees of freedom for the controller. You will implement an MPC that coordinates the main pack current and individual balancing currents to maximize performance while respecting the voltage limits of every single cell. This exercise powerfully demonstrates a key advantage of MPC: its ability to manage multi-input, multi-output systems and perform \"feasibility recovery\" by intelligently using all available actuators to navigate complex constraints .",
            "id": "3928844",
            "problem": "Consider a series-connected three-cell lithium-ion battery pack whose dynamics over a discrete-time prediction horizon are modeled by the following physically based relations derived from conservation of charge, Ohm’s law, and a linearized open-circuit voltage map. Each cell index is denoted by $i \\in \\{1,2,3\\}$ and time index by $k \\in \\{0,1,\\dots,N-1\\}$. The decision variables at each time step are the pack current $I_k$ and the balancing (bleeder) currents $b_{i,k}$ for each cell. The net cell current is $I_{i,k} = I_k - b_{i,k}$, where the balancing currents represent bypass actuation that redistributes current among cells in the series string. The state-of-charge $s_{i,k}$ evolves according to the conservation of charge\n$$ s_{i,k+1} = s_{i,k} - \\frac{\\Delta t}{Q_i} I_{i,k} , $$\nwhere $Q_i$ is the cell capacity and $\\Delta t$ is the sampling interval. The cell voltage is given by the linear equivalent-circuit relation\n$$ V_{i,k} = V_{\\mathrm{oc},i}(s_{i,k}) - R_i I_{i,k} , \\quad V_{\\mathrm{oc},i}(s) = \\alpha_i + \\beta_i s, $$\nwhere $R_i$ is the internal resistance, $\\alpha_i$ is the intercept of the open-circuit voltage with respect to state-of-charge, and $\\beta_i$ is the slope.\n\nModel Predictive Control (MPC) seeks a sequence $\\{I_k, b_{1,k}, b_{2,k}, b_{3,k}\\}_{k=0}^{N-1}$ to minimize a convex objective subject to voltage safety constraints and actuator bounds. The constraints enforce\n$$ V_{\\min} \\le V_{i,k} \\le V_{\\max}, \\quad 0 \\le b_{i,k} \\le b_{\\max}, \\quad 0 \\le I_k \\le I_{\\max} , $$\nfor all $i,k$. The objective to be minimized is\n$$ J = \\sum_{k=0}^{N-1} \\left( w_{\\mathrm{track}} (I_k - I^{\\mathrm{ref}}_k)^2 + w_{\\mathrm{bleed}} \\sum_{i=1}^{3} b_{i,k}^2 + w_{\\mathrm{slew}} (I_k - I_{k-1})^2 \\right), $$\nwith the convention $I_{-1} = I_0$. Here $I^{\\mathrm{ref}}_k$ is a given load current reference sequence. The balancing currents are penalized in the objective to capture the trade-off between feasibility recovery and increased losses.\n\nYour task is to implement an MPC that, for each provided test case, computes an optimal sequence $\\{I_k, b_{1,k}, b_{2,k}, b_{3,k}\\}$ minimizing $J$ subject to the stated constraints and dynamics. From the optimal solution, compute:\n- A feasibility boolean indicating whether all voltage constraints $V_{\\min} \\le V_{i,k} \\le V_{\\max}$ are satisfied for all $i,k$ within a numerical tolerance of $10^{-6}$.\n- The root-mean-square tracking error in amperes, defined as\n$$ \\mathrm{RMS} = \\sqrt{\\frac{1}{N} \\sum_{k=0}^{N-1} (I_k - I^{\\mathrm{ref}}_k)^2} \\quad \\text{(express in $\\mathrm{A}$)}. $$\n- The total bleed energy in joules over the horizon,\n$$ E_{\\mathrm{bleed}} = \\sum_{k=0}^{N-1} \\sum_{i=1}^{3} V_{i,k} \\, b_{i,k} \\, \\Delta t \\quad \\text{(express in $\\mathrm{J}$)}. $$\n\nDesign your program to handle the following test suite of parameter values, which includes a general case and edge cases targeting boundary behavior:\n\nTest Case $1$ (balanced, happy path):\n- $N = 8$, $\\Delta t = 1.0 \\, \\mathrm{s}$, $I_{\\max} = 6.0 \\, \\mathrm{A}$, $b_{\\max} = 0.5 \\, \\mathrm{A}$.\n- $Q_1 = Q_2 = Q_3 = 3600.0 \\, \\mathrm{A}\\cdot\\mathrm{s}$, $R_1 = R_2 = R_3 = 0.01 \\, \\Omega$.\n- $\\alpha_1 = \\alpha_2 = \\alpha_3 = 3.0 \\, \\mathrm{V}$, $\\beta_1 = \\beta_2 = \\beta_3 = 1.2 \\, \\mathrm{V}$.\n- $V_{\\min} = 3.0 \\, \\mathrm{V}$, $V_{\\max} = 4.2 \\, \\mathrm{V}$.\n- Initial states $s_{1,0} = s_{2,0} = s_{3,0} = 0.6$.\n- Reference $I^{\\mathrm{ref}}_k = 3.0 \\, \\mathrm{A}$ for all $k$.\n- Weights $w_{\\mathrm{track}} = 10.0$, $w_{\\mathrm{bleed}} = 0.1$, $w_{\\mathrm{slew}} = 0.01$.\n\nTest Case $2$ (one cell hits lower voltage limit without balancing; feasibility recovered via balancing):\n- $N = 8$, $\\Delta t = 1.0 \\, \\mathrm{s}$, $I_{\\max} = 6.0 \\, \\mathrm{A}$, $b_{\\max} = 2.0 \\, \\mathrm{A}$.\n- $Q_1 = Q_2 = Q_3 = 3600.0 \\, \\mathrm{A}\\cdot\\mathrm{s}$, $R_1 = 0.05 \\, \\Omega$, $R_2 = R_3 = 0.01 \\, \\Omega$.\n- $\\alpha_1 = \\alpha_2 = \\alpha_3 = 3.0 \\, \\mathrm{V}$, $\\beta_1 = \\beta_2 = \\beta_3 = 1.2 \\, \\mathrm{V}$.\n- $V_{\\min} = 3.0 \\, \\mathrm{V}$, $V_{\\max} = 4.2 \\, \\mathrm{V}$.\n- Initial states $s_{1,0} = 0.2$, $s_{2,0} = 0.5$, $s_{3,0} = 0.5$.\n- Reference $I^{\\mathrm{ref}}_k = 6.0 \\, \\mathrm{A}$ for all $k$.\n- Weights $w_{\\mathrm{track}} = 10.0$, $w_{\\mathrm{bleed}} = 0.1$, $w_{\\mathrm{slew}} = 0.01$.\n\nTest Case $3$ (insufficient balancing; feasibility recovered by reducing pack current):\n- $N = 8$, $\\Delta t = 1.0 \\, \\mathrm{s}$, $I_{\\max} = 6.0 \\, \\mathrm{A}$, $b_{\\max} = 0.2 \\, \\mathrm{A}$.\n- $Q_1 = Q_2 = Q_3 = 3600.0 \\, \\mathrm{A}\\cdot\\mathrm{s}$, $R_1 = 0.05 \\, \\Omega$, $R_2 = R_3 = 0.01 \\, \\Omega$.\n- $\\alpha_1 = \\alpha_2 = \\alpha_3 = 3.0 \\, \\mathrm{V}$, $\\beta_1 = \\beta_2 = \\beta_3 = 1.2 \\, \\mathrm{V}$.\n- $V_{\\min} = 3.0 \\, \\mathrm{V}$, $V_{\\max} = 4.2 \\, \\mathrm{V}$.\n- Initial states $s_{1,0} = 0.2$, $s_{2,0} = 0.5$, $s_{3,0} = 0.5$.\n- Reference $I^{\\mathrm{ref}}_k = 6.0 \\, \\mathrm{A}$ for all $k$.\n- Weights $w_{\\mathrm{track}} = 1.0$, $w_{\\mathrm{bleed}} = 0.1$, $w_{\\mathrm{slew}} = 0.01$.\n\nFor each test case, implement an MPC solver that uses numerical optimization to compute the optimal control sequences. Then compute the feasibility boolean, the root-mean-square tracking error in $\\mathrm{A}$, and the total bleed energy in $\\mathrm{J}$.\n\nFinal Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must itself be a list of the form $[ \\text{feasible boolean}, \\text{RMS tracking error in A}, \\text{bleed energy in J} ]$. For example, the output must be in the form $[[\\text{boolean},\\text{float},\\text{float}],[\\text{boolean},\\text{float},\\text{float}],[\\text{boolean},\\text{float},\\text{float}]]$ with no additional text.",
            "solution": "The user has provided a well-posed problem in the domain of optimal control for battery management systems. The problem is scientifically grounded in established battery modeling principles and is formulated as a convex optimization problem, specifically a Quadratic Program (QP), which guarantees a unique solution. All parameters and conditions are clearly specified, and the test cases are designed to probe different operational regimes of the controller. The problem is valid.\n\nThe task is to implement a Model Predictive Controller (MPC) for a three-cell series-connected battery pack. The MPC must find the optimal sequences of pack current $\\{I_k\\}_{k=0}^{N-1}$ and per-cell balancing currents $\\{b_{i,k}\\}_{k=0}^{N-1}$ over a prediction horizon of length $N$. The optimality is defined by minimizing a quadratic cost function $J$, subject to a set of linear constraints representing the battery dynamics, voltage safety limits, and actuator capabilities.\n\nThe problem is structured as a standard convex QP, which can be expressed in the form:\n$$ \\min_{x} \\frac{1}{2} x^T H x + f^T x \\quad \\text{subject to} \\quad A x \\le b $$\nHere, the decision vector $x$ is a flattened vector containing all decision variables over the horizon:\n$$ x = [I_0, \\dots, I_{N-1}, b_{1,0}, \\dots, b_{1,N-1}, b_{2,0}, \\dots, b_{2,N-1}, b_{3,0}, \\dots, b_{3,N-1}]^T $$\nThe total number of decision variables is $4N$.\n\nThe objective function to minimize is:\n$$ J = \\sum_{k=0}^{N-1} \\left( w_{\\mathrm{track}} (I_k - I^{\\mathrm{ref}}_k)^2 + w_{\\mathrm{bleed}} \\sum_{i=1}^{3} b_{i,k}^2 + w_{\\mathrm{slew}} (I_k - I_{k-1})^2 \\right) $$\nwith the convention $I_{-1} = I_0$. This convention implies that the slew rate penalty $(I_0 - I_{-1})^2$ is zero for the first step, so the effective slew rate term is $\\sum_{k=1}^{N-1} w_{\\mathrm{slew}} (I_k - I_{k-1})^2$. Since all weights ($w_{\\mathrm{track}}, w_{\\mathrm{bleed}}, w_{\\mathrm{slew}}$) are positive, the cost function $J$ is a strictly convex quadratic function of the decision vector $x$.\n\nThe constraints are all linear with respect to the decision variables. The state-of-charge (SOC) dynamics are given by:\n$$ s_{i,k+1} = s_{i,k} - \\frac{\\Delta t}{Q_i} (I_k - b_{i,k}) $$\nBy unrolling this recurrence, the state $s_{i,k}$ at any time step $k$ can be expressed as a linear function of the initial state $s_{i,0}$ and the decision variables $\\{I_j, b_{i,j}\\}_{j=0}^{k-1}$:\n$$ s_{i,k} = s_{i,0} - \\frac{\\Delta t}{Q_i} \\sum_{j=0}^{k-1} (I_j - b_{i,j}) $$\nThe cell voltage $V_{i,k}$ is also a linear function of the decision variables, obtained by substituting the expression for $s_{i,k}$ into the voltage equation:\n$$ V_{i,k} = \\alpha_i + \\beta_i s_{i,k} - R_i (I_k - b_{i,k}) $$\n$$ V_{i,k} = \\alpha_i + \\beta_i \\left( s_{i,0} - \\frac{\\Delta t}{Q_i} \\sum_{j=0}^{k-1} (I_j - b_{i,j}) \\right) - R_i (I_k - b_{i,k}) $$\nThe voltage constraints $V_{\\min} \\le V_{i,k} \\le V_{\\max}$ and the actuator bounds $0 \\le I_k \\le I_{\\max}$, $0 \\le b_{i,k} \\le b_{\\max}$ are therefore all linear inequality constraints on $x$.\n\nThe QP is solved using the `scipy.optimize.minimize` function with the 'SLSQP' (Sequential Least Squares Programming) method, which is well-suited for constrained nonlinear optimization and is efficient for QPs. The implementation involves:\n1.  Defining an objective function that computes $J$ for a given decision vector $x$.\n2.  Defining a set of inequality constraint functions of the form $g(x) \\ge 0$. These are derived from the voltage limits: $V_{i,k} - V_{\\min} \\ge 0$ and $V_{\\max} - V_{i,k} \\ge 0$.\n3.  Defining the box constraints (bounds) for each element of $x$ according to $I_k$ and $b_{i,k}$ limits.\n4.  Providing an initial guess for the optimizer. A logical choice is to set the pack currents equal to the reference currents and all balancing currents to zero.\n\nAfter the optimization yields the optimal decision vector $x^*$, the optimal trajectories for currents ($I_k^*, b_{i,k}^*$), states ($s_{i,k}^*$), and voltages ($V_{i,k}^*$) are computed. From these trajectories, the following three output metrics are calculated for each test case:\n1.  **Feasibility**: A boolean check is performed to confirm if all voltage constraints $V_{\\min} \\le V_{i,k}^* \\le V_{\\max}$ are satisfied for all cells $i$ and time steps $k$ within a numerical tolerance of $10^{-6}$.\n2.  **RMS Tracking Error**: The root-mean-square error between the optimal pack current $I_k^*$ and the reference current $I_k^{\\mathrm{ref}}$ is calculated.\n3.  **Total Bleed Energy**: The total energy dissipated by the balancing circuits is computed by summing the product of cell voltage, balancing current, and the time step duration over all cells and the entire horizon: $E_{\\mathrm{bleed}} = \\sum_{k,i} V_{i,k}^* b_{i,k}^* \\Delta t$.\n\nThe overall process is repeated for each of the three test cases provided, and the results are aggregated into the specified output format.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_mpc_for_case(params):\n    \"\"\"\n    Solves the MPC optimization problem for a single test case.\n    \"\"\"\n    # Unpack parameters\n    N = params['N']\n    dt = params['dt']\n    I_max = params['I_max']\n    b_max = params['b_max']\n    Q = params['Q']\n    R = params['R']\n    alpha = params['alpha']\n    beta = params['beta']\n    Vmin = params['Vmin']\n    Vmax = params['Vmax']\n    s0 = params['s0']\n    I_ref = params['I_ref']\n    w_track = params['w_track']\n    w_bleed = params['w_bleed']\n    w_slew = params['w_slew']\n    \n    num_vars = 4 * N\n\n    # Objective function J(x)\n    def objective(x):\n        I = x[0:N]\n        b = np.reshape(x[N:], (3, N))\n        \n        tracking_cost = w_track * np.sum((I - I_ref)**2)\n        bleed_cost = w_bleed * np.sum(b**2)\n        slew_cost = w_slew * np.sum((I[1:] - I[:-1])**2)\n        \n        return tracking_cost + bleed_cost + slew_cost\n\n    # Inequality constraints: V_min <= V_ik <= V_max\n    def constraints(x):\n        I = x[0:N]\n        b = np.reshape(x[N:], (3, N))\n        I_cell = I[np.newaxis, :] - b # Broadcasting to (3, N)\n\n        # Calculate SOC trajectory s_i,k for k=0..N-1\n        s = np.zeros((3, N))\n        s[:, 0] = s0\n        for k in range(N - 1):\n            s[:, k + 1] = s[:, k] - (dt / Q) * I_cell[:, k]\n\n        # Calculate voltage trajectory V_i,k for k=0..N-1\n        Voc = alpha[:, np.newaxis] + beta[:, np.newaxis] * s\n        V = Voc - R[:, np.newaxis] * I_cell\n    \n        # Constraints are g(x) >= 0\n        # V_ik - Vmin >= 0  and  Vmax - V_ik >= 0\n        c1 = V - Vmin\n        c2 = Vmax - V\n        \n        return np.concatenate([c1.flatten(), c2.flatten()])\n\n    # Bounds for decision variables\n    bounds = []\n    bounds.extend([(0, I_max)] * N)       # I_k bounds\n    bounds.extend([(0, b_max)] * (3 * N))  # b_ik bounds\n\n    # Initial guess for x\n    x0 = np.zeros(num_vars)\n    x0[0:N] = I_ref\n\n    # Solve the QP\n    res = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'disp': False, 'ftol': 1e-9, 'maxiter': 200}\n    )\n    \n    x_opt = res.x\n    I_opt = x_opt[0:N]\n    b_opt = np.reshape(x_opt[N:], (3, N))\n\n    # Re-compute optimal trajectories to calculate final metrics\n    I_cell_opt = I_opt[np.newaxis, :] - b_opt\n    \n    s_opt = np.zeros((3, N))\n    s_opt[:, 0] = s0\n    for k in range(N - 1):\n        s_opt[:, k + 1] = s_opt[:, k] - (dt / Q) * I_cell_opt[:, k]\n        \n    Voc_opt = alpha[:, np.newaxis] + beta[:, np.newaxis] * s_opt\n    V_opt = Voc_opt - R[:, np.newaxis] * I_cell_opt\n\n    # 1. Feasibility check\n    tol = 1e-6\n    feasible = np.all(V_opt >= Vmin - tol) and np.all(V_opt <= Vmax + tol)\n    \n    # 2. RMS tracking error\n    rms_error = np.sqrt(np.mean((I_opt - I_ref)**2))\n    \n    # 3. Total bleed energy\n    bleed_energy = np.sum(V_opt * b_opt * dt)\n    \n    return [feasible, rms_error, bleed_energy]\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 8, \"dt\": 1.0, \"I_max\": 6.0, \"b_max\": 0.5,\n            \"Q\": np.array([3600.0, 3600.0, 3600.0]),\n            \"R\": np.array([0.01, 0.01, 0.01]),\n            \"alpha\": np.array([3.0, 3.0, 3.0]),\n            \"beta\": np.array([1.2, 1.2, 1.2]),\n            \"Vmin\": 3.0, \"Vmax\": 4.2,\n            \"s0\": np.array([0.6, 0.6, 0.6]),\n            \"I_ref\": np.full(8, 3.0),\n            \"w_track\": 10.0, \"w_bleed\": 0.1, \"w_slew\": 0.01,\n        },\n        {\n            \"N\": 8, \"dt\": 1.0, \"I_max\": 6.0, \"b_max\": 2.0,\n            \"Q\": np.array([3600.0, 3600.0, 3600.0]),\n            \"R\": np.array([0.05, 0.01, 0.01]),\n            \"alpha\": np.array([3.0, 3.0, 3.0]),\n            \"beta\": np.array([1.2, 1.2, 1.2]),\n            \"Vmin\": 3.0, \"Vmax\": 4.2,\n            \"s0\": np.array([0.2, 0.5, 0.5]),\n            \"I_ref\": np.full(8, 6.0),\n            \"w_track\": 10.0, \"w_bleed\": 0.1, \"w_slew\": 0.01,\n        },\n        {\n            \"N\": 8, \"dt\": 1.0, \"I_max\": 6.0, \"b_max\": 0.2,\n            \"Q\": np.array([3600.0, 3600.0, 3600.0]),\n            \"R\": np.array([0.05, 0.01, 0.01]),\n            \"alpha\": np.array([3.0, 3.0, 3.0]),\n            \"beta\": np.array([1.2, 1.2, 1.2]),\n            \"Vmin\": 3.0, \"Vmax\": 4.2,\n            \"s0\": np.array([0.2, 0.5, 0.5]),\n            \"I_ref\": np.full(8, 6.0),\n            \"w_track\": 1.0, \"w_bleed\": 0.1, \"w_slew\": 0.01,\n        },\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        result = run_mpc_for_case(case_params)\n        all_results.append(result)\n\n    formatted_results = []\n    for res in all_results:\n        # Convert boolean to string 'True'/'False'\n        bool_val_str = str(res[0])\n        # Format the result list as a string\n        formatted_results.append(f\"[{bool_val_str},{res[1]},{res[2]}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n\n```"
        }
    ]
}