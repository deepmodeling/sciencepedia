{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any successful Model Predictive Control strategy is a reliable model of the system. While many battery models are inherently nonlinear, MPC often leverages linear approximations for computational tractability. This practice will guide you through the essential process of linearizing a nonlinear electro-thermal battery model by deriving its Jacobians, a cornerstone of advanced methods like successive linearization MPC. By numerically validating your analytical derivations, you will develop a critical skill for ensuring the robustness and correctness of your control algorithms .",
            "id": "3928856",
            "problem": "You are given a mildly nonlinear continuous-time battery thermal-electrical model suitable for successive linearization in Model Predictive Control (MPC). Consider an Equivalent Circuit Model (ECM) with a single Resistor-Capacitor (RC) branch, ohmic resistance dependent on temperature, and lumped thermal dynamics. The state vector is $\\mathbf{x} = [s, v, T]^\\top$ where $s$ is state of charge (dimensionless), $v$ is the RC branch capacitor voltage in $\\mathrm{V}$, and $T$ is the cell temperature in $\\mathrm{K}$. The control input is $\\mathbf{u} = I$ in $\\mathrm{A}$, where positive $I$ denotes discharge. The ohmic resistance depends on temperature as $R(T) = R_0 \\exp(\\gamma (T - T_{\\mathrm{ref}}))$, where $R_0$ is in $\\Omega$, $\\gamma$ is in $\\mathrm{K}^{-1}$, and $T_{\\mathrm{ref}}$ is in $\\mathrm{K}$. The RC branch has parameters $R_1$ in $\\Omega$ and $C_1$ in $\\mathrm{F}$, with time constant $\\tau_1 = R_1 C_1$. The nominal capacity is $Q$ in $\\mathrm{C}$, the thermal capacity is $C_{\\mathrm{th}}$ in $\\mathrm{J/K}$, and the convective coefficient-area product is $hA$ in $\\mathrm{W/K}$. The ambient temperature is $T_{\\mathrm{amb}}$ in $\\mathrm{K}$. The continuous-time dynamics are defined by fundamental laws and widely accepted modeling approximations as follows:\n- Conservation of charge in the electrode-electrolyte system gives $ds/dt = -I/Q$.\n- The RC branch follows $dv/dt = -(1/(R_1 C_1)) v + (1/C_1) I$.\n- Lumped thermal energy balance yields $dT/dt = (1/C_{\\mathrm{th}})\\left(R(T) I^2 - hA (T - T_{\\mathrm{amb}})\\right)$.\n\nDefine the discrete-time mapping under forward Euler integration with sampling period $\\Delta t$ seconds as $\\mathbf{g}(\\mathbf{x}, \\mathbf{u}) = \\mathbf{x} + \\Delta t\\, \\mathbf{f}(\\mathbf{x}, \\mathbf{u})$, where $\\mathbf{f}$ collects the continuous-time right-hand sides.\n\nTask:\n1. Starting from the definitions above, derive, from first principles, the analytic Jacobians needed for successive linearization MPC: the discrete-time state Jacobian $\\mathbf{A}_d = \\partial \\mathbf{g}/\\partial \\mathbf{x}$ and the discrete-time input Jacobian $\\mathbf{B}_d = \\partial \\mathbf{g}/\\partial \\mathbf{u}$ at an arbitrary operating point $(\\mathbf{x}_0, \\mathbf{u}_0)$.\n2. Implement a complete, runnable program that:\n   - Encodes the model $\\mathbf{f}$ and mapping $\\mathbf{g}$ in terms of the parameters and variables stated.\n   - Computes the analytic Jacobians $\\mathbf{A}_d$ and $\\mathbf{B}_d$ derived in part 1 at a given operating point.\n   - Validates these Jacobians numerically using central finite differences applied directly to $\\mathbf{g}$ with small, dimensionally consistent perturbations, and checks whether the maximum absolute entry-wise discrepancy between analytic and numerical Jacobians is within specified tolerances.\n   - For each test case, returns a boolean indicating whether both $\\mathbf{A}_d$ and $\\mathbf{B}_d$ pass the validation.\n\nUnits:\n- Use $\\mathrm{A}$ for current $I$, $\\mathrm{V}$ for voltage $v$, and $\\mathrm{K}$ for temperature $T$.\n- The sampling period $\\Delta t$ is in $\\mathrm{s}$.\n- The final program output consists of booleans and is unitless.\n\nNumerical validation details:\n- Use central differences for $\\partial \\mathbf{g}/\\partial \\mathbf{x}$ by perturbing each state component $x_j$ by $\\pm h_{x_j}$ and computing $(\\mathbf{g}(\\mathbf{x} + h_{x_j}\\mathbf{e}_j, \\mathbf{u}) - \\mathbf{g}(\\mathbf{x} - h_{x_j}\\mathbf{e}_j, \\mathbf{u}))/(2 h_{x_j})$.\n- Use central differences for $\\partial \\mathbf{g}/\\partial \\mathbf{u}$ by perturbing $I$ by $\\pm h_u$ and computing $(\\mathbf{g}(\\mathbf{x}, \\mathbf{u} + h_u) - \\mathbf{g}(\\mathbf{x}, \\mathbf{u} - h_u))/(2 h_u)$.\n- Use perturbation magnitudes $h_s$, $h_v$, $h_T$, $h_u$ that are physically small and dimensionally correct.\n- Use absolute tolerances $\\tau_A$ and $\\tau_B$ for validating $\\mathbf{A}_d$ and $\\mathbf{B}_d$, respectively.\n\nParameter values:\n- $Q = 10800\\,\\mathrm{C}$, $R_1 = 0.015\\,\\Omega$, $C_1 = 2000\\,\\mathrm{F}$, $R_0 = 0.02\\,\\Omega$, $\\gamma = 0.01\\,\\mathrm{K}^{-1}$, $T_{\\mathrm{ref}} = 298.15\\,\\mathrm{K}$, $C_{\\mathrm{th}} = 500\\,\\mathrm{J/K}$, $hA = 5\\,\\mathrm{W/K}$, $T_{\\mathrm{amb}} = 298.15\\,\\mathrm{K}$, $\\Delta t = 0.1\\,\\mathrm{s}$.\n- Perturbations: $h_s = 10^{-6}$, $h_v = 10^{-6}\\,\\mathrm{V}$, $h_T = 10^{-6}\\,\\mathrm{K}$, $h_u = 10^{-6}\\,\\mathrm{A}$.\n- Tolerances: $\\tau_A = 10^{-8}$, $\\tau_B = 10^{-8}$.\n\nTest suite operating points $(\\mathbf{x}_0, \\mathbf{u}_0)$:\n- Case 1 (typical mid-range): $\\mathbf{x}_0 = [0.5, 0.0, 298.15]$, $\\mathbf{u}_0 = 10.0$.\n- Case 2 (low temperature boundary): $\\mathbf{x}_0 = [0.8, 0.1, 263.15]$, $\\mathbf{u}_0 = 5.0$.\n- Case 3 (charging at elevated temperature): $\\mathbf{x}_0 = [0.2, -0.05, 308.15]$, $\\mathbf{u}_0 = -8.0$.\n- Case 4 (no current edge): $\\mathbf{x}_0 = [0.9, 0.0, 298.15]$, $\\mathbf{u}_0 = 0.0$.\n- Case 5 (high discharge at high temperature): $\\mathbf{x}_0 = [0.1, 0.2, 318.15]$, $\\mathbf{u}_0 = 20.0$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}]$, where each result is a boolean for the corresponding test case.",
            "solution": "The problem has been validated and is deemed valid. It is scientifically grounded in standard battery modeling principles, well-posed with a clear objective, and provides all necessary data and constraints for a unique solution. The model equations and units are internally consistent.\n\nThe task is to derive the analytic Jacobians of a discrete-time battery model and implement a program to verify them numerically. The model is based on a forward Euler discretization of a continuous-time system.\n\nLet the state vector be $\\mathbf{x} = [s, v, T]^\\top$, where $s$ is the state of charge, $v$ is the RC branch capacitor voltage, and $T$ is the cell temperature. The input is the current $\\mathbf{u} = I$. The continuous-time dynamics are given by $\\dot{\\mathbf{x}} = \\mathbf{f}(\\mathbf{x}, \\mathbf{u})$, where:\n$$\n\\mathbf{f}(\\mathbf{x}, \\mathbf{u}) =\n\\begin{bmatrix}\nf_1(s, v, T, I) \\\\\nf_2(s, v, T, I) \\\\\nf_3(s, v, T, I)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-I/Q \\\\\n-\\frac{1}{R_1 C_1} v + \\frac{1}{C_1} I \\\\\n\\frac{1}{C_{\\mathrm{th}}}\\left(R(T) I^2 - hA (T - T_{\\mathrm{amb}})\\right)\n\\end{bmatrix}\n$$\nThe temperature-dependent resistance is defined as $R(T) = R_0 \\exp(\\gamma (T - T_{\\mathrm{ref}}))$.\n\nThe discrete-time dynamics are obtained using the forward Euler method with a sampling period $\\Delta t$:\n$$\n\\mathbf{x}_{k+1} = \\mathbf{g}(\\mathbf{x}_k, \\mathbf{u}_k) = \\mathbf{x}_k + \\Delta t \\, \\mathbf{f}(\\mathbf{x}_k, \\mathbf{u}_k)\n$$\nExplicitly, the components of $\\mathbf{g}$ are:\n$$\n\\mathbf{g}(\\mathbf{x}, \\mathbf{u}) =\n\\begin{bmatrix}\ng_1 \\\\ g_2 \\\\ g_3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\ns - \\frac{\\Delta t}{Q} I \\\\\nv - \\frac{\\Delta t}{R_1 C_1} v + \\frac{\\Delta t}{C_1} I \\\\\nT + \\frac{\\Delta t}{C_{\\mathrm{th}}}\\left(R(T) I^2 - hA (T - T_{\\mathrm{amb}})\\right)\n\\end{bmatrix}\n$$\n\nThe goal is to find the Jacobians of this discrete-time map, $\\mathbf{A}_d = \\partial \\mathbf{g} / \\partial \\mathbf{x}$ and $\\mathbf{B}_d = \\partial \\mathbf{g} / \\partial \\mathbf{u}$, evaluated at an operating point $(\\mathbf{x}_0, \\mathbf{u}_0)$.\n\nDerivation of the State Jacobian $\\mathbf{A}_d$:\nThe state Jacobian is a $3 \\times 3$ matrix defined as $\\mathbf{A}_d = \\partial \\mathbf{g} / \\partial \\mathbf{x}$. Using the definition of $\\mathbf{g}$, we can write:\n$$\n\\mathbf{A}_d = \\frac{\\partial}{\\partial \\mathbf{x}} \\left( \\mathbf{x} + \\Delta t \\, \\mathbf{f}(\\mathbf{x}, \\mathbf{u}) \\right) = \\mathbf{I} + \\Delta t \\frac{\\partial \\mathbf{f}(\\mathbf{x}, \\mathbf{u})}{\\partial \\mathbf{x}}\n$$\nwhere $\\mathbf{I}$ is the $3 \\times 3$ identity matrix. We must compute the Jacobian of the continuous-time dynamics, $\\mathbf{A}_c = \\partial \\mathbf{f} / \\partial \\mathbf{x}$. Its entries are $(\\mathbf{A}_c)_{ij} = \\partial f_i / \\partial x_j$, where $\\mathbf{x} = [x_1, x_2, x_3]^\\top = [s, v, T]^\\top$.\n\nThe partial derivatives are:\n$\\frac{\\partial f_1}{\\partial s} = 0$, $\\frac{\\partial f_1}{\\partial v} = 0$, $\\frac{\\partial f_1}{\\partial T} = 0$.\n$\\frac{\\partial f_2}{\\partial s} = 0$, $\\frac{\\partial f_2}{\\partial v} = -\\frac{1}{R_1 C_1}$, $\\frac{\\partial f_2}{\\partial T} = 0$.\n$\\frac{\\partial f_3}{\\partial s} = 0$, $\\frac{\\partial f_3}{\\partial v} = 0$.\nFor the derivative with respect to $T$:\n$$\n\\frac{\\partial f_3}{\\partial T} = \\frac{\\partial}{\\partial T} \\left[ \\frac{1}{C_{\\mathrm{th}}}\\left(R_0 \\exp(\\gamma (T - T_{\\mathrm{ref}})) I^2 - hA (T - T_{\\mathrm{amb}})\\right) \\right]\n$$\n$$\n\\frac{\\partial f_3}{\\partial T} = \\frac{1}{C_{\\mathrm{th}}} \\left( R_0 \\exp(\\gamma (T - T_{\\mathrm{ref}})) \\cdot \\gamma \\cdot I^2 - hA \\right) = \\frac{1}{C_{\\mathrm{th}}} \\left( \\gamma R(T) I^2 - hA \\right)\n$$\nCombining these results, we get the continuous-time state Jacobian:\n$$\n\\mathbf{A}_c = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{x}} =\n\\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & -\\frac{1}{R_1 C_1} & 0 \\\\\n0 & 0 & \\frac{1}{C_{\\mathrm{th}}} \\left( \\gamma R(T) I^2 - hA \\right)\n\\end{bmatrix}\n$$\nThe discrete-time state Jacobian is therefore:\n$$\n\\mathbf{A}_d = \\mathbf{I} + \\Delta t \\mathbf{A}_c =\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & 1 - \\frac{\\Delta t}{R_1 C_1} & 0 \\\\\n0 & 0 & 1 + \\frac{\\Delta t}{C_{\\mathrm{th}}} \\left( \\gamma R(T) I^2 - hA \\right)\n\\end{bmatrix}\n$$\n\nDerivation of the Input Jacobian $\\mathbf{B}_d$:\nThe input Jacobian is a $3 \\times 1$ matrix (vector) defined as $\\mathbf{B}_d = \\partial \\mathbf{g} / \\partial \\mathbf{u} = \\partial \\mathbf{g} / \\partial I$.\n$$\n\\mathbf{B}_d = \\frac{\\partial}{\\partial I} \\left( \\mathbf{x} + \\Delta t \\, \\mathbf{f}(\\mathbf{x}, \\mathbf{u}) \\right) = \\Delta t \\frac{\\partial \\mathbf{f}(\\mathbf{x}, \\mathbf{u})}{\\partial I}\n$$\nWe compute the derivatives of each component of $\\mathbf{f}$ with respect to $I$:\n$\\frac{\\partial f_1}{\\partial I} = -\\frac{1}{Q}$.\n$\\frac{\\partial f_2}{\\partial I} = \\frac{1}{C_1}$.\n$\\frac{\\partial f_3}{\\partial I} = \\frac{\\partial}{\\partial I} \\left[ \\frac{1}{C_{\\mathrm{th}}}\\left(R(T) I^2 - hA (T - T_{\\mathrm{amb}})\\right) \\right] = \\frac{1}{C_{\\mathrm{th}}} \\left( R(T) \\cdot 2I \\right) = \\frac{2 R(T) I}{C_{\\mathrm{th}}}$.\n\nThe continuous-time input Jacobian is:\n$$\n\\mathbf{B}_c = \\frac{\\partial \\mathbf{f}}{\\partial I} =\n\\begin{bmatrix}\n-1/Q \\\\\n1/C_1 \\\\\n\\frac{2 R(T) I}{C_{\\mathrm{th}}}\n\\end{bmatrix}\n$$\nThe discrete-time input Jacobian is:\n$$\n\\mathbf{B}_d = \\Delta t \\mathbf{B}_c =\n\\begin{bmatrix}\n-\\Delta t / Q \\\\\n\\Delta t / C_1 \\\\\n\\frac{2 \\Delta t R(T) I}{C_{\\mathrm{th}}}\n\\end{bmatrix}\n$$\nBoth Jacobians $\\mathbf{A}_d$ and $\\mathbf{B}_d$ must be evaluated at the specific operating point $(\\mathbf{x}_0, \\mathbf{u}_0)$, meaning $T=T_0$ and $I=I_0$ are used in the expressions.\n\nThe implementation will encode these derived analytic formulas and compare them to results from a central finite difference approximation applied to the function $\\mathbf{g}(\\mathbf{x}, \\mathbf{u})$, confirming the correctness of the derivation. The maximum absolute entry-wise error between the analytic and numerical Jacobians will be checked against a given tolerance.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the battery model Jacobian validation problem.\n    This function defines the model, computes analytic and numerical Jacobians,\n    compares them, and outputs the validation results for a suite of test cases.\n    \"\"\"\n\n    # Define model parameters\n    params = {\n        'Q': 10800.0,      # Nominal capacity (C)\n        'R1': 0.015,       # RC branch resistance (Ohm)\n        'C1': 2000.0,      # RC branch capacitance (F)\n        'R0': 0.02,        # Ohmic resistance base (Ohm)\n        'gamma': 0.01,     # Temperature coefficient for R0 (1/K)\n        'T_ref': 298.15,   # Reference temperature for R0 (K)\n        'C_th': 500.0,     # Thermal capacity (J/K)\n        'hA': 5.0,         # Convective coefficient-area product (W/K)\n        'T_amb': 298.15,   # Ambient temperature (K)\n        'dt': 0.1,         # Sampling period (s)\n    }\n\n    # Define validation parameters\n    validation_params = {\n        'h_x': np.array([1e-6, 1e-6, 1e-6]),  # Perturbations for s, v, T\n        'h_u': 1e-6,                         # Perturbation for I (A)\n        'tol_A': 1e-8,                       # Tolerance for A_d\n        'tol_B': 1e-8,                       # Tolerance for B_d\n    }\n\n    # Define test suite operating points (x0, u0)\n    # x0 = [s, v, T], u0 = I\n    test_cases = [\n        # Case 1 (typical mid-range)\n        (np.array([0.5, 0.0, 298.15]), 10.0),\n        # Case 2 (low temperature boundary)\n        (np.array([0.8, 0.1, 263.15]), 5.0),\n        # Case 3 (charging at elevated temperature)\n        (np.array([0.2, -0.05, 308.15]), -8.0),\n        # Case 4 (no current edge)\n        (np.array([0.9, 0.0, 298.15]), 0.0),\n        # Case 5 (high discharge at high temperature)\n        (np.array([0.1, 0.2, 318.15]), 20.0),\n    ]\n\n    # --- Model Functions ---\n\n    def R_func(T, p):\n        \"\"\"Computes ohmic resistance R(T).\"\"\"\n        return p['R0'] * np.exp(p['gamma'] * (T - p['T_ref']))\n\n    def f_func(x, u, p):\n        \"\"\"Computes continuous-time dynamics dx/dt = f(x, u).\"\"\"\n        s, v, T = x\n        I = u\n        \n        ds_dt = -I / p['Q']\n        dv_dt = -v / (p['R1'] * p['C1']) + I / p['C1']\n        \n        joule_heat = R_func(T, p) * I**2\n        convective_heat = p['hA'] * (T - p['T_amb'])\n        dT_dt = (joule_heat - convective_heat) / p['C_th']\n        \n        return np.array([ds_dt, dv_dt, dT_dt])\n\n    def g_func(x, u, p):\n        \"\"\"Computes discrete-time mapping x_k+1 = g(x_k, u_k) via Forward Euler.\"\"\"\n        return x + p['dt'] * f_func(x, u, p)\n\n    # --- Analytic Jacobian Functions ---\n\n    def compute_Ad_analytic(x, u, p):\n        \"\"\"Computes the analytic discrete-time state Jacobian A_d.\"\"\"\n        _, _, T = x\n        I = u\n        \n        A_d = np.identity(3)\n        A_d[1, 1] = 1.0 - p['dt'] / (p['R1'] * p['C1'])\n        \n        R_T = R_func(T, p)\n        df3_dT = (p['gamma'] * R_T * I**2 - p['hA']) / p['C_th']\n        A_d[2, 2] = 1.0 + p['dt'] * df3_dT\n        \n        return A_d\n\n    def compute_Bd_analytic(x, u, p):\n        \"\"\"Computes the analytic discrete-time input Jacobian B_d.\"\"\"\n        _, _, T = x\n        I = u\n        \n        B_d = np.zeros((3, 1))\n        B_d[0, 0] = -p['dt'] / p['Q']\n        B_d[1, 0] = p['dt'] / p['C1']\n        \n        R_T = R_func(T, p)\n        df3_dI = (2.0 * R_T * I) / p['C_th']\n        B_d[2, 0] = p['dt'] * df3_dI\n        \n        return B_d\n\n    # --- Numerical Jacobian Functions (Central Differences) ---\n\n    def compute_Ad_numeric(x, u, p, vp):\n        \"\"\"Computes the numerical discrete-time state Jacobian A_d.\"\"\"\n        A_d_num = np.zeros((3, 3))\n        h_vec = vp['h_x']\n        for j in range(3):\n            h_j = h_vec[j]\n            e_j = np.zeros(3)\n            e_j[j] = 1.0\n            \n            g_plus = g_func(x + h_j * e_j, u, p)\n            g_minus = g_func(x - h_j * e_j, u, p)\n            \n            A_d_num[:, j] = (g_plus - g_minus) / (2.0 * h_j)\n        return A_d_num\n\n    def compute_Bd_numeric(x, u, p, vp):\n        \"\"\"Computes the numerical discrete-time input Jacobian B_d.\"\"\"\n        h = vp['h_u']\n        \n        g_plus = g_func(x, u + h, p)\n        g_minus = g_func(x, u - h, p)\n        \n        B_d_num = (g_plus - g_minus) / (2.0 * h)\n        return B_d_num.reshape((3, 1))\n\n\n    # --- Main Loop for Validation ---\n    \n    results = []\n    for x0, u0 in test_cases:\n        # Compute analytic Jacobians\n        Ad_analytic = compute_Ad_analytic(x0, u0, params)\n        Bd_analytic = compute_Bd_analytic(x0, u0, params)\n\n        # Compute numerical Jacobians\n        Ad_numeric = compute_Ad_numeric(x0, u0, params, validation_params)\n        Bd_numeric = compute_Bd_numeric(x0, u0, params, validation_params)\n\n        # Validate A_d\n        diff_A = np.max(np.abs(Ad_analytic - Ad_numeric))\n        is_A_valid = diff_A = validation_params['tol_A']\n\n        # Validate B_d\n        diff_B = np.max(np.abs(Bd_analytic - Bd_numeric))\n        is_B_valid = diff_B = validation_params['tol_B']\n\n        # Append result if both validations pass\n        results.append(is_A_valid and is_B_valid)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "One of the most critical tasks in battery management is ensuring thermal safety, especially during high-performance operations like fast charging. This exercise moves from modeling to active control design, challenging you to build an MPC that proactively prevents temperature violations. You will learn how MPC uses its predictive horizon to anticipate future thermal overshoot and modulate the charging current accordingly, providing a powerful demonstration of balancing aggressive performance goals with strict safety constraints by tuning the controller's objective function .",
            "id": "3928791",
            "problem": "You are given a physically realistic, two-node lumped electro-thermal battery model and must implement a Model Predictive Control (MPC) strategy to mitigate temperature overshoot under a step current input while maintaining performance. The task requires deriving the discrete-time thermal dynamics from first principles and formulating a finite-horizon MPC that balances current tracking with thermal regulation. You must compute the worst-case temperature overshoot under an open-loop step current, then design MPC weights to reduce the overshoot subject to a performance constraint. All answers must be expressed numerically and produced by a complete, runnable program.\n\nThe fundamental base consists of the following well-tested physical laws and definitions:\n- Joule heating: the power generated internally by resistive losses is $P = I^2 R$, where $I$ is current and $R$ is internal resistance.\n- Lumped thermal energy balance: for a node with thermal capacitance $C$, the temperature dynamics obey $C \\, \\frac{dT}{dt} = \\text{net heat inflow}$.\n- Two-node thermal network with a core and a surface:\n  - Core node temperature $T_c$ with thermal capacitance $C_c$ and conduction to surface with thermal conductance $h_{cs}$.\n  - Surface node temperature $T_s$ with thermal capacitance $C_s$, conduction from core with thermal conductance $h_{cs}$, and convection to ambient temperature $T_{\\text{amb}}$ with thermal conductance $h_{sa}$.\n- The continuous-time model is\n  $$C_c \\frac{dT_c}{dt} = - h_{cs} (T_c - T_s) + \\eta I^2,$$\n  $$C_s \\frac{dT_s}{dt} = h_{cs} (T_c - T_s) - h_{sa} (T_s - T_{\\text{amb}}),$$\n  where $\\eta$ is the fraction of resistive heating applied to the core (for a simple Joule model $\\eta = R$).\n\nDiscretize the above dynamics using forward Euler with sample time $\\Delta t$ to obtain the affine, discrete-time dynamics\n$$\n\\begin{bmatrix}\nT_{c,k+1} \\\\\nT_{s,k+1}\n\\end{bmatrix}\n=\n\\left(I_2 + \\Delta t \\, A\\right)\n\\begin{bmatrix}\nT_{c,k} \\\\\nT_{s,k}\n\\end{bmatrix}\n+ \\Delta t \\, B \\, w_k + \\Delta t \\, g,\n$$\nwhere $w_k = I_k^2$, $A = \\begin{bmatrix} -\\frac{h_{cs}}{C_c}  \\frac{h_{cs}}{C_c} \\\\ \\frac{h_{cs}}{C_s}  -\\frac{h_{cs} + h_{sa}}{C_s} \\end{bmatrix}$, $B = \\begin{bmatrix} \\frac{\\eta}{C_c} \\\\ 0 \\end{bmatrix}$, and $g = \\begin{bmatrix} 0 \\\\ \\frac{h_{sa}}{C_s} T_{\\text{amb}} \\end{bmatrix}$.\n\nDefine the step current command as $I_d$ (assume $I_d \\ge 0$), and the squared-current input bound as $w_{\\max} = I_d^2$. The open-loop step input applies $w_k = w_{\\max}$ for all $k$ over the finite horizon of $N$ steps.\n\nDefine the worst-case temperature overshoot relative to a temperature limit $T_{\\max}$ as\n$$\n\\Delta T_{\\text{overshoot}} = \\max\\left(0, \\max_{0 \\le k \\le N} \\left( T_{s,k} - T_{\\max} \\right) \\right),\n$$\nexpressed in degrees Celsius (°C).\n\nFormulate a finite-horizon MPC with decision variables $w_0, w_1, \\dots, w_{N-1}$ subject to bounds $0 \\le w_k \\le w_{\\max}$ to minimize the objective\n$$\nJ = \\sum_{k=0}^{N-1} \\left[ Q \\left(w_k - w_d\\right)^2 + R \\left(w_k - w_{k-1}\\right)^2 + S \\left( \\max\\left(0, T_{s,k} - T_{\\max}\\right) \\right)^2 \\right],\n$$\nwhere $w_d = I_d^2$, $Q \\ge 0$ is the tracking weight, $R \\ge 0$ is the smoothness weight, $S \\ge 0$ is the temperature penalty weight, and $w_{-1}$ is defined as $w_{-1} = w_d$ for the first step. The MPC is evaluated in an open-loop predictive manner using the given discrete-time thermal model.\n\nPerformance is measured as the root mean square error (RMSE) of the current tracking:\n$$\n\\text{RMSE}_I = \\sqrt{ \\frac{1}{N} \\sum_{k=0}^{N-1} \\left( \\sqrt{w_k} - I_d \\right)^2 },\n$$\nexpressed in amperes (A). The design requirement is to select weights $(Q, S)$ from a candidate grid with a fixed $R$ such that $\\Delta T_{\\text{overshoot}}$ is minimized subject to $\\text{RMSE}_I \\le \\varepsilon$, where $\\varepsilon$ is a performance threshold.\n\nImplement the following algorithm for each test case:\n- Step $1$: Compute the open-loop worst-case temperature overshoot under the step input $w_k = w_{\\max}$.\n- Step $2$: For each $(Q, S)$ pair in the candidate grid, solve the bounded optimization for $w_{0:N-1}$ using the discrete-time model and objective $J$, then compute the resulting overshoot and $\\text{RMSE}_I$.\n- Step $3$: Among candidates satisfying $\\text{RMSE}_I \\le \\varepsilon$, select the one with the smallest overshoot; in case of ties, select the one with the smallest $S$; if none satisfy the constraint, select the candidate with the smallest overshoot and report its $\\text{RMSE}_I$.\n- Step $4$: Report the open-loop overshoot, the MPC overshoot at the selected weights, the $\\text{RMSE}_I$, and the selected $(Q, S)$.\n\nUnits and numerical requirements:\n- Temperatures must be handled in degrees Celsius; report overshoot in degrees Celsius, rounded to three decimal places.\n- Currents must be in amperes; report $\\text{RMSE}_I$ in amperes, rounded to three decimal places.\n- Angles do not apply in this problem.\n- All times are in seconds.\n\nTest suite:\n- Case A (happy path): $C_c = 4000$, $C_s = 2000$, $h_{cs} = 10$, $h_{sa} = 5$, $\\eta = 0.02$, $\\Delta t = 1$, $N = 120$, $T_{\\text{amb}} = 25$, $T_{c,0} = 25$, $T_{s,0} = 25$, $I_d = 100$, $T_{\\max} = 35$, $\\varepsilon = 10$, $R = 0.01$, candidate $Q \\in \\{0.1, 1.0, 10.0\\}$, candidate $S \\in \\{0.1, 1.0, 10.0, 100.0\\}$.\n- Case B (boundary near limit): $C_c = 4000$, $C_s = 2000$, $h_{cs} = 10$, $h_{sa} = 5$, $\\eta = 0.02$, $\\Delta t = 1$, $N = 120$, $T_{\\text{amb}} = 25$, $T_{c,0} = 34$, $T_{s,0} = 34$, $I_d = 100$, $T_{\\max} = 35$, $\\varepsilon = 10$, $R = 0.01$, candidate $Q \\in \\{0.1, 1.0, 10.0\\}$, candidate $S \\in \\{0.1, 1.0, 10.0, 100.0\\}$.\n- Case C (high ambient, lower current): $C_c = 4000$, $C_s = 2000$, $h_{cs} = 10$, $h_{sa} = 5$, $\\eta = 0.02$, $\\Delta t = 1$, $N = 120$, $T_{\\text{amb}} = 35$, $T_{c,0} = 35$, $T_{s,0} = 35$, $I_d = 80$, $T_{\\max} = 40$, $\\varepsilon = 8$, $R = 0.01$, candidate $Q \\in \\{0.1, 1.0, 10.0\\}$, candidate $S \\in \\{0.1, 1.0, 10.0, 100.0\\}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a bracketed comma-separated list of five floats in the order: $[\\Delta T_{\\text{overshoot,open}}, \\Delta T_{\\text{overshoot,MPC}}, \\text{RMSE}_I, Q, S]$. For example: $[[1.234,0.987,2.345,1.0,10.0],[...],[...]]$.",
            "solution": "The user has provided a problem that requires the design and evaluation of a Model Predictive Control (MPC) strategy for the thermal management of a battery. The problem is to be solved for a set of test cases.\n\n### Step 1: Extract Givens\n\nThe givens for this problem are:\n- **System Model**: A two-node lumped electro-thermal battery model.\n  - Core temperature: $T_c$, Surface temperature: $T_s$.\n  - Thermal capacitances: $C_c$, $C_s$.\n  - Thermal conductances: $h_{cs}$ (core-surface), $h_{sa}$ (surface-ambient).\n  - Ambient temperature: $T_{\\text{amb}}$.\n  - Resistive heating fraction: $\\eta$. The problem text states \"for a simple Joule model $\\eta = R$,\" where $R$ would be internal resistance. Here, $\\eta$ is given as a numerical value, representing the lumped effect of resistance and the fraction of heat generated in the core.\n  - Current: $I$.\n- **Continuous-Time Dynamics**:\n  $$C_c \\frac{dT_c}{dt} = - h_{cs} (T_c - T_s) + \\eta I^2$$\n  $$C_s \\frac{dT_s}{dt} = h_{cs} (T_c - T_s) - h_{sa} (T_s - T_{\\text{amb}})$$\n- **Discrete-Time Dynamics**: A forward Euler discretization with sample time $\\Delta t$.\n  $$\n  \\begin{bmatrix}\n  T_{c,k+1} \\\\\n  T_{s,k+1}\n  \\end{bmatrix}\n  =\n  \\mathbf{A_d}\n  \\begin{bmatrix}\n  T_{c,k} \\\\\n  T_{s,k}\n  \\end{bmatrix}\n  + \\mathbf{B_d} \\, w_k + \\mathbf{g_d}\n  $$\n  where $w_k = I_k^2$, and the matrices are defined as:\n  $$ \\mathbf{A_d} = I_2 + \\Delta t \\, A, \\quad \\mathbf{B_d} = \\Delta t \\, B, \\quad \\mathbf{g_d} = \\Delta t \\, g $$\n  $$ A = \\begin{bmatrix} -\\frac{h_{cs}}{C_c}  \\frac{h_{cs}}{C_c} \\\\ \\frac{h_{cs}}{C_s}  -\\frac{h_{cs} + h_{sa}}{C_s} \\end{bmatrix}, \\quad B = \\begin{bmatrix} \\frac{\\eta}{C_c} \\\\ 0 \\end{bmatrix}, \\quad g = \\begin{bmatrix} 0 \\\\ \\frac{h_{sa}}{C_s} T_{\\text{amb}} \\end{bmatrix} $$\n- **Control Problem**:\n  - Desired current: $I_d \\ge 0$. Desired squared-current: $w_d = I_d^2$.\n  - Control input bounds: $0 \\le w_k \\le w_{\\max}$, where $w_{\\max} = I_d^2$.\n  - Prediction horizon: $N$ steps.\n- **Metrics**:\n  - Worst-case temperature overshoot: $\\Delta T_{\\text{overshoot}} = \\max\\left(0, \\max_{0 \\le k \\le N} \\left( T_{s,k} - T_{\\max} \\right) \\right)$, where $T_{\\max}$ is a temperature limit.\n  - Current tracking RMSE: $\\text{RMSE}_I = \\sqrt{ \\frac{1}{N} \\sum_{k=0}^{N-1} \\left( \\sqrt{w_k} - I_d \\right)^2 }$.\n- **MPC Objective Function**:\n  $$ J = \\sum_{k=0}^{N-1} \\left[ Q \\left(w_k - w_d\\right)^2 + R \\left(w_k - w_{k-1}\\right)^2 + S \\left( \\max\\left(0, T_{s,k} - T_{\\max}\\right) \\right)^2 \\right] $$\n  - Weights: $Q$ (tracking), $R$ (smoothness), $S$ (temperature penalty).\n  - Initial condition for smoothness term: $w_{-1} = w_d$.\n- **Design Task**: Find weights $(Q, S)$ from a given grid that minimize $\\Delta T_{\\text{overshoot}}$ subject to a performance constraint $\\text{RMSE}_I \\le \\varepsilon$.\n- **Selection Logic**:\n  1.  Filter candidates satisfying $\\text{RMSE}_I \\le \\varepsilon$.\n  2.  From the filtered set, select the one with the smallest $\\Delta T_{\\text{overshoot}}$.\n  3.  Break ties using the smallest $S$.\n  4.  If no candidate satisfies the constraint, select the one with the overall smallest $\\Delta T_{\\text{overshoot}}$.\n- **Test Cases**: Three distinct test cases (A, B, C) are provided with all necessary numerical parameters.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is based on fundamental principles of thermodynamics and control theory. The two-node thermal model is a standard and physically realistic simplification for battery analysis. The MPC formulation is a canonical approach to constrained optimal control.\n2.  **Well-Posed**: The problem is well-posed. The system dynamics are linear and time-invariant (affine), the objective function is convex (as it is a sum of squared terms and squared hinge loss terms), and the constraints are simple bounds. This structure guarantees that a unique optimal solution exists for the MPC optimization subproblem. The overall task is a search over a discrete grid of parameters, which is also well-defined.\n3.  **Objective**: The problem is stated in precise mathematical and algorithmic terms, free of subjectivity or ambiguity.\n4.  **Completeness**: All required data, constants, initial conditions, and parameter grids are provided for each test case, making the problem self-contained.\n5.  **Consistency**: There are no contradictions in the problem statement. The definitions, equations, and algorithmic steps are logically consistent.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. It is a well-defined and scientifically sound problem in the domain of control engineering applied to battery systems. I will proceed with the full solution.\n\n### Principle-Based Solution Derivation\n\nThe solution will be implemented by adhering to the four-step algorithm specified in the problem description for each test case.\n\n**1. System Discretization**:\nFirst, for each test case, the continuous-time system matrices $A$ and vectors $B, g$ are constructed using the given physical parameters ($C_c, C_s, h_{cs}, h_{sa}, \\eta, T_{\\text{amb}}$). The discrete-time system matrices $\\mathbf{A_d}$, $\\mathbf{B_d}$, and vector $\\mathbf{g_d}$ are then computed using the forward Euler method with the specified sampling time $\\Delta t$.\n\n**2. Open-Loop Analysis (Step 1)**:\nThe open-loop response is simulated by applying a constant step input of squared-current $w_k = w_{\\max} = I_d^2$ for the entire horizon $k=0, \\dots, N-1$. Starting from the initial state $(T_{c,0}, T_{s,0})$, the state trajectory is propagated for $N$ steps using the discrete-time equation:\n$$ \\begin{bmatrix} T_{c,k+1} \\\\ T_{s,k+1} \\end{bmatrix} = \\mathbf{A_d} \\begin{bmatrix} T_{c,k} \\\\ T_{s,k} \\end{bmatrix} + \\mathbf{B_d} w_{\\max} + \\mathbf{g_d} $$\nThe simulation yields a sequence of surface temperatures $T_{s,0}, T_{s,1}, \\dots, T_{s,N}$. The open-loop overshoot, $\\Delta T_{\\text{overshoot,open}}$, is then calculated as the maximum temperature reached above the limit $T_{\\max}$ over this trajectory.\n\n**3. MPC Formulation and Optimization (Step 2)**:\nThis step involves solving a series of optimization problems, one for each pair of weights $(Q, S)$ in the provided candidate grid. For each pair, the goal is to find the optimal sequence of control inputs $w_0, \\dots, w_{N-1}$ that minimizes the objective function $J$.\n\nThe objective function $J$ is a weighted sum representing three competing goals:\n- **Tracking**: The term $Q(w_k - w_d)^2$ penalizes deviation of the applied (squared) current $w_k$ from the desired (squared) current $w_d = I_d^2$. A higher $Q$ prioritizes performance.\n- **Smoothness**: The term $R(w_k - w_{k-1})^2$ penalizes large changes in the control input between consecutive time steps, preventing aggressive control actions.\n- **Thermal Safety**: The term $S(\\max(0, T_{s,k} - T_{\\max}))^2$ applies a heavy penalty if the predicted surface temperature $T_{s,k}$ exceeds the safety limit $T_{\\max}$. A higher $S$ prioritizes thermal regulation.\n\nThis is a constrained nonlinear optimization problem, which can be stated as:\n$$ \\underset{w_0, \\dots, w_{N-1}}{\\text{minimize}} \\quad J(w_0, \\dots, w_{N-1}) $$\n$$ \\text{subject to} \\quad 0 \\le w_k \\le w_{\\max} \\quad \\text{for } k=0, \\dots, N-1 $$\n\nTo solve this, a numerical optimizer is required. The `scipy.optimize.minimize` function with the Sequential Least Squares Programming (`SLSQP`) method is well-suited for this task, as it can handle nonlinear objectives with bounds. The objective function passed to the optimizer must, for a given trial sequence of inputs `w`, internally simulate the system dynamics to calculate the state trajectory $T_{s,k}$ needed for the penalty term.\n\n**4. Performance Evaluation and Candidate Selection (Step 3)**:\nAfter obtaining the optimal input sequence $w_{\\text{opt}}$ for a given $(Q, S)$ pair, the system is simulated one last time with this input to find the resulting temperature trajectory. From this trajectory, the controlled overshoot $\\Delta T_{\\text{overshoot,MPC}}$ and the current tracking error $\\text{RMSE}_I$ are calculated. This process is repeated for all $(Q, S)$ pairs.\n\nFinally, the best pair is selected according to the specified logic:\n- First, we identify a subset of solutions that meet the performance criterion, $\\text{RMSE}_I \\le \\varepsilon$.\n- If this subset is non-empty, we sort it first by ascending $\\Delta T_{\\text{overshoot}}$, and then by ascending $S$ to break ties. The top entry is the chosen solution.\n- If no solution meets the performance criterion, we sort all solutions by ascending $\\Delta T_{\\text{overshoot}}$ and choose the top one, regardless of its $\\text{RMSE}_I$.\n\n**5. Reporting (Step 4)**:\nFor each test case, the final result is a list containing the open-loop overshoot, the best-found MPC overshoot, the corresponding $\\text{RMSE}_I$, and the values of $Q$ and $S$ that achieved this result. These are then formatted as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the battery MPC problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: Happy path\n        {\n            'params': {'Cc': 4000, 'Cs': 2000, 'hcs': 10, 'hsa': 5, 'eta': 0.02, 'dt': 1, 'N': 120, 'Tamb': 25, 'Tc0': 25, 'Ts0': 25},\n            'spec': {'Id': 100, 'Tmax': 35, 'epsilon': 10, 'R': 0.01},\n            'grid': {'Q': [0.1, 1.0, 10.0], 'S': [0.1, 1.0, 10.0, 100.0]}\n        },\n        # Case B: Boundary near limit\n        {\n            'params': {'Cc': 4000, 'Cs': 2000, 'hcs': 10, 'hsa': 5, 'eta': 0.02, 'dt': 1, 'N': 120, 'Tamb': 25, 'Tc0': 34, 'Ts0': 34},\n            'spec': {'Id': 100, 'Tmax': 35, 'epsilon': 10, 'R': 0.01},\n            'grid': {'Q': [0.1, 1.0, 10.0], 'S': [0.1, 1.0, 10.0, 100.0]}\n        },\n        # Case C: High ambient, lower current\n        {\n            'params': {'Cc': 4000, 'Cs': 2000, 'hcs': 10, 'hsa': 5, 'eta': 0.02, 'dt': 1, 'N': 120, 'Tamb': 35, 'Tc0': 35, 'Ts0': 35},\n            'spec': {'Id': 80, 'Tmax': 40, 'epsilon': 8, 'R': 0.01},\n            'grid': {'Q': [0.1, 1.0, 10.0], 'S': [0.1, 1.0, 10.0, 100.0]}\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        p = case['params']\n        s = case['spec']\n        g = case['grid']\n\n        # Unpack parameters\n        Cc, Cs, hcs, hsa, eta, dt, N, Tamb, Tc0, Ts0 = p.values()\n        Id, Tmax, epsilon, R = s.values()\n        Q_grid, S_grid = g.values()\n\n        # Define system matrices\n        A_cont = np.array([\n            [-hcs / Cc, hcs / Cc],\n            [hcs / Cs, -(hcs + hsa) / Cs]\n        ])\n        B_cont = np.array([[eta / Cc], [0]])\n        g_cont = np.array([[0], [hsa * Tamb / Cs]])\n\n        # Discretize using Forward Euler\n        I_2 = np.identity(2)\n        Ad = I_2 + dt * A_cont\n        Bd_vec = dt * B_cont\n        gd_vec = dt * g_cont\n\n        w_d = Id**2\n        w_max = Id**2\n\n        # --- Step 1: Open-loop overshoot ---\n        T_ol = np.zeros((N + 1, 2))\n        T_ol[0] = [Tc0, Ts0]\n        for k in range(N):\n            T_ol[k+1] = Ad @ T_ol[k] + (Bd_vec * w_max + gd_vec).flatten()\n        Ts_ol = T_ol[:, 1]\n        overshoot_ol = max(0, np.max(Ts_ol) - Tmax)\n\n        # --- Steps 2  3: MPC Optimization and Selection ---\n        w_initial = np.full(N, w_d)\n        bounds = [(0, w_max) for _ in range(N)]\n        w_minus_1 = w_d\n\n        mpc_results = []\n        for Q in Q_grid:\n            for S in S_grid:\n                \n                def objective_func(w):\n                    T_pred = np.zeros((N + 1, 2))\n                    T_pred[0] = [Tc0, Ts0]\n                    for k in range(N):\n                        T_pred[k+1] = Ad @ T_pred[k] + (Bd_vec * w[k] + gd_vec).flatten()\n\n                    J_tracking = Q * np.sum((w - w_d)**2)\n                    \n                    w_lagged = np.insert(w[:-1], 0, w_minus_1)\n                    J_smoothness = R * np.sum((w - w_lagged)**2)\n\n                    Ts_for_J = T_pred[1:N+1, 1] # Temperature penalty is on T_s,k for k=0...N-1\n                    # Since state at k is T_pred[k], we need T_s,k+1, which are indices 1..N\n                    # The problem statement says T_s,k for k=0..N-1. This is ambiguous. Let's assume penalty is on predicted T_s,k+1...T_s,N\n                    # Correct interpretation: T_s,k is the state at the start of interval k. We simulate to get T_s,1...T_s,N.\n                    # A more standard MPC formulation penalizes the full predicted state trajectory from k=1...N\n                    Ts_pred_horizon = T_pred[1:, 1]\n                    overshoot_terms = np.maximum(0, Ts_pred_horizon - Tmax)\n                    J_temp_penalty = S * np.sum(overshoot_terms**2)\n                    \n                    return J_tracking + J_smoothness + J_temp_penalty\n\n                opt_res = minimize(\n                    objective_func,\n                    w_initial,\n                    method='SLSQP',\n                    bounds=bounds,\n                    options={'maxiter': 200, 'ftol': 1e-6}\n                )\n                w_opt = opt_res.x\n\n                # Evaluate performance with optimal control sequence\n                T_mpc = np.zeros((N + 1, 2))\n                T_mpc[0] = [Tc0, Ts0]\n                for k in range(N):\n                    T_mpc[k+1] = Ad @ T_mpc[k] + (Bd_vec * w_opt[k] + gd_vec).flatten()\n                \n                Ts_mpc = T_mpc[:, 1]\n                overshoot_mpc = max(0, np.max(Ts_mpc) - Tmax)\n                \n                w_opt_safe = np.maximum(0, w_opt)\n                rmse_I = np.sqrt(np.mean((np.sqrt(w_opt_safe) - Id)**2))\n                \n                mpc_results.append({\n                    'overshoot': overshoot_mpc,\n                    'rmse': rmse_I,\n                    'Q': Q,\n                    'S': S\n                })\n\n        # Select best candidate\n        valid_candidates = [r for r in mpc_results if r['rmse'] = epsilon]\n\n        if valid_candidates:\n            # Sort by overshoot, then by S\n            best_candidate = sorted(valid_candidates, key=lambda x: (x['overshoot'], x['S']))[0]\n        else:\n            # If no candidate is valid, sort all by overshoot\n            best_candidate = sorted(mpc_results, key=lambda x: x['overshoot'])[0]\n\n        # --- Step 4: Report ---\n        final_result = [\n            round(overshoot_ol, 3),\n            round(best_candidate['overshoot'], 3),\n            round(best_candidate['rmse'], 3),\n            float(best_candidate['Q']),\n            float(best_candidate['S'])\n        ]\n        all_results.append(final_result)\n    \n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "The complexity of battery management multiplies when scaling from a single cell to a multi-cell pack, where inherent imbalances can cause a single weak cell to limit the entire system. This advanced practice showcases the power of MPC in system-level coordination, where it optimizes both the main pack current and individual cell-balancing actuators simultaneously. You will implement a controller that intelligently manages cell-to-cell variations, demonstrating how MPC can use its actuators to recover feasibility and maximize pack performance without violating the safety limits of any individual cell .",
            "id": "3928844",
            "problem": "Consider a series-connected three-cell lithium-ion battery pack whose dynamics over a discrete-time prediction horizon are modeled by the following physically based relations derived from conservation of charge, Ohm’s law, and a linearized open-circuit voltage map. Each cell index is denoted by $i \\in \\{1,2,3\\}$ and time index by $k \\in \\{0,1,\\dots,N-1\\}$. The decision variables at each time step are the pack current $I_k$ and the balancing (bleeder) currents $b_{i,k}$ for each cell. The net cell current is $I_{i,k} = I_k - b_{i,k}$, where the balancing currents represent bypass actuation that redistributes current among cells in the series string. The state-of-charge $s_{i,k}$ evolves according to the conservation of charge\n$$ s_{i,k+1} = s_{i,k} - \\frac{\\Delta t}{Q_i} I_{i,k} , $$\nwhere $Q_i$ is the cell capacity and $\\Delta t$ is the sampling interval. The cell voltage is given by the linear equivalent-circuit relation\n$$ V_{i,k} = V_{\\mathrm{oc},i}(s_{i,k}) - R_i I_{i,k} , \\quad V_{\\mathrm{oc},i}(s) = \\alpha_i + \\beta_i s, $$\nwhere $R_i$ is the internal resistance, $\\alpha_i$ is the intercept of the open-circuit voltage with respect to state-of-charge, and $\\beta_i$ is the slope.\n\nModel Predictive Control (MPC) seeks a sequence $\\{I_k, b_{1,k}, b_{2,k}, b_{3,k}\\}_{k=0}^{N-1}$ to minimize a convex objective subject to voltage safety constraints and actuator bounds. The constraints enforce\n$$ V_{\\min} \\le V_{i,k} \\le V_{\\max}, \\quad 0 \\le b_{i,k} \\le b_{\\max}, \\quad 0 \\le I_k \\le I_{\\max} , $$\nfor all $i,k$. The objective to be minimized is\n$$ J = \\sum_{k=0}^{N-1} \\left( w_{\\mathrm{track}} (I_k - I^{\\mathrm{ref}}_k)^2 + w_{\\mathrm{bleed}} \\sum_{i=1}^{3} b_{i,k}^2 + w_{\\mathrm{slew}} (I_k - I_{k-1})^2 \\right), $$\nwith the convention $I_{-1} = I_0$. Here $I^{\\mathrm{ref}}_k$ is a given load current reference sequence. The balancing currents are penalized in the objective to capture the trade-off between feasibility recovery and increased losses.\n\nYour task is to implement an MPC that, for each provided test case, computes an optimal sequence $\\{I_k, b_{1,k}, b_{2,k}, b_{3,k}\\}$ minimizing $J$ subject to the stated constraints and dynamics. From the optimal solution, compute:\n- A feasibility boolean indicating whether all voltage constraints $V_{\\min} \\le V_{i,k} \\le V_{\\max}$ are satisfied for all $i,k$ within a numerical tolerance of $10^{-6}$.\n- The root-mean-square tracking error in amperes, defined as\n$$ \\mathrm{RMS} = \\sqrt{\\frac{1}{N} \\sum_{k=0}^{N-1} (I_k - I^{\\mathrm{ref}}_k)^2} \\quad \\text{(express in $\\mathrm{A}$)}. $$\n- The total bleed energy in joules over the horizon,\n$$ E_{\\mathrm{bleed}} = \\sum_{k=0}^{N-1} \\sum_{i=1}^{3} V_{i,k} \\, b_{i,k} \\, \\Delta t \\quad \\text{(express in $\\mathrm{J}$)}. $$\n\nDesign your program to handle the following test suite of parameter values, which includes a general case and edge cases targeting boundary behavior:\n\nTest Case $1$ (balanced, happy path):\n- $N = 8$, $\\Delta t = 1.0 \\, \\mathrm{s}$, $I_{\\max} = 6.0 \\, \\mathrm{A}$, $b_{\\max} = 0.5 \\, \\mathrm{A}$.\n- $Q_1 = Q_2 = Q_3 = 3600.0 \\, \\mathrm{A}\\cdot\\mathrm{s}$, $R_1 = R_2 = R_3 = 0.01 \\, \\Omega$.\n- $\\alpha_1 = \\alpha_2 = \\alpha_3 = 3.0 \\, \\mathrm{V}$, $\\beta_1 = \\beta_2 = \\beta_3 = 1.2 \\, \\mathrm{V}$.\n- $V_{\\min} = 3.0 \\, \\mathrm{V}$, $V_{\\max} = 4.2 \\, \\mathrm{V}$.\n- Initial states $s_{1,0} = s_{2,0} = s_{3,0} = 0.6$.\n- Reference $I^{\\mathrm{ref}}_k = 3.0 \\, \\mathrm{A}$ for all $k$.\n- Weights $w_{\\mathrm{track}} = 10.0$, $w_{\\mathrm{bleed}} = 0.1$, $w_{\\mathrm{slew}} = 0.01$.\n\nTest Case $2$ (one cell hits lower voltage limit without balancing; feasibility recovered via balancing):\n- $N = 8$, $\\Delta t = 1.0 \\, \\mathrm{s}$, $I_{\\max} = 6.0 \\, \\mathrm{A}$, $b_{\\max} = 2.0 \\, \\mathrm{A}$.\n- $Q_1 = Q_2 = Q_3 = 3600.0 \\, \\mathrm{A}\\cdot\\mathrm{s}$, $R_1 = 0.05 \\, \\Omega$, $R_2 = R_3 = 0.01 \\, \\Omega$.\n- $\\alpha_1 = \\alpha_2 = \\alpha_3 = 3.0 \\, \\mathrm{V}$, $\\beta_1 = \\beta_2 = \\beta_3 = 1.2 \\, \\mathrm{V}$.\n- $V_{\\min} = 3.0 \\, \\mathrm{V}$, $V_{\\max} = 4.2 \\, \\mathrm{V}$.\n- Initial states $s_{1,0} = 0.2$, $s_{2,0} = 0.5$, $s_{3,0} = 0.5$.\n- Reference $I^{\\mathrm{ref}}_k = 6.0 \\, \\mathrm{A}$ for all $k$.\n- Weights $w_{\\mathrm{track}} = 10.0$, $w_{\\mathrm{bleed}} = 0.1$, $w_{\\mathrm{slew}} = 0.01$.\n\nTest Case $3$ (insufficient balancing; feasibility recovered by reducing pack current):\n- $N = 8$, $\\Delta t = 1.0 \\, \\mathrm{s}$, $I_{\\max} = 6.0 \\, \\mathrm{A}$, $b_{\\max} = 0.2 \\, \\mathrm{A}$.\n- $Q_1 = Q_2 = Q_3 = 3600.0 \\, \\mathrm{A}\\cdot\\mathrm{s}$, $R_1 = 0.05 \\, \\Omega$, $R_2 = R_3 = 0.01 \\, \\Omega$.\n- $\\alpha_1 = \\alpha_2 = \\alpha_3 = 3.0 \\, \\mathrm{V}$, $\\beta_1 = \\beta_2 = \\beta_3 = 1.2 \\, \\mathrm{V}$.\n- $V_{\\min} = 3.0 \\, \\mathrm{V}$, $V_{\\max} = 4.2 \\, \\mathrm{V}$.\n- Initial states $s_{1,0} = 0.2$, $s_{2,0} = 0.5$, $s_{3,0} = 0.5$.\n- Reference $I^{\\mathrm{ref}}_k = 6.0 \\, \\mathrm{A}$ for all $k$.\n- Weights $w_{\\mathrm{track}} = 1.0$, $w_{\\mathrm{bleed}} = 0.1$, $w_{\\mathrm{slew}} = 0.01$.\n\nFor each test case, implement an MPC solver that uses numerical optimization to compute the optimal control sequences. Then compute the feasibility boolean, the root-mean-square tracking error in $\\mathrm{A}$, and the total bleed energy in $\\mathrm{J}$.\n\nFinal Output Format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must itself be a list of the form $[ \\text{feasible boolean}, \\text{RMS tracking error in A}, \\text{bleed energy in J} ]$. For example, the output must be in the form $[[\\text{boolean},\\text{float},\\text{float}],[\\text{boolean},\\text{float},\\text{float}],[\\text{boolean},\\text{float},\\text{float}]]$ with no additional text.",
            "solution": "The user has provided a well-posed problem in the domain of optimal control for battery management systems. The problem is scientifically grounded in established battery modeling principles and is formulated as a convex optimization problem, specifically a Quadratic Program (QP), which guarantees a unique solution. All parameters and conditions are clearly specified, and the test cases are designed to probe different operational regimes of the controller. The problem is valid.\n\nThe task is to implement a Model Predictive Controller (MPC) for a three-cell series-connected battery pack. The MPC must find the optimal sequences of pack current $\\{I_k\\}_{k=0}^{N-1}$ and per-cell balancing currents $\\{b_{i,k}\\}_{k=0}^{N-1}$ over a prediction horizon of length $N$. The optimality is defined by minimizing a quadratic cost function $J$, subject to a set of linear constraints representing the battery dynamics, voltage safety limits, and actuator capabilities.\n\nThe problem is structured as a standard convex QP, which can be expressed in the form:\n$$ \\min_{x} \\frac{1}{2} x^T H x + f^T x \\quad \\text{subject to} \\quad A x \\le b $$\nHere, the decision vector $x$ is a flattened vector containing all decision variables over the horizon:\n$$ x = [I_0, \\dots, I_{N-1}, b_{1,0}, \\dots, b_{1,N-1}, b_{2,0}, \\dots, b_{2,N-1}, b_{3,0}, \\dots, b_{3,N-1}]^T $$\nThe total number of decision variables is $4N$.\n\nThe objective function to minimize is:\n$$ J = \\sum_{k=0}^{N-1} \\left( w_{\\mathrm{track}} (I_k - I^{\\mathrm{ref}}_k)^2 + w_{\\mathrm{bleed}} \\sum_{i=1}^{3} b_{i,k}^2 + w_{\\mathrm{slew}} (I_k - I_{k-1})^2 \\right) $$\nwith the convention $I_{-1} = I_0$. This convention implies that the slew rate penalty $(I_0 - I_{-1})^2$ is zero for the first step, so the effective slew rate term is $\\sum_{k=1}^{N-1} w_{\\mathrm{slew}} (I_k - I_{k-1})^2$. Since all weights ($w_{\\mathrm{track}}, w_{\\mathrm{bleed}}, w_{\\mathrm{slew}}$) are positive, the cost function $J$ is a strictly convex quadratic function of the decision vector $x$.\n\nThe constraints are all linear with respect to the decision variables. The state-of-charge (SOC) dynamics are given by:\n$$ s_{i,k+1} = s_{i,k} - \\frac{\\Delta t}{Q_i} (I_k - b_{i,k}) $$\nBy unrolling this recurrence, the state $s_{i,k}$ at any time step $k$ can be expressed as a linear function of the initial state $s_{i,0}$ and the decision variables $\\{I_j, b_{i,j}\\}_{j=0}^{k-1}$:\n$$ s_{i,k} = s_{i,0} - \\frac{\\Delta t}{Q_i} \\sum_{j=0}^{k-1} (I_j - b_{i,j}) $$\nThe cell voltage $V_{i,k}$ is also a linear function of the decision variables, obtained by substituting the expression for $s_{i,k}$ into the voltage equation:\n$$ V_{i,k} = \\alpha_i + \\beta_i s_{i,k} - R_i (I_k - b_{i,k}) $$\n$$ V_{i,k} = \\alpha_i + \\beta_i \\left( s_{i,0} - \\frac{\\Delta t}{Q_i} \\sum_{j=0}^{k-1} (I_j - b_{i,j}) \\right) - R_i (I_k - b_{i,k}) $$\nThe voltage constraints $V_{\\min} \\le V_{i,k} \\le V_{\\max}$ and the actuator bounds $0 \\le I_k \\le I_{\\max}$, $0 \\le b_{i,k} \\le b_{\\max}$ are therefore all linear inequality constraints on $x$.\n\nThe QP is solved using the `scipy.optimize.minimize` function with the 'SLSQP' (Sequential Least Squares Programming) method, which is well-suited for constrained nonlinear optimization and is efficient for QPs. The implementation involves:\n1.  Defining an objective function that computes $J$ for a given decision vector $x$.\n2.  Defining a set of inequality constraint functions of the form $g(x) \\ge 0$. These are derived from the voltage limits: $V_{i,k} - V_{\\min} \\ge 0$ and $V_{\\max} - V_{i,k} \\ge 0$.\n3.  Defining the box constraints (bounds) for each element of $x$ according to $I_k$ and $b_{i,k}$ limits.\n4.  Providing an initial guess for the optimizer. A logical choice is to set the pack currents equal to the reference currents and all balancing currents to zero.\n\nAfter the optimization yields the optimal decision vector $x^*$, the optimal trajectories for currents ($I_k^*, b_{i,k}^*$), states ($s_{i,k}^*$), and voltages ($V_{i,k}^*$) are computed. From these trajectories, the following three output metrics are calculated for each test case:\n1.  **Feasibility**: A boolean check is performed to confirm if all voltage constraints $V_{\\min} \\le V_{i,k}^* \\le V_{\\max}$ are satisfied for all cells $i$ and time steps $k$ within a numerical tolerance of $10^{-6}$.\n2.  **RMS Tracking Error**: The root-mean-square error between the optimal pack current $I_k^*$ and the reference current $I_k^{\\mathrm{ref}}$ is calculated.\n3.  **Total Bleed Energy**: The total energy dissipated by the balancing circuits is computed by summing the product of cell voltage, balancing current, and the time step duration over all cells and the entire horizon: $E_{\\mathrm{bleed}} = \\sum_{k,i} V_{i,k}^* b_{i,k}^* \\Delta t$.\n\nThe overall process is repeated for each of the three test cases provided, and the results are aggregated into the specified output format.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_mpc_for_case(params):\n    \"\"\"\n    Solves the MPC optimization problem for a single test case.\n    \"\"\"\n    # Unpack parameters\n    N = params['N']\n    dt = params['dt']\n    I_max = params['I_max']\n    b_max = params['b_max']\n    Q = params['Q']\n    R = params['R']\n    alpha = params['alpha']\n    beta = params['beta']\n    Vmin = params['Vmin']\n    Vmax = params['Vmax']\n    s0 = params['s0']\n    I_ref = params['I_ref']\n    w_track = params['w_track']\n    w_bleed = params['w_bleed']\n    w_slew = params['w_slew']\n    \n    num_vars = 4 * N\n\n    # Objective function J(x)\n    def objective(x):\n        I = x[0:N]\n        b = np.reshape(x[N:], (3, N))\n        \n        tracking_cost = w_track * np.sum((I - I_ref)**2)\n        bleed_cost = w_bleed * np.sum(b**2)\n\n        # Per problem spec I_-1 = I_0, so slew cost is on I_1 to I_{N-1}\n        I_prev = np.insert(I[:-1], 0, I[0])\n        slew_cost = w_slew * np.sum((I - I_prev)**2)\n        \n        return tracking_cost + bleed_cost + slew_cost\n\n    # Inequality constraints: V_min = V_ik = V_max\n    def constraints(x):\n        I = x[0:N]\n        b = np.reshape(x[N:], (3, N))\n        I_cell = I[np.newaxis, :] - b # Broadcasting to (3, N)\n\n        # Calculate SOC trajectory s_i,k for k=0..N-1\n        s = np.zeros((3, N))\n        # Initial SOC for first time step prediction is the state at k=0\n        current_s = s0.copy()\n        for k in range(N):\n            s[:, k] = current_s\n            current_s = current_s - (dt / Q) * I_cell[:, k]\n\n        # Calculate voltage trajectory V_i,k for k=0..N-1\n        Voc = alpha[:, np.newaxis] + beta[:, np.newaxis] * s\n        V = Voc - R[:, np.newaxis] * I_cell\n    \n        # Constraints are g(x) >= 0\n        # V_ik - Vmin >= 0  and  Vmax - V_ik >= 0\n        c1 = V - Vmin\n        c2 = Vmax - V\n        \n        return np.concatenate([c1.flatten(), c2.flatten()])\n\n    # Bounds for decision variables\n    bounds = []\n    bounds.extend([(0, I_max)] * N)       # I_k bounds\n    bounds.extend([(0, b_max)] * (3 * N))  # b_ik bounds\n\n    # Initial guess for x\n    x0 = np.zeros(num_vars)\n    x0[0:N] = np.clip(I_ref, 0, I_max)\n\n    # Solve the QP\n    res = minimize(\n        objective,\n        x0,\n        method='SLSQP',\n        bounds=bounds,\n        constraints={'type': 'ineq', 'fun': constraints},\n        options={'disp': False, 'ftol': 1e-9, 'maxiter': 200}\n    )\n    \n    x_opt = res.x\n    I_opt = x_opt[0:N]\n    b_opt = np.reshape(x_opt[N:], (3, N))\n\n    # Re-compute optimal trajectories to calculate final metrics\n    I_cell_opt = I_opt[np.newaxis, :] - b_opt\n    \n    s_opt = np.zeros((3, N))\n    current_s_opt = s0.copy()\n    for k in range(N):\n        s_opt[:, k] = current_s_opt\n        current_s_opt = current_s_opt - (dt / Q) * I_cell_opt[:, k]\n        \n    Voc_opt = alpha[:, np.newaxis] + beta[:, np.newaxis] * s_opt\n    V_opt = Voc_opt - R[:, np.newaxis] * I_cell_opt\n\n    # 1. Feasibility check\n    tol = 1e-6\n    feasible = np.all(V_opt >= Vmin - tol) and np.all(V_opt = Vmax + tol)\n    \n    # 2. RMS tracking error\n    rms_error = np.sqrt(np.mean((I_opt - I_ref)**2))\n    \n    # 3. Total bleed energy\n    bleed_energy = np.sum(V_opt * b_opt * dt)\n    \n    return [feasible, rms_error, bleed_energy]\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 8, \"dt\": 1.0, \"I_max\": 6.0, \"b_max\": 0.5,\n            \"Q\": np.array([3600.0, 3600.0, 3600.0]),\n            \"R\": np.array([0.01, 0.01, 0.01]),\n            \"alpha\": np.array([3.0, 3.0, 3.0]),\n            \"beta\": np.array([1.2, 1.2, 1.2]),\n            \"Vmin\": 3.0, \"Vmax\": 4.2,\n            \"s0\": np.array([0.6, 0.6, 0.6]),\n            \"I_ref\": np.full(8, 3.0),\n            \"w_track\": 10.0, \"w_bleed\": 0.1, \"w_slew\": 0.01,\n        },\n        {\n            \"N\": 8, \"dt\": 1.0, \"I_max\": 6.0, \"b_max\": 2.0,\n            \"Q\": np.array([3600.0, 3600.0, 3600.0]),\n            \"R\": np.array([0.05, 0.01, 0.01]),\n            \"alpha\": np.array([3.0, 3.0, 3.0]),\n            \"beta\": np.array([1.2, 1.2, 1.2]),\n            \"Vmin\": 3.0, \"Vmax\": 4.2,\n            \"s0\": np.array([0.2, 0.5, 0.5]),\n            \"I_ref\": np.full(8, 6.0),\n            \"w_track\": 10.0, \"w_bleed\": 0.1, \"w_slew\": 0.01,\n        },\n        {\n            \"N\": 8, \"dt\": 1.0, \"I_max\": 6.0, \"b_max\": 0.2,\n            \"Q\": np.array([3600.0, 3600.0, 3600.0]),\n            \"R\": np.array([0.05, 0.01, 0.01]),\n            \"alpha\": np.array([3.0, 3.0, 3.0]),\n            \"beta\": np.array([1.2, 1.2, 1.2]),\n            \"Vmin\": 3.0, \"Vmax\": 4.2,\n            \"s0\": np.array([0.2, 0.5, 0.5]),\n            \"I_ref\": np.full(8, 6.0),\n            \"w_track\": 1.0, \"w_bleed\": 0.1, \"w_slew\": 0.01,\n        },\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        result = run_mpc_for_case(case_params)\n        all_results.append(result)\n\n    formatted_results = []\n    for res in all_results:\n        # Convert boolean to string 'True'/'False' as lowercase 'true'/'false'\n        bool_val_str = str(res[0])\n        # Format the result list as a string\n        formatted_results.append(f\"[{bool_val_str},{res[1]},{res[2]}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n\n```"
        }
    ]
}