{
    "hands_on_practices": [
        {
            "introduction": "Before delving into complex optimization algorithms, it is crucial to master the fundamental principles governing battery operation. This first practice grounds your understanding in the core concepts of energy conservation, state of charge (SoC), and conversion efficiency. By calculating the maximum export duration for a single electric vehicle, you will solidify your grasp on the basic energy accounting that underpins all Vehicle-to-Grid (V2G) strategies .",
            "id": "3959539",
            "problem": "An Electric Vehicle (EV) participating in Vehicle-to-Grid (V2G) export is coupled to the grid through a bidirectional power converter with constant conversion efficiency $\\eta$ in discharge mode. The on-board battery has a usable energy capacity $E_{\\text{cap}}$ and is operated within a State of Charge (SoC) window $\\text{SoC} \\in [\\text{SoC}_{\\min}, \\text{SoC}_{\\max}]$, where State of Charge (SoC) is defined as the ratio of instantaneous stored direct-current energy in the battery $E_{\\text{dc}}(t)$ to its usable capacity $E_{\\text{cap}}$, i.e., $\\text{SoC}(t) = E_{\\text{dc}}(t)/E_{\\text{cap}}$. The Alternating Current (AC) export power to the grid is denoted by $P$ and is bounded above by $P_{\\max}$. Assume the discharge losses are fully captured by the converter efficiency and that the battery conversion and efficiency are constant over the operating range. The discharge process is quasi-steady so that power and energy are related by $P = \\mathrm{d}E/\\mathrm{d}t$ on the respective side of conversion. Starting from $\\text{SoC}(0) = 0.8$, the EV exports at constant AC power $P = 6\\ \\text{kW}$, with $P_{\\max} = 7\\ \\text{kW}$, converter efficiency $\\eta = 0.94$, allowable SoC window $\\text{SoC} \\in [0.2, 0.9]$, and battery usable capacity $E_{\\text{cap}} = 60\\ \\text{kWh}$. Compute the maximum duration of continuous export until the lower SoC bound is reached while respecting $\\text{SoC}(t) \\ge 0.2$ and $P \\le P_{\\max}$. Express your answer in hours and round your final numerical value to four significant figures.",
            "solution": "The problem is first validated against the specified criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n-   Converter efficiency in discharge mode: $\\eta$\n-   Usable battery energy capacity: $E_{\\text{cap}}$\n-   State of Charge (SoC) window: $\\text{SoC} \\in [\\text{SoC}_{\\min}, \\text{SoC}_{\\max}]$\n-   SoC definition: $\\text{SoC}(t) = E_{\\text{dc}}(t)/E_{\\text{cap}}$\n-   Instantaneous stored DC energy: $E_{\\text{dc}}(t)$\n-   AC export power: $P$\n-   Maximum AC export power: $P_{\\max}$\n-   Initial SoC: $\\text{SoC}(0) = 0.8$\n-   Export power value: $P = 6\\ \\text{kW}$\n-   Maximum power value: $P_{\\max} = 7\\ \\text{kW}$\n-   Efficiency value: $\\eta = 0.94$\n-   Allowable SoC window values: $[\\text{SoC}_{\\min}, \\text{SoC}_{\\max}] = [0.2, 0.9]$\n-   Battery capacity value: $E_{\\text{cap}} = 60\\ \\text{kWh}$\n-   Assumption: Discharge is a quasi-steady process where $P = \\mathrm{d}E/\\mathrm{d}t$.\n-   Assumption: Efficiency $\\eta$ is constant.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientifically Grounded**: The problem is based on fundamental principles of energy conservation and electrical power conversion, using a standard simplified model for a battery system. The given values are physically realistic for a contemporary electric vehicle.\n-   **Well-Posed**: The problem is well-posed, providing all necessary data (initial state, final state, process parameters) to calculate a unique solution for the time duration.\n-   **Objective**: The problem is stated using precise, objective, and quantitative language.\n-   **Incomplete or Contradictory Setup**: The problem is self-contained. The initial condition $\\text{SoC}(0) = 0.8$ is within the allowed window $[0.2, 0.9]$. The operating power $P = 6\\ \\text{kW}$ is below the maximum allowed power $P_{\\max} = 7\\ \\text{kW}$. The setup is consistent.\n\n**Step 3: Verdict and Action**\nThe problem is deemed valid. A solution will be provided.\n\n### Solution\n\nThe objective is to calculate the total time, $\\Delta t$, for the battery's State of Charge ($\\text{SoC}$) to decrease from its initial value, $\\text{SoC}_0$, to its minimum allowed value, $\\text{SoC}_{\\min}$, while exporting a constant AC power $P$.\n\nThe fundamental principle is the conservation of energy, applied across the power converter. The energy exported to the grid, $\\Delta E_{\\text{ac}}$, is related to the energy drawn from the battery, $\\Delta E_{\\text{dc}}$, by the converter efficiency, $\\eta$.\n\nIn discharge mode, the energy flows from the battery (DC) to the grid (AC). The efficiency $\\eta$ is the ratio of the output power (or energy) to the input power (or energy).\n$$ \\eta = \\frac{\\Delta E_{\\text{ac}}}{\\Delta E_{\\text{dc}}} $$\nThe total energy drawn from the battery, $\\Delta E_{\\text{dc}}$, corresponds to the change in the stored energy. The stored energy $E_{\\text{dc}}$ is defined in terms of the SoC and the usable capacity $E_{\\text{cap}}$ as $E_{\\text{dc}}(t) = \\text{SoC}(t) \\cdot E_{\\text{cap}}$.\n\nThe process starts at an initial state of charge $\\text{SoC}(0) = \\text{SoC}_0 = 0.8$ and ends when the state of charge reaches the lower bound $\\text{SoC}_{\\min} = 0.2$. Let the final state of charge be $\\text{SoC}_f = 0.2$. The total DC energy discharged from the battery is:\n$$ \\Delta E_{\\text{dc}} = E_{\\text{dc, initial}} - E_{\\text{dc, final}} = \\text{SoC}_0 \\cdot E_{\\text{cap}} - \\text{SoC}_f \\cdot E_{\\text{cap}} $$\n$$ \\Delta E_{\\text{dc}} = (\\text{SoC}_0 - \\text{SoC}_f) E_{\\text{cap}} $$\nThe total AC energy exported to the grid is delivered at a constant power $P$ over the duration $\\Delta t$. Assuming a quasi-steady process, this energy is given by:\n$$ \\Delta E_{\\text{ac}} = P \\cdot \\Delta t $$\nSubstituting these expressions for $\\Delta E_{\\text{ac}}$ and $\\Delta E_{\\text{dc}}$ into the efficiency equation:\n$$ \\eta = \\frac{P \\cdot \\Delta t}{(\\text{SoC}_0 - \\text{SoC}_f) E_{\\text{cap}}} $$\nWe can now solve for the time duration $\\Delta t$:\n$$ \\Delta t = \\frac{\\eta \\cdot (\\text{SoC}_0 - \\text{SoC}_f) \\cdot E_{\\text{cap}}}{P} $$\nNow, we substitute the given numerical values into this expression:\n-   $\\eta = 0.94$\n-   $\\text{SoC}_0 = 0.8$\n-   $\\text{SoC}_f = \\text{SoC}_{\\min} = 0.2$\n-   $E_{\\text{cap}} = 60\\ \\text{kWh}$\n-   $P = 6\\ \\text{kW}$\n\nThe calculation proceeds as follows:\n$$ \\Delta t = \\frac{0.94 \\cdot (0.8 - 0.2) \\cdot 60\\ \\text{kWh}}{6\\ \\text{kW}} $$\nFirst, calculate the change in SoC:\n$$ \\text{SoC}_0 - \\text{SoC}_f = 0.8 - 0.2 = 0.6 $$\nSubstitute this back into the equation for $\\Delta t$:\n$$ \\Delta t = \\frac{0.94 \\cdot 0.6 \\cdot 60}{6}\\ \\text{h} $$\nThe units $\\text{kWh}/\\text{kW}$ correctly yield hours ($\\text{h}$).\n$$ \\Delta t = 0.94 \\cdot 0.6 \\cdot 10\\ \\text{h} $$\n$$ \\Delta t = 0.94 \\cdot 6\\ \\text{h} $$\n$$ \\Delta t = 5.64\\ \\text{h} $$\nThe problem requires the final answer to be rounded to four significant figures.\n$$ \\Delta t = 5.640\\ \\text{h} $$\nThis is the maximum duration of continuous export under the specified conditions.",
            "answer": "$$\\boxed{5.640}$$"
        },
        {
            "introduction": "Moving from a single vehicle's capabilities to orchestrating an entire fleet requires a systematic approach to decision-making. This exercise introduces you to the power of formal optimization by asking you to formulate a mixed-integer linear program (MILP) for scheduling V2G services . You will learn how to translate physical constraints, such as battery capacity and power limits, and economic factors, like electricity prices and degradation costs, into a mathematical framework that can be solved to find the most cost-effective operational strategy for a group of vehicles.",
            "id": "3959482",
            "problem": "You are asked to derive, implement, and solve a mixed-integer linear optimization for a Vehicle-to-Grid (V2G) scheduling problem grounded in first principles of energy conservation and linear device constraints. Consider a fleet of electric vehicles indexed by $v \\in \\mathcal{V}$ and discrete time steps indexed by $t \\in \\mathcal{T}$. The fundamental base is the State of Charge (SoC) dynamics from energy balance and linear power constraints with binary connectivity decisions. You must derive a Mixed-Integer Linear Program (MILP) whose decision variables are the binary connection state $x_{v,t} \\in \\{0,1\\}$ and the continuous power variables $P_{v,t}$ per vehicle per time step, enforce availability constraints, and integrate the SoC dynamics. Your final program must enumerate the binary decisions over availability windows and solve the resulting continuous subproblems as linear programs to optimality.\n\nUse the following fundamental bases:\n- Energy conservation for State of Charge (SoC): State of Charge (SoC) $s_{v,t}$ is the fraction of stored energy in the battery of vehicle $v$ at time $t$, defined on the interval $[0,1]$.\n- Discrete-time energy balance over time step $\\Delta t$: Charging and discharging affect $s_{v,t}$ proportionally to power and inversely to usable energy.\n- Linear device constraints: Power limits scale with connectivity, and SoC is bounded.\n\nDefine the model as follows.\n- Variables:\n  - Binary connectivity $x_{v,t} \\in \\{0,1\\}$ indicating whether vehicle $v$ is physically connected and can exchange power at time $t$.\n  - Nonnegative charging power $P^{+}_{v,t} \\ge 0$ and nonnegative discharging power $P^{-}_{v,t} \\ge 0$, with net power $P_{v,t} = P^{+}_{v,t} - P^{-}_{v,t}$.\n  - State of Charge (SoC) $s_{v,t} \\in [0,1]$.\n- Parameters (given):\n  - Availability window $a_{v,t} \\in \\{0,1\\}$.\n  - Usable energy capacity $E_{v}$ in $\\mathrm{kWh}$.\n  - Maximum charging power $\\bar{P}^{+}_{v}$ in $\\mathrm{kW}$.\n  - Maximum discharging power $\\bar{P}^{-}_{v}$ in $\\mathrm{kW}$.\n  - Charging efficiency $\\eta^{+}_{v} \\in (0,1]$ and discharging efficiency $\\eta^{-}_{v} \\in (0,1]$.\n  - Electricity price $c_{t}$ in dollars per $\\mathrm{kWh}$.\n  - Degradation penalty coefficient $\\alpha_{v}$ in dollars per $\\mathrm{kWh}$ of throughput.\n  - Connection overhead per time step $\\gamma_{v}$ in dollars.\n  - Initial SoC $s_{v,0} \\in [0,1]$; SoC bounds $s^{\\min}_{v}, s^{\\max}_{v} \\in [0,1]$; terminal SoC requirement $s^{\\mathrm{req}}_{v} \\in [0,1]$.\n  - Time step $\\Delta t$ in hours.\n- Constraints to derive using first principles:\n  - Availability: $x_{v,t} \\le a_{v,t}$ for all $v,t$.\n  - Power gating: $0 \\le P^{+}_{v,t} \\le \\bar{P}^{+}_{v} x_{v,t}$ and $0 \\le P^{-}_{v,t} \\le \\bar{P}^{-}_{v} x_{v,t}$ for all $v,t$.\n  - SoC dynamics: $s_{v,t+1} = s_{v,t} + \\dfrac{\\eta^{+}_{v} \\Delta t}{E_{v}} P^{+}_{v,t} - \\dfrac{\\Delta t}{\\eta^{-}_{v} E_{v}} P^{-}_{v,t}$ for all $v$ and all $t$ in $\\{0,\\dots,|\\mathcal{T}|-1\\}$.\n  - SoC bounds: $s^{\\min}_{v} \\le s_{v,t} \\le s^{\\max}_{v}$ for all $v,t$, and $s_{v,0} = \\text{given}$.\n  - Terminal requirement: $s_{v,|\\mathcal{T}|} \\ge s^{\\mathrm{req}}_{v}$ for all $v$.\n- Objective to derive and implement: minimize the total monetary cost over the horizon, defined as the sum of energy purchase cost minus energy sale revenue, plus linear degradation and connection overhead penalties. Formally, minimize\n  $$\\sum_{t \\in \\mathcal{T}} \\sum_{v \\in \\mathcal{V}} \\left[ c_{t} \\Delta t \\left(P^{+}_{v,t} - P^{-}_{v,t}\\right) + \\alpha_{v} \\Delta t \\left(P^{+}_{v,t} + P^{-}_{v,t}\\right) + \\gamma_{v} x_{v,t} \\right].$$\nGiven the binary nature of $x_{v,t}$ and the linear continuous constraints, this is a mixed-integer linear program. Your program must exhaustively enumerate $x_{v,t}$ patterns consistent with $a_{v,t}$ and, for each pattern, solve the continuous subproblem (the linear program with fixed $x_{v,t}$) to global optimality. Select the pattern with minimal total cost. Because the test instances are small, exhaustive enumeration is tractable.\n\nPhysical units and output specification:\n- Power $P^{+}_{v,t}, P^{-}_{v,t}$ must be handled in $\\mathrm{kW}$.\n- Energy capacity $E_{v}$ must be handled in $\\mathrm{kWh}$.\n- Price $c_{t}$ is in dollars per $\\mathrm{kWh}$.\n- Time step $\\Delta t$ is in hours.\n- State of Charge $s_{v,t}$ is dimensionless in $[0,1]$.\n- Express each optimal total cost in dollars, rounded to $3$ decimal places.\n\nTest suite. Implement your program to compute and output the optimal total cost for each of the following parameter sets:\n\n- Test case $1$ (general case):\n  - $|\\mathcal{V}| = 2$, $|\\mathcal{T}| = 3$, $\\Delta t = 1$.\n  - Prices $c_{t} = [0.15, 0.25, 0.20]$ in dollars per $\\mathrm{kWh}$.\n  - Vehicle $1$: $E_{1} = 60$, $\\bar{P}^{+}_{1} = 7.2$, $\\bar{P}^{-}_{1} = 5.0$, $\\eta^{+}_{1} = 0.95$, $\\eta^{-}_{1} = 0.95$, $s_{1,0} = 0.50$, $s^{\\min}_{1} = 0.20$, $s^{\\max}_{1} = 0.90$, $s^{\\mathrm{req}}_{1} = 0.60$, $\\alpha_{1} = 0.01$, $\\gamma_{1} = 0.02$.\n  - Vehicle $2$: $E_{2} = 75$, $\\bar{P}^{+}_{2} = 11.0$, $\\bar{P}^{-}_{2} = 8.0$, $\\eta^{+}_{2} = 0.90$, $\\eta^{-}_{2} = 0.90$, $s_{2,0} = 0.60$, $s^{\\min}_{2} = 0.30$, $s^{\\max}_{2} = 0.90$, $s^{\\mathrm{req}}_{2} = 0.65$, $\\alpha_{2} = 0.015$, $\\gamma_{2} = 0.02$.\n  - Availability $a_{v,t}$: vehicle $1$ is available at $t = 0,1$ and unavailable at $t = 2$; vehicle $2$ is available at $t = 1,2$ and unavailable at $t = 0$.\n- Test case $2$ (boundary with negative price):\n  - $|\\mathcal{V}| = 1$, $|\\mathcal{T}| = 4$, $\\Delta t = 1$.\n  - Prices $c_{t} = [-0.05, 0.10, 0.18, 0.12]$ in dollars per $\\mathrm{kWh}$.\n  - Vehicle $1$: $E_{1} = 75$, $\\bar{P}^{+}_{1} = 7.0$, $\\bar{P}^{-}_{1} = 7.0$, $\\eta^{+}_{1} = 0.92$, $\\eta^{-}_{1} = 0.92$, $s_{1,0} = 0.40$, $s^{\\min}_{1} = 0.30$, $s^{\\max}_{1} = 0.95$, $s^{\\mathrm{req}}_{1} = 0.50$, $\\alpha_{1} = 0.01$, $\\gamma_{1} = 0.01$.\n  - Availability $a_{1,t} = 1$ for all $t$ in $\\{0,1,2,3\\}$.\n- Test case $3$ (edge with high degradation cost):\n  - $|\\mathcal{V}| = 2$, $|\\mathcal{T}| = 2$, $\\Delta t = 1$.\n  - Prices $c_{t} = [0.20, 0.22]$ in dollars per $\\mathrm{kWh}$.\n  - Vehicle $1$: $E_{1} = 60$, $\\bar{P}^{+}_{1} = 7.2$, $\\bar{P}^{-}_{1} = 5.0$, $\\eta^{+}_{1} = 0.95$, $\\eta^{-}_{1} = 0.95$, $s_{1,0} = 0.79$, $s^{\\min}_{1} = 0.20$, $s^{\\max}_{1} = 0.95$, $s^{\\mathrm{req}}_{1} = 0.80$, $\\alpha_{1} = 1.0$, $\\gamma_{1} = 0.00$.\n  - Vehicle $2$: $E_{2} = 60$, $\\bar{P}^{+}_{2} = 7.2$, $\\bar{P}^{-}_{2} = 5.0$, $\\eta^{+}_{2} = 0.95$, $\\eta^{-}_{2} = 0.95$, $s_{2,0} = 0.85$, $s^{\\min}_{2} = 0.20$, $s^{\\max}_{2} = 0.95$, $s^{\\mathrm{req}}_{2} = 0.85$, $\\alpha_{2} = 1.0$, $\\gamma_{2} = 0.00$.\n  - Availability $a_{1,t} = 1$ for $t \\in \\{0,1\\}$; availability $a_{2,t} = 0$ for $t \\in \\{0,1\\}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\"[r_{1},r_{2},r_{3}]\"$, where each $r_{i}$ is the optimal total cost in dollars for test case $i$, rounded to $3$ decimal places.",
            "solution": "The user has provided a well-defined Vehicle-to-Grid (V2G) optimization problem. The first step is to validate the problem statement.\n\n### Step 1: Extract Givens\n\n**Sets and Indices:**\n-   Vehicles: $v \\in \\mathcal{V}$.\n-   Discrete time steps: $t \\in \\mathcal{T} = \\{0, 1, \\dots, |\\mathcal{T}|-1\\}$.\n\n**Decision Variables:**\n-   Binary connectivity: $x_{v,t} \\in \\{0,1\\}$.\n-   Nonnegative charging power: $P^{+}_{v,t} \\ge 0$ in $\\mathrm{kW}$.\n-   Nonnegative discharging power: $P^{-}_{v,t} \\ge 0$ in $\\mathrm{kW}$.\n-   State of Charge (SoC): $s_{v,t} \\in [0,1]$.\n\n**Parameters:**\n-   Availability window: $a_{v,t} \\in \\{0,1\\}$.\n-   Usable energy capacity: $E_{v}$ in $\\mathrm{kWh}$.\n-   Maximum charging power: $\\bar{P}^{+}_{v}$ in $\\mathrm{kW}$.\n-   Maximum discharging power: $\\bar{P}^{-}_{v}$ in $\\mathrm{kW}$.\n-   Charging efficiency: $\\eta^{+}_{v} \\in (0,1]$.\n-   Discharging efficiency: $\\eta^{-}_{v} \\in (0,1]$.\n-   Electricity price: $c_{t}$ in dollars per $\\mathrm{kWh}$.\n-   Degradation penalty coefficient: $\\alpha_{v}$ in dollars per $\\mathrm{kWh}$.\n-   Connection overhead: $\\gamma_{v}$ in dollars per time step.\n-   Initial SoC: $s_{v,0} \\in [0,1]$.\n-   SoC bounds: $s^{\\min}_{v}, s^{\\max}_{v} \\in [0,1]$.\n-   Terminal SoC requirement: $s^{\\mathrm{req}}_{v} \\in [0,1]$.\n-   Time step duration: $\\Delta t$ in hours.\n\n**Constraints (to be formally derived):**\n1.  Availability: $x_{v,t} \\le a_{v,t}$.\n2.  Power gating: $0 \\le P^{+}_{v,t} \\le \\bar{P}^{+}_{v} x_{v,t}$ and $0 \\le P^{-}_{v,t} \\le \\bar{P}^{-}_{v} x_{v,t}$.\n3.  SoC dynamics: $s_{v,t+1} = s_{v,t} + \\dfrac{\\eta^{+}_{v} \\Delta t}{E_{v}} P^{+}_{v,t} - \\dfrac{\\Delta t}{\\eta^{-}_{v} E_{v}} P^{-}_{v,t}$.\n4.  SoC bounds: $s^{\\min}_{v} \\le s_{v,t} \\le s^{\\max}_{v}$ for all $t > 0$, and $s_{v,0}$ is fixed.\n5.  Terminal requirement: $s_{v,|\\mathcal{T}|} \\ge s^{\\mathrm{req}}_{v}$.\n\n**Objective Function (to be formally derived):**\n-   Minimize total cost: $\\sum_{t \\in \\mathcal{T}} \\sum_{v \\in \\mathcal{V}} \\left[ c_{t} \\Delta t \\left(P^{+}_{v,t} - P^{-}_{v,t}\\right) + \\alpha_{v} \\Delta t \\left(P^{+}_{v,t} + P^{-}_{v,t}\\right) + \\gamma_{v} x_{v,t} \\right]$.\n\n**Solution Method:**\n-   Exhaustively enumerate all binary patterns for $x_{v,t}$ consistent with $a_{v,t}$.\n-   For each pattern, solve the resulting continuous subproblem (a Linear Program) to optimality.\n-   Select the pattern yielding the minimum total cost.\n\n**Test Cases:**\n-   Three specific test cases with all parameters provided.\n\n**Output Format:**\n-   A single line with a comma-separated list of optimal costs for each test case, rounded to $3$ decimal places, enclosed in square brackets. Example: `[r1,r2,r3]`.\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientifically Grounded (Critical):** The problem is based on the fundamental principle of energy conservation, represented by the State of Charge (SoC) balance equation. The constraints for power limits and SoC bounds are standard in battery and power systems modeling. The economic objective function is a conventional representation of costs in energy markets. The model is scientifically sound and realistic.\n-   **Well-Posed:** The problem is a Mixed-Integer Linear Program (MILP). The specified solution method, exhaustive enumeration of binary variables for small instances, is a valid (though not generally scalable) method to find the global optimum. Each resulting continuous subproblem is a Linear Program (LP), which is convex and for which standard solvers can find a unique optimal solution if one exists. The problem structure is well-posed.\n-   **Objective (Critical):** The problem is stated using precise mathematical language and unambiguous definitions for all variables, parameters, and constraints. It is free of subjective or opinion-based claims.\n-   **Completeness and Consistency:** All necessary parameters are provided for each test case. The units ($\\mathrm{kW}$, $\\mathrm{kWh}$, $\\mathrm{h}$, `\\$`) are consistent with the physical and economic relationships defined in the model. For instance, the product $c_t \\Delta t P_{v,t}$ has units $(\\$/\\mathrm{kWh}) \\cdot \\mathrm{h} \\cdot \\mathrm{kW} = \\$$, which is correct for a cost term. There are no contradictions in the problem statement.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. It is scientifically grounded, well-posed, objective, and complete. I will proceed with the solution.\n\n### Derivation and Formulation\n\nThe problem is a Mixed-Integer Linear Program (MILP) aimed at minimizing the total operational cost of a fleet of electric vehicles participating in Vehicle-to-Grid services. We will first formalize the derivation of the model components and then detail the solution algorithm.\n\n**1. Model Derivation**\n\nThe model is built upon three pillars: energy balance, linear device constraints, and economic costs.\n\n-   **State of Charge (SoC) Dynamics:** The SoC, $s_{v,t}$, represents the ratio of stored energy to the total usable capacity $E_v$. The change in stored energy over a time step $\\Delta t$ is the net energy flow into the battery. When charging with power $P^{+}_{v,t}$, the energy added to the battery is $\\eta^{+}_{v} P^{+}_{v,t} \\Delta t$, where $\\eta^{+}_{v}$ is the charging efficiency. When discharging with power $P^{-}_{v,t}$, the energy removed from the battery is $(1/\\eta^{-}_{v}) P^{-}_{v,t} \\Delta t$, where the energy delivered to the grid is $P^{-}_{v,t} \\Delta t$ and $\\eta^{-}_{v}$ is the discharging efficiency.\n    The change in SoC is the change in stored energy divided by the capacity $E_v$:\n    $$s_{v,t+1} - s_{v,t} = \\frac{\\eta^{+}_{v} P^{+}_{v,t} \\Delta t - (1/\\eta^{-}_{v}) P^{-}_{v,t} \\Delta t}{E_v}$$\n    Rearranging gives the provided state transition equation:\n    $$s_{v,t+1} = s_{v,t} + \\frac{\\eta^{+}_{v} \\Delta t}{E_v} P^{+}_{v,t} - \\frac{\\Delta t}{\\eta^{-}_{v} E_v} P^{-}_{v,t}$$\n\n-   **Power Constraints:** The binary variable $x_{v,t}$ acts as a switch. If a vehicle is not connected ($x_{v,t}=0$), no power can be exchanged, so $P^{+}_{v,t}=0$ and $P^{-}_{v,t}=0$. If it is connected ($x_{v,t}=1$), the power is limited by the vehicle's hardware, $\\bar{P}^{+}_{v}$ and $\\bar{P}^{-}_{v}$. This is captured by the \"power gating\" constraints:\n    $$0 \\le P^{+}_{v,t} \\le \\bar{P}^{+}_{v} x_{v,t}$$\n    $$0 \\le P^{-}_{v,t} \\le \\bar{P}^{-}_{v} x_{v,t}$$\n    Additionally, a vehicle can only be connected if it is physically available, requiring $x_{v,t} \\le a_{v,t}$. Since $x_{v,t}$ is binary, this enforces that $x_{v,t}$ can only be $1$ if $a_{v,t}$ is $1$.\n\n-   **Objective Function:** The total cost is the sum of three components, aggregated over all vehicles and time steps.\n    1.  **Energy Cost:** The net cost of electricity is the price $c_t$ multiplied by the net energy drawn from the grid, which is $(P^{+}_{v,t} - P^{-}_{v,t}) \\Delta t$.\n    2.  **Degradation Cost:** Battery degradation is often modeled as proportional to the total energy throughput. The power throughput is $P^{+}_{v,t} + P^{-}_{v,t}$, so the energy throughput is $(P^{+}_{v,t} + P^{-}_{v,t}) \\Delta t$. The associated cost is $\\alpha_v$ times this value.\n    3.  **Connection Cost:** A fixed cost $\\gamma_v$ is incurred for each time step the vehicle is connected, modeled as $\\gamma_v x_{v,t}$.\n\n    Summing these terms yields the objective function. We can group terms by the decision variables $P^{+}$ and $P^{-}$:\n    $$\\min \\sum_{v,t} \\left[ \\Delta t (c_t + \\alpha_v) P^{+}_{v,t} + \\Delta t (\\alpha_v - c_t) P^{-}_{v,t} + \\gamma_v x_{v,t} \\right]$$\n\n**2. Solution Strategy: Enumeration and Linear Programming**\n\nAs stipulated, we solve the MILP by enumerating all valid combinations of the binary variables $x_{v,t}$ and solving the resulting LP for the continuous variables for each combination.\n\nFor a fixed binary pattern $\\mathbf{x} = \\{x_{v,t}\\}$, the problem becomes a Linear Program (LP). The variables of this LP are the continuous variables $\\{P^{+}_{v,t}, P^{-}_{v,t}, s_{v,t}\\}$ for all $v \\in \\mathcal{V}$ and $t \\in \\mathcal{T}$.\n\nThe LP subproblem for a given $\\mathbf{x}$ is:\n$$\\text{Minimize} \\quad \\sum_{v,t} \\left[ \\Delta t (c_t + \\alpha_v) P^{+}_{v,t} + \\Delta t (\\alpha_v - c_t) P^{-}_{v,t} \\right] + \\underbrace{\\sum_{v,t} \\gamma_v x_{v,t}}_{\\text{constant}}$$\nSubject to:\n1.  $0 \\le P^{+}_{v,t} \\le \\bar{P}^{+}_{v} x_{v,t}$ (where $x_{v,t}$ is a fixed $0$ or $1$)\n2.  $0 \\le P^{-}_{v,t} \\le \\bar{P}^{-}_{v} x_{v,t}$ (where $x_{v,t}$ is a fixed $0$ or $1$)\n3.  $s_{v,t+1} - s_{v,t} - \\frac{\\eta^{+}_{v} \\Delta t}{E_v} P^{+}_{v,t} + \\frac{\\Delta t}{\\eta^{-}_{v} E_v} P^{-}_{v,t} = 0 \\quad (\\text{for } t=0, \\dots, |\\mathcal{T}|-1)$\n4.  $s^{\\min}_{v} \\le s_{v,t} \\le s^{\\max}_{v} \\quad (\\text{for } t=1, \\dots, |\\mathcal{T}|)$\n5.  $s_{v,|\\mathcal{T}|} \\ge s^{\\mathrm{req}}_{v}$\n\nThis LP can be solved using a standard solver like `scipy.optimize.linprog`.\n\n**3. Implementation using `scipy.optimize.linprog`**\n\nTo use `scipy.optimize.linprog`, we must formulate the LP in the standard form: $\\min \\mathbf{c}^T \\mathbf{z}$ subject to $\\mathbf{A}_{\\text{ub}} \\mathbf{z} \\le \\mathbf{b}_{\\text{ub}}$, $\\mathbf{A}_{\\text{eq}} \\mathbf{z} = \\mathbf{b}_{\\text{eq}}$, and $\\mathbf{lb} \\le \\mathbf{z} \\le \\mathbf{ub}$.\n\n-   **Decision Vector $\\mathbf{z}$:** We flatten the continuous variables into a single vector $\\mathbf{z}$. For $V=|\\mathcal{V}|$ vehicles and $T=|\\mathcal{T}|$ time horizons, the vector can be structured as:\n    $$\\mathbf{z} = [P^{+}_{0,0}, \\dots, P^{+}_{V-1,T-1}, \\quad P^{-}_{0,0}, \\dots, P^{-}_{V-1,T-1}, \\quad s_{0,1}, \\dots, s_{V-1,T}]$$\n    The total number of variables is $3VT$.\n\n-   **Objective Vector $\\mathbf{c}$:** The coefficients in $\\mathbf{c}$ correspond to the objective function. For a variable $P^{+}_{v,t}$, the coefficient is $\\Delta t (c_t + \\alpha_v)$. For $P^{-}_{v,t}$, it is $\\Delta t (\\alpha_v - c_t)$. For all $s_{v,t}$ variables, the coefficients are $0$. The fixed-cost part $\\sum \\gamma_v x_{v,t}$ is added to the LP optimal value `result.fun` after solving.\n\n-   **Bounds ($\\mathbf{lb}, \\mathbf{ub}$):**\n    -   For $P^{+}_{v,t}$: $[0, \\bar{P}^{+}_{v} x_{v,t}]$\n    -   For $P^{-}_{v,t}$: $[0, \\bar{P}^{-}_{v} x_{v,t}]$\n    -   For $s_{v,t}$: $[s^{\\min}_{v}, s^{\\max}_{v}]$\n\n-   **Equality Constraints ($\\mathbf{A}_{\\text{eq}}, \\mathbf{b}_{\\text{eq}}$):** These represent the SoC dynamics. For each vehicle $v$ and time step $t \\in \\{0, \\dots, T-1\\}$, we have one equation:\n    -   For $t=0$: $s_{v,1} - (\\frac{\\eta^{+}_{v}\\Delta t}{E_v})P^{+}_{v,0} + (\\frac{\\Delta t}{\\eta^{-}_{v}E_v})P^{-}_{v,0} = s_{v,0}$\n    -   For $t>0$: $s_{v,t+1} - s_{v,t} - (\\frac{\\eta^{+}_{v}\\Delta t}{E_v})P^{+}_{v,t} + (\\frac{\\Delta t}{\\eta^{-}_{v}E_v})P^{-}_{v,t} = 0$\n    These equations define the rows of $\\mathbf{A}_{\\text{eq}}$ and elements of $\\mathbf{b}_{\\text{eq}}$.\n\n-   **Inequality Constraints ($\\mathbf{A}_{\\text{ub}}, \\mathbf{b}_{\\text{ub}}$):** These capture the terminal SoC requirement $s_{v,T} \\ge s^{\\mathrm{req}}_{v}$, which is rewritten as $-s_{v,T} \\le -s^{\\mathrm{req}}_{v}$. For each vehicle $v$, we add a row to $\\mathbf{A}_{\\text{ub}}$ with a $-1$ at the position corresponding to $s_{v,T}$ and a corresponding entry $-s^{\\mathrm{req}}_{v}$ in $\\mathbf{b}_{\\text{ub}}$.\n\nThe overall algorithm consists of an outer loop that generates each valid binary pattern $\\mathbf{x}$, and an inner part that constructs and solves the above LP. The minimum cost found across all patterns is the solution.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            # Test case 1 (general case)\n            \"V\": 2, \"T\": 3, \"dt\": 1.0,\n            \"c\": np.array([0.15, 0.25, 0.20]),\n            \"vehicles\": [\n                {\n                    \"E\": 60.0, \"P_plus_max\": 7.2, \"P_minus_max\": 5.0,\n                    \"eta_plus\": 0.95, \"eta_minus\": 0.95,\n                    \"s_initial\": 0.50, \"s_min\": 0.20, \"s_max\": 0.90, \"s_req\": 0.60,\n                    \"alpha\": 0.01, \"gamma\": 0.02,\n                    \"a\": np.array([1, 1, 0])\n                },\n                {\n                    \"E\": 75.0, \"P_plus_max\": 11.0, \"P_minus_max\": 8.0,\n                    \"eta_plus\": 0.90, \"eta_minus\": 0.90,\n                    \"s_initial\": 0.60, \"s_min\": 0.30, \"s_max\": 0.90, \"s_req\": 0.65,\n                    \"alpha\": 0.015, \"gamma\": 0.02,\n                    \"a\": np.array([0, 1, 1])\n                }\n            ]\n        },\n        {\n            # Test case 2 (boundary with negative price)\n            \"V\": 1, \"T\": 4, \"dt\": 1.0,\n            \"c\": np.array([-0.05, 0.10, 0.18, 0.12]),\n            \"vehicles\": [\n                {\n                    \"E\": 75.0, \"P_plus_max\": 7.0, \"P_minus_max\": 7.0,\n                    \"eta_plus\": 0.92, \"eta_minus\": 0.92,\n                    \"s_initial\": 0.40, \"s_min\": 0.30, \"s_max\": 0.95, \"s_req\": 0.50,\n                    \"alpha\": 0.01, \"gamma\": 0.01,\n                    \"a\": np.array([1, 1, 1, 1])\n                }\n            ]\n        },\n        {\n            # Test case 3 (edge with high degradation cost)\n            \"V\": 2, \"T\": 2, \"dt\": 1.0,\n            \"c\": np.array([0.20, 0.22]),\n            \"vehicles\": [\n                {\n                    \"E\": 60.0, \"P_plus_max\": 7.2, \"P_minus_max\": 5.0,\n                    \"eta_plus\": 0.95, \"eta_minus\": 0.95,\n                    \"s_initial\": 0.79, \"s_min\": 0.20, \"s_max\": 0.95, \"s_req\": 0.80,\n                    \"alpha\": 1.0, \"gamma\": 0.00,\n                    \"a\": np.array([1, 1])\n                },\n                {\n                    \"E\": 60.0, \"P_plus_max\": 7.2, \"P_minus_max\": 5.0,\n                    \"eta_plus\": 0.95, \"eta_minus\": 0.95,\n                    \"s_initial\": 0.85, \"s_min\": 0.20, \"s_max\": 0.95, \"s_req\": 0.85,\n                    \"alpha\": 1.0, \"gamma\": 0.00,\n                    \"a\": np.array([0, 0])\n                }\n            ]\n        }\n    ]\n\n    results = []\n    for case_data in test_cases:\n        cost = solve_v2g_scheduling(case_data)\n        results.append(f\"{cost:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_v2g_scheduling(params):\n    \"\"\"\n    Solves the V2G scheduling MILP for a given test case by enumerating\n    binary connection patterns and solving the resulting LPs.\n    \"\"\"\n    V = params[\"V\"]\n    T = params[\"T\"]\n    dt = params[\"dt\"]\n    prices = params[\"c\"]\n    vehicles = params[\"vehicles\"]\n\n    # Generate all valid combinations of binary x_vt variables\n    vehicle_x_patterns = []\n    for v_idx in range(V):\n        availability = vehicles[v_idx][\"a\"]\n        available_slots = np.where(availability == 1)[0]\n        num_available = len(available_slots)\n        \n        patterns_for_v = []\n        for combo in itertools.product([0, 1], repeat=num_available):\n            x_v = np.zeros(T, dtype=int)\n            x_v[available_slots] = combo\n            patterns_for_v.append(x_v)\n        vehicle_x_patterns.append(patterns_for_v)\n\n    all_x_combinations = itertools.product(*vehicle_x_patterns)\n    \n    min_total_cost = float('inf')\n\n    # Variable indexing helpers\n    num_p_plus = V * T\n    num_p_minus = V * T\n    num_s = V * T\n    num_vars = num_p_plus + num_p_minus + num_s\n\n    def p_plus_idx(v, t): return v * T + t\n    def p_minus_idx(v, t): return num_p_plus + v * T + t\n    def s_idx(v, t): return num_p_plus + num_p_minus + v * T + (t - 1)\n\n    for x_combo in all_x_combinations:\n        x_matrix = np.array(x_combo)\n        \n        # --- Formulate and solve the LP subproblem ---\n        \n        # 1. Objective function vector c\n        c = np.zeros(num_vars)\n        fixed_connection_cost = 0.0\n        for v in range(V):\n            alpha_v = vehicles[v][\"alpha\"]\n            gamma_v = vehicles[v][\"gamma\"]\n            for t in range(T):\n                c[p_plus_idx(v, t)] = dt * (prices[t] + alpha_v)\n                c[p_minus_idx(v, t)] = dt * (alpha_v - prices[t])\n                fixed_connection_cost += gamma_v * x_matrix[v, t]\n\n        # 2. Bounds (lb, ub)\n        bounds = np.zeros((num_vars, 2))\n        for v in range(V):\n            for t in range(T):\n                bounds[p_plus_idx(v, t), 1] = vehicles[v][\"P_plus_max\"] * x_matrix[v, t]\n                bounds[p_minus_idx(v, t), 1] = vehicles[v][\"P_minus_max\"] * x_matrix[v, t]\n            for t in range(1, T + 1):\n                bounds[s_idx(v, t), 0] = vehicles[v][\"s_min\"]\n                bounds[s_idx(v, t), 1] = vehicles[v][\"s_max\"]\n\n        # 3. Equality constraints A_eq, b_eq (SoC dynamics)\n        A_eq = np.zeros((V * T, num_vars))\n        b_eq = np.zeros(V * T)\n        for v in range(V):\n            E_v = vehicles[v][\"E\"]\n            eta_plus_v = vehicles[v][\"eta_plus\"]\n            eta_minus_v = vehicles[v][\"eta_minus\"]\n            k_plus = (eta_plus_v * dt) / E_v\n            k_minus = dt / (eta_minus_v * E_v)\n            \n            for t in range(T):\n                row_idx = v * T + t\n                A_eq[row_idx, p_plus_idx(v, t)] = -k_plus\n                A_eq[row_idx, p_minus_idx(v, t)] = k_minus\n                if t == 0:\n                    A_eq[row_idx, s_idx(v, 1)] = 1\n                    b_eq[row_idx] = vehicles[v][\"s_initial\"]\n                else:\n                    A_eq[row_idx, s_idx(v, t)] = -1\n                    A_eq[row_idx, s_idx(v, t+1)] = 1\n\n        # 4. Inequality constraints A_ub, b_ub (Terminal SoC)\n        A_ub = np.zeros((V, num_vars))\n        b_ub = np.zeros(V)\n        for v in range(V):\n            A_ub[v, s_idx(v, T)] = -1\n            b_ub[v] = -vehicles[v][\"s_req\"]\n\n        # 5. Solve the LP\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if res.success:\n            current_total_cost = res.fun + fixed_connection_cost\n            if current_total_cost  min_total_cost:\n                min_total_cost = current_total_cost\n\n    return min_total_cost\n    \nsolve()\n```"
        },
        {
            "introduction": "Real-world V2G operations must contend with an uncertain future, particularly fluctuating electricity prices. This advanced practice introduces Model Predictive Control (MPC), a powerful, modern control technique for making optimal decisions in real-time by repeatedly planning over a moving horizon . By implementing and comparing a forward-looking MPC controller against a simpler myopic (short-sighted) baseline, you will gain hands-on experience with a state-of-the-art control strategy and quantify the economic value of using predictions to inform dispatch decisions.",
            "id": "3959510",
            "problem": "Consider a grid-interactive electric vehicle battery performing Vehicle-to-Grid (V2G) energy arbitrage under Model Predictive Control (MPC) with updated electricity price forecasts and symmetric error bounds. The battery is modeled over a discrete time horizon with a fixed prediction horizon of $H=12$ steps and a step duration of $\\Delta t = 1$ hour. The objective is to compute the MPC dispatch sequence and compare its total day cost to a myopic control baseline that optimizes over only a single-step horizon.\n\nAssume the following physically grounded battery and market model.\n\n- Battery state of charge (SoC) $s_t$ evolves under charging power $c_t \\ge 0$ and discharging power $d_t \\ge 0$ according to\n$$\ns_{t+1} = s_t + \\eta_c \\, c_t \\, \\Delta t - \\frac{1}{\\eta_d} \\, d_t \\, \\Delta t,\n$$\nwhere $\\eta_c \\in (0,1]$ and $\\eta_d \\in (0,1]$ are the charge and discharge efficiencies, respectively.\n\n- The SoC is bounded by\n$$\ns_{\\min} \\le s_t \\le s_{\\max} \\quad \\text{for all } t.\n$$\n\n- The battery can only exchange power with the grid when connected, modeled by a connectivity indicator $a_t \\in \\{0,1\\}$. Power limits are\n$$\n0 \\le c_t \\le a_t \\, P^{\\max}_{\\mathrm{ch}}, \\qquad 0 \\le d_t \\le a_t \\, P^{\\max}_{\\mathrm{dis}}.\n$$\n\n- The market price forecast at time $t$ is $p_t$ in dollars per kilowatt-hour ($$/\\mathrm{kWh}$), with a symmetric error bound $e_t \\ge 0$ such that the realized price $\\tilde{p}_t$ lies within $[p_t - e_t, \\, p_t + e_t]$. For robust planning, adopt a worst-case objective over this interval.\n\n- The degradation cost is modeled as a linear cost per energy throughput, with unit cost $c_{\\mathrm{deg}}$ in dollars per kilowatt-hour ($$/\\mathrm{kWh}$). The instantaneous cost at time $t$ is defined for realized price $\\tilde{p}_t$ as\n$$\nJ_t(\\tilde{p}_t, c_t, d_t) = \\tilde{p}_t \\, c_t \\, \\Delta t - \\tilde{p}_t \\, d_t \\, \\Delta t + c_{\\mathrm{deg}} \\, (c_t + d_t) \\, \\Delta t,\n$$\nwhere charging incurs energy purchase and discharging yields revenue that reduces cost.\n\n- For robust MPC planning under price uncertainty, replace $\\tilde{p}_t$ by its worst-case value with respect to decision direction: use $p_t + e_t$ for charging cost and $p_t - e_t$ for discharging revenue. The resulting worst-case stage cost is\n$$\n\\hat{J}_t(c_t, d_t) = (p_t + e_t) \\, c_t \\, \\Delta t - (p_t - e_t) \\, d_t \\, \\Delta t + c_{\\mathrm{deg}} \\, (c_t + d_t) \\, \\Delta t.\n$$\n\n- At the final time $T$, impose a terminal SoC requirement $s_T \\ge s_{\\mathrm{terminal}}$ only when the MPC horizon reaches the end of the day.\n\nDefine two controllers:\n1. Model Predictive Control (MPC): At each time $t$, solve a robust linear program over the horizon $t, t+1, \\dots, t+N-1$ with $N = \\min(H, T-t)$ to minimize $\\sum_{k=0}^{N-1} \\hat{J}_{t+k}$ subject to the linear dynamics, SoC bounds, power bounds, and terminal SoC constraint applied when $t+N = T$. Implement receding horizon by applying only the first-step decision $(c_t, d_t)$ and then updating $s_{t+1}$.\n\n2. Myopic baseline: At each time $t$, solve the same robust linear program but only over a single-step horizon ($N = 1$) to minimize the current worst-case stage cost $\\hat{J}_t$ subject to the same constraints, apply $(c_t, d_t)$, and update $s_{t+1}$.\n\nFor both controllers, evaluate the realized total day cost using the central forecast prices (i.e., set $\\tilde{p}_t = p_t$) as\n$$\nJ_{\\mathrm{day}} = \\sum_{t=0}^{T-1} \\left( p_t \\, c_t \\, \\Delta t - p_t \\, d_t \\, \\Delta t + c_{\\mathrm{deg}} (c_t + d_t) \\Delta t \\right).\n$$\n\nCompute the difference between the myopic baseline total day cost and the MPC total day cost, for each test case:\n$$\n\\Delta J = J_{\\mathrm{day}}^{\\mathrm{myopic}} - J_{\\mathrm{day}}^{\\mathrm{MPC}}.\n$$\nExpress each $\\Delta J$ in dollars, rounded to two decimal places.\n\nYou must implement the above controllers and calculations as a complete, runnable program. The program must produce the final output exactly as a single line containing a comma-separated list enclosed in square brackets, where the $i$-th element corresponds to the value of $\\Delta J$ in dollars for the $i$-th test case.\n\nUse the following test suite. Each test case specifies the number of steps $T$, price sequence $p_t$ in dollars per kilowatt-hour ($$/\\mathrm{kWh}$), error bounds $e_t$ in dollars per kilowatt-hour ($$/\\mathrm{kWh}$), connectivity $a_t \\in \\{0,1\\}$, initial SoC $s_0$ in kilowatt-hours ($\\mathrm{kWh}$), SoC bounds $s_{\\min}$ and $s_{\\max}$ in kilowatt-hours ($\\mathrm{kWh}$), power limits $P^{\\max}_{\\mathrm{ch}}$ and $P^{\\max}_{\\mathrm{dis}}$ in kilowatts ($\\mathrm{kW}$), efficiencies $\\eta_c$ and $\\eta_d$, degradation cost $c_{\\mathrm{deg}}$ in dollars per kilowatt-hour ($$/\\mathrm{kWh}$), and terminal SoC $s_{\\mathrm{terminal}}$ in kilowatt-hours ($\\mathrm{kWh}$). The step duration is $\\Delta t = 1$ hour and the prediction horizon is $H=12$:\n\n- Test case $1$ (standard arbitrage potential):\n    - $T = 24$\n    - $p_t$: $[0.12 \\text{ for } t \\in [0,5]], [0.18 \\text{ for } t \\in [6,10]], [0.32 \\text{ for } t \\in [11,14]], [0.18 \\text{ for } t \\in [15,19]], [0.10 \\text{ for } t \\in [20,23]]$\n    - $e_t$: constant $0.03$\n    - $a_t$: $1$ for $t \\in [0,7] \\cup [18,23]$, else $0$\n    - $s_0 = 10$, $s_{\\min} = 5$, $s_{\\max} = 50$\n    - $P^{\\max}_{\\mathrm{ch}} = 7.2$, $P^{\\max}_{\\mathrm{dis}} = 7.2$\n    - $\\eta_c = 0.95$, $\\eta_d = 0.95$\n    - $c_{\\mathrm{deg}} = 0.005$\n    - $s_{\\mathrm{terminal}} = 8$\n\n- Test case $2$ (zero-price boundary):\n    - $T = 24$\n    - $p_t$: all zeros\n    - $e_t$: all zeros\n    - $a_t$: all ones\n    - $s_0 = 20$, $s_{\\min} = 5$, $s_{\\max} = 50$\n    - $P^{\\max}_{\\mathrm{ch}} = 7.2$, $P^{\\max}_{\\mathrm{dis}} = 7.2$\n    - $\\eta_c = 0.95$, $\\eta_d = 0.95$\n    - $c_{\\mathrm{deg}} = 0.005$\n    - $s_{\\mathrm{terminal}} = 5$\n\n- Test case $3$ (high uncertainty suppresses discharge):\n    - $T = 24$\n    - $p_t$: $0.20$ for all $t$\n    - $e_t$: $0.10$ for all $t$\n    - $a_t$: all ones\n    - $s_0 = 20$, $s_{\\min} = 5$, $s_{\\max} = 50$\n    - $P^{\\max}_{\\mathrm{ch}} = 7.2$, $P^{\\max}_{\\mathrm{dis}} = 7.2$\n    - $\\eta_c = 0.95$, $\\eta_d = 0.95$\n    - $c_{\\mathrm{deg}} = 0.005$\n    - $s_{\\mathrm{terminal}} = 5$\n\n- Test case $4$ (limited early connectivity with midday price spike):\n    - $T = 24$\n    - $p_t$: $[0.08 \\text{ for } t \\in [0,5]], [0.18 \\text{ for } t \\in [6,11]], [0.30 \\text{ for } t \\in [12,15]], [0.18 \\text{ for } t \\in [16,19]], [0.12 \\text{ for } t \\in [20,23]]$\n    - $e_t$: constant $0.02$\n    - $a_t$: $1$ for $t \\in [0,3] \\cup [12,15] \\cup [20,23]$, else $0$\n    - $s_0 = 9$, $s_{\\min} = 5$, $s_{\\max} = 50$\n    - $P^{\\max}_{\\mathrm{ch}} = 7.2$, $P^{\\max}_{\\mathrm{dis}} = 7.2$\n    - $\\eta_c = 0.95$, $\\eta_d = 0.95$\n    - $c_{\\mathrm{deg}} = 0.005$\n    - $s_{\\mathrm{terminal}} = 7$\n\nAlgorithmic requirements:\n- Formulate the MPC subproblem as a linear program with decision variables $\\{c_{t+k}, d_{t+k}, s_{t+k+1}\\}_{k=0}^{N-1}$, linear dynamics constraints, box constraints, and the robust objective $\\sum_{k=0}^{N-1} \\hat{J}_{t+k}$, applying the terminal SoC constraint when $t+N=T$.\n- Implement the myopic baseline as the same linear program with $N=1$.\n- Use the central forecast $p_t$ for realized cost evaluation.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the value of $\\Delta J$ for the corresponding test case, in dollars rounded to two decimal places (e.g., \"[1.23,0.00,0.45,-0.12]\").",
            "solution": "The user problem has been subjected to a rigorous validation process and is determined to be valid. The problem is scientifically grounded, well-posed, internally consistent, and contains all necessary information to derive a unique, verifiable solution.\n\nThe problem requires a comparison of two control strategies for electric vehicle battery dispatch in a vehicle-to-grid (V2G) context: a Model Predictive Control (MPC) strategy with a lookahead horizon and a myopic (single-step) baseline. The performance metric is the total daily cost, accounting for energy purchase, energy sales revenue, and battery degradation. Both controllers operate under electricity price uncertainty, using a robust, worst-case formulation for planning.\n\n### 1. Mathematical Model\nThe core of the problem is a discrete-time linear model of a battery system.\n\n**State Dynamics:** The battery state of charge (SoC), denoted by $s_t$ in units of kilowatt-hours (kWh) at time step $t$, evolves according to the linear equation:\n$$\ns_{t+1} = s_t + \\eta_c \\, c_t \\, \\Delta t - \\frac{1}{\\eta_d} \\, d_t \\, \\Delta t\n$$\nwhere $c_t$ and $d_t$ are the charging and discharging power in kilowatts (kW), respectively. The parameters $\\eta_c \\in (0,1]$ and $\\eta_d \\in (0,1]$ represent the charging and discharging efficiencies. The time step duration is $\\Delta t = 1$ hour.\n\n**Constraints:** The system is subject to several linear constraints:\n- **SoC Limits:** $s_{\\min} \\le s_t \\le s_{\\max}$ for all $t$.\n- **Power Limits:**\n  - $0 \\le c_t \\le a_t \\, P^{\\max}_{\\mathrm{ch}}$\n  - $0 \\le d_t \\le a_t \\, P^{\\max}_{\\mathrm{dis}}$\n  where $a_t \\in \\{0,1\\}$ is a binary indicator of grid connectivity.\n- **Terminal Constraint:** $s_T \\ge s_{\\mathrm{terminal}}$, applied at the final time $T$ of the daily operational window.\n\n**Objective Function for Planning:** The controllers must plan actions by minimizing a robust, worst-case cost function over a given prediction horizon. The worst-case stage cost $\\hat{J}_t$ at time $t$ is formulated to account for price uncertainty represented by a forecast $p_t$ and an error bound $e_t$:\n$$\n\\hat{J}_t(c_t, d_t) = (p_t + e_t + c_{\\mathrm{deg}}) \\, c_t \\, \\Delta t + (c_{\\mathrm{deg}} - (p_t - e_t)) \\, d_t \\, \\Delta t\n$$\nThis formulation ensures that when making a decision to charge, the controller assumes the highest possible price ($p_t + e_t$), and when deciding to discharge, it assumes the lowest possible price ($p_t - e_t$) to guarantee robustness. $c_{\\mathrm{deg}}$ is the linear degradation cost per kWh of throughput.\n\n### 2. Control Strategies and Optimization\nAt each time step $t$, an optimization problem is solved to determine the optimal actions $c_t$ and $d_t$.\n\n**Linear Program (LP) Formulation:** For a planning horizon of length $N$ starting at time $t$, the problem is a linear program. The decision variables are the sequences of charge powers, discharge powers, and resulting SoC values:\n$$\n\\mathbf{x} = [c_t, \\dots, c_{t+N-1}, d_t, \\dots, d_{t+N-1}, s_{t+1}, \\dots, s_{t+N}]^T\n$$\nThis is a vector in $\\mathbb{R}^{3N}$.\n\nThe LP is formulated as follows:\n$$\n\\min_{\\mathbf{x}} \\sum_{k=0}^{N-1} \\left[ (p_{t+k} + e_{t+k} + c_{\\mathrm{deg}}) c_{t+k} \\Delta t + (c_{\\mathrm{deg}} - (p_{t+k} - e_{t+k})) d_{t+k} \\Delta t \\right]\n$$\nsubject to:\n1.  **Dynamics Constraints (Equality):** For $k=0, \\dots, N-1$:\n    $$\n    s_{t+k+1} - s_{t+k} - \\eta_c c_{t+k} \\Delta t + \\frac{1}{\\eta_d} d_{t+k} \\Delta t = 0\n    $$\n    where $s_t$ is the known initial state at the beginning of the horizon. These $N$ equations form the equality constraints $A_{eq}\\mathbf{x} = b_{eq}$.\n\n2.  **State and Control Bounds (Box Constraints):** For $k=0, \\dots, N-1$:\n    - $0 \\le c_{t+k} \\le a_{t+k} P^{\\max}_{\\mathrm{ch}}$\n    - $0 \\le d_{t+k} \\le a_{t+k} P^{\\max}_{\\mathrm{dis}}$\n    - $s_{\\min} \\le s_{t+k+1} \\le s_{\\max}$\n\n3.  **Terminal Constraint (Bound Adjustment):** If the horizon extends to the end of the day, i.e., $t+N = T$, the lower bound on the final state is adjusted: $s_{t+N} \\ge s_{\\mathrm{terminal}}$.\n\nThis structure is a standard LP that can be solved efficiently using numerical solvers.\n\n**Controller Implementation:**\n1.  **MPC Controller:** At each time step $t \\in [0, T-1]$, the MPC controller solves the LP with a horizon of length $N = \\min(H, T-t)$, where $H=12$ is the maximum prediction horizon. After solving, only the first actions $(c_t^*, d_t^*)$ of the optimal sequence are applied to the system. The state is updated to $s_{t+1}$, and the process is repeated at the next time step (receding horizon control).\n\n2.  **Myopic Controller:** This controller is a special case of the MPC where the horizon is always $N=1$. At each time step $t$, it solves the LP for a single step, optimizing only the immediate cost $\\hat{J}_t$ without any foresight.\n\n### 3. Simulation and Evaluation\nThe primary task is to simulate the battery's operation over a $T=24$ hour period under both control strategies and compare their economic performance.\n\n**Simulation Loop:**\nFor each controller (MPC and Myopic):\n1.  Initialize SoC to $s_0$.\n2.  Iterate $t$ from $0$ to $T-1$:\n    a.  Set up and solve the corresponding LP (with horizon $N$ for MPC, $N=1$ for Myopic) using the current state $s_t$.\n    b.  Apply the first-step optimal actions $(c_t, d_t)$.\n    c.  Update the state to $s_{t+1}$ using the dynamics equation.\n    d.  Store the actions $(c_t, d_t)$.\n\n**Performance Evaluation:** After the simulation for each controller is complete, the total realized daily cost, $J_{\\mathrm{day}}$, is calculated using the central price forecast ($\\tilde{p}_t = p_t$) as specified:\n$$\nJ_{\\mathrm{day}} = \\sum_{t=0}^{T-1} \\left( p_t c_t \\Delta t - p_t d_t \\Delta t + c_{\\mathrm{deg}} (c_t + d_t) \\Delta t \\right)\n$$\nThe final metric is the difference in cost between the two strategies, $\\Delta J = J_{\\mathrm{day}}^{\\mathrm{myopic}} - J_{\\mathrm{day}}^{\\mathrm{MPC}}$. A positive value indicates that MPC is economically superior to the myopic baseline.\n\nThe implementation will utilize the `scipy.optimize.linprog` function to solve the LP at each step. The test cases provided will be systematically processed to compute the required $\\Delta J$ for each.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to run the V2G optimization simulation for all test cases.\n    \"\"\"\n\n    # Global parameters as defined in the problem statement\n    H = 12  # Prediction horizon\n    DELTA_T = 1.0  # Time step duration in hours\n\n    # Test cases definition\n    test_cases = [\n        {\n            \"T\": 24,\n            \"p_t\": np.concatenate([\n                np.full(6, 0.12), np.full(5, 0.18), np.full(4, 0.32),\n                np.full(5, 0.18), np.full(4, 0.10)\n            ]),\n            \"e_t\": np.full(24, 0.03),\n            \"a_t\": np.array([1]*8 + [0]*10 + [1]*6),\n            \"s_0\": 10.0, \"s_min\": 5.0, \"s_max\": 50.0,\n            \"P_ch_max\": 7.2, \"P_dis_max\": 7.2,\n            \"eta_c\": 0.95, \"eta_d\": 0.95,\n            \"c_deg\": 0.005, \"s_terminal\": 8.0\n        },\n        {\n            \"T\": 24,\n            \"p_t\": np.zeros(24),\n            \"e_t\": np.zeros(24),\n            \"a_t\": np.ones(24),\n            \"s_0\": 20.0, \"s_min\": 5.0, \"s_max\": 50.0,\n            \"P_ch_max\": 7.2, \"P_dis_max\": 7.2,\n            \"eta_c\": 0.95, \"eta_d\": 0.95,\n            \"c_deg\": 0.005, \"s_terminal\": 5.0\n        },\n        {\n            \"T\": 24,\n            \"p_t\": np.full(24, 0.20),\n            \"e_t\": np.full(24, 0.10),\n            \"a_t\": np.ones(24),\n            \"s_0\": 20.0, \"s_min\": 5.0, \"s_max\": 50.0,\n            \"P_ch_max\": 7.2, \"P_dis_max\": 7.2,\n            \"eta_c\": 0.95, \"eta_d\": 0.95,\n            \"c_deg\": 0.005, \"s_terminal\": 5.0\n        },\n        {\n            \"T\": 24,\n            \"p_t\": np.concatenate([\n                np.full(6, 0.08), np.full(6, 0.18), np.full(4, 0.30),\n                np.full(4, 0.18), np.full(4, 0.12)\n            ]),\n            \"e_t\": np.full(24, 0.02),\n            \"a_t\": np.array([1]*4 + [0]*8 + [1]*4 + [0]*4 + [1]*4),\n            \"s_0\": 9.0, \"s_min\": 5.0, \"s_max\": 50.0,\n            \"P_ch_max\": 7.2, \"P_dis_max\": 7.2,\n            \"eta_c\": 0.95, \"eta_d\": 0.95,\n            \"c_deg\": 0.005, \"s_terminal\": 7.0\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        cost_mpc = run_simulation(params, H, DELTA_T, 'MPC')\n        cost_myopic = run_simulation(params, H, DELTA_T, 'Myopic')\n        delta_j = cost_myopic - cost_mpc\n        results.append(round(delta_j, 2))\n\n    # Format and print the final output as specified\n    print(f\"[{','.join(f'{r:.2f}' for r in results)}]\")\n\n\ndef run_simulation(params, H, dt, controller_type):\n    \"\"\"\n    Runs a T-step simulation for a given controller type ('MPC' or 'Myopic').\n    \"\"\"\n    T = params[\"T\"]\n    s_t = params[\"s_0\"]\n    \n    charge_actions = np.zeros(T)\n    discharge_actions = np.zeros(T)\n\n    for t in range(T):\n        if controller_type == 'MPC':\n            N = min(H, T - t)\n        else:  # Myopic\n            N = 1\n        \n        c_t_opt, d_t_opt = solve_dispatch_lp(params, s_t, t, N, dt)\n\n        charge_actions[t] = c_t_opt\n        discharge_actions[t] = d_t_opt\n        \n        # Update SoC based on the applied actions\n        s_t += params[\"eta_c\"] * c_t_opt * dt - (1 / params[\"eta_d\"]) * d_t_opt * dt\n\n    # Calculate total day cost using central price forecast\n    total_cost = np.sum(\n        params[\"p_t\"] * charge_actions * dt\n        - params[\"p_t\"] * discharge_actions * dt\n        + params[\"c_deg\"] * (charge_actions + discharge_actions) * dt\n    )\n    \n    return total_cost\n\n\ndef solve_dispatch_lp(params, s_current, t, N, dt):\n    \"\"\"\n    Sets up and solves the linear program for a single dispatch decision.\n    Decision variables are [c_0..c_{N-1}, d_0..d_{N-1}, s_1..s_N]\n    \"\"\"\n    p_forecast = params[\"p_t\"][t : t + N]\n    e_forecast = params[\"e_t\"][t : t + N]\n    a_forecast = params[\"a_t\"][t : t + N]\n    \n    # 1. Objective function coefficients (cost vector c)\n    cost_c = (p_forecast + e_forecast + params[\"c_deg\"]) * dt\n    cost_d = (params[\"c_deg\"] - (p_forecast - e_forecast)) * dt\n    cost_s = np.zeros(N)\n    c_vec = np.concatenate([cost_c, cost_d, cost_s])\n    \n    # 2. Equality constraints for dynamics (A_eq x = b_eq)\n    A_eq = np.zeros((N, 3 * N))\n    b_eq = np.zeros(N)\n\n    # First row connects to s_current\n    A_eq[0, 0] = -params[\"eta_c\"] * dt      # c_t\n    A_eq[0, N] = (1 / params[\"eta_d\"]) * dt # d_t\n    A_eq[0, 2 * N] = 1.0                      # s_{t+1}\n    b_eq[0] = s_current\n\n    # Subsequent rows for internal dynamics\n    for k in range(1, N):\n        A_eq[k, k] = -params[\"eta_c\"] * dt           # c_{t+k}\n        A_eq[k, N + k] = (1 / params[\"eta_d\"]) * dt    # d_{t+k}\n        A_eq[k, 2 * N + k - 1] = -1.0                 # s_{t+k}\n        A_eq[k, 2 * N + k] = 1.0                      # s_{t+k+1}\n    \n    # 3. Bounds for decision variables\n    bounds_c = [(0, a_forecast[k] * params[\"P_ch_max\"]) for k in range(N)]\n    bounds_d = [(0, a_forecast[k] * params[\"P_dis_max\"]) for k in range(N)]\n    \n    s_min_val = params[\"s_min\"]\n    s_max_val = params[\"s_max\"]\n    bounds_s = [(s_min_val, s_max_val) for _ in range(N)]\n    \n    # Apply terminal SoC constraint if horizon reaches the end of the day\n    if t + N == params[\"T\"]:\n        # The last state variable s_{t+N} must be >= s_terminal\n        s_terminal = params[\"s_terminal\"]\n        bounds_s[-1] = (max(s_min_val, s_terminal), s_max_val)\n        \n    all_bounds = bounds_c + bounds_d + bounds_s\n\n    # Solve the linear program\n    res = linprog(c=c_vec, A_eq=A_eq, b_eq=b_eq, bounds=all_bounds, method='highs')\n    \n    if res.success:\n        # Extract the first step actions\n        c_t_opt = res.x[0] if N > 0 else 0.0\n        d_t_opt = res.x[N] if N > 0 else 0.0\n        # Clamp small values to zero to handle numerical noise\n        c_t_opt = 0.0 if c_t_opt  1e-6 else c_t_opt\n        d_t_opt = 0.0 if d_t_opt  1e-6 else d_t_opt\n\n        return c_t_opt, d_t_opt\n    else:\n        # If solver fails, take no action\n        return 0.0, 0.0\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}