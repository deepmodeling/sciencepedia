{
    "hands_on_practices": [
        {
            "introduction": "这个首个实践练习是基础性的。在进行优化之前，我们必须首先理解物理约束。本练习聚焦于V2G系统中的核心能量平衡原则，将输送到电网的交流功率与电池中存储的直流能量联系起来。通过计算最大放电持续时间，您将巩固对电池容量、荷电状态（SoC）和转换器效率如何决定单台电动汽车操作边界的理解。",
            "id": "3959539",
            "problem": "一辆参与车辆到电网 (V2G) 输电的电动汽车 (EV)，通过一个在放电模式下具有恒定转换效率 $\\eta$ 的双向功率转换器连接到电网。其车载电池具有可用能量容量 $E_{\\text{cap}}$，并在充电状态 (SoC) 窗口 $\\text{SoC} \\in [\\text{SoC}_{\\min}, \\text{SoC}_{\\max}]$ 内运行。充电状态 (SoC) 定义为电池中瞬时存储的直流能量 $E_{\\text{dc}}(t)$ 与其可用容量 $E_{\\text{cap}}$ 的比率，即 $\\text{SoC}(t) = E_{\\text{dc}}(t)/E_{\\text{cap}}$。向电网输出的交流 (AC) 功率用 $P$ 表示，其上限为 $P_{\\max}$。假设放电损耗完全由转换器效率体现，并且电池的转换和效率在工作范围内是恒定的。放电过程是准稳态的，因此在转换的相应侧，功率和能量的关系为 $P = \\mathrm{d}E/\\mathrm{d}t$。从 $\\text{SoC}(0) = 0.8$ 开始，该电动汽车以恒定的交流功率 $P = 6\\ \\text{kW}$ 输出，其中最大功率 $P_{\\max} = 7\\ \\text{kW}$，转换器效率 $\\eta = 0.94$，允许的SoC窗口为 $\\text{SoC} \\in [0.2, 0.9]$，电池可用容量 $E_{\\text{cap}} = 60\\ \\text{kWh}$。计算在满足 $\\text{SoC}(t) \\ge 0.2$ 和 $P \\le P_{\\max}$ 的条件下，连续输出直至达到SoC下限的最长持续时间。答案以小时为单位表示，并将最终数值结果四舍五入到四位有效数字。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n-   放电模式下的转换器效率：$\\eta$\n-   电池可用能量容量：$E_{\\text{cap}}$\n-   充电状态 (SoC) 窗口：$\\text{SoC} \\in [\\text{SoC}_{\\min}, \\text{SoC}_{\\max}]$\n-   SoC 定义：$\\text{SoC}(t) = E_{\\text{dc}}(t)/E_{\\text{cap}}$\n-   瞬时存储的直流能量：$E_{\\text{dc}}(t)$\n-   交流输出功率：$P$\n-   最大交流输出功率：$P_{\\max}$\n-   初始 SoC：$\\text{SoC}(0) = 0.8$\n-   输出功率值：$P = 6\\ \\text{kW}$\n-   最大功率值：$P_{\\max} = 7\\ \\text{kW}$\n-   效率值：$\\eta = 0.94$\n-   允许的 SoC 窗口值：$[\\text{SoC}_{\\min}, \\text{SoC}_{\\max}] = [0.2, 0.9]$\n-   电池容量值：$E_{\\text{cap}} = 60\\ \\text{kWh}$\n-   假设：放电是一个准稳态过程，其中 $P = \\mathrm{d}E/\\mathrm{d}t$。\n-   假设：效率 $\\eta$ 是恒定的。\n\n**步骤2：使用提取的已知条件进行验证**\n-   **科学依据**：该问题基于能量守恒和电能转换的基本原理，使用了一个电池系统的标准简化模型。给定的数值对于现代电动汽车而言在物理上是现实的。\n-   **适定性**：该问题是适定的，提供了计算唯一持续时间解所需的所有数据（初始状态、最终状态、过程参数）。\n-   **客观性**：该问题使用精确、客观和定量的语言进行陈述。\n-   **完整性与一致性**：该问题是自洽的。初始条件 $\\text{SoC}(0) = 0.8$ 在允许的窗口 $[0.2, 0.9]$ 内。工作功率 $P = 6\\ \\text{kW}$ 低于最大允许功率 $P_{\\max} = 7\\ \\text{kW}$。设置是一致的。\n\n**步骤3：结论与行动**\n该问题被认为是有效的。将提供解答。\n\n### 解答\n\n目标是计算电池的充电状态 (SoC) 在输出恒定交流功率 $P$ 的情况下，从其初始值 $\\text{SoC}_0$ 降低到其最小允许值 $\\text{SoC}_{\\min}$ 所需的总时间 $\\Delta t$。\n\n基本原理是应用于功率转换器的能量守恒。在放电模式下，能量从电池（直流）流向电网（交流）。效率 $\\eta$ 被定义为输出功率与输入功率的比值。设输送到电网的交流功率为 $P$。从电池抽取的直流功率 $P_{\\text{dc}}$ 必须满足 $\\eta = P / P_{\\text{dc}}$，因此 $P_{\\text{dc}} = P / \\eta$。\n\n从电池放出的总直流能量 $\\Delta E_{\\text{dc}}$ 对应于存储能量的变化。存储的能量 $E_{\\text{dc}}$ 根据SoC和可用容量 $E_{\\text{cap}}$ 定义为 $E_{\\text{dc}}(t) = \\text{SoC}(t) \\cdot E_{\\text{cap}}$。\n\n该过程从初始充电状态 $\\text{SoC}(0) = \\text{SoC}_0 = 0.8$ 开始，到充电状态达到下限 $\\text{SoC}_{\\min} = 0.2$ 时结束。设最终充电状态为 $\\text{SoC}_f = 0.2$。从电池放出的总可用直流能量为：\n$$ \\Delta E_{\\text{dc, available}} = E_{\\text{dc, initial}} - E_{\\text{dc, final}} = (\\text{SoC}_0 - \\text{SoC}_f) E_{\\text{cap}} $$\n在持续时间 $\\Delta t$ 内，从电池抽取的总直流能量为 $\\Delta E_{\\text{dc, drawn}} = P_{\\text{dc}} \\cdot \\Delta t = (P/\\eta) \\cdot \\Delta t$。\n令抽取的能量等于可用能量：\n$$ (P/\\eta) \\cdot \\Delta t = (\\text{SoC}_0 - \\text{SoC}_f) E_{\\text{cap}} $$\n现在我们可以求解持续时间 $\\Delta t$：\n$$ \\Delta t = \\frac{\\eta \\cdot (\\text{SoC}_0 - \\text{SoC}_f) \\cdot E_{\\text{cap}}}{P} $$\n现在，我们将给定的数值代入此表达式：\n-   $\\eta = 0.94$\n-   $\\text{SoC}_0 = 0.8$\n-   $\\text{SoC}_f = \\text{SoC}_{\\min} = 0.2$\n-   $E_{\\text{cap}} = 60\\ \\text{kWh}$\n-   $P = 6\\ \\text{kW}$\n\n计算过程如下：\n$$ \\Delta t = \\frac{0.94 \\cdot (0.8 - 0.2) \\cdot 60\\ \\text{kWh}}{6\\ \\text{kW}} $$\n首先，计算SoC的变化量：\n$$ \\text{SoC}_0 - \\text{SoC}_f = 0.8 - 0.2 = 0.6 $$\n将此结果代回 $\\Delta t$ 的方程中：\n$$ \\Delta t = \\frac{0.94 \\cdot 0.6 \\cdot 60}{6}\\ \\text{h} $$\n单位 $\\text{kWh}/\\text{kW}$ 正确地得到小时 ($\\text{h}$)。\n$$ \\Delta t = 0.94 \\cdot 0.6 \\cdot 10\\ \\text{h} $$\n$$ \\Delta t = 0.94 \\cdot 6\\ \\text{h} $$\n$$ \\Delta t = 5.64\\ \\text{h} $$\n问题要求最终答案四舍五入到四位有效数字。\n$$ \\Delta t = 5.640\\ \\text{h} $$\n这是在指定条件下的最长连续输出持续时间。",
            "answer": "$$\\boxed{5.640}$$"
        },
        {
            "introduction": "V2G操作并非没有成本；每个充放电循环都会加速电池的老化。一个成功的优化策略必须精确地核算这种退化成本。本练习将从基础物理学转向电池使用的经济影响，要求您实现一个计算模型，使用简化的雨流计数法和给定的老化成本图，将SoC轨迹转化为货币成本。 这项技能对于开发可盈利且可持续的V2G商业模式至关重要。",
            "id": "3959485",
            "problem": "给定一个为期一天的车辆到电网 (V2G) 调度曲线，该曲线由一个离散时间功率序列 $P_k$（单位：千瓦）描述，采样索引为 $k \\in \\{0,\\dots,N-1\\}$，具有均匀的时间步长 $\\Delta t$（单位：小时）。同时给定一个电池模型，其额定能量为 $E_{\\text{nom}}$（单位：千瓦时），充电效率为 $\\eta_{\\text{ch}} \\in (0,1]$，放电效率为 $\\eta_{\\text{dis}} \\in (0,1]$，初始荷电状态 (SoC) 为 $s_0 \\in [0,1]$，SoC 边界为 $s_{\\min}, s_{\\max} \\in [0,1]$ 且 $s_{\\min}  s_{\\max}$。电池在每个采样索引 $k$ 处的温度 $T_k$（单位：开尔文）也已给出（可以是恒定的或随时间变化的）。提供了一个循环老化成本图 $c(\\Delta s, T)$，单位为美元/千瓦时 ($$/\\text{kWh}$)，该图基于循环深度 $\\Delta s \\in [0,1]$（无量纲 SoC 偏移）和温度 $T \\in \\mathbb{R}^+$ 的矩形网格，需通过双线性插值进行评估。您的任务是，通过使用雨流法概念（根据美国材料与试验协会 (ASTM) E1049 的定义）将 $P_k$ 引起的 SoC 轨迹映射为半循环，并对所有识别出的半循环的老化成本求和，从而计算出全天的总退化成本。\n\n使用以下基本原理和定义：\n\n- 令 $E(t)$ 表示存储的能量（单位：千瓦时），$s(t) = E(t)/E_{\\text{nom}}$ 表示荷电状态 (SoC)。向电网输送的功率用 $P(t)$（单位：千瓦）表示，其中 $P(t) > 0$ 表示向电网放电，$P(t)  0$ 表示从电网充电。\n- 离散时间更新遵循能量守恒和效率建模。定义\n$$\n\\phi(P_k) = \\begin{cases}\n\\dfrac{P_k}{\\eta_{\\text{dis}}},  P_k \\ge 0, \\\\\nP_k \\,\\eta_{\\text{ch}},  P_k  0,\n\\end{cases}\n$$\n并通过下式更新 SoC：\n$$\ns_{k+1} = \\text{clip}\\left(s_k - \\dfrac{\\phi(P_k)\\,\\Delta t}{E_{\\text{nom}}},\\, s_{\\min},\\, s_{\\max}\\right),\n$$\n其中 $\\text{clip}(x,a,b)$ 将 $x$ 的值限制在区间 $[a,b]$ 内。\n- 使用给定的 $s_0$ 和上述更新规则，构建离散的 SoC 轨迹 $\\{s_k\\}_{k=0}^{N}$。\n- 从 $\\{s_k\\}$ 中提取反转点（包括端点的局部极值点）。然后将连续的相邻反转点对 $(i,j)$ 枚举为半循环，其深度为\n$$\n\\Delta s_{i,j} = |s_j - s_i|,\n$$\n并将每个半循环与温度平均值关联起来\n$$\n\\overline{T}_{i,j} = \\dfrac{1}{j-i}\\sum_{k=i}^{j-1} T_k\n$$\n对于 $j>i$。对于 $j=i$，半循环深度为零，贡献的成本也为零。\n- 对于每个半循环，通过在提供的网格上进行双线性插值来评估 $c(\\Delta s_{i,j}, \\overline{T}_{i,j})$。该半循环的吞吐能量为\n$$\nE_{\\text{throughput},\\,i,j} = \\Delta s_{i,j}\\, E_{\\text{nom}} \\quad \\text{(单位 kWh)}.\n$$\n- 半循环的退化成本为\n$$\nC_{i,j} = c(\\Delta s_{i,j}, \\overline{T}_{i,j}) \\cdot E_{\\text{throughput},\\,i,j} \\quad \\text{(单位 美元)}.\n$$\n- 总退化成本是所有半循环的成本之和：\n$$\nC_{\\text{total}} = \\sum_{(i,j)} C_{i,j}.\n$$\n\n使用以下循环老化成本图网格计算 $c(\\Delta s, T)$（单位 $$/\\text{kWh}），在点之间进行双线性插值，并在网格之外进行截断。设深度网格为\n$$\n\\Delta s \\in \\{\\, 0.05,\\, 0.10,\\, 0.20,\\, 0.40,\\, 0.60,\\, 0.80 \\,\\},\n$$\n温度网格为\n$$\nT \\in \\{\\, 293,\\, 298,\\, 308,\\, 318 \\,\\}\\ \\text{开尔文}.\n$$\n设数值表按 $T$ 递增的行和 $\\Delta s$ 递增的列排序：\n$$\n\\begin{array}{c|cccccc}\nT\\backslash \\Delta s  0.05  0.10  0.20  0.40  0.60  0.80 \\\\\n\\hline\n293  0.010  0.015  0.022  0.032  0.045  0.062 \\\\\n298  0.012  0.017  0.025  0.036  0.052  0.072 \\\\\n308  0.015  0.021  0.030  0.043  0.062  0.086 \\\\\n318  0.019  0.026  0.037  0.052  0.075  0.103\n\\end{array}\n$$\n\n实施以上方法，为以下五个测试用例生成结果。在所有情况下，以美元为单位，用实值浮点数作答。对于类似角度的表达式，使用弧度。电池和调度规格如下：\n\n- 测试用例 1 (理想正弦 V2G 日):\n    - $N = 24$, $\\Delta t = 1.0$ 小时。\n    - 对于 $k \\in \\{0,\\dots,23\\}$，$P_k = 10 \\sin\\!\\left( 2\\pi\\, k / 24 \\right)$ 千瓦。\n    - $E_{\\text{nom}} = 60$ 千瓦时, $\\eta_{\\text{ch}} = 0.95$, $\\eta_{\\text{dis}} = 0.95$。\n    - $s_0 = 0.50$, $s_{\\min} = 0.10$, $s_{\\max} = 0.90$。\n    - 对于所有 $k$，$T_k = 298$ 开尔文。\n\n- 测试用例 2 (零调度，恒定低温):\n    - $N = 12$, $\\Delta t = 0.5$ 小时。\n    - 对于所有 $k$，$P_k = 0$ 千瓦。\n    - $E_{\\text{nom}} = 50$ 千瓦时, $\\eta_{\\text{ch}} = 0.96$, $\\eta_{\\text{dis}} = 0.96$。\n    - $s_0 = 0.50$, $s_{\\min} = 0.10$, $s_{\\max} = 0.90$。\n    - 对于所有 $k$，$T_k = 293$ 开尔文。\n\n- 测试用例 3 (因强充放电导致的饱和):\n    - $N = 20$, $\\Delta t = 0.5$ 小时。\n    - 对于 $k \\in \\{0,\\dots,7\\}$，$P_k = -25$ 千瓦；对于 $k \\in \\{8,\\dots,15\\}$，$P_k = 25$ 千瓦；对于 $k \\in \\{16,\\dots,19\\}$，$P_k = 0$ 千瓦。\n    - $E_{\\text{nom}} = 50$ 千瓦时, $\\eta_{\\text{ch}} = 0.97$, $\\eta_{\\text{dis}} = 0.97$。\n    - $s_0 = 0.50$, $s_{\\min} = 0.10$, $s_{\\max} = 0.90$。\n    - 对于所有 $k$，$T_k = 308$ 开尔文。\n\n- 测试用例 4 (高频小循环，温度升高):\n    - $N = 16$, $\\Delta t = 0.5$ 小时。\n    - 对于偶数 $k$，$P_k = 5$ 千瓦；对于奇数 $k$，$P_k = -5$ 千瓦。\n    - $E_{\\text{nom}} = 40$ 千瓦时, $\\eta_{\\text{ch}} = 0.98$, $\\eta_{\\text{dis}} = 0.98$。\n    - $s_0 = 0.50$, $s_{\\min} = 0.20$, $s_{\\max} = 0.80$。\n    - $T_k$ 从 $k=0$ 时的 $293$ 开尔文线性增加到 $k=15$ 时的 $318$ 开尔文。\n\n- 测试用例 5 (单调充电斜坡，中等温度):\n    - $N = 10$, $\\Delta t = 1.0$ 小时。\n    - $P_k$ 是一个从 $k=0$ 时的 $-10$ 千瓦到 $k=9$ 时（含）的 $-2$ 千瓦的线性斜坡。\n    - $E_{\\text{nom}} = 70$ 千瓦时, $\\eta_{\\text{ch}} = 0.95$, $\\eta_{\\text{dis}} = 0.95$。\n    - $s_0 = 0.30$, $s_{\\min} = 0.10$, $s_{\\max} = 0.95$。\n    - 对于所有 $k$，$T_k = 298$ 开尔文。\n\n算法要求：\n\n- 通过离散更新和限幅计算 $\\{s_k\\}_{k=0}^{N}$。\n- 识别包括端点在内的反转点（局部极值），并构建半循环为相邻反转点索引对。\n- 对每个半循环，计算 $\\Delta s$ 和 $\\overline{T}$，插值计算 $c(\\Delta s,\\overline{T})$，计算吞吐能量和成本，然后求和得到 $C_{\\text{total}}$。\n- 如果 $\\Delta s = 0$，则半循环的成本贡献为零。\n- 使用双线性插值，并在需要时将 $(\\Delta s, T)$ 限制在所提供网格的边界内。\n\n您的程序应生成单行输出，其中包含五个测试用例的结果，格式为用方括号括起来的逗号分隔列表，每个浮点数四舍五入到六位小数，例如 $[x_1,x_2,x_3,x_4,x_5]$，其中 $x_i$ 是测试用例 $i$ 的成本（美元）。",
            "solution": "该问题要求计算电池在经历指定的为期一天的车辆到电网 (V2G) 调度循环后的总退化成本。该方法基于一个已定义的电池荷电状态 (SoC) 演化的物理化学模型和一个简化的循环计数方法来量化老化。解决方案通过以结构化、分步的方式实施指定的模型来推进。\n\n首先，我们为电池的能量状态建立核心物理模型。SoC，用 $s(t)$ 表示，代表当前存储能量 $E(t)$ 与额定能量容量 $E_{\\text{nom}}$ 的比率。存储能量的变化由功率流 $P(t)$ 决定，并根据效率损失进行调整。问题提供了一个离散时间模型。从电池抽取或输送到电池的功率 $\\phi(P_k)$ 考虑了效率低下的问题。对于放电（$P_k \\ge 0$），从电池抽取的功率为 $P_k / \\eta_{\\text{dis}}$，大于输送到电网的功率。对于充电（$P_k  0$），输送到电池的功率为 $P_k \\eta_{\\text{ch}}$，其绝对值小于从电网抽取的功率。\n在时间步长 $\\Delta t$ 上的能量平衡推导出第 $k+1$ 步的 SoC 离散时间更新方程：\n$$\nE_{k+1} = E_k - \\phi(P_k) \\Delta t\n$$\n两边同除以 $E_{\\text{nom}}$ 并包含指定的工作 SoC 限制 $[s_{\\min}, s_{\\max}]$，我们得到所提供的更新规则：\n$$\ns_{k+1} = \\text{clip}\\left(s_k - \\dfrac{\\phi(P_k)\\,\\Delta t}{E_{\\text{nom}}},\\, s_{\\min},\\, s_{\\max}\\right)\n$$\n其中 $\\phi(P_k)$ 定义为：\n$$\n\\phi(P_k) = \\begin{cases}\n\\dfrac{P_k}{\\eta_{\\text{dis}}},  P_k \\ge 0 \\\\\nP_k \\,\\eta_{\\text{ch}},  P_k  0\n\\end{cases}\n$$\n从初始 SoC $s_0$ 开始，对 $k \\in \\{0, 1, \\dots, N-1\\}$ 迭代此方程，以生成完整的 SoC 轨迹 $\\{s_k\\}_{k=0}^{N}$。\n\n第二步是将得到的 SoC 轨迹分解为一系列引起老化的事件，称为半循环。问题指定了一种基于识别反转点的方法，这些反转点是离散序列 $\\{s_k\\}$ 的局部最小值和最大值，包括起点和终点。索引 $k \\in \\{1, \\dots, N-1\\}$ 处的反转表示 SoC 趋势方向的改变。这可以通过算法检查相邻段斜率的乘积是否非正来实现，即 $(s_k - s_{k-1})(s_{k+1} - s_k) \\le 0$。反转索引的集合，包括 $0$ 和 $N$，形成一个有序序列 $\\{i_1, i_2, \\dots, i_m\\}$。然后，半循环被定义为连续反转点之间的段，即 $(i_1, i_2), (i_2, i_3), \\dots, (i_{m-1}, i_m)$。\n\n对于在时间索引 $i$ 和 $j$ 之间识别出的每个半循环，我们量化其对总退化的贡献。每个半循环都与两个关键参数相关联：其深度 $\\Delta s_{i,j}$ 和其平均工作温度 $\\overline{T}_{i,j}$。\n深度是 SoC 变化的幅度：\n$$\n\\Delta s_{i,j} = |s_j - s_i|\n$$\n平均温度是在半循环持续时间内计算的：\n$$\n\\overline{T}_{i,j} = \\dfrac{1}{j-i}\\sum_{k=i}^{j-1} T_k\n$$\n这两个参数 $(\\Delta s_{i,j}, \\overline{T}_{i,j})$ 用于确定特定的退化成本率 $c(\\Delta s, T)$，单位是美元/千瓦时 ($$/kWh)。该值通过对提供的表格化成本图进行双线性插值获得。如果坐标 $(\\Delta s, T)$ 落在表格定义的网格之外，则在插值前将其限制在网格的边界上。\n\n单个半循环的成本 $C_{i,j}$ 是插值得到的成本率与该半循环总能量吞吐量的乘积。能量吞吐量是电池循环的能量，由下式给出：\n$$\nE_{\\text{throughput},\\,i,j} = \\Delta s_{i,j}\\, E_{\\text{nom}}\n$$\n因此，成本为：\n$$\nC_{i,j} = c(\\Delta s_{i,j}, \\overline{T}_{i,j}) \\cdot E_{\\text{throughput},\\,i,j} = c(\\Delta s_{i,j}, \\overline{T}_{i,j}) \\cdot \\Delta s_{i,j} \\cdot E_{\\text{nom}}\n$$\n深度为零（$\\Delta s_{i,j} = 0$）的半循环对应于 SoC 没有变化的时期，因此产生的退化成本为零。\n\n最后，整个调度曲线的总退化成本 $C_{\\text{total}}$ 是所有已识别半循环成本的总和：\n$$\nC_{\\text{total}} = \\sum_{(i,j)} C_{i,j}\n$$\n对提供的五个测试用例中的每一个都实施这一完整过程，为每种情景得出一个最终的退化成本值。实施过程包括一个计算 SoC 轨迹的函数，一个查找反转点的例程，一个用于成本图的双线性插值函数，以及一个主循环来遍历半循环并汇总成本。",
            "answer": "```python\nimport numpy as np\n\ndef bilinear_interp(x, y, x_grid, y_grid, z_grid):\n    \"\"\"\n    Performs bilinear interpolation on a regular grid, with clamping.\n    \"\"\"\n    # Clamp inputs to the grid boundaries\n    x = np.clip(x, x_grid[0], x_grid[-1])\n    y = np.clip(y, y_grid[0], y_grid[-1])\n\n    # Find the indices for the lower-left corner of the grid cell\n    x_idx = np.searchsorted(x_grid, x, side='right') - 1\n    y_idx = np.searchsorted(y_grid, y, side='right') - 1\n    \n    # Handle the case where x or y is exactly the upper boundary of the grid\n    x_idx = np.clip(x_idx, 0, len(x_grid) - 2)\n    y_idx = np.clip(y_idx, 0, len(y_grid) - 2)\n\n    # Grid points for the cell\n    x1, x2 = x_grid[x_idx], x_grid[x_idx + 1]\n    y1, y2 = y_grid[y_idx], y_grid[y_idx + 1]\n\n    # Values at the corners of the cell\n    Q11 = z_grid[y_idx, x_idx]\n    Q12 = z_grid[y_idx, x_idx + 1]\n    Q21 = z_grid[y_idx + 1, x_idx]\n    Q22 = z_grid[y_idx + 1, x_idx + 1]\n\n    # Handle cases where grid points are coincident to avoid division by zero\n    if x1 == x2 and y1 == y2:\n        return Q11\n    if x1 == x2: # Vertical line interpolation\n        return Q11 + (Q21 - Q11) * (y - y1) / (y2 - y1)\n    if y1 == y2: # Horizontal line interpolation\n        return Q11 + (Q12 - Q11) * (x - x1) / (x2 - x1)\n\n    # Normalize coordinates within the cell\n    x_norm = (x - x1) / (x2 - x1)\n    y_norm = (y - y1) / (y2 - y1)\n\n    # Interpolate along x for lower and upper y bounds\n    R1 = (1 - x_norm) * Q11 + x_norm * Q12\n    R2 = (1 - x_norm) * Q21 + x_norm * Q22\n\n    # Interpolate along y to get the final value\n    P = (1 - y_norm) * R1 + y_norm * R2\n    \n    return P\n\ndef calculate_total_cost(params):\n    \"\"\"\n    Calculates the total degradation cost for a single test case.\n    \"\"\"\n    N = params['N']\n    dt = params['dt']\n    P_k = params['P_k']\n    E_nom = params['E_nom']\n    eta_ch = params['eta_ch']\n    eta_dis = params['eta_dis']\n    s0 = params['s0']\n    s_min = params['s_min']\n    s_max = params['s_max']\n    T_k = params['T_k']\n    ds_grid = params['ds_grid']\n    T_grid = params['T_grid']\n    c_map = params['c_map']\n\n    # Step 1: Generate SoC trajectory\n    s = np.zeros(N + 1)\n    s[0] = s0\n    for k in range(N):\n        Pk = P_k[k]\n        phi_Pk = Pk / eta_dis if Pk >= 0 else Pk * eta_ch\n        s[k + 1] = np.clip(s[k] - (phi_Pk * dt) / E_nom, s_min, s_max)\n\n    # Step 2: Identify reversal points\n    reversal_indices = [0]\n    for k in range(1, N):\n        if (s[k] - s[k - 1]) * (s[k + 1] - s[k]) = 0:\n            reversal_indices.append(k)\n    reversal_indices.append(N)\n    \n    # Remove consecutive duplicates which may arise from clipping\n    reversal_indices = [i for i, j in zip(reversal_indices, reversal_indices[1:] + [reversal_indices[-1]-1]) if i != j]\n\n    # Step 3: Sum costs over half-cycles\n    total_cost = 0.0\n    for idx in range(len(reversal_indices) - 1):\n        i = reversal_indices[idx]\n        j = reversal_indices[idx + 1]\n\n        if i == j:\n            continue\n\n        ds_ij = abs(s[j] - s[i])\n        if ds_ij == 0:\n            continue\n\n        T_avg_ij = np.mean(T_k[i:j])\n        \n        cost_rate = bilinear_interp(ds_ij, T_avg_ij, ds_grid, T_grid, c_map)\n        E_throughput = ds_ij * E_nom\n        C_ij = cost_rate * E_throughput\n        \n        total_cost += C_ij\n        \n    return total_cost\n\ndef solve():\n    # Define cycle aging cost map\n    ds_grid = np.array([0.05, 0.10, 0.20, 0.40, 0.60, 0.80])\n    T_grid = np.array([293, 298, 308, 318])\n    c_map = np.array([\n        [0.010, 0.015, 0.022, 0.032, 0.045, 0.062],  # T = 293K\n        [0.012, 0.017, 0.025, 0.036, 0.052, 0.072],  # T = 298K\n        [0.015, 0.021, 0.030, 0.043, 0.062, 0.086],  # T = 308K\n        [0.019, 0.026, 0.037, 0.052, 0.075, 0.103]   # T = 318K\n    ])\n\n    common_params = {'ds_grid': ds_grid, 'T_grid': T_grid, 'c_map': c_map}\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # Case 1\n        {**common_params, 'N': 24, 'dt': 1.0, \n         'P_k': np.array([10 * np.sin(2 * np.pi * k / 24) for k in range(24)]),\n         'E_nom': 60, 'eta_ch': 0.95, 'eta_dis': 0.95, \n         's0': 0.50, 's_min': 0.10, 's_max': 0.90, \n         'T_k': np.full(24, 298)},\n        # Case 2\n        {**common_params, 'N': 12, 'dt': 0.5, \n         'P_k': np.zeros(12),\n         'E_nom': 50, 'eta_ch': 0.96, 'eta_dis': 0.96, \n         's0': 0.50, 's_min': 0.10, 's_max': 0.90, \n         'T_k': np.full(12, 293)},\n        # Case 3\n        {**common_params, 'N': 20, 'dt': 0.5, \n         'P_k': np.array([-25.0] * 8 + [25.0] * 8 + [0.0] * 4),\n         'E_nom': 50, 'eta_ch': 0.97, 'eta_dis': 0.97, \n         's0': 0.50, 's_min': 0.10, 's_max': 0.90, \n         'T_k': np.full(20, 308)},\n        # Case 4\n        {**common_params, 'N': 16, 'dt': 0.5,\n         'P_k': np.array([5 if k % 2 == 0 else -5 for k in range(16)]),\n         'E_nom': 40, 'eta_ch': 0.98, 'eta_dis': 0.98,\n         's0': 0.50, 's_min': 0.20, 's_max': 0.80,\n         'T_k': np.linspace(293, 318, 16)},\n        # Case 5\n        {**common_params, 'N': 10, 'dt': 1.0,\n         'P_k': np.linspace(-10, -2, 10),\n         'E_nom': 70, 'eta_ch': 0.95, 'eta_dis': 0.95,\n         's0': 0.30, 's_min': 0.10, 's_max': 0.95,\n         'T_k': np.full(10, 298)},\n    ]\n\n    results = []\n    for params in test_cases:\n        cost = calculate_total_cost(params)\n        results.append(f\"{cost:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "这个综合性练习将我们前面探讨过的物理约束和经济成本整合到一个完整的优化框架中。您的任务是构建并求解一个混合整数线性规划（MILP）问题，为一组电动汽车确定最具成本效益的充放电计划。通过定义决策变量、基于能量动态的约束条件，以及一个平衡能量套利收益与退化和连接成本的目标函数，您将应用运筹学的核心原理来创建一个智能V2G策略。",
            "id": "3959482",
            "problem": "要求您推导、实现并求解一个基于能量守恒和线性设备约束第一性原理的车辆到电网（V2G）调度问题的混合整数线性优化问题。考虑一个由 $v \\in \\mathcal{V}$ 索引的电动汽车车队和由 $t \\in \\mathcal{T}$ 索引的离散时间步。基本基础是源于能量平衡的充电状态（SoC）动态学以及带有二元连接决策的线性功率约束。您必须推导一个混合整数线性规划（MILP），其决策变量是每个车辆每个时间步的二元连接状态 $x_{v,t} \\in \\{0,1\\}$ 和连续功率变量 $P_{v,t}$，强制执行可用性约束，并整合SoC动态学。您的最终程序必须在可用性窗口内枚举所有二元决策，并将得到的连续子问题作为线性规划求解至最优。\n\n使用以下基本基础：\n- 充电状态（SoC）的能量守恒：充电状态（SoC）$s_{v,t}$ 是车辆 $v$ 在时间 $t$ 的电池中存储能量的比例，定义在区间 $[0,1]$ 上。\n- 时间步 $\\Delta t$ 上的离散时间能量平衡：充电和放电对 $s_{v,t}$ 的影响与功率成正比，与可用能量成反比。\n- 线性设备约束：功率限制随连接状态而变化，且SoC有界。\n\n按如下方式定义模型。\n- 变量：\n  - 二元连接状态 $x_{v,t} \\in \\{0,1\\}$，表示车辆 $v$ 在时间 $t$ 是否物理连接并可以交换功率。\n  - 非负充电功率 $P^{+}_{v,t} \\ge 0$ 和非负放电功率 $P^{-}_{v,t} \\ge 0$，净功率为 $P_{v,t} = P^{+}_{v,t} - P^{-}_{v,t}$。\n  - 充电状态 (SoC) $s_{v,t} \\in [0,1]$。\n- 参数（给定）：\n  - 可用性窗口 $a_{v,t} \\in \\{0,1\\}$。\n  - 可用能量容量 $E_{v}$，单位为 $\\mathrm{kWh}$。\n  - 最大充电功率 $\\bar{P}^{+}_{v}$，单位为 $\\mathrm{kW}$。\n  - 最大放电功率 $\\bar{P}^{-}_{v}$，单位为 $\\mathrm{kW}$。\n  - 充电效率 $\\eta^{+}_{v} \\in (0,1]$ 和放电效率 $\\eta^{-}_{v} \\in (0,1]$。\n  - 电价 $c_{t}$，单位为美元/$\\mathrm{kWh}$。\n  - 退化惩罚系数 $\\alpha_{v}$，单位为美元/$\\mathrm{kWh}$ 吞吐量。\n  - 每时间步的连接开销 $\\gamma_{v}$，单位为美元。\n  - 初始SoC $s_{v,0} \\in [0,1]$；SoC界限 $s^{\\min}_{v}, s^{\\max}_{v} \\in [0,1]$；终端SoC要求 $s^{\\mathrm{req}}_{v} \\in [0,1]$。\n  - 时间步长 $\\Delta t$，单位为小时。\n- 待用第一性原理推导的约束：\n  - 可用性：对所有 $v,t$，有 $x_{v,t} \\le a_{v,t}$。\n  - 功率门控：对所有 $v,t$，有 $0 \\le P^{+}_{v,t} \\le \\bar{P}^{+}_{v} x_{v,t}$ 和 $0 \\le P^{-}_{v,t} \\le \\bar{P}^{-}_{v} x_{v,t}$。\n  - SoC动态学：对所有 $v$ 和所有 $t$ in $\\{0,\\dots,|\\mathcal{T}|-1\\}$，有 $s_{v,t+1} = s_{v,t} + \\dfrac{\\eta^{+}_{v} \\Delta t}{E_{v}} P^{+}_{v,t} - \\dfrac{\\Delta t}{\\eta^{-}_{v} E_{v}} P^{-}_{v,t}$。\n  - SoC界限：对所有 $v,t$，有 $s^{\\min}_{v} \\le s_{v,t} \\le s^{\\max}_{v}$，且 $s_{v,0} = \\text{给定}$。\n  - 终端要求：对所有 $v$，有 $s_{v,|\\mathcal{T}|} \\ge s^{\\mathrm{req}}_{v}$。\n- 待推导和实现的目标：最小化时间范围内的总货币成本，定义为购电成本减去售电收入，加上线性退化和连接开销惩罚的总和。形式上，最小化\n  $$\\sum_{t \\in \\mathcal{T}} \\sum_{v \\in \\mathcal{V}} \\left[ c_{t} \\Delta t \\left(P^{+}_{v,t} - P^{-}_{v,t}\\right) + \\alpha_{v} \\Delta t \\left(P^{+}_{v,t} + P^{-}_{v,t}\\right) + \\gamma_{v} x_{v,t} \\right].$$\n鉴于 $x_{v,t}$ 的二元性质和线性连续约束，这是一个混合整数线性规划。您的程序必须详尽枚举与 $a_{v,t}$ 一致的 $x_{v,t}$ 模式，并对每种模式，求解其连续子问题（即固定 $x_{v,t}$ 的线性规划）至全局最优。选择总成本最小的模式。由于测试实例很小，穷举法是可行的。\n\n物理单位和输出规范：\n- 功率 $P^{+}_{v,t}, P^{-}_{v,t}$ 必须以 $\\mathrm{kW}$ 为单位处理。\n- 能量容量 $E_{v}$ 必须以 $\\mathrm{kWh}$ 为单位处理。\n- 价格 $c_{t}$ 以美元/$\\mathrm{kWh}$ 为单位。\n- 时间步长 $\\Delta t$ 以小时为单位。\n- 充电状态 $s_{v,t}$ 是在 $[0,1]$ 区间内的无量纲量。\n- 将每个最优总成本以美元表示，四舍五入到 $3$ 位小数。\n\n测试套件。实现您的程序以计算并输出以下每个参数集的最优总成本：\n\n- 测试用例 $1$（一般情况）：\n  - $|\\mathcal{V}| = 2$, $|\\mathcal{T}| = 3$, $\\Delta t = 1$。\n  - 价格 $c_{t} = [0.15, 0.25, 0.20]$，单位为美元/$\\mathrm{kWh}$。\n  - 车辆 $1$：$E_{1} = 60$, $\\bar{P}^{+}_{1} = 7.2$, $\\bar{P}^{-}_{1} = 5.0$, $\\eta^{+}_{1} = 0.95$, $\\eta^{-}_{1} = 0.95$, $s_{1,0} = 0.50$, $s^{\\min}_{1} = 0.20$, $s^{\\max}_{1} = 0.90$, $s^{\\mathrm{req}}_{1} = 0.60$, $\\alpha_{1} = 0.01$, $\\gamma_{1} = 0.02$。\n  - 车辆 $2$：$E_{2} = 75$, $\\bar{P}^{+}_{2} = 11.0$, $\\bar{P}^{-}_{2} = 8.0$, $\\eta^{+}_{2} = 0.90$, $\\eta^{-}_{2} = 0.90$, $s_{2,0} = 0.60$, $s^{\\min}_{2} = 0.30$, $s^{\\max}_{2} = 0.90$, $s^{\\mathrm{req}}_{2} = 0.65$, $\\alpha_{2} = 0.015$, $\\gamma_{2} = 0.02$。\n  - 可用性 $a_{v,t}$：车辆 $1$ 在 $t = 0,1$ 时可用，在 $t = 2$ 时不可用；车辆 $2$ 在 $t = 1,2$ 时可用，在 $t = 0$ 时不可用。\n- 测试用例 $2$（带有负价格的边界情况）：\n  - $|\\mathcal{V}| = 1$, $|\\mathcal{T}| = 4$, $\\Delta t = 1$。\n  - 价格 $c_{t} = [-0.05, 0.10, 0.18, 0.12]$，单位为美元/$\\mathrm{kWh}$。\n  - 车辆 $1$：$E_{1} = 75$, $\\bar{P}^{+}_{1} = 7.0$, $\\bar{P}^{-}_{1} = 7.0$, $\\eta^{+}_{1} = 0.92$, $\\eta^{-}_{1} = 0.92$, $s_{1,0} = 0.40$, $s^{\\min}_{1} = 0.30$, $s^{\\max}_{1} = 0.95$, $s^{\\mathrm{req}}_{1} = 0.50$, $\\alpha_{1} = 0.01$, $\\gamma_{1} = 0.01$。\n  - 可用性 $a_{1,t} = 1$ 对所有 $t$ in $\\{0,1,2,3\\}$。\n- 测试用例 $3$（具有高退化成本的边缘情况）：\n  - $|\\mathcal{V}| = 2$, $|\\mathcal{T}| = 2$, $\\Delta t = 1$。\n  - 价格 $c_{t} = [0.20, 0.22]$，单位为美元/$\\mathrm{kWh}$。\n  - 车辆 $1$：$E_{1} = 60$, $\\bar{P}^{+}_{1} = 7.2$, $\\bar{P}^{-}_{1} = 5.0$, $\\eta^{+}_{1} = 0.95$, $\\eta^{-}_{1} = 0.95$, $s_{1,0} = 0.79$, $s^{\\min}_{1} = 0.20$, $s^{\\max}_{1} = 0.95$, $s^{\\mathrm{req}}_{1} = 0.80$, $\\alpha_{1} = 1.0$, $\\gamma_{1} = 0.00$。\n  - 车辆 $2$：$E_{2} = 60$, $\\bar{P}^{+}_{2} = 7.2$, $\\bar{P}^{-}_{2} = 5.0$, $\\eta^{+}_{2} = 0.95$, $\\eta^{-}_{2} = 0.95$, $s_{2,0} = 0.85$, $s^{\\min}_{2} = 0.20$, $s^{\\max}_{2} = 0.95$, $s^{\\mathrm{req}}_{2} = 0.85$, $\\alpha_{2} = 1.0$, $\\gamma_{2} = 0.00$。\n  - 可用性 $a_{1,t} = 1$ 对 $t \\in \\{0,1\\}$；可用性 $a_{2,t} = 0$ 对 $t \\in \\{0,1\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个方括号内的逗号分隔列表，例如 $\"[r_{1},r_{2},r_{3}]\"$，其中每个 $r_{i}$ 是测试用例 $i$ 的最优总成本（美元），四舍五入到 $3$ 位小数。",
            "solution": "用户提供了一个定义明确的车辆到电网（V2G）优化问题。第一步是验证问题陈述。\n\n### 步骤1：提取给定信息\n\n**集合与索引：**\n-   车辆：$v \\in \\mathcal{V}$。\n-   离散时间步：$t \\in \\mathcal{T} = \\{0, 1, \\dots, |\\mathcal{T}|-1\\}$。\n\n**决策变量：**\n-   二元连接状态：$x_{v,t} \\in \\{0,1\\}$。\n-   非负充电功率：$P^{+}_{v,t} \\ge 0$，单位为 $\\mathrm{kW}$。\n-   非负放电功率：$P^{-}_{v,t} \\ge 0$，单位为 $\\mathrm{kW}$。\n-   充电状态（SoC）：$s_{v,t} \\in [0,1]$。\n\n**参数：**\n-   可用性窗口：$a_{v,t} \\in \\{0,1\\}$。\n-   可用能量容量：$E_{v}$，单位为 $\\mathrm{kWh}$。\n-   最大充电功率：$\\bar{P}^{+}_{v}$，单位为 $\\mathrm{kW}$。\n-   最大放电功率：$\\bar{P}^{-}_{v}$，单位为 $\\mathrm{kW}$。\n-   充电效率：$\\eta^{+}_{v} \\in (0,1]$。\n-   放电效率：$\\eta^{-}_{v} \\in (0,1]$。\n-   电价：$c_{t}$，单位为美元/$\\mathrm{kWh}$。\n-   退化惩罚系数：$\\alpha_{v}$，单位为美元/$\\mathrm{kWh}$。\n-   连接开销：$\\gamma_{v}$，单位为美元/时间步。\n-   初始SoC：$s_{v,0} \\in [0,1]$。\n-   SoC界限：$s^{\\min}_{v}, s^{\\max}_{v} \\in [0,1]$。\n-   终端SoC要求：$s^{\\mathrm{req}}_{v} \\in [0,1]$。\n-   时间步长：$\\Delta t$，单位为小时。\n\n**约束（待形式化推导）：**\n1.  可用性：$x_{v,t} \\le a_{v,t}$。\n2.  功率门控：$0 \\le P^{+}_{v,t} \\le \\bar{P}^{+}_{v} x_{v,t}$ 和 $0 \\le P^{-}_{v,t} \\le \\bar{P}^{-}_{v} x_{v,t}$。\n3.  SoC动态学：$s_{v,t+1} = s_{v,t} + \\dfrac{\\eta^{+}_{v} \\Delta t}{E_{v}} P^{+}_{v,t} - \\dfrac{\\Delta t}{\\eta^{-}_{v} E_{v}} P^{-}_{v,t}$。\n4.  SoC界限：对所有 $t > 0$，有 $s^{\\min}_{v} \\le s_{v,t} \\le s^{\\max}_{v}$，且 $s_{v,0}$ 固定。\n5.  终端要求：$s_{v,|\\mathcal{T}|} \\ge s^{\\mathrm{req}}_{v}$。\n\n**目标函数（待形式化推导）：**\n-   最小化总成本：$\\sum_{t \\in \\mathcal{T}} \\sum_{v \\in \\mathcal{V}} \\left[ c_{t} \\Delta t \\left(P^{+}_{v,t} - P^{-}_{v,t}\\right) + \\alpha_{v} \\Delta t \\left(P^{+}_{v,t} + P^{-}_{v,t}\\right) + \\gamma_{v} x_{v,t} \\right]$。\n\n**求解方法：**\n-   穷举所有与 $a_{v,t}$ 一致的 $x_{v,t}$ 的二元模式。\n-   对每种模式，求解得到的连续子问题（一个线性规划）至最优。\n-   选择产生最小总成本的模式。\n\n**测试用例：**\n-   三个具体的测试用例，提供了所有参数。\n\n**输出格式：**\n-   单行输出，包含方括号内的逗号分隔列表，其中是每个测试用例的最优成本，四舍五入到3位小数。例如：`[r1,r2,r3]`。\n\n### 步骤2：使用提取的给定信息进行验证\n\n-   **科学依据（关键）：** 该问题基于能量守恒的基本原理，由充电状态（SoC）平衡方程表示。功率限制和SoC界限的约束是电池和电力系统建模中的标准做法。经济目标函数是能源市场中成本的传统表示。该模型在科学上是合理和现实的。\n-   **良构的：** 该问题是一个混合整数线性规划（MILP）。指定的求解方法，即对小实例穷举二元变量，是找到全局最优解的有效方法（尽管通常不具可扩展性）。每个产生的连续子问题都是一个线性规划（LP），它是凸的，标准求解器可以找到其唯一的（如果存在）最优解。问题结构是良构的。\n-   **客观性（关键）：** 问题使用精确的数学语言陈述，并为所有变量、参数和约束提供了明确的定义。它不含主观或基于意见的论断。\n-   **完整性与一致性：** 每个测试用例都提供了所有必要的参数。单位（$\\mathrm{kW}$、$\\mathrm{kWh}$、$\\mathrm{h}$、`\\$`）与模型中定义的物理和经济关系一致。例如，乘积 $c_t \\Delta t P_{v,t}$ 的单位是 $(\\$/\\mathrm{kWh}) \\cdot \\mathrm{h} \\cdot \\mathrm{kW} = \\$$，这对于成本项是正确的。问题陈述中没有矛盾之处。\n\n### 步骤3：结论与行动\n问题陈述有效。它具有科学依据，是良构的、客观的和完整的。我将继续进行求解。\n\n### 推导与公式化\n\n该问题是一个混合整数线性规划（MILP），旨在最小化参与车辆到电网服务的电动汽车车队的总运营成本。我们将首先形式化模型组件的推导，然后详细说明求解算法。\n\n**1. 模型推导**\n\n该模型建立在三个支柱上：能量平衡、线性设备约束和经济成本。\n\n-   **充电状态（SoC）动态学：** SoC，$s_{v,t}$，表示存储能量与总可用容量 $E_v$ 的比率。在一个时间步 $\\Delta t$ 内存储能量的变化是流入电池的净能量。当以功率 $P^{+}_{v,t}$ 充电时，添加到电池的能量是 $\\eta^{+}_{v} P^{+}_{v,t} \\Delta t$，其中 $\\eta^{+}_{v}$ 是充电效率。当以功率 $P^{-}_{v,t}$ 放电时，从电池中移除的能量是 $(1/\\eta^{-}_{v}) P^{-}_{v,t} \\Delta t$，其中输送到电网的能量是 $P^{-}_{v,t} \\Delta t$，而 $\\eta^{-}_{v}$ 是放电效率。\n    SoC的变化是存储能量的变化除以容量 $E_v$：\n    $$s_{v,t+1} - s_{v,t} = \\frac{\\eta^{+}_{v} P^{+}_{v,t} \\Delta t - (1/\\eta^{-}_{v}) P^{-}_{v,t} \\Delta t}{E_v}$$\n    整理后得到给定的状态转移方程：\n    $$s_{v,t+1} = s_{v,t} + \\frac{\\eta^{+}_{v} \\Delta t}{E_v} P^{+}_{v,t} - \\frac{\\Delta t}{\\eta^{-}_{v} E_v} P^{-}_{v,t}$$\n\n-   **功率约束：** 二元变量 $x_{v,t}$ 充当一个开关。如果车辆未连接（$x_{v,t}=0$），则不能交换功率，因此 $P^{+}_{v,t}=0$ 且 $P^{-}_{v,t}=0$。如果已连接（$x_{v,t}=1$），则功率受车辆硬件的限制，即 $\\bar{P}^{+}_{v}$ 和 $\\bar{P}^{-}_{v}$。这由“功率门控”约束捕获：\n    $$0 \\le P^{+}_{v,t} \\le \\bar{P}^{+}_{v} x_{v,t}$$\n    $$0 \\le P^{-}_{v,t} \\le \\bar{P}^{-}_{v} x_{v,t}$$\n    此外，车辆只有在物理上可用时才能连接，这要求 $x_{v,t} \\le a_{v,t}$。由于 $x_{v,t}$ 是二元的，这强制要求只有当 $a_{v,t}$ 为 $1$ 时，$x_{v,t}$ 才能为 $1$。\n\n-   **目标函数：** 总成本是三个组成部分的总和，在所有车辆和时间步上进行汇总。\n    1.  **能源成本：** 电力的净成本是价格 $c_t$ 乘以从电网吸取的净能量，即 $(P^{+}_{v,t} - P^{-}_{v,t}) \\Delta t$。\n    2.  **退化成本：** 电池退化通常被建模为与总能量吞吐量成正比。功率吞吐量是 $P^{+}_{v,t} + P^{-}_{v,t}$，因此能量吞吐量是 $(P^{+}_{v,t} + P^{-}_{v,t}) \\Delta t$。相关成本是 $\\alpha_v$ 乘以这个值。\n    3.  **连接成本：** 车辆连接的每个时间步都会产生一个固定成本 $\\gamma_v$，建模为 $\\gamma_v x_{v,t}$。\n\n    将这些项相加得到目标函数。我们可以按决策变量 $P^{+}$ 和 $P^{-}$ 对项进行分组：\n    $$\\min \\sum_{v,t} \\left[ \\Delta t (c_t + \\alpha_v) P^{+}_{v,t} + \\Delta t (\\alpha_v - c_t) P^{-}_{v,t} + \\gamma_v x_{v,t} \\right]$$\n\n**2. 求解策略：枚举与线性规划**\n\n按照规定，我们通过枚举二元变量 $x_{v,t}$ 的所有有效组合来求解MILP，并对每种组合求解得到的LP以获取连续变量。\n\n对于一个固定的二元模式 $\\mathbf{x} = \\{x_{v,t}\\}$，问题变成了一个线性规划（LP）。该LP的变量是所有 $v \\in \\mathcal{V}$ 和 $t \\in \\mathcal{T}$ 的连续变量 $\\{P^{+}_{v,t}, P^{-}_{v,t}, s_{v,t}\\}$。\n\n对于给定的 $\\mathbf{x}$，LP子问题是：\n$$\\text{最小化} \\quad \\sum_{v,t} \\left[ \\Delta t (c_t + \\alpha_v) P^{+}_{v,t} + \\Delta t (\\alpha_v - c_t) P^{-}_{v,t} \\right] + \\underbrace{\\sum_{v,t} \\gamma_v x_{v,t}}_{\\text{常数}}$$\n约束条件：\n1.  $0 \\le P^{+}_{v,t} \\le \\bar{P}^{+}_{v} x_{v,t}$ (其中 $x_{v,t}$ 是固定的 $0$ 或 $1$)\n2.  $0 \\le P^{-}_{v,t} \\le \\bar{P}^{-}_{v} x_{v,t}$ (其中 $x_{v,t}$ 是固定的 $0$ 或 $1$)\n3.  $s_{v,t+1} - s_{v,t} - \\frac{\\eta^{+}_{v} \\Delta t}{E_v} P^{+}_{v,t} + \\frac{\\Delta t}{\\eta^{-}_{v} E_v} P^{-}_{v,t} = 0 \\quad (\\text{对于 } t=0, \\dots, |\\mathcal{T}|-1)$\n4.  $s^{\\min}_{v} \\le s_{v,t} \\le s^{\\max}_{v} \\quad (\\text{对于 } t=1, \\dots, |\\mathcal{T}|)$\n5.  $s_{v,|\\mathcal{T}|} \\ge s^{\\mathrm{req}}_{v}$\n\n这个LP可以使用标准求解器如 `scipy.optimize.linprog` 来求解。\n\n**3. 使用 `scipy.optimize.linprog` 实现**\n\n要使用 `scipy.optimize.linprog`，我们必须将LP表述为标准形式：$\\min \\mathbf{c}^T \\mathbf{z}$，约束条件为 $\\mathbf{A}_{\\text{ub}} \\mathbf{z} \\le \\mathbf{b}_{\\text{ub}}$，$\\mathbf{A}_{\\text{eq}} \\mathbf{z} = \\mathbf{b}_{\\text{eq}}$，以及 $\\mathbf{lb} \\le \\mathbf{z} \\le \\mathbf{ub}$。\n\n-   **决策向量 $\\mathbf{z}$：** 我们将连续变量扁平化为一个向量 $\\mathbf{z}$。对于 $V=|\\mathcal{V}|$ 辆车和 $T=|\\mathcal{T}|$ 个时间范围，向量可以结构化为：\n    $$\\mathbf{z} = [P^{+}_{0,0}, \\dots, P^{+}_{V-1,T-1}, \\quad P^{-}_{0,0}, \\dots, P^{-}_{V-1,T-1}, \\quad s_{0,1}, \\dots, s_{V-1,T}]$$\n    总变量数为 $3VT$。\n\n-   **目标向量 $\\mathbf{c}$：** $\\mathbf{c}$ 中的系数对应于目标函数。对于变量 $P^{+}_{v,t}$，系数是 $\\Delta t (c_t + \\alpha_v)$。对于 $P^{-}_{v,t}$，它是 $\\Delta t (\\alpha_v - c_t)$。对于所有 $s_{v,t}$ 变量，系数为 $0$。固定成本部分 $\\sum \\gamma_v x_{v,t}$ 在求解后加到LP最优值 `result.fun` 上。\n\n-   **界限 ($\\mathbf{lb}, \\mathbf{ub}$):**\n    -   对于 $P^{+}_{v,t}$: $[0, \\bar{P}^{+}_{v} x_{v,t}]$\n    -   对于 $P^{-}_{v,t}$: $[0, \\bar{P}^{-}_{v} x_{v,t}]$\n    -   对于 $s_{v,t}$: $[s^{\\min}_{v}, s^{\\max}_{v}]$\n\n-   **等式约束 ($\\mathbf{A}_{\\text{eq}}, \\mathbf{b}_{\\text{eq}}$):** 这些表示SoC动态学。对于每个车辆 $v$ 和时间步 $t \\in \\{0, \\dots, T-1\\}$，我们有一个方程：\n    -   对于 $t=0$: $s_{v,1} - (\\frac{\\eta^{+}_{v}\\Delta t}{E_v})P^{+}_{v,0} + (\\frac{\\Delta t}{\\eta^{-}_{v}E_v})P^{-}_{v,0} = s_{v,0}$\n    -   对于 $t>0$: $s_{v,t+1} - s_{v,t} - (\\frac{\\eta^{+}_{v}\\Delta t}{E_v})P^{+}_{v,t} + (\\frac{\\Delta t}{\\eta^{-}_{v}E_v})P^{-}_{v,t} = 0$\n    这些方程定义了 $\\mathbf{A}_{\\text{eq}}$ 的行和 $\\mathbf{b}_{\\text{eq}}$ 的元素。\n\n-   **不等式约束 ($\\mathbf{A}_{\\text{ub}}, \\mathbf{b}_{\\text{ub}}$):** 这些捕获终端SoC要求 $s_{v,T} \\ge s^{\\mathrm{req}}_{v}$，可重写为 $-s_{v,T} \\le -s^{\\mathrm{req}}_{v}$。对于每个车辆 $v$，我们在 $\\mathbf{A}_{\\text{ub}}$ 中添加一行，在对应于 $s_{v,T}$ 的位置上为 $-1$，并在 $\\mathbf{b}_{\\text{ub}}$ 中有相应的条目 $-s^{\\mathrm{req}}_{v}$。\n\n整个算法由一个生成每个有效二元模式 $\\mathbf{x}$ 的外层循环和一个构建并求解上述LP的内层部分组成。在所有模式中找到的最小成本即为解。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            # Test case 1 (general case)\n            \"V\": 2, \"T\": 3, \"dt\": 1.0,\n            \"c\": np.array([0.15, 0.25, 0.20]),\n            \"vehicles\": [\n                {\n                    \"E\": 60.0, \"P_plus_max\": 7.2, \"P_minus_max\": 5.0,\n                    \"eta_plus\": 0.95, \"eta_minus\": 0.95,\n                    \"s_initial\": 0.50, \"s_min\": 0.20, \"s_max\": 0.90, \"s_req\": 0.60,\n                    \"alpha\": 0.01, \"gamma\": 0.02,\n                    \"a\": np.array([1, 1, 0])\n                },\n                {\n                    \"E\": 75.0, \"P_plus_max\": 11.0, \"P_minus_max\": 8.0,\n                    \"eta_plus\": 0.90, \"eta_minus\": 0.90,\n                    \"s_initial\": 0.60, \"s_min\": 0.30, \"s_max\": 0.90, \"s_req\": 0.65,\n                    \"alpha\": 0.015, \"gamma\": 0.02,\n                    \"a\": np.array([0, 1, 1])\n                }\n            ]\n        },\n        {\n            # Test case 2 (boundary with negative price)\n            \"V\": 1, \"T\": 4, \"dt\": 1.0,\n            \"c\": np.array([-0.05, 0.10, 0.18, 0.12]),\n            \"vehicles\": [\n                {\n                    \"E\": 75.0, \"P_plus_max\": 7.0, \"P_minus_max\": 7.0,\n                    \"eta_plus\": 0.92, \"eta_minus\": 0.92,\n                    \"s_initial\": 0.40, \"s_min\": 0.30, \"s_max\": 0.95, \"s_req\": 0.50,\n                    \"alpha\": 0.01, \"gamma\": 0.01,\n                    \"a\": np.array([1, 1, 1, 1])\n                }\n            ]\n        },\n        {\n            # Test case 3 (edge with high degradation cost)\n            \"V\": 2, \"T\": 2, \"dt\": 1.0,\n            \"c\": np.array([0.20, 0.22]),\n            \"vehicles\": [\n                {\n                    \"E\": 60.0, \"P_plus_max\": 7.2, \"P_minus_max\": 5.0,\n                    \"eta_plus\": 0.95, \"eta_minus\": 0.95,\n                    \"s_initial\": 0.79, \"s_min\": 0.20, \"s_max\": 0.95, \"s_req\": 0.80,\n                    \"alpha\": 1.0, \"gamma\": 0.00,\n                    \"a\": np.array([1, 1])\n                },\n                {\n                    \"E\": 60.0, \"P_plus_max\": 7.2, \"P_minus_max\": 5.0,\n                    \"eta_plus\": 0.95, \"eta_minus\": 0.95,\n                    \"s_initial\": 0.85, \"s_min\": 0.20, \"s_max\": 0.95, \"s_req\": 0.85,\n                    \"alpha\": 1.0, \"gamma\": 0.00,\n                    \"a\": np.array([0, 0])\n                }\n            ]\n        }\n    ]\n\n    results = []\n    for case_data in test_cases:\n        cost = solve_v2g_scheduling(case_data)\n        results.append(f\"{cost:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_v2g_scheduling(params):\n    \"\"\"\n    Solves the V2G scheduling MILP for a given test case by enumerating\n    binary connection patterns and solving the resulting LPs.\n    \"\"\"\n    V = params[\"V\"]\n    T = params[\"T\"]\n    dt = params[\"dt\"]\n    prices = params[\"c\"]\n    vehicles = params[\"vehicles\"]\n\n    # Generate all valid combinations of binary x_vt variables\n    vehicle_x_patterns = []\n    for v_idx in range(V):\n        availability = vehicles[v_idx][\"a\"]\n        available_slots = np.where(availability == 1)[0]\n        num_available = len(available_slots)\n        \n        patterns_for_v = []\n        for combo in itertools.product([0, 1], repeat=num_available):\n            x_v = np.zeros(T, dtype=int)\n            x_v[available_slots] = combo\n            patterns_for_v.append(x_v)\n        vehicle_x_patterns.append(patterns_for_v)\n\n    all_x_combinations = itertools.product(*vehicle_x_patterns)\n    \n    min_total_cost = float('inf')\n\n    # Variable indexing helpers\n    num_p_plus = V * T\n    num_p_minus = V * T\n    num_s = V * T\n    num_vars = num_p_plus + num_p_minus + num_s\n\n    def p_plus_idx(v, t): return v * T + t\n    def p_minus_idx(v, t): return num_p_plus + v * T + t\n    def s_idx(v, t): return num_p_plus + num_p_minus + v * T + (t - 1)\n\n    for x_combo in all_x_combinations:\n        x_matrix = np.array(x_combo)\n        \n        # --- Formulate and solve the LP subproblem ---\n        \n        # 1. Objective function vector c\n        c = np.zeros(num_vars)\n        fixed_connection_cost = 0.0\n        for v in range(V):\n            alpha_v = vehicles[v][\"alpha\"]\n            gamma_v = vehicles[v][\"gamma\"]\n            for t in range(T):\n                c[p_plus_idx(v, t)] = dt * (prices[t] + alpha_v)\n                c[p_minus_idx(v, t)] = dt * (alpha_v - prices[t])\n                fixed_connection_cost += gamma_v * x_matrix[v, t]\n\n        # 2. Bounds (lb, ub)\n        bounds = np.zeros((num_vars, 2))\n        for v in range(V):\n            for t in range(T):\n                bounds[p_plus_idx(v, t), 1] = vehicles[v][\"P_plus_max\"] * x_matrix[v, t]\n                bounds[p_minus_idx(v, t), 1] = vehicles[v][\"P_minus_max\"] * x_matrix[v, t]\n            for t in range(1, T + 1):\n                bounds[s_idx(v, t), 0] = vehicles[v][\"s_min\"]\n                bounds[s_idx(v, t), 1] = vehicles[v][\"s_max\"]\n\n        # 3. Equality constraints A_eq, b_eq (SoC dynamics)\n        A_eq = np.zeros((V * T, num_vars))\n        b_eq = np.zeros(V * T)\n        for v in range(V):\n            E_v = vehicles[v][\"E\"]\n            eta_plus_v = vehicles[v][\"eta_plus\"]\n            eta_minus_v = vehicles[v][\"eta_minus\"]\n            k_plus = (eta_plus_v * dt) / E_v\n            k_minus = dt / (eta_minus_v * E_v)\n            \n            for t in range(T):\n                row_idx = v * T + t\n                A_eq[row_idx, p_plus_idx(v, t)] = -k_plus\n                A_eq[row_idx, p_minus_idx(v, t)] = k_minus\n                if t == 0:\n                    A_eq[row_idx, s_idx(v, 1)] = 1\n                    b_eq[row_idx] = vehicles[v][\"s_initial\"]\n                else:\n                    A_eq[row_idx, s_idx(v, t)] = -1\n                    A_eq[row_idx, s_idx(v, t+1)] = 1\n\n        # 4. Inequality constraints A_ub, b_ub (Terminal SoC)\n        A_ub = np.zeros((V, num_vars))\n        b_ub = np.zeros(V)\n        for v in range(V):\n            A_ub[v, s_idx(v, T)] = -1\n            b_ub[v] = -vehicles[v][\"s_req\"]\n\n        # 5. Solve the LP\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=list(map(tuple, bounds)), method='highs')\n        \n        if res.success:\n            current_total_cost = res.fun + fixed_connection_cost\n            if current_total_cost  min_total_cost:\n                min_total_cost = current_total_cost\n\n    return min_total_cost\n    \nsolve()\n```"
        }
    ]
}