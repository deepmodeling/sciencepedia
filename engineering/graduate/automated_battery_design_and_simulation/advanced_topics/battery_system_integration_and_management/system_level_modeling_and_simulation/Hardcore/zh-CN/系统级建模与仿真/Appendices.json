{
    "hands_on_practices": [
        {
            "introduction": "电池包是由许多单体电池组成的系统，而这些单体之间的不一致性是不可避免的。本练习旨在探讨串联电池组中的这种不匹配如何限制整个电池包的性能。通过应用欧姆定律和荷电状态（SOC）定义等基本原理，我们将计算出“最弱”的电池组何时达到其电压极限，从而具体理解为何电芯均衡和严格筛选在电池包设计中至关重要 。",
            "id": "3954167",
            "problem": "考虑一个由三组串联电池串组成的电池包。每组电池串 $i \\in \\{1,2,3\\}$ 由 $N_i$ 个相同的电芯串联而成。同一电池串内的电芯彼此相同，但三组电池串在单位电芯容量、单位电芯内阻和开路电压特性上有所不同。该电池包以恒定电流 $I$ 从所有电池串的初始荷电状态 (SOC) $z_i(0)=1$ 开始放电。温度恒定且均匀，所有互连件均为理想的。\n\n电池串 $i$ 中的每个电芯具有：\n- 容量 $Q_i$（单位：安时, \\text{Ah}），因此电池串的库仑容量为 $C_i = Q_i \\times 3600$（单位：库仑）。\n- 内阻 $r_i$（单位：欧姆），因此电池串的串联电阻为 $R_i = N_i r_i$。\n- 单位电芯的开路电压 (OCV) 与 SOC 的线性模型为 $V_{\\text{ocv},i}(z_i) = V_{\\min,i} + \\Delta V_i z_i$，其中 $z_i \\in [0,1]$ 是电池串 $i$ 的 SOC，$V_{\\min,i}$ 是 $z_i=0$ 时的单位电芯 OCV，$\\Delta V_i$ 是从空电 ($z_i=0$) 到满电 ($z_i=1$) 的单位电芯 OCV 上升量。\n\n在负载下，电池串 $i$ 的端电压为 $V_i(t) = N_i V_{\\text{ocv},i}(z_i(t)) - I R_i$。根据基尔霍夫电压定律 (KVL)，电池包的端电压是各电池串端电压之和。电池串的电压限制由单位电芯的最低端电压 $V_{\\text{cut},i}$ 定义，因此当 $V_i(t) = N_i V_{\\text{cut},i}$ 时，达到电池串的限制。\n\n使用基本定律和定义，包括欧姆定律、KVL 以及串联电池串在恒流下的 SOC 速率方程 $dz_i/dt = - I / C_i$，来：\n\n- 推导 $V_i(t)$ 关于给定参数的表达式。\n- 推导每个电池串达到限制的时间 $t_i$，由 $V_i(t_i)=N_i V_{\\text{cut},i}$ 隐式定义。\n- 确定哪个电池串首先达到其电压限制，并计算最早的截止时间 $t^{\\ast} = \\min\\{t_1,t_2,t_3\\}$。\n\n参数值：\n- 电池包电流: $I = 60$。\n- 每个电池串的电芯数量: $N_1 = 12$, $N_2 = 12$, $N_3 = 12$。\n- 单位电芯容量: $Q_1 = 50$, $Q_2 = 52$, $Q_3 = 48$ (安时)。\n- 单位电芯内阻: $r_1 = 0.002$, $r_2 = 0.0025$, $r_3 = 0.0018$。\n- 单位电芯 OCV 参数: $V_{\\min,1} = 3.0$, $\\Delta V_1 = 0.55$; $V_{\\min,2} = 3.0$, $\\Delta V_2 = 0.60$; $V_{\\min,3} = 3.0$, $\\Delta V_3 = 0.50$。\n- 单位电芯截止端电压: $V_{\\text{cut},1} = 3.0$, $V_{\\text{cut},2} = 3.0$, $V_{\\text{cut},3} = 3.0$。\n\n将您的最终数值答案 $t^{\\ast}$ 四舍五入到 $4$ 位有效数字。最终时间以秒为单位表示。",
            "solution": "该问题要求确定一个由三组不同的串联电芯串组成的电池包的最早截止时间。分析过程将首先建立系统的控制方程，然后推导符号表达式，最后代入给定的数值以求得解。\n\n每个电池串 $i$ 的荷电状态 (SOC) $z_i(t)$ 由恒流放电的微分方程控制：\n$$\n\\frac{dz_i}{dt} = -\\frac{I}{C_i}\n$$\n其中 $I$ 是恒定放电电流，$C_i$ 是电池串 $i$ 的总库仑容量。对该方程进行积分，并使用初始条件 $z_i(0)=1$，可得到 SOC 作为时间函数的表达式：\n$$\n\\int_{z_i(0)}^{z_i(t)} dz'_i = \\int_{0}^{t} \\left(-\\frac{I}{C_i}\\right) dt'\n$$\n$$\nz_i(t) - z_i(0) = -\\frac{I}{C_i} t\n$$\n给定 $z_i(0) = 1$，SOC 的表达式为：\n$$\nz_i(t) = 1 - \\frac{I}{C_i} t\n$$\n\n电池串 $i$ 的端电压 $V_i(t)$ 由其电芯的开路电压之和减去总串联电阻上的电压降给出：\n$$\nV_i(t) = N_i V_{\\text{ocv},i}(z_i(t)) - I R_i\n$$\n单位电芯的开路电压 $V_{\\text{ocv},i}$ 被建模为 SOC 的线性函数：\n$$\nV_{\\text{ocv},i}(z_i) = V_{\\min,i} + \\Delta V_i z_i\n$$\n将 $V_{\\text{ocv},i}$ 的表达式代入 $V_i(t)$ 的方程中：\n$$\nV_i(t) = N_i (V_{\\min,i} + \\Delta V_i z_i(t)) - I R_i\n$$\n现在，代入先前推导出的 $z_i(t)$ 表达式：\n$$\nV_i(t) = N_i \\left( V_{\\min,i} + \\Delta V_i \\left(1 - \\frac{I}{C_i} t\\right) \\right) - I R_i\n$$\n该方程描述了在恒流放电期间每个电池串的端电压随时间线性变化的规律。\n\n每个电池串的达到限制时间 $t_i$ 定义为其端电压达到指定截止电压的时刻，即 $V_i(t_i) = N_i V_{\\text{cut},i}$。我们将 $V_i(t)$ 的表达式设为等于此限制，并求解 $t_i$：\n$$\nN_i V_{\\text{cut},i} = N_i \\left( V_{\\min,i} + \\Delta V_i \\left(1 - \\frac{I}{C_i} t_i\\right) \\right) - I R_i\n$$\n为了求解 $t_i$，我们重新整理各项：\n$$\nN_i V_{\\text{cut},i} + I R_i = N_i (V_{\\min,i} + \\Delta V_i) - \\frac{N_i \\Delta V_i I}{C_i} t_i\n$$\n$$\n\\frac{N_i \\Delta V_i I}{C_i} t_i = N_i (V_{\\min,i} + \\Delta V_i) - N_i V_{\\text{cut},i} - I R_i\n$$\n$$\nt_i = \\frac{C_i}{N_i \\Delta V_i I} \\left[ N_i (V_{\\min,i} + \\Delta V_i - V_{\\text{cut},i}) - I R_i \\right]\n$$\n这可以简化为：\n$$\nt_i = \\frac{C_i}{I} \\left( \\frac{V_{\\min,i} + \\Delta V_i - V_{\\text{cut},i}}{\\Delta V_i} - \\frac{I R_i}{N_i \\Delta V_i} \\right)\n$$\n对于这个问题，一个显著的简化是，所有电池串的 $V_{\\min,i} = V_{\\text{cut},i} = 3.0$。$t_i$ 的公式简化为：\n$$\nt_i = \\frac{C_i}{I} \\left( \\frac{\\Delta V_i}{\\Delta V_i} - \\frac{I R_i}{N_i \\Delta V_i} \\right) = \\frac{C_i}{I} \\left( 1 - \\frac{I R_i}{N_i \\Delta V_i} \\right)\n$$\n\n接下来，我们使用提供的数值计算每个电池串所需的参数和达到限制的时间。放电电流为 $I=60$。\n\n对于电池串 1：\n- $N_1=12$, $Q_1=50$, $r_1=0.002$, $V_{\\min,1}=3.0$, $\\Delta V_1=0.55$, $V_{\\text{cut},1}=3.0$。\n- $C_1 = Q_1 \\times 3600 = 50 \\times 3600 = 180000$ C。\n- $R_1 = N_1 r_1 = 12 \\times 0.002 = 0.024$ $\\Omega$。\n- $t_1 = \\frac{180000}{60} \\left( 1 - \\frac{60 \\times 0.024}{12 \\times 0.55} \\right) = 3000 \\left( 1 - \\frac{1.44}{6.6} \\right) = 3000 \\left( 1 - \\frac{12}{55} \\right) = 3000 \\left( \\frac{43}{55} \\right) \\approx 2345.4545...$ s。\n\n对于电池串 2：\n- $N_2=12$, $Q_2=52$, $r_2=0.0025$, $V_{\\min,2}=3.0$, $\\Delta V_2=0.60$, $V_{\\text{cut},2}=3.0$。\n- $C_2 = Q_2 \\times 3600 = 52 \\times 3600 = 187200$ C。\n- $R_2 = N_2 r_2 = 12 \\times 0.0025 = 0.030$ $\\Omega$。\n- $t_2 = \\frac{187200}{60} \\left( 1 - \\frac{60 \\times 0.030}{12 \\times 0.60} \\right) = 3120 \\left( 1 - \\frac{1.8}{7.2} \\right) = 3120 \\left( 1 - 0.25 \\right) = 3120 \\times 0.75 = 2340$ s。\n\n对于电池串 3：\n- $N_3=12$, $Q_3=48$, $r_3=0.0018$, $V_{\\min,3}=3.0$, $\\Delta V_3=0.50$, $V_{\\text{cut},3}=3.0$。\n- $C_3 = Q_3 \\times 3600 = 48 \\times 3600 = 172800$ C。\n- $R_3 = N_3 r_3 = 12 \\times 0.0018 = 0.0216$ $\\Omega$。\n- $t_3 = \\frac{172800}{60} \\left( 1 - \\frac{60 \\times 0.0216}{12 \\times 0.50} \\right) = 2880 \\left( 1 - \\frac{1.296}{6.0} \\right) = 2880 \\left( 1 - 0.216 \\right) = 2880 \\times 0.784 = 2257.92$ s。\n\n电池包的最早截止时间 $t^{\\ast}$ 是各电池串截止时间的最小值：\n$$\nt^{\\ast} = \\min\\{t_1, t_2, t_3\\} = \\min\\{2345.45..., 2340, 2257.92\\} = 2257.92 \\text{ s}\n$$\n电池串 3 的容量最低，并且综合其他参数，它首先达到其电压限制。\n\n最终答案必须四舍五入到 $4$ 位有效数字。\n$$\nt^{\\ast} = 2257.92 \\approx 2258 \\text{ s}\n$$",
            "answer": "$$\n\\boxed{2258}\n$$"
        },
        {
            "introduction": "在理解了电气行为之后，我们转向同样关键的热维度。电池包在运行过程中产生的热量必须得到有效管理，以确保安全性和长寿命。本实践将通过一个基于牛顿冷却定律的一阶常微分方程（ODE），对电池包的集总参数热模型进行建模 。通过在各种负载情景下实施并求解此模型，您将掌握模拟系统热响应的实用技能，这不仅是热管理系统设计的基础，也是更高级老化仿真的关键一环。",
            "id": "3954199",
            "problem": "您的任务是在系统层面为电池包的集总热动力学建模。假设电池包可以近似为一个由热容和到环境的热导表征的单个热节点。从能量守恒和牛顿冷却定律出发，电池包温度随时间变化的轨迹的第一性原理模型由一个一阶线性常微分方程 (ODE) 控制。具体来说，令 $T(t)$ 表示绝对温度（单位：开尔文），$T_{\\text{amb}}$ 表示环境温度（单位：开尔文），$C$ 表示热容（单位：焦耳/开尔文），$G$ 表示到环境的热导（单位：瓦特/开尔文），$Q_{\\text{gen}}(t)$ 表示内部产生的热量（单位：瓦特）。能量平衡给出了以下 ODE\n$$\nC \\,\\frac{dT}{dt}(t) \\;=\\; Q_{\\text{gen}}(t) \\;-\\; G \\,\\big(T(t) - T_{\\text{amb}}\\big).\n$$\n给定指定的初始条件 $T(0) = T_0$ 和时间范围 $t \\in [0, t_f]$，通过求解 ODE 计算温度轨迹 $T(t)$，然后量化在该时间范围内达到的峰值（最高）温度。将峰值温度以摄氏度表示，并四舍五入到三位小数。所有数值必须使用国际单位制 (SI)：温度使用开尔文（作为输入），时间使用秒，热容使用焦耳/开尔文，热导使用瓦特/开尔文，产热使用瓦特。当使用正弦函数时，角度必须以弧度为单位进行解释。\n\n您的程序必须评估以下四个测试用例，每个用例由 $(C, G, T_{\\text{amb}}, T_0, t_f, \\Delta t, Q_{\\text{gen}})$ 定义，其中 $\\Delta t$ 是用于对解进行求值的均匀时间步长，$Q_{\\text{gen}}$ 定义为时间的函数：\n\n- 测试用例 1（一般时变强迫，中等冷却，正弦产热）：\n  - $C = 5000$ $\\mathrm{J/K}$，\n  - $G = 25$ $\\mathrm{W/K}$，\n  - $T_{\\text{amb}} = 298.15$ $\\mathrm{K}$，\n  - $T_0 = 298.15$ $\\mathrm{K}$，\n  - $t_f = 1200$ $\\mathrm{s}$，\n  - $\\Delta t = 0.5$ $\\mathrm{s}$，\n  - $Q_{\\text{gen}}(t) = 40 + 80 \\sin\\!\\big(2\\pi t / 300\\big)$ $\\mathrm{W}$，其中 $2\\pi t / 300$ 以弧度为单位。\n\n- 测试用例 2（绝热边界条件，有限时长脉冲产热）：\n  - $C = 8000$ $\\mathrm{J/K}$，\n  - $G = 0$ $\\mathrm{W/K}$，\n  - $T_{\\text{amb}} = 298.15$ $\\mathrm{K}$，\n  - $T_0 = 298.15$ $\\mathrm{K}$，\n  - $t_f = 1000$ $\\mathrm{s}$，\n  - $\\Delta t = 0.5$ $\\mathrm{s}$，\n  - 对于 $0 \\le t  500$ $\\mathrm{s}$，$Q_{\\text{gen}}(t) = 50$ $\\mathrm{W}$，对于 $500 \\le t \\le 1000$ $\\mathrm{s}$，$Q_{\\text{gen}}(t) = 0$ $\\mathrm{W}$。\n\n- 测试用例 3（强冷却，斜坡-保持产热，初始温度低于环境温度）：\n  - $C = 2000$ $\\mathrm{J/K}$，\n  - $G = 500$ $\\mathrm{W/K}$，\n  - $T_{\\text{amb}} = 303.15$ $\\mathrm{K}$，\n  - $T_0 = 293.15$ $\\mathrm{K}$，\n  - $t_f = 600$ $\\mathrm{s}$，\n  - $\\Delta t = 0.2$ $\\mathrm{s}$，\n  - 对于 $0 \\le t  200$ $\\mathrm{s}$，$Q_{\\text{gen}}(t) = \\frac{100}{200}\\,t$ $\\mathrm{W}$，对于 $200 \\le t \\le 600$ $\\mathrm{s}$，$Q_{\\text{gen}}(t) = 100$ $\\mathrm{W}$。\n\n- 测试用例 4（中等冷却，指数衰减产热，初始温度高于环境温度）：\n  - $C = 10000$ $\\mathrm{J/K}$，\n  - $G = 40$ $\\mathrm{W/K}$，\n  - $T_{\\text{amb}} = 298.15$ $\\mathrm{K}$，\n  - $T_0 = 308.15$ $\\mathrm{K}$，\n  - $t_f = 600$ $\\mathrm{s}$，\n  - $\\Delta t = 0.5$ $\\mathrm{s}$，\n  - $Q_{\\text{gen}}(t) = 200 \\,\\exp\\!\\big(-t/100\\big)$ $\\mathrm{W}$。\n\n对于每个测试用例，在区间 $[0, t_f]$ 上使用给定的初始条件和参数求解 ODE，在间距为 $\\Delta t$ 的均匀时间网格上评估计算出的轨迹，并确定以摄氏度为单位的峰值温度，表示为四舍五入到三位小数的浮点数。您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，按测试用例的顺序列出结果，例如：$[T_{\\text{peak},1}, T_{\\text{peak},2}, T_{\\text{peak},3}, T_{\\text{peak},4}]$，其中每个 $T_{\\text{peak},i}$ 是测试用例 $i$ 的峰值温度，以摄氏度为单位，四舍五入到三位小数，并表示为浮点数（输出中不含百分号或单位）。",
            "solution": "该问题要求解一个一阶线性常微分方程 (ODE)，该方程为电池包的集总热动力学建模。任务是找出在四个不同场景下，指定时间范围内的峰值温度。\n\n首先，我们验证问题陈述。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n控制 ODE 为：\n$$\nC \\,\\frac{dT}{dt}(t) \\;=\\; Q_{\\text{gen}}(t) \\;-\\; G \\,\\big(T(t) - T_{\\text{amb}}\\big)\n$$\n初始条件为 $T(0) = T_0$。\n参数为：\n- $T(t)$：绝对温度，单位为开尔文 ($\\mathrm{K}$)。\n- $T_{\\text{amb}}$：环境温度，单位为开尔文 ($\\mathrm{K}$)。\n- $C$：热容，单位为焦耳/开尔文 ($\\mathrm{J/K}$)。\n- $G$：到环境的热导，单位为瓦特/开尔文 ($\\mathrm{W/K}$)。\n- $Q_{\\text{gen}}(t)$：内部产生的热量，单位为瓦特 ($\\mathrm{W}$)。\n- $t \\in [0, t_f]$：时间范围，单位为秒 ($\\mathrm{s}$)。\n- $\\Delta t$：时间步长，单位为秒 ($\\mathrm{s}$)。\n\n测试用例由元组 $(C, G, T_{\\text{amb}}, T_0, t_f, \\Delta t, Q_{\\text{gen}})$ 定义：\n- **测试用例 1**：$(5000, 25, 298.15, 298.15, 1200, 0.5, Q_{\\text{gen}}(t) = 40 + 80 \\sin(2\\pi t / 300))$。\n- **测试用例 2**：$(8000, 0, 298.15, 298.15, 1000, 0.5, Q_{\\text{gen}}(t) = 50 \\text{ 对于 } 0 \\le t  500, \\text{ 否则为 } 0)$。\n- **测试用例 3**：$(2000, 500, 303.15, 293.15, 600, 0.2, Q_{\\text{gen}}(t) = 0.5t \\text{ 对于 } 0 \\le t  200, \\text{ 否则为 } 100)$。\n- **测试用例 4**：$(10000, 40, 298.15, 308.15, 600, 0.5, Q_{\\text{gen}}(t) = 200 \\exp(-t/100))$。\n\n目标是求出以摄氏度表示的峰值温度，并四舍五入到三位小数。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该模型基于能量守恒和牛顿冷却定律，这是集总参数热分析中一种标准且有效的第一性原理方法。\n- **适定性**：该问题是一个适定的一阶线性 ODE 初值问题。对于分段连续的强迫函数 $Q_{\\text{gen}}(t)$，保证存在唯一且稳定的解。\n- **客观性**：问题陈述使用精确、客观和标准的科学术语进行阐述。\n\n该问题没有任何科学或逻辑上的缺陷，是自洽且明确的。\n\n**步骤 3：结论与行动**\n问题是 **有效的**。将提供一个解决方案。\n\n**数学解法**\n\n控制 ODE 可以重排为一阶线性 ODE 的标准形式：\n$$\n\\frac{dT}{dt}(t) + \\frac{G}{C} T(t) = \\frac{Q_{\\text{gen}}(t)}{C} + \\frac{G}{C} T_{\\text{amb}}\n$$\n令 $\\tau = C/G$ 为热时间常数。方程变为：\n$$\n\\frac{dT}{dt} + \\frac{1}{\\tau} T(t) = \\frac{1}{C}Q_{\\text{gen}}(t) + \\frac{1}{\\tau}T_{\\text{amb}}\n$$\n这是一个形如 $y' + p(t)y = q(t)$ 的 ODE，其中 $p(t) = 1/\\tau$。积分因子是 $I(t) = \\exp(\\int (1/\\tau) dt) = \\exp(t/\\tau)$。初值问题的一般解由卷积给出：\n$$\nT(t) = T(0)e^{-t/\\tau} + \\int_0^t e^{-(t-s)/\\tau} \\left(\\frac{Q_{\\text{gen}}(s)}{C} + \\frac{T_{\\text{amb}}}{\\tau}\\right) ds\n$$\n分离各项可得：\n$$\nT(t) = T_0 e^{-t/\\tau} + T_{\\text{amb}} \\int_0^t \\frac{1}{\\tau} e^{-(t-s)/\\tau} ds + \\frac{1}{C} \\int_0^t e^{-(t-s)/\\tau} Q_{\\text{gen}}(s) ds\n$$\n涉及 $T_{\\text{amb}}$ 的积分计算结果为 $T_{\\text{amb}}(1 - e^{-t/\\tau})$。合并各项，我们得到最终解的形式：\n$$\nT(t) = T_{\\text{amb}} + (T_0 - T_{\\text{amb}})e^{-t/\\tau} + \\frac{1}{C} e^{-t/\\tau} \\int_0^t e^{s/\\tau} Q_{\\text{gen}}(s) ds\n$$\n我们将此通用解应用于每个测试用例。\n\n**测试用例 1**\n此处，$C = 5000$，$G = 25$，$T_0 = T_{\\text{amb}} = 298.15$，且 $Q_{\\text{gen}}(t) = 40 + 80 \\sin(\\omega t)$，其中 $\\omega = 2\\pi/300$。\n时间常数为 $\\tau = C/G = 5000/25 = 200 \\, \\mathrm{s}$。由于 $T_0 = T_{\\text{amb}}$，解简化为：\n$$\nT(t) = T_{\\text{amb}} + \\frac{1}{C} \\int_0^t e^{-(t-s)/\\tau} (40 + 80\\sin(\\omega s)) ds\n$$\n该积分可以解析求解。解由一个常数部分和一个正弦部分组成：\n$$\n\\int_0^t e^{-(t-s)/\\tau} (40) ds = 40\\tau(1 - e^{-t/\\tau})\n$$\n$$\n\\int_0^t e^{-(t-s)/\\tau} (80\\sin(\\omega s)) ds = 80 e^{-t/\\tau} \\int_0^t e^{s/\\tau}\\sin(\\omega s)ds\n$$\n使用标准积分 $\\int e^{as}\\sin(bs)ds = \\frac{e^{as}}{a^2+b^2}(a\\sin(bs) - b\\cos(bs))$，其中 $a=1/\\tau$ 和 $b=\\omega$，我们得到完整解：\n$$\nT(t) = T_{\\text{amb}} + \\frac{40}{G}(1 - e^{-t/\\tau}) + \\frac{80}{G^2 + (C\\omega)^2} \\left[ G\\sin(\\omega t) - C\\omega\\cos(\\omega t) + C\\omega e^{-t/\\tau} \\right]\n$$\n通过在时间网格 $t \\in [0, 1200]$（步长 $\\Delta t = 0.5$）上对此函数进行数值评估并找到最大值，即可求得峰值温度。\n\n**测试用例 2**\n此处，$G=0$，这是一个绝热情况。ODE 大大简化：\n$$\nC \\frac{dT}{dt} = Q_{\\text{gen}}(t) \\implies T(t) = T_0 + \\frac{1}{C} \\int_0^t Q_{\\text{gen}}(s) ds\n$$\n产热是分段的：对于 $0 \\le t  500$，$Q_{\\text{gen}}(t) = 50$；对于 $500 \\le t \\le 1000$，$Q_{\\text{gen}}(t) = 0$。\n对于 $0 \\le t  500$：\n$$\nT(t) = T_0 + \\frac{1}{8000} \\int_0^t 50 ds = 298.15 + \\frac{50}{8000} t\n$$\n温度线性增加。在 $t=500$ 时，$T(500) = 298.15 + 50 \\times 500 / 8000 = 298.15 + 3.125 = 301.275 \\, \\mathrm{K}$。\n对于 $500 \\le t \\le 1000$：\n$$\nT(t) = T(500) + \\frac{1}{C} \\int_{500}^t 0 ds = 301.275 \\, \\mathrm{K}\n$$\n温度保持不变。温度轨迹是单调不减的，因此峰值温度为 $301.275 \\, \\mathrm{K}$，在所有 $t \\ge 500 \\, \\mathrm{s}$ 时出现。\n\n**测试用例 3**\n$Q_{\\text{gen}}(t)$ 是一个斜坡-保持函数，且 $T_0  T_{\\text{amb}}$。解是分段的。\n$\\tau = C/G = 2000/500 = 4 \\, \\mathrm{s}$。\n对于 $0 \\le t  200$，$Q_{\\text{gen}}(t) = kt$，其中 $k=0.5$。积分为 $\\int_0^t e^{s/\\tau} (ks) ds = k\\tau^2(e^{t/\\tau}(t/\\tau - 1) + 1)$。\n温度为：\n$$\nT(t) = T_{\\text{amb}} + (T_0 - T_{\\text{amb}})e^{-t/\\tau} + \\frac{k\\tau}{C}(t-\\tau) + \\frac{k\\tau^2}{C}e^{-t/\\tau}\n$$\n可以证明，导数 $\\frac{dT}{dt}$ 在此区间内始终为正。因此，温度是增加的。\n对于 $200 \\le t \\le 600$，$Q_{\\text{gen}} = 100 \\, \\mathrm{W}$。温度接近一个稳态值 $T_{ss} = T_{\\text{amb}} + Q_{\\text{gen}}/G = 303.15 + 100/500 = 303.35 \\, \\mathrm{K}$。\n解为 $T(t) = T_{ss} + (T(200) - T_{ss})e^{-(t-200)/\\tau}$。\n由于 $T(200) \\approx 303.346 \\, \\mathrm{K}  T_{ss}$，温度将继续单调增加，趋向于 $T_{ss}$。\n因此，整个时间范围内的峰值温度出现在终点，即 $t = t_f = 600 \\, \\mathrm{s}$。\n\n**测试用例 4**\n$Q_{\\text{gen}}(t) = 200e^{-\\alpha t}$，其中 $\\alpha=1/100$。热时间常数为 $\\tau = C/G = 10000/40 = 250 \\, \\mathrm{s}$。\n积分为 $\\int_0^t e^{s/\\tau} (200e^{-\\alpha s})ds = 200 \\int_0^t e^{(1/\\tau - \\alpha)s}ds$。由于 $\\alpha \\neq 1/\\tau$，这是一个标准指数积分。\n解为：\n$$\nT(t) = T_{\\text{amb}} + (T_0 - T_{\\text{amb}})e^{-t/\\tau} + \\frac{200}{C(1/\\tau - \\alpha)} \\left( e^{-\\alpha t} - e^{-t/\\tau} \\right)\n$$\n代入数值 $G-C\\alpha = 40 - 10000/100 = -60$：\n$$\nT(t) = 298.15 + 10 e^{-t/250} + \\frac{200}{-60}(e^{-t/100} - e^{-t/250}) = 298.15 - \\frac{10}{3}e^{-t/100} + \\frac{40}{3}e^{-t/250}\n$$\n为求峰值，我们检查 $t=0$ 处的导数：\n$$\nC \\frac{dT}{dt}\\bigg|_{t=0} = Q_{\\text{gen}}(0) - G(T(0) - T_{\\text{amb}}) = 200 - 40(308.15 - 298.15) = 200 - 40(10) = -200  0\n$$\n由于温度从一开始就下降，并且可以证明在 $t \\ge 0$ 时是单调的，因此最高温度出现在初始时刻 $t=0$。峰值温度为 $T_{\\text{peak}} = T(0) = T_0 = 308.15 \\, \\mathrm{K}$。\n\n最后，所有以开尔文为单位的峰值温度都将转换为摄氏度 ($T_C = T_K - 273.15$) 并四舍五入到三位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the peak battery temperature for four different test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Test Case 1: (C, G, Tamb, T0, tf, dt, Q_gen_params)\n        (5000, 25, 298.15, 298.15, 1200, 0.5, {'type': 'sinusoidal', 'params': (40, 80, 2*np.pi/300)}),\n        # Test Case 2:\n        (8000, 0, 298.15, 298.15, 1000, 0.5, {'type': 'pulse', 'params': (50, 500)}),\n        # Test Case 3:\n        (2000, 500, 303.15, 293.15, 600, 0.2, {'type': 'ramp_hold', 'params': (0.5, 100, 200)}),\n        # Test Case 4:\n        (10000, 40, 298.15, 308.15, 600, 0.5, {'type': 'exp_decay', 'params': (200, 1/100)}),\n    ]\n\n    results = []\n\n    for i, case in enumerate(test_cases):\n        C, G, Tamb, T0, tf, dt, q_gen_info = case\n        \n        # Define the time grid, ensuring the final time is included\n        t = np.arange(0, tf + dt, dt)\n        \n        T_t = None\n        \n        if i == 0: # Test Case 1: Sinusoidal Q_gen\n            w = q_gen_info['params'][2]\n            tau = C / G\n            \n            # Analytical solution\n            term1 = 40 / G * (1 - np.exp(-t / tau))\n            common_factor = 80 / (G**2 + (C * w)**2)\n            term2 = common_factor * (G * np.sin(w * t) - C * w * np.cos(w * t) + C * w * np.exp(-t / tau))\n            \n            # Since T0 = Tamb, the (T0 - Tamb) term is zero\n            T_t = Tamb + term1 + term2\n\n        elif i == 1: # Test Case 2: Adiabatic with pulse Q_gen\n            q_val, pulse_end = q_gen_info['params']\n            \n            # Analytical solution for G=0\n            T_t = np.zeros_like(t)\n            mask_pulse = t  pulse_end\n            mask_post_pulse = t >= pulse_end\n            \n            T_t[mask_pulse] = T0 + (q_val / C) * t[mask_pulse]\n            \n            T_at_pulse_end = T0 + (q_val / C) * pulse_end\n            T_t[mask_post_pulse] = T_at_pulse_end\n\n        elif i == 2: # Test Case 3: Ramp and hold Q_gen\n            k, q_hold, t_ramp_end = q_gen_info['params']\n            tau = C / G\n            \n            T_t = np.zeros_like(t)\n            \n            # Part 1: Ramp (0 = t  200)\n            mask_ramp = t  t_ramp_end\n            t_ramp = t[mask_ramp]\n            T_t[mask_ramp] = Tamb + (k * tau / C) * (t_ramp - tau) + \\\n                             (T0 - Tamb + k * tau**2 / C) * np.exp(-t_ramp / tau)\n            \n            # Part 2: Hold (200 = t = 600)\n            # Temperature at the end of the ramp\n            T_at_ramp_end = Tamb + (k * tau / C) * (t_ramp_end - tau) + \\\n                            (T0 - Tamb + k * tau**2 / C) * np.exp(-t_ramp_end / tau)\n            T_ss = Tamb + q_hold / G # steady state for the hold period\n            \n            mask_hold = t >= t_ramp_end\n            t_hold = t[mask_hold]\n            T_t[mask_hold] = T_ss + (T_at_ramp_end - T_ss) * np.exp(-(t_hold - t_ramp_end) / tau)\n\n        elif i == 3: # Test Case 4: Exponentially decaying Q_gen\n            alpha = q_gen_info['params'][1]\n            tau = C / G\n            \n            # The derivative at t=0 is negative, so the function is monotonically decreasing.\n            # The peak is therefore at t=0, which is T0.\n            # We can also compute the full trajectory to verify.\n            # T(t) = Tamb - (10/3)e^(-t/100) + (40/3)e^(-t/250)\n            T_t = Tamb - (10/3) * np.exp(-alpha * t) + (T0 - Tamb + 10/3) * np.exp(-t / tau)\n\n        # Find peak temperature in Kelvin\n        T_peak_K = np.max(T_t)\n        \n        # Convert to Celsius and round\n        T_peak_C = T_peak_K - 273.15\n        results.append(round(T_peak_C, 3))\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "结合我们对电气和热动态的理解，最后的实践将解决电池系统的一个终极问题：其使用寿命。容量衰减是一个复杂的过程，它取决于电池在整个生命周期中的使用方式。本练习将引导您实现一个结合了日历老化和循环老化效应的半经验模型，并应用阿伦尼乌斯方程来描述温度依赖性 。通过在一个重复的任务剖面上积分老化速率，您将获得预测电池寿命终点的实践经验，这项技能对于设计耐用的电池系统和评估不同使用策略至关重要。",
            "id": "3954233",
            "problem": "您的任务是开发一个完整的、可运行的程序，用于计算在重复性任务剖面下，系统级电池包的寿命终止时间。在此场景中，容量衰减由日历老化和循环老化共同导致。寿命终止时间定义为可用容量 $Q(t)$ 首次达到阈值 $Q_{\\text{EOL}}$ 的时间 $t$。容量的演变由一个老化速率决定，该速率取决于环境温度、电流和荷电状态。您的程序必须在分段恒定的占空比上对容量衰减进行积分，这些占空比会无限重复，直到 $Q(t)$ 达到 $Q_{\\text{EOL}}$。\n\n基本原理：\n- 容量 $Q(t)$ 以安培时 (Ah) 为单位。\n- 容量损失速率是日历老化和循环老化速率之和，这些速率源自 Arrhenius 定律和经验依赖关系：\n  - 日历老化速率\n    $$ r_{\\text{cal}}(T(t), \\text{SoC}(t)) = k_{\\text{cal},0}\\,\\exp\\!\\left(-\\frac{E_{a,\\text{cal}}}{R\\,T(t)}\\right)\\,\\left(\\text{SoC}(t)\\right)^{c_{\\text{cal}}}, $$\n  - 循环老化速率\n    $$ r_{\\text{cyc}}(T(t), I(t), \\text{SoC}(t)) = k_{\\text{cyc},0}\\,\\exp\\!\\left(-\\frac{E_{a,\\text{cyc}}}{R\\,T(t)}\\right)\\,\\left|I(t)\\right|^{b}\\,\\left(\\text{SoC}(t)\\right)^{c_{\\text{cyc}}}, $$\n  - 总容量损失速率\n    $$ \\frac{dQ}{dt} = -\\left(r_{\\text{cal}}(T(t), \\text{SoC}(t)) + r_{\\text{cyc}}(T(t), I(t), \\text{SoC}(t))\\right). $$\n- 通用气体常数为 $R = 8.314\\,\\text{J}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}$。\n- 指前因子和活化能（为确保科学真实性和量纲一致性而选择）如下：\n  - $k_{\\text{cal},0} = 300\\,\\text{Ah}\\,\\text{h}^{-1}$，\n  - $E_{a,\\text{cal}} = 30000\\,\\text{J}\\,\\text{mol}^{-1}$，\n  - $c_{\\text{cal}} = 1.2$，\n  - $k_{\\text{cyc},0} = 800\\,\\text{Ah}\\,\\text{h}^{-1}\\,\\text{A}^{-b}$，\n  - $E_{a,\\text{cyc}} = 40000\\,\\text{J}\\,\\text{mol}^{-1}$，\n  - $b = 0.6$，\n  - $c_{\\text{cyc}} = 0.8$。\n\n任务剖面模型与仿真要求：\n- 任务剖面是一个由 $n$ 个片段组成的有限序列，该序列无限重复。在片段 $i \\in \\{1,\\dots,n\\}$ 中，环境温度 $T$（单位：开尔文）、电流 $I$（单位：安培）、荷电状态 $\\text{SoC}$（无量纲分数）和持续时间 $\\tau$（单位：小时）均为恒定值。\n- 在每个条件恒定的片段中，容量线性下降：$Q(t + \\tau) = Q(t) - r\\,\\tau$，其中 $r$ 是该片段的日历老化速率和循环老化速率之和。\n- 该序列无变化地重复，直到 $Q(t)$ 首次达到 $Q_{\\text{EOL}}$。\n\n单位：\n- 温度必须以开尔文为单位处理。\n- 电流必须以安培为单位处理。\n- 荷电状态必须作为 $[0,1]$ 范围内的无量纲分数处理。\n- 持续时间必须以小时为单位处理。\n- 容量必须以安培时 (Ah) 为单位处理。\n- 最终的寿命终止时间以小时表示，并四舍五入到三位小数。\n\n测试套件：\n您的程序必须计算以下四个测试用例的寿命终止时间。每个用例由 $(Q_0, \\alpha, \\text{segments})$ 指定，其中 $Q_0$ 是初始容量（Ah），$Q_{\\text{EOL}} = \\alpha\\,Q_0$，segments 是一个元组列表 $(\\tau, T, I, \\text{SoC})$，单位如上所述。每个任务剖面都会无限重复。\n\n- 测试用例 1（中等条件，混合使用）：\n  - $Q_0 = 100$\n  - $\\alpha = 0.8$\n  - segments:\n    - $(\\tau = 2,\\; T = 298,\\; I = 50,\\; \\text{SoC} = 0.6)$\n    - $(\\tau = 1,\\; T = 310,\\; I = 100,\\; \\text{SoC} = 0.5)$\n    - $(\\tau = 1,\\; T = 298,\\; I = 0,\\; \\text{SoC} = 0.7)$\n- 测试用例 2（寒冷环境，低负载，更严苛的容量阈值）：\n  - $Q_0 = 85$\n  - $\\alpha = 0.7$\n  - segments:\n    - $(\\tau = 4,\\; T = 273,\\; I = 30,\\; \\text{SoC} = 0.5)$\n    - $(\\tau = 2,\\; T = 273,\\; I = 0,\\; \\text{SoC} = 0.8)$\n- 测试用例 3（炎热环境，高负载）：\n  - $Q_0 = 120$\n  - $\\alpha = 0.8$\n  - segments:\n    - $(\\tau = 0.5,\\; T = 330,\\; I = 180,\\; \\text{SoC} = 0.5)$\n    - $(\\tau = 0.5,\\; T = 330,\\; I = 150,\\; \\text{SoC} = 0.4)$\n    - $(\\tau = 1.0,\\; T = 320,\\; I = 20,\\; \\text{SoC} = 0.7)$\n- 测试用例 4（日历老化主导：主要在高荷电状态下静置）：\n  - $Q_0 = 60$\n  - $\\alpha = 0.75$\n  - segments:\n    - $(\\tau = 10,\\; T = 305,\\; I = 0,\\; \\text{SoC} = 0.9)$\n    - $(\\tau = 2,\\; T = 305,\\; I = 50,\\; \\text{SoC} = 0.6)$\n\n输出规格：\n- 您的程序应生成单行输出，其中包含所有四个测试用例的寿命终止时间，格式为用方括号括起来的逗号分隔列表，单位为小时，每个值四舍五入到三位小数（例如 $[t_1,t_2,t_3,t_4]$）。\n\n覆盖设计：\n- 测试用例 1 是一个通用的混合使用场景。\n- 测试用例 2 强调低温运行，循环老化减弱，寿命终止阈值更低。\n- 测试用例 3 强调高温、大电流循环。\n- 测试用例 4 强调在高荷电状态下长时间静置期间的日历老化。\n\n您的程序必须实现上述基于物理的速率模型，并计算出第一个满足 $Q(t) \\le Q_{\\text{EOL}}$ 的时间 $t$，假设任务剖面无限重复。",
            "solution": "该问题已经过验证，被认为是合理的。它在科学上基于已建立的电池老化经验模型，问题设定良好，具有唯一且稳定的解，并且自成体系，提供了所有必要的数据和定义。在重复性任务剖面的每个片段内保持荷电状态 (SoC) 恒定的简化处理，对于系统级仿真而言，是一种明确且可接受的建模选择，它使得问题易于处理且无歧义。\n\n问题的核心是确定电池的寿命终止时间 $t_{\\text{EOL}}$，定义为其容量 $Q(t)$ 从初始值 $Q_0$ 衰减到指定阈值 $Q_{\\text{EOL}}$ 的时刻。容量衰减由一个微分方程控制，该方程表示两种不同老化机制的总和：日历老化和循环老化。\n\n日历老化速率 $r_{\\text{cal}}$ 取决于温度 $T$ 和荷电状态 $\\text{SoC}$：\n$$\nr_{\\text{cal}}(T, \\text{SoC}) = k_{\\text{cal},0}\\,\\exp\\!\\left(-\\frac{E_{a,\\text{cal}}}{R\\,T}\\right)\\,\\left(\\text{SoC}\\right)^{c_{\\text{cal}}}\n$$\n循环老化速率 $r_{\\text{cyc}}$ 取决于温度 $T$、电流大小 $|I|$ 和荷电状态 $\\text{SoC}$：\n$$\nr_{\\text{cyc}}(T, I, \\text{SoC}) = k_{\\text{cyc},0}\\,\\exp\\!\\left(-\\frac{E_{a,\\text{cyc}}}{R\\,T}\\right)\\,\\left|I\\right|^{b}\\,\\left(\\text{SoC}\\right)^{c_{\\text{cyc}}}\n$$\n总容量损失速率是这两个分量的和：\n$$\n\\frac{dQ}{dt} = -(r_{\\text{cal}} + r_{\\text{cyc}})\n$$\n问题指定了一个由固定片段序列组成的任务剖面，该序列无限重复。在每个片段 $i$ 中，操作条件——温度 $T_i$、电流 $I_i$、荷电状态 $\\text{SoC}_i$ 和持续时间 $\\tau_i$——均为恒定值。这个关键的简化意味着每个片段的总老化速率 $r_i = r_{\\text{cal},i} + r_{\\text{cyc},i}$ 也是恒定的。因此，在一个片段内的容量损失与时间呈线性关系：$\\Delta Q_i = r_i \\tau_i$。\n\n算法解决方案涉及一个时间步进仿真，该仿真会迭代遍历任务剖面的各个片段，直到容量达到 $Q_{\\text{EOL}}$。\n\n算法如下：\n1.  定义所有物理和模型常数：通用气体常数 $R$，以及老化模型的参数 ($k_{\\text{cal},0}, E_{a,\\text{cal}}, c_{\\text{cal}}, k_{\\text{cyc},0}, E_{a,\\text{cyc}}, b, c_{\\text{cyc}}$)。\n2.  对于每个由 $(Q_0, \\alpha, \\text{segments})$ 指定的测试用例：\n    a. 计算寿命终止容量阈值：$Q_{\\text{EOL}} = \\alpha Q_0$。\n    b. 初始化仿真状态：当前容量 $Q_{\\text{current}} = Q_0$ 和已用时间 $t_{\\text{elapsed}} = 0$。\n    c. 为提高效率，预先计算任务剖面中每个片段 $i$ 的恒定总老化速率 $r_i$ 和总容量损失 $\\Delta Q_i$。\n    d. 进入一个仿真循环，该循环无限进行，直到满足 EOL 条件。\n    e. 在循环内部，遍历任务剖面的每个片段。对于每个片段 $i$：\n        i. 检查电池容量是否会在此片段期间下降到或低于 $Q_{\\text{EOL}}$。如果 $Q_{\\text{current}} - \\Delta Q_i \\le Q_{\\text{EOL}}$，则条件为真。\n        ii. 如果满足条件，则 EOL 在此片段内达到。所需的额外时间通过将剩余待损失容量 ($Q_{\\text{current}} - Q_{\\text{EOL}}$) 除以该片段的老化速率 $r_i$ 来计算。总寿命终止时间为 $t_{\\text{EOL}} = t_{\\text{elapsed}} + \\frac{Q_{\\text{current}} - Q_{\\text{EOL}}}{r_i}$。此测试用例的仿真终止，该值即为结果。\n        iii. 如果未达到 EOL，则完整地完成该片段。通过从当前容量中减去该片段的全部容量损失 ($Q_{\\text{current}} = Q_{\\text{current}} - \\Delta Q_i$) 并将片段的持续时间加到已用时间上 ($t_{\\text{elapsed}} = t_{\\text{elapsed}} + \\tau_i$) 来更新仿真状态。\n3.  收集所有测试用例的最终结果，四舍五入到三位小数，并格式化为指定的输出字符串。\n\n这种迭代方法通过模拟在重复的、分段恒定的占空比下的容量衰减，精确地计算出达到 EOL 的时间。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Define physical and model constants\nR = 8.314  # Universal gas constant in J mol^-1 K^-1\nK_CAL_0 = 300.0  # Ah h^-1\nE_A_CAL = 30000.0  # J mol^-1\nC_CAL = 1.2\nK_CYC_0 = 800.0  # Ah h^-1 A^-b\nE_A_CYC = 40000.0  # J mol^-1\nB = 0.6\nC_CYC = 0.8\n\ndef compute_eol_time(Q0, alpha, segments):\n    \"\"\"\n    Computes the end-of-life time for a battery pack under a repeating mission profile.\n\n    Args:\n        Q0 (float): Initial capacity in Ah.\n        alpha (float): EOL capacity threshold factor (Q_EOL = alpha * Q0).\n        segments (list): A list of tuples, where each tuple represents a mission\n                         segment as (tau, T, I, SoC).\n                         tau: duration in hours\n                         T: temperature in Kelvin\n                         I: current in Ampere\n                         SoC: state-of-charge as a fraction [0, 1]\n\n    Returns:\n        float: The end-of-life time in hours.\n    \"\"\"\n    Q_eol = alpha * Q0\n    \n    precomputed_segments = []\n    for tau, T, I, soc in segments:\n        # Calendar aging rate for this segment\n        r_cal = K_CAL_0 * np.exp(-E_A_CAL / (R * T)) * (soc ** C_CAL)\n\n        # Cycle aging rate for this segment\n        # The equation uses |I|, so we handle I=0 case where 0**B is undefined if B0\n        # although here B=0.6, so it's not a problem. abs(I) is specified.\n        if I == 0:\n            r_cyc = 0.0\n        else:\n            r_cyc = K_CYC_0 * np.exp(-E_A_CYC / (R * T)) * (abs(I) ** B) * (soc ** C_CYC)\n\n        total_rate = r_cal + r_cyc\n        delta_q_segment = total_rate * tau\n        \n        precomputed_segments.append({\n            'tau': tau,\n            'rate': total_rate,\n            'delta_q': delta_q_segment\n        })\n        \n    Q_current = Q0\n    time_elapsed = 0.0\n\n    # Simulation loop\n    while True:\n        for seg in precomputed_segments:\n            # Check if EOL is reached within this segment\n            # A rate of zero would mean infinite time to lose capacity, so check for it.\n            if seg['rate'] > 0 and Q_current - seg['delta_q'] = Q_eol:\n                # Capacity to lose until EOL\n                q_to_lose = Q_current - Q_eol\n                # Time to lose this capacity at the current segment's rate\n                time_in_segment = q_to_lose / seg['rate']\n                # Total EOL time\n                total_time = time_elapsed + time_in_segment\n                return total_time\n            \n            # If EOL not reached, complete the segment and update state\n            Q_current -= seg['delta_q']\n            time_elapsed += seg['tau']\n            \n            # In an edge case where all rates are zero, this loop could be infinite.\n            # However, the physical model with T>0K and SoC>0 ensures non-zero rates.\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the EOL for each, printing the final result.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (moderate conditions, mixed use)\n        (100.0, 0.8, [\n            (2.0, 298.0, 50.0, 0.6),\n            (1.0, 310.0, 100.0, 0.5),\n            (1.0, 298.0, 0.0, 0.7)\n        ]),\n        # Test case 2 (cold environment, low load)\n        (85.0, 0.7, [\n            (4.0, 273.0, 30.0, 0.5),\n            (2.0, 273.0, 0.0, 0.8)\n        ]),\n        # Test case 3 (hot environment, high load)\n        (120.0, 0.8, [\n            (0.5, 330.0, 180.0, 0.5),\n            (0.5, 330.0, 150.0, 0.4),\n            (1.0, 320.0, 20.0, 0.7)\n        ]),\n        # Test case 4 (calendar aging dominated)\n        (60.0, 0.75, [\n            (10.0, 305.0, 0.0, 0.9),\n            (2.0, 305.0, 50.0, 0.6)\n        ])\n    ]\n\n    results = []\n    for Q0, alpha, segments in test_cases:\n        eol_time = compute_eol_time(Q0, alpha, segments)\n        results.append(f\"{eol_time:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}