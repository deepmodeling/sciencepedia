{
    "hands_on_practices": [
        {
            "introduction": "A battery pack's performance is often dictated by its weakest component. In this practice, we explore this principle by modeling a pack with series-connected strings that have slight variations in capacity and resistance, a common result of manufacturing tolerances. By calculating the discharge behavior of each string , you will determine which string reaches its cutoff voltage first, thereby understanding how cell-to-cell imbalance can prematurely limit the entire pack's usable energy.",
            "id": "3954167",
            "problem": "Consider a battery pack composed of three series-connected strings. Each string $i \\in \\{1,2,3\\}$ consists of $N_i$ identical cells in series. The cells within a string are identical to each other but the three strings differ in their per-cell capacity, per-cell internal resistance, and open-circuit voltage characteristics. The pack is discharged at a constant current $I$ from an initial State of Charge (SOC) of $z_i(0)=1$ for all strings. The temperature is constant and homogeneous, and all interconnects are ideal.\n\nEach cell in string $i$ has:\n- Capacity $Q_i$ (in ampere-hours, Ah), so the string’s Coulomb capacity is $C_i = Q_i \\times 3600$ (in coulombs).\n- Internal resistance $r_i$ (in ohms), so the string’s series resistance is $R_i = N_i r_i$.\n- Open-Circuit Voltage (OCV) per cell modeled linearly with SOC as $V_{\\text{ocv},i}(z_i) = V_{\\min,i} + \\Delta V_i z_i$, where $z_i \\in [0,1]$ is the SOC of string $i$, $V_{\\min,i}$ is the per-cell OCV at $z_i=0$, and $\\Delta V_i$ is the per-cell OCV rise from empty ($z_i=0$) to full ($z_i=1$).\n\nUnder load, the terminal voltage of string $i$ is $V_i(t) = N_i V_{\\text{ocv},i}(z_i(t)) - I R_i$. The pack terminal voltage is the sum of the string terminal voltages by Kirchhoff’s Voltage Law (KVL). The string voltage limit is defined by a per-cell minimum terminal voltage $V_{\\text{cut},i}$, so the string limit is reached when $V_i(t) = N_i V_{\\text{cut},i}$.\n\nUse fundamental laws and definitions, including Ohm’s law, KVL, and the SOC rate equation $dz_i/dt = - I / C_i$ for series-connected strings under constant current, to:\n\n- Derive expressions for $V_i(t)$ in terms of the given parameters.\n- Derive the time-to-limit $t_i$ for each string, defined implicitly by $V_i(t_i)=N_i V_{\\text{cut},i}$.\n- Identify which string reaches its voltage limit first and compute the earliest cutoff time $t^{\\ast} = \\min\\{t_1,t_2,t_3\\}$.\n\nParameter values:\n- Pack current: $I = 60$ A.\n- Number of cells in each string: $N_1 = 12$, $N_2 = 12$, $N_3 = 12$.\n- Per-cell capacities: $Q_1 = 50$, $Q_2 = 52$, $Q_3 = 48$ (Ah).\n- Per-cell internal resistances: $r_1 = 0.002$, $r_2 = 0.0025$, $r_3 = 0.0018$ $\\Omega$.\n- Per-cell OCV parameters: $V_{\\min,1} = 3.0$ V, $\\Delta V_1 = 0.55$ V; $V_{\\min,2} = 3.0$ V, $\\Delta V_2 = 0.60$ V; $V_{\\min,3} = 3.0$ V, $\\Delta V_3 = 0.50$ V.\n- Per-cell cutoff terminal voltage: $V_{\\text{cut},1} = 3.0$ V, $V_{\\text{cut},2} = 3.0$ V, $V_{\\text{cut},3} = 3.0$ V.\n\nRound your final numerical answer $t^{\\ast}$ to $4$ significant figures. Express the final time in seconds.",
            "solution": "The problem requires the determination of the earliest cutoff time for a battery pack consisting of three distinct strings of cells connected in series. The analysis will proceed by first establishing the governing equations for the system, then deriving symbolic expressions, and finally substituting the given numerical values to find the solution.\n\nThe state of charge (SOC), $z_i(t)$, for each string $i$ is governed by the differential equation for constant current discharge:\n$$\n\\frac{dz_i}{dt} = -\\frac{I}{C_i}\n$$\nwhere $I$ is the constant discharge current and $C_i$ is the total Coulombic capacity of string $i$. Integrating this equation with the initial condition $z_i(0)=1$ yields the SOC as a function of time:\n$$\n\\int_{z_i(0)}^{z_i(t)} dz'_i = \\int_{0}^{t} \\left(-\\frac{I}{C_i}\\right) dt'\n$$\n$$\nz_i(t) - z_i(0) = -\\frac{I}{C_i} t\n$$\nGiven $z_i(0) = 1$, the expression for SOC is:\n$$\nz_i(t) = 1 - \\frac{I}{C_i} t\n$$\n\nThe terminal voltage of string $i$, $V_i(t)$, is given by the sum of the open-circuit voltages of its cells minus the voltage drop across the total string resistance:\n$$\nV_i(t) = N_i V_{\\text{ocv},i}(z_i(t)) - I R_i\n$$\nThe per-cell open-circuit voltage, $V_{\\text{ocv},i}$, is modeled as a linear function of SOC:\n$$\nV_{\\text{ocv},i}(z_i) = V_{\\min,i} + \\Delta V_i z_i\n$$\nSubstituting the expression for $V_{\\text{ocv},i}$ into the equation for $V_i(t)$:\n$$\nV_i(t) = N_i (V_{\\min,i} + \\Delta V_i z_i(t)) - I R_i\n$$\nNow, substituting the previously derived expression for $z_i(t)$:\n$$\nV_i(t) = N_i \\left( V_{\\min,i} + \\Delta V_i \\left(1 - \\frac{I}{C_i} t\\right) \\right) - I R_i\n$$\nThis equation describes the terminal voltage of each string as a linear function of time during the constant current discharge.\n\nThe time-to-limit, $t_i$, for each string is defined as the time when its terminal voltage reaches the specified cutoff voltage, $V_i(t_i) = N_i V_{\\text{cut},i}$. We set the expression for $V_i(t)$ equal to this limit and solve for $t_i$:\n$$\nN_i V_{\\text{cut},i} = N_i \\left( V_{\\min,i} + \\Delta V_i \\left(1 - \\frac{I}{C_i} t_i\\right) \\right) - I R_i\n$$\nTo solve for $t_i$, we rearrange the terms:\n$$\nN_i V_{\\text{cut},i} + I R_i = N_i (V_{\\min,i} + \\Delta V_i) - \\frac{N_i \\Delta V_i I}{C_i} t_i\n$$\n$$\n\\frac{N_i \\Delta V_i I}{C_i} t_i = N_i (V_{\\min,i} + \\Delta V_i - V_{\\text{cut},i}) - I R_i\n$$\n$$\nt_i = \\frac{C_i}{N_i \\Delta V_i I} \\left[ N_i (V_{\\min,i} + \\Delta V_i - V_{\\text{cut},i}) - I R_i \\right]\n$$\nThis can be simplified to:\n$$\nt_i = \\frac{C_i}{I} \\left( \\frac{V_{\\min,i} + \\Delta V_i - V_{\\text{cut},i}}{\\Delta V_i} - \\frac{I R_i}{N_i \\Delta V_i} \\right)\n$$\nA notable simplification occurs for this problem because $V_{\\min,i} = V_{\\text{cut},i} = 3.0$ V for all strings. The formula for $t_i$ reduces to:\n$$\nt_i = \\frac{C_i}{I} \\left( \\frac{\\Delta V_i}{\\Delta V_i} - \\frac{I R_i}{N_i \\Delta V_i} \\right) = \\frac{C_i}{I} \\left( 1 - \\frac{I R_i}{N_i \\Delta V_i} \\right)\n$$\n\nNext, we calculate the required parameters and the time-to-limit for each string using the provided numerical values. The discharge current is $I=60$ A.\n\nFor string 1:\n- $N_1=12$, $Q_1=50$ Ah, $r_1=0.002$ $\\Omega$, $V_{\\min,1}=3.0$ V, $\\Delta V_1=0.55$ V, $V_{\\text{cut},1}=3.0$ V.\n- $C_1 = Q_1 \\times 3600 = 50 \\times 3600 = 180000$ C.\n- $R_1 = N_1 r_1 = 12 \\times 0.002 = 0.024$ $\\Omega$.\n- $t_1 = \\frac{180000}{60} \\left( 1 - \\frac{60 \\times 0.024}{12 \\times 0.55} \\right) = 3000 \\left( 1 - \\frac{1.44}{6.6} \\right) = 3000 \\left( 1 - \\frac{12}{55} \\right) = 3000 \\left( \\frac{43}{55} \\right) \\approx 2345.4545...$ s.\n\nFor string 2:\n- $N_2=12$, $Q_2=52$ Ah, $r_2=0.0025$ $\\Omega$, $V_{\\min,2}=3.0$ V, $\\Delta V_2=0.60$ V, $V_{\\text{cut},2}=3.0$ V.\n- $C_2 = Q_2 \\times 3600 = 52 \\times 3600 = 187200$ C.\n- $R_2 = N_2 r_2 = 12 \\times 0.0025 = 0.030$ $\\Omega$.\n- $t_2 = \\frac{187200}{60} \\left( 1 - \\frac{60 \\times 0.030}{12 \\times 0.60} \\right) = 3120 \\left( 1 - \\frac{1.8}{7.2} \\right) = 3120 \\left( 1 - 0.25 \\right) = 3120 \\times 0.75 = 2340$ s.\n\nFor string 3:\n- $N_3=12$, $Q_3=48$ Ah, $r_3=0.0018$ $\\Omega$, $V_{\\min,3}=3.0$ V, $\\Delta V_3=0.50$ V, $V_{\\text{cut},3}=3.0$ V.\n- $C_3 = Q_3 \\times 3600 = 48 \\times 3600 = 172800$ C.\n- $R_3 = N_3 r_3 = 12 \\times 0.0018 = 0.0216$ $\\Omega$.\n- $t_3 = \\frac{172800}{60} \\left( 1 - \\frac{60 \\times 0.0216}{12 \\times 0.50} \\right) = 2880 \\left( 1 - \\frac{1.296}{6.0} \\right) = 2880 \\left( 1 - 0.216 \\right) = 2880 \\times 0.784 = 2257.92$ s.\n\nThe earliest cutoff time for the pack, $t^{\\ast}$, is the minimum of the individual string cutoff times:\n$$\nt^{\\ast} = \\min\\{t_1, t_2, t_3\\} = \\min\\{2345.45..., 2340, 2257.92\\} = 2257.92 \\text{ s}\n$$\nString 3, having the lowest capacity and a combination of other parameters, reaches its voltage limit first.\n\nThe final answer must be rounded to $4$ significant figures.\n$$\nt^{\\ast} = 2257.92 \\approx 2258 \\text{ s}\n$$",
            "answer": "$$\n\\boxed{2258}\n$$"
        },
        {
            "introduction": "Effective thermal management is paramount for ensuring a battery's safety, performance, and longevity. This exercise puts you in the role of a thermal engineer, tasked with predicting the temperature evolution of a battery pack using a fundamental lumped-parameter model. By solving the governing first-order ordinary differential equation for various realistic heat generation profiles , you will gain hands-on experience in simulating the core thermal dynamics that drive system-level design decisions.",
            "id": "3954199",
            "problem": "You are tasked with modeling the lumped thermal dynamics of a battery pack at the system level. Assume the battery pack can be approximated by a single thermal node characterized by a thermal capacitance and a thermal conductance to ambient. Starting from energy conservation and Newtonian cooling, the first-principles model of the pack temperature trajectory over time is governed by a first-order linear Ordinary Differential Equation (ODE). Specifically, let $T(t)$ denote the absolute temperature in Kelvin, $T_{\\text{amb}}$ denote the ambient temperature in Kelvin, $C$ denote the thermal capacitance in Joules per Kelvin, $G$ denote the thermal conductance to ambient in Watts per Kelvin, and $Q_{\\text{gen}}(t)$ denote the internally generated heat in Watts. The energy balance gives the ODE\n$$\nC \\,\\frac{dT}{dt}(t) \\;=\\; Q_{\\text{gen}}(t) \\;-\\; G \\,\\big(T(t) - T_{\\text{amb}}\\big).\n$$\nGiven a specified initial condition $T(0) = T_0$, and a time horizon $t \\in [0, t_f]$, compute the temperature trajectory $T(t)$ by solving the ODE and then quantify the peak (maximum) temperature attained over the horizon. Express the peak temperature in degrees Celsius, rounded to three decimal places. All numerical values must be used in International System of Units (SI): temperature in Kelvin (for inputs), time in seconds, thermal capacitance in Joules per Kelvin, thermal conductance in Watts per Kelvin, and heat generation in Watts. When sinusoidal functions are used, angles must be interpreted in radians.\n\nYour program must evaluate the following four test cases, each defined by $(C, G, T_{\\text{amb}}, T_0, t_f, \\Delta t, Q_{\\text{gen}})$, where $\\Delta t$ is the uniform time step for evaluation of the solution and $Q_{\\text{gen}}$ is defined as a function of time:\n\n- Test Case $1$ (general time-varying forcing, moderate cooling, sinusoidal heat generation):\n  - $C = 5000$ $\\mathrm{J/K}$,\n  - $G = 25$ $\\mathrm{W/K}$,\n  - $T_{\\text{amb}} = 298.15$ $\\mathrm{K}$,\n  - $T_0 = 298.15$ $\\mathrm{K}$,\n  - $t_f = 1200$ $\\mathrm{s}$,\n  - $\\Delta t = 0.5$ $\\mathrm{s}$,\n  - $Q_{\\text{gen}}(t) = 40 + 80 \\sin(2\\pi t / 300)$ $\\mathrm{W}$, where $2\\pi t / 300$ is in radians.\n\n- Test Case $2$ (adiabatic boundary case with a finite-duration pulse of heat generation):\n  - $C = 8000$ $\\mathrm{J/K}$,\n  - $G = 0$ $\\mathrm{W/K}$,\n  - $T_{\\text{amb}} = 298.15$ $\\mathrm{K}$,\n  - $T_0 = 298.15$ $\\mathrm{K}$,\n  - $t_f = 1000$ $\\mathrm{s}$,\n  - $\\Delta t = 0.5$ $\\mathrm{s}$,\n  - $Q_{\\text{gen}}(t) = 50$ $\\mathrm{W}$ for $0 \\le t < 500$ $\\mathrm{s}$ and $Q_{\\text{gen}}(t) = 0$ $\\mathrm{W}$ for $500 \\le t \\le 1000$ $\\mathrm{s}$.\n\n- Test Case $3$ (strong cooling, ramp-and-hold heat generation, initial temperature below ambient):\n  - $C = 2000$ $\\mathrm{J/K}$,\n  - $G = 500$ $\\mathrm{W/K}$,\n  - $T_{\\text{amb}} = 303.15$ $\\mathrm{K}$,\n  - $T_0 = 293.15$ $\\mathrm{K}$,\n  - $t_f = 600$ $\\mathrm{s}$,\n  - $\\Delta t = 0.2$ $\\mathrm{s}$,\n  - $Q_{\\text{gen}}(t) = \\frac{100}{200}\\,t$ $\\mathrm{W}$ for $0 \\le t < 200$ $\\mathrm{s}$ and $Q_{\\text{gen}}(t) = 100$ $\\mathrm{W}$ for $200 \\le t \\le 600$ $\\mathrm{s}$.\n\n- Test Case $4$ (moderate cooling, exponentially decaying heat generation, initial temperature above ambient):\n  - $C = 10000$ $\\mathrm{J/K}$,\n  - $G = 40$ $\\mathrm{W/K}$,\n  - $T_{\\text{amb}} = 298.15$ $\\mathrm{K}$,\n  - $T_0 = 308.15$ $\\mathrm{K}$,\n  - $t_f = 600$ $\\mathrm{s}$,\n  - $\\Delta t = 0.5$ $\\mathrm{s}$,\n  - $Q_{\\text{gen}}(t) = 200 \\exp(-t/100)$ $\\mathrm{W}$.\n\nFor each test case, solve the ODE over the interval $[0, t_f]$ with the given initial condition and parameters, evaluate the computed trajectory at the uniform time grid with spacing $\\Delta t$, and determine the peak temperature in degrees Celsius as a float rounded to three decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases, for example: $[T_{\\text{peak},1}, T_{\\text{peak},2}, T_{\\text{peak},3}, T_{\\text{peak},4}]$, where each $T_{\\text{peak},i}$ is the peak temperature for test case $i$ in degrees Celsius rounded to three decimals and expressed as a floating-point number (no percentage signs and no units in the output).",
            "solution": "The problem requires the solution of a first-order linear ordinary differential equation (ODE) modeling the lumped thermal dynamics of a battery pack. The task is to find the peak temperature over a specified time horizon for four different scenarios.\n\nFirst, we validate the problem statement.\n\n**Problem Validation**\n\n**Step 1: Extract Givens**\nThe governing ODE is:\n$$\nC \\,\\frac{dT}{dt}(t) \\;=\\; Q_{\\text{gen}}(t) \\;-\\; G \\,\\big(T(t) - T_{\\text{amb}}\\big)\n$$\nwith initial condition $T(0) = T_0$.\nThe parameters are:\n- $T(t)$: absolute temperature in Kelvin ($\\mathrm{K}$).\n- $T_{\\text{amb}}$: ambient temperature in Kelvin ($\\mathrm{K}$).\n- $C$: thermal capacitance in Joules per Kelvin ($\\mathrm{J/K}$).\n- $G$: thermal conductance to ambient in Watts per Kelvin ($\\mathrm{W/K}$).\n- $Q_{\\text{gen}}(t)$: internally generated heat in Watts ($\\mathrm{W}$).\n- $t \\in [0, t_f]$: time horizon in seconds ($\\mathrm{s}$).\n- $\\Delta t$: time step in seconds ($\\mathrm{s}$).\n\nTest cases are defined by the tuple $(C, G, T_{\\text{amb}}, T_0, t_f, \\Delta t, Q_{\\text{gen}})$:\n- **Test Case 1**: $(5000, 25, 298.15, 298.15, 1200, 0.5, Q_{\\text{gen}}(t) = 40 + 80 \\sin(2\\pi t / 300))$.\n- **Test Case 2**: $(8000, 0, 298.15, 298.15, 1000, 0.5, Q_{\\text{gen}}(t) = 50 \\text{ for } 0 \\le t < 500, 0 \\text{ otherwise})$.\n- **Test Case 3**: $(2000, 500, 303.15, 293.15, 600, 0.2, Q_{\\text{gen}}(t) = 0.5t \\text{ for } 0 \\le t < 200, 100 \\text{ otherwise})$.\n- **Test Case 4**: $(10000, 40, 298.15, 308.15, 600, 0.5, Q_{\\text{gen}}(t) = 200 \\exp(-t/100))$.\n\nThe objective is to find the peak temperature in degrees Celsius, rounded to three decimal places.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded**: The model is based on energy conservation and Newton's law of cooling, which is a standard and valid first-principles approach for lumped-parameter thermal analysis.\n- **Well-Posed**: The problem is a well-posed initial value problem for a first-order linear ODE. With piecewise continuous forcing functions $Q_{\\text{gen}}(t)$, a unique, stable solution is guaranteed to exist.\n- **Objective**: The problem statement is formulated with precise, objective, and standard scientific terminology.\n\nThe problem is free of any scientific or logical flaws, is self-contained, and is unambiguous.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. A solution will be provided.\n\n**Mathematical Solution**\n\nThe governing ODE can be rearranged into the standard form for a first-order linear ODE:\n$$\n\\frac{dT}{dt}(t) + \\frac{G}{C} T(t) = \\frac{Q_{\\text{gen}}(t)}{C} + \\frac{G}{C} T_{\\text{amb}}\n$$\nLet $\\tau = C/G$ be the thermal time constant. The equation becomes:\n$$\n\\frac{dT}{dt} + \\frac{1}{\\tau} T(t) = \\frac{1}{C}Q_{\\text{gen}}(t) + \\frac{1}{\\tau}T_{\\text{amb}}\n$$\nThis is an ODE of the form $y' + p(t)y = q(t)$ with $p(t) = 1/\\tau$. The integrating factor is $I(t) = \\exp(\\int (1/\\tau) dt) = \\exp(t/\\tau)$. The general solution for an initial value problem is given by convolution:\n$$\nT(t) = T(0)e^{-t/\\tau} + \\int_0^t e^{-(t-s)/\\tau} \\left(\\frac{Q_{\\text{gen}}(s)}{C} + \\frac{T_{\\text{amb}}}{\\tau}\\right) ds\n$$\nSeparating the terms gives:\n$$\nT(t) = T_0 e^{-t/\\tau} + T_{\\text{amb}} \\int_0^t \\frac{1}{\\tau} e^{-(t-s)/\\tau} ds + \\frac{1}{C} \\int_0^t e^{-(t-s)/\\tau} Q_{\\text{gen}}(s) ds\n$$\nThe integral involving $T_{\\text{amb}}$ evaluates to $T_{\\text{amb}}(1 - e^{-t/\\tau})$. Combining terms, we get the definitive solution form:\n$$\nT(t) = T_{\\text{amb}} + (T_0 - T_{\\text{amb}})e^{-t/\\tau} + \\frac{1}{C} e^{-t/\\tau} \\int_0^t e^{s/\\tau} Q_{\\text{gen}}(s) ds\n$$\nWe apply this general solution to each test case.\n\n**Test Case 1**\nHere, $C = 5000$, $G = 25$, $T_0 = T_{\\text{amb}} = 298.15$, and $Q_{\\text{gen}}(t) = 40 + 80 \\sin(\\omega t)$ with $\\omega = 2\\pi/300$.\nThe time constant is $\\tau = C/G = 5000/25 = 200 \\, \\mathrm{s}$. Since $T_0 = T_{\\text{amb}}$, the solution simplifies to:\n$$\nT(t) = T_{\\text{amb}} + \\frac{1}{C} \\int_0^t e^{-(t-s)/\\tau} (40 + 80\\sin(\\omega s)) ds\n$$\nThe integral can be solved analytically. The solution consists of a constant part and a sinusoidal part:\n$$\n\\int_0^t e^{-(t-s)/\\tau} (40) ds = 40\\tau(1 - e^{-t/\\tau})\n$$\n$$\n\\int_0^t e^{-(t-s)/\\tau} (80\\sin(\\omega s)) ds = 80 e^{-t/\\tau} \\int_0^t e^{s/\\tau}\\sin(\\omega s)ds\n$$\nUsing the standard integral $\\int e^{as}\\sin(bs)ds = \\frac{e^{as}}{a^2+b^2}(a\\sin(bs) - b\\cos(bs))$, with $a=1/\\tau$ and $b=\\omega$, we obtain the full solution:\n$$\nT(t) = T_{\\text{amb}} + \\frac{40}{G}(1 - e^{-t/\\tau}) + \\frac{80}{G^2 + (C\\omega)^2} \\left[ G\\sin(\\omega t) - C\\omega\\cos(\\omega t) + C\\omega e^{-t/\\tau} \\right]\n$$\nThe peak temperature is found by numerically evaluating this function over the time grid $t \\in [0, 1200]$ with $\\Delta t = 0.5$ and finding the maximum.\n\n**Test Case 2**\nHere, $G=0$, which is an adiabatic case. The ODE simplifies significantly:\n$$\nC \\frac{dT}{dt} = Q_{\\text{gen}}(t) \\implies T(t) = T_0 + \\frac{1}{C} \\int_0^t Q_{\\text{gen}}(s) ds\n$$\nThe heat generation is piecewise: $Q_{\\text{gen}}(t) = 50$ for $0 \\le t < 500$ and $Q_{\\text{gen}}(t) = 0$ for $500 \\le t \\le 1000$.\nFor $0 \\le t < 500$:\n$$\nT(t) = T_0 + \\frac{1}{8000} \\int_0^t 50 ds = 298.15 + \\frac{50}{8000} t\n$$\nThe temperature increases linearly. At $t=500$, $T(500) = 298.15 + 50 \\times 500 / 8000 = 298.15 + 3.125 = 301.275 \\, \\mathrm{K}$.\nFor $500 \\le t \\le 1000$:\n$$\nT(t) = T(500) + \\frac{1}{C} \\int_{500}^t 0 ds = 301.275 \\, \\mathrm{K}\n$$\nThe temperature remains constant. The trajectory is monotonically non-decreasing, so the peak temperature is $301.275 \\, \\mathrm{K}$, occurring for all $t \\ge 500 \\, \\mathrm{s}$.\n\n**Test Case 3**\n$Q_{\\text{gen}}(t)$ is a ramp-then-hold function, and $T_0 < T_{\\text{amb}}$. The solution is piecewise.\n$\\tau = C/G = 2000/500 = 4 \\, \\mathrm{s}$.\nFor $0 \\le t < 200$, $Q_{\\text{gen}}(t) = kt$ with $k=0.5$. The integral is $\\int_0^t e^{s/\\tau} (ks) ds = k\\tau^2(e^{t/\\tau}(t/\\tau - 1) + 1)$.\nThe temperature is:\n$$\nT(t) = T_{\\text{amb}} + (T_0 - T_{\\text{amb}})e^{-t/\\tau} + \\frac{k\\tau}{C}(t-\\tau) + \\frac{k\\tau^2}{C}e^{-t/\\tau}\n$$\nThe derivative $\\frac{dT}{dt}$ can be shown to be always positive in this interval. Thus, temperature is increasing.\nFor $200 \\le t \\le 600$, $Q_{\\text{gen}} = 100 \\, \\mathrm{W}$. The temperature approaches a steady-state value $T_{ss} = T_{\\text{amb}} + Q_{\\text{gen}}/G = 303.15 + 100/500 = 303.35 \\, \\mathrm{K}$.\nThe solution is $T(t) = T_{ss} + (T(200) - T_{ss})e^{-(t-200)/\\tau}$.\nSince $T(200) \\approx 303.346 \\, \\mathrm{K} < T_{ss}$, the temperature will continue to increase monotonically towards $T_{ss}$.\nTherefore, the peak temperature for the entire horizon occurs at the end, $t = t_f = 600 \\, \\mathrm{s}$.\n\n**Test Case 4**\n$Q_{\\text{gen}}(t) = 200e^{-\\alpha t}$ with $\\alpha=1/100$. The thermal time constant is $\\tau = C/G = 10000/40 = 250 \\, \\mathrm{s}$.\nThe integral is $\\int_0^t e^{s/\\tau} (200e^{-\\alpha s})ds = 200 \\int_0^t e^{(1/\\tau - \\alpha)s}ds$. Since $\\alpha \\neq 1/\\tau$, this is a standard exponential integral.\nThe solution is:\n$$\nT(t) = T_{\\text{amb}} + (T_0 - T_{\\text{amb}})e^{-t/\\tau} + \\frac{200}{C(1/\\tau - \\alpha)} \\left( e^{-\\alpha t} - e^{-t/\\tau} \\right)\n$$\nSubstituting values $G-C\\alpha = 40 - 10000/100 = -60$:\n$$\nT(t) = 298.15 + 10 e^{-t/250} + \\frac{200}{-60}(e^{-t/100} - e^{-t/250}) = 298.15 - \\frac{10}{3}e^{-t/100} + \\frac{40}{3}e^{-t/250}\n$$\nTo find the peak, we check the derivative at $t=0$:\n$$\nC \\frac{dT}{dt}\\bigg|_{t=0} = Q_{\\text{gen}}(0) - G(T(0) - T_{\\text{amb}}) = 200 - 40(308.15 - 298.15) = 200 - 40(10) = -200 < 0\n$$\nSince the temperature starts decreasing and can be shown to be monotonic for $t \\ge 0$, the maximum temperature occurs at the initial time, $t=0$. The peak temperature is $T_{\\text{peak}} = T(0) = T_0 = 308.15 \\, \\mathrm{K}$.\n\nFinally, all peak temperatures in Kelvin are converted to degrees Celsius ($T_C = T_K - 273.15$) and rounded to three decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the peak battery temperature for four different test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Test Case 1: (C, G, Tamb, T0, tf, dt, Q_gen_params)\n        (5000, 25, 298.15, 298.15, 1200, 0.5, {'type': 'sinusoidal', 'params': (40, 80, 2*np.pi/300)}),\n        # Test Case 2:\n        (8000, 0, 298.15, 298.15, 1000, 0.5, {'type': 'pulse', 'params': (50, 500)}),\n        # Test Case 3:\n        (2000, 500, 303.15, 293.15, 600, 0.2, {'type': 'ramp_hold', 'params': (0.5, 100, 200)}),\n        # Test Case 4:\n        (10000, 40, 298.15, 308.15, 600, 0.5, {'type': 'exp_decay', 'params': (200, 1/100)}),\n    ]\n\n    results = []\n\n    for i, case in enumerate(test_cases):\n        C, G, Tamb, T0, tf, dt, q_gen_info = case\n        \n        # Define the time grid, ensuring the final time is included\n        t = np.arange(0, tf + dt, dt)\n        \n        T_t = None\n        \n        if i == 0: # Test Case 1: Sinusoidal Q_gen\n            w = q_gen_info['params'][2]\n            tau = C / G\n            \n            # Analytical solution\n            term1 = 40 / G * (1 - np.exp(-t / tau))\n            common_factor = 80 / (G**2 + (C * w)**2)\n            term2 = common_factor * (G * np.sin(w * t) - C * w * np.cos(w * t) + C * w * np.exp(-t / tau))\n            \n            # Since T0 = Tamb, the (T0 - Tamb) term is zero\n            T_t = Tamb + term1 + term2\n\n        elif i == 1: # Test Case 2: Adiabatic with pulse Q_gen\n            q_val, pulse_end = q_gen_info['params']\n            \n            # Analytical solution for G=0\n            T_t = np.zeros_like(t)\n            mask_pulse = t  pulse_end\n            mask_post_pulse = t >= pulse_end\n            \n            T_t[mask_pulse] = T0 + (q_val / C) * t[mask_pulse]\n            \n            T_at_pulse_end = T0 + (q_val / C) * pulse_end\n            T_t[mask_post_pulse] = T_at_pulse_end\n\n        elif i == 2: # Test Case 3: Ramp and hold Q_gen\n            k, q_hold, t_ramp_end = q_gen_info['params']\n            tau = C / G\n            \n            T_t = np.zeros_like(t)\n            \n            # Part 1: Ramp (0 = t  200)\n            mask_ramp = t  t_ramp_end\n            t_ramp = t[mask_ramp]\n            T_t[mask_ramp] = Tamb + (k * tau / C) * (t_ramp - tau) + \\\n                             (T0 - Tamb + k * tau**2 / C) * np.exp(-t_ramp / tau)\n            \n            # Part 2: Hold (200 = t = 600)\n            # Temperature at the end of the ramp\n            T_at_ramp_end = Tamb + (k * tau / C) * (t_ramp_end - tau) + \\\n                            (T0 - Tamb + k * tau**2 / C) * np.exp(-t_ramp_end / tau)\n            T_ss = Tamb + q_hold / G # steady state for the hold period\n            \n            mask_hold = t >= t_ramp_end\n            t_hold = t[mask_hold]\n            T_t[mask_hold] = T_ss + (T_at_ramp_end - T_ss) * np.exp(-(t_hold - t_ramp_end) / tau)\n\n        elif i == 3: # Test Case 4: Exponentially decaying Q_gen\n            alpha = q_gen_info['params'][1]\n            tau = C / G\n            \n            # The derivative at t=0 is negative, so the function is monotonically decreasing.\n            # The peak is therefore at t=0, which is T0.\n            # We can also compute the full trajectory to verify.\n            # T(t) = Tamb - (10/3)e^(-t/100) + (40/3)e^(-t/250)\n            T_t = Tamb - (10/3) * np.exp(-alpha * t) + (T0 - Tamb + 10/3) * np.exp(-t / tau)\n\n        # Find peak temperature in Kelvin\n        T_peak_K = np.max(T_t)\n        \n        # Convert to Celsius and round\n        T_peak_C = T_peak_K - 273.15\n        results.append(round(T_peak_C, 3))\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "A central question in battery system design is predicting its operational lifespan under real-world usage conditions. This practice addresses that question by having you build a simulation to compute the battery's end-of-life based on cumulative capacity degradation. You will implement physics-informed aging models that account for both calendar and cycle aging, and integrate their effects over a repeating mission profile to forecast when the battery will no longer meet its performance requirements .",
            "id": "3954233",
            "problem": "You are tasked with developing a complete, runnable program that computes the end-of-life time for a battery pack at the system level under a repeating mission profile, where capacity fades due to both calendar aging and cycle aging. The end-of-life time is defined as the first time $t$ at which the available capacity $Q(t)$ reaches a threshold $Q_{\\text{EOL}}$. The capacity evolution is governed by an aging rate that depends on ambient temperature, current, and state-of-charge. Your program must integrate the capacity fade over piecewise-constant duty cycles that repeat indefinitely until $Q(t)$ reaches $Q_{\\text{EOL}}$.\n\nFundamental base:\n- Capacity $Q(t)$ is measured in ampere-hour (Ah).\n- The capacity loss rate is the sum of calendar aging and cycle aging rates derived from the Arrhenius law and empirical dependencies:\n  - Calendar aging rate\n    $$ r_{\\text{cal}}(T(t), \\text{SoC}(t)) = k_{\\text{cal},0}\\,\\exp\\!\\left(-\\frac{E_{a,\\text{cal}}}{R\\,T(t)}\\right)\\,\\left(\\text{SoC}(t)\\right)^{c_{\\text{cal}}}, $$\n  - Cycle aging rate\n    $$ r_{\\text{cyc}}(T(t), I(t), \\text{SoC}(t)) = k_{\\text{cyc},0}\\,\\exp\\!\\left(-\\frac{E_{a,\\text{cyc}}}{R\\,T(t)}\\right)\\,\\left|I(t)\\right|^{b}\\,\\left(\\text{SoC}(t)\\right)^{c_{\\text{cyc}}}, $$\n  - Total capacity loss rate\n    $$ \\frac{dQ}{dt} = -\\left(r_{\\text{cal}}(T(t), \\text{SoC}(t)) + r_{\\text{cyc}}(T(t), I(t), \\text{SoC}(t))\\right). $$\n- The universal gas constant is $R = 8.314\\,\\text{J}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}$.\n- The pre-exponential factors and activation energies (selected for scientific realism and dimensional consistency) are:\n  - $k_{\\text{cal},0} = 300\\,\\text{Ah}\\,\\text{h}^{-1}$,\n  - $E_{a,\\text{cal}} = 30000\\,\\text{J}\\,\\text{mol}^{-1}$,\n  - $c_{\\text{cal}} = 1.2$,\n  - $k_{\\text{cyc},0} = 800\\,\\text{Ah}\\,\\text{h}^{-1}\\,\\text{A}^{-b}$,\n  - $E_{a,\\text{cyc}} = 40000\\,\\text{J}\\,\\text{mol}^{-1}$,\n  - $b = 0.6$,\n  - $c_{\\text{cyc}} = 0.8$.\n\nMission profile model and simulation requirement:\n- The mission profile is a finite sequence of $n$ segments that repeats indefinitely. In segment $i \\in \\{1,\\dots,n\\}$, the ambient temperature $T$ (in kelvin), current $I$ (in ampere), state-of-charge $\\text{SoC}$ (unitless fraction), and duration $\\tau$ (in hours) are constant.\n- Over each segment with constant conditions, capacity decreases linearly: $Q(t + \\tau) = Q(t) - r\\,\\tau$, where $r$ is the sum of the calendar and cycle rates for that segment.\n- The sequence repeats without change until $Q(t)$ first reaches $Q_{\\text{EOL}}$.\n\nUnits:\n- Temperature must be treated in kelvin.\n- Current must be treated in ampere.\n- State-of-charge must be treated as a unitless fraction in $[0,1]$.\n- Duration must be treated in hours.\n- Capacity must be treated in ampere-hour (Ah).\n- Express the final end-of-life time in hours, rounded to three decimal places.\n\nTest suite:\nYour program must compute the end-of-life time for the following four test cases. Each case is specified by $(Q_0, \\alpha, \\text{segments})$, where $Q_0$ is the initial capacity in Ah, $Q_{\\text{EOL}} = \\alpha\\,Q_0$, and segments is a list of tuples $(\\tau, T, I, \\text{SoC})$ with the units described above. Each mission profile repeats indefinitely.\n\n- Test case $1$ (moderate conditions, mixed use):\n  - $Q_0 = 100$\n  - $\\alpha = 0.8$\n  - segments:\n    - $(\\tau = 2,\\; T = 298,\\; I = 50,\\; \\text{SoC} = 0.6)$\n    - $(\\tau = 1,\\; T = 310,\\; I = 100,\\; \\text{SoC} = 0.5)$\n    - $(\\tau = 1,\\; T = 298,\\; I = 0,\\; \\text{SoC} = 0.7)$\n- Test case $2$ (cold environment, low load, capacity threshold more aggressive):\n  - $Q_0 = 85$\n  - $\\alpha = 0.7$\n  - segments:\n    - $(\\tau = 4,\\; T = 273,\\; I = 30,\\; \\text{SoC} = 0.5)$\n    - $(\\tau = 2,\\; T = 273,\\; I = 0,\\; \\text{SoC} = 0.8)$\n- Test case $3$ (hot environment, high load):\n  - $Q_0 = 120$\n  - $\\alpha = 0.8$\n  - segments:\n    - $(\\tau = 0.5,\\; T = 330,\\; I = 180,\\; \\text{SoC} = 0.5)$\n    - $(\\tau = 0.5,\\; T = 330,\\; I = 150,\\; \\text{SoC} = 0.4)$\n    - $(\\tau = 1.0,\\; T = 320,\\; I = 20,\\; \\text{SoC} = 0.7)$\n- Test case $4$ (calendar aging dominated: mostly rest at high state-of-charge):\n  - $Q_0 = 60$\n  - $\\alpha = 0.75$\n  - segments:\n    - $(\\tau = 10,\\; T = 305,\\; I = 0,\\; \\text{SoC} = 0.9)$\n    - $(\\tau = 2,\\; T = 305,\\; I = 50,\\; \\text{SoC} = 0.6)$\n\nOutput specification:\n- Your program should produce a single line of output containing the end-of-life times for all four test cases, as a comma-separated list enclosed in square brackets, in hours, each rounded to three decimal places (e.g., $[t_1,t_2,t_3,t_4]$).\n\nDesign for coverage:\n- Test case $1$ is a general mixed-use scenario.\n- Test case $2$ emphasizes low-temperature operation with reduced cycle aging and lower end-of-life threshold.\n- Test case $3$ emphasizes high-temperature, high-current cycling.\n- Test case $4$ emphasizes calendar aging during long rest at high state-of-charge.\n\nYour program must implement the above physics-based rate model and compute the first time $t$ such that $Q(t) \\le Q_{\\text{EOL}}$, assuming the mission profile repeats indefinitely.",
            "solution": "The problem has been validated and is deemed sound. It is scientifically grounded in established empirical models for battery aging, well-posed with a unique and stable solution, and self-contained with all necessary data and definitions provided. The simplification of holding the State-of-Charge (SoC) constant within each segment of a repeating mission profile is an explicit and acceptable modeling choice for a system-level simulation, making the problem tractable and unambiguous.\n\nThe core of the problem is to determine the end-of-life time, $t_{\\text{EOL}}$, for a battery, defined as the time when its capacity $Q(t)$ degrades from an initial value $Q_0$ to a specified threshold $Q_{\\text{EOL}}$. The capacity degradation is governed by a differential equation representing the sum of two distinct aging mechanisms: calendar aging and cycle aging.\n\nThe calendar aging rate, $r_{\\text{cal}}$, depends on temperature $T$ and state-of-charge $\\text{SoC}$:\n$$\nr_{\\text{cal}}(T, \\text{SoC}) = k_{\\text{cal},0}\\,\\exp\\!\\left(-\\frac{E_{a,\\text{cal}}}{R\\,T}\\right)\\,\\left(\\text{SoC}\\right)^{c_{\\text{cal}}}\n$$\nThe cycle aging rate, $r_{\\text{cyc}}$, depends on temperature $T$, current magnitude $|I|$, and state-of-charge $\\text{SoC}$:\n$$\nr_{\\text{cyc}}(T, I, \\text{SoC}) = k_{\\text{cyc},0}\\,\\exp\\!\\left(-\\frac{E_{a,\\text{cyc}}}{R\\,T}\\right)\\,\\left|I\\right|^{b}\\,\\left(\\text{SoC}\\right)^{c_{\\text{cyc}}}\n$$\nThe total rate of capacity loss is the sum of these two components:\n$$\n\\frac{dQ}{dt} = -(r_{\\text{cal}} + r_{\\text{cyc}})\n$$\nThe problem specifies a mission profile composed of a fixed sequence of segments, repeating indefinitely. Within each segment $i$, the operating conditions—temperature $T_i$, current $I_i$, $\\text{SoC}_i$, and duration $\\tau_i$—are constant. This crucial simplification means the total aging rate $r_i = r_{\\text{cal},i} + r_{\\text{cyc},i}$ is also constant throughout each segment. The capacity loss during a segment is therefore linear with time: $\\Delta Q_i = r_i \\tau_i$.\n\nThe algorithmic solution involves a time-stepping simulation that iterates through the mission profile segments until the capacity reaches $Q_{\\text{EOL}}$.\n\nThe algorithm is as follows:\n1.  Define all physical and model constants: the universal gas constant $R$, and the parameters for the aging models ($k_{\\text{cal},0}, E_{a,\\text{cal}}, c_{\\text{cal}}, k_{\\text{cyc},0}, E_{a,\\text{cyc}}, b, c_{\\text{cyc}}$).\n2.  For each test case, specified by $(Q_0, \\alpha, \\text{segments})$:\n    a. Calculate the end-of-life capacity threshold: $Q_{\\text{EOL}} = \\alpha Q_0$.\n    b. Initialize the simulation state: current capacity $Q_{\\text{current}} = Q_0$ and elapsed time $t_{\\text{elapsed}} = 0$.\n    c. For improved efficiency, pre-calculate the constant total aging rate $r_i$ and the total capacity loss $\\Delta Q_i$ for each segment $i$ in the mission profile.\n    d. Enter a simulation loop that continues indefinitely until the EOL condition is met.\n    e. Inside the loop, iterate through each segment of the mission profile. For each segment $i$:\n        i. Check if the battery's capacity will drop to or below $Q_{\\text{EOL}}$ during this segment. This is true if $Q_{\\text{current}} - \\Delta Q_i \\le Q_{\\text{EOL}}$.\n        ii. If the condition is met, the EOL is reached within this segment. The additional time required is calculated by dividing the remaining capacity to be lost ($Q_{\\text{current}} - Q_{\\text{EOL}}$) by the segment's aging rate $r_i$. The total end-of-life time is $t_{\\text{EOL}} = t_{\\text{elapsed}} + \\frac{Q_{\\text{current}} - Q_{\\text{EOL}}}{r_i}$. The simulation for this test case terminates, and this value is the result.\n        iii. If the EOL is not reached, the segment completes fully. Update the simulation state by subtracting the segment's full capacity loss from the current capacity ($Q_{\\text{current}} = Q_{\\text{current}} - \\Delta Q_i$) and adding the segment's duration to the elapsed time ($t_{\\text{elapsed}} = t_{\\text{elapsed}} + \\tau_i$).\n3.  The final results for all test cases are collected, rounded to three decimal places, and formatted into the specified output string.\n\nThis iterative approach precisely calculates the time to EOL by simulating the capacity degradation over the repeating, piecewise-constant duty cycles.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Define physical and model constants\nR = 8.314  # Universal gas constant in J mol^-1 K^-1\nK_CAL_0 = 300.0  # Ah h^-1\nE_A_CAL = 30000.0  # J mol^-1\nC_CAL = 1.2\nK_CYC_0 = 800.0  # Ah h^-1 A^-b\nE_A_CYC = 40000.0  # J mol^-1\nB = 0.6\nC_CYC = 0.8\n\ndef compute_eol_time(Q0, alpha, segments):\n    \"\"\"\n    Computes the end-of-life time for a battery pack under a repeating mission profile.\n\n    Args:\n        Q0 (float): Initial capacity in Ah.\n        alpha (float): EOL capacity threshold factor (Q_EOL = alpha * Q0).\n        segments (list): A list of tuples, where each tuple represents a mission\n                         segment as (tau, T, I, SoC).\n                         tau: duration in hours\n                         T: temperature in Kelvin\n                         I: current in Ampere\n                         SoC: state-of-charge as a fraction [0, 1]\n\n    Returns:\n        float: The end-of-life time in hours.\n    \"\"\"\n    Q_eol = alpha * Q0\n    \n    precomputed_segments = []\n    for tau, T, I, soc in segments:\n        # Calendar aging rate for this segment\n        r_cal = K_CAL_0 * np.exp(-E_A_CAL / (R * T)) * (soc ** C_CAL)\n\n        # Cycle aging rate for this segment\n        # The equation uses |I|, so we handle I=0 case where 0**B is undefined if B0\n        # although here B=0.6, so it's not a problem. abs(I) is specified.\n        if I == 0:\n            r_cyc = 0.0\n        else:\n            r_cyc = K_CYC_0 * np.exp(-E_A_CYC / (R * T)) * (abs(I) ** B) * (soc ** C_CYC)\n\n        total_rate = r_cal + r_cyc\n        delta_q_segment = total_rate * tau\n        \n        precomputed_segments.append({\n            'tau': tau,\n            'rate': total_rate,\n            'delta_q': delta_q_segment\n        })\n        \n    Q_current = Q0\n    time_elapsed = 0.0\n\n    # Simulation loop\n    while True:\n        for seg in precomputed_segments:\n            # Check if EOL is reached within this segment\n            # A rate of zero would mean infinite time to lose capacity, so check for it.\n            if seg['rate'] > 0 and Q_current - seg['delta_q'] = Q_eol:\n                # Capacity to lose until EOL\n                q_to_lose = Q_current - Q_eol\n                # Time to lose this capacity at the current segment's rate\n                time_in_segment = q_to_lose / seg['rate']\n                # Total EOL time\n                total_time = time_elapsed + time_in_segment\n                return total_time\n            \n            # If EOL not reached, complete the segment and update state\n            Q_current -= seg['delta_q']\n            time_elapsed += seg['tau']\n            \n            # In an edge case where all rates are zero, this loop could be infinite.\n            # However, the physical model with T>0K and SoC>0 ensures non-zero rates.\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the EOL for each, printing the final result.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (moderate conditions, mixed use)\n        (100.0, 0.8, [\n            (2.0, 298.0, 50.0, 0.6),\n            (1.0, 310.0, 100.0, 0.5),\n            (1.0, 298.0, 0.0, 0.7)\n        ]),\n        # Test case 2 (cold environment, low load)\n        (85.0, 0.7, [\n            (4.0, 273.0, 30.0, 0.5),\n            (2.0, 273.0, 0.0, 0.8)\n        ]),\n        # Test case 3 (hot environment, high load)\n        (120.0, 0.8, [\n            (0.5, 330.0, 180.0, 0.5),\n            (0.5, 330.0, 150.0, 0.4),\n            (1.0, 320.0, 20.0, 0.7)\n        ]),\n        # Test case 4 (calendar aging dominated)\n        (60.0, 0.75, [\n            (10.0, 305.0, 0.0, 0.9),\n            (2.0, 305.0, 50.0, 0.6)\n        ])\n    ]\n\n    results = []\n    for Q0, alpha, segments in test_cases:\n        eol_time = compute_eol_time(Q0, alpha, segments)\n        results.append(f\"{eol_time:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}