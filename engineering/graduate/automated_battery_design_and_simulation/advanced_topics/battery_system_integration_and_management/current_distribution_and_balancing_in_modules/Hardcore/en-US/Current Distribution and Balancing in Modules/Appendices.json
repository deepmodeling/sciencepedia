{
    "hands_on_practices": [
        {
            "introduction": "The first step in mastering current balancing is to understand its fundamental origin. This practice  strips the problem down to its essential physics by modeling two cells as simple Thevenin equivalents connected in parallel. By applying basic circuit laws, you will derive the initial redistribution current that flows between them, driven solely by the difference in their open-circuit voltages ($OCV$) and limited by their internal resistances.",
            "id": "3902675",
            "problem": "Two electrochemical cells, hereafter referred to as cell $1$ and cell $2$, are initially isolated and then connected in parallel at time $t=0$ via an ideal, zero-resistance switch. Each cell is represented by a Thevenin model comprising an ideal voltage source equal to its Open-Circuit Voltage (OCV) and a series ohmic resistance. The Open-Circuit Voltage (OCV) of cell $i$ at its State of Charge (SOC) is denoted $OCV(SOC_i)=V_i$ for $i \\in \\{1,2\\}$, and its series resistance is $R_i0$. Assume the following:\n- The interconnect and switch resistances are negligible compared to $R_1$ and $R_2$.\n- Parasitic inductances and capacitances, including double-layer capacitance, are negligible, so that on a timescale immediately after connection, the State of Charge (SOC) is unchanged and $V_1$ and $V_2$ remain constant.\n- The cells are connected with like terminals together (positive to positive, negative to negative), so that immediately after connection a redistribution current flows only due to the difference in $V_1$ and $V_2$ through $R_1$ and $R_2$.\n\nDefine the initial redistribution current $I_{red}$ at $t=0^{+}$ to be positive when it flows from cell $1$ to cell $2$ through the positive terminal interconnect. Starting only from Kirchhoff’s Current Law, Kirchhoff’s Voltage Law, and Ohm’s law, derive a closed-form symbolic expression for $I_{red}$ in terms of $V_1$, $V_2$, $R_1$, and $R_2$. Express your final answer in amperes as a single analytic expression (no intermediate equalities).",
            "solution": "The problem statement is subjected to validation.\n\n### Step 1: Extract Givens\n- Two electrochemical cells, cell $1$ and cell $2$.\n- Connection is in parallel at time $t=0$.\n- Each cell is a Thevenin model: ideal voltage source $V_i = OCV(SOC_i)$ and series resistance $R_i0$ for $i \\in \\{1,2\\}$.\n- Interconnect and switch resistances are negligible.\n- Parasitic inductances and capacitances are negligible.\n- At $t=0^{+}$, SOC is unchanged, and $V_1$ and $V_2$ are constant.\n- Connection is with like terminals together (positive to positive, negative to negative).\n- Initial redistribution current $I_{red}$ at $t=0^{+}$ is positive when it flows from cell $1$ to cell $2$ through the positive terminal interconnect.\n- The derivation must start from Kirchhoff’s Current Law, Kirchhoff’s Voltage Law, and Ohm’s law.\n- The desired output is a closed-form symbolic expression for $I_{red}$ in terms of $V_1$, $V_2$, $R_1$, and $R_2$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem is based on the Thevenin equivalent circuit model, a fundamental and standard representation for voltage sources like batteries in circuit analysis. The use of Kirchhoff's laws and Ohm's law is appropriate and constitutes the basis of classical circuit theory. The scenario is a standard problem in electrical engineering and battery management systems. The problem is scientifically sound.\n- **Well-Posed:** The problem provides a complete set of parameters ($V_1$, $V_2$, $R_1$, $R_2$) and a clear circuit configuration. It requests a specific quantity, $I_{red}$, which can be uniquely determined from the given information and physical laws.\n- **Objective:** The problem is stated in precise, technical language, free from ambiguity or subjective content. The sign convention for the current $I_{red}$ is explicitly defined.\n\n### Step 3: Verdict and Action\nThe problem is valid as it is scientifically grounded, well-posed, objective, and self-contained. A rigorous solution can be derived from the provided information and fundamental principles.\n\n### Solution Derivation\nThe problem describes two Thevenin equivalent circuits connected in parallel. Cell $1$ is modeled as an ideal voltage source $V_1$ in series with a resistor $R_1$. Cell $2$ is modeled as an ideal voltage source $V_2$ in series with a resistor $R_2$. The cells are connected with positive terminals together and negative terminals together. This configuration creates a single, closed electrical loop containing both cells. The redistribution current $I_{red}$ flows within this loop.\n\nWe will apply Kirchhoff’s Voltage Law (KVL) to this loop. KVL states that the algebraic sum of the potential differences (voltages) around any closed loop is zero.\n\nLet's define the direction of the current $I_{red}$ in the loop. The problem states that $I_{red}$ is positive when it flows from cell $1$ to cell $2$. This means the current flows out of the positive terminal of cell $1$, through the interconnect, and into the positive terminal of cell $2$. We will assume $I_{red}$ flows in this direction, which corresponds to a clockwise direction if we draw cell $1$ on the left and cell $2$ on the right.\n\nLet's trace the loop starting from the negative terminal of the source $V_1$ and moving in the direction of $I_{red}$ (clockwise):\n\n$1$. Across the voltage source $V_1$: We move from the negative to the positive terminal, which constitutes a voltage rise of $+V_1$.\n$2$. Across the series resistor $R_1$: According to Ohm's law, a current $I_{red}$ flowing through a resistor $R_1$ causes a voltage drop. The potential decreases in the direction of the current, so the change in voltage is $-I_{red}R_1$.\n$3$. Across the voltage source $V_2$: Since the positive terminal of cell $1$ is connected to the positive terminal of cell $2$, the current $I_{red}$ enters the positive terminal of $V_2$ and exits the negative terminal. Traversing the source $V_2$ in the direction of the current means moving from its positive to its negative terminal, which is a voltage drop of $-V_2$.\n$4$. Across the series resistor $R_2$: The current $I_{red}$ continues through resistor $R_2$ back towards the negative terminal of $V_1$. This is in the direction of the current flow, so it results in another voltage drop of $-I_{red}R_2$.\n\nAccording to KVL, the sum of these voltage changes must be zero:\n$$+V_1 - I_{red}R_1 - V_2 - I_{red}R_2 = 0$$\n\nNow, we must solve this equation for $I_{red}$. We can group the terms involving $I_{red}$:\n$$V_1 - V_2 = I_{red}R_1 + I_{red}R_2$$\n\nFactoring out $I_{red}$ on the right-hand side gives:\n$$V_1 - V_2 = I_{red}(R_1 + R_2)$$\n\nFinally, dividing by the total series resistance of the loop, $(R_1 + R_2)$, yields the expression for the redistribution current $I_{red}$:\n$$I_{red} = \\frac{V_1 - V_2}{R_1 + R_2}$$\n\nThis expression is in terms of the given quantities $V_1$, $V_2$, $R_1$, and $R_2$, as required. The sign of $I_{red}$ is correctly determined by the relative magnitudes of $V_1$ and $V_2$. If $V_1  V_2$, $I_{red}$ is positive, indicating current flow from cell $1$ to cell $2$. If $V_2  V_1$, $I_{red}$ is negative, indicating current flow from cell $2$ to cell $1$, consistent with the definition provided.",
            "answer": "$$\\boxed{\\frac{V_1 - V_2}{R_1 + R_2}}$$"
        },
        {
            "introduction": "In real-world battery modules, electrical and thermal behaviors are inextricably linked. This exercise  moves beyond purely electrical models to explore this critical multiphysics coupling, where current distribution is influenced by temperature-dependent resistance. You will develop a model that captures the positive feedback loop between Joule heating, temperature rise, and current shifting, a phenomenon crucial for predicting and preventing thermal runaway.",
            "id": "3902728",
            "problem": "You are tasked with deriving and implementing a physically consistent model for the steady-state thermal-electrical interaction in a three-cell parallel module used in automated battery design and simulation. You must compute the steady-state temperature rise and the resulting current split among three parallel cells that have identical internal resistance at ambient temperature but different thermal conductance to ambient. The scenario is to be modeled using first principles and well-established relationships in electrothermal systems.\n\nAssume three cells indexed by $i \\in \\{1,2,3\\}$ connected in parallel delivering a specified total current. Each cell is modeled as:\n- A lumped electrical resistor with temperature-dependent resistance $R_i(T)$.\n- A lumped thermal node with steady convective heat removal parameterized by the product of convection coefficient and area $hA_i$.\n\nUse the following base relationships and definitions:\n- Joule heating: For a cell with current $I_i$ and resistance $R_i(T_i)$, the heat generation rate is $P_i = I_i^2 R_i(T_i)$.\n- Steady-state thermal balance: The heat transfer to ambient at steady state is $Q_i = hA_i \\Delta T_i$, where $\\Delta T_i = T_i - T_{amb}$ is the steady-state temperature rise.\n- Temperature dependence of resistance with a linear temperature coefficient: $R_i(T_i) = R_0 \\left(1 + \\alpha \\left(T_i - T_{amb}\\right)\\right)$, where $R_0$ is the common reference resistance at ambient temperature and $\\alpha$ is the temperature coefficient.\n- Parallel connection electrical constraint: All cells share the same terminal voltage drop $V$, and currents must satisfy $V = I_i R_i(T_i)$ for each $i$.\n- Current conservation: $I_1 + I_2 + I_3 = I_{tot}$.\n\nStarting from these relationships, derive the governing equations to compute both the steady-state temperature rises $\\Delta T_i$ and the current split $\\{I_1, I_2, I_3\\}$ for a given total pack current $I_{tot}$ and ambient temperature $T_{amb}$. Express $\\Delta T_i$ in $\\mathrm{K}$ and the currents $I_i$ in $\\mathrm{A}$.\n\nThe final program must compute the solution for the following test suite of parameter sets. Each parameter set is a tuple containing $(R_0,\\alpha,hA_1,hA_2,hA_3,I_{tot},T_{amb})$ with units specified as $\\Omega$, $\\mathrm{K}^{-1}$, $\\mathrm{W}/\\mathrm{K}$, $\\mathrm{W}/\\mathrm{K}$, $\\mathrm{W}/\\mathrm{K}$, $\\mathrm{A}$, and $\\mathrm{K}$ respectively:\n- Test case $1$ (general case, asymmetric cooling): $(R_0 = 0.002,\\ \\alpha = 0.003,\\ hA_1 = 1.0,\\ hA_2 = 1.2,\\ hA_3 = 0.8,\\ I_{tot} = 180.0,\\ T_{amb} = 298.15)$.\n- Test case $2$ (no temperature dependence, $\\alpha = 0$): $(R_0 = 0.002,\\ \\alpha = 0.0,\\ hA_1 = 1.0,\\ hA_2 = 1.2,\\ hA_3 = 0.8,\\ I_{tot} = 180.0,\\ T_{amb} = 298.15)$.\n- Test case $3$ (identical thermal paths): $(R_0 = 0.002,\\ \\alpha = 0.003,\\ hA_1 = 1.0,\\ hA_2 = 1.0,\\ hA_3 = 1.0,\\ I_{tot} = 180.0,\\ T_{amb} = 298.15)$.\n- Test case $4$ (high asymmetry, moderate current): $(R_0 = 0.002,\\ \\alpha = 0.003,\\ hA_1 = 0.6,\\ hA_2 = 1.8,\\ hA_3 = 1.2,\\ I_{tot} = 150.0,\\ T_{amb} = 298.15)$.\n\nYour program must:\n- Derive the necessary equations from the stated fundamental base.\n- Numerically solve for the shared terminal voltage $V$ and the currents $I_i$ that satisfy the parallel connection constraints and thermal steady-state.\n- Compute the steady-state temperature rises $\\Delta T_i$ using the energy balance.\n- Return results for each test case as a list in the form $[\\Delta T_1,\\Delta T_2,\\Delta T_3,I_1,I_2,I_3]$ with each value expressed as a decimal. Aggregate the results for all test cases into a single line of output containing a comma-separated list enclosed in square brackets, where each element is itself the list for that test case. For example, produce an output of the form $[[x_{11},x_{12},x_{13},x_{14},x_{15},x_{16}],[x_{21},x_{22},x_{23},x_{24},x_{25},x_{26}],\\ldots]$.\n\nExpress the temperature rises in $\\mathrm{K}$ and the currents in $\\mathrm{A}$, each rounded to six decimal places. Angles are not involved. No percentages are involved; all values must be decimals.",
            "solution": "We begin with three parallel cells indexed by $i \\in \\{1,2,3\\}$, each with identical ambient resistance $R_0$ and linear temperature coefficient $\\alpha$, but distinct thermal conductance to ambient $hA_i$. The ambient temperature is $T_{amb}$ and the total pack current is $I_{tot}$.\n\nWe use the following foundational relationships:\n- Joule heating in a resistor: $P_i = I_i^2 R_i(T_i)$.\n- Steady-state thermal balance (no heat capacity accumulation): $P_i = hA_i \\Delta T_i$, where $\\Delta T_i = T_i - T_{amb}$.\n- Linear temperature dependence of resistance: $R_i(T_i) = R_0 \\left(1 + \\alpha \\Delta T_i\\right)$.\n- Parallel connection with common terminal voltage: $V = I_i R_i(T_i)$ for each $i$.\n- Current conservation: $I_1 + I_2 + I_3 = I_{tot}$.\n\nFrom steady-state thermal balance and Joule heating, equate heat generation and removal:\n$$I_i^2 R_i(T_i) = hA_i \\Delta T_i.$$\nSubstituting the linear resistance model,\n$$I_i^2 R_0 \\left(1 + \\alpha \\Delta T_i\\right) = hA_i \\Delta T_i.$$\nSolve for $\\Delta T_i$ in terms of $I_i$ (algebraic isolation):\n$$I_i^2 R_0 + \\alpha I_i^2 R_0 \\Delta T_i = hA_i \\Delta T_i,$$\n$$(hA_i - \\alpha R_0 I_i^2) \\Delta T_i = R_0 I_i^2,$$\n$$\\Delta T_i = \\frac{R_0 I_i^2}{hA_i - \\alpha R_0 I_i^2}.$$\nThis expression is physically meaningful when the denominator is positive, i.e., $hA_i - \\alpha R_0 I_i^2  0$, indicating a stable steady state without thermal runaway.\n\nUsing the parallel condition $V = I_i R_i(T_i)$ with $R_i(T_i) = R_0 \\left(1 + \\alpha \\Delta T_i\\right)$, substitute the expression for $\\Delta T_i$ in terms of $I_i$:\n$$R_i(T_i) = R_0 \\left(1 + \\alpha \\cdot \\frac{R_0 I_i^2}{hA_i - \\alpha R_0 I_i^2}\\right) = R_0 \\cdot \\frac{hA_i}{hA_i - \\alpha R_0 I_i^2}.$$\nHence,\n$$V = I_i \\cdot R_0 \\cdot \\frac{hA_i}{hA_i - \\alpha R_0 I_i^2}.$$\nThis links $V$ and $I_i$ for each cell. Rearranging to an explicit polynomial in $I_i$ for a given $V$,\n$$V \\left(hA_i - \\alpha R_0 I_i^2\\right) = I_i R_0 hA_i,$$\n$$V hA_i - V \\alpha R_0 I_i^2 = I_i R_0 hA_i,$$\n$$V \\alpha R_0 I_i^2 + I_i R_0 hA_i - V hA_i = 0.$$\nThis is a quadratic in $I_i$:\n$$a_i I_i^2 + b_i I_i + c_i = 0,$$\nwith coefficients\n$$a_i = V \\alpha R_0,\\quad b_i = R_0 hA_i,\\quad c_i = - V hA_i.$$\nThe discriminant is\n$$D_i = b_i^2 - 4 a_i c_i = \\left(R_0 hA_i\\right)^2 + 4 V^2 \\alpha R_0 hA_i,$$\nwhich is nonnegative for all $V \\ge 0$, $\\alpha \\ge 0$, $R_0  0$, $hA_i  0$. The physically relevant root is the positive one:\n$$ I_i(V) = \\begin{cases} \\frac{V}{R_0},  \\text{if } \\alpha = 0 \\\\ \\\\ \\frac{-b_i + \\sqrt{D_i}}{2 a_i},  \\text{if } \\alpha > 0 \\end{cases} $$\nThe case $\\alpha = 0$ reduces to $I_i(V) = \\frac{V}{R_0}$ because $V = I_i R_0$ and all three cells are identical electrically; thermal parameters do not affect currents when electrical resistance is temperature independent.\n\nWe must determine $V$ such that the current conservation condition is satisfied:\n$$I_1(V) + I_2(V) + I_3(V) = I_{tot}.$$\nDefine\n$$S(V) = \\sum_{i=1}^{3} I_i(V).$$\nNote that $S(V)$ is a monotonically increasing function in $V$ over $V \\ge 0$ because each $I_i(V)$ increases with $V$ (the coefficients yield an increasing root due to positive discriminant dependence on $V$). For $\\alpha = 0$, $S(V) = \\frac{3 V}{R_0}$ and we obtain explicitly\n$$V^\\star = \\frac{I_{tot} R_0}{3},\\quad I_i^\\star = \\frac{V^\\star}{R_0} = \\frac{I_{tot}}{3}.$$\nFor $\\alpha  0$, we solve $S(V) = I_{tot}$ numerically via a robust bracketed method such as bisection:\n- Choose $V_{low} = 0$ with $S(V_{low}) = 0$.\n- Increase $V_{high}$ geometrically until $S(V_{high}) \\ge I_{tot}$.\n- Apply bisection on $[V_{low}, V_{high}]$ until convergence to a desired tolerance.\n\nOnce $V^\\star$ is found, compute currents $I_i^\\star = I_i(V^\\star)$ and then steady-state temperature rises with the earlier formula:\n$$ \\Delta T_i^\\star = \\begin{cases} \\frac{R_0 \\left(I_i^\\star\\right)^2}{hA_i},  \\text{if } \\alpha = 0 \\\\ \\\\ \\frac{R_0 \\left(I_i^\\star\\right)^2}{hA_i - \\alpha R_0 \\left(I_i^\\star\\right)^2},  \\text{if } \\alpha > 0 \\end{cases} $$\nThe special case $\\alpha = 0$ comes directly from $I_i^2 R_0 = hA_i \\Delta T_i$.\n\nAlgorithmic steps for each test case:\n- Input $(R_0,\\alpha,hA_1,hA_2,hA_3,I_{tot},T_{amb})$.\n- If $\\alpha = 0$, compute $V^\\star = \\frac{I_{tot} R_0}{3}$, $I_i^\\star = \\frac{V^\\star}{R_0}$ for all $i$, and $\\Delta T_i^\\star = \\frac{R_0 \\left(I_i^\\star\\right)^2}{hA_i}$.\n- If $\\alpha  0$, define $I_i(V)$ via the quadratic root above, bracket and solve $S(V) = I_{tot}$ via bisection, then compute $I_i^\\star$ and $\\Delta T_i^\\star$.\n- Report $[\\Delta T_1^\\star,\\Delta T_2^\\star,\\Delta T_3^\\star,I_1^\\star,I_2^\\star,I_3^\\star]$ with $\\Delta T_i^\\star$ in $\\mathrm{K}$ and $I_i^\\star$ in $\\mathrm{A}$, each rounded to six decimal places.\n\nEdge cases in the test suite:\n- Test case $2$ validates the $\\alpha = 0$ reduction where currents split equally irrespective of $hA_i$.\n- Test case $3$ uses identical $hA_i$ values to confirm symmetry when thermal paths are equal.\n- Test cases $1$ and $4$ explore asymmetry in thermal conductance leading to different temperature rises and current splits via electrothermal coupling.\n\nThe final program implements the above method for all test cases and prints a single line containing the aggregated results as a comma-separated list enclosed in square brackets, where each element is the list corresponding to one test case. No angles appear; temperatures are rises in $\\mathrm{K}$, and currents are in $\\mathrm{A}$, both as decimals rounded to six places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef i_of_v(V, R0, alpha, hA):\n    \"\"\"\n    Compute the cell current I as a function of terminal voltage V\n    for a single cell with parameters R0 (Ohm), alpha (1/K),\n    and hA (W/K), using the derived quadratic relation.\n    \"\"\"\n    if alpha == 0.0:\n        # Linear case: V = I * R0\n        return V / R0\n    # Quadratic coefficients: a I^2 + b I + c = 0\n    a = V * alpha * R0\n    b = R0 * hA\n    c = -V * hA\n    # Discriminant (always nonnegative for V>=0, alpha>=0, R0>0, hA>0)\n    D = b * b - 4.0 * a * c  # = b^2 + 4 V^2 alpha R0 hA\n    sqrtD = np.sqrt(D)\n    # Physical positive root\n    I = (-b + sqrtD) / (2.0 * a)\n    return I\n\ndef sum_currents(V, R0, alpha, hA_list):\n    return sum(i_of_v(V, R0, alpha, hA) for hA in hA_list)\n\ndef solve_case(params):\n    \"\"\"\n    params: tuple (R0, alpha, hA1, hA2, hA3, Itot, Tamb)\n    Returns: [dT1, dT2, dT3, I1, I2, I3] with floats rounded to 6 decimals.\n    \"\"\"\n    R0, alpha, hA1, hA2, hA3, Itot, Tamb = params\n    hA_list = [hA1, hA2, hA3]\n\n    if alpha == 0.0:\n        # Closed form for V and currents\n        V_star = Itot * R0 / 3.0\n        I_list = [V_star / R0] * 3\n    else:\n        # Find V_star such that sum_currents(V_star) = Itot using bisection\n        V_low = 0.0\n        # A reasonable initial high bound; escalate if needed\n        V_high = max(Itot * R0, 1e-6)\n        # Ensure upper bound yields sum >= Itot\n        max_iters_expand = 100\n        for _ in range(max_iters_expand):\n            S = sum_currents(V_high, R0, alpha, hA_list)\n            if S >= Itot:\n                break\n            V_high *= 2.0\n        else:\n            # Fallback: if expansion failed, set a very high bound\n            V_high = max(V_high, Itot * R0 * 100.0)\n\n        # Bisection\n        tol = 1e-12\n        max_iters_bisect = 200\n        for _ in range(max_iters_bisect):\n            V_mid = 0.5 * (V_low + V_high)\n            S_mid = sum_currents(V_mid, R0, alpha, hA_list)\n            if abs(S_mid - Itot)  tol:\n                V_star = V_mid\n                break\n            if S_mid  Itot:\n                V_low = V_mid\n            else:\n                V_high = V_mid\n        else:\n            V_star = 0.5 * (V_low + V_high)\n\n        I_list = [i_of_v(V_star, R0, alpha, hA) for hA in hA_list]\n\n    # Compute steady-state temperature rises\n    dT_list = []\n    for I, hA in zip(I_list, hA_list):\n        if alpha == 0.0:\n            dT = (R0 * I * I) / hA\n        else:\n            denom = hA - alpha * R0 * I * I\n            # To maintain physical consistency, denom should be > 0.\n            # If numerical noise causes nonpositive denom, set to NaN.\n            if denom = 0.0:\n                dT = np.nan\n            else:\n                dT = (R0 * I * I) / denom\n        dT_list.append(dT)\n\n    # Round to six decimal places\n    dT_list_rounded = [float(f\"{dT:.6f}\") if not np.isnan(dT) else float(\"nan\") for dT in dT_list]\n    I_list_rounded = [float(f\"{I:.6f}\") for I in I_list]\n\n    return dT_list_rounded + I_list_rounded\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.002, 0.003, 1.0, 1.2, 0.8, 180.0, 298.15),  # Test case 1\n        (0.002, 0.0,   1.0, 1.2, 0.8, 180.0, 298.15),  # Test case 2\n        (0.002, 0.003, 1.0, 1.0, 1.0, 180.0, 298.15),  # Test case 3\n        (0.002, 0.003, 0.6, 1.8, 1.2, 150.0, 298.15),  # Test case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # We print a single line: list of lists, comma-separated, enclosed in square brackets.\n    def format_list(lst):\n        # Ensure fixed formatting of floats with up to six decimals\n        return \"[\" + \",\".join(f\"{x:.6f}\" if isinstance(x, float) and not np.isnan(x) else \"nan\" for x in lst) + \"]\"\n\n    formatted = \"[\" + \",\".join(format_list(res) for res in results) + \"]\"\n    print(formatted)\n\nsolve()\n```"
        },
        {
            "introduction": "Effective battery design requires not only analyzing problems but engineering robust solutions. This advanced practice  shifts the focus from analysis to control, challenging you to design an active balancing strategy under uncertainty. You will formulate a robust optimization problem to determine the ideal balancing currents that minimize the worst-case current deviation, accounting for the fact that cell resistances are not known precisely but vary within a given range.",
            "id": "3902721",
            "problem": "Consider a battery module consisting of $n$ parallel branches, each modeled as a Thevenin source with known open-circuit voltage $U_i$ in volts (V) and an uncertain series resistance $R_i$ in ohms ($\\Omega$). The module is connected to a voltage-controlled bus at voltage $V_{\\text{bus}}$ in volts (V). Each branch $i$ is equipped with a balancing actuator that can inject or absorb a balancing current $i_{b,i}$ in amperes (A), subject to hardware limits. The objective is to derive, from first principles, a robust optimization formulation that minimizes the worst-case maximum magnitude of the branch bus currents under uncertainty sets for the resistances $R_i$, and then compute the balancing currents $i_{b,i}$ that achieve this objective for a given set of parameters.\n\nStart from the following fundamental base:\n- Ohm’s law: for a branch $i$ with conductance $G_i$ in siemens (S), the current induced by a potential difference is given by $I = G \\cdot \\Delta V$.\n- The relation between resistance and conductance: $G_i = \\dfrac{1}{R_i}$.\n- Kirchhoff’s current law: net injected balancing currents in a closed redistribution network sum to zero.\n\nAdopt the following physically consistent sign convention: the bus current contributed by branch $i$ is $I_i = G_i \\cdot (U_i - V_{\\text{bus}}) - i_{b,i}$, where $i_{b,i}  0$ denotes a bypass balancing current that reduces the branch’s bus contribution. The uncertainty sets are intervals $R_i \\in [R_i^{-}, R_i^{+}]$, equivalently $G_i \\in [G_i^{-}, G_i^{+}]$ with $G_i^{-} = \\dfrac{1}{R_i^{+}}$ and $G_i^{+} = \\dfrac{1}{R_i^{-}}$. The balancing hardware imposes bounds $\\lvert i_{b,i} \\rvert \\leq I_{b,i}^{\\max}$ and conservation imposes $\\sum_{i=1}^{n} i_{b,i} = 0$.\n\nYou must:\n- Formulate a robust optimization problem that minimizes the worst-case maximum branch current magnitude, expressed as $\\min_{i_{b,1},\\dots,i_{b,n}} \\max_{i \\in \\{1,\\dots,n\\}} \\sup_{G_i \\in [G_i^{-}, G_i^{+}]} \\lvert G_i \\cdot (U_i - V_{\\text{bus}}) - i_{b,i} \\rvert$, subject to $\\sum_{i=1}^{n} i_{b,i} = 0$ and $\\lvert i_{b,i} \\rvert \\leq I_{b,i}^{\\max}$ for all $i$.\n- Derive a tractable formulation suitable for computation in a modern programming language.\n\nYour program must implement the derived formulation and compute the balancing currents $i_{b,i}$ and the minimized worst-case bound $t^{\\star}$ (in amperes (A)) for each test case. All computed currents and $t^{\\star}$ must be expressed in amperes (A). Round all outputs to $6$ decimal places.\n\nTest suite:\n- Case $1$ (general case): $n = 3$, $U = [3.71, 3.69, 3.73]$ V, $R^{-} = [0.0025, 0.0028, 0.0030]$ $\\Omega$, $R^{+} = [0.0035, 0.0032, 0.0040]$ $\\Omega$, $V_{\\text{bus}} = 3.70$ V, $I_{b}^{\\max} = [2.0, 2.0, 2.0]$ A.\n- Case $2$ (wide uncertainty with tight actuators): $n = 4$, $U = [3.68, 3.72, 3.70, 3.75]$ V, $R^{-} = [0.0015, 0.0020, 0.0018, 0.0022]$ $\\Omega$, $R^{+} = [0.0050, 0.0040, 0.0045, 0.0042]$ $\\Omega$, $V_{\\text{bus}} = 3.71$ V, $I_{b}^{\\max} = [1.0, 1.0, 1.0, 1.0]$ A.\n- Case $3$ (balanced voltages): $n = 3$, $U = [3.70, 3.70, 3.70]$ V, $R^{-} = [0.0020, 0.0020, 0.0020]$ $\\Omega$, $R^{+} = [0.0030, 0.0030, 0.0030]$ $\\Omega$, $V_{\\text{bus}} = 3.70$ V, $I_{b}^{\\max} = [5.0, 5.0, 5.0]$ A.\n- Case $4$ (no balancing capability): $n = 2$, $U = [3.74, 3.66]$ V, $R^{-} = [0.0025, 0.0025]$ $\\Omega$, $R^{+} = [0.0035, 0.0035]$ $\\Omega$, $V_{\\text{bus}} = 3.70$ V, $I_{b}^{\\max} = [0.0, 0.0]$ A.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes one sublist formatted as $[t^{\\star}, i_{b,1}^{\\star}, i_{b,2}^{\\star}, \\dots, i_{b,n}^{\\star}]$ with all values rounded to $6$ decimal places. For example, $[[t^{\\star}_{(1)}, i_{b,1}^{\\star}, \\dots], [t^{\\star}_{(2)}, \\dots], \\dots]$.",
            "solution": "The user-provided problem is first validated against the specified criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **System Model**: A battery module with $n$ parallel branches.\n- **Branch Model**: Each branch $i$ is a Thevenin source with open-circuit voltage $U_i$ and series resistance $R_i$.\n- **Connection**: The module is connected to a bus at voltage $V_{\\text{bus}}$.\n- **Balancing**: Each branch has a balancing actuator injecting current $i_{b,i}$.\n- **Bus Current Equation**: The current from branch $i$ to the bus is $I_i = G_i \\cdot (U_i - V_{\\text{bus}}) - i_{b,i}$, where $G_i = 1/R_i$.\n- **Sign Convention**: $i_{b,i}  0$ is a bypass current reducing the branch's bus contribution.\n- **Uncertainty**: Resistances are uncertain, $R_i \\in [R_i^{-}, R_i^{+}]$. This implies conductance uncertainty $G_i \\in [G_i^{-}, G_i^{+}]$, where $G_i^{-} = 1/R_i^{+}$ and $G_i^{+} = 1/R_i^{-}$.\n- **Constraints**:\n    1.  Balancing current conservation: $\\sum_{i=1}^{n} i_{b,i} = 0$.\n    2.  Balancing current limits: $\\lvert i_{b,i} \\rvert \\leq I_{b,i}^{\\max}$ for all $i$.\n- **Objective**: Formulate and solve the robust optimization problem:\n    $\\min_{i_{b,1},\\dots,i_{b,n}} \\max_{i \\in \\{1,\\dots,n\\}} \\sup_{G_i \\in [G_i^{-}, G_i^{+}]} \\lvert G_i \\cdot (U_i - V_{\\text{bus}}) - i_{b,i} \\rvert$.\n- **Test Data**: Four test cases are provided with numerical values for $n, U_i, R_i^{-}, R_i^{+}, V_{\\text{bus}},$ and $I_{b,i}^{\\max}$.\n\n**Step 2: Validate Using Extracted Givens**\n\n- **Scientifically Grounded**: The problem is based on fundamental electrical engineering principles, namely Thevenin's theorem, Ohm's law, and Kirchhoff's current law. The model of a battery branch as a voltage source with series resistance is a standard and widely accepted simplification. The concept of robust optimization to handle parameter uncertainty is a well-established field in engineering and applied mathematics. The problem is scientifically sound.\n- **Well-Posed**: The problem asks to formulate and solve a specific optimization problem. As will be shown in the derivation, this robust optimization problem can be converted into a standard Linear Program (LP), which is known to be well-posed and for which efficient solvers exist. The provided test data is complete and sufficient to instantiate and solve the problem for each case.\n- **Objective**: The problem is stated using precise mathematical notation and formal definitions. All terms are clearly defined, and there is no subjective or ambiguous language.\n\n**Step 3: Verdict and Action**\nThe problem is scientifically grounded, well-posed, objective, self-contained, and consistent. It does not violate any of the invalidity criteria. Therefore, the problem is **valid**. The solution process will now proceed.\n\n### Derivation of the Tractable Formulation\n\nThe objective is to solve the following robust optimization problem:\n$$\n\\min_{\\mathbf{i_b}} \\max_{i=1, \\dots, n} \\left( \\sup_{G_i \\in [G_i^-, G_i^+]} |G_i(U_i - V_{\\text{bus}}) - i_{b,i}| \\right)\n$$\nsubject to the constraints:\n$$\n\\sum_{i=1}^n i_{b,i} = 0\n$$\n$$\n|i_{b,i}| \\le I_{b,i}^{\\max} \\quad \\text{for } i=1, \\dots, n\n$$\nwhere $\\mathbf{i_b} = [i_{b,1}, \\dots, i_{b,n}]^T$.\n\nLet's first analyze the inner supremum term for a fixed branch $i$ and a fixed balancing current $i_{b,i}$:\n$$\n\\sup_{G_i \\in [G_i^-, G_i^+]} |G_i(U_i - V_{\\text{bus}}) - i_{b,i}|\n$$\nLet's define the voltage potential difference for branch $i$ as $v_i = U_i - V_{\\text{bus}}$. The expression becomes $\\sup_{G_i \\in [G_i^-, G_i^+]} |G_i v_i - i_{b,i}|$. The function inside the absolute value, $f(G_i) = G_i v_i - i_{b,i}$, is a linear function of $G_i$. The supremum of the absolute value of a linear function over a closed interval $[G_i^-, G_i^+]$ must occur at one of the endpoints of the interval.\nTherefore, the supremum is equivalent to the maximum of the values at the endpoints:\n$$\n\\sup_{G_i \\in [G_i^-, G_i^+]} |G_i v_i - i_{b,i}| = \\max \\left( |G_i^- v_i - i_{b,i}|, |G_i^+ v_i - i_{b,i}| \\right)\n$$\nLet's define the uncompensated currents at the conductance interval endpoints as $I_i^- = G_i^- v_i$ and $I_i^+ = G_i^+ v_i$. The worst-case absolute current for branch $i$ is then $\\max(|I_i^- - i_{b,i}|, |I_i^+ - i_{b,i}|)$.\n\nThe original problem can now be rewritten as:\n$$\n\\min_{\\mathbf{i_b}} \\max_{i=1, \\dots, n} \\max(|I_i^- - i_{b,i}|, |I_i^+ - i_{b,i}|)\n$$\nThis is a standard \"minimax\" problem structure. We can introduce an auxiliary scalar variable $t$ which will represent the worst-case current magnitude across all branches. The problem can be equivalently formulated as:\n$$\n\\min_{t, \\mathbf{i_b}} t\n$$\nsubject to:\n$$\n\\max_{i=1, \\dots, n} \\max(|I_i^- - i_{b,i}|, |I_i^+ - i_{b,i}|) \\le t\n$$\nand the original constraints on $\\mathbf{i_b}$.\n\nThe main inequality constraint can be decomposed into a set of simpler inequalities. The condition holds if and only if for every branch $i \\in \\{1, \\dots, n\\}$:\n$$\n\\max(|I_i^- - i_{b,i}|, |I_i^+ - i_{b,i}|) \\le t\n$$\nThis is equivalent to the pair of inequalities:\n$$\n|I_i^- - i_{b,i}| \\le t \\quad \\text{and} \\quad |I_i^+ - i_{b,i}| \\le t\n$$\nEach absolute value inequality $|x| \\le t$ is equivalent to $-t \\le x \\le t$. Applying this, we get for each branch $i$:\n1.  $-t \\le I_i^- - i_{b,i} \\le t$\n2.  $-t \\le I_i^+ - i_{b,i} \\le t$\n\nThese can be rearranged to isolate the optimization variables:\n1.  $i_{b,i} - t \\le I_i^-$ and $i_{b,i} + t \\ge I_i^-$\n2.  $i_{b,i} - t \\le I_i^+$ and $i_{b,i} + t \\ge I_i^+$\n\nCombining these, we get:\n$$\ni_{b,i} - t \\le \\min(I_i^-, I_i^+)\n$$\n$$\ni_{b,i} + t \\ge \\max(I_i^-, I_i^+)\n$$\n\nThis has transformed the original robust problem into a standard Linear Program (LP). The complete LP formulation is:\n$$\n\\min_{t, i_{b,1}, \\dots, i_{b,n}} t\n$$\nsubject to, for all $i \\in \\{1, \\dots, n\\}$:\n$$\n-t + i_{b,i} \\le \\min(I_i^-, I_i^+)\n$$\n$$\n-t - i_{b,i} \\le -\\max(I_i^-, I_i^+)\n$$\n$$\n\\sum_{i=1}^n i_{b,i} = 0\n$$\n$$\n-I_{b,i}^{\\max} \\le i_{b,i} \\le I_{b,i}^{\\max}\n$$\n$$\nt \\ge 0\n$$\n\nThis LP can be solved using standard numerical solvers. The optimization variables are $x = [t, i_{b,1}, \\dots, i_{b,n}]^T$. The objective function is $c^T x$ with $c=[1, 0, \\dots, 0]^T$. The constraints are expressed in matrix form as $A_{ub}x \\le b_{ub}$, $A_{eq}x = b_{eq}$, and bounds on the variables. The implementation will construct these matrices and vectors and pass them to a solver. The optimal value $t^{\\star}$ will be the minimized worst-case current bound, and $i_{b,1}^{\\star}, \\dots, i_{b,n}^{\\star}$ will be the optimal balancing currents.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the robust battery balancing problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {'n': 3, 'U': [3.71, 3.69, 3.73], 'R_minus': [0.0025, 0.0028, 0.0030], 'R_plus': [0.0035, 0.0032, 0.0040], 'V_bus': 3.70, 'Ib_max': [2.0, 2.0, 2.0]},\n        {'n': 4, 'U': [3.68, 3.72, 3.70, 3.75], 'R_minus': [0.0015, 0.0020, 0.0018, 0.0022], 'R_plus': [0.0050, 0.0040, 0.0045, 0.0042], 'V_bus': 3.71, 'Ib_max': [1.0, 1.0, 1.0, 1.0]},\n        {'n': 3, 'U': [3.70, 3.70, 3.70], 'R_minus': [0.0020, 0.0020, 0.0020], 'R_plus': [0.0030, 0.0030, 0.0030], 'V_bus': 3.70, 'Ib_max': [5.0, 5.0, 5.0]},\n        {'n': 2, 'U': [3.74, 3.66], 'R_minus': [0.0025, 0.0025], 'R_plus': [0.0035, 0.0035], 'V_bus': 3.70, 'Ib_max': [0.0, 0.0]}\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        n = case['n']\n        U = np.array(case['U'])\n        R_minus = np.array(case['R_minus'])\n        R_plus = np.array(case['R_plus'])\n        V_bus = case['V_bus']\n        Ib_max = np.array(case['Ib_max'])\n\n        # Calculate derived parameters based on the problem statement\n        G_minus = 1.0 / R_plus\n        G_plus = 1.0 / R_minus\n        \n        v = U - V_bus\n        \n        I_minus = G_minus * v\n        I_plus = G_plus * v\n        \n        I_min_vals = np.minimum(I_minus, I_plus)\n        I_max_vals = np.maximum(I_minus, I_plus)\n        \n        # Formulate the Linear Program (LP)\n        # Optimization variables: x = [t, i_b,1, ..., i_b,n]\n        num_vars = n + 1\n        \n        # Objective function: minimize t\n        c = np.zeros(num_vars)\n        c[0] = 1.0\n        \n        # Inequality constraints: A_ub * x = b_ub\n        # For each branch i:\n        # -t + i_b,i = min(I_i^-, I_i^+)\n        # -t - i_b,i = -max(I_i^-, I_i^+)\n        A_ub = np.zeros((2 * n, num_vars))\n        b_ub = np.zeros(2 * n)\n        \n        for i in range(n):\n            # Constraint: -t + i_b,i = I_min_i\n            A_ub[i, 0] = -1.0\n            A_ub[i, i + 1] = 1.0\n            b_ub[i] = I_min_vals[i]\n            \n            # Constraint: -t - i_b,i = -I_max_i\n            A_ub[n + i, 0] = -1.0\n            A_ub[n + i, i + 1] = -1.0\n            b_ub[n + i] = -I_max_vals[i]\n\n        # Equality constraint: A_eq * x == b_eq\n        # sum(i_b,i) = 0\n        A_eq = np.zeros((1, num_vars))\n        A_eq[0, 1:] = 1.0\n        b_eq = np.array([0.0])\n\n        # Bounds for variables\n        # t >= 0\n        # -I_b,i^max = i_b,i = I_b,i^max\n        bounds = [(0, None)] + [(-Ib_max[i], Ib_max[i]) for i in range(n)]\n\n        # Solve the LP using the 'highs' solver\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        if res.success:\n            t_star = res.x[0]\n            ib_star = res.x[1:]\n            \n            case_result = [t_star] + list(ib_star)\n            all_results.append(case_result)\n        else:\n            # This path should not be taken for the given well-posed problems.\n            # Including for robustness, though output format won't match.\n            all_results.append([float('nan')] * (n + 1))\n\n    # Format the final output string exactly as specified.\n    formatted_results = []\n    for r in all_results:\n        # Use f-string formatting to ensure 6 decimal places, including trailing zeros.\n        formatted_r = [f\"{val:.6f}\" for val in r]\n        formatted_results.append(f\"[{','.join(formatted_r)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}