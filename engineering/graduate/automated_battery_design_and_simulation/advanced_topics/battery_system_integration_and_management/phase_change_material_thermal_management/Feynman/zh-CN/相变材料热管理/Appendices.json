{
    "hands_on_practices": [
        {
            "introduction": "精确的仿真实践始于可靠的材料属性模型。本练习将引导您将差示扫描量热法 (DSC) 的实验测量结果——例如相变起始、峰值和结束温度——转化为一个平滑、连续的有效热容函数 $c_p^{\\text{eff}}(T)$。掌握这项技能对于为数值求解器准备高质量的输入至关重要，它构成了从物理测试到虚拟设计的第一步。",
            "id": "3939109",
            "problem": "一名开发人员正在为一个用于自动化电池设计与仿真的相变材料 (PCM) 热管理数值模块进行开发。其目标是利用差示扫描量热法 (DSC) 数据，构建一个平滑的有效热容函数，并量化热滞后现象。\n\n假设存在以下源于热力学和量热学的基础建模框架：\n- 在受控扫描下，PCM 的总比焓 $H(T)$ 是比热容对温度的路径积分，而在恒定扫描速率 $\\beta = dT/dt$ 下，DSC 热流 $\\dot{Q}$ 可得到 $dH/dT = \\dot{Q}/\\beta$，此即有效热容 $c_p^{\\text{eff}}(T)$。\n- 将 $c_p^{\\text{eff}}(T)$ 分解为显热部分和潜热部分，即 $c_p^{\\text{eff}}(T) = c_p + L \\, g(T)$，其中 $c_p$ 是基线显热比热容，$L$ 是单位质量的熔化潜热，$g(T)$ 是一个关于温度的单峰概率密度函数 (PDF)，其积分为 $1$，用于模拟熔化过程中潜热吸收随温度变化的分布。相关的液相分数是 $\\phi(T) = \\int_{-\\infty}^{T} g(\\theta)\\, d\\theta$，潜焓贡献为 $L \\, \\phi(T)$。\n- 对于凝固过程（降温扫描），滞后现象通过一个经过平移并可能重塑的潜热分布 $g_{\\downarrow}(T)$ 来捕捉，其参数与升温过程的参数不同。\n\n您必须：\n1. 使用升温 DSC 数据（起始温度、峰值温度、完成温度、积分潜热 $L$），通过选择一个以峰值温度为锚点且与作为分位数处理的起始和完成温度一致的单峰函数 $g(T)$，来拟合一个平滑的 $dH/dT = c_p^{\\text{eff}}(T)$。约束 $g(T)$ 使其满足 $\\int_{-\\infty}^{\\infty} g(T)\\, dT = 1$，从而保证在相变过程中的积分潜焓等于 $L$。对于起始温度和完成温度，将其分别视为对应于累积概率 $p_{\\text{low}} = 0.1$ 和 $p_{\\text{high}} = 0.9$ 的分位数。\n2. 对于凝固（降温） DSC 数据，使用相同的建模方法拟合一个类似的平滑函数 $c_{p,\\downarrow}^{\\text{eff}}(T)$，但允许拟合参数不同。通过计算以下量来量化滞后现象：\n   - 中点偏移 $\\Delta T_{\\text{mid}}$，定义为升温和降温过程中液相分数 $\\phi(T)$ 等于 $0.5$ 时的温度之差。\n   - 宽度比 $r_{\\sigma}$，定义为降温过程中的分布宽度与升温过程中的分布宽度的比率。\n   - 回路面积 $A_{\\text{loop}}$，定义为 $A_{\\text{loop}} = L \\int_{-\\infty}^{\\infty} \\left|\\phi_{\\uparrow}(T) - \\phi_{\\downarrow}(T)\\right|\\, dT$，它衡量了温-焓平面上的滞后现象。在一个足够宽以捕捉两个分布支撑集的有限域上对该积分进行数值计算。\n\n所有温度必须以开尔文（K）为单位表示，所有比热容以 $\\text{kJ}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$ 为单位，所有潜热以 $\\text{kJ}\\,\\text{kg}^{-1}$ 为单位。回路面积 $A_{\\text{loop}}$ 必须以 $\\text{kJ}\\,\\text{kg}^{-1}\\,\\text{K}$ 为单位表示。\n\n测试套件：\n为三个独立的测试用例提供计算。每个测试用例包含升温 DSC 数据 $(T_{\\text{onset},\\uparrow}, T_{\\text{peak},\\uparrow}, T_{\\text{comp},\\uparrow}, L, c_p)$ 和降温 DSC 数据 $(T_{\\text{onset},\\downarrow}, T_{\\text{peak},\\downarrow}, T_{\\text{comp},\\downarrow})$，具体数值如下：\n- 用例 1（一般情况）：\n  - 升温：$T_{\\text{onset},\\uparrow} = 313.15\\ \\text{K}$，$T_{\\text{peak},\\uparrow} = 317.15\\ \\text{K}$，$T_{\\text{comp},\\uparrow} = 320.15\\ \\text{K}$，$L = 220\\ \\text{kJ}\\,\\text{kg}^{-1}$，$c_p = 2.0\\ \\text{kJ}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$。\n  - 降温：$T_{\\text{onset},\\downarrow} = 311.15\\ \\text{K}$，$T_{\\text{peak},\\downarrow} = 315.15\\ \\text{K}$，$T_{\\text{comp},\\downarrow} = 318.15\\ \\text{K}$。\n- 用例 2（窄相变）：\n  - 升温：$T_{\\text{onset},\\uparrow} = 319.15\\ \\text{K}$，$T_{\\text{peak},\\uparrow} = 320.15\\ \\text{K}$，$T_{\\text{comp},\\uparrow} = 321.15\\ \\text{K}$，$L = 180\\ \\text{kJ}\\,\\text{kg}^{-1}$，$c_p = 2.2\\ \\text{kJ}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$。\n  - 降温：$T_{\\text{onset},\\downarrow} = 318.65\\ \\text{K}$，$T_{\\text{peak},\\downarrow} = 319.65\\ \\text{K}$，$T_{\\text{comp},\\downarrow} = 320.65\\ \\text{K}$。\n- 用例 3（宽相变）：\n  - 升温：$T_{\\text{onset},\\uparrow} = 300.15\\ \\text{K}$，$T_{\\text{peak},\\uparrow} = 310.15\\ \\text{K}$，$T_{\\text{comp},\\uparrow} = 330.15\\ \\text{K}$，$L = 50\\ \\text{kJ}\\,\\text{kg}^{-1}$，$c_p = 1.8\\ \\text{kJ}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$。\n  - 降温：$T_{\\text{onset},\\downarrow} = 295.15\\ \\text{K}$，$T_{\\text{peak},\\downarrow} = 305.15\\ \\text{K}$，$T_{\\text{comp},\\downarrow} = 325.15\\ \\text{K}$。\n\n对于每个测试用例，生成一个结果列表，包含以下六个量：\n- 升温过程的拟合峰值温度 $\\mu_{\\uparrow}$，单位为 K。\n- 升温过程的拟合宽度 $\\sigma_{\\uparrow}$，单位为 K。\n- 峰值有效热容 $c_{p,\\uparrow}^{\\text{eff}}(\\mu_{\\uparrow})$，单位为 $\\text{kJ}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$。\n- 中点偏移 $\\Delta T_{\\text{mid}} = \\mu_{\\uparrow} - \\mu_{\\downarrow}$，单位为 K。\n- 宽度比 $r_{\\sigma} = \\sigma_{\\downarrow}/\\sigma_{\\uparrow}$（无量纲）。\n- 滞后回路面积 $A_{\\text{loop}}$，单位为 $\\text{kJ}\\,\\text{kg}^{-1}\\,\\text{K}$。\n\n您的程序应生成单行输出，包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表，其中每个测试用例的结果本身是一个无空格的、由方括号括起来的逗号分隔列表（例如，$[[x_1,y_1],[x_2,y_2]]$）。具体来说，格式必须是 $[[r_{11},r_{12},r_{13},r_{14},r_{15},r_{16}],[r_{21},r_{22},r_{23},r_{24},r_{25},r_{26}],[r_{31},r_{32},r_{33},r_{34},r_{35},r_{36}]]$。",
            "solution": "用户希望我解决一个问题。\n\n**第一步：提取已知条件**\n\n- **有效比热容模型, $c_p^{\\text{eff}}(T)$**: $c_p^{\\text{eff}}(T) = c_p + L \\, g(T)$。\n- **$c_p$**: 基线显热比热容。\n- **$L$**: 单位质量熔化潜热。\n- **$g(T)$**: 在 $(-\\infty, \\infty)$ 上积分为1的单峰概率密度函数 (PDF)。\n- **液相分数, $\\phi(T)$**: $\\phi(T) = \\int_{-\\infty}^{T} g(\\theta)\\, d\\theta$。\n- **潜焓贡献**: $L \\, \\phi(T)$。\n- **滞后模型**: 凝固过程（降温扫描）由一个不同的分布 $g_{\\downarrow}(T)$ 建模。\n- **$g(T)$ 的拟合约束**:\n    - 以峰值温度为锚点。\n    - 起始和完成温度被视为分别对应于累积概率 $p_{\\text{low}} = 0.1$ 和 $p_{\\text{high}} = 0.9$ 的分位数。\n- **滞后度量定义**:\n    - 中点偏移: $\\Delta T_{\\text{mid}} = T_{0.5, \\uparrow} - T_{0.5, \\downarrow}$，其中 $\\phi(T_{0.5}) = 0.5$。\n    - 宽度比: $r_{\\sigma} = \\sigma_{\\downarrow}/\\sigma_{\\uparrow}$，其中 $\\sigma$ 是分布的宽度参数。\n    - 回路面积: $A_{\\text{loop}} = L \\int_{-\\infty}^{\\infty} |\\phi_{\\uparrow}(T) - \\phi_{\\downarrow}(T)| \\, dT$。\n- **单位**: 温度单位为开尔文 ($\\text{K}$)，比热容单位为 $\\text{kJ}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$，潜热单位为 $\\text{kJ}\\,\\text{kg}^{-1}$，回路面积单位为 $\\text{kJ}\\,\\text{kg}^{-1}\\,\\text{K}$。\n- **测试用例 1**:\n    - 升温: $T_{\\text{onset},\\uparrow} = 313.15\\ \\text{K}$，$T_{\\text{peak},\\uparrow} = 317.15\\ \\text{K}$，$T_{\\text{comp},\\uparrow} = 320.15\\ \\text{K}$，$L = 220\\ \\text{kJ}\\,\\text{kg}^{-1}$，$c_p = 2.0\\ \\text{kJ}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$。\n    - 降温: $T_{\\text{onset},\\downarrow} = 311.15\\ \\text{K}$，$T_{\\text{peak},\\downarrow} = 315.15\\ \\text{K}$，$T_{\\text{comp},\\downarrow} = 318.15\\ \\text{K}$。\n- **测试用例 2**:\n    - 升温: $T_{\\text{onset},\\uparrow} = 319.15\\ \\text{K}$，$T_{\\text{peak},\\uparrow} = 320.15\\ \\text{K}$，$T_{\\text{comp},\\uparrow} = 321.15\\ \\text{K}$，$L = 180\\ \\text{kJ}\\,\\text{kg}^{-1}$，$c_p = 2.2\\ \\text{kJ}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$。\n    - 降温: $T_{\\text{onset},\\downarrow} = 318.65\\ \\text{K}$，$T_{\\text{peak},\\downarrow} = 319.65\\ \\text{K}$，$T_{\\text{comp},\\downarrow} = 320.65\\ \\text{K}$。\n- **测试用例 3**:\n    - 升温: $T_{\\text{onset},\\uparrow} = 300.15\\ \\text{K}$，$T_{\\text{peak},\\uparrow} = 310.15\\ \\text{K}$，$T_{\\text{comp},\\uparrow} = 330.15\\ \\text{K}$，$L = 50\\ \\text{kJ}\\,\\text{kg}^{-1}$，$c_p = 1.8\\ \\text{kJ}\\,\\text{kg}^{-1}\\,\\text{K}^{-1}$。\n    - 降温: $T_{\\text{onset},\\downarrow} = 295.15\\ \\text{K}$，$T_{\\text{peak},\\downarrow} = 305.15\\ \\text{K}$，$T_{\\text{comp},\\downarrow} = 325.15\\ \\text{K}$。\n- **要求输出的量**: $\\mu_{\\uparrow}$，$\\sigma_{\\uparrow}$，$c_{p,\\uparrow}^{\\text{eff}}(\\mu_{\\uparrow})$，$\\Delta T_{\\text{mid}}$，$r_{\\sigma}$，$A_{\\text{loop}}$。\n\n**第二步：使用提取的已知条件进行验证**\n\n问题根据验证标准进行评估。\n- **科学依据**: 该问题基于量热学和相变热力学的既定原理。将有效热容分解为显热和潜热部分，并用分布函数对潜热释放/吸收进行建模，是材料科学和热工程中一种标准且物理上合理的方法。\n- **适定性**: 该问题提供了所有必要的数据，并定义了所需的计算和输出量。必须选择一个特定的单峰PDF；正态（高斯）分布是符合标准的标准且合适的选择。描述了参数拟合的方法，虽然对于对称PDF使用非对称的起始/完成数据存在一个小的模糊之处，但一个稳健的解释是可行的，并能导出一个唯一的解。\n- **客观性**: 该问题用精确的数学定义和客观的数值数据来表述。它需要定量分析，而非主观判断。\n- **其他检查**: 该问题在科学上是合理的、可形式化的、完整的、无矛盾的、符合现实的、适定的、非琐碎的，且在科学可验证的范围内。单位是一致的。\n\n**第三步：结论与行动**\n\n问题是**有效的**。将提供一个合理的解决方案。\n\n该问题要求拟合一个平滑的单峰概率密度函数 $g(T)$ 来表征潜热对有效热容 $c_p^{\\text{eff}}(T)$ 的贡献。正态（高斯）分布因其单峰性和数学易处理性，是 $g(T)$ 的一个合适选择。\n\n正态分布由两个参数定义：代表分布中心的均值 $\\mu$，和代表其宽度的标准差 $\\sigma$。其PDF由下式给出：\n$$ g(T; \\mu, \\sigma) = \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\left(-\\frac{(T-\\mu)^2}{2\\sigma^2}\\right) $$\n相应的累积分布函数（CDF），代表液相分数 $\\phi(T)$，是：\n$$ \\phi(T; \\mu, \\sigma) = \\int_{-\\infty}^{T} g(\\theta; \\mu, \\sigma) \\, d\\theta = \\Phi\\left(\\frac{T-\\mu}{\\sigma}\\right) $$\n其中 $\\Phi(z)$ 是标准正态分布 ($N(0,1)$) 的CDF。\n\n**参数拟合**\n\n我们将使用提供的 DSC 数据为升温（$\\uparrow$）和降温（$\\downarrow$）过程拟合参数 $\\mu$ 和 $\\sigma$。\n1.  **均值 ($\\mu$)**: 问题陈述 $g(T)$ 分布应“以峰值温度为锚点”。这直接意味着我们的正态分布的均值 $\\mu$ 应设置为给定的峰值温度 $T_{\\text{peak}}$。\n    $$ \\mu_{\\uparrow} = T_{\\text{peak},\\uparrow} \\quad \\text{和} \\quad \\mu_{\\downarrow} = T_{\\text{peak},\\downarrow} $$\n\n2.  **标准差 ($\\sigma$)**: 问题指明起始和完成温度对应于累积概率 $p_{\\text{low}} = 0.1$ 和 $p_{\\text{high}} = 0.9$ 的分位数。令 $z_p$ 为标准正态分布的第 $p$ 个分位数，即 $\\Phi(z_p) = p$。\n    关系如下：\n    $$ \\phi(T_{\\text{onset}}) = \\Phi\\left(\\frac{T_{\\text{onset}}-\\mu}{\\sigma}\\right) = 0.1 \\implies \\frac{T_{\\text{onset}}-\\mu}{\\sigma} = z_{0.1} $$\n    $$ \\phi(T_{\\text{comp}}) = \\Phi\\left(\\frac{T_{\\text{comp}}-\\mu}{\\sigma}\\right) = 0.9 \\implies \\frac{T_{\\text{comp}}-\\mu}{\\sigma} = z_{0.9} $$\n    将第二个方程减去第一个方程，我们可以解出 $\\sigma$：\n    $$ \\frac{T_{\\text{comp}} - T_{\\text{onset}}}{\\sigma} = z_{0.9} - z_{0.1} $$\n    由于正态分布的对称性，$z_{0.1} = -z_{0.9}$。因此，$z_{0.9} - z_{0.1} = 2z_{0.9}$。\n    $$ \\sigma = \\frac{T_{\\text{comp}} - T_{\\text{onset}}}{2 z_{0.9}} $$\n    该方法稳健地使用定义的相变宽度（10%至90%）来确定分布的展宽。$z_{0.9}$ 的值是一个常数，$z_{0.9} = \\Phi^{-1}(0.9) \\approx 1.28155$。我们将使用此公式，利用各自的起始和完成温度来找到 $\\sigma_{\\uparrow}$ 和 $\\sigma_{\\downarrow}$。\n\n**所需量的计算**\n\n对于每个测试用例，我们计算以下六个量：\n1.  **升温过程的拟合峰值温度, $\\mu_{\\uparrow}$**: 如前所述，$\\mu_{\\uparrow} = T_{\\text{peak},\\uparrow}$。\n2.  **升温过程的拟合宽度, $\\sigma_{\\uparrow}$**: 计算公式为 $\\sigma_{\\uparrow} = (T_{\\text{comp},\\uparrow} - T_{\\text{onset},\\uparrow}) / (2 z_{0.9})$。\n3.  **峰值有效热容, $c_{p,\\uparrow}^{\\text{eff}}(\\mu_{\\uparrow})$**: 有效热容为 $c_p^{\\text{eff}}(T) = c_p + L \\, g(T)$。在其峰值处（$T=\\mu_{\\uparrow}$），正态PDF的值最大：$g(\\mu_{\\uparrow}) = 1/(\\sigma_{\\uparrow}\\sqrt{2\\pi})$。\n    $$ c_{p,\\uparrow}^{\\text{eff}}(\\mu_{\\uparrow}) = c_p + \\frac{L}{\\sigma_{\\uparrow}\\sqrt{2\\pi}} $$\n4.  **中点偏移, $\\Delta T_{\\text{mid}}$**: 这是液相分数为0.5时温度的差值。对于正态分布，$\\phi(T) = 0.5$ 精确地出现在均值处，即 $T = \\mu$。\n    $$ \\Delta T_{\\text{mid}} = \\mu_{\\uparrow} - \\mu_{\\downarrow} $$\n5.  **宽度比, $r_{\\sigma}$**: 这是降温和升温过程拟合标准差的比率。\n    $$ r_{\\sigma} = \\frac{\\sigma_{\\downarrow}}{\\sigma_{\\uparrow}} $$\n6.  **滞后回路面积, $A_{\\text{loop}}$**: 定义为 $A_{\\text{loop}} = L \\int_{-\\infty}^{\\infty} |\\phi_{\\uparrow}(T) - \\phi_{\\downarrow}(T)| \\, dT$。使用拟合的参数，被积函数为 $|\\Phi(\\frac{T-\\mu_{\\uparrow}}{\\sigma_{\\uparrow}}) - \\Phi(\\frac{T-\\mu_{\\downarrow}}{\\sigma_{\\downarrow}})|$。该积分没有通用的闭合形式解，必须进行数值计算。我们在足够宽的温度范围（例如，$\\mu \\pm 10\\sigma$）上使用数值积分来精确捕捉积分值。如规定，潜热 $L$ 取自升温数据。\n\n将此程序应用于每个测试用例以生成所需的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Each case: ((T_onset_up, T_peak_up, T_comp_up, L, c_p), \n    #             (T_onset_down, T_peak_down, T_comp_down))\n    test_cases = [\n        # Case 1 (general case)\n        ((313.15, 317.15, 320.15, 220.0, 2.0),\n         (311.15, 315.15, 318.15)),\n        # Case 2 (narrow transition)\n        ((319.15, 320.15, 321.15, 180.0, 2.2),\n         (318.65, 319.65, 320.65)),\n        # Case 3 (wide transition)\n        ((300.15, 310.15, 330.15, 50.0, 1.8),\n         (295.15, 305.15, 325.15)),\n    ]\n\n    # Pre-calculate the standard normal quantile for p=0.9\n    z_90 = norm.ppf(0.9)\n\n    results = []\n    for heating_params, cooling_params in test_cases:\n        case_results = calculate_metrics(heating_params, cooling_params, z_90)\n        results.append(f\"[{','.join(f'{x:.8f}' for x in case_results)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_metrics(heating_params, cooling_params, z_90):\n    \"\"\"\n    Calculates the six required metrics for a single test case.\n    \n    Args:\n        heating_params (tuple): (T_onset, T_peak, T_comp, L, c_p) for heating.\n        cooling_params (tuple): (T_onset, T_peak, T_comp) for cooling.\n        z_90 (float): Standard normal quantile for p=0.9.\n\n    Returns:\n        list: A list of the six computed metrics.\n    \"\"\"\n    T_onset_up, T_peak_up, T_comp_up, L, c_p = heating_params\n    T_onset_down, T_peak_down, T_comp_down = cooling_params\n\n    # 1. Fit heating parameters (mu_up, sigma_up)\n    mu_up = T_peak_up\n    sigma_up = (T_comp_up - T_onset_up) / (2 * z_90)\n\n    # 2. Calculate peak effective heat capacity\n    # g(T) at peak is 1 / (sigma * sqrt(2*pi))\n    g_peak = 1 / (sigma_up * np.sqrt(2 * np.pi))\n    c_p_eff_peak = c_p + L * g_peak\n\n    # 3. Fit cooling parameters (mu_down, sigma_down)\n    mu_down = T_peak_down\n    sigma_down = (T_comp_down - T_onset_down) / (2 * z_90)\n\n    # 4. Calculate hysteresis metrics\n    # Midpoint shift (delta T_mid)\n    delta_T_mid = mu_up - mu_down\n\n    # Width ratio (r_sigma)\n    # Avoid division by zero, though sigma_up should not be zero here.\n    r_sigma = sigma_down / sigma_up if sigma_up != 0 else np.inf\n\n    # Hysteresis loop area (A_loop)\n    # Integrand: |phi_up(T) - phi_down(T)|\n    integrand = lambda T: np.abs(norm.cdf((T - mu_up) / sigma_up) - \n                                 norm.cdf((T - mu_down) / sigma_down))\n\n    # Define integration limits to be sufficiently wide\n    # Using +-10 standard deviations from each mean should be more than enough\n    lower_bound = min(mu_up - 10 * sigma_up, mu_down - 10 * sigma_down)\n    upper_bound = max(mu_up + 10 * sigma_up, mu_down + 10 * sigma_down)\n\n    # Perform numerical integration\n    integral_val, _ = quad(integrand, lower_bound, upper_bound)\n    A_loop = L * integral_val\n\n    # Collect results\n    return [mu_up, sigma_up, c_p_eff_peak, delta_T_mid, r_sigma, A_loop]\n\nsolve()\n```"
        },
        {
            "introduction": "在获得材料的焓-温度 $H(T)$ 关系后，精确模拟其热行为通常需要求解刚性非线性方程，尤其是在采用稳定的隐式时间步进格式时。本练习的核心是实现一个带安全保护机制的牛顿迭代法，以稳健地求解能量平衡方程。这对于开发能够可靠处理相变过程中急剧变化的物理属性的定制化热仿真工具是一项核心能力。",
            "id": "3939148",
            "problem": "您正在设计一个稳健的隐式时间步进器，用于对嵌入相变材料 (PCM) 中的电池模块进行热管理。您将采用集总参数焓法。令 $T$ 表示温度（单位：开尔文），$h(T)$ 表示比焓（单位：焦耳/千克），$H(T) = m \\, h(T)$ 表示质量为 $m$（单位：千克）的总焓（单位：焦耳）。PCM 通过一个平滑的液相分数函数来模拟熔化过程。从 $t^n$ 到 $t^{n+1}$ 的单个后向（隐式）欧拉时间步长的能量平衡基于能量守恒：\n- 总焓变等于净能量输入减去与环境的对流热损失。形式上，\n$$\nH\\!\\left(T^{n+1}\\right) - H\\!\\left(T^{n}\\right) = \\Delta t \\left(P - h_c A \\left(T^{n+1} - T_{\\text{amb}}\\right)\\right),\n$$\n其中 $\\Delta t$ 是时间步长（单位：秒），$P$ 是恒定的体积功率输入（单位：瓦特），$h_c A$ 是集总传热系数乘以表面积（单位：瓦特/开尔文），$T_{\\text{amb}}$ 是环境温度（单位：开尔文）。\n\n给定一个平滑的焓-温关系，形式如下\n$$\nh(T) = c \\left(T - T_{\\text{ref}}\\right) + L \\, f(T),\n$$\n其中 $c$ 是有效比热（单位：焦耳/千克·开尔文），$T_{\\text{ref}}$ 是参考温度（单位：开尔文），$L$ 是潜热（单位：焦耳/千克），$f(T)$ 是平滑熔化分数\n$$\nf(T) = \\tfrac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{T - T_m}{w}\\right)\\right),\n$$\n其中熔化温度为 $T_m$（单位：开尔文），平滑半宽为 $w$（单位：开尔文）。其导数满足\n$$\n\\frac{dh}{dT}(T) = c + L \\, f'(T), \\quad f'(T) = \\tfrac{1}{2}\\,\\frac{1}{w}\\,\\operatorname{sech}^2\\!\\left(\\frac{T - T_m}{w}\\right),\n$$\n其中 $\\operatorname{sech}(x) = 1/\\cosh(x)$。\n\n任务：\n- 实现一个牛顿迭代法，从非线性隐式方程中求解 $T^{n+1}$（单位：开尔文）\n$$\nF(T) \\equiv H(T) + \\Delta t \\, h_c A \\, T - \\left(H\\!\\left(T^n\\right) + \\Delta t \\, P + \\Delta t \\, h_c A \\, T_{\\text{amb}}\\right) = 0,\n$$\n其中 $H(T) = m \\, h(T)$。\n- 您的求解器必须包含收敛准则和保障措施，以在 $\\frac{dH}{dT} = m \\, \\frac{dh}{dT}$ 非常大时（接近相变点）保持稳健性，至少包括：基于残差的停止准则、步长控制、带二分法回退的区间限定以及线搜索阻尼。\n- 您可以自行选择容差，但在您的解题叙述中需用具有物理意义的理由来证明其合理性。在程序中，报告计算出的 $T^{n+1}$（单位：开尔文），并四舍五入到六位小数。\n\n定义以下参数集测试套件。对于每种情况，计算 $T^{n+1}$（单位：开尔文）。\n\n- 情况 1（理想路径，中等平滑）：\n  - $m = 0.5$ $\\mathrm{kg}$，$c = 2000$ $\\mathrm{J/(kg\\cdot K)}$，$L = 200000$ $\\mathrm{J/kg}$，$T_{\\text{ref}} = 300$ $\\mathrm{K}$，$T_m = 330$ $\\mathrm{K}$，$w = 2$ $\\mathrm{K}$，$h_c A = 5$ $\\mathrm{W/K}$，$P = 50$ $\\mathrm{W}$，$\\Delta t = 10$ $\\mathrm{s}$，$T_{\\text{amb}} = 300$ $\\mathrm{K}$，$T^n = 320$ $\\mathrm{K}$。\n\n- 情况 2（非常急剧的转变，具有挑战性的导数）：\n  - $m = 0.5$ $\\mathrm{kg}$，$c = 2000$ $\\mathrm{J/(kg\\cdot K)}$，$L = 200000$ $\\mathrm{J/kg}$，$T_{\\text{ref}} = 300$ $\\mathrm{K}$，$T_m = 330$ $\\mathrm{K}$，$w = 0.2$ $\\mathrm{K}$，$h_c A = 5$ $\\mathrm{W/K}$，$P = 50$ $\\mathrm{W}$，$\\Delta t = 10$ $\\mathrm{s}$，$T_{\\text{amb}} = 300$ $\\mathrm{K}$，$T^n = 320$ $\\mathrm{K}$。\n\n- 情况 3（无潜热，线性检验）：\n  - $m = 1.0$ $\\mathrm{kg}$，$c = 1000$ $\\mathrm{J/(kg\\cdot K)}$，$L = 0$ $\\mathrm{J/kg}$，$T_{\\text{ref}} = 300$ $\\mathrm{K}$，$T_m = 330$ $\\mathrm{K}$，$w = 1.0$ $\\mathrm{K}$，$h_c A = 2$ $\\mathrm{W/K}$，$P = 100$ $\\mathrm{W}$，$\\Delta t = 5$ $\\mathrm{s}$，$T_{\\text{amb}} = 300$ $\\mathrm{K}$，$T^n = 305$ $\\mathrm{K}$。\n\n- 情况 4（跨越 $T_m$ 的冷却伴随凝固）：\n  - $m = 0.3$ $\\mathrm{kg}$，$c = 1800$ $\\mathrm{J/(kg\\cdot K)}$，$L = 150000$ $\\mathrm{J/kg}$，$T_{\\text{ref}} = 300$ $\\mathrm{K}$，$T_m = 330$ $\\mathrm{K}$，$w = 1$ $\\mathrm{K}$，$h_c A = 10$ $\\mathrm{W/K}$，$P = -20$ $\\mathrm{W}$，$\\Delta t = 30$ $\\mathrm{s}$，$T_{\\text{amb}} = 300$ $\\mathrm{K}$，$T^n = 335$ $\\mathrm{K}$。\n\n- 情况 5（在相变点附近具有大 $\\Delta t$ 和 $h_c A$ 的刚性步长）：\n  - $m = 0.8$ $\\mathrm{kg}$，$c = 2200$ $\\mathrm{J/(kg\\cdot K)}$，$L = 250000$ $\\mathrm{J/kg}$，$T_{\\text{ref}} = 298$ $\\mathrm{K}$，$T_m = 335$ $\\mathrm{K}$，$w = 0.5$ $\\mathrm{K}$，$h_c A = 50$ $\\mathrm{W/K}$，$P = 200$ $\\mathrm{W}$，$\\Delta t = 120$ $\\mathrm{s}$，$T_{\\text{amb}} = 300$ $\\mathrm{K}$，$T^n = 334$ $\\mathrm{K}$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表，按上述情况的顺序排列，每个 $T^{n+1}$ 四舍五入到六位小数（单位：开尔文）。例如，格式应类似于 [$r_1$,$r_2$,$r_3$,$r_4$,$r_5$]，其中每个 $r_i$ 是一个以开尔文为单位的浮点数。",
            "solution": "我们从一个集总节点的后向（隐式）欧拉时间步长的能量守恒开始，该节点与环境交换热量并接收恒定的功率输入。令 $T^n$ 为已知的先前温度（单位：开尔文），$T^{n+1}$ 为未知的下一时刻温度（单位：开尔文）。能量平衡方程为\n$$\nH\\!\\left(T^{n+1}\\right) - H\\!\\left(T^n\\right) = \\Delta t \\left(P - h_c A \\left(T^{n+1} - T_{\\text{amb}}\\right)\\right),\n$$\n其中 $H(T) = m \\, h(T)$ 且 $h(T)$ 是比焓。这是焓法的一种经过充分检验的表述，源于将热力学第一定律（能量守恒）应用于集总控制质量。\n\n比焓的本构关系是\n$$\nh(T) = c \\left(T - T_{\\text{ref}}\\right) + L \\, f(T), \\quad f(T) = \\tfrac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{T - T_m}{w}\\right)\\right),\n$$\n该关系通过半宽为 $w$ 的双曲正切过渡，将显热与平滑的潜热贡献相结合。其导数为\n$$\n\\frac{dh}{dT}(T) = c + L \\, f'(T), \\quad f'(T) = \\tfrac{1}{2}\\,\\frac{1}{w}\\,\\operatorname{sech}^2\\!\\left(\\frac{T - T_m}{w}\\right),\n$$\n其中 $\\operatorname{sech}(x) = 1/\\cosh(x)$。当 $w$ 很小且 $T$ 接近 $T_m$ 时，函数 $f'(T)$ 会变得非常大，这反映了与相变相关的急剧焓变。这是刚性和病态条件的物理现实来源。\n\n将能量平衡方程重排为关于 $T^{n+1}$ 的求根形式，定义\n$$\nF(T) \\equiv H(T) + \\Delta t \\, h_c A \\, T - \\left(H\\!\\left(T^n\\right) + \\Delta t \\, P + \\Delta t \\, h_c A \\, T_{\\text{amb}}\\right) = 0.\n$$\n因为 $H(T) = m \\, h(T)$，牛顿法所需的导数为\n$$\nF'(T) = \\frac{dH}{dT}(T) + \\Delta t \\, h_c A = m \\left(c + L \\, f'(T)\\right) + \\Delta t \\, h_c A.\n$$\n根据构造，$c \\ge 0$, $L \\ge 0$, $f'(T) \\ge 0$, $m > 0$ 且 $\\Delta t \\, h_c A \\ge 0$。因此，\n$$\nF'(T) > 0 \\quad \\text{for all } T,\n$$\n所以 $F(T)$ 是严格单调递增的。因此，该非线性方程对于 $T^{n+1}$ 有唯一解，并且通过取足够宽的界限，总能进行区间限定。\n\n牛顿迭代：\n- 从初始猜测值 $T^{(0)}$ 开始（一个物理上合理的选择是 $T^{(0)} = T^n$），迭代\n$$\nT^{(k+1)} = T^{(k)} - \\frac{F\\!\\left(T^{(k)}\\right)}{F'\\!\\left(T^{(k)}\\right)}.\n$$\n- 收敛准则：\n  - 残差准则 $|F(T^{(k)})| \\le \\varepsilon_F$，其中 $\\varepsilon_F$ 是一个小的能量容差（单位：焦耳，例如 $\\varepsilon_F = 10^{-6}$ $\\mathrm{J}$），确保能量平衡得到满足。\n  - 步长准则 $|T^{(k+1)} - T^{(k)}| \\le \\varepsilon_T$（例如 $\\varepsilon_T = 10^{-8}$ $\\mathrm{K}$），确保迭代值没有显著变化。\n\n当 $\\frac{dH}{dT}$ 很大时的稳健性保障措施：\n- 区间限定与二分法回退：\n  - 因为 $F'(T) > 0$，找到 $[T_{\\ell}, T_u]$ 使得 $F(T_{\\ell}) \\le 0 \\le F(T_u)$ 或反之。如果初始区间内函数值不变号，则几何级数地扩大该区间，直到找到变号点（或达到预设的界限）。\n  - 在一个区间内，尝试一个牛顿步。如果提议的 $T^{(k+1)}$ 超出该区间或未能充分减小 $|F|$（例如，不满足简单的充分下降测试），则用二分步 $T^{(k+1)} = \\tfrac{1}{2}(T_{\\ell} + T_u)$ 替换它。根据新点上 $F$ 的符号更新区间。\n- 线搜索阻尼：\n  - 当没有进行区间限定或 $F'(T)$ 极大时（在 $T_m$ 附近且 $w$ 很小），对牛顿步使用回溯线搜索以强制 $|F|$ 减小，即，用 $\\alpha \\left(-F/F'\\right)$ 替换完整步长，其中 $\\alpha \\in (0,1]$ 不断减小，直到 $|F|$ 相对于前一个迭代值有所减小。\n- 步长控制：\n  - 限制步长以避免不符合物理规律的跳跃（例如，信赖域式控制），并防止在计算 $\\tanh$ 和 $\\cosh$ 时出现数值溢出；注意对于大的 $|T - T_m|/w$ 值，$\\operatorname{sech}^2$ 会饱和到 $0$，这是良性的。\n- 导数正则性：\n  - 即使 $\\frac{dH}{dT}$ 非常大，$F'(T) = \\frac{dH}{dT} + \\Delta t \\, h_c A$ 仍然是严格正的，从而缓解了牛顿更新中除以接近零的数的问题。\n\n每种情况的算法摘要：\n- 计算常数右侧项 $C \\equiv H\\!\\left(T^n\\right) + \\Delta t \\, P + \\Delta t \\, h_c A \\, T_{\\text{amb}}$。\n- 定义 $F(T) = H(T) + \\Delta t \\, h_c A \\, T - C$ 和 $F'(T) = m \\left(c + L \\, f'(T)\\right) + \\Delta t \\, h_c A$。\n- 初始化 $T^{(0)} = T^n$。\n- 围绕 $\\min(T^n, T_{\\text{amb}}) - \\Delta$ 和 $\\max(T^n, T_{\\text{amb}}) + \\Delta$ 构造一个初始区间 $[T_{\\ell}, T_u]$，其中 $\\Delta$ 是某个开尔文温度值（例如 $\\Delta = 100$），然后扩展该区间，直到 $F(T_{\\ell})$ 和 $F(T_u)$ 符号相反。\n- 使用带二分法和线搜索保障措施的牛顿法进行迭代，直到 $|F| \\le \\varepsilon_F$ 且 $| \\Delta T | \\le \\varepsilon_T$，或达到最大迭代次数（例如 50 次）。\n- 报告 $T^{n+1}$（单位：开尔文），四舍五入到六位小数。\n\n容差的理由：\n- 选择 $\\varepsilon_F = 10^{-6}$ $\\mathrm{J}$ 远低于由 $m c$ 乘以开尔文级别温度变化设定的典型能量尺度（数量级在 $10^{3}$ 到 $10^{5}$ $\\mathrm{J}$），这确保了能量平衡在实践中以远小于 $10^{-6}$ 的相对容差得到满足。\n- 选择 $\\varepsilon_T = 10^{-8}$ $\\mathrm{K}$ 保证了牛顿迭代稳定到一个远低于任何传感器分辨率或模型不确定性的温度，因此主要作为一种数学上的终止准则，而不会损害物理真实性。\n- 对于给定的平滑单调函数 $F(T)$，50 次的最大迭代限制对于带二分法保障的牛顿法来说足够高，可以确保收敛。\n\n该测试套件涵盖：\n- 具有中等平滑度（$w = 2$ $\\mathrm{K}$）的标称 PCM 相变。\n- 急剧的相变（$w = 0.2$ $\\mathrm{K}$），在 $T_m$ 附近具有非常大的 $\\frac{dH}{dT}$，用于测试步长阻尼和二分法回退。\n- 线性情况（$L = 0$），此时该方法简化为求解一个严格的线性方程，在没有保障措施的情况下，一次牛顿迭代即可收敛。\n- 跨越 $T_m$ 的负功率冷却，确保凝固过程中的稳健性。\n- 具有大 $\\Delta t$ 和 $h_c A$ 的刚性步长，用于测试由线性汇项引起的条件数。\n\n最终程序实现了上述方法，评估了所有五种情况，并按要求打印单行输出，包含五个以开尔文为单位、四舍五入到六位小数的温度，用方括号括起并以逗号分隔。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef melt_fraction(T, Tm, w):\n    \"\"\"Smooth melt fraction f(T) = 0.5 * (1 + tanh((T-Tm)/w)).\"\"\"\n    z = (T - Tm) / w\n    return 0.5 * (1.0 + np.tanh(z))\n\ndef dmelt_dT(T, Tm, w):\n    \"\"\"Derivative f'(T) = 0.5 * (1/w) * sech^2((T-Tm)/w).\"\"\"\n    z = (T - Tm) / w\n    # sech^2(z) = 1 / cosh^2(z). Use stable computation; large cosh -> inf, 1/inf -> 0.\n    cosh_z = np.cosh(z)\n    sech2 = 1.0 / (cosh_z * cosh_z)\n    return 0.5 * (1.0 / w) * sech2\n\ndef specific_enthalpy(T, c, L, Tref, Tm, w):\n    \"\"\"Specific enthalpy h(T) = c*(T - Tref) + L*f(T).\"\"\"\n    return c * (T - Tref) + L * melt_fraction(T, Tm, w)\n\ndef dhdT(T, c, L, Tm, w):\n    \"\"\"Derivative dh/dT = c + L*f'(T).\"\"\"\n    return c + L * dmelt_dT(T, Tm, w)\n\ndef newton_solve_temperature(m, c, L, Tref, Tm, w, hA, P, dt, Tamb, Tn):\n    \"\"\"\n    Solve F(T) = m*h(T) + dt*hA*T - (m*h(Tn) + dt*P + dt*hA*Tamb) = 0 for T.\n    Safeguarded Newton with bracketing, bisection fallback, and line-search damping.\n    \"\"\"\n    # Define H(T), F(T), and derivatives\n    def h(T):\n        return specific_enthalpy(T, c, L, Tref, Tm, w)\n\n    def dh(T):\n        return dhdT(T, c, L, Tm, w)\n\n    C = m * h(Tn) + dt * P + dt * hA * Tamb\n\n    def F(T):\n        return m * h(T) + dt * hA * T - C\n\n    def J(T):\n        return m * dh(T) + dt * hA\n\n    # Initial guess\n    T_curr = Tn\n\n    # Bracketing\n    # Start with a plausible bracket around known states and expand geometrically until sign change.\n    bracket_delta = 100.0  # Kelvin\n    T_low = min(Tn, Tamb) - bracket_delta\n    T_high = max(Tn, Tamb) + bracket_delta\n\n    F_low = F(T_low)\n    F_high = F(T_high)\n\n    # Expand bracket if no sign change\n    max_expand = 20\n    expand_count = 0\n    while F_low * F_high > 0.0 and expand_count  max_expand:\n        width = T_high - T_low\n        T_low -= width\n        T_high += width\n        F_low = F(T_low)\n        F_high = F(T_high)\n        expand_count += 1\n\n    bracketed = (F_low * F_high) = 0.0\n\n    # Newton iteration with safeguards\n    tol_F = 1e-6      # Joule tolerance\n    tol_T = 1e-8      # Kelvin tolerance\n    max_iter = 50\n    last_T = T_curr\n\n    for it in range(max_iter):\n        Fc = F(T_curr)\n        Jc = J(T_curr)\n\n        # Check residual convergence first\n        if abs(Fc) = tol_F:\n            break\n\n        # Avoid division by very small Jacobian (should not occur here since Jc > 0 by construction)\n        if Jc == 0.0 or not np.isfinite(Jc):\n            # Fall back to bisection if bracketed, otherwise nudge temperature slightly\n            if bracketed:\n                T_next = 0.5 * (T_low + T_high)\n            else:\n                T_next = T_curr + 1e-6  # minimal perturbation\n        else:\n            # Proposed Newton step\n            newton_step = -Fc / Jc\n            T_proposed = T_curr + newton_step\n\n            if bracketed:\n                # Check if proposed step stays within bracket and reduces residual sufficiently\n                accepted = True\n                if not (T_low = T_proposed = T_high):\n                    accepted = False\n                else:\n                    F_prop = F(T_proposed)\n                    # Sufficient decrease check\n                    if abs(F_prop) > 0.5 * abs(Fc):\n                        accepted = False\n                if accepted:\n                    T_next = T_proposed\n                else:\n                    # Bisection fallback\n                    T_next = 0.5 * (T_low + T_high)\n            else:\n                # No bracket: perform backtracking line search on Newton step\n                alpha = 1.0\n                T_next = T_proposed\n                F_next = F(T_next)\n                # Armijo-like decrease condition with small slope parameter\n                while abs(F_next) > (1.0 - 1e-4 * alpha) * abs(Fc) and alpha > (1.0 / 128.0):\n                    alpha *= 0.5\n                    T_next = T_curr + alpha * newton_step\n                    F_next = F(T_next)\n\n        # Update bracket if available\n        if bracketed:\n            F_next = F(T_next)\n            # Maintain bracket with sign test\n            if F_low * F_next = 0.0:\n                T_high = T_next\n                F_high = F_next\n            else:\n                T_low = T_next\n                F_low = F_next\n\n        # Step update\n        step = T_next - T_curr\n        last_T = T_curr\n        T_curr = T_next\n\n        # Check both residual and step size convergence\n        if abs(F(T_curr)) = tol_F and abs(step) = tol_T:\n            break\n\n    return T_curr\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple:\n    # (m, c, L, Tref, Tm, w, hA, P, dt, Tamb, Tn)\n    test_cases = [\n        (0.5, 2000.0, 200000.0, 300.0, 330.0, 2.0, 5.0, 50.0, 10.0, 300.0, 320.0),\n        (0.5, 2000.0, 200000.0, 300.0, 330.0, 0.2, 5.0, 50.0, 10.0, 300.0, 320.0),\n        (1.0, 1000.0, 0.0,     300.0, 330.0, 1.0, 2.0, 100.0, 5.0,  300.0, 305.0),\n        (0.3, 1800.0, 150000.0,300.0, 330.0, 1.0, 10.0,-20.0, 30.0, 300.0, 335.0),\n        (0.8, 2200.0, 250000.0,298.0, 335.0, 0.5, 50.0,200.0, 120.0,300.0, 334.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        m, c, L, Tref, Tm, w, hA, P, dt, Tamb, Tn = case\n        T_np1 = newton_solve_temperature(m, c, L, Tref, Tm, w, hA, P, dt, Tamb, Tn)\n        results.append(T_np1)\n\n    # Final print statement in the exact required format.\n    # Round to six decimal places, Kelvin.\n    formatted = \"[\" + \",\".join(f\"{val:.6f}\" for val in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "工程设计的最终目标是将精确的模型和稳健的求解器应用于解决实际问题。这个综合性练习将材料建模和数值模拟的概念集成到一个真实的优化任务中。您将通过调整导热填料的体积分数来设计一种复合相变材料，以满足电池模组在特定质量预算下的峰值温度约束，这完整地体现了自动化仿真在热管理系统设计中的强大作用。",
            "id": "3939032",
            "problem": "考虑一个与复合相变材料 (PCM) 板块热接触的单一电池模组。目标是在固定的复合材料质量预算下，选择填充物体积分数以平衡增强的导热性和降低的潜热容量，从而将电池峰值温度保持在规定的最大值以下。\n\n基本原理和建模假设：\n- 集总电池温度的能量守恒由热力学第一定律和傅里叶热传导给出：总焓的变化率等于内部生热减去流向环境的热量。\n- 复合 PCM 被视为一种均匀介质，其有效属性取决于填料体积分数，这与球形夹杂物的经典有效介质理论一致。\n- 潜热吸收通过在有限熔化区间内的有效热容进行建模（焓法）。\n\n几何与边界条件：\n- 电池表面是一个面积为 $A$ 的平板，与厚度为 $t$ 的复合 PCM 板块完美热接触。板块的另一侧通过一个大型散热器保持在环境温度 $T_{\\text{amb}}$。\n- 假设热量通过板块进行一维传导，并且通过接触面的热流由一个额外的热阻 $R_{\\text{contact}}$ 表示。\n\n复合材料属性作为填料体积分数 $\\phi$ 的函数：\n- 设 $k_m$ 和 $k_f$ 分别为 PCM 基体和填料的热导率。有效热导率 $k_{\\text{eff}}(\\phi)$ 遵循球形夹杂物的 Maxwell–Eucken 模型：\n$$\nk_{\\text{eff}}(\\phi) = k_m \\, \\frac{k_f + 2 k_m - 2 \\phi (k_m - k_f)}{k_f + 2 k_m + \\phi (k_m - k_f)}.\n$$\n- 设 $\\rho_m$ 和 $\\rho_f$ 分别为 PCM 基体和填料的密度。有效复合材料密度为\n$$\n\\rho_{\\text{eff}}(\\phi) = (1-\\phi) \\rho_m + \\phi \\rho_f.\n$$\n- 设 $c_m$ 和 $c_f$ 分别为 PCM 基体和填料的定压比热容。复合材料的有效显热比热容为\n$$\nc_{\\text{sens,eff}}(\\phi) = (1-\\phi) c_m + \\phi c_f.\n$$\n- 复合材料单位质量的潜热根据以下公式减少\n$$\nL_{\\text{eff}}(\\phi) = (1-\\phi) L,\n$$\n其中 $L$ 是纯 PCM 基体的潜热。\n\n热阻和质量预算：\n- 复合材料的质量预算固定为 $M_c$。板块的厚度由质量预算和有效密度决定：\n$$\nt(\\phi) = \\frac{M_c}{\\rho_{\\text{eff}}(\\phi) \\, A}.\n$$\n- 通过板块和接触面，电池与环境之间的总热阻为\n$$\nR_{\\text{th}}(\\phi) = \\frac{t(\\phi)}{k_{\\text{eff}}(\\phi) \\, A} + R_{\\text{contact}}.\n$$\n\n电池和 PCM 热模型：\n- 设 $m_b$ 为电池质量， $c_b$ 为其比热容。电池温度 $T(t)$ 被建模为集总且空间均匀的。电池内部的生热率 $q(t)$ 是指定的且为非负值。\n- 耦合的电池-PCM 系统的有效热容 $C_{\\text{eff}}(T,\\phi)$ 使用焓法，其熔化区间宽度为 $\\Delta T$，中心在熔化温度 $T_m$ 处，因此：\n$$\nC_{\\text{eff}}(T,\\phi) = m_b c_b + M_c c_{\\text{sens,eff}}(\\phi) + \\chi(T) \\, \\frac{M_c L_{\\text{eff}}(\\phi)}{\\Delta T},\n$$\n其中，指示函数 $\\chi(T)$ 在 $|T - T_m| \\le \\Delta T/2$ 时等于 $1$，否则等于 $0$。\n- 能量平衡给出了温度演化方程：\n$$\nC_{\\text{eff}}(T,\\phi) \\, \\frac{dT}{dt} = q(t) - \\frac{T(t) - T_{\\text{amb}}}{R_{\\text{th}}(\\phi)}.\n$$\n- 初始条件：$T(0) = T_{\\text{amb}}$。\n\n优化问题：\n- 给定一个最大允许峰值温度 $T_{\\max}$ 和一个填料分数上限 $\\phi_{\\max}$，选择 $\\phi \\in [0,\\phi_{\\max}]$ 以在指定的时间范围内满足峰值温度约束 $T_{\\text{peak}}(\\phi) \\le T_{\\max}$，同时遵守质量预算 $M_c$。在所有可行的 $\\phi$ 中，选择最小的 $\\phi$ 以最小化填料使用量。如果区间 $[0,\\phi_{\\max}]$ 内没有可行的 $\\phi$，则报告无解。\n\n数值要求：\n- 通过对微分方程使用固定时间步长 $\\Delta t$ 的显式时间步进法，并使用上述焓法的指示函数形式，来实现温度演化。\n- 对于每个测试用例，在 $[0,\\phi_{\\max}]$ 上的均匀网格上以分辨率 $\\Delta \\phi$ 搜索 $\\phi$，并确定最小的可行 $\\phi$。\n\n你的程序必须解决以下三个测试用例。所有量都必须使用指定的单位。\n\n全局常量（所有测试用例共享）：\n- $A = 0.01 \\, \\mathrm{m^2}$。\n- $T_{\\text{amb}} = 298.15 \\, \\mathrm{K}$。\n- $R_{\\text{contact}} = 0.001 \\, \\mathrm{K/W}$。\n- $m_b = 0.8 \\, \\mathrm{kg}$，$c_b = 1000 \\, \\mathrm{J/(kg \\cdot K)}$。\n- PCM 基体属性：$k_m = 0.25 \\, \\mathrm{W/(m \\cdot K)}$，$\\rho_m = 900 \\, \\mathrm{kg/m^3}$，$c_m = 2000 \\, \\mathrm{J/(kg \\cdot K)}$，$L = 250000 \\, \\mathrm{J/kg}$，$T_m = 305 \\, \\mathrm{K}$，$\\Delta T = 6 \\, \\mathrm{K}$。\n- 填料属性：$k_f = 200 \\, \\mathrm{W/(m \\cdot K)}$，$\\rho_f = 2000 \\, \\mathrm{kg/m^3}$，$c_f = 800 \\, \\mathrm{J/(kg \\cdot K)}$。\n- 时间步进：$\\Delta t = 0.5 \\, \\mathrm{s}$，总持续时间 $t_f$ 按每个测试用例指定。\n- 填料搜索网格分辨率：$\\Delta \\phi = 0.001$。\n\n测试套件：\n1. 用例 1 (理想情况)：\n   - 质量预算 $M_c = 0.6 \\, \\mathrm{kg}$。\n   - 生热率 $q(t) = Q_0$ 对于 $0 \\le t \\le \\tau$，否则 $q(t) = 0$，其中 $Q_0 = 80 \\, \\mathrm{W}$，$\\tau = 600 \\, \\mathrm{s}$。\n   - 最大填料分数 $\\phi_{\\max} = 0.35$。\n   - 温度约束 $T_{\\max} = 315 \\, \\mathrm{K}$。\n   - 仿真持续时间 $t_f = 1200 \\, \\mathrm{s}$。\n\n2. 用例 2 (严格约束，可能不可行)：\n   - 质量预算 $M_c = 0.6 \\, \\mathrm{kg}$。\n   - 生热率 $q(t) = Q_0$ 对于 $0 \\le t \\le \\tau$，否则 $q(t) = 0$，其中 $Q_0 = 150 \\, \\mathrm{W}$，$\\tau = 600 \\, \\mathrm{s}$。\n   - 最大填料分数 $\\phi_{\\max} = 0.50$。\n   - 温度约束 $T_{\\max} = 313 \\, \\mathrm{K}$。\n   - 仿真持续时间 $t_f = 1200 \\, \\mathrm{s}$。\n\n3. 用例 3 (低热量，预计不发生熔化)：\n   - 质量预算 $M_c = 0.3 \\, \\mathrm{kg}$。\n   - 生热率 $q(t) = Q_0$ 对于 $0 \\le t \\le \\tau$，否则 $q(t) = 0$，其中 $Q_0 = 30 \\, \\mathrm{W}$，$\\tau = 300 \\, \\mathrm{s}$。\n   - 最大填料分数 $\\phi_{\\max} = 0.30$。\n   - 温度约束 $T_{\\max} = 310 \\, \\mathrm{K}$。\n   - 仿真持续时间 $t_f = 900 \\, \\mathrm{s}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含三个测试用例的最优填料体积分数，格式为逗号分隔的 Python 风格列表。如果可行，每个条目四舍五入到四位小数，如果区间 $[0,\\phi_{\\max}]$ 内没有 $\\phi$ 满足峰值温度约束，则为整数 $-1$。例如：`[0.1234,-1,0.0000]`。",
            "solution": "所呈现的问题是热工程领域一个适定的优化任务，具体涉及使用复合相变材料（PCM）对电池模组进行热管理。该问题在科学上基于能量守恒和传热原理，并提供了所有必要的参数和本构模型。其表述是客观的，没有矛盾或歧义。因此，该问题被认为是有效的，并且可以构建一个解决方案。\n\n目标是找到在给定范围 $[0, \\phi_{\\max}]$ 内的最小填料体积分数 $\\phi$，以确保电池的峰值温度 $T_{\\text{peak}}$ 不超过指定的最高值 $T_{\\max}$。对最优 $\\phi$ 的搜索必须在分辨率为 $\\Delta\\phi$ 的离散网格上进行。\n\n求解方法包括以下步骤：\n1.  **参数离散化与搜索**：连续设计变量 $\\phi$ 被离散化为一系列候选值的均匀网格，$\\phi_j = j \\Delta\\phi$，从 $\\phi=0$ 开始直到 $\\phi_{\\max}$。搜索按顺序遍历此网格。\n2.  **系统特性计算**：对于每个候选值 $\\phi$，计算复合 PCM 的有效属性和系统的总热阻。\n3.  **瞬态热仿真**：通过使用显式时间步进法对控制常微分方程（ODE）进行数值积分，来模拟电池的温度演化 $T(t)$。\n4.  **约束评估**：从仿真中确定峰值温度 $T_{\\text{peak}}(\\phi) = \\max_{t \\in [0, t_f]} T(t)$。将此值与约束 $T_{\\text{peak}}(\\phi) \\le T_{\\max}$ 进行核对。\n5.  **最优选择**：由于搜索从最小的 $\\phi$ 开始向上进行，第一个满足温度约束的值就是所期望的最小解。如果搜索完成而没有找到可行的 $\\phi$，则在离散化的搜索空间内不存在解。\n\n问题的核心在于由填料分数 $\\phi$ 控制的权衡。增加 $\\phi$ 会增强热导率，但会降低潜热容量。这种平衡决定了系统的热性能。\n\n**1. 作为 $\\phi$ 函数的复合材料属性**\n\n对于给定的填料体积分数 $\\phi$，使用所提供的模型计算复合材料的有效属性：\n-   **有效热导率** ($k_{\\text{eff}}$)：Maxwell–Eucken 模型描述了具有分散球形填料的基体的热导率。\n    $$k_{\\text{eff}}(\\phi) = k_m \\, \\frac{k_f + 2 k_m - 2 \\phi (k_m - k_f)}{k_f + 2 k_m + \\phi (k_m - k_f)}$$\n    $\\phi$ 的增加会提高 $k_{\\text{eff}}$，因为填料的导热系数 $k_f$ 远大于基体的导热系数 $k_m$。\n-   **有效密度** ($\\rho_{\\text{eff}}$)：基于体积分数的简单混合法则。\n    $$\\rho_{\\text{eff}}(\\phi) = (1-\\phi) \\rho_m + \\phi \\rho_f$$\n    由于 $\\rho_f > \\rho_m$，$\\rho_{\\text{eff}}$ 随着 $\\phi$ 的增加而增加。\n-   **有效显热比热容** ($c_{\\text{sens,eff}}$)：基于质量分数的混合法则，对于此问题结构，可简化为所提供的形式。\n    $$c_{\\text{sens,eff}}(\\phi) = (1-\\phi) c_m + \\phi c_f$$\n-   **有效潜热** ($L_{\\text{eff}}$)：潜热容量与 PCM 基体的质量分数成正比。由于复合材料的质量为 $M_c$，基体的质量为 $(1-\\phi)\\rho_m / \\rho_{\\text{eff}}(\\phi) \\cdot M_c$。这里给出了一个更简单的、基于复合材料单位质量的直接减少量：\n    $$L_{\\text{eff}}(\\phi) = (1-\\phi) L$$\n    这表明，添加填料会直接降低复合材料单位质量的潜热储存能力。\n\n**2. 热阻和质量预算**\n\n固定的质量预算 $M_c$ 将板厚 $t$ 与复合材料密度 $\\rho_{\\text{eff}}(\\phi)$ 联系起来：\n$$t(\\phi) = \\frac{M_c}{\\rho_{\\text{eff}}(\\phi) \\, A}$$\n对于相同的质量，较高的 $\\phi$ 会导致更致密的复合材料，从而使板更薄。电池与环境散热器之间的总热阻 $R_{\\text{th}}(\\phi)$ 是板的导热热阻和接触热阻之和：\n$$R_{\\text{th}}(\\phi) = \\frac{t(\\phi)}{k_{\\text{eff}}(\\phi) \\, A} + R_{\\text{contact}} = \\frac{M_c}{\\rho_{\\text{eff}}(\\phi) k_{\\text{eff}}(\\phi) A^2} + R_{\\text{contact}}$$\n增加 $\\phi$ 会同时增加 $\\rho_{\\text{eff}}$ 和 $k_{\\text{eff}}$。乘积 $\\rho_{\\text{eff}} k_{\\text{eff}}$ 通常以超线性的速度增长，导致 $R_{\\text{th}}$ 减小。这改善了稳态散热。\n\n**3. 控制微分方程和数值积分**\n\n集总电容电池-PCM系统的热行为由能量平衡方程控制：\n$$C_{\\text{eff}}(T,\\phi) \\, \\frac{dT}{dt} = q(t) - \\frac{T(t) - T_{\\text{amb}}}{R_{\\text{th}}(\\phi)}$$\n有效热容 $C_{\\text{eff}}(T, \\phi)$ 包括来自电池的贡献、复合材料的显热以及熔化过程中吸收的潜热：\n$$C_{\\text{eff}}(T,\\phi) = m_b c_b + M_c c_{\\text{sens,eff}}(\\phi) + \\chi(T) \\, \\frac{M_c L_{\\text{eff}}(\\phi)}{\\Delta T}$$\n其中指示函数 $\\chi(T)$ 在 $T_m - \\Delta T/2 \\le T \\le T_m + \\Delta T/2$ 时为 $1$，否则为 $0$。该项表示相变期间热容的大幅增加。\n\n为了求解 $T(t)$，我们重排该常微分方程：\n$$\\frac{dT}{dt} = \\frac{1}{C_{\\text{eff}}(T, \\phi)} \\left( q(t) - \\frac{T(t) - T_{\\text{amb}}}{R_{\\text{th}}(\\phi)} \\right)$$\n如指定的那样，此方程使用显式欧拉前向法进行数值积分。给定在时间 $t_i$ 的温度 $T_i$，在下一个时间步 $t_{i+1} = t_i + \\Delta t$ 的温度 $T_{i+1}$ 为：\n$$T_{i+1} = T_i + \\Delta t \\cdot \\left[ \\frac{1}{C_{\\text{eff}}(T_i, \\phi)} \\left( q(t_i) - \\frac{T_i - T_{\\text{amb}}}{R_{\\text{th}}(\\phi)} \\right) \\right]$$\n仿真从初始条件 $T_0 = T(0) = T_{\\text{amb}}$ 开始，并进行到最终时间 $t_f$。在此过程中记录峰值温度 $T_{\\text{peak}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants as per problem statement\nA = 0.01  # m^2\nT_AMB = 298.15  # K\nR_CONTACT = 0.001  # K/W\nM_B = 0.8  # kg\nC_B = 1000.0  # J/(kg.K)\n\n# PCM matrix properties\nK_M = 0.25  # W/(m.K)\nRHO_M = 900.0  # kg/m^3\nC_M = 2000.0  # J/(kg.K)\nL = 250000.0  # J/kg\nT_M = 305.0  # K\nDELTA_T_MELT = 6.0  # K\n\n# Filler properties\nK_F = 200.0  # W/(m.K)\nRHO_F = 2000.0  # kg/m^3\nC_F = 800.0  # J/(kg.K)\n\n# Numerical parameters\nDT = 0.5  # s\nDELTA_PHI = 0.001\n\ndef run_simulation(phi, params):\n    \"\"\"\n    Simulates the temperature evolution for a given filler fraction phi and returns the peak temperature.\n    \n    Args:\n        phi (float): The filler volume fraction.\n        params (dict): A dictionary of case-specific parameters.\n\n    Returns:\n        float: The peak temperature reached during the simulation.\n    \"\"\"\n    # Unpack case-specific parameters\n    m_c = params['M_c']\n    q0 = params['Q0']\n    tau = params['tau']\n    t_f = params['t_f']\n    \n    # 1. Calculate effective properties for the given phi\n    # Effective thermal conductivity (Maxwell-Eucken)\n    k_eff_num = K_F + 2 * K_M - 2 * phi * (K_M - K_F)\n    k_eff_den = K_F + 2 * K_M + phi * (K_M - K_F)\n    k_eff = K_M * k_eff_num / k_eff_den\n    \n    # Effective density (Rule of mixtures)\n    rho_eff = (1 - phi) * RHO_M + phi * RHO_F\n    \n    # Effective sensible specific heat, as defined in problem statement\n    c_sens_eff = (1-phi) * C_M + phi * C_F\n\n    # Effective latent heat\n    l_eff = (1 - phi) * L\n    \n    # 2. Calculate derived quantities\n    # Slab thickness from mass budget\n    t_phi = m_c / (rho_eff * A)\n    \n    # Total thermal resistance\n    r_th = t_phi / (k_eff * A) + R_CONTACT\n    \n    # 3. Time-stepping simulation\n    num_steps = int(t_f / DT)\n    T = T_AMB\n    T_peak = T_AMB\n    \n    T_melt_min = T_M - DELTA_T_MELT / 2\n    T_melt_max = T_M + DELTA_T_MELT / 2\n    \n    # Pre-calculate constant part of C_eff and latent term\n    c_sens_total = M_B * C_B + m_c * c_sens_eff\n    c_latent_term = m_c * l_eff / DELTA_T_MELT if DELTA_T_MELT > 0 else 0\n    \n    for i in range(num_steps):\n        current_time = i * DT\n        \n        # Heat generation pulse\n        q_t = q0 if current_time = tau else 0.0\n        \n        # Effective heat capacity (Enthalpy method) based on indicator function chi(T)\n        is_melting = 1.0 if T_melt_min = T = T_melt_max else 0.0\n        c_eff = c_sens_total + is_melting * c_latent_term\n        \n        # Temperature derivative from the energy balance ODE\n        if c_eff > 1e-9: # Avoid division by zero, though c_eff should always be positive\n            dT_dt = (q_t - (T - T_AMB) / r_th) / c_eff\n        else:\n            dT_dt = 0.0\n\n        # Update temperature using Explicit Euler method\n        T += dT_dt * DT\n        \n        # Update peak temperature\n        if T > T_peak:\n            T_peak = T\n            \n    return T_peak\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        { # Case 1\n            'M_c': 0.6, 'Q0': 80.0, 'tau': 600.0, 'phi_max': 0.35, \n            'T_max': 315.0, 't_f': 1200.0\n        },\n        { # Case 2\n            'M_c': 0.6, 'Q0': 150.0, 'tau': 600.0, 'phi_max': 0.50,\n            'T_max': 313.0, 't_f': 1200.0\n        },\n        { # Case 3\n            'M_c': 0.3, 'Q0': 30.0, 'tau': 300.0, 'phi_max': 0.30,\n            'T_max': 310.0, 't_f': 900.0\n        }\n    ]\n\n    results = []\n    \n    for case_params in test_cases:\n        phi_max = case_params['phi_max']\n        t_max_constraint = case_params['T_max']\n        \n        # Create a uniform grid for phi from 0 to phi_max\n        num_phi_steps = int(round(phi_max / DELTA_PHI)) + 1\n        phi_grid = np.linspace(0, phi_max, num_phi_steps)\n        \n        found_solution = False\n        for phi in phi_grid:\n            peak_temp = run_simulation(phi, case_params)\n            \n            # Check if the peak temperature constraint is satisfied\n            if peak_temp = t_max_constraint:\n                results.append(f\"{phi:.4f}\")\n                found_solution = True\n                break  # Found the smallest feasible phi, move to next case\n        \n        if not found_solution:\n            results.append(\"-1\")\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}