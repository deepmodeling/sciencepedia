{
    "hands_on_practices": [
        {
            "introduction": "本次实践将聚焦于微观尺度下应力的起源。我们将探讨石墨颗粒在锂离子嵌入过程中如何膨胀，并在其表面的固体电解质界面膜（SEI）中产生显著的拉应力。通过运用薄膜力学原理，您将推导膨胀应变与SEI应力之间的关系，从而对一个关键的电池退化机制获得定量的理解。",
            "id": "3910454",
            "problem": "锂离子电池中的石墨负极在运行过程中会形成一层固体电解质界面膜（SEI）。将SEI建模为一个与厚得多的石墨基底完美结合的脆性、线性弹性、各向同性的薄膜。假设薄膜厚度足够小，以至于平面外应力可以忽略不计，并且由于基底的均匀膨胀，平面内应力状态为等双轴应力。基底因锂的嵌入而发生均匀的平面内化学膨胀，锂的嵌入由无量纲的锂分数 $x(t)$ 描述，这在薄膜上产生了施加的平面内溶胀应变 $\\epsilon_{s}(t)$。相对于石墨，SEI的本征应变可以忽略不计（$\\epsilon_{\\text{SEI}}^{\\text{eig}}(t) \\approx 0$），并且没有塑性变形和粘弹性松弛。SEI与基底之间的结合在界面处强制实现平面内应变兼容性。\n\n仅使用小应变各向同性线弹性理论和平面应力运动学的基本原理，推导SEI薄膜中等双轴平面内应力 $\\sigma_{\\text{SEI}}(t)$ 随时间演化的闭合表达式，该表达式应以施加的基底溶胀应变和SEI的弹性常数为变量。然后，对于基底溶胀应变为 $\\epsilon_{s}(t) = k\\,x(t)$ 且\n$$\nx(t) = x_{\\infty}\\left(1 - \\exp\\!\\left(-\\frac{t}{\\tau}\\right)\\right),\n$$\n的特定情况，使用以下参数，计算在 $t^{\\star} = 600\\,\\text{s}$ 时SEI的应力：\n- SEI 杨氏模量 $E_{\\text{SEI}} = 18\\,\\text{GPa}$，\n- SEI 泊松比 $\\nu_{\\text{SEI}} = 0.24$，\n- 化学膨胀系数 $k = 0.020$，\n- 渐近锂分数 $x_{\\infty} = 1$，\n- 时间常数 $\\tau = 480\\,\\text{s}$。\n\n以 $\\text{MPa}$ 为单位表示最终的应力大小，并将答案四舍五入到四位有效数字。",
            "solution": "该问题要求推导附着在膨胀基底（石墨电极）上的薄膜（SEI）的平面内应力，然后针对特定情况进行数值计算。分析将在小应变、各向同性线弹性的框架下进行。\n\n**问题验证**\n\n问题陈述经评估有效。\n\n-   **步骤1：提取已知条件**\n    -   模型：附着于厚得多的石墨基底上的脆性、线性弹性、各向同性薄膜（SEI）。\n    -   假设：完美结合，可忽略的平面外应力（平面应力），等双轴平面内应力 $\\sigma_{\\text{SEI}}$，可忽略的SEI本征应变（$\\epsilon_{\\text{SEI}}^{\\text{eig}}(t) \\approx 0$），无塑性，无粘弹性。\n    -   载荷：基底由于锂嵌入而施加均匀的平面内溶胀应变 $\\epsilon_{s}(t)$，由锂分数 $x(t)$ 表征。\n    -   界面条件：平面内应变兼容性，$\\epsilon_{\\text{SEI, in-plane}} = \\epsilon_{s}(t)$。\n    -   特定应变定律：$\\epsilon_{s}(t) = k\\,x(t)$，其中 $x(t) = x_{\\infty}\\left(1 - \\exp(-t/\\tau)\\right)$。\n    -   参数：$E_{\\text{SEI}} = 18\\,\\text{GPa}$，$\\nu_{\\text{SEI}} = 0.24$，$k = 0.020$，$x_{\\infty} = 1$，$\\tau = 480\\,\\text{s}$。\n    -   求值点：$t^{\\star} = 600\\,\\text{s}$。\n    -   要求输出：应力 $\\sigma_{\\text{SEI}}(t^{\\star})$，单位为兆帕（$\\text{MPa}$），并四舍五入到四位有效数字。\n\n-   **步骤2：使用提取的已知条件进行验证**\n    -   该问题具有科学依据，采用了连续介质力学（线弹性、平面应力）的标准原理。锂离子电池中SEI形成和电极溶胀的物理背景是公认的。\n    -   问题提法得当，提供了所有必要的物理和材料常数、边界条件以及明确的目标。\n    -   语言客观、精确。\n    -   设置是自洽的，没有矛盾。诸如“厚得多”的基底和完美结合等假设是标准的，并且适合将问题简化为可解的形式。\n    -   参数值对于所描述的材料和现象是物理上现实的。\n\n-   **步骤3：结论与行动**\n    -   问题有效。将制定完整的解决方案。\n\n**SEI应力的推导**\n\n设平面内方向由下标 $1$ 和 $2$ 表示，平面外方向由 $3$ 表示。问题陈述，平面内应力状态为等双轴。因此，SEI薄膜中的应力张量分量为：\n$$\n\\sigma_{\\text{SEI}, 11} = \\sigma_{\\text{SEI}, 22} = \\sigma_{\\text{SEI}}(t)\n$$\n$$\n\\sigma_{\\text{SEI}, 12} = \\sigma_{\\text{SEI}, 21} = 0\n$$\n\n分析是在平面应力假设下进行的，该假设假定垂直于薄膜平面的应力分量可以忽略不计：\n$$\n\\sigma_{\\text{SEI}, 33} = \\sigma_{\\text{SEI}, 13} = \\sigma_{\\text{SEI}, 23} = 0\n$$\n\nSEI的本构行为由各向同性线弹性材料的胡克定律描述。应变和应力分量之间的关系是：\n$$\n\\epsilon_{ij} = \\frac{1+\\nu}{E}\\sigma_{ij} - \\frac{\\nu}{E}\\delta_{ij} \\sum_{k=1}^{3} \\sigma_{kk}\n$$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比，$\\delta_{ij}$ 是克罗内克符号。\n\n对于SEI中的平面内正应变（$i=j=1$ 或 $i=j=2$），我们应用本构定律，使用SEI的材料属性（$E_{\\text{SEI}}$, $\\nu_{\\text{SEI}}$）和指定的应力状态：\n$$\n\\epsilon_{\\text{SEI}, 11} = \\frac{1}{E_{\\text{SEI}}}[\\sigma_{\\text{SEI}, 11} - \\nu_{\\text{SEI}}(\\sigma_{\\text{SEI}, 22} + \\sigma_{\\text{SEI}, 33})]\n$$\n$$\n\\epsilon_{\\text{SEI}, 22} = \\frac{1}{E_{\\text{SEI}}}[\\sigma_{\\text{SEI}, 22} - \\nu_{\\text{SEI}}(\\sigma_{\\text{SEI}, 11} + \\sigma_{\\text{SEI}, 33})]\n$$\n代入 $\\sigma_{\\text{SEI}, 11} = \\sigma_{\\text{SEI}, 22} = \\sigma_{\\text{SEI}}(t)$ 和平面应力条件 $\\sigma_{\\text{SEI}, 33} = 0$，平面内应变的方程简化为：\n$$\n\\epsilon_{\\text{SEI}, 11}(t) = \\frac{1}{E_{\\text{SEI}}}[\\sigma_{\\text{SEI}}(t) - \\nu_{\\text{SEI}}\\sigma_{\\text{SEI}}(t)] = \\frac{1-\\nu_{\\text{SEI}}}{E_{\\text{SEI}}}\\sigma_{\\text{SEI}}(t)\n$$\n$$\n\\epsilon_{\\text{SEI}, 22}(t) = \\frac{1}{E_{\\text{SEI}}}[\\sigma_{\\text{SEI}}(t) - \\nu_{\\text{SEI}}\\sigma_{\\text{SEI}}(t)] = \\frac{1-\\nu_{\\text{SEI}}}{E_{\\text{SEI}}}\\sigma_{\\text{SEI}}(t)\n$$\n这表明平面内应变也是等双轴的，$\\epsilon_{\\text{SEI}, 11}(t) = \\epsilon_{\\text{SEI}, 22}(t)$。\n\n问题指明了界面处的完美结合和应变兼容性。这意味着SEI薄膜中的总平面内应变必须与基底施加的溶胀应变 $\\epsilon_s(t)$ 相匹配。由于基底膨胀是均匀的，我们有：\n$$\n\\epsilon_{\\text{SEI}, 11}(t) = \\epsilon_s(t)\n$$\n问题还指出SEI的本征应变可以忽略不计，因此总应变完全是弹性的。\n\n将SEI中弹性应变的表达式与施加的基底应变相等，得到：\n$$\n\\epsilon_s(t) = \\frac{1-\\nu_{\\text{SEI}}}{E_{\\text{SEI}}}\\sigma_{\\text{SEI}}(t)\n$$\n求解等双轴应力 $\\sigma_{\\text{SEI}}(t)$，得到通用的闭合表达式：\n$$\n\\sigma_{\\text{SEI}}(t) = \\frac{E_{\\text{SEI}}}{1-\\nu_{\\text{SEI}}}\\epsilon_s(t)\n$$\n项 $\\frac{E_{\\text{SEI}}}{1-\\nu_{\\text{SEI}}}$ 被称为双轴模量。\n\n**数值计算**\n\n现在，我们针对所提供的特定情况计算此表达式。基底溶胀应变由下式给出：\n$$\n\\epsilon_{s}(t) = k\\,x(t) = k\\,x_{\\infty}\\left(1 - \\exp\\left(-\\frac{t}{\\tau}\\right)\\right)\n$$\n将此代入应力方程：\n$$\n\\sigma_{\\text{SEI}}(t) = \\frac{E_{\\text{SEI}}}{1-\\nu_{\\text{SEI}}} k\\,x_{\\infty}\\left(1 - \\exp\\left(-\\frac{t}{\\tau}\\right)\\right)\n$$\n我们需要使用给定参数计算在时间 $t^{\\star} = 600\\,\\text{s}$ 时的应力：\n-   $E_{\\text{SEI}} = 18\\,\\text{GPa} = 18 \\times 10^3\\,\\text{MPa}$\n-   $\\nu_{\\text{SEI}} = 0.24$\n-   $k = 0.020$\n-   $x_{\\infty} = 1$\n-   $\\tau = 480\\,\\text{s}$\n\n首先，计算指数函数的参数：\n$$\n\\frac{t^{\\star}}{\\tau} = \\frac{600\\,\\text{s}}{480\\,\\text{s}} = \\frac{60}{48} = \\frac{5}{4} = 1.25\n$$\n现在将所有值代入应力表达式：\n$$\n\\sigma_{\\text{SEI}}(t^{\\star}) = \\frac{18 \\times 10^3\\,\\text{MPa}}{1 - 0.24} \\times 0.020 \\times 1 \\times \\left(1 - \\exp(-1.25)\\right)\n$$\n$$\n\\sigma_{\\text{SEI}}(t^{\\star}) = \\frac{18 \\times 10^3}{0.76} \\times 0.020 \\times \\left(1 - \\exp(-1.25)\\right)\\,\\text{MPa}\n$$\n进行数值计算：\n$$\n\\exp(-1.25) \\approx 0.2865047968\n$$\n$$\n1 - \\exp(-1.25) \\approx 1 - 0.2865047968 = 0.7134952032\n$$\n$$\n\\sigma_{\\text{SEI}}(t^{\\star}) \\approx \\left(\\frac{18 \\times 10^3}{0.76}\\right) \\times 0.020 \\times 0.7134952032\\,\\text{MPa}\n$$\n$$\n\\sigma_{\\text{SEI}}(t^{\\star}) \\approx (23684.2105...) \\times 0.020 \\times 0.7134952032\\,\\text{MPa}\n$$\n$$\n\\sigma_{\\text{SEI}}(t^{\\star}) \\approx 473.68421... \\times 0.7134952032\\,\\text{MPa}\n$$\n$$\n\\sigma_{\\text{SEI}}(t^{\\star}) \\approx 338.006422\\,\\text{MPa}\n$$\n问题要求将答案四舍五入到四位有效数字。\n$$\n\\sigma_{\\text{SEI}}(t^{\\star}) \\approx 338.0\\,\\text{MPa}\n$$\n正号表示SEI薄膜处于拉伸状态，这与被膨胀的基底拉伸的物理情况一致。",
            "answer": "$$\\boxed{338.0}$$"
        },
        {
            "introduction": "基于对膨胀诱导应力的理解，本次实践将重点转向电极设计。我们将使用简化的均质化模型，研究机械完整性与电化学性能（以孔隙率作为代表）之间的内在权衡。该练习将引导您学习多目标优化的概念并构建帕累托前沿，这是做出明智工程设计决策的关键工具。",
            "id": "3910461",
            "problem": "考虑一个在约束性叠层中经历嵌入引起的体积膨胀的多孔、各向同性复合电极。您将使用一个简化的均质化模型，推导、形式化并计算孔隙率与溶胀引起的机械应力之间的权衡关系，然后为这些竞争性目标构建一个帕累托前沿。\n\n从线性弹性力学和微观力学的第一性原理开始：\n\n- 电极的固体骨架被建模为线性弹性、均匀、各向同性的材料，其杨氏模量为 $E_s$，泊松比为 $\\nu_s$。体积模量定义为 $K_s = \\dfrac{E_s}{3(1 - 2 \\nu_s)}$。\n- 在固相中发生体积本征应变为 $\\epsilon^\\star$ 的各向同性溶胀，并受到具有有限体积刚度 $K_c$ 的叠层的静水压力耦合约束时，平衡与相容性条件意味着会产生载荷分担的压力。将约束叠层和多孔电极视为两个串联的静水压力弹簧。\n- 对于均质化，使用一个简化但科学上合理的标度律来描述多孔复合材料：有效体积模量 $K_{\\text{eff}}(\\varepsilon)$ 与固体体积分数 $(1 - \\varepsilon)$ 遵循幂律关系，其指数 $m$ 源于多孔固体微观力学（如 Gibson–Ashby 标度律）的启发。由于承载面积减小，固体骨架所承受的应力高于复合材料的平均压力；用一个指数 $q \\geq 1$ 来对此应力集中进行建模。\n\n您必须推导、论证并实现以下内容，不得引入任何不符合物理现实的假设：\n\n1. 根据线性弹性力学和串联弹簧（约束性叠层和多孔电极）之间的静水压力载荷分担原理，推导在本征应变 $\\epsilon^\\star$ 下复合材料中由溶胀引起的静水压力 $p(\\varepsilon)$；然后通过基于固体体积分数的应力集中因子定义固体骨架应力 $\\sigma_{\\text{solid}}(\\varepsilon)$。\n2. 根据多孔介质的微观力学，写出有效模量标度律 $K_{\\text{eff}}(\\varepsilon)$ 作为 $K_s$、$\\varepsilon$ 和 $m$ 的函数。确保 $K_{\\text{eff}}(\\varepsilon)$ 遵守有效介质理论的界限，并在允许的孔隙率范围内保持为正值。\n3. 使用孔隙率定义一个传输目标：可以直接是孔隙率 $\\varepsilon$（待最大化），也可以是通过使用 Bruggeman 型指数 $a$ 的有效离子电导率 $\\kappa_{\\text{eff}}(\\varepsilon)$。您必须明确说明您采用哪个目标以及如何计算它。\n4. 将此问题视为一个双目标问题，在一系列离散的孔隙率值网格上构建一个帕累托前沿：\n   - 目标 $\\mathcal{O}_1$：最小化 $\\sigma_{\\text{solid}}(\\varepsilon)$（单位：帕斯卡）。\n   - 目标 $\\mathcal{O}_2$：最大化孔隙率 $\\varepsilon$（等效于最小化 $-\\varepsilon$；孔隙率是无量纲的）。\n   使用帕累托支配的标准定义：如果点 $A$ 在所有目标上都不差于点 $B$，并且在至少一个目标上严格优于点 $B$，则点 $A$ 支配点 $B$。识别出非支配孔隙率值的集合。\n\n数值实现要求：\n\n- 对于每个测试案例，使用以下离散孔隙率网格定义：从 $\\varepsilon_{\\min}$ 到 $\\varepsilon_{\\max}$ 的均匀网格，步长为 $\\Delta \\varepsilon$，包含端点。孔隙率是无量纲的。\n- 所有模量单位均为帕斯卡，本征应变 $\\epsilon^\\star$ 为无量纲体积应变，孔隙率 $\\varepsilon$ 为无量纲。内部计算时应力单位为帕斯卡；最终输出应仅包含孔隙率值（无量纲）。\n- 四舍五入：在最终的帕累托前沿列表中，将每个孔隙率值四舍五入到三位小数。\n- 不允许外部输入；硬编码测试套件并直接生成输出。\n\n测试套件：\n\n为以下所有参数集提供结果。对于每个案例，构建孔隙率网格并如上所述计算帕累托前沿。参数如下：\n\n- 案例 1（通用“理想路径”）：$E_s = 12 \\times 10^9 \\, \\text{Pa}$，$\\nu_s = 0.30$，$\\beta = 0.08$，$x = 0.60$，$\\epsilon^\\star = \\beta x$，$K_c = 2 \\times 10^9 \\, \\text{Pa}$，$m = 2.0$，$q = 2.0$，采用传输目标为孔隙率 $\\varepsilon$，孔隙率网格：$\\varepsilon_{\\min} = 0.05$，$\\varepsilon_{\\max} = 0.60$，$\\Delta \\varepsilon = 0.01$。\n- 案例 2（高约束刚度边界）：$E_s = 35 \\times 10^9 \\, \\text{Pa}$，$\\nu_s = 0.26$，$\\beta = 0.05$，$x = 1.00$，$\\epsilon^\\star = \\beta x$，$K_c = 50 \\times 10^9 \\, \\text{Pa}$，$m = 2.5$，$q = 2.0$，采用传输目标为孔隙率 $\\varepsilon$，孔隙率网格：$\\varepsilon_{\\min} = 0.10$，$\\varepsilon_{\\max} = 0.70$，$\\Delta \\varepsilon = 0.02$。\n- 案例 3（高溶胀边缘案例）：$E_s = 70 \\times 10^9 \\, \\text{Pa}$，$\\nu_s = 0.22$，$\\beta = 0.25$，$x = 0.40$，$\\epsilon^\\star = \\beta x$，$K_c = 5 \\times 10^9 \\, \\text{Pa}$，$m = 2.0$，$q = 2.0$，采用传输目标为孔隙率 $\\varepsilon$，孔隙率网格：$\\varepsilon_{\\min} = 0.02$，$\\varepsilon_{\\max} = 0.40$，$\\Delta \\varepsilon = 0.01$。\n\n输出规格：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试案例的帕累托前沿：一个包含四舍五入后的孔隙率值（无量纲）的列表。例如，最后一行应类似于 $[\\,[\\ldots],\\,[\\ldots],\\,[\\ldots]\\,]$，并且其中的每个孔隙率值都必须四舍五入到三位小数。\n\n明确地说，您的输出必须是一个单独的 Python 列表字面量，包含三个元素（每个案例一个），每个元素都是一个列表，其中包含帕累托前沿上的孔隙率值，四舍五入到三位小数，无额外文本。",
            "solution": "已对用户提供的问题进行分析和验证。\n\n### 第 1 步：提取已知条件\n- **模型**：约束下的多孔、各向同性复合电极。\n- **物理学**：线性弹性力学、微观力学、静水压力载荷分担。\n- **固体骨架属性**：杨氏模量 $E_s$、泊松比 $\\nu_s$。\n- **固体体积模量定义**：$K_s = \\dfrac{E_s}{3(1 - 2 \\nu_s)}$。\n- **溶胀**：固相中的各向同性溶胀，体积本征应变为 $\\epsilon^\\star$。\n- **约束**：具有有限体积刚度 $K_c$ 的叠层。\n- **均质化 - 有效模量**：$K_{\\text{eff}}(\\varepsilon)$ 与固体体积分数 $(1 - \\varepsilon)$ 遵循幂律关系，指数为 $m$。即 $K_{\\text{eff}}(\\varepsilon) \\propto (1-\\varepsilon)^m$。\n- **均质化 - 应力集中**：固体骨架应力 $\\sigma_{\\text{solid}}$ 相对于复合材料平均压力 $p$ 发生集中，通过指数 $q \\geq 1$ 描述。\n- **孔隙率**：符号 $\\varepsilon$，无量纲。\n- **目标**：\n    - $\\mathcal{O}_1$：最小化固体骨架应力 $\\sigma_{\\text{solid}}(\\varepsilon)$（单位：帕斯卡）。\n    - $\\mathcal{O}_2$：最大化孔隙率 $\\varepsilon$（无量纲），等效于最小化 $-\\varepsilon$。\n- **帕累托支配**：如果点 $A$ 在所有目标上都不差于点 $B$，并且在至少一个目标上严格优于点 $B$，则点 $A$ 支配点 $B$。\n- **孔隙率网格**：从 $\\varepsilon_{\\min}$ 到 $\\varepsilon_{\\max}$ 的均匀网格，步长为 $\\Delta \\varepsilon$，包含端点。\n- **测试案例 1**：$E_s = 12 \\times 10^9 \\, \\text{Pa}$，$\\nu_s = 0.30$，$\\beta = 0.08$，$x = 0.60$，$\\epsilon^\\star = \\beta x$，$K_c = 2 \\times 10^9 \\, \\text{Pa}$，$m = 2.0$，$q = 2.0$，$\\mathcal{O}_2$ 为最大化 $\\varepsilon$，网格：$\\varepsilon_{\\min} = 0.05$，$\\varepsilon_{\\max} = 0.60$，$\\Delta \\varepsilon = 0.01$。\n- **测试案例 2**：$E_s = 35 \\times 10^9 \\, \\text{Pa}$，$\\nu_s = 0.26$，$\\beta = 0.05$，$x = 1.00$，$\\epsilon^\\star = \\beta x$，$K_c = 50 \\times 10^9 \\, \\text{Pa}$，$m = 2.5$，$q = 2.0$，$\\mathcal{O}_2$ 为最大化 $\\varepsilon$，网格：$\\varepsilon_{\\min} = 0.10$，$\\varepsilon_{\\max} = 0.70$，$\\Delta \\varepsilon = 0.02$。\n- **测试案例 3**：$E_s = 70 \\times 10^9 \\, \\text{Pa}$，$\\nu_s = 0.22$，$\\beta = 0.25$，$x = 0.40$，$\\epsilon^\\star = \\beta x$，$K_c = 5 \\times 10^9 \\, \\text{Pa}$，$m = 2.0$，$q = 2.0$，$\\mathcal{O}_2$ 为最大化 $\\varepsilon$，网格：$\\varepsilon_{\\min} = 0.02$，$\\varepsilon_{\\max} = 0.40$，$\\Delta \\varepsilon = 0.01$。\n- **四舍五入**：帕累托前沿中的最终孔隙率值需四舍五入到三位小数。\n\n### 第 2 步：使用提取的已知条件进行验证\n问题被评估为**有效**。\n- **科学基础**：该问题基于连续介质力学、线性弹性力学和多孔材料微观力学的既定原理。所用模型，如有效属性的幂律标度（类似于 Gibson-Ashby 模型）和用于载荷分担的串联弹簧类比，是机械建模中标准且合理的简化。\n- **良态问题**：任务是在一组离散的设计选项（孔隙率值）上执行多目标优化。目标定义清晰，构建帕累托前沿的程序是一个标准、明确定义的数学过程。对于给定的输入，存在唯一的解（帕累托最优孔隙率的集合）。\n- **客观性**：问题陈述具有精确、量化的参数和客观标准。它没有歧义和主观论断。\n- **完整性**：为每个测试案例提供了所有必要的参数和定义（$E_s, \\nu_s, \\epsilon^\\star, K_c, m, q$ 以及孔隙率网格），使得问题自成体系。“LASER 不相关”的陈述旨在澄清范围，不引入任何使问题无效的因素。\n\n### 第 3 步：结论与行动\n问题有效。将提供完整解决方案。\n\n### 求解推导与算法设计\n\n#### 1. 有效体积模量 $K_{\\text{eff}}(\\varepsilon)$ 的推导\n问题指定多孔复合材料的有效体积模量 $K_{\\text{eff}}(\\varepsilon)$ 与固体体积分数 $(1 - \\varepsilon)$ 遵循幂律关系，指数为 $m$。此关系表示为：\n$$\nK_{\\text{eff}}(\\varepsilon) \\propto (1 - \\varepsilon)^m\n$$\n为确定比例常数，我们应用边界条件：当孔隙率为零（$\\varepsilon = 0$）时，有效模量必须等于固体材料的模量 $K_s$。\n$$\nK_{\\text{eff}}(0) = K_s\n$$\n这导出了以下表达式：\n$$\nK_{\\text{eff}}(\\varepsilon) = K_s (1 - \\varepsilon)^m\n$$\n固体骨架的体积模量 $K_s$ 根据给定的杨氏模量 $E_s$ 和泊松比 $\\nu_s$，使用各向同性线性弹性力学中的标准公式推导得出：\n$$\nK_s = \\frac{E_s}{3(1 - 2\\nu_s)}\n$$\n\n#### 2. 溶胀引起的压力 $p(\\varepsilon)$ 的推导\n问题将多孔电极及其约束建模为两个串联的静水压力弹簧。电极的总自由体积膨胀（本征应变）$\\epsilon^\\star$ 由电极本身的压缩应变 $\\epsilon_{\\text{comp, electrode}}$ 和约束的膨胀应变 $\\epsilon_{\\text{comp, confine}}$ 共同调节。根据几何相容性：\n$$\n\\epsilon^\\star = \\epsilon_{\\text{comp, electrode}} + \\epsilon_{\\text{comp, confine}}\n$$\n在静水压力条件下，压力 $p$ 和体积应变 $\\epsilon_{\\text{comp}}$ 之间的关系由体积模量 $K$ 给出：$p = K \\cdot \\epsilon_{\\text{comp}}$。因此，我们可以用系统中产生的平衡压力 $p$ 来表示应变：\n$$\n\\epsilon_{\\text{comp, electrode}} = \\frac{p}{K_{\\text{eff}}(\\varepsilon)}\n$$\n$$\n\\epsilon_{\\text{comp, confine}} = \\frac{p}{K_c}\n$$\n将这些代入相容性方程：\n$$\n\\epsilon^\\star = \\frac{p}{K_{\\text{eff}}(\\varepsilon)} + \\frac{p}{K_c} = p \\left( \\frac{1}{K_{\\text{eff}}(\\varepsilon)} + \\frac{1}{K_c} \\right)\n$$\n解出压力 $p(\\varepsilon)$：\n$$\np(\\varepsilon) = \\epsilon^\\star \\left( \\frac{1}{K_{\\text{eff}}(\\varepsilon)} + \\frac{1}{K_c} \\right)^{-1} = \\epsilon^\\star \\frac{K_{\\text{eff}}(\\varepsilon) K_c}{K_{\\text{eff}}(\\varepsilon) + K_c}\n$$\n这是复合电极内的平均静水压力。\n\n#### 3. 固体骨架应力 $\\sigma_{\\text{solid}}(\\varepsilon)$ 的推导\n平均压力 $p(\\varepsilon)$ 由电极的固体骨架承载，其承载面积分数减小，可近似为固体体积分数 $(1 - \\varepsilon)$。这导致固相中的应力集中。问题指定了一个幂律模型来描述这种集中效应，指数为 $q$。固相中的应力 $\\sigma_{\\text{solid}}$ 与平均压力 $p$ 的关系为：\n$$\n\\sigma_{\\text{solid}}(\\varepsilon) = \\frac{p(\\varepsilon)}{(1 - \\varepsilon)^q}\n$$\n通过代入 $p(\\varepsilon)$ 和 $K_{\\text{eff}}(\\varepsilon)$ 的表达式，我们得到第一个目标函数的最终表达式：\n$$\n\\sigma_{\\text{solid}}(\\varepsilon) = \\left( \\epsilon^\\star \\frac{K_s (1 - \\varepsilon)^m K_c}{K_s (1 - \\varepsilon)^m + K_c} \\right) \\frac{1}{(1 - \\varepsilon)^q} = \\epsilon^\\star K_c K_s \\frac{(1 - \\varepsilon)^{m-q}}{K_c + K_s (1 - \\varepsilon)^m}\n$$\n此函数 $\\sigma_{\\text{solid}}(\\varepsilon)$ 需要被最小化。\n\n#### 4. 双目标问题公式化与帕累托前沿构建\n我们在一个离散的孔隙率值 $\\varepsilon_i$ 网格上定义了一个双目标优化问题。两个目标是：\n- $\\mathcal{O}_1(\\varepsilon) = \\sigma_{\\text{solid}}(\\varepsilon)$ (最小化)\n- $\\mathcal{O}_2(\\varepsilon) = \\varepsilon$ (最大化)\n\n要构建帕累托前沿，我们为指定网格中的每个孔隙率 $\\varepsilon_i$ 计算目标对 $(\\sigma_{\\text{solid}}(\\varepsilon_i), \\varepsilon_i)$。一个点（及其对应的孔隙率值 $\\varepsilon_k$）如果未被任何其他点支配，则属于帕累托前沿。一个具有目标 $(\\sigma_j, \\varepsilon_j)$ 的点 $j$ 支配一个具有目标 $(\\sigma_i, \\varepsilon_i)$ 的点 $i$，如果：\n$$\n(\\sigma_j \\le \\sigma_i) \\land (\\varepsilon_j \\ge \\varepsilon_i) \\land ((\\sigma_j  \\sigma_i) \\lor (\\varepsilon_j > \\varepsilon_i))\n$$\n算法流程如下：\n1. 对于给定的测试案例，从 $\\varepsilon_{\\min}$ 到 $\\varepsilon_{\\max}$ 生成步长为 $\\Delta\\varepsilon$ 的均匀孔隙率网格，确保包含端点 $\\varepsilon_{\\max}$。\n2. 对于网格中的每个孔隙率值 $\\varepsilon_i$，计算目标向量 $(\\sigma_{\\text{solid}}(\\varepsilon_i), \\varepsilon_i)$。存储这些向量。\n3. 初始化一个空集用于存放帕累托最优的点。\n4. 遍历每个计算出的目标向量。对于每个候选向量 $V_i$，将其与所有其他向量 $V_j$ 进行比较。如果有任何 $V_j$ 支配 $V_i$，则 $V_i$ 不在帕累托前沿上。\n5. 如果在所有比较之后，没有其他向量支配 $V_i$，则 $V_i$ 是一个帕累托最优点，并将其添加到前沿中。\n6. 检查完所有候选向量后，得到的集合即包含完整的帕累托前沿。\n7. 从帕累托前沿上的点中提取孔隙率值，按升序排序，并将每个值四舍五入到三位小数。此列表构成该测试案例的最终结果。\n对提供的三个测试案例中的每一个都执行此程序。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes the Pareto front for a bi-objective optimization problem \n    in battery electrode design, trading off mechanical stress against porosity.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"E_s\": 12e9, \"nu_s\": 0.30, \"beta\": 0.08, \"x\": 0.60,\n            \"K_c\": 2e9, \"m\": 2.0, \"q\": 2.0,\n            \"eps_min\": 0.05, \"eps_max\": 0.60, \"delta_eps\": 0.01\n        },\n        {\n            \"E_s\": 35e9, \"nu_s\": 0.26, \"beta\": 0.05, \"x\": 1.00,\n            \"K_c\": 50e9, \"m\": 2.5, \"q\": 2.0,\n            \"eps_min\": 0.10, \"eps_max\": 0.70, \"delta_eps\": 0.02\n        },\n        {\n            \"E_s\": 70e9, \"nu_s\": 0.22, \"beta\": 0.25, \"x\": 0.40,\n            \"K_c\": 5e9, \"m\": 2.0, \"q\": 2.0,\n            \"eps_min\": 0.02, \"eps_max\": 0.40, \"delta_eps\": 0.01\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Unpack parameters for the current case\n        E_s, nu_s = case[\"E_s\"], case[\"nu_s\"]\n        beta, x = case[\"beta\"], case[\"x\"]\n        K_c, m, q = case[\"K_c\"], case[\"m\"], case[\"q\"]\n        eps_min, eps_max, delta_eps = case[\"eps_min\"], case[\"eps_max\"], case[\"delta_eps\"]\n        \n        # Calculate derived parameters\n        eps_star = beta * x\n        K_s = E_s / (3 * (1 - 2 * nu_s))\n\n        # 1. Generate the porosity grid.\n        # Use a small tolerance with np.arange to ensure the endpoint is included.\n        porosity_grid = np.arange(eps_min, eps_max + delta_eps / 2.0, delta_eps)\n\n        # 2. Evaluate objectives for each point in the grid.\n        # objectives is a list of dicts, each holding the values for one porosity point.\n        objectives = []\n        for eps in porosity_grid:\n            # Effective bulk modulus of the porous electrode\n            K_eff = K_s * (1 - eps)**m\n            \n            # Swelling-induced hydrostatic pressure in the composite\n            p = eps_star * (K_eff * K_c) / (K_eff + K_c)\n            \n            # Stress in the solid-skeleton, accounting for stress concentration\n            sigma_solid = p / (1 - eps)**q\n            \n            objectives.append({'stress': sigma_solid, 'porosity': eps})\n\n        # 3. Construct the Pareto front.\n        pareto_front_points = []\n        for p_i in objectives:\n            is_dominated = False\n            for p_j in objectives:\n                if p_i is p_j:\n                    continue\n                \n                # A point j dominates point i if it is better or equal on all objectives\n                # and strictly better on at least one.\n                # Objective 1: stress (minimize)\n                # Objective 2: porosity (maximize)\n                stress_j, por_j = p_j['stress'], p_j['porosity']\n                stress_i, por_i = p_i['stress'], p_i['porosity']\n                \n                # Correct logic for Pareto dominance:\n                # j dominates i if (j is no worse than i) AND (j is strictly better in at least one aspect)\n                is_no_worse = (stress_j = stress_i) and (por_j >= por_i)\n                is_strictly_better = (stress_j  stress_i) or (por_j > por_i)\n                \n                if is_no_worse and is_strictly_better:\n                    is_dominated = True\n                    break\n            \n            if not is_dominated:\n                pareto_front_points.append(p_i)\n        \n        # 4. Extract, sort, and round porosity values from the Pareto front.\n        pareto_porosities = sorted([p['porosity'] for p in pareto_front_points])\n        rounded_porosities = [round(p, 3) for p in pareto_porosities]\n        \n        all_results.append(rounded_porosities)\n\n    # Final print statement must be a single line in the format [[...],[...],[...]]\n    # using str() and replace() to achieve the exact format without spaces.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "对于实时控制和系统级仿真，高保真度的完整力学模型通常计算成本过高。最后的实践将介绍一种先进的计算技术——多项式混沌展开（Polynomial Chaos Expansion, PCE），以构建一个关于电堆压力的低阶代理模型。通过用简单的多项式逼近复杂的高保真函数，您将学习如何为电池管理系统创建快速而准确的预测工具。",
            "id": "3910435",
            "problem": "您的任务是使用多项式混沌展开（PCE）方法，构建、实现并验证一个低阶代理模型。该模型用于描述在贯穿厚度方向约束下，层压式锂离子电池堆的堆叠压力，并将其表示为荷电状态和温度的函数。目标是近似一个物理上合理的高保真参考模型，该参考模型可替代有限元方法（FEM）模型。该问题必须从与复合电极的线弹性及热机械膨胀相一致的第一性原理出发进行求解，最终答案必须是一个可运行的程序，能够为指定的测试套件生成输出。\n\n从以下基本依据和核心定义开始：\n- 线性弹性的 Hooke 定律，指出应力与应变成正比，$\\,\\sigma = E \\,\\varepsilon\\,$，其中 $\\,\\sigma\\,$ 是应力，$\\,E\\,$ 是杨氏模量，$\\,\\varepsilon\\,$ 是应变。\n- 受约束层的平面应变模量，$\\,E_{\\text{ps}}(T) = \\dfrac{E(T)}{1-\\nu^2}\\,$，其中 $\\,\\nu\\,$ 是泊松比，$\\,E(T)\\,$ 是随温度变化的有效模量。\n- 受约束的堆叠压力被建模为与平均贯穿厚度方向应力成正比，$\\,p(s,T) = g \\, E_{\\text{ps}}(T)\\, \\varepsilon_{\\text{eff}}(s,T)\\,$，其中 $\\,g\\,$ 是一个无量纲的几何约束因子，它综合了电堆纵横比和端板刚度，$\\,s\\,$ 是荷电状态（分数化学计量，无量纲），$\\,T\\,$ 是开尔文温度。\n\n将高保真参考压力 $\\,p_{\\text{true}}(s,T)\\,$ 定义为一个成分和热耦合的函数，该函数包含了模量软化和非线性膨胀，与在复合电极中观察到的行为一致：\n- 随温度变化的模量：\n$$\nE(T) = \\frac{E_0}{\\,1 + b\\,(T - T_{\\text{ref}})\\,}\\,,\n$$\n$$\nE_{\\text{ps}}(T) = \\frac{E(T)}{\\,1 - \\nu^2\\,}\\,,\n$$\n其中 $\\,E_0 = 4000\\,\\text{MPa}\\,$, $\\,b = 0.015\\,\\text{K}^{-1}\\,$, $\\,T_{\\text{ref}} = 298\\,\\text{K}\\,$, $\\,\\nu = 0.30\\,$。\n- 有效膨胀应变：\n$$\n\\varepsilon_{\\text{eff}}(s,T) = a_1 s + a_2 s^2 + a_T s^2 \\left(\\frac{T - T_{\\text{ref}}}{T_{\\text{ref}}}\\right) + a_c\\, s(1-s)\\, \\tanh\\!\\left(\\frac{T - T_{\\text{ref}}}{\\Delta T}\\right),\n$$\n其中 $\\,a_1 = 0.015\\,$, $\\,a_2 = 0.006\\,$, $\\,a_T = 0.004\\,$, $\\,a_c = 0.003\\,$, $\\,\\Delta T = 50\\,\\text{K}\\,$。\n- 交叉耦合放大因子：\n$$\n\\chi(s,T) = 1 + \\delta\\, s \\left(\\frac{T - T_{\\text{ref}}}{T_{\\text{ref}}}\\right), \\quad \\delta = 0.2\\,.\n$$\n- 几何约束因子：\n$$\ng = 0.08\\,.\n$$\n- 以兆帕（MPa）为单位的高保真压力：\n$$\np_{\\text{true}}(s,T) = g \\, E_{\\text{ps}}(T)\\, \\varepsilon_{\\text{eff}}(s,T)\\, \\chi(s,T)\\,.\n$$\n\n使用多项式混沌展开（PCE）构建一个在两个输入 $\\,s\\,$ 和 $\\,T\\,$ 上的总阶数为 $\\,2\\,$ 的低阶代理模型。这两个输入被视为在其操作域上均匀分布的独立随机变量。使用 Legendre 多项式作为均匀输入的正交基。将物理输入映射到 $\\,[-1,1]\\,$ 上的规范变量：\n- 荷电状态映射：\n$$\n\\xi_s = 2s - 1\\,, \\quad s \\in [0,1]\\,.\n$$\n- 温度映射：\n$$\n\\xi_T = \\frac{2T - (T_{\\min} + T_{\\max})}{T_{\\max} - T_{\\min}}\\,, \\quad T \\in [T_{\\min}, T_{\\max}]\\,,\n$$\n其中 $\\,T_{\\min} = 273\\,\\text{K}\\,$，$\\,T_{\\max} = 333\\,\\text{K}\\,$。\n\n令 $\\,L_0(x) = 1\\,$, $\\,L_1(x) = x\\,$ 和 $\\,L_2(x) = \\tfrac{1}{2}(3x^2-1)\\,$ 表示前三个 Legendre 多项式。通过对 $\\,i,j \\in \\{0,1,2\\}\\,$ 求积 $\\,L_i(\\xi_s)\\,L_j(\\xi_T)\\,$，形成最高阶数为 $\\,2\\,$ 的二元基，共产生 $\\,9\\,$ 个项。代理模型的形式为\n$$\np_{\\text{PCE}}(s,T) = \\sum_{i=0}^{2} \\sum_{j=0}^{2} c_{ij}\\, L_i(\\xi_s)\\, L_j(\\xi_T)\\,,\n$$\n其中 $\\,c_{ij}\\,$ 是待定系数，可通过非侵入式谱投影方法确定。该方法通过张量积 Gauss-Legendre 求积进行近似，或等效地，通过在 Gauss-Legendre 配置网格上进行最小二乘回归来确定。\n\n必须通过计算在输入域上相对于均匀概率测度的相对 $\\,L^2\\,$ 误差来量化其相对于高保真参考模型的准确性：\n$$\n\\mathcal{E}_{\\text{rel}} = \\sqrt{\\frac{\\int_{-1}^{1}\\int_{-1}^{1} \\left(p_{\\text{PCE}} - p_{\\text{true}}\\right)^2 \\, d\\xi_s\\, d\\xi_T}{\\int_{-1}^{1}\\int_{-1}^{1} \\left(p_{\\text{true}}\\right)^2 \\, d\\xi_s\\, d\\xi_T}}\\,,\n$$\n该误差通过每维使用 $\\,9\\,$ 个点的二维 Gauss-Legendre 求积进行近似。此外，还需计算指定测试案例的绝对误差。\n\n实现一个 Python 程序，该程序：\n- 基于 $\\,(\\xi_s,\\xi_T)\\,$ 中一个映射到 $\\,s\\,$ 和 $\\,T\\,$ 的 $\\,9 \\times 9\\,$ Gauss-Legendre 配置网格，构建总阶数为 $\\,2\\,$ 的 PCE 代理模型 $\\,p_{\\text{PCE}}(s,T)\\,$。\n- 对每个测试案例，评估高保真压力 $\\,p_{\\text{true}}(s,T)\\,$ 和代理模型 $\\,p_{\\text{PCE}}(s,T)\\,$，并报告绝对误差。\n- 使用 $\\,9 \\times 9\\,$ Gauss-Legendre 求积计算全局相对 $\\,L^2\\,$ 误差 $\\,\\mathcal{E}_{\\text{rel}}\\,$。\n- 所有压力必须以兆帕（MPa）表示，误差也以兆帕（MPa）报告。相对 $\\,L^2\\,$ 误差必须以小数形式报告。\n\n使用以下输入测试套件，每个输入以 $\\, (s,T)\\,$ 的形式给出：\n- 案例 1: $\\, (0.0,\\, 298)\\,$。\n- 案例 2: $\\, (0.5,\\, 298)\\,$。\n- 案例 3: $\\, (1.0,\\, 273)\\,$。\n- 案例 4: $\\, (1.0,\\, 333)\\,$。\n- 案例 5: $\\, (0.2,\\, 333)\\,$。\n- 案例 6: $\\, (0.8,\\, 283)\\,$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须包含 $\\,7\\,$ 个浮点数：前 $\\,6\\,$ 个是按给定顺序排列的测试套件的绝对误差（单位为 MPa），最后一个元素是全局相对 $\\,L^2\\,$ 误差 $\\,\\mathcal{E}_{\\text{rel}}\\,$。例如，必须生成形如 $\\, [e_1,e_2,e_3,e_4,e_5,e_6,E_{\\text{rel}}]\\,$ 的输出格式，其中每个 $\\,e_k\\,$ 是以 MPa 为单位的绝对误差，而 $\\,E_{\\text{rel}}\\,$ 是一个小数。",
            "solution": "该问题在科学和数学上是适定的，提供了一套完整且一致的方程、参数和程序，用于构建电池堆叠压力的代理模型并随后评估其准确性。我们将通过以下步骤进行求解：首先详细介绍高保真物理模型，然后构建多项式混沌展开（PCE）代理模型，最后量化该代理模型相对于高保真参考模型的准确性。\n\n### 1. 高保真物理模型\n\n贯穿厚度方向压力 $p_{\\text{true}}(s,T)$ 的参考模型或“真实”模型，基于受约束复合材料的线性热弹性原理。假设压力与平均应力成正比，根据 Hooke 定律，平均应力是有效模量与有效应变的乘积。该模型包含了随温度变化的材料属性以及作为荷电状态 $s$ 和温度 $T$ 函数的非线性耦合膨胀行为。\n\n关键组成部分如下：\n\n- **随温度变化的平面应变模量, $E_{\\text{ps}}(T)$**：有效杨氏模量 $E(T)$ 假设会随温度升高而降低，这种现象称为模量软化，在电池的聚合物基组件中很常见。平面应变模量 $E_{\\text{ps}}(T)$ 则考虑了层压电堆中的横向约束。\n$$\nE(T) = \\frac{E_0}{\\,1 + b\\,(T - T_{\\text{ref}})\\,}, \\quad E_{\\text{ps}}(T) = \\frac{E(T)}{\\,1 - \\nu^2\\,}\n$$\n给定的常数包括参考模量 $E_0 = 4000\\,\\text{MPa}$，软化系数 $b = 0.015\\,\\text{K}^{-1}$，参考温度 $T_{\\text{ref}} = 298\\,\\text{K}$，以及泊松比 $\\nu = 0.30$。\n\n- **有效膨胀应变, $\\varepsilon_{\\text{eff}}(s,T)$**：该项捕捉了由锂嵌入（$s$ 的函数）和热膨胀（$T$ 的函数）引起的应变。所提供的模型是一个非线性的耦合函数，包括对 $s$ 的二次依赖项和两个热机械耦合项。\n$$\n\\varepsilon_{\\text{eff}}(s,T) = a_1 s + a_2 s^2 + a_T s^2 \\left(\\frac{T - T_{\\text{ref}}}{T_{\\text{ref}}}\\right) + a_c\\, s(1-s)\\, \\tanh\\!\\left(\\frac{T - T_{\\text{ref}}}{\\Delta T}\\right)\n$$\n经验系数为 $a_1 = 0.015$, $a_2 = 0.006$, $a_T = 0.004$, $a_c = 0.003$ 和 $\\Delta T = 50\\,\\text{K}$。\n\n- **交叉耦合放大因子, $\\chi(s,T)$**：该因子模拟了一种次级耦合效应，即在较高的荷电状态和温度下，应力响应会被放大。\n$$\n\\chi(s,T) = 1 + \\delta\\, s \\left(\\frac{T - T_{\\text{ref}}}{T_{\\text{ref}}}\\right), \\quad \\text{with } \\delta = 0.2\n$$\n\n- **高保真压力, $p_{\\text{true}}(s,T)$**：最终压力是这些分量的乘积，再乘以几何约束因子 $g=0.08$ 进行缩放。\n$$\np_{\\text{true}}(s,T) = g \\, E_{\\text{ps}}(T)\\, \\varepsilon_{\\text{eff}}(s,T)\\, \\chi(s,T)\n$$\n压力的单位由 $E_0$ 决定，其单位为兆帕（$\\text{MPa}$）。\n\n### 2. 多项式混沌展开（PCE）代理模型\n\n目标是创建一个低阶计算代理模型 $p_{\\text{PCE}}(s,T)$，在其操作域上近似 $p_{\\text{true}}(s,T)$。PCE 将一个函数表示为其随机输入的正交多项式基上的谱展开。\n\n- **规范变量映射**：物理输入 $s \\in [0, 1]$ 和 $T \\in [T_{\\min}, T_{\\max}] = [273\\,\\text{K}, 333\\,\\text{K}]$ 被映射到区间 $[-1, 1]$ 上的独立规范变量 $\\xi_s$ 和 $\\xi_T$，Legendre 多项式在该区间上是正交的。\n$$\n\\xi_s = 2s - 1\n$$\n$$\n\\xi_T = \\frac{2T - (T_{\\min} + T_{\\max})}{T_{\\max} - T_{\\min}} = \\frac{2T - (273 + 333)}{333 - 273} = \\frac{T - 303}{30}\n$$\n\n- **基多项式**：由于输入被假定为均匀分布，合适的正交多项式基是 Legendre 多项式。我们使用前三个多项式：\n$$\nL_0(x) = 1, \\quad L_1(x) = x, \\quad L_2(x) = \\frac{1}{2}(3x^2-1)\n$$\n\n- **代理模型构建**：使用每个变量中最高阶数为 2 的多项式构成张量积基。这会产生 $3 \\times 3 = 9$ 个基函数, $\\Psi_{ij}(\\xi_s, \\xi_T) = L_i(\\xi_s)L_j(\\xi_T)$。代理模型是这些基函数的线性组合：\n$$\np_{\\text{PCE}}(s,T) = \\sum_{i=0}^{2} \\sum_{j=0}^{2} c_{ij}\\, L_i(\\xi_s(s))\\, L_j(\\xi_T(T))\n$$\n必须确定系数 $\\{c_{ij}\\}$。\n\n### 3. PCE 系数的确定\n\n问题指定了在配置网格上使用最小二乘回归的非侵入式方法。这包括在一组点上评估高保真模型，并将 PCE 系数拟合到这些结果上。\n\n- **配置网格**：使用一个 $N \\times N = 9 \\times 9 = 81$ 个点的张量积网格。这些点是 $[-1, 1]$ 上 9 点 Gauss-Legendre 求积法则的节点。设一维节点为 $\\{\\xi_k\\}_{k=1}^9$。规范空间中的二维网格是 $\\{(\\xi_{s,k}, \\xi_{T,l}) = (\\xi_k, \\xi_l)\\}_{k,l=1}^9$。这 81 个点被映射到它们的物理坐标 $(s,T)$。\n\n- **最小二乘回归**：系数向量 $\\mathbf{c}$（包含 9 个未知系数 $c_{ij}$）通过以最小二乘方式求解以下超定线性系统来找到：\n$$\n\\mathbf{\\Psi} \\mathbf{c} = \\mathbf{y}\n$$\n此处，$\\mathbf{y}$ 是一个 $81 \\times 1$ 的向量，包含高保真模型 $p_{\\text{true}}$ 在 81 个网格点上的评价值。$\\mathbf{\\Psi}$ 是一个 $81 \\times 9$ 的设计矩阵（一个类范德蒙矩阵），其中每一行对应一个网格点，每一列对应一个基函数。该矩阵的一个条目是 $\\Psi_{(k,l),(i,j)} = L_i(\\xi_{s,k})L_j(\\xi_{T,l})$。最小二乘解最小化欧几里得范数 $\\|\\mathbf{\\Psi} \\mathbf{c} - \\mathbf{y}\\|_2$，由 $\\mathbf{c} = (\\mathbf{\\Psi}^T\\mathbf{\\Psi})^{-1}\\mathbf{\\Psi}^T\\mathbf{y}$ 给出。\n\n### 4. 准确性评估\n\n所得代理模型 $p_{\\text{PCE}}$ 的准确性通过两种方式进行评估：\n\n- **逐点绝对误差**：对于 6 个测试案例中的每一个 $(s_k, T_k)$，绝对误差计算如下：\n$$\ne_k = |p_{\\text{PCE}}(s_k, T_k) - p_{\\text{true}}(s_k, T_k)|\n$$\n\n- **全局相对 $L^2$ 误差**：该度量衡量整个输入域上的平均误差，并由输入的（均匀）概率分布加权。积分在规范空间 $[-1, 1] \\times [-1, 1]$ 上计算。\n$$\n\\mathcal{E}_{\\text{rel}} = \\sqrt{\\frac{\\int_{-1}^{1}\\int_{-1}^{1} \\left(p_{\\text{PCE}} - p_{\\text{true}}\\right)^2 \\, d\\xi_s\\, d\\xi_T}{\\int_{-1}^{1}\\int_{-1}^{1} \\left(p_{\\text{true}}\\right)^2 \\, d\\xi_s\\, d\\xi_T}}\n$$\n分子和分母中的两个积分都使用 $9 \\times 9$ 张量积 Gauss-Legendre 求积法则进行数值近似。设 $\\{\\xi_k, w_k\\}_{k=1}^9$ 为一维 Gauss-Legendre 节点和权重。函数 $f(\\xi_s, \\xi_T)$ 的积分近似为：\n$$\n\\int_{-1}^{1}\\int_{-1}^{1} f(\\xi_s, \\xi_T) \\, d\\xi_s\\, d\\xi_T \\approx \\sum_{k=1}^{9}\\sum_{l=1}^{9} f(\\xi_k, \\xi_l)\\,w_k w_l\n$$\n将此过程应用于被积函数 $(p_{\\text{PCE}} - p_{\\text{true}})^2$ 和 $(p_{\\text{true}})^2$（在求积节点上求值），以计算最终的相对误差 $\\mathcal{E}_{\\text{rel}}$。\n\n下面的实现将系统地执行这些步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not needed, numpy has all required functions.\n\ndef solve():\n    \"\"\"\n    Constructs and validates a PCE surrogate for battery stack athermal pressure.\n    \"\"\"\n    # --- 1. Define Constants and High-Fidelity Model ---\n\n    # Physical and model constants\n    E0 = 4000.0       # Reference modulus [MPa]\n    b = 0.015         # Modulus softening coefficient [K^-1]\n    T_ref = 298.0     # Reference temperature [K]\n    nu = 0.30         # Poisson's ratio\n    a1 = 0.015        # Strain coefficient\n    a2 = 0.006        # Strain coefficient\n    aT = 0.004        # Strain coefficient\n    ac = 0.003        # Strain coefficient\n    DeltaT = 50.0     # Temperature scale for tanh [K]\n    delta = 0.2       # Amplification factor coefficient\n    g = 0.08          # Geometric constraint factor\n\n    # Input domain boundaries\n    T_min = 273.0     # Minimum temperature [K]\n    T_max = 333.0     # Maximum temperature [K]\n    s_min = 0.0\n    s_max = 1.0\n\n    def p_true(s, T):\n        \"\"\"High-fidelity reference pressure model in MPa.\"\"\"\n        # Temperature-dependent modulus\n        E_T = E0 / (1.0 + b * (T - T_ref))\n        E_ps_T = E_T / (1.0 - nu**2)\n        \n        # Effective swelling strain\n        T_term1 = aT * s**2 * (T - T_ref) / T_ref\n        T_term2 = ac * s * (1 - s) * np.tanh((T - T_ref) / DeltaT)\n        eps_eff = a1 * s + a2 * s**2 + T_term1 + T_term2\n\n        # Cross-coupled amplification factor\n        chi = 1.0 + delta * s * (T - T_ref) / T_ref\n        \n        # High-fidelity pressure\n        pressure = g * E_ps_T * eps_eff * chi\n        return pressure\n\n    # --- 2. Set up PCE Framework ---\n    \n    # PCE settings\n    PCE_DEG = 2\n    N_TERMS_1D = PCE_DEG + 1\n    N_FIT = 9 # Number of points for least-squares fitting grid per dimension\n    N_QUAD = 9 # Number of points for quadrature grid per dimension\n\n    # Canonical variable mappings\n    def s_to_xi_s(s):\n        return 2.0 * (s - s_min) / (s_max - s_min) - 1.0\n\n    def T_to_xi_T(T):\n        return 2.0 * (T - T_min) / (T_max - T_min) - 1.0\n\n    def xi_s_to_s(xi_s):\n        return (xi_s + 1.0) / 2.0 * (s_max - s_min) + s_min\n\n    def T_from_xi_T(xi_T):\n        return (xi_T + 1.0) / 2.0 * (T_max - T_min) + T_min\n\n    # Legendre polynomial basis functions\n    L = [\n        lambda x: np.ones_like(x),\n        lambda x: x,\n        lambda x: 0.5 * (3 * x**2 - 1)\n    ]\n\n    # --- 3. Determine PCE Coefficients via Least-Squares Regression ---\n    \n    # Generate collocation grid for fitting\n    xi_s_fit_1d, _ = np.polynomial.legendre.leggauss(N_FIT)\n    xi_T_fit_1d, _ = np.polynomial.legendre.leggauss(N_FIT)\n    xi_s_fit_2d, xi_T_fit_2d = np.meshgrid(xi_s_fit_1d, xi_T_fit_1d)\n    \n    # Map grid to physical domain\n    s_fit_grid = xi_s_to_s(xi_s_fit_2d.flatten())\n    T_fit_grid = T_from_xi_T(xi_T_fit_2d.flatten())\n\n    # Evaluate true model on the grid\n    y_true = p_true(s_fit_grid, T_fit_grid)\n\n    # Construct the Vandermonde-like matrix (design matrix)\n    num_points_fit = N_FIT * N_FIT\n    num_basis_funcs = N_TERMS_1D * N_TERMS_1D\n    psi_matrix = np.zeros((num_points_fit, num_basis_funcs))\n    \n    xi_s_flat = xi_s_fit_2d.flatten()\n    xi_T_flat = xi_T_fit_2d.flatten()\n\n    basis_idx = 0\n    for i in range(N_TERMS_1D):\n        for j in range(N_TERMS_1D):\n            psi_matrix[:, basis_idx] = L[i](xi_s_flat) * L[j](xi_T_flat)\n            basis_idx += 1\n\n    # Solve for coefficients using least squares\n    coeffs, _, _, _ = np.linalg.lstsq(psi_matrix, y_true, rcond=None)\n\n    def p_pce(s, T):\n        \"\"\"Evaluates the PCE surrogate model.\"\"\"\n        xi_s = s_to_xi_s(s)\n        xi_T = T_to_xi_T(T)\n        \n        p_val = 0.0\n        basis_idx = 0\n        for i in range(N_TERMS_1D):\n            for j in range(N_TERMS_1D):\n                p_val += coeffs[basis_idx] * L[i](xi_s) * L[j](xi_T)\n                basis_idx += 1\n        return p_val\n    \n    # --- 4. Evaluate Accuracy ---\n\n    # Test suite\n    test_cases = [\n        (0.0, 298.0), (0.5, 298.0), (1.0, 273.0),\n        (1.0, 333.0), (0.2, 333.0), (0.8, 283.0)\n    ]\n    \n    absolute_errors = []\n    for s_test, T_test in test_cases:\n        p_val_true = p_true(s_test, T_test)\n        p_val_pce = p_pce(s_test, T_test)\n        absolute_errors.append(abs(p_val_pce - p_val_true))\n        \n    # Calculate global relative L2 error using Gauss-Legendre quadrature\n    nodes_1d, weights_1d = np.polynomial.legendre.leggauss(N_QUAD)\n    nodes_s_2d, nodes_T_2d = np.meshgrid(nodes_1d, nodes_1d)\n    weights_s_2d, weights_T_2d = np.meshgrid(weights_1d, weights_1d)\n    \n    s_quad_grid = xi_s_to_s(nodes_s_2d)\n    T_quad_grid = T_from_xi_T(nodes_T_2d)\n    \n    p_true_on_quad_grid = p_true(s_quad_grid, T_quad_grid)\n    p_pce_on_quad_grid = p_pce(s_quad_grid, T_quad_grid)\n    \n    # Numerator integral: integral of (p_pce - p_true)^2\n    integrand_num = (p_pce_on_quad_grid - p_true_on_quad_grid)**2\n    integral_num = np.sum(integrand_num * weights_s_2d * weights_T_2d)\n    \n    # Denominator integral: integral of (p_true)^2\n    integrand_den = p_true_on_quad_grid**2\n    integral_den = np.sum(integrand_den * weights_s_2d * weights_T_2d)\n\n    # Avoid division by zero if true model is identically zero (unlikely here)\n    if integral_den == 0:\n        rel_l2_error = 0.0 if integral_num == 0 else np.inf\n    else:\n        rel_l2_error = np.sqrt(integral_num / integral_den)\n\n    # --- 5. Final Output ---\n    results = absolute_errors + [rel_l2_error]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}