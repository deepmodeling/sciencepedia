{
    "hands_on_practices": [
        {
            "introduction": "This first practice lays the groundwork for simulating the mechanical behavior of battery components. You will translate the fundamental physics of a constrained electrode into a one-dimensional computational model, focusing on the correct implementation of boundary conditions. By representing substrate bonding as a Dirichlet constraint and external stack pressure as a Neumann traction, you will build a solver that accurately predicts deformation, a foundational skill for any mechanical simulation of layered systems .",
            "id": "3910412",
            "problem": "Consider a one-dimensional laminate model representing the through-thickness mechanics of a composite electrode bonded to a rigid substrate in a lithium-ion battery stack. The coordinate is denoted by $z \\in [0,h]$, where $z=0$ is the substrate interface and $z=h$ is the free top surface. The laminate consists of $N$ layers stacked in the $z$-direction, each with thickness $h_i$, elastic modulus $E_i$, and a swelling eigenstrain distribution $\\varepsilon^{\\mathrm{sw}}_i(z)$ due to electrochemical insertion. Assume small-strain, linear elasticity, and quasi-static equilibrium with no body forces. Use the following fundamental base:\n\n- Kinematics: the small-strain definition $\\varepsilon(z) = \\dfrac{du}{dz}$, where $u(z)$ is the out-of-plane displacement.\n- Constitutive relation (linear elastic with eigenstrain): $\\sigma(z) = E(z)\\left(\\varepsilon(z) - \\varepsilon^{\\mathrm{sw}}(z)\\right)$, where $\\sigma(z)$ is the through-thickness normal stress and $E(z)$ is piecewise constant over each layer.\n- Balance of linear momentum with no body forces: $\\dfrac{d\\sigma}{dz} = 0$.\n- Boundary conditions implementing external stack pressure and substrate bonding:\n  - Dirichlet (essential) constraint at the bonded substrate: $u(0) = 0$.\n  - Neumann (natural) traction at the free top surface representing external stack pressure: $\\sigma(h) = -p_{\\mathrm{ext}}$, with compressive pressure taken as positive $p_{\\mathrm{ext}} > 0$, and the traction sign convention set so that a compressive external stack pressure yields a negative stress at the top surface.\n\nYour task is to implement these boundary conditions in a solver that computes the displacement field $u(z)$ and verifies the traction boundary condition in a laminate model. The solver must:\n\n1. Start from the above fundamental base, enforce the Dirichlet condition $u(0)=0$, and the Neumann traction $\\sigma(h) = -p_{\\mathrm{ext}}$.\n2. Compute the top-surface displacement $u(h)$ in $\\mathrm{m}$ for each test case by a logically derived algorithm based on the governing equations. The numerical evaluation must be performed using a discretization or quadrature over the laminate layers; do not hard-code closed-form shortcuts.\n3. Verify the Neumann traction boundary condition by computing the stress at the top surface from the constitutive relation and reporting whether it matches the applied traction to within a specified tolerance.\n\nUse only the International System of Units (SI). Express $u(h)$ in $\\mathrm{m}$ and report the verification as a boolean. Round $u(h)$ to $10^{-9}\\,\\mathrm{m}$ (nine decimal places). The stress verification should use an absolute tolerance of $10^{-12}\\,\\mathrm{Pa}$.\n\nTest Suite:\nImplement the following $4$ test cases, each defined by its layers and external stack pressure $p_{\\mathrm{ext}}$:\n\n- Case $1$ (two-layer laminate, uniform swelling in the electrode):\n  - Layer $1$ (electrode): thickness $h_1 = 6.0\\times 10^{-5}\\,\\mathrm{m}$, modulus $E_1 = 1.2\\times 10^{10}\\,\\mathrm{Pa}$, swelling eigenstrain $\\varepsilon^{\\mathrm{sw}}_1(z) = 1.5\\times 10^{-2}$ (uniform).\n  - Layer $2$ (current collector): thickness $h_2 = 1.5\\times 10^{-5}\\,\\mathrm{m}$, modulus $E_2 = 7.0\\times 10^{10}\\,\\mathrm{Pa}$, swelling eigenstrain $\\varepsilon^{\\mathrm{sw}}_2(z) = 0.0$ (uniform).\n  - External stack pressure $p_{\\mathrm{ext}} = 5.0\\times 10^{4}\\,\\mathrm{Pa}$.\n\n- Case $2$ (single layer with linearly varying swelling):\n  - Layer $1$: thickness $h_1 = 8.0\\times 10^{-5}\\,\\mathrm{m}$, modulus $E_1 = 1.0\\times 10^{10}\\,\\mathrm{Pa}$, swelling eigenstrain $\\varepsilon^{\\mathrm{sw}}_1(z) = \\varepsilon_0\\left(1+\\alpha\\,\\dfrac{z}{h_1}\\right)$ with $\\varepsilon_0 = 1.0\\times 10^{-2}$ and $\\alpha = 0.5$.\n  - External stack pressure $p_{\\mathrm{ext}} = 2.0\\times 10^{4}\\,\\mathrm{Pa}$.\n\n- Case $3$ (three-layer laminate with compliant separator):\n  - Layer $1$ (electrode): thickness $h_1 = 8.0\\times 10^{-5}\\,\\mathrm{m}$, modulus $E_1 = 1.2\\times 10^{10}\\,\\mathrm{Pa}$, swelling eigenstrain $\\varepsilon^{\\mathrm{sw}}_1(z) = 1.5\\times 10^{-2}$ (uniform).\n  - Layer $2$ (separator): thickness $h_2 = 2.0\\times 10^{-5}\\,\\mathrm{m}$, modulus $E_2 = 5.0\\times 10^{8}\\,\\mathrm{Pa}$, swelling eigenstrain $\\varepsilon^{\\mathrm{sw}}_2(z) = 0.0$ (uniform).\n  - Layer $3$ (current collector): thickness $h_3 = 1.5\\times 10^{-5}\\,\\mathrm{m}$, modulus $E_3 = 1.0\\times 10^{11}\\,\\mathrm{Pa}$, swelling eigenstrain $\\varepsilon^{\\mathrm{sw}}_3(z) = 0.0$ (uniform).\n  - External stack pressure $p_{\\mathrm{ext}} = 1.0\\times 10^{5}\\,\\mathrm{Pa}$.\n\n- Case $4$ (edge case with zero external pressure and non-uniform swelling):\n  - Layer $1$: thickness $h_1 = 5.0\\times 10^{-5}\\,\\mathrm{m}$, modulus $E_1 = 1.0\\times 10^{10}\\,\\mathrm{Pa}$, swelling eigenstrain $\\varepsilon^{\\mathrm{sw}}_1(z) = \\varepsilon_0\\left(1-0.8\\,\\dfrac{z}{h_1}\\right)$ with $\\varepsilon_0 = 2.0\\times 10^{-2}$.\n  - External stack pressure $p_{\\mathrm{ext}} = 0.0\\,\\mathrm{Pa}$.\n\nOutput Specification:\nFor each case, your program must compute:\n- The top-surface displacement $u(h)$ in $\\mathrm{m}$, rounded to $10^{-9}\\,\\mathrm{m}$.\n- A boolean indicating whether the computed top-surface stress equals $-p_{\\mathrm{ext}}$ within $10^{-12}\\,\\mathrm{Pa}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[ \\text{result}_1,\\text{result}_2,\\ldots \\right]$), with entries ordered as $[u(h)_1,\\text{flag}_1,u(h)_2,\\text{flag}_2,u(h)_3,\\text{flag}_3,u(h)_4,\\text{flag}_4]$ where the subscript denotes the case index.",
            "solution": "The supplied problem is assessed to be valid. It is scientifically grounded in the principles of one-dimensional linear elasticity, is well-posed with a complete set of governing equations and boundary conditions, and is expressed in objective, formal language. The provided parameters for the test cases are physically reasonable for battery electrode materials. I will now proceed with the derivation of the solution.\n\nThe problem describes the through-thickness mechanics of a laminate structure using a one-dimensional model. We are given the fundamental equations governing the system's behavior.\n\nThe balance of linear momentum, in the absence of body forces, is given by:\n$$\n\\frac{d\\sigma}{dz} = 0\n$$\nwhere $\\sigma(z)$ is the through-thickness normal stress and $z$ is the coordinate. Integrating this equation reveals that the stress $\\sigma$ must be constant throughout the entire thickness of the laminate, from $z=0$ to $z=h$:\n$$\n\\sigma(z) = C\n$$\nwhere $C$ is a constant of integration. This constant can be determined using the Neumann boundary condition specified at the free top surface ($z=h$). The problem states that the traction at this surface is equal to the negative of the external stack pressure, $p_{\\mathrm{ext}}$:\n$$\n\\sigma(h) = -p_{\\mathrm{ext}}\n$$\nGiven that the stress is constant, its value at any point $z$ must be equal to its value at $z=h$. Therefore, the stress is determined everywhere in the laminate:\n$$\n\\sigma(z) = -p_{\\mathrm{ext}} \\quad \\forall z \\in [0, h]\n$$\n\nNext, we use the constitutive relation, which connects stress $\\sigma(z)$ to the total strain $\\varepsilon(z)$ and the swelling eigenstrain $\\varepsilon^{\\mathrm{sw}}(z)$:\n$$\n\\sigma(z) = E(z)\\left(\\varepsilon(z) - \\varepsilon^{\\mathrm{sw}}(z)\\right)\n$$\nHere, $E(z)$ is the Young's modulus, which is piecewise constant for each layer in the laminate. We can substitute the expression for the constant stress into this relation and solve for the total strain $\\varepsilon(z)$:\n$$\n-p_{\\mathrm{ext}} = E(z)\\left(\\varepsilon(z) - \\varepsilon^{\\mathrm{sw}}(z)\\right)\n$$\n$$\n\\varepsilon(z) = \\varepsilon^{\\mathrm{sw}}(z) - \\frac{p_{\\mathrm{ext}}}{E(z)}\n$$\n\nThe kinematic relation defines the total strain in terms of the displacement field $u(z)$:\n$$\n\\varepsilon(z) = \\frac{du}{dz}\n$$\nTo find the displacement $u(z)$, we integrate the strain with respect to the coordinate $z$. We integrate from the substrate at $z=0$ to an arbitrary position $z$:\n$$\nu(z) - u(0) = \\int_0^z \\varepsilon(z') dz'\n$$\nThe problem specifies a Dirichlet boundary condition at the substrate interface, $u(0)=0$, because it is bonded to a rigid substrate. Applying this condition simplifies the expression for displacement:\n$$\nu(z) = \\int_0^z \\varepsilon(z') dz' = \\int_0^z \\left(\\varepsilon^{\\mathrm{sw}}(z') - \\frac{p_{\\mathrm{ext}}}{E(z')}\\right) dz'\n$$\n\nThe primary quantity to compute is the displacement at the top surface, $u(h)$. This is obtained by setting the upper limit of the integral to the total thickness $h$:\n$$\nu(h) = \\int_0^h \\left(\\varepsilon^{\\mathrm{sw}}(z') - \\frac{p_{\\mathrm{ext}}}{E(z')}\\right) dz'\n$$\nSince the laminate consists of $N$ discrete layers, the properties $E(z)$ and $\\varepsilon^{\\mathrm{sw}}(z)$ are piecewise functions. The integral must be evaluated as a sum of integrals over each layer. Let layer $i$ (where $i=1, \\dots, N$) have thickness $h_i$, modulus $E_i$, and swelling strain function $\\varepsilon^{\\mathrm{sw}}_i(z)$. The layers are stacked such that layer $i$ occupies the domain $z \\in [z_{i-1}, z_i]$, where $z_0=0$ and $z_i = \\sum_{j=1}^i h_j$. The total thickness is $h=z_N$. The expression for $u(h)$ becomes:\n$$\nu(h) = \\sum_{i=1}^N \\int_{z_{i-1}}^{z_i} \\left(\\varepsilon^{\\mathrm{sw}}_i(z') - \\frac{p_{\\mathrm{ext}}}{E_i}\\right) dz'\n$$\nThis can be split into two parts:\n$$\nu(h) = \\sum_{i=1}^N \\left( \\int_{z_{i-1}}^{z_i} \\varepsilon^{\\mathrm{sw}}_i(z') dz' \\right) - \\sum_{i=1}^N \\left( \\int_{z_{i-1}}^{z_i} \\frac{p_{\\mathrm{ext}}}{E_i} dz' \\right)\n$$\nThe second term is straightforward to integrate as $p_{\\mathrm{ext}}$ and $E_i$ are constant within each layer:\n$$\n\\int_{z_{i-1}}^{z_i} \\frac{p_{\\mathrm{ext}}}{E_i} dz' = \\frac{p_{\\mathrm{ext}}}{E_i} (z_i - z_{i-1}) = \\frac{p_{\\mathrm{ext}}h_i}{E_i}\n$$\nThus, the final expression for the top-surface displacement is:\n$$\nu(h) = \\sum_{i=1}^N \\left( \\int_{z_{i-1}}^{z_i} \\varepsilon^{\\mathrm{sw}}_i(z') dz' - \\frac{p_{\\mathrm{ext}}h_i}{E_i} \\right)\n$$\nTo satisfy the problem's requirement to use a numerical quadrature, the integral of the swelling strain, $\\int_{z_{i-1}}^{z_i} \\varepsilon^{\\mathrm{sw}}_i(z') dz'$, will be computed numerically for each layer using a standard routine, such as `scipy.integrate.quad`. This approach builds the solution by iterating through the layers, consistent with the instruction to avoid single hard-coded closed-form shortcuts.\n\nFor the verification task, we must compute the stress at the top surface, $\\sigma(h)$, and check if it matches $-p_{\\mathrm{ext}}$. The stress is computed from its definition in the constitutive relation:\n$$\n\\sigma(h) = E_N \\left( \\varepsilon(h) - \\varepsilon^{\\mathrm{sw}}_N(h) \\right)\n$$\nwhere $E_N$ and $\\varepsilon^{\\mathrm{sw}}_N(h)$ are the modulus and swelling eigenstrain of the top-most layer ($i=N$) evaluated at $z=h$. The total strain at the top surface, $\\varepsilon(h)$, is given by our derived expression for strain evaluated at $z=h$:\n$$\n\\varepsilon(h) = \\varepsilon^{\\mathrm{sw}}_N(h) - \\frac{p_{\\mathrm{ext}}}{E_N}\n$$\nSubstituting this into the constitutive relation gives:\n$$\n\\sigma(h) = E_N \\left( \\left( \\varepsilon^{\\mathrm{sw}}_N(h) - \\frac{p_{\\mathrm{ext}}}{E_N} \\right) - \\varepsilon^{\\mathrm{sw}}_N(h) \\right) = E_N \\left( -\\frac{p_{\\mathrm{ext}}}{E_N} \\right) = -p_{\\mathrm{ext}}\n$$\nThis result holds analytically. The numerical verification will thus check the self-consistency of the implementation, ensuring $|\\sigma_{\\text{computed}}(h) - (-p_{\\text{ext}})| < 10^{-12}\\,\\mathrm{Pa}$. The value for $\\sigma_{\\text{computed}}(h)$ will be calculated based on the derived relationships and will be subject to floating-point arithmetic precision.\n\nThe algorithm to be implemented is as follows:\n1. For each test case, define the properties of each layer (thickness $h_i$, modulus $E_i$, swelling function $\\varepsilon^{\\mathrm{sw}}_i(z)$) and the external pressure $p_{\\mathrm{ext}}$.\n2. Initialize total displacement $u(h) = 0$ and current coordinate $z_{\\text{current}} = 0$.\n3. Iterate through the layers of the laminate:\n    a. Determine the start and end coordinates of the current layer, $z_{\\text{start}}$ and $z_{\\text{end}}$.\n    b. Numerically compute the integral of the swelling strain over the layer's domain.\n    c. Compute the displacement contribution from the external pressure term, $-p_{\\mathrm{ext}}h_i/E_i$.\n    d. Add the sum of these two contributions to the total displacement $u(h)$.\n    e. Update $z_{\\text{current}}$ to the end of the current layer.\n4. After iterating through all layers, round the final $u(h)$ to $9$ decimal places.\n5. For verification, calculate $\\sigma(h)$ using the constitutive relation and the derived expression for $\\varepsilon(h)$. Check if its absolute difference with $-p_{\\mathrm{ext}}$ is within the specified tolerance of $10^{-12}\\,\\mathrm{Pa}$.\n6. Collate the results from all test cases into the specified output format.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main solver function that defines test cases, calculates results,\n    and prints them in the specified format.\n    \"\"\"\n\n    def calculate_solution(layers, p_ext):\n        \"\"\"\n        Calculates the top-surface displacement and verifies the Neumann\n        boundary condition for a given laminate structure and pressure.\n\n        Args:\n            layers (list): A list of dictionaries, where each dictionary\n                           describes a layer's properties: 'h' (thickness),\n                           'E' (modulus), and 'eps_sw_func' (swelling\n                           strain as a function of z).\n            p_ext (float): The external stack pressure in Pa.\n\n        Returns:\n            tuple: A tuple containing:\n                   - The top-surface displacement u(h) in m, rounded.\n                   - A boolean for the verification of the boundary condition.\n        \"\"\"\n        total_displacement = 0.0\n        current_z = 0.0\n\n        for layer in layers:\n            h_i = layer['h']\n            E_i = layer['E']\n            eps_sw_func = layer['eps_sw_func']\n            \n            z_start = current_z\n            z_end = current_z + h_i\n\n            # Numerically integrate the swelling strain over the layer using quadrature.\n            integral_swelling, _ = quad(eps_sw_func, z_start, z_end)\n            \n            # Analytically integrate the pressure term.\n            integral_pressure_term = (p_ext / E_i) * h_i\n\n            # Add this layer's contribution to the total displacement.\n            delta_u = integral_swelling - integral_pressure_term\n            total_displacement += delta_u\n            \n            current_z = z_end\n        \n        # Total thickness h is the final z coordinate.\n        h_total = current_z\n        u_h = total_displacement\n\n        # Verification of the Neumann boundary condition at z=h.\n        top_layer = layers[-1]\n        E_top = top_layer['E']\n        eps_sw_at_h = top_layer['eps_sw_func'](h_total)\n\n        # Calculate stress at z=h from the constitutive relation,\n        # using the derived expression for total strain at h.\n        # sigma(h) = E_top * (epsilon(h) - eps_sw(h))\n        # epsilon(h) = eps_sw(h) - p_ext / E_top\n        # Thus, sigma(h) = -p_ext\n        sigma_h_computed = E_top * ((eps_sw_at_h - p_ext / E_top) - eps_sw_at_h)\n        \n        # Check if the computed stress matches the applied traction -p_ext\n        # within the specified tolerance.\n        stress_tolerance = 1.0e-12\n        verification = abs(sigma_h_computed - (-p_ext)) < stress_tolerance\n        \n        # Round final displacement to 9 decimal places as specified.\n        u_h_rounded = round(u_h, 9)\n\n        return u_h_rounded, verification\n\n    # --- Test Case Definitions ---\n\n    # Case 1: Two-layer laminate, uniform swelling\n    case1_layers = [\n        {'h': 6.0e-5, 'E': 1.2e10, 'eps_sw_func': lambda z: 1.5e-2},\n        {'h': 1.5e-5, 'E': 7.0e10, 'eps_sw_func': lambda z: 0.0},\n    ]\n    case1_p_ext = 5.0e4\n\n    # Case 2: Single layer, linear swelling\n    case2_h1 = 8.0e-5\n    case2_layers = [\n        {'h': case2_h1, 'E': 1.0e10, 'eps_sw_func': lambda z, h1=case2_h1: 1.0e-2 * (1 + 0.5 * z / h1)},\n    ]\n    case2_p_ext = 2.0e4\n\n    # Case 3: Three-layer laminate\n    case3_layers = [\n        {'h': 8.0e-5, 'E': 1.2e10, 'eps_sw_func': lambda z: 1.5e-2},\n        {'h': 2.0e-5, 'E': 5.0e8,  'eps_sw_func': lambda z: 0.0},\n        {'h': 1.5e-5, 'E': 1.0e11, 'eps_sw_func': lambda z: 0.0},\n    ]\n    case3_p_ext = 1.0e5\n\n    # Case 4: Single layer, zero pressure, non-uniform swelling\n    case4_h1 = 5.0e-5\n    case4_layers = [\n        {'h': case4_h1, 'E': 1.0e10, 'eps_sw_func': lambda z, h1=case4_h1: 2.0e-2 * (1 - 0.8 * z / h1)},\n    ]\n    case4_p_ext = 0.0\n    \n    test_cases = [\n        (case1_layers, case1_p_ext),\n        (case2_layers, case2_p_ext),\n        (case3_layers, case3_p_ext),\n        (case4_layers, case4_p_ext),\n    ]\n\n    results = []\n    for layers, p_ext in test_cases:\n        u_h, is_verified = calculate_solution(layers, p_ext)\n        results.append(f\"{u_h:.9f}\")\n        results.append(str(is_verified))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the fundamentals of mechanical modeling, this practice addresses a real-world engineering design problem. You will explore the critical trade-off between minimizing mechanical stress to enhance durability and maximizing electrode porosity to improve electrochemical performance. By implementing a simplified micromechanics model and constructing a Pareto front, you will learn a powerful technique for navigating competing design objectives, a core skill in automated battery design .",
            "id": "3910461",
            "problem": "Consider a porous, isotropic composite electrode undergoing insertion-induced volumetric expansion in a confining stack. You will derive, formalize, and compute trade-offs between porosity and swelling-induced mechanical stress using a simplified homogenization model, and then construct a Pareto front for competing objectives.\n\nBegin from first principles of linear elasticity and micromechanics:\n\n- The electrode’s solid skeleton is modeled as a linear elastic, homogeneous, isotropic material with Young’s modulus $E_s$ and Poisson’s ratio $\\nu_s$. The bulk modulus is defined as $K_s = \\dfrac{E_s}{3(1 - 2 \\nu_s)}$.\n- Under isotropic swelling with volumetric eigenstrain $\\epsilon^\\star$ in the solid phase, and confinement by a stack of finite bulk stiffness $K_c$ coupled hydrostatically, equilibrium and compatibility imply a load-sharing pressure buildup. Treat the confinement and the porous electrode as two hydrostatic springs in series.\n- For homogenization, use a simplified but scientifically plausible scaling for the porous composite: the effective bulk modulus $K_{\\text{eff}}(\\varepsilon)$ scales with the solid volume fraction $(1 - \\varepsilon)$ via a power-law exponent $m$ motivated by porous solid micromechanics such as Gibson–Ashby scaling. The solid skeleton carries stress that is higher than the composite-average pressure due to reduced load-bearing area; model this stress concentration with an exponent $q \\geq 1$.\n\nYou must derive, justify, and implement the following, without introducing any physically unrealistic assumptions:\n\n1. From linear elasticity and hydrostatic load-sharing between series springs (the confining stack and the porous electrode), derive the swelling-induced hydrostatic pressure $p(\\varepsilon)$ in the composite under eigenstrain $\\epsilon^\\star$; then define the solid-skeleton stress $\\sigma_{\\text{solid}}(\\varepsilon)$ via a stress concentration factor based on the solid volume fraction.\n2. From micromechanics of porous media, write the effective modulus scaling $K_{\\text{eff}}(\\varepsilon)$ as a function of $K_s$, $\\varepsilon$, and $m$. Ensure $K_{\\text{eff}}(\\varepsilon)$ respects the bounds of effective medium theory and remains positive for admissible porosities.\n3. Define a transport objective using porosity: either directly as porosity $\\varepsilon$ (to be maximized) or via effective ionic conductivity $\\kappa_{\\text{eff}}(\\varepsilon)$ using a Bruggeman-type exponent $a$. You must be explicit about which objective you adopt and how it is computed.\n4. Construct a Pareto front over a discrete grid of porosity values by treating this as a bi-objective problem:\n   - Objective $\\mathcal{O}_1$: minimize $\\sigma_{\\text{solid}}(\\varepsilon)$ in Pascals.\n   - Objective $\\mathcal{O}_2$: maximize porosity $\\varepsilon$ (equivalently minimize $-\\varepsilon$; porosity is dimensionless).\n   Use the standard definition of Pareto dominance: a point $A$ dominates point $B$ if $A$ is no worse in all objectives and strictly better in at least one. Identify the set of non-dominated porosity values.\n\nNumerical implementation requirements:\n\n- Use the following discrete porosity grid definition for each test case: uniform grid from $\\varepsilon_{\\min}$ to $\\varepsilon_{\\max}$ with step $\\Delta \\varepsilon$, inclusive of endpoints. Porosity is dimensionless.\n- Treat all moduli in Pascals, eigenstrain $\\epsilon^\\star$ as dimensionless volumetric strain, and porosity $\\varepsilon$ as dimensionless. Express stress in Pascals internally; the final output should contain only porosity values (dimensionless).\n- Rounding: in the final Pareto front list, round each porosity value to three decimal places.\n- No external input is allowed; hard-code the test suite and produce output directly.\n\nTest suite:\n\nProvide results for all of the following parameter sets. For each case, construct the porosity grid and compute the Pareto front as described above. The parameters are:\n\n- Case $1$ (general “happy path”): $E_s = 12 \\times 10^9 \\, \\text{Pa}$, $\\nu_s = 0.30$, $\\beta = 0.08$, $x = 0.60$, $\\epsilon^\\star = \\beta x$, $K_c = 2 \\times 10^9 \\, \\text{Pa}$, $m = 2.0$, $q = 2.0$, adopt transport objective as porosity $\\varepsilon$, porosity grid: $\\varepsilon_{\\min} = 0.05$, $\\varepsilon_{\\max} = 0.60$, $\\Delta \\varepsilon = 0.01$.\n- Case $2$ (high confinement stiffness boundary): $E_s = 35 \\times 10^9 \\, \\text{Pa}$, $\\nu_s = 0.26$, $\\beta = 0.05$, $x = 1.00$, $\\epsilon^\\star = \\beta x$, $K_c = 50 \\times 10^9 \\, \\text{Pa}$, $m = 2.5$, $q = 2.0$, adopt transport objective as porosity $\\varepsilon$, porosity grid: $\\varepsilon_{\\min} = 0.10$, $\\varepsilon_{\\max} = 0.70$, $\\Delta \\varepsilon = 0.02$.\n- Case $3$ (high swelling edge case): $E_s = 70 \\times 10^9 \\, \\text{Pa}$, $\\nu_s = 0.22$, $\\beta = 0.25$, $x = 0.40$, $\\epsilon^\\star = \\beta x$, $K_c = 5 \\times 10^9 \\, \\text{Pa}$, $m = 2.0$, $q = 2.0$, adopt transport objective as porosity $\\varepsilon$, porosity grid: $\\varepsilon_{\\min} = 0.02$, $\\varepsilon_{\\max} = 0.40$, $\\Delta \\varepsilon = 0.01$.\n\nOutput specification:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case’s Pareto front: a list of rounded porosity values (dimensionless). For example, the final line should look like $[\\,[\\ldots],\\,[\\ldots],\\,[\\ldots]\\,]$, and every porosity value inside must be rounded to three decimal places.\n\nExplicitly, your output must be a single Python list literal containing three elements (one per case), each of which is a list of porosity values on the Pareto front rounded to three decimals, with no extra text.",
            "solution": "The user-provided problem has been analyzed and validated.\n\n### Step 1: Extract Givens\n- **Model**: Porous, isotropic composite electrode under confinement.\n- **Physics**: Linear elasticity, micromechanics, hydrostatic load sharing.\n- **Solid Skeleton Properties**: Young’s modulus $E_s$, Poisson’s ratio $\\nu_s$.\n- **Solid Bulk Modulus Definition**: $K_s = \\dfrac{E_s}{3(1 - 2 \\nu_s)}$.\n- **Swelling**: Isotropic swelling with volumetric eigenstrain $\\epsilon^\\star$ in the solid phase.\n- **Confinement**: Stack with finite bulk stiffness $K_c$.\n- **Homogenization - Effective Modulus**: $K_{\\text{eff}}(\\varepsilon)$ scales with solid volume fraction $(1 - \\varepsilon)$ via a power-law exponent $m$. That is, $K_{\\text{eff}}(\\varepsilon) \\propto (1-\\varepsilon)^m$.\n- **Homogenization - Stress Concentration**: Solid skeleton stress $\\sigma_{\\text{solid}}$ is concentrated relative to the composite-average pressure $p$ via an exponent $q \\geq 1$.\n- **Porosity**: Symbol $\\varepsilon$, dimensionless.\n- **Objectives**:\n    - $\\mathcal{O}_1$: Minimize solid-skeleton stress $\\sigma_{\\text{solid}}(\\varepsilon)$ (in Pascals).\n    - $\\mathcal{O}_2$: Maximize porosity $\\varepsilon$ (dimensionless), which is equivalent to minimizing $-\\varepsilon$.\n- **Pareto Dominance**: A point $A$ dominates point $B$ if $A$ is no worse in all objectives and strictly better in at least one.\n- **Porosity Grid**: Uniform grid from $\\varepsilon_{\\min}$ to $\\varepsilon_{\\max}$ with step $\\Delta \\varepsilon$, inclusive of endpoints.\n- **Test Case 1**: $E_s = 12 \\times 10^9 \\, \\text{Pa}$, $\\nu_s = 0.30$, $\\beta = 0.08$, $x = 0.60$, $\\epsilon^\\star = \\beta x$, $K_c = 2 \\times 10^9 \\, \\text{Pa}$, $m = 2.0$, $q = 2.0$, $\\mathcal{O}_2$ is maximizing $\\varepsilon$, grid: $\\varepsilon_{\\min} = 0.05$, $\\varepsilon_{\\max} = 0.60$, $\\Delta \\varepsilon = 0.01$.\n- **Test Case 2**: $E_s = 35 \\times 10^9 \\, \\text{Pa}$, $\\nu_s = 0.26$, $\\beta = 0.05$, $x = 1.00$, $\\epsilon^\\star = \\beta x$, $K_c = 50 \\times 10^9 \\, \\text{Pa}$, $m = 2.5$, $q = 2.0$, $\\mathcal{O}_2$ is maximizing $\\varepsilon$, grid: $\\varepsilon_{\\min} = 0.10$, $\\varepsilon_{\\max} = 0.70$, $\\Delta \\varepsilon = 0.02$.\n- **Test Case 3**: $E_s = 70 \\times 10^9 \\, \\text{Pa}$, $\\nu_s = 0.22$, $\\beta = 0.25$, $x = 0.40$, $\\epsilon^\\star = \\beta x$, $K_c = 5 \\times 10^9 \\, \\text{Pa}$, $m = 2.0$, $q = 2.0$, $\\mathcal{O}_2$ is maximizing $\\varepsilon$, grid: $\\varepsilon_{\\min} = 0.02$, $\\varepsilon_{\\max} = 0.40$, $\\Delta \\varepsilon = 0.01$.\n- **Rounding**: Final porosity values in the Pareto front are to be rounded to three decimal places.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed to be **valid**.\n- **Scientifically Grounded**: The problem is based on established principles of continuum mechanics, linear elasticity, and micromechanics of porous materials. The models, such as power-law scaling for effective properties (akin to Gibson-Ashby models) and the series-spring analogy for load sharing, are standard and plausible simplifications in mechanical modeling.\n- **Well-Posed**: The task is to perform a multi-objective optimization over a discrete set of design choices (porosity values). The objectives are clearly defined, and the procedure for constructing a Pareto front is a standard, well-defined mathematical process. A unique solution (the set of Pareto-optimal porosities) exists for the given inputs.\n- **Objective**: The problem is stated with precise, quantitative parameters and objective criteria. It is free from ambiguity and subjective claims.\n- **Completeness**: All necessary parameters and definitions ($E_s, \\nu_s, \\epsilon^\\star, K_c, m, q$, and the porosity grid) are provided for each test case, making the problem self-contained. The statement \"LASER is not relevant\" serves to clarify the scope and does not introduce an invalidating element.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution Derivation and Algorithmic Design\n\n#### 1. Derivation of the Effective Bulk Modulus, $K_{\\text{eff}}(\\varepsilon)$\nThe problem specifies that the effective bulk modulus, $K_{\\text{eff}}(\\varepsilon)$, of the porous composite scales with the solid volume fraction, $(1 - \\varepsilon)$, via a power-law with exponent $m$. This relationship is expressed as:\n$$\nK_{\\text{eff}}(\\varepsilon) \\propto (1 - \\varepsilon)^m\n$$\nTo determine the constant of proportionality, we apply the boundary condition that at zero porosity ($\\varepsilon = 0$), the effective modulus must equal the modulus of the solid material, $K_s$.\n$$\nK_{\\text{eff}}(0) = K_s\n$$\nThis leads to the expression:\n$$\nK_{\\text{eff}}(\\varepsilon) = K_s (1 - \\varepsilon)^m\n$$\nThe bulk modulus of the solid skeleton, $K_s$, is derived from the given Young's modulus, $E_s$, and Poisson's ratio, $\\nu_s$, using the standard formula from isotropic linear elasticity:\n$$\nK_s = \\frac{E_s}{3(1 - 2\\nu_s)}\n$$\n\n#### 2. Derivation of the Swelling-Induced Pressure, $p(\\varepsilon)$\nThe problem models the porous electrode and its confinement as two hydrostatic springs in series. The total free volumetric expansion (eigenstrain) of the electrode, $\\epsilon^\\star$, is accommodated by the compressive strain of the electrode itself, $\\epsilon_{\\text{comp, electrode}}$, and the expansive strain of the confinement, $\\epsilon_{\\text{comp, confine}}$. By geometric compatibility:\n$$\n\\epsilon^\\star = \\epsilon_{\\text{comp, electrode}} + \\epsilon_{\\text{comp, confine}}\n$$\nUnder hydrostatic conditions, the relationship between pressure $p$ and volumetric strain $\\epsilon_{\\text{comp}}$ is given by the bulk modulus, $K$: $p = K \\cdot \\epsilon_{\\text{comp}}$. Thus, we can express the strains in terms of the equilibrium pressure $p$ that develops in the system:\n$$\n\\epsilon_{\\text{comp, electrode}} = \\frac{p}{K_{\\text{eff}}(\\varepsilon)}\n$$\n$$\n\\epsilon_{\\text{comp, confine}} = \\frac{p}{K_c}\n$$\nSubstituting these into the compatibility equation:\n$$\n\\epsilon^\\star = \\frac{p}{K_{\\text{eff}}(\\varepsilon)} + \\frac{p}{K_c} = p \\left( \\frac{1}{K_{\\text{eff}}(\\varepsilon)} + \\frac{1}{K_c} \\right)\n$$\nSolving for the pressure $p(\\varepsilon)$:\n$$\np(\\varepsilon) = \\epsilon^\\star \\left( \\frac{1}{K_{\\text{eff}}(\\varepsilon)} + \\frac{1}{K_c} \\right)^{-1} = \\epsilon^\\star \\frac{K_{\\text{eff}}(\\varepsilon) K_c}{K_{\\text{eff}}(\\varepsilon) + K_c}\n$$\nThis is the average hydrostatic pressure within the composite electrode.\n\n#### 3. Derivation of the Solid-Skeleton Stress, $\\sigma_{\\text{solid}}(\\varepsilon)$\nThe average pressure $p(\\varepsilon)$ is carried by the solid skeleton of the electrode, which has a reduced load-bearing area fraction approximated by the solid volume fraction, $(1 - \\varepsilon)$. This leads to stress concentration in the solid phase. The problem specifies a power-law model for this concentration effect with an exponent $q$. The stress in the solid phase, $\\sigma_{\\text{solid}}$, is related to the average pressure $p$ by:\n$$\n\\sigma_{\\text{solid}}(\\varepsilon) = \\frac{p(\\varepsilon)}{(1 - \\varepsilon)^q}\n$$\nBy substituting the expressions for $p(\\varepsilon)$ and $K_{\\text{eff}}(\\varepsilon)$, we obtain the final expression for the first objective function:\n$$\n\\sigma_{\\text{solid}}(\\varepsilon) = \\left( \\epsilon^\\star \\frac{K_s (1 - \\varepsilon)^m K_c}{K_s (1 - \\varepsilon)^m + K_c} \\right) \\frac{1}{(1 - \\varepsilon)^q} = \\epsilon^\\star K_c K_s \\frac{(1 - \\varepsilon)^{m-q}}{K_c + K_s (1 - \\varepsilon)^m}\n$$\nThis function, $\\sigma_{\\text{solid}}(\\varepsilon)$, is to be minimized.\n\n#### 4. Bi-Objective Problem Formulation and Pareto Front Construction\nWe have a bi-objective optimization problem defined over a discrete grid of porosity values $\\varepsilon_i$. The two objectives are:\n- $\\mathcal{O}_1(\\varepsilon) = \\sigma_{\\text{solid}}(\\varepsilon)$ (minimize)\n- $\\mathcal{O}_2(\\varepsilon) = \\varepsilon$ (maximize)\n\nTo construct the Pareto front, we evaluate the pair of objectives $(\\sigma_{\\text{solid}}(\\varepsilon_i), \\varepsilon_i)$ for each porosity $\\varepsilon_i$ in the specified grid. A point (and its corresponding porosity value $\\varepsilon_k$) is part of the Pareto front if it is not dominated by any other point. A point $j$ with objectives $(\\sigma_j, \\varepsilon_j)$ dominates a point $i$ with objectives $(\\sigma_i, \\varepsilon_i)$ if:\n$$\n(\\sigma_j \\le \\sigma_i) \\land (\\varepsilon_j \\ge \\varepsilon_i) \\land ((\\sigma_j < \\sigma_i) \\lor (\\varepsilon_j > \\varepsilon_i))\n$$\nThe algorithm proceeds as follows:\n1. For a given test case, generate the uniform porosity grid from $\\varepsilon_{\\min}$ to $\\varepsilon_{\\max}$ with step $\\Delta\\varepsilon$, ensuring the inclusion of the endpoint $\\varepsilon_{\\max}$.\n2. For each porosity value $\\varepsilon_i$ in the grid, calculate the objective vector $(\\sigma_{\\text{solid}}(\\varepsilon_i), \\varepsilon_i)$. Store these vectors.\n3. Initialize an empty set for the Pareto-optimal points.\n4. Iterate through each calculated objective vector. For each candidate vector $V_i$, compare it against all other vectors $V_j$. If any $V_j$ dominates $V_i$, then $V_i$ is not on the Pareto front.\n5. If after all comparisons, no other vector dominates $V_i$, then $V_i$ is a Pareto-optimal point and is added to the front.\n6. After checking all candidate vectors, the resulting set contains the full Pareto front.\n7. Extract the porosity values from the points on the Pareto front, sort them in ascending order, and round each to three decimal places. This list constitutes the final result for the test case.\nThis procedure is implemented for each of the three test cases provided.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes the Pareto front for a bi-objective optimization problem \n    in battery electrode design, trading off mechanical stress against porosity.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"E_s\": 12e9, \"nu_s\": 0.30, \"beta\": 0.08, \"x\": 0.60,\n            \"K_c\": 2e9, \"m\": 2.0, \"q\": 2.0,\n            \"eps_min\": 0.05, \"eps_max\": 0.60, \"delta_eps\": 0.01\n        },\n        {\n            \"E_s\": 35e9, \"nu_s\": 0.26, \"beta\": 0.05, \"x\": 1.00,\n            \"K_c\": 50e9, \"m\": 2.5, \"q\": 2.0,\n            \"eps_min\": 0.10, \"eps_max\": 0.70, \"delta_eps\": 0.02\n        },\n        {\n            \"E_s\": 70e9, \"nu_s\": 0.22, \"beta\": 0.25, \"x\": 0.40,\n            \"K_c\": 5e9, \"m\": 2.0, \"q\": 2.0,\n            \"eps_min\": 0.02, \"eps_max\": 0.40, \"delta_eps\": 0.01\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Unpack parameters for the current case\n        E_s, nu_s = case[\"E_s\"], case[\"nu_s\"]\n        beta, x = case[\"beta\"], case[\"x\"]\n        K_c, m, q = case[\"K_c\"], case[\"m\"], case[\"q\"]\n        eps_min, eps_max, delta_eps = case[\"eps_min\"], case[\"eps_max\"], case[\"delta_eps\"]\n        \n        # Calculate derived parameters\n        eps_star = beta * x\n        K_s = E_s / (3 * (1 - 2 * nu_s))\n\n        # 1. Generate the porosity grid.\n        # Use a small tolerance with np.arange to ensure the endpoint is included.\n        porosity_grid = np.arange(eps_min, eps_max + delta_eps / 2.0, delta_eps)\n\n        # 2. Evaluate objectives for each point in the grid.\n        # objectives is a list of dicts, each holding the values for one porosity point.\n        objectives = []\n        for eps in porosity_grid:\n            # Effective bulk modulus of the porous electrode\n            K_eff = K_s * (1 - eps)**m\n            \n            # Swelling-induced hydrostatic pressure in the composite\n            p = eps_star * (K_eff * K_c) / (K_eff + K_c)\n            \n            # Stress in the solid-skeleton, accounting for stress concentration\n            sigma_solid = p / (1 - eps)**q\n            \n            objectives.append({'stress': sigma_solid, 'porosity': eps})\n\n        # 3. Construct the Pareto front.\n        pareto_front_points = []\n        for p_i in objectives:\n            is_dominated = False\n            for p_j in objectives:\n                if p_i is p_j:\n                    continue\n                \n                # A point j dominates point i if it is better or equal on all objectives\n                # and strictly better on at least one.\n                # Objective 1: stress (minimize)\n                # Objective 2: porosity (maximize)\n                stress_j, por_j = p_j['stress'], p_j['porosity']\n                stress_i, por_i = p_i['stress'], p_i['porosity']\n                \n                is_weakly_dominant = (stress_j <= stress_i) and (por_j >= por_i)\n                is_strictly_dominant = (stress_j < stress_i) or (por_j > por_i)\n                \n                if is_weakly_dominant and is_strictly_dominant:\n                    is_dominated = True\n                    break\n            \n            if not is_dominated:\n                pareto_front_points.append(p_i)\n        \n        # 4. Extract, sort, and round porosity values from the Pareto front.\n        pareto_porosities = sorted([p['porosity'] for p in pareto_front_points])\n        rounded_porosities = [round(p, 3) for p in pareto_porosities]\n        \n        all_results.append(rounded_porosities)\n\n    # Final print statement must be a single line in the format [[...],[...],[...]]\n    # using str() and replace() to achieve the exact format without spaces.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "High-fidelity simulations are essential for design, but their computational cost can be a major bottleneck for rapid optimization. This final practice introduces an advanced technique, Polynomial Chaos Expansion (PCE), to create a fast and accurate \"surrogate model\" that mimics complex physical behavior with minimal computational overhead. Mastering the creation and validation of such data-driven models is crucial for enabling the large-scale design space exploration required in modern automated engineering workflows .",
            "id": "3910435",
            "problem": "You are tasked with constructing, implementing, and validating a low-order surrogate for stack pressure in a laminated lithium-ion cell stack under through-thickness constraint, as a function of state of charge and temperature, using Polynomial Chaos Expansion (PCE). The objective is to approximate a physically plausible high-fidelity reference that stands in for a Finite Element Method (FEM) model. The problem must be solved from first principles consistent with linear elasticity and thermomechanical swelling of composite electrodes, and the final answer must be a runnable program that produces outputs for a prescribed test suite.\n\nStart from the following fundamental bases and core definitions:\n- Hooke’s law for linear elasticity stating that stress is proportional to strain, $\\,\\sigma = E \\,\\varepsilon\\,$, where $\\,\\sigma\\,$ is stress, $\\,E\\,$ is Young’s modulus, and $\\,\\varepsilon\\,$ is strain.\n- Plane-strain modulus for constrained layers, $\\,E_{\\text{ps}}(T) = \\dfrac{E(T)}{1-\\nu^2}\\,$, where $\\,\\nu\\,$ is Poisson’s ratio and $\\,E(T)\\,$ is the effective temperature-dependent modulus.\n- The constrained stack pressure is modeled as proportional to the average through-thickness stress, $\\,p(s,T) = g \\, E_{\\text{ps}}(T)\\, \\varepsilon_{\\text{eff}}(s,T)\\,$, where $\\,g\\,$ is a dimensionless geometric constraint factor that aggregates stack aspect ratio and end plate stiffness, $\\,s\\,$ is the state of charge (fractional stoichiometry, dimensionless), and $\\,T\\,$ is temperature in Kelvin.\n\nDefine the high-fidelity reference pressure $\\,p_{\\text{true}}(s,T)\\,$ as a compositionally and thermally coupled function incorporating modulus softening and nonlinear swelling, consistent with observed behavior in composite electrodes:\n- Temperature-dependent modulus:\n$$\nE(T) = \\frac{E_0}{\\,1 + b\\,(T - T_{\\text{ref}})\\,}\\,,\n$$\n$$\nE_{\\text{ps}}(T) = \\frac{E(T)}{\\,1 - \\nu^2\\,}\\,,\n$$\nwith $\\,E_0 = 4000\\,\\text{MPa}\\,$, $\\,b = 0.015\\,\\text{K}^{-1}\\,$, $\\,T_{\\text{ref}} = 298\\,\\text{K}\\,$, and $\\,\\nu = 0.30\\,$.\n- Effective swelling strain:\n$$\n\\varepsilon_{\\text{eff}}(s,T) = a_1 s + a_2 s^2 + a_T s^2 \\left(\\frac{T - T_{\\text{ref}}}{T_{\\text{ref}}}\\right) + a_c\\, s(1-s)\\, \\tanh\\!\\left(\\frac{T - T_{\\text{ref}}}{\\Delta T}\\right),\n$$\nwith $\\,a_1 = 0.015\\,$, $\\,a_2 = 0.006\\,$, $\\,a_T = 0.004\\,$, $\\,a_c = 0.003\\,$, and $\\,\\Delta T = 50\\,\\text{K}\\,$.\n- Cross-coupled amplification factor:\n$$\n\\chi(s,T) = 1 + \\delta\\, s \\left(\\frac{T - T_{\\text{ref}}}{T_{\\text{ref}}}\\right), \\quad \\delta = 0.2\\,.\n$$\n- Geometric constraint factor:\n$$\ng = 0.08\\,.\n$$\n- The high-fidelity pressure in megapascals:\n$$\np_{\\text{true}}(s,T) = g \\, E_{\\text{ps}}(T)\\, \\varepsilon_{\\text{eff}}(s,T)\\, \\chi(s,T)\\,.\n$$\n\nConstruct a low-order surrogate using Polynomial Chaos Expansion (PCE) of total degree $\\,2\\,$ in two inputs $\\,s\\,$ and $\\,T\\,$, treated as independent random variables uniformly distributed over their operational domains. Use Legendre polynomials as the orthogonal basis for uniform inputs. Map the physical inputs to canonical variables on $\\,[-1,1]\\,$:\n- State of charge mapping:\n$$\n\\xi_s = 2s - 1\\,, \\quad s \\in [0,1]\\,.\n$$\n- Temperature mapping:\n$$\n\\xi_T = \\frac{2T - (T_{\\min} + T_{\\max})}{T_{\\max} - T_{\\min}}\\,, \\quad T \\in [T_{\\min}, T_{\\max}]\\,,\n$$\nwith $\\,T_{\\min} = 273\\,\\text{K}\\,$ and $\\,T_{\\max} = 333\\,\\text{K}\\,$.\n\nLet $\\,L_0(x) = 1\\,$, $\\,L_1(x) = x\\,$, and $\\,L_2(x) = \\tfrac{1}{2}(3x^2-1)\\,$ denote the first three Legendre polynomials. Form the bivariate basis up to degree $\\,2\\,$ as products $\\,L_i(\\xi_s)\\,L_j(\\xi_T)\\,$ for $\\,i,j \\in \\{0,1,2\\}\\,$, resulting in $\\,9\\,$ terms. The surrogate has the form\n$$\np_{\\text{PCE}}(s,T) = \\sum_{i=0}^{2} \\sum_{j=0}^{2} c_{ij}\\, L_i(\\xi_s)\\, L_j(\\xi_T)\\,,\n$$\nwhere $\\,c_{ij}\\,$ are coefficients to be determined via non-intrusive spectral projection approximated by tensor-product Gauss–Legendre quadrature or, equivalently, via least-squares regression on a Gauss–Legendre collocation grid.\n\nAccuracy must be quantified against the high-fidelity reference by computing the relative $\\,L^2\\,$ error over the input domain with respect to the uniform probability measure:\n$$\n\\mathcal{E}_{\\text{rel}} = \\sqrt{\\frac{\\int_{-1}^{1}\\int_{-1}^{1} \\left(p_{\\text{PCE}} - p_{\\text{true}}\\right)^2 \\, d\\xi_s\\, d\\xi_T}{\\int_{-1}^{1}\\int_{-1}^{1} \\left(p_{\\text{true}}\\right)^2 \\, d\\xi_s\\, d\\xi_T}}\\,,\n$$\nto be approximated via two-dimensional Gauss–Legendre quadrature using $\\,9\\,$ points per dimension. Additionally, compute absolute errors at specified test cases.\n\nImplement a Python program that:\n- Constructs the PCE surrogate $\\,p_{\\text{PCE}}(s,T)\\,$ of total degree $\\,2\\,$ based on a $\\,9 \\times 9\\,$ Gauss–Legendre collocation grid in $\\,(\\xi_s,\\xi_T)\\,$ mapped to $\\,s\\,$ and $\\,T\\,$.\n- Evaluates the high-fidelity pressure $\\,p_{\\text{true}}(s,T)\\,$ and the surrogate $\\,p_{\\text{PCE}}(s,T)\\,$ for each test case and reports absolute errors.\n- Computes the global relative $\\,L^2\\,$ error $\\,\\mathcal{E}_{\\text{rel}}\\,$ using $\\,9 \\times 9\\,$ Gauss–Legendre quadrature.\n- All pressures must be expressed in megapascals (MPa), and report errors in megapascals (MPa). The relative $\\,L^2\\,$ error must be reported as a decimal fraction.\n\nUse the following test suite of inputs, each given as $\\, (s,T)\\,$:\n- Case 1: $\\, (0.0,\\, 298)\\,$.\n- Case 2: $\\, (0.5,\\, 298)\\,$.\n- Case 3: $\\, (1.0,\\, 273)\\,$.\n- Case 4: $\\, (1.0,\\, 333)\\,$.\n- Case 5: $\\, (0.2,\\, 333)\\,$.\n- Case 6: $\\, (0.8,\\, 283)\\,$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain $\\,7\\,$ floats: the first $\\,6\\,$ are the absolute errors in MPa for the test suite in the order given, and the last element is the global relative $\\,L^2\\,$ error $\\,\\mathcal{E}_{\\text{rel}}\\,$. For example, an output format of the form $\\, [e_1,e_2,e_3,e_4,e_5,e_6,E_{\\text{rel}}]\\,$ must be produced, where each $\\,e_k\\,$ is an absolute error in MPa, and $\\,E_{\\text{rel}}\\,$ is a decimal fraction.",
            "solution": "The problem is scientifically and mathematically well-posed, providing a complete and consistent set of equations, parameters, and procedures to construct a surrogate model for battery stack pressure and subsequently evaluate its accuracy. We will proceed with the solution by first detailing the high-fidelity physical model, then formulating and constructing the Polynomial Chaos Expansion (PCE) surrogate, and finally quantifying the surrogate's accuracy against the high-fidelity reference.\n\n### 1. High-Fidelity Physical Model\n\nThe reference or \"true\" model for the through-thickness pressure, $p_{\\text{true}}(s,T)$, is grounded in the principles of linear thermo-elasticity for a constrained composite material. The pressure is assumed to be proportional to the average stress, which by Hooke's law is the product of the effective modulus and the effective strain. The model incorporates temperature-dependent material properties and nonlinear, coupled swelling behavior as a function of state of charge, $s$, and temperature, $T$.\n\nThe key components are:\n\n- **Temperature-Dependent Plane-Strain Modulus, $E_{\\text{ps}}(T)$**: The effective Young's modulus, $E(T)$, is assumed to decrease with temperature, a phenomenon known as modulus softening, common in polymer-based components of a battery. The plane-strain modulus, $E_{\\text{ps}}(T)$, accounts for the lateral constraint in the laminated stack.\n$$\nE(T) = \\frac{E_0}{\\,1 + b\\,(T - T_{\\text{ref}})\\,}, \\quad E_{\\text{ps}}(T) = \\frac{E(T)}{\\,1 - \\nu^2\\,}\n$$\nThe given constants are the reference modulus $E_0 = 4000\\,\\text{MPa}$, the softening coefficient $b = 0.015\\,\\text{K}^{-1}$, the reference temperature $T_{\\text{ref}} = 298\\,\\text{K}$, and Poisson's ratio $\\nu = 0.30$.\n\n- **Effective Swelling Strain, $\\varepsilon_{\\text{eff}}(s,T)$**: This term captures the strain induced by lithium intercalation (a function of $s$) and thermal expansion (a function of $T$). The provided model is a nonlinear, coupled function including a quadratic dependence on $s$ and two thermo-mechanical coupling terms.\n$$\n\\varepsilon_{\\text{eff}}(s,T) = a_1 s + a_2 s^2 + a_T s^2 \\left(\\frac{T - T_{\\text{ref}}}{T_{\\text{ref}}}\\right) + a_c\\, s(1-s)\\, \\tanh\\!\\left(\\frac{T - T_{\\text{ref}}}{\\Delta T}\\right)\n$$\nThe empirical coefficients are $a_1 = 0.015$, $a_2 = 0.006$, $a_T = 0.004$, $a_c = 0.003$, and $\\Delta T = 50\\,\\text{K}$.\n\n- **Cross-Coupled Amplification Factor, $\\chi(s,T)$**: This factor models a secondary coupling effect where the stress response is amplified at higher states of charge and temperatures.\n$$\n\\chi(s,T) = 1 + \\delta\\, s \\left(\\frac{T - T_{\\text{ref}}}{T_{\\text{ref}}}\\right), \\quad \\text{with } \\delta = 0.2\n$$\n\n- **High-Fidelity Pressure, $p_{\\text{true}}(s,T)$**: The final pressure is the product of these components, scaled by a geometric constraint factor $g=0.08$.\n$$\np_{\\text{true}}(s,T) = g \\, E_{\\text{ps}}(T)\\, \\varepsilon_{\\text{eff}}(s,T)\\, \\chi(s,T)\n$$\nThe units of pressure are determined by $E_0$, which is in megapascals ($\\text{MPa}$).\n\n### 2. Polynomial Chaos Expansion (PCE) Surrogate Model\n\nThe objective is to create a low-order computational surrogate, $p_{\\text{PCE}}(s,T)$, that approximates $p_{\\text{true}}(s,T)$ over its operational domain. PCE represents a function as a spectral expansion in a basis of orthogonal polynomials of its random inputs.\n\n- **Canonical Variable Mapping**: The physical inputs $s \\in [0, 1]$ and $T \\in [T_{\\min}, T_{\\max}] = [273\\,\\text{K}, 333\\,\\text{K}]$ are mapped to independent canonical variables $\\xi_s$ and $\\xi_T$ on the interval $[-1, 1]$, where the Legendre polynomials are orthogonal.\n$$\n\\xi_s = 2s - 1\n$$\n$$\n\\xi_T = \\frac{2T - (T_{\\min} + T_{\\max})}{T_{\\max} - T_{\\min}} = \\frac{2T - (273 + 333)}{333 - 273} = \\frac{T - 303}{30}\n$$\n\n- **Basis Polynomials**: Since the inputs are assumed to be uniformly distributed, the appropriate orthogonal polynomial basis is the Legendre polynomials. We use the first three polynomials:\n$$\nL_0(x) = 1, \\quad L_1(x) = x, \\quad L_2(x) = \\frac{1}{2}(3x^2-1)\n$$\n\n- **Surrogate Formulation**: A tensor-product basis is formed using polynomials up to degree $2$ in each variable. This results in $3 \\times 3 = 9$ basis functions, $\\Psi_{ij}(\\xi_s, \\xi_T) = L_i(\\xi_s)L_j(\\xi_T)$. The surrogate model is a linear combination of these basis functions:\n$$\np_{\\text{PCE}}(s,T) = \\sum_{i=0}^{2} \\sum_{j=0}^{2} c_{ij}\\, L_i(\\xi_s(s))\\, L_j(\\xi_T(T))\n$$\nThe coefficients $\\{c_{ij}\\}$ must be determined.\n\n### 3. Determination of PCE Coefficients\n\nThe problem specifies a non-intrusive method using least-squares regression on a collocation grid. This involves evaluating the high-fidelity model at a set of points and fitting the PCE coefficients to these results.\n\n- **Collocation Grid**: A tensor-product grid of $N \\times N = 9 \\times 9 = 81$ points is used. These points are the nodes of the $9$-point Gauss-Legendre quadrature rule on $[-1, 1]$. Let the 1D nodes be $\\{\\xi_k\\}_{k=1}^9$. The 2D grid in the canonical space is $\\{(\\xi_{s,k}, \\xi_{T,l}) = (\\xi_k, \\xi_l)\\}_{k,l=1}^9$. These $81$ points are mapped to their physical $(s,T)$ coordinates.\n\n- **Least-Squares Regression**: The vector of coefficients $\\mathbf{c}$ (containing the $9$ unknown $c_{ij}$) is found by solving the following overdetermined linear system in a least-squares sense:\n$$\n\\mathbf{\\Psi} \\mathbf{c} = \\mathbf{y}\n$$\nHere, $\\mathbf{y}$ is an $81 \\times 1$ vector of the high-fidelity model evaluations, $p_{\\text{true}}$, at each of the $81$ grid points. $\\mathbf{\\Psi}$ is an $81 \\times 9$ design matrix (a Vandermonde-like matrix) where each row corresponds to a grid point and each column corresponds to a basis function. An entry of this matrix is $\\Psi_{(k,l),(i,j)} = L_i(\\xi_{s,k})L_j(\\xi_{T,l})$. The least-squares solution minimizes the Euclidean norm $\\|\\mathbf{\\Psi} \\mathbf{c} - \\mathbf{y}\\|_2$ and is given by $\\mathbf{c} = (\\mathbf{\\Psi}^T\\mathbf{\\Psi})^{-1}\\mathbf{\\Psi}^T\\mathbf{y}$.\n\n### 4. Accuracy Evaluation\n\nThe accuracy of the resulting surrogate $p_{\\text{PCE}}$ is assessed in two ways:\n\n- **Pointwise Absolute Error**: For each of the $6$ test cases $(s_k, T_k)$, the absolute error is calculated as:\n$$\ne_k = |p_{\\text{PCE}}(s_k, T_k) - p_{\\text{true}}(s_k, T_k)|\n$$\n\n- **Global Relative $L^2$ Error**: This metric measures the average error over the entire input domain, weighted by the (uniform) probability distribution of the inputs. The integral is computed over the canonical space $[-1, 1] \\times [-1, 1]$.\n$$\n\\mathcal{E}_{\\text{rel}} = \\sqrt{\\frac{\\int_{-1}^{1}\\int_{-1}^{1} \\left(p_{\\text{PCE}} - p_{\\text{true}}\\right)^2 \\, d\\xi_s\\, d\\xi_T}{\\int_{-1}^{1}\\int_{-1}^{1} \\left(p_{\\text{true}}\\right)^2 \\, d\\xi_s\\, d\\xi_T}}\n$$\nBoth integrals in the numerator and the denominator are approximated numerically using a $9 \\times 9$ tensor-product Gauss-Legendre quadrature rule. Let $\\{\\xi_k, w_k\\}_{k=1}^9$ be the 1D Gauss-Legendre nodes and weights. The integral of a function $f(\\xi_s, \\xi_T)$ is approximated as:\n$$\n\\int_{-1}^{1}\\int_{-1}^{1} f(\\xi_s, \\xi_T) \\, d\\xi_s\\, d\\xi_T \\approx \\sum_{k=1}^{9}\\sum_{l=1}^{9} f(\\xi_k, \\xi_l)\\,w_k w_l\n$$\nThis procedure is applied to the integrands $(p_{\\text{PCE}} - p_{\\text{true}})^2$ and $(p_{\\text{true}})^2$, evaluated at the quadrature nodes, to compute the final relative error $\\mathcal{E}_{\\text{rel}}$.\n\nThe following implementation will systematically execute these steps.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and validates a PCE surrogate for battery stack athermal pressure.\n    \"\"\"\n    # --- 1. Define Constants and High-Fidelity Model ---\n\n    # Physical and model constants\n    E0 = 4000.0       # Reference modulus [MPa]\n    b = 0.015         # Modulus softening coefficient [K^-1]\n    T_ref = 298.0     # Reference temperature [K]\n    nu = 0.30         # Poisson's ratio\n    a1 = 0.015        # Strain coefficient\n    a2 = 0.006        # Strain coefficient\n    aT = 0.004        # Strain coefficient\n    ac = 0.003        # Strain coefficient\n    DeltaT = 50.0     # Temperature scale for tanh [K]\n    delta = 0.2       # Amplification factor coefficient\n    g = 0.08          # Geometric constraint factor\n\n    # Input domain boundaries\n    T_min = 273.0     # Minimum temperature [K]\n    T_max = 333.0     # Maximum temperature [K]\n    s_min = 0.0\n    s_max = 1.0\n\n    def p_true(s, T):\n        \"\"\"High-fidelity reference pressure model in MPa.\"\"\"\n        # Temperature-dependent modulus\n        E_T = E0 / (1.0 + b * (T - T_ref))\n        E_ps_T = E_T / (1.0 - nu**2)\n        \n        # Effective swelling strain\n        T_term1 = aT * s**2 * (T - T_ref) / T_ref\n        T_term2 = ac * s * (1 - s) * np.tanh((T - T_ref) / DeltaT)\n        eps_eff = a1 * s + a2 * s**2 + T_term1 + T_term2\n\n        # Cross-coupled amplification factor\n        chi = 1.0 + delta * s * (T - T_ref) / T_ref\n        \n        # High-fidelity pressure\n        pressure = g * E_ps_T * eps_eff * chi\n        return pressure\n\n    # --- 2. Set up PCE Framework ---\n    \n    # PCE settings\n    PCE_DEG = 2\n    N_TERMS_1D = PCE_DEG + 1\n    N_FIT = 9 # Number of points for least-squares fitting grid per dimension\n    N_QUAD = 9 # Number of points for quadrature grid per dimension\n\n    # Canonical variable mappings\n    def s_to_xi_s(s):\n        return 2.0 * (s - s_min) / (s_max - s_min) - 1.0\n\n    def T_to_xi_T(T):\n        return 2.0 * (T - T_min) / (T_max - T_min) - 1.0\n\n    def xi_s_to_s(xi_s):\n        return (xi_s + 1.0) / 2.0 * (s_max - s_min) + s_min\n\n    def T_from_xi_T(xi_T):\n        return (xi_T + 1.0) / 2.0 * (T_max - T_min) + T_min\n\n    # Legendre polynomial basis functions\n    L = [\n        lambda x: np.ones_like(x),\n        lambda x: x,\n        lambda x: 0.5 * (3 * x**2 - 1)\n    ]\n\n    # --- 3. Determine PCE Coefficients via Least-Squares Regression ---\n    \n    # Generate collocation grid for fitting\n    xi_s_fit_1d, _ = np.polynomial.legendre.leggauss(N_FIT)\n    xi_T_fit_1d, _ = np.polynomial.legendre.leggauss(N_FIT)\n    xi_s_fit_2d, xi_T_fit_2d = np.meshgrid(xi_s_fit_1d, xi_T_fit_1d)\n    \n    # Map grid to physical domain\n    s_fit_grid = xi_s_to_s(xi_s_fit_2d.flatten())\n    T_fit_grid = T_from_xi_T(xi_T_fit_2d.flatten())\n\n    # Evaluate true model on the grid\n    y_true = p_true(s_fit_grid, T_fit_grid)\n\n    # Construct the Vandermonde-like matrix (design matrix)\n    num_points_fit = N_FIT * N_FIT\n    num_basis_funcs = N_TERMS_1D * N_TERMS_1D\n    psi_matrix = np.zeros((num_points_fit, num_basis_funcs))\n    \n    xi_s_flat = xi_s_fit_2d.flatten()\n    xi_T_flat = xi_T_fit_2d.flatten()\n\n    basis_idx = 0\n    for i in range(N_TERMS_1D):\n        for j in range(N_TERMS_1D):\n            psi_matrix[:, basis_idx] = L[i](xi_s_flat) * L[j](xi_T_flat)\n            basis_idx += 1\n\n    # Solve for coefficients using least squares\n    coeffs, _, _, _ = np.linalg.lstsq(psi_matrix, y_true, rcond=None)\n\n    def p_pce(s, T):\n        \"\"\"Evaluates the PCE surrogate model.\"\"\"\n        xi_s = s_to_xi_s(s)\n        xi_T = T_to_xi_T(T)\n        \n        p_val = 0.0\n        basis_idx = 0\n        for i in range(N_TERMS_1D):\n            for j in range(N_TERMS_1D):\n                p_val += coeffs[basis_idx] * L[i](xi_s) * L[j](xi_T)\n                basis_idx += 1\n        return p_val\n    \n    # --- 4. Evaluate Accuracy ---\n\n    # Test suite\n    test_cases = [\n        (0.0, 298.0), (0.5, 298.0), (1.0, 273.0),\n        (1.0, 333.0), (0.2, 333.0), (0.8, 283.0)\n    ]\n    \n    absolute_errors = []\n    for s_test, T_test in test_cases:\n        p_val_true = p_true(s_test, T_test)\n        p_val_pce = p_pce(s_test, T_test)\n        absolute_errors.append(abs(p_val_pce - p_val_true))\n        \n    # Calculate global relative L2 error using Gauss-Legendre quadrature\n    nodes_1d, weights_1d = np.polynomial.legendre.leggauss(N_QUAD)\n    nodes_s_2d, nodes_T_2d = np.meshgrid(nodes_1d, nodes_1d)\n    weights_s_2d, weights_T_2d = np.meshgrid(weights_1d, weights_1d)\n    \n    s_quad_grid = xi_s_to_s(nodes_s_2d)\n    T_quad_grid = T_from_xi_T(nodes_T_2d)\n    \n    p_true_on_quad_grid = p_true(s_quad_grid, T_quad_grid)\n    p_pce_on_quad_grid = p_pce(s_quad_grid, T_quad_grid)\n    \n    # Numerator integral: integral of (p_pce - p_true)^2\n    integrand_num = (p_pce_on_quad_grid - p_true_on_quad_grid)**2\n    integral_num = np.sum(integrand_num * weights_s_2d * weights_T_2d)\n    \n    # Denominator integral: integral of (p_true)^2\n    integrand_den = p_true_on_quad_grid**2\n    integral_den = np.sum(integrand_den * weights_s_2d * weights_T_2d)\n\n    # Avoid division by zero if true model is identically zero (unlikely here)\n    if integral_den == 0:\n        rel_l2_error = 0.0 if integral_num == 0 else np.inf\n    else:\n        rel_l2_error = np.sqrt(integral_num / integral_den)\n\n    # --- 5. Final Output ---\n    results = absolute_errors + [rel_l2_error]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}