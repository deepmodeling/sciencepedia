{
    "hands_on_practices": [
        {
            "introduction": "在对固态电池中的接触损失进行建模时，一个基本出发点是理解即使在理想的微观接触点上，电阻也必然存在。本练习将引导您从基本物理原理出发，推导单个圆形接触点处由于电流线收缩而产生的“收缩电阻”。通过掌握这个核心概念，您将能够为包含大量独立接触点的更真实界面建立一个并联电阻网络模型。",
            "id": "3929467",
            "problem": "考虑一个固态电池（SSB）界面，该界面被建模为两个名义上平坦、半无限、均匀、各向同性的离子导体之间的机械图案化接触，其体离子电导率为 $\\kappa$。假设是稳态、等温、线性输运，并且电极动力学可忽略不计，因此主要电阻来源于微接触点处离子电流线的几何收缩（扩散）。设一个半径为 $a$ 的单个圆形微接触点连接这两个半空间。控制关系是离子传导的局部形式欧姆定律 $\\mathbf{J}=-\\kappa\\nabla\\phi$ 和连续性方程 $\\nabla\\cdot\\mathbf{J}=0$，这两个方程共同意味着在每个半空间中都满足拉普拉斯方程 $\\nabla^{2}\\phi=0$。将界面平面处理为 $z=0$，使用柱坐标 $(r,\\theta,z)$ 并施加轴对称性。远离接触点时，两个半空间中的电势趋于恒定值，其差值为施加的电势降 $\\Delta\\phi$，而圆形接触区域外的界面是绝缘的，法向通量为零。\n\n从这些基本原理和适当的边界条件出发，推导单个圆形微接触点的总收缩电阻 $R_{c}$ 的闭式表达式，用 $\\kappa$ 和 $a$ 表示。然后，考虑一个包含许多不重叠的圆形微接触点的界面，其半径为 $\\{a_{i}\\}_{i=1}^{N}$，这些微接触点在流体动力学或静电学上不相互作用（即，叠加场不会显著地相互扰动）。如果一个化学-机械过程使比例为 $1-f$ 的微接触点失效而不导电（其中 $f\\in(0,1]$ 是活性比例），并且剩余活性接触点的半径集合的平均值为 $\\bar{a}$，请说明多接触点界面如何表现为收缩电阻的并联网络。最后，考虑一个全电池，其中离子传导必须串联通过两个这样的界面，索引为 $k\\in\\{1,2\\}$，其体离子电导率为 $\\kappa_{k}$，平面面积为 $A_{k}$，几何微接触点的数密度为 $n_{k}$，活性比例为 $f_{k}$，活性接触点的平均半径为 $\\bar{a}_{k}$。在所述假设下，提供一个单一的闭式符号表达式，用 $\\kappa_{k}$、$A_{k}$、$n_{k}$、$f_{k}$ 和 $\\bar{a}_{k}$ 表示跨越两个界面的总串联接触电阻 $R_{\\mathrm{tot}}$。\n\n用符号表示你的最终结果。如果进行数值解释，以欧姆（SI单位）报告电阻。",
            "solution": "该问题是有效的，因为它具有科学依据、提法明确且客观。它包括三个部分：推导单个圆形微接触点的收缩电阻，将其推广到非相互作用的微接触点阵列，最后将两个这样的界面串联起来。\n\n**第一部分：单个圆形微接触点的收缩电阻**\n\n我们首先考虑在两个半无限离子导体之间 $z=0$ 界面上的一个半径为 $a$ 的单个圆形微接触点，两个导体的体电导率均为 $\\kappa$。设整个接触点上的总电势降为 $\\Delta\\phi$。根据对称性，我们可以将接触盘的电势设为 $\\phi=0$，并将两个半空间在无穷远处的电势分别设为 $+\\Delta\\phi/2$ 和 $-\\Delta\\phi/2$。\n\n这是一个势理论中的经典混合边值问题（“电气化圆盘问题”）。其解给出流经接触点的总电流 $I$ 为：\n$$ I = 2 \\kappa a \\Delta\\phi $$\n总收缩电阻 $R_c$ 定义为 $R_c = \\Delta\\phi / I$。因此，\n$$ R_c = \\frac{\\Delta\\phi}{2 \\kappa a \\Delta\\phi} = \\frac{1}{2 \\kappa a} $$\n这就是单个圆形微接触点的收缩电阻，也被称为麦克斯韦电阻。\n\n**第二部分：多接触点界面**\n\n对于一个包含许多不相互作用的微接触点的界面，这些接触点在电学上是并联的。如果总共有 $N_{\\mathrm{geom}} = n A$ 个几何微接触点，其中比例为 $f$ 的接触点是活性的，那么活性接触点的数量为 $N_{\\mathrm{active}} = f n A$。每个活性接触点的平均半径为 $\\bar{a}$，其平均电阻为 $\\bar{R}_c = 1/(2\\kappa\\bar{a})$。总电导 $G_{\\mathrm{total}}$ 是所有活性接触点电导的总和：\n$$ G_{\\mathrm{total}} = \\sum_{i=1}^{N_{\\mathrm{active}}} \\frac{1}{R_i} \\approx N_{\\mathrm{active}} \\cdot \\frac{1}{\\bar{R}_c} = (f n A) \\cdot (2 \\kappa \\bar{a}) $$\n因此，界面的总电阻 $R_{\\mathrm{interface}}$ 是总电导的倒数：\n$$ R_{\\mathrm{interface}} = \\frac{1}{G_{\\mathrm{total}}} = \\frac{1}{2 f n A \\kappa \\bar{a}} $$\n\n**第三部分：两个串联的界面**\n\n当两个界面（索引为 $k=1,2$）串联时，它们的总电阻是各自电阻之和：\n$$ R_{\\mathrm{tot}} = R_1 + R_2 = \\frac{1}{2 f_1 n_1 A_1 \\kappa_1 \\bar{a}_1} + \\frac{1}{2 f_2 n_2 A_2 \\kappa_2 \\bar{a}_2} $$\n这个结果与答案框中的表达式相匹配。",
            "answer": "$$\n\\boxed{\\frac{1}{2 f_1 n_1 A_1 \\kappa_1 \\bar{a}_1} + \\frac{1}{2 f_2 n_2 A_2 \\kappa_2 \\bar{a}_2}}\n$$"
        },
        {
            "introduction": "界面的完整性并非一成不变，它会受到电池运行过程中产生的内部应力的动态影响。这个实践练习将通过编写一个一维模型，来探索电化学反应产生的化学应力与外部施加的堆叠压力之间的竞争关系。通过这个练习，您将亲手实现一个耦合了电化学和力学效应的模型，以预测在给定电流密度下界面是保持接触还是发生分离。",
            "id": "3929469",
            "problem": "您的任务是构建并分析一个固态电池（SSB）中固-固界面接触损失的一维力学-化学模型。该界面位于固态电解质（SSE）和锂金属负极之间。外部堆叠压力垂直施加于界面，而在规定电流密度下的界面电化学反应会产生体积本征应变，这可能在界面处产生拉伸应力。目标是对于给定的参数集，确定界面是保持接触还是分离。您必须实现一个完整的、可运行的程序，该程序能针对提供的测试套件，以指定格式输出接触状态和临界外部压力。\n\n建模假设和符号约定如下：\n- 外部堆叠压力为正时视为压缩性。设外部施加的压力为 $P_{\\mathrm{ext}}$，单位为 $\\mathrm{Pa}$。\n- 电流密度 $j$（单位 $\\mathrm{A/m^2}$）在界面发生净剥离（锂去除）时为正，在发生净沉积（锂沉积）时为负。\n- 电化学摩尔通量为 $J = j / F$，其中 $F$ 是法拉第常数，单位为 $\\mathrm{C/mol}$。\n- 一个厚度为 $h$（单位 $\\mathrm{m}$）的薄界面反应影响层由于质量的移除或增加而产生体积本征应变。在一维近似中，质量守恒结合法拉第定律意味着本征应变速率与通量散度成正比，在反应影响层上近似为 $J / h$。在时间 $t$（单位 $\\mathrm{s}$）内，累积的体积本征应变与 $J t / h$ 成正比，比例因子由偏摩尔体积 $\\Omega$（单位 $\\mathrm{m^3/mol}$）给出。使用以下符号约定：剥离（$j > 0$）在界面旁的反应层中引起负的本征应变（收缩），而沉积（$j  0$）引起正的本征应变（膨胀）。\n- 该层表现为杨氏模量为 $E$（单位 $\\mathrm{Pa}$）的线性弹性固体。当负的本征应变受到机械性抵抗时，界面处会产生拉伸化学应力。一个具有物理动机的上限值 $\\sigma_{y}$（单位 $\\mathrm{Pa}$）表示由于非弹性机制（例如，微裂纹或粘塑性松弛）可达到的最大拉伸化学应力，超过此值应力不再增加。\n\n接触准则：\n- 设由本征应变产生的拉伸化学应力大小表示为 $\\sigma_{\\mathrm{chem}}$（单位 $\\mathrm{Pa}$），其上限为 $\\sigma_{y}$。则界面处的净法向牵引力为 $T_{n} = P_{\\mathrm{ext}} - \\sigma_{\\mathrm{chem}}$。如果 $T_{n} \\ge 0$，界面保持接触，否则分离。\n- 将刚好维持接触所需的临界外部压力定义为 $P_{\\mathrm{crit}} = \\sigma_{\\mathrm{chem}}$。您必须为每个测试用例输出 $P_{\\mathrm{crit}}$（单位 $\\mathrm{Pa}$），以及相应的布尔型接触判定。\n\n在您的推导和算法设计中使用的基本依据：\n- 连接电流密度和摩尔通量的法拉第定律：$J = j / F$。\n- 通过一维胡克定律的线性弹性，将应力与抵抗本征应变的机械应变联系起来。\n- 反应影响层内的质量守恒，通过偏摩尔体积将通量散度与本征应变累积联系起来。\n\n每个测试用例的所需输出：\n- 一个指示接触的布尔值（使用字面值 True 或 False），通过 $T_{n} \\ge 0$ 进行评估。\n- 临界外部压力 $P_{\\mathrm{crit}}$（单位 $\\mathrm{Pa}$），作为一个浮点数值。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个形式为 $[ \\text{boolean}, \\text{float} ]$ 的双元素列表。例如：$[[\\text{True}, 123.0],[\\text{False}, 0.0]]$。\n\n使用以下测试套件，它涵盖了不同情况（正常路径、边界、带外部拉力的沉积、屈服限制的分离以及高压克服上限应力的接触）。所有量均以国际单位制（SI）处理：\n\n- 测试用例 1：$E = 5.0 \\times 10^{9} \\, \\mathrm{Pa}$，$h = 2.0 \\times 10^{-4} \\, \\mathrm{m}$，$\\Omega = 1.0 \\times 10^{-6} \\, \\mathrm{m^3/mol}$，$j = 5.0 \\times 10^{3} \\, \\mathrm{A/m^2}$，$t = 5.0 \\, \\mathrm{s}$，$P_{\\mathrm{ext}} = 8.0 \\times 10^{6} \\, \\mathrm{Pa}$，$\\sigma_{y} = 5.0 \\times 10^{7} \\, \\mathrm{Pa}$。\n- 测试用例 2（边界）：$E = 3.0 \\times 10^{10} \\, \\mathrm{Pa}$，$h = 1.0 \\times 10^{-4} \\, \\mathrm{m}$，$\\Omega = 1.0 \\times 10^{-6} \\, \\mathrm{m^3/mol}$，$j = 0.0 \\, \\mathrm{A/m^2}$，$t = 10.0 \\, \\mathrm{s}$，$P_{\\mathrm{ext}} = 0.0 \\, \\mathrm{Pa}$，$\\sigma_{y} = 1.0 \\times 10^{8} \\, \\mathrm{Pa}$。\n- 测试用例 3（带拉力的沉积）：$E = 2.0 \\times 10^{10} \\, \\mathrm{Pa}$，$h = 1.0 \\times 10^{-4} \\, \\mathrm{m}$，$\\Omega = 1.0 \\times 10^{-6} \\, \\mathrm{m^3/mol}$，$j = -5.0 \\times 10^{3} \\, \\mathrm{A/m^2}$，$t = 5.0 \\, \\mathrm{s}$，$P_{\\mathrm{ext}} = -1.0 \\times 10^{6} \\, \\mathrm{Pa}$，$\\sigma_{y} = 5.0 \\times 10^{7} \\, \\mathrm{Pa}$。\n- 测试用例 4（屈服限制的分离）：$E = 4.0 \\times 10^{10} \\, \\mathrm{Pa}$，$h = 1.0 \\times 10^{-4} \\, \\mathrm{m}$，$\\Omega = 1.0 \\times 10^{-6} \\, \\mathrm{m^3/mol}$，$j = 2.0 \\times 10^{4} \\, \\mathrm{A/m^2}$，$t = 10.0 \\, \\mathrm{s}$，$P_{\\mathrm{ext}} = 3.0 \\times 10^{6} \\, \\mathrm{Pa}$，$\\sigma_{y} = 5.0 \\times 10^{6} \\, \\mathrm{Pa}$。\n- 测试用例 5（带上限应力的高压接触）：$E = 3.0 \\times 10^{10} \\, \\mathrm{Pa}$，$h = 2.0 \\times 10^{-4} \\, \\mathrm{m}$，$\\Omega = 1.0 \\times 10^{-6} \\, \\mathrm{m^3/mol}$，$j = 1.5 \\times 10^{4} \\, \\mathrm{A/m^2}$，$t = 10.0 \\, \\mathrm{s}$，$P_{\\mathrm{ext}} = 1.2 \\times 10^{8} \\, \\mathrm{Pa}$，$\\sigma_{y} = 1.0 \\times 10^{8} \\, \\mathrm{Pa}$。\n\n在所有计算中使用法拉第常数 $F = 96485.33212 \\, \\mathrm{C/mol}$。角度单位不适用。所有涉及物理单位的输出必须以 $\\mathrm{Pa}$ 表示。您的程序必须生成上述单行输出，并且不得读取任何输入。",
            "solution": "问题陈述被评估为有效。它在科学上基于连续介质力学和电化学的既定原理，包括法拉第定律和线性弹性。该模型虽然简化为一维，但是对电池中固-固界面化学-力学耦合的一个合理解释。该问题是适定的，提供了计算唯一解所需的所有必要参数、常数和明确定义。语言客观精确，给定的数值在物理上是合理的。不存在矛盾、歧义或逻辑缺陷。\n\n解决方案首先推导拉伸化学应力 $\\sigma_{\\mathrm{chem}}$ 的解析表达式，然后用它来确定接触状态和临界压力 $P_{\\mathrm{crit}}$。\n\n首先，我们确定界面处锂的摩尔通量 $J$。根据法拉第定律，它与电流密度 $j$ 成正比，与法拉第常数 $F = 96485.33212 \\, \\mathrm{C/mol}$ 成反比。\n$$J = \\frac{j}{F}$$\n符号约定为 $j > 0$ 对应于剥离（锂去除），$j \\le 0$ 对应于沉积（锂沉积）或零电流。\n\n接下来，我们计算在时间 $t$ 内，厚度为 $h$ 的反应影响层中累积的体积本征应变 $\\epsilon_{\\mathrm{v}}^{\\star}$。此本征应变是由质量的增加或减少引起的。体积变化率与摩尔通量 $J$ 和锂的偏摩尔体积 $\\Omega$ 成正比。在厚度 $h$ 上，本征应变累积的速率近似为通量散度 $J/h$ 的函数。因此，累积的体积本征应变为：\n$$\\epsilon_{\\mathrm{v}}^{\\star} = \\frac{\\Omega J t}{h}$$\n代入 $J$ 的表达式：\n$$\\epsilon_{\\mathrm{v}}^{\\star} = \\frac{\\Omega j t}{F h}$$\n问题指明剥离（$j>0$）会引起负的本征应变（收缩）。因此，我们必须引入一个负号以符合此约定。在一维模型中，假设这种体积变化主要表现为垂直于界面的应变 $\\epsilon^{\\star}$。\n$$\\epsilon^{\\star} = - \\frac{\\Omega j t}{F h}$$\n\n这个本征应变 $\\epsilon^{\\star}$ 代表了材料在不受约束时会经历的应变。然而，周围的材料会机械地抵抗这种应变，从而引起一个大小相等、方向相反的机械应变 $\\epsilon_{\\mathrm{mech}}$，以保持兼容性（假设为刚性约束）。\n$$\\epsilon_{\\mathrm{mech}} = - \\epsilon^{\\star} = \\frac{\\Omega j t}{F h}$$\n\n根据一维胡克定律，这种机械应变在层内产生一个应力 $\\sigma_{\\mathrm{raw}}$，其中 $E$ 是杨氏模量。\n$$\\sigma_{\\mathrm{raw}} = E \\epsilon_{\\mathrm{mech}} = E \\left(\\frac{\\Omega j t}{F h}\\right)$$\n如果 $j > 0$（剥离），$\\sigma_{\\mathrm{raw}}$ 为正，表示拉伸应力。如果 $j \\le 0$（沉积或零电流），$\\sigma_{\\mathrm{raw}}$ 为非正值，表示压缩应力或零应力。问题将 $\\sigma_{\\mathrm{chem}}$ 定义为倾向于导致分离的*拉伸*化学应力的大小。因此，任何由沉积产生的压缩应力都无助于脱粘，在这种情况下 $\\sigma_{\\mathrm{chem}}$ 应为零。我们可以通过取 $\\sigma_{\\mathrm{raw}}$ 和 $0$ 的最大值来表示这一点。\n$$\\sigma_{\\mathrm{chem, uncapped}} = \\max\\left(0, E \\frac{\\Omega j t}{F h}\\right)$$\n\n问题进一步指出，由于非弹性机制，该拉伸化学应力被一个最大值 $\\sigma_{y}$ 所限制。这导致了有效拉伸化学应力 $\\sigma_{\\mathrm{chem}}$ 的最终表达式：\n$$\\sigma_{\\mathrm{chem}} = \\min(\\sigma_{\\mathrm{chem, uncapped}}, \\sigma_{y}) = \\min\\left( \\max\\left(0, E \\frac{\\Omega j t}{F h}\\right), \\sigma_{y} \\right)$$\n\n临界外部压力 $P_{\\mathrm{crit}}$ 被定义为刚好维持接触所需的压力。这种情况发生在外部压力恰好平衡拉伸化学应力时。\n$$P_{\\mathrm{crit}} = \\sigma_{\\mathrm{chem}}$$\n\n最后，评估接触准则。界面处的净法向牵引力 $T_{n}$ 是外部施加的压缩压力 $P_{\\mathrm{ext}}$ 与拉伸化学应力 $\\sigma_{\\mathrm{chem}}$ 之间的差值。\n$$T_{n} = P_{\\mathrm{ext}} - \\sigma_{\\mathrm{chem}}$$\n如果此净牵引力为非负（$T_{n} \\ge 0$），则界面保持接触，否则分离（$T_{n}  0$）。因此，接触状态是通过条件 $P_{\\mathrm{ext}} \\ge \\sigma_{\\mathrm{chem}}$ 评估的布尔值。\n\n每个测试用例的算法如下：\n1.  给定参数 $E$、$h$、$\\Omega$、$j$、$t$、$P_{\\mathrm{ext}}$ 和 $\\sigma_{y}$。\n2.  计算未设限的拉伸化学应力：$\\sigma_{\\mathrm{chem, uncapped}} = \\max\\left(0, E \\frac{\\Omega j t}{F h}\\right)$。\n3.  应用屈服上限以找到最终的拉伸化学应力和临界压力：$\\sigma_{\\mathrm{chem}} = P_{\\mathrm{crit}} = \\min(\\sigma_{\\mathrm{chem, uncapped}}, \\sigma_{y})$。\n4.  通过评估布尔表达式 $P_{\\mathrm{ext}} \\ge \\sigma_{\\mathrm{chem}}$ 来确定接触状态。\n5.  返回数对 $[\\text{接触状态}, P_{\\mathrm{crit}}]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes a 1D mechanical-chemical model of contact loss\n    in a Solid-State Battery to determine contact state and critical pressure.\n    \"\"\"\n\n    # Fundamental constant\n    F = 96485.33212  # Faraday constant in C/mol\n\n    # Test suite in SI units (Pa, m, m^3/mol, A/m^2, s)\n    test_cases = [\n        # Case 1: Happy path\n        # E, h, Omega, j, t, P_ext, sigma_y\n        (5.0e9, 2.0e-4, 1.0e-6, 5.0e3, 5.0, 8.0e6, 5.0e7),\n        # Case 2: Boundary (zero current)\n        (3.0e10, 1.0e-4, 1.0e-6, 0.0, 10.0, 0.0, 1.0e8),\n        # Case 3: Plating with external tension\n        (2.0e10, 1.0e-4, 1.0e-6, -5.0e3, 5.0, -1.0e6, 5.0e7),\n        # Case 4: Yield-limited separation\n        (4.0e10, 1.0e-4, 1.0e-6, 2.0e4, 10.0, 3.0e6, 5.0e6),\n        # Case 5: High-pressure contact with capped stress\n        (3.0e10, 2.0e-4, 1.0e-6, 1.5e4, 10.0, 1.2e8, 1.0e8),\n    ]\n\n    results = []\n    for case in test_cases:\n        E, h, Omega, j, t, P_ext, sigma_y = case\n\n        # Calculate the raw stress generated by the eigenstrain.\n        # This can be positive (tensile for stripping) or negative (compressive for plating).\n        if h > 0 and F > 0:\n            stress_raw = E * (Omega * j * t) / (F * h)\n        else:\n            # Avoid division by zero, though h is positive in all test cases.\n            stress_raw = 0.0\n\n        # The chemical stress causing separation is purely tensile.\n        # Compressive stress (j = 0) helps maintain contact, so its contribution to\n        # tensile separation stress is zero.\n        # We use np.maximum for clean handling of the max(0, x) operation.\n        stress_uncapped_tensile = np.maximum(0.0, stress_raw)\n\n        # Apply the physically motivated stress cap (e.g., yield stress).\n        # The stress cannot exceed sigma_y.\n        sigma_chem = np.minimum(stress_uncapped_tensile, sigma_y)\n\n        # The critical external pressure is the pressure needed to exactly balance\n        # the tensile chemical stress.\n        P_crit = sigma_chem\n\n        # Determine contact state. Contact is maintained if the external compressive\n        # pressure is greater than or equal to the tensile chemical stress.\n        # P_ext being positive is compressive. A negative P_ext is an external tensile load.\n        contact_state = (P_ext >= sigma_chem)\n\n        # Append the results for the current test case.\n        # The required output format is a list [boolean, float].\n        results.append([contact_state, P_crit])\n\n    # Format the final output string exactly as specified: [[True, 123.0],[False, 0.0]]\n    # str() on a list correctly formats it as \"[True, 123.0]\".\n    # We join these string representations with commas and enclose in brackets.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "真实的电池界面本质上是异质的，由导电性能各异的无数微观接触点组成，在模拟中，一个常见的简化方法是用单一的“平均”电阻来代表整个界面，但这可能导致严重偏差。本练习将结合解析推导与蒙特卡洛模拟，旨在量化这种简化所带来的误差。此练习将揭示在并联导电网络中对电阻和电导进行平均的根本区别，并突显了在模型中正确处理异质性的重要性。",
            "id": "3929409",
            "problem": "固态电池 (SSB) 的界面通过固态电解质和电极之间形成的异质接触来传导电流。在纯欧姆条件下，界面上的电压降与面积比界面电阻成正比。假设总界面面积被划分为 $N$ 个面积相等的微接触点。对于每个微接触点 $i \\in \\{1,\\dots,N\\}$，假设局部比界面电阻 $r_i$（单位为 $\\Omega \\cdot \\mathrm{m}^2$）是一个正随机变量。有一部分比例为 $f_{\\mathrm{loss}}$ 的微接触点是开路的（无接触），我们将其建模为 $r_i = +\\infty$（等效于零电导）。剩余比例为 $1 - f_{\\mathrm{loss}}$ 的微接触点的 $r_i$ 是从对数正态分布中独立抽取的，即 $\\ln r_i$ 服从均值为 $\\mu$、标准差为 $\\sigma$ 的正态分布，其中 $\\mu$ 和 $\\sigma$ 是实值参数。\n\n基本事实：\n- 界面上的欧姆定律为 $V = J \\, r_{\\mathrm{eq}}$，其中 $V$ 是电压（单位为 $\\mathrm{V}$），$J$ 是电流密度（单位为 $\\mathrm{A/m^2}$），$r_{\\mathrm{eq}}$ 是等效面积比电阻（单位为 $\\Omega \\cdot \\mathrm{m}^2$）。\n- 面积相等的微接触点的并联组合意味着\n$$\n\\frac{1}{r_{\\mathrm{eq}}} \\;=\\; \\frac{1}{N} \\sum_{i=1}^{N} \\frac{1}{r_i},\n$$\n并约定对于开路的微接触点，$1/(+\\infty) = 0$。\n\n许多自动化电池设计模型将分布式的 $r_i$ 替换为单一的集总面积比界面电阻 $r_{\\mathrm{single}}$，该值通常取非开路局部电阻的算术平均值，\n$$\nr_{\\mathrm{single}} \\;=\\; \\frac{1}{K} \\sum_{i=1}^{N} r_i \\,\\mathbf{1}\\{r_i  +\\infty\\},\n$$\n其中 $K$ 是非开路微接触点的数量，$\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n\n定义相对电压误差\n$$\n\\epsilon \\;=\\; \\frac{V_{\\mathrm{single}} - V_{\\mathrm{true}}}{V_{\\mathrm{true}}} \\;=\\; \\frac{J r_{\\mathrm{single}} - J r_{\\mathrm{eq}}}{J r_{\\mathrm{eq}}} \\;=\\; \\frac{r_{\\mathrm{single}}}{r_{\\mathrm{eq}}} - 1,\n$$\n该误差是无量纲的。假设对数正态分布的参数意味着有限矩的存在。\n\n任务：\n1. 从欧姆定律和上述的电阻并联关系出发，推导 $r_{\\mathrm{eq}}$ 的表达式，并证明当 $N$ 很大且微接触点状态相互独立时，大数定律意味着\n$$\n\\frac{1}{r_{\\mathrm{eq}}} \\;\\approx\\; (1 - f_{\\mathrm{loss}})\\,\\mathbb{E}\\!\\left[\\frac{1}{r}\\right],\n$$\n和\n$$\nr_{\\mathrm{single}} \\;\\approx\\; \\mathbb{E}[r],\n$$\n其中 $r$ 表示一个参数为 $(\\mu,\\sigma)$ 的对数正态随机变量，用于非开路的微接触点。利用对数正态分布的性质，得出相对误差 $\\epsilon$ 关于 $f_{\\mathrm{loss}}$ 和 $\\sigma$ 的闭式解析预测。\n\n2. 针对指定的有限 $N$ 值，实现一个 $r_{\\mathrm{eq}}$ 和 $r_{\\mathrm{single}}$ 的蒙特卡洛估计器，并使用上述定义为给定参数计算基于样本的 $\\epsilon$。将其与第 1 部分的解析预测进行比较。\n\n科学真实性要求：\n- 将 $r_i$ 视为面积比电阻，单位为 $\\Omega \\cdot \\mathrm{m}^2$。\n- 将 $J$ 视为电流密度，单位为 $\\mathrm{A/m^2}$。\n- 确保最终的数值输出是无量纲的小数。\n\n测试套件：\n提供一个程序，为下列每组参数计算基于样本的相对误差和大的 $N$ 值下的解析预测。使用固定的种子以确保可复现性，种子分别为 $s = 1, 2, 3, 4, 5$。对于每个测试用例，电流密度 $J$ 以 $\\mathrm{A/m^2}$ 表示，对数正态参数 $(\\mu,\\sigma)$ 以自然对数单位表示。\n\n- 用例 1 (一般情况，中等异质性): $N = 10000$, $\\mu = \\ln(10^{-4})$, $\\sigma = 0.5$, $f_{\\mathrm{loss}} = 0.10$, $J = 20$, 种子 $s=1$。\n- 用例 2 (近乎均匀的接触): $N = 5000$, $\\mu = \\ln(5 \\times 10^{-5})$, $\\sigma = 0.01$, $f_{\\mathrm{loss}} = 0.0$, $J = 10$, 种子 $s=2$。\n- 用例 3 (高度异质性与显著损失): $N = 20000$, $\\mu = \\ln(10^{-4})$, $\\sigma = 1.0$, $f_{\\mathrm{loss}} = 0.30$, $J = 15$, 种子 $s=3$。\n- 用例 4 (有限样本边缘情况): $N = 50$, $\\mu = \\ln(10^{-4})$, $\\sigma = 1.2$, $f_{\\mathrm{loss}} = 0.20$, $J = 5$, 种子 $s=4$。\n- 用例 5 (高损失比例): $N = 20000$, $\\mu = \\ln(10^{-4})$, $\\sigma = 0.8$, $f_{\\mathrm{loss}} = 0.95$, $J = 20$, 种子 $s=5$。\n\n答案规格：\n- 对于每个用例，输出一个包含两个浮点数的列表：$[\\epsilon_{\\mathrm{sample}}, \\epsilon_{\\mathrm{analytic}}]$。\n- 程序应生成单行输出，其中包含按上述用例顺序排列的结果，格式为用方括号括起来的逗号分隔列表，例如 $[[\\epsilon_1^{\\mathrm{sample}},\\epsilon_1^{\\mathrm{analytic}}],[\\epsilon_2^{\\mathrm{sample}},\\epsilon_2^{\\mathrm{analytic}}],\\dots]$。",
            "solution": "该问题要求在一个简化的固态电池界面模型中，推导相对电压误差 $\\epsilon$ 的解析表达式，并将其与数值蒙特卡洛模拟进行比较。问题陈述的验证已经完成，该问题被认为是有效的、有科学依据且定义明确的。我们现在开始进行解答。\n\n问题的核心在于对比计算界面等效面积比电阻的两种方法：一种是基于并联电导的物理正确模型 ($r_{\\mathrm{eq}}$)，另一种是基于局部电阻算术平均值的简化模型 ($r_{\\mathrm{single}}$)。\n\n相对电压误差定义为：\n$$\n\\epsilon = \\frac{V_{\\mathrm{single}} - V_{\\mathrm{true}}}{V_{\\mathrm{true}}}\n$$\n在纯欧姆条件下，$V = J r$，其中 $J$ 是电流密度。“真实”电压降对应于物理上正确的等效电阻 $r_{\\mathrm{eq}}$，因此 $V_{\\mathrm{true}} = J r_{\\mathrm{eq}}$。简化模型中的电压降为 $V_{\\mathrm{single}} = J r_{\\mathrm{single}}$。电流密度 $J$ 在整个界面上是恒定的，这使我们可以写出：\n$$\n\\epsilon = \\frac{J r_{\\mathrm{single}} - J r_{\\mathrm{eq}}}{J r_{\\mathrm{eq}}} = \\frac{r_{\\mathrm{single}}}{r_{\\mathrm{eq}}} - 1\n$$\n这表明相对电压误差与电流密度 $J$ 无关，仅取决于两个电阻值的比率。\n\n### 第 1 部分：大 $N$ 极限下的解析推导\n\n我们将使用大数定律 (LLN) 在大量微接触点 ($N \\to \\infty$) 的极限情况下，推导 $r_{\\mathrm{eq}}$ 和 $r_{\\mathrm{single}}$ 的表达式。\n\n**1. 等效电阻, $r_{\\mathrm{eq}}$**\n\n等效电阻 $r_{\\mathrm{eq}}$ 由所有 $N$ 个微接触点电导的并联组合定义。总电导是各个电导的总和。对于一个划分为 $N$ 个等面积微接触点的界面，单位面积的等效电导是单位面积局部电导的平均值。令 $g_i = 1/r_i$ 为局部面积比电导。\n$$\n\\frac{1}{r_{\\mathrm{eq}}} = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{1}{r_i} = \\frac{1}{N} \\sum_{i=1}^{N} g_i\n$$\n此表达式是随机变量 $g = 1/r$ 的样本均值。根据大数定律，当 $N \\to \\infty$ 时，样本均值收敛于期望值：\n$$\n\\frac{1}{r_{\\mathrm{eq}}} \\approx \\mathbb{E}[g] = \\mathbb{E}\\left[\\frac{1}{r}\\right]\n$$\n局部电阻 $r_i$ 服从一个混合分布：以概率 $f_{\\mathrm{loss}}$，$r_i = +\\infty$（因此 $g_i=0$）；以概率 $1-f_{\\mathrm{loss}}$，$r_i$ 从参数为 $(\\mu, \\sigma)$ 的对数正态分布中抽取。我们用 $r_{\\mathrm{log}} \\sim \\mathrm{Lognormal}(\\mu, \\sigma^2)$ 表示来自此对数正态部分的随机变量。期望值在整个概率空间上计算：\n$$\n\\mathbb{E}\\left[\\frac{1}{r}\\right] = P(r=+\\infty) \\cdot \\mathbb{E}\\left[\\frac{1}{r} \\middle| r=+\\infty\\right] + P(r+\\infty) \\cdot \\mathbb{E}\\left[\\frac{1}{r} \\middle| r+\\infty\\right]\n$$\n$$\n\\mathbb{E}\\left[\\frac{1}{r}\\right] = f_{\\mathrm{loss}} \\cdot (0) + (1-f_{\\mathrm{loss}}) \\cdot \\mathbb{E}\\left[\\frac{1}{r_{\\mathrm{log}}}\\right]\n$$\n因此，我们得到了第一个要求的结果：\n$$\n\\frac{1}{r_{\\mathrm{eq}}} \\approx (1-f_{\\mathrm{loss}}) \\, \\mathbb{E}\\left[\\frac{1}{r_{\\mathrm{log}}}\\right]\n$$\n\n**2. 单一集总电阻, $r_{\\mathrm{single}}$**\n\n简化电阻 $r_{\\mathrm{single}}$ 被定义为仅非开路（有限）局部电阻的算术平均值：\n$$\nr_{\\mathrm{single}} = \\frac{1}{K} \\sum_{i=1}^{N} r_i \\, \\mathbf{1}\\{r_i  +\\infty\\}\n$$\n其中 $K = \\sum_{i=1}^{N} \\mathbf{1}\\{r_i  +\\infty\\}$ 是导电微接触点的数量。这恰好是电阻在有限条件下的样本均值。根据大数定律，当样本数量 $K$ 变得很大时（当 $N \\to \\infty$ 且 $f_{\\mathrm{loss}}  1$ 时发生），该样本均值收敛于条件分布的期望值：\n$$\nr_{\\mathrm{single}} \\approx \\mathbb{E}[r | r  +\\infty] = \\mathbb{E}[r_{\\mathrm{log}}]\n$$\n这证实了第二个要求的结果。\n\n**3. 相对误差的解析表达式, $\\epsilon_{\\mathrm{analytic}}$**\n\n我们现在使用对数正态分布的性质来求期望值。如果 $X \\sim \\mathrm{Lognormal}(\\mu, \\sigma^2)$，那么它的 $k$ 阶矩由 $\\mathbb{E}[X^k] = e^{k\\mu + \\frac{1}{2}k^2\\sigma^2}$ 给出。对于我们的电阻 $r_{\\mathrm{log}}$：\n- 电阻的期望值 ($k=1$): $\\mathbb{E}[r_{\\mathrm{log}}] = e^{\\mu + \\frac{1}{2}\\sigma^2}$。\n- 电导的期望值 ($k=-1$): $\\mathbb{E}[1/r_{\\mathrm{log}}] = \\mathbb{E}[r_{\\mathrm{log}}^{-1}] = e^{-\\mu + \\frac{1}{2}(-1)^2\\sigma^2} = e^{-\\mu + \\frac{1}{2}\\sigma^2}$。\n\n将这些代入我们对 $r_{\\mathrm{single}}$ 和 $r_{\\mathrm{eq}}$ 的大 $N$ 近似中：\n$$\nr_{\\mathrm{single}} \\approx e^{\\mu + \\frac{1}{2}\\sigma^2}\n$$\n$$\n\\frac{1}{r_{\\mathrm{eq}}} \\approx (1 - f_{\\mathrm{loss}}) e^{-\\mu + \\frac{1}{2}\\sigma^2} \\quad \\implies \\quad r_{\\mathrm{eq}} \\approx \\frac{1}{(1-f_{\\mathrm{loss}}) e^{-\\mu + \\frac{1}{2}\\sigma^2}}\n$$\n现在，我们可以找到在大 $N$ 极限下相对误差 $\\epsilon_{\\mathrm{analytic}}$ 的解析表达式：\n$$\n\\epsilon_{\\mathrm{analytic}} = \\frac{r_{\\mathrm{single}}}{r_{\\mathrm{eq}}} - 1 \\approx \\left( e^{\\mu + \\frac{1}{2}\\sigma^2} \\right) \\left( (1 - f_{\\mathrm{loss}}) e^{-\\mu + \\frac{1}{2}\\sigma^2} \\right) - 1\n$$\n$$\n\\epsilon_{\\mathrm{analytic}} = (1 - f_{\\mathrm{loss}}) e^{(\\mu + \\frac{1}{2}\\sigma^2) + (-\\mu + \\frac{1}{2}\\sigma^2)} - 1\n$$\n$$\n\\epsilon_{\\mathrm{analytic}} = (1 - f_{\\mathrm{loss}}) e^{\\sigma^2} - 1\n$$\n这是最终的闭式预测。它仅取决于丢失接触点的比例 $f_{\\mathrm{loss}}$ 和对数电阻的方差 $\\sigma^2$，而与对数电阻的均值 $\\mu$ 无关。\n\n### 第 2 部分：蒙特卡洛模拟设计\n\n为了评估有限数量微接触点 $N$ 的系统，我们将实现一个蒙特卡洛模拟。\n\n**1. 模拟步骤**\n\n对于每个具有参数 $(N, \\mu, \\sigma, f_{\\mathrm{loss}})$ 和给定随机种子 $s$ 的测试用例：\n1. 使用种子 $s$ 初始化一个随机数生成器，以确保可复现性。\n2. 首先从对数正态分布 $\\mathrm{Lognormal}(\\mu, \\sigma^2)$ 中抽取 $N$ 个样本，生成一个包含 $N$ 个电阻值 $\\{r_i\\}$ 的数组。\n3. 模拟接触损失：对于 $N$ 个微接触点中的每一个，以概率 $f_{\\mathrm{loss}}$ 决定其是否为开路。这通过生成 $N$ 个均匀分布的随机数并与 $f_{\\mathrm{loss}}$ 比较来完成。设导电微接触点的集合为 $S$，其大小为 $K = |S|$。\n4. 计算基于样本的集总电阻 $r_{\\mathrm{single, sample}}$。这是 $K$ 个导电微接触点电阻的算术平均值。如果 $K=0$，这个量是未定义的；然而，对于给定的测试用例，$K > 0$ 的概率非常高。\n$$\nr_{\\mathrm{single, sample}} = \\frac{1}{K} \\sum_{i \\in S} r_i\n$$\n5. 计算基于样本的等效电阻 $r_{\\mathrm{eq, sample}}$。这是通过所有 $N$ 个位置上的平均电导得出的，其中开路位置的电导为零。\n$$\n\\frac{1}{r_{\\mathrm{eq, sample}}} = \\frac{1}{N} \\sum_{i=1}^N \\frac{1}{r_i} = \\frac{1}{N} \\sum_{i \\in S} \\frac{1}{r_i}\n$$\n6. 计算基于样本的相对误差 $\\epsilon_{\\mathrm{sample}}$。\n$$\n\\epsilon_{\\mathrm{sample}} = \\frac{r_{\\mathrm{single, sample}}}{r_{\\mathrm{eq, sample}}} - 1 = \\left( \\frac{1}{K} \\sum_{i \\in S} r_i \\right) \\left( \\frac{N}{\\sum_{i \\in S} 1/r_i} \\right) - 1\n$$\n一个计算上更稳健的形式是：\n$$\n\\epsilon_{\\mathrm{sample}} = \\frac{N}{K} \\frac{\\sum_{i \\in S} r_i}{\\sum_{i \\in S} 1/r_i} - 1\n$$\n这个表达式避免了中间出现过大或过小的数，并可直接实现。对于每个测试用例，我们计算这个 $\\epsilon_{\\mathrm{sample}}$，并将其与理论值 $\\epsilon_{\\mathrm{analytic}} = (1 - f_{\\mathrm{loss}}) e^{\\sigma^2} - 1$ 进行比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the sample-based and analytic relative voltage error for a\n    solid-state battery interface model across a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, mu, sigma, f_loss, J, seed)\n    # Note: J is provided for context but not used in the error calculation.\n    test_cases = [\n        (10000, np.log(1e-4), 0.5, 0.10, 20, 1),\n        (5000, np.log(5e-5), 0.01, 0.0, 10, 2),\n        (20000, np.log(1e-4), 1.0, 0.30, 15, 3),\n        (50, np.log(1e-4), 1.2, 0.20, 5, 4),\n        (20000, np.log(1e-4), 0.8, 0.95, 20, 5)\n    ]\n\n    results = []\n    for case in test_cases:\n        N, mu, sigma, f_loss, _, seed = case\n\n        # --- 1. Analytic Prediction ---\n        # The analytic relative error in the large-N limit is given by:\n        # epsilon_analytic = (1 - f_loss) * exp(sigma^2) - 1\n        epsilon_analytic = (1 - f_loss) * np.exp(sigma**2) - 1\n\n        # --- 2. Monte Carlo Simulation ---\n        # Initialize a random number generator with the specified seed for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # Generate N resistances from the specified lognormal distribution.\n        # This represents the population of potential microcontact resistances.\n        # r = exp(X), where X ~ N(mu, sigma^2)\n        log_r_population = rng.normal(loc=mu, scale=sigma, size=N)\n        r_population = np.exp(log_r_population)\n        \n        # Simulate contact loss. Each microcontact has an independent probability\n        # f_loss of being an open circuit (r_i = +inf, conductance = 0).\n        is_lost = rng.random(size=N)  f_loss\n        \n        # Isolate the resistances of the conducting (non-lost) microcontacts.\n        r_good_contacts = r_population[~is_lost]\n        \n        # K is the number of conducting microcontacts.\n        K = len(r_good_contacts)\n\n        if K == 0:\n            # If all contacts are lost, the equivalent resistance req is infinite.\n            # The simplified resistance r_single is ill-defined (mean of an empty set).\n            # The error is technically undefined. We can represent this failure case.\n            # However, for the given test cases, K will not be 0.\n            # A physically sensible limit for epsilon would be -1, as the true voltage\n            # becomes infinite while the simplified model is broken.\n            epsilon_sample = -1.0\n        else:\n            # Calculate r_single_sample: the arithmetic mean of good resistances.\n            r_single_sample = np.mean(r_good_contacts)\n\n            # Calculate r_eq_sample from the average conductance over all N sites.\n            # Conductance of lost sites is 0.\n            sum_inv_r_good = np.sum(1.0 / r_good_contacts)\n            avg_conductance = sum_inv_r_good / N\n            r_eq_sample = 1.0 / avg_conductance\n            \n            # The sample-based relative error is r_single / r_eq - 1.\n            epsilon_sample = r_single_sample / r_eq_sample - 1\n        \n        results.append([epsilon_sample, epsilon_analytic])\n\n    # Final print statement in the exact required format.\n    # The output is a list of lists, e.g., [[val1, val2], [val3, val4], ...]\n    # We construct the string representation manually for precise formatting.\n    output_str = \"[\" + \",\".join(f\"[{s},{a}]\" for s, a in results) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}