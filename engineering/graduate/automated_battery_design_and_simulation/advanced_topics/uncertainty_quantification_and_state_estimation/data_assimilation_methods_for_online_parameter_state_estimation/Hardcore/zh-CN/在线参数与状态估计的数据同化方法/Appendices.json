{
    "hands_on_practices": [
        {
            "introduction": "掌握数据同化技术的第一步是理解卡尔曼滤波器的核心机制。本练习将该滤波器分解为其两个基本步骤——预测和更新——并应用于一个简化的线性化电池模型。通过手动完成此计算 ，您将具体地体会到滤波器如何将模型预测与带噪声的测量值进行最优融合，从而精确地修正对电池状态的估计。",
            "id": "3903722",
            "problem": "一个锂离子电池在固定工作点附近被一个离散时间线性化的戴维南电阻-电容（RC）等效电路建模。状态向量为 $x_k = [x_{1,k}\\; x_{2,k}]^{\\top}$，其中 $x_{1,k}$ 是荷电状态（SOC）分数，而 $x_{2,k}$ 是RC过电位，单位为伏特。输入 $u_{k-1}$ 是施加的电流（放电为正），测量输出 $y_k$ 是预补偿欧姆压降后，端电压与工作点电压的偏差。该随机线性高斯状态空间模型为\n$$x_k = A x_{k-1} + B u_{k-1} + w_{k-1}, \\quad w_{k-1} \\sim \\mathcal{N}(0,Q),$$\n$$y_k = H x_k + v_k, \\quad v_k \\sim \\mathcal{N}(0,R),$$\n其中过程噪声和测量噪声是独立的。\n\n假设系统矩阵和噪声协方差的数值指定如下\n$$A = \\begin{bmatrix} 1  0 \\\\ 0  \\tfrac{1}{2} \\end{bmatrix}, \\quad B = \\begin{bmatrix} -\\tfrac{1}{10} \\\\ \\tfrac{1}{5} \\end{bmatrix}, \\quad H = \\begin{bmatrix} \\tfrac{3}{10}  -1 \\end{bmatrix},$$\n$$Q = \\begin{bmatrix} \\tfrac{1}{100}  0 \\\\ 0  \\tfrac{1}{25} \\end{bmatrix}, \\quad R = \\tfrac{9}{100}.$$\n\n在时间 $k-1$ 时，后验状态估计和协方差为\n$$x_{k-1}^{+} = \\begin{bmatrix} \\tfrac{1}{2} \\\\ \\tfrac{1}{5} \\end{bmatrix}, \\quad P_{k-1}^{+} = \\begin{bmatrix} \\tfrac{1}{25}  0 \\\\ 0  \\tfrac{9}{100} \\end{bmatrix}.$$\n在下一步中，施加的电流为 $u_{k-1} = 1$，测量的端电压偏差为 $y_k = -\\tfrac{1}{5}$。\n\n从线性高斯状态转移和观测模型以及高斯随机变量的标准概率条件化出发，执行一次完整的卡尔曼滤波器迭代（预测和更新），以获得在时间 $k$ 的后验状态 $x_k^{+}$ 和协方差 $P_k^{+}$。\n\n答案规格：\n- 以封闭形式提供精确值；不要四舍五入。\n- 将最终答案以单行矩阵的形式报告，顺序为 $[x_{1,k}^{+},\\, x_{2,k}^{+},\\, P_{11,k}^{+},\\, P_{12,k}^{+},\\, P_{21,k}^{+},\\, P_{22,k}^{+}]$。\n- 将 $x_{1,k}^{+}$ 表示为SOC分数，$x_{2,k}^{+}$ 的单位为伏特；协方差项的单位为相应的平方单位。在最终的方框答案中，不包括单位。",
            "solution": "卡尔曼滤波器算法包括两个相继的步骤：预测（时间更新）和校正（测量更新）。我们将执行一次完整的迭代。\n\n在时间 $k-1$ 时的后验状态估计及其协方差给出如下：\n$$x_{k-1}^{+} = \\begin{bmatrix} \\tfrac{1}{2} \\\\ \\tfrac{1}{5} \\end{bmatrix}, \\quad P_{k-1}^{+} = \\begin{bmatrix} \\tfrac{1}{25}  0 \\\\ 0  \\tfrac{9}{100} \\end{bmatrix}$$\n系统矩阵、输入和测量值如下：\n$$A = \\begin{bmatrix} 1  0 \\\\ 0  \\tfrac{1}{2} \\end{bmatrix}, \\quad B = \\begin{bmatrix} -\\tfrac{1}{10} \\\\ \\tfrac{1}{5} \\end{bmatrix}, \\quad H = \\begin{bmatrix} \\tfrac{3}{10}  -1 \\end{bmatrix}$$\n$$Q = \\begin{bmatrix} \\tfrac{1}{100}  0 \\\\ 0  \\tfrac{1}{25} \\end{bmatrix}, \\quad R = \\tfrac{9}{100}$$\n$$u_{k-1} = 1, \\quad y_k = -\\tfrac{1}{5}$$\n\n**1. 预测步骤**\n\n预测步骤将状态和协方差估计从步骤 $k-1$ 向前投影到步骤 $k$。\n\n首先，我们计算预测（先验）状态估计 $x_k^{-}$：\n$$x_k^{-} = A x_{k-1}^{+} + B u_{k-1}$$\n$$x_k^{-} = \\begin{bmatrix} 1  0 \\\\ 0  \\tfrac{1}{2} \\end{bmatrix} \\begin{bmatrix} \\tfrac{1}{2} \\\\ \\tfrac{1}{5} \\end{bmatrix} + \\begin{bmatrix} -\\tfrac{1}{10} \\\\ \\tfrac{1}{5} \\end{bmatrix} (1) = \\begin{bmatrix} \\tfrac{1}{2} \\\\ \\tfrac{1}{10} \\end{bmatrix} + \\begin{bmatrix} -\\tfrac{1}{10} \\\\ \\tfrac{2}{10} \\end{bmatrix} = \\begin{bmatrix} \\tfrac{4}{10} \\\\ \\tfrac{3}{10} \\end{bmatrix} = \\begin{bmatrix} \\tfrac{2}{5} \\\\ \\tfrac{3}{10} \\end{bmatrix}$$\n\n接下来，我们计算预测（先验）误差协方差 $P_k^{-}$：\n$$P_k^{-} = A P_{k-1}^{+} A^{\\top} + Q$$\n由于 $A$ 是一个对角矩阵，所以 $A^{\\top} = A$。\n$$P_k^{-} = \\begin{bmatrix} 1  0 \\\\ 0  \\tfrac{1}{2} \\end{bmatrix} \\begin{bmatrix} \\tfrac{1}{25}  0 \\\\ 0  \\tfrac{9}{100} \\end{bmatrix} \\begin{bmatrix} 1  0 \\\\ 0  \\tfrac{1}{2} \\end{bmatrix} + \\begin{bmatrix} \\tfrac{1}{100}  0 \\\\ 0  \\tfrac{1}{25} \\end{bmatrix}$$\n$$P_k^{-} = \\begin{bmatrix} \\tfrac{1}{25}  0 \\\\ 0  \\tfrac{9}{200} \\end{bmatrix} \\begin{bmatrix} 1  0 \\\\ 0  \\tfrac{1}{2} \\end{bmatrix} + \\begin{bmatrix} \\tfrac{1}{100}  0 \\\\ 0  \\tfrac{1}{25} \\end{bmatrix}$$\n$$P_k^{-} = \\begin{bmatrix} \\tfrac{1}{25}  0 \\\\ 0  \\tfrac{9}{400} \\end{bmatrix} + \\begin{bmatrix} \\tfrac{4}{100}  0 \\\\ 0  \\tfrac{16}{400} \\end{bmatrix} = \\begin{bmatrix} \\tfrac{5}{100}  0 \\\\ 0  \\tfrac{25}{400} \\end{bmatrix} = \\begin{bmatrix} \\tfrac{1}{20}  0 \\\\ 0  \\tfrac{1}{16} \\end{bmatrix}$$\n\n**2. 更新步骤**\n\n更新步骤使用新的测量值 $y_k$ 来校正预测的估计值。\n\n首先，我们计算卡尔曼增益 $K_k$。这需要新息协方差，$S_k = H P_k^{-} H^{\\top} + R$。\n$$P_k^{-} H^{\\top} = \\begin{bmatrix} \\tfrac{1}{20}  0 \\\\ 0  \\tfrac{1}{16} \\end{bmatrix} \\begin{bmatrix} \\tfrac{3}{10} \\\\ -1 \\end{bmatrix} = \\begin{bmatrix} \\tfrac{3}{200} \\\\ -\\tfrac{1}{16} \\end{bmatrix}$$\n$$H P_k^{-} H^{\\top} = \\begin{bmatrix} \\tfrac{3}{10}  -1 \\end{bmatrix} \\begin{bmatrix} \\tfrac{3}{200} \\\\ -\\tfrac{1}{16} \\end{bmatrix} = \\tfrac{9}{2000} + \\tfrac{1}{16} = \\tfrac{9}{2000} + \\tfrac{125}{2000} = \\tfrac{134}{2000} = \\tfrac{67}{1000}$$\n$$S_k = H P_k^{-} H^{\\top} + R = \\tfrac{67}{1000} + \\tfrac{9}{100} = \\tfrac{67}{1000} + \\tfrac{90}{1000} = \\tfrac{157}{1000}$$\n卡尔曼增益 $K_k$ 随后为：\n$$K_k = P_k^{-} H^{\\top} S_k^{-1} = \\begin{bmatrix} \\tfrac{3}{200} \\\\ -\\tfrac{1}{16} \\end{bmatrix} \\left(\\tfrac{1000}{157}\\right) = \\begin{bmatrix} \\tfrac{3 \\times 5}{157} \\\\ -\\tfrac{1000/16}{157} \\end{bmatrix} = \\begin{bmatrix} \\tfrac{15}{157} \\\\ -\\tfrac{125/2}{157} \\end{bmatrix} = \\begin{bmatrix} \\tfrac{15}{157} \\\\ -\\tfrac{125}{314} \\end{bmatrix}$$\n\n接下来，我们更新状态估计以获得后验（a posteriori）估计 $x_k^{+}$。这需要测量残差（新息），$y_k - H x_k^{-}$。\n$$H x_k^{-} = \\begin{bmatrix} \\tfrac{3}{10}  -1 \\end{bmatrix} \\begin{bmatrix} \\tfrac{2}{5} \\\\ \\tfrac{3}{10} \\end{bmatrix} = \\tfrac{6}{50} - \\tfrac{3}{10} = \\tfrac{6}{50} - \\tfrac{15}{50} = -\\tfrac{9}{50}$$\n新息为 $y_k - H x_k^{-} = -\\tfrac{1}{5} - (-\\tfrac{9}{50}) = -\\tfrac{10}{50} + \\tfrac{9}{50} = -\\tfrac{1}{50}$。\n$$x_k^{+} = x_k^{-} + K_k (y_k - H x_k^{-})$$\n$$x_k^{+} = \\begin{bmatrix} \\tfrac{2}{5} \\\\ \\tfrac{3}{10} \\end{bmatrix} + \\begin{bmatrix} \\tfrac{15}{157} \\\\ -\\tfrac{125}{314} \\end{bmatrix} \\left(-\\tfrac{1}{50}\\right) = \\begin{bmatrix} \\tfrac{2}{5} - \\tfrac{15}{157 \\times 50} \\\\ \\tfrac{3}{10} + \\tfrac{125}{314 \\times 50} \\end{bmatrix}$$\n$x_k^{+}$ 的分量为：\n$$x_{1,k}^{+} = \\tfrac{2}{5} - \\tfrac{3}{1570} = \\tfrac{2 \\times 314 - 3}{1570} = \\tfrac{628-3}{1570} = \\tfrac{625}{1570} = \\tfrac{125}{314}$$\n$$x_{2,k}^{+} = \\tfrac{3}{10} + \\tfrac{125}{15700} = \\tfrac{3}{10} + \\tfrac{5}{628} = \\tfrac{3 \\times 314 + 5 \\times 5}{3140} = \\tfrac{942+25}{3140} = \\tfrac{967}{3140}$$\n所以，$x_k^{+} = \\begin{bmatrix} \\tfrac{125}{314} \\\\ \\tfrac{967}{3140} \\end{bmatrix}$。\n\n最后，我们更新误差协方差以获得后验协方差 $P_k^{+}$。\n$$P_k^{+} = (I - K_k H) P_k^{-}$$\n$$I - K_k H = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} - \\begin{bmatrix} \\tfrac{15}{157} \\\\ -\\tfrac{125}{314} \\end{bmatrix} \\begin{bmatrix} \\tfrac{3}{10}  -1 \\end{bmatrix} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} - \\begin{bmatrix} \\tfrac{45}{1570}  -\\tfrac{15}{157} \\\\ -\\tfrac{375}{3140}  \\tfrac{125}{314} \\end{bmatrix}$$\n$$I - K_k H = \\begin{bmatrix} 1 - \\tfrac{9}{314}  \\tfrac{15}{157} \\\\ \\tfrac{375}{3140}  1 - \\tfrac{125}{314} \\end{bmatrix} = \\begin{bmatrix} \\tfrac{305}{314}  \\tfrac{30}{314} \\\\ \\tfrac{75}{628}  \\tfrac{189}{314} \\end{bmatrix}$$\n现在，乘以对角矩阵 $P_k^{-}$：\n$$P_k^{+} = \\begin{bmatrix} \\tfrac{305}{314}  \\tfrac{30}{314} \\\\ \\tfrac{75}{628}  \\tfrac{189}{314} \\end{bmatrix} \\begin{bmatrix} \\tfrac{1}{20}  0 \\\\ 0  \\tfrac{1}{16} \\end{bmatrix} = \\begin{bmatrix} \\tfrac{305}{314 \\times 20}  \\tfrac{30}{314 \\times 16} \\\\ \\tfrac{75}{628 \\times 20}  \\tfrac{189}{314 \\times 16} \\end{bmatrix}$$\n$P_k^{+}$ 的分量为：\n$$P_{11,k}^{+} = \\tfrac{305}{6280} = \\tfrac{61}{1256}$$\n$$P_{12,k}^{+} = \\tfrac{30}{5024} = \\tfrac{15}{2512}$$\n$$P_{21,k}^{+} = \\tfrac{75}{12560} = \\tfrac{15}{2512}$$\n$$P_{22,k}^{+} = \\tfrac{189}{5024}$$\n如预期，$P_k^{+}$ 是对称的，即 $P_{12,k}^{+} = P_{21,k}^{+}$。\n\n最终的后验状态和协方差为：\n$$x_k^{+} = \\begin{bmatrix} \\tfrac{125}{314} \\\\ \\tfrac{967}{3140} \\end{bmatrix}, \\quad P_k^{+} = \\begin{bmatrix} \\tfrac{61}{1256}  \\tfrac{15}{2512} \\\\ \\tfrac{15}{2512}  \\tfrac{189}{5024} \\end{bmatrix}$$\n所要求的输出是行矩阵 $[x_{1,k}^{+},\\, x_{2,k}^{+},\\, P_{11,k}^{+},\\, P_{12,k}^{+},\\, P_{21,k}^{+},\\, P_{22,k}^{+}]$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{125}{314}  \\frac{967}{3140}  \\frac{61}{1256}  \\frac{15}{2512}  \\frac{15}{2512}  \\frac{189}{5024}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "现实世界中的电池模型（例如，开路电压与荷电状态的关系）本质上是高度非线性的，这使得线性卡尔曼滤波器无法直接应用。本练习聚焦于扩展卡尔曼滤波器 (EKF) 的关键步骤：通过计算雅可比矩阵，在当前状态估计点对非线性模型进行局部线性化。此实践  将演示如何推导该矩阵，并阐明为何它是将滤波器的更新规则应用于非线性系统的基石。",
            "id": "3903746",
            "problem": "考虑一个在恒定温度下工作的单体锂离子电池，该电池被建模用于扩展卡尔曼滤波器（EKF）中的在线状态和参数估计。端电压的测量方程由开路电压和荷电状态之间的关系给出，并包含由内阻引起的欧姆压降：\n$$\nV_k = \\mathrm{OCV}(\\mathrm{SOC}_k) - R_k I_k + w_k,\n$$\n其中，$V_k$ 是在离散时间 $k$ 测得的端电压，$\\mathrm{SOC}_k$ 是荷电状态，$R_k$ 是欧姆电阻，$I_k$ 是施加的电流（放电为正），$w_k$ 是测量噪声。EKF 的测量函数为 $h(x_k,u_k) = \\mathrm{OCV}(\\mathrm{SOC}_k) - R_k I_k$，状态向量为 $x_k = \\begin{pmatrix} \\mathrm{SOC}_k \\\\ R_k \\end{pmatrix}$，输入为 $u_k = I_k$。\n\n从基于测量函数一阶泰勒展开的扩展卡尔曼滤波器线性化定义出发，利用偏导数 $\\frac{\\partial \\mathrm{OCV}}{\\partial \\mathrm{SOC}}$ 以及对 $R_k$ 和 $I_k$ 的函数依赖性，推导测量雅可比矩阵 $H_k = \\left.\\frac{\\partial h}{\\partial x}\\right|_{x=\\hat{x}_k^{-}}$。然后，对于给定的开路电压函数\n$$\n\\mathrm{OCV}(\\mathrm{SOC}) = 3.7 + 0.1\\,\\mathrm{SOC} + 0.05\\,\\mathrm{SOC}^{2} - 0.03\\,\\mathrm{SOC}^{3},\n$$\n在预测状态 $\\hat{x}_k^{-} = \\begin{pmatrix} \\hat{\\mathrm{SOC}}_k^{-} \\\\ \\hat{R}_k^{-} \\end{pmatrix} = \\begin{pmatrix} 0.60 \\\\ 0.050 \\end{pmatrix}$ 和施加电流 $I_k = 2.000$ 下，假设数值计算采用标准国际单位制（SI），计算 $H_k$ 的值。将 $H_k$ 的第一个条目以伏特/单位荷电状态表示，第二个条目以伏特/欧姆表示，并报告最终的数值行向量 $H_k$，结果四舍五入到四位有效数字。在最终的行向量中只提供数值，不带单位。",
            "solution": "测量雅可比矩阵 $H_k$ 定义为标量测量函数 $h$ 对状态向量 $x_k$ 的偏导数。由于状态向量 $x_k$ 有两个分量 $\\mathrm{SOC}_k$ 和 $R_k$，雅可比矩阵 $H_k$ 将是一个 $1 \\times 2$ 的行向量：\n$$\nH_k = \\left.\\begin{pmatrix} \\frac{\\partial h}{\\partial \\mathrm{SOC}_k}  \\frac{\\partial h}{\\partial R_k} \\end{pmatrix}\\right|_{x_k = \\hat{x}_k^{-}}\n$$\n测量函数为 $h(x_k, u_k) = \\mathrm{OCV}(\\mathrm{SOC}_k) - R_k I_k$。让我们计算每个偏导数。\n\n$H_k$ 的第一个分量是 $h$ 关于 $\\mathrm{SOC}_k$ 的偏导数：\n$$\n\\frac{\\partial h}{\\partial \\mathrm{SOC}_k} = \\frac{\\partial}{\\partial \\mathrm{SOC}_k} \\left( \\mathrm{OCV}(\\mathrm{SOC}_k) - R_k I_k \\right)\n$$\n由于项 $- R_k I_k$ 不依赖于 $\\mathrm{SOC}_k$，其关于 $\\mathrm{SOC}_k$ 的导数为零。因此，\n$$\n\\frac{\\partial h}{\\partial \\mathrm{SOC}_k} = \\frac{d\\mathrm{OCV}}{d\\mathrm{SOC}_k}\n$$\n$H_k$ 的第二个分量是 $h$ 关于 $R_k$ 的偏导数：\n$$\n\\frac{\\partial h}{\\partial R_k} = \\frac{\\partial}{\\partial R_k} \\left( \\mathrm{OCV}(\\mathrm{SOC}_k) - R_k I_k \\right)\n$$\n项 $\\mathrm{OCV}(\\mathrm{SOC}_k)$ 不依赖于 $R_k$，所以其导数为零。第二项的导数是：\n$$\n\\frac{\\partial h}{\\partial R_k} = -I_k\n$$\n结合这些结果，雅可比矩阵的符号表达式为：\n$$\nH_k = \\begin{pmatrix} \\frac{d\\mathrm{OCV}}{d\\mathrm{SOC}_k}  -I_k \\end{pmatrix}\n$$\n该矩阵必须在先验状态估计 $x_k = \\hat{x}_k^{-} = \\begin{pmatrix} \\hat{\\mathrm{SOC}}_k^{-} \\\\ \\hat{R}_k^{-} \\end{pmatrix}$ 处进行评估。\n\n现在，我们使用问题陈述中提供的 $\\mathrm{OCV}(\\mathrm{SOC})$ 的具体函数形式：\n$$\n\\mathrm{OCV}(\\mathrm{SOC}) = 3.7 + 0.1\\,\\mathrm{SOC} + 0.05\\,\\mathrm{SOC}^{2} - 0.03\\,\\mathrm{SOC}^{3}\n$$\n我们计算它关于 $\\mathrm{SOC}$ 的导数：\n$$\n\\frac{d\\mathrm{OCV}}{d\\mathrm{SOC}} = \\frac{d}{d\\mathrm{SOC}} \\left( 3.7 + 0.1\\,\\mathrm{SOC} + 0.05\\,\\mathrm{SOC}^{2} - 0.03\\,\\mathrm{SOC}^{3} \\right)\n$$\n$$\n\\frac{d\\mathrm{OCV}}{d\\mathrm{SOC}} = 0.1 + 2(0.05)\\,\\mathrm{SOC} - 3(0.03)\\,\\mathrm{SOC}^{2}\n$$\n$$\n\\frac{d\\mathrm{OCV}}{d\\mathrm{SOC}} = 0.1 + 0.1\\,\\mathrm{SOC} - 0.09\\,\\mathrm{SOC}^{2}\n$$\n我们需要在 $\\mathrm{SOC}_k = \\hat{\\mathrm{SOC}}_k^{-} = 0.60$ 处计算这个导数的值：\n$$\n\\left.\\frac{d\\mathrm{OCV}}{d\\mathrm{SOC}_k}\\right|_{\\hat{\\mathrm{SOC}}_k^{-}=0.60} = 0.1 + 0.1(0.60) - 0.09(0.60)^{2}\n$$\n$$\n= 0.1 + 0.06 - 0.09(0.36)\n$$\n$$\n= 0.16 - 0.0324\n$$\n$$\n= 0.1276\n$$\n$H_k$ 的第一个条目是 $0.1276$。单位是伏特/单位荷电状态。\n\n$H_k$ 的第二个条目是 $-I_k$。我们已知 $I_k = 2.000$ 安培。\n$$\n-I_k = -2.000\n$$\n$H_k$ 的第二个条目是 $-2.000$。单位是伏特/欧姆，等效于安培。\n\n组合成数值雅可比矩阵 $H_k$：\n$$\nH_k = \\begin{pmatrix} 0.1276  -2.000 \\end{pmatrix}\n$$\n问题要求最终答案四舍五入到四位有效数字。\n第一个值 $0.1276$ 有四位有效数字。\n第二个值 $-2.000$ 有四位有效数字。\n因此，不需要进一步的四舍五入。$H_k$ 的最终数值行向量是 $\\begin{pmatrix} 0.1276  -2.000 \\end{pmatrix}$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.1276  -2.000\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "现在，我们将探讨一个更高级且极为实用的挑战：任何滤波器的性能都严重依赖于对过程噪声和测量噪声（即协方差矩阵 $Q$ 和 $R$）的准确建模，但这些参数在实际应用中通常是未知的。本练习  介绍了一种基于期望最大化 (EM) 算法与状态平滑器相结合的优雅解决方案。您将实现一个能够直接从测量数据中“学习”噪声协方差的系统，这展示了构建能够适应真实世界条件的、鲁棒的自适应滤波器的关键技术。",
            "id": "3903741",
            "problem": "考虑在自动化电池仿真中使用的离散时间线性随机状态空间模型中，对过程噪声协方差和测量噪声协方差进行在线估计。该模型是锂离子电池双态等效电路模型 (ECM) 在固定工作点附近的线性化。其离散时间动力学和测量方程如下：\n$$\n\\mathbf{x}_{k+1} = \\mathbf{A}\\,\\mathbf{x}_k + \\mathbf{B}\\,u_k + \\mathbf{w}_k,\\quad \\mathbf{w}_k \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{Q}),\n$$\n$$\ny_k = \\mathbf{H}\\,\\mathbf{x}_k + \\mathbf{D}\\,u_k + v_k,\\quad v_k \\sim \\mathcal{N}(0, R),\n$$\n其中 $\\mathbf{x}_k \\in \\mathbb{R}^2$ 表示状态向量，包含荷电状态和一个一阶电阻-电容 (RC) 对电压；$u_k \\in \\mathbb{R}$ 表示施加的电流（视为已知输入）；$y_k \\in \\mathbb{R}$ 表示端电压测量值；$\\mathbf{w}_k$ 是过程噪声，其协方差为 $\\mathbf{Q} \\in \\mathbb{R}^{2 \\times 2}$；$v_k$ 是测量噪声，其方差为 $R \\in \\mathbb{R}$。矩阵 $\\mathbf{A} \\in \\mathbb{R}^{2 \\times 2}$、$\\mathbf{B} \\in \\mathbb{R}^{2 \\times 1}$、$\\mathbf{H} \\in \\mathbb{R}^{1 \\times 2}$ 和 $\\mathbf{D} \\in \\mathbb{R}^{1 \\times 1}$ 对于每个测试用例都是已知且固定的。初始状态 $\\mathbf{x}_0$ 及其协方差 $\\mathbf{P}_0$ 是给定的。\n\n目标是使用从 Rauch–Tung–Striebel (RTS) 平滑器获得的平滑残差来计算更新后的 $\\mathbf{Q}$ 和 $R$，并迭代直至收敛。收敛性通过 $\\mathbf{Q}$ 和 $R$ 的相对 Frobenius 范数变化以及检查最后几次迭代中新息对数似然的单调非递减性来评估。具体来说，每次更新后：\n- 计算相对变化\n$$\n\\delta_Q = \\frac{\\|\\mathbf{Q}_{\\text{new}} - \\mathbf{Q}_{\\text{old}}\\|_F}{\\max(\\|\\mathbf{Q}_{\\text{old}}\\|_F, \\epsilon)},\\quad\n\\delta_R = \\frac{|R_{\\text{new}} - R_{\\text{old}}|}{\\max(|R_{\\text{old}}|, \\epsilon)},\n$$\n其中 $\\epsilon = 10^{-12}$。\n- 定义容差 $\\tau = 0.05$ 和最大迭代次数 $N_{\\text{max}} = 60$。\n- 收敛定义为 $\\delta_Q \\le \\tau$ 和 $\\delta_R \\le \\tau$，并且在最后 $5$ 次迭代中新息对数似然非递减（在数值容差范围内允许完全相等）。\n\n您必须使用 RTS 平滑器计算的平滑残差来实现期望最大化 (EM) 算法。在期望步骤 (Expectation step) 中，运行卡尔曼滤波器 (Kalman Filter, KF)，然后是 RTS 平滑器，以获得平滑均值、协方差和滞后一阶协方差。在最大化步骤 (Maximization step) 中，使用残差的期望充分统计量来更新 $\\mathbf{Q}$ 和 $R$：\n- 定义一步状态残差 $\\mathbf{r}_k^{(x)} = \\mathbf{x}_{k+1} - \\mathbf{A}\\,\\mathbf{x}_k - \\mathbf{B}\\,u_k$ 和测量残差 $r_k^{(y)} = y_k - \\mathbf{H}\\,\\mathbf{x}_k - \\mathbf{D}\\,u_k$。使用平滑期望来构建\n$$\n\\mathbf{Q}_{\\text{new}} = \\frac{1}{T-1} \\sum_{k=0}^{T-2} \\mathbb{E}\\left[\\mathbf{r}_k^{(x)}\\mathbf{r}_k^{(x)\\top}\\,\\big|\\, y_{0:T-1}\\right],\n$$\n$$\nR_{\\text{new}} = \\frac{1}{T} \\sum_{k=0}^{T-1} \\mathbb{E}\\left[r_k^{(y)}r_k^{(y)}\\,\\big|\\, y_{0:T-1}\\right].\n$$\n这些期望必须根据平滑均值和协方差计算，包括滞后一阶协方差 $\\mathrm{Cov}(\\mathbf{x}_k,\\mathbf{x}_{k+1}\\,|\\,y_{0:T-1})$。\n\n为了在数据同化中进行模型评估，每次迭代时使用 KF 计算新息对数似然，\n$$\n\\mathcal{L} = -\\frac{1}{2} \\sum_{k=0}^{T-1} \\left( \\log\\left((2\\pi)^m \\det \\mathbf{S}_k\\right) + \\mathbf{e}_k^\\top \\mathbf{S}_k^{-1} \\mathbf{e}_k \\right),\n$$\n其中 $\\mathbf{e}_k = y_k - \\mathbf{H}\\,\\hat{\\mathbf{x}}_{k|k-1} - \\mathbf{D}\\,u_k$ 是新息，$\\hat{\\mathbf{x}}_{k|k-1}$ 是一步预测均值，$\\mathbf{S}_k = \\mathbf{H}\\,\\mathbf{P}_{k|k-1}\\,\\mathbf{H}^\\top + R$ 是新息协方差，而 $m = 1$ 是测量维度。\n\n请实现上述算法，并将其应用于以下测试套件。对于每个测试用例，使用给定的真实协方差和固定的伪随机种子模拟一个数据集。然后，从 $\\mathbf{Q}$ 和 $R$ 的一个通用初始猜测值开始，运行 EM 更新，直到收敛或达到最大迭代次数。对于每种情况，输出一个布尔值，指示是否根据上述标准达到了收敛。\n\n所有用例的通用初始条件和初始猜测值：\n- 初始状态均值 $\\mathbf{x}_0 = \\begin{bmatrix} 0.5 \\\\ 0.0 \\end{bmatrix}$。\n- 初始状态协方差 $\\mathbf{P}_0 = \\begin{bmatrix} 10^{-4}  0 \\\\ 0  10^{-3} \\end{bmatrix}$。\n- 初始猜测值 $\\mathbf{Q}^{(0)} = \\begin{bmatrix} 10^{-5}  0 \\\\ 0  10^{-3} \\end{bmatrix}$ 和 $R^{(0)} = 10^{-2}$。\n\n使用输入电流序列\n$$\nu_k = 0.5 + \\sin(0.03\\,k) + 0.1\\,\\sin(0.005\\,k^2),\\quad k = 0,1,\\dots,T-1,\n$$\n该序列是确定性的。\n\n测试用例 1（理想路径，中等噪声）：\n- 长度 $T = 200$。\n- 矩阵\n$$\n\\mathbf{A} = \\begin{bmatrix} 1  0 \\\\ 0  0.98 \\end{bmatrix},\\quad\n\\mathbf{B} = \\begin{bmatrix} -0.001 \\\\ 0.02 \\end{bmatrix},\\quad\n\\mathbf{H} = \\begin{bmatrix} 0.1  1.0 \\end{bmatrix},\\quad\n\\mathbf{D} = \\begin{bmatrix} -0.05 \\end{bmatrix}.\n$$\n- 真实协方差\n$$\n\\mathbf{Q}_{\\text{true}} = \\begin{bmatrix} 10^{-6}  0 \\\\ 0  10^{-4} \\end{bmatrix},\\quad R_{\\text{true}} = 10^{-3}.\n$$\n- 随机种子 $7$。\n\n测试用例 2（边界情况，过程噪声非常小）：\n- 长度 $T = 150$。\n- $\\mathbf{A}$、$\\mathbf{B}$、$\\mathbf{H}$、$\\mathbf{D}$ 与测试用例 1 相同。\n- 真实协方差\n$$\n\\mathbf{Q}_{\\text{true}} = \\begin{bmatrix} 10^{-9}  0 \\\\ 0  10^{-6} \\end{bmatrix},\\quad R_{\\text{true}} = 5\\times 10^{-4}.\n$$\n- 随机种子 $11$。\n\n测试用例 3（边缘情况，测量噪声大）：\n- 长度 $T = 250$。\n- $\\mathbf{A}$、$\\mathbf{B}$、$\\mathbf{H}$、$\\mathbf{D}$ 与测试用例 1 相同。\n- 真实协方差\n$$\n\\mathbf{Q}_{\\text{true}} = \\begin{bmatrix} 5\\times 10^{-6}  0 \\\\ 0  2\\times 10^{-4} \\end{bmatrix},\\quad R_{\\text{true}} = 5\\times 10^{-2}.\n$$\n- 随机种子 $19$。\n\n每个用例的模拟流程：\n- 从 $\\mathbf{x}_0$ 开始，使用给定的 $\\mathbf{A}$、$\\mathbf{B}$、$\\mathbf{Q}_{\\text{true}}$ 和输入 $u_k$，通过真实动力学递归生成 $\\mathbf{x}_{k+1}$，其中 $\\mathbf{w}_k$ 使用指定的种子从 $\\mathcal{N}(\\mathbf{0}, \\mathbf{Q}_{\\text{true}})$ 采样。\n- 使用 $\\mathbf{H}$、$\\mathbf{D}$ 和 $R_{\\text{true}}$，通过测量方程生成 $y_k$，其中 $v_k$ 使用指定的种子从 $\\mathcal{N}(0, R_{\\text{true}})$ 采样。\n\n算法要求：\n- 使用卡尔曼滤波器 (KF) 和 Rauch–Tung–Striebel (RTS) 平滑器计算用于 EM 更新的平滑均值 $\\mathbb{E}[\\mathbf{x}_k \\mid y_{0:T-1}]$、平滑协方差 $\\mathrm{Cov}(\\mathbf{x}_k \\mid y_{0:T-1})$ 和滞后一阶协方差 $\\mathrm{Cov}(\\mathbf{x}_k,\\mathbf{x}_{k+1} \\mid y_{0:T-1})$。\n- 通过对称化和必要时的特征值裁剪，确保更新后的 $\\mathbf{Q}$ 和 $R$ 保持对称正定。\n- 在每次迭代中，使用当前的 $\\mathbf{Q}$ 和 $R$ 通过 KF 计算新息对数似然。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$），每个结果都是一个布尔值，指示相应测试用例是否满足收敛标准。\n\n本问题不需要物理单位。不使用角度。不使用百分比。",
            "solution": "该解决方案涉及实现期望最大化 (EM) 算法，以迭代地优化过程噪声协方差 $\\mathbf{Q}$ 和测量噪声方差 $R$ 的估计值。每次迭代包括两个步骤：期望 (E) 步骤和最大化 (M) 步骤。\n\n**1. 状态空间模型和数据模拟**\n\n首先，对于每个测试用例，我们根据提供的真实模型生成一个长度为 $T$ 的合成数据集。离散时间线性状态空间模型由下式给出：\n$$\n\\mathbf{x}_{k+1} = \\mathbf{A}\\,\\mathbf{x}_k + \\mathbf{B}\\,u_k + \\mathbf{w}_k, \\quad \\mathbf{w}_k \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{Q}_{\\text{true}})\n$$\n$$\ny_k = \\mathbf{H}\\,\\mathbf{x}_k + \\mathbf{D}\\,u_k + v_k, \\quad v_k \\sim \\mathcal{N}(0, R_{\\text{true}})\n$$\n从给定的初始状态 $\\mathbf{x}_0$ 开始，我们递归地生成状态序列 $\\{\\mathbf{x}_k\\}_{k=1}^{T-1}$ 和测量序列 $\\{y_k\\}_{k=0}^{T-1}$。过程噪声 $\\mathbf{w}_k$ 和测量噪声 $v_k$ 是使用固定的伪随机种子从各自的零均值高斯分布中抽取的，其真实协方差分别为 $\\mathbf{Q}_{\\text{true}}$ 和 $R_{\\text{true}}$，以确保可复现性。输入序列 $u_k$ 是确定性的。这个模拟数据集 $\\{y_k, u_k\\}_{k=0}^{T-1}$ 是该估计问题的“观测数据”。\n\n**2. 期望最大化 (EM) 算法**\n\nEM 算法旨在找到使观测数据的对数似然最大化的参数（$\\mathbf{Q}$，$R$）。它通过迭代地最大化完整数据对数似然的期望来实现这一目标，其中隐藏状态 $\\{\\mathbf{x}_k\\}$ 被视为缺失数据。\n\n**2.1. E-步骤：状态平滑**\n\n在 E-步骤中，给定当前参数估计值 $\\mathbf{Q}^{(i)}$ 和 $R^{(i)}$，我们在给定观测测量值 $y_{0:T-1}$ 的条件下，计算完整数据的充分统计量的条件期望。对于线性高斯模型，这些统计量是平滑状态均值和协方差的函数。我们使用一个两遍过程来计算它们：\n\n**a) 卡尔曼滤波器（前向传递）：** 卡尔曼滤波器 (KF) 处理从 $k=0$ 到 $T-1$ 的数据。它递归地计算滤波后的状态估计 $\\hat{\\mathbf{x}}_{k|k} = \\mathbb{E}[\\mathbf{x}_k | y_{0:k}]$ 及其协方差 $\\mathbf{P}_{k|k} = \\mathrm{Cov}(\\mathbf{x}_k | y_{0:k})$。关键步骤如下：\n-   **初始化：** $\\hat{\\mathbf{x}}_{0|-1} = \\mathbf{x}_0$，$\\mathbf{P}_{0|-1} = \\mathbf{P}_0$。\n-   **预测：** 对于 $k=0, \\dots, T-1$：\n    $$\n    \\hat{\\mathbf{x}}_{k|k-1} = \\mathbf{A}\\,\\hat{\\mathbf{x}}_{k-1|k-1} + \\mathbf{B}\\,u_{k-1} \\quad (\\text{for } k>0)\n    $$\n    $$\n    \\mathbf{P}_{k|k-1} = \\mathbf{A}\\,\\mathbf{P}_{k-1|k-1}\\,\\mathbf{A}^\\top + \\mathbf{Q}^{(i)} \\quad (\\text{for } k>0)\n    $$\n-   **更新：**\n    $$\n    \\mathbf{e}_k = y_k - (\\mathbf{H}\\,\\hat{\\mathbf{x}}_{k|k-1} + \\mathbf{D}\\,u_k)\n    $$\n    $$\n    S_k = \\mathbf{H}\\,\\mathbf{P}_{k|k-1}\\,\\mathbf{H}^\\top + R^{(i)}\n    $$\n    $$\n    \\mathbf{K}_k = \\mathbf{P}_{k|k-1}\\,\\mathbf{H}^\\top S_k^{-1}\n    $$\n    $$\n    \\hat{\\mathbf{x}}_{k|k} = \\hat{\\mathbf{x}}_{k|k-1} + \\mathbf{K}_k \\mathbf{e}_k\n    $$\n    $$\n    \\mathbf{P}_{k|k} = (\\mathbf{I} - \\mathbf{K}_k \\mathbf{H})\\mathbf{P}_{k|k-1}\n    $$\nKF 还得出新息对数似然，用于监控收敛：\n$$\n\\mathcal{L}(\\mathbf{Q}^{(i)}, R^{(i)}) = -\\frac{1}{2} \\sum_{k=0}^{T-1} \\left( \\log(2\\pi S_k) + \\frac{\\mathbf{e}_k^2}{S_k} \\right)\n$$\n所有预测和滤波后的量（$\\hat{\\mathbf{x}}_{k|k-1}, \\mathbf{P}_{k|k-1}, \\hat{\\mathbf{x}}_{k|k}, \\mathbf{P}_{k|k}$），对于 $k=0, \\dots, T-1$，都会被存储起来，用于后向传递。\n\n**b) Rauch–Tung–Striebel (RTS) 平滑器（后向传递）：** RTS 平滑器使用 KF 的结果来计算以整个数据序列为条件的平滑估计。它从 $k=T-1$ 反向运行到 $0$。令 $\\hat{\\mathbf{x}}_{k|T-1} \\equiv \\hat{\\mathbf{x}}_k^s$ 且 $\\mathbf{P}_{k|T-1} \\equiv \\mathbf{P}_k^s$。\n-   **初始化：** $\\hat{\\mathbf{x}}_{T-1}^s = \\hat{\\mathbf{x}}_{T-1|T-1}$，$\\mathbf{P}_{T-1}^s = \\mathbf{P}_{T-1|T-1}$。\n-   **后向递归：** 对于 $k=T-2, \\dots, 0$：\n    $$\n    \\mathbf{J}_k = \\mathbf{P}_{k|k}\\,\\mathbf{A}^\\top \\mathbf{P}_{k+1|k}^{-1}\n    $$\n    $$\n    \\hat{\\mathbf{x}}_k^s = \\hat{\\mathbf{x}}_{k|k} + \\mathbf{J}_k(\\hat{\\mathbf{x}}_{k+1}^s - \\hat{\\mathbf{x}}_{k+1|k})\n    $$\n    $$\n    \\mathbf{P}_k^s = \\mathbf{P}_{k|k} + \\mathbf{J}_k(\\mathbf{P}_{k+1}^s - \\mathbf{P}_{k+1|k})\\mathbf{J}_k^\\top\n    $$\n平滑器还计算平滑的滞后一阶互协方差，$\\mathbf{P}_{k+1,k|T-1} \\equiv \\mathbf{P}_{k+1,k}^s = \\mathrm{Cov}(\\mathbf{x}_{k+1}, \\mathbf{x}_k | y_{0:T-1})$，这对于 $\\mathbf{Q}$ 的更新至关重要：\n$$\n\\mathbf{P}_{k+1,k}^s = \\mathbf{P}_{k+1}^s \\mathbf{J}_k^\\top\n$$\n\n**2.2. M-步骤：参数更新**\n\n在 M-步骤中，我们使用 E-步骤得到的平滑统计量来更新参数 $\\mathbf{Q}$ 和 $R$，以最大化期望的完整数据对数似然。更新方程如下：\n$$\n\\mathbf{Q}^{(i+1)} = \\frac{1}{T-1} \\sum_{k=0}^{T-2} \\mathbb{E}\\left[(\\mathbf{x}_{k+1} - \\mathbf{A}\\mathbf{x}_k - \\mathbf{B}u_k)(\\mathbf{x}_{k+1} - \\mathbf{A}\\mathbf{x}_k - \\mathbf{B}u_k)^\\top \\mid y_{0:T-1}\\right]\n$$\n$$\nR^{(i+1)} = \\frac{1}{T} \\sum_{k=0}^{T-1} \\mathbb{E}\\left[(y_k - \\mathbf{H}\\mathbf{x}_k - \\mathbf{D}u_k)^2 \\mid y_{0:T-1}\\right]\n$$\n利用平滑估计的性质展开这些期望，可得：\n$$\n\\mathbf{Q}^{(i+1)} = \\frac{1}{T-1} \\sum_{k=0}^{T-2} \\left[ (\\hat{\\mathbf{x}}_{k+1}^s - \\mathbf{A}\\hat{\\mathbf{x}}_k^s - \\mathbf{B}u_k)(\\hat{\\mathbf{x}}_{k+1}^s - \\mathbf{A}\\hat{\\mathbf{x}}_k^s - \\mathbf{B}u_k)^\\top + \\boldsymbol{\\Gamma}_k \\right]\n$$\n其中 $\\boldsymbol{\\Gamma}_k = \\mathbf{P}_{k+1}^s + \\mathbf{A}\\mathbf{P}_k^s\\mathbf{A}^\\top - \\mathbf{A}(\\mathbf{P}_{k+1,k}^s)^\\top - \\mathbf{P}_{k+1,k}^s\\mathbf{A}^\\top$。\n对于测量方差：\n$$\nR^{(i+1)} = \\frac{1}{T} \\sum_{k=0}^{T-1} \\left[ (y_k - \\mathbf{H}\\hat{\\mathbf{x}}_k^s - \\mathbf{D}u_k)^2 + \\mathbf{H}\\mathbf{P}_k^s\\mathbf{H}^\\top \\right]\n$$\n\n为确保数值稳定性和物理意义，更新后的协方差矩阵必须是对称半正定的。$\\mathbf{Q}^{(i+1)}$ 通过 $\\mathbf{Q} \\leftarrow (\\mathbf{Q} + \\mathbf{Q}^\\top)/2$ 进行对称化。然后，计算其特征值，任何小于一个小的正下限（例如 $10^{-15}$）的特征值都将被替换为该下限，然后重新构造矩阵。$R^{(i+1)}$ 同样被限制在同一个小的下限值。\n\n**3. 迭代和收敛**\n\n重复 E 和 M 步骤，直到满足收敛标准或达到最大迭代次数 $N_{\\text{max}} = 60$。在第 $i$ 次迭代时的收敛由三个条件定义：\n1.  $\\mathbf{Q}$ 的相对变化小于容差 $\\tau = 0.05$：$\\frac{\\|\\mathbf{Q}^{(i)} - \\mathbf{Q}^{(i-1)}\\|_F}{\\max(\\|\\mathbf{Q}^{(i-1)}\\|_F, \\epsilon)} \\le \\tau$。\n2.  $R$ 的相对变化小于容差：$\\frac{|R^{(i)} - R^{(i-1)}|}{\\max(|R^{(i-1)}|, \\epsilon)} \\le \\tau$。\n3.  在最近五次迭代中（从 $i-4$ 到 $i$，要求 $i \\ge 4$），新息对数似然是单调非递减的：对于 $j=i-3, \\dots, i$，有 $\\mathcal{L}^{(j)} \\ge \\mathcal{L}^{(j-1)}$，允许有小的数值容差。\n\n该过程应用于每个测试用例，从指定的初始猜测值 $\\mathbf{Q}^{(0)}$ 和 $R^{(0)}$ 开始，并记录表示是否达到收敛的布尔结果。",
            "answer": "```python\nimport numpy as np\nfrom numpy.linalg import inv, norm, eigh\n\ndef solve():\n    \"\"\"\n    Main solver function to run EM algorithm on all test cases and print results.\n    \"\"\"\n    \n    # Common parameters for all test cases\n    x0 = np.array([0.5, 0.0])\n    P0 = np.array([[1e-4, 0], [0, 1e-3]])\n    Q_init = np.array([[1e-5, 0], [0, 1e-3]])\n    R_init = 1e-2\n    \n    # Common system matrices for all test cases\n    A = np.array([[1.0, 0.0], [0.0, 0.98]])\n    B = np.array([[-0.001], [0.02]])\n    H = np.array([[0.1, 1.0]])\n    D = np.array([[-0.05]])\n    \n    test_cases = [\n        # Case 1\n        {\n            \"T\": 200, \"A\": A, \"B\": B, \"H\": H, \"D\": D, \"x0\": x0, \"P0\": P0,\n            \"Q_true\": np.array([[1e-6, 0], [0, 1e-4]]),\n            \"R_true\": 1e-3, \"seed\": 7,\n            \"Q_init\": Q_init, \"R_init\": R_init\n        },\n        # Case 2\n        {\n            \"T\": 150, \"A\": A, \"B\": B, \"H\": H, \"D\": D, \"x0\": x0, \"P0\": P0,\n            \"Q_true\": np.array([[1e-9, 0], [0, 1e-6]]),\n            \"R_true\": 5e-4, \"seed\": 11,\n            \"Q_init\": Q_init, \"R_init\": R_init\n        },\n        # Case 3\n        {\n            \"T\": 250, \"A\": A, \"B\": B, \"H\": H, \"D\": D, \"x0\": x0, \"P0\": P0,\n            \"Q_true\": np.array([[5e-6, 0], [0, 2e-4]]),\n            \"R_true\": 5e-2, \"seed\": 19,\n            \"Q_init\": Q_init, \"R_init\": R_init\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        converged = run_em_for_case(case)\n        results.append(converged)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef simulate_data(params):\n    \"\"\"Generates synthetic data from the state-space model.\"\"\"\n    T, A, B, H, D = params[\"T\"], params[\"A\"], params[\"B\"], params[\"H\"], params[\"D\"]\n    x0, Q_true, R_true, seed = params[\"x0\"], params[\"Q_true\"], params[\"R_true\"], params[\"seed\"]\n    \n    np.random.seed(seed)\n    \n    n_states = x0.shape[0]\n    x = np.zeros((T, n_states))\n    y = np.zeros(T)\n    u = np.zeros(T)\n    \n    x[0] = x0\n    \n    for k in range(T):\n        u[k] = 0.5 + np.sin(0.03 * k) + 0.1 * np.sin(0.005 * k**2)\n        v_k = np.random.normal(0, np.sqrt(R_true))\n        y[k] = (H @ x[k] + D @ np.array([[u[k]]]))[0, 0] + v_k\n        if k  T - 1:\n            w_k = np.random.multivariate_normal(np.zeros(n_states), Q_true)\n            x[k+1] = A @ x[k] + B.flatten() * u[k] + w_k\n            \n    return y, u\n\ndef kalman_filter(y, u, A, B, H, D, Q, R, x0, P0):\n    \"\"\"Performs the Kalman filter forward pass.\"\"\"\n    T = len(y)\n    n_states = A.shape[0]\n\n    # Storage for filter outputs\n    x_pred = np.zeros((T, n_states))\n    P_pred = np.zeros((T, n_states, n_states))\n    x_filt = np.zeros((T, n_states))\n    P_filt = np.zeros((T, n_states, n_states))\n    log_likelihood = 0.0\n\n    # Initialization\n    x_pred[0] = x0\n    P_pred[0] = P0\n    \n    for k in range(T):\n        if k  0:\n            x_pred[k] = A @ x_filt[k-1] + B.flatten() * u[k-1]\n            P_pred[k] = A @ P_filt[k-1] @ A.T + Q\n        \n        # Update step\n        e_k = y[k] - (H @ x_pred[k] + D * u[k])[0, 0]\n        S_k = (H @ P_pred[k] @ H.T + R)[0, 0]\n        \n        if S_k = 0: return None # Filter divergence\n        \n        K_k = P_pred[k] @ H.T / S_k\n        \n        x_filt[k] = x_pred[k] + K_k.flatten() * e_k\n        P_filt[k] = (np.eye(n_states) - K_k @ H) @ P_pred[k]\n        \n        log_likelihood += -0.5 * (np.log(2 * np.pi * S_k) + e_k**2 / S_k)\n        \n    return x_pred, P_pred, x_filt, P_filt, log_likelihood\n\ndef rts_smoother(A, x_pred, P_pred, x_filt, P_filt):\n    \"\"\"Performs the Rauch-Tung-Striebel backward pass.\"\"\"\n    T = x_filt.shape[0]\n    n_states = A.shape[0]\n\n    x_smooth = np.copy(x_filt)\n    P_smooth = np.copy(P_filt)\n    P_lag1_smooth = np.zeros((T - 1, n_states, n_states))\n\n    for k in range(T - 2, -1, -1):\n        try:\n            P_pred_k1_inv = inv(P_pred[k+1])\n        except np.linalg.LinAlgError:\n            return None # Smoother divergence\n        \n        J_k = P_filt[k] @ A.T @ P_pred_k1_inv\n        \n        x_smooth[k] += J_k @ (x_smooth[k+1] - x_pred[k+1])\n        P_smooth[k] += J_k @ (P_smooth[k+1] - P_pred[k+1]) @ J_k.T\n        \n    # Lag-one covariance (an alternative formulation exists but this is common)\n    for k in range(T-2, -1, -1):\n        J_k = P_filt[k] @ A.T @ inv(P_pred[k+1])\n        P_lag1_smooth[k] = P_smooth[k+1] @ J_k.T\n        \n    return x_smooth, P_smooth, P_lag1_smooth\n\ndef m_step(y, u, A, B, H, D, x_smooth, P_smooth, P_lag1_smooth):\n    \"\"\"Performs the M-step of the EM algorithm.\"\"\"\n    T = len(y)\n    n_states = A.shape[0]\n    \n    # Update Q\n    sum_Q = np.zeros((n_states, n_states))\n    for k in range(T-1):\n        res_mean = x_smooth[k+1] - A @ x_smooth[k] - B.flatten() * u[k]\n        term1 = np.outer(res_mean, res_mean)\n        \n        Gamma_k = P_smooth[k+1] + A @ P_smooth[k] @ A.T - A @ P_lag1_smooth[k].T - P_lag1_smooth[k] @ A.T\n        sum_Q += term1 + Gamma_k\n    Q_new = sum_Q / (T-1)\n\n    # Update R\n    sum_R = 0.0\n    for k in range(T):\n        res_mean = y[k] - (H @ x_smooth[k] + D * u[k])[0, 0]\n        term1 = res_mean**2\n        term2 = (H @ P_smooth[k] @ H.T)[0, 0]\n        sum_R += term1 + term2\n    R_new = sum_R / T\n    \n    return Q_new, R_new\n\ndef enforce_psd(M, min_eig=1e-15):\n    \"\"\"Enforces a matrix to be symmetric positive semi-definite.\"\"\"\n    M_sym = (M + M.T) / 2\n    eigvals, eigvecs = eigh(M_sym)\n    eigvals[eigvals  min_eig] = min_eig\n    return eigvecs @ np.diag(eigvals) @ eigvecs.T\n\ndef run_em_for_case(case_params):\n    \"\"\"Runs the EM algorithm for a single test case.\"\"\"\n    y, u = simulate_data(case_params)\n    \n    A, B, H, D = case_params[\"A\"], case_params[\"B\"], case_params[\"H\"], case_params[\"D\"]\n    x0, P0 = case_params[\"x0\"], case_params[\"P0\"]\n    Q, R = np.copy(case_params[\"Q_init\"]), case_params[\"R_init\"]\n    \n    max_iter = 60\n    tol = 0.05\n    eps_norm = 1e-12\n    ll_history = []\n    \n    for i in range(max_iter):\n        Q_old, R_old = np.copy(Q), R\n        \n        # E-step\n        kf_out = kalman_filter(y, u, A, B, H, D, Q, R, x0, P0)\n        if kf_out is None: return False # Divergence\n        x_pred, P_pred, x_filt, P_filt, log_likelihood = kf_out\n        ll_history.append(log_likelihood)\n\n        rts_out = rts_smoother(A, x_pred, P_pred, x_filt, P_filt)\n        if rts_out is None: return False # Divergence\n        x_smooth, P_smooth, P_lag1_smooth = rts_out\n\n        # M-step\n        Q_new, R_new = m_step(y, u, A, B, H, D, x_smooth, P_smooth, P_lag1_smooth)\n        \n        # Enforce PSD constraints\n        Q = enforce_psd(Q_new)\n        R = max(R_new, 1e-15)\n\n        # Check convergence\n        delta_Q = norm(Q - Q_old, 'fro') / max(norm(Q_old, 'fro'), eps_norm)\n        delta_R = abs(R - R_old) / max(abs(R_old), eps_norm)\n\n        if delta_Q = tol and delta_R = tol:\n            if i = 4:\n                last_five_ll = ll_history[-5:]\n                is_non_decreasing = all(last_five_ll[j] = last_five_ll[j-1] - 1e-9 for j in range(1, 5))\n                if is_non_decreasing:\n                    return True\n\n    return False\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}