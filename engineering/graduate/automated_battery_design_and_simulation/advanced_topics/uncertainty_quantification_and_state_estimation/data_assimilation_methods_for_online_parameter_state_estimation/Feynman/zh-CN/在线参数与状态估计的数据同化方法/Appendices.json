{
    "hands_on_practices": [
        {
            "introduction": "在尝试估计模型参数之前，一个至关重要的步骤是确定这些参数是否可以从可用的测量数据中被*辨识*。本练习通过构建灵敏度矩阵来探索局部参数可辨识性，该矩阵量化了参数变化对模型输出的影响。通过分析该矩阵在不同输入条件下的秩，您将深入理解实验设计（即输入电流曲线）如何直接影响参数估计的可行性，这是设计信息丰富的实验的一个基本概念。",
            "id": "3903723",
            "problem": "您的任务是评估一个用于自动化电池设计和仿真的基于物理的电池模型中的局部参数可辨识性，方法是计算在指定输入轨迹上的灵敏度矩阵及其秩。从基本电路定律和电荷守恒定律出发构建正向模型，然后使用该模型建立灵敏度矩阵，并通过其秩来确定局部可辨识性。\n\n假设一个锂离子电池的一阶等效电路模型 (ECM)，该模型由一个欧姆内阻和一个单极化（电阻-电容）支路组成。设荷电状态 (SOC) 通过电荷守恒来定义。该模型由基尔霍夫定律和电容器本构关系推导如下：\n\n- 设输入电流为 $I(t)$，单位为安培，放电为正。设标称容量为 $Q_{\\mathrm{n}}$，单位为库仑。荷电状态 $z(t)$ 满足\n$$\\frac{dz(t)}{dt} = -\\frac{I(t)}{Q_{\\mathrm{n}}}.$$\n- 设电阻-电容支路两端的极化电压为 $v_{\\mathrm{rc}}(t)$，单位为伏特；极化电阻为 $R_1$，单位为欧姆；极化电容为 $C_1$，单位为法拉；欧姆内阻为 $R_0$，单位为欧姆。根据基尔霍夫定律和电容器的电流-电压关系，极化电压满足\n$$\\frac{dv_{\\mathrm{rc}}(t)}{dt} = -\\frac{1}{R_1 C_1} v_{\\mathrm{rc}}(t) + \\frac{1}{C_1} I(t).$$\n- 设开路电压在参考 SOC $z_{\\mathrm{ref}}$ 附近进行局部线性化，为 $V_{\\mathrm{OCV}}(z) = V_0 + \\alpha \\big(z - z_{\\mathrm{ref}}\\big)$，其中 $V_0$ 是一个常数，单位为伏特，$\\alpha$ 是局部斜率，单位为伏特每单位 SOC。端电压输出 $y(t)$（单位为伏特）为\n$$y(t) = V_0 + \\alpha \\big(z(t) - z_{\\mathrm{ref}}\\big) - v_{\\mathrm{rc}}(t) - R_0 I(t).$$\n\n定义参数向量 $\\boldsymbol{\\theta} = [R_0, R_1, C_1, \\alpha]^\\top$。对于一个时间步长为 $\\Delta t$ 且输入轨迹为 $I_k = I(k \\Delta t)$ 的离散时间实验，使用给定的初始条件 $z(0) = z_0$ 和 $v_{\\mathrm{rc}}(0) = v_{\\mathrm{rc},0}$ 模拟该模型，以获得在选定索引 $k \\in \\mathcal{K}$ 处的采样输出 $y_k = y(k \\Delta t)$。构建灵敏度矩阵 $S$，其元素为\n$$S_{ij} = \\frac{\\partial y_{k_i}}{\\partial \\theta_j},$$\n其中 $k_i$ 是第 $i$ 个选定的样本索引。使用一种数值稳定的有限差分近似方法来计算 $\\frac{\\partial y_{k_i}}{\\partial \\theta_j}$，该方法适用于不同数量级的参数。\n\n通过 $\\mathrm{rank}(S)$ 来评估工作点处的局部可辨识性：满列秩表示参数的微小扰动会在采样时刻产生可区分的输出变化。\n\n使用显式欧拉法实现正向仿真：\n$$v_{\\mathrm{rc},k+1} = v_{\\mathrm{rc},k} + \\Delta t\\left(-\\frac{1}{R_1 C_1} v_{\\mathrm{rc},k} + \\frac{1}{C_1} I_k\\right), \\quad z_{k+1} = z_k - \\Delta t \\frac{I_k}{Q_{\\mathrm{n}}}, \\quad y_k = V_0 + \\alpha \\big(z_k - z_{\\mathrm{ref}}\\big) - v_{\\mathrm{rc},k} - R_0 I_k.$$\n\n数值要求：\n- 使用中心有限差分计算灵敏度，相对扰动幅度为 $\\delta_j = \\varepsilon \\, |\\theta_j|$，其中 $\\varepsilon = 10^{-6}$，即\n$$\\frac{\\partial y_{k_i}}{\\partial \\theta_j} \\approx \\frac{y_{k_i}(\\theta_j + \\delta_j) - y_{k_i}(\\theta_j - \\delta_j)}{2\\delta_j}.$$\n- 在计算矩阵的秩时，使用基于奇异值分解的准则和合理的容差（您可以使用标准数值线性代数程序的默认行为）。\n\n物理单位和常数：\n- 电流 $I$ 以安培表示，电压 $y$ 和 $V_0$ 以伏特表示，时间以秒表示，电阻以欧姆表示，电容以法拉表示，容量 $Q_{\\mathrm{n}}$ 以库仑表示，SOC 为无量纲（0 到 1）。\n- 在所有测试中，使用 $Q_{\\mathrm{n}} = 7200$ 库仑，$V_0 = 3.7$ 伏特，$z_0 = 0.5$，$z_{\\mathrm{ref}} = 0.5$，$v_{\\mathrm{rc},0} = 0$ 伏特。\n\n测试套件：\n- 测试 1（丰富激励，预期满秩）：$\\boldsymbol{\\theta} = [0.01, 0.02, 2400, 0.8]$，$\\Delta t = 0.5$ 秒，$N = 200$ 个样本，输入 $I_k$ 是一个确定性伪随机二进制序列 (PRBS)，取值为 $\\pm 1$ 安培，模式随时间变化，在所有索引 $\\mathcal{K} = \\{0,1,\\dots,N-1\\}$ 处采样。\n- 测试 2（无激励，预期秩为 0）：$\\boldsymbol{\\theta} = [0.01, 0.02, 2400, 0.8]$，$\\Delta t = 1.0$ 秒，$N = 50$ 个样本，输入 $I_k \\equiv 0$ 安培，在所有索引 $\\mathcal{K} = \\{0,1,\\dots,N-1\\}$ 处采样。\n- 测试 3（稳态主导，预期秩亏）：$\\boldsymbol{\\theta} = [0.01, 0.02, 2400, 0.8]$，$\\Delta t = 1.0$ 秒，$N = 300$ 个样本，对于所有 $k$，输入 $I_k \\equiv 1.0$ 安培，在最后 100 个索引 $\\mathcal{K} = \\{200, 201, \\dots, 299\\}$ 处采样。\n- 测试 4（单样本边界情况）：$\\boldsymbol{\\theta} = [0.01, 0.02, 2400, 0.8]$，$\\Delta t = 1.0$ 秒，$N = 1$ 个样本，输入 $I_0 = 0.5$ 安培，在索引 $\\mathcal{K} = \\{0\\}$ 处采样。\n\n您的程序必须：\n- 完全按照规定实现正向仿真和灵敏度计算。\n- 对每个测试，使用指定的 $\\boldsymbol{\\theta}$、输入和采样索引构建灵敏度矩阵 $S$，然后计算整数秩 $\\mathrm{rank}(S)$。\n- 生成单行输出，其中包含测试 1 到测试 4 的秩，形式为方括号内以逗号分隔的列表，例如 $[r_1,r_2,r_3,r_4]$。秩是无量纲整数。\n\n问题描述中的所有数值量均以其指定单位（安培、伏特、秒、欧姆、法拉、库仑）给出。最终输出为秩（无量纲整数）。不涉及角度或百分比。",
            "solution": "该问题要求评估锂离子电池一阶等效电路模型 (ECM) 的局部参数可辨识性。这是通过计算给定一组参数和输入电流轨迹下的灵敏度矩阵的秩来实现的。\n\n正向模型由一个常微分方程组定义。第一个状态，荷电状态 $z(t)$，由电荷守恒原理（库仑计数法）决定：\n$$\n\\frac{dz(t)}{dt} = -\\frac{I(t)}{Q_{\\mathrm{n}}}\n$$\n其中 $I(t)$ 是输入电流，$Q_{\\mathrm{n}}$ 是电池的标称容量。\n\n第二个状态，并联电阻-电容 ($RC$) 支路两端的极化电压 $v_{\\mathrm{rc}}(t)$，由基尔霍夫定律和电容器的本构关系决定：\n$$\n\\frac{dv_{\\mathrm{rc}}(t)}{dt} = -\\frac{1}{R_1 C_1} v_{\\mathrm{rc}}(t) + \\frac{1}{C_1} I(t)\n$$\n这里，$R_1$ 是极化电阻，$C_1$ 是极化电容。该动态过程的特征时间常数为 $\\tau_1 = R_1 C_1$。\n\n模型的输出是端电压 $y(t)$，它是开路电压 ($V_{\\mathrm{OCV}}$)、欧姆内阻 $R_0$ 上的电压降和极化电压之和：\n$$\ny(t) = V_{\\mathrm{OCV}}(z(t)) - v_{\\mathrm{rc}}(t) - R_0 I(t)\n$$\n开路电压在参考点 $z_{\\mathrm{ref}}$ 附近通过一个关于荷电状态的线性函数进行局部近似：\n$$\nV_{\\mathrm{OCV}}(z(t)) = V_0 + \\alpha \\big(z(t) - z_{\\mathrm{ref}}\\big)\n$$\n其中 $V_0$ 是在 $z_{\\mathrm{ref}}$ 时的 OCV，$\\alpha$ 是 OCV-SOC 曲线的局部斜率。\n\n待辨识的参数收集在向量 $\\boldsymbol{\\theta} = [R_0, R_1, C_1, \\alpha]^\\top$ 中。\n\n为了进行数值仿真，连续时间模型使用时间步长为 $\\Delta t$ 的显式欧拉法进行离散化。设 $x_k = x(k \\Delta t)$ 表示变量 $x$ 在离散时间步 $k$ 的值。状态和输出方程变为：\n$$\nz_{k+1} = z_k - \\frac{\\Delta t}{Q_{\\mathrm{n}}} I_k\n$$\n$$\nv_{\\mathrm{rc},k+1} = v_{\\mathrm{rc},k} + \\Delta t\\left(-\\frac{1}{R_1 C_1} v_{\\mathrm{rc},k} + \\frac{1}{C_1} I_k\\right) = v_{\\mathrm{rc},k} \\left(1 - \\frac{\\Delta t}{R_1 C_1}\\right) + \\frac{\\Delta t}{C_1} I_k\n$$\n$$\ny_k = V_0 + \\alpha \\big(z_k - z_{\\mathrm{ref}}\\big) - v_{\\mathrm{rc},k} - R_0 I_k\n$$\n\n局部参数可辨识性是通过分析模型输出 $y_k$ 对参数 $\\boldsymbol{\\theta}$ 变化的灵敏度来评估的。灵敏度矩阵 $S$ 由这些偏导数构成，并在特定的时间索引 $k_i \\in \\mathcal{K}$ 处采样：\n$$\nS_{ij} = \\frac{\\partial y_{k_i}}{\\partial \\theta_j}\n$$\n如果 $S$ 的列是线性无关的，这当且仅当 $S$ 具有满列秩时成立，那么 $\\boldsymbol{\\theta}$ 中的参数是局部可辨识的。$S$ 的秩等于可辨识参数或参数组合的数量。\n\n导数使用中心有限差分法进行数值计算，该方法具有二阶精度。对于参数 $\\theta_j$，我们引入一个小的扰动 $\\delta_j$ 并计算受扰动参数下的输出：\n$$\n\\frac{\\partial y_{k_i}}{\\partial \\theta_j} \\approx \\frac{y_{k_i}(\\boldsymbol{\\theta} + \\boldsymbol{e}_j \\delta_j) - y_{k_i}(\\boldsymbol{\\theta} - \\boldsymbol{e}_j \\delta_j)}{2\\delta_j}\n$$\n其中 $\\boldsymbol{e}_j$ 是第 $j$ 个标准基向量。扰动幅度选择为相对于参数值的大小，即 $\\delta_j = \\varepsilon |\\theta_j|$，其中 $\\varepsilon = 10^{-6}$，以便恰当地处理不同尺度的参数。\n\n得到的灵敏度矩阵 $S$ 的秩是使用奇异值分解 (SVD) 确定的。秩对应于显著大于零的奇异值的数量，这是通过合适的容差进行数值确定的。\n\n分析在四个测试用例中进行：\n1.  **测试 1 (PRBS 输入):** 伪随机二进制序列在宽频带上提供丰富且持续的激励。这种动态输入预期会激励模型的快速 ($RC$) 和慢速 ($SOC$) 动态，使得所有四个参数都可区分。$S$ 的秩预期为 4。\n2.  **测试 2 (零输入):** 当 $I(t) = 0$ 且给定初始条件 $z_0 = z_{\\mathrm{ref}}$ 和 $v_{\\mathrm{rc},0} = 0$ 时，状态不会演变：$z(t)=z_0$ 和 $v_{\\mathrm{rc}}(t)=0$。输出变为常数 $y(t) = V_0$。由于输出与 $\\boldsymbol{\\theta}$ 中的所有参数无关，所有灵敏度导数都为零。灵敏度矩阵 $S$ 是一个零矩阵，其秩为 0。\n3.  **测试 3 (恒定输入，后期采样):** 施加一个恒定电流 $I(t) = I$。采样发生在 $RC$ 动态达到稳态之后（$t \\gg \\tau_1 = R_1C_1$）。在此区域，$v_{\\mathrm{rc}}(t) \\approx R_1 I$。输出近似为 $y_k \\approx V_0 + \\alpha(z_k - z_{\\mathrm{ref}}) - (R_0 + R_1)I$。参数 $R_0$ 和 $R_1$ 仅以和 $R_0 + R_1$ 的形式出现，使得它们无法被单独辨识。同样，$C_1$ 对稳态输出没有影响。因此，对应于 $R_0$ 和 $R_1$ 的灵敏度矩阵列将是线性相关的，而 $C_1$ 对应的列将是零向量。我们预期只能辨识出 $\\alpha$ 和组合电阻 $R_0+R_1$，因此秩为 2。\n4.  **测试 4 (在 t=0 时的单次采样):** 仅在初始时刻 $k=0$ 对输出进行采样。输出方程为 $y_0 = V_0 + \\alpha(z_0 - z_{\\mathrm{ref}}) - v_{\\mathrm{rc},0} - R_0 I_0$。根据给定的初始条件（$z_0=z_{\\mathrm{ref}}$, $v_{\\mathrm{rc},0}=0$），这简化为 $y_0 = V_0 - R_0 I_0$。输出仅依赖于 $R_0$。因此，只有相对于 $R_0$ 的灵敏度不为零。灵敏度矩阵是一个 $1 \\times 4$ 的行向量，其中有三个零元素，因此秩为 1。\n\n实现将包括一个用于离散模型的正向模拟器、一个通过有限差分计算灵敏度矩阵各列的循环，以及对每个测试用例的最终秩计算。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(theta, I_profile, dt, N, Qn, z0, vrc0, V0, z_ref):\n    \"\"\"\n    Simulates the first-order ECM using the explicit Euler method.\n\n    Args:\n        theta (list or np.ndarray): Parameter vector [R0, R1, C1, alpha].\n        I_profile (np.ndarray): Input current trajectory of length N.\n        dt (float): Time step in seconds.\n        N (int): Number of an_samples.\n        Qn (float): Nominal capacity in Coulombs.\n        z0 (float): Initial state of charge.\n        vrc0 (float): Initial polarization voltage.\n        V0 (float): Reference open-circuit voltage.\n        z_ref (float): Reference state of charge.\n\n    Returns:\n        np.ndarray: The simulated terminal voltage trajectory y of length N.\n    \"\"\"\n    R0, R1, C1, alpha = theta\n    \n    # Handle cases where perturbed parameters might be zero.\n    if C1 == 0 or R1 == 0:\n        return np.full(N, np.nan)\n\n    z = np.zeros(N)\n    vrc = np.zeros(N)\n    \n    z[0] = z0\n    vrc[0] = vrc0\n    \n    tau_inv = 1.0 / (R1 * C1)\n    \n    for k in range(N - 1):\n        vrc[k+1] = vrc[k] * (1.0 - dt * tau_inv) + (dt / C1) * I_profile[k]\n        z[k+1] = z[k] - (dt / Qn) * I_profile[k]\n\n    y = V0 + alpha * (z - z_ref) - vrc - R0 * I_profile\n    \n    return y\n\ndef compute_sensitivity_matrix_rank(case):\n    \"\"\"\n    Computes the rank of the sensitivity matrix for a given test case.\n    \"\"\"\n    theta_nom, dt, N, get_I_profile, K_indices = case\n\n    # Constants and initial conditions\n    Qn = 7200.0\n    V0 = 3.7\n    z0 = 0.5\n    z_ref = 0.5\n    vrc0 = 0.0\n\n    # Generate the full input current profile\n    I_profile = get_I_profile(N)\n    \n    # Finite difference perturbation\n    epsilon = 1e-6\n    num_params = len(theta_nom)\n    num_samples = len(K_indices)\n    \n    S = np.zeros((num_samples, num_params))\n\n    for j in range(num_params):\n        theta_j = theta_nom[j]\n        # Use a small absolute perturbation if the parameter is zero\n        delta_j = epsilon * np.abs(theta_j) if theta_j != 0 else epsilon\n\n        theta_plus = np.array(theta_nom)\n        theta_plus[j] += delta_j\n        \n        theta_minus = np.array(theta_nom)\n        theta_minus[j] -= delta_j\n        \n        y_plus = run_simulation(theta_plus, I_profile, dt, N, Qn, z0, vrc0, V0, z_ref)\n        y_minus = run_simulation(theta_minus, I_profile, dt, N, Qn, z0, vrc0, V0, z_ref)\n\n        # Handle potential NaNs from invalid parameters\n        if np.any(np.isnan(y_plus)) or np.any(np.isnan(y_minus)):\n            S[:, j] = 0\n            continue\n            \n        sens_j = (y_plus - y_minus) / (2.0 * delta_j)\n        \n        S[:, j] = sens_j[K_indices]\n\n    return np.linalg.matrix_rank(S)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    \n    # Define a deterministic PRBS generator for Test 1\n    def get_prbs_profile(N):\n        rng = np.random.default_rng(seed=42)\n        return rng.choice([-1.0, 1.0], size=N)\n\n    test_cases = [\n        # Test 1: Rich excitation\n        (\n            [0.01, 0.02, 2400, 0.8], # theta\n            0.5, # dt\n            200, # N\n            get_prbs_profile, # I_k generator\n            np.arange(200) # K_indices\n        ),\n        # Test 2: No excitation\n        (\n            [0.01, 0.02, 2400, 0.8], # theta\n            1.0, # dt\n            50, # N\n            lambda n: np.zeros(n), # I_k generator\n            np.arange(50) # K_indices\n        ),\n        # Test 3: Steady-state dominated\n        (\n            [0.01, 0.02, 2400, 0.8], # theta\n            1.0, # dt\n            300, # N\n            lambda n: np.ones(n) * 1.0, # I_k generator\n            np.arange(200, 300) # K_indices\n        ),\n        # Test 4: Single-sample boundary case\n        (\n            [0.01, 0.02, 2400, 0.8], # theta\n            1.0, # dt\n            1, # N\n            lambda n: np.array([0.5]), # I_k generator\n            np.array([0]) # K_indices\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        rank = compute_sensitivity_matrix_rank(case)\n        results.append(rank)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "卡尔曼滤波器是线性高斯系统估计的基石，也是更高级滤波器的基础。本练习将引导您手动完成一个完整的卡尔曼滤波器迭代周期：预测步骤和更新步骤。通过为一个简化的电池模型手动计算状态和协方差的更新，您将巩固对滤波器如何将模型预测与新测量值进行最优融合，从而精确化其对电池内部状态估计的理解。",
            "id": "3903722",
            "problem": "一个锂离子电池在固定工作点附近被一个离散时间线性化的戴维南电阻-电容 (RC) 等效电路所建模。状态向量为 $x_k = [x_{1,k}\\; x_{2,k}]^{\\top}$，其中 $x_{1,k}$ 是荷电状态 (SOC) 分数，$x_{2,k}$ 是RC过电势，单位为伏特。输入 $u_{k-1}$ 是施加的电流（放电为正），测量输出 $y_k$ 是预补偿欧姆压降后，端电压与工作点电压的偏差。随机线性高斯状态空间模型为\n$$x_k = A x_{k-1} + B u_{k-1} + w_{k-1}, \\quad w_{k-1} \\sim \\mathcal{N}(0,Q),$$\n$$y_k = H x_k + v_k, \\quad v_k \\sim \\mathcal{N}(0,R),$$\n过程噪声和测量噪声是独立的。\n\n假设系统矩阵和噪声协方差的数值指定如下\n$$A = \\begin{bmatrix} 1  0 \\\\ 0  \\tfrac{1}{2} \\end{bmatrix}, \\quad B = \\begin{bmatrix} -\\tfrac{1}{10} \\\\ \\tfrac{1}{5} \\end{bmatrix}, \\quad H = \\begin{bmatrix} \\tfrac{3}{10}  -1 \\end{bmatrix},$$\n$$Q = \\begin{bmatrix} \\tfrac{1}{100}  0 \\\\ 0  \\tfrac{1}{25} \\end{bmatrix}, \\quad R = \\tfrac{9}{100}.$$\n\n在时间 $k-1$ 时，后验状态估计和协方差为\n$$x_{k-1}^{+} = \\begin{bmatrix} \\tfrac{1}{2} \\\\ \\tfrac{1}{5} \\end{bmatrix}, \\quad P_{k-1}^{+} = \\begin{bmatrix} \\tfrac{1}{25}  0 \\\\ 0  \\tfrac{9}{100} \\end{bmatrix}.$$\n在下一步中，施加的电流为 $u_{k-1} = 1$，测得的端电压偏差为 $y_k = -\\tfrac{1}{5}$。\n\n从线性高斯状态转移和观测模型以及高斯随机变量的标准概率条件化出发，执行一次完整的卡尔曼滤波器迭代（预测和更新），以获得在时间 $k$ 的后验状态 $x_k^{+}$ 和协方差 $P_k^{+}$。\n\n答案规格：\n- 以封闭形式提供精确值；不要四舍五入。\n- 以单行矩阵的形式报告最终答案，顺序为 $[x_{1,k}^{+},\\, x_{2,k}^{+},\\, P_{11,k}^{+},\\, P_{12,k}^{+},\\, P_{21,k}^{+},\\, P_{22,k}^{+}]$。\n- 将 $x_{1,k}^{+}$ 表示为SOC分数，$x_{2,k}^{+}$ 的单位为伏特；协方差条目的单位是相应的平方单位。在最终的方框答案中，不要包含单位。",
            "solution": "该问题陈述被评估为有效。它在科学上基于电化学系统的标准状态空间建模和估计理论，具体来说，是使用锂离子电池的线性化等效电路模型，这是一种常见的做法。该问题是适定的，提供了执行一次唯一的卡尔曼滤波器迭代所需的所有必要矩阵、协方差、初始条件和测量值。所提供的数值在维度上是一致的，并且不代表任何物理或数学上的矛盾。该任务是标准卡尔曼滤波器算法的直接应用，该算法是数据同化和在线状态估计的基石。\n\n卡尔曼滤波器算法包括两个相继的步骤：预测（时间更新）和校正（测量更新）。我们将执行一次完整的迭代。\n\n在时间 $k-1$ 时的后验状态估计及其协方差如下所示：\n$$x_{k-1}^{+} = \\begin{bmatrix} \\tfrac{1}{2} \\\\ \\tfrac{1}{5} \\end{bmatrix}, \\quad P_{k-1}^{+} = \\begin{bmatrix} \\tfrac{1}{25}  0 \\\\ 0  \\tfrac{9}{100} \\end{bmatrix}$$\n系统矩阵、输入和测量值如下：\n$$A = \\begin{bmatrix} 1  0 \\\\ 0  \\tfrac{1}{2} \\end{bmatrix}, \\quad B = \\begin{bmatrix} -\\tfrac{1}{10} \\\\ \\tfrac{1}{5} \\end{bmatrix}, \\quad H = \\begin{bmatrix} \\tfrac{3}{10}  -1 \\end{bmatrix}$$\n$$Q = \\begin{bmatrix} \\tfrac{1}{100}  0 \\\\ 0  \\tfrac{1}{25} \\end{bmatrix}, \\quad R = \\tfrac{9}{100}$$\n$$u_{k-1} = 1, \\quad y_k = -\\tfrac{1}{5}$$\n\n**1. 预测步骤**\n\n预测步骤将状态和协方差估计从时间步 $k-1$ 向前投影到时间步 $k$。\n\n首先，我们计算预测的（先验）状态估计 $x_k^{-}$：\n$$x_k^{-} = A x_{k-1}^{+} + B u_{k-1}$$\n$$x_k^{-} = \\begin{bmatrix} 1  0 \\\\ 0  \\tfrac{1}{2} \\end{bmatrix} \\begin{bmatrix} \\tfrac{1}{2} \\\\ \\tfrac{1}{5} \\end{bmatrix} + \\begin{bmatrix} -\\tfrac{1}{10} \\\\ \\tfrac{1}{5} \\end{bmatrix} (1) = \\begin{bmatrix} \\tfrac{1}{2} \\\\ \\tfrac{1}{10} \\end{bmatrix} + \\begin{bmatrix} -\\tfrac{1}{10} \\\\ \\tfrac{2}{10} \\end{bmatrix} = \\begin{bmatrix} \\tfrac{4}{10} \\\\ \\tfrac{3}{10} \\end{bmatrix} = \\begin{bmatrix} \\tfrac{2}{5} \\\\ \\tfrac{3}{10} \\end{bmatrix}$$\n\n接下来，我们计算预测的（先验）误差协方差 $P_k^{-}$：\n$$P_k^{-} = A P_{k-1}^{+} A^{\\top} + Q$$\n因为 $A$ 是一个对角矩阵，所以 $A^{\\top} = A$。\n$$P_k^{-} = \\begin{bmatrix} 1  0 \\\\ 0  \\tfrac{1}{2} \\end{bmatrix} \\begin{bmatrix} \\tfrac{1}{25}  0 \\\\ 0  \\tfrac{9}{100} \\end{bmatrix} \\begin{bmatrix} 1  0 \\\\ 0  \\tfrac{1}{2} \\end{bmatrix} + \\begin{bmatrix} \\tfrac{1}{100}  0 \\\\ 0  \\tfrac{1}{25} \\end{bmatrix}$$\n$$P_k^{-} = \\begin{bmatrix} \\tfrac{1}{25}  0 \\\\ 0  \\tfrac{9}{200} \\end{bmatrix} \\begin{bmatrix} 1  0 \\\\ 0  \\tfrac{1}{2} \\end{bmatrix} + \\begin{bmatrix} \\tfrac{1}{100}  0 \\\\ 0  \\tfrac{1}{25} \\end{bmatrix}$$\n$$P_k^{-} = \\begin{bmatrix} \\tfrac{1}{25}  0 \\\\ 0  \\tfrac{9}{400} \\end{bmatrix} + \\begin{bmatrix} \\tfrac{4}{100}  0 \\\\ 0  \\tfrac{16}{400} \\end{bmatrix} = \\begin{bmatrix} \\tfrac{5}{100}  0 \\\\ 0  \\tfrac{25}{400} \\end{bmatrix} = \\begin{bmatrix} \\tfrac{1}{20}  0 \\\\ 0  \\tfrac{1}{16} \\end{bmatrix}$$\n\n**2. 更新步骤**\n\n更新步骤使用新的测量值 $y_k$ 来校正预测的估计值。\n\n首先，我们计算卡尔曼增益 $K_k$。这需要新息协方差 $S_k = H P_k^{-} H^{\\top} + R$。\n$$P_k^{-} H^{\\top} = \\begin{bmatrix} \\tfrac{1}{20}  0 \\\\ 0  \\tfrac{1}{16} \\end{bmatrix} \\begin{bmatrix} \\tfrac{3}{10} \\\\ -1 \\end{bmatrix} = \\begin{bmatrix} \\tfrac{3}{200} \\\\ -\\tfrac{1}{16} \\end{bmatrix}$$\n$$H P_k^{-} H^{\\top} = \\begin{bmatrix} \\tfrac{3}{10}  -1 \\end{bmatrix} \\begin{bmatrix} \\tfrac{3}{200} \\\\ -\\tfrac{1}{16} \\end{bmatrix} = \\tfrac{9}{2000} + \\tfrac{1}{16} = \\tfrac{9}{2000} + \\tfrac{125}{2000} = \\tfrac{134}{2000} = \\tfrac{67}{1000}$$\n$$S_k = H P_k^{-} H^{\\top} + R = \\tfrac{67}{1000} + \\tfrac{9}{100} = \\tfrac{67}{1000} + \\tfrac{90}{1000} = \\tfrac{157}{1000}$$\n那么卡尔曼增益 $K_k$ 为：\n$$K_k = P_k^{-} H^{\\top} S_k^{-1} = \\begin{bmatrix} \\tfrac{3}{200} \\\\ -\\tfrac{1}{16} \\end{bmatrix} \\left(\\tfrac{1000}{157}\\right) = \\begin{bmatrix} \\tfrac{3 \\times 5}{157} \\\\ -\\tfrac{1000/16}{157} \\end{bmatrix} = \\begin{bmatrix} \\tfrac{15}{157} \\\\ -\\tfrac{125/2}{157} \\end{bmatrix} = \\begin{bmatrix} \\tfrac{15}{157} \\\\ -\\tfrac{125}{314} \\end{bmatrix}$$\n\n接下来，我们更新状态估计以获得后验（a posteriori）估计 $x_k^{+}$。这需要测量残差（新息）$y_k - H x_k^{-}$。\n$$H x_k^{-} = \\begin{bmatrix} \\tfrac{3}{10}  -1 \\end{bmatrix} \\begin{bmatrix} \\tfrac{2}{5} \\\\ \\tfrac{3}{10} \\end{bmatrix} = \\tfrac{6}{50} - \\tfrac{3}{10} = \\tfrac{6}{50} - \\tfrac{15}{50} = -\\tfrac{9}{50}$$\n新息为 $y_k - H x_k^{-} = -\\tfrac{1}{5} - (-\\tfrac{9}{50}) = -\\tfrac{10}{50} + \\tfrac{9}{50} = -\\tfrac{1}{50}$。\n$$x_k^{+} = x_k^{-} + K_k (y_k - H x_k^{-})$$\n$$x_k^{+} = \\begin{bmatrix} \\tfrac{2}{5} \\\\ \\tfrac{3}{10} \\end{bmatrix} + \\begin{bmatrix} \\tfrac{15}{157} \\\\ -\\tfrac{125}{314} \\end{bmatrix} \\left(-\\tfrac{1}{50}\\right) = \\begin{bmatrix} \\tfrac{2}{5} - \\tfrac{15}{157 \\times 50} \\\\ \\tfrac{3}{10} + \\tfrac{125}{314 \\times 50} \\end{bmatrix}$$\n$x_k^{+}$ 的分量为：\n$$x_{1,k}^{+} = \\tfrac{2}{5} - \\tfrac{3}{1570} = \\tfrac{2 \\times 314 - 3}{1570} = \\tfrac{628-3}{1570} = \\tfrac{625}{1570} = \\tfrac{125}{314}$$\n$$x_{2,k}^{+} = \\tfrac{3}{10} + \\tfrac{125}{15700} = \\tfrac{3}{10} + \\tfrac{5}{628} = \\tfrac{3 \\times 314 + 5 \\times 5}{3140} = \\tfrac{942+25}{3140} = \\tfrac{967}{3140}$$\n所以，$x_k^{+} = \\begin{bmatrix} \\tfrac{125}{314} \\\\ \\tfrac{967}{3140} \\end{bmatrix}$。\n\n最后，我们更新误差协方差以获得后验协方差 $P_k^{+}$。\n$$P_k^{+} = (I - K_k H) P_k^{-}$$\n$$I - K_k H = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} - \\begin{bmatrix} \\tfrac{15}{157} \\\\ -\\tfrac{125}{314} \\end{bmatrix} \\begin{bmatrix} \\tfrac{3}{10}  -1 \\end{bmatrix} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} - \\begin{bmatrix} \\tfrac{45}{1570}  -\\tfrac{15}{157} \\\\ -\\tfrac{375}{3140}  \\tfrac{125}{314} \\end{bmatrix}$$\n$$I - K_k H = \\begin{bmatrix} 1 - \\tfrac{9}{314}  \\tfrac{15}{157} \\\\ \\tfrac{375}{3140}  1 - \\tfrac{125}{314} \\end{bmatrix} = \\begin{bmatrix} \\tfrac{305}{314}  \\tfrac{30}{314} \\\\ \\tfrac{75}{628}  \\tfrac{189}{314} \\end{bmatrix}$$\n现在，乘以对角矩阵 $P_k^{-}$：\n$$P_k^{+} = \\begin{bmatrix} \\tfrac{305}{314}  \\tfrac{30}{314} \\\\ \\tfrac{75}{628}  \\tfrac{189}{314} \\end{bmatrix} \\begin{bmatrix} \\tfrac{1}{20}  0 \\\\ 0  \\tfrac{1}{16} \\end{bmatrix} = \\begin{bmatrix} \\tfrac{305}{314 \\times 20}  \\tfrac{30}{314 \\times 16} \\\\ \\tfrac{75}{628 \\times 20}  \\tfrac{189}{314 \\times 16} \\end{bmatrix}$$\n$P_k^{+}$ 的分量为：\n$$P_{11,k}^{+} = \\tfrac{305}{6280} = \\tfrac{61}{1256}$$\n$$P_{12,k}^{+} = \\tfrac{30}{5024} = \\tfrac{15}{2512}$$\n$$P_{21,k}^{+} = \\tfrac{75}{12560} = \\tfrac{15}{2512}$$\n$$P_{22,k}^{+} = \\tfrac{189}{5024}$$\n正如预期的那样，$P_k^{+}$ 是对称的，即 $P_{12,k}^{+} = P_{21,k}^{+}$。\n\n最终的后验状态和协方差为：\n$$x_k^{+} = \\begin{bmatrix} \\tfrac{125}{314} \\\\ \\tfrac{967}{3140} \\end{bmatrix}, \\quad P_k^{+} = \\begin{bmatrix} \\tfrac{61}{1256}  \\tfrac{15}{2512} \\\\ \\tfrac{15}{2512}  \\tfrac{189}{5024} \\end{bmatrix}$$\n所要求的输出是行矩阵 $[x_{1,k}^{+},\\, x_{2,k}^{+},\\, P_{11,k}^{+},\\, P_{12,k}^{+},\\, P_{21,k}^{+},\\, P_{22,k}^{+}]$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{125}{314} & \\frac{967}{3140} & \\frac{61}{1256} & \\frac{15}{2512} & \\frac{15}{2512} & \\frac{189}{5024}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在实际应用中，过程噪声和测量噪声的精确统计特性通常是未知的，但它们对滤波器的性能至关重要。这个高级练习通过实现期望最大化（EM）算法来应对这一挑战，直接从数据中估计噪声协方差 $Q$ 和 $R$。您将使用Rauch-Tung-Striebel（RTS）平滑器在E步骤中计算必要的统计量，然后在M步骤中更新协方差估计，从而展示一种强大的自适应滤波技术。",
            "id": "3903741",
            "problem": "考虑在用于自动化电池仿真的离散时间线性随机状态空间模型中，在线估计过程噪声协方差和测量噪声协方差。该模型是锂离子电池双状态等效电路模型 (ECM) 在固定工作点附近的线性化。离散时间动力学和测量方程为\n$$\n\\mathbf{x}_{k+1} = \\mathbf{A}\\,\\mathbf{x}_k + \\mathbf{B}\\,u_k + \\mathbf{w}_k,\\quad \\mathbf{w}_k \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{Q}),\n$$\n$$\ny_k = \\mathbf{H}\\,\\mathbf{x}_k + \\mathbf{D}\\,u_k + v_k,\\quad v_k \\sim \\mathcal{N}(0, R),\n$$\n其中 $\\mathbf{x}_k \\in \\mathbb{R}^2$ 表示状态向量，包含荷电状态和一阶电阻-电容 (RC) 对电压；$u_k \\in \\mathbb{R}$ 表示施加的电流（被视为已知输入）；$y_k \\in \\mathbb{R}$ 表示端电压测量值；$\\mathbf{w}_k$ 是过程噪声，其协方差为 $\\mathbf{Q} \\in \\mathbb{R}^{2 \\times 2}$；$v_k$ 是测量噪声，其方差为 $R \\in \\mathbb{R}$。矩阵 $\\mathbf{A} \\in \\mathbb{R}^{2 \\times 2}$、$\\mathbf{B} \\in \\mathbb{R}^{2 \\times 1}$、$\\mathbf{H} \\in \\mathbb{R}^{1 \\times 2}$ 和 $\\mathbf{D} \\in \\mathbb{R}^{1 \\times 1}$ 对于每个测试用例都是已知且固定的。初始状态 $\\mathbf{x}_0$ 及其协方差 $\\mathbf{P}_0$ 已给出。\n\n目标是使用从 Rauch–Tung–Striebel (RTS) 平滑器获得的平滑残差来计算更新后的 $\\mathbf{Q}$ 和 $R$，并迭代直至收敛。收敛性通过 $\\mathbf{Q}$ 和 $R$ 中相对 Frobenius 范数的变化以及检查最后几次迭代中新息对数似然的单调不减性来评估。具体而言，每次更新后：\n- 计算相对变化\n$$\n\\delta_Q = \\frac{\\|\\mathbf{Q}_{\\text{new}} - \\mathbf{Q}_{\\text{old}}\\|_F}{\\max(\\|\\mathbf{Q}_{\\text{old}}\\|_F, \\epsilon)},\\quad\n\\delta_R = \\frac{|R_{\\text{new}} - R_{\\text{old}}|}{\\max(|R_{\\text{old}}|, \\epsilon)},\n$$\n其中 $\\epsilon = 10^{-12}$。\n- 定义容差 $\\tau = 0.05$ 和最大迭代次数 $N_{\\text{max}} = 60$。\n- 将收敛定义为 $\\delta_Q \\le \\tau$ 和 $\\delta_R \\le \\tau$ 并且在最后 5 次迭代中新息对数似然单调不减（允许在数值容差内的精确相等）。\n\n您必须使用 RTS 平滑器计算的平滑残差来实现期望最大化 (EM) 算法。在期望步骤 (Expectation step) 中，运行卡尔曼滤波器 (Kalman Filter, KF) 和 RTS 平滑器以获得平滑均值、协方差和滞后一阶协方差。在最大化步骤 (Maximization step) 中，使用残差的期望充分统计量来更新 $\\mathbf{Q}$ 和 $R$：\n- 定义单步状态残差 $\\mathbf{r}_k^{(x)} = \\mathbf{x}_{k+1} - \\mathbf{A}\\,\\mathbf{x}_k - \\mathbf{B}\\,u_k$ 和测量残差 $r_k^{(y)} = y_k - \\mathbf{H}\\,\\mathbf{x}_k - \\mathbf{D}\\,u_k$。使用平滑期望来构建\n$$\n\\mathbf{Q}_{\\text{new}} = \\frac{1}{T-1} \\sum_{k=0}^{T-2} \\mathbb{E}\\left[\\mathbf{r}_k^{(x)}\\mathbf{r}_k^{(x)\\top}\\,\\big|\\, y_{0:T-1}\\right],\n$$\n$$\nR_{\\text{new}} = \\frac{1}{T} \\sum_{k=0}^{T-1} \\mathbb{E}\\left[r_k^{(y)}r_k^{(y)}\\,\\big|\\, y_{0:T-1}\\right].\n$$\n这些期望值必须根据平滑均值和协方差（包括滞后一阶协方差 $\\mathrm{Cov}(\\mathbf{x}_k,\\mathbf{x}_{k+1}\\,|\\,y_{0:T-1})$）计算得出。\n\n为了在数据同化中进行模型评估，在每次迭代中使用 KF 计算新息对数似然，\n$$\n\\mathcal{L} = -\\frac{1}{2} \\sum_{k=0}^{T-1} \\left( \\log\\left((2\\pi)^m \\det \\mathbf{S}_k\\right) + \\mathbf{e}_k^\\top \\mathbf{S}_k^{-1} \\mathbf{e}_k \\right),\n$$\n其中 $\\mathbf{e}_k = y_k - \\mathbf{H}\\,\\hat{\\mathbf{x}}_{k|k-1} - \\mathbf{D}\\,u_k$，$\\hat{\\mathbf{x}}_{k|k-1}$ 是单步预测均值，$\\mathbf{S}_k = \\mathbf{H}\\,\\mathbf{P}_{k|k-1}\\,\\mathbf{H}^\\top + R$，以及 $m = 1$ 是测量维度。\n\n实现上述算法并将其应用于以下测试套件。对每个测试用例，使用给定的真实协方差和固定的伪随机种子模拟一个数据集。然后，从 $\\mathbf{Q}$ 和 $R$ 的一个通用初始猜测值开始，运行 EM 更新，直到收敛或达到最大迭代次数。对每个用例，输出一个布尔值，指示是否根据上述准则达到了收敛。\n\n所有用例的通用初始条件和初始猜测值：\n- 初始状态均值 $\\mathbf{x}_0 = \\begin{bmatrix} 0.5 \\\\ 0.0 \\end{bmatrix}$。\n- 初始状态协方差 $\\mathbf{P}_0 = \\begin{bmatrix} 10^{-4}  0 \\\\ 0  10^{-3} \\end{bmatrix}$。\n- 初始猜测值 $\\mathbf{Q}^{(0)} = \\begin{bmatrix} 10^{-5}  0 \\\\ 0  10^{-3} \\end{bmatrix}$ 和 $R^{(0)} = 10^{-2}$。\n\n使用输入电流序列\n$$\nu_k = 0.5 + \\sin(0.03\\,k) + 0.1\\,\\sin(0.005\\,k^2),\\quad k = 0,1,\\dots,T-1,\n$$\n该序列是确定性的。\n\n测试用例 1（理想路径，中等噪声）：\n- 长度 $T = 200$。\n- 矩阵\n$$\n\\mathbf{A} = \\begin{bmatrix} 1  0 \\\\ 0  0.98 \\end{bmatrix},\\quad\n\\mathbf{B} = \\begin{bmatrix} -0.001 \\\\ 0.02 \\end{bmatrix},\\quad\n\\mathbf{H} = \\begin{bmatrix} 0.1  1.0 \\end{bmatrix},\\quad\n\\mathbf{D} = \\begin{bmatrix} -0.05 \\end{bmatrix}.\n$$\n- 真实协方差\n$$\n\\mathbf{Q}_{\\text{true}} = \\begin{bmatrix} 10^{-6}  0 \\\\ 0  10^{-4} \\end{bmatrix},\\quad R_{\\text{true}} = 10^{-3}.\n$$\n- 随机种子 $7$。\n\n测试用例 2（边界情况，过程噪声非常小）：\n- 长度 $T = 150$。\n- $\\mathbf{A}$、$\\mathbf{B}$、$\\mathbf{H}$、$\\mathbf{D}$ 与测试用例 1 相同。\n- 真实协方差\n$$\n\\mathbf{Q}_{\\text{true}} = \\begin{bmatrix} 10^{-9}  0 \\\\ 0  10^{-6} \\end{bmatrix},\\quad R_{\\text{true}} = 5\\times 10^{-4}.\n$$\n- 随机种子 $11$。\n\n测试用例 3（边缘情况，测量噪声高）：\n- 长度 $T = 250$。\n- $\\mathbf{A}$、$\\mathbf{B}$、$\\mathbf{H}$、$\\mathbf{D}$ 与测试用例 1 相同。\n- 真实协方差\n$$\n\\mathbf{Q}_{\\text{true}} = \\begin{bmatrix} 5\\times 10^{-6}  0 \\\\ 0  2\\times 10^{-4} \\end{bmatrix},\\quad R_{\\text{true}} = 5\\times 10^{-2}.\n$$\n- 随机种子 $19$。\n\n每个用例的模拟过程：\n- 从 $\\mathbf{x}_0$ 开始，使用给定的 $\\mathbf{A}$、$\\mathbf{B}$、$\\mathbf{Q}_{\\text{true}}$ 和输入 $u_k$ 递归地生成 $\\mathbf{x}_{k+1}$，其中 $\\mathbf{w}_k$ 使用指定的种子从 $\\mathcal{N}(\\mathbf{0}, \\mathbf{Q}_{\\text{true}})$ 采样。\n- 使用 $\\mathbf{H}$、$\\mathbf{D}$ 和 $R_{\\text{true}}$ 从测量方程生成 $y_k$，其中 $v_k$ 使用指定的种子从 $\\mathcal{N}(0, R_{\\text{true}})$ 采样。\n\n算法要求：\n- 使用卡尔曼滤波器 (KF) 和 Rauch–Tung–Striebel (RTS) 平滑器计算平滑均值 $\\mathbb{E}[\\mathbf{x}_k \\mid y_{0:T-1}]$、平滑协方差 $\\mathrm{Cov}(\\mathbf{x}_k \\mid y_{0:T-1})$ 和滞后一阶协方差 $\\mathrm{Cov}(\\mathbf{x}_k,\\mathbf{x}_{k+1} \\mid y_{0:T-1})$，用于 EM 更新。\n- 通过对称化和必要时的特征值裁剪，确保更新后的 $\\mathbf{Q}$ 和 $R$ 保持对称正定。\n- 在每次迭代中，使用当前的 $\\mathbf{Q}$ 和 $R$ 通过 KF 计算新息对数似然。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$），其中每个结果是一个布尔值，指示相应测试用例是否满足收敛准则。\n\n此问题不需要物理单位。不使用角度。不使用百分比。",
            "solution": "在线性状态空间模型中估计过程和测量噪声协方差的问题是系统辨识和控制理论中一个明确定义的标准问题。所提出的方法，即使用带有 Rauch–Tung–Striebel (RTS) 平滑器的期望最大化 (EM) 算法，是一种经典方法。所有提供的参数、方程和条件在科学上都是合理的、一致的且计算上可行的。该问题是有效的，可以按所述方式解决。\n\n解决方案涉及实现 EM 算法，以迭代地优化过程噪声协方差 $\\mathbf{Q}$ 和测量噪声方差 $R$ 的估计。每次迭代包括两个步骤：期望 (E) 步骤和最大化 (M) 步骤。\n\n**1. 状态空间模型和数据模拟**\n\n首先，对于每个测试用例，我们根据提供的真实模型生成一个长度为 $T$ 的合成数据集。离散时间线性状态空间模型由以下公式给出：\n$$\n\\mathbf{x}_{k+1} = \\mathbf{A}\\,\\mathbf{x}_k + \\mathbf{B}\\,u_k + \\mathbf{w}_k, \\quad \\mathbf{w}_k \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{Q}_{\\text{true}})\n$$\n$$\ny_k = \\mathbf{H}\\,\\mathbf{x}_k + \\mathbf{D}\\,u_k + v_k, \\quad v_k \\sim \\mathcal{N}(0, R_{\\text{true}})\n$$\n从给定的初始状态 $\\mathbf{x}_0$ 开始，我们递归地生成状态序列 $\\{\\mathbf{x}_k\\}_{k=1}^{T-1}$ 和测量序列 $\\{y_k\\}_{k=0}^{T-1}$。过程噪声 $\\mathbf{w}_k$ 和测量噪声 $v_k$ 是使用固定的伪随机种子从各自的零均值高斯分布中抽取的，其真实协方差分别为 $\\mathbf{Q}_{\\text{true}}$ 和 $R_{\\text{true}}$，以确保可复现性。输入序列 $u_k$ 是确定性的。这个模拟数据集 $\\{y_k, u_k\\}_{k=0}^{T-1}$ 是估计问题的“观测数据”。\n\n**2. 期望最大化 (EM) 算法**\n\nEM 算法旨在找到使观测数据的对数似然最大化的参数 ($\\mathbf{Q}$, $R$)。它通过迭代地最大化完整数据对数似然的期望来实现这一点，其中隐藏状态 $\\{\\mathbf{x}_k\\}$ 被视为缺失数据。\n\n**2.1. E-步骤：状态平滑**\n\n在 E-步骤中，给定当前的参数估计 $\\mathbf{Q}^{(i)}$ 和 $R^{(i)}$，我们计算完整数据充分统计量在给定观测测量值 $y_{0:T-1}$ 条件下的条件期望。对于线性高斯模型，这些统计量是平滑状态均值和协方差的函数。我们使用一个两遍过程来计算它们：\n\n**a) 卡尔曼滤波器（前向传递）：** 卡尔曼滤波器 (KF) 从 $k=0$ 到 $T-1$ 处理数据。它递归地计算滤波后的状态估计 $\\hat{\\mathbf{x}}_{k|k} = \\mathbb{E}[\\mathbf{x}_k | y_{0:k}]$ 及其协方差 $\\mathbf{P}_{k|k} = \\mathrm{Cov}(\\mathbf{x}_k | y_{0:k})$。关键步骤是：\n-   **初始化：** $\\hat{\\mathbf{x}}_{0|-1} = \\mathbf{x}_0$，$\\mathbf{P}_{0|-1} = \\mathbf{P}_0$。\n-   **预测：** 对于 $k=0, \\dots, T-1$：\n    $$\n    \\hat{\\mathbf{x}}_{k|k-1} = \\mathbf{A}\\,\\hat{\\mathbf{x}}_{k-1|k-1} + \\mathbf{B}\\,u_{k-1} \\quad (\\text{对于 } k>0)\n    $$\n    $$\n    \\mathbf{P}_{k|k-1} = \\mathbf{A}\\,\\mathbf{P}_{k-1|k-1}\\,\\mathbf{A}^\\top + \\mathbf{Q}^{(i)} \\quad (\\text{对于 } k>0)\n    $$\n-   **更新：**\n    $$\n    \\mathbf{e}_k = y_k - (\\mathbf{H}\\,\\hat{\\mathbf{x}}_{k|k-1} + \\mathbf{D}\\,u_k)\n    $$\n    $$\n    S_k = \\mathbf{H}\\,\\mathbf{P}_{k|k-1}\\,\\mathbf{H}^\\top + R^{(i)}\n    $$\n    $$\n    \\mathbf{K}_k = \\mathbf{P}_{k|k-1}\\,\\mathbf{H}^\\top S_k^{-1}\n    $$\n    $$\n    \\hat{\\mathbf{x}}_{k|k} = \\hat{\\mathbf{x}}_{k|k-1} + \\mathbf{K}_k \\mathbf{e}_k\n    $$\n    $$\n    \\mathbf{P}_{k|k} = (\\mathbf{I} - \\mathbf{K}_k \\mathbf{H})\\mathbf{P}_{k|k-1}\n    $$\nKF 还得出用于监控收敛的新息对数似然：\n$$\n\\mathcal{L}(\\mathbf{Q}^{(i)}, R^{(i)}) = -\\frac{1}{2} \\sum_{k=0}^{T-1} \\left( \\log(2\\pi S_k) + \\frac{\\mathbf{e}_k^2}{S_k} \\right)\n$$\n所有预测和滤波的量（$\\hat{\\mathbf{x}}_{k|k-1}, \\mathbf{P}_{k|k-1}, \\hat{\\mathbf{x}}_{k|k}, \\mathbf{P}_{k|k}$），对于 $k=0, \\dots, T-1$，都为后向传递存储起来。\n\n**b) Rauch–Tung–Striebel (RTS) 平滑器（后向传递）：** RTS 平滑器使用 KF 的结果来计算以整个数据序列为条件的平滑估计。它从 $k=T-1$ 向后运行到 $0$。令 $\\hat{\\mathbf{x}}_{k|T-1} \\equiv \\hat{\\mathbf{x}}_k^s$ 和 $\\mathbf{P}_{k|T-1} \\equiv \\mathbf{P}_k^s$。\n-   **初始化：** $\\hat{\\mathbf{x}}_{T-1}^s = \\hat{\\mathbf{x}}_{T-1|T-1}$，$\\mathbf{P}_{T-1}^s = \\mathbf{P}_{T-1|T-1}$。\n-   **后向递归：** 对于 $k=T-2, \\dots, 0$：\n    $$\n    \\mathbf{J}_k = \\mathbf{P}_{k|k}\\,\\mathbf{A}^\\top \\mathbf{P}_{k+1|k}^{-1}\n    $$\n    $$\n    \\hat{\\mathbf{x}}_k^s = \\hat{\\mathbf{x}}_{k|k} + \\mathbf{J}_k(\\hat{\\mathbf{x}}_{k+1}^s - \\hat{\\mathbf{x}}_{k+1|k})\n    $$\n    $$\n    \\mathbf{P}_k^s = \\mathbf{P}_{k|k} + \\mathbf{J}_k(\\mathbf{P}_{k+1}^s - \\mathbf{P}_{k+1|k})\\mathbf{J}_k^\\top\n    $$\n平滑器还计算平滑的滞后一阶互协方差，$\\mathbf{P}_{k+1,k|T-1} \\equiv \\mathbf{P}_{k+1,k}^s = \\mathrm{Cov}(\\mathbf{x}_{k+1}, \\mathbf{x}_k | y_{0:T-1})$，这对于 $\\mathbf{Q}$ 的更新至关重要：\n$$\n\\mathbf{P}_{k+1,k}^s = \\mathbf{P}_{k+1}^s \\mathbf{J}_k^\\top\n$$\n\n**2.2. M-步骤：参数更新**\n\n在 M-步骤中，我们使用 E-步骤中的平滑统计量更新参数 $\\mathbf{Q}$ 和 $R$，以最大化期望的完整数据对数似然。更新方程为：\n$$\n\\mathbf{Q}^{(i+1)} = \\frac{1}{T-1} \\sum_{k=0}^{T-2} \\mathbb{E}\\left[(\\mathbf{x}_{k+1} - \\mathbf{A}\\mathbf{x}_k - \\mathbf{B}u_k)(\\mathbf{x}_{k+1} - \\mathbf{A}\\mathbf{x}_k - \\mathbf{B}u_k)^\\top \\mid y_{0:T-1}\\right]\n$$\n$$\nR^{(i+1)} = \\frac{1}{T} \\sum_{k=0}^{T-1} \\mathbb{E}\\left[(y_k - \\mathbf{H}\\mathbf{x}_k - \\mathbf{D}u_k)^2 \\mid y_{0:T-1}\\right]\n$$\n使用平滑估计的属性展开这些期望，得到：\n$$\n\\mathbf{Q}^{(i+1)} = \\frac{1}{T-1} \\sum_{k=0}^{T-2} \\left[ (\\hat{\\mathbf{x}}_{k+1}^s - \\mathbf{A}\\hat{\\mathbf{x}}_k^s - \\mathbf{B}u_k)(\\hat{\\mathbf{x}}_{k+1}^s - \\mathbf{A}\\hat{\\mathbf{x}}_k^s - \\mathbf{B}u_k)^\\top + \\boldsymbol{\\Gamma}_k \\right]\n$$\n其中 $\\boldsymbol{\\Gamma}_k = \\mathbf{P}_{k+1}^s + \\mathbf{A}\\mathbf{P}_k^s\\mathbf{A}^\\top - \\mathbf{A}(\\mathbf{P}_{k+1,k}^s)^\\top - \\mathbf{P}_{k+1,k}^s\\mathbf{A}^\\top$。\n对于测量方差：\n$$\nR^{(i+1)} = \\frac{1}{T} \\sum_{k=0}^{T-1} \\left[ (y_k - \\mathbf{H}\\hat{\\mathbf{x}}_k^s - \\mathbf{D}u_k)^2 + \\mathbf{H}\\mathbf{P}_k^s\\mathbf{H}^\\top \\right]\n$$\n\n为了确保数值稳定性和物理意义，更新后的协方差必须是对称半正定的。$\\mathbf{Q}^{(i+1)}$ 通过 $\\mathbf{Q} \\leftarrow (\\mathbf{Q} + \\mathbf{Q}^\\top)/2$ 进行对称化。然后，计算其特征值，任何小于一个小的正下限（例如 $10^{-15}$）的特征值都被替换为该下限，然后再重构矩阵。$R^{(i+1)}$ 简单地被限制在同一个小值以上。\n\n**3. 迭代和收敛**\n\n重复 E 和 M 步骤，直到满足收敛准则或达到最大迭代次数 $N_{\\text{max}} = 60$。在第 $i$ 次迭代时的收敛由三个条件定义：\n1.  $\\mathbf{Q}$ 的相对变化低于容差 $\\tau = 0.05$：$\\frac{\\|\\mathbf{Q}^{(i)} - \\mathbf{Q}^{(i-1)}\\|_F}{\\max(\\|\\mathbf{Q}^{(i-1)}\\|_F, \\epsilon)} \\le \\tau$。\n2.  $R$ 的相对变化低于容差：$\\frac{|R^{(i)} - R^{(i-1)}|}{\\max(|R^{(i-1)}|, \\epsilon)} \\le \\tau$。\n3.  新息对数似然在最后五次迭代中（从 $i-4$ 到 $i$，要求 $i \\ge 4$）是单调不减的：对于 $j=i-3, \\dots, i$，$\\mathcal{L}^{(j)} \\ge \\mathcal{L}^{(j-1)}$，允许有小的数值容差。\n\n将此过程应用于每个测试用例，从指定的初始猜测值 $\\mathbf{Q}^{(0)}$ 和 $R^{(0)}$ 开始，并记录指示是否达到收敛的布尔结果。",
            "answer": "```python\nimport numpy as np\nfrom numpy.linalg import inv, norm, eigh\n\ndef solve():\n    \"\"\"\n    Main solver function to run EM algorithm on all test cases and print results.\n    \"\"\"\n    \n    # Common parameters for all test cases\n    x0 = np.array([0.5, 0.0])\n    P0 = np.array([[1e-4, 0], [0, 1e-3]])\n    Q_init = np.array([[1e-5, 0], [0, 1e-3]])\n    R_init = 1e-2\n    \n    # Common system matrices for all test cases\n    A = np.array([[1.0, 0.0], [0.0, 0.98]])\n    B = np.array([[-0.001], [0.02]])\n    H = np.array([[0.1, 1.0]])\n    D = np.array([[-0.05]])\n    \n    test_cases = [\n        # Case 1\n        {\n            \"T\": 200, \"A\": A, \"B\": B, \"H\": H, \"D\": D, \"x0\": x0, \"P0\": P0,\n            \"Q_true\": np.array([[1e-6, 0], [0, 1e-4]]),\n            \"R_true\": 1e-3, \"seed\": 7,\n            \"Q_init\": Q_init, \"R_init\": R_init\n        },\n        # Case 2\n        {\n            \"T\": 150, \"A\": A, \"B\": B, \"H\": H, \"D\": D, \"x0\": x0, \"P0\": P0,\n            \"Q_true\": np.array([[1e-9, 0], [0, 1e-6]]),\n            \"R_true\": 5e-4, \"seed\": 11,\n            \"Q_init\": Q_init, \"R_init\": R_init\n        },\n        # Case 3\n        {\n            \"T\": 250, \"A\": A, \"B\": B, \"H\": H, \"D\": D, \"x0\": x0, \"P0\": P0,\n            \"Q_true\": np.array([[5e-6, 0], [0, 2e-4]]),\n            \"R_true\": 5e-2, \"seed\": 19,\n            \"Q_init\": Q_init, \"R_init\": R_init\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        converged = run_em_for_case(case)\n        results.append(converged)\n\n    print(f\"[{','.join(map(str, [r.lower() for r in map(str, results)]))}]\")\n\ndef simulate_data(params):\n    \"\"\"Generates synthetic data from the state-space model.\"\"\"\n    T, A, B, H, D = params[\"T\"], params[\"A\"], params[\"B\"], params[\"H\"], params[\"D\"]\n    x0, Q_true, R_true, seed = params[\"x0\"], params[\"Q_true\"], params[\"R_true\"], params[\"seed\"]\n    \n    rng = np.random.default_rng(seed)\n    \n    n_states = x0.shape[0]\n    x = np.zeros((T, n_states))\n    y = np.zeros(T)\n    u = np.zeros(T)\n    \n    x[0] = x0\n    \n    for k in range(T):\n        u[k] = 0.5 + np.sin(0.03 * k) + 0.1 * np.sin(0.005 * k**2)\n        v_k = rng.normal(0, np.sqrt(R_true))\n        y[k] = (H @ x[k] + D @ np.array([[u[k]]]))[0, 0] + v_k\n        if k  T - 1:\n            w_k = rng.multivariate_normal(np.zeros(n_states), Q_true)\n            x[k+1] = A @ x[k] + B.flatten() * u[k] + w_k\n            \n    return y, u\n\ndef kalman_filter(y, u, A, B, H, D, Q, R, x0, P0):\n    \"\"\"Performs the Kalman filter forward pass.\"\"\"\n    T = len(y)\n    n_states = A.shape[0]\n\n    x_pred = np.zeros((T, n_states))\n    P_pred = np.zeros((T, n_states, n_states))\n    x_filt = np.zeros((T, n_states))\n    P_filt = np.zeros((T, n_states, n_states))\n    log_likelihood = 0.0\n\n    x_filt_prev = x0\n    P_filt_prev = P0\n    \n    for k in range(T):\n        if k > 0:\n            x_pred_k = A @ x_filt_prev + B.flatten() * u[k-1]\n            P_pred_k = A @ P_filt_prev @ A.T + Q\n        else:\n            x_pred_k = x0\n            P_pred_k = P0\n        \n        e_k = y[k] - (H @ x_pred_k + D * u[k])[0, 0]\n        S_k = (H @ P_pred_k @ H.T + R)[0, 0]\n        \n        if S_k = 0: return None\n        \n        K_k = P_pred_k @ H.T / S_k\n        \n        x_filt_k = x_pred_k + K_k.flatten() * e_k\n        P_filt_k = (np.eye(n_states) - K_k @ H) @ P_pred_k\n        \n        x_pred[k], P_pred[k] = x_pred_k, P_pred_k\n        x_filt[k], P_filt[k] = x_filt_k, P_filt_k\n        x_filt_prev, P_filt_prev = x_filt_k, P_filt_k\n        \n        log_likelihood += -0.5 * (np.log(2 * np.pi * S_k) + e_k**2 / S_k)\n        \n    return x_pred, P_pred, x_filt, P_filt, log_likelihood\n\ndef rts_smoother(A, x_pred, P_pred, x_filt, P_filt):\n    \"\"\"Performs the Rauch-Tung-Striebel backward pass.\"\"\"\n    T = x_filt.shape[0]\n    n_states = A.shape[0]\n\n    x_smooth = np.copy(x_filt)\n    P_smooth = np.copy(P_filt)\n    P_lag1_smooth = np.zeros((T, n_states, n_states))\n\n    for k in range(T - 2, -1, -1):\n        try:\n            P_pred_inv = inv(P_pred[k+1])\n        except np.linalg.LinAlgError:\n            return None\n        \n        J_k = P_filt[k] @ A.T @ P_pred_inv\n        x_smooth[k] += J_k @ (x_smooth[k+1] - x_pred[k+1])\n        P_smooth[k] += J_k @ (P_smooth[k+1] - P_pred[k+1]) @ J_k.T\n    \n    P_lag1_smooth[T-1] = (np.eye(n_states) - (P_filt[T-1] @ H.T / (H @ P_filt[T-1] @ H.T + R_init)) @ H) @ A @ P_filt[T-2] # Simplified from a known formula\n    for k in range(T-2, -1, -1):\n         J_prev = P_filt[k-1] @ A.T @ inv(P_pred[k]) if k > 0 else P0 @ A.T @ inv(P_pred[k])\n         P_lag1_smooth[k] = P_smooth[k] @ J_prev.T + J_k @ (P_lag1_smooth[k+1] - A @ P_smooth[k]) if 'J_k' in locals() else P_smooth[k] @ J_prev.T\n    return x_smooth, P_smooth, P_lag1_smooth\n\n\ndef m_step(y, u, A, B, H, D, T, x_smooth, P_smooth, P_lag1_smooth):\n    \"\"\"Performs the M-step of the EM algorithm.\"\"\"\n    n_states = A.shape[0]\n    \n    beta = np.zeros((T, n_states, n_states))\n    alpha = np.zeros((T, n_states))\n\n    for k in range(T):\n        beta[k] = P_smooth[k] + np.outer(x_smooth[k], x_smooth[k])\n        alpha[k] = x_smooth[k]\n\n    C = np.zeros((T-1, n_states, n_states))\n    for k in range(T-1):\n      C[k] = P_lag1_smooth[k] + np.outer(alpha[k+1], alpha[k])\n\n    sum_beta_T = np.sum(beta[1:T], axis=0)\n    sum_beta_T_1 = np.sum(beta[0:T-1], axis=0)\n    sum_C = np.sum(C[0:T-1], axis=0)\n    \n    sum_u_x_T_1 = np.sum([u[k] * alpha[k] for k in range(T-1)], axis=0)\n    sum_u_sq_T_1 = np.sum([u[k]**2 for k in range(T-1)])\n\n    E = sum_beta_T\n    F = sum_C.T\n    G = sum_beta_T_1\n    H_m = np.sum([u[k] * alpha[k+1] for k in range(T-1)], axis=0)\n    I_m = sum_u_x_T_1\n    J_m = sum_u_sq_T_1\n\n    AB_est = np.linalg.solve(np.block([[G, I_m.reshape(-1,1)],[I_m.reshape(1,-1), np.array([[J_m]]) ]]).T, np.vstack([F, H_m])).T\n    A_est, B_est = AB_est[:,:n_states], AB_est[:,n_states:]\n\n    Q_new = (E - A_est @ F - B_est @ H_m.reshape(1,-1)) / (T-1)\n\n    sum_R = 0\n    for k in range(T):\n        sum_R += y[k]**2 - 2*y[k]*(D*u[k] + H @ alpha[k]) + (D*u[k])**2 + 2*D*u[k]*H @ alpha[k] + np.trace(H @ beta[k] @ H.T)\n    R_new = sum_R/T\n\n    return Q_new, R_new[0,0]\n\ndef enforce_psd(M, min_eig=1e-15):\n    \"\"\"Enforces a matrix to be symmetric positive semi-definite.\"\"\"\n    M_sym = (M + M.T) / 2\n    eigvals, eigvecs = eigh(M_sym)\n    eigvals[eigvals  min_eig] = min_eig\n    return eigvecs @ np.diag(eigvals) @ eigvecs.T\n\ndef run_em_for_case(case_params):\n    \"\"\"Runs the EM algorithm for a single test case.\"\"\"\n    y, u = simulate_data(case_params)\n    \n    A_true, B_true, H_true, D_true = case_params[\"A\"], case_params[\"B\"], case_params[\"H\"], case_params[\"D\"]\n    x0, P0 = case_params[\"x0\"], case_params[\"P0\"]\n    Q, R = np.copy(case_params[\"Q_init\"]), case_params[\"R_init\"]\n    \n    max_iter = 60\n    tol = 0.05\n    eps_norm = 1e-12\n    ll_history = []\n    \n    for i in range(max_iter):\n        Q_old, R_old = np.copy(Q), R\n        \n        kf_out = kalman_filter(y, u, A_true, B_true, H_true, D_true, Q, R, x0, P0)\n        if kf_out is None: return False\n        x_pred, P_pred, x_filt, P_filt, log_likelihood = kf_out\n        ll_history.append(log_likelihood)\n\n        rts_out = rts_smoother(A_true, x_pred, P_pred, x_filt, P_filt)\n        if rts_out is None: return False\n        x_smooth, P_smooth, P_lag1_smooth = rts_out\n\n        Q_new, R_new = m_step(y, u, A_true, B_true, H_true, D_true, len(y), x_smooth, P_smooth, P_lag1_smooth)\n        \n        Q = enforce_psd(Q_new)\n        R = max(R_new, 1e-15)\n\n        delta_Q = norm(Q - Q_old, 'fro') / max(norm(Q_old, 'fro'), eps_norm)\n        delta_R = abs(R - R_old) / max(abs(R_old), eps_norm)\n\n        if delta_Q = tol and delta_R = tol:\n            if i >= 4:\n                last_five_ll = ll_history[-5:]\n                is_non_decreasing = all(last_five_ll[j] >= last_five_ll[j-1] - 1e-9 for j in range(1, 5))\n                if is_non_decreasing:\n                    return True\n    return False\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}