{
    "hands_on_practices": [
        {
            "introduction": "在评估任何采样策略的有效性之前，我们需要一套客观的度量标准来量化样本集的空间填充质量。此练习介绍三个核心的几何指标：填充距离 $h_X$、分离距离 $q_X$ 和网格比 $\\rho_X$。通过亲手计算这些指标 ，您将深入理解它们如何分别揭示样本覆盖范围内的最大“空洞”以及样本点之间的最小间距，从而为评价和比较不同的实验设计方案提供坚实的量化基础。",
            "id": "3951685",
            "problem": "考虑一个用于电池自动化设计和仿真的三参数归一化设计空间，该空间定义为单位立方体 $[0,1]^3$，其参数分别为电极孔隙率 $\\phi$、电解质盐浓度 $c$ 和隔膜厚度 $\\delta$，每个参数都归一化到 $[0,1]$ 区间内。设 $X = \\{x_i\\}_{i=1}^N \\subset [0,1]^3$ 是一个有限样本集，用于训练一个高保真电化学模拟器的代理模型。在 $\\mathbb{R}^3$ 中的标准 Euclidean 度量下，$X$ 的空间填充质量可以通过填充距离 $h_X$、分离距离 $q_X$ 和网格比 $\\rho_X = h_X/q_X$ 来表征。填充距离 $h_X$ 是域中任意点到 $X$ 中最近样本的最坏情况距离，分离距离 $q_X$ 是 $X$ 中不同样本之间最小 Euclidean 距离的一半，而网格比 $\\rho_X$ 是这两个量的比值。\n\n您必须为几个指定的样本集计算 $h_X$、$q_X$ 和 $\\rho_X$。计算时，通过在 $[0,1]^3$ 上使用统一的笛卡尔网格搜索来近似 $h_X$，每个轴上取预定分辨率 $n_g$ 个点（包括端点），以评估网格点上的最近样本距离。使用 Euclidean 范数来测量距离。距离以归一化立方体边长为单位（无量纲）。角度单位不适用。输出必须四舍五入到 $6$ 位小数。\n\n对于每个测试用例，程序的输入是固定的并嵌入在程序中：样本集 $X$ 和网格分辨率 $n_g$。您的程序应为每个测试用例计算一个三元组 $[h_X,q_X,\\rho_X]$，并将所有测试用例的结果汇总到单行输出中，格式如下文所述。\n\n使用以下测试套件（每个用例提供一个特定的 $X$ 和 $n_g$）：\n\n- 用例 A（多样化设计，类似于拉丁超立方采样 (LHS)）：$N = 10$，$n_g = 25$，其中\n  $$\n  X_A = \\Big\\{\n  (0.05,0.62,0.11),\\,\n  (0.18,0.86,0.73),\\,\n  (0.29,0.19,0.44),\\,\n  (0.41,0.48,0.95),\\,\n  (0.52,0.03,0.29),\\,\n  (0.63,0.77,0.05),\\,\n  (0.74,0.34,0.58),\\,\n  (0.80,0.10,0.88),\\,\n  (0.92,0.56,0.21),\\,\n  (0.15,0.72,0.37)\n  \\Big\\}.\n  $$\n\n- 用例 B（聚集在一个角附近，说明覆盖性差）：$N = 10$，$n_g = 25$，其中\n  $$\n  X_B = \\Big\\{\n  (0.02,0.01,0.03),\\,\n  (0.05,0.04,0.02),\\,\n  (0.08,0.06,0.05),\\,\n  (0.10,0.02,0.08),\\,\n  (0.07,0.09,0.04),\\,\n  (0.12,0.11,0.07),\\,\n  (0.15,0.14,0.06),\\,\n  (0.18,0.16,0.10),\\,\n  (0.20,0.19,0.12),\\,\n  (0.22,0.18,0.15)\n  \\Big\\}.\n  $$\n\n- 用例 C（结构化的内部网格，$3\\times 3\\times 3$）：$N = 27$，$n_g = 30$，其中\n  $$\n  X_C = \\{(x,y,z) \\mid x \\in \\{1/6,\\, 1/2,\\, 5/6\\},\\, y \\in \\{1/6,\\, 1/2,\\, 5/6\\},\\, z \\in \\{1/6,\\, 1/2,\\, 5/6\\}\\}.\n  $$\n\n- 用例 D（仅立方体角点）：$N = 8$，$n_g = 30$，其中\n  $$\n  X_D = \\{(x,y,z) \\mid x \\in \\{0,\\,1\\},\\, y \\in \\{0,\\,1\\},\\, z \\in \\{0,\\,1\\}\\}.\n  $$\n\n科学真实性要求：您必须使用 $\\mathbb{R}^3$ 中的 Euclidean 距离；通过在 $[0,1]^3$ 上分辨率为每轴 $n_g$ 个点（包括端点）的统一笛卡尔网格的每个点上评估最近样本距离来近似 $h_X$；通过成对样本距离精确计算 $q_X$，其值为不同样本间最小距离的一半；然后计算 $\\rho_X = h_X/q_X$。不允许进行其他简化。\n\n覆盖性设计：该测试套件探索了一个通用的“理想路径”用例（用例 A）、一个严重的聚类边缘用例（用例 B）、一个结构化的准均匀内部网格（用例 C）和一个仅边界的用例（用例 D）。\n\n最终输出格式：您的程序应生成单行输出，其中包含结果，形式为一个逗号分隔的列表，包含四个用例的三元组，每个三元组本身是三个四舍五入到 $6$ 位小数的浮点数的逗号分隔列表，不含空格，并用方括号括起来。例如，您的输出必须看起来像\n$$\n[\\,[h_A,q_A,\\rho_A],\\,[h_B,q_B,\\rho_B],\\,[h_C,q_C,\\rho_C],\\,[h_D,q_D,\\rho_D]]\n$$\n但以纯文本形式打印，不带额外空格，使用十进制浮点数。$h_X$、$q_X$ 和 $\\rho_X$ 的值是无量纲的。",
            "solution": "该问题要求计算三个标准度量，用于表征三维单位立方体 $[0,1]^3$ 内样本集 $X = \\{x_i\\}_{i=1}^N$ 的空间填充特性。这些度量是填充距离 $h_X$、分离距离 $q_X$ 和网格比 $\\rho_X$。需要对四个不同的样本集 $X_A, X_B, X_C,$ 和 $X_D$ 执行这些计算。底层空间是配备了标准 Euclidean 范数 $\\|v\\|_2 = \\sqrt{v_1^2 + v_2^2 + v_3^2}$ 的 $\\mathbb{R}^3$。\n\n对每个测试用例，求解方法按三个顺序步骤实现：计算分离距离 $q_X$，近似填充距离 $h_X$，最后计算网格比 $\\rho_X$。\n\n### 1. 分离距离 $q_X$ 的计算\n\n分离距离 $q_X$ 量化了样本集 $X$ 中点之间的最小间距。其形式化定义为集合中任意两个不同点之间最小 Euclidean 距离的一半：\n$$\nq_X = \\frac{1}{2} \\min_{i \\neq j} \\|x_i - x_j\\|_2\n$$\n较大的 $q_X$ 意味着样本点分离良好，避免了聚类。\n\n**算法方法**：\n为计算 $q_X$，我们必须计算集合 $X$ 中所有不同点对 $(x_i, x_j)$（其中 $i \\neq j$）之间的 Euclidean 距离。对于一个包含 $N$ 个点的集合，这样的点对总数为 $\\binom{N}{2} = N(N-1)/2$。计算完所有这些成对距离后，找到其中的最小值 $d_{min} = \\min_{i \\neq j} \\|x_i - x_j\\|_2$。然后分离距离为 $q_X = d_{min} / 2$。这个计算可以使用向量化的库函数高效执行，例如 `scipy.spatial.distance.pdist`，它可以计算给定集合中所有点的成对距离。\n\n### 2. 填充距离 $h_X$ 的近似\n\n填充距离 $h_X$（也称为离散度）测量采样中的最大“间隙”。它定义为从域 $[0,1]^3$ 中任意点到其在 $X$ 中最近样本点的最大可能距离：\n$$\nh_X = \\sup_{p \\in [0,1]^3} \\left( \\min_{x_i \\in X} \\|p - x_i\\|_2 \\right)\n$$\n较小的 $h_X$ 表明设计空间的覆盖性更好，因为域中没有点离样本太远。\n\n**算法方法**：\n计算 $h_X$ 的精确值是一个计算上困难的全局优化问题。该问题指定了一种基于在统一笛卡尔网格上进行离散搜索的近似方法。\n在域 $[0,1]^3$ 内构造一个网格 $G$，每个轴的分辨率为 $n_g$ 个点，包括端点。每个轴的坐标由集合 $\\{0, 1/(n_g-1), 2/(n_g-1), \\ldots, 1\\}$ 给出。完整的网格 $G$ 是这些坐标集的笛卡尔积，总共产生 $n_g^3$ 个网格点。\n\n近似的填充距离（我们仍记为 $h_X$）是所有网格点 $g_k \\in G$ 上评估的最近样本距离的最大值：\n$$\nh_X \\approx \\max_{g_k \\in G} \\left( \\min_{x_i \\in X} \\|g_k - x_i\\|_2 \\right)\n$$\n此过程包括以下步骤：\n1.  生成所有 $n_g^3$ 个网格点 $G$ 的集合。\n2.  对于每个网格点 $g_k \\in G$，计算其到每个样本点 $x_i \\in X$ 的距离。\n3.  对于每个 $g_k$，找到这些距离的最小值，即其到 $X$ 中最近邻的距离。\n4.  填充距离 $h_X$ 是所有这些最小距离中的最大值。\n\n这个计算可以被有效地向量化。例如，`scipy.spatial.distance.cdist` 可以计算所有网格点和所有样本点之间的距离矩阵。随后对该矩阵的适当轴执行 `min` 和 `max` 操作即可得到 $h_X$ 的最终值。\n\n### 3. 网格比 $\\rho_X$ 的计算\n\n网格比 $\\rho_X$ 是一个无量纲量，它结合了填充距离和分离距离，为样本质量提供了单一的度量。其定义为：\n$$\n\\rho_X = \\frac{h_X}{q_X}\n$$\n理想的点集其网格比应接近于 $1$，这对应于最大空球半径（$h_X$）等于围绕样本点的最小影响球半径（$q_X$）的情况。大的 $\\rho_X$ 值可能表示覆盖性差（$h_X$ 大）或显著聚类（$q_X$ 小）。\n\n**算法方法**：\n一旦按上述方法计算出 $h_X$ 和 $q_X$ 的值，$\\rho_X$ 就通过它们的直接相除得到。如果 $q_X$ 为零（当样本集中存在重复点时会发生），则网格比未定义。然而，所提供的测试用例均由不同的点组成，因此 $q_X > 0$。\n\n通过将这个三步过程应用于四个指定的测试用例中的每一个，我们系统地推导出所需的度量。然后将结果四舍五入到 $6$ 位小数，并按规定格式化。",
            "answer": "```python\nimport numpy as np\nfrom scipy.spatial.distance import pdist, cdist\n\ndef solve():\n    \"\"\"\n    Computes space-filling metrics (h_X, q_X, rho_X) for four test cases\n    of sample sets in a 3D unit cube.\n    \"\"\"\n\n    def compute_metrics(X, n_g):\n        \"\"\"\n        Calculates separation distance, fill distance, and mesh ratio.\n\n        Args:\n            X (np.ndarray): A set of N sample points, shape (N, 3).\n            n_g (int): The number of grid points per axis for h_X approximation.\n\n        Returns:\n            tuple: A tuple containing (h_X, q_X, rho_X).\n        \"\"\"\n        # Ensure X is a NumPy array\n        X = np.array(X)\n        N = X.shape[0]\n\n        # 1. Compute Separation Distance (q_X)\n        # q_X is half the minimum Euclidean distance between distinct samples.\n        if N > 1:\n            # pdist computes pairwise distances between all points in X.\n            pairwise_distances = pdist(X, 'euclidean')\n            min_dist = np.min(pairwise_distances)\n            q_X = 0.5 * min_dist\n        else:\n            # Undefined for a single point, but we can set it to infinity\n            # to indicate no \"separation\" constraint.\n            # Handle as per problem context if it arises. For these tests N > 1.\n            q_X = np.inf\n\n        # 2. Approximate Fill Distance (h_X)\n        # h_X is the max distance from any point in the domain to its nearest sample.\n        # We approximate this by searching over a uniform grid.\n        \n        # Create grid points\n        axis_coords = np.linspace(0, 1, n_g)\n        grid_points = np.stack(np.meshgrid(axis_coords, axis_coords, axis_coords), axis=-1).reshape(-1, 3)\n\n        # Compute distances from each grid point to each sample point.\n        # cdist(A, B) creates a matrix where entry (i,j) is the distance from A[i] to B[j].\n        # Shape: (n_g**3, N)\n        dist_matrix = cdist(grid_points, X, 'euclidean')\n\n        # For each grid point, find the minimum distance to any sample point.\n        # Shape: (n_g**3,)\n        min_dists_from_grid = np.min(dist_matrix, axis=1)\n\n        # The fill distance h_X is the maximum of these minimum distances.\n        h_X = np.max(min_dists_from_grid)\n\n        # 3. Compute Mesh Ratio (rho_X)\n        if q_X > 0:\n            rho_X = h_X / q_X\n        else:\n            # This case (duplicate points) does not occur in the test suite.\n            rho_X = np.inf\n            \n        return h_X, q_X, rho_X\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Diverse design\n        {\n            \"name\": \"A\",\n            \"n_g\": 25,\n            \"X\": [\n                (0.05, 0.62, 0.11), (0.18, 0.86, 0.73), (0.29, 0.19, 0.44),\n                (0.41, 0.48, 0.95), (0.52, 0.03, 0.29), (0.63, 0.77, 0.05),\n                (0.74, 0.34, 0.58), (0.80, 0.10, 0.88), (0.92, 0.56, 0.21),\n                (0.15, 0.72, 0.37)\n            ]\n        },\n        # Case B: Clustered design\n        {\n            \"name\": \"B\",\n            \"n_g\": 25,\n            \"X\": [\n                (0.02, 0.01, 0.03), (0.05, 0.04, 0.02), (0.08, 0.06, 0.05),\n                (0.10, 0.02, 0.08), (0.07, 0.09, 0.04), (0.12, 0.11, 0.07),\n                (0.15, 0.14, 0.06), (0.18, 0.16, 0.10), (0.20, 0.19, 0.12),\n                (0.22, 0.18, 0.15)\n            ]\n        },\n        # Case C: Structured interior grid\n        {\n            \"name\": \"C\",\n            \"n_g\": 30,\n            \"X\": [(x, y, z) for x in [1/6, 1/2, 5/6] \n                              for y in [1/6, 1/2, 5/6]\n                              for z in [1/6, 1/2, 5/6]]\n        },\n        # Case D: Cube corners\n        {\n            \"name\": \"D\",\n            \"n_g\": 30,\n            \"X\": [(x, y, z) for x in [0, 1] for y in [0, 1] for z in [0, 1]]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        h, q, rho = compute_metrics(case[\"X\"], case[\"n_g\"])\n        results.append([round(val, 6) for val in [h, q, rho]])\n\n    # Format the output string as per the requirement:\n    # [[h_A,q_A,rho_A],[h_B,q_B,rho_B],...] with 6 decimal places.\n    formatted_cases = []\n    for case_result in results:\n        # Format each number to 6 decimal places.\n        formatted_nums = [f\"{num:.6f}\" for num in case_result]\n        formatted_cases.append(f\"[{','.join(formatted_nums)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_cases)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了评估样本集质量的指标后，下一步是学习如何主动构建一个优质的采样设计。本练习将指导您实现一种贪婪最远点采样算法，这是一种强大的序列设计方法，它通过迭代地将新样本点放置在距离现有样本集最远的区域来优化空间填充性。您将探索加权度量空间的概念，这对于处理具有不同物理单位和重要性的多维参数至关重要，并通过跟踪关键指标的演变来观察算法的收敛特性 。",
            "id": "3951689",
            "problem": "考虑一个用于锂离子电池设计的参数域，该参数域表示为一个超矩形 $\\Omega \\subset \\mathbb{R}^d$，其坐标轴对应具有物理意义的参数。为构建适用于自动化电池模拟的空间填充设计，请在一个加权度量空间中实现贪心最远点采样策略，其中权重编码了特定维度的特征尺度，以使度量无量纲化并反映参数敏感度。设 $X_k = \\{x_1, \\dots, x_k\\} \\subset \\Omega$ 表示当前的设计集，并设 $C \\subset \\Omega$ 是在一个网格上采样的有限候选集。定义一个对角正定权重矩阵 $W = \\mathrm{diag}(w_1, \\dots, w_d)$，其中 $w_i = 1/s_i^2$，$s_i > 0$ 是第 $i$ 个参数的特征尺度。定义 $x, y \\in \\Omega$ 之间的加权距离为\n$$\nd_W(x, y) = \\sqrt{(x - y)^\\top W (x - y)} = \\sqrt{\\sum_{i=1}^d w_i (x_i - y_i)^2},\n$$\n当 $s_i$ 的选择与第 $i$ 个坐标的单位相匹配时，该距离是无量纲的。\n\n对于一个有限集 $X \\subset \\Omega$，定义分离距离\n$$\nq_X = \\min_{\\substack{x, y \\in X\\\\ x \\neq y}} d_W(x, y),\n$$\n以及相对于候选集 $C$ 的填充距离\n$$\nh_X = \\max_{z \\in C} \\min_{x \\in X} d_W(z, x).\n$$\n当 $|X| = 1$ 时，约定 $q_X = 0$。贪心最远点算法通过选择以下点来迭代地扩充 $X_k$\n$$\nx_{k+1} = \\operatorname{argmax}_{z \\in C \\setminus X_k} \\left( \\min_{x \\in X_k} d_W(z, x) \\right),\n$$\n起始点选择为在 $d_W$ 度量下最接近 $\\Omega$ 中心的候选点。每次添加点后，计算 $q_{X_k}$ 和 $h_{X_k}$。所有距离都是无量纲的，并且必须报告为四舍五入到六位小数的浮点数。\n\n您必须实现一个完整的程序，该程序：\n- 根据每个轴上指定的分辨率，在 $\\Omega$ 上构建一个完整网格作为候选集 $C$。\n- 通过选择（在 $d_W$ 度量下）最接近 $\\Omega$ 中心的候选点来初始化 $X_1$。\n- 应用贪心最远点规则选择 $K$ 个点，并在每次添加后，在候选集 $C$ 上计算 $q_{X_k}$ 和 $h_{X_k}$。\n\n请使用以下测试套件，它涵盖了电池参数域中的典型行为和边缘行为：\n\n测试用例 A（正常流程，三维，中等各向异性）：\n- 维度 $d = 3$，参数为：电极厚度 $t$（单位：米），孔隙率 $\\varepsilon$（无量纲），以及电解质电导率 $\\kappa$（单位：西门子/米）。\n- 边界 $\\Omega = [60 \\times 10^{-6}, 120 \\times 10^{-6}] \\times [0.25, 0.45] \\times [0.8, 2.0]$。\n- 特征尺度 $s = [30 \\times 10^{-6}, 0.10, 0.60]$，因此 $W = \\mathrm{diag}(1/s_i^2)$。\n- 候选网格分辨率 $\\text{res} = [7, 5, 6]$。\n- 点数 $K = 6$。\n\n测试用例 B（边界行为，二维，强各向异性）：\n- 维度 $d = 2$，参数为：固相扩散系数 $D_s$（单位：平方米/秒），以及交换电流密度 $i_0$（单位：安培/平方米）。\n- 边界 $\\Omega = [1 \\times 10^{-14}, 5 \\times 10^{-14}] \\times [0.5, 2.5]$。\n- 特征尺度 $s = [0.5 \\times 10^{-14}, 1.0]$，因此 $W = \\mathrm{diag}(1/s_i^2)$。\n- 候选网格分辨率 $\\text{res} = [8, 9]$。\n- 点数 $K = 5$。\n\n测试用例 C（边缘情况，一维，候选集耗尽）：\n- 维度 $d = 1$，参数为：隔膜厚度 $\\delta$（单位：米）。\n- 边界 $\\Omega = [10 \\times 10^{-6}, 12 \\times 10^{-6}]$。\n- 特征尺度 $s = [1 \\times 10^{-6}]$，因此 $W = \\mathrm{diag}(1/s_i^2)$。\n- 候选网格分辨率 $\\text{res} = [5]$。\n- 点数 $K = 5$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果是一个由 $[q_{X_k}, h_{X_k}]$ 对（$k = 1, \\dots, K$）组成的列表。例如，输出必须采用以下格式：\n$[ \\text{caseA}, \\text{caseB}, \\text{caseC} ]$\n其中每个 $\\text{caseX}$ 等于一个由四舍五入到六位小数的浮点数组成的列表的列表。所有距离都是无量纲的，并且必须报告为四舍五入到六位小数的浮点数。角度单位不适用。百分比不适用。",
            "solution": "问题陈述是有效的。它在科学上基于计算模拟的实验设计（DoE）领域，在数学上是适定的、客观的，并为实现提供了完整且一致的定义和数据集。该问题要求实现一个贪心最远点采样算法，以在指定的超矩形参数域 $\\Omega \\subset \\mathbb{R}^d$ 内生成空间填充设计。该解决方案涉及多个集成步骤，基于加权度量空间和迭代优化的原理。\n\n首先，我们建立几何设置。参数域 $\\Omega$ 由其沿 $d$ 个维度的下界和上界定义。设计点从中选出的候选点 $C$ 在 $\\Omega$ 上形成一个离散网格。该网格是通过对每个轴上具有指定分辨率的线性间隔一维点集进行笛卡尔积而构建的。第 $i$ 维网格中的点数为 $\\text{res}_i$。\n\n一个关键概念是加权距离 $d_W(x, y)$，定义为：\n$$\nd_W(x, y) = \\sqrt{(x - y)^\\top W (x - y)} = \\sqrt{\\sum_{i=1}^d w_i (x_i - y_i)^2}\n$$\n权重矩阵 $W$ 是对角矩阵，其元素为 $w_i = 1/s_i^2$，其中 $s_i$ 是第 $i$ 个参数的特征尺度。此度量有两个目的：它通过将每个坐标差 $(x_i - y_i)$ 除以其尺度 $s_i$ 来使距离无量纲化，并且它允许编码不同参数之间的不同敏感度或重要性。所有后续的几何计算都在这个加权空间中执行。\n\n算法流程如下：\n\n1.  **初始化**：设计集用单个点 $X_1 = \\{x_1\\}$ 进行初始化。点 $x_1$ 从候选集 $C$ 中选择，使其是在加权距离 $d_W$ 下最接近域 $\\Omega$ 几何中心的点。$\\Omega = \\prod_{i=1}^d [l_i, u_i]$ 的中心 $c$ 是坐标为 $c_i = (l_i + u_i)/2$ 的点。因此，$x_1 = \\arg\\min_{z \\in C} d_W(z, c)$。\n\n2.  **迭代选择**：对于 $k = 1, \\dots, K-1$，通过添加距离现有集合 $X_k$ 最远的候选点来将设计集 $X_k$ 扩充为 $X_{k+1}$。这是贪心最远点或极小化极大选择规则：\n    $$\n    x_{k+1} = \\operatorname{argmax}_{z \\in C \\setminus X_k} \\left( \\min_{x \\in X_k} d_W(z, x) \\right)\n    $$\n    此规则迭代地将新点放置在域中采样最少的区域，这是通过候选集上的填充距离来度量的。为了高效实现这一点，我们维护一个数组，其中包含每个候选点 $z \\in C$ 到当前设计集 $X_k$ 的最小距离。当添加一个新点 $x_{k+1}$ 时，通过取旧距离与到新点 $x_{k+1}$ 的距离的逐元素最小值来更新此数组。然后，要添加的下一个点就是该更新后的最小距离数组中最大值对应的候选点。\n\n3.  **度量计算**：在添加每个点 $x_k$ 之后（对于 $k=1, \\dots, K$），计算集合 $X_k$ 的两个质量度量。\n    *   **分离距离 ($q_{X_k}$)**：此度量衡量设计集内点之间的最小成对距离。其定义为：\n        $$\n        q_{X_k} = \\min_{\\substack{x, y \\in X_k \\\\ x \\neq y}} d_W(x, y)\n        $$\n        按照约定，对于单元素集 $X_1$，$q_{X_1}$ 设为 $0$。对于 $k > 1$，这需要计算 $X_k$ 内所有 $\\binom{k}{2}$ 个成对距离并找到最小值。\n    *   **填充距离 ($h_{X_k}$)**：此度量衡量设计集对候选集 $C$ 的覆盖程度。它被定义为从任何候选点到其在设计集中的最近邻点的最大距离：\n        $$\n        h_{X_k} = \\max_{z \\in C} \\min_{x \\in X_k} d_W(z, x)\n        $$\n        如选择步骤中所述，$h_{X_k}$ 的值恰好是用于选择后续点 $x_{k+2}$ 的最小距离数组的最大值。\n\n对提供的三个测试用例中的每一个都重复此过程。对于每个用例，我们生成一个 $[q_{X_k}, h_{X_k}]$ 对的列表，其中 $k=1, \\dots, K$。所有距离值都按要求四舍五入到六位小数。该实现依赖 `numpy` 进行高效的、向量化的距离计算以及管理候选集和设计集。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"d\": 3,\n            \"bounds\": np.array([[60e-6, 120e-6], [0.25, 0.45], [0.8, 2.0]]),\n            \"scales\": np.array([30e-6, 0.10, 0.60]),\n            \"resolutions\": [7, 5, 6],\n            \"K\": 6,\n        },\n        {\n            \"name\": \"Case B\",\n            \"d\": 2,\n            \"bounds\": np.array([[1e-14, 5e-14], [0.5, 2.5]]),\n            \"scales\": np.array([0.5e-14, 1.0]),\n            \"resolutions\": [8, 9],\n            \"K\": 5,\n        },\n        {\n            \"name\": \"Case C\",\n            \"d\": 1,\n            \"bounds\": np.array([[10e-6, 12e-6]]),\n            \"scales\": np.array([1e-6]),\n            \"resolutions\": [5],\n            \"K\": 5,\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = run_case(case[\"bounds\"], case[\"scales\"], case[\"resolutions\"], case[\"K\"])\n        all_results.append(result)\n\n    # The problem description's textual example `[ caseA, caseB, caseC ]` suggests\n    # standard Python list string representation, which includes spaces.\n    # Therefore, we use the standard string representation of the list.\n    print(str(all_results))\n\n\ndef run_case(bounds, scales, resolutions, K):\n    \"\"\"\n    Executes the greedy farthest-point sampling for a single test case.\n    \"\"\"\n    # 1. Setup: Weights and Candidate Set\n    weights = 1.0 / (scales**2)\n    grid_axes = [np.linspace(b[0], b[1], r) for b, r in zip(bounds, resolutions)]\n    mesh = np.meshgrid(*grid_axes, indexing='ij')\n    candidates = np.vstack([m.ravel() for m in mesh]).T\n    \n    # 2. Initialization: Find starting point x_1\n    center = np.mean(bounds, axis=1)\n    \n    # helper for weighted distance from one point p1 to many points p2\n    def weighted_dist(p1, p2_array):\n        diff = p2_array - p1\n        return np.sqrt(np.sum(weights * diff**2, axis=1))\n\n    dists_to_center = weighted_dist(center, candidates)\n    initial_idx = np.argmin(dists_to_center)\n    \n    X_indices = {initial_idx}\n    X_points = [candidates[initial_idx]]\n    \n    case_results = []\n\n    # 3. Iteratively select points and compute metrics\n    min_dists_to_X = weighted_dist(X_points[0], candidates)\n\n    for k in range(1, K + 1):\n        # Metrics for the current set X_k\n        \n        # Calculate q_Xk (Separation Distance)\n        if k == 1:\n            q_k = 0.0\n        else:\n            current_X_array = np.array(X_points)\n            pairwise_dists = []\n            for i in range(k):\n                for j in range(i + 1, k):\n                    diff = current_X_array[i] - current_X_array[j]\n                    dist = np.sqrt(np.sum(weights * diff**2))\n                    pairwise_dists.append(dist)\n            q_k = np.min(pairwise_dists)\n            \n        # Calculate h_Xk (Fill Distance)\n        # h_k is the max of the current minimum distances to X_k\n        h_k = np.max(min_dists_to_X)\n        \n        case_results.append([round(q_k, 6), round(h_k, 6)])\n        \n        # If we have collected K points, we stop.\n        if k == K:\n            break\n            \n        # Select next point (x_{k+1})\n        # The next point is the candidate farthest from the current set X_k.\n        # To strictly implement C \\ X_k, we mask already selected points.\n        temp_min_dists = np.copy(min_dists_to_X)\n        temp_min_dists[list(X_indices)] = -1.0 # Ensure selected points are not chosen again\n        next_idx = np.argmax(temp_min_dists)\n        \n        next_point = candidates[next_idx]\n        X_indices.add(next_idx)\n        X_points.append(next_point)\n        \n        # Update minimum distances for the new set X_{k+1}\n        dists_to_new_point = weighted_dist(next_point, candidates)\n        min_dists_to_X = np.minimum(min_dists_to_X, dists_to_new_point)\n        \n    return case_results\n\nsolve()\n```"
        },
        {
            "introduction": "标准的空间填充设计通常均匀地探索整个参数空间，但这在许多实际应用中并非最高效的策略。当我们预先知道某些区域（例如电池模型中的高倍率或高温区）对性能影响更大时，我们希望在这些关键区域部署更密集的样本点。此练习介绍了一种先进的自适应采样技术——加权中心Voronoi剖分（CVT），它通过在Lloyd迭代算法中引入权重函数来实现这一目标 。通过这个实践，您将学会如何生成非均匀的、根据问题重要性自适应调整的样本分布，从而显著提升仿真和代理建模的效率。",
            "id": "3951723",
            "problem": "考虑一个用于电池自动化设计和仿真的二维参数域，其中每个点都是代表充电速率和温度的参数对。设充电速率由 $c$ 表示，单位为 C倍率 (C)，温度由 $T$ 表示，单位为开尔文 (K)。将该域定义为一个闭合矩形 $\\Omega = [c_{\\min}, c_{\\max}] \\times [T_{\\min}, T_{\\max}] \\subset \\mathbb{R}^2$。需要采用一种基于质心Voronoi剖分（centroidal Voronoi tessellations）的空间填充采样策略，以强调高充电速率和高温区域。具体来说，定义一个正权重函数 $w(c, T)$，它随 $c$ 和 $T$ 的增加而增加，其表达式如下：\n$$\nw(c, T) = \\exp\\left(\\alpha \\cdot \\frac{c - c_{\\min}}{c_{\\max} - c_{\\min}} + \\beta \\cdot \\frac{T - T_{\\min}}{T_{\\max} - T_{\\min}}\\right),\n$$\n其中 $\\alpha > 0$ 和 $\\beta > 0$ 是给定的常数。\n\n从一个有限的生成点集合 $\\{(c_i, T_i)\\}_{i=1}^k \\subset \\Omega$ 开始，在标准欧几里得度量下定义 $\\Omega$ 的Voronoi划分，每个Voronoi单元对应于 $\\Omega$ 中比其他任何生成点都更接近某一个生成点的点的子集。目标是通过将每个生成点移动到其Voronoi单元在权重函数 $w(c, T)$ 下的加权质心来计算更新后的生成点位置，该过程需使用一个根据第一性原理推导出的算法程序。最终更新后的位置必须使用与域相同的物理单位表示，即充电速率用 C，温度用 K。\n\n为了使计算在数值上易于处理且可通用实现，需在一个分辨率为 $n_x \\times n_y$ 的笛卡尔网格上使用均匀矩形求积来近似所需的积分。将每个网格节点 $(c_j, T_\\ell)$ 视为一个采样点；将每个采样点分配给最近的生成点（按欧几里得距离）以近似Voronoi划分；然后使用离散加权和来近似每个单元的加权质心。对于任何空的Voronoi单元（即没有分配网格节点），在该次迭代中保持其生成点不变。\n\n实现一个迭代更新（Lloyd型迭代），迭代次数为指定的 $N_{\\text{iter}} \\in \\mathbb{N}$，在每次迭代中应用加权质心更新。\n\n您的程序必须为以下每个测试用例计算指定迭代次数后的最终更新生成点位置。对于每个测试用例，输出必须是生成点位置的列表，格式为 $[[c_1, T_1], [c_2, T_2], \\dots, [c_k, T_k]]$，其中每个 $c_i$ 的单位是 C，每个 $T_i$ 的单位是 K。程序必须生成单行输出，其中包含所有测试用例的结果，结果为逗号分隔的列表，并用方括号括起来。\n\n测试套件：\n- 测试用例 1（一般情况）：\n  - 域：$c \\in [0, 6]$ C, $T \\in [293, 333]$ K，因此 $c_{\\min} = 0$, $c_{\\max} = 6$, $T_{\\min} = 293$, $T_{\\max} = 333$。\n  - 权重参数：$\\alpha = 3$, $\\beta = 2$。\n  - 初始生成点：$[(1.0, 300.0), (3.0, 320.0), (5.5, 330.0), (4.0, 295.0)]$。\n  - 网格分辨率：$n_x = 64$, $n_y = 64$。\n  - 迭代次数：$N_{\\text{iter}} = 2$。\n\n- 测试用例 2（边界压力情况）：\n  - 域：$c \\in [0, 10]$ C, $T \\in [273, 343]$ K，因此 $c_{\\min} = 0$, $c_{\\max} = 10$, $T_{\\min} = 273$, $T_{\\max} = 343$。\n  - 权重参数：$\\alpha = 1$, $\\beta = 1$。\n  - 初始生成点：$[(0.2, 273.0), (9.8, 343.0), (0.2, 343.0)]$。\n  - 网格分辨率：$n_x = 60$, $n_y = 60$。\n  - 迭代次数：$N_{\\text{iter}} = 1$。\n\n- 测试用例 3（极端集中情况）：\n  - 域：$c \\in [0, 8]$ C, $T \\in [298, 358]$ K，因此 $c_{\\min} = 0$, $c_{\\max} = 8$, $T_{\\min} = 298$, $T_{\\max} = 358$。\n  - 权重参数：$\\alpha = 8$, $\\beta = 8$。\n  - 初始生成点：$[(1.0, 300.0), (2.0, 330.0), (7.5, 356.0)]$。\n  - 网格分辨率：$n_x = 80$, $n_y = 80$。\n  - 迭代次数：$N_{\\text{iter}} = 1$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表，并用方括号括起来，严格遵循以下格式：\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3]\n$$\n其中每个 $\\text{result}_i$ 是第 $i$ 个测试用例的更新后生成点坐标列表，表示为 $[[c_1, T_1], [c_2, T_2], \\dots]$，其中 $c$ 的单位是 C，$T$ 的单位是 K，不带单位符号。不应打印任何其他文本。",
            "solution": "在提供解决方案之前，对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **域：** 一个二维矩形域 $\\Omega = [c_{\\min}, c_{\\max}] \\times [T_{\\min}, T_{\\max}] \\subset \\mathbb{R}^2$。\n- **参数：** 充电速率 $c$ (C倍率, C) 和温度 $T$ (开尔文, K)。\n- **权重函数：** $w(c, T) = \\exp\\left(\\alpha \\cdot \\frac{c - c_{\\min}}{c_{\\max} - c_{\\min}} + \\beta \\cdot \\frac{T - T_{\\min}}{T_{\\max} - T_{\\min}}\\right)$，其中 $\\alpha > 0$ 且 $\\beta > 0$。\n- **生成点：** 一个有限的点集 $\\{(c_i, T_i)\\}_{i=1}^k \\subset \\Omega$。\n- **划分：** 基于标准欧几里得度量的Voronoi划分。\n- **目标：** 将每个生成点更新为其Voronoi单元的加权质心。\n- **数值近似：**\n    - 使用一个分辨率为 $n_x \\times n_y$ 的笛卡尔网格。\n    - 通过将网格节点分配给最近的生成点来近似Voronoi单元。\n    - 使用离散加权和来近似质心的积分。\n- **空单元处理：** 如果某个生成点的近似Voronoi单元不包含任何网格节点，则其位置在该次迭代中保持不变。\n- **算法：** 执行一个迭代更新（Lloyd型）算法，共进行 $N_{\\text{iter}}$ 次迭代。\n- **测试用例：**\n    1.  **用例 1：** $c \\in [0, 6]$, $T \\in [293, 333]$。$\\alpha = 3$, $\\beta = 2$。初始生成点：$[(1.0, 300.0), (3.0, 320.0), (5.5, 330.0), (4.0, 295.0)]$。网格：$n_x = 64$, $n_y = 64$。迭代次数：$N_{\\text{iter}} = 2$。\n    2.  **用例 2：** $c \\in [0, 10]$, $T \\in [273, 343]$。$\\alpha = 1$, $\\beta = 1$。初始生成点：$[(0.2, 273.0), (9.8, 343.0), (0.2, 343.0)]$。网格：$n_x = 60$, $n_y = 60$。迭代次数：$N_{\\text{iter}} = 1$。\n    3.  **用例 3：** $c \\in [0, 8]$, $T \\in [298, 358]$。$\\alpha = 8$, $\\beta = 8$。初始生成点：$[(1.0, 300.0), (2.0, 330.0), (7.5, 356.0)]$。网格：$n_x = 80$, $n_y = 80$。迭代次数：$N_{\\text{iter}} = 1$。\n- **输出：** 每个测试用例的最终更新生成点位置，格式为逗号分隔的坐标列表的列表。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学基础：** 该问题描述了Lloyd算法的一个加权版本，用于计算质心Voronoi剖分（Centroidal Voronoi Tessellations, CVT）。这是计算几何和科学计算中一个标准且成熟的方法。其在电池设计参数空间中优化采样的应用是工程和材料科学领域中一个现实且相关的用例。\n- **适定性：** 该问题是适定的。目标陈述清晰，更新规则在数学上是明确的，并且为每个测试用例提供了所有必需的参数和初始条件。迭代过程定义了固定的步数，确保了唯一的终止状态。处理空Voronoi单元的规则消除了任何歧义。\n- **客观性：** 该问题使用精确的数学和算法语言表述。所有术语都已定义，要求是客观且可量化的。\n- **完整性与一致性：** 该问题是自洽的。所有必要的数值、函数和约束条件都已提供。内部没有矛盾。\n- **现实性与可行性：** 物理参数（C倍率、温度）在电池研究的现实范围内。计算任务虽然需要仔细实现，但是可行的。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。它是一个基于既定数学原理、定义明确的计算问题。将提供一个解决方案。\n\n### 基于原理的解决方案设计\n\n目标是实现Lloyd算法的离散加权版本，以找到 $k$ 个生成点 $\\{p_i = (c_i, T_i)\\}_{i=1}^k$ 的位置，使它们成为各自在域 $\\Omega$ 内的Voronoi单元的加权质心。区域 $V_i \\subseteq \\Omega$ 相对于权重函数 $w(p)$ 的加权质心 $p_i'$ 的位置由以下积分公式给出：\n$$\np_i' = \\frac{\\int_{V_i} p \\cdot w(p) \\, dA}{\\int_{V_i} w(p) \\, dA}\n$$\n其中 $p = (c, T)$ 表示域中的一个点。\n\n问题指定了对此连续问题的数值近似方法。域 $\\Omega = [c_{\\min}, c_{\\max}] \\times [T_{\\min}, T_{\\max}]$ 被离散化为一个包含 $n_x \\times n_y$ 个节点的均匀笛卡尔网格。设该网格节点集为 $\\mathcal{G} = \\{q_j\\}_{j=1}^{n_x n_y}$，其中每个 $q_j = (c_j, T_j)$ 是 $\\Omega$ 中的一个点。积分被替换为对这些网格节点的求和。\n\n该算法按指定的迭代次数 $N_{\\text{iter}}$ 进行迭代。设 $P^{(m)} = \\{p_i^{(m)}\\}_{i=1}^k$ 是第 $m$ 次迭代时的生成点集合。\n\n**1. 初始化：**\n从初始生成点集 $P^{(0)}$ 开始。将域 $\\Omega$ 离散化为一个网格 $\\mathcal{G}$。网格节点的坐标通过均匀间隔的点生成：\n$$ c_j = c_{\\min} + j \\frac{c_{\\max} - c_{\\min}}{n_x - 1}, \\quad j = 0, \\dots, n_x-1 $$\n$$ T_\\ell = T_{\\min} + \\ell \\frac{T_{\\max} - T_{\\min}}{n_y - 1}, \\quad \\ell = 0, \\dots, n_y-1 $$\n对每个网格节点 $q \\in \\mathcal{G}$ 计算并存储权重函数 $w(q)$ 的值。\n\n**2. 迭代更新：**\n对于每次迭代 $m = 0, 1, \\dots, N_{\\text{iter}}-1$：\n\n**a. 划分步骤（近似Voronoi剖分）：**\n通过将每个网格节点 $q_j \\in \\mathcal{G}$ 分配给当前集合 $P^{(m)}$ 中最近的生成点来近似连续的Voronoi划分。距离度量是标准欧几里得距离。这将网格 $\\mathcal{G}$ 划分为 $k$ 个不相交的子集 $\\mathcal{G}_1^{(m)}, \\mathcal{G}_2^{(m)}, \\dots, \\mathcal{G}_k^{(m)}$，其中：\n$$\n\\mathcal{G}_i^{(m)} = \\{q \\in \\mathcal{G} \\mid \\|q - p_i^{(m)}\\|_2 \\leq \\|q - p_j^{(m)}\\|_2 \\text{ for all } j \\neq i\\}\n$$\n距离相等的情况可以任意处理，例如，将点分配给索引较小的生成点。\n\n**b. 质心更新步骤：**\n对于每个 $i \\in \\{1, \\dots, k\\}$，下一个生成点的位置 $p_i^{(m+1)}$ 计算为其分配的单元 $\\mathcal{G}_i^{(m)}$ 中网格节点的加权质心。连续积分被离散求和所取代：\n$$\np_i^{(m+1)} = \\frac{\\sum_{q \\in \\mathcal{G}_i^{(m)}} q \\cdot w(q)}{\\sum_{q \\in \\mathcal{G}_i^{(m)}} w(q)}\n$$\n该向量方程可以对每个坐标表示为：\n$$\nc_i^{(m+1)} = \\frac{\\sum_{(c_j, T_j) \\in \\mathcal{G}_i^{(m)}} c_j \\cdot w(c_j, T_j)}{\\sum_{(c_j, T_j) \\in \\mathcal{G}_i^{(m)}} w(c_j, T_j)}\n$$\n$$\nT_i^{(m+1)} = \\frac{\\sum_{(c_j, T_j) \\in \\mathcal{G}_i^{(m)}} T_j \\cdot w(c_j, T_j)}{\\sum_{(c_j, T_j) \\in \\mathcal{G}_i^{(m)}} w(c_j, T_j)}\n$$\n根据问题规范，如果一个单元 $\\mathcal{G}_i^{(m)}$ 为空（即不包含任何网格节点），则不更新生成点的位置：$p_i^{(m+1)} = p_i^{(m)}$。如果对空集求和，这种情况会自然处理，但必须显式检查以避免除以零。由于权重函数 $w(c, T)$ 严格为正，分母为零当且仅当集合 $\\mathcal{G}_i^{(m)}$ 为空。\n\n**3. 终止：**\n经过 $N_{\\text{iter}}$ 次迭代后，生成点的最终位置由集合 $P^{(N_{\\text{iter}})}$ 给出。这些是要报告的结果。此过程将为提供的每个测试用例实现。",
            "answer": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef compute_weighted_cvt(domain, weight_params, initial_generators, grid_resolution, n_iter):\n    \"\"\"\n    Computes weighted centroidal Voronoi tessellations using a discrete Lloyd-type algorithm.\n\n    Args:\n        domain (dict): Dictionary with keys 'c_min', 'c_max', 't_min', 't_max'.\n        weight_params (dict): Dictionary with keys 'alpha', 'beta'.\n        initial_generators (list of tuples): Initial positions of the generators.\n        grid_resolution (dict): Dictionary with keys 'nx', 'ny'.\n        n_iter (int): Number of iterations to perform.\n\n    Returns:\n        list of lists: Final positions of the generators.\n    \"\"\"\n    c_min, c_max = domain['c_min'], domain['c_max']\n    t_min, t_max = domain['t_min'], domain['t_max']\n    alpha, beta = weight_params['alpha'], weight_params['beta']\n    nx, ny = grid_resolution['nx'], grid_resolution['ny']\n\n    # Step 1: Create the grid and pre-compute weights\n    c_coords = np.linspace(c_min, c_max, nx)\n    t_coords = np.linspace(t_min, t_max, ny)\n    c_grid, t_grid = np.meshgrid(c_coords, t_coords)\n    grid_points = np.vstack([c_grid.ravel(), t_grid.ravel()]).T\n\n    # Normalize coordinates for weight calculation, handling potential division by zero if domain is a point.\n    c_range = c_max - c_min\n    t_range = t_max - t_min\n    c_norm = (grid_points[:, 0] - c_min) / c_range if c_range > 0 else np.zeros(grid_points.shape[0])\n    t_norm = (grid_points[:, 1] - t_min) / t_range if t_range > 0 else np.zeros(grid_points.shape[0])\n    \n    weights = np.exp(alpha * c_norm + beta * t_norm)\n\n    # Initialize generators\n    generators = np.array(initial_generators, dtype=float)\n    num_generators = generators.shape[0]\n\n    # Step 2: Iterative updates\n    for _ in range(n_iter):\n        # Step 2a: Partition the grid by assigning each grid point to the nearest generator\n        # cdist computes the Euclidean distance between each grid point and each generator.\n        dists_sq = cdist(grid_points, generators, 'sqeuclidean')\n        assignments = np.argmin(dists_sq, axis=1)\n\n        # Step 2b: Update generator positions to the weighted centroid of their cells\n        new_generators = generators.copy()\n        for i in range(num_generators):\n            # Find all grid points assigned to the current generator\n            mask = (assignments == i)\n            \n            # If the cell is empty, do not update the generator position\n            if not np.any(mask):\n                continue\n            \n            points_in_cell = grid_points[mask]\n            weights_in_cell = weights[mask]\n            \n            # Calculate the weighted centroid\n            denominator = np.sum(weights_in_cell)\n            \n            # The numerator is the sum of (point_coordinate * weight)\n            # Use broadcasting to multiply each coordinate of each point by its corresponding weight\n            weighted_coords = points_in_cell * weights_in_cell[:, np.newaxis]\n            \n            # Sum the weighted coordinates and divide by the sum of weights\n            centroid = np.sum(weighted_coords, axis=0) / denominator\n            \n            new_generators[i] = centroid\n        \n        generators = new_generators\n\n    return generators.tolist()\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"domain\": {\"c_min\": 0.0, \"c_max\": 6.0, \"t_min\": 293.0, \"t_max\": 333.0},\n            \"weight_params\": {\"alpha\": 3.0, \"beta\": 2.0},\n            \"initial_generators\": [(1.0, 300.0), (3.0, 320.0), (5.5, 330.0), (4.0, 295.0)],\n            \"grid_resolution\": {\"nx\": 64, \"ny\": 64},\n            \"n_iter\": 2,\n        },\n        {\n            \"domain\": {\"c_min\": 0.0, \"c_max\": 10.0, \"t_min\": 273.0, \"t_max\": 343.0},\n            \"weight_params\": {\"alpha\": 1.0, \"beta\": 1.0},\n            \"initial_generators\": [(0.2, 273.0), (9.8, 343.0), (0.2, 343.0)],\n            \"grid_resolution\": {\"nx\": 60, \"ny\": 60},\n            \"n_iter\": 1,\n        },\n        {\n            \"domain\": {\"c_min\": 0.0, \"c_max\": 8.0, \"t_min\": 298.0, \"t_max\": 358.0},\n            \"weight_params\": {\"alpha\": 8.0, \"beta\": 8.0},\n            \"initial_generators\": [(1.0, 300.0), (2.0, 330.0), (7.5, 356.0)],\n            \"grid_resolution\": {\"nx\": 80, \"ny\": 80},\n            \"n_iter\": 1,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        final_generators = compute_weighted_cvt(\n            case[\"domain\"],\n            case[\"weight_params\"],\n            case[\"initial_generators\"],\n            case[\"grid_resolution\"],\n            case[\"n_iter\"]\n        )\n        # Format list to string without spaces for compact output\n        result_str = str(final_generators).replace(\" \", \"\")\n        results.append(result_str)\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}