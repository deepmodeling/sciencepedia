{
    "hands_on_practices": [
        {
            "introduction": "在我们能够构建优秀的采样设计之前，我们必须能够量化其“优良”程度。此练习旨在通过实现三个核心的几何度量来建立这项基本技能：填充距离（$h_X$）、分离距离（$q_X$）和网格比（$\\rho_X$）。这些度量共同评估了样本点在设计空间中的覆盖范围、聚类程度以及整体均匀性，为客观评价任何采样策略的有效性提供了基础。",
            "id": "3951685",
            "problem": "考虑一个用于自动化电池设计与仿真的三参数归一化设计空间，该空间定义为单位立方体 $[0,1]^3$。其中的参数分别为电极孔隙率 $\\phi$、电解质盐浓度 $c$ 和隔膜厚度 $\\delta$，每个参数都经过归一化处理，取值范围在 $[0,1]$ 内。设 $X = \\{x_i\\}_{i=1}^N \\subset [0,1]^3$ 是一个有限样本集，用于训练一个高保真电化学模拟器的代理模型。在 $\\mathbb{R}^3$ 的标准欧几里得度量下，$X$ 的空间填充质量可以通过填充距离 $h_X$、分离距离 $q_X$ 以及网格比 $\\rho_X = h_X/q_X$ 来表征。填充距离 $h_X$ 是定义域中任意点到其最近的 $X$ 中样本点的最坏情况距离；分离距离 $q_X$ 是 $X$ 中不同样本点之间最小欧几里得距离的一半；网格比 $\\rho_X$ 是这两个量的比值。\n\n您必须为几个指定的样本集计算 $h_X$、$q_X$ 和 $\\rho_X$。为此，您需要通过在 $[0,1]^3$ 上使用均匀笛卡尔网格搜索来近似计算 $h_X$。该网格在每个轴向上具有预设的分辨率，即 $n_g$ 个点（包括端点），用于评估网格点上的最近样本距离。使用欧几里得范数来测量距离。距离应以归一化立方体边长为单位表示（无量纲）。角度单位不适用。输出必须四舍五入到 $6$ 位小数。\n\n对于每个测试用例，程序的输入是固定的并嵌入在程序中：样本集 $X$ 和网格分辨率 $n_g$。您的程序应为每个测试用例计算一个三元组 $[h_X,q_X,\\rho_X]$，并将所有测试用例的结果汇总到单行输出中，其格式需严格遵循下文的描述。\n\n请使用以下测试套件（每个用例提供一个特定的 $X$ 和 $n_g$）：\n\n- 用例 A（多样化设计，类似于拉丁超立方采样 (LHS)）：$N = 10$，$n_g = 25$，其中\n  $$\n  X_A = \\Big\\{\n  (0.05,0.62,0.11),\\,\n  (0.18,0.86,0.73),\\,\n  (0.29,0.19,0.44),\\,\n  (0.41,0.48,0.95),\\,\n  (0.52,0.03,0.29),\\,\n  (0.63,0.77,0.05),\\,\n  (0.74,0.34,0.58),\\,\n  (0.80,0.10,0.88),\\,\n  (0.92,0.56,0.21),\\,\n  (0.15,0.72,0.37)\n  \\Big\\}.\n  $$\n\n- 用例 B（聚集在一个角附近，说明覆盖性差）：$N = 10$，$n_g = 25$，其中\n  $$\n  X_B = \\Big\\{\n  (0.02,0.01,0.03),\\,\n  (0.05,0.04,0.02),\\,\n  (0.08,0.06,0.05),\\,\n  (0.10,0.02,0.08),\\,\n  (0.07,0.09,0.04),\\,\n  (0.12,0.11,0.07),\\,\n  (0.15,0.14,0.06),\\,\n  (0.18,0.16,0.10),\\,\n  (0.20,0.19,0.12),\\,\n  (0.22,0.18,0.15)\n  \\Big\\}.\n  $$\n\n- 用例 C（结构化内部网格，$3\\times 3\\times 3$）：$N = 27$，$n_g = 30$，其中\n  $$\n  X_C = \\{(x,y,z) \\mid x \\in \\{1/6,\\, 1/2,\\, 5/6\\},\\; y \\in \\{1/6,\\, 1/2,\\, 5/6\\},\\; z \\in \\{1/6,\\, 1/2,\\, 5/6\\}\\}.\n  $$\n\n- 用例 D（仅立方体顶点）：$N = 8$，$n_g = 30$，其中\n  $$\n  X_D = \\{(x,y,z) \\mid x \\in \\{0,\\,1\\},\\; y \\in \\{0,\\,1\\},\\; z \\in \\{0,\\,1\\}\\}.\n  $$\n\n科学真实性要求：您必须使用 $\\mathbb{R}^3$ 中的欧几里得距离；通过在 $[0,1]^3$ 上一个每轴分辨率为 $n_g$ 的均匀笛卡尔网格（包括端点）的每个点上评估最近样本距离来近似 $h_X$；通过样本点对距离精确计算 $q_X$，其值为不同样本之间最小距离的一半；然后计算 $\\rho_X = h_X/q_X$。不允许进行其他简化。\n\n覆盖性设计：该测试套件探讨了一种通用的“理想”情况（用例 A）、一种严重聚类的边缘情况（用例 B）、一种结构化准均匀内部网格（用例 C）和一种仅边界情况（用例 D）。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个用例的结果，形式为一个逗号分隔的列表。每个用例的结果本身是一个三元组，由三个四舍五入到 $6$ 位小数的浮点数组成，用逗号分隔，不含空格，并用方括号括起来。例如，您的输出必须类似于\n$$\n[\\,[h_A,q_A,\\rho_A],\\,[h_B,q_B,\\rho_B],\\,[h_C,q_C,\\rho_C],\\,[h_D,q_D,\\rho_D]\\,]\n$$\n但以纯文本形式打印，不带多余空格，并使用十进制浮点数。$h_X$、$q_X$ 和 $\\rho_X$ 的值均为无量纲。",
            "solution": "该问题要求计算用于表征三维单位立方体 $[0,1]^3$ 内样本集 $X = \\{x_i\\}_{i=1}^N$ 空间填充特性的三个标准度量。这些度量分别是填充距离 $h_X$、分离距离 $q_X$ 和网格比 $\\rho_X$。需要对四个不同的样本集 $X_A, X_B, X_C$ 和 $X_D$ 进行计算。其基础空间为 $\\mathbb{R}^3$，配备标准欧几里得范数 $\\|v\\|_2 = \\sqrt{v_1^2 + v_2^2 + v_3^2}$。\n\n对于每个测试用例，求解方法分三个连续步骤实现：计算分离距离 $q_X$，近似计算填充距离 $h_X$，最后计算网格比 $\\rho_X$。\n\n### 1. 分离距离 $q_X$ 的计算\n\n分离距离 $q_X$ 量化了样本集 $X$ 中点之间的最小间距。其形式化定义为集合中任意两个不同点之间最小欧几里得距离的一半：\n$$\nq_X = \\frac{1}{2} \\min_{i \\neq j} \\|x_i - x_j\\|_2\n$$\n较大的 $q_X$ 意味着样本点分离良好，避免了聚类。\n\n**算法方法**：\n为了计算 $q_X$，我们必须计算集合 $X$ 中所有满足 $i \\neq j$ 的唯一对点 $(x_i, x_j)$ 之间的欧几里得距离。对于一个包含 $N$ 个点的集合，这样的点对总数为 $\\binom{N}{2} = N(N-1)/2$。计算完所有这些点对距离后，找到其中的最小值 $d_{min} = \\min_{i \\neq j} \\|x_i - x_j\\|_2$。分离距离即为 $q_X = d_{min} / 2$。此计算可以使用向量化库函数（例如 `scipy.spatial.distance.pdist`）高效执行，该函数能计算给定集合中所有点的点对距离。\n\n### 2. 填充距离 $h_X$ 的近似计算\n\n填充距离 $h_X$（也称为离散度）测量采样中的最大“间隙”。其定义为定义域 $[0,1]^3$ 中任意点到其最近的 $X$ 中样本点的最大可能距离：\n$$\nh_X = \\sup_{p \\in [0,1]^3} \\left( \\min_{x_i \\in X} \\|p - x_i\\|_2 \\right)\n$$\n较小的 $h_X$ 表示设计空间的覆盖性更好，因为定义域中没有点离样本点太远。\n\n**算法方法**：\n精确计算 $h_X$ 的值是一个计算上很困难的全局优化问题。本问题指定了一种基于在均匀笛卡尔网格上进行离散搜索的近似方法。\n在定义域 $[0,1]^3$ 内构建一个网格 $G$，其每个轴的分辨率为 $n_g$ 个点（包括端点）。每个轴的坐标由集合 $\\{0, 1/(n_g-1), 2/(n_g-1), \\ldots, 1\\}$ 给出。完整网格 $G$ 是这些坐标集的笛卡尔积，总共包含 $n_g^3$ 个网格点。\n\n然后，近似填充距离（我们仍用 $h_X$ 表示）是在每个网格点 $g_k \\in G$ 上评估的最近样本距离中的最大值：\n$$\nh_X \\approx \\max_{g_k \\in G} \\left( \\min_{x_i \\in X} \\|g_k - x_i\\|_2 \\right)\n$$\n该过程包括以下步骤：\n1.  生成所有 $n_g^3$ 个网格点 $G$ 的集合。\n2.  对于每个网格点 $g_k \\in G$，计算其到每个样本点 $x_i \\in X$ 的距离。\n3.  对于每个 $g_k$，找到这些距离的最小值，即其到 $X$ 中最近邻的距离。\n4.  填充距离 $h_X$ 是所有这些最小距离中的最大值。\n\n此计算可以被有效地向量化。例如，`scipy.spatial.distance.cdist` 可以计算所有网格点和所有样本点之间的距离矩阵。随后沿该矩阵的适当轴执行 `min` 和 `max` 操作，即可得出 $h_X$ 的最终值。\n\n### 3. 网格比 $\\rho_X$ 的计算\n\n网格比 $\\rho_X$ 是一个无量纲量，它结合了填充距离和分离距离，为样本质量提供了一个单一的度量。其定义为：\n$$\n\\rho_X = \\frac{h_X}{q_X}\n$$\n一个理想的点集其网格比应接近 $1$，这对应于最大空球半径 ($h_X$) 等于样本点周围最小影响球半径 ($q_X$) 的情况。较大的 $\\rho_X$ 值可能表示覆盖性差（$h_X$ 大）或显著聚类（$q_X$ 小）。\n\n**算法方法**：\n一旦按上述方法计算出 $h_X$ 和 $q_X$ 的值，通过将它们直接相除即可得到 $\\rho_X$。如果 $q_X$ 为零（当样本集中存在重复点时会发生这种情况），则网格比无定义。然而，所提供的测试用例均由不同的点组成，因此 $q_X > 0$。\n\n通过将此三步法应用于四个指定的测试用例中的每一个，我们系统地推导出所需的度量。然后将结果四舍五入到 $6$ 位小数，并按指定格式进行格式化。",
            "answer": "```python\nimport numpy as np\nfrom scipy.spatial.distance import pdist, cdist\n\ndef solve():\n    \"\"\"\n    Computes space-filling metrics (h_X, q_X, rho_X) for four test cases\n    of sample sets in a 3D unit cube.\n    \"\"\"\n\n    def compute_metrics(X, n_g):\n        \"\"\"\n        Calculates separation distance, fill distance, and mesh ratio.\n\n        Args:\n            X (np.ndarray): A set of N sample points, shape (N, 3).\n            n_g (int): The number of grid points per axis for h_X approximation.\n\n        Returns:\n            tuple: A tuple containing (h_X, q_X, rho_X).\n        \"\"\"\n        # Ensure X is a NumPy array\n        X = np.array(X)\n        N = X.shape[0]\n\n        # 1. Compute Separation Distance (q_X)\n        # q_X is half the minimum Euclidean distance between distinct samples.\n        if N > 1:\n            # pdist computes pairwise distances between all points in X.\n            pairwise_distances = pdist(X, 'euclidean')\n            min_dist = np.min(pairwise_distances)\n            q_X = 0.5 * min_dist\n        else:\n            # Undefined for a single point, but we can set it to infinity\n            # to indicate no \"separation\" constraint.\n            # Handle as per problem context if it arises. For these tests N > 1.\n            q_X = np.inf\n\n        # 2. Approximate Fill Distance (h_X)\n        # h_X is the max distance from any point in the domain to its nearest sample.\n        # We approximate this by searching over a uniform grid.\n        \n        # Create grid points\n        axis_coords = np.linspace(0, 1, n_g)\n        grid_points = np.stack(np.meshgrid(axis_coords, axis_coords, axis_coords), axis=-1).reshape(-1, 3)\n\n        # Compute distances from each grid point to each sample point.\n        # cdist(A, B) creates a matrix where entry (i,j) is the distance from A[i] to B[j].\n        # Shape: (n_g**3, N)\n        dist_matrix = cdist(grid_points, X, 'euclidean')\n\n        # For each grid point, find the minimum distance to any sample point.\n        # Shape: (n_g**3,)\n        min_dists_from_grid = np.min(dist_matrix, axis=1)\n\n        # The fill distance h_X is the maximum of these minimum distances.\n        h_X = np.max(min_dists_from_grid)\n\n        # 3. Compute Mesh Ratio (rho_X)\n        if q_X > 0:\n            rho_X = h_X / q_X\n        else:\n            # This case (duplicate points) does not occur in the test suite.\n            rho_X = np.inf\n            \n        return h_X, q_X, rho_X\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Diverse design\n        {\n            \"name\": \"A\",\n            \"n_g\": 25,\n            \"X\": [\n                (0.05, 0.62, 0.11), (0.18, 0.86, 0.73), (0.29, 0.19, 0.44),\n                (0.41, 0.48, 0.95), (0.52, 0.03, 0.29), (0.63, 0.77, 0.05),\n                (0.74, 0.34, 0.58), (0.80, 0.10, 0.88), (0.92, 0.56, 0.21),\n                (0.15, 0.72, 0.37)\n            ]\n        },\n        # Case B: Clustered design\n        {\n            \"name\": \"B\",\n            \"n_g\": 25,\n            \"X\": [\n                (0.02, 0.01, 0.03), (0.05, 0.04, 0.02), (0.08, 0.06, 0.05),\n                (0.10, 0.02, 0.08), (0.07, 0.09, 0.04), (0.12, 0.11, 0.07),\n                (0.15, 0.14, 0.06), (0.18, 0.16, 0.10), (0.20, 0.19, 0.12),\n                (0.22, 0.18, 0.15)\n            ]\n        },\n        # Case C: Structured interior grid\n        {\n            \"name\": \"C\",\n            \"n_g\": 30,\n            \"X\": [(x, y, z) for x in [1/6, 1/2, 5/6] \n                              for y in [1/6, 1/2, 5/6]\n                              for z in [1/6, 1/2, 5/6]]\n        },\n        # Case D: Cube corners\n        {\n            \"name\": \"D\",\n            \"n_g\": 30,\n            \"X\": [(x, y, z) for x in [0, 1] for y in [0, 1] for z in [0, 1]]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        h, q, rho = compute_metrics(case[\"X\"], case[\"n_g\"])\n        results.append([round(val, 6) for val in [h, q, rho]])\n\n    # Format the output string as per the requirement:\n    # [[h_A,q_A,rho_A],[h_B,q_B,rho_B],...] with 6 decimal places.\n    formatted_cases = []\n    for case_result in results:\n        # Format each number to 6 decimal places.\n        formatted_nums = [f\"{num:.6f}\" for num in case_result]\n        formatted_cases.append(f\"[{','.join(formatted_nums)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_cases)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了评估方法后，下一步自然是学习如何生成高质量的设计。本练习将介绍一种强大且直观的序列采样方法——贪心最远点算法，它通过迭代地将新样本点放置在距离现有样本集最远的位置来逐步优化空间覆盖。通过在电池设计中常见的加权参数空间中实现此算法，您将学习如何从零开始构建一个能兼顾不同参数敏感性的高效实验设计。",
            "id": "3951689",
            "problem": "考虑一个用于锂离子电池设计的参数域，表示为一个超矩形 $\\Omega \\subset \\mathbb{R}^d$，其坐标轴对应于具有物理意义的参数。为构建适用于自动化电池模拟的空间填充设计，请在一个加权度量空间中实现一个贪心最远点采样策略。其中，权重编码了特定维度的特征尺度，以使度量无量纲化并反映参数敏感度。令 $X_k = \\{x_1, \\dots, x_k\\} \\subset \\Omega$ 表示当前的设计集，并令 $C \\subset \\Omega$ 为一个在网格上采样的有限候选集。定义一个对角正定权重矩阵 $W = \\mathrm{diag}(w_1, \\dots, w_d)$，其中 $w_i = 1/s_i^2$，$s_i > 0$ 是第 $i$ 个参数的特征尺度。$x, y \\in \\Omega$ 之间的加权距离定义为\n$$\nd_W(x, y) = \\sqrt{(x - y)^\\top W (x - y)} = \\sqrt{\\sum_{i=1}^d w_i (x_i - y_i)^2},\n$$\n当 $s_i$ 的选择与第 $i$ 个坐标的单位相匹配时，该距离是无量纲的。\n\n对于一个有限集 $X \\subset \\Omega$，定义分离距离\n$$\nq_X = \\min_{\\substack{x, y \\in X\\\\ x \\neq y}} d_W(x, y),\n$$\n以及关于候选集 $C$ 的填充距离\n$$\nh_X = \\max_{z \\in C} \\min_{x \\in X} d_W(z, x).\n$$\n约定当 $\\lvert X \\rvert = 1$ 时，$q_X = 0$。贪心最远点算法通过选择\n$$\nx_{k+1} = \\arg\\max_{z \\in C \\setminus X_k} \\left( \\min_{x \\in X_k} d_W(z, x) \\right),\n$$\n来迭代地增广 $X_k$。算法从一个初始点开始，该初始点被选为在 $d_W$ 度量下离 $\\Omega$ 中心最近的候选点。每次添加点后，计算 $q_{X_k}$ 和 $h_{X_k}$。所有距离都是无量纲的，并且必须以四舍五入到六位小数的浮点数形式报告。\n\n您必须实现一个完整的程序，该程序：\n- 根据每个轴上指定的分辨率，在 $\\Omega$ 上构建一个完整网格作为候选集 $C$。\n- 通过选择（在 $d_W$ 度量下）离 $\\Omega$ 中心最近的候选点来初始化 $X_1$。\n- 应用贪心最远点规则选择 $K$ 个点，并在每次添加后，在候选集 $C$ 上计算 $q_{X_k}$ 和 $h_{X_k}$。\n\n使用以下测试套件，它涵盖了电池参数域中的典型和边缘行为：\n\n测试用例 A（正常路径，三维，中等各向异性）：\n- 维度 $d = 3$，参数包括：电极厚度 $t$（单位：米），孔隙率 $\\varepsilon$（无量纲），以及电解质电导率 $\\kappa$（单位：西门子/米）。\n- 边界 $\\Omega = [60 \\times 10^{-6}, 120 \\times 10^{-6}] \\times [0.25, 0.45] \\times [0.8, 2.0]$。\n- 特征尺度 $s = [30 \\times 10^{-6}, 0.10, 0.60]$，因此 $W = \\mathrm{diag}(1/s_i^2)$。\n- 候选网格分辨率 $\\text{res} = [7, 5, 6]$。\n- 点的数量 $K = 6$。\n\n测试用例 B（边界行为，二维，强各向异性）：\n- 维度 $d = 2$，参数包括：固相扩散系数 $D_s$（单位：平方米/秒），以及交换电流密度 $i_0$（单位：安培/平方米）。\n- 边界 $\\Omega = [1 \\times 10^{-14}, 5 \\times 10^{-14}] \\times [0.5, 2.5]$。\n- 特征尺度 $s = [0.5 \\times 10^{-14}, 1.0]$，因此 $W = \\mathrm{diag}(1/s_i^2)$。\n- 候选网格分辨率 $\\text{res} = [8, 9]$。\n- 点的数量 $K = 5$。\n\n测试用例 C（边缘情况，一维，候选点耗尽）：\n- 维度 $d = 1$，参数为：隔膜厚度 $\\delta$（单位：米）。\n- 边界 $\\Omega = [10 \\times 10^{-6}, 12 \\times 10^{-6}]$。\n- 特征尺度 $s = [1 \\times 10^{-6}]$，因此 $W = \\mathrm{diag}(1/s_i^2)$。\n- 候选网格分辨率 $\\text{res} = [5]$。\n- 点的数量 $K = 5$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果是一个由 $[q_{X_k}, h_{X_k}]$ 对（$k = 1, \\dots, K$）组成的列表。例如，输出必须是以下形式\n$[ \\text{caseA}, \\text{caseB}, \\text{caseC} ]$\n其中每个 $\\text{caseX}$ 等于一个由浮点数列表组成的列表，浮点数需四舍五入到六位小数。所有距离都是无量纲的，并且必须以四舍五入到六位小数的浮点数形式报告。角度单位不适用。百分比不适用。",
            "solution": "问题陈述是有效的。它在用于计算模拟的实验设计（DoE）领域有其科学依据，在数学上是适定的、客观的，并为实现提供了完整且一致的定义和数据集。该问题要求实现一个贪心最远点采样算法，以在指定的超矩形参数域 $\\Omega \\subset \\mathbb{R}^d$ 内生成一个空间填充设计。解决方案涉及多个集成步骤，基于加权度量空间和迭代优化的原理。\n\n首先，我们建立几何设定。参数域 $\\Omega$ 由其 $d$ 个维度各自的上下界定义。从中选择设计点的候选点集 $C$ 在 $\\Omega$ 上形成一个离散网格。该网格是通过对每个轴上具有指定分辨率的一维线性间隔点集进行笛卡尔积而构建的。第 $i$ 维网格中的点数为 $\\text{res}_i$。\n\n一个关键概念是加权距离 $d_W(x, y)$，定义为：\n$$\nd_W(x, y) = \\sqrt{(x - y)^\\top W (x - y)} = \\sqrt{\\sum_{i=1}^d w_i (x_i - y_i)^2}\n$$\n权重矩阵 $W$ 是对角的，其元素为 $w_i = 1/s_i^2$，其中 $s_i$ 是第 $i$ 个参数的特征尺度。该度量有两个目的：它通过用每个坐标差 $(x_i - y_i)$ 除以其尺度 $s_i$ 来进行归一化，从而使距离无量纲化；它还允许编码不同参数间的不同敏感度或重要性。所有后续的几何计算都在这个加权空间中进行。\n\n算法按以下步骤进行：\n\n1.  **初始化**：设计集用单个点 $X_1 = \\{x_1\\}$ 进行初始化。点 $x_1$ 从候选集 $C$ 中选出，它是在加权距离 $d_W$ 下离域 $\\Omega$ 几何中心最近的点。$\\Omega = \\prod_{i=1}^d [l_i, u_i]$ 的中心 $c$ 是坐标为 $c_i = (l_i + u_i)/2$ 的点。因此，$x_1 = \\arg\\min_{z \\in C} d_W(z, c)$。\n\n2.  **迭代选择**：对于 $k = 1, \\dots, K-1$，通过添加离现有集合 $X_k$ 最远的候选点，将设计集 $X_k$ 增广为 $X_{k+1}$。这就是贪心最远点或极小化极大选择规则：\n    $$\n    x_{k+1} = \\arg\\max_{z \\in C \\setminus X_k} \\left( \\min_{x \\in X_k} d_W(z, x) \\right)\n    $$\n    该规则根据候选集上的填充距离，迭代地将新点放置在域中采样最稀疏的区域。为了高效地实现这一点，我们维护一个数组，记录每个候选点 $z \\in C$ 到当前设计集 $X_k$ 的最小距离。当添加一个新点 $x_{k+1}$ 时，通过取旧距离与到新点 $x_{k+1}$ 的距离的逐元素最小值来更新此数组。下一个要添加的点就是这个更新后的最小距离数组中最大值所对应的候选点。\n\n3.  **度量计算**：每添加一个点 $x_k$（对于 $k=1, \\dots, K$），都会计算集合 $X_k$ 的两个质量度量。\n    *   **分离距离 ($q_{X_k}$)**：此度量衡量设计集中点之间的最小成对距离。其定义为：\n        $$\n        q_{X_k} = \\min_{\\substack{x, y \\in X_k \\\\ x \\neq y}} d_W(x, y)\n        $$\n        按照约定，对于单元素集 $X_1$，$q_{X_1}$ 设为 $0$。对于 $k > 1$，这需要计算 $X_k$ 内所有 $\\binom{k}{2}$ 个成对距离并找到最小值。\n    *   **填充距离 ($h_{X_k}$)**：此度量衡量设计集对候选集 $C$ 的覆盖程度。它被定义为任何候选点到其在设计集中的最近邻的最大距离：\n        $$\n        h_{X_k} = \\max_{z \\in C} \\min_{x \\in X} d_W(z, x)\n        $$\n        如选择步骤中所述，值 $h_{X_k}$ 正是用于选择后续点 $x_{k+2}$ 的最小距离数组的最大值。\n\n对提供的三个测试用例中的每一个都重复此过程。对于每个用例，我们生成一个由 $[q_{X_k}, h_{X_k}]$ 对（$k=1, \\dots, K$）组成的列表。所有距离值都按要求四舍五入到六位小数。该实现依赖于 `numpy` 来进行高效的向量化距离计算以及管理候选集和设计集。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"d\": 3,\n            \"bounds\": np.array([[60e-6, 120e-6], [0.25, 0.45], [0.8, 2.0]]),\n            \"scales\": np.array([30e-6, 0.10, 0.60]),\n            \"resolutions\": [7, 5, 6],\n            \"K\": 6,\n        },\n        {\n            \"name\": \"Case B\",\n            \"d\": 2,\n            \"bounds\": np.array([[1e-14, 5e-14], [0.5, 2.5]]),\n            \"scales\": np.array([0.5e-14, 1.0]),\n            \"resolutions\": [8, 9],\n            \"K\": 5,\n        },\n        {\n            \"name\": \"Case C\",\n            \"d\": 1,\n            \"bounds\": np.array([[10e-6, 12e-6]]),\n            \"scales\": np.array([1e-6]),\n            \"resolutions\": [5],\n            \"K\": 5,\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = run_case(case[\"bounds\"], case[\"scales\"], case[\"resolutions\"], case[\"K\"])\n        all_results.append(result)\n\n    # The problem description's textual example `[ caseA, caseB, caseC ]` suggests\n    # standard Python list string representation, which includes spaces.\n    # The provided print template `print(f\"[{','.join(map(str, results))}]\")`\n    # would produce no spaces between cases, contradicting the visual example.\n    # Therefore, we use the standard string representation of the list.\n    print(str(all_results))\n\n\ndef run_case(bounds, scales, resolutions, K):\n    \"\"\"\n    Executes the greedy farthest-point sampling for a single test case.\n    \"\"\"\n    # 1. Setup: Weights and Candidate Set\n    weights = 1.0 / (scales**2)\n    grid_axes = [np.linspace(b[0], b[1], r) for b, r in zip(bounds, resolutions)]\n    mesh = np.meshgrid(*grid_axes, indexing='ij')\n    candidates = np.vstack([m.ravel() for m in mesh]).T\n    \n    # 2. Initialization: Find starting point x_1\n    center = np.mean(bounds, axis=1)\n    \n    # helper for weighted distance from one point p1 to many points p2\n    def weighted_dist(p1, p2_array):\n        diff = p2_array - p1\n        return np.sqrt(np.sum(weights * diff**2, axis=1))\n\n    dists_to_center = weighted_dist(center, candidates)\n    initial_idx = np.argmin(dists_to_center)\n    \n    X_indices = {initial_idx}\n    X_points = [candidates[initial_idx]]\n    \n    case_results = []\n\n    # 3. Iteratively select points and compute metrics\n    min_dists_to_X = weighted_dist(X_points[0], candidates)\n\n    for k in range(1, K + 1):\n        # Metrics for the current set X_k\n        \n        # Calculate q_Xk (Separation Distance)\n        if k == 1:\n            q_k = 0.0\n        else:\n            current_X_array = np.array(X_points)\n            pairwise_dists = []\n            for i in range(k):\n                for j in range(i + 1, k):\n                    diff = current_X_array[i] - current_X_array[j]\n                    dist = np.sqrt(np.sum(weights * diff**2))\n                    pairwise_dists.append(dist)\n            q_k = np.min(pairwise_dists)\n            \n        # Calculate h_Xk (Fill Distance)\n        # h_k is the max of the current minimum distances to X_k\n        h_k = np.max(min_dists_to_X)\n        \n        case_results.append([round(q_k, 6), round(h_k, 6)])\n        \n        # If we have collected K points, we stop.\n        if k == K:\n            break\n            \n        # Select next point (x_{k+1})\n        # The next point is the candidate farthest from the current set X_k.\n        # To strictly implement C \\ X_k, we mask already selected points.\n        temp_min_dists = np.copy(min_dists_to_X)\n        temp_min_dists[list(X_indices)] = -1.0 # Ensure selected points are not chosen again\n        next_idx = np.argmax(temp_min_dists)\n        \n        next_point = candidates[next_idx]\n        X_indices.add(next_idx)\n        X_points.append(next_point)\n        \n        # Update minimum distances for the new set X_{k+1}\n        dists_to_new_point = weighted_dist(next_point, candidates)\n        min_dists_to_X = np.minimum(min_dists_to_X, dists_to_new_point)\n        \n    return case_results\n\nsolve()\n```"
        },
        {
            "introduction": "在序列生成方法的基础上，我们可以采用更复杂的迭代优化技术来创建自适应设计。本练习将引导您实现加权质心沃罗诺伊划分（Centroidal Voronoi Tessellation, CVT）的Lloyd算法，这是一种能够使样本点收敛到其自身沃罗诺伊单元质心的强大方法。通过引入权重函数，该练习展示了如何生成能够将计算资源集中在高性能区域（例如高倍率和高温区域）的自适应样本集，这对于高效的虚拟筛选和优化至关重要。",
            "id": "3951723",
            "problem": "考虑一个用于自动化电池设计和模拟的二维参数域，其中每个点都是代表充电速率和温度的一对参数。设充电速率用 $c$ 表示，单位为 C-rate (C)；温度用 $T$ 表示，单位为开尔文 (K)。将该域定义为一个闭合矩形 $\\Omega = [c_{\\min}, c_{\\max}] \\times [T_{\\min}, T_{\\max}] \\subset \\mathbb{R}^2$。一种基于质心 Voronoi 剖分（centroidal Voronoi tessellations）的空间填充采样策略将被调整，以强调高充电速率和高温区域。具体来说，定义一个正权重函数 $w(c, T)$，该函数随 $c$ 和 $T$ 的增加而增加，其公式如下：\n$$\nw(c, T) = \\exp\\left(\\alpha \\cdot \\frac{c - c_{\\min}}{c_{\\max} - c_{\\min}} + \\beta \\cdot \\frac{T - T_{\\min}}{T_{\\max} - T_{\\min}}\\right),\n$$\n其中 $\\alpha > 0$ 和 $\\beta > 0$ 是给定的常数。\n\n从一个有限的生成点集合 $\\{(c_i, T_i)\\}_{i=1}^k \\subset \\Omega$ 开始，在标准欧几里得度量下定义 $\\Omega$ 的 Voronoi 剖分，其中每个 Voronoi 单元对应于 $\\Omega$ 中距离某个生成点比其他任何生成点都近的点的子集。目标是使用从第一性原理推导出的算法过程，通过将每个生成点移动到其 Voronoi 单元在权重函数 $w(c, T)$ 下的加权质心来计算更新后的生成点位置。最终更新的位置必须以与域相同的物理单位表示，即充电速率单位为 C，温度单位为 K。\n\n为了使计算在数值上易于处理且具有通用可实现性，需要在 $\\Omega$ 上使用一个分辨率为 $n_x \\times n_y$ 的笛卡尔网格，通过均匀矩形积分来近似所需的积分。将每个网格节点 $(c_j, T_\\ell)$ 视为一个采样点；将每个采样点分配给最近的生成点（按欧几里得距离）以近似 Voronoi 剖分；然后使用离散加权和来近似每个单元的加权质心。对于任何空的 Voronoi 单元（即没有分配网格节点），在该次迭代中保持其生成点不变。\n\n实现一个具有指定迭代次数 $N_{\\text{iter}} \\in \\mathbb{N}$ 的迭代更新（Lloyd 型迭代），在每次迭代中应用加权质心更新。\n\n您的程序必须为以下每个测试用例计算指定迭代次数后的最终生成点位置。对于每个测试用例，输出必须是生成点位置的列表，格式为 $[[c_1, T_1], [c_2, T_2], \\dots, [c_k, T_k]]$，其中每个 $c_i$ 的单位为 C，每个 $T_i$ 的单位为 K。程序必须生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表。\n\n测试套件：\n- 测试用例 1（一般情况）：\n  - 域：$c \\in [0, 6]$ C, $T \\in [293, 333]$ K，因此 $c_{\\min} = 0$, $c_{\\max} = 6$, $T_{\\min} = 293$, $T_{\\max} = 333$。\n  - 权重参数：$\\alpha = 3$, $\\beta = 2$。\n  - 初始生成点：$[(1.0, 300.0), (3.0, 320.0), (5.5, 330.0), (4.0, 295.0)]$。\n  - 网格分辨率：$n_x = 64$, $n_y = 64$。\n  - 迭代次数：$N_{\\text{iter}} = 2$。\n\n- 测试用例 2（边界压力情况）：\n  - 域：$c \\in [0, 10]$ C, $T \\in [273, 343]$ K，因此 $c_{\\min} = 0$, $c_{\\max} = 10$, $T_{\\min} = 273$, $T_{\\max} = 343$。\n  - 权重参数：$\\alpha = 1$, $\\beta = 1$。\n  - 初始生成点：$[(0.2, 273.0), (9.8, 343.0), (0.2, 343.0)]$。\n  - 网格分辨率：$n_x = 60$, $n_y = 60$。\n  - 迭代次数：$N_{\\text{iter}} = 1$。\n\n- 测试用例 3（极端集中情况）：\n  - 域：$c \\in [0, 8]$ C, $T \\in [298, 358]$ K，因此 $c_{\\min} = 0$, $c_{\\max} = 8$, $T_{\\min} = 298$, $T_{\\max} = 358$。\n  - 权重参数：$\\alpha = 8$, $\\beta = 8$。\n  - 初始生成点：$[(1.0, 300.0), (2.0, 330.0), (7.5, 356.0)]$。\n  - 网格分辨率：$n_x = 80$, $n_y = 80$。\n  - 迭代次数：$N_{\\text{iter}} = 1$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，格式完全如下\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3],\n$$\n其中每个 $\\text{result}_i$ 是第 i 个测试用例更新后的生成点坐标列表，表示为 $[[c_1, T_1], [c_2, T_2], \\dots]$，其中 $c$ 的单位是 C，$T$ 的单位是 K，不带单位符号。不应打印任何额外文本。",
            "solution": "在进行求解之前，需要对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **域：** 一个二维矩形域 $\\Omega = [c_{\\min}, c_{\\max}] \\times [T_{\\min}, T_{\\max}] \\subset \\mathbb{R}^2$。\n- **参数：** 充电速率 $c$ (C-rate, C) 和温度 $T$ (开尔文, K)。\n- **权重函数：** $w(c, T) = \\exp\\left(\\alpha \\cdot \\frac{c - c_{\\min}}{c_{\\max} - c_{\\min}} + \\beta \\cdot \\frac{T - T_{\\min}}{T_{\\max} - T_{\\min}}\\right)$，其中 $\\alpha > 0$ 且 $\\beta > 0$。\n- **生成点：** 一个有限的点集 $\\{(c_i, T_i)\\}_{i=1}^k \\subset \\Omega$。\n- **剖分：** 基于标准欧几里得度量的 Voronoi 剖分。\n- **目标：** 将每个生成点更新为其 Voronoi 单元的加权质心。\n- **数值近似：**\n    - 使用一个分辨率为 $n_x \\times n_y$ 的笛卡尔网格。\n    - 将网格节点分配给最近的生成点以近似 Voronoi 单元。\n    - 质心的积分通过离散加权和来近似。\n- **空单元处理：** 如果一个生成点的近似 Voronoi 单元不包含任何网格节点，则其位置在该次迭代中保持不变。\n- **算法：** 执行 $N_{\\text{iter}}$ 次迭代更新（Lloyd 型）。\n- **测试用例：**\n    1.  **用例 1：** $c \\in [0, 6]$, $T \\in [293, 333]$。 $\\alpha = 3$, $\\beta = 2$。初始生成点：$[(1.0, 300.0), (3.0, 320.0), (5.5, 330.0), (4.0, 295.0)]$。网格：$n_x = 64$, $n_y = 64$。迭代次数：$N_{\\text{iter}} = 2$。\n    2.  **用例 2：** $c \\in [0, 10]$, $T \\in [273, 343]$。 $\\alpha = 1$, $\\beta = 1$。初始生成点：$[(0.2, 273.0), (9.8, 343.0), (0.2, 343.0)]$。网格：$n_x = 60$, $n_y = 60$。迭代次数：$N_{\\text{iter}} = 1$。\n    3.  **用例 3：** $c \\in [0, 8]$, $T \\in [298, 358]$。 $\\alpha = 8$, $\\beta = 8$。初始生成点：$[(1.0, 300.0), (2.0, 330.0), (7.5, 356.0)]$。网格：$n_x = 80$, $n_y = 80$。迭代次数：$N_{\\text{iter}} = 1$。\n- **输出：** 每个测试用例的最终更新生成点位置，格式为以逗号分隔的坐标列表的列表。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学性：** 该问题描述了用于计算质心 Voronoi 剖分（CVT）的 Lloyd 算法的加权版本。这是计算几何和科学计算中一个标准且成熟的方法。将其应用于优化电池设计参数空间中的采样，是工程和材料科学中一个现实且相关的用例。\n- **适定性：** 该问题是适定的。目标陈述清晰，更新规则在数学上没有歧义，并且为每个测试用例提供了所有必需的参数和初始条件。迭代过程定义了固定的步数，确保了唯一的最终状态。处理空 Voronoi 单元的规则消除了任何歧义。\n- **客观性：** 该问题使用精确的数学和算法语言进行表述。所有术语都有定义，要求是客观且可量化的。\n- **完整性和一致性：** 该问题是自洽的。提供了所有必要的数值、函数和约束。没有内部矛盾。\n- **现实性和可行性：** 物理参数（C-rate、温度）在电池研究的实际范围内。计算任务虽然需要仔细实现，但是可行的。\n\n### 步骤 3：结论和行动\n该问题是 **有效的**。它是一个定义明确、基于既定数学原理的计算问题。将提供解决方案。\n\n### 基于原理的解决方案设计\n\n目标是实现一个离散的、加权的 Lloyd 算法，以找到 $k$ 个生成点 $\\{p_i = (c_i, T_i)\\}_{i=1}^k$ 的位置，这些点是它们各自在域 $\\Omega$ 内的 Voronoi 单元的加权质心。对于一个区域 $V_i \\subseteq \\Omega$，其关于权重函数 $w(p)$ 的加权质心 $p_i'$ 的位置由以下积分公式给出：\n$$\np_i' = \\frac{\\int_{V_i} p \\cdot w(p) \\, dA}{\\int_{V_i} w(p) \\, dA}\n$$\n其中 $p = (c, T)$ 代表域中的一个点。\n\n该问题指定了对此连续问题的一种数值近似方法。域 $\\Omega = [c_{\\min}, c_{\\max}] \\times [T_{\\min}, T_{\\max}]$ 被离散化为一个由 $n_x \\times n_y$ 个节点组成的均匀笛卡尔网格。设该网格节点集合为 $\\mathcal{G} = \\{q_j\\}_{j=1}^{n_x n_y}$，其中每个 $q_j = (c_j, T_j)$ 是 $\\Omega$ 中的一个点。积分被替换为对这些网格节点的求和。\n\n算法以迭代方式进行，迭代次数为指定的 $N_{\\text{iter}}$。设 $P^{(m)} = \\{p_i^{(m)}\\}_{i=1}^k$ 为第 $m$ 次迭代时的生成点集合。\n\n**1. 初始化：**\n从初始生成点集 $P^{(0)}$ 开始。将域 $\\Omega$ 离散化为一个网格 $\\mathcal{G}$。网格节点的坐标通过均匀间隔的点生成：\n$$ c_j = c_{\\min} + j \\frac{c_{\\max} - c_{\\min}}{n_x - 1}, \\quad j = 0, \\dots, n_x-1 $$\n$$ T_\\ell = T_{\\min} + \\ell \\frac{T_{\\max} - T_{\\min}}{n_y - 1}, \\quad \\ell = 0, \\dots, n_y-1 $$\n对每个网格节点 $q \\in \\mathcal{G}$，计算并存储权重函数 $w(q)$。\n\n**2. 迭代更新：**\n对于每次迭代 $m = 0, 1, \\dots, N_{\\text{iter}}-1$：\n\n**a. 剖分步骤（近似 Voronoi 剖分）：**\n通过将每个网格节点 $q_j \\in \\mathcal{G}$ 分配给当前集合 $P^{(m)}$ 中最近的生成点，来近似连续的 Voronoi 剖分。距离度量为标准欧几里得距离。这将网格 $\\mathcal{G}$ 剖分为 $k$ 个不相交的子集 $\\mathcal{G}_1^{(m)}, \\mathcal{G}_2^{(m)}, \\dots, \\mathcal{G}_k^{(m)}$，其中：\n$$\n\\mathcal{G}_i^{(m)} = \\{q \\in \\mathcal{G} \\mid \\|q - p_i^{(m)}\\|_2 \\leq \\|q - p_j^{(m)}\\|_2 \\text{ for all } j \\neq i\\}\n$$\n相等情况可以任意处理，例如，将点分配给索引较小的生成点。\n\n**b. 质心更新步骤：**\n对于每个 $i \\in \\{1, \\dots, k\\}$，下一个生成点的位置 $p_i^{(m+1)}$ 计算为其分配的单元 $\\mathcal{G}_i^{(m)}$ 中网格节点的加权质心。连续积分被离散求和所取代：\n$$\np_i^{(m+1)} = \\frac{\\sum_{q \\in \\mathcal{G}_i^{(m)}} q \\cdot w(q)}{\\sum_{q \\in \\mathcal{G}_i^{(m)}} w(q)}\n$$\n这个向量方程可以对每个坐标表示为：\n$$\nc_i^{(m+1)} = \\frac{\\sum_{(c_j, T_j) \\in \\mathcal{G}_i^{(m)}} c_j \\cdot w(c_j, T_j)}{\\sum_{(c_j, T_j) \\in \\mathcal{G}_i^{(m)}} w(c_j, T_j)}\n$$\n$$\nT_i^{(m+1)} = \\frac{\\sum_{(c_j, T_j) \\in \\mathcal{G}_i^{(m)}} T_j \\cdot w(c_j, T_j)}{\\sum_{(c_j, T_j) \\in \\mathcal{G}_i^{(m)}} w(c_j, T_j)}\n$$\n根据问题规范，如果一个单元 $\\mathcal{G}_i^{(m)}$ 是空的（即不包含网格节点），则生成点的位置不更新：$p_i^{(m+1)} = p_i^{(m)}$。如果对空集求和，这个条件会自然处理，但必须显式检查以避免除以零。由于权重函数 $w(c, T)$ 严格为正，分母为零当且仅当集合 $\\mathcal{G}_i^{(m)}$ 为空。\n\n**3. 终止：**\n经过 $N_{\\text{iter}}$ 次迭代后，生成点的最终位置由集合 $P^{(N_{\\text{iter}})}$ 给出。这些是要报告的结果。将为提供的每个测试用例实现此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef compute_weighted_cvt(domain, weight_params, initial_generators, grid_resolution, n_iter):\n    \"\"\"\n    Computes weighted centroidal Voronoi tessellations using a discrete Lloyd-type algorithm.\n\n    Args:\n        domain (dict): Dictionary with keys 'c_min', 'c_max', 't_min', 't_max'.\n        weight_params (dict): Dictionary with keys 'alpha', 'beta'.\n        initial_generators (list of tuples): Initial positions of the generators.\n        grid_resolution (dict): Dictionary with keys 'nx', 'ny'.\n        n_iter (int): Number of iterations to perform.\n\n    Returns:\n        list of lists: Final positions of the generators.\n    \"\"\"\n    c_min, c_max = domain['c_min'], domain['c_max']\n    t_min, t_max = domain['t_min'], domain['t_max']\n    alpha, beta = weight_params['alpha'], weight_params['beta']\n    nx, ny = grid_resolution['nx'], grid_resolution['ny']\n\n    # Step 1: Create the grid and pre-compute weights\n    c_coords = np.linspace(c_min, c_max, nx)\n    t_coords = np.linspace(t_min, t_max, ny)\n    c_grid, t_grid = np.meshgrid(c_coords, t_coords)\n    grid_points = np.vstack([c_grid.ravel(), t_grid.ravel()]).T\n\n    # Normalize coordinates for weight calculation, handling potential division by zero if domain is a point.\n    c_range = c_max - c_min\n    t_range = t_max - t_min\n    c_norm = (grid_points[:, 0] - c_min) / c_range if c_range > 0 else np.zeros(grid_points.shape[0])\n    t_norm = (grid_points[:, 1] - t_min) / t_range if t_range > 0 else np.zeros(grid_points.shape[0])\n    \n    weights = np.exp(alpha * c_norm + beta * t_norm)\n\n    # Initialize generators\n    generators = np.array(initial_generators, dtype=float)\n    num_generators = generators.shape[0]\n\n    # Step 2: Iterative updates\n    for _ in range(n_iter):\n        # Step 2a: Partition the grid by assigning each grid point to the nearest generator\n        # cdist computes the Euclidean distance between each grid point and each generator.\n        # 'sqeuclidean' is used for efficiency as it avoids the sqrt operation.\n        dists_sq = cdist(grid_points, generators, 'sqeuclidean')\n        assignments = np.argmin(dists_sq, axis=1)\n\n        # Step 2b: Update generator positions to the weighted centroid of their cells\n        new_generators = generators.copy()\n        for i in range(num_generators):\n            # Find all grid points assigned to the current generator\n            mask = (assignments == i)\n            \n            # If the cell is empty, do not update the generator position\n            if not np.any(mask):\n                continue\n            \n            points_in_cell = grid_points[mask]\n            weights_in_cell = weights[mask]\n            \n            # Calculate the weighted centroid\n            denominator = np.sum(weights_in_cell)\n            \n            # The numerator is the sum of (point_coordinate * weight)\n            # Use broadcasting to multiply each coordinate of each point by its corresponding weight\n            weighted_coords = points_in_cell * weights_in_cell[:, np.newaxis]\n            \n            # Sum the weighted coordinates and divide by the sum of weights\n            centroid = np.sum(weighted_coords, axis=0) / denominator\n            \n            new_generators[i] = centroid\n        \n        generators = new_generators\n\n    return generators.tolist()\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"domain\": {\"c_min\": 0.0, \"c_max\": 6.0, \"t_min\": 293.0, \"t_max\": 333.0},\n            \"weight_params\": {\"alpha\": 3.0, \"beta\": 2.0},\n            \"initial_generators\": [(1.0, 300.0), (3.0, 320.0), (5.5, 330.0), (4.0, 295.0)],\n            \"grid_resolution\": {\"nx\": 64, \"ny\": 64},\n            \"n_iter\": 2,\n        },\n        {\n            \"domain\": {\"c_min\": 0.0, \"c_max\": 10.0, \"t_min\": 273.0, \"t_max\": 343.0},\n            \"weight_params\": {\"alpha\": 1.0, \"beta\": 1.0},\n            \"initial_generators\": [(0.2, 273.0), (9.8, 343.0), (0.2, 343.0)],\n            \"grid_resolution\": {\"nx\": 60, \"ny\": 60},\n            \"n_iter\": 1,\n        },\n        {\n            \"domain\": {\"c_min\": 0.0, \"c_max\": 8.0, \"t_min\": 298.0, \"t_max\": 358.0},\n            \"weight_params\": {\"alpha\": 8.0, \"beta\": 8.0},\n            \"initial_generators\": [(1.0, 300.0), (2.0, 330.0), (7.5, 356.0)],\n            \"grid_resolution\": {\"nx\": 80, \"ny\": 80},\n            \"n_iter\": 1,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        final_generators = compute_weighted_cvt(\n            case[\"domain\"],\n            case[\"weight_params\"],\n            case[\"initial_generators\"],\n            case[\"grid_resolution\"],\n            case[\"n_iter\"]\n        )\n        # Format list to string without spaces for compact output\n        result_str = str(final_generators).replace(\" \", \"\")\n        results.append(result_str)\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}