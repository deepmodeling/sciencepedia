{
    "hands_on_practices": [
        {
            "introduction": "在材料发现的初期阶段，研究者常常面对众多的潜在影响因素。全因子实验（即测试所有因素的全部水平组合）在成本和时间上往往是不可行的。部分因子设计（Fractional Factorial Design）提供了一种高效的策略，可以用最少的实验次数筛选出最重要的因素。然而，这种效率的代价是效应的“混杂”（aliasing），即不同效应的影响无法被完全区分。本练习将通过构建一个$2^{5-2}$设计的别名结构，帮助你深入理解混杂的概念及其对实验结果解读的影响 。",
            "id": "3905377",
            "problem": "一个研究团队正在为自动化电池设计和模拟执行一项电解质配方的虚拟筛选活动，使用实验设计（DOE）来研究五个二元可控因子：溶剂族 $A$、共溶剂存在性 $B$、盐类型 $C$、添加剂包 $D$ 和合成温度方案 $E$。为了减少所需的高保真电化学模拟次数，他们选择了一个正则两水平部分析因设计，进行 $2^{5-2}$ 次试验，该设计通过施加两个独立的生成元 $G_1$ 和 $G_2$ 来创建，使得定义关系满足 $I = G_1$ 和 $I = G_2$，其中 $I$ 表示恒等式。所选的生成元是 $G_1 = ABCD$ 和 $G_2 = ABCE$。\n\n从正则部分析因设计的基本效应混杂原理出发——即任何效应的混杂集是通过将该效应与由生成元导出的完全定义关系中的每个字相乘得到的，并使用代数规则 $A^2 = B^2 = C^2 = D^2 = E^2 = I$ 和因子-字乘法的交换律——构建由这些生成元所隐含的完整混杂结构，并识别哪些主效应和二因子交互效应彼此混杂。然后，根据完全定义关系，确定该设计的分辨率 $R$，分辨率定义为定义关系中非恒等式字的最短字长（字母数）。\n\n将您的最终答案表示为 $R$ 的单个数值，不带单位。无需四舍五入。",
            "solution": "该问题要求对一个 $2^{5-2}$ 正则两水平部分析因设计进行分析。分析按规定分三步进行：首先，从给定的生成元推导完全定义关系；其次，构建主效应和二因子交互效应的混杂结构；第三，确定设计分辨率 $R$。\n\n### 步骤1：问题验证\n问题陈述为标准的实验设计（DOE）分析提供了所有必要信息。\n- **已知条件**：五个二元因子，表示为 $A, B, C, D, E$。设计是一个 $2^{5-2}$ 部分析因设计。生成元为 $G_1 = ABCD$ 和 $G_2 = ABCE$。代数规则为对于任何因子 $X$，$X^2 = I$（其中 $I$ 是恒等式）以及乘法交换律。\n- **任务**：\n    1. 构建完整的混杂结构。\n    2. 识别主效应和二因子交互效应之间的混杂关系。\n    3. 确定设计分辨率 $R$。\n- **结论**：该问题在科学上基于实验设计的数学理论，问题提出得很好，并使用了客观、明确的语言。这是一个有效的问题。\n\n### 步骤2：推导完全定义关系\n部分析因设计由一组与恒等式 $I$ 混杂的字定义。这个集合称为定义关系，在字乘法运算下形成一个数学群。该群由指定的生成元生成。对于本问题，生成元为 $G_1 = ABCD$ 和 $G_2 = ABCE$。\n\n完全定义关系包括恒等式 $I$、生成元本身以及它们所有可能的乘积。\n初始的定义关系为：\n$I = G_1 = ABCD$\n$I = G_2 = ABCE$\n\n为了找到完全关系，我们必须计算生成元的乘积 $G_1 G_2$。使用提供的代数规则（交换律和对于任何因子 $X$，$X^2 = I$）：\n$$G_1 G_2 = (ABCD)(ABCE) = A \\cdot A \\cdot B \\cdot B \\cdot C \\cdot C \\cdot D \\cdot E = A^2 B^2 C^2 DE$$\n由于 $A^2 = I$，$B^2 = I$ 和 $C^2 = I$，表达式简化为：\n$$A^2 B^2 C^2 DE = (I)(I)(I)DE = DE$$\n因此，定义关系中的第三个非恒等式字是 $DE$，我们有 $I = DE$。\n\n完全定义关系是集合 $\\{I, G_1, G_2, G_1 G_2\\}$，即：\n$$I = ABCD = ABCE = DE$$\n\n### 步骤3：确定设计分辨率\n部分析因设计的分辨率，用 $R$ 表示，定义为其完全定义关系中最短字的长度（不包括恒等式字 $I$）。\n定义关系中的非恒等式字是 $ABCD$、$ABCE$ 和 $DE$。我们确定它们的长度（字母数）：\n- $ABCD$ 的长度是 $4$。\n- $ABCE$ 的长度是 $4$。\n- $DE$ 的长度是 $2$。\n\n分辨率 $R$ 是这些长度的最小值：\n$$R = \\min(4, 4, 2) = 2$$\n分辨率II级设计是指主效应与其他主效应混杂的设计。这是一个非常不理想的属性，因为它使得无法区分混杂的主效应因子的效果。\n\n### 步骤4：构建混杂结构\n任何效应的混杂集都是通过将该效应与完全定义关系中的每个字相乘得到的。\n\n**主效应混杂：**\n一个主效应（例如 $X$）的混杂链由集合 $\\{X, X \\cdot (ABCD), X \\cdot (ABCE), X \\cdot (DE)\\}$ 给出。\n- 对于因子 $D$：\n  $D \\cdot ABCD = ABC(D^2) = ABCI = ABC$\n  $D \\cdot ABCE = ABCDE$\n  $D \\cdot DE = (D^2)E = IE = E$\n  因此，$D$ 的混杂链是 $D \\leftrightarrow ABC \\leftrightarrow ABCDE \\leftrightarrow E$。最关键的是，这表明 $D$ 的主效应与 $E$ 的主效应混杂。\n\n- 主效应的完整混杂链集是：\n  $A \\leftrightarrow BCD \\leftrightarrow BCE \\leftrightarrow ADE$\n  $B \\leftrightarrow ACD \\leftrightarrow ACE \\leftrightarrow BDE$\n  $C \\leftrightarrow ABD \\leftrightarrow ABE \\leftrightarrow CDE$\n  $D \\leftrightarrow E \\leftrightarrow ABC \\leftrightarrow ABCDE$\n\n**二因子交互效应混杂：**\n二因子交互效应之间的混杂关系以类似方式确定。\n- 对于交互效应 $AB$：\n  $AB \\cdot ABCD = (A^2)(B^2)CD = I \\cdot I \\cdot CD = CD$\n  $AB \\cdot ABCE = (A^2)(B^2)CE = I \\cdot I \\cdot CE = CE$\n  $AB \\cdot DE = ABDE$\n  因此，混杂链是 $AB \\leftrightarrow CD \\leftrightarrow CE$。\n\n- 二因子交互效应的完整混杂结构被划分为以下集合：\n  1. $\\{AB, CD, CE, ABDE\\}$\n  2. $\\{AC, BD, BE, ACDE\\}$\n  3. $\\{AD, BC, AE, BCDE\\}$\n\n  这可以表示为二因子交互效应之间的混杂关系：\n  - $AB \\leftrightarrow CD \\leftrightarrow CE$\n  - $AC \\leftrightarrow BD \\leftrightarrow BE$\n  - $AD \\leftrightarrow BC \\leftrightarrow AE$\n\n  最后，交互效应 $DE$ 本身就是定义关系中的一个字：\n  $DE \\cdot I = DE$\n  $DE \\cdot DE = D^2 E^2 = I \\cdot I = I$\n  这意味着二因子交互效应 $DE$ 与恒等式 $I$ 混杂。其效应与总均值（回归模型中的截距项）相混淆，无法从实验数据中估计。\n\n该分析证实了分辨率II级设计的含义：主效应 $D$ 和 $E$ 彼此混杂。关于分辨率 $R$ 的核心问题已经得到解答。",
            "answer": "$$\\boxed{2}$$"
        },
        {
            "introduction": "当通过筛选实验确定了关键因素后，下一步通常是建立一个更精细的数学模型，以量化这些因素如何影响系统性能，并找到最优的操作条件。响应面法（Response Surface Methodology, RSM）是实现这一目标的常用工具，它通过拟合一个（通常是二次）多项式模型来描述输入变量与输出响应之间的关系。本练习将带你实践响应面分析中最关键的一步：求解拟合模型的稳态点，并判断其类型（最大值、最小值或鞍点），从而确定能使电池容量保持率达到最佳的电解液组分 。",
            "id": "3905189",
            "problem": "一项针对锂离子电池电解质的虚拟筛选活动使用二阶响应面模型来预测在恒定方案下循环后的长期容量保持率。使用中心复合设计 (Central Composite Design, CCD) 对两个组分变量进行调整：碳酸亚乙酯相对于碳酸甲乙酯的体积分数的编码偏差，记为 $x_1$；以及碳酸二甲酯与碳酸二乙酯的体积比的编码偏差，记为 $x_2$。预测的容量保持率（表示为无单位的小数）的拟合二次模型，以编码变量表示为：\n$$\n\\hat{R}(x_1,x_2) \\;=\\; b_0 \\;+\\; b_1 x_1 \\;+\\; b_2 x_2 \\;+\\; b_{11} x_1^2 \\;+\\; b_{22} x_2^2 \\;+\\; b_{12} x_1 x_2,\n$$\n系数为：\n$$\nb_0 = 0.92,\\quad b_1 = 0.05,\\quad b_2 = -0.03,\\quad b_{11} = -0.15,\\quad b_{22} = -0.10,\\quad b_{12} = -0.02.\n$$\n从多元微积分中的驻点定义和基于海森矩阵的二阶导数检验出发，完成以下任务：\n\n1. 通过求解一阶最优性条件 $\\frac{\\partial \\hat{R}}{\\partial x_1} = 0$ 和 $\\frac{\\partial \\hat{R}}{\\partial x_2} = 0$，解析地推导出驻点 $(x_1^{\\star},x_2^{\\star})$。\n\n2. 通过分析 $\\hat{R}(x_1,x_2)$ 在 $(x_1^{\\star},x_2^{\\star})$ 处的海森矩阵的定性，将驻点分类为局部最小值、局部最大值或鞍点。\n\n3. 计算驻点处的预测容量保持率 $\\hat{R}(x_1^{\\star},x_2^{\\star})$，并将此标量作为最终答案报告。\n\n将最终答案表示为无单位小数，并四舍五入至五位有效数字。本题无需将编码变量转换为物理组分单位。",
            "solution": "该问题要求找到并分类给定电池容量保持率的二阶响应面模型的驻点，然后计算该点处的预测保持率。\n\n预测容量保持率的模型 $\\hat{R}(x_1, x_2)$ 由以下二次函数给出：\n$$\n\\hat{R}(x_1,x_2) = b_0 + b_1 x_1 + b_2 x_2 + b_{11} x_1^2 + b_{22} x_2^2 + b_{12} x_1 x_2\n$$\n系数为：\n$$\nb_0 = 0.92,\\quad b_1 = 0.05,\\quad b_2 = -0.03,\\quad b_{11} = -0.15,\\quad b_{22} = -0.10,\\quad b_{12} = -0.02.\n$$\n代入系数，函数为：\n$$\n\\hat{R}(x_1,x_2) = 0.92 + 0.05 x_1 - 0.03 x_2 - 0.15 x_1^2 - 0.10 x_2^2 - 0.02 x_1 x_2\n$$\n\n**1. 驻点的推导**\n\n当函数的梯度为零向量时，出现驻点 $(x_1^{\\star}, x_2^{\\star})$。这可以通过将关于 $x_1$ 和 $x_2$ 的一阶偏导数设为零来找到。\n\n首先，我们计算关于 $x_1$ 的偏导数：\n$$\n\\frac{\\partial \\hat{R}}{\\partial x_1} = \\frac{\\partial}{\\partial x_1} (0.92 + 0.05 x_1 - 0.03 x_2 - 0.15 x_1^2 - 0.10 x_2^2 - 0.02 x_1 x_2) = 0.05 - 2(0.15) x_1 - 0.02 x_2\n$$\n$$\n\\frac{\\partial \\hat{R}}{\\partial x_1} = 0.05 - 0.30 x_1 - 0.02 x_2\n$$\n接着，我们计算关于 $x_2$ 的偏导数：\n$$\n\\frac{\\partial \\hat{R}}{\\partial x_2} = \\frac{\\partial}{\\partial x_2} (0.92 + 0.05 x_1 - 0.03 x_2 - 0.15 x_1^2 - 0.10 x_2^2 - 0.02 x_1 x_2) = -0.03 - 2(0.10) x_2 - 0.02 x_1\n$$\n$$\n\\frac{\\partial \\hat{R}}{\\partial x_2} = -0.03 - 0.02 x_1 - 0.20 x_2\n$$\n一阶最优性条件是 $\\frac{\\partial \\hat{R}}{\\partial x_1} = 0$ 和 $\\frac{\\partial \\hat{R}}{\\partial x_2} = 0$。这给出了以下线性方程组：\n$$\n\\begin{cases}\n0.05 - 0.30 x_1 - 0.02 x_2 = 0 \\\\\n-0.03 - 0.02 x_1 - 0.20 x_2 = 0\n\\end{cases}\n$$\n整理各项，我们得到：\n$$\n\\begin{cases}\n0.30 x_1 + 0.02 x_2 = 0.05  (1) \\\\\n0.02 x_1 + 0.20 x_2 = -0.03  (2)\n\\end{cases}\n$$\n我们可以求解这个方程组。从方程(1)中，我们可以用 $x_1$ 表示 $x_2$：\n$$\n0.02 x_2 = 0.05 - 0.30 x_1 \\implies x_2 = \\frac{0.05 - 0.30 x_1}{0.02} = 2.5 - 15 x_1\n$$\n将这个 $x_2$ 的表达式代入方程(2)：\n$$\n0.02 x_1 + 0.20 (2.5 - 15 x_1) = -0.03\n$$\n$$\n0.02 x_1 + 0.5 - 3.0 x_1 = -0.03\n$$\n$$\n-2.98 x_1 = -0.53\n$$\n$$\nx_1^{\\star} = \\frac{-0.53}{-2.98} = \\frac{53}{298}\n$$\n现在，将 $x_1^{\\star}$ 的值代回到 $x_2$ 的表达式中：\n$$\nx_2^{\\star} = 2.5 - 15 \\left(\\frac{53}{298}\\right) = \\frac{5}{2} - \\frac{795}{298} = \\frac{5 \\times 149 - 795}{298} = \\frac{745 - 795}{298} = \\frac{-50}{298} = -\\frac{25}{149}\n$$\n因此，驻点为 $(x_1^{\\star}, x_2^{\\star}) = \\left(\\frac{53}{298}, -\\frac{25}{149}\\right)$。\n\n**2. 驻点的分类**\n\n为了对驻点进行分类，我们使用二阶导数检验，这涉及到分析 $\\hat{R}$ 的海森矩阵。海森矩阵 $H$ 的元素是二阶偏导数。\n$$\n\\frac{\\partial^2 \\hat{R}}{\\partial x_1^2} = \\frac{\\partial}{\\partial x_1} (0.05 - 0.30 x_1 - 0.02 x_2) = -0.30\n$$\n$$\n\\frac{\\partial^2 \\hat{R}}{\\partial x_2^2} = \\frac{\\partial}{\\partial x_2} (-0.03 - 0.02 x_1 - 0.20 x_2) = -0.20\n$$\n$$\n\\frac{\\partial^2 \\hat{R}}{\\partial x_1 \\partial x_2} = \\frac{\\partial^2 \\hat{R}}{\\partial x_2 \\partial x_1} = \\frac{\\partial}{\\partial x_1} (-0.03 - 0.02 x_1 - 0.20 x_2) = -0.02\n$$\n对于这个二次模型，海森矩阵是恒定的：\n$$\nH = \\begin{pmatrix} \\frac{\\partial^2 \\hat{R}}{\\partial x_1^2}  \\frac{\\partial^2 \\hat{R}}{\\partial x_1 \\partial x_2} \\\\ \\frac{\\partial^2 \\hat{R}}{\\partial x_2 \\partial x_1}  \\frac{\\partial^2 \\hat{R}}{\\partial x_2^2} \\end{pmatrix} = \\begin{pmatrix} -0.30  -0.02 \\\\ -0.02  -0.20 \\end{pmatrix}\n$$\n我们计算海森矩阵的行列式 $\\det(H)$：\n$$\n\\det(H) = (-0.30)(-0.20) - (-0.02)(-0.02) = 0.06 - 0.0004 = 0.0596\n$$\n由于 $\\det(H)  0$，该驻点是局部最大值或局部最小值。为了确定是哪一种，我们检查一阶顺序主子式 $\\frac{\\partial^2 \\hat{R}}{\\partial x_1^2}$ 的符号：\n$$\n\\frac{\\partial^2 \\hat{R}}{\\partial x_1^2} = -0.30\n$$\n由于 $\\frac{\\partial^2 \\hat{R}}{\\partial x_1^2}  0$ 且 $\\det(H)  0$，海森矩阵是负定的。因此，驻点 $(x_1^{\\star}, x_2^{\\star})$ 是一个局部最大值。\n\n**3. 计算驻点处的预测容量保持率**\n\n最后，我们通过将驻点的坐标代入模型方程来计算预测的容量保持率 $\\hat{R}(x_1^{\\star}, x_2^{\\star})$。\n对于二次响应面，一个有用的简化是驻点处的值 $\\hat{R}(\\mathbf{x}^{\\star})$ 可由下式给出：\n$$\n\\hat{R}(\\mathbf{x}^{\\star}) = b_0 + \\frac{1}{2} (b_1 x_1^{\\star} + b_2 x_2^{\\star})\n$$\n我们首先计算 $b_1 x_1^{\\star} + b_2 x_2^{\\star}$ 这一项：\n$$\nb_1 x_1^{\\star} + b_2 x_2^{\\star} = (0.05) \\left(\\frac{53}{298}\\right) + (-0.03) \\left(-\\frac{25}{149}\\right)\n$$\n$$\n= \\frac{2.65}{298} + \\frac{0.75}{149} = \\frac{2.65}{298} + \\frac{2 \\times 0.75}{2 \\times 149} = \\frac{2.65}{298} + \\frac{1.5}{298} = \\frac{2.65 + 1.5}{298} = \\frac{4.15}{298}\n$$\n现在，将此结果代入 $\\hat{R}(\\mathbf{x}^{\\star})$ 的公式中：\n$$\n\\hat{R}(x_1^{\\star}, x_2^{\\star}) = 0.92 + \\frac{1}{2} \\left(\\frac{4.15}{298}\\right) = 0.92 + \\frac{4.15}{596}\n$$\n为了获得数值，我们进行除法运算：\n$$\n\\frac{4.15}{596} \\approx 0.006963087248\n$$\n$$\n\\hat{R}(x_1^{\\star}, x_2^{\\star}) \\approx 0.92 + 0.006963087248 = 0.926963087248\n$$\n题目要求最终答案四舍五入至五位有效数字。结果的前五位有效数字是 $9$、$2$、$6$、$9$ 和 $6$。第六位有效数字是 $3$，因此我们向下舍入。\n驻点处的预测容量保持率为 $0.92696$。",
            "answer": "$$\n\\boxed{0.92696}\n$$"
        },
        {
            "introduction": "现实世界中的工程设计，如电池电解液的开发，往往需要在多个相互冲突的目标之间进行权衡，例如同时追求高离子电导率和宽电化学稳定窗口。多目标优化旨在找到一组“帕累托最优”（Pareto-optimal）解，这些解代表了不同目标之间的最佳权衡。在自动化实验平台中，期望超体积增益（Expected Hypervolume Improvement, EHVI）是一种先进的决策准则，它能基于不确定性量化，智能地选择下一个最有可能扩展我们对最优权衡边界认知的实验点。本编程练习将让你亲手实现非支配排序和基于蒙特卡洛的EHVI计算，体验自动化材料发现的前沿技术 。",
            "id": "3905367",
            "problem": "您正在为锂离子电池电解质的发现设计一个自动化的多目标优化活动，该活动专注于虚拟筛选和实验设计。每种电解质由两个需要最大化的可测量目标来表征：离子电导率和电化学稳定窗口。任务是实现两个核心组件：非支配排序，以及在高斯预测模型下通过最大化期望超体积提升（EHVI）来选择下一个实验。\n\n请遵循以下基本原理：\n- **多目标优化中的帕累托支配**：对于一个最大化问题，如果点 $\\mathbf{p} \\in \\mathbb{R}^m$ 对于所有 $i \\in \\{1,\\dots,m\\}$ 都有 $p_i \\ge q_i$，并且存在某个 $j$ 使得 $p_j  q_j$，那么点 $\\mathbf{p}$ 支配点 $\\mathbf{q} \\in \\mathbb{R}^m$。\n- **超体积指标**：给定一个集合 $S \\subset \\mathbb{R}^m$ 和一个参考点 $\\mathbf{r} \\in \\mathbb{R}^m$，在最大化设定下，超体积 $\\mathcal{H}(S;\\mathbf{r})$ 是对于每个 $\\mathbf{s} \\in S$ 的轴对齐矩形 $\\prod_{i=1}^m [r_i,s_i]$ 之并集的勒贝格测度（只有满足 $s_i \\ge r_i$ 的矩形才贡献非零测度）。\n- **期望超体积提升 (EHVI)**：给定一个候选点 $\\mathbf{Y}$ 的概率预测模型，EHVI 是 $\\mathbb{E}\\left[\\max\\left(0, \\mathcal{H}(S \\cup \\{\\mathbf{Y}\\};\\mathbf{r}) - \\mathcal{H}(S;\\mathbf{r})\\right)\\right]$。\n\n您必须完成以下任务：\n1.  实现一个非支配排序程序，为一组已测量的电解质分配排名。如果一个候选者是非支配的，则其排名为 $1$；如果它仅被排名为 $1$ 的点支配，则其排名为 $2$，以此类推，遵循经典的分层定义。\n2.  在双目标独立高斯预测模型下，通过最大化期望超体积提升（EHVI）来选择下一个实验。其中，每个候选者的预测目标被建模为独立的、服从正态分布的随机变量。使用蒙特卡洛积分来近似期望值：为每个候选者抽取 $N$ 个独立样本，并计算平均超体积提升。为保证可复现性和科学严谨性，请使用固定的伪随机种子并确保确定性输出。\n3.  选择具有最大 EHVI 值的候选者作为下一个实验。如果 EHVI 值在 $10^{-9}$ 的容差范围内出现平局，则选择索引最小的候选者。\n\n**单位与科学约定：**\n- 目标1（离子电导率）必须以 S/m 为单位。\n- 目标2（电化学稳定窗口）必须以 V 为单位。\n- 超体积和 EHVI 必须以 S/m·V 为单位。\n- 不涉及角度。\n- 不使用百分比。\n\n您的实现必须严格遵循上述数学和算法定义，不得使用任何简化的快捷公式。具体而言，蒙特卡洛积分必须通过从指定的高斯预测分布中直接采样来完成，而二维超体积差值的计算则需采用正确的矩形并集方法。\n\n**测试用例与输出要求：**\n请实现您的程序来处理以下三个测试用例。对每个案例，为已测量的电解质计算非支配排序排名，然后通过在提议的候选者中最大化 EHVI 来选择下一个实验。每个候选者使用 $N=10000$ 个样本，并使用基础种子 $s=42$；对于一个案例中的候选者 $k$，使用种子 $s+k$。\n\n**案例1：**\n- 已测量的电解质（按以下顺序），每个点表示为（电导率，单位 S/m；窗口，单位 V）：\n  - $E_1$: $(1.1,\\ 4.2)$\n  - $E_2$: $(0.9,\\ 4.8)$\n  - $E_3$: $(1.3,\\ 4.0)$\n  - $E_4$: $(0.7,\\ 4.6)$\n  - $E_5$: $(1.0,\\ 4.4)$\n- 参考点 $\\mathbf{r} = (0.0,\\ 0.0)$。\n- 候选者的预测均值 $\\boldsymbol{\\mu}_k$ 和标准差 $\\boldsymbol{\\sigma}_k$（每个目标独立服从正态分布）：\n  - $C_1$: $\\boldsymbol{\\mu}_1 = (1.05,\\ 4.9)$, $\\boldsymbol{\\sigma}_1 = (0.1,\\ 0.2)$\n  - $C_2$: $\\boldsymbol{\\mu}_2 = (1.4,\\ 4.1)$, $\\boldsymbol{\\sigma}_2 = (0.05,\\ 0.15)$\n  - $C_3$: $\\boldsymbol{\\mu}_3 = (0.85,\\ 4.7)$, $\\boldsymbol{\\sigma}_3 = (0.12,\\ 0.1)$\n\n**案例2：**\n- 已测量的电解质：\n  - $E_1$: $(1.2,\\ 4.7)$\n  - $E_2$: $(1.2,\\ 4.7)$\n  - $E_3$: $(0.6,\\ 5.0)$\n  - $E_4$: $(1.5,\\ 3.9)$\n  - $E_5$: $(0.4,\\ 4.0)$\n- 参考点 $\\mathbf{r} = (0.0,\\ 0.0)$。\n- 候选者：\n  - $C_1$: $\\boldsymbol{\\mu}_1 = (1.2,\\ 4.8)$, $\\boldsymbol{\\sigma}_1 = (0.0,\\ 0.05)$\n  - $C_2$: $\\boldsymbol{\\mu}_2 = (0.5,\\ 4.1)$, $\\boldsymbol{\\sigma}_2 = (0.1,\\ 0.1)$\n  - $C_3$: $\\boldsymbol{\\mu}_3 = (1.6,\\ 4.0)$, $\\boldsymbol{\\sigma}_3 = (0.05,\\ 0.05)$\n\n**案例3：**\n- 已测量的电解质：\n  - $E_1$: $(1.3,\\ 4.9)$\n  - $E_2$: $(1.1,\\ 4.8)$\n  - $E_3$: $(1.0,\\ 5.0)$\n  - $E_4$: $(1.2,\\ 4.7)$\n- 参考点 $\\mathbf{r} = (0.0,\\ 0.0)$。\n- 候选者：\n  - $C_1$: $\\boldsymbol{\\mu}_1 = (0.8,\\ 4.2)$, $\\boldsymbol{\\sigma}_1 = (0.1,\\ 0.1)$\n  - $C_2$: $\\boldsymbol{\\mu}_2 = (0.9,\\ 4.3)$, $\\boldsymbol{\\sigma}_2 = (0.05,\\ 0.1)$\n  - $C_3$: $\\boldsymbol{\\mu}_3 = (1.0,\\ 4.4)$, $\\boldsymbol{\\sigma}_3 = (0.02,\\ 0.05)$\n\n**程序输入/输出与格式规范：**\n- 程序无外部输入；所有数据均已在代码中提供。\n- 对每个测试用例，生成一个形如 `[ranks, best_index, best_EHVI]` 的列表作为结果，其中：\n  - `ranks` 是一个整数列表，按提供顺序给出每个已测量电解质的非支配排序排名。\n  - `best_index` 是一个整数，标识具有最大 EHVI 的候选者的索引（基于0的索引，即 $C_1$ 为 $0$，$C_2$ 为 $1$，$C_3$ 为 $2$）。\n  - `best_EHVI` 是一个浮点数，等于所选候选者的 EHVI 值，单位为 S/m·V，四舍五入至6位小数。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，并用逗号分隔，嵌套在方括号内。例如，最终输出必须类似于 `[case1_result,case2_result,case3_result]`。\n\n**附加约束：**\n- 在二维空间中，必须使用精确的矩形并集原理来计算超体积，例如采用沿x坐标排序并维护y坐标运行最大值的平面扫描方法。\n- 非支配排序必须根据上述经典的支配定义从头实现，不得依赖任何现有的库函数。\n- 必须按照规定使用确定性的伪随机种子，并确保对不同候选者的采样过程是独立的。",
            "solution": "任务是为电池电解质发现中的一个多目标优化问题设计一个自动化的实验选择策略。该过程涉及两个主要部分：使用非支配排序对现有实验数据进行排名，以及通过最大化期望超体积提升（EHVI）来选择下一个实验。本解决方案是根据指定的帕累托优化和概率建模的基本原理推导出来的。\n\n需要最大化的两个目标是离子电导率，记为 $o_1$（单位 S/m），和电化学稳定窗口，记为 $o_2$（单位 V）。目标空间中的一个点由向量 $\\mathbf{p} = (p_1, p_2)$ 表示。\n\n### 第一部分：非支配排序\n\n第一步是评估一组现有的已测量电解质数据点 $E = \\{\\mathbf{e}_1, \\mathbf{e}_2, \\dots, \\mathbf{e}_n\\}$。此评估通过将该集合划分为带排名的非支配前沿来执行。\n\n**帕累托支配**：如果一个点 $\\mathbf{p} \\in \\mathbb{R}^2$ 在所有目标上至少与另一个点 $\\mathbf{q} \\in \\mathbb{R}^2$ 一样好，并且在至少一个目标上严格更优，则称点 $\\mathbf{p}$ 支配点 $\\mathbf{q}$，记为 $\\mathbf{p} \\succ \\mathbf{q}$。对于此最大化问题，其形式化定义为：\n$$\n\\mathbf{p} \\succ \\mathbf{q} \\iff (p_1 \\ge q_1 \\land p_2 \\ge q_2) \\land (p_1  q_1 \\lor p_2  q_2)\n$$\n\n**排序算法**：采用一种经典的非支配排序算法为每个点分配排名。一个点的排名对应于其在支配层次结构中的前沿或层级。\n\n1.  **初始化**：对于数据集 $E$ 中的每个点 $\\mathbf{p}$：\n    *   计算其支配计数 $n_p$，即 $E$ 中支配 $\\mathbf{p}$ 的其他点的数量。\n    *   构建一个集合 $S_p$，包含 $E$ 中所有被 $\\mathbf{p}$ 支配的点。\n\n2.  **第一前沿识别**：所有支配计数 $n_p = 0$ 的点都不会被集合中任何其他点所支配。这些点构成了第一个帕累托前沿 $F_1$。$F_1$ 中的所有点都被赋予排名 $1$。\n\n3.  **迭代构建前沿**：算法迭代进行以识别后续的前沿。对于当前前沿 $F_i$ 中的每个点 $\\mathbf{p}$：\n    *   遍历其被支配集合 $S_p$ 中的每个点 $\\mathbf{q}$。\n    *   将 $\\mathbf{q}$ 的支配计数减一：$n_q \\leftarrow n_q - 1$。\n    *   如果 $n_q$ 变为 $0$，意味着 $\\mathbf{q}$ 不再被任何尚未排名的点所支配。因此，$\\mathbf{q}$ 属于下一个前沿 $F_{i+1}$，并被赋予排名 $i+1$。\n\n重复此过程，直到 $E$ 中的所有点都被分配了排名。\n\n### 第二部分：超体积指标计算\n\n超体积指标 $\\mathcal{H}(S; \\mathbf{r})$ 衡量的是相对于参考点 $\\mathbf{r}$，由点集 $S$ 所支配的目标空间区域的体积（在二维中为面积）。对于一个集合 $S = \\{\\mathbf{s}_1, \\dots, \\mathbf{s}_k\\}$ 和一个参考点 $\\mathbf{r}=(r_1, r_2)$，超体积是每个点与参考点形成的超矩形并集的勒贝格测度：\n$$\n\\mathcal{H}(S; \\mathbf{r}) = \\text{measure}\\left(\\bigcup_{\\mathbf{s} \\in S} [r_1, s_1] \\times [r_2, s_2]\\right)\n$$\n其中 $[a, b]$ 表示一个闭区间，并且假设对于所有目标 $i$ 都有 $s_i \\ge r_i$。\n\n**计算算法（二维切片法）**：为了计算这些可能重叠的矩形并集的面积，我们使用一种等效于平面扫描的通用切片算法。\n\n1.  **筛选**：从 $S$ 中移除任何被参考点 $\\mathbf{r}$ 支配的点，因为它们对超体积没有贡献。设筛选后的集合为 $S'$。\n2.  **收集X坐标**：创建 $S'$ 中所有点的第一坐标值以及参考点的第一坐标值的所有唯一值的排序列表，$X = \\text{sorted}(\\text{unique}(\\{r_1\\} \\cup \\{s_1 | \\mathbf{s} \\in S'\\}))$。设这些值为 $x'_0, x'_1, \\dots, x'_m$，其中 $x'_0=r_1$。\n3.  **求和切片面积**：通过对垂直矩形切片的面积求和来计算总超体积。对于第一轴上的每个区间 $[x'_{j-1}, x'_{j}]$（其中 $j=1, \\dots, m$）：\n    *   切片的宽度为 $w_j = x'_{j} - x'_{j-1}$。\n    *   切片的高度 $h_j$ 由该区间上矩形并集的最高点决定。这对应于 $S'$ 中所有第一坐标大于等于 $x'_{j}$ 的点中的最大第二坐标值。形式上，$h_j = \\max(\\{r_2\\} \\cup \\{s_2 | \\mathbf{s} \\in S', s_1 \\ge x'_{j}\\})$。\n    *   该切片的面积为 $w_j \\times (h_j - r_2)$。\n4.  **总超体积**：总超体积是这些切片面积之和：\n    $$\n    \\mathcal{H}(S; \\mathbf{r}) = \\sum_{j=1}^{m} (x'_{j} - x'_{j-1}) \\cdot (\\max(\\{r_2\\} \\cup \\{s_2 | \\mathbf{s} \\in S', s_1 \\ge x'_{j}\\}) - r_2)\n    $$\n该方法是稳健的，并且可以正确计算任何点集的超体积，而不仅仅是针对非支配前沿。\n\n### 第三部分：期望超体积提升 (EHVI)\n\nEHVI 是选择下一个实验的标准。它量化了在给定新候选点结果的概率模型的情况下，评估该点所带来的预期超体积增量。\n\n**超体积提升 (HVI)**：将一个新点 $\\mathbf{y}$ 添加到当前非支配前沿 $F_1$ 中所带来的提升是：\n$$\n\\text{HVI}(\\mathbf{y}) = \\mathcal{H}(F_1 \\cup \\{\\mathbf{y}\\}; \\mathbf{r}) - \\mathcal{H}(F_1; \\mathbf{r})\n$$\n请注意，如果 $\\mathbf{y}$ 被 $F_1$ 中的任何点支配，矩形的并集不会改变，因此 $\\mathcal{H}(F_1 \\cup \\{\\mathbf{y}\\}; \\mathbf{r}) = \\mathcal{H}(F_1; \\mathbf{r})$，提升为 $0$。\n\n**期望超体积提升 (EHVI)**：对于一个预测结果为随机变量 $\\mathbf{Y}$ 的候选者，EHVI 是 HVI 的期望值：\n$$\n\\text{EHVI} = \\mathbb{E}[\\text{HVI}(\\mathbf{Y})] = \\mathbb{E}\\left[\\max\\left(0, \\mathcal{H}(F_1 \\cup \\{\\mathbf{Y}\\};\\mathbf{r}) - \\mathcal{H}(F_1;\\mathbf{r})\\right)\\right]\n$$\n问题规定，对于每个候选者 $k$，其目标的预测模型 $\\mathbf{Y}_k = (Y_{k1}, Y_{k2})$ 是一对独立的高斯随机变量，$Y_{k1} \\sim \\mathcal{N}(\\mu_{k1}, \\sigma_{k1}^2)$ 且 $Y_{k2} \\sim \\mathcal{N}(\\mu_{k2}, \\sigma_{k2}^2)$。\n\n**蒙特卡洛近似**：EHVI 的期望值使用蒙特卡洛积分进行近似。\n1.  **计算当前超体积**：首先，计算当前排名为1的前沿的超体积，$\\mathcal{H}_{\\text{current}} = \\mathcal{H}(F_1; \\mathbf{r})$。\n2.  **采样**：对于每个候选者 $k$，生成 $N$ 个独立样本 $\\{\\mathbf{y}^{(1)}, \\mathbf{y}^{(2)}, \\dots, \\mathbf{y}^{(N)}\\}$，其中每个 $\\mathbf{y}^{(i)} = (y_1^{(i)}, y_2^{(i)})$ 均从该候选者的预测分布 $\\mathcal{N}(\\boldsymbol{\\mu}_k, \\text{diag}(\\boldsymbol{\\sigma}_k^2))$ 中抽取。\n3.  **平均提升**：对于每个样本 $\\mathbf{y}^{(i)}$，计算增强集和的超体积，$\\mathcal{H}_{\\text{new}}^{(i)} = \\mathcal{H}(F_1 \\cup \\{\\mathbf{y}^{(i)}\\}; \\mathbf{r})$。此样本的提升为 $\\text{HVI}^{(i)} = \\mathcal{H}_{\\text{new}}^{(i)} - \\mathcal{H}_{\\text{current}}$。\n4.  **EHVI 估计**：候选者 $k$ 的 EHVI 是这些样本提升的平均值：\n    $$\n    \\text{EHVI}_k \\approx \\frac{1}{N} \\sum_{i=1}^{N} \\text{HVI}^{(i)}\n    $$\n\n### 第四部分：选择标准\n\n最后一步是从候选者集合中选择下一个实验。选择具有最高 EHVI 的候选者。为确保在出现平局时结果具有确定性，如果多个候选者的 EHVI 值在 $10^{-9}$ 的数值容差范围内达到最大，则选择原始索引最小的那个。\n\n每个测试案例的总体流程如下：\n1.  对已测量的电解质应用非支配排序，以找到它们的排名并识别第一个帕累托前沿 $F_1$。\n2.  计算基线超体积 $\\mathcal{H}_{\\text{current}} = \\mathcal{H}(F_1; \\mathbf{r})$。\n3.  对于每个候选者，使用包含 $N=10000$ 个样本和指定种子协议（对于候选者 $k$，使用 $s+k$）的蒙特卡洛程序来估计其 $\\text{EHVI}$。\n4.  选择具有最大 EHVI 的候选者，通过选择最小索引来解决平局。\n5.  报告排名、最佳候选者的索引及其 EHVI 值。",
            "answer": "```python\nimport numpy as np\n\n# Note: scipy is listed in the environment but not strictly necessary for this problem.\n# All required functionality is available in numpy.\n\ndef solve():\n    \"\"\"\n    Main function to process test cases for battery electrolyte optimization.\n    \n    This function orchestrates the entire process:\n    1. Defines the test cases.\n    2. For each case, performs non-dominated sorting on measured data.\n    3. Calculates the current Pareto front and its hypervolume.\n    4. For each candidate, computes the Expected Hypervolume Improvement (EHVI) via Monte Carlo simulation.\n    5. Selects the best candidate based on maximizing EHVI.\n    6. Formats and prints the final results.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"measured\": [(1.1, 4.2), (0.9, 4.8), (1.3, 4.0), (0.7, 4.6), (1.0, 4.4)],\n            \"ref_point\": (0.0, 0.0),\n            \"candidates\": {\n                \"means\": [(1.05, 4.9), (1.4, 4.1), (0.85, 4.7)],\n                \"stds\": [(0.1, 0.2), (0.05, 0.15), (0.12, 0.1)],\n            },\n        },\n        {\n            \"measured\": [(1.2, 4.7), (1.2, 4.7), (0.6, 5.0), (1.5, 3.9), (0.4, 4.0)],\n            \"ref_point\": (0.0, 0.0),\n            \"candidates\": {\n                \"means\": [(1.2, 4.8), (0.5, 4.1), (1.6, 4.0)],\n                \"stds\": [(0.0, 0.05), (0.1, 0.1), (0.05, 0.05)],\n            },\n        },\n        {\n            \"measured\": [(1.3, 4.9), (1.1, 4.8), (1.0, 5.0), (1.2, 4.7)],\n            \"ref_point\": (0.0, 0.0),\n            \"candidates\": {\n                \"means\": [(0.8, 4.2), (0.9, 4.3), (1.0, 4.4)],\n                \"stds\": [(0.1, 0.1), (0.05, 0.1), (0.02, 0.05)],\n            },\n        },\n    ]\n\n    N_SAMPLES = 10000\n    BASE_SEED = 42\n    TIE_TOLERANCE = 1e-9\n\n    def dominates(p1, p2):\n        \"\"\"Checks if point p1 dominates point p2 for a maximization problem.\"\"\"\n        p1 = np.asarray(p1)\n        p2 = np.asarray(p2)\n        return np.all(p1 >= p2) and np.any(p1 > p2)\n\n    def non_dominated_sorting(points):\n        \"\"\"Performs non-dominated sorting on a list of points.\"\"\"\n        n_points = len(points)\n        domination_counts = [0] * n_points\n        dominated_sets = [[] for _ in range(n_points)]\n        \n        point_indices = list(range(n_points))\n        \n        for i in range(n_points):\n            for j in range(i + 1, n_points):\n                p1 = points[i]\n                p2 = points[j]\n                \n                if dominates(p1, p2):\n                    domination_counts[j] += 1\n                    dominated_sets[i].append(j)\n                elif dominates(p2, p1):\n                    domination_counts[i] += 1\n                    dominated_sets[j].append(i)\n\n        ranks = [0] * n_points\n        fronts = [[] for _ in range(n_points + 1)]\n        \n        for i in range(n_points):\n            if domination_counts[i] == 0:\n                ranks[i] = 1\n                fronts[1].append(i)\n        \n        rank_idx = 1\n        while fronts[rank_idx]:\n            next_front = []\n            for p_idx in fronts[rank_idx]:\n                for q_idx in dominated_sets[p_idx]:\n                    domination_counts[q_idx] -= 1\n                    if domination_counts[q_idx] == 0:\n                        ranks[q_idx] = rank_idx + 1\n                        next_front.append(q_idx)\n            rank_idx += 1\n            fronts[rank_idx] = next_front\n            \n        return ranks, fronts[1]\n\n    def hypervolume_2d(points, ref_point):\n        \"\"\"\n        Calculates the 2D hypervolume of a set of points relative to a reference point.\n        Uses a slicing method for general applicability.\n        \"\"\"\n        ref_x, ref_y = ref_point\n        \n        # Filter points that are dominated by the reference point\n        effective_points = [p for p in points if p[0] >= ref_x and p[1] >= ref_y]\n        \n        if not effective_points:\n            return 0.0\n\n        # Collect and sort unique x-coordinates\n        x_coords = sorted(list(set([p[0] for p in effective_points] + [ref_x])))\n        \n        total_hv = 0.0\n        \n        # Iterate through vertical slices defined by x-coordinates\n        for i in range(1, len(x_coords)):\n            x_i = x_coords[i]\n            x_prev = x_coords[i-1]\n            width = x_i - x_prev\n            \n            # Determine the height of the slice\n            max_y = ref_y\n            # Find max y among points whose x-coordinate covers the current slice\n            relevant_points_y = [p[1] for p in effective_points if p[0] >= x_i]\n            if relevant_points_y:\n                max_y = max(relevant_points_y)\n            \n            height = max_y - ref_y\n            total_hv += width * height\n            \n        return total_hv\n\n    def calculate_ehvi(candidate_mean, candidate_std, pareto_front, h_current, ref_point, n_samples, seed):\n        \"\"\"\n        Calculates EHVI for a candidate using Monte Carlo simulation.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        \n        samples_x = rng.normal(candidate_mean[0], candidate_std[0], n_samples)\n        samples_y = rng.normal(candidate_mean[1], candidate_std[1], n_samples)\n\n        total_hvi = 0.0\n        for i in range(n_samples):\n            sample_point = (samples_x[i], samples_y[i])\n            \n            # Calculate new hypervolume with the sample point\n            h_new = hypervolume_2d(pareto_front + [sample_point], ref_point)\n            \n            # Improvement is the difference (will be >= 0)\n            hvi = h_new - h_current\n            total_hvi += hvi\n            \n        return total_hvi / n_samples\n\n    all_results = []\n    for case in test_cases:\n        measured_points = case[\"measured\"]\n        ref_point = case[\"ref_point\"]\n        candidates = case[\"candidates\"]\n        \n        ranks, front1_indices = non_dominated_sorting(measured_points)\n        pareto_front = [measured_points[i] for i in front1_indices]\n        \n        h_current = hypervolume_2d(pareto_front, ref_point)\n        \n        ehvi_values = []\n        num_candidates = len(candidates[\"means\"])\n        \n        for k in range(num_candidates):\n            mean = candidates[\"means\"][k]\n            std = candidates[\"stds\"][k]\n            seed = BASE_SEED + k\n            \n            ehvi = calculate_ehvi(mean, std, pareto_front, h_current, ref_point, N_SAMPLES, seed)\n            ehvi_values.append(ehvi)\n        \n        # Selection: find max EHVI, break ties with smallest index\n        max_ehvi = -1.0\n        # Find the true maximum value first\n        if ehvi_values:\n            max_ehvi = max(ehvi_values)\n\n        best_index = -1\n        for k, ehvi in enumerate(ehvi_values):\n            # Check if this ehvi is within tolerance of the maximum\n            if max_ehvi - ehvi = TIE_TOLERANCE:\n                best_index = k\n                break # First one found is the smallest index\n        \n        best_ehvi = ehvi_values[best_index]\n        \n        # Format the result list for this case\n        case_result = [ranks, best_index, round(best_ehvi, 6)]\n        all_results.append(case_result)\n\n    # Convert list of lists to string representation for final output\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}