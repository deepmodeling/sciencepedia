{
    "hands_on_practices": [
        {
            "introduction": "灵敏度分析的基础在于理解输出如何随输入的微小扰动而变化，这正是局部灵敏度的核心——导数。本练习提供了一个从第一性原理出发，在电化学背景下手动推导此类灵敏度的机会。通过求解基于巴特勒-福尔默（Butler-Volmer）动力学的模型，您不仅能练习微积分，还能对局部灵敏度系数所代表的物理意义建立起具体的直觉。",
            "id": "3948524",
            "problem": "一个自动化的电池设计和仿真工作流程通过评估在电荷转移控制动力学下，放电容量如何响应交换电流密度的变化来筛选候选负极化学物质。考虑一个面积为 $A$ 的单一平面电极，在温度 $T$ 下等温运行，施加固定的电极电势 $\\phi$，其界面平衡电势 $U$ 在一个持续时间为 $\\tau$ 的短放电窗口内近似恒定。界面过电势定义为 $\\eta = \\phi - U - i R_{s}$，其中 $R_{s}$ 是一个集总串联电阻，$i = A j$ 是总电流，$j$ 是界面电流密度。忽略浓差极化和传质限制，因此动力学由 Butler–Volmer 关系式决定，\n$$\nj = j_{0} \\left[\\exp\\!\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\!\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right],\n$$\n其中 $j_{0}$ 是交换电流密度，$F$ 是法拉第常数，$R$ 是通用气体常数，$\\alpha_{a}$ 和 $\\alpha_{c}$ 分别是阳极和阴极电荷转移系数。在窗口 $\\tau$ 内的放出容量定义为电荷 $Q = A \\int_{0}^{\\tau} j(t)\\,\\mathrm{d}t$。假设在 $\\tau$ 期间为准稳态操作，因此在与上述关系式一致的工作点上，$j$ 在时间上是恒定的。将 $A$、$T$、$R_{s}$、$\\phi$、$U$、$\\alpha_{a}$ 和 $\\alpha_{c}$ 视为相对于 $j_{0}$ 的常数。\n\n从上述基本定义出发，推导一个关于放出容量对交换电流密度的局部灵敏度的闭式解析表达式，即在工作点处求导数 $\\frac{\\partial Q}{\\partial j_{0}}$。您的表达式必须明确显示其对 $\\alpha_{a}$、$\\alpha_{c}$ 和过电势 $\\eta$ 的依赖关系，并包含通过串联电阻 $R_{s}$ 将 $\\eta$ 与 $j$ 耦合的影响。对所有量均使用国际单位制 (SI)。将您的最终答案表示为单个闭式解析表达式，且最终表达式中不包含单位。不需要进行数值舍入。",
            "solution": "用户要求推导放出容量 $Q$ 对交换电流密度 $j_{0}$ 的局部灵敏度。该灵敏度表示为偏导数 $\\frac{\\partial Q}{\\partial j_{0}}$。推导必须从所提供的基本定义开始。\n\n首先，我们建立放出容量 $Q$ 与界面电流密度 $j$ 之间的关系。问题将容量定义为 $Q = A \\int_{0}^{\\tau} j(t)\\,\\mathrm{d}t$，其中 $A$ 是电极面积，$\\tau$ 是放电持续时间。一个关键的简化假设是系统在准稳态条件下运行，这意味着电流密度 $j$ 在时间间隔 $\\tau$ 内是恒定的。因此，积分简化为：\n$$\nQ = A j \\tau\n$$\n参数 $A$ 和 $\\tau$ 相对于 $j_{0}$ 是常数。为了求得 $\\frac{\\partial Q}{\\partial j_{0}}$，我们可以应用链式法则：\n$$\n\\frac{\\partial Q}{\\partial j_{0}} = \\frac{\\partial (A \\tau j)}{\\partial j_{0}} = A \\tau \\frac{\\partial j}{\\partial j_{0}}\n$$\n因此，问题的核心是确定电流密度 $j$ 相对于交换电流密度 $j_{0}$ 的偏导数。\n\n该系统由两个耦合方程描述。第一个是关于电流密度 $j$ 的 Butler-Volmer 方程：\n$$\nj = j_{0} \\left[\\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right] \\quad (1)\n$$\n第二个方程定义了界面过电势 $\\eta$：\n$$\n\\eta = \\phi - U - i R_{s}\n$$\n代入 $i = A j$，其中 $j$ 是电流密度，我们得到：\n$$\n\\eta = \\phi - U - A R_s j \\quad (2)\n$$\n在此系统中，$j$ 和 $\\eta$ 都是自变量 $j_{0}$ 的函数，而所有其他量（$A$、$T$、$R_s$、$\\phi$、$U$、$\\alpha_a$、$\\alpha_c$、$F$、$R$）都被视为相对于 $j_0$ 的常数。为了求得 $\\frac{\\partial j}{\\partial j_{0}}$，我们必须使用隐式微分法。\n\n我们对方程 (1) 关于 $j_{0}$ 求导。对右侧应用乘法法则，我们得到：\n$$\n\\frac{\\partial j}{\\partial j_{0}} = \\frac{\\partial}{\\partial j_{0}} \\left( j_{0} \\right) \\left[\\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right] + j_{0} \\frac{\\partial}{\\partial j_{0}} \\left[\\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right]\n$$\n第一项可以简化。通过从方程 (1) 中识别出方括号中的项等于 $j/j_0$，我们得到：\n$$\n\\frac{\\partial j}{\\partial j_{0}} = 1 \\cdot \\frac{j}{j_{0}} + j_{0} \\frac{\\partial}{\\partial j_{0}} \\left[\\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right]\n$$\n现在，我们对第二项应用链式法则，因为 $\\eta$ 是 $j_{0}$ 的函数：\n$$\n\\frac{\\partial j}{\\partial j_{0}} = \\frac{j}{j_{0}} + j_{0} \\left[ \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) \\cdot \\frac{\\alpha_{a} F}{R T} \\frac{\\partial \\eta}{\\partial j_{0}} - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right) \\cdot \\left(-\\frac{\\alpha_{c} F}{R T}\\right) \\frac{\\partial \\eta}{\\partial j_{0}} \\right]\n$$\n提取公因式得到：\n$$\n\\frac{\\partial j}{\\partial j_{0}} = \\frac{j}{j_{0}} + j_{0} \\frac{F}{R T} \\left[ \\alpha_{a} \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) + \\alpha_{c} \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right) \\right] \\frac{\\partial \\eta}{\\partial j_{0}} \\quad (3)\n$$\n这个方程包含未知导数 $\\frac{\\partial \\eta}{\\partial j_{0}}$。我们通过对方程 (2) 关于 $j_{0}$ 求导来找到它：\n$$\n\\frac{\\partial \\eta}{\\partial j_{0}} = \\frac{\\partial}{\\partial j_{0}} (\\phi - U - A R_s j)\n$$\n因为 $\\phi$、$U$、$A$ 和 $R_s$ 相对于 $j_{0}$ 是常数，所以这简化为：\n$$\n\\frac{\\partial \\eta}{\\partial j_{0}} = -A R_s \\frac{\\partial j}{\\partial j_{0}} \\quad (4)\n$$\n现在，我们将方程 (4) 代入方程 (3)：\n$$\n\\frac{\\partial j}{\\partial j_{0}} = \\frac{j}{j_{0}} + j_{0} \\frac{F}{R T} \\left[ \\alpha_{a} \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) + \\alpha_{c} \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right) \\right] \\left( -A R_s \\frac{\\partial j}{\\partial j_{0}} \\right)\n$$\n我们现在可以求解 $\\frac{\\partial j}{\\partial j_{0}}$。让我们将所有包含 $\\frac{\\partial j}{\\partial j_{0}}$ 的项收集到一边：\n$$\n\\frac{\\partial j}{\\partial j_{0}} + A R_s j_{0} \\frac{F}{R T} \\left[ \\alpha_{a} \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) + \\alpha_{c} \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right) \\right] \\frac{\\partial j}{\\partial j_{0}} = \\frac{j}{j_{0}}\n$$\n提取 $\\frac{\\partial j}{\\partial j_{0}}$：\n$$\n\\frac{\\partial j}{\\partial j_{0}} \\left( 1 + A R_s j_{0} \\frac{F}{R T} \\left[ \\alpha_{a} \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) + \\alpha_{c} \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right) \\right] \\right) = \\frac{j}{j_{0}}\n$$\n分离出 $\\frac{\\partial j}{\\partial j_{0}}$ 得到：\n$$\n\\frac{\\partial j}{\\partial j_{0}} = \\frac{j/j_{0}}{1 + A R_s j_{0} \\frac{F}{R T} \\left[ \\alpha_{a} \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) + \\alpha_{c} \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right) \\right]}\n$$\n最后，我们将此结果代回到容量灵敏度的表达式 $\\frac{\\partial Q}{\\partial j_{0}} = A \\tau \\frac{\\partial j}{\\partial j_{0}}$ 中：\n$$\n\\frac{\\partial Q}{\\partial j_{0}} = \\frac{A \\tau (j/j_{0})}{1 + A R_s j_{0} \\frac{F}{R T} \\left[ \\alpha_{a} \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) + \\alpha_{c} \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right) \\right]}\n$$\n为了以指定变量的形式获得最终表达式，我们使用方程 (1) 中的定义替换分子中的项 $j/j_0$：\n$$\n\\frac{j}{j_{0}} = \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\n$$\n代入此式，得到灵敏度的最终闭式解析表达式：\n$$\n\\frac{\\partial Q}{\\partial j_{0}} = \\frac{A \\tau \\left[\\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right]}{1 + A R_s j_{0} \\frac{F}{R T} \\left[ \\alpha_{a} \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) + \\alpha_{c} \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right) \\right]}\n$$\n此表达式在工作点处求值，该工作点由对于给定的 $j_0$ 同时满足方程 (1) 和 (2) 的 $\\eta$ 和 $j$ 的特定值定义。该表达式正确地显示了对 $\\alpha_a$、$\\alpha_c$ 和 $\\eta$ 的显式依赖关系，并包含了串联电阻 $R_s$ 的影响。",
            "answer": "$$\n\\boxed{\\frac{A \\tau \\left[\\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right]}{1 + A R_{s} j_{0} \\frac{F}{R T} \\left[\\alpha_{a} \\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) + \\alpha_{c} \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right]}}\n$$"
        },
        {
            "introduction": "在真实的电池设计中，模型往往极其复杂，无法进行手动解析求导。此时，我们会采用伴随法（adjoint methods）等自动化技术来计算灵敏度。然而，我们如何确保这些复杂求解器给出的结果是准确的呢？本练习将探讨这一关键的“梯度检验”步骤，它是科学计算中验证与确认（V&V）不可或缺的一部分。您将学习设计一个稳健的方案，用以验证计算出的灵敏度，并在其中权衡数值精度与计算效率。",
            "id": "3948566",
            "problem": "一个伪二维 (P2D) 电化学模型将一个参数向量 $\\mathbf{p} \\in \\mathbb{R}^{n}$（包括固相扩散系数 $D_{s}$、反应速率常数 $k$、隔膜孔隙率 $\\varepsilon_{s}$ 和 SEI 膜厚度 $\\delta_{\\mathrm{SEI}}$ 等参数）映射到在预设电流曲线下于 $m$ 个时间点采样的端电压向量 $f(\\mathbf{p}) = \\mathbf{V}(\\mathbf{p}) \\in \\mathbb{R}^{m}$。一个自动化求解器使用伴随方法计算解析雅可比矩阵 $J(\\mathbf{p}) \\in \\mathbb{R}^{m \\times n}$，旨在将这些灵敏度用于设计优化和不确定性量化。该求解器使用 IEEE-754 双精度算术，机器精度为 $\\epsilon_{\\mathrm{mach}}$，其时间积分容差为绝对容差 $\\tau_{\\mathrm{abs}}$ 和相对容差 $\\tau_{\\mathrm{rel}}$。\n\n你的任务是选择一个科学上合理且稳健的方案，通过梯度检验来验证 $J(\\mathbf{p})$。该方案必须：\n\n- 基于光滑函数 $f$ 的第一性原理（假设 $f$ 在 $\\mathbf{p}$ 的邻域内是二阶连续可微的）。\n- 平衡泰勒近似带来的截断误差与浮点舍入误差。\n- 适用于向量值输出 $f(\\mathbf{p}) \\in \\mathbb{R}^{m}$ 和高维参数向量 $\\mathbf{p} \\in \\mathbb{R}^{n}$。\n- 指明如何为每个参数 $p_{i}$ 选择扰动大小 $h_{i}$。\n- 定义如何进行比较（包括使用方向导数与分量偏导数）。\n- 设定与求解器的数值特性相关联的明确接受容差和标准。\n\n从以下选项中选择最佳方案：\n\nA. 使用方向导数中心差分检验。对于 $k \\in \\{1,2,3,4,5\\}$，抽取随机单位向量 $\\mathbf{v}^{(k)} \\in \\mathbb{R}^{n}$，满足 $\\|\\mathbf{v}^{(k)}\\|_{2} = 1$。对每个 $\\mathbf{v}^{(k)}$，评估对称扰动并构建有限差分方向导数\n$$\n\\tilde{\\mathbf{d}}^{(k)}(h) = \\frac{f(\\mathbf{p} + h\\, \\mathbf{v}^{(k)}) - f(\\mathbf{p} - h\\, \\mathbf{v}^{(k)})}{2h},\n$$\n并与解析方向导数 $\\mathbf{d}^{(k)} = J(\\mathbf{p})\\, \\mathbf{v}^{(k)}$ 进行比較。选择与参数缩放的步长 $h_{i} = \\alpha\\,(1 + |p_{i}|)$，基础尺度为 $\\alpha = \\epsilon_{\\mathrm{mach}}^{1/3}$，并对每个方向使用 $h \\in \\{\\alpha, \\alpha/2, \\alpha/4\\}$ 进行三级细化。定义相对差异\n$$\ne_{\\mathrm{rel}}^{(k)}(h) = \\frac{\\left\\|\\mathbf{d}^{(k)} - \\tilde{\\mathbf{d}}^{(k)}(h)\\right\\|_{2}}{\\left\\|\\mathbf{d}^{(k)}\\right\\|_{2} + \\left\\|\\tilde{\\mathbf{d}}^{(k)}(h)\\right\\|_{2}},\n$$\n和绝对差异 $e_{\\mathrm{abs}}^{(k)}(h) = \\left\\|\\mathbf{d}^{(k)} - \\tilde{\\mathbf{d}}^{(k)}(h)\\right\\|_{2}$。接受条件要求，在 5 个方向中至少有 4 个满足 $e_{\\mathrm{rel}}^{(k)}(\\alpha) \\le 10^{-3}$，并且 $e_{\\mathrm{rel}}^{(k)}$ 在细化过程中近似呈二次方下降，即 $e_{\\mathrm{rel}}^{(k)}(\\alpha/2) \\in [e_{\\mathrm{rel}}^{(k)}(\\alpha)/8,\\, e_{\\mathrm{rel}}^{(k)}(\\alpha)/2]$ 且 $e_{\\mathrm{rel}}^{(k)}(\\alpha/4) \\in [e_{\\mathrm{rel}}^{(k)}(\\alpha)/32,\\, e_{\\mathrm{rel}}^{(k)}(\\alpha)/8]$。此外，还要求 $e_{\\mathrm{abs}}^{(k)}(\\alpha) \\le 10\\, \\tau_{\\mathrm{abs}}$。使用相同的求解器容差 $(\\tau_{\\mathrm{abs}}, \\tau_{\\mathrm{rel}})$ 和相同的时间网格执行所有模拟，以避免混淆离散化差异。\n\nB. 在坐标方向上使用单边前向差分。对每个参数 $p_{i}$，计算\n$$\n\\tilde{\\mathbf{g}}_{i} = \\frac{f(\\mathbf{p} + h\\, \\mathbf{e}_{i}) - f(\\mathbf{p})}{h}\n$$\n并对所有 $i$ 使用固定的 $h = 10^{-4}$，其中 $\\mathbf{e}_{i}$ 是 $\\mathbb{R}^{n}$ 中的第 $i$ 个标准基向量。使用最大范数差异\n$$\n\\max_{i} \\left\\|\\mathbf{j}_{i} - \\tilde{\\mathbf{g}}_{i}\\right\\|_{\\infty} \\le 10^{-9}\n$$\n将 $\\tilde{\\mathbf{g}}_{i}$ 与 $J(\\mathbf{p})$ 的解析列 $\\mathbf{j}_{i}$ 进行比较，作为接受标准。不按参数大小缩放 $h$，也不细化 $h$；将求解器容差固定为给定值。\n\nC. 使用单一方向的中心差分，不进行细化，并采用严格的相对阈值。抽取一个单位向量 $\\mathbf{v} \\in \\mathbb{R}^{n}$，设置 $h_{i} = \\sqrt{\\epsilon_{\\mathrm{mach}}}\\,(1 + |p_{i}|)$，并计算\n$$\n\\tilde{\\mathbf{d}}(h) = \\frac{f(\\mathbf{p} + h\\, \\mathbf{v}) - f(\\mathbf{p} - h\\, \\mathbf{v})}{2h}.\n$$\n如果\n$$\n\\frac{\\left\\|\\mathbf{d} - \\tilde{\\mathbf{d}}(h)\\right\\|_{\\infty}}{\\left\\|\\mathbf{d}\\right\\|_{2}} \\le 10^{-6},\n$$\n成立则接受，其中 $\\mathbf{d} = J(\\mathbf{p})\\, \\mathbf{v}$。不执行多步长 $h$ 的收敛性检查。\n\nD. 使用与机器精度平方根相关联的步长，通过穷舉的分量中心差分来比较整个雅可比矩阵。对每个 $i$，使用 $h_{i} = \\epsilon_{\\mathrm{mach}}^{1/2}\\,(1 + |p_{i}|)$ 计算\n$$\n\\tilde{\\mathbf{j}}_{i}(h) = \\frac{f(\\mathbf{p} + h_{i}\\, \\mathbf{e}_{i}) - f(\\mathbf{p} - h_{i}\\, \\mathbf{e}_{i})}{2h_{i}},\n$$\n并组装 $\\tilde{J}(h) = [\\tilde{\\mathbf{j}}_{1}(h)\\ \\cdots\\ \\tilde{\\mathbf{j}}_{n}(h)]$。如果弗罗贝尼乌斯范数差异满足\n$$\n\\frac{\\left\\|J(\\mathbf{p}) - \\tilde{J}(h)\\right\\|_{F}}{\\left\\|J(\\mathbf{p})\\right\\|_{F}} \\le 10^{-8},\n$$\n则接受，不进行多步长 $h$ 的细化，也不与 $(\\tau_{\\mathrm{abs}}, \\tau_{\\mathrm{rel}})$ 相关联。",
            "solution": "问题陈述是有效的。它提出了一个来自计算科学领域的真实场景——为一个复杂的基于物理的模型（电池的 P2D 模型）验证其解析计算的雅可比矩阵。该问题有科学依据、良定、客观，并提供了足够的信息来根据数值分析的既定原则评估各个选项。\n\n任务是为梯度检验选择最稳健且科学上最合理的方案。一个稳健的方案必须遵循从数值微分中的误差分析得出的几个核心原则。\n\n1.  **有限差分公式的选择**：对于一个二阶连续可微函数 $f$，泰勒展开表明，中心差分公式 $\\frac{f(\\mathbf{p}+h\\mathbf{v}) - f(\\mathbf{p}-h\\mathbf{v})}{2h}$ 近似方向导数 $\\nabla f(\\mathbf{p}) \\cdot \\mathbf{v}$，其截断误差为 $O(h^2)$ 阶。前向差分公式 $\\frac{f(\\mathbf{p}+h\\mathbf{v}) - f(\\mathbf{p})}{h}$ 有一个更大的截断误差，为 $O(h)$ 阶。因此，对于给定的步长 $h$，中心差分要精确得多，是首选方法。\n\n2.  **平衡截断误差和舍入误差**：有限差分近似的总误差是截断误差（随 $h$ 减小而减小）和舍入误差（由于灾难性抵消，随 $h$ 减小而增大）之和。评估 $f(\\mathbf{p}+\\delta\\mathbf{p}) - f(\\mathbf{p})$ 时的舍入误差约为 $\\epsilon_{\\mathrm{mach}} |f(\\mathbf{p})|$ 量级，其中 $\\epsilon_{\\mathrm{mach}}$ 是机器精度。中心差分的总误差约为 $Ah^2 + B\\frac{\\epsilon_{\\mathrm{mach}}}{h}$。对此关于 $h$ 进行最小化，可得最佳步长 $h_{\\mathrm{opt}} \\propto \\epsilon_{\\mathrm{mach}}^{1/3}$。此时可达到的最小误差约为 $O(\\epsilon_{\\mathrm{mach}}^{2/3})$ 量级。对于前向差分，误差为 $Ah + B\\frac{\\epsilon_{\\mathrm{mach}}}{h}$，得出 $h_{\\mathrm{opt}} \\propto \\epsilon_{\\mathrm{mach}}^{1/2}$，最小误差为 $O(\\epsilon_{\\mathrm{mach}}^{1/2})$ 量级。对于双精度，$\\epsilon_{\\mathrm{mach}} \\approx 2.2 \\times 10^{-16}$，因此中心差分对应的 $h_{\\mathrm{opt}} \\sim 10^{-5}$ 和误差 $\\sim 10^{-11}$，而前向差分对应的 $h_{\\mathrm{opt}} \\sim 10^{-8}$ 和误差 $\\sim 10^{-8}$。\n\n3.  **高维度性**：对于高维参数空间 $\\mathbf{p} \\in \\mathbb{R}^{n}$，通过分量有限差分来评估其 $n$ 个列以计算完整的雅可比矩阵 $J(\\mathbf{p})$，需要 $2n$ 次（中心差分）或 $n$ 次（前向差分）函数求值。这在计算上可能是不可行的。一种更高效的策略是“雅可比-向量积检验”或方向导数检验。这包括将解析计算的乘积 $J(\\mathbf{p})\\mathbf{v}$ 与 $f$ 沿向量 $\\mathbf{v}$ 的方向导数的有限差分近似进行比较。通过选择几个随机方向 $\\mathbf{v}$，只需少量函数求值（中心差分为每个方向 2 次），就可以对整个雅可比矩阵 $J(\\mathbf{p})$ 的正确性获得高度置信。\n\n4.  **稳健性与验证**：一个可靠的方案不应依赖于单一的固定步长。它应该验证预期的理论收敛率。通过为一系列递减的步长（例如 $h, h/2, h/4$）计算有限差分，可以检查误差是否呈二次方下降（$E(h/2) \\approx E(h)/4$），从而确认计算处于截断误差主导的区域，并且函数足够光滑。\n\n5.  **对求解器的实际考量**：函数 $f(\\mathbf{p})$ 不是一个精确的数学函数，而是带有自身误差控制（如绝对容差 $\\tau_{\\mathrm{abs}}$ 和相对容差 $\\tau_{\\mathrm{rel}}$）的数值求解器的输出。来自求解器的这种数值噪声有效地为函数求值的精度设定了一个下限。任何梯度检验方案都必须认识到，有限差分近似的可达到精度受此噪声限制。因此，接受容差应该相对于求解器容差进行实事求是地设置（例如，必须比 $\\tau_{\\mathrm{abs}}$ 和 $\\tau_{\\mathrm{rel}}$ 更宽松），并且應控制非確定性來源（如自適應網格）。\n\n牢记这些原则，我们来评估各个选项：\n\n**A. 使用方向导数中心差分检验...**\n该方案设计得非常好，并符合稳健梯度检验的所有原则。\n-   它使用了更优的中心差分公式。\n-   它通过检验 5 个随机方向导数来高效地处理高维问题。\n-   它使用了最佳的基础步长缩放 $\\alpha = \\epsilon_{\\mathrm{mach}}^{1/3}$，这正确地平衡了中心差分的截斷誤差和捨入誤差。文本中关于标量步长 $h$ 和分量缩放 $h_i$ 的轻微歧义是一个小的表述弱点，但 $\\alpha$ 的核心选择是正确的。\n-   它执行了多级细化（$h, h/2, h/4$），并包含了对收敛率的定量检查，确保误差近似呈二次方下降。\n-   它使用了稳健的相对和绝对误差度量进行比较。\n-   关键的是，它将绝对接受容差与求解器的容差相关联（$e_{\\mathrm{abs}}^{(k)}(\\alpha) \\le 10\\, \\tau_{\\mathrm{abs}}$），并强制要求使用相同的时间网格来控制数值噪声。\n\n该选项描述了一个最先进的验证方案。\n**结论：正确**\n\n**B. 在坐标方向上使用单边前向差分...**\n该方案存在根本性缺陷。\n-   它使用了精度较低的前向差分（$O(h)$）方法。\n-   它对于高维问题效率低下，需要 $n$ 次函数求值。\n-   步长是一个固定的、任意的值 $h=10^{-4}$，没有按参数大小进行缩放，并且远非前向差分的最佳值 $h_{\\mathrm{opt}} \\sim \\epsilon_{\\mathrm{mach}}^{1/2} \\approx 10^{-8}$。这个选择保证了测试由截断误差主导。\n-   对于 $h=10^{-4}$ 的 $O(h)$ 方法，其接受容差 $10^{-9}$ 是不可能达到的，因为仅截断误差就在 $10^{-4}$ 量级。\n-   它没有包含细化检查，也没有考虑求解器容差。\n\n该方案是幼稚且内部不一致的。\n**结论：不正确**\n\n**C. 使用单一方向的中心差分，不进行细化...**\n该方案比 B 有所改进，但仍然薄弱且不够稳健。\n-   它正确地使用了中心差分法和方向导数方法。\n-   然而，对于中心差分计算，它使用了次优的步长 $h \\propto \\epsilon_{\\mathrm{mach}}^{1/2}$。这个步长太小，会将计算推入舍入误差主导的区域。最佳选择是 $\\epsilon_{\\mathrm{mach}}^{1/3}$。`h_i = ...` 的表述也与 `f(p + h v)` 相矛盾。\n-   它通过只检查一个方向且不进行细化来验证收敛率，因而缺乏稳健性。\n-   其接受标准与底层求解器的精度无关。\n\n该方案缺乏可靠验证所必需的制衡与检查。\n**结论：不正确**\n\n**D. 通过穷举的分量中心差分比较整个雅可比矩阵...**\n该方案很全面，但对于问题背景不合适，且缺乏关键的稳健性特性。\n-   它的主要缺陷是“穷举”和“分量式”，这对于问题设置中提到的“高维参数向量”不具可扩展性。这违反了一个关键要求。\n-   与选项 C 一样，它对中心差分法使用了次优的步长缩放 $h_{i} \\propto \\epsilon_{\\mathrm{mach}}^{1/2}$。\n-   它缺乏多步长细化来验证二次收敛率。\n-   对于 $h \\sim 10^{-8}$ 的步长，其 $10^{-8}$ 的接受容差非常严格，没有为求解器噪声留出余地。\n-   它未能将容差与求解器的特性 $(\\tau_{\\mathrm{abs}}, \\tau_{\\mathrm{rel}})$ 联系起来。\n\n该方案对于所述问题类别来说计算效率低下且缺乏稳健性。\n**结论：不正确**\n\n总之，选项 A是唯一一个为验证雅可比矩阵提供了全面、理论上合理且实践中稳健的方案。它正确地应用了数值分析的原理来平衡准确性和效率，并且恰当地考虑了使用数值求解器工作的现实情况。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "到目前为止，我们的焦点一直集中在局部灵敏度上，它仅在参数围绕一个名义点发生微小变化时有效。然而，在设计优化和不确定性量化中，参数通常会在很宽的范围内变化。最后的这个练习将我们的视角转向全局灵敏度分析（GSA），它旨在评估参数在其整个分布范围内的影响。您将亲手实现应用广泛的Sobol方法，为一个热模型计算总效应指数，并学习如何根据参数的整体重要性对其进行排序，从而为设计决策提供指导。",
            "id": "3948598",
            "problem": "您的任务是实现一个简化电池热管理模型的蒙特卡洛全局灵敏度分析，并根据参数的总 Sobol 指数对其进行排序。背景是自动化电池设计与仿真；目标是量化在固定时间范围内，冷却边界条件和内部热源如何影响最高电芯温度。\n\n假设一个具有恒定内部产热的单一热集总电池单元。该电池单元通过与周围环境的对流进行冷却。从积分能量平衡和牛顿冷却定律出发，采用集总电容模型，其中电池单元的温度根据以下公式演变：\n$$\nm c_p \\frac{d T(t)}{dt} = q - h A \\left(T(t) - T_{\\text{amb}}\\right),\n$$\n其中 $m$ 是质量，$c_p$ 是比热容，$q$ 是总内部产热率，$h$ 是对流传热系数，$A$ 是有效冷却面积，$T_{\\text{amb}}$ 是环境温度。假设初始条件为 $T(0) = T_{\\text{amb}}$ 且 $q$ 恒定，求解在时间 $t = \\tau$ 时的绝对温度，以定义热管理有效性指标：\n$$\nf(h, q, T_{\\text{amb}}, A) = T(\\tau) = T_{\\text{amb}} + \\frac{q}{h A}\\left(1 - e^{- \\frac{h A}{m c_p} \\tau}\\right).\n$$\n所有物理单位应按如下方式一致处理：$m$ 单位为 $\\mathrm{kg}$，$c_p$ 单位为 $\\mathrm{J}\\cdot\\mathrm{kg}^{-1}\\cdot\\mathrm{K}^{-1}$，$q$ 单位为 $\\mathrm{W}$，$h$ 单位为 $\\mathrm{W}\\cdot\\mathrm{m}^{-2}\\cdot\\mathrm{K}^{-1}$，$A$ 单位为 $\\mathrm{m}^2$，$T_{\\text{amb}}$ 单位为 $\\mathrm{K}$，$\\tau$ 单位为 $\\mathrm{s}$。程序输出不会直接报告温度；相反，它将提供参数排序。尽管如此，模型必须在内部以 $\\mathrm{K}$ 为单位计算 $f$。\n\n使用基于方差的 Sobol 方法执行全局灵敏度分析。令不确定性输入向量为：\n$$\n\\mathbf{X} = \\left(h, q, T_{\\text{amb}}, A\\right) \\in \\mathbb{R}^4,\n$$\n其分量在指定范围内服从独立的均匀分布。对于参数 $i$ 的总 Sobol 指数（记为 $S_{T_i}$），使用 Jansen 估计器。抽取两个独立的蒙特卡洛样本矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$，形状为 $N \\times d$（其中 $d = 4$），每个列从其参数范围内独立且均匀地采样。对于每个参数 $i \\in \\{0,1,2,3\\}$，构造混合矩阵 $\\mathbf{A}_{B}^{(i)}$，其所有列来自 $\\mathbf{B}$，但第 $i$ 列必须来自 $\\mathbf{A}$。在 $\\mathbf{A}$ 和每个 $\\mathbf{A}_{B}^{(i)}$ 上评估模型 $f$，以获得向量 $Y_{\\mathbf{A}}$ 和 $Y_{\\mathbf{A}_{B}^{(i)}}$。使用以下公式估计输出方差：\n$$\n\\operatorname{Var}(Y) \\approx \\frac{1}{N} \\sum_{j=1}^{N} Y_{\\mathbf{A},j}^2 - \\left(\\frac{1}{N} \\sum_{j=1}^{N} Y_{\\mathbf{A},j}\\right)^2,\n$$\n并使用以下公式估计总 Sobol 指数：\n$$\nS_{T_i} \\approx \\frac{1}{2 N \\operatorname{Var}(Y)} \\sum_{j=1}^{N} \\left(Y_{\\mathbf{A},j} - Y_{\\mathbf{A}_{B}^{(i)},j}\\right)^2.\n$$\n如果 $\\operatorname{Var}(Y) = 0$，则定义所有 $S_{T_i} = 0$。\n\n您的程序必须：\n- 实现指定的模型 $f$。\n- 实现指定的 Jansen 总效应估计器。\n- 对每个测试用例，在定义的范围内使用伪随机均匀采样。\n- 对每个测试用例，按总 Sobol 指数的降序对参数进行排序。若出现平局，必须按参数索引的升序打破。\n\n参数索引必须严格如下：\n- $i = 0$ 对应于 $h$，单位为 $\\mathrm{W}\\cdot\\mathrm{m}^{-2}\\cdot\\mathrm{K}^{-1}$。\n- $i = 1$ 对应于 $q$，单位为 $\\mathrm{W}$。\n- $i = 2$ 对应于 $T_{\\text{amb}}$，单位为 $\\mathrm{K}$。\n- $i = 3$ 对应于 $A$，单位为 $\\mathrm{m}^2$。\n\n对所有测试用例使用以下常数：\n- $m = 0.5$，单位为 $\\mathrm{kg}$。\n- $c_p = 900$，单位为 $\\mathrm{J}\\cdot\\mathrm{kg}^{-1}\\cdot\\mathrm{K}^{-1}$。\n- $\\tau = 600$，单位为 $\\mathrm{s}$。\n\n测试套件：\n- 案例 1（一般情况）：$N = 4096$，种子 $= 2025$，参数范围 $h \\in [10, 100]$，$q \\in [1, 20]$，$T_{\\text{amb}} \\in [293, 313]$，$A \\in [0.01, 0.05]$。\n- 案例 2（小样本边界）：$N = 128$，种子 $= 2026$，参数范围 $h \\in [10, 100]$，$q \\in [1, 20]$，$T_{\\text{amb}} \\in [293, 313]$，$A \\in [0.01, 0.05]$。\n- 案例 3（内部热量可忽略的边缘情况）：$N = 2048$，种子 $= 2027$，参数范围 $h \\in [5, 150]$，$q \\in [0, 0.1]$，$T_{\\text{amb}} \\in [293, 313]$，$A \\in [0.01, 0.05]$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素都是一个整数列表，代表该测试用例中按总 Sobol 指数降序排列的参数索引。例如，生成以下形式的输出：\n$$\n[\\,[i_{1,1}, i_{1,2}, i_{1,3}, i_{1,4}],\\,[i_{2,1}, i_{2,2}, i_{2,3}, i_{2,4}],\\,[i_{3,1}, i_{3,2}, i_{3,3}, i_{3,4}]\\,],\n$$\n其中 $[i_{k,1}, i_{k,2}, i_{k,3}, i_{k,4}]$ 是案例 $k \\in \\{1,2,3\\}$ 的排序结果。",
            "solution": "用户希望对一个简化的电池热模型执行全局灵敏度分析。\n\n### 步骤 1：提取已知条件\n\n*   **模型方程：** 热集总电池单元的温度 $T(t)$ 根据常微分方程 $m c_p \\frac{d T(t)}{dt} = q - h A \\left(T(t) - T_{\\text{amb}}\\right)$ 演变。\n*   **初始条件：** $T(0) = T_{\\text{amb}}$。\n*   **模型输出函数：** 在时间 $t=\\tau$ 时的解由 $f(h, q, T_{\\text{amb}}, A) = T(\\tau) = T_{\\text{amb}} + \\frac{q}{h A}\\left(1 - e^{- \\frac{h A}{m c_p} \\tau}\\right)$ 给出。\n*   **输入参数（不确定性）：** $\\mathbf{X} = \\left(h, q, T_{\\text{amb}}, A\\right)$，其中 $h$（对流传热系数，索引 0），$q$（内部产热率，索引 1），$T_{\\text{amb}}$（环境温度，索引 2），和 $A$（有效冷却面积，索引 3）。这些参数被假定在给定范围内是独立且均匀分布的。\n*   **固定常数：** $m = 0.5 \\, \\mathrm{kg}$，$c_p = 900 \\, \\mathrm{J}\\cdot\\mathrm{kg}^{-1}\\cdot\\mathrm{K}^{-1}$，$\\tau = 600 \\, \\mathrm{s}$。\n*   **灵敏度分析方法：** 基于方差的 Sobol 方法，用于计算总灵敏度指数 $S_{T_i}$。\n*   **估计器：** Jansen 估计器。\n*   **采样：** 两个独立的蒙特卡洛样本矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$，形状为 $N \\times d$（其中 $d=4$）。\n*   **混合矩阵构造：** 对于每个参数 $i$，矩阵 $\\mathbf{A}_{B}^{(i)}$ 的构造方式为：取矩阵 $\\mathbf{B}$ 的所有列，但第 $i$ 列取自矩阵 $\\mathbf{A}$。\n*   **方差估计：** $\\operatorname{Var}(Y) \\approx \\frac{1}{N} \\sum_{j=1}^{N} Y_{\\mathbf{A},j}^2 - \\left(\\frac{1}{N} \\sum_{j=1}^{N} Y_{\\mathbf{A},j}\\right)^2$，其中 $Y_{\\mathbf{A}}$ 是在矩阵 $\\mathbf{A}$ 上评估的模型输出向量。\n*   **总 Sobol 指数估计：** $S_{T_i} \\approx \\frac{1}{2 N \\operatorname{Var}(Y)} \\sum_{j=1}^{N} \\left(Y_{\\mathbf{A},j} - Y_{\\mathbf{A}_{B}^{(i)},j}\\right)^2$。如果 $\\operatorname{Var}(Y)=0$，则 $S_{T_i}=0$。\n*   **排序规则：** 参数按其总 Sobol 指数 $S_{T_i}$ 的降序排列。平局由参数索引（0, 1, 2, 3）的升序打破。\n*   **测试用例：**\n    1.  $N = 4096$，种子 $= 2025$，范围：$h \\in [10, 100]$，$q \\in [1, 20]$，$T_{\\text{amb}} \\in [293, 313]$，$A \\in [0.01, 0.05]$。\n    2.  $N = 128$，种子 $= 2026$，范围：$h \\in [10, 100]$，$q \\in [1, 20]$，$T_{\\text{amb}} \\in [293, 313]$，$A \\in [0.01, 0.05]$。\n    3.  $N = 2048$，种子 $= 2027$，范围：$h \\in [5, 150]$，$q \\in [0, 0.1]$，$T_{\\text{amb}} \\in [293, 313]$，$A \\in [0.01, 0.05]$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n*   **科学依据：** 该问题具有科学合理性。它采用了集总电容模型，这是热工学中对于低毕渥数（Biot number）物体的标准且恰当的简化。控制常微分方程及其解析解是正确的。使用 Jansen 估计器的 Sobol 方法是一种成熟且严谨的全局灵敏度分析技术。所有物理常数和参数范围都是符合实际的。\n*   **良构性：** 该问题是良构的。它提供了唯一的模型函数、一个明确定义的灵敏度指数计算算法、所有必要的常数、每个输入的特定参数范围以及用于可复现性的随机种子。平局打破规则确保了排序的唯一性。\n*   **客观性：** 问题以精确、客观和量化的方式陈述，没有模糊之处或主观论断。\n\n### 步骤 3：结论与行动\n\n该问题是**有效的**。可以通过忠实地实现指定的模型和数值方法来构建解决方案。\n\n### 基于原则的解决方案设计\n\n该解决方案的实现遵循了规定的蒙特卡洛模拟和基于方差的灵敏度分析的原则。\n\n1.  **模型实现：** 分析的核心是模型函数 $f(h, q, T_{\\text{amb}}, A)$。此函数通过使用 `numpy` 进行矢量化计算来实现数值效率，使其能够同时为 $N$ 个输入样本的整个矩阵评估模型。该函数为给定的输入向量 $h, q, T_{\\text{amb}}, A$ 计算 $T(\\tau) = T_{\\text{amb}} + \\frac{q}{h A}\\left(1 - e^{- \\frac{h A \\tau}{m c_p}}\\right)$。\n\n2.  **蒙特卡洛采样：** 对每个测试用例，程序首先为保证可复现性，设置指定的伪随机数生成器种子。生成两个独立的样本矩阵 $\\mathbf{A}$ 和 $\\mathbf{B}$。每个矩阵有 $N$ 行和 $d=4$ 列。每一列对应四个输入参数之一（$h, q, T_{\\text{amb}}, A$），其值从由参数指定范围定义的独立均匀分布中抽取。\n\n3.  **Jansen 总 Sobol 指数估计器：** 总 Sobol 指数 $S_{T_i}$ 量化了输入参数 $X_i$ 对输出方差的总贡献，包括其与其他所有参数的所有交互作用。我们按规定实现 Jansen 估计器：\n    *   首先，对矩阵 $\\mathbf{A}$ 中的所有样本点评估模型，得到输出向量 $Y_{\\mathbf{A}}$。\n    *   根据 $Y_{\\mathbf{A}}$，使用提供的公式估计输出的总方差 $\\operatorname{Var}(Y)$，该公式等价于有偏样本方差。设置一个检查来处理 $\\operatorname{Var}(Y)=0$ 的情况。\n    *   然后，对每个参数 $i \\in \\{0, 1, 2, 3\\}$，构造一个“混合”矩阵 $\\mathbf{A}_{B}^{(i)}$。遵循问题的明确指示，该矩阵包含矩阵 $\\mathbf{B}$ 的所有列，但第 $i$ 列取自矩阵 $\\mathbf{A}$。\n    *   在此混合矩阵上评估模型，以产生输出向量 $Y_{\\mathbf{A}_{B}^{(i)}}$。\n    *   然后使用提供的公式计算总 Sobol 指数 $S_{T_i}$：$S_{T_i} \\approx \\frac{\\sum_{j=1}^{N} \\left(Y_{\\mathbf{A},j} - Y_{\\mathbf{A}_{B}^{(i)},j}\\right)^2}{2 N \\operatorname{Var}(Y)}$。该公式量化了当仅第 $i$ 个参数的值在两个不同样本间变化，而所有其他参数也在变化时，输出平均变化的程度。\n\n4.  **参数排序：** 计算出四个总 Sobol 指数（$S_{T_0}, S_{T_1}, S_{T_2}, S_{T_3}$）后，对相应的参数索引（$0, 1, 2, 3$）进行排序。主要排序标准是 $S_{T_i}$ 值的降序。次要标准用于打破任何平局，即参数索引 $i$ 的升序。这通过基于元组键 `(-S_Ti, i)` 对索引进行排序来实现。\n\n5.  **执行与格式化：** 整个过程被封装在一个函数中，该函数迭代三个指定的测试用例。对于每个用例，它执行采样、估计和排序，并存储得到的排序索引列表。最后，将所有案例的结果格式化为单个字符串，表示一个不含空格的整数列表的列表，以符合所要求的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs global sensitivity analysis on a battery thermal model and ranks\n    parameters based on their total Sobol indices for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, seed, parameter_ranges)\n    test_cases = [\n        # Case 1 (general case)\n        (4096, 2025, [(10, 100), (1, 20), (293, 313), (0.01, 0.05)]),\n        # Case 2 (small-sample boundary)\n        (128, 2026, [(10, 100), (1, 20), (293, 313), (0.01, 0.05)]),\n        # Case 3 (edge case with negligible internal heat)\n        (2048, 2027, [(5, 150), (0, 0.1), (293, 313), (0.01, 0.05)]),\n    ]\n\n    # Global constants for the model\n    m = 0.5  # kg\n    cp = 900.0  # J/kg/K\n    tau = 600.0  # s\n    d = 4  # Number of parameters\n\n    def model_f(h, q, T_amb, A):\n        \"\"\"\n        Calculates the battery cell temperature at time tau.\n        This is a vectorized implementation using numpy.\n        \n        Args:\n            h (np.ndarray): Convective heat transfer coefficient vector.\n            q (np.ndarray): Internal heat generation rate vector.\n            T_amb (np.ndarray): Ambient temperature vector.\n            A (np.ndarray): Cooling area vector.\n\n        Returns:\n            np.ndarray: Final temperature T(tau) vector.\n        \"\"\"\n        # To prevent division by zero, although problem ranges make it impossible\n        hA = h * A\n        # The term is set to a large number to ensure the result is T_amb when hA is zero.\n        # This is a safe guard not strictly needed for the given parameter ranges.\n        safe_hA = np.where(hA == 0, 1e12, hA)\n        \n        term1 = q / safe_hA\n        exponent = -safe_hA * tau / (m * cp)\n        exp_term = np.exp(exponent)\n        \n        return T_amb + term1 * (1 - exp_term)\n\n    def analyze_case(N, seed, param_ranges):\n        \"\"\"\n        Performs the sensitivity analysis for a single case.\n        \"\"\"\n        np.random.seed(seed)\n        \n        # Generate two independent N x d sample matrices, A and B\n        A_matrix = np.zeros((N, d))\n        B_matrix = np.zeros((N, d))\n        \n        for i in range(d):\n            low, high = param_ranges[i]\n            A_matrix[:, i] = np.random.uniform(low, high, size=N)\n            B_matrix[:, i] = np.random.uniform(low, high, size=N)\n            \n        # Evaluate the model on matrix A\n        Y_A = model_f(A_matrix[:, 0], A_matrix[:, 1], A_matrix[:, 2], A_matrix[:, 3])\n        \n        # Estimate the variance of the output Y based on Y_A samples\n        # Var(Y) = E[Y^2] - (E[Y])^2\n        var_Y = np.mean(Y_A**2) - (np.mean(Y_A))**2\n\n        total_sobol_indices = []\n\n        if var_Y == 0:\n            # If variance is zero, all sensitivities are zero.\n            # Ranking follows the tie-breaking rule (ascending index).\n            return list(range(d))\n\n        # Calculate total Sobol index for each parameter\n        for i in range(d):\n            # Construct the mixed matrix A_B^(i) as per the problem description:\n            # \"all columns from B except the i-th, which must come from A\"\n            A_B_i = B_matrix.copy()\n            A_B_i[:, i] = A_matrix[:, i]\n            \n            # Evaluate the model on the mixed matrix\n            Y_A_B_i = model_f(A_B_i[:, 0], A_B_i[:, 1], A_B_i[:, 2], A_B_i[:, 3])\n            \n            # Estimate the total Sobol index using the Jansen estimator formula\n            # S_Ti = (1 / (2*N)) * sum((Y_A - Y_A_B_i)^2) / Var(Y)\n            numerator = np.sum((Y_A - Y_A_B_i)**2)\n            S_Ti = numerator / (2 * N * var_Y)\n            total_sobol_indices.append(S_Ti)\n\n        # Rank parameters by descending Sobol index, breaking ties with ascending index\n        param_indices = list(range(d))\n        ranked_indices = sorted(param_indices, key=lambda idx: (-total_sobol_indices[idx], idx))\n        \n        return ranked_indices\n\n    results = []\n    for case in test_cases:\n        N_val, seed_val, ranges_val = case\n        ranking = analyze_case(N_val, seed_val, ranges_val)\n        results.append(ranking)\n\n    # Format the final output string to match [[i1,i2,..],[i1,i2,..]] with no spaces.\n    inner_strs = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output = f\"[{','.join(inner_strs)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}