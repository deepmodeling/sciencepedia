{
    "hands_on_practices": [
        {
            "introduction": "在数据驱动的科学发现中，算法可能会提出许多数学上看似合理但物理上荒谬的候选方程。本练习将指导您构建一个自动化的量纲一致性检验器 。这是确保模型物理意义的第一道防线，通过编程方式实施量纲分析的基本原理，以过滤掉不符合物理定律的方程结构。",
            "id": "3904049",
            "problem": "您的任务是构建一个单位一致性检查器，用于验证在自动化电池设计与仿真中通过数据驱动方法发现的候选控制方程。目标是确保方程右侧的每个加法项都与左侧的量纲相匹配，并且满足所有特殊函数约束。您的程序必须是一个单一、完整、可运行的脚本，并以指定格式生成单行输出。\n\n基本依据。该检查器必须基于以下基本原理进行操作，这些原理仅限于普遍接受的定律和定义：\n- 基于国际单位制 (SI) 的七个基本量纲进行的量纲分析，在本情景中简化为实际需要的六个：质量 $M$ (千克, $kg$)、长度 $L$ (米, $m$)、时间 $T$ (秒, $s$)、电流 $I$ (安培, $A$)、热力学温度 $\\Theta$ (开尔文, $K$) 和物质的量 $N$ (摩尔, $mol$)。\n- 算子量纲：\n  - 空间梯度 $\\nabla$ 贡献一个因子 $L^{-1}$。\n  - 空间散度 $\\nabla \\cdot$ 贡献一个因子 $L^{-1}$。\n  - 空间拉普拉斯算子 $\\nabla^{2}$ 贡献一个因子 $L^{-2}$。\n  - 时间导数 $\\partial/\\partial t$ 贡献一个因子 $T^{-1}$。\n- 特殊函数约束：\n  - 指数函数 $\\exp(\\cdot)$ 和自然对数 $\\log(\\cdot)$ 要求其参数为无量纲。\n  - 绝对值 $|\\cdot|$ 保持量纲不变。\n  - 范数的平方 $|\\cdot|^{2}$ 将量纲指数乘以2。\n  - 允许将有量纲的量进行实数次幂运算；量纲指数将乘以该幂次。\n\n变量和参数的量纲赋值。对常见电池模型中的物理量使用以下一致且有科学依据的单位：\n- 电解质浓度 $c$：$N L^{-3}$ ($mol \\, m^{-3}$)。\n- 电势 $\\phi$：$M L^{2} T^{-3} I^{-1}$ ($V$)。\n- 电流密度 $i$：$I L^{-2}$ ($A \\, m^{-2}$)。\n- 扩散系数 $D$：$L^{2} T^{-1}$ ($m^{2} \\, s^{-1}$)。\n- 反应速率 (摩尔通量) $j$：$N L^{-2} T^{-1}$ ($mol \\, m^{-2} \\, s^{-1}$)。\n- 法拉第常数 $F$：$I T N^{-1}$ ($C \\, mol^{-1}$)。\n- 比界面面积 $a$：$L^{-1}$ ($m^{2} \\, m^{-3}$)。\n- 电解质电导率 $\\kappa$：$M^{-1} L^{-3} T^{3} I^{2}$ ($S \\, m^{-1}$)。\n- 固体电导率 $\\sigma$：$M^{-1} L^{-3} T^{3} I^{2}$ ($S \\, m^{-1}$)。\n- 热导率 $k$：$M L T^{-3} \\Theta^{-1}$ ($W \\, m^{-1} \\, K^{-1}$)。\n- 质量密度 $\\rho$：$M L^{-3}$ ($kg \\, m^{-3}$)。\n- 比热容 $c_{p}$：$L^{2} T^{-2} \\Theta^{-1}$ ($J \\, kg^{-1} \\, K^{-1}$)。\n- 温度 $T$：$\\Theta$ ($K$)。\n- 普适气体常数 $R$：$M L^{2} T^{-2} N^{-1} \\Theta^{-1}$ ($J \\, mol^{-1} \\, K^{-1}$)。\n- 活化能 $E_{a}$：$M L^{2} T^{-2} N^{-1}$ ($J \\, mol^{-1}$)。\n- 无量纲孔隙率 $\\varepsilon$：无量纲 $M^{0} L^{0} T^{0} I^{0} \\Theta^{0} N^{0}$。\n- 一级表面反应速率常数 $k_{0}$：$L T^{-1}$ ($m \\, s^{-1}$)。\n\n量纲组合规则。您必须实现关于 $(M, L, T, I, \\Theta, N)$ 指数的代数运算：\n- 乘法将指数向量相加。\n- 除法将指数向量相减。\n- 加法要求所有加数具有相同的指数向量；结果也具有该指数向量。\n- 时间导数乘以 $T^{-1}$；空间梯度乘以 $L^{-1}$；空间散度乘以 $L^{-1}$；空间拉普拉斯算子乘以 $L^{-2}$。\n- 指数函数和对数函数要求输入为无量纲，并产生无量纲输出。\n\n程序目标。您的程序必须：\n- 编码一个支持变量、常量及上述算子的小型表达式代数系统。\n- 对每个候选方程，独立计算左侧和右侧每一项的量纲。\n- 返回一个布尔值，指示是否所有右侧项的量纲都与左侧匹配，并且所有特殊函数约束都得到满足。\n\n物理单位和数值。此问题纯粹是关于量纲的；不要求任何数值。布尔值是无单位的，并应以编程语言术语中的 $true$ 或 $false$ 值的形式返回。\n\n测试套件。检查以下九个案例，每个案例都以一个方程的形式给出，包含一个左侧项和一个或多个右侧项。对于每个案例，如果根据上述规则方程在量纲上是一致的，则返回 $true$，否则返回 $false$。\n\n- 案例 $1$ (物种扩散，一致):\n  - 左侧: $\\dfrac{\\partial c}{\\partial t}$。\n  - 右侧项: $D \\, \\nabla^{2} c$。\n\n- 案例 $2$ (物种扩散，不一致的额外项):\n  - 左侧: $\\dfrac{\\partial c}{\\partial t}$。\n  - 右侧项: $D \\, \\nabla^{2} c$, $\\kappa \\, \\nabla^{2} \\phi$。\n\n- 案例 $3$ (电解质电荷守恒，一致):\n  - 左侧: $\\nabla \\cdot i$。\n  - 右侧项: $a \\, F \\, j$。\n\n- 案例 $4$ (电解质电荷守恒，不一致（缺少比界面面积）):\n  - 左侧: $\\nabla \\cdot i$。\n  - 右侧项: $F \\, j$。\n\n- 案例 $5$ (带有焦耳热的能量平衡，一致):\n  - 左侧: $\\rho \\, c_{p} \\, \\dfrac{\\partial T}{\\partial t}$。\n  - 右侧项: $k \\, \\nabla^{2} T$, $\\sigma \\, \\left| \\nabla \\phi \\right|^{2}$。\n\n- 案例 $6$ (能量平衡，焦耳热项形式不一致):\n  - 左侧: $\\rho \\, c_{p} \\, \\dfrac{\\partial T}{\\partial t}$。\n  - 右侧项: $k \\, \\nabla^{2} T$, $\\sigma \\, \\nabla \\phi$。\n\n- 案例 $7$ (阿伦尼乌斯型表面反应速率，一致):\n  - 左侧: $j$。\n  - 右侧项: $k_{0} \\, \\exp\\!\\left( - \\dfrac{E_{a}}{R \\, T} \\right) \\, c$。\n\n- 案例 $8$ (阿伦尼乌斯型表面反应速率，指数参数不一致):\n  - 左侧: $j$。\n  - 右侧项: $k_{0} \\, \\exp\\!\\left( - \\dfrac{E_{a}}{T} \\right) \\, c$。\n\n- 案例 $9$ (无量纲乘数保持一致性):\n  - 左侧: $\\dfrac{\\partial c}{\\partial t}$。\n  - 右侧项: $\\varepsilon \\, \\dfrac{\\partial c}{\\partial t}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述顺序列出九个案例的结果（例如，$[true,false,true,\\dots]$）。在 Python 中，请使用内置的布尔字面量且不改变大小写，因此输出应类似于 $[True,False,True,\\dots]$。",
            "solution": "在物理学和工程学中，验证候选控制方程的量纲一致性是一个基本步骤，它确保数学模型遵守量纲齐次性原则。该原则指出，一个方程只有在其所有加法项都具有相同的物理量纲时，才具有物理意义。解决方案涉及实现一个计算框架，以根据一套针对物理量和数学算子的预定义规则自动执行此验证。\n\n该方法的核心是将任何物理量的量纲表示为一个指数向量，这些指数对应于一组基本量纲。对于此问题，六个基本量纲是质量 ($M$)、长度 ($L$)、时间 ($T$)、电流 ($I$)、热力学温度 ($\\Theta$) 和物质的量 ($N$)。因此，任何量纲都可以用一个6元素实数向量 $[d_M, d_L, d_T, d_I, d_\\Theta, d_N]$ 来表示。例如，电解质浓度 $c$ 的单位是 $mol \\, m^{-3}$，量纲为 $N L^{-3}$，其表示向量为 $[0, -3, 0, 0, 0, 1]$。一个无量纲量的指数向量为 $[0, 0, 0, 0, 0, 0]$。\n\n量纲分析的代数运算随后被映射到向量运算：\n1.  **乘法**：当两个量相乘 ($A \\cdot B$) 时，它们的量纲向量相加。如果 $\\dim(A) = \\vec{v}_A$ 且 $\\dim(B) = \\vec{v}_B$，则 $\\dim(A \\cdot B) = \\vec{v}_A + \\vec{v}_B$。\n2.  **除法**：当一个量除以另一个量 ($A / B$) 时，它们的量纲向量相减：$\\dim(A / B) = \\vec{v}_A - \\vec{v}_B$。\n3.  **幂运算**：将一个量取 $p$ 次幂 ($A^p$) 会将其量纲向量乘以 $p$：$\\dim(A^p) = p \\cdot \\vec{v}_A$。\n4.  **加法/减法**：对于要相加或相减的项 ($A + B$)，它们必须是量纲齐次的，即 $\\dim(A) = \\dim(B)$。结果具有相同的量纲。\n5.  **算子**：微分算子也对量纲有贡献。时间导数 $\\partial/\\partial t$ 引入 $T^{-1}$ 的量纲（向量 $[0, 0, -1, 0, 0, 0]$），而像梯度 ($\\nabla$) 或散度 ($\\nabla \\cdot$) 这样的空间算子引入 $L^{-1}$ 的量纲（向量 $[0, -1, 0, 0, 0, 0]$）。拉普拉斯算子 ($\\nabla^2$) 引入 $L^{-2}$ 的量纲（向量 $[0, -2, 0, 0, 0, 0]$）。\n6.  **特殊函数**：像 $\\exp(\\cdot)$ 和 $\\log(\\cdot)$ 这样的超越函数仅对无量纲参数有定义。函数本身及其参数都必须是无量纲的。\n\n为了验证形如 $LHS = T_1 + T_2 + \\dots + T_n$ 的方程，我们执行以下步骤：\n1.  计算左侧 (LHS) 的量纲向量 $\\vec{d}_{LHS}$。\n2.  对右侧的每一项 $T_i$，计算其量纲向量 $\\vec{d}_{T_i}$。在此计算过程中，必须验证所有关于特殊函数参数的约束。如果发现任何参数（例如 $\\exp$ 函数的参数）是有量纲的，则立即宣布整个方程无效。\n3.  将右侧每一项的量纲向量与左侧的向量进行比较。当且仅当 $\\vec{d}_{LHS} = \\vec{d}_{T_1} = \\vec{d}_{T_2} = \\dots = \\vec{d}_{T_n}$ 且所有特殊函数约束都满足时，方程才有效。\n\n让我们用两个测试案例来说明：\n\n**案例 1 (一致): $\\dfrac{\\partial c}{\\partial t} = D \\, \\nabla^{2} c$**\n- 变量的量纲: $\\dim(c) = N L^{-3} \\implies [0, -3, 0, 0, 0, 1]$, $\\dim(D) = L^{2} T^{-1} \\implies [0, 2, -1, 0, 0, 0]$。\n- 算子的量纲: $\\dim(\\partial/\\partial t) = T^{-1} \\implies [0, 0, -1, 0, 0, 0]$, $\\dim(\\nabla^2) = L^{-2} \\implies [0, -2, 0, 0, 0, 0]$。\n- 左侧 (LHS): $\\dim(\\frac{\\partial c}{\\partial t}) = \\dim(c) + \\dim(\\frac{\\partial}{\\partial t}) = [0, -3, 0, 0, 0, 1] + [0, 0, -1, 0, 0, 0] = [0, -3, -1, 0, 0, 1]$。\n- 右侧 (RHS): $\\dim(D \\nabla^2 c) = \\dim(D) + \\dim(\\nabla^2) + \\dim(c) = [0, 2, -1, 0, 0, 0] + [0, -2, 0, 0, 0, 0] + [0, -3, 0, 0, 0, 1] = [0, -3, -1, 0, 0, 1]$。\n- 由于 $\\dim(LHS) = \\dim(RHS)$，该方程量纲一致 ($True$)。\n\n**案例 8 (不一致): $j = k_{0} \\, \\exp\\!\\left( - \\dfrac{E_{a}}{T} \\right) \\, c$**\n- 此方程涉及一个特殊函数 $\\exp(\\cdot)$，其参数必须是无量纲的。\n- 变量的量纲: $\\dim(E_a) = M L^2 T^{-2} N^{-1} \\implies [1, 2, -2, 0, 0, -1]$, $\\dim(T_{temp}) = \\Theta \\implies [0, 0, 0, 0, 1, 0]$。\n- $\\exp$ 的参数: $\\dim(\\frac{E_a}{T_{temp}}) = \\dim(E_a) - \\dim(T_{temp}) = [1, 2, -2, 0, 0, -1] - [0, 0, 0, 0, 1, 0] = [1, 2, -2, 0, -1, -1]$。\n- 结果向量不是零向量 $[0, 0, 0, 0, 0, 0]$，因此参数不是无量纲的。\n- 指数函数的约束被违反。因此，该方程量纲无效 ($False$)，无需进行进一步检查。\n\n对所有九个测试案例都实施了这一系统性过程，以生成最终的布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the dimensional analysis problem by defining a checker class,\n    running through the test cases, and printing the results.\n    \"\"\"\n\n    class DimensionalityChecker:\n        \"\"\"\n        A class to perform dimensional analysis on physical equations.\n        It represents dimensions as 6D vectors (M, L, T, I, Theta, N)\n        and checks for consistency based on predefined rules.\n        \"\"\"\n        def __init__(self):\n            # Base dimensions are represented by a 6-element numpy array corresponding\n            # to the exponents of Mass, Length, Time, Current, Temperature, and Moles.\n            # M, L, T, I, Theta, N\n            self.dims = {\n                'c':      np.array([0, -3,  0,  0,  0,  1]), # N L^-3\n                'phi':    np.array([1,  2, -3, -1,  0,  0]), # M L^2 T^-3 I^-1\n                'i':      np.array([0, -2,  0,  1,  0,  0]), # I L^-2\n                'D':      np.array([0,  2, -1,  0,  0,  0]), # L^2 T^-1\n                'j':      np.array([0, -2, -1,  0,  0,  1]), # N L^-2 T^-1\n                'F':      np.array([0,  0,  1,  1,  0, -1]), # I T N^-1\n                'a':      np.array([0, -1,  0,  0,  0,  0]), # L^-1\n                'kappa':  np.array([-1,-3,  3,  2,  0,  0]), # M^-1 L^-3 T^3 I^2\n                'sigma':  np.array([-1,-3,  3,  2,  0,  0]), # M^-1 L^-3 T^3 I^2\n                'k':      np.array([1,  1, -3,  0, -1,  0]), # M L T^-3 Theta^-1\n                'rho':    np.array([1, -3,  0,  0,  0,  0]), # M L^-3\n                'cp':     np.array([0,  2, -2,  0, -1,  0]), # L^2 T^-2 Theta^-1\n                'T_':     np.array([0,  0,  0,  0,  1,  0]), # Theta (Temp)\n                'R':      np.array([1,  2, -2,  0, -1, -1]), # M L^2 T^-2 N^-1 Theta^-1\n                'Ea':     np.array([1,  2, -2,  0,  0, -1]), # M L^2 T^-2 N^-1\n                'eps':    np.array([0,  0,  0,  0,  0,  0]), # dimensionless\n                'k0':     np.array([0,  1, -1,  0,  0,  0]), # L T^-1\n            }\n            self.op_dims = {\n                'dt':        np.array([0,  0, -1,  0,  0,  0]), # T^-1\n                'grad_div':  np.array([0, -1,  0,  0,  0,  0]), # L^-1\n                'laplacian': np.array([0, -2,  0,  0,  0,  0]), # L^-2\n            }\n            self.DIMENSIONLESS = np.array([0, 0, 0, 0, 0, 0])\n\n        def get_dim(self, key):\n            \"\"\"Returns a copy of the dimensional vector for a variable or operator.\"\"\"\n            if key in self.dims:\n                return self.dims[key].copy()\n            return self.op_dims[key].copy()\n\n        def is_dimensionless(self, dim_vector):\n            \"\"\"Checks if a dimensional vector corresponds to a dimensionless quantity.\"\"\"\n            return np.array_equal(dim_vector, self.DIMENSIONLESS)\n\n        def check_equation(self, lhs_calc, rhs_calcs):\n            \"\"\"\n            Checks a single equation for dimensional consistency.\n\n            Args:\n                lhs_calc (callable): A function that computes the LHS dimensions.\n                rhs_calcs (list[callable]): A list of functions for each RHS term.\n\n            Returns:\n                bool: True if the equation is consistent, False otherwise.\n            \"\"\"\n            try:\n                lhs_dim = lhs_calc()\n                if lhs_dim is None: return False\n\n                for calc in rhs_calcs:\n                    rhs_dim = calc()\n                    if rhs_dim is None or not np.array_equal(lhs_dim, rhs_dim):\n                        return False\n                return True\n            except Exception:\n                return False\n\n    checker = DimensionalityChecker()\n    results = []\n\n    # Case 1: ∂c/∂t = D ∇²c\n    case1_lhs = lambda: checker.get_dim('c') + checker.get_dim('dt')\n    case1_rhs1 = lambda: checker.get_dim('D') + checker.get_dim('laplacian') + checker.get_dim('c')\n    results.append(checker.check_equation(case1_lhs, [case1_rhs1]))\n\n    # Case 2: ∂c/∂t = D ∇²c + κ ∇²ϕ\n    case2_rhs2 = lambda: checker.get_dim('kappa') + checker.get_dim('laplacian') + checker.get_dim('phi')\n    results.append(checker.check_equation(case1_lhs, [case1_rhs1, case2_rhs2]))\n\n    # Case 3: ∇⋅i = a F j\n    case3_lhs = lambda: checker.get_dim('grad_div') + checker.get_dim('i')\n    case3_rhs1 = lambda: checker.get_dim('a') + checker.get_dim('F') + checker.get_dim('j')\n    results.append(checker.check_equation(case3_lhs, [case3_rhs1]))\n\n    # Case 4: ∇⋅i = F j\n    case4_rhs1 = lambda: checker.get_dim('F') + checker.get_dim('j')\n    results.append(checker.check_equation(case3_lhs, [case4_rhs1]))\n\n    # Case 5: ρ cp ∂T/∂t = k ∇²T + σ |∇ϕ|²\n    case5_lhs = lambda: checker.get_dim('rho') + checker.get_dim('cp') + checker.get_dim('dt') + checker.get_dim('T_')\n    case5_rhs1 = lambda: checker.get_dim('k') + checker.get_dim('laplacian') + checker.get_dim('T_')\n    def case5_rhs2():\n        grad_phi_dim = checker.get_dim('grad_div') + checker.get_dim('phi')\n        norm_sq_grad_phi_dim = grad_phi_dim * 2\n        return checker.get_dim('sigma') + norm_sq_grad_phi_dim\n    results.append(checker.check_equation(case5_lhs, [case5_rhs1, case5_rhs2]))\n\n    # Case 6: ρ cp ∂T/∂t = k ∇²T + σ ∇ϕ\n    case6_rhs2 = lambda: checker.get_dim('sigma') + checker.get_dim('grad_div') + checker.get_dim('phi')\n    results.append(checker.check_equation(case5_lhs, [case5_rhs1, case6_rhs2]))\n\n    # Case 7: j = k₀ exp(-Eₐ/(RT)) c\n    case7_lhs = lambda: checker.get_dim('j')\n    def case7_rhs1():\n        exp_arg_dim = checker.get_dim('Ea') - (checker.get_dim('R') + checker.get_dim('T_'))\n        if not checker.is_dimensionless(exp_arg_dim):\n            return None  # Invalid operation\n        return checker.get_dim('k0') + checker.DIMENSIONLESS + checker.get_dim('c')\n    results.append(checker.check_equation(case7_lhs, [case7_rhs1]))\n\n    # Case 8: j = k₀ exp(-Eₐ/T) c\n    def case8_rhs1():\n        exp_arg_dim = checker.get_dim('Ea') - checker.get_dim('T_')\n        if not checker.is_dimensionless(exp_arg_dim):\n            return None  # Invalid operation\n        return checker.get_dim('k0') + checker.DIMENSIONLESS + checker.get_dim('c')\n    results.append(checker.check_equation(case7_lhs, [case8_rhs1]))\n\n    # Case 9: ∂c/∂t = ε ∂c/∂t\n    case9_rhs1 = lambda: checker.get_dim('eps') + checker.get_dim('dt') + checker.get_dim('c')\n    results.append(checker.check_equation(case1_lhs, [case9_rhs1]))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个量纲正确的模型仍然可能违反更深层次的物理定律。本练习探讨如何将热力学第二定律这一基本约束施加到数据驱动模型上 。您将学习如何通过分析和修正线性耦合模型的系数矩阵，确保其预测的熵产生始终为非负，从而使模型与物理现实保持一致。",
            "id": "3904045",
            "problem": "考虑一个可充电电池内部的等温、一维、均匀电解质域，其中离子电流密度和电解质电势梯度是共线的。用 $i_e$ 表示电解质离子电流密度的大小（单位为 $\\mathrm{A/m^2}$），用 $g$ 表示电解质电势梯度 $g = \\partial_x \\phi_e$ 的大小（单位为 $\\mathrm{V/m}$），用 $j$ 表示界面反应电流密度的大小（单位为 $\\mathrm{A/m^2}$），用 $\\eta$ 表示过电势的大小（单位为 $\\mathrm{V}$），用 $T$ 表示绝对温度（单位为 $\\mathrm{K}$）。在非平衡态热力学中，局部体积熵产生密度定义为\n$$\n\\sigma = \\frac{i_e \\, g}{T} + \\frac{j \\, \\eta}{T},\n$$\n单位为 $\\mathrm{W/(m^3\\cdot K)}$。热力学第二定律要求对于所有物理上允许的状态，$\\sigma \\ge 0$。\n\n一个数据驱动发现的线性模型通过一个 $2 \\times 2$ 的系数矩阵 $L$ 将流和力关联起来：\n$$\n\\begin{bmatrix}\ni_e \\\\\nj\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nL_{11} & L_{12} \\\\\nL_{21} & L_{22}\n\\end{bmatrix}\n\\begin{bmatrix}\ng \\\\\n\\eta\n\\end{bmatrix}.\n$$\n热力学第二定律施加了熵产生必须为非负的约束。在线性不可逆热力学中，对于任意 $T>0$ 和所有 $[g,\\eta]^T$，熵产生非负的充分必要条件是 $L$ 的对称部分 $S = (L + L^\\top)/2$ 是半正定的。如果发现的 $L$ 违反了此约束，必须对其进行最小程度的调整以强制满足热力学第二定律，同时保持其线性结构。\n\n您的任务是实现一个程序，该程序为每个提供的测试用例执行以下步骤：\n1. 计算对称部分 $S = (L + L^\\top)/2$。\n2. 对于给定的采样状态集 $(g,\\eta)$ 和温度 $T$，计算熵产生值\n$$\n\\sigma_k = \\frac{1}{T} \\begin{bmatrix} g_k & \\eta_k \\end{bmatrix} S \\begin{bmatrix} g_k \\\\ \\eta_k \\end{bmatrix}\n$$\n对于每个样本索引 $k$，并确定是否所有 $\\sigma_k$ 均为非负。报告所有样本中 $\\sigma_k$ 的最小值。所有熵产生值必须以 $\\mathrm{W/(m^3\\cdot K)}$ 为单位表示。\n3. 通过将 $S$ 投影到对称半正定矩阵锥上来调整系数，以强制满足热力学第二定律。这通过特征值分解 $S = U \\Lambda U^\\top$ 并将任何负特征值 $\\lambda_i$ 替换为 $0$ 来实现，从而得到 $\\tilde{S} = U \\tilde{\\Lambda} U^\\top$，其中 $\\tilde{\\Lambda} = \\mathrm{diag}(\\max(\\lambda_1,0),\\max(\\lambda_2,0))$。将校正后的系数矩阵 $\\tilde{L}$ 设置为 $\\tilde{S}$。\n4. 使用 $\\tilde{S}$ 为相同的样本和温度重新计算熵产生值，确定是否所有校正后的值均为非负，并报告校正后的最小值。同时，以列表形式按行主序输出 $\\tilde{L}$ 的条目。\n\n测试套件：\n- 测试用例 A（理想情况，对称正定）：$L = \\begin{bmatrix} 5.0 & 0.5 \\\\ 0.5 & 2.0 \\end{bmatrix}$，$T = 298\\,\\mathrm{K}$，样本 $(g,\\eta)$ 为 $\\{(0.0,0.0),(10.0,0.02),(100.0,0.1),(50.0,-0.05)\\}$。\n- 测试用例 B（不定，非对称）：$L = \\begin{bmatrix} -1.0 & 4.0 \\\\ 0.2 & -0.5 \\end{bmatrix}$，$T = 300\\,\\mathrm{K}$，样本 $(g,\\eta)$ 为 $\\{(20.0,0.2),(50.0,-0.1),(100.0,0.0),(0.0,0.5)\\}$。\n- 测试用例 C（接近边界，对称且有一个小的负特征值）：$L = \\begin{bmatrix} 10^{-3} & -2\\cdot 10^{-3} \\\\ -2\\cdot 10^{-3} & 10^{-3} \\end{bmatrix}$，$T = 350\\,\\mathrm{K}$，样本 $(g,\\eta)$ 为 $\\{(1000.0,0.5),(100.0,-0.5),(0.0,1.0)\\}$。\n- 测试用例 D（强非对角，非对称）：$L = \\begin{bmatrix} 0.5 & 4.5 \\\\ -4.0 & 0.1 \\end{bmatrix}$，$T = 1000\\,\\mathrm{K}$，样本 $(g,\\eta)$ 为 $\\{(200.0,0.2),(400.0,-0.3),(1.0,10.0)\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个列表，形式如下：\n$$\n[\\text{initial\\_nonnegativity}, \\ \\min(\\sigma)\\ \\text{in}\\ \\mathrm{W/(m^3\\cdot K)}, \\ \\text{corrected\\_nonnegativity}, \\ \\min(\\tilde{\\sigma})\\ \\text{in}\\ \\mathrm{W/(m^3\\cdot K)}, \\ \\text{flattened}\\ \\tilde{L}]\n$$\n其中包含布尔值和浮点数，分别对应测试用例 A、B、C 和 D。例如，输出应如下所示：\n$$\n[[\\dots],[\\dots],[\\dots],[\\dots]]\n$$\n不含任何附加文本。所有浮点数中，熵产生最小值的单位为 $\\mathrm{W/(m^3\\cdot K)}$，$\\tilde{L}$ 的条目是如上文所定义的、关联流与力的量纲一致的系数。",
            "solution": "该问题要求对一个用于电池电解质中耦合离子输运和反应动力学的数据驱动线性模型进行分析和校正，以确保其符合热力学第二定律。核心原则是局部体积熵产生密度 $\\sigma$ 对于任何物理上允许的状态都必须是非负的。\n\n起点是给定的熵产生定义：\n$$\n\\sigma = \\frac{i_e \\, g}{T} + \\frac{j \\, \\eta}{T}\n$$\n其中 $i_e$ 是离子电流密度，$g$ 是电势梯度，$j$ 是反应电流密度，$\\eta$ 是过电势，$T$ 是绝对温度。数对 $(i_e, j)$ 代表热力学流，而 $(g, \\eta)$ 代表相应的力（相差一个因子 $1/T$）。\n\n提出的线性本构关系是：\n$$\n\\begin{bmatrix}\ni_e \\\\\nj\n\\end{bmatrix}\n=\nL\n\\begin{bmatrix}\ng \\\\\n\\eta\n\\end{bmatrix}\n$$\n其中 $L$ 是一个 $2 \\times 2$ 的唯象系数矩阵。将此关系代入 $\\sigma$ 的表达式，得到一个二次型。设状态向量为 $\\mathbf{x} = [g, \\eta]^T$。则流向量为 $\\mathbf{J} = [i_e, j]^T = L\\mathbf{x}$。熵产生可以用矩阵表示法写为：\n$$\n\\sigma = \\frac{1}{T} \\mathbf{J}^T \\mathbf{x} = \\frac{1}{T} (L\\mathbf{x})^T \\mathbf{x} = \\frac{1}{T} \\mathbf{x}^T L^T \\mathbf{x}\n$$\n这个表达式不直接方便。一个等价且更标准的形式是：\n$$\n\\sigma = \\frac{1}{T} \\mathbf{x}^T \\mathbf{J} = \\frac{1}{T} \\mathbf{x}^T L \\mathbf{x}\n$$\n二次型 $\\mathbf{x}^T M \\mathbf{x}$ 的值仅取决于矩阵 $M$ 的对称部分，因为 $\\mathbf{x}^T M \\mathbf{x} = \\mathbf{x}^T \\left(\\frac{M+M^T}{2}\\right) \\mathbf{x}$。设 $S$ 为系数矩阵 $L$ 的对称部分，定义为 $S = (L + L^T)/2$。则熵产生由下式给出：\n$$\n\\sigma = \\frac{1}{T} \\mathbf{x}^T S \\mathbf{x} = \\frac{1}{T} \\begin{bmatrix} g & \\eta \\end{bmatrix} S \\begin{bmatrix} g \\\\ \\eta \\end{bmatrix}\n$$\n热力学第二定律要求对于所有可能的状态向量 $\\mathbf{x} = [g, \\eta]^T$，$\\sigma \\ge 0$。由于 $T > 0$，这等价于二次型 $\\mathbf{x}^T S \\mathbf{x}$ 对所有 $\\mathbf{x}$ 均为非负的条件。这就是矩阵 $S$ 是半正定的定义。\n\n对于每个测试用例，程序如下：\n\n1.  **计算对称部分**：给定发现的矩阵 $L$，我们首先计算其对称部分 $S = (L + L^T)/2$。\n\n2.  **评估初始熵产生**：对于给定的温度 $T$ 和包含 $N$ 个样本状态的集合 $\\{\\mathbf{x}_k\\}_{k=1}^N$，其中 $\\mathbf{x}_k = [g_k, \\eta_k]^T$，我们为每个样本计算熵产生：\n    $$\n    \\sigma_k = \\frac{1}{T} \\mathbf{x}_k^T S \\mathbf{x}_k\n    $$\n    然后我们检查是否所有 $\\sigma_k \\ge 0$。这决定了 `initial_nonnegativity` 布尔值。我们还找出所有计算出的 $\\sigma_k$ 中的最小值。需要注意的是，即使 $S$ 不是半正定的，在一个有限的样本集中，所有的 $\\sigma_k$ 仍可能为非负。然而，这并不能保证对于所有可能的状态都符合热力学第二定律。\n\n3.  **通过投影强制满足热力学第二定律**：为确保对于所有状态 $\\sigma \\ge 0$，我们必须将 $S$ 修改为半正定矩阵。一种标准方法是将 $S$ 投影到对称半正定矩阵锥上。这通过特征值分解实现。由于 $S$ 是对称的，它可以分解为：\n    $$\n    S = U \\Lambda U^T\n    $$\n    其中 $U$ 是一个正交矩阵，其列是 $S$ 的特征向量，$\\Lambda = \\mathrm{diag}(\\lambda_1, \\lambda_2)$ 是一个由相应实特征值组成的对角矩阵。\n    一个矩阵是半正定的，当且仅当其所有特征值都是非负的。如果 $S$ 有任何负特征值，它就不是半正定的。我们通过将所有负特征值替换为零来构造与 $S$ 最接近的半正定矩阵（在弗罗贝尼乌斯范数意义下）。我们形成一个新的对角矩阵 $\\tilde{\\Lambda}$，其中：\n    $$\n    \\tilde{\\Lambda} = \\mathrm{diag}(\\max(\\lambda_1, 0), \\max(\\lambda_2, 0))\n    $$\n    然后重构校正后的对称矩阵 $\\tilde{S}$：\n    $$\n    \\tilde{S} = U \\tilde{\\Lambda} U^T\n    $$\n    问题规定，校正后的系数矩阵 $\\tilde{L}$ 被设置为这个新的对称半正定矩阵，即 $\\tilde{L} = \\tilde{S}$。这个新矩阵 $\\tilde{L}$ 保证了对所有状态的熵产生均为非负。\n\n4.  **评估校正后的熵产生**：使用校正后的矩阵 $\\tilde{S}$，我们为同一组样本重新计算熵产生值：\n    $$\n    \\tilde{\\sigma}_k = \\frac{1}{T} \\mathbf{x}_k^T \\tilde{S} \\mathbf{x}_k\n    $$\n    通过构造，$\\tilde{S}$ 是半正定的，因此可以保证所有 $\\tilde{\\sigma}_k \\ge 0$。我们报告 `corrected_nonnegativity`（这将始终为真）和 $\\tilde{\\sigma}_k$ 的最小值。最后，将得到的矩阵 $\\tilde{L} = \\tilde{S}$ 的元素展开为一个列表以供输出。此过程系统地应用于所有提供的测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates a data-driven battery model against the Second Law of Thermodynamics,\n    corrects the model if necessary, and reports the results.\n    \"\"\"\n\n    test_cases = [\n        # Case A (happy path, symmetric positive definite)\n        {\n            \"L\": np.array([[5.0, 0.5], [0.5, 2.0]]),\n            \"T\": 298.0,\n            \"samples\": np.array([[0.0, 0.0], [10.0, 0.02], [100.0, 0.1], [50.0, -0.05]]),\n        },\n        # Case B (indefinite, non-symmetric)\n        {\n            \"L\": np.array([[-1.0, 4.0], [0.2, -0.5]]),\n            \"T\": 300.0,\n            \"samples\": np.array([[20.0, 0.2], [50.0, -0.1], [100.0, 0.0], [0.0, 0.5]]),\n        },\n        # Case C (near-boundary, symmetric with a small negative eigenvalue)\n        {\n            \"L\": np.array([[1e-3, -2e-3], [-2e-3, 1e-3]]),\n            \"T\": 350.0,\n            \"samples\": np.array([[1000.0, 0.5], [100.0, -0.5], [0.0, 1.0]]),\n        },\n        # Case D (strong off-diagonal, non-symmetric)\n        {\n            \"L\": np.array([[0.5, 4.5], [-4.0, 0.1]]),\n            \"T\": 1000.0,\n            \"samples\": np.array([[200.0, 0.2], [400.0, -0.3], [1.0, 10.0]]),\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L = case[\"L\"]\n        T = case[\"T\"]\n        samples = case[\"samples\"]\n\n        # Step 1: Compute the symmetric part S\n        S = (L + L.T) / 2.0\n\n        # Step 2: Compute initial entropy production\n        sigmas = []\n        for x in samples:\n            sigma = (x.T @ S @ x) / T\n            sigmas.append(sigma)\n        \n        min_sigma = min(sigmas) if sigmas else 0.0\n        initial_nonnegativity = all(s >= 0 for s in sigmas)\n\n        # Step 3: Adjust coefficients to enforce the Second Law\n        # Use np.linalg.eigh for symmetric matrices\n        eigenvalues, eigenvectors = np.linalg.eigh(S)\n        \n        # Clip negative eigenvalues to 0\n        corrected_eigenvalues = np.maximum(eigenvalues, 0)\n        \n        # Reconstruct the corrected symmetric positive semidefinite matrix S_tilde\n        Lambda_tilde = np.diag(corrected_eigenvalues)\n        S_tilde = eigenvectors @ Lambda_tilde @ eigenvectors.T\n        \n        # The corrected coefficient matrix L_tilde is set to S_tilde\n        L_tilde = S_tilde\n\n        # Step 4: Recompute entropy production with the corrected matrix\n        corrected_sigmas = []\n        for x in samples:\n            corrected_sigma = (x.T @ L_tilde @ x) / T\n            corrected_sigmas.append(corrected_sigma)\n\n        min_corrected_sigma = min(corrected_sigmas) if corrected_sigmas else 0.0\n        corrected_nonnegativity = all(s >= -1e-9 for s in corrected_sigmas) # Use tolerance for float precision\n        \n        flattened_L_tilde = list(L_tilde.flatten())\n\n        results.append([\n            initial_nonnegativity,\n            min_sigma,\n            corrected_nonnegativity,\n            min_corrected_sigma,\n            flattened_L_tilde,\n        ])\n\n    print(f\"{results}\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "最终，我们的目标是从数据中发现一个不仅物理上合理，而且其参数不确定性也得到量化的模型。本综合练习将引导您完成一个从生成含噪数据、发现控制性偏微分方程（PDE）系数，到使用自助法（bootstrapping）计算这些系数置信区间的完整工作流程 。这个过程将使您从简单的点估计，迈向更完整、更严谨的科学结论。",
            "id": "3904092",
            "problem": "您的任务是实现一个严谨的、数据驱动的流程，用于估计和量化多孔电极中均质化一维锂浓度场的控制偏微分方程（PDE）的系数不确定性，该流程适用于自动化电池设计与仿真。此任务的科学基础是物种质量守恒和 Fickian 扩散。具体来说，假设长度为 $L$ 的一维周期性域上的锂浓度场 $c(x,t)$ 服从质量守恒，其通量为 $J$，并带有一个线性体积反应汇：\n$$\\frac{\\partial c}{\\partial t} + \\frac{\\partial J}{\\partial x} = R,$$\n其中 Fickian 通量为 $J = -D \\frac{\\partial c}{\\partial x}$，线性反应为 $R = -k c$，$D$ 是扩散系数，$k$ 是一级反应速率常数。在这些假设下，控制 PDE 为\n$$\\frac{\\partial c}{\\partial t} = D \\frac{\\partial^2 c}{\\partial x^2} - k c.$$\n\n您将通过解析求解上述在周期性域上的 PDE 来生成合成的、物理上合理的数据，初始条件为正弦傅里叶模式的叠加。令\n$$c(x,0) = c_0 + A_1 \\sin\\left(\\frac{2\\pi x}{L}\\right) + A_2 \\sin\\left(\\frac{4\\pi x}{L}\\right),$$\n对于 $t \\ge 0$，其精确解为\n$$c(x,t) = c_0 e^{-k t} + A_1 \\exp\\left(-\\left[k + D\\left(\\frac{2\\pi}{L}\\right)^2\\right] t\\right) \\sin\\left(\\frac{2\\pi x}{L}\\right) + A_2 \\exp\\left(-\\left[k + D\\left(\\frac{4\\pi}{L}\\right)^2\\right] t\\right) \\sin\\left(\\frac{4\\pi x}{L}\\right)。$$\n\n为模拟测量噪声，在每个时空网格点上向 $c(x,t)$ 添加标准差为 $\\sigma$ 的独立的、零均值的高斯噪声。使用具有 $N_x$ 个点和间距 $\\Delta x = L/N_x$ 的均匀空间网格，以及具有 $N_t$ 个点和时间步长 $\\Delta t$ 的均匀时间采样。在逼近空间导数时，使用空间上的周期性边界条件。计算时间导数和二阶空间导数的离散近似值为\n$$c_t(x_i,t_j) \\approx \\frac{c(x_i,t_{j+1}) - c(x_i,t_j)}{\\Delta t}, \\quad c_{xx}(x_i,t_j) \\approx \\frac{c(x_{i-1},t_j) - 2 c(x_i,t_j) + c(x_{i+1},t_j)}{\\Delta x^2},$$\n其中由于周期性，空间索引在模 $N_x$ 的意义下解释。\n\n将发现候选库限制在两个函数 $\\{c_{xx},\\, c\\}$ 内，并执行以下形式的线性回归\n$$c_t = \\Theta \\, \\xi,$$\n其中 $\\Theta = [\\, c_{xx},\\; c\\,]$ 且 $\\xi = [\\, D,\\; -k\\,]^\\top$。使用普通最小二乘法估计 $\\hat{\\xi}$。\n\n为量化不确定性，通过有放回地重采样时空区块来执行非参数自助法（bootstrapping）。一个时空区块是 $(x,t)$ 网格上大小为 $p_x \\times p_t$ 的轴对齐子数组，通过连续的空间索引（具有周期性环绕）和连续的时间索引收集。对于每个自助法复制，有放回地采样 $M$ 个区块，将其展平的数据向量连接起来形成回归数据，估计 $\\hat{\\xi}^{(b)}$，并对 $B$ 个复制重复此过程。使用经验百分位法，基于相应估计值的自助法分布，为 $D$ 和 $k$ 构建双边 $95\\%$ 置信区间（CI）。报告基于全部 $M$ 个区块（非重采样）集合的点估计值。\n\n所有量必须以国际单位制（SI 单位）表示：报告 $D$ 的单位为 $\\mathrm{m^2/s}$，$k$ 的单位为 $\\mathrm{s^{-1}}$。不出现角度，也不需要角度单位。输出中不要使用百分比；将所有 CI 界限表示为浮点数。\n\n实现一个单一程序，该程序：\n- 生成合成数据集，\n- 构建离散导数近似，\n- 定义并采样时空区块，\n- 对区块执行自助法重采样，\n- 估计系数和 $95\\%$ 置信区间。\n\n使用以下测试套件。对于每个测试用例，您必须使用指定的参数。在所有情况下，使用 $c_0 = 1000$（单位 $\\mathrm{mol/m^3}$），$A_1 = 50$（单位 $\\mathrm{mol/m^3}$），以及 $A_2 = 30$（单位 $\\mathrm{mol/m^3}$），除非另有说明。空间域长度为 $L = 10^{-3}$（单位 $\\mathrm{m}$）。对于周期性，在空间上按模 $N_x$ 解释索引。\n\n- 测试用例 1（一般情况）：\n    - $D = 5 \\times 10^{-12}$，$k = 10^{-3}$，$L = 10^{-3}$，$N_x = 128$，$N_t = 120$，$\\Delta t = 0.5$，$\\sigma = 10^{-6}$，$p_x = 16$，$p_t = 20$，$M = 50$，$B = 200$。\n- 测试用例 2（无噪声边界）：\n    - $D = 5 \\times 10^{-12}$，$k = 10^{-3}$，$L = 10^{-3}$，$N_x = 128$，$N_t = 120$，$\\Delta t = 0.5$，$\\sigma = 0$，$p_x = 32$，$p_t = 30$，$M = 40$，$B = 150$。\n- 测试用例 3（更高反应速率和更高噪声）：\n    - $D = 5 \\times 10^{-12}$，$k = 2 \\times 10^{-3}$，$L = 10^{-3}$，$N_x = 96$，$N_t = 100$，$\\Delta t = 0.5$，$\\sigma = 5 \\times 10^{-6}$，$p_x = 12$，$p_t = 16$，$M = 60$，$B = 200$。\n- 测试用例 4（小数据集和较弱的扩散/反应）：\n    - $D = 10^{-12}$，$k = 5 \\times 10^{-4}$，$L = 10^{-3}$，$N_x = 64$，$N_t = 80$，$\\Delta t = 0.5$，$\\sigma = 10^{-6}$，$p_x = 8$，$p_t = 10$，$M = 12$，$B = 60$。\n\n您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果。每个测试用例必须产生一个包含六个浮点数的列表，顺序为\n$$[\\, \\hat{D},\\; \\hat{k},\\; D_{\\mathrm{low}},\\; D_{\\mathrm{high}},\\; k_{\\mathrm{low}},\\; k_{\\mathrm{high}}\\,],$$\n其中 $\\hat{D}$ 和 $\\hat{k}$ 是点估计值（单位为 $\\mathrm{m^2/s}$ 和 $\\mathrm{s^{-1}}$），而 $(D_{\\mathrm{low}}, D_{\\mathrm{high}})$ 和 $(k_{\\mathrm{low}}, k_{\\mathrm{high}})$ 分别是双边 $95\\%$ 置信区间的下限和上限。因此，最终输出必须是一个包含四个此类列表的列表，每个测试用例一个，例如\n$$[ [d_1,k_1,d_{1,\\ell},d_{1,u},k_{1,\\ell},k_{1,u}], [d_2,k_2,d_{2,\\ell},d_{2,u},k_{2,\\ell},k_{2,u}], [d_3,k_3,d_{3,\\ell},d_{3,u},k_{3,\\ell},k_{3,u}], [d_4,k_4,d_{4,\\ell},d_{4,u},k_{4,\\ell},k_{4,u}] ]。$$",
            "solution": "设计从物种质量守恒和 Fickian 扩散出发，并结合线性反应动力学。在一维中，守恒表达式为\n$$\\frac{\\partial c}{\\partial t} + \\frac{\\partial J}{\\partial x} = R,$$\n其中 $c(x,t)$ 是嵌入锂的浓度，$J(x,t)$ 是空间通量，$R(x,t)$ 是体积反应项。在 Fickian 扩散下，通量为 $J = -D \\frac{\\partial c}{\\partial x}$，其中 $D$ 是扩散系数。在偏离平衡不大的情况下，一级动力学将体积反应近似为 $R = -k c$，其中 $k$ 是一个速率常数。代入这些本构关系得到控制偏微分方程（PDE）\n$$\\frac{\\partial c}{\\partial t} = D \\frac{\\partial^2 c}{\\partial x^2} - k c.$$\n\n这个 PDE 是线性常系数的，并且在周期性边界条件下，它允许傅里叶模式解。如果初始条件是正弦模式的叠加，\n$$c(x,0) = c_0 + A_1 \\sin\\left(\\frac{2\\pi x}{L}\\right) + A_2 \\sin\\left(\\frac{4\\pi x}{L}\\right),$$\n那么每个傅里叶模式会独立衰减。零阶模式衰减为 $c_0 e^{-k t}$，而正弦模式衰减为\n$$A_n \\exp\\left(-\\left[k + D\\left(\\frac{2\\pi n}{L}\\right)^2\\right] t\\right) \\sin\\left(\\frac{2\\pi n x}{L}\\right),$$\n对于 $n \\in \\{1,2\\}$。因此，精确解为\n$$c(x,t) = c_0 e^{-k t} + A_1 \\exp\\left(-\\left[k + D\\left(\\frac{2\\pi}{L}\\right)^2\\right] t\\right) \\sin\\left(\\frac{2\\pi x}{L}\\right) + A_2 \\exp\\left(-\\left[k + D\\left(\\frac{4\\pi}{L}\\right)^2\\right] t\\right) \\sin\\left(\\frac{4\\pi x}{L}\\right)。$$\n\n为了模拟真实的数据采集，对 $c(x,t)$ 的每个时空样本添加了标准差为 $\\sigma$ 的独立零均值高斯噪声。使用具有 $N_x$ 个点和间距 $\\Delta x = L/N_x$ 的均匀空间网格及周期性索引对域进行离散化，并使用具有 $N_t$ 个点和时间步长 $\\Delta t$ 的均匀时间网格。使用有限差分，时间导数和二阶空间导数近似为\n$$c_t(x_i,t_j) \\approx \\frac{c(x_i,t_{j+1}) - c(x_i,t_j)}{\\Delta t},$$\n$$c_{xx}(x_i,t_j) \\approx \\frac{c(x_{i-1},t_j) - 2 c(x_i,t_j) + c(x_{i+1},t_j)}{\\Delta x^2},$$\n其中 $i \\in \\{0,1,\\dots,N_x-1\\}$ 和 $j \\in \\{0,1,\\dots,N_t-2\\}$，且由于周期性边界，空间索引按模 $N_x$ 计算。\n\n对于数据驱动的发现，我们将候选项库限制为 $\\{c_{xx},\\, c\\}$ 并假设一个线性回归关系\n$$c_t = \\Theta \\, \\xi,$$\n其中 $\\Theta = [\\, c_{xx},\\; c\\,]$ 且系数向量 $\\xi = [\\, \\xi_1,\\; \\xi_2\\,]^\\top$ 与物理量的映射关系为 $\\xi_1 = D$ 和 $\\xi_2 = -k$。普通最小二乘估计量通过最小化\n$$\\min_{\\xi} \\| \\Theta \\xi - y \\|_2^2,$$\n得到，其中 $y$ 表示 $c_t$ 样本的向量。解是 Moore–Penrose 最小二乘估计\n$$\\hat{\\xi} = (\\Theta^\\top \\Theta)^{-1} \\Theta^\\top y,$$\n假设 $\\Theta^\\top \\Theta$ 是非奇异的，对于足够多样化的区块，这通常是满足的。\n\n为了真实地建模空间和时间相关性并获得有效的不确定性量化，我们在时空区块的层面上应用非参数自助法。一个区块被定义为 $(x,t)$ 网格上大小为 $p_x \\times p_t$ 的轴对齐子数组，由连续的空间索引（具有周期性环绕）和连续的时间索引构成。对于每个自助法复制 $b \\in \\{1,2,\\dots,B\\}$，我们从可用区块集中有放回地采样 $M$ 个区块，将 $c_t$、$c_{xx}$ 和 $c$ 的展平区块数据连接起来，以组装回归矩阵 $\\Theta^{(b)}$ 和向量 $y^{(b)}$，并通过最小二乘法计算 $\\hat{\\xi}^{(b)}$。这将产生自助法样本 $\\{\\hat{\\xi}^{(b)}\\}_{b=1}^B$。使用经验百分位法， $D$ 的双边 $95\\%$ 置信区间（CI）是 $\\{ \\hat{\\xi}_1^{(b)} \\}$ 的第 $2.5$ 和第 $97.5$ 百分位数之间的区间，而 $k$ 的 CI 则类似地从 $\\{ -\\hat{\\xi}_2^{(b)} \\}$ 导出。点估计 $(\\hat{D}, \\hat{k})$ 是从完整的、未经重采样的 $M$ 个区块集合中计算出来的。\n\n每个测试用例的算法步骤如下：\n- 固定指定的 $D$、$k$、$L$、$N_x$、$N_t$、$\\Delta t$、$\\sigma$、$p_x$、$p_t$、$M$ 和 $B$。\n- 构建 $x_i = i \\Delta x$（对于 $i \\in \\{0,\\dots,N_x-1\\}$）和 $t_j = j \\Delta t$（对于 $j \\in \\{0,\\dots,N_t-1\\}$）。\n- 使用精确公式计算 $c(x_i,t_j)$，然后添加标准差为 $\\sigma$ 的独立高斯噪声。\n- 计算 $c_t(x_i,t_j)$（在 $j \\in \\{0,\\dots,N_t-2\\}$ 上）和 $c_{xx}(x_i,t_j)$（在相同时间索引上）的离散数组，并收集 $c(x_i,t_j)$（在 $j \\in \\{0,\\dots,N_t-2\\}$ 上）以与 $c_t$ 对齐。\n- 均匀随机采样 $M$ 个时空区块：选择空间起始索引 $s_x \\in \\{0,\\dots,N_x-1\\}$（具有周期性环绕）和时间起始索引 $s_t \\in \\{0,\\dots,N_t-2-p_t+1\\}$，提取 $p_x \\times p_t$ 的块，并将其展平。\n- 通过求解 $y = \\Theta \\xi$ 计算全数据最小二乘估计 $(\\hat{D}, \\hat{k})$，记住 $\\xi_2 = -k$。\n- 执行 $B$ 次自助法复制，通过有放回地重采样 $M$ 个区块，对每个复制求解最小二乘问题，并为 $D$ 和 $k$ 构建经验百分位 $95\\%$ CI。\n- 以 SI 单位返回 $[\\, \\hat{D},\\; \\hat{k},\\; D_{\\mathrm{low}},\\; D_{\\mathrm{high}},\\; k_{\\mathrm{low}},\\; k_{\\mathrm{high}}\\,]$。\n\n测试套件包括四个用例，它们共同探测算法在各种条件下的行为：一个具有中等噪声的通用“理想路径”情况，一个用于测试一致性的无噪声边界情况，一个具有更高反应速率和更高噪声以测试鲁棒性的情况，以及一个用于测试在有限数据下性能的小数据集情况。最终输出是包含四个结果列表的单行列表，按测试用例定义排序。不应打印任何额外文本。",
            "answer": "```python\nimport numpy as np\n\n# Set a global random seed for reproducibility\nnp.random.seed(123)\n\ndef generate_concentration(D, k, L, Nx, Nt, dt, c0=1000.0, A1=50.0, A2=30.0):\n    \"\"\"\n    Generate the exact solution c(x,t) for the diffusion-reaction PDE on a periodic domain,\n    using the specified initial condition composed of sine modes and a constant offset.\n    Returns an array C of shape (Nt, Nx).\n    \"\"\"\n    x = np.linspace(0.0, L, Nx, endpoint=False)  # spatial grid\n    t = dt * np.arange(Nt)                       # time grid\n\n    # Wavenumbers for the sine modes\n    k1 = 2.0 * np.pi / L\n    k2 = 4.0 * np.pi / L\n\n    # Mode decay rates\n    decay0 = np.exp(-k * t)  # zero mode\n    decay1 = np.exp(-(k + D * (k1 ** 2)) * t)\n    decay2 = np.exp(-(k + D * (k2 ** 2)) * t)\n\n    # Construct solution: broadcast over x\n    C = (\n        (c0 * decay0)[:, None]\n        + (A1 * decay1)[:, None] * np.sin(k1 * x)[None, :]\n        + (A2 * decay2)[:, None] * np.sin(k2 * x)[None, :]\n    )\n    return C\n\ndef add_noise(C, sigma):\n    \"\"\"\n    Add independent Gaussian noise with standard deviation sigma to the concentration data.\n    \"\"\"\n    if sigma == 0.0:\n        return C.copy()\n    noise = np.random.normal(loc=0.0, scale=sigma, size=C.shape)\n    return C + noise\n\ndef compute_derivatives(C, L, dt):\n    \"\"\"\n    Compute discrete time derivative c_t and second spatial derivative c_xx with periodic wrapping.\n    c_t is computed using forward differences over time.\n    c_xx is computed using central differences in space (periodic).\n    Returns (ct, cxx, c_slice) where ct and cxx have shape (Nt-1, Nx) and c_slice aligns with ct in time.\n    \"\"\"\n    Nt, Nx = C.shape\n    dx = L / Nx\n\n    # Time derivative using forward difference: shape (Nt-1, Nx)\n    ct = (C[1:, :] - C[:-1, :]) / dt\n\n    # Second spatial derivative at times 0..Nt-2 to align with ct\n    C_time = C[:-1, :]  # shape (Nt-1, Nx)\n    # Periodic roll for spatial neighbors\n    C_left = np.roll(C_time, shift=1, axis=1)\n    C_right = np.roll(C_time, shift=-1, axis=1)\n\n    cxx = (C_left - 2.0 * C_time + C_right) / (dx ** 2)\n\n    # c aligned with ct in time\n    c_slice = C_time.copy()\n\n    return ct, cxx, c_slice\n\ndef sample_patches(ct, cxx, c_slice, px, pt, M):\n    \"\"\"\n    Sample M space-time patches with replacement.\n    Spatial dimension wraps periodically; time does not wrap.\n    Returns a list of patches, each patch is a tuple (y_flat, Theta_flat)\n    where y_flat is ct flattened and Theta_flat has columns [cxx_flat, c_flat].\n    \"\"\"\n    T, Nx = ct.shape  # T = Nt-1\n    patches = []\n\n    # Valid time start indices to fit pt within T\n    max_t_start = T - pt\n    if max_t_start < 0:\n        raise ValueError(\"Patch time size exceeds available time samples.\")\n\n    for _ in range(M):\n        s_t = np.random.randint(0, max_t_start + 1)\n        s_x = np.random.randint(0, Nx)  # start in space; will wrap\n\n        # Spatial indices with periodic wrapping\n        idx = (s_x + np.arange(px)) % Nx\n\n        # Extract blocks and flatten in row-major\n        ct_patch = ct[s_t:s_t + pt, :][:, idx].reshape(-1)\n        cxx_patch = cxx[s_t:s_t + pt, :][:, idx].reshape(-1)\n        c_patch = c_slice[s_t:s_t + pt, :][:, idx].reshape(-1)\n\n        # Build Theta for this patch\n        Theta_patch = np.column_stack([cxx_patch, c_patch])\n\n        patches.append((ct_patch, Theta_patch))\n\n    return patches\n\ndef aggregate_patches(patches):\n    \"\"\"\n    Concatenate all patch data into a single regression dataset.\n    Returns y (vector) and Theta (matrix).\n    \"\"\"\n    y_list = []\n    Theta_list = []\n    for y_p, Th_p in patches:\n        y_list.append(y_p)\n        Theta_list.append(Th_p)\n    y = np.concatenate(y_list, axis=0)\n    Theta = np.vstack(Theta_list)\n    return y, Theta\n\ndef estimate_coefficients(y, Theta):\n    \"\"\"\n    Ordinary least squares estimate of xi in y = Theta @ xi.\n    Returns xi_hat (length-2 vector).\n    \"\"\"\n    # Use numpy lstsq for numerical stability\n    xi_hat, _, _, _ = np.linalg.lstsq(Theta, y, rcond=None)\n    return xi_hat\n\ndef bootstrap_ci(patches, B):\n    \"\"\"\n    Perform B bootstrap replicates by resampling patches with replacement.\n    Returns arrays of bootstrap estimates for D_hat and k_hat (k_hat computed as -xi2).\n    \"\"\"\n    P = len(patches)\n    D_boot = np.zeros(B)\n    k_boot = np.zeros(B)\n    for b in range(B):\n        # Sample patch indices with replacement\n        idx = np.random.randint(0, P, size=P)\n        resampled = [patches[i] for i in idx]\n        y_b, Theta_b = aggregate_patches(resampled)\n        xi_b = estimate_coefficients(y_b, Theta_b)\n        D_boot[b] = xi_b[0]\n        k_boot[b] = -xi_b[1]\n    return D_boot, k_boot\n\ndef run_case(D_true, k_true, L, Nx, Nt, dt, sigma, px, pt, M, B):\n    \"\"\"\n    Run the full pipeline for a single test case:\n    - Generate synthetic data\n    - Compute derivatives\n    - Sample patches\n    - Estimate coefficients\n    - Bootstrap confidence intervals\n    Returns [D_hat, k_hat, D_low, D_high, k_low, k_high]\n    \"\"\"\n    # Generate concentration and add noise\n    C = generate_concentration(D_true, k_true, L, Nx, Nt, dt)\n    C_noisy = add_noise(C, sigma)\n\n    # Derivatives\n    ct, cxx, c_slice = compute_derivatives(C_noisy, L, dt)\n\n    # Sample patches\n    patches = sample_patches(ct, cxx, c_slice, px, pt, M)\n\n    # Point estimate from full (non-resampled) set of M patches\n    y_all, Theta_all = aggregate_patches(patches)\n    xi_hat = estimate_coefficients(y_all, Theta_all)\n    D_hat = float(xi_hat[0])\n    k_hat = float(-xi_hat[1])\n\n    # Bootstrap\n    D_boot, k_boot = bootstrap_ci(patches, B)\n\n    # 95% percentile CIs\n    D_low = float(np.percentile(D_boot, 2.5))\n    D_high = float(np.percentile(D_boot, 97.5))\n    k_low = float(np.percentile(k_boot, 2.5))\n    k_high = float(np.percentile(k_boot, 97.5))\n\n    return [D_hat, k_hat, D_low, D_high, k_low, k_high]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: general case\n        {\n            \"D\": 5e-12, \"k\": 1e-3, \"L\": 1e-3,\n            \"Nx\": 128, \"Nt\": 120, \"dt\": 0.5, \"sigma\": 1e-6,\n            \"px\": 16, \"pt\": 20, \"M\": 50, \"B\": 200\n        },\n        # Test case 2: noise-free boundary\n        {\n            \"D\": 5e-12, \"k\": 1e-3, \"L\": 1e-3,\n            \"Nx\": 128, \"Nt\": 120, \"dt\": 0.5, \"sigma\": 0.0,\n            \"px\": 32, \"pt\": 30, \"M\": 40, \"B\": 150\n        },\n        # Test case 3: higher reaction rate and higher noise\n        {\n            \"D\": 5e-12, \"k\": 2e-3, \"L\": 1e-3,\n            \"Nx\": 96, \"Nt\": 100, \"dt\": 0.5, \"sigma\": 5e-6,\n            \"px\": 12, \"pt\": 16, \"M\": 60, \"B\": 200\n        },\n        # Test case 4: small dataset, weaker diffusion/reaction\n        {\n            \"D\": 1e-12, \"k\": 5e-4, \"L\": 1e-3,\n            \"Nx\": 64, \"Nt\": 80, \"dt\": 0.5, \"sigma\": 1e-6,\n            \"px\": 8, \"pt\": 10, \"M\": 12, \"B\": 60\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        res = run_case(\n            D_true=case[\"D\"], k_true=case[\"k\"], L=case[\"L\"],\n            Nx=case[\"Nx\"], Nt=case[\"Nt\"], dt=case[\"dt\"], sigma=case[\"sigma\"],\n            px=case[\"px\"], pt=case[\"pt\"], M=case[\"M\"], B=case[\"B\"]\n        )\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    # Print as a single line: list of four lists, each with six floats.\n    # Avoid additional text.\n    print(f\"[{','.join('[' + ','.join(map(str, r)) + ']' for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}