{
    "hands_on_practices": [
        {
            "introduction": "This practice will introduce the core mechanics of Shapley Additive Explanations (SHAP), a foundational method in XAI. By working with a simplified but scientifically plausible model of co-doping in a battery cathode, you will calculate Shapley values and interaction indices from first principles. This exercise provides a concrete understanding of how SHAP decomposes a model's prediction into additive contributions from individual features and their synergistic or antagonistic interactions. ",
            "id": "3913432",
            "problem": "Consider a simplified, scientifically plausible predictive model used in automated battery design and simulation to estimate the change in specific capacity of a layered oxide cathode (in milliampere-hours per gram) due to co-doping with two cation species. Let the dopant mole fractions be $x_1$ and $x_2$ (dimensionless decimal fractions), and let the model prediction be\n$$\nf(x_1,x_2) = w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2,\n$$\nwhere $w_1$ and $w_2$ have units of $\\mathrm{mAh/g}$ per unit dopant fraction, and $w_{12}$ has units of $\\mathrm{mAh/g}$ per square of dopant fraction. This captures both individual dopant effects and a binary interaction term that models co-doping synergy or antagonism in cathode chemistry.\n\nIn Explainable Artificial Intelligence (XAI), Shapley Additive explanation (SHAP) attributes the prediction to input features using cooperative game theory. For an instance $x=(x_1,x_2)$, define the interventional value function\n$$\nv(S) = f(x_S, b_{-S}),\n$$\nwhere the baseline vector $b=(b_1,b_2)$ represents the undoped reference, with $b_1=0$ and $b_2=0$. The Shapley value for feature $i$ is given by the cooperative game theory definition\n$$\n\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|!(M-|S|-1)!}{M!}\\left[v(S \\cup \\{i\\}) - v(S)\\right],\n$$\nwhere $N=\\{1,2\\}$ and $M=|N|=2$. The Shapley interaction index for the pair $(i,j)$ is defined (interventional form) by\n$$\n\\phi_{ij} = \\sum_{S \\subseteq N \\setminus \\{i,j\\}} \\frac{|S|!(M-|S|-2)!}{(M-1)!}\\left[v(S \\cup \\{i,j\\}) - v(S \\cup \\{i\\}) - v(S \\cup \\{j\\}) + v(S)\\right].\n$$\nFor $M=2$, this reduces to\n$$\n\\phi_{12} = v(\\{1,2\\}) - v(\\{1\\}) - v(\\{2\\}) + v(\\emptyset).\n$$\n\nYour task is to implement a program that, for each provided test case, computes:\n1. The Shapley values $\\phi_1$ and $\\phi_2$ in $\\mathrm{mAh/g}$.\n2. The Shapley interaction index $\\phi_{12}$ in $\\mathrm{mAh/g}$.\n3. A boolean synergy flag that is $\\mathrm{True}$ if $\\phi_{12} > 0$ and $\\mathrm{False}$ otherwise, interpreting positive interaction as synergistic co-doping and non-positive interaction as antagonistic or neutral.\n4. A boolean conservation check that is $\\mathrm{True}$ if $\\phi_1 + \\phi_2$ equals $f(x_1,x_2) - f(b_1,b_2)$ within an absolute tolerance of $10^{-12}$, and $\\mathrm{False}$ otherwise.\n\nAll floating-point outputs must be rounded to $6$ decimal places and expressed in $\\mathrm{mAh/g}$. Dopant fractions $x_1$ and $x_2$ must be treated as decimal fractions (not percentages).\n\nUse the following test suite (each tuple is $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2)$):\n- Case A (typical synergistic co-doping): $(50.0, 30.0, 40.0, 0.02, 0.03, 0.0, 0.0)$.\n- Case B (antagonistic co-doping): $(50.0, 60.0, -80.0, 0.01, 0.02, 0.0, 0.0)$.\n- Case C (no interaction, single-dopant present): $(45.0, 20.0, 0.0, 0.05, 0.0, 0.0, 0.0)$.\n- Case D (boundary with one dopant absent, positive interaction coefficient): $(35.0, 25.0, 100.0, 0.0, 0.04, 0.0, 0.0)$.\n- Case E (harmful single dopant with weak synergy): $( -10.0, 40.0, 10.0, 0.03, 0.03, 0.0, 0.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of this list corresponds to a test case and must itself be a list in the form $[\\phi_1,\\phi_2,\\phi_{12},\\mathrm{synergy},\\mathrm{conservation}]$, where $\\phi_1$, $\\phi_2$, and $\\phi_{12}$ are floats in $\\mathrm{mAh/g}$ rounded to $6$ decimal places, and $\\mathrm{synergy}$ and $\\mathrm{conservation}$ are booleans. For example, the output should look like $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$ with no additional text.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n### Step 1: Extract Givens\n- **Predictive Model**: The change in specific capacity is given by the function $f(x_1, x_2) = w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2$, where $x_1$ and $x_2$ are dopant mole fractions.\n- **Interventional Value Function**: $v(S) = f(x_S, b_{-S})$.\n- **Baseline Vector**: The undoped reference state is $b = (b_1, b_2) = (0, 0)$.\n- **Number of Features**: $M = |N| = 2$, with $N = \\{1, 2\\}$.\n- **Shapley Value Formula**: $\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|!(M-|S|-1)!}{M!}\\left[v(S \\cup \\{i\\}) - v(S)\\right]$.\n- **Shapley Interaction Index Formula (for $M=2$)**: $\\phi_{12} = v(\\{1,2\\}) - v(\\{1\\}) - v(\\{2\\}) + v(\\emptyset)$.\n- **Tasks**:\n  1. Compute Shapley values $\\phi_1$ and $\\phi_2$.\n  2. Compute Shapley interaction index $\\phi_{12}$.\n  3. Determine a synergy flag: $\\mathrm{True}$ if $\\phi_{12} > 0$.\n  4. Perform a conservation check: $\\mathrm{True}$ if $|\\phi_1 + \\phi_2 - (f(x_1,x_2) - f(b_1,b_2))| \\le 10^{-12}$.\n- **Output Requirements**: Floating-point values must be rounded to $6$ decimal places.\n- **Test Cases**:\n  - A: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = (50.0, 30.0, 40.0, 0.02, 0.03, 0.0, 0.0)$.\n  - B: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = (50.0, 60.0, -80.0, 0.01, 0.02, 0.0, 0.0)$.\n  - C: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = (45.0, 20.0, 0.0, 0.05, 0.0, 0.0, 0.0)$.\n  - D: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = (35.0, 25.0, 100.0, 0.0, 0.04, 0.0, 0.0)$.\n  - E: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = ( -10.0, 40.0, 10.0, 0.03, 0.03, 0.0, 0.0)$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is grounded in materials science and explainable AI. The predictive model is a simple polynomial, a common starting point in materials informatics. The use of Shapley values for feature attribution is a standard, mathematically rigorous method in XAI. The context of co-doping in cathodes is scientifically relevant. The problem is valid.\n- **Well-Posed**: The problem provides all necessary formulas, data, and a clear set of tasks. For each input test case, a unique set of outputs can be calculated through a direct application of the provided definitions. The problem is valid.\n- **Objective**: All terms are defined mathematically. The tasks are quantitative and based on the provided model and definitions, free of subjective interpretation. The problem is valid.\n- **Conclusion**: The problem does not violate any of the invalidity criteria. It is complete, consistent, scientifically plausible, and well-posed.\n\n### Step 3: Verdict and Action\nThe problem is valid. A solution will be developed.\n\n### Principle-Based Design and Solution\n\nThe core of the problem is to derive analytical expressions for the Shapley values and interaction index for the given predictive model $f(x_1, x_2)$. This avoids numerical approximation and provides an exact solution.\n\nFirst, we evaluate the interventional value function $v(S)$ for all possible subsets $S \\subseteq N = \\{1, 2\\}$. The instance is $x = (x_1, x_2)$ and the baseline is $b = (0, 0)$.\n\n1.  $S = \\emptyset$: The subset of features is empty. We use the baseline values for all features.\n    $v(\\emptyset) = f(b_1, b_2) = f(0, 0) = w_1(0) + w_2(0) + w_{12}(0)(0) = 0$.\n\n2.  $S = \\{1\\}$: We use the instance value for feature $1$ ($x_1$) and the baseline for feature $2$ ($b_2$).\n    $v(\\{1\\}) = f(x_1, b_2) = f(x_1, 0) = w_1 x_1 + w_2(0) + w_{12}x_1(0) = w_1 x_1$.\n\n3.  $S = \\{2\\}$: We use the baseline for feature $1$ ($b_1$) and the instance value for feature $2$ ($x_2$).\n    $v(\\{2\\}) = f(b_1, x_2) = f(0, x_2) = w_1(0) + w_2 x_2 + w_{12}(0)x_2 = w_2 x_2$.\n\n4.  $S = \\{1, 2\\}$: We use the instance values for both features.\n    $v(\\{1, 2\\}) = f(x_1, x_2) = w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2$.\n\nWith these values, we can compute the Shapley values $\\phi_1$ and $\\phi_2$. For $M=2$ features, the general Shapley formula simplifies. The Shapley value for feature $i$ is the average of its marginal contributions over all possible orderings of features. For two features, the two orderings are $(1, 2)$ and $(2, 1)$.\n\nThe marginal contribution of feature $1$ when added first is $v(\\{1\\}) - v(\\emptyset)$.\nThe marginal contribution of feature $1$ when added second (after feature $2$) is $v(\\{1, 2\\}) - v(\\{2\\})$.\nThe Shapley value $\\phi_1$ is the average of these two contributions:\n$$\n\\phi_1 = \\frac{1}{2} \\left[ (v(\\{1\\}) - v(\\emptyset)) + (v(\\{1, 2\\}) - v(\\{2\\})) \\right]\n$$\nSubstituting a Priori calculated values:\n$$\n\\phi_1 = \\frac{1}{2} \\left[ (w_1 x_1 - 0) + ( (w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2) - w_2 x_2 ) \\right]\n$$\n$$\n\\phi_1 = \\frac{1}{2} \\left[ w_1 x_1 + w_1 x_1 + w_{12} x_1 x_2 \\right] = \\frac{1}{2} \\left[ 2 w_1 x_1 + w_{12} x_1 x_2 \\right]\n$$\n$$\n\\phi_1 = w_1 x_1 + \\frac{1}{2} w_{12} x_1 x_2\n$$\nBy symmetry, swapping indices $1$ and $2$, we find $\\phi_2$:\n$$\n\\phi_2 = w_2 x_2 + \\frac{1}{2} w_{12} x_1 x_2\n$$\nNext, we compute the Shapley interaction index $\\phi_{12}$ using the simplified formula for $M=2$:\n$$\n\\phi_{12} = v(\\{1,2\\}) - v(\\{1\\}) - v(\\{2\\}) + v(\\emptyset)\n$$\nSubstituting our values:\n$$\n\\phi_{12} = (w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2) - (w_1 x_1) - (w_2 x_2) + 0\n$$\n$$\n\\phi_{12} = w_{12} x_1 x_2\n$$\nThis result is intuitive: the interaction index isolates the contribution of the interaction term $w_{12} x_1 x_2$ in the model. The Shapley values $\\phi_1$ and $\\phi_2$ attribute the individual linear effects ($w_1 x_1$ and $w_2 x_2$) entirely to features $1$ and $2$ respectively, and distribute the interaction effect ($w_{12} x_1 x_2$) equally between them.\n\nThe synergy flag is $\\mathrm{True}$ if $\\phi_{12} > 0$, which corresponds to a positive (synergistic) interaction effect.\n\nFinally, we perform the conservation check. This is a fundamental property of Shapley values, known as efficiency. The sum of the Shapley values must equal the total change in the prediction from the baseline.\n$$\n\\phi_1 + \\phi_2 = (w_1 x_1 + \\frac{1}{2} w_{12} x_1 x_2) + (w_2 x_2 + \\frac{1}{2} w_{12} x_1 x_2) = w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2\n$$\nThe change in prediction from the baseline is:\n$$\nf(x_1, x_2) - f(b_1, b_2) = f(x_1, x_2) - f(0, 0) = (w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2) - 0\n$$\nThus, we find that $\\phi_1 + \\phi_2 = f(x_1, x_2) - f(b_1, b_2)$ holds exactly. The conservation check should be $\\mathrm{True}$ for all cases, and it serves as a robust verification of the implementation's correctness against floating-point arithmetic errors.\n\nThe algorithm is as follows:\n1. For each test case $(w_1, w_2, w_{12}, x_1, x_2, b_1, b_2)$:\n2. Calculate the interaction term effect: $I = w_{12} x_1 x_2$.\n3. Calculate $\\phi_{12} = I$.\n4. Calculate $\\phi_1 = w_1 x_1 + \\frac{1}{2} I$.\n5. Calculate $\\phi_2 = w_2 x_2 + \\frac{1}{2} I$.\n6. Determine synergy: $\\phi_{12} > 0$.\n7. Perform conservation check: $|\\phi_1 + \\phi_2 - (w_1 x_1 + w_2 x_2 + I)| \\le 10^{-12}$.\n8. Round $\\phi_1, \\phi_2, \\phi_{12}$ to $6$ decimal places.\n9. Collate the results into a list.\n10. Aggregate results from all test cases and format the final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Calculates Shapley values and interaction indices for a battery cathode model\n    and prints the results for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (w1, w2, w12, x1, x2, b1, b2).\n    test_cases = [\n        # Case A (typical synergistic co-doping)\n        (50.0, 30.0, 40.0, 0.02, 0.03, 0.0, 0.0),\n        # Case B (antagonistic co-doping)\n        (50.0, 60.0, -80.0, 0.01, 0.02, 0.0, 0.0),\n        # Case C (no interaction, single-dopant present)\n        (45.0, 20.0, 0.0, 0.05, 0.0, 0.0, 0.0),\n        # Case D (boundary with one dopant absent, positive interaction coefficient)\n        (35.0, 25.0, 100.0, 0.0, 0.04, 0.0, 0.0),\n        # Case E (harmful single dopant with weak synergy)\n        (-10.0, 40.0, 10.0, 0.03, 0.03, 0.0, 0.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        w1, w2, w12, x1, x2, b1, b2 = case\n\n        # The predictive model is f(x1, x2) = w1*x1 + w2*x2 + w12*x1*x2.\n        # The baseline is b = (0, 0), so f(b1, b2) = 0.\n        \n        # 1. Calculate Shapley interaction index phi_12\n        # phi_12 = v({1,2}) - v({1}) - v({2}) + v(0)\n        # v({1,2}) = f(x1, x2) = w1*x1 + w2*x2 + w12*x1*x2\n        # v({1}) = f(x1, 0) = w1*x1\n        # v({2}) = f(0, x2) = w2*x2\n        # v(0) = f(0, 0) = 0\n        # phi_12 = (w1*x1 + w2*x2 + w12*x1*x2) - (w1*x1) - (w2*x2) + 0\n        # phi_12 = w12 * x1 * x2\n        phi_12 = w12 * x1 * x2\n\n        # 2. Calculate Shapley values phi_1 and phi_2\n        # phi_1 = w1*x1 + 0.5 * w12*x1*x2\n        # phi_2 = w2*x2 + 0.5 * w12*x1*x2\n        phi_1 = w1 * x1 + 0.5 * phi_12\n        phi_2 = w2 * x2 + 0.5 * phi_12\n\n        # 3. Determine synergy flag\n        # True if phi_12 > 0\n        synergy = phi_12 > 0\n\n        # 4. Perform conservation check\n        # Check if phi_1 + phi_2 = f(x1, x2) - f(b1, b2)\n        f_x = w1 * x1 + w2 * x2 + w12 * x1 * x2\n        f_b = w1 * b1 + w2 * b2 + w12 * b1 * b2 # This is always 0 for the given cases.\n        total_effect = f_x - f_b\n        shapley_sum = phi_1 + phi_2\n        \n        # Use a tolerance for floating point comparison\n        conservation = abs(shapley_sum - total_effect) <= 1e-12\n        \n        # Round the float outputs to 6 decimal places.\n        phi_1_rounded = round(phi_1, 6)\n        phi_2_rounded = round(phi_2, 6)\n        phi_12_rounded = round(phi_12, 6)\n\n        results.append([\n            phi_1_rounded,\n            phi_2_rounded,\n            phi_12_rounded,\n            synergy,\n            conservation\n        ])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, represented as a string.\n    # e.g., [[val1, val2,...], [val1, val2,...]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the fundamentals of feature attribution, this practice explores the application of SHAP to a more realistic, non-linear physical model of a porous electrode. A key challenge in practical XAI is understanding how feature representation influences the resulting explanations. Here, you will investigate the sensitivity of SHAP-based feature importance to different scaling and standardization schemes, a crucial step for correctly interpreting and comparing attributions in real-world battery design scenarios. ",
            "id": "3913467",
            "problem": "You are given a physically grounded surrogate model for porous lithium-ion battery electrodes that maps microstructural features to a simplified power-density proxy. Let the features be porosity $\\epsilon$ (dimensionless), particle radius $r$ (in meters), and Bruggeman exponent $b$ (dimensionless). The model output is defined by\n$$\nP(\\epsilon,r,b) = C\\,\\kappa_0\\,\\epsilon^{b}\\,\\frac{3(1-\\epsilon)}{r},\n$$\nwhere $C$ is a dimensionful scaling constant and $\\kappa_0$ is the bulk electrolyte ionic conductivity in $\\mathrm{S/m}$. This surrogate follows two well-tested bases: the Bruggeman-type scaling $\\kappa_{\\mathrm{eff}} \\propto \\epsilon^{b}$ for effective ionic transport and the specific surface area of a sphere packing $a \\propto \\frac{(1-\\epsilon)}{r}$.\n\nFor a given instance $x=(\\epsilon,r,b)$ and a fixed reference $x^{\\mathrm{ref}}=(\\epsilon_0,r_0,b_0)$, define a coalition value function $v(S)$ for any subset $S\\subseteq\\{\\epsilon,r,b\\}$ as the model output with features in $S$ set to their instance values and features not in $S$ set to their reference values:\n$$\nv(S) = P\\big(x_S \\cup x^{\\mathrm{ref}}_{\\overline{S}}\\big).\n$$\nThe Shapley value $\\phi_i$ for feature $i\\in\\{\\epsilon,r,b\\}$ is\n$$\n\\phi_i(x;x^{\\mathrm{ref}}) = \\sum_{S\\subseteq N\\setminus\\{i\\}} \\frac{|S|!\\,(|N|-|S|-1)!}{|N|!}\\Big[v(S\\cup\\{i\\})-v(S)\\Big],\n$$\nwith $N=\\{\\epsilon,r,b\\}$ and $|N|=3$. The normalized feature importance $w_i$ is defined by\n$$\nw_i = \\frac{|\\phi_i|}{|\\phi_\\epsilon|+|\\phi_r|+|\\phi_b|}.\n$$\n\nYour task is to compute the normalized feature importance vector $[w_\\epsilon,w_r,w_b]$ for each of the following test cases. Unless specified, all radii must be provided in meters, and all outputs and intermediate computations must be consistent with the units above. For the unit-scaling tests, explicit transformations are given and must be strictly followed. Use $C=1$ and $\\kappa_0=1.2\\,\\mathrm{S/m}$ throughout.\n\nTest Suite:\n- Case $1$ (happy path, raw features): instance $(\\epsilon,r,b)=(0.35,5\\times 10^{-6}\\,\\mathrm{m},1.6)$ with reference $(\\epsilon_0,r_0,b_0)=(0.30,8\\times 10^{-6}\\,\\mathrm{m},2.0)$.\n- Case $2$ (boundary sensitivity, raw features): instance $(\\epsilon,r,b)=(0.95,1\\times 10^{-6}\\,\\mathrm{m},2.5)$ with the same reference $(\\epsilon_0,r_0,b_0)=(0.30,8\\times 10^{-6}\\,\\mathrm{m},2.0)$.\n- Case $3$ (unit scaling of radius): treat the radius feature in micrometers; define $r_{\\mu\\mathrm{m}} = r / 10^{-6}\\,\\mathrm{m}$. Compute Shapley values with respect to features $(\\epsilon,r_{\\mu\\mathrm{m}},b)$, while the model strictly evaluates $P$ using $r=10^{-6}\\times r_{\\mu\\mathrm{m}}\\,\\mathrm{m}$. Use the same physical instance as Case $1$, i.e., $(\\epsilon,r_{\\mu\\mathrm{m}},b)=(0.35,5,1.6)$, and reference $(\\epsilon_0,r_{0,\\mu\\mathrm{m}},b_0)=(0.30,8,2.0)$.\n- Case $4$ (standardization and interaction structure): define standardized features\n$$\nz_\\epsilon = \\frac{\\epsilon-\\mu_\\epsilon}{\\sigma_\\epsilon},\\quad z_r = \\frac{r-\\mu_r}{\\sigma_r},\\quad z_b = \\frac{b-\\mu_b}{\\sigma_b},\n$$\nwith $\\mu=(\\mu_\\epsilon,\\mu_r,\\mu_b)=x^{\\mathrm{ref}}=(0.30,8\\times 10^{-6}\\,\\mathrm{m},2.0)$ and $\\sigma=(\\sigma_\\epsilon,\\sigma_r,\\sigma_b)=(0.05,1\\times 10^{-6}\\,\\mathrm{m},0.4)$. Compute Shapley values with respect to $(z_\\epsilon,z_r,z_b)$, while the model evaluates $P$ using the inverse transform $(\\epsilon,r,b)=(\\mu_\\epsilon+\\sigma_\\epsilon z_\\epsilon,\\mu_r+\\sigma_r z_r,\\mu_b+\\sigma_b z_b)$. Use the physical instance from Case $1$ mapped into $z$-space, i.e., $z=(\\frac{0.35-0.30}{0.05},\\frac{5\\times 10^{-6}-8\\times 10^{-6}}{1\\times 10^{-6}},\\frac{1.6-2.0}{0.4})=(1.0,-3.0,-1.0)$, and reference $z^{\\mathrm{ref}}=(0,0,0)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the normalized feature importance results for the four cases as a comma-separated list enclosed in square brackets. Each case must appear as an inner list $[w_\\epsilon,w_r,w_b]$ of three floats, rounded to six decimal places, with no spaces. For example, the output should look like\n$$\n[[w_{\\epsilon,1},w_{r,1},w_{b,1}],[w_{\\epsilon,2},w_{r,2},w_{b,2}],[w_{\\epsilon,3},w_{r,3},w_{b,3}],[w_{\\epsilon,4},w_{r,4},w_{b,4}]]\n$$\nwhere the subscript indicates the case index. All values $w_i$ are dimensionless decimals.",
            "solution": "The problem statement has been rigorously validated and is determined to be valid. It is scientifically grounded in established electrochemical and materials science principles, mathematically well-posed, objective, and self-contained. All provided parameters and conditions are consistent and physically plausible. The task requires the application of a standard methodology from explainable artificial intelligence (Shapley values) to a simplified, physics-based model of a battery electrode, which is a relevant and non-trivial problem.\n\nThe solution is approached by first implementing the given surrogate model and then developing a generalized function to compute Shapley values for a three-feature system. This framework is then applied to each of the four specified test cases, with appropriate handling of feature transformations as required.\n\nThe surrogate model for the power-density proxy is given by:\n$$\nP(\\epsilon,r,b) = C\\,\\kappa_0\\,\\epsilon^{b}\\,\\frac{3(1-\\epsilon)}{r}\n$$\nwhere $\\epsilon$ is the porosity, $r$ is the particle radius, and $b$ is the Bruggeman exponent. The constants are fixed at $C=1$ and $\\kappa_0=1.2\\,\\mathrm{S/m}$. The model thus simplifies to:\n$$\nP(\\epsilon,r,b) = 3.6\\,\\frac{\\epsilon^{b}\\,(1-\\epsilon)}{r}\n$$\n\nThe core of the analysis is the computation of Shapley values, which quantify the contribution of each feature to the model's output deviation from a reference value. For a set of three features $N=\\{\\text{feature}_1, \\text{feature}_2, \\text{feature}_3\\}$, we must first compute the output of the model for all $2^{|N|} = 8$ possible coalitions of features. A coalition $S \\subseteq N$ corresponds to using feature values from the instance $x$ for features in $S$ and values from the reference $x^{\\mathrm{ref}}$ for features not in $S$. The value function $v(S)$ is defined as this model output.\n\nLet the features be indexed as $1 \\leftrightarrow \\epsilon$, $2 \\leftrightarrow r$, and $3 \\leftrightarrow b$. The eight coalition values are:\n- $v(\\emptyset) = P(\\epsilon_0, r_0, b_0)$\n- $v(\\{1\\}) = P(\\epsilon, r_0, b_0)$\n- $v(\\{2\\}) = P(\\epsilon_0, r, b_0)$\n- $v(\\{3\\}) = P(\\epsilon_0, r_0, b)$\n- $v(\\{1, 2\\}) = P(\\epsilon, r, b_0)$\n- $v(\\{1, 3\\}) = P(\\epsilon, r_0, b)$\n- $v(\\{2, 3\\}) = P(\\epsilon_0, r, b)$\n- $v(\\{1, 2, 3\\}) = P(\\epsilon, r, b)$\n\nThe Shapley value $\\phi_i$ for a feature $i$ is a weighted average of its marginal contributions to all coalitions. For a 3-feature game ($|N|=3$), the formula for feature $i$ is:\n$$\n\\phi_i = \\frac{1}{3} \\Big(v(\\{i\\}) - v(\\emptyset)\\Big) + \\frac{1}{6} \\sum_{j \\in N \\setminus \\{i\\}} \\Big(v(\\{i,j\\}) - v(\\{j\\})\\Big) + \\frac{1}{3} \\Big(v(N) - v(N \\setminus \\{i\\})\\Big)\n$$\nExplicitly for each feature:\n$$\n\\phi_\\epsilon = \\frac{1}{3}\\Big[v(\\{\\epsilon\\}) - v(\\emptyset)\\Big] + \\frac{1}{6}\\Big[v(\\{\\epsilon,r\\}) - v(\\{r\\})\\Big] + \\frac{1}{6}\\Big[v(\\{\\epsilon,b\\}) - v(\\{b\\})\\Big] + \\frac{1}{3}\\Big[v(\\{\\epsilon,r,b\\}) - v(\\{r,b\\})\\Big]\n$$\n$$\n\\phi_r = \\frac{1}{3}\\Big[v(\\{r\\}) - v(\\emptyset)\\Big] + \\frac{1}{6}\\Big[v(\\{\\epsilon,r\\}) - v(\\{\\epsilon\\})\\Big] + \\frac{1}{6}\\Big[v(\\{r,b\\}) - v(\\{b\\})\\Big] + \\frac{1}{3}\\Big[v(\\{\\epsilon,r,b\\}) - v(\\{\\epsilon,b\\})\\Big]\n$$\n$$\n\\phi_b = \\frac{1}{3}\\Big[v(\\{b\\}) - v(\\emptyset)\\Big] + \\frac{1}{6}\\Big[v(\\{\\epsilon,b\\}) - v(\\{\\epsilon\\})\\Big] + \\frac{1}{6}\\Big[v(\\{r,b\\}) - v(\\{r\\})\\Big] + \\frac{1}{3}\\Big[v(\\{\\epsilon,r,b\\}) - v(\\{\\epsilon,r\\})\\Big]\n$$\nFinally, the normalized feature importance $w_i$ is computed from the absolute values of the Shapley values:\n$$\nw_i = \\frac{|\\phi_i|}{|\\phi_\\epsilon|+|\\phi_r|+|\\phi_b|}\n$$\n\nThis computational procedure is applied to each of the four test cases.\n\n**Case 1: Raw Features**\nThe instance is $(\\epsilon,r,b)=(0.35,5\\times 10^{-6},1.6)$ and the reference is $(\\epsilon_0,r_0,b_0)=(0.30,8\\times 10^{-6},2.0)$. The features for attribution are $(\\epsilon,r,b)$ directly. The function $P(\\epsilon,r,b)$ is used to compute the eight coalition values, from which the Shapley values and normalized importances are derived.\n\n**Case 2: Boundary Sensitivity**\nThe instance is $(\\epsilon,r,b)=(0.95,1\\times 10^{-6},2.5)$ and the reference is the same as in Case 1. The porosity value of $0.95$ is near the physical limit of $1$, which can lead to different interaction effects. The computational procedure is identical to Case 1, using these new instance values.\n\n**Case 3: Unit Scaling of Radius**\nThe instance and reference are physically the same as in Case 1. However, the attribution is performed on the feature space $(\\epsilon, r_{\\mu\\mathrm{m}}, b)$, where $r_{\\mu\\mathrm{m}} = r / 10^{-6}$. The instance is $(\\epsilon,r_{\\mu\\mathrm{m}},b)=(0.35,5,1.6)$ and reference is $(\\epsilon_0,r_{0,\\mu\\mathrm{m}},b_0)=(0.30,8,2.0)$. To compute the coalition values, a wrapper function is used. This function accepts features $(\\epsilon, r_{\\mu\\mathrm{m}}, b)$, internally converts the radius back to meters ($r = r_{\\mu\\mathrm{m}} \\times 10^{-6}$), and then evaluates the physical model $P(\\epsilon,r,b)$. The Shapley values are calculated for this transformed feature space.\n\n**Case 4: Standardized Features**\nAttribution is performed on standardized features $(z_\\epsilon, z_r, z_b)$, where the transformation is $z_i = (x_i - \\mu_i)/\\sigma_i$. The reference is defined at the mean, $z^{\\mathrm{ref}} = (0,0,0)$, which corresponds to the physical reference $(\\mu_\\epsilon,\\mu_r,\\mu_b) = (0.30, 8\\times 10^{-6}, 2.0)$. The instance is the standardized version of the instance from Case 1: $z=(1.0,-3.0,-1.0)$. A wrapper function is defined that accepts $(z_\\epsilon,z_r,z_b)$ as input, applies the inverse transformation to get physical features $(\\epsilon,r,b) = (\\mu_\\epsilon+\\sigma_\\epsilon z_\\epsilon, \\mu_r+\\sigma_r z_r, \\mu_b+\\sigma_b z_b)$, and then evaluates $P(\\epsilon,r,b)$. The Shapley values are computed for the standardized features.\n\nThe final Python code implements this logic systematically for each case and formats the output as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating normalized feature importances for four test cases.\n    \"\"\"\n\n    # Global constants from the problem statement\n    C = 1.0\n    KAPPA_0 = 1.2\n\n    def P_model(epsilon, r, b):\n        \"\"\"\n        The physically grounded surrogate model P(epsilon, r, b).\n        Uses physical units (r in meters).\n        \"\"\"\n        # Physical constraints to prevent math errors and undefined behavior.\n        if r <= 0 or epsilon <= 0 or epsilon >= 1:\n            return 0.0\n        return C * KAPPA_0 * (epsilon**b) * (3.0 * (1.0 - epsilon) / r)\n\n    def calculate_shapley_values(model_func, instance, reference):\n        \"\"\"\n        Calculates Shapley values for a 3-feature model.\n\n        Args:\n            model_func: A function that takes 3 features and returns a value.\n            instance: A tuple/list of 3 feature values for the instance x.\n            reference: A tuple/list of 3 feature values for the reference x_ref.\n\n        Returns:\n            A tuple containing the Shapley values (phi_1, phi_2, phi_3).\n        \"\"\"\n        feat1_inst, feat2_inst, feat3_inst = instance\n        feat1_ref, feat2_ref, feat3_ref = reference\n\n        # Calculate value function v(S) for all 2^3 = 8 coalitions S.\n        v = {\n            'empty': model_func(feat1_ref,  feat2_ref,  feat3_ref),\n            '1':     model_func(feat1_inst, feat2_ref,  feat3_ref),\n            '2':     model_func(feat1_ref,  feat2_inst, feat3_ref),\n            '3':     model_func(feat1_ref,  feat2_ref,  feat3_inst),\n            '12':    model_func(feat1_inst, feat2_inst, feat3_ref),\n            '13':    model_func(feat1_inst, feat2_ref,  feat3_inst),\n            '23':    model_func(feat1_ref,  feat2_inst, feat3_inst),\n            '123':   model_func(feat1_inst, feat2_inst, feat3_inst)\n        }\n\n        # Calculate Shapley values using the explicit formula for |N|=3.\n        # Weights are 1/3 for |S|=0,2 and 1/6 for |S|=1.\n        phi_1 = (1/3) * (v['1'] - v['empty']) + \\\n                (1/6) * (v['12'] - v['2']) + \\\n                (1/6) * (v['13'] - v['3']) + \\\n                (1/3) * (v['123'] - v['23'])\n\n        phi_2 = (1/3) * (v['2'] - v['empty']) + \\\n                (1/6) * (v['12'] - v['1']) + \\\n                (1/6) * (v['23'] - v['3']) + \\\n                (1/3) * (v['123'] - v['13'])\n\n        phi_3 = (1/3) * (v['3'] - v['empty']) + \\\n                (1/6) * (v['13'] - v['1']) + \\\n                (1/6) * (v['23'] - v['2']) + \\\n                (1/3) * (v['123'] - v['12'])\n\n        return phi_1, phi_2, phi_3\n\n    def normalize_importance(shapley_values):\n        \"\"\"\n        Normalizes the absolute Shapley values to get feature importance weights.\n        \"\"\"\n        phi_1, phi_2, phi_3 = shapley_values\n        total_abs_phi = abs(phi_1) + abs(phi_2) + abs(phi_3)\n        \n        if total_abs_phi == 0:\n            return [1/3, 1/3, 1/3]\n            \n        w1 = abs(phi_1) / total_abs_phi\n        w2 = abs(phi_2) / total_abs_phi\n        w3 = abs(phi_3) / total_abs_phi\n        \n        return [w1, w2, w3]\n\n    results = []\n\n    # Case 1: happy path, raw features\n    instance_1 = (0.35, 5e-6, 1.6)\n    reference_1 = (0.30, 8e-6, 2.0)\n    shapley_1 = calculate_shapley_values(P_model, instance_1, reference_1)\n    importance_1 = normalize_importance(shapley_1)\n    results.append(importance_1)\n\n    # Case 2: boundary sensitivity, raw features\n    instance_2 = (0.95, 1e-6, 2.5)\n    reference_2 = (0.30, 8e-6, 2.0)\n    shapley_2 = calculate_shapley_values(P_model, instance_2, reference_2)\n    importance_2 = normalize_importance(shapley_2)\n    results.append(importance_2)\n\n    # Case 3: unit scaling of radius\n    instance_3 = (0.35, 5.0, 1.6)  # r is in micrometers\n    reference_3 = (0.30, 8.0, 2.0) # r is in micrometers\n    def model_case3(eps, r_um, b_val):\n        r_m = r_um * 1e-6\n        return P_model(eps, r_m, b_val)\n    shapley_3 = calculate_shapley_values(model_case3, instance_3, reference_3)\n    importance_3 = normalize_importance(shapley_3)\n    results.append(importance_3)\n\n    # Case 4: standardization and interaction structure\n    instance_4 = (1.0, -3.0, -1.0) # (z_eps, z_r, z_b)\n    reference_4 = (0.0, 0.0, 0.0)\n    mu = (0.30, 8e-6, 2.0)\n    sigma = (0.05, 1e-6, 0.4)\n    def model_case4(z_eps, z_r, z_b_val):\n        eps = mu[0] + sigma[0] * z_eps\n        r = mu[1] + sigma[1] * z_r\n        b = mu[2] + sigma[2] * z_b_val\n        return P_model(eps, r, b)\n    shapley_4 = calculate_shapley_values(model_case4, instance_4, reference_4)\n    importance_4 = normalize_importance(shapley_4)\n    results.append(importance_4)\n    \n    # Format the final output string as per problem specification.\n    # Inner lists are formatted as \"[val1,val2,val3]\" with no spaces.\n    formatted_case_results = []\n    for res in results:\n        s = f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\"\n        formatted_case_results.append(s)\n    \n    print(f\"[{','.join(formatted_case_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate goal of XAI in engineering is not just to understand models, but to leverage that understanding to create better designs. This advanced practice demonstrates how to use local, explanation-driven surrogates to generate counterfactuals—alternative designs that achieve a desired outcome. You will formulate and solve a constrained optimization problem to find a new battery charging protocol that minimizes lithium plating risk while satisfying physical and operational constraints, directly translating an AI-generated insight into an actionable, improved engineering solution. ",
            "id": "3913447",
            "problem": "You are given a baseline constant-current charging protocol over a finite horizon and asked to construct a counterfactual protocol that reduces a plating-risk surrogate while maintaining charge throughput and respecting current density and thermal constraints. The setting is motivated by explainable artificial intelligence in battery design: a locally interpretable surrogate derived from a black-box plating-risk predictor provides first- and second-order sensitivities with respect to current density. Your task is to solve, for each test case, a constrained quadratic program representing the locally valid counterfactual adjustment.\n\nFundamental base and core definitions to use in the derivation: (i) the Butler–Volmer relationship implies that interfacial overpotential increases monotonically with current density, which increases plating propensity; (ii) a lumped one-resistor one-capacitor thermal model, with heat input from Joule heating, captures cell temperature evolution; (iii) a local surrogate approximation from an explainable predictor yields a quadratic-increment risk function in the current-density adjustments. The steps are specified below.\n\nLet there be $N$ time intervals, each of duration $\\Delta t$ (in seconds), with baseline current-density profile $\\mathbf{J}_0 \\in \\mathbb{R}^N$ where each component $J_{0,i}$ is in $\\mathrm{A}/\\mathrm{m}^2$. Let the decision variable be the counterfactual current-density profile $\\mathbf{J} \\in \\mathbb{R}^N$, with the same units. Let the cell geometric area be $A_{\\mathrm{cell}}$ (in $\\mathrm{m}^2$), internal resistance be $R_{\\mathrm{int}}$ (in $\\Omega$), thermal resistance be $R_{\\mathrm{th}}$ (in $\\mathrm{K}/\\mathrm{W}$), thermal capacitance be $C_{\\mathrm{th}}$ (in $\\mathrm{J}/\\mathrm{K}$), ambient temperature be $T_{\\mathrm{env}}$ (in $\\mathrm{K}$), and initial temperature be $T_{\\mathrm{init}}$ (in $\\mathrm{K}$). The lumped thermal dynamics are discretized by forward Euler from the energy balance\n$$\nC_{\\mathrm{th}} \\frac{dT}{dt} = I^2 R_{\\mathrm{int}} - \\frac{T - T_{\\mathrm{env}}}{R_{\\mathrm{th}}},\n$$\nwith $I = A_{\\mathrm{cell}} J$, yielding\n$$\nT_{i+1} = T_i + \\frac{\\Delta t}{C_{\\mathrm{th}}} \\left( A_{\\mathrm{cell}}^2 J_i^2 R_{\\mathrm{int}} - \\frac{T_i - T_{\\mathrm{env}}}{R_{\\mathrm{th}}} \\right),\n$$\nfor $i \\in \\{0,\\dots,N-1\\}$, $T_0 = T_{\\mathrm{init}}$. The thermal constraint is $T_i \\le T_{\\max}$ (in $\\mathrm{K}$) for all indices at the end of each interval. The current-density bound is $0 \\le J_i \\le J_{\\max}$ (in $\\mathrm{A}/\\mathrm{m}^2$). The charge-throughput equality is\n$$\n\\sum_{i=1}^{N} J_i \\, \\Delta t = \\sum_{i=1}^{N} J_{0,i} \\, \\Delta t,\n$$\nwhich enforces equal total delivered charge (in $\\mathrm{A}\\cdot\\mathrm{s}/\\mathrm{m}^2$) between baseline and counterfactual.\n\nFrom a locally interpretable surrogate of a plating-risk black box (e.g., a local model-agnostic explanation or Shapley-based quadratic fit), you are given per-interval first-order sensitivities $g_i$ and positive curvatures $h_i > 0$ such that the incremental change in aggregate risk relative to the baseline is approximated by\n$$\n\\Delta \\mathcal{R}(\\mathbf{J}) \\approx \\sum_{i=1}^N \\left[ g_i \\, (J_i - J_{0,i}) + \\tfrac{1}{2} h_i \\, (J_i - J_{0,i})^2 \\right].\n$$\nThe absolute baseline risk $\\mathcal{R}_0$ (in arbitrary nonnegative units) is provided. The counterfactual risk is approximated by $\\mathcal{R}_{\\star} \\approx \\mathcal{R}_0 + \\Delta \\mathcal{R}(\\mathbf{J}_{\\star})$. Your goal is to minimize $\\Delta \\mathcal{R}$ subject to constraints.\n\nTo retain the thermal constraint in a tractable form, use a first-order sensitivity linearization about the baseline trajectory. Define $\\phi = 1 - \\frac{\\Delta t}{C_{\\mathrm{th}} R_{\\mathrm{th}}}$. The baseline temperature trajectory $(T_i^0)_{i=0}^N$ is obtained by the above thermal recursion with $\\mathbf{J}_0$. The linear sensitivity matrix $\\mathbf{B} \\in \\mathbb{R}^{N \\times N}$, with entries $B_{i,k} = \\frac{\\partial T_{i+1}}{\\partial J_k} \\big|_{\\mathbf{J}_0}$, satisfies\n$$\nB_{k,k} = \\frac{\\Delta t}{C_{\\mathrm{th}}} \\, 2 A_{\\mathrm{cell}}^2 R_{\\mathrm{int}} \\, J_{0,k}, \\quad\nB_{i,k} = \\phi \\, B_{i-1,k} \\text{ for } i > k, \\quad\nB_{i,k} = 0 \\text{ for } i < k,\n$$\nso that the linearized thermal constraints at the end of each interval become\n$$\nT_{i+1}^0 + \\sum_{k=1}^N B_{i,k} \\, (J_k - J_{0,k}) \\le T_{\\max}, \\quad i = 0,\\dots,N-1.\n$$\nYou must solve the constrained quadratic program\n$$\n\\min_{\\mathbf{J} \\in \\mathbb{R}^N} \\sum_{i=1}^N \\left[ g_i \\, (J_i - J_{0,i}) + \\tfrac{1}{2} h_i \\, (J_i - J_{0,i})^2 \\right]\n$$\nsubject to\n$$\n\\sum_{i=1}^{N} J_i \\, \\Delta t = \\sum_{i=1}^{N} J_{0,i} \\, \\Delta t, \\quad\n0 \\le J_i \\le J_{\\max} \\text{ for all } i, \\quad\nT_{i+1}^0 + \\sum_{k=1}^N B_{i,k} \\, (J_k - J_{0,k}) \\le T_{\\max} \\text{ for } i=0,\\dots,N-1.\n$$\nFor each test case, compute the optimized $\\mathbf{J}_{\\star}$, then compute the estimated absolute counterfactual risk $\\mathcal{R}_{\\star} \\approx \\mathcal{R}_0 + \\Delta \\mathcal{R}(\\mathbf{J}_{\\star})$, and finally report the fractional risk reduction as the decimal\n$$\n\\rho = \\frac{\\mathcal{R}_0 - \\mathcal{R}_{\\star}}{\\mathcal{R}_0},\n$$\nrounded to six decimal places. No percentage sign is permitted; report a unitless decimal.\n\nPhysical units and angle units: current density must be in $\\mathrm{A}/\\mathrm{m}^2$, time in $\\mathrm{s}$, area in $\\mathrm{m}^2$, resistance in $\\Omega$, thermal resistance in $\\mathrm{K}/\\mathrm{W}$, thermal capacitance in $\\mathrm{J}/\\mathrm{K}$, and temperature in $\\mathrm{K}$. No angle quantities appear.\n\nTest suite and parameters:\n\nTest case $1$ (happy path, moderate constraints):\n- $N = 4$, $\\Delta t = 60.0$, $A_{\\mathrm{cell}} = 0.01$, $R_{\\mathrm{int}} = 0.05$, $R_{\\mathrm{th}} = 5.0$, $C_{\\mathrm{th}} = 400.0$, $T_{\\mathrm{env}} = 298.15$, $T_{\\mathrm{init}} = 298.15$, $J_{\\max} = 150.0$, $T_{\\max} = 313.15$.\n- Baseline $\\mathbf{J}_0 = [120.0, 120.0, 80.0, 80.0]$.\n- Surrogate parameters $\\mathbf{g} = [0.8, 0.6, 0.2, 0.1]$, $\\mathbf{h} = [0.02, 0.02, 0.01, 0.01]$, and $\\mathcal{R}_0 = 10.0$.\n\nTest case $2$ (thermal constraint more active):\n- $N = 4$, $\\Delta t = 60.0$, $A_{\\mathrm{cell}} = 0.01$, $R_{\\mathrm{int}} = 0.05$, $R_{\\mathrm{th}} = 5.0$, $C_{\\mathrm{th}} = 400.0$, $T_{\\mathrm{env}} = 298.15$, $T_{\\mathrm{init}} = 298.15$, $J_{\\max} = 150.0$, $T_{\\max} = 303.15$.\n- Baseline $\\mathbf{J}_0 = [100.0, 100.0, 100.0, 100.0]$.\n- Surrogate parameters $\\mathbf{g} = [1.0, 0.7, 0.2, 0.1]$, $\\mathbf{h} = [0.02, 0.02, 0.01, 0.01]$, and $\\mathcal{R}_0 = 8.0$.\n\nTest case $3$ (current-density bound limiting reallocation):\n- $N = 4$, $\\Delta t = 30.0$, $A_{\\mathrm{cell}} = 0.01$, $R_{\\mathrm{int}} = 0.05$, $R_{\\mathrm{th}} = 5.0$, $C_{\\mathrm{th}} = 400.0$, $T_{\\mathrm{env}} = 298.15$, $T_{\\mathrm{init}} = 298.15$, $J_{\\max} = 110.0$, $T_{\\max} = 330.0$.\n- Baseline $\\mathbf{J}_0 = [110.0, 110.0, 110.0, 110.0]$.\n- Surrogate parameters $\\mathbf{g} = [0.1, 0.1, 0.1, 0.1]$, $\\mathbf{h} = [0.005, 0.005, 0.005, 0.005]$, and $\\mathcal{R}_0 = 12.0$.\n\nFinal output format: Your program should produce a single line of output containing the three fractional risk reductions, in order for test cases $1$, $2$, and $3$, as a comma-separated list enclosed in square brackets, for example, $[x_1,x_2,x_3]$, where each $x_i$ is a decimal rounded to six places. No other text should be printed.",
            "solution": "The problem requires the solution of a constrained quadratic optimization problem to find a counterfactual battery charging protocol that minimizes a surrogate for plating risk while adhering to constraints on total charge, current density, and cell temperature. The solution process involves formulating the problem as a standard Quadratic Program (QP), constructing the necessary matrices and vectors from the given physical parameters, solving the QP numerically, and calculating the final performance metric.\n\nLet the number of time intervals be $N$, and let the vector of adjustments to the baseline current-density profile $\\mathbf{J}_0 \\in \\mathbb{R}^N$ be the decision variable $\\boldsymbol{\\delta} \\in \\mathbb{R}^N$, where $\\boldsymbol{\\delta} = \\mathbf{J} - \\mathbf{J}_0$. The indices for all vectors and time-dependent quantities will be $0$-based, i.e., $i \\in \\{0, 1, \\dots, N-1\\}$.\n\nThe optimization problem is to minimize the incremental risk, which is a quadratic function of $\\boldsymbol{\\delta}$:\n$$\n\\min_{\\boldsymbol{\\delta} \\in \\mathbb{R}^N} \\quad f(\\boldsymbol{\\delta}) = \\sum_{i=0}^{N-1} \\left[ g_i \\delta_i + \\tfrac{1}{2} h_i \\delta_i^2 \\right]\n$$\nThis objective function can be written in matrix form as:\n$$\n\\min_{\\boldsymbol{\\delta}} \\quad \\frac{1}{2} \\boldsymbol{\\delta}^T \\mathbf{H} \\boldsymbol{\\delta} + \\mathbf{g}^T \\boldsymbol{\\delta}\n$$\nwhere $\\mathbf{g} = [g_0, g_1, \\dots, g_{N-1}]^T$ is the vector of first-order sensitivities and $\\mathbf{H} = \\mathrm{diag}(h_0, h_1, \\dots, h_{N-1})$ is the diagonal matrix of positive curvatures. Since all $h_i > 0$, the Hessian matrix $\\mathbf{H}$ is positive definite, making the objective function strictly convex.\n\nThe optimization is subject to the following linear constraints:\n\n1.  **Charge Throughput Conservation**: The total charge delivered must be the same as the baseline.\n    $$\n    \\sum_{i=0}^{N-1} J_i \\Delta t = \\sum_{i=0}^{N-1} J_{0,i} \\Delta t \\implies \\sum_{i=0}^{N-1} (J_{0,i} + \\delta_i) = \\sum_{i=0}^{N-1} J_{0,i} \\implies \\sum_{i=0}^{N-1} \\delta_i = 0\n    $$\n    In vector form, this is $\\mathbf{1}^T \\boldsymbol{\\delta} = 0$, where $\\mathbf{1}$ is a vector of ones.\n\n2.  **Current Density Bounds**: The current density at each step must be within the specified limits.\n    $$\n    0 \\le J_i \\le J_{\\max} \\implies 0 \\le J_{0,i} + \\delta_i \\le J_{\\max} \\implies -J_{0,i} \\le \\delta_i \\le J_{\\max} - J_{0,i}\n    $$\n    These are box constraints on the decision variables $\\delta_i$.\n\n3.  **Linearized Thermal Constraints**: The cell temperature at the end of each interval must not exceed a maximum value $T_{\\max}$. The temperature evolution is linearized around the baseline trajectory $\\mathbf{T}^0 = (T_1^0, \\dots, T_N^0)$.\n    $$\n    T_{i+1}^0 + \\sum_{k=0}^{N-1} B_{i,k} \\delta_k \\le T_{\\max} \\quad \\text{for } i = 0, \\dots, N-1\n    $$\n    where $\\mathbf{B}$ is the $N \\times N$ thermal sensitivity matrix. This set of $N$ inequalities can be written as $\\mathbf{B} \\boldsymbol{\\delta} \\le \\mathbf{d}$, where the vector $\\mathbf{d}$ has components $d_i = T_{\\max} - T_{i+1}^0$.\n\nThe problem is a convex QP, as it involves minimizing a strictly convex quadratic function over a convex feasible set (defined by linear equalities and inequalities). Such a problem has a unique global minimum. We can solve it using a numerical optimization solver, such as the Sequential Least Squares Programming (SLSQP) algorithm available in `scipy.optimize.minimize`.\n\nThe solution proceeds in the following steps for each test case:\n\n**Step 1: Compute Baseline Temperature Trajectory**\nThe baseline temperature at the end of each interval, $T_{i+1}^0$, is calculated by iterating the discretized thermal model with the baseline current profile $\\mathbf{J}_0$. The recurrence relation is:\n$$\nT_{i+1}^0 = T_i^0 + \\frac{\\Delta t}{C_{\\mathrm{th}}} \\left( A_{\\mathrm{cell}}^2 J_{0,i}^2 R_{\\mathrm{int}} - \\frac{T_i^0 - T_{\\mathrm{env}}}{R_{\\mathrm{th}}} \\right), \\quad T_0^0 = T_{\\mathrm{init}}\n$$\nThis can be rewritten as $T_{i+1}^0 = \\phi T_i^0 + \\alpha J_{0,i}^2 + \\beta T_{\\mathrm{env}}$, where $\\phi = 1 - \\frac{\\Delta t}{C_{\\mathrm{th}}R_{\\mathrm{th}}}$, $\\alpha = \\frac{\\Delta t A_{\\mathrm{cell}}^2 R_{\\mathrm{int}}}{C_{\\mathrm{th}}}$, and $\\beta = \\frac{\\Delta t}{C_{\\mathrm{th}}R_{\\mathrm{th}}}$. The resulting temperatures $T_1^0, \\dots, T_N^0$ are used to define the thermal constraint bounds.\n\n**Step 2: Construct Thermal Sensitivity Matrix B**\nThe matrix $\\mathbf{B}$ contains the partial derivatives $B_{i,k} = \\frac{\\partial T_{i+1}}{\\partial J_k}$ evaluated at $\\mathbf{J} = \\mathbf{J}_0$. It has a lower triangular structure because the temperature at time step $i+1$ is not affected by future currents ($J_k$ for $k > i$). The entries are computed as:\n$$\nB_{i,k} =\n\\begin{cases}\n0 & \\text{if } k > i \\\\\n\\frac{2 \\Delta t A_{\\mathrm{cell}}^2 R_{\\mathrm{int}}}{C_{\\mathrm{th}}} J_{0,k} & \\text{if } k = i \\\\\n\\phi B_{i-1,k} & \\text{if } k < i\n\\end{cases}\n$$\n\n**Step 3: Solve the Quadratic Program**\nThe QP is formulated and solved numerically. The necessary components for the solver are:\n- The objective function $f(\\boldsymbol{\\delta}) = \\frac{1}{2}\\boldsymbol{\\delta}^T \\mathbf{H} \\boldsymbol{\\delta} + \\mathbf{g}^T \\boldsymbol{\\delta}$.\n- The gradient (Jacobian) of the objective: $\\nabla f(\\boldsymbol{\\delta}) = \\mathbf{H}\\boldsymbol{\\delta} + \\mathbf{g}$.\n- The equality constraint: $\\sum_{i=0}^{N-1} \\delta_i = 0$.\n- The inequality constraints: $T_{\\max} - T_{i+1}^0 - (\\mathbf{B}\\boldsymbol{\\delta})_i \\ge 0$ for $i=0, \\dots, N-1$. (Note the $\\ge 0$ form required by SciPy).\n- The bounds on variables: $-J_{0,i} \\le \\delta_i \\le J_{\\max} - J_{0,i}$.\n\nAn initial guess of $\\boldsymbol{\\delta} = \\mathbf{0}$ is provided to the solver. The output is the optimal adjustment vector $\\boldsymbol{\\delta}_{\\star}$.\n\n**Step 4: Compute Fractional Risk Reduction**\nThe optimal incremental risk, $\\Delta \\mathcal{R}(\\mathbf{J}_{\\star})$, is the value of the objective function at the solution $\\boldsymbol{\\delta}_{\\star}$. The counterfactual absolute risk is $\\mathcal{R}_{\\star} = \\mathcal{R}_0 + \\Delta \\mathcal{R}(\\mathbf{J}_{\\star})$. The fractional risk reduction, $\\rho$, is then calculated as:\n$$\n\\rho = \\frac{\\mathcal{R}_0 - \\mathcal{R}_{\\star}}{\\mathcal{R}_0} = \\frac{\\mathcal{R}_0 - (\\mathcal{R}_0 + \\Delta \\mathcal{R}(\\mathbf{J}_{\\star}))}{\\mathcal{R}_0} = - \\frac{\\Delta \\mathcal{R}(\\mathbf{J}_{\\star})}{\\mathcal{R}_0}\n$$\nThe final value is rounded to six decimal places as specified. This process is repeated for all test cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the constrained quadratic program for each test case to find the\n    optimal counterfactual charging protocol and reports the fractional risk reduction.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        {\n            'N': 4, 'dt': 60.0, 'A_cell': 0.01, 'R_int': 0.05, 'R_th': 5.0, \n            'C_th': 400.0, 'T_env': 298.15, 'T_init': 298.15, 'J_max': 150.0, \n            'T_max': 313.15, 'J0': [120.0, 120.0, 80.0, 80.0],\n            'g': [0.8, 0.6, 0.2, 0.1], 'h': [0.02, 0.02, 0.01, 0.01], 'R0': 10.0\n        },\n        # Test case 2\n        {\n            'N': 4, 'dt': 60.0, 'A_cell': 0.01, 'R_int': 0.05, 'R_th': 5.0,\n            'C_th': 400.0, 'T_env': 298.15, 'T_init': 298.15, 'J_max': 150.0,\n            'T_max': 303.15, 'J0': [100.0, 100.0, 100.0, 100.0],\n            'g': [1.0, 0.7, 0.2, 0.1], 'h': [0.02, 0.02, 0.01, 0.01], 'R0': 8.0\n        },\n        # Test case 3\n        {\n            'N': 4, 'dt': 30.0, 'A_cell': 0.01, 'R_int': 0.05, 'R_th': 5.0, \n            'C_th': 400.0, 'T_env': 298.15, 'T_init': 298.15, 'J_max': 110.0, \n            'T_max': 330.0, 'J0': [110.0, 110.0, 110.0, 110.0],\n            'g': [0.1, 0.1, 0.1, 0.1], 'h': [0.005, 0.005, 0.005, 0.005], 'R0': 12.0\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_case(params)\n        results.append(f\"{result:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\n\ndef _solve_case(params):\n    \"\"\"\n    Helper function to set up and solve the QP for a single test case.\n    \"\"\"\n    # 1. Unpack parameters and convert to numpy arrays\n    N = params['N']\n    dt = params['dt']\n    A_cell = params['A_cell']\n    R_int = params['R_int']\n    R_th = params['R_th']\n    C_th = params['C_th']\n    T_env = params['T_env']\n    T_init = params['T_init']\n    J_max = params['J_max']\n    T_max = params['T_max']\n    J0 = np.array(params['J0'])\n    g = np.array(params['g'])\n    h = np.array(params['h'])\n    R0 = params['R0']\n\n    # 2. Calculate baseline temperature trajectory\n    T0_traj = np.zeros(N + 1)\n    T0_traj[0] = T_init\n    \n    phi = 1.0 - dt / (C_th * R_th)\n    alpha = dt * A_cell**2 * R_int / C_th\n    beta_T_env = (dt / (C_th * R_th)) * T_env\n\n    for i in range(N):\n        T0_traj[i+1] = phi * T0_traj[i] + alpha * J0[i]**2 + beta_T_env\n\n    # 3. Construct the thermal sensitivity matrix B\n    B = np.zeros((N, N))\n    b_diag_factor = 2.0 * dt * A_cell**2 * R_int / C_th\n    for k in range(N):\n        B[k, k] = b_diag_factor * J0[k]\n        for i in range(k + 1, N):\n            B[i, k] = phi * B[i - 1, k]\n\n    # 4. Define the QP problem for the solver\n    # Decision variable is delta, the adjustment to J0\n    def objective(delta):\n        return 0.5 * np.sum(h * delta**2) + np.sum(g * delta)\n\n    def jacobian(delta):\n        return h * delta + g\n\n    # Equality constraint: sum of adjustments is zero (charge conservation)\n    eq_constraint = {'type': 'eq', 'fun': lambda delta: np.sum(delta)}\n\n    # Inequality constraints: thermal limits\n    # SLSQP expects constraints in the form C(x) >= 0.\n    # B @ delta <= T_max - T0_traj[1:] -> (T_max - T0_traj[1:]) - (B @ delta) >= 0\n    ineq_constraints = []\n    for i in range(N):\n        constraint_fun = lambda delta, i=i: (T_max - T0_traj[i + 1]) - np.dot(B[i, :], delta)\n        ineq_constraints.append({'type': 'ineq', 'fun': constraint_fun})\n\n    constraints = [eq_constraint] + ineq_constraints\n\n    # Bounds for each delta_i: -J0[i] <= delta_i <= J_max - J0[i]\n    bounds = [(-J0[i], J_max - J0[i]) for i in range(N)]\n    \n    # 5. Solve the QP\n    delta0 = np.zeros(N)\n    res = minimize(objective, delta0, method='SLSQP', jac=jacobian, \n                   bounds=bounds, constraints=constraints)\n\n    # 6. Calculate the final result (fractional risk reduction)\n    delta_R_star = res.fun\n    rho = -delta_R_star / R0\n    \n    return rho\n\nsolve()\n```"
        }
    ]
}