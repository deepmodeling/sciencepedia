{
    "hands_on_practices": [
        {
            "introduction": "我们首先探索一种最强大的可解释人工智能（XAI）技术——沙普利加性解释（SHAP），用于将模型的预测归因于其输入特征。本练习使用一个简化的正极材料共掺杂模型，来演示SHAP值不仅可以量化每种掺杂剂的独立效应，还能揭示它们之间的协同或拮抗相互作用。理解这些基本计算是解释复杂电池模型的第一步。",
            "id": "3913432",
            "problem": "考虑一个简化的、科学上合理的预测模型，该模型用于自动化电池设计和仿真，以估算层状氧化物正极因两种阳离子共掺杂而引起比容量（单位：毫安时/克）的变化。设掺杂剂摩尔分数为 $x_1$ 和 $x_2$（无量纲小数），模型预测值为\n$$\nf(x_1,x_2) = w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2,\n$$\n其中 $w_1$ 和 $w_2$ 的单位是每单位掺杂分数的 $\\mathrm{mAh/g}$，$w_{12}$ 的单位是每掺杂分数平方的 $\\mathrm{mAh/g}$。该模型捕捉了单个掺杂剂效应以及一个模拟正极化学中协同或拮抗作用的二元相互作用项。\n\n在可解释性人工智能（XAI）中，Shapley 加性解释（SHAP）使用合作博弈论将预测归因于输入特征。对于一个实例 $x=(x_1,x_2)$，定义干预价值函数为\n$$\nv(S) = f(x_S, b_{-S}),\n$$\n其中基线向量 $b=(b_1,b_2)$ 代表未掺杂的参考状态，即 $b_1=0$ 和 $b_2=0$。特征 $i$ 的 Shapley 值由合作博弈论定义给出\n$$\n\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|!(M-|S|-1)!}{M!}\\left[v(S \\cup \\{i\\}) - v(S)\\right],\n$$\n其中 $N=\\{1,2\\}$ 且 $M=|N|=2$。对 $(i,j)$ 的 Shapley 相互作用指数（干预形式）定义为\n$$\n\\phi_{ij} = \\sum_{S \\subseteq N \\setminus \\{i,j\\}} \\frac{|S|!(M-|S|-2)!}{(M-1)!}\\left[v(S \\cup \\{i,j\\}) - v(S \\cup \\{i\\}) - v(S \\cup \\{j\\}) + v(S)\\right].\n$$\n对于 $M=2$，这简化为\n$$\n\\phi_{12} = v(\\{1,2\\}) - v(\\{1\\}) - v(\\{2\\}) + v(\\emptyset).\n$$\n\n您的任务是实现一个程序，对每个提供的测试用例，计算：\n1. Shapley 值 $\\phi_1$ 和 $\\phi_2$，单位为 $\\mathrm{mAh/g}$。\n2. Shapley 相互作用指数 $\\phi_{12}$，单位为 $\\mathrm{mAh/g}$。\n3. 一个布尔协同作用标志，如果 $\\phi_{12} > 0$ 则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$，将正相互作用解释为协同共掺杂，非正相互作用解释为拮抗或中性。\n4. 一个布尔守恒性检验，如果 $\\phi_1 + \\phi_2$ 在 $10^{-12}$ 的绝对容差内等于 $f(x_1,x_2) - f(b_1,b_2)$，则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n所有浮点数输出必须四舍五入到 $6$ 位小数，并以 $\\mathrm{mAh/g}$ 表示。掺杂剂分数 $x_1$ 和 $x_2$ 必须作为小数（而非百分比）处理。\n\n使用以下测试套件（每个元组为 $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2)$）：\n- 案例 A（典型的协同共掺杂）：$(50.0, 30.0, 40.0, 0.02, 0.03, 0.0, 0.0)$。\n- 案例 B（拮抗共掺杂）：$(50.0, 60.0, -80.0, 0.01, 0.02, 0.0, 0.0)$。\n- 案例 C（无相互作用，仅存在单一掺杂剂）：$(45.0, 20.0, 0.0, 0.05, 0.0, 0.0, 0.0)$。\n- 案例 D（边界情况，一种掺杂剂缺失，正相互作用系数）：$(35.0, 25.0, 100.0, 0.0, 0.04, 0.0, 0.0)$。\n- 案例 E（有害的单一掺杂剂，具有弱协同作用）：$( -10.0, 40.0, 10.0, 0.03, 0.03, 0.0, 0.0)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。此列表中的每个元素对应一个测试用例，并且本身必须是 $[\\phi_1,\\phi_2,\\phi_{12},\\mathrm{synergy},\\mathrm{conservation}]$ 形式的列表，其中 $\\phi_1$、$\\phi_2$ 和 $\\phi_{12}$ 是四舍五入到 $6$ 位小数的浮点数（单位为 $\\mathrm{mAh/g}$），而 $\\mathrm{synergy}$ 和 $\\mathrm{conservation}$ 是布尔值。例如，输出应类似于 $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$，不带任何附加文本。",
            "solution": "首先验证问题，以确保其具有科学依据、良构且客观。\n\n### 第1步：提取已知条件\n- **预测模型**：比容量的变化由函数 $f(x_1, x_2) = w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2$ 给出，其中 $x_1$ 和 $x_2$ 是掺杂剂摩尔分数。\n- **干预价值函数**：$v(S) = f(x_S, b_{-S})$。\n- **基线向量**：未掺杂的参考状态是 $b = (b_1, b_2) = (0, 0)$。\n- **特征数量**：$M = |N| = 2$，其中 $N = \\{1, 2\\}$。\n- **Shapley 值公式**：$\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|!(M-|S|-1)!}{M!}\\left[v(S \\cup \\{i\\}) - v(S)\\right]$。\n- **Shapley 相互作用指数公式（对于 $M=2$）**：$\\phi_{12} = v(\\{1,2\\}) - v(\\{1\\}) - v(\\{2\\}) + v(\\emptyset)$。\n- **任务**：\n  1. 计算 Shapley 值 $\\phi_1$ 和 $\\phi_2$。\n  2. 计算 Shapley 相互作用指数 $\\phi_{12}$。\n  3. 确定协同作用标志：如果 $\\phi_{12} > 0$ 则为 $\\mathrm{True}$。\n  4. 执行守恒性检验：如果 $|\\phi_1 + \\phi_2 - (f(x_1,x_2) - f(b_1,b_2))| \\le 10^{-12}$ 则为 $\\mathrm{True}$。\n- **输出要求**：浮点值必须四舍五入到 $6$ 位小数。\n- **测试用例**：\n  - A: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = (50.0, 30.0, 40.0, 0.02, 0.03, 0.0, 0.0)$。\n  - B: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = (50.0, 60.0, -80.0, 0.01, 0.02, 0.0, 0.0)$。\n  - C: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = (45.0, 20.0, 0.0, 0.05, 0.0, 0.0, 0.0)$。\n  - D: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = (35.0, 25.0, 100.0, 0.0, 0.04, 0.0, 0.0)$。\n  - E: $(w_1,w_2,w_{12},x_1,x_2,b_1,b_2) = ( -10.0, 40.0, 10.0, 0.03, 0.03, 0.0, 0.0)$。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学依据**：该问题基于材料科学和可解释性人工智能。预测模型是一个简单的多项式，这是材料信息学中常见的起点。使用 Shapley 值进行特征归因是 XAI 中一种标准的、数学上严谨的方法。正极共掺杂的背景具有科学相关性。问题有效。\n- **良构性**：该问题提供了所有必需的公式、数据和一组明确的任务。对于每个输入测试用例，可以通过直接应用所提供的定义计算出一组唯一的输出。问题有效。\n- **客观性**：所有术语都经过数学定义。任务是定量的，基于提供的模型和定义，没有主观解释。问题有效。\n- **结论**：该问题不违反任何无效性标准。它是完整的、一致的、科学上合理的和良构的。\n\n### 第3步：结论与行动\n问题有效。将开发一个解决方案。\n\n### 基于原则的设计和解决方案\n\n问题的核心是为给定的预测模型 $f(x_1, x_2)$ 推导 Shapley 值和相互作用指数的解析表达式。这避免了数值近似，并提供了精确的解决方案。\n\n首先，我们为所有可能的子集 $S \\subseteq N = \\{1, 2\\}$ 计算干预价值函数 $v(S)$。实例是 $x = (x_1, x_2)$，基线是 $b = (0, 0)$。\n\n1.  $S = \\emptyset$：特征子集为空。我们对所有特征使用基线值。\n    $v(\\emptyset) = f(b_1, b_2) = f(0, 0) = w_1(0) + w_2(0) + w_{12}(0)(0) = 0$。\n\n2.  $S = \\{1\\}$：我们对特征 $1$ 使用实例值 ($x_1$)，对特征 $2$ 使用基线值 ($b_2$)。\n    $v(\\{1\\}) = f(x_1, b_2) = f(x_1, 0) = w_1 x_1 + w_2(0) + w_{12}x_1(0) = w_1 x_1$。\n\n3.  $S = \\{2\\}$：我们对特征 $1$ 使用基线值 ($b_1$)，对特征 $2$ 使用实例值 ($x_2$)。\n    $v(\\{2\\}) = f(b_1, x_2) = f(0, x_2) = w_1(0) + w_2 x_2 + w_{12}(0)x_2 = w_2 x_2$。\n\n4.  $S = \\{1, 2\\}$：我们对两个特征都使用实例值。\n    $v(\\{1, 2\\}) = f(x_1, x_2) = w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2$。\n\n有了这些值，我们就可以计算 Shapley 值 $\\phi_1$ 和 $\\phi_2$。对于 $M=2$ 个特征，通用的 Shapley 公式得以简化。特征 $i$ 的 Shapley 值是其在所有可能的特征排序上的边际贡献的平均值。对于两个特征，两种排序是 $(1, 2)$ 和 $(2, 1)$。\n\n当特征 $1$ 首先添加时，其边际贡献为 $v(\\{1\\}) - v(\\emptyset)$。\n当特征 $1$ 第二个添加时（在特征 $2$ 之后），其边际贡献为 $v(\\{1, 2\\}) - v(\\{2\\})$。\nShapley 值 $\\phi_1$ 是这两个贡献的平均值：\n$$\n\\phi_1 = \\frac{1}{2} \\left[ (v(\\{1\\}) - v(\\emptyset)) + (v(\\{1, 2\\}) - v(\\{2\\})) \\right]\n$$\n代入先前计算的值：\n$$\n\\phi_1 = \\frac{1}{2} \\left[ (w_1 x_1 - 0) + ( (w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2) - w_2 x_2 ) \\right]\n$$\n$$\n\\phi_1 = \\frac{1}{2} \\left[ w_1 x_1 + w_1 x_1 + w_{12} x_1 x_2 \\right] = \\frac{1}{2} \\left[ 2 w_1 x_1 + w_{12} x_1 x_2 \\right]\n$$\n$$\n\\phi_1 = w_1 x_1 + \\frac{1}{2} w_{12} x_1 x_2\n$$\n根据对称性，交换索引 $1$ 和 $2$，我们得到 $\\phi_2$：\n$$\n\\phi_2 = w_2 x_2 + \\frac{1}{2} w_{12} x_1 x_2\n$$\n接下来，我们使用 $M=2$ 的简化公式计算 Shapley 相互作用指数 $\\phi_{12}$：\n$$\n\\phi_{12} = v(\\{1,2\\}) - v(\\{1\\}) - v(\\{2\\}) + v(\\emptyset)\n$$\n代入我们的值：\n$$\n\\phi_{12} = (w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2) - (w_1 x_1) - (w_2 x_2) + 0\n$$\n$$\n\\phi_{12} = w_{12} x_1 x_2\n$$\n这个结果是直观的：相互作用指数分离了模型中相互作用项 $w_{12} x_1 x_2$ 的贡献。Shapley 值 $\\phi_1$ 和 $\\phi_2$ 将单个线性效应（$w_1 x_1$ 和 $w_2 x_2$）完全归因于特征 $1$ 和 $2$，并将相互作用效应（$w_{12} x_1 x_2$）在它们之间平均分配。\n\n如果 $\\phi_{12} > 0$，则协同作用标志为 $\\mathrm{True}$，这对应于正（协同）的相互作用效应。\n\n最后，我们执行守恒性检验。这是 Shapley 值的一个基本属性，称为效率（efficiency）。Shapley 值的总和必须等于从基线开始的预测总变化量。\n$$\n\\phi_1 + \\phi_2 = (w_1 x_1 + \\frac{1}{2} w_{12} x_1 x_2) + (w_2 x_2 + \\frac{1}{2} w_{12} x_1 x_2) = w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2\n$$\n从基线开始的预测变化是：\n$$\nf(x_1, x_2) - f(b_1, b_2) = f(x_1, x_2) - f(0, 0) = (w_1 x_1 + w_2 x_2 + w_{12} x_1 x_2) - 0\n$$\n因此，我们发现 $\\phi_1 + \\phi_2 = f(x_1, x_2) - f(b_1, b_2)$ 精确成立。守恒性检验在所有情况下都应为 $\\mathrm{True}$，它可作为对实现正确性（对抗浮点运算错误）的稳健验证。\n\n算法如下：\n1. 对于每个测试用例 $(w_1, w_2, w_{12}, x_1, x_2, b_1, b_2)$：\n2. 计算相互作用项效应：$I = w_{12} x_1 x_2$。\n3. 计算 $\\phi_{12} = I$。\n4. 计算 $\\phi_1 = w_1 x_1 + \\frac{1}{2} I$。\n5. 计算 $\\phi_2 = w_2 x_2 + \\frac{1}{2} I$。\n6. 确定协同作用：$\\phi_{12} > 0$。\n7. 执行守恒性检验：$|\\phi_1 + \\phi_2 - (w_1 x_1 + w_2 x_2 + I)| \\le 10^{-12}$。\n8. 将 $\\phi_1, \\phi_2, \\phi_{12}$ 四舍五入到 $6$ 位小数。\n9. 将结果整理成一个列表。\n10. 聚合所有测试用例的结果并格式化最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Calculates Shapley values and interaction indices for a battery cathode model\n    and prints the results for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (w1, w2, w12, x1, x2, b1, b2).\n    test_cases = [\n        # Case A (typical synergistic co-doping)\n        (50.0, 30.0, 40.0, 0.02, 0.03, 0.0, 0.0),\n        # Case B (antagonistic co-doping)\n        (50.0, 60.0, -80.0, 0.01, 0.02, 0.0, 0.0),\n        # Case C (no interaction, single-dopant present)\n        (45.0, 20.0, 0.0, 0.05, 0.0, 0.0, 0.0),\n        # Case D (boundary with one dopant absent, positive interaction coefficient)\n        (35.0, 25.0, 100.0, 0.0, 0.04, 0.0, 0.0),\n        # Case E (harmful single dopant with weak synergy)\n        (-10.0, 40.0, 10.0, 0.03, 0.03, 0.0, 0.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        w1, w2, w12, x1, x2, b1, b2 = case\n\n        # The predictive model is f(x1, x2) = w1*x1 + w2*x2 + w12*x1*x2.\n        # The baseline is b = (0, 0), so f(b1, b2) = 0.\n        \n        # 1. Calculate Shapley interaction index phi_12\n        # phi_12 = v({1,2}) - v({1}) - v({2}) + v(0)\n        # v({1,2}) = f(x1, x2) = w1*x1 + w2*x2 + w12*x1*x2\n        # v({1}) = f(x1, 0) = w1*x1\n        # v({2}) = f(0, x2) = w2*x2\n        # v(0) = f(0, 0) = 0\n        # phi_12 = (w1*x1 + w2*x2 + w12*x1*x2) - (w1*x1) - (w2*x2) + 0\n        # phi_12 = w12 * x1 * x2\n        phi_12 = w12 * x1 * x2\n\n        # 2. Calculate Shapley values phi_1 and phi_2\n        # phi_1 = w1*x1 + 0.5 * w12*x1*x2\n        # phi_2 = w2*x2 + 0.5 * w12*x1*x2\n        phi_1 = w1 * x1 + 0.5 * phi_12\n        phi_2 = w2 * x2 + 0.5 * phi_12\n\n        # 3. Determine synergy flag\n        # True if phi_12 > 0\n        synergy = phi_12 > 0\n\n        # 4. Perform conservation check\n        # Check if phi_1 + phi_2 = f(x1, x2) - f(b1, b2)\n        f_x = w1 * x1 + w2 * x2 + w12 * x1 * x2\n        f_b = w1 * b1 + w2 * b2 + w12 * b1 * b2 # This is always 0 for the given cases.\n        total_effect = f_x - f_b\n        shapley_sum = phi_1 + phi_2\n        \n        # Use a tolerance for floating point comparison\n        conservation = abs(shapley_sum - total_effect) = 1e-12\n        \n        # Round the float outputs to 6 decimal places.\n        phi_1_rounded = round(phi_1, 6)\n        phi_2_rounded = round(phi_2, 6)\n        phi_12_rounded = round(phi_12, 6)\n\n        results.append([\n            phi_1_rounded,\n            phi_2_rounded,\n            phi_12_rounded,\n            synergy,\n            conservation\n        ])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, represented as a string.\n    # e.g., [[val1, val2,...], [val1, val2,...]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个解释只有当它忠实于其所解释的模型时才是有用的。本练习将介绍一项关键技能：验证XAI系统的可靠性。通过将基于梯度的解释所预测的性能变化与来自机理模型的实际结果进行比较，您将学会如何量化解释的准确性，并判断其是否可信赖以指导真实世界的设计决策。",
            "id": "3913419",
            "problem": "一个可解释人工智能（AI）模型对锂离子电池电极设计提出了“解释引导的消融变化”，并声称其基于局部梯度的解释能够准确预测微小设计调整对能量密度和放电电压的影响。您的任务是通过计算基于物理梯度的“一阶预测”，并将其与机理模型的观测结果进行比较，从而严格验证这些可解释性声明。您的任务是实现一个程序，针对多个测试用例，执行以下步骤：在基线设计处计算梯度，应用解释引导的设计变更，形成输出变化的一阶预测，在机理模型上评估相同的变化以获得观测到的变化，并量化绝对误差和声明的验证布尔值。\n\n使用以下源自等效电路建模和有效介质理论的物理基础：\n\n- 欧姆定律：恒定电流下的端电压由 $$V = U_{\\mathrm{oc}} - I R$$ 给出。\n- 使用 Bruggeman 关系的有效电导率：$$\\sigma_{\\mathrm{eff}} = \\sigma_{0}\\,\\varepsilon^{\\alpha},$$ 其中 $\\varepsilon$ 是孔隙率，$\\alpha$ 是 Bruggeman 指数，$\\sigma_{0}$ 是本征电导率。\n- 厚度方向电阻：$$R = \\dfrac{L}{A\\,\\sigma_{\\mathrm{eff}}} = \\dfrac{L}{A\\,\\sigma_{0}\\,\\varepsilon^{\\alpha}},$$ 其中 $L$ 是涂层厚度，$A$ 是电极面积。\n- 极化下的比容量利用率，建模为有理惩罚项：$$u = \\dfrac{1}{1 + \\beta\\,R\\,I} = \\dfrac{1}{1 + \\beta\\,I\\,\\dfrac{L}{A\\,\\sigma_{0}\\,\\varepsilon^{\\alpha}}},$$ 其中 $\\beta$ 是一个捕获利用率对极化敏感度的正常数。\n- 单位质量能量密度：$$E = U_{\\mathrm{oc}}\\,Q_{\\mathrm{spec}} = U_{\\mathrm{oc}}\\,f_{\\mathrm{am}}\\,q_{\\mathrm{th}}\\,u,$$ 其中 $f_{\\mathrm{am}}$ 是活性物质质量分数，$q_{\\mathrm{th}}$ 是理论比容量。\n\n该解释系统声称，输出相对于设计变量的局部梯度可以预测由微小设计修改引起的变化。考虑设计变量 $\\varepsilon$、$f_{\\mathrm{am}}$ 和 $L$。在基线设计点，获取一阶预测所需的梯度。通过一阶泰勒近似，形成预测的能量密度变化 $\\Delta E_{\\mathrm{pred}}$ 和预测的端电压变化 $\\Delta V_{\\mathrm{pred}}$：\n$$\\Delta E_{\\mathrm{pred}} = \\left(\\dfrac{\\partial E}{\\partial \\varepsilon}\\right)\\Delta \\varepsilon + \\left(\\dfrac{\\partial E}{\\partial f_{\\mathrm{am}}}\\right)\\Delta f_{\\mathrm{am}} + \\left(\\dfrac{\\partial E}{\\partial L}\\right)\\Delta L,$$\n$$\\Delta V_{\\mathrm{pred}} = \\left(\\dfrac{\\partial V}{\\partial \\varepsilon}\\right)\\Delta \\varepsilon + \\left(\\dfrac{\\partial V}{\\partial L}\\right)\\Delta L + \\left(\\dfrac{\\partial V}{\\partial f_{\\mathrm{am}}}\\right)\\Delta f_{\\mathrm{am}},$$\n然后使用上述机理模型计算观测到的变化 $\\Delta E_{\\mathrm{obs}} = E(\\varepsilon+\\Delta \\varepsilon, f_{\\mathrm{am}}+\\Delta f_{\\mathrm{am}}, L+\\Delta L) - E(\\varepsilon, f_{\\mathrm{am}}, L)$ 和 $\\Delta V_{\\mathrm{obs}} = V(\\varepsilon+\\Delta \\varepsilon, f_{\\mathrm{am}}+\\Delta f_{\\mathrm{am}}, L+\\Delta L) - V(\\varepsilon, f_{\\mathrm{am}}, L)$。\n\n为确保设计在物理上是现实的，在应用变化后将更新的变量裁剪到可行范围内：强制 $0  \\varepsilon  1$，$0  f_{\\mathrm{am}}  1$，以及 $L  0$。对于 $\\varepsilon$ 和 $f_{\\mathrm{am}}$，应裁剪到 $(10^{-6}, 1-10^{-6})$ 范围内；对于 $L$，应裁剪到 $[10^{-6}, \\infty)$ 范围内。\n\n对于每个测试用例，计算：\n- 能量密度变化的绝对误差，$$\\mathrm{err}_{E} = \\left|\\Delta E_{\\mathrm{pred}} - \\Delta E_{\\mathrm{obs}}\\right|,$$ 以 $\\mathrm{Wh}/\\mathrm{kg}$ 为单位。\n- 电压变化的绝对误差，$$\\mathrm{err}_{V} = \\left|\\Delta V_{\\mathrm{pred}} - \\Delta V_{\\mathrm{obs}}\\right|,$$ 以 $\\mathrm{V}$ 为单位。\n- 一个验证布尔值 $$\\mathrm{valid} = \\left(\\mathrm{err}_{E} \\le \\tau_{E}\\right) \\land \\left(\\mathrm{err}_{V} \\le \\tau_{V}\\right),$$ 其中 $\\tau_{E}$ 和 $\\tau_{V}$ 是固定的容差。\n\n所有测试用例共享的常数：\n- $U_{\\mathrm{oc}} = 3.7$ $\\mathrm{V}$。\n- $q_{\\mathrm{th}} = 180.0$ $\\mathrm{Ah}/\\mathrm{kg}$。\n- $\\sigma_{0} = 5.0$ $\\mathrm{S}/\\mathrm{m}$。\n- $\\alpha = 1.5$。\n- $A = 0.01$ $\\mathrm{m}^{2}$。\n- $I = 5.0$ $\\mathrm{A}$。\n- $\\beta = 0.2$ $\\mathrm{V}^{-1}$。\n- $\\tau_{E} = 1.0$ $\\mathrm{Wh}/\\mathrm{kg}$。\n- $\\tau_{V} = 0.01$ $\\mathrm{V}$。\n\n基线和解释引导变化的测试套件：\n- 案例 1（正常路径）：基线 $(\\varepsilon, f_{\\mathrm{am}}, L) = (0.40, 0.90, 1.0\\times 10^{-4}\\,\\mathrm{m})$，变化 $(\\Delta \\varepsilon, \\Delta f_{\\mathrm{am}}, \\Delta L) = (+0.05, +0.01, -1.0\\times 10^{-5}\\,\\mathrm{m})$。\n- 案例 2（边界压力测试）：基线 $(\\varepsilon, f_{\\mathrm{am}}, L) = (0.30, 0.92, 2.0\\times 10^{-4}\\,\\mathrm{m})$，变化 $(\\Delta \\varepsilon, \\Delta f_{\\mathrm{am}}, \\Delta L) = (+0.25, -0.02, -5.0\\times 10^{-5}\\,\\mathrm{m})$。\n- 案例 3（特定特征消融）：基线 $(\\varepsilon, f_{\\mathrm{am}}, L) = (0.60, 0.88, 8.0\\times 10^{-5}\\,\\mathrm{m})$，变化 $(\\Delta \\varepsilon, \\Delta f_{\\mathrm{am}}, \\Delta L) = (0.0, +0.05, 0.0)$。\n\n您的程序必须：\n- 完全按照规定实现机理模型。\n- 使用第一性原理计算基线处的物理梯度。\n- 对每个案例，应用变化并裁剪到可行范围，然后计算预测和观测到的变化、误差以及验证布尔值。\n- 将能量密度误差以 $\\mathrm{Wh}/\\mathrm{kg}$ 表示，电压误差以 $\\mathrm{V}$ 表示，均为浮点数。\n- 生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\mathrm{err}_{E}^{(1)}, \\mathrm{err}_{V}^{(1)}, \\mathrm{valid}^{(1)}, \\mathrm{err}_{E}^{(2)}, \\mathrm{err}_{V}^{(2)}, \\mathrm{valid}^{(2)}, \\mathrm{err}_{E}^{(3)}, \\mathrm{err}_{V}^{(3)}, \\mathrm{valid}^{(3)}]$，其中浮点数四舍五入到 $6$ 位小数，布尔值不带引号。\n\n本任务不涉及任何角度量；无需指定角度单位。所有物理量必须按上述指定单位计算和报告，所有数值答案必须是定义的浮点数或布尔值。程序必须是自包含的，且不得读取任何外部输入。",
            "solution": "该问题陈述在科学和数学上是合理的，提供了一项定义明确的任务，即使用一个简化但有物理基础的机理电池模型来验证一个可解释 AI 模型的声明。所有常数、变量和程序都已明确定义，从而可以得到唯一且可验证的解。底层的模型，包括欧姆定律、用于有效电导率的 Bruggeman 关系以及能量密度的公式，均符合电化学工程的原理。该验证任务将一阶泰勒近似与完整模型进行比较，是评估基于梯度的局部解释准确性的标准方法。\n\n解决方案主要分三步进行：首先，我们正式定义电池能量密度和电压的机理模型。其次，我们推导这些输出相对于设计变量的解析梯度。第三，我们概述用于评估测试用例的计算过程。\n\n机理模型的核心建立在以下方程之上。电极的内阻 $R$ 由下式给出：\n$$ R = \\dfrac{L}{A\\,\\sigma_{0}\\,\\varepsilon^{\\alpha}} $$\n其中 $L$ 是电极厚度，$A$ 是其面积，$\\sigma_0$ 是本征电导率，$\\varepsilon$ 是孔隙率，$\\alpha$ 是 Bruggeman 指数。\n\n比容量利用率 $u$ 是一个介于 0 和 1 之间的无量纲因子，用于解释因极化造成的性能损失，其模型为：\n$$ u = \\dfrac{1}{1 + \\beta\\,I\\,R} = \\left(1 + \\dfrac{\\beta\\,I\\,L}{A\\,\\sigma_{0}\\,\\varepsilon^{\\alpha}}\\right)^{-1} $$\n此处，$I$ 是放电电流，$\\beta$ 是一个极化敏感度常数。\n\n利用这些中间量，两个主要输出——单位质量能量密度 $E$ 和端电压 $V$——定义如下：\n$$ E = U_{\\mathrm{oc}}\\,f_{\\mathrm{am}}\\,q_{\\mathrm{th}}\\,u $$\n$$ V = U_{\\mathrm{oc}} - I\\,R $$\n其中 $U_{\\mathrm{oc}}$ 是开路电压，$f_{\\mathrm{am}}$ 是活性物质质量分数，$q_{\\mathrm{th}}$ 是理论比容量。\n\n为了验证 AI 的解释，我们计算 $E$ 和 $V$ 相对于设计变量 $\\varepsilon$、$f_{\\mathrm{am}}$ 和 $L$ 的一阶偏导数（梯度）。使用链式法则，我们推导出以下六个梯度：\n\n对于能量密度 $E$：\n1.  相对于孔隙率 $\\varepsilon$：\n    $$ \\dfrac{\\partial E}{\\partial \\varepsilon} = U_{\\mathrm{oc}}\\,f_{\\mathrm{am}}\\,q_{\\mathrm{th}}\\,\\dfrac{\\partial u}{\\partial \\varepsilon} = U_{\\mathrm{oc}}\\,f_{\\mathrm{am}}\\,q_{\\mathrm{th}}\\left( -u^2 \\cdot \\dfrac{\\beta I L}{A \\sigma_0} \\cdot (-\\alpha \\varepsilon^{-\\alpha-1}) \\right) = \\alpha \\left(U_{\\mathrm{oc}}\\,f_{\\mathrm{am}}\\,q_{\\mathrm{th}}\\,u\\right) u \\left(\\dfrac{\\beta I L}{A \\sigma_0 \\varepsilon^{\\alpha+1}}\\right) $$\n2.  相对于活性物质质量分数 $f_{\\mathrm{am}}$：\n    $$ \\dfrac{\\partial E}{\\partial f_{\\mathrm{am}}} = U_{\\mathrm{oc}}\\,q_{\\mathrm{th}}\\,u = \\dfrac{E}{f_{\\mathrm{am}}} $$\n3.  相对于厚度 $L$：\n    $$ \\dfrac{\\partial E}{\\partial L} = U_{\\mathrm{oc}}\\,f_{\\mathrm{am}}\\,q_{\\mathrm{th}}\\,\\dfrac{\\partial u}{\\partial L} = U_{\\mathrm{oc}}\\,f_{\\mathrm{am}}\\,q_{\\mathrm{th}}\\left( -u^2 \\cdot \\dfrac{\\beta I}{A \\sigma_0 \\varepsilon^\\alpha} \\right) = - \\left(U_{\\mathrm{oc}}\\,f_{\\mathrm{am}}\\,q_{\\mathrm{th}}\\,u\\right) u \\left(\\dfrac{\\beta I}{A \\sigma_0 \\varepsilon^\\alpha}\\right) $$\n\n对于端电压 $V$：\n1.  相对于孔隙率 $\\varepsilon$：\n    $$ \\dfrac{\\partial V}{\\partial \\varepsilon} = -I\\,\\dfrac{\\partial R}{\\partial \\varepsilon} = -I \\left( \\dfrac{L}{A \\sigma_0} \\cdot (-\\alpha \\varepsilon^{-\\alpha-1}) \\right) = \\dfrac{\\alpha I L}{A \\sigma_0 \\varepsilon^{\\alpha+1}} $$\n2.  相对于活性物质质量分数 $f_{\\mathrm{am}}$：\n    $$ \\dfrac{\\partial V}{\\partial f_{\\mathrm{am}}} = 0 $$\n    因为 $V$ 不是 $f_{\\mathrm{am}}$ 的函数。\n3.  相对于厚度 $L$：\n    $$ \\dfrac{\\partial V}{\\partial L} = -I\\,\\dfrac{\\partial R}{\\partial L} = -I \\left( \\dfrac{1}{A \\sigma_0 \\varepsilon^\\alpha} \\right) = -\\dfrac{R}{L} $$\n\n对于每个测试用例，验证过程如下：\n1.  使用初始设计参数 $(\\varepsilon, f_{\\mathrm{am}}, L)$，通过机理模型计算基线输出 $E_{base}$ 和 $V_{base}$。\n2.  在此基线点上评估六个偏导数。\n3.  使用给定的设计变化 $(\\Delta \\varepsilon, \\Delta f_{\\mathrm{am}}, \\Delta L)$，通过一阶泰勒近似计算预测的变化量 $\\Delta E_{\\mathrm{pred}}$ 和 $\\Delta V_{\\mathrm{pred}}$：\n    $$ \\Delta E_{\\mathrm{pred}} = \\dfrac{\\partial E}{\\partial \\varepsilon}\\Delta \\varepsilon + \\dfrac{\\partial E}{\\partial f_{\\mathrm{am}}}\\Delta f_{\\mathrm{am}} + \\dfrac{\\partial E}{\\partial L}\\Delta L $$\n    $$ \\Delta V_{\\mathrm{pred}} = \\dfrac{\\partial V}{\\partial \\varepsilon}\\Delta \\varepsilon + \\dfrac{\\partial V}{\\partial f_{\\mathrm{am}}}\\Delta f_{\\mathrm{am}} + \\dfrac{\\partial V}{\\partial L}\\Delta L $$\n4.  通过将增量加到基线来确定新的设计点 $(\\varepsilon_{new}, f_{\\mathrm{am, new}}, L_{new})$。这些新参数被裁剪到物理可行范围内：$\\varepsilon_{new} \\in (10^{-6}, 1-10^{-6})$，$f_{\\mathrm{am, new}} \\in (10^{-6}, 1-10^{-6})$，以及 $L_{new} \\ge 10^{-6}$。\n5.  使用*裁剪后*的新参数，通过机理模型计算新的输出 $E_{new}$ 和 $V_{new}$。\n6.  计算观测到的变化：$\\Delta E_{\\mathrm{obs}} = E_{new} - E_{base}$ 和 $\\Delta V_{\\mathrm{obs}} = V_{new} - V_{base}$。\n7.  量化绝对误差 $\\mathrm{err}_{E} = \\left|\\Delta E_{\\mathrm{pred}} - \\Delta E_{\\mathrm{obs}}\\right|$ 和 $\\mathrm{err}_{V} = \\left|\\Delta V_{\\mathrm{pred}} - \\Delta V_{\\mathrm{obs}}\\right|$。\n8.  通过将误差与给定的容差进行比较来确定验证布尔值 $\\mathrm{valid}$：$\\mathrm{valid} = (\\mathrm{err}_{E} \\le \\tau_{E}) \\land (\\mathrm{err}_{V} \\le \\tau_{V})$。\n\n这个严谨的过程允许在不同条件下（包括小扰动、大扰动和特定特征消融）对基于梯度的解释的准确性进行定量评估。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs the validation of XAI claims for battery electrode design.\n    \"\"\"\n    # Define shared constants\n    U_oc = 3.7  # V\n    q_th = 180.0  # Ah/kg\n    sigma_0 = 5.0  # S/m\n    alpha = 1.5  # Bruggeman exponent\n    A = 0.01  # m^2\n    I = 5.0  # A\n    beta = 0.2  # V^-1\n    tau_E = 1.0  # Wh/kg\n    tau_V = 0.01  # V\n\n    # Define test cases: (baseline_params, delta_params)\n    # baseline_params: (epsilon, f_am, L)\n    # delta_params: (delta_epsilon, delta_f_am, delta_L)\n    test_cases = [\n        # Case 1: Happy path\n        ((0.40, 0.90, 1.0e-4), (0.05, 0.01, -1.0e-5)),\n        # Case 2: Boundary stress\n        ((0.30, 0.92, 2.0e-4), (0.25, -0.02, -5.0e-5)),\n        # Case 3: Feature-specific ablation\n        ((0.60, 0.88, 8.0e-5), (0.0, 0.05, 0.0)),\n    ]\n\n    results = []\n\n    def mechanistic_model(params):\n        \"\"\"\n        Computes energy density (E) and terminal voltage (V) from design parameters.\n        \"\"\"\n        eps, f_am, L = params\n        \n        # Avoid division by zero or negative powers if eps is invalid, though clipping handles this.\n        if eps = 0:\n            return -np.inf, -np.inf\n\n        # Resistance\n        R = L / (A * sigma_0 * eps**alpha)\n        \n        # Utilization\n        u_denominator = 1.0 + beta * I * R\n        u = 1.0 / u_denominator if u_denominator > 0 else np.inf\n        \n        # Energy Density (Wh/kg)\n        E = U_oc * f_am * q_th * u\n        # Note: q_th is in Ah/kg, U_oc is in V. Product is Wh/kg.\n        \n        # Terminal Voltage\n        V = U_oc - I * R\n        \n        return E, V\n\n    def compute_gradients(params):\n        \"\"\"\n        Computes the partial derivatives of E and V with respect to the design parameters.\n        \"\"\"\n        eps, f_am, L = params\n        \n        # Pre-compute baseline model outputs\n        E_base, V_base = mechanistic_model(params)\n        R_base = (U_oc - V_base) / I\n        \n        u_denominator = 1.0 + beta * I * R_base\n        u_base = 1.0 / u_denominator if u_denominator > 0 else np.inf\n\n        # Gradients for E\n        # dE/deps\n        term1 = U_oc * f_am * q_th\n        term2 = -u_base**2\n        term3 = (beta * I * L) / (A * sigma_0)\n        term4 = -alpha * eps**(-alpha - 1.0)\n        grad_E_eps = term1 * term2 * term3 * term4\n\n        # dE/df_am\n        grad_E_fam = U_oc * q_th * u_base if f_am > 0 else 0\n\n        # dE/dL\n        term5 = (beta * I) / (A * sigma_0 * eps**alpha)\n        grad_E_L = term1 * term2 * term5\n\n        # Gradients for V\n        # dV/deps\n        grad_V_eps = (alpha * I * L) / (A * sigma_0 * eps**(alpha + 1.0))\n\n        # dV/df_am\n        grad_V_fam = 0.0\n\n        # dV/dL\n        grad_V_L = -I / (A * sigma_0 * eps**alpha)\n        \n        return grad_E_eps, grad_E_fam, grad_E_L, grad_V_eps, grad_V_fam, grad_V_L\n\n    for baseline_params, delta_params in test_cases:\n        # 1. Baseline Calculation\n        E_base, V_base = mechanistic_model(baseline_params)\n        \n        # 2. Gradient Calculation\n        grads = compute_gradients(baseline_params)\n        grad_E_eps, grad_E_fam, grad_E_L, grad_V_eps, grad_V_fam, grad_V_L = grads\n        \n        # 3. Prediction Calculation\n        d_eps, d_fam, d_L = delta_params\n        dE_pred = grad_E_eps * d_eps + grad_E_fam * d_fam + grad_E_L * d_L\n        dV_pred = grad_V_eps * d_eps + grad_V_fam * d_fam + grad_V_L * d_L\n\n        # 4. New State Calculation and Clipping\n        eps_new_unclipped = baseline_params[0] + d_eps\n        fam_new_unclipped = baseline_params[1] + d_fam\n        L_new_unclipped = baseline_params[2] + d_L\n        \n        eps_new_clipped = np.clip(eps_new_unclipped, 1e-6, 1.0 - 1e-6)\n        fam_new_clipped = np.clip(fam_new_unclipped, 1e-6, 1.0 - 1e-6)\n        L_new_clipped = np.maximum(1e-6, L_new_unclipped)\n        \n        clipped_params = (eps_new_clipped, fam_new_clipped, L_new_clipped)\n        \n        # 5. Observation Calculation\n        E_new, V_new = mechanistic_model(clipped_params)\n        dE_obs = E_new - E_base\n        dV_obs = V_new - V_base\n\n        # 6. Error and Validation Calculation\n        err_E = abs(dE_pred - dE_obs)\n        err_V = abs(dV_pred - dV_obs)\n        is_valid = (err_E = tau_E) and (err_V = tau_V)\n        \n        results.extend([round(err_E, 6), round(err_V, 6), is_valid])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了能解释模型的*行为*，XAI还可以建议*如何*实现期望的结果。本练习深入探讨了反事实解释，您将利用一个局部风险代理模型来重新设计电池充电策略。通过求解一个约束优化问题，您将找到一个在满足关键操作约束的同时，能最小化锂枝晶析出风险的新策略，从而直接展示XAI如何驱动自动化且更安全的电池设计。",
            "id": "3913447",
            "problem": "给定一个有限时间范围内的基准恒流充电协议，您的任务是构建一个反事实协议，该协议能够降低析锂风险替代指标，同时保持充电通量并遵守电流密度和热约束。此场景的动机是电池设计中的可解释人工智能：一个从黑箱析锂风险预测器中派生出的局部可解释替代模型，提供了关于电流密度的一阶和二阶灵敏度。您的任务是为每个测试用例求解一个约束二次规划问题，该问题代表了局部有效的反事实调整。\n\n推导中使用的基本和核心定义如下：(i) Butler–Volmer 关系意味着界面过电势随电流密度单调增加，从而增加了析锂倾向；(ii) 一个集总一电阻一电容热模型，其热输入来自焦耳热，捕捉了电芯的温度演变；(iii) 来自可解释预测器的局部替代近似，产生了一个关于电流密度调整的二次增量风险函数。具体步骤详述如下。\n\n假设有 $N$ 个时间间隔，每个间隔的持续时间为 $\\Delta t$（单位：秒），基准电流密度曲线为 $\\mathbf{J}_0 \\in \\mathbb{R}^N$，其中每个分量 $J_{0,i}$ 的单位为 $\\mathrm{A}/\\mathrm{m}^2$。设决策变量为反事实电流密度曲线 $\\mathbf{J} \\in \\mathbb{R}^N$，单位相同。设电芯几何面积为 $A_{\\mathrm{cell}}$（单位：$\\mathrm{m}^2$），内阻为 $R_{\\mathrm{int}}$（单位：$\\Omega$），热阻为 $R_{\\mathrm{th}}$（单位：$\\mathrm{K}/\\mathrm{W}$），热容为 $C_{\\mathrm{th}}$（单位：$\\mathrm{J}/\\mathrm{K}$），环境温度为 $T_{\\mathrm{env}}$（单位：$\\mathrm{K}$），初始温度为 $T_{\\mathrm{init}}$（单位：$\\mathrm{K}$）。集总热动力学通过对能量平衡方程使用前向欧拉法进行离散化\n$$\nC_{\\mathrm{th}} \\frac{dT}{dt} = I^2 R_{\\mathrm{int}} - \\frac{T - T_{\\mathrm{env}}}{R_{\\mathrm{th}}},\n$$\n其中 $I = A_{\\mathrm{cell}} J$，得到\n$$\nT_{i+1} = T_i + \\frac{\\Delta t}{C_{\\mathrm{th}}} \\left( A_{\\mathrm{cell}}^2 J_i^2 R_{\\mathrm{int}} - \\frac{T_i - T_{\\mathrm{env}}}{R_{\\mathrm{th}}} \\right),\n$$\n对于 $i \\in \\{0,\\dots,N-1\\}$，$T_0 = T_{\\mathrm{init}}$。热约束为在每个时间间隔结束时，对所有索引 $i$ 均有 $T_i \\le T_{\\max}$（单位：$\\mathrm{K}$）。电流密度边界为 $0 \\le J_i \\le J_{\\max}$（单位：$\\mathrm{A}/\\mathrm{m}^2$）。充电通量相等约束为\n$$\n\\sum_{i=1}^{N} J_i \\, \\Delta t = \\sum_{i=1}^{N} J_{0,i} \\, \\Delta t,\n$$\n该约束强制基准和反事实协议的总输送电荷（单位：$\\mathrm{A}\\cdot\\mathrm{s}/\\mathrm{m}^2$）相等。\n\n从一个析锂风险黑箱的局部可解释替代模型（例如，一个局部模型无关解释或基于 Shapley 的二次拟合）中，给定每个间隔的一阶灵敏度 $g_i$ 和正曲率 $h_i  0$，使得相对于基准的总风险增量变化可近似为\n$$\n\\Delta \\mathcal{R}(\\mathbf{J}) \\approx \\sum_{i=1}^N \\left[ g_i \\, (J_i - J_{0,i}) + \\tfrac{1}{2} h_i \\, (J_i - J_{0,i})^2 \\right].\n$$\n提供了绝对基准风险 $\\mathcal{R}_0$（任意非负单位）。反事实风险由 $\\mathcal{R}_{\\star} \\approx \\mathcal{R}_0 + \\Delta \\mathcal{R}(\\mathbf{J}_{\\star})$ 近似。您的目标是在满足约束的条件下最小化 $\\Delta \\mathcal{R}$。\n\n为使热约束保持易于处理的形式，请围绕基准轨迹进行一阶灵敏度线性化。定义 $\\phi = 1 - \\frac{\\Delta t}{C_{\\mathrm{th}} R_{\\mathrm{th}}}$。基准温度轨迹 $(T_i^0)_{i=0}^N$ 通过上述使用 $\\mathbf{J}_0$ 的热递推关系获得。线性灵敏度矩阵 $\\mathbf{B} \\in \\mathbb{R}^{N \\times N}$，其元素 $B_{i,k} = \\frac{\\partial T_{i+1}}{\\partial J_k} \\big|_{\\mathbf{J}_0}$ 满足\n$$\nB_{k,k} = \\frac{\\Delta t}{C_{\\mathrm{th}}} \\, 2 A_{\\mathrm{cell}}^2 R_{\\mathrm{int}} \\, J_{0,k}, \\quad\nB_{i,k} = \\phi \\, B_{i-1,k} \\text{ for } i  k, \\quad\nB_{i,k} = 0 \\text{ for } i  k,\n$$\n因此，每个间隔结束时的线性化热约束变为\n$$\nT_{i+1}^0 + \\sum_{k=1}^N B_{i,k} \\, (J_k - J_{0,k}) \\le T_{\\max}, \\quad i = 0,\\dots,N-1.\n$$\n您必须求解以下约束二次规划问题\n$$\n\\min_{\\mathbf{J} \\in \\mathbb{R}^N} \\sum_{i=1}^N \\left[ g_i \\, (J_i - J_{0,i}) + \\tfrac{1}{2} h_i \\, (J_i - J_{0,i})^2 \\right]\n$$\n约束条件为\n$$\n\\sum_{i=1}^{N} J_i \\, \\Delta t = \\sum_{i=1}^{N} J_{0,i} \\, \\Delta t, \\quad\n0 \\le J_i \\le J_{\\max} \\text{ for all } i, \\quad\nT_{i+1}^0 + \\sum_{k=1}^N B_{i,k} \\, (J_k - J_{0,k}) \\le T_{\\max} \\text{ for } i=0,\\dots,N-1.\n$$\n对于每个测试用例，计算优化的 $\\mathbf{J}_{\\star}$，然后计算估计的绝对反事实风险 $\\mathcal{R}_{\\star} \\approx \\mathcal{R}_0 + \\Delta \\mathcal{R}(\\mathbf{J}_{\\star})$，最后将风险降低分数报告为小数\n$$\n\\rho = \\frac{\\mathcal{R}_0 - \\mathcal{R}_{\\star}}{\\mathcal{R}_0},\n$$\n四舍五入到六位小数。不允许使用百分号；报告一个无单位的小数。\n\n物理单位和角度单位：电流密度单位必须是 $\\mathrm{A}/\\mathrm{m}^2$，时间单位是 $\\mathrm{s}$，面积单位是 $\\mathrm{m}^2$，电阻单位是 $\\Omega$，热阻单位是 $\\mathrm{K}/\\mathrm{W}$，热容单位是 $\\mathrm{J}/\\mathrm{K}$，温度单位是 $\\mathrm{K}$。没有出现角度量。\n\n测试套件和参数：\n\n测试用例 $1$（理想情况，适度约束）：\n- $N = 4$，$\\Delta t = 60.0$， $A_{\\mathrm{cell}} = 0.01$，$R_{\\mathrm{int}} = 0.05$，$R_{\\mathrm{th}} = 5.0$，$C_{\\mathrm{th}} = 400.0$，$T_{\\mathrm{env}} = 298.15$，$T_{\\mathrm{init}} = 298.15$，$J_{\\max} = 150.0$，$T_{\\max} = 313.15$。\n- 基准 $\\mathbf{J}_0 = [120.0, 120.0, 80.0, 80.0]$。\n- 替代模型参数 $\\mathbf{g} = [0.8, 0.6, 0.2, 0.1]$，$\\mathbf{h} = [0.02, 0.02, 0.01, 0.01]$，以及 $\\mathcal{R}_0 = 10.0$。\n\n测试用例 $2$（热约束更活跃）：\n- $N = 4$，$\\Delta t = 60.0$， $A_{\\mathrm{cell}} = 0.01$，$R_{\\mathrm{int}} = 0.05$，$R_{\\mathrm{th}} = 5.0$，$C_{\\mathrm{th}} = 400.0$，$T_{\\mathrm{env}} = 298.15$，$T_{\\mathrm{init}} = 298.15$，$J_{\\max} = 150.0$，$T_{\\max} = 303.15$。\n- 基准 $\\mathbf{J}_0 = [100.0, 100.0, 100.0, 100.0]$。\n- 替代模型参数 $\\mathbf{g} = [1.0, 0.7, 0.2, 0.1]$，$\\mathbf{h} = [0.02, 0.02, 0.01, 0.01]$，以及 $\\mathcal{R}_0 = 8.0$。\n\n测试用例 $3$（电流密度边界限制了重新分配）：\n- $N = 4$，$\\Delta t = 30.0$， $A_{\\mathrm{cell}} = 0.01$，$R_{\\mathrm{int}} = 0.05$，$R_{\\mathrm{th}} = 5.0$，$C_{\\mathrm{th}} = 400.0$，$T_{\\mathrm{env}} = 298.15$，$T_{\\mathrm{init}} = 298.15$，$J_{\\max} = 110.0$，$T_{\\max} = 330.0$。\n- 基准 $\\mathbf{J}_0 = [110.0, 110.0, 110.0, 110.0]$。\n- 替代模型参数 $\\mathbf{g} = [0.1, 0.1, 0.1, 0.1]$，$\\mathbf{h} = [0.005, 0.005, 0.005, 0.005]$，以及 $\\mathcal{R}_0 = 12.0$。\n\n最终输出格式：您的程序应生成单行输出，其中包含测试用例 $1$、$2$ 和 $3$ 的三个风险降低分数，按顺序排列，格式为方括号括起来的逗号分隔列表，例如 $[x_1,x_2,x_3]$，其中每个 $x_i$ 是四舍五入到六位的小数。不应打印任何其他文本。",
            "solution": "该问题需要求解一个约束二次优化问题，以找到一个反事实电池充电协议，该协议在遵守总电荷、电流密度和电芯温度约束的同时，最小化析锂风险的替代指标。求解过程包括：将问题表述为标准二次规划（QP），根据给定的物理参数构建必要的矩阵和向量，对QP进行数值求解，并计算最终的性能指标。\n\n设时间间隔数为 $N$，决策变量为对基准电流密度曲线 $\\mathbf{J}_0 \\in \\mathbb{R}^N$ 的调整向量 $\\boldsymbol{\\delta} \\in \\mathbb{R}^N$，其中 $\\boldsymbol{\\delta} = \\mathbf{J} - \\mathbf{J}_0$。所有向量和与时间相关的量的索引都将是基于0的，即 $i \\in \\{0, 1, \\dots, N-1\\}$。\n\n优化问题是最小化增量风险，它是 $\\boldsymbol{\\delta}$ 的一个二次函数：\n$$\n\\min_{\\boldsymbol{\\delta} \\in \\mathbb{R}^N} \\quad f(\\boldsymbol{\\delta}) = \\sum_{i=0}^{N-1} \\left[ g_i \\delta_i + \\tfrac{1}{2} h_i \\delta_i^2 \\right]\n$$\n该目标函数可以写成矩阵形式：\n$$\n\\min_{\\boldsymbol{\\delta}} \\quad \\frac{1}{2} \\boldsymbol{\\delta}^T \\mathbf{H} \\boldsymbol{\\delta} + \\mathbf{g}^T \\boldsymbol{\\delta}\n$$\n其中 $\\mathbf{g} = [g_0, g_1, \\dots, g_{N-1}]^T$ 是一阶灵敏度向量，$\\mathbf{H} = \\mathrm{diag}(h_0, h_1, \\dots, h_{N-1})$ 是正曲率的对角矩阵。由于所有 $h_i  0$，Hessian矩阵 $\\mathbf{H}$ 是正定的，这使得目标函数是严格凸的。\n\n该优化受以下线性约束的限制：\n\n1.  **充电通量守恒**：总输送电荷必须与基准相同。\n    $$\n    \\sum_{i=0}^{N-1} J_i \\Delta t = \\sum_{i=0}^{N-1} J_{0,i} \\Delta t \\implies \\sum_{i=0}^{N-1} (J_{0,i} + \\delta_i) = \\sum_{i=0}^{N-1} J_{0,i} \\implies \\sum_{i=0}^{N-1} \\delta_i = 0\n    $$\n    以向量形式表示为 $\\mathbf{1}^T \\boldsymbol{\\delta} = 0$，其中 $\\mathbf{1}$ 是一个全为1的向量。\n\n2.  **电流密度边界**：每一步的电流密度必须在指定限制内。\n    $$\n    0 \\le J_i \\le J_{\\max} \\implies 0 \\le J_{0,i} + \\delta_i \\le J_{\\max} \\implies -J_{0,i} \\le \\delta_i \\le J_{\\max} - J_{0,i}\n    $$\n    这些是对决策变量 $\\delta_i$ 的箱形约束。\n\n3.  **线性化热约束**：在每个间隔结束时，电芯温度不得超过最大值 $T_{\\max}$。温度演变在基准轨迹 $\\mathbf{T}^0 = (T_1^0, \\dots, T_N^0)$ 周围进行线性化。\n    $$\n    T_{i+1}^0 + \\sum_{k=0}^{N-1} B_{i,k} \\delta_k \\le T_{\\max} \\quad \\text{for } i = 0, \\dots, N-1\n    $$\n    其中 $\\mathbf{B}$ 是 $N \\times N$ 的热灵敏度矩阵。这组 $N$ 个不等式可以写成 $\\mathbf{B} \\boldsymbol{\\delta} \\le \\mathbf{d}$，其中向量 $\\mathbf{d}$ 的分量为 $d_i = T_{\\max} - T_{i+1}^0$。\n\n该问题是一个凸二次规划（QP），因为它涉及在由线性等式和不等式定义的凸可行集上最小化一个严格凸的二次函数。这样的问题有唯一的全局最小值。我们可以使用数值优化求解器来解决它，例如 `scipy.optimize.minimize` 中可用的序列最小二乘规划（SLSQP）算法。\n\n对于每个测试用例，求解过程按以下步骤进行：\n\n**步骤1：计算基准温度轨迹**\n通过使用基准电流曲线 $\\mathbf{J}_0$ 迭代离散化的热模型，计算每个间隔结束时的基准温度 $T_{i+1}^0$。递推关系为：\n$$\nT_{i+1}^0 = T_i^0 + \\frac{\\Delta t}{C_{\\mathrm{th}}} \\left( A_{\\mathrm{cell}}^2 J_{0,i}^2 R_{\\mathrm{int}} - \\frac{T_i^0 - T_{\\mathrm{env}}}{R_{\\mathrm{th}}} \\right), \\quad T_0^0 = T_{\\mathrm{init}}\n$$\n这可以重写为 $T_{i+1}^0 = \\phi T_i^0 + \\alpha J_{0,i}^2 + \\beta T_{\\mathrm{env}}$，其中 $\\phi = 1 - \\frac{\\Delta t}{C_{\\mathrm{th}}R_{\\mathrm{th}}}$，$\\alpha = \\frac{\\Delta t A_{\\mathrm{cell}}^2 R_{\\mathrm{int}}}{C_{\\mathrm{th}}}$，以及 $\\beta = \\frac{\\Delta t}{C_{\\mathrm{th}}R_{\\mathrm{th}}}$。得到的温度 $T_1^0, \\dots, T_N^0$ 用于定义热约束边界。\n\n**步骤2：构建热灵敏度矩阵 B**\n矩阵 $\\mathbf{B}$ 包含在 $\\mathbf{J} = \\mathbf{J}_0$ 处求值的偏导数 $B_{i,k} = \\frac{\\partial T_{i+1}}{\\partial J_k}$。它具有下三角结构，因为时间步 $i+1$ 的温度不受未来电流（$J_k$ for $k  i$）的影响。矩阵元素计算如下：\n$$\nB_{i,k} =\n\\begin{cases}\n0  \\text{if } k  i \\\\\n\\frac{2 \\Delta t A_{\\mathrm{cell}}^2 R_{\\mathrm{int}}}{C_{\\mathrm{th}}} J_{0,k}  \\text{if } k = i \\\\\n\\phi B_{i-1,k}  \\text{if } k  i\n\\end{cases}\n$$\n\n**步骤3：求解二次规划问题**\nQP被公式化并进行数值求解。求解器所需的组件如下：\n- 目标函数 $f(\\boldsymbol{\\delta}) = \\frac{1}{2}\\boldsymbol{\\delta}^T \\mathbf{H} \\boldsymbol{\\delta} + \\mathbf{g}^T \\boldsymbol{\\delta}$。\n- 目标函数的梯度（雅可比矩阵）：$\\nabla f(\\boldsymbol{\\delta}) = \\mathbf{H}\\boldsymbol{\\delta} + \\mathbf{g}$。\n- 等式约束：$\\sum_{i=0}^{N-1} \\delta_i = 0$。\n- 不等式约束：$T_{\\max} - T_{i+1}^0 - (\\mathbf{B}\\boldsymbol{\\delta})_i \\ge 0$ 对于 $i=0, \\dots, N-1$。（注意 SciPy 所需的 $\\ge 0$ 形式）。\n- 变量的边界：$-J_{0,i} \\le \\delta_i \\le J_{\\max} - J_{0,i}$。\n\n向求解器提供 $\\boldsymbol{\\delta} = \\mathbf{0}$ 的初始猜测。输出为最优调整向量 $\\boldsymbol{\\delta}_{\\star}$。\n\n**步骤4：计算风险降低分数**\n最优增量风险 $\\Delta \\mathcal{R}(\\mathbf{J}_{\\star})$ 是目标函数在解 $\\boldsymbol{\\delta}_{\\star}$ 处的值。反事实绝对风险为 $\\mathcal{R}_{\\star} = \\mathcal{R}_0 + \\Delta \\mathcal{R}(\\mathbf{J}_{\\star})$。然后，风险降低分数 $\\rho$ 计算如下：\n$$\n\\rho = \\frac{\\mathcal{R}_0 - \\mathcal{R}_{\\star}}{\\mathcal{R}_0} = \\frac{\\mathcal{R}_0 - (\\mathcal{R}_0 + \\Delta \\mathcal{R}(\\mathbf{J}_{\\star}))}{\\mathcal{R}_0} = - \\frac{\\Delta \\mathcal{R}(\\mathbf{J}_{\\star})}{\\mathcal{R}_0}\n$$\n最终值按要求四舍五入到六位小数。对所有测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the constrained quadratic program for each test case to find the\n    optimal counterfactual charging protocol and reports the fractional risk reduction.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        {\n            'N': 4, 'dt': 60.0, 'A_cell': 0.01, 'R_int': 0.05, 'R_th': 5.0, \n            'C_th': 400.0, 'T_env': 298.15, 'T_init': 298.15, 'J_max': 150.0, \n            'T_max': 313.15, 'J0': [120.0, 120.0, 80.0, 80.0],\n            'g': [0.8, 0.6, 0.2, 0.1], 'h': [0.02, 0.02, 0.01, 0.01], 'R0': 10.0\n        },\n        # Test case 2\n        {\n            'N': 4, 'dt': 60.0, 'A_cell': 0.01, 'R_int': 0.05, 'R_th': 5.0,\n            'C_th': 400.0, 'T_env': 298.15, 'T_init': 298.15, 'J_max': 150.0,\n            'T_max': 303.15, 'J0': [100.0, 100.0, 100.0, 100.0],\n            'g': [1.0, 0.7, 0.2, 0.1], 'h': [0.02, 0.02, 0.01, 0.01], 'R0': 8.0\n        },\n        # Test case 3\n        {\n            'N': 4, 'dt': 30.0, 'A_cell': 0.01, 'R_int': 0.05, 'R_th': 5.0, \n            'C_th': 400.0, 'T_env': 298.15, 'T_init': 298.15, 'J_max': 110.0, \n            'T_max': 330.0, 'J0': [110.0, 110.0, 110.0, 110.0],\n            'g': [0.1, 0.1, 0.1, 0.1], 'h': [0.005, 0.005, 0.005, 0.005], 'R0': 12.0\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_case(params)\n        results.append(f\"{result:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\n\ndef _solve_case(params):\n    \"\"\"\n    Helper function to set up and solve the QP for a single test case.\n    \"\"\"\n    # 1. Unpack parameters and convert to numpy arrays\n    N = params['N']\n    dt = params['dt']\n    A_cell = params['A_cell']\n    R_int = params['R_int']\n    R_th = params['R_th']\n    C_th = params['C_th']\n    T_env = params['T_env']\n    T_init = params['T_init']\n    J_max = params['J_max']\n    T_max = params['T_max']\n    J0 = np.array(params['J0'])\n    g = np.array(params['g'])\n    h = np.array(params['h'])\n    R0 = params['R0']\n\n    # 2. Calculate baseline temperature trajectory\n    T0_traj = np.zeros(N + 1)\n    T0_traj[0] = T_init\n    \n    phi = 1.0 - dt / (C_th * R_th)\n    alpha = dt * A_cell**2 * R_int / C_th\n    beta_T_env = (dt / (C_th * R_th)) * T_env\n\n    for i in range(N):\n        T0_traj[i+1] = phi * T0_traj[i] + alpha * J0[i]**2 + beta_T_env\n\n    # 3. Construct the thermal sensitivity matrix B\n    B = np.zeros((N, N))\n    b_diag_factor = 2.0 * dt * A_cell**2 * R_int / C_th\n    for k in range(N):\n        B[k, k] = b_diag_factor * J0[k]\n        for i in range(k + 1, N):\n            B[i, k] = phi * B[i - 1, k]\n\n    # 4. Define the QP problem for the solver\n    # Decision variable is delta, the adjustment to J0\n    def objective(delta):\n        return 0.5 * np.sum(h * delta**2) + np.sum(g * delta)\n\n    def jacobian(delta):\n        return h * delta + g\n\n    # Equality constraint: sum of adjustments is zero (charge conservation)\n    eq_constraint = {'type': 'eq', 'fun': lambda delta: np.sum(delta)}\n\n    # Inequality constraints: thermal limits\n    # SLSQP expects constraints in the form C(x) >= 0.\n    # B @ delta = T_max - T0_traj[1:] -> (T_max - T0_traj[1:]) - (B @ delta) >= 0\n    ineq_constraints = []\n    for i in range(N):\n        constraint_fun = lambda delta, i=i: (T_max - T0_traj[i + 1]) - np.dot(B[i, :], delta)\n        ineq_constraints.append({'type': 'ineq', 'fun': constraint_fun})\n\n    constraints = [eq_constraint] + ineq_constraints\n\n    # Bounds for each delta_i: -J0[i] = delta_i = J_max - J0[i]\n    bounds = [(-J0[i], J_max - J0[i]) for i in range(N)]\n    \n    # 5. Solve the QP\n    delta0 = np.zeros(N)\n    res = minimize(objective, delta0, method='SLSQP', jac=jacobian, \n                   bounds=bounds, constraints=constraints)\n\n    # 6. Calculate the final result (fractional risk reduction)\n    delta_R_star = res.fun\n    rho = -delta_R_star / R0\n    \n    return rho\n\nsolve()\n```"
        }
    ]
}