{
    "hands_on_practices": [
        {
            "introduction": "This practice focuses on the crucial first step in applying GNNs to materials: converting a periodic crystal structure into a graph. By deriving the adjacency criterion from the minimum-image convention, you will gain a first-principles understanding of how atomic interactions in a lattice are translated into graph edges. This exercise bridges the gap between crystallography and graph theory, a foundational skill for any materials informatics practitioner .",
            "id": "3917806",
            "problem": "In automated battery design and simulation, atomistic structures are often converted into graphs for use with Graph Neural Networks (GNNs), where atoms are nodes and edges represent near-neighbor interactions under periodic boundary conditions. Consider the orthorhombic olivine lithium iron phosphate $\\mathrm{LiFePO_{4}}$ crystallizing in space group $\\mathrm{Pnma}$ with $Z=4$ formula units per conventional unit cell. Let the lattice vectors be $\\mathbf{a}=(a,0,0)$, $\\mathbf{b}=(0,b,0)$, and $\\mathbf{c}=(0,0,c)$, and define the lattice matrix as $$\\mathbf{L}=\\begin{pmatrix} a & 0 & 0 \\\\ 0 & b & 0 \\\\ 0 & 0 & c \\end{pmatrix}.$$ Atoms $i$ and $j$ are given by fractional coordinates $\\mathbf{s}_{i}, \\mathbf{s}_{j} \\in [0,1)^{3}$. Edges are formed using the minimum-image convention with a radial cutoff $r_{c}$, meaning two atoms are adjacent if the shortest periodic distance between them is less than $r_{c}$.\n\nTask 1 (derivation): Starting from periodic boundary conditions and the Euclidean metric, derive an explicit adjacency criterion $A_{ij}\\in\\{0,1\\}$ in terms of $\\mathbf{s}_{i}$, $\\mathbf{s}_{j}$, $\\mathbf{L}$, and $r_{c}$ that implements the minimum-image convention for the orthorhombic cell. Your criterion must correctly select the nearest image among all Bravais lattice translations and compare its norm to $r_{c}$.\n\nTask 2 (calculation): For $\\mathrm{LiFePO_{4}}$, the typical nearest-neighbor bond distances are well established from crystallography: $\\mathrm{P}$–$\\mathrm{O}$ bonds lie in the range $1.50$–$1.54\\,\\mathrm{\\AA}$, $\\mathrm{Fe}$–$\\mathrm{O}$ bonds lie in the range $2.14$–$2.27\\,\\mathrm{\\AA}$, and $\\mathrm{Li}$–$\\mathrm{O}$ bonds lie in the range $1.96$–$2.20\\,\\mathrm{\\AA}$. Nonbonded $\\mathrm{O}$–$\\mathrm{O}$ separations and cation–cation separations are greater than $2.30\\,\\mathrm{\\AA}$ in this structure. Let the cutoff be $r_{c}=2.30\\,\\mathrm{\\AA}$. Using only these well-tested structural facts and the stoichiometry of the unit cell, compute the expected average node degree $\\langle k \\rangle$ of the atomic graph constructed by the criterion from Task 1, assuming undirected edges. Express the final average node degree as a single simplified fraction with no units.\n\nDo not use any pre-derived neighbor-list formulas beyond the minimum-image convention and the Euclidean norm. Round nothing; give the exact simplified fraction.",
            "solution": "The problem is divided into two parts. The first task requires the derivation of an adjacency criterion for atom pairs in a periodic orthorhombic lattice based on the minimum-image convention. The second task asks for the calculation of the average node degree for a graph representation of $\\mathrm{LiFePO_{4}}$, using the derived criterion and provided structural data.\n\n### Task 1: Derivation of the Adjacency Criterion\n\nLet two atoms, $i$ and $j$, be located within the unit cell. Their positions are given by fractional coordinate vectors $\\mathbf{s}_{i}, \\mathbf{s}_{j} \\in [0,1)^{3}$. The Cartesian coordinates $\\mathbf{r}_{i}$ and $\\mathbf{r}_{j}$ are obtained by multiplication with the lattice matrix $\\mathbf{L}$:\n$$ \\mathbf{r}_{i} = \\mathbf{L} \\mathbf{s}_{i}, \\quad \\mathbf{r}_{j} = \\mathbf{L} \\mathbf{s}_{j} $$\nFor an orthorhombic cell with lattice parameters $a$, $b$, and $c$, the lattice matrix $\\mathbf{L}$ is diagonal:\n$$ \\mathbf{L} = \\begin{pmatrix} a & 0 & 0 \\\\ 0 & b & 0 \\\\ 0 & 0 & c \\end{pmatrix} $$\nDue to periodic boundary conditions, atom $j$ has an infinite number of images located at positions $\\mathbf{r}_{j, \\mathbf{n}}$, where $\\mathbf{n}=(n_x, n_y, n_z)^T$ is a vector of integers ($n_x, n_y, n_z \\in \\mathbb{Z}$). The position of an image is given by a translation from the primary cell by a lattice vector $\\mathbf{T}_{\\mathbf{n}} = \\mathbf{L}\\mathbf{n}$:\n$$ \\mathbf{r}_{j, \\mathbf{n}} = \\mathbf{r}_{j} + \\mathbf{T}_{\\mathbf{n}} = \\mathbf{L}\\mathbf{s}_{j} + \\mathbf{L}\\mathbf{n} = \\mathbf{L}(\\mathbf{s}_{j} + \\mathbf{n}) $$\nThe vector connecting atom $i$ to an image of atom $j$ is $\\mathbf{d}_{ij, \\mathbf{n}} = \\mathbf{r}_{j, \\mathbf{n}} - \\mathbf{r}_{i}$.\n$$ \\mathbf{d}_{ij, \\mathbf{n}} = \\mathbf{L}(\\mathbf{s}_{j} + \\mathbf{n}) - \\mathbf{L}\\mathbf{s}_{i} = \\mathbf{L}(\\mathbf{s}_{j} - \\mathbf{s}_{i} + \\mathbf{n}) $$\nLet the fractional coordinate difference vector be $\\Delta\\mathbf{s} = \\mathbf{s}_{j} - \\mathbf{s}_{i}$. Each component $\\Delta s_k$ of this vector lies in the interval $(-1, 1)$. The squared Euclidean distance is given by the squared norm of this vector:\n$$ d_{ij, \\mathbf{n}}^2 = \\|\\mathbf{d}_{ij, \\mathbf{n}}\\|^2 = \\|\\mathbf{L}(\\Delta\\mathbf{s} + \\mathbf{n})\\|^2 $$\nThe minimum-image convention requires finding the integer vector $\\mathbf{n}^{\\ast}$ that minimizes this distance.\n$$ d_{ij, \\text{min}}^2 = \\min_{\\mathbf{n} \\in \\mathbb{Z}^3} \\|\\mathbf{L}(\\Delta\\mathbf{s} + \\mathbf{n})\\|^2 $$\nFor a diagonal lattice matrix $\\mathbf{L}$, the expression for the squared distance expands as:\n$$ d_{ij, \\mathbf{n}}^2 = (a(\\Delta s_x + n_x))^2 + (b(\\Delta s_y + n_y))^2 + (c(\\Delta s_z + n_z))^2 $$\nSince the three terms are independent, we can minimize each one separately. We need to find the integer $n_k$ that minimizes $(\\Delta s_k + n_k)^2$ for each component $k \\in \\{x, y, z\\}$. The minimum is achieved when $\\Delta s_k + n_k$ is as close to zero as possible. Since $\\Delta s_k \\in (-1, 1)$, this occurs when we choose $n_k$ to shift $\\Delta s_k$ into the interval $[-0.5, 0.5]$. This operation is equivalent to subtracting the nearest integer from $\\Delta s_k$. Let $\\text{round}(x)$ be the function that returns the nearest integer to $x$. The optimal integer vector is $\\mathbf{n}^{\\ast} = -\\text{round}(\\Delta\\mathbf{s})$, where the rounding is applied component-wise.\n\nLet us define a modified fractional difference vector, $\\Delta\\mathbf{s}'$, whose components are wrapped into the $[-0.5, 0.5]$ range:\n$$ \\Delta\\mathbf{s}' = \\Delta\\mathbf{s} - \\text{round}(\\Delta\\mathbf{s}) $$\nwhere $\\text{round}(\\Delta\\mathbf{s}) = (\\text{round}(\\Delta s_x), \\text{round}(\\Delta s_y), \\text{round}(\\Delta s_z))^T$.\nThe minimum distance vector is then $\\Delta\\mathbf{r}_{\\text{min}} = \\mathbf{L}\\Delta\\mathbf{s}'$, and its squared norm is:\n$$ d_{ij, \\text{min}}^2 = \\| \\mathbf{L} ( \\Delta\\mathbf{s} - \\text{round}(\\Delta\\mathbf{s}) ) \\|^2 $$\nAn edge exists between atoms $i$ and $j$ if this minimum distance is less than the cutoff radius $r_c$. The adjacency criterion $A_{ij} \\in \\{0,1\\}$ is therefore:\n$$ A_{ij} = \\begin{cases} 1 & \\text{if } \\| \\mathbf{L} ( \\mathbf{s}_{j} - \\mathbf{s}_{i} - \\text{round}(\\mathbf{s}_{j} - \\mathbf{s}_{i}) ) \\|^2 < r_c^2 \\\\ 0 & \\text{otherwise} \\end{cases} $$\nThis provides the explicit adjacency criterion in terms of the specified variables.\n\n### Task 2: Calculation of Average Node Degree\n\nThe average node degree, $\\langle k \\rangle$, of a graph is defined as the sum of all node degrees divided by the total number of nodes, $N$. By the handshaking lemma, the sum of degrees is twice the number of edges, $E$.\n$$ \\langle k \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} k_i = \\frac{2E}{N} $$\n\nFirst, we determine the number of nodes $N$. The material is $\\mathrm{LiFePO_{4}}$ and the unit cell contains $Z=4$ formula units. Each formula unit contains $1$ $\\mathrm{Li}$, $1$ $\\mathrm{Fe}$, $1$ $\\mathrm{P}$, and $4$ $\\mathrm{O}$ atoms, for a total of $1+1+1+4=7$ atoms. The total number of atoms (nodes) in the conventional unit cell is:\n$$ N = Z \\times 7 = 4 \\times 7 = 28 $$\n\nNext, we determine the number of edges $E$. An edge is formed if the distance between two atoms is less than the cutoff $r_c = 2.30\\,\\mathrm{\\AA}$. The problem provides the following structural information:\n- $\\mathrm{P}$–$\\mathrm{O}$ bond distances: $1.50$–$1.54\\,\\mathrm{\\AA}$. All are $< r_c$.\n- $\\mathrm{Fe}$–$\\mathrm{O}$ bond distances: $2.14$–$2.27\\,\\mathrm{\\AA}$. All are $< r_c$.\n- $\\mathrm{Li}$–$\\mathrm{O}$ bond distances: $1.96$–$2.20\\,\\mathrm{\\AA}$. All are $< r_c$.\n- Nonbonded $\\mathrm{O}$–$\\mathrm{O}$ separations and cation–cation separations are greater than $2.30\\,\\mathrm{\\AA}$. All are $> r_c$.\n\nThis information precisely defines which pairs of atoms can form an edge. Edges will form exclusively between cations ($\\mathrm{Li}$, $\\mathrm{Fe}$, $\\mathrm{P}$) and oxygen anions ($\\mathrm{O}$). No cation-cation or O-O edges will exist. The graph is bipartite, with one partition being the cations and the other being the oxygen anions.\n\nThe problem asks to use these \"well-tested structural facts\" and stoichiometry. For the well-characterized olivine $\\mathrm{LiFePO_{4}}$ structure, the coordination environments are standard:\n- Phosphorus ($\\mathrm{P}$) is tetrahedrally coordinated by $4$ oxygen atoms, forming the phosphate group ($\\mathrm{PO}_4^{3-}$). Thus, the coordination number is $CN_{\\mathrm{P}} = 4$.\n- Iron ($\\mathrm{Fe}$) is octahedrally coordinated by $6$ oxygen atoms. Thus, $CN_{\\mathrm{Fe}} = 6$.\n- Lithium ($\\mathrm{Li}$) is also octahedrally coordinated by $6$ oxygen atoms. Thus, $CN_{\\mathrm{Li}} = 6$.\n\nThe number of edges $E$ is the total count of these cation-oxygen bonds in the unit cell. We can find $E$ by summing the degrees (coordination numbers) of all cations.\nNumber of atoms of each type in the cell:\n- $N_{\\mathrm{Li}} = 4 \\times 1 = 4$\n- $N_{\\mathrm{Fe}} = 4 \\times 1 = 4$\n- $N_{\\mathrm{P}} = 4 \\times 1 = 4$\n- $N_{\\mathrm{O}} = 4 \\times 4 = 16$\n\nTotal number of edges $E$ is the sum of all bonds:\n- Total $\\mathrm{P}$–$\\mathrm{O}$ bonds: $N_{\\mathrm{P}} \\times CN_{\\mathrm{P}} = 4 \\times 4 = 16$.\n- Total $\\mathrm{Fe}$–$\\mathrm{O}$ bonds: $N_{\\mathrm{Fe}} \\times CN_{\\mathrm{Fe}} = 4 \\times 6 = 24$.\n- Total $\\mathrm{Li}$–$\\mathrm{O}$ bonds: $N_{\\mathrm{Li}} \\times CN_{\\mathrm{Li}} = 4 \\times 6 = 24$.\n\nSince there are no other types of bonds, the total number of edges is the sum of these counts:\n$$ E = 16 + 24 + 24 = 64 $$\n\nNow we can compute the average node degree $\\langle k \\rangle$:\n$$ \\langle k \\rangle = \\frac{2E}{N} = \\frac{2 \\times 64}{28} = \\frac{128}{28} $$\nSimplifying this fraction by dividing the numerator and denominator by their greatest common divisor, which is $4$:\n$$ \\langle k \\rangle = \\frac{128 \\div 4}{28 \\div 4} = \\frac{32}{7} $$\nThe expected average node degree is $\\frac{32}{7}$.",
            "answer": "$$\\boxed{\\frac{32}{7}}$$"
        },
        {
            "introduction": "A cornerstone of any physical model is that its predictions must obey fundamental symmetries, such as rotational invariance for scalar properties like energy. This exercise provides a tangible demonstration of this principle by contrasting a physically valid, rotationally-invariant energy model with a flawed, non-invariant one. Through a simple coding task, you will see firsthand how a non-equivariant model produces physically nonsensical results, reinforcing the importance of building symmetry into GNN architectures .",
            "id": "3917776",
            "problem": "You are tasked with constructing a rigorous, computational test that exposes the rotational failure mode of a non-equivariant surrogate for a Graph Neural Network (GNN) energy predictor and demonstrates how an equivariant surrogate avoids this failure. In automated battery design and simulation, scalar energies of atomistic configurations are physically required to be invariant under rigid rotations. The fundamental base for this problem is the rotational invariance of scalar physical quantities in Euclidean space, expressed as follows: for any atomic configuration with positions $X = \\{ \\mathbf{x}_i \\in \\mathbb{R}^3 \\}_{i=1}^N$ and any rotation matrix $R \\in \\mathrm{SO}(3)$ (Special Orthogonal group in three dimensions), a physically valid scalar energy $E$ must satisfy $E(RX) = E(X)$. You will implement two surrogate predictors on atomistic graphs defined by nodes (atoms) and edges (pairs of atoms). The first surrogate will be deliberately non-equivariant by embedding an anisotropic axis-dependent metric into its pairwise energy, and the second surrogate will be equivariant by basing its energy on rotation-invariant distances. You must then test both surrogates on a small set of rotations of two atomistic structures relevant to battery materials to quantify the change in predicted energy under rotation.\n\nDefinitions and setup:\n- Let the node set be $V = \\{ 1, \\dots, N \\}$, and the undirected edge set be $E = \\{ (i,j) \\mid 1 \\le i < j \\le N \\}$, i.e., all unordered distinct pairs.\n- Positions are given in angstroms (Å) as $X = [\\mathbf{x}_1, \\dots, \\mathbf{x}_N]$ with $\\mathbf{x}_i \\in \\mathbb{R}^3$.\n- The rotation of $X$ by axis-angle $(\\mathbf{a}, \\theta)$ is $RX$, where $R \\in \\mathrm{SO}(3)$ is constructed via the Rodrigues rotation formula:\n  $$ R = \\cos\\theta \\, I_3 + (1 - \\cos\\theta) \\, \\mathbf{u} \\mathbf{u}^\\top + (\\sin\\theta) \\, [\\mathbf{u}]_\\times, $$\n  where $I_3$ is the $3 \\times 3$ identity, $\\mathbf{u} = \\mathbf{a}/\\|\\mathbf{a}\\|$ is the unit axis, and $[\\mathbf{u}]_\\times$ is the $3 \\times 3$ skew-symmetric matrix such that $[\\mathbf{u}]_\\times \\mathbf{v} = \\mathbf{u} \\times \\mathbf{v}$ for any $\\mathbf{v} \\in \\mathbb{R}^3$.\n- Non-equivariant surrogate energy (anisotropic axis-weighted quadratic):\n  $$ E_{\\mathrm{neq}}(X) = \\sum_{(i,j)\\in E} (\\mathbf{x}_j - \\mathbf{x}_i)^\\top A (\\mathbf{x}_j - \\mathbf{x}_i), $$\n  with a fixed symmetric positive-definite matrix\n  $$ A = \\mathrm{diag}(0.10, 0.20, 0.05) \\quad \\text{in units of eV/Å}^2. $$\n  This energy is not rotation-invariant unless $A$ is proportional to the identity.\n- Equivariant surrogate energy (distance-based quadratic):\n  $$ E_{\\mathrm{eq}}(X) = c \\sum_{(i,j)\\in E} \\| \\mathbf{x}_j - \\mathbf{x}_i \\|_2^2, \\quad c = 0.10 \\quad \\text{in units of eV/Å}^2. $$\n\nTasks:\n1. Implement a function to build $E$ as all unordered pairs $(i,j)$ with $i<j$ for any given $X$.\n2. Implement the Rodrigues rotation to form $R$ for a given axis $\\mathbf{a}$ and angle $\\theta$ (angle unit must be radians).\n3. Implement $E_{\\mathrm{neq}}(X)$ and $E_{\\mathrm{eq}}(X)$ as scalar energies in electronvolts (eV).\n4. For each test case below, compute the baseline energies $E_{\\mathrm{neq}}(X)$ and $E_{\\mathrm{eq}}(X)$ and the rotated energies $E_{\\mathrm{neq}}(RX)$ and $E_{\\mathrm{eq}}(RX)$. Report the absolute energy changes\n   $$ \\Delta_{\\mathrm{neq}} = | E_{\\mathrm{neq}}(RX) - E_{\\mathrm{neq}}(X) |, \\quad \\Delta_{\\mathrm{eq}} = | E_{\\mathrm{eq}}(RX) - E_{\\mathrm{eq}}(X) |. $$\n   Use the numerical tolerance $10^{-12}$ eV to judge exact invariance for $E_{\\mathrm{eq}}$ and $10^{-6}$ eV to flag a meaningful change for $E_{\\mathrm{neq}}$.\n5. Express all energies and energy differences in electronvolts (eV). Angles must be in radians.\n\nTest suite:\n- Structure A (a minimal Li–Mn–O motif): $N=4$, positions in Å\n  $$ \\mathbf{x}_1 = (0.00, 0.00, 0.00), \\quad \\mathbf{x}_2 = (1.90, 0.00, 0.00), $$\n  $$ \\mathbf{x}_3 = (0.00, 1.90, 0.00), \\quad \\mathbf{x}_4 = (0.00, 0.00, 1.90). $$\n- Structure B (a colinear triad along the $x$-axis): $N=3$, positions in Å\n  $$ \\mathbf{x}_1 = (0.00, 0.00, 0.00), \\quad \\mathbf{x}_2 = (1.50, 0.00, 0.00), \\quad \\mathbf{x}_3 = (3.00, 0.00, 0.00). $$\n- Rotations to test (angles in radians, axes dimensionless):\n  1. Structure A rotated about the $z$-axis: $\\mathbf{a} = (0,0,1)$, $\\theta = 0.0$ (boundary case).\n  2. Structure A rotated about the $z$-axis: $\\mathbf{a} = (0,0,1)$, $\\theta = \\pi/2$.\n  3. Structure A rotated about the $y$-axis: $\\mathbf{a} = (0,1,0)$, $\\theta = \\pi/4$.\n  4. Structure A rotated about the axis $\\mathbf{a} = (1,1,1)$: $\\theta = \\pi/3$.\n  5. Structure B rotated about the $z$-axis: $\\mathbf{a} = (0,0,1)$, $\\theta = \\pi/2$ (degenerate colinear case).\n\nAnswer specification:\n- For each test case, return a sublist $[\\Delta_{\\mathrm{neq}}, \\Delta_{\\mathrm{eq}}, \\mathrm{eq\\_ok}, \\mathrm{neq\\_changes}]$ where $\\mathrm{eq\\_ok}$ is a boolean asserting $\\Delta_{\\mathrm{eq}} \\le 10^{-12}$ and $\\mathrm{neq\\_changes}$ is a boolean asserting $\\Delta_{\\mathrm{neq}} \\ge 10^{-6}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in the order listed above and is itself a sublist in the specified format; for example, the output should look like $[ [\\cdot,\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot,\\cdot], \\dots ]$.\n\nAll computations must be self-contained, deterministic, and performed numerically under the constraints specified in the final answer; no user input or external data is permitted.",
            "solution": "The problem statement is valid. It is scientifically grounded, well-posed, objective, and self-contained. It presents a clear and computable task to demonstrate the fundamental physical principle of rotational invariance for scalar energy predictions, a critical concept in physics-informed machine learning for materials science.\n\nThe core principle under examination is that the total energy $E$ of a physical system, a scalar quantity, must be invariant under rigid transformations of the system in Euclidean space. Specifically, for a set of atomic positions $X = \\{ \\mathbf{x}_i \\in \\mathbb{R}^3 \\}_{i=1}^N$, its energy must not change upon rotation. If $R \\in \\mathrm{SO}(3)$ is any rotation matrix, the rotated configuration is $RX = \\{ R\\mathbf{x}_i \\}_{i=1}^N$, and the invariance condition is $E(RX) = E(X)$. This problem requires constructing and testing two surrogate energy functions, one that respects this principle and one that violates it.\n\nThe rotation of a vector $\\mathbf{v}$ around a unit axis $\\mathbf{u}$ by an angle $\\theta$ is given by the Rodrigues rotation formula, which produces the rotation matrix $R$. The formula is given as:\n$$ R = \\cos\\theta \\, I_3 + (1 - \\cos\\theta) \\, \\mathbf{u} \\mathbf{u}^\\top + (\\sin\\theta) \\, [\\mathbf{u}]_\\times $$\nHere, $I_3$ is the $3 \\times 3$ identity matrix, $\\mathbf{u}\\mathbf{u}^\\top$ is the outer product of the unit axis vector with itself, and $[\\mathbf{u}]_\\times$ is the skew-symmetric matrix corresponding to the cross product with $\\mathbf{u}$.\n\nThe first energy function, termed equivariant (more precisely, the resulting scalar energy is invariant), is defined as:\n$$ E_{\\mathrm{eq}}(X) = c \\sum_{(i,j)\\in E} \\| \\mathbf{x}_j - \\mathbf{x}_i \\|_2^2 $$\nwith a constant $c = 0.10 \\, \\mathrm{eV/\\text{Å}}^2$. This function is fundamentally rotationally invariant. Rotations are isometries, which means they preserve Euclidean distances. For any vector $\\mathbf{v}$, $\\|R\\mathbf{v}\\|_2 = \\|\\mathbf{v}\\|_2$. Let $\\mathbf{r}_{ij} = \\mathbf{x}_j - \\mathbf{x}_i$ be the displacement vector between two atoms. The corresponding vector in the rotated configuration is $R\\mathbf{x}_j - R\\mathbf{x}_i = R(\\mathbf{x}_j - \\mathbf{x}_i) = R\\mathbf{r}_{ij}$. The squared distance term in the sum becomes $\\|R\\mathbf{r}_{ij}\\|_2^2$, which is strictly equal to $\\|\\mathbf{r}_{ij}\\|_2^2$ due to the isometric property of $R$. Since every term in the summation is invariant, the total energy $E_{\\mathrm{eq}}$ is invariant. Thus, we must find $E_{\\mathrm{eq}}(RX) = E_{\\mathrm{eq}}(X)$, or $\\Delta_{\\mathrm{eq}} = |E_{\\mathrm{eq}}(RX) - E_{\\mathrm{eq}}(X)|$ to be zero (or within floating-point precision of zero).\n\nThe second energy function, the non-equivariant surrogate, is defined as:\n$$ E_{\\mathrm{neq}}(X) = \\sum_{(i,j)\\in E} (\\mathbf{x}_j - \\mathbf{x}_i)^\\top A (\\mathbf{x}_j - \\mathbf{x}_i) $$\nwhere $A = \\mathrm{diag}(0.10, 0.20, 0.05) \\, \\mathrm{eV/\\text{Å}}^2$. This function introduces an anisotropic weighting. Let's analyze its behavior under rotation. A term in the sum is $\\mathbf{r}_{ij}^\\top A \\mathbf{r}_{ij}$. After rotation, this term becomes $(R\\mathbf{r}_{ij})^\\top A (R\\mathbf{r}_{ij}) = \\mathbf{r}_{ij}^\\top (R^\\top A R) \\mathbf{r}_{ij}$. For the energy to be invariant, this new term must equal the original for any $\\mathbf{r}_{ij}$. This requires the effective metric to be unchanged, i.e., $R^\\top A R = A$, or $A R = R A$ since $R^\\top = R^{-1}$. This means the matrix $A$ must commute with all rotation matrices $R \\in \\mathrm{SO}(3)$. By Schur's Lemma from representation theory, the only matrices that commute with all elements of an irreducible representation of a group (such as $\\mathrm{SO}(3)$ acting on $\\mathbb{R}^3$) are scalar multiples of the identity matrix. Since the given $A$ is diagonal but not a multiple of $I_3$ (as $0.10 \\neq 0.20 \\neq 0.05$), it will not commute with a general rotation matrix. Consequently, $E_{\\mathrm{neq}}(RX)$ will not, in general, equal $E_{\\mathrm{neq}}(X)$. This failure to preserve energy upon rotation represents a failure of the model to capture a fundamental physical symmetry. Note that for specific rotations and structures, accidental invariance can occur, as will be demonstrated in one of the test cases.\n\nThe computational procedure is as follows:\n1. For each test case, we identify the atomic positions $X$ and the rotation parameters $(\\mathbf{a}, \\theta)$.\n2. We generate the edge set $E$ consisting of all unique pairs of atoms.\n3. We implement a function to construct the rotation matrix $R$ from $(\\mathbf{a}, \\theta)$ using the Rodrigues formula, ensuring the axis $\\mathbf{a}$ is normalized to $\\mathbf{u}$.\n4. We calculate the original energies $E_{\\mathrm{eq}}(X)$ and $E_{\\mathrm{neq}}(X)$ by summing the respective potential terms over all edges.\n5. We apply the rotation to obtain the new configuration $X' = RX$, where each position vector $\\mathbf{x}_i$ is transformed to $\\mathbf{x}'_i = R\\mathbf{x}_i$. In matrix notation, with $X$ as an $N \\times 3$ matrix of row vectors, this is $X' = X R^\\top$.\n6. We calculate the energies of the rotated structure, $E_{\\mathrm{eq}}(X')$ and $E_{\\mathrm{neq}}(X')$.\n7. We compute the absolute differences $\\Delta_{\\mathrm{eq}} = |E_{\\mathrm{eq}}(X') - E_{\\mathrm{eq}}(X)|$ and $\\Delta_{\\mathrm{neq}} = |E_{\\mathrm{neq}}(X') - E_{\\mathrm{neq}}(X)|$.\n8. Finally, we check these differences against the specified tolerances ($10^{-12}$ for $\\Delta_{\\mathrm{eq}}$ and $10^{-6}$ for $\\Delta_{\\mathrm{neq}}$) to determine the boolean flags. The results are aggregated and formatted as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of testing rotational invariance for two surrogate energy models.\n    \"\"\"\n\n    # --- Problem Definitions ---\n\n    # Constants for energy calculations\n    C_EQ = 0.10  # eV/Å^2\n    A_NEQ = np.diag([0.10, 0.20, 0.05])  # eV/Å^2\n\n    # Tolerances for flagging changes\n    TOL_EQ = 1e-12\n    TOL_NEQ = 1e-6\n\n    # Test Structures\n    STRUCT_A = np.array([\n        [0.00, 0.00, 0.00],\n        [1.90, 0.00, 0.00],\n        [0.00, 1.90, 0.00],\n        [0.00, 0.00, 1.90],\n    ])\n\n    STRUCT_B = np.array([\n        [0.00, 0.00, 0.00],\n        [1.50, 0.00, 0.00],\n        [3.00, 0.00, 0.00],\n    ])\n\n    # Test Cases: (Structure, axis, angle)\n    test_cases = [\n        (STRUCT_A, np.array([0.0, 0.0, 1.0]), 0.0),\n        (STRUCT_A, np.array([0.0, 0.0, 1.0]), np.pi / 2),\n        (STRUCT_A, np.array([0.0, 1.0, 0.0]), np.pi / 4),\n        (STRUCT_A, np.array([1.0, 1.0, 1.0]), np.pi / 3),\n        (STRUCT_B, np.array([0.0, 0.0, 1.0]), np.pi / 2),\n    ]\n\n    # --- Helper Functions ---\n\n    def get_edges(num_atoms):\n        \"\"\"Generates the edge set E for a fully connected graph.\"\"\"\n        return [(i, j) for i in range(num_atoms) for j in range(i + 1, num_atoms)]\n\n    def rodrigues_rotation(axis, angle):\n        \"\"\"Computes the rotation matrix R using Rodrigues' formula.\"\"\"\n        if angle == 0.0:\n            return np.identity(3)\n            \n        norm_axis = np.linalg.norm(axis)\n        if norm_axis == 0:\n            # Should not happen with problem inputs, but good practice\n            return np.identity(3)\n        \n        u = axis / norm_axis\n        \n        # Skew-symmetric matrix\n        u_cross = np.array([\n            [0, -u[2], u[1]],\n            [u[2], 0, -u[0]],\n            [-u[1], u[0], 0]\n        ])\n        \n        # Outer product\n        u_outer = np.outer(u, u)\n        \n        # Rodrigues' formula\n        R = (np.cos(angle) * np.identity(3) +\n             (1 - np.cos(angle)) * u_outer +\n             np.sin(angle) * u_cross)\n        \n        return R\n\n    def energy_neq(positions, edges, A_matrix):\n        \"\"\"Computes the non-equivariant surrogate energy.\"\"\"\n        total_energy = 0.0\n        for i, j in edges:\n            rij = positions[j] - positions[i]\n            total_energy += rij.T @ A_matrix @ rij\n        return total_energy\n\n    def energy_eq(positions, edges, c_const):\n        \"\"\"Computes the equivariant surrogate energy.\"\"\"\n        total_energy = 0.0\n        for i, j in edges:\n            rij = positions[j] - positions[i]\n            total_energy += c_const * np.dot(rij, rij)\n        return total_energy\n\n    # --- Main Calculation Loop ---\n    \n    results = []\n    for structure, axis, angle in test_cases:\n        num_atoms = structure.shape[0]\n        edges = get_edges(num_atoms)\n        \n        # 1. Calculate baseline energies\n        e_neq_orig = energy_neq(structure, edges, A_NEQ)\n        e_eq_orig = energy_eq(structure, edges, C_EQ)\n        \n        # 2. Get rotation matrix and apply it\n        R = rodrigues_rotation(axis, angle)\n        # Apply rotation: X' = X @ R.T for row vectors\n        rotated_structure = structure @ R.T\n        \n        # 3. Calculate rotated energies\n        e_neq_rot = energy_neq(rotated_structure, edges, A_NEQ)\n        e_eq_rot = energy_eq(rotated_structure, edges, C_EQ)\n        \n        # 4. Compute absolute energy changes\n        delta_neq = abs(e_neq_rot - e_neq_orig)\n        delta_eq = abs(e_eq_rot - e_eq_orig)\n        \n        # 5. Perform boolean checks\n        eq_ok = delta_eq = TOL_EQ\n        neq_changes = delta_neq >= TOL_NEQ\n        \n        results.append([delta_neq, delta_eq, eq_ok, neq_changes])\n\n    # --- Format and Print Output ---\n    # The str() of a list includes spaces, which is consistent with the example.\n    # The problem asks for a comma-separated list of these sublists.\n    formatted_results = \",\".join(map(str, results))\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the concept of energy invariance, this practice explores the related symmetry for vector quantities: rotational equivariance of forces. You will implement a simple, physically-motivated potential and analytically derive the forces, then numerically verify that they correctly rotate with the atomic system. This exercise solidifies the concept of $E(3)$-equivariance, a key property that enables GNNs to accurately predict vectorial properties like forces, which are essential for molecular dynamics simulations .",
            "id": "3917810",
            "problem": "You are tasked to formalize and verify rotational equivariance of an energy-based force predictor modeled as a Graph Neural Network (GNN), within the context of automated battery design and simulation. Consider a finite crystal fragment represented as a graph with atoms as nodes and undirected edges between each pair of distinct atoms. Let the position of atom $i$ be $\\mathbf{r}_i \\in \\mathbb{R}^3$ in angstroms ($\\mathrm{\\AA}$). Define the total predicted energy $E$ in electronvolts ($\\mathrm{eV}$) as a sum of pairwise radial contributions, and define predicted forces $\\mathbf{F}_i$ in $\\mathrm{eV}/\\mathrm{\\AA}$ as the negative gradient of the energy with respect to positions. You must show that if the energy depends only on pairwise distances, an equivariant Graph Neural Network (GNN), constructed with messages that depend exclusively on rotation-invariant scalars, will produce forces that transform under a rotation $\\mathbf{R} \\in \\mathrm{SO}(3)$ according to $\\mathbf{F}_i'=\\mathbf{R}\\mathbf{F}_i$.\n\nUse the following fundamental base:\n- Rotational invariance of Euclidean norms: for any orthogonal matrix $\\mathbf{R}$ with $\\mathbf{R}^{\\top}\\mathbf{R}=\\mathbf{I}$, $\\lVert \\mathbf{R}\\mathbf{x}\\rVert_2=\\lVert \\mathbf{x}\\rVert_2$ for any $\\mathbf{x}\\in\\mathbb{R}^3$.\n- Definition of energy in terms of pairwise distances: $E=\\sum_{ij}\\phi(d_{ij})$, where $d_{ij}=\\lVert \\mathbf{r}_i-\\mathbf{r}_j\\rVert_2$ and $\\phi:\\mathbb{R}_{+}\\to\\mathbb{R}$ is twice continuously differentiable.\n- Definition of forces: $\\mathbf{F}_i=-\\nabla_{\\mathbf{r}_i}E$.\n- Chain rule for gradients and linearity of differentiation.\n\nYour program must implement:\n- An energy model $E=\\sum_{ij}\\phi(d_{ij})$ with pairwise distances $d_{ij}$ computed from $\\mathbf{r}_i$ in $\\mathrm{\\AA}$, where $\\phi(d)=a\\exp(-bd)+cd^2$ with parameters $a$ in $\\mathrm{eV}$, $b$ in $\\mathrm{\\AA}^{-1}$, and $c$ in $\\mathrm{eV}/\\mathrm{\\AA}^2$. The derivative is $\\phi'(d)=-ab\\exp(-bd)+2cd$.\n- Forces $\\mathbf{F}_i=-\\sum_{j\\neq i}\\phi'(d_{ij})\\frac{\\mathbf{r}_i-\\mathbf{r}_j}{d_{ij}}$ in $\\mathrm{eV}/\\mathrm{\\AA}$ computed analytically from the gradient of the energy.\n- A function that applies a rotation $\\mathbf{R}$ to all positions, with angles specified in radians.\n- A verification routine that, for each test case, computes $\\mathbf{F}_i$ on the original geometry, computes $\\mathbf{F}_i'$ on the rotated geometry, and checks whether $\\mathbf{F}_i'=\\mathbf{R}\\mathbf{F}_i$ within a specified numerical tolerance.\n\nYour test suite must include the following cases to ensure coverage:\n- Case $1$: Identity rotation $\\mathbf{R}=\\mathbf{I}$ applied to a nontrivial crystal fragment with parameters $(a,b,c)=(0.3,1.0,0.1)$ in respective units.\n- Case $2$: Rotation about the $z$-axis by angle $\\theta=\\pi/2$ applied to the same geometry and parameters $(a,b,c)=(0.3,1.0,0.1)$.\n- Case $3$: Rotation about the $x$-axis by angle $\\theta=\\pi$ applied to the same geometry and parameters $(a,b,c)=(0.3,1.0,0.1)$.\n- Case $4$: Rotation by a fixed axis-angle pair: axis proportional to $(1,2,3)$ normalized, angle $\\theta=1.234$ radians, applied to the same geometry and parameters $(a,b,c)=(0.3,1.0,0.1)$.\n- Case $5$: Random rotation with parameters $(a,b,c)=(0.0,1.0,0.0)$ that yield identically zero energy and zero forces; this verifies the boundary condition with zero forces.\n\nGeometric specification (positions in $\\mathrm{\\AA}$):\n- Use $N=5$ atoms located at\n$\\mathbf{r}_1=(0.0,0.0,0.0)$,\n$\\mathbf{r}_2=(2.8,0.0,0.0)$,\n$\\mathbf{r}_3=(1.4,2.424,0.0)$,\n$\\mathbf{r}_4=(1.4,0.808,2.8)$,\n$\\mathbf{r}_5=(0.0,2.4,2.0)$.\n\nNumerical requirements:\n- Use a tolerance of $\\varepsilon=10^{-10}$ on the maximum absolute difference between the rotated-force prediction and the rotation of the original forces, aggregated over all atoms and coordinates.\n- All angles must be specified in radians.\n- Positions must be in $\\mathrm{\\AA}$, energy in $\\mathrm{eV}$, and forces in $\\mathrm{eV}/\\mathrm{\\AA}$, but the final outputs are unitless booleans that indicate pass or fail per case.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}]$, where each $\\text{resultk}$ is a boolean from case $k$.",
            "solution": "The problem requires a formal proof and numerical verification of the rotational equivariance of forces derived from a rotationally invariant potential energy function. This principle is fundamental in physics and is a critical constraint for machine learning models, such as Graph Neural Networks (GNNs), that aim to predict physical quantities in three-dimensional space. A model that fails to respect this symmetry is physically inconsistent.\n\nWe begin with the mathematical formalism. Let the system consist of $N$ atoms with positions $\\{\\mathbf{r}_i\\}_{i=1}^N$, where each $\\mathbf{r}_i \\in \\mathbb{R}^3$. The total potential energy $E$ is given as a function of only the pairwise distances between atoms, $d_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert_2$. Specifically, the energy is $E = \\sum_{ij} \\phi(d_{ij})$, where $\\phi$ is a potential function. This form ensures that the energy depends on the internal configuration of the system, not its absolute orientation in space. The force on atom $i$ is defined as the negative gradient of the energy with respect to its position: $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} E$.\n\nThe core task is to demonstrate that if the positions undergo a rotation, the resulting forces are correspondingly rotated. Let a rotation be represented by an orthogonal matrix $\\mathbf{R} \\in \\mathrm{SO}(3)$, satisfying $\\mathbf{R}^{\\top}\\mathbf{R} = \\mathbf{I}$ and $\\det(\\mathbf{R})=1$. The new positions are $\\mathbf{r}_i' = \\mathbf{R}\\mathbf{r}_i$. We must show that the new forces $\\mathbf{F}_i'$ relate to the original forces $\\mathbf{F}_i$ by the equivariance relation $\\mathbf{F}_i' = \\mathbf{R}\\mathbf{F}_i$.\n\nFirst, we establish the rotational invariance of the energy $E$. The energy in the rotated system, $E'$, is computed using the new positions $\\mathbf{r}_i'$.\nThe pairwise distances in the rotated frame are $d_{ij}'$:\n$$\nd_{ij}' = \\lVert \\mathbf{r}_i' - \\mathbf{r}_j' \\rVert_2 = \\lVert \\mathbf{R}\\mathbf{r}_i - \\mathbf{R}\\mathbf{r}_j \\rVert_2\n$$\nBy the linearity of matrix-vector multiplication, this is:\n$$\nd_{ij}' = \\lVert \\mathbf{R}(\\mathbf{r}_i - \\mathbf{r}_j) \\rVert_2\n$$\nA fundamental property of orthogonal matrices is that they preserve the Euclidean norm, i.e., $\\lVert \\mathbf{R}\\mathbf{x} \\rVert_2 = \\lVert \\mathbf{x} \\rVert_2$ for any vector $\\mathbf{x} \\in \\mathbb{R}^3$. Applying this property, we find:\n$$\nd_{ij}' = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert_2 = d_{ij}\n$$\nThe distances between atoms are invariant under rotation. Since the energy $E = \\sum_{ij} \\phi(d_{ij})$ is a function only of these distances, it follows that the energy itself is invariant:\n$$\nE' = E(\\{\\mathbf{r}_k'\\}) = \\sum_{ij} \\phi(d_{ij}') = \\sum_{ij} \\phi(d_{ij}) = E(\\{\\mathbf{r}_k\\})\n$$\n\nNext, we prove the rotational equivariance of the forces. The force on atom $i$ in the rotated system is $\\mathbf{F}_i' = -\\nabla_{\\mathbf{r}_i'} E(\\{\\mathbf{r}_k'\\})$. To relate this to the original force $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} E(\\{\\mathbf{r}_k\\})$, we use the chain rule for differentiation with respect to transformed coordinates. The transformation is $\\mathbf{r}_i' = \\mathbf{R}\\mathbf{r}_i$, which can be inverted as $\\mathbf{r}_i = \\mathbf{R}^{-1}\\mathbf{r}_i' = \\mathbf{R}^{\\top}\\mathbf{r}_i'$ since $\\mathbf{R}$ is orthogonal.\nThe gradient operator transforms according to the Jacobian of the coordinate transformation. Let $J_{pq} = \\frac{\\partial (\\mathbf{r}_i)_p}{\\partial (\\mathbf{r}_i')_q}$. From $\\mathbf{r}_i = \\mathbf{R}^{\\top}\\mathbf{r}_i'$, we have $(\\mathbf{r}_i)_p = \\sum_q (\\mathbf{R}^{\\top})_{pq} (\\mathbf{r}_i')_q = \\sum_q R_{qp} (\\mathbf{r}_i')_q$. The Jacobian element is $\\frac{\\partial (\\mathbf{r}_i)_p}{\\partial (\\mathbf{r}_i')_q} = R_{qp} = (\\mathbf{R}^{\\top})_{pq}$. Thus, the Jacobian matrix is $\\mathbf{R}^{\\top}$.\nThe gradient operator in the original coordinates $\\nabla_{\\mathbf{r}_i}$ can be expressed in terms of the rotated coordinates $\\nabla_{\\mathbf{r}_i'}$ as:\n$$\n\\nabla_{\\mathbf{r}_i} = \\left(\\frac{\\partial \\mathbf{r}_i'}{\\partial \\mathbf{r}_i}\\right)^{\\top} \\nabla_{\\mathbf{r}_i'} = \\mathbf{R}^{\\top} \\nabla_{\\mathbf{r}_i'}\n$$\nInverting this relationship gives $\\nabla_{\\mathbf{r}_i'} = \\mathbf{R} \\nabla_{\\mathbf{r}_i}$.\n\nNow, we evaluate the gradient of the invariant energy function. Let us consider the energy as a function $E(\\mathbf{r}_1, \\dots, \\mathbf{r}_N)$. The invariance property means $E(\\mathbf{R}\\mathbf{r}_1, \\dots, \\mathbf{R}\\mathbf{r}_N) = E(\\mathbf{r}_1, \\dots, \\mathbf{r}_N)$. Let us differentiate this identity with respect to $\\mathbf{r}_i$:\n$$\n\\nabla_{\\mathbf{r}_i} E(\\mathbf{R}\\mathbf{r}_1, \\dots, \\mathbf{R}\\mathbf{r}_N) = \\nabla_{\\mathbf{r}_i} E(\\mathbf{r}_1, \\dots, \\mathbf{r}_N)\n$$\nApplying the chain rule to the left-hand side:\n$$\n\\sum_{j=1}^N \\left( \\frac{\\partial (\\mathbf{R}\\mathbf{r}_j)}{\\partial \\mathbf{r}_i} \\right)^{\\top} \\nabla_{\\mathbf{R}\\mathbf{r}_j} E(\\{\\mathbf{R}\\mathbf{r}_k\\}) = \\nabla_{\\mathbf{r}_i} E(\\{\\mathbf{r}_k\\})\n$$\nThe Jacobian term $\\frac{\\partial (\\mathbf{R}\\mathbf{r}_j)}{\\partial \\mathbf{r}_i}$ is the zero matrix for $j \\neq i$ and is the matrix $\\mathbf{R}$ for $j=i$. The sum thus collapses to a single term for $j=i$:\n$$\n\\mathbf{R}^{\\top} \\nabla_{\\mathbf{R}\\mathbf{r}_i} E(\\{\\mathbf{R}\\mathbf{r}_k\\}) = \\nabla_{\\mathbf{r}_i} E(\\{\\mathbf{r}_k\\})\n$$\nThe term $\\nabla_{\\mathbf{R}\\mathbf{r}_i} E(\\{\\mathbf{R}\\mathbf{r}_k\\})$ is the gradient of $E$ with respect to its $i$-th vector argument, evaluated at the rotated coordinates $\\{\\mathbf{R}\\mathbf{r}_k\\} = \\{\\mathbf{r}_k'\\}$. This is by definition the gradient that defines the force in the rotated frame, $\\nabla_{\\mathbf{r}_i'} E(\\{\\mathbf{r}_k'\\})$. Substituting the force definitions $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} E(\\{\\mathbf{r}_k\\})$ and $\\mathbf{F}_i' = -\\nabla_{\\mathbf{r}_i'} E(\\{\\mathbf{r}_k'\\})$, we get:\n$$\n\\mathbf{R}^{\\top} (-\\mathbf{F}_i') = -\\mathbf{F}_i \\implies \\mathbf{R}^{\\top} \\mathbf{F}_i' = \\mathbf{F}_i\n$$\nMultiplying from the left by $\\mathbf{R}$ and using $\\mathbf{R}\\mathbf{R}^{\\top}=\\mathbf{I}$ yields the desired equivariance relation:\n$$\n\\mathbf{R}(\\mathbf{R}^{\\top} \\mathbf{F}_i') = \\mathbf{R}\\mathbf{F}_i \\implies \\mathbf{I}\\mathbf{F}_i' = \\mathbf{R}\\mathbf{F}_i \\implies \\mathbf{F}_i' = \\mathbf{R}\\mathbf{F}_i\n$$\nThis completes the proof.\n\nThis result is directly applicable to the specified class of Graph Neural Networks. The problem states that the GNN messages depend \"exclusively on rotation-invariant scalars\". The energy model $E = \\sum_{ij} \\phi(d_{ij})$ is a simple but representative example of such a GNN, where only pairwise distances (which are rotation-invariant scalars) are used to compute an atom's contribution to the total energy. More complex GNNs for atomistic modeling might use other invariant scalars, such as angles between triplets of atoms or dihedral angles, as inputs to their message functions. As long as the final energy prediction is an aggregation of features that are themselves functions of only rotation-invariant scalars, the total energy will be rotationally invariant. The proof above then guarantees that the forces derived as the negative gradient of this energy will be rotationally equivariant. This is a crucial self-consistency check for any physics-based machine learning model. The numerical implementation will verify this property for the specified potential and geometry.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Verifies the rotational equivariance of forces derived from an invariant potential.\n    \"\"\"\n    \n    # Geometric specification in Angstroms\n    positions = np.array([\n        [0.0, 0.0, 0.0],\n        [2.8, 0.0, 0.0],\n        [1.4, 2.424, 0.0],\n        [1.4, 0.808, 2.8],\n        [0.0, 2.4, 2.0]\n    ])\n\n    # Numerical requirements\n    tolerance = 1e-10\n\n    def potential_derivative(d, a, b, c):\n        \"\"\"\n        Computes the derivative of the pairwise potential phi'(d).\n        phi(d) = a*exp(-b*d) + c*d^2\n        phi'(d) = -a*b*exp(-b*d) + 2*c*d\n        \"\"\"\n        return -a * b * np.exp(-b * d) + 2 * c * d\n\n    def compute_forces(pos, a, b, c):\n        \"\"\"\n        Computes the forces on each atom.\n        F_i = -sum_{j!=i} phi'(d_ij) * (r_i - r_j) / d_ij\n        \"\"\"\n        num_atoms = pos.shape[0]\n        forces = np.zeros((num_atoms, 3))\n        \n        for i in range(num_atoms):\n            for j in range(i + 1, num_atoms):\n                r_ij = pos[i] - pos[j]\n                d_ij = np.linalg.norm(r_ij)\n                \n                # Avoid division by zero, although not expected for this geometry\n                if d_ij  1e-12:\n                    continue\n                \n                phi_prime_val = potential_derivative(d_ij, a, b, c)\n                \n                # Force contribution on atom i from atom j\n                force_vec_contribution = -phi_prime_val * r_ij / d_ij\n                \n                forces[i] += force_vec_contribution\n                forces[j] -= force_vec_contribution  # Newton's third law\n        \n        return forces\n\n    def get_rotation_matrix(axis, angle):\n        \"\"\"\n        Creates a rotation matrix from an axis and an angle using Rodrigues' formula.\n        \"\"\"\n        axis = np.asarray(axis)\n        axis = axis / np.linalg.norm(axis)\n        \n        # Cross-product matrix (K)\n        K = np.array([\n            [0, -axis[2], axis[1]],\n            [axis[2], 0, -axis[0]],\n            [-axis[1], axis[0], 0]\n        ])\n        \n        # Rodrigues' rotation formula: R = I + sin(theta)*K + (1-cos(theta))*K^2\n        R = np.identity(3) + np.sin(angle) * K + (1 - np.cos(angle)) * np.dot(K, K)\n        return R\n\n    # Define test cases\n    # (params_tuple, rotation_matrix)\n    test_cases_defs = [\n        # Case 1: Identity rotation\n        {'params': (0.3, 1.0, 0.1), 'rotation': np.identity(3)},\n        # Case 2: Rotation about z-axis by pi/2\n        {'params': (0.3, 1.0, 0.1), 'rotation': get_rotation_matrix([0, 0, 1], np.pi / 2)},\n        # Case 3: Rotation about x-axis by pi\n        {'params': (0.3, 1.0, 0.1), 'rotation': get_rotation_matrix([1, 0, 0], np.pi)},\n        # Case 4: Rotation about a fixed axis-angle\n        {'params': (0.3, 1.0, 0.1), 'rotation': get_rotation_matrix([1, 2, 3], 1.234)},\n        # Case 5: Zero force boundary condition check with a non-trivial rotation\n        {'params': (0.0, 1.0, 0.0), 'rotation': get_rotation_matrix([1, 2, 3], 1.234)}\n    ]\n\n    results = []\n    for case in test_cases_defs:\n        a, b, c = case['params']\n        R = case['rotation']\n\n        # 1. Compute forces on the original geometry\n        F = compute_forces(positions, a, b, c)\n\n        # 2. Apply rotation to all positions\n        # Using row-vector convention, r' = r @ R.T\n        rotated_positions = positions @ R.T\n\n        # 3. Compute forces on the rotated geometry\n        F_prime = compute_forces(rotated_positions, a, b, c)\n\n        # 4. Rotate the original forces\n        # Using row-vector convention, F_rot = F @ R.T\n        R_F = F @ R.T\n        \n        # 5. Verify if F' == R @ F within tolerance\n        # Check |F'_i - (R @ F_i)|  tol for all i\n        max_abs_diff = np.max(np.abs(F_prime - R_F))\n        \n        is_equivariant = max_abs_diff  tolerance\n        results.append(is_equivariant)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r.item() for r in results]))}]\".lower())\n\nsolve()\n```"
        }
    ]
}