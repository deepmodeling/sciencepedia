{
    "hands_on_practices": [
        {
            "introduction": "将理论付诸实践是掌握任何复杂领域的关键。本章的动手实践旨在引导您解决将强化学习应用于电池充电时遇到的几个核心挑战。我们将从奖励函数设计的精妙之处开始，探讨看似直观的设定如何导致意想不到的策略偏差。这个练习  将通过一个清晰的计算反例，揭示直接惩罚电流平方 ($I^2$) 的奖励函数会如何抑制脉冲充电策略，即便在热管理系统能够完全处理焦耳热的理想情况下也是如此。",
            "id": "3946202",
            "problem": "一个电池充电智能体被建模为马尔可夫决策过程（MDP），该过程位于用于电池自动化设计和模拟的强化学习（RL）框架内。在每个离散时间步 $t \\in \\{0,1\\}$，智能体选择一个归一化充电电流 $i_t \\in [0,1]$，其中物理电流为 $I_t = i_t I_{\\max}$。归一化荷电状态 $s_t \\in [0,1]$ 根据单位效率的库仑电荷转移定义演变，因此 $s_{t+1} = s_t + i_t$，输送的电荷增量为 $s_{t+1} - s_t = i_t$。电芯中的焦耳热与 $I_t^2$ 成正比，但一个专用的热管理控制器（外在于RL智能体）会施加冷却，在每个时间步完美补偿焦耳热，从而维持一个恒定的归一化温度 $\\theta_t$；也就是说，尽管 $i_t$ 的值不同，但对于所有 $t$ 都有 $\\theta_{t+1} = \\theta_t$。\n\n智能体在每个时间步的塑形奖励定义为\n$$\nr_t = \\beta \\, (s_{t+1} - s_t) - \\alpha \\, i_t^{2},\n$$\n其中 $\\beta = 1$ 且 $\\alpha = 1$。片段长度为 $N = 2$（时间步 $t=0,1$），回报为 $G = \\sum_{t=0}^{N-1} r_t$。\n\n为了探究直接惩罚 $i_t^2$ 的朴素奖励塑形是否会在热安全完全得到管理的情况下，仍然使策略偏向于反对脉冲充电，请比较以下两种轨迹。这两种轨迹由于完美的热管理，输送了相同的总电荷并保持了相同的温度：\n\n- 恒流轨迹：$i_0 = \\frac{1}{2}$ 和 $i_1 = \\frac{1}{2}$。\n- 脉冲充电轨迹：$i_0 = 1$ 和 $i_1 = 0$。\n\n计算累积塑形回报之差的精确值，\n$$\nG_{\\mathrm{pulse}} - G_{\\mathrm{const}},\n$$\n结果应为一个实数。请以精确值的形式给出最终答案，不带单位（回报是无量纲的）。",
            "solution": "问题要求计算两种不同充电轨迹之间的累积塑形回报之差 $G_{\\mathrm{pulse}} - G_{\\mathrm{const}}$。分析从奖励函数和总回报的定义开始。\n\n每个时间步 $t$ 的奖励由以下表达式给出：\n$$\nr_t = \\beta \\, (s_{t+1} - s_t) - \\alpha \\, i_t^{2}\n$$\n归一化荷电状态 $s_t$ 的状态演变定义为：\n$$\ns_{t+1} = s_t + i_t\n$$\n这意味着一个时间步内的电荷增量等于该步施加的归一化电流：\n$$\ns_{t+1} - s_t = i_t\n$$\n将此关系代入奖励函数，可以简化 $r_t$ 的表达式。它变得仅依赖于该步采取的动作 $i_t$：\n$$\nr_t = \\beta \\, i_t - \\alpha \\, i_t^{2}\n$$\n问题指定了参数 $\\beta$ 和 $\\alpha$ 的值为：\n$$\n\\beta = 1\n$$\n$$\n\\alpha = 1\n$$\n因此，该问题的特定奖励函数为：\n$$\nr_t = i_t - i_t^{2}\n$$\n总回报 $G$ 是整个片段（长度为 $N=2$，即时间步 $t=0$ 和 $t=1$）的奖励之和：\n$$\nG = \\sum_{t=0}^{N-1} r_t = r_0 + r_1\n$$\n代入 $r_t$ 的表达式，总回报为：\n$$\nG = (i_0 - i_0^{2}) + (i_1 - i_1^{2})\n$$\n我们现在计算两种指定轨迹各自的总回报。\n\n首先，考虑恒流轨迹，其中 $i_0 = \\frac{1}{2}$ 且 $i_1 = \\frac{1}{2}$。总回报 $G_{\\mathrm{const}}$ 的计算如下：\n$$\nG_{\\mathrm{const}} = \\left(\\frac{1}{2} - \\left(\\frac{1}{2}\\right)^2\\right) + \\left(\\frac{1}{2} - \\left(\\frac{1}{2}\\right)^2\\right)\n$$\n$$\nG_{\\mathrm{const}} = \\left(\\frac{1}{2} - \\frac{1}{4}\\right) + \\left(\\frac{1}{2} - \\frac{1}{4}\\right)\n$$\n$$\nG_{\\mathrm{const}} = \\frac{1}{4} + \\frac{1}{4} = \\frac{1}{2}\n$$\n\n接下来，考虑脉冲充电轨迹，其中 $i_0 = 1$ 且 $i_1 = 0$。总回报 $G_{\\mathrm{pulse}}$ 的计算如下：\n$$\nG_{\\mathrm{pulse}} = (1 - 1^2) + (0 - 0^2)\n$$\n$$\nG_{\\mathrm{pulse}} = (1 - 1) + (0 - 0)\n$$\n$$\nG_{\\mathrm{pulse}} = 0 + 0 = 0\n$$\n\n最后，我们计算脉冲充电轨迹和恒流轨迹的回报之差：\n$$\nG_{\\mathrm{pulse}} - G_{\\mathrm{const}} = 0 - \\frac{1}{2}\n$$\n$$\nG_{\\mathrm{pulse}} - G_{\\mathrm{const}} = -\\frac{1}{2}\n$$\n这个结果表明，对于给定的奖励结构，恒流轨迹产生的累积回报高于脉冲充电轨迹，尽管两者都输送了相同的总电荷（$i_0 + i_1 = 1$）并且其热效应得到了完美的管理。惩罚项 $-i_t^2$ 是非线性的，它更严厉地惩罚较高的瞬时电流，从而导致了这种偏差。",
            "answer": "$$\n\\boxed{-\\frac{1}{2}}\n$$"
        },
        {
            "introduction": "设计并训练出一个充电策略后，我们如何严谨地评估其性能并量化其可靠性？强化学习策略在模拟中的表现本身是一个随机变量，单次或少数几次的评估结果可能具有误导性。本章的最后一个实践  聚焦于策略的后训练评估，引入了一种强大的非参数统计工具——自助法 (bootstrap)，用于为策略的预期性能构建置信区间。通过这个练习，您将学会如何超越简单的平均性能指标，为策略的可靠性提供统计保证，并理解模拟结果的局限性。",
            "id": "3946228",
            "problem": "您正在一个物理一致的自动化电池模拟器中评估一个已学习的强化学习 (RL) 充电策略。在每个评估回合中，该策略从一个受控的初始健康状态和环境开始执行一个充电协议，模拟器返回该回合的综合退化量，表示为在该回合中损失的标称容量的分数。将每个回合的退化量记为随机变量 $D$，以分数容量单位（无量纲）衡量。假设您在固定的已学习策略下运行了 $n$ 个回合，并获得了观测值 $d_1,\\dots,d_n$，其中 $d_i \\in [0,\\infty)$ 是分数。您希望推断每个回合的期望退化量 $\\mu = \\mathbb{E}[D]$，并使用对回合进行非参数自助法（nonparametric bootstrap）来量化不确定性。\n\n从期望和样本均值的基本定义出发，并基于固定策略和静态环境下回合是独立同分布（IID）的基本抽样假设，设计一种方法，通过有放回地重采样回合（非参数自助法）来为 $\\mu$ 构建一个 $(1-\\alpha)$ 中心置信区间。不要对 $D$ 的分布做任何参数形式的假设。您的推导必须解释正在估计什么，为什么根据插件原则（plug-in principle）重采样回合可以作为样本均值抽样分布的近似是合理的，以及如何从经验自助法分布构建该区间。然后，将此方法实现为一个程序，给定一个小的回合数据集测试套件，返回所要求的区间。最后，讨论这些区间在强化学习用于充电背景下的解释性限制，特别是关于回合间的依赖性、策略的非平稳性以及模拟器与现实之间的差距。所有物理量必须以分数容量单位（无量纲）表示。如果需要表示比率或比例，请以小数形式表示，而不是百分比。\n\n使用的数学基础和约束：\n- 回合被建模为在固定策略和静态模拟器下对 $D$ 的独立同分布（IID）抽取。目标是 $\\mu = \\mathbb{E}[D]$。\n- 估计量是样本均值 $\\bar{D}_n = \\frac{1}{n}\\sum_{i=1}^n d_i$。\n- 自助法使用经验分布，该分布在每个观测到的 $d_i$ 处赋予 $\\frac{1}{n}$ 的概率质量，并有放回地重采样 $n$ 次，以形成均值的一个自助法复制。重复此过程 $B$ 次，以近似 $\\bar{D}_n$ 的抽样分布。\n- 通过取 $B$ 个自助法复制在 $\\frac{\\alpha}{2}$ 和 $1-\\frac{\\alpha}{2}$ 水平上的下分位数和上分位数来构建一个中心 $(1-\\alpha)$ 区间。\n\n不涉及角度单位。所有输出必须是分数容量单位（无量纲小数）。\n\n测试套件和可复现性：\n- 在每个测试用例中，为自助法重采样使用带有固定种子的伪随机数生成器，以确保确定性输出。使用下面指定的种子。\n- 对于每个测试用例，使用 $B$ 次自助法复制，在指定的显著性水平 $\\alpha$ 下，计算并返回 $\\mu$ 的中心百分位置信区间。\n\n测试用例：\n- A 例（理想情况，中等变异性）：$n = 20$，$B = 5000$，$\\alpha = 0.10$，种子 $= 123$。回合退化量：[$0.0010$, $0.0012$, $0.0011$, $0.0015$, $0.0013$, $0.0014$, $0.0016$, $0.0012$, $0.0018$, $0.0017$, $0.0013$, $0.0019$, $0.0020$, $0.0015$, $0.0014$, $0.0016$, $0.0011$, $0.0012$, $0.0018$, $0.0010$]。\n- B 例（有离群值的偏态分布）：$n = 15$，$B = 5000$，$\\alpha = 0.05$，种子 $= 456$。回合退化量：[$0.0006$, $0.0007$, $0.0005$, $0.0006$, $0.0008$, $0.0007$, $0.0006$, $0.0005$, $0.0007$, $0.0006$, $0.0005$, $0.0007$, $0.0006$, $0.0006$, $0.0100$]。\n- C 例（退化方差）：$n = 10$，$B = 5000$，$\\alpha = 0.20$，种子 $= 789$。回合退化量：[$0.0010$, $0.0010$, $0.0010$, $0.0010$, $0.0010$, $0.0010$, $0.0010$, $0.0010$, $0.0010$, $0.0010$]。\n- D 例（单回合边界情况）：$n = 1$，$B = 5000$，$\\alpha = 0.05$，种子 $= 101112$。回合退化量：[$0.0015$]。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个元素是对应测试用例区间的下界和上界组成的双元素列表 [$L$, $U$]，顺序为 A、B、C、D。例如：\"[[L_A,U_A],[L_B,U_B],[L_C,U_C],[L_D,U_D]]\"。每个 $L$ 和 $U$ 都必须是分数容量单位的小数。",
            "solution": "问题要求设计并实现一种方法，使用非参数自助法为每个回合的电池期望退化量 $\\mu$ 构建一个中心置信区间。该方法基于从一个运行固定强化学习策略的基于物理的模拟器中获得的 $n$ 个观测退化值 $d_1, d_2, \\dots, d_n$ 样本。\n\n目标参数是每个回合的真实期望退化量，记为 $\\mu = \\mathbb{E}[D]$，其中 $D$ 是代表退化量的随机变量。观测数据 $\\{d_1, \\dots, d_n\\}$ 被假定为从 $D$ 的真实但未知的概率分布 $F$ 中抽取的 $n$ 个独立同分布（IID）实现的样本。$\\mu$ 的一个自然且无偏的点估计量是样本均值：\n$$\n\\bar{D}_n = \\frac{1}{n}\\sum_{i=1}^n d_i\n$$\n为了量化此估计中的不确定性，我们的目标是为 $\\mu$ 构建一个 $(1-\\alpha)$ 置信区间。置信区间是根据样本数据计算出的一个区间，如果实验重复多次，该区间在 $(1-\\alpha)$ 的情况下会包含真实参数 $\\mu$。构建这样的区间需要了解估计量 $\\bar{D}_n$ 的抽样分布，该分布描述了从真实分布 $F$ 中抽取的不同大小为 $n$ 的随机样本中 $\\bar{D}_n$ 的值会如何变化。\n\n主要困难在于真实分布 $F$ 是未知的，因此 $\\bar{D}_n$ 的确切抽样分布也是未知的。非参数自助法提供了一种计算方法来近似这个抽样分布，而无需对 $F$ 的参数形式做任何假设。该程序的合理性建立在**插件原则（plug-in principle）**之上。插件原则表明，我们可以通过在 $F$ 的经验估计上计算相同的泛函来估计真实分布 $F$ 的一个泛函。从数据 $\\{d_1, \\dots, d_n\\}$ 中对 $F$ 的最佳非参数估计是经验分布函数（EDF），记为 $\\hat{F}_n$。该分布在每个观测数据点 $d_i$ 上放置 $\\frac{1}{n}$ 的概率质量。\n\n自助法使用此原则来近似 $\\bar{D}_n$ 的抽样分布。我们不是从未知的真实分布 $F$ 中抽样，而是从我们对它的最佳估计 $\\hat{F}_n$ 中抽样。从 $\\hat{F}_n$ 中抽取一个大小为 $n$ 的样本的过程，等同于从原始数据集 $\\{d_1, \\dots, d_n\\}$ 中有放回地抽取 $n$ 个值。\n\n构建 $(1-\\alpha)$ 中心百分位自助法置信区间的算法如下：\n1. 从原始数据样本 $\\{d_1, \\dots, d_n\\}$ 中，生成大量的（$B$ 个）自助法样本。每个自助法样本 $\\{d_{1,j}^*, \\dots, d_{n,j}^*\\}$（其中 $j=1, \\dots, B$）都是通过从原始样本中有放回地抽取 $n$ 个数据点形成的。\n2. 对于 $B$ 个自助法样本中的每一个，计算样本均值（统计量的自助法复制）：\n$$\n\\bar{d}_j^* = \\frac{1}{n}\\sum_{i=1}^n d_{i,j}^*\n$$\n3. 这 $B$ 个自助法均值的集合 $\\{\\bar{d}_1^*, \\dots, \\bar{d}_B^*\\}$，构成了 $\\bar{D}_n$ 抽样分布的一个经验近似。\n4. 为了构建中心 $(1-\\alpha)$ 置信区间，我们找到这个自助法分布的经验分位数。下界 $L$ 是排序后的自助法均值的第 $100 \\times (\\frac{\\alpha}{2})$ 百分位数，上界 $U$ 是第 $100 \\times (1-\\frac{\\alpha}{2})$ 百分位数。\n\n该方法通过从样本本身进行重采样，有效地模拟了从总体中重采样的过程，从而提供了对均值抽样变异性的估计。\n\n**在强化学习用于充电背景下的解释性限制**\n\n尽管自助法置信区间在统计上很强大，但其有效性和解释依赖于几个关键假设，这些假设在实际应用中可能会受到挑战。\n\n1. **回合间的依赖性**：该方法从根本上假设退化值 $d_i$ 是独立同分布的。在电池充电中，这要求每个回合都从相同的初始状态开始。然而，如果一个充电回合的退化会延续并改变下一个回合的初始健康状态（SoH），那么这些回合就不再是独立的。回合 $i+1$ 的退化将取决于回合 $i$ 的结果。这种时间上的依赖性违反了独立同分布（IID）的假设，由此产生的置信区间可能不准确，通常会低估长期平均退化的真实不确定性。\n\n2. **策略的非平稳性**：该分析基于一个*固定*的已学习策略。如果在收集数据的 $n$ 个回合中，强化学习代理仍在训练或调整其策略，那么该策略就是非平稳的。这意味着抽取 $d_i$ 的分布 $F$ 在不同回合之间是变化的。这样一来，样本将是来自不同分布的混合体，计算出的均值 $\\mu$ 及其置信区间将不对应于任何单一、稳定策略的性能，从而使结果难以解释。\n\n3. **模拟到现实（Sim2Real）的差距**：整个分析是使用来自模拟器的数据进行的。由此产生的置信区间量化了*模拟环境内*平均退化量的*统计不确定性*。它描述了由于只运行了有限数量的回合（$n$），我们对该策略*在模拟器中*的真实平均性能的不确定性。这个区间没有提供任何关于由模拟器物理特性与真实世界电池行为之间的差异（即“模拟到现实的差距”）所引起的*系统误差*或*模型形式不确定性*的信息。真实的现实世界退化可能系统性地高于或低于模拟值，并且现实世界的均值可能远远超出计算出的置信区间。因此，如果没有对模拟器与经验数据进行独立的、严格的验证，该区间不能被解释为策略在物理电池上性能的可靠范围。\n\n总之，自助法置信区间是在具有独立同分布回合的静态模拟环境范围内量化统计不确定性的强大工具。将其推广到现实世界的性能需要仔细考虑回合间的依赖性、策略的平稳性以及模拟器的保真度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating bootstrap confidence intervals for the mean\n    degradation for several test cases.\n    \"\"\"\n\n    def calculate_bootstrap_ci(data, n_boot, alpha, seed):\n        \"\"\"\n        Calculates a (1-alpha) central confidence interval for the mean of the data\n        using the nonparametric percentile bootstrap method.\n\n        Args:\n            data (list or np.array): The observed data points.\n            n_boot (int): The number of bootstrap replications.\n            alpha (float): The significance level for the interval.\n            seed (int): The seed for the random number generator.\n\n        Returns:\n            list: A list containing the lower and upper bounds of the confidence interval.\n        \"\"\"\n        n = len(data)\n        data_arr = np.array(data)\n        \n        # Initialize a random number generator with the specified seed for reproducibility.\n        rng = np.random.default_rng(seed)\n        \n        # Handle the edge case of n=1, where bootstrap resampling is degenerate.\n        # Any resample will be the single element itself.\n        if n == 1:\n            mean_val = data_arr[0]\n            return [mean_val, mean_val]\n\n        # Generate bootstrap replicate means.\n        bootstrap_means = np.zeros(n_boot)\n        for i in range(n_boot):\n            # Draw n samples with replacement from the original data.\n            bootstrap_sample = rng.choice(data_arr, size=n, replace=True)\n            # Calculate the mean of the bootstrap sample.\n            bootstrap_means[i] = np.mean(bootstrap_sample)\n\n        # Calculate the lower and upper percentile points for the central interval.\n        lower_quantile = (alpha / 2.0) * 100.0\n        upper_quantile = (1.0 - alpha / 2.0) * 100.0\n        \n        # Determine the confidence interval from the percentiles of the bootstrap distribution.\n        lower_bound, upper_bound = np.percentile(bootstrap_means, [lower_quantile, upper_quantile])\n        \n        return [lower_bound, upper_bound]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"id\": \"A\", \"n\": 20, \"B\": 5000, \"alpha\": 0.10, \"seed\": 123,\n            \"data\": [0.0010, 0.0012, 0.0011, 0.0015, 0.0013, 0.0014, 0.0016, 0.0012, \n                     0.0018, 0.0017, 0.0013, 0.0019, 0.0020, 0.0015, 0.0014, 0.0016, \n                     0.0011, 0.0012, 0.0018, 0.0010]\n        },\n        {\n            \"id\": \"B\", \"n\": 15, \"B\": 5000, \"alpha\": 0.05, \"seed\": 456,\n            \"data\": [0.0006, 0.0007, 0.0005, 0.0006, 0.0008, 0.0007, 0.0006, 0.0005, \n                     0.0007, 0.0006, 0.0005, 0.0007, 0.0006, 0.0006, 0.0100]\n        },\n        {\n            \"id\": \"C\", \"n\": 10, \"B\": 5000, \"alpha\": 0.20, \"seed\": 789,\n            \"data\": [0.0010, 0.0010, 0.0010, 0.0010, 0.0010, 0.0010, 0.0010, 0.0010, \n                     0.0010, 0.0010]\n        },\n        {\n            \"id\": \"D\", \"n\": 1, \"B\": 5000, \"alpha\": 0.05, \"seed\": 101112,\n            \"data\": [0.0015]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate the confidence interval for the current test case.\n        interval = calculate_bootstrap_ci(\n            data=case[\"data\"],\n            n_boot=case[\"B\"],\n            alpha=case[\"alpha\"],\n            seed=case[\"seed\"]\n        )\n        results.append(interval)\n\n    # Convert the list of lists to the required string format.\n    # e.g., [[L_A, U_A], [L_B, U_B], ...]\n    result_str = str(results).replace(\" \", \"\")\n\n    # Final print statement in the exact required format.\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}