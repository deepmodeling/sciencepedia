{
    "hands_on_practices": [
        {
            "introduction": "虚拟样机的准确性始于其输入的质量。这个练习模拟了一个基本但至关重要的验证步骤：传感器校准。你将使用假设的实验数据，通过统计学上严谨的加权最小二乘法来校准电池单元内部的热电偶，并推导校准参数的协方差。此实践的核心在于将这些来自校准的不确定性，通过一阶不确定性传播，量化到最终的物理量——产热率——的估计中，从而让你亲身体验误差如何在模型链中传递和放大。",
            "id": "3959862",
            "problem": "一个用于虚拟样机研究的锂离子软包电池，内部安装了一个嵌入式热电偶，其原始读数被处理成以开尔文为单位的测量温度 $T_{\\mathrm{meas}}$。为验证虚拟样机并量化误差，该热电偶在一系列温箱设定点下，以铂电阻温度计（PRT）的参考测量值 $T_{\\mathrm{true}}$ 为基准进行校准。假设PRT读数具有独立的高斯不确定度，其标准差已知，并且在校准中，$T_{\\mathrm{meas}}$ 可被视为不确定度可忽略的自变量。\n\n给定一个热电偶的校准数据：\n- 五个设定点下的测量配对 $(T_{\\mathrm{meas},i}, T_{\\mathrm{true},i})$：$(298.0, 298.10)$、$(308.0, 308.12)$、$(318.0, 318.14)$、$(328.0, 328.16)$、$(338.0, 338.18)$，单位均为开尔文。\n- 每个参考值 $T_{\\mathrm{true},i}$ 的标准不确定度为 $\\sigma_i = 0.10$ 开尔文。\n\n将校准建模为线性关系 $T_{\\mathrm{true}} = a + b\\,T_{\\mathrm{meas}}$，并使用一个从高斯误差模型出发、能得出最大似然线性拟合结果的统计可靠方法来估计参数 $a$ 和 $b$。然后，从第一性原理出发，推导参数 $(a,b)$ 的协方差矩阵。\n\n在一个用于验证虚拟样机并量化误差的独立放电实验中，在特定时间 $t^\\star$ 测量到的量为：\n- $T_{\\mathrm{meas}}(t^\\star) = 320.0$ 开尔文，\n- $\\frac{d T_{\\mathrm{meas}}}{dt}(t^\\star) = 0.020$ 开尔文/秒。\n\n假设基于热力学第一定律和牛顿对流冷却定律，电芯加夹具节点满足集总能量平衡，\n$$ q = m\\,c\\,\\frac{d T_{\\mathrm{true}}}{dt} + h\\,A\\,\\left(T_{\\mathrm{true}} - T_{\\mathrm{amb}}\\right), $$\n其中 $m = 0.050$ 千克，$c = 1100$ 焦耳/千克·开尔文，$h\\,A = 2.5$ 瓦特/开尔文，以及 $T_{\\mathrm{amb}} = 298.0$ 开尔文。将 $m$、$c$、$h\\,A$、$T_{\\mathrm{amb}}$、$T_{\\mathrm{meas}}(t^\\star)$ 和 $\\frac{d T_{\\mathrm{meas}}}{dt}(t^\\star)$ 视为精确已知值。使用校准关系式 $T_{\\mathrm{true}} = a + b\\,T_{\\mathrm{meas}}$ 和 $\\frac{d T_{\\mathrm{true}}}{dt} = b\\,\\frac{d T_{\\mathrm{meas}}}{dt}$。\n\n通过线性（一阶）不确定度传播，传递校准参数的不确定度，以获得在时间 $t^\\star$ 时产热率 $q$ 的标准不确定度，并充分考虑拟合产生的 $a$ 和 $b$ 之间的协方差。\n\n将最终的 $q$ 的标准不确定度答案四舍五入到四位有效数字。最终答案以瓦特为单位表示。",
            "solution": "求解过程主要分为三个部分：\n1.  使用最大似然法估计校准参数 $a$ 和 $b$。\n2.  推导参数 $(a,b)$ 的协方差矩阵。\n3.  传递参数不确定度以计算产热率 $q$ 的不确定度。\n\n**1. 校准参数的最大似然估计**\n\n模型为 $T_{\\mathrm{true}} = a + b\\,T_{\\mathrm{meas}}$。给定 $N=5$ 对数据 $(x_i, y_i) = (T_{\\mathrm{meas},i}, T_{\\mathrm{true},i})$，其中每个 $y_i$ 都具有高斯不确定度，其标准差 $\\sigma_i$ 已知。在给定模型下观测到特定 $y_i$ 的概率为：\n$$ P(y_i|x_i, a, b) = \\frac{1}{\\sigma_i\\sqrt{2\\pi}} \\exp\\left(-\\frac{(y_i - (a+bx_i))^2}{2\\sigma_i^2}\\right) $$\n假设测量是独立的，总似然函数 $\\mathcal{L}$ 是单个概率的乘积。最大化 $\\mathcal{L}$ 等价于最小化负对数似然，这可以简化为最小化卡方函数 $\\chi^2$：\n$$ \\chi^2(a,b) = \\sum_{i=1}^N \\left(\\frac{y_i - a - bx_i}{\\sigma_i}\\right)^2 = \\sum_{i=1}^N w_i (y_i - a - bx_i)^2 $$\n其中权重为 $w_i = 1/\\sigma_i^2$。\n为了找到最小化 $\\chi^2$ 的参数 $a$ 和 $b$，我们将偏导数设为零：\n$$ \\frac{\\partial\\chi^2}{\\partial a} = -2\\sum_{i=1}^N w_i(y_i - a - bx_i) = 0 \\implies a\\sum w_i + b\\sum w_i x_i = \\sum w_i y_i $$\n$$ \\frac{\\partial\\chi^2}{\\partial b} = -2\\sum_{i=1}^N w_i x_i(y_i - a - bx_i) = 0 \\implies a\\sum w_i x_i + b\\sum w_i x_i^2 = \\sum w_i x_i y_i $$\n在本问题中，所有 $\\sigma_i = 0.10$ K，因此权重 $w_i = w = 1/(0.10)^2 = 100$ 是常数，可以被提出来。这将正规方程组简化为非加权情况：\n$$ aN + b\\sum x_i = \\sum y_i $$\n$$ a\\sum x_i + b\\sum x_i^2 = \\sum x_i y_i $$\n数据为 $x_i = \\{298.0, 308.0, 318.0, 328.0, 338.0\\}$ 和 $y_i = \\{298.10, 308.12, 318.14, 328.16, 338.18\\}$。我们计算所需的总和：\n- $N=5$\n- $\\sum x_i = 1590.0$\n- $\\sum y_i = 1590.70$\n- $\\sum x_i^2 = 298.0^2 + 308.0^2 + 318.0^2 + 328.0^2 + 338.0^2 = 506620.0$\n- $\\sum x_i y_i = (298.0)(298.10) + \\dots + (338.0)(338.18) = 506742.6$\n\n方程组为：\n$$ 5a + 1590b = 1590.70 $$\n$$ 1590a + 506620b = 506742.6 $$\n解此方程组可得最大似然估计值：\n$b = 1.002$\n$a = -0.496$\n\n**2. 参数的协方差矩阵**\n\n参数 $(a,b)$ 的协方差矩阵 $\\mathbf{C}$ 由费雪信息矩阵的逆给出，对于加权线性最小二乘法，这是 $\\frac{1}{2}\\chi^2$ 的二阶导数矩阵（Hessian矩阵的一半）的逆：\n$$ \\mathbf{C} = \\begin{pmatrix} \\sum w_i & \\sum w_i x_i \\\\ \\sum w_i x_i & \\sum w_i x_i^2 \\end{pmatrix}^{-1} $$\n使用常数权重 $w=100$：\n- $\\sum w_i = Nw = 5 \\times 100 = 500$\n- $\\sum w_i x_i = w \\sum x_i = 100 \\times 1590.0 = 159000$\n- $\\sum w_i x_i^2 = w \\sum x_i^2 = 100 \\times 506620.0 = 50662000$\n\n需要求逆的矩阵是：\n$$ \\mathbf{M} = \\begin{pmatrix} 500 & 159000 \\\\ 159000 & 50662000 \\end{pmatrix} $$\n其行列式为 $\\det(\\mathbf{M}) = (500)(50662000) - (159000)^2 = 25331000000 - 25281000000 = 50000000$。\n逆矩阵是：\n$$ \\mathbf{C} = \\frac{1}{\\det(\\mathbf{M})} \\begin{pmatrix} 50662000 & -159000 \\\\ -159000 & 500 \\end{pmatrix} = \\frac{1}{5 \\times 10^7} \\begin{pmatrix} 5.0662 \\times 10^7 & -1.59 \\times 10^5 \\\\ -1.59 \\times 10^5 & 500 \\end{pmatrix} $$\n$$ \\mathbf{C} = \\begin{pmatrix} \\sigma_a^2 & \\mathrm{cov}(a,b) \\\\ \\mathrm{cov}(a,b) & \\sigma_b^2 \\end{pmatrix} = \\begin{pmatrix} 1.01324 & -0.00318 \\\\ -0.00318 & 1.0 \\times 10^{-5} \\end{pmatrix} $$\n$\\sigma_a^2$ 的单位是 $\\mathrm{K}^2$，$\\sigma_b^2$ 是无量纲的，$\\mathrm{cov}(a,b)$ 的单位是 $\\mathrm{K}$。\n\n**3. 产热率的不确定度传播**\n\n产热率 $q$ 由下式给出：\n$$ q = m\\,c\\,\\frac{d T_{\\mathrm{true}}}{dt} + h\\,A\\,\\left(T_{\\mathrm{true}} - T_{\\mathrm{amb}}\\right) $$\n使用校准模型 $T_{\\mathrm{true}} = a + b\\,T_{\\mathrm{meas}}$，我们还有 $\\frac{d T_{\\mathrm{true}}}{dt} = b\\,\\frac{d T_{\\mathrm{meas}}}{dt}$。\n将这些代入 $q$ 的方程，得到 $q$ 作为参数 $a$ 和 $b$ 的函数：\n$$ q(a,b) = m\\,c\\,\\left(b\\,\\frac{d T_{\\mathrm{meas}}}{dt}\\right) + h\\,A\\,\\left((a + b\\,T_{\\mathrm{meas}}) - T_{\\mathrm{amb}}\\right) $$\n重新排列以分离 $a$ 和 $b$：\n$$ q(a,b) = (hA) a + \\left(mc \\frac{dT_{\\mathrm{meas}}}{dt} + hA T_{\\mathrm{meas}}\\right) b - hA T_{\\mathrm{amb}} $$\n对于线性（一阶）不确定度传播，$q$ 的方差 $\\sigma_q^2$ 由下式给出：\n$$ \\sigma_q^2 = \\left(\\frac{\\partial q}{\\partial a}\\right)^2 \\sigma_a^2 + \\left(\\frac{\\partial q}{\\partial b}\\right)^2 \\sigma_b^2 + 2\\left(\\frac{\\partial q}{\\partial a}\\right)\\left(\\frac{\\partial q}{\\partial b}\\right) \\mathrm{cov}(a,b) $$\n偏导数是 $q(a,b)$ 表达式中 $a$ 和 $b$ 的系数：\n$$ \\frac{\\partial q}{\\partial a} = hA $$\n$$ \\frac{\\partial q}{\\partial b} = mc \\frac{dT_{\\mathrm{meas}}}{dt} + hA T_{\\mathrm{meas}} $$\n我们使用在时间 $t^\\star$ 给定的值来计算这些导数：\n- $hA = 2.5 \\, \\text{W/K}$\n- $mc = (0.050 \\, \\text{kg})(1100 \\, \\text{J/(kg K)}) = 55 \\, \\text{J/K}$\n- $T_{\\mathrm{meas}}(t^\\star) = 320.0 \\, \\text{K}$\n- $\\frac{dT_{\\mathrm{meas}}}{dt}(t^\\star) = 0.020 \\, \\text{K/s}$\n\n因此，导数为：\n$$ \\frac{\\partial q}{\\partial a} = 2.5 $$\n$$ \\frac{\\partial q}{\\partial b} = (55)(0.020) + (2.5)(320.0) = 1.1 + 800.0 = 801.1 $$\n现在我们将这些值和协方差矩阵的元素代入方差公式：\n$$ \\sigma_q^2 = (2.5)^2(1.01324) + (801.1)^2(1.0 \\times 10^{-5}) + 2(2.5)(801.1)(-0.00318) $$\n$$ \\sigma_q^2 = (6.25)(1.01324) + (641761.21)(1.0 \\times 10^{-5}) + (5)(801.1)(-0.00318) $$\n$$ \\sigma_q^2 = 6.33275 + 6.4176121 - 12.73749 $$\n$$ \\sigma_q^2 = 0.0128721 \\, \\mathrm{W}^2 $$\n标准不确定度 $\\sigma_q$ 是方差的平方根：\n$$ \\sigma_q = \\sqrt{0.0128721} \\approx 0.11345527 \\, \\mathrm{W} $$\n按要求四舍五入到四位有效数字，得到 $0.1135 \\, \\mathrm{W}$。",
            "answer": "$$\n\\boxed{0.1135}\n$$"
        },
        {
            "introduction": "超越单点误差分析，对虚拟样机进行验证通常需要评估其在动态操作和参数不确定性下的系统级行为。本实践采用蒙特卡洛方法，在一个集成了电、热和电化学动力学的电池模型中，同时传播多个不确定参数的分布。你的任务是量化由于这些不确定性导致模型状态（如温度、电压）超出预设安全边界的频率，这是一种被称为基于约束的验证的关键技术，对于评估系统可靠性和风险至关重要。",
            "id": "3959907",
            "problem": "您将为一个在参数不确定性下的锂离子电池单元模型实现一个虚拟原型设计与验证工作流。目标是执行基于约束的验证，即拒绝任何状态变量超出物理允许范围的模拟，并为每个给定的测试用例将拒绝频率量化为一个十进制小数。程序必须通过从指定的分布中对输入参数进行采样，并模拟随时间变化的轨迹，来在模型中传播不确定性。\n\n基本基础包括电荷守恒、能量守恒和线性电路动力学，具体规定如下：\n\n- 令荷电状态 (SOC) 表示为 $s(t)$，电芯温度（单位：开尔文）表示为 $T(t)$，极化态电压表示为 $v_{\\mathrm{rc}}(t)$，代表单元素过电势的阻容 (RC) 动力学。\n- 在每次模拟运行中，电池承受恒定的放电电流 $I$（单位：安培）、串联电阻 $R$（单位：欧姆）、标称容量 $Q_{\\mathrm{nom}}$（单位：库仑）、集总热容 $C_{\\mathrm{th}}$（单位：焦耳/开尔文）以及集总传热系数-面积乘积 $hA$（单位：瓦特/开尔文）。环境温度为 $T_{\\mathrm{amb}}$（单位：开尔文）。\n- 开路电压 (OCV) 函数 $V_{\\mathrm{oc}}(s)$ 由一个物理上合理的单调函数给出：\n$$\nV_{\\mathrm{oc}}(s) = 3.0 + 1.2\\,s - 0.1\\,e^{-10 s}.\n$$\n- 电荷守恒得出 SOC 动力学：\n$$\n\\frac{ds}{dt} = -\\frac{I}{Q_{\\mathrm{nom}}}.\n$$\n- 能量平衡得出集总热动力学：\n$$\nC_{\\mathrm{th}} \\frac{dT}{dt} = I^2 R - hA \\left(T - T_{\\mathrm{amb}}\\right).\n$$\n- RC 极化电压根据一个线性时不变一阶模型演化：\n$$\n\\frac{dv_{\\mathrm{rc}}}{dt} = -\\frac{1}{\\tau} v_{\\mathrm{rc}} + \\frac{\\alpha}{\\tau} I,\n$$\n其中 $\\tau$ 是时间常数（单位：秒），$\\alpha$ 是无量纲耦合系数。\n- 端电压 $V(t)$ 计算如下：\n$$\nV(t) = V_{\\mathrm{oc}}(s(t)) - I R - v_{\\mathrm{rc}}(t).\n$$\n\n基于约束的验证：如果在任何时间 $t$，模拟轨迹违反了以下任一允许范围，则该轨迹将被拒绝：\n- SOC 范围：$s(t) \\in [0, 1]$ (无量纲)。\n- 温度范围：$T(t) \\in [T_{\\min}, T_{\\max}]$（单位：开尔文）。\n- 电压范围：$V(t) \\in [V_{\\min}, V_{\\max}]$（单位：伏特）。\n\n不确定性传播：对于每次模拟运行，从指定的分布（如下文每个测试用例所定义）中独立采样不确定参数。使用时间离散化在有限时间范围内模拟系统，并确定是否违反约束。将拒绝频率量化为被拒绝的运行次数除以总运行次数，表示为一个十进制小数（而非百分比）。为保证可复现性，使用固定的伪随机种子 $42$。\n\n实现细节：\n- 在时间范围 $[0, t_{\\mathrm{h}}]$ 上使用固定步长 $\\Delta t$ 的显式时间步进。\n- 必须严格遵守单位：$s$ 是无量纲的，$I$ 的单位是安培，$R$ 是欧姆，$Q_{\\mathrm{nom}}$ 是库仑，$T$ 和 $T_{\\mathrm{amb}}$ 是开尔文，$C_{\\mathrm{th}}$ 是焦耳/开尔文，$hA$ 是瓦特/开尔文，$\\tau$ 是秒，$V$ 是伏特。\n- 初始条件 $s(0)$ 和 $T(0)$ 必须按照每个测试用例的规定进行采样。初始极化态为 $v_{\\mathrm{rc}}(0) = 0$。\n\n测试套件：实现以下四种参数化设置的测试用例。在每个用例中，执行 $N$ 次独立运行，并输出因违反约束而被拒绝的运行所占的比例。\n\n- 用例 A（基准线，中等压力）：\n  - $N = 500$, $t_{\\mathrm{h}} = 600\\,\\mathrm{s}$, $\\Delta t = 0.5\\,\\mathrm{s}$, $\\tau = 20\\,\\mathrm{s}$, $\\alpha = 1$。\n  - 电流 $I \\sim \\mathrm{Uniform}(1, 8)$ (安培)。\n  - 电阻 $R \\sim \\mathrm{Normal}(\\mu_R = 0.05, \\sigma_R = 0.01)$ (欧姆)，在 $R_{\\min} = 0.01$ 处下截断。\n  - 容量 $Q_{\\mathrm{nom}} \\sim \\mathrm{Normal}(\\mu_Q = 10800, \\sigma_Q = 300)$ (库仑)，在 $Q_{\\min} = 8000$ 处下截断。\n  - 热参数：$hA \\sim \\mathrm{Normal}(\\mu_{hA} = 5.0, \\sigma_{hA} = 0.8)$ (瓦特/开尔文)，在 $hA_{\\min} = 1.0$ 处下截断；$C_{\\mathrm{th}} \\sim \\mathrm{Normal}(\\mu_C = 500, \\sigma_C = 50)$ (焦耳/开尔文)，在 $C_{\\min} = 300$ 处下截断。\n  - 初始条件：$s(0) \\sim \\mathrm{Uniform}(0.2, 0.9)$；$T(0) \\sim \\mathrm{Normal}(\\mu_{T0} = 298, \\sigma_{T0} = 2)$ (开尔文)，在 $T_{\\mathrm{abs},\\min} = 273.15$ 处下截断。\n  - 环境：$T_{\\mathrm{amb}} \\sim \\mathrm{Normal}(\\mu_{\\mathrm{amb}} = 298, \\sigma_{\\mathrm{amb}} = 2)$ (开尔文)。\n  - 边界：$T_{\\min} = 273.15\\,\\mathrm{K}$，$T_{\\max} = 335\\,\\mathrm{K}$，$V_{\\min} = 2.5\\,\\mathrm{V}$，$V_{\\max} = 4.2\\,\\mathrm{V}$。\n\n- 用例 B（大电流压力和扩展的时间范围）：\n  - $N = 500$, $t_{\\mathrm{h}} = 1200\\,\\mathrm{s}$, $\\Delta t = 0.5\\,\\mathrm{s}$, $\\tau = 20\\,\\mathrm{s}$, $\\alpha = 1$。\n  - 电流 $I \\sim \\mathrm{Uniform}(6, 12)$ (安培)。\n  - 电阻 $R \\sim \\mathrm{Normal}(\\mu_R = 0.06, \\sigma_R = 0.012)$ (欧姆)，在 $R_{\\min} = 0.015$ 处下截断。\n  - 容量 $Q_{\\mathrm{nom}} \\sim \\mathrm{Normal}(\\mu_Q = 10500, \\sigma_Q = 350)$ (库仑)，在 $Q_{\\min} = 8000$ 处下截断。\n  - 热参数：$hA \\sim \\mathrm{Normal}(\\mu_{hA} = 4.0, \\sigma_{hA} = 0.7)$ (瓦特/开尔文)，在 $hA_{\\min} = 1.0$ 处下截断；$C_{\\mathrm{th}} \\sim \\mathrm{Normal}(\\mu_C = 450, \\sigma_C = 60)$ (焦耳/开尔文)，在 $C_{\\min} = 300$ 处下截断。\n  - 初始条件：$s(0) \\sim \\mathrm{Uniform}(0.3, 0.8)$；$T(0) \\sim \\mathrm{Normal}(\\mu_{T0} = 300, \\sigma_{T0} = 2.5)$ (开尔文)，在 $T_{\\mathrm{abs},\\min} = 273.15$ 处下截断。\n  - 环境：$T_{\\mathrm{amb}} \\sim \\mathrm{Normal}(\\mu_{\\mathrm{amb}} = 300, \\sigma_{\\mathrm{amb}} = 3)$ (开尔文)。\n  - 边界：$T_{\\min} = 273.15\\,\\mathrm{K}$，$T_{\\max} = 335\\,\\mathrm{K}$，$V_{\\min} = 2.5\\,\\mathrm{V}$，$V_{\\max} = 4.2\\,\\mathrm{V}$。\n\n- 用例 C（小电流，保守的热管理）：\n  - $N = 400$, $t_{\\mathrm{h}} = 900\\,\\mathrm{s}$, $\\Delta t = 0.5\\,\\mathrm{s}$, $\\tau = 20\\,\\mathrm{s}$, $\\alpha = 1$。\n  - 电流 $I \\sim \\mathrm{Uniform}(0, 0.5)$ (安培)。\n  - 电阻 $R \\sim \\mathrm{Normal}(\\mu_R = 0.045, \\sigma_R = 0.008)$ (欧姆)，在 $R_{\\min} = 0.01$ 处下截断。\n  - 容量 $Q_{\\mathrm{nom}} \\sim \\mathrm{Normal}(\\mu_Q = 11200, \\sigma_Q = 250)$ (库仑)，在 $Q_{\\min} = 9000$ 处下截断。\n  - 热参数：$hA \\sim \\mathrm{Normal}(\\mu_{hA} = 6.0, \\sigma_{hA} = 0.9)$ (瓦特/开尔文)，在 $hA_{\\min} = 1.0$ 处下截断；$C_{\\mathrm{th}} \\sim \\mathrm{Normal}(\\mu_C = 520, \\sigma_C = 40)$ (焦耳/开尔文)，在 $C_{\\min} = 350$ 处下截断。\n  - 初始条件：$s(0) \\sim \\mathrm{Uniform}(0.4, 0.95)$；$T(0) \\sim \\mathrm{Normal}(\\mu_{T0} = 297, \\sigma_{T0} = 1.5)$ (开尔文)，在 $T_{\\mathrm{abs},\\min} = 273.15$ 处下截断。\n  - 环境：$T_{\\mathrm{amb}} \\sim \\mathrm{Normal}(\\mu_{\\mathrm{amb}} = 297, \\sigma_{\\mathrm{amb}} = 1.5)$ (开尔文)。\n  - 边界：$T_{\\min} = 273.15\\,\\mathrm{K}$，$T_{\\max} = 335\\,\\mathrm{K}$，$V_{\\min} = 2.5\\,\\mathrm{V}$，$V_{\\max} = 4.2\\,\\mathrm{V}$。\n\n- 用例 D（边界 SOC 接近耗尽，中等电流）：\n  - $N = 300$, $t_{\\mathrm{h}} = 1800\\,\\mathrm{s}$, $\\Delta t = 0.5\\,\\mathrm{s}$, $\\tau = 20\\,\\mathrm{s}$, $\\alpha = 1$。\n  - 电流 $I \\sim \\mathrm{Uniform}(2, 4)$ (安培)。\n  - 电阻 $R \\sim \\mathrm{Normal}(\\mu_R = 0.05, \\sigma_R = 0.01)$ (欧姆)，在 $R_{\\min} = 0.01$ 处下截断。\n  - 容量 $Q_{\\mathrm{nom}} \\sim \\mathrm{Normal}(\\mu_Q = 10800, \\sigma_Q = 300)$ (库仑)，在 $Q_{\\min} = 9000$ 处下截断。\n  - 热参数：$hA \\sim \\mathrm{Normal}(\\mu_{hA} = 5.0, \\sigma_{hA} = 0.8)$ (瓦特/开尔文)，在 $hA_{\\min} = 1.0$ 处下截断；$C_{\\mathrm{th}} \\sim \\mathrm{Normal}(\\mu_C = 500, \\sigma_C = 50)$ (焦耳/开尔文)，在 $C_{\\min} = 300$ 处下截断。\n  - 初始条件：$s(0) \\sim \\mathrm{Uniform}(0.05, 0.15)$；$T(0) \\sim \\mathrm{Normal}(\\mu_{T0} = 298, \\sigma_{T0} = 2)$ (开尔文)，在 $T_{\\mathrm{abs},\\min} = 273.15$ 处下截断。\n  - 环境：$T_{\\mathrm{amb}} \\sim \\mathrm{Normal}(\\mu_{\\mathrm{amb}} = 298, \\sigma_{\\mathrm{amb}} = 2)$ (开尔文)。\n  - 边界：$T_{\\min} = 273.15\\,\\mathrm{K}$，$T_{\\max} = 335\\,\\mathrm{K}$，$V_{\\min} = 2.5\\,\\mathrm{V}$，$V_{\\max} = 4.2\\,\\mathrm{V}$。\n\n数值要求：\n- 将所有计算出的拒绝频率表示为 $[0,1]$ 范围内的十进制小数。\n- 最终程序输出必须是单行，包含一个用方括号括起来的、由逗号分隔的四个拒绝频率列表，例如 $[0.12,0.34,0.00,0.67]$，无任何额外文本。\n\n此问题中不涉及角度单位。确保所有温度值单位为开尔文，电流为安培，电阻为欧姆，容量为库仑，与能量相关的参数单位如指定为焦耳/开尔文或瓦特/开尔文，时间为秒，电压为伏特。",
            "solution": "该问题要求为一个锂离子电池单元模型实现一个虚拟原型设计工作流，以量化在参数不确定性下约束违反的频率。此任务通过蒙特卡洛模拟完成。对于四个指定的测试用例中的每一个，都执行大量的模拟（$N$ 次）。在每次模拟运行中，模型的参数从指定的概率分布中采样。然后使用数值积分使系统状态随时间演化。每个状态变量的轨迹都会根据预定义的物理和操作约束进行检查。如果在任何时间点有任何约束被违反，该次运行就被视为“已拒绝”。每个用例的最终输出是拒绝频率，计算方法是被拒绝的运行次数与总运行次数 $N$ 的比率。\n\n该模型由一个包含三个耦合常微分方程 (ODE) 的系统组成，描述了荷电状态 $s(t)$、温度 $T(t)$ 和极化电压 $v_{\\mathrm{rc}}(t)$ 的演化过程。\n\n控制方程如下：\n1.  **荷电状态动力学（电荷守恒）：**\n    $$\n    \\frac{ds}{dt} = -\\frac{I}{Q_{\\mathrm{nom}}}\n    $$\n    其中 $I$ 是放电电流，$Q_{\\mathrm{nom}}$ 是标称容量。\n\n2.  **温度动力学（能量平衡）：**\n    $$\n    C_{\\mathrm{th}} \\frac{dT}{dt} = I^2 R - hA \\left(T - T_{\\mathrm{amb}}\\right)\n    $$\n    其中 $C_{\\mathrm{th}}$ 是热容，$R$ 是内阻，$hA$ 是传热系数-面积乘积，$T_{\\mathrm{amb}}$ 是环境温度。$I^2 R$ 项代表焦耳热。\n\n3.  **极化动力学（RC 电路）：**\n    $$\n    \\frac{dv_{\\mathrm{rc}}}{dt} = -\\frac{1}{\\tau} v_{\\mathrm{rc}} + \\frac{\\alpha}{\\tau} I\n    $$\n    其中 $\\tau$ 是时间常数，$\\alpha$ 是单元素阻容 (RC) 对的耦合系数。\n\n端电压 $V(t)$ 是状态的代数函数：\n$$\nV(t) = V_{\\mathrm{oc}}(s(t)) - I R - v_{\\mathrm{rc}}(t)\n$$\n其中开路电压 (OCV) 由以下公式给出：\n$$\nV_{\\mathrm{oc}}(s) = 3.0 + 1.2\\,s - 0.1\\,e^{-10 s}\n$$\n\n求解方法包括以下关键步骤：\n\n**1. 数值积分：**\nODE 系统使用固定时间步长 $\\Delta t$ 的显式欧拉法进行数值求解。对于在时间 $t_k = k \\Delta t$ 的状态向量 $\\mathbf{x}_k = [s_k, T_k, v_{\\mathrm{rc},k}]^T$，下一个时间步 $t_{k+1}$ 的状态计算如下：\n$$\ns_{k+1} = s_k - \\frac{I}{Q_{\\mathrm{nom}}} \\Delta t\n$$\n$$\nT_{k+1} = T_k + \\frac{\\Delta t}{C_{\\mathrm{th}}} \\left(I^2 R - hA (T_k - T_{\\mathrm{amb}})\\right)\n$$\n$$\nv_{\\mathrm{rc},k+1} = v_{\\mathrm{rc},k} \\left(1 - \\frac{\\Delta t}{\\tau}\\right) + I \\frac{\\alpha \\Delta t}{\\tau}\n$$\n\n**2. 不确定性传播：**\n对于给定测试用例中的 $N$ 次运行中的每一次，不确定参数（$I, R, Q_{\\mathrm{nom}}, C_{\\mathrm{th}}, hA$）和初始条件（$s(0), T(0)$）从它们各自指定的分布（均匀分布或正态分布，可能被截断）中采样。一个伪随机数生成器以固定的种子 $42$ 进行初始化，以确保整个随机样本序列的可复现性。\n-   对于均匀分布 $\\mathrm{Uniform}(a, b)$，使用标准库函数抽取样本。\n-   对于正态分布 $\\mathrm{Normal}(\\mu, \\sigma)$，以类似方式抽取样本。\n-   对于具有均值 $\\mu$、标准差 $\\sigma$ 和下界 $x_{\\min}$ 的截断正态分布，我们使用专门的函数，例如 `scipy.stats.truncnorm`。用于采样的标准化下界计算为 $a = (x_{\\min} - \\mu) / \\sigma$，上界为 $b = \\infty$。\n\n**3. 约束验证：**\n在每次运行中，在从 $t_0 = 0$ 到模拟时间范围 $t_{\\mathrm{h}}$ 的每个时间步 $t_k$，状态变量和计算出的端电压都会根据以下约束进行检查：\n-   $s(t_k) \\in [0, 1]$\n-   $T(t_k) \\in [T_{\\min}, T_{\\max}]$\n-   $V(t_k) \\in [V_{\\min}, V_{\\max}]$\n如果在任何 $t_k$ 时刻违反了这些条件中的任何一个，该次运行的模拟将立即终止，并被计为“已拒绝”。\n\n**4. 拒绝频率量化：**\n在完成一个测试用例的所有 $N$ 次运行后，拒绝频率 $f_{\\mathrm{reject}}$ 计算如下：\n$$\nf_{\\mathrm{reject}} = \\frac{\\text{被拒绝的运行次数}}{N}\n$$\n对所有四个测试用例重复此过程，并收集得出的频率。\n\n**实现摘要：**\n该算法使用 Python 实现，其中 `numpy` 库用于数值运算，`scipy.stats.truncnorm` 用于从截断正态分布中采样。一个主函数负责协调四个测试用例的模拟。一个辅助函数用于清晰地处理截断正态变量的采样。主模拟逻辑遍历 $N$ 次运行中的每一次。在每次运行内部，另一个循环遍历时间步，更新状态并执行约束检查。\n每次运行的初始条件是 $s(0)$ 和 $T(0)$ 从其分布中采样，以及 $v_{\\mathrm{rc}}(0) = 0$。从 $t=0$ 开始执行约束违反检查，以确保初始状态本身是有效的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import truncnorm\n\ndef solve():\n    \"\"\"\n    Solves the battery virtual prototyping problem for all test cases.\n    \"\"\"\n    \n    # A single random number generator for reproducibility across all cases.\n    rng = np.random.default_rng(42)\n\n    def sample_truncated_normal(mu, sigma, lower_bound, size=1):\n        \"\"\"\n        Samples from a lower-truncated normal distribution.\n        Handles the sigma=0 case correctly.\n        \"\"\"\n        if sigma == 0:\n            return np.full(size, mu)\n        a = (lower_bound - mu) / sigma\n        b = np.inf\n        return truncnorm.rvs(a, b, loc=mu, scale=sigma, size=size, random_state=rng)\n\n    def run_simulation(case_params, rng_instance):\n        \"\"\"\n        Runs a Monte Carlo simulation for a single test case.\n        \"\"\"\n        N = case_params['N']\n        t_h = case_params['t_h']\n        dt = case_params['dt']\n        tau = case_params['tau']\n        alpha = case_params['alpha']\n        \n        # Unpack constraint boundaries\n        T_min, T_max = case_params['bounds']['T']\n        V_min, V_max = case_params['bounds']['V']\n        s_min, s_max = 0.0, 1.0\n\n        # Unpack sampling parameters\n        p = case_params['params']\n        \n        rejected_count = 0\n        for _ in range(N):\n            # Sample parameters for this single run\n            I = rng_instance.uniform(p['I'][0], p['I'][1])\n            R = sample_truncated_normal(p['R']['mu'], p['R']['sigma'], p['R']['min'])[0]\n            Q_nom = sample_truncated_normal(p['Q_nom']['mu'], p['Q_nom']['sigma'], p['Q_nom']['min'])[0]\n            hA = sample_truncated_normal(p['hA']['mu'], p['hA']['sigma'], p['hA']['min'])[0]\n            C_th = sample_truncated_normal(p['C_th']['mu'], p['C_th']['sigma'], p['C_th']['min'])[0]\n            \n            s0 = rng_instance.uniform(p['s0'][0], p['s0'][1])\n            T0 = sample_truncated_normal(p['T0']['mu'], p['T0']['sigma'], p['T0']['min'])[0]\n            T_amb = rng_instance.normal(p['T_amb']['mu'], p['T_amb']['sigma'])\n            \n            # Initialize states\n            s = s0\n            T = T0\n            v_rc = 0.0\n\n            is_rejected = False\n            num_steps = int(t_h / dt)\n\n            for step in range(num_steps + 1):\n                # Calculate OCV and Terminal Voltage at current step\n                V_oc = 3.0 + 1.2 * s - 0.1 * np.exp(-10.0 * s)\n                V = V_oc - I * R - v_rc\n\n                # Check constraints\n                if not (s_min = s = s_max and T_min = T = T_max and V_min = V = V_max):\n                    is_rejected = True\n                    break\n\n                # If it's the last step, no need to update state for the next step.\n                if step == num_steps:\n                    break\n                \n                # Update states for the next step using explicit Euler method\n                s = s - (I / Q_nom) * dt\n                T = T + (dt / C_th) * (I**2 * R - hA * (T - T_amb))\n                v_rc = v_rc * (1.0 - dt / tau) + (alpha * dt / tau) * I\n\n            if is_rejected:\n                rejected_count += 1\n        \n        return rejected_count / N\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {\n            'N': 500, 't_h': 600.0, 'dt': 0.5, 'tau': 20.0, 'alpha': 1.0,\n            'bounds': {'T': (273.15, 335.0), 'V': (2.5, 4.2)},\n            'params': {\n                'I': (1.0, 8.0),\n                'R': {'mu': 0.05, 'sigma': 0.01, 'min': 0.01},\n                'Q_nom': {'mu': 10800, 'sigma': 300, 'min': 8000},\n                'hA': {'mu': 5.0, 'sigma': 0.8, 'min': 1.0},\n                'C_th': {'mu': 500, 'sigma': 50, 'min': 300},\n                's0': (0.2, 0.9),\n                'T0': {'mu': 298, 'sigma': 2, 'min': 273.15},\n                'T_amb': {'mu': 298, 'sigma': 2},\n            }\n        },\n        # Case B\n        {\n            'N': 500, 't_h': 1200.0, 'dt': 0.5, 'tau': 20.0, 'alpha': 1.0,\n            'bounds': {'T': (273.15, 335.0), 'V': (2.5, 4.2)},\n            'params': {\n                'I': (6.0, 12.0),\n                'R': {'mu': 0.06, 'sigma': 0.012, 'min': 0.015},\n                'Q_nom': {'mu': 10500, 'sigma': 350, 'min': 8000},\n                'hA': {'mu': 4.0, 'sigma': 0.7, 'min': 1.0},\n                'C_th': {'mu': 450, 'sigma': 60, 'min': 300},\n                's0': (0.3, 0.8),\n                'T0': {'mu': 300, 'sigma': 2.5, 'min': 273.15},\n                'T_amb': {'mu': 300, 'sigma': 3},\n            }\n        },\n        # Case C\n        {\n            'N': 400, 't_h': 900.0, 'dt': 0.5, 'tau': 20.0, 'alpha': 1.0,\n            'bounds': {'T': (273.15, 335.0), 'V': (2.5, 4.2)},\n            'params': {\n                'I': (0.0, 0.5),\n                'R': {'mu': 0.045, 'sigma': 0.008, 'min': 0.01},\n                'Q_nom': {'mu': 11200, 'sigma': 250, 'min': 9000},\n                'hA': {'mu': 6.0, 'sigma': 0.9, 'min': 1.0},\n                'C_th': {'mu': 520, 'sigma': 40, 'min': 350},\n                's0': (0.4, 0.95),\n                'T0': {'mu': 297, 'sigma': 1.5, 'min': 273.15},\n                'T_amb': {'mu': 297, 'sigma': 1.5},\n            }\n        },\n        # Case D\n        {\n            'N': 300, 't_h': 1800.0, 'dt': 0.5, 'tau': 20.0, 'alpha': 1.0,\n            'bounds': {'T': (273.15, 335.0), 'V': (2.5, 4.2)},\n            'params': {\n                'I': (2.0, 4.0),\n                'R': {'mu': 0.05, 'sigma': 0.01, 'min': 0.01},\n                'Q_nom': {'mu': 10800, 'sigma': 300, 'min': 9000},\n                'hA': {'mu': 5.0, 'sigma': 0.8, 'min': 1.0},\n                'C_th': {'mu': 500, 'sigma': 50, 'min': 300},\n                's0': (0.05, 0.15),\n                'T0': {'mu': 298, 'sigma': 2, 'min': 273.15},\n                'T_amb': {'mu': 298, 'sigma': 2},\n            }\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case, rng)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}'.rstrip('0').rstrip('.') for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个经过充分验证的虚拟样机不仅应提供准确的预测，还必须诚实地报告其预测的不确定性。本练习深入探讨了贝叶斯验证框架，你将为一个等效电路模型生成后验预测分布。核心任务是通过计算“覆盖率”，来检验模型的 $0.95$ 置信区间是否能够有效地包含真实的观测值，这个诊断过程能让你清晰地判断模型是校准良好、过于自信（不确定性过小）还是过于保守（不确定性过大）。",
            "id": "3959873",
            "problem": "您将执行一项虚拟样机任务，为使用等效电路模型（ECM）建模的电化学电池进行设计。该ECM用于在指定时间生成后验预测电压分布，并通过 $0.95$ 置信区间对预留实验数据的覆盖情况来评估校准质量。\n\n使用单电阻-电容（RC）支路的ECM对电池进行建模，定义如下：\n- 端电压为 $V(t) = E(\\mathrm{SOC}(t)) - R_0 I(t) - V_{\\mathrm{rc}}(t)$，其中 $I(t)$ 是施加的电流（放电为正），$E(\\mathrm{SOC})$ 是作为荷电状态函数的开路电压，$R_0$ 是欧姆电阻，$V_{\\mathrm{rc}}(t)$ 是RC支路电压。\n- 荷电状态 $\\mathrm{SOC}(t)$ 根据电荷平衡定律 $d\\,\\mathrm{SOC}(t)/dt = -I(t)/Q$ 演变，其中 $Q$ 是以安培秒为单位的容量，且 $\\mathrm{SOC}(t) \\in [0,1]$。\n- RC支路电压遵循 $dV_{\\mathrm{rc}}(t)/dt = -\\dfrac{1}{R_1 C_1} V_{\\mathrm{rc}}(t) + \\dfrac{1}{C_1} I(t)$，其中 $R_1$ 和 $C_1$ 分别是RC对的电阻和电容。\n- 开路电压线性近似为 $E(\\mathrm{SOC}) = V_{\\min} + (V_{\\max} - V_{\\min}) \\mathrm{SOC}$。\n\n使用时间步长 $\\Delta t = 1\\,\\mathrm{s}$ 的前向欧拉离散化方法：\n- $\\mathrm{SOC}_{k+1} = \\mathrm{clip}\\left(\\mathrm{SOC}_k - \\dfrac{\\Delta t}{Q} I_k, 0, 1\\right)$,\n- $V_{\\mathrm{rc},k+1} = V_{\\mathrm{rc},k} + \\Delta t\\left(-\\dfrac{1}{R_1 C_1} V_{\\mathrm{rc},k} + \\dfrac{1}{C_1} I_k\\right)$,\n- $V_k = V_{\\min} + (V_{\\max} - V_{\\min}) \\mathrm{SOC}_k - R_0 I_k - V_{\\mathrm{rc},k}$。\n\n参数的贝叶斯后验在对数空间中指定，以确保其正定性。设 $\\boldsymbol{\\phi} = \\log([Q, R_0, R_1, C_1])$。假设 $\\boldsymbol{\\phi} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$。对于一个给定的后验样本 $\\boldsymbol{\\phi}^{(j)}$，通过 $[Q^{(j)}, R_0^{(j)}, R_1^{(j)}, C_1^{(j)}] = \\exp(\\boldsymbol{\\phi}^{(j)})$ 进行反变换，并在时间网格上模拟 $V(t)$。测量噪声被建模为加性高斯噪声：对于每个评估时间 $t_i$，后验预测电压抽样为 $V^{(j)}(t_i) + \\varepsilon^{(j)}_i$，其中 $\\varepsilon^{(j)}_i \\sim \\mathcal{N}(0, \\sigma_{\\mathrm{meas}}^2)$。\n\n对于每个指定的时间 $t_i$，通过后验预测抽样，计算处于 $0.025$ 和 $0.975$ 水平的经验分位数对，作为 $0.95$ 置信区间。通过检查 $y_i$ 是否落在每个 $t_i$ 计算出的区间内，来评估相对于预留实验电压值 $y_i$ 的覆盖率。一个测试用例的覆盖率是预留值被覆盖的时间点所占的比例（以小数表示）。\n\n使用以下符合物理现实的常数和单位：\n- 时间单位为秒，电流单位为安培，电压单位为伏特，电阻单位为欧姆，电容单位为法拉，容量单位为安培秒。\n- 开路电压参数：$V_{\\min} = 3.0\\,\\mathrm{V}$ 和 $V_{\\max} = 4.2\\,\\mathrm{V}$。\n- 初始荷电状态：$\\mathrm{SOC}_0 = 0.8$。\n- 评估时间：$t_{\\mathrm{eval}} = [50, 100, 150, 200, 250]\\,\\mathrm{s}$。\n- 电流剖面段（持续时间单位为秒，电流单位为安培）：$(100, 2.0)$, $(50, 0.0)$, $(50, -1.5)$, $(50, 0.0)$。\n\n预留的实验值 $y_i$ 是由高保真数字孪生使用真实参数和相同的电流剖面生成的，其测量噪声为零（即 $y_i = V^{\\star}(t_i)$）。真实参数（物理单位）为：\n- $Q^{\\star} = 10800\\,\\mathrm{A\\cdot s}$,\n- $R_0^{\\star} = 0.005\\,\\Omega$,\n- $R_1^{\\star} = 0.02\\,\\Omega$,\n- $C_1^{\\star} = 10000\\,\\mathrm{F}$。\n\n将对数空间中的后验均值定义为 $\\boldsymbol{\\mu} = \\log\\left([Q^{\\star}, R_0^{\\star}, R_1^{\\star}, C_1^{\\star}]\\right)$。\n\n设计一个程序，为下述每个测试用例，从后验分布中抽取 $N = 2000$ 个样本，计算指定时间的后验预测分布，构建 $0.95$ 置信区间，并计算相对于预留值的覆盖分数。使用以下具有不同对数空间后验标准差 $\\boldsymbol{s}$ 和测量噪声水平的测试套件：\n\n- 测试用例 1（良好校准的后验）：\n  - $\\boldsymbol{s} = [0.05, 0.10, 0.10, 0.10]$,\n  - $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{s}^2)$,\n  - $\\sigma_{\\mathrm{meas}} = 0.01\\,\\mathrm{V}$。\n\n- 测试用例 2（离散不足的后验）：\n  - $\\boldsymbol{s} = [0.01, 0.02, 0.02, 0.02]$,\n  - $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{s}^2)$,\n  - $\\sigma_{\\mathrm{meas}} = 0.01\\,\\mathrm{V}$。\n\n- 测试用例 3（过度离散的后验和更高的测量噪声）：\n  - $\\boldsymbol{s} = [0.20, 0.25, 0.25, 0.25]$,\n  - $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{s}^2)$,\n  - $\\sigma_{\\mathrm{meas}} = 0.02\\,\\mathrm{V}$。\n\n您的程序应产生单行输出，其中包含测试用例1、2和3的覆盖分数（按此顺序），四舍五入到三位小数，并以方括号括起来的逗号分隔列表形式呈现（例如，$[0.940,0.800,0.980]$）。不应打印任何其他文本。不涉及角度。所有量都应使用上述指定的单位进行处理，且覆盖分数必须是小数，而不是百分比。",
            "solution": "已对用户提供的问题进行了分析和验证。\n\n### 第1步：提取的已知信息\n\n**模型定义（等效电路模型 - ECM）：**\n- 端电压：$V(t) = E(\\mathrm{SOC}(t)) - R_0 I(t) - V_{\\mathrm{rc}}(t)$。\n- 电流约定：$I(t)$ 放电为正。\n- 荷电状态（SOC）动态：$d\\,\\mathrm{SOC}(t)/dt = -I(t)/Q$，其中 $\\mathrm{SOC}(t) \\in [0,1]$。\n- RC支路电压动态：$dV_{\\mathrm{rc}}(t)/dt = -\\dfrac{1}{R_1 C_1} V_{\\mathrm{rc}}(t) + \\dfrac{1}{C_1} I(t)$。\n- 开路电压（OCV）模型：$E(\\mathrm{SOC}) = V_{\\min} + (V_{\\max} - V_{\\min}) \\mathrm{SOC}$。\n\n**数值离散化（前向欧拉）：**\n- 时间步长：$\\Delta t = 1\\,\\mathrm{s}$。\n- SOC更新：$\\mathrm{SOC}_{k+1} = \\mathrm{clip}\\left(\\mathrm{SOC}_k - \\dfrac{\\Delta t}{Q} I_k, 0, 1\\right)$。\n- RC电压更新：$V_{\\mathrm{rc},k+1} = V_{\\mathrm{rc},k} + \\Delta t\\left(-\\dfrac{1}{R_1 C_1} V_{\\mathrm{rc},k} + \\dfrac{1}{C_1} I_k\\right)$。\n- 端电压计算：$V_k = V_{\\min} + (V_{\\max} - V_{\\min}) \\mathrm{SOC}_k - R_0 I_k - V_{\\mathrm{rc},k}$。\n\n**贝叶斯框架：**\n- 对数空间参数：$\\boldsymbol{\\phi} = \\log([Q, R_0, R_1, C_1])$。\n- 后验分布：$\\boldsymbol{\\phi} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$。\n- 参数变换：$[Q^{(j)}, R_0^{(j)}, R_1^{(j)}, C_1^{(j)}] = \\exp(\\boldsymbol{\\phi}^{(j)})$。\n- 蒙特卡洛样本数量：$N = 2000$。\n- 测量噪声模型：加性高斯噪声，$\\varepsilon^{(j)}_i \\sim \\mathcal{N}(0, \\sigma_{\\mathrm{meas}}^2)$。\n- 后验预测抽样：$V^{(j)}(t_i) + \\varepsilon^{(j)}_i$。\n\n**验证程序：**\n- 置信区间：$0.95$ 水平，使用 $0.025$ 和 $0.975$ 的经验分位数计算。\n- 预留数据：$y_i = V^{\\star}(t_i)$，其中 $V^{\\star}$ 是使用真实参数和零噪声模拟得出的。\n- 覆盖率定义：$y_i$ 落在相应置信区间内所占评估时间 $t_i$ 的比例。\n\n**常数与初始条件：**\n- OCV参数：$V_{\\min} = 3.0\\,\\mathrm{V}$， $V_{\\max} = 4.2\\,\\mathrm{V}$。\n- 初始荷电状态：$\\mathrm{SOC}_0 = 0.8$。\n- 初始RC电压：假定为 $V_{\\mathrm{rc},0} = 0.0\\,\\mathrm{V}$（电池处于静置状态的标准假设）。\n- 评估时间：$t_{\\mathrm{eval}} = [50, 100, 150, 200, 250]\\,\\mathrm{s}$。\n- 电流剖面：$(100\\,\\mathrm{s}, 2.0\\,\\mathrm{A})$，$(50\\,\\mathrm{s}, 0.0\\,\\mathrm{A})$，$(50\\,\\mathrm{s}, -1.5\\,\\mathrm{A})$，$(50\\,\\mathrm{s}, 0.0\\,\\mathrm{A})$。\n\n**真实参数：**\n- $Q^{\\star} = 10800\\,\\mathrm{A\\cdot s}$\n- $R_0^{\\star} = 0.005\\,\\Omega$\n- $R_1^{\\star} = 0.02\\,\\Omega$\n- $C_1^{\\star} = 10000\\,\\mathrm{F}$\n\n**后验分布定义：**\n- 均值（对数空间）：$\\boldsymbol{\\mu} = \\log\\left([Q^{\\star}, R_0^{\\star}, R_1^{\\star}, C_1^{\\star}]\\right)$。\n\n**测试用例：**\n1. $\\boldsymbol{s} = [0.05, 0.10, 0.10, 0.10]$, $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{s}^2)$, $\\sigma_{\\mathrm{meas}} = 0.01\\,\\mathrm{V}$。\n2. $\\boldsymbol{s} = [0.01, 0.02, 0.02, 0.02]$, $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{s}^2)$, $\\sigma_{\\mathrm{meas}} = 0.01\\,\\mathrm{V}$。\n3. $\\boldsymbol{s} = [0.20, 0.25, 0.25, 0.25]$, $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{s}^2)$, $\\sigma_{\\mathrm{meas}} = 0.02\\,\\mathrm{V}$。\n\n### 第2步：问题验证\n\n该问题在科学上合理、适定且客观。\n- **科学合理性：** 该问题使用标准的1-RC等效电路模型，这是电池工程中用于性能模拟的基础且被广泛接受的工具。控制微分方程、前向欧拉离散化以及用于不确定性量化的贝叶斯框架都是标准且正确的。所有指定的参数对于常见的锂离子电池都是物理上现实的。\n- **适定性：** 问题提供了执行模拟所需的完整方程、参数和初始条件。尽管RC支路电压的初始条件 $V_{\\mathrm{rc},0}$ 未明确说明，但在模拟从静置状态开始的标准假设下，它隐含为 $0\\,\\mathrm{V}$，这使得问题是适定的。任务定义清晰，可以获得唯一的计算结果（受蒙特卡洛抽样方差的影响，这是该方法的一个受控方面）。\n- **客观性：** 语言精确且量化。任务是一个形式化的计算过程，没有主观性或模糊性。\n\n### 第3步：结论与行动\n\n问题陈述有效。将提供一个解决方案。\n\n### 基于原理的解决方案\n\n该问题要求对电池模型的后验校准进行评估。这是虚拟样机设计中的一项常见任务，必须验证模型后验分布量化的不确定性是否准确反映了预测中的真实不确定性。置信区间的覆盖率是此验证的主要诊断工具。一个良好校准的模型应该能产生 $p\\%$ 的置信区间，该区间在平均情况下有 $p\\%$ 的时间包含真实值。在这里，我们检查 $95\\%$ 的置信区间是否覆盖了真实的电压值。\n\n对于每个测试用例，解决方案被构建为一个两阶段的计算过程：\n1. **生成基准真相：** “预留的实验数据”是通过使用提供的真实参数 $(\\boldsymbol{\\theta}^{\\star} = [Q^{\\star}, R_0^{\\star}, R_1^{\\star}, C_1^{\\star}])$ 模拟ECM生成的。这建立了参考电压轨迹 $V^{\\star}(t)$。\n2. **用于后验预测分布的蒙特卡洛模拟：** 对于每个测试用例，我们模拟从后验分布中抽样的过程，以在指定的评估时间生成电压的预测分布。\n\n**详细算法步骤：**\n\n1. **定义系统常数和电流剖面：**\n    - 定义物理常数 $V_{\\min}$、$V_{\\max}$ 和初始状态 $\\mathrm{SOC}_0$。\n    - 总模拟时间为 $T_{\\mathrm{max}} = 250\\,\\mathrm{s}$。在 $\\Delta t = 1\\,\\mathrm{s}$ 的情况下，这对应于从 $k=0, 1, \\dots, 250$ 索引的 $251$ 个时间点。\n    - 电流剖面 $I_k$ 被构建为一个长度为 $251$ 的向量。对于 $k \\in [0, 99]$，其值为 $2.0\\,\\mathrm{A}$；对于 $k \\in [100, 149]$，为 $0.0\\,\\mathrm{A}$；对于 $k \\in [150, 199]$，为 $-1.5\\,\\mathrm{A}$；对于 $k \\in [200, 250]$，为 $0.0\\,\\mathrm{A}$。\n\n2. **实现ECM模拟器：**\n    - 创建一个函数来执行基于前向欧拉格式的时间推进模拟。\n    - 输入：一个参数集 $[Q, R_0, R_1, C_1]$ 和电流剖面 $I$。\n    - 初始化：$\\mathrm{SOC}_0 = 0.8$ 和 $V_{\\mathrm{rc},0} = 0.0\\,\\mathrm{V}$。\n    - 循环：对于 $k = 0, \\dots, T_{\\mathrm{max}}-1$：\n        - $\\mathrm{SOC}_{k+1} = \\mathrm{clip}\\left(\\mathrm{SOC}_k - \\frac{\\Delta t}{Q} I_k, 0, 1\\right)$\n        - $V_{\\mathrm{rc},k+1} = V_{\\mathrm{rc},k} \\left(1 - \\frac{\\Delta t}{R_1 C_1}\\right) + \\frac{\\Delta t}{C_1} I_k$\n    - 输出计算：在状态演化循环之后，为所有时间步计算端电压：$V_k = (V_{\\min} + (V_{\\max} - V_{\\min})\\mathrm{SOC}_k) - R_0 I_k - V_{\\mathrm{rc},k}$。\n    - 函数返回完整的电压轨迹 $V$。\n\n3. **生成真实电压数据：**\n    - 将真实参数集 $\\boldsymbol{\\theta}^{\\star} = [10800, 0.005, 0.02, 10000]$ 传递给ECM模拟器。\n    - 计算得到的电压轨迹 $V^{\\star}$。\n    - 从 $V^{\\star}$ 中提取在指定评估时间索引 $t_{\\mathrm{eval}} = [50, 100, 150, 200, 250]$ 处的预留数据 $y_i$。\n\n4. **处理每个测试用例：**\n    对于三个测试用例中的每一个，其特征在于对数空间标准差向量 $\\boldsymbol{s}$ 和测量噪声标准差 $\\sigma_{\\mathrm{meas}}$：\n    a. **定义后验：** 对数参数分布的均值为 $\\boldsymbol{\\mu} = \\log(\\boldsymbol{\\theta}^{\\star})$。协方差为 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{s}^2)$。\n    b. **蒙特卡洛循环：** 循环运行 $N=2000$ 次。在每次迭代 $j$ 中：\n        i. **抽样参数：** 从 $\\mathcal{N}(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$ 中抽取一个对数参数向量 $\\boldsymbol{\\phi}^{(j)}$。由于 $\\boldsymbol{\\Sigma}$ 是对角矩阵，这等同于从 $\\mathcal{N}(\\mu_i, s_i^2)$ 中独立抽取每个分量 $\\phi_i^{(j)}$。\n        ii. **变换参数：** 计算物理参数 $\\boldsymbol{\\theta}^{(j)} = \\exp(\\boldsymbol{\\phi}^{(j)})$。\n        iii. **模拟电压：** 使用 $\\boldsymbol{\\theta}^{(j)}$ 运行ECM模拟器，获得电压轨迹 $V^{(j)}$。\n        iv. **生成预测样本：** 提取评估时间的电压 $V^{(j)}(t_i)$。抽取加性高斯噪声 $\\varepsilon_i^{(j)} \\sim \\mathcal{N}(0, \\sigma_{\\mathrm{meas}}^2)$，并将其加到这些电压上，形成后验预测样本 $\\{V^{(j)}(t_i) + \\varepsilon_i^{(j)}\\}$。\n    c. **计算覆盖率：**\n        i. 循环结束后，对于每个评估时间 $t_i$，我们有一组 $N=2000$ 个后验预测电压样本。\n        ii. 计算这组样本的 $0.025$ 和 $0.975$ 分位数，以定义 $95\\%$ 置信区间 $[L_i, U_i]$。\n        iii. 对于每个 $t_i$，我们检查真实值 $y_i$ 是否位于此区间内：$L_i \\le y_i \\le U_i$。\n        iv. 覆盖分数计算为检查结果为“真”的次数除以总评估点数，即 $5$。\n    d. 存储该测试用例的最终覆盖分数。\n\n此程序可以稳健地评估指定的后验不确定性如何通过基于物理的模型传播，以及由此产生的预测不确定性是否相对于基准真相得到了良好校准。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the battery model validation problem by computing coverage fractions for three test cases.\n    \"\"\"\n    # Define physical constants and simulation parameters\n    V_MIN = 3.0  # V\n    V_MAX = 4.2  # V\n    SOC0 = 0.8  # Initial State of Charge\n    DT = 1.0  # s\n    T_MAX = 250  # s\n    N_SAMPLES = 2000\n    \n    # Evaluation time steps (indices)\n    t_eval_indices = np.array([50, 100, 150, 200, 250], dtype=int)\n    \n    # True physical parameters\n    params_true = np.array([10800.0, 0.005, 0.02, 10000.0])  # [Q, R0, R1, C1]\n\n    # Test case definitions\n    test_cases = [\n        # Case 1: Well-calibrated\n        {'s_log': np.array([0.05, 0.10, 0.10, 0.10]), 'sigma_meas': 0.01},\n        # Case 2: Under-dispersed\n        {'s_log': np.array([0.01, 0.02, 0.02, 0.02]), 'sigma_meas': 0.01},\n        # Case 3: Over-dispersed\n        {'s_log': np.array([0.20, 0.25, 0.25, 0.25]), 'sigma_meas': 0.02},\n    ]\n\n    # Create the current profile for the simulation\n    n_steps = int(T_MAX / DT)\n    current_profile = np.zeros(n_steps + 1)\n    current_profile[0:100] = 2.0   # 0s to 100s\n    current_profile[100:150] = 0.0  # 100s to 150s\n    current_profile[150:200] = -1.5 # 150s to 200s\n    current_profile[200:251] = 0.0  # 200s to 250s\n\n    def run_simulation(params, current, n_steps, dt, soc0, v_min, v_max):\n        \"\"\"\n        Runs a single forward Euler simulation of the ECM.\n        \"\"\"\n        Q, R0, R1, C1 = params\n        \n        soc = np.zeros(n_steps + 1)\n        v_rc = np.zeros(n_steps + 1)\n        \n        soc[0] = soc0\n        v_rc[0] = 0.0\n\n        for k in range(n_steps):\n            # Update SOC with clipping\n            soc[k+1] = soc[k] - (dt / Q) * current[k]\n            soc[k+1] = np.clip(soc[k+1], 0.0, 1.0)\n            \n            # Update RC voltage\n            v_rc[k+1] = v_rc[k] + dt * (-(1 / (R1 * C1)) * v_rc[k] + (1 / C1) * current[k])\n        \n        # Calculate terminal voltage\n        E_ocv = v_min + (v_max - v_min) * soc\n        V_terminal = E_ocv - R0 * current - v_rc\n        \n        return V_terminal\n\n    # Generate the \"true\" held-out voltage data\n    V_true_trajectory = run_simulation(params_true, current_profile, n_steps, DT, SOC0, V_MIN, V_MAX)\n    y_true = V_true_trajectory[t_eval_indices]\n\n    # Use a fixed seed for reproducibility of the Monte Carlo simulation\n    rng = np.random.default_rng(seed=42)\n\n    results = []\n    \n    # Process each test case\n    for case in test_cases:\n        s_log = case['s_log']\n        sigma_meas = case['sigma_meas']\n        \n        mu_log = np.log(params_true)\n        \n        posterior_predictive_voltages = np.zeros((N_SAMPLES, len(t_eval_indices)))\n\n        for j in range(N_SAMPLES):\n            # 1. Sample parameters from the posterior\n            phi_j = rng.normal(loc=mu_log, scale=s_log)\n            params_j = np.exp(phi_j)\n            \n            # 2. Simulate the model with the sampled parameters\n            V_j_trajectory = run_simulation(params_j, current_profile, n_steps, DT, SOC0, V_MIN, V_MAX)\n            V_j_eval = V_j_trajectory[t_eval_indices]\n            \n            # 3. Add measurement noise to generate a posterior predictive sample\n            noise = rng.normal(loc=0.0, scale=sigma_meas, size=len(t_eval_indices))\n            V_pred_j = V_j_eval + noise\n            \n            posterior_predictive_voltages[j, :] = V_pred_j\n            \n        # 4. Compute credible intervals and coverage\n        lower_bounds = np.quantile(posterior_predictive_voltages, 0.025, axis=0)\n        upper_bounds = np.quantile(posterior_predictive_voltages, 0.975, axis=0)\n        \n        is_covered = (y_true >= lower_bounds)  (y_true = upper_bounds)\n        coverage_fraction = np.mean(is_covered)\n        \n        results.append(coverage_fraction)\n\n    # Format the output as specified\n    print(f\"[{','.join([f'{r:.3f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}