{
    "hands_on_practices": [
        {
            "introduction": "预测二次寿命电池的剩余使用寿命，对于经济性评估和运营规划至关重要。本练习 () 通过一个简化的线性退化模型，向您介绍剩余使用寿命（Remaining Useful Life, RUL）的基本概念。此练习旨在通过清晰的第一性原理计算，为您理解更复杂的预测技术打下坚实的基础。",
            "id": "3929132",
            "problem": "一个为二次生命固定式储能而回收的锂离子电池被整合到一个自动化的退化模拟工作流程中。在再利用时，其可用容量被测量为原始额定容量的一部分。该二次生命应用将使用寿命终止阈值定义为原始额定容量的一部分。在预定的恒定工作循环下，容量衰减的短周期经验模型表明，每个循环的容量损失近似恒定。\n\n假设以下具有科学依据的量和条件：\n- 原始额定容量为 $C_{\\mathrm{nom}} = 3.0\\,\\mathrm{Ah}$。\n- 二次生命使用开始时测得的可用容量为 $C_{\\mathrm{nom}}$ 的 $85\\%$。\n- 二次生命应用的使用寿命终止阈值为 $C_{\\mathrm{nom}}$ 的 $80\\%$。\n- 在此恒定工作循环下，观察到的容量衰减率为 $\\alpha = 0.5\\,\\mathrm{mAh/cycle}$，并且在剩余寿命周期内与循环次数无关。\n- 循环在相同负荷（恒定条件）下持续进行，并且在预测范围内，日历老化相对于循环引起的衰减可以忽略不计。\n\n将剩余使用寿命 (RUL) 定义为在容量首次达到阈值之前可以完成的完整循环次数。使用容量作为电荷 ($\\mathrm{Ah}$) 的物理定义，以及每个循环容量损失恒定意味着容量随循环次数线性减少的标准概念。计算 RUL（以循环次数为单位）。将您的答案四舍五入到三位有效数字，并以循环次数表示结果。",
            "solution": "我们从容量是可用电荷（以安培时为单位）的物理定义开始。令 $C_{\\mathrm{nom}}$ 表示原始额定容量。当前时间（二次生命使用开始时）测得的可用容量是额定容量的一部分，给定为 $C_{\\mathrm{nom}}$ 的 $85\\%$。使用寿命终止阈值为 $C_{\\mathrm{nom}}$ 的 $80\\%$。我们用 $Q(n)$ 表示容量作为循环次数 $n$ 的函数，其中 $n$ 计二次生命应用中的完整循环次数。\n\n在每个循环容量损失恒定的经验假设下，容量随循环次数线性衰减。在此假设下，基本表达式为\n$$\nQ(n) = Q(0) - \\alpha\\, n,\n$$\n其中 $Q(0)$ 是二次生命使用开始时的初始容量，$\\alpha$ 是每个循环的容量损失。剩余使用寿命 (RUL)，记为 $N$，是使 $Q(n)$ 达到使用寿命终止阈值 $Q_{\\min}$ 的最小整数 $n$：\n$$\nQ(N) \\le Q_{\\min}, \\quad \\text{with} \\quad Q_{\\min} = 0.80\\, C_{\\mathrm{nom}}, \\quad Q(0) = 0.85\\, C_{\\mathrm{nom}}.\n$$\n\n我们用一致的单位计算初始容量和阈值。首先，将 $C_{\\mathrm{nom}}$ 转换为毫安时：\n$$\nC_{\\mathrm{nom}} = 3.0\\,\\mathrm{Ah} = 3000\\,\\mathrm{mAh}.\n$$\n因此，\n$$\nQ(0) = 0.85 \\times 3000\\,\\mathrm{mAh} = 2550\\,\\mathrm{mAh},\n$$\n并且\n$$\nQ_{\\min} = 0.80 \\times 3000\\,\\mathrm{mAh} = 2400\\,\\mathrm{mAh}.\n$$\n\n线性模型意味着达到阈值的循环次数（在连续意义上）可以通过求解以下方程得到\n$$\nQ(0) - \\alpha\\, n^{\\ast} = Q_{\\min} \\quad \\Rightarrow \\quad n^{\\ast} = \\frac{Q(0) - Q_{\\min}}{\\alpha}.\n$$\n代入数值：\n$$\nn^{\\ast} = \\frac{2550\\,\\mathrm{mAh} - 2400\\,\\mathrm{mAh}}{0.5\\,\\mathrm{mAh/cycle}} = \\frac{150\\,\\mathrm{mAh}}{0.5\\,\\mathrm{mAh/cycle}} = 300\\,\\text{cycles}.\n$$\n\n根据 RUL 的离散定义，即容量达到或低于阈值的最小整数循环次数 $N$，我们计算 $Q(300)$：\n$$\nQ(300) = 2550\\,\\mathrm{mAh} - 0.5\\,\\mathrm{mAh/cycle} \\times 300 = 2550\\,\\mathrm{mAh} - 150\\,\\mathrm{mAh} = 2400\\,\\mathrm{mAh} = Q_{\\min}.\n$$\n因此，阈值恰好在 $N = 300$ 次循环时达到。RUL 为 $300$ 次循环。\n\n题目要求四舍五入到三位有效数字。数值 $300$ 写成三位有效数字是 $3.00 \\times 10^{2}$。单位是循环，但最终方框内的答案不能包含单位。",
            "answer": "$$\\boxed{3.00 \\times 10^{2}}$$"
        },
        {
            "introduction": "除了使用寿命，电池在特定应用中的性能，尤其是其能量效率，也同样关键。本练习 () 将指导您开发一个计算模型，以模拟电池在特定工作循环下的往返效率（Round-Trip Efficiency, RTE）。通过实现一个与老化和温度相关的电阻模型，您将获得将物理原理转化为量化性能退化仿真工具的实践经验。",
            "id": "3929154",
            "problem": "考虑一个可充电电池模组的单支路Thevenin等效模型，其中在所关注的短占空比周期内，开路电压被建模为恒定的 $V_{\\text{oc}}$，而内部等效串联电阻 (ESR) $R(t)$ 是电芯老化程度和温度的函数。目标是通过明确计算欧姆损耗，来计算在指定的充放电占空比曲线下的往返效率。请使用电路理论和能量守恒的第一性原理来推导您的计算过程。假设以下基本条件：瞬时端电压为 $V_t(t)$，瞬时电流为 $I(t)$ (对负载放电时为正，从外部电源充电时为负)，瞬时电功率为 $P(t) = V_t(t)\\,I(t)$，在ESR中耗散的Joule热功率为 $P_R(t)$。\n\n将内部ESR建模为关于参考温度的老化程度和温度的乘法函数。设段 $j$ 期间的有效内阻为\n$$\nR_j \\equiv \\big(R_0 + R_c\\big)\\,\\Big(1 + k_{\\text{age}}\\,\\frac{N_{\\text{cycles}}}{1000}\\Big)\\,\\Big(1 + k_T\\,\\big(T_j - T_{\\text{ref}}\\big)\\Big),\n$$\n其中 $R_0$ 是老化电芯在参考温度 $T_{\\text{ref}}$ 下的基础电阻，$R_c$ 是接触与互连电阻，$k_{\\text{age}}$ 是每1000次循环老化引起的电阻增长的比例系数，$N_{\\text{cycles}}$ 是等效满充满放循环次数，$k_T$ 是温度系数（当电阻随温度升高而减小时，通常为负值），$T_j$ 是该段的温度。在每个段上使用Thevenin端电压关系式 $V_t(t) = V_{\\text{oc}} - I(t)\\,R(t)$。\n\n给定分段恒定占空比曲线，每个段 $j$ 由 $(I_j, \\Delta t_j, T_j)$ 指定，其中 $I_j$ 是该段的恒定电流，$\\Delta t_j$ 是段持续时间，$T_j$ 是该段的温度。使用以上定义，设计一个程序，该程序：\n- 通过对瞬时Joule热功率进行时间积分，计算整个循环中的总欧姆耗散能量 $E_{\\text{loss}}$ (单位为焦耳)。\n- 计算在放电段期间输送至外部负载的能量 $E_{\\text{out}}$ (单位为焦耳)。\n- 计算在充电段期间由外部电源提供的能量 $E_{\\text{in}}$ (单位为焦耳)。\n- 计算往返效率 $\\eta$，其值为 $E_{\\text{out}}/E_{\\text{in}}$ 的比率，表示为小数形式（无百分号）。\n\n所有能量必须以焦耳表示，效率必须以小数形式表示。本问题不涉及角度。温度单位为开尔文，电流单位为安培，电阻单位为欧姆，电压单位为伏特，时间单位为秒。在首次出现时定义并使用以下缩略语：充电状态 (State of Charge, SOC)、等效串联电阻 (Equivalent Series Resistance, ESR) 和往返效率 (Round-Trip Efficiency, RTE)。\n\n您的程序必须为以下参数集测试套件实现计算。每个案例由元组 $(V_{\\text{oc}}, R_0, R_c, k_{\\text{age}}, N_{\\text{cycles}}, k_T, T_{\\text{ref}}, \\text{segments})$ 定义：\n\n- 案例1 (带静置的平衡循环，中度老化和轻微升温):\n  - $V_{\\text{oc}} = 3.7\\,\\mathrm{V}$, $R_0 = 0.03\\,\\Omega$, $R_c = 0.005\\,\\Omega$, $k_{\\text{age}} = 0.25$, $N_{\\text{cycles}} = 800$, $k_T = -0.004\\,\\mathrm{K}^{-1}$, $T_{\\text{ref}} = 298\\,\\mathrm{K}$。\n  - 段: $(-10\\,\\mathrm{A}, 1800\\,\\mathrm{s}, 298\\,\\mathrm{K})$, $(0\\,\\mathrm{A}, 600\\,\\mathrm{s}, 298\\,\\mathrm{K})$, $(+10\\,\\mathrm{A}, 1800\\,\\mathrm{s}, 303\\,\\mathrm{K})$。\n\n- 案例2 (低电阻、新电芯、恒温对称循环):\n  - $V_{\\text{oc}} = 3.6\\,\\mathrm{V}$, $R_0 = 0.005\\,\\Omega$, $R_c = 0.001\\,\\Omega$, $k_{\\text{age}} = 0$, $N_{\\text{cycles}} = 0$, $k_T = 0\\,\\mathrm{K}^{-1}$, $T_{\\text{ref}} = 298\\,\\mathrm{K}$。\n  - 段: $(-5\\,\\mathrm{A}, 3600\\,\\mathrm{s}, 298\\,\\mathrm{K})$, $(+5\\,\\mathrm{A}, 3600\\,\\mathrm{s}, 298\\,\\mathrm{K})$。\n\n- 案例3 (严重老化的电芯，电阻接近但低于给定电流的极限):\n  - $V_{\\text{oc}} = 3.7\\,\\mathrm{V}$, $R_0 = 0.1\\,\\Omega$, $R_c = 0.02\\,\\Omega$, $k_{\\text{age}} = 0.5$, $N_{\\text{cycles}} = 2000$, $k_T = -0.004\\,\\mathrm{K}^{-1}$, $T_{\\text{ref}} = 298\\,\\mathrm{K}$。\n  - 段: $(-5\\,\\mathrm{A}, 1200\\,\\mathrm{s}, 293\\,\\mathrm{K})$, $(+5\\,\\mathrm{A}, 1200\\,\\mathrm{s}, 313\\,\\mathrm{K})$。\n\n- 案例4 (中度老化下循环过程中的极端温度):\n  - $V_{\\text{oc}} = 3.7\\,\\mathrm{V}$, $R_0 = 0.04\\,\\Omega$, $R_c = 0.005\\,\\Omega$, $k_{\\text{age}} = 0.5$, $N_{\\text{cycles}} = 1000$, $k_T = -0.004\\,\\mathrm{K}^{-1}$, $T_{\\text{ref}} = 298\\,\\mathrm{K}$。\n  - 段: $(-8\\,\\mathrm{A}, 1800\\,\\mathrm{s}, 258\\,\\mathrm{K})$, $(+8\\,\\mathrm{A}, 1800\\,\\mathrm{s}, 318\\,\\mathrm{K})$。\n\n您的程序应生成单行输出，其中包含每个测试案例的一个四元素浮点数列表 $[E_{\\text{loss}}, E_{\\text{out}}, E_{\\text{in}}, \\eta]$，所有能量单位为焦耳，$\\eta$ 为小数形式。每个浮点数必须四舍五入到恰好六位小数。将这些各案例的列表聚合到一个顶层列表中，并以方括号括起来的逗号分隔列表形式打印，例如 $[[e_{11},e_{12},e_{13},e_{14}],[e_{21},e_{22},e_{23},e_{24}],\\dots]$。",
            "solution": "我们从基本电路原理和能量守恒出发。电池端的Thevenin等效模型将瞬时端电压定义为 $V_t(t) = V_{\\text{oc}} - I(t)\\,R(t)$，其中 $V_{\\text{oc}}$ 是开路电压，$R(t)$ 是内部等效串联电阻 (ESR)。端子处的瞬时电功率为 $P(t) = V_t(t)\\,I(t)$。电阻中耗散的Joule热功率为 $P_R(t) = I^2(t)\\,R(t)$，这直接源于Ohm定律和电阻中功率的定义。\n\n一个时间间隔内的能量是功率对时间的积分。整个占空比周期内的欧姆耗散能量是 $P_R(t)$ 的积分：\n$$\nE_{\\text{loss}} = \\int P_R(t)\\,dt = \\int I^2(t)\\,R(t)\\,dt.\n$$\n通过端子的外部能量转移为\n$$\nE_{\\text{term}} = \\int P(t)\\,dt = \\int V_t(t)\\,I(t)\\,dt = \\int \\big(V_{\\text{oc}} - I(t)\\,R(t)\\big)\\,I(t)\\,dt.\n$$\n我们采用符号约定，$I(t) > 0$ 表示对负载放电，$I(t)  0$ 表示从外部电源充电。在此约定下，放电段期间输送至负载的能量为\n$$\nE_{\\text{out}} = \\int_{I(t) > 0} V_t(t)\\,I(t)\\,dt = \\int_{I(t) > 0} \\big(V_{\\text{oc}}\\,I(t) - I^2(t)\\,R(t)\\big)\\,dt,\n$$\n充电段期间由外部电源提供的能量是在 $I(t)  0$ 期间负的端子能量的绝对值：\n$$\nE_{\\text{in}} = -\\int_{I(t)  0} V_t(t)\\,I(t)\\,dt = -\\int_{I(t)  0} \\big(V_{\\text{oc}}\\,I(t) - I^2(t)\\,R(t)\\big)\\,dt,\n$$\n其值为正。往返效率 (Round-Trip Efficiency, RTE) 定义为\n$$\n\\eta = \\frac{E_{\\text{out}}}{E_{\\text{in}}}.\n$$\n\n每个占空比曲线段 $j$ 具有恒定的电流 $I_j$、持续时间 $\\Delta t_j$ 和温度 $T_j$。因此，积分简化为对各段的求和。ESR模型考虑了老化和温度：\n$$\nR_j = \\big(R_0 + R_c\\big)\\,\\Big(1 + k_{\\text{age}}\\,\\frac{N_{\\text{cycles}}}{1000}\\Big)\\,\\Big(1 + k_T\\,\\big(T_j - T_{\\text{ref}}\\big)\\Big).\n$$\n对于每个段：\n- 使用参数和 $T_j$ 计算 $R_j$。\n- 计算端电压 $V_{t,j} = V_{\\text{oc}} - I_j\\,R_j$。\n- 计算段端子能量 $E_{\\text{term},j} = V_{t,j}\\,I_j\\,\\Delta t_j$。\n- 计算段欧姆损耗 $E_{\\text{loss},j} = I_j^2\\,R_j\\,\\Delta t_j$。\n- 对于 $I_j > 0$ 的段，将 $E_{\\text{term},j}$ 累加到 $E_{\\text{out}}$。\n- 对于 $I_j  0$ 的段，将 $-E_{\\text{term},j}$ 累加到 $E_{\\text{in}}$。\n- 将所有段的 $E_{\\text{loss},j}$ 求和以累加 $E_{\\text{loss}}$。\n\n最后计算 $\\eta = E_{\\text{out}}/E_{\\text{in}}$。此过程基于能量守恒和Ohm定律。请注意，$E_{\\text{out}}$ 等于来自开路电源的理想能量减去放电段期间的欧姆损耗，而 $E_{\\text{in}}$ 等于储存电荷所需的理想能量加上充电段期间的欧姆损耗。因为每个段都是分段恒定的，所以对于指定的曲线，该计算是精确的。\n\n算法实现细节：\n- 为了数值稳定性和清晰度，以浮点数执行计算，并按要求将最终报告的值四舍五入到六位小数。\n- 确保 $E_{\\text{in}} > 0$；所提供的测试案例满足此条件。\n- 通过构造，单位得以保持：电压单位为伏特，电流单位为安培，电阻单位为欧姆，时间单位为秒，从而得出能量单位为焦耳，$\\eta$ 为无量纲。\n\n程序将遍历问题中指定的四个测试案例，并为每个案例计算并以要求的单行聚合格式报告列表 $[E_{\\text{loss}}, E_{\\text{out}}, E_{\\text{in}}, \\eta]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_case(params):\n    \"\"\"\n    Compute E_loss, E_out, E_in, eta for a given test case.\n    params: dict with keys:\n        V_oc, R0, Rc, k_age, N_cycles, k_T, T_ref, segments\n    segments: list of tuples (I, dt, T)\n    \"\"\"\n    V_oc = float(params[\"V_oc\"])\n    R0 = float(params[\"R0\"])\n    Rc = float(params[\"Rc\"])\n    k_age = float(params[\"k_age\"])\n    N_cycles = float(params[\"N_cycles\"])\n    k_T = float(params[\"k_T\"])\n    T_ref = float(params[\"T_ref\"])\n    segments = params[\"segments\"]\n\n    age_factor = 1.0 + k_age * (N_cycles / 1000.0)\n\n    E_loss = 0.0\n    E_out = 0.0\n    E_in = 0.0\n\n    for I, dt, T in segments:\n        I = float(I)\n        dt = float(dt)\n        T = float(T)\n\n        temp_factor = 1.0 + k_T * (T - T_ref)\n        R_eff = (R0 + Rc) * age_factor * temp_factor\n\n        # Terminal voltage per Thevenin model\n        V_t = V_oc - I * R_eff\n\n        # Segment energies\n        E_term = V_t * I * dt\n        E_loss_seg = (I ** 2) * R_eff * dt\n\n        # Accumulate\n        E_loss += E_loss_seg\n        if I  0.0:\n            E_out += E_term\n        elif I  0.0:\n            E_in += (-E_term)\n        # I == 0 contributes nothing\n\n    eta = np.nan\n    if E_in  0.0:\n        eta = E_out / E_in\n\n    # Round to six decimals as required\n    def r6(x):\n        return float(f\"{x:.6f}\")\n\n    return [r6(E_loss), r6(E_out), r6(E_in), r6(eta if not np.isnan(eta) else np.nan)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"V_oc\": 3.7, \"R0\": 0.03, \"Rc\": 0.005, \"k_age\": 0.25, \"N_cycles\": 800,\n            \"k_T\": -0.004, \"T_ref\": 298.0,\n            \"segments\": [(-10.0, 1800.0, 298.0), (0.0, 600.0, 298.0), (10.0, 1800.0, 303.0)]\n        },\n        {\n            \"V_oc\": 3.6, \"R0\": 0.005, \"Rc\": 0.001, \"k_age\": 0.0, \"N_cycles\": 0.0,\n            \"k_T\": 0.0, \"T_ref\": 298.0,\n            \"segments\": [(-5.0, 3600.0, 298.0), (5.0, 3600.0, 298.0)]\n        },\n        {\n            \"V_oc\": 3.7, \"R0\": 0.1, \"Rc\": 0.02, \"k_age\": 0.5, \"N_cycles\": 2000.0,\n            \"k_T\": -0.004, \"T_ref\": 298.0,\n            \"segments\": [(-5.0, 1200.0, 293.0), (5.0, 1200.0, 313.0)]\n        },\n        {\n            \"V_oc\": 3.7, \"R0\": 0.04, \"Rc\": 0.005, \"k_age\": 0.5, \"N_cycles\": 1000.0,\n            \"k_T\": -0.004, \"T_ref\": 298.0,\n            \"segments\": [(-8.0, 1800.0, 258.0), (8.0, 1800.0, 318.0)]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_case(case)\n        results.append(result)\n\n    # Format the final output exactly as required: a single line with the aggregated list.\n    # Each inner list is printed with floats rounded to six decimals.\n    inner_strs = []\n    for lst in results:\n        inner_strs.append(\"[\" + \",\".join(f\"{x:.6f}\" for x in lst) + \"]\")\n    print(f\"[{','.join(inner_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "设计二次寿命系统的一个主要挑战是废旧电池参数中固有的不确定性。为了创建稳健可靠的系统，我们必须能够预测这种输入不确定性将如何影响电池的性能。这项高级练习 () 将向您介绍多项式混沌展开（Polynomial Chaos Expansion, PCE），这是一种强大的不确定性量化方法，您将通过它来模拟等效电路模型（Equivalent Circuit Model, ECM）参数的不确定性如何传播到其输出电压。",
            "id": "3929174",
            "problem": "您的任务是为用于梯次利用的锂离子电池的等效电路模型 (ECM) 中的不确定参数传播进行建模，以量化在指定工作循环内端电压的变异性。单个戴维南支路的 ECM 包括一个欧姆内阻、一个电阻-电容对以及一个开路电压函数。假设电池由于老化和先前使用而具有不确定参数，并且这些不确定性是独立的，并在指定范围内均匀分布。\n\n从以下基础出发，推导一个算法并用代码实现它：\n\n1. 使用由电荷守恒和线性网络理论推导出的关系所定义的 ECM。设端电压由 $V(t) = \\mathrm{OCV}(s(t)) - R_0 I(t) - V_1(t)$ 给出，其中 $R_0$ 是欧姆内阻，$I(t)$ 是施加的电流（放电为正），$s(t)$ 是荷电状态 (SOC)，$V_1(t)$ 是电容支路电压。SOC 的演变遵循 $s(t+\\Delta t) = s(t) - \\frac{I(t)\\Delta t}{Q}$，其中 $Q$ 是以库仑为单位的容量。电容支路电压遵循 $V_1(t+\\Delta t) = V_1(t) \\exp\\!\\left(-\\frac{\\Delta t}{R_1 C_1}\\right) + R_1 \\left(1 - \\exp\\!\\left(-\\frac{\\Delta t}{R_1 C_1}\\right)\\right) I(t)$，其中 $R_1$ 和 $C_1$ 是戴维南支路的电阻和电容值。开路电压在局部近似为线性函数 $\\mathrm{OCV}(s) = V_0 + \\alpha (s - s_0)$，其中 $V_0$ 是标称电压，$\\alpha$ 是斜率参数，$s_0$ 是参考 SOC。在每次更新后将 $s(t)$ 限制在区间 $[0,1]$ 内。\n\n2. 将 ECM 参数 $(R_0, R_1, C_1, Q)$ 视为不确定的独立变量，每个变量在给定区间上均匀分布。使用总阶数最高为 $p = 2$ 的多元勒让德多项式的多项式混沌展开 (PCE) 来对这些不确定性传播到输出 $V(t)$ 的过程进行建模。对于每个输入变量，使用 $\\phi_n(x) = \\sqrt{2n+1}\\,P_n(x)$（其中 $P_n$ 是勒让德多项式）构建一个关于 $[-1,1]$ 上均匀分布的标准正交基。\n\n3. 使用非侵入式回归（最小二乘法），基于一组独立同分布的输入随机变量样本，在每个时间步计算 $V(t)$ 的 PCE 系数。在标准正交基中，每个时间 $t_k$ 的方差等于该时间点所有非常数 PCE 系数的平方和。计算整个工作循环内的时间平均方差为 $\\overline{\\mathrm{Var}}(V) = \\frac{1}{T} \\sum_{k=0}^{T-1} \\mathrm{Var}(V(t_k))$。\n\n所有物理量必须使用适当的单位处理：\n- $V(t)$、$V_0$ 单位为伏特 ($\\mathrm{V}$)。\n- $I(t)$ 单位为安培 ($\\mathrm{A}$)。\n- $R_0$、$R_1$ 单位为欧姆 ($\\Omega$)。\n- $C_1$ 单位为法拉 ($\\mathrm{F}$)。\n- $Q$ 单位为库仑 ($\\mathrm{C}$)。\n- 时间单位为秒 ($\\mathrm{s}$)。\n- 最终输出是电压的时间平均方差，单位为 $\\mathrm{V}^2$，且必须表示为十进制浮点数。\n\n实现该算法并为以下三个测试用例计算 $\\overline{\\mathrm{Var}}(V)$。在所有情况下，使用 $s_0 = 0.5$，$V_0 = 3.7\\,\\mathrm{V}$，$\\alpha = 0.12\\,\\mathrm{V}$ 每单位 SOC，并用 $V_1(0) = 0\\,\\mathrm{V}$ 初始化电容支路电压。使用总阶数 $p = 2$ 的标准正交 PCE，以及至少 $S$ 个随机样本（$S$ 在每个用例中指定）。使用 $T$ 个时间步，步长为常数 $\\Delta t$，并提供分段恒定的电流 $I(t_k)$。\n\n- 测试用例 1 (理想路径)：\n  - 不确定性范围：$R_0 \\in [0.003, 0.006]\\,\\Omega$，$R_1 \\in [0.002, 0.008]\\,\\Omega$，$C_1 \\in [1500, 3000]\\,\\mathrm{F}$，$Q \\in [9000, 11000]\\,\\mathrm{C}$。\n  - 工作循环长度：$T = 20$，$\\Delta t = 1\\,\\mathrm{s}$。\n  - 初始 SOC：$s(0) = 0.6$。\n  - 电流曲线 (单位 $\\mathrm{A}$)：$[2, -1, 3, 0, 2, -2, 4, 1, -3, 0, 1, -1, 2, 0, -2, 3, -3, 0, 2, -1]$。\n  - 样本数：$S = 300$。\n\n- 测试用例 2 (边界情况：窄不确定性区间与接近静置的片段)：\n  - 不确定性范围：$R_0 \\in [0.0045, 0.005]\\,\\Omega$，$R_1 \\in [0.004, 0.0045]\\,\\Omega$，$C_1 \\in [1800, 1900]\\,\\mathrm{F}$，$Q \\in [10500, 10600]\\,\\mathrm{C}$。\n  - 工作循环长度：$T = 10$，$\\Delta t = 1\\,\\mathrm{s}$。\n  - 初始 SOC：$s(0) = 0.8$。\n  - 电流曲线 (单位 $\\mathrm{A}$)：$[0, 0, 0, 1, -1, 0, 1, -1, 0, 0]$。\n  - 样本数：$S = 200$。\n\n- 测试用例 3 (边缘情况：更高电流与更宽的不确定性区间)：\n  - 不确定性范围：$R_0 \\in [0.002, 0.008]\\,\\Omega$，$R_1 \\in [0.001, 0.010]\\,\\Omega$，$C_1 \\in [1200, 3500]\\,\\mathrm{F}$，$Q \\in [8000, 12000]\\,\\mathrm{C}$。\n  - 工作循环长度：$T = 24$，$\\Delta t = 0.5\\,\\mathrm{s}$。\n  - 初始 SOC：$s(0) = 0.5$。\n  - 电流曲线 (单位 $\\mathrm{A}$)：$[5, -5, 4, -4, 3, -3, 2, -2, 0, 6, -6, 5, -5, 4, -4, 3, -3, 2, -2, 0, 7, -7, 6, -6]$。\n  - 样本数：$S = 400$。\n\n您的程序应生成单行输出，其中包含三个测试用例的时间平均方差，形式为方括号括起来的逗号分隔列表，顺序与上述用例相同，每个值以 $\\mathrm{V}^2$ 为单位，表示为十进制浮点数。例如：$[\\text{result1},\\text{result2},\\text{result3}]$。",
            "solution": "该问题被评估为有效。它在科学上基于标准的电池建模技术（等效电路模型）和不确定性量化方法（多项式混沌展开）。该问题是适定的，提供了所有必要的参数、方程和初始条件来指定一个唯一的计算任务。这些参数和条件在梯次利用电池应用领域是物理上现实的。\n\n目标是计算锂离子电池端电压在指定工作循环内的时间平均方差，同时考虑到其等效电路模型 (ECM) 的四个关键参数是不确定的。指定的方法是一种非侵入式多项式混沌展开 (PCE)。解决方案通过以下推理步骤制定。\n\n### 1. 等效电路模型与状态空间公式\n电池的电气行为由一个一阶戴维南 ECM 描述。端电压 $V(t)$ 由下式给出：\n$$V(t) = \\mathrm{OCV}(s(t)) - R_0 I(t) - V_1(t)$$\n其中 $s(t)$ 是荷电状态 (SOC)，$I(t)$ 是电流（放电为正），$R_0$ 是欧姆内阻，$V_1(t)$ 是并联电阻-电容 ($R_1C_1$) 支路两端的电压。\n\n开路电压 (OCV) 是 SOC 的函数，在局部通过线性关系近似：\n$$\\mathrm{OCV}(s) = V_0 + \\alpha (s - s_0)$$\n其中 $V_0$、$\\alpha$ 和 $s_0$ 是给定的常数。\n\n系统的状态由两个变量描述：SOC $s(t)$ 和电容电压 $V_1(t)$。它们在步长为 $\\Delta t$ 的离散时间中的演化由以下方程控制，这些方程从电荷守恒和 RC 电路的阶跃响应推导而来：\n$$s(t_k + \\Delta t) = s(t_k) - \\frac{I(t_k)\\Delta t}{Q}$$\n$$V_1(t_k + \\Delta t) = V_1(t_k) \\exp\\!\\left(-\\frac{\\Delta t}{R_1 C_1}\\right) + R_1 \\left(1 - \\exp\\!\\left(-\\frac{\\Delta t}{R_1 C_1}\\right)\\right) I(t_k)$$\n这里，$t_k = k\\Delta t$，$I(t_k)$ 是在区间 $[t_k, t_k+\\Delta t)$ 上施加的恒定电流。SOC 在物理上被约束在区间 $[0, 1]$ 内。\n\n不确定参数是向量 $\\vec{\\theta} = [R_0, R_1, C_1, Q]$。每个分量 $\\theta_i$ 被假定为在指定区间 $[a_i, b_i]$ 上均匀分布的独立随机变量。\n\n### 2. 用于不确定性传播的多项式混沌展开\nPCE 是一种谱方法，用于将随机变量表示为正交多项式的级数展开。由于不确定参数 $\\vec{\\theta}$，模型输出，即端电压 $V(t)$，成为一个随机过程。核心思想是使用一组标准化的独立随机变量 $\\vec{\\xi} = [\\xi_0, \\xi_1, \\xi_2, \\xi_3]$ 来表示 $V(t)$，其中每个 $\\xi_i$ 都遵循一个典型的概率分布。由于我们的物理参数 $\\theta_i$ 在 $[a_i, b_i]$ 上均匀分布，我们使用仿射变换将它们映射到标准均匀变量 $\\xi_i \\in [-1, 1]$：\n$$\\theta_i = \\frac{b_i - a_i}{2} \\xi_i + \\frac{b_i + a_i}{2}$$\n现在，端电压是时间和这些标准随机变量的函数，$V(t, \\vec{\\xi})$。我们用一个总阶为 $p=2$ 的截断 PCE 来近似这个函数：\n$$V(t, \\vec{\\xi}) \\approx \\hat{V}(t, \\vec{\\xi}) = \\sum_{j=0}^{N_P-1} c_j(t) \\Psi_j(\\vec{\\xi})$$\n其中 $c_j(t)$ 是与时间相关的确定性系数，$\\Psi_j(\\vec{\\xi})$ 是多元正交基多项式。对于 $d=4$ 个变量和总阶 $p=2$，基函数的数量为 $N_P = \\frac{(p+d)!}{p!d!} = \\frac{6!}{2!4!} = 15$。\n\n基函数 $\\Psi_j(\\vec{\\xi})$ 是由单变量标准正交多项式 $\\phi_{\\alpha_i}(\\xi_i)$ 的乘积构成的。对于 $[-1,1]$ 上的均匀分布，合适的多项式是勒让德多项式 $P_n(x)$。标准正交基函数是 $\\phi_n(x) = \\sqrt{2n+1}P_n(x)$。一个多元基函数 $\\Psi_j(\\vec{\\xi})$ 对应一个多重指标 $\\vec{\\alpha}_j = (\\alpha_{j,0}, \\alpha_{j,1}, \\alpha_{j,2}, \\alpha_{j,3})$，其总阶 $|\\vec{\\alpha}_j| = \\sum_i \\alpha_{j,i} \\le p$：\n$$\\Psi_j(\\vec{\\xi}) = \\prod_{i=0}^{3} \\phi_{\\alpha_{j,i}}(\\xi_i) = \\prod_{i=0}^{3} \\sqrt{2\\alpha_{j,i}+1} P_{\\alpha_{j,i}}(\\xi_i)$$\n\n### 3. 用于系数计算的非侵入式回归\nPCE 系数 $c_j(t)$ 是使用非侵入式回归方法计算的。这种方法将 ECM 模拟视为一个“黑箱”模型，我们在随机输入空间的特定点上查询它。过程如下：\n1.  **抽样**：从 $[-1,1]^4$ 上的 4 维标准均匀分布中生成 $S$ 个独立同分布 (i.i.d.) 的样本 $\\vec{\\xi}^{(1)}, \\dots, \\vec{\\xi}^{(S)}$。\n2.  **模型评估**：对于每个样本 $\\vec{\\xi}^{(i)}$，计算相应的物理参数 $\\vec{\\theta}^{(i)}$，并运行完整的时域 ECM 模拟。这将产生 $S$ 条端电压轨迹，$V^{(i)}(t_k)$，其中 $k=0, \\dots, T-1$。\n3.  **线性系统构建**：在每个时间步 $t_k$，我们都有一组 $S$ 个输入-输出对 $(\\vec{\\xi}^{(i)}, V^{(i)}(t_k))$。我们可以将所有样本的 PCE 近似写成矩阵形式：$\\mathbf{Y}_k \\approx \\mathbf{\\Phi} \\mathbf{c}_k$，其中：\n    *   $\\mathbf{Y}_k$ 是一个大小为 $S$ 的向量，包含模型输出 $V^{(i)}(t_k)$。\n    *   $\\mathbf{\\Phi}$ 是 $S \\times N_P$ 的设计矩阵，其中每个元素 $\\Phi_{ij} = \\Psi_j(\\vec{\\xi}^{(i)})$ 是第 $j$ 个基函数在第 $i$ 个样本点上的评价值。\n    *   $\\mathbf{c}_k$ 是在时间 $t_k$ 的 $N_P$ 个未知 PCE 系数的向量。\n4.  **最小二乘解**：由于样本数量 $S$ 被选择为大于系数数量 $N_P$，该系统是超定的。系数 $\\mathbf{c}_k$ 通过求解线性最小二乘问题找到，该问题最小化了平方误差 $||\\mathbf{Y}_k - \\mathbf{\\Phi} \\mathbf{c}_k||_2^2$。解由 $\\mathbf{c}_k = (\\mathbf{\\Phi}^T \\mathbf{\\Phi})^\\dagger \\mathbf{\\Phi}^T \\mathbf{Y}_k$ 给出，其中 $\\dagger$ 表示 Moore-Penrose 伪逆。\n\n### 4. 方差计算\n使用标准正交基的一个关键优势是统计矩的计算被简化了。模型输出的期望值（均值）就是第一个系数，对应于常数基函数 $\\Psi_0=1$：\n$$\\mathbb{E}[V(t_k)] \\approx c_0(t_k)$$\n方差是所有其他系数平方的和：\n$$\\mathrm{Var}(V(t_k)) = \\mathbb{E}[(V(t_k)-\\mathbb{E}[V(t_k)])^2] \\approx \\sum_{j=1}^{N_P-1} c_j(t_k)^2$$\n最终要求的量是时间平均方差，计算覆盖工作循环的 $T$ 个时间步：\n$$\\overline{\\mathrm{Var}}(V) = \\frac{1}{T} \\sum_{k=0}^{T-1} \\mathrm{Var}(V(t_k))$$\n\n### 5. 算法实现\n对于每个测试用例，算法按以下步骤进行：\n1.  初始化常数（$V_0, \\alpha, s_0, p=2$）和测试用例特定的参数（参数范围、初始 SOC、工作循环细节）。为可复现性设置一个随机种子。\n2.  生成 4 维标准均匀随机向量 $\\vec{\\xi}$ 的 $S$ 个样本。\n3.  为 $d=4$ 和 $p=2$ 生成多重指标 $\\vec{\\alpha}_j$。共有 $N_P=15$ 个这样的指标。\n4.  通过在 $\\vec{\\xi}$ 的 $S$ 个样本点上评估 15 个多元标准正交勒让德多项式，构建 $S \\times 15$ 的设计矩阵 $\\mathbf{\\Phi}$。\n5.  初始化一个 $S \\times T$ 的矩阵，用于存储蒙特卡洛模拟的结果。\n6.  循环 $S$ 次：\n    a. 对于当前样本 $\\vec{\\xi}^{(i)}$，将其转换为物理参数集 $\\vec{\\theta}^{(i)} = [R_0, R_1, C_1, Q]^{(i)}$。\n    b. 使用 $\\vec{\\theta}^{(i)}$ 和给定的电流曲线运行 ECM 模拟 $T$ 个时间步。将得到的 $T$ 个电压值存储在结果矩阵中。\n7.  初始化一个数组，用于存储每个时间步的方差。\n8.  循环 $T$ 次（对于每个时间步 $k=0, \\dots, T-1$）：\n    a. 提取此时的 $S$ 个电压输出向量 $\\mathbf{Y}_k$。\n    b. 求解线性最小二乘系统 $\\mathbf{Y}_k \\approx \\mathbf{\\Phi} \\mathbf{c}_k$ 以获得系数向量 $\\mathbf{c}_k$。\n    c. 通过对第二个到最后一个系数的平方求和来计算此步的方差，即 $\\sum_{j=1}^{14} c_{j,k}^2$。存储此值。\n9.  计算所存储方差的平均值，以获得最终的时间平均方差 $\\overline{\\mathrm{Var}}(V)$。\n对三个测试用例中的每一个重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre\n\ndef get_multi_indices(d, p_total):\n    \"\"\"\n    Generates multi-indices for multivariate polynomials of d variables\n    up to a total polynomial order p_total.\n    \"\"\"\n    if d == 1:\n        return [[i] for i in range(p_total + 1)]\n    \n    indices = []\n    for i in range(p_total + 1):\n        sub_indices = get_multi_indices(d - 1, p_total - i)\n        for sub_index in sub_indices:\n            indices.append([i] + sub_index)\n    return indices\n\ndef build_pce_design_matrix(xi_samples, multi_indices, p_order):\n    \"\"\"\n    Builds the PCE design matrix Phi from samples of standard variables.\n    \"\"\"\n    S, d = xi_samples.shape\n    num_coeffs = len(multi_indices)\n    \n    # Pre-compute Legendre polynomials and normalization factors\n    polys = [legendre(i) for i in range(p_order + 1)]\n    ortho_factors = np.sqrt(2 * np.arange(p_order + 1) + 1)\n    \n    Phi = np.ones((S, num_coeffs))\n\n    # Pre-evaluate polynomial values for all samples to speed up computation\n    # poly_evals[deg, dim, sample_idx]\n    poly_evals = np.array([[polys[deg](xi_samples[:, i]) for i in range(d)] for deg in range(p_order + 1)])\n    \n    for k, idx in enumerate(multi_indices):\n        # The first index (0,0,0,0) results in a column of ones, handled by initialization.\n        if k == 0:\n            continue\n        \n        term_product = np.ones(S)\n        for i in range(d):\n            poly_degree = idx[i]\n            # phi_n(x) = sqrt(2n+1) * Pn(x)\n            term_product *= ortho_factors[poly_degree] * poly_evals[poly_degree, i, :]\n        Phi[:, k] = term_product\n        \n    return Phi\n\ndef run_ecm_simulation(params, T, dt, I_profile, s_init, v1_init, V0, alpha, s0):\n    \"\"\"\n    Runs a time-domain simulation of the ECM for a single parameter set.\n    \"\"\"\n    R0, R1, C1, Q = params\n    \n    s_current = s_init\n    v1_current = v1_init\n    V_out_series = np.zeros(T)\n\n    # Avoid division by zero if R1 or C1 is zero.\n    tau = R1 * C1\n    exp_term = np.exp(-dt / tau) if tau  0 else 0.0\n\n    for k in range(T):\n        I_k = I_profile[k]\n\n        # Calculate terminal voltage at current time step t_k\n        ocv = V0 + alpha * (s_current - s0)\n        v_terminal = ocv - R0 * I_k - v1_current\n        V_out_series[k] = v_terminal\n\n        # Update state for next time step t_{k+1}\n        s_next = s_current - (I_k * dt) / Q\n        s_next = np.clip(s_next, 0.0, 1.0) # Clamp SOC\n        \n        v1_next = v1_current * exp_term + R1 * (1 - exp_term) * I_k\n\n        # Advance to the next state\n        s_current = s_next\n        v1_current = v1_next\n        \n    return V_out_series\n\ndef solve_case(case_data):\n    \"\"\"\n    Solves a single test case for the time-averaged voltage variance.\n    \"\"\"\n    param_ranges = case_data['ranges']\n    T = case_data['T']\n    dt = case_data['dt']\n    I_profile = case_data['I']\n    s_init = case_data['s_init']\n    S = case_data['S']\n\n    # Shared constants\n    V0 = 3.7\n    alpha = 0.12\n    s0 = 0.5\n    v1_init = 0.0\n    p_order = 2\n    d = 4 # Number of uncertain parameters\n\n    # For reproducibility of sampling\n    np.random.seed(42)\n\n    # Step 1: Generate samples in standard uniform space [-1, 1]\n    xi_samples = np.random.uniform(-1, 1, size=(S, d))\n\n    # Step 2: Transform samples to physical parameter space\n    theta_samples = np.zeros_like(xi_samples)\n    for i, (a, b) in enumerate(param_ranges):\n        theta_samples[:, i] = (b - a) / 2.0 * xi_samples[:, i] + (b + a) / 2.0\n    \n    # Step 3: Build PCE design matrix\n    multi_indices = get_multi_indices(d, p_order)\n    Phi = build_pce_design_matrix(xi_samples, multi_indices, p_order)\n\n    # Step 4: Run Monte Carlo simulations\n    V_mc_results = np.zeros((S, T))\n    for i in range(S):\n        V_mc_results[i, :] = run_ecm_simulation(\n            params=theta_samples[i, :],\n            T=T, dt=dt, I_profile=I_profile, s_init=s_init,\n            v1_init=v1_init, V0=V0, alpha=alpha, s0=s0\n        )\n\n    # Step 5: Compute PCE coefficients and variance for each time step\n    variances_over_time = np.zeros(T)\n    for k in range(T):\n        Y_k = V_mc_results[:, k]\n        # Solve for coefficients using least squares\n        coeffs, _, _, _ = np.linalg.lstsq(Phi, Y_k, rcond=None)\n        # Variance is the sum of squares of non-constant coefficients\n        variances_over_time[k] = np.sum(coeffs[1:]**2)\n    \n    # Step 6: Compute time-averaged variance\n    avg_variance = np.mean(variances_over_time)\n    return avg_variance\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the solution for all test cases.\n    \"\"\"\n    test_cases = [\n        { # Test Case 1\n            'ranges': [(0.003, 0.006), (0.002, 0.008), (1500, 3000), (9000, 11000)],\n            'T': 20, 'dt': 1.0, 's_init': 0.6, 'S': 300,\n            'I': np.array([2, -1, 3, 0, 2, -2, 4, 1, -3, 0, 1, -1, 2, 0, -2, 3, -3, 0, 2, -1]),\n        },\n        { # Test Case 2\n            'ranges': [(0.0045, 0.005), (0.004, 0.0045), (1800, 1900), (10500, 10600)],\n            'T': 10, 'dt': 1.0, 's_init': 0.8, 'S': 200,\n            'I': np.array([0, 0, 0, 1, -1, 0, 1, -1, 0, 0]),\n        },\n        { # Test Case 3\n            'ranges': [(0.002, 0.008), (0.001, 0.010), (1200, 3500), (8000, 12000)],\n            'T': 24, 'dt': 0.5, 's_init': 0.5, 'S': 400,\n            'I': np.array([5, -5, 4, -4, 3, -3, 2, -2, 0, 6, -6, 5, -5, 4, -4, 3, -3, 2, -2, 0, 7, -7, 6, -6]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}