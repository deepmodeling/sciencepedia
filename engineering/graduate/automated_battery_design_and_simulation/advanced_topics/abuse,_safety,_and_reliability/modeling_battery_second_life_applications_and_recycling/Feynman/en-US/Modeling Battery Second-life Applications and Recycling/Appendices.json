{
    "hands_on_practices": [
        {
            "introduction": "Assessing a battery for a second-life role requires more than just measuring its remaining capacity. This exercise  guides you in defining an application-specific State of Health (SOH) that incorporates both energy retention and power delivery capability. By calculating SOH as a function of both capacity fade and resistance increase, you will learn to make more nuanced and practical decisions about a battery's suitability for a new purpose.",
            "id": "3929204",
            "problem": "A single lithium-ion cell is being evaluated for second-life use in a power-assist application within an automated battery design and simulation workflow. The application requires a short pulse discharge at a peak current equal to twice the C-rate. The cell has a rated capacity of $Q_{\\text{rated}}=3.0\\ \\mathrm{Ah}$ and an aged measured capacity of $Q_{\\text{aged}}=2.4\\ \\mathrm{Ah}$. The Direct Current (DC) internal resistance increases by $30\\%$ due to ageing relative to the rated DC resistance. The cell’s rated DC resistance is $R_{\\text{DC,rated}}=30\\ \\mathrm{m}\\Omega$. The Open-Circuit Voltage (OCV) at the operating state-of-charge is approximately constant during the pulse at $V_{\\text{OCV}}=3.6\\ \\mathrm{V}$. The application imposes a voltage sag limit such that the terminal voltage drop due to resistive losses during the pulse must not exceed $10\\%$ of the Open-Circuit Voltage, i.e., the allowable drop fraction is $\\eta_{\\max}=0.10$.\n\nUse the following fundamental bases:\n- Ohm’s law $V=I R$ for resistive voltage drop.\n- C-rate definition: a C-rate of $1\\ \\mathrm{C}$ corresponds to a current of $Q$ in $\\mathrm{A}$ when capacity is given in $\\mathrm{Ah}$, so a $2\\ \\mathrm{C}$ pulse current requirement is $I_{\\text{req}}=2\\,Q_{\\text{rated}}$.\n- Define application-specific State of Health (SOH) for second-life screening as the most conservative among capacity retention and instantaneous current capability under the voltage sag constraint, namely\n$$\n\\mathrm{SOH}_{\\text{app}}=\\min\\!\\left(\\frac{Q_{\\text{aged}}}{Q_{\\text{rated}}},\\ \\min\\!\\left(1,\\ \\frac{I_{\\max}}{I_{\\text{req}}}\\right)\\right),\n$$\nwhere $I_{\\max}$ is the maximum allowable discharge current that satisfies the voltage sag limit $I\\,R_{\\text{DC,aged}}\\leq \\eta_{\\max}\\,V_{\\text{OCV}}$, with $R_{\\text{DC,aged}}$ the aged DC resistance.\n\nAssume temperature is constant and the OCV does not change appreciably over the short pulse so that the resistive drop model is valid. Compute the application-specific State of Health $\\mathrm{SOH}_{\\text{app}}$ for this cell. Express your final answer as a unitless decimal rounded to four significant figures.",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It presents a standard engineering scenario for evaluating a battery's fitness for a second-life application. All necessary data and definitions are provided, and the requested calculation is based on fundamental principles of electrical circuits and battery characterization.\n\nThe objective is to compute the application-specific State of Health ($\\mathrm{SOH}_{\\text{app}}$). The governing equation is given as:\n$$\n\\mathrm{SOH}_{\\text{app}}=\\min\\!\\left(\\frac{Q_{\\text{aged}}}{Q_{\\text{rated}}},\\ \\min\\!\\left(1,\\ \\frac{I_{\\max}}{I_{\\text{req}}}\\right)\\right)\n$$\nThis formula indicates that $\\mathrm{SOH}_{\\text{app}}$ is the more conservative (i.e., the minimum) of two metrics: one based on capacity retention and the other on current-delivery capability. We will calculate these two metrics sequentially.\n\nFirst, we calculate the capacity retention term, which is the ratio of the aged capacity, $Q_{\\text{aged}}$, to the rated capacity, $Q_{\\text{rated}}$.\nThe given values are:\n- Rated capacity, $Q_{\\text{rated}} = 3.0\\ \\mathrm{Ah}$\n- Aged capacity, $Q_{\\text{aged}} = 2.4\\ \\mathrm{Ah}$\n\nThe capacity retention is:\n$$\n\\frac{Q_{\\text{aged}}}{Q_{\\text{rated}}} = \\frac{2.4\\ \\mathrm{Ah}}{3.0\\ \\mathrm{Ah}} = 0.8\n$$\n\nSecond, we evaluate the current capability term, $\\min\\!\\left(1,\\ \\frac{I_{\\max}}{I_{\\text{req}}}\\right)$. This requires the calculation of the required application current, $I_{\\text{req}}$, and the maximum current the cell can supply under the given constraints, $I_{\\max}$.\n\nThe required current, $I_{\\text{req}}$, is for a pulse at twice the C-rate ($2\\ \\mathrm{C}$) relative to the rated capacity. By definition, a $1\\ \\mathrm{C}$ current for a battery with capacity $Q_{\\text{rated}}$ in units of $\\mathrm{Ah}$ is a current of value $Q_{\\text{rated}}$ in units of $\\mathrm{A}$.\nFor $Q_{\\text{rated}} = 3.0\\ \\mathrm{Ah}$, the required $2\\ \\mathrm{C}$ current is:\n$$\nI_{\\text{req}} = 2 \\times 3.0\\ \\mathrm{A} = 6.0\\ \\mathrm{A}\n$$\n\nThe maximum allowable current, $I_{\\max}$, is determined by the constraint on the voltage sag. The voltage drop due to the internal resistance, $\\Delta V_{\\text{drop}}$, must not exceed a fraction $\\eta_{\\max}$ of the Open-Circuit Voltage, $V_{\\text{OCV}}$. Using Ohm's law, this is expressed as:\n$$\n\\Delta V_{\\text{drop}} = I R \\leq \\eta_{\\max} V_{\\text{OCV}}\n$$\nThe resistance in this context is the aged DC internal resistance, $R_{\\text{DC,aged}}$. The maximum current $I_{\\max}$ is the current at which this inequality becomes an equality:\n$$\nI_{\\max} R_{\\text{DC,aged}} = \\eta_{\\max} V_{\\text{OCV}}\n$$\nWe need to calculate $R_{\\text{DC,aged}}$. The rated DC resistance is $R_{\\text{DC,rated}} = 30\\ \\mathrm{m}\\Omega = 0.030\\ \\Omega$. This resistance increases by $30\\%$ with age.\n$$\nR_{\\text{DC,aged}} = R_{\\text{DC,rated}} \\times (1 + \\frac{30}{100}) = 0.030\\ \\Omega \\times (1 + 0.30) = 0.030\\ \\Omega \\times 1.30 = 0.039\\ \\Omega\n$$\nWith the given values $\\eta_{\\max} = 0.10$ and $V_{\\text{OCV}} = 3.6\\ \\mathrm{V}$, we can now solve for $I_{\\max}$:\n$$\nI_{\\max} = \\frac{\\eta_{\\max} V_{\\text{OCV}}}{R_{\\text{DC,aged}}} = \\frac{0.10 \\times 3.6\\ \\mathrm{V}}{0.039\\ \\Omega} = \\frac{0.36}{0.039}\\ \\mathrm{A} = \\frac{360}{39}\\ \\mathrm{A} = \\frac{120}{13}\\ \\mathrm{A}\n$$\nNow we compute the ratio of the maximum current to the required current:\n$$\n\\frac{I_{\\max}}{I_{\\text{req}}} = \\frac{\\frac{120}{13}\\ \\mathrm{A}}{6.0\\ \\mathrm{A}} = \\frac{120}{13 \\times 6} = \\frac{20}{13}\n$$\nThe current capability metric is therefore:\n$$\n\\min\\!\\left(1,\\ \\frac{I_{\\max}}{I_{\\text{req}}}\\right) = \\min\\!\\left(1,\\ \\frac{20}{13}\\right)\n$$\nSince $\\frac{20}{13} \\approx 1.538 > 1$, the minimum value is $1$. This indicates that the cell's current delivery capability is not a limiting factor for this application, as it can supply more current than required while respecting the voltage sag constraint.\n\nFinally, we substitute the two calculated metrics back into the expression for $\\mathrm{SOH}_{\\text{app}}$:\n$$\n\\mathrm{SOH}_{\\text{app}} = \\min\\!\\left(0.8, 1\\right) = 0.8\n$$\nThe performance of the aged cell is thus limited by its reduced capacity, not its power capability, for this specific application. The problem requests the answer as a unitless decimal rounded to four significant figures.\n$$\n\\mathrm{SOH}_{\\text{app}} = 0.8000\n$$",
            "answer": "$$\n\\boxed{0.8000}\n$$"
        },
        {
            "introduction": "The economic viability of a second-life battery system often hinges on its Round-Trip Efficiency (RTE). In this practice , you will develop a simulation to quantify RTE by modeling the ohmic losses within a battery, based on a Thevenin equivalent circuit. This exercise will help you understand how factors like cell age and operating temperature directly affect energy losses ($I^2R$) and overall system efficiency.",
            "id": "3929154",
            "problem": "Consider a single-branch Thevenin-equivalent model of a rechargeable battery module where the open-circuit voltage is modeled as a constant $V_{\\text{oc}}$ over the short duty cycles of interest and the internal Equivalent Series Resistance (ESR) $R(t)$ is a function of cell age and temperature. The goal is to compute the round-trip efficiency over a specified charge–discharge duty profile by explicitly accounting for ohmic losses. Use first principles from electric circuit theory and energy conservation to derive your computation. Assume the following foundations: instantaneous terminal voltage is $V_t(t)$, instantaneous current is $I(t)$ (positive for discharge into a load, negative for charge from an external source), instantaneous electrical power is $P(t) = V_t(t)\\,I(t)$, and the Joule heating power dissipated in the ESR is $P_R(t)$.\n\nModel the internal ESR as a multiplicative function of age and temperature about a reference temperature. Let the effective internal resistance during segment $j$ be\n$$\nR_j \\equiv \\big(R_0 + R_c\\big)\\,\\Big(1 + k_{\\text{age}}\\,\\frac{N_{\\text{cycles}}}{1000}\\Big)\\,\\Big(1 + k_T\\,\\big(T_j - T_{\\text{ref}}\\big)\\Big),\n$$\nwhere $R_0$ is the base resistance of the aged chemistry at reference temperature $T_{\\text{ref}}$, $R_c$ is the contact and interconnect resistance, $k_{\\text{age}}$ scales the age-induced resistance growth per $1000$ cycles, $N_{\\text{cycles}}$ is the number of equivalent full cycles, $k_T$ is the temperature coefficient (negative values are typical when resistance decreases with temperature), and $T_j$ is the segment temperature. Use the Thevenin terminal relation $V_t(t) = V_{\\text{oc}} - I(t)\\,R(t)$ over each segment.\n\nYou are given piecewise-constant duty profiles, with each segment $j$ specified by $(I_j, \\Delta t_j, T_j)$, where $I_j$ is the constant current during the segment, $\\Delta t_j$ is the segment duration, and $T_j$ is the segment temperature. Using the definitions above, design a program that:\n- Computes the total ohmic dissipation energy $E_{\\text{loss}}$ over the entire cycle in joules by integrating the instantaneous Joule heating power over time.\n- Computes the energy delivered to the external load during discharge segments $E_{\\text{out}}$ in joules.\n- Computes the energy supplied by the external source during charge segments $E_{\\text{in}}$ in joules.\n- Computes the round-trip efficiency $\\eta$ as the ratio $E_{\\text{out}}/E_{\\text{in}}$ expressed as a decimal fraction (no percentage sign).\n\nAll energies must be expressed in joules and the efficiency must be expressed as a decimal fraction. Angles do not appear in this problem. The unit for temperature is kelvin, current is amperes, resistance is ohms, voltage is volts, and time is seconds. Define and use the following acronyms on first appearance: State of Charge (SOC), Equivalent Series Resistance (ESR), and Round-Trip Efficiency (RTE).\n\nYour program must implement the computation for the following test suite of parameter sets. Each case is defined by the tuple $(V_{\\text{oc}}, R_0, R_c, k_{\\text{age}}, N_{\\text{cycles}}, k_T, T_{\\text{ref}}, \\text{segments})$:\n\n- Case $1$ (balanced cycle with a rest, moderate aging and mild warming):\n  - $V_{\\text{oc}} = 3.7\\,\\mathrm{V}$, $R_0 = 0.03\\,\\Omega$, $R_c = 0.005\\,\\Omega$, $k_{\\text{age}} = 0.25$, $N_{\\text{cycles}} = 800$, $k_T = -0.004\\,\\mathrm{K}^{-1}$, $T_{\\text{ref}} = 298\\,\\mathrm{K}$.\n  - Segments: $(-10\\,\\mathrm{A}, 1800\\,\\mathrm{s}, 298\\,\\mathrm{K})$, $(0\\,\\mathrm{A}, 600\\,\\mathrm{s}, 298\\,\\mathrm{K})$, $(+10\\,\\mathrm{A}, 1800\\,\\mathrm{s}, 303\\,\\mathrm{K})$.\n\n- Case $2$ (low-resistance, new cell, symmetric cycle at constant temperature):\n  - $V_{\\text{oc}} = 3.6\\,\\mathrm{V}$, $R_0 = 0.005\\,\\Omega$, $R_c = 0.001\\,\\Omega$, $k_{\\text{age}} = 0$, $N_{\\text{cycles}} = 0$, $k_T = 0\\,\\mathrm{K}^{-1}$, $T_{\\text{ref}} = 298\\,\\mathrm{K}$.\n  - Segments: $(-5\\,\\mathrm{A}, 3600\\,\\mathrm{s}, 298\\,\\mathrm{K})$, $(+5\\,\\mathrm{A}, 3600\\,\\mathrm{s}, 298\\,\\mathrm{K})$.\n\n- Case $3$ (heavily aged cell, resistance near but below the limit for the given current):\n  - $V_{\\text{oc}} = 3.7\\,\\mathrm{V}$, $R_0 = 0.1\\,\\Omega$, $R_c = 0.02\\,\\Omega$, $k_{\\text{age}} = 0.5$, $N_{\\text{cycles}} = 2000$, $k_T = -0.004\\,\\mathrm{K}^{-1}$, $T_{\\text{ref}} = 298\\,\\mathrm{K}$.\n  - Segments: $(-5\\,\\mathrm{A}, 1200\\,\\mathrm{s}, 293\\,\\mathrm{K})$, $(+5\\,\\mathrm{A}, 1200\\,\\mathrm{s}, 313\\,\\mathrm{K})$.\n\n- Case $4$ (temperature extremes across the cycle with moderate aging):\n  - $V_{\\text{oc}} = 3.7\\,\\mathrm{V}$, $R_0 = 0.04\\,\\Omega$, $R_c = 0.005\\,\\Omega$, $k_{\\text{age}} = 0.5$, $N_{\\text{cycles}} = 1000$, $k_T = -0.004\\,\\mathrm{K}^{-1}$, $T_{\\text{ref}} = 298\\,\\mathrm{K}$.\n  - Segments: $(-8\\,\\mathrm{A}, 1800\\,\\mathrm{s}, 258\\,\\mathrm{K})$, $(+8\\,\\mathrm{A}, 1800\\,\\mathrm{s}, 318\\,\\mathrm{K})$.\n\nYour program should produce a single line of output containing, for each test case, a four-element list of floats $[E_{\\text{loss}}, E_{\\text{out}}, E_{\\text{in}}, \\eta]$ with all energies in joules and $\\eta$ as a decimal fraction. Each float must be rounded to exactly six decimal places. Aggregate these per-case lists into a single top-level list and print it as a comma-separated list enclosed in square brackets, for example, $[[e_{11},e_{12},e_{13},e_{14}],[e_{21},e_{22},e_{23},e_{24}],\\dots]$.",
            "solution": "We begin from fundamental electric circuit principles and energy conservation. The Thevenin-equivalent model for the battery terminal defines the instantaneous terminal voltage as $V_t(t) = V_{\\text{oc}} - I(t)\\,R(t)$, where $V_{\\text{oc}}$ is the open-circuit voltage and $R(t)$ is the internal Equivalent Series Resistance (ESR). The instantaneous electrical power at the terminals is $P(t) = V_t(t)\\,I(t)$. The Joule heating power dissipated in the resistance is $P_R(t) = I^2(t)\\,R(t)$, which follows directly from Ohm's law and the definition of power in a resistor.\n\nEnergy over a time interval is the time integral of power. The ohmic dissipation energy over the entire duty cycle is the integral of $P_R(t)$:\n$$\nE_{\\text{loss}} = \\int P_R(t)\\,dt = \\int I^2(t)\\,R(t)\\,dt.\n$$\nThe external energy transfer through the terminals is\n$$\nE_{\\text{term}} = \\int P(t)\\,dt = \\int V_t(t)\\,I(t)\\,dt = \\int \\big(V_{\\text{oc}} - I(t)\\,R(t)\\big)\\,I(t)\\,dt.\n$$\nWe adopt the sign convention that $I(t) > 0$ for discharge into a load and $I(t) < 0$ for charge from an external source. Under this convention, energy delivered to the load during discharge segments is\n$$\nE_{\\text{out}} = \\int_{I(t) > 0} V_t(t)\\,I(t)\\,dt = \\int_{I(t) > 0} \\big(V_{\\text{oc}}\\,I(t) - I^2(t)\\,R(t)\\big)\\,dt,\n$$\nand energy supplied by the external source during charge segments is the magnitude of the negative terminal energy over $I(t) < 0$:\n$$\nE_{\\text{in}} = -\\int_{I(t) < 0} V_t(t)\\,I(t)\\,dt = \\int_{I(t) < 0} \\big(-V_{\\text{oc}}\\,I(t) - I^2(t)\\,R(t)\\big)\\,dt,\n$$\nwhich is positive. The Round-Trip Efficiency (RTE) is defined as\n$$\n\\eta = \\frac{E_{\\text{out}}}{E_{\\text{in}}}.\n$$\n\nEach duty profile segment $j$ has constant current $I_j$, duration $\\Delta t_j$, and temperature $T_j$. Therefore the integrals reduce to sums over segments. The ESR model accounts for age and temperature:\n$$\nR_j = \\big(R_0 + R_c\\big)\\,\\Big(1 + k_{\\text{age}}\\,\\frac{N_{\\text{cycles}}}{1000}\\Big)\\,\\Big(1 + k_T\\,\\big(T_j - T_{\\text{ref}}\\big)\\Big).\n$$\nFor each segment:\n- Compute $R_j$ using the parameters and $T_j$.\n- Compute the terminal voltage $V_{t,j} = V_{\\text{oc}} - I_j\\,R_j$.\n- Compute segment terminal energy $E_{\\text{term},j} = V_{t,j}\\,I_j\\,\\Delta t_j$.\n- Compute segment ohmic loss $E_{\\text{loss},j} = I_j^2\\,R_j\\,\\Delta t_j$.\n- Accumulate $E_{\\text{out}}$ by adding $E_{\\text{term},j}$ for segments with $I_j > 0$.\n- Accumulate $E_{\\text{in}}$ by adding $-E_{\\text{term},j}$ for segments with $I_j < 0$.\n- Accumulate $E_{\\text{loss}}$ by summing $E_{\\text{loss},j}$ over all segments.\n\nFinally compute $\\eta = E_{\\text{out}}/E_{\\text{in}}$. This procedure is grounded in the conservation of energy and Ohm's law. Note that $E_{\\text{out}}$ equals the ideal energy from the open-circuit source minus the ohmic losses during discharge segments, while $E_{\\text{in}}$ equals the ideal energy required to store charge plus the ohmic losses during charge segments. Because each segment is piecewise constant, the computation is exact for the specified profiles.\n\nAlgorithmic implementation details:\n- For numerical stability and clarity, perform computations in floating point and round the final reported values to six decimal places as required.\n- Ensure that $E_{\\text{in}} > 0$; the provided test cases satisfy this condition.\n- Units are preserved by construction: voltage in volts, current in amperes, resistance in ohms, time in seconds, yielding energy in joules and dimensionless $\\eta$.\n\nThe program will iterate over the four test cases specified in the problem and, for each case, compute and report the list $[E_{\\text{loss}}, E_{\\text{out}}, E_{\\text{in}}, \\eta]$ in the required single-line aggregated format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_case(params):\n    \"\"\"\n    Compute E_loss, E_out, E_in, eta for a given test case.\n    params: dict with keys:\n        V_oc, R0, Rc, k_age, N_cycles, k_T, T_ref, segments\n    segments: list of tuples (I, dt, T)\n    \"\"\"\n    V_oc = float(params[\"V_oc\"])\n    R0 = float(params[\"R0\"])\n    Rc = float(params[\"Rc\"])\n    k_age = float(params[\"k_age\"])\n    N_cycles = float(params[\"N_cycles\"])\n    k_T = float(params[\"k_T\"])\n    T_ref = float(params[\"T_ref\"])\n    segments = params[\"segments\"]\n\n    age_factor = 1.0 + k_age * (N_cycles / 1000.0)\n\n    E_loss = 0.0\n    E_out = 0.0\n    E_in = 0.0\n\n    for I, dt, T in segments:\n        I = float(I)\n        dt = float(dt)\n        T = float(T)\n\n        temp_factor = 1.0 + k_T * (T - T_ref)\n        R_eff = (R0 + Rc) * age_factor * temp_factor\n\n        # Terminal voltage per Thevenin model\n        V_t = V_oc - I * R_eff\n\n        # Segment energies\n        E_term = V_t * I * dt\n        E_loss_seg = (I ** 2) * R_eff * dt\n\n        # Accumulate\n        E_loss += E_loss_seg\n        if I > 0.0:\n            E_out += E_term\n        elif I  0.0:\n            E_in += (-E_term)\n        # I == 0 contributes nothing\n\n    eta = np.nan\n    if E_in > 0.0:\n        eta = E_out / E_in\n\n    # Round to six decimals as required\n    def r6(x):\n        return float(f\"{x:.6f}\")\n\n    return [r6(E_loss), r6(E_out), r6(E_in), r6(eta if not np.isnan(eta) else np.nan)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"V_oc\": 3.7, \"R0\": 0.03, \"Rc\": 0.005, \"k_age\": 0.25, \"N_cycles\": 800,\n            \"k_T\": -0.004, \"T_ref\": 298.0,\n            \"segments\": [(-10.0, 1800.0, 298.0), (0.0, 600.0, 298.0), (10.0, 1800.0, 303.0)]\n        },\n        {\n            \"V_oc\": 3.6, \"R0\": 0.005, \"Rc\": 0.001, \"k_age\": 0.0, \"N_cycles\": 0.0,\n            \"k_T\": 0.0, \"T_ref\": 298.0,\n            \"segments\": [(-5.0, 3600.0, 298.0), (5.0, 3600.0, 298.0)]\n        },\n        {\n            \"V_oc\": 3.7, \"R0\": 0.1, \"Rc\": 0.02, \"k_age\": 0.5, \"N_cycles\": 2000.0,\n            \"k_T\": -0.004, \"T_ref\": 298.0,\n            \"segments\": [(-5.0, 1200.0, 293.0), (5.0, 1200.0, 313.0)]\n        },\n        {\n            \"V_oc\": 3.7, \"R0\": 0.04, \"Rc\": 0.005, \"k_age\": 0.5, \"N_cycles\": 1000.0,\n            \"k_T\": -0.004, \"T_ref\": 298.0,\n            \"segments\": [(-8.0, 1800.0, 258.0), (8.0, 1800.0, 318.0)]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_case(case)\n        results.append(result)\n\n    # Format the final output exactly as required: a single line with the aggregated list.\n    # Each inner list is printed with floats rounded to six decimals.\n    inner_strs = []\n    for lst in results:\n        inner_strs.append(\"[\" + \",\".join(f\"{x:.6f}\" for x in lst) + \"]\")\n    print(f\"[{','.join(inner_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A major challenge in second-life applications is the inherent uncertainty in the properties of aged batteries. This advanced practice  introduces a powerful technique, Polynomial Chaos Expansion (PCE), to model this variability. You will implement an algorithm to propagate uncertainty from key model parameters to the battery's voltage response, allowing you to quantify the expected variance in performance and design more robust systems.",
            "id": "3929174",
            "problem": "You are tasked with modeling the propagation of uncertain parameters in the Equivalent Circuit Model (ECM) of a lithium-ion battery used in second-life applications, to quantify variability in terminal voltage over a specified duty cycle. The ECM for a single Thevenin branch comprises an ohmic resistance, a resistor-capacitor pair, and an open-circuit voltage function. Assume the battery has uncertain parameters due to aging and prior use, and that these uncertainties are independent and uniformly distributed over specified ranges.\n\nStarting from the following base, derive an algorithm and implement it in code:\n\n1. Use the ECM defined by the relations derived from conservation of charge and linear network theory. Let the terminal voltage be given by $V(t) = \\mathrm{OCV}(s(t)) - R_0 I(t) - V_1(t)$, where $R_0$ is the ohmic resistance, $I(t)$ is the applied current (positive for discharge), $s(t)$ is the state of charge (SOC), and $V_1(t)$ is the capacitor branch voltage. The SOC evolves as $s(t+\\Delta t) = s(t) - \\frac{I(t)\\Delta t}{Q}$, where $Q$ is the capacity in Coulombs. The capacitor branch voltage follows $V_1(t+\\Delta t) = V_1(t) \\exp\\!\\left(-\\frac{\\Delta t}{R_1 C_1}\\right) + R_1 \\left(1 - \\exp\\!\\left(-\\frac{\\Delta t}{R_1 C_1}\\right)\\right) I(t)$, where $R_1$ and $C_1$ are the resistor and capacitor values of the Thevenin branch. The open-circuit voltage is approximated locally as a linear function $\\mathrm{OCV}(s) = V_0 + \\alpha (s - s_0)$, where $V_0$ is a nominal voltage, $\\alpha$ is a slope parameter, and $s_0$ is a reference SOC. Clamp $s(t)$ to the interval $[0,1]$ after each update.\n\n2. Treat the ECM parameters $(R_0, R_1, C_1, Q)$ as uncertain and independent, each uniformly distributed over a given interval. Model the propagation of these uncertainties to the output $V(t)$ using a Polynomial Chaos Expansion (PCE) with multivariate Legendre polynomials up to total order $p = 2$. Construct an orthonormal basis with respect to the uniform distribution on $[-1,1]$ for each input variable, using $\\phi_n(x) = \\sqrt{2n+1}\\,P_n(x)$ where $P_n$ are the Legendre polynomials.\n\n3. Use non-intrusive regression (least squares) to compute the PCE coefficients for $V(t)$ at each time step based on a set of i.i.d. samples of the input random variables. In the orthonormal basis, the variance at each time $t_k$ equals the sum of the squares of all non-constant PCE coefficients at that time. Compute the time-averaged variance over the duty cycle as $\\overline{\\mathrm{Var}}(V) = \\frac{1}{T} \\sum_{k=1}^{T} \\mathrm{Var}(V(t_k))$.\n\nAll physical quantities must be handled with appropriate units:\n- $V(t)$, $V_0$ in Volts ($\\mathrm{V}$).\n- $I(t)$ in Amperes ($\\mathrm{A}$).\n- $R_0$, $R_1$ in Ohms ($\\Omega$).\n- $C_1$ in Farads ($\\mathrm{F}$).\n- $Q$ in Coulombs ($\\mathrm{C}$).\n- Time in seconds ($\\mathrm{s}$).\n- The final outputs are time-averaged variances in voltage with units $\\mathrm{V}^2$ and must be expressed as decimal floats.\n\nImplement the algorithm and compute $\\overline{\\mathrm{Var}}(V)$ for the following three test cases. In all cases, use $s_0 = 0.5$, $V_0 = 3.7\\,\\mathrm{V}$, $\\alpha = 0.12\\,\\mathrm{V}$ per unit SOC, and initialize the capacitor branch voltage with $V_1(0) = 0\\,\\mathrm{V}$. Use an orthonormal PCE with total order $p = 2$, and at least $S$ random samples where $S$ is specified per case. Use $T$ time steps with constant step size $\\Delta t$ and piecewise-constant current $I(t_k)$ provided.\n\n- Test Case $1$ (happy path):\n  - Uncertain ranges: $R_0 \\in [0.003, 0.006]\\,\\Omega$, $R_1 \\in [0.002, 0.008]\\,\\Omega$, $C_1 \\in [1500, 3000]\\,\\mathrm{F}$, $Q \\in [9000, 11000]\\,\\mathrm{C}$.\n  - Duty cycle length: $T = 20$ with $\\Delta t = 1\\,\\mathrm{s}$.\n  - Initial SOC: $s(0) = 0.6$.\n  - Current profile (in $\\mathrm{A}$): $[2, -1, 3, 0, 2, -2, 4, 1, -3, 0, 1, -1, 2, 0, -2, 3, -3, 0, 2, -1]$.\n  - Samples: $S = 300$.\n\n- Test Case $2$ (boundary with narrow uncertainty and near-rest segments):\n  - Uncertain ranges: $R_0 \\in [0.0045, 0.005]\\,\\Omega$, $R_1 \\in [0.004, 0.0045]\\,\\Omega$, $C_1 \\in [1800, 1900]\\,\\mathrm{F}$, $Q \\in [10500, 10600]\\,\\mathrm{C}$.\n  - Duty cycle length: $T = 10$ with $\\Delta t = 1\\,\\mathrm{s}$.\n  - Initial SOC: $s(0) = 0.8$.\n  - Current profile (in $\\mathrm{A}$): $[0, 0, 0, 1, -1, 0, 1, -1, 0, 0]$.\n  - Samples: $S = 200$.\n\n- Test Case $3$ (edge case with higher currents and wider uncertainty):\n  - Uncertain ranges: $R_0 \\in [0.002, 0.008]\\,\\Omega$, $R_1 \\in [0.001, 0.010]\\,\\Omega$, $C_1 \\in [1200, 3500]\\,\\mathrm{F}$, $Q \\in [8000, 12000]\\,\\mathrm{C}$.\n  - Duty cycle length: $T = 24$ with $\\Delta t = 0.5\\,\\mathrm{s}$.\n  - Initial SOC: $s(0) = 0.5$.\n  - Current profile (in $\\mathrm{A}$): $[5, -5, 4, -4, 3, -3, 2, -2, 0, 6, -6, 5, -5, 4, -4, 3, -3, 2, -2, 0, 7, -7, 6, -6]$.\n  - Samples: $S = 400$.\n\nYour program should produce a single line of output containing the time-averaged variances for the three test cases, as a comma-separated list enclosed in square brackets, in the order of the cases above, with each value in $\\mathrm{V}^2$ as a decimal float. For example: $[\\text{result1},\\text{result2},\\text{result3}]$.",
            "solution": "The problem is assessed as valid. It is scientifically grounded in standard battery modeling techniques (Equivalent Circuit Model) and uncertainty quantification methods (Polynomial Chaos Expansion). The problem is well-posed, with all necessary parameters, equations, and initial conditions provided to specify a unique computational task. The parameters and conditions are physically realistic for the domain of second-life battery applications.\n\nThe objective is to compute the time-averaged variance of the terminal voltage of a lithium-ion battery over a specified duty cycle, considering that four key parameters of its Equivalent Circuit Model (ECM) are uncertain. The method prescribed is a non-intrusive Polynomial Chaos Expansion (PCE). The solution is developed through the following reasoned steps.\n\n### 1. Equivalent Circuit Model and State-Space Formulation\nThe battery's electrical behavior is described by a first-order Thevenin ECM. The terminal voltage $V(t)$ is given by:\n$$V(t) = \\mathrm{OCV}(s(t)) - R_0 I(t) - V_1(t)$$\nwhere $s(t)$ is the state of charge (SOC), $I(t)$ is the current (positive for discharge), $R_0$ is the ohmic resistance, and $V_1(t)$ is the voltage across the parallel resistor-capacitor ($R_1C_1$) branch.\n\nThe open-circuit voltage (OCV) is a function of SOC, locally approximated by a linear relationship:\n$$\\mathrm{OCV}(s) = V_0 + \\alpha (s - s_0)$$\nwhere $V_0$, $\\alpha$, and $s_0$ are given constants.\n\nThe system's state is described by two variables: the SOC $s(t)$ and the capacitor voltage $V_1(t)$. Their evolution in discrete time with step $\\Delta t$ is governed by the following equations, derived from conservation of charge and the step response of an RC circuit:\n$$s(t_k + \\Delta t) = s(t_k) - \\frac{I(t_k)\\Delta t}{Q}$$\n$$V_1(t_k + \\Delta t) = V_1(t_k) \\exp\\!\\left(-\\frac{\\Delta t}{R_1 C_1}\\right) + R_1 \\left(1 - \\exp\\!\\left(-\\frac{\\Delta t}{R_1 C_1}\\right)\\right) I(t_k)$$\nHere, $t_k = k\\Delta t$ and $I(t_k)$ is the constant current applied over the interval $[t_k, t_k+\\Delta t)$. The SOC is physically constrained to the interval $[0, 1]$.\n\nThe uncertain parameters are the vector $\\vec{\\theta} = [R_0, R_1, C_1, Q]$. Each component $\\theta_i$ is assumed to be an independent random variable uniformly distributed on a specified interval $[a_i, b_i]$.\n\n### 2. Polynomial Chaos Expansion for Uncertainty Propagation\nPCE is a spectral method used to represent a random variable as a series expansion of orthogonal polynomials. The model output, the terminal voltage $V(t)$, becomes a random process due to the uncertain parameters $\\vec{\\theta}$. The core idea is to express $V(t)$ in terms of a standardized set of independent random variables $\\vec{\\xi} = [\\xi_0, \\xi_1, \\xi_2, \\xi_3]$, where each $\\xi_i$ follows a canonical probability distribution. Since our physical parameters $\\theta_i$ are uniform on $[a_i, b_i]$, we map them to standard uniform variables $\\xi_i \\in [-1, 1]$ using the affine transformation:\n$$\\theta_i = \\frac{b_i - a_i}{2} \\xi_i + \\frac{b_i + a_i}{2}$$\nThe terminal voltage is now a function of time and these standard random variables, $V(t, \\vec{\\xi})$. We approximate this function with a truncated PCE of total order $p=2$:\n$$V(t, \\vec{\\xi}) \\approx \\hat{V}(t, \\vec{\\xi}) = \\sum_{j=0}^{N_P-1} c_j(t) \\Psi_j(\\vec{\\xi})$$\nwhere $c_j(t)$ are time-dependent deterministic coefficients and $\\Psi_j(\\vec{\\xi})$ are multivariate orthogonal basis polynomials. The number of basis functions for $d=4$ variables and total order $p=2$ is $N_P = \\frac{(p+d)!}{p!d!} = \\frac{6!}{2!4!} = 15$.\n\nThe basis functions $\\Psi_j(\\vec{\\xi})$ are constructed as products of univariate orthonormal polynomials $\\phi_{\\alpha_i}(\\xi_i)$. For the uniform distribution on $[-1,1]$, the appropriate polynomials are the Legendre polynomials, $P_n(x)$. The orthonormal basis functions are $\\phi_n(x) = \\sqrt{2n+1}P_n(x)$. A multivariate basis function $\\Psi_j(\\vec{\\xi})$ corresponds to a multi-index $\\vec{\\alpha}_j = (\\alpha_{j,0}, \\alpha_{j,1}, \\alpha_{j,2}, \\alpha_{j,3})$ with total degree $|\\vec{\\alpha}_j| = \\sum_i \\alpha_{j,i} \\le p$:\n$$\\Psi_j(\\vec{\\xi}) = \\prod_{i=0}^{3} \\phi_{\\alpha_{j,i}}(\\xi_i) = \\prod_{i=0}^{3} \\sqrt{2\\alpha_{j,i}+1} P_{\\alpha_{j,i}}(\\xi_i)$$\n\n### 3. Non-Intrusive Regression for Coefficient Computation\nThe PCE coefficients $c_j(t)$ are computed using a non-intrusive regression method. This approach treats the ECM simulation as a \"black box\" model, which we query at specific points in the random input space. The procedure is as follows:\n1.  **Sampling**: Generate $S$ independent and identically distributed (i.i.d.) samples $\\vec{\\xi}^{(1)}, \\dots, \\vec{\\xi}^{(S)}$ from the 4-dimensional standard uniform distribution on $[-1,1]^4$.\n2.  **Model Evaluation**: For each sample $\\vec{\\xi}^{(i)}$, compute the corresponding physical parameters $\\vec{\\theta}^{(i)}$ and run the full time-domain ECM simulation. This yields $S$ trajectories of the terminal voltage, $V^{(i)}(t_k)$ for $k=0, \\dots, T-1$.\n3.  **Linear System Formulation**: At each time step $t_k$, we have a set of $S$ input-output pairs $(\\vec{\\xi}^{(i)}, V^{(i)}(t_k))$. We can write the PCE approximation for all samples in a matrix form: $\\mathbf{Y}_k \\approx \\mathbf{\\Phi} \\mathbf{c}_k$, where:\n    *   $\\mathbf{Y}_k$ is a vector of size $S$ containing the model outputs $V^{(i)}(t_k)$.\n    *   $\\mathbf{\\Phi}$ is the $S \\times N_P$ design matrix, where each element $\\Phi_{ij} = \\Psi_j(\\vec{\\xi}^{(i)})$ is the evaluation of the $j$-th basis function at the $i$-th sample point.\n    *   $\\mathbf{c}_k$ is the vector of the $N_P$ unknown PCE coefficients at time $t_k$.\n4.  **Least-Squares Solution**: Since the number of samples $S$ is chosen to be greater than the number of coefficients $N_P$, the system is overdetermined. The coefficients $\\mathbf{c}_k$ are found by solving the linear least-squares problem, which minimizes the squared error $||\\mathbf{Y}_k - \\mathbf{\\Phi} \\mathbf{c}_k||_2^2$. The solution is given by $\\mathbf{c}_k = (\\mathbf{\\Phi}^T \\mathbf{\\Phi})^\\dagger \\mathbf{\\Phi}^T \\mathbf{Y}_k$, where $\\dagger$ denotes the Moore-Penrose pseudoinverse.\n\n### 4. Variance Calculation\nA key advantage of using an orthonormal basis is the simplified calculation of statistical moments. The expected value (mean) of the model output is simply the first coefficient, corresponding to the constant basis function $\\Psi_0=1$:\n$$\\mathbb{E}[V(t_k)] \\approx c_0(t_k)$$\nThe variance is the sum of the squares of all other coefficients:\n$$\\mathrm{Var}(V(t_k)) = \\mathbb{E}[(V(t_k)-\\mathbb{E}[V(t_k)])^2] \\approx \\sum_{j=1}^{N_P-1} c_j(t_k)^2$$\nThe final required quantity is the time-averaged variance, calculated over the $T$ time steps of the duty cycle:\n$$\\overline{\\mathrm{Var}}(V) = \\frac{1}{T} \\sum_{k=0}^{T-1} \\mathrm{Var}(V(t_k))$$\n\n### 5. Algorithmic Implementation\nThe algorithm proceeds as follows for each test case:\n1.  Initialize constants ($V_0, \\alpha, s_0, p=2$) and test-case-specific parameters (parameter ranges, initial SOC, duty cycle details). Set a random seed for reproducibility.\n2.  Generate $S$ samples of the 4-dimensional standard uniform random vector $\\vec{\\xi}$.\n3.  Generate the multi-indices $\\vec{\\alpha}_j$ for $d=4$ and $p=2$. There are $N_P=15$ such indices.\n4.  Construct the $S \\times 15$ design matrix $\\mathbf{\\Phi}$ by evaluating the 15 multivariate orthonormal Legendre polynomials at each of the $S$ samples of $\\vec{\\xi}$.\n5.  Initialize an $S \\times T$ matrix to store the results of the Monte Carlo simulations.\n6.  Loop $S$ times:\n    a. For the current sample $\\vec{\\xi}^{(i)}$, transform it to the physical parameter set $\\vec{\\theta}^{(i)} = [R_0, R_1, C_1, Q]^{(i)}$.\n    b. Run the ECM simulation for $T$ time steps using $\\vec{\\theta}^{(i)}$ and the given current profile. Store the resulting $T$ voltage values in the results matrix.\n7.  Initialize an array to store the variance at each time step.\n8.  Loop $T$ times (for each time step $k=0, \\dots, T-1$):\n    a. Extract the vector of $S$ voltage outputs at this time step, $\\mathbf{Y}_k$.\n    b. Solve the linear least-squares system $\\mathbf{Y}_k \\approx \\mathbf{\\Phi} \\mathbf{c}_k$ for the coefficient vector $\\mathbf{c}_k$.\n    c. Calculate the variance at this step by summing the squares of the coefficients from the second to the last, $\\sum_{j=1}^{14} c_{j,k}^2$. Store this value.\n9.  Compute the mean of the stored variances to obtain the final time-averaged variance $\\overline{\\mathrm{Var}}(V)$.\nThis process is repeated for each of the three test cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre\n\ndef get_multi_indices(d, p_total):\n    \"\"\"\n    Generates multi-indices for multivariate polynomials of d variables\n    up to a total polynomial order p_total.\n    \"\"\"\n    if d == 1:\n        return [[i] for i in range(p_total + 1)]\n    \n    indices = []\n    for i in range(p_total + 1):\n        sub_indices = get_multi_indices(d - 1, p_total - i)\n        for sub_index in sub_indices:\n            indices.append([i] + sub_index)\n    return indices\n\ndef build_pce_design_matrix(xi_samples, multi_indices, p_order):\n    \"\"\"\n    Builds the PCE design matrix Phi from samples of standard variables.\n    \"\"\"\n    S, d = xi_samples.shape\n    num_coeffs = len(multi_indices)\n    \n    # Pre-compute Legendre polynomials and normalization factors\n    polys = [legendre(i) for i in range(p_order + 1)]\n    ortho_factors = np.sqrt(2 * np.arange(p_order + 1) + 1)\n    \n    Phi = np.ones((S, num_coeffs))\n\n    # Pre-evaluate polynomial values for all samples to speed up computation\n    # poly_evals[deg, dim, sample_idx]\n    poly_evals = np.array([[polys[deg](xi_samples[:, i]) for i in range(d)] for deg in range(p_order + 1)])\n    \n    for k, idx in enumerate(multi_indices):\n        # The first index (0,0,0,0) results in a column of ones, handled by initialization.\n        if k == 0:\n            continue\n        \n        term_product = np.ones(S)\n        for i in range(d):\n            poly_degree = idx[i]\n            # phi_n(x) = sqrt(2n+1) * Pn(x)\n            term_product *= ortho_factors[poly_degree] * poly_evals[poly_degree, i, :]\n        Phi[:, k] = term_product\n        \n    return Phi\n\ndef run_ecm_simulation(params, T, dt, I_profile, s_init, v1_init, V0, alpha, s0):\n    \"\"\"\n    Runs a time-domain simulation of the ECM for a single parameter set.\n    \"\"\"\n    R0, R1, C1, Q = params\n    \n    s_current = s_init\n    v1_current = v1_init\n    V_out_series = np.zeros(T)\n\n    # Avoid division by zero if R1 or C1 is zero.\n    tau = R1 * C1\n    exp_term = np.exp(-dt / tau) if tau > 0 else 0.0\n\n    for k in range(T):\n        I_k = I_profile[k]\n\n        # Calculate terminal voltage at current time step t_k\n        ocv = V0 + alpha * (s_current - s0)\n        v_terminal = ocv - R0 * I_k - v1_current\n        V_out_series[k] = v_terminal\n\n        # Update state for next time step t_{k+1}\n        s_next = s_current - (I_k * dt) / Q\n        s_next = np.clip(s_next, 0.0, 1.0) # Clamp SOC\n        \n        v1_next = v1_current * exp_term + R1 * (1 - exp_term) * I_k\n\n        # Advance to the next state\n        s_current = s_next\n        v1_current = v1_next\n        \n    return V_out_series\n\ndef solve_case(case_data):\n    \"\"\"\n    Solves a single test case for the time-averaged voltage variance.\n    \"\"\"\n    param_ranges = case_data['ranges']\n    T = case_data['T']\n    dt = case_data['dt']\n    I_profile = case_data['I']\n    s_init = case_data['s_init']\n    S = case_data['S']\n\n    # Shared constants\n    V0 = 3.7\n    alpha = 0.12\n    s0 = 0.5\n    v1_init = 0.0\n    p_order = 2\n    d = 4 # Number of uncertain parameters\n\n    # For reproducibility of sampling\n    np.random.seed(42)\n\n    # Step 1: Generate samples in standard uniform space [-1, 1]\n    xi_samples = np.random.uniform(-1, 1, size=(S, d))\n\n    # Step 2: Transform samples to physical parameter space\n    theta_samples = np.zeros_like(xi_samples)\n    for i, (a, b) in enumerate(param_ranges):\n        theta_samples[:, i] = (b - a) / 2.0 * xi_samples[:, i] + (b + a) / 2.0\n    \n    # Step 3: Build PCE design matrix\n    multi_indices = get_multi_indices(d, p_order)\n    Phi = build_pce_design_matrix(xi_samples, multi_indices, p_order)\n\n    # Step 4: Run Monte Carlo simulations\n    V_mc_results = np.zeros((S, T))\n    for i in range(S):\n        V_mc_results[i, :] = run_ecm_simulation(\n            params=theta_samples[i, :],\n            T=T, dt=dt, I_profile=I_profile, s_init=s_init,\n            v1_init=v1_init, V0=V0, alpha=alpha, s0=s0\n        )\n\n    # Step 5: Compute PCE coefficients and variance for each time step\n    variances_over_time = np.zeros(T)\n    for k in range(T):\n        Y_k = V_mc_results[:, k]\n        # Solve for coefficients using least squares\n        coeffs, _, _, _ = np.linalg.lstsq(Phi, Y_k, rcond=None)\n        # Variance is the sum of squares of non-constant coefficients\n        variances_over_time[k] = np.sum(coeffs[1:]**2)\n    \n    # Step 6: Compute time-averaged variance\n    avg_variance = np.mean(variances_over_time)\n    return avg_variance\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the solution for all test cases.\n    \"\"\"\n    test_cases = [\n        { # Test Case 1\n            'ranges': [(0.003, 0.006), (0.002, 0.008), (1500, 3000), (9000, 11000)],\n            'T': 20, 'dt': 1.0, 's_init': 0.6, 'S': 300,\n            'I': np.array([2, -1, 3, 0, 2, -2, 4, 1, -3, 0, 1, -1, 2, 0, -2, 3, -3, 0, 2, -1]),\n        },\n        { # Test Case 2\n            'ranges': [(0.0045, 0.005), (0.004, 0.0045), (1800, 1900), (10500, 10600)],\n            'T': 10, 'dt': 1.0, 's_init': 0.8, 'S': 200,\n            'I': np.array([0, 0, 0, 1, -1, 0, 1, -1, 0, 0]),\n        },\n        { # Test Case 3\n            'ranges': [(0.002, 0.008), (0.001, 0.010), (1200, 3500), (8000, 12000)],\n            'T': 24, 'dt': 0.5, 's_init': 0.5, 'S': 400,\n            'I': np.array([5, -5, 4, -4, 3, -3, 2, -2, 0, 6, -6, 5, -5, 4, -4, 3, -3, 2, -2, 0, 7, -7, 6, -6]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}