{
    "hands_on_practices": [
        {
            "introduction": "本次练习将指导您完成任何可靠DFT计算中的一个关键步骤：收敛性测试。我们将以计算层状材料的剥离能为例，这是一个对于石墨烯或过渡金属硫化物（TMDs）等二维电极材料非常重要的物理量。通过系统地评估真空层间距和$k$点取样等模拟参数的影响，您将学习如何确保计算出的能量具有物理意义，而不是数值近似带来的假象 。",
            "id": "3904861",
            "problem": "您正在设计一个自动化程序，用于从密度泛函理论（DFT）的板层计算中提取层状电极材料的单位面积剥离能，并评估其相对于层间真空间距和倒易空间采样的收敛性。请从以下基本依据出发：(i) 密度泛函理论（DFT）的基态能量是一个变分量，通过在电子密度上最小化 Kohn–Sham 能量泛函得到；(ii) 将一个束缚构型分离成无相互作用的片段所需的可逆功等于它们基态能量的差值；(iii) 周期性边界条件和离散的布里渊区采样会引入系统误差，这些误差会随着真空层的增加和采样的加密而衰减。请利用这些依据推导出双层相对于两个孤立单层的单位面积剥离能，并设计收敛性判据。\n\n假设一个层状电极材料由周期性板层表示，其层间真空厚度为 $L$（单位为 $\\text{\\AA}$），并采用大小为 $(k_x,k_y,k_z)$ 的均匀 $k$ 点网格，总点数为 $N = k_x k_y k_z$。设原胞表面积为 $A$（单位为 $\\text{\\AA}^2$）。记无限真空、无限密集 $k$ 点的单层能量为 $E_m^0$（单位为 $\\text{eV}$），相应的双层能量为 $E_b^0$（单位为 $\\text{eV}$）。对于有限的 $L$ 和有限的 $N$，将计算出的单层和双层能量中的主要误差建模为经过充分检验的衰减形式：\n$$\\Delta E_{\\text{vac}}(L) = \\frac{c}{L^3}, \\quad \\Delta E_{k}(N) = \\frac{d}{N^p},$$\n其中 $c$ 和 $d$ 是正常数（单位分别为 $\\text{eV}\\cdot \\text{\\AA}^3$ 和 $\\text{eV}$），指数 $p > 1$。因此，计算出的单层和双层能量为：\n$$E_m(L,N) = E_m^0 + \\frac{c_m}{L^3} + \\frac{d_m}{N^p}, \\quad E_b(L,N) = E_b^0 + \\frac{c_b}{L^3} + \\frac{d_b}{N^p}.$$\n根据可逆功和无相互作用片段能量可加性的第一性原理，仅使用计算出的总能量 $E_m(L,N)$ 和 $E_b(L,N)$ 以及表面积 $A$，构建单位面积剥离能的公式并进行数值实现。剥离能必须以焦耳/平方米为单位表示，并四舍五入保留三位小数。\n\n收敛性评估必须沿着每个数值轴分开进行：\n- 固定 $k$ 网格的真空收敛性：使用更密集的 $k$ 网格，比较在 $L_1$ 和 $L_2$ 处计算的剥离能，如果绝对差值低于给定的容差 $\\tau_{\\text{vac}}$（单位为 $\\text{J}/\\text{m}^2$），则宣布收敛。\n- 固定 $L$ 的 $k$ 点收敛性：使用更大的真空层 $L$，比较在 $N_1$ 和 $N_2$ 处计算的剥离能，如果绝对差值低于给定的容差 $\\tau_{k}$（单位为 $\\text{J}/\\text{m}^2$），则宣布收敛。\n\n请使用以下科学上合理且自洽的参数、常数和测试套件。所有量均需严格按照规定处理：\n- 物理常数和材料参数：\n  - 表面积 $A = 8.0$ $\\text{\\AA}^2$。\n  - 无限极限单层能量 $E_m^0 = -100.0$ $\\text{eV}$。\n  - 无限极限双层能量 $E_b^0 = -200.17475$ $\\text{eV}$。\n  - 真空误差系数 $c_m = 0.25$ $\\text{eV}\\cdot \\text{\\AA}^3$, $c_b = 0.35$ $\\text{eV}\\cdot \\text{\\AA}^3$。\n  - $k$ 点误差系数 $d_m = 0.03$ $\\text{eV}$, $d_b = 0.045$ $\\text{eV}$，以及指数 $p = 1.2$。\n  - 从电子伏特/平方埃到焦耳/平方米的单位转换因子：$u = 16.0218$。\n\n- 三个测试用例组成的测试套件。对于每个用例，给定 $(L_1,L_2)$, $(k_x^{(1)},k_y^{(1)},k_z^{(1)})$, $(k_x^{(2)},k_y^{(2)},k_z^{(2)})$, $\\tau_{\\text{vac}}$ 和 $\\tau_k$。您必须：\n  1. 计算在 $(L_2,(k_x^{(2)},k_y^{(2)},k_z^{(2)}))$ 条件下的剥离能（单位为 $\\text{J}/\\text{m}^2$），四舍五入到三位小数。\n  2. 在更密集的 $k$ 网格 $(k_x^{(2)},k_y^{(2)},k_z^{(2)})$ 和容差 $\\tau_{\\text{vac}}$ 下，使用 $(L_1,L_2)$ 评估真空收敛性。\n  3. 在更大的真空层 $L_2$ 和容差 $\\tau_k$ 下，使用 $(k_x^{(1)},k_y^{(1)},k_z^{(1)})$, $(k_x^{(2)},k_y^{(2)},k_z^{(2)})$ 评估 $k$ 点收敛性。\n\n  用例如下：\n  - 用例 1: $(L_1,L_2) = (12,16)$, $(k_x^{(1)},k_y^{(1)},k_z^{(1)}) = (9,9,1)$, $(k_x^{(2)},k_y^{(2)},k_z^{(2)}) = (12,12,1)$, $\\tau_{\\text{vac}} = 0.001$, $\\tau_k = 0.001$。\n  - 用例 2: $(L_1,L_2) = (6,8)$, $(k_x^{(1)},k_y^{(1)},k_z^{(1)}) = (3,3,1)$, $(k_x^{(2)},k_y^{(2)},k_z^{(2)}) = (6,6,1)$, $\\tau_{\\text{vac}} = 0.0005$, $\\tau_k = 0.001$。\n  - 用例 3: $(L_1,L_2) = (20,24)$, $(k_x^{(1)},k_y^{(1)},k_z^{(1)}) = (18,18,1)$, $(k_x^{(2)},k_y^{(2)},k_z^{(2)}) = (21,21,1)$, $\\tau_{\\text{vac}} = 0.0002$, $\\tau_k = 0.0002$。\n\n您的程序必须实现上述模型，计算每个用例在 $(L_2,(k_x^{(2)},k_y^{(2)},k_z^{(2)}))$ 条件下的剥离能，测试两个收敛性判据，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个用例，输出必须包括剥离能值（单位为 $\\text{J}/\\text{m}^2$，四舍五入到三位小数）、真空收敛性布尔值和 $k$ 点收敛性布尔值，按用例顺序扁平化为一个列表，例如 $[e_1,b_{1,\\text{vac}},b_{1,k},e_2,b_{2,\\text{vac}},b_{2,k},e_3,b_{3,\\text{vac}},b_{3,k}]$，其中 $e_i$ 是浮点数，$b_{i,\\cdot}$ 是布尔值。",
            "solution": "该问题要求构建并实现一个程序，用以计算层状材料的剥离能并评估其关于模拟参数的数值收敛性。推导过程基于密度泛函理论（DFT）和热力学原理。\n\n将双层材料剥离成两个不相互作用的单层是一个物理过程，其特征可以通过所需的可逆功来描述。根据基本热力学原理，这个功等于系统基态能量的变化。设 $E_b$ 为双层的基态能量，$E_m$ 为单个单层的基态能量。初始状态是双层，能量为 $E_b$。最终状态是两个分离的、不相互作用的单层，总能量为 $2E_m$。因此，剥离能 $E_{\\text{exf}}$ 为：\n$$E_{\\text{exf}} = E_{\\text{final}} - E_{\\text{initial}} = 2E_m - E_b$$\n对于一个稳定束缚的双层结构，$E_b  2E_m$，这使得 $E_{\\text{exf}}$ 为正值，代表分离所需的能量成本。问题要求的是单位面积的剥离能 $e_{\\text{exf}}$，可以通过除以原胞的表面积 $A$ 得到：\n$$e_{\\text{exf}} = \\frac{E_{\\text{exf}}}{A} = \\frac{2E_m - E_b}{A}$$\n在实践中，DFT计算是使用有限的数值参数进行的，这会引入系统误差。问题给出了计算出的单层能量 $E_m(L, N)$ 和双层能量 $E_b(L, N)$ 作为层间真空间距 $L$ 和总 $k$ 点数 $N$ 的函数模型。这些模型是：\n$$E_m(L,N) = E_m^0 + \\frac{c_m}{L^3} + \\frac{d_m}{N^p}$$\n$$E_b(L,N) = E_b^0 + \\frac{c_b}{L^3} + \\frac{d_b}{N^p}$$\n在这里，$E_m^0$ 和 $E_b^0$ 是在无限真空和无限密集 $k$ 点采样极限下的真实基态能量。与 $L^{-3}$ 成正比的项模拟了板层周期性镜像之间虚假的静电相互作用，而与 $N^{-p}$ 成正比的项模拟了布里渊区积分离散化带来的误差。\n\n将这些表达式代入单位面积剥离能的公式中，得到：\n$$e_{\\text{exf}}(L, N) = \\frac{1}{A} \\left[ 2 \\left( E_m^0 + \\frac{c_m}{L^3} + \\frac{d_m}{N^p} \\right) - \\left( E_b^0 + \\frac{c_b}{L^3} + \\frac{d_b}{N^p} \\right) \\right]$$\n这个表达式可以通过将理想能量项和误差贡献项分组来重新整理：\n$$e_{\\text{exf}}(L, N) = \\frac{1}{A} \\left[ (2E_m^0 - E_b^0) + (2c_m - c_b)\\frac{1}{L^3} + (2d_m - d_b)\\frac{1}{N^p} \\right]$$\n第一项 $(2E_m^0 - E_b^0)/A$ 代表真实的物理剥离能。随后的项代表了由于有限真空和 $k$ 点采样而产生的剥离能总数值误差。最终结果必须通过乘以给定的单位转换因子 $u = 16.0218$，从电子伏特/平方埃（$\\text{eV}/\\text{\\AA}^2$）转换为焦耳/平方米（$\\text{J}/\\text{m}^2$）。计算所需单位的剥离能的完整公式为：\n$$e_{\\text{exf, J/m^2}}(L, N) = u \\cdot e_{\\text{exf}}(L, N) = \\frac{u}{A} \\left[ (2E_m^0 - E_b^0) + \\frac{2c_m - c_b}{L^3} + \\frac{2d_m - d_b}{N^p} \\right]$$\n为确保计算能量的可靠性，我们必须评估其收敛性。问题指定了两个独立的收敛性检查。\n\n1.  **真空收敛性**：此测试评估结果对真空间距 $L$ 的敏感性。它在固定的、密集的 $k$ 点网格（$N_2 = k_x^{(2)}k_y^{(2)}k_z^{(2)}$）下进行，通过比较在两个不同真空间距 $L_1$ 和 $L_2$ 下计算的剥离能。计算其绝对差值：\n    $$\\Delta_{\\text{vac}} = |e_{\\text{exf, J/m^2}}(L_2, N_2) - e_{\\text{exf, J/m^2}}(L_1, N_2)|$$\n    如果此差值低于指定的容差 $\\tau_{\\text{vac}}$，即 $\\Delta_{\\text{vac}}  \\tau_{\\text{vac}}$，则认为已达到收敛。\n\n2.  **$k$ 点收敛性**：此测试评估对倒易空间网格密度的敏感性。它在固定的、较大的真空间距（$L_2$）下进行，通过比较使用两个不同 $k$ 点网格（总点数分别为 $N_1 = k_x^{(1)}k_y^{(1)}k_z^{(1)}$ 和 $N_2$）计算的能量。其绝对差值为：\n    $$\\Delta_{k} = |e_{\\text{exf, J/m^2}}(L_2, N_2) - e_{\\text{exf, J/m^2}}(L_2, N_1)|$$\n    如果此差值低于其容差 $\\tau_k$，即 $\\Delta_k  \\tau_k$，则认为已达到收敛。\n\n数值实现将涉及创建一个函数，该函数使用给定参数计算 $e_{\\text{exf, J/m^2}}(L, N)$。然后，为每个测试用例调用此函数，并使用适当的参数来计算在 $(L_2, N_2)$ 下的目标剥离能，执行两个收敛性检查，并按规定格式化结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating exfoliation energy and its convergence\n    for a layered material based on a DFT model.\n    \"\"\"\n\n    # Physical constants and material parameters\n    A = 8.0  # Surface area in Å^2\n    E_m0 = -100.0  # Infinite-limit monolayer energy in eV\n    E_b0 = -200.17475  # Infinite-limit bilayer energy in eV\n    c_m = 0.25  # Monolayer vacuum error coefficient in eV*Å^3\n    c_b = 0.35  # Bilayer vacuum error coefficient in eV*Å^3\n    d_m = 0.03  # Monolayer k-point error coefficient in eV\n    d_b = 0.045  # Bilayer k-point error coefficient in eV\n    p = 1.2  # k-point error exponent\n    u = 16.0218  # Conversion factor from eV/Å^2 to J/m^2\n\n    # Pre-calculate constant terms for the exfoliation energy expression\n    E_exf0_term = 2 * E_m0 - E_b0\n    c_exf_term = 2 * c_m - c_b\n    d_exf_term = 2 * d_m - d_b\n    u_over_A = u / A\n\n    def calculate_exfoliation_energy(L, N):\n        \"\"\"\n        Calculates the exfoliation energy per area in J/m^2 for a given\n        vacuum spacing L and total number of k-points N.\n        \n        Args:\n            L (float): Interlayer vacuum thickness in Å.\n            N (int): Total number of k-points.\n\n        Returns:\n            float: Exfoliation energy in J/m^2.\n        \"\"\"\n        energy_ev_per_a2 = (E_exf0_term + \n                              c_exf_term / (L**3) + \n                              d_exf_term / (N**p))\n        \n        return u_over_A * energy_ev_per_a2\n\n    # Test suite of cases\n    test_cases = [\n        {'L': (12, 16), 'k': ((9, 9, 1), (12, 12, 1)), 'tau_vac': 0.001, 'tau_k': 0.001},\n        {'L': (6, 8), 'k': ((3, 3, 1), (6, 6, 1)), 'tau_vac': 0.0005, 'tau_k': 0.001},\n        {'L': (20, 24), 'k': ((18, 18, 1), (21, 21, 1)), 'tau_vac': 0.0002, 'tau_k': 0.0002},\n    ]\n\n    results = []\n    for case in test_cases:\n        L1, L2 = case['L']\n        k1_dims, k2_dims = case['k']\n        tau_vac, tau_k = case['tau_vac'], case['tau_k']\n\n        N1 = k1_dims[0] * k1_dims[1] * k1_dims[2]\n        N2 = k2_dims[0] * k2_dims[1] * k2_dims[2]\n\n        # 1. Compute the exfoliation energy at (L2, N2)\n        e_target = calculate_exfoliation_energy(L2, N2)\n        e_rounded = round(e_target, 3)\n\n        # 2. Assess vacuum convergence at the denser k-grid (N2)\n        e_vac_ref = calculate_exfoliation_energy(L1, N2)\n        delta_vac = abs(e_target - e_vac_ref)\n        is_vac_converged = delta_vac  tau_vac\n\n        # 3. Assess k-point convergence at the larger vacuum (L2)\n        e_k_ref = calculate_exfoliation_energy(L2, N1)\n        delta_k = abs(e_target - e_k_ref)\n        is_k_converged = delta_k  tau_k\n        \n        results.extend([e_rounded, is_vac_converged, is_k_converged])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "DFT计算提供了丰富的数据，但要从中提取物理洞见则需要仔细的分析。本练习专注于识别许多电极材料中一种关键的准粒子——小极化子，它是一种与晶格畸变耦合的局域化载流子。您将开发一种结合了电荷密度和局部键长信息的定量诊断方法，以确认极化子的形成，这是影响电导率和电池性能的关键因素 。",
            "id": "3904815",
            "problem": "您的任务是设计并实现一种程序化诊断方法，使用密度泛函理论 (DFT) 来确认电极材料中的小极化子局域化。该诊断方法必须基于这样一个物理图像：晶体中的局域电荷会产生空间上集中的电子密度变化，并引发局域结构畸变。该任务必须从以下基本基础开始：Kohn-Sham 密度泛函理论 (DFT) 定义了相互作用电子体系的基态电子密度 $\\rho(\\mathbf{r})$；一个电子的加入或移除会产生一个变化 $\\Delta \\rho(\\mathbf{r}) = \\rho_{\\text{charged}}(\\mathbf{r}) - \\rho_{\\text{neutral}}(\\mathbf{r})$。小极化子是一种准粒子，由局域在少数原子位点上的电荷以及由电子-声子耦合引起的局域晶格畸变共同构成。从这个基础出发，推导出一个数学上精确的诊断方法，该方法结合了电荷密度差的空间局域化度量和局域畸变幅度度量。将此诊断方法在一个程序中实现，该程序接受离散数据，并为每个案例输出一个指示极化子是否局域化的布尔值。\n\n您将使用一种离散近似方法，其中域被划分为 $N$ 个不相交的盆或单元 $\\{\\Omega_i\\}_{i=1}^N$。每个单元的电荷差定义为 $\\Delta q_i = \\int_{\\Omega_i} \\Delta \\rho(\\mathbf{r})\\,\\mathrm{d}^3 r$，以电子为单位。由于电子（$\\Delta q_i > 0$）和空穴（$\\Delta q_i  0$）极化子都可能存在，您的局域化度量必须依赖于 $|\\Delta q_i|$。您还被给予了参考（未畸变）结构和弛豫（畸变）结构中候选极化子位点周围的局域键长。键长以埃为单位提供，并且必须始终按此处理。\n\n您推导出的诊断方法必须使用以下阈值为每个测试案例产生一个布尔决策，您必须将这些阈值应用于您推导出的度量，而不能跳过其推导过程：\n- 电荷局域化的有效位点数必须小于或等于 $S_{\\mathrm{max}} = 3.0$。\n- 平均局域键长畸变幅度必须大于或等于 $D_{\\mathrm{min}} = 0.02$。\n\n不涉及角度。键长以埃为单位。根据构造，畸变是无量纲的。每个测试案例的最终输出必须是一个布尔值，指示根据您推导出的度量，这两个条件是否都满足。\n\n您的程序必须为以下测试套件实现该诊断方法。每个测试案例提供 $(N, \\{\\Delta q_i\\}_{i=1}^N, \\{d^{(0)}_j\\}_{j=1}^M, \\{d_j\\}_{j=1}^M)$，其中 $N$ 是单元数，$\\Delta q_i$ 是每个单元的电荷差（以电子为单位），$d^{(0)}_j$ 是参考键长（以埃为单位），$d_j$ 是弛豫后的键长（以埃为单位）。所有案例的键数 $M$ 均为 $6$。\n\n- 案例 A (理想情况：具有显著畸变的局域化电子极化子)：$N = 12$, $\\{\\Delta q_i\\} = [\\,0.02, 0.01, 0.01, 0.02, 0.02, 0.80, 0.06, 0.02, 0.01, 0.00, 0.00, 0.01\\,]$, $\\{d^{(0)}_j\\} = [\\,2.00, 2.00, 2.00, 2.00, 2.00, 2.00\\,]$ 埃, $\\{d_j\\} = [\\,2.10, 2.06, 1.94, 1.95, 2.00, 2.00\\,]$ 埃。\n- 案例 B (具有极小畸变的离域电荷)：$N = 12$, $\\{\\Delta q_i\\} = [\\,0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083\\,]$, $\\{d^{(0)}_j\\} = [\\,2.00, 2.00, 2.00, 2.00, 2.00, 2.00\\,]$ 埃, $\\{d_j\\} = [\\,2.01, 2.01, 1.99, 1.99, 2.00, 2.00\\,]$ 埃。\n- 案例 C (具有显著畸变的局域化空穴极化子)：$N = 12$, $\\{\\Delta q_i\\} = [\\,-0.02, -0.01, -0.01, -0.02, -0.02, -0.75, -0.08, -0.03, -0.02, 0.00, 0.00, -0.01\\,]$, $\\{d^{(0)}_j\\} = [\\,2.00, 2.00, 2.00, 2.00, 2.00, 2.00\\,]$ 埃, $\\{d_j\\} = [\\,1.90, 1.95, 2.06, 2.05, 2.00, 2.00\\,]$ 埃。\n- 案例 D (密度局域化处于临界状态但畸变不足)：$N = 12$, $\\{\\Delta q_i\\} = [\\,0.02, 0.01, 0.01, 0.02, 0.02, 0.80, 0.06, 0.02, 0.01, 0.00, 0.00, 0.01\\,]$, $\\{d^{(0)}_j\\} = [\\,2.00, 2.00, 2.00, 2.00, 2.00, 2.00\\,]$ 埃, $\\{d_j\\} = [\\,2.01, 2.00, 1.99, 2.00, 2.00, 2.00\\,]$ 埃。\n- 案例 E (具有中等畸变的双位点极化子)：$N = 12$, $\\{\\Delta q_i\\} = [\\,0.00, 0.00, 0.00, 0.48, 0.48, 0.01, 0.01, 0.00, 0.00, 0.00, 0.00, 0.00\\,]$, $\\{d^{(0)}_j\\} = [\\,2.00, 2.00, 2.00, 2.00, 2.00, 2.00\\,]$ 埃, $\\{d_j\\} = [\\,2.08, 2.06, 1.94, 1.94, 2.00, 2.00\\,]$ 埃。\n\n您的程序必须：\n- 从第一性原理推导，将 $\\{|\\Delta q_i|\\}$ 归一化为 $N$ 个单元上的离散概率分布，一个基于此分布的数学上合理的局域化指数，以及一个基于所提供键长的畸变度量。\n- 通过检查推导出的有效作用范围大小是否小于或等于 $S_{\\mathrm{max}}$ 以及推导出的平均畸变是否大于或等于 $D_{\\mathrm{min}}$，来为每个案例确定极化子局域化（布尔值）。\n- 生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[\\,\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D,\\text{result}_E\\,]$。\n\n每个案例的最终输出类型是一个布尔值。键长必须以埃为单位处理。畸变必须是无量纲的。不涉及角度。程序不得读取外部文件或接受输入，并且必须仅对提供的测试套件进行操作。",
            "solution": "问题陈述已经过分析，并被认为是有效的。它在科学上基于密度泛函理论的原理和小极化子的物理学。该问题是适定的，提供了一套自洽的数据和明确的目标，要求从第一性原理推导具有物理意义的度量。语言是客观的，提供的数值数据在物理上是合理的。任务是推导并应用一种诊断方法，这在计算材料科学中构成了一个非平凡但可解的问题。\n\n目标是基于两个标准构建一个定量的小极化子局域化诊断方法：电荷密度差 $\\Delta\\rho(\\mathbf{r})$ 的空间局域化，以及相关局域晶格畸变的幅度。我们被给予了电荷和键长的离散数据，并且必须为几个测试案例产生一个布尔决策。\n\n首先，我们推导电荷局域化的度量。问题提供了 $N$ 个离散单元内的净电荷差 $\\Delta q_i$，其中 $\\Delta q_i = \\int_{\\Omega_i} \\Delta \\rho(\\mathbf{r})\\,\\mathrm{d}^3 r$。一个局域化的极化子意味着大部分的过剩电荷（对于电子极化子，$\\sum_i \\Delta q_i \\approx +1$）或电荷亏损（对于空穴极化子，$\\sum_i \\Delta q_i \\approx -1$）集中在少数几个单元中。为了创建一个适用于电子和空穴极化子的通用度量，我们必须使用电荷差的绝对值 $|\\Delta q_i|$。\n\n我们可以将电荷变化幅度的分布概念化为一个离散概率分布。让我们为每个单元 $i=1, \\dots, N$ 定义一组非负权重 $w_i = |\\Delta q_i|$。为了形成一个概率分布 $\\{p_i\\}$，我们将这些权重归一化：\n$$\np_i = \\frac{w_i}{\\sum_{k=1}^N w_k} = \\frac{|\\Delta q_i|}{\\sum_{k=1}^N |\\Delta q_k|}\n$$\n这个量 $p_i$ 代表在单元 $i$ 中发生的总电荷再分布幅度的分数。根据构造，$p_i \\ge 0$ 且 $\\sum_{i=1}^N p_i = 1$。\n\n高度局域化的电荷分布对应于一个急剧峰化的概率分布，而离域电荷对应于一个类均匀分布。一种量化分布局域化程度的标准且具有物理意义的方法是通过其信息熵。分布 $\\{p_i\\}$ 的香农熵由以下公式给出：\n$$\nH = -\\sum_{i=1}^N p_i \\ln p_i\n$$\n其中如果 $p_i=0$，则 $p_i \\ln p_i$ 项取为 $0$。对于一个所有电荷都在一个单元中的完全局域化分布（某个 $k$ 使得 $p_k=1$，而 $p_{i \\ne k}=0$），熵 $H$ 是最小的（$H=0$）。对于一个电荷均匀分布在所有 $N$ 个单元中的完全离域化分布（对所有 $i$，$p_i=1/N$），熵是最大的（$H=\\ln N$）。\n\n为了将此熵解释为电荷分布的“有效位点数”，我们将局域化指数 $S$ 定义为熵的指数：\n$$\nS = \\exp(H) = \\exp\\left(-\\sum_{i=1}^N p_i \\ln p_i\\right)\n$$\n这个量，有时被称为困惑度或有效模式数，其范围从 $S=1$（在单个位点上的完美局域化）到 $S=N$（在 $N$ 个位点上的完美离域化）。极化子局域化的第一个条件是，这个有效位点数必须低于给定的阈值 $S_{\\mathrm{max}}$：\n$$\nS \\le S_{\\mathrm{max}} = 3.0\n$$\n\n其次，我们推导局域晶格畸变的度量。我们被给予了 $M$ 个参考键长 $\\{d_j^{(0)}\\}_{j=1}^M$ 和在弛豫（带电）结构中相应的键长 $\\{d_j\\}_{j=1}^M$。问题要求一个无量纲的平均畸变幅度度量。\n\n对于每个键 $j$，长度的变化为 $\\Delta d_j = d_j - d_j^{(0)}$。为了使这个变化无量纲并独立于绝对键长，我们计算分数畸变：\n$$\n\\delta_j = \\frac{d_j - d_j^{(0)}}{d_j^{(0)}}\n$$\n由于畸变可以涉及键的伸长（$\\delta_j > 0$）和压缩（$\\delta_j  0$），而我们关心的是结构变化的总体幅度，我们考虑分数畸变的绝对值 $|\\delta_j|$。\n\n为了获得代表平均局域畸变的单个度量，我们计算这 $M$ 个键的这些幅度的算术平均值：\n$$\nD = \\frac{1}{M}\\sum_{j=1}^M |\\delta_j| = \\frac{1}{M}\\sum_{j=1}^M \\left| \\frac{d_j - d_j^{(0)}}{d_j^{(0)}} \\right|\n$$\n这个度量 $D$ 是一个无量纲的、半正定的量，它量化了极化子位点周围键长变化的平均幅度。极化子局域化的第二个条件是，这个平均畸变必须高于给定的阈值 $D_{\\mathrm{min}}$：\n$$\nD \\ge D_{\\mathrm{min}} = 0.02\n$$\n\n最终的极化子诊断是这两个条件的布尔与（AND）运算。当且仅当电荷足够局域化（$S \\le S_{\\mathrm{max}}$）且晶格畸变足够大（$D \\ge D_{\\mathrm{min}}$）时，一个系统才被确定为拥有一个局域化的小极化子。这个组合标准正确地捕捉了极化子作为同时具有电荷和晶格畸变特性的准粒子的双重性质。现在将实现该逻辑并将其应用于提供的测试案例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... # Scipy is available but not required for this implementation.\n\ndef solve():\n    \"\"\"\n    Derives and applies a diagnostic for small polaron localization based on DFT data.\n    The diagnostic evaluates two conditions:\n    1. Charge Localization: The effective number of sites for charge spread must be low.\n    2. Lattice Distortion: The average local bond distortion must be high.\n    A polaron is considered localized if both conditions are met.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = {\n        \"Case A\": {\n            \"N\": 12,\n            \"delta_q\": np.array([0.02, 0.01, 0.01, 0.02, 0.02, 0.80, 0.06, 0.02, 0.01, 0.00, 0.00, 0.01]),\n            \"d0\": np.array([2.00, 2.00, 2.00, 2.00, 2.00, 2.00]),\n            \"d\": np.array([2.10, 2.06, 1.94, 1.95, 2.00, 2.00]),\n        },\n        \"Case B\": {\n            \"N\": 12,\n            \"delta_q\": np.array([0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083, 0.083]),\n            \"d0\": np.array([2.00, 2.00, 2.00, 2.00, 2.00, 2.00]),\n            \"d\": np.array([2.01, 2.01, 1.99, 1.99, 2.00, 2.00]),\n        },\n        \"Case C\": {\n            \"N\": 12,\n            \"delta_q\": np.array([-0.02, -0.01, -0.01, -0.02, -0.02, -0.75, -0.08, -0.03, -0.02, 0.00, 0.00, -0.01]),\n            \"d0\": np.array([2.00, 2.00, 2.00, 2.00, 2.00, 2.00]),\n            \"d\": np.array([1.90, 1.95, 2.06, 2.05, 2.00, 2.00]),\n        },\n        \"Case D\": {\n            \"N\": 12,\n            \"delta_q\": np.array([0.02, 0.01, 0.01, 0.02, 0.02, 0.80, 0.06, 0.02, 0.01, 0.00, 0.00, 0.01]),\n            \"d0\": np.array([2.00, 2.00, 2.00, 2.00, 2.00, 2.00]),\n            \"d\": np.array([2.01, 2.00, 1.99, 2.00, 2.00, 2.00]),\n        },\n        \"Case E\": {\n            \"N\": 12,\n            \"delta_q\": np.array([0.00, 0.00, 0.00, 0.48, 0.48, 0.01, 0.01, 0.00, 0.00, 0.00, 0.00, 0.00]),\n            \"d0\": np.array([2.00, 2.00, 2.00, 2.00, 2.00, 2.00]),\n            \"d\": np.array([2.08, 2.06, 1.94, 1.94, 2.00, 2.00]),\n        },\n    }\n\n    # Define thresholds from the problem statement\n    S_max = 3.0\n    D_min = 0.02\n\n    def check_polaron_localization(delta_q, d0, d):\n        \"\"\"\n        Calculates the localization index S and distortion metric D for a single case.\n        Returns a boolean indicating if the polaron is localized.\n        \"\"\"\n        # 1. Calculate the charge localization index S\n        abs_delta_q = np.abs(delta_q)\n        total_abs_q = np.sum(abs_delta_q)\n\n        # Handle the edge case of no charge difference\n        if total_abs_q == 0:\n            # If there's no charge, it's perfectly delocalized over all sites.\n            # Could be N, but this case isn't physically interesting for a polaron search.\n            # In any case, it's not localized on a few sites.\n            S = float('inf') \n        else:\n            p = abs_delta_q / total_abs_q\n            # Filter out p_i = 0 to avoid log(0) errors. The term p_i*log(p_i) is 0 for p_i=0.\n            p_nonzero = p[p > 0]\n            # Calculate Shannon entropy H\n            H = -np.sum(p_nonzero * np.log(p_nonzero))\n            # Calculate localization index S (effective number of sites)\n            S = np.exp(H)\n        \n        is_charge_localized = (S = S_max)\n\n        # 2. Calculate the lattice distortion metric D\n        # Use np.divide to handle potential division by zero if a bond length is 0,\n        # although physically d0 should always be positive.\n        fractional_distortion = np.divide(d - d0, d0)\n        D = np.mean(np.abs(fractional_distortion))\n        \n        is_distorted = (D >= D_min)\n\n        # 3. Final polaron diagnostic\n        is_polaron_localized = is_charge_localized and is_distorted\n        \n        return is_polaron_localized\n\n    results = []\n    # The order of cases must be preserved for the final output.\n    case_order = [\"Case A\", \"Case B\", \"Case C\", \"Case D\", \"Case E\"]\n    for case_name in case_order:\n        case_data = test_cases[case_name]\n        result = check_polaron_localization(case_data[\"delta_q\"], case_data[\"d0\"], case_data[\"d\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The output format for booleans in Python's str() is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "模拟电极材料的一个主要目标是预测其电化学性质，例如开路电压。本次实践将弥合零开尔文（0K）下的DFT计算与真实世界有限温度条件之间的鸿沟。您将学习如何将振动自由能和构型熵的贡献纳入吉布斯自由能的计算中，从而能够预测电池在工作温度下的电压 。",
            "id": "3904866",
            "problem": "要求您实现一个规范的计算工作流，用以将振动自由能和构型熵修正纳入锂嵌入电极材料的有限温度吉布斯自由能 $G(T)$ 中，并利用它来预测有限温度下的开路电压。该场景基于密度泛函理论（DFT）和统计力学。DFT是一种用于获得总能量 $E_{\\mathrm{DFT}}$ 的量子力学方法，而统计力学用于计算振动和构型贡献。您的程序必须计算给定组分的 $G(T)$，使用锂金属的化学势将其合并为锂插入步骤的反应自由能，然后将其转化为电压。\n\n从以下基本事实和定义开始：\n- 吉布斯自由能定义为 $G = U - T S + p V$。对于环境条件下的凝聚相固体， $pV$ 项可以忽略不计，因此 $G(T)$ 可以近似为 $G(T) \\approx E_{\\mathrm{DFT}} + F_{\\mathrm{vib}}(T) - T S_{\\mathrm{conf}}(x)$，其中 $E_{\\mathrm{DFT}}$ 是来自密度泛函理论（DFT）的总能量，$F_{\\mathrm{vib}}(T)$ 是温度 $T$ 下的振动亥姆霍兹自由能，而 $S_{\\mathrm{conf}}(x)$ 是在一组等效位点上锂/空位以分数占有率 $x$ 混合所产生的构型熵。\n- 在声子的谐波近似中，每个角频率为 $\\omega_i$ 的简正模对振动亥姆霍兹自由能的贡献如下\n$$\nF_{\\mathrm{vib}}(T) = \\sum_{i} \\left( \\frac{1}{2}\\hbar \\omega_i + k_B T \\ln\\left(1 - e^{-\\hbar \\omega_i / (k_B T)} \\right) \\right),\n$$\n其中 $k_B$ 是玻尔兹曼常数，$\\hbar$ 是约化普朗克常数。如果频率以周/秒 $f_i$ 给出，则 $\\omega_i = 2 \\pi f_i$。\n- 对于每个化学式单位上 $N_{\\mathrm{sites}}$ 个等效位点上的锂和空位的二元理想混合，构型熵为\n$$\nS_{\\mathrm{conf}}(x) = -k_B N_{\\mathrm{sites}} \\left[ x \\ln x + (1-x) \\ln (1-x) \\right],\n$$\n对于 $0  x  1$，$S_{\\mathrm{conf}}(0) = S_{\\mathrm{conf}}(1) = 0$ 由连续性可知。\n- 对于主体材料中从 $x_2$ 到 $x_1$ 的锂插入反应，\n$$\n\\Delta G(T) = G_{\\mathrm{host}}(x_1,T) - G_{\\mathrm{host}}(x_2,T) - (x_1 - x_2)\\,\\mu_{\\mathrm{Li}}(T),\n$$\n其中 $\\mu_{\\mathrm{Li}}(T)$ 是每个原子的锂金属化学势（通过 DFT 和振动贡献近似），且\n$$\nG_{\\mathrm{host}}(x,T) = E_{\\mathrm{DFT}}^{\\mathrm{host}}(x) + F_{\\mathrm{vib}}^{\\mathrm{host}}(x,T) - T S_{\\mathrm{conf}}(x).\n$$\n- 温度 $T$ 下的开路电压由下式给出\n$$\nV(T) = -\\frac{\\Delta G(T)}{x_1 - x_2}.\n$$\n当所有能量以每个化学式单位和每个原子的电子伏特（eV）进行追踪时，此表达式以伏特（V）为单位得出电压，因为每个电子 $1\\,\\mathrm{eV}$ 对应于 $1\\,\\mathrm{V}$。\n\n您的程序必须使用以下数值和物理输入及约定来实现上述原理：\n- 使用 $k_B = 8.617333262\\times 10^{-5}\\,\\mathrm{eV/K}$ 和 $\\hbar = 6.582119569\\times 10^{-16}\\,\\mathrm{eV\\cdot s}$。使用 $\\omega = 2\\pi f$ 和 $1\\,\\mathrm{THz} = 10^{12}\\,\\mathrm{Hz}$。所有振动频率均以太赫兹（THz）为单位给出。\n- 主体材料的组分由每个化学式单位的锂分数 $x$ 参数化，每个化学式单位有 $N_{\\mathrm{sites}} = 1$ 个位点。使用以下主体材料的密度泛函理论（DFT）总能量，单位为电子伏特（每个化学式单位）：\n    - $E_{\\mathrm{DFT}}^{\\mathrm{host}}(0.0) = -100.000\\,\\mathrm{eV}$,\n    - $E_{\\mathrm{DFT}}^{\\mathrm{host}}(0.5) = -102.500\\,\\mathrm{eV}$,\n    - $E_{\\mathrm{DFT}}^{\\mathrm{host}}(0.95) = -104.100\\,\\mathrm{eV}$,\n    - $E_{\\mathrm{DFT}}^{\\mathrm{host}}(1.0) = -104.200\\,\\mathrm{eV}$。\n- 主体材料在每种组分 $x$ 下的振动频率（单位 THz）（每个化学式单位，谐波简正模）：\n    - 对于 $x=0.0$: $[5.0,\\,8.0,\\,12.0,\\,15.0,\\,3.0,\\,7.0,\\,10.0,\\,14.0,\\,18.0]$,\n    - 对于 $x=0.5$: $[4.5,\\,7.5,\\,11.5,\\,14.5,\\,2.5,\\,6.5,\\,9.5,\\,13.5,\\,17.0]$,\n    - 对于 $x=0.95$: $[4.2,\\,7.0,\\,11.0,\\,14.0,\\,2.2,\\,6.2,\\,9.2,\\,13.2,\\,16.5]$,\n    - 对于 $x=1.0$: $[4.0,\\,6.8,\\,10.8,\\,13.8,\\,2.0,\\,6.0,\\,9.0,\\,13.0,\\,16.0]$。\n- 锂金属（每个原子）的DFT能量和振动频率（单位 THz）：\n    - $E_{\\mathrm{DFT}}^{\\mathrm{Li}} = -1.600\\,\\mathrm{eV}$,\n    - 频率 $[2.0,\\,4.0,\\,6.0]$。\n\n算法要求：\n- 实现一个鲁棒的 $F_{\\mathrm{vib}}(T)$ 计算，在 $T=0$ 时返回零点能 $\\sum_i \\frac{1}{2}\\hbar\\omega_i$，否则使用完整的谐波自由能表达式。通过为非常小的 $T$ 实现一个阈值来避免数值问题。\n- 实现 $S_{\\mathrm{conf}}(x)$，并对 $x=0$ 和 $x=1$ 进行数值稳定的处理，以确保 $S_{\\mathrm{conf}}(0)=S_{\\mathrm{conf}}(1)=0$。\n\n测试套件：\n计算以下四种情况下的电压（单位为伏特 V），并四舍五入到六位小数：\n1. $T = 300\\,\\mathrm{K}$, $x_2=0.0$, $x_1=0.5$.\n2. $T = 1\\,\\mathrm{K}$, $x_2=0.0$, $x_1=0.5$.\n3. $T = 1000\\,\\mathrm{K}$, $x_2=0.5$, $x_1=1.0$.\n4. $T = 300\\,\\mathrm{K}$, $x_2=0.95$, $x_1=1.0$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[v_1,v_2,v_3,v_4]$），其中每个 $v_i$ 是预测的电压，单位为伏特，四舍五入到六位小数。不应打印任何其他文本。所有内部计算必须一致地使用提供的常数和单位，并且最终答案必须以 $\\mathrm{V}$ 表示。",
            "solution": "该问题要求实现一个计算工作流，以确定锂嵌入电极在有限温度下的开路电压。该方法论植根于用于总能量计算的密度泛函理论（DFT）原理和用于吉布斯自由能的热和熵贡献的统计力学。解决方案将根据提供的物理模型和数据，遵循严谨的、分步推导来构建。\n\n在可忽略的压力下，固相在温度 $T$ 下的吉布斯自由能 $G(T)$ 可由亥姆霍兹自由能 $A(T) = U - TS$ 近似。在我们的模型中，这被进一步分解为：\n$$\nG(T) \\approx G(x,T) = E_{\\mathrm{DFT}}(x) + F_{\\mathrm{vib}}(x,T) - T S_{\\mathrm{conf}}(x)\n$$\n在这里，$x$ 是锂的分数占有率，$E_{\\mathrm{DFT}}(x)$ 是从DFT获得的 $T=0\\,\\mathrm{K}$ 时的静态总能量，$F_{\\mathrm{vib}}(x,T)$ 是振动亥姆霍兹自由能，而 $S_{\\mathrm{conf}}(x)$ 是由锂离子和空位的统计排列引起的构型熵。\n\n计算过程的结构如下：\n\n1.  **热力学量的建模：** 我们首先建立鲁棒的函数，以计算任何给定组分和温度下的组成热力学量。\n\n    -   **振动亥姆霍兹自由能, $F_{\\mathrm{vib}}(T)$:** 在谐波近似内，一组具有角频率 $\\{\\omega_i\\}$ 的简正模的振动自由能由下式给出：\n        $$\n        F_{\\mathrm{vib}}(T) = \\sum_{i} \\left( \\frac{1}{2}\\hbar \\omega_i + k_B T \\ln\\left(1 - e^{-\\hbar \\omega_i / (k_B T)} \\right) \\right)\n        $$\n        第一项 $\\sum_i \\frac{1}{2}\\hbar \\omega_i$ 是与温度无关的零点能（ZPE）。第二项代表对自由能的热贡献。实现时必须处理输入频率 $f_i$（单位 THz）到角频率 $\\omega_i = 2 \\pi f_i$ 的转换。在数值上，对于非常小的 $T$，对数的参数趋近于0，可能导致不稳定。在 $T \\to 0\\,\\mathrm{K}$ 时，对数项消失，$F_{\\mathrm{vib}}(0)$ 正确地简化为零点能。我们的实现遵循此极限，并使用数值稳定的库函数（即 `numpy.log1p`）来精确计算对数项。使用的物理常数是玻尔兹曼常数 $k_B=8.617333262\\times 10^{-5}\\,\\mathrm{eV/K}$ 和约化普朗克常数 $\\hbar = 6.582119569\\times 10^{-16}\\,\\mathrm{eV\\cdot s}$。\n\n    -   **构型熵, $S_{\\mathrm{conf}}(x)$:** 对于每个化学式单位上 $N_{\\mathrm{sites}}$ 个等效位点上的锂和空位的理想固溶体，构型熵由玻尔兹曼混合公式给出：\n        $$\n        S_{\\mathrm{conf}}(x) = -k_B N_{\\mathrm{sites}} \\left[ x \\ln x + (1-x) \\ln (1-x) \\right]\n        $$\n        此表达式对 $x \\in (0,1)$ 有效。对于纯相 $x=0$ 和 $x=1$，没有构型无序度，因此 $S_{\\mathrm{conf}}(0)=S_{\\mathrm{conf}}(1)=0$。实现时必须显式处理这些端点条件，以避免计算 $\\ln(0)$ 时的数值错误。问题指定 $N_{\\mathrm{sites}} = 1$。\n\n2.  **化学势和吉布斯自由能的计算：**\n\n    -   **锂金属的化学势, $\\mu_{\\mathrm{Li}}(T)$:** 锂化学势的参考标准取为纯锂金属。其每个原子的吉布斯自由能计算如下：\n        $$\n        \\mu_{\\mathrm{Li}}(T) = G_{\\mathrm{Li}}(T) = E_{\\mathrm{DFT}}^{\\mathrm{Li}} + F_{\\mathrm{vib}}^{\\mathrm{Li}}(T)\n        $$\n        这里，$E_{\\mathrm{DFT}}^{\\mathrm{Li}}$ 和锂金属的振动频率是已知的。纯元素的构型熵为零。\n\n    -   **主体材料的吉布斯自由能, $G_{\\mathrm{host}}(x,T)$:** 使用第一步中开发的函数以及提供的不同组分 $x$ 下主体材料的DFT能量和振动频率，我们计算每个化学式单位的总吉布斯自由能：\n        $$\n        G_{\\mathrm{host}}(x,T) = E_{\\mathrm{DFT}}^{\\mathrm{host}}(x) + F_{\\mathrm{vib}}^{\\mathrm{host}}(x,T) - T S_{\\mathrm{conf}}(x)\n        $$\n\n3.  **开路电压的确定：** 电动势，或称开路电压（$V$），由电化学反应的吉布斯自由能变化决定。对于将 $(x_1 - x_2)$ 摩尔的锂插入主体材料中，反应为 $\\mathrm{Host}(x_2) + (x_1 - x_2)\\mathrm{Li} \\rightarrow \\mathrm{Host}(x_1)$。此过程的吉布斯自由能变化为：\n    $$\n    \\Delta G(T) = G_{\\mathrm{host}}(x_1,T) - G_{\\mathrm{host}}(x_2,T) - (x_1 - x_2)\\,\\mu_{\\mathrm{Li}}(T)\n    $$\n    电压是每摩尔转移电荷的自由能变化的负值。当所有能量以电子伏特（eV）为单位，并考虑转移 $(x_1 - x_2)$ 个电子（对于 $(x_1 - x_2)$ 个 Li$^+$ 离子）时，电压（V）为：\n    $$\n    V(T) = -\\frac{\\Delta G(T)}{x_1 - x_2} = -\\left( \\frac{G_{\\mathrm{host}}(x_1,T) - G_{\\mathrm{host}}(x_2,T)}{x_1 - x_2} - \\mu_{\\mathrm{Li}}(T) \\right)\n    $$\n    项 $\\frac{G_{\\mathrm{host}}(x_1,T) - G_{\\mathrm{host}}(x_2,T)}{x_1 - x_2}$ 是主体材料中锂的化学势 $\\mu_{\\mathrm{Li}}^{\\mathrm{host}}(T)$ 的有限差分近似。\n\n最终的程序实现了这整个工作流。它定义了物理常数和输入数据，实现了 $F_{\\mathrm{vib}}(T)$ 和 $S_{\\mathrm{conf}}(x)$ 的函数，然后将它们组合起来计算 $G_{\\mathrm{host}}(x,T)$ 和 $\\mu_{\\mathrm{Li}}(T)$。最后，它遍历指定的测试用例，为每个用例计算电压，将结果四舍五入到六位小数，并打印格式化的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes open-circuit voltages at finite temperature for a Li-intercalation electrode.\n    The calculation is based on DFT total energies and statistical mechanics for\n    vibrational and configurational contributions to the Gibbs free energy.\n    \"\"\"\n\n    # Define the physical constants provided in the problem statement.\n    k_B = 8.617333262e-5  # Boltzmann constant in eV/K\n    hbar = 6.582119569e-16 # Reduced Planck constant in eV*s\n\n    # Define the input data for the host material.\n    E_dft_host = {\n        0.0: -100.000,\n        0.5: -102.500,\n        0.95: -104.100,\n        1.0: -104.200,\n    }\n    freqs_host = {\n        0.0: np.array([5.0, 8.0, 12.0, 15.0, 3.0, 7.0, 10.0, 14.0, 18.0]),\n        0.5: np.array([4.5, 7.5, 11.5, 14.5, 2.5, 6.5, 9.5, 13.5, 17.0]),\n        0.95: np.array([4.2, 7.0, 11.0, 14.0, 2.2, 6.2, 9.2, 13.2, 16.5]),\n        1.0: np.array([4.0, 6.8, 10.8, 13.8, 2.0, 6.0, 9.0, 13.0, 16.0]),\n    }\n    N_sites = 1\n\n    # Define the input data for Lithium metal.\n    E_dft_li = -1.600\n    freqs_li = np.array([2.0, 4.0, 6.0])\n\n    def calculate_F_vib(T, freqs_thz):\n        \"\"\"\n        Calculates the vibrational Helmholtz free energy F_vib(T) in the harmonic approximation.\n        \n        Args:\n            T (float): Temperature in Kelvin.\n            freqs_thz (np.ndarray): Array of vibrational frequencies in THz.\n\n        Returns:\n            float: Vibrational free energy in eV.\n        \"\"\"\n        # omega = 2 * pi * f\n        omegas = 2 * np.pi * freqs_thz * 1e12  # Angular frequencies in rad/s\n\n        # Zero-point energy (ZPE) = sum(0.5 * hbar * omega)\n        zpe = 0.5 * hbar * np.sum(omegas)\n\n        # At T=0, F_vib is just the ZPE. Use a small threshold for numerical stability.\n        if T  1e-6:\n            return zpe\n\n        # Thermal contribution to free energy\n        k_B_T = k_B * T\n        hbar_omegas = hbar * omegas\n        \n        # Argument of the exponential: x = hbar * omega / (k_B * T)\n        # Avoid division by zero if k_B_T is zero, though already handled by T check.\n        exponents = hbar_omegas / k_B_T\n        \n        # Use np.log1p for better numerical precision for log(1-y) where y is small.\n        # log(1 - exp(-x)) = log1p(-exp(-x))\n        thermal_terms = k_B_T * np.log1p(-np.exp(-exponents))\n        thermal_F = np.sum(thermal_terms)\n        \n        return zpe + thermal_F\n\n    def calculate_S_conf(x):\n        \"\"\"\n        Calculates the configurational entropy S_conf(x) for ideal binary mixing.\n\n        Args:\n            x (float): Lithium fraction, between 0 and 1.\n\n        Returns:\n            float: Configurational entropy in eV/K.\n        \"\"\"\n        # For pure phases (x=0 or x=1), entropy is 0. Use tolerance for float comparison.\n        if x  1e-9 or x > (1.0 - 1e-9):\n            return 0.0\n        \n        return -k_B * N_sites * (x * np.log(x) + (1 - x) * np.log(1 - x))\n\n    def calculate_G_host(x, T):\n        \"\"\"\n        Calculates the Gibbs free energy G(x, T) for the host material.\n        \n        Args:\n            x (float): Lithium fraction.\n            T (float): Temperature in Kelvin.\n            \n        Returns:\n            float: Gibbs free energy in eV.\n        \"\"\"\n        E_dft = E_dft_host[x]\n        freqs = freqs_host[x]\n        \n        F_vib = calculate_F_vib(T, freqs)\n        S_conf = calculate_S_conf(x)\n        \n        return E_dft + F_vib - T * S_conf\n\n    def calculate_mu_li(T):\n        \"\"\"\n        Calculates the chemical potential mu(T) for lithium metal.\n\n        Args:\n            T (float): Temperature in Kelvin.\n\n        Returns:\n            float: Chemical potential of Li metal in eV/atom.\n        \"\"\"\n        F_vib = calculate_F_vib(T, freqs_li)\n        # S_conf for a pure element is 0.\n        return E_dft_li + F_vib\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (300, 0.0, 0.5),   # Case 1\n        (1, 0.0, 0.5),     # Case 2\n        (1000, 0.5, 1.0),  # Case 3\n        (300, 0.95, 1.0),  # Case 4\n    ]\n\n    results = []\n    for T, x2, x1 in test_cases:\n        # Calculate Gibbs free energies for the host at initial and final compositions\n        G_host_x1 = calculate_G_host(x1, T)\n        G_host_x2 = calculate_G_host(x2, T)\n        \n        # Calculate the chemical potential of the Li reservoir\n        mu_li_T = calculate_mu_li(T)\n        \n        # Calculate the change in Gibbs free energy for the reaction\n        delta_x = x1 - x2\n        delta_G = G_host_x1 - G_host_x2 - delta_x * mu_li_T\n        \n        # Calculate the voltage\n        voltage = -delta_G / delta_x\n        \n        # Round to six decimal places as specified\n        results.append(round(voltage, 6))\n\n    # Format the final list of results into the required output string.\n    # Using .6f ensures that numbers like 2.0 are printed as 2.000000.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}