{
    "hands_on_practices": [
        {
            "introduction": "Before embarking on the complex task of developing a GPU-accelerated solver, a critical preliminary step is to perform a \"back-of-the-envelope\" calculation of the required resources. This practice focuses on estimating the GPU memory footprint, a primary constraint in high-performance computing. By quantifying the memory demands for all essential data structures—including state vectors, residuals, and the sparse Jacobian matrix—you will develop the crucial skill of assessing the feasibility of a large-scale simulation on a given hardware architecture .",
            "id": "3917083",
            "problem": "A lithium-ion battery electrochemical-thermal solver is deployed on a Graphics Processing Unit (GPU) for automated battery design and simulation of a three-dimensional domain. The domain is discretized by a uniform structured mesh with $N_{x}$, $N_{y}$, and $N_{z}$ cells along the three Cartesian axes, and periodic boundary conditions are assumed so that each interior cell has $6$ face neighbors. At each cell, the state comprises $b$ coupled fields representing solid-phase potential $\\phi_{s}$, electrolyte potential $\\phi_{e}$, electrolyte concentration $c_{e}$, solid-phase lithium concentration $c_{s}$, and temperature $T$, so $b = 5$.\n\nThe solver maintains the following data structures on the GPU:\n- The state vector $x \\in \\mathbb{R}^{N}$, where $N = N_{x} N_{y} N_{z} b$, stored in double precision ($8$ bytes per scalar).\n- The residual vector $r \\in \\mathbb{R}^{N}$, stored in double precision ($8$ bytes per scalar).\n- The Jacobian matrix $J \\in \\mathbb{R}^{N \\times N}$, arising from a second-order diffusion/conduction and first-order reaction/charge transport discretization. Assume the Jacobian has a $7$-point block stencil per cell (the diagonal block plus $6$ face-neighbor blocks), and that each block is a dense $b \\times b$ matrix due to multiphysics coupling. The Jacobian is stored in Compressed Sparse Row (CSR) format, where each nonzero scalar entry requires one double ($8$ bytes) and one $32$-bit integer column index ($4$ bytes), and the row pointer array has length $N + 1$ with $32$-bit integers ($4$ bytes each).\n- A Block Jacobi (BJ) preconditioner that stores the inverse of each diagonal $b \\times b$ block in double precision ($8$ bytes per scalar), one block per mesh cell.\n\nStarting only from the core definitions that the memory footprint of an array equals the number of entries times the bytes per entry, and the CSR format described above, derive the total memory footprint on the GPU for $x$, $r$, $J$, and the BJ preconditioner for the representative mesh with $N_{x} = 256$, $N_{y} = 128$, $N_{z} = 64$, and $b = 5$. Express your final answer as a single number in gibibytes (GiB), where $1$ GiB $= 2^{30}$ bytes, and round your answer to four significant figures.",
            "solution": "The problem requires the calculation of the total GPU memory footprint for an electrochemical-thermal solver. The calculation will proceed by determining the memory required for each specified data structure and then summing these individual footprints. The given parameters are the mesh dimensions $N_{x} = 256$, $N_{y} = 128$, and $N_{z} = 64$, and the number of coupled fields per cell, $b = 5$. The storage sizes are $8$ bytes for a double-precision floating-point number and $4$ bytes for a $32$-bit integer.\n\nFirst, we determine the total number of cells in the computational domain, denoted by $N_{\\text{cells}}$.\n$$N_{\\text{cells}} = N_{x} \\times N_{y} \\times N_{z}$$\nSubstituting the given values:\n$$N_{\\text{cells}} = 256 \\times 128 \\times 64 = 2^8 \\times 2^7 \\times 2^6 = 2^{21} = 2,097,152 \\text{ cells}$$\n\nNext, we calculate the total number of degrees of freedom (DOFs) in the system, denoted by $N$. With $b=5$ state variables per cell, the total number of DOFs is:\n$$N = N_{\\text{cells}} \\times b = (2^{21}) \\times 5 = 10,485,760 \\text{ DOFs}$$\n\nWith these fundamental quantities established, we can calculate the memory footprint for each data structure. Let $S_{\\text{double}} = 8$ bytes and $S_{\\text{int}} = 4$ bytes.\n\n1.  **Memory for the state vector $x$ ($M_{x}$):**\n    The state vector $x \\in \\mathbb{R}^{N}$ contains $N$ elements, each stored as a double-precision number.\n    $$M_{x} = N \\times S_{\\text{double}} = (5 \\times 2^{21}) \\times 8 \\text{ bytes} = 40 \\times 2^{21} \\text{ bytes}$$\n\n2.  **Memory for the residual vector $r$ ($M_{r}$):**\n    The residual vector $r \\in \\mathbb{R}^{N}$ has the same dimensions and data type as the state vector $x$.\n    $$M_{r} = N \\times S_{\\text{double}} = (5 \\times 2^{21}) \\times 8 \\text{ bytes} = 40 \\times 2^{21} \\text{ bytes}$$\n\n3.  **Memory for the Jacobian matrix $J$ ($M_{J}$):**\n    The Jacobian matrix $J \\in \\mathbb{R}^{N \\times N}$ is stored in Compressed Sparse Row (CSR) format. Its memory footprint is the sum of the memory for its three components: the non-zero values array, the column indices array, and the row pointers array.\n\n    First, we determine the number of non-zero scalar entries ($nnz$). The matrix has a $7$-point block stencil, meaning each of the $N_{\\text{cells}}$ cells has its $b$ DOFs coupled to the $b$ DOFs of itself and its $6$ face neighbors. This results in $7$ non-zero blocks for each group of $b$ rows (a block-row) corresponding to a cell. Each block is a dense $b \\times b$ matrix.\n    $$nnz = N_{\\text{cells}} \\times (\\text{number of blocks per cell}) \\times (\\text{entries per block})$$\n    $$nnz = N_{\\text{cells}} \\times 7 \\times b^2 = 2^{21} \\times 7 \\times 5^2 = 2^{21} \\times 7 \\times 25 = 175 \\times 2^{21}$$\n\n    The memory for the `values` array ($M_{J,val}$) and the `col_ind` array ($M_{J,col}$) is based on $nnz$. Each non-zero entry requires one double for its value and one $32$-bit integer for its column index.\n    $$M_{J,val} + M_{J,col} = nnz \\times (S_{\\text{double}} + S_{\\text{int}}) = (175 \\times 2^{21}) \\times (8 + 4) \\text{ bytes}$$\n    $$M_{J,val} + M_{J,col} = (175 \\times 2^{21}) \\times 12 = 2100 \\times 2^{21} \\text{ bytes}$$\n\n    The `row_ptr` array has a length of $N+1$ and stores $32$-bit integers.\n    $$M_{J,row} = (N+1) \\times S_{\\text{int}} = (5 \\times 2^{21} + 1) \\times 4 \\text{ bytes} = 20 \\times 2^{21} + 4 \\text{ bytes}$$\n\n    The total memory for the Jacobian is the sum of these components:\n    $$M_{J} = (M_{J,val} + M_{J,col}) + M_{J,row} = (2100 \\times 2^{21}) + (20 \\times 2^{21} + 4) = 2120 \\times 2^{21} + 4 \\text{ bytes}$$\n\n4.  **Memory for the Block Jacobi (BJ) preconditioner ($M_{BJ}$):**\n    The BJ preconditioner stores the inverse of each diagonal $b \\times b$ block. There is one such block for each of the $N_{\\text{cells}}$. These are stored as dense matrices in double precision.\n    $$M_{BJ} = N_{\\text{cells}} \\times (\\text{entries per block}) \\times S_{\\text{double}}$$\n    $$M_{BJ} = N_{\\text{cells}} \\times b^2 \\times S_{\\text{double}} = 2^{21} \\times 5^2 \\times 8 = 2^{21} \\times 25 \\times 8 = 200 \\times 2^{21} \\text{ bytes}$$\n\nFinally, we sum the memory footprints of all components to find the total memory, $M_{\\text{total}}$.\n$$M_{\\text{total}} = M_{x} + M_{r} + M_{J} + M_{BJ}$$\n$$M_{\\text{total}} = (40 \\times 2^{21}) + (40 \\times 2^{21}) + (2120 \\times 2^{21} + 4) + (200 \\times 2^{21})$$\n$$M_{\\text{total}} = (40 + 40 + 2120 + 200) \\times 2^{21} + 4 = 2400 \\times 2^{21} + 4 \\text{ bytes}$$\n\nThe problem asks for the answer in gibibytes (GiB), where $1 \\text{ GiB} = 2^{30} \\text{ bytes}$. The additional $4$ bytes are negligible for this conversion and subsequent rounding.\n$$M_{\\text{total}} (\\text{GiB}) = \\frac{2400 \\times 2^{21}}{2^{30}} = 2400 \\times 2^{21-30} = 2400 \\times 2^{-9} = \\frac{2400}{512}$$\nPerforming the division:\n$$\\frac{2400}{512} = \\frac{1200}{256} = \\frac{600}{128} = \\frac{300}{64} = \\frac{150}{32} = \\frac{75}{16} = 4.6875$$\nThe result must be rounded to four significant figures.\n$$4.6875 \\approx 4.688$$\nThus, the total memory footprint is approximately $4.688$ GiB.",
            "answer": "$$\\boxed{4.688}$$"
        },
        {
            "introduction": "After confirming that a simulation is feasible from a memory standpoint, the next fundamental question is: what is the upper bound on its performance? The roofline model is an indispensable tool for answering this, providing insight into whether a kernel is limited by the processor's computational speed or its memory bandwidth. This exercise will guide you through calculating the arithmetic intensity for a representative 3D stencil kernel, a common pattern in electrochemical-thermal solvers, and using this to predict its attainable performance .",
            "id": "3917076",
            "problem": "A high-fidelity electrochemical-thermal model for a lithium-ion battery pack is discretized on a uniform Cartesian grid using a second-order central finite-difference scheme for heat conduction and an explicit forward-Euler time integrator. On a Graphics Processing Unit (GPU), a naive seven-point three-dimensional stencil kernel updates the temperature field from time level $n$ to $n+1$ using the following per-node operation pattern: read the center temperature value and its $6$ face-adjacent neighbors from the input array at time level $n$, read a volumetric heat source from a separate array, compute a weighted linear combination with preloaded scalar coefficients, and write the updated temperature to an output array at time level $n+1$. Assume double precision ($s=8$ bytes per value), no use of fused multiply-add, coefficients reside in registers, and the GPU exhibits no read-for-ownership behavior for global stores. All global memory accesses are perfectly coalesced, and there is no inter-thread data reuse via shared memory or caches.\n\nFor a single lattice-point update, the arithmetic work follows this explicit form:\n- Compute $P_0=\\gamma_0 T_{i,j,k}$, and for each of the $6$ face neighbors $p \\in \\{1,\\dots,6\\}$ compute $P_p=\\gamma_p T_{\\text{nb}(p)}$.\n- Accumulate the $7$ products $\\{P_0,P_1,\\dots,P_6\\}$ by pairwise addition into a single sum.\n- Compute $P_s=\\sigma s_{i,j,k}$ and add it to the accumulated sum to produce $T^{n+1}_{i,j,k}$.\n\nCount floating-point operations using the convention that each multiply or add counts as $1$ floating-point operation and that no multiply-add fusion occurs.\n\nAssume the following hardware properties for the GPU:\n- Sustained global-memory bandwidth $B_{\\text{sust}}=1.2 \\times 10^{12}$ bytes/s under the given access pattern.\n- Peak double-precision throughput $P_{\\text{peak}}=9.5 \\times 10^{12}$ floating-point operations/s.\n\nStarting only from the definitions of arithmetic intensity and the roofline performance model, do the following:\n- Derive the arithmetic intensity, defined as floating-point operations per byte of global memory traffic, for the described stencil update.\n- Map this arithmetic intensity to the roofline model to estimate the attainable bandwidth-limited performance of the kernel, and verify whether the kernel is bandwidth-bound under the given hardware parameters.\n\nRound your final numerical answer for the attainable performance to $3$ significant figures and express the final performance in GFLOP/s. The final answer must be a single number.",
            "solution": "The solution proceeds in three stages: first, we determine the number of floating-point operations (FLOPs) per stencil point update; second, we determine the total global memory traffic in bytes per point update; and third, we use these quantities to calculate the arithmetic intensity and apply the roofline model to find the attainable performance.\n\n**1. Calculation of Floating-Point Operations**\n\nThe problem specifies the arithmetic work for a single lattice-point update. We count the operations according to the provided breakdown, where each multiplication and each addition counts as $1$ FLOP.\n\n- Computation of the central point's contribution: $P_0 = \\gamma_0 T_{i,j,k}$. This is $1$ multiplication.\n- Computation of the $6$ neighbors' contributions: $P_p = \\gamma_p T_{\\text{nb}(p)}$ for $p \\in \\{1, \\dots, 6\\}$. This is $6$ multiplications.\n- Accumulation of the $7$ product terms $\\{P_0, P_1, \\dots, P_6\\}$ into a single sum. Summing $7$ numbers requires $7-1=6$ pairwise additions.\n- Computation of the source term's contribution: $P_s = \\sigma s_{i,j,k}$. This is $1$ multiplication.\n- Addition of the source term to the accumulated sum: This is $1$ final addition.\n\nThe total number of floating-point operations, $N_{\\text{FLOPs}}$, per point update is the sum of all multiplications and additions:\n$$N_{\\text{FLOPs}} = (1 + 6 + 1) \\text{ multiplications} + (6 + 1) \\text{ additions}$$\n$$N_{\\text{FLOPs}} = 8 + 7 = 15 \\text{ FLOPs}$$\n\n**2. Calculation of Global Memory Traffic**\n\nThe problem states that each thread updates one point in the grid. We calculate the total data transfer to and from global memory for this single update. The assumptions of no data reuse via caches or shared memory and perfectly coalesced accesses simplify this to a direct count of reads and writes. Data is in double precision, so each value requires $s=8$ bytes.\n\n- **Reads from Global Memory:**\n  - $1$ center temperature value ($T_{i,j,k}$).\n  - $6$ face-adjacent neighbor temperature values.\n  - $1$ volumetric heat source value ($s_{i,j,k}$) from a separate array.\n  - Total values read = $1 + 6 + 1 = 8$ values.\n  - Total bytes read = $8 \\text{ values} \\times 8 \\frac{\\text{bytes}}{\\text{value}} = 64$ bytes.\n\n- **Writes to Global Memory:**\n  - $1$ updated temperature value ($T^{n+1}_{i,j,k}$) to the output array.\n  - Total values written = $1$ value.\n  - Total bytes written = $1 \\text{ value} \\times 8 \\frac{\\text{bytes}}{\\text{value}} = 8$ bytes.\n\nThe total memory traffic in bytes, $N_{\\text{Bytes}}$, per point update is the sum of bytes read and bytes written:\n$$N_{\\text{Bytes}} = 64 \\text{ bytes (read)} + 8 \\text{ bytes (write)} = 72 \\text{ bytes}$$\n\n**3. Application of the Roofline Performance Model**\n\nThe arithmetic intensity, $I$, is defined as the ratio of floating-point operations to bytes of global memory traffic.\n$$I = \\frac{N_{\\text{FLOPs}}}{N_{\\text{Bytes}}} = \\frac{15 \\text{ FLOPs}}{72 \\text{ bytes}} = \\frac{5}{24} \\frac{\\text{FLOPs}}{\\text{byte}}$$\n\nThe roofline model predicts that the attainable performance, $P_{\\text{attainable}}$, is the minimum of the peak compute throughput, $P_{\\text{peak}}$, and the performance sustainable by the memory subsystem, which is the product of the arithmetic intensity and the sustained memory bandwidth, $B_{\\text{sust}}$.\n$$P_{\\text{attainable}} = \\min(P_{\\text{peak}}, I \\times B_{\\text{sust}})$$\n\nTo determine whether the kernel is bandwidth-bound or compute-bound, we can compute the machine's ridge point, $I_{\\text{ridge}}$, which is the minimum arithmetic intensity required to saturate the peak compute performance.\n$$I_{\\text{ridge}} = \\frac{P_{\\text{peak}}}{B_{\\text{sust}}} = \\frac{9.5 \\times 10^{12} \\text{ FLOP/s}}{1.2 \\times 10^{12} \\text{ bytes/s}} = \\frac{9.5}{1.2} \\frac{\\text{FLOPs}}{\\text{byte}} \\approx 7.917 \\frac{\\text{FLOPs}}{\\text{byte}}$$\n\nThe kernel's arithmetic intensity is $I = \\frac{5}{24} \\approx 0.2083$ FLOPs/byte. Since $I  I_{\\text{ridge}}$, the kernel is **bandwidth-bound**. Its performance is limited by the memory bandwidth.\n\nTherefore, the attainable performance is given by:\n$$P_{\\text{attainable}} = I \\times B_{\\text{sust}}$$\n$$P_{\\text{attainable}} = \\left(\\frac{5}{24} \\frac{\\text{FLOPs}}{\\text{byte}}\\right) \\times \\left(1.2 \\times 10^{12} \\frac{\\text{bytes}}{\\text{s}}\\right)$$\n$$P_{\\text{attainable}} = \\frac{5 \\times 1.2}{24} \\times 10^{12} \\frac{\\text{FLOPs}}{\\text{s}} = \\frac{6}{24} \\times 10^{12} \\frac{\\text{FLOPs}}{\\text{s}}$$\n$$P_{\\text{attainable}} = 0.25 \\times 10^{12} \\frac{\\text{FLOPs}}{\\text{s}}$$\n\nThe problem requires the answer in GigaFLOPs per second (GFLOP/s), where $1 \\text{ GFLOP/s} = 10^9$ FLOP/s.\n$$P_{\\text{attainable}} = 0.25 \\times 10^{12} \\text{ FLOP/s} = 250 \\times 10^9 \\text{ FLOP/s} = 250 \\text{ GFLOP/s}$$\n\nThis value is exact. Rounding to $3$ significant figures gives $250$.",
            "answer": "$$\\boxed{250}$$"
        },
        {
            "introduction": "The roofline analysis from the previous practice often confirms that solvers for physical models, like heat conduction, are memory-bandwidth bound. To combat this bottleneck, a key optimization strategy is to exploit the GPU's fast, on-chip shared memory to increase data reuse and reduce traffic to global memory. This hands-on problem frames this strategy as a constrained optimization puzzle: you will determine the optimal tile size for a shared-memory-blocked kernel by carefully balancing the competing demands on shared memory and register file resources to maximize arithmetic intensity and, ultimately, performance .",
            "id": "3917132",
            "problem": "In a high-fidelity electrochemical-thermal battery pack simulator, the heat conduction subsolver advances the temperature field by an explicit finite-difference scheme for the three-dimensional heat equation, where each update uses the central point and its six axis-aligned neighbors. On a Graphics Processing Unit (GPU), the solver maps the grid to thread blocks and uses on-chip shared memory to stage a cubic tile of grid values so that each thread updates one interior cell of the tile. To correctly compute neighbor differences without extra global memory traffic, the shared-memory tile must include a one-cell halo in every direction around the interior region.\n\nAssume the following scientifically realistic configuration and constraints for a Streaming Multiprocessor (SM) on the target GPU:\n- Double-precision storage is used, so each scalar value requires $b = 8$ bytes.\n- The halo thickness is $h = 1$ cell on each of the six faces.\n- Each thread processes one interior cell and consumes $r = 64$ registers.\n- The total shared memory capacity per SM is $S_{\\mathrm{SM}} = 98{,}304$ bytes, and the per-block shared memory allocation cap is $S_{\\mathrm{block,max}} = 49{,}152$ bytes.\n- The total register file per SM contains $R_{\\mathrm{SM}} = 65{,}536$ registers.\n- For adequate latency hiding and memory-compute overlap, the scheduler requires at least $m = 2$ resident (concurrent) thread blocks per SM.\n\nLet the interior region of a cubic tile processed by one block have edge length $T$, so there are $T^{3}$ interior threads and $(T+2)^{3}$ stored values in shared memory including the halo. Derive from first principles the constraints that must be satisfied by $T$ in terms of shared memory usage and register availability to guarantee at least $m = 2$ resident blocks per SM. Argue why maximizing arithmetic intensity for this stencil under these constraints reduces to maximizing $T$ subject to those constraints. Using the provided parameters, determine the largest integer $T$ that is feasible. Report $T$ as a pure number with no units. No rounding is necessary.",
            "solution": "The problem asks for three things: first, to derive the constraints on the interior cubic tile edge length, $T$, that guarantee at least $m=2$ thread blocks can be resident on a Streaming Multiprocessor (SM). Second, to argue why maximizing arithmetic intensity under these constraints simplifies to maximizing $T$. Third, to determine the largest feasible integer value for $T$ using the provided parameters.\n\nLet us begin by formalizing the constraints imposed by the GPU hardware resources: shared memory and registers.\n\n**1. Shared Memory Constraint**\n\nA single thread block processes an interior region of volume $T \\times T \\times T = T^3$ cells. To update the cells at the boundary of this interior region using the 7-point stencil, a halo of data from neighboring cells is required. The problem states this halo has a thickness of $h=1$ cell on each of the six faces of the cube.\n\nThe total cubic tile of data staged in a block's shared memory therefore has dimensions of $(T+2h) \\times (T+2h) \\times (T+2h)$. Given $h=1$, the dimensions are $(T+2) \\times (T+2) \\times (T+2)$. The total number of scalar values in the shared memory tile for one block is $(T+2)^3$.\n\nEach scalar value is stored in double-precision, requiring $b=8$ bytes. The total shared memory required by a single thread block, $S_{\\text{block}}$, is:\n$$S_{\\text{block}} = b(T+2h)^3 = 8(T+2)^3 \\text{ bytes}$$\n\nThere are two limits on shared memory usage. First, the memory used by a single block cannot exceed the per-block maximum, $S_{\\text{block,max}} = 49{,}152$ bytes.\n$$8(T+2)^3 \\le 49{,}152$$\n$$(T+2)^3 \\le \\frac{49{,}152}{8}$$\n$$(T+2)^3 \\le 6144 \\quad (\\text{Constraint 1a})$$\n\nSecond, to ensure latency hiding, at least $m=2$ blocks must be resident on the SM. The total shared memory consumed by these $m$ blocks cannot exceed the SM's total capacity, $S_{\\mathrm{SM}} = 98{,}304$ bytes.\n$$m \\cdot S_{\\text{block}} \\le S_{\\mathrm{SM}}$$\n$$2 \\cdot 8(T+2)^3 \\le 98{,}304$$\n$$16(T+2)^3 \\le 98{,}304$$\n$$(T+2)^3 \\le \\frac{98{,}304}{16}$$\n$$(T+2)^3 \\le 6144 \\quad (\\text{Constraint 1b})$$\n\nIn this case, the per-block limit and the total SM limit for $m=2$ blocks yield the identical constraint. This is because the total SM capacity is exactly twice the per-block cap ($98{,}304 = 2 \\times 49{,}152$), a common feature in GPU architectures that partition resources among concurrent blocks. Thus, the governing shared memory constraint is $(T+2)^3 \\le 6144$.\n\n**2. Register Constraint**\n\nEach thread block is composed of threads that update the $T^3$ interior cells, so there are $N_{\\text{threads}} = T^3$ threads per block. Each thread consumes $r = 64$ registers. The total number of registers required by a single block, $R_{\\text{block}}$, is:\n$$R_{\\text{block}} = N_{\\text{threads}} \\cdot r = T^3 \\cdot 64$$\n\nTo have $m=2$ resident blocks, the total register usage must not exceed the SM's total register file capacity, $R_{\\mathrm{SM}} = 65{,}536$.\n$$m \\cdot R_{\\text{block}} \\le R_{\\mathrm{SM}}$$\n$$2 \\cdot (64 T^3) \\le 65{,}536$$\n$$128 T^3 \\le 65{,}536$$\n$$T^3 \\le \\frac{65{,}536}{128}$$\n$$T^3 \\le 512 \\quad (\\text{Constraint 2})$$\n\nIn summary, the two governing constraints that $T$ must satisfy are:\n1. Shared Memory: $(T+2)^3 \\le 6144$\n2. Registers: $T^3 \\le 512$\nAdditionally, $T$ must be a positive integer, $T \\ge 1$.\n\n**3. Maximizing Arithmetic Intensity**\n\nArithmetic intensity, $I$, is the ratio of floating-point operations (FLOPs) performed to the amount of data (in bytes) transferred from a slow memory (global memory) to a fast memory (on-chip shared memory). Maximizing this ratio is key to performance, as it signifies that more computation is done per byte of expensive memory traffic.\n\nFor a block processing $T^3$ interior cells, the number of FLOPs is proportional to the number of cells updated. Let $F_{\\text{op}}$ be the number of FLOPs per cell update.\n$$\\text{FLOPs per block} = F_{\\text{op}} \\cdot T^3$$\n\nThe data loaded from global memory into shared memory for this block is the entire $(T+2)^3$ tile. The number of bytes transferred is:\n$$\\text{Bytes per block} = b \\cdot (T+2)^3 = 8(T+2)^3$$\n\nThe arithmetic intensity is therefore:\n$$I = \\frac{\\text{FLOPs per block}}{\\text{Bytes per block}} = \\frac{F_{\\text{op}} \\cdot T^3}{b \\cdot (T+2)^3} = \\frac{F_{\\text{op}}}{b} \\left(\\frac{T}{T+2}\\right)^3$$\n\nSince $F_{\\text{op}}$ and $b$ are constants for this problem, maximizing $I$ is equivalent to maximizing the term $\\left(\\frac{T}{T+2}\\right)^3$. The function $f(T) = \\frac{T}{T+2} = 1 - \\frac{2}{T+2}$ is a monotonically increasing function for $T  0$. As $T$ increases, $\\frac{2}{T+2}$ decreases, and thus $f(T)$ increases. Consequently, maximizing arithmetic intensity for this stencil computation reduces to finding the largest possible value of $T$ that satisfies the hardware constraints.\n\n**4. Determining the Largest Feasible Integer T**\n\nWe must find the largest integer $T$ that satisfies both derived constraints.\n\nFrom the register constraint:\n$$T^3 \\le 512$$\n$$T \\le \\sqrt[3]{512}$$\nSince $8^3 = 512$, this gives:\n$$T \\le 8$$\n\nFrom the shared memory constraint:\n$$(T+2)^3 \\le 6144$$\n$$T+2 \\le \\sqrt[3]{6144}$$\nWe can find the integer bound by testing cubes of integers:\n$18^3 = 5832$\n$19^3 = 6859$\nSince $5832 \\le 6144  6859$, the largest integer value for $T+2$ is $18$.\n$$T+2 \\le 18$$\n$$T \\le 16$$\n\nTo satisfy both constraints simultaneously, $T$ must be less than or equal to the minimum of the two upper bounds:\n$$T \\le \\min(8, 16)$$\n$$T \\le 8$$\n\nThe limiting resource is the register file. The largest integer value for the interior tile edge length $T$ that is feasible under all given conditions is $8$.",
            "answer": "$$\\boxed{8}$$"
        }
    ]
}