{
    "hands_on_practices": [
        {
            "introduction": "在将电化学-热求解器移植到 GPU 时，首要任务是诊断其性能瓶颈。屋顶线模型 (Roofline model) 是一个关键的分析工具，它将算法的计算强度（每次内存访问的浮点运算次数）与硬件的峰值性能联系起来。通过计算一个典型的模版（stencil）操作的计算强度 ，本练习将揭示为何这类求解器通常受限于内存带宽，并为后续的性能优化指明方向。",
            "id": "3917076",
            "problem": "一个用于锂离子电池包的高保真电化学-热模型，在一个均匀的笛卡尔网格上使用二阶中心有限差分格式对热传导进行离散化，并采用显式前向欧拉时间积分器。在图形处理单元（GPU）上，一个朴素的七点三维模板核函数使用以下逐节点操作模式将温度场从时间层 $n$ 更新到 $n+1$：从时间层 $n$ 的输入数组中读取中心温度值及其6个面相邻邻居的值，从一个单独的数组中读取一个体积热源，与预加载的标量系数计算加权线性组合，并将更新后的温度写入时间层 $n+1$ 的输出数组。假设使用双精度（每个值 $s=8$ 字节），不使用融合乘加操作，系数驻留在寄存器中，且 GPU 对全局存储操作不表现出“为所有权而读”的行为。所有全局内存访问都是完美合并的，且没有通过共享内存或缓存实现的线程间数据重用。\n\n对于单个晶格点的更新，算术工作量遵循以下显式形式：\n- 计算 $P_0=\\gamma_0 T_{i,j,k}$，并对6个面邻居中的每一个 $p \\in \\{1,\\dots,6\\}$，计算 $P_p=\\gamma_p T_{\\text{nb}(p)}$。\n- 通过成对相加将7个乘积项 $\\{P_0,P_1,\\dots,P_6\\}$ 累加成一个总和。\n- 计算 $P_s=\\sigma s_{i,j,k}$ 并将其加到累加和上，以生成 $T^{n+1}_{i,j,k}$。\n\n按照每次乘法或加法计为1次浮点运算且不发生乘加融合的约定来计算浮点运算次数。\n\n假设GPU具有以下硬件属性：\n- 在给定的访问模式下，持续全局内存带宽为 $B_{\\text{sust}}=1.2 \\times 10^{12}$ 字节/秒。\n- 双精度峰值吞吐量为 $P_{\\text{peak}}=9.5 \\times 10^{12}$ 浮点运算/秒。\n\n仅从算术强度和屋顶线性能模型的定义出发，完成以下任务：\n- 推导所述模板更新的算术强度，其定义为每字节全局内存流量的浮点运算次数。\n- 将此算术强度映射到屋顶线模型，以估算核函数在带宽限制下的可达到性能，并验证在给定的硬件参数下，该核函数是否受带宽限制。\n\n将可达到性能的最终数值答案四舍五入到3位有效数字，并以 GFLOP/s 为单位表示最终性能。最终答案必须是一个数字。",
            "solution": "问题陈述经评估为有效。其科学基础在于计算科学和高性能计算的原理，特别是利用了成熟的屋顶线性能模型。该问题是适定的，为得出唯一且有意义的解提供了所有必要的数据和约束。其语言客观而精确，其设置虽然因“无缓存”等假设而简化，但代表了朴素模板核函数实现的一个标准、可分析的案例。\n\n求解过程分三个阶段：首先，我们确定每次模板点更新所需的浮点运算次数（FLOPs）；其次，我们确定每次点更新的总全局内存流量（以字节为单位）；第三，我们使用这些量来计算算术强度并应用屋顶线模型来找出可达到的性能。\n\n**1. 浮点运算次数的计算**\n\n问题指明了单次晶格点更新的算术工作量。我们根据提供的分解来计算运算次数，其中每次乘法和每次加法都计为1个FLOP。\n\n- 计算中心点的贡献：$P_0 = \\gamma_0 T_{i,j,k}$。这是1次乘法。\n- 计算6个邻居的贡献：对于 $p \\in \\{1, \\dots, 6\\}$，计算 $P_p = \\gamma_p T_{\\text{nb}(p)}$。这是6次乘法。\n- 将7个乘积项 $\\{P_0, P_1, \\dots, P_6\\}$ 累加成一个总和。对7个数求和需要 $7-1=6$ 次成对加法。\n- 计算源项的贡献：$P_s = \\sigma s_{i,j,k}$。这是1次乘法。\n- 将源项加到累加和上：这是最后1次加法。\n\n每次点更新的总浮点运算次数 $N_{\\text{FLOPs}}$ 是所有乘法和加法次数的总和：\n$$N_{\\text{FLOPs}} = (1 + 6 + 1) \\text{ 次乘法} + (6 + 1) \\text{ 次加法}$$\n$$N_{\\text{FLOPs}} = 8 + 7 = 15 \\text{ FLOPs}$$\n\n**2. 全局内存流量的计算**\n\n问题指出每个线程更新网格中的一个点。我们计算这次单点更新与全局内存之间传输的总数据量。“无缓存或共享内存的数据重用”以及“完美合并访问”的假设将此计算简化为对读写次数的直接计数。数据为双精度，因此每个值需要 $s=8$ 字节。\n\n- **从全局内存读取：**\n  - 1个中心温度值（$T_{i,j,k}$）。\n  - 6个面相邻邻居的温度值。\n  - 从一个单独数组中读取的1个体积热源值（$s_{i,j,k}$）。\n  - 读取的值总数 = $1 + 6 + 1 = 8$ 个值。\n  - 读取的总字节数 = $8 \\text{ 个值} \\times 8 \\frac{\\text{字节}}{\\text{值}} = 64$ 字节。\n\n- **写入全局内存：**\n  - 1个更新后的温度值（$T^{n+1}_{i,j,k}$）写入输出数组。\n  - 写入的值总数 = 1个值。\n  - 写入的总字节数 = $1 \\text{ 个值} \\times 8 \\frac{\\text{字节}}{\\text{值}} = 8$ 字节。\n\n每次点更新的总内存流量（以字节为单位）$N_{\\text{Bytes}}$ 是读取字节数和写入字节数的总和：\n$$N_{\\text{Bytes}} = 64 \\text{ 字节 (读)} + 8 \\text{ 字节 (写)} = 72 \\text{ 字节}$$\n\n**3. 屋顶线性能模型的应用**\n\n算术强度 $I$ 定义为浮点运算次数与全局内存流量（以字节为单位）的比率。\n$$I = \\frac{N_{\\text{FLOPs}}}{N_{\\text{Bytes}}} = \\frac{15 \\text{ FLOPs}}{72 \\text{ 字节}} = \\frac{5}{24} \\frac{\\text{FLOPs}}{\\text{字节}}$$\n\n屋顶线模型预测，可达到的性能 $P_{\\text{attainable}}$ 是峰值计算吞吐量 $P_{\\text{peak}}$ 与内存子系统可支持的性能（即算术强度与持续内存带宽 $B_{\\text{sust}}$ 的乘积）之间的最小值。\n$$P_{\\text{attainable}} = \\min(P_{\\text{peak}}, I \\times B_{\\text{sust}})$$\n\n为了确定核函数是受带宽限制还是受计算限制，我们可以计算机器的“屋脊点” $I_{\\text{ridge}}$，它是使峰值计算性能饱和所需的最小算术强度。\n$$I_{\\text{ridge}} = \\frac{P_{\\text{peak}}}{B_{\\text{sust}}} = \\frac{9.5 \\times 10^{12} \\text{ FLOP/s}}{1.2 \\times 10^{12} \\text{ 字节/s}} = \\frac{9.5}{1.2} \\frac{\\text{FLOPs}}{\\text{字节}} \\approx 7.917 \\frac{\\text{FLOPs}}{\\text{字节}}$$\n\n核函数的算术强度为 $I = \\frac{5}{24} \\approx 0.2083$ FLOPs/字节。由于 $I  I_{\\text{ridge}}$，该核函数是**受带宽限制**的。其性能受内存带宽的限制。\n\n因此，可达到的性能由下式给出：\n$$P_{\\text{attainable}} = I \\times B_{\\text{sust}}$$\n$$P_{\\text{attainable}} = \\left(\\frac{5}{24} \\frac{\\text{FLOPs}}{\\text{字节}}\\right) \\times \\left(1.2 \\times 10^{12} \\frac{\\text{字节}}{\\text{s}}\\right)$$\n$$P_{\\text{attainable}} = \\frac{5 \\times 1.2}{24} \\times 10^{12} \\frac{\\text{FLOPs}}{\\text{s}} = \\frac{6}{24} \\times 10^{12} \\frac{\\text{FLOPs}}{\\text{s}}$$\n$$P_{\\text{attainable}} = 0.25 \\times 10^{12} \\frac{\\text{FLOPs}}{\\text{s}}$$\n\n问题要求答案以 GigaFLOPs/秒 (GFLOP/s) 为单位，其中 $1 \\text{ GFLOP/s} = 10^9$ FLOP/s。\n$$P_{\\text{attainable}} = 0.25 \\times 10^{12} \\text{ FLOP/s} = 250 \\times 10^9 \\text{ FLOP/s} = 250 \\text{ GFLOP/s}$$\n\n这个值是精确值。四舍五入到3位有效数字得到 $250$。",
            "answer": "$$\\boxed{250}$$"
        },
        {
            "introduction": "一旦确定内存带宽是性能瓶颈，下一步就是最大化有效数据传输速率。在 GPU 架构中，实现高带宽的关键在于“合并内存访问” (memory coalescing)，即确保一个线程束 (warp) 中的所有线程能够通过最少的内存事务来满足其数据请求。本练习  将从第一性原理出发，推导访问模式（步长和对齐）如何直接影响内存事务数量和有效带宽，从而为编写高效的访存代码提供理论基础。",
            "id": "3917106",
            "problem": "一个用于自动化电池设计和模拟的电化学-热有限体积核在图形处理单元（GPU）上运行。每个 GPU warp 由 $32$ 个线程组成，这些线程协同更新控制卷，通过每个线程从全局内存的一个大数组中读取一个双精度值（大小为 $8$ 字节），并对每次更新执行固定数量的浮点运算。假设以下经过充分检验的事实和定义：\n- 全局内存以大小为 $128$ 字节的对齐段（segment）提供服务（即，每次事务获取一个包含任何请求字的 $128$ 字节对齐段），硬件合并器（coalescer）发出满足 warp 请求所需的最少数量的此类段。\n- 一个双精度值占用 $8$ 字节，因此一个 $128$ 字节的段中有 $16$ 个双精度值。\n- 峰值可持续全局内存带宽为 $B_{g}$，峰值浮点吞吐量为 $F_{\\max}$。\n- 内核的算术强度（arithmetic intensity） $I$，定义为从全局内存中每获取一字节所执行的浮点运算次数，在电化学-热求解器典型的模板式（stencil-like）更新中较低。\n\nwarp 的第 $t$ 个线程（其中 $t \\in \\{0,1,\\dots,31\\}$）从一个非常大的双精度数组中读取元素索引\n$$\ne(t) = e_{0} + S\\,t,\n$$\n其中 $S \\in \\mathbb{N}$ 是连续线程之间的元素跨度（stride），$e_{0} \\in \\mathbb{N}$ 是基准元素索引。定义元素对齐余数\n$$\nr \\equiv e_{0} \\bmod 16,\n$$\n使得 $r \\in \\{0,1,\\dots,15\\}$。假设冷缓存（cold-cache）行为，因此不发生 warp 间的重用。\n\n任务：\n1. 从 roofline 模型出发，并且不使用任何未经检验的快捷公式，以符号方式论证为什么对于具有低算术强度 $I$ 的电化学-热模板核，其执行主要受全局内存访问而非算术吞吐量的限制。您的论证必须基于算术强度和带宽限制性能的基本定义。\n2. 仅使用所述的内存事务模型，从第一性原理推导出一个闭式表达式，用于表示 warp 的 $32$ 次加载所触及的不同 $128$ 字节段的数量，该表达式是 $S$ 和 $r$ 的函数。清晰地说明您所依赖的任何中间定义。\n3. 使用第 2 部分的结果，为此 warp 的内存访问获得归一化有效带宽\n$$\n\\eta(S,r) \\equiv \\frac{B_{\\text{eff}}(S,r)}{B_{g}},\n$$\n的闭式解析表达式，其中 $B_{\\text{eff}}(S,r)$ 是传递给有用数据的有效带宽。将每个 $128$ 字节的事务视为传输等量的时间等效带宽，并且在分子中只计算 $32 \\times 8$ 的有用字节。\n4. 陈述对于双精度数组，最小化段数量并因此最大化 $\\eta(S,r)$ 的对齐和跨度条件。\n\n答案规格：\n- 最终答案仅提供在第 3 部分中获得的 $\\eta(S,r)$ 的单个闭式解析表达式。在最终的方框表达式中不要包含任何单位；它是一个无量纲的比率。不要四舍五入。",
            "solution": "该问题被验证为具有科学依据、问题明确、客观且自洽。GPU 内存访问模型虽然经过简化，但基于高性能计算的既定原则，如内存合并、带宽和算术强度，使其适合进行严格分析。我们开始解答。\n\n解答分为四个部分，对应于问题描述中的任务。\n\n1. 从 roofline 模型出发，我们论证执行过程主要受全局内存访问限制。roofline 模型为计算核可实现的浮点性能 $F$ 提供了一个上限。该性能受限于峰值浮点吞吐量 $F_{\\max}$（单位：FLOP/s）或内存子系统可维持的性能 $F_{\\text{mem}}$。这表示为：\n$$\nF = \\min(F_{\\max}, F_{\\text{mem}})\n$$\n内存限制的性能 $F_{\\text{mem}}$ 由峰值全局内存带宽 $B_{g}$（单位：字节/秒）和核的算术强度 $I$（单位：FLOP/字节）决定。算术强度是执行的浮点运算次数与从全局内存传输的字节数之比。因此，内存带宽施加的性能限制是：\n$$\nF_{\\text{mem}} = I \\times B_{g}\n$$\n将其代入 roofline 模型，得到：\n$$\nF = \\min(F_{\\max}, I \\times B_{g})\n$$\n问题指出，电化学-热模板核表现出低的算术强度 $I$。性能限制从内存受限（memory-bound）转换到计算受限（compute-bound）的阈值强度 $I_{\\text{cross}}$，可以通过设置 $F_{\\max} = I_{\\text{cross}} \\times B_{g}$ 来找到，这得出 $I_{\\text{cross}} = F_{\\max} / B_{g}$。对于“低”算术强度，我们有 $I  I_{\\text{cross}}$。这意味着 $I \\times B_{g}  F_{\\max}$。因此，roofline 模型中两项的最小值是 $I \\times B_{g}$。可实现的性能因此为 $F = I \\times B_{g}$，这与内存带宽 $B_{g}$ 成正比。这表明，执行受限于从全局内存获取数据的速率，而不是算术计算的速度。该核是内存受限的。\n\n2. 我们推导一个闭式表达式，用于表示一个 warp 访问的不同 $128$ 字节段的数量 $N_{\\text{seg}}(S,r)$。一个 warp 由 $32$ 个线程组成，索引为 $t \\in \\{0, 1, \\dots, 31\\}$。每个线程读取一个大小为 $8$ 字节的双精度值。全局内存以 $128$ 字节的对齐段进行访问。因此，每个段包含 $128 / 8 = 16$ 个双精度值。\n\n线程 $t$ 访问的元素索引是 $e(t) = e_{0} + S\\,t$。索引为 $e$ 的元素的内存段索引由 $\\lfloor e/16 \\rfloor$ 给出。因此，线程 $t$ 访问的段是 $s(t) = \\lfloor (e_{0} + S\\,t) / 16 \\rfloor$。\n\n问题指出，硬件发出满足 warp 请求所需的“最少段数”。根据常见的简化合并模型，我们将其解释为从包含最小访问地址的段到包含最大访问地址的段的连续范围内的总段数。\n\n最小元素索引由线程 $t=0$ 访问：$e_{\\min} = e(0) = e_{0}$。\n最大元素索引由线程 $t=31$ 访问：$e_{\\max} = e(31) = e_{0} + 31S$。\n\n持有第一个元素的段是 $s_{\\min} = \\lfloor e_{0} / 16 \\rfloor$。\n持有最后一个元素的段是 $s_{\\max} = \\lfloor (e_{0} + 31S) / 16 \\rfloor$。\n\n该范围内的段数为 $N_{\\text{seg}} = s_{\\max} - s_{\\min} + 1$。代入 $s_{\\min}$ 和 $s_{\\max}$ 的表达式：\n$$\nN_{\\text{seg}}(S, e_{0}) = \\left\\lfloor \\frac{e_{0} + 31S}{16} \\right\\rfloor - \\left\\lfloor \\frac{e_{0}}{16} \\right\\rfloor + 1\n$$\n我们已知元素对齐余数 $r \\equiv e_{0} \\bmod 16$。这意味着 $e_{0}$ 可以写成 $e_{0} = 16k + r$ 的形式，其中 $k \\ge 0$ 为某个整数，$r \\in \\{0, 1, \\dots, 15\\}$。将此代入 $N_{\\text{seg}}$ 的表达式中：\n$$\nN_{\\text{seg}}(S, r) = \\left\\lfloor \\frac{16k + r + 31S}{16} \\right\\rfloor - \\left\\lfloor \\frac{16k + r}{16} \\right\\rfloor + 1\n$$\n对任意整数 $n$ 使用性质 $\\lfloor x+n \\rfloor = \\lfloor x \\rfloor + n$：\n$$\nN_{\\text{seg}}(S, r) = \\left(k + \\left\\lfloor \\frac{r + 31S}{16} \\right\\rfloor\\right) - \\left(k + \\left\\lfloor \\frac{r}{16} \\right\\rfloor\\right) + 1\n$$\n由于 $r \\in \\{0, 1, \\dots, 15\\}$，我们有 $\\lfloor r/16 \\rfloor = 0$。该表达式简化为：\n$$\nN_{\\text{seg}}(S, r) = \\left\\lfloor \\frac{r + 31S}{16} \\right\\rfloor + 1\n$$\n这是 warp 访问的内存段数量的闭式表达式。\n\n3. 我们推导归一化有效带宽 $\\eta(S,r)$。有效带宽 $B_{\\text{eff}}$ 是有用数据的传输速率。归一化有效带宽 $\\eta$ 是有用数据字节数与为该操作传输的总数据字节数之比。\n对于单次 warp 级别的内存访问，有用字节总数是 $32$ 个线程所需的数据量：\n$$\n\\text{Useful Data} = 32 \\text{ 线程} \\times 8 \\frac{\\text{字节}}{\\text{线程}} = 256 \\text{ 字节}\n$$\n从全局内存传输的总字节数是访问的段数 $N_{\\text{seg}}(S,r)$ 乘以每段的大小 $128$ 字节：\n$$\n\\text{Total Data Transferred} = N_{\\text{seg}}(S, r) \\times 128 \\text{ 字节}\n$$\n归一化有效带宽是这两个量的比值：\n$$\n\\eta(S,r) = \\frac{\\text{Useful Data}}{\\text{Total Data Transferred}} = \\frac{256}{128 \\times N_{\\text{seg}}(S, r)} = \\frac{2}{N_{\\text{seg}}(S, r)}\n$$\n将第 2 部分的 $N_{\\text{seg}}(S,r)$ 表达式代入，我们得到最终的解析表达式：\n$$\n\\eta(S,r) = \\frac{2}{\\left\\lfloor \\frac{r + 31S}{16} \\right\\rfloor + 1}\n$$\n\n4. 我们陈述最大化 $\\eta(S,r)$ 的跨度 $S$ 和对齐 $r$ 的条件。为了最大化 $\\eta(S,r)$，我们必须最小化其分母 $N_{\\text{seg}}(S,r)$。可能的最小段数由总有用数据决定。由于需要 $256$ 字节的数据，且每段为 $128$ 字节，因此必须至少获取 $256/128 = 2$ 个段。因此，$N_{\\text{seg}}(S,r)$ 的最小可能值为 $2$。\n我们寻找使 $N_{\\text{seg}}(S,r) = 2$ 的条件：\n$$\n\\left\\lfloor \\frac{r + 31S}{16} \\right\\rfloor + 1 = 2 \\implies \\left\\lfloor \\frac{r + 31S}{16} \\right\\rfloor = 1\n$$\n这个向下取整的方程等价于不等式：\n$$\n1 \\le \\frac{r + 31S}{16}  2\n$$\n两边乘以 $16$ 得：\n$$\n16 \\le r + 31S  32\n$$\n已知 $S \\in \\mathbb{N}$（因此 $S \\ge 1$）且 $r \\in \\{0, 1, \\dots, 15\\}$。如果 $S \\ge 2$，那么 $31S \\ge 62$，这违反了不等式的上界。因此，我们必须有 $S=1$。\n将 $S=1$ 代入不等式：\n$$\n16 \\le r + 31  32 \\implies -15 \\le r  1\n$$\n已知 $r$ 必须在集合 $\\{0, 1, \\dots, 15\\}$ 中，满足 $-15 \\le r  1$ 的唯一值是 $r=0$。\n因此，在 $S=1$ 和 $r=0$ 的条件下，段数被最小化，从而有效带宽被最大化。这对应于单位跨度访问（$S=1$），其中基地址与一个 $16$ 元素块的起始位置（$r=0$）完全对齐，该位置也是一个 $128$ 字节内存段的起始位置。在这种情况下，$\\eta(1,0) = 2/(\\lfloor 31/16 \\rfloor + 1) = 2/(1+1) = 1$，表示 $100\\%$ 的内存效率。",
            "answer": "$$\n\\boxed{\\frac{2}{\\left\\lfloor \\frac{r + 31S}{16} \\right\\rfloor + 1}}\n$$"
        },
        {
            "introduction": "为了从根本上突破内存墙的限制，我们必须减少对全局内存的访问次数，其核心思想是数据复用。GPU 上的片上共享内存 (shared memory) 提供了一个由程序员控制的高速缓存，通过“分块” (tiling) 技术可以极大地提高模版计算中的数据复用率。本练习  构建了一个优化问题：在满足共享内存容量和寄存器数量等硬件约束的前提下，如何选择最优的块大小以最大化计算强度，从而显著提升内核性能。",
            "id": "3917132",
            "problem": "在一个高保真度的电化学-热电池组模拟器中，热传导子求解器通过一种用于三维热方程的显式有限差分格式来推进温度场，其中每次更新使用中心点及其六个轴对齐的邻居点。在图形处理单元（GPU）上，该求解器将网格映射到线程块，并使用片上共享内存来暂存一个立方体瓦片（cubic tile）的网格值，以便每个线程更新瓦片的一个内部单元。为了在不产生额外全局内存流量的情况下正确计算邻居差值，共享内存瓦片必须在内部区域周围的每个方向上包含一个单元厚度的光环（halo）。\n\n假设目标 GPU 上的一个流式多处理器（Streaming Multiprocessor, SM）具有以下科学上现实的配置和约束：\n- 使用双精度存储，因此每个标量值需要 $b = 8$ 字节。\n- 在六个面上，光环厚度均为 $h = 1$ 个单元。\n- 每个线程处理一个内部单元并消耗 $r = 64$ 个寄存器。\n- 每个 SM 的总共享内存容量为 $S_{\\mathrm{SM}} = 98{,}304$ 字节，每个块的共享内存分配上限为 $S_{\\mathrm{block,max}} = 49{,}152$ 字节。\n- 每个 SM 的总寄存器文件包含 $R_{\\mathrm{SM}} = 65{,}536$ 个寄存器。\n- 为实现充分的延迟隐藏和内存-计算重叠，调度器要求每个 SM 至少有 $m = 2$ 个驻留（并发）的线程块。\n\n设一个块处理的立方体瓦片的内部区域边长为 $T$，因此有 $T^{3}$ 个内部线程，并且包括光环在内的共享内存中存储了 $(T+2)^{3}$ 个值。从第一性原理出发，推导 $T$ 在共享内存使用和寄存器可用性方面必须满足的约束，以保证每个 SM 上至少有 $m = 2$ 个驻留块。论证为什么在这些约束下，最大化此模板计算的算术强度可以简化为在这些约束下最大化 $T$。使用所提供的参数，确定可行的最大整数 $T$。将 $T$ 报告为一个不带单位的纯数字。无需四舍五入。",
            "solution": "该问题陈述是一个基于高性能计算和数值方法原理的适定优化问题。所有常数和条件均已提供，且科学上现实、内部一致。未发现任何缺陷。因此，我们可以开始求解。\n\n问题要求做三件事：首先，推导内部立方体瓦片边长 $T$ 必须满足的约束，以保证在一个流式多处理器（SM）上至少可以驻留 $m=2$ 个线程块。其次，论证为什么在这些约束下最大化算术强度可以简化为最大化 $T$。第三，使用所提供的参数确定 $T$ 的最大可行整数值。\n\n让我们从形式化 GPU 硬件资源（共享内存和寄存器）施加的约束开始。\n\n**1. 共享内存约束**\n\n单个线程块处理一个体积为 $T \\times T \\times T = T^3$ 单元的内部区域。为了使用 7 点模板更新该内部区域边界处的单元，需要来自相邻单元数据的光环。问题陈述此光环在立方体的六个面上各有 $h=1$ 个单元的厚度。\n\n因此，暂存在一个块的共享内存中的总立方体瓦片数据的维度为 $(T+2h) \\times (T+2h) \\times (T+2h)$。给定 $h=1$，维度为 $(T+2) \\times (T+2) \\times (T+2)$。一个块的共享内存瓦片中的标量总数为 $(T+2)^3$。\n\n每个标量值以双精度存储，需要 $b=8$ 字节。单个线程块所需的总共享内存 $S_{\\text{block}}$ 为：\n$$S_{\\text{block}} = b(T+2h)^3 = 8(T+2)^3 \\text{ 字节}$$\n\n共享内存的使用有两个限制。首先，单个块使用的内存不能超过每个块的最大值 $S_{\\text{block,max}} = 49{,}152$ 字节。\n$$8(T+2)^3 \\le 49{,}152$$\n$$(T+2)^3 \\le \\frac{49{,}152}{8}$$\n$$(T+2)^3 \\le 6144 \\quad (\\text{约束 1a})$$\n\n其次，为确保延迟隐藏，SM 上必须至少驻留 $m=2$ 个块。这 $m$ 个块消耗的总共享内存不能超过 SM 的总容量 $S_{\\mathrm{SM}} = 98{,}304$ 字节。\n$$m \\cdot S_{\\text{block}} \\le S_{\\mathrm{SM}}$$\n$$2 \\cdot 8(T+2)^3 \\le 98{,}304$$\n$$16(T+2)^3 \\le 98{,}304$$\n$$(T+2)^3 \\le \\frac{98{,}304}{16}$$\n$$(T+2)^3 \\le 6144 \\quad (\\text{约束 1b})$$\n\n在这种情况下，对于 $m=2$ 个块，每个块的限制和 SM 的总限制得出了相同的约束。这是因为 SM 的总容量恰好是每个块上限的两倍（$98{,}304 = 2 \\times 49{,}152$），这是在并发块之间划分资源的 GPU 架构中的一个共同特征。因此，主要的共享内存约束是 $(T+2)^3 \\le 6144$。\n\n**2. 寄存器约束**\n\n每个线程块由更新 $T^3$ 个内部单元的线程组成，因此每个块有 $N_{\\text{threads}} = T^3$ 个线程。每个线程消耗 $r = 64$ 个寄存器。单个块所需的寄存器总数 $R_{\\text{block}}$ 为：\n$$R_{\\text{block}} = N_{\\text{threads}} \\cdot r = T^3 \\cdot 64$$\n\n要有 $m=2$ 个驻留块，总寄存器使用量不得超过 SM 的总寄存器文件容量 $R_{\\mathrm{SM}} = 65{,}536$。\n$$m \\cdot R_{\\text{block}} \\le R_{\\mathrm{SM}}$$\n$$2 \\cdot (64 T^3) \\le 65{,}536$$\n$$128 T^3 \\le 65{,}536$$\n$$T^3 \\le \\frac{65{,}536}{128}$$\n$$T^3 \\le 512 \\quad (\\text{约束 2})$$\n\n总而言之，$T$ 必须满足的两个主要约束是：\n1. 共享内存：$(T+2)^3 \\le 6144$\n2. 寄存器：$T^3 \\le 512$\n此外，$T$ 必须是一个正整数，$T \\ge 1$。\n\n**3. 最大化算术强度**\n\n算术强度 $I$ 是指执行的浮点运算次数（FLOPs）与从慢速内存（全局内存）传输到快速内存（片上共享内存）的数据量（以字节为单位）之比。最大化此比率是性能的关键，因为它意味着每字节昂贵的内存流量能完成更多的计算。\n\n对于一个处理 $T^3$ 个内部单元的块，FLOPs 的数量与更新的单元数量成正比。设 $F_{\\text{op}}$ 为每个单元更新的 FLOPs 数量。\n$$\\text{每个块的 FLOPs} = F_{\\text{op}} \\cdot T^3$$\n\n为此块从全局内存加载到共享内存的数据是整个 $(T+2)^3$ 大小的瓦片。传输的字节数为：\n$$\\text{每个块的字节数} = b \\cdot (T+2)^3 = 8(T+2)^3$$\n\n因此，算术强度为：\n$$I = \\frac{\\text{每个块的 FLOPs}}{\\text{每个块的字节数}} = \\frac{F_{\\text{op}} \\cdot T^3}{b \\cdot (T+2)^3} = \\frac{F_{\\text{op}}}{b} \\left(\\frac{T}{T+2}\\right)^3$$\n\n由于 $F_{\\text{op}}$ 和 $b$ 在此问题中是常数，最大化 $I$ 等价于最大化 $\\left(\\frac{T}{T+2}\\right)^3$ 这一项。函数 $f(T) = \\frac{T}{T+2} = 1 - \\frac{2}{T+2}$ 对于 $T > 0$ 是一个单调递增函数。随着 $T$ 增加，$\\frac{2}{T+2}$ 减小，因此 $f(T)$ 增加。因此，最大化此模板计算的算术强度可以简化为寻找满足硬件约束的最大可能 $T$ 值。\n\n**4. 确定最大可行整数 T**\n\n我们必须找到满足两个导出约束的最大整数 $T$。\n\n从寄存器约束出发：\n$$T^3 \\le 512$$\n$$T \\le \\sqrt[3]{512}$$\n由于 $8^3 = 512$，这得出：\n$$T \\le 8$$\n\n从共享内存约束出发：\n$$(T+2)^3 \\le 6144$$\n$$T+2 \\le \\sqrt[3]{6144}$$\n我们可以通过测试整数的立方来找到整数边界：\n$18^3 = 5832$\n$19^3 = 6859$\n因为 $5832 \\le 6144  6859$，所以 $T+2$ 的最大整数值为 $18$。\n$$T+2 \\le 18$$\n$$T \\le 16$$\n\n为了同时满足两个约束，$T$ 必须小于或等于两个上界中的最小值：\n$$T \\le \\min(8, 16)$$\n$$T \\le 8$$\n\n限制性资源是寄存器文件。在所有给定条件下，内部瓦片边长 $T$ 的最大可行整数值为 $8$。",
            "answer": "$$\\boxed{8}$$"
        }
    ]
}