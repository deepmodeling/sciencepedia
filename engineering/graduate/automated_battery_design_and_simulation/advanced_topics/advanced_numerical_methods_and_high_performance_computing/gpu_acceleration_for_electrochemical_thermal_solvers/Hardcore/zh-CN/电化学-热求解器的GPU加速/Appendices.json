{
    "hands_on_practices": [
        {
            "introduction": "为了有效地加速电化学-热求解器，我们首先必须理解硬件的根本性能限制。Roofline模型为此提供了一个强大的可视化框架，它将一个计算核心的算术强度（即计算量与内存访问量的比率）与GPU的峰值性能联系起来。本练习 () 将指导您计算一个典型模板操作的算术强度，并使用Roofline模型来判断计算过程是受限于内存带宽还是处理器速度，这是任何优化工作都必须走出的关键第一步。",
            "id": "3917076",
            "problem": "锂离子电池组的高保真电化学-热模型在均匀笛卡尔网格上进行离散化，热传导采用二阶中心有限差分格式，时间积分采用显式前向欧拉法。在图形处理单元（GPU）上，一个朴素的七点三维模板核使用以下逐节点操作模式将温度场从时间层级 $n$ 更新到 $n+1$：从时间层级 $n$ 的输入数组中读取中心温度值及其 $6$ 个面相邻邻居的值，从一个单独的数组中读取一个体积热源，用预加载的标量系数计算加权线性组合，并将更新后的温度写入时间层级 $n+1$ 的输出数组中。假设使用双精度（每个值 $s=8$ 字节），不使用融合乘加运算，系数驻留在寄存器中，且GPU对于全局存储没有“读所有权”（read-for-ownership）行为。所有全局内存访问都是完美合并的，并且没有通过共享内存或缓存实现的线程间数据重用。\n\n对于单个晶格点的更新，算术工作遵循以下显式形式：\n- 计算 $P_0=\\gamma_0 T_{i,j,k}$，并为 $6$ 个面相邻邻居中的每一个 $p \\in \\{1,\\dots,6\\}$ 计算 $P_p=\\gamma_p T_{\\text{nb}(p)}$。\n- 通过两两相加，将 $7$ 个乘积 $\\{P_0,P_1,\\dots,P_6\\}$ 累加成一个总和。\n- 计算 $P_s=\\sigma s_{i,j,k}$ 并将其加到累加和中，以产生 $T^{n+1}_{i,j,k}$。\n\n按照每个乘法或加法计为 $1$ 次浮点运算且不发生乘加融合的约定来计算浮点运算次数。\n\n假设GPU具有以下硬件属性：\n- 在给定的访问模式下，持续全局内存带宽为 $B_{\\text{sust}}=1.2 \\times 10^{12}$ 字节/秒。\n- 峰值双精度吞吐量为 $P_{\\text{peak}}=9.5 \\times 10^{12}$ 次浮点运算/秒。\n\n仅从算术强度和屋顶线性能模型的定义出发，完成以下任务：\n- 推导所述模板更新的算术强度，其定义为每次全局内存流量（字节）所对应的浮点运算次数。\n- 将此算术强度映射到屋顶线模型，以估计内核可达到的受带宽限制的性能，并验证在给定的硬件参数下，该内核是否受带宽限制。\n\n将可达性能的最终数值答案四舍五入到 $3$ 位有效数字，并以 GFLOP/s 为单位表示最终性能。最终答案必须是单个数字。",
            "solution": "问题陈述经评估有效。它在科学上基于计算科学和高性能计算的原理，特别是利用了成熟的屋顶线性能模型。该问题定义明确，为得出唯一且有意义的解提供了所有必要的数据和约束。其语言客观精确，并且其设置（尽管因缺少缓存等假设而简化）代表了朴素模板核实现的标准、可分析案例。\n\n求解过程分三个阶段：首先，我们确定每次模板点更新的浮点运算次数（FLOPs）；其次，我们确定每次点更新的总全局内存流量（以字节为单位）；第三，我们使用这些量来计算算术强度，并应用屋顶线模型来找出可达到的性能。\n\n**1. 浮点运算次数的计算**\n\n问题指明了单个晶格点更新的算术工作。我们根据提供的分解来计算操作次数，其中每次乘法和每次加法都计为 $1$ 次浮点运算。\n\n- 计算中心点的贡献：$P_0 = \\gamma_0 T_{i,j,k}$。这是 $1$ 次乘法。\n- 计算 $6$ 个邻居的贡献：$P_p = \\gamma_p T_{\\text{nb}(p)}$，其中 $p \\in \\{1, \\dots, 6\\}$。这是 $6$ 次乘法。\n- 将 $7$ 个乘积项 $\\{P_0, P_1, \\dots, P_6\\}$ 累加成一个总和。对 $7$ 个数求和需要 $7-1=6$ 次两两相加。\n- 计算源项的贡献：$P_s = \\sigma s_{i,j,k}$。这是 $1$ 次乘法。\n- 将源项加到累加和中：这是最后 $1$ 次加法。\n\n每次点更新的总浮点运算次数 $N_{\\text{FLOPs}}$ 是所有乘法和加法的总和：\n$$N_{\\text{FLOPs}} = (1 + 6 + 1) \\text{ 次乘法} + (6 + 1) \\text{ 次加法}$$\n$$N_{\\text{FLOPs}} = 8 + 7 = 15 \\text{ FLOPs}$$\n\n**2. 全局内存流量的计算**\n\n问题陈述每个线程更新网格中的一个点。我们计算此次单点更新与全局内存之间的数据传输总量。没有通过缓存或共享内存进行数据重用以及完美合并访问的假设，将此简化为直接计算读和写的次数。数据为双精度，因此每个值需要 $s=8$ 字节。\n\n- **从全局内存读取：**\n  - $1$ 个中心温度值 ($T_{i,j,k}$)。\n  - $6$ 个面相邻邻居的温度值。\n  - 从一个单独的数组中读取 $1$ 个体积热源值 ($s_{i,j,k}$)。\n  - 读取总值数 = $1 + 6 + 1 = 8$ 个值。\n  - 读取总字节数 = $8 \\text{ 个值} \\times 8 \\frac{\\text{字节}}{\\text{值}} = 64$ 字节。\n\n- **写入全局内存：**\n  - 将 $1$ 个更新后的温度值 ($T^{n+1}_{i,j,k}$) 写入输出数组。\n  - 写入总值数 = $1$ 个值。\n  - 写入总字节数 = $1 \\text{ 个值} \\times 8 \\frac{\\text{字节}}{\\text{值}} = 8$ 字节。\n\n每次点更新的总内存流量（以字节为单位）$N_{\\text{Bytes}}$ 是读取字节数和写入字节数的总和：\n$$N_{\\text{Bytes}} = 64 \\text{ 字节 (读)} + 8 \\text{ 字节 (写)} = 72 \\text{ 字节}$$\n\n**3. 屋顶线性能模型的应用**\n\n算术强度 $I$ 定义为浮点运算次数与全局内存流量（以字节为单位）的比率。\n$$I = \\frac{N_{\\text{FLOPs}}}{N_{\\text{Bytes}}} = \\frac{15 \\text{ FLOPs}}{72 \\text{ 字节}} = \\frac{5}{24} \\frac{\\text{FLOPs}}{\\text{字节}}$$\n\n屋顶线模型预测，可达性能 $P_{\\text{attainable}}$ 是峰值计算吞吐量 $P_{\\text{peak}}$ 和内存子系统可维持性能的最小值，后者是算术强度与持续内存带宽 $B_{\\text{sust}}$ 的乘积。\n$$P_{\\text{attainable}} = \\min(P_{\\text{peak}}, I \\times B_{\\text{sust}})$$\n\n为了确定内核是受带宽限制还是受计算限制，我们可以计算机器的“屋脊点” $I_{\\text{ridge}}$，这是使峰值计算性能饱和所需的最小算术强度。\n$$I_{\\text{ridge}} = \\frac{P_{\\text{peak}}}{B_{\\text{sust}}} = \\frac{9.5 \\times 10^{12} \\text{ FLOP/s}}{1.2 \\times 10^{12} \\text{ 字节/s}} = \\frac{9.5}{1.2} \\frac{\\text{FLOPs}}{\\text{字节}} \\approx 7.917 \\frac{\\text{FLOPs}}{\\text{字节}}$$\n\n内核的算术强度为 $I = \\frac{5}{24} \\approx 0.2083$ FLOPs/byte。由于 $I  I_{\\text{ridge}}$，该内核**受带宽限制**。其性能受内存带宽的限制。\n\n因此，可达性能由下式给出：\n$$P_{\\text{attainable}} = I \\times B_{\\text{sust}}$$\n$$P_{\\text{attainable}} = \\left(\\frac{5}{24} \\frac{\\text{FLOPs}}{\\text{字节}}\\right) \\times \\left(1.2 \\times 10^{12} \\frac{\\text{字节}}{\\text{s}}\\right)$$\n$$P_{\\text{attainable}} = \\frac{5 \\times 1.2}{24} \\times 10^{12} \\frac{\\text{FLOPs}}{\\text{s}} = \\frac{6}{24} \\times 10^{12} \\frac{\\text{FLOPs}}{\\text{s}}$$\n$$P_{\\text{attainable}} = 0.25 \\times 10^{12} \\frac{\\text{FLOPs}}{\\text{s}}$$\n\n问题要求答案以千兆浮点运算每秒（GFLOP/s）为单位，其中 $1 \\text{ GFLOP/s} = 10^9$ FLOP/s。\n$$P_{\\text{attainable}} = 0.25 \\times 10^{12} \\text{ FLOP/s} = 250 \\times 10^9 \\text{ FLOP/s} = 250 \\text{ GFLOP/s}$$\n\n这个值是精确值。四舍五入到 $3$ 位有效数字得到 $250$。",
            "answer": "$$\\boxed{250}$$"
        },
        {
            "introduction": "在认识到许多求解器核心受限于内存带宽后，一个主要的优化策略便是改善数据局部性与重用。通过将一块数据的“瓦片”加载到GPU高速的片上共享内存中，线程可以无需重复从较慢的全局内存中读取数据就能访问邻近数据，从而提高算术强度。本实践 () 要求您通过平衡更大瓦片带来的收益与共享内存容量和寄存器可用性的严格限制，来推导出最优的瓦片尺寸，这是GPU核心设计中的一个核心权衡。",
            "id": "3917132",
            "problem": "在一个高保真电化学-热电池包模拟器中，热传导子求解器通过一个三维热方程的显式有限差分格式来推进温度场，其中每次更新使用中心点及其六个轴对齐的邻居点。在图形处理单元（GPU）上，该求解器将网格映射到线程块，并使用片上共享内存来暂存一个立方体瓦片网格值，以便每个线程更新瓦片的一个内部单元。为了在不产生额外全局内存流量的情况下正确计算邻居差分，共享内存瓦片必须在内部区域的每个方向上包含一个单元厚度的光环（halo）。\n\n假设目标 GPU 上的流式多处理器（SM）具有以下科学上真实的配置和约束：\n- 使用双精度存储，因此每个标量值需要 $b = 8$ 字节。\n- 在六个面上，光环厚度均为 $h = 1$ 个单元。\n- 每个线程处理一个内部单元，并消耗 $r = 64$ 个寄存器。\n- 每个 SM 的总共享内存容量为 $S_{\\mathrm{SM}} = 98{,}304$ 字节，每个块的共享内存分配上限为 $S_{\\mathrm{block,max}} = 49{,}152$ 字节。\n- 每个 SM 的总寄存器文件包含 $R_{\\mathrm{SM}} = 65{,}536$ 个寄存器。\n- 为了实现充分的延迟隐藏和内存-计算重叠，调度器要求每个 SM 至少有 $m = 2$ 个驻留（并发）线程块。\n\n设一个块处理的立方体瓦片的内部区域边长为 $T$，因此有 $T^{3}$ 个内部线程，共享内存中存储的值（包括光环）有 $(T+2)^{3}$ 个。从第一性原理推导 $T$ 在共享内存使用和寄存器可用性方面必须满足的约束条件，以保证每个 SM 至少有 $m = 2$ 个驻留块。论证为什么在这些约束下最大化此模板的算术强度可以简化为最大化满足这些约束的 $T$。使用所提供的参数，确定可行的最大整数 $T$。将 $T$ 报告为一个无单位的纯数字。无需四舍五入。",
            "solution": "问题陈述是一个基于高性能计算和数值方法原理的适定优化问题。所有常数和条件都已提供，科学上真实且内部一致。未发现任何缺陷。因此，我们可以着手求解。\n\n问题要求做三件事：首先，推导内部立方体瓦片边长 $T$ 必须满足的约束条件，以保证至少有 $m=2$ 个线程块可以驻留在流式多处理器（SM）上。其次，论证为什么在这些约束下最大化算术强度可以简化为最大化 $T$。第三，使用所提供的参数确定可行的最大整数值 $T$。\n\n让我们从形式化 GPU 硬件资源（共享内存和寄存器）施加的约束开始。\n\n**1. 共享内存约束**\n\n单个线程块处理一个体积为 $T \\times T \\times T = T^3$ 单元的内部区域。为了使用 7 点模板更新此内部区域边界上的单元，需要来自相邻单元的数据光环。问题陈述此光环在立方体的六个面上各有 $h=1$ 个单元的厚度。\n\n因此，暂存在一个块的共享内存中的总立方体数据瓦片的维度为 $(T+2h) \\times (T+2h) \\times (T+2h)$。给定 $h=1$，维度为 $(T+2) \\times (T+2) \\times (T+2)$。一个块的共享内存瓦片中的标量值总数为 $(T+2)^3$。\n\n每个标量值以双精度存储，需要 $b=8$ 字节。单个线程块所需的总共享内存 $S_{\\text{block}}$ 为：\n$$S_{\\text{block}} = b(T+2h)^3 = 8(T+2)^3 \\text{ 字节}$$\n\n共享内存的使用有两个限制。首先，单个块使用的内存不能超过每块的最大值 $S_{\\text{block,max}} = 49{,}152$ 字节。\n$$8(T+2)^3 \\le 49{,}152$$\n$$(T+2)^3 \\le \\frac{49{,}152}{8}$$\n$$(T+2)^3 \\le 6144 \\quad (\\text{约束 1a})$$\n\n其次，为确保延迟隐藏，至少要有 $m=2$ 个块驻留在 SM 上。这 $m$ 个块消耗的总共享内存不能超过 SM 的总容量 $S_{\\mathrm{SM}} = 98{,}304$ 字节。\n$$m \\cdot S_{\\text{block}} \\le S_{\\mathrm{SM}}$$\n$$2 \\cdot 8(T+2)^3 \\le 98{,}304$$\n$$16(T+2)^3 \\le 98{,}304$$\n$$(T+2)^3 \\le \\frac{98{,}304}{16}$$\n$$(T+2)^3 \\le 6144 \\quad (\\text{约束 1b})$$\n\n在这种情况下，每块的限制和 $m=2$ 个块的总 SM 限制得出了相同的约束。这是因为 SM 的总容量恰好是每块上限的两倍（$98{,}304 = 2 \\times 49{,}152$），这是 GPU 架构中在并发块之间划分资源的常见特征。因此，主导的共享内存约束是 $(T+2)^3 \\le 6144$。\n\n**2. 寄存器约束**\n\n每个线程块由更新 $T^3$ 个内部单元的线程组成，因此每个块有 $N_{\\text{threads}} = T^3$ 个线程。每个线程消耗 $r = 64$ 个寄存器。单个块所需的总寄存器数 $R_{\\text{block}}$ 为：\n$$R_{\\text{block}} = N_{\\text{threads}} \\cdot r = T^3 \\cdot 64$$\n\n为了有 $m=2$ 个驻留块，总寄存器使用量不得超过 SM 的总寄存器文件容量 $R_{\\mathrm{SM}} = 65{,}536$。\n$$m \\cdot R_{\\text{block}} \\le R_{\\mathrm{SM}}$$\n$$2 \\cdot (64 T^3) \\le 65{,}536$$\n$$128 T^3 \\le 65{,}536$$\n$$T^3 \\le \\frac{65{,}536}{128}$$\n$$T^3 \\le 512 \\quad (\\text{约束 2})$$\n\n总之，$T$ 必须满足的两个主导约束是：\n1. 共享内存：$(T+2)^3 \\le 6144$\n2. 寄存器：$T^3 \\le 512$\n此外，$T$ 必须是正整数，$T \\ge 1$。\n\n**3. 最大化算术强度**\n\n算术强度 $I$ 是执行的浮点运算（FLOPs）次数与从慢速内存（全局内存）传输到快速内存（片上共享内存）的数据量（以字节为单位）之比。最大化该比率是性能的关键，因为它表示每字节昂贵的内存流量能完成更多的计算。\n\n对于处理 $T^3$ 个内部单元的块，FLOPs 的数量与更新的单元数成正比。设 $F_{\\text{op}}$ 为每个单元更新的 FLOPs 数。\n$$\\text{每块的 FLOPs} = F_{\\text{op}} \\cdot T^3$$\n\n为此块从全局内存加载到共享内存的数据是整个 $(T+2)^3$ 的瓦片。传输的字节数为：\n$$\\text{每块的字节数} = b \\cdot (T+2)^3 = 8(T+2)^3$$\n\n因此，算术强度为：\n$$I = \\frac{\\text{每块的 FLOPs}}{\\text{每块的字节数}} = \\frac{F_{\\text{op}} \\cdot T^3}{b \\cdot (T+2)^3} = \\frac{F_{\\text{op}}}{b} \\left(\\frac{T}{T+2}\\right)^3$$\n\n由于 $F_{\\text{op}}$ 和 $b$ 在此问题中是常数，最大化 $I$ 等同于最大化 $\\left(\\frac{T}{T+2}\\right)^3$ 这一项。函数 $f(T) = \\frac{T}{T+2} = 1 - \\frac{2}{T+2}$ 对于 $T > 0$ 是一个单调递增函数。随着 $T$ 的增加，$\\frac{2}{T+2}$ 减小，因此 $f(T)$ 增加。因此，最大化此模板计算的算术强度简化为找到满足硬件约束的最大可能值 $T$。\n\n**4. 确定最大的可行整数 T**\n\n我们必须找到满足两个导出约束的最大整数 $T$。\n\n从寄存器约束：\n$$T^3 \\le 512$$\n$$T \\le \\sqrt[3]{512}$$\n由于 $8^3 = 512$，这给出：\n$$T \\le 8$$\n\n从共享内存约束：\n$$(T+2)^3 \\le 6144$$\n$$T+2 \\le \\sqrt[3]{6144}$$\n我们可以通过测试整数的立方来找到整数边界：\n$18^3 = 5832$\n$19^3 = 6859$\n由于 $5832 \\le 6144  6859$，因此 $T+2$ 的最大整数值为 $18$。\n$$T+2 \\le 18$$\n$$T \\le 16$$\n\n为了同时满足两个约束，$T$ 必须小于或等于两个上界中的最小值：\n$$T \\le \\min(8, 16)$$\n$$T \\le 8$$\n\n限制性资源是寄存器文件。在所有给定条件下，内部瓦片边长 $T$ 的最大可行整数值为 $8$。",
            "answer": "$$\\boxed{8}$$"
        },
        {
            "introduction": "即使采用了优化的数据访问模式，实现高性能仍然取决于能否有效利用GPU的并行处理单元。占用率（Occupancy）是一个关键指标，它衡量了在一个流式多处理器（SM）上能够并发运行的活动线程数量，这对于隐藏不可避免的内存操作延迟至关重要。在最后一个练习中 ()，您将分析一个核心的资源需求（寄存器和共享内存）如何限制其占用率，并计算一个“延迟隐藏因子”，以量化地评估是否存在足够的并行度来保持硬件繁忙。",
            "id": "3917080",
            "problem": "一个图形处理单元 (GPU) 的流式多处理器 (SM) 在一个电池组模型中执行一个有限体积电化学-热更新内核，它使用共享内存片 (shared memory tiles) 来处理局部守恒律模板 (stencils)，并使用每线程寄存器来存储中间电化学反应速率。考虑一个具有以下物理资源限制和调度模型的 SM：\n- 每个 SM 的总寄存器文件容量：$R_{\\mathrm{SM}} = 65536$ 个寄存器 (每个寄存器为 32 位)。\n- 每个 SM 的总共享内存：$S_{\\mathrm{SM}} = 96\\,\\mathrm{KB}$。\n- 每个 SM 的最大驻留线程数：$T_{\\max} = 2048$。\n- 每个 SM 的最大驻留线程块数：$B_{\\max} = 32$。\n- 线程束大小：$W_{\\mathrm{size}} = 32$ 个线程。\n- 线程束调度器以轮询方式在所有就绪的线程束中，每个周期从一个线程束中发射一条指令（单发射，轮询），并且该内核主要内存操作的一级 (L1) 缓存命中延迟为 $L_{\\mathrm{mem}} = 20$ 个周期。\n\n内核启动参数以及每线程/每块的资源使用情况如下：\n- 每块的线程数：$T_{\\mathrm{block}} = 256$。\n- 每线程的寄存器数：$R_{\\mathrm{thread}} = 80$。\n- 每块的共享内存：$S_{\\mathrm{block}} = 24\\,\\mathrm{KB}$。\n\n从 SM 级别的占用率和资源绑定的定义出发，使用基本限制来确定由每种资源导致的单个 SM 上的最大驻留块数，并由此计算出每个 SM 的活动线程束数量。将占用率定义为分数\n$$\nO \\equiv \\frac{W_{\\mathrm{active}}}{W_{\\max}},\n$$\n其中 $W_{\\mathrm{active}}$ 是驻留在 SM 上的活动线程束数量，而 $W_{\\max} \\equiv \\frac{T_{\\max}}{W_{\\mathrm{size}}}$ 是每个 SM 的最大线程束数量。\n\n在所述的单发射轮询调度模型下，将延迟隐藏因子定义为\n$$\nH \\equiv \\frac{W_{\\mathrm{active}}}{L_{\\mathrm{mem}}}.\n$$\n$H \\geq 1$ 的值表示内存延迟被线程束级并发完全隐藏；$H  1$ 表示部分延迟仍然暴露。\n\n计算此内核-SM配对的 $H$ 值。将最终答案表示为一个无单位的十进制数，并四舍五入到四位有效数字。",
            "solution": "问题要求计算在流式多处理器 (SM) 上执行的给定 GPU 内核的延迟隐藏因子 $H$。分析首先需要确定可以驻留在 SM 上的活动线程块数量，该数量受到 SM 物理资源的限制。\n\n驻留块的数量，表示为 $B_{\\mathrm{resident}}$，是由每个硬件资源限制（总寄存器文件容量 ($R_{\\mathrm{SM}}$)、总共享内存容量 ($S_{\\mathrm{SM}}$)、最大驻留线程数 ($T_{\\max}$) 和驻留块的架构最大值 ($B_{\\max}$)）所允许的最大块数的最小值。\n\n给定的参数如下：\n- 每个 SM 的总寄存器文件容量：$R_{\\mathrm{SM}} = 65536$ 个寄存器。\n- 每个 SM 的总共享内存：$S_{\\mathrm{SM}} = 96\\,\\mathrm{KB}$。\n- 每个 SM 的最大驻留线程数：$T_{\\max} = 2048$ 个线程。\n- 每个 SM 的最大驻留线程块数：$B_{\\max} = 32$ 个块。\n- 线程束大小：$W_{\\mathrm{size}} = 32$ 个线程。\n- 内存延迟：$L_{\\mathrm{mem}} = 20$ 个周期。\n- 每块的线程数：$T_{\\mathrm{block}} = 256$ 个线程。\n- 每线程的寄存器数：$R_{\\mathrm{thread}} = 80$ 个寄存器。\n- 每块的共享内存：$S_{\\mathrm{block}} = 24\\,\\mathrm{KB}$。\n\n首先，我们计算受每种资源限制的、可以驻留在 SM 上的最大块数。\n\n1.  **寄存器文件的限制：**\n    单个线程块所需的总寄存器数是每块的线程数与每线程的寄存器数的乘积。\n    $$R_{\\mathrm{block\\_req}} = T_{\\mathrm{block}} \\times R_{\\mathrm{thread}}$$\n    代入给定值：\n    $$R_{\\mathrm{block\\_req}} = 256 \\times 80 = 20480 \\text{ registers}$$\n    受寄存器文件限制，可以在 SM 上共存的最大块数是 SM 上可用的总寄存器数除以每块所需的寄存器数。由于块数必须是整数，我们对该比率取底。\n    $$B_{\\mathrm{limit\\_reg}} = \\left\\lfloor \\frac{R_{\\mathrm{SM}}}{R_{\\mathrm{block\\_req}}} \\right\\rfloor = \\left\\lfloor \\frac{65536}{20480} \\right\\rfloor = \\lfloor 3.2 \\rfloor = 3 \\text{ blocks}$$\n\n2.  **共享内存的限制：**\n    受共享内存限制的最大块数是 SM 上可用的总共享内存除以每块所需的共享内存。\n    $$B_{\\mathrm{limit\\_smem}} = \\left\\lfloor \\frac{S_{\\mathrm{SM}}}{S_{\\mathrm{block}}} \\right\\rfloor = \\left\\lfloor \\frac{96\\,\\mathrm{KB}}{24\\,\\mathrm{KB}} \\right\\rfloor = \\lfloor 4 \\rfloor = 4 \\text{ blocks}$$\n\n3.  **最大驻留线程数的限制：**\n    所有驻留块的总线程数不能超过 SM 的线程容量。因此，最大块数是每个 SM 的最大线程数除以每块的线程数。\n    $$B_{\\mathrm{limit\\_threads}} = \\left\\lfloor \\frac{T_{\\max}}{T_{\\mathrm{block}}} \\right\\rfloor = \\left\\lfloor \\frac{2048}{256} \\right\\rfloor = \\lfloor 8 \\rfloor = 8 \\text{ blocks}$$\n\n4.  **块的架构限制：**\n    GPU 架构对每个 SM 上的并发块数施加了硬性限制。\n    $$B_{\\mathrm{limit\\_max}} = B_{\\max} = 32 \\text{ blocks}$$\n\n实际的驻留块数 $B_{\\mathrm{resident}}$ 是这些限制中最严格的一个，即最小值。\n$$B_{\\mathrm{resident}} = \\min(B_{\\mathrm{limit\\_reg}}, B_{\\mathrm{limit\\_smem}}, B_{\\mathrm{limit\\_threads}}, B_{\\mathrm{limit\\_max}})$$\n$$B_{\\mathrm{resident}} = \\min(3, 4, 8, 32) = 3 \\text{ blocks}$$\n限制性资源是寄存器文件。\n\n当 $B_{\\mathrm{resident}} = 3$ 个块时，我们现在可以计算活动线程束的数量 $W_{\\mathrm{active}}$。一个线程束由 $W_{\\mathrm{size}} = 32$ 个线程组成。每块的线程束数量为：\n$$W_{\\mathrm{block}} = \\frac{T_{\\mathrm{block}}}{W_{\\mathrm{size}}} = \\frac{256}{32} = 8 \\text{ warps/block}$$\nSM 上的总活动线程束数是驻留块数乘以每块的线程束数。\n$$W_{\\mathrm{active}} = B_{\\mathrm{resident}} \\times W_{\\mathrm{block}} = 3 \\times 8 = 24 \\text{ warps}$$\n\n问题要求计算延迟隐藏因子 $H$，其定义为：\n$$H \\equiv \\frac{W_{\\mathrm{active}}}{L_{\\mathrm{mem}}}$$\n代入计算出的 $W_{\\mathrm{active}}$ 值和给定的内存延迟 $L_{\\mathrm{mem}} = 20$ 个周期：\n$$H = \\frac{24}{20} = 1.2$$\n问题要求答案应四舍五入到四位有效数字。\n$$H = 1.200$$\n$H > 1$ 的值表示在单发射轮询调度模型下，线程束级并行度足以完全隐藏 L1 内存延迟。\n\n为完整起见，我们也可以计算占用率 $O$。每个 SM 的最大线程束数量为：\n$$W_{\\max} = \\frac{T_{\\max}}{W_{\\mathrm{size}}} = \\frac{2048}{32} = 64 \\text{ warps}$$\n占用率为：\n$$O = \\frac{W_{\\mathrm{active}}}{W_{\\max}} = \\frac{24}{64} = \\frac{3}{8} = 0.375$$\n这证实了对于典型的 GPU 工作负载，中间计算是合理的。最终答案是 $H$ 的值。",
            "answer": "$$\\boxed{1.200}$$"
        }
    ]
}