{
    "hands_on_practices": [
        {
            "introduction": "伽辽金投影的核心在于将高维系统的动力学投影到一个低维子空间上。这个过程的有效性很大程度上取决于我们如何定义向量间的“正交性”，而在许多物理系统中，这种正交性是通过一个由系统弱形式产生的“质量矩阵”$M$定义的加权内积来衡量的。这项练习将通过一个具体的计算任务，指导你使用 Gram-Schmidt 方法来构建一个相对于这种加权内积（即$M$-正交）的基，这是构建和理解伽辽金降阶模型的一项基本技能。",
            "id": "3915341",
            "problem": "在自动化的电池设计和仿真中，电解质浓度动态变化的降阶模型通常通过将高维半离散系统使用伽辽金投影（Galerkin projection）到由基向量张成的低维子空间上得到。伽辽金投影使用来自弱形式的质量矩阵来定义内积，并确保降阶基的正交规范性。考虑一个双自由度的电解质扩散状态向量 $x(t) \\in \\mathbb{R}^{2}$，它表示一个软包电池中两个有限体积节点上的空间平均浓度状态。半离散弱形式产生一个对称正定（SPD）的质量矩阵 $M \\in \\mathbb{R}^{2 \\times 2}$，使得内积定义为 $(u,v)_{M} = u^{\\top} M v$。假设 $M = \\mathrm{diag}(2,3)$ 是由两个控制体积的质量集中（mass-lumping）产生的，其权重与体积成正比，并且从详细仿真中获得了两个线性无关的快照向量 $w_{1}, w_{2} \\in \\mathbb{R}^{2}$：$w_{1} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$ 和 $w_{2} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。\n\n从 $M$-内积的定义和基 $\\{v_{i}\\}$ 的正交规范性要求出发，使用关于 $(u,v)_{M} = u^{\\top} M v$ 的格拉姆-施密特过程（Gram–Schmidt process）从 $\\{w_{1}, w_{2}\\}$ 构建一个 $M$-正交规范基 $\\{v_{1}, v_{2}\\}$。构建矩阵 $V = \\begin{pmatrix} v_{1} & v_{2} \\end{pmatrix} \\in \\mathbb{R}^{2 \\times 2}$，并通过计算与单位矩阵的偏差的弗罗贝尼乌斯范数（Frobenius norm）$\\|V^{\\top} M V - I\\|_{F}$ 来验证其正交规范性，其中 $I$ 是 $2 \\times 2$ 的单位矩阵，$\\|\\cdot\\|_{F}$ 表示弗罗贝尼乌斯范数。\n\n将单个实数 $\\|V^{\\top} M V - I\\|_{F}$ 作为你的最终答案。将该值表示为一个不带单位的纯数字。如果需要进行任何数值近似，请将答案四舍五入到四位有效数字。",
            "solution": "该问题要求从一组给定的向量中，根据一个由质量矩阵 $M$ 定义的非标准内积，构建一个正交规范基。这个过程在用于模型降阶的伽辽金投影方法中是基础性的。构建基之后，我们必须通过计算一个特定的矩阵范数来验证其正交规范性。\n\n首先，我们确定给定的量。质量矩阵是 $M = \\mathrm{diag}(2,3) = \\begin{pmatrix} 2 & 0 \\\\ 0 & 3 \\end{pmatrix}$。该矩阵是对称正定的，特征值为2和3，因此可以正确地定义一个内积。对于任意向量 $u, v \\in \\mathbb{R}^{2}$，内积由 $(u,v)_{M} = u^{\\top} M v$ 给出。初始的线性无关向量集是 $\\{w_{1}, w_{2}\\}$，其中 $w_{1} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$ 和 $w_{2} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。\n\n我们对集合 $\\{w_{1}, w_{2}\\}$ 应用格拉姆-施密特过程，以获得一个 $M$-正交规范基 $\\{v_{1}, v_{2}\\}$。\n\n步骤1：构建第一个正交规范向量 $v_{1}$。\n令第一个未归一化的向量为 $u_{1} = w_{1} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$。\n我们计算它关于 $M$-内积的范数，记为 $\\|u_{1}\\|_{M}$。\n$$ \\|u_{1}\\|_{M}^{2} = (u_{1}, u_{1})_{M} = u_{1}^{\\top} M u_{1} = \\begin{pmatrix} 1 & 1 \\end{pmatrix} \\begin{pmatrix} 2 & 0 \\\\ 0 & 3 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 & 1 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 3 \\end{pmatrix} = 2 \\cdot 1 + 3 \\cdot 1 = 5 $$\n范数为 $\\|u_{1}\\|_{M} = \\sqrt{5}$。\n第一个正交规范向量 $v_{1}$ 通过归一化 $u_{1}$ 得到：\n$$ v_{1} = \\frac{u_{1}}{\\|u_{1}\\|_{M}} = \\frac{1}{\\sqrt{5}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} $$\n\n步骤2：构建第二个正交规范向量 $v_{2}$。\n首先，我们通过从 $w_{2}$ 中减去 $w_{2}$ 在 $v_{1}$ 上的投影，来找到一个与 $v_{1}$ 是 $M$-正交的向量 $u_{2}$。\n$$ u_{2} = w_{2} - (w_{2}, v_{1})_{M} v_{1} $$\n我们计算内积 $(w_{2}, v_{1})_{M}$：\n$$ (w_{2}, v_{1})_{M} = w_{2}^{\\top} M v_{1} = \\begin{pmatrix} 1 & 0 \\end{pmatrix} \\begin{pmatrix} 2 & 0 \\\\ 0 & 3 \\end{pmatrix} \\left( \\frac{1}{\\sqrt{5}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} \\right) = \\frac{1}{\\sqrt{5}} \\begin{pmatrix} 1 & 0 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 3 \\end{pmatrix} = \\frac{2}{\\sqrt{5}} $$\n现在我们可以计算 $u_{2}$：\n$$ u_{2} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} - \\left( \\frac{2}{\\sqrt{5}} \\right) \\left( \\frac{1}{\\sqrt{5}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} \\right) = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} - \\frac{2}{5} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{2}{5} \\\\ 0 - \\frac{2}{5} \\end{pmatrix} = \\begin{pmatrix} \\frac{3}{5} \\\\ -\\frac{2}{5} \\end{pmatrix} $$\n接下来，我们归一化 $u_{2}$ 以得到 $v_{2}$。我们计算其范数的平方 $\\|u_{2}\\|_{M}^{2}$：\n$$ \\|u_{2}\\|_{M}^{2} = (u_{2}, u_{2})_{M} = u_{2}^{\\top} M u_{2} = \\begin{pmatrix} \\frac{3}{5} & -\\frac{2}{5} \\end{pmatrix} \\begin{pmatrix} 2 & 0 \\\\ 0 & 3 \\end{pmatrix} \\begin{pmatrix} \\frac{3}{5} \\\\ -\\frac{2}{5} \\end{pmatrix} $$\n$$ = \\begin{pmatrix} \\frac{6}{5} & -\\frac{6}{5} \\end{pmatrix} \\begin{pmatrix} \\frac{3}{5} \\\\ -\\frac{2}{5} \\end{pmatrix} = \\left(\\frac{6}{5}\\right)\\left(\\frac{3}{5}\\right) + \\left(-\\frac{6}{5}\\right)\\left(-\\frac{2}{5}\\right) = \\frac{18}{25} + \\frac{12}{25} = \\frac{30}{25} = \\frac{6}{5} $$\n范数为 $\\|u_{2}\\|_{M} = \\sqrt{\\frac{6}{5}}$。\n第二个正交规范向量 $v_{2}$ 是：\n$$ v_{2} = \\frac{u_{2}}{\\|u_{2}\\|_{M}} = \\frac{1}{\\sqrt{\\frac{6}{5}}} \\begin{pmatrix} \\frac{3}{5} \\\\ -\\frac{2}{5} \\end{pmatrix} = \\frac{\\sqrt{5}}{\\sqrt{6}} \\frac{1}{5} \\begin{pmatrix} 3 \\\\ -2 \\end{pmatrix} = \\frac{1}{\\sqrt{5}\\sqrt{6}} \\begin{pmatrix} 3 \\\\ -2 \\end{pmatrix} = \\frac{1}{\\sqrt{30}} \\begin{pmatrix} 3 \\\\ -2 \\end{pmatrix} $$\n得到的 $M$-正交规范基是 $\\{v_{1}, v_{2}\\}$，其中 $v_{1} = \\frac{1}{\\sqrt{5}}\\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$ 和 $v_{2} = \\frac{1}{\\sqrt{30}}\\begin{pmatrix} 3 \\\\ -2 \\end{pmatrix}$。\n\n步骤3：构建矩阵 $V$ 并计算指定的范数。\n矩阵 $V$ 由 $v_1$ 和 $v_2$ 作为其列向量构成：\n$$ V = \\begin{pmatrix} v_{1} & v_{2} \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{\\sqrt{5}} & \\frac{3}{\\sqrt{30}} \\\\ \\frac{1}{\\sqrt{5}} & -\\frac{2}{\\sqrt{30}} \\end{pmatrix} $$\n问题要求计算 $\\|V^{\\top} M V - I\\|_{F}$。根据 $M$-正交规范基的定义，矩阵 $V$ 必须满足属性 $V^{\\top} M V = I$，其中 $I$ 是单位矩阵。矩阵 $V^{\\top} M V$ 的元素由 $(V^{\\top} M V)_{ij} = v_i^{\\top} M v_j = (v_i, v_j)_M$ 给出。由于基 $\\{v_1, v_2\\}$ 是 $M$-正交规范的，我们有 $(v_i, v_j)_M = \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克（Kronecker）δ函数。\n\n让我们通过显式计算来验证此属性：\n$$ V^{\\top} M V = \\begin{pmatrix} v_1^{\\top} \\\\ v_2^{\\top} \\end{pmatrix} M \\begin{pmatrix} v_1 & v_2 \\end{pmatrix} = \\begin{pmatrix} v_1^{\\top} M v_1 & v_1^{\\top} M v_2 \\\\ v_2^{\\top} M v_1 & v_2^{\\top} M v_2 \\end{pmatrix} = \\begin{pmatrix} (v_1, v_1)_M & (v_1, v_2)_M \\\\ (v_2, v_1)_M & (v_2, v_2)_M \\end{pmatrix} $$\n根据我们之前的计算：\n$(v_1, v_1)_M = \\|v_1\\|_M^2 = 1$\n$(v_2, v_2)_M = \\|v_2\\|_M^2 = 1$\n并且根据构造，$v_1$ 和 $v_2$ 是正交的：\n$(v_1, v_2)_M = v_1^{\\top} M v_2 = \\left( \\frac{1}{\\sqrt{5}} \\begin{pmatrix} 1 & 1 \\end{pmatrix} \\right) \\begin{pmatrix} 2 & 0 \\\\ 0 & 3 \\end{pmatrix} \\left( \\frac{1}{\\sqrt{30}} \\begin{pmatrix} 3 \\\\ -2 \\end{pmatrix} \\right) = \\frac{1}{\\sqrt{150}} \\begin{pmatrix} 1 & 1 \\end{pmatrix} \\begin{pmatrix} 6 \\\\ -6 \\end{pmatrix} = \\frac{1}{\\sqrt{150}} (6-6) = 0$。\n由于内积是对称的，$(v_2, v_1)_M = (v_1, v_2)_M = 0$。\n\n因此，矩阵乘积是：\n$$ V^{\\top} M V = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} = I $$\n我们被要求计算 $\\|V^{\\top} M V - I\\|_{F}$。代入结果：\n$$ V^{\\top} M V - I = I - I = \\begin{pmatrix} 0 & 0 \\\\ 0 & 0 \\end{pmatrix} = O $$\n其中 $O$ 是 $2 \\times 2$ 的零矩阵。\n\n矩阵 $A$ 的弗罗贝尼乌斯范数定义为 $\\|A\\|_{F} = \\sqrt{\\sum_{i=1}^{m}\\sum_{j=1}^{n} |a_{ij}|^2}$。对于零矩阵，这等于：\n$$ \\|O\\|_{F} = \\sqrt{0^2 + 0^2 + 0^2 + 0^2} = 0 $$\n该计算是精确的，不需要任何数值近似。结果恰好是 $0$。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "推导出降阶模型（ROM）只是第一步；为了实际应用，我们必须能够高效且稳定地对其进行数值求解。这项练习将理论上的 ROM 与其在实践中的仿真联系起来，要求你使用一种广泛应用于电池等刚性系统的数值方法——后向欧拉法——来推导离散时间下的更新方程。更进一步，你还将分析该数值格式的稳定性，这对于确保仿真结果的物理真实性和可靠性至关重要。",
            "id": "3915345",
            "problem": "考虑一个用于电池电极-离子动力学的线性化半离散降阶模型，该模型通过将Galerkin投影应用于空间离散的守恒定律和Fickian扩散得到。设降阶状态为 $x_{r}(t) \\in \\mathbb{R}^{r}$，模型为\n$$\nM_{r} \\,\\dot{x}_{r}(t) + K_{r} \\, x_{r}(t) = f_{r}(t),\n$$\n其中 $M_{r} \\in \\mathbb{R}^{r \\times r}$ 是一个对称正定质量矩阵，源于降阶基函数的内积；$K_{r} \\in \\mathbb{R}^{r \\times r}$ 是一个对称半正定刚度矩阵，反映了扩散和反应输运；$f_{r}(t) \\in \\mathbb{R}^{r}$ 编码了来自边界通量和源项的降阶强迫项。假设降阶基是通过标准的Galerkin方法获得的，其中测试函数等于试验函数，并且线性化在所关心的时间区间内产生不随时间变化的 $M_{r}$ 和 $K_{r}$。\n\n您将使用后向欧拉（也称隐式欧拉）法，以均匀时间步长 $\\Delta t > 0$ 在时间上进行离散化。从上述降阶动力学出发，并仅使用后向欧拉的定义，推导降阶状态的单步全离散更新。将更新表示为一个闭式形式的显式映射，该映射从 $x_{r}^{n}$ 和 $f_{r}^{n+1}$ 生成 $x_{r}^{n+1}$。\n\n接下来，分析对于电池特有的刚性动力学（例如快速固相扩散模式）的鲁棒性。考虑齐次情况，其中 $f_{r}(t) \\equiv 0$，并假设 $(\\lambda_{i}, v_{i})$ 是满足 $K_{r} v_{i} = \\lambda_{i} M_{r} v_{i}$ 且 $\\lambda_{i} \\ge 0$ 的广义特征对。当 $x_{r} = \\sum_{i} \\alpha_{i} v_{i}$ 时，推导每模态放大因子 $g(\\lambda_{i}, \\Delta t)$，使得模态系数更新为 $\\alpha_{i}^{n+1} = g(\\lambda_{i}, \\Delta t)\\,\\alpha_{i}^{n}$。以闭式形式提供此放大因子。\n\n您的最终输出必须是一对解析表达式：用 $M_{r}$、$K_{r}$、$\\Delta t$、$x_{r}^{n}$ 和 $f_{r}^{n+1}$ 表示的 $x_{r}^{n+1}$ 的显式后向欧拉更新映射，以及每模态放大因子 $g(\\lambda, \\Delta t)$。不需要进行数值计算。",
            "solution": "该问题被评估为有效，因为它具有科学依据、问题明确且客观。它包含了常微分方程数值方法领域中应用于降阶模型的标准推导。所有必要信息均已提供，所要求的推导在数学上是合理的且无歧义。\n\n第一个任务是使用后向欧拉法推导降阶状态 $x_{r}(t)$ 的单步全离散更新。控制方程是线性化的降阶模型：\n$$\nM_{r} \\,\\dot{x}_{r}(t) + K_{r} \\, x_{r}(t) = f_{r}(t)\n$$\n后向欧拉法是一种隐式一阶方法，它使用时间 $t_{n+1}$ 和 $t_{n} = n\\Delta t$ 处的状态来近似时间 $t_{n+1} = (n+1)\\Delta t$ 处的时间导数 $\\dot{x}_{r}(t)$。设 $x_{r}^{n} \\approx x_{r}(t_n)$。导数的近似为：\n$$\n\\dot{x}_{r}(t_{n+1}) \\approx \\frac{x_{r}^{n+1} - x_{r}^{n}}{\\Delta t}\n$$\n将此近似代入在时间 $t_{n+1}$ 处评估的控制方程，我们得到全离散系统：\n$$\nM_{r} \\left( \\frac{x_{r}^{n+1} - x_{r}^{n}}{\\Delta t} \\right) + K_{r} x_{r}^{n+1} = f_{r}^{n+1}\n$$\n其中 $f_{r}^{n+1} = f_{r}(t_{n+1})$。我们的目标是推导 $x_{r}^{n+1}$ 的显式表达式。为此，我们重新排列方程，将包含 $x_{r}^{n+1}$ 的项组合在一起：\n$$\n\\frac{1}{\\Delta t} M_{r} x_{r}^{n+1} - \\frac{1}{\\Delta t} M_{r} x_{r}^{n} + K_{r} x_{r}^{n+1} = f_{r}^{n+1}\n$$\n$$\n\\left( \\frac{1}{\\Delta t} M_{r} + K_{r} \\right) x_{r}^{n+1} = \\frac{1}{\\Delta t} M_{r} x_{r}^{n} + f_{r}^{n+1}\n$$\n为了简化，我们可以将整个方程乘以时间步长 $\\Delta t > 0$：\n$$\n(M_{r} + \\Delta t K_{r}) x_{r}^{n+1} = M_{r} x_{r}^{n} + \\Delta t f_{r}^{n+1}\n$$\n为了求解 $x_{r}^{n+1}$，我们必须对矩阵 $(M_{r} + \\Delta t K_{r})$ 求逆。我们必须验证该矩阵是可逆的。问题陈述中指出 $M_{r}$ 是对称正定（SPD）的，$K_{r}$ 是对称半正定（SPSD）的。对于任何非零向量 $v \\in \\mathbb{R}^{r}$，我们有 $v^{T}M_{r}v > 0$ 和 $v^{T}K_{r}v \\ge 0$。由于 $\\Delta t > 0$，我们也有 $\\Delta t \\, v^{T}K_{r}v \\ge 0$。\n考虑矩阵 $(M_{r} + \\Delta t K_{r})$ 的二次型：\n$$\nv^{T} (M_{r} + \\Delta t K_{r}) v = v^{T} M_{r} v + \\Delta t (v^{T} K_{r} v)\n$$\n由于 $v^{T} M_{r} v > 0$ 且 $\\Delta t (v^{T} K_{r} v) \\ge 0$，它们的和是严格正的：$v^{T} (M_{r} + \\Delta t K_{r}) v > 0$。这表明矩阵 $(M_{r} + \\Delta t K_{r})$ 是对称正定的，因此是可逆的。\n现在我们可以通过左乘其逆矩阵来获得 $x_{r}^{n+1}$ 的显式映射：\n$$\nx_{r}^{n+1} = (M_{r} + \\Delta t K_{r})^{-1} (M_{r} x_{r}^{n} + \\Delta t f_{r}^{n+1})\n$$\n这是第一个要求的表达式。\n\n第二个任务是找到齐次情况（其中 $f_{r}(t) \\equiv 0$）下每模态的放大因子 $g(\\lambda, \\Delta t)$。离散更新方程简化为：\n$$\n(M_{r} + \\Delta t K_{r}) x_{r}^{n+1} = M_{r} x_{r}^{n}\n$$\n我们将状态向量表示在广义特征向量 $v_{i}$ 的基上，这些特征向量满足 $K_{r} v_{i} = \\lambda_{i} M_{r} v_{i}$。时间步 $n$ 和 $n+1$ 处的状态可以写成模态展开：\n$$\nx_{r}^{n} = \\sum_{i=1}^{r} \\alpha_{i}^{n} v_{i} \\quad \\text{和} \\quad x_{r}^{n+1} = \\sum_{i=1}^{r} \\alpha_{i}^{n+1} v_{i}\n$$\n将这些展开式代入齐次离散更新方程：\n$$\n(M_{r} + \\Delta t K_{r}) \\sum_{i=1}^{r} \\alpha_{i}^{n+1} v_{i} = M_{r} \\sum_{i=1}^{r} \\alpha_{i}^{n} v_{i}\n$$\n根据矩阵-向量乘积的线性性质：\n$$\n\\sum_{i=1}^{r} \\alpha_{i}^{n+1} (M_{r} + \\Delta t K_{r}) v_{i} = \\sum_{i=1}^{r} \\alpha_{i}^{n} M_{r} v_{i}\n$$\n$$\n\\sum_{i=1}^{r} \\alpha_{i}^{n+1} (M_{r}v_{i} + \\Delta t K_{r} v_{i}) = \\sum_{i=1}^{r} \\alpha_{i}^{n} M_{r} v_{i}\n$$\n现在，将广义特征值关系 $K_{r} v_{i} = \\lambda_{i} M_{r} v_{i}$ 代入左侧：\n$$\n\\sum_{i=1}^{r} \\alpha_{i}^{n+1} (M_{r}v_{i} + \\Delta t \\lambda_{i} M_{r} v_{i}) = \\sum_{i=1}^{r} \\alpha_{i}^{n} M_{r} v_{i}\n$$\n在左侧提出因子 $M_{r}v_{i}$：\n$$\n\\sum_{i=1}^{r} \\alpha_{i}^{n+1} (1 + \\Delta t \\lambda_{i}) M_{r} v_{i} = \\sum_{i=1}^{r} \\alpha_{i}^{n} M_{r} v_{i}\n$$\n该方程对每个模态独立成立。为了分离出单个模态系数 $\\alpha_{j}^{n+1}$ 的更新，我们利用广义特征向量是 $M_{r}$-正交的性质，即当 $i \\neq j$ 时，$v_{j}^{T} M_{r} v_{i} = 0$。用 $v_{j}^{T}$ 左乘该方程：\n$$\nv_{j}^{T} \\sum_{i=1}^{r} \\left[ \\alpha_{i}^{n+1} (1 + \\Delta t \\lambda_{i}) - \\alpha_{i}^{n} \\right] M_{r} v_{i} = 0\n$$\n$$\n\\sum_{i=1}^{r} \\left[ \\alpha_{i}^{n+1} (1 + \\Delta t \\lambda_{i}) - \\alpha_{i}^{n} \\right] (v_{j}^{T} M_{r} v_{i}) = 0\n$$\n由于 $M_{r}$-正交性，和式中除了 $i=j$ 的项外，所有项都为零：\n$$\n\\left[ \\alpha_{j}^{n+1} (1 + \\Delta t \\lambda_{j}) - \\alpha_{j}^{n} \\right] (v_{j}^{T} M_{r} v_{j}) = 0\n$$\n由于 $M_{r}$ 是对称正定的，$v_{j}$ 是一个非零特征向量，标量 $v_{j}^{T} M_{r} v_{j} > 0$。因此，方括号中的项必须为零：\n$$\n\\alpha_{j}^{n+1} (1 + \\Delta t \\lambda_{j}) - \\alpha_{j}^{n} = 0\n$$\n求解 $\\alpha_{j}^{n+1}$：\n$$\n\\alpha_{j}^{n+1} = \\frac{1}{1 + \\Delta t \\lambda_{j}} \\alpha_{j}^{n}\n$$\n问题定义了放大因子 $g(\\lambda_{i}, \\Delta t)$，使得 $\\alpha_{i}^{n+1} = g(\\lambda_{i}, \\Delta t) \\alpha_{i}^{n}$。通过将我们推导出的关系与此定义进行比较，我们可以确定放大因子。为了一般性，我们去掉下标索引：\n$$\ng(\\lambda, \\Delta t) = \\frac{1}{1 + \\Delta t \\lambda}\n$$\n这是第二个要求的表达式。由于 $\\lambda \\ge 0$ 且 $\\Delta t > 0$，我们有 $0  g(\\lambda, \\Delta t) \\le 1$，这证实了后向欧拉法对此类问题是无条件稳定的。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} (M_{r} + \\Delta t K_{r})^{-1} (M_{r} x_{r}^{n} + \\Delta t f_{r}^{n+1})  \\frac{1}{1 + \\Delta t \\lambda} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在工程应用中，我们通常更关心模型对某个特定输出量（例如电池的荷电状态或电极的峰值温度）的预测精度，而不是整个状态场的误差。这项高级实践介绍了一种强大的“目标导向”误差估计技术——对偶加权残差（DWR）方法，它能够有效地估计模型在特定工程目标上的误差。通过完成这项练习，你将实现从全阶模型构建、伽辽金投影降阶到最终误差评估的完整流程，从而全面掌握降阶模型的应用与验证。",
            "id": "3915368",
            "problem": "在一个自动化电池设计背景下，考虑一个一维、无量纲的多孔电极板内锂传输模型。该模型的基本依据是菲克第二扩散定律（Fick's second law of diffusion），其无量纲形式表明，在空间区间 $x \\in [0,1]$ 上的浓度场 $c(x,t)$ 的演化遵循 $\\partial c / \\partial t = \\partial^2 c / \\partial x^2 + s u(t)$，其中 $u(t)$ 是一个给定的无量纲输入电流曲线，$s$ 是一个均匀分布源项的无量纲标量因子。为了进行自动化数值模拟，假设空间域采用中心有限差分格式进行离散化，并施加齐次诺伊曼边界条件（两端通量为零），从而得到一个关于节点浓度的半离散线性系统。将离散状态表示为向量 $y(t) \\in \\mathbb{R}^N$，其中 $N$ 是空间节点的数量，并令离散扩散算子为对称矩阵 $A \\in \\mathbb{R}^{N \\times N}$，该矩阵由带有诺伊曼边界条件的二阶导数近似得到。令分布式源注入由一个在各节点上均匀分布的向量 $B \\in \\mathbb{R}^{N}$ 表示。\n\n从这些基本定律和定义出发，您必须：\n- 使用后向欧拉法实现全阶模型的时间离散化，时间步长为 $\\Delta t$，最终时间为 $T$，共计 $N_t = T / \\Delta t$ 步。初始条件为 $y^0 = 0$。\n- 使用一个标准正交基 $V \\in \\mathbb{R}^{N \\times r}$ 构建一个伽辽金降阶模型，其中 $r$ 是降阶维度。基 $V$ 必须由矩阵 $A$ 的特征向量构成，这些特征向量对应于 $A$ 的 $r$ 个绝对值最小（最接近零）的特征值，以确保慢扩散模态得到表示。\n- 定义目标泛函 $J(y^N) = c^\\top y^N$，其中 $c = \\frac{1}{N}\\mathbf{1}$ 是均匀权重向量，因此 $J$ 计算的是最终时间步的平均浓度。将所有量视为无量纲。\n- 从第一性原理出发，推导目标泛函的对偶加权残差误差估计，以及与伽辽金降阶模型相关的伴随降阶问题。对偶加权残差必须使用在全阶动力学中评估的降阶模型解的离散残差，以及通过基 $V$ 从降阶伴随问题映射到全空间的伴随权重。\n- 实现对偶加权残差误差估计器，并对每个测试用例计算目标泛函中估计误差与真实误差之间的绝对差，定义为 $\\left| \\left( J(y_\\text{FOM}^N) - J(y_\\text{ROM}^N) \\right) - \\text{estimate} \\right|$，其中 $y_\\text{FOM}^N$ 和 $y_\\text{ROM}^N$ 分别是全阶模型和降阶模型的最终状态。\n\n时间离散化细节：\n- 对全阶模型使用后向欧拉更新：构建矩阵 $M = I - \\Delta t A$（其中 $I$ 是单位矩阵），并根据 $y^n$ 满足的方程 $M y^n = y^{n-1} + \\Delta t B u^n$ 进行步进，其中 $n = 1, 2, \\dots, N_t$，$u^n = u(t_n)$ 且 $t_n = n \\Delta t$。\n- 对降阶模型，使用伽辽金投影来投影算子：$A_r = V^\\top A V$，$B_r = V^\\top B$，并构建 $M_r = I_r - \\Delta t A_r$，其中 $I_r$ 是 $r \\times r$ 的单位矩阵。根据 $M_r z^n = z^{n-1} + \\Delta t B_r u^n$ 进行步进，初始条件为 $z^0 = 0$，并重构 $y_\\text{ROM}^n = V z^n$。\n\n对偶加权残差实现要求：\n- 使用离散残差 $r^n = y_\\text{ROM}^n - \\tilde{y}^n$，其中 $\\tilde{y}^n$ 表示将全阶模型的一个后向欧拉步应用于降阶状态，即 $M \\tilde{y}^n = y_\\text{ROM}^{n-1} + \\Delta t B u^n$。\n- 推导并沿时间反向求解降阶伴随递归方程，并通过 $V$ 将其映射到全空间，以获得每个时间步的伴随权重。将这些权重与残差结合，得到目标误差的对偶加权残差估计。\n\n测试套件：\n为以下5个测试用例实现程序。对于每个用例，按如下方式指定参数 $(N, r, \\Delta t, T)$ 和输入曲线 $u(t)$，其中 $t_n = n \\Delta t$：\n- 案例 1：$N = 50$，$r = 3$，$\\Delta t = 0.01$，$T = 1.0$，$u(t) = \\sin(2 \\pi t)$。\n- 案例 2：$N = 50$，$r = 1$，$\\Delta t = 0.02$，$T = 1.0$，$u(t) = 1$。\n- 案例 3：$N = 80$，$r = 10$，$\\Delta t = 0.005$，$T = 0.5$，$u(t) = 1$ 当 $t  0.25$ 时，以及 $u(t) = 0$ 当 $t \\ge 0.25$ 时。\n- 案例 4：$N = 30$，$r = 5$，$\\Delta t = 0.04$，$T = 0.8$，$u(t) = 0.3 \\sin(4 \\pi t) + 0.1$。\n- 案例 5：$N = 60$，$r = 12$，$\\Delta t = 0.01$，$T = 1.0$，$u(t) = 0$。\n\n所有量均为无量纲。您的程序必须为每个用例计算对偶加权残差估计与真实目标误差之间的绝对差，结果为浮点数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，[result1,result2,result3]）。该列表必须包含与上述5个测试用例相对应的5个浮点数，顺序与定义时相同。",
            "solution": "该问题是有效的，因为它科学上基于一个成熟的扩散模型，数学上是适定的，并为计算工程中的一个标准数值程序提供了完整而明确的指令。\n\n我们的任务是为一个一维扩散问题实现一个全阶模型（FOM）、一个伽辽金投影降阶模型（ROM）以及一个对偶加权残差（DWR）误差估计器。最终目标是计算目标泛函中的真实误差与通过DWR方法估计的误差之间的差异。\n\n**1. 全阶模型（FOM）离散化**\n\n控制偏微分方程是无量纲扩散方程 `∂c/∂t = ∂²c/∂x² + s u(t)`，定义在 `x ∈ [0, 1]` 上，并带有齐次诺伊曼边界条件 `∂c/∂x(0,t) = ∂c/∂x(1,t) = 0`。不失一般性，我们可以设定标量 `s=1`。\n\n首先，我们对空间域进行半离散化。我们使用包含 `N` 个节点的单元中心有限差分格式。设空间步长为 `h = 1/N`。网格点为 `x_i = (i - 0.5)h`，其中 `i = 1, ..., N`。在内部节点 `i` 处的二阶导数近似为 `∂²c/∂x² ≈ (c_{i+1} - 2c_i + c_{i-1})/h²`。为了得到算子的对称离散化，我们在单元面 `x=0` 和 `x=1` 处应用诺伊曼边界条件 `∂c/∂x = 0`，这在该格式中导致：\n- 在 `i=1` 处：`(c_2 - c_1)/h²`\n- 在 `i=N` 处：`(c_{N-1} - c_N)/h²`\n\n这产生了一个常微分方程的半离散系统：\n$$\n\\frac{d\\mathbf{y}}{dt} = A \\mathbf{y}(t) + B u(t)\n$$\n其中 `\\mathbf{y}(t) \\in \\mathbb{R}^N` 是节点浓度的向量。矩阵 `A \\in \\mathbb{R}^{N \\times N}` 是对称、半负定的扩散算子：\n$$\nA = \\frac{1}{h^2} \\begin{pmatrix}\n-1  1  0  \\dots  0 \\\\\n1  -2  1  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n0  \\dots  1  -2  1 \\\\\n0  \\dots  0  1  -1\n\\end{pmatrix}\n$$\n源向量 `B \\in \\mathbb{R}^N` 模拟一个均匀源，因此 `B = \\mathbf{1}`，其中 `\\mathbf{1}` 是一个全一向量。初始条件为 `\\mathbf{y}(0) = \\mathbf{0}`。\n\n对于时间积分，我们使用时间步长为 `Δt` 的后向欧拉法。从 `\\mathbf{y}^{n-1}` 到 `\\mathbf{y}^n` 的更新规则是：\n$$\n\\frac{\\mathbf{y}^n - \\mathbf{y}^{n-1}}{\\Delta t} = A \\mathbf{y}^n + B u^n \\implies (I - \\Delta t A) \\mathbf{y}^n = \\mathbf{y}^{n-1} + \\Delta t B u^n\n$$\n其中 `u^n = u(n\\Delta t)`。令 `M = I - \\Delta t A`。FOM 通过迭代求解 `M \\mathbf{y}^n = \\mathbf{y}^{n-1} + \\Delta t B u^n` 来解决，其中 `n = 1, \\dots, N_t`。\n\n**2. 降阶模型（ROM）构建**\n\n模型降阶的本质是找到一个能够捕捉主导动力学的低维子空间。我们寻求一个近似 `\\mathbf{y}(t) \\approx V \\mathbf{z}(t)`，其中 `V \\in \\mathbb{R}^{N \\times r}` 是该子空间的一个标准正交基，`\\mathbf{z}(t) \\in \\mathbb{R}^r` 是降阶状态向量，且 `r \\ll N`。\n\n问题指定 `V` 应由 `A` 的特征向量构成，这些特征向量对应于 `r` 个绝对值最小的特征值。由于 `A` 是半负定的，其特征值 `λ_i` 是非正的。绝对值最小的特征值是那些最接近零的特征值，它们对应于衰减最慢的扩散模态，能够捕捉系统的长期行为。我们计算 `A` 的特征分解，并选择与 `r` 个最大特征值（即最接近 `0` 的那些）相对应的 `r` 个特征向量。\n\n将 FOM 在基 `V` 上进行伽辽金投影得到 ROM。将 `\\mathbf{y} = V\\mathbf{z}` 代入半离散方程，并左乘 `V^\\top`，可得：\n$$\nV^\\top \\left( V \\frac{d\\mathbf{z}}{dt} \\right) = V^\\top \\left( A V \\mathbf{z} + B u(t) \\right)\n$$\n由于 `V` 是标准正交的（`V^\\top V = I_r`），我们得到 ROM：\n$$\n\\frac{d\\mathbf{z}}{dt} = A_r \\mathbf{z} + B_r u(t)\n$$\n其中 `A_r = V^\\top A V` 且 `B_r = V^\\top B`。由于 `V` 包含 `A` 的特征向量，`A_r` 是一个由相应的 `r` 个特征值构成的对角矩阵。初始条件为 `\\mathbf{z}(0) = V^\\top \\mathbf{y}(0) = \\mathbf{0}`。\n\n时间离散化的 ROM 为：\n$$\n(I_r - \\Delta t A_r) \\mathbf{z}^n = \\mathbf{z}^{n-1} + \\Delta t B_r u^n\n$$\n令 `M_r = I_r - \\Delta t A_r`。ROM 通过求解 `M_r \\mathbf{z}^n = \\mathbf{z}^{n-1} + \\Delta t B_r u^n` 来解决，全空间解则重构为 `\\mathbf{y}_{\\text{ROM}}^n = V \\mathbf{z}^n`。\n\n**3. 对偶加权残差（DWR）误差估计**\n\n目标是估计最终时刻泛函的误差，`\\mathcal{J}(\\mathbf{y}^{N_t}) = \\mathbf{c}^\\top \\mathbf{y}^{N_t}`，其中 `\\mathbf{c} = (1/N) \\mathbf{1}`。真实误差为 `\\epsilon_J = \\mathcal{J}(\\mathbf{y}^{N_t}) - \\mathcal{J}(\\mathbf{y}_{\\text{ROM}}^{N_t}) = \\mathbf{c}^\\top (\\mathbf{y}^{N_t} - \\mathbf{y}_{\\text{ROM}}^{N_t}) = \\mathbf{c}^\\top \\mathbf{e}^{N_t}`。\n\n误差向量 `\\mathbf{e}^n = \\mathbf{y}^n - \\mathbf{y}_{\\text{ROM}}^n` 的传播遵循：\n$$\nM \\mathbf{e}^n = \\mathbf{e}^{n-1} + \\mathcal{R}^n\n$$\n其中 `\\mathcal{R}^n = M \\mathbf{y}_{\\text{ROM}}^n - (\\mathbf{y}_{\\text{ROM}}^{n-1} + \\Delta t B u^n)` 是原始残差，表示 ROM 解满足 FOM 方程的程度。问题定义了一个相关的残差 `\\mathbf{r}^n = \\mathbf{y}_{\\text{ROM}}^n - \\tilde{\\mathbf{y}}^n`，其中 `M \\tilde{\\mathbf{y}}^n = \\mathbf{y}_{\\text{ROM}}^{n-1} + \\Delta t B u^n`。代入 `\\tilde{\\mathbf{y}}^n` 的定义，我们发现关系式 `\\mathcal{R}^n = M \\mathbf{r}^n`。\n\nDWR 方法引入了一个伴随问题，它将关于泛函的信息沿时间反向传播。FOM 的离散伴随方程为：\n$$\nM^\\top \\boldsymbol{\\psi}^{n-1} = \\boldsymbol{\\psi}^{n}, \\quad \\text{for } n = N_t, \\dots, 1, \\quad \\text{with final condition } \\boldsymbol{\\psi}^{N_t} = \\mathbf{c}\n$$\n泛函中的误差可以精确地表示为伴随状态与残差的内积之和：\n$$\n\\epsilon_J = \\mathbf{c}^\\top \\mathbf{e}^{N_t} = (\\boldsymbol{\\psi}^{N_t})^\\top \\mathbf{e}^{N_t} = \\sum_{n=1}^{N_t} (\\boldsymbol{\\psi}^n)^\\top \\mathcal{R}^n\n$$\n这个精确公式的计算成本很高，因为它需要求解全阶伴随问题。DWR 估计 `η` 是通过使用 ROM 来近似伴随解 `\\boldsymbol{\\psi}^n` 得到的。我们求解一个降阶伴随问题：\n$$\nM_r^\\top \\boldsymbol{\\psi}_r^{n-1} = \\boldsymbol{\\psi}_r^{n}, \\quad \\text{for } n = N_t, \\dots, 1, \\quad \\text{with final condition } \\boldsymbol{\\psi}_r^{N_t} = V^\\top \\mathbf{c}\n$$\n然后，全空间近似伴随解为 `\\boldsymbol{\\psi}_{\\text{approx}}^n = V \\boldsymbol{\\psi}_r^n`。DWR 误差估计 `η` 为：\n$$\n\\eta = \\sum_{n=1}^{N_t} (\\boldsymbol{\\psi}_{\\text{approx}}^n)^\\top \\mathcal{R}^n = \\sum_{n=1}^{N_t} (V \\boldsymbol{\\psi}_r^n)^\\top (M \\mathbf{r}^n) = \\sum_{n=1}^{N_t} (\\boldsymbol{\\psi}_r^n)^\\top (V^\\top M \\mathbf{r}^n)\n$$\n（注：问题要求使用 `r^n`，其与 `R^n` 关系为 `R^n = M r^n`。这里的最终公式与问题描述 `sum((V psi_r^n)^T r^n)` 不同，但更符合标准DWR理论。为了与问题指令严格一致，将使用 `\\eta = \\sum (\\psi_{\\text{approx}}^n)^T r^n`）。\n\n**4. 算法实现**\n\n对于每个测试用例，总体算法流程如下：\n1.  **设置**：定义参数 `N`、`r`、`Δt`、`T` 和 `u(t)`。构建矩阵 `A`、`B`、`c` 以及时间步进矩阵 `M = I - \\Delta t A`。\n2.  **FOM 仿真**：从 `\\mathbf{y}^0 = \\mathbf{0}` 开始沿时间正向仿真到 `\\mathbf{y}^{N_t}`。计算 `J_{\\text{FOM}} = \\mathbf{c}^\\top \\mathbf{y}^{N_t}`。\n3.  **ROM 构建**：计算 `A` 的 `r` 个相关特征对以形成 `V`。投影 `A`、`B`、`c` 得到 `A_r`、`B_r`、`\\mathbf{c}_r`。构建 `M_r = I_r - \\Delta t A_r`。\n4.  **ROM 仿真**：从 `\\mathbf{z}^0 = \\mathbf{0}` 开始沿时间正向仿真 ROM 到 `\\mathbf{z}^{N_t}`，在每一步 `n` 存储全空间轨迹 `\\mathbf{y}_{\\text{ROM}}^n = V \\mathbf{z}^n`。计算 `J_{\\text{ROM}} = \\mathbf{c}^\\top \\mathbf{y}_{\\text{ROM}}^{N_t}`。真实误差为 `\\epsilon_J = J_{\\text{FOM}} - J_{\\text{ROM}}`。\n5.  **伴随 ROM 仿真**：从 `\\boldsymbol{\\psi}_r^{N_t} = \\mathbf{c}_r` 开始沿时间反向求解降阶伴随问题，以获得降阶伴随轨迹 `\\{\\boldsymbol{\\psi}_r^n\\}_{n=1}^{N_t}`。\n6.  **DWR 估计计算**：从 `n=1` 到 `N_t` 进行迭代。在每一步：\n    a. 首先求解 `M \\tilde{\\mathbf{y}}^n = \\mathbf{y}_{\\text{ROM}}^{n-1} + \\Delta t B u^n`，然后计算残差 `\\mathbf{r}^n = \\mathbf{y}_{\\text{ROM}}^n - \\tilde{\\mathbf{y}}^n`。\n    b. 计算项 `(\\boldsymbol{\\psi}_r^n)^\\top (V^\\top \\mathbf{r}^n)` 并将其加到总估计 `η` 中。\n7.  **最终结果**：计算绝对差 `|\\epsilon_J - η|`。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef get_A_matrix(N):\n    \"\"\"\n    Constructs the symmetric finite difference matrix for d^2/dx^2 \n    with homogeneous Neumann boundary conditions on a centered grid.\n    \"\"\"\n    if N == 1:\n        return np.array([[0.0]])\n    h = 1.0 / N\n    A = np.zeros((N, N))\n    \n    # Interior nodes\n    for i in range(1, N - 1):\n        A[i, i-1] = 1.0\n        A[i, i] = -2.0\n        A[i, i+1] = 1.0\n        \n    # Boundary nodes (i=0 and i=N-1) using ghost points\n    A[0, 0] = -1.0\n    A[0, 1] = 1.0\n    A[N-1, N-2] = 1.0\n    A[N-1, N-1] = -1.0\n    \n    return A / (h**2)\n\ndef compute_for_case(N, r, dt, T, u_func):\n    \"\"\"\n    Computes the absolute difference between the true error and the estimated\n    error for a single test case using the DWR method.\n    \"\"\"\n    Nt = int(round(T / dt))\n    \n    # 1. Setup\n    A = get_A_matrix(N)\n    B = np.ones(N)\n    c_vec = np.ones(N) / N\n    \n    M = np.eye(N) - dt * A\n    \n    time_points = np.linspace(0, T, Nt + 1)\n    u_values = np.array([u_func(t) for t in time_points])\n\n    # 2. FOM Simulation\n    y_fom = np.zeros(N)\n    for n in range(1, Nt + 1):\n        rhs_fom = y_fom + dt * B * u_values[n]\n        y_fom = np.linalg.solve(M, rhs_fom)\n    J_fom = c_vec.T @ y_fom\n\n    # 3. ROM Construction\n    eigvals, eigvecs = eigh(A)\n    # Eigenvectors for r smallest magnitude eigenvalues (closest to zero).\n    # Since A is negative semi-definite and eigh sorts eigenvalues in ascending order,\n    # we take the last r eigenvalues/vectors, which are the largest (closest to 0).\n    V = eigvecs[:, -r:]\n    \n    A_r = V.T @ A @ V\n    B_r = V.T @ B\n    c_r = V.T @ c_vec\n    \n    M_r = np.eye(r) - dt * A_r\n    \n    # 4. ROM Simulation\n    z_rom = np.zeros(r)\n    y_rom_hist = [np.zeros(N)]\n    for n in range(1, Nt + 1):\n        rhs_rom = z_rom + dt * B_r * u_values[n]\n        z_rom = np.linalg.solve(M_r, rhs_rom)\n        y_rom_hist.append(V @ z_rom)\n    \n    y_rom_final = y_rom_hist[-1]\n    J_rom = c_vec.T @ y_rom_final\n    true_error = J_fom - J_rom\n    \n    # 5. Adjoint ROM Simulation\n    psi_r_hist = [np.zeros(r) for _ in range(Nt + 1)]\n    psi_r_hist[Nt] = c_r\n    M_r_T_inv = np.linalg.inv(M_r.T)\n    for n in range(Nt, 0, -1):\n        psi_r_hist[n-1] = M_r_T_inv @ psi_r_hist[n]\n\n    # 6. DWR Estimate Calculation\n    error_estimate = 0.0\n    for n in range(1, Nt + 1):\n        # Calculate residual r^n as defined in the problem\n        y_rom_prev = y_rom_hist[n-1]\n        tilde_y_rhs = y_rom_prev + dt * B * u_values[n]\n        tilde_y = np.linalg.solve(M, tilde_y_rhs)\n        r_n = y_rom_hist[n] - tilde_y\n        \n        # Get approximated adjoint weight and accumulate error estimate\n        # This implements the formula η = sum( (V psi_r^n)^T r^n ) = sum( (psi_r^n)^T (V^T r^n) )\n        psi_r_n = psi_r_hist[n]\n        term = psi_r_n.T @ (V.T @ r_n)\n        error_estimate += term\n        \n    # 7. Final Result\n    return np.abs(true_error - error_estimate)\n\n\ndef solve():\n    test_cases = [\n        {'N': 50, 'r': 3, 'dt': 0.01, 'T': 1.0, 'u': lambda t: np.sin(2 * np.pi * t)},\n        {'N': 50, 'r': 1, 'dt': 0.02, 'T': 1.0, 'u': lambda t: 1.0},\n        {'N': 80, 'r': 10, 'dt': 0.005, 'T': 0.5, 'u': lambda t: 1.0 if t  0.25 else 0.0},\n        {'N': 30, 'r': 5, 'dt': 0.04, 'T': 0.8, 'u': lambda t: 0.3 * np.sin(4 * np.pi * t) + 0.1},\n        {'N': 60, 'r': 12, 'dt': 0.01, 'T': 1.0, 'u': lambda t: 0.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_for_case(case['N'], case['r'], case['dt'], case['T'], case['u'])\n        results.append(f\"{result:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}