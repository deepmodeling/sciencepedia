{
    "hands_on_practices": [
        {
            "introduction": "在模拟电池随时间的行为之前，我们必须找到一个有效的起点，其中所有物理定律（即代数约束）在给定的初始状态（如荷电状态）和输入（如外加电流）下都得到满足。本练习  使用一个简化的Doyle-Fuller-Newman (DFN) 模型，演示了如何将此初始化问题构建为一个非线性方程组，并使用牛顿法进行数值求解。通过这个实践，你将掌握为复杂的微分代数方程（DAE）模型计算一致初始条件的关键技能。",
            "id": "3903333",
            "problem": "考虑锂离子电池的 Doyle–Fuller–Newman (DFN) 模型在空间上半离散化的情况，其中固相和电解质相的电势是代数变量，而浓度是微分变量。在隐式时间积分（例如，后向欧拉法）开始时，一致的初始条件必须满足在时间 $t = 0$ 时，对于指定的施加电流和荷电状态的代数约束。假设一个双电极电池，包含一个负极 (n) 和一个正极 (p)，并假定负极处的电解质电势被选为规范参考值 $0$（通过规范固定进行指数约简）。以下经过充分检验的科学关系被作为基本依据：\n\n- 每个电极界面处的电荷守恒将反应电流密度与按界面面积缩放的施加电流相等同。\n- 具有对称转移系数的 Butler–Volmer 动力学将反应电流密度与活化过电势相关联。\n- 电解质中的欧姆关系近似地将电极间的电解质电势降与施加电流成正比。\n\n令 $i_{\\mathrm{app}}$ 表示无量纲的施加电流（由特征电流和面积归一化），$a_n$ 和 $a_p$ 分别表示负极和正极的无量纲界面面积缩放因子，$k_n$ 和 $k_p$ 表示无量纲动力学前置因子，$r_e$ 表示无量纲电解质电阻，并令开路电势 $U_n$ 和 $U_p$ 由能斯特型关系式给出\n$$\nU_{\\ell}(c_{\\ell}) = U_{\\ell,\\mathrm{ref}} + \\beta_{\\ell}\\,\\ln\\!\\left(\\frac{c_{\\ell}}{1 - c_{\\ell}}\\right), \\quad \\ell \\in \\{n,p\\},\n$$\n其中 $c_{\\ell}\\in(0,1)$ 是电极表面的无量纲固相锂分数（初始时等于每个电极的荷电状态），$U_{\\ell,\\mathrm{ref}}$ 是一个无量纲参考电势，$\\beta_{\\ell}$ 是一个无量纲系数。\n\n令未知数为每个电极的固相电势 $ \\phi_{s,n}$、$ \\phi_{s,p}$ 和正极的电解质电势 $ \\phi_{e,p}$，规范条件为 $ \\phi_{e,n} = 0$。Butler–Volmer 反应电流密度为\n$$\nj_n = 2\\,k_n\\,\\sinh\\!\\left(\\frac{\\phi_{s,n} - \\phi_{e,n} - U_n(c_n)}{2}\\right) = 2\\,k_n\\,\\sinh\\!\\left(\\frac{\\phi_{s,n} - U_n(c_n)}{2}\\right),\n$$\n$$\nj_p = 2\\,k_p\\,\\sinh\\!\\left(\\frac{\\phi_{s,p} - \\phi_{e,p} - U_p(c_p)}{2}\\right),\n$$\n以及为确保与指定的施加电流和荷电状态一致而建立的代数系统是\n$$\nF_1(\\phi_{s,n}) = a_n\\,j_n - i_{\\mathrm{app}} = 0,\n$$\n$$\nF_2(\\phi_{s,p},\\phi_{e,p}) = a_p\\,j_p + i_{\\mathrm{app}} = 0,\n$$\n$$\nF_3(\\phi_{e,p}) = \\phi_{e,p} - r_e\\,i_{\\mathrm{app}} = 0.\n$$\n初始固相浓度是微分变量，因此可以根据 $t=0$ 时指定的荷电状态自由设定，即 $ c_n = \\mathrm{SOC}_n$ 和 $ c_p = \\mathrm{SOC}_p$。本问题要求构建该系统并概述求解该系统的牛顿法。\n\n任务：\n1. 从上述基本依据出发，写出非线性系统 $F(\\mathbf{x}) = \\mathbf{0}$，其中 $\\mathbf{x} = [\\phi_{s,n}, \\phi_{s,p}, \\phi_{e,p}]^\\top$。求解该系统可得到与指定的初始电流 $i_{\\mathrm{app}}$ 和荷电状态值 $c_n$、$c_p$ 相一致的初始电势和浓度。\n2. 推导适用于牛顿迭代的解析雅可比矩阵 $J(\\mathbf{x}) = \\partial F/\\partial \\mathbf{x}$。\n3. 实现一种阻尼牛顿法，在给定参数值和初始猜测的情况下求解 $\\phi_{s,n}$、$\\phi_{s,p}$ 和 $\\phi_{e,p}$。使用规范条件 $ \\phi_{e,n} = 0$。将 $c_n$ 和 $c_p$ 分别视为给定的 $\\mathrm{SOC}_n$ 和 $\\mathrm{SOC}_p$。\n4. 提供一个包含三组参数的测试套件，用于测试不同的工况：\n   - 一个典型工作电流工况。\n   - 一个 $i_{\\mathrm{app}} = 0$ 的近平衡工况。\n   - 一个大电流工况。\n   对于每种工况，指定 $(i_{\\mathrm{app}}, \\mathrm{SOC}_n, \\mathrm{SOC}_p, a_n, a_p, k_n, k_p, r_e, U_{n,\\mathrm{ref}}, U_{p,\\mathrm{ref}}, \\beta_n, \\beta_p)$。\n5. 最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的聚合结果，形式为方括号内的逗号分隔列表。对于每个测试用例，按顺序输出六个浮点数 $[\\phi_{s,n}, \\phi_{e,n}, \\phi_{s,p}, \\phi_{e,p}, c_n, c_p]$，并将所有测试用例的结果展平为一个列表。所有量均为无量纲，因此不需要物理单位。\n\n使用的测试套件参数：\n- 工况1（典型）：$(i_{\\mathrm{app}}, \\mathrm{SOC}_n, \\mathrm{SOC}_p, a_n, a_p, k_n, k_p, r_e, U_{n,\\mathrm{ref}}, U_{p,\\mathrm{ref}}, \\beta_n, \\beta_p) = (0.5, 0.7, 0.4, 1.0, 1.0, 1.0, 1.0, 0.2, 0.1, 4.0, 0.1, 0.1)$。\n- 工况2（近平衡）：$(0.0, 0.6, 0.6, 1.0, 1.0, 1.0, 1.0, 0.3, 0.15, 3.9, 0.2, 0.2)$。\n- 工况3（大电流）：$(2.0, 0.9, 0.3, 1.0, 1.0, 1.5, 1.0, 0.5, 0.2, 4.2, 0.15, 0.12)$。\n\n您的程序必须实现上述定义的非线性系统的牛顿求解，并生成指定的输出格式。不需要用户输入。",
            "solution": "该问题要求构建并求解一个非线性代数系统，以确定半离散化 Doyle-Fuller-Newman (DFN) 电池模型的一致初始条件。分析过程分为三步：首先，构建控制方程组；其次，推导牛顿-拉夫逊迭代求解器所需的雅可比矩阵；第三，概述用于求解的阻尼牛顿法的实现。\n\n### 1. 非线性系统的构建\n\n未知数的状态向量定义为 $\\mathbf{x} = [\\phi_{s,n}, \\phi_{s,p}, \\phi_{e,p}]^\\top$，分别代表负极的固相电势、正极的固相电势和正极的电解质相电势。负极处的电解质电势通过规范条件固定为 $\\phi_{e,n} = 0$。初始固相表面浓度 $c_n$ 和 $c_p$ 作为固定参数给出，等于电极特定的荷电状态 $\\mathrm{SOC}_n$ 和 $\\mathrm{SOC}_p$。\n\n方程组 $F(\\mathbf{x}) = \\mathbf{0}$ 源于基本的电化学和传输原理：\n\n1.  **负极界面处的电荷守恒：** 在整个界面面积上由电化学反应产生的总电流必须等于施加的电流 $i_{\\mathrm{app}}$。这给出第一个方程：\n    $$F_1 = a_n\\,j_n - i_{\\mathrm{app}} = 0$$\n    这里，$a_n$ 是界面面积缩放因子，$j_n$ 是负极的反应电流密度。\n\n2.  **正极界面处的电荷守恒：** 同样，考虑到符号约定（放电时电流流入正极），我们有：\n    $$F_2 = a_p\\,j_p + i_{\\mathrm{app}} = 0$$\n    其中 $a_p$ 是面积缩放因子，$j_p$ 是正极的反应电流密度。\n\n3.  **电解质中的欧姆降：** 一个简化的欧姆模型将电解质中的电势降与施加的电流相关联：\n    $$F_3 = \\phi_{e,p} - \\phi_{e,n} - r_e\\,i_{\\mathrm{app}} = 0$$\n    使用规范条件 $\\phi_{e,n}=0$，该式简化为：\n    $$F_3 = \\phi_{e,p} - r_e\\,i_{\\mathrm{app}} = 0$$\n    其中 $r_e$ 是电解质的有效无量纲电阻。\n\n反应电流密度 $j_n$ 和 $j_p$ 由对称转移系数（$\\alpha_a = \\alpha_c = 0.5$）的 Butler-Volmer 方程描述：\n$$j_{\\ell} = 2\\,k_{\\ell}\\,\\sinh\\!\\left(\\frac{\\eta_{\\ell}}{2}\\right), \\quad \\ell \\in \\{n, p\\}$$\n其中 $k_{\\ell}$ 是动力学速率前置因子，$\\eta_{\\ell}$ 是活化过电势，定义为 $\\eta_{\\ell} = \\phi_{s,\\ell} - \\phi_{e,\\ell} - U_{\\ell}(c_{\\ell})$。开路电势 $U_n$ 和 $U_p$ 是表面浓度的函数，由下式给出：\n$$U_{\\ell}(c_{\\ell}) = U_{\\ell,\\mathrm{ref}} + \\beta_{\\ell}\\,\\ln\\!\\left(\\frac{c_{\\ell}}{1 - c_{\\ell}}\\right)$$\n对于此初始化问题，$c_n$ 和 $c_p$ 是固定的，因此 $U_n$ 和 $U_p$ 被视为常数。\n\n将 $j_n$ 和 $j_p$ 的表达式代入守恒方程，我们得到显式的非线性系统 $F(\\mathbf{x}) = [F_1, F_2, F_3]^\\top = \\mathbf{0}$：\n$$\nF_1(\\phi_{s,n}) = 2\\,a_n\\,k_n\\,\\sinh\\!\\left(\\frac{\\phi_{s,n} - U_n}{2}\\right) - i_{\\mathrm{app}} = 0\n$$\n$$\nF_2(\\phi_{s,p}, \\phi_{e,p}) = 2\\,a_p\\,k_p\\,\\sinh\\!\\left(\\frac{\\phi_{s,p} - \\phi_{e,p} - U_p}{2}\\right) + i_{\\mathrm{app}} = 0\n$$\n$$\nF_3(\\phi_{e,p}) = \\phi_{e,p} - r_e\\,i_{\\mathrm{app}} = 0\n$$\n\n### 2. 雅可比矩阵的推导\n\n牛顿-拉夫逊法需要雅可比矩阵 $J(\\mathbf{x}) = \\partial F / \\partial \\mathbf{x}$，其元素为 $J_{ij} = \\partial F_i / \\partial x_j$。状态向量为 $\\mathbf{x} = [\\phi_{s,n}, \\phi_{s,p}, \\phi_{e,p}]^\\top$。\n\n偏导数计算如下，使用链式法则以及 $d(\\sinh(u))/dx = \\cosh(u) \\cdot du/dx$ 这一事实。\n\n- **$F_1$ 的导数：**\n  - $\\frac{\\partial F_1}{\\partial \\phi_{s,n}} = 2\\,a_n\\,k_n\\,\\cosh\\!\\left(\\frac{\\phi_{s,n} - U_n}{2}\\right) \\cdot \\frac{1}{2} = a_n\\,k_n\\,\\cosh\\!\\left(\\frac{\\phi_{s,n} - U_n}{2}\\right)$\n  - $\\frac{\\partial F_1}{\\partial \\phi_{s,p}} = 0$\n  - $\\frac{\\partial F_1}{\\partial \\phi_{e,p}} = 0$\n\n- **$F_2$ 的导数：**\n  - $\\frac{\\partial F_2}{\\partial \\phi_{s,n}} = 0$\n  - $\\frac{\\partial F_2}{\\partial \\phi_{s,p}} = 2\\,a_p\\,k_p\\,\\cosh\\!\\left(\\frac{\\phi_{s,p} - \\phi_{e,p} - U_p}{2}\\right) \\cdot \\frac{1}{2} = a_p\\,k_p\\,\\cosh\\!\\left(\\frac{\\phi_{s,p} - \\phi_{e,p} - U_p}{2}\\right)$\n  - $\\frac{\\partial F_2}{\\partial \\phi_{e,p}} = 2\\,a_p\\,k_p\\,\\cosh\\!\\left(\\frac{\\phi_{s,p} - \\phi_{e,p} - U_p}{2}\\right) \\cdot \\left(-\\frac{1}{2}\\right) = -a_p\\,k_p\\,\\cosh\\!\\left(\\frac{\\phi_{s,p} - \\phi_{e,p} - U_p}{2}\\right)$\n\n- **$F_3$ 的导数：**\n  - $\\frac{\\partial F_3}{\\partial \\phi_{s,n}} = 0$\n  - $\\frac{\\partial F_3}{\\partial \\phi_{s,p}} = 0$\n  - $\\frac{\\partial F_3}{\\partial \\phi_{e,p}} = 1$\n\n组合这些分量得到雅可比矩阵：\n$$\nJ(\\mathbf{x}) = \\begin{pmatrix}\na_n k_n \\cosh\\!\\left(\\frac{\\phi_{s,n} - U_n}{2}\\right) & 0 & 0 \\\\\n0 & a_p k_p \\cosh\\!\\left(\\frac{\\phi_{s,p} - \\phi_{e,p} - U_p}{2}\\right) & -a_p k_p \\cosh\\!\\left(\\frac{\\phi_{s,p} - \\phi_{e,p} - U_p}{2}\\right) \\\\\n0 & 0 & 1\n\\end{pmatrix}\n$$\n雅可比矩阵的上三角结构表明该系统仅是部分耦合的。\n\n### 3. 阻尼牛顿法\n\n牛顿-拉夫逊法是一种用于寻找 $F(\\mathbf{x}) = \\mathbf{0}$ 根的迭代过程。从一个初始猜测值 $\\mathbf{x}_0$ 开始，通过求解基于 $F(\\mathbf{x})$ 在当前迭代点 $\\mathbf{x}_k$ 附近的一阶泰勒展开的线性系统，来找到后续的近似值 $\\mathbf{x}_{k+1}$。\n\n迭代更新由下式给出：\n$$ \\mathbf{x}_{k+1} = \\mathbf{x}_k + \\alpha_k \\Delta\\mathbf{x}_k $$\n其中步长方向 $\\Delta\\mathbf{x}_k$ 是以下线性系统的解：\n$$ J(\\mathbf{x}_k) \\Delta\\mathbf{x}_k = -F(\\mathbf{x}_k) $$\n标量 $\\alpha_k \\in (0, 1]$ 是一个阻尼因子，其选择是为了确保从更广泛的初始猜测值范围收敛。采用回溯线搜索来选择 $\\alpha_k$：从 $\\alpha_k = 1$ 开始，依次减小（例如，减半），直到满足条件 $\\|F(\\mathbf{x}_k + \\alpha_k \\Delta\\mathbf{x}_k)\\| < \\|F(\\mathbf{x}_k)\\|$，以确保每一步的残差范数都在减小。\n\n算法流程如下：\n1.  使用一个猜测值 $\\mathbf{x}_0$ 进行初始化。一个具有物理动机的选择是 $\\mathbf{x}_0 = [U_n, U_p, 0]^\\top$，对应于平衡状态。\n2.  对于 $k=0, 1, 2, \\dots$：\n    a. 计算残差向量 $F(\\mathbf{x}_k)$ 及其范数 $\\|F(\\mathbf{x}_k)\\|$。如果范数低于指定的容差 $\\epsilon$，则算法收敛。\n    b. 计算雅可比矩阵 $J(\\mathbf{x}_k)$。\n    c. 求解线性系统 $J(\\mathbf{x}_k) \\Delta\\mathbf{x}_k = -F(\\mathbf{x}_k)$ 以获得更新步长 $\\Delta\\mathbf{x}_k$。\n    d. 执行回溯线搜索以找到合适的阻尼因子 $\\alpha_k$。\n    e. 更新解：$\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\alpha_k \\Delta\\mathbf{x}_k$。\n3.  最终的迭代值 $\\mathbf{x}_k$ 是初始电势 $[\\phi_{s,n}, \\phi_{s,p}, \\phi_{e,p}]^\\top$ 的数值解。\n随后时间积分中使用的初始条件由已解出的电势和指定的初始浓度给出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve for consistent initial conditions for all test cases.\n    \"\"\"\n    # Test suite parameters:\n    # (i_app, SOC_n, SOC_p, a_n, a_p, k_n, k_p, r_e, U_n_ref, U_p_ref, beta_n, beta_p)\n    test_cases = [\n        # Case 1 (typical)\n        (0.5, 0.7, 0.4, 1.0, 1.0, 1.0, 1.0, 0.2, 0.1, 4.0, 0.1, 0.1),\n        # Case 2 (near-equilibrium)\n        (0.0, 0.6, 0.6, 1.0, 1.0, 1.0, 1.0, 0.3, 0.15, 3.9, 0.2, 0.2),\n        # Case 3 (high-current)\n        (2.0, 0.9, 0.3, 1.0, 1.0, 1.5, 1.0, 0.5, 0.2, 4.2, 0.15, 0.12),\n    ]\n\n    all_results_flat = []\n\n    for i, case_params in enumerate(test_cases):\n        params = {\n            'i_app': case_params[0],\n            'soc_n': case_params[1],\n            'soc_p': case_params[2],\n            'a_n': case_params[3],\n            'a_p': case_params[4],\n            'k_n': case_params[5],\n            'k_p': case_params[6],\n            'r_e': case_params[7],\n            'U_n_ref': case_params[8],\n            'U_p_ref': case_params[9],\n            'beta_n': case_params[10],\n            'beta_p': case_params[11],\n        }\n\n        # Calculate open-circuit potentials\n        params['U_n'] = _calc_ocp(params['U_n_ref'], params['beta_n'], params['soc_n'])\n        params['U_p'] = _calc_ocp(params['U_p_ref'], params['beta_p'], params['soc_p'])\n\n        # Initial guess for x = [phi_s,n, phi_s,p, phi_e,p]\n        # A good guess is the equilibrium potential state.\n        x0 = np.array([params['U_n'], params['U_p'], 0.0])\n\n        # Solve the nonlinear system using the Newton method\n        x_sol = _newton_solver(params, x0)\n\n        phi_sn_sol, phi_sp_sol, phi_ep_sol = x_sol\n\n        # Collect results for this case in the specified order\n        # [phi_s,n, phi_e,n, phi_s,p, phi_e,p, c_n, c_p]\n        # phi_e,n is 0 by gauge choice. c_n/c_p are the given SOCs.\n        case_results = [\n            phi_sn_sol,\n            0.0,\n            phi_sp_sol,\n            phi_ep_sol,\n            params['soc_n'],\n            params['soc_p'],\n        ]\n        all_results_flat.extend(case_results)\n\n    # Print the flattened list in the required format\n    print(f\"[{','.join(f'{v:.6f}' for v in all_results_flat)}]\")\n\n\ndef _calc_ocp(U_ref, beta, c):\n    \"\"\"Calculates the open-circuit potential using the Nernst-type relation.\"\"\"\n    if not (0  c  1):\n        raise ValueError(\"Concentration c must be in the interval (0, 1).\")\n    return U_ref + beta * np.log(c / (1.0 - c))\n\n\ndef _evaluate_F(x, params):\n    \"\"\"\n    Evaluates the residual vector F(x) of the nonlinear system.\n    x = [phi_s,n, phi_s,p, phi_e,p]\n    \"\"\"\n    phi_sn, phi_sp, phi_ep = x\n\n    # Butler-Volmer current densities\n    jn = 2.0 * params['k_n'] * np.sinh((phi_sn - params['U_n']) / 2.0)\n    jp = 2.0 * params['k_p'] * np.sinh((phi_sp - phi_ep - params['U_p']) / 2.0)\n\n    # Residuals\n    F1 = params['a_n'] * jn - params['i_app']\n    F2 = params['a_p'] * jp + params['i_app']\n    F3 = phi_ep - params['r_e'] * params['i_app']\n\n    return np.array([F1, F2, F3])\n\n\ndef _evaluate_J(x, params):\n    \"\"\"\n    Evaluates the Jacobian matrix J(x) of the nonlinear system.\n    x = [phi_s,n, phi_s,p, phi_e,p]\n    \"\"\"\n    phi_sn, phi_sp, phi_ep = x\n\n    # Jacobian components\n    J11 = params['a_n'] * params['k_n'] * np.cosh((phi_sn - params['U_n']) / 2.0)\n\n    common_term_p = params['a_p'] * params['k_p'] * np.cosh((phi_sp - phi_ep - params['U_p']) / 2.0)\n    J22 = common_term_p\n    J23 = -common_term_p\n\n    return np.array([\n        [J11, 0.0, 0.0],\n        [0.0, J22, J23],\n        [0.0, 0.0, 1.0]\n    ])\n\n\ndef _newton_solver(params, x0, tol=1e-10, max_iter=50, max_backtrack=10):\n    \"\"\"\n    Solves F(x)=0 using a damped Newton-Raphson method.\n    \"\"\"\n    x = np.copy(x0).astype(float)\n\n    for _ in range(max_iter):\n        F = _evaluate_F(x, params)\n        norm_F = np.linalg.norm(F)\n\n        if norm_F  tol:\n            return x\n\n        J = _evaluate_J(x, params)\n        if np.linalg.det(J) == 0:\n            raise RuntimeError(\"Newton solver failed: Jacobian is singular.\")\n\n        delta_x = np.linalg.solve(J, -F)\n\n        # Damping via backtracking line search\n        alpha = 1.0\n        for _ in range(max_backtrack):\n            x_new = x + alpha * delta_x\n            norm_F_new = np.linalg.norm(_evaluate_F(x_new, params))\n            if norm_F_new  norm_F:\n                break\n            alpha /= 2.0\n        else: # Loop completed without break\n            raise RuntimeError(\"Newton solver failed: line search did not converge.\")\n\n        x = x_new\n    \n    raise RuntimeError(\"Newton solver failed: maximum iterations reached.\")\n\n\nif __name__ == '__main__':\n    solve()\n\n```"
        },
        {
            "introduction": "在对微分代数方程（DAE）进行数值积分时，离散化带来的近似误差可能导致数值解逐渐“漂移”出代数约束定义的流形，从而产生不符合物理实际的结果。本实践  通过一个具有精确解析解的简单模型，对比了一种朴素的积分方案和一种包含投影步骤的方案。它清晰地展示了投影如何在每一步强制执行代数约束，从而显著提高全局解的准确性。",
            "id": "3903303",
            "problem": "考虑一个半显式微分代数方程 (DAE) 模型，该模型捕捉了微分状态与代数约束之间的简化耦合关系，这在用于自动化电池设计和仿真的电化学模型中很典型。设微分变量为 $x(t)$ (无量纲的电极状态代理)，代数变量为 $z(t)$ (无量纲的电解质电位代理)。该模型由以下系统组成：\n$$\\frac{dx}{dt} = f(x,z,t) = -a\\,x(t) + b\\,z(t),$$\n以及代数约束\n$$g(x,z,t) = z(t) - \\phi(x,t) = 0,$$\n其中约束流形由下式给出\n$$\\phi(x,t) = x(t) + \\sin(t).$$\n所有量均为无量纲，所有角度必须以弧度为单位。\n\n初始条件与约束流形相容：\n$$x(0) = x_0,\\quad z(0) = x_0 + \\sin(0) = x_0.$$\n\n您必须使用后向欧拉法为微分方程实现一个隐式时间积分格式，并演示在每个隐式时间步后通过求解关于代数变量 $z$ 的方程 $g(x,z,t)=0$，将解投影回约束流形的投影步骤。具体来说，考虑两种算法：\n\n- 算法 A (无投影)：使用滞后的代数变量 $z_n$ 通过后向欧拉法推进 $x$，并保持 $z$ 不变：\n$$x_{n+1} = \\frac{x_n + h\\,b\\,z_n}{1 + h\\,a},\\quad z_{n+1} = z_n.$$\n\n- 算法 B (带投影)：使用滞后的代数变量 $z_n$ 通过后向欧拉法推进 $x$，然后通过求解关于 $z_{n+1}$ 的方程 $g(x_{n+1},z_{n+1},t_{n+1})=0$ 投影到约束流形上：\n$$x_{n+1} = \\frac{x_n + h\\,b\\,z_n}{1 + h\\,a},\\quad z_{n+1} = x_{n+1} + \\sin(t_{n+1}).$$\n\n目标是评估投影步骤对全局误差的影响。通过执行 DAE 指数约化（通过约束消去代数变量）来定义精确解：\n$$z(t) = x(t) + \\sin(t),$$\n这会得到约化后的常微分方程\n$$\\frac{dx}{dt} = -a\\,x(t) + b\\,(x(t) + \\sin(t)) = c\\,x(t) + b\\,\\sin(t),\\quad c = -a + b.$$\n对于相容的初始条件 $x(0) = x_0$，$x(t)$ 的精确解为\n$$x(t) = e^{c t}\\left(x_0 + \\frac{b}{c^2 + 1}\\right) + \\frac{b}{c^2 + 1}\\left(-c\\,\\sin(t) - \\cos(t)\\right),$$\n精确的代数变量为\n$$z(t) = x(t) + \\sin(t).$$\n\n对于给定的均匀时间步长 $h$ 和最终时间 $T$，计算每种算法在离散时间网格 $\\{t_n\\}_{n=0}^{N}$（其中 $N = T/h$）上的全局均方根 (RMS) 误差：\n$$E = \\sqrt{\\frac{1}{N+1}\\sum_{n=0}^{N}\\left[(x_n - x(t_n))^2 + (z_n - z(t_n))^2\\right]}.$$\n报告 RMS 误差的比值，\n$$R = \\frac{E_{\\text{no\\_proj}}}{E_{\\text{proj}}},$$\n其中 $E_{\\text{no\\_proj}}$ 是算法 A (无投影) 的 RMS 误差，$E_{\\text{proj}}$ 是算法 B (带投影) 的 RMS 误差。若 $R  1$，则表示投影减小了全局误差。\n\n所有计算必须使用弧度作为角度单位。所有量均为无量纲。\n\n测试套件：\n使用以下参数集来评估该方法。在每种情况下，均使用相同的相容初始条件 $x_0 = 0.1$：\n1. 标准情况：$a = 1.5$, $b = 1.0$, $T = 10.0$, $h = 0.1$。\n2. 小时间步长边界：$a = 1.5$, $b = 1.0$, $T = 10.0$, $h = 0.001$。\n3. 大时间步长边缘情况：$a = 1.5$, $b = 1.0$, $T = 10.0$, $h = 2.0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目是按上述顺序列出的一个测试用例的浮点误差比 $R$，例如 $[R_1,R_2,R_3]$。每个 $R_i$ 必须作为 Python 浮点数输出。",
            "solution": "该问题要求对一个半显式微分代数方程 (DAE) 系统的两种数值积分格式进行严格比较，该系统是类似于电池仿真中所用模型的简化模型。主要目标是通过在每个时间步后应用投影步骤来强制执行代数约束，从而量化全局精度的提升。\n\n首先，我们重述控制方程。该系统由状态 $x(t)$ 的微分方程和变量 $z(t)$ 的代数约束组成：\n$$\n\\frac{dx}{dt} = -a\\,x(t) + b\\,z(t)\n$$\n$$\ng(x,z,t) = z(t) - (x(t) + \\sin(t)) = 0\n$$\n量 $a$ 和 $b$ 是常数参数。初始条件为 $x(0) = x_0$ 和 $z(0) = z_0$，它们必须与 $t=0$ 时的代数约束相容。这种相容性得到确认：$z(0) = x(0) + \\sin(0) = x_0$。\n\n为了评估数值解，我们需要一个精确的解析解。这可以通过 DAE 指数约化获得。该 DAE 系统是指数-1 的，意味着对代数约束进行一次微分就足以获得关于 $z$ 的微分方程。然而，一个更简单的方法是将代数约束直接代入微分方程中。根据约束，我们有 $z(t) = x(t) + \\sin(t)$。将其代入 $\\frac{dx}{dt}$ 的方程中，可得：\n$$\n\\frac{dx}{dt} = -a\\,x(t) + b\\,(x(t) + \\sin(t)) = (b-a)x(t) + b\\,\\sin(t)\n$$\n令 $c = b-a$，我们得到约化后的常微分方程 (ODE)：\n$$\n\\frac{dx}{dt} = c\\,x(t) + b\\,\\sin(t)\n$$\n这是一个标准的一阶线性非齐次常微分方程。对于初始条件 $x(0) = x_0$，其解（如题目所提供并已验证）为：\n$$\nx(t) = e^{c t}\\left(x_0 + \\frac{b}{c^2 + 1}\\right) + \\frac{b}{c^2 + 1}\\left(-c\\,\\sin(t) - \\cos(t)\\right)\n$$\n然后，可以从约束中轻易地找到代数变量 $z(t)$ 的精确解：\n$$\nz(t) = x(t) + \\sin(t)\n$$\n这些 $x(t)$ 和 $z(t)$ 的表达式构成了我们的基准真相。\n\n现在我们来看数值格式。时间域 $[0, T]$ 被离散化为 $N$ 个步长为 $h = T/N$ 的时间步，离散时间点为 $t_n = n \\cdot h$，其中 $n = 0, 1, \\dots, N$。两种算法都对微分部分使用后向欧拉法，通过使用前一时间步的代数变量值 $z_n$ 使其变为半隐式：\n$$\n\\frac{x_{n+1} - x_n}{h} = -a\\,x_{n+1} + b\\,z_n\n$$\n求解 $x_{n+1}$ 得到两种算法共有的更新规则：\n$$\nx_{n+1} = \\frac{x_n + h\\,b\\,z_n}{1 + h\\,a}\n$$\n\n这两种算法在如何更新 $z_{n+1}$ 上有所不同：\n\n**算法 A (无投影)：** 这是最朴素的方法。代数变量在时间步内被视为常数参数，并且不进行更新以满足约束。这种方法计算成本低，但预计精度不高。\n$$\nx_{n+1} = \\frac{x_n + h\\,b\\,z_n}{1 + h\\,a}\n$$\n$$\nz_{n+1} = z_n\n$$\n数值解 $(x_n, z_n)$ 通常会偏离由 $g(x,z,t)=0$ 定义的约束流形。\n\n**算法 B (带投影)：** 该算法引入了一个校正（或投影）步骤。在计算出微分状态的新值 $x_{n+1}$ 后，显式地计算代数状态 $z_{n+1}$ 以满足新时间 $t_{n+1}$ 处的约束。\n$$\nx_{n+1} = \\frac{x_n + h\\,b\\,z_n}{1 + h\\,a} \\quad (\\text{积分步})\n$$\n$$\nz_{n+1} = x_{n+1} + \\sin(t_{n+1}) \\quad (\\text{投影步})\n$$\n这种方法是一种坐标投影，它确保数值解 $(x_{n+1}, z_{n+1})$ 在每个时间步 $t_{n+1}$ 都位于约束流形上。这有望防止漂移误差的累积，并产生更精确的全局解。\n\n为了比较这些算法，我们为每种算法计算全局均方根 (RMS) 误差。误差 $E$ 定义为在包括 $t_0$ 在内的所有时间点上，数值解 $(x_n, z_n)$ 与精确解 $(x(t_n), z(t_n))$ 之间均方欧几里得距离的平方根：\n$$\nE = \\sqrt{\\frac{1}{N+1}\\sum_{n=0}^{N}\\left[(x_n - x(t_n))^2 + (z_n - z(t_n))^2\\right]}\n$$\n我们计算算法 A ($E_{\\text{no\\_proj}}$) 和算法 B ($E_{\\text{proj}}$) 的此误差。最终的比较指标是这些误差的比值：\n$$\nR = \\frac{E_{\\text{no\\_proj}}}{E_{\\text{proj}}}\n$$\n若 $R  1$，则表示与算法 A 相比，算法 B 中的投影步骤减小了全局误差。\n\n实现过程将首先定义一个用于精确解的函数。然后，对于每个测试用例，我们将从 $t=0$ 到 $t=T$ 运行两次仿真，每种算法一次。在每次仿真中，我们将存储计算出的状态序列 $(x_n, z_n)$。仿真结束后，我们将计算所有离散时间点 $t_n$ 处的精确解。最后，我们将使用这些数值解和精确解来计算 RMS 误差 $E_{\\text{no\\_proj}}$ 和 $E_{\\text{proj}}$，以及它们的比值 $R$。对测试套件中的所有参数集重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the DAE problem for the given test cases.\n    It calculates the error ratio R for each test case and prints the results.\n    \"\"\"\n    # Test cases: (a, b, T, h)\n    test_cases = [\n        (1.5, 1.0, 10.0, 0.1),    # Happy path\n        (1.5, 1.0, 10.0, 0.001),  # Small time-step boundary\n        (1.5, 1.0, 10.0, 2.0),    # Large time-step edge case\n    ]\n    x0 = 0.1  # Consistent initial condition for x(0)\n\n    results = []\n    for a, b, T, h in test_cases:\n        params = {'a': a, 'b': b, 'T': T, 'h': h, 'x0': x0}\n        \n        # Simulate without projection (Algorithm A)\n        x_num_A, z_num_A, t_grid = simulate('A', params)\n        \n        # Simulate with projection (Algorithm B)\n        x_num_B, z_num_B, _ = simulate('B', params)\n\n        # Calculate exact solution for the time grid\n        x_exact, z_exact = exact_solution(t_grid, params)\n        \n        # Calculate RMS error for both algorithms\n        E_no_proj = calculate_rms_error(x_num_A, z_num_A, x_exact, z_exact)\n        E_proj = calculate_rms_error(x_num_B, z_num_B, x_exact, z_exact)\n        \n        # Compute the error ratio R\n        # Handle the case where E_proj is zero to avoid division by zero,\n        # though it's highly unlikely in floating point arithmetic for\n        # a non-trivial problem.\n        if E_proj == 0.0:\n            # If projection error is zero, and no-projection error is non-zero,\n            # the ratio is effectively infinite. If both are zero, the ratio is 1.\n            ratio = np.inf if E_no_proj > 0.0 else 1.0\n        else:\n            ratio = E_no_proj / E_proj\n\n        results.append(ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef exact_solution(t, params):\n    \"\"\"\n    Calculates the exact solution for x(t) and z(t) at given time points.\n    \n    Args:\n        t (np.ndarray): Array of time points.\n        params (dict): Dictionary of parameters {a, b, x0}.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the exact solutions \n                                       for x and z at the given time points.\n    \"\"\"\n    a, b, x0 = params['a'], params['b'], params['x0']\n    c = b - a\n    \n    # Check for the special case c=0 which is not in our test suite\n    # to avoid potential division by zero if this function were reused.\n    # For this problem c = -0.5, so this branch is not taken.\n    if c == 0:\n        x_t = x0 - b * (np.cos(t) - 1)\n    else:\n        c_sq = c**2\n        term1_factor = x0 + b / (c_sq + 1.0)\n        term1 = np.exp(c * t) * term1_factor\n        \n        term2_factor = b / (c_sq + 1.0)\n        term2 = term2_factor * (-c * np.sin(t) - np.cos(t))\n        \n        x_t = term1 + term2\n\n    z_t = x_t + np.sin(t)\n    return x_t, z_t\n\ndef simulate(algorithm_type, params):\n    \"\"\"\n    Performs time integration using either Algorithm A or B.\n\n    Args:\n        algorithm_type (str): 'A' for no projection, 'B' for projection.\n        params (dict): Dictionary of parameters {a, b, T, h, x0}.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray, np.ndarray]: Numerical solution arrays for \n                                                    x and z, and the time grid.\n    \"\"\"\n    a, b, T, h, x0 = params['a'], params['b'], params['T'], params['h'], params['x0']\n    \n    # Create the time grid. Use np.ceil to ensure an integer number of steps\n    # and that the grid includes T. The +1 is for the N+1 points.\n    N = int(np.ceil(T / h))\n    t_grid = np.linspace(0, T, N + 1)\n    num_points = len(t_grid)\n    \n    # Recalculate h to match the grid if linspace created a slightly different step\n    if N > 0:\n        h = t_grid[1] - t_grid[0]\n\n    x_num = np.zeros(num_points)\n    z_num = np.zeros(num_points)\n    \n    # Set initial conditions (consistent)\n    x_num[0] = x0\n    z_num[0] = x0  # z(0) = x(0) + sin(0) = x0\n\n    # Denominator in the x update rule\n    denom = 1.0 + h * a\n\n    for n in range(num_points - 1):\n        # Semi-implicit update for x\n        x_num[n+1] = (x_num[n] + h * b * z_num[n]) / denom\n\n        # Update for z depends on the algorithm\n        if algorithm_type == 'A':\n            # Algorithm A: No projection, z is lagged\n            z_num[n+1] = z_num[n]\n        elif algorithm_type == 'B':\n            # Algorithm B: Projection onto constraint manifold\n            z_num[n+1] = x_num[n+1] + np.sin(t_grid[n+1])\n        else:\n            raise ValueError(\"Invalid algorithm_type. Must be 'A' or 'B'.\")\n            \n    return x_num, z_num, t_grid\n\n\ndef calculate_rms_error(x_num, z_num, x_exact, z_exact):\n    \"\"\"\n    Calculates the RMS global error between numerical and exact solutions.\n\n    Args:\n        x_num (np.ndarray): Numerical solution for x.\n        z_num (np.ndarray): Numerical solution for z.\n        x_exact (np.ndarray): Exact solution for x.\n        z_exact (np.ndarray): Exact solution for z.\n\n    Returns:\n        float: The RMS error.\n    \"\"\"\n    squared_error_x = (x_num - x_exact)**2\n    squared_error_z = (z_num - z_exact)**2\n    \n    mean_squared_error = np.mean(squared_error_x + squared_error_z)\n    \n    return np.sqrt(mean_squared_error)\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "现实世界的系统，如电池组，经常会经历突然的变化或开关事件（例如，负载电流的突变）。本练习  解决了一个关键问题：在这样的跳变不连续点之后，如何一致地重新初始化微分代数方程（DAE）求解器。它展示了如何计算代数变量的新值及其时间导数，这对于平稳地重启积分过程至关重要。",
            "id": "3903350",
            "problem": "在自动化电池设计与仿真中，诸如反向微分公式 (BDF) 等隐式积分器要求，当输入发生跳跃不连续时，在切换瞬间对所有变量进行一致性初始化。考虑一个集总电化学界面的半显式微分代数方程 (DAE) 模型，该模型捕捉了施加电流如何分流到一个电荷转移分支和一个电解质传导分支。设微分状态为双电层电压 $x \\equiv V_{\\mathrm{c}}$，代数变量为电解质电势 $z \\equiv \\phi$。右侧输入是施加电流 $I(t)$，它是分段常数，并在时间 $t_0$ 处有一个跳跃。本构方程由 Kirchhoff 电流定律和电容器关系导出，由下式给出\n$$ C \\,\\dot{V}_{\\mathrm{c}} \\;=\\; \\frac{1}{R_{\\mathrm{ct}}}\\,\\big(\\phi - V_{\\mathrm{c}}\\big), $$\n$$ 0 \\;=\\; I(t) \\;-\\; \\frac{1}{R_{\\mathrm{ct}}}\\,\\big(\\phi - V_{\\mathrm{c}}\\big) \\;-\\; \\frac{1}{R_{\\mathrm{e}}}\\,\\big(\\phi - V_{\\mathrm{ref}}\\big), $$\n其中 $C \\gt 0$ 是双电层电容，$R_{\\mathrm{ct}} \\gt 0$ 是电荷转移电阻，$R_{\\mathrm{e}} \\gt 0$ 是电解质电阻，参考电势 $V_{\\mathrm{ref}}$ 取为 $0\\,\\mathrm{V}$。该模型是一个形式为 $M\\,\\dot{x} = f(x,z,t)$ 和 $g(x,z,t)=0$ 的半显式 DAE，其中 $M=C$。当 $I(t)$ 在 $t_0$ 处有跳跃时，在没有脉冲强迫的情况下，状态 $x$ 必须在 $t_0$ 处保持连续，而代数变量 $z$ 可能会跳跃以满足代数约束。为了在跳跃后立即对隐式方法进行一致性初始化，必须计算右极限值 $x(t_0^+)$、$z(t_0^+)$，以及通过对代数约束求导得到的一致右极限导数 $\\dot{x}(t_0^+)$ 和 $\\dot{z}(t_0^+)$。\n\n设计一个算法，在给定 $(C,R_{\\mathrm{ct}},R_{\\mathrm{e}},V_{\\mathrm{c}}(t_0^-),I(t_0^-),I(t_0^+))$ 的情况下，通过强制执行以下条件来计算元组 $\\big(\\phi(t_0^+),\\dot{V}_{\\mathrm{c}}(t_0^+),\\dot{\\phi}(t_0^+)\\big)$：(i) $V_{\\mathrm{c}}$ 在 $t_0$ 处的连续性，(ii) 在 $t_0^+$ 处满足代数约束，以及 (iii) 在假设 $I(t)$ 在跳跃后是右侧恒定（因此 $\\dot{I}(t_0^+)=0$）的情况下，在 $t_0^+$ 处满足对时间微分的代数约束。您的算法不应假设代数变量有闭式公式，并且必须基于使用鲁棒的 Newton 迭代来求解非线性代数方程 $g(x,z,t_0^+)=0$，然后根据微分方程评估 $\\dot{x}(t_0^+)$，并根据线性化的微分约束\n$$ g_x(x,z,t)\\,\\dot{x} \\;+\\; g_z(x,z,t)\\,\\dot{z} \\;+\\; g_t(x,z,t) \\;=\\; 0, $$\n来评估 $\\dot{z}(t_0^+)$，其中 $g_x$ 和 $g_z$ 表示关于 $x$ 和 $z$ 的偏导数，$g_t$ 表示显式时间导数。\n\n所有物理量必须以国际单位制 (SI) 表示：电流单位为安培 $(\\mathrm{A})$，电压单位为伏特 $(\\mathrm{V})$，电阻单位为欧姆 $(\\Omega)$，电容单位为法拉 $(\\mathrm{F})$，时间单位为秒 $(\\mathrm{s})$。下面的数值测试套件指定了参数值、输入的跳跃前值 $I(t_0^-)$ 和跳跃后值 $I(t_0^+)$。对每个测试用例，计算并以 SI 单位的实数形式返回三元组 $\\big(\\phi(t_0^+),\\dot{V}_{\\mathrm{c}}(t_0^+),\\dot{\\phi}(t_0^+)\\big)$。\n\n测试套件：\n- 用例 $1$：$C = 100\\,\\mathrm{F}$, $R_{\\mathrm{ct}} = 10\\,\\Omega$, $R_{\\mathrm{e}} = 1\\,\\Omega$, $V_{\\mathrm{c}}(t_0^-) = 1.0\\,\\mathrm{V}$, $I(t_0^-) = 2.0\\,\\mathrm{A}$, $I(t_0^+) = 5.0\\,\\mathrm{A}$。\n- 用例 $2$：$C = 50\\,\\mathrm{F}$, $R_{\\mathrm{ct}} = 5\\,\\Omega$, $R_{\\mathrm{e}} = 10^9\\,\\Omega$, $V_{\\mathrm{c}}(t_0^-) = 0.1\\,\\mathrm{V}$, $I(t_0^-) = 0.0\\,\\mathrm{A}$, $I(t_0^+) = -3.0\\,\\mathrm{A}$。\n- 用例 $3$：$C = 10\\,\\mathrm{F}$, $R_{\\mathrm{ct}} = 10^{-3}\\,\\Omega$, $R_{\\mathrm{e}} = 0.05\\,\\Omega$, $V_{\\mathrm{c}}(t_0^-) = 0.0\\,\\mathrm{V}$, $I(t_0^-) = 0.0\\,\\mathrm{A}$, $I(t_0^+) = 100.0\\,\\mathrm{A}$。\n- 用例 $4$：$C = 1.0\\,\\mathrm{F}$, $R_{\\mathrm{ct}} = 2.0\\,\\Omega$, $R_{\\mathrm{e}} = 3.0\\,\\Omega$, $V_{\\mathrm{c}}(t_0^-) = 0.5\\,\\mathrm{V}$, $I(t_0^-) = 1.0\\,\\mathrm{A}$, $I(t_0^+) = 1.0\\,\\mathrm{A}$。\n\n您的程序必须实现上述算法并将其应用于四个用例。您的程序应生成单行输出，其中包含结果，格式为一个由四个列表组成的逗号分隔列表，每个内部列表按 $\\big[\\phi(t_0^+),\\dot{V}_{\\mathrm{c}}(t_0^+),\\dot{\\phi}(t_0^+)\\big]$ 的顺序排列，所有数值均采用 SI 单位，并用方括号括起来。例如，所需格式为\n$[\\,[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot]\\,]$,\n其中点代表计算出的浮点数。输出必须是单行，不含任何额外文本。",
            "solution": "该问题要求设计一种算法，用于在输入电流 $I(t)$ 发生跳跃不连续后，立即为一个电化学界面的微分代数方程 (DAE) 模型计算一组一致的初始值。所需的值是跳跃后的代数变量 $\\phi(t_0^+)$，以及状态变量和代数变量的跳跃后时间导数 $\\dot{V}_{\\mathrm{c}}(t_0^+)$ 和 $\\dot{\\phi}(t_0^+)$。\n\nDAE 系统由以下方程给出：\n$$ C \\frac{d V_{\\mathrm{c}}}{dt} = \\frac{1}{R_{\\mathrm{ct}}}\\big(\\phi - V_{\\mathrm{c}}\\big) \\quad \\text{(微分方程)} $$\n$$ 0 = I(t) - \\frac{1}{R_{\\mathrm{ct}}}\\big(\\phi - V_{\\mathrm{c}}\\big) - \\frac{1}{R_{\\mathrm{e}}}\\phi \\quad \\text{(代数约束)} $$\n\n让我们将状态变量表示为 $x(t) \\equiv V_{\\mathrm{c}}(t)$，代数变量表示为 $z(t) \\equiv \\phi(t)$。DAE 是半显式形式 $M\\dot{x} = f(x, z, t)$ 和 $g(x, z, t) = 0$，其中 $M=C$，$f(x, z, t) = (z-x)/R_{\\mathrm{ct}}$，以及 $g(x, z, t) = I(t) - (z-x)/R_{\\mathrm{ct}} - z/R_{\\mathrm{e}}$。为使 DAE 在物理上保持一致，状态变量 $x(t)$ 在输入的任何有限跳跃中都必须是连续的，除非存在脉冲强迫（Dirac δ函数），但此处情况并非如此。相反，代数变量 $z(t)$ 不要求连续，并且通常会跳跃到一个新值，以确保代数约束在 $t_0^+$ 处得到满足。\n\n寻找一致的跳跃后值的算法分四步进行。\n\n**第一步：确定跳跃后的状态变量 $V_{\\mathrm{c}}(t_0^+)$**\n状态变量的连续性原理规定，$V_{\\mathrm{c}}(t)$ 在跳跃后的瞬时值必须等于其跳跃前的瞬时值。\n$$ V_{\\mathrm{c}}(t_0^+) = V_{\\mathrm{c}}(t_0^-) $$\n每个测试用例都提供了 $V_{\\mathrm{c}}(t_0^-)$ 的值。\n\n**第二步：确定跳跃后的代数变量 $\\phi(t_0^+)$**\n代数约束 $g(x, z, t) = 0$ 必须在所有时间 $t$（包括 $t_0^+$ 时刻）都得到满足。因此，我们必须解以下关于 $\\phi(t_0^+)$ 的方程：\n$$ g(V_{\\mathrm{c}}(t_0^+), \\phi(t_0^+), t_0^+) = I(t_0^+) - \\frac{1}{R_{\\mathrm{ct}}}\\big(\\phi(t_0^+) - V_{\\mathrm{c}}(t_0^+)\\big) - \\frac{1}{R_{\\mathrm{e}}}\\phi(t_0^+) = 0 $$\n虽然这是一个关于 $\\phi(t_0^+)$ 的线性方程，可以直接求解，但问题强制要求使用 Newton 法。设 $z_{plus} \\equiv \\phi(t_0^+)$。我们要找到函数 $h(z_{plus}) = I(t_0^+) - \\frac{1}{R_{\\mathrm{ct}}}(z_{plus} - V_{\\mathrm{c}}(t_0^+)) - \\frac{1}{R_{\\mathrm{e}}}z_{plus}$ 的根。Newton-Raphson 迭代由下式给出：\n$$ z_{k+1} = z_k - \\frac{h(z_k)}{h'(z_k)} $$\n导数 $h'(z_{plus})$ 关于 $z_{plus}$ 的导数为：\n$$ h'(z_{plus}) = \\frac{\\partial g}{\\partial \\phi} = -\\frac{1}{R_{\\mathrm{ct}}} - \\frac{1}{R_{\\mathrm{e}}} $$\n由于函数 $h$ 是线性的，Newton 法将从任意初始猜测值开始，在一次迭代中收敛到精确解。一个物理上有意义的初始猜测值是跳跃前的值 $\\phi(t_0^-)$，它可以根据 $t_0^-$ 时的代数约束计算得出。\n\n**第三步：确定跳跃后的状态导数 $\\dot{V}_{\\mathrm{c}}(t_0^+)$**\n在 $V_{\\mathrm{c}}(t_0^+)$ 和 $\\phi(t_0^+)$ 已知的情况下，状态导数 $\\dot{V}_{\\mathrm{c}}(t_0^+) \\equiv dV_{\\mathrm{c}}/dt(t_0^+)$ 通过在 $t_0^+$ 处评估微分方程来计算：\n$$ C \\dot{V}_{\\mathrm{c}}(t_0^+) = \\frac{1}{R_{\\mathrm{ct}}}\\big(\\phi(t_0^+) - V_{\\mathrm{c}}(t_0^+)\\big) $$\n$$ \\implies \\dot{V}_{\\mathrm{c}}(t_0^+) = \\frac{1}{C R_{\\mathrm{ct}}}\\big(\\phi(t_0^+) - V_{\\mathrm{c}}(t_0^+)\\big) $$\n\n**第四步：确定跳跃后的代数导数 $\\dot{\\phi}(t_0^+)$**\n为保持一致性，代数约束的时间导数也必须为零。我们使用链式法则对 $g(V_{\\mathrm{c}}(t), \\phi(t), t) = 0$ 关于时间求导：\n$$ \\frac{d g}{d t} = \\frac{\\partial g}{\\partial V_{\\mathrm{c}}} \\frac{d V_{\\mathrm{c}}}{dt} + \\frac{\\partial g}{\\partial \\phi} \\frac{d \\phi}{dt} + \\frac{\\partial g}{\\partial t} = 0 $$\n让我们计算偏导数：\n$$ \\frac{\\partial g}{\\partial V_{\\mathrm{c}}} = \\frac{\\partial}{\\partial V_{\\mathrm{c}}} \\left( I(t) - \\frac{1}{R_{\\mathrm{ct}}}(\\phi - V_{\\mathrm{c}}) - \\frac{1}{R_{\\mathrm{e}}}\\phi \\right) = \\frac{1}{R_{\\mathrm{ct}}} $$\n$$ \\frac{\\partial g}{\\partial \\phi} = \\frac{\\partial}{\\partial \\phi} \\left( I(t) - \\frac{1}{R_{\\mathrm{ct}}}(\\phi - V_{\\mathrm{c}}) - \\frac{1}{R_{\\mathrm{e}}}\\phi \\right) = -\\frac{1}{R_{\\mathrm{ct}}} - \\frac{1}{R_{\\mathrm{e}}} $$\n$$ \\frac{\\partial g}{\\partial t} = \\frac{\\partial}{\\partial t} \\left( I(t) - \\frac{1}{R_{\\mathrm{ct}}}(\\phi - V_{\\mathrm{c}}) - \\frac{1}{R_{\\mathrm{e}}}\\phi \\right) = \\frac{dI}{dt} $$\n问题指出，输入电流 $I(t)$ 在跳跃后是右侧恒定的，这意味着 $dI/dt(t_0^+) = 0$。在 $t_0^+$ 处评估微分后的约束可得：\n$$ \\frac{1}{R_{\\mathrm{ct}}} \\dot{V}_{\\mathrm{c}}(t_0^+) + \\left(-\\frac{1}{R_{\\mathrm{ct}}} - \\frac{1}{R_{\\mathrm{e}}}\\right) \\dot{\\phi}(t_0^+) + 0 = 0 $$\n求解 $\\dot{\\phi}(t_0^+) \\equiv d\\phi/dt(t_0^+)$ 可得：\n$$ \\dot{\\phi}(t_0^+) = \\frac{1/R_{\\mathrm{ct}}}{1/R_{\\mathrm{ct}} + 1/R_{\\mathrm{e}}} \\dot{V}_{\\mathrm{c}}(t_0^+) $$\n分子和分母同乘以 $R_{\\mathrm{ct}}R_{\\mathrm{e}}$ 可得更简单的形式：\n$$ \\dot{\\phi}(t_0^+) = \\frac{R_{\\mathrm{e}}}{R_{\\mathrm{e}} + R_{\\mathrm{ct}}} \\dot{V}_{\\mathrm{c}}(t_0^+) $$\n这个四步过程提供了所需的元组 $(\\phi(t_0^+), \\dot{V}_{\\mathrm{c}}(t_0^+), \\dot{\\phi}(t_0^+))$，并为每个测试用例实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_consistent_initialization(C, R_ct, R_e, Vc_minus, I_minus, I_plus):\n    \"\"\"\n    Computes consistent DAE initialization at a switching instant t_0.\n\n    Args:\n        C (float): Double-layer capacitance (F).\n        R_ct (float): Charge-transfer resistance (Ohm).\n        R_e (float): Electrolyte resistance (Ohm).\n        Vc_minus (float): Pre-jump double-layer voltage Vc(t_0^-) (V).\n        I_minus (float): Pre-jump applied current I(t_0^-) (A).\n        I_plus (float): Post-jump applied current I(t_0^+) (A).\n\n    Returns:\n        list: A list containing [phi(t_0^+), Vc_dot(t_0^+), phi_dot(t_0^+)].\n    \"\"\"\n    # Step 1: Determine Vc(t_0^+)\n    # State variable is continuous across the jump.\n    Vc_plus = Vc_minus\n\n    # Step 2: Determine phi(t_0^+) using Newton's method\n    # The algebraic constraint g(Vc, phi, I) = 0 must hold at t_0^+.\n    # g = I_plus - (phi_plus - Vc_plus)/R_ct - phi_plus/R_e\n    \n    # Define the function for the root-finding and its derivative\n    inv_R_ct = 1.0 / R_ct\n    inv_R_e = 1.0 / R_e\n    \n    def g(phi):\n        return I_plus - (phi - Vc_plus) * inv_R_ct - phi * inv_R_e\n        \n    def g_prime(phi):\n        return -inv_R_ct - inv_R_e\n\n    # Use a reasonable initial guess for the iteration. The pre-jump value\n    # phi(t_0^-) is a good choice.\n    # phi(t_0^-) = (I_minus + Vc_minus/R_ct) / (1/R_ct + 1/R_e)\n    try:\n        phi_guess = (I_minus + Vc_minus * inv_R_ct) / (inv_R_ct + inv_R_e)\n    except ZeroDivisionError:\n        # Handle case where both resistances are infinite, although problem states > 0\n        phi_guess = 0.0\n\n    phi_k = phi_guess\n    \n    # Since the equation is linear, one iteration is sufficient, but a loop\n    # is a more general implementation of Newton's method. We use a fixed\n    # number of iterations which is more than enough for convergence here.\n    for _ in range(5):\n        g_val = g(phi_k)\n        g_prime_val = g_prime(phi_k)\n        \n        # Avoid division by zero if g_prime_val is zero\n        if abs(g_prime_val)  1e-20:\n            break\n            \n        delta = -g_val / g_prime_val\n        phi_k += delta\n        \n        # Convergence check\n        if abs(delta)  1e-15:\n            break\n\n    phi_plus = phi_k\n\n    # Step 3: Determine Vc_dot(t_0^+)\n    # From the differential equation: Vc_dot = (1/(C*R_ct)) * (phi - Vc)\n    Vc_dot_plus = (1.0 / (C * R_ct)) * (phi_plus - Vc_plus)\n\n    # Step 4: Determine phi_dot(t_0^+)\n    # From the differentiated algebraic constraint:\n    # phi_dot = (R_e / (R_e + R_ct)) * Vc_dot\n    phi_dot_plus = (R_e / (R_e + R_ct)) * Vc_dot_plus\n\n    return [phi_plus, Vc_dot_plus, phi_dot_plus]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (C, R_ct, R_e, Vc(t0-), I(t0-), I(t0+))\n        (100.0, 10.0, 1.0, 1.0, 2.0, 5.0),\n        (50.0, 5.0, 1e9, 0.1, 0.0, -3.0),\n        (10.0, 1e-3, 0.05, 0.0, 0.0, 100.0),\n        (1.0, 2.0, 3.0, 0.5, 1.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        C, R_ct, R_e, Vc_minus, I_minus, I_plus = case\n        result = compute_consistent_initialization(C, R_ct, R_e, Vc_minus, I_minus, I_plus)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() function on a list automatically adds brackets and spaces.\n    # The format requirement is [[...],[...]], so we build the string manually.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}