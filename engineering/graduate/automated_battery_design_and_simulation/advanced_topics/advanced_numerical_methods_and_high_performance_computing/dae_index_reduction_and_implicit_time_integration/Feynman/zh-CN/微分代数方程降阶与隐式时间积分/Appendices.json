{
    "hands_on_practices": [
        {
            "introduction": "在对微分代数方程（DAE）进行数值积分时，一个常见的挑战是数值解会随着时间的推移逐渐偏离代数约束所定义的流形，这种现象被称为“约束漂移”。本练习  通过一个简洁的模型，直观地展示了这一问题，并引入了一种有效的修正技术——投影法。通过在每个时间步后将解投影回约束流形，我们可以显著提高解的全局精度，这是保持DAE解一致性的基础。",
            "id": "3903303",
            "problem": "考虑一个半显式微分代数方程（DAE）模型，该模型捕捉了微分状态和代数约束之间的简化耦合关系，这在用于自动化电池设计和仿真的电化学模型中是典型的。设微分变量为 $x(t)$（无量纲电极状态代理），代数变量为 $z(t)$（无量纲电解质电位代理）。该模型由以下系统组成：\n$$\\frac{dx}{dt} = f(x,z,t) = -a\\,x(t) + b\\,z(t),$$\n以及代数约束\n$$g(x,z,t) = z(t) - \\phi(x,t) = 0,$$\n其中约束流形由下式给出\n$$\\phi(x,t) = x(t) + \\sin(t).$$\n所有量均为无量纲，所有角度必须以弧度为单位。\n\n初始条件与约束流形一致：\n$$x(0) = x_0,\\quad z(0) = x_0 + \\sin(0) = x_0.$$\n\n您必须使用后向欧拉法为微分方程实现一个隐式时间积分方案，并在每个隐式时间步后演示一个投影步骤，通过求解 $g(x,z,t)=0$ 来确定代数变量 $z$，从而将解驱动回约束流形。具体来说，考虑两种算法：\n\n- 算法 A（无投影）：使用滞后的代数变量 $z_n$ 通过后向欧拉法推进 $x$，并保持 $z$ 不变：\n$$x_{n+1} = \\frac{x_n + h\\,b\\,z_n}{1 + h\\,a},\\quad z_{n+1} = z_n.$$\n\n- 算法 B（带投影）：使用滞后的代数变量 $z_n$ 通过后向欧拉法推进 $x$，然后通过求解 $g(x_{n+1},z_{n+1},t_{n+1})=0$ 来确定 $z_{n+1}$，从而投影到约束流形上：\n$$x_{n+1} = \\frac{x_n + h\\,b\\,z_n}{1 + h\\,a},\\quad z_{n+1} = x_{n+1} + \\sin(t_{n+1}).$$\n\n目标是评估投影步骤对全局误差的影响。通过进行 DAE 指数约化（通过约束消去代数变量）来定义精确解：\n$$z(t) = x(t) + \\sin(t),$$\n这得到了约化后的常微分方程\n$$\\frac{dx}{dt} = -a\\,x(t) + b\\,(x(t) + \\sin(t)) = c\\,x(t) + b\\,\\sin(t),\\quad c = -a + b.$$\n在一致的初始条件 $x(0) = x_0$ 下，$x(t)$ 的精确解为\n$$x(t) = e^{c t}\\left(x_0 + \\frac{b}{c^2 + 1}\\right) + \\frac{b}{c^2 + 1}\\left(-c\\,\\sin(t) - \\cos(t)\\right),$$\n精确的代数变量为\n$$z(t) = x(t) + \\sin(t).$$\n\n对于给定的均匀时间步长 $h$ 和最终时间 $T$，计算每个算法在离散时间网格 $\\{t_n\\}_{n=0}^{N}$（其中 $N = T/h$）上的均方根（RMS）全局误差：\n$$E = \\sqrt{\\frac{1}{N+1}\\sum_{n=0}^{N}\\left[(x_n - x(t_n))^2 + (z_n - z(t_n))^2\\right]}.$$\n报告 RMS 误差之比，\n$$R = \\frac{E_{\\text{no\\_proj}}}{E_{\\text{proj}}},$$\n其中 $E_{\\text{no\\_proj}}$ 是算法 A（无投影）的 RMS 误差，$E_{\\text{proj}}$ 是算法 B（带投影）的 RMS 误差。若 $R > 1$，则表示投影减少了全局误差。\n\n所有计算必须使用弧度单位的角度。所有量均为无量纲。\n\n测试套件：\n使用以下参数集来评估该方法。在每种情况下，使用相同的一致初始条件 $x_0 = 0.1$：\n1. 正常路径 (Happy path): $a = 1.5$, $b = 1.0$, $T = 10.0$, $h = 0.1$。\n2. 小时间步边界: $a = 1.5$, $b = 1.0$, $T = 10.0$, $h = 0.001$。\n3. 大时间步边缘情况: $a = 1.5$, $b = 1.0$, $T = 10.0$, $h = 2.0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个条目是上述测试用例之一的浮点误差比 $R$，例如 $[R_1,R_2,R_3]$。每个 $R_i$ 必须作为 Python 浮点数输出。",
            "solution": "该问题要求对一个半显式微分代数方程（DAE）系统的两种数值积分方案进行严格比较，该系统是一个简化模型，类似于电池仿真中使用的模型。主要目标是通过在每个时间步后应用投影步骤来强制执行代数约束，从而量化全局精度的提升。\n\n首先，我们重述控制方程。该系统由状态 $x(t)$ 的一个微分方程和变量 $z(t)$ 的一个代数约束组成：\n$$\n\\frac{dx}{dt} = -a\\,x(t) + b\\,z(t)\n$$\n$$\ng(x,z,t) = z(t) - (x(t) + \\sin(t)) = 0\n$$\n量 $a$ 和 $b$ 是常数参数。初始条件给定为 $x(0) = x_0$ 和 $z(0) = z_0$，它们必须与 $t=0$ 时的代数约束一致。该一致性得到确认：$z(0) = x(0) + \\sin(0) = x_0$。\n\n为了评估数值解，我们需要一个精确的解析解。这可以通过 DAE 指数约化获得。该 DAE 系统是指数为 1 的，意味着对代数约束进行一次微分就足以获得 $z$ 的微分方程。然而，一个更简单的方法是直接将代数约束代入微分方程。根据约束，我们有 $z(t) = x(t) + \\sin(t)$。将其代入 $\\frac{dx}{dt}$ 的方程中可得：\n$$\n\\frac{dx}{dt} = -a\\,x(t) + b\\,(x(t) + \\sin(t)) = (b-a)x(t) + b\\,\\sin(t)\n$$\n令 $c = b-a$，我们得到约化后的常微分方程（ODE）：\n$$\n\\frac{dx}{dt} = c\\,x(t) + b\\,\\sin(t)\n$$\n这是一个标准的一阶线性非齐次常微分方程。对于初始条件 $x(0) = x_0$，其解（已提供并验证）为：\n$$\nx(t) = e^{c t}\\left(x_0 + \\frac{b}{c^2 + 1}\\right) + \\frac{b}{c^2 + 1}\\left(-c\\,\\sin(t) - \\cos(t)\\right)\n$$\n然后可以从约束中轻易地找到代数变量 $z(t)$ 的精确解：\n$$\nz(t) = x(t) + \\sin(t)\n$$\n这些关于 $x(t)$ 和 $z(t)$ 的表达式构成了我们的基准真相（ground truth）。\n\n现在我们来看数值方案。时间域 $[0, T]$ 被离散化为 $N$ 个步长为 $h = T/N$ 的步骤，离散时间点为 $t_n = n \\cdot h$，其中 $n = 0, 1, \\dots, N$。两种算法都对微分部分使用后向欧拉法，通过使用前一时间步的代数变量值 $z_n$ 使其变为半隐式：\n$$\n\\frac{x_{n+1} - x_n}{h} = -a\\,x_{n+1} + b\\,z_n\n$$\n求解 $x_{n+1}$ 可得到两种算法共有的更新规则：\n$$\nx_{n+1} = \\frac{x_n + h\\,b\\,z_n}{1 + h\\,a}\n$$\n\n这两种算法在如何更新 $z_{n+1}$ 上有所不同：\n\n**算法 A（无投影）：** 这是最朴素的方法。代数变量在时间步内被视为一个常数参数，并且不进行更新以满足约束。这种方法计算成本低，但预计精度不高。\n$$\nx_{n+1} = \\frac{x_n + h\\,b\\,z_n}{1 + h\\,a}\n$$\n$$\nz_{n+1} = z_n\n$$\n数值解 $(x_n, z_n)$ 通常会偏离由 $g(x,z,t)=0$ 定义的约束流形。\n\n**算法 B（带投影）：** 该算法引入了一个修正（或投影）步骤。在计算出微分状态的新值 $x_{n+1}$ 后，显式地计算代数状态 $z_{n+1}$ 以满足在新时间 $t_{n+1}$ 时的约束。\n$$\nx_{n+1} = \\frac{x_n + h\\,b\\,z_n}{1 + h\\,a} \\quad (\\text{积分步骤})\n$$\n$$\nz_{n+1} = x_{n+1} + \\sin(t_{n+1}) \\quad (\\text{投影步骤})\n$$\n这种方法是一种坐标投影，它确保了数值解 $(x_{n+1}, z_{n+1})$ 在每个时间步 $t_{n+1}$ 都位于约束流形上。这有望防止漂移误差的累积，并产生更准确的全局解。\n\n为了比较这些算法，我们为每种算法计算均方根（RMS）全局误差。误差 $E$ 定义为在所有时间点（包括 $t_0$）上，数值解 $(x_n, z_n)$ 与精确解 $(x(t_n), z(t_n))$ 之间均方欧几里得距离的平方根：\n$$\nE = \\sqrt{\\frac{1}{N+1}\\sum_{n=0}^{N}\\left[(x_n - x(t_n))^2 + (z_n - z(t_n))^2\\right]}\n$$\n我们为算法 A ($E_{\\text{no\\_proj}}$) 和算法 B ($E_{\\text{proj}}$) 计算此误差。用于比较的最终度量是这些误差的比率：\n$$\nR = \\frac{E_{\\text{no\\_proj}}}{E_{\\text{proj}}}\n$$\n若 $R > 1$，则表示与算法 A 相比，算法 B 中的投影步骤减少了全局误差。\n\n实现过程将首先为精确解定义一个函数。然后，对于每个测试用例，我们将从 $t=0$ 到 $t=T$ 运行两个仿真，每个算法一个。在每次仿真中，我们将存储计算出的状态序列 $(x_n, z_n)$。仿真结束后，我们将在所有离散时间点 $t_n$ 计算精确解。最后，我们将使用这些数值解和精确解来计算 RMS 误差 $E_{\\text{no\\_proj}}$ 和 $E_{\\text{proj}}$，以及它们的比值 $R$。对于测试套件中的所有参数集，将重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the DAE problem for the given test cases.\n    It calculates the error ratio R for each test case and prints the results.\n    \"\"\"\n    # Test cases: (a, b, T, h)\n    test_cases = [\n        (1.5, 1.0, 10.0, 0.1),    # Happy path\n        (1.5, 1.0, 10.0, 0.001),  # Small time-step boundary\n        (1.5, 1.0, 10.0, 2.0),    # Large time-step edge case\n    ]\n    x0 = 0.1  # Consistent initial condition for x(0)\n\n    results = []\n    for a, b, T, h in test_cases:\n        params = {'a': a, 'b': b, 'T': T, 'h': h, 'x0': x0}\n        \n        # Simulate without projection (Algorithm A)\n        x_num_A, z_num_A, t_grid = simulate('A', params)\n        \n        # Simulate with projection (Algorithm B)\n        x_num_B, z_num_B, _ = simulate('B', params)\n\n        # Calculate exact solution for the time grid\n        x_exact, z_exact = exact_solution(t_grid, params)\n        \n        # Calculate RMS error for both algorithms\n        E_no_proj = calculate_rms_error(x_num_A, z_num_A, x_exact, z_exact)\n        E_proj = calculate_rms_error(x_num_B, z_num_B, x_exact, z_exact)\n        \n        # Compute the error ratio R\n        # Handle the case where E_proj is zero to avoid division by zero,\n        # though it's highly unlikely in floating point arithmetic for\n        # a non-trivial problem.\n        if E_proj == 0.0:\n            # If projection error is zero, and no-projection error is non-zero,\n            # the ratio is effectively infinite. If both are zero, the ratio is 1.\n            ratio = np.inf if E_no_proj > 0.0 else 1.0\n        else:\n            ratio = E_no_proj / E_proj\n\n        results.append(ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef exact_solution(t, params):\n    \"\"\"\n    Calculates the exact solution for x(t) and z(t) at given time points.\n    \n    Args:\n        t (np.ndarray): Array of time points.\n        params (dict): Dictionary of parameters {a, b, x0}.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the exact solutions \n                                       for x and z at the given time points.\n    \"\"\"\n    a, b, x0 = params['a'], params['b'], params['x0']\n    c = b - a\n    \n    # Check for the special case c=0 which is not in our test suite\n    # to avoid potential division by zero if this function were reused.\n    # For this problem c = -0.5, so this branch is not taken.\n    if c == 0:\n        x_t = x0 - b * (np.cos(t) - 1)\n    else:\n        c_sq = c**2\n        term1_factor = x0 + b / (c_sq + 1.0)\n        term1 = np.exp(c * t) * term1_factor\n        \n        term2_factor = b / (c_sq + 1.0)\n        term2 = term2_factor * (-c * np.sin(t) - np.cos(t))\n        \n        x_t = term1 + term2\n\n    z_t = x_t + np.sin(t)\n    return x_t, z_t\n\ndef simulate(algorithm_type, params):\n    \"\"\"\n    Performs time integration using either Algorithm A or B.\n\n    Args:\n        algorithm_type (str): 'A' for no projection, 'B' for projection.\n        params (dict): Dictionary of parameters {a, b, T, h, x0}.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray, np.ndarray]: Numerical solution arrays for \n                                                    x and z, and the time grid.\n    \"\"\"\n    a, b, T, h, x0 = params['a'], params['b'], params['T'], params['h'], params['x0']\n    \n    # Create the time grid. Use np.ceil to ensure an integer number of steps\n    # and that the grid includes T. The +1 is for the N+1 points.\n    N = int(np.ceil(T / h))\n    t_grid = np.linspace(0, T, N + 1)\n    num_points = len(t_grid)\n    \n    # Recalculate h to match the grid if linspace created a slightly different step\n    if N > 0:\n        h = t_grid[1] - t_grid[0]\n\n    x_num = np.zeros(num_points)\n    z_num = np.zeros(num_points)\n    \n    # Set initial conditions (consistent)\n    x_num[0] = x0\n    z_num[0] = x0  # z(0) = x(0) + sin(0) = x0\n\n    # Denominator in the x update rule\n    denom = 1.0 + h * a\n\n    for n in range(num_points - 1):\n        # Semi-implicit update for x\n        x_num[n+1] = (x_num[n] + h * b * z_num[n]) / denom\n\n        # Update for z depends on the algorithm\n        if algorithm_type == 'A':\n            # Algorithm A: No projection, z is lagged\n            z_num[n+1] = z_num[n]\n        elif algorithm_type == 'B':\n            # Algorithm B: Projection onto constraint manifold\n            z_num[n+1] = x_num[n+1] + np.sin(t_grid[n+1])\n        else:\n            raise ValueError(\"Invalid algorithm_type. Must be 'A' or 'B'.\")\n            \n    return x_num, z_num, t_grid\n\n\ndef calculate_rms_error(x_num, z_num, x_exact, z_exact):\n    \"\"\"\n    Calculates the RMS global error between numerical and exact solutions.\n\n    Args:\n        x_num (np.ndarray): Numerical solution for x.\n        z_num (np.ndarray): Numerical solution for z.\n        x_exact (np.ndarray): Exact solution for x.\n        z_exact (np.ndarray): Exact solution for z.\n\n    Returns:\n        float: The RMS error.\n    \"\"\"\n    squared_error_x = (x_num - x_exact)**2\n    squared_error_z = (z_num - z_exact)**2\n    \n    mean_squared_error = np.mean(squared_error_x + squared_error_z)\n    \n    return np.sqrt(mean_squared_error)\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "虽然投影法是有效的，但更稳健和一体化的方法是采用全隐式积分，同时求解系统的微分和代数部分。本练习  探讨了如何将隐式欧拉法应用于一个采用改进节点分析（MNA）建立的电池组模型。您将发现，这种方法会在每个时间步产生一个具有特殊“鞍点”结构的非线性方程组，我们将学习如何通过牛顿法以及舒尔补等高效的数值技巧来求解这类系统，这是进行大规模电路和电池组仿真的核心技能。",
            "id": "3903309",
            "problem": "您正在为使用改进节点分析（Modified Nodal Analysis, MNA）构建的电池组模型设计一个隐式时间积分器。您的任务是为一个双节点电池组微分代数方程（Differential-Algebraic Equation, DAE）的单个隐式欧拉步推导并实现牛顿系统，并利用由此产生的稀疏、对称不定鞍点结构，构建一个基于块消元的有效线性求解器。\n\n基本原理：\n- 基尔霍夫电流定律（Kirchhoff’s Current Law, KCL）：流入节点的电流代数和为零。\n- 电容器本构定律：$i_C = C \\, \\dfrac{dv}{dt}$。\n- 电阻器本构定律：$i_R = \\dfrac{v}{R}$。\n- 由双曲正弦函数建模的非线性法拉第界面电流：$i_F(v) = i_0 \\, \\sinh\\!\\big(\\beta \\, (v - E)\\big)$。\n\n模型设置：\n- 有两个动态节点，其电压 $v_1$ 和 $v_2$ 相对地线测量，构成向量 $v = \\begin{bmatrix} v_1 \\\\ v_2 \\end{bmatrix}$。\n- 每个节点上都有一个到地线的电容器，电容分别为 $C_1$ 和 $C_2$，构成对角矩阵 $C = \\mathrm{diag}(C_1,C_2)$。\n- 节点1和节点2分别有到地线的内部电阻，阻值分别为 $R_1$ 和 $R_2$。\n- 节点1和节点2之间有一个互连电阻，阻值为 $R_{12}$。\n- 每个节点上的非线性法拉第电流：$i_{F,1}(v_1) = i_{0,1} \\, \\sinh\\!\\big(\\beta \\, (v_1 - E_1)\\big)$ 和 $i_{F,2}(v_2) = i_{0,2} \\, \\sinh\\!\\big(\\beta \\, (v_2 - E_2)\\big)$。\n- 一个理想电压源将节点2约束到指定值 $V_{\\mathrm{src}}(t)$；这引入了一个代数约束 $A \\, v = g(t)$，其中 $A = \\begin{bmatrix} 0 & 1 \\end{bmatrix}$ 且 $g(t) = V_{\\mathrm{src}}(t)$，以及一个表示源电流的相应拉格朗日乘子 $\\lambda$。\n\n使用MNA，该半显式DAE可写为以下形式\n$$\nC \\, \\dfrac{dv}{dt} + G \\, v + i_F(v) + A^\\top \\lambda = s(t), \\quad A \\, v = g(t),\n$$\n其中 $G \\in \\mathbb{R}^{2 \\times 2}$ 是由电阻器组合成的对称电导矩阵：\n$$\nG = \\begin{bmatrix}\n\\dfrac{1}{R_1} + \\dfrac{1}{R_{12}} & -\\dfrac{1}{R_{12}} \\\\\n-\\dfrac{1}{R_{12}} & \\dfrac{1}{R_2} + \\dfrac{1}{R_{12}}\n\\end{bmatrix},\n$$\n且 $s(t) \\in \\mathbb{R}^2$ 是一个已知源向量（在本问题中假设 $s(t) = 0$）。$i_F(v)$ 的雅可比矩阵是对角的：\n$$\nJ_F(v) = \\mathrm{diag}\\!\\Big(i_{0,1} \\beta \\cosh\\!\\big(\\beta (v_1 - E_1)\\big), \\; i_{0,2} \\beta \\cosh\\!\\big(\\beta (v_2 - E_2)\\big)\\Big).\n$$\n\n隐式欧拉步：\n对于从时间 $t_n$ 到 $t_{n+1}$ 的大小为 $\\Delta t$ 的时间步，用 $v_n$ 表示已知的先前状态，用 $v_{n+1}$ 表示未知的下一个状态。使用隐式欧拉法对DAE进行离散化，以获得关于 $v_{n+1}$ 和 $\\lambda_{n+1}$ 的两个非线性方程。\n\n您的任务：\n1. 从上述基本定律和定义出发，推导隐式欧拉步的残差方程，并建立牛顿线性化。证明在迭代点 $(v^{(k)}, \\lambda^{(k)})$ 处的牛顿系统具有鞍点形式\n$$\n\\begin{bmatrix}\nM(v^{(k)}) & A^\\top \\\\\nA & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\delta v^{(k)} \\\\\n\\delta \\lambda^{(k)}\n\\end{bmatrix}\n=\n-\n\\begin{bmatrix}\nr_v(v^{(k)}, \\lambda^{(k)}) \\\\\nr_c(v^{(k)})\n\\end{bmatrix},\n$$\n并用 $C$, $G$, $J_F(v^{(k)})$, $v_n$, $s(t_{n+1})$ 和 $g(t_{n+1})$ 显式地确定 $M(v^{(k)})$、$r_v(\\cdot)$ 和 $r_c(\\cdot)$。\n2. 提出一个利用牛顿矩阵的稀疏、对称不定结构的有效求解器。具体来说，假设 $M(v^{(k)})$ 是对称正定的，使用块消元法形成关于 $\\lambda$ 的舒尔补（Schur complement），并使用稀疏线性代数求解。清晰地陈述获得 $(\\delta v^{(k)}, \\delta \\lambda^{(k)})$ 所需的线性求解序列。\n3. 实现一个程序，对下面的每个测试用例，从初始猜测 $v^{(0)} = v_n$ 和 $\\lambda^{(0)} = 0$ 开始，为单个隐式欧拉时间步执行牛顿迭代，当电压更新的欧几里得范数满足 $\\|\\delta v^{(k)}\\|_2 < \\varepsilon$（容差 $\\varepsilon = 10^{-12}$）或达到最大50次迭代时停止。使用任务2中描述的块消元求解器，并在舒尔补变得病态（ill-conditioned）时，回退到对完整鞍点系统进行直接稀疏求解。对于每个测试用例，输出收敛后的电压增量的最终欧几里得范数 $\\|v_{n+1} - v_n\\|_2$。以伏特（V）为单位，用十进制数表示输出值。\n\n测试套件：\n- 案例1（理想情况）：$C_1 = 500 \\text{ F}$，$C_2 = 500 \\text{ F}$，$R_1 = 0.01 \\, \\Omega$，$R_2 = 0.01 \\, \\Omega$，$R_{12} = 0.02 \\, \\Omega$，$i_{0,1} = 2 \\text{ A}$，$i_{0,2} = 2 \\text{ A}$，$\\beta = 10 \\text{ V}^{-1}$，$E_1 = 3.7 \\text{ V}$，$E_2 = 3.7 \\text{ V}$，$V_{\\mathrm{src}}(t_{n+1}) = 3.8 \\text{ V}$，$\\Delta t = 1 \\times 10^{-3} \\text{ s}$，$v_n = \\begin{bmatrix} 3.7 \\\\ 3.8 \\end{bmatrix} \\text{ V}$。\n- 案例2（刚性小步长边缘情况）：$C_1 = 200 \\text{ F}$，$C_2 = 200 \\text{ F}$，$R_1 = 0.005 \\, \\Omega$，$R_2 = 0.005 \\, \\Omega$，$R_{12} = 0.001 \\, \\Omega$，$i_{0,1} = 5 \\text{ A}$，$i_{0,2} = 5 \\text{ A}$，$\\beta = 20 \\text{ V}^{-1}$，$E_1 = 3.75 \\text{ V}$，$E_2 = 3.75 \\text{ V}$，$V_{\\mathrm{src}}(t_{n+1}) = 3.9 \\text{ V}$，$\\Delta t = 1 \\times 10^{-6} \\text{ s}$，$v_n = \\begin{bmatrix} 3.75 \\\\ 3.9 \\end{bmatrix} \\text{ V}$。\n- 案例3（弱耦合边界情况）：$C_1 = 100 \\text{ F}$，$C_2 = 100 \\text{ F}$，$R_1 = 0.02 \\, \\Omega$，$R_2 = 0.02 \\, \\Omega$，$R_{12} = 1000 \\, \\Omega$，$i_{0,1} = 0.5 \\text{ A}$，$i_{0,2} = 0.5 \\text{ A}$，$\\beta = 5 \\text{ V}^{-1}$，$E_1 = 3.6 \\text{ V}$，$E_2 = 3.6 \\text{ V}$，$V_{\\mathrm{src}}(t_{n+1}) = 3.6 \\text{ V}$，$\\Delta t = 1 \\times 10^{-1} \\text{ s}$，$v_n = \\begin{bmatrix} 3.6 \\\\ 3.6 \\end{bmatrix} \\text{ V}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，形式为逗号分隔的列表，并用方括号括起来，例如 $\\big[ r_1, r_2, r_3 \\big]$，其中 $r_k$ 是案例 $k$ 的最终欧几里得范数 $\\|v_{n+1} - v_n\\|_2$，单位为伏特（V）。",
            "solution": "### 任务1：牛顿系统的推导\n\n该系统由一组微分代数方程（DAE）在改进节点分析（MNA）框架下描述。设 $v(t) \\in \\mathbb{R}^2$ 为节点电压向量，$\\lambda(t) \\in \\mathbb{R}$ 为电压源约束的拉格朗日乘子。\n\n控制DAE方程组为：\n$$\n\\begin{align*}\nC \\, \\frac{dv}{dt} + G \\, v + i_F(v) + A^\\top \\lambda = s(t) \\quad (1a) \\\\\nA \\, v = g(t) \\quad (1b)\n\\end{align*}\n$$\n其中 C 是电容矩阵，G 是电导矩阵，$i_F(v)$ 是非线性法拉第电流向量，A 是约束矩阵，$\\lambda$ 是通过电压源的电流，$s(t)$ 是外部电流源向量（给定为 $s(t)=0$），$g(t)$ 是来自电源的指定电压。\n\n我们使用隐式欧拉法对时间导数 $\\frac{dv}{dt}$ 进行离散化，对于一个从 $t_n$ 到 $t_{n+1}$，步长为 $\\Delta t = t_{n+1} - t_n$ 的时间步：\n$$\n\\frac{dv}{dt}\\bigg|_{t_{n+1}} \\approx \\frac{v_{n+1} - v_n}{\\Delta t}\n$$\n这里，$v_n = v(t_n)$ 是前一时间步的已知电压向量，$v_{n+1} = v(t_{n+1})$ 是当前时间步的未知电压向量。将此代入DAE系统（1a）并在 $t_{n+1}$ 处计算所有项，得到关于未知数 $v_{n+1}$ 和 $\\lambda_{n+1}$ 的非线性代数系统：\n$$\n\\begin{align*}\nC \\frac{v_{n+1} - v_n}{\\Delta t} + G v_{n+1} + i_F(v_{n+1}) + A^\\top \\lambda_{n+1} - s(t_{n+1}) = 0 \\\\\nA v_{n+1} - g(t_{n+1}) = 0\n\\end{align*}\n$$\n为求解此非线性系统，我们使用牛顿法。设 $(v^{(k)}, \\lambda^{(k)})$ 是解 $(v_{n+1}, \\lambda_{n+1})$ 的第 $k$ 次迭代。我们定义残差函数：\n$$\n\\begin{align*}\nr_v(v, \\lambda) = \\frac{C(v - v_n)}{\\Delta t} + Gv + i_F(v) + A^\\top \\lambda - s(t_{n+1}) \\\\\nr_c(v) = Av - g(t_{n+1})\n\\end{align*}\n$$\n牛顿更新步通过求解线性系统 $J^{(k)} \\begin{bmatrix} \\delta v^{(k)} \\\\ \\delta \\lambda^{(k)} \\end{bmatrix} = - \\begin{bmatrix} r_v(v^{(k)}, \\lambda^{(k)}) \\\\ r_c(v^{(k)}) \\end{bmatrix}$ 来定义，其中 $J^{(k)}$ 是在 $(v^{(k)}, \\lambda^{(k)})$ 处求值的残差向量 $\\begin{bmatrix} r_v \\\\ r_c \\end{bmatrix}$ 的雅可比矩阵，而 $(\\delta v^{(k)}, \\delta \\lambda^{(k)})$ 是更新量，使得 $v^{(k+1)} = v^{(k)} + \\delta v^{(k)}$ 且 $\\lambda^{(k+1)} = \\lambda^{(k)} + \\delta \\lambda^{(k)}$。\n\n雅可比矩阵 $J$ 由偏导数组成：\n$$\nJ(v, \\lambda) = \\begin{bmatrix} \\frac{\\partial r_v}{\\partial v} & \\frac{\\partial r_v}{\\partial \\lambda} \\\\ \\frac{\\partial r_c}{\\partial v} & \\frac{\\partial r_c}{\\partial \\lambda} \\end{bmatrix}\n$$\n各个块为：\n- $\\frac{\\partial r_v}{\\partial v} = \\frac{C}{\\Delta t} + G + \\frac{\\partial i_F(v)}{\\partial v} = \\frac{C}{\\Delta t} + G + J_F(v)$，其中 $J_F(v)$ 是法拉第电流的雅可比矩阵。\n- $\\frac{\\partial r_v}{\\partial \\lambda} = A^\\top$\n- $\\frac{\\partial r_c}{\\partial v} = A$\n- $\\frac{\\partial r_c}{\\partial \\lambda} = 0$ (一个零矩阵，在此情况下为标量 $0$)\n\n因此，第 $k$ 次迭代的牛顿系统为：\n$$\n\\begin{bmatrix}\n\\frac{C}{\\Delta t} + G + J_F(v^{(k)}) & A^\\top \\\\\nA & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\delta v^{(k)} \\\\\n\\delta \\lambda^{(k)}\n\\end{bmatrix}\n=\n-\n\\begin{bmatrix}\nr_v(v^{(k)}, \\lambda^{(k)}) \\\\\nr_c(v^{(k)})\n\\end{bmatrix}\n$$\n这就是所要求的鞍点形式。通过与问题陈述的模板进行比较，我们确定：\n- $M(v^{(k)}) = \\frac{C}{\\Delta t} + G + J_F(v^{(k)})$\n- $r_v(v^{(k)}, \\lambda^{(k)}) = \\frac{C}{\\Delta t}(v^{(k)} - v_n) + Gv^{(k)} + i_F(v^{(k)}) + A^\\top \\lambda^{(k)} - s(t_{n+1})$\n- $r_c(v^{(k)}) = Av^{(k)} - g(t_{n+1})$\n\n矩阵 $M(v^{(k)})$ 是对称的，因为 $C$、$G$ 和 $J_F(v^{(k)})$ 都是对称的。它也是正定的，因为 $C$ 和 $J_F$ 是对角线元素为正的对角矩阵，$G$ 是半正定的，且 $\\Delta t > 0$。因此，它们的和是对称正定（Symmetric Positive Definite, SPD）的。\n\n### 任务2：块消元求解器\n\n牛顿系统具有 $2 \\times 2$ 的块结构，通常称为 Karush-Kuhn-Tucker（KKT）系统或鞍点系统。\n$$\n\\begin{align*}\nM \\delta v + A^\\top \\delta \\lambda = -r_v \\quad (2a) \\\\\nA \\delta v = -r_c \\quad (2b)\n\\end{align*}\n$$\n鉴于 $M = M(v^{(k)})$ 是对称正定（SPD）因而可逆，我们可以从（2a）中求解 $\\delta v$：\n$$\n\\delta v = M^{-1}(-r_v - A^\\top \\delta \\lambda) \\quad (3)\n$$\n将此代入（2b）：\n$$\nA \\big( M^{-1}(-r_v - A^\\top \\delta \\lambda) \\big) = -r_c\n$$\n$$\n-A M^{-1} r_v - (A M^{-1} A^\\top) \\delta \\lambda = -r_c\n$$\n重新整理以求解标量更新 $\\delta \\lambda$：\n$$\n(A M^{-1} A^\\top) \\delta \\lambda = r_c - A M^{-1} r_v\n$$\n项 $S = A M^{-1} A^\\top$ 是系统关于块 $M$ 的舒尔补。由于 $M$ 是对称正定（SPD）且 $A$ 具有满行秩（在本例中 $A = \\begin{bmatrix} 0 & 1 \\end{bmatrix} \\neq 0$），舒尔补 $S$ 也是对称正定（SPD）的。由于它是一个 $1 \\times 1$ 矩阵（一个标量），这意味着 $S > 0$。\n\n高效的求解过程如下，它避免了在一般稀疏情况下显式地形成一个大的逆矩阵：\n1.  形成矩阵 $M(v^{(k)})$。\n2.  求解线性系统 $M z_v = r_v$ 以获得向量 $z_v$。\n3.  求解线性系统 $M z_A = A^\\top$ 以获得向量 $z_A$。\n4.  计算舒尔补：$S = A z_A$。\n5.  求解拉格朗日乘子更新：$\\delta \\lambda = S^{-1} (r_c - A z_v)$。对于一个标量 $S$，这是一个简单的除法 $\\delta \\lambda = (r_c - A z_v) / S$。\n6.  反向代入以求得电压更新：$\\delta v = -z_v - z_A \\delta \\lambda$。\n\n此方法需要对矩阵 $M$ 进行两次线性求解（该矩阵可以分解一次）以及标量/向量运算，这使其对于大规模系统非常高效，因为在这些系统中，对完整的不定系统进行直接求解可能不够稳定或成本更高。对于给定的 $2 \\times 2$ 问题，用 $M$ 求解是微不足道的，但这个过程展示了一般原理。\n\n### 任务3：实现\n\n提供的Python代码使用上面推导的块消元（舒尔补）求解器实现了牛顿法。它进行迭代，直到电压更新的L2范数 $\\|\\delta v^{(k)}\\|_2$ 低于容差 $\\varepsilon = 10^{-12}$。代码中包含了一个回退机制，即在舒尔补 $S$ 接近于零（病态）的情况下，直接对完整的 $3 \\times 3$ KKT系统进行稀疏求解，尽管考虑到问题的结构，这种情况不太可能发生。对于每个测试用例，程序计算并报告该时间步的总电压变化的L2范数 $\\|v_{n+1} - v_n\\|_2$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"C1\": 500.0, \"C2\": 500.0, \"R1\": 0.01, \"R2\": 0.01, \"R12\": 0.02,\n            \"i01\": 2.0, \"i02\": 2.0, \"beta\": 10.0, \"E1\": 3.7, \"E2\": 3.7,\n            \"V_src\": 3.8, \"dt\": 1e-3, \"v_n\": np.array([3.7, 3.8]),\n        },\n        {\n            \"C1\": 200.0, \"C2\": 200.0, \"R1\": 0.005, \"R2\": 0.005, \"R12\": 0.001,\n            \"i01\": 5.0, \"i02\": 5.0, \"beta\": 20.0, \"E1\": 3.75, \"E2\": 3.75,\n            \"V_src\": 3.9, \"dt\": 1e-6, \"v_n\": np.array([3.75, 3.9]),\n        },\n        {\n            \"C1\": 100.0, \"C2\": 100.0, \"R1\": 0.02, \"R2\": 0.02, \"R12\": 1000.0,\n            \"i01\": 0.5, \"i02\": 0.5, \"beta\": 5.0, \"E1\": 3.6, \"E2\": 3.6,\n            \"V_src\": 3.6, \"dt\": 0.1, \"v_n\": np.array([3.6, 3.6]),\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_newton_step(params)\n        results.append(f\"{result:.15f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_newton_step(params):\n    \"\"\"\n    Performs Newton iterations for a single implicit Euler time step.\n    \n    Args:\n        params (dict): A dictionary containing all the parameters for the simulation.\n\n    Returns:\n        float: The Euclidean norm of the converged voltage increment ||v_{n+1} - v_n||_2.\n    \"\"\"\n    # Unpack parameters\n    C1, C2 = params[\"C1\"], params[\"C2\"]\n    R1, R2, R12 = params[\"R1\"], params[\"R2\"], params[\"R12\"]\n    i01, i02, beta = params[\"i01\"], params[\"i02\"], params[\"beta\"]\n    E1, E2 = params[\"E1\"], params[\"E2\"]\n    V_src, dt, v_n = params[\"V_src\"], params[\"dt\"], params[\"v_n\"]\n    \n    # Constants and constant matrices\n    C = np.diag([C1, C2])\n    G = np.array([\n        [1/R1 + 1/R12, -1/R12],\n        [-1/R12, 1/R2 + 1/R12]\n    ])\n    A = np.array([[0.0, 1.0]])\n    A_T = A.T\n    g = V_src\n    s = np.zeros(2) # s(t) = 0\n    \n    # Newton iteration settings\n    v_k = np.copy(v_n)\n    lambda_k = 0.0\n    max_iter = 50\n    tolerance = 1e-12\n\n    for _ in range(max_iter):\n        v1k, v2k = v_k\n        \n        # Evaluate nonlinear currents and their Jacobian\n        arg1 = beta * (v1k - E1)\n        arg2 = beta * (v2k - E2)\n        \n        # Check for potential overflow in sinh/cosh\n        if np.abs(arg1) > 100 or np.abs(arg2) > 100:\n             # If arguments get too big, Newton is likely diverging.\n             # Terminate and let the max_iter condition handle it.\n             break\n\n        iF = np.array([i01 * np.sinh(arg1), i02 * np.sinh(arg2)])\n        \n        JF_diag = np.array([\n            i01 * beta * np.cosh(arg1),\n            i02 * beta * np.cosh(arg2)\n        ])\n        JF = np.diag(JF_diag)\n        \n        # Calculate residuals\n        r_v = (C @ (v_k - v_n)) / dt + G @ v_k + iF + A_T.flatten() * lambda_k - s\n        r_c = (A @ v_k)[0] - g\n        \n        # Form the (1,1) block of the Newton matrix\n        M = C / dt + G + JF\n        \n        # --- Solve the KKT system ---\n        # Schur Complement: S = A * M^-1 * A^T\n        # For A = [0, 1], S is the (2,2) element of M^-1\n        det_M = M[0, 0] * M[1, 1] - M[0, 1] * M[1, 0]\n        \n        # Use Schur complement by default\n        # The condition for fallback is if Schur complement is ill-conditioned (near zero)\n        if abs(det_M)  1e-20 or abs(M[0, 0]/det_M)  1e-14:\n            # Fallback to direct sparse solve of the full KKT system\n            KKT_mat = np.zeros((3, 3))\n            KKT_mat[0:2, 0:2] = M\n            KKT_mat[0:2, 2] = A_T.flatten()\n            KKT_mat[2, 0:2] = A.flatten()\n            KKT_sparse = csr_matrix(KKT_mat)\n            \n            rhs = -np.concatenate([r_v, [r_c]])\n            \n            delta_x = spsolve(KKT_sparse, rhs)\n            delta_v = delta_x[:2]\n            delta_lambda = delta_x[2]\n        else:\n            # Block elimination via Schur complement\n            M_inv = (1.0 / det_M) * np.array([[M[1, 1], -M[0, 1]], [-M[1, 0], M[0, 0]]])\n            S = M_inv[1, 1] # A M^-1 A.T\n\n            # Solve for delta_lambda\n            # delta_lambda = S^-1 * (r_c - A * M^-1 * r_v)\n            z_v = M_inv @ r_v\n            A_z_v = z_v[1] # A @ z_v\n            delta_lambda = (r_c - A_z_v) / S\n            \n            # Solve for delta_v\n            # delta_v = -M^-1 * r_v - M^-1 * A^T * delta_lambda\n            z_A = M_inv @ A_T\n            delta_v = -z_v - z_A.flatten() * delta_lambda\n\n        # Update solution\n        v_k += delta_v\n        lambda_k += delta_lambda\n        \n        # Check for convergence\n        if np.linalg.norm(delta_v)  tolerance:\n            break\n            \n    v_np1 = v_k\n    return np.linalg.norm(v_np1 - v_n)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在开始任何时间积分之前，我们必须确保所有变量在初始时刻 $t=0$ 都满足代数约束，这个过程被称为“一致性初始化”。本练习  深入探讨了一个真实且复杂的场景：为锂离子电池的Doyle-Fuller-Newman (DFN) 模型寻找一致的初始电势。您需要将巴特勒-福尔默动力学等基本电化学原理转化为一个非线性代数方程组，并使用数值方法求解，这是启动任何高保真度电池模拟的关键第一步。",
            "id": "3903333",
            "problem": "考虑一个在空间上进行半离散化的锂离子电池的Doyle–Fuller–Newman (DFN) 模型，其中固相和电解质相的电势是代数变量，而浓度是微分变量。在隐式时间积分（例如，后向欧拉法）的开始阶段，一致的初始条件必须在时间 $t = 0$ 时满足代数约束，以对应指定的施加电流和荷电状态。假设一个双电极电池，包含一个负极 (n) 和一个正极 (p)，并假定负极处的电解质电势被选为规范参考 $0$（通过规范固定进行指数约简）。以下经过充分检验的科学关系被作为基本依据：\n\n- 每个电极界面处的电荷守恒将反应电流密度与按界面面积缩放的外加电流等同起来。\n- 具有对称传递系数的 Butler–Volmer 动力学将反应电流密度与活化过电势联系起来。\n- 电解质中的欧姆关系将电极间的电解质电势降近似为与外加电流成正比。\n\n令 $i_{\\mathrm{app}}$ 表示无量纲外加电流（由特征电流和面积归一化），$a_n$ 和 $a_p$ 分别表示负极和正极的无量纲界面面积比例因子，$k_n$ 和 $k_p$ 表示无量纲动力学前置因子，$r_e$ 表示无量纲电解质电阻，并令开路电势 $U_n$ 和 $U_p$ 由能斯特型关系给出\n$$\nU_{\\ell}(c_{\\ell}) = U_{\\ell,\\mathrm{ref}} + \\beta_{\\ell}\\,\\ln\\!\\left(\\frac{c_{\\ell}}{1 - c_{\\ell}}\\right), \\quad \\ell \\in \\{n,p\\},\n$$\n其中 $c_{\\ell}\\in(0,1)$ 是电极表面的无量纲固相锂分数（初始时等于每个电极的荷电状态），$U_{\\ell,\\mathrm{ref}}$ 是无量纲参考电势，$\\beta_{\\ell}$ 是无量纲系数。\n\n令未知数为每个电极的固相电势 $ \\phi_{s,n}$、$ \\phi_{s,p}$ 和正极处的电解质电势 $ \\phi_{e,p}$，规范为 $ \\phi_{e,n} = 0$。Butler–Volmer 反应电流密度为\n$$\nj_n = 2\\,k_n\\,\\sinh\\!\\left(\\frac{\\phi_{s,n} - \\phi_{e,n} - U_n(c_n)}{2}\\right) = 2\\,k_n\\,\\sinh\\!\\left(\\frac{\\phi_{s,n} - U_n(c_n)}{2}\\right),\n$$\n$$\nj_p = 2\\,k_p\\,\\sinh\\!\\left(\\frac{\\phi_{s,p} - \\phi_{e,p} - U_p(c_p)}{2}\\right),\n$$\n为强制与指定的外加电流和荷电状态保持一致而建立的代数系统为\n$$\nF_1(\\phi_{s,n}) = a_n\\,j_n - i_{\\mathrm{app}} = 0,\n$$\n$$\nF_2(\\phi_{s,p},\\phi_{e,p}) = a_p\\,j_p + i_{\\mathrm{app}} = 0,\n$$\n$$\nF_3(\\phi_{e,p}) = \\phi_{e,p} - r_e\\,i_{\\mathrm{app}} = 0.\n$$\n初始固相浓度是微分变量，因此可以在 $t=0$ 时自由地由指定的荷电状态设定，即 $ c_n = \\mathrm{SOC}_n$ 和 $ c_p = \\mathrm{SOC}_p$。问题要求建立该系统并概述用于求解它的牛顿法。\n\n任务：\n1. 从上述基本依据出发，写出非线性系统 $F(\\mathbf{x}) = \\mathbf{0}$，其中 $\\mathbf{x} = [\\phi_{s,n}, \\phi_{s,p}, \\phi_{e,p}]^\\top$，该系统必须被求解以找到与指定的初始电流 $i_{\\mathrm{app}}$ 和荷电状态值 $c_n$、$c_p$ 相一致的初始电势和浓度。\n2. 推导适用于牛顿迭代的解析雅可比矩阵 $J(\\mathbf{x}) = \\partial F/\\partial \\mathbf{x}$。\n3. 在给定参数值和初始猜测值的情况下，实现一个阻尼牛顿法来求解 $\\phi_{s,n}$、$\\phi_{s,p}$ 和 $\\phi_{e,p}$。使用规范 $ \\phi_{e,n} = 0$。将 $c_n$ 和 $c_p$ 分别视为给定的 $\\mathrm{SOC}_n$ 和 $\\mathrm{SOC}_p$。\n4. 提供一个包含三组参数的测试套件，用于测试不同的工况：\n   - 典型工作电流情况。\n   - $i_{\\mathrm{app}} = 0$ 的近平衡情况。\n   - 大电流情况。\n   对于每种情况，指定 $(i_{\\mathrm{app}}, \\mathrm{SOC}_n, \\mathrm{SOC}_p, a_n, a_p, k_n, k_p, r_e, U_{n,\\mathrm{ref}}, U_{p,\\mathrm{ref}}, \\beta_n, \\beta_p)$。\n5. 最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的汇总结果，格式为方括号内的逗号分隔列表。对于每个测试用例，按顺序输出六个浮点数 $[\\phi_{s,n}, \\phi_{e,n}, \\phi_{s,p}, \\phi_{e,p}, c_n, c_p]$，并将所有测试用例的结果平铺到一个列表中。所有量都是无量纲的，因此不需要物理单位。\n\n使用的测试套件参数：\n- 情况1（典型）：$(i_{\\mathrm{app}}, \\mathrm{SOC}_n, \\mathrm{SOC}_p, a_n, a_p, k_n, k_p, r_e, U_{n,\\mathrm{ref}}, U_{p,\\mathrm{ref}}, \\beta_n, \\beta_p) = (0.5, 0.7, 0.4, 1.0, 1.0, 1.0, 1.0, 0.2, 0.1, 4.0, 0.1, 0.1)$。\n- 情况2（近平衡）：$(0.0, 0.6, 0.6, 1.0, 1.0, 1.0, 1.0, 0.3, 0.15, 3.9, 0.2, 0.2)$。\n- 情况3（大电流）：$(2.0, 0.9, 0.3, 1.0, 1.0, 1.5, 1.0, 0.5, 0.2, 4.2, 0.15, 0.12)$。\n\n您的程序必须为上述定义的非线性系统实现牛顿求解，并生成指定的输出格式。不需要用户输入。",
            "solution": "该问题要求建立并求解一个非线性代数系统，以确定半离散化 Doyle-Fuller-Newman (DFN) 电池模型的一致初始条件。分析过程分为三个步骤：首先，建立控制方程组；其次，推导牛顿-拉夫逊迭代求解器所需的雅可比矩阵；第三，概述用于找到解的阻尼牛顿法的实现。\n\n### 1. 非线性系统的建立\n\n未知数的状态向量定义为 $\\mathbf{x} = [\\phi_{s,n}, \\phi_{s,p}, \\phi_{e,p}]^\\top$，分别代表负极固相电势、正极固相电势和正极电解质相电势。负极的电解质电势通过规范条件固定为 $\\phi_{e,n} = 0$。初始固相表面浓度 $c_n$ 和 $c_p$ 作为固定参数给出，等于电极特定的荷电状态 $\\mathrm{SOC}_n$ 和 $\\mathrm{SOC}_p$。\n\n方程组 $F(\\mathbf{x}) = \\mathbf{0}$ 源于基本的电化学和传输原理：\n\n1.  **负极界面处的电荷守恒：** 在整个界面面积上由电化学反应产生的总电流必须等于外加电流 $i_{\\mathrm{app}}$。这给出了第一个方程：\n    $$F_1 = a_n\\,j_n - i_{\\mathrm{app}} = 0$$\n    这里，$a_n$ 是界面面积比例因子，$j_n$ 是负极的反应电流密度。\n\n2.  **正极界面处的电荷守恒：** 类似地，考虑到符号约定（放电时电流流入正极），我们有：\n    $$F_2 = a_p\\,j_p + i_{\\mathrm{app}} = 0$$\n    其中 $a_p$ 是面积比例因子，$j_p$ 是正极的反应电流密度。\n\n3.  **电解质中的欧姆降：** 一个简化的欧姆模型将电解质中的电势降与外加电流联系起来：\n    $$F_3 = \\phi_{e,p} - \\phi_{e,n} - r_e\\,i_{\\mathrm{app}} = 0$$\n    在规范 $\\phi_{e,n}=0$ 下，这简化为：\n    $$F_3 = \\phi_{e,p} - r_e\\,i_{\\mathrm{app}} = 0$$\n    其中 $r_e$ 是电解质的有效无量纲电阻。\n\n反应电流密度 $j_n$ 和 $j_p$ 由对称传递系数（$\\alpha_a = \\alpha_c = 0.5$）的 Butler-Volmer 方程描述：\n$$j_{\\ell} = 2\\,k_{\\ell}\\,\\sinh\\!\\left(\\frac{\\eta_{\\ell}}{2}\\right), \\quad \\ell \\in \\{n, p\\}$$\n其中 $k_{\\ell}$ 是动力学速率前置因子，$\\eta_{\\ell}$ 是活化过电势，定义为 $\\eta_{\\ell} = \\phi_{s,\\ell} - \\phi_{e,\\ell} - U_{\\ell}(c_{\\ell})$。开路电势 $U_n$ 和 $U_p$ 是表面浓度的函数，由以下公式给出：\n$$U_{\\ell}(c_{\\ell}) = U_{\\ell,\\mathrm{ref}} + \\beta_{\\ell}\\,\\ln\\!\\left(\\frac{c_{\\ell}}{1 - c_{\\ell}}\\right)$$\n对于此初始化问题，$c_n$ 和 $c_p$ 是固定的，因此 $U_n$ 和 $U_p$ 被视为常数。\n\n将 $j_n$ 和 $j_p$ 的表达式代入守恒方程，我们得到显式的非线性系统 $F(\\mathbf{x}) = [F_1, F_2, F_3]^\\top = \\mathbf{0}$：\n$$\nF_1(\\phi_{s,n}) = 2\\,a_n\\,k_n\\,\\sinh\\!\\left(\\frac{\\phi_{s,n} - U_n}{2}\\right) - i_{\\mathrm{app}} = 0\n$$\n$$\nF_2(\\phi_{s,p}, \\phi_{e,p}) = 2\\,a_p\\,k_p\\,\\sinh\\!\\left(\\frac{\\phi_{s,p} - \\phi_{e,p} - U_p}{2}\\right) + i_{\\mathrm{app}} = 0\n$$\n$$\nF_3(\\phi_{e,p}) = \\phi_{e,p} - r_e\\,i_{\\mathrm{app}} = 0\n$$\n\n### 2. 雅可比矩阵的推导\n\n牛顿-拉夫逊法需要雅可比矩阵 $J(\\mathbf{x}) = \\partial F / \\partial \\mathbf{x}$，其元素为 $J_{ij} = \\partial F_i / \\partial x_j$。状态向量为 $\\mathbf{x} = [\\phi_{s,n}, \\phi_{s,p}, \\phi_{e,p}]^\\top$。\n\n使用链式法则和 $d(\\sinh(u))/dx = \\cosh(u) \\cdot du/dx$，偏导数计算如下。\n\n- **$F_1$ 的导数：**\n  - $\\frac{\\partial F_1}{\\partial \\phi_{s,n}} = 2\\,a_n\\,k_n\\,\\cosh\\!\\left(\\frac{\\phi_{s,n} - U_n}{2}\\right) \\cdot \\frac{1}{2} = a_n\\,k_n\\,\\cosh\\!\\left(\\frac{\\phi_{s,n} - U_n}{2}\\right)$\n  - $\\frac{\\partial F_1}{\\partial \\phi_{s,p}} = 0$\n  - $\\frac{\\partial F_1}{\\partial \\phi_{e,p}} = 0$\n\n- **$F_2$ 的导数：**\n  - $\\frac{\\partial F_2}{\\partial \\phi_{s,n}} = 0$\n  - $\\frac{\\partial F_2}{\\partial \\phi_{s,p}} = 2\\,a_p\\,k_p\\,\\cosh\\!\\left(\\frac{\\phi_{s,p} - \\phi_{e,p} - U_p}{2}\\right) \\cdot \\frac{1}{2} = a_p\\,k_p\\,\\cosh\\!\\left(\\frac{\\phi_{s,p} - \\phi_{e,p} - U_p}{2}\\right)$\n  - $\\frac{\\partial F_2}{\\partial \\phi_{e,p}} = 2\\,a_p\\,k_p\\,\\cosh\\!\\left(\\frac{\\phi_{s,p} - \\phi_{e,p} - U_p}{2}\\right) \\cdot \\left(-\\frac{1}{2}\\right) = -a_p\\,k_p\\,\\cosh\\!\\left(\\frac{\\phi_{s,p} - \\phi_{e,p} - U_p}{2}\\right)$\n\n- **$F_3$ 的导数：**\n  - $\\frac{\\partial F_3}{\\partial \\phi_{s,n}} = 0$\n  - $\\frac{\\partial F_3}{\\partial \\phi_{s,p}} = 0$\n  - $\\frac{\\partial F_3}{\\partial \\phi_{e,p}} = 1$\n\n将这些分量组合起来，得到雅可比矩阵：\n$$\nJ(\\mathbf{x}) = \\begin{pmatrix}\na_n k_n \\cosh\\!\\left(\\frac{\\phi_{s,n} - U_n}{2}\\right)  0  0 \\\\\n0  a_p k_p \\cosh\\!\\left(\\frac{\\phi_{s,p} - \\phi_{e,p} - U_p}{2}\\right)  -a_p k_p \\cosh\\!\\left(\\frac{\\phi_{s,p} - \\phi_{e,p} - U_p}{2}\\right) \\\\\n0  0  1\n\\end{pmatrix}\n$$\n雅可比矩阵的上三角结构表明该系统只是部分耦合的。\n\n### 3. 阻尼牛顿法\n\n牛顿-拉夫逊法是一种寻找 $F(\\mathbf{x}) = \\mathbf{0}$ 根的迭代过程。从初始猜测值 $\\mathbf{x}_0$ 开始，通过求解基于 $F(\\mathbf{x})$ 在当前迭代值 $\\mathbf{x}_k$ 附近的一阶泰勒展开的线性系统，来找到连续的近似值 $\\mathbf{x}_{k+1}$。\n\n迭代更新由下式给出：\n$$ \\mathbf{x}_{k+1} = \\mathbf{x}_k + \\alpha_k \\Delta\\mathbf{x}_k $$\n其中步长方向 $\\Delta\\mathbf{x}_k$ 是线性系统的解：\n$$ J(\\mathbf{x}_k) \\Delta\\mathbf{x}_k = -F(\\mathbf{x}_k) $$\n标量 $\\alpha_k \\in (0, 1]$ 是一个阻尼因子，选择它是为了确保从更广泛的初始猜测值范围收敛。采用回溯线搜索来选择 $\\alpha_k$：从 $\\alpha_k = 1$ 开始，依次减小（例如，减半），直到满足条件 $\\|F(\\mathbf{x}_k + \\alpha_k \\Delta\\mathbf{x}_k)\\|  \\|F(\\mathbf{x}_k)\\|$，从而确保每一步的残差范数都在减小。\n\n算法流程如下：\n1.  使用一个猜测值 $\\mathbf{x}_0$ 进行初始化。一个有物理动机的选择是 $\\mathbf{x}_0 = [U_n, U_p, 0]^\\top$，对应于平衡状态。\n2.  对于 $k=0, 1, 2, \\dots$：\n    a. 计算残差向量 $F(\\mathbf{x}_k)$ 及其范数 $\\|F(\\mathbf{x}_k)\\|$。如果范数低于指定的容差 $\\epsilon$，则算法已收敛。\n    b. 计算雅可比矩阵 $J(\\mathbf{x}_k)$。\n    c. 求解线性系统 $J(\\mathbf{x}_k) \\Delta\\mathbf{x}_k = -F(\\mathbf{x}_k)$ 以获得更新步长 $\\Delta\\mathbf{x}_k$。\n    d. 执行回溯线搜索以找到合适的阻尼因子 $\\alpha_k$。\n    e. 更新解：$\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\alpha_k \\Delta\\mathbf{x}_k$。\n3.  最终的迭代值 $\\mathbf{x}_k$ 是初始电势 $[\\phi_{s,n}, \\phi_{s,p}, \\phi_{e,p}]^\\top$ 的数值解。\n随后时间积分中要使用的初始条件则由求解出的电势和指定的初始浓度给出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve for consistent initial conditions for all test cases.\n    \"\"\"\n    # Test suite parameters:\n    # (i_app, SOC_n, SOC_p, a_n, a_p, k_n, k_p, r_e, U_n_ref, U_p_ref, beta_n, beta_p)\n    test_cases = [\n        # Case 1 (typical)\n        (0.5, 0.7, 0.4, 1.0, 1.0, 1.0, 1.0, 0.2, 0.1, 4.0, 0.1, 0.1),\n        # Case 2 (near-equilibrium)\n        (0.0, 0.6, 0.6, 1.0, 1.0, 1.0, 1.0, 0.3, 0.15, 3.9, 0.2, 0.2),\n        # Case 3 (high-current)\n        (2.0, 0.9, 0.3, 1.0, 1.0, 1.5, 1.0, 0.5, 0.2, 4.2, 0.15, 0.12),\n    ]\n\n    all_results_flat = []\n\n    for i, case_params in enumerate(test_cases):\n        params = {\n            'i_app': case_params[0],\n            'soc_n': case_params[1],\n            'soc_p': case_params[2],\n            'a_n': case_params[3],\n            'a_p': case_params[4],\n            'k_n': case_params[5],\n            'k_p': case_params[6],\n            'r_e': case_params[7],\n            'U_n_ref': case_params[8],\n            'U_p_ref': case_params[9],\n            'beta_n': case_params[10],\n            'beta_p': case_params[11],\n        }\n\n        # Calculate open-circuit potentials\n        params['U_n'] = _calc_ocp(params['U_n_ref'], params['beta_n'], params['soc_n'])\n        params['U_p'] = _calc_ocp(params['U_p_ref'], params['beta_p'], params['soc_p'])\n\n        # Initial guess for x = [phi_s,n, phi_s,p, phi_e,p]\n        # A good guess is the equilibrium potential state.\n        x0 = np.array([params['U_n'], params['U_p'], 0.0])\n\n        # Solve the nonlinear system using the Newton method\n        x_sol = _newton_solver(params, x0)\n\n        phi_sn_sol, phi_sp_sol, phi_ep_sol = x_sol\n\n        # Collect results for this case in the specified order\n        # [phi_s,n, phi_e,n, phi_s,p, phi_e,p, c_n, c_p]\n        # phi_e,n is 0 by gauge choice. c_n/c_p are the given SOCs.\n        case_results = [\n            phi_sn_sol,\n            0.0,\n            phi_sp_sol,\n            phi_ep_sol,\n            params['soc_n'],\n            params['soc_p'],\n        ]\n        all_results_flat.extend(case_results)\n\n    # Print the flattened list in the required format\n    print(f\"[{','.join(f'{v:.6f}' for v in all_results_flat)}]\")\n\n\ndef _calc_ocp(U_ref, beta, c):\n    \"\"\"Calculates the open-circuit potential using the Nernst-type relation.\"\"\"\n    if not (0  c  1):\n        raise ValueError(\"Concentration c must be in the interval (0, 1).\")\n    return U_ref + beta * np.log(c / (1.0 - c))\n\n\ndef _evaluate_F(x, params):\n    \"\"\"\n    Evaluates the residual vector F(x) of the nonlinear system.\n    x = [phi_s,n, phi_s,p, phi_e,p]\n    \"\"\"\n    phi_sn, phi_sp, phi_ep = x\n\n    # Butler-Volmer current densities\n    jn = 2.0 * params['k_n'] * np.sinh((phi_sn - params['U_n']) / 2.0)\n    jp = 2.0 * params['k_p'] * np.sinh((phi_sp - phi_ep - params['U_p']) / 2.0)\n\n    # Residuals\n    F1 = params['a_n'] * jn - params['i_app']\n    F2 = params['a_p'] * jp + params['i_app']\n    F3 = phi_ep - params['r_e'] * params['i_app']\n\n    return np.array([F1, F2, F3])\n\n\ndef _evaluate_J(x, params):\n    \"\"\"\n    Evaluates the Jacobian matrix J(x) of the nonlinear system.\n    x = [phi_s,n, phi_s,p, phi_e,p]\n    \"\"\"\n    phi_sn, phi_sp, phi_ep = x\n\n    # Jacobian components\n    J11 = params['a_n'] * params['k_n'] * np.cosh((phi_sn - params['U_n']) / 2.0)\n\n    common_term_p = params['a_p'] * params['k_p'] * np.cosh((phi_sp - phi_ep - params['U_p']) / 2.0)\n    J22 = common_term_p\n    J23 = -common_term_p\n\n    return np.array([\n        [J11, 0.0, 0.0],\n        [0.0, J22, J23],\n        [0.0, 0.0, 1.0]\n    ])\n\n\ndef _newton_solver(params, x0, tol=1e-10, max_iter=50, max_backtrack=10):\n    \"\"\"\n    Solves F(x)=0 using a damped Newton-Raphson method.\n    \"\"\"\n    x = np.copy(x0).astype(float)\n\n    for _ in range(max_iter):\n        F = _evaluate_F(x, params)\n        norm_F = np.linalg.norm(F)\n\n        if norm_F  tol:\n            return x\n\n        J = _evaluate_J(x, params)\n        if np.linalg.det(J) == 0:\n            raise RuntimeError(\"Newton solver failed: Jacobian is singular.\")\n\n        delta_x = np.linalg.solve(J, -F)\n\n        # Damping via backtracking line search\n        alpha = 1.0\n        for _ in range(max_backtrack):\n            x_new = x + alpha * delta_x\n            norm_F_new = np.linalg.norm(_evaluate_F(x_new, params))\n            if norm_F_new  norm_F:\n                break\n            alpha /= 2.0\n        else: # Loop completed without break\n            raise RuntimeError(\"Newton solver failed: line search did not converge.\")\n\n        x = x_new\n    \n    raise RuntimeError(\"Newton solver failed: maximum iterations reached.\")\n\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}