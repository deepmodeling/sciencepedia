{
    "hands_on_practices": [
        {
            "introduction": "伪二维（P2D）模型是电池模拟的基石。为了设计高效的数值求解器，理解模型中固有的物理时间尺度至关重要。本练习将通过无量纲化这一强大技术，揭示这些时间尺度，并量化数值刚度这一高性能计算中的主要障碍。",
            "id": "3918533",
            "problem": "考虑一个多孔锂离子电池电极的伪二维（P2D）模型，该模型在厚度方向坐标 $x \\in [0,L]$ 和球形颗粒径向坐标 $r \\in [0,R_{p}]$ 上求解。基于菲克传输、电荷守恒和界面动力学的控制关系式包括：\n\n- 电解质质量平衡：$\\varepsilon_{e}\\,\\dfrac{\\partial c_{e}}{\\partial t} = \\dfrac{\\partial}{\\partial x}\\!\\left(D_{e}\\,\\dfrac{\\partial c_{e}}{\\partial x}\\right) + \\left(1-t_{+}^{0}\\right)\\,\\dfrac{a_{s}\\,j}{F}$。\n- 固相颗粒扩散：$\\dfrac{\\partial c_{s}}{\\partial t} = \\dfrac{D_{s}}{r^{2}}\\,\\dfrac{\\partial}{\\partial r}\\!\\left(r^{2}\\,\\dfrac{\\partial c_{s}}{\\partial r}\\right)$，边界条件为 $-D_{s}\\,\\left.\\dfrac{\\partial c_{s}}{\\partial r}\\right|_{r=R_{p}} = \\dfrac{j}{F}$ 且在 $r=0$ 处对称。\n- 电解质中电荷守恒：$\\dfrac{\\partial}{\\partial x}\\!\\left(\\kappa_{\\mathrm{eff}}\\,\\dfrac{\\partial \\phi_{e}}{\\partial x} + 2\\,\\dfrac{R\\,T}{F}\\,\\left(1-t_{+}^{0}\\right)\\,\\dfrac{\\partial \\ln c_{e}}{\\partial x}\\right) = a_{s}\\,j$。\n- 固相中电荷守恒：$\\dfrac{\\partial}{\\partial x}\\!\\left(\\sigma_{\\mathrm{eff}}\\,\\dfrac{\\partial \\phi_{s}}{\\partial x}\\right) = -\\,a_{s}\\,j$。\n- 界面动力学（通用形式），$j = j_{\\mathrm{ref}}\\,\\mathcal{K}(c_{e},c_{s}^{\\mathrm{surf}},\\eta)$，其中 $\\mathcal{K}$ 是一个由 Butler-Volmer 型关系产生的无量纲动力学函数，$\\eta$ 是过电势。\n\n此处，$\\varepsilon_{e}$ 是电解质孔隙率，$c_{e}$ 是电解质锂浓度，$c_{s}$ 是活性颗粒内部的固相浓度，$D_{e}$ 和 $D_{s}$ 分别是有效电解质和固相扩散系数，$t_{+}^{0}$ 是迁移数，$a_{s}$ 是比界面面积，$j$ 是界面电流密度，$F$ 是法拉第常数，$\\kappa_{\\mathrm{eff}}$ 和 $\\sigma_{\\mathrm{eff}}$ 分别是有效电解质和固相电导率，$\\phi_{e}$ 和 $\\phi_{s}$ 分别是电解质和固相电势，$R$ 是普适气体常数，$T$ 是温度。\n\n从这些方程和标准守恒原理出发，使用以下尺度进行系统性的无量纲化：$x$ 用 $L$，$r$ 用 $R_{p}$，$t$ 对于厚度方向过程用 $t_{D,e} = L^{2}/D_{e}$，对于颗粒内部过程酌情使用 $t_{D,s} = R_{p}^{2}/D_{s}$，$c_{e}$ 用 $c_{e0}$，$c_{s}$ 用 $c_{s,\\max}$，$\\phi_{e}$ 和 $\\phi_{s}$ 用 $R\\,T/F$，$j$ 用 $j_{\\mathrm{ref}}$。根据你的无量纲化过程，识别并用原始的量纲参数解释以下关键无量纲数群：\n\n- 电解质丹姆科勒数 $\\mathrm{Da}_{e}$，衡量反应速率与电解质扩散速率之比。\n- 颗粒泰勒型参数 $\\phi^{2}$，衡量界面反应速率与颗粒内部固态扩散速率之比。\n- 电导率比 $\\Lambda$，比较电子传导路径与离子传导路径。\n\n简要解释这些数群的量级如何为大规模模拟的高性能计算（HPC）实现中算法刚度的判断以及时间积分器和预处理器的选择提供信息。\n\n然后，使用你推导出的表达式，针对以下在室温下科学上合理的参数值，评估复合刚度指标\n$$\\Xi \\equiv \\max\\!\\left\\{\\mathrm{Da}_{e},\\,\\phi^{2}\\right\\}$$\n$L = 70\\times 10^{-6}\\,\\mathrm{m}$，$R_{p} = 5\\times 10^{-6}\\,\\mathrm{m}$，$a_{s} = 8.0\\times 10^{4}\\,\\mathrm{m^{-1}}$，$D_{e} = 1.5\\times 10^{-10}\\,\\mathrm{m^{2}\\,s^{-1}}$，$D_{s} = 5.0\\times 10^{-14}\\,\\mathrm{m^{2}\\,s^{-1}}$，$c_{e0} = 1000\\,\\mathrm{mol\\,m^{-3}}$，$c_{s,\\max} = 2.5\\times 10^{4}\\,\\mathrm{mol\\,m^{-3}}$，$j_{\\mathrm{ref}} = 3.0\\,\\mathrm{A\\,m^{-2}}$，$F = 96485\\,\\mathrm{C\\,mol^{-1}}$。假设 $t_{+}^{0}$ 和任何动力学对称因子都是中等大小，并且不改变所识别数群的主阶标度。将 $\\Xi$ 的最终数值结果四舍五入到三位有效数字。将最终结果表示为一个无量纲数。",
            "solution": "首先将验证问题陈述的科学性和形式正确性。\n\n### 第 1 步：提取已知条件\n伪二维（P2D）电池模型的控制方程如下：\n- 电解质质量平衡：$\\varepsilon_{e}\\,\\dfrac{\\partial c_{e}}{\\partial t} = \\dfrac{\\partial}{\\partial x}\\!\\left(D_{e}\\,\\dfrac{\\partial c_{e}}{\\partial x}\\right) + \\left(1-t_{+}^{0}\\right)\\,\\dfrac{a_{s}\\,j}{F}$\n- 固相颗粒扩散：$\\dfrac{\\partial c_{s}}{\\partial t} = \\dfrac{D_{s}}{r^{2}}\\,\\dfrac{\\partial}{\\partial r}\\!\\left(r^{2}\\,\\dfrac{\\partial c_{s}}{\\partial r}\\right)$\n- 固相颗粒边界条件：$-D_{s}\\,\\left.\\dfrac{\\partial c_{s}}{\\partial r}\\right|_{r=R_{p}} = \\dfrac{j}{F}$ 且在 r=0 处对称。\n- 电解质中电荷守恒：$\\dfrac{\\partial}{\\partial x}\\!\\left(\\kappa_{\\mathrm{eff}}\\,\\dfrac{\\partial \\phi_{e}}{\\partial x} + 2\\,\\dfrac{R\\,T}{F}\\,\\left(1-t_{+}^{0}\\right)\\,\\dfrac{\\partial \\ln c_{e}}{\\partial x}\\right) = a_{s}\\,j$\n- 固相中电荷守恒：$\\dfrac{\\partial}{\\partial x}\\!\\left(\\sigma_{\\mathrm{eff}}\\,\\dfrac{\\partial \\phi_{s}}{\\partial x}\\right) = -\\,a_{s}\\,j$\n- 界面动力学：$j = j_{\\mathrm{ref}}\\,\\mathcal{K}(c_{e},c_{s}^{\\mathrm{surf}},\\eta)$\n\n无量纲化的特征尺度如下：\n- $x \\sim L$\n- $r \\sim R_{p}$\n- 对于厚度方向过程，$t \\sim t_{D,e} = L^{2}/D_{e}$\n- 对于颗粒内部过程，$t \\sim t_{D,s} = R_{p}^{2}/D_{s}$\n- $c_{e} \\sim c_{e0}$\n- $c_{s} \\sim c_{s,\\max}$\n- $\\phi_{e}, \\phi_{s} \\sim R\\,T/F$\n- $j \\sim j_{\\mathrm{ref}}$\n\n数值参数值如下：\n- $L = 70\\times 10^{-6}\\,\\mathrm{m}$\n- $R_{p} = 5\\times 10^{-6}\\,\\mathrm{m}$\n- $a_{s} = 8.0\\times 10^{4}\\,\\mathrm{m^{-1}}$\n- $D_{e} = 1.5\\times 10^{-10}\\,\\mathrm{m^{2}\\,s^{-1}}$\n- $D_{s} = 5.0\\times 10^{-14}\\,\\mathrm{m^{2}\\,s^{-1}}$\n- $c_{e0} = 1000\\,\\mathrm{mol\\,m^{-3}}$\n- $c_{s,\\max} = 2.5\\times 10^{4}\\,\\mathrm{mol\\,m^{-3}}$\n- $j_{\\mathrm{ref}} = 3.0\\,\\mathrm{A\\,m^{-2}}$\n- $F = 96485\\,\\mathrm{C\\,mol^{-1}}$\n\n任务是推导和解释三个无量纲数群（$\\mathrm{Da}_{e}$、$\\phi^{2}$、$\\Lambda$），解释它们对数值模拟的意义，并计算刚度指标 $\\Xi \\equiv \\max\\!\\left\\{\\mathrm{Da}_{e},\\,\\phi^{2}\\right\\}$。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题具有科学依据。所提供的方程是标准的、被广泛接受的 Doyle-Fuller-Newman（或 P2D）模型，它是基于输运现象和电化学基本原理的电池模拟的基石。该问题是适定的、自洽的、客观的。它对一个成熟的物理模型进行了标准分析（无量纲化）。所提供的参数对于典型的锂离子电池系统是科学上合理的。所提出的问题直接关系到求解这些方程的数值分析和高性能计算方面，这是该领域的一个关键课题。没有矛盾、模糊之处或事实错误。\n\n### 第 3 步：结论和行动\n问题有效。将提供完整的解答。\n\n### 无量纲化与推导\n\n我们定义以下用上划线表示的无量纲变量：\n$\\bar{x} = \\dfrac{x}{L}$，$\\bar{r} = \\dfrac{r}{R_{p}}$，$\\bar{c}_{e} = \\dfrac{c_{e}}{c_{e0}}$，$\\bar{c}_{s} = \\dfrac{c_{s}}{c_{s,\\max}}$，$\\bar{\\phi}_{e} = \\dfrac{\\phi_{e}}{RT/F}$，$\\bar{\\phi}_{s} = \\dfrac{\\phi_{s}}{RT/F}$，$\\bar{j} = \\dfrac{j}{j_{\\mathrm{ref}}}$。\n对于时间，我们使用电解质扩散时间尺度，$\\bar{t} = \\dfrac{t}{t_{D,e}} = \\dfrac{t D_{e}}{L^2}$。\n\n导数变换如下：\n$\\dfrac{\\partial}{\\partial t} = \\dfrac{D_{e}}{L^{2}}\\dfrac{\\partial}{\\partial \\bar{t}}$，$\\dfrac{\\partial}{\\partial x} = \\dfrac{1}{L}\\dfrac{\\partial}{\\partial \\bar{x}}$，$\\dfrac{\\partial}{\\partial r} = \\dfrac{1}{R_{p}}\\dfrac{\\partial}{\\partial \\bar{r}}$。\n\n1.  **电解质质量平衡分析**\n    原始方程为：\n    $$ \\varepsilon_{e}\\,\\dfrac{\\partial c_{e}}{\\partial t} = \\dfrac{\\partial}{\\partial x}\\!\\left(D_{e}\\,\\dfrac{\\partial c_{e}}{\\partial x}\\right) + \\left(1-t_{+}^{0}\\right)\\,\\dfrac{a_{s}\\,j}{F} $$\n    代入无量纲变量：\n    $$ \\varepsilon_{e}\\,\\dfrac{c_{e0} D_{e}}{L^2}\\dfrac{\\partial \\bar{c}_{e}}{\\partial \\bar{t}} = \\dfrac{1}{L}\\dfrac{\\partial}{\\partial \\bar{x}}\\!\\left(D_{e}\\,\\dfrac{c_{e0}}{L}\\dfrac{\\partial \\bar{c}_{e}}{\\partial \\bar{x}}\\right) + \\left(1-t_{+}^{0}\\right)\\,\\dfrac{a_{s}\\,(j_{\\mathrm{ref}}\\bar{j})}{F} $$\n    假设 $D_e$ 是常数，并除以扩散项的尺度 $\\dfrac{D_{e}c_{e0}}{L^2}$：\n    $$ \\varepsilon_{e}\\,\\dfrac{\\partial \\bar{c}_{e}}{\\partial \\bar{t}} = \\dfrac{\\partial^2 \\bar{c}_{e}}{\\partial \\bar{x}^2} + \\left(1-t_{+}^{0}\\right)\\,\\left(\\dfrac{a_{s}\\,j_{\\mathrm{ref}}L^2}{F\\,c_{e0}\\,D_{e}}\\right)\\bar{j} $$\n    乘以反应项 $\\bar{j}$ 的无量纲数群是电解质丹姆科勒数 $\\mathrm{Da}_{e}$。它代表了反应的特征速率与电解质中扩散的特征速率之比。\n    $$ \\mathrm{Da}_{e} = \\dfrac{a_{s}\\,j_{\\mathrm{ref}}L^2}{F\\,c_{e0}\\,D_{e}} $$\n    解释：$\\mathrm{Da}_{e}$ 是电解质穿过电极的特征时间尺度（$L^2/D_e$）与反应消耗电解质的时间尺度之比。如果 $\\mathrm{Da}_{e} \\gg 1$，则反应远快于扩散，导致急剧的浓度梯度。\n\n2.  **固相颗粒扩散分析**\n    固相扩散方程使用其自身的内部时间尺度 $\\bar{t_s} = t/t_{D,s} = tD_s/R_p^2$。颗粒表面的边界条件是关键。\n    $$ -D_{s}\\,\\left.\\dfrac{\\partial c_{s}}{\\partial r}\\right|_{r=R_{p}} = \\dfrac{j}{F} $$\n    代入无量纲变量：\n    $$ -D_{s}\\,\\dfrac{c_{s,\\max}}{R_{p}}\\left.\\dfrac{\\partial \\bar{c}_{s}}{\\partial \\bar{r}}\\right|_{\\bar{r}=1} = \\dfrac{j_{\\mathrm{ref}}\\bar{j}}{F} $$\n    重新整理以使导数项无量纲化：\n    $$ -\\left.\\dfrac{\\partial \\bar{c}_{s}}{\\partial \\bar{r}}\\right|_{\\bar{r}=1} = \\left(\\dfrac{j_{\\mathrm{ref}}R_{p}}{F\\,D_{s}\\,c_{s,\\max}}\\right)\\bar{j} $$\n    括号中的数群是泰勒型参数 $\\phi^{2}$。它衡量颗粒表面的反应速率与颗粒内部的特征扩散速率之比。\n    $$ \\phi^{2} = \\dfrac{j_{\\mathrm{ref}}R_{p}}{F\\,D_{s}\\,c_{s,\\max}} $$\n    解释：$\\phi^2$ 是表面反应通量（$j/F$）与颗粒内最大可能扩散通量（$D_s c_{s,max}/R_p$）之比。如果 $\\phi^{2} \\gg 1$，则反应相对于固态扩散而言是快速的，锂在颗粒中的分布将不均匀，在表面附近出现陡峭的梯度。\n\n3.  **电荷守恒分析**\n    我们分析两个电荷守恒方程来找出电导率比。\n    固相：$\\dfrac{\\partial}{\\partial x}\\!\\left(\\sigma_{\\mathrm{eff}}\\,\\dfrac{\\partial \\phi_{s}}{\\partial x}\\right) = -\\,a_{s}\\,j$\n    电解相：$\\dfrac{\\partial}{\\partial x}\\!\\left(\\kappa_{\\mathrm{eff}}\\,\\dfrac{\\partial \\phi_{e}}{\\partial x} + \\dots\\right) = a_{s}\\,j$\n    对固相方程进行无量纲化：\n    $$ \\dfrac{1}{L}\\dfrac{\\partial}{\\partial \\bar{x}}\\!\\left(\\sigma_{\\mathrm{eff}}\\,\\dfrac{RT}{FL}\\dfrac{\\partial \\bar{\\phi}_{s}}{\\partial \\bar{x}}\\right) = -\\,a_{s}\\,(j_{\\mathrm{ref}}\\bar{j}) \\implies \\dfrac{\\partial^2 \\bar{\\phi}_{s}}{\\partial \\bar{x}^2} = -\\left(\\dfrac{a_s j_{\\mathrm{ref}} L^2 F}{\\sigma_{\\mathrm{eff}} RT}\\right)\\bar{j} $$\n    电解相方程的欧姆定律部分，$\\dfrac{\\partial}{\\partial x}(\\kappa_{\\mathrm{eff}}\\,\\dfrac{\\partial \\phi_e}{\\partial x})$，也类似地进行标度，得到一个无量纲数群 $\\dfrac{a_s j_{\\mathrm{ref}} L^2 F}{\\kappa_{\\mathrm{eff}} RT}$。\n    问题要求一个比较电子和离子路径的电导率比 $\\Lambda$。电导率本身的直接比值是最自然且最有意义的定义。\n    $$ \\Lambda = \\dfrac{\\sigma_{\\mathrm{eff}}}{\\kappa_{\\mathrm{eff}}} $$\n    解释：$\\Lambda$ 比较了电子电荷通过固相基质传输的难易程度与离子电荷通过电解质传输的难易程度。如果 $\\Lambda \\gg 1$，固相的导电性要强得多，显著的电势降（以及由此产生的欧姆损耗）将主要发生在电解质中。如果 $\\Lambda \\ll 1$，则情况相反。这种平衡控制着反应电流在电极厚度上的分布。\n\n### HPC 影响\n$\\mathrm{Da}_{e}$ 和 $\\phi^{2}$ 的量级是数值刚度的关键指标。当微分方程系统中不同过程之间存在巨大的时间尺度分离时，就会出现刚性问题。\n- 较大的 $\\mathrm{Da}_{e}$ 或 $\\phi^2$ 意味着反应的特征时间远小于扩散的特征时间。\n- 这就产生了一个多尺度时间问题：系统具有快速动力学（反应）和慢速动力学（扩散）。为了捕捉长时间（例如，一个完整的充电/放电循环）内的整体行为，模拟会受到快速动力学的瓶颈限制。\n- **时间积分器**：显式时间积分方法（例如，前向欧拉法，龙格-库塔法）具有稳定性区域，要求时间步长 $\\Delta t$ 与系统中最快的时间尺度处于同一数量级。对于刚性问题，这会导致时间步数过多而无法接受。因此，较大的 $\\mathrm{Da}_{e}$ 或 $\\phi^2$ 值要求使用隐式的、A-稳定的方法（例如，后向差分公式，BDF），这些方法对于大得多的时间步长也是稳定的。\n- **预处理器**：A-稳定的隐式方法需要在每个时间步求解一个大型、稀疏、非线性的代数方程组，通常通过牛顿-拉夫逊型方法。其核心是求解一个线性系统 $J\\delta x = -f$，其中 $J$ 是雅可比矩阵。对于刚性问题，$J$ 往往是病态的，导致迭代线性求解器（如 HPC 中常用的 GMRES）收敛缓慢或失败。一个有效的预处理器 $P$ 是一个近似于 $J^{-1}$ 的矩阵，它将系统转换为 $P J \\delta x = -P f$，这个新系统条件更好，更容易求解。开发基于物理的预处理器，利用 P2D 模型中已知的耦合结构，对于在大型电池模拟中实现高性能至关重要。\n\n### 刚度指标的数值计算\n我们现在使用所提供的值计算 $\\mathrm{Da}_{e}$ 和 $\\phi^{2}$，以求出 $\\Xi = \\max\\!\\left\\{\\mathrm{Da}_{e},\\,\\phi^{2}\\right\\}$。\n\n-   $\\mathrm{Da}_{e}$ 的计算：\n    $$ \\mathrm{Da}_{e} = \\dfrac{a_{s}\\,j_{\\mathrm{ref}}L^2}{F\\,c_{e0}\\,D_{e}} = \\dfrac{(8.0\\times 10^{4}\\,\\mathrm{m^{-1}})(3.0\\,\\mathrm{A\\,m^{-2}})(70\\times 10^{-6}\\,\\mathrm{m})^2}{(96485\\,\\mathrm{C\\,mol^{-1}})(1000\\,\\mathrm{mol\\,m^{-3}})(1.5\\times 10^{-10}\\,\\mathrm{m^{2}\\,s^{-1}})} $$\n    $$ \\mathrm{Da}_{e} = \\dfrac{(8.0 \\times 10^4)(3.0)(4.9 \\times 10^{-9})}{96485 \\times 10^3 \\times 1.5 \\times 10^{-10}} = \\dfrac{1.176 \\times 10^{-3}}{1.447275 \\times 10^{-2}} \\approx 0.081256 $$\n\n-   $\\phi^{2}$ 的计算：\n    $$ \\phi^{2} = \\dfrac{j_{\\mathrm{ref}}R_{p}}{F\\,D_{s}\\,c_{s,\\max}} = \\dfrac{(3.0\\,\\mathrm{A\\,m^{-2}})(5\\times 10^{-6}\\,\\mathrm{m})}{(96485\\,\\mathrm{C\\,mol^{-1}})(5.0\\times 10^{-14}\\,\\mathrm{m^{2}\\,s^{-1}})(2.5\\times 10^{4}\\,\\mathrm{mol\\,m^{-3}})} $$\n    $$ \\phi^{2} = \\dfrac{1.5 \\times 10^{-5}}{96485 \\times (1.25 \\times 10^{-9})} = \\dfrac{1.5 \\times 10^{-5}}{1.2060625 \\times 10^{-4}} \\approx 0.12437 $$\n\n-   $\\Xi$ 的评估：\n    $$ \\Xi = \\max\\!\\left\\{0.081256, 0.12437\\right\\} = 0.12437 $$\n    四舍五入到三位有效数字，结果为 $0.124$。",
            "answer": "$$\\boxed{0.124}$$"
        },
        {
            "introduction": "在理解了数值挑战之后，下一步是在给定的计算机体系结构上分析实际代码的性能。本练习介绍屋顶线（Roofline）模型，这是高性能计算中的一个重要工具，用于判断计算过程是受限于内存带宽还是处理器速度。通过分析电池模拟中的一个关键内核——扩散矩阵的组装，您将学会计算运算强度并识别性能瓶颈。",
            "id": "3918481",
            "problem": "一个三维锂离子电池电解质扩散问题，在使用基于菲克定律的单元中心有限体积法在均匀笛卡尔网格上进行离散化。菲克定律指出，摩尔通量密度与浓度的负梯度成正比。通过计算每个单元与其在 $x$、$y$ 和 $z$ 方向上的六个轴向邻居之间的面心扩散通量，将扩散算子组装成一个稀疏对称正定矩阵。对于每个内部单元，组装核对每个面执行以下操作：使用公式 $H = \\frac{2 D_{i} D_{j}}{D_{i} + D_{j}}$ 计算两个相邻单元扩散系数的调和平均值，将 $H$ 乘以一个预先计算的几何因子 $f = \\frac{A}{d}$（其中 $A$ 是面面积，$d$ 是穿过面的单元中心距），并更新两个受影响的稀疏矩阵条目，将 $a = H f$ 加到当前单元的对角线元素上，并从耦合当前单元与其邻居的非对角线元素中减去 $a$。假设采用双精度浮点运算，每个浮点数占用 $8$ 字节；索引数组使用 $32$ 位整数，每个整数占用 $4$ 字节。\n\n假设该核的每个面具有以下算术和内存行为：\n- 每个面的算术运算：计算 $H$ 需要 $2$ 次乘法、$1$ 次加法和 $1$ 次除法；计算 $a$ 需要 $1$ 次乘法；更新两个稀疏矩阵条目需要 $2$ 次加法。因此，每个面有 $7$ 次浮点运算，每个单元有 $6$ 个面，总计每个单元有 $42$ 次浮点运算。\n- 每个单元的内存访问：读取当前单元的扩散系数 $D_{i}$ 一次（$8$ 字节），读取 $6$ 个邻居单元的扩散系数 $D_{j}$（$6 \\times 8$ 字节），读取 $6$ 个预计算的几何因子 $f$（$6 \\times 8$ 字节），执行 $12$ 次稀疏矩阵更新，每次更新包括对一个双精度值的读-修改-写操作（$12 \\times (8 + 8)$ 字节），并读取 $12$ 个整数偏移量，用于将局部更新映射到全局矩阵位置（$12 \\times 4$ 字节）。因此，每个单元的总数据移动量为 $344$ 字节。\n\n目标架构是一个现代高性能计算（HPC）节点的单插槽，其特点是峰值双精度吞吐量为 $3\\,\\mathrm{TFLOP/s}$，持续主内存带宽为 $100\\,\\mathrm{GB/s}$。\n\n仅使用操作强度的通用定义（即每传输字节的浮点运算次数）以及“roofline性能界限由峰值浮点吞吐量和受带宽限制的吞吐量中的较小者决定”这一概念，执行以下操作：\n- 根据所述的算术和数据移动特性，推导所述组装核的操作强度。将最终的操作强度以每字节浮点运算次数表示。\n- 解释对于给定架构，该核在roofline图上的位置，并论证其是内存密集型还是计算密集型。\n- 基于阿姆达尔定律和古斯塔夫森定律，论证优化此核的并行扩展性影响，并提出至少一种科学合理的优化方法，通过改变算术与内存访问比率，将该核推向计算密集型区域。\n\n将您的操作强度四舍五入到四位有效数字。以每字节浮点运算次数表示操作强度。",
            "solution": "该问题陈述经评估为有效。它在科学上基于偏微分方程数值方法和高性能计算性能分析的原理。问题提法得当、客观，并提供了一套自洽、一致的数据和定义，足以推导所要求的量并进行分析。没有发现诸如科学不健全、不完整或含糊不清等可识别的缺陷。因此，在此给出完整解答。\n\n按照问题陈述的要求，解答分为三个部分。\n\n首先，我们推导该核的操作强度。操作强度（用 $I$ 表示）定义为执行的总浮点运算次数（FLOPs）与处理器和主内存之间移动的总数据字节数之比。\n\n问题提供了以下基于每个单元的值：\n- 每个单元的总浮点运算次数：$42$ FLOPs。\n- 每个单元的总数据移动量：$344$ 字节。\n\n使用操作强度的定义，我们可以计算该核的操作强度值：\n$$\nI = \\frac{\\text{Total Floating-Point Operations}}{\\text{Total Data Movement}} = \\frac{42 \\text{ FLOPs}}{344 \\text{ Bytes}}\n$$\n计算此表达式并四舍五入到四位有效数字：\n$$\nI \\approx 0.122093... \\text{ FLOPs/Byte} \\approx 0.1221 \\text{ FLOPs/Byte}\n$$\n\n其次，我们分析该核在给定架构的roofline图上的位置，并确定其是内存密集型还是计算密集型。Roofline模型建立了一个性能上界 $\\Pi$，该上界由架构的峰值浮点吞吐量 $\\Pi_{\\text{peak}}$ 和受内存带宽限制的性能 $\\beta$ 中的较小者决定。其公式为：\n$$\n\\Pi \\le \\min(\\Pi_{\\text{peak}}, I \\cdot \\beta)\n$$\n问题指明了架构特性：\n- 峰值双精度吞吐量，$\\Pi_{\\text{peak}} = 3\\,\\mathrm{TFLOP/s} = 3 \\times 10^{12}$ FLOPs/秒。\n- 持续主内存带宽，$\\beta = 100\\,\\mathrm{GB/s} = 1 \\times 10^{11}$ 字节/秒。\n\n内存密集型和计算密集型区域之间的边界由机器平衡点（也称为屋脊点）$I_{\\text{ridge}}$ 决定。操作强度低于屋脊点的核是内存密集型的，而操作强度高于屋脊点的核是计算密集型的。屋脊点的计算公式为：\n$$\nI_{\\text{ridge}} = \\frac{\\Pi_{\\text{peak}}}{\\beta} = \\frac{3 \\times 10^{12} \\text{ FLOPs/s}}{1 \\times 10^{11} \\text{ Bytes/s}} = 30 \\text{ FLOPs/Byte}\n$$\n将该核的操作强度与机器平衡点进行比较：\n$$\nI \\approx 0.1221 \\text{ FLOPs/Byte} \\ll I_{\\text{ridge}} = 30 \\text{ FLOPs/Byte}\n$$\n由于该核的操作强度远低于机器的屋脊点，因此该核是重度**内存密集型**。这意味着其执行速度受限于从主内存获取数据的速率，而不是处理器执行计算的能力。在roofline图（性能与操作强度的对数-对数坐标图）上，该核位于屋顶的倾斜部分，远在屋脊点的左侧。其可达到的性能由内存带宽决定：\n$$\n\\Pi_{\\text{attainable}} = I \\cdot \\beta \\approx 0.1221 \\frac{\\text{FLOPs}}{\\text{Byte}} \\times 1 \\times 10^{11} \\frac{\\text{Bytes}}{\\text{s}} \\approx 1.221 \\times 10^{10} \\text{ FLOPs/s} = 0.01221 \\text{ TFLOP/s}\n$$\n这个可达到的性能仅为机器峰值能力 $3\\,\\mathrm{TFLOP/s}$ 的约 $0.41\\%$，这进一步凸显了内存瓶颈的严重性。\n\n第三，我们论证并行扩展性的影响并提出一种优化方法。\n\n该核的内存密集型特性对并行扩展性有重大影响。\n- 根据通常描述强扩展（固定问题规模）的**阿姆达尔定律**，总加速比受代码串行部分的限制。在共享内存环境中，内存总线是共享资源。随着使用的处理核心增多，它们会争用有限的内存带宽。这种争用就像程序的串行部分一样，形成了一个瓶颈，从而限制了可实现的加速比。所有核心的总性能不能超过 $I \\cdot \\beta \\approx 0.01221\\,\\mathrm{TFLOP/s}$ 的带宽限制。\n- 根据描述弱扩展（问题规模随处理器数量扩展）的**古斯塔夫森定律**，性能表现可能更好。在一个设计良好的、采用域分解的并行实现中，随着问题规模和核心数量的增加，大多数内存访问会变为对核心缓存或处理器NUMA（非一致性内存访问）节点的局部访问。这减少了对主内存总线或互连的争用，从而实现更好的可扩展性。然而，在每个子域内，根本性的低操作强度仍然是性能的限制因素。\n\n为了提高性能和并行可扩展性，必须增加操作强度 $I$。这需要修改该核，以提高算术运算与内存访问的比率。一种科学合理的优化方法是**即时重新计算几何因子 $f$**，而不是从内存中读取它。这是一种经典的时空权衡。\n\n对所提优化的分析：\n- **当前状态：** 该核每个单元读取 $6$ 个预计算的几何因子，贡献了 $6 \\times 8 \\text{ 字节} = 48$ 字节的总内存流量。\n- **优化：** 我们取消 $f$ 的存储和读取。取而代之的是，对每个面，我们计算 $f = A/d$，其中 $A$ 是面面积，$d$ 是单元中心距。这为每个面增加了 $1$ 次浮点除法运算。\n- **对算术运算的影响：** 每个面的浮点运算次数从 $7$ 次增加到 $7+1=8$ 次。每个单元的总浮点运算次数变为 $6 \\text{ 个面} \\times 8 \\text{ FLOPs/面} = 48$ FLOPs。\n- **对内存访问的影响：** 每个单元的内存流量减少了之前用于读取 $f$ 的 $48$ 字节。新的总数据移动量为 $344 - 48 = 296$ 字节。\n- **新的操作强度：** 新的操作强度 $I'$ 变为：\n$$\nI' = \\frac{48 \\text{ FLOPs}}{296 \\text{ Bytes}} \\approx 0.1622 \\text{ FLOPs/Byte}\n$$\n此优化将操作强度提高了约 $33\\%$（从 $0.1221$ 提高到 $0.1622$）。虽然该核仍然牢牢处于内存密集型区域（$0.1622 \\ll 30$），但这一改变使其在roofline图上向右移动。这将其可达到的性能上限提高到 $I' \\cdot \\beta \\approx 0.01622\\,\\mathrm{TFLOP/s}$，并使该核的算术密集度更高，从而提高了其效率和并行扩展的潜力。",
            "answer": "$$\n\\boxed{0.1221}\n$$"
        },
        {
            "introduction": "大规模模拟运行在多节点集群上，节点间的通信可能成为主要的性能限制因素。本练习将对一个完整的并行非线性求解器工作流进行建模，比较一个简单的顺序调度和一个重叠了计算与通信的高级调度。这个实践将展示高层次的算法设计对于在高性能计算环境中实现可扩展性和效率是何等关键。",
            "id": "3918527",
            "problem": "设计并实现一个完整的、可运行的程序，该程序为大规模电池模拟建模并评估一个可扩展的非线性求解工作流，重点是通过重叠任务来最大化多节点集群上的并行效率。该工作流使用牛顿-克雷洛夫（Newton–Krylov, NK）方法，其中牛顿法使用广义最小残差法（Generalized Minimal Residual, GMRES）以无雅可比（Jacobian-free）方法和块预处理（block-preconditioning）来求解线性化子问题。模型必须按如下方式构建。\n\n从以下基本基础开始：\n\n- 牛顿法：给定一个非线性残差映射 $F(u): \\mathbb{R}^N \\to \\mathbb{R}^N$，迭代更新为 $u_{k+1} = u_k + s_k$，其中 $s_k$ 求解 $J(u_k) s_k = -F(u_k)$，$J(u_k)$ 是雅可比矩阵。\n- 无雅可比牛顿-克雷洛夫（JFNK）：线性求解使用广义最小残差法（GMRES），而不显式构造 $J(u_k)$，通过 $J(u_k) v \\approx \\frac{F(u_k + \\epsilon v) - F(u_k)}{\\epsilon}$ 来评估雅可比-向量积，其中 $\\epsilon$ 很小。\n- 重叠调度原则：如果任务 $A$、$B$ 和 $C$ 在一个阶段内是独立的，则该阶段的墙上时钟时间等于 $\\max(T_A, T_B, T_C)$，而顺序调度的时间为 $T_A + T_B + T_C$。\n- 延迟-带宽通信模型：向一个邻居发送大小为 $m$ 字节的消息所需时间为 $T_{\\text{msg}} = \\alpha + \\frac{m}{B}$，其中 $\\alpha$ 是延迟，$B$ 是带宽。对于 $n_{\\text{nb}}$ 个邻居， $T_{\\text{comm}} = n_{\\text{nb}} \\left(\\alpha + \\frac{m}{B}\\right)$。\n- 并行分解：对于 $P$ 个节点和完美平衡的一维区域分解，每个节点处理 $N/P$ 个未知量。设每个节点的有效浮点吞吐量为 $f_{\\text{cpu}} \\cdot e$，其中 $f_{\\text{cpu}}$ 是每个节点的峰值浮点运算速度（FLOPS），$e \\in (0,1]$ 是效率。\n- 每单元工作量模型：残差评估每个单元消耗 $w_{\\text{res}}$ 次浮点运算（flops）；雅可比-向量积每个单元消耗 $w_{Jv}$ 次 flops；预处理器设置每个单元消耗 $w_{\\text{ps}}$ 次 flops；预处理器应用每个单元消耗 $w_{\\text{pa}}$ 次 flops；牛顿更新组装每个单元消耗 $w_{\\text{upd}}$ 次 flops。\n\n假设单次牛顿迭代的调度模型如下：\n\n- 每次牛顿迭代的顺序调度：\n  $$T_{\\text{seq,Newton}} = T_{\\text{res}} + T_{\\text{comm}} + T_{\\text{ps}} + k \\left(T_{Jv} + T_{\\text{comm}} + T_{\\text{pa}}\\right) + T_{\\text{upd}},$$\n  其中 $k$ 是 GMRES 迭代的次数。\n- 每次牛顿迭代的重叠调度（残差评估、预处理器设置和通信重叠；并且，在每次GMRES迭代中，雅可比-向量积与通信重叠）：\n  $$T_{\\text{ov,Newton}} = \\max\\left(T_{\\text{res}}, T_{\\text{comm}}, T_{\\text{ps}}\\right) + k \\left(T_{\\text{pa}} + \\max\\left(T_{Jv}, T_{\\text{comm}}\\right)\\right) + T_{\\text{upd}}.$$\n\n对于 $n_N$ 次牛顿迭代，总时间为 $T_{\\text{seq,total}} = n_N \\cdot T_{\\text{seq,Newton}}$ 和 $T_{\\text{ov,total}} = n_N \\cdot T_{\\text{ov,Newton}}$。计算加速比因子\n$$S = \\frac{T_{\\text{seq,total}}}{T_{\\text{ov,total}}}.$$\n\n所有时间量必须以秒为单位表示。每个节点的时间应按如下方式推导：\n\n- 每节点计算速率：$r = f_{\\text{cpu}} \\cdot e$。\n- 每节点局部未知量：$n_{\\text{local}} = N / P$。\n- 每节点计算时间：\n  $$T_{\\text{res}} = \\frac{n_{\\text{local}} \\cdot w_{\\text{res}}}{r}, \\quad T_{Jv} = \\frac{n_{\\text{local}} \\cdot w_{Jv}}{r}, \\quad T_{\\text{ps}} = \\frac{n_{\\text{local}} \\cdot w_{\\text{ps}}}{r}, \\quad T_{\\text{pa}} = \\frac{n_{\\text{local}} \\cdot w_{\\text{pa}}}{r}, \\quad T_{\\text{upd}} = \\frac{n_{\\text{local}} \\cdot w_{\\text{upd}}}{r}.$$\n- 每次交换的通信（每次残差或每次雅可比-向量积进行一次光环交换）：每个边界有 $g$ 个鬼单元（ghost cells），每个邻居的消息大小为 $m = g \\cdot 8$ 字节（假设为64位浮点值）。对于 $n_{\\text{nb}}$ 个邻居，\n  $$T_{\\text{comm}} = n_{\\text{nb}} \\left(\\alpha + \\frac{m}{B}\\right).$$\n\n实现一个程序，对于每个提供的测试用例，使用上述模型计算 $S$。使用双精度浮点运算。\n\n给你以下包含5个参数集的测试套件。对于每个用例，所有时间都必须以秒为单位计算，最终输出必须是无量纲的浮点加速比因子。每个用例提供：\n- $N$：未知量总数，\n- $P$：节点数，\n- $g$：每个边界的鬼单元数，\n- $n_{\\text{nb}}$：邻居数，\n- $w_{\\text{res}}$, $w_{Jv}$, $w_{\\text{ps}}$, $w_{\\text{pa}}$, $w_{\\text{upd}}$（每个单元的浮点运算次数），\n- $f_{\\text{cpu}}$（每个节点的 FLOPS），\n- $e$（效率，以小数表示），\n- $\\alpha$（秒），\n- $B$（字节/秒），\n- $k$：每个牛顿步骤的 GMRES 迭代次数，\n- $n_N$：牛顿迭代次数。\n\n测试用例：\n\n- 用例1（均衡计算，低延迟）：\n  - $N = 10000000$, $P = 32$, $g = 2$, $n_{\\text{nb}} = 2$\n  - $w_{\\text{res}} = 3000$, $w_{Jv} = 3000$, $w_{\\text{ps}} = 20000$, $w_{\\text{pa}} = 2000$, $w_{\\text{upd}} = 500$\n  - $f_{\\text{cpu}} = 2.0 \\times 10^{11}$, $e = 0.7$\n  - $\\alpha = 2.0 \\times 10^{-6}$, $B = 2.5 \\times 10^{10}$\n  - $k = 40$, $n_N = 5$\n\n- 用例2（高延迟，较低带宽）：\n  - $N = 10000000$, $P = 32$, $g = 2$, $n_{\\text{nb}} = 2$\n  - $w_{\\text{res}} = 3000$, $w_{Jv} = 3000$, $w_{\\text{ps}} = 20000$, $w_{\\text{pa}} = 2000$, $w_{\\text{upd}} = 500$\n  - $f_{\\text{cpu}} = 2.0 \\times 10^{11}$, $e = 0.7$\n  - $\\alpha = 1.0 \\times 10^{-3}$, $B = 5.0 \\times 10^{9}$\n  - $k = 40$, $n_N = 5$\n\n- 用例3（小域，多节点，通信主导）：\n  - $N = 32768$, $P = 64$, $g = 2$, $n_{\\text{nb}} = 2$\n  - $w_{\\text{res}} = 3000$, $w_{Jv} = 3000$, $w_{\\text{ps}} = 20000$, $w_{\\text{pa}} = 2000$, $w_{\\text{upd}} = 500$\n  - $f_{\\text{cpu}} = 2.0 \\times 10^{11}$, $e = 0.5$\n  - $\\alpha = 5.0 \\times 10^{-4}$, $B = 1.0 \\times 10^{10}$\n  - $k = 30$, $n_N = 4$\n\n- 用例4（单节点，无通信）：\n  - $N = 10000000$, $P = 1$, $g = 2$, $n_{\\text{nb}} = 0$\n  - $w_{\\text{res}} = 3000$, $w_{Jv} = 3000$, $w_{\\text{ps}} = 20000$, $w_{\\text{pa}} = 2000$, $w_{\\text{upd}} = 500$\n  - $f_{\\text{cpu}} = 2.0 \\times 10^{11}$, $e = 0.7$\n  - $\\alpha = 2.0 \\times 10^{-6}$, $B = 2.5 \\times 10^{10}$\n  - $k = 40$, $n_N = 5$\n\n- 用例5（重型预处理器，Krylov收敛性差）：\n  - $N = 10000000$, $P = 16$, $g = 2$, $n_{\\text{nb}} = 2$\n  - $w_{\\text{res}} = 4000$, $w_{Jv} = 4000$, $w_{\\text{ps}} = 100000$, $w_{\\text{pa}} = 10000$, $w_{\\text{upd}} = 500$\n  - $f_{\\text{cpu}} = 2.0 \\times 10^{11}$, $e = 0.8$\n  - $\\alpha = 2.0 \\times 10^{-6}$, $B = 2.5 \\times 10^{10}$\n  - $k = 200$, $n_N = 6$\n\n你的程序应生成一行输出，其中包含所有五个测试用例的加速比因子 $S$，形式为用方括号括起来的逗号分隔列表（例如，$[s_1,s_2,s_3,s_4,s_5]$）。将每个加速比表示为浮点数。不允许有其他输出。",
            "solution": "目标是为适用于大规模电池模拟的并行非线性求解器工作流构建并实现一个性能模型。该模型评估通过重叠计算和通信任务相对于纯顺序执行调度所实现的加速比 $S$。其底层数值方法是带有块预处理的无雅可比牛顿-克雷洛夫（Jacobian-Free Newton–Krylov, JFNK）算法。\n\n该模型建立在并行计算和数值分析的基本原则之上。我们首先定义系统和参数。问题总规模为 $N$ 个未知量，分布在 $P$ 个节点上，采用完美平衡的一维区域分解。因此，每个节点负责一个大小为 $n_{\\text{local}} = N/P$ 的局部问题。\n\n单个节点的计算性能由其有效浮点吞吐量 $r$ 来表征，定义为其理论峰值吞吐量 $f_{\\text{cpu}}$ 与其持续效率 $e$ 的乘积：\n$$r = f_{\\text{cpu}} \\cdot e$$\n$r$ 的单位是每秒浮点运算次数（FLOPS）。\n\n算法不同阶段的计算成本是基于每单元（或每未知量）建模的。工作量以每单元浮点运算次数（flops）给出，分为五个不同阶段：残差评估（$w_{\\text{res}}$）、雅可比-向量积（$w_{Jv}$）、预处理器设置（$w_{\\text{ps}}$）、预处理器应用（$w_{\\text{pa}}$）和最终解更新（$w_{\\text{upd}}$）。单个节点上每个阶段所需的时间（秒）是该阶段的总浮点运算次数除以有效吞吐量 $r$：\n$$T_{\\text{res}} = \\frac{n_{\\text{local}} \\cdot w_{\\text{res}}}{r}$$\n$$T_{Jv} = \\frac{n_{\\text{local}} \\cdot w_{Jv}}{r}$$\n$$T_{\\text{ps}} = \\frac{n_{\\text{local}} \\cdot w_{\\text{ps}}}{r}$$\n$$T_{\\text{pa}} = \\frac{n_{\\text{local}} \\cdot w_{\\text{pa}}}{r}$$\n$$T_{\\text{upd}} = \\frac{n_{\\text{local}} \\cdot w_{\\text{upd}}}{r}$$\n\n节点之间的通信对于更新域的光环（halo）或鬼（ghost）区域是必需的。对于一维分解，每个内部节点与 $n_{\\text{nb}}$ 个邻居通信（通常 $n_{\\text{nb}}=2$）。问题指定每次此类交换涉及大小为 $m$ 的消息，该大小由鬼单元数 $g$ 和双精度浮点数的大小（$8$ 字节）确定：$m = g \\cdot 8$。此通信所需的时间使用标准的延迟-带宽模型建模，其中 $\\alpha$ 是网络延迟，$B$ 是带宽：\n$$T_{\\text{comm}} = n_{\\text{nb}} \\left(\\alpha + \\frac{m}{B}\\right)$$\n这个时间代表一个单独的光环交换步骤，这在残差评估和克雷洛夫求解器内的每次雅可比-向量积中都是必需的。\n\n定义了这些组件时间后，我们可以根据两种不同的调度策略，组装出单次牛顿迭代的总墙上时钟时间。一次牛顿迭代包括一个初始设置阶段，然后是 $k$ 次 GMRES 线性求解器迭代，最后是一个最终更新。\n\n首先，顺序调度 $T_{\\text{seq,Newton}}$ 假设每个任务都按顺序执行，没有任何重叠。初始残差计算需要一次光环交换。在 GMRES 循环中， $k$ 次迭代中的每一次都需要一次雅可比-向量积（有其自己的光环交换）和一次预处理器应用。\n$$T_{\\text{seq,Newton}} = T_{\\text{res}} + T_{\\text{comm}} + T_{\\text{ps}} + k \\left(T_{Jv} + T_{\\text{comm}} + T_{\\text{pa}}\\right) + T_{\\text{upd}}$$\n\n其次，重叠调度 $T_{\\text{ov,Newton}}$ 利用了任务级并行性。在设置阶段，残差评估（$T_{\\text{res}}$）、其通信（$T_{\\text{comm}}$）和预处理器设置（$T_{\\text{ps}}$）被假定为独立的，可以重叠。此阶段的时间是三者中的最大值。在 $k$ 次 GMRES 迭代的每一次中，雅可比-向量积（$T_{Jv}$）及其相关的通信（$T_{\\text{comm}}$）也可以重叠。预处理器应用（$T_{\\text{pa}}$）被假定与此重叠块顺序执行。最终更新（$T_{\\text{upd}}$）保持顺序执行。\n$$T_{\\text{ov,Newton}} = \\max\\left(T_{\\text{res}}, T_{\\text{comm}}, T_{\\text{ps}}\\right) + k \\left(T_{\\text{pa}} + \\max\\left(T_{Jv}, T_{\\text{comm}}\\right)\\right) + T_{\\text{upd}}$$\n\n总模拟时间是每次牛顿迭代的时间乘以牛顿迭代次数 $n_N$。加速比因子 $S$ 是总顺序时间与总重叠时间的比率。\n$$S = \\frac{T_{\\text{seq,total}}}{T_{\\text{ov,total}}} = \\frac{n_N \\cdot T_{\\text{seq,Newton}}}{n_N \\cdot T_{\\text{ov,Newton}}} = \\frac{T_{\\text{seq,Newton}}}{T_{\\text{ov,Newton}}}$$\n因子 $n_N$ 会被约掉，因此加速比可以直接根据每次迭代的时间计算得出。以下程序实现了这个模型，用于为每个指定的测试用例计算 $S$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the speed-up factor for a set of test cases based on a performance\n    model of a parallel Newton-Krylov solver.\n    \"\"\"\n    \n    # Each dictionary in the list represents a distinct test case with all required parameters.\n    test_cases = [\n        # Case 1: balanced compute, low latency\n        {\n            \"N\": 10000000, \"P\": 32, \"g\": 2, \"n_nb\": 2,\n            \"w_res\": 3000, \"w_Jv\": 3000, \"w_ps\": 20000, \"w_pa\": 2000, \"w_upd\": 500,\n            \"f_cpu\": 2.0e11, \"e\": 0.7,\n            \"alpha\": 2.0e-6, \"B\": 2.5e10,\n            \"k\": 40, \"n_N\": 5\n        },\n        # Case 2: high latency, lower bandwidth\n        {\n            \"N\": 10000000, \"P\": 32, \"g\": 2, \"n_nb\": 2,\n            \"w_res\": 3000, \"w_Jv\": 3000, \"w_ps\": 20000, \"w_pa\": 2000, \"w_upd\": 500,\n            \"f_cpu\": 2.0e11, \"e\": 0.7,\n            \"alpha\": 1.0e-3, \"B\": 5.0e9,\n            \"k\": 40, \"n_N\": 5\n        },\n        # Case 3: tiny domain, many nodes, communication-dominated\n        {\n            \"N\": 32768, \"P\": 64, \"g\": 2, \"n_nb\": 2,\n            \"w_res\": 3000, \"w_Jv\": 3000, \"w_ps\": 20000, \"w_pa\": 2000, \"w_upd\": 500,\n            \"f_cpu\": 2.0e11, \"e\": 0.5,\n            \"alpha\": 5.0e-4, \"B\": 1.0e10,\n            \"k\": 30, \"n_N\": 4\n        },\n        # Case 4: single node, no communication\n        {\n            \"N\": 10000000, \"P\": 1, \"g\": 2, \"n_nb\": 0,\n            \"w_res\": 3000, \"w_Jv\": 3000, \"w_ps\": 20000, \"w_pa\": 2000, \"w_upd\": 500,\n            \"f_cpu\": 2.0e11, \"e\": 0.7,\n            \"alpha\": 2.0e-6, \"B\": 2.5e10,\n            \"k\": 40, \"n_N\": 5\n        },\n        # Case 5: heavy preconditioner, poor Krylov convergence\n        {\n            \"N\": 10000000, \"P\": 16, \"g\": 2, \"n_nb\": 2,\n            \"w_res\": 4000, \"w_Jv\": 4000, \"w_ps\": 100000, \"w_pa\": 10000, \"w_upd\": 500,\n            \"f_cpu\": 2.0e11, \"e\": 0.8,\n            \"alpha\": 2.0e-6, \"B\": 2.5e10,\n            \"k\": 200, \"n_N\": 6\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Unpack parameters from the case dictionary\n        N = case[\"N\"]\n        P = case[\"P\"]\n        g = case[\"g\"]\n        n_nb = case[\"n_nb\"]\n        w_res = case[\"w_res\"]\n        w_Jv = case[\"w_Jv\"]\n        w_ps = case[\"w_ps\"]\n        w_pa = case[\"w_pa\"]\n        w_upd = case[\"w_upd\"]\n        f_cpu = case[\"f_cpu\"]\n        e = case[\"e\"]\n        alpha = case[\"alpha\"]\n        B = case[\"B\"]\n        k = case[\"k\"]\n        # n_N is not needed as it cancels out in the speed-up ratio\n\n        # Step 1: Calculate intermediate values\n        r = f_cpu * e  # Effective FLOPS per node\n        n_local = N / P  # Local unknowns per node\n        m = g * 8.0  # Message size in bytes (8 bytes for a double)\n\n        # Step 2: Calculate time components\n        T_res = (n_local * w_res) / r\n        T_Jv = (n_local * w_Jv) / r\n        T_ps = (n_local * w_ps) / r\n        T_pa = (n_local * w_pa) / r\n        T_upd = (n_local * w_upd) / r\n        \n        # Communication time is zero if there are no neighbors\n        if n_nb == 0:\n            T_comm = 0.0\n        else:\n            T_comm = n_nb * (alpha + m / B)\n\n        # Step 3: Calculate total time per Newton iteration for both schedules\n        \n        # Sequential schedule time\n        T_seq_newton = T_res + T_comm + T_ps + k * (T_Jv + T_comm + T_pa) + T_upd\n        \n        # Overlapped schedule time\n        T_ov_newton = max(T_res, T_comm, T_ps) + k * (T_pa + max(T_Jv, T_comm)) + T_upd\n\n        # Step 4: Calculate speed-up\n        if T_ov_newton == 0:\n            # Avoid division by zero, although this case is unlikely with the given inputs\n            speedup = 1.0 \n        else:\n            speedup = T_seq_newton / T_ov_newton\n        \n        results.append(speedup)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}