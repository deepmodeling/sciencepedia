{
    "hands_on_practices": [
        {
            "introduction": "在我们能够为特定目标性能设计微观结构之前，我们必须首先能够预测一个*给定*微观结构的性能。这个基础性的“正向问题”是模拟驱动设计的基石。本练习将指导您实现一个有限体积法（FVM）求解器，用以计算非均质材料的有效电导率，这项技能可直接应用于预测电池电极的性能。",
            "id": "3921852",
            "problem": "给定一个二维体素化的微观结构，该结构表示在一个覆盖边长 $L_x = L_y = 1\\,\\mathrm{m}$ 的单位正方形域的 $N \\times N$ 方形网格上。每个体素（单元）都具有对应于两相之一的局部标量电导率 $k(\\mathbf{x})$，单位为 $\\mathrm{S/m}$。在沿 $x$ 方向施加电势差 $\\Delta \\phi = 1\\,\\mathrm{V}$、沿 $y$ 方向采用无通量（诺伊曼）边界条件的稳态直流电传导下，其控制方程为电流密度守恒和局部线性本构关系，即 $ \\nabla \\cdot \\mathbf{J} = 0$ 和 $\\mathbf{J} = -k(\\mathbf{x}) \\nabla \\phi(\\mathbf{x})$，其中 $ \\phi$ 是电势，$\\mathbf{J}$ 是电流密度。\n\n您的任务是实现有限体积法 (FVM) 来计算微观结构的有效电导率 $K^{\\text{eff}}$（单位：$\\mathrm{S/m}$），该值由宏观关系式 $I = K^{\\text{eff}} A \\frac{\\Delta \\phi}{L_x}$ 定义，其中 $I$ 是在施加电势差 $\\Delta \\phi$ 时流经左边界的总电流，$A$ 是垂直于 $x$ 方向的横截面积。在这种二维设置中，将域解释为在平面外方向上具有单位厚度，因此 $A = L_y \\times 1 = 1\\,\\mathrm{m}^2$。离散化必须在 $x=0$ 处强制施加狄利克雷边界条件 $\\phi = 0\\,\\mathrm{V}$，在 $x=1$ 处施加 $\\phi = 1\\,\\mathrm{V}$，并在 $y=0$ 和 $y=1$ 处施加诺伊曼（无通量）边界条件。使用内部面电导率的调和平均来近似相邻单元之间的通量。\n\n从静态极限下的电磁学基本定律和上述定义出发，在尺寸为 $h = 1/N$ 的均匀网格上推导并实现一个以单元为中心的 FVM 离散化，其中单元中心的坐标为 $(x_i, y_j) = \\left( \\frac{i+1/2}{N}, \\frac{j+1/2}{N} \\right)$，整数索引 $i,j \\in \\{0,\\dots,N-1\\}$。在您的算法中，对于电导率分别为 $k_1$ 和 $k_2$ 的单元之间的内部面，使用调和平均 $k_f = \\left( \\frac{1}{2} \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right) \\right)^{-1}$ 来计算面传导。对于 $x=0$ 和 $x=1$ 处的边界面，使用半单元距离 $h/2$ 和面面积 $h$ 施加狄利克雷条件，使得邻近边界的单元的边界面传导等于 $2\\,k$。在求解离散电势场 $\\phi_{i,j}$ 后，通过对边流通量求和来计算通过左边界的总电流 $I$，然后计算 $K^{\\text{eff}}$（单位：$\\mathrm{S/m}$）。\n\n此外，通过将计算出的 $K^{\\text{eff}}(h)$ 与在更精细网格（$h_{\\text{ref}} = 1/N_{\\text{ref}}$）上获得的参考解 $K^{\\text{eff}}(h_{\\text{ref}})$ 进行比较，来估计离散误差 $\\mathcal{E}(h)$ 作为网格尺寸 $h$ 的函数。报告绝对误差 $\\mathcal{E}(h) = \\left| K^{\\text{eff}}(h) - K^{\\text{eff}}(h_{\\text{ref}})\\right|$（单位：$\\mathrm{S/m}$）。\n\n定义以下测试套件，每个套件都将按指定的分辨率进行采样：\n\n- 测试用例 1（理想情况，异质夹杂物）：\n    - 几何形状：位于 $(0.5, 0.5)$ 中心，半径为 $r = 0.3$ 的圆形夹杂物。\n    - 相电导率：夹杂物相 $k_{\\text{in}} = 12.0\\,\\mathrm{S/m}$，基体相 $k_{\\text{out}} = 0.5\\,\\mathrm{S/m}$。\n    - 分辨率：$N \\in \\{16, 32, 64\\}$ 及参考分辨率 $N_{\\text{ref}} = 128$。\n\n- 测试用例 2（高电导率条带，接近逾渗阈值）：\n    - 几何形状：跨越整个高度的垂直条带，其中 $x \\in [0.4, 0.6]$。\n    - 相电导率：条带相 $k_{\\text{stripe}} = 50.0\\,\\mathrm{S/m}$，基体相 $k_{\\text{matrix}} = 1.0\\,\\mathrm{S/m}$。\n    - 分辨率：$N \\in \\{16, 32, 64\\}$ 及参考分辨率 $N_{\\text{ref}} = 128$。\n\n- 测试用例 3（均匀介质，验证边界情况）：\n    - 几何形状：整个区域为单相。\n    - 相电导率：均匀电导率 $k_{\\text{uni}} = 3.0\\,\\mathrm{S/m}$。\n    - 分辨率：$N \\in \\{8, 16, 32\\}$ 及参考分辨率 $N_{\\text{ref}} = 128$。\n\n对于每个测试用例，通过在单元中心对解析微观结构定义进行采样来构建 $k(\\mathbf{x})$。计算每个 $N$ 对应的 $K^{\\text{eff}}(h)$ 和参考值 $K^{\\text{eff}}(h_{\\text{ref}})$，然后计算每个 $N$ 对应的误差 $\\mathcal{E}(h)$。\n\n最终输出格式要求如下：您的程序应生成单行输出，其中包含一个结果列表，每个测试用例一个结果，其中每个测试用例的结果是一个以 $\\mathrm{S/m}$ 为单位的浮点数列表，排序为 $[K^{\\text{eff}}(h_{\\text{ref}}), K^{\\text{eff}}(h_1), \\mathcal{E}(h_1), K^{\\text{eff}}(h_2), \\mathcal{E}(h_2), K^{\\text{eff}}(h_3), \\mathcal{E}(h_3)]$。例如，整体输出应类似于 $[[\\dots],[\\dots],[\\dots]]$，所有浮点数均以 $\\mathrm{S/m}$ 表示，且无附加文本。\n\n您的程序必须是自包含的，不需要任何输入，并遵守指定的执行环境。$K^{\\text{eff}}$ 和 $\\mathcal{E}(h)$ 的所有计算和报告值都必须以 $\\mathrm{S/m}$ 为单位，并表示为十进制浮点数。",
            "solution": "该问题已根据指定标准进行验证。\n\n### 步骤 1：提取已知条件\n- **控制物理学**：稳态直流电传导，由电流密度守恒定律 $\\nabla \\cdot \\mathbf{J} = 0$ 和线性本构关系（欧姆定律） $\\mathbf{J} = -k(\\mathbf{x}) \\nabla \\phi(\\mathbf{x})$ 描述，其中 $\\phi$ 是电势，$\\mathbf{J}$ 是电流密度，$k(\\mathbf{x})$ 是局部标量电导率，单位为 $\\mathrm{S/m}$。\n- **域**：一个二维单位正方形，$L_x = L_y = 1\\,\\mathrm{m}$，具有单位厚度。横截面积为 $A = L_y \\times 1 = 1\\,\\mathrm{m}^2$。\n- **边界条件 (BCs)**：\n    - 垂直边界上的狄利克雷边界条件：$\\phi(x=0) = 0\\,\\mathrm{V}$ 和 $\\phi(x=1) = 1\\,\\mathrm{V}$。施加的电势差为 $\\Delta \\phi = 1\\,\\mathrm{V}$。\n    - 水平边界上的诺伊曼边界条件：无通量，即在 $y=0$ 和 $y=1$ 处 $\\frac{\\partial \\phi}{\\partial y} = 0$。\n- **离散化**：在均匀的 $N \\times N$ 网格上采用以单元为中心的有限体积法 (FVM)。网格尺寸为 $h = 1/N$。单元中心位于 $(x_i, y_j) = \\left( \\frac{i+1/2}{N}, \\frac{j+1/2}{N} \\right)$，其中 $i,j \\in \\{0, \\dots, N-1\\}$。\n- **通量近似**：\n    - 对于电导率分别为 $k_1$ 和 $k_2$ 的单元之间的内部面，面电导率 $k_f$ 是调和平均值：$k_f = \\left( \\frac{1}{2} \\left( \\frac{1}{k_1} + \\frac{1}{k_2} \\right) \\right)^{-1}$。\n    - 对于狄利克雷边界面，面传导被指定为 $2k$，其中 $k$ 是邻近边界的单元的电导率。\n- **目标量**：有效电导率 $K^{\\text{eff}}$，单位为 $\\mathrm{S/m}$，由宏观关系式 $I = K^{\\text{eff}} A \\frac{\\Delta \\phi}{L_x}$ 定义，其中 $I$ 是总电流。\n- **误差估计**：绝对误差 $\\mathcal{E}(h) = \\left| K^{\\text{eff}}(h) - K^{\\text{eff}}(h_{\\text{ref}})\\right|$，将相对于在更精细网格（$h_{\\text{ref}}=1/N_{\\text{ref}}$）上得到的参考解来计算。\n- **测试用例**：定义了三个具有特定几何形状、相电导率和分辨率的不同异质微观结构以供分析。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题在基础上是合理的。它描述了异质介质中的稳态电传导，这是一个经典的椭圆边值问题，由方程 $\\nabla \\cdot (k(\\mathbf{x}) \\nabla \\phi(\\mathbf{x})) = 0$ 控制。FVM 是解决此类问题的标准且鲁棒的数值方法。使用电导率的调和平均是一种物理上合适的选择，它确保了电流密度法向分量在单元界面上的连续性。\n- **适定性**：该问题是适定的。在封闭域上结合狄利克雷和诺伊曼边界条件，确保了电势场 $\\phi(\\mathbf{x})$ 存在唯一且稳定的解。目标量 $K^{\\text{eff}}$ 也由该解唯一确定。\n- **客观性和完整性**：该问题以精确、客观的语言陈述。所有参数、方程、边界条件和数值方案都已明确定义，使得问题自成体系且无歧义。各项定义内部一致。\n- **可行性**：物理参数和计算任务是现实且可行的。\n- **结构**：该问题结构良好，引导用户从第一性原理到数值实现和分析。它并非微不足道，需要对偏微分方程数值方法进行实质性应用。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。现在将推导并实现一个严谨的解法。\n\n### 有限体积法的推导\n\n通过结合守恒定律和本构关系，可以得到控制偏微分方程：\n$$\n\\nabla \\cdot (-k(\\mathbf{x}) \\nabla \\phi(\\mathbf{x})) = 0\n$$\n我们采用以单元为中心的有限体积法。我们将控制方程在一个控制体积 $\\Omega_{i,j}$ 上进行积分，该控制体积对应于以 $(x_i, y_j)$ 为中心的单元：\n$$\n\\int_{\\Omega_{i,j}} \\nabla \\cdot (-k \\nabla \\phi) \\, dV = 0\n$$\n应用散度定理，我们将体积分转换为对控制体积边界 $\\partial\\Omega_{i,j}$ 的面积分：\n$$\n\\oint_{\\partial\\Omega_{i,j}} (-k \\nabla \\phi) \\cdot \\mathbf{n} \\, dS = 0\n$$\n这个方程表达了电流守恒：流出任何控制体积的净电流为零。对于边长为 $h=1/N$ 且具有单位厚度的二维方形单元，该积分变为四个面（东、西、南、北）上的电流之和：\n$$\nI_e + I_w + I_n + I_s = 0\n$$\n其中 $I_f$ 是向外流经面 $f$ 的总电流。通过一个面的电流使用电势梯度的有限差分进行近似。对于分隔单元 $(i,j)$ 和单元 $(i+1,j)$ 的东面，电流为：\n$$\nI_e = -k_e A_e \\frac{\\phi_{i+1,j} - \\phi_{i,j}}{h}\n$$\n其中 $A_e = h \\times 1 = h$ 是面的面积。面电导率 $k_e$ 是相邻单元电导率 $k_{i,j}$ 和 $k_{i+1,j}$ 的调和平均值：\n$$\nk_e = \\frac{2 k_{i,j} k_{i+1,j}}{k_{i,j} + k_{i+1,j}}\n$$\n我们定义面传导 $g_f = k_f A_f / \\delta$，其中 $\\delta$ 是单元中心之间的距离。对于一个内部面，$\\delta=h$ 且 $A_f=h$，因此传导就是 $g_f=k_f$。通过内部单元 $(i,j)$ 四个面的电流为：\n- $I_e = g_e (\\phi_{i,j} - \\phi_{i+1,j})$\n- $I_w = g_w (\\phi_{i,j} - \\phi_{i-1,j})$\n- $I_n = g_n (\\phi_{i,j} - \\phi_{i,j+1})$\n- $I_s = g_s (\\phi_{i,j} - \\phi_{i,j-1})$\n\n将这些代入守恒方程，得到内部单元 $(i,j)$ 的离散代数方程：\n$$\n(g_e + g_w + g_n + g_s)\\phi_{i,j} - g_e \\phi_{i+1,j} - g_w \\phi_{i-1,j} - g_n \\phi_{i,j+1} - g_s \\phi_{i,j-1} = 0\n$$\n\n**边界条件：**\n1.  **$y=0$ 和 $y=1$ 处的诺伊曼（无通量）条件**：对于底部边界（$j=0$）的单元，穿过南面的通量为零，因此 $I_s=0$，这意味着 $g_s=0$。类似地，对于顶部边界（$j=N-1$）的单元，$I_n=0$，因此 $g_n=0$。\n\n2.  **$x=0$ 和 $x=1$ 处的狄利克雷（固定电势）条件**：对于左边界上的单元 $(0,j)$，电势固定为 $\\phi(x=0) = \\phi_L = 0\\,\\mathrm{V}$。从单元中心到边界的距离是 $h/2$。从边界流入单元的电流近似为：\n    $$\n    I_w = -k_{0,j} A_w \\frac{\\phi_{0,j} - \\phi_L}{h/2} = -k_{0,j} h \\frac{\\phi_{0,j} - 0}{h/2} = -2 k_{0,j} \\phi_{0,j}\n    $$\n    相应的西向传导为 $g_w = 2k_{0,j}$。单元 $(0,j)$ 的方程包含了这个已知的边界电势，该值为零。\n    对于右边界上的单元 $(N-1,j)$，电势固定为 $\\phi(x=1) = \\phi_R = 1\\,\\mathrm{V}$。类似的，东向传导为 $g_e = 2k_{N-1,j}$。流向边界的电流是 $I_e = g_e(\\phi_{N-1,j} - \\phi_R)$。单元 $(N-1,j)$ 的方程变为：\n    $$\n    (g_e + g_w + g_n + g_s)\\phi_{N-1,j} - g_w \\phi_{N-2,j} - g_n \\phi_{N-1,j+1} - g_s \\phi_{N-1,j-1} = g_e \\phi_R = g_e\n    $$\n    这在线性系统的右侧引入了一个非零源项。\n\n**方程组与求解：**\n将所有 $N \\times N$ 个单元的方程组合起来，会得到一个形式为 $M\\mathbf{\\Phi} = \\mathbf{b}$ 的大型稀疏线性方程组，其中 $\\mathbf{\\Phi}$ 是未知单元电势 $\\phi_{i,j}$ 的向量。矩阵 $M$ 是对角占优且对称的，这保证了解的唯一性。我们构建 $M$ 和 $\\mathbf{b}$，并使用稀疏线性代数求解器来求解 $\\mathbf{\\Phi}$。\n\n**有效电导率 $K^{\\text{eff}}$ 的计算：**\n在求解电势场 $\\mathbf{\\Phi}$ 后，我们计算流经整个域的总电流 $I$。根据守恒定律，在 $x=0$ 处进入的电流等于在 $x=1$ 处流出的电流。我们计算通过右边界流出的总电流：\n$$\nI = \\sum_{j=0}^{N-1} I_{e,j} = \\sum_{j=0}^{N-1} g_{e,j} (\\phi_R - \\phi_{N-1,j}) = \\sum_{j=0}^{N-1} 2 k_{N-1,j} (1 - \\phi_{N-1,j})\n$$\n问题通过 $I = K^{\\text{eff}} A \\frac{\\Delta \\phi}{L_x}$ 定义 $K^{\\text{eff}}$。给定 $A=1\\,\\mathrm{m}^2$，$L_x=1\\,\\mathrm{m}$ 和 $\\Delta\\phi=1\\,\\mathrm{V}$，这可简化为 $K^{\\text{eff}} = I$。因此，有效电导率在数值上等于上面计算出的总电流。对于电导率为 $k_{\\text{uni}}$ 的均匀介质，解析解为 $\\phi(x)=x$，我们的 FVM 格式能精确地恢复 $K^{\\text{eff}} = k_{\\text{uni}}$，这可以作为该方法的一个鲁棒性验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef generate_k_map(N, case_params):\n    \"\"\"\n    Generates the conductivity map k(x, y) for a given microstructure.\n    \"\"\"\n    h = 1.0 / N\n    x = np.linspace(h / 2, 1.0 - h / 2, N)\n    y = np.linspace(h / 2, 1.0 - h / 2, N)\n    xx, yy = np.meshgrid(x, y)\n\n    case_type = case_params['type']\n    \n    if case_type == 'circle':\n        k_in = case_params['k_in']\n        k_out = case_params['k_out']\n        center = case_params['center']\n        radius = case_params['radius']\n        mask = (xx - center[0])**2 + (yy - center[1])**2 = radius**2\n        k_map = np.full((N, N), k_out)\n        k_map[mask] = k_in\n    elif case_type == 'stripe':\n        k_stripe = case_params['k_stripe']\n        k_matrix = case_params['k_matrix']\n        x_range = case_params['x_range']\n        mask = (xx >= x_range[0])  (xx = x_range[1])\n        k_map = np.full((N, N), k_matrix)\n        k_map[mask] = k_stripe\n    elif case_type == 'uniform':\n        k_uni = case_params['k_uni']\n        k_map = np.full((N, N), k_uni)\n    else:\n        raise ValueError(\"Unknown case type\")\n        \n    return k_map\n\ndef compute_Keff(N, k_map):\n    \"\"\"\n    Computes the effective conductivity of a microstructure using FVM.\n    \"\"\"\n    num_vars = N * N\n    M = lil_matrix((num_vars, num_vars))\n    b = np.zeros(num_vars)\n\n    # Flatten conductivity map for easier indexing\n    k_flat = k_map.flatten(order='C') # Row-major\n\n    for j in range(N):\n        for i in range(N):\n            p = j * N + i  # Linear index for cell (i, j)\n            k_center = k_map[j, i]\n            \n            # Diagonal term accumulator\n            diag_sum = 0.0\n            \n            # South neighbor (j-1)\n            if j > 0:\n                k_s = k_map[j-1, i]\n                g_s = (2.0 * k_center * k_s) / (k_center + k_s)\n                M[p, p - N] = g_s\n                diag_sum += g_s\n            # else: no-flux (gs=0)\n            \n            # North neighbor (j+1)\n            if j  N - 1:\n                k_n = k_map[j+1, i]\n                g_n = (2.0 * k_center * k_n) / (k_center + k_n)\n                M[p, p + N] = g_n\n                diag_sum += g_n\n            # else: no-flux (gn=0)\n            \n            # West neighbor (i-1)\n            if i > 0:\n                k_w = k_map[j, i-1]\n                g_w = (2.0 * k_center * k_w) / (k_center + k_w)\n                M[p, p - 1] = g_w\n                diag_sum += g_w\n            else: # i=0, Dirichlet boundary phi=0\n                g_w = 2.0 * k_center\n                diag_sum += g_w\n                # Source term is g_w * phi_L = g_w * 0 = 0\n            \n            # East neighbor (i+1)\n            if i  N - 1:\n                k_e = k_map[j, i+1]\n                g_e = (2.0 * k_center * k_e) / (k_center + k_e)\n                M[p, p + 1] = g_e\n                diag_sum += g_e\n            else: # i=N-1, Dirichlet boundary phi=1\n                g_e = 2.0 * k_center\n                diag_sum += g_e\n                b[p] = -g_e * 1.0\n            \n            M[p, p] = -diag_sum\n\n    # Solve the linear system\n    M_csc = M.tocsc()\n    phi_vec = spsolve(M_csc, b)\n    phi_map = phi_vec.reshape((N, N))\n\n    # Calculate total current and K_eff\n    k_right_boundary = k_map[:, N-1]\n    phi_right_boundary = phi_map[:, N-1]\n    \n    # I = sum(g_e * (phi_R - phi_cell)) = sum(2*k * (1 - phi))\n    # With L=1, A=1, dPhi=1, K_eff = I\n    K_eff = np.sum(2.0 * k_right_boundary * (1.0 - phi_right_boundary))\n    \n    return K_eff\n\ndef solve():\n    test_suite = [\n        {\n            'params': {'type': 'circle', 'k_in': 12.0, 'k_out': 0.5, 'center': (0.5, 0.5), 'radius': 0.3},\n            'resolutions': [16, 32, 64],\n            'ref_resolution': 128\n        },\n        {\n            'params': {'type': 'stripe', 'k_stripe': 50.0, 'k_matrix': 1.0, 'x_range': [0.4, 0.6]},\n            'resolutions': [16, 32, 64],\n            'ref_resolution': 128\n        },\n        {\n            'params': {'type': 'uniform', 'k_uni': 3.0},\n            'resolutions': [8, 16, 32],\n            'ref_resolution': 128\n        }\n    ]\n\n    all_results = []\n\n    for test_case in test_suite:\n        params = test_case['params']\n        resolutions = test_case['resolutions']\n        N_ref = test_case['ref_resolution']\n        \n        # Compute reference solution\n        k_map_ref = generate_k_map(N_ref, params)\n        K_eff_ref = compute_Keff(N_ref, k_map_ref)\n        \n        case_results = [K_eff_ref]\n        \n        # Compute for other resolutions and calculate errors\n        for N in resolutions:\n            k_map = generate_k_map(N, params)\n            K_eff = compute_Keff(N, k_map)\n            error = abs(K_eff - K_eff_ref)\n            case_results.extend([K_eff, error])\n            \n        all_results.append(case_results)\n\n    # Format output as a list of lists of floats\n    print(all_results)\n\nsolve()\n```"
        },
        {
            "introduction": "本练习将从正向模拟转向一个真正的逆向问题。我们将使用综合的实验数据（来自电化学阻抗谱）来推断一个关键的微观结构属性——曲折度。您将实现一种强大的技术，该技术涉及稀疏正则化，以解决寻找弛豫时间分布（DRT）的逆向问题，并将其与电极的物理结构联系起来。",
            "id": "3921846",
            "problem": "要求您实现一个逆向设计程序，该程序从电化学阻抗数据中恢复稀疏的弛豫时间分布 (DRT)，然后将恢复的主导扩散时间常数映射到多孔电池电极的微观结构曲折度和孔隙率。弛豫时间分布 (DRT) 将阻抗响应的虚部表示为标准弛豫核的叠加。目标是从合成阻抗数据中恢复稀疏的 DRT，并利用恢复的时间常数来估计不同孔隙率下的曲折度。\n\n基本物理原理和定义如下：\n- 通过电化学阻抗谱 (EIS) 测量的电极过程可以用特征弛豫时间的分布来表示。阻抗响应的虚部由以下公式建模：\n$$\nZ''(\\omega) = \\int_{-\\infty}^{+\\infty} \\gamma(\\tau) \\, \\frac{\\omega \\tau}{1 + (\\omega \\tau)^2} \\, d\\ln \\tau,\n$$\n其中 $Z''(\\omega)$ 是角频率 $\\omega$ 下的阻抗虚部，$\\gamma(\\tau)$ 是描述弛豫时间 $\\tau$ 处 DRT 幅值的非负度量，而 $\\frac{\\omega \\tau}{1 + (\\omega \\tau)^2}$ 是用于一阶过程的标准核函数。我们将 $\\gamma(\\tau)$ 限制为非负，这与无源耗散过程一致。\n- 在多孔介质的均质化和有效介质理论下，有效扩散系数 $D_{\\text{eff}}$ 与体扩散系数 $D$、孔隙率 $\\varepsilon$（无量纲分数）和曲折度 $\\mathcal{T}$（无量纲）通过以下关系式关联：\n$$\nD_{\\text{eff}} = \\frac{D \\, \\varepsilon}{\\mathcal{T}}.\n$$\n- 跨越厚度为 $L$ 的电极进行传输的主导扩散相关弛豫时间 $\\tau_{\\text{diff}}$ 遵循以下标度关系：\n$$\n\\tau_{\\text{diff}} \\approx \\frac{L^2}{D_{\\text{eff}}} = \\frac{L^2 \\, \\mathcal{T}}{D \\, \\varepsilon}.\n$$\n因此，根据恢复的扩散时间常数估算出的曲折度为：\n$$\n\\widehat{\\mathcal{T}} = \\frac{\\tau_{\\text{diff}} \\, D \\, \\varepsilon}{L^2}.\n$$\n\n在 $\\ln \\tau$ 的均匀网格上离散化 DRT 的逆问题。设 $\\{\\tau_j\\}_{j=1}^{N_\\tau}$ 为以秒为单位的弛豫时间网格，$\\{\\omega_i\\}_{i=1}^{N_\\omega}$ 为以弧度/秒为单位的角频率网格。定义线性算子矩阵 $K \\in \\mathbb{R}^{N_\\omega \\times N_\\tau}$，其元素为：\n$$\nK_{ij} = \\frac{\\omega_i \\tau_j}{1 + (\\omega_i \\tau_j)^2}.\n$$\n给定数据 $y_i = Z''(\\omega_i)$，求解离散化 DRT 幅值 $\\gamma \\in \\mathbb{R}^{N_\\tau}$ 的凸优化问题：\n$$\n\\min_{\\gamma \\ge 0} \\; \\frac{1}{2} \\left\\| K \\gamma - y \\right\\|_2^2 + \\lambda \\left\\| \\gamma \\right\\|_1,\n$$\n其中 $\\lambda  0$ 用于促进稀疏性。实现带有非负性投影的近端梯度（迭代软阈值算法）方案来解决此问题。\n\n恢复 $\\gamma$ 后，检测峰值，并选择检测到的峰值中最大的弛豫时间作为主导扩散相关时间常数 $\\tau_{\\text{diff}}$。使用该值通过以下公式估算曲折度：\n$$\n\\widehat{\\mathcal{T}} = \\frac{\\tau_{\\text{diff}} \\, D \\, \\varepsilon}{L^2}.\n$$\n\n单位和精度要求：\n- 所有弛豫时间 $\\tau$ 必须以秒为单位。\n- 频率输入以赫兹为单位；通过 $\\omega = 2\\pi f$ 转换为以弧度/秒为单位的角频率。\n- 厚度 $L$ 必须以米为单位，体扩散系数 $D$ 以 $\\mathrm{m}^2/\\mathrm{s}$ 为单位，孔隙率 $\\varepsilon$ 和曲折度 $\\mathcal{T}$ 是无量纲的。\n- 输出的曲折度估计值必须表示为浮点值（不带百分号）。\n\n测试套件规范：\n您必须通过将在已知时间常数和幅值处的少量理想化 DRT 峰值相加来生成合成的 $Z''(\\omega)$：\n$$\nZ''(\\omega) = \\sum_{k=1}^{K} a_k \\frac{\\omega \\tau_k}{1 + (\\omega \\tau_k)^2},\n$$\n其中 $a_k \\ge 0$ 且 $\\tau_k  0$。在每个测试案例中，添加独立的零均值高斯噪声，其标准差等于 $Z''(\\omega)$ 最大幅值的 $0.005$ 倍，以模拟测量噪声。\n\n对所有测试案例，使用一个在 $f \\in [10^{-5}, 10^{3}]$ 赫兹范围内的均匀对数频率网格，包含 $N_\\omega = 60$ 个点。使用一个在 $\\tau \\in [10^{-4}, 10^{5}]$ 秒范围内的 DRT 网格，包含 $N_\\tau = 200$ 个点，该网格在 $\\ln \\tau$ 上是均匀的。\n\n提供三个测试案例：\n\n- 案例 A（一般情况）：\n    - $L = 100 \\times 10^{-6}$ 米，$\\varepsilon = 0.4$，$D = 1 \\times 10^{-10}$ $\\mathrm{m}^2/\\mathrm{s}$。\n    - 真实曲折度 $\\mathcal{T}_{\\text{true}} = 2.5$。\n    - 扩散时间常数 $\\tau_{\\text{diff,true}} = \\dfrac{L^2 \\mathcal{T}_{\\text{true}}}{D \\varepsilon}$。\n    - 峰值：$(\\tau, a)$ 等于 $(1, 0.3)$、$(\\tau_{\\text{diff,true}}, 0.5)$ 和 $(50, 0.1)$。\n\n- 案例 B（高孔隙率）：\n    - $L = 100 \\times 10^{-6}$ 米，$\\varepsilon = 0.8$，$D = 1 \\times 10^{-10}$ $\\mathrm{m}^2/\\mathrm{s}$。\n    - 真实曲折度 $\\mathcal{T}_{\\text{true}} = 1.5$。\n    - 扩散时间常数 $\\tau_{\\text{diff,true}} = \\dfrac{L^2 \\mathcal{T}_{\\text{true}}}{D \\varepsilon}$。\n    - 峰值：$(\\tau, a)$ 等于 $(0.8, 0.25)$、$(\\tau_{\\text{diff,true}}, 0.5)$ 和 $(30, 0.15)$。\n\n- 案例 C（低孔隙率，较厚电极，长时间边界情况）：\n    - $L = 150 \\times 10^{-6}$ 米，$\\varepsilon = 0.2$，$D = 1 \\times 10^{-10}$ $\\mathrm{m}^2/\\mathrm{s}$。\n    - 真实曲折度 $\\mathcal{T}_{\\text{true}} = 4.0$。\n    - 扩散时间常数 $\\tau_{\\text{diff,true}} = \\dfrac{L^2 \\mathcal{T}_{\\text{true}}}{D \\varepsilon}$。\n    - 峰值：$(\\tau, a)$ 等于 $(2, 0.3)$、$(\\tau_{\\text{diff,true}}, 0.6)$ 和 $(70, 0.1)$。\n\n您的程序必须：\n- 构建核矩阵 $K$，为每个案例合成带噪声的 $Z''(\\omega)$，使用近端梯度迭代法求解带有所述约束的稀疏反演问题，检测恢复的 $\\gamma(\\tau)$ 的峰值，选择检测到的最大 $\\tau$ 作为 $\\tau_{\\text{diff}}$，并使用上述公式为每个案例计算 $\\widehat{\\mathcal{T}}$。\n- 使用一个与问题规模相适应的正则化强度 $\\lambda$（例如，基于 $K^\\top y$ 的无穷范数），以及一个基于梯度 Lipschitz 常数（即 $K^\\top K$ 的谱范数）的步长。\n- 通过为噪声生成使用固定的随机种子来确保可复现性。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个测试案例的估计曲折度，格式为逗号分隔的列表，并用方括号括起来，顺序为案例 A、案例 B、案例 C。例如，输出必须如下所示：\n$$\n[\\widehat{\\mathcal{T}}_{\\mathrm{A}},\\widehat{\\mathcal{T}}_{\\mathrm{B}},\\widehat{\\mathcal{T}}_{\\mathrm{C}}].\n$$\n每个条目必须是浮点值。",
            "solution": "所提出的问题是有效的。这是一个在计算材料科学和电化学领域内具有科学依据、适定且客观的问题。它要求实现一个逆向设计工作流，从合成的电化学阻抗谱 (EIS) 数据中估算电池电极的一个关键微观结构参数，即曲折度 $\\mathcal{T}$。该方法基于弛豫时间分布 (DRT) 的恢复及其与物理传输现象的联系。所有必需的物理模型、数学公式、数值参数和测试案例均已提供，构成了一个完整且一致的规范。\n\n解决方案是通过遵循一系列从第一性原理推导出的步骤来制定的。首先，我们建立连接可测量的阻抗数据与底层材料属性的物理和数学模型。其次，我们构建恢复 DRT 的逆问题。第三，我们详细说明用于解决此逆问题的数值算法。最后，我们描述从数值解中提取目标物理参数的过程。\n\n基本的物理模型是将阻抗虚部 $Z''(\\omega)$ 表示为对弛豫时间分布 $\\gamma(\\tau)$ 的积分。这表示为：\n$$\nZ''(\\omega) = \\int_{-\\infty}^{+\\infty} \\gamma(\\tau) \\, K(\\omega, \\tau) \\, d\\ln \\tau, \\quad \\text{with } K(\\omega, \\tau) = \\frac{\\omega \\tau}{1 + (\\omega \\tau)^2}\n$$\n这里，$\\omega$ 是角频率，$\\tau$ 是弛豫时间，核函数 $K(\\omega, \\tau)$ 代表单个一阶德拜弛豫过程的响应。函数 $\\gamma(\\tau)$ 是一个非负分布，它量化了在特征时间 $\\tau$ 发生的各种过程的贡献。\n\n与电极微观结构的联系是通过主导扩散过程建立的。对于厚度为 $L$ 的多孔电极，活性物质的有效扩散系数 $D_{\\text{eff}}$ 通过有效介质关系式与它的体扩散系数 $D$、电极孔隙率 $\\varepsilon$ 和曲折度 $\\mathcal{T}$ 相关联：\n$$\nD_{\\text{eff}} = \\frac{D \\varepsilon}{\\mathcal{T}}\n$$\n曲折度 $\\mathcal{T}$ 是一个大于或等于 1 的无量纲因子，它解释了离子必须通过多孔结构所走的曲折路径，使得有效路径长度比电极厚度更长。跨越此厚度的扩散特征时间尺度 $\\tau_{\\text{diff}}$ 由以下标度律给出：\n$$\n\\tau_{\\text{diff}} \\approx \\frac{L^2}{D_{\\text{eff}}} = \\frac{L^2 \\mathcal{T}}{D \\varepsilon}\n$$\n通过反转这个关系，如果我们能从阻抗数据中确定 $\\tau_{\\text{diff}}$，就可以得到曲折度的估计值 $\\widehat{\\mathcal{T}}$：\n$$\n\\widehat{\\mathcal{T}} = \\frac{\\tau_{\\text{diff}} D \\varepsilon}{L^2}\n$$\n问题的核心在于从一组离散的带噪声的 $Z''(\\omega)$ 测量值中恢复 $\\gamma(\\tau)$。这是一个典型的不适定逆问题。为了解决这个问题，我们首先离散化该积分方程。我们定义一个包含 $N_\\omega$ 个角频率的网格 $\\{\\omega_i\\}_{i=1}^{N_\\omega}$ 和一个包含 $N_\\tau$ 个弛豫时间的网格 $\\{\\tau_j\\}_{j=1}^{N_\\tau}$（在对数域上均匀分布）。测量值为 $y_i = Z''(\\omega_i)$，我们寻求离散的 DRT 幅值 $\\gamma_j = \\gamma(\\tau_j)$。这将积分方程转换为一个线性方程组：\n$$\ny \\approx K \\gamma\n$$\n其中 $y \\in \\mathbb{R}^{N_\\omega}$，$\\gamma \\in \\mathbb{R}^{N_\\tau}$，而 $K \\in \\mathbb{R}^{N_\\omega \\times N_\\tau}$ 是核矩阵，其元素为 $K_{ij} = \\frac{\\omega_i \\tau_j}{1 + (\\omega_i \\tau_j)^2}$。\n\n由于问题的不适定性，一个朴素的最小二乘解会非常不稳定，并被噪声主导。我们引入正则化来获得一个稳定且具有物理意义的解。问题指定了 L1 范数惩罚项，这会促进 $\\gamma$ 的稀疏解。这反映了电化学响应通常由少数几个不同的过程主导的物理直觉。物理耗散率的非负性要求约束 $\\gamma_j \\ge 0$。最终的优化问题是一个非负 LASSO 问题：\n$$\n\\min_{\\gamma \\ge 0} \\; \\frac{1}{2} \\left\\| K \\gamma - y \\right\\|_2^2 + \\lambda \\left\\| \\gamma \\right\\|_1\n$$\n其中 $\\lambda  0$ 是正则化参数，用于平衡数据保真度与稀疏性。\n\n这个凸优化问题使用近端梯度法来解决，具体来说是迭代软阈值算法 (ISTA)。该算法迭代地对最小二乘项执行梯度下降步骤，然后执行一个强制稀疏性和非负性的近端映射步骤。更新规则是：\n$$\n\\gamma^{(k+1)} = \\text{prox}_{\\alpha \\lambda g}(\\gamma^{(k)} - \\alpha \\nabla f(\\gamma^{(k)}))\n$$\n其中 $f(\\gamma) = \\frac{1}{2} \\| K \\gamma - y \\|_2^2$ 且 $g(\\gamma)$ 包含了 L1 范数和非负性。梯度为 $\\nabla f(\\gamma) = K^\\top (K\\gamma - y)$。对于参数 $z$，组合 L1 和非负性惩罚的近端算子是 $\\text{prox}(z) = \\max(0, z - \\alpha\\lambda)$。因此，完整的更新是：\n$$\n\\gamma^{(k+1)} = \\max\\left(0, \\gamma^{(k)} - \\alpha K^\\top(K\\gamma^{(k)} - y) - \\alpha\\lambda\\right)\n$$\n等等，近端更新被推导为 $\\max(0, z - \\alpha\\lambda)$，其中 $z = \\gamma^{(k)} - \\alpha \\nabla f(\\gamma^{(k)})$。让我们纠正一下。设 $z^{(k)} = \\gamma^{(k)} - \\alpha K^\\top(K\\gamma^{(k)} - y)$。更新是 $\\gamma^{(k+1)} = \\max(0, z^{(k)} - \\alpha\\lambda)$。这个实现是正确的。选择步长 $\\alpha$ 以确保收敛，通常 $\\alpha \\le 1/L$，其中 $L$ 是梯度 $\\nabla f$ 的 Lipschitz 常数。该常数是 $K^\\top K$ 的最大特征值，它等于 $K$ 的最大奇异值的平方，即 $L = \\sigma_{\\text{max}}(K)^2$。正则化参数 $\\lambda$ 根据数据进行缩放，具体来说是 $\\lambda \\propto \\|K^\\top y\\|_{\\infty}$，以适应不同的问题规模。\n\n经过足够次数的迭代后，算法收敛到一个稀疏的非负向量 $\\gamma$。从这个恢复的 DRT 中，我们识别出峰值。根据问题规范，与检测到的峰值对应的最大弛豫时间 $\\tau$ 被识别为扩散时间常数 $\\tau_{\\text{diff}}$。然后，在最后一步中使用这个估计的 $\\tau_{\\text{diff}}$ 来计算曲折度估计值 $\\widehat{\\mathcal{T}}$。将整个程序应用于三个具有不同物理参数的独立测试案例，并报告所得的曲折度估计值。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import find_peaks\n\ndef inverse_design_tortuosity():\n    \"\"\"\n    Solves for electrode tortuosity from synthetic impedance data.\n\n    This function implements the full workflow described in the problem statement.\n    It iterates through three test cases, and for each case:\n    1. Generates synthetic noisy impedance data based on true physical parameters.\n    2. Constructs the DRT kernel matrix.\n    3. Solves the sparse, non-negative regularized inverse problem using ISTA\n       to recover the Distribution of Relaxation Times (DRT).\n    4. Identifies peaks in the recovered DRT.\n    5. Selects the diffusion time constant based on the specified rule.\n    6. Computes the estimated tortuosity.\n    Finally, it prints the results for all cases in the required format.\n    \"\"\"\n\n    # --- Global Parameters ---\n    # Grids\n    N_FREQ = 60\n    N_TAU = 200\n    FREQ_MIN, FREQ_MAX = 1e-5, 1e3  # Hz\n    TAU_MIN, TAU_MAX = 1e-4, 1e5    # s\n\n    # Algorithm parameters\n    ISTA_ITERATIONS = 2000\n    LAMBDA_SCALE_FACTOR = 0.02\n    PEAK_HEIGHT_RATIO = 0.05\n\n    # Reproducibility\n    RANDOM_SEED = 42\n    np.random.seed(RANDOM_SEED)\n\n    # --- Grid Setup ---\n    # Frequencies (f in Hz, omega in rad/s)\n    f_grid = np.logspace(np.log10(FREQ_MIN), np.log10(FREQ_MAX), N_FREQ)\n    omega_grid = 2 * np.pi * f_grid\n    \n    # Relaxation times (tau in s)\n    tau_grid = np.logspace(np.log10(TAU_MIN), np.log10(TAU_MAX), N_TAU)\n\n    # --- Test Cases ---\n    test_cases = [\n        {\n            \"name\": \"Case A (general)\",\n            \"L\": 100e-6, \"epsilon\": 0.4, \"D\": 1e-10, \"T_true\": 2.5,\n            \"base_peaks\": [(1.0, 0.3), (50.0, 0.1)]\n        },\n        {\n            \"name\": \"Case B (high porosity)\",\n            \"L\": 100e-6, \"epsilon\": 0.8, \"D\": 1e-10, \"T_true\": 1.5,\n            \"base_peaks\": [(0.8, 0.25), (30.0, 0.15)]\n        },\n        {\n            \"name\": \"Case C (low porosity, thick)\",\n            \"L\": 150e-6, \"epsilon\": 0.2, \"D\": 1e-10, \"T_true\": 4.0,\n            \"base_peaks\": [(2.0, 0.3), (70.0, 0.1)]\n        }\n    ]\n    \n    estimated_tortuosities = []\n\n    # --- Main Loop ---\n    for case in test_cases:\n        L, epsilon, D, T_true = case[\"L\"], case[\"epsilon\"], case[\"D\"], case[\"T_true\"]\n\n        # 1. Calculate true diffusion time and complete the peak list\n        tau_diff_true = (L**2 * T_true) / (D * epsilon)\n        true_peaks = case[\"base_peaks\"] + [(tau_diff_true, 0.5 if case[\"name\"] != \"Case C (low porosity, thick)\" else 0.6)]\n\n        # 2. Generate synthetic impedance data Z''\n        Z_imag_true = np.zeros_like(omega_grid)\n        for tau_k, a_k in true_peaks:\n            Z_imag_true += a_k * (omega_grid * tau_k) / (1 + (omega_grid * tau_k)**2)\n        \n        noise_std = 0.005 * np.max(np.abs(Z_imag_true))\n        noise = np.random.normal(0, noise_std, size=Z_imag_true.shape)\n        y = Z_imag_true + noise\n\n        # 3. Construct kernel matrix K\n        K = (omega_grid[:, np.newaxis] * tau_grid[np.newaxis, :]) / \\\n            (1 + (omega_grid[:, np.newaxis] * tau_grid[np.newaxis, :])**2)\n\n        # 4. Set ISTA hyperparameters\n        # Step size (alpha) based on Lipschitz constant\n        s_max = np.linalg.svd(K, compute_uv=False)[0]\n        lipschitz_const = s_max**2\n        alpha = 1.0 / lipschitz_const\n        \n        # Regularization parameter (lambda) scaled by data\n        lambda_reg = LAMBDA_SCALE_FACTOR * np.linalg.norm(K.T @ y, ord=np.inf)\n\n        # 5. Solve for DRT (gamma) using ISTA\n        gamma = np.zeros(N_TAU)\n        for _ in range(ISTA_ITERATIONS):\n            grad = K.T @ (K @ gamma - y)\n            z = gamma - alpha * grad\n            gamma = np.maximum(z - alpha * lambda_reg, 0)\n        \n        # 6. Peak detection in the recovered DRT\n        peak_height_threshold = PEAK_HEIGHT_RATIO * np.max(gamma)\n        peak_indices, _ = find_peaks(gamma, height=peak_height_threshold)\n        \n        if len(peak_indices) == 0:\n            # Fallback if no peaks are detected (unlikely but robust)\n            # Use the tau corresponding to the max gamma value\n            tau_diff_est = tau_grid[np.argmax(gamma)]\n        else:\n            # 7. Select largest relaxation time among detected peaks\n            detected_taus = tau_grid[peak_indices]\n            tau_diff_est = np.max(detected_taus)\n\n        # 8. Compute estimated tortuosity\n        T_hat = (tau_diff_est * D * epsilon) / (L**2)\n        estimated_tortuosities.append(T_hat)\n\n    # --- Final Output ---\n    print(f\"[{','.join([f'{val:.6f}' for val in estimated_tortuosities])}]\")\n\nif __name__ == '__main__':\n    inverse_design_tortuosity()\n```"
        },
        {
            "introduction": "计算模拟总是在有限大小的域上执行，但我们感兴趣的是体材料的性质。本练习通过实现一个数据驱动的外推程序，解决了有限尺寸偏差这一关键问题。您将学习如何使用来自多个不同尺寸模拟的结果来估计真实的无限域属性并量化不确定性，这是实现可靠逆向设计的关键一步。",
            "id": "3921820",
            "problem": "考虑在自动化电池设计与仿真中，为实现目标输运性质而进行的多孔电极微结构逆向设计。对于各向同性介质，将曲折度（记为 $\\tau$）定义为无量纲比率 $\\tau = D_0 / D_{\\mathrm{eff}}$，其中 $D_0$ 是参考自由空间扩散系数，$D_{\\mathrm{eff}}$ 是通过对代表性体积单元上的稳态扩散方程 $-\\nabla \\cdot (D(\\mathbf{x}) \\nabla c) = 0$ 进行均质化得到的有效扩散系数。在实践中，$\\tau$ 是通过在具有线性尺寸 $L$ 的有限样本上使用周期性边界条件并对通量进行空间平均来估计的，这会引入有限尺寸偏差。在平稳随机介质的标准混合与遍历性假设下，由于样本边界处长程相关的截断，$\\tau(L)$ 中的偏差在 $L$ 上存在一个领头阶的代数衰减。\n\n以此为基础，假设对于尺寸为 $L$ 的立方体样本，曲折度估计量存在以下渐近测量模型：\n$$\n\\tau(L) = \\tau_\\infty + c\\,L^{-p} + \\varepsilon,\n$$\n其中 $\\tau_\\infty$ 是无限域曲折度（逆向设计的目标量），$c$ 是一个未知系数，$p  0$ 是一个由相关性衰减和边界条件决定的未知指数，$\\varepsilon$ 是一个代表数值求解器噪声和样本间波动的零均值随机误差，被建模为标准差为 $\\sigma$ 的独立同分布高斯随机变量。所有曲折度和 $\\sigma$ 都是无量纲的；长度 $L$ 使用任意但一致的长度单位。\n\n您的任务是仅使用上述假设以及来自均质化和统计估计的第一性原理，为 $\\tau_\\infty$ 设计一个有原则的估计量和外推程序，并量化有限尺寸误差。具体而言，为每个测试用例实现以下步骤：\n\n- 使用提供的随机种子以保证可复现性，从模型 $\\tau(L_i) = \\tau_\\infty + c\\,L_i^{-p} + \\varepsilon_i$（其中 $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$）在指定尺寸 $L_i$ 处生成合成测量值 $\\tau(L_i)$。\n- 对于模型选择，考虑候选指数集 $\\mathcal{P} = \\{1.0, 1.5, 2.0\\}$。对于每个 $p \\in \\mathcal{P}$，通过普通最小二乘法拟合线性回归模型 $\\tau(L) = a + b\\,L^{-p}$，从测量到的数据对 $(L_i, \\tau(L_i))$ 中估计 $(a,b)$。将残差平方和记为 $\\mathrm{RSS}(p)$。通过最小化贝叶斯信息准则 (BIC) 来选择 $\\hat{p}$：\n$$\n\\mathrm{BIC}(p) = n \\ln\\!\\left(\\frac{\\mathrm{RSS}(p)}{n}\\right) + k \\ln(n),\n$$\n其中 $n$ 等于测量次数，$k = 2$ 等于 $(a,b)$ 中拟合参数的数量。\n- 外推的无限域曲折度估计值为 $\\widehat{\\tau}_\\infty = \\hat{a}$，即对应于 $\\hat{p}$ 的截距。在尺寸 $L$ 处的估计有限尺寸偏差为 $\\widehat{\\mathrm{bias}}(L) = \\hat{b}\\,L^{-\\hat{p}}$。\n- 通过均方根有限尺寸偏差来量化所提供尺寸范围内的有限尺寸误差\n$$\n\\mathrm{RMSB} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n} \\left(\\hat{b}\\,L_i^{-\\hat{p}}\\right)^2 }.\n$$\n- 对于给定的容差 $\\varepsilon_{\\mathrm{tol}}$，计算确保 $|\\widehat{\\mathrm{bias}}(L_\\star)| \\le \\varepsilon_{\\mathrm{tol}}$ 的最小样本尺寸 $L_\\star$：\n$$\nL_\\star = \n\\begin{cases}\n0,  \\text{if } \\hat{b} = 0,\\\\\n\\left(\\dfrac{|\\hat{b}|}{\\varepsilon_{\\mathrm{tol}}}\\right)^{1/\\hat{p}},  \\text{otherwise}.\n\\end{cases}\n$$\n使用与输入相同的长度单位表示 $L_\\star$。\n\n- 为了在合成数据上进行评估，还需使用每个测试用例中提供的真实值 $\\tau_\\infty$ 报告绝对估计误差 $|\\widehat{\\tau}_\\infty - \\tau_\\infty|$。\n\n您的程序必须实现上述完整流程，并为每个测试用例生成一个包含以下内容的列表：\n$[\\widehat{\\tau}_\\infty,\\ |\\widehat{\\tau}_\\infty - \\tau_\\infty|,\\ \\hat{p},\\ \\mathrm{RMSB},\\ L_\\star]$。\n\n测试套件和数据生成细节：\n\n- 对于每个测试用例，使用下面给出的指定参数 $(\\tau_\\infty, c, p, \\sigma, \\{L_i\\}, \\varepsilon_{\\mathrm{tol}}, \\text{seed})$，并使用公式 $\\tau(L_i) = \\tau_\\infty + c\\,L_i^{-p} + \\varepsilon_i$（其中 $\\varepsilon_i \\overset{\\mathrm{iid}}{\\sim} \\mathcal{N}(0,\\sigma^2)$ 且随机数生成器由所提供的种子初始化）生成 $\\tau(L_i)$。\n\n- 测试用例 1（具有中等有限尺寸效应和中等噪声的一般情况）：\n  - $\\tau_\\infty = 2.0$\n  - $c = 20.0$\n  - $p = 1.5$\n  - $\\sigma = 0.02$\n  - $\\{L_i\\} = [50.0, 75.0, 100.0, 150.0, 200.0]$\n  - $\\varepsilon_{\\mathrm{tol}} = 0.01$\n  - $\\text{seed} = 12345$\n\n- 测试用例 2（有限尺寸效应较小，由测量噪声主导）：\n  - $\\tau_\\infty = 1.75$\n  - $c = 0.5$\n  - $p = 2.0$\n  - $\\sigma = 0.01$\n  - $\\{L_i\\} = [30.0, 40.0, 60.0, 90.0]$\n  - $\\varepsilon_{\\mathrm{tol}} = 0.005$\n  - $\\text{seed} = 24680$\n\n- 测试用例 3（具有缓慢 $L^{-1}$ 衰减的强有限尺寸效应）：\n  - $\\tau_\\infty = 3.2$\n  - $c = 12.0$\n  - $p = 1.0$\n  - $\\sigma = 0.05$\n  - $\\{L_i\\} = [20.0, 30.0, 50.0, 80.0]$\n  - $\\varepsilon_{\\mathrm{tol}} = 0.02$\n  - $\\text{seed} = 13579$\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个每个测试用例结果的列表，每个测试用例的结果是一个列表 $[\\widehat{\\tau}_\\infty,\\ |\\widehat{\\tau}_\\infty - \\tau_\\infty|,\\ \\hat{p},\\ \\mathrm{RMSB},\\ L_\\star]$。例如，输出格式应类似于 $[[x_1,y_1,z_1,u_1,v_1],[x_2,y_2,z_2,u_2,v_2],[x_3,y_3,z_3,u_3,v_3]]$，所有条目均为小数。所有曲折度和 $\\sigma$ 都是无量纲的；$L_\\star$ 以与输入 $L_i$ 值相同的长度单位报告。不使用角度。任何地方都不要包含百分号；任何比例（如置信水平）都必须写成小数。",
            "solution": "所提出的问题是一个适定的、有科学依据的数据分析练习，专门解决从有限尺寸计算实验中估计物理性质的问题。其背景是电池电极的逆向设计，其中多孔微结构的体（无限域）曲折度 $\\tau_\\infty$ 是一项关键的输运性质。我们的任务是从一系列在有限线性尺寸 $L_i$ 的样本上执行的模拟测量 $\\tau(L_i)$ 中估计 $\\tau_\\infty$。这些测量同时受到系统性有限尺寸偏差和随机噪声的影响。\n\n该问题为测量的曲折度提供了一个渐近模型：\n$$\n\\tau(L) = \\tau_\\infty + c\\,L^{-p} + \\varepsilon\n$$\n此处，$\\tau_\\infty$ 是我们寻求的真实性质。项 $c\\,L^{-p}$ 代表领头阶有限尺寸偏差，它随系统尺寸 $L$ 代数衰减。指数 $p  0$ 取决于介质中空间相关性的性质。项 $\\varepsilon$ 是一个零均值高斯随机变量，$\\varepsilon \\sim \\mathcal{N}(0, \\sigma^2)$，用于解释数值噪声和相同尺寸不同样本之间的统计涨落。\n\n我们的目标是设计一个程序，通过将此模型拟合到合成数据来估计 $\\tau_\\infty$，并量化相关的误差和标度行为。核心挑战在于系数 $(\\tau_\\infty, c)$ 和指数 $p$ 都是未知的。指定的方法论涉及一个模型选择步骤，以从候选集 $\\mathcal{P} = \\{1.0, 1.5, 2.0\\}$ 中确定最合理的指数。\n\n对于每个提供的测试用例，该程序包括以下步骤。\n\n首先，我们生成合成测量数据。对于一组给定的真实参数 $(\\tau_\\infty, c, p, \\sigma)$、一组样本尺寸 $\\{L_i\\}_{i=1}^n$ 和一个用于保证可复现性的随机种子，我们计算测量的曲折度值：\n$$\n\\tau(L_i) = \\tau_\\infty + c\\,L_i^{-p} + \\varepsilon_i\n$$\n其中每个 $\\varepsilon_i$ 是从正态分布 $\\mathcal{N}(0, \\sigma^2)$ 中的一次独立抽取。\n\n其次，我们执行模型选择。对于每个候选指数 $p_j \\in \\mathcal{P}$，我们通过定义一个新的自变量 $x_j = L^{-p_j}$ 来线性化模型。然后模型呈现为简单线性方程的形式：\n$$\n\\tau(L) = a + b\\,x_j\n$$\n其中截距 $a$ 对应于 $\\tau_\\infty$（因为当 $L \\to \\infty$ 时，$x_j \\to 0$），斜率 $b$ 对应于系数 $c$。我们使用普通最小二乘法 (OLS) 将此线性模型拟合到数据对 $(x_{j,i}, \\tau(L_i))$（其中 $i=1, \\dots, n$）。OLS 确定使残差平方和 (RSS) 最小化的参数 $(\\hat{a}_j, \\hat{b}_j)$：\n$$\n\\mathrm{RSS}(p_j) = \\sum_{i=1}^{n} \\left( \\tau(L_i) - (\\hat{a}_j + \\hat{b}_j L_i^{-p_j}) \\right)^2\n$$\n为了从集合 $\\mathcal{P}$ 中选择最佳指数 $\\hat{p}$，我们不能简单地选择具有最低 $\\mathrm{RSS}$ 的那个，因为这会偏向于更复杂的模型。相反，我们使用贝叶斯信息准则 (BIC)，它会对模型复杂度进行惩罚。具有候选指数 $p_j$ 的模型的 BIC 由下式给出：\n$$\n\\mathrm{BIC}(p_j) = n \\ln\\!\\left(\\frac{\\mathrm{RSS}(p_j)}{n}\\right) + k \\ln(n)\n$$\n此处，$n$ 是数据点的数量，$k=2$ 是拟合参数（$a$ 和 $b$）的数量。产生最小 BIC 的指数 $\\hat{p}$ 被选为数据的最佳模型。\n\n第三，在确定了最优指数 $\\hat{p}$ 后，我们获得最终的参数估计值。外推的无限域曲折度为 $\\widehat{\\tau}_\\infty = \\hat{a}$，偏差系数为 $\\hat{b}$，两者均取自对应于 $\\hat{p}$ 的 OLS 拟合。\n\n第四，我们根据所选模型量化误差和标度行为。\n对于我们的合成测试用例，绝对估计误差为 $|\\widehat{\\tau}_\\infty - \\tau_\\infty|$，其中 $\\tau_\\infty$ 是已知的真实值。\n在给定尺寸 $L$ 处的估计有限尺寸偏差为 $\\widehat{\\mathrm{bias}}(L) = \\hat{b}\\,L^{-\\hat{p}}$。为了表征该偏差在所有测量尺寸上的总体大小，我们计算均方根偏差 (RMSB)：\n$$\n\\mathrm{RMSB} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n} \\left(\\widehat{\\mathrm{bias}}(L_i)\\right)^2} = \\sqrt{\\frac{1}{n}\\sum_{i=1}^{n} \\left(\\hat{b}\\,L_i^{-\\hat{p}}\\right)^2}\n$$\n最后，我们计算将有限尺寸偏差的大小减小到指定容差 $\\varepsilon_{\\mathrm{tol}}$ 所需的最小样本尺寸 $L_\\star$。这是通过求解 $|\\widehat{\\mathrm{bias}}(L_\\star)| = \\varepsilon_{\\mathrm{tol}}$ 得到 $L_\\star$：\n$$\n|\\hat{b}\\,L_\\star^{-\\hat{p}}| = \\varepsilon_{\\mathrm{tol}} \\implies L_\\star = \\left(\\frac{|\\hat{b}|}{\\varepsilon_{\\mathrm{tol}}}\\right)^{1/\\hat{p}}\n$$\n该公式在 $\\hat{b} \\ne 0$ 时有效；如果 $\\hat{b} = 0$，则所有尺寸的估计偏差均为零，因此我们定义 $L_\\star = 0$。\n\n这一全面的程序允许对无限尺寸极限进行有原则的外推，并为评估和控制计算材料科学中的有限尺寸误差提供了实用指标。实现将对每个测试用例严格遵循这些步骤。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final results.\n    \"\"\"\n    # Test cases as specified in the problem statement.\n    test_cases = [\n        # case 1\n        {\n            \"tau_inf_true\": 2.0, \"c\": 20.0, \"p_true\": 1.5, \"sigma\": 0.02,\n            \"L_values\": [50.0, 75.0, 100.0, 150.0, 200.0],\n            \"epsilon_tol\": 0.01, \"seed\": 12345\n        },\n        # case 2\n        {\n            \"tau_inf_true\": 1.75, \"c\": 0.5, \"p_true\": 2.0, \"sigma\": 0.01,\n            \"L_values\": [30.0, 40.0, 60.0, 90.0],\n            \"epsilon_tol\": 0.005, \"seed\": 24680\n        },\n        # case 3\n        {\n            \"tau_inf_true\": 3.2, \"c\": 12.0, \"p_true\": 1.0, \"sigma\": 0.05,\n            \"L_values\": [20.0, 30.0, 50.0, 80.0],\n            \"epsilon_tol\": 0.02, \"seed\": 13579\n        }\n    ]\n\n    # Candidate exponents for model selection\n    candidate_p = [1.0, 1.5, 2.0]\n\n    all_results = []\n\n    for case in test_cases:\n        # Unpack case parameters\n        tau_inf_true = case[\"tau_inf_true\"]\n        c_true = case[\"c\"]\n        p_true = case[\"p_true\"]\n        sigma = case[\"sigma\"]\n        L_values = np.array(case[\"L_values\"])\n        epsilon_tol = case[\"epsilon_tol\"]\n        seed = case[\"seed\"]\n\n        n = len(L_values)\n        k = 2  # Number of parameters in the linear model (a, b)\n\n        # 1. Generate synthetic data\n        rng = np.random.default_rng(seed)\n        epsilon = rng.normal(0, sigma, size=n)\n        tau_measured = tau_inf_true + c_true * L_values**(-p_true) + epsilon\n\n        # 2. Model selection\n        model_fits = []\n        for p_cand in candidate_p:\n            # Linearize the model: y = a + b*x, where x = L^(-p)\n            x_var = L_values**(-p_cand)\n            y_var = tau_measured\n            \n            # Design matrix for OLS: A * [a, b]^T = y\n            A = np.vstack([np.ones(n), x_var]).T\n\n            # Perform Ordinary Least Squares using numpy\n            # Solves for coefficients [a, b] that minimize ||y - A*coeffs||^2\n            coeffs, residuals, _, _ = np.linalg.lstsq(A, y_var, rcond=None)\n            a_hat, b_hat = coeffs[0], coeffs[1]\n            \n            # The 'residuals' output from lstsq is the RSS if the system is overdetermined\n            rss = residuals[0] if residuals.size > 0 else np.sum((y_var - (a_hat + b_hat * x_var))**2)\n\n            # Calculate BIC\n            bic = n * np.log(rss / n) + k * np.log(n)\n            \n            model_fits.append({'p': p_cand, 'a': a_hat, 'b': b_hat, 'bic': bic})\n\n        # Find the best model (minimum BIC)\n        best_model = min(model_fits, key=lambda x: x['bic'])\n        hat_p = best_model['p']\n        hat_a = best_model['a']\n        hat_b = best_model['b']\n\n        # 3. Extrapolate and estimate bias\n        hat_tau_inf = hat_a\n        \n        # 4. Quantify errors\n        abs_estimation_error = abs(hat_tau_inf - tau_inf_true)\n        \n        bias_terms = hat_b * L_values**(-hat_p)\n        rmsb = np.sqrt(np.mean(bias_terms**2))\n        \n        if hat_b == 0:\n            L_star = 0.0\n        else:\n            L_star = (abs(hat_b) / epsilon_tol)**(1 / hat_p)\n            \n        # Compile results for the current case\n        case_results = [hat_tau_inf, abs_estimation_error, hat_p, rmsb, L_star]\n        all_results.append(case_results)\n\n    # Format output as a list of lists strings, then join\n    # e.g., [\"[1,2,3]\", \"[4,5,6]\"] -> join -> \"[1,2,3],[4,5,6]\"\n    # then wrap with another pair of brackets\n    # This ensures no spaces in the final output format.\n    results_str_list = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output_str = f\"[{','.join(results_str_list)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}