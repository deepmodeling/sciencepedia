{
    "hands_on_practices": [
        {
            "introduction": "A fundamental decision in modeling electrolyte transport is whether to solve the full Poisson-Nernst-Planck equations or to use the simplified, computationally efficient electroneutrality assumption. This choice hinges on the relationship between the characteristic pore size of the microstructure and the Debye length, $\\lambda_{D}$, which describes the screening distance of electrostatic interactions in the electrolyte. This exercise guides you through the first-principles derivation of the Debye length and its application to a realistic battery electrolyte, providing a quantitative basis for model simplification .",
            "id": "3928427",
            "problem": "In microstructure-resolved modeling of lithium-ion battery electrodes and separators, one often imposes bulk electroneutrality when the characteristic electrostatic screening length is much smaller than the characteristic pore size. Starting from first principles, derive an expression for the electrostatic screening length (Debye length) $\\lambda_{D}$ for a symmetric monovalent electrolyte by combining the electrostatic Poisson equation and the Maxwell–Boltzmann number density of ions under the small-potential assumption $|z e \\phi| \\ll k_{B} T$. Express $\\lambda_{D}$ in terms of the absolute permittivity $\\epsilon$, temperature $T$, ionic strength $I$, the elementary charge $e$, and Avogadro’s number $N_{A}$. Assume ideal dissociation so that for a symmetric $1:1$ electrolyte the ionic strength equals the salt concentration, $I = c_{s}$, where $c_{s}$ is in $\\mathrm{mol \\, m^{-3}}$.\n\nThen, using your derived expression, evaluate $\\lambda_{D}$ for a carbonate-based electrolyte with relative permittivity $\\epsilon_{r} = 18$ at temperature $T = 298 \\ \\mathrm{K}$ and bulk salt concentration $c_{s} = 1.0 \\ \\mathrm{mol \\, L^{-1}}$. Take the vacuum permittivity $\\epsilon_{0} = 8.854187817 \\times 10^{-12} \\ \\mathrm{F \\, m^{-1}}$, Boltzmann’s constant $k_{B} = 1.380649 \\times 10^{-23} \\ \\mathrm{J \\, K^{-1}}$, elementary charge $e = 1.602176634 \\times 10^{-19} \\ \\mathrm{C}$, and Avogadro’s number $N_{A} = 6.02214076 \\times 10^{23} \\ \\mathrm{mol^{-1}}$. Consider two microstructures: a separator with mean pore radius $R_{\\mathrm{sep}} = 50 \\ \\mathrm{nm}$ and an electrode with mean pore radius $R_{\\mathrm{elec}} = 500 \\ \\mathrm{nm}$. Compute the two ratios $\\lambda_{D} / R_{\\mathrm{sep}}$ and $\\lambda_{D} / R_{\\mathrm{elec}}$, and report as your final answer the larger of the two ratios,\n$$\nr_{\\max} = \\max\\!\\left( \\frac{\\lambda_{D}}{R_{\\mathrm{sep}}}, \\frac{\\lambda_{D}}{R_{\\mathrm{elec}}} \\right).\n$$\nRound your final answer to three significant figures. Express your final answer as a dimensionless number with no units.",
            "solution": "The problem requires the derivation of the Debye length, $\\lambda_{D}$, for a symmetric monovalent electrolyte and its subsequent numerical evaluation for a specific set of parameters relevant to lithium-ion battery modeling. The process begins from first principles, combining electrostatics and statistical mechanics.\n\n**Part 1: Derivation of the Debye Length, $\\lambda_{D}$**\n\nThe derivation starts with the Poisson equation, which relates the electrostatic potential $\\phi$ to the local net charge density $\\rho_{e}$:\n$$\n\\nabla^2 \\phi = - \\frac{\\rho_{e}}{\\epsilon}\n$$\nHere, $\\epsilon$ is the absolute permittivity of the electrolyte medium.\n\nFor a symmetric monovalent electrolyte (a $1:1$ electrolyte), the charge density $\\rho_{e}$ arises from the presence of cations with charge $+e$ and anions with charge $-e$. The charge density is given by the sum of charges over all species:\n$$\n\\rho_{e} = z_{+} e n_{+} + z_{-} e n_{-}\n$$\nwhere $n_{+}$ and $n_{-}$ are the local number densities (ions per unit volume) of cations and anions, respectively, and $z_{+} = +1$ and $z_{-} = -1$ are their valencies. Thus:\n$$\n\\rho_{e} = e(n_{+} - n_{-})\n$$\nThe local number densities of ions are described by the Maxwell-Boltzmann distribution, which relates the local density to the local potential energy $z e \\phi$:\n$$\nn_{i} = n_{i, \\infty} \\exp\\left(-\\frac{z_{i} e \\phi}{k_{B} T}\\right)\n$$\nHere, $n_{i, \\infty}$ is the bulk number density of species $i$ far from any charged surface where $\\phi \\rightarrow 0$, $k_{B}$ is the Boltzmann constant, and $T$ is the absolute temperature. For a neutral bulk electrolyte, the bulk number densities of cations and anions must be equal: $n_{+, \\infty} = n_{-, \\infty} = n_{\\infty}$.\n\nApplying the Maxwell-Boltzmann distribution to our system:\n$$\nn_{+} = n_{\\infty} \\exp\\left(-\\frac{e \\phi}{k_{B} T}\\right)\n$$\n$$\nn_{-} = n_{\\infty} \\exp\\left(\\frac{e \\phi}{k_{B} T}\\right)\n$$\nSubstituting these expressions into the equation for charge density yields:\n$$\n\\rho_{e} = e n_{\\infty} \\left[ \\exp\\left(-\\frac{e \\phi}{k_{B} T}\\right) - \\exp\\left(\\frac{e \\phi}{k_{B} T}\\right) \\right]\n$$\nThe problem specifies using the small-potential assumption, $|z e \\phi| \\ll k_{B} T$. Since $z = \\pm 1$, this is $|e \\phi| \\ll k_{B} T$. This allows for the linearization of the exponential functions using the Taylor series expansion $\\exp(x) \\approx 1 + x$ for small $x$:\n$$\n\\exp\\left(-\\frac{e \\phi}{k_{B} T}\\right) \\approx 1 - \\frac{e \\phi}{k_{B} T}\n$$\n$$\n\\exp\\left(\\frac{e \\phi}{k_{B} T}\\right) \\approx 1 + \\frac{e \\phi}{k_{B} T}\n$$\nSubstituting these approximations into the expression for $\\rho_{e}$:\n$$\n\\rho_{e} \\approx e n_{\\infty} \\left[ \\left(1 - \\frac{e \\phi}{k_{B} T}\\right) - \\left(1 + \\frac{e \\phi}{k_{B} T}\\right) \\right] = e n_{\\infty} \\left(-\\frac{2e\\phi}{k_{B} T}\\right) = - \\frac{2 n_{\\infty} e^2}{k_{B} T} \\phi\n$$\nNow, we substitute this linearized expression for $\\rho_{e}$ back into the Poisson equation, which yields the linearized Poisson-Boltzmann equation:\n$$\n\\nabla^2 \\phi = - \\frac{1}{\\epsilon} \\left( - \\frac{2 n_{\\infty} e^2}{k_{B} T} \\phi \\right) = \\left( \\frac{2 n_{\\infty} e^2}{\\epsilon k_{B} T} \\right) \\phi\n$$\nThis equation is of the form $\\nabla^2 \\phi = \\kappa^2 \\phi$, where $\\kappa^{-1}$ is the characteristic length scale for the decay of the potential. This length scale is defined as the Debye length, $\\lambda_{D}$. Therefore, we have:\n$$\n\\frac{1}{\\lambda_{D}^2} = \\frac{2 n_{\\infty} e^2}{\\epsilon k_{B} T} \\quad \\implies \\quad \\lambda_{D} = \\sqrt{\\frac{\\epsilon k_{B} T}{2 n_{\\infty} e^2}}\n$$\nThe problem asks for the expression in terms of the ionic strength $I$. The ionic strength for a general electrolyte is defined in molar concentrations $c_i$ as $I = \\frac{1}{2} \\sum_i c_i z_i^2$. The number density $n_i$ and molar concentration $c_i$ are related by $n_i = c_i N_A$. The general expression for the inverse square of the Debye length is $\\lambda_D^{-2} = \\frac{e^2}{\\epsilon k_B T} \\sum_i n_{i,\\infty}z_i^2$. The summation term can be related to ionic strength: $\\sum_i n_{i,\\infty}z_i^2 = N_A \\sum_i c_{i,\\infty}z_i^2 = 2 N_A I$. Substituting this into the general expression gives:\n$$\n\\frac{1}{\\lambda_{D}^2} = \\frac{e^2}{\\epsilon k_{B} T} (2 N_{A} I) = \\frac{2 N_A e^2 I}{\\epsilon k_B T}\n$$\nSolving for $\\lambda_{D}$ gives the desired expression:\n$$\n\\lambda_{D} = \\sqrt{\\frac{\\epsilon k_{B} T}{2 N_{A} e^2 I}}\n$$\nFor a symmetric $1:1$ electrolyte with salt concentration $c_s$, $I=c_s$, so we use this in the subsequent calculation.\n\n**Part 2: Numerical Evaluation**\n\nWe are given the following parameters:\n-   Relative permittivity: $\\epsilon_{r} = 18$\n-   Temperature: $T = 298 \\ \\mathrm{K}$\n-   Bulk salt concentration: $c_{s} = 1.0 \\ \\mathrm{mol \\, L^{-1}}$. We must convert this to SI units ($\\mathrm{mol \\, m^{-3}}$). Since $1 \\ \\mathrm{L} = 10^{-3} \\ \\mathrm{m^3}$, we have $c_{s} = \\frac{1.0 \\ \\mathrm{mol}}{10^{-3} \\ \\mathrm{m^3}} = 1000 \\ \\mathrm{mol \\, m^{-3}}$. Since $I=c_s$, $I = 1000 \\ \\mathrm{mol \\, m^{-3}}$.\n-   Vacuum permittivity: $\\epsilon_{0} = 8.854187817 \\times 10^{-12} \\ \\mathrm{F \\, m^{-1}}$\n-   Boltzmann's constant: $k_{B} = 1.380649 \\times 10^{-23} \\ \\mathrm{J \\, K^{-1}}$\n-   Elementary charge: $e = 1.602176634 \\times 10^{-19} \\ \\mathrm{C}$\n-   Avogadro's number: $N_{A} = 6.02214076 \\times 10^{23} \\ \\mathrm{mol^{-1}}$\n\nFirst, calculate the absolute permittivity $\\epsilon$:\n$$\n\\epsilon = \\epsilon_{r} \\epsilon_{0} = 18 \\times (8.854187817 \\times 10^{-12} \\ \\mathrm{F \\, m^{-1}}) = 1.5937538... \\times 10^{-10} \\ \\mathrm{F \\, m^{-1}}\n$$\nNow, substitute all values into the expression for $\\lambda_{D}$:\n$$\n\\lambda_{D} = \\sqrt{\\frac{(1.59375... \\times 10^{-10}) \\times (1.380649 \\times 10^{-23}) \\times 298}{2 \\times (6.02214076 \\times 10^{23}) \\times (1.602176634 \\times 10^{-19})^2 \\times 1000}}\n$$\nCalculating the numerator and denominator separately:\n$$\n\\mathrm{Numerator} = \\epsilon k_{B} T = (1.59375... \\times 10^{-10}) \\times (1.380649 \\times 10^{-23}) \\times 298 = 6.55683... \\times 10^{-31} \\ \\mathrm{J \\cdot F \\cdot m^{-1}}\n$$\n$$\n\\mathrm{Denominator} = 2 N_{A} e^2 I = 2 \\times (6.02214076 \\times 10^{23}) \\times (1.602176634 \\times 10^{-19})^2 \\times 1000 = 3.09163... \\times 10^{-11} \\ \\mathrm{C^2 \\cdot m^{-3}}\n$$\nNow, we compute the ratio and take the square root:\n$$\n\\lambda_{D}^2 = \\frac{6.55683... \\times 10^{-31}}{3.09163... \\times 10^{-11}} = 2.12086... \\times 10^{-20} \\ \\mathrm{m^2}\n$$\n$$\n\\lambda_{D} = \\sqrt{2.12086... \\times 10^{-20}} = 1.45631... \\times 10^{-10} \\ \\mathrm{m}\n$$\n\n**Part 3: Calculation of Ratios and Final Answer**\n\nWe are given the mean pore radii for two microstructures:\n-   Separator: $R_{\\mathrm{sep}} = 50 \\ \\mathrm{nm} = 50 \\times 10^{-9} \\ \\mathrm{m}$\n-   Electrode: $R_{\\mathrm{elec}} = 500 \\ \\mathrm{nm} = 500 \\times 10^{-9} \\ \\mathrm{m}$\n\nWe compute the required ratios:\n$$\n\\frac{\\lambda_{D}}{R_{\\mathrm{sep}}} = \\frac{1.45631... \\times 10^{-10} \\ \\mathrm{m}}{50 \\times 10^{-9} \\ \\mathrm{m}} = 0.0029126...\n$$\n$$\n\\frac{\\lambda_{D}}{R_{\\mathrm{elec}}} = \\frac{1.45631... \\times 10^{-10} \\ \\mathrm{m}}{500 \\times 10^{-9} \\ \\mathrm{m}} = 0.00029126...\n$$\nThe problem asks for the larger of these two ratios, $r_{\\max}$:\n$$\nr_{\\max} = \\max\\left( \\frac{\\lambda_{D}}{R_{\\mathrm{sep}}}, \\frac{\\lambda_{D}}{R_{\\mathrm{elec}}} \\right) = \\max(0.0029126..., 0.00029126...) = 0.0029126...\n$$\nFinally, rounding the result to three significant figures:\n$$\nr_{\\max} \\approx 0.00291\n$$\nIn standard scientific notation, this is $2.91 \\times 10^{-3}$. Both ratios are much less than $1$, which validates the assumption of bulk electroneutrality in these microstructures under the given conditions.",
            "answer": "$$\\boxed{2.91 \\times 10^{-3}}$$"
        },
        {
            "introduction": "Once the physical model is established, we must analyze the complex geometry of the electrode itself, which is often represented as a voxelized dataset from techniques like X-ray tomography. A key property governing transport is the connectivity of the phases, as only connected pathways contribute to the cell's function. This practice introduces a computational approach to quantify the 'percolating fraction' of the electrolyte phase—the portion that forms a continuous path for ion transport—by treating the microstructure as a graph and identifying its connected components .",
            "id": "3928283",
            "problem": "You are given three-dimensional voxelized samples representing the greyscale signal of a battery electrode microstructure, where higher intensity indicates a higher likelihood of electrolyte phase at that voxel. For a given segmentation threshold, the electrolyte phase is defined as the set of voxels whose intensity is greater than or equal to the threshold. Two opposite faces of interest are the faces orthogonal to the third axis (commonly called the $z$-axis), namely the planes at $z=0$ and $z=L_z-1$ for a volume of size $L_x \\times L_y \\times L_z$. Your task is to construct an algorithm that, for each supplied sample and set of thresholds, computes the percolating fraction of the electrolyte phase between these opposite faces and quantifies its sensitivity to the segmentation threshold.\n\nStart from the following fundamental base:\n- Represent the voxel lattice as a graph whose vertices are voxels and whose edges connect voxels that share a face in three dimensions (six-neighbor connectivity). That is, voxels at indices $(i,j,k)$ and $(i',j',k')$ are adjacent if $|i-i'|+|j-j'|+|k-k'|=1$.\n- Given a threshold $\\tau$, define the binary indicator $I_{\\tau}(i,j,k)$ that equals $1$ if the intensity $A(i,j,k)$ satisfies $A(i,j,k)\\ge \\tau$, and equals $0$ otherwise.\n- Define the subgraph $G_{\\tau}$ induced by the vertices where $I_{\\tau}(i,j,k)=1$. Define a connected component in $G_{\\tau}$ using six-neighbor connectivity.\n- A percolating component between faces $z=0$ and $z=L_z-1$ is any connected component in $G_{\\tau}$ that contains at least one voxel with $k=0$ and at least one voxel with $k=L_z-1$.\n- The percolating set $C_{\\tau}$ is the union of all percolating components. The percolating fraction is\n$$\n\\mathrm{PF}(\\tau)=\n\\begin{cases}\n\\frac{|C_{\\tau}|}{|\\{(i,j,k): I_{\\tau}(i,j,k)=1\\}|}, & \\text{if } |\\{(i,j,k): I_{\\tau}(i,j,k)=1\\}|>0,\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\n- For a strictly increasing list of thresholds $\\{\\tau_0,\\tau_1,\\ldots,\\tau_{N-1}\\}$, define the sensitivity at $\\tau_i$ using finite differences:\n$$\nS(\\tau_i)=\n\\begin{cases}\n\\frac{\\mathrm{PF}(\\tau_{i+1})-\\mathrm{PF}(\\tau_i)}{\\tau_{i+1}-\\tau_i}, & \\text{if } i=0 \\text{ and } N\\ge 2,\\\\\n\\frac{\\mathrm{PF}(\\tau_{i+1})-\\mathrm{PF}(\\tau_{i-1})}{\\tau_{i+1}-\\tau_{i-1}}, & \\text{if } 0<i<N-1,\\\\\n\\frac{\\mathrm{PF}(\\tau_i)-\\mathrm{PF}(\\tau_{i-1})}{\\tau_i-\\tau_{i-1}}, & \\text{if } i=N-1 \\text{ and } N\\ge 2,\\\\\n0, & \\text{if } N=1.\n\\end{cases}\n$$\n\nImplement an algorithm that computes $\\mathrm{PF}(\\tau)$ and $S(\\tau)$ for each provided threshold $\\tau$ and for each provided sample. Use six-neighbor connectivity, and treat a voxel with intensity exactly equal to the threshold as belonging to the electrolyte phase. If there are no electrolyte voxels at a threshold, define $\\mathrm{PF}(\\tau)=0$.\n\nInput is fixed by the test suite below and must be hard-coded in your program. No user input will be provided. Your program must process all test cases and print a single line containing the aggregated results as specified. The final outputs are dimensionless quantities; do not include any physical units.\n\nTest suite:\n- Test case $1$ (general connected path with bottleneck):\n  - Volume $A^{(1)}$ of size $3\\times 3\\times 3$, specified by slices at $k=0,1,2$ respectively:\n    - At $k=0$: $\\begin{bmatrix} 0.9 & 0.1 & 0.1 \\\\ 0.1 & 0.9 & 0.1 \\\\ 0.1 & 0.1 & 0.1 \\end{bmatrix}$\n    - At $k=1$: $\\begin{bmatrix} 0.1 & 0.1 & 0.1 \\\\ 0.1 & 0.65 & 0.1 \\\\ 0.1 & 0.1 & 0.1 \\end{bmatrix}$\n    - At $k=2$: $\\begin{bmatrix} 0.1 & 0.1 & 0.1 \\\\ 0.1 & 0.9 & 0.1 \\\\ 0.1 & 0.1 & 0.9 \\end{bmatrix}$\n  - Thresholds $\\{\\tau_0,\\tau_1,\\tau_2\\}=\\{0.2,0.6,0.8\\}$.\n- Test case $2$ (no electrolyte at these thresholds):\n  - Volume $A^{(2)}$ of size $3\\times 3\\times 3$, with all entries equal to $0.0$.\n  - Thresholds $\\{\\tau_0,\\tau_1,\\tau_2\\}=\\{0.2,0.6,0.8\\}$.\n- Test case $3$ (fully electrolyte across all thresholds):\n  - Volume $A^{(3)}$ of size $3\\times 3\\times 3$, with all entries equal to $1.0$.\n  - Thresholds $\\{\\tau_0,\\tau_1,\\tau_2\\}=\\{0.2,0.6,0.8\\}$.\n\nOutput specification:\n- For each test case, output a pair of lists $[\\,[\\mathrm{PF}(\\tau_0),\\ldots,\\mathrm{PF}(\\tau_{N-1})],\\,[S(\\tau_0),\\ldots,S(\\tau_{N-1})]\\,]$.\n- Aggregate the test-case results into a single outer list in the given order of test cases.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example: $[[\\ldots],[\\ldots],[\\ldots]]$. Do not print any additional characters or text.\n\nAll mathematical symbols, variables, and numbers in this description are provided in LaTeX. Implement the algorithm faithfully to these definitions and produce the exact output format described above.",
            "solution": "The user has provided a problem that requires the computation of a percolating fraction and its sensitivity to a segmentation threshold for three-dimensional voxelized microstructures. The problem is well-defined, scientifically grounded in percolation theory and computational materials science, and all necessary definitions and data are provided. The problem is therefore deemed valid.\n\nThe core of the problem is to identify connected pathways of the electrolyte phase that span two opposite faces of a 3D volume. This is a classic connected components problem on a grid graph. The solution will be implemented by following a principled, step-by-step algorithm derived directly from the provided definitions.\n\nFirst, we must establish a consistent coordinate system. The problem specifies a volume of size $L_x \\times L_y \\times L_z$ with voxels indexed by $(i,j,k)$. The faces of interest are orthogonal to the third axis, $k$, at $k=0$ and $k=L_z-1$. We will represent the volume data $A(i,j,k)$ using a three-dimensional NumPy array. A standard convention for mapping 3D data slices to a NumPy array is to use the shape $(L_z, L_y, L_x)$, where the first index corresponds to the slice index. Therefore, we will access the intensity at voxel $(i,j,k)$—which we associate with spatial coordinates $(x,y,z)$—as `A[k, j, i]`.\n\nThe algorithm proceeds as follows for each test case, which consists of a volume $A$ and a set of thresholds $\\{\\tau_0, \\tau_1, \\ldots, \\tau_{N-1}\\}$:\n\n1.  **Iterate through Thresholds to Compute Percolating Fractions**: For each threshold $\\tau_m$ in the set, we compute the percolating fraction $\\mathrm{PF}(\\tau_m)$.\n    -   **Binarization**: We first segment the greyscale volume $A$ into a binary volume $B$. According to the definition $I_{\\tau}(i,j,k)$, a voxel at $(i,j,k)$ is part of the electrolyte phase if its intensity $A(i,j,k)$ is greater than or equal to the threshold $\\tau_m$. This produces a binary array where $B[k,j,i] = 1$ if $A[k,j,i] \\ge \\tau_m$, and $0$ otherwise.\n    -   **Handle Empty Phase**: If the total number of electrolyte voxels, $|\\{(i,j,k): I_{\\tau_m}(i,j,k)=1\\}|$, is zero, the percolating fraction $\\mathrm{PF}(\\tau_m)$ is defined as $0$. The algorithm proceeds to the next threshold.\n    -   **Connected Component Labeling**: To find connected components in the electrolyte phase, we utilize the `scipy.ndimage.label` function. This function efficiently identifies and labels all connected clusters of non-zero voxels in an array. We specify a 6-neighbor connectivity by using a structuring element generated by `scipy.ndimage.generate_binary_structure(3, 1)`, which corresponds to face-sharing neighbors as required by the problem statement: $|i-i'|+|j-j'|+|k-k'|=1$. The function returns a `labeled_array` where each distinct component is marked with a unique positive integer label, and a count `num_features` of the components found.\n    -   **Identify Percolating Components**: A component is defined as percolating if it spans the volume from the $z=0$ face to the $z=L_z-1$ face. With our $(L_z, L_y, L_x)$ array structure, these faces correspond to slices `labeled_array[0, :, :]` and `labeled_array[L_z-1, :, :]`. We identify the unique component labels present on the $z=0$ face and the unique labels on the $z=L_z-1$ face. The set of percolating labels is the intersection of these two sets (excluding the background label $0$).\n    -   **Calculate Percolating Fraction $\\mathrm{PF}(\\tau_m)$**: The percolating set $C_{\\tau_m}$ is the union of all voxels belonging to the identified percolating components. Its size, $|C_{\\tau_m}|$, is found by counting the total number of voxels in the `labeled_array` that have a percolating label. The percolating fraction is then calculated using the provided formula:\n        $$\n        \\mathrm{PF}(\\tau_m) = \\frac{|C_{\\tau_m}|}{|\\{(i,j,k): I_{\\tau_m}(i,j,k)=1\\}|}\n        $$\n\n2.  **Compute Sensitivity**: After computing the list of percolating fractions $[\\mathrm{PF}(\\tau_0), \\mathrm{PF}(\\tau_1), \\ldots, \\mathrm{PF}(\\tau_{N-1})]$, we calculate the sensitivity $S(\\tau_i)$ for each threshold. The calculation strictly follows the provided finite difference schemes:\n    -   For $N=1$, $S(\\tau_0) = 0$.\n    -   For $N \\ge 2$:\n        -   At the first point $i=0$ (forward difference): $S(\\tau_0) = \\frac{\\mathrm{PF}(\\tau_1)-\\mathrm{PF}(\\tau_0)}{\\tau_1-\\tau_0}$.\n        -   For interior points $0<i<N-1$ (central difference): $S(\\tau_i) = \\frac{\\mathrm{PF}(\\tau_{i+1})-\\mathrm{PF}(\\tau_{i-1})}{\\tau_{i+1}-\\tau_{i-1}}$.\n        -   At the last point $i=N-1$ (backward difference): $S(\\tau_{N-1}) = \\frac{\\mathrm{PF}(\\tau_{N-1})-\\mathrm{PF}(\\tau_{N-2})}{\\tau_{N-1}-\\tau_{N-2}}$.\n\nThis comprehensive, principle-based approach ensures that all definitions from the problem statement are faithfully implemented to produce a correct and verifiable solution. The use of established scientific libraries like NumPy and SciPy ensures both correctness and computational efficiency.",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label, generate_binary_structure\n\ndef compute_percolating_fraction(volume, threshold):\n    \"\"\"\n    Computes the percolating fraction for a given volume and threshold.\n    \n    Args:\n        volume (np.ndarray): The 3D voxelized data.\n        threshold (float): The segmentation threshold.\n        \n    Returns:\n        float: The percolating fraction PF(tau).\n    \"\"\"\n    # Binarize the volume based on the threshold\n    # A voxel is electrolyte if its intensity is >= threshold\n    binary_volume = (volume >= threshold).astype(int)\n    \n    total_electrolyte_voxels = np.sum(binary_volume)\n    \n    # If no electrolyte phase, PF is 0 by definition\n    if total_electrolyte_voxels == 0:\n        return 0.0\n        \n    # Define 6-neighbor connectivity (face-sharing)\n    # This is connectivity=1 in SciPy's terms for a 3D structure\n    structure = generate_binary_structure(3, 1)\n    \n    # Find and label all connected components\n    # The shape of the volume is assumed (Lz, Ly, Lx)\n    labeled_volume, num_features = label(binary_volume, structure=structure)\n    \n    if num_features == 0:\n        return 0.0\n        \n    # Identify component labels on the z=0 and z=Lz-1 faces\n    z_dim = volume.shape[0]\n    labels_at_z0 = np.unique(labeled_volume[0, :, :])\n    labels_at_z_end = np.unique(labeled_volume[z_dim - 1, :, :])\n    \n    # Filter out the background label 0\n    labels_at_z0 = labels_at_z0[labels_at_z0 != 0]\n    labels_at_z_end = labels_at_z_end[labels_at_z_end != 0]\n    \n    # Find labels present on both faces (percolating components)\n    percolating_labels = np.intersect1d(labels_at_z0, labels_at_z_end, assume_unique=True)\n    \n    if percolating_labels.size == 0:\n        return 0.0\n        \n    # Calculate the total size of all percolating components |C_tau|\n    percolating_set_mask = np.isin(labeled_volume, percolating_labels)\n    percolating_voxels_count = np.sum(percolating_set_mask)\n    \n    # Compute the percolating fraction\n    pf = percolating_voxels_count / total_electrolyte_voxels\n    \n    return pf\n\ndef compute_sensitivity(pf_values, thresholds):\n    \"\"\"\n    Computes the sensitivity of the percolating fraction to the threshold.\n    \n    Args:\n        pf_values (list): A list of percolating fraction values.\n        thresholds (list): A list of corresponding thresholds.\n        \n    Returns:\n        list: A list of sensitivity values S(tau).\n    \"\"\"\n    N = len(thresholds)\n    if N == 0:\n        return []\n    if N == 1:\n        return [0.0]\n        \n    sensitivities = []\n    \n    # i = 0 (forward difference)\n    s_0 = (pf_values[1] - pf_values[0]) / (thresholds[1] - thresholds[0])\n    sensitivities.append(s_0)\n    \n    # 0 < i < N-1 (central difference)\n    for i in range(1, N - 1):\n        s_i = (pf_values[i + 1] - pf_values[i - 1]) / (thresholds[i + 1] - thresholds[i - 1])\n        sensitivities.append(s_i)\n        \n    # i = N-1 (backward difference)\n    s_last = (pf_values[N - 1] - pf_values[N - 2]) / (thresholds[N - 1] - thresholds[N - 2])\n    sensitivities.append(s_last)\n    \n    return sensitivities\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # The volumes are structured as numpy arrays with shape (Lz, Ly, Lx)\n    test_cases = [\n        (\n            np.array([\n                [[0.9, 0.1, 0.1], [0.1, 0.9, 0.1], [0.1, 0.1, 0.1]], # k=0\n                [[0.1, 0.1, 0.1], [0.1, 0.65, 0.1], [0.1, 0.1, 0.1]], # k=1\n                [[0.1, 0.1, 0.1], [0.1, 0.9, 0.1], [0.1, 0.1, 0.9]]  # k=2\n            ]),\n            [0.2, 0.6, 0.8]\n        ),\n        (\n            np.full((3, 3, 3), 0.0),\n            [0.2, 0.6, 0.8]\n        ),\n        (\n            np.full((3, 3, 3), 1.0),\n            [0.2, 0.6, 0.8]\n        )\n    ]\n\n    all_results = []\n    for volume, thresholds in test_cases:\n        pf_results = [compute_percolating_fraction(volume, t) for t in thresholds]\n        s_results = compute_sensitivity(pf_results, thresholds)\n        \n        # Rounding for consistent float representation\n        pf_results_rounded = [round(p, 4) for p in pf_results]\n        s_results_rounded = [round(s, 4) for s in s_results]\n\n        all_results.append([pf_results_rounded, s_results_rounded])\n\n    # Convert final results to string, respecting the specified format\n    # Using str() on lists produces the required '[...]' format.\n    # The join then assembles the outer list.\n    results_str =','.join(map(str, all_results))\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With an understanding of both the governing physics and the geometric connectivity, the final step is to perform a direct simulation on the digital microstructure. A major challenge in simulating transport phenomena like ionic conduction is correctly handling regions that are geometrically isolated from the main transport pathways. This exercise focuses on implementing a finite volume solver that enforces global charge conservation by correctly identifying non-percolating domains and applying physically consistent boundary conditions to ensure that no charge is artificially created or destroyed in these trapped regions .",
            "id": "3928365",
            "problem": "You are given the task of formulating boundary conditions for a microstructure-resolved conduction problem in a porous battery electrode electrolyte domain such that global charge conservation is always satisfied, even when parts of the electrolyte are isolated by trapped pores and nonpercolating regions. The fundamental base must be the steady-state ionic charge conservation law with linear constitutive behavior:\n\n- The steady-state conservation law is given by the divergence of ionic current density equal to zero in the electrolyte bulk, where no volumetric sources exist: $$\\nabla \\cdot \\mathbf{j}_e = 0.$$\n- The ionic current density is related to the electrolyte potential by a linear constitutive relation: $$\\mathbf{j}_e = -\\kappa \\nabla \\phi_e,$$ where $\\kappa$ is the ionic conductivity (in $\\mathrm{S/m}$), and $\\phi_e$ is the electrolyte potential (in $\\mathrm{V}$).\n- At the solid–electrolyte interface where electrochemical reaction occurs, impose a linearized Butler–Volmer-like boundary condition (Robin type) that relates the normal flux to the overpotential: $$-\\mathbf{n} \\cdot \\mathbf{j}_e = k \\left(\\phi_e - \\phi_{\\mathrm{eq}}\\right),$$ where $k$ is the interfacial reaction conductance (in $\\mathrm{A/(m^2 \\cdot V)}$), $\\phi_{\\mathrm{eq}}$ is the equilibrium potential (in $\\mathrm{V}$), and $\\mathbf{n}$ is the outward unit normal of the electrolyte domain.\n- On external reservoir boundaries, enforce Dirichlet conditions: $$\\phi_e = \\phi_{\\mathrm{L}} \\text{ on the left boundary,} \\quad \\phi_e = \\phi_{\\mathrm{R}} \\text{ on the right boundary},$$ with $\\phi_{\\mathrm{L}}$ and $\\phi_{\\mathrm{R}}$ in $\\mathrm{V}$.\n- On non-reactive boundaries (e.g., top and bottom of the domain if specified nonconducting), enforce zero-flux Neumann conditions: $$-\\mathbf{n} \\cdot \\mathbf{j}_e = 0.$$\n\nIsolated electrolyte components that do not percolate to any reservoir boundary must have zero net ionic exchange with the solid; that is, the reaction boundary condition must be deactivated there by setting $k=0$ on all their solid interfaces. This enforces that no net charge can enter or leave those isolated regions, which is required by global charge conservation.\n\nConstruct a purely mathematical and algorithmic procedure that:\n1. Identifies connected electrolyte components and determines which components percolate to the left or right reservoirs.\n2. Assembles and solves the resulting linear system for $\\phi_e$ using a finite volume discretization on a uniform Cartesian grid with cell size $dx$ (in $\\mathrm{m}$) and out-of-plane thickness $t$ (in $\\mathrm{m}$), where each face transmissibility is $$T = \\kappa \\, t.$$ The reaction flux contribution per electrolyte–solid face is $$F_{\\mathrm{rxn}} = k \\, t \\, dx \\, \\left(\\phi_e - \\phi_{\\mathrm{eq}}\\right).$$\n3. Enforces $k=0$ on all solid interfaces that border isolated electrolyte components.\n4. Computes the global conservation residual, defined as the algebraic sum of all electrolyte boundary outfluxes and all reaction outfluxes:\n   $$\\mathcal{R} = \\sum_{\\text{reservoir faces}} T \\left(\\phi_e - \\phi_{\\mathrm{res}}\\right) + \\sum_{\\text{reactive faces}} k \\, t \\, dx \\left(\\phi_e - \\phi_{\\mathrm{eq}}\\right),$$\n   where $\\phi_{\\mathrm{res}}$ is $\\phi_{\\mathrm{L}}$ or $\\phi_{\\mathrm{R}}$ depending on the reservoir face. The quantity $\\mathcal{R}$ must be numerically near zero when boundary conditions are consistent, due to cancellation of interior face fluxes and the steady-state conservation law.\n\nThe program must implement the above for a set of two-dimensional microstructure masks, treating the top and bottom boundaries as zero-flux Neumann boundaries. The out-of-plane thickness $t$ must be used to convert face flux densities to currents, so all currents are in $\\mathrm{A}$. If any electrolyte component is completely isolated (no reservoir contact and no reactive interfaces, since $k$ is set to zero), assign $\\phi_e = \\phi_{\\mathrm{eq}}$ directly in that component to avoid singularity without introducing any artificial flux.\n\nPhysical units and parameters:\n- $\\kappa$ in $\\mathrm{S/m}$; use $\\kappa = 1.0 \\, \\mathrm{S/m}$.\n- $k$ in $\\mathrm{A/(m^2 \\cdot V)}$; use $k = 1.0 \\times 10^{6} \\, \\mathrm{A/(m^2 \\cdot V)}$ for reactive interfaces of percolating components, and $k = 0$ for isolated components.\n- $dx = 1.0 \\times 10^{-5} \\, \\mathrm{m}$ (cell size).\n- $t = 5.0 \\times 10^{-6} \\, \\mathrm{m}$ (out-of-plane thickness).\n- $\\phi_{\\mathrm{eq}} = 0.0 \\, \\mathrm{V}$, $\\phi_{\\mathrm{L}} = 0.1 \\, \\mathrm{V}$, $\\phi_{\\mathrm{R}} = 0.0 \\, \\mathrm{V}$.\n\nAngle units are not applicable. All output currents must be expressed in $\\mathrm{A}$.\n\nTest suite:\n- Case 1 (happy path): Grid size $8 \\times 6$; a percolating electrolyte channel along the middle row connects left to right reservoirs; additional isolated pocket away from the channel. Expect a small global residual near $0 \\, \\mathrm{A}$.\n- Case 2 (isolated edge case): Grid size $5 \\times 5$; a single-cell isolated electrolyte pocket not touching any reservoir; reaction deactivated. Expect exactly $0 \\, \\mathrm{A}$ residual.\n- Case 3 (left-only percolation): Grid size $7 \\times 6$; an electrolyte region touches only the left reservoir and terminates before reaching the right boundary; reaction active on its solid interfaces. Expect residual near $0 \\, \\mathrm{A}$.\n- Case 4 (thin path boundary case): Grid size $3 \\times 3$; a one-cell-wide electrolyte path across the middle row connects left and right reservoirs; reaction active. Expect residual near $0 \\, \\mathrm{A}$.\n\nYour program must produce a single line of output containing the global residuals for the four cases formatted as a comma-separated list enclosed in square brackets, for example, \"[r1,r2,r3,r4]\". Each list entry must be a floating-point number in $\\mathrm{A}$. No additional text should be printed.",
            "solution": "The problem posed is a well-defined boundary value problem in electrochemistry, grounded in the fundamental principle of steady-state charge conservation. It requires the solution of a linear elliptic partial differential equation, specifically the Laplace equation for the electrolyte potential $\\phi_e$, subject to a combination of Dirichlet, Neumann, and Robin boundary conditions. The problem is scientifically and mathematically sound.\n\nThe core challenge lies in satisfying global charge conservation in a domain with a complex, potentially disjointed microstructure. Electrolyte regions that are not connected to an external current reservoir (i.e., non-percolating components) cannot act as a net source or sink of charge. The problem correctly formalizes this physical constraint by requiring that the net ionic exchange with the solid phase be zero for such isolated regions. This is achieved by deactivating the electrochemical reaction on their boundaries by setting the interfacial reaction conductance $k$ to $0$. This procedure is not an arbitrary simplification but a necessary condition to ensure the problem remains physically meaningful and mathematically well-posed.\n\nIf an electrolyte component is entirely disconnected from both reservoirs and all reactive solid interfaces (either by geometry or because $k$ has been set to $0$), its potential $\\phi_e$ is defined only up to an additive constant. The problem resolves this ambiguity by stipulating that $\\phi_e = \\phi_{\\mathrm{eq}}$ in such regions, which is a physically reasonable choice that sets the potential to a reference value where no net driving force for reaction exists, thereby ensuring no artificial fluxes are introduced and the resulting linear system is not singular.\n\nThe solution will be implemented using the finite volume method (FVM) on a uniform Cartesian grid, as specified. This method is inherently conservative, making it well-suited for this problem. The overall algorithm proceeds as follows:\n\n1.  **Component Identification**: The discrete microstructure is treated as a graph where electrolyte cells are nodes and adjacent electrolyte cells share an edge. A graph traversal algorithm, such as Breadth-First Search (BFS), is employed to identify all connected components within the electrolyte phase. For each component, we determine if it percolates to the left reservoir (column $j=0$), the right reservoir (column $j=N-1$), or neither. A component is deemed \"percolating\" if it connects to at least one reservoir.\n\n2.  **Linear System Assembly**: A linear system of equations of the form $\\mathbf{A}\\boldsymbol{\\phi} = \\mathbf{b}$ is constructed, where $\\boldsymbol{\\phi}$ is the vector of unknown potentials at the center of each electrolyte cell. The matrix $\\mathbf{A}$ and vector $\\mathbf{b}$ are assembled by applying the conservation law to each electrolyte cell (control volume).\n    - For an electrolyte cell $p$ belonging to a non-percolating component, the potential is indeterminate without a reference. We enforce the condition $\\phi_p = \\phi_{\\mathrm{eq}}$ by creating a trivial equation $1 \\cdot \\phi_p = \\phi_{\\mathrm{eq}}$. This sets the corresponding row in $\\mathbf{A}$ to have a $1$ on the diagonal and $0$s elsewhere, and the corresponding entry in $\\mathbf{b}$ to $\\phi_{\\mathrm{eq}}$.\n    - For an electrolyte cell $p$ in a percolating component, the FVM equation is built by summing all currents leaving its four faces.\n        - **Conductive Flux**: The current to an adjacent electrolyte cell $q$ is $I_{p \\to q} = T (\\phi_p - \\phi_q)$, where $T = \\kappa t$ is the face transmissibility.\n        - **Reactive Flux**: The current to an adjacent solid-phase cell is $I_{p \\to \\text{solid}} = k \\, t \\, dx (\\phi_p - \\phi_{\\mathrm{eq}})$. Here, $k > 0$ since the component is percolating.\n        - **Reservoir Flux**: The current to an adjacent reservoir (e.g., left) is $I_{p \\to \\text{res}} = T (\\phi_p - \\phi_{\\mathrm{L}})$.\n        - **Neumann Boundary Flux**: The current across non-reactive (e.g., top/bottom) boundaries is zero.\n    The FVM equation for cell $p$ is $\\sum_{\\text{faces}} I_{\\text{out}} = 0$. Grouping terms with unknown potentials on the left-hand side and constant terms on the right-hand side yields the $p$-th row of the system $\\mathbf{A}\\boldsymbol{\\phi} = \\mathbf{b}$.\n\n3.  **System Solution**: The resulting linear system is large and sparse. It is efficiently solved for $\\boldsymbol{\\phi}$ using a sparse linear algebra solver.\n\n4.  **Residual Calculation**: After obtaining the potential field $\\phi_e$, the global conservation residual $\\mathcal{R}$ is calculated by summing all currents crossing the domain's external boundaries (reservoirs and reactive interfaces), using the formula provided:\n    $$\\mathcal{R} = \\sum_{\\text{reservoir faces}} T \\left(\\phi_e - \\phi_{\\mathrm{res}}\\right) + \\sum_{\\text{reactive faces}} k \\, t \\, dx \\left(\\phi_e - \\phi_{\\mathrm{eq}}\\right)$$\n    The reaction conductance $k$ in this sum is the effective value used in the simulation ($k > 0$ for percolating components, $k=0$ for isolated ones). By the principles of FVM, this sum must be numerically close to zero if the problem is correctly formulated and solved.\n\nThis systematic procedure guarantees that global charge conservation is respected for arbitrary microstructures, correctly handling the physical and mathematical complexities of isolated domains.",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Validates and solves the microstructure-resolved conduction problem.\n    \"\"\"\n    \n    # --- PHYSICAL PARAMETERS ---\n    KAPPA = 1.0  # S/m\n    K_RXN = 1.0e6  # A/(m^2 * V)\n    DX = 1.0e-5  # m\n    T_THICKNESS = 5.0e-6  # m\n    PHI_EQ = 0.0  # V\n    PHI_L = 0.1  # V\n    PHI_R = 0.0  # V\n\n    T = KAPPA * T_THICKNESS  # Transmissibility (S)\n\n    # --- TEST SUITE DEFINITION ---\n    # 1: electrolyte, 0: solid\n    case1_grid = np.zeros((8, 6), dtype=int)\n    case1_grid[3:5, :] = 1  # Percolating channel\n    case1_grid[0:2, 0:2] = 1 # Isolated pocket\n\n    case2_grid = np.zeros((5, 5), dtype=int)\n    case2_grid[2, 2] = 1  # Single isolated cell\n\n    case3_grid = np.zeros((7, 6), dtype=int)\n    case3_grid[2:5, 0:3] = 1 # Left-only percolation\n\n    case4_grid = np.zeros((3, 3), dtype=int)\n    case4_grid[1, :] = 1 # Thin percolating path\n\n    test_cases = [\n        {\"grid\": case1_grid},\n        {\"grid\": case2_grid},\n        {\"grid\": case3_grid},\n        {\"grid\": case4_grid},\n    ]\n\n    results = []\n    \n    for case_data in test_cases:\n        grid = case_data[\"grid\"]\n        M, N = grid.shape\n\n        # Step 1: Identify connected components using BFS\n        visited = np.zeros_like(grid, dtype=bool)\n        component_map = np.full_like(grid, -1, dtype=int)\n        component_props = []\n        component_id_counter = 0\n\n        for r_start in range(M):\n            for c_start in range(N):\n                if grid[r_start, c_start] == 1 and not visited[r_start, c_start]:\n                    q = deque([(r_start, c_start)])\n                    visited[r_start, c_start] = True\n                    \n                    is_left_percolating = False\n                    is_right_percolating = False\n                    \n                    while q:\n                        r, c = q.popleft()\n                        component_map[r, c] = component_id_counter\n                        if c == 0:\n                            is_left_percolating = True\n                        if c == N - 1:\n                            is_right_percolating = True\n                        \n                        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                            nr, nc = r + dr, c + dc\n                            if 0 <= nr < M and 0 <= nc < N and grid[nr, nc] == 1 and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                    \n                    is_percolating = is_left_percolating or is_right_percolating\n                    component_props.append({\"percolating\": is_percolating})\n                    component_id_counter += 1\n\n        # Map electrolyte cell coordinates to linear system indices\n        electrolyte_cells = np.argwhere(grid == 1)\n        num_vars = len(electrolyte_cells)\n        coord_to_idx = {tuple(coord): i for i, coord in enumerate(electrolyte_cells)}\n\n        if num_vars == 0:\n            results.append(0.0)\n            continue\n            \n        # Step 2: Assemble the linear system A*phi = b\n        A = lil_matrix((num_vars, num_vars), dtype=float)\n        b = np.zeros(num_vars, dtype=float)\n\n        for idx, (r, c) in enumerate(electrolyte_cells):\n            comp_id = component_map[r, c]\n            is_percolating = component_props[comp_id][\"percolating\"]\n\n            if not is_percolating:\n                # Enforce phi_e = phi_eq for non-percolating components\n                A[idx, idx] = 1.0\n                b[idx] = PHI_EQ\n                continue\n\n            # Assemble FVM equation for percolating cells\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n\n                # Neighbor is a boundary\n                if not (0 <= nr < M and 0 <= nc < N):\n                    # Left reservoir boundary\n                    if nc < 0:\n                        A[idx, idx] += T\n                        b[idx] += T * PHI_L\n                    # Right reservoir boundary\n                    elif nc >= N:\n                        A[idx, idx] += T\n                        b[idx] += T * PHI_R\n                    # Top/Bottom are Neumann (zero flux), no contribution\n                else:\n                    # Neighbor is an electrolyte cell\n                    if grid[nr, nc] == 1:\n                        neighbor_idx = coord_to_idx[(nr, nc)]\n                        A[idx, idx] += T\n                        A[idx, neighbor_idx] -= T\n                    # Neighbor is a solid (reactive boundary)\n                    else:\n                        A[idx, idx] += K_RXN * T_THICKNESS * DX\n                        b[idx] += K_RXN * T_THICKNESS * DX * PHI_EQ\n\n        # Step 3: Solve the system\n        A = A.tocsr()\n        phi_vec = spsolve(A, b)\n\n        # Create a potential grid for easier residual calculation\n        potential_grid = np.full_like(grid, np.nan, dtype=float)\n        for idx, (r, c) in enumerate(electrolyte_cells):\n            potential_grid[r, c] = phi_vec[idx]\n            \n        # Step 4: Compute global conservation residual\n        residual = 0.0\n        for r, c in electrolyte_cells:\n            phi_p = potential_grid[r, c]\n            \n            # Reservoir fluxes\n            if c == 0:\n                residual += T * (phi_p - PHI_L)\n            if c == N - 1:\n                residual += T * (phi_p - PHI_R)\n\n            # Reaction fluxes\n            k_eff = 0.0\n            comp_id = component_map[r,c]\n            if component_props[comp_id][\"percolating\"]:\n                k_eff = K_RXN\n\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < M and 0 <= nc < N and grid[nr, nc] == 0:\n                     residual += k_eff * T_THICKNESS * DX * (phi_p - PHI_EQ)\n\n        results.append(residual)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}